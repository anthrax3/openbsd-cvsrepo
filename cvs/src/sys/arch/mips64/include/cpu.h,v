head	1.121;
access;
symbols
	OPENBSD_6_2:1.121.0.2
	OPENBSD_6_2_BASE:1.121
	OPENBSD_6_1:1.114.0.4
	OPENBSD_6_1_BASE:1.114
	OPENBSD_6_0:1.110.0.2
	OPENBSD_6_0_BASE:1.110
	OPENBSD_5_9:1.108.0.2
	OPENBSD_5_9_BASE:1.108
	OPENBSD_5_8:1.105.0.4
	OPENBSD_5_8_BASE:1.105
	OPENBSD_5_7:1.104.0.2
	OPENBSD_5_7_BASE:1.104
	OPENBSD_5_6:1.102.0.4
	OPENBSD_5_6_BASE:1.102
	OPENBSD_5_5:1.95.0.4
	OPENBSD_5_5_BASE:1.95
	OPENBSD_5_4:1.94.0.2
	OPENBSD_5_4_BASE:1.94
	OPENBSD_5_3:1.93.0.2
	OPENBSD_5_3_BASE:1.93
	OPENBSD_5_2:1.83.0.2
	OPENBSD_5_2_BASE:1.83
	OPENBSD_5_1_BASE:1.72
	OPENBSD_5_1:1.72.0.4
	OPENBSD_5_0:1.72.0.2
	OPENBSD_5_0_BASE:1.72
	OPENBSD_4_9:1.69.0.2
	OPENBSD_4_9_BASE:1.69
	OPENBSD_4_8:1.58.0.2
	OPENBSD_4_8_BASE:1.58
	OPENBSD_4_7:1.57.0.2
	OPENBSD_4_7_BASE:1.57
	OPENBSD_4_6:1.33.0.4
	OPENBSD_4_6_BASE:1.33
	OPENBSD_4_5:1.29.0.2
	OPENBSD_4_5_BASE:1.29
	OPENBSD_4_4:1.25.0.2
	OPENBSD_4_4_BASE:1.25
	OPENBSD_4_3:1.22.0.2
	OPENBSD_4_3_BASE:1.22
	OPENBSD_4_2:1.20.0.2
	OPENBSD_4_2_BASE:1.20
	OPENBSD_4_1:1.14.0.2
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.12.0.4
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.12.0.2
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.11.0.2
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.10.0.2
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.5.0.2
	OPENBSD_3_6_BASE:1.5;
locks; strict;
comment	@ * @;


1.121
date	2017.09.02.15.56.29;	author visa;	state Exp;
branches;
next	1.120;
commitid	1y6OLI6UaecTzk2S;

1.120
date	2017.07.30.16.05.24;	author visa;	state Exp;
branches;
next	1.119;
commitid	OXR2nDTbL2KN6sIb;

1.119
date	2017.07.12.06.26.33;	author natano;	state Exp;
branches;
next	1.118;
commitid	Jb2yji2oX9woPvMw;

1.118
date	2017.06.11.03.35.30;	author visa;	state Exp;
branches;
next	1.117;
commitid	xcjj4iIMUAMBmIOZ;

1.117
date	2017.05.24.13.33.00;	author visa;	state Exp;
branches;
next	1.116;
commitid	NXlLAw4A7gJnttTv;

1.116
date	2017.04.20.15.42.26;	author visa;	state Exp;
branches;
next	1.115;
commitid	pxUSNsLcOM556nqP;

1.115
date	2017.04.07.14.17.38;	author visa;	state Exp;
branches;
next	1.114;
commitid	dAsyyRsPzHFJUVuw;

1.114
date	2017.03.02.10.38.10;	author natano;	state Exp;
branches;
next	1.113;
commitid	EeVoCYFCx2tYicZQ;

1.113
date	2016.12.17.11.51.01;	author visa;	state Exp;
branches;
next	1.112;
commitid	DpBtOVzHHvh4mGBa;

1.112
date	2016.12.16.12.01.19;	author fcambus;	state Exp;
branches;
next	1.111;
commitid	xLXMXiIz2IQcDoTA;

1.111
date	2016.08.14.08.23.52;	author visa;	state Exp;
branches;
next	1.110;
commitid	at8t1tG4p7ou4Cj7;

1.110
date	2016.03.06.19.42.27;	author mpi;	state Exp;
branches;
next	1.109;
commitid	cyYKarj4qRTft4gD;

1.109
date	2016.03.01.19.17.37;	author mmcc;	state Exp;
branches;
next	1.108;
commitid	X6zJ1dl85dc0hfhR;

1.108
date	2016.01.05.05.27.54;	author visa;	state Exp;
branches;
next	1.107;
commitid	916i76I5mjNtTg33;

1.107
date	2015.12.25.08.34.50;	author visa;	state Exp;
branches;
next	1.106;
commitid	mGLOAekfSVArdeBr;

1.106
date	2015.09.23.21.18.38;	author miod;	state Exp;
branches;
next	1.105;
commitid	XwuEAWkPhrpiobHq;

1.105
date	2015.07.02.01.33.59;	author dlg;	state Exp;
branches;
next	1.104;
commitid	HBmwORlhlW47BLMN;

1.104
date	2015.02.11.07.05.39;	author dlg;	state Exp;
branches;
next	1.103;
commitid	JTpbkhDknrIuy9pn;

1.103
date	2014.08.14.17.55.28;	author tobias;	state Exp;
branches;
next	1.102;
commitid	U10H0ss9SRjFygPh;

1.102
date	2014.07.11.10.53.07;	author uebayasi;	state Exp;
branches;
next	1.101;
commitid	CaCLs5fTSVpJlqFi;

1.101
date	2014.04.04.20.52.05;	author miod;	state Exp;
branches;
next	1.100;

1.100
date	2014.03.31.20.21.19;	author miod;	state Exp;
branches;
next	1.99;

1.99
date	2014.03.29.18.09.30;	author guenther;	state Exp;
branches;
next	1.98;

1.98
date	2014.03.22.00.01.04;	author miod;	state Exp;
branches;
next	1.97;

1.97
date	2014.03.21.23.05.41;	author miod;	state Exp;
branches;
next	1.96;

1.96
date	2014.03.09.10.12.17;	author miod;	state Exp;
branches;
next	1.95;

1.95
date	2013.12.19.09.37.13;	author jasper;	state Exp;
branches;
next	1.94;

1.94
date	2013.03.12.09.37.16;	author mpi;	state Exp;
branches;
next	1.93;

1.93
date	2013.02.12.08.06.22;	author mpi;	state Exp;
branches;
next	1.92;

1.92
date	2013.02.11.17.05.25;	author mpi;	state Exp;
branches;
next	1.91;

1.91
date	2012.12.02.07.03.31;	author guenther;	state Exp;
branches;
next	1.90;

1.90
date	2012.10.03.11.18.23;	author miod;	state Exp;
branches;
next	1.89;

1.89
date	2012.09.29.21.37.03;	author miod;	state Exp;
branches;
next	1.88;

1.88
date	2012.09.29.19.42.30;	author miod;	state Exp;
branches;
next	1.87;

1.87
date	2012.09.29.19.24.31;	author miod;	state Exp;
branches;
next	1.86;

1.86
date	2012.09.29.19.13.13;	author miod;	state Exp;
branches;
next	1.85;

1.85
date	2012.09.29.19.11.08;	author miod;	state Exp;
branches;
next	1.84;

1.84
date	2012.09.29.18.54.38;	author miod;	state Exp;
branches;
next	1.83;

1.83
date	2012.07.14.19.50.11;	author miod;	state Exp;
branches;
next	1.82;

1.82
date	2012.06.24.16.26.02;	author miod;	state Exp;
branches;
next	1.81;

1.81
date	2012.05.27.19.13.02;	author miod;	state Exp;
branches;
next	1.80;

1.80
date	2012.04.19.18.15.08;	author miod;	state Exp;
branches;
next	1.79;

1.79
date	2012.04.06.20.11.18;	author miod;	state Exp;
branches;
next	1.78;

1.78
date	2012.03.28.20.44.23;	author miod;	state Exp;
branches;
next	1.77;

1.77
date	2012.03.25.13.52.52;	author miod;	state Exp;
branches;
next	1.76;

1.76
date	2012.03.24.20.10.08;	author miod;	state Exp;
branches;
next	1.75;

1.75
date	2012.03.24.20.06.02;	author miod;	state Exp;
branches;
next	1.74;

1.74
date	2012.03.19.19.16.06;	author miod;	state Exp;
branches;
next	1.73;

1.73
date	2012.03.15.18.57.22;	author miod;	state Exp;
branches;
next	1.72;

1.72
date	2011.06.24.19.47.48;	author naddy;	state Exp;
branches;
next	1.71;

1.71
date	2011.03.31.20.37.44;	author miod;	state Exp;
branches;
next	1.70;

1.70
date	2011.03.23.16.54.36;	author pirofti;	state Exp;
branches;
next	1.69;

1.69
date	2010.11.24.21.16.26;	author miod;	state Exp;
branches;
next	1.68;

1.68
date	2010.10.24.15.40.03;	author miod;	state Exp;
branches;
next	1.67;

1.67
date	2010.10.02.20.49.22;	author syuu;	state Exp;
branches;
next	1.66;

1.66
date	2010.09.28.20.27.55;	author miod;	state Exp;
branches;
next	1.65;

1.65
date	2010.09.21.20.29.17;	author miod;	state Exp;
branches;
next	1.64;

1.64
date	2010.09.20.12.10.26;	author syuu;	state Exp;
branches;
next	1.63;

1.63
date	2010.09.17.00.35.51;	author miod;	state Exp;
branches;
next	1.62;

1.62
date	2010.09.13.21.59.07;	author syuu;	state Exp;
branches;
next	1.61;

1.61
date	2010.09.12.18.30.19;	author miod;	state Exp;
branches;
next	1.60;

1.60
date	2010.09.11.11.29.49;	author syuu;	state Exp;
branches;
next	1.59;

1.59
date	2010.08.30.08.52.10;	author syuu;	state Exp;
branches;
next	1.58;

1.58
date	2010.04.28.16.20.28;	author syuu;	state Exp;
branches;
next	1.57;

1.57
date	2010.02.28.18.01.36;	author miod;	state Exp;
branches;
next	1.56;

1.56
date	2010.02.28.17.23.23;	author miod;	state Exp;
branches;
next	1.55;

1.55
date	2010.01.18.16.59.22;	author miod;	state Exp;
branches;
next	1.54;

1.54
date	2010.01.09.23.43.41;	author miod;	state Exp;
branches;
next	1.53;

1.53
date	2010.01.09.23.34.29;	author miod;	state Exp;
branches;
next	1.52;

1.52
date	2010.01.09.20.33.16;	author miod;	state Exp;
branches;
next	1.51;

1.51
date	2010.01.08.01.35.52;	author syuu;	state Exp;
branches;
next	1.50;

1.50
date	2009.12.30.01.17.59;	author syuu;	state Exp;
branches;
next	1.49;

1.49
date	2009.12.28.06.55.27;	author syuu;	state Exp;
branches;
next	1.48;

1.48
date	2009.12.25.21.02.13;	author miod;	state Exp;
branches;
next	1.47;

1.47
date	2009.12.07.19.05.57;	author miod;	state Exp;
branches;
next	1.46;

1.46
date	2009.11.25.17.39.51;	author syuu;	state Exp;
branches;
next	1.45;

1.45
date	2009.11.24.22.46.59;	author syuu;	state Exp;
branches;
next	1.44;

1.44
date	2009.11.22.18.33.48;	author syuu;	state Exp;
branches;
next	1.43;

1.43
date	2009.11.19.20.16.26;	author miod;	state Exp;
branches;
next	1.42;

1.42
date	2009.10.30.08.13.57;	author syuu;	state Exp;
branches;
next	1.41;

1.41
date	2009.10.22.22.08.52;	author miod;	state Exp;
branches;
next	1.40;

1.40
date	2009.10.22.20.59.22;	author miod;	state Exp;
branches;
next	1.39;

1.39
date	2009.10.22.20.05.26;	author miod;	state Exp;
branches;
next	1.38;

1.38
date	2009.10.07.08.35.47;	author syuu;	state Exp;
branches;
next	1.37;

1.37
date	2009.09.30.06.22.00;	author syuu;	state Exp;
branches;
next	1.36;

1.36
date	2009.09.15.04.54.31;	author syuu;	state Exp;
branches;
next	1.35;

1.35
date	2009.08.06.21.54.27;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2009.08.06.21.11.38;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2009.06.10.18.05.30;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2009.06.02.17.55.37;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2009.05.22.20.37.53;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2009.03.26.17.24.33;	author oga;	state Exp;
branches;
next	1.29;

1.29
date	2008.10.15.23.23.49;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2008.10.10.08.36.28;	author art;	state Exp;
branches;
next	1.27;

1.27
date	2008.10.10.08.05.45;	author art;	state Exp;
branches;
next	1.26;

1.26
date	2008.10.09.08.43.43;	author art;	state Exp;
branches;
next	1.25;

1.25
date	2008.07.18.23.43.31;	author art;	state Exp;
branches;
next	1.24;

1.24
date	2008.04.07.22.37.16;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2008.04.07.22.29.16;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2007.12.18.08.29.02;	author jasper;	state Exp;
branches;
next	1.21;

1.21
date	2007.11.25.16.40.04;	author jmc;	state Exp;
branches;
next	1.20;

1.20
date	2007.07.18.20.03.50;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2007.06.18.20.25.53;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2007.05.07.18.42.12;	author kettenis;	state Exp;
branches;
next	1.17;

1.17
date	2007.05.03.19.34.00;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2007.04.10.21.44.56;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2007.03.15.10.22.29;	author art;	state Exp;
branches;
next	1.14;

1.14
date	2006.12.24.20.30.35;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2006.11.29.12.26.13;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2006.01.02.18.09.25;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2005.08.07.07.29.44;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2004.11.11.16.14.22;	author pefo;	state Exp;
branches;
next	1.9;

1.9
date	2004.10.20.12.49.15;	author pefo;	state Exp;
branches;
next	1.8;

1.8
date	2004.09.27.19.20.49;	author pefo;	state Exp;
branches;
next	1.7;

1.7
date	2004.09.21.05.51.13;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2004.09.20.10.29.57;	author pefo;	state Exp;
branches;
next	1.5;

1.5
date	2004.09.09.22.21.41;	author pefo;	state Exp;
branches;
next	1.4;

1.4
date	2004.08.15.12.07.28;	author pefo;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.10.20.28.13;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2004.08.09.14.57.26;	author pefo;	state Exp;
branches;
next	1.1;

1.1
date	2004.08.06.20.56.01;	author pefo;	state Exp;
branches;
next	;


desc
@@


1.121
log
@Let the kernel utilize the FPU if one is available, even when the
FPUEMUL option is enabled. This benefits OCTEON III systems which can
run floating-point operations natively.

Feedback from and OK miod@@; he also helped with testing.

Tested on octeon without FPU (CN5020, CN6120) and with FPU (CN7130),
as well as on sgi/IP27 (MP R16000), sgi/IP32 (R5000), and
loongson (3A1000).
@
text
@/*	$OpenBSD: cpu.h,v 1.120 2017/07/30 16:05:24 visa Exp $	*/

/*-
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Ralph Campbell and Rick Macklem.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	Copyright (C) 1989 Digital Equipment Corporation.
 *	Permission to use, copy, modify, and distribute this software and
 *	its documentation for any purpose and without fee is hereby granted,
 *	provided that the above copyright notice appears in all copies.
 *	Digital Equipment Corporation makes no representations about the
 *	suitability of this software for any purpose.  It is provided "as is"
 *	without express or implied warranty.
 *
 *	from: @@(#)cpu.h	8.4 (Berkeley) 1/4/94
 */

#ifndef _MIPS64_CPU_H_
#define	_MIPS64_CPU_H_

#ifndef _LOCORE

/*
 * MIPS32-style segment definitions.
 * They only cover the first 512MB of physical addresses.
 */
#define	CKSEG0_BASE		0xffffffff80000000UL
#define	CKSEG1_BASE		0xffffffffa0000000UL
#define	CKSSEG_BASE		0xffffffffc0000000UL
#define	CKSEG3_BASE		0xffffffffe0000000UL
#define	CKSEG_SIZE		0x0000000020000000UL

#define	CKSEG0_TO_PHYS(x)	((u_long)(x) & (CKSEG_SIZE - 1))
#define	CKSEG1_TO_PHYS(x)	((u_long)(x) & (CKSEG_SIZE - 1))
#define	PHYS_TO_CKSEG0(x)	((u_long)(x) | CKSEG0_BASE)
#define	PHYS_TO_CKSEG1(x)	((u_long)(x) | CKSEG1_BASE)

/*
 * MIPS64-style segment definitions.
 * These allow for 36 bits of addressable physical memory, thus 64GB.
 */

/*
 * Cache Coherency Attributes.
 */
/* r8k only */
#define	CCA_NC_COPROCESSOR	0UL	/* uncached, coprocessor ordered */
/* common to r4, r5k, r8k and r1xk */
#define	CCA_NC			2UL	/* uncached, write-around */
#define	CCA_NONCOHERENT		3UL	/* cached, non-coherent, write-back */
/* r8k, r1xk only */
#define	CCA_COHERENT_EXCL	4UL	/* cached, coherent, exclusive */
#define	CCA_COHERENT_EXCLWRITE	5UL	/* cached, coherent, exclusive write */
/* r4k only */
#define	CCA_COHERENT_UPDWRITE	6UL	/* cached, coherent, update on write */
/* r1xk only */
#define	CCA_NC_ACCELERATED	7UL	/* uncached accelerated */

#ifdef TGT_COHERENT
#define	CCA_CACHED		CCA_COHERENT_EXCLWRITE
#else
#define	CCA_CACHED		CCA_NONCOHERENT
#endif

/*
 * Uncached spaces.
 * R1x000 processors use bits 58:57 of uncached virtual addresses (CCA_NC)
 * to select different spaces. Unfortunately, other processors need these
 * bits to be zero, so uncached address have to be decided at runtime.
 */
#define	SP_HUB			0UL	/* Hub space */
#define	SP_IO			1UL	/* I/O space */
#define	SP_SPECIAL		2UL	/* Memory Special space */
#define	SP_NC			3UL	/* Memory Uncached space */

#define	XKSSSEG_BASE		0x4000000000000000UL
#define	XKPHYS_BASE		0x8000000000000000UL
#define	XKSSEG_BASE		0xc000000000000000UL

#define	XKPHYS_TO_PHYS(x)	((paddr_t)(x) & 0x0000000fffffffffUL)
#define	PHYS_TO_XKPHYS(x,c)	((paddr_t)(x) | XKPHYS_BASE | ((c) << 59))
#define	PHYS_TO_XKPHYS_UNCACHED(x,s) \
	(PHYS_TO_XKPHYS(x, CCA_NC) | ((s) << 57))
#define	IS_XKPHYS(va)		(((va) >> 62) == 2)
#define	XKPHYS_TO_CCA(x)	(((x) >> 59) & 0x07)
#define	XKPHYS_TO_SP(x)		(((x) >> 57) & 0x03)

#endif	/* _LOCORE */

/*
 * Exported definitions unique to mips cpu support.
 */

#if defined(_KERNEL) && !defined(_LOCORE)

#include <sys/device.h>
#include <machine/intr.h>
#include <sys/sched.h>

struct cpu_hwinfo {
	uint32_t	c0prid;
	uint32_t	c1prid;
	uint32_t	clock;	/* Hz */
	uint32_t	tlbsize;
	uint		type;
	uint32_t	l2size;
};

/*
 * Cache memory configuration. One struct per cache.
 */
struct cache_info {
	uint		size;		/* total cache size */
	uint		linesize;	/* line size */
	uint		setsize;	/* set size */
	uint		sets;		/* number of sets */
};

struct cpu_info {
	struct device	*ci_dev;	/* our device */
	struct cpu_info	*ci_self;	/* pointer to this structure */
	struct cpu_info	*ci_next;	/* next cpu */
	struct proc	*ci_curproc;
	struct user	*ci_curprocpaddr;
	struct proc	*ci_fpuproc;	/* pointer to last proc to use FP */
	uint32_t	 ci_delayconst;
	struct cpu_hwinfo
			ci_hw;

#if defined(MULTIPROCESSOR)
	struct srp_hazard ci_srp_hazards[SRP_HAZARD_NUM];
#endif

	/* cache information and pending flush state */
	uint		ci_cacheconfiguration;
	uint64_t	ci_cachepending_l1i;
	struct cache_info
			ci_l1inst,
			ci_l1data,
			ci_l2,
			ci_l3;

	/* function pointers for the cache handling routines */
	void		(*ci_SyncCache)(struct cpu_info *);
	void		(*ci_InvalidateICache)(struct cpu_info *, vaddr_t,
			    size_t);
	void		(*ci_InvalidateICachePage)(struct cpu_info *, vaddr_t);
	void		(*ci_SyncICache)(struct cpu_info *);
	void		(*ci_SyncDCachePage)(struct cpu_info *, vaddr_t,
			    paddr_t);
	void		(*ci_HitSyncDCachePage)(struct cpu_info *, vaddr_t,
			    paddr_t);
	void		(*ci_HitSyncDCache)(struct cpu_info *, vaddr_t, size_t);
	void		(*ci_HitInvalidateDCache)(struct cpu_info *, vaddr_t,
			    size_t);
	void		(*ci_IOSyncDCache)(struct cpu_info *, vaddr_t, size_t,
			    int);

	struct schedstate_percpu
			ci_schedstate;
	int		ci_want_resched;	/* need_resched() invoked */
	cpuid_t		ci_cpuid;		/* our CPU ID */
	uint32_t	ci_randseed;		/* per cpu random seed */
	int		ci_ipl;			/* software IPL */
	uint32_t	ci_softpending;		/* pending soft interrupts */
	int		ci_clock_started;
	u_int32_t	ci_cpu_counter_last;	/* last compare value loaded */
	u_int32_t	ci_cpu_counter_interval; /* # of counter ticks/tick */

	u_int32_t	ci_pendingticks;

#ifdef TGT_ORIGIN
	u_int16_t	ci_nasid;
	u_int16_t	ci_slice;
#endif

	struct pmap	*ci_curpmap;
	uint		ci_intrdepth;		/* interrupt depth */
#ifdef MULTIPROCESSOR
	u_long		ci_flags;		/* flags; see below */
	struct intrhand	ci_ipiih;
#endif
	volatile int    ci_ddb;
#define	CI_DDB_RUNNING		0
#define	CI_DDB_SHOULDSTOP	1
#define	CI_DDB_STOPPED		2
#define	CI_DDB_ENTERDDB		3
#define	CI_DDB_INDDB		4

#ifdef DIAGNOSTIC
	int	ci_mutex_level;
#endif
#ifdef GPROF
	struct gmonparam *ci_gmon;
#endif
};

#define	CPUF_PRIMARY	0x01		/* CPU is primary CPU */
#define	CPUF_PRESENT	0x02		/* CPU is present */
#define	CPUF_RUNNING	0x04		/* CPU is running */

extern struct cpu_info cpu_info_primary;
extern struct cpu_info *cpu_info_list;
#define CPU_INFO_ITERATOR		int
#define	CPU_INFO_FOREACH(cii, ci)	for (cii = 0, ci = cpu_info_list; \
					    ci != NULL; ci = ci->ci_next)

#define CPU_INFO_UNIT(ci)               ((ci)->ci_dev ? (ci)->ci_dev->dv_unit : 0)

extern void (*cpu_idle_cycle_func)(void);
#define cpu_idle_cycle()		(*cpu_idle_cycle_func)()

#ifdef MULTIPROCESSOR
#define getcurcpu()			hw_getcurcpu()
#define setcurcpu(ci)			hw_setcurcpu(ci)
extern struct cpu_info *get_cpu_info(int);
#define curcpu() getcurcpu()
#define	CPU_IS_PRIMARY(ci)		((ci)->ci_flags & CPUF_PRIMARY)
#define cpu_number()			(curcpu()->ci_cpuid)

extern struct cpuset cpus_running;
void cpu_unidle(struct cpu_info *);
void cpu_boot_secondary_processors(void);
#define cpu_boot_secondary(ci)          hw_cpu_boot_secondary(ci)
#define cpu_hatch(ci)                   hw_cpu_hatch(ci)

vaddr_t alloc_contiguous_pages(size_t);

#define MIPS64_IPI_NOP		0x00000001
#define MIPS64_IPI_RENDEZVOUS	0x00000002
#define MIPS64_IPI_DDB		0x00000004
#define MIPS64_NIPIS		3	/* must not exceed 32 */

void	mips64_ipi_init(void);
void	mips64_send_ipi(unsigned int, unsigned int);
void	smp_rendezvous_cpus(unsigned long, void (*)(void *), void *arg);

#include <sys/mplock.h>
#else
#define MAXCPUS				1
#define curcpu()			(&cpu_info_primary)
#define	CPU_IS_PRIMARY(ci)		1
#define cpu_number()			0
#define cpu_unidle(ci)
#define get_cpu_info(i)			(&cpu_info_primary)
#endif

#define CPU_BUSY_CYCLE()	do {} while (0)

extern void (*md_startclock)(struct cpu_info *);
void	cp0_calibrate(struct cpu_info *);

#include <machine/frame.h>

/*
 * Arguments to hardclock encapsulate the previous machine state in
 * an opaque clockframe.
 */
#define	clockframe trapframe	/* Use normal trap frame */

#define	SR_KSU_USER		0x00000010
#define	CLKF_USERMODE(framep)	((framep)->sr & SR_KSU_USER)
#define	CLKF_PC(framep)		((framep)->pc)
#define	CLKF_INTR(framep)	(curcpu()->ci_intrdepth > 1)	/* XXX */

/*
 * This is used during profiling to integrate system time.
 */
#define	PROC_PC(p)	((p)->p_md.md_regs->pc)
#define	PROC_STACK(p)	((p)->p_md.md_regs->sp)

/*
 * Preempt the current process if in interrupt from user mode,
 * or after the current trap/syscall if in system mode.
 */
#define	need_resched(ci) \
	do { \
		(ci)->ci_want_resched = 1; \
		if ((ci)->ci_curproc != NULL) \
			aston((ci)->ci_curproc); \
	} while(0)
#define	clear_resched(ci) 	(ci)->ci_want_resched = 0

/*
 * Give a profiling tick to the current process when the user profiling
 * buffer pages are invalid.  On MIPS designs, request an ast to send us
 * through trap, marking the proc as needing a profiling tick.
 */
#define	need_proftick(p)	aston(p)

/*
 * Notify the current process (p) that it has a signal pending,
 * process as soon as possible.
 */
#ifdef MULTIPROCESSOR
#define	signotify(p)		(aston(p), cpu_unidle((p)->p_cpu))
#else
#define	signotify(p)		aston(p)
#endif

#define	aston(p)		((p)->p_md.md_astpending = 1)

#ifdef CPU_R8000
#define	mips_sync()		__asm__ volatile ("lw $0, 0(%0)" :: \
				    "r" (PHYS_TO_XKPHYS(0, CCA_NC)) : "memory")
#else
#define	mips_sync()		__asm__ volatile ("sync" ::: "memory")
#endif

#endif /* _KERNEL && !_LOCORE */

#ifdef _KERNEL
/*
 * Values for the code field in a break instruction.
 */
#define	BREAK_INSTR		0x0000000d
#define	BREAK_VAL_MASK		0x03ff0000
#define	BREAK_VAL_SHIFT		16
#define	BREAK_KDB_VAL		512
#define	BREAK_SSTEP_VAL		513
#define	BREAK_BRKPT_VAL		514
#define	BREAK_SOVER_VAL		515
#define	BREAK_DDB_VAL		516
#define	BREAK_FPUEMUL_VAL	517
#define	BREAK_KDB	(BREAK_INSTR | (BREAK_KDB_VAL << BREAK_VAL_SHIFT))
#define	BREAK_SSTEP	(BREAK_INSTR | (BREAK_SSTEP_VAL << BREAK_VAL_SHIFT))
#define	BREAK_BRKPT	(BREAK_INSTR | (BREAK_BRKPT_VAL << BREAK_VAL_SHIFT))
#define	BREAK_SOVER	(BREAK_INSTR | (BREAK_SOVER_VAL << BREAK_VAL_SHIFT))
#define	BREAK_DDB	(BREAK_INSTR | (BREAK_DDB_VAL << BREAK_VAL_SHIFT))
#define	BREAK_FPUEMUL	(BREAK_INSTR | (BREAK_FPUEMUL_VAL << BREAK_VAL_SHIFT))

#endif /* _KERNEL */

/*
 * CTL_MACHDEP definitions.
 */
#define	CPU_ALLOWAPERTURE	1	/* allow mmap of /dev/xf86 */
		/*		2	   formerly: keyboard reset */
		/*		3	   formerly: CPU_LIDSUSPEND */
#define CPU_LIDACTION		4	/* action caused by lid close */
#define	CPU_MAXID		5	/* number of valid machdep ids */

#define	CTL_MACHDEP_NAMES {			\
	{ 0, 0 },				\
	{ "allowaperture", CTLTYPE_INT },	\
	{ 0, 0 },				\
	{ 0, 0 },				\
	{ "lidaction", CTLTYPE_INT },		\
}

/*
 * MIPS CPU types (cp_imp).
 */
#define	MIPS_R2000	0x01	/* MIPS R2000 CPU		ISA I   */
#define	MIPS_R3000	0x02	/* MIPS R3000 CPU		ISA I   */
#define	MIPS_R6000	0x03	/* MIPS R6000 CPU		ISA II	*/
#define	MIPS_R4000	0x04	/* MIPS R4000/4400 CPU		ISA III	*/
#define	MIPS_R3LSI	0x05	/* LSI Logic R3000 derivate	ISA I	*/
#define	MIPS_R6000A	0x06	/* MIPS R6000A CPU		ISA II	*/
#define	MIPS_CN50XX	0x06	/* Cavium OCTEON CN50xx		MIPS64R2*/
#define	MIPS_R3IDT	0x07	/* IDT R3000 derivate		ISA I	*/
#define	MIPS_R10000	0x09	/* MIPS R10000/T5 CPU		ISA IV  */
#define	MIPS_R4200	0x0a	/* MIPS R4200 CPU (ICE)		ISA III */
#define	MIPS_R4300	0x0b	/* NEC VR4300 CPU		ISA III */
#define	MIPS_R4100	0x0c	/* NEC VR41xx CPU MIPS-16	ISA III */
#define	MIPS_R12000	0x0e	/* MIPS R12000			ISA IV  */
#define	MIPS_R14000	0x0f	/* MIPS R14000			ISA IV  */
#define	MIPS_R8000	0x10	/* MIPS R8000 Blackbird/TFP	ISA IV  */
#define	MIPS_R4600	0x20	/* PMCS R4600 Orion		ISA III */
#define	MIPS_R4700	0x21	/* PMCS R4700 Orion		ISA III */
#define	MIPS_R3TOSH	0x22	/* Toshiba R3000 based CPU	ISA I	*/
#define	MIPS_R5000	0x23	/* MIPS R5000 CPU		ISA IV  */
#define	MIPS_RM7000	0x27	/* PMCS RM7000 CPU		ISA IV  */
#define	MIPS_RM52X0	0x28	/* PMCS RM52X0 CPU		ISA IV  */
#define	MIPS_RM9000	0x34	/* PMCS RM9000 CPU		ISA IV  */
#define	MIPS_LOONGSON	0x42	/* STC LoongSon CPU		ISA III */
#define	MIPS_VR5400	0x54	/* NEC Vr5400 CPU		ISA IV+ */
#define	MIPS_LOONGSON2	0x63	/* STC LoongSon2/3 CPU		ISA III+ */
#define	MIPS_CN61XX	0x93	/* Cavium OCTEON II CN6[01]xx	MIPS64R2 */
#define	MIPS_CN71XX	0x96	/* Cavium OCTEON III CN7[01]xx	MIPS64R2 */
#define	MIPS_CN73XX	0x97	/* Cavium OCTEON III CN7[23]xx	MIPS64R2 */

/*
 * MIPS FPU types. Only soft, rest is the same as cpu type.
 */
#define	MIPS_SOFT	0x00	/* Software emulation		ISA I   */


#if defined(_KERNEL) && !defined(_LOCORE)

extern register_t protosr;
extern int cpu_has_userlocal;

#ifdef FPUEMUL
#define	CPU_HAS_FPU(ci)	((ci)->ci_hw.c1prid != 0)
#else
#define	CPU_HAS_FPU(ci)	1
#endif

struct exec_package;
struct user;

void	tlb_asid_wrap(struct cpu_info *);
void	tlb_flush(int);
void	tlb_flush_addr(vaddr_t);
void	tlb_init(unsigned int);
int64_t	tlb_probe(vaddr_t);
void	tlb_set_gbase(vaddr_t, vsize_t);
void	tlb_set_page_mask(uint32_t);
void	tlb_set_pid(u_int);
void	tlb_set_wired(uint32_t);
int	tlb_update(vaddr_t, register_t);
void	tlb_update_indexed(vaddr_t, register_t, register_t, uint);

void	build_trampoline(vaddr_t, vaddr_t);
void	cpu_switchto_asm(struct proc *, struct proc *);
int	exec_md_map(struct proc *, struct exec_package *);
void	savectx(struct user *, int);

void	enable_fpu(struct proc *);
void	save_fpu(void);
int	fpe_branch_emulate(struct proc *, struct trapframe *, uint32_t,
	    vaddr_t);
void	MipsSaveCurFPState(struct proc *);
void	MipsSaveCurFPState16(struct proc *);
void	MipsSwitchFPState(struct proc *, struct trapframe *);
void	MipsSwitchFPState16(struct proc *, struct trapframe *);

int	guarded_read_1(paddr_t, uint8_t *);
int	guarded_read_2(paddr_t, uint16_t *);
int	guarded_read_4(paddr_t, uint32_t *);
int	guarded_write_4(paddr_t, uint32_t);

void	MipsFPTrap(struct trapframe *);
register_t MipsEmulateBranch(struct trapframe *, vaddr_t, uint32_t, uint32_t);

int	classify_insn(uint32_t);
#define	INSNCLASS_NEUTRAL	0
#define	INSNCLASS_CALL		1
#define	INSNCLASS_BRANCH	2

/*
 * R4000 end-of-page errata workaround routines
 */

extern int r4000_errata;
u_int	eop_page_check(paddr_t);
void	eop_tlb_flush_addr(struct pmap *, vaddr_t, u_long);
int	eop_tlb_miss_handler(struct trapframe *, struct cpu_info *,
	    struct proc *);
void	eop_cleanup(struct trapframe *, struct proc *);

/*
 * Low level access routines to CPU registers
 */

void	setsoftintr0(void);
void	clearsoftintr0(void);
void	setsoftintr1(void);
void	clearsoftintr1(void);
register_t enableintr(void);
register_t disableintr(void);
register_t getsr(void);
register_t setsr(register_t);

u_int	cp0_get_count(void);
register_t cp0_get_config(void);
uint32_t cp0_get_config_1(void);
uint32_t cp0_get_config_2(void);
uint32_t cp0_get_config_3(void);
uint32_t cp0_get_config_4(void);
uint32_t cp0_get_pagegrain(void);
register_t cp0_get_prid(void);
void	cp0_reset_cause(register_t);
void	cp0_set_compare(u_int);
void	cp0_set_config(register_t);
void	cp0_set_pagegrain(uint32_t);
void	cp0_set_trapbase(register_t);
u_int	cp1_get_prid(void);

static inline uint32_t
cp0_get_hwrena(void)
{
	uint32_t value;
	__asm__ volatile ("mfc0 %0, $7" : "=r" (value));
	return value;
}

static inline void
cp0_set_hwrena(uint32_t value)
{
	__asm__ volatile ("mtc0 %0, $7" : : "r" (value));
}

static inline void
cp0_set_userlocal(void *value)
{
	__asm__ volatile (
	"	.set	push\n"
	"	.set	mips64r2\n"
	"	dmtc0	%0, $4, 2\n"
	"	.set	pop\n"
	: : "r" (value));
}

/*
 * Cache routines (may be overridden)
 */

#ifndef	Mips_SyncCache
#define	Mips_SyncCache(ci) \
	((ci)->ci_SyncCache)(ci)
#endif
#ifndef	Mips_InvalidateICache
#define	Mips_InvalidateICache(ci, va, l) \
	((ci)->ci_InvalidateICache)(ci, va, l)
#endif
#ifndef	Mips_InvalidateICachePage
#define	Mips_InvalidateICachePage(ci, va) \
	((ci)->ci_InvalidateICachePage)(ci, va)
#endif
#ifndef	Mips_SyncICache
#define	Mips_SyncICache(ci) \
	((ci)->ci_SyncICache)(ci)
#endif
#ifndef	Mips_SyncDCachePage
#define	Mips_SyncDCachePage(ci, va, pa) \
	((ci)->ci_SyncDCachePage)(ci, va, pa)
#endif
#ifndef	Mips_HitSyncDCachePage
#define	Mips_HitSyncDCachePage(ci, va, pa) \
	((ci)->ci_HitSyncDCachePage)(ci, va, pa)
#endif
#ifndef	Mips_HitSyncDCache
#define	Mips_HitSyncDCache(ci, va, l) \
	((ci)->ci_HitSyncDCache)(ci, va, l)
#endif
#ifndef	Mips_HitInvalidateDCache
#define	Mips_HitInvalidateDCache(ci, va, l) \
	((ci)->ci_HitInvalidateDCache)(ci, va, l)
#endif
#ifndef	Mips_IOSyncDCache
#define	Mips_IOSyncDCache(ci, va, l, h) \
	((ci)->ci_IOSyncDCache)(ci, va, l, h)
#endif
 
#endif /* _KERNEL && !_LOCORE */
#endif /* !_MIPS64_CPU_H_ */
@


1.120
log
@Define MAXCPUS per mips64 port.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.119 2017/07/12 06:26:33 natano Exp $	*/
d420 6
@


1.119
log
@remove CPU_LIDSUSPEND/machdep.lidsuspend

"fire away!" tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.118 2017/06/11 03:35:30 visa Exp $	*/
a240 1
#define MAXCPUS				4
@


1.118
log
@Fix TLB size computation on OCTEON II and III. The CPUs have utilized
the whole TLB space even before this. However, TLB initialization on
boot and TLB flush on ASID wraparound have been incomplete. These have
caused crashes of processes.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.117 2017/05/24 13:33:00 visa Exp $	*/
d367 1
a367 1
#define	CPU_LIDSUSPEND		3	/* lid close causes a suspend */
d375 1
a375 1
	{ "lidsuspend", CTLTYPE_INT },		\
@


1.117
log
@Add an idle cycle implementation for R4600/R5000/RM7000 CPUs and their
derivatives. This lets the kernel utilize the CPUs' Standby Mode to
reduce the power consumption of an idle system.

Suggested by and input from miod@@.
He also tested this patch on an RM7000 O2.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.116 2017/04/20 15:42:26 visa Exp $	*/
d493 1
@


1.116
log
@Make TCB address available to userspace via the UserLocal register.
This lets programs get the address without a system call on OCTEON II
and later.

Add UserLocal load emulation for systems that do not implement
the RDHWR instruction or the UserLocal register.

OK guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.115 2017/04/07 14:17:38 visa Exp $	*/
d236 3
@


1.115
log
@Add prid for CN72xx/CN73xx.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.114 2017/03/02 10:38:10 natano Exp $	*/
d417 1
d498 25
@


1.114
log
@Add a new sysctl machdep.lidaction. The sysctl works as follows:

machdep.lidaction=0	# do nothing
machdep.lidaction=1	# suspend
machdep.lidaction=2	# hibernate

lidsuspend is just an alias for lidaction, so if you change one, the
other one will have the same value. The plan is to remove
machdep.lidsuspend eventually when people have upgraded their
/ets/sysctl.conf.

discussed with deraadt, who came up with the new MIB name
no objections mlarkin
ok stsp halex jcs
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.113 2016/12/17 11:51:01 visa Exp $	*/
d406 1
@


1.113
log
@Make Octeon model strings a bit more specific. While there,
add CN70xx/CN71xx.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.112 2016/12/16 12:01:19 fcambus Exp $	*/
d365 2
a366 1
#define	CPU_MAXID		4	/* number of valid machdep ids */
d373 1
@


1.112
log
@Provide the "machdep.lidsuspend" sysctl on Loongson.

OK visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.111 2016/08/14 08:23:52 visa Exp $	*/
d383 1
a383 1
#define MIPS_OCTEON	0x06	/* Cavium OCTEON		MIPS64R2*/
d402 2
a403 1
#define MIPS_OCTEON2	0x93	/* Cavium OCTEON II		MIPS64R2 */
@


1.111
log
@Utilize the TLB Execute-Inhibit bit with non-executable mappings on CPUs
that support the Execute-Inhibit exception. This makes user space W^X
effective on Octeon Plus and later Octeon versions.

Feedback from miod@@, thanks!
No objection from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.110 2016/03/06 19:42:27 mpi Exp $	*/
d364 2
a365 1
#define	CPU_MAXID		3	/* number of valid machdep ids */
d371 1
@


1.110
log
@Rename mips64's trap_frame into trapframe.

For coherency with other archs and in order to use it in MI code.

ok visa@@, tobiasu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.109 2016/03/01 19:17:37 mmcc Exp $	*/
d483 1
d488 1
@


1.109
log
@guard macro args with parens

from Michal Mazurek, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.108 2016/01/05 05:27:54 visa Exp $	*/
d284 1
a284 1
#define	clockframe trap_frame	/* Use normal trap frame */
d434 1
a434 1
int	fpe_branch_emulate(struct proc *, struct trap_frame *, uint32_t,
d438 2
a439 2
void	MipsSwitchFPState(struct proc *, struct trap_frame *);
void	MipsSwitchFPState16(struct proc *, struct trap_frame *);
d446 2
a447 2
void	MipsFPTrap(struct trap_frame *);
register_t MipsEmulateBranch(struct trap_frame *, vaddr_t, uint32_t, uint32_t);
d461 1
a461 1
int	eop_tlb_miss_handler(struct trap_frame *, struct cpu_info *,
d463 1
a463 1
void	eop_cleanup(struct trap_frame *, struct proc *);
@


1.108
log
@Some implementations of HitSyncDCache() call pmap_extract() for va->pa
conversion. Because pmap_extract() acquires the PTE mutex, a "locking
against myself" panic is triggered if the cache routine gets called in
a context where the mutex is already held.

In the pmap, all calls to HitSyncDCache() are for a whole page. Add a
new cache routine, HitSyncDCachePage(), which gets both the va and the
pa of a page. This removes the need of the va->pa conversion. The new
routine has the same signature as SyncDCachePage(), allowing reuse of
the same routine for cache implementations that do not need differences
between "Hit" and non-"Hit" routines.

With the diff, POWER Indigo2 R8000 boots multiuser again. Tested on sgi
GENERIC-IP27.MP and octeon GENERIC.MP, too.

Diff from miod@@, ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.107 2015/12/25 08:34:50 visa Exp $	*/
d321 1
a321 1
#define	signotify(p)		(aston(p), cpu_unidle(p->p_cpu))
d326 1
a326 1
#define	aston(p)		p->p_md.md_astpending = 1
@


1.107
log
@Make interrupt masking MP-aware. Linux IP27 and IP35 ports served as a
substitute for hardware documentation.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.106 2015/09/23 21:18:38 miod Exp $	*/
d178 2
d513 4
@


1.106
log
@That PICA reference ought to have been removed 20 years ago!
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.105 2015/07/02 01:33:59 dlg Exp $	*/
d196 6
@


1.105
log
@introduce srp, which according to the manpage i wrote is short for
"shared reference pointers".

srp allows concurrent access to a data structure by multiple cpus
while avoiding interlocking cpu opcodes. it manages its own reference
counts and the garbage collection of those data structure to avoid
use after frees.

internally srp is a twisted version of hazard pointers, which are
a relative of RCU.

jmatthew wrote the bulk of a hazard pointer implementation and
changed bpf to use it to allow mpsafe access to bpfilters. however,
at s2k15 we were trying to apply it to other data structures but
the memory overhead of every hazard pointer would have blown out
significantly in several uses cases. a bulk of our time at s2k15
was spent reworking hazard pointers into srp.

this diff adds the srp api and adds the necessary metadata to struct
cpuinfo on our MP architectures. srp on uniprocessor platforms has
alternate code that is optimised because it knows there'll be no
concurrent access to data by multiple cpus.

srp is made available to the system via param.h, so it should be
available everywhere in the kernel.

the docs likely need improvement cos im too close to the implementation.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.104 2015/02/11 07:05:39 dlg Exp $	*/
d303 1
a303 1
 * buffer pages are invalid.  On the PICA, request an ast to send us
@


1.104
log
@no md code wants lockmgr locks, so no md code needs to include sys/lock.h

with and ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.103 2014/08/14 17:55:28 tobias Exp $	*/
d156 4
@


1.103
log
@fixed overrid(d)en typo

millert@@ and jmc@@ agree that "overriden" is wrong
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.102 2014/07/11 10:53:07 uebayasi Exp $	*/
a123 1
#include <sys/lock.h>
@


1.102
log
@CPU_BUSY_CYCLE(): A new MI statement for busy loop power reduction

The new CPU_BUSY_CYCLE() may be put in a busy loop body so that CPU can reduce
power consumption, as Linux's cpu_relax() and FreeBSD's cpu_spinwait().  To
start minimally, use PAUSE on i386/amd64 and empty on others.  The name is
chosen following the existing cpu_idle_*() functions.  Naming and API may be
polished later.

OK kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d480 1
a480 1
 * Cache routines (may be overriden)
@


1.101
log
@Second step of the R4000 EOP errata WAR: when pmap invalidates a page which
is currently being covered by the wired TLB entries, flush them, so that,
if the process' pc is still running in a vulnerable page, the WAR will
reapply immediately and fault the next page.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.100 2014/03/31 20:21:19 miod Exp $	*/
d261 2
@


1.100
log
@Due the virtually indexed nature of the L1 instruction cache on most mips
processors, every time a new text page is mapped in a pmap, the L1 I$ is
flushed for the va spanned by this page.

Since we map pages of our binaries upon demand, as they get faulted in, but
uvm_fault() tries to map the few neighbour pages, this can end up in a
bunch of pmap_enter() calls in a row, for executable mappings. If the L1
I$ is small enough, this can cause the whole L1 I$ cache to be flushed
several times.

Change pmap_enter() to postpone these flushes by only registering the
pending flushes, and have pmap_update() perform them. The cpu-specific
cache code can then optimize this to avoid unnecessary operations.

Tested on R4000SC, R4600SC, R5000SC, RM7000, R10000 with 4KB and 16KB
page sizes (coherent and non-coherent designs), and Loongson 2F by mikeb@@ and
me. Should not affect anything on Octeon since there is no way to flush a
subset of I$ anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.99 2014/03/29 18:09:30 guenther Exp $	*/
d447 1
@


1.99
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.98 2014/03/22 00:01:04 miod Exp $	*/
d158 1
a158 1
	/* cache information */
d160 1
d171 2
d487 8
@


1.98
log
@Second draft of my attempt to workaround the infamous R4000 end-of-page errata,
affecting R4000 processors revision 2.x and below (found on most R4000 Indigo
and a few R4000 Indy).

Since this errata gets triggered by TLB misses when the code flow crosses a
page boundary, this code attempts to identify code pages prone to trigger the
errata, and force the next page to be mapped for at least as long as the
current pc lies in the troublesome page, by creating wiring extra TLB entries.
These entries get recycled in a lazy-but-aggressive-enough way, either because
of context switches, or because of further tlb exceptions reaching trap().

The errata workaround code is only compiled on R4000-capable kernels (i.e.
sgi GENERIC-IP22 and nothing else), and only enabled on affected processors
(i.e. not on R4000 revision 3, or on R4400).

There is still room for improvemnt in unlucky cases, but in this simple enough
incarnation, this allows my R4000 2.2 Indigo to finally reliably boot multiuser,
even though both /sbin/init and /bin/sh contain code pages which can trigger
the errata.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.97 2014/03/21 23:05:41 miod Exp $	*/
d313 1
a313 1
#define	mips_sync()		__asm__ __volatile__ ("lw $0, 0(%0)" :: \
d316 1
a316 1
#define	mips_sync()		__asm__ __volatile__ ("sync" ::: "memory")
@


1.97
log
@Rename db_inst_type() into classify_insn() and make that function available
outside of ddb. It will be used by regular kernel code shortly.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.96 2014/03/09 10:12:17 miod Exp $	*/
d403 1
d409 1
d437 10
@


1.96
log
@Rework the per-cpu cache information. Use a common struct to store the line
size, the number of sets, and the total size (and the set size, for convenience)
per cache (I$, D$, L2, L3).
This allows cpu.c to print the number of ways (sets) of L2 and L3 caches from
the cache information, rather than hardcoding this from the processor type.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.95 2013/12/19 09:37:13 jasper Exp $	*/
d430 5
@


1.95
log
@recognize octeon 2 cpus; as found in the lanner mr326

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.94 2013/03/12 09:37:16 mpi Exp $	*/
d137 10
d160 5
a164 10
	uint		ci_cacheways;
	uint		ci_l1instcachesize;
	uint		ci_l1instcacheline;
	uint		ci_l1instcacheset;
	uint		ci_l1datacachesize;
	uint		ci_l1datacacheline;
	uint		ci_l1datacacheset;
	uint		ci_l2size;
	uint		ci_l2line;
	uint		ci_l3size;
@


1.94
log
@Fix kernel profiling on MP systems by using per-CPU buffers and teach
kgmon(8) to deal with them, this time without public header changes.

Previously various CPUs were iterating over the same global buffer at
the same time to modify it and never ended.

This diff includes some ideas submited by Thor Simon to NetBSD via miod@@.

ok deraadt@@, mikeb@@, haesbaert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.93 2013/02/12 08:06:22 mpi Exp $	*/
d379 1
@


1.93
log
@Back out per-CPU kernel profiling, it shouldn't modify a public header
at this moment.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.92 2013/02/11 17:05:25 mpi Exp $	*/
d200 3
@


1.92
log
@Fix kernel profiling on MP systems by using per-CPU buffer. Previously
various CPUs were iterating over the same global buffer at the same
time to modify it and never ended.

This diff includes some ideas submited by Thor Simon to NetBSD via miod@@.

ok mikeb@@, haesbaert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.91 2012/12/02 07:03:31 guenther Exp $	*/
a199 3
#endif
#ifdef GPROF
	struct gmonparam *ci_gmon;
@


1.91
log
@Determine whether we're currently on the alternative signal stack
dynamically, by comparing the stack pointer against the altstack
base and size, so that you get the correct answer if you longjmp
out of the signal handler, as tested by regress/sys/kern/stackjmp/.
Also, fix alt stack handling on vax, where it was completely broken.

Testing and corrections by miod@@, krw@@, tobiasu@@, pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.90 2012/10/03 11:18:23 miod Exp $	*/
d200 3
@


1.90
log
@Split ever-growing mips <machine/cpu.h> into what 99% of the kernel needs,
which will remain in <machine/cpu.h>, and a new mips_cpu.h containing only the
goriest md details, which are only of interest to a handful set of files; this
is similar in spirit to what alpha does, but here <machine/cpu.h> does not
include the new file.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.89 2012/09/29 21:37:03 miod Exp $	*/
d271 1
@


1.89
log
@Basic R8000 processor support. R8000 processors require MMU-specific code,
exception-specific code, clock-specific code, and L1 cache-specific code. L2
cache is per-design, of which only two exist: SGI Power Indigo2 (IP26) and SGI
Power Challenge (IP21) and are not covered by this commit.

R8000 processors also are 64-bit only processors with 64-bit coprocessor 0
registers, and lack so-called ``compatibility'' memory spaces allowing 32-bit
code to run with sign-extended addresses and registers.

The intrusive changes are covered by #ifdef CPU_R8000 stanzas. However,
trap() is split into a high-level wrapper and a new function, itsa(),
responsible for the actual trap servicing (which name couldn't be helped
because I'm an incorrigible punster). While an R8000 exception may cause
(via trap() ) multiple exceptions to be serviced, non-R8000 processors will
always service one exception in trap(), but they are nevertheless affected
by this code split.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.88 2012/09/29 19:42:30 miod Exp $	*/
a116 263
#if defined(_KERNEL) || defined(_STANDALONE)

/*
 * Status register.
 */

#define	SR_COP_USABILITY	0x30000000	/* CP0 and CP1 only */
#define	SR_COP_0_BIT		0x10000000
#define	SR_COP_1_BIT		0x20000000
#define	SR_RP			0x08000000
#define	SR_FR_32		0x04000000
#define	SR_RE			0x02000000
#define	SR_DSD			0x01000000	/* Only on R12000 */
#define	SR_BOOT_EXC_VEC		0x00400000
#define	SR_TLB_SHUTDOWN		0x00200000
#define	SR_SOFT_RESET		0x00100000
#define	SR_DIAG_CH		0x00040000
#define	SR_DIAG_CE		0x00020000
#define	SR_DIAG_DE		0x00010000
#define	SR_KX			0x00000080
#define	SR_SX			0x00000040
#define	SR_UX			0x00000020
#define	SR_ERL			0x00000004
#define	SR_EXL			0x00000002
#define	SR_INT_ENAB		0x00000001

#define	SOFT_INT_MASK_0		0x00000100
#define	SOFT_INT_MASK_1		0x00000200
#define	SR_INT_MASK_0		0x00000400
#define	SR_INT_MASK_1		0x00000800
#define	SR_INT_MASK_2		0x00001000
#define	SR_INT_MASK_3		0x00002000
#define	SR_INT_MASK_4		0x00004000
#define	SR_INT_MASK_5		0x00008000

/* R8000-specific bits */
#define	SR_SERIALIZE_FPU	0x0000010000000000
#define	SR_KPGSZ_SHIFT		36
#define	SR_UPGSZ_SHIFT		32
#define	SR_PGSZ_4K		0
#define	SR_PGSZ_8K		1
#define	SR_PGSZ_16K		2
#define	SR_PGSZ_64K		3
#define	SR_PGSZ_1M		4
#define	SR_PGSZ_4M		5
#define	SR_PGSZ_16M		6
#define	SR_PGSZ_MASK		0x0f

#define	SR_INT_MASK_6		0x00010000
#define	SR_INT_MASK_7		0x00020000
#define	SR_INT_MASK_8		0x00040000

#ifdef CPU_R8000
#define	SR_XX			0x00000040
#define	SR_KSU_MASK		0x00000010
#define	SR_KSU_USER		0x00000010
#define	SR_KSU_KERNEL		0x00000000
#define	SR_INT_MASK		0x0007ff00
#else
#define	SR_XX			0x80000000
#define	SR_KSU_MASK		0x00000018
#define	SR_KSU_USER		0x00000010
#define	SR_KSU_SUPER		0x00000008
#define	SR_KSU_KERNEL		0x00000000
#define	SR_INT_MASK		0x0000ff00
#endif

/*
 * Interrupt control register in RM7000. Expansion of interrupts.
 */

#define	IC_INT_MASK		0x00003f00	/* Two msb reserved */
#define	IC_INT_MASK_6		0x00000100
#define	IC_INT_MASK_7		0x00000200
#define	IC_INT_MASK_8		0x00000400
#define	IC_INT_MASK_9		0x00000800
#define	IC_INT_TIMR		0x00001000	/* 12 Timer */
#define	IC_INT_PERF		0x00002000	/* 13 Performance counter */
#define	IC_INT_TE		0x00000080	/* Timer on INT11 */

#define	SOFT_INT_MASK		(SOFT_INT_MASK_0 | SOFT_INT_MASK_1)

/*
 * Cause register.
 */

#ifdef CPU_R8000
#define	CR_BR_DELAY		0x8000000000000000
#define	CR_EXC_CODE		0x000000f8
#define	CR_EXC_CODE_SHIFT	3
#define	CR_COP_ERR		0x10000000
#else
#define	CR_BR_DELAY		0x80000000
#define	CR_EXC_CODE		0x0000007c
#define	CR_EXC_CODE_SHIFT	2
#define	CR_COP_ERR		0x30000000
#endif
#define	CR_COP1_ERR		0x10000000
#define	CR_COP2_ERR		0x20000000
#define	CR_COP3_ERR		0x20000000
#define	CR_INT_SOFT0		0x00000100
#define	CR_INT_SOFT1		0x00000200
#define	CR_INT_0		0x00000400
#define	CR_INT_1		0x00000800
#define	CR_INT_2		0x00001000
#define	CR_INT_3		0x00002000
#define	CR_INT_4		0x00004000
#define	CR_INT_5		0x00008000
/* Following on RM7000 and R8000 */
#define	CR_INT_6		0x00010000
#define	CR_INT_7		0x00020000
#define	CR_INT_8		0x00040000
/* Following on RM7000 */
#define	CR_INT_9		0x00080000
#define	CR_INT_HARD		0x000ffc00
#define	CR_INT_TIMR		0x00100000	/* 12 Timer */
#define	CR_INT_PERF		0x00200000	/* 13 Performance counter */
/* R8000 specific */
#define	CR_FPE			0x01000000
#define	CR_VCE			0x02000000
#define	CR_BERR			0x04000000
#define	CR_NMI			0x08000000

#ifdef CPU_R8000
#define	CR_INT_MASK		0x0407ff00	/* contains CR_BERR */
#else
#define	CR_INT_MASK		0x003fff00
#endif

/*
 * Config register.
 */

#define	CFGR_CCA_MASK		0x00000007
#define	CFGR_CU			0x00000008
#define	CFGR_ICE		0x0000000200000000
#define	CFGR_SMM		0x0000000400000000

/*
 * Location of exception vectors.
 */

#ifdef CPU_R8000
#define	RESET_EXC_VEC		PHYS_TO_XKPHYS(0x1fc00000, CCA_NC)
/* all the others are relative to COP_0_TRAPBASE */
/* #define	UTLB_MISS_EXC_VEC	0x00000000 */
/* #define	KV1TLB_MISS_EXC_VEC	0x00000400 */
/* #define	KV0TLB_MISS_EXC_VEC	0x00000800 */
/* #define	GEN_EXC_VEC		0x00000c00 */
#else
#define	RESET_EXC_VEC		(CKSEG1_BASE + 0x1fc00000)
#define	TLB_MISS_EXC_VEC	(CKSEG1_BASE + 0x00000000)
#define	XTLB_MISS_EXC_VEC	(CKSEG1_BASE + 0x00000080)
#define	CACHE_ERR_EXC_VEC	(CKSEG1_BASE + 0x00000100)
#define	GEN_EXC_VEC		(CKSEG1_BASE + 0x00000180)
#endif

/*
 * Coprocessor 0 registers
 */

/* Common subset */
#define	COP_0_COUNT		$9
#define	COP_0_TLB_HI		$10
#define	COP_0_STATUS_REG	$12
#define	COP_0_CAUSE_REG		$13
#define	COP_0_EXC_PC		$14
#define	COP_0_PRID		$15
#define	COP_0_CONFIG		$16

/* R4000/5000/10000 */
#define	COP_0_TLB_INDEX		$0
#define	COP_0_TLB_RANDOM	$1
#define	COP_0_TLB_LO0		$2
#define	COP_0_TLB_LO1		$3
#define	COP_0_TLB_CONTEXT	$4
#define	COP_0_TLB_PG_MASK	$5
#define	COP_0_TLB_WIRED		$6
#define	COP_0_BAD_VADDR		$8
#define	COP_0_COMPARE		$11
#define	COP_0_LLADDR		$17
#define	COP_0_WATCH_LO		$18
#define	COP_0_WATCH_HI		$19
#define	COP_0_TLB_XCONTEXT	$20
#define	COP_0_ECC		$26
#define	COP_0_CACHE_ERR		$27
#define	COP_0_TAG_LO		$28
#define	COP_0_TAG_HI		$29
#define	COP_0_ERROR_PC		$30

/* R8000 specific */
#define	COP_0_TLB_SET		$0
#define	COP_0_TLB_LO		$2
#define	COP_0_UBASE		$4
#define	COP_0_SHIFTAMT		$5
#define	COP_0_TRAPBASE		$6
#define	COP_0_BAD_PADDR		$7
#define	COP_0_VADDR		$8
#define	COP_0_WORK0		$18
#define	COP_0_WORK1		$19
#define	COP_0_PBASE		$20
#define	COP_0_GBASE		$21
#define	COP_0_TFP_TLB_WIRED	$24
#define	COP_0_DCACHE		$28
#define	COP_0_ICACHE		$29

/* RM7000 specific */
#define	COP_0_WATCH_1		$18
#define	COP_0_WATCH_2		$19
#define	COP_0_WATCH_M		$24
#define	COP_0_PC_COUNT		$25
#define	COP_0_PC_CTRL		$22

#define	COP_0_ICR		$20	/* Use cfc0/ctc0 to access */

/* R10000 specific */
#define	COP_0_TLB_FR_MASK	$21

/* Loongson-2 specific */
#define	COP_0_DIAG		$22

/* Octeon specific */
#define COP_0_TLB_PG_GRAIN	$5, 1
#define COP_0_CVMCTL		$9, 7
#define COP_0_CVMMEMCTL		$11, 7
#define COP_0_EBASE		$15, 1

/*
 * COP_0_COUNT speed divider.
 */
#if defined(CPU_OCTEON) || defined(CPU_R8000)
#define	CP0_CYCLE_DIVIDER	1
#else
#define	CP0_CYCLE_DIVIDER	2
#endif

/*
 * Values for the code field in a break instruction.
 */
#define	BREAK_INSTR		0x0000000d
#define	BREAK_VAL_MASK		0x03ff0000
#define	BREAK_VAL_SHIFT		16
#define	BREAK_KDB_VAL		512
#define	BREAK_SSTEP_VAL		513
#define	BREAK_BRKPT_VAL		514
#define	BREAK_SOVER_VAL		515
#define	BREAK_DDB_VAL		516
#define	BREAK_FPUEMUL_VAL	517
#define	BREAK_KDB	(BREAK_INSTR | (BREAK_KDB_VAL << BREAK_VAL_SHIFT))
#define	BREAK_SSTEP	(BREAK_INSTR | (BREAK_SSTEP_VAL << BREAK_VAL_SHIFT))
#define	BREAK_BRKPT	(BREAK_INSTR | (BREAK_BRKPT_VAL << BREAK_VAL_SHIFT))
#define	BREAK_SOVER	(BREAK_INSTR | (BREAK_SOVER_VAL << BREAK_VAL_SHIFT))
#define	BREAK_DDB	(BREAK_INSTR | (BREAK_DDB_VAL << BREAK_VAL_SHIFT))
#define	BREAK_FPUEMUL	(BREAK_INSTR | (BREAK_FPUEMUL_VAL << BREAK_VAL_SHIFT))

/*
 * The floating point version and status registers.
 */
#define	FPC_ID			$0
#define	FPC_CSR			$31

#endif	/* _KERNEL || _STANDALONE */

d262 1
d311 22
@


1.88
log
@Forgot this in previous commit
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.87 2012/09/29 19:24:31 miod Exp $	*/
d152 13
d169 7
d182 1
d203 6
d213 1
d225 1
a225 1
/* Following on RM7000 */
d229 1
d234 5
d240 3
d244 1
d259 8
d272 1
d307 16
d347 1
a347 1
#if defined(CPU_OCTEON)
d565 4
d570 1
d633 1
@


1.87
log
@Handle the coprocessor 0 cause and status registers as a 64 bit value now,
as some odd mips designs need moro than 32 bits in there. This causes a lot
of mechanical changes everywhere getsr() is used.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.86 2012/09/29 19:13:13 miod Exp $	*/
d555 2
@


1.86
log
@Add a few more coprocessor 0 cause and config registers defines.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.85 2012/09/29 19:11:08 miod Exp $	*/
a558 9
u_int	cp0_get_count(void);
uint32_t cp0_get_config(void);
uint32_t cp0_get_config_1(void);
uint32_t cp0_get_config_2(void);
uint32_t cp0_get_config_3(void);
uint32_t cp0_get_prid(void);
void	cp0_set_compare(u_int);
void	cp0_set_config(uint32_t);
u_int	cp1_get_prid(void);
d598 16
a613 4
uint32_t enableintr(void);
uint32_t disableintr(void);
uint32_t getsr(void);
uint32_t setsr(uint32_t);
@


1.85
log
@Kill the mostly unused VMTLB_xxx and VMNUM_xxx defines. Move all tlb
knowledge to <machine/pte.h>. Add specific routines for tlb handling setup
(at cpu initialization time) and tlb ASID wrap.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.84 2012/09/29 18:54:38 miod Exp $	*/
d81 2
a84 2
/* r4k only */
#define	CCA_COHERENT_UPDWRITE	6UL	/* cached, coherent, update on write */
d122 1
a122 1
#define	SR_XX			0x80000000
a138 4
#define	SR_KSU_MASK		0x00000018
#define	SR_KSU_USER		0x00000010
#define	SR_KSU_SUPER		0x00000008
#define	SR_KSU_KERNEL		0x00000000
a142 1
#define	SR_INT_MASK		0x0000ff00
d151 12
d166 1
a175 1
#define	ALL_INT_MASK		((IC_INT_MASK << 8) | SR_INT_MASK)
a176 2
#define	HW_INT_MASK		(ALL_INT_MASK & ~SOFT_INT_MASK)

d179 1
a179 6
 * The bits in the cause register.
 *
 *	CR_BR_DELAY	Exception happened in branch delay slot.
 *	CR_COP_ERR	Coprocessor error.
 *	CR_IP		Interrupt pending bits defined below.
 *	CR_EXC_CODE	The exception type (see exception codes below).
d181 1
a182 1
#define	CR_COP_ERR		0x30000000
d185 4
a188 1
#define	CR_IPEND		0x003fff00
d206 2
d209 1
a209 1
 * The bits in the context register.
d211 5
a215 2
#define	CNTXT_PTE_BASE		0xff800000
#define	CNTXT_BAD_VPN2		0x007ffff0
d220 1
d228 1
a228 1
 * Coprocessor 0 registers:
d230 11
a248 2
#define	COP_0_COUNT		$9
#define	COP_0_TLB_HI		$10
a249 5
#define	COP_0_STATUS_REG	$12
#define	COP_0_CAUSE_REG		$13
#define	COP_0_EXC_PC		$14
#define	COP_0_PRID		$15
#define	COP_0_CONFIG		$16
a253 2
#define	COP_0_TLB_FR_MASK	$21	/* R10000 onwards */
#define	COP_0_DIAG		$22	/* Loongson 2F */
d260 1
a260 3
/*
 * RM7000 specific
 */
d269 7
a275 3
/*
 * Octeon specific
 */
d285 1
a285 1
#define CP0_CYCLE_DIVIDER       1
d287 1
a287 1
#define CP0_CYCLE_DIVIDER       2
@


1.84
log
@Proide a mips_sync() macro to wrap asm("sync"), and replace gazillions of
such statements with it.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.83 2012/07/14 19:50:11 miod Exp $	*/
a301 32
/*
 * The low part of the TLB entry.
 */
#define	VMTLB_PF_NUM		0x3fffffc0
#define	VMTLB_ATTR_MASK		0x00000038
#define	VMTLB_MOD_BIT		0x00000004
#define	VMTLB_VALID_BIT		0x00000002
#define	VMTLB_GLOBAL_BIT	0x00000001

#define	VMTLB_PHYS_PAGE_SHIFT	6

/*
 * The high part of the TLB entry.
 */
#define	VMTLB_VIRT_PAGE_NUM	0xffffe000
#define	VMTLB_PID		0x000000ff
#define	VMTLB_PID_SHIFT		0
#define	VMTLB_VIRT_PAGE_SHIFT	12

/*
 * The number of process id entries.
 */
#define	VMNUM_PIDS		256

/*
 * TLB probe return codes.
 */
#define	VMTLB_NOT_FOUND		0
#define	VMTLB_FOUND		1
#define	VMTLB_FOUND_WITH_PATCH	2
#define	VMTLB_PROBE_ERROR	3

a543 1
struct tlb_entry;
d555 4
a558 1
u_int	tlb_get_pid(void);
d561 2
a562 7
void	tlb_set_wired(int);

void	tlb_flush(int);
void	tlb_flush_addr(vaddr_t);
void	tlb_write_indexed(int, struct tlb_entry *);
int	tlb_update(vaddr_t, unsigned);
void	tlb_read(int, struct tlb_entry *);
@


1.83
log
@Split the existing mips64 clock code into time-of-day and generic duties in
machdep.c, and internal clock interrupting on level 5, still in clock.c; this
will allow other clock sources to be used in the near future. (delay() will
remain tied to the internal clock)
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.82 2012/06/24 16:26:02 miod Exp $	*/
d520 2
@


1.82
log
@Add cache operation functions pointers to struct cpu_info; the various
cache lines and sizes are already there, after all.

The ConfigCache cache routine is responsible for filling these function
pointers; cache routine invocation macros are updated to use the cpu_info
fields, but may still be overriden in <machine/cpu.h> on platforms where
only one set of cache routines is used.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.81 2012/05/27 19:13:02 miod Exp $	*/
d269 9
d470 2
a471 1
void cpu_startclock(struct cpu_info *);
@


1.81
log
@Add a `L2 cache line size' member to struct cpu_info. This allows R4k code to
stop abusing another field, and will be used by more routines RSN.

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.80 2012/04/19 18:15:08 miod Exp $	*/
d371 12
d588 1
d596 4
d610 1
a610 1
 *  Low level access routines to CPU registers
d622 29
@


1.80
log
@Print the currently active ASID in `machine tlb' ddb command.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.79 2012/04/06 20:11:18 miod Exp $	*/
d368 1
@


1.79
log
@Make the logic for PMAP_PREFER() and the logic, inside pmap, to do the
necessary cache coherency work wrt similar virtual indexes of different
physical pages, depending upon two distinct global variables, instead of
a shared one. R4000/R4400 VCE requires a 32KB mask for PMAP_PREFER, which
is otherwise not necessary for pmap coherency (especially since, on these
processors, only L1 uses virtual indexes, and the L1 size is not greater
than the page size, as we are using 16KB pages).
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.78 2012/03/28 20:44:23 miod Exp $	*/
d563 1
d565 1
a565 1
void	tlb_set_pid(int);
@


1.78
log
@Work in progress support for the SGI Indigo, Indigo 2 and Indy systems
(IP20, IP22, IP24) in 64-bit mode, adapated from NetBSD. Currently limited
to headless operation, input and video drivers will get ported soon.

Should work on all R4000, R4440 and R5000 based systems. L2 cache on R5000SC
Indy not supported yet (coming soon), R4600 not supported yet either (coming
soon as well).

Tested to boot multiuser on: Indigo2 R4000SC, Indy R4000PC, Indy R4000SC,
Indy R5000SC, Indigo2 R4400SC. There are still glitches in the Ethernet driver
which are being looked at.

Expansion support is limited to the GIO E++ board; GIO boards with PCI-GIO
bridges not ported yet due to the lack of hardware, and this kind of driver
does not port blindly.

Most of this work comes from NetBSD, polishing and integration work, as well
as putting as many ``R4x00 in 64-bit mode'' erratas as necessary, by yours
truly.

More work is coming, as well as trying to get some easy way to boot install
kernels (as older PROM can only boot ECOFF binaries, which won't do for the
kernel).
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.77 2012/03/25 13:52:52 miod Exp $	*/
a548 2

extern vaddr_t CpuCacheAliasMask;
@


1.77
log
@Move cache handling routines related definitions to a dedicated header file,
rather than abusing <machine/cpu.h>.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.76 2012/03/24 20:10:08 miod Exp $	*/
d563 1
d584 2
@


1.76
log
@The various ConfigCache() functions actually return void, not int.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.75 2012/03/24 20:06:02 miod Exp $	*/
a566 35

/*
 * Available cache operation routines. See <machine/cpu.h> for more.
 */
void	Octeon_ConfigCache(struct cpu_info *);
void	Octeon_SyncCache(struct cpu_info *);
void	Octeon_InvalidateICache(struct cpu_info *, vaddr_t, size_t);
void	Octeon_SyncDCachePage(struct cpu_info *, paddr_t);
void	Octeon_HitSyncDCache(struct cpu_info *, paddr_t, size_t);
void	Octeon_HitInvalidateDCache(struct cpu_info *, paddr_t, size_t);
void	Octeon_IOSyncDCache(struct cpu_info *, paddr_t, size_t, int);

void	Loongson2_ConfigCache(struct cpu_info *);
void	Loongson2_SyncCache(struct cpu_info *);
void	Loongson2_InvalidateICache(struct cpu_info *, vaddr_t, size_t);
void	Loongson2_SyncDCachePage(struct cpu_info *, paddr_t);
void	Loongson2_HitSyncDCache(struct cpu_info *, paddr_t, size_t);
void	Loongson2_HitInvalidateDCache(struct cpu_info *, paddr_t, size_t);
void	Loongson2_IOSyncDCache(struct cpu_info *, paddr_t, size_t, int);

void	Mips5k_ConfigCache(struct cpu_info *);
void	Mips5k_SyncCache(struct cpu_info *);
void	Mips5k_InvalidateICache(struct cpu_info *, vaddr_t, size_t);
void	Mips5k_SyncDCachePage(struct cpu_info *, vaddr_t);
void	Mips5k_HitSyncDCache(struct cpu_info *, vaddr_t, size_t);
void	Mips5k_HitInvalidateDCache(struct cpu_info *, vaddr_t, size_t);
void	Mips5k_IOSyncDCache(struct cpu_info *, vaddr_t, size_t, int);

void	Mips10k_ConfigCache(struct cpu_info *);
void	Mips10k_SyncCache(struct cpu_info *);
void	Mips10k_InvalidateICache(struct cpu_info *, vaddr_t, size_t);
void	Mips10k_SyncDCachePage(struct cpu_info *, vaddr_t);
void	Mips10k_HitSyncDCache(struct cpu_info *, vaddr_t, size_t);
void	Mips10k_HitInvalidateDCache(struct cpu_info *, vaddr_t, size_t);
void	Mips10k_IOSyncDCache(struct cpu_info *, vaddr_t, size_t, int);
@


1.75
log
@Add a few trivial routines to get mips64r2 specific config registers. Not used
by anything yet, but has been lying in one of my trees for too long.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.74 2012/03/19 19:16:06 miod Exp $	*/
d571 1
a571 1
int	Octeon_ConfigCache(struct cpu_info *);
d579 1
a579 1
int	Loongson2_ConfigCache(struct cpu_info *);
d587 1
a587 1
int	Mips5k_ConfigCache(struct cpu_info *);
d595 1
a595 1
int	Mips10k_ConfigCache(struct cpu_info *);
@


1.74
log
@Use uncached addresses for all exception vectors, when copying our code (or
trampolines) to them; this makes sure there is no risk of pending writes
being lost when we clear the caches. Of course, this would be a bug in the
cache handling routines, but having our vectors correctly set will help
debugging the issue.
Tested on sgi and loongson.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.73 2012/03/15 18:57:22 miod Exp $	*/
d558 3
@


1.73
log
@uncached_base was introduced early in IP27 support, since these designs use
subspaces in the CCA_NC uncached memory space. However, being coherent,
there was never a need for bus_dma to use uncached addresses.

This means that, on the only systems where uncached_base was not set to
PHYS_TO_XKPHYS(0, CCA_NC), it was never used.

Remove the variable, and replace PHYS_TO_UNCACHED() with
PHYS_TO_XKPHYS(, CCA_NC). No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.72 2011/06/24 19:47:48 naddy Exp $	*/
d213 4
a216 4
#define	TLB_MISS_EXC_VEC	(CKSEG0_BASE + 0x00000000)
#define	XTLB_MISS_EXC_VEC	(CKSEG0_BASE + 0x00000080)
#define	CACHE_ERR_EXC_VEC	(CKSEG0_BASE + 0x00000100)
#define	GEN_EXC_VEC		(CKSEG0_BASE + 0x00000180)
@


1.72
log
@machdep.kbdreset enables a shutdown by Ctrl-Alt-Del on amd64 and
i386.  Stop abusing it on other archs for controling a shutdown by
pressing the soft power button:

* Add a MI sysctl hw.allowpowerdown; if set to 1 (the default) it
  allows a power button shutdown.
* Make acpi(4)/acpibtn(4) honor hw.allowpowerdown.
* Switch the various power button intercepts on landisk, sgi, sparc64
  and zaurus over to hw.allowpowerdown.
* Garbage collect the machdep.kbdreset sysctl on all archs other than
  amd64 and i386.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.71 2011/03/31 20:37:44 miod Exp $	*/
a102 2
extern vaddr_t uncached_base;

a110 1
#define	PHYS_TO_UNCACHED(x)	((paddr_t)(x) | uncached_base)
@


1.71
log
@Recognize Loongson 3A processors, but don't accept to run on them yet, the
cache routines are not ready. This is mostly low-hanging fruit.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.70 2011/03/23 16:54:36 pirofti Exp $	*/
d507 1
a507 1
#define	CPU_KBDRESET		2	/* keyboard reset */
d513 1
a513 1
	{ "kbdreset", CTLTYPE_INT },		\
@


1.70
log
@Normalize sentinel. Use _MACHINE_*_H_ and _<ARCH>_*_H_ properly and consitently.

Discussed and okay drahn@@. Okay deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.69 2010/11/24 21:16:26 miod Exp $	*/
d543 1
a543 1
#define	MIPS_LOONGSON2	0x63	/* STC LoongSon2 CPU		ISA III */
@


1.69
log
@Floating-point emulation code for systems lacking proper FPU (i.e. Octeon),
enabled by option FPUEMUL.

This is pretty straightforward, except for conditional branch on FPU condition
codes emulation (bc1f/bc1fl/bc1t/bc1tl instructions): unlike most
RISC-with-delay-slots designs (m88k, sparc), the branch pipeline is not exposed
to the kernel on Mips, therefore we can not resume a branch without losing the
delay slot instruction.

Some other operating systems work around this issue by emulating the delay
slot instruction, but this is error-prone (and requires the kernel code to
be aware of all supported instructions of the processor it is currently running
on), some use dedicated breakpoints to single-step through the delay slot and
then resume the branch as expected, but this causes a lot of copy-on-write
allocations.

This code chooses a third path, of copying the delay slot instructions to run toa special `magic' page, followed by a special trap instruction to give control
back to the kernel. This makes sure the instruction will actually be run by the
processor, and that no more than one page per process is wasted, regardless of
the number of branches to emulate.

Tested on octeon (big-endian) by syuu@@ and on loongson (little-endian) by me.
Note that enabling option FPUEMUL in the kernel will completely disable the
hardware FPU, if there is one; there is currently no way to build a kernel
supporting both hardware and software FPU, and there is no reason to change
this until there is a strong need to support both.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.68 2010/10/24 15:40:03 miod Exp $	*/
d45 2
a46 2
#ifndef _MIPS_CPU_H_
#define	_MIPS_CPU_H_
d638 1
a638 1
#endif /* !_MIPS_CPU_H_ */
@


1.68
log
@Move build_trampoline() and setregs() to a common location for all mips ports.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.67 2010/10/02 20:49:22 syuu Exp $	*/
d282 1
d288 1
d555 1
d610 1
d615 2
@


1.67
log
@Added octeon specific cop0 registers. ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.66 2010/09/28 20:27:55 miod Exp $	*/
d606 1
@


1.66
log
@Implement a per-cpu held mutex counter if DIAGNOSTIC on all non-x86 platforms,
to complete matthew@@'s commit of a few days ago, and drop __HAVE_CPU_MUTEX_LEVEL
define. With help from, and ok deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.65 2010/09/21 20:29:17 miod Exp $	*/
d262 8
@


1.65
log
@Replace the old floating point completion code with a C interface to the
MI softfloat code, implementing all MIPS IV specified floating point
operations.
Tested on R5000, R10000, R14000 and Loongson2F.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.64 2010/09/20 12:10:26 syuu Exp $	*/
d387 4
@


1.64
log
@cache operations for octeon. ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.63 2010/09/17 00:35:51 miod Exp $	*/
a286 37
 * The floating point coprocessor status register bits.
 */
#define	FPC_ROUNDING_BITS		0x00000003
#define	FPC_ROUND_RN			0x00000000
#define	FPC_ROUND_RZ			0x00000001
#define	FPC_ROUND_RP			0x00000002
#define	FPC_ROUND_RM			0x00000003
#define	FPC_STICKY_BITS			0x0000007c
#define	FPC_STICKY_INEXACT		0x00000004
#define	FPC_STICKY_UNDERFLOW		0x00000008
#define	FPC_STICKY_OVERFLOW		0x00000010
#define	FPC_STICKY_DIV0			0x00000020
#define	FPC_STICKY_INVALID		0x00000040
#define	FPC_ENABLE_BITS			0x00000f80
#define	FPC_ENABLE_INEXACT		0x00000080
#define	FPC_ENABLE_UNDERFLOW		0x00000100
#define	FPC_ENABLE_OVERFLOW		0x00000200
#define	FPC_ENABLE_DIV0			0x00000400
#define	FPC_ENABLE_INVALID		0x00000800
#define	FPC_EXCEPTION_BITS		0x0003f000
#define	FPC_EXCEPTION_INEXACT		0x00001000
#define	FPC_EXCEPTION_UNDERFLOW		0x00002000
#define	FPC_EXCEPTION_OVERFLOW		0x00004000
#define	FPC_EXCEPTION_DIV0		0x00008000
#define	FPC_EXCEPTION_INVALID		0x00010000
#define	FPC_EXCEPTION_UNIMPL		0x00020000
#define	FPC_COND_BIT			0x00800000
#define	FPC_FLUSH_BIT			0x01000000
#define	FPC_MBZ_BITS			0xfe7c0000

/*
 * Constants to determine if have a floating point instruction.
 */
#define	OPCODE_SHIFT		26
#define	OPCODE_C1		0x11

/*
d602 1
@


1.63
log
@Protect a few more defines with _KERNEL checks, and also allow some of them
to be visible if _STANDALONE. This will eventually be used by the upcoming
new-and-improved loongson bootblocks (in the works).
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.62 2010/09/13 21:59:07 syuu Exp $	*/
d593 7
@


1.62
log
@Added OCTEON in cpu type. ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.61 2010/09/12 18:30:19 miod Exp $	*/
d120 1
a120 1
#ifdef _KERNEL
d355 2
d361 1
a361 1
#ifndef _LOCORE
d524 1
a524 2
#endif /* !_LOCORE */
#endif /* _KERNEL */
d647 1
a647 1
#endif /* _KERNEL */
@


1.61
log
@Stricter types in MipsEmulateBranch(), and related cleanups.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.60 2010/09/11 11:29:49 syuu Exp $	*/
d547 1
@


1.60
log
@move machine dependent GET_CPU_INFO(), getcurcpu(), setcurcpu() to arch/sgi. ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.59 2010/08/30 08:52:10 syuu Exp $	*/
d406 3
a408 2
	u_int32_t	ci_cpu_counter_last;
	u_int32_t	ci_cpu_counter_interval;
a475 4
#endif	/* _LOCORE */

#ifndef _LOCORE

d630 1
a630 2
extern u_int32_t cpu_counter_interval;	/* Number of counter ticks/tick */
extern u_int32_t cpu_counter_last;	/* Last compare value loaded */
@


1.59
log
@ddbcpu for sgi. ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.58 2010/04/28 16:20:28 syuu Exp $	*/
d437 2
a438 2
extern struct cpu_info *getcurcpu(void);
extern void setcurcpu(struct cpu_info *);
@


1.58
log
@Storeing current cpu_info address into LLAddr register, for curcpu().
Instead of previous implementation, we won't use physical cpuid to fetch curcpu().
This requires to implement IP27/35 SMP.
Implemented getcurcpu() and setcurcpu() for it, smp_malloc() renamed alloc_contiguous_pages() because now it only allocate by page.
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.57 2010/02/28 18:01:36 miod Exp $	*/
d415 6
a438 1
#ifdef DEBUG
a439 1
#endif
d454 2
a455 1
#define MIPS64_NIPIS		2	/* must not exceed 32 */
d468 1
@


1.57
log
@Pass L2 cache size in struct cpu_hwinfo, so that bootstrap of secondary
processors can display correct data. Now cpu1 on octane is correctly
reported in dmesg.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.56 2010/02/28 17:23:23 miod Exp $	*/
d431 6
a436 1
#define curcpu()			(cpu_info[cpu_number()])
d438 1
a438 1
#define cpu_number()			hw_cpu_number()
a440 1
extern struct cpu_info *cpu_info[];
d446 1
a446 1
vaddr_t smp_malloc(size_t);
@


1.56
log
@Add an explicit `delay constant' member to struct cpu_info, so that it can
be decoupled from the nominal processor speed.
While there, make sure delay() gets a proper delay constant if invoked before
cpu0 attaches (how could I miss that when introducing struct cpu_hwinfo?!?)
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.55 2010/01/18 16:59:22 miod Exp $	*/
d372 1
@


1.55
log
@Define IPL_SCHED as IPL_CLOCK, not IPL_HIGH.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.54 2010/01/09 23:43:41 miod Exp $	*/
d381 1
@


1.54
log
@Make interrupt depth counters per-cpu.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.53 2010/01/09 23:34:29 miod Exp $	*/
d363 1
a364 2

#include <machine/intr.h>
@


1.53
log
@Move cache information from global variables to per-cpu_info fields; this
allows processors with different cache sizes to be used.

Cache management routines now take a struct cpu_info * as first parameter.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.52 2010/01/09 20:33:16 miod Exp $	*/
d409 1
a471 1
extern int int_nest_cntr;
d476 1
a476 1
#define	CLKF_INTR(framep)	(int_nest_cntr > 0)
@


1.52
log
@Define struct cpu_hwinfo, to hold hardware specific information about each
processor (instead of sys_config.cpu[]), and pass it in the attach_args
when attaching cpu devices.

This allows per-cpu information to be gathered late in the bootstrap process,
and not be limited by an arbitrary MAX_CPUS limit; this will suit IP27 and
IP35 systems better.

While there, use this information to make sure delay() uses the speed
information from the cpu it is invoked on.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.51 2010/01/08 01:35:52 syuu Exp $	*/
d384 13
d566 1
a566 15
extern u_int	CpuPrimaryInstCacheSize;
extern u_int	CpuPrimaryInstCacheLSize;
extern u_int	CpuPrimaryInstSetSize;
extern u_int	CpuPrimaryDataCacheSize;
extern u_int	CpuPrimaryDataCacheLSize;
extern u_int	CpuPrimaryDataSetSize;
extern u_int	CpuCacheAliasMask;
extern u_int	CpuSecondaryCacheSize;
extern u_int	CpuTertiaryCacheSize;
extern u_int	CpuNWayCache;
extern u_int	CpuCacheType;		/* R4K, R5K, RM7K */
extern u_int	CpuConfigRegister;
extern u_int	CpuStatusRegister;
extern u_int	CpuExternalCacheOn;	/* R5K, RM7K */
extern u_int	CpuOnboardCacheOn;	/* RM7K */
d572 2
a573 1
u_int	cp0_get_prid(void);
d584 23
a606 23
int	Loongson2_ConfigCache(void);
void	Loongson2_SyncCache(void);
void	Loongson2_InvalidateICache(vaddr_t, size_t);
void	Loongson2_SyncDCachePage(paddr_t);
void	Loongson2_HitSyncDCache(paddr_t, size_t);
void	Loongson2_HitInvalidateDCache(paddr_t, size_t);
void	Loongson2_IOSyncDCache(paddr_t, size_t, int);

int	Mips5k_ConfigCache(void);
void	Mips5k_SyncCache(void);
void	Mips5k_InvalidateICache(vaddr_t, size_t);
void	Mips5k_SyncDCachePage(vaddr_t);
void	Mips5k_HitSyncDCache(vaddr_t, size_t);
void	Mips5k_HitInvalidateDCache(vaddr_t, size_t);
void	Mips5k_IOSyncDCache(vaddr_t, size_t, int);

int	Mips10k_ConfigCache(void);
void	Mips10k_SyncCache(void);
void	Mips10k_InvalidateICache(vaddr_t, size_t);
void	Mips10k_SyncDCachePage(vaddr_t);
void	Mips10k_HitSyncDCache(vaddr_t, size_t);
void	Mips10k_HitInvalidateDCache(vaddr_t, size_t);
void	Mips10k_IOSyncDCache(vaddr_t, size_t, int);
d633 4
a636 4
u_int32_t enableintr(void);
u_int32_t disableintr(void);
void	setsr(u_int32_t);
u_int32_t getsr(void);
@


1.51
log
@MP-safe FPU handling. ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.50 2009/12/30 01:17:59 syuu Exp $	*/
d367 8
d376 3
a378 3
	struct device   *ci_dev;	/* our device */
	struct cpu_info *ci_self;	/* pointer to this structure */
	struct cpu_info *ci_next;	/* next cpu */
d382 2
a383 1

d387 1
a387 1
	cpuid_t		ci_cpuid;              /* our CPU ID */
d389 2
a390 2
	int		ci_ipl;		/* software IPL */
	uint32_t	ci_softpending;	/* pending soft interrupts */
@


1.50
log
@curcpu()->ci_curpmap added. ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.49 2009/12/28 06:55:27 syuu Exp $	*/
d373 1
d606 3
a608 2
void	MipsSaveCurFPState(struct proc *);
void	MipsSaveCurFPState16(struct proc *);
@


1.49
log
@MP-safe pmap implemented, enable IPI in interrupt handler to avoid deadlock.
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.48 2009/12/25 21:02:13 miod Exp $	*/
d372 1
a372 1
	struct user *ci_curprocpaddr;
d375 11
a385 10
			 ci_schedstate;
	int		 ci_want_resched;	/* need_resched() invoked */
	cpuid_t          ci_cpuid;              /* our CPU ID */
	uint32_t	 ci_randseed;		/* per cpu random seed */
	int		 ci_ipl;		/* software IPL */
	uint32_t	 ci_softpending;	/* pending soft interrupts */
	int	         ci_clock_started;
	u_int32_t        ci_cpu_counter_last;
	u_int32_t        ci_cpu_counter_interval;
	u_int32_t        ci_pendingticks;
d387 2
a388 2
	u_long           ci_flags;		/* flags; see below */
	struct intrhand  ci_ipiih;
@


1.48
log
@Pass both the virtual address and the physical address of the memory range
when invoking the cache functions. The physical address is needed when
operating on physically-indexed caches, such as the L2 cache on Loongson
processors.

Preprocessor abuse makes sure that the physical address computation gets
compiled out when running on a kernel compiled for virtually-indexed
caches only, such as the sgi kernel.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.47 2009/12/07 19:05:57 miod Exp $	*/
d387 1
a387 1
	struct intrhand  *ci_ipiih;
d419 2
a420 1
#define MIPS64_NIPIS		1	/* must not exceed 32 */
d422 3
a424 4
void    mips64_ipi_init(void);
void    mips64_send_ipi(unsigned int, unsigned int);
void    mips64_broadcast_ipi(unsigned int);
void    mips64_multicast_ipi(unsigned int, unsigned int);
d482 3
d486 1
@


1.47
log
@Support for 16KB page size kernels; page size is now set in <machine/param.h>
rather than <mips64/param.h>.

For now, kernels are kept at 4KB to give people some time to build 16KB
compatible binaries; this will change before the end of this release cycle.

Use of 16KB page size kernels yields a 18% speedup (which, offset by the
1.6% slowdown caused by the pmap changes, yields a 16.6% overall speedup).
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.46 2009/11/25 17:39:51 syuu Exp $	*/
d215 1
a215 1
#define	RESET_EXC_VEC		(CKSEG0_BASE + 0x3fc00000)
d566 1
a566 1
 * Define soft selected cache functions.
a567 11
#define	Mips_SyncCache()	(*(sys_config._SyncCache))()
#define	Mips_InvalidateICache(a, l)	\
				(*(sys_config._InvalidateICache))((a), (l))
#define	Mips_SyncDCachePage(a)		\
				(*(sys_config._SyncDCachePage))((a))
#define	Mips_HitSyncDCache(a, l)	\
				(*(sys_config._HitSyncDCache))((a), (l))
#define	Mips_IOSyncDCache(a, l, h)	\
				(*(sys_config._IOSyncDCache))((a), (l), (h))
#define	Mips_HitInvalidateDCache(a, l)	\
				(*(sys_config._HitInvalidateDCache))((a), (l))
d571 5
a575 5
void	Loongson2_InvalidateICache(vaddr_t, int);
void	Loongson2_SyncDCachePage(vaddr_t);
void	Loongson2_HitSyncDCache(vaddr_t, int);
void	Loongson2_IOSyncDCache(vaddr_t, int, int);
void	Loongson2_HitInvalidateDCache(vaddr_t, int);
d579 1
a579 1
void	Mips5k_InvalidateICache(vaddr_t, int);
d581 3
a583 3
void	Mips5k_HitSyncDCache(vaddr_t, int);
void	Mips5k_IOSyncDCache(vaddr_t, int, int);
void	Mips5k_HitInvalidateDCache(vaddr_t, int);
d587 1
a587 1
void	Mips10k_InvalidateICache(vaddr_t, int);
d589 3
a591 3
void	Mips10k_HitSyncDCache(vaddr_t, int);
void	Mips10k_IOSyncDCache(vaddr_t, int, int);
void	Mips10k_HitInvalidateDCache(vaddr_t, int);
@


1.46
log
@IP30 IPI implementation.
Also few xheart modification for SMP.
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.45 2009/11/24 22:46:59 syuu Exp $	*/
d557 1
a557 2
void	tlb_set_wired(int);
void	tlb_set_pid(int);
d559 1
d561 3
a563 2
u_int	cp0_get_count(void);
void	cp0_set_compare(u_int);
@


1.45
log
@smp_malloc() implemented.
This function allocates memory using malloc or uvm_pglistalloc, then returns XKPHYS address of allocated memory.
It's for avoid using virtual address on secondary cpus in early stage, and also in TLB handler.
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.44 2009/11/22 18:33:48 syuu Exp $	*/
d387 1
d417 8
@


1.44
log
@SMP support on MIPS clock.
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.43 2009/11/19 20:16:26 miod Exp $	*/
d368 1
a368 1
	struct device   ci_dev;		/* our device */
d400 1
a400 1
#define CPU_INFO_UNIT(ci)		((ci)->ci_dev.dv_unit)
d414 2
@


1.43
log
@Rename KSEG* defines to CKSEG* to match their names in 64 bit mode; also
define more 64 bit spaces.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.42 2009/10/30 08:13:57 syuu Exp $	*/
d381 4
d423 2
@


1.42
log
@Support IP30 secondary cpu bootup. ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.41 2009/10/22 22:08:52 miod Exp $	*/
d48 2
d54 10
a63 11
#define	KSEG0_BASE	0xffffffff80000000
#define	KSEG1_BASE	0xffffffffa0000000
#define	KSSEG_BASE	0xffffffffc0000000
#define	KSEG3_BASE	0xffffffffe0000000
#define	KSEG_SIZE	0x0000000020000000

#define	KSEG0_TO_PHYS(x)	((u_long)(x) & (KSEG_SIZE - 1))
#define	KSEG1_TO_PHYS(x)	((u_long)(x) & (KSEG_SIZE - 1))
#define	PHYS_TO_KSEG0(x)	((u_long)(x) | KSEG0_BASE)
#define	PHYS_TO_KSEG1(x)	((u_long)(x) | KSEG1_BASE)
#define	PHYS_TO_KSEG3(x)	((u_long)(x) | KSEG3_BASE)
a69 2
#ifndef _LOCORE

d105 3
a107 1
#endif	/* _LOCORE */
a108 1
#define	XKPHYS_BASE		0x8000000000000000UL
d118 2
d215 5
a219 5
#define	RESET_EXC_VEC		(KSEG0_BASE + 0x3fc00000)
#define	TLB_MISS_EXC_VEC	(KSEG0_BASE + 0x00000000)
#define	XTLB_MISS_EXC_VEC	(KSEG0_BASE + 0x00000080)
#define	CACHE_ERR_EXC_VEC	(KSEG0_BASE + 0x00000100)
#define	GEN_EXC_VEC		(KSEG0_BASE + 0x00000180)
@


1.41
log
@Completely overhaul interrupt handling on sgi. Cpu state now only stores a
logical IPL level, and per-platform (IP27/IP30/IP32) code will from the
necessary hardware mask registers.

This allows the use of more than one interrupt mask register. Also, the
generic (platform independent) interrupt code shrinks a lot, and the actual
interrupt handler chains and masking information is now per-platform private
data.

Interrupt dispatching is generated from a template; more routines will be
added to the template to reduce platform-specific changes and share as much
code as possible.

Tested on IP27, IP30, IP32 and IP35.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.40 2009/10/22 20:59:22 miod Exp $	*/
d406 2
@


1.40
log
@With the splx() changes, it is no longer necessary to remember which interrupt
sources were masked and saved in ci_ipending, as splx() will unmask what needs
to be unmasked anyway. ci_ipending only now needs to store pending soft
interrupts, so rename it to ci_softpending.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.39 2009/10/22 20:05:26 miod Exp $	*/
d377 1
a377 1
	uint32_t	 ci_cpl;
@


1.39
log
@Replace intrmask_t with uint32_t. This types only describes interrupt masks
in the coprocessor 0 status register (coupled with ICR on rm7k/rm9k), and
may be completely alien to real hardware interrupt masks, so don't make
things unnecessary confusing.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.38 2009/10/07 08:35:47 syuu Exp $	*/
d378 1
a378 1
	uint32_t	 ci_ipending;
@


1.38
log
@ipending, cpl moved into cpu_info
OK miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.37 2009/09/30 06:22:00 syuu Exp $	*/
d376 3
a378 3
	u_int32_t	 ci_randseed;		/* per cpu random seed */
	intrmask_t       ci_cpl;
	intrmask_t       ci_ipending;
@


1.37
log
@curproc, curprocpaddr moved into cpu_info
OK miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.36 2009/09/15 04:54:31 syuu Exp $	*/
d377 2
@


1.36
log
@cpu status flag, cpuid added to cpu_info.
cpu_info pointer array, cpu_info iterator, cpu_number() implementation added.
constraint modifier fixed in lock.h to output correct assembly.
calling proc_trampoline_mp in exception.S.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.35 2009/08/06 21:54:27 miod Exp $	*/
d370 1
@


1.35
log
@Make sure <machine/cpu.h> includes <machine/intr.h> when included with _LOCORE
defined; cp0access.S relies on this.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.33 2009/06/10 18:05:30 miod Exp $	*/
d359 2
d363 2
d366 3
d374 1
a374 1

d376 3
d381 4
d386 17
d404 8
a411 11
#define	curcpu()	(&cpu_info_primary)

#define	CPU_IS_PRIMARY(ci)	1
#define	CPU_INFO_ITERATOR	int
#define	CPU_INFO_FOREACH(cii, ci)					\
	for (cii = 0, ci = curcpu(); ci != NULL; ci = NULL)
#define	CPU_INFO_UNIT(ci)	0
#define	MAXCPUS	1
#define	cpu_unidle(ci)

#define	cpu_number()	0
a415 2

#include <machine/intr.h>
@


1.34
log
@Work in progress support for Loongson2E/2F processors; need option CPU_LOONGSON2
in the kernel to be brought in, due to invasive differences in tlb operation.
Comes with a separate cache operations file due to the cache being R5k-style
with R10k-style way number encoding.
@
text
@d386 3
d390 2
@


1.33
log
@Switch sgi to per-process AST, and move ast() from interrupt.c to trap.c
where it can use userret() instead of duplicating it.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.32 2009/06/02 17:55:37 miod Exp $	*/
d243 1
d471 1
d473 1
a514 2
#define	Mips_InvalidateICachePage(a)	\
				(*(sys_config._InvalidateICachePage))((a))
d524 8
a534 1
void	Mips5k_InvalidateICachePage(vaddr_t);
a542 1
void	Mips10k_InvalidateICachePage(vaddr_t);
@


1.32
log
@Add an r10k-specific cop0 control register.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.31 2009/05/22 20:37:53 miod Exp $	*/
d361 1
a361 1
	struct schedstate_percpu ci_schedstate;
d363 5
a367 2
	struct proc *ci_curproc;
	u_int32_t ci_randseed;
d407 7
a413 2
#define	need_resched(info)	{ want_resched = 1; aston(); }
#define	clear_resched(ci) 	want_resched = 0
d420 1
a420 1
#define	need_proftick(p)	aston()
d426 1
a426 3
#define	signotify(p)	aston()

#define	aston()		(astpending = 1)
d428 1
a428 1
extern int want_resched;	/* resched() was called */
@


1.31
log
@Drop almost unused <machine/psl.h> on sgi; move USERMODE() definition from
there to trap.c which is its only user. This also cleans up multiple
inclusion of <machine/cpu.h> (because <machine/psl.h> includes it) in many
places.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.30 2009/03/26 17:24:33 oga Exp $	*/
d46 1
a46 1
#define _MIPS_CPU_H_
d52 5
a56 5
#define KSEG0_BASE	0xffffffff80000000
#define KSEG1_BASE	0xffffffffa0000000
#define KSSEG_BASE	0xffffffffc0000000
#define KSEG3_BASE	0xffffffffe0000000
#define KSEG_SIZE	0x0000000020000000
d121 1
a121 1
 *  Status register.
d123 34
a156 34
#define SR_XX			0x80000000
#define SR_COP_USABILITY	0x30000000	/* CP0 and CP1 only */
#define SR_COP_0_BIT		0x10000000
#define SR_COP_1_BIT		0x20000000
#define SR_RP			0x08000000
#define SR_FR_32		0x04000000
#define SR_RE			0x02000000
#define SR_DSD			0x01000000	/* Only on R12000 */
#define SR_BOOT_EXC_VEC		0x00400000
#define SR_TLB_SHUTDOWN		0x00200000
#define SR_SOFT_RESET		0x00100000
#define SR_DIAG_CH		0x00040000
#define SR_DIAG_CE		0x00020000
#define SR_DIAG_DE		0x00010000
#define SR_KX			0x00000080
#define SR_SX			0x00000040
#define SR_UX			0x00000020
#define SR_KSU_MASK		0x00000018
#define SR_KSU_USER		0x00000010
#define SR_KSU_SUPER		0x00000008
#define SR_KSU_KERNEL		0x00000000
#define SR_ERL			0x00000004
#define SR_EXL			0x00000002
#define SR_INT_ENAB		0x00000001

#define SR_INT_MASK		0x0000ff00
#define SOFT_INT_MASK_0		0x00000100
#define SOFT_INT_MASK_1		0x00000200
#define SR_INT_MASK_0		0x00000400
#define SR_INT_MASK_1		0x00000800
#define SR_INT_MASK_2		0x00001000
#define SR_INT_MASK_3		0x00002000
#define SR_INT_MASK_4		0x00004000
#define SR_INT_MASK_5		0x00008000
d178 1
a178 1
 *	CR_COP_ERR		Coprocessor error.
d182 5
a186 5
#define CR_BR_DELAY		0x80000000
#define CR_COP_ERR		0x30000000
#define CR_EXC_CODE		0x0000007c
#define CR_EXC_CODE_SHIFT	2
#define CR_IPEND		0x003fff00
d207 2
a208 2
#define CNTXT_PTE_BASE		0xff800000
#define CNTXT_BAD_VPN2		0x007ffff0
d213 5
a217 5
#define RESET_EXC_VEC		(KSEG0_BASE + 0x3fc00000)
#define TLB_MISS_EXC_VEC	(KSEG0_BASE + 0x00000000)
#define XTLB_MISS_EXC_VEC	(KSEG0_BASE + 0x00000080)
#define CACHE_ERR_EXC_VEC	(KSEG0_BASE + 0x00000100)
#define GEN_EXC_VEC		(KSEG0_BASE + 0x00000180)
d222 26
a247 25
#define COP_0_TLB_INDEX		$0
#define COP_0_TLB_RANDOM	$1
#define COP_0_TLB_LO0		$2
#define COP_0_TLB_LO1		$3
#define COP_0_TLB_CONTEXT	$4
#define COP_0_TLB_PG_MASK	$5
#define COP_0_TLB_WIRED		$6
#define COP_0_BAD_VADDR		$8
#define COP_0_COUNT		$9
#define COP_0_TLB_HI		$10
#define COP_0_COMPARE		$11
#define COP_0_STATUS_REG	$12
#define COP_0_CAUSE_REG		$13
#define COP_0_EXC_PC		$14
#define COP_0_PRID		$15
#define COP_0_CONFIG		$16
#define COP_0_LLADDR		$17
#define COP_0_WATCH_LO		$18
#define COP_0_WATCH_HI		$19
#define COP_0_TLB_XCONTEXT	$20
#define COP_0_ECC		$26
#define COP_0_CACHE_ERR		$27
#define COP_0_TAG_LO		$28
#define COP_0_TAG_HI		$29
#define COP_0_ERROR_PC		$30
d252 5
a256 5
#define COP_0_WATCH_1		$18
#define COP_0_WATCH_2		$19
#define COP_0_WATCH_M		$24
#define COP_0_PC_COUNT		$25
#define COP_0_PC_CTRL		$22
d263 13
a275 19
#define BREAK_INSTR		0x0000000d
#define BREAK_VAL_MASK		0x03ff0000
#define BREAK_VAL_SHIFT		16
#define BREAK_KDB_VAL		512
#define BREAK_SSTEP_VAL		513
#define BREAK_BRKPT_VAL		514
#define BREAK_SOVER_VAL		515
#define BREAK_DDB_VAL		516
#define BREAK_KDB	(BREAK_INSTR | (BREAK_KDB_VAL << BREAK_VAL_SHIFT))
#define BREAK_SSTEP	(BREAK_INSTR | (BREAK_SSTEP_VAL << BREAK_VAL_SHIFT))
#define BREAK_BRKPT	(BREAK_INSTR | (BREAK_BRKPT_VAL << BREAK_VAL_SHIFT))
#define BREAK_SOVER	(BREAK_INSTR | (BREAK_SOVER_VAL << BREAK_VAL_SHIFT))
#define BREAK_DDB	(BREAK_INSTR | (BREAK_DDB_VAL << BREAK_VAL_SHIFT))

/*
 * Mininum and maximum cache sizes.
 */
#define MIN_CACHE_SIZE		(16 * 1024)
#define MAX_CACHE_SIZE		(256 * 1024)
d286 27
a312 27
#define FPC_ROUNDING_BITS		0x00000003
#define FPC_ROUND_RN			0x00000000
#define FPC_ROUND_RZ			0x00000001
#define FPC_ROUND_RP			0x00000002
#define FPC_ROUND_RM			0x00000003
#define FPC_STICKY_BITS			0x0000007c
#define FPC_STICKY_INEXACT		0x00000004
#define FPC_STICKY_UNDERFLOW		0x00000008
#define FPC_STICKY_OVERFLOW		0x00000010
#define FPC_STICKY_DIV0			0x00000020
#define FPC_STICKY_INVALID		0x00000040
#define FPC_ENABLE_BITS			0x00000f80
#define FPC_ENABLE_INEXACT		0x00000080
#define FPC_ENABLE_UNDERFLOW		0x00000100
#define FPC_ENABLE_OVERFLOW		0x00000200
#define FPC_ENABLE_DIV0			0x00000400
#define FPC_ENABLE_INVALID		0x00000800
#define FPC_EXCEPTION_BITS		0x0003f000
#define FPC_EXCEPTION_INEXACT		0x00001000
#define FPC_EXCEPTION_UNDERFLOW		0x00002000
#define FPC_EXCEPTION_OVERFLOW		0x00004000
#define FPC_EXCEPTION_DIV0		0x00008000
#define FPC_EXCEPTION_INVALID		0x00010000
#define FPC_EXCEPTION_UNIMPL		0x00020000
#define FPC_COND_BIT			0x00800000
#define FPC_FLUSH_BIT			0x01000000
#define FPC_MBZ_BITS			0xfe7c0000
d317 2
a318 2
#define OPCODE_SHIFT		26
#define OPCODE_C1		0x11
d323 5
a327 5
#define VMTLB_PF_NUM		0x3fffffc0
#define VMTLB_ATTR_MASK		0x00000038
#define VMTLB_MOD_BIT		0x00000004
#define VMTLB_VALID_BIT		0x00000002
#define VMTLB_GLOBAL_BIT	0x00000001
d329 1
a329 1
#define VMTLB_PHYS_PAGE_SHIFT	6
d334 4
a337 4
#define VMTLB_VIRT_PAGE_NUM	0xffffe000
#define VMTLB_PID		0x000000ff
#define VMTLB_PID_SHIFT		0
#define VMTLB_VIRT_PAGE_SHIFT	12
d347 4
a350 4
#define VMTLB_NOT_FOUND		0
#define VMTLB_FOUND		1
#define VMTLB_FOUND_WITH_PATCH	2
#define VMTLB_PROBE_ERROR	3
d369 1
a369 1
#define curcpu()	(&cpu_info_primary)
d371 3
a373 3
#define CPU_IS_PRIMARY(ci)	1
#define CPU_INFO_ITERATOR	int
#define CPU_INFO_FOREACH(cii, ci)					\
d375 3
a377 3
#define CPU_INFO_UNIT(ci)	0
#define MAXCPUS	1
#define cpu_unidle(ci)
d379 1
a379 1
#define cpu_number()	0
d385 2
a386 2
 * Arguments to hardclock and gatherstats encapsulate the previous
 * machine state in an opaque clockframe.
d389 1
a389 1
#define clockframe trap_frame	/* Use normal trap frame */
d405 1
a405 1
#define clear_resched(ci) 	want_resched = 0
d420 1
a420 1
#define aston()		(astpending = 1)
d434 1
a434 1
#define CTL_MACHDEP_NAMES {			\
d447 1
a447 1
#define MIPS_R3LSI	0x05	/* LSI Logic R3000 derivate	ISA I	*/
d452 2
a453 2
#define MIPS_R4300	0x0b	/* NEC VR4300 CPU		ISA III */
#define MIPS_R4100	0x0c	/* NEC VR41xx CPU MIPS-16	ISA III */
d501 1
a501 1
 *  Define soft selected cache functions.
d548 2
a549 2
extern u_int32_t cpu_counter_interval;  /* Number of counter ticks/tick */
extern u_int32_t cpu_counter_last;      /* Last compare value loaded    */
@


1.30
log
@Remove cpu_wait(). It's original use was to be called from the reaper so
MD code would free resources that couldn't be freed until we were no
longer running in that processor. However, it's is unused on all
architectures since mikeb@@'s tss changes on x86 earlier in the year.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.29 2008/10/15 23:23:49 deraadt Exp $	*/
a47 2
#include <machine/psl.h>

d387 2
a565 1
u_int32_t updateimask(intrmask_t);
@


1.29
log
@make random(9) return per-cpu values (by saving the seed in the cpuinfo),
which are uniform for the profclock on each cpu in a SMP system (but using
a different seed for each cpu).  on all cpus, avoid seeding with a value out
of the [0, 2^31-1] range (since that is not stable)
ok kettenis drahn
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.28 2008/10/10 08:36:28 art Exp $	*/
a361 6

/*
 * definitions of cpu-dependent requirements
 * referenced in generic code
 */
#define	cpu_wait(p)		/* nothing */
@


1.28
log
@Add empty cpu_unidle() macros for architectures that currently don't do
anything special to prod a cpu to leave the idle loop in signotify.
powerpc, i386, amd64 and sparc64 will follow soon so that everyone has
the same interface to wake an idling cpu.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.27 2008/10/10 08:05:45 art Exp $	*/
d377 1
@


1.27
log
@Define MAXCPUS on all architectures.
For now, sparc64 is arbitrarily set to 256 (only architecture that didn't have
a practical limit in the code on the number of cpus).
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.26 2008/10/09 08:43:43 art Exp $	*/
d389 1
@


1.26
log
@Implement CPU_INFO_UNIT for everyone, not just MP kernels.
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.25 2008/07/18 23:43:31 art Exp $	*/
d388 1
@


1.25
log
@Add a macro that clears the want_resched flag that need_resched sets.
Right now when mi_switch picks up the same proc, we didn't clear the
flag which would mean that every time we service an AST we would attempt
a context switch. For some architectures, amd64 being probably the
most extreme, that meant attempting to context switch for every
trap and interrupt.

Now we clear_resched explicitly after every context switch, even if it
didn't do anything. Which also allows us to remove some more code
in cpu_switchto (not done yet).

miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.24 2008/04/07 22:37:16 miod Exp $	*/
d387 1
@


1.24
log
@Add ``guarded'' word read and write routines, to be used by machine-dependent
code soon. Similar to what ddb does, but does not need ddb to be compiled in.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.23 2008/04/07 22:29:16 miod Exp $	*/
d412 1
@


1.23
log
@Define more cache coherency attributes, as well as R10k space identifiers.
Define a symbolic ``cached'' attribute, to be used for cached mappings
regardless of the system's cache coherency.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.22 2007/12/18 08:29:02 jasper Exp $	*/
a547 1
void	switch_exit(struct proc *);
d550 3
@


1.22
log
@add power(4), a driver for the power button found on SGI O2's.
when machdep.kbdreset is set, and the correct interrupt is fired,
the machine gets shut down.

with help from and ok jsing@@, ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.21 2007/11/25 16:40:04 jmc Exp $	*/
d50 4
a53 1
#ifdef __LP64__
d58 1
a58 7
#else
#define KSEG0_BASE	0x80000000
#define KSEG1_BASE	0xa0000000
#define KSSEG_BASE	0xc0000000
#define KSEG3_BASE	0xe0000000
#endif
#define KSEG_SIZE	0x20000000
d60 2
a61 2
#define	KSEG0_TO_PHYS(x)	((u_long)(x) & 0x1fffffff)
#define	KSEG1_TO_PHYS(x)	((u_long)(x) & 0x1fffffff)
d67 8
a74 2
 * Cache Coherency Attributes
 * We only list values common to r4k and r5k.
d76 3
a78 1
#if !defined(_LOCORE)
d81 12
d95 15
a109 1
#ifdef __LP64__
d112 4
a115 1
#define	PHYS_TO_XKPHYS(x,c)	((paddr_t)(x) | XKPHYS_BASE | (c) << 59)
d118 1
a118 1
#endif
@


1.21
log
@spelling fixes, from Martynas Venckus;
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.20 2007/07/18 20:03:50 miod Exp $	*/
d403 2
a404 1
#define	CPU_MAXID		2	/* number of valid machdep ids */
d406 4
a409 3
#define CTL_MACHDEP_NAMES { \
	{ 0, 0 }, \
	{ "allowaperture", CTLTYPE_INT }, \
@


1.20
log
@bus_dmamem_map() maps with a single segment in directly-translated XKPHYS
space, either cache coherent for regular mappings and uncached for
BUS_DMA_COHERENT mappings, as done on all other platforms with direct mappings.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.19 2007/06/18 20:25:53 miod Exp $	*/
d437 1
a437 1
 * MIPS FPU types. Only soft, rest is teh same as cpu type.
@


1.19
log
@Use a shorter form to load XKPHYS constants in .S code, shaves a few text
bytes, no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.18 2007/05/07 18:42:12 kettenis Exp $	*/
d83 1
d523 4
a526 4
void setsoftintr0(void);
void clearsoftintr0(void);
void setsoftintr1(void);
void clearsoftintr1(void);
d530 1
a530 1
void setsr(u_int32_t);
@


1.18
log
@Move sgo to __HAVE_CPUINFO.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.17 2007/05/03 19:34:00 miod Exp $	*/
d73 1
d76 1
@


1.17
log
@Enable support for > 512MB of physical memory on mips64 systems, by using
XKPHYS instead of KSEG[01] for direct mappings.

Then, detect memory above 256MB on O2 by poking at the CRIME registers
(ARCbios will not report memory above 256MB, which is mapped above 1GB
physical, to the system), and add it to the UVM managed memory.

Tested on r5k, rm5200 and r10k with and without more than 256MB, matching
hinv reports in all cases. CRIME memory decoding based on a diff from
kettenis@@ in december 2005.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.16 2007/04/10 21:44:56 miod Exp $	*/
d333 20
@


1.16
log
@Remove long dead definitions. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.15 2007/03/15 10:22:29 art Exp $	*/
a54 3
/* Compatible between R5K and R1xK */
#define	XKSEG0_BASE	0x9800000000000000
#define	XKSEG1_BASE	0x9000000000000000
d68 14
@


1.15
log
@Since p_flag is often manipulated in interrupts and without biglock
it's a good idea to use atomic.h operations on it. This mechanic
change updates all bit operations on p_flag to atomic_{set,clear}bits_int.

Only exception is that P_OWEUPC is set by MI code before calling
need_proftick and it's automatically cleared by ADDUPC. There's
no reason for MD handling of that flag since everyone handles it the
same way.

kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.14 2006/12/24 20:30:35 miod Exp $	*/
a318 2
#define	COPY_SIGCODE		/* copy sigcode above user stack in exec */

a476 1
void	wbflush(void);
a477 1
int	copykstack(struct user *);
@


1.14
log
@Define PROC_PC. Then, since profiling information is being reported in
statclock(), do not bother doing this in userret() anymore. As a result,
userret() does not need its pc and ticks arguments, simplify.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.13 2006/11/29 12:26:13 miod Exp $	*/
d352 1
a352 1
#define	need_proftick(p)	{ (p)->p_flag |= P_OWEUPC; aston(); }
@


1.13
log
@Remove cpu_swapin() and cpu_swapout(), they are no longer necessary (except
for cpu_swapin() on hppa* which is kept).
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.12 2006/01/02 18:09:25 miod Exp $	*/
d335 5
@


1.12
log
@Kill enablertclock.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.11 2005/08/07 07:29:44 miod Exp $	*/
a321 1
#define cpu_swapout(p)		panic("cpu_swapout: can't get here");
@


1.11
log
@Remove advertising clause from UCB licenses; ok deraad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.10 2004/11/11 16:14:22 pefo Exp $	*/
a483 5

/*
 * Enable realtime clock (always enabled).
 */
#define	enablertclock()
@


1.10
log
@say hello to XKSEG0 and XKSEG1!
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.9 2004/10/20 12:49:15 pefo Exp $	*/
d18 1
a18 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.9
log
@Fix some 64 bit address problems.
Some function names made more unique.
Other changes for the upcoming Origin 200 support.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.8 2004/09/27 19:20:49 pefo Exp $	*/
d59 3
@


1.8
log
@Rewrite parts of the interrupt system to achive:

o Remove do_pending code and take a real int instead. The performance
  impact seems to be very low and it simplifies the code considerably.

o Allow interrupt nesting at first level. Run softints with HW ints
  enabled.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.7 2004/09/21 05:51:13 miod Exp $	*/
d425 1
a425 1
struct tlb;
d472 1
a472 1
void	tlb_write_indexed(int, struct tlb *);
d474 1
a474 1
void	tlb_read(int, struct tlb *);
d503 1
@


1.7
log
@Nuke commons.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.6 2004/09/20 10:29:57 pefo Exp $	*/
d331 1
a334 1
#define	CLKF_BASEPRI(framep)	((framep)->cpl == 0)
d336 1
a336 1
#define	CLKF_INTR(framep)	(0)
@


1.6
log
@Add support for R10K cpu class
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.5 2004/09/09 22:21:41 pefo Exp $	*/
d359 1
a359 1
int	want_resched;	/* resched() was called */
d409 15
a423 15
u_int	CpuPrimaryInstCacheSize;
u_int	CpuPrimaryInstCacheLSize;
u_int	CpuPrimaryInstSetSize;
u_int	CpuPrimaryDataCacheSize;
u_int	CpuPrimaryDataCacheLSize;
u_int	CpuPrimaryDataSetSize;
u_int	CpuCacheAliasMask;
u_int	CpuSecondaryCacheSize;
u_int	CpuTertiaryCacheSize;
u_int	CpuNWayCache;
u_int	CpuCacheType;		/* R4K, R5K, RM7K */
u_int	CpuConfigRegister;
u_int	CpuStatusRegister;
u_int	CpuExternalCacheOn;	/* R5K, RM7K */
u_int	CpuOnboardCacheOn;	/* RM7K */
@


1.5
log
@these should have gone in with the other 64 bit changes
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.4 2004/08/15 12:07:28 pefo Exp $	*/
d85 1
d389 2
d402 1
a402 1
 * MIPS FPU types
d405 1
a405 19
#define	MIPS_R2360	0x01	/* MIPS R2360 FPC		ISA I   */
#define	MIPS_R2010	0x02	/* MIPS R2010 FPC		ISA I   */
#define	MIPS_R3010	0x03	/* MIPS R3010 FPC		ISA I   */
#define	MIPS_R6010	0x04	/* MIPS R6010 FPC		ISA II  */
#define	MIPS_R4010	0x05	/* MIPS R4000/R4400 FPC		ISA II  */
#define MIPS_R31LSI	0x06	/* LSI Logic derivate		ISA I	*/
#define	MIPS_R10010	0x09	/* MIPS R10000/T5 FPU		ISA IV  */
#define	MIPS_R4210	0x0a	/* MIPS R4200 FPC (ICE)		ISA III */
#define MIPS_UNKF1	0x0b	/* unnanounced product cpu	ISA III */
#define	MIPS_R8000	0x10	/* MIPS R8000 Blackbird/TFP	ISA IV  */
#define	MIPS_R4600	0x20	/* PMCS R4600 Orion		ISA III */
#define	MIPS_R3SONY	0x21	/* Sony R3000 based FPU		ISA I   */
#define	MIPS_R3TOSH	0x22	/* Toshiba R3000 based FPU	ISA I	*/
#define	MIPS_R5010	0x23	/* MIPS R5000 based FPU		ISA IV  */
#define	MIPS_RM7000	0x27	/* PMCS RM7000 FPU		ISA IV  */
#define	MIPS_RM5230	0x28	/* PMCS RM52X0 based FPU	ISA IV  */
#define	MIPS_RM52XX	0x28	/* PMCS RM52X0 based FPU	ISA IV  */
#define	MIPS_RM9000	0x34	/* PMCS RM9000 based FPU	ISA IV  */
#define	MIPS_VR5400	0x54	/* NEC Vr5400 FPU		ISA IV+ */
d436 1
a436 1
 *  Defines temporary until soft selected cache functions fixed.
d438 13
a450 8
#define	Mips_ConfigCache	Mips5k_ConfigCache
#define	Mips_SyncCache		Mips5k_SyncCache
#define	Mips_InvalidateICache	Mips5k_InvalidateICache
#define	Mips_InvalidateICachePage Mips5k_InvalidateICachePage
#define	Mips_SyncDCachePage	Mips5k_SyncDCachePage
#define	Mips_HitSyncDCache	Mips5k_HitSyncDCache
#define	Mips_IOSyncDCache	Mips5k_IOSyncDCache
#define	Mips_HitInvalidateDCache Mips5k_HitInvalidateDCache
d460 9
@


1.4
log
@remove LP32 defs not used
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.3 2004/08/10 20:28:13 deraadt Exp $	*/
d54 1
d59 6
d167 5
a171 5
#define RESET_EXC_VEC		0xffffffffbfc00000
#define TLB_MISS_EXC_VEC	0xffffffff80000000
#define XTLB_MISS_EXC_VEC	0xffffffff80000080
#define CACHE_ERR_EXC_VEC	0xffffffff80000100
#define GEN_EXC_VEC		0xffffffff80000180
@


1.3
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.2 2004/08/09 14:57:26 pefo Exp $	*/
a53 1
#if defined(_LP64)
a57 6
#else
#define KSEG0_BASE	0x80000000
#define KSEG1_BASE	0xa0000000
#define KSSEG_BASE	0xc0000000
#define KSEG3_BASE	0xe0000000
#endif
@


1.2
log
@Big cleanup. Removed some unused obsolete stuff and fixed copyrights
on some files. Arcbios support is now in, thus detects memorysize and cpu
clock frequency.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.1 2004/08/06 20:56:01 pefo Exp $	*/
d68 1
a68 1
#define	KSEG1_TO_PHYS(x) 	((u_long)(x) & 0x1fffffff)
d70 2
a71 2
#define	PHYS_TO_KSEG1(x) 	((u_long)(x) | KSEG1_BASE)
#define	PHYS_TO_KSEG3(x) 	((u_long)(x) | KSEG3_BASE)
@


1.1
log
@initial mips64
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.4 1998/09/15 10:50:12 pefo Exp $	*/
a359 19
/*
 * CPU identification, from PRID register.
 */
union cpuprid {
	int	cpuprid;
	struct {
#if BYTE_ORDER == BIG_ENDIAN
		u_int	pad1:16;	/* reserved */
		u_int	cp_imp:8;	/* implementation identifier */
		u_int	cp_majrev:4;	/* major revision identifier */
		u_int	cp_minrev:4;	/* minor revision identifier */
#else
		u_int	cp_minrev:4;	/* minor revision identifier */
		u_int	cp_majrev:4;	/* major revision identifier */
		u_int	cp_imp:8;	/* implementation identifier */
		u_int	pad1:16;	/* reserved */
#endif
	} cpu;
};
a422 2
union	cpuprid cpu_id;
union	cpuprid fpu_id;
d445 2
@

