head	1.39;
access;
symbols
	OPENBSD_6_2:1.39.0.6
	OPENBSD_6_2_BASE:1.39
	OPENBSD_6_1:1.39.0.4
	OPENBSD_6_1_BASE:1.39
	OPENBSD_6_0:1.38.0.10
	OPENBSD_6_0_BASE:1.38
	OPENBSD_5_9:1.38.0.6
	OPENBSD_5_9_BASE:1.38
	OPENBSD_5_8:1.38.0.8
	OPENBSD_5_8_BASE:1.38
	OPENBSD_5_7:1.38.0.2
	OPENBSD_5_7_BASE:1.38
	OPENBSD_5_6:1.38.0.4
	OPENBSD_5_6_BASE:1.38
	OPENBSD_5_5:1.36.0.8
	OPENBSD_5_5_BASE:1.36
	OPENBSD_5_4:1.36.0.4
	OPENBSD_5_4_BASE:1.36
	OPENBSD_5_3:1.36.0.2
	OPENBSD_5_3_BASE:1.36
	OPENBSD_5_2:1.33.0.2
	OPENBSD_5_2_BASE:1.33
	OPENBSD_5_1_BASE:1.32
	OPENBSD_5_1:1.32.0.6
	OPENBSD_5_0:1.32.0.4
	OPENBSD_5_0_BASE:1.32
	OPENBSD_4_9:1.32.0.2
	OPENBSD_4_9_BASE:1.32
	OPENBSD_4_8:1.30.0.4
	OPENBSD_4_8_BASE:1.30
	OPENBSD_4_7:1.30.0.2
	OPENBSD_4_7_BASE:1.30
	OPENBSD_4_6:1.20.0.4
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.16.0.4
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.16.0.2
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.15.0.2
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.13.0.2
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.8.0.6
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.4
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.2
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.7.0.4
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.2
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.5.0.2
	OPENBSD_3_6_BASE:1.5;
locks; strict;
comment	@# @;


1.39
date	2016.08.16.13.03.58;	author visa;	state Exp;
branches;
next	1.38;
commitid	6TiwRQZbesPVamIE;

1.38
date	2014.03.26.19.38.18;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2014.03.11.07.50.49;	author jasper;	state Exp;
branches;
next	1.36;

1.36
date	2012.10.03.11.18.23;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2012.09.29.19.02.26;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2012.09.29.18.58.30;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2012.03.28.20.44.23;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2010.12.28.18.40.28;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2010.12.13.10.49.48;	author kettenis;	state Exp;
branches;
next	1.30;

1.30
date	2010.02.01.05.26.17;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2010.01.18.16.58.42;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2010.01.09.23.43.43;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2009.11.19.20.15.04;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2009.10.22.22.08.54;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2009.10.22.18.46.48;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2009.10.22.18.21.40;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2009.10.07.08.35.47;	author syuu;	state Exp;
branches;
next	1.22;

1.22
date	2009.09.30.06.22.00;	author syuu;	state Exp;
branches;
next	1.21;

1.21
date	2009.09.15.04.54.31;	author syuu;	state Exp;
branches;
next	1.20;

1.20
date	2009.06.10.18.05.31;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2009.05.27.18.58.15;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2009.05.22.20.37.53;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2009.05.19.16.16.43;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2008.03.20.22.54.49;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2007.10.18.18.15.40;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2007.09.03.01.15.50;	author krw;	state Exp;
branches;
next	1.13;

1.13
date	2007.05.25.20.47.19;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2007.05.09.19.23.17;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2007.05.07.20.30.25;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2007.04.24.16.47.36;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2007.03.23.21.07.38;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2005.12.20.07.06.26;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2004.09.27.19.20.49;	author pefo;	state Exp;
branches;
next	1.6;

1.6
date	2004.09.19.20.24.38;	author pefo;	state Exp;
branches;
next	1.5;

1.5
date	2004.09.10.08.58.27;	author pefo;	state Exp;
branches;
next	1.4;

1.4
date	2004.09.09.22.11.38;	author pefo;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.10.20.15.47;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2004.08.09.14.57.26;	author pefo;	state Exp;
branches;
next	1.1;

1.1
date	2004.08.06.20.56.03;	author pefo;	state Exp;
branches;
next	;


desc
@@


1.39
log
@Remove RM7000/RM9000-specific performance counter code. It originates
from PMON2000 and has not been enabled on OpenBSD.

Suggested by and ok miod@@ (after seeing a quad_t cleanup patch of mine)
@
text
@/*	$OpenBSD: exception.S,v 1.38 2014/03/26 19:38:18 miod Exp $ */

/*
 * Copyright (c) 2002-2003 Opsycon AB  (www.opsycon.se / www.opsycon.com)
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

/*
 *  This code handles exceptions and dispatches to the
 *  correct handler depending on the exception type.
 *
 *  Exceptions are directed to the following addresses:
 *      0xffffffffbfc00000  Reset, NMI etc. Not handled by the kernel.
 *	0xffffffff80000000  TLB refill, not in exception.
 *	0xffffffff80000080  XTLB refill, not in exception.
 *	0xffffffffa0000100  Cache errors.
 *	0xffffffff80000180  Interrupts. Same as next.
 *	0xffffffff80000180  Everything else...
 */

#include <machine/param.h>
#include <machine/asm.h>
#include <machine/cpu.h>
#include <mips64/mips_cpu.h>
#include <machine/regnum.h>
#include <machine/cpustate.h>
#ifdef CPU_LOONGSON2
#include <machine/loongson2.h>
#endif

#include "assym.h"

	.set	mips3

	.text

k_exception_table:
	PTR_VAL	k_intr			/* T_INT */
	PTR_VAL	k_general		/* T_TLB_MOD */
	PTR_VAL	k_tlb_inv		/* T_TLB_LD_MISS */
	PTR_VAL	k_tlb_inv		/* T_TLB_ST_MISS */
	PTR_VAL	k_general		/* T_ADDR_ERR_LD */
	PTR_VAL	k_general		/* T_ADDR_ERR_ST */
	PTR_VAL	k_general		/* T_BUS_ERR_IFETCH */
	PTR_VAL	k_general		/* T_BUS_ERR_LD_ST */
	PTR_VAL	k_general		/* T_SYSCALL */
	PTR_VAL	k_general		/* T_BREAK */
	PTR_VAL	k_general		/* T_RES_INST */
	PTR_VAL	k_general		/* T_COP_UNUSABLE */
	PTR_VAL	k_general		/* T_OVFLOW */
	PTR_VAL	k_general		/* T_TRAP */
#ifdef CPU_R4000
	PTR_VAL	vcei			/* T_VCEI */
#else
	PTR_VAL	k_general		/* T_VCEI */
#endif
	PTR_VAL	k_general		/* T_FPE */
	PTR_VAL	k_general		/* T_IWATCH */
	PTR_VAL	k_general
	PTR_VAL	k_general		/* T_C2E */
	PTR_VAL	k_general
	PTR_VAL	k_general
	PTR_VAL	k_general
	PTR_VAL	k_general		/* T_MDMX */
	PTR_VAL	k_general		/* T_DWATCH */
	PTR_VAL	k_general		/* T_MCHECK */
	PTR_VAL	k_general
	PTR_VAL	k_general
	PTR_VAL	k_general
	PTR_VAL	k_general
	PTR_VAL	k_general
	PTR_VAL	k_general		/* T_CACHEERR */
#ifdef CPU_R4000
	PTR_VAL	vced			/* T_VCED */
#else
	PTR_VAL	k_general		/* T_VCED */
#endif

u_exception_table:
	PTR_VAL	u_intr			/* T_INT */
	PTR_VAL	u_general		/* T_TLB_MOD */
	PTR_VAL	u_general		/* T_TLB_LD_MISS */
	PTR_VAL	u_general		/* T_TLB_ST_MISS */
	PTR_VAL	u_general		/* T_ADDR_ERR_LD */
	PTR_VAL	u_general		/* T_ADDR_ERR_ST */
	PTR_VAL	u_general		/* T_BUS_ERR_IFETCH */
	PTR_VAL	u_general		/* T_BUS_ERR_LD_ST */
	PTR_VAL	u_general		/* T_SYSCALL */
	PTR_VAL	u_general		/* T_BREAK */
	PTR_VAL	u_general		/* T_RES_INST */
	PTR_VAL	u_general		/* T_COP_UNUSABLE */
	PTR_VAL	u_general		/* T_OVFLOW */
	PTR_VAL	u_general		/* T_TRAP */
#ifdef CPU_R4000
	PTR_VAL	vcei			/* T_VCEI */
#else
	PTR_VAL	u_general		/* T_VCEI */
#endif
	PTR_VAL	u_general		/* T_FPE */
	PTR_VAL	u_general		/* T_IWATCH */
	PTR_VAL	u_general
	PTR_VAL	u_general		/* T_C2E */
	PTR_VAL	u_general
	PTR_VAL	u_general
	PTR_VAL	u_general
	PTR_VAL	u_general		/* T_MDMX */
	PTR_VAL	u_general		/* T_DWATCH */
	PTR_VAL	u_general		/* T_MCHECK */
	PTR_VAL	u_general
	PTR_VAL	u_general
	PTR_VAL	u_general
	PTR_VAL	u_general
	PTR_VAL	u_general
	PTR_VAL	u_general		/* T_CACHEERR */
#ifdef CPU_R4000
	PTR_VAL	vced			/* T_VCED */
#else
	PTR_VAL	u_general		/* T_VCED */
#endif

	.set	noreorder		# Noreorder is default style!

/*---------------------------------------------------------------- exception
 *	General exception handler dispatcher. This code is copied
 *	to the vector area and must thus be PIC and less than 128
 *	bytes long to fit. Only k0 and k1 may be used at this time.
 */
	.globl	cache_err
cache_err:
#ifdef CPU_R4000
	nop
#endif
	.globl	exception
exception:
	.set	noat
#ifdef CPU_LOONGSON2
	/*
	 * To work around a branch prediction issue on earlier LS2F
	 * chips, it is necessary to clear the BTB upon
	 * userland->kernel boundaries.
	 */
	li	k0, COP_0_DIAG_BTB_CLEAR | COP_0_DIAG_RAS_DISABLE
	dmtc0	k0, COP_0_DIAG
#endif
	MFC0	k0, COP_0_STATUS_REG
	MFC0	k1, COP_0_CAUSE_REG
	and	k0, k0, SR_KSU_USER
	beqz	k0, k_exception		# Kernel mode mode
	and	k1, k1, CR_EXC_CODE

	LA	k0, u_exception_table
	PTR_ADDU k0, k0, k1
	PTR_ADDU k0, k0, k1		# yes, twice...
	PTR_L	k0, 0(k0)
	j	k0
	nop

k_exception:
	LA	k0, k_exception_table
	PTR_ADDU k0, k0, k1
	PTR_ADDU k0, k0, k1		# yes, twice...
	PTR_L	k0, 0(k0)
	j	k0
	nop
	.set	at
	.globl	e_exception
e_exception:


/*---------------------------------------------------------------- k_intr
 *	Handle an interrupt in kernel mode. This is easy since we
 *	just need to save away the 'save' registers and state.
 *	State is saved on kernel stack.
 */

NNON_LEAF(k_intr, FRAMESZ(KERN_EXC_FRAME_SIZE), ra)
	.set	noat
	.mask	0x80000000, (CF_RA_OFFS - FRAMESZ(KERN_EXC_FRAME_SIZE))
	PTR_SUB	k0, sp, FRAMESZ(KERN_EXC_FRAME_SIZE)
	SAVE_CPU(k0, CF_RA_OFFS)
#ifdef RM7000_ICR
	cfc0	v1, COP_0_ICR
	SAVE_REG(v1, IC, k0, CF_RA_OFFS)
#endif
	.set	at
	move	sp, k0			# Already on kernel stack
	LA	gp, _gp
	and	t0, a1, ~(SR_COP_1_BIT | SR_EXL | SR_INT_ENAB | SR_KSU_MASK)
	MTC0	t0, COP_0_STATUS_REG
	MTC0_SR_IE_HAZARD
	PTR_S	a0, 0(sp)
	jal	interrupt
	PTR_S	a3, CF_RA_OFFS + KERN_REG_SIZE(sp)

	PTR_L	a0, CF_RA_OFFS + KERN_REG_SIZE(sp)
	.set	noat
#ifdef RM7000_ICR
	RESTORE_REG(t0, IC, sp, CF_RA_OFFS)
	ctc0	t0, COP_0_ICR
#endif
	RESTORE_CPU(sp, CF_RA_OFFS)
	PTR_ADDU sp, sp, FRAMESZ(KERN_EXC_FRAME_SIZE)
	ERET
	.set	at
END(k_intr)

/*---------------------------------------------------------------- u_intr
 *	Handle an interrupt in user mode. Save the relevant user
 *	registers into the u.u_pcb struct. This will allow us
 *	to preempt the interrupted process. Full save is held
 *	off though until a switch() really is required.
 */
NNON_LEAF(u_intr, FRAMESZ(CF_SZ), ra)
	.set	noat
	.mask	0x80000000, (CF_RA_OFFS - FRAMESZ(CF_SZ))
	GET_CPU_INFO(k1, k0)
	PTR_L	k0, CI_CURPROCPADDR(k1)
	SAVE_CPU(k0, 0)
#ifdef RM7000_ICR
	cfc0	v1, COP_0_ICR
	SAVE_REG(v1, IC, k0, 0)
#endif
	PTR_ADDU sp, k0, USPACE-FRAMESZ(CF_SZ)
	LA	gp, _gp
	.set	at
	and	t0, a1, ~(SR_COP_1_BIT | SR_EXL | SR_INT_ENAB | SR_KSU_MASK)
	MTC0	t0, COP_0_STATUS_REG
	MTC0_SR_IE_HAZARD
	PTR_S	a0, 0(sp)
	jal	interrupt
	PTR_S	a3, CF_RA_OFFS(sp)	# for debugging

	MFC0	t0, COP_0_STATUS_REG	# enable interrupts before checking
	ori	t0, SR_INT_ENAB		# for ast.
	MTC0	t0, COP_0_STATUS_REG
	MTC0_SR_IE_HAZARD

	GET_CPU_INFO(t1, t0)
0:
	PTR_L	t0, CI_CURPROC(t1)
	lw	v0, P_ASTPENDING(t0)	# any pending AST?
	beq	v0, zero, 4f
	nop

	PTR_L	t0, CI_CURPROCPADDR(t1)	# curprocpaddr
	SAVE_CPU_SREG(t0, 0)

	jal	ast
	nop

/*
 * Restore user registers and return. NOTE: interrupts are enabled.
 */
	GET_CPU_INFO(t1, t0)
	PTR_L	t0, CI_CURPROCPADDR(t1)
	RESTORE_CPU_SREG(t0, 0)

	b	0b
	nop

4:
	MFC0	t0, COP_0_STATUS_REG	# disable interrupts
	LI	v0, ~SR_INT_ENAB
	and	t0, t0, v0
	MTC0	t0, COP_0_STATUS_REG
	MTC0_SR_IE_HAZARD

	ori	t0, SR_EXL		# restoring to user mode.
	MTC0	t0, COP_0_STATUS_REG	# must set exception level bit.
	MTC0_SR_IE_HAZARD

	# t1 is curcpu() from earlier
	move	k1, t1
	PTR_L	k0, CI_CURPROCPADDR(k1)
	RESTORE_REG(a3, CPL, k0, 0)
	sw	a3, CI_IPL(k1)
	.set	noat
	RESTORE_REG(a0, PC, k0, 0)
#ifdef RM7000_ICR
	RESTORE_REG(t0, IC, k0, 0)
	ctc0	t0, COP_0_ICR
#endif
	RESTORE_CPU(k0, 0)
	RESTORE_REG(sp, SP, k0, 0)
	LI	k0, 0
	LI	k1, 0
	ERET
	.set	at
END(u_intr)

/*---------------------------------------------------------------- k_general
 *	Handle a kernel general trap. This is very much like
 *	k_intr except that we call ktrap instead of interrupt.
 */

NNON_LEAF(k_general, FRAMESZ(KERN_EXC_FRAME_SIZE), ra)
	.set	noat
	.mask	0x80000000, (CF_RA_OFFS - FRAMESZ(KERN_EXC_FRAME_SIZE))
	PTR_SUB	k0, sp, FRAMESZ(KERN_EXC_FRAME_SIZE)
	SAVE_CPU(k0, CF_RA_OFFS)
#ifdef RM7000_ICR
	cfc0	v1, COP_0_ICR
	SAVE_REG(v1, IC, k0, CF_RA_OFFS)
#endif
#if defined(DDB)
	SAVE_CPU_SREG(k0, CF_RA_OFFS)
#endif
	.set	at
	move	sp, k0			# Already on kernel stack
	LA	gp, _gp
	and	t0, a1, ~(SR_COP_1_BIT | SR_EXL | SR_INT_ENAB | SR_KSU_MASK)
	MTC0	t0, COP_0_STATUS_REG
	MTC0_SR_IE_HAZARD
	PTR_S	a0, 0(sp)
	jal	trap
	PTR_S	a3, CF_RA_OFFS + KERN_REG_SIZE(sp)

	MFC0	t0, COP_0_STATUS_REG	# disable interrupts
	LI	t1, ~SR_INT_ENAB
	and	t0, t0, t1
	MTC0	t0, COP_0_STATUS_REG
	MTC0_SR_IE_HAZARD

	.set	noat
#ifdef RM7000_ICR
	RESTORE_REG(t0, IC, sp, CF_RA_OFFS)
	ctc0	t0, COP_0_ICR
#endif
	RESTORE_REG(a0, PC, sp, CF_RA_OFFS)
	RESTORE_CPU(sp, CF_RA_OFFS)
	PTR_ADDU sp, sp, FRAMESZ(KERN_EXC_FRAME_SIZE)
	ERET
	.set	at
END(k_general)

/*---------------------------------------------------------------- u_general
 *	Handle a user general trap.
 */
NNON_LEAF(u_general, FRAMESZ(CF_SZ), ra)
	.set	noat
	.mask	0x80000000, (CF_RA_OFFS - FRAMESZ(CF_SZ))

	GET_CPU_INFO(k1, k0)
	PTR_L	k0, CI_CURPROCPADDR(k1)
	SAVE_CPU(k0, 0)
#ifdef RM7000_ICR
	cfc0	v1, COP_0_ICR
	SAVE_REG(v1, IC, k0, 0)
#endif
	SAVE_CPU_SREG(k0, 0)
	PTR_ADDU sp, k0, USPACE-FRAMESZ(CF_SZ)
	LA	gp, _gp
	.set	at
	and	t0, a1, ~(SR_COP_1_BIT | SR_EXL | SR_INT_ENAB | SR_KSU_MASK)
	MTC0	t0, COP_0_STATUS_REG
	MTC0_SR_IE_HAZARD

	jal	trap
	PTR_S	a3, CF_RA_OFFS(sp)		# for debugging

0:
	GET_CPU_INFO(t1, t0)
	PTR_L	t0, CI_CURPROC(t1)
	lw	v0, P_ASTPENDING(t0)	# any pending AST?
	beq	v0, zero, 4f
	nop

	jal	ast
	nop

	b	0b
	nop

4:
	MFC0	t0, COP_0_STATUS_REG	# disable interrupts
	LI	t1, ~SR_INT_ENAB
	and	t0, t0, t1
	MTC0	t0, COP_0_STATUS_REG
	MTC0_SR_IE_HAZARD

	ori	t0, SR_EXL		# restoring to user mode.
	MTC0	t0, COP_0_STATUS_REG	# must set exception level bit.
	MTC0_SR_IE_HAZARD

	GET_CPU_INFO(k1, k0)
	PTR_L	k0, CI_CURPROCPADDR(k1)
	RESTORE_REG(a3, CPL, k0, 0)
	sw	a3, CI_IPL(k1)
	.set	noat
	RESTORE_CPU_SREG(k0, 0)
	RESTORE_REG(a0, PC, k0, 0)
#ifdef RM7000_ICR
	RESTORE_REG(t0, IC, k0, 0)
	ctc0	t0, COP_0_ICR
#endif
	RESTORE_CPU(k0, 0)
	RESTORE_REG(sp, SP, k0, 0)
	LI	k0, 0
	LI	k1, 0
	ERET
	.set	at
END(u_general)

#ifdef CPU_R4000
LEAF(vced, 0)
	.set	noat
	dmfc0	k0, COP_0_BAD_VADDR
	ori	k0, k0, 3		# need to align badvaddr...
	xori	k0, k0, 3		# ...to a word boundary.
	cache	0x17, 0(k0)		# HitWBInvalidate_S
	cache	0x11, 0(k0)		# HitWBInvalidate_D
	LI	k0, 0
	ERET
	.set	at
END(vced)

LEAF(vcei, 0)
	.set	noat
	dmfc0	k0, COP_0_BAD_VADDR
	cache	0x17, 0(k0)		# HitWBInvalidate_S
	cache	0x10, 0(k0)		# HitInvalidate_I
	LI	k0, 0
	ERET
	.set	at
END(vcei)
#endif
@


1.38
log
@Service R4[04]00SC-specific virtual coherency exceptions directly from the
lowest bowels of the exception handling code, rather than in trap(). They
won't get recorded in the trap history, but there is a measurable speedup.

No change for non-CPU_R4000 kernels.
@
text
@d1 1
a1 1
/*	$OpenBSD: exception.S,v 1.37 2014/03/11 07:50:49 jasper Exp $ */
a268 22
#ifdef PERFCNTRS
	lw	t0, cpu_is_rm7k
	beqz	t0, 1f			# not an RM7K. Don't do perf save.
	nop

	mfc0	v0, COP_0_PC_CTRL
	PTR_L	t0, curproc
	sw	v0, P_PC_CTRL(t0)
	dmfc0	v0, COP_0_WATCH_1
	dmfc0	v1, COP_0_WATCH_2
	sd	v0, P_WATCH_1(t0)
	sd	v1, P_WATCH_2(t0)
	mfc0	v0, COP_0_WATCH_M
	mfc0	v1, COP_0_PC_COUNT
	sw	v0, P_WATCH_M(t0)
	sw	v1, P_PC_COUNT(t0)
	mtc0	zero, COP_0_PC_CTRL
	dmtc0	zero, COP_0_WATCH_1
	dmtc0	zero, COP_0_WATCH_2
	nop;nop;nop;nop
1:
#endif
a274 21
#ifdef PERFCNTRS
	lw	t0, cpu_is_rm7k
	beqz	t0, 1f			# not an RM7K. Don't do perf setup.

	GET_CPU_INFO(t1, t0)
	PTR_L	t0, CI_CURPROC(t1)	# set up rm7k.
	ld	v0, P_WATCH_1(t1)
	dmtc0	v0, COP_0_WATCH_1
	ld	v0, P_WATCH_2(t1)
	dmtc0	v0, COP_0_WATCH_2
	lw	v0, P_WATCH_M(t1)
	mtc0	v0, COP_0_WATCH_M
	lw	v0, P_PC_CTRL(t1)
	lw	v1, P_PC_COUNT(t1)
	nop;nop
	mtc0	v0, COP_0_PC_CTRL
	nop;nop;nop;nop
	mtc0	v1, COP_0_PC_COUNT
	nop;nop;nop;nop
1:
#endif
a378 21
#ifdef PERFCNTRS
	lw	t0, cpu_is_rm7k
	beqz	t0, 1f			# not an RM7K. Don't do perf save.
	nop

	mfc0	v0, COP_0_PC_CTRL
	PTR_L	t0, CI_CURPROC(k1)
	sw	v0, P_PC_CTRL(t0)
	dmfc0	v0, COP_0_WATCH_1
	dmfc0	v1, COP_0_WATCH_2
	sd	v0, P_WATCH_1(t0)
	sd	v1, P_WATCH_2(t0)
	mfc0	v0, COP_0_WATCH_M
	mfc0	v1, COP_0_PC_COUNT
	sw	v0, P_WATCH_M(t0)
	sw	v1, P_PC_COUNT(t0)
	mtc0	zero, COP_0_PC_CTRL
	nop;nop;nop;nop
1:
#endif

a395 21
#ifdef PERFCNTRS
	lw	t0, cpu_is_rm7k
	beqz	t0, 1f			# not an RM7K. Don't do perf setup.

	GET_CPU_INFO(t1, t0)
	PTR_L	t0, CI_CURPROC(k1)	# set up rm7k.
	ld	v0, P_WATCH_1(t0)
	dmtc0	v0, COP_0_WATCH_1
	ld	v0, P_WATCH_2(t0)
	dmtc0	v0, COP_0_WATCH_2
	lw	v0, P_WATCH_M(t0)
	mtc0	v0, COP_0_WATCH_M
	lw	v0, P_PC_CTRL(t0)
	lw	v1, P_PC_COUNT(t0)
	nop;nop
	mtc0	v0, COP_0_PC_CTRL
	nop;nop;nop;nop
	mtc0	v1, COP_0_PC_COUNT
	nop;nop;nop;nop
1:
#endif
@


1.37
log
@remove #if(n)def __LP64__ from the mips64 codebase, as mips32 never really went anywhere.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exception.S,v 1.36 2012/10/03 11:18:23 miod Exp $ */
d59 21
a79 23
	PTR_VAL	k_intr
	PTR_VAL	k_general
	PTR_VAL	k_tlb_inv
	PTR_VAL	k_tlb_inv
	PTR_VAL	k_general
	PTR_VAL	k_general
	PTR_VAL	k_general
	PTR_VAL	k_general
	PTR_VAL	k_general
	PTR_VAL	k_general
	PTR_VAL	k_general
	PTR_VAL	k_general
	PTR_VAL	k_general
	PTR_VAL	k_general
	PTR_VAL	k_general
	PTR_VAL	k_general
	PTR_VAL	k_general
	PTR_VAL	k_general
	PTR_VAL	k_general
	PTR_VAL	k_general
	PTR_VAL	k_general
	PTR_VAL	k_general
	PTR_VAL	k_general
d81 1
d85 3
d93 6
d101 21
a121 23
	PTR_VAL	u_intr
	PTR_VAL	u_general
	PTR_VAL	u_general
	PTR_VAL	u_general
	PTR_VAL	u_general
	PTR_VAL	u_general
	PTR_VAL	u_general
	PTR_VAL	u_general
	PTR_VAL	u_general
	PTR_VAL	u_general
	PTR_VAL	u_general
	PTR_VAL	u_general
	PTR_VAL	u_general
	PTR_VAL	u_general
	PTR_VAL	u_general
	PTR_VAL	u_general
	PTR_VAL	u_general
	PTR_VAL	u_general
	PTR_VAL	u_general
	PTR_VAL	u_general
	PTR_VAL	u_general
	PTR_VAL	u_general
	PTR_VAL	u_general
d123 1
d127 3
d135 6
d272 1
d425 1
d509 24
@


1.36
log
@Split ever-growing mips <machine/cpu.h> into what 99% of the kernel needs,
which will remain in <machine/cpu.h>, and a new mips_cpu.h containing only the
goriest md details, which are only of interest to a handful set of files; this
is similar in spirit to what alpha does, but here <machine/cpu.h> does not
include the new file.
@
text
@d1 1
a1 1
/*	$OpenBSD: exception.S,v 1.35 2012/09/29 19:02:26 miod Exp $ */
a157 1
#ifdef __LP64__
a158 1
#endif
a165 1
#ifdef __LP64__
a166 1
#endif
@


1.35
log
@Introduce assembly macros for specific processor hazards: tlb update, status
register update, status register update causing a change to the interrupt
enable flag, and a few other arcane ones. <mips64/asm.h> will provide
(supposedly sane) defaults, and <machine/asm.h> may override these with
better tuned versions.

Use these macros instead of random strings of nop in the various .S files
requiring hazard workarounds.
@
text
@d1 1
a1 1
/*	$OpenBSD: exception.S,v 1.34 2012/09/29 18:58:30 miod Exp $ */
d45 1
@


1.34
log
@Move proc_trampoline, which is not really exception processing, from exception.S
to context.S, to eventually allow alternate versions of exception.S to be used.
@
text
@d1 1
a1 1
/*	$OpenBSD: exception.S,v 1.33 2012/03/28 20:44:23 miod Exp $ */
d149 2
a150 2
	mfc0	k0, COP_0_STATUS_REG
	mfc0	k1, COP_0_CAUSE_REG
d197 2
a198 3
	mtc0	t0, COP_0_STATUS_REG
	ITLBNOPFIX
	ITLBNOPFIX			# XXX necessary?
d211 1
a211 2
	sync
	eret
d235 2
a236 3
	mtc0	t0, COP_0_STATUS_REG
	ITLBNOPFIX
	ITLBNOPFIX			# XXX necessary?
d241 1
a241 1
	mfc0	t0, COP_0_STATUS_REG	# enable interrupts before checking
d243 2
a244 2
	mtc0	t0, COP_0_STATUS_REG
	ITLBNOPFIX
d312 2
a313 2
	mfc0	t0, COP_0_STATUS_REG	# disable interrupts
	li	v0, ~SR_INT_ENAB
d315 2
a316 2
	mtc0	t0, COP_0_STATUS_REG
	ITLBNOPFIX
d319 2
a320 2
	mtc0	t0, COP_0_STATUS_REG	# must set exception level bit.
	ITLBNOPFIX
d337 1
a337 2
	sync
	eret
d362 2
a363 2
	mtc0	t0, COP_0_STATUS_REG
	ITLBNOPFIX
d368 2
a369 2
	mfc0	t0, COP_0_STATUS_REG	# disable interrupts
	li	t1, ~SR_INT_ENAB
d371 2
a372 2
	mtc0	t0, COP_0_STATUS_REG
	ITLBNOPFIX
d382 1
a382 2
	sync
	eret
d405 2
a406 2
	mtc0	t0, COP_0_STATUS_REG
	ITLBNOPFIX
d449 2
a450 1
	LOAD	t0, CI_CURPROC(k1)	# set up rm7k.
d466 2
a467 2
	mfc0	t0, COP_0_STATUS_REG	# disable interrupts
	li	t1, ~SR_INT_ENAB
d469 2
a470 2
	mtc0	t0, COP_0_STATUS_REG
	ITLBNOPFIX
d473 2
a474 2
	mtc0	t0, COP_0_STATUS_REG	# must set exception level bit.
	ITLBNOPFIX
d491 1
a491 2
	sync
	eret
@


1.33
log
@Work in progress support for the SGI Indigo, Indigo 2 and Indy systems
(IP20, IP22, IP24) in 64-bit mode, adapated from NetBSD. Currently limited
to headless operation, input and video drivers will get ported soon.

Should work on all R4000, R4440 and R5000 based systems. L2 cache on R5000SC
Indy not supported yet (coming soon), R4600 not supported yet either (coming
soon as well).

Tested to boot multiuser on: Indigo2 R4000SC, Indy R4000PC, Indy R4000SC,
Indy R5000SC, Indigo2 R4400SC. There are still glitches in the Ethernet driver
which are being looked at.

Expansion support is limited to the GIO E++ board; GIO boards with PCI-GIO
bridges not ported yet due to the lack of hardware, and this kind of driver
does not port blindly.

Most of this work comes from NetBSD, polishing and integration work, as well
as putting as many ``R4x00 in 64-bit mode'' erratas as necessary, by yours
truly.

More work is coming, as well as trying to get some easy way to boot install
kernels (as older PROM can only boot ECOFF binaries, which won't do for the
kernel).
@
text
@d1 1
a1 1
/*	$OpenBSD: exception.S,v 1.32 2010/12/28 18:40:28 miod Exp $ */
a498 77

/*-------------------------------------------------------------- proc_trampoline
 *	Setup for and return to user.
 */
LEAF(proc_trampoline, 0)
#ifdef DDB
	move	zero, ra
#endif
#ifdef MULTIPROCESSOR
	jal	_C_LABEL(proc_trampoline_mp)
	nop
#endif
	/*
	 * Enable interrupts, since we want kernel threads to
	 * start at spl0 and with interrupts enabled, and these
	 * won't ``return to userland''.
	 */
#ifndef MULTIPROCESSOR	/* done by proc_trampoline_mp() */
	jal	splx
	xor	a0, a0
#endif
	jal	updateimask		# Make sure SR imask is updated
	xor	a0, a0			# and interrupts enabled

	jal	s0
	move	a0,s1			# invoke callback.

#if 0	/* && defined(RM7000_ICR) */
	lw	t0, cpu_is_rm7k
	beqz	t0, 1f			# not an RM7K. Don't do IC reg.

	LOAD	t0, curproc		# set up rm7k.
	ld	v0, P_WATCH_1(t0)
	dmtc0	v0, COP_0_WATCH_1
	ld	v0, P_WATCH_2(t0)
	dmtc0	v0, COP_0_WATCH_2
	lw	v0, P_WATCH_M(t0)
	mtc0	v0, COP_0_WATCH_M
	lw	v0, P_PC_CTRL(t0)
	lw	v1, P_PC_COUNT(t0)
	nop;nop
	mtc0	v0, COP_0_PC_CTRL
	nop;nop;nop;nop
	mtc0	v1, COP_0_PC_COUNT
	nop;nop;nop;nop
	li	v0, IC_INT_PERF
	ctc0	v0, COP_0_ICR		# enable perfcntr interrupt.
1:
#endif

	mfc0	t0, COP_0_STATUS_REG
	li	t1, ~SR_INT_ENAB
	and	t0, t0, t1
	mtc0	t0, COP_0_STATUS_REG
	ITLBNOPFIX

	ori	t0, SR_EXL		# restoring to user mode.
	mtc0	t0, COP_0_STATUS_REG	# must set exception level bit.
	ITLBNOPFIX

	.set	noat
	GET_CPU_INFO(k1, k0)
	PTR_L	k0, CI_CURPROCPADDR(k1)
	RESTORE_CPU_SREG(k0, 0)
	RESTORE_REG(a0, PC, k0, 0)
#ifdef RM7000_ICR
	RESTORE_REG(t0, IC, k0, 0)
	ctc0	t0, COP_0_ICR
#endif
	RESTORE_CPU(k0, 0)
	RESTORE_REG(sp, SP, k0, 0)
	LI	k0, 0
	LI	k1, 0
	sync
	eret
	.set	at
END(proc_trampoline)
@


1.32
log
@Previous diff had a buglet, found the hard way by pea@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exception.S,v 1.31 2010/12/13 10:49:48 kettenis Exp $ */
d132 5
@


1.31
log
@Remove superfluous SAVE_CPU_SREG()/RESTORE_CPU_SREG() around ast() call in
u_general exception handler.  The SAVE_CPU_SREG() is actually harmful, since
it overwrites any changes made to to s0-s8 in the trapframe by ptrace(2).
Fixes some issues with GDB.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exception.S,v 1.30 2010/02/01 05:26:17 miod Exp $ */
d431 1
a432 1
0:
@


1.30
log
@On Loongson 2 processors, clear the branch target buffer on userland->kernel
transitions, to work around an evil horde of evil bugs in the processor's
branch prediction logic.

This finally makes the Lemote Yeeloong stable, and I can now spend my
time looking for hair implants resellers.
@
text
@d1 1
a1 1
/*	$OpenBSD: exception.S,v 1.29 2010/01/18 16:58:42 miod Exp $ */
a437 3
	PTR_L	t0, CI_CURPROCPADDR(t1)	# curprocpaddr
	SAVE_CPU_SREG(t0, 0)

a439 4

	GET_CPU_INFO(t1, t0)
	PTR_L	t0, CI_CURPROCPADDR(t1)
	RESTORE_CPU_SREG(t0, 0)
@


1.29
log
@In proc_trampoline(), don't spl0() if option MULTIPROCESSOR; this is already
done for us by proc_trampoline_mp().
@
text
@d1 1
a1 1
/*	$OpenBSD: exception.S,v 1.28 2010/01/09 23:43:43 miod Exp $ */
d47 3
d135 9
@


1.28
log
@Make interrupt depth counters per-cpu.
@
text
@d1 1
a1 1
/*	$OpenBSD: exception.S,v 1.27 2009/11/19 20:15:04 miod Exp $ */
d494 3
d506 1
d509 1
@


1.27
log
@All callers of updateimask() immediately enable interrupts afterwards, so do
it in updateimask() itself. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: exception.S,v 1.26 2009/10/22 22:08:54 miod Exp $ */
a51 4
	.data
	.globl	int_nest_cntr
int_nest_cntr:
	.word	-1
d182 1
a182 5
	LA	t1, int_nest_cntr
	lw	t2, (t1)
	addiu	t2, 1
	sw	t2, (t1)
	ITLBNOPFIX
a186 5
	LA	t1, int_nest_cntr
	lw	t2, (t1)
	addiu	t2, -1
	sw	t2, (t1)

d222 1
a222 5
	LA	t1, int_nest_cntr
	lw	t2, (t1)
	addiu	t2, 1
	sw	t2, (t1)
	ITLBNOPFIX
d225 1
a225 1
	PTR_S	a3, CF_RA_OFFS(sp)		# for debugging
d232 1
a233 1
	GET_CPU_INFO(t1, t0)
d299 2
a300 2
	li	t1, ~SR_INT_ENAB
	and	t0, t0, t1
a303 5
	LA	t1, int_nest_cntr
	lw	t2, (t1)
	addiu	t2, -1
	sw	t2, (t1)

d308 2
a309 1
	GET_CPU_INFO(k1, k0)
d419 1
a420 1
	GET_CPU_INFO(t1, t0)
d426 1
a426 1
	PTR_L	t0, P_ADDR(t0)		# curprocpaddr
@


1.26
log
@Completely overhaul interrupt handling on sgi. Cpu state now only stores a
logical IPL level, and per-platform (IP27/IP30/IP32) code will from the
necessary hardware mask registers.

This allows the use of more than one interrupt mask register. Also, the
generic (platform independent) interrupt code shrinks a lot, and the actual
interrupt handler chains and masking information is now per-platform private
data.

Interrupt dispatching is generated from a template; more routines will be
added to the template to reduce platform-specific changes and share as much
code as possible.

Tested on IP27, IP30, IP32 and IP35.
@
text
@d1 1
a1 1
/*	$OpenBSD: exception.S,v 1.25 2009/10/22 18:46:48 miod Exp $ */
d527 1
a527 6
	xor	a0, a0

	mfc0	t0, COP_0_STATUS_REG	# enable interrupts
	ori	t0, SR_INT_ENAB
	mtc0	t0, COP_0_STATUS_REG
	ITLBNOPFIX
@


1.25
log
@Change the #define controlling use of RM7k/RM9k coprocessor 0 ICR to
RM7000_ICR, instead of IMASK_EXTERNAL, since they are actually different
concepts. This code remains disabled since RM7000_ICR is not defined anywhere
at the moment.
@
text
@d1 1
a1 1
/*	$OpenBSD: exception.S,v 1.24 2009/10/22 18:21:40 miod Exp $ */
d333 1
a333 1
	sw	a3, CI_CPL(k1)
d494 1
a494 1
	sw	a3, CI_CPL(k1)
@


1.24
log
@At the end of a context switch and in proc_trampoline(), instead of doing the
`restore cpl and invoke hw_setintrmask' slippery dance, just invoke splx().
@
text
@d1 1
a1 1
/*	$OpenBSD: exception.S,v 1.23 2009/10/07 08:35:47 syuu Exp $ */
d176 1
a176 1
#if 0
d202 1
a202 1
#if 0
d225 1
a225 1
#if 0
d336 1
a336 1
#if 0
d359 1
a359 1
#if 0
d383 1
a383 1
#if 0
d405 1
a405 1
#if 0
d498 1
a498 1
#if 0
d537 1
a537 1
#if 0
d575 1
a575 1
#if 0
@


1.23
log
@ipending, cpl moved into cpu_info
OK miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exception.S,v 1.22 2009/09/30 06:22:00 syuu Exp $ */
d524 1
a524 11
	GET_CPU_INFO(t0, t1)
	sw	zero, CI_CPL(t0)	# lower to spl0
	lw	t0, CI_IPENDING(t0)
	beqz	t0, 1f
	nop

	jal	setsoftintr0		# process any pending ints
	nop
1:
#ifdef IMASK_EXTERNAL
	jal	hw_setintrmask
a525 1
#endif
@


1.22
log
@curproc, curprocpaddr moved into cpu_info
OK miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exception.S,v 1.21 2009/09/15 04:54:31 syuu Exp $ */
d333 1
a333 1
	sw	a3, cpl
d494 1
a494 1
	sw	a3, cpl
d524 3
a526 2
	sw	zero, cpl		# lower to spl0
	lw	t0, ipending
@


1.21
log
@cpu status flag, cpuid added to cpu_info.
cpu_info pointer array, cpu_info iterator, cpu_number() implementation added.
constraint modifier fixed in lock.h to output correct assembly.
calling proc_trampoline_mp in exception.S.
@
text
@d1 1
a1 1
/*	$OpenBSD: exception.S,v 1.20 2009/06/10 18:05:31 miod Exp $ */
a49 2
#define curproc	(cpu_info_primary + CI_CURPROC)

d222 2
a223 1
	PTR_L	k0, curprocpaddr
d250 2
a251 1
	PTR_L	t0, curproc
d256 1
a256 1
	PTR_L	t0, P_ADDR(t0)		# curprocpaddr
d290 2
a291 1
	PTR_L	t1, curproc		# set up rm7k.
d307 2
a308 1
	PTR_L	t0, curprocpaddr
d330 2
a331 1
	PTR_L	k0, curprocpaddr
d402 2
a403 1
	PTR_L	k0, curprocpaddr
d422 1
a422 1
	PTR_L	t0, curproc
d441 2
a442 1
	PTR_L	t0, curproc
d453 2
a454 1
	PTR_L	t0, curprocpaddr
d465 1
a465 1
	LOAD	t0, curproc		# set up rm7k.
d491 2
a492 1
	PTR_L	k0, curprocpaddr
d581 2
a582 1
	PTR_L	k0, curprocpaddr
@


1.20
log
@Switch sgi to per-process AST, and move ast() from interrupt.c to trap.c
where it can use userret() instead of duplicating it.
@
text
@d1 1
a1 1
/*	$OpenBSD: exception.S,v 1.19 2009/05/27 18:58:15 miod Exp $ */
d508 4
@


1.19
log
@Rename the ast processing function from softintr() to ast(), to reduce
confusion. Make sure this function is invoked with interrupts enabled now.
@
text
@d1 1
a1 1
/*	$OpenBSD: exception.S,v 1.18 2009/05/22 20:37:53 miod Exp $ */
d50 2
d251 2
a252 1
	lw	v0, astpending		# any pending interrupts?
d256 1
a256 1
	PTR_L	t0, curprocpaddr
d437 3
a439 2
	lw	v0, astpending
	beqz	v0, 4f
d442 1
a442 1
	PTR_L	t0, curprocpaddr
@


1.18
log
@Drop almost unused <machine/psl.h> on sgi; move USERMODE() definition from
there to trap.c which is its only user. This also cleans up multiple
inclusion of <machine/cpu.h> (because <machine/psl.h> includes it) in many
places.
@
text
@d1 1
a1 1
/*	$OpenBSD: exception.S,v 1.17 2009/05/19 16:16:43 miod Exp $ */
d185 1
a194 5
	mfc0	t0, COP_0_STATUS_REG	# dis int preserve settings.
	li	t1, ~SR_INT_ENAB
	and	t0, t0, t1
	mtc0	t0, COP_0_STATUS_REG

d233 1
d243 5
d277 1
a277 1
	jal	softintr
d279 1
d310 1
a310 1
	mfc0	t0, COP_0_STATUS_REG	# dis int preserve settings.
d314 1
d323 1
d370 1
a370 1
	mfc0	t0, COP_0_STATUS_REG	# dis int preserve settings.
d374 1
d441 1
a441 1
	jal	softintr
d471 1
a471 1
	mfc0	t0, COP_0_STATUS_REG	# dis int preserve settings.
@


1.17
log
@Processing AST can trigger more AST. Loop on astpending instead of checking
only once.
@
text
@d1 1
a1 1
/*	$OpenBSD: exception.S,v 1.16 2008/03/20 22:54:49 miod Exp $ */
a42 1
#include <machine/psl.h>
a492 113

#ifdef notyet
/*---------------------------------------------------------------- u_syscall
 *	Syscall exceptions are special such that they can be
 *	optimized by not saving more than what is really needed.
 *	Syscalls are actually 'function calls' from the user
 *	programs point of view and thus it does not expect us to
 *	save away all temporary registers etc. Just save state and
 *	args to avoid a lot of overhead.
 */
NNON_LEAF(u_syscall, FRAMESZ(CF_SZ), ra)
	.set	noat
	.mask	0x80000000, (CF_RA_OFFS - FRAMESZ(CF_SZ))

	REG_S	a0, UADDR+PCB_REGS+(A0 * REGSZ)
	REG_S	a1, UADDR+PCB_REGS+(A1 * REGSZ)
	REG_S	a2, UADDR+PCB_REGS+(A2 * REGSZ)
	REG_S	a3, UADDR+PCB_REGS+(A3 * REGSZ)
	mfc0	a0, COP_0_STATUS_REG	# First arg is the status reg.
	mfc0	a1, COP_0_CAUSE_REG	# Second arg is the cause reg.
	dmfc0	a3, COP_0_EXC_PC		# Fourth arg is the pc.
	REG_S	sp, UADDR+PCB_REGS+(SP * REGSZ)
	LA	sp, KERNELSTACK - FRAMESZ(CF_SZ)	# switch to kernel SP
	REG_S	ra, UADDR+PCB_REGS+(RA * REGSZ)
	REG_S	a0, UADDR+PCB_REGS+(SR * REGSZ)
	REG_S	a1, UADDR+PCB_REGS+(CAUSE * REGSZ)
	REG_S	a3, UADDR+PCB_REGS+(PC * REGSZ)
	REG_S	a3, CF_RA_OFFS(sp)		# for debugging
	LA	gp, _gp				# switch to kernel GP
	lw	a3, cpl
	sw	a3, UADDR+PCB_REGS+(CPL * REGSZ)
	.set	at
# Turn off fpu and enter kernel mode
	and	t0, a0, ~(SR_COP_1_BIT | SR_EXL | SR_KSU_MASK | SR_INT_ENAB)
	mtc0	t0, COP_0_STATUS_REG
	li	a0, UADDR+PCB_REGS
	ITLBNOPFIX
/*
 *  If CPU is a RM7000 save away performance stuff.
 */
#if 0
	lw	t0, cpu_is_rm7k
	beqz	t0, 1f			# not an RM7K. Don't do perf save.
	mfc0	v0, COP_0_PC_CTRL
	lw      t0, curproc
	sw	v0, P_PC_CTRL(t0)
	dmfc0	v0, COP_0_WATCH_1
	dmfc0	v1, COP_0_WATCH_2
	sd	v0, P_WATCH_1(t0)
	sd	v1, P_WATCH_2(t0)
	mfc0	v0, COP_0_WATCH_M
	mfc0	v1, COP_0_PC_COUNT
	sw	v0, P_WATCH_M(t0)
	sw	v1, P_PC_COUNT(t0)
	mtc0	zero, COP_0_PC_CTRL
	dmtc0	zero, COP_0_WATCH_1
	dmtc0	zero, COP_0_WATCH_2
1:
#endif

	jal	trap
	nop

	mfc0	t0, COP_0_STATUS_REG	# dis int preserve settings.
	li	t1, ~SR_INT_ENAB
	and	t0, t0, t1
	mtc0	t0, COP_0_STATUS_REG
	ITLBNOPFIX

	ori	t0, SR_EXL
	mtc0	t0, COP_0_STATUS_REG	# set exception level
	ITLBNOPFIX

#if 0
	lw	t0, cpu_is_rm7k
	beqz	t0, 1f			# not an RM7K. Don't do perf setup.

	PTR_L	t0, curproc		# set up rm7k.
	ld	v0, P_WATCH_1(t0)
	dmtc0	v0, COP_0_WATCH_1
	ld	v0, P_WATCH_2(t0)
	dmtc0	v0, COP_0_WATCH_2
	lw	v0, P_WATCH_M(t0)
	mtc0	v0, COP_0_WATCH_M
	lw	v0, P_PC_CTRL(t0)
	lw	v1, P_PC_COUNT(t0)
	nop;nop
	mtc0	v0, COP_0_PC_CTRL
	nop;nop;nop;nop
	mtc0	v1, COP_0_PC_COUNT
	nop;nop;nop;nop
1:
#endif
	lw	a3, UADDR+PCB_REGS+(CPL * REGSZ)
	sw	a3, cpl

	.set	noat

	REG_L	a0, UADDR+PCB_REGS+(SR * REGSZ)
	mtc0	a0, COP_0_STATUS_REG	# still exception level
	REG_L	a0, UADDR+PCB_REGS+(PC * REGSZ)
	REG_L	v0, UADDR+PCB_REGS+(V0 * REGSZ)
	dmtc0	a0, COP_0_EXC_PC		# set return address
	REG_L	v1, UADDR+PCB_REGS+(V1 * REGSZ)
	REG_L	gp, UADDR+PCB_REGS+(GP * REGSZ)
	REG_L	sp, UADDR+PCB_REGS+(SP * REGSZ)
	REG_L	ra, UADDR+PCB_REGS+(RA * REGSZ)
	sync
	eret
	.set	at
END(u_syscall)
#endif

@


1.16
log
@An overoptimization in r1.15 introduced an evil race, back it out. For some
reason this would have been blatant on sparc on motorola, one more proof
mips is the ante${DEITY} yet fun to live with.
@
text
@d1 1
a1 1
/*	$OpenBSD: exception.S,v 1.15 2007/10/18 18:15:40 miod Exp $ */
d247 1
d304 3
d428 1
d430 1
a430 1
	beq	v0, zero, 4f
d441 3
@


1.15
log
@Make sure interrupts are really enabled at the beginning of proc_trampoline,
tested by deraadt@@ jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exception.S,v 1.14 2007/09/03 01:15:50 krw Exp $ */
d658 3
@


1.14
log
@Typos from miod. 'requiered' -> 'required' in some comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: exception.S,v 1.13 2007/05/25 20:47:19 miod Exp $ */
d604 5
d611 1
a611 1
	beq	t0, zero, 0f
d616 13
a628 1
0:
d630 1
a630 1
	move	a0,s1			# set up for return to user.
d654 2
a655 1
	mfc0	t0, COP_0_STATUS_REG	# dis int preserve settings.
a657 3
	mtc0	t0, COP_0_STATUS_REG
	ITLBNOPFIX

@


1.13
log
@Unifdef TLB_TRACE and TLBTRACE, no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: exception.S,v 1.12 2007/05/09 19:23:17 miod Exp $ */
d222 1
a222 1
 *	off though until a switch() really is requiered.
@


1.12
log
@Change trap() into a void function, and restore pc from the trapframe instead
of having trap() return it. This makes trap() consistent with other
platforms, and its code smaller.
@
text
@d1 1
a1 1
/*	$OpenBSD: exception.S,v 1.11 2007/05/07 20:30:25 miod Exp $ */
a136 19
#ifdef TLB_TRACE
	dmfc0	k0, COP_0_EXC_PC
	PTR_L	k1, tlbtrcptr
	PTR_S	k0, 0(k1)
	dmfc0	k0, COP_0_BAD_VADDR
        PTR_S   k0, REGSZ(k1)
	mfc0	k0, COP_0_CAUSE_REG
        PTR_S	k0, 2*REGSZ(k1)
	mfc0	k0, COP_0_STATUS_REG
        PTR_S	k0, 3*REGSZ(k1)

        PTR_L   k1, tlbtrcptr
        PTR_ADDU k1, 4*REGSZ
        LI      k0, 0x100
        not     k0, k0
        and     k1, k0
        LA      k0, tlbtrcptr
        PTR_S   k1, 0(k0)
#endif
@


1.11
log
@Check for astpending in u_general (userland traps) in addition to u_intr
(hardware interrupts occuring while cpu is in usermode), fixes
regress/sys/kern/sig-stop on sgi.
@
text
@d1 1
a1 1
/*	$OpenBSD: exception.S,v 1.10 2007/04/24 16:47:36 miod Exp $ */
a385 1
	move	a0, v0
d391 1
@


1.10
log
@exeption -> exception
@
text
@d1 1
a1 1
/*	$OpenBSD: exception.S,v 1.9 2007/03/23 21:07:38 miod Exp $ */
d443 14
a476 2

4:
@


1.9
log
@Real atomic_{set,clear}bits_int implementation, and replace similar
{set,clr}_ipending with the above routines.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exception.S,v 1.8 2005/12/20 07:06:26 miod Exp $ */
d334 1
a334 1
	mtc0	t0, COP_0_STATUS_REG	# must set exeption level bit.
d472 1
a472 1
	mtc0	t0, COP_0_STATUS_REG	# must set exeption level bit.
d563 1
a563 1
	mtc0	t0, COP_0_STATUS_REG	# set exeption level
d592 1
a592 1
	mtc0	a0, COP_0_STATUS_REG	# still exeption level
d651 1
a651 1
	mtc0	t0, COP_0_STATUS_REG	# must set exeption level bit.
@


1.8
log
@Since we are allowed to rely on the fact that the pcb is the first element
of struct user, use syntactic sugar in genassym.cf and use PCB_xxx defines
instead of U_PCB_xxx, like all other platforms do; no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: exception.S,v 1.7 2004/09/27 19:20:49 pefo Exp $ */
a352 31

/*---------------------------------------------------------------- set_ipending
 *  Atomic ipending set
 */
LEAF(set_ipending, 0)
	LA	a1, ipending
1:
	ll	v0, 0(a1)
	or	v1, v0, a0
	sc	v1, 0(a1)
	beqz	v1, 1b
	nop
	j	ra
	nop
END(set_ipending)

/*---------------------------------------------------------------- set_ipending
 *  Atomic ipending clear
 */
LEAF(clr_ipending, 0)
	LA	a1, ipending
	not	a0, a0
1:
	ll	v0, 0(a1)
	and	v1, v0, a0
	sc	v1, 0(a1)
	beqz	v1, 1b
	nop
	j	ra
	nop
END(clr_ipending)
@


1.7
log
@Rewrite parts of the interrupt system to achive:

o Remove do_pending code and take a real int instead. The performance
  impact seems to be very low and it simplifies the code considerably.

o Allow interrupt nesting at first level. Run softints with HW ints
  enabled.
@
text
@d1 1
a1 1
/*	$OpenBSD: exception.S,v 1.6 2004/09/19 20:24:38 pefo Exp $ */
d538 4
a541 4
	REG_S	a0, UADDR+U_PCB_REGS+(A0 * REGSZ)
	REG_S	a1, UADDR+U_PCB_REGS+(A1 * REGSZ)
	REG_S	a2, UADDR+U_PCB_REGS+(A2 * REGSZ)
	REG_S	a3, UADDR+U_PCB_REGS+(A3 * REGSZ)
d545 1
a545 1
	REG_S	sp, UADDR+U_PCB_REGS+(SP * REGSZ)
d547 4
a550 4
	REG_S	ra, UADDR+U_PCB_REGS+(RA * REGSZ)
	REG_S	a0, UADDR+U_PCB_REGS+(SR * REGSZ)
	REG_S	a1, UADDR+U_PCB_REGS+(CAUSE * REGSZ)
	REG_S	a3, UADDR+U_PCB_REGS+(PC * REGSZ)
d554 1
a554 1
	sw	a3, UADDR+U_PCB_REGS+(CPL * REGSZ)
d559 1
a559 1
	li	a0, UADDR+U_PCB_REGS
d617 1
a617 1
	lw	a3, UADDR+U_PCB_REGS+(CPL * REGSZ)
d622 1
a622 1
	REG_L	a0, UADDR+U_PCB_REGS+(SR * REGSZ)
d624 2
a625 2
	REG_L	a0, UADDR+U_PCB_REGS+(PC * REGSZ)
	REG_L	v0, UADDR+U_PCB_REGS+(V0 * REGSZ)
d627 4
a630 4
	REG_L	v1, UADDR+U_PCB_REGS+(V1 * REGSZ)
	REG_L	gp, UADDR+U_PCB_REGS+(GP * REGSZ)
	REG_L	sp, UADDR+U_PCB_REGS+(SP * REGSZ)
	REG_L	ra, UADDR+U_PCB_REGS+(RA * REGSZ)
@


1.6
log
@nop missing in bd slot
@
text
@d1 1
a1 1
/*	$OpenBSD: exception.S,v 1.5 2004/09/10 08:58:27 pefo Exp $ */
d51 1
a51 6
/*
 *  DDB stack backtrace uses 'jr ra' to find functions starts.
 *  Put this after functions which does not end with 'jr ra'.
 */
#define	DDB_BARRIER \
	jr ra; nop
d53 5
a57 1
	.set	mips3
a128 2
#define	ITLBNOPFIX	nop;nop;nop;nop;nop;nop;nop;nop;nop;nop;

d151 1
a151 1
        nor     k0, zero, k0
a183 1
	DDB_BARRIER
d205 4
d219 5
a233 1
	DDB_BARRIER
d257 4
d327 5
a331 1
	ITLBNOPFIX
a334 1
	ITLBNOPFIX
a350 1
	DDB_BARRIER
d354 17
a370 2
/*---------------------------------------------------------------- set_sint
 *  Atomic ipending update
d372 3
a374 2
LEAF(set_sint, 0)
	LA	v1, ipending
d376 4
a379 4
	ll	v0, 0(v1)
	or	v0, a0
	sc	v0, 0(v1)
	beqz	v0, 1b
d383 1
a383 1
END(set_sint)
a426 1
	DDB_BARRIER
a521 1
	DDB_BARRIER
a632 1
	DDB_BARRIER
@


1.5
log
@Fix LEAF usage adding new extra arg. spotted by miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: exception.S,v 1.4 2004/09/09 22:11:38 pefo Exp $ */
d354 1
@


1.4
log
@Kernel moves to 64 bit. A few more tweaks when binutils is updated.
@
text
@d1 1
a1 1
/*	$OpenBSD: exception.S,v 1.3 2004/08/10 20:15:47 deraadt Exp $ */
d347 1
a347 1
LEAF(set_sint)
d617 1
a617 1
LEAF(proc_trampoline)
@


1.3
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: exception.S,v 1.2 2004/08/09 14:57:26 pefo Exp $ */
d167 1
a167 1
#if (_MIPS_SZPTR == 64)
d177 1
a177 1
#if (_MIPS_SZPTR == 64)
@


1.2
log
@Big cleanup. Removed some unused obsolete stuff and fixed copyrights
on some files. Arcbios support is now in, thus detects memorysize and cpu
clock frequency.
@
text
@d1 1
a1 1
/*	$OpenBSD: exception.S,v 1.1 2004/08/06 20:56:03 pefo Exp $ */
d5 1
a5 1
 * 
d166 1
a166 1
	PTR_ADDU k0, k0, k1	
d176 1
a176 1
	PTR_ADDU k0, k0, k1	
d249 1
a249 1
	LA	gp, _gp	
d259 1
a259 1
	beq	v0, zero, 4f	
d419 1
a419 1
	LA	gp, _gp	
@


1.1
log
@initial mips64
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a13 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Opsycon AB, Sweden.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d140 1
a140 1
#if 0
@

