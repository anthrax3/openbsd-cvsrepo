head	1.11;
access;
symbols
	OPENBSD_6_2_BASE:1.11
	OPENBSD_6_1:1.11.0.4
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.10.0.4
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.2
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.9.0.6
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.8.0.4
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.6.0.8
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.4
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.2
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.5.0.2
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.1
	OPENBSD_5_1:1.1.0.6
	OPENBSD_5_0:1.1.0.4
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1;
locks; strict;
comment	@ * @;


1.11
date	2016.12.21.13.59.57;	author visa;	state Exp;
branches;
next	1.10;
commitid	p6zUhTuh4cX1l0nl;

1.10
date	2016.01.05.05.27.54;	author visa;	state Exp;
branches;
next	1.9;
commitid	916i76I5mjNtTg33;

1.9
date	2014.08.12.04.30.21;	author miod;	state Exp;
branches;
next	1.8;
commitid	9nVTOLQehINSztcq;

1.8
date	2014.03.31.20.21.19;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2014.03.09.10.12.17;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2012.09.29.18.54.38;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2012.06.24.16.26.04;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2012.04.21.12.20.30;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2012.03.25.13.52.52;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2012.03.24.20.10.08;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2010.09.20.12.11.18;	author syuu;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Add a driver for OCTEON MMC host controller.

Tested on EdgeRouter Pro, and Shasta.

OK mpi@@
@
text
@/*	$OpenBSD: cache_octeon.c,v 1.10 2016/01/05 05:27:54 visa Exp $	*/
/*
 * Copyright (c) 2010 Takuya ASADA.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
/*
 * Copyright (c) 1998-2004 Opsycon AB (www.opsycon.se)
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>

#include <uvm/uvm_extern.h>

#include <mips64/cache.h>
#include <machine/cpu.h>

#define SYNCI() \
	asm volatile( \
		".set push\n" \
		".set mips64r2\n" \
		".word 0x041f0000\n" \
		"nop\n" \
		".set pop")

void 
Octeon_ConfigCache(struct cpu_info *ci)
{
	uint32_t cfg;
	uint32_t s, l, a;

	/* minimalist default values */
	ci->ci_l1inst.size = 16 * 1024;
	ci->ci_l1inst.linesize = 128;
	ci->ci_l1inst.sets = 2;
	ci->ci_l1inst.setsize = ci->ci_l1inst.size / ci->ci_l1inst.sets;

	ci->ci_l1data.size = 8 * 1024;
	ci->ci_l1data.linesize = 128;
	ci->ci_l1data.sets = 64;
	ci->ci_l1data.setsize = ci->ci_l1data.size / ci->ci_l1data.sets;

	ci->ci_l2.size = 128 * 1024;
	ci->ci_l2.linesize = 128;
	ci->ci_l2.sets = 4;
	ci->ci_l2.setsize = ci->ci_l2.size / ci->ci_l2.sets;

	cfg = cp0_get_config();
	if ((cfg & 0x80000000) != 0) {
		cfg = cp0_get_config_1();

		/*
		 * Octeon L1 cache information does not follow the mips64
		 * standard encoding.
		 */

	        a = (cfg >> 16) & 0x07;
		l = (cfg >> 19) & 0x07;
		s = (cfg >> 22) & 0x07;
		ci->ci_l1inst.linesize = 2 << l;
		ci->ci_l1inst.setsize = (64 << s) * ci->ci_l1inst.linesize;
		if (a >= 1)
	        	ci->ci_l1inst.sets = 1 << (a - 1);
		else
			ci->ci_l1inst.sets = 1;
		ci->ci_l1inst.size = ci->ci_l1inst.sets * ci->ci_l1inst.setsize;

		if ((cfg & 0x80000000) != 0) {
			cfg = cp0_get_config_2();
			
			a = 1 + ((cfg >> 0) & 0x0f);
			l = (cfg >> 4) & 0x0f;
			s = (cfg >> 8) & 0x0f;

			ci->ci_l2.linesize = 2 << l;
			ci->ci_l2.sets = a;
			ci->ci_l2.setsize = (64 << s) * ci->ci_l2.linesize;
			ci->ci_l2.size = ci->ci_l2.sets * ci->ci_l2.setsize;

		}
	}

	memset(&ci->ci_l3, 0, sizeof(struct cache_info));

	ci->ci_SyncCache = Octeon_SyncCache;
	ci->ci_InvalidateICache = Octeon_InvalidateICache;
	ci->ci_InvalidateICachePage = Octeon_InvalidateICachePage;
	ci->ci_SyncICache = Octeon_SyncICache;
	ci->ci_SyncDCachePage = Octeon_SyncDCachePage;
	ci->ci_HitSyncDCachePage = Octeon_SyncDCachePage;
	ci->ci_HitSyncDCache = Octeon_HitSyncDCache;
	ci->ci_HitInvalidateDCache = Octeon_HitInvalidateDCache;
	ci->ci_IOSyncDCache = Octeon_IOSyncDCache;
}

void
Octeon_SyncCache(struct cpu_info *ci)
{
	mips_sync();
}

void
Octeon_InvalidateICache(struct cpu_info *ci, vaddr_t va, size_t len)
{
	/* A SYNCI flushes the entire icache on OCTEON */
	SYNCI();
}

/*
 * Register a given page for I$ invalidation.
 */
void
Octeon_InvalidateICachePage(struct cpu_info *ci, vaddr_t va)
{
	/*
	 * Since there is apparently no way to operate on a subset of I$,
	 * all we need to do here is remember there are postponed flushes.
	 */
	ci->ci_cachepending_l1i = 1;
}

/*
 * Perform postponed I$ invalidation.
 */
void
Octeon_SyncICache(struct cpu_info *ci)
{
	if (ci->ci_cachepending_l1i != 0) {
		SYNCI(); /* Octeon_InvalidateICache(ci, 0, PAGE_SIZE); */
		ci->ci_cachepending_l1i = 0;
	}
}

void
Octeon_SyncDCachePage(struct cpu_info *ci, vaddr_t va, paddr_t pa)
{
}

void
Octeon_HitSyncDCache(struct cpu_info *ci, vaddr_t va, size_t len)
{
}

void
Octeon_HitInvalidateDCache(struct cpu_info *ci, vaddr_t va, size_t len)
{
}

void
Octeon_IOSyncDCache(struct cpu_info *ci, vaddr_t va, size_t len, int how)
{
	switch (how) {
	default:
	case CACHE_SYNC_R:
		break;
	case CACHE_SYNC_W: /* writeback */
	case CACHE_SYNC_X: /* writeback and invalidate */
		mips_sync();
		break;
	}
}

void
Octeon_lock_secondary_cache(struct cpu_info *ci, paddr_t _pa, size_t _sz)
{
	size_t linesize = ci->ci_l2.linesize;
	size_t sz;
	paddr_t pa;
	vaddr_t end, va;

	pa = _pa & ~(linesize - 1);
	sz = ((_pa + _sz + linesize - 1) & ~(linesize - 1)) - pa;

	va = PHYS_TO_XKPHYS(pa, 0ul);
	end = va + sz;
	while (va < end) {
		asm volatile ("cache 31, (%0)" : : "r" (va));
		va += linesize;
	}

	/* Wait for the lock operations to finish. */
	mips_sync();
}

void
Octeon_unlock_secondary_cache(struct cpu_info *ci, paddr_t _pa, size_t _sz)
{
	size_t linesize = ci->ci_l2.linesize;
	size_t sz;
	paddr_t pa;
	vaddr_t end, va;

	pa = _pa & ~(linesize - 1);
	sz = ((_pa + _sz + linesize - 1) & ~(linesize - 1)) - pa;

	va = PHYS_TO_XKPHYS(pa, 0ul);
	end = va + sz;
	while (va < end) {
		asm volatile ("cache 23, (%0)" : : "r" (va));
		va += linesize;
	}
}
@


1.10
log
@Some implementations of HitSyncDCache() call pmap_extract() for va->pa
conversion. Because pmap_extract() acquires the PTE mutex, a "locking
against myself" panic is triggered if the cache routine gets called in
a context where the mutex is already held.

In the pmap, all calls to HitSyncDCache() are for a whole page. Add a
new cache routine, HitSyncDCachePage(), which gets both the va and the
pa of a page. This removes the need of the va->pa conversion. The new
routine has the same signature as SyncDCachePage(), allowing reuse of
the same routine for cache implementations that do not need differences
between "Hit" and non-"Hit" routines.

With the diff, POWER Indigo2 R8000 boots multiuser again. Tested on sgi
GENERIC-IP27.MP and octeon GENERIC.MP, too.

Diff from miod@@, ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cache_octeon.c,v 1.9 2014/08/12 04:30:21 miod Exp $	*/
d194 41
@


1.9
log
@Better cache information gathering. Only affects information put in dmesg.
@
text
@d1 1
a1 1
/*	$OpenBSD: cache_octeon.c,v 1.8 2014/03/31 20:21:19 miod Exp $	*/
d124 1
@


1.8
log
@Due the virtually indexed nature of the L1 instruction cache on most mips
processors, every time a new text page is mapped in a pmap, the L1 I$ is
flushed for the va spanned by this page.

Since we map pages of our binaries upon demand, as they get faulted in, but
uvm_fault() tries to map the few neighbour pages, this can end up in a
bunch of pmap_enter() calls in a row, for executable mappings. If the L1
I$ is small enough, this can cause the whole L1 I$ cache to be flushed
several times.

Change pmap_enter() to postpone these flushes by only registering the
pending flushes, and have pmap_update() perform them. The cpu-specific
cache code can then optimize this to avoid unnecessary operations.

Tested on R4000SC, R4600SC, R5000SC, RM7000, R10000 with 4KB and 16KB
page sizes (coherent and non-coherent designs), and Loongson 2F by mikeb@@ and
me. Should not affect anything on Octeon since there is no way to flush a
subset of I$ anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: cache_octeon.c,v 1.7 2014/03/09 10:12:17 miod Exp $	*/
d63 5
a67 1
	ci->ci_l1inst.size = 32 * 1024;
d69 2
a70 2
	ci->ci_l1inst.setsize = 4;
	ci->ci_l1inst.sets = ci->ci_l1inst.size / ci->ci_l1inst.setsize;
d72 1
a72 1
	ci->ci_l1data.size = 16 * 1024;
d74 2
a75 2
	ci->ci_l1data.setsize = 4;
	ci->ci_l1data.sets = ci->ci_l1data.size / ci->ci_l1data.setsize;
d79 37
a115 2
	ci->ci_l2.setsize = 4;
	ci->ci_l2.sets = ci->ci_l2.size / ci->ci_l2.setsize;
@


1.7
log
@Rework the per-cpu cache information. Use a common struct to store the line
size, the number of sets, and the total size (and the set size, for convenience)
per cache (I$, D$, L2, L3).
This allows cpu.c to print the number of ways (sets) of L2 and L3 caches from
the cache information, rather than hardcoding this from the processor type.
@
text
@d1 1
a1 1
/*	$OpenBSD: cache_octeon.c,v 1.6 2012/09/29 18:54:38 miod Exp $	*/
d82 2
d101 25
@


1.6
log
@Proide a mips_sync() macro to wrap asm("sync"), and replace gazillions of
such statements with it.
@
text
@d1 1
a1 1
/*	$OpenBSD: cache_octeon.c,v 1.5 2012/06/24 16:26:04 miod Exp $	*/
d63 16
a78 8
	ci->ci_cacheways = 4;
	ci->ci_l1instcachesize = 32 * 1024;
	ci->ci_l1instcacheline = 128;
	ci->ci_l1datacachesize = 16 * 1024;
	ci->ci_l1datacacheline = 128;
	ci->ci_l2size = 128 * 1024;
	ci->ci_l2line = 128;
	ci->ci_l3size = 0;
@


1.5
log
@Add cache operation functions pointers to struct cpu_info; the various
cache lines and sizes are already there, after all.

The ConfigCache cache routine is responsible for filling these function
pointers; cache routine invocation macros are updated to use the cpu_info
fields, but may still be overriden in <machine/cpu.h> on platforms where
only one set of cache routines is used.
@
text
@d1 1
a1 1
/*	$OpenBSD: cache_octeon.c,v 1.4 2012/04/21 12:20:30 miod Exp $	*/
a51 1
#define SYNC() asm volatile("sync\n" ::: "memory")
d83 1
a83 1
	SYNC();
d117 1
a117 1
		SYNC();
@


1.4
log
@Rework the signature of the cache handling routines again. It makes more sense
to pass both the virtual and physical addresses of the page to clean to
SyncDCachePage, which is the only routine using `Index' operations on the data
cache, which might be virtually indexed at some levels but physically indexed
at others. On the other hand, it does not make any sense to pass a physical
address to routines using `Hit' operations (and they were discarding them
anyway).

In addition to making things cleaner, this fixes sporadic userland misbehaviour
(read: SIGSGEV) on RM7000 O2 systems.
@
text
@d1 1
a1 1
/*	$OpenBSD: cache_octeon.c,v 1.3 2012/03/25 13:52:52 miod Exp $	*/
d70 1
d72 7
@


1.3
log
@Move cache handling routines related definitions to a dedicated header file,
rather than abusing <machine/cpu.h>.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d80 1
a80 1
Octeon_InvalidateICache(struct cpu_info *ci, uint64_t va, size_t len)
d87 1
a87 1
Octeon_SyncDCachePage(struct cpu_info *ci, uint64_t pa)
d92 1
a92 1
Octeon_HitSyncDCache(struct cpu_info *ci, uint64_t pa, size_t len)
d97 1
a97 1
Octeon_HitInvalidateDCache(struct cpu_info *ci, uint64_t pa, size_t len)
d102 1
a102 1
Octeon_IOSyncDCache(struct cpu_info *ci, uint64_t pa, size_t len, int how)
@


1.2
log
@The various ConfigCache() functions actually return void, not int.
@
text
@d1 1
d49 1
d52 1
a52 1
#define SYNC() asm volatile("sync\n")
d80 1
a80 1
Octeon_InvalidateICache(struct cpu_info *ci, vaddr_t addr, size_t len)
d87 1
a87 1
Octeon_SyncDCachePage(struct cpu_info *ci, paddr_t addr)
d92 1
a92 1
Octeon_HitSyncDCache(struct cpu_info *ci, paddr_t addr, size_t len)
d97 1
a97 1
Octeon_HitInvalidateDCache(struct cpu_info *ci, paddr_t addr, size_t len)
d102 1
a102 1
Octeon_IOSyncDCache(struct cpu_info *ci, paddr_t addr, size_t len, int how)
d105 7
a111 7
		default:
		case 0:
			break;
		case 1: /* writeback */
		case 2: /* writeback and invalidate */
			SYNC();
			break;
@


1.1
log
@cache operations for octeon. ok miod@@
@
text
@d59 1
a59 1
int 
a68 1
	return 0;
@

