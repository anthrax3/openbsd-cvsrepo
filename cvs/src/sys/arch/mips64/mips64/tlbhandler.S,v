head	1.47;
access;
symbols
	OPENBSD_6_1:1.47.0.2
	OPENBSD_6_1_BASE:1.47
	OPENBSD_6_0:1.44.0.8
	OPENBSD_6_0_BASE:1.44
	OPENBSD_5_9:1.44.0.4
	OPENBSD_5_9_BASE:1.44
	OPENBSD_5_8:1.44.0.6
	OPENBSD_5_8_BASE:1.44
	OPENBSD_5_7:1.44.0.2
	OPENBSD_5_7_BASE:1.44
	OPENBSD_5_6:1.43.0.4
	OPENBSD_5_6_BASE:1.43
	OPENBSD_5_5:1.40.0.4
	OPENBSD_5_5_BASE:1.40
	OPENBSD_5_4:1.38.0.4
	OPENBSD_5_4_BASE:1.38
	OPENBSD_5_3:1.38.0.2
	OPENBSD_5_3_BASE:1.38
	OPENBSD_5_2:1.35.0.2
	OPENBSD_5_2_BASE:1.35
	OPENBSD_5_1_BASE:1.32
	OPENBSD_5_1:1.32.0.6
	OPENBSD_5_0:1.32.0.4
	OPENBSD_5_0_BASE:1.32
	OPENBSD_4_9:1.32.0.2
	OPENBSD_4_9_BASE:1.32
	OPENBSD_4_8:1.31.0.4
	OPENBSD_4_8_BASE:1.31
	OPENBSD_4_7:1.31.0.2
	OPENBSD_4_7_BASE:1.31
	OPENBSD_4_6:1.18.0.4
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.16.0.8
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.16.0.6
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.16.0.4
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.16.0.2
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.13.0.4
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.13.0.2
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.12.0.2
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.10.0.4
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.2
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.7.0.2
	OPENBSD_3_6_BASE:1.7;
locks; strict;
comment	@# @;


1.47
date	2016.12.22.15.33.36;	author visa;	state Exp;
branches;
next	1.46;
commitid	sw48d58czeutOmw2;

1.46
date	2016.09.06.13.41.29;	author visa;	state Exp;
branches;
next	1.45;
commitid	YLWh6Z5nXoTUOOVU;

1.45
date	2016.08.14.08.23.52;	author visa;	state Exp;
branches;
next	1.44;
commitid	at8t1tG4p7ou4Cj7;

1.44
date	2014.08.12.19.33.59;	author miod;	state Exp;
branches;
next	1.43;
commitid	xYOBa9ic9mdIENDM;

1.43
date	2014.04.09.21.10.35;	author miod;	state Exp;
branches;
next	1.42;

1.42
date	2014.03.24.17.12.01;	author miod;	state Exp;
branches;
next	1.41;

1.41
date	2014.03.22.00.01.04;	author miod;	state Exp;
branches;
next	1.40;

1.40
date	2014.02.08.09.34.04;	author miod;	state Exp;
branches;
next	1.39;

1.39
date	2013.12.19.20.15.08;	author miod;	state Exp;
branches;
next	1.38;

1.38
date	2012.10.03.11.18.23;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2012.09.29.21.37.03;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2012.09.29.19.02.26;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2012.04.24.20.01.03;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2012.04.09.16.54.39;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2012.03.28.20.44.23;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2010.09.12.12.05.37;	author syuu;	state Exp;
branches;
next	1.31;

1.31
date	2010.02.13.14.07.30;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2010.02.01.05.26.17;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2010.01.28.21.24.08;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2010.01.28.05.27.16;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2010.01.21.17.52.25;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2010.01.09.23.43.17;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2009.12.12.20.07.10;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2009.12.07.19.05.59;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2009.12.07.18.54.46;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2009.11.19.20.16.27;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2009.11.18.20.58.52;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2009.09.30.06.22.00;	author syuu;	state Exp;
branches;
next	1.19;

1.19
date	2009.08.06.21.11.39;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2009.05.25.17.10.38;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2009.05.22.20.37.53;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2007.05.25.20.58.39;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2007.05.25.20.47.19;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2007.05.01.20.40.18;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2006.03.04.19.33.21;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2005.12.20.07.06.26;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2005.12.17.20.17.46;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2004.10.20.12.49.15;	author pefo;	state Exp;
branches;
next	1.9;

1.9
date	2004.09.27.20.39.27;	author pefo;	state Exp;
branches;
next	1.8;

1.8
date	2004.09.27.19.13.25;	author pefo;	state Exp;
branches;
next	1.7;

1.7
date	2004.09.10.10.39.45;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2004.09.10.09.32.13;	author pefo;	state Exp;
branches;
next	1.5;

1.5
date	2004.09.10.08.58.27;	author pefo;	state Exp;
branches;
next	1.4;

1.4
date	2004.09.09.22.11.38;	author pefo;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.10.20.15.47;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2004.08.09.14.57.26;	author pefo;	state Exp;
branches;
next	1.1;

1.1
date	2004.08.06.20.56.03;	author pefo;	state Exp;
branches;
next	;


desc
@@


1.47
log
@Extend the size of user virtual address space from 2GB to 1TB on mips64
by adding another level to page directories. This improves ASLR and
complements W^X added earlier on some systems, giving a notable update
to the architecture's security. Besides, there is now more room for
running tasks that hog memory.

Testing help from deraadt@@ and fcambus@@.
Platforms tested: loongson, octeon, sgi/IP27 and sgi/IP30
(IP30 also with 4KB pages).
@
text
@/*	$OpenBSD: tlbhandler.S,v 1.46 2016/09/06 13:41:29 visa Exp $ */

/*
 * Copyright (c) 1995-2004 Opsycon AB  (www.opsycon.se / www.opsycon.com)
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

/*
 *  This code handles TLB exceptions and updates.
 */

#include <machine/param.h>
#include <machine/pte.h>
#include <machine/asm.h>
#include <machine/cpu.h>
#include <mips64/mips_cpu.h>
#include <machine/regnum.h>
#include <machine/cpustate.h>
#ifdef CPU_LOONGSON2
#include <machine/loongson2.h>
#endif

#include "assym.h"

	.set	mips3

	.set	noreorder	/* Default reorder mode */

/*---------------------------------------------------------------- tlb_miss
 *	Low level TLB exception handler. TLB and XTLB code are
 *	identical at the moment.
 *	This code is not copied to the exception area, instead
 *	trampolines branching to the appropriate code are built.
 */
	.set	noat

#ifdef CPU_R4000
	.globl	xtlb_miss_err_r4k
	.ent	xtlb_miss_err_r4k, 0
xtlb_miss_err_r4k:
	/*
	 * R4000 errata #27: TLB miss exception may be invoked with BadVAddr
	 * being incorrect.
	 */
	tlbp
	mfc0	k1, COP_0_TLB_INDEX
	bltz	k1, xtlb_miss			# missing!
	 nop
	ERET
	 nop
	.end	xtlb_miss_err_r4k

	.globl	xtlb_miss_err_r4000SC
	.ent	xtlb_miss_err_r4000SC, 0
xtlb_miss_err_r4000SC:
	/*
	 * R4000SC errata #12: In addition to errata #27 above, the tlbp
	 * instruction needs to be issued in uncached space, to prevent
	 * BadVAddr to be further corrupted if a VCE exception occurs
	 * immediately after the TLB miss exception has been serviced.
	 */
	tlbp
	mfc0	k1, COP_0_TLB_INDEX
	bltz	k1, 1f		# missing!
	 nop
	ERET
	 nop
1:
	LA	k1, xtlb_miss
	jr	k1
	 nop
	.end	xtlb_miss_err_r4000SC
#endif	/* CPU_R4000 */
#if defined(CPU_R5000) || defined(CPU_RM7000)
	.globl	xtlb_miss_err_r5k
	.ent	xtlb_miss_err_r5k, 0
xtlb_miss_err_r5k:
	/*
	 * R5000 errata: edge cases can trigger a TLB miss exception
	 * instead of an invalid TLB exception. Servicing the TLB miss
	 * exception would cause a duplicate TLB to be inserted, which
	 * causes the processor operation to become unpredictable (but
	 * very bad for the kernel's health, ten times out of nine).
	 *
	 * More details about the problem can be found in:
	 *  http://www.linux-mips.org/archives/linux-mips/2000-02/msg00040.html
	 *
	 * We work around the issue by checking for an existing TLB entry,
	 * and handling this as an invalid TLB exception (as it was intended
	 * to be), in this case.
	 */
	tlbp
	mfc0	k1, COP_0_TLB_INDEX
	bltz	k1, xtlb_miss		# missing!
	 nop
	b	k_tlb_inv
	 nop
	.end	xtlb_miss_err_r5k
#endif	/* CPU_R5000 || CPU_RM7000 */

	.globl	xtlb_miss
	.ent	xtlb_miss, 0
xtlb_miss:
	dmfc0	k0, COP_0_BAD_VADDR
	bltz	k0, _k_miss		# kernel address space
	PTR_SRL	k0, k0, SEGSHIFT
	sltiu	k1, k0, PMAP_SEGTABSIZE
	beqz	k1, _inv_seg		# wrong if outside pm_segtab
	nop
	GET_CPU_INFO(k1, k0)
	PTR_L	k1, CI_CURPROCPADDR(k1)
	dmfc0	k0, COP_0_BAD_VADDR
	PTR_SRL	k0, k0, SEGSHIFT
	PTR_SLL	k0, k0, LOGREGSZ
	PTR_L	k1, PCB_SEGTAB(k1)
	PTR_ADDU k1, k1, k0
	PTR_L	k1, 0(k1)		# get pointer to page directory
	dmfc0	k0, COP_0_BAD_VADDR
	PTR_SRL	k0, k0, (DIRSHIFT - LOGREGSZ)
	beqz	k1, _inv_seg
	andi	k0, k0, (NPDEPG - 1) << LOGREGSZ
	PTR_ADDU k1, k1, k0
	PTR_L	k1, 0(k1)		# get pointer to page table
	dmfc0	k0, COP_0_BAD_VADDR
	PTR_SRL	k0, k0, PGSHIFT - PTE_LOG
	beqz	k1, _inv_seg
	andi	k0, k0, ((NPTEPG >> 1) - 1) << (PTE_LOG + 1)
	PTR_ADDU k1, k1, k0
	PTE_LOAD	k0, 0(k1)
	PTE_LOAD	k1, PTE_OFFS(k1)
#ifdef CPU_R4000
	dsll	k0, k0, (64 - PG_FRAMEBITS - 1)	# clear bits left of PG_FRAME...
	dsll	k1, k1, (64 - PG_FRAMEBITS - 1)	# ...but PG_SP
	bltz	k0, _inv_seg			# defer to trap() if PG_SP set.
	bltz	k1, _inv_seg
	dsll	k0, k0, 1
	dsll	k1, k1, 1
	dsrl	k0, k0, (64 - PG_FRAMEBITS)
	dsrl	k1, k1, (64 - PG_FRAMEBITS)
#else
	PTE_CLEAR_SWBITS(k0)
	PTE_CLEAR_SWBITS(k1)
#endif
	dmtc0	k0, COP_0_TLB_LO0
	dmtc0	k1, COP_0_TLB_LO1
	TLB_HAZARD
	tlbwr				# update TLB
	TLB_HAZARD

#ifdef CPU_LOONGSON2
	li	k0, COP_0_DIAG_ITLB_CLEAR | COP_0_DIAG_BTB_CLEAR | COP_0_DIAG_RAS_DISABLE
	dmtc0	k0, COP_0_DIAG
#endif

	ERET

_k_miss:
	dmfc0	k0, COP_0_BAD_VADDR	# must reload.
	b	k_tlb_miss		# kernel tlbmiss.
	nop

_inv_seg:				# No page table for this segment,
					# or processing is too complex to be
					# done here: invoke C code.
	mfc0	k0, COP_0_STATUS_REG
	andi	k0, SR_KSU_USER
	bne	k0, zero, go_u_general
	nop

go_k_general:
	j	k_general
	nop
go_u_general:
#ifdef CPU_LOONGSON2
	/*
	 * To work around a branch prediction issue on earlier LS2F
	 * chips, it is necessary to clear the BTB upon
	 * userland->kernel boundaries.
	 */
	li	k0, COP_0_DIAG_BTB_CLEAR | COP_0_DIAG_RAS_DISABLE
	dmtc0	k0, COP_0_DIAG
#endif
	j	u_general
	nop
	.end	xtlb_miss

	.set	at

/*---------------------------------------------------------------- k_tlb_inv
 *	Handle a TLB invalid exception from kernel mode in kernel
 *	space. This happens when we have a TLB match but an invalid
 *	entry. Try to reload.
 */
NLEAF(k_tlb_inv, 0)
	.set	noat
#ifdef CPU_OCTEON
	/* Check if the fault was caused by an instruction fetch. */
	dmfc0	k0, COP_0_CAUSE_REG
	/* XXX bbit0 k0, CR_BR_DELAY_BIT, 1f */
	li	k1, CR_BR_DELAY
	and	k0, k0, k1
	beq	k0, zero, 1f			# fault in a branch delay slot?
	 dmfc0	k1, COP_0_EXC_PC
	daddu	k1, k1, 4			# adjust for the slot
1:	dmfc0	k0, COP_0_BAD_VADDR
	beq	k0, k1, go_k_general
#else
	dmfc0	k0, COP_0_BAD_VADDR		# get the fault address
#endif
	LA	k1, (VM_MIN_KERNEL_ADDRESS)	# compute index
	PTR_SUBU k0, k0, k1
	lw	k1, Sysmapsize			# index within range?
	PTR_SRL	k0, k0, PGSHIFT
	sltu	k1, k0, k1
	beq	k1, zero, sys_stk_chk		# No. check for valid stack
	nop

	PTR_L	k1, Sysmap
	PTR_SLL	k0, k0, PTE_LOG			# compute offset from index
	TLB_HAZARD
	tlbp					# Probe the invalid entry
	TLB_HAZARD				# necessary?
	PTR_ADDU k1, k1, k0
	and	k0, k0, PTE_OFFS		# check even/odd page
	bne	k0, zero, k_tlb_inv_odd
	nop

	mfc0	k0, COP_0_TLB_INDEX
	bltz	k0, sys_stk_chk			# probe fail
	PTE_LOAD k0, 0(k1)			# get PTE entry

	PTE_CLEAR_SWBITS(k0)
	dmtc0	k0, COP_0_TLB_LO0		# load PTE entry
	and	k0, k0, PG_V			# check for valid entry
	beq	k0, zero, go_k_general		# PTE invalid
	PTE_LOAD k0, PTE_OFFS(k1)		# get odd PTE entry
	PTE_CLEAR_SWBITS(k0)
	dmtc0	k0, COP_0_TLB_LO1		# load PTE entry
	TLB_HAZARD
	tlbwi					# write TLB
	TLB_HAZARD

#ifdef CPU_LOONGSON2
	li	k0, COP_0_DIAG_ITLB_CLEAR | COP_0_DIAG_BTB_CLEAR | COP_0_DIAG_RAS_DISABLE
	dmtc0	k0, COP_0_DIAG
#endif

	ERET

k_tlb_inv_odd:
	mfc0	k0, COP_0_TLB_INDEX
	bltz	k0, sys_stk_chk			# probe fail
	PTE_LOAD k0, 0(k1)			# get PTE entry

	PTE_CLEAR_SWBITS(k0)
	dmtc0	k0, COP_0_TLB_LO1		# save PTE entry
	and	k0, k0, PG_V			# check for valid entry
	beq	k0, zero, go_k_general		# PTE invalid
	PTE_LOAD k0, -PTE_OFFS(k1)		# get even PTE entry
	PTE_CLEAR_SWBITS(k0)
	dmtc0	k0, COP_0_TLB_LO0		# save PTE entry
	TLB_HAZARD
	tlbwi					# update TLB
	TLB_HAZARD

#ifdef CPU_LOONGSON2
	li	k0, COP_0_DIAG_ITLB_CLEAR | COP_0_DIAG_BTB_CLEAR | COP_0_DIAG_RAS_DISABLE
	dmtc0	k0, COP_0_DIAG
#endif

	ERET
END(k_tlb_inv)

/*---------------------------------------------------------------- k_tlb_miss
 *
 *	Handle a TLB miss exception from kernel mode in kernel space.
 *	We must check that this is coming from kernel mode. If not
 *	it's a bad address from user mode so handle properly.
 *	Load up the correct entry contents from the kernel map.
 *	k0 has bad address.
 */
NLEAF(k_tlb_miss, 0)
	.set	noat
	mfc0	k1, COP_0_STATUS_REG
	andi	k1, SR_KSU_USER
	bne	k1, zero, go_u_general
	LA	k1, (VM_MIN_KERNEL_ADDRESS)	# compute index
						# (safe if expands to > 1 insn)
	PTR_SUBU k0, k0, k1
	lw	k1, Sysmapsize			# index within range?
	PTR_SRL	k0, k0, PGSHIFT
	sltu	k1, k0, k1
	beq	k1, zero, sys_stk_chk		# No. check for valid stack
	PTR_SRL	k0, k0, 1
	PTR_L	k1, Sysmap
	PTR_SLL	k0, k0, (PTE_LOG + 1)		# compute offset from index
	PTR_ADDU k1, k1, k0
	PTE_LOAD k0, 0(k1)			# get PTE entry
	PTE_LOAD k1, PTE_OFFS(k1)		# get odd PTE entry
	PTE_CLEAR_SWBITS(k0)
	dmtc0	k0, COP_0_TLB_LO0		# load PTE entry
	PTE_CLEAR_SWBITS(k1)
	dmtc0	k1, COP_0_TLB_LO1		# load PTE entry
	TLB_HAZARD
	tlbwr					# write TLB
	TLB_HAZARD

#ifdef CPU_LOONGSON2
	li	k0, COP_0_DIAG_ITLB_CLEAR | COP_0_DIAG_BTB_CLEAR | COP_0_DIAG_RAS_DISABLE
	dmtc0	k0, COP_0_DIAG
#endif

	ERET

sys_stk_chk:
	GET_CPU_INFO(k1, k0)
	PTR_L	k1, CI_CURPROCPADDR(k1)
	PTR_SUBU k0, sp, k1			# check to see if we have a
	sltiu	k0, 2048			#  valid kernel stack
	beqz	k0, go_k_general		# yes, handle.
	nop

	LA	a0, start-FRAMESZ(CF_SZ)-4*REGSZ # set sp to a valid place
#ifdef __mips_n64
	mfc0	a4, COP_0_STATUS_REG
	mfc0	a5, COP_0_CAUSE_REG
	move	a6, sp
#else
	mfc0	a2, COP_0_STATUS_REG
	mfc0	a3, COP_0_CAUSE_REG
	REG_S	a2, CF_ARGSZ+0*REGSZ(sp)
	REG_S	a3, CF_ARGSZ+1*REGSZ(sp)
	PTR_S	sp, CF_ARGSZ+2*REGSZ(a0)
#endif
	move	sp, a0
	dmfc0	a3, COP_0_BAD_VADDR
	move	a2, ra
	dmfc0	a1, COP_0_EXC_PC
	LA	a0, 1f
	jal	printf
	nop

	LA	sp, start-FRAMESZ(CF_SZ)	# set sp to a valid place

#ifdef DDB
	LA	a1, db_printf
	LA	a0, 2f
	jal	trapDump
	nop
#endif

	PANIC("kernel stack overflow")
	/*noreturn*/

	.data
1:
	.asciiz	"\rktlbmiss: PC %p RA %p ADR %p\nSR %p CR %p SP %p\n"
2:
	.asciiz	"stack ovf"
	.text

	.set	at
END(k_tlb_miss)

/*---------------------------------------------------------------- tlb_flush
 *	Flush the "random" entries from the TLB.
 *	Uses "wired" register to determine what register to start with.
 *	Arg "tlbsize" is the number of entries to flush.
 */
LEAF(tlb_flush, 0)
	mfc0	v1, COP_0_STATUS_REG	# Save the status register.
	ori	v0, v1, SR_INT_ENAB
	xori	v0, v0, SR_INT_ENAB
	mtc0	v0, COP_0_STATUS_REG	# Disable interrupts
	MTC0_SR_IE_HAZARD
	mfc0	ta1, COP_0_TLB_WIRED
	LA	v0, CKSEG0_BASE		# invalid address
	dmfc0	ta0, COP_0_TLB_HI	# Save the PID

#ifdef CPU_OCTEON
	PTR_SLL	ta2, ta1, PAGE_SHIFT + 1
	PTR_ADDU v0, v0, ta2
#else
	dmtc0	v0, COP_0_TLB_HI	# Mark entry high as invalid
#endif
	dmtc0	zero, COP_0_TLB_LO0	# Zero out low entry0.
	dmtc0	zero, COP_0_TLB_LO1	# Zero out low entry1.
	mtc0	zero, COP_0_TLB_PG_MASK	# Zero out mask entry.
/*
 * Align the starting value (ta1) and the upper bound (a0).
 */
1:
	mtc0	ta1, COP_0_TLB_INDEX	# Set the index register.
#ifdef CPU_OCTEON
	dmtc0	v0, COP_0_TLB_HI	# Mark entry high as invalid
	PTR_ADDU v0, v0, 2 * PAGE_SIZE
#endif
	addu	ta1, ta1, 1		# Increment index.
	TLB_HAZARD
	tlbwi				# Write the TLB entry.
	TLB_HAZARD
	bne	ta1, a0, 1b
	nop

#ifdef CPU_LOONGSON2
	li	v0, COP_0_DIAG_ITLB_CLEAR | COP_0_DIAG_BTB_CLEAR | COP_0_DIAG_RAS_DISABLE
	dmtc0	v0, COP_0_DIAG
#endif

	dmtc0	ta0, COP_0_TLB_HI	# Restore the PID
	li	a0, TLB_PAGE_MASK
	mtc0	a0, COP_0_TLB_PG_MASK	# Restore default mask value.
	mtc0	v1, COP_0_STATUS_REG	# Restore the status register
	MTC0_SR_IE_HAZARD
	j	ra
	nop
END(tlb_flush)

/*--------------------------------------------------------------- tlb_flush_addr
 *	Flush any TLB entries for the given address and TLB PID.
 */
LEAF(tlb_flush_addr, 0)
	mfc0	v1, COP_0_STATUS_REG	# Save the status register.
	ori	v0, v1, SR_INT_ENAB
	xori	v0, v0, SR_INT_ENAB
	mtc0	v0, COP_0_STATUS_REG	# Disable interrupts
	MTC0_SR_IE_HAZARD
	dli	v0, (PG_HVPN | PG_ASID_MASK)
	and	a0, a0, v0		# Make sure valid hi value.
	dmfc0	ta0, COP_0_TLB_HI	# Get current PID
	dmtc0	a0, COP_0_TLB_HI	# look for addr & PID
	TLB_HAZARD
	tlbp				# Probe for the entry.
	TLB_HAZARD			# necessary?
	LA	ta1, CKSEG0_BASE	# Load invalid entry.
	mfc0	v0, COP_0_TLB_INDEX	# See what we got
	bltz	v0, 1f			# index < 0 => !found
	nop
#ifdef CPU_OCTEON
	PTR_SLL	ta2, v0, PAGE_SHIFT + 1
	PTR_ADDU ta1, ta1, ta2
#endif
	dmtc0	ta1, COP_0_TLB_HI	# Mark entry high as invalid

	dmtc0	zero, COP_0_TLB_LO0	# Zero out low entry.
	dmtc0	zero, COP_0_TLB_LO1	# Zero out low entry.
	TLB_HAZARD
	tlbwi
	TLB_HAZARD

#ifdef CPU_LOONGSON2
	li	v0, COP_0_DIAG_ITLB_CLEAR | COP_0_DIAG_BTB_CLEAR | COP_0_DIAG_RAS_DISABLE
	dmtc0	v0, COP_0_DIAG
#endif

1:
	dmtc0	ta0, COP_0_TLB_HI	# restore PID
	mtc0	v1, COP_0_STATUS_REG	# Restore the status register
	MTC0_SR_IE_HAZARD
	j	ra
	nop
END(tlb_flush_addr)

/*---------------------------------------------------------------- tlb_update
 *	Update the TLB if highreg is found; otherwise, enter the data.
 */
LEAF(tlb_update, 0)
	mfc0	v1, COP_0_STATUS_REG	# Save the status register.
	ori	v0, v1, SR_INT_ENAB
	xori	v0, v0, SR_INT_ENAB
	mtc0	v0, COP_0_STATUS_REG	# Disable interrupts
	MTC0_SR_IE_HAZARD
	and	ta1, a0, PG_ODDPG	# ta1 = Even/Odd flag
	dli	v0, (PG_HVPN | PG_ASID_MASK)
	and	a0, a0, v0
	dmfc0	ta0, COP_0_TLB_HI	# Save current PID
	dmtc0	a0, COP_0_TLB_HI	# Init high reg
	and	a2, a1, PG_G		# Copy global bit
	li	a3, TLB_PAGE_MASK
	TLB_HAZARD
	tlbp				# Probe for the entry.
	TLB_HAZARD			# necessary?
	PTE_CLEAR_SWBITS(a1)
	mfc0	v0, COP_0_TLB_INDEX	# See what we got
	bne	ta1, zero, 2f		# Decide even odd
	nop
# EVEN
	bltz	v0, 1f			# index < 0 => !found
	nop

	TLB_HAZARD
	tlbr				# update, read entry first
	TLB_HAZARD			# necessary?
	dmtc0	a1, COP_0_TLB_LO0	# init low reg0.
	TLB_HAZARD
	tlbwi				# update slot found
	TLB_HAZARD
	b	4f
	li	v0, 1
1:
	mtc0	a3, COP_0_TLB_PG_MASK	# init mask.
	dmtc0	a0, COP_0_TLB_HI	# init high reg.
	dmtc0	a1, COP_0_TLB_LO0	# init low reg0.
	dmtc0	a2, COP_0_TLB_LO1	# init low reg1.
	TLB_HAZARD
	tlbwr				# enter into a random slot
	TLB_HAZARD
	b	4f
	li	v0, 0
# ODD
2:
	nop
	bltz	v0, 3f			# index < 0 => !found
	nop

	TLB_HAZARD
	tlbr				# read the entry first
	TLB_HAZARD			# necessary?
	dmtc0	a1, COP_0_TLB_LO1	# init low reg1.
	TLB_HAZARD
	tlbwi				# update slot found
	TLB_HAZARD
	b	4f
	li	v0, 1
3:
	mtc0	a3, COP_0_TLB_PG_MASK	# init mask.
	dmtc0	a0, COP_0_TLB_HI	# init high reg.
	dmtc0	a2, COP_0_TLB_LO0	# init low reg0.
	dmtc0	a1, COP_0_TLB_LO1	# init low reg1.
	TLB_HAZARD
	tlbwr				# enter into a random slot
	TLB_HAZARD
4:
#ifdef CPU_LOONGSON2
	li	v0, COP_0_DIAG_ITLB_CLEAR | COP_0_DIAG_BTB_CLEAR | COP_0_DIAG_RAS_DISABLE
	dmtc0	v0, COP_0_DIAG
#endif

	dmtc0	ta0, COP_0_TLB_HI	# restore PID
	mtc0	v1, COP_0_STATUS_REG	# Restore the status register
	MTC0_SR_IE_HAZARD
	j	ra
	li	v0, 0
END(tlb_update)

/*
 * int64_t tlb_probe(vaddr_t a0);
 * Probe for a TLB entry covering the given address, and return its index
 * (< 0 if no match)
 */
LEAF(tlb_probe, 0)
	mfc0	v1, COP_0_STATUS_REG	# Save the status register.
	ori	v0, v1, SR_INT_ENAB
	xori	v0, v0, SR_INT_ENAB
	mtc0	v0, COP_0_STATUS_REG	# Disable interrupts
	MTC0_SR_IE_HAZARD
	dli	v0, (PG_HVPN | PG_ASID_MASK)
	and	a0, a0, v0
	dmfc0	ta0, COP_0_TLB_HI	# Save current PID
	dmtc0	a0, COP_0_TLB_HI	# Init high reg
	TLB_HAZARD
	tlbp				# Probe for the entry.
	TLB_HAZARD			# necessary?
	mfc0	v0, COP_0_TLB_INDEX	# Return index
	dmtc0	ta0, COP_0_TLB_HI	# restore PID
	mtc0	v1, COP_0_STATUS_REG	# Restore the status register
	MTC0_SR_IE_HAZARD
	j	ra
	nop
END(tlb_probe)

/*
 * void tlb_update_indexed(vaddr_t a0, register_t a1, register_t a2, uint a3);
 * Update a TLB entry pair.
 */
LEAF(tlb_update_indexed, 0)
	mfc0	v1, COP_0_STATUS_REG	# Save the status register.
	ori	v0, v1, SR_INT_ENAB
	xori	v0, v0, SR_INT_ENAB
	mtc0	v0, COP_0_STATUS_REG	# Disable interrupts
	MTC0_SR_IE_HAZARD
	dmfc0	ta0, COP_0_TLB_HI	# Save current PID
	li	ta1, TLB_PAGE_MASK

	mtc0	a3, COP_0_TLB_INDEX
	mtc0	ta1, COP_0_TLB_PG_MASK	# init mask
	dmtc0	a0, COP_0_TLB_HI	# init high reg.

	PTE_CLEAR_SWBITS(a1)
	dmtc0	a1, COP_0_TLB_LO0	# init low reg0.
	PTE_CLEAR_SWBITS(a2)
	dmtc0	a2, COP_0_TLB_LO1	# init low reg1.

	TLB_HAZARD
	tlbwi				# update slot
	TLB_HAZARD

	dmtc0	ta0, COP_0_TLB_HI	# restore PID
	mtc0	v1, COP_0_STATUS_REG	# Restore the status register
	MTC0_SR_IE_HAZARD
	j	ra
	nop
END(tlb_update_indexed)

/*---------------------------------------------------------------- tlb_read
 *	Read the TLB entry.
 */
LEAF(tlb_read, 0)
	mfc0	v1, COP_0_STATUS_REG	# Save the status register.
	ori	v0, v1, SR_INT_ENAB
	xori	v0, v0, SR_INT_ENAB
	mtc0	v0, COP_0_STATUS_REG	# Disable interrupts
	MTC0_SR_IE_HAZARD
	dmfc0	v0, COP_0_TLB_HI	# Get current PID

	mtc0	a0, COP_0_TLB_INDEX	# Set the index register
	TLB_HAZARD
	tlbr				# Read from the TLB
	TLB_HAZARD			# necessary?
	mfc0	ta0, COP_0_TLB_PG_MASK	# fetch the size
	dmfc0	ta1, COP_0_TLB_HI	# fetch the hi entry
	dmfc0	ta2, COP_0_TLB_LO0	# See what we got
	dmfc0	ta3, COP_0_TLB_LO1	# See what we got
	dmtc0	v0, COP_0_TLB_HI	# restore PID
	nop
	nop
	nop				# wait for PID active
	li	a0, TLB_PAGE_MASK
	mtc0	a0, COP_0_TLB_PG_MASK	# Restore default mask value.
	mtc0	v1, COP_0_STATUS_REG	# Restore the status register
	MTC0_SR_IE_HAZARD
	sd	ta0, 0(a1)
	sd	ta1, 8(a1)
	sd	ta2, 16(a1)
	j	ra
	sd	ta3, 24(a1)
END(tlb_read)

/*---------------------------------------------------------------- tlb_get_pid
 *	Read the tlb pid value.
 */
LEAF(tlb_get_pid, 0)
	dmfc0	v0, COP_0_TLB_HI	# get PID
	li	v1, PG_ASID_MASK	# mask off PID
	j	ra
	and	v0, v0, v1		# mask off PID
END(tlb_get_pid)

/*---------------------------------------------------------------- tlb_set_pid
 *	Write the given pid into the TLB pid reg.
 */
LEAF(tlb_set_pid, 0)
	dmtc0	a0, COP_0_TLB_HI		# Write the hi reg value
	TLB_HAZARD
	j	ra
	nop
END(tlb_set_pid)

/*---------------------------------------------------------------- tlb_set_wired
 *	Write the given value into the TLB wired reg.
 */
LEAF(tlb_set_wired, 0)
	mtc0	a0, COP_0_TLB_WIRED
	j	ra
	nop
END(tlb_set_wired)

/*
 *	Initialize the TLB page mask.
 */
LEAF(tlb_set_page_mask, 0)
	mtc0	a0, COP_0_TLB_PG_MASK
	TLB_HAZARD
	j	ra
	nop
END(tlb_set_page_mask)

/*
 *	Initialize the kernel page table pointer.
 *	This is a no-op on non-R8000 processors.
 */
LEAF(tlb_set_gbase, 0)
	j	ra
	 nop
END(tlb_set_gbase)
@


1.46
log
@Define PTE_* macros in one place. Use the lwu instruction for 32-bit PTE
loads on all systems as the TLB code does not need sign extension.
@
text
@d1 1
a1 1
/*	$OpenBSD: tlbhandler.S,v 1.45 2016/08/14 08:23:52 visa Exp $ */
d137 6
@


1.45
log
@Utilize the TLB Execute-Inhibit bit with non-executable mappings on CPUs
that support the Execute-Inhibit exception. This makes user space W^X
effective on Octeon Plus and later Octeon versions.

Feedback from miod@@, thanks!
No objection from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tlbhandler.S,v 1.44 2014/08/12 19:33:59 miod Exp $ */
a44 10

#ifdef MIPS_PTE64
#define	PTE_LOG		3
#define	PTE_LOAD	ld
#define	PTE_OFFS	8
#else
#define	PTE_LOG		2
#define	PTE_LOAD	lw
#define	PTE_OFFS	4
#endif
@


1.44
log
@addu -> PTR_ADDU when doing address arithmetic in the octeon-specific code path.
@
text
@d1 1
a1 1
/*	$OpenBSD: tlbhandler.S,v 1.43 2014/04/09 21:10:35 miod Exp $ */
d163 2
d166 2
a167 2
	dsll	k0, k0, (64 - PG_FRAMEBITS)	# clear bits left of PG_FRAME
	dsll	k1, k1, (64 - PG_FRAMEBITS)
a168 2
	dsrl	k0, k0, (64 - PG_FRAMEBITS)
	dsrl	k1, k1, (64 - PG_FRAMEBITS)
d221 14
a235 1
	dmfc0	k0, COP_0_BAD_VADDR		# get the fault address
d257 1
a257 2
	dsll	k0, k0, (64 - PG_FRAMEBITS)	# clear bits left of PG_FRAME
	dsrl	k0, k0, (64 - PG_FRAMEBITS)
d262 1
a262 2
	dsll	k0, k0, (64 - PG_FRAMEBITS)
	dsrl	k0, k0, (64 - PG_FRAMEBITS)
d280 1
a280 2
	dsll	k0, k0, (64 - PG_FRAMEBITS)	# clear bits left of PG_FRAME
	dsrl	k0, k0, (64 - PG_FRAMEBITS)
d285 1
a285 2
	dsll	k0, k0, (64 - PG_FRAMEBITS)
	dsrl	k0, k0, (64 - PG_FRAMEBITS)
d325 1
a325 2
	dsll	k0, k0, (64 - PG_FRAMEBITS)	# clear bits left of PG_FRAME
	dsrl	k0, k0, (64 - PG_FRAMEBITS)
d327 1
a327 2
	dsll	k1, k1, (64 - PG_FRAMEBITS)
	dsrl	k1, k1, (64 - PG_FRAMEBITS)
d508 1
a508 1
	dsll	a1, a1, (64 - PG_FRAMEBITS)	# clear bits left of PG_FRAME
d511 1
a511 1
	dsrl	a1, a1, (64 - PG_FRAMEBITS)
d614 1
a614 2
	dsll	a1, a1, (64 - PG_FRAMEBITS)	# clear bits left of PG_FRAME
	dsrl	a1, a1, (64 - PG_FRAMEBITS)
d616 1
a616 2
	dsll	a2, a2, (64 - PG_FRAMEBITS)	# clear bits left of PG_FRAME
	dsrl	a2, a2, (64 - PG_FRAMEBITS)
@


1.43
log
@Make trapDump() take the printf-like function as a 2nd parameter.
No functional change; helps non-released kernels with extra debugging code (-:
@
text
@d1 1
a1 1
/*	$OpenBSD: tlbhandler.S,v 1.42 2014/03/24 17:12:01 miod Exp $ */
d400 1
a400 1
	addu	v0, v0, ta2
d414 1
a414 1
	addu	v0, v0, 2 * PAGE_SIZE
d459 1
a459 1
	addu	ta1, ta1, ta2
@


1.42
log
@Make sure tlb_probe() reads the probe result before reenabling interrupts
(egads!). While there, remove leftover instructions from an early flavour of
tlb_update_indexed(), which crept in by accident.
@
text
@d1 1
a1 1
/*	$OpenBSD: tlbhandler.S,v 1.41 2014/03/22 00:01:04 miod Exp $ */
d353 1
d359 1
a359 1
	move	sp, a0
d364 1
@


1.41
log
@Second draft of my attempt to workaround the infamous R4000 end-of-page errata,
affecting R4000 processors revision 2.x and below (found on most R4000 Indigo
and a few R4000 Indy).

Since this errata gets triggered by TLB misses when the code flow crosses a
page boundary, this code attempts to identify code pages prone to trigger the
errata, and force the next page to be mapped for at least as long as the
current pc lies in the troublesome page, by creating wiring extra TLB entries.
These entries get recycled in a lazy-but-aggressive-enough way, either because
of context switches, or because of further tlb exceptions reaching trap().

The errata workaround code is only compiled on R4000-capable kernels (i.e.
sgi GENERIC-IP22 and nothing else), and only enabled on affected processors
(i.e. not on R4000 revision 3, or on R4400).

There is still room for improvemnt in unlucky cases, but in this simple enough
incarnation, this allows my R4000 2.2 Indigo to finally reliably boot multiuser,
even though both /sbin/init and /bin/sh contain code pages which can trigger
the errata.
@
text
@d1 1
a1 1
/*	$OpenBSD: tlbhandler.S,v 1.40 2014/02/08 09:34:04 miod Exp $ */
d580 1
d585 1
a585 1
	mfc0	v0, COP_0_TLB_INDEX	# Return index
a597 2
	dli	v0, (PG_HVPN | PG_ASID_MASK)
	and	a0, a0, v0
a601 4
	TLB_HAZARD
	tlbr
	TLB_HAZARD			# necessary?

@


1.40
log
@Allow page table entries to be either 32 bits wide (the existing state of the
code), or 64 bits wide, if option MIPS_PTE64.
64-bit ptes allow for physical memory beyond 16GB (34 bits) to be addressable
by the pmap code.
@
text
@d1 1
a1 1
/*	$OpenBSD: tlbhandler.S,v 1.39 2013/12/19 20:15:08 miod Exp $ */
d156 8
d165 2
d168 1
a169 2
	dsll	k1, k1, (64 - PG_FRAMEBITS)
	dsrl	k1, k1, (64 - PG_FRAMEBITS)
d187 3
a189 1
_inv_seg:				# No page table for this segment.
d304 1
d561 66
@


1.39
log
@Use shifts instead of integer multiplication by the page size in the
Octeon-specific code paths. No functional change.
ok bcallah@@ pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tlbhandler.S,v 1.38 2012/10/03 11:18:23 miod Exp $ */
d46 10
d150 1
a150 2
	PTR_SRL	k0, k0, PGSHIFT - 2
	andi	k0, k0, ((NPTEPG/2) - 1) << 3
d152 1
d154 2
a155 2
	lw	k0, 0(k1)
	lw	k1, 4(k1)
d174 1
d176 1
a176 1
	dmfc0	k0, COP_0_BAD_VADDR	# must reload.
a182 2
	b	go_k_general
	nop
d211 1
a211 1
	dmfc0	k0, COP_0_BAD_VADDR	# get the fault address
d220 1
a220 1
	PTR_SLL	k0, k0, 2			# compute offset from index
d225 1
a225 1
	and	k0, k0, 4			# check even/odd page
d231 1
a231 1
	lw	k0, 0(k1)			# get PTE entry
d238 1
a238 1
	lw	k0, 4(k1)			# get odd PTE entry
d256 1
a256 1
	lw	k0, 0(k1)			# get PTE entry
d263 1
a263 1
	lw	k0, -4(k1)			# get even PTE entry
d300 1
a300 1
	PTR_SLL	k0, k0, 3			# compute offset from index
d302 2
a303 2
	lw	k0, 0(k1)			# get PTE entry
	lw	k1, 4(k1)			# get odd PTE entry
d341 2
a342 1
	move	sp, a0
a343 1
	move	a2, ra
d346 1
a346 1
	dmfc0	a3, COP_0_BAD_VADDR
d488 2
a490 2
	bne	ta1, zero, 2f		# Decide even odd
	mfc0	v0, COP_0_TLB_INDEX	# See what we got
@


1.38
log
@Split ever-growing mips <machine/cpu.h> into what 99% of the kernel needs,
which will remain in <machine/cpu.h>, and a new mips_cpu.h containing only the
goriest md details, which are only of interest to a handful set of files; this
is similar in spirit to what alpha does, but here <machine/cpu.h> does not
include the new file.
@
text
@d1 1
a1 1
/*	$OpenBSD: tlbhandler.S,v 1.37 2012/09/29 21:37:03 miod Exp $ */
d376 1
a376 1
	mul	ta2, ta1, 2 * PAGE_SIZE
d435 1
a435 1
	mul	ta2, v0, 2 * PAGE_SIZE
@


1.37
log
@Basic R8000 processor support. R8000 processors require MMU-specific code,
exception-specific code, clock-specific code, and L1 cache-specific code. L2
cache is per-design, of which only two exist: SGI Power Indigo2 (IP26) and SGI
Power Challenge (IP21) and are not covered by this commit.

R8000 processors also are 64-bit only processors with 64-bit coprocessor 0
registers, and lack so-called ``compatibility'' memory spaces allowing 32-bit
code to run with sign-extended addresses and registers.

The intrusive changes are covered by #ifdef CPU_R8000 stanzas. However,
trap() is split into a high-level wrapper and a new function, itsa(),
responsible for the actual trap servicing (which name couldn't be helped
because I'm an incorrigible punster). While an R8000 exception may cause
(via trap() ) multiple exceptions to be serviced, non-R8000 processors will
always service one exception in trap(), but they are nevertheless affected
by this code split.
@
text
@d1 1
a1 1
/*	$OpenBSD: tlbhandler.S,v 1.36 2012/09/29 19:02:26 miod Exp $ */
d37 1
@


1.36
log
@Introduce assembly macros for specific processor hazards: tlb update, status
register update, status register update causing a change to the interrupt
enable flag, and a few other arcane ones. <mips64/asm.h> will provide
(supposedly sane) defaults, and <machine/asm.h> may override these with
better tuned versions.

Use these macros instead of random strings of nop in the various .S files
requiring hazard workarounds.
@
text
@d1 1
a1 1
/*	$OpenBSD: tlbhandler.S,v 1.35 2012/04/24 20:01:03 miod Exp $ */
d612 9
@


1.35
log
@Introduce a #define for the number of PFN bits in a pte, to be used in the
.S code when masking the upper bits, instead of hardcoding them. Makes code
easier to understand (and also I might have a need to reduce PFN width on
some particular CPU models in the future).
No change in generated code.
@
text
@d1 1
a1 1
/*	$OpenBSD: tlbhandler.S,v 1.34 2012/04/09 16:54:39 miod Exp $ */
d69 1
a69 1
	eret
d86 1
a86 1
	eret
d151 1
a151 4
	nop				# RM7000 needs 4 nops
	nop
	nop
	nop
d153 1
a153 4
	nop				# RM7000 need 4 for JTLB usage.
	nop
	nop
	nop
d160 1
a160 1
	eret
d211 1
d213 1
d232 1
a232 4
	nop
	nop
	nop
	nop
d234 1
a234 4
	nop
	nop
	nop
	nop
d241 1
a241 1
	eret
d257 1
a257 4
	nop
	nop
	nop
	nop
d259 1
a259 4
	nop
	nop
	nop
	nop
d266 1
a266 1
	eret
d300 1
a300 4
	nop
	nop
	nop
	nop
d302 1
a302 4
	nop
	nop
	nop
	nop
d309 1
a309 1
	eret
a358 47
#if 0	/* currently unused */
/*---------------------------------------------------------------- tlb_write_i
 *	Write the given entry into the TLB at the given index.
 */
LEAF(tlb_write_indexed, 0)
	mfc0	v1, COP_0_STATUS_REG		# Save the status register.
	ori	v0, v1, SR_INT_ENAB
	xori	v0, v0, SR_INT_ENAB
	mtc0	v0, COP_0_STATUS_REG		# Disable interrupts
	ITLBNOPFIX
	ld	a2, 16(a1)
	ld	a3, 24(a1)
	dmfc0	ta0, COP_0_TLB_HI		# Save the current PID.

	dmtc0	a2, COP_0_TLB_LO0		# Set up entry low0.
	dmtc0	a3, COP_0_TLB_LO1		# Set up entry low1.
	ld	a2, 0(a1)
	ld	a3, 8(a1)
	mtc0	a0, COP_0_TLB_INDEX		# Set the index.
	mtc0	a2, COP_0_TLB_PG_MASK		# Set up entry mask.
	dmtc0	a3, COP_0_TLB_HI		# Set up entry high.
	nop
	nop
	nop
	nop
	tlbwi					# Write the TLB
	nop
	nop					# Delay for effect
	nop
	nop

#ifdef CPU_LOONGSON2
	li	v0, COP_0_DIAG_ITLB_CLEAR | COP_0_DIAG_BTB_CLEAR | COP_0_DIAG_RAS_DISABLE
	dmtc0	v0, COP_0_DIAG
#endif

	dmtc0	ta0, COP_0_TLB_HI		# Restore the PID.
	nop
	li	a0, TLB_PAGE_MASK
	mtc0	a0, COP_0_TLB_PG_MASK		# Restore default mask value.
	mtc0	v1, COP_0_STATUS_REG		# Restore the status register
	ITLBNOPFIX
	j	ra
	nop
END(tlb_write_indexed)
#endif

d369 1
a369 1
	ITLBNOPFIX
d393 1
a393 3
	nop
	nop
	nop
d395 1
a395 2
	nop
	nop
d408 1
a408 1
	ITLBNOPFIX
d421 2
a422 2
	ITLBNOPFIX
	dli	v0, (PG_HVPN | PG_ASID)
d426 1
a426 4
	nop
	nop
	nop
	nop
d428 1
a428 3
	nop
	nop				# Delay for effect
	nop
d441 1
a441 4
	nop
	nop
	nop
	nop
d443 1
a443 4
	nop
	nop
	nop
	nop
d453 1
a453 1
	ITLBNOPFIX
d466 1
a466 1
	ITLBNOPFIX
d468 1
a468 1
	dli	v0, (PG_HVPN | PG_ASID)
d474 1
a474 3
	nop
	nop
	nop
d476 1
d485 1
d487 1
a487 3
	nop
	nop
	nop
d489 1
a489 4
	nop
	nop
	nop
	nop
d491 1
d499 1
a499 4
	nop
	nop
	nop
	nop
d501 1
d510 1
d512 1
a512 3
	nop
	nop
	nop
d514 1
a514 4
	nop
	nop
	nop
	nop
d516 1
d524 1
a524 4
	nop
	nop
	nop
	nop
d526 2
a527 7
	nop
	li	v0, 0

4:					# Make sure pipeline
	nop				# advances before we
	nop				# use the tlb.

d535 1
a535 1
	ITLBNOPFIX
d537 1
a537 1
	nop
d548 1
a548 1
	ITLBNOPFIX
d552 1
a552 4
	nop
	nop
	nop
	nop
d554 2
a555 4
	nop
	nop
	nop
	dmfc0	ta0, COP_0_TLB_PG_MASK	# fetch the hi entry
d566 1
a566 1
	ITLBNOPFIX
d579 1
a579 1
	li	v1, VMTLB_PID		# mask off PID
d589 1
a593 9
/*---------------------------------------------------------------- tlb_get_wired
 *	Get the value from the TLB wired reg.
 */
LEAF(tlb_get_wired, 0)
	mfc0	v0, COP_0_TLB_WIRED
	j	ra
	nop
END(tlb_get_wired)

d608 1
@


1.34
log
@More errata bandaid for the R4000SC is necessary in the tlb handlers.
@
text
@d1 1
a1 1
/*	$OpenBSD: tlbhandler.S,v 1.33 2012/03/28 20:44:23 miod Exp $ */
d145 2
a146 2
	dsll	k0, k0, 34
	dsrl	k0, k0, 34
d148 2
a149 2
	dsll	k1, k1, 34
	dsrl	k1, k1, 34
d227 2
a228 2
	dsll	k0, k0, 34			# get rid of "wired" bit
	dsrl	k0, k0, 34
d233 2
a234 2
	dsll	k0, k0, 34
	dsrl	k0, k0, 34
d258 2
a259 2
	dsll	k0, k0, 34			# get rid of wired bit
	dsrl	k0, k0, 34
d264 2
a265 2
	dsll	k0, k0, 34
	dsrl	k0, k0, 34
d310 2
a311 2
	dsll	k0, k0, 34			# get rid of "wired" bit
	dsrl	k0, k0, 34
d313 2
a314 2
	dsll	k1, k1, 34
	dsrl	k1, k1, 34
d561 2
a562 2
	dsll	a1, a1, 34
	dsrl	a1, a1, 34
@


1.33
log
@Work in progress support for the SGI Indigo, Indigo 2 and Indy systems
(IP20, IP22, IP24) in 64-bit mode, adapated from NetBSD. Currently limited
to headless operation, input and video drivers will get ported soon.

Should work on all R4000, R4440 and R5000 based systems. L2 cache on R5000SC
Indy not supported yet (coming soon), R4600 not supported yet either (coming
soon as well).

Tested to boot multiuser on: Indigo2 R4000SC, Indy R4000PC, Indy R4000SC,
Indy R5000SC, Indigo2 R4400SC. There are still glitches in the Ethernet driver
which are being looked at.

Expansion support is limited to the GIO E++ board; GIO boards with PCI-GIO
bridges not ported yet due to the lack of hardware, and this kind of driver
does not port blindly.

Most of this work comes from NetBSD, polishing and integration work, as well
as putting as many ``R4x00 in 64-bit mode'' erratas as necessary, by yours
truly.

More work is coming, as well as trying to get some easy way to boot install
kernels (as older PROM can only boot ECOFF binaries, which won't do for the
kernel).
@
text
@d1 1
a1 1
/*	$OpenBSD: tlbhandler.S,v 1.32 2010/09/12 12:05:37 syuu Exp $ */
d62 1
a62 1
	 * R4000 errata: TLB miss exception may be invoked with BadVAddr
d67 1
a67 1
	bltz	k1, xtlb_miss		# missing!
d72 21
@


1.32
log
@Avoid machine-check exception on OCTEON. ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tlbhandler.S,v 1.31 2010/02/13 14:07:30 miod Exp $ */
d57 16
@


1.31
log
@Since the TLB handler exception code is now always a trampoline to branch
to the handler code in the kernel, we can use relative branches in it to
make it a bit faster.
Also, get rid of the tlbmiss handler and have both the tlb and xtlb refill
exceptions branch to the xtlbmiss handler.
@
text
@d1 1
a1 1
/*	$OpenBSD: tlbhandler.S,v 1.30 2010/02/01 05:26:17 miod Exp $ */
d406 4
d411 1
d420 4
d473 4
@


1.30
log
@On Loongson 2 processors, clear the branch target buffer on userland->kernel
transitions, to work around an evil horde of evil bugs in the processor's
branch prediction logic.

This finally makes the Lemote Yeeloong stable, and I can now spend my
time looking for hair implants resellers.
@
text
@d1 1
a1 1
/*	$OpenBSD: tlbhandler.S,v 1.29 2010/01/28 21:24:08 miod Exp $ */
d50 4
a53 6
 *	Low level TLB exception handler. TLB and XTLB share some
 *	code for the moment and is copied down at the same time.
 *	This code must be PIC and not more than 64 instructions
 *	for both TLB and XTLB handling or it will overflow the
 *	available storage. If the startup code finds out that it
 *	is larger, the trampoline code is copied instead of panicing.
d58 3
a60 3
	.globl	tlb_miss_err_r5k
	.ent	tlb_miss_err_r5k, 0
tlb_miss_err_r5k:
d77 1
a77 1
	bltz	k1, tlb_miss		# missing!
d79 1
a79 1
	j	k_tlb_inv
d81 1
a81 1
	.end	tlb_miss_err_r5k
d84 9
a92 3
	.globl	tlb_miss
	.ent	tlb_miss, 0
tlb_miss:
d96 2
a97 2
	bltz	k0, _k_miss		# kernel address space
	PTR_SRL	k0, k0, SEGSHIFT - LOGREGSZ
a98 1
	andi	k0, k0, (PMAP_SEGTABSIZE - 1) << LOGREGSZ
d104 3
a106 4
	beqz	k1, _inv_seg		# invalid segment map
	PTR_ADDU k1, k1, k0		# index into segment map
	lw	k0, 0(k1)		# get page PTE
tlb_load:
d119 1
a119 1
	nop
d129 1
a129 48
	eret				# RM7000 need 4 for JTLB usage.
	.end	tlb_miss

/*---------------------------------------------------------------- xtlb_miss
 *	Low level XTLB exception handler.
 */
#if defined(CPU_R5000) || defined(CPU_RM7000)
	.globl	xtlb_miss_err_r5k
	.ent	xtlb_miss_err_r5k, 0
xtlb_miss_err_r5k:
	/* See errata comments in tlb_miss above */
	tlbp
	mfc0	k1, COP_0_TLB_INDEX
	bltz	k1, xtlb_miss		# missing!
	 nop
	j	k_tlb_inv
	 nop
	.end	xtlb_miss_err_r5k
#endif	/* CPU_R5000 || CPU_RM7000 */

	.globl	xtlb_miss
	.ent	xtlb_miss, 0
xtlb_miss:
	dmfc0	k0, COP_0_BAD_VADDR
	bltz	k0, _k_miss		# kernel address space
	PTR_SRL	k0, k0, SEGSHIFT
	sltiu	k1, k0, PMAP_SEGTABSIZE
	beqz	k1, _inv_seg		# wrong if outside pm_segtab
	nop
	GET_CPU_INFO(k1, k0)
	PTR_L	k1, CI_CURPROCPADDR(k1)
	dmfc0	k0, COP_0_BAD_VADDR
	PTR_SRL	k0, k0, SEGSHIFT
	PTR_SLL	k0, k0, LOGREGSZ
	PTR_L	k1, PCB_SEGTAB(k1)
	PTR_ADDU k1, k1, k0
	PTR_L	k1, 0(k1)		# get pointer to page table
	dmfc0	k0, COP_0_BAD_VADDR
	PTR_SRL	k0, k0, PGSHIFT - 2
	andi	k0, k0, ((NPTEPG/2) - 1) << 3
	beqz	k1, _inv_seg
	PTR_ADDU k1, k1, k0
	b	tlb_load		# rest is same as 'tlb_miss'
	lw	k0, 0(k1)

_inv_seg:
	j	tlb_miss_nopt		# No page table for this segment.
	nop
d132 1
a132 1
	j	k_tlb_miss		# kernel tlbmiss.
a133 1
	.end	xtlb_miss
d135 1
a135 3
	.globl	tlb_miss_nopt
	.ent	tlb_miss_nopt, 0
tlb_miss_nopt:
d140 4
d146 13
a158 1
	.end	tlb_miss_nopt
d225 1
a225 1
	beq	k0, zero, go_k_general	# PTE invalid
a333 18
go_k_general:
	j	k_general
	nop

go_u_general:
#ifdef CPU_LOONGSON2
	/*
	 * To work around a branch prediction issue on earlier LS2F
	 * chips, it is necessary to clear the BTB upon
	 * userland->kernel boundaries.
	 */
	li	k0, COP_0_DIAG_BTB_CLEAR | COP_0_DIAG_RAS_DISABLE
	dmtc0	k0, COP_0_DIAG
#endif
	j	u_general
	nop


d344 1
a344 1
#if 0
@


1.29
log
@The RA stack control bit on the loongson2 diagnostic register is not a clear
but a disable bit; rename the define and keep the RA stack disabled at all
times - I blame the few remaining hard freezes on it.
@
text
@d1 1
a1 1
/*	$OpenBSD: tlbhandler.S,v 1.28 2010/01/28 05:27:16 miod Exp $ */
d371 9
@


1.28
log
@Make sure we also cause an iTLB and BTB flush on loongson processors during
regular tlb replacement, as well. Helps stability a lot, still not perfect.
@
text
@d1 1
a1 1
/*	$OpenBSD: tlbhandler.S,v 1.27 2010/01/21 17:52:25 miod Exp $ */
d123 1
a123 1
	li	k0, COP_0_DIAG_ITLB_CLEAR | COP_0_DIAG_BTB_CLEAR
d242 1
a242 1
	li	k0, COP_0_DIAG_ITLB_CLEAR | COP_0_DIAG_BTB_CLEAR
d273 1
a273 1
	li	k0, COP_0_DIAG_ITLB_CLEAR | COP_0_DIAG_BTB_CLEAR
d322 1
a322 1
	li	k0, COP_0_DIAG_ITLB_CLEAR | COP_0_DIAG_BTB_CLEAR
d417 1
a417 1
	li	v0, COP_0_DIAG_ITLB_CLEAR | COP_0_DIAG_BTB_CLEAR
d467 1
a467 1
	li	v0, COP_0_DIAG_ITLB_CLEAR | COP_0_DIAG_BTB_CLEAR
d520 1
a520 1
	li	v0, COP_0_DIAG_ITLB_CLEAR | COP_0_DIAG_BTB_CLEAR
d620 1
a620 1
	li	v0, COP_0_DIAG_ITLB_CLEAR | COP_0_DIAG_BTB_CLEAR
@


1.27
log
@*Write* to the magic Loongson2 register to invalidate iTLB and branch
prediction caches, instead of *reading* it. Ahem. Blush.
Yeelong lemote now run single user.
@
text
@d1 1
a1 1
/*	$OpenBSD: tlbhandler.S,v 1.26 2010/01/09 23:43:17 miod Exp $ */
d121 6
d226 1
a226 1
	beq	k0, zero, go_k_general	# PTE invalid
d242 2
a243 10
#if 0	/* enable if Loongson2 + R5K|R10K kernel ever exist... */
	mfc0	v0, COP_0_PRID
	and	v0, 0xff00
	sub	v0, (MIPS_LOONGSON2 << 8)
	bnez	v0, 7f
	nop
#endif
	li	v0, COP_0_DIAG_ITLB_CLEAR
	dmtc0	v0, COP_0_DIAG
7:
d273 2
a274 10
#if 0	/* enable if Loongson2 + R5K|R10K kernel ever exist... */
	mfc0	v0, COP_0_PRID
	and	v0, 0xff00
	sub	v0, (MIPS_LOONGSON2 << 8)
	bnez	v0, 7f
	nop
#endif
	li	v0, COP_0_DIAG_ITLB_CLEAR
	dmtc0	v0, COP_0_DIAG
7:
d320 6
d417 1
a417 8
#if 0	/* enable if Loongson2 + R5K|R10K kernel ever exist... */
	mfc0	v0, COP_0_PRID
	and	v0, 0xff00
	sub	v0, (MIPS_LOONGSON2 << 8)
	bnez	v0, 7f
	nop
#endif
	li	v0, COP_0_DIAG_ITLB_CLEAR
a418 1
7:
d467 1
a467 8
#if 0	/* enable if Loongson2 + R5K|R10K kernel ever exist... */
	mfc0	v0, COP_0_PRID
	and	v0, 0xff00
	sub	v0, (MIPS_LOONGSON2 << 8)
	bnez	v0, 7f
	nop
#endif
	li	v0, COP_0_DIAG_ITLB_CLEAR
a468 1
7:
d520 1
a520 8
#if 0	/* enable if Loongson2 + R5K|R10K kernel ever exist... */
	mfc0	v0, COP_0_PRID
	and	v0, 0xff00
	sub	v0, (MIPS_LOONGSON2 << 8)
	bnez	v0, 7f
	nop
#endif
	li	v0, COP_0_DIAG_ITLB_CLEAR
a521 1
7:
d620 1
a620 8
#if 0	/* enable if Loongson2 + R5K|R10K kernel ever exist... */
	mfc0	v0, COP_0_PRID
	and	v0, 0xff00
	sub	v0, (MIPS_LOONGSON2 << 8)
	bnez	v0, 7f
	nop
#endif
	li	v0, COP_0_DIAG_ITLB_CLEAR
a621 1
7:
@


1.26
log
@Move more R5000 code behind proper #ifdef stanzas.
@
text
@d1 1
a1 1
/*	$OpenBSD: tlbhandler.S,v 1.25 2009/12/12 20:07:10 miod Exp $ */
d239 1
a239 1
	subi	v0, (MIPS_LOONGSON2 << 8)
d244 1
a244 1
	mfc0	v0, COP_0_DIAG
d278 1
a278 1
	subi	v0, (MIPS_LOONGSON2 << 8)
d283 1
a283 1
	mfc0	v0, COP_0_DIAG
d424 1
a424 1
	subi	v0, (MIPS_LOONGSON2 << 8)
d429 1
a429 1
	mfc0	v0, COP_0_DIAG
d482 1
a482 1
	subi	v0, (MIPS_LOONGSON2 << 8)
d487 1
a487 1
	mfc0	v0, COP_0_DIAG
d543 1
a543 1
	subi	v0, (MIPS_LOONGSON2 << 8)
d548 1
a548 1
	mfc0	v0, COP_0_DIAG
d651 1
a651 1
	subi	v0, (MIPS_LOONGSON2 << 8)
d656 1
a656 1
	mfc0	v0, COP_0_DIAG
@


1.25
log
@Introduce various CPU_### options to enable cpu-specific code or workarounds;
be sure to rerun config(8) on your kernel configuration files.
@
text
@d1 1
a1 1
/*	$OpenBSD: tlbhandler.S,v 1.24 2009/12/07 19:05:59 miod Exp $ */
d127 1
d139 1
@


1.24
log
@Support for 16KB page size kernels; page size is now set in <machine/param.h>
rather than <mips64/param.h>.

For now, kernels are kept at 4KB to give people some time to build 16KB
compatible binaries; this will change before the end of this release cycle.

Use of 16KB page size kernels yields a 18% speedup (which, offset by the
1.6% slowdown caused by the pmap changes, yields a 16.6% overall speedup).
@
text
@d1 1
a1 1
/*	$OpenBSD: tlbhandler.S,v 1.23 2009/12/07 18:54:46 miod Exp $ */
d59 1
d84 1
@


1.23
log
@Be sure to always check tlbp return values for strictly negative values
to consider the probe as failed; tlb pair #0 does not deserve to be magic
in any way.
@
text
@d1 1
a1 1
/*	$OpenBSD: tlbhandler.S,v 1.22 2009/11/19 20:16:27 miod Exp $ */
d390 1
a390 1
	mfc0	v1, COP_0_STATUS_REG	# Save the status register.
d393 1
a393 1
	mtc0	v0, COP_0_STATUS_REG	# Disable interrupts
d403 2
a404 2
	mtc0	a0, COP_0_TLB_INDEX	# Set the index.
	dmtc0	a2, COP_0_TLB_PG_MASK	# Set up entry mask.
d431 3
a433 2
	dmtc0	zero, COP_0_TLB_PG_MASK	# Default mask value.
	mtc0	v1, COP_0_STATUS_REG	# Restore the status register
d488 2
d571 1
d597 1
a597 1
	mtc0	zero, COP_0_TLB_PG_MASK	# init mask.
d627 1
a627 1
	mtc0	zero, COP_0_TLB_PG_MASK	# init mask.
d691 2
d738 9
@


1.22
log
@Rename KSEG* defines to CKSEG* to match their names in 64 bit mode; also
define more 64 bit spaces.
@
text
@d1 1
a1 1
/*	$OpenBSD: tlbhandler.S,v 1.21 2009/11/18 20:58:52 miod Exp $ */
d209 1
a209 1
	blez	k0, sys_stk_chk			# probe fail or index 0!
d248 1
a248 1
	blez	k0, sys_stk_chk			# probe fail or index 0!
@


1.21
log
@Stricter type usage (width and signedness); first step towards 64 bit ptes.
@
text
@d1 1
a1 1
/*	$OpenBSD: tlbhandler.S,v 1.20 2009/09/30 06:22:00 syuu Exp $ */
d451 1
a451 1
	LA	v0, KSEG0_BASE		# invalid address
d514 1
a514 1
	LA	ta1, KSEG0_BASE		# Load invalid entry.
@


1.20
log
@curproc, curprocpaddr moved into cpu_info
OK miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tlbhandler.S,v 1.19 2009/08/06 21:11:39 miod Exp $ */
d502 1
a502 1
	li	v0, (PG_HVPN | PG_ASID)
d562 2
a563 2
	and	ta1, a0, 0x1000		# ta1 = Even/Odd flag
	li	v0, (PG_HVPN | PG_ASID)
@


1.19
log
@Work in progress support for Loongson2E/2F processors; need option CPU_LOONGSON2
in the kernel to be brought in, due to invasive differences in tlb operation.
Comes with a separate cache operations file due to the cache being R5k-style
with R10k-style way number encoding.
@
text
@d1 1
a1 1
/*	$OpenBSD: tlbhandler.S,v 1.18 2009/05/25 17:10:38 miod Exp $ */
d87 2
a88 1
	PTR_L	k1, curprocpaddr
d145 5
a150 1
	PTR_L	k1, curprocpaddr
d329 2
a330 1
	PTR_L	k1, curprocpaddr
@


1.18
log
@Years ago, I fixed an R5000 O2 instability by implementing a workaround for
a chip bug, which was supposed to be fixed in that particular revision of
the die but wasn't (tlbhandler.S 1.16).

Being lazy, I did not write a runtime selection of the appropriate TLB
handler code, although this was on my list.

It turns out that this fix confuses the hell of R10000 processors revision 3
(but not earlier 2.x revisions), to the point of making the Origin 200 here
hang so hard it would not even enter the NMI handler (don't ask me how I
figured this was the cause).

So it's time to choose the appropriate TLB handling flavour at runtime,
building the trampoline code from the fixed exception handler location
jumping to the handler address at runtime. As a bonus, kernels linked in
KSEG0 get the address computation optimized and thus a smaller trampoline
than before.
@
text
@d1 1
a1 1
/*	$OpenBSD: tlbhandler.S,v 1.17 2009/05/22 20:37:53 miod Exp $ */
d39 3
d225 14
d264 14
d379 1
d410 13
d431 1
d467 13
d525 14
d632 14
@


1.17
log
@Drop almost unused <machine/psl.h> on sgi; move USERMODE() definition from
there to trap.c which is its only user. This also cleans up multiple
inclusion of <machine/cpu.h> (because <machine/psl.h> includes it) in many
places.
@
text
@d1 1
a1 1
/*	$OpenBSD: tlbhandler.S,v 1.16 2007/05/25 20:58:39 miod Exp $ */
a39 2
#define	HAIRY_R5000_ERRATA

a53 2
/*****************************  Start of code copied to exception vector */
	.globl	tlb_miss	/* 0xffffffff80000000 */
d55 4
a58 3
	.ent	tlb_miss, 0
tlb_miss:
#ifdef HAIRY_R5000_ERRATA
d75 1
a75 1
	bltz	k1, 1f			# missing!
d79 5
a83 2
1:
#endif
a117 3
	.globl	e_tlb_miss
e_tlb_miss:

d121 3
a123 5
	.globl	xtlb_miss	/* 0xffffffff80000080 */
	.set	noat
	.ent	xtlb_miss, 0
xtlb_miss:
#ifdef HAIRY_R5000_ERRATA
d127 1
a127 1
	bltz	k1, 1f			# missing!
d131 5
a135 2
1:
#endif
a162 5
	.globl	e_xtlb_miss
e_xtlb_miss:
	.set	at
/*****************************  End of code copied to exception vector */

a165 1
	.set	noat
a172 1
	.set	at
a173 23
/*
 * Trampolines copied to exception vectors when code is too big.
 */
	.globl	tlb_miss_tramp
	.ent	tlb_miss_tramp, 0
tlb_miss_tramp:
	.set	noat
	LA	k0, tlb_miss
	jr	k0
	nop
	.end	tlb_miss_tramp
	.set	at
	.globl	e_tlb_miss_tramp
e_tlb_miss_tramp:

	.globl	xtlb_miss_tramp
	.ent	xtlb_miss_tramp, 0
xtlb_miss_tramp:
	.set	noat
	LA	k0, xtlb_miss
	jr	k0
	nop
	.end	xtlb_miss_tramp
a174 3
	.globl	e_xtlb_miss_tramp
e_xtlb_miss_tramp:

@


1.16
log
@Edge cases can trigger a TLB miss exception instead of an invalid TLB
exception on early R5000 revisions. Despite this bug being supposedly
fixed in R5000 revision 2 onwards, it nevertheless occurs quite frequently
on matthieu's revision 2.1 R5000.

Servicing the TLB miss exception would cause a duplicate TLB to be inserted,
which causes the processor operation to become unpredictable (but lethal to
the kernel, ten times out of nine).

More details about the problem can be found in:
  http://www.linux-mips.org/archives/linux-mips/2000-02/msg00040.html

We work around the issue by checking for an existing TLB entry, and handling
this as an invalid TLB exception (as it was intended to be), in this case.

Unfortunately this causes a measurable 1% slowdown on ``safe'' processors,
so we'll work on providing different tlb handler flavours in the near future
to recover from this.
@
text
@d1 1
a1 1
/*	$OpenBSD: tlbhandler.S,v 1.15 2007/05/25 20:47:19 miod Exp $ */
a33 1
#include <machine/psl.h>
@


1.15
log
@Unifdef TLB_TRACE and TLBTRACE, no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: tlbhandler.S,v 1.14 2007/05/01 20:40:18 miod Exp $ */
d41 2
d62 23
d129 10
@


1.14
log
@ELF symbol type fixes, no code change
@
text
@d1 1
a1 1
/*	$OpenBSD: tlbhandler.S,v 1.13 2006/03/04 19:33:21 miod Exp $ */
a59 39
#ifdef TLB_TRACE
	dmfc0	k0, COP_0_EXC_PC
	PTR_L	k1, tlbtrcptr
	PTR_S	k0, 0(k1)
	dmfc0	k0, COP_0_BAD_VADDR
	PTR_S	zero, 2*REGSZ(k1)
	PTR_S	zero, 3*REGSZ(k1)
	bltz	k0, 1f			# kernel address
	PTR_S	k0, REGSZ(k1)

	PTR_L	k1, curprocpaddr
	PTR_L	k1, PCB_SEGTAB(k1)
	PTR_SRL	k0, k0, SEGSHIFT - LOGREGSZ
	andi	k0, k0, (PMAP_SEGTABSIZE - 1) << LOGREGSZ
	PTR_ADDU k1, k1, k0
	PTR_L	k0, 0(k1)		# get pointer to page table
	PTR_L	k1, tlbtrcptr
	PTR_S	k0, 2*REGSZ(k1)
	beqz	k0, 1f
	dmfc0	k1, COP_0_BAD_VADDR

	PTR_SRL	k1, k1, PGSHIFT - 2
	andi	k1, k1, ((NPTEPG/2) - 1) << 3
	PTR_ADDU k1, k1, k0		# index into segment map
	lwu	k0, 0(k1)		# get page PTE
	dsll	k0, k0, 32
	lwu	k1, 4(k1)
	or	k0, k1
	PTR_L	k1, tlbtrcptr
	PTR_S	k0, 3*REGSZ(k1)
1:
	PTR_L	k1, tlbtrcptr
	PTR_ADDU k1, 4*REGSZ
	LI	k0, 0x100
	nor	k0, zero, k0
	and	k1, k0
	LA	k0, tlbtrcptr
	PTR_S	k1, 0(k0)
#endif
@


1.13
log
@Typos grab bag of the month, eyeballed by jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tlbhandler.S,v 1.12 2005/12/20 07:06:26 miod Exp $ */
d58 1
d131 1
d141 1
d168 1
d175 2
d185 1
d192 1
d198 1
d204 1
d210 1
@


1.12
log
@Since we are allowed to rely on the fact that the pcb is the first element
of struct user, use syntactic sugar in genassym.cf and use PCB_xxx defines
instead of U_PCB_xxx, like all other platforms do; no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: tlbhandler.S,v 1.11 2005/12/17 20:17:46 miod Exp $ */
d182 1
a182 1
 * Trampolines copied to exception vectors when code is to big.
d467 1
a467 1
	and	a0, a0, v0		# Make shure valid hi value.
d585 1
a585 1
4:					# Make shure pipeline
d587 1
a587 1
	nop				# uses the tlb.
@


1.11
log
@Let the xtlb refill handler fault if the userland va is out of the supported
address space instead of using the tlb of the va modulo the address space size.

ok pefo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tlbhandler.S,v 1.10 2004/10/20 12:49:15 pefo Exp $ */
d70 1
a70 1
	PTR_L	k1, U_PCB_SEGTAB(k1)
d102 1
a102 1
	PTR_L	k1, U_PCB_SEGTAB(k1)
d147 1
a147 1
	PTR_L	k1, U_PCB_SEGTAB(k1)
@


1.10
log
@Fix some 64 bit address problems.
Some function names made more unique.
Other changes for the upcoming Origin 200 support.
@
text
@d1 1
a1 1
/*	$OpenBSD: tlbhandler.S,v 1.9 2004/09/27 20:39:27 pefo Exp $ */
d72 1
a72 1
	andi	k0, k0, 0x1ff << LOGREGSZ
d103 1
a103 1
	andi	k0, k0, 0x1ff << LOGREGSZ
d109 1
a109 1
	beq	k1, zero, _inv_seg	# invalid segment map
a135 1
 * XXX!	This handler should be changed to handle larger segtabs.
d140 6
a146 3
	dmfc0	k0, COP_0_BAD_VADDR
	bltz	k0, _k_miss
	PTR_SRL	k0, k0, SEGSHIFT - LOGREGSZ
a147 1
	andi	k0, k0, 0x1ff << LOGREGSZ
d153 1
a153 1
	beq	k1, zero, _inv_seg
@


1.9
log
@R5K seems to have bugs/hazards
@
text
@d1 1
a1 1
/*	$OpenBSD: tlbhandler.S,v 1.8 2004/09/27 19:13:25 pefo Exp $ */
d186 2
a187 1
	j	tlb_miss
d196 2
a197 1
	j	xtlb_miss
d381 3
a383 1
	mtc0	zero, COP_0_STATUS_REG	# Disable interrupts
d385 2
a386 2
	lw	a2, 8(a1)
	lw	a3, 12(a1)
d391 2
a392 2
	lw	a2, 0(a1)
	lw	a3, 4(a1)
d422 3
a424 1
	mtc0	zero, COP_0_STATUS_REG	# Disable interrupts
d461 3
a463 1
	mtc0	zero, COP_0_STATUS_REG	# Disable interrupts
d507 3
a509 1
	mtc0	zero, COP_0_STATUS_REG	# Disable interrupts
d599 3
a601 1
	mtc0	zero, COP_0_STATUS_REG	# Disable interrupts
d614 1
a614 1
	mfc0	ta0, COP_0_TLB_PG_MASK	# fetch the hi entry
d624 3
a626 3
	sw	ta0, 0(a1)
	sw	ta1, 4(a1)
	sw	ta2, 8(a1)
d628 1
a628 1
	sw	ta3, 12(a1)
@


1.8
log
@reorder slightly to avoid asm warnings
@
text
@d1 1
a1 1
/*	$OpenBSD: tlbhandler.S,v 1.7 2004/09/10 10:39:45 miod Exp $ */
d216 1
a216 1
	PTR_SLL	k0, k0, 2			# compute offset from index
d219 1
@


1.7
log
@Need to sync NLEAF() occurences too.
@
text
@d1 1
a1 1
/*	$OpenBSD: tlbhandler.S,v 1.6 2004/09/10 09:32:13 pefo Exp $ */
a44 3
/* XXX pipeline drainer fix for older RM7000 cpus. */
#define	ITLBNOPFIX	nop;nop;nop;nop;nop;nop;nop;nop;nop;nop;

d216 2
a218 2

	PTR_SLL	k0, k0, 2			# compute offset from index
d294 1
a295 1
	PTR_SRL	k0, k0, 1
@


1.6
log
@Use correct register aliases wrt the __mips_n64 regdef.
@
text
@d1 1
a1 1
/*	$OpenBSD: tlbhandler.S,v 1.5 2004/09/10 08:58:27 pefo Exp $ */
d210 1
a210 1
NLEAF(k_tlb_inv)
d286 1
a286 1
NLEAF(k_tlb_miss)
@


1.5
log
@Fix LEAF usage adding new extra arg. spotted by miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: tlbhandler.S,v 1.4 2004/09/09 22:11:38 pefo Exp $ */
d385 1
a385 1
	dmfc0	ta4, COP_0_TLB_HI		# Save the current PID.
d404 1
a404 1
	dmtc0	ta4, COP_0_TLB_HI		# Restore the PID.
d422 1
a422 1
	mfc0	ta5, COP_0_TLB_WIRED
d424 1
a424 1
	dmfc0	ta4, COP_0_TLB_HI	# Save the PID
d431 1
a431 1
 * Align the starting value (ta5) and the upper bound (a0).
d434 2
a435 2
	mtc0	ta5, COP_0_TLB_INDEX	# Set the index register.
	addu	ta5, ta5, 1		# Increment index.
d442 1
a442 1
	bne	ta5, a0, 1b
d445 1
a445 1
	dmtc0	ta4, COP_0_TLB_HI	# Restore the PID
d461 1
a461 1
	dmfc0	ta4, COP_0_TLB_HI	# Get current PID
d471 1
a471 1
	LA	ta5, KSEG0_BASE		# Load invalid entry.
d475 1
a475 1
	dmtc0	ta5, COP_0_TLB_HI	# Mark entry high as invalid
d489 1
a489 1
	dmtc0	ta4, COP_0_TLB_HI	# restore PID
d503 1
a503 1
	and	ta5, a0, 0x1000		# ta5 = Even/Odd flag
d506 1
a506 1
	dmfc0	ta4, COP_0_TLB_HI	# Save current PID
d515 1
a515 1
	bne	ta5, zero, 2f		# Decide even odd
d579 1
a579 1
	dmtc0	ta4, COP_0_TLB_HI	# restore PID
d604 4
a607 4
	mfc0	ta4, COP_0_TLB_PG_MASK	# fetch the hi entry
	dmfc0	ta5, COP_0_TLB_HI	# fetch the hi entry
	dmfc0	ta6, COP_0_TLB_LO0	# See what we got
	dmfc0	ta7, COP_0_TLB_LO1	# See what we got
d614 3
a616 3
	sw	ta4, 0(a1)
	sw	ta5, 4(a1)
	sw	ta6, 8(a1)
d618 1
a618 1
	sw	ta7, 12(a1)
@


1.4
log
@Kernel moves to 64 bit. A few more tweaks when binutils is updated.
@
text
@d1 1
a1 1
/*	$OpenBSD: tlbhandler.S,v 1.3 2004/08/10 20:15:47 deraadt Exp $ */
d379 1
a379 1
LEAF(tlb_write_indexed)
d418 1
a418 1
LEAF(tlb_flush)
d455 1
a455 1
LEAF(tlb_flush_addr)
d499 1
a499 1
LEAF(tlb_update)
d589 1
a589 1
LEAF(tlb_read)
d624 1
a624 1
LEAF(tlb_get_pid)
d634 1
a634 1
LEAF(tlb_set_pid)
d643 1
a643 1
LEAF(tlb_get_wired)
d652 1
a652 1
LEAF(tlb_set_wired)
@


1.3
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: tlbhandler.S,v 1.2 2004/08/09 14:57:26 pefo Exp $ */
d134 3
d168 2
a169 2
	.globl	e_tlb_miss
e_tlb_miss:
d328 5
a332 3
	PTR_S	sp, CF_ARGSZ+2*REGSZ(a0)
	move	sp, a0
	LA	a0, 1f
a334 1
	dmfc0	a1, COP_0_EXC_PC
d337 4
d342 1
d346 1
a346 1
	la	sp, start-FRAMESZ(CF_SZ)	# set sp to a valid place
d385 1
a385 1
	dmfc0	t0, COP_0_TLB_HI		# Save the current PID.
d404 1
a404 1
	dmtc0	t0, COP_0_TLB_HI		# Restore the PID.
d422 1
a422 1
	mfc0	t1, COP_0_TLB_WIRED
d424 1
a424 1
	dmfc0	t0, COP_0_TLB_HI	# Save the PID
d431 1
a431 1
 * Align the starting value (t1) and the upper bound (a0).
d434 2
a435 2
	mtc0	t1, COP_0_TLB_INDEX	# Set the index register.
	addu	t1, t1, 1		# Increment index.
d442 1
a442 1
	bne	t1, a0, 1b
d445 1
a445 1
	dmtc0	t0, COP_0_TLB_HI	# Restore the PID
d461 1
a461 1
	dmfc0	t0, COP_0_TLB_HI	# Get current PID
d471 1
a471 1
	LA	t1, KSEG0_BASE		# Load invalid entry.
d475 1
a475 1
	dmtc0	t1, COP_0_TLB_HI	# Mark entry high as invalid
d489 1
a489 1
	dmtc0	t0, COP_0_TLB_HI	# restore PID
d503 1
a503 1
	and	t1, a0, 0x1000		# t1 = Even/Odd flag
d506 1
a506 1
	dmfc0	t0, COP_0_TLB_HI	# Save current PID
d515 1
a515 1
	bne	t1, zero, 2f		# Decide even odd
d579 1
a579 1
	dmtc0	t0, COP_0_TLB_HI	# restore PID
d593 1
a593 1
	dmfc0	t0, COP_0_TLB_HI	# Get current PID
d604 5
a608 5
	mfc0	t2, COP_0_TLB_PG_MASK	# fetch the hi entry
	dmfc0	t3, COP_0_TLB_HI	# fetch the hi entry
	dmfc0	t4, COP_0_TLB_LO0	# See what we got
	dmfc0	t5, COP_0_TLB_LO1	# See what we got
	dmtc0	t0, COP_0_TLB_HI	# restore PID
d614 3
a616 3
	sw	t2, 0(a1)
	sw	t3, 4(a1)
	sw	t4, 8(a1)
d618 1
a618 1
	sw	t5, 12(a1)
@


1.2
log
@Big cleanup. Removed some unused obsolete stuff and fixed copyrights
on some files. Arcbios support is now in, thus detects memorysize and cpu
clock frequency.
@
text
@d1 1
a1 1
/*	$OpenBSD: tlbhandler.S,v 1.1 2004/08/06 20:56:03 pefo Exp $ */
d5 1
a5 1
 * 
d69 1
a69 1
	bltz	k0, 1f			# kernel address 
d136 1
a136 1
 * XXX!	This handler should be changed to handle larger segtabs. 
d164 1
a164 1
	
@


1.1
log
@initial mips64
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d62 1
a62 1
#if 0
@

