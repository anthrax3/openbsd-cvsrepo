head	1.22;
access;
symbols
	OPENBSD_6_1:1.22.0.20
	OPENBSD_6_1_BASE:1.22
	OPENBSD_6_0:1.22.0.16
	OPENBSD_6_0_BASE:1.22
	OPENBSD_5_9:1.22.0.12
	OPENBSD_5_9_BASE:1.22
	OPENBSD_5_8:1.22.0.14
	OPENBSD_5_8_BASE:1.22
	OPENBSD_5_7:1.22.0.6
	OPENBSD_5_7_BASE:1.22
	OPENBSD_5_6:1.22.0.10
	OPENBSD_5_6_BASE:1.22
	OPENBSD_5_5:1.22.0.8
	OPENBSD_5_5_BASE:1.22
	OPENBSD_5_4:1.22.0.4
	OPENBSD_5_4_BASE:1.22
	OPENBSD_5_3:1.22.0.2
	OPENBSD_5_3_BASE:1.22
	OPENBSD_5_2:1.20.0.8
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.6
	OPENBSD_5_0:1.20.0.4
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.20.0.2
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.19.0.4
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.19.0.2
	OPENBSD_4_7_BASE:1.19
	OPENBSD_4_6:1.16.0.4
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.15.0.6
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.4
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.15.0.2
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.14.0.2
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.11.0.6
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.4
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.11.0.2
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.10.0.4
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.2
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.6.0.2
	OPENBSD_3_6_BASE:1.6;
locks; strict;
comment	@# @;


1.22
date	2012.10.03.11.18.23;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2012.09.29.19.02.26;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2010.09.21.20.29.17;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2010.01.08.01.35.52;	author syuu;	state Exp;
branches;
next	1.18;

1.18
date	2010.01.01.15.04.00;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2009.09.30.06.22.00;	author syuu;	state Exp;
branches;
next	1.16;

1.16
date	2009.05.22.20.37.53;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2007.10.18.04.32.25;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2007.07.16.20.23.09;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2007.05.07.18.42.13;	author kettenis;	state Exp;
branches;
next	1.12;

1.12
date	2007.04.26.17.04.32;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2005.12.20.07.06.26;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2004.11.08.20.55.45;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2004.10.30.14.48.59;	author pefo;	state Exp;
branches;
next	1.8;

1.8
date	2004.10.20.12.49.15;	author pefo;	state Exp;
branches;
next	1.7;

1.7
date	2004.09.27.19.16.06;	author pefo;	state Exp;
branches;
next	1.6;

1.6
date	2004.09.10.08.58.27;	author pefo;	state Exp;
branches;
next	1.5;

1.5
date	2004.09.09.22.11.38;	author pefo;	state Exp;
branches;
next	1.4;

1.4
date	2004.08.15.18.35.58;	author pefo;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.10.20.15.47;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2004.08.09.14.57.26;	author pefo;	state Exp;
branches;
next	1.1;

1.1
date	2004.08.06.20.56.03;	author pefo;	state Exp;
branches;
next	;


desc
@@


1.22
log
@Split ever-growing mips <machine/cpu.h> into what 99% of the kernel needs,
which will remain in <machine/cpu.h>, and a new mips_cpu.h containing only the
goriest md details, which are only of interest to a handful set of files; this
is similar in spirit to what alpha does, but here <machine/cpu.h> does not
include the new file.
@
text
@/*	$OpenBSD: lcore_float.S,v 1.21 2012/09/29 19:02:26 miod Exp $ */

/*
 * Copyright (c) 2001-2003 Opsycon AB  (www.opsycon.se / www.opsycon.com)
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */
#include <sys/errno.h>
#include <sys/syscall.h>

#include <machine/param.h>
#include <machine/asm.h>
#include <machine/cpu.h>
#include <mips64/mips_cpu.h>
#include <machine/regnum.h>
#include <machine/cpustate.h>

#include "assym.h"

	.set	mips3
	.set	noreorder		# Noreorder is default style!

/*----------------------------------------------------------------------------
 *
 * MipsSwitchFPState --
 *
 *	Save the current state into 'from' and restore it from 'to'.
 *
 *	MipsSwitchFPState(from, to)
 *		struct proc *from;
 *		struct user *to;
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------------
 */
LEAF(MipsSwitchFPState, 0)
	MFC0	t1, COP_0_STATUS_REG	# Save old SR
	MFC0_HAZARD
	or	t0, t1, SR_COP_1_BIT|SR_FR_32	# enable the coprocessor
	MTC0	t0, COP_0_STATUS_REG
	MTC0_SR_CU_HAZARD

	beq	a0, zero, 1f		# skip save if NULL pointer
	 NOP
/*
 * First read out the status register to make sure that all FP operations
 * have completed.
 */
	PTR_L	a0, P_ADDR(a0)		# get pointer to pcb for proc
	cfc1	t0, FPC_CSR		# stall til FP done
	cfc1	t0, FPC_CSR		# now get status
	LI	t3, ~SR_COP_1_BIT
	REG_L	t2, PCB_REGS+(SR * REGSZ)(a0)	# get CPU status register
	REG_S	t0, PCB_FPREGS+(32 * REGSZ)(a0)	# save FP status
	and	t2, t2, t3			# clear COP_1 enable bit
	REG_S	t2, PCB_REGS+(SR * REGSZ)(a0)	# save new status register
/*
 * Save the floating point registers.
 */
	sdc1	$f0, PCB_FPREGS+(0 * REGSZ)(a0)
	sdc1	$f1, PCB_FPREGS+(1 * REGSZ)(a0)
	sdc1	$f2, PCB_FPREGS+(2 * REGSZ)(a0)
	sdc1	$f3, PCB_FPREGS+(3 * REGSZ)(a0)
	sdc1	$f4, PCB_FPREGS+(4 * REGSZ)(a0)
	sdc1	$f5, PCB_FPREGS+(5 * REGSZ)(a0)
	sdc1	$f6, PCB_FPREGS+(6 * REGSZ)(a0)
	sdc1	$f7, PCB_FPREGS+(7 * REGSZ)(a0)
	sdc1	$f8, PCB_FPREGS+(8 * REGSZ)(a0)
	sdc1	$f9, PCB_FPREGS+(9 * REGSZ)(a0)
	sdc1	$f10, PCB_FPREGS+(10 * REGSZ)(a0)
	sdc1	$f11, PCB_FPREGS+(11 * REGSZ)(a0)
	sdc1	$f12, PCB_FPREGS+(12 * REGSZ)(a0)
	sdc1	$f13, PCB_FPREGS+(13 * REGSZ)(a0)
	sdc1	$f14, PCB_FPREGS+(14 * REGSZ)(a0)
	sdc1	$f15, PCB_FPREGS+(15 * REGSZ)(a0)
	sdc1	$f16, PCB_FPREGS+(16 * REGSZ)(a0)
	sdc1	$f17, PCB_FPREGS+(17 * REGSZ)(a0)
	sdc1	$f18, PCB_FPREGS+(18 * REGSZ)(a0)
	sdc1	$f19, PCB_FPREGS+(19 * REGSZ)(a0)
	sdc1	$f20, PCB_FPREGS+(20 * REGSZ)(a0)
	sdc1	$f21, PCB_FPREGS+(21 * REGSZ)(a0)
	sdc1	$f22, PCB_FPREGS+(22 * REGSZ)(a0)
	sdc1	$f23, PCB_FPREGS+(23 * REGSZ)(a0)
	sdc1	$f24, PCB_FPREGS+(24 * REGSZ)(a0)
	sdc1	$f25, PCB_FPREGS+(25 * REGSZ)(a0)
	sdc1	$f26, PCB_FPREGS+(26 * REGSZ)(a0)
	sdc1	$f27, PCB_FPREGS+(27 * REGSZ)(a0)
	sdc1	$f28, PCB_FPREGS+(28 * REGSZ)(a0)
	sdc1	$f29, PCB_FPREGS+(29 * REGSZ)(a0)
	sdc1	$f30, PCB_FPREGS+(30 * REGSZ)(a0)
	sdc1	$f31, PCB_FPREGS+(31 * REGSZ)(a0)

1:
/*
 *  Restore the floating point registers.
 */
	REG_L	t0, PCB_FPREGS+(32 * REGSZ)(a1)	# get status register
	ldc1	$f0, PCB_FPREGS+(0 * REGSZ)(a1)
	ldc1	$f1, PCB_FPREGS+(1 * REGSZ)(a1)
	ldc1	$f2, PCB_FPREGS+(2 * REGSZ)(a1)
	ldc1	$f3, PCB_FPREGS+(3 * REGSZ)(a1)
	ldc1	$f4, PCB_FPREGS+(4 * REGSZ)(a1)
	ldc1	$f5, PCB_FPREGS+(5 * REGSZ)(a1)
	ldc1	$f6, PCB_FPREGS+(6 * REGSZ)(a1)
	ldc1	$f7, PCB_FPREGS+(7 * REGSZ)(a1)
	ldc1	$f8, PCB_FPREGS+(8 * REGSZ)(a1)
	ldc1	$f9, PCB_FPREGS+(9 * REGSZ)(a1)
	ldc1	$f10, PCB_FPREGS+(10 * REGSZ)(a1)
	ldc1	$f11, PCB_FPREGS+(11 * REGSZ)(a1)
	ldc1	$f12, PCB_FPREGS+(12 * REGSZ)(a1)
	ldc1	$f13, PCB_FPREGS+(13 * REGSZ)(a1)
	ldc1	$f14, PCB_FPREGS+(14 * REGSZ)(a1)
	ldc1	$f15, PCB_FPREGS+(15 * REGSZ)(a1)
	ldc1	$f16, PCB_FPREGS+(16 * REGSZ)(a1)
	ldc1	$f17, PCB_FPREGS+(17 * REGSZ)(a1)
	ldc1	$f18, PCB_FPREGS+(18 * REGSZ)(a1)
	ldc1	$f19, PCB_FPREGS+(19 * REGSZ)(a1)
	ldc1	$f20, PCB_FPREGS+(20 * REGSZ)(a1)
	ldc1	$f21, PCB_FPREGS+(21 * REGSZ)(a1)
	ldc1	$f22, PCB_FPREGS+(22 * REGSZ)(a1)
	ldc1	$f23, PCB_FPREGS+(23 * REGSZ)(a1)
	ldc1	$f24, PCB_FPREGS+(24 * REGSZ)(a1)
	ldc1	$f25, PCB_FPREGS+(25 * REGSZ)(a1)
	ldc1	$f26, PCB_FPREGS+(26 * REGSZ)(a1)
	ldc1	$f27, PCB_FPREGS+(27 * REGSZ)(a1)
	ldc1	$f28, PCB_FPREGS+(28 * REGSZ)(a1)
	ldc1	$f29, PCB_FPREGS+(29 * REGSZ)(a1)
	ldc1	$f30, PCB_FPREGS+(30 * REGSZ)(a1)
	ldc1	$f31, PCB_FPREGS+(31 * REGSZ)(a1)

	ctc1	t0, FPC_CSR
	NOP

	MTC0	t1, COP_0_STATUS_REG	# Restore the status register.
	MTC0_SR_CU_HAZARD
	j	ra
	 NOP
END(MipsSwitchFPState)

LEAF(MipsSwitchFPState16, 0)
	MFC0	t1, COP_0_STATUS_REG	# Save old SR
	MFC0_HAZARD
	or	t0, t1, SR_COP_1_BIT	# enable the coprocessor
	MTC0	t0, COP_0_STATUS_REG
	MTC0_SR_CU_HAZARD

	beq	a0, zero, 1f		# skip save if NULL pointer
	 NOP
/*
 * First read out the status register to make sure that all FP operations
 * have completed.
 */
	PTR_L	a0, P_ADDR(a0)		# get pointer to pcb for proc
	cfc1	t0, FPC_CSR		# stall til FP done
	cfc1	t0, FPC_CSR		# now get status
	LI	t3, ~SR_COP_1_BIT
	REG_L	t2, PCB_REGS+(SR * REGSZ)(a0)	# get CPU status register
	REG_S	t0, PCB_FPREGS+(32 * REGSZ)(a0)	# save FP status
	and	t2, t2, t3			# clear COP_1 enable bit
	REG_S	t2, PCB_REGS+(SR * REGSZ)(a0)	# save new status register
/*
 * Save the floating point registers.
 */
	swc1	$f0, PCB_FPREGS+(0 * REGSZ)(a0)
	swc1	$f1, PCB_FPREGS+(1 * REGSZ)(a0)
	swc1	$f2, PCB_FPREGS+(2 * REGSZ)(a0)
	swc1	$f3, PCB_FPREGS+(3 * REGSZ)(a0)
	swc1	$f4, PCB_FPREGS+(4 * REGSZ)(a0)
	swc1	$f5, PCB_FPREGS+(5 * REGSZ)(a0)
	swc1	$f6, PCB_FPREGS+(6 * REGSZ)(a0)
	swc1	$f7, PCB_FPREGS+(7 * REGSZ)(a0)
	swc1	$f8, PCB_FPREGS+(8 * REGSZ)(a0)
	swc1	$f9, PCB_FPREGS+(9 * REGSZ)(a0)
	swc1	$f10, PCB_FPREGS+(10 * REGSZ)(a0)
	swc1	$f11, PCB_FPREGS+(11 * REGSZ)(a0)
	swc1	$f12, PCB_FPREGS+(12 * REGSZ)(a0)
	swc1	$f13, PCB_FPREGS+(13 * REGSZ)(a0)
	swc1	$f14, PCB_FPREGS+(14 * REGSZ)(a0)
	swc1	$f15, PCB_FPREGS+(15 * REGSZ)(a0)
	swc1	$f16, PCB_FPREGS+(16 * REGSZ)(a0)
	swc1	$f17, PCB_FPREGS+(17 * REGSZ)(a0)
	swc1	$f18, PCB_FPREGS+(18 * REGSZ)(a0)
	swc1	$f19, PCB_FPREGS+(19 * REGSZ)(a0)
	swc1	$f20, PCB_FPREGS+(20 * REGSZ)(a0)
	swc1	$f21, PCB_FPREGS+(21 * REGSZ)(a0)
	swc1	$f22, PCB_FPREGS+(22 * REGSZ)(a0)
	swc1	$f23, PCB_FPREGS+(23 * REGSZ)(a0)
	swc1	$f24, PCB_FPREGS+(24 * REGSZ)(a0)
	swc1	$f25, PCB_FPREGS+(25 * REGSZ)(a0)
	swc1	$f26, PCB_FPREGS+(26 * REGSZ)(a0)
	swc1	$f27, PCB_FPREGS+(27 * REGSZ)(a0)
	swc1	$f28, PCB_FPREGS+(28 * REGSZ)(a0)
	swc1	$f29, PCB_FPREGS+(29 * REGSZ)(a0)
	swc1	$f30, PCB_FPREGS+(30 * REGSZ)(a0)
	swc1	$f31, PCB_FPREGS+(31 * REGSZ)(a0)

1:
/*
 *  Restore the floating point registers.
 */
	REG_L	t0, PCB_FPREGS+(32 * REGSZ)(a1)	# get status register
	lwc1	$f0, PCB_FPREGS+(0 * REGSZ)(a1)
	lwc1	$f1, PCB_FPREGS+(1 * REGSZ)(a1)
	lwc1	$f2, PCB_FPREGS+(2 * REGSZ)(a1)
	lwc1	$f3, PCB_FPREGS+(3 * REGSZ)(a1)
	lwc1	$f4, PCB_FPREGS+(4 * REGSZ)(a1)
	lwc1	$f5, PCB_FPREGS+(5 * REGSZ)(a1)
	lwc1	$f6, PCB_FPREGS+(6 * REGSZ)(a1)
	lwc1	$f7, PCB_FPREGS+(7 * REGSZ)(a1)
	lwc1	$f8, PCB_FPREGS+(8 * REGSZ)(a1)
	lwc1	$f9, PCB_FPREGS+(9 * REGSZ)(a1)
	lwc1	$f10, PCB_FPREGS+(10 * REGSZ)(a1)
	lwc1	$f11, PCB_FPREGS+(11 * REGSZ)(a1)
	lwc1	$f12, PCB_FPREGS+(12 * REGSZ)(a1)
	lwc1	$f13, PCB_FPREGS+(13 * REGSZ)(a1)
	lwc1	$f14, PCB_FPREGS+(14 * REGSZ)(a1)
	lwc1	$f15, PCB_FPREGS+(15 * REGSZ)(a1)
	lwc1	$f16, PCB_FPREGS+(16 * REGSZ)(a1)
	lwc1	$f17, PCB_FPREGS+(17 * REGSZ)(a1)
	lwc1	$f18, PCB_FPREGS+(18 * REGSZ)(a1)
	lwc1	$f19, PCB_FPREGS+(19 * REGSZ)(a1)
	lwc1	$f20, PCB_FPREGS+(20 * REGSZ)(a1)
	lwc1	$f21, PCB_FPREGS+(21 * REGSZ)(a1)
	lwc1	$f22, PCB_FPREGS+(22 * REGSZ)(a1)
	lwc1	$f23, PCB_FPREGS+(23 * REGSZ)(a1)
	lwc1	$f24, PCB_FPREGS+(24 * REGSZ)(a1)
	lwc1	$f25, PCB_FPREGS+(25 * REGSZ)(a1)
	lwc1	$f26, PCB_FPREGS+(26 * REGSZ)(a1)
	lwc1	$f27, PCB_FPREGS+(27 * REGSZ)(a1)
	lwc1	$f28, PCB_FPREGS+(28 * REGSZ)(a1)
	lwc1	$f29, PCB_FPREGS+(29 * REGSZ)(a1)
	lwc1	$f30, PCB_FPREGS+(30 * REGSZ)(a1)
	lwc1	$f31, PCB_FPREGS+(31 * REGSZ)(a1)

	ctc1	t0, FPC_CSR
	NOP

	MTC0	t1, COP_0_STATUS_REG	# Restore the status register.
	MTC0_SR_CU_HAZARD
	j	ra
	 NOP
END(MipsSwitchFPState16)

/*----------------------------------------------------------------------------
 *
 * MipsSaveCurFPState --
 *
 *	Save the current floating point coprocessor state.
 *
 *	MipsSaveCurFPState(p)
 *		struct proc *p;
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	curcpu()->ci_fpuproc is cleared.
 *
 *----------------------------------------------------------------------------
 */
LEAF(MipsSaveCurFPState, 0)
	PTR_L	a0, P_ADDR(a0)			# get pointer to pcb for proc
	MFC0	t1, COP_0_STATUS_REG	# Disable interrupts and
	MFC0_HAZARD
	or	t0, t1, SR_COP_1_BIT|SR_FR_32	# enable the coprocessor
	MTC0	t0, COP_0_STATUS_REG
	MTC0_SR_IE_HAZARD
	GET_CPU_INFO(t2, t3)
	PTR_S	zero, CI_FPUPROC(t2)		# indicate state has been saved
/*
 * First read out the status register to make sure that all FP operations
 * have completed.
 */
	REG_L	t2, PCB_REGS+(SR * REGSZ)(a0)	# get CPU status register
	LI	t3, ~SR_COP_1_BIT
	and	t2, t2, t3			# clear COP_1 enable bit
	cfc1	t0, FPC_CSR		# stall til FP done
	cfc1	t0, FPC_CSR		# now get status
	REG_S	t2, PCB_REGS+(SR * REGSZ)(a0)	# save new status register
	REG_S	t0, PCB_FPREGS+(32 * REGSZ)(a0)	# save FP status
/*
 * Save the floating point registers.
 */
	sdc1	$f0, PCB_FPREGS+(0 * REGSZ)(a0)
	sdc1	$f1, PCB_FPREGS+(1 * REGSZ)(a0)
	sdc1	$f2, PCB_FPREGS+(2 * REGSZ)(a0)
	sdc1	$f3, PCB_FPREGS+(3 * REGSZ)(a0)
	sdc1	$f4, PCB_FPREGS+(4 * REGSZ)(a0)
	sdc1	$f5, PCB_FPREGS+(5 * REGSZ)(a0)
	sdc1	$f6, PCB_FPREGS+(6 * REGSZ)(a0)
	sdc1	$f7, PCB_FPREGS+(7 * REGSZ)(a0)
	sdc1	$f8, PCB_FPREGS+(8 * REGSZ)(a0)
	sdc1	$f9, PCB_FPREGS+(9 * REGSZ)(a0)
	sdc1	$f10, PCB_FPREGS+(10 * REGSZ)(a0)
	sdc1	$f11, PCB_FPREGS+(11 * REGSZ)(a0)
	sdc1	$f12, PCB_FPREGS+(12 * REGSZ)(a0)
	sdc1	$f13, PCB_FPREGS+(13 * REGSZ)(a0)
	sdc1	$f14, PCB_FPREGS+(14 * REGSZ)(a0)
	sdc1	$f15, PCB_FPREGS+(15 * REGSZ)(a0)
	sdc1	$f16, PCB_FPREGS+(16 * REGSZ)(a0)
	sdc1	$f17, PCB_FPREGS+(17 * REGSZ)(a0)
	sdc1	$f18, PCB_FPREGS+(18 * REGSZ)(a0)
	sdc1	$f19, PCB_FPREGS+(19 * REGSZ)(a0)
	sdc1	$f20, PCB_FPREGS+(20 * REGSZ)(a0)
	sdc1	$f21, PCB_FPREGS+(21 * REGSZ)(a0)
	sdc1	$f22, PCB_FPREGS+(22 * REGSZ)(a0)
	sdc1	$f23, PCB_FPREGS+(23 * REGSZ)(a0)
	sdc1	$f24, PCB_FPREGS+(24 * REGSZ)(a0)
	sdc1	$f25, PCB_FPREGS+(25 * REGSZ)(a0)
	sdc1	$f26, PCB_FPREGS+(26 * REGSZ)(a0)
	sdc1	$f27, PCB_FPREGS+(27 * REGSZ)(a0)
	sdc1	$f28, PCB_FPREGS+(28 * REGSZ)(a0)
	sdc1	$f29, PCB_FPREGS+(29 * REGSZ)(a0)
	sdc1	$f30, PCB_FPREGS+(30 * REGSZ)(a0)
	sdc1	$f31, PCB_FPREGS+(31 * REGSZ)(a0)

	MTC0	t1, COP_0_STATUS_REG	# Restore the status register.
	MTC0_SR_IE_HAZARD
	j	ra
	 NOP
END(MipsSaveCurFPState)

LEAF(MipsSaveCurFPState16, 0)
	PTR_L	a0, P_ADDR(a0)			# get pointer to pcb for proc
	MFC0	t1, COP_0_STATUS_REG	# Disable interrupts and
	MFC0_HAZARD
	or	t0, t1, SR_COP_1_BIT	# enable the coprocessor
	MTC0	t0, COP_0_STATUS_REG
	MTC0_SR_IE_HAZARD
	GET_CPU_INFO(t2, t3)
	PTR_S	zero, CI_FPUPROC(t2)		# indicate state has been saved
/*
 * First read out the status register to make sure that all FP operations
 * have completed.
 */
	REG_L	t2, PCB_REGS+(SR * REGSZ)(a0)	# get CPU status register
	LI	t3, ~SR_COP_1_BIT
	and	t2, t2, t3			# clear COP_1 enable bit
	cfc1	t0, FPC_CSR		# stall til FP done
	cfc1	t0, FPC_CSR		# now get status
	REG_S	t2, PCB_REGS+(SR * REGSZ)(a0)	# save new status register
	REG_S	t0, PCB_FPREGS+(32 * REGSZ)(a0)	# save FP status
/*
 * Save the floating point registers.
 */
	swc1	$f0, PCB_FPREGS+(0 * REGSZ)(a0)
	swc1	$f1, PCB_FPREGS+(1 * REGSZ)(a0)
	swc1	$f2, PCB_FPREGS+(2 * REGSZ)(a0)
	swc1	$f3, PCB_FPREGS+(3 * REGSZ)(a0)
	swc1	$f4, PCB_FPREGS+(4 * REGSZ)(a0)
	swc1	$f5, PCB_FPREGS+(5 * REGSZ)(a0)
	swc1	$f6, PCB_FPREGS+(6 * REGSZ)(a0)
	swc1	$f7, PCB_FPREGS+(7 * REGSZ)(a0)
	swc1	$f8, PCB_FPREGS+(8 * REGSZ)(a0)
	swc1	$f9, PCB_FPREGS+(9 * REGSZ)(a0)
	swc1	$f10, PCB_FPREGS+(10 * REGSZ)(a0)
	swc1	$f11, PCB_FPREGS+(11 * REGSZ)(a0)
	swc1	$f12, PCB_FPREGS+(12 * REGSZ)(a0)
	swc1	$f13, PCB_FPREGS+(13 * REGSZ)(a0)
	swc1	$f14, PCB_FPREGS+(14 * REGSZ)(a0)
	swc1	$f15, PCB_FPREGS+(15 * REGSZ)(a0)
	swc1	$f16, PCB_FPREGS+(16 * REGSZ)(a0)
	swc1	$f17, PCB_FPREGS+(17 * REGSZ)(a0)
	swc1	$f18, PCB_FPREGS+(18 * REGSZ)(a0)
	swc1	$f19, PCB_FPREGS+(19 * REGSZ)(a0)
	swc1	$f20, PCB_FPREGS+(20 * REGSZ)(a0)
	swc1	$f21, PCB_FPREGS+(21 * REGSZ)(a0)
	swc1	$f22, PCB_FPREGS+(22 * REGSZ)(a0)
	swc1	$f23, PCB_FPREGS+(23 * REGSZ)(a0)
	swc1	$f24, PCB_FPREGS+(24 * REGSZ)(a0)
	swc1	$f25, PCB_FPREGS+(25 * REGSZ)(a0)
	swc1	$f26, PCB_FPREGS+(26 * REGSZ)(a0)
	swc1	$f27, PCB_FPREGS+(27 * REGSZ)(a0)
	swc1	$f28, PCB_FPREGS+(28 * REGSZ)(a0)
	swc1	$f29, PCB_FPREGS+(29 * REGSZ)(a0)
	swc1	$f30, PCB_FPREGS+(30 * REGSZ)(a0)
	swc1	$f31, PCB_FPREGS+(31 * REGSZ)(a0)

	MTC0	t1, COP_0_STATUS_REG	# Restore the status register.
	MTC0_SR_IE_HAZARD
	j	ra
	 NOP
END(MipsSaveCurFPState16)

/*----------------------------------------------------------------------------
 *
 * cp1_get_prid
 *
 *	Get the floating point co-processor id.
 *
 *	cp1_get_prid(void)
 *
 * Results:
 *	FPC_ID
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------------
 */
LEAF(cp1_get_prid, 0)
	MFC0	v1, COP_0_STATUS_REG
	MFC0_HAZARD
	li	a0, SR_COP_1_BIT
	or	v1, a0
	MTC0	v1, COP_0_STATUS_REG
	MTC0_SR_CU_HAZARD
	cfc1	v0, FPC_ID
	xor	v1, a0
	MTC0	v1, COP_0_STATUS_REG
	MTC0_SR_CU_HAZARD
	jr	ra
	 NOP
END(cp1_get_prid)
@


1.21
log
@Introduce assembly macros for specific processor hazards: tlb update, status
register update, status register update causing a change to the interrupt
enable flag, and a few other arcane ones. <mips64/asm.h> will provide
(supposedly sane) defaults, and <machine/asm.h> may override these with
better tuned versions.

Use these macros instead of random strings of nop in the various .S files
requiring hazard workarounds.
@
text
@d1 1
a1 1
/*	$OpenBSD: lcore_float.S,v 1.20 2010/09/21 20:29:17 miod Exp $ */
d34 1
@


1.20
log
@Replace the old floating point completion code with a C interface to the
MI softfloat code, implementing all MIPS IV specified floating point
operations.
Tested on R5000, R10000, R14000 and Loongson2F.
@
text
@d1 1
a1 1
/*	$OpenBSD: lcore_float.S,v 1.19 2010/01/08 01:35:52 syuu Exp $ */
d39 1
a41 2
	.set	mips3

d61 2
a62 1
	mfc0	t1, COP_0_STATUS_REG	# Save old SR
d64 2
a65 2
	mtc0	t0, COP_0_STATUS_REG
	ITLBNOPFIX
d68 1
a68 1
	nop
d76 2
a77 2
	li	t3, ~SR_COP_1_BIT
	REG_L	t2, PCB_REGS+(PS * REGSZ)(a0)	# get CPU status register
d80 1
a80 1
	REG_S	t2, PCB_REGS+(PS * REGSZ)(a0)	# save new status register
d156 1
a156 1
	nop
d158 2
a159 2
	mtc0	t1, COP_0_STATUS_REG	# Restore the status register.
	ITLBNOPFIX
d161 1
a161 1
	nop
d165 2
a166 1
	mfc0	t1, COP_0_STATUS_REG	# Save old SR
d168 2
a169 2
	mtc0	t0, COP_0_STATUS_REG
	ITLBNOPFIX
d172 1
a172 1
	nop
d180 2
a181 2
	li	t3, ~SR_COP_1_BIT
	REG_L	t2, PCB_REGS+(PS * REGSZ)(a0)	# get CPU status register
d184 1
a184 1
	REG_S	t2, PCB_REGS+(PS * REGSZ)(a0)	# save new status register
d260 1
a260 1
	nop
d262 2
a263 2
	mtc0	t1, COP_0_STATUS_REG	# Restore the status register.
	ITLBNOPFIX
d265 1
a265 1
	nop
d287 2
a288 1
	mfc0	t1, COP_0_STATUS_REG	# Disable interrupts and
d290 2
a291 2
	mtc0	t0, COP_0_STATUS_REG
	ITLBNOPFIX
d298 2
a299 2
	REG_L	t2, PCB_REGS+(PS * REGSZ)(a0)	# get CPU status register
	li	t3, ~SR_COP_1_BIT
d303 1
a303 1
	REG_S	t2, PCB_REGS+(PS * REGSZ)(a0)	# save new status register
d341 2
a342 2
	mtc0	t1, COP_0_STATUS_REG	# Restore the status register.
	ITLBNOPFIX
d344 1
a344 1
	nop
d349 2
a350 1
	mfc0	t1, COP_0_STATUS_REG	# Disable interrupts and
d352 2
a353 2
	mtc0	t0, COP_0_STATUS_REG
	ITLBNOPFIX
d360 2
a361 2
	REG_L	t2, PCB_REGS+(PS * REGSZ)(a0)	# get CPU status register
	li	t3, ~SR_COP_1_BIT
d365 1
a365 1
	REG_S	t2, PCB_REGS+(PS * REGSZ)(a0)	# save new status register
d403 2
a404 2
	mtc0	t1, COP_0_STATUS_REG	# Restore the status register.
	ITLBNOPFIX
d406 1
a406 1
	nop
d426 2
a427 1
	mfc0	v1, COP_0_STATUS_REG
d430 2
a431 2
	mtc0	v1, COP_0_STATUS_REG
	ITLBNOPFIX
d434 2
a435 2
	mtc0	v1, COP_0_STATUS_REG
	ITLBNOPFIX
d437 1
a437 1
	nop
@


1.19
log
@MP-safe FPU handling. ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lcore_float.S,v 1.18 2010/01/01 15:04:00 miod Exp $ */
a154 1
	and	t0, t0, ~FPC_EXCEPTION_BITS
a257 1
	and	t0, t0, ~FPC_EXCEPTION_BITS
a407 128
 * MipsFPTrap --
 *
 *	Handle a floating point Trap.
 *
 *	MipsFPTrap(statusReg, causeReg, pc)
 *		unsigned statusReg;
 *		unsigned causeReg;
 *		unsigned pc;
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------------
 */
NON_LEAF(MipsFPTrap, FRAMESZ(CF_SZ), ra)
	PTR_SUBU sp, sp, FRAMESZ(CF_SZ)
	mfc0	t0, COP_0_STATUS_REG
	PTR_S	ra, CF_RA_OFFS(sp)
	.mask	0x80000000, (CF_RA_OFFS - FRAMESZ(CF_SZ))

	PTR_S	a2, 2*REGSZ(sp)
	PTR_S	a3, 3*REGSZ(sp)
	or	t1, t0, SR_COP_1_BIT
	mtc0	t1, COP_0_STATUS_REG
	ITLBNOPFIX
	cfc1	t1, FPC_CSR		# stall til FP done
	cfc1	t1, FPC_CSR		# now get status
	nop
	sll	t2, t1, (31-17)		# unimplemented operation?
	bgez	t2, 3f			# no, normal trap
	nop
/*
 * We got an unimplemented operation trap so fetch the instruction,
 * compute the next PC and emulate the instruction.
 */
	bgez	a1, 1f			# Check the branch delay bit.
	nop
/*
 * The instruction is in the branch delay slot so the branch will have to
 * be emulated to get the resulting PC.
 */
	GET_CPU_INFO(t2, t3)
	PTR_L	a0, CI_CURPROCPADDR(t2)	# first arg is ptr to CPU regs
	move	a1, a2			# second arg is instruction PC
	move	a2, t1			# third arg is the FP CSR
	jal	MipsEmulateBranch	# compute PC after branch
	move	a3, zero		# fourth arg is FALSE
/*
 * Now load the floating-point instruction in the branch delay slot
 * to be emulated.
 */
	PTR_L	a2, 2*REGSZ(sp)		# restore EXC pc
	b	2f
	lw	a0, 4(a2)		# a0 = coproc instruction
/*
 * This is not in the branch delay slot so calculate the resulting
 * PC (epc + 4) into v0 and continue to MipsEmulateFP().
 */
1:
	lw	a0, 0(a2)		# a0 = coproc instruction
	PTR_ADDU v0, a2, 4		# v0 = next pc
2:
	GET_CPU_INFO(t2, t3)
	PTR_L	a3, CI_CURPROCPADDR(t2)	# first arg is ptr to CPU regs
	PTR_S	v0, PCB_REGS+(PC * REGSZ)(a3)	# save new pc
/*
 * Check to see if the instruction to be emulated is a floating-point
 * instruction.
 */
	srl	a3, a0, OPCODE_SHIFT
	beq	a3, OPCODE_C1, 5f	# this should never fail
	nop
/*
 * Send a floating point exception signal to the current process.
 */
3:
	cfc1	a1, FPC_CSR		# code = FP exceptions
	GET_CPU_INFO(t2, t3)	
	PTR_L	a0, CI_CURPROC(t2)	# get current process
	PTR_L	a3, 3*REGSZ(sp)
	and	v0, a1, FPC_EXCEPTION_INEXACT
	bnez	v0, 4f
	li	a2, FPE_FLTRES
	and	v0, a1, FPC_EXCEPTION_UNDERFLOW
	bnez	v0, 4f
	li	a2, FPE_FLTUND
	and	v0, a1, FPC_EXCEPTION_OVERFLOW
	bnez	v0, 4f
	li	a2, FPE_FLTOVF
	and	v0, a1, FPC_EXCEPTION_DIV0
	bnez	v0, 4f
	li	a2, FPE_FLTDIV
	li	a2, FPE_FLTINV
4:
	ctc1	zero, FPC_CSR		# Clear exceptions
	jal	fpu_trapsignal
	nop
	b	FPReturn
	nop

/*
 * Finally, we can call MipsEmulateFP() where a0 is the instruction to emulate.
 */
5:
	jal	MipsEmulateFP
	nop

	bnez	v0, 3b			# Emulation failed.
	nop

/*
 * Turn off the floating point coprocessor and return.
 */
FPReturn:
	mfc0	t0, COP_0_STATUS_REG
	PTR_L	ra, CF_RA_OFFS(sp)
	and	t0, t0, ~SR_COP_1_BIT
	mtc0	t0, COP_0_STATUS_REG
	ITLBNOPFIX
	j	ra
	PTR_ADDU sp, sp, FRAMESZ(CF_SZ)
END(MipsFPTrap)

/*----------------------------------------------------------------------------
 *
a434 1

@


1.18
log
@Make sure we grab the kernel lock before invoking trapsignal().
@
text
@d1 1
a1 1
/*	$OpenBSD: lcore_float.S,v 1.17 2009/09/30 06:22:00 syuu Exp $ */
d282 1
a282 1
 *	machFPCurProcPtr is cleared.
d292 2
a293 1
	PTR_S	zero, machFPCurProcPtr		# indicate state has been saved
d353 2
a354 1
	PTR_S	zero, machFPCurProcPtr		# indicate state has been saved
@


1.17
log
@curproc, curprocpaddr moved into cpu_info
OK miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lcore_float.S,v 1.16 2009/05/22 20:37:53 miod Exp $ */
d487 1
a487 1
	cfc1	a2, FPC_CSR		# code = FP exceptions
d490 2
a491 2
	PTR_L	a4, 3*REGSZ(sp)
	and	v0, a2, FPC_EXCEPTION_INEXACT
d493 2
a494 2
	li	a3, 6
	and	v0, a2, FPC_EXCEPTION_UNDERFLOW
d496 2
a497 2
	li	a3, 5
	and	v0, a2, FPC_EXCEPTION_OVERFLOW
d499 2
a500 2
	li	a3, 4
	and	v0, a2, FPC_EXCEPTION_DIV0
d502 2
a503 2
	li	a3, 3
	li	a3, 7			# XXX FPE_FLTINV
d506 2
a507 2
	jal	trapsignal
	li	a1, SIGFPE
@


1.16
log
@Drop almost unused <machine/psl.h> on sgi; move USERMODE() definition from
there to trap.c which is its only user. This also cleans up multiple
inclusion of <machine/cpu.h> (because <machine/psl.h> includes it) in many
places.
@
text
@d1 1
a1 1
/*	$OpenBSD: lcore_float.S,v 1.15 2007/10/18 04:32:25 miod Exp $ */
a38 2
#define curproc	(cpu_info_primary + CI_CURPROC)

d452 2
a453 1
	PTR_L	a0, curprocpaddr	# first arg is ptr to CPU regs
d473 2
a474 1
	PTR_L	a3, curprocpaddr	# first arg is ptr to CPU regs
d488 2
a489 1
	PTR_L	a0, curproc		# get current process
@


1.15
log
@No need to include <machine/pte.h> here.
@
text
@d1 1
a1 1
/*	$OpenBSD: lcore_float.S,v 1.14 2007/07/16 20:23:09 miod Exp $ */
a31 1
#include <machine/psl.h>
@


1.14
log
@Replace bunches of nops with the ITLBNOPFIX macro, which generates fewer
nops unless we compile for early RM7000 flavours, which we usually don't do.
@
text
@d1 1
a1 1
/*	$OpenBSD: lcore_float.S,v 1.13 2007/05/07 18:42:13 kettenis Exp $ */
a36 1
#include <machine/pte.h>
@


1.13
log
@Move sgo to __HAVE_CPUINFO.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lcore_float.S,v 1.12 2007/04/26 17:04:32 miod Exp $ */
d556 1
a556 4
	nop
	nop
	nop
	nop
@


1.12
log
@Be more careful when changing cop0 SR value; or flags in instead of setting
the SR value to them, and correctly propagate the SR to userland via proper
proc0 initialization and cpu_fork() care.
@
text
@d1 1
a1 1
/*	$OpenBSD: lcore_float.S,v 1.11 2005/12/20 07:06:26 miod Exp $ */
d40 2
@


1.11
log
@Since we are allowed to rely on the fact that the pcb is the first element
of struct user, use syntactic sugar in genassym.cf and use PCB_xxx defines
instead of U_PCB_xxx, like all other platforms do; no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: lcore_float.S,v 1.10 2004/11/08 20:55:45 miod Exp $ */
d65 1
a65 1
	li	t0, SR_COP_1_BIT|SR_FR_32	# enable the coprocessor
d169 1
a169 1
	li	t0, SR_COP_1_BIT	# enable the coprocessor
d291 1
a291 1
	li	t0, SR_COP_1_BIT|SR_FR_32	# enable the coprocessor
d351 1
a351 1
	li	t0, SR_COP_1_BIT	# enable the coprocessor
@


1.10
log
@Typo
@
text
@d1 1
a1 1
/*	$OpenBSD: lcore_float.S,v 1.9 2004/10/30 14:48:59 pefo Exp $ */
d79 2
a80 2
	REG_L	t2, U_PCB_REGS+(PS * REGSZ)(a0)	# get CPU status register
	REG_S	t0, U_PCB_FPREGS+(32 * REGSZ)(a0)	# save FP status
d82 1
a82 1
	REG_S	t2, U_PCB_REGS+(PS * REGSZ)(a0)	# save new status register
d86 32
a117 32
	sdc1	$f0, U_PCB_FPREGS+(0 * REGSZ)(a0)
	sdc1	$f1, U_PCB_FPREGS+(1 * REGSZ)(a0)
	sdc1	$f2, U_PCB_FPREGS+(2 * REGSZ)(a0)
	sdc1	$f3, U_PCB_FPREGS+(3 * REGSZ)(a0)
	sdc1	$f4, U_PCB_FPREGS+(4 * REGSZ)(a0)
	sdc1	$f5, U_PCB_FPREGS+(5 * REGSZ)(a0)
	sdc1	$f6, U_PCB_FPREGS+(6 * REGSZ)(a0)
	sdc1	$f7, U_PCB_FPREGS+(7 * REGSZ)(a0)
	sdc1	$f8, U_PCB_FPREGS+(8 * REGSZ)(a0)
	sdc1	$f9, U_PCB_FPREGS+(9 * REGSZ)(a0)
	sdc1	$f10, U_PCB_FPREGS+(10 * REGSZ)(a0)
	sdc1	$f11, U_PCB_FPREGS+(11 * REGSZ)(a0)
	sdc1	$f12, U_PCB_FPREGS+(12 * REGSZ)(a0)
	sdc1	$f13, U_PCB_FPREGS+(13 * REGSZ)(a0)
	sdc1	$f14, U_PCB_FPREGS+(14 * REGSZ)(a0)
	sdc1	$f15, U_PCB_FPREGS+(15 * REGSZ)(a0)
	sdc1	$f16, U_PCB_FPREGS+(16 * REGSZ)(a0)
	sdc1	$f17, U_PCB_FPREGS+(17 * REGSZ)(a0)
	sdc1	$f18, U_PCB_FPREGS+(18 * REGSZ)(a0)
	sdc1	$f19, U_PCB_FPREGS+(19 * REGSZ)(a0)
	sdc1	$f20, U_PCB_FPREGS+(20 * REGSZ)(a0)
	sdc1	$f21, U_PCB_FPREGS+(21 * REGSZ)(a0)
	sdc1	$f22, U_PCB_FPREGS+(22 * REGSZ)(a0)
	sdc1	$f23, U_PCB_FPREGS+(23 * REGSZ)(a0)
	sdc1	$f24, U_PCB_FPREGS+(24 * REGSZ)(a0)
	sdc1	$f25, U_PCB_FPREGS+(25 * REGSZ)(a0)
	sdc1	$f26, U_PCB_FPREGS+(26 * REGSZ)(a0)
	sdc1	$f27, U_PCB_FPREGS+(27 * REGSZ)(a0)
	sdc1	$f28, U_PCB_FPREGS+(28 * REGSZ)(a0)
	sdc1	$f29, U_PCB_FPREGS+(29 * REGSZ)(a0)
	sdc1	$f30, U_PCB_FPREGS+(30 * REGSZ)(a0)
	sdc1	$f31, U_PCB_FPREGS+(31 * REGSZ)(a0)
d123 33
a155 33
	REG_L	t0, U_PCB_FPREGS+(32 * REGSZ)(a1)	# get status register
	ldc1	$f0, U_PCB_FPREGS+(0 * REGSZ)(a1)
	ldc1	$f1, U_PCB_FPREGS+(1 * REGSZ)(a1)
	ldc1	$f2, U_PCB_FPREGS+(2 * REGSZ)(a1)
	ldc1	$f3, U_PCB_FPREGS+(3 * REGSZ)(a1)
	ldc1	$f4, U_PCB_FPREGS+(4 * REGSZ)(a1)
	ldc1	$f5, U_PCB_FPREGS+(5 * REGSZ)(a1)
	ldc1	$f6, U_PCB_FPREGS+(6 * REGSZ)(a1)
	ldc1	$f7, U_PCB_FPREGS+(7 * REGSZ)(a1)
	ldc1	$f8, U_PCB_FPREGS+(8 * REGSZ)(a1)
	ldc1	$f9, U_PCB_FPREGS+(9 * REGSZ)(a1)
	ldc1	$f10, U_PCB_FPREGS+(10 * REGSZ)(a1)
	ldc1	$f11, U_PCB_FPREGS+(11 * REGSZ)(a1)
	ldc1	$f12, U_PCB_FPREGS+(12 * REGSZ)(a1)
	ldc1	$f13, U_PCB_FPREGS+(13 * REGSZ)(a1)
	ldc1	$f14, U_PCB_FPREGS+(14 * REGSZ)(a1)
	ldc1	$f15, U_PCB_FPREGS+(15 * REGSZ)(a1)
	ldc1	$f16, U_PCB_FPREGS+(16 * REGSZ)(a1)
	ldc1	$f17, U_PCB_FPREGS+(17 * REGSZ)(a1)
	ldc1	$f18, U_PCB_FPREGS+(18 * REGSZ)(a1)
	ldc1	$f19, U_PCB_FPREGS+(19 * REGSZ)(a1)
	ldc1	$f20, U_PCB_FPREGS+(20 * REGSZ)(a1)
	ldc1	$f21, U_PCB_FPREGS+(21 * REGSZ)(a1)
	ldc1	$f22, U_PCB_FPREGS+(22 * REGSZ)(a1)
	ldc1	$f23, U_PCB_FPREGS+(23 * REGSZ)(a1)
	ldc1	$f24, U_PCB_FPREGS+(24 * REGSZ)(a1)
	ldc1	$f25, U_PCB_FPREGS+(25 * REGSZ)(a1)
	ldc1	$f26, U_PCB_FPREGS+(26 * REGSZ)(a1)
	ldc1	$f27, U_PCB_FPREGS+(27 * REGSZ)(a1)
	ldc1	$f28, U_PCB_FPREGS+(28 * REGSZ)(a1)
	ldc1	$f29, U_PCB_FPREGS+(29 * REGSZ)(a1)
	ldc1	$f30, U_PCB_FPREGS+(30 * REGSZ)(a1)
	ldc1	$f31, U_PCB_FPREGS+(31 * REGSZ)(a1)
d183 2
a184 2
	REG_L	t2, U_PCB_REGS+(PS * REGSZ)(a0)	# get CPU status register
	REG_S	t0, U_PCB_FPREGS+(32 * REGSZ)(a0)	# save FP status
d186 1
a186 1
	REG_S	t2, U_PCB_REGS+(PS * REGSZ)(a0)	# save new status register
d190 32
a221 32
	swc1	$f0, U_PCB_FPREGS+(0 * REGSZ)(a0)
	swc1	$f1, U_PCB_FPREGS+(1 * REGSZ)(a0)
	swc1	$f2, U_PCB_FPREGS+(2 * REGSZ)(a0)
	swc1	$f3, U_PCB_FPREGS+(3 * REGSZ)(a0)
	swc1	$f4, U_PCB_FPREGS+(4 * REGSZ)(a0)
	swc1	$f5, U_PCB_FPREGS+(5 * REGSZ)(a0)
	swc1	$f6, U_PCB_FPREGS+(6 * REGSZ)(a0)
	swc1	$f7, U_PCB_FPREGS+(7 * REGSZ)(a0)
	swc1	$f8, U_PCB_FPREGS+(8 * REGSZ)(a0)
	swc1	$f9, U_PCB_FPREGS+(9 * REGSZ)(a0)
	swc1	$f10, U_PCB_FPREGS+(10 * REGSZ)(a0)
	swc1	$f11, U_PCB_FPREGS+(11 * REGSZ)(a0)
	swc1	$f12, U_PCB_FPREGS+(12 * REGSZ)(a0)
	swc1	$f13, U_PCB_FPREGS+(13 * REGSZ)(a0)
	swc1	$f14, U_PCB_FPREGS+(14 * REGSZ)(a0)
	swc1	$f15, U_PCB_FPREGS+(15 * REGSZ)(a0)
	swc1	$f16, U_PCB_FPREGS+(16 * REGSZ)(a0)
	swc1	$f17, U_PCB_FPREGS+(17 * REGSZ)(a0)
	swc1	$f18, U_PCB_FPREGS+(18 * REGSZ)(a0)
	swc1	$f19, U_PCB_FPREGS+(19 * REGSZ)(a0)
	swc1	$f20, U_PCB_FPREGS+(20 * REGSZ)(a0)
	swc1	$f21, U_PCB_FPREGS+(21 * REGSZ)(a0)
	swc1	$f22, U_PCB_FPREGS+(22 * REGSZ)(a0)
	swc1	$f23, U_PCB_FPREGS+(23 * REGSZ)(a0)
	swc1	$f24, U_PCB_FPREGS+(24 * REGSZ)(a0)
	swc1	$f25, U_PCB_FPREGS+(25 * REGSZ)(a0)
	swc1	$f26, U_PCB_FPREGS+(26 * REGSZ)(a0)
	swc1	$f27, U_PCB_FPREGS+(27 * REGSZ)(a0)
	swc1	$f28, U_PCB_FPREGS+(28 * REGSZ)(a0)
	swc1	$f29, U_PCB_FPREGS+(29 * REGSZ)(a0)
	swc1	$f30, U_PCB_FPREGS+(30 * REGSZ)(a0)
	swc1	$f31, U_PCB_FPREGS+(31 * REGSZ)(a0)
d227 33
a259 33
	REG_L	t0, U_PCB_FPREGS+(32 * REGSZ)(a1)	# get status register
	lwc1	$f0, U_PCB_FPREGS+(0 * REGSZ)(a1)
	lwc1	$f1, U_PCB_FPREGS+(1 * REGSZ)(a1)
	lwc1	$f2, U_PCB_FPREGS+(2 * REGSZ)(a1)
	lwc1	$f3, U_PCB_FPREGS+(3 * REGSZ)(a1)
	lwc1	$f4, U_PCB_FPREGS+(4 * REGSZ)(a1)
	lwc1	$f5, U_PCB_FPREGS+(5 * REGSZ)(a1)
	lwc1	$f6, U_PCB_FPREGS+(6 * REGSZ)(a1)
	lwc1	$f7, U_PCB_FPREGS+(7 * REGSZ)(a1)
	lwc1	$f8, U_PCB_FPREGS+(8 * REGSZ)(a1)
	lwc1	$f9, U_PCB_FPREGS+(9 * REGSZ)(a1)
	lwc1	$f10, U_PCB_FPREGS+(10 * REGSZ)(a1)
	lwc1	$f11, U_PCB_FPREGS+(11 * REGSZ)(a1)
	lwc1	$f12, U_PCB_FPREGS+(12 * REGSZ)(a1)
	lwc1	$f13, U_PCB_FPREGS+(13 * REGSZ)(a1)
	lwc1	$f14, U_PCB_FPREGS+(14 * REGSZ)(a1)
	lwc1	$f15, U_PCB_FPREGS+(15 * REGSZ)(a1)
	lwc1	$f16, U_PCB_FPREGS+(16 * REGSZ)(a1)
	lwc1	$f17, U_PCB_FPREGS+(17 * REGSZ)(a1)
	lwc1	$f18, U_PCB_FPREGS+(18 * REGSZ)(a1)
	lwc1	$f19, U_PCB_FPREGS+(19 * REGSZ)(a1)
	lwc1	$f20, U_PCB_FPREGS+(20 * REGSZ)(a1)
	lwc1	$f21, U_PCB_FPREGS+(21 * REGSZ)(a1)
	lwc1	$f22, U_PCB_FPREGS+(22 * REGSZ)(a1)
	lwc1	$f23, U_PCB_FPREGS+(23 * REGSZ)(a1)
	lwc1	$f24, U_PCB_FPREGS+(24 * REGSZ)(a1)
	lwc1	$f25, U_PCB_FPREGS+(25 * REGSZ)(a1)
	lwc1	$f26, U_PCB_FPREGS+(26 * REGSZ)(a1)
	lwc1	$f27, U_PCB_FPREGS+(27 * REGSZ)(a1)
	lwc1	$f28, U_PCB_FPREGS+(28 * REGSZ)(a1)
	lwc1	$f29, U_PCB_FPREGS+(29 * REGSZ)(a1)
	lwc1	$f30, U_PCB_FPREGS+(30 * REGSZ)(a1)
	lwc1	$f31, U_PCB_FPREGS+(31 * REGSZ)(a1)
d299 1
a299 1
	REG_L	t2, U_PCB_REGS+(PS * REGSZ)(a0)	# get CPU status register
d304 2
a305 2
	REG_S	t2, U_PCB_REGS+(PS * REGSZ)(a0)	# save new status register
	REG_S	t0, U_PCB_FPREGS+(32 * REGSZ)(a0)	# save FP status
d309 32
a340 32
	sdc1	$f0, U_PCB_FPREGS+(0 * REGSZ)(a0)
	sdc1	$f1, U_PCB_FPREGS+(1 * REGSZ)(a0)
	sdc1	$f2, U_PCB_FPREGS+(2 * REGSZ)(a0)
	sdc1	$f3, U_PCB_FPREGS+(3 * REGSZ)(a0)
	sdc1	$f4, U_PCB_FPREGS+(4 * REGSZ)(a0)
	sdc1	$f5, U_PCB_FPREGS+(5 * REGSZ)(a0)
	sdc1	$f6, U_PCB_FPREGS+(6 * REGSZ)(a0)
	sdc1	$f7, U_PCB_FPREGS+(7 * REGSZ)(a0)
	sdc1	$f8, U_PCB_FPREGS+(8 * REGSZ)(a0)
	sdc1	$f9, U_PCB_FPREGS+(9 * REGSZ)(a0)
	sdc1	$f10, U_PCB_FPREGS+(10 * REGSZ)(a0)
	sdc1	$f11, U_PCB_FPREGS+(11 * REGSZ)(a0)
	sdc1	$f12, U_PCB_FPREGS+(12 * REGSZ)(a0)
	sdc1	$f13, U_PCB_FPREGS+(13 * REGSZ)(a0)
	sdc1	$f14, U_PCB_FPREGS+(14 * REGSZ)(a0)
	sdc1	$f15, U_PCB_FPREGS+(15 * REGSZ)(a0)
	sdc1	$f16, U_PCB_FPREGS+(16 * REGSZ)(a0)
	sdc1	$f17, U_PCB_FPREGS+(17 * REGSZ)(a0)
	sdc1	$f18, U_PCB_FPREGS+(18 * REGSZ)(a0)
	sdc1	$f19, U_PCB_FPREGS+(19 * REGSZ)(a0)
	sdc1	$f20, U_PCB_FPREGS+(20 * REGSZ)(a0)
	sdc1	$f21, U_PCB_FPREGS+(21 * REGSZ)(a0)
	sdc1	$f22, U_PCB_FPREGS+(22 * REGSZ)(a0)
	sdc1	$f23, U_PCB_FPREGS+(23 * REGSZ)(a0)
	sdc1	$f24, U_PCB_FPREGS+(24 * REGSZ)(a0)
	sdc1	$f25, U_PCB_FPREGS+(25 * REGSZ)(a0)
	sdc1	$f26, U_PCB_FPREGS+(26 * REGSZ)(a0)
	sdc1	$f27, U_PCB_FPREGS+(27 * REGSZ)(a0)
	sdc1	$f28, U_PCB_FPREGS+(28 * REGSZ)(a0)
	sdc1	$f29, U_PCB_FPREGS+(29 * REGSZ)(a0)
	sdc1	$f30, U_PCB_FPREGS+(30 * REGSZ)(a0)
	sdc1	$f31, U_PCB_FPREGS+(31 * REGSZ)(a0)
d359 1
a359 1
	REG_L	t2, U_PCB_REGS+(PS * REGSZ)(a0)	# get CPU status register
d364 2
a365 2
	REG_S	t2, U_PCB_REGS+(PS * REGSZ)(a0)	# save new status register
	REG_S	t0, U_PCB_FPREGS+(32 * REGSZ)(a0)	# save FP status
d369 32
a400 32
	swc1	$f0, U_PCB_FPREGS+(0 * REGSZ)(a0)
	swc1	$f1, U_PCB_FPREGS+(1 * REGSZ)(a0)
	swc1	$f2, U_PCB_FPREGS+(2 * REGSZ)(a0)
	swc1	$f3, U_PCB_FPREGS+(3 * REGSZ)(a0)
	swc1	$f4, U_PCB_FPREGS+(4 * REGSZ)(a0)
	swc1	$f5, U_PCB_FPREGS+(5 * REGSZ)(a0)
	swc1	$f6, U_PCB_FPREGS+(6 * REGSZ)(a0)
	swc1	$f7, U_PCB_FPREGS+(7 * REGSZ)(a0)
	swc1	$f8, U_PCB_FPREGS+(8 * REGSZ)(a0)
	swc1	$f9, U_PCB_FPREGS+(9 * REGSZ)(a0)
	swc1	$f10, U_PCB_FPREGS+(10 * REGSZ)(a0)
	swc1	$f11, U_PCB_FPREGS+(11 * REGSZ)(a0)
	swc1	$f12, U_PCB_FPREGS+(12 * REGSZ)(a0)
	swc1	$f13, U_PCB_FPREGS+(13 * REGSZ)(a0)
	swc1	$f14, U_PCB_FPREGS+(14 * REGSZ)(a0)
	swc1	$f15, U_PCB_FPREGS+(15 * REGSZ)(a0)
	swc1	$f16, U_PCB_FPREGS+(16 * REGSZ)(a0)
	swc1	$f17, U_PCB_FPREGS+(17 * REGSZ)(a0)
	swc1	$f18, U_PCB_FPREGS+(18 * REGSZ)(a0)
	swc1	$f19, U_PCB_FPREGS+(19 * REGSZ)(a0)
	swc1	$f20, U_PCB_FPREGS+(20 * REGSZ)(a0)
	swc1	$f21, U_PCB_FPREGS+(21 * REGSZ)(a0)
	swc1	$f22, U_PCB_FPREGS+(22 * REGSZ)(a0)
	swc1	$f23, U_PCB_FPREGS+(23 * REGSZ)(a0)
	swc1	$f24, U_PCB_FPREGS+(24 * REGSZ)(a0)
	swc1	$f25, U_PCB_FPREGS+(25 * REGSZ)(a0)
	swc1	$f26, U_PCB_FPREGS+(26 * REGSZ)(a0)
	swc1	$f27, U_PCB_FPREGS+(27 * REGSZ)(a0)
	swc1	$f28, U_PCB_FPREGS+(28 * REGSZ)(a0)
	swc1	$f29, U_PCB_FPREGS+(29 * REGSZ)(a0)
	swc1	$f30, U_PCB_FPREGS+(30 * REGSZ)(a0)
	swc1	$f31, U_PCB_FPREGS+(31 * REGSZ)(a0)
d475 1
a475 1
	PTR_S	v0, U_PCB_REGS+(PC * REGSZ)(a3)	# save new pc
@


1.9
log
@Make the default boot partition p.
Migrate float exception code to 64 bit. Add a few new "uniplemented".
@
text
@d1 1
a1 1
/*	$OpenBSD: lcore_float.S,v 1.8 2004/10/20 12:49:15 pefo Exp $ */
d487 1
a487 1
	cfc1	a2, FPC_CSR		# code = FP execptions
@


1.8
log
@Fix some 64 bit address problems.
Some function names made more unique.
Other changes for the upcoming Origin 200 support.
@
text
@d1 1
a1 1
/*	$OpenBSD: lcore_float.S,v 1.7 2004/09/27 19:16:06 pefo Exp $ */
d433 2
d438 2
a439 2
	cfc1	t1, FPC_CSR	# stall til FP done
	cfc1	t1, FPC_CSR	# now get status
d441 1
a441 1
	sll	t2, t1, (31 - 17)	# unimplemented operation?
d445 2
a446 2
 * We got an unimplemented operation trap so
 * fetch the instruction, compute the next PC and emulate the instruction.
d454 5
a458 6
	PTR_S	a2, FRAMESZ(CF_SZ) + 2 * REGSZ(sp)
	PTR_L	a0, curprocpaddr		# first arg is ptr to CPU regs
	move	a1, a2				# second arg is instruction PC
	move	a2, t1				# third arg is floating point CSR
	jal	MipsEmulateBranch		# compute PC after branch
	move	a3, zero			# fourth arg is FALSE
d463 1
a463 1
	PTR_L	a2, FRAMESZ(CF_SZ) + 2 * REGSZ(sp)	# restore EXC pc
d465 1
a465 1
	lw	a0, 4(a2)			# a0 = coproc instruction
d471 2
a472 2
	lw	a0, 0(a2)			# a0 = coproc instruction
	PTR_ADDU v0, a2, 4			# v0 = next pc
d474 1
a474 1
	PTR_L	a3, curprocpaddr		# first arg is ptr to CPU regs
d481 1
a481 1
	beq	a3, OPCODE_C1, 4f		# this should never fail
d487 1
d489 15
a503 1
	cfc1	a2, FPC_CSR		# code = FP execptions
d513 1
a513 1
4:
@


1.7
log
@move ITLBNOPFIX to asm.h and make it conditional
@
text
@d1 1
a1 1
/*	$OpenBSD: lcore_float.S,v 1.6 2004/09/10 08:58:27 pefo Exp $ */
d471 1
a471 1
	addu	v0, a2, 4			# v0 = next pc
@


1.6
log
@Fix LEAF usage adding new extra arg. spotted by miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: lcore_float.S,v 1.5 2004/09/09 22:11:38 pefo Exp $ */
a43 2

#define	ITLBNOPFIX	nop;nop;nop;nop;nop;nop;nop;nop;nop;nop;
@


1.5
log
@Kernel moves to 64 bit. A few more tweaks when binutils is updated.
@
text
@d1 1
a1 1
/*	$OpenBSD: lcore_float.S,v 1.4 2004/08/15 18:35:58 pefo Exp $ */
d65 1
a65 1
LEAF(MipsSwitchFPState)
d169 1
a169 1
LEAF(MipsSwitchFPState16)
d290 1
a290 1
LEAF(MipsSaveCurFPState)
d350 1
a350 1
LEAF(MipsSaveCurFPState16)
d535 1
a535 1
LEAF(cp1_get_prid)
@


1.4
log
@gracefully handle FP traps
@
text
@d1 1
a1 1
/*	$OpenBSD: lcore_float.S,v 1.3 2004/08/10 20:15:47 deraadt Exp $ */
d81 2
a82 2
	lw	t2, U_PCB_REGS+(PS * REGSZ)(a0)	# get CPU status register
	sw	t0, U_PCB_FPREGS+(32 * REGSZ)(a0)	# save FP status
d84 1
a84 1
	sw	t2, U_PCB_REGS+(PS * REGSZ)(a0)	# save new status register
d125 1
a125 1
	lw	t0, U_PCB_FPREGS+(32 * REGSZ)(a1)	# get status register
d185 2
a186 2
	lw	t2, U_PCB_REGS+(PS * REGSZ)(a0)	# get CPU status register
	sw	t0, U_PCB_FPREGS+(32 * REGSZ)(a0)	# save FP status
d188 1
a188 1
	sw	t2, U_PCB_REGS+(PS * REGSZ)(a0)	# save new status register
d229 1
a229 1
	lw	t0, U_PCB_FPREGS+(32 * REGSZ)(a1)	# get status register
d291 1
a291 1
	lw	a0, P_ADDR(a0)			# get pointer to pcb for proc
d301 1
a301 1
	lw	t2, U_PCB_REGS+(PS * REGSZ)(a0)	# get CPU status register
d306 2
a307 2
	sw	t2, U_PCB_REGS+(PS * REGSZ)(a0)	# save new status register
	sw	t0, U_PCB_FPREGS+(32 * REGSZ)(a0)	# save FP status
d351 1
a351 1
	lw	a0, P_ADDR(a0)			# get pointer to pcb for proc
d361 1
a361 1
	lw	t2, U_PCB_REGS+(PS * REGSZ)(a0)	# get CPU status register
d366 2
a367 2
	sw	t2, U_PCB_REGS+(PS * REGSZ)(a0)	# save new status register
	sw	t0, U_PCB_FPREGS+(32 * REGSZ)(a0)	# save FP status
@


1.3
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: lcore_float.S,v 1.2 2004/08/09 14:57:26 pefo Exp $ */
d501 3
@


1.2
log
@Big cleanup. Removed some unused obsolete stuff and fixed copyrights
on some files. Arcbios support is now in, thus detects memorysize and cpu
clock frequency.
@
text
@d1 1
a1 1
/*	$OpenBSD: lcore_float.S,v 1.1 2004/08/06 20:56:03 pefo Exp $ */
d5 1
a5 1
 * 
@


1.1
log
@initial mips64
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a13 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Opsycon AB, Sweden.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d515 34
@

