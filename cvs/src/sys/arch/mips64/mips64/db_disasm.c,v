head	1.17;
access;
symbols
	OPENBSD_6_0:1.17.0.4
	OPENBSD_6_0_BASE:1.17
	OPENBSD_5_9:1.17.0.2
	OPENBSD_5_9_BASE:1.17
	OPENBSD_5_8:1.16.0.14
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.16.0.6
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.16.0.10
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.16.0.8
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.16.0.4
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.16.0.2
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.15.0.6
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.4
	OPENBSD_5_0:1.15.0.2
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.14.0.2
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.9.0.4
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.2
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.8.0.10
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.6
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.4
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.2
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.7.0.2
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.5.0.6
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.4
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.2
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.4.0.4
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.2
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.2.0.2
	OPENBSD_3_6_BASE:1.2;
locks; strict;
comment	@ * @;


1.17
date	2015.09.23.17.03.27;	author miod;	state Exp;
branches;
next	1.16;
commitid	v57iCOZrnMzQrqNv;

1.16
date	2012.09.29.21.37.03;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2011.04.04.16.58.28;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2010.11.11.17.34.53;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2010.09.20.23.37.08;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2010.09.19.23.34.33;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2010.09.17.00.30.09;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2010.09.17.00.25.11;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2010.01.16.23.26.43;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2007.11.24.19.39.20;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2007.07.05.04.37.30;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2007.03.27.15.57.20;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2006.01.15.14.36.09;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2005.01.31.21.35.50;	author grange;	state Exp;
branches;
next	1.3;

1.3
date	2004.09.15.16.05.18;	author pefo;	state Exp;
branches;
next	1.2;

1.2
date	2004.08.10.20.15.47;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2004.08.06.20.56.03;	author pefo;	state Exp;
branches;
next	;


desc
@@


1.17
log
@Output operands of movn and movz in the correct order.
@
text
@/*	$OpenBSD: db_disasm.c,v 1.16 2012/09/29 21:37:03 miod Exp $	*/

/*
 * Copyright (c) 2010 Miodrag Vallat.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
/*-
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Ralph Campbell.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	from: @@(#)kadb.c	8.1 (Berkeley) 6/10/93
 *      $Id: db_disasm.c,v 1.16 2012/09/29 21:37:03 miod Exp $
 */

#ifdef _KERNEL
#include <sys/param.h>
#include <sys/systm.h>
#else
#include <unistd.h>
#include <stdio.h>
#endif

#ifdef _KERNEL
#include <machine/db_machdep.h>
#endif
#include <machine/mips_opcode.h>
#include <machine/regnum.h>

#ifdef _KERNEL
#include <ddb/db_interface.h>
#include <ddb/db_output.h>
#include <ddb/db_sym.h>
#else
#define db_addr_t uint64_t
#define	db_printsym(addr,flags,fn)	(fn)("%p",addr)
#endif

static const char *op_name[64] = {
	NULL,	/* OP_SPECIAL */
	NULL,	/* OP_BCOND */
	"j",
	"jal",
	"beq",
	"bne",
	"blez",
	"bgtz",

	"addi",
	"addiu",
	"slti",
	"sltiu",
	"andi",
	"ori",
	"xori",
	"lui",

	"cop0",
	"cop1",
	"cop2",
	"cop1x",
	"beql",
	"bnel",
	"blezl",
	"bgtzl",

	"daddi",
	"daddiu",
	"ldl",
	"ldr",
	NULL,
	NULL,
	NULL,
	NULL,

	"lb",
	"lh",
	"lwl",
	"lw",
	"lbu",
	"lhu",
	"lwr",
	"lwu",

	"sb",
	"sh",
	"swl",
	"sw",
	"sdl",
	"sdr",
	"swr",
	"cache",

	"ll",
	"lwc1",
	"lwc2",
	"pref",
	"lld",
	"ldc1",
	"ldc2",
	"ld",

	"sc",
	"swc1",
	"swc2",
	"swc3",
	"scd",
	"sdc1",
	"sdc2",
	"sd"
};

static const char *special_name[64] = {
	"sll",
	NULL,
	"srl",
	"sra",
	"sllv",
	NULL,
	"srlv",
	"srav",

	"jr",
	"jalr",
	"movz",
	"movn",
	"syscall",
	"break",
	NULL,
	"sync",

	"mfhi",
	"mthi",
	"mflo",
	"mtlo",
	"dsllv",
	NULL,
	"dsrlv",
	"dsrav",

	"mult",
	"multu",
	"div",
	"divu",
	"dmult",
	"dmultu",
	"ddiv",
	"ddivu",

	"add",
	"addu",
	"sub",
	"subu",
	"and",
	"or",
	"xor",
	"nor",

	NULL,
	NULL,
	"slt",
	"sltu",
	"dadd",
	"daddu",
	"dsub",
	"dsubu",

	"tge",
	"tgeu",
	"tlt",
	"tltu",
	"teq",
	NULL,
	"tne",
	NULL,

	"dsll",
	NULL,
	"dsrl",
	"dsra",
	"dsll32",
	NULL,
	"dsrl32",
	"dsra32"
};

static const char *bcond_name[32] = {
	"bltz",
	"bgez",
	"bltzl",
	"bgezl",
	NULL,
	NULL,
	NULL,
	NULL,

	"tgei",
	"tgeiu",
	"tlti",
	"tltiu",
	"teqi",
	NULL,
	"tnei",
	NULL,

	"bltzal",
	"bgezal",
	"bltzall",
	"bgezall",
	NULL,
	NULL,
	NULL,
	NULL,

	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	"synci"
};

static const char *cop_std[OP_MTH + 1] = {
	"mfc",
	"dmfc",
	"cfc",
	"mfhc",
	"mtc",
	"dmtc",
	"ctc",
	"mthc"
};

static const char *cop1_name[64] = {
	"add",
	"sub",
	"mul",
	"div",
	"sqrt",
	"abs",
	"mov",
	"neg",

	"round.l",
	"trunc.l",
	"ceil.l",
	"floor.l",
	"round.w",
	"trunc.w",
	"ceil.w",
	"floor.w",

	NULL,
	NULL,	/* movf/movt */
	"movz",
	"movn",
	NULL,
	"recip",
	"rsqrt",
	NULL,

	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,

	"cvt.s",
	"cvt.d",
	NULL,
	NULL,
	"cvt.w",
	"cvt.l",
	NULL,
	NULL,

	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,

	"c.f",
	"c.un",
	"c.eq",
	"c.ueq",
	"c.olt",
	"c.ult",
	"c.ole",
	"c.ule",

	"c.sf",
	"c.ngle",
	"c.seq",
	"c.ngl",
	"c.lt",
	"c.nge",
	"c.le",
	"c.ngt"
};

static const char *fmt_name[16] = {
	"s",
	"d",
	NULL,
	NULL,
	"w",
	"l",
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL
};

static const char *cop1x_op4[8] = {
	NULL,
	NULL,
	NULL,
	NULL,
	"madd",
	"msub",
	"nmadd",
	"nmsub"
};

static const char *cop1x_std[32] = {
	"lwxc1",
	"ldxc1",
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,

	"swxc1",
	"sdxc1",
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	"prefx",

	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,

	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL
};

static const char *reg_name[32] = {
	"zero",	"at",	"v0",	"v1",	"a0",	"a1",	"a2",	"a3",
	"ta0",	"ta1",	"ta2",	"ta3",	"t0",	"t1",	"t2",	"t3",
	"s0",	"s1",	"s2",	"s3",	"s4",	"s5",	"s6",	"s7",
	"t8",	"t9",	"k0",	"k1",	"gp",	"sp",	"s8",	"ra"
};

static const char *cop0_miscname[64] = {
	NULL,
	"tlbr",
	"tlbwi",
	NULL,
	NULL,
	NULL,
	"tlbwr",
	NULL,

	"tlbp",
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,

	NULL,	/* rfe */
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,

	"eret",
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,

	"wait"	/* RM5200 */
};

static const char *cop0_tfp_miscname[64] = {
	NULL,
	"tlbr",
	"tlbw",
	NULL,
	NULL,
	NULL,
	"tlbwr",
	NULL,

	"tlbp",
	"dctr",
	"dctw"
};

static const char *cop0_reg0[32] = {
	"Index",
	"Random",
	"EntryLo0",
	"EntryLo1",
	"Context",
	"PageMask",
	"Wired",
	"Info",		/* RM7000 */

	"BadVAddr",
	"Count",
	"EntryHi",
	"Compare",
	"Status",
	"Cause",
	"EPC",
	"PRId",

	"Config",
	"LLAddr",
	"WatchLo",	/* RM7000 Watch1 */
	"WatchHi",	/* RM7000 Watch2 */
	"XContext",
	NULL,
	"PerfControl",	/* RM7000 */
	NULL,

	"WatchMask",	/* RM7000 */
	"PerfCount",	/* RM7000 */
	"ECC",
	"CacheErr",
	"TagLo",
	"TagHi",
	"ErrorEPC",
	NULL
};

static const char *cop0_reg1[32] = {
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,

	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,

	NULL,
	NULL,
	"IPLLo",
	"IPLHi",
	"IntCtl",
	NULL,
	NULL,
	NULL,

	NULL,
	NULL,
	"DErrAddr0",
	"DErrAddr1",
	NULL,
	NULL,
	NULL,
	NULL,
};

int
dbmd_print_insn(uint32_t ins, db_addr_t mdbdot, int (*pr)(const char *, ...))
{
	InstFmt i;
	int delay = 0;
	const char *insn, *descr;

	i.word = ins;
	insn = op_name[i.JType.op];

	switch (i.JType.op) {
	case OP_SPECIAL:
		/* recognize nop/ssnop variants of sll early */
		if (i.word == 0) {
			(*pr)("nop");
			break;
		} else if (i.word == 1 << 6) {
			(*pr)("ssnop");
			break;
		}

		/* display `daddu' involving zero as `move' */
		if (i.RType.func == OP_DADDU && i.RType.rt == 0) {
			(*pr)("move\t%s,%s",
			    reg_name[i.RType.rd], reg_name[i.RType.rs]);
			break;
		}

		if (i.RType.func == OP_MOVCI) {
			(*pr)("mov%c\t%s,%s,%d",
			    i.RType.rt & 1 ? 't' : 'f',
			    reg_name[i.RType.rd], reg_name[i.RType.rs],
			    i.RType.rt >> 2);
			break;
		}

		/* fix ambiguous opcode memonics */
		insn = special_name[i.RType.func];
		switch (i.RType.func) {
		case OP_SRL:
			if (i.RType.rs != 0)
				insn = "rotr";
			break;
		case OP_SRLV:
			if (i.RType.shamt != 0)
				insn = "rotrv";
			break;
		case OP_JR:
			if (i.RType.shamt != 0)
				insn = "jr.hb";
			break;
		case OP_JALR:
			if (i.RType.shamt != 0)
				insn = "jalr.hb";
			break;
		case OP_DSRL:
			if (i.RType.rs != 0)
				insn = "drotr";
			break;
		case OP_DSRLV:
			if (i.RType.shamt != 0)
				insn = "drotrv";
			break;
		}

		if (insn == NULL)
			goto unknown;
		(*pr)("%s", insn);

		switch (i.RType.func) {
		case OP_SLL:
		case OP_SRL:
		case OP_SRA:
		case OP_DSLL:
		case OP_DSRL:
		case OP_DSRA:
		case OP_DSLL32:
		case OP_DSRL32:
		case OP_DSRA32:
			(*pr)("\t%s,%s,%d",
			    reg_name[i.RType.rd], reg_name[i.RType.rt],
			    i.RType.shamt);
			break;
		case OP_SLLV:
		case OP_SRLV:
		case OP_SRAV:
		case OP_DSLLV:
		case OP_DSRLV:
		case OP_DSRAV:
			(*pr)("\t%s,%s,%s",
			    reg_name[i.RType.rd], reg_name[i.RType.rt],
			    reg_name[i.RType.rs]);
			break;
		case OP_MFHI:
		case OP_MFLO:
			(*pr)("\t%s", reg_name[i.RType.rd]);
			break;
		case OP_JALR:
			delay = 1;
			if (i.RType.rd != RA)
				(*pr)("\t%s,%s",
				    reg_name[i.RType.rd], reg_name[i.RType.rs]);
			else
				(*pr)("\t%s", reg_name[i.RType.rs]);
			break;
		case OP_JR:
			delay = 1;
			/* FALLTHROUGH */
		case OP_MTLO:
		case OP_MTHI:
			(*pr)("\t%s", reg_name[i.RType.rs]);
			break;
		case OP_MULT:
		case OP_MULTU:
		case OP_DIV:
		case OP_DIVU:
		case OP_DMULT:
		case OP_DMULTU:
		case OP_DDIV:
		case OP_DDIVU:
		case OP_TGE:
		case OP_TGEU:
		case OP_TLT:
		case OP_TLTU:
		case OP_TEQ:
		case OP_TNE:
			(*pr)("\t%s,%s",
			    reg_name[i.RType.rs], reg_name[i.RType.rt]);
			break;
		case OP_SYSCALL:
			if ((ins >> 6) != 0)
				(*pr)("\t%d", ins >> 6);
			break;
		case OP_SYNC:
			break;
		case OP_BREAK:
			(*pr)("\t%d", ins >> 16);
			break;
		case OP_MOVZ:
		case OP_MOVN:
		default:
			(*pr)("\t%s,%s,%s",
			    reg_name[i.RType.rd], reg_name[i.RType.rs],
			    reg_name[i.RType.rt]);
		};
		break;

	case OP_BCOND:
		insn = bcond_name[i.IType.rt];
		if (insn == NULL)
			goto unknown;
		if (i.IType.rt == 31) {	/* synci */
			(*pr)("%s\t", insn);
			goto loadstore;
		}
		(*pr)("%s\t%s,", insn, reg_name[i.IType.rs]);
		if ((i.IType.rt & 0x18) == 0x08)	/* trap, not branch */
			(*pr)("%d", i.IType.imm);
		else
			goto pr_displ;

	case OP_J:
	case OP_JAL:
		delay = 1;
		(*pr)("%s\t", insn);
		db_printsym((mdbdot & ~0x0fffffffUL) |
		    (db_addr_t)(i.JType.target << 2), DB_STGY_PROC, pr);
		break;

	case OP_BEQ:
	case OP_BEQL:
		if (i.IType.rs == ZERO && i.IType.rt == ZERO) {
			(*pr)("b\t");
			goto pr_displ;
		}
		/* FALLTHROUGH */
	case OP_BNE:
	case OP_BNEL:
		if (i.IType.rt == ZERO) {
			if (i.IType.op == OP_BEQL || i.IType.op == OP_BNEL) {
				/* get the non-l opcode name */
				insn = op_name[i.IType.op & 0x07];
				(*pr)("%szl\t%s,", insn, reg_name[i.IType.rs]);
			} else
				(*pr)("%sz\t%s,", insn, reg_name[i.IType.rs]);
		} else
			(*pr)("%s\t%s,%s,", insn,
			    reg_name[i.IType.rs], reg_name[i.IType.rt]);
pr_displ:
		delay = 1;
		db_printsym(mdbdot + 4 + ((int16_t)i.IType.imm << 2),
		    DB_STGY_PROC, pr);
		break;

	case OP_BLEZ:
	case OP_BGTZ:
	case OP_BLEZL:
	case OP_BGTZL:
		(*pr)("%s\t%s,", insn, reg_name[i.IType.rs]);
		goto pr_displ;

	case OP_ADDI:
	case OP_ADDIU:
	case OP_DADDI:
	case OP_DADDIU:
		if (i.IType.rs == 0) {
			(*pr)("li\t%s,%d",
			    reg_name[i.IType.rt], (int16_t)i.IType.imm);
			break;
		}
		/* FALLTHROUGH */
	case OP_SLTI:
	case OP_SLTIU:
	default:
		if (insn != NULL)
			(*pr)("%s\t%s,%s,%d", insn,
			    reg_name[i.IType.rt], reg_name[i.IType.rs],
			    (int16_t)i.IType.imm);
		else {
unknown:
			(*pr)(".word\t%08x", ins);
		}
		break;

	case OP_ORI:
	case OP_XORI:
		if (i.IType.rs == 0) {
			(*pr)("li\t%s,0x%x", reg_name[i.IType.rt], i.IType.imm);
			break;
		}
		/* FALLTHROUGH */
	case OP_ANDI:
		(*pr)("%s\t%s,%s,0x%x", insn,
		    reg_name[i.IType.rt], reg_name[i.IType.rs], i.IType.imm);
		break;

	case OP_LUI:
		(*pr)("%s\t%s,0x%x", insn, reg_name[i.IType.rt], i.IType.imm);
		break;

	case OP_COP0:
		switch (i.RType.rs) {
		case OP_MF:
		case OP_DMF:
		case OP_MT:
		case OP_DMT:
			if ((i.RType.func & 0x07) != 0) {
				insn = cop_std[i.RType.rs];
				descr = cop0_reg0[i.RType.rd];
				if (descr != NULL)
					(*pr)("%s0\t%s,%d,%d # %s.%d", insn,
					    reg_name[i.RType.rt], i.RType.rd,
					    i.RType.func & 0x07, descr,
					    i.RType.func & 0x07);
				else
					(*pr)("%s0\t%s,%d,%d", insn,
					    reg_name[i.RType.rt], i.RType.rd,
					    i.RType.func & 0x07);
				break;
			}
			/* FALLTHROUGH */
		case OP_CF:
		case OP_CT:
			insn = cop_std[i.RType.rs];
			if (i.RType.rs == OP_CF || i.RType.rs == OP_CT)
				descr = cop0_reg1[i.RType.rd];
			else
				descr = cop0_reg0[i.RType.rd];
			if (descr != NULL)
				(*pr)("%s0\t%s,%d # %s", insn,
				    reg_name[i.RType.rt], i.RType.rd, descr);
			else
				(*pr)("%s0\t%s,%d", insn,
				    reg_name[i.RType.rt], i.RType.rd);
			break;
		case OP_BC:
			(*pr)("bc0%c%c\t",
			    i.RType.rt & COPz_BC_TF_MASK ? 't' : 'f',
			    i.RType.rt & COPz_BCL_TF_MASK ? 'l' : ' ');
			goto pr_displ;
		case OP_C0MISC:
			if (i.FRType.func < nitems(cop0_miscname))
				insn = cop0_miscname[i.FRType.func];
			else
				insn = NULL;
			if (insn == NULL)
				goto unknown;
			else
				(*pr)("%s", insn);
			break;
		case OP_TFP_C0MISC:
			if (i.FRType.func < nitems(cop0_tfp_miscname))
				insn = cop0_tfp_miscname[i.FRType.func];
			else
				insn = NULL;
			if (insn == NULL)
				goto unknown;
			else
				(*pr)("%s", insn);
			break;
		default:
			goto unknown;
		};
		break;

	case OP_COP1:
		switch (i.RType.rs) {
		case OP_MF:
		case OP_DMF:
		case OP_CF:
		case OP_MFH:
		case OP_MT:
		case OP_DMT:
		case OP_CT:
		case OP_MTH:
			insn = cop_std[i.RType.rs];
			(*pr)("%s1\t%s,f%d", insn,
			    reg_name[i.RType.rt], i.RType.rd);
			break;
		case OP_BC:
			(*pr)("bc1%c%c\t",
			    i.RType.rt & COPz_BC_TF_MASK ? 't' : 'f',
			    i.RType.rt & COPz_BCL_TF_MASK ? 'l' : ' ');
			goto pr_displ;
		default:
			if (fmt_name[i.FRType.fmt] == NULL)
				goto unknown;
			if (i.FRType.func == 0x11) {	/* movcf */
				insn = i.FRType.ft & 1 ? "movt" : "movf";
				(*pr)("%s.%s\tf%d,f%d,%d",
				    insn, fmt_name[i.FRType.fmt],
				    i.FRType.fd, i.FRType.fs, i.FRType.ft >> 2);
				break;
			 }
			insn = cop1_name[i.FRType.func];
			if (insn == NULL)
				goto unknown;
			(*pr)("%s.%s\tf%d,f%d,f%d",
			    insn, fmt_name[i.FRType.fmt],
			    i.FRType.fd, i.FRType.fs, i.FRType.ft);
		};
		break;

	case OP_COP2:
		switch (i.RType.rs) {
		case OP_MF:
		case OP_DMF:
		case OP_CF:
		case OP_MFH:
		case OP_MT:
		case OP_DMT:
		case OP_CT:
		case OP_MTH:
			insn = cop_std[i.RType.rs];
			(*pr)("%s2\t%s,f%d", insn,
			    reg_name[i.RType.rt], i.RType.rd);
			break;
		case OP_BC:
			(*pr)("bc2%c%c\t",
			    i.RType.rt & COPz_BC_TF_MASK ? 't' : 'f',
			    i.RType.rt & COPz_BCL_TF_MASK ? 'l' : ' ');
			goto pr_displ;
		default:
			goto unknown;
		};
		break;

	case OP_COP1X:
		switch (i.FQType.op4) {
		case OP_MADD:
		case OP_MSUB:
		case OP_NMADD:
		case OP_NMSUB:
			if (fmt_name[i.FQType.fmt3] == NULL)
				goto unknown;
			insn = cop1x_op4[i.FQType.op4];
			(*pr)("%s.%s\tf%d,f%d,f%d,f%d",
			    insn, fmt_name[i.FQType.fmt3],
			    i.FQType.fd, i.FQType.fr,
			    i.FQType.fs, i.FQType.ft);
			break;
		default:
			insn = cop1x_std[i.FRType.func];
			switch (i.FRType.func) {
			case OP_LWXC1:
			case OP_LDXC1:
				(*pr)("%s\tf%d,%s(%s)", insn,
				    i.FQType.fd, reg_name[i.FQType.ft],
				    reg_name[i.FQType.fr]);
				break;
			case OP_SWXC1:
			case OP_SDXC1:
				(*pr)("%s\tf%d,%s(%s)", insn,
				    i.FQType.fs, reg_name[i.FQType.ft],
				    reg_name[i.FQType.fr]);
				break;
			case OP_PREFX:
				(*pr)("%s\t%d,%s(%s)", insn,
				    i.FQType.fs, reg_name[i.FQType.ft],
				    reg_name[i.FQType.fr]);
				break;
			}
			break;
		}
		break;

	case OP_LDL:
	case OP_LDR:
	case OP_LB:
	case OP_LH:
	case OP_LWL:
	case OP_LW:
	case OP_LBU:
	case OP_LHU:
	case OP_LWR:
	case OP_LWU:
	case OP_SB:
	case OP_SH:
	case OP_SWL:
	case OP_SW:
	case OP_SDL:
	case OP_SDR:
	case OP_SWR:
	case OP_LL:
	case OP_LLD:
	case OP_LD:
	case OP_SC:
	case OP_SCD:
	case OP_SD:
		(*pr)("%s\t%s,", insn, reg_name[i.IType.rt]);
loadstore:
		(*pr)("%d(%s)", (int16_t)i.IType.imm, reg_name[i.IType.rs]);
		break;

	case OP_CACHE:
		(*pr)("%s\t0x%x,", insn, i.IType.rt);
		goto loadstore;
		break;

	case OP_LWC1:
	case OP_LWC2:
	/* case OP_LWC3: superseded with OP_PREF */
	case OP_LDC1:
	case OP_LDC2:
	case OP_SWC1:
	case OP_SWC2:
	case OP_SWC3:
	case OP_SDC1:
	case OP_SDC2:
		(*pr)("%s\tf%d,", insn, i.IType.rt);
		goto loadstore;

	case OP_PREF:
		(*pr)("%s\t%d,", insn, i.IType.rt);
		goto loadstore;
	}
	(*pr)("\n");
	return delay;
}

#ifdef _KERNEL
db_addr_t
db_disasm(db_addr_t loc, boolean_t altfmt)
{
	extern uint32_t kdbpeek(vaddr_t);

	if (dbmd_print_insn(kdbpeek(loc), loc, db_printf)) {
		loc += 4;
		db_printsym(loc, DB_STGY_ANY, db_printf);
		db_printf(":\t ");
		dbmd_print_insn(kdbpeek(loc), loc, db_printf);
	}
	loc += 4;
	return loc;
}
#else
/*
 * Simple userspace test program (to confirm the logic never tries to print
 * NULL, to begin with...)
 */
int
main()
{
	uint32_t insn = 0;

	do {
		printf("%08x\t", insn);
		dbmd_print_insn(insn, 0, printf);
		insn++;
		if ((insn & 0x00ffffff) == 0)
			fprintf(stderr, "%08x\n", insn);
	} while (insn != 0);

	return 0;
}
#endif
@


1.16
log
@Basic R8000 processor support. R8000 processors require MMU-specific code,
exception-specific code, clock-specific code, and L1 cache-specific code. L2
cache is per-design, of which only two exist: SGI Power Indigo2 (IP26) and SGI
Power Challenge (IP21) and are not covered by this commit.

R8000 processors also are 64-bit only processors with 64-bit coprocessor 0
registers, and lack so-called ``compatibility'' memory spaces allowing 32-bit
code to run with sign-extended addresses and registers.

The intrusive changes are covered by #ifdef CPU_R8000 stanzas. However,
trap() is split into a high-level wrapper and a new function, itsa(),
responsible for the actual trap servicing (which name couldn't be helped
because I'm an incorrigible punster). While an R8000 exception may cause
(via trap() ) multiple exceptions to be serviced, non-R8000 processors will
always service one exception in trap(), but they are nevertheless affected
by this code split.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.15 2011/04/04 16:58:28 miod Exp $	*/
d54 1
a54 1
 *      $Id: db_disasm.c,v 1.15 2011/04/04 16:58:28 miod Exp $
a642 2
		case OP_MOVZ:
		case OP_MOVN:
d695 2
d846 1
d856 1
@


1.15
log
@Correctly disassemble triadic version of {d,}m[ft]c instructions found on
more and more mips64 processors.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.14 2010/11/11 17:34:53 miod Exp $	*/
d54 1
a54 1
 *      $Id: db_disasm.c,v 1.14 2010/11/11 17:34:53 miod Exp $
d463 2
a464 8
	"wait",	/* RM5200 */
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
d466 1
d468 2
d473 1
a473 3
	NULL,
	NULL,
	NULL,
d476 3
a478 17
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,

	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL
d838 13
a850 1
			insn = cop0_miscname[i.FRType.func];
@


1.14
log
@Correctly disassemble ssnop.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.13 2010/09/20 23:37:08 miod Exp $	*/
d54 1
a54 1
 *      $Id: db_disasm.c,v 1.13 2010/09/20 23:37:08 miod Exp $
d822 15
@


1.13
log
@Make md_printins() get the printf-like function as an extra parameter, and
make it visible so that md parts of the kernel can use it for debug messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.12 2010/09/19 23:34:33 miod Exp $	*/
d54 1
a54 1
 *      $Id: db_disasm.c,v 1.12 2010/09/19 23:34:33 miod Exp $
d592 1
a592 1
		} else if (i.word == 1 << 5) {
@


1.12
log
@Overhaul ddb disassembler to recognize all MIPS IV instructions, as well as
some mips64r2 instructions. Various bugfixes all over as well (conditional
trap instructions do not have a delay slot, for instance).
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.11 2010/09/17 00:30:09 miod Exp $	*/
d54 1
a54 1
 *      $Id: db_disasm.c,v 1.11 2010/09/17 00:30:09 miod Exp $
a76 1
#define	db_printf printf
d576 2
a577 4
static int md_printins(uint32_t ins, db_addr_t mdbdot);

static int
md_printins(uint32_t ins, db_addr_t mdbdot)
d590 1
a590 1
			db_printf("nop");
d593 1
a593 1
			db_printf("ssnop");
d599 1
a599 1
			db_printf("move\t%s,%s",
d605 1
a605 1
			db_printf("mov%c\t%s,%s,%d",
d643 1
a643 1
		db_printf("%s", insn);
d655 1
a655 1
			db_printf("\t%s,%s,%d",
d667 1
a667 1
			db_printf("\t%s,%s,%s",
d673 1
a673 1
			db_printf("\t%s", reg_name[i.RType.rd]);
d678 1
a678 1
				db_printf("\t%s,%s",
d681 1
a681 1
				db_printf("\t%s", reg_name[i.RType.rs]);
d688 1
a688 1
			db_printf("\t%s", reg_name[i.RType.rs]);
d704 1
a704 1
			db_printf("\t%s,%s",
d709 1
a709 1
				db_printf("\t%d", ins >> 6);
d714 1
a714 1
			db_printf("\t%d", ins >> 16);
d717 1
a717 1
			db_printf("\t%s,%s,%s",
d728 1
a728 1
			db_printf("%s\t", insn);
d731 1
a731 1
		db_printf("%s\t%s,", insn, reg_name[i.IType.rs]);
d733 1
a733 1
			db_printf("%d", i.IType.imm);
d740 1
a740 1
		db_printf("%s\t", insn);
d742 1
a742 1
		    (db_addr_t)(i.JType.target << 2), DB_STGY_PROC, db_printf);
d748 1
a748 1
			db_printf("b\t");
d758 1
a758 2
				db_printf("%szl\t%s,",
				    insn, reg_name[i.IType.rs]);
d760 1
a760 2
				db_printf("%sz\t%s,",
				    insn, reg_name[i.IType.rs]);
d762 1
a762 1
			db_printf("%s\t%s,%s,", insn,
d767 1
a767 1
		    DB_STGY_PROC, db_printf);
d774 1
a774 1
		db_printf("%s\t%s,", insn, reg_name[i.IType.rs]);
d782 1
a782 1
			db_printf("li\t%s,%d",
d791 1
a791 1
			db_printf("%s\t%s,%s,%d", insn,
d796 1
a796 1
			db_printf(".word\t%08x", ins);
d803 1
a803 2
			db_printf("li\t%s,0x%x",
			    reg_name[i.IType.rt], i.IType.imm);
d808 1
a808 1
		db_printf("%s\t%s,%s,0x%x", insn,
d813 1
a813 2
		db_printf("%s\t%s,0x%x", insn,
		    reg_name[i.IType.rt], i.IType.imm);
d830 1
a830 1
				db_printf("%s0\t%s,%d # %s", insn,
d833 1
a833 1
				db_printf("%s0\t%s,%d", insn,
d837 1
a837 1
			db_printf("bc0%c%c\t",
d846 1
a846 1
				db_printf("%s", insn);
d863 1
a863 1
			db_printf("%s1\t%s,f%d", insn,
d867 1
a867 1
			db_printf("bc1%c%c\t",
d876 1
a876 1
				db_printf("%s.%s\tf%d,f%d,%d",
d884 1
a884 1
			db_printf("%s.%s\tf%d,f%d,f%d",
d901 1
a901 1
			db_printf("%s2\t%s,f%d", insn,
d905 1
a905 1
			db_printf("bc2%c%c\t",
d923 1
a923 1
			db_printf("%s.%s\tf%d,f%d,f%d,f%d",
d933 1
a933 1
				db_printf("%s\tf%d,%s(%s)", insn,
d939 1
a939 1
				db_printf("%s\tf%d,%s(%s)", insn,
d944 1
a944 1
				db_printf("%s\t%d,%s(%s)", insn,
d976 1
a976 1
		db_printf("%s\t%s,", insn, reg_name[i.IType.rt]);
d978 1
a978 2
		db_printf("%d(%s)",
		    (int16_t)i.IType.imm, reg_name[i.IType.rs]);
d982 1
a982 1
		db_printf("%s\t0x%x,", insn, i.IType.rt);
d996 1
a996 1
		db_printf("%s\tf%d,", insn, i.IType.rt);
d1000 1
a1000 1
		db_printf("%s\t%d,", insn, i.IType.rt);
d1003 1
a1003 1
	db_printf("\n");
d1013 1
a1013 1
	if (md_printins(kdbpeek(loc), loc)) {
d1017 1
a1017 1
		md_printins(kdbpeek(loc), loc);
d1034 1
a1034 1
		md_printins(insn, 0);
@


1.11
log
@Correctly disassemble `branch likely' instructions.
@
text
@d1 17
a17 1
/*	$OpenBSD: db_disasm.c,v 1.10 2010/09/17 00:25:11 miod Exp $	*/
d54 1
a54 1
 *      $Id: db_disasm.c,v 1.10 2010/09/17 00:25:11 miod Exp $
d57 1
d60 4
d65 3
d69 3
a71 1
#include <machine/db_machdep.h>
d75 5
d82 145
a226 19
/* 0 */	"spec",	"bcond","j",	"jal",	"beq",	"bne",	"blez",	"bgtz",
/* 8 */	"addi",	"addiu","slti",	"sltiu","andi",	"ori",	"xori",	"lui",
/*16 */	"cop0",	"cop1",	"cop2",	"cop3",	"beql",	"bnel",	"blezl","bgtzl",
/*24 */	"daddi","daddiu","ldl",	"ldr",	"op34",	"op35",	"op36",	"op37",
/*32 */	"lb",	"lh",	"lwl",	"lw",	"lbu",	"lhu",	"lwr",	"lwu",
/*40 */	"sb",	"sh",	"swl",	"sw",	"sdl",	"sdr",	"swr",	"cache",
/*48 */	"ll",	"lwc1",	"lwc2",	"lwc3",	"lld",	"ldc1",	"ldc2",	"ld",
/*56 */	"sc",	"swc1",	"swc2",	"swc3",	"scd",	"sdc1",	"sdc2",	"sd"
};

static const char *spec_name[64] = {
/* 0 */	"sll",	"spec01","srl",	"sra",	"sllv",	"spec05","srlv","srav",
/* 8 */	"jr",	"jalr",	"spec12","spec13","syscall","break","spec16","sync",
/*16 */	"mfhi",	"mthi",	"mflo",	"mtlo",	"dsllv","spec25","dsrlv","dsrav",
/*24 */	"mult",	"multu","div",	"divu",	"dmult","dmultu","ddiv","ddivu",
/*32 */	"add",	"addu",	"sub",	"subu",	"and",	"or",	"xor",	"nor",
/*40 */	"spec50","spec51","slt","sltu",	"dadd","daddu","dsub","dsubu",
/*48 */	"tge","tgeu","tlt","tltu","teq","spec65","tne","spec67",
/*56 */	"dsll","spec71","dsrl","dsra","dsll32","spec75","dsrl32","dsra32"
d230 46
a275 4
/* 0 */	"bltz",	"bgez", "bltzl", "bgezl", "?", "?", "?", "?",
/* 8 */	"tgei", "tgeiu", "tlti", "tltiu", "teqi", "?", "tnei", "?",
/*16 */	"bltzal", "bgezal", "bltzall", "bgezall", "?", "?", "?", "?",
/*24 */	"?", "?", "?", "?", "?", "?", "?", "?",
d279 71
a349 10
/* 0 */	"fadd",	"fsub",	"fmpy",	"fdiv",	"fsqrt","fabs",	"fmov",	"fneg",
/* 8 */	"fop08","fop09","fop0a","fop0b","fop0c","fop0d","fop0e","fop0f",
/*16 */	"fop10","fop11","fop12","fop13","fop14","fop15","fop16","fop17",
/*24 */	"fop18","fop19","fop1a","fop1b","fop1c","fop1d","fop1e","fop1f",
/*32 */	"fcvts","fcvtd","fcvte","fop23","fcvtw","fop25","fop26","fop27",
/*40 */	"fop28","fop29","fop2a","fop2b","fop2c","fop2d","fop2e","fop2f",
/*48 */	"fcmp.f","fcmp.un","fcmp.eq","fcmp.ueq","fcmp.olt","fcmp.ult",
	"fcmp.ole","fcmp.ule",
/*56 */	"fcmp.sf","fcmp.ngle","fcmp.seq","fcmp.ngl","fcmp.lt","fcmp.nge",
	"fcmp.le","fcmp.ngt"
d353 65
a417 4
	"s",	"d",	"e",	"fmt3",
	"w",	"fmt5",	"fmt6",	"fmt7",
	"fmt8",	"fmt9",	"fmta",	"fmtb",
	"fmtc",	"fmtd",	"fmte",	"fmtf"
d427 110
a536 16
static const char *c0_opname[64] = {
	"c0op00","tlbr",  "tlbwi", "c0op03","c0op04","c0op05","tlbwr", "c0op07",
	"tlbp",  "c0op11","c0op12","c0op13","c0op14","c0op15","c0op16","c0op17",
	"rfe",   "c0op21","c0op22","c0op23","c0op24","c0op25","c0op26","c0op27",
	"eret","c0op31","c0op32","c0op33","c0op34","c0op35","c0op36","c0op37",
	"wait","c0op41","c0op42","c0op43","c0op44","c0op45","c0op46","c0op47",
	"c0op50","c0op51","c0op52","c0op53","c0op54","c0op55","c0op56","c0op57",
	"c0op60","c0op61","c0op62","c0op63","c0op64","c0op65","c0op66","c0op67",
	"c0op70","c0op71","c0op72","c0op73","c0op74","c0op75","c0op77","c0op77",
};

static const char *c0_reg[32] = {
	"index","random","tlblo0","tlblo1","context","tlbmask","wired","c0r7",
	"badvaddr","count","tlbhi","c0r11","sr","cause","epc",	"prid",
	"config","lladr","watchlo","watchhi","xcontext","c0r21","c0r22","c0r23",
	"c0r24","c0r25","ecc","cacheerr","taglo","taghi","errepc","c0r31"
d539 37
a575 1
uint32_t kdbpeek(vaddr_t);
a578 14
db_addr_t
db_disasm(db_addr_t loc, boolean_t altfmt)
{
        if (md_printins(kdbpeek(loc), loc)) {
		loc += 4;
		db_printsym(loc, DB_STGY_ANY, db_printf);
		db_printf(":\t ");
		md_printins(kdbpeek(loc), loc);
	}
	loc += 4;
        return loc;
}

/* ARGSUSED */
d584 1
d587 1
d591 1
d595 3
d599 3
a601 1
		if (i.RType.func == OP_ADDU && i.RType.rt == 0) {
d603 9
a611 2
				reg_name[i.RType.rd],
				reg_name[i.RType.rs]);
d614 34
a647 1
		db_printf("%s", spec_name[i.RType.func]);
d659 2
a660 3
				reg_name[i.RType.rd],
				reg_name[i.RType.rt],
				i.RType.shamt);
a661 1

d665 2
d671 2
a672 3
				reg_name[i.RType.rd],
				reg_name[i.RType.rt],
				reg_name[i.RType.rs]);
a673 1

d678 8
a685 1

a686 1
		case OP_JALR:
a692 1

d695 2
a698 2
		case OP_DIV:
		case OP_DIVU:
d701 6
d708 1
a708 2
				reg_name[i.RType.rs],
				reg_name[i.RType.rt]);
a709 1

d711 3
a715 1

d717 1
a717 1
			db_printf("\t%d", (i.RType.rs << 5) | i.RType.rt);
a718 1

d721 2
a722 3
				reg_name[i.RType.rd],
				reg_name[i.RType.rs],
				reg_name[i.RType.rt]);
d727 12
a738 3
		db_printf("%s\t%s,", bcond_name[i.IType.rt],
			reg_name[i.IType.rs]);
		goto pr_displ;
d740 7
a746 7
	case OP_BLEZ:
	case OP_BLEZL:
	case OP_BGTZ:
	case OP_BGTZL:
		db_printf("%s\t%s,", op_name[i.IType.op],
			reg_name[i.IType.rs]);
		goto pr_displ;
d750 1
a750 1
		if (i.IType.rs == 0 && i.IType.rt == 0) {
d757 13
a769 4
		db_printf("%s\t%s,%s,", op_name[i.IType.op],
			reg_name[i.IType.rs],
			reg_name[i.IType.rt]);
	pr_displ:
d775 6
a780 7
	case OP_COP0:
		switch (i.RType.rs) {
		case OP_BC:
			db_printf("bc0%c%c\t",
				"ft"[i.RType.rt & COPz_BC_TF_MASK],
				i.RType.rt & COPz_BCL_TF_MASK ? 'l' : ' ');
			goto pr_displ;
d782 7
a788 4
		case OP_MT:
			db_printf("mtc0\t%s,%s",
				reg_name[i.RType.rt],
				c0_reg[i.RType.rd]);
d790 14
d805 5
a809 4
		case OP_DMT:
			db_printf("dmtc0\t%s,%s",
				reg_name[i.RType.rt],
				c0_reg[i.RType.rd]);
d811 11
d823 2
a825 5
			db_printf("mfc0\t%s,%s",
				reg_name[i.RType.rt],
				c0_reg[i.RType.rd]);
			break;

d827 15
a841 3
			db_printf("dmfc0\t%s,%s",
				reg_name[i.RType.rt],
				c0_reg[i.RType.rd]);
d843 11
a853 1

d855 1
a855 1
			db_printf("%s", c0_opname[i.FRType.func]);
d861 12
d875 2
a876 2
				"ft"[i.RType.rt & COPz_BC_TF_MASK],
				i.RType.rt & COPz_BCL_TF_MASK ? 'l' : ' ');
d878 18
d897 6
d904 1
a904 11
			db_printf("mtc1\t%s,f%d",
				reg_name[i.RType.rt],
				i.RType.rd);
			break;

		case OP_MF:
			db_printf("mfc1\t%s,f%d",
				reg_name[i.RType.rt],
				i.RType.rd);
			break;

d906 4
a909 3
			db_printf("ctc1\t%s,f%d",
				reg_name[i.RType.rt],
				i.RType.rd);
d911 5
a915 7

		case OP_CF:
			db_printf("cfc1\t%s,f%d",
				reg_name[i.RType.rt],
				i.RType.rd);
			break;

d917 1
a917 4
			db_printf("%s.%s\tf%d,f%d,f%d",
				cop1_name[i.FRType.func],
				fmt_name[i.FRType.fmt],
				i.FRType.fd, i.FRType.fs, i.FRType.ft);
d921 37
a957 6
	case OP_J:
	case OP_JAL:
		db_printf("%s\t", op_name[i.JType.op]);
		db_printsym((mdbdot & ~0x0fffffffUL) |
		    (db_addr_t)(i.JType.target << 2), DB_STGY_PROC, db_printf);
		delay = 1;
d960 2
a961 6
	case OP_LWC1:
	case OP_SWC1:
		db_printf("%s\tf%d,", op_name[i.IType.op],
			i.IType.rt);
		goto loadstore;

d964 1
a965 1
	case OP_LD:
d968 1
d972 1
d974 8
d983 4
a986 5
		db_printf("%s\t%s,", op_name[i.IType.op],
			reg_name[i.IType.rt]);
	loadstore:
		db_printf("%d(%s)", (int16_t)i.IType.imm,
			reg_name[i.IType.rs]);
d989 3
a991 14
	case OP_ORI:
	case OP_XORI:
		if (i.IType.rs == 0) {
			db_printf("li\t%s,0x%x",
				reg_name[i.IType.rt],
				i.IType.imm);
			break;
		}
		/* FALLTHROUGH */
	case OP_ANDI:
		db_printf("%s\t%s,%s,0x%x", op_name[i.IType.op],
			reg_name[i.IType.rt],
			reg_name[i.IType.rs],
			i.IType.imm);
d994 20
a1013 5
	case OP_LUI:
		db_printf("%s\t%s,0x%x", op_name[i.IType.op],
			reg_name[i.IType.rt],
			i.IType.imm);
		break;
d1015 5
a1019 6
	case OP_CACHE:
		db_printf("%s\t0x%x,%d(%s)", op_name[i.IType.op],
			i.IType.rt,
			(int16_t)i.IType.imm,
			reg_name[i.IType.rs]);
		break;
d1021 5
a1025 16
	case OP_ADDI:
	case OP_DADDI:
	case OP_ADDIU:
	case OP_DADDIU:
		if (i.IType.rs == 0) {
			db_printf("li\t%s,%d",
				reg_name[i.IType.rt],
				(int16_t)i.IType.imm);
			break;
		}
		/* FALLTHROUGH */
	default:
		db_printf("%s\t%s,%s,%d", op_name[i.IType.op],
			reg_name[i.IType.rt],
			reg_name[i.IType.rs],
			(int16_t)i.IType.imm);
d1027 22
a1048 2
	db_printf("\n");
	return(delay);
d1050 1
@


1.10
log
@There is only one code for coprocessor BC opcodes, so don't bother to handle
a second (invalid) opcode; confirmed by all mips core documentation.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.9 2010/01/16 23:26:43 miod Exp $	*/
d38 1
a38 1
 *      $Id: db_disasm.c,v 1.9 2010/01/16 23:26:43 miod Exp $
d267 4
a270 4
		case OP_BCx:
		case OP_BCy:
			db_printf("bc0%c\t",
				"ft"[i.RType.rt & COPz_BC_TF_MASK]);
@


1.9
log
@Fix types so that the upper 32 bits of addresses of branches are correct.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.8 2007/11/24 19:39:20 miod Exp $	*/
d38 1
a38 1
 *      $Id: db_disasm.c,v 1.8 2007/11/24 19:39:20 miod Exp $
d304 4
a307 4
		case OP_BCx:
		case OP_BCy:
			db_printf("bc1%c\t",
				"ft"[i.RType.rt & COPz_BC_TF_MASK]);
@


1.8
log
@Recognize the wait r5k instruction in ddb and use it in cpu_idle_cycle.
ok jsing@@ a while ago (and this diff is much much older)
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.7 2007/07/05 04:37:30 miod Exp $	*/
d38 1
a38 1
 *      $Id: db_disasm.c,v 1.7 2007/07/05 04:37:30 miod Exp $
d50 1
a50 1
static char *op_name[64] = {
d61 1
a61 1
static char *spec_name[64] = {
d72 1
a72 1
static char *bcond_name[32] = {
d79 1
a79 1
static char *cop1_name[64] = {
d92 1
a92 1
static char *fmt_name[16] = {
d99 1
a99 1
static char *reg_name[32] = {
d106 1
a106 1
static char *c0_opname[64] = {
d117 1
a117 1
static char *c0_reg[32] = {
d124 1
a124 1
int  kdbpeek(void *);
d126 1
a126 1
static int md_printins(int ins, int mdbdot);
d129 1
a129 3
db_disasm(loc, altfmt)
	db_addr_t loc;
	boolean_t altfmt;
d131 1
a131 1
        if (md_printins(kdbpeek((void *)loc), loc)) {
d135 1
a135 1
		md_printins(kdbpeek((void *)loc), loc);
d143 1
a143 1
md_printins(int ins, int mdbdot)
d261 1
a261 1
		db_printsym(mdbdot + 4 + ((short)i.IType.imm << 2),
d345 2
a346 2
		db_printsym((mdbdot & ~0x0fffffffL) | (i.JType.target << 2),
		    DB_STGY_PROC, db_printf);
d370 1
a370 1
		db_printf("%d(%s)", (short)i.IType.imm,
d399 1
a399 1
			(short)i.IType.imm,
d410 1
a410 1
				(short)i.IType.imm);
d418 1
a418 1
			(short)i.IType.imm);
@


1.7
log
@Compute the correct address and try and print a matching symbol for j and
jal instructions.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.6 2007/03/27 15:57:20 miod Exp $	*/
d38 1
a38 1
 *      $Id: db_disasm.c,v 1.6 2007/03/27 15:57:20 miod Exp $
d111 1
a111 1
	"c0op40","c0op41","c0op42","c0op43","c0op44","c0op45","c0op46","c0op47",
@


1.6
log
@Try and print symbol-relative addresses for branches, and display
delay slots instructions correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.5 2006/01/15 14:36:09 miod Exp $	*/
d38 1
a38 1
 *      $Id: db_disasm.c,v 1.5 2006/01/15 14:36:09 miod Exp $
d347 2
a348 1
		db_printf("0x%8x",(mdbdot & 0xF0000000) | (i.JType.target << 2));
@


1.5
log
@Print cache instructions correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.4 2005/01/31 21:35:50 grange Exp $	*/
d38 1
a38 1
 *      $Id: db_disasm.c,v 1.4 2005/01/31 21:35:50 grange Exp $
d48 1
d135 2
a136 1
		printf("\t\t");
d263 2
a264 1
		db_printf("0x%08x", mdbdot + 4 + ((short)i.IType.imm << 2));
@


1.4
log
@Un-__P.

ok pefo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.3 2004/09/15 16:05:18 pefo Exp $	*/
d38 1
a38 1
 *      $Id: db_disasm.c,v 1.3 2004/09/15 16:05:18 pefo Exp $
d392 7
@


1.3
log
@Make trace work better. Don't hope for a good stacktrace without symbols
loaded. GCC 3.x really moves things around.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.2 2004/08/10 20:15:47 deraadt Exp $	*/
d38 1
a38 1
 *      $Id: db_disasm.c,v 1.2 2004/08/10 20:15:47 deraadt Exp $
d123 1
a123 1
int  kdbpeek __P((void *));
d125 1
a125 1
static int md_printins __P((int ins, int mdbdot));
@


1.2
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.1 2004/08/06 20:56:03 pefo Exp $	*/
d38 1
a38 1
 *      $Id: db_disasm.c,v 1.1 2004/08/06 20:56:03 pefo Exp $
d100 1
a100 1
	"t0",	"t1",	"t2",	"t3",	"t4",	"t5",	"t6",	"t7",
@


1.1
log
@initial mips64
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.1 1998/03/16 09:03:24 pefo Exp $	*/
d38 1
a38 1
 *      $Id: db_disasm.c,v 1.1 1998/03/16 09:03:24 pefo Exp $
a130 1

d135 1
a135 1
        	md_printins(kdbpeek((void *)loc), loc);
d139 1
a139 1
} 
d399 1
a399 1
 			db_printf("li\t%s,%d",
@

