head	1.8;
access;
symbols
	OPENBSD_6_1:1.8.0.14
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.8.0.10
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.6
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.8
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.2
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.4
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.7.0.10
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.6
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.4
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.2
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.10
	OPENBSD_5_0:1.5.0.8
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.6
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.2
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.2.0.20
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.16
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.2.0.14
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3:1.2.0.12
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_2:1.2.0.10
	OPENBSD_4_2_BASE:1.2
	OPENBSD_4_1:1.2.0.8
	OPENBSD_4_1_BASE:1.2
	OPENBSD_4_0:1.2.0.6
	OPENBSD_4_0_BASE:1.2
	OPENBSD_3_9:1.2.0.4
	OPENBSD_3_9_BASE:1.2
	OPENBSD_3_8:1.2.0.2
	OPENBSD_3_8_BASE:1.2
	OPENBSD_3_7:1.1.0.4
	OPENBSD_3_7_BASE:1.1
	OPENBSD_3_6:1.1.0.2
	OPENBSD_3_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.8
date	2014.04.03.08.07.16;	author mpi;	state Exp;
branches;
next	1.7;

1.7
date	2012.04.21.12.20.30;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2012.03.25.13.52.52;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2010.01.09.23.34.29;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2009.12.25.21.02.15;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.27.18.20.13;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2005.08.01.15.43.12;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2004.08.06.20.56.03;	author pefo;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Moar <uvm/uvm.h> -> <uvm/uvm_extern.h> love.
@
text
@/*	$OpenBSD: sys_machdep.c,v 1.7 2012/04/21 12:20:30 miod Exp $	*/

/*
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Ralph Campbell.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)sys_machdep.c	8.1 (Berkeley) 6/10/93
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/ioctl.h>
#include <sys/file.h>
#include <sys/time.h>
#include <sys/proc.h>
#include <sys/kernel.h>
#include <sys/buf.h>

#include <sys/mount.h>
#include <sys/syscallargs.h>

#include <uvm/uvm_extern.h>

#include <mips64/cache.h>
#include <mips64/sysarch.h>

#include <machine/autoconf.h>

int	mips64_cacheflush(struct proc *, struct mips64_cacheflush_args *);

int
sys_sysarch(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_sysarch_args /* {
		syscallarg(int) op;
		syscallarg(char *) parms;
	} */ *uap = v;
	int error = 0;

	switch(SCARG(uap, op)) {
	case MIPS64_CACHEFLUSH:
	    {
		struct mips64_cacheflush_args cfa;

		if ((error = copyin(SCARG(uap, parms), &cfa, sizeof cfa)) != 0)
			return error;
		error = mips64_cacheflush(p, &cfa);
	    }
		break;
	default:
		error = EINVAL;
		break;
	}

	return error;
}

int
mips64_cacheflush(struct proc *p, struct mips64_cacheflush_args *cfa)
{
	vaddr_t va;
	paddr_t pa;
	size_t sz, chunk;
	struct vm_map *map = &p->p_vmspace->vm_map;
	struct pmap *pm = map->pmap;
	struct vm_map_entry *entry;
	int rc = 0;

	/*
	 * Sanity checks.
	 */
	if ((cfa->which & BCACHE) != cfa->which)
		return EINVAL;

	if (cfa->which == 0)
		return 0;

	va = cfa->va;
	sz = cfa->sz;
	chunk = PAGE_SIZE - (va & PAGE_MASK);
	vm_map_lock_read(map);
	if (va < vm_map_min(map) || va + sz > vm_map_max(map) || va + sz < va)
		rc = EFAULT;
	else while (sz != 0) {
		if (chunk > sz)
			chunk = sz;

		/*
		 * Check for a resident mapping first, this is faster than
		 * uvm_map_lookup_entry().
		 */
		if (pmap_extract(pm, va, &pa) != FALSE) {
			if (cfa->which & ICACHE)
				Mips_InvalidateICache(p->p_cpu, va, chunk);
			if (cfa->which & DCACHE)
				Mips_HitSyncDCache(p->p_cpu, va, chunk);
		} else {
			if (uvm_map_lookup_entry(map, va, &entry) == FALSE) {
				rc = EFAULT;
				break;
			}
			/* else simply not resident at the moment */
		}

		va += chunk;
		sz -= chunk;
		chunk = PAGE_SIZE;
	}
	vm_map_unlock_read(map);

	return rc;
}
@


1.7
log
@Rework the signature of the cache handling routines again. It makes more sense
to pass both the virtual and physical addresses of the page to clean to
SyncDCachePage, which is the only routine using `Index' operations on the data
cache, which might be virtually indexed at some levels but physically indexed
at others. On the other hand, it does not make any sense to pass a physical
address to routines using `Hit' operations (and they were discarding them
anyway).

In addition to making things cleaner, this fixes sporadic userland misbehaviour
(read: SIGSGEV) on RM7000 O2 systems.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_machdep.c,v 1.6 2012/03/25 13:52:52 miod Exp $	*/
d53 1
a53 1
#include <uvm/uvm.h>
@


1.6
log
@Move cache handling routines related definitions to a dedicated header file,
rather than abusing <machine/cpu.h>.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_machdep.c,v 1.5 2010/01/09 23:34:29 miod Exp $	*/
d130 1
a130 1
				Mips_HitSyncDCache(p->p_cpu, va, pa, chunk);
@


1.5
log
@Move cache information from global variables to per-cpu_info fields; this
allows processors with different cache sizes to be used.

Cache management routines now take a struct cpu_info * as first parameter.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_machdep.c,v 1.4 2009/12/25 21:02:15 miod Exp $	*/
d55 1
@


1.4
log
@Pass both the virtual address and the physical address of the memory range
when invoking the cache functions. The physical address is needed when
operating on physically-indexed caches, such as the L2 cache on Loongson
processors.

Preprocessor abuse makes sure that the physical address computation gets
compiled out when running on a kernel compiled for virtually-indexed
caches only, such as the sgi kernel.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_machdep.c,v 1.3 2009/09/27 18:20:13 miod Exp $	*/
d127 1
a127 1
				Mips_InvalidateICache(va, chunk);
d129 1
a129 1
				Mips_HitSyncDCache(va, pa, chunk);
@


1.3
log
@Add an implementation of IRIX-compatible cacheflush() routine to mips ports,
needed for gcc -ftrampoline operation as well as by some third-party
software.
Although the implementation uses the sysarch() sysctl, the wrapper is
added to libc as it was a direct system call (which it is on IRIX).
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_machdep.c,v 1.2 2005/08/01 15:43:12 miod Exp $	*/
d125 1
a125 1
		if (pmap_extract(pm, va, &pa) != 0) {
d129 1
a129 1
				Mips_HitSyncDCache(va, chunk);
@


1.2
log
@Remoe unused vtrace stuff; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_machdep.c,v 1.1 2004/08/06 20:56:03 pefo Exp $	*/
d53 8
d74 9
d87 58
a144 1
	return(error);
@


1.1
log
@initial mips64
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_machdep.c,v 1.1 1998/01/28 12:12:09 pefo Exp $	*/
a46 1
#include <sys/uio.h>
a47 1
#include <sys/mtio.h>
a51 56

#ifdef TRACE
int	nvualarm;

vtrace(p, uap, retval)
	struct proc *p;
	register struct vtrace_args /* {
		syscallarg(int) request;
		syscallarg(int) value;
	} */ *uap;
	register_t *retval;
{
	int vdoualarm();

	switch (SCARG(uap, request)) {

	case VTR_DISABLE:		/* disable a trace point */
	case VTR_ENABLE:		/* enable a trace point */
		if (SCARG(uap, value) < 0 || SCARG(uap, value) >= TR_NFLAGS)
			return (EINVAL);
		*retval = traceflags[SCARG(uap, value)];
		traceflags[SCARG(uap, value)] = SCARG(uap, request);
		break;

	case VTR_VALUE:		/* return a trace point setting */
		if (SCARG(uap, value) < 0 || SCARG(uap, value) >= TR_NFLAGS)
			return (EINVAL);
		*retval = traceflags[SCARG(uap, value)];
		break;

	case VTR_UALARM:	/* set a real-time ualarm, less than 1 min */
		if (SCARG(uap, value) <= 0 || SCARG(uap, value) > 60 * hz ||
		    nvualarm > 5)
			return (EINVAL);
		nvualarm++;
		timeout(vdoualarm, (caddr_t)p->p_pid, SCARG(uap, value));
		break;

	case VTR_STAMP:
		trace(TR_STAMP, SCARG(uap, value), p->p_pid);
		break;
	}
	return (0);
}

vdoualarm(arg)
	int arg;
{
	register struct proc *p;

	p = pfind(arg);
	if (p)
		psignal(p, 16);
	nvualarm--;
}
#endif
@

