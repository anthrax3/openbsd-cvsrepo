head	1.25;
access;
symbols
	OPENBSD_6_1:1.21.0.4
	OPENBSD_6_1_BASE:1.21
	OPENBSD_6_0:1.20.0.2
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.19.0.4
	OPENBSD_5_9_BASE:1.19
	OPENBSD_5_8:1.19.0.6
	OPENBSD_5_8_BASE:1.19
	OPENBSD_5_7:1.19.0.2
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.15.0.4
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.12.0.6
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.12.0.2
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.11.0.2
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.4.0.2
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.6
	OPENBSD_5_0:1.2.0.4
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.2
	OPENBSD_4_9_BASE:1.2;
locks; strict;
comment	@ * @;


1.25
date	2017.09.02.15.56.29;	author visa;	state Exp;
branches;
next	1.24;
commitid	1y6OLI6UaecTzk2S;

1.24
date	2017.09.01.13.16.47;	author visa;	state Exp;
branches;
next	1.23;
commitid	mhxDobf0k9bDgJtK;

1.23
date	2017.06.08.12.02.52;	author visa;	state Exp;
branches;
next	1.22;
commitid	zGzjYZWjWwx4nSCj;

1.22
date	2017.05.29.11.46.49;	author visa;	state Exp;
branches;
next	1.21;
commitid	KqakzHkcVH77nHKw;

1.21
date	2016.08.16.13.03.58;	author visa;	state Exp;
branches;
next	1.20;
commitid	6TiwRQZbesPVamIE;

1.20
date	2016.03.06.19.42.27;	author mpi;	state Exp;
branches;
next	1.19;
commitid	cyYKarj4qRTft4gD;

1.19
date	2014.12.15.02.24.22;	author guenther;	state Exp;
branches;
next	1.18;
commitid	ZxaujiOM0aYQRjFY;

1.18
date	2014.12.13.23.29.14;	author guenther;	state Exp;
branches;
next	1.17;
commitid	GnI4LcupJV7IUKdp;

1.17
date	2014.11.16.12.30.58;	author deraadt;	state Exp;
branches;
next	1.16;
commitid	yv0ECmCdICvq576h;

1.16
date	2014.08.12.04.28.07;	author miod;	state Exp;
branches;
next	1.15;
commitid	qTh0IaV8ZOA8Xs0l;

1.15
date	2014.04.03.08.07.16;	author mpi;	state Exp;
branches;
next	1.14;

1.14
date	2014.03.21.23.05.41;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2014.03.09.10.12.17;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2013.04.21.15.43.34;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2013.01.16.20.23.54;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2013.01.15.23.30.37;	author pirofti;	state Exp;
branches;
next	1.9;

1.9
date	2013.01.14.21.18.47;	author pirofti;	state Exp;
branches;
next	1.8;

1.8
date	2012.10.03.11.18.23;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2012.09.29.21.37.03;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2012.09.29.19.29.05;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2012.09.29.19.11.08;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2012.07.14.19.50.12;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2012.03.24.22.10.59;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2010.11.24.21.16.28;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2010.10.24.15.40.03;	author miod;	state Exp;
branches;
next	;


desc
@@


1.25
log
@Let the kernel utilize the FPU if one is available, even when the
FPUEMUL option is enabled. This benefits OCTEON III systems which can
run floating-point operations natively.

Feedback from and OK miod@@; he also helped with testing.

Tested on octeon without FPU (CN5020, CN6120) and with FPU (CN7130),
as well as on sgi/IP27 (MP R16000), sgi/IP32 (R5000), and
loongson (3A1000).
@
text
@/*	$OpenBSD: mips64_machdep.c,v 1.24 2017/09/01 13:16:47 visa Exp $ */

/*
 * Copyright (c) 2009, 2010, 2012 Miodrag Vallat.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
/*
 * Copyright (c) 2001-2004 Opsycon AB  (www.opsycon.se / www.opsycon.com)
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/proc.h>
#include <sys/exec.h>
#include <sys/sysctl.h>
#include <sys/timetc.h>

#include <machine/autoconf.h>
#include <machine/cpu.h>
#include <mips64/cache.h>
#include <mips64/mips_cpu.h>
#include <mips64/mips_opcode.h>

#include <uvm/uvm_extern.h>

#include <mips64/dev/clockvar.h>

/*
 * Build a tlb trampoline
 */
void
build_trampoline(vaddr_t addr, vaddr_t dest)
{
	const uint32_t insns[] = {
		0x3c1a0000,	/* lui k0, imm16 */
		0x675a0000,	/* daddiu k0, k0, imm16 */
		0x001ad438,	/* dsll k0, k0, 0x10 */
		0x675a0000,	/* daddiu k0, k0, imm16 */
		0x001ad438,	/* dsll k0, k0, 0x10 */
		0x675a0000,	/* daddiu k0, k0, imm16 */
		0x03400008,	/* jr k0 */
		0x00000000	/* nop */
	};
	uint32_t *dst = (uint32_t *)addr;
	const uint32_t *src = insns;
	uint32_t a, b, c, d;

	/*
	 * Decompose the handler address in the four components which,
	 * added with sign extension, will produce the correct address.
	 */
	d = dest & 0xffff;
	dest >>= 16;
	if (d & 0x8000)
		dest++;
	c = dest & 0xffff;
	dest >>= 16;
	if (c & 0x8000)
		dest++;
	b = dest & 0xffff;
	dest >>= 16;
	if (b & 0x8000)
		dest++;
	a = dest & 0xffff;

	/*
	 * Build the trampoline, skipping noop computations.
	 */
	*dst++ = *src++ | a;
	if (b != 0)
		*dst++ = *src++ | b;
	else
		src++;
	*dst++ = *src++;
	if (c != 0)
		*dst++ = *src++ | c;
	else
		src++;
	*dst++ = *src++;
	if (d != 0)
		*dst++ = *src++ | d;
	else
		src++;
	*dst++ = *src++;
	*dst++ = *src++;

	/*
	 * Note that we keep the delay slot instruction a nop, instead
	 * of branching to the second instruction of the handler and
	 * having its first instruction in the delay slot, so that the
	 * tlb handler is free to use k0 immediately.
	 */
}

/*
 * Prototype status registers value for userland processes.
 */
register_t protosr = SR_FR_32 | SR_XX | SR_UX | SR_KSU_USER | SR_EXL |
#ifdef CPU_R8000
    SR_SERIALIZE_FPU |
#else
    SR_KX |
#endif
    SR_INT_ENAB;

/*
 * Set registers on exec for native exec format. For o64/64.
 */
void
setregs(struct proc *p, struct exec_package *pack, u_long stack,
    register_t *retval)
{
	struct cpu_info *ci = curcpu();

	bzero((caddr_t)p->p_md.md_regs, sizeof(struct trapframe));
	p->p_md.md_regs->sp = stack;
	p->p_md.md_regs->pc = pack->ep_entry & ~3;
	p->p_md.md_regs->t9 = pack->ep_entry & ~3; /* abicall req */
	p->p_md.md_regs->sr = protosr | (idle_mask & SR_INT_MASK);
	p->p_md.md_regs->ic = (idle_mask << 8) & IC_INT_MASK;
	if (CPU_HAS_FPU(ci))
		p->p_md.md_flags &= ~MDP_FPUSED;
	if (ci->ci_fpuproc == p)
		ci->ci_fpuproc = NULL;

	retval[1] = 0;
}

int
exec_md_map(struct proc *p, struct exec_package *pack)
{
#ifdef FPUEMUL
	struct cpu_info *ci = curcpu();
	vaddr_t va;
	int rc;

	if (CPU_HAS_FPU(ci))
		return 0;

	/*
	 * If we are running with FPU instruction emulation, we need
	 * to allocate a special page in the process' address space,
	 * in order to be able to emulate delay slot instructions of
	 * successful conditional branches.
	 */

	va = 0;
	rc = uvm_map(&p->p_vmspace->vm_map, &va, PAGE_SIZE, NULL,
	    UVM_UNKNOWN_OFFSET, 0,
	    UVM_MAPFLAG(PROT_NONE, PROT_MASK, MAP_INHERIT_COPY,
	      MADV_NORMAL, UVM_FLAG_COPYONW));
	if (rc != 0)
		return rc;
#ifdef DEBUG
	printf("%s: p %p fppgva %p\n", __func__, p, va);
#endif
	p->p_md.md_fppgva = va;
#endif

	return 0;
}

/*
 * Initial TLB setup for the current processor.
 */
void
tlb_init(unsigned int tlbsize)
{
#ifdef CPU_R8000
	register_t sr;

	sr = getsr();
	sr &= ~(((uint64_t)SR_PGSZ_MASK << SR_KPGSZ_SHIFT) |
	        ((uint64_t)SR_PGSZ_MASK << SR_UPGSZ_SHIFT));
	sr |= ((uint64_t)SR_PGSZ_16K << SR_KPGSZ_SHIFT) |
	    ((uint64_t)SR_PGSZ_16K << SR_UPGSZ_SHIFT);
	protosr |= ((uint64_t)SR_PGSZ_16K << SR_KPGSZ_SHIFT) |
	    ((uint64_t)SR_PGSZ_16K << SR_UPGSZ_SHIFT);
	setsr(sr);
#else
	tlb_set_page_mask(TLB_PAGE_MASK);
#endif
	tlb_set_wired(0);
	tlb_flush(tlbsize);
#if UPAGES > 1
	tlb_set_wired(UPAGES / 2);
#endif
}

/*
 * Handle an ASID wrap.
 */
void
tlb_asid_wrap(struct cpu_info *ci)
{
	tlb_flush(ci->ci_hw.tlbsize);
#if defined(CPU_OCTEON) || defined(CPU_R8000)
	Mips_InvalidateICache(ci, 0, ci->ci_l1inst.size);
#endif
}

/*
 *	Mips machine independent clock routines.
 */

struct tod_desc sys_tod;
void (*md_startclock)(struct cpu_info *);

/*
 * Wait "n" microseconds.
 */
void
delay(int n)
{
	int dly;
	int p, c;
	struct cpu_info *ci = curcpu();
	uint32_t delayconst;

	delayconst = ci->ci_delayconst;
	if (delayconst == 0)
		delayconst = bootcpu_hwinfo.clock / CP0_CYCLE_DIVIDER;
	p = cp0_get_count();
	dly = (delayconst / 1000000) * n;
	while (dly > 0) {
		c = cp0_get_count();
		dly -= c - p;
		p = c;
	}
}

#ifndef MULTIPROCESSOR
u_int cp0_get_timecount(struct timecounter *);

struct timecounter cp0_timecounter = {
	cp0_get_timecount,	/* get_timecount */
	0,			/* no poll_pps */
	0xffffffff,		/* counter_mask */
	0,			/* frequency */
	"CP0",			/* name */
	0			/* quality */
};

u_int
cp0_get_timecount(struct timecounter *tc)
{
	return (cp0_get_count());
}
#endif

/*
 * Calibrate cpu internal counter against the TOD clock if available.
 */
void
cp0_calibrate(struct cpu_info *ci)
{
	struct tod_desc *cd = &sys_tod;
	struct tod_time ct;
	u_int first_cp0, second_cp0, cycles_per_sec;
	int first_sec;

	if (cd->tod_get == NULL)
		return;

	(*cd->tod_get)(cd->tod_cookie, 0, &ct);
	first_sec = ct.sec;

	/* Let the clock tick one second. */
	do {
		first_cp0 = cp0_get_count();
		(*cd->tod_get)(cd->tod_cookie, 0, &ct);
	} while (ct.sec == first_sec);
	first_sec = ct.sec;
	/* Let the clock tick one more second. */
	do {
		second_cp0 = cp0_get_count();
		(*cd->tod_get)(cd->tod_cookie, 0, &ct);
	} while (ct.sec == first_sec);

	cycles_per_sec = second_cp0 - first_cp0;
	ci->ci_hw.clock = cycles_per_sec * CP0_CYCLE_DIVIDER;
	ci->ci_delayconst = cycles_per_sec;
}

/*
 * Start the real-time and statistics clocks.
 */
void
cpu_initclocks()
{
	struct cpu_info *ci = curcpu();

	profhz = hz;

	tick = 1000000 / hz;	/* number of micro-seconds between interrupts */
	tickadj = 240000 / (60 * hz);		/* can adjust 240ms in 60s */

	cp0_calibrate(ci);

#ifndef MULTIPROCESSOR
	if (cpu_setperf == NULL) {
		cp0_timecounter.tc_frequency =
		    (uint64_t)ci->ci_hw.clock / CP0_CYCLE_DIVIDER;
		tc_init(&cp0_timecounter);
	}
#endif

#ifdef DIAGNOSTIC
	if (md_startclock == NULL)
		panic("no clock");
#endif
	(*md_startclock)(ci);
}

/*
 * We assume newhz is either stathz or profhz, and that neither will
 * change after being set up above.  Could recalculate intervals here
 * but that would be a drag.
 */
void
setstatclockrate(int newhz)
{
}

/* XXX switch to kern/clock_subr.c routines */
/*
 * This code is defunct after 2099. Will Unix still be here then??
 */
static short dayyr[12] = {
	0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334
};

#define	SECMIN	(60)		/* seconds per minute */
#define	SECHOUR	(60*SECMIN)	/* seconds per hour */

#define	YEARDAYS(year)	(((((year) + 1900) % 4) == 0 && \
			 ((((year) + 1900) % 100) != 0 || \
			  (((year) + 1900) % 400) == 0)) ? 366 : 365)

/*
 * Initialize the time of day register, based on the time base which
 * is, e.g. from a filesystem.
 */
void
inittodr(time_t base)
{
	struct timespec ts;
	struct tod_time c;
	struct tod_desc *cd = &sys_tod;
	int days, yr;

	ts.tv_nsec = 0;

	if (base < 35 * SECYR) {
		printf("WARNING: preposterous time in file system");
		/* read the system clock anyway */
		base = 40 * SECYR;	/* 2010 */
	}

	/*
	 * Read RTC chip registers NOTE: Read routines are responsible
	 * for sanity checking clock. Dates after 19991231 should be
	 * returned as year >= 100.
	 */
	if (cd->tod_get) {
		(*cd->tod_get)(cd->tod_cookie, base, &c);
	} else {
		printf("WARNING: No TOD clock, believing file system.\n");
		goto bad;
	}

	days = 0;
	for (yr = 70; yr < c.year; yr++) {
		days += YEARDAYS(yr);
	}

	days += dayyr[c.mon - 1] + c.day - 1;
	if (YEARDAYS(c.year) == 366 && c.mon > 2) {
		days++;
	}

	/* now have days since Jan 1, 1970; the rest is easy... */
	ts.tv_sec = days * SECDAY + c.hour * 3600 + c.min * 60 + c.sec;

	/*
	 * See if we gained/lost time.
	 */
	if (base < ts.tv_sec - 5*SECYR) {
		printf("WARNING: file system time much less than clock time\n");
	} else if (base > ts.tv_sec + 5*SECYR) {
		printf("WARNING: clock time much less than file system time\n");
		printf("WARNING: using file system time\n");
	} else {
		tc_setclock(&ts);
		cd->tod_valid = 1;
		return;
	}

bad:
	ts.tv_sec = base;
	tc_setclock(&ts);
	cd->tod_valid = 1;
	printf("WARNING: CHECK AND RESET THE DATE!\n");
}

/*
 * Reset the TOD clock. This is done when the system is halted or
 * when the time is reset by the stime system call.
 */
void
resettodr()
{
	struct tod_time c;
	struct tod_desc *cd = &sys_tod;
	int t, t2;

	/*
	 *  Don't reset TOD if time has not been set!
	 */
	if (!cd->tod_valid)
		return;

	/* compute the day of week. 1 is Sunday*/
	t2 = time_second / SECDAY;
	c.dow = (t2 + 5) % 7 + 1;	/* 1/1/1970 was thursday */

	/* compute the year */
	t = 0;
	t2 = time_second / SECDAY;
	c.year = 69;
	while (t2 >= 0) {	/* whittle off years */
		t = t2;
		c.year++;
		t2 -= YEARDAYS(c.year);
	}

	/* t = month + day; separate */
	t2 = YEARDAYS(c.year);
	for (c.mon = 1; c.mon < 12; c.mon++) {
		if (t < dayyr[c.mon] + (t2 == 366 && c.mon > 1))
			break;
	}

	c.day = t - dayyr[c.mon - 1] + 1;
	if (t2 == 366 && c.mon > 2) {
		c.day--;
	}

	t = time_second % SECDAY;
	c.hour = t / 3600;
	t %= 3600;
	c.min = t / 60;
	c.sec = t % 60;

	if (cd->tod_set)
		(*cd->tod_set)(cd->tod_cookie, &c);
}

/*
 * Decode instruction and figure out type.
 */
int
classify_insn(uint32_t insn)
{
	InstFmt	inst;

	inst.word = insn;
	switch (inst.JType.op) {
	case OP_SPECIAL:
		switch (inst.RType.func) {
		case OP_JR:
			return INSNCLASS_BRANCH;
		case OP_JALR:
			return INSNCLASS_CALL;
		}
		break;

	case OP_BCOND:
		switch (inst.IType.rt) {
		case OP_BLTZ:
		case OP_BLTZL:
		case OP_BGEZ:
		case OP_BGEZL:
			return INSNCLASS_BRANCH;
		case OP_BLTZAL:
		case OP_BLTZALL:
		case OP_BGEZAL:
		case OP_BGEZALL:
			return INSNCLASS_CALL;
		}
		break;

	case OP_JAL:
		return INSNCLASS_CALL;

	case OP_J:
	case OP_BEQ:
	case OP_BEQL:
	case OP_BNE:
	case OP_BNEL:
	case OP_BLEZ:
	case OP_BLEZL:
	case OP_BGTZ:
	case OP_BGTZL:
		return INSNCLASS_BRANCH;

	case OP_COP1:
		switch (inst.RType.rs) {
		case OP_BC:
			return INSNCLASS_BRANCH;
		}
		break;
	}

	return INSNCLASS_NEUTRAL;
}

/*
 * Smash the startup code. There is no way to really unmap it
 * because the kernel runs in the kseg0 or xkphys space.
 */
void
unmap_startup(void)
{
	extern uint32_t kernel_text[], endboot[];
	uint32_t *word = kernel_text;

	while (word < endboot)
		*word++ = 0x00000034u;	/* TEQ zero, zero */
}
@


1.24
log
@Ansify function definitions.
@
text
@d1 1
a1 1
/*	$OpenBSD: mips64_machdep.c,v 1.23 2017/06/08 12:02:52 visa Exp $ */
d155 2
a156 3
#ifndef FPUEMUL
	p->p_md.md_flags &= ~MDP_FPUSED;
#endif
d167 2
d170 3
a172 1
	vaddr_t va;
@


1.23
log
@Move loongson/octeon/sgi unmap_startup() under arch/mips64.
@
text
@d1 1
a1 1
/*	$OpenBSD: mips64_machdep.c,v 1.22 2017/05/29 11:46:49 visa Exp $ */
d144 2
a145 5
setregs(p, pack, stack, retval)
	struct proc *p;
	struct exec_package *pack;
	u_long stack;
	register_t *retval;
@


1.22
log
@Invalidate OCTEON icache after TLB ASID wraparound, otherwise userspace
might execute stale instructions. The cache is virtually tagged and does
not seem to pick up TLB alterations automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: mips64_machdep.c,v 1.21 2016/08/16 13:03:58 visa Exp $ */
d550 14
@


1.21
log
@Remove RM7000/RM9000-specific performance counter code. It originates
from PMON2000 and has not been enabled on OpenBSD.

Suggested by and ok miod@@ (after seeing a quad_t cleanup patch of mine)
@
text
@d1 1
a1 1
/*	$OpenBSD: mips64_machdep.c,v 1.20 2016/03/06 19:42:27 mpi Exp $ */
d54 1
d231 1
a231 1
#ifdef CPU_R8000
@


1.20
log
@Rename mips64's trap_frame into trapframe.

For coherency with other archs and in order to use it in MI code.

ok visa@@, tobiasu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mips64_machdep.c,v 1.19 2014/12/15 02:24:22 guenther Exp $ */
a161 4
	p->p_md.md_ss_addr = 0;
	p->p_md.md_pc_ctrl = 0;
	p->p_md.md_watch_1 = 0;
	p->p_md.md_watch_2 = 0;
@


1.19
log
@Use MAP_INHERIT_* for the 'inh' argument to the UMV_MAPFLAG() macro,
eliminating the must-be-kept-in-sync UVM_INH_* macros

ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mips64_machdep.c,v 1.18 2014/12/13 23:29:14 guenther Exp $ */
d151 1
a151 1
	bzero((caddr_t)p->p_md.md_regs, sizeof(struct trap_frame));
@


1.18
log
@An UVM_ADV_NORMAL -> MADV_NORMAL was missed here
@
text
@d1 1
a1 1
/*	$OpenBSD: mips64_machdep.c,v 1.17 2014/11/16 12:30:58 deraadt Exp $ */
d187 1
a187 1
	    UVM_MAPFLAG(PROT_NONE, PROT_MASK, UVM_INH_COPY,
@


1.17
log
@Replace a plethora of historical protection options with just
PROT_NONE, PROT_READ, PROT_WRITE, and PROT_EXEC from mman.h.
PROT_MASK is introduced as the one true way of extracting those bits.
Remove UVM_ADV_* wrapper, using the standard names.
ok doug guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: mips64_machdep.c,v 1.16 2014/08/12 04:28:07 miod Exp $ */
d188 1
a188 1
	      UVM_ADV_NORMAL, UVM_FLAG_COPYONW));
@


1.16
log
@Pass 0 instead of uvm_map_hint() to uvm_map() in exec_md_map() to figure out
where to put the fpu assist page, for uvm_map_hint() may return an address
outside userland bounds due to aggressive randomization. Passing zero will
still get a random address, but correctly bounded.
@
text
@d1 1
a1 1
/*	$OpenBSD: mips64_machdep.c,v 1.15 2014/04/03 08:07:16 mpi Exp $ */
d187 1
a187 1
	    UVM_MAPFLAG(UVM_PROT_NONE, UVM_PROT_ALL, UVM_INH_COPY,
@


1.15
log
@Moar <uvm/uvm.h> -> <uvm/uvm_extern.h> love.
@
text
@d1 1
a1 1
/*	$OpenBSD: mips64_machdep.c,v 1.14 2014/03/21 23:05:41 miod Exp $ */
d184 1
a184 1
	va = uvm_map_hint(p->p_vmspace, UVM_PROT_RX);
@


1.14
log
@Rename db_inst_type() into classify_insn() and make that function available
outside of ddb. It will be used by regular kernel code shortly.
@
text
@d1 1
a1 1
/*	$OpenBSD: mips64_machdep.c,v 1.13 2014/03/09 10:12:17 miod Exp $ */
d57 1
a57 1
#include <uvm/uvm.h>
@


1.13
log
@Rework the per-cpu cache information. Use a common struct to store the line
size, the number of sets, and the total size (and the set size, for convenience)
per cache (I$, D$, L2, L3).
This allows cpu.c to print the number of ways (sets) of L2 and L3 caches from
the cache information, rather than hardcoding this from the processor type.
@
text
@d1 1
a1 1
/*	$OpenBSD: mips64_machdep.c,v 1.12 2013/04/21 15:43:34 miod Exp $ */
d55 1
d494 59
@


1.12
log
@In inittodr(), be sure to only invoke tc_setclock() once. Fixes huge uptime
when the clock is bad and we switch to the filesystem time.
@
text
@d1 1
a1 1
/*	$OpenBSD: mips64_machdep.c,v 1.11 2013/01/16 20:23:54 miod Exp $ */
d234 1
a234 1
	Mips_InvalidateICache(ci, 0, ci->ci_l1instcachesize);
@


1.11
log
@Do not register the internal cpu timer-based timecounter if we support cpu
throttling.
@
text
@d1 1
a1 1
/*	$OpenBSD: mips64_machdep.c,v 1.10 2013/01/15 23:30:37 pirofti Exp $ */
a419 2
	tc_setclock(&ts);
	cd->tod_valid = 1;
d430 2
@


1.10
log
@Loongson: Add a stat clock for the lemote machines.

The stat clock is implemented so that it also covers, at least
according to the tests I've done, Torek's paper on randomized sampling.

Most of the bits for randomizing the stat ticks were taken from sparc's
implementation and adapted to the companion chip's MFGPT frequencies.

Before this my lemote showed a 8% cpu usage for the cpuhog example from
Torek's paper even though openssl speed showed differences up to 27%
when ran with and without cpuhog. With the new stat clock  it shows
cpuhog around 18-22%, which I think is the proper value.

Okay miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: mips64_machdep.c,v 1.9 2013/01/14 21:18:47 pirofti Exp $ */
d49 1
d337 5
a341 3
	cp0_timecounter.tc_frequency =
	    (uint64_t)ci->ci_hw.clock / CP0_CYCLE_DIVIDER;
	tc_init(&cp0_timecounter);
@


1.9
log
@Loongson: Replace the system clock provided by the CPU with a GLX MFGPT.

CPU throttling was not possible due to the fact that the system clock
was the CPU clock. So slowing down the CPU would also slow down the
passing of time.

This commit adds a driver for the MFGPT1 clock from the AMD companion
chip found on lemote and hooks it up as the system clock.

It also changes the frequency value of hz from the default, which was
100, to 128. That's because the scaling on MFGPT clocks is represented
by powers of two.

Okay miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: mips64_machdep.c,v 1.8 2012/10/03 11:18:23 miod Exp $ */
d321 1
a321 2
 * Start the real-time and statistics clocks. Leave stathz 0 since there
 * are no other timers available.
a328 1
	stathz = 0;	/* XXX no stat clock yet */
@


1.8
log
@Split ever-growing mips <machine/cpu.h> into what 99% of the kernel needs,
which will remain in <machine/cpu.h>, and a new mips_cpu.h containing only the
goriest md details, which are only of interest to a handful set of files; this
is similar in spirit to what alpha does, but here <machine/cpu.h> does not
include the new file.
@
text
@d1 1
a1 1
/*	$OpenBSD: mips64_machdep.c,v 1.7 2012/09/29 21:37:03 miod Exp $ */
d329 1
a329 2
	hz = 100;
	profhz = 100;
@


1.7
log
@Basic R8000 processor support. R8000 processors require MMU-specific code,
exception-specific code, clock-specific code, and L1 cache-specific code. L2
cache is per-design, of which only two exist: SGI Power Indigo2 (IP26) and SGI
Power Challenge (IP21) and are not covered by this commit.

R8000 processors also are 64-bit only processors with 64-bit coprocessor 0
registers, and lack so-called ``compatibility'' memory spaces allowing 32-bit
code to run with sign-extended addresses and registers.

The intrusive changes are covered by #ifdef CPU_R8000 stanzas. However,
trap() is split into a high-level wrapper and a new function, itsa(),
responsible for the actual trap servicing (which name couldn't be helped
because I'm an incorrigible punster). While an R8000 exception may cause
(via trap() ) multiple exceptions to be serviced, non-R8000 processors will
always service one exception in trap(), but they are nevertheless affected
by this code split.
@
text
@d1 1
a1 1
/*	$OpenBSD: mips64_machdep.c,v 1.6 2012/09/29 19:29:05 miod Exp $ */
d53 1
@


1.6
log
@Store the base value of coprocessor 0 system register, when running userland,
into a global. This allows R12000 O2 systems to set the DSD bit in once for
all, instead of having to set it every time in setregs().
@
text
@d1 1
a1 1
/*	$OpenBSD: mips64_machdep.c,v 1.5 2012/09/29 19:11:08 miod Exp $ */
d129 6
a134 1
    SR_KX | SR_INT_ENAB;
d203 12
d216 1
d231 3
@


1.5
log
@Kill the mostly unused VMTLB_xxx and VMNUM_xxx defines. Move all tlb
knowledge to <machine/pte.h>. Add specific routines for tlb handling setup
(at cpu initialization time) and tlb ASID wrap.
@
text
@d1 1
a1 1
/*	$OpenBSD: mips64_machdep.c,v 1.4 2012/07/14 19:50:12 miod Exp $ */
d126 6
d147 1
a147 7
	p->p_md.md_regs->sr = SR_FR_32 | SR_XX | SR_KSU_USER | SR_KX | SR_UX |
	    SR_EXL | SR_INT_ENAB;
#if defined(CPU_R10000) && !defined(TGT_COHERENT)
	if (ci->ci_hw.type == MIPS_R12000)
		p->p_md.md_regs->sr |= SR_DSD;
#endif
	p->p_md.md_regs->sr |= idle_mask & SR_INT_MASK;
@


1.4
log
@Split the existing mips64 clock code into time-of-day and generic duties in
machdep.c, and internal clock interrupting on level 5, still in clock.c; this
will allow other clock sources to be used in the near future. (delay() will
remain tied to the internal clock)
@
text
@d1 1
a1 1
/*	$OpenBSD: mips64_machdep.c,v 1.3 2012/03/24 22:10:59 miod Exp $ */
d4 1
a4 1
 * Copyright (c) 2009, 2010 Miodrag Vallat.
d190 23
@


1.3
log
@Fix fallback of uvm_map_hint() argument changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: mips64_machdep.c,v 1.2 2010/11/24 21:16:28 miod Exp $ */
d19 1
a19 1
 * Copyright (c) 2003-2004 Opsycon AB  (www.opsycon.se / www.opsycon.com)
d43 1
d49 1
d51 1
d56 2
d190 258
@


1.2
log
@Floating-point emulation code for systems lacking proper FPU (i.e. Octeon),
enabled by option FPUEMUL.

This is pretty straightforward, except for conditional branch on FPU condition
codes emulation (bc1f/bc1fl/bc1t/bc1tl instructions): unlike most
RISC-with-delay-slots designs (m88k, sparc), the branch pipeline is not exposed
to the kernel on Mips, therefore we can not resume a branch without losing the
delay slot instruction.

Some other operating systems work around this issue by emulating the delay
slot instruction, but this is error-prone (and requires the kernel code to
be aware of all supported instructions of the processor it is currently running
on), some use dedicated breakpoints to single-step through the delay slot and
then resume the branch as expected, but this causes a lot of copy-on-write
allocations.

This code chooses a third path, of copying the delay slot instructions to run toa special `magic' page, followed by a special trap instruction to give control
back to the kernel. This makes sure the instruction will actually be run by the
processor, and that no more than one page per process is wasted, regardless of
the number of branches to emulate.

Tested on octeon (big-endian) by syuu@@ and on loongson (little-endian) by me.
Note that enabling option FPUEMUL in the kernel will completely disable the
hardware FPU, if there is one; there is currently no way to build a kernel
supporting both hardware and software FPU, and there is no reason to change
this until there is a strong need to support both.
@
text
@d1 1
a1 1
/*	$OpenBSD: mips64_machdep.c,v 1.1 2010/10/24 15:40:03 miod Exp $ */
d171 1
a171 1
	va = uvm_map_hint(p, UVM_PROT_RX);
@


1.1
log
@Move build_trampoline() and setregs() to a common location for all mips ports.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.23 2010/08/28 22:29:03 miod Exp $ */
d144 1
d146 1
d155 30
@

