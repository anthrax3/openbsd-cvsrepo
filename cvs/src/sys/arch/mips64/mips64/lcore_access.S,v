head	1.27;
access;
symbols
	OPENBSD_6_2:1.27.0.4
	OPENBSD_6_2_BASE:1.27
	OPENBSD_6_1:1.26.0.6
	OPENBSD_6_1_BASE:1.26
	OPENBSD_6_0:1.26.0.2
	OPENBSD_6_0_BASE:1.26
	OPENBSD_5_9:1.24.0.12
	OPENBSD_5_9_BASE:1.24
	OPENBSD_5_8:1.24.0.14
	OPENBSD_5_8_BASE:1.24
	OPENBSD_5_7:1.24.0.6
	OPENBSD_5_7_BASE:1.24
	OPENBSD_5_6:1.24.0.10
	OPENBSD_5_6_BASE:1.24
	OPENBSD_5_5:1.24.0.8
	OPENBSD_5_5_BASE:1.24
	OPENBSD_5_4:1.24.0.4
	OPENBSD_5_4_BASE:1.24
	OPENBSD_5_3:1.24.0.2
	OPENBSD_5_3_BASE:1.24
	OPENBSD_5_2:1.21.0.2
	OPENBSD_5_2_BASE:1.21
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.10
	OPENBSD_5_0:1.19.0.8
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.19.0.6
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.19.0.4
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.19.0.2
	OPENBSD_4_7_BASE:1.19
	OPENBSD_4_6:1.17.0.4
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.16.0.2
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.15.0.2
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.13.0.2
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.10.0.2
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.9.0.6
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.4
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.2
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.8.0.4
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.2
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.6.0.2
	OPENBSD_3_6_BASE:1.6;
locks; strict;
comment	@# @;


1.27
date	2017.05.19.00.50.24;	author visa;	state Exp;
branches;
next	1.26;
commitid	5BT3pImXKPn4ULqw;

1.26
date	2016.05.23.20.11.49;	author deraadt;	state Exp;
branches;
next	1.25;
commitid	0oWSDXhpPUnuLpPD;

1.25
date	2016.05.10.18.39.47;	author deraadt;	state Exp;
branches;
next	1.24;
commitid	qfOifNidEGDB2jL1;

1.24
date	2012.10.03.11.18.23;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2012.09.29.21.37.03;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2012.09.29.19.02.26;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2012.04.16.22.23.04;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2012.03.28.20.44.23;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2010.01.31.19.39.04;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2009.09.30.06.22.00;	author syuu;	state Exp;
branches;
next	1.17;

1.17
date	2009.05.22.20.37.53;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2009.02.15.14.13.33;	author jsing;	state Exp;
branches;
next	1.15;

1.15
date	2008.06.09.20.43.43;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2008.04.07.22.37.18;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2008.02.20.21.34.19;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2008.02.20.19.13.38;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2008.02.20.18.35.43;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2007.05.20.14.34.23;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2005.12.20.07.06.26;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2004.10.20.12.49.15;	author pefo;	state Exp;
branches;
next	1.7;

1.7
date	2004.09.27.19.16.06;	author pefo;	state Exp;
branches;
next	1.6;

1.6
date	2004.09.10.08.58.27;	author pefo;	state Exp;
branches;
next	1.5;

1.5
date	2004.09.09.22.11.38;	author pefo;	state Exp;
branches;
next	1.4;

1.4
date	2004.08.10.20.15.47;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.09.14.57.26;	author pefo;	state Exp;
branches;
next	1.2;

1.2
date	2004.08.08.14.21.27;	author pefo;	state Exp;
branches;
next	1.1;

1.1
date	2004.08.06.20.56.03;	author pefo;	state Exp;
branches;
next	;


desc
@@


1.27
log
@Implement copyin32(9) for mips64.

OK kettenis@@
@
text
@/*	$OpenBSD: lcore_access.S,v 1.26 2016/05/23 20:11:49 deraadt Exp $ */

/*
 * Copyright (c) 2001-2003 Opsycon AB  (www.opsycon.se / www.opsycon.com)
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */
#include <sys/errno.h>
#include <sys/syscall.h>

#include <machine/param.h>
#include <machine/asm.h>
#include <machine/cpu.h>
#include <mips64/mips_cpu.h>
#include <machine/regnum.h>
#include <machine/cpustate.h>
#include <machine/trap.h>

#include "assym.h"

	.set	mips3

	.set	noreorder		# Noreorder is default style!

/*
 * Primitives
 */

/*
 * This table is indexed by u.u_pcb.pcb_onfault in trap().
 * The reason for using this table rather than storing an address in
 * u.u_pcb.pcb_onfault is simply to make the code faster.
 * This table must match with definitions in trap.h.
 */
	.globl	onfault_table
	.data
	.align	3
onfault_table:
	PTR_VAL	0		# invalid index number
	PTR_VAL	_copyerr
	PTR_VAL	_kcopyerr
#if defined(DDB) || defined(DEBUG)
	PTR_VAL	kt_ddberr
#else
	PTR_VAL	0
#endif
	PTR_VAL	_guarderr
	.text

/*
 * This code is copied the user's stack for returning from signal handlers
 * (see sendsig() and sigreturn()). We have to compute the address
 * of the sigcontext struct for the sigreturn call.
 */
	.globl	sigcode
sigcode:
	PTR_ADDU a0, sp, 4*REGSZ		# address of sigcontext
	LI	v0, SYS_sigreturn	# sigreturn(scp)
	syscall
	.globl  _C_LABEL(sigcoderet)
_C_LABEL(sigcoderet):
	break	0			# just in case sigreturn fails
	.globl	esigcode
esigcode:

	.globl	sigfill
sigfill:
	break	0
esigfill:

	.data
	.globl	sigfillsiz
sigfillsiz:
	.long	esigfill - sigfill

	.text

/*
 * Copy a null terminated string within the kernel address space.
 * Maxlength may be null if count not wanted.
 *	copystr(fromaddr, toaddr, maxlength, &lencopied)
 *		caddr_t fromaddr;
 *		caddr_t toaddr;
 *		u_int maxlength;
 *		u_long *lencopied;
 */
LEAF(copystr, 0)
	move	t2, a2			# Save the number of bytes
	move	v0, zero
1:
	lbu	t0, 0(a0)
	PTR_SUBU a2, a2, 1
	sb	t0, 0(a1)
	PTR_ADDU a0, a0, 1
	beq	t0, zero, 2f
	 PTR_ADDU a1, a1, 1
	bne	a2, zero, 1b
	 NOP
	LI	v0, ENAMETOOLONG	# String is longer than maxlength
2:
	beq	a3, zero, 3f
	 PTR_SUBU a2, t2, a2		# Compute length copied
	REG_S	a2, 0(a3)
3:
	j	ra
	 NOP
END(copystr)

/*
 * Optimized memory zero code.
 * mem_zero_page(addr);
 */
LEAF(mem_zero_page, 0)
	LI	v0, PAGE_SIZE
1:
	PTR_SUBU v0, 8
	sd	zero, 0(a0)
	bne	zero, v0, 1b
	 PTR_ADDU a0, 8
	jr	ra
	 NOP
END(mem_zero_page)

/*
 * Copy a null terminated string from the user address space into
 * the kernel address space.
 *
 *	copyinstr(fromaddr, toaddr, maxlength, &lencopied)
 *		caddr_t fromaddr;
 *		caddr_t toaddr;
 *		u_int maxlength;
 *		u_int *lencopied;
 */
NON_LEAF(copyinstr, FRAMESZ(CF_SZ), ra)
	PTR_SUBU sp, sp, FRAMESZ(CF_SZ)
	.mask	0x80000000, (CF_RA_OFFS - FRAMESZ(CF_SZ))
	PTR_S	ra, CF_RA_OFFS(sp)
	blt	a0, zero, _copyerr	# make sure address is in user space
	 LI	v0, KT_COPYERR
	GET_CPU_INFO(t1, t0)
	PTR_L	t3, CI_CURPROCPADDR(t1)
	jal	copystr
	 sw	v0, PCB_ONFAULT(t3)

	PTR_L	ra, CF_RA_OFFS(sp)
	GET_CPU_INFO(t1, t0)
	PTR_L	t3, CI_CURPROCPADDR(t1)
	sw	zero, PCB_ONFAULT(t3)
	PTR_ADDU sp, sp, FRAMESZ(CF_SZ)
	j	ra
	 NOP
END(copyinstr)

/*
 * Copy a null terminated string from the kernel address space into
 * the user address space.
 *
 *	copyoutstr(fromaddr, toaddr, maxlength, &lencopied)
 *		caddr_t fromaddr;
 *		caddr_t toaddr;
 *		u_int maxlength;
 *		u_int *lencopied;
 */
NON_LEAF(copyoutstr, FRAMESZ(CF_SZ), ra)
	PTR_SUBU sp, sp, FRAMESZ(CF_SZ)
	.mask	0x80000000, (CF_RA_OFFS - FRAMESZ(CF_SZ))
	PTR_S	ra, CF_RA_OFFS(sp)
	blt	a1, zero, _copyerr	# make sure address is in user space
	 LI	v0, KT_COPYERR
	GET_CPU_INFO(t1, t0)
	PTR_L	t3, CI_CURPROCPADDR(t1)
	jal	copystr
	 sw	v0, PCB_ONFAULT(t3)

	PTR_L	ra, CF_RA_OFFS(sp)
	GET_CPU_INFO(t1, t0)
	PTR_L	t3, CI_CURPROCPADDR(t1)
	sw	zero, PCB_ONFAULT(t3)
	PTR_ADDU sp, sp, FRAMESZ(CF_SZ)
	j	ra
	 NOP
END(copyoutstr)

/*
 * Copy specified amount of data from user space into the kernel
 *	copyin(from, to, len)
 *		caddr_t *from;	(user source address)
 *		caddr_t *to;	(kernel destination address)
 *		unsigned len;
 */
NON_LEAF(copyin, FRAMESZ(CF_SZ), ra)
	PTR_SUBU sp, sp, FRAMESZ(CF_SZ)
	.mask	0x80000000, (CF_RA_OFFS - FRAMESZ(CF_SZ))
	PTR_S	ra, CF_RA_OFFS(sp)
	blt	a0, zero, _copyerr	# make sure address is in user space
	 li	v0, KT_COPYERR
	GET_CPU_INFO(t1, t0)
	PTR_L	t3, CI_CURPROCPADDR(t1)
	jal	bcopy
	 sw	v0, PCB_ONFAULT(t3)

	PTR_L	ra, CF_RA_OFFS(sp)
	GET_CPU_INFO(t1, t0)
	PTR_L	t3, CI_CURPROCPADDR(t1)
	sw	zero, PCB_ONFAULT(t3)
	PTR_ADDU sp, sp, FRAMESZ(CF_SZ)
	j	ra
	 move	v0, zero
END(copyin)

/*
 * Copy specified amount of data from kernel to the user space
 *	copyout(from, to, len)
 *		caddr_t *from;	(kernel source address)
 *		caddr_t *to;	(user destination address)
 *		unsigned len;
 */
NON_LEAF(copyout, FRAMESZ(CF_SZ), ra)
	PTR_SUBU sp, sp, FRAMESZ(CF_SZ)
	.mask	0x80000000, (CF_RA_OFFS - FRAMESZ(CF_SZ))
	PTR_S	ra, CF_RA_OFFS(sp)
	blt	a1, zero, _copyerr	# make sure address is in user space
	 li	v0, KT_COPYERR
	GET_CPU_INFO(t1, t0)
	PTR_L	t3, CI_CURPROCPADDR(t1)
	jal	bcopy
	 sw	v0, PCB_ONFAULT(t3)

	PTR_L	ra, CF_RA_OFFS(sp)
	GET_CPU_INFO(t1, t0)
	PTR_L	t3, CI_CURPROCPADDR(t1)
	sw	zero, PCB_ONFAULT(t3)
	PTR_ADDU sp, sp, FRAMESZ(CF_SZ)
	j	ra
	 move	v0, zero
END(copyout)

/*
 * Copy an aligned 32-bit word atomically from user space into the kernel
 *	copyin32(from, to)
 *		uint32_t *from;	(user source address)
 *		uint32_t *to;	(kernel destination address)
 */
NON_LEAF(copyin32, FRAMESZ(CF_SZ), ra)
	PTR_SUBU sp, sp, FRAMESZ(CF_SZ)
	.mask	0x80000000, (CF_RA_OFFS - FRAMESZ(CF_SZ))
	PTR_S	ra, CF_RA_OFFS(sp)
	blt	a0, zero, _copyerr	# make sure address is in user space
	 li	v0, KT_COPYERR
	GET_CPU_INFO(t1, t0)
	PTR_L	t3, CI_CURPROCPADDR(t1)
	sw	v0, PCB_ONFAULT(t3)

	lw	v1, 0(a0)
	sw	v1, 0(a1)

	sw	zero, PCB_ONFAULT(t3)
	PTR_ADDU sp, sp, FRAMESZ(CF_SZ)
	j	ra
	 move	v0, zero
END(copyin32)

_copyerr:
	PTR_L	ra, CF_RA_OFFS(sp)
	GET_CPU_INFO(t1, t0)
	PTR_L	t3, CI_CURPROCPADDR(t1)
	sw	zero, PCB_ONFAULT(t3)
	PTR_ADDU sp, sp, FRAMESZ(CF_SZ)
	j	ra
	 li	v0, EFAULT		# return error

/*
 *  kcopy is a wrapper around bcopy that catches bad memory references.
 */
NON_LEAF(kcopy, FRAMESZ(CF_SZ + REGSZ), ra)
	PTR_SUBU sp, sp, FRAMESZ(CF_SZ + REGSZ)
	.mask	0x80000000, (CF_RA_OFFS - FRAMESZ(CF_SZ + REGSZ))
	PTR_S	ra, CF_RA_OFFS + REGSZ(sp)
	GET_CPU_INFO(t1, t0)
	PTR_L	t3, CI_CURPROCPADDR(t1)
	lw	v1, PCB_ONFAULT(t3)
	li	v0, KT_KCOPYERR
	PTR_S	v1, CF_ARGSZ(sp)	# save old pcb_onfault
	jal	bcopy
	 sw	v0, PCB_ONFAULT(t3)

	PTR_L	v0, CF_ARGSZ(sp)
	GET_CPU_INFO(t1, t0)
	PTR_L	t3, CI_CURPROCPADDR(t1)
	PTR_L	ra, CF_RA_OFFS + REGSZ(sp)
	sw	v0, PCB_ONFAULT(t3)
	PTR_ADDU sp, sp, FRAMESZ(CF_SZ + REGSZ)
	j	ra
	 move	v0, zero
END(kcopy)

_kcopyerr:
	PTR_L	v0, CF_ARGSZ(sp)
	GET_CPU_INFO(t1, t0)
	PTR_L	t3, CI_CURPROCPADDR(t1)
	PTR_L	ra, CF_RA_OFFS + REGSZ(sp)
	sw	v0, PCB_ONFAULT(t3)
	PTR_ADDU sp, sp, FRAMESZ(CF_SZ + REGSZ)
	j	ra
	 li	v0, EFAULT		# return error

/*
 * Guarded ``memory'' access routines
 * int guarded_read_1(paddr_t address, uint8_t *dest);
 * int guarded_read_2(paddr_t address, uint16_t *dest);
 * int guarded_read_4(paddr_t address, uint32_t *dest);
 * int guarded_write_4(paddr_t address, uint32_t src);
 */

LEAF(guarded_read_1, 0)
	GET_CPU_INFO(t1, t0)
	PTR_L	t3, CI_CURPROCPADDR(t1)

#ifndef CPU_R8000
	li	a3, SR_BOOT_EXC_VEC
	MFC0	a2, COP_0_STATUS_REG
	or	a4, a2, a3
	xor	a4, a4, a3
#endif

	li	v0, KT_GUARDERR
	lw	v1, PCB_ONFAULT(t3)
	sw	v0, PCB_ONFAULT(t3)

#ifndef CPU_R8000
	MTC0	a4, COP_0_STATUS_REG
	MTC0_HAZARD
#endif

	lb	v0, 0(a0)
	sb	v0, 0(a1)

#ifndef CPU_R8000
	MTC0	a2, COP_0_STATUS_REG
	MTC0_HAZARD
#endif

	sw	v1, PCB_ONFAULT(t3)
	j	ra
	 move	v0, zero
END(guarded_read_1)

LEAF(guarded_read_2, 0)
	GET_CPU_INFO(t1, t0)
	PTR_L	t3, CI_CURPROCPADDR(t1)

#ifndef CPU_R8000
	li	a3, SR_BOOT_EXC_VEC
	MFC0	a2, COP_0_STATUS_REG
	or	a4, a2, a3
	xor	a4, a4, a3
#endif

	li	v0, KT_GUARDERR
	lw	v1, PCB_ONFAULT(t3)
	sw	v0, PCB_ONFAULT(t3)

#ifndef CPU_R8000
	MTC0	a4, COP_0_STATUS_REG
	MTC0_HAZARD
#endif

	lh	v0, 0(a0)
	sh	v0, 0(a1)

#ifndef CPU_R8000
	MTC0	a2, COP_0_STATUS_REG
	MTC0_HAZARD
#endif

	sw	v1, PCB_ONFAULT(t3)
	j	ra
	move	v0, zero
END(guarded_read_2)

LEAF(guarded_read_4, 0)
	GET_CPU_INFO(t1, t0)
	PTR_L	t3, CI_CURPROCPADDR(t1)

#ifndef CPU_R8000
	li	a3, SR_BOOT_EXC_VEC
	MFC0	a2, COP_0_STATUS_REG
	or	a4, a2, a3
	xor	a4, a4, a3
#endif

	li	v0, KT_GUARDERR
	lw	v1, PCB_ONFAULT(t3)
	sw	v0, PCB_ONFAULT(t3)

#ifndef CPU_R8000
	MTC0	a4, COP_0_STATUS_REG
	MTC0_HAZARD
#endif

	lw	v0, 0(a0)
	sw	v0, 0(a1)

#ifndef CPU_R8000
	MTC0	a2, COP_0_STATUS_REG
	MTC0_HAZARD
#endif

	sw	v1, PCB_ONFAULT(t3)
	j	ra
	move	v0, zero
END(guarded_read_4)

LEAF(guarded_write_4, 0)
	GET_CPU_INFO(t1, t0)
	PTR_L	t3, CI_CURPROCPADDR(t1)

#ifndef CPU_R8000
	li	a3, SR_BOOT_EXC_VEC
	MFC0	a2, COP_0_STATUS_REG
	or	a4, a2, a3
	xor	a4, a4, a3
#endif

	li	v0, KT_GUARDERR
	lw	v1, PCB_ONFAULT(t3)
	sw	v0, PCB_ONFAULT(t3)

#ifndef CPU_R8000
	MTC0	a4, COP_0_STATUS_REG
	MTC0_HAZARD
#endif

	sw	a1, 0(a0)

#ifndef CPU_R8000
	MTC0	a2, COP_0_STATUS_REG
	MTC0_HAZARD
#endif

	sw	v1, PCB_ONFAULT(t3)
	j	ra
	move	v0, zero
END(guarded_write_4)

_guarderr:
#ifndef CPU_R8000
	MTC0	a2, COP_0_STATUS_REG
	MTC0_HAZARD
#endif

	sw	v1, PCB_ONFAULT(t3)
	j	ra
	li	v0, EFAULT		# return error
@


1.26
log
@Place a cpu-dependent trap/illegal instruction over the remainder of the
sigtramp page, so that it will generate a nice kernel fault if touched.
While here, move most of the sigtramps to the .rodata segment, because
they are not executed in the kernel.
Also some preparation for sliding the actual sigtramp forward (will need
some gdb changes)
ok mlarkin kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: lcore_access.S,v 1.25 2016/05/10 18:39:47 deraadt Exp $ */
d257 25
@


1.25
log
@SROP mitigation.  sendsig() stores a (per-process ^ &sigcontext) cookie
inside the sigcontext.  sigreturn(2) checks syscall entry was from the
exact PC addr in the (per-process ASLR) sigtramp, verifies the cookie,
and clears it to prevent sigcontext reuse.
not yet tested on landisk, sparc, *88k, socppc.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: lcore_access.S,v 1.24 2012/10/03 11:18:23 miod Exp $ */
d85 12
@


1.24
log
@Split ever-growing mips <machine/cpu.h> into what 99% of the kernel needs,
which will remain in <machine/cpu.h>, and a new mips_cpu.h containing only the
goriest md details, which are only of interest to a handful set of files; this
is similar in spirit to what alpha does, but here <machine/cpu.h> does not
include the new file.
@
text
@d1 1
a1 1
/*	$OpenBSD: lcore_access.S,v 1.23 2012/09/29 21:37:03 miod Exp $ */
d80 2
@


1.23
log
@Basic R8000 processor support. R8000 processors require MMU-specific code,
exception-specific code, clock-specific code, and L1 cache-specific code. L2
cache is per-design, of which only two exist: SGI Power Indigo2 (IP26) and SGI
Power Challenge (IP21) and are not covered by this commit.

R8000 processors also are 64-bit only processors with 64-bit coprocessor 0
registers, and lack so-called ``compatibility'' memory spaces allowing 32-bit
code to run with sign-extended addresses and registers.

The intrusive changes are covered by #ifdef CPU_R8000 stanzas. However,
trap() is split into a high-level wrapper and a new function, itsa(),
responsible for the actual trap servicing (which name couldn't be helped
because I'm an incorrigible punster). While an R8000 exception may cause
(via trap() ) multiple exceptions to be serviced, non-R8000 processors will
always service one exception in trap(), but they are nevertheless affected
by this code split.
@
text
@d1 1
a1 1
/*	$OpenBSD: lcore_access.S,v 1.22 2012/09/29 19:02:26 miod Exp $ */
d34 1
@


1.22
log
@Introduce assembly macros for specific processor hazards: tlb update, status
register update, status register update causing a change to the interrupt
enable flag, and a few other arcane ones. <mips64/asm.h> will provide
(supposedly sane) defaults, and <machine/asm.h> may override these with
better tuned versions.

Use these macros instead of random strings of nop in the various .S files
requiring hazard workarounds.
@
text
@d1 1
a1 1
/*	$OpenBSD: lcore_access.S,v 1.21 2012/04/16 22:23:04 miod Exp $ */
d299 1
d304 1
d310 1
d313 1
d318 1
d321 2
a322 1
	
d332 1
d337 1
d343 1
d346 1
d350 2
a351 1
	
d354 2
a355 1
	
d365 1
d370 1
d376 1
d379 1
d383 2
a384 1
	
d387 2
a388 1
	
d398 1
d403 1
d409 1
d412 1
d415 2
a416 1
	
d419 2
a420 1
	
d427 1
d430 2
a431 1
	
@


1.21
log
@Move proc0 and trap handler setup before consinit(), but still wait for the
initial setup to be complete before switching to our trap handlers.

However, change guarded_{read,write}_* to clear BEV in the coprocessor 0
status register, and restore it afterwards, to use our fault handlers within
these functions. This makes these functions usable from consinit().
@
text
@d1 1
a1 1
/*	$OpenBSD: lcore_access.S,v 1.20 2012/03/28 20:44:23 miod Exp $ */
d101 1
a101 1
	PTR_ADDU a1, a1, 1
d103 1
a103 1
	nop
d107 1
a107 1
	PTR_SUBU a2, t2, a2		# Compute length copied
d111 1
a111 1
	nop
d119 1
a119 1
	LI	v0, NBPG
d124 1
a124 1
	PTR_ADDU a0, 8
d126 1
a126 1
	nop
d144 1
a144 1
	LI	v0, KT_COPYERR
d148 1
a148 1
	sw	v0, PCB_ONFAULT(t3)
d156 1
a156 1
	nop
d174 1
a174 1
	LI	v0, KT_COPYERR
d178 1
a178 1
	sw	v0, PCB_ONFAULT(t3)
d186 1
a186 1
	nop
d201 1
a201 1
	li	v0, KT_COPYERR
d205 1
a205 1
	sw	v0, PCB_ONFAULT(t3)
d213 1
a213 1
	move	v0, zero
d228 1
a228 1
	li	v0, KT_COPYERR
d232 1
a232 1
	sw	v0, PCB_ONFAULT(t3)
d240 1
a240 1
	move	v0, zero
d250 1
a250 1
	li	v0, EFAULT		# return error
d265 1
a265 1
	sw	v0, PCB_ONFAULT(t3)
d274 1
a274 1
	move	v0, zero
d285 1
a285 1
	li	v0, EFAULT		# return error
d300 1
a300 1
	mfc0	a2, COP_0_STATUS_REG
d308 2
a309 2
	mtc0	a4, COP_0_STATUS_REG
	NOP
d314 2
a315 2
	mtc0	a2, COP_0_STATUS_REG
	NOP
d319 1
a319 1
	move	v0, zero
d327 1
a327 1
	mfc0	a2, COP_0_STATUS_REG
d335 2
a336 2
	mtc0	a4, COP_0_STATUS_REG
	NOP
d341 2
a342 2
	mtc0	a2, COP_0_STATUS_REG
	NOP
d354 1
a354 1
	mfc0	a2, COP_0_STATUS_REG
d362 2
a363 2
	mtc0	a4, COP_0_STATUS_REG
	NOP
d368 2
a369 2
	mtc0	a2, COP_0_STATUS_REG
	NOP
d381 1
a381 1
	mfc0	a2, COP_0_STATUS_REG
d389 2
a390 2
	mtc0	a4, COP_0_STATUS_REG
	NOP
d394 2
a395 2
	mtc0	a2, COP_0_STATUS_REG
	NOP
d403 2
a404 2
	mtc0	a2, COP_0_STATUS_REG
	NOP
@


1.20
log
@Work in progress support for the SGI Indigo, Indigo 2 and Indy systems
(IP20, IP22, IP24) in 64-bit mode, adapated from NetBSD. Currently limited
to headless operation, input and video drivers will get ported soon.

Should work on all R4000, R4440 and R5000 based systems. L2 cache on R5000SC
Indy not supported yet (coming soon), R4600 not supported yet either (coming
soon as well).

Tested to boot multiuser on: Indigo2 R4000SC, Indy R4000PC, Indy R4000SC,
Indy R5000SC, Indigo2 R4400SC. There are still glitches in the Ethernet driver
which are being looked at.

Expansion support is limited to the GIO E++ board; GIO boards with PCI-GIO
bridges not ported yet due to the lack of hardware, and this kind of driver
does not port blindly.

Most of this work comes from NetBSD, polishing and integration work, as well
as putting as many ``R4x00 in 64-bit mode'' erratas as necessary, by yours
truly.

More work is coming, as well as trying to get some easy way to boot install
kernels (as older PROM can only boot ECOFF binaries, which won't do for the
kernel).
@
text
@d1 1
a1 1
/*	$OpenBSD: lcore_access.S,v 1.19 2010/01/31 19:39:04 miod Exp $ */
d298 6
d308 3
d313 3
d325 6
d335 3
d341 3
d352 6
d362 3
d368 3
d379 6
d389 3
d394 3
d403 3
@


1.19
log
@Remove !__LP64__ bits and __LP64__ tests.
@
text
@d1 1
a1 1
/*	$OpenBSD: lcore_access.S,v 1.18 2009/09/30 06:22:00 syuu Exp $ */
d289 2
d294 30
@


1.18
log
@curproc, curprocpaddr moved into cpu_info
OK miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lcore_access.S,v 1.17 2009/05/22 20:37:53 miod Exp $ */
a82 10
/* Mips o32 ABI sigcode. 32 bit pointers. */
	.globl	sigcode_o32
sigcode_o32:
	addu	a0, sp, 16		# address of sigcontext
	li	v0, SYS_sigreturn	# sigreturn(scp)
	syscall
	break	0			# just in case sigreturn fails
	.globl	esigcode_o32
esigcode_o32:

a112 38

#ifndef __LP64__
/*
 *  Read 64 bits from bus in non LP64 mode.
 *  XXX ints should be disabled!
 */
LEAF(lp32_read8, 0)
#if defined(__MIPSEB__)
	ld	v1, 0(a0)
	jr	ra
	dsrl	v0, v1, 32
#else
	ld	v0, 0(a0)
	jr	ra
	dsrl	v1, v0, 32
#endif
END(lp32_read8)

/*
 *  Write 64 bits to bus in non LP64 mode.
 *  XXX ints should be disabled!
 */
LEAF(lp32_write8, 0)
#if defined(__MIPSEB__)
	dsll	a2, 32
	dsll	a3, 32
	dsrl	a3, 32
	or	a2, a3
#else
	dsll	a3, 32
	dsll	a2, 32
	dsrl	a2, 32
	or	a3, a2
#endif
	jr	ra
	sd	a2, 0(a0)
END(lp32_write8)
#endif
@


1.17
log
@Drop almost unused <machine/psl.h> on sgi; move USERMODE() definition from
there to trap.c which is its only user. This also cleans up multiple
inclusion of <machine/cpu.h> (because <machine/psl.h> includes it) in many
places.
@
text
@d1 1
a1 1
/*	$OpenBSD: lcore_access.S,v 1.16 2009/02/15 14:13:33 jsing Exp $ */
d193 2
a194 1
	PTR_L	t3, curprocpaddr
d199 2
a200 1
	PTR_L	t3, curprocpaddr
d223 2
a224 1
	PTR_L	t3, curprocpaddr
d229 2
a230 1
	PTR_L	t3, curprocpaddr
d250 2
a251 1
	PTR_L	t3, curprocpaddr
d256 2
a257 1
	PTR_L	t3, curprocpaddr
d277 2
a278 1
	PTR_L	t3, curprocpaddr
d283 2
a284 1
	PTR_L	t3, curprocpaddr
d293 2
a294 1
	PTR_L	t3, curprocpaddr
d307 2
a308 1
	PTR_L	t3, curprocpaddr
d316 2
a317 1
	PTR_L	t3, curprocpaddr
d327 2
a328 1
	PTR_L	t3, curprocpaddr
d342 2
a343 1
	PTR_L	t3, curprocpaddr
d357 2
a358 1
	PTR_L	t3, curprocpaddr
@


1.16
log
@copystr(), copyinstr() and copyoutstr() should all return ENAMETOOLONG if
string length exceeds maxlength.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lcore_access.S,v 1.14 2008/04/07 22:37:18 miod Exp $ */
a31 1
#include <machine/psl.h>
@


1.15
log
@Remove fillw(). Bonus points if you do not remember what it was used for.
@
text
@d105 1
a108 1
	beq	t0, zero, 2f
d111 2
d114 2
a115 1
	PTR_ADDU a1, a1, 1
d118 1
a118 1
	PTR_SUBU a2, t2, a2		# compute length copied
d122 1
a122 1
	move	v0, zero
d193 1
a193 1
	li	v0, KT_COPYERR
d203 1
a203 1
	move	v0, zero
d221 1
a221 1
	li	v0, KT_COPYERR
d231 1
a231 1
	move	v0, zero
@


1.14
log
@Add ``guarded'' word read and write routines, to be used by machine-dependent
code soon. Similar to what ddb does, but does not need ddb to be compiled in.
@
text
@d1 1
a1 1
/*	$OpenBSD: lcore_access.S,v 1.13 2008/02/20 21:34:19 miod Exp $ */
a158 14

/*
 * fillw(pat, addr, count)
 */
LEAF(fillw, 0)
1:
	PTR_ADDU a2, a2, -1
	sh	a0, 0(a1)
	bne	a2,zero, 1b
	PTR_ADDU a1, a1, 2

	jr	ra
	nop
END(fillw)
@


1.13
log
@Oops, correctly recover from kcopy() faults, since the stack frame is
different now.
@
text
@d1 1
a1 1
/*	$OpenBSD: lcore_access.S,v 1.12 2008/02/20 19:13:38 miod Exp $ */
d67 1
d332 38
@


1.12
log
@More dead includes and functions noone will mourn.
@
text
@d1 1
a1 1
/*	$OpenBSD: lcore_access.S,v 1.11 2008/02/20 18:35:43 miod Exp $ */
d61 1
a61 1
	PTR_VAL	_copyerr
d324 9
@


1.11
log
@Preserve pcb_onfault within kcopy(), as expected and as all other platforms do.
@
text
@d1 1
a1 1
/*	$OpenBSD: lcore_access.S,v 1.10 2007/05/20 14:34:23 miod Exp $ */
a186 113

/*
 *	Block I/O routines mainly used by I/O drivers.
 *
 *	Args as:	a0 = port
 *			a1 = memory address
 *			a2 = count
 */
LEAF(insb, 0)
	beq	a2, zero, 2f
	PTR_ADDU a2, a1
1:
	lbu	v0, 0(a0)
	PTR_ADDU a1, 1
	bne	a1, a2, 1b
	sb	v0, -1(a1)
2:
	jr	ra
	nop
END(insb)

LEAF(insw, 0)
	beq	a2, zero, 2f
	PTR_ADDU a2, a2
	PTR_ADDU a2, a1
1:
	lhu	v0, 0(a0)
	PTR_ADDU a1, 2
	bne	a1, a2, 1b
	sh	v0, -2(a1)
2:
	jr	ra
	nop
END(insw)

LEAF(insl, 0)
	beq	a2, zero, 2f
	PTR_SLL	a2, 2
	PTR_ADDU a2, a1
1:
	lw	v0, 0(a0)
	PTR_ADDU a1, 4
	bne	a1, a2, 1b
	sw	v0, -4(a1)
2:
	jr	ra
	nop
END(insl)

LEAF(outsb, 0)
	beq	a2, zero, 2f
	PTR_ADDU a2, a1
1:
	lbu	v0, 0(a1)
	PTR_ADDU a1, 1
	bne	a1, a2, 1b
	sb	v0, 0(a0)
2:
	jr	ra
	nop
END(outsb)

LEAF(outsw, 0)
	beq	a2, zero, 2f
	PTR_ADDU a2, a2
	LI	v0, 1
	and	v0, a1
	bne	v0, zero, 3f		# arghh, unaligned.
	PTR_ADDU a2, a1
1:
	lhu	v0, 0(a1)
	PTR_ADDU a1, 2
	bne	a1, a2, 1b
	sh	v0, 0(a0)
2:
	jr	ra
	nop
3:
	LWHI	v0, 0(a1)
	LWLO	v0, 3(a1)
	PTR_ADDU a1, 2
	bne	a1, a2, 3b
	sh	v0, 0(a0)

	jr	ra
	nop
END(outsw)

LEAF(outsl, 0)
	beq	a2, zero, 2f
	PTR_SLL	a2, 2
	LI	v0, 3
	and	v0, a1
	bne	v0, zero, 3f		# arghh, unaligned.
	PTR_ADDU a2, a1
1:
	lw	v0, 0(a1)
	PTR_ADDU a1, 4
	bne	a1, a2, 1b
	sw	v0, 0(a0)
2:
	jr	ra
	nop
3:
	LWHI	v0, 0(a1)
	LWLO	v0, 3(a1)
	PTR_ADDU a1, 4
	bne	a1, a2, 3b
	sw	v0, 0(a0)

	jr	ra
	nop
END(outsl)
@


1.10
log
@Remove unused badaddr().
@
text
@d1 1
a1 1
/*	$OpenBSD: lcore_access.S,v 1.9 2005/12/20 07:06:26 miod Exp $ */
d418 6
a423 4
NON_LEAF(kcopy, FRAMESZ(CF_SZ), ra)
	PTR_SUBU sp, sp, FRAMESZ(CF_SZ)
	.mask	0x80000000, (CF_RA_OFFS - FRAMESZ(CF_SZ))
	PTR_S	ra, CF_RA_OFFS(sp)
d425 1
a425 1
	PTR_L	t3, curprocpaddr
d429 1
a429 1
	PTR_L	ra, CF_RA_OFFS(sp)
d431 3
a433 2
	sw	zero, PCB_ONFAULT(t3)
	PTR_ADDU sp, sp, FRAMESZ(CF_SZ)
@


1.9
log
@Since we are allowed to rely on the fact that the pcb is the first element
of struct user, use syntactic sugar in genassym.cf and use PCB_xxx defines
instead of U_PCB_xxx, like all other platforms do; no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: lcore_access.S,v 1.8 2004/10/20 12:49:15 pefo Exp $ */
a59 1
	PTR_VAL	baderr
a67 34

/*
 * See if access to addr with a len type instruction causes a machine check.
 * len is length of access (1=byte, 2=short, 4=long)
 *
 * badaddr(addr, len)
 *	char *addr;
 *	int len;
 */
LEAF(badaddr, 0)
	li	v0, KT_BADERR
	PTR_L	t3, curprocpaddr
	bne	a1, 1, 2f
	sw	v0, PCB_ONFAULT(t3)
	lbu	v0, (a0)		# don't put in bd-slot!
	b	5f
	nop
2:
	bne	a1, 2, 4f
	nop
	lhu	v0, (a0)		# don't put in bd-slot!
	b	5f
	nop
4:
	lw	v0, (a0)
5:
	sync
	sw	zero, PCB_ONFAULT(t3)
	j	ra
	move	v0, zero		# made it w/o errors
baderr:
	j	ra
	li	v0, 1			# trap sends us here
END(badaddr)
@


1.8
log
@Fix some 64 bit address problems.
Some function names made more unique.
Other changes for the upcoming Origin 200 support.
@
text
@d1 1
a1 1
/*	$OpenBSD: lcore_access.S,v 1.7 2004/09/27 19:16:06 pefo Exp $ */
d82 1
a82 1
	sw	v0, U_PCB_ONFAULT(t3)
d96 1
a96 1
	sw	zero, U_PCB_ONFAULT(t3)
d354 1
a354 1
	sw	v0, U_PCB_ONFAULT(t3)
d358 1
a358 1
	sw	zero, U_PCB_ONFAULT(t3)
d382 1
a382 1
	sw	v0, U_PCB_ONFAULT(t3)
d386 1
a386 1
	sw	zero, U_PCB_ONFAULT(t3)
d407 1
a407 1
	sw	v0, U_PCB_ONFAULT(t3)
d411 1
a411 1
	sw	zero, U_PCB_ONFAULT(t3)
d432 1
a432 1
	sw	v0, U_PCB_ONFAULT(t3)
d436 1
a436 1
	sw	zero, U_PCB_ONFAULT(t3)
d445 1
a445 1
	sw	zero, U_PCB_ONFAULT(t3)
d460 1
a460 1
	sw	v0, U_PCB_ONFAULT(t3)
d464 1
a464 1
	sw	zero, U_PCB_ONFAULT(t3)
@


1.7
log
@move ITLBNOPFIX to asm.h and make it conditional
@
text
@d1 1
a1 1
/*	$OpenBSD: lcore_access.S,v 1.6 2004/09/10 08:58:27 pefo Exp $ */
d215 1
a215 1
	dsubu	v0, 8
d218 1
a218 1
	daddu	a0, 8
@


1.6
log
@Fix LEAF usage adding new extra arg. spotted by miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: lcore_access.S,v 1.5 2004/09/09 22:11:38 pefo Exp $ */
a43 2

#define	ITLBNOPFIX	nop;nop;nop;nop;nop;nop;nop;nop;nop;nop;
@


1.5
log
@Kernel moves to 64 bit. A few more tweaks when binutils is updated.
@
text
@d1 1
a1 1
/*	$OpenBSD: lcore_access.S,v 1.4 2004/08/10 20:15:47 deraadt Exp $ */
d80 1
a80 1
LEAF(badaddr)
d139 1
a139 1
LEAF(copystr)
d163 1
a163 1
LEAF(lp32_read8)
d179 1
a179 1
LEAF(lp32_write8)
d199 1
a199 1
LEAF(fillw)
d214 1
a214 1
LEAF(mem_zero_page)
d232 1
a232 1
LEAF(insb)
d245 1
a245 1
LEAF(insw)
d259 1
a259 1
LEAF(insl)
d273 1
a273 1
LEAF(outsb)
d286 1
a286 1
LEAF(outsw)
d312 1
a312 1
LEAF(outsl)
@


1.4
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: lcore_access.S,v 1.3 2004/08/09 14:57:26 pefo Exp $ */
d63 2
a64 2
	PTR_VAL	copyerr
	PTR_VAL	copyerr
d158 1
d161 1
d177 1
d194 1
d352 1
a352 1
	blt	a0, zero, copyerr	# make sure address is in user space
d380 1
a380 1
	blt	a1, zero, copyerr	# make sure address is in user space
d405 1
a405 1
	blt	a0, zero, copyerr	# make sure address is in user space
d430 1
a430 1
	blt	a1, zero, copyerr	# make sure address is in user space
d444 1
a444 1
LEAF(copyerr)
a450 1
END(copyerr)
@


1.3
log
@Big cleanup. Removed some unused obsolete stuff and fixed copyrights
on some files. Arcbios support is now in, thus detects memorysize and cpu
clock frequency.
@
text
@d1 1
a1 1
/*	$OpenBSD: lcore_access.S,v 1.2 2004/08/08 14:21:27 pefo Exp $ */
d5 1
a5 1
 * 
@


1.2
log
@Various fixes and cleanups from miod@@, tested and OK.
@
text
@d1 1
a1 1
/*	$OpenBSD: lcore_access.S,v 1.1 2004/08/06 20:56:03 pefo Exp $ */
a13 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Opsycon AB, Sweden.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.1
log
@initial mips64
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a69 2
	PTR_VAL	fswberr
	PTR_VAL	fswintrberr
a472 107

/*
 * {fu,su},{byte,sword,word}, fetch or store a byte, short or word to
 * user space.
 */
LEAF(fuword)
	blt	a0, zero, fswberr	# make sure address is in user space
	li	v0, KT_FSWBERR
	PTR_L	t3, curprocpaddr
	sw	v0, U_PCB_ONFAULT(t3)
	lw	v0, 0(a0)		# fetch word
	j	ra
	sw	zero, U_PCB_ONFAULT(t3)
END(fuword)

LEAF(fusword)
	blt	a0, zero, fswberr	# make sure address is in user space
	li	v0, KT_FSWBERR
	PTR_L	t3, curprocpaddr
	sw	v0, U_PCB_ONFAULT(t3)
	lhu	v0, 0(a0)		# fetch short
	j	ra
	sw	zero, U_PCB_ONFAULT(t3)
END(fusword)

LEAF(fubyte)
	blt	a0, zero, fswberr	# make sure address is in user space
	li	v0, KT_FSWBERR
	PTR_L	t3, curprocpaddr
	sw	v0, U_PCB_ONFAULT(t3)
	lbu	v0, 0(a0)		# fetch byte
	j	ra
	sw	zero, U_PCB_ONFAULT(t3)
END(fubyte)

LEAF(suword)
	blt	a0, zero, fswberr	# make sure address is in user space
	li	v0, KT_FSWBERR
	PTR_L	t3, curprocpaddr
	sw	v0, U_PCB_ONFAULT(t3)
	sw	a1, 0(a0)		# store word
	sw	zero, U_PCB_ONFAULT(t3)
	j	ra
	move	v0, zero
END(suword)

/*
 * Will have to flush the instruction cache if byte merging is done in hardware.
 */
LEAF(susword)
	blt	a0, zero, fswberr	# make sure address is in user space
	li	v0, KT_FSWBERR
	PTR_L	t3, curprocpaddr
	sw	v0, U_PCB_ONFAULT(t3)
	sh	a1, 0(a0)		# store short
	sw	zero, U_PCB_ONFAULT(t3)
	j	ra
	move	v0, zero
END(susword)

LEAF(subyte)
	blt	a0, zero, fswberr	# make sure address is in user space
	li	v0, KT_FSWBERR
	PTR_L	t3, curprocpaddr
	sw	v0, U_PCB_ONFAULT(t3)
	sb	a1, 0(a0)		# store byte
	sw	zero, U_PCB_ONFAULT(t3)
	j	ra
	move	v0, zero
END(subyte)

LEAF(fswberr)
	j	ra
	li	v0, -1
END(fswberr)

/*
 * fuswintr and suswintr are just like fusword and susword except that if
 * the page is not in memory or would cause a trap, then we return an error.
 * The important thing is to prevent sleep() and switch().
 */
LEAF(fuswintr)
	blt	a0, zero, fswintrberr	# make sure address is in user space
	li	v0, KT_FSWINTRBERR
	PTR_L	t3, curprocpaddr
	sw	v0, U_PCB_ONFAULT(t3)
	lhu	v0, 0(a0)		# fetch short
	sw	zero, U_PCB_ONFAULT(t3)
	j	ra
	move	v0, zero
END(fuswintr)

LEAF(suswintr)
	blt	a0, zero, fswintrberr	# make sure address is in user space
	li	v0, KT_FSWINTRBERR
	PTR_L	t3, curprocpaddr
	sw	v0, U_PCB_ONFAULT(t3)
	sh	a1, 0(a0)		# store short
	sw	zero, U_PCB_ONFAULT(t3)
	j	ra
	move	v0, zero
END(suswintr)

LEAF(fswintrberr)
	j	ra
	li	v0, -1
END(fswintrberr)
@

