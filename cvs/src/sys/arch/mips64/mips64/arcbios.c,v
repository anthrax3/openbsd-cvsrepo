head	1.35;
access;
symbols
	OPENBSD_6_1:1.35.0.12
	OPENBSD_6_1_BASE:1.35
	OPENBSD_6_0:1.35.0.10
	OPENBSD_6_0_BASE:1.35
	OPENBSD_5_9:1.35.0.6
	OPENBSD_5_9_BASE:1.35
	OPENBSD_5_8:1.35.0.8
	OPENBSD_5_8_BASE:1.35
	OPENBSD_5_7:1.35.0.2
	OPENBSD_5_7_BASE:1.35
	OPENBSD_5_6:1.35.0.4
	OPENBSD_5_6_BASE:1.35
	OPENBSD_5_5:1.34.0.4
	OPENBSD_5_5_BASE:1.34
	OPENBSD_5_4:1.33.0.4
	OPENBSD_5_4_BASE:1.33
	OPENBSD_5_3:1.33.0.2
	OPENBSD_5_3_BASE:1.33
	OPENBSD_5_2:1.32.0.2
	OPENBSD_5_2_BASE:1.32
	OPENBSD_5_1_BASE:1.30
	OPENBSD_5_1:1.30.0.4
	OPENBSD_5_0:1.30.0.2
	OPENBSD_5_0_BASE:1.30
	OPENBSD_4_9:1.29.0.6
	OPENBSD_4_9_BASE:1.29
	OPENBSD_4_8:1.29.0.4
	OPENBSD_4_8_BASE:1.29
	OPENBSD_4_7:1.29.0.2
	OPENBSD_4_7_BASE:1.29
	OPENBSD_4_6:1.21.0.4
	OPENBSD_4_6_BASE:1.21
	OPENBSD_4_5:1.15.0.2
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.14.0.2
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.13.0.2
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.9.0.2
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.8.0.4
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.2
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.7.0.6
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.4
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.2
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.6.0.2
	OPENBSD_3_6_BASE:1.6;
locks; strict;
comment	@ * @;


1.35
date	2014.03.29.18.09.30;	author guenther;	state Exp;
branches;
next	1.34;

1.34
date	2014.02.08.22.13.45;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2012.09.29.21.39.30;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2012.03.28.20.44.23;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2012.03.24.20.11.28;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2011.05.30.22.25.21;	author oga;	state Exp;
branches;
next	1.29;

1.29
date	2010.03.03.12.25.09;	author jsing;	state Exp;
branches;
next	1.28;

1.28
date	2009.12.07.19.39.57;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2009.12.07.18.56.29;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2009.12.07.18.51.24;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2009.11.19.06.06.51;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2009.11.07.18.56.54;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2009.11.07.14.49.01;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2009.07.15.20.34.57;	author martynas;	state Exp;
branches;
next	1.21;

1.21
date	2009.05.16.16.40.31;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2009.05.15.22.56.08;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2009.05.09.18.08.59;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2009.05.08.18.34.37;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2009.05.06.20.07.10;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2009.04.19.12.52.33;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2008.12.03.15.43.17;	author sthen;	state Exp;
branches;
next	1.14;

1.14
date	2008.04.07.22.40.58;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2008.02.18.19.48.36;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2008.02.18.19.43.28;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2007.12.14.10.13.17;	author jsing;	state Exp;
branches;
next	1.10;

1.10
date	2007.10.18.04.32.25;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2007.04.26.17.02.40;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2006.03.09.23.06.20;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2004.10.20.12.49.15;	author pefo;	state Exp;
branches;
next	1.6;

1.6
date	2004.09.09.22.11.38;	author pefo;	state Exp;
branches;
next	1.5;

1.5
date	2004.08.15.12.08.24;	author pefo;	state Exp;
branches;
next	1.4;

1.4
date	2004.08.15.10.36.17;	author pefo;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.10.20.15.47;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2004.08.09.14.57.26;	author pefo;	state Exp;
branches;
next	1.1;

1.1
date	2004.08.08.21.51.36;	author pefo;	state Exp;
branches;
next	;


desc
@@


1.35
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@/*	$OpenBSD: arcbios.c,v 1.34 2014/02/08 22:13:45 miod Exp $	*/
/*-
 * Copyright (c) 1996 M. Warner Losh.  All rights reserved.
 * Copyright (c) 1996-2004 Opsycon AB.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>

#include <machine/autoconf.h>
#include <machine/cpu.h>
#include <machine/memconf.h>
#include <machine/vmparam.h>

#include <mips64/arcbios.h>
#include <mips64/archtype.h>

#include <uvm/uvm_extern.h>

#ifdef TGT_ORIGIN
#include <machine/mnode.h>
#endif

int bios_is_32bit;
void	*bios_base;

/*
 * If we cannot get the onboard Ethernet address to override this bogus
 * value, ether_ifattach() will pick a valid address.
 */
char bios_enaddr[20] = "ff:ff:ff:ff:ff:ff";

int bios_consrate;			/* Serial console speed. */
char bios_console[30];			/* Primary console. */
char bios_graphics[6];			/* Graphics state. */
char bios_keyboard[6];			/* Keyboard layout. */

void (*bios_halt)(void);
void (*bios_powerdown)(void);
void (*bios_restart)(void);
void (*bios_reboot)(void);
void (*bios_eim)(void);

extern int	physmem;		/* Total physical memory size */
extern int	rsvdmem;		/* Total reserved memory size */

void bios_configure_memory(void);
int bios_get_system_type(void);

arc_dsp_stat_t	displayinfo;		/* Save area for display status info. */

static struct systypes {
	char *sys_vend;		/* Vendor ID if name is ambiguous */
	char *sys_name;		/* May be left NULL if name is sufficient */
	int  sys_type;
} sys_types[] = {
#if 0
    { NULL,		"PICA-61",			ACER_PICA_61 },
    { NULL,		"NEC-R94",			ACER_PICA_61 },
    { NULL,		"DESKTECH-TYNE",		DESKSTATION_TYNE },
    { NULL,		"DESKTECH-ARCStation I",	DESKSTATION_RPC44 },
    { NULL,		"Microsoft-Jazz",		MAGNUM },
    { NULL,		"RM200PCI",			SNI_RM200 },
#endif
    { NULL,		"SGI-IP17",			SGI_IP17 },
    { NULL,		"SGI-IP19",			SGI_IP19 },
    { NULL,		"SGI-IP20",			SGI_IP20 },
    { NULL,		"SGI-IP21",			SGI_IP21 },
    { NULL,		"SGI-IP22",			SGI_IP22 },
    { NULL,		"SGI-IP25",			SGI_IP25 },
    { NULL,		"SGI-IP26",			SGI_IP26 },
    { NULL,		"SGI-IP28",			SGI_IP28 },
    { NULL,		"SGI-IP30",			SGI_OCTANE },
    { NULL,		"SGI-IP32",			SGI_O2 }
};

#define KNOWNSYSTEMS (sizeof(sys_types) / sizeof(struct systypes))

/*
 *	ARC Bios trampoline code.
 */

#define ARC_Call(Name,Offset)	\
__asm__("\n"			\
"	.text\n"		\
"	.ent	" #Name "\n"	\
"	.align	3\n"		\
"	.set	noreorder\n"	\
"	.globl	" #Name "\n"	\
#Name":\n"			\
"	lw	$3, bios_is_32bit\n"\
"	ld	$2, bios_base\n"\
"	beqz	$3, 1f\n"	\
"	 nop\n"			\
"	lw	$3, 0x20($2)\n"	\
"       lw      $2," #Offset "($3)\n"\
"	jr	$2\n"		\
"	 nop\n"			\
"1:\n"				\
"	ld	$3, 2*0x20($2)\n"\
"	ld	$2, 2*" #Offset "($3)\n"\
"	jr	$2\n"		\
"	 nop\n"			\
"	.end	" #Name "\n"	);

/*
 * Invoke an ARC routine through a function pointer (set up in bios_ident()),
 * also forcing the stack to be in CKSEG0 (actually, whatever area proc0 stack
 * was allocated in) if this is a 32-bit ARCBios; used by restart functions,
 * which aren't supposed to return anyway.
 */
#define ARC_Call_Via_Pointer(Name,fnptr) \
__asm__("\n"	\
"	.text\n"		\
"	.ent	" #Name "\n"	\
"	.align	3\n"		\
"	.set	noreorder\n"	\
"	.globl	" #Name "\n"	\
#Name":\n"			\
"	lw	$3, bios_is_32bit\n"\
"	beqz	$3, 1f\n"	\
"	 nop\n"			\
"	ld	$3, proc0paddr\n" \
"	addi	$29, $3, 16384 - 64\n"		/* assumes USPACE >= 16384 */ \
"1:\n"				\
"	ld	$2, " #fnptr "\n"\
"	jr	$2\n"		\
"	 nop\n"			\
"	.end	" #Name "\n");

#if 0
ARC_Call(Bios_Load,			0x00);
ARC_Call(Bios_Invoke,			0x04);
ARC_Call(Bios_Execute,			0x08);
#endif
ARC_Call_Via_Pointer(Bios_Halt,			bios_halt);
ARC_Call_Via_Pointer(Bios_PowerDown,		bios_powerdown);
ARC_Call_Via_Pointer(Bios_Restart,		bios_restart);
ARC_Call_Via_Pointer(Bios_Reboot,		bios_reboot);
ARC_Call_Via_Pointer(Bios_EnterInteractiveMode,	bios_eim);
#if 0
ARC_Call(Bios_Unused1,			0x20);
#endif
ARC_Call(Bios_GetPeer,			0x24);
ARC_Call(Bios_GetChild,			0x28);
#if 0
ARC_Call(Bios_GetParent,		0x2c);
#endif
#if 0
ARC_Call(Bios_GetConfigurationData,	0x30);
#endif
#if 0
ARC_Call(Bios_AddChild,			0x34);
ARC_Call(Bios_DeleteComponent,		0x38);
#endif
#if 0
ARC_Call(Bios_GetComponent,		0x3c);
ARC_Call(Bios_SaveConfiguration,	0x40);
#endif
ARC_Call(Bios_GetSystemId,		0x44);
ARC_Call(Bios_GetMemoryDescriptor,	0x48);
#if 0
ARC_Call(Bios_Unused2,			0x4c);
#endif
ARC_Call(Bios_GetTime,			0x50);
#if 0
ARC_Call(Bios_GetRelativeTime,		0x54);
ARC_Call(Bios_GetDirectoryEntry,	0x58);
ARC_Call(Bios_Open,			0x5c);
ARC_Call(Bios_Close,			0x60);
ARC_Call(Bios_Read,			0x64);
ARC_Call(Bios_GetReadStatus,		0x68);
#endif
ARC_Call(Bios_Write,			0x6c);
#if 0
ARC_Call(Bios_Seek,			0x70);
ARC_Call(Bios_Mount,			0x74);
#endif
ARC_Call(Bios_GetEnvironmentVariable,	0x78);
#if 0
ARC_Call(Bios_SetEnvironmentVariable,	0x7c);
ARC_Call(Bios_GetFileInformation,	0x80);
ARC_Call(Bios_SetFileInformation,	0x84);
#endif
ARC_Call(Bios_FlushAllCaches,		0x88);
#if 0
ARC_Call(Bios_TestUnicodeCharacter,	0x8c);
ARC_Call(Bios_GetDisplayStatus,		0x90);
#endif

/*
 *	Simple getchar/putchar interface.
 */

#if 0
int
bios_getchar()
{
	char buf[4];
	long  cnt;

	if (Bios_Read(0, &buf[0], 1, &cnt) != 0)
		return(-1);
	return(buf[0] & 255);
}
#endif

void
bios_putchar(c)
char c;
{
	char buf[4];
	long  cnt;

	if (c == '\n') {
		buf[0] = '\r';
		buf[1] = c;
		cnt = 2;
#ifdef __arc__
		if (displayinfo.CursorYPosition < displayinfo.CursorMaxYPosition)
			displayinfo.CursorYPosition++;
#endif
	}
	else {
		buf[0] = c;
		cnt = 1;
	}
	Bios_Write(1, &buf[0], cnt, &cnt);
}

void
bios_putstring(s)
char *s;
{
	while (*s) {
		bios_putchar(*s++);
	}
}

void
bios_printf(const char *fmt, ...)
{
	va_list ap;
	char buf[1024];

	va_start(ap, fmt);
	vsnprintf(buf, sizeof(buf), fmt, ap);
	bios_putstring(buf);
	va_end(ap);
}

/*
 * Get memory descriptor for the memory configuration and
 * create a layout database used by pmap init to set up
 * the memory system.
 *
 * Concatenate obvious adjacent segments.
 */
void
bios_configure_memory()
{
	arc_mem_t *descr = NULL;
	uint64_t start, count, prevend = 0;
	MEMORYTYPE type, prevtype = BadMemory;
	uint64_t seg_start, seg_end;
#ifdef TGT_ORIGIN
	int seen_free = 0;
#endif
#ifdef ARCBIOS_DEBUG
	int i;
#endif

	descr = (arc_mem_t *)Bios_GetMemoryDescriptor(descr);
	while (descr != NULL) {
		if (bios_is_32bit) {
			start = descr->BasePage;
			count = descr->PageCount;
			type = descr->Type;
		} else {
			start = ((arc_mem64_t *)descr)->BasePage;
			count = ((arc_mem64_t *)descr)->PageCount;
			type = descr->Type;

#ifdef TGT_OCTANE
			/*
			 * Memory above 1GB physical (address 1.5GB)
			 * gets reported as reserved on Octane, while
			 * it isn't.
			 * Abort scan at this point, platform dependent
			 * code will add the remaining memory, if any.
			 */
			if (sys_config.system_type == SGI_OCTANE &&
			    type == FirmwarePermanent &&
			    start >= 0x60000)
				break;
#endif

#ifdef TGT_ORIGIN
			if (sys_config.system_type == SGI_IP27) {
				/*
				 * For the lack of a better way to tell
				 * IP27 apart from IP35, look at the
				 * start of the first chunk of free
				 * memory. On IP27, it starts under
				 * 0x20000 (which allows us to link
				 * kernels at 0xa800000000020000).
				 * On IP35, it starts at 0x40000.
				 */
				if (type == FreeMemory && seen_free == 0) {
					seen_free = 1;
					if (start >= 0x20)	/* IP35 */
						sys_config.system_type =
						    SGI_IP35;
				}

				/*
				 * On IP27 and IP35 systems, data after the
				 * first FirmwarePermanent entry is not
				 * reliable (entries conflict with each other),
				 * and memory after 32MB (or 64MB on IP35) is
				 * not listed anyway.
				 * So, break from the loop as soon as a
				 * FirmwarePermanent entry is found, after
				 * making it span the end of the first 32MB
				 * (64MB on IP35).
				 *
				 * The rest of the memory will be gathered
				 * from the node structures.  This loses some
				 * of the first few MB (well... all of them
				 * but the kernel image), but at least we're
				 * safe to use ARCBios after going virtual.
				 */
				if (type == FirmwarePermanent) {
					descr = NULL; /* abort loop */
					count = ((sys_config.system_type ==
					    SGI_IP27 ?  32 : 64) << (20 - 12)) -
					    start;
				}
			}
#endif	/* O200 || O300 */
		}

		switch (type) {
		case BadMemory:		/* have no use for these */
			break;
		case LoadedProgram:
			/*
			 * LoadedProgram areas are either the boot loader,
			 * if the kernel has not been directly loaded by
			 * ARCBios, or the kernel image itself.
			 * Since we will move the kernel image out of the
			 * memory segments later anyway, it makes sense to
			 * claim this memory as free.
			 */
			/* FALLTHROUGH */
		case FreeMemory:
		case FreeContigous:
			/*
			 * Convert from ARCBios page size to kernel page size.
			 * As this can yield a smaller range due to possible
			 * different page size, we try to force coalescing
			 * with the previous range if this is safe.
			 */
			seg_start = atop(round_page(start * ARCBIOS_PAGE_SIZE));
			seg_end = atop(trunc_page((start + count) *
			    ARCBIOS_PAGE_SIZE));
			if (start == prevend)
				switch (prevtype) {
				case LoadedProgram:
				case FreeMemory:
				case FreeContigous:
					seg_start = atop(trunc_page(start *
					    ARCBIOS_PAGE_SIZE));
					break;
				default:
					break;
				}
			if (seg_start < seg_end)
				memrange_register(seg_start, seg_end, 0);
			break;
		case ExceptionBlock:
		case SystemParameterBlock:
		case FirmwareTemporary:
		case FirmwarePermanent:
			rsvdmem += count;
			break;
		default:		/* Unknown type, leave it alone... */
			break;
		}
		prevtype = type;
		prevend = start + count;
#ifdef TGT_ORIGIN
		if (descr == NULL)
			break;
#endif
		descr = (arc_mem_t *)Bios_GetMemoryDescriptor(descr);
	}

	/* convert rsvdmem to kernel pages, and count it in physmem */
	rsvdmem = atop(round_page(rsvdmem * ARCBIOS_PAGE_SIZE));
	physmem += rsvdmem;

#ifdef ARCBIOS_DEBUG
	for (i = 0; i < MAXMEMSEGS; i++) {
		if (mem_layout[i].mem_last_page) {
			bios_printf("MEM %d, %p to  %p\n", i,
			    ptoa(mem_layout[i].mem_first_page),
			    ptoa(mem_layout[i].mem_last_page));
	    }
	}
#endif
}

/*
 * Find out system type.
 */
int
bios_get_system_type()
{
	arc_config_t	*cf;
	arc_sid_t	*sid;
	register_t	prid;
	char		*sysid;
	int		sysid_len;
	int		i;

	/*
	 * Figure out where ARCBios can be addressed. On R8000, we can not
	 * use compatibility space, but on IP27/IP35, we can not blindly
	 * use XKPHYS due to subspacing, while compatibility space works.
	 * Fortunately we can get the processor ID to tell these apart, even
	 * though 32-bit coprocessor 0 instructions are not supposed to be
	 * supported on the R8000 (they probably misbehave somehow if the
	 * register has bits sets in the upper 32 bits, which is not the
	 * case of the R8000 PrId register).
	 */
	__asm__ volatile ("mfc0 %0, $15" /* COP_0_PRID */ : "=r" (prid));
	if ((prid & 0xff00) == (MIPS_R8000 << 8))
		bios_base = (void *)PHYS_TO_XKPHYS(ARCBIOS_BASE, CCA_CACHED);
	else
		bios_base = (void *)PHYS_TO_CKSEG0(ARCBIOS_BASE);

	/*
	 * Figure out if this is an ARCBios machine and if it is, see if we're
	 * dealing with a 32 or 64 bit version.
	 */
	if ((ArcBiosBase32->magic == ARC_PARAM_BLK_MAGIC) ||
	    (ArcBiosBase32->magic == ARC_PARAM_BLK_MAGIC_BUG)) {
		bios_is_32bit = 1;
		bios_printf("ARCS32 Firmware Version %d.%d\n",
		    ArcBiosBase32->version, ArcBiosBase32->revision);
	} else if ((ArcBiosBase64->magic == ARC_PARAM_BLK_MAGIC) ||
	    (ArcBiosBase64->magic == ARC_PARAM_BLK_MAGIC_BUG)) {
		bios_is_32bit = 0;
		bios_printf("ARCS64 Firmware\n");
	} else {
		return -1; /* Today is not your lucky day */
	}

	sid = (arc_sid_t *)Bios_GetSystemId();

	cf = (arc_config_t *)Bios_GetChild(NULL);
	if (cf != NULL) {
		if (bios_is_32bit) {
			sysid = (char *)(long)cf->id;
			sysid_len = cf->id_len;
		} else {
			sysid = (char *)((arc_config64_t *)cf)->id;
			sysid_len = ((arc_config64_t *)cf)->id_len;
		}

		if (sysid_len > 0 && sysid != NULL) {
			sysid_len--;
			for (i = 0; i < KNOWNSYSTEMS; i++) {
				if (strlen(sys_types[i].sys_name) !=sysid_len)
					continue;
				if (strncmp(sys_types[i].sys_name, sysid,
				    sysid_len) != 0)
					continue;
				if (sys_types[i].sys_vend &&
				    strncmp(sys_types[i].sys_vend, sid->vendor,
				      8) != 0)
					continue;
				return (sys_types[i].sys_type);	/* Found it. */
			}
		}
	} else {
#ifdef TGT_ORIGIN
		if (IP27_KLD_KLCONFIG(0)->magic == IP27_KLDIR_MAGIC) {
			/*
			 * If we find a kldir assume IP27 for now.
			 * We'll decide whether this is IP27 or IP35 later.
			 */
			return SGI_IP27;
		}
#endif
	}

	bios_printf("UNRECOGNIZED SYSTEM '%s' VENDOR '%8.8s' PRODUCT '%8.8s'\n",
	    cf == NULL ? "??" : sysid, sid->vendor, sid->prodid);
	bios_printf("Halting system!\n");
	Bios_Halt();
	bios_printf("Halting failed, use manual reset!\n");
	while(1);
}

/*
 * Incomplete version of bios_ident
 */
void
bios_ident()
{
	sys_config.system_type = bios_get_system_type();

	if (bios_is_32bit) {
#define bios_fnptr(slot) \
    (int64_t)*(int32_t *)((int64_t)ArcBiosBase32->firmware_vect + (slot) * 4)
		bios_halt = (void (*)(void))bios_fnptr(3);
		bios_powerdown = (void (*)(void))bios_fnptr(4);
		bios_restart = (void (*)(void))bios_fnptr(5);
		bios_reboot = (void (*)(void))bios_fnptr(6);
		bios_eim = (void (*)(void))bios_fnptr(7);
#undef bios_fnptr
	} else {
#define bios_fnptr(slot) \
    *(int64_t *)(ArcBiosBase64->firmware_vect + (slot) * 8)
		bios_halt = (void (*)(void))bios_fnptr(3);
		bios_powerdown = (void (*)(void))bios_fnptr(4);
		bios_restart = (void (*)(void))bios_fnptr(5);
		bios_reboot = (void (*)(void))bios_fnptr(6);
		bios_eim = (void (*)(void))bios_fnptr(7);
#undef bios_fnptr
	}

	bios_configure_memory();
#ifdef __arc__
	displayinfo = *(arc_dsp_stat_t *)Bios_GetDisplayStatus(1);
#endif
}

#if 0
/*
 * Return geometry of the display. Used by pccons.c to set up the
 * display configuration.
 */
void
bios_display_info(xpos, ypos, xsize, ysize)
    int	*xpos;
    int	*ypos;
    int *xsize;
    int *ysize;
{
#ifdef __arc__
	*xpos = displayinfo.CursorXPosition;
	*ypos = displayinfo.CursorYPosition;
	*xsize = displayinfo.CursorMaxXPosition;
	*ysize = displayinfo.CursorMaxYPosition;
#endif
}
#endif
@


1.34
log
@Replace ARC_Call2(), used to invoke the `return-to-PROM' routines with a
PROM-compatible stack, with a sligthly different ARC_Call_Via_Pointer(),
which uses a global function pointer variable instead of computing the
address from the ARCBios parameter block; said variable being set in
bios_ident().

No functional change... yet. Tested on IP22(24), IP30 and IP32.
@
text
@d1 1
a1 1
/*	$OpenBSD: arcbios.c,v 1.33 2012/09/29 21:39:30 miod Exp $	*/
d459 1
a459 1
	__asm__ __volatile__ ("mfc0 %0, $15" /* COP_0_PRID */ : "=r" (prid));
@


1.33
log
@Do not hardcode ARCBios vector base, but rather compute it at runtime.
This allows MI code to support both 32-bit ARCS systems, as well as 64-bit
R8000 and R1x000 systems.

While there, #if 0 out ARCBios routines currently not used by the kernel.
@
text
@d1 1
a1 1
/*	$OpenBSD: arcbios.c,v 1.32 2012/03/28 20:44:23 miod Exp $	*/
d60 6
d129 4
a132 3
 * Same, which also forces the stack to be in CKSEG0 (actually, whatever area
 * proc0 stack was allocated in), used for restart functions, which aren't
 * supposed to return.
d134 1
a134 1
#define ARC_Call2(Name,Offset)	\
a142 1
"	ld	$2, bios_base\n"\
d144 1
a144 1
"	nop\n"			\
d146 1
a146 6
"	addi	$29, $3, 16384 - 64\n" \
"2:\n"				\
"	lw	$3, 0x20($2)\n"	\
"       lw      $2," #Offset "($3)\n"\
"	jr	$2\n"		\
"	nop\n"			\
d148 1
a148 2
"	ld	$3, 2*0x20($2)\n"\
"	ld	$2, 2*" #Offset "($3)\n"\
d150 1
a150 1
"	nop\n"			\
d158 5
a162 5
ARC_Call2(Bios_Halt,			0x0c);
ARC_Call2(Bios_PowerDown,		0x10);
ARC_Call2(Bios_Restart,			0x14);
ARC_Call2(Bios_Reboot,			0x18);
ARC_Call2(Bios_EnterInteractiveMode,	0x1c);
d536 21
@


1.32
log
@Work in progress support for the SGI Indigo, Indigo 2 and Indy systems
(IP20, IP22, IP24) in 64-bit mode, adapated from NetBSD. Currently limited
to headless operation, input and video drivers will get ported soon.

Should work on all R4000, R4440 and R5000 based systems. L2 cache on R5000SC
Indy not supported yet (coming soon), R4600 not supported yet either (coming
soon as well).

Tested to boot multiuser on: Indigo2 R4000SC, Indy R4000PC, Indy R4000SC,
Indy R5000SC, Indigo2 R4400SC. There are still glitches in the Ethernet driver
which are being looked at.

Expansion support is limited to the GIO E++ board; GIO boards with PCI-GIO
bridges not ported yet due to the lack of hardware, and this kind of driver
does not port blindly.

Most of this work comes from NetBSD, polishing and integration work, as well
as putting as many ``R4x00 in 64-bit mode'' erratas as necessary, by yours
truly.

More work is coming, as well as trying to get some easy way to boot install
kernels (as older PROM can only boot ECOFF binaries, which won't do for the
kernel).
@
text
@d1 1
a1 1
/*	$OpenBSD: arcbios.c,v 1.31 2012/03/24 20:11:28 miod Exp $	*/
d47 2
d100 1
a100 1
__asm__("\n"	\
d107 6
a112 5
"	lw	$2, bios_is_32bit\n"\
"	beqz	$2, 1f\n"	\
"	nop\n"			\
"       lw      $2, 0xffffffff80001020\n"\
"       lw      $2," #Offset "($2)\n"\
d114 1
a114 1
"	nop\n"			\
d116 2
a117 2
"       ld      $2, 0xffffffff80001040\n"\
"	ld	$2, 2*" #Offset "($2)\n"\
d119 2
a120 2
"	nop\n"			\
"	.end	" #Name "\n");
d123 3
a125 2
 * Same, which also forces the stack to be in CKSEG0, used for
 * restart functions, which aren't supposed to return.
d135 3
a137 2
"	lw	$2, bios_is_32bit\n"\
"	beqz	$2, 1f\n"	\
d139 2
a140 2
"	ld	$2, proc0paddr\n" \
"	addi	$29, $2, 16384 - 64\n" \
d142 2
a143 2
"       lw      $2, 0xffffffff80001020\n"\
"       lw      $2," #Offset "($2)\n"\
d147 2
a148 2
"       ld      $2, 0xffffffff80001040\n"\
"	ld	$2, 2*" #Offset "($2)\n"\
d153 1
d157 1
d163 1
d165 1
d168 1
d170 2
d173 2
d177 2
d181 1
d184 1
d186 1
d188 1
d195 1
d197 1
d200 1
d202 1
d206 1
d208 1
d211 1
d217 1
d228 1
d444 1
d450 17
a466 1
	 * Figure out if this is an ARC Bios machine and if it is, see if we're
d477 1
a477 2
		bios_printf("ARCS64 Firmware Version %d.%d\n",
		    ArcBiosBase64->version, ArcBiosBase64->revision);
d479 1
a479 1
		return -1;	/* XXX BAD BAD BAD!!! */
d542 1
d561 1
@


1.31
log
@Oops, forgot this file in the SGI_<model> -> SGI_IP## change.
@
text
@d1 1
a1 1
/*	$OpenBSD: arcbios.c,v 1.30 2011/05/30 22:25:21 oga Exp $	*/
d53 1
@


1.30
log
@Remove the freelist member from vm_physseg

The new world order of pmemrange makes this data completely redundant
(being dealt with by the pmemrange constraints instead). Remove all code
that messes with the freelist.

While touching every caller of uvm_page_physload() anyway, add the flags
argument to all callers (all but one is 0 and that one already used
PHYSLOAD_DEVICE) and remove the macro magic to allow callers to continue
without it.

Should shrink the code a bit, as well.

matthew@@ pointed out some mistakes i'd made.
``freelist death, I like. Ok.' ariane@@
`I agree with the general direction, go ahead and i'll fix any fallout
shortly'' miod@@ (68k 88k and vax i could not check would build)
@
text
@d1 1
a1 1
/*	$OpenBSD: arcbios.c,v 1.29 2010/03/03 12:25:09 jsing Exp $	*/
d70 1
d77 9
a85 7
    { NULL,		"SGI-IP17",			SGI_CRIMSON },
    { NULL,		"SGI-IP19",			SGI_ONYX },
    { NULL,		"SGI-IP20",			SGI_INDIGO },
    { NULL,		"SGI-IP21",			SGI_POWER },
    { NULL,		"SGI-IP22",			SGI_INDY },
    { NULL,		"SGI-IP25",			SGI_POWER10 },
    { NULL,		"SGI-IP26",			SGI_POWERI },
d261 1
a261 1
#ifdef DEBUG
d395 1
a395 1
#ifdef DEBUG
@


1.29
log
@Store ARCBios variables before machine specific setup is performed and
make console selection on a per machine basis. Whilst here store the
keyboard layout ('keybd') and graphics state ('gfx') variables for
future use.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arcbios.c,v 1.28 2009/12/07 19:39:57 miod Exp $	*/
d368 1
a368 2
				memrange_register(seg_start, seg_end, 0,
				    VM_FREELIST_DEFAULT);
@


1.28
log
@Correctly skip available memory regions without (kernel) page aligned
boundaries, entirely contained within a kernel page; issue raised by drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arcbios.c,v 1.27 2009/12/07 18:56:29 miod Exp $	*/
d53 3
a55 1
char bios_console[10];			/* Primary console. */
@


1.27
log
@When converting ARCBios memory spaces from ARCBios page size to the kernel
page size, be sure to pick the strictest interval so as not to incorrectly
claim ARCBios reserved data not (kernel) page size aligned as free memory.

No functional change since the kernel uses the same page size as ARCBios
(at the moment).
@
text
@d1 1
a1 1
/*	$OpenBSD: arcbios.c,v 1.26 2009/12/07 18:51:24 miod Exp $	*/
d365 3
a367 2
			memrange_register(seg_start, seg_end, 0,
			    VM_FREELIST_DEFAULT);
@


1.26
log
@When trying to return to ARCBios on a 32 bit ARCBios machine (such as the O2),
disable interrupts and unconditionnaly use proc0 u area as the stack, so that
once ARCBios loses the upper 32 bits of the stack pointer, accessing the
stack does not fault (proc0 u area is allocated in CKSEG0 for this reason).
@
text
@d1 1
a1 1
/*	$OpenBSD: arcbios.c,v 1.25 2009/11/19 06:06:51 miod Exp $	*/
d250 2
a251 2
	uint64_t start, count;
	MEMORYTYPE type;
a329 5
		/* convert from ARCBios page size to kernel page size */
		seg_start = atop(start * 4096);
		count = atop(count * 4096);
		seg_end = seg_start + count;

d345 20
a372 1
			physmem += count;
d377 2
d385 4
@


1.25
log
@Factor triplicated code responsible to add memory information into a
single place.
@
text
@d1 1
a1 1
/*	$OpenBSD: arcbios.c,v 1.24 2009/11/07 18:56:54 miod Exp $	*/
d90 1
d92 27
a118 1
__asm__("\n"			\
d128 3
d140 1
a140 1
"	.end	" #Name "\n"	);
d145 5
a149 5
ARC_Call(Bios_Halt,			0x0c);
ARC_Call(Bios_PowerDown,		0x10);
ARC_Call(Bios_Restart,			0x14);
ARC_Call(Bios_Reboot,			0x18);
ARC_Call(Bios_EnterInteractiveMode,	0x1c);
@


1.24
log
@Replace option TGT_ORIGIN200 and TGT_ORIGIN2000 with a single option,
TGT_ORIGIN, which enables support for all IP27 and IP35 systems. The original
two options have always been used together, and go back to when pefo thought
supporting multiple nodes would be significant work. Since an Origin 200
can be a dual-node system, making a distinction between single node and
multiple node systems is a moot point anyway.

Be sure to rerun config(8) before rebuilding a kernel.
@
text
@d1 1
a1 1
/*	$OpenBSD: arcbios.c,v 1.23 2009/11/07 14:49:01 miod Exp $	*/
d40 2
a219 1
	struct phys_mem_desc *m;
d222 1
a222 1
	vaddr_t seg_start, seg_end;
d226 1
d228 1
d246 2
d252 1
a252 1
				type = FreeMemory;
d300 3
a302 1
		seg_start = start;
d306 1
a306 1
		case BadMemory:		/* Have no use for these */
a307 1

d320 2
a321 21
			physmem += count;
			m = NULL;
			for (i = 0; i < MAXMEMSEGS; i++) {
				if (mem_layout[i].mem_last_page == 0) {
					if (m == NULL)
						m = &mem_layout[i]; /* free */
				}
				else if (seg_end == mem_layout[i].mem_first_page) {
					m = &mem_layout[i];
					m->mem_first_page = seg_start;
				}
				else if (mem_layout[i].mem_last_page == seg_start) {
					m = &mem_layout[i];
					m->mem_last_page = seg_end;
				}
			}
			if (m && m->mem_first_page == 0) {
				m->mem_first_page = seg_start;
				m->mem_last_page = seg_end;
				m->mem_freelist = VM_FREELIST_DEFAULT;
			}
a322 1

a329 1

d340 1
a340 1
#ifdef DEBUG_MEM_LAYOUT
d342 4
a345 4
		if (mem_layout[i].mem_first_page) {
			bios_printf("MEM %d, 0x%x to  0x%x\n",i,
				mem_layout[i].mem_first_page * 4096,
				mem_layout[i].mem_last_page * 4096);
@


1.23
log
@Change sgi system identification from a single system type list, to a smaller
system type list (which really is the system family) and a subsystem type.

No functional change yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: arcbios.c,v 1.22 2009/07/15 20:34:57 martynas Exp $	*/
d40 1
a40 1
#if defined(TGT_ORIGIN200) || defined(TGT_ORIGIN2000)
d222 1
a222 1
#if defined(TGT_ORIGIN200) || defined(TGT_ORIGIN2000)
d250 1
a250 1
#if defined(TGT_ORIGIN200) || defined(TGT_ORIGIN2000)
d348 1
a348 1
#if defined(TGT_ORIGIN200) || defined(TGT_ORIGIN2000)
d424 1
a424 1
#if defined(TGT_ORIGIN200) || defined(TGT_ORIGIN2000)
@


1.22
log
@missing va_end in bios_printf & dioopen.  ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arcbios.c,v 1.21 2009/05/16 16:40:31 miod Exp $	*/
d251 1
a251 3
			if ((sys_config.system_type == SGI_O200 ||
			     sys_config.system_type == SGI_O300)) {

d265 1
a265 1
						    SGI_O300;
d288 1
a288 1
					    SGI_O200 ?  32 : 64) << (20 - 12)) -
d430 1
a430 1
			return SGI_O200;
@


1.21
log
@Count LoadedProgram regions as free memory, since these are either the boot
loader image (which we can safely overwrite) or the kernel image itself (in
case of netboot) and there is already code to move the kernel image out
of the free memory later on.
@
text
@d1 1
a1 1
/*	$OpenBSD: arcbios.c,v 1.20 2009/05/15 22:56:08 miod Exp $	*/
d204 1
@


1.20
log
@Revert 1.18, the memory bank allocation logic was actually correct, and I
must have been on drugs when thinking otherwise.
@
text
@d1 1
a1 1
/*	$OpenBSD: arcbios.c,v 1.19 2009/05/09 18:08:59 miod Exp $	*/
d303 10
a342 4
			physmem += count;
			break;

		case LoadedProgram:	/* Count this into total memory */
@


1.19
log
@Promote types in ARCBios function prototypes from int to long whenever
necessary, to allow the same C code to be used against 32 bit ARCBios, when
compiled in 32 bit mode, or against 64 bit ARCBios, when compiled in native
mode.

Soon to be used by the boot blocks; this commit doesn't introduce any
functional change yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: arcbios.c,v 1.18 2009/05/08 18:34:37 miod Exp $	*/
a78 1
    { NULL,		"SGI-IP27",			SGI_O200 },
d80 1
a80 2
    { NULL,		"SGI-IP32",			SGI_O2 },
    { NULL,		"SGI-IP35",			SGI_O300 },
d286 1
a286 2
				switch (type) {
				case FirmwarePermanent:
a290 8
					rsvdmem = start;
					break;
				case FreeMemory:
				case FreeContigous:
					type = BadMemory; /* do not count */
					break;
				default:
					break;
@


1.18
log
@Be sure to completely ignore ARCBios memory information on IP27 and IP35
for now, as we get this information from elsewhere and bad things would
happen if arcbios memory walk causes more memory segment entries to be
populated than the KL memory walk will, later on.
@
text
@d1 1
a1 1
/*	$OpenBSD: arcbios.c,v 1.17 2009/05/06 20:07:10 miod Exp $	*/
d44 1
a44 1
int bios_is_32bit = 1;
d158 1
a158 1
	int  cnt;
d170 1
a170 1
	int  cnt;
d385 2
a386 1
	 *  Figure out if this is an ARC Bios machine and if its 32 or 64 bits.
@


1.17
log
@Fix typo in a comment, and remove 20st-century mention of option
MACHINE_NONCONTIG (not even MACHINE_NEWNONCONTIG!)
@
text
@d1 1
a1 1
/*	$OpenBSD: arcbios.c,v 1.16 2009/04/19 12:52:33 miod Exp $	*/
d223 3
a225 1
	int seen_free;
a227 1
	seen_free = 0;
a250 2
			if (type == FreeMemory && seen_free == 0) {
				seen_free = 1;
d252 3
d264 6
a269 4
				if (start >= 0x20)	/* IP35 */
					sys_config.system_type = SGI_O300;
#endif
			}
d271 32
a302 23
#if defined(TGT_ORIGIN200) || defined(TGT_ORIGIN2000)
			/*
			 * On IP27 and IP35 systems, data after the first
			 * FirmwarePermanent entry is not reliable
			 * (entries conflict with each other), and memory
			 * after 32MB (or 64MB on IP35) is not listed anyway.
			 * So, break from the loop as soon as a
			 * FirmwarePermanent entry is found, after
			 * making it span the end of the first 32MB
			 * (64MB on IP35).
			 *
			 * The rest of the memory is gathered from the
			 * node structures.  This probably loses some of
			 * the first few MB, but at least we're safe to
			 * use ARCBios after going virtual.
			 */
			if (type == FirmwarePermanent &&
			    (sys_config.system_type == SGI_O200 ||
			     sys_config.system_type == SGI_O300)) {
				descr = NULL;
				count = ((sys_config.system_type == SGI_O200 ?
				    32 : 64) << (20 - 12)) - start;
				rsvdmem = start;
d304 1
a304 1
#endif
d306 1
@


1.16
log
@Add heuristics to tell IP27 and IP35 apart, as they will need to be handled
differently at times.
@
text
@d1 1
a1 1
/*	$OpenBSD: arcbios.c,v 1.15 2008/12/03 15:43:17 sthen Exp $	*/
d211 1
a211 2
 * the memory system. Note that kernel option "MACHINE_NONCONTIG"
 * must be set for systems with non contigous physical memory.
d213 1
a213 1
 * Concatenate obvious adjecent segments.
d272 1
a272 1
			 * after 32MB is not listed anyway.
d289 1
a427 1
	bios_printf("See the www.openbsd.org for further information.\n");
@


1.15
log
@Some more ambigous -> ambiguous pointed out by mbalmer (there are
others, these are the ones from code unlikely to be re-merged with
upstream sources).
@
text
@d1 1
a1 1
/*	$OpenBSD: arcbios.c,v 1.14 2008/04/07 22:40:58 miod Exp $	*/
d81 2
a82 1
    { NULL,		"SGI-IP32",			SGI_O2 }
d224 2
a225 1
	int	i;
d227 1
d251 17
d270 1
a270 1
			 * On Origin200 systems, data after the first
d276 3
a278 1
			 * making it span the end of the first 32MB.
d281 1
a281 1
			 * the first 32MB, but at least we're safe to
d284 3
a286 3
			if (sys_config.system_type == SGI_O200 &&
			    type == FirmwarePermanent) {
				count = (32 << (20 - 12)) - start;
d288 2
d325 1
a325 1
		case ExeceptionBlock:
d417 4
a420 1
			/* If we find a kldir assume IP27 */
@


1.14
log
@Add a freelist member to the ARCBios memory information. For now, all ARCBios
available memory regions will be reported to be in VM_FREELIST_DEFAULT.

Add a few quirks to cope with (some) IP27 and IP30 weirdness.
@
text
@d1 1
a1 1
/*	$OpenBSD: arcbios.c,v 1.13 2008/02/18 19:48:36 miod Exp $	*/
d62 1
a62 1
	char *sys_vend;		/* Vendor ID if name is ambigous */
@


1.13
log
@Get correct memory information from 64 bit ARCBios, tested on Octane.
@
text
@d1 1
a1 1
/*	$OpenBSD: arcbios.c,v 1.12 2008/02/18 19:43:28 miod Exp $	*/
d31 2
d35 2
a36 2
#include <machine/param.h>
#include <machine/autoconf.h>
d221 1
d230 1
d234 34
d272 2
a273 2
		switch (descr->Type) {
		case BadMemory:		/* Have no use for theese */
d297 1
d316 4
d415 1
a415 9
	/* Get memory configuration from bios if applicable */
	switch (sys_config.system_type) {
	case SGI_O200:
		break;
	default:
		if (sys_config.system_type >= 0)
			bios_configure_memory();
		break;
	}
a438 1

@


1.12
log
@More 64-bit ARCBios friendliness, correctly identify a 64 bit system, such
as the Octane; joint work with jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arcbios.c,v 1.11 2007/12/14 10:13:17 jsing Exp $	*/
d173 1
d176 1
d218 1
d224 9
a232 2
		seg_start = descr->BasePage;
		seg_end = seg_start + descr->PageCount;
d240 1
a240 1
			physmem += descr->PageCount;
d266 2
a267 2
			rsvdmem += descr->PageCount;
			physmem += descr->PageCount;
d271 1
a271 1
			physmem += descr->PageCount;
a374 1
	case SGI_OCTANE:
@


1.11
log
@Store the ARCBIOS ConsoleOut environment variable so that we can refer to
it later on.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arcbios.c,v 1.10 2007/10/18 04:32:25 miod Exp $	*/
d78 2
a79 1
    { NULL,		"SGI-IP32",			SGI_O2 },
d214 1
a214 1
	arc_mem_t *descr = 0;
d220 1
a220 2
	while(descr != 0) {

d231 1
a231 1
			m = 0;
d234 1
a234 1
					if (m == 0)
d271 1
a271 1
	for ( i = 0; i < MAXMEMSEGS; i++) {
d289 2
d313 23
a335 8
	if (cf) {
		for (i = 0; i < KNOWNSYSTEMS; i++) {
			if (strcmp(sys_types[i].sys_name, (char *)(long)cf->id) != 0)
				continue;
			if (sys_types[i].sys_vend &&
			    strncmp(sys_types[i].sys_vend, sid->vendor, 8) != 0)
				continue;
			return (sys_types[i].sys_type);	/* Found it. */
d337 1
d339 4
a342 3
	} else if (IP27_KLD_KLCONFIG(0)->magic == IP27_KLDIR_MAGIC) {
		/* If we find a kldir assume IP27 */
		return SGI_O200;
d346 2
a347 4
	sid->vendor[8] = 0;
	sid->prodid[8] = 0;
	bios_printf("UNRECOGNIZED SYSTEM '%s' VENDOR '%s' PRODUCT '%s'\n",
		cf ? (char *)(long)cf->id : "??", sid->vendor, sid->prodid);
d362 9
a370 2
	if (sys_config.system_type < 0 || sys_config.system_type == SGI_O200) {
		return;
a371 2
	/* If not an IP27 platform, get memory configuration from bios */
	bios_configure_memory();
@


1.10
log
@No need to include <machine/pte.h> here.
@
text
@d1 1
a1 1
/*	$OpenBSD: arcbios.c,v 1.9 2007/04/26 17:02:40 miod Exp $	*/
d44 1
a44 1
 * If we can not get the onboard ethernet address to override this bogus
d48 2
@


1.9
log
@Do not invoke arcbios routines from the moment our page tables are set up,
to the moment we reboot, for we do not know what it can do behind our back;
this means the built-in ethernet address has to be read from the arcbios
environment earlier.
@
text
@d1 1
a1 1
/*	$OpenBSD: arcbios.c,v 1.8 2006/03/09 23:06:20 miod Exp $	*/
a30 1
#include <machine/pte.h>
@


1.8
log
@Do not include <lib/libkern/libkern.h> explicitely, get it via <sys/systm.h>.
@
text
@d1 1
a1 1
/*	$OpenBSD: arcbios.c,v 1.7 2004/10/20 12:49:15 pefo Exp $	*/
d44 5
@


1.7
log
@Fix some 64 bit address problems.
Some function names made more unique.
Other changes for the upcoming Origin 200 support.
@
text
@d1 1
a1 1
/*	$OpenBSD: arcbios.c,v 1.6 2004/09/09 22:11:38 pefo Exp $	*/
a30 1
#include <lib/libkern/libkern.h>
@


1.6
log
@Kernel moves to 64 bit. A few more tweaks when binutils is updated.
@
text
@d1 1
a1 1
/*	$OpenBSD: arcbios.c,v 1.5 2004/08/15 12:08:24 pefo Exp $	*/
d40 5
a44 1
arc_param_blk_t *bios_base = ArcBiosBase;
d72 1
d89 10
a98 2
"	lw	$2, 0xffffffff80001020\n"\
"	lw	$2," #Offset "($2)\n"\
d186 11
a266 1
		char str[100];
d268 1
a268 1
			snprintf(str, sizeof(str), "MEM %d, 0x%x to  0x%x\n",i,
a270 1
			bios_putstring(str);
d286 15
a300 3
	if ((bios_base->magic != ARC_PARAM_BLK_MAGIC) &&
	    (bios_base->magic != ARC_PARAM_BLK_MAGIC_BUG)) {
		return(-1);	/* This is not an ARC system */
d304 1
d315 5
a321 6
	bios_putstring("UNIDENTIFIED SYSTEM `");
	if (cf)
		bios_putstring((char *)(long)cf->id);
	else
		bios_putstring("????????");
	bios_putstring("' VENDOR `");
d323 7
a329 3
	bios_putstring(sid->vendor);
	bios_putstring("'. Please contact OpenBSD (www.openbsd.org).\n");
	bios_putstring("Reset system to restart!\n");
d340 1
a340 1
	if (sys_config.system_type < 0) {
d343 1
@


1.5
log
@gas 2.14 have different understanding of 32-64 bit constant cvt
@
text
@d1 1
a1 1
/*	$OpenBSD: arcbios.c,v 1.4 2004/08/15 10:36:17 pefo Exp $	*/
d273 1
a273 1
			if (strcmp(sys_types[i].sys_name, cf->id) != 0)
d284 1
a284 1
		bios_putstring(cf->id);
@


1.4
log
@cleanup and more protos
@
text
@d1 1
a1 1
/*	$OpenBSD: arcbios.c,v 1.3 2004/08/10 20:15:47 deraadt Exp $	*/
d84 1
a84 1
"	lw	$2, 0x80001020\n"\
@


1.3
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: arcbios.c,v 1.2 2004/08/09 14:57:26 pefo Exp $	*/
a30 1
#include <sys/user.h>
@


1.2
log
@Big cleanup. Removed some unused obsolete stuff and fixed copyrights
on some files. Arcbios support is now in, thus detects memorysize and cpu
clock frequency.
@
text
@d1 1
a1 1
/*	$OpenBSD: arcbios.c,v 1.1 2004/08/08 21:51:36 pefo Exp $	*/
d58 1
a58 1
    { NULL,		"DESKTECH-TYNE",		DESKSTATION_TYNE }, 
d83 1
a83 1
"	.globl	" #Name "\n" 	\
@


1.1
log
@Ahh! This code brings out old memories. Eight years old but still
useful. This is the ARCBIOS interface, eg the firmware interface
for SGI machines.
@
text
@d1 1
a1 1
/*	$OpenBSD: arcbios.c,v 1.3 1998/06/06 06:33:33 mickey Exp $	*/
d44 1
a188 1
	char str[100];
a199 6
#if 0
		case ExeceptionBlock:
		case SystemParameterBlock:
		case FirmwareTemporary:
		case FirmwarePermanent:
#endif
d224 9
a232 1
		case LoadedProgram:	/* This is the loaded kernel */
d244 1
@

