head	1.27;
access;
symbols
	OPENBSD_6_1_BASE:1.27
	OPENBSD_6_0:1.27.0.2
	OPENBSD_6_0_BASE:1.27
	OPENBSD_5_9:1.24.0.4
	OPENBSD_5_9_BASE:1.24
	OPENBSD_5_8:1.24.0.6
	OPENBSD_5_8_BASE:1.24
	OPENBSD_5_7:1.24.0.2
	OPENBSD_5_7_BASE:1.24
	OPENBSD_5_6:1.22.0.4
	OPENBSD_5_6_BASE:1.22
	OPENBSD_5_5:1.20.0.8
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.20.0.4
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.20.0.2
	OPENBSD_5_3_BASE:1.20
	OPENBSD_5_2:1.17.0.6
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.4
	OPENBSD_5_0:1.17.0.2
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.13.0.4
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.2
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.11.0.2
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.10.0.8
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.4
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.2
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.9.0.8
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.6
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.4
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.2
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.8.0.2
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.6.0.4
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.2
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.3.0.2
	OPENBSD_3_6_BASE:1.3;
locks; strict;
comment	@ * @;


1.27
date	2016.05.21.00.56.43;	author deraadt;	state Exp;
branches;
next	1.26;
commitid	oWpLaBOdDMvIxei3;

1.26
date	2016.05.10.18.39.47;	author deraadt;	state Exp;
branches;
next	1.25;
commitid	qfOifNidEGDB2jL1;

1.25
date	2016.03.06.19.42.27;	author mpi;	state Exp;
branches;
next	1.24;
commitid	cyYKarj4qRTft4gD;

1.24
date	2015.02.09.08.48.23;	author miod;	state Exp;
branches;
next	1.23;
commitid	nHILVH7gnv1xZfAl;

1.23
date	2015.01.02.22.38.46;	author sebastia;	state Exp;
branches;
next	1.22;
commitid	2Ybjy1BIuB1bzzpD;

1.22
date	2014.03.26.05.23.42;	author guenther;	state Exp;
branches;
next	1.21;

1.21
date	2014.03.22.06.05.45;	author guenther;	state Exp;
branches;
next	1.20;

1.20
date	2012.12.02.07.03.31;	author guenther;	state Exp;
branches;
next	1.19;

1.19
date	2012.10.03.11.18.23;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2012.08.22.13.33.32;	author okan;	state Exp;
branches;
next	1.17;

1.17
date	2011.07.05.04.48.01;	author guenther;	state Exp;
branches;
next	1.16;

1.16
date	2011.04.18.21.44.55;	author guenther;	state Exp;
branches;
next	1.15;

1.15
date	2011.04.15.04.52.39;	author guenther;	state Exp;
branches;
next	1.14;

1.14
date	2011.04.07.15.30.15;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2010.06.26.23.24.43;	author guenther;	state Exp;
branches;
next	1.12;

1.12
date	2010.04.21.03.03.26;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2010.01.08.01.35.52;	author syuu;	state Exp;
branches;
next	1.10;

1.10
date	2008.05.04.09.57.47;	author martin;	state Exp;
branches;
next	1.9;

1.9
date	2006.03.04.19.33.21;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2005.12.20.06.58.19;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2005.12.17.21.10.24;	author kettenis;	state Exp;
branches;
next	1.6;

1.6
date	2004.11.02.21.05.34;	author pefo;	state Exp;
branches;
next	1.5;

1.5
date	2004.09.17.13.31.22;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2004.09.16.09.06.41;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.10.20.15.47;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2004.08.09.14.57.26;	author pefo;	state Exp;
branches;
next	1.1;

1.1
date	2004.08.06.20.56.03;	author pefo;	state Exp;
branches;
next	;


desc
@@


1.27
log
@hand-massage sendsig() and sys_sigreturn() to be much more similar.
ok guenther kettenis
@
text
@/*	$OpenBSD: sendsig.c,v 1.26 2016/05/10 18:39:47 deraadt Exp $ */

/*
 * Copyright (c) 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * William Jolitz and Don Ahn.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by the University of
 *      California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */
/*
 * Copyright (c) 2001 Opsycon AB  (www.opsycon.se)
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/signalvar.h>
#include <sys/proc.h>
#include <sys/exec.h>
#include <sys/mount.h>
#include <sys/syscallargs.h>

#include <uvm/uvm_extern.h>

#include <machine/regnum.h>
#include <mips64/mips_cpu.h>

/*
 * WARNING: code in locore.s assumes the layout shown for sf_signum
 * thru sf_handler so... don't screw with them!
 */
struct sigframe {
	int	sf_signum;		/* signo for handler */
	siginfo_t *sf_sip;		/* pointer to siginfo_t */
	struct	sigcontext *sf_scp;	/* context ptr for handler */
	sig_t	sf_handler;		/* handler addr for u_sigc */
	struct	sigcontext sf_sc;	/* actual context */
	siginfo_t sf_si;
};

#ifdef DEBUG
int sigdebug = 0;
pid_t sigpid = 0;
#define SDB_FOLLOW	0x01
#define SDB_KSTACK	0x02
#define SDB_FPSTATE	0x04
#endif

/*
 * Send an interrupt to process.
 */
void
sendsig(sig_t catcher, int sig, int mask, u_long code, int type,
    union sigval val)
{
	struct cpu_info *ci = curcpu();
	struct proc *p = curproc;
	struct sigframe *fp;
	struct trapframe *regs;
	struct sigacts *psp = p->p_p->ps_sigacts;
	int fsize;
	struct sigcontext ksc;

	regs = p->p_md.md_regs;

	/*
	 * Allocate space for the signal handler context.
	 */
	fsize = sizeof(struct sigframe);
	if (!(psp->ps_siginfo & sigmask(sig)))
		fsize -= sizeof(siginfo_t);
	if ((p->p_sigstk.ss_flags & SS_DISABLE) == 0 &&
	    !sigonstack(regs->sp) && (psp->ps_sigonstack & sigmask(sig)))
		fp = (struct sigframe *)(p->p_sigstk.ss_sp +
					 p->p_sigstk.ss_size - fsize);
	else
		fp = (struct sigframe *)(regs->sp - fsize);
	/*
	 * Build the signal context to be used by sigreturn.
	 */
	bzero(&ksc, sizeof(ksc));
	ksc.sc_mask = mask;
	ksc.sc_pc = regs->pc;
	ksc.mullo = regs->mullo;
	ksc.mulhi = regs->mulhi;
	bcopy((caddr_t)&regs->ast, (caddr_t)&ksc.sc_regs[1],
		sizeof(ksc.sc_regs) - sizeof(register_t));
	ksc.sc_fpused = p->p_md.md_flags & MDP_FPUSED;
	if (ksc.sc_fpused) {
		/* if FPU has current state, save it first */
		if (p == ci->ci_fpuproc)
			save_fpu();

		bcopy((caddr_t)&p->p_md.md_regs->f0, (caddr_t)ksc.sc_fpregs,
			sizeof(ksc.sc_fpregs));
	}

	if (psp->ps_siginfo & sigmask(sig)) {
		siginfo_t si;

		initsiginfo(&si, sig, code, type, val);
		if (copyout((caddr_t)&si, (caddr_t)&fp->sf_si, sizeof si))
			goto bail;
	}

	ksc.sc_cookie = (long)&fp->sf_sc ^ p->p_p->ps_sigcookie;
	if (copyout((caddr_t)&ksc, (caddr_t)&fp->sf_sc, sizeof(ksc))) {
bail:
		/*
		 * Process has trashed its stack; give it an illegal
		 * instruction to halt it in its tracks.
		 */
		sigexit(p, SIGILL);
		/* NOTREACHED */
	}
	/*
	 * Build the argument list for the signal handler.
	 */
	regs->a0 = sig;
	regs->a1 = (psp->ps_siginfo & sigmask(sig)) ? (register_t)&fp->sf_si : 0;
	regs->a2 = (register_t)&fp->sf_sc;
	regs->a3 = (register_t)catcher;

	regs->pc = (register_t)catcher;
	regs->t9 = (register_t)catcher;
	regs->sp = (register_t)fp;

	regs->ra = p->p_p->ps_sigcode;
}

/*
 * System call to cleanup state after a signal
 * has been taken.  Reset signal mask and
 * stack state from context left by sendsig (above).
 * Return to previous pc and psl as specified by
 * context left by sendsig. Check carefully to
 * make sure that the user has not modified the
 * psl to gain improper privileges or to cause
 * a machine fault.
 */
/* ARGSUSED */
int
sys_sigreturn(struct proc *p, void *v, register_t *retval)
{
	struct cpu_info *ci = curcpu();
	struct sys_sigreturn_args /* {
		syscallarg(struct sigcontext *) sigcntxp;
	} */ *uap = v;
	struct sigcontext ksc, *scp = SCARG(uap, sigcntxp);
	struct trapframe *regs = p->p_md.md_regs;
	int error;

	if (PROC_PC(p) != p->p_p->ps_sigcoderet) {
		sigexit(p, SIGILL);
		return (EPERM);
	}

	/*
	 * Test and fetch the context structure.
	 * We grab it all at once for speed.
	 */
	error = copyin((caddr_t)scp, (caddr_t)&ksc, sizeof(ksc));
	if (error)
		return (error);

	if (ksc.sc_cookie != ((long)scp ^ p->p_p->ps_sigcookie)) {
		sigexit(p, SIGILL);
		return (EFAULT);
	}

	/* Prevent reuse of the sigcontext cookie */
	ksc.sc_cookie = 0;
	(void)copyout(&ksc.sc_cookie, (caddr_t)scp +
	    offsetof(struct sigcontext, sc_cookie), sizeof (ksc.sc_cookie));

	/*
	 * Restore the user supplied information
	 */
	p->p_sigmask = ksc.sc_mask &~ sigcantmask;
	regs->pc = ksc.sc_pc;
	regs->mullo = ksc.mullo;
	regs->mulhi = ksc.mulhi;
	regs->sr &= ~SR_COP_1_BIT;	/* Zap current FP state */
	if (p == ci->ci_fpuproc)
		ci->ci_fpuproc = NULL;
	bcopy((caddr_t)&ksc.sc_regs[1], (caddr_t)&regs->ast,
		sizeof(ksc.sc_regs) - sizeof(register_t));
	if (ksc.sc_fpused)
		bcopy((caddr_t)ksc.sc_fpregs, (caddr_t)&p->p_md.md_regs->f0,
			sizeof(ksc.sc_fpregs));
	return (EJUSTRETURN);
}
@


1.26
log
@SROP mitigation.  sendsig() stores a (per-process ^ &sigcontext) cookie
inside the sigcontext.  sigreturn(2) checks syscall entry was from the
exact PC addr in the (per-process ASLR) sigtramp, verifies the cookie,
and clears it to prevent sigcontext reuse.
not yet tested on landisk, sparc, *88k, socppc.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: sendsig.c,v 1.25 2016/03/06 19:42:27 mpi Exp $ */
d103 2
a104 6
sendsig(catcher, sig, mask, code, type, val)
	sig_t catcher;
	int sig, mask;
	u_long code;
	int type;
	union sigval val;
a127 6
#ifdef DEBUG
	if ((sigdebug & SDB_FOLLOW) ||
	    ((sigdebug & SDB_KSTACK) && (p->p_pid == sigpid)))
		printf("sendsig(%d): sig %d ssp %p usp %p scp %p\n",
		       p->p_pid, sig, &ksc, fp, &fp->sf_sc);
#endif
a135 1
	ksc.sc_regs[ZERO] = 0xACEDBADE;		/* magic number */
a178 6
#ifdef DEBUG
	if ((sigdebug & SDB_FOLLOW) ||
	    ((sigdebug & SDB_KSTACK) && (p->p_pid == sigpid)))
		printf("sendsig(%d): sig %d returns\n",
		       p->p_pid, sig);
#endif
d193 1
a193 4
sys_sigreturn(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d199 2
a200 3
	struct sigcontext *scp = SCARG(uap, sigcntxp);
	struct trapframe *regs;
	struct sigcontext ksc;
a202 6
#ifdef DEBUG
	if (sigdebug & SDB_FOLLOW)
		printf("sigreturn: pid %d, scp %p\n", p->p_pid, scp);
#endif
	regs = p->p_md.md_regs;

a203 2
		printf("%s(%d): sigreturn not from tramp [pc 0x%lx 0x%lx]\n",
		    p->p_comm, p->p_pid, PROC_PC(p), p->p_p->ps_sigcoderet);
a216 3
		printf("%s(%d): cookie %lx should have been %lx\n",
		    p->p_comm, p->p_pid, ksc.sc_cookie,
		    (long)scp ^ p->p_p->ps_sigcookie);
d224 1
a224 2
	    offsetof(struct sigcontext, sc_cookie),
	    sizeof (ksc.sc_cookie));
a225 1
	scp = &ksc;
d229 4
a232 4
	p->p_sigmask = scp->sc_mask &~ sigcantmask;
	regs->pc = scp->sc_pc;
	regs->mullo = scp->mullo;
	regs->mulhi = scp->mulhi;
d236 5
a240 5
	bcopy((caddr_t)&scp->sc_regs[1], (caddr_t)&regs->ast,
		sizeof(scp->sc_regs) - sizeof(register_t));
	if (scp->sc_fpused)
		bcopy((caddr_t)scp->sc_fpregs, (caddr_t)&p->p_md.md_regs->f0,
			sizeof(scp->sc_fpregs));
@


1.25
log
@Rename mips64's trap_frame into trapframe.

For coherency with other archs and in order to use it in MI code.

ok visa@@, tobiasu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sendsig.c,v 1.24 2015/02/09 08:48:23 miod Exp $ */
d167 1
d219 1
a219 1
	struct sigcontext *scp;
a223 1
	scp = SCARG(uap, sigcntxp);
d229 8
d242 9
a250 11
	if (error || ksc.sc_regs[ZERO] != 0xACEDBADE) {
#ifdef DEBUG
		if (!(sigdebug & SDB_FOLLOW))
			printf("sigreturn: pid %d, scp %p\n", p->p_pid, scp);
		printf("  old sp %lx ra %lx pc %lx\n",
			regs->sp, regs->ra, regs->pc);
		printf("  new sp %lx ra %lx pc %lx err %d z %lx\n",
			ksc.sc_regs[SP], ksc.sc_regs[RA], ksc.sc_regs[PC],
			error, ksc.sc_regs[ZERO]);
#endif
		return (EINVAL);
d252 7
@


1.24
log
@Do not even try to call uvm_grow() from sendsig. It will be invoked
automagically if copyout() of the signal frame faults.
@
text
@d1 1
a1 1
/*	$OpenBSD: sendsig.c,v 1.23 2015/01/02 22:38:46 sebastia Exp $ */
d113 1
a113 1
	struct trap_frame *regs;
d219 1
a219 1
	struct trap_frame *regs;
@


1.23
log
@Fix a few format string warnings, allow to build DEBUG kernel on sgi

OK miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sendsig.c,v 1.22 2014/03/26 05:23:42 guenther Exp $ */
d121 1
a121 5
	 * Allocate and validate space for the signal handler
	 * context. Note that if the stack is in data space, the
	 * call to grow() is a nop, and the copyout()
	 * will fail if the process has not already allocated
	 * the space with a `brk'.
a131 2
	if ((vaddr_t)fp <= USRSTACK - ptoa(p->p_vmspace->vm_ssize))
		(void)uvm_grow(p, (vaddr_t)fp);
@


1.22
log
@Move p_emul and p_sigcode from proc to process.
Tweak the handling of ktrace EMUL when changing ktracing: only
generate one per process (not one per thread) and pass the correct
proc pointer down to the VFS layer.  Permit generating of NAMI and
CSW records inside ktrace(2) itself.

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sendsig.c,v 1.21 2014/03/22 06:05:45 guenther Exp $ */
d141 1
a141 1
		printf("sendsig(%d): sig %d ssp %x usp %x scp %x\n",
d232 1
a232 1
		printf("sigreturn: pid %d, scp %x\n", p->p_pid, scp);
d243 2
a244 2
			printf("sigreturn: pid %d, scp %x\n", p->p_pid, scp);
		printf("  old sp %x ra %x pc %x\n",
d246 1
a246 1
		printf("  new sp %x ra %x pc %x err %d z %x\n",
@


1.21
log
@Move p_sigacts from struct proc to struct process.

testing help mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sendsig.c,v 1.20 2012/12/02 07:03:31 guenther Exp $ */
d194 1
a194 1
	regs->ra = p->p_sigcode;
@


1.20
log
@Determine whether we're currently on the alternative signal stack
dynamically, by comparing the stack pointer against the altstack
base and size, so that you get the correct answer if you longjmp
out of the signal handler, as tested by regress/sys/kern/stackjmp/.
Also, fix alt stack handling on vax, where it was completely broken.

Testing and corrections by miod@@, krw@@, tobiasu@@, pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sendsig.c,v 1.19 2012/10/03 11:18:23 miod Exp $ */
d114 1
a114 1
	struct sigacts *psp = p->p_sigacts;
@


1.19
log
@Split ever-growing mips <machine/cpu.h> into what 99% of the kernel needs,
which will remain in <machine/cpu.h>, and a new mips_cpu.h containing only the
goriest md details, which are only of interest to a handful set of files; this
is similar in spirit to what alpha does, but here <machine/cpu.h> does not
include the new file.
@
text
@d1 1
a1 1
/*	$OpenBSD: sendsig.c,v 1.18 2012/08/22 13:33:32 okan Exp $ */
d115 1
a115 1
	int oonstack, fsize;
d119 1
a119 1
	oonstack = p->p_sigstk.ss_flags & SA_ONSTACK;
d131 1
a131 2
	    (p->p_sigstk.ss_flags & SA_ONSTACK) == 0 &&
	    (psp->ps_sigonstack & sigmask(sig))) {
d134 1
a134 2
		p->p_sigstk.ss_flags |= SA_ONSTACK;
	} else
d142 1
a142 1
		       p->p_pid, sig, &oonstack, fp, &fp->sf_sc);
d147 1
a147 1
	ksc.sc_onstack = oonstack;
a255 4
	if (scp->sc_onstack & SA_ONSTACK)
		p->p_sigstk.ss_flags |= SA_ONSTACK;
	else
		p->p_sigstk.ss_flags &= ~SA_ONSTACK;
@


1.18
log
@sigpid should be of type pid_t (only visable with DEBUG).

ok miod@@ (who found others to fix as well)
@
text
@d1 1
a1 1
/*	$OpenBSD: sendsig.c,v 1.17 2011/07/05 04:48:01 guenther Exp $ */
d76 1
@


1.17
log
@Recommit the reverted sigacts change now that the NFS use-after-free
problem has been tracked down.  This fixes the sharing of the signal
handling state: shared bits go in sigacts, per-rthread bits goes in
struct proc.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sendsig.c,v 1.16 2011/04/18 21:44:55 guenther Exp $ */
d92 1
a92 1
int sigpid = 0;
@


1.16
log
@Revert the sigacts diff: NFS can apparently retain pointers to processes
until they're zombies and then send them signals (for intr mounts).  Until
that is untangled, the sigacts change is unsafe.  sthen@@ was the victim
for this one
@
text
@d1 1
a1 1
/*	$OpenBSD: sendsig.c,v 1.14 2011/04/07 15:30:15 miod Exp $ */
d118 1
a118 1
	oonstack = psp->ps_sigstk.ss_flags & SA_ONSTACK;
d129 2
a130 2
	if ((psp->ps_flags & SAS_ALTSTACK) &&
	    (psp->ps_sigstk.ss_flags & SA_ONSTACK) == 0 &&
d132 3
a134 3
		fp = (struct sigframe *)(psp->ps_sigstk.ss_sp +
					 psp->ps_sigstk.ss_size - fsize);
		psp->ps_sigstk.ss_flags |= SA_ONSTACK;
d258 1
a258 1
		p->p_sigacts->ps_sigstk.ss_flags |= SA_ONSTACK;
d260 1
a260 1
		p->p_sigacts->ps_sigstk.ss_flags &= ~SA_ONSTACK;
@


1.15
log
@Correct the sharing of the signal handling state: stuff that should
be shared (p_sigignore, p_sigcatch, P_NOCLDSTOP, P_NOCLDWAIT) moves
to struct sigacts, wihle stuff that should be per rthread (ps_oldmask,
SAS_OLDMASK, ps_sigstk) moves to struct proc.  Treat the coredumping
state bits (ps_sig, ps_code, ps_type, ps_sigval) as per-rthread
until our locking around coredumping is better.

Oh, and remove the old SunOS-compat ps_usertramp member.

"I like the sound of this" tedu@@
@
text
@d118 1
a118 1
	oonstack = p->p_sigstk.ss_flags & SA_ONSTACK;
d129 2
a130 2
	if ((p->p_sigstk.ss_flags & SS_DISABLE) == 0 &&
	    (p->p_sigstk.ss_flags & SA_ONSTACK) == 0 &&
d132 3
a134 3
		fp = (struct sigframe *)(p->p_sigstk.ss_sp +
					 p->p_sigstk.ss_size - fsize);
		p->p_sigstk.ss_flags |= SA_ONSTACK;
d258 1
a258 1
		p->p_sigstk.ss_flags |= SA_ONSTACK;
d260 1
a260 1
		p->p_sigstk.ss_flags &= ~SA_ONSTACK;
@


1.14
log
@Do not use NULL in integer comparisons. No functional change.
ok matthew@@ tedu@@, also eyeballed by at least krw@@ oga@@ kettenis@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sendsig.c,v 1.13 2010/06/26 23:24:43 guenther Exp $ */
d118 1
a118 1
	oonstack = psp->ps_sigstk.ss_flags & SA_ONSTACK;
d129 2
a130 2
	if ((psp->ps_flags & SAS_ALTSTACK) &&
	    (psp->ps_sigstk.ss_flags & SA_ONSTACK) == 0 &&
d132 3
a134 3
		fp = (struct sigframe *)(psp->ps_sigstk.ss_sp +
					 psp->ps_sigstk.ss_size - fsize);
		psp->ps_sigstk.ss_flags |= SA_ONSTACK;
d258 1
a258 1
		p->p_sigacts->ps_sigstk.ss_flags |= SA_ONSTACK;
d260 1
a260 1
		p->p_sigacts->ps_sigstk.ss_flags &= ~SA_ONSTACK;
@


1.13
log
@Don't #include <sys/user.h> into files that don't need the stuff
it defines.  In some cases, this means pulling in uvm.h or pcb.h
instead, but most of the inclusions were just noise.  Tested on
alpha, amd64, armish, hppa, i386, macpcc, sgi, sparc64, and vax,
mostly by krw and naddy.
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sendsig.c,v 1.12 2010/04/21 03:03:26 deraadt Exp $ */
d187 1
a187 1
	regs->a1 = (psp->ps_siginfo & sigmask(sig)) ? (register_t)&fp->sf_si : NULL;
@


1.12
log
@more cleanup to cope with the change that tries to make proc.h not act
like it is everything.h
ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: sendsig.c,v 1.11 2010/01/08 01:35:52 syuu Exp $ */
a68 1
#include <sys/user.h>
d72 2
@


1.11
log
@MP-safe FPU handling. ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sendsig.c,v 1.10 2008/05/04 09:57:47 martin Exp $ */
d68 1
@


1.10
log
@convert arm and mips64 platforms to ptoa/atop

tested by maja@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sendsig.c,v 1.9 2006/03/04 19:33:21 miod Exp $ */
d107 1
d156 3
a158 1
		extern struct proc *machFPCurProcPtr;
a159 7
		/* if FPU has current state, save it first */
		if (p == machFPCurProcPtr) {
			if (regs->sr & SR_FR_32)
				MipsSaveCurFPState(p);
			else
				MipsSaveCurFPState16(p);
		}
d219 1
a226 1
	extern struct proc *machFPCurProcPtr;
d264 2
a265 2
	if (p == machFPCurProcPtr) 
		machFPCurProcPtr = NULL;
@


1.9
log
@Typos grab bag of the month, eyeballed by jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sendsig.c,v 1.8 2005/12/20 06:58:19 miod Exp $ */
d134 1
a134 1
	if ((vaddr_t)fp <= USRSTACK - ctob(p->p_vmspace->vm_ssize))
@


1.8
log
@01 -> SA_ONSTACK in sigreturn.
@
text
@d1 1
a1 1
/*	$OpenBSD: sendsig.c,v 1.7 2005/12/17 21:10:24 kettenis Exp $ */
d213 1
a213 1
 * psl to gain improper priviledges or to cause
@


1.7
log
@Remove duplicate definition of machFPCurProcPtr.
ok pefo@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sendsig.c,v 1.6 2004/11/02 21:05:34 pefo Exp $ */
d150 1
a150 1
	ksc.sc_regs[0] = 0xACEDBADE;		/* magic number */
d259 1
a259 1
	if (scp->sc_onstack & 01)
@


1.6
log
@Fix problem with floating point restore at sigreturn.
Regress lib/libpthread/preemption_float now passes.
@
text
@d1 1
a1 1
/*	$OpenBSD: sendsig.c,v 1.5 2004/09/17 13:31:22 miod Exp $ */
a74 2
struct proc *machFPCurProcPtr;		/* pointer to last proc to use FP */

d230 1
@


1.5
log
@Properly setup register ra in sendsig() in 64bit world.
@
text
@d1 1
a1 1
/*	$OpenBSD: sendsig.c,v 1.4 2004/09/16 09:06:41 miod Exp $ */
d75 2
d268 3
@


1.4
log
@When copyout() of the signal frame fails, sigexit() the process instead of
doing this by an hand-delivered SIGILL.
@
text
@d1 1
a1 1
/*	$OpenBSD: sendsig.c,v 1.3 2004/08/10 20:15:47 deraadt Exp $ */
d152 1
a152 1
		sizeof(ksc.sc_regs) - sizeof(int));
@


1.3
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: sendsig.c,v 1.2 2004/08/09 14:57:26 pefo Exp $ */
d134 2
a135 2
	if ((long)fp <= USRSTACK - ctob(p->p_vmspace->vm_ssize))
		(void)uvm_grow(p, (long)fp);
d182 2
a183 7
		SIGACTION(p, SIGILL) = SIG_DFL;
		sig = sigmask(SIGILL);
		p->p_sigignore &= ~sig;
		p->p_sigcatch &= ~sig;
		p->p_sigmask &= ~sig;
		psignal(p, SIGILL);
		return;
@


1.2
log
@Big cleanup. Removed some unused obsolete stuff and fixed copyrights
on some files. Arcbios support is now in, thus detects memorysize and cpu
clock frequency.
@
text
@d1 1
a1 1
/*	$OpenBSD: sendsig.c,v 1.1 2004/08/06 20:56:03 pefo Exp $ */
d41 1
a41 1
 * 
d134 1
a134 1
	if ((long)fp <= USRSTACK - ctob(p->p_vmspace->vm_ssize)) 
d190 1
a190 1
	/* 
@


1.1
log
@initial mips64
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a49 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Opsycon AB, Sweden.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@

