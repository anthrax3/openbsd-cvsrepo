head	1.48;
access;
symbols
	OPENBSD_6_1:1.47.0.4
	OPENBSD_6_1_BASE:1.47
	OPENBSD_6_0:1.45.0.2
	OPENBSD_6_0_BASE:1.45
	OPENBSD_5_9:1.43.0.4
	OPENBSD_5_9_BASE:1.43
	OPENBSD_5_8:1.43.0.6
	OPENBSD_5_8_BASE:1.43
	OPENBSD_5_7:1.43.0.2
	OPENBSD_5_7_BASE:1.43
	OPENBSD_5_6:1.42.0.4
	OPENBSD_5_6_BASE:1.42
	OPENBSD_5_5:1.36.0.8
	OPENBSD_5_5_BASE:1.36
	OPENBSD_5_4:1.36.0.4
	OPENBSD_5_4_BASE:1.36
	OPENBSD_5_3:1.36.0.2
	OPENBSD_5_3_BASE:1.36
	OPENBSD_5_2:1.35.0.2
	OPENBSD_5_2_BASE:1.35
	OPENBSD_5_1_BASE:1.32
	OPENBSD_5_1:1.32.0.6
	OPENBSD_5_0:1.32.0.4
	OPENBSD_5_0_BASE:1.32
	OPENBSD_4_9:1.32.0.2
	OPENBSD_4_9_BASE:1.32
	OPENBSD_4_8:1.28.0.2
	OPENBSD_4_8_BASE:1.28
	OPENBSD_4_7:1.27.0.2
	OPENBSD_4_7_BASE:1.27
	OPENBSD_4_6:1.17.0.8
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.17.0.4
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.17.0.2
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.16.0.2
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.11.0.2
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.9.0.8
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.6
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.4
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.2
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.8.0.2
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.5.0.2
	OPENBSD_3_6_BASE:1.5;
locks; strict;
comment	@ * @;


1.48
date	2017.08.26.15.21.48;	author visa;	state Exp;
branches;
next	1.47;
commitid	S6Yyp9OyfdlsuUW2;

1.47
date	2016.09.19.17.59.19;	author jasper;	state Exp;
branches;
next	1.46;
commitid	34nXrfiWjgfvT3XN;

1.46
date	2016.08.14.08.23.52;	author visa;	state Exp;
branches;
next	1.45;
commitid	at8t1tG4p7ou4Cj7;

1.45
date	2016.03.06.19.42.27;	author mpi;	state Exp;
branches;
next	1.44;
commitid	cyYKarj4qRTft4gD;

1.44
date	2016.02.27.13.08.07;	author mpi;	state Exp;
branches;
next	1.43;
commitid	hnv9KfQtxhCytAnd;

1.43
date	2015.02.08.00.30.20;	author uebayasi;	state Exp;
branches;
next	1.42;
commitid	YarU7nXxm2yBgghs;

1.42
date	2014.07.13.12.11.01;	author jasper;	state Exp;
branches;
next	1.41;
commitid	XHZxhpAa5R1Ymp1z;

1.41
date	2014.07.09.12.58.08;	author miod;	state Exp;
branches;
next	1.40;
commitid	tzZYofASe0kXr1p9;

1.40
date	2014.05.19.21.18.42;	author miod;	state Exp;
branches;
next	1.39;

1.39
date	2014.05.10.22.25.16;	author jasper;	state Exp;
branches;
next	1.38;

1.38
date	2014.04.09.21.10.35;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2014.03.21.23.05.41;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2012.09.29.21.37.03;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2012.04.21.12.20.30;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2012.04.19.18.15.08;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2012.03.25.13.52.52;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2010.11.27.19.57.23;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2010.09.17.00.25.11;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2010.09.12.18.30.19;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2010.08.30.08.52.10;	author syuu;	state Exp;
branches;
next	1.28;

1.28
date	2010.05.10.22.14.43;	author kettenis;	state Exp;
branches;
next	1.27;

1.27
date	2010.01.21.17.50.44;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2010.01.16.23.28.10;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2010.01.14.07.24.43;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2010.01.13.22.55.54;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2010.01.09.23.34.29;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2010.01.09.20.33.16;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2009.12.25.21.02.15;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2009.11.21.23.56.56;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2009.11.19.20.16.27;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2009.07.22.21.15.42;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2008.06.22.21.02.10;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2008.02.29.19.00.39;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2008.02.18.19.47.36;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2007.10.22.14.46.46;	author jsing;	state Exp;
branches;
next	1.13;

1.13
date	2007.10.10.15.53.52;	author art;	state Exp;
branches;
next	1.12;

1.12
date	2007.09.03.01.15.50;	author krw;	state Exp;
branches;
next	1.11;

1.11
date	2007.05.03.19.34.00;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2007.03.22.18.55.20;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2005.05.22.19.40.51;	author art;	state Exp;
branches;
next	1.8;

1.8
date	2004.10.30.14.48.59;	author pefo;	state Exp;
branches;
next	1.7;

1.7
date	2004.10.20.12.49.15;	author pefo;	state Exp;
branches;
next	1.6;

1.6
date	2004.09.15.16.05.18;	author pefo;	state Exp;
branches;
next	1.5;

1.5
date	2004.09.09.22.11.38;	author pefo;	state Exp;
branches;
next	1.4;

1.4
date	2004.08.10.20.28.13;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.10.20.15.47;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2004.08.09.14.57.26;	author pefo;	state Exp;
branches;
next	1.1;

1.1
date	2004.08.06.20.56.03;	author pefo;	state Exp;
branches;
next	;


desc
@@


1.48
log
@Use copyin32() instead of a direct memory load when fetching a branch
instruction for branch emulation. This ensures the userspace memory
access is properly guarded and that TLB faults are handled.

In order not to complicate the interface of MipsEmulateBranch(), each
caller now has to provide the branch instruction for the function.

Feedback from miod@@
@
text
@/*	$OpenBSD: db_machdep.c,v 1.47 2016/09/19 17:59:19 jasper Exp $ */

/*
 * Copyright (c) 1998-2003 Opsycon AB (www.opsycon.se)
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <dev/cons.h>

#include <mips64/cache.h>

#include <machine/autoconf.h>
#include <machine/cpu.h>
#include <machine/db_machdep.h>
#include <machine/mips_opcode.h>
#include <machine/pte.h>
#include <machine/frame.h>
#include <machine/regnum.h>

#include <ddb/db_sym.h>
#include <ddb/db_extern.h>
#include <ddb/db_access.h>
#include <ddb/db_command.h>
#include <ddb/db_output.h>
#include <ddb/db_variables.h>
#include <ddb/db_interface.h>
#include <ddb/db_run.h>

#define MIPS_JR_RA        0x03e00008      /* instruction code for jr ra */

void  stacktrace_subr(db_regs_t *, int, int (*)(const char*, ...));

uint32_t kdbpeek(vaddr_t);
uint64_t kdbpeekd(vaddr_t);
uint16_t kdbpeekw(vaddr_t);
uint8_t  kdbpeekb(vaddr_t);
void  kdbpoke(vaddr_t, uint32_t);
void  kdbpoked(vaddr_t, uint64_t);
void  kdbpokew(vaddr_t, uint16_t);
void  kdbpokeb(vaddr_t, uint8_t);
int   db_ktrap(int, struct trapframe *);

void db_print_tlb(uint, uint64_t);
void db_trap_trace_cmd(db_expr_t, int, db_expr_t, char *);
void db_dump_tlb_cmd(db_expr_t, int, db_expr_t, char *);

#ifdef MULTIPROCESSOR
struct mutex ddb_mp_mutex = MUTEX_INITIALIZER(IPL_HIGH);
volatile int ddb_state = DDB_STATE_NOT_RUNNING;
volatile cpuid_t ddb_active_cpu;
boolean_t        db_switch_cpu;
long             db_switch_to_cpu;
#endif

int   db_active = 0;
db_regs_t ddb_regs;

#ifdef MULTIPROCESSOR
void db_cpuinfo_cmd(db_expr_t, int, db_expr_t, char *);
void db_startproc_cmd(db_expr_t, int, db_expr_t, char *);
void db_stopproc_cmd(db_expr_t, int, db_expr_t, char *);
void db_ddbproc_cmd(db_expr_t, int, db_expr_t, char *);
#endif

struct db_variable db_regs[] = {
    { "at",  (long *)&ddb_regs.ast,     FCN_NULL },
    { "v0",  (long *)&ddb_regs.v0,      FCN_NULL },
    { "v1",  (long *)&ddb_regs.v1,      FCN_NULL },
    { "a0",  (long *)&ddb_regs.a0,      FCN_NULL },
    { "a1",  (long *)&ddb_regs.a1,      FCN_NULL },
    { "a2",  (long *)&ddb_regs.a2,      FCN_NULL },
    { "a3",  (long *)&ddb_regs.a3,      FCN_NULL },
    { "a4",  (long *)&ddb_regs.a4,      FCN_NULL },
    { "a5",  (long *)&ddb_regs.a5,      FCN_NULL },
    { "a6",  (long *)&ddb_regs.a6,      FCN_NULL },
    { "a7",  (long *)&ddb_regs.a7,      FCN_NULL },
    { "t0",  (long *)&ddb_regs.t0,      FCN_NULL },
    { "t1",  (long *)&ddb_regs.t1,      FCN_NULL },
    { "t2",  (long *)&ddb_regs.t2,      FCN_NULL },
    { "t3",  (long *)&ddb_regs.t3,      FCN_NULL },
    { "s0",  (long *)&ddb_regs.s0,      FCN_NULL },
    { "s1",  (long *)&ddb_regs.s1,      FCN_NULL },
    { "s2",  (long *)&ddb_regs.s2,      FCN_NULL },
    { "s3",  (long *)&ddb_regs.s3,      FCN_NULL },
    { "s4",  (long *)&ddb_regs.s4,      FCN_NULL },
    { "s5",  (long *)&ddb_regs.s5,      FCN_NULL },
    { "s6",  (long *)&ddb_regs.s6,      FCN_NULL },
    { "s7",  (long *)&ddb_regs.s7,      FCN_NULL },
    { "t8",  (long *)&ddb_regs.t8,      FCN_NULL },
    { "t9",  (long *)&ddb_regs.t9,      FCN_NULL },
    { "k0",  (long *)&ddb_regs.k0,      FCN_NULL },
    { "k1",  (long *)&ddb_regs.k1,      FCN_NULL },
    { "gp",  (long *)&ddb_regs.gp,      FCN_NULL },
    { "sp",  (long *)&ddb_regs.sp,      FCN_NULL },
    { "s8",  (long *)&ddb_regs.s8,      FCN_NULL },
    { "ra",  (long *)&ddb_regs.ra,      FCN_NULL },
    { "sr",  (long *)&ddb_regs.sr,      FCN_NULL },
    { "lo",  (long *)&ddb_regs.mullo,   FCN_NULL },
    { "hi",  (long *)&ddb_regs.mulhi,   FCN_NULL },
    { "bad", (long *)&ddb_regs.badvaddr,FCN_NULL },
    { "cs",  (long *)&ddb_regs.cause,   FCN_NULL },
    { "pc",  (long *)&ddb_regs.pc,      FCN_NULL },
};
struct db_variable *db_eregs = db_regs + nitems(db_regs);

extern label_t  *db_recover;

int
db_ktrap(int type, struct trapframe *fp)
{
	switch(type) {
	case T_BREAK:		/* breakpoint */
		if (db_get_value((fp)->pc, sizeof(int), FALSE) == BREAK_SOVER) {
			(fp)->pc += BKPT_SIZE;
		}
		break;
	case -1:
		break;
	default:
#if 0
		if (!db_panic)
			return (0);
#endif
		if (db_recover != 0) {
			db_error("Caught exception in ddb.\n");
			/*NOTREACHED*/
		}
		printf("stopped on non ddb fault\n");
	}

#ifdef MULTIPROCESSOR
	mtx_enter(&ddb_mp_mutex);
	if (ddb_state == DDB_STATE_EXITING)
		ddb_state = DDB_STATE_NOT_RUNNING;
	mtx_leave(&ddb_mp_mutex);

	while (db_enter_ddb()) {
#endif
		bcopy((void *)fp, (void *)&ddb_regs, NUMSAVEREGS * sizeof(register_t));

		db_active++;
		cnpollc(TRUE);
		db_trap(type, 0);
		cnpollc(FALSE);
		db_active--;

		bcopy((void *)&ddb_regs, (void *)fp, NUMSAVEREGS * sizeof(register_t));
#ifdef MULTIPROCESSOR
		if (!db_switch_cpu)
			ddb_state = DDB_STATE_EXITING;
	}
#endif
	return(TRUE);
}

#ifdef MULTIPROCESSOR
int
db_enter_ddb(void)
{
	int i;
	struct cpu_info *ci = curcpu();
	mtx_enter(&ddb_mp_mutex);

#ifdef DEBUG
	printf("db_enter_ddb %d: state %x pause %x\n", ci->ci_cpuid,
	    ddb_state, ci->ci_ddb);
#endif
	/* If we are first in, grab ddb and stop all other CPUs */
	if (ddb_state == DDB_STATE_NOT_RUNNING) {
		ddb_active_cpu = cpu_number();
		ddb_state = DDB_STATE_RUNNING;
		ci->ci_ddb = CI_DDB_INDDB;
		for (i = 0; i < ncpus; i++) {
			if (i != cpu_number() &&
			    get_cpu_info(i)->ci_ddb != CI_DDB_STOPPED) {
				get_cpu_info(i)->ci_ddb = CI_DDB_SHOULDSTOP;
				mips64_send_ipi(get_cpu_info(i)->ci_cpuid, MIPS64_IPI_DDB);
			}
		}
		mtx_leave(&ddb_mp_mutex);
		return (1);
	}

	/* Leaving ddb completely.  Start all other CPUs and return 0 */
	if (ddb_active_cpu == cpu_number() && ddb_state == DDB_STATE_EXITING) {
		for (i = 0; i < ncpus; i++) {
			get_cpu_info(i)->ci_ddb = CI_DDB_RUNNING;
		}
		mtx_leave(&ddb_mp_mutex);
		return (0);
	}

	/* We are switching to another CPU. ddb_ddbproc_cmd() has made sure
	 * it is waiting for ddb, we just have to set ddb_active_cpu. */
	if (ddb_active_cpu == cpu_number() && db_switch_cpu) {
		ci->ci_ddb = CI_DDB_SHOULDSTOP;
		db_switch_cpu = 0;
		ddb_active_cpu = db_switch_to_cpu;
		get_cpu_info(db_switch_to_cpu)->ci_ddb = CI_DDB_ENTERDDB;
	}

	/* Wait until we should enter ddb or resume */
	while (ddb_active_cpu != cpu_number() &&
	    ci->ci_ddb != CI_DDB_RUNNING) {
		if (ci->ci_ddb == CI_DDB_SHOULDSTOP)
			ci->ci_ddb = CI_DDB_STOPPED;
		mtx_leave(&ddb_mp_mutex);
		/* Busy wait without locking, we will confirm with lock later */
		while (ddb_active_cpu != cpu_number() &&
		    ci->ci_ddb != CI_DDB_RUNNING)
			;	/* Do nothing */
		mtx_enter(&ddb_mp_mutex);
	}

	/* Either enter ddb or exit */
	if (ddb_active_cpu == cpu_number() && ddb_state == DDB_STATE_RUNNING) {
		ci->ci_ddb = CI_DDB_INDDB;
		mtx_leave(&ddb_mp_mutex);
		return (1);
	} else {
		mtx_leave(&ddb_mp_mutex);
		return (0);
	}
}

void
db_cpuinfo_cmd(db_expr_t addr, int have_addr, db_expr_t count, char *modif)
{
	int i;

	for (i = 0; i < ncpus; i++) {
		db_printf("%c%4ld: ", (i == cpu_number()) ? '*' : ' ',
		    get_cpu_info(i)->ci_cpuid);
		switch(get_cpu_info(i)->ci_ddb) {
		case CI_DDB_RUNNING:
			db_printf("running\n");
			break;
		case CI_DDB_SHOULDSTOP:
			db_printf("stopping\n");
			break;
		case CI_DDB_STOPPED:
			db_printf("stopped\n");
			break;
		case CI_DDB_ENTERDDB:
			db_printf("entering ddb\n");
			break;
		case CI_DDB_INDDB:
			db_printf("ddb\n");
			break;
		default:
			db_printf("? (%d)\n",
			    get_cpu_info(i)->ci_ddb);
			break;
		}
	}
}
#endif

void
db_read_bytes(vaddr_t addr, size_t size, char *data)
{
	while (size >= sizeof(uint32_t)) {
		*(uint32_t *)data = kdbpeek(addr);
		data += sizeof(uint32_t);
		addr += sizeof(uint32_t);
		size -= sizeof(uint32_t);
	}

	if (size >= sizeof(uint16_t)) {
		*(uint16_t *)data = kdbpeekw(addr);
		data += sizeof(uint16_t);
		addr += sizeof(uint16_t);
		size -= sizeof(uint16_t);
	}

	if (size)
		*(uint8_t *)data = kdbpeekb(addr);
}

void
db_write_bytes(vaddr_t addr, size_t size, char *data)
{
	vaddr_t ptr = addr;
	size_t len = size;

	while (len >= sizeof(uint32_t)) {
		kdbpoke(ptr, *(uint32_t *)data);
		data += sizeof(uint32_t);
		ptr += sizeof(uint32_t);
		len -= sizeof(uint32_t);
	}

	if (len >= sizeof(uint16_t)) {
		kdbpokew(ptr, *(uint16_t *)data);
		data += sizeof(uint16_t);
		ptr += sizeof(uint16_t);
		len -= sizeof(uint16_t);
	}

	if (len)
		kdbpokeb(ptr, *(uint8_t *)data);

	if (addr < VM_MAXUSER_ADDRESS) {
		struct cpu_info *ci = curcpu();

		Mips_HitSyncDCache(ci, addr, size);
		Mips_InvalidateICache(ci, addr, size);
	}
}

void
db_stack_trace_print(db_expr_t addr, boolean_t have_addr, db_expr_t count,
    char *modif, int (*pr)(const char *, ...))
{
	struct trapframe *regs = &ddb_regs;

	if (have_addr) {
		(*pr)("mips trace requires a trap frame... giving up\n");
		return;
	}

	stacktrace_subr(regs, count, pr);
}

/*
 *	To do a single step ddb needs to know the next address
 *	that we will get to. It means that we need to find out
 *	both the address for a branch taken and for not taken, NOT! :-)
 *	MipsEmulateBranch will do the job to find out _exactly_ which
 *	address we will end up at so the 'dual bp' method is not
 *	required.
 */
db_addr_t
next_instr_address(db_addr_t pc, boolean_t bd)
{
	db_addr_t next;
	uint32_t instr;

	instr = kdbpeek(pc);
	next = MipsEmulateBranch(&ddb_regs, (vaddr_t)pc, 0, instr);
	return (next);
}

/*
 *  MIPS machine dependent DDB commands.
 */

/*
 *  Do a trap traceback.
 */
void
db_trap_trace_cmd(db_expr_t addr, int have_addr, db_expr_t count, char *m)
{
	trapDump("ddb trap trace", db_printf);
}

void
db_print_tlb(uint tlbno, uint64_t tlblo)
{
	paddr_t pa;
#ifndef CPU_R8000
	/* short description of coherency attributes */
	static const char *attr[] = {
		"CCA 0",
		"CCA 1",
		"NC   ",
		"C    ",
		"CEX  ",
		"CEXW ",
		"CCA 6",
		"NCACC"
	};
#endif

	pa = pfn_to_pad(tlblo);
#ifdef CPU_R8000
	pa |= ptoa(tlbno % 128);
#endif
	if (tlblo & PG_V) {
		db_printf("%016lx ", pa);
#ifdef CPU_MIPS64R2
		db_printf("%c", tlblo & PG_XI ? 'X' : ' ');
#endif
		db_printf("%c", tlblo & PG_M ? 'M' : ' ');
#ifndef CPU_R8000
		db_printf("%c", tlblo & PG_G ? 'G' : ' ');
		db_printf("%s ", attr[(tlblo >> 3) & 7]);
#endif
	} else {
		db_printf("invalid                 ");
	}
}

/*
 *	Dump TLB contents.
 * Syntax: machine tlb [/p asid] [/c] [tlb#]
 *	/p: only display tlb entries matching the given asid
 *	/c: check for duplicate entries
 *	tlb#: display <count> entries starting from this index
 */
void
db_dump_tlb_cmd(db_expr_t addr, int have_addr, db_expr_t count, char *m)
{
	int tlbno, last, check, pid;
	struct tlb_entry tlb, tlbp;
	struct cpu_info *ci = curcpu();

	pid = -1;

	if (m[0] == 'p') {
		if (have_addr && addr < PG_ASID_COUNT) {
			pid = addr;
		}
		tlbno = 0;
		count = ci->ci_hw.tlbsize;
	} else if (m[0] == 'c') {
		last = ci->ci_hw.tlbsize;
		for (tlbno = 0; tlbno < last; tlbno++) {
			tlb_read(tlbno, &tlb);
			for (check = tlbno + 1; check < last; check++) {
				tlb_read(check, &tlbp);
				if ((tlbp.tlb_hi == tlb.tlb_hi &&
				    (tlb.tlb_lo0 & PG_V || tlb.tlb_lo1 & PG_V)) ||
				    (pfn_to_pad(tlb.tlb_lo0) ==
				     pfn_to_pad(tlbp.tlb_lo0) &&
				     tlb.tlb_lo0 & PG_V) ||
				    (pfn_to_pad(tlb.tlb_lo1) ==
				     pfn_to_pad(tlbp.tlb_lo1) &&
				     tlb.tlb_lo1 & PG_V)) {
					db_printf("MATCH:\n");
					db_dump_tlb_cmd(tlbno, 1, 1, "");
					db_dump_tlb_cmd(check, 1, 1, "");
				}
			}
		}
		return;
	} else {
		if (have_addr && addr < ci->ci_hw.tlbsize) {
			tlbno = addr;
		} else {
			tlbno = 0;
			count = ci->ci_hw.tlbsize;
		}
	}
	last = tlbno + count;
	if (last > ci->ci_hw.tlbsize)
		last = ci->ci_hw.tlbsize;

	if (pid == -1)
		db_printf("current asid: %d\n", tlb_get_pid());
	for (; tlbno < last; tlbno++) {
		tlb_read(tlbno, &tlb);

		if (pid >= 0 &&
		    (tlb.tlb_hi & PG_ASID_MASK) != (pid << PG_ASID_SHIFT))
			continue;

		if (tlb.tlb_lo0 & PG_V || tlb.tlb_lo1 & PG_V) {
			vaddr_t va;
			uint asid;

			asid = (tlb.tlb_hi & PG_ASID_MASK) >> PG_ASID_SHIFT;
			va = tlb.tlb_hi & ~((vaddr_t)PG_ASID_MASK);
#ifdef CPU_R8000
			if ((int64_t)va < 0)
				asid = 0;	/* KV1 addresses ignore ASID */
			va |= ptoa((tlbno ^ asid) % 128);
#endif
			db_printf("%3d v=%016lx", tlbno, va);
			db_printf("/%02x ", asid);

			db_print_tlb(tlbno, tlb.tlb_lo0);
#ifndef CPU_R8000
			db_print_tlb(tlbno, tlb.tlb_lo1);
			db_printf(" sz=%llx", tlb.tlb_mask);
#endif
		} else if (pid < 0) {
			db_printf("%3d v=invalid    ", tlbno);
		}
		db_printf("\n");
	}
}


struct db_command mips_db_command_table[] = {
	{ "tlb",	db_dump_tlb_cmd,	0,	NULL },
	{ "trap",	db_trap_trace_cmd,	0,	NULL },
#ifdef MULTIPROCESSOR
	{ "cpuinfo",    db_cpuinfo_cmd,         0,      NULL },
	{ "startcpu",   db_startproc_cmd,       0,      NULL },
	{ "stopcpu",    db_stopproc_cmd,        0,      NULL },
	{ "ddbcpu",     db_ddbproc_cmd,         0,      NULL },
#endif
	{ NULL,		NULL,			0,	NULL }
};

void
db_machine_init(void)
{
	extern char *ssym;
#ifdef MULTIPROCESSOR
	int i;
#endif

	db_machine_commands_install(mips_db_command_table);
#ifdef MULTIPROCESSOR
	for (i = 0; i < ncpus; i++) {
		get_cpu_info(i)->ci_ddb = CI_DDB_RUNNING;
	}
#endif
	if (ssym != NULL) {
		ddb_init();	/* Init symbols */
	}
}

#ifdef MULTIPROCESSOR
void
db_ddbproc_cmd(db_expr_t addr, int have_addr, db_expr_t count, char *modif)
{
	int cpu_n;

	if (have_addr) {
		cpu_n = addr;
		if (cpu_n >= 0 && cpu_n < ncpus &&
		    cpu_n != cpu_number()) {
			db_stopcpu(cpu_n);
			db_switch_to_cpu = cpu_n;
			db_switch_cpu = 1;
			db_cmd_loop_done = 1;
		} else {
			db_printf("Invalid cpu %d\n", (int)addr);
		}
	} else {
		db_printf("CPU not specified\n");
	}
}

void
db_startproc_cmd(db_expr_t addr, int have_addr, db_expr_t count, char *modif)
{
	int cpu_n;

	if (have_addr) {
		cpu_n = addr;
		if (cpu_n >= 0 && cpu_n < ncpus &&
		    cpu_n != cpu_number())
			db_startcpu(cpu_n);
		else
			db_printf("Invalid cpu %d\n", (int)addr);
	} else {
		for (cpu_n = 0; cpu_n < ncpus; cpu_n++) {
			if (cpu_n != cpu_number()) {
				db_startcpu(cpu_n);
			}
		}
	}
}

void
db_stopproc_cmd(db_expr_t addr, int have_addr, db_expr_t count, char *modif)
{
	int cpu_n;

	if (have_addr) {
		cpu_n = addr;
		if (cpu_n >= 0 && cpu_n < ncpus &&
		    cpu_n != cpu_number())
			db_stopcpu(cpu_n);
		else
			db_printf("Invalid cpu %d\n", (int)addr);
	} else {
		for (cpu_n = 0; cpu_n < ncpus; cpu_n++) {
			if (cpu_n != cpu_number()) {
				db_stopcpu(cpu_n);
			}
		}
	}
}

void
db_startcpu(int cpu)
{
	if (cpu != cpu_number() && cpu < ncpus) {
		mtx_enter(&ddb_mp_mutex);
		get_cpu_info(cpu)->ci_ddb = CI_DDB_RUNNING;
		mtx_leave(&ddb_mp_mutex);
	}
}

void
db_stopcpu(int cpu)
{
	mtx_enter(&ddb_mp_mutex);
	if (cpu != cpu_number() && cpu < ncpus &&
	    get_cpu_info(cpu)->ci_ddb != CI_DDB_STOPPED) {
		get_cpu_info(cpu)->ci_ddb = CI_DDB_SHOULDSTOP;
		mtx_leave(&ddb_mp_mutex);
		mips64_send_ipi(cpu, MIPS64_IPI_DDB);
	} else {
		mtx_leave(&ddb_mp_mutex);
	}
}
#endif
@


1.47
log
@fix whitespace at EOL
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.c,v 1.46 2016/08/14 08:23:52 visa Exp $ */
d361 1
d363 3
a365 2
	next = MipsEmulateBranch(&ddb_regs, (vaddr_t)pc, 0, 0);
	return(next);
@


1.46
log
@Utilize the TLB Execute-Inhibit bit with non-executable mappings on CPUs
that support the Execute-Inhibit exception. This makes user space W^X
effective on Octeon Plus and later Octeon versions.

Feedback from miod@@, thanks!
No objection from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.c,v 1.45 2016/03/06 19:42:27 mpi Exp $ */
d154 1
a154 1
	
d160 1
a160 1
	
d170 1
a170 1
		
d515 1
a515 1
#endif   
d585 1
a585 1
	
d610 1
a610 1
}   
d618 1
a618 1
		get_cpu_info(cpu)->ci_ddb = CI_DDB_SHOULDSTOP;  
@


1.45
log
@Rename mips64's trap_frame into trapframe.

For coherency with other archs and in order to use it in MI code.

ok visa@@, tobiasu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.c,v 1.44 2016/02/27 13:08:07 mpi Exp $ */
d403 3
@


1.44
log
@Rename kdb_trap() into db_ktrap().

The goal is to include it in the list of functions that must not be
instrumented.  All ddb(8) functions should be in this list and have
their names start with 'db_'.

ok visa@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.c,v 1.43 2015/02/08 00:30:20 uebayasi Exp $ */
d65 1
a65 1
int   db_ktrap(int, struct trap_frame *);
d133 1
a133 1
db_ktrap(int type, struct trap_frame *fp)
d339 1
a339 1
	struct trap_frame *regs = &ddb_regs;
@


1.43
log
@Style.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d65 1
a65 1
int   kdb_trap(int, struct trap_frame *);
d133 1
a133 1
kdb_trap(int type, struct trap_frame *fp)
@


1.42
log
@use nitems() instead of handrolling something identical

ok mpi@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.c,v 1.41 2014/07/09 12:58:08 miod Exp $ */
d133 1
a133 3
kdb_trap(type, fp)
	int type;
	struct trap_frame *fp;
a249 1

d284 1
a284 4
db_read_bytes(addr, size, data)
	vaddr_t addr;
	size_t      size;
	char       *data;
d305 1
a305 4
db_write_bytes(addr, size, data)
	vaddr_t addr;
	size_t      size;
	char       *data;
d336 2
a337 6
db_stack_trace_print(addr, have_addr, count, modif, pr)
	db_expr_t	addr;
	boolean_t	have_addr;
	db_expr_t	count;
	char		*modif;
	int		(*pr)(const char *, ...);
a365 1

d386 8
a393 8
	    "CCA 0",
	    "CCA 1",
	    "NC   ",
	    "C    ",
	    "CEX  ",
	    "CEXW ",
	    "CCA 6",
	    "NCACC"
d517 1
a517 1
db_machine_init()
d519 1
a523 1
extern char *ssym;
a533 1

@


1.41
log
@Do the way long overdue renaming of register names from o32 to n64 ABI.
In other words, ta0-ta3 are now a4-a7 instead of t0-t3; and the former t4-t7
are now t0-t3.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.c,v 1.40 2014/05/19 21:18:42 miod Exp $ */
d128 1
a128 1
struct db_variable *db_eregs = db_regs + sizeof(db_regs)/sizeof(db_regs[0]);
@


1.40
log
@Format string fixes and removal of -Wno-format for sgi. Based upon an
initial diff from jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.c,v 1.39 2014/05/10 22:25:16 jasper Exp $ */
d97 8
a104 8
    { "a4",  (long *)&ddb_regs.t0,      FCN_NULL },
    { "a5",  (long *)&ddb_regs.t1,      FCN_NULL },
    { "a6",  (long *)&ddb_regs.t2,      FCN_NULL },
    { "a7",  (long *)&ddb_regs.t3,      FCN_NULL },
    { "t0",  (long *)&ddb_regs.t4,      FCN_NULL },
    { "t1",  (long *)&ddb_regs.t5,      FCN_NULL },
    { "t2",  (long *)&ddb_regs.t6,      FCN_NULL },
    { "t3",  (long *)&ddb_regs.t7,      FCN_NULL },
@


1.39
log
@various format string fixes and remove -Wno-format from octeon

feedback/ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.c,v 1.38 2014/04/09 21:10:35 miod Exp $ */
d259 1
a259 1
		db_printf("%c%4d: ", (i == cpu_number()) ? '*' : ' ',
@


1.38
log
@Make trapDump() take the printf-like function as a 2nd parameter.
No functional change; helps non-released kernels with extra debugging code (-:
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.c,v 1.37 2014/03/21 23:05:41 miod Exp $ */
d502 1
a502 1
			db_printf("%3d v=%016llx", tlbno, va);
d508 1
a508 1
			db_printf(" sz=%x", tlb.tlb_mask);
@


1.37
log
@Rename db_inst_type() into classify_insn() and make that function available
outside of ddb. It will be used by regular kernel code shortly.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.c,v 1.36 2012/09/29 21:37:03 miod Exp $ */
d390 1
a390 1
	trapDump("ddb trap trace");
@


1.36
log
@Basic R8000 processor support. R8000 processors require MMU-specific code,
exception-specific code, clock-specific code, and L1 cache-specific code. L2
cache is per-design, of which only two exist: SGI Power Indigo2 (IP26) and SGI
Power Challenge (IP21) and are not covered by this commit.

R8000 processors also are 64-bit only processors with 64-bit coprocessor 0
registers, and lack so-called ``compatibility'' memory spaces allowing 32-bit
code to run with sign-extended addresses and registers.

The intrusive changes are covered by #ifdef CPU_R8000 stanzas. However,
trap() is split into a high-level wrapper and a new function, itsa(),
responsible for the actual trap servicing (which name couldn't be helped
because I'm an incorrigible punster). While an R8000 exception may cause
(via trap() ) multiple exceptions to be serviced, non-R8000 processors will
always service one exception in trap(), but they are nevertheless affected
by this code split.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.c,v 1.35 2012/04/21 12:20:30 miod Exp $ */
a378 69

/*
 *	Decode instruction and figure out type.
 */
int
db_inst_type(ins)
	int	ins;
{
	InstFmt	inst;
	int	ityp = 0;

	inst.word = ins;
	switch ((int)inst.JType.op) {
	case OP_SPECIAL:
		switch ((int)inst.RType.func) {
		case OP_JR:
			ityp = IT_BRANCH;
			break;
		case OP_JALR:
		case OP_SYSCALL:
			ityp = IT_CALL;
			break;
		}
		break;

	case OP_BCOND:
		switch ((int)inst.IType.rt) {
		case OP_BLTZ:
		case OP_BLTZL:
		case OP_BGEZ:
		case OP_BGEZL:
			ityp = IT_BRANCH;
			break;

		case OP_BLTZAL:
		case OP_BLTZALL:
		case OP_BGEZAL:
		case OP_BGEZALL:
			ityp = IT_CALL;
			break;
		}
		break;

	case OP_JAL:
		ityp = IT_CALL;
		break;

	case OP_J:
	case OP_BEQ:
	case OP_BEQL:
	case OP_BNE:
	case OP_BNEL:
	case OP_BLEZ:
	case OP_BLEZL:
	case OP_BGTZ:
	case OP_BGTZL:
		ityp = IT_BRANCH;
		break;

	case OP_COP1:
		switch (inst.RType.rs) {
		case OP_BC:
			ityp = IT_BRANCH;
			break;
		}
		break;
	}
	return (ityp);
}
@


1.35
log
@Rework the signature of the cache handling routines again. It makes more sense
to pass both the virtual and physical addresses of the page to clean to
SyncDCachePage, which is the only routine using `Index' operations on the data
cache, which might be virtually indexed at some levels but physically indexed
at others. On the other hand, it does not make any sense to pass a physical
address to routines using `Hit' operations (and they were discarding them
anyway).

In addition to making things cleaner, this fixes sporadic userland misbehaviour
(read: SIGSGEV) on RM7000 O2 systems.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.c,v 1.34 2012/04/19 18:15:08 miod Exp $ */
d67 1
d462 34
d498 4
a508 3
char *attr[] = {
	"WTNA", "WTA ", "UCBL", "CWB ", "RES ", "RES ", "UCNB", "BPAS"
};
d513 1
a513 1
		if (have_addr && addr < 256) {
a514 2
			tlbno = 0;
			count = ci->ci_hw.tlbsize;
d516 2
d524 8
a531 3
if ((tlbp.tlb_hi == tlb.tlb_hi && (tlb.tlb_lo0 & PG_V || tlb.tlb_lo1 & PG_V)) ||
(pfn_to_pad(tlb.tlb_lo0) == pfn_to_pad(tlbp.tlb_lo0) && tlb.tlb_lo0 & PG_V) ||
(pfn_to_pad(tlb.tlb_lo1) == pfn_to_pad(tlbp.tlb_lo1) && tlb.tlb_lo1 & PG_V)) {
d548 2
d553 1
a553 1
	for (; tlbno < ci->ci_hw.tlbsize && tlbno < last; tlbno++) {
d556 2
a557 1
		if (pid >= 0 && (tlb.tlb_hi & 0xff) != pid)
d561 2
a562 2
			db_printf("%2d v=%16llx", tlbno, tlb.tlb_hi & ~0xffL);
			db_printf("/%02x ", tlb.tlb_hi & 0xff);
d564 9
a572 8
			if (tlb.tlb_lo0 & PG_V) {
				db_printf("%16llx ", pfn_to_pad(tlb.tlb_lo0));
				db_printf("%c", tlb.tlb_lo0 & PG_M ? 'M' : ' ');
				db_printf("%c", tlb.tlb_lo0 & PG_G ? 'G' : ' ');
				db_printf("%s ", attr[(tlb.tlb_lo0 >> 3) & 7]);
			} else {
				db_printf("invalid                 ");
			}
d574 3
a576 8
			if (tlb.tlb_lo1 & PG_V) {
				db_printf("%16llx ", pfn_to_pad(tlb.tlb_lo1));
				db_printf("%c", tlb.tlb_lo1 & PG_M ? 'M' : ' ');
				db_printf("%c", tlb.tlb_lo1 & PG_G ? 'G' : ' ');
				db_printf("%s ", attr[(tlb.tlb_lo1 >> 3) & 7]);
			} else {
				db_printf("invalid                 ");
			}
d578 3
a580 3
		}
		else if (pid < 0) {
			db_printf("%2d v=invalid    ", tlbno);
@


1.34
log
@Print the currently active ASID in `machine tlb' ddb command.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.c,v 1.33 2012/03/25 13:52:52 miod Exp $ */
d338 2
a339 4
		/* XXX we don't know where this page is mapped... */
		Mips_HitSyncDCache(ci, addr, PHYS_TO_XKPHYS(addr, CCA_CACHED),
		    size);
		Mips_InvalidateICache(ci, PHYS_TO_CKSEG0(addr & 0xffff), size);
@


1.33
log
@Move cache handling routines related definitions to a dedicated header file,
rather than abusing <machine/cpu.h>.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.c,v 1.32 2010/11/27 19:57:23 miod Exp $ */
a69 1

d510 2
@


1.32
log
@Remove ddb single-step load and store counters. Most platforms do not
implement them, and they are of questionable usefulness.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.c,v 1.31 2010/09/17 00:25:11 miod Exp $ */
d34 2
d37 1
a38 1
#include <machine/cpu.h>
@


1.31
log
@There is only one code for coprocessor BC opcodes, so don't bother to handle
a second (invalid) opcode; confirmed by all mips core documentation.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.c,v 1.30 2010/09/12 18:30:19 miod Exp $ */
a443 19
		break;

	case OP_LB:
	case OP_LH:
	case OP_LW:
	case OP_LD:
	case OP_LBU:
	case OP_LHU:
	case OP_LWU:
	case OP_LWC1:
		ityp = IT_LOAD;
		break;

	case OP_SB:
	case OP_SH:
	case OP_SW:
	case OP_SD:
	case OP_SWC1:
		ityp = IT_STORE;
@


1.30
log
@Stricter types in MipsEmulateBranch(), and related cleanups.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.c,v 1.29 2010/08/30 08:52:10 syuu Exp $ */
d440 1
a440 2
		case OP_BCx:
		case OP_BCy:
@


1.29
log
@ddbcpu for sgi. ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.c,v 1.28 2010/05/10 22:14:43 kettenis Exp $ */
a52 2
extern void trapDump(char *);
u_long MipsEmulateBranch(db_regs_t *, int, int, u_int);
d375 1
a375 1
	next = MipsEmulateBranch(&ddb_regs, pc, 0, 0);
@


1.28
log
@Don't postincrement a casted pointer; split into multiple statements instead.
Makes gcc4 happy.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.c,v 1.27 2010/01/21 17:50:44 miod Exp $ */
d49 1
d70 9
d82 7
d156 62
d219 32
a250 1
	bcopy((void *)fp, (void *)&ddb_regs, NUMSAVEREGS * sizeof(register_t));
a251 5
	db_active++;
	cnpollc(TRUE);
	db_trap(type, 0);
	cnpollc(FALSE);
	db_active--;
d253 30
a282 2
	bcopy((void *)&ddb_regs, (void *)fp, NUMSAVEREGS * sizeof(register_t));
	return(TRUE);
d284 1
d571 6
d583 4
d589 5
d598 90
@


1.27
log
@Use db_printf() instead of printf() in db_dump_tlb_cmd() and trapDump(), so
that the output can be paused by ddb if it spans too many lines.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.c,v 1.26 2010/01/16 23:28:10 miod Exp $ */
d159 2
a160 1
		*((uint32_t *)data)++ = kdbpeek(addr);
d166 2
a167 1
		*((uint16_t *)data)++ = kdbpeekw(addr);
d186 2
a187 1
		kdbpoke(ptr, *((uint32_t *)data)++);
d193 2
a194 1
		kdbpokew(ptr, *((uint16_t *)data)++);
@


1.26
log
@Merge db_stack_trace_print() and stacktrace() logic, and have the former
invoke the latter to avoid duplicating code.
Fix the logic by looking for `sd' instructions for register saves only,
and read the whole 64-bit value then. Makes the backtraces less wrong.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.c,v 1.25 2010/01/14 07:24:43 miod Exp $ */
d376 1
a376 1
					printf("MATCH:\n");
d400 2
a401 2
			printf("%2d v=%16llx", tlbno, tlb.tlb_hi & ~0xffL);
			printf("/%02x ", tlb.tlb_hi & 0xff);
d404 4
a407 4
				printf("%16llx ", pfn_to_pad(tlb.tlb_lo0));
				printf("%c", tlb.tlb_lo0 & PG_M ? 'M' : ' ');
				printf("%c", tlb.tlb_lo0 & PG_G ? 'G' : ' ');
				printf("%s ", attr[(tlb.tlb_lo0 >> 3) & 7]);
d409 1
a409 1
				printf("invalid             ");
d413 4
a416 4
				printf("%16llx ", pfn_to_pad(tlb.tlb_lo1));
				printf("%c", tlb.tlb_lo1 & PG_M ? 'M' : ' ');
				printf("%c", tlb.tlb_lo1 & PG_G ? 'G' : ' ');
				printf("%s ", attr[(tlb.tlb_lo1 >> 3) & 7]);
d418 1
a418 1
				printf("invalid             ");
d420 1
a420 1
			printf(" sz=%x", tlb.tlb_mask);
d423 1
a423 1
			printf("%2d v=invalid    ", tlbno);
d425 1
a425 1
		printf("\n");
@


1.25
log
@When trying to get a stack trace, consider CKSEG1 addresses as invalid, as the
kernel will never use them for code or stack.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.c,v 1.24 2010/01/13 22:55:54 miod Exp $ */
d54 1
a54 1
void  stacktrace_subr(db_regs_t *, int (*)(const char*, ...));
d56 8
a63 8
int   kdbpeek(void *);
int64_t kdbpeekd(void *);
short kdbpeekw(void *);
char  kdbpeekb(void *);
void  kdbpoke(vaddr_t, int);
void  kdbpoked(vaddr_t, int64_t);
void  kdbpokew(vaddr_t, short);
void  kdbpokeb(vaddr_t, char);
d158 4
a161 4
	while (size >= sizeof(int)) {
		*((int *)data)++ = kdbpeek((void *)addr);
		addr += sizeof(int);
		size -= sizeof(int);
d164 4
a167 4
	if (size >= sizeof(short)) {
		*((short *)data)++ = kdbpeekw((void *)addr);
		addr += sizeof(short);
		size -= sizeof(short);
d170 2
a171 3
	if (size) {
		*data++ = kdbpeekb((void *)addr);
	}
d183 4
a186 4
	while (len >= sizeof(int)) {
		kdbpoke(ptr, *((int *)data)++);
		ptr += sizeof(int);
		len -= sizeof(int);
d189 4
a192 4
	if (len >= sizeof(short)) {
		kdbpokew(ptr, *((short *)data)++);
		ptr += sizeof(int);
		len -= sizeof(int);
d195 3
a197 3
	if (len) {
		kdbpokeb(ptr, *data++);
	}
a207 4
#define	VALID_ADDRESS(va) \
	(((va) >= VM_MIN_KERNEL_ADDRESS && (va) < VM_MAX_KERNEL_ADDRESS) || \
	 IS_XKPHYS(va) || ((va) >= CKSEG0_BASE && (va) < CKSEG1_BASE))

a215 11
	db_sym_t sym;
	db_expr_t diff;
	db_addr_t subr;
	char *symname;
	vaddr_t pc, sp, ra, va;
	register_t a0, a1, a2, a3;
	unsigned instr, mask;
	InstFmt i;
	int more, stksize;
	extern char k_intr[];
	extern char k_general[];
d223 1
a223 189
	/* get initial values from the exception frame */
	sp = (vaddr_t)regs->sp;
	pc = (vaddr_t)regs->pc;
	ra = (vaddr_t)regs->ra;		/* May be a 'leaf' function */
	a0 = regs->a0;
	a1 = regs->a1;
	a2 = regs->a2;
	a3 = regs->a3;

/* Jump here when done with a frame, to start a new one */
loop:
	symname = NULL;
	subr = 0;
	stksize = 0;

	if (count-- == 0) {
		ra = 0;
		goto end;
	}

	/* check for bad SP: could foul up next frame */
	if (sp & 3 || !VALID_ADDRESS(sp)) {
		(*pr)("SP %p: not in kernel\n", sp);
		ra = 0;
		goto done;
	}

	/* check for bad PC */
	if (pc & 3 || !VALID_ADDRESS(pc)) {
		(*pr)("PC %p: not in kernel\n", pc);
		ra = 0;
		goto done;
	}

	/*
	 * Dig out the function from the symbol table.
	 * Watch out for function tail optimizations.
	 */
	sym = db_search_symbol(pc, DB_STGY_ANY, &diff);
	db_symbol_values(sym, &symname, 0);
	if (sym != DB_SYM_NULL) {
		subr = pc - diff;
	} else {
		subr = 0;
	}

	/*
	 * Find the beginning of the current subroutine by scanning backwards
	 * from the current PC for the end of the previous subroutine.
	 */
	if (!subr) {
		va = pc - sizeof(int);
		while ((instr = kdbpeek((int *)va)) != MIPS_JR_RA)
			va -= sizeof(int);
		va += 2 * sizeof(int);	/* skip back over branch & delay slot */
		/* skip over nulls which might separate .o files */
		while ((instr = kdbpeek((int *)va)) == 0)
			va += sizeof(int);
		subr = va;
	}

	/*
	 * Jump here for locore entry points for which the preceding
	 * function doesn't end in "j ra"
	 */
	/* scan forwards to find stack size and any saved registers */
	stksize = 0;
	more = 3;
	mask = 0;
	for (va = subr; more; va += sizeof(int),
	    more = (more == 3) ? 3 : more - 1) {
		/* stop if hit our current position */
		if (va >= pc)
			break;
		instr = kdbpeek((int *)va);
		i.word = instr;
		switch (i.JType.op) {
		case OP_SPECIAL:
			switch (i.RType.func) {
			case OP_JR:
			case OP_JALR:
				more = 2; /* stop after next instruction */
				break;

			case OP_SYSCALL:
			case OP_BREAK:
				more = 1; /* stop now */
			};
			break;

		case OP_BCOND:
		case OP_J:
		case OP_JAL:
		case OP_BEQ:
		case OP_BNE:
		case OP_BLEZ:
		case OP_BGTZ:
			more = 2; /* stop after next instruction */
			break;

		case OP_COP0:
		case OP_COP1:
		case OP_COP2:
		case OP_COP3:
			switch (i.RType.rs) {
			case OP_BCx:
			case OP_BCy:
				more = 2; /* stop after next instruction */
			};
			break;

		case OP_SW:
		case OP_SD:
			/* look for saved registers on the stack */
			if (i.IType.rs != 29)
				break;
			/* only restore the first one */
			if (mask & (1 << i.IType.rt))
				break;
			mask |= (1 << i.IType.rt);
			switch (i.IType.rt) {
			case 4: /* a0 */
				a0 = kdbpeekd((long *)(sp + (short)i.IType.imm));
				break;

			case 5: /* a1 */
				a1 = kdbpeekd((long *)(sp + (short)i.IType.imm));
				break;

			case 6: /* a2 */
				a2 = kdbpeekd((long *)(sp + (short)i.IType.imm));
				break;

			case 7: /* a3 */
				a3 = kdbpeekd((long *)(sp + (short)i.IType.imm));
				break;

			case 31: /* ra */
				ra = kdbpeekd((long *)(sp + (short)i.IType.imm));
				break;
			}
			break;

		case OP_ADDI:
		case OP_ADDIU:
		case OP_DADDI:
		case OP_DADDIU:
			/* look for stack pointer adjustment */
			if (i.IType.rs != 29 || i.IType.rt != 29)
				break;
			stksize = - ((short)i.IType.imm);
		}
	}

done:
	if (symname == NULL)
		(*pr)("%p ", subr);
	else
		(*pr)("%s+%p ", symname, diff);
	(*pr)("(%llx,%llx,%llx,%llx) sp %llx ra %llx, sz %d\n", a0, a1, a2, a3, sp, ra, stksize);

	if (subr == (vaddr_t)k_intr || subr == (vaddr_t)k_general) {
		if (subr == (vaddr_t)k_intr)
			(*pr)("(KERNEL INTERRUPT)\n");
		else
			(*pr)("(KERNEL TRAP)\n");
		sp = *(register_t *)sp;
		pc = ((struct trap_frame *)sp)->pc;
		ra = ((struct trap_frame *)sp)->ra;
		sp = ((struct trap_frame *)sp)->sp;	/* last */
		goto loop;
	}

end:
	if (ra) {
		if (pc == ra && stksize == 0)
			(*pr)("stacktrace: loop!\n");
		else {
			pc = ra;
			sp += stksize;
			ra = 0;
			goto loop;
		}
	} else {
		if (curproc)
			(*pr)("User-level: pid %d\n", curproc->p_pid);
		else
			(*pr)("User-level: curproc NULL\n");
	}
a224 2

#undef	VALID_ADDRESS
@


1.24
log
@Do not lose ra on the first loop (regression from 1.20)
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.c,v 1.23 2010/01/09 23:34:29 miod Exp $ */
d211 1
a211 1
	 IS_XKPHYS(va) || ((va) >= CKSEG0_BASE && (va) < CKSSEG_BASE))
@


1.23
log
@Move cache information from global variables to per-cpu_info fields; this
allows processors with different cache sizes to be used.

Cache management routines now take a struct cpu_info * as first parameter.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.c,v 1.22 2010/01/09 20:33:16 miod Exp $ */
a250 1
	ra = 0;
d254 2
a255 1
	if (count-- == 0)
d257 1
d262 1
d269 1
@


1.22
log
@Define struct cpu_hwinfo, to hold hardware specific information about each
processor (instead of sys_config.cpu[]), and pass it in the attach_args
when attaching cpu devices.

This allows per-cpu information to be gathered late in the bootstrap process,
and not be limited by an arbitrary MAX_CPUS limit; this will suit IP27 and
IP35 systems better.

While there, use this information to make sure delay() uses the speed
information from the cpu it is invoked on.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.c,v 1.21 2009/12/25 21:02:15 miod Exp $ */
d200 2
d203 1
a203 1
		Mips_HitSyncDCache(addr, PHYS_TO_XKPHYS(addr, CCA_CACHED),
d205 1
a205 1
		Mips_InvalidateICache(PHYS_TO_CKSEG0(addr & 0xffff), size);
@


1.21
log
@Pass both the virtual address and the physical address of the memory range
when invoking the cache functions. The physical address is needed when
operating on physically-indexed caches, such as the L2 cache on Loongson
processors.

Preprocessor abuse makes sure that the physical address computation gets
compiled out when running on a kernel compiled for virtually-indexed
caches only, such as the sgi kernel.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.c,v 1.20 2009/11/21 23:56:56 miod Exp $ */
d555 1
d566 1
a566 1
			count = sys_config.cpu[0].tlbsize;
d569 1
a569 1
		last = sys_config.cpu[0].tlbsize;
d585 1
a585 1
		if (have_addr && addr < sys_config.cpu[0].tlbsize) {
d587 1
a587 2
		}
			else {
d589 1
a589 1
			count = sys_config.cpu[0].tlbsize;
d594 1
a594 1
	for (; tlbno < sys_config.cpu[0].tlbsize && tlbno < last; tlbno++) {
@


1.20
log
@Fix uninitialized variables in db_stack_trace_print(), and honour the
frame count argument.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.c,v 1.19 2009/11/19 20:16:27 miod Exp $ */
d200 3
a202 1
		Mips_HitSyncDCache(addr, size);
@


1.19
log
@Rename KSEG* defines to CKSEG* to match their names in 64 bit mode; also
define more 64 bit spaces.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.c,v 1.18 2009/07/22 21:15:42 miod Exp $ */
d205 4
a225 1
	extern char edata[];
d246 4
d251 2
a252 2
/* Jump here after a nonstandard (interrupt handler) frame */
	stksize = 0;
d255 1
a255 1
	if (sp & 3 || (!IS_XKPHYS(sp) && sp < CKSEG0_BASE)) {
a256 2
		ra = 0;
		subr = 0;
a259 19
#if 0
	/* Backtraces should contine through interrupts from kernel mode */
	if (pc >= (vaddr_t)MipsKernIntr && pc < (vaddr_t)MipsUserIntr) {
		(*pr)("MipsKernIntr+%x: (%x, %x ,%x) -------\n",
		       pc - (vaddr_t)MipsKernIntr, a0, a1, a2);
		regs = (struct trap_frame *)(sp + STAND_ARG_SIZE);
		a0 = kdbpeek(&regs->a0);
		a1 = kdbpeek(&regs->a1);
		a2 = kdbpeek(&regs->a2);
		a3 = kdbpeek(&regs->a3);

		pc = kdbpeek(&regs->pc); /* exc_pc - pc at time of exception */
		ra = kdbpeek(&regs->ra); /* ra at time of exception */
		sp = kdbpeek(&regs->sp);
		goto specialframe;
	}
#endif


d261 1
a261 2
	if (pc & 3 || (!IS_XKPHYS(pc) && pc < CKSEG0_BASE) ||
	    pc >= (vaddr_t)edata) {
a262 1
		ra = 0;
d405 1
d422 2
@


1.18
log
@When disassembling, if our pc matches the beginning of a routine, then
it's at routine+0; do not search for the previous routine in the symbol
table. This fixes tracebacks when the fault occurs on the first instruction
of a routine.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.c,v 1.17 2008/06/22 21:02:10 miod Exp $ */
d201 1
a201 1
		Mips_InvalidateICache(PHYS_TO_KSEG0(addr & 0xffff), size);
d248 1
a248 1
	if (sp & 3 || (!IS_XKPHYS(sp) && sp < KSEG0_BASE)) {
d275 1
a275 1
	if (pc & 3 || (!IS_XKPHYS(pc) && pc < KSEG0_BASE) ||
@


1.17
log
@Like alpha, db_stack_dump() on mips and sh needs complete frame information
and can not work from a stack address only. Mention this and abort instead of
printing a wrong trace. (prefer kern.splassert=3 to =2 on these platforms)
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.c,v 1.16 2008/02/29 19:00:39 miod Exp $ */
a286 2
	if (sym != DB_SYM_NULL && diff == 0)
		sym = db_search_symbol(pc - 4, DB_STGY_ANY, &diff);
@


1.16
log
@Fix db_read_bytes() for short reads.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.c,v 1.15 2008/02/18 19:47:36 miod Exp $ */
d226 5
@


1.15
log
@Use better types and fix tests for pc and sp being in kernel to really
handle XKPHYS addresses correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.c,v 1.14 2007/10/22 14:46:46 jsing Exp $ */
d151 1
d158 1
a158 1
	while(size >= sizeof(int)) {
d164 1
a164 1
	if (size > sizeof(short)) {
d199 1
a199 1
	if (addr < VM_MIN_KERNEL_ADDRESS) {
d406 2
a407 2
	if (subr == (long)k_intr || subr == (long)k_general) {
		if (subr == (long)k_intr)
d609 1
a609 1
			printf("%2d v=%16llx", tlbno, tlb.tlb_hi & (long)~0xff);
@


1.14
log
@stoped -> stopped

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.c,v 1.13 2007/10/10 15:53:52 art Exp $ */
d216 1
a216 1
	register_t pc, sp, ra, va;
d227 3
a229 3
	sp = regs->sp;
	pc = regs->pc;
	ra = regs->ra;		/* May be a 'leaf' function */
d242 1
a242 1
	if (sp & 3 || (!IS_XKPHYS((vaddr_t)sp) && sp < KSEG0_BASE)) {
d251 1
a251 1
	if (pc >= (unsigned)MipsKernIntr && pc < (unsigned)MipsUserIntr) {
d253 1
a253 1
		       pc-(unsigned)MipsKernIntr, a0, a1, a2);
d269 2
a270 1
	if (pc & 3 || pc < KSEG0_BASE || pc >= (unsigned)edata) {
@


1.13
log
@Make context switching much more MI:
 - Move the functionality of choosing a process from cpu_switch into
   a much simpler function: cpu_switchto. Instead of having the locore
   code walk the run queues, let the MI code choose the process we
   want to run and only implement the context switching itself in MD
   code.
 - Let MD context switching run without worrying about spls or locks.
 - Instead of having the idle loop implemented with special contexts
   in MD code, implement one idle proc for each cpu. make the idle
   loop MI with MD hooks.
 - Change the proc lists from the old style vax queues to TAILQs.
 - Change the sleep queue from vax queues to TAILQs. This makes
   wakeup() go from O(n^2) to O(n)

there will be some MD fallout, but it will be fixed shortly.
There's also a few cleanups to be done after this.

deraadt@@, kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.c,v 1.12 2007/09/03 01:15:50 krw Exp $ */
d137 1
a137 1
		printf("stoped on non ddb fault\n");
@


1.12
log
@Typos from miod. 'requiered' -> 'required' in some comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.c,v 1.11 2007/05/03 19:34:00 miod Exp $ */
a223 1
	extern char idle[];
d398 3
a400 6
	if (symname == NULL) {
		if (subr == (long)idle)
			(*pr)("idle ");
		else
			(*pr)("%p ", subr);
	} else {
a401 1
	}
@


1.11
log
@Enable support for > 512MB of physical memory on mips64 systems, by using
XKPHYS instead of KSEG[01] for direct mappings.

Then, detect memory above 256MB on O2 by poking at the CRIME registers
(ARCbios will not report memory above 256MB, which is mapped above 1GB
physical, to the system), and add it to the UVM managed memory.

Tested on r5k, rm5200 and r10k with and without more than 256MB, matching
hinv reports in all cases. CRIME memory decoding based on a diff from
kettenis@@ in december 2005.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.c,v 1.10 2007/03/22 18:55:20 miod Exp $ */
d444 1
a444 1
 *	requiered.
@


1.10
log
@Change yet another kernel message starting with `<'.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.c,v 1.9 2005/05/22 19:40:51 art Exp $ */
d243 1
a243 1
	if (sp & 3 || sp < KSEG0_BASE) {
@


1.9
log
@remove "0x" in front of %p in printfs.

eyeballed by krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.c,v 1.8 2004/10/30 14:48:59 pefo Exp $ */
d411 1
a411 1
			(*pr)("<-> KERNEL INTERRUPT <->\n");
d413 1
a413 1
			(*pr)("<-> KERNEL TRAP <->\n");
@


1.8
log
@Make the default boot partition p.
Migrate float exception code to 64 bit. Add a few new "uniplemented".
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.c,v 1.7 2004/10/20 12:49:15 pefo Exp $ */
d271 1
a271 1
		(*pr)("PC 0x%p: not in kernel\n", pc);
@


1.7
log
@Fix some 64 bit address problems.
Some function names made more unique.
Other changes for the upcoming Origin 200 support.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.c,v 1.6 2004/09/15 16:05:18 pefo Exp $ */
d80 8
a87 8
    { "t0",  (long *)&ddb_regs.t0,      FCN_NULL },
    { "t1",  (long *)&ddb_regs.t1,      FCN_NULL },
    { "t2",  (long *)&ddb_regs.t2,      FCN_NULL },
    { "t3",  (long *)&ddb_regs.t3,      FCN_NULL },
    { "t4",  (long *)&ddb_regs.t4,      FCN_NULL },
    { "t5",  (long *)&ddb_regs.t5,      FCN_NULL },
    { "t6",  (long *)&ddb_regs.t6,      FCN_NULL },
    { "t7",  (long *)&ddb_regs.t7,      FCN_NULL },
@


1.6
log
@Make trace work better. Don't hope for a good stacktrace without symbols
loaded. GCC 3.x really moves things around.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.c,v 1.5 2004/09/09 22:11:38 pefo Exp $ */
d565 1
a565 1
	struct tlb tlb, tlbp;
d567 1
a567 1
	"CWTNA", "CWTA ", "UCBL ", "CWB  ", "RES  ", "RES  ", "UCNB ", "BPASS"
d612 1
a612 1
			printf("%2d v=0x%08x", tlbno, tlb.tlb_hi & ~0xff);
d616 1
a616 1
				printf("0x%08x ", pfn_to_pad(tlb.tlb_lo0));
d619 1
a619 1
				printf(" %s ", attr[(tlb.tlb_lo0 >> 3) & 7]);
d625 1
a625 1
				printf("0x%08x ", pfn_to_pad(tlb.tlb_lo1));
d628 1
a628 1
				printf(" %s ", attr[(tlb.tlb_lo1 >> 3) & 7]);
@


1.5
log
@Kernel moves to 64 bit. A few more tweaks when binutils is updated.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.c,v 1.4 2004/08/10 20:28:13 deraadt Exp $ */
d57 1
d60 4
a63 3
void  kdbpoke(int, int);
void  kdbpokew(int, short);
void  kdbpokeb(int, char);
d278 1
d281 2
d366 1
a366 1
				a0 = kdbpeek((int *)(sp + (short)i.IType.imm));
d370 1
a370 1
				a1 = kdbpeek((int *)(sp + (short)i.IType.imm));
d374 1
a374 1
				a2 = kdbpeek((int *)(sp + (short)i.IType.imm));
d378 1
a378 1
				a3 = kdbpeek((int *)(sp + (short)i.IType.imm));
d382 1
a382 1
				ra = kdbpeek((int *)(sp + (short)i.IType.imm));
d407 1
a407 1
	(*pr)("(%x,%x,%x,%x) sp %x ra %x, sz %d\n", a0, a1, a2, a3, sp, ra, stksize);
@


1.4
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.c,v 1.3 2004/08/10 20:15:47 deraadt Exp $ */
d241 1
a241 1
	if (sp & 3 || sp < 0xffffffff80000000) {
d268 2
a269 2
	if (pc & 3 || pc < 0xffffffff80000000 || pc >= (unsigned)edata) {
		(*pr)("PC 0x%x: not in kernel\n", pc);
@


1.3
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.c,v 1.2 2004/08/09 14:57:26 pefo Exp $ */
d120 1
a120 1
		if(db_get_value((fp)->pc, sizeof(int), FALSE) == BREAK_SOVER) {
d131 1
a131 1
		if(db_recover != 0) {
d193 1
a193 1
	if(len) {
d196 1
a196 1
	if(addr < VM_MIN_KERNEL_ADDRESS) {
d394 1
a394 1
	if(symname == NULL) {
d568 1
a568 1
		if(have_addr && addr < 256) {
d590 1
a590 1
		if(have_addr && addr < sys_config.cpu[0].tlbsize) {
d606 1
a606 1
		if(tlb.tlb_lo0 & PG_V || tlb.tlb_lo1 & PG_V) {
d610 1
a610 1
			if(tlb.tlb_lo0 & PG_V) {
d619 1
a619 1
			if(tlb.tlb_lo1 & PG_V) {
@


1.2
log
@Big cleanup. Removed some unused obsolete stuff and fixed copyrights
on some files. Arcbios support is now in, thus detects memorysize and cpu
clock frequency.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.c,v 1.1 2004/08/06 20:56:03 pefo Exp $ */
d5 1
a5 1
 * 
d121 1
a121 1
                	(fp)->pc += BKPT_SIZE;        
d309 1
a309 1
	     		      more = (more == 3) ? 3 : more - 1) {
d385 1
a385 1
		case OP_DADDIU: 
d532 1
a532 1
	case OP_SD:  
d640 1
a640 1
	{ NULL, 	NULL,			0,	NULL }
@


1.1
log
@initial mips64
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.c,v 1.2 1998/09/15 10:50:13 pefo Exp $ */
a13 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Opsycon AB, Sweden.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d571 1
a571 1
			count = sys_config.cpu.tlbsize;
d574 1
a574 1
		last = sys_config.cpu.tlbsize;
d590 1
a590 1
		if(have_addr && addr < sys_config.cpu.tlbsize) {
d595 1
a595 1
			count = sys_config.cpu.tlbsize;
d600 1
a600 1
	for (; tlbno < sys_config.cpu.tlbsize && tlbno < last; tlbno++) {
@

