head	1.57;
access;
symbols
	OPENBSD_6_1_BASE:1.57
	OPENBSD_6_0:1.54.0.4
	OPENBSD_6_0_BASE:1.54
	OPENBSD_5_9:1.54.0.2
	OPENBSD_5_9_BASE:1.54
	OPENBSD_5_8:1.53.0.8
	OPENBSD_5_8_BASE:1.53
	OPENBSD_5_7:1.53.0.2
	OPENBSD_5_7_BASE:1.53
	OPENBSD_5_6:1.53.0.4
	OPENBSD_5_6_BASE:1.53
	OPENBSD_5_5:1.52.0.4
	OPENBSD_5_5_BASE:1.52
	OPENBSD_5_4:1.51.0.4
	OPENBSD_5_4_BASE:1.51
	OPENBSD_5_3:1.51.0.2
	OPENBSD_5_3_BASE:1.51
	OPENBSD_5_2:1.46.0.2
	OPENBSD_5_2_BASE:1.46
	OPENBSD_5_1_BASE:1.45
	OPENBSD_5_1:1.45.0.8
	OPENBSD_5_0:1.45.0.6
	OPENBSD_5_0_BASE:1.45
	OPENBSD_4_9:1.45.0.4
	OPENBSD_4_9_BASE:1.45
	OPENBSD_4_8:1.45.0.2
	OPENBSD_4_8_BASE:1.45
	OPENBSD_4_7:1.44.0.2
	OPENBSD_4_7_BASE:1.44
	OPENBSD_4_6:1.22.0.4
	OPENBSD_4_6_BASE:1.22
	OPENBSD_4_5:1.20.0.4
	OPENBSD_4_5_BASE:1.20
	OPENBSD_4_4:1.20.0.2
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.19.0.2
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.13.0.2
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.9.0.6
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.4
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.2
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.8.0.4
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.2
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.6.0.2
	OPENBSD_3_6_BASE:1.6;
locks; strict;
comment	@# @;


1.57
date	2016.09.06.13.41.29;	author visa;	state Exp;
branches;
next	1.56;
commitid	YLWh6Z5nXoTUOOVU;

1.56
date	2016.08.16.13.03.58;	author visa;	state Exp;
branches;
next	1.55;
commitid	6TiwRQZbesPVamIE;

1.55
date	2016.08.14.08.23.52;	author visa;	state Exp;
branches;
next	1.54;
commitid	at8t1tG4p7ou4Cj7;

1.54
date	2015.09.29.17.07.53;	author miod;	state Exp;
branches;
next	1.53;
commitid	bDBgQLaVTOsRt1je;

1.53
date	2014.03.22.00.01.04;	author miod;	state Exp;
branches;
next	1.52;

1.52
date	2014.02.08.09.34.04;	author miod;	state Exp;
branches;
next	1.51;

1.51
date	2012.10.03.11.18.23;	author miod;	state Exp;
branches;
next	1.50;

1.50
date	2012.09.29.21.37.03;	author miod;	state Exp;
branches;
next	1.49;

1.49
date	2012.09.29.19.11.08;	author miod;	state Exp;
branches;
next	1.48;

1.48
date	2012.09.29.19.02.26;	author miod;	state Exp;
branches;
next	1.47;

1.47
date	2012.09.29.18.58.30;	author miod;	state Exp;
branches;
next	1.46;

1.46
date	2012.04.24.20.01.03;	author miod;	state Exp;
branches;
next	1.45;

1.45
date	2010.04.28.16.20.28;	author syuu;	state Exp;
branches;
next	1.44;

1.44
date	2010.02.13.14.04.45;	author miod;	state Exp;
branches;
next	1.43;

1.43
date	2010.01.28.21.24.08;	author miod;	state Exp;
branches;
next	1.42;

1.42
date	2010.01.28.05.27.16;	author miod;	state Exp;
branches;
next	1.41;

1.41
date	2010.01.21.17.52.25;	author miod;	state Exp;
branches;
next	1.40;

1.40
date	2010.01.18.17.04.11;	author miod;	state Exp;
branches;
next	1.39;

1.39
date	2010.01.10.13.00.24;	author miod;	state Exp;
branches;
next	1.38;

1.38
date	2010.01.08.01.35.52;	author syuu;	state Exp;
branches;
next	1.37;

1.37
date	2010.01.07.20.24.15;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2010.01.05.06.44.58;	author syuu;	state Exp;
branches;
next	1.35;

1.35
date	2009.12.28.06.55.27;	author syuu;	state Exp;
branches;
next	1.34;

1.34
date	2009.12.12.20.07.10;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2009.12.08.22.14.43;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2009.12.07.19.01.06;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2009.11.19.20.16.27;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2009.10.22.22.08.54;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2009.10.22.18.46.48;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2009.10.22.18.31.51;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2009.10.22.18.23.12;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2009.10.22.18.21.40;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2009.10.07.08.35.47;	author syuu;	state Exp;
branches;
next	1.24;

1.24
date	2009.09.30.06.22.00;	author syuu;	state Exp;
branches;
next	1.23;

1.23
date	2009.08.06.21.11.39;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2009.05.22.20.37.53;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2009.05.21.16.10.38;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2008.07.28.19.08.46;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2008.02.16.18.43.27;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2007.11.24.19.39.20;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2007.10.24.20.01.36;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2007.10.18.04.32.25;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2007.10.13.12.46.18;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2007.10.10.15.53.52;	author art;	state Exp;
branches;
next	1.13;

1.13
date	2007.07.16.20.22.18;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2007.07.01.19.12.42;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2007.05.09.19.19.26;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2007.05.07.18.42.13;	author kettenis;	state Exp;
branches;
next	1.9;

1.9
date	2005.12.20.07.06.26;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2004.09.27.19.16.06;	author pefo;	state Exp;
branches;
next	1.7;

1.7
date	2004.09.27.17.41.56;	author pefo;	state Exp;
branches;
next	1.6;

1.6
date	2004.09.10.09.32.13;	author pefo;	state Exp;
branches;
next	1.5;

1.5
date	2004.09.10.08.58.27;	author pefo;	state Exp;
branches;
next	1.4;

1.4
date	2004.09.09.22.11.38;	author pefo;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.10.20.15.47;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2004.08.09.14.57.26;	author pefo;	state Exp;
branches;
next	1.1;

1.1
date	2004.08.06.20.56.03;	author pefo;	state Exp;
branches;
next	;


desc
@@


1.57
log
@Define PTE_* macros in one place. Use the lwu instruction for 32-bit PTE
loads on all systems as the TLB code does not need sign extension.
@
text
@/*	$OpenBSD: context.S,v 1.56 2016/08/16 13:03:58 visa Exp $ */

/*
 * Copyright (c) 2002-2003 Opsycon AB  (www.opsycon.se / www.opsycon.com)
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */
#include <sys/errno.h>
#include <sys/syscall.h>

#include <machine/param.h>
#include <machine/asm.h>
#include <machine/cpu.h>
#include <machine/pte.h>
#include <machine/regnum.h>
#include <mips64/mips_cpu.h>
#include <machine/cpustate.h>
#ifdef CPU_LOONGSON2
#include <machine/loongson2.h>
#endif

#include "assym.h"

	.set	mips3
	.set	noreorder		# Noreorder is default style!

/*
 * Save registers and state used by reboot to take snapshot.
 */
LEAF(savectx, 0)
	REG_S	s0, PCB_CONTEXT+0*REGSZ(a0)
	REG_S	s1, PCB_CONTEXT+1*REGSZ(a0)
	REG_S	s2, PCB_CONTEXT+2*REGSZ(a0)
	REG_S	s3, PCB_CONTEXT+3*REGSZ(a0)
	MFC0	v0, COP_0_STATUS_REG
	MFC0_HAZARD
	REG_S	s4, PCB_CONTEXT+4*REGSZ(a0)
	REG_S	s5, PCB_CONTEXT+5*REGSZ(a0)
	REG_S	s6, PCB_CONTEXT+6*REGSZ(a0)
	REG_S	s7, PCB_CONTEXT+7*REGSZ(a0)
	REG_S	sp, PCB_CONTEXT+8*REGSZ(a0)
	REG_S	s8, PCB_CONTEXT+9*REGSZ(a0)
	REG_S	ra, PCB_CONTEXT+10*REGSZ(a0)
	REG_S	v0, PCB_CONTEXT+11*REGSZ(a0)
#ifdef RM7000_ICR
	cfc0	t1, COP_0_ICR
	REG_S	t1, PCB_CONTEXT+12*REGSZ(a0)	# save status register
#endif
	j	ra
	 move	v0, zero
END(savectx)

LEAF(cpu_idle_enter, 0)
	j	ra
	 NOP
END(cpu_idle_enter)

LEAF(cpu_idle_leave, 0)
	j	ra
	 NOP
END(cpu_idle_leave)

LEAF(cpu_idle_cycle, 0)
	j	ra
	 NOP
END(cpu_idle_cycle)

/*
 * cpu_switchto_asm(struct proc *oldproc, struct proc *newproc)
 */
NON_LEAF(cpu_switchto_asm, FRAMESZ(CF_SZ), ra)
	GET_CPU_INFO(t1, t3)
	PTR_L	t3, CI_CURPROCPADDR(t1)
	REG_S	sp, PCB_CONTEXT+8*REGSZ(t3)	# save old sp

	PTR_SUBU sp, sp, FRAMESZ(CF_SZ)
	REG_S	ra, CF_RA_OFFS(sp)
	.mask	0x80000000, (CF_RA_OFFS - FRAMESZ(CF_SZ))

#ifdef CPU_R8000	/* XXX everywhere where MFC0_HAZARD is not empty */
	MFC0	v0, COP_0_STATUS_REG
	MFC0_HAZARD
	beqz	a0, 1f
	 NOP
#else
	beqz	a0, 1f
	 MFC0	v0, COP_0_STATUS_REG
#endif

	REG_S	s0, PCB_CONTEXT+0*REGSZ(t3)	# do a 'savectx()'
	REG_S	s1, PCB_CONTEXT+1*REGSZ(t3)
	REG_S	s2, PCB_CONTEXT+2*REGSZ(t3)
	REG_S	s3, PCB_CONTEXT+3*REGSZ(t3)
	REG_S	s4, PCB_CONTEXT+4*REGSZ(t3)
	REG_S	s5, PCB_CONTEXT+5*REGSZ(t3)
	REG_S	s6, PCB_CONTEXT+6*REGSZ(t3)
	REG_S	s7, PCB_CONTEXT+7*REGSZ(t3)
	REG_S	s8, PCB_CONTEXT+9*REGSZ(t3)
	REG_S	ra, PCB_CONTEXT+10*REGSZ(t3)
	REG_S	v0, PCB_CONTEXT+11*REGSZ(t3)
#ifdef RM7000_ICR
	cfc0	t1, COP_0_ICR
	REG_S	t1, PCB_CONTEXT+12*REGSZ(t3)
#endif

1:
	/*
	 * Disable interrupts
	 */
	ori	v0, SR_INT_ENAB
	xori	v0, SR_INT_ENAB
	MTC0	v0, COP_0_STATUS_REG
	MTC0_SR_IE_HAZARD

	/*
	 * Switch to new context
 	*/
	move	s0, a1				# save p
	jal	pmap_activate
	move	a0, s0

	PTR_L	t3, P_ADDR(s0)			# get uarea pointer.
	GET_CPU_INFO(t1, t0)
	PTR_S	s0, CI_CURPROC(t1)		# set curproc
	PTR_S	t3, CI_CURPROCPADDR(t1)
	
#ifdef MULTIPROCESSOR
	PTR_S	t1, P_CPU(s0)
#endif
	li	t1, SONPROC
	sb	t1, P_STAT(s0)			# set to onproc.

	/* get process ASID */
	PTR_L	t0, P_VMSPACE(s0)		# p->p_vmspace
	PTR_L	t1, VMSPACE_PMAP(t0)		# ->vm_map.pmap
#ifdef MULTIPROCESSOR
	GET_CPU_INFO(v0, t2)
	PTR_L	v0, CI_CPUID(v0)
	PTR_SLL	v0, v0, 0x3			# size of pmap_asid_info
	PTR_ADDU t1, t1, v0
#endif
	lw	v0, PM_ASID(t1)			# ->pm_asid[cpuid].pma_asid
#ifdef CPU_R8000
	PTR_L	t0, PCB_SEGTAB(t3)		# save pcb_segtab for
	DMTC0	t0, COP_0_UBASE			# Utlbmiss handler
	MTC0_HAZARD
#endif

#ifdef CPU_R4000
	/*
	 * Restore the number of wired TLB entries to the minimal possible
	 * value, in case the EOP errata workaround has caused more wired
	 * entries to be created.
	 */
	lw	a0, PCB_NWIRED(t3)
	beqz	a0, 1f
	sw	zero, PCB_NWIRED(t3)

	li	a1, UPAGES / 2
	move	s0, v0				# save asid
	mtc0	a1, COP_0_TLB_WIRED
	jal	tlb_flush			# clear formerly wired entries
	addu	a0, a1, a0
	move	v0, s0
1:
#endif

#if UPAGES > 1	/* { */
#ifdef CPU_R8000
#error Your processor has just been eaten by a grue.
#endif
	or	v0, t3
	dmtc0	v0, COP_0_TLB_HI		# init high entry (tlbid)

	/*
	 * We need to wire the process kernel stack mapping so there
	 * will be no tlb misses in exception handlers. This is done
	 * by invalidating any tlb entries mapping the U-area and
	 * put valid mappings in tlb entries 0 and 1.
	 */

	LA	t1, CKSEG0_BASE
	PTR_SUBU t2, t3, t1
	bgez	t2, ctx3			# in CKSEG0
	LA	t1, VM_MIN_KERNEL_ADDRESS	# (safe if expands to > 1 insn)
	PTR_SUBU t2, t3, t1
	bltz	t2, ctx3			# not mapped.
	PTR_SRL	t2, PGSHIFT+1
	PTR_L	t1, Sysmap
	TLB_HAZARD
	tlbp
	TLB_HAZARD			# necessary?
	PTR_SLL	t2, PTE_LOG + 1
	PTR_ADDU t1, t2				# t1 now points at ptes.
	mfc0	t0, COP_0_TLB_INDEX
	nop
	bltz	t0, ctx1			# not in tlb
	LA	t2, CKSEG0_BASE			# safe if expands to > 1 insn

	dmtc0	t2, COP_0_TLB_HI		# invalidate it.
	dmtc0	zero, COP_0_TLB_LO0
	dmtc0	zero, COP_0_TLB_LO1
	TLB_HAZARD
	tlbwi
	TLB_HAZARD

ctx1:
	mtc0	zero, COP_0_TLB_INDEX
	dmtc0	v0, COP_0_TLB_HI
	PTE_LOAD ta0, 0(t1)
	PTE_LOAD ta1, PTE_OFFS(t1)
	PTE_CLEAR_SWBITS(ta0)
	PTE_CLEAR_SWBITS(ta1)
	dmtc0	ta0, COP_0_TLB_LO0
	dmtc0	ta1, COP_0_TLB_LO1
	PTR_ADDU v0, 2*PAGE_SIZE
	TLB_HAZARD
	tlbwi
	TLB_HAZARD

#if UPAGES > 2	/* { */
	dmtc0	v0, COP_0_TLB_HI		# init high entry (tlbid)
	PTE_LOAD ta0, (2*PTE_OFFS)(t1)
	PTE_LOAD ta1, (3*PTE_OFFS)(t1)
	PTE_CLEAR_SWBITS(ta0)
	TLB_HAZARD
	tlbp
	TLB_HAZARD			# necessary?
	PTE_CLEAR_SWBITS(ta1)
	mfc0	t0, COP_0_TLB_INDEX
	nop
	bltz	t0, ctx2			# not in tlb
	li	t2, 1

	dmtc0	t2, COP_0_TLB_HI		# invalidate it.
	dmtc0	zero, COP_0_TLB_LO0
	dmtc0	zero, COP_0_TLB_LO1
	TLB_HAZARD
	tlbwi
	TLB_HAZARD

ctx2:
	mtc0	t2, COP_0_TLB_INDEX
	dmtc0	v0, COP_0_TLB_HI
	dmtc0	ta0, COP_0_TLB_LO0
	dmtc0	ta1, COP_0_TLB_LO1
	TLB_HAZARD
	tlbwi
	TLB_HAZARD
#endif	/* } UPAGES > 2 */
ctx3:
#else	/* } UPAGES > 1 { */
#if PG_ASID_SHIFT != 0
	dsll	v0, PG_ASID_SHIFT
#endif
	DMTC0	v0, COP_0_TLB_HI		# init high entry (tlbid)
	MTC0_HAZARD
#endif	/* } UPAGES > 1 */

#ifdef CPU_LOONGSON2
	li	v0, COP_0_DIAG_ITLB_CLEAR | COP_0_DIAG_BTB_CLEAR | COP_0_DIAG_RAS_DISABLE
	dmtc0	v0, COP_0_DIAG
#endif

	/*
	 * Restore registers and return.
	 */

	REG_L	s0, PCB_CONTEXT+0*REGSZ(t3)
	REG_L	s1, PCB_CONTEXT+1*REGSZ(t3)
	REG_L	s2, PCB_CONTEXT+2*REGSZ(t3)
	REG_L	s3, PCB_CONTEXT+3*REGSZ(t3)
	REG_L	s4, PCB_CONTEXT+4*REGSZ(t3)
	REG_L	s5, PCB_CONTEXT+5*REGSZ(t3)
	REG_L	s6, PCB_CONTEXT+6*REGSZ(t3)
	REG_L	s7, PCB_CONTEXT+7*REGSZ(t3)
	REG_L	sp, PCB_CONTEXT+8*REGSZ(t3)
	REG_L	s8, PCB_CONTEXT+9*REGSZ(t3)
	REG_L	ra, PCB_CONTEXT+10*REGSZ(t3)
	REG_L	v0, PCB_CONTEXT+11*REGSZ(t3)
#ifdef RM7000_ICR
	REG_L	v1, PCB_CONTEXT+12*REGSZ(t3)
	ctc0	v1, COP_0_ICR		# XXX RM7000
#endif
	ori	v0, v0, SR_INT_ENAB
	MTC0	v0, COP_0_STATUS_REG
	MTC0_SR_IE_HAZARD
	j	ra
	 NOP
END(cpu_switchto_asm)

/*-------------------------------------------------------------- proc_trampoline
 *	Setup for and return to user.
 */
LEAF(proc_trampoline, 0)
#ifdef DDB
	move	zero, ra
#endif
#ifdef MULTIPROCESSOR
	jal	_C_LABEL(proc_trampoline_mp)
	 NOP
#endif
	/*
	 * Enable interrupts, since we want kernel threads to
	 * start at spl0 and with interrupts enabled, and these
	 * won't ``return to userland''.
	 */
#ifndef MULTIPROCESSOR	/* done by proc_trampoline_mp() */
	jal	splx
	 xor	a0, a0
#endif
	jal	updateimask		# Make sure SR imask is updated
	 xor	a0, a0			# and interrupts enabled

	jal	s0
	 move	a0,s1			# invoke callback.

	MFC0	t0, COP_0_STATUS_REG
	MFC0_HAZARD
	LI	t1, ~SR_INT_ENAB
	and	t0, t0, t1
	MTC0	t0, COP_0_STATUS_REG
	MTC0_SR_IE_HAZARD

	ori	t0, SR_EXL		# restoring to user mode.
	MTC0	t0, COP_0_STATUS_REG	# must set exception level bit.
	MTC0_SR_IE_HAZARD

	.set	noat
	GET_CPU_INFO(k1, k0)
	PTR_L	k0, CI_CURPROCPADDR(k1)
	RESTORE_CPU_SREG(k0, 0)
	RESTORE_REG(a0, PC, k0, 0)
#ifdef RM7000_ICR
	RESTORE_REG(t0, IC, k0, 0)
	ctc0	t0, COP_0_ICR
#endif
	RESTORE_CPU(k0, 0)
	RESTORE_REG(sp, SP, k0, 0)
	LI	k0, 0
	LI	k1, 0
	ERET
	.set	at
END(proc_trampoline)
@


1.56
log
@Remove RM7000/RM9000-specific performance counter code. It originates
from PMON2000 and has not been enabled on OpenBSD.

Suggested by and ok miod@@ (after seeing a quad_t cleanup patch of mine)
@
text
@d1 1
a1 1
/*	$OpenBSD: context.S,v 1.55 2016/08/14 08:23:52 visa Exp $ */
a42 10

#ifdef MIPS_PTE64
#define	PTE_LOG		3
#define	PTE_LOAD	ld
#define	PTE_OFFS	8
#else
#define	PTE_LOG		2
#define	PTE_LOAD	lw
#define	PTE_OFFS	4
#endif
@


1.55
log
@Utilize the TLB Execute-Inhibit bit with non-executable mappings on CPUs
that support the Execute-Inhibit exception. This makes user space W^X
effective on Octeon Plus and later Octeon versions.

Feedback from miod@@, thanks!
No objection from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: context.S,v 1.54 2015/09/29 17:07:53 miod Exp $ */
a346 25

#if 0	/* && defined(RM7000_ICR) */
	lw	t0, cpu_is_rm7k
	beqz	t0, 1f			# not an RM7K. Don't do IC reg.
	 NOP
	
	GET_CPU_INFO(t1, t0)
	PTR_L	t0, CI_CURPROC(t1)	# set up rm7k.
	ld	v0, P_WATCH_1(t0)
	dmtc0	v0, COP_0_WATCH_1
	ld	v0, P_WATCH_2(t0)
	dmtc0	v0, COP_0_WATCH_2
	lw	v0, P_WATCH_M(t0)
	mtc0	v0, COP_0_WATCH_M
	lw	v0, P_PC_CTRL(t0)
	lw	v1, P_PC_COUNT(t0)
	nop;nop
	mtc0	v0, COP_0_PC_CTRL
	nop;nop;nop;nop
	mtc0	v1, COP_0_PC_COUNT
	nop;nop;nop;nop
	li	v0, IC_INT_PERF
	ctc0	v0, COP_0_ICR		# enable perfcntr interrupt.
1:
#endif
@


1.54
log
@Use the DMTC0 macro and MTC0_HAZARD in the UPAGES > 1 case. Now R8000 kernel
have all their m[ft]c0 instructions correctly wrapped.
@
text
@d1 1
a1 1
/*	$OpenBSD: context.S,v 1.53 2014/03/22 00:01:04 miod Exp $ */
d242 2
a243 4
	dsll	ta0, ta0, (64 - PG_FRAMEBITS)	# clear bits left of PG_FRAME
	dsrl	ta0, ta0, (64 - PG_FRAMEBITS)
	dsll	ta1, ta1, (64 - PG_FRAMEBITS)
	dsrl	ta1, ta1, (64 - PG_FRAMEBITS)
d255 1
a255 2
	dsll	ta0, ta0, (64 - PG_FRAMEBITS)	# clear bits left of PG_FRAME
	dsrl	ta0, ta0, (64 - PG_FRAMEBITS)
d259 1
a259 2
	dsll	ta1, ta1, (64 - PG_FRAMEBITS)
	dsrl	ta1, ta1, (64 - PG_FRAMEBITS)
@


1.53
log
@Second draft of my attempt to workaround the infamous R4000 end-of-page errata,
affecting R4000 processors revision 2.x and below (found on most R4000 Indigo
and a few R4000 Indy).

Since this errata gets triggered by TLB misses when the code flow crosses a
page boundary, this code attempts to identify code pages prone to trigger the
errata, and force the next page to be mapped for at least as long as the
current pc lies in the troublesome page, by creating wiring extra TLB entries.
These entries get recycled in a lazy-but-aggressive-enough way, either because
of context switches, or because of further tlb exceptions reaching trap().

The errata workaround code is only compiled on R4000-capable kernels (i.e.
sgi GENERIC-IP22 and nothing else), and only enabled on affected processors
(i.e. not on R4000 revision 3, or on R4400).

There is still room for improvemnt in unlucky cases, but in this simple enough
incarnation, this allows my R4000 2.2 Indigo to finally reliably boot multiuser,
even though both /sbin/init and /bin/sh contain code pages which can trigger
the errata.
@
text
@d1 1
a1 1
/*	$OpenBSD: context.S,v 1.52 2014/02/08 09:34:04 miod Exp $ */
d290 2
a291 1
	dmtc0	v0, COP_0_TLB_HI		# init high entry (tlbid)
@


1.52
log
@Allow page table entries to be either 32 bits wide (the existing state of the
code), or 64 bits wide, if option MIPS_PTE64.
64-bit ptes allow for physical memory beyond 16GB (34 bits) to be addressable
by the pmap code.
@
text
@d1 1
a1 1
/*	$OpenBSD: context.S,v 1.51 2012/10/03 11:18:23 miod Exp $ */
d179 19
d215 1
a215 1
	LA	t1, VM_MIN_KERNEL_ADDRESS	# safe if expands to > 1 insn
d285 1
a291 2

ctx3:
@


1.51
log
@Split ever-growing mips <machine/cpu.h> into what 99% of the kernel needs,
which will remain in <machine/cpu.h>, and a new mips_cpu.h containing only the
goriest md details, which are only of interest to a handful set of files; this
is similar in spirit to what alpha does, but here <machine/cpu.h> does not
include the new file.
@
text
@d1 1
a1 1
/*	$OpenBSD: context.S,v 1.50 2012/09/29 21:37:03 miod Exp $ */
d44 10
d204 1
a204 1
	PTR_SLL	t2, 3
d221 2
a222 2
	lw	ta0, 0(t1)
	lw	ta1, 4(t1)
d236 2
a237 2
	lw	ta0, 8(t1)
	lw	ta1, 12(t1)
@


1.50
log
@Basic R8000 processor support. R8000 processors require MMU-specific code,
exception-specific code, clock-specific code, and L1 cache-specific code. L2
cache is per-design, of which only two exist: SGI Power Indigo2 (IP26) and SGI
Power Challenge (IP21) and are not covered by this commit.

R8000 processors also are 64-bit only processors with 64-bit coprocessor 0
registers, and lack so-called ``compatibility'' memory spaces allowing 32-bit
code to run with sign-extended addresses and registers.

The intrusive changes are covered by #ifdef CPU_R8000 stanzas. However,
trap() is split into a high-level wrapper and a new function, itsa(),
responsible for the actual trap servicing (which name couldn't be helped
because I'm an incorrigible punster). While an R8000 exception may cause
(via trap() ) multiple exceptions to be serviced, non-R8000 processors will
always service one exception in trap(), but they are nevertheless affected
by this code split.
@
text
@d1 1
a1 1
/*	$OpenBSD: context.S,v 1.49 2012/09/29 19:11:08 miod Exp $ */
d36 1
@


1.49
log
@Kill the mostly unused VMTLB_xxx and VMNUM_xxx defines. Move all tlb
knowledge to <machine/pte.h>. Add specific routines for tlb handling setup
(at cpu initialization time) and tlb ASID wrap.
@
text
@d1 1
a1 1
/*	$OpenBSD: context.S,v 1.48 2012/09/29 19:02:26 miod Exp $ */
d99 6
d107 1
d162 5
d169 3
@


1.48
log
@Introduce assembly macros for specific processor hazards: tlb update, status
register update, status register update causing a change to the interrupt
enable flag, and a few other arcane ones. <mips64/asm.h> will provide
(supposedly sane) defaults, and <machine/asm.h> may override these with
better tuned versions.

Use these macros instead of random strings of nop in the various .S files
requiring hazard workarounds.
@
text
@d1 1
a1 1
/*	$OpenBSD: context.S,v 1.47 2012/09/29 18:58:30 miod Exp $ */
d241 3
@


1.47
log
@Move proc_trampoline, which is not really exception processing, from exception.S
to context.S, to eventually allow alternate versions of exception.S to be used.
@
text
@d1 1
a1 1
/*	$OpenBSD: context.S,v 1.46 2012/04/24 20:01:03 miod Exp $ */
a43 1

d54 2
a55 1
	mfc0	v0, COP_0_STATUS_REG
d69 1
a69 1
	move	v0, zero
d74 1
a74 1
	nop
d79 1
a79 1
	nop
d84 1
a84 1
	nop
d100 1
a100 1
	mfc0	v0, COP_0_STATUS_REG
d122 4
a125 4
	li	v1, ~SR_INT_ENAB
	and	v0, v0, v1
	mtc0	v0, COP_0_STATUS_REG
	ITLBNOPFIX
d156 1
a156 1
#if UPAGES > 1
d175 1
d177 1
d188 1
a188 4
	nop
	nop
	nop
	nop
d190 1
a190 3
	nop
	nop
	nop
d203 2
a204 4
	nop
	PTR_ADDU v0, 2*NBPG
	nop
	nop
d206 1
d208 1
a208 1
#if UPAGES > 2
d214 1
d216 1
a216 1
	nop
d227 1
a227 4
	nop
	nop
	nop
	nop
d229 1
a229 3
	nop
	nop
	nop
d236 1
a236 4
	nop
	nop
	nop
	nop
d238 3
a240 6
#endif	/* UPAGES > 2 */
	nop
	nop
	nop
	nop
#else	/* UPAGES > 1 */
d242 1
a242 1
#endif	/* UPAGES > 1 */
d272 2
a273 2
	mtc0	v0, COP_0_STATUS_REG
	ITLBNOPFIX
d275 1
a275 1
	nop
@


1.46
log
@Introduce a #define for the number of PFN bits in a pte, to be used in the
.S code when masking the upper bits, instead of hardcoding them. Makes code
easier to understand (and also I might have a need to reduce PFN width on
some particular CPU models in the future).
No change in generated code.
@
text
@d1 1
a1 1
/*	$OpenBSD: context.S,v 1.45 2010/04/28 16:20:28 syuu Exp $ */
d291 79
@


1.45
log
@Storeing current cpu_info address into LLAddr register, for curcpu().
Instead of previous implementation, we won't use physical cpuid to fetch curcpu().
This requires to implement IP27/35 SMP.
Implemented getcurcpu() and setcurcpu() for it, smp_malloc() renamed alloc_contiguous_pages() because now it only allocate by page.
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: context.S,v 1.44 2010/02/13 14:04:45 miod Exp $ */
d34 1
d200 4
a203 4
	dsll	ta0, ta0, 34
	dsrl	ta0, ta0, 34
	dsll	ta1, ta1, 34
	dsrl	ta1, ta1, 34
d216 2
a217 2
	dsll	ta0, ta0, 34
	dsrl	ta0, ta0, 34
d220 2
a221 2
	dsll	ta1, ta1, 34
	dsrl	ta1, ta1, 34
@


1.44
log
@Since we don't use the saved ipl in pcb anymore, remove it from the struct
layout.
@
text
@d1 1
a1 1
/*	$OpenBSD: context.S,v 1.43 2010/01/28 21:24:08 miod Exp $ */
d148 2
a149 1
	HW_CPU_NUMBER(v0)			# cpuid
@


1.43
log
@The RA stack control bit on the loongson2 diagnostic register is not a clear
but a disable bit; rename the define and keep the RA stack disabled at all
times - I blame the few remaining hard freezes on it.
@
text
@d1 1
a1 1
/*	$OpenBSD: context.S,v 1.42 2010/01/28 05:27:16 miod Exp $ */
a62 2
	GET_CPU_INFO(t0, t1)
	lw	t0, CI_IPL(t0)
a66 1
	REG_S	t0, PCB_CONTEXT+13*REGSZ(a0)
a100 1
	lw	t0, CI_IPL(t1)
a115 1
	REG_S	t0, PCB_CONTEXT+13*REGSZ(t3)
@


1.42
log
@Make sure we also cause an iTLB and BTB flush on loongson processors during
regular tlb replacement, as well. Helps stability a lot, still not perfect.
@
text
@d1 1
a1 1
/*	$OpenBSD: context.S,v 1.41 2010/01/21 17:52:25 miod Exp $ */
d264 1
a264 1
	li	v0, COP_0_DIAG_ITLB_CLEAR | COP_0_DIAG_BTB_CLEAR /* | COP_0_DIAG_RAS_CLEAR */
@


1.41
log
@*Write* to the magic Loongson2 register to invalidate iTLB and branch
prediction caches, instead of *reading* it. Ahem. Blush.
Yeelong lemote now run single user.
@
text
@d1 1
a1 1
/*	$OpenBSD: context.S,v 1.40 2010/01/18 17:04:11 miod Exp $ */
d264 1
a264 8
#if 0	/* enable if Loongson2 + R5K|R10K kernel ever exist... */
	mfc0	v0, COP_0_PRID
	and	v0, 0xff00
	sub	v0, (MIPS_LOONGSON2 << 8)
	bnez	v0, 7f
	nop
#endif
	li	v0, COP_0_DIAG_ITLB_CLEAR | COP_0_DIAG_BTB_CLEAR | COP_0_DIAG_RAS_CLEAR
a265 1
7:
@


1.40
log
@Do not call splx() from cpu_switchto(), we are at IPL_SCHED anyway and ipl will
be lowered later, by the caller. This was supposed to be harmless, but newly
created processes inherit a bogus level from proc0, which in turn causes a
race on MULTIPROCESSOR kernel.
@
text
@d1 1
a1 1
/*	$OpenBSD: context.S,v 1.39 2010/01/10 13:00:24 miod Exp $ */
d267 1
a267 1
	subi	v0, (MIPS_LOONGSON2 << 8)
d272 1
a272 1
	mfc0	v0, COP_0_DIAG
@


1.39
log
@Make sure END() matches the *{LEAF,ENTRY}() function names.
@
text
@d1 1
a1 1
/*	$OpenBSD: context.S,v 1.38 2010/01/08 01:35:52 syuu Exp $ */
a289 2
	jal	splx
	REG_L	a0, PCB_CONTEXT+13*REGSZ(t3)
@


1.38
log
@MP-safe FPU handling. ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: context.S,v 1.37 2010/01/07 20:24:15 miod Exp $ */
d303 1
a303 1
END(cpu_switchto)
@


1.37
log
@Make sure to update p_cpu on MULTIPROCESSOR kernels.
@
text
@d1 1
a1 1
/*	$OpenBSD: context.S,v 1.36 2010/01/05 06:44:58 syuu Exp $ */
d90 1
a90 1
 * cpu_switchto(struct proc *oldproc, struct proc *newproc)
d92 1
a92 1
NON_LEAF(cpu_switchto, FRAMESZ(CF_SZ), ra)
@


1.36
log
@Dynamic allocation for ASID and ASID generation number on struct pmap. ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: context.S,v 1.35 2009/12/28 06:55:27 syuu Exp $ */
d143 3
@


1.35
log
@MP-safe pmap implemented, enable IPI in interrupt handler to avoid deadlock.
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: context.S,v 1.34 2009/12/12 20:07:10 miod Exp $ */
d151 1
a151 1
	PTR_SLL	v0, v0, 0x2
d154 1
a154 1
	lw	v0, PM_TLBPID(t1)		# ->pm_tlbpid[cpuid]
@


1.34
log
@Introduce various CPU_### options to enable cpu-specific code or workarounds;
be sure to rerun config(8) on your kernel configuration files.
@
text
@d1 1
a1 1
/*	$OpenBSD: context.S,v 1.33 2009/12/08 22:14:43 miod Exp $ */
d149 6
a154 1
	lw	v0, PM_TLBPID(t1)		# ->pm_tlbpid
@


1.33
log
@In cpu_switchto(), correctly ignore CKSEG0 curprocpaddr (and do not update the
wired TLB entries).
@
text
@d1 1
a1 1
/*	$OpenBSD: context.S,v 1.32 2009/12/07 19:01:06 miod Exp $ */
a74 8
#if defined(TGT_CP7000) || defined(TGT_CP7000G)
	PTR_L	t2, misc_h		# if non zero, do Ocelot LEDs.
	beqz	t2, 1f
	li	t0, 0x40
	sb	t0, 0x0d(t2)
1:
#endif

a79 8
#if defined(TGT_CP7000) || defined(TGT_CP7000G)
	PTR_L	t2, misc_h		# if non zero, do Ocelot LEDs.
	beqz	t2, 1f
	li	t0, 0x40
	sb	t0, 0x0c(t2)
1:
#endif

@


1.32
log
@If UPAGES would turn out to be 1, instead of using wired TLB entries to map
the u area after each context switch, simply convert it to an XKPHYS address,
so that access to it never faults. Idea from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: context.S,v 1.31 2009/11/19 20:16:27 miod Exp $ */
d167 1
a170 1
#if UPAGES > 1
d178 4
a181 1
	LA	t1, (VM_MIN_KERNEL_ADDRESS)
d192 1
a192 1
	LA	t2, CKSEG0_BASE		# NOTE: if > 1 ins, does not matter
d265 2
@


1.31
log
@Rename KSEG* defines to CKSEG* to match their names in 64 bit mode; also
define more 64 bit spaces.
@
text
@d1 1
a1 1
/*	$OpenBSD: context.S,v 1.30 2009/10/22 22:08:54 miod Exp $ */
d162 9
a177 7
	/* get process ASID */
	PTR_L	t0, P_VMSPACE(s0)		# p->p_vmspace
	PTR_L	t1, VMSPACE_PMAP(t0)		# ->vm_map.pmap
	lw	v0, PM_TLBPID(t1)		# ->pm_tlbpid

	or	v0, t3
	dmtc0	v0, COP_0_TLB_HI		# init high entry (tlbid)
d220 1
a220 1
#if (UPAGES != 2)
d257 1
a257 1
#endif
d262 1
@


1.30
log
@Completely overhaul interrupt handling on sgi. Cpu state now only stores a
logical IPL level, and per-platform (IP27/IP30/IP32) code will from the
necessary hardware mask registers.

This allows the use of more than one interrupt mask register. Also, the
generic (platform independent) interrupt code shrinks a lot, and the actual
interrupt handler chains and masking information is now per-platform private
data.

Interrupt dispatching is generated from a template; more routines will be
added to the template to reduce platform-specific changes and share as much
code as possible.

Tested on IP27, IP30, IP32 and IP35.
@
text
@d1 1
a1 1
/*	$OpenBSD: context.S,v 1.29 2009/10/22 18:46:48 miod Exp $ */
d187 1
a187 1
	LA	t2, KSEG0_BASE		# NOTE: if > 1 ins, does not matter
@


1.29
log
@Change the #define controlling use of RM7k/RM9k coprocessor 0 ICR to
RM7000_ICR, instead of IMASK_EXTERNAL, since they are actually different
concepts. This code remains disabled since RM7000_ICR is not defined anywhere
at the moment.
@
text
@d1 1
a1 1
/*	$OpenBSD: context.S,v 1.28 2009/10/22 18:31:51 miod Exp $ */
d64 1
a64 1
	lw	t0, CI_CPL(t0)
d120 1
a120 1
	lw	t0, CI_CPL(t1)
@


1.28
log
@Remove a never hit debug panic I commited by accident sometime ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: context.S,v 1.27 2009/10/22 18:23:12 miod Exp $ */
d65 1
a65 1
#ifndef IMASK_EXTERNAL
d132 1
a132 1
#ifndef IMASK_EXTERNAL
d294 1
a294 1
#ifndef IMASK_EXTERNAL
@


1.27
log
@Only play with RM7k coprocessor 0 ICR if IMASK_EXTERNAL is not defined.
Paves the way for instrusive upcoming changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: context.S,v 1.26 2009/10/22 18:21:40 miod Exp $ */
d131 2
a133 1
	REG_S	v0, PCB_CONTEXT+11*REGSZ(t3)
d135 1
@


1.26
log
@At the end of a context switch and in proc_trampoline(), instead of doing the
`restore cpl and invoke hw_setintrmask' slippery dance, just invoke splx().
@
text
@d1 1
a1 1
/*	$OpenBSD: context.S,v 1.25 2009/10/07 08:35:47 syuu Exp $ */
d65 1
d68 1
@


1.25
log
@ipending, cpl moved into cpu_info
OK miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: context.S,v 1.24 2009/09/30 06:22:00 syuu Exp $ */
a275 1
	REG_L	a0, PCB_CONTEXT+13*REGSZ(t3)
d286 2
a287 6
	GET_CPU_INFO(t1, t0)
	sw	a0, CI_CPL(t1)
#ifdef IMASK_EXTERNAL
	jal	hw_setintrmask
	nop
#endif
d290 1
a291 1
#ifndef IMASK_EXTERNAL
@


1.24
log
@curproc, curprocpaddr moved into cpu_info
OK miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: context.S,v 1.23 2009/08/06 21:11:39 miod Exp $ */
d63 2
a65 1
	lw	t0, cpl
d118 1
a118 1
	lw	t0, cpl
d287 2
a288 1
	sw	a0, cpl
@


1.23
log
@Work in progress support for Loongson2E/2F processors; need option CPU_LOONGSON2
in the kernel to be brought in, due to invasive differences in tlb operation.
Comes with a separate cache operations file due to the cache being R5k-style
with R10k-style way number encoding.
@
text
@d1 1
a1 1
/*	$OpenBSD: context.S,v 1.22 2009/05/22 20:37:53 miod Exp $ */
a41 2
#define curproc	(cpu_info_primary + CI_CURPROC)

d106 2
a107 1
	PTR_L	t3, curprocpaddr
d150 4
a153 3
	PTR_S	s0, curproc			# set curproc
	PTR_S	t3, curprocpaddr

@


1.22
log
@Drop almost unused <machine/psl.h> on sgi; move USERMODE() definition from
there to trap.c which is its only user. This also cleans up multiple
inclusion of <machine/cpu.h> (because <machine/psl.h> includes it) in many
places.
@
text
@d1 1
a1 1
/*	$OpenBSD: context.S,v 1.21 2009/05/21 16:10:38 miod Exp $ */
d36 3
d257 13
@


1.21
log
@Make sure cpu_switchto() returns to the new proc with interrupts enabled (this
is bandaid until interrupt handling is made more sane.
@
text
@d1 1
a1 1
/*	$OpenBSD: context.S,v 1.20 2008/07/28 19:08:46 miod Exp $ */
a31 1
#include <machine/psl.h>
@


1.20
log
@No longer clear ci_want_resched within cpu_switchto(), now that it's done
in the MI code.
@
text
@d1 1
a1 1
/*	$OpenBSD: context.S,v 1.19 2008/02/16 18:43:27 miod Exp $ */
d282 1
@


1.19
log
@Remove the wait instruction from cpu_idle_cycle(), as it causes problems on
RM7000 machines.
@
text
@d1 1
a1 1
/*	$OpenBSD: context.S,v 1.18 2007/11/24 19:39:20 miod Exp $ */
a144 1
	sw	zero, want_resched
@


1.18
log
@Recognize the wait r5k instruction in ddb and use it in cpu_idle_cycle.
ok jsing@@ a while ago (and this diff is much much older)
@
text
@d1 1
a1 1
/*	$OpenBSD: context.S,v 1.17 2007/10/24 20:01:36 miod Exp $ */
a97 1
	wait
@


1.17
log
@In cpu_switchto(), load pmap->pm_tlbpid manually, instead of expecting
pmap_update() to return with this value in v0. A void function. Bwahahaha.
@
text
@d1 1
a1 1
/*	$OpenBSD: context.S,v 1.16 2007/10/18 04:32:25 miod Exp $ */
d98 1
@


1.16
log
@No need to include <machine/pte.h> here.
@
text
@d1 1
a1 1
/*	$OpenBSD: context.S,v 1.15 2007/10/13 12:46:18 miod Exp $ */
d114 1
a114 1
	nop
a116 1
	REG_S	t0, PCB_CONTEXT+13*REGSZ(t3)
a126 1
	mfc0	t0, COP_0_STATUS_REG
d128 1
a128 1
	REG_S	t0, PCB_CONTEXT+11*REGSZ(t3)
d130 1
a135 1
	mfc0	v0, COP_0_STATUS_REG	# disable interrupts
d162 5
@


1.15
log
@There is no need to fiddle with spl in cpu_idle_{enter,leave}, actually.
@
text
@d1 1
a1 1
/*	$OpenBSD: context.S,v 1.14 2007/10/10 15:53:52 art Exp $ */
a36 1
#include <machine/pte.h>
@


1.14
log
@Make context switching much more MI:
 - Move the functionality of choosing a process from cpu_switch into
   a much simpler function: cpu_switchto. Instead of having the locore
   code walk the run queues, let the MI code choose the process we
   want to run and only implement the context switching itself in MD
   code.
 - Let MD context switching run without worrying about spls or locks.
 - Instead of having the idle loop implemented with special contexts
   in MD code, implement one idle proc for each cpu. make the idle
   loop MI with MD hooks.
 - Change the proc lists from the old style vax queues to TAILQs.
 - Change the sleep queue from vax queues to TAILQs. This makes
   wakeup() go from O(n^2) to O(n)

there will be some MD fallout, but it will be fixed shortly.
There's also a few cleanups to be done after this.

deraadt@@, kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: context.S,v 1.13 2007/07/16 20:22:18 miod Exp $ */
d72 1
a72 25
NON_LEAF(cpu_idle_enter, FRAMESZ(CF_SZ), ra)
	PTR_SUBU sp, sp, FRAMESZ(CF_SZ)
	PTR_S	ra, CF_RA_OFFS(sp)
	.mask	0x80000000, (CF_RA_OFFS - FRAMESZ(CF_SZ))

	sw	zero, cpl		# lower to spl0
	lw	t0, ipending
	beqz	t0, 1f
	nop
	jal	setsoftintr0
	nop
1:
	mfc0	a0, COP_0_STATUS_REG	# ... and enable interrupts
	li	a1, SR_INT_ENAB
	or	a0, a0, a1
	mtc0	a0, COP_0_STATUS_REG
	ITLBNOPFIX

#ifdef IMASK_EXTERNAL
	jal	hw_setintrmask
	xor	a0, a0
#endif
	jal	updateimask		# Make sure SR imask is updated
	xor	a0, a0

a80 1
	PTR_L	ra, CF_RA_OFFS(sp)
d82 1
a82 1
	PTR_ADDU sp, sp, FRAMESZ(CF_SZ)
a92 6

	mfc0	a0, COP_0_STATUS_REG	# disable interrupts
	li	a1, ~SR_INT_ENAB
	and	a0, a0, a1
	mtc0	a0, COP_0_STATUS_REG
	ITLBNOPFIX
@


1.13
log
@On exit from switch_exit(), do not bother saving context and immediately
jump into the scheduler loop.
@
text
@d1 1
a1 1
/*	$OpenBSD: context.S,v 1.12 2007/07/01 19:12:42 miod Exp $ */
d72 1
a72 36
/*
 * The following primitives manipulate the run queues.  _whichqs tells which
 * of the 32 queues _qs have processes in them.  Setrunqueue puts processes
 * into queues, Remrq removes them from queues.  The running process is on
 * no queue, other processes are on a queue related to p->p_priority, divided
 * by 4 actually to shrink the 0-127 range of priorities into the 32 available
 * queues.
 */
/*
 * setrunqueue(p)
 *	proc *p;
 *
 * Call should be made at splclock(), and p->p_stat should be SRUN.
 */
NON_LEAF(setrunqueue, FRAMESZ(CF_SZ), ra)
	.mask	0x80000000, (CF_RA_OFFS - FRAMESZ(CF_SZ))
	PTR_L	t0, P_BACK(a0)		## firewall: p->p_back must be 0
	bne	t0, zero, 1f		##
	lbu	t0, P_PRIORITY(a0)	# put on p->p_priority / 4 queue
	li	t1, 1			# compute corresponding bit
	srl	t0, t0, 2		# compute index into 'whichqs'
	sll	t1, t1, t0
	lw	t2, whichqs		# set corresponding bit
	sll	t0, t0, LOGREGSZ+1	# compute index into 'qs'
	or	t2, t2, t1
	sw	t2, whichqs
	LA	t1, qs
	PTR_ADDU t0, t0, t1		# t0 = qp = &qs[pri >> 2]
	PTR_L	t1, P_BACK(t0)		# t1 = qp->ph_rlink
	PTR_S	t0, P_FORW(a0)		# p->p_forw = qp
	PTR_S	t1, P_BACK(a0)		# p->p_back = qp->ph_rlink
	PTR_S	a0, P_FORW(t1)		# p->p_back->p_forw = p;
	j	ra
	PTR_S	a0, P_BACK(t0)		# qp->ph_rlink = p

1:
a74 11
	PANIC("setrunqueue")
	jr	ra
	nop
END(setrunqueue)

/*
 * Remrq(p)
 *
 * Call should be made at splclock().
 */
NON_LEAF(remrunqueue, FRAMESZ(CF_SZ), ra)
a75 22
	lbu	t0, P_PRIORITY(a0)	# get from p->p_priority / 4 queue
	li	t1, 1			# compute corresponding bit
	srl	t0, t0, 2		# compute index into 'whichqs'
	lw	t2, whichqs		# check corresponding bit
	sll	t1, t1, t0
	and	v0, t2, t1
	beqz	v0, 2f			# oops! queue is empty!
	PTR_L	v0, P_BACK(a0)		# v0 = p->p_back

	PTR_L	v1, P_FORW(a0)		# v1 = p->p_forw
	PTR_SLL	t0, t0, LOGREGSZ+1	# compute index into 'qs'
	PTR_S	v1, P_FORW(v0)		# p->p_back->p_forw = p->p_forw;
	PTR_S	v0, P_BACK(v1)		# p->p_forw->p_back = p->r_rlink
	LA	v0, qs
	PTR_ADDU t0, t0, v0		# t0 = qp = &qs[pri >> 2]
	PTR_L	v0, P_FORW(t0)		# check if queue empty
	bne	v0, t0, 1f		# No. qp->ph_link != qp
	xor	t2, t2, t1		# clear corresponding bit in 'whichqs'
	sw	t2, whichqs
1:
	j	ra
	PTR_S	zero, P_BACK(a0)	# for firewall checking
a76 13
2:
	PTR_SUBU sp, sp, FRAMESZ(CF_SZ)
	PTR_S	ra, CF_RA_OFFS(sp)
	PANIC("remrunqueue empty")
	jr	ra
	nop
END(remrunqueue)

/*
 *   Idle, this is where we spend time when nothing to do.
 */
LEAF(idle, 0)
_idle:
a96 1
	li	t1,1
d102 1
d104 7
a110 4
1:
	lw	t0, whichqs		# look for non-empty queue
	beq	t0, zero, 1b
	nop
d112 2
a113 1
	beqz	t2, sw1
d116 1
a117 7
	b	sw1			# Hey, time to do some work!
	nop
	jr	ra			# DDB trace
	nop
	.globl e_idle
e_idle:
END(idle)
d119 4
a122 11
/*
 * switch_exit(p)
 *
 * At exit of a process, do a cpu_switch for the last time.
 * All interrupts should be blocked at this point.
 */
LEAF(switch_exit, 0)
	mfc0	v0, COP_0_STATUS_REG
	li	v1, ~SR_INT_ENAB
	and	v0, v0, v1
	mtc0	v0, COP_0_STATUS_REG
d124 2
a125 2
	LA	sp, idle_stack - FRAMESZ(CF_SZ)
	jal	exit2
d127 1
d129 2
a130 4
	PTR_S	zero, curproc
	b	sw0
	nop
	jr	ra			# DDB trace
d132 1
a132 1
END(switch_exit)
d135 1
a135 2
 * cpu_switch()
 * Find the highest priority process and resume it.
d137 1
a137 1
NON_LEAF(cpu_switch, FRAMESZ(CF_SZ), ra)
d140 1
d144 4
d165 5
a169 9
sw0:
#	lw	t2, cnt+V_SWTCH			# for statistics
	lw	t1, whichqs			# look for non-empty queue
#	addu	t2, t2, 1
#	sw	t2, cnt+V_SWTCH
	beq	t1, zero, _idle			# if none, idle
	nop
sw1:
	mfc0	v0, COP_0_STATUS_REG
d174 5
a178 30
	lw	t0, whichqs			# look for non-empty queue
	li	t2, -1				# t2 = lowest bit set
	beq	t0, zero, _idle			# if none, idle
	move	t3, t0				# t3 = saved whichqs
1:
	addu	t2, t2, 1
	and	t1, t0, 1			# bit set?
	beq	t1, zero, 1b
	srl	t0, t0, 1			# try next bit
/*
 * Remove process from queue.
 */
	PTR_SLL	t0, t2, LOGREGSZ+1
	LA	t1, qs
	PTR_ADDU t0, t0, t1			# t0 = qp = &qs[highbit]
	PTR_L	a0, P_FORW(t0)			# a0 = p = highest pri process
	PTR_L	v0, P_FORW(a0)			# v0 = p->p_forw
	beq	t0, a0, 4f			# make sure something in queue
	PTR_S	v0, P_FORW(t0)			# qp->ph_link = p->p_forw;
	PTR_S	t0, P_BACK(v0)			# p->p_forw->p_back = qp
	bne	v0, t0, 2f			# queue still not empty
	PTR_S	zero, P_BACK(a0)		## for firewall checking
	li	v1, 1				# compute bit in 'whichqs'
	sll	v1, v1, t2
	xor	t3, t3, v1			# clear bit in 'whichqs'
	sw	t3, whichqs
2:
/*
 * Switch to new context.
 */
d180 2
a181 9
	jal	pmap_activate			# v0 = TLB PID
	move	s0, a0				# BDSLOT: save p

/*
 * We need to wire the process kernel stack mapping so there
 * will be no tlb misses in exception handlers. This is done
 * by invalidating any tlb entries mapping the U-area and
 * put valid mappings in tlb entries 0 and 1.
 */
d190 7
d286 4
a289 3
/*
 * Restore registers and return.
 */
d316 1
a316 3
4:
	PANIC("cpu_switch")			# nothing in queue
END(cpu_switch)
@


1.12
log
@In cpu_switch(), store the saved cpl in the pcb as a 64 bit store, so that
the high order bits are not undefined when invoking hw_setintrmask() on
return.
@
text
@d1 1
a1 1
/*	$OpenBSD: context.S,v 1.11 2007/05/09 19:19:26 miod Exp $ */
a157 1
	PTR_S	zero, curproc		# set curproc NULL for stats
d165 1
a165 1
	mfc0	a0, COP_0_STATUS_REG
a185 2
	beq	t1, zero, 2f		# check if stuck in idle!
	addu	t1, t1, 1
a195 4
2:
	break   BREAK_SOVER_VAL		# interrupt stuck!?
	b	1b
	nop
d219 4
d224 1
a224 1
	/* FALL THROUGH TO cpu switch! */
a236 1
#	lw	t2, cnt+V_SWTCH			# for statistics
d252 2
@


1.11
log
@When entering the idle loop, do a real spl0 (processing soft interrupts)
instead of simply lowering cpl to zero.
@
text
@d1 1
a1 1
/*	$OpenBSD: context.S,v 1.10 2007/05/07 18:42:13 kettenis Exp $ */
d239 1
a239 1
	sw	t0, PCB_CONTEXT+13*REGSZ(t3)
@


1.10
log
@Move sgo to __HAVE_CPUINFO.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: context.S,v 1.9 2005/12/20 07:06:26 miod Exp $ */
d160 6
a165 1

@


1.9
log
@Since we are allowed to rely on the fact that the pcb is the first element
of struct user, use syntactic sugar in genassym.cf and use PCB_xxx defines
instead of U_PCB_xxx, like all other platforms do; no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: context.S,v 1.8 2004/09/27 19:16:06 pefo Exp $ */
d40 2
@


1.8
log
@move ITLBNOPFIX to asm.h and make it conditional
@
text
@d1 1
a1 1
/*	$OpenBSD: context.S,v 1.7 2004/09/27 17:41:56 pefo Exp $ */
d49 4
a52 4
	REG_S	s0, U_PCB_CONTEXT+0*REGSZ(a0)
	REG_S	s1, U_PCB_CONTEXT+1*REGSZ(a0)
	REG_S	s2, U_PCB_CONTEXT+2*REGSZ(a0)
	REG_S	s3, U_PCB_CONTEXT+3*REGSZ(a0)
d54 8
a61 8
	REG_S	s4, U_PCB_CONTEXT+4*REGSZ(a0)
	REG_S	s5, U_PCB_CONTEXT+5*REGSZ(a0)
	REG_S	s6, U_PCB_CONTEXT+6*REGSZ(a0)
	REG_S	s7, U_PCB_CONTEXT+7*REGSZ(a0)
	REG_S	sp, U_PCB_CONTEXT+8*REGSZ(a0)
	REG_S	s8, U_PCB_CONTEXT+9*REGSZ(a0)
	REG_S	ra, U_PCB_CONTEXT+10*REGSZ(a0)
	REG_S	v0, U_PCB_CONTEXT+11*REGSZ(a0)
d64 2
a65 2
	REG_S	t1, U_PCB_CONTEXT+12*REGSZ(a0)	# save status register
	REG_S	t0, U_PCB_CONTEXT+13*REGSZ(a0)
d227 1
a227 1
	REG_S	sp, U_PCB_CONTEXT+8*REGSZ(t3)	# save old sp
d232 1
a232 1
	sw	t0, U_PCB_CONTEXT+13*REGSZ(t3)
d234 10
a243 10
	REG_S	s0, U_PCB_CONTEXT+0*REGSZ(t3)	# do a 'savectx()'
	REG_S	s1, U_PCB_CONTEXT+1*REGSZ(t3)
	REG_S	s2, U_PCB_CONTEXT+2*REGSZ(t3)
	REG_S	s3, U_PCB_CONTEXT+3*REGSZ(t3)
	REG_S	s4, U_PCB_CONTEXT+4*REGSZ(t3)
	REG_S	s5, U_PCB_CONTEXT+5*REGSZ(t3)
	REG_S	s6, U_PCB_CONTEXT+6*REGSZ(t3)
	REG_S	s7, U_PCB_CONTEXT+7*REGSZ(t3)
	REG_S	s8, U_PCB_CONTEXT+9*REGSZ(t3)
	REG_S	ra, U_PCB_CONTEXT+10*REGSZ(t3)
d246 2
a247 2
	REG_S	t0, U_PCB_CONTEXT+11*REGSZ(t3)
	REG_S	t1, U_PCB_CONTEXT+12*REGSZ(t3)
d400 11
a410 11
	REG_L	a0, U_PCB_CONTEXT+13*REGSZ(t3)
	REG_L	s0, U_PCB_CONTEXT+0*REGSZ(t3)
	REG_L	s1, U_PCB_CONTEXT+1*REGSZ(t3)
	REG_L	s2, U_PCB_CONTEXT+2*REGSZ(t3)
	REG_L	s3, U_PCB_CONTEXT+3*REGSZ(t3)
	REG_L	s4, U_PCB_CONTEXT+4*REGSZ(t3)
	REG_L	s5, U_PCB_CONTEXT+5*REGSZ(t3)
	REG_L	s6, U_PCB_CONTEXT+6*REGSZ(t3)
	REG_L	s7, U_PCB_CONTEXT+7*REGSZ(t3)
	REG_L	sp, U_PCB_CONTEXT+8*REGSZ(t3)
	REG_L	s8, U_PCB_CONTEXT+9*REGSZ(t3)
d416 3
a418 3
	REG_L	ra, U_PCB_CONTEXT+10*REGSZ(t3)
	REG_L	v0, U_PCB_CONTEXT+11*REGSZ(t3)
	REG_L	v1, U_PCB_CONTEXT+12*REGSZ(t3)
@


1.7
log
@rearrange code to avoid asm warnings
@
text
@d1 1
a1 1
/*	$OpenBSD: context.S,v 1.6 2004/09/10 09:32:13 pefo Exp $ */
a43 2

#define	ITLBNOPFIX	nop;nop;nop;nop;nop;nop;nop;nop;nop;nop;
@


1.6
log
@Use correct register aliases wrt the __mips_n64 regdef.
@
text
@d1 1
a1 1
/*	$OpenBSD: context.S,v 1.5 2004/09/10 08:58:27 pefo Exp $ */
d157 1
d254 1
a254 1
	beq	t1, zero, idle			# if none, idle
d264 1
a264 1
	beq	t0, zero, idle			# if none, idle
d315 1
a317 1
	PTR_SRL	t2, PGSHIFT+1
@


1.5
log
@Fix LEAF usage adding new extra arg. spotted by miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: context.S,v 1.4 2004/09/09 22:11:38 pefo Exp $ */
d339 8
a346 8
	lw	ta4, 0(t1)
	lw	ta5, 4(t1)
	dsll	ta4, ta4, 34
	dsrl	ta4, ta4, 34
	dsll	ta5, ta5, 34
	dsrl	ta5, ta5, 34
	dmtc0	ta4, COP_0_TLB_LO0
	dmtc0	ta5, COP_0_TLB_LO1
d355 4
a358 4
	lw	ta4, 8(t1)
	lw	ta5, 12(t1)
	dsll	ta4, ta4, 34
	dsrl	ta4, ta4, 34
d361 2
a362 2
	dsll	ta5, ta5, 34
	dsrl	ta5, ta5, 34
d383 2
a384 2
	dmtc0	ta4, COP_0_TLB_LO0
	dmtc0	ta5, COP_0_TLB_LO1
@


1.4
log
@Kernel moves to 64 bit. A few more tweaks when binutils is updated.
@
text
@d1 1
a1 1
/*	$OpenBSD: context.S,v 1.3 2004/08/10 20:15:47 deraadt Exp $ */
d50 1
a50 1
LEAF(savectx)
d156 1
a156 1
LEAF(idle)
d209 1
a209 1
LEAF(switch_exit)
@


1.3
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: context.S,v 1.2 2004/08/09 14:57:26 pefo Exp $ */
d62 1
a62 1
	PTR_S	ra, U_PCB_CONTEXT+10*REGSZ(a0)
d66 2
a67 2
	sw	t1, U_PCB_CONTEXT+12*REGSZ(a0)	# save status register
	sw	t0, U_PCB_CONTEXT+13*REGSZ(a0)
d228 1
a228 1
	PTR_S	sp, U_PCB_CONTEXT+8*REGSZ(t3)	# save old sp
d230 1
a230 1
	PTR_S	ra, CF_RA_OFFS(sp)
d244 1
a244 1
	PTR_S	ra, U_PCB_CONTEXT+10*REGSZ(t3)
d339 8
a346 8
	lw	t4, 0(t1)
	lw	t5, 4(t1)
	dsll	t4, t4, 34
	dsrl	t4, t4, 34
	dsll	t5, t5, 34
	dsrl	t5, t5, 34
	dmtc0	t4, COP_0_TLB_LO0
	dmtc0	t5, COP_0_TLB_LO1
d355 4
a358 4
	lw	t4, 8(t1)
	lw	t5, 12(t1)
	dsll	t4, t4, 34
	dsrl	t4, t4, 34
d361 2
a362 2
	dsll	t5, t5, 34
	dsrl	t5, t5, 34
d383 2
a384 2
	dmtc0	t4, COP_0_TLB_LO0
	dmtc0	t5, COP_0_TLB_LO1
d401 1
a401 1
	lw	a0, U_PCB_CONTEXT+13*REGSZ(t3)
d417 3
a419 3
	PTR_L	ra, U_PCB_CONTEXT+10*REGSZ(t3)
	lw	v0, U_PCB_CONTEXT+11*REGSZ(t3)
	lw	v1, U_PCB_CONTEXT+12*REGSZ(t3)
@


1.2
log
@Big cleanup. Removed some unused obsolete stuff and fixed copyrights
on some files. Arcbios support is now in, thus detects memorysize and cpu
clock frequency.
@
text
@d1 1
a1 1
/*	$OpenBSD: context.S,v 1.1 2004/08/06 20:56:03 pefo Exp $ */
d5 1
a5 1
 * 
@


1.1
log
@initial mips64
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a13 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Opsycon AB, Sweden.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@

