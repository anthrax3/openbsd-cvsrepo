head	1.34;
access;
symbols
	OPENBSD_6_1_BASE:1.34
	OPENBSD_6_0:1.33.0.2
	OPENBSD_6_0_BASE:1.33
	OPENBSD_5_9:1.32.0.2
	OPENBSD_5_9_BASE:1.32
	OPENBSD_5_8:1.32.0.4
	OPENBSD_5_8_BASE:1.32
	OPENBSD_5_7:1.31.0.2
	OPENBSD_5_7_BASE:1.31
	OPENBSD_5_6:1.29.0.4
	OPENBSD_5_6_BASE:1.29
	OPENBSD_5_5:1.28.0.8
	OPENBSD_5_5_BASE:1.28
	OPENBSD_5_4:1.28.0.4
	OPENBSD_5_4_BASE:1.28
	OPENBSD_5_3:1.28.0.2
	OPENBSD_5_3_BASE:1.28
	OPENBSD_5_2:1.25.0.2
	OPENBSD_5_2_BASE:1.25
	OPENBSD_5_1_BASE:1.24
	OPENBSD_5_1:1.24.0.6
	OPENBSD_5_0:1.24.0.4
	OPENBSD_5_0_BASE:1.24
	OPENBSD_4_9:1.24.0.2
	OPENBSD_4_9_BASE:1.24
	OPENBSD_4_8:1.23.0.4
	OPENBSD_4_8_BASE:1.23
	OPENBSD_4_7:1.23.0.2
	OPENBSD_4_7_BASE:1.23
	OPENBSD_4_6:1.18.0.10
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.18.0.6
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.18.0.4
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.18.0.2
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.14.0.2
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.9.0.2
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.7.0.8
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.6
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.4
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.2
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.3.0.2
	OPENBSD_3_6_BASE:1.3;
locks; strict;
comment	@ * @;


1.34
date	2017.02.12.04.55.08;	author guenther;	state Exp;
branches;
next	1.33;
commitid	1rXx7AiXIWFC9gYa;

1.33
date	2016.03.06.19.42.27;	author mpi;	state Exp;
branches;
next	1.32;
commitid	cyYKarj4qRTft4gD;

1.32
date	2015.05.05.02.13.47;	author guenther;	state Exp;
branches;
next	1.31;
commitid	dNPv28CJI5BxtRGW;

1.31
date	2014.12.16.18.30.03;	author tedu;	state Exp;
branches;
next	1.30;
commitid	P6Av4XGqOi3rFasL;

1.30
date	2014.11.16.12.30.58;	author deraadt;	state Exp;
branches;
next	1.29;
commitid	yv0ECmCdICvq576h;

1.29
date	2014.05.10.22.25.16;	author jasper;	state Exp;
branches;
next	1.28;

1.28
date	2013.01.16.19.04.43;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2012.10.03.11.18.23;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2012.09.29.21.37.03;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2012.03.19.21.56.49;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2010.11.24.21.16.28;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2010.02.13.14.04.45;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2010.01.08.01.35.52;	author syuu;	state Exp;
branches;
next	1.21;

1.21
date	2009.12.07.19.01.06;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2009.10.22.22.08.54;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2009.10.22.18.46.48;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2007.10.18.04.32.25;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2007.10.13.07.18.01;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2007.10.10.15.53.52;	author art;	state Exp;
branches;
next	1.15;

1.15
date	2007.09.03.17.35.51;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2007.07.16.20.20.08;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2007.06.20.17.29.36;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2007.05.27.20.59.25;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2007.05.09.19.21.49;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2007.04.26.17.04.33;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2007.02.24.11.59.47;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2006.11.29.12.26.13;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2005.01.31.21.35.50;	author grange;	state Exp;
branches;
next	1.6;

1.6
date	2004.09.20.10.29.57;	author pefo;	state Exp;
branches;
next	1.5;

1.5
date	2004.09.17.21.29.38;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2004.09.17.19.28.05;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.10.20.28.13;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2004.08.10.20.15.47;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2004.08.06.20.56.03;	author pefo;	state Exp;
branches;
next	;


desc
@@


1.34
log
@Split up fork1():
 - FORK_THREAD handling is a totally separate function, thread_fork(),
   that is only used by sys___tfork() and which loses the flags, func,
   arg, and newprocp parameters and gains tcb parameter to guarantee
   the new thread's TCB is set before the creating thread returns
 - fork1() loses its stack and tidptr parameters
Common bits factor out:
 - struct proc allocation and initialization moves to thread_new()
 - maxthread handling moves to fork_check_maxthread()
 - setting the new thread running moves to fork_thread_start()
The MD cpu_fork() function swaps its unused stacksize parameter for
a tcb parameter.

luna88k testing by aoyama@@, alpha testing by dlg@@
ok mpi@@
@
text
@/*	$OpenBSD: vm_machdep.c,v 1.33 2016/03/06 19:42:27 mpi Exp $	*/
/*
 * Copyright (c) 1988 University of Utah.
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department and Ralph Campbell.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * from: Utah Hdr: vm_machdep.c 1.21 91/04/06
 *
 *	from: @@(#)vm_machdep.c	8.3 (Berkeley) 1/4/94
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/malloc.h>
#include <sys/buf.h>
#include <sys/vnode.h>
#include <sys/user.h>
#include <sys/exec.h>
#include <sys/signalvar.h>

#include <uvm/uvm_extern.h>

#include <machine/cpu.h>
#include <mips64/mips_cpu.h>

extern void proc_trampoline(void);
/*
 * Finish a fork operation, with process p2 nearly set up.
 */
void
cpu_fork(struct proc *p1, struct proc *p2, void *stack, void *tcb,
    void (*func)(void *), void *arg)
{
	struct cpu_info *ci = curcpu();
	struct pcb *pcb;
#if UPAGES == 1
	paddr_t pa;

	/* replace p_addr with a direct translation address */
	p2->p_md.md_uarea = (vaddr_t)p2->p_addr;
	pmap_extract(pmap_kernel(), p2->p_md.md_uarea, &pa);
#ifdef __sgi__
#ifndef CPU_R8000
	/*
	 * Return a CKSEG0 address whenever possible.
	 */
	if (pa < CKSEG_SIZE)
		p2->p_addr = (void *)PHYS_TO_CKSEG0(pa);
	else
#endif
		p2->p_addr = (void *)PHYS_TO_XKPHYS(pa, CCA_CACHED);
#else
	p2->p_addr = (void *)PHYS_TO_XKPHYS(pa, CCA_CACHED);
#endif
#endif
	pcb = &p2->p_addr->u_pcb;

	/*
	 * If we own the FPU, save its state before copying the PCB.
	 */
	if (p1 == ci->ci_fpuproc)
		save_fpu();

	p2->p_md.md_flags = p1->p_md.md_flags & MDP_FORKSAVE;
#ifdef FPUEMUL
	p2->p_md.md_fppgva = p1->p_md.md_fppgva;
	KASSERT((p2->p_md.md_flags & MDP_FPUSED) == 0);
#endif

	/* Copy pcb from p1 to p2 */
	if (p1 == curproc) {
		/* Sync the PCB before we copy it. */
		savectx(p1->p_addr, 0);
	}
#ifdef DIAGNOSTIC
	else if (p1 != &proc0)
		panic("cpu_fork: curproc");
#endif
	*pcb = p1->p_addr->u_pcb;
	p2->p_md.md_regs = &p2->p_addr->u_pcb.pcb_regs;

	/*
	 * If specified, give the child a different stack and/or TCB.
	 */
	if (stack != NULL)
		p2->p_md.md_regs->sp = (u_int64_t)stack;
	if (tcb != NULL)
		TCB_SET(p2, tcb);

	/*
	 * Copy the process control block to the new proc and
	 * create a clean stack for exit through trampoline.
	 * pcb_context has s0-s7, sp, s8, ra, sr, icr.
	 */
	if (p1 != curproc) {
#ifdef RM7000_ICR
		pcb->pcb_context.val[12] = (idle_mask << 8) & IC_INT_MASK;
#endif
		pcb->pcb_context.val[11] = (pcb->pcb_regs.sr & ~SR_INT_MASK) |
		    (idle_mask & SR_INT_MASK);
	}
	pcb->pcb_context.val[10] = (register_t)proc_trampoline;
	pcb->pcb_context.val[8] = (register_t)pcb +
	    USPACE - sizeof(struct trapframe);
	pcb->pcb_context.val[1] = (register_t)arg;
	pcb->pcb_context.val[0] = (register_t)func;
}

/*
 * cpu_exit is called as the last action during exit.
 */
void
cpu_exit(p)
	struct proc *p;
{
	struct cpu_info *ci = curcpu();

	if (ci->ci_fpuproc == p)
		ci->ci_fpuproc = NULL;

	pmap_deactivate(p);
#if UPAGES == 1
	/* restore p_addr for proper deallocation */
	p->p_addr = (void *)p->p_md.md_uarea;
#endif
	sched_exit(p);
}

extern vm_map_t phys_map;

/*
 * Map an user IO request into kernel virtual address space.
 */

void
vmapbuf(bp, len)
	struct buf *bp;
	vsize_t len;
{
	vaddr_t uva, kva;
	vsize_t sz, off;
	paddr_t pa;
	struct pmap *pmap;

	if ((bp->b_flags & B_PHYS) == 0) {
		panic("vmapbuf");
	}

	pmap = vm_map_pmap(&bp->b_proc->p_vmspace->vm_map);
	bp->b_saveaddr = bp->b_data;
	uva = trunc_page((vaddr_t)bp->b_saveaddr);
	off = (vaddr_t)bp->b_saveaddr - uva;
	sz = round_page(off + len);

	kva = uvm_km_valloc_prefer_wait(phys_map, sz, uva);
	bp->b_data = (caddr_t) (kva + off);

	while (sz > 0) {
		if (pmap_extract(pmap, uva, &pa) == FALSE)
			panic("vmapbuf: pmap_extract(%p, %lx) failed!",
			    pmap, uva);

		pmap_enter(vm_map_pmap(phys_map), kva, trunc_page(pa),
		    PROT_READ | PROT_WRITE,
		    PROT_READ | PROT_WRITE | PMAP_WIRED);
		uva += PAGE_SIZE;
		kva += PAGE_SIZE;
		sz -= PAGE_SIZE;
	}
	pmap_update(vm_map_pmap(phys_map));
}

/*
 * Free the io map PTEs associated with this IO operation.
 * We also invalidate the TLB entries and restore the original b_addr.
 */
void
vunmapbuf(bp, len)
	struct buf *bp;
	vsize_t len;
{
	vsize_t sz;
	vaddr_t addr;

	if ((bp->b_flags & B_PHYS) == 0) {
		panic("vunmapbuf");
	}
	addr = trunc_page((vaddr_t)bp->b_data);
	sz = round_page(len + ((vaddr_t)bp->b_data - addr));
	pmap_remove(vm_map_pmap(phys_map), addr, addr + sz);
	pmap_update(vm_map_pmap(phys_map));
	uvm_km_free_wakeup(phys_map, addr, sz);
	bp->b_data = bp->b_saveaddr;
	bp->b_saveaddr = NULL;
}
@


1.33
log
@Rename mips64's trap_frame into trapframe.

For coherency with other archs and in order to use it in MI code.

ok visa@@, tobiasu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.32 2015/05/05 02:13:47 guenther Exp $	*/
d64 2
a65 6
cpu_fork(p1, p2, stack, stacksize, func, arg)
	struct proc *p1, *p2;
	void *stack;
	size_t stacksize;
	void (*func)(void *);
	void *arg;
d116 1
a116 1
	 * If specified, give the child a different stack.
d119 3
a121 1
		p2->p_md.md_regs->sp = (u_int64_t)stack + stacksize;
@


1.32
log
@emul_native is only used for kernel threads which can't dump core, so
delete coredump_trad(), uvm_coredump(), cpu_coredump(), struct md_coredump,
and various #includes that are superfluous.

This leaves compat_linux processes without a coredump callback.  If that
ability is desired, someone should update it to use coredump_elf32() and
verify the results...

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.31 2014/12/16 18:30:03 tedu Exp $	*/
d139 1
a139 1
	    USPACE - sizeof(struct trap_frame);
@


1.31
log
@primary change: move uvm_vnode out of vnode, keeping only a pointer.
objective: vnode.h doesn't include uvm_extern.h anymore.
followup changes: include uvm_extern.h or lock.h where necessary.
ok and help from deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.30 2014/11/16 12:30:58 deraadt Exp $	*/
a50 1
#include <sys/core.h>
a161 49
}

/*
 * Dump the machine specific header information at the start of a core dump.
 */
int
cpu_coredump(p, vp, cred, chdr)
	struct proc *p;
	struct vnode *vp;
	struct ucred *cred;
	struct core *chdr;
{
	struct cpu_info *ci = curcpu();
	int error;
	/*register struct user *up = p->p_addr;*/
	struct coreseg cseg;

	CORE_SETMAGIC(*chdr, COREMAGIC, MID_MIPS, 0);
	chdr->c_hdrsize = ALIGN(sizeof(*chdr));
	chdr->c_seghdrsize = ALIGN(sizeof(cseg));
	chdr->c_cpusize = sizeof (p -> p_addr -> u_pcb.pcb_regs);

	/*
	 * Copy floating point state from the FP chip if this process
	 * has state stored there.
	 */
	if (p == ci->ci_fpuproc)
		save_fpu();

	CORE_SETMAGIC(cseg, CORESEGMAGIC, MID_MIPS, CORE_CPU);
	cseg.c_addr = 0;
	cseg.c_size = chdr->c_cpusize;

	error = vn_rdwr(UIO_WRITE, vp, (caddr_t)&cseg, chdr->c_seghdrsize,
	    (off_t)chdr->c_hdrsize, UIO_SYSSPACE,
	    IO_UNIT, cred, NULL, p);
	if (error)
		return error;

	error = vn_rdwr(UIO_WRITE, vp,
			(caddr_t)(&(p -> p_addr -> u_pcb.pcb_regs)),
			(off_t)chdr -> c_cpusize,
			(off_t)(chdr->c_hdrsize + chdr->c_seghdrsize),
			UIO_SYSSPACE, IO_UNIT, cred, NULL, p);

	if (!error)
		chdr->c_nseg++;

	return error;
@


1.30
log
@Replace a plethora of historical protection options with just
PROT_NONE, PROT_READ, PROT_WRITE, and PROT_EXEC from mman.h.
PROT_MASK is introduced as the one true way of extracting those bits.
Remove UVM_ADV_* wrapper, using the standard names.
ok doug guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.29 2014/05/10 22:25:16 jasper Exp $	*/
d55 1
@


1.29
log
@various format string fixes and remove -Wno-format from octeon

feedback/ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.28 2013/01/16 19:04:43 miod Exp $	*/
d248 2
a249 2
			VM_PROT_READ | VM_PROT_WRITE,
			VM_PROT_READ | VM_PROT_WRITE | PMAP_WIRED);
@


1.28
log
@cpu_coredump() also needs to invoke vn_rdwr() without IO_NODELOCKED; only
affects a.out binaries' core dumps.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.27 2012/10/03 11:18:23 miod Exp $	*/
d244 1
a244 1
			panic("vmapbuf: pmap_extract(%x, %x) failed!",
@


1.27
log
@Split ever-growing mips <machine/cpu.h> into what 99% of the kernel needs,
which will remain in <machine/cpu.h>, and a new mips_cpu.h containing only the
goriest md details, which are only of interest to a handful set of files; this
is similar in spirit to what alpha does, but here <machine/cpu.h> does not
include the new file.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.26 2012/09/29 21:37:03 miod Exp $	*/
d197 1
a197 1
	    IO_NODELOCKED|IO_UNIT, cred, NULL, p);
d205 1
a205 2
			UIO_SYSSPACE, IO_NODELOCKED|IO_UNIT,
			cred, NULL, p);
@


1.26
log
@Basic R8000 processor support. R8000 processors require MMU-specific code,
exception-specific code, clock-specific code, and L1 cache-specific code. L2
cache is per-design, of which only two exist: SGI Power Indigo2 (IP26) and SGI
Power Challenge (IP21) and are not covered by this commit.

R8000 processors also are 64-bit only processors with 64-bit coprocessor 0
registers, and lack so-called ``compatibility'' memory spaces allowing 32-bit
code to run with sign-extended addresses and registers.

The intrusive changes are covered by #ifdef CPU_R8000 stanzas. However,
trap() is split into a high-level wrapper and a new function, itsa(),
responsible for the actual trap servicing (which name couldn't be helped
because I'm an incorrigible punster). While an R8000 exception may cause
(via trap() ) multiple exceptions to be serviced, non-R8000 processors will
always service one exception in trap(), but they are nevertheless affected
by this code split.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.25 2012/03/19 21:56:49 miod Exp $	*/
d57 1
a57 1
#include <machine/autoconf.h>
@


1.25
log
@On sgi, use CKSEG0 addresses whenever possible for pmap_map_direct and u area
pages. This will allow R5000-based systems with physical memory fitting in
CKSEG0 to use 16KB pages and direct maps (since only XKPHYS accesses trigger
the XKPHYS coherency errata on these processors).
Tested on IP32, IP30 and IP27 (and loongson too as well).
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.24 2010/11/24 21:16:28 miod Exp $	*/
d80 1
d87 1
@


1.24
log
@Floating-point emulation code for systems lacking proper FPU (i.e. Octeon),
enabled by option FPUEMUL.

This is pretty straightforward, except for conditional branch on FPU condition
codes emulation (bc1f/bc1fl/bc1t/bc1tl instructions): unlike most
RISC-with-delay-slots designs (m88k, sparc), the branch pipeline is not exposed
to the kernel on Mips, therefore we can not resume a branch without losing the
delay slot instruction.

Some other operating systems work around this issue by emulating the delay
slot instruction, but this is error-prone (and requires the kernel code to
be aware of all supported instructions of the processor it is currently running
on), some use dedicated breakpoints to single-step through the delay slot and
then resume the branch as expected, but this causes a lot of copy-on-write
allocations.

This code chooses a third path, of copying the delay slot instructions to run toa special `magic' page, followed by a special trap instruction to give control
back to the kernel. This makes sure the instruction will actually be run by the
processor, and that no more than one page per process is wasted, regardless of
the number of branches to emulate.

Tested on octeon (big-endian) by syuu@@ and on loongson (little-endian) by me.
Note that enabling option FPUEMUL in the kernel will completely disable the
hardware FPU, if there is one; there is currently no way to build a kernel
supporting both hardware and software FPU, and there is no reason to change
this until there is a strong need to support both.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.23 2010/02/13 14:04:45 miod Exp $	*/
d79 9
d89 1
@


1.23
log
@Since we don't use the saved ipl in pcb anymore, remove it from the struct
layout.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.22 2010/01/08 01:35:52 syuu Exp $	*/
d90 4
@


1.22
log
@MP-safe FPU handling. ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.21 2009/12/07 19:01:06 miod Exp $	*/
d112 1
a112 1
	 * pcb_context has s0-s7, sp, s8, ra, sr, icr, ipl.
a113 1

a114 1
		pcb->pcb_context.val[13] = IPL_NONE;
d124 1
a125 1
	pcb->pcb_context.val[1] = (register_t)arg;
@


1.21
log
@If UPAGES would turn out to be 1, instead of using wired TLB entries to map
the u area after each context switch, simply convert it to an XKPHYS address,
so that access to it never faults. Idea from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.20 2009/10/22 22:08:54 miod Exp $	*/
d71 1
a74 2
#endif
	extern struct proc *machFPCurProcPtr;
a75 1
#if UPAGES == 1
d86 2
a87 6
	if (p1 == machFPCurProcPtr) {
		if (p1->p_addr->u_pcb.pcb_regs.sr & SR_FR_32)
			MipsSaveCurFPState(p1);
		else
			MipsSaveCurFPState16(p1);
	}
d137 1
a137 1
	extern struct proc *machFPCurProcPtr;
d139 2
a140 2
	if (machFPCurProcPtr == p)
		machFPCurProcPtr = (struct proc *)0;
d160 1
a163 1
	extern struct proc *machFPCurProcPtr;
d174 2
a175 6
	if (p == machFPCurProcPtr) {
		if (p->p_md.md_regs->sr & SR_FR_32)
			MipsSaveCurFPState(p);
		else
			MipsSaveCurFPState16(p);
	}
@


1.20
log
@Completely overhaul interrupt handling on sgi. Cpu state now only stores a
logical IPL level, and per-platform (IP27/IP30/IP32) code will from the
necessary hardware mask registers.

This allows the use of more than one interrupt mask register. Also, the
generic (platform independent) interrupt code shrinks a lot, and the actual
interrupt handler chains and masking information is now per-platform private
data.

Interrupt dispatching is generated from a template; more routines will be
added to the template to reduce platform-specific changes and share as much
code as possible.

Tested on IP27, IP30, IP32 and IP35.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.19 2009/10/22 18:46:48 miod Exp $	*/
d71 4
a74 1
	struct pcb *pcb = &p2->p_addr->u_pcb;
d77 8
d149 4
@


1.19
log
@Change the #define controlling use of RM7k/RM9k coprocessor 0 ICR to
RM7000_ICR, instead of IMASK_EXTERNAL, since they are actually different
concepts. This code remains disabled since RM7000_ICR is not defined anywhere
at the moment.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.18 2007/10/18 04:32:25 miod Exp $	*/
d107 1
a107 1
	 * pcb_context has s0-s7, sp, s8, ra, sr, icr, cpl.
d111 1
a111 1
		pcb->pcb_context.val[13] = 0;
@


1.18
log
@No need to include <machine/pte.h> here.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.17 2007/10/13 07:18:01 miod Exp $	*/
d112 1
d114 1
@


1.17
log
@Do not splhigh() before invoking sched_exit(), sched_exit() will do it better.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.16 2007/10/10 15:53:52 art Exp $	*/
a55 1
#include <machine/pte.h>
@


1.16
log
@Make context switching much more MI:
 - Move the functionality of choosing a process from cpu_switch into
   a much simpler function: cpu_switchto. Instead of having the locore
   code walk the run queues, let the MI code choose the process we
   want to run and only implement the context switching itself in MD
   code.
 - Let MD context switching run without worrying about spls or locks.
 - Instead of having the idle loop implemented with special contexts
   in MD code, implement one idle proc for each cpu. make the idle
   loop MI with MD hooks.
 - Change the proc lists from the old style vax queues to TAILQs.
 - Change the sleep queue from vax queues to TAILQs. This makes
   wakeup() go from O(n^2) to O(n)

there will be some MD fallout, but it will be fixed shortly.
There's also a few cleanups to be done after this.

deraadt@@, kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.15 2007/09/03 17:35:51 miod Exp $	*/
a125 1
 * release adress space and machine dependent resources.
a135 1
	(void)splhigh();
@


1.15
log
@call savectx() in cpu_fork(), so that the new process can take signals
correctly in child_return()'s userret(); makes the sys/kern/signal/earlysig
regression test pass. From a 2.5 years old diff I should have commited much
earlier.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.14 2007/07/16 20:20:08 miod Exp $	*/
d137 3
a139 3
	(void) splhigh();
	switch_exit(p);
	/* NOTREACHED */
@


1.14
log
@Change idle_mask to be made of the cop0 SR bits unshifted and the cop0 IC bits
shifted, instead of the other way around; this shaves a few instructions.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.13 2007/06/20 17:29:36 miod Exp $	*/
d72 1
a72 1
	struct pcb *pcb;
d75 3
a77 3
	p2->p_md.md_regs = &p2->p_addr->u_pcb.pcb_regs;
	p2->p_md.md_flags = p1->p_md.md_flags & MDP_FORKSAVE;

d79 1
a79 1
		if (p2->p_addr->u_pcb.pcb_regs.sr & SR_FR_32)
d85 14
a98 1
#ifdef notyet
d103 1
a103 2
		/* XXX How??? */;
#endif
d106 3
a108 3
	 *  Copy the process control block to the new proc and
	 *  create a clean stack for exit through trampoline.
	 *  pcb_context has s0-s7, sp, s8, ra, sr, icr, cpl.
a109 2
	pcb = &p2->p_addr->u_pcb;
	*pcb = p1->p_addr->u_pcb;
d111 6
a116 4
	pcb->pcb_context.val[13] = 0;
	pcb->pcb_context.val[12] = (idle_mask << 8) & IC_INT_MASK;
	pcb->pcb_context.val[11] = (pcb->pcb_regs.sr & ~SR_INT_MASK) |
	    (idle_mask & SR_INT_MASK);
d118 2
a119 1
	pcb->pcb_context.val[8] = (register_t)(caddr_t)pcb + USPACE - 64;
@


1.13
log
@In vunmapbuf(), explicitely remove mappings before invoking uvm_km_free().
Even if the latter would end up removing the mappings by itself, it would
do so using pmap_remove() because phys_map is not intrsafe; but some
platforms use pmap_kenter_pa() in vmapbuf(). By removing the mappings
ourselves, we can ensure the remove function used matches the enter function
which has been used.
Discussed and theoretical ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.12 2007/05/27 20:59:25 miod Exp $	*/
d101 2
a102 1
	pcb->pcb_context.val[12] = idle_mask & IC_INT_MASK;
d104 1
a104 1
	    ((idle_mask << 8) & SR_INT_MASK);
@


1.12
log
@pagemove() is no longer used.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.11 2007/05/09 19:21:49 miod Exp $	*/
d223 1
d243 2
@


1.11
log
@In cpu_fork(), enable all known interrupt sources in cop0 sr/ic, so that
kthreads start with interrupts enabled.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.10 2007/04/26 17:04:33 miod Exp $	*/
a181 31
/*
 * Move pages from one kernel virtual address to another.
 * Both addresses are assumed to reside in the Sysmap,
 * and size must be a multiple of CLSIZE.
 */
void
pagemove(from, to, size)
	caddr_t from, to;
	size_t size;
{
	pt_entry_t *fpte, *tpte;

	if (size % PAGE_SIZE)
		panic("pagemove");
	fpte = kvtopte(from);
	tpte = kvtopte(to);
	if (((vaddr_t)from & CpuCacheAliasMask) != ((vaddr_t)to & CpuCacheAliasMask)) {
		Mips_HitSyncDCache((vaddr_t)from, size);
	}
	while (size > 0) {
		tlb_flush_addr((vaddr_t)from);
		tlb_update((vaddr_t)to, fpte->pt_entry);
		*tpte++ = *fpte;
		fpte->pt_entry = PG_NV | PG_G;
		fpte++;
		size -= NBPG;
		from += NBPG;
		to += NBPG;
	}
}

a186 2

#define trunc_page_align(x) ((vaddr_t)(x) & ~(CpuCacheAliasMask | PAGE_SIZE))
@


1.10
log
@Be more careful when changing cop0 SR value; or flags in instead of setting
the SR value to them, and correctly propagate the SR to userland via proper
proc0 initialization and cpu_fork() care.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.9 2007/02/24 11:59:47 miod Exp $	*/
d101 3
a103 1
	pcb->pcb_context.val[11] = (register_t)pcb->pcb_regs.sr;
@


1.9
log
@Remove unused B_DIRTY, B_PAGET, B_PGIN, B_TAPE and B_UAREA b_flags values.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.8 2006/11/29 12:26:13 miod Exp $	*/
d101 1
@


1.8
log
@Remove cpu_swapin() and cpu_swapout(), they are no longer necessary (except
for cpu_swapin() on hppa* which is kept).
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.7 2005/01/31 21:35:50 grange Exp $	*/
d213 1
a213 15
 * Map an IO request into kernel virtual address space.  Requests fall into
 * one of five catagories:
 *
 *	B_PHYS|B_UAREA:	User u-area swap.
 *			Address is relative to start of u-area (p_addr).
 *	B_PHYS|B_PAGET:	User page table swap.
 *			Address is a kernel VA in usrpt (Usrptmap).
 *	B_PHYS|B_DIRTY:	Dirty page push.
 *			Address is a VA in proc2's address space.
 *	B_PHYS|B_PGIN:	Kernel pagein of user pages.
 *			Address is VA in user's address space.
 *	B_PHYS:		User "raw" IO request.
 *			Address is VA in user's address space.
 *
 * All requests are (re)mapped into kernel VA space via the phys_map
@


1.7
log
@Un-__P.

ok pefo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.6 2004/09/20 10:29:57 pefo Exp $	*/
a104 9
}

/*
 * Finish a swapin operation. Nothing to do.
 */
void
cpu_swapin(p)
	struct proc *p;
{
@


1.6
log
@Add support for R10K cpu class
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.5 2004/09/17 21:29:38 miod Exp $	*/
d60 1
a60 1
extern void proc_trampoline __P((void));
@


1.5
log
@In vmapbuf(), pass VM_PROT_READ | VM_PROT_WRITE as flags hints too.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.4 2004/09/17 19:28:05 miod Exp $	*/
d58 1
@


1.4
log
@Now that we can check for pmap_extract() failure properly, do so.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.3 2004/08/10 20:28:13 deraadt Exp $	*/
d269 2
a270 1
			VM_PROT_READ|VM_PROT_WRITE, PMAP_WIRED);
@


1.3
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.2 2004/08/10 20:15:47 deraadt Exp $	*/
d264 4
a267 4
		pmap_extract(pmap, uva, &pa);
		if (pa == 0) {
			panic("vmapbuf: null page frame");
		}
@


1.2
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.1 2004/08/06 20:56:03 pefo Exp $	*/
d203 1
a203 1
	if(((vaddr_t)from & CpuCacheAliasMask) != ((vaddr_t)to & CpuCacheAliasMask)) {
@


1.1
log
@initial mips64
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.4 1998/09/15 10:50:13 pefo Exp $	*/
d177 1
a177 1
	    		(off_t)(chdr->c_hdrsize + chdr->c_seghdrsize),
@

