head	1.63;
access;
symbols
	OPENBSD_6_1:1.63.0.2
	OPENBSD_6_1_BASE:1.63
	OPENBSD_6_0:1.59.0.4
	OPENBSD_6_0_BASE:1.59
	OPENBSD_5_9:1.59.0.2
	OPENBSD_5_9_BASE:1.59
	OPENBSD_5_8:1.58.0.4
	OPENBSD_5_8_BASE:1.58
	OPENBSD_5_7:1.57.0.2
	OPENBSD_5_7_BASE:1.57
	OPENBSD_5_6:1.55.0.4
	OPENBSD_5_6_BASE:1.55
	OPENBSD_5_5:1.52.0.4
	OPENBSD_5_5_BASE:1.52
	OPENBSD_5_4:1.50.0.2
	OPENBSD_5_4_BASE:1.50
	OPENBSD_5_3:1.49.0.2
	OPENBSD_5_3_BASE:1.49
	OPENBSD_5_2:1.45.0.2
	OPENBSD_5_2_BASE:1.45
	OPENBSD_5_1_BASE:1.39
	OPENBSD_5_1:1.39.0.4
	OPENBSD_5_0:1.39.0.2
	OPENBSD_5_0_BASE:1.39
	OPENBSD_4_9:1.36.0.2
	OPENBSD_4_9_BASE:1.36
	OPENBSD_4_8:1.31.0.2
	OPENBSD_4_8_BASE:1.31
	OPENBSD_4_7:1.27.0.2
	OPENBSD_4_7_BASE:1.27
	OPENBSD_4_6:1.12.0.4
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.11.0.6
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.4
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.2
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.10.0.2
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.9.0.10
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.8
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.6
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.4
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.2
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.7.0.2
	OPENBSD_3_6_BASE:1.7;
locks; strict;
comment	@ * @;


1.63
date	2016.12.17.11.51.02;	author visa;	state Exp;
branches;
next	1.62;
commitid	DpBtOVzHHvh4mGBa;

1.62
date	2016.10.27.13.19.27;	author visa;	state Exp;
branches;
next	1.61;
commitid	6Ve06RHpI01QGFsX;

1.61
date	2016.10.26.13.42.54;	author visa;	state Exp;
branches;
next	1.60;
commitid	khNYWeTCmYcllpHh;

1.60
date	2016.08.16.13.03.58;	author visa;	state Exp;
branches;
next	1.59;
commitid	6TiwRQZbesPVamIE;

1.59
date	2015.12.25.08.34.50;	author visa;	state Exp;
branches;
next	1.58;
commitid	mGLOAekfSVArdeBr;

1.58
date	2015.06.16.18.28.51;	author miod;	state Exp;
branches;
next	1.57;
commitid	DfyYtV0LqE3MlR1Z;

1.57
date	2015.02.11.05.25.15;	author miod;	state Exp;
branches;
next	1.56;
commitid	fUMRrm9lIBdX4Usg;

1.56
date	2014.09.30.06.51.58;	author jmatthew;	state Exp;
branches;
next	1.55;
commitid	pUEUpP9FlbomZUiI;

1.55
date	2014.06.18.20.03.55;	author miod;	state Exp;
branches;
next	1.54;
commitid	SELH2gUhcQMcsgiG;

1.54
date	2014.03.29.23.59.49;	author miod;	state Exp;
branches;
next	1.53;

1.53
date	2014.03.09.10.12.17;	author miod;	state Exp;
branches;
next	1.52;

1.52
date	2014.01.19.12.45.35;	author deraadt;	state Exp;
branches;
next	1.51;

1.51
date	2013.12.19.09.37.14;	author jasper;	state Exp;
branches;
next	1.50;

1.50
date	2013.05.09.19.45.19;	author miod;	state Exp;
branches;
next	1.49;

1.49
date	2012.10.03.11.18.23;	author miod;	state Exp;
branches;
next	1.48;

1.48
date	2012.09.29.21.37.03;	author miod;	state Exp;
branches;
next	1.47;

1.47
date	2012.09.29.19.25.28;	author miod;	state Exp;
branches;
next	1.46;

1.46
date	2012.09.29.19.24.31;	author miod;	state Exp;
branches;
next	1.45;

1.45
date	2012.07.09.09.07.29;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2012.06.24.16.26.04;	author miod;	state Exp;
branches;
next	1.43;

1.43
date	2012.06.17.12.34.35;	author miod;	state Exp;
branches;
next	1.42;

1.42
date	2012.04.10.15.59.21;	author miod;	state Exp;
branches;
next	1.41;

1.41
date	2012.04.06.20.11.18;	author miod;	state Exp;
branches;
next	1.40;

1.40
date	2012.03.28.20.44.23;	author miod;	state Exp;
branches;
next	1.39;

1.39
date	2011.04.10.17.16.51;	author miod;	state Exp;
branches;
next	1.38;

1.38
date	2011.04.07.15.30.15;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2011.03.31.20.37.44;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2010.11.24.21.16.28;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2010.09.13.21.59.07;	author syuu;	state Exp;
branches;
next	1.34;

1.34
date	2010.09.09.10.59.01;	author syuu;	state Exp;
branches;
next	1.33;

1.33
date	2010.09.09.10.55.52;	author syuu;	state Exp;
branches;
next	1.32;

1.32
date	2010.08.30.08.52.10;	author syuu;	state Exp;
branches;
next	1.31;

1.31
date	2010.08.07.03.50.01;	author krw;	state Exp;
branches;
next	1.30;

1.30
date	2010.06.26.23.24.43;	author guenther;	state Exp;
branches;
next	1.29;

1.29
date	2010.04.28.16.20.28;	author syuu;	state Exp;
branches;
next	1.28;

1.28
date	2010.03.28.17.09.36;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2010.02.28.18.01.39;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2010.02.02.01.29.56;	author syuu;	state Exp;
branches;
next	1.25;

1.25
date	2010.01.09.23.34.29;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2010.01.09.20.33.16;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2010.01.08.01.35.52;	author syuu;	state Exp;
branches;
next	1.22;

1.22
date	2009.12.28.06.55.27;	author syuu;	state Exp;
branches;
next	1.21;

1.21
date	2009.12.02.01.42.14;	author syuu;	state Exp;
branches;
next	1.20;

1.20
date	2009.11.26.14.14.08;	author syuu;	state Exp;
branches;
next	1.19;

1.19
date	2009.11.25.17.39.51;	author syuu;	state Exp;
branches;
next	1.18;

1.18
date	2009.11.24.22.46.59;	author syuu;	state Exp;
branches;
next	1.17;

1.17
date	2009.11.22.19.41.41;	author syuu;	state Exp;
branches;
next	1.16;

1.16
date	2009.10.30.08.13.57;	author syuu;	state Exp;
branches;
next	1.15;

1.15
date	2009.10.26.20.14.40;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2009.09.15.04.54.31;	author syuu;	state Exp;
branches;
next	1.13;

1.13
date	2009.08.06.21.11.39;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2009.06.17.18.18.21;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2007.10.18.04.32.25;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2007.05.07.18.42.13;	author kettenis;	state Exp;
branches;
next	1.9;

1.9
date	2004.09.21.05.51.15;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2004.09.20.10.29.57;	author pefo;	state Exp;
branches;
next	1.7;

1.7
date	2004.09.09.22.11.38;	author pefo;	state Exp;
branches;
next	1.6;

1.6
date	2004.08.11.15.13.58;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2004.08.10.20.28.13;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2004.08.10.20.15.47;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.09.21.00.54;	author pefo;	state Exp;
branches;
next	1.2;

1.2
date	2004.08.09.14.57.26;	author pefo;	state Exp;
branches;
next	1.1;

1.1
date	2004.08.06.20.56.03;	author pefo;	state Exp;
branches;
next	;


desc
@@


1.63
log
@Make Octeon model strings a bit more specific. While there,
add CN70xx/CN71xx.
@
text
@/*	$OpenBSD: cpu.c,v 1.62 2016/10/27 13:19:27 visa Exp $ */

/*
 * Copyright (c) 1997-2004 Opsycon AB (www.opsycon.se)
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/atomic.h>
#include <sys/device.h>
#include <sys/malloc.h>
#include <dev/rndvar.h>

#include <uvm/uvm_extern.h>

#include <machine/cpu.h>
#include <mips64/mips_cpu.h>
#include <machine/autoconf.h>

int	cpumatch(struct device *, void *, void *);
void	cpuattach(struct device *, struct device *, void *);

struct cpu_info cpu_info_primary;
struct cpu_info *cpu_info_list = &cpu_info_primary;
struct cpu_info *cpu_info_secondaries;
#ifdef MULTIPROCESSOR
struct cpuset cpus_running;
#endif

vaddr_t	cache_valias_mask;

struct cfattach cpu_ca = {
	sizeof(struct device), cpumatch, cpuattach
};
struct cfdriver cpu_cd = {
	NULL, "cpu", DV_DULL,
};

int
cpumatch(struct device *parent, void *match, void *aux)
{
	struct cpu_attach_args *caa = aux;

	/* make sure that we're looking for a CPU. */
	if (strcmp(caa->caa_maa.maa_name, cpu_cd.cd_name) != 0)
		return 0;

	return 20;	/* Make CPU probe first */
}

void
cpuattach(struct device *parent, struct device *dev, void *aux)
{
	struct cpu_attach_args *caa = aux;
	struct cpu_hwinfo *ch = caa->caa_hw;
	struct cpu_info *ci;
	int cpuno = dev->dv_unit;
	int isr16k = 0;
	int fptype, vers_maj, vers_min;
	int displayver;

	if (cpuno == 0) {
		ci = &cpu_info_primary;
#ifdef MULTIPROCESSOR
		ci->ci_flags |= CPUF_RUNNING | CPUF_PRESENT | CPUF_PRIMARY;
		cpuset_add(&cpus_running, ci);
		if (ncpusfound > 1) {
			cpu_info_secondaries = (struct cpu_info *)
			    alloc_contiguous_pages(sizeof(struct cpu_info) *
			      (ncpusfound - 1));
			if (cpu_info_secondaries == NULL)
				panic("unable to allocate cpu_info");
		}
#endif
	}
#ifdef MULTIPROCESSOR
	else {
		ci = &cpu_info_secondaries[cpuno - 1];
		ci->ci_next = cpu_info_list->ci_next;
		cpu_info_list->ci_next = ci;
		ci->ci_flags |= CPUF_PRESENT;
	}
#endif
	ci->ci_self = ci;
	ci->ci_cpuid = cpuno;
	ci->ci_dev = dev;
	bcopy(ch, &ci->ci_hw, sizeof(struct cpu_hwinfo));
#ifdef MULTIPROCESSOR
	/*
	 * When attaching secondary processors, cache information is not
	 * available yet.  Copy the cache information from the primary cpu
	 * instead.
	 * XXX The MP boot sequence needs to be reworked to avoid this.
	 */
	if (!ISSET(ci->ci_flags, CPUF_PRIMARY)) {
		ci->ci_l1inst = cpu_info_primary.ci_l1inst;
		ci->ci_l1data = cpu_info_primary.ci_l1data;
		ci->ci_l2 = cpu_info_primary.ci_l2;
		ci->ci_l3 = cpu_info_primary.ci_l3;
	}
#endif

#ifdef TGT_ORIGIN
	ci->ci_nasid = caa->caa_maa.maa_nasid;
	ci->ci_slice = caa->caa_maa.maa_physid;
#endif

	printf(": ");

	displayver = 1;
	fptype = (ch->c1prid >> 8) & 0xff;
	vers_maj = (ch->c0prid >> 4) & 0x0f;
	vers_min = ch->c0prid & 0x0f;
	switch (ch->type) {
	case MIPS_R4000:
		if (vers_maj < 4)
			printf("MIPS R4000 CPU");
		else {
			vers_maj -= 3;
			printf("MIPS R4400 CPU");
		}
		fptype = MIPS_R4000;
		break;
#if 0
	case MIPS_R4100:
		printf("NEC VR41xx CPU");
		break;
	case MIPS_R4200:
		printf("NEC VR4200 CPU (ICE)");
		break;
	case MIPS_R4300:
		printf("NEC VR4300 CPU");
		break;
#endif
	case MIPS_R4600:
		printf("QED R4600 Orion CPU");
		break;
#if 0
	case MIPS_R4700:
		printf("QED R4700 Orion CPU");
		break;
#endif
	case MIPS_R5000:
		printf("MIPS R5000 CPU");
		break;
	case MIPS_RM52X0:
		printf("PMC-Sierra RM52X0 CPU");
		break;
	case MIPS_RM7000:
		if (vers_maj < 2)
			printf("PMC-Sierra RM7000 CPU");
		else
			printf("PMC-Sierra RM7000A CPU");
		break;
	case MIPS_R8000:
		printf("MIPS R8000 CPU");
		break;
	case MIPS_RM9000:
		printf("PMC-Sierra RM9000 CPU");
		break;
	case MIPS_R10000:
		printf("MIPS R10000 CPU");
		break;
	case MIPS_R12000:
		printf("MIPS R12000 CPU");
		break;
	case MIPS_R14000:
		if (vers_maj > 2) {
			vers_maj -= 2;
			isr16k = 1;
		}
		printf("R1%d000 CPU", isr16k ? 6 : 4);
		break;
	case MIPS_LOONGSON2:
		switch (ch->c0prid & 0xff) {
		case 0x00:
		case 0x02:
		case 0x03:
			printf("STC Loongson2%c CPU", 'C' + vers_min);
			break;
		case 0x05:
			printf("STC Loongson3%c CPU", 'A' + vers_min - 5);
			break;
		default:
			printf("Unknown STC Loongson CPU type (%02x)",
			    ch->c0prid & 0xff);
			break;
		}
		displayver = 0;
		break;
	case MIPS_CN50XX:
		printf("CN50xx CPU");
		fptype = MIPS_SOFT;
		break;
	case MIPS_CN61XX:
		if (ci->ci_l2.size < 1024 * 1024)
			printf("CN60xx CPU");
		else
			printf("CN61xx CPU");
		fptype = MIPS_SOFT;
		break;
	case MIPS_CN71XX:
		printf("CN70xx/CN71xx CPU");
		break;
	default:
		printf("Unknown CPU type (0x%x)", ch->type);
		break;
	}
	if (displayver != 0)
		printf(" rev %d.%d", vers_maj, vers_min);
	printf(" %d MHz, ", ch->clock / 1000000);

	displayver = 1;
	vers_maj = (ch->c1prid >> 4) & 0x0f;
	vers_min = ch->c1prid & 0x0f;
	switch (fptype) {
	case MIPS_SOFT:
#ifdef FPUEMUL
		printf("Software FP emulation");
#else
		printf("no FPU");
#endif
		displayver = 0;
		break;
	case MIPS_R4000:
		printf("R4010 FPC");
		break;
#if 0
	case MIPS_R4200:
		printf("VR4200 FPC (ICE)");
		break;
#endif
	case MIPS_R4600:
		printf("R4600 Orion FPC");
		break;
#if 0
	case MIPS_R4700:
		printf("R4700 Orion FPC");
		break;
#endif
	case MIPS_R5000:
		printf("R5000 based FPC");
		break;
	case MIPS_RM52X0:
		printf("RM52X0 FPC");
		break;
	case MIPS_RM7000:
		printf("RM7000 FPC");
		break;
	case MIPS_R8000:
		printf("R8010 FPU");
		break;
	case MIPS_RM9000:
		printf("RM9000 FPC");
		break;
	case MIPS_R10000:
		printf("R10000 FPU");
		break;
	case MIPS_R12000:
		printf("R12000 FPU");
		break;
	case MIPS_R14000:
		if (isr16k) {
			if (ch->c0prid == ch->c1prid)
				vers_maj -= 2;
			printf("R16000 FPU");
		} else
			printf("R14000 FPU");
		break;
	case MIPS_LOONGSON2:
		switch (ch->c1prid & 0xff) {
		case 0x00:
		case 0x02:
		case 0x03:
			printf("STC Loongson2%c FPU", 'C' + vers_min);
			break;
		case 0x05:
			printf("STC Loongson3%c FPU", 'A' + vers_min - 5);
			break;
		default:
			printf("Unknown STC Loongson FPU type (%02x)",
			    ch->c1prid & 0xff);
			break;
		}
		displayver = 0;
		break;
	case MIPS_CN71XX:
		printf("CN70xx/CN71xx FPU");
		break;
	default:
		printf("Unknown FPU type (0x%x)", fptype);
		break;
	}
	if (displayver != 0)
		printf(" rev %d.%d", vers_maj, vers_min);
	printf("\n");

	if (ci->ci_l1inst.sets == ci->ci_l1data.sets) {
		printf("cpu%d: cache L1-I %dKB D %dKB ", cpuno,
		    ci->ci_l1inst.size / 1024, ci->ci_l1data.size / 1024);
		if (ci->ci_l1inst.sets == 1)
			printf("direct");
		else
			printf("%d way", ci->ci_l1inst.sets);
	} else {
		printf("cpu%d: cache L1-I %dKB ", cpuno,
		    ci->ci_l1inst.size / 1024);
		if (ci->ci_l1inst.sets == 1)
			printf("direct");
		else
			printf("%d way", ci->ci_l1inst.sets);
		printf(" D %dKB ", ci->ci_l1data.size / 1024);
		if (ci->ci_l1data.sets == 1)
			printf("direct");
		else
			printf("%d way", ci->ci_l1data.sets);
	}

	if (ci->ci_l2.size != 0) {
		printf(", L2 %dKB ", ci->ci_l2.size / 1024);
		if (ci->ci_l2.sets == 1)
			printf("direct");
		else
			printf("%d way", ci->ci_l2.sets);
	}
	if (ci->ci_l3.size != 0) {
		printf(", L3 %dKB ", ci->ci_l3.size / 1024);
		if (ci->ci_l3.sets == 1)
			printf("direct");
		else
			printf("%d way", ci->ci_l3.sets);
	}
	printf("\n");

#ifdef DEBUG
	printf("cpu%d: L1 set size %d:%d\n", cpuno,
	    ci->ci_l1inst.setsize, ci->ci_l1data.setsize);
	printf("cpu%d: L1 line size %d:%d\n", cpuno,
	    ci->ci_l1inst.linesize, ci->ci_l1data.linesize);
	printf("cpu%d: L2 line size %d\n", cpuno, ci->ci_l2.linesize);
	printf("cpu%d: cache configuration %x\n",
	    cpuno, ci->ci_cacheconfiguration);
	printf("cpu%d: virtual alias mask 0x%lx\n", cpuno, cache_valias_mask);
	printf("cpu%d: config register %016lx, status register %016lx\n",
	    cpuno, cp0_get_config(), getsr());
#endif
}

void
cpu_switchto(struct proc *oldproc, struct proc *newproc)
{
#ifdef MULTIPROCESSOR
	struct cpu_info *ci = curcpu();
	if (ci->ci_fpuproc)
		save_fpu();
#endif

	cpu_switchto_asm(oldproc, newproc);
}

void
enable_fpu(struct proc *p)
{
#ifndef FPUEMUL
	struct cpu_info *ci = curcpu();

	if (p->p_md.md_regs->sr & SR_FR_32)
		MipsSwitchFPState(ci->ci_fpuproc, p->p_md.md_regs);
	else
		MipsSwitchFPState16(ci->ci_fpuproc, p->p_md.md_regs);
	atomic_inc_int(&uvmexp.fpswtch);

	ci->ci_fpuproc = p;
	p->p_md.md_regs->sr |= SR_COP_1_BIT;
	p->p_md.md_flags |= MDP_FPUSED;
#endif
}

void
save_fpu(void)
{
#ifndef FPUEMUL
	struct cpu_info *ci = curcpu();
	struct proc *p;

	KASSERT(ci->ci_fpuproc);
	p = ci->ci_fpuproc;
	if (p->p_md.md_regs->sr & SR_FR_32)
		MipsSaveCurFPState(p);
	else
		MipsSaveCurFPState16(p);
#endif
}

#ifdef MULTIPROCESSOR
struct cpu_info *
get_cpu_info(int cpuno)
{
	struct cpu_info *ci;
	CPU_INFO_ITERATOR cii;

	CPU_INFO_FOREACH(cii, ci) {
		if (ci->ci_cpuid == cpuno)
			return ci;
	}
	return NULL;
}

void
cpu_boot_secondary_processors(void)
{
	struct cpu_info *ci;
	CPU_INFO_ITERATOR cii;

	CPU_INFO_FOREACH(cii, ci) {
		if ((ci->ci_flags & CPUF_PRESENT) == 0)
			continue;
		if (ci->ci_flags & CPUF_PRIMARY)
			continue;

		ci->ci_randseed = (arc4random() & 0x7fffffff) + 1;
		sched_init_cpu(ci);
		cpu_boot_secondary(ci);
	}

       /* This must called after xheart0 has initialized, so here is 
	* the best place to do so.
	*/
       mips64_ipi_init();
}

void
cpu_unidle(struct cpu_info *ci)
{
	if (ci != curcpu())
		mips64_send_ipi(ci->ci_cpuid, MIPS64_IPI_NOP);
}

vaddr_t 
alloc_contiguous_pages(size_t size)
{
	struct pglist mlist;
	struct vm_page *m;
	int error;
	paddr_t pa;

	TAILQ_INIT(&mlist);
	error = uvm_pglistalloc(round_page(size), 0, (paddr_t)-1, 0, 0,
		&mlist, 1, UVM_PLA_NOWAIT | UVM_PLA_ZERO);
	if (error)
		return 0;
	m = TAILQ_FIRST(&mlist);
	pa = VM_PAGE_TO_PHYS(m);

	return PHYS_TO_XKPHYS(pa, CCA_CACHED);
}
#endif
@


1.62
log
@Revert previous `ncpus' change because the percpu code now works
without it.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.61 2016/10/26 13:42:54 visa Exp $ */
d214 2
a215 2
	case MIPS_OCTEON:
		printf("Cavium OCTEON CPU");
d218 5
a222 2
	case MIPS_OCTEON2:
		printf("Cavium OCTEON II CPU");
d225 3
d309 3
@


1.61
log
@Increment `ncpus' to its final value already during autoconfiguration so
that percpu data areas get allocated properly on mips64 platforms. It is
too late to set the value during launch of secondary CPUs.

ok jasper@@ kettenis@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.60 2016/08/16 13:03:58 visa Exp $ */
a104 1
		ncpus++;
@


1.60
log
@Remove RM7000/RM9000-specific performance counter code. It originates
from PMON2000 and has not been enabled on OpenBSD.

Suggested by and ok miod@@ (after seeing a quad_t cleanup patch of mine)
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.59 2015/12/25 08:34:50 visa Exp $ */
d105 1
@


1.59
log
@Make interrupt masking MP-aware. Linux IP27 and IP35 ports served as a
substitute for hardware documentation.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.58 2015/06/16 18:28:51 miod Exp $ */
a53 1
int	cpu_is_rm7k = 0;
a176 1
		cpu_is_rm7k++;
@


1.58
log
@alloc_contiguous_pages() is supposed to round the allocation size to a page
boundary, not to an u area boundary. Oops.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.57 2015/02/11 05:25:15 miod Exp $ */
d125 5
@


1.57
log
@Explicitely include <sys/atomic.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.56 2014/09/30 06:51:58 jmatthew Exp $ */
d459 1
a459 1
	error = uvm_pglistalloc(roundup(size, USPACE), 0, (paddr_t)-1, 0, 0,
@


1.56
log
@implement atomic operations using ll/sc, and convert rw_cas and callers of the
pre-existing atomics to match.

tested on sgi (octane) and octeon (erl)
ok miod@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.55 2014/06/18 20:03:55 miod Exp $ */
d32 1
@


1.55
log
@fix format string if DEBUG
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.54 2014/03/29 23:59:49 miod Exp $ */
d381 1
a381 1
	atomic_add_int(&uvmexp.fpswtch, 1);
@


1.54
log
@Update the loongson codebase to recognize the so-called `EFI-like' interface
supposedly provided by newer PMON firmware (on Loongson 2Gq and Loongson 3A
systems).
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.53 2014/03/09 10:12:17 miod Exp $ */
d353 2
a354 2
	printf("cpu%d: virtual alias mask %p\n", cpuno, cache_valias_mask);
	printf("cpu%d: config register %016x, status register %016x\n",
@


1.53
log
@Rework the per-cpu cache information. Use a common struct to store the line
size, the number of sets, and the total size (and the set size, for convenience)
per cache (I$, D$, L2, L3).
This allows cpu.c to print the number of ways (sets) of L2 and L3 caches from
the cache information, rather than hardcoding this from the processor type.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.52 2014/01/19 12:45:35 deraadt Exp $ */
d284 14
a297 1
		printf("STC Loongson2%c FPU", 'C' + vers_min);
@


1.52
log
@Initialize ci_randseed better using arc4random() + a trick.  Remove the
libkern srandom() API since it is not suitable for this use.
ok kettenis miod
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.51 2013/12/19 09:37:14 jasper Exp $ */
d112 12
a123 2
	if (!ISSET(ci->ci_flags, CPUF_PRIMARY))
		hw_cpu_init_secondary(ci);
d295 20
a314 2
	printf("cpu%d: cache L1-I %dKB D %dKB ", cpuno,
	    ci->ci_l1instcachesize / 1024, ci->ci_l1datacachesize / 1024);
d316 6
a321 10
	switch (ci->ci_cacheways) {
	case 2:
		printf("2 way");
		break;
	case 4:
		printf("4 way");
		break;
	default:
		printf("direct");
		break;
d323 6
a328 18

	if (ci->ci_l2size != 0) {
		switch (ch->type) {
		case MIPS_R10000:
		case MIPS_R12000:
		case MIPS_R14000:
			printf(", L2 %dKB 2 way", ci->ci_l2size / 1024);
			break;
		case MIPS_RM7000:
		case MIPS_R8000:
		case MIPS_RM9000:
		case MIPS_LOONGSON2:
			printf(", L2 %dKB 4 way", ci->ci_l2size / 1024);
			break;
		default:
			printf(", L2 %dKB direct", ci->ci_l2size / 1024);
			break;
		}
a329 2
	if (ci->ci_l3size != 0)
		printf(", L3 %dKB direct", ci->ci_l3size / 1024);
d334 1
a334 1
	    ci->ci_l1instcacheset, ci->ci_l1datacacheset);
d336 2
a337 2
	    ci->ci_l1instcacheline, ci->ci_l1datacacheline);
	printf("cpu%d: L2 line size %d\n", cpuno, ci->ci_l2line);
@


1.51
log
@recognize octeon 2 cpus; as found in the lanner mr326

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.50 2013/05/09 19:45:19 miod Exp $ */
d34 1
d408 1
a408 1
		ci->ci_randseed = random();
@


1.50
log
@Do not panic when running the MP kernel on a single-processor system; found
the hard way by tobiasu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.49 2012/10/03 11:18:23 miod Exp $ */
d201 4
@


1.49
log
@Split ever-growing mips <machine/cpu.h> into what 99% of the kernel needs,
which will remain in <machine/cpu.h>, and a new mips_cpu.h containing only the
goriest md details, which are only of interest to a handful set of files; this
is similar in spirit to what alpha does, but here <machine/cpu.h> does not
include the new file.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.48 2012/09/29 21:37:03 miod Exp $ */
d89 7
a95 5
		cpu_info_secondaries = (struct cpu_info *)
		    alloc_contiguous_pages(sizeof(struct cpu_info) *
		      (ncpusfound - 1));
		if (cpu_info_secondaries == NULL)
			panic("unable to allocate cpu_info");
@


1.48
log
@Basic R8000 processor support. R8000 processors require MMU-specific code,
exception-specific code, clock-specific code, and L1 cache-specific code. L2
cache is per-design, of which only two exist: SGI Power Indigo2 (IP26) and SGI
Power Challenge (IP21) and are not covered by this commit.

R8000 processors also are 64-bit only processors with 64-bit coprocessor 0
registers, and lack so-called ``compatibility'' memory spaces allowing 32-bit
code to run with sign-extended addresses and registers.

The intrusive changes are covered by #ifdef CPU_R8000 stanzas. However,
trap() is split into a high-level wrapper and a new function, itsa(),
responsible for the actual trap servicing (which name couldn't be helped
because I'm an incorrigible punster). While an R8000 exception may cause
(via trap() ) multiple exceptions to be serviced, non-R8000 processors will
always service one exception in trap(), but they are nevertheless affected
by this code split.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.47 2012/09/29 19:25:28 miod Exp $ */
d38 1
@


1.47
log
@Sort cpu and fpu list, and don't bother printing those we don't run on (yet).
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.46 2012/09/29 19:24:31 miod Exp $ */
d160 3
d245 3
d300 1
@


1.46
log
@Handle the coprocessor 0 cause and status registers as a 64 bit value now,
as some odd mips designs need moro than 32 bits in there. This causes a lot
of mechanical changes everywhere getsr() is used.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.45 2012/07/09 09:07:29 deraadt Exp $ */
d128 3
a130 15
	case MIPS_R5000:
		printf("MIPS R5000 CPU");
		break;
	case MIPS_R10000:
		printf("MIPS R10000 CPU");
		break;
	case MIPS_R12000:
		printf("MIPS R12000 CPU");
		break;
	case MIPS_R14000:
		if (vers_maj > 2) {
			vers_maj -= 2;
			isr16k = 1;
		}
		printf("R1%d000 CPU", isr16k ? 6 : 4);
d138 1
a138 3
	case MIPS_R4100:
		printf("NEC VR41xx CPU");
		break;
d142 1
d146 4
d163 13
d210 1
d212 3
d220 1
a220 14
	case MIPS_R10000:
		printf("R10000 FPU");
		break;
	case MIPS_R12000:
		printf("R12000 FPU");
		break;
	case MIPS_R14000:
		if (isr16k) {
			if (ch->c0prid == ch->c1prid)
				vers_maj -= 2;
			printf("R16000 FPU");
		} else
			printf("R14000 FPU");
		break;
d224 1
d228 1
d232 1
d244 14
@


1.45
log
@Do not re-initialize ci_randseed on the primary cpu
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.44 2012/06/24 16:26:04 miod Exp $ */
d304 1
a304 1
	printf("cpu%d: config register %08x, status register %08x\n",
@


1.44
log
@Add cache operation functions pointers to struct cpu_info; the various
cache lines and sizes are already there, after all.

The ConfigCache cache routine is responsible for filling these function
pointers; cache routine invocation macros are updated to use the cpu_info
fields, but may still be overriden in <machine/cpu.h> on platforms where
only one set of cache routines is used.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.43 2012/06/17 12:34:35 miod Exp $ */
d372 1
a372 1
       struct cpu_info *ci;
d376 8
a383 8
               if ((ci->ci_flags & CPUF_PRESENT) == 0)
                       continue;
               if (ci->ci_flags & CPUF_PRIMARY)
                       continue;

               sched_init_cpu(ci);
               ci->ci_randseed = random();
               cpu_boot_secondary(ci);
@


1.43
log
@No longer restrict alloc_contiguous_pages() to memory in the low 4GB.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.42 2012/04/10 15:59:21 miod Exp $ */
d300 1
a300 2
	printf("cpu%d: virtual alias mask %p\n", cpuno, cache_valias_mask);
	printf("cpu%d: config register %08x\n", cpuno, cp0_get_config());
d303 3
a305 25
	if (ch->type == MIPS_RM7000) {
		uint32_t tmp = cp0_get_config();

		printf("cpu%d: ", cpuno);
		printf("K0 = %1d  ", 0x7 & tmp);
		printf("SE = %1d  ", 0x1 & (tmp>>3));
		printf("DB = %1d  ", 0x1 & (tmp>>4));
		printf("IB = %1d\n", 0x1 & (tmp>>5));
		printf("cpu%d: ", cpuno);
		printf("DC = %1d  ", 0x7 & (tmp>>6));
		printf("IC = %1d  ", 0x7 & (tmp>>9));
		printf("TE = %1d  ", 0x1 & (tmp>>12));
		printf("EB = %1d\n", 0x1 & (tmp>>13));
		printf("cpu%d: ", cpuno);
		printf("EM = %1d  ", 0x1 & (tmp>>14));
		printf("BE = %1d  ", 0x1 & (tmp>>15));
		printf("TC = %1d  ", 0x1 & (tmp>>17));
		printf("EW = %1d\n", 0x3 & (tmp>>18));
		printf("cpu%d: ", cpuno);
		printf("TS = %1d  ", 0x3 & (tmp>>20));
		printf("EP = %1d  ", 0xf & (tmp>>24));
		printf("EC = %1d  ", 0x7 & (tmp>>28));
		printf("SC = %1d\n", 0x1 & (tmp>>31));
	}
	printf("cpu%d: Status Register %08x\n", cpuno, getsr());
a307 6

extern void cpu_switchto_asm(struct proc *, struct proc *);
extern void MipsSaveCurFPState(struct proc *);
extern void MipsSaveCurFPState16(struct proc *);
extern void MipsSwitchFPState(struct proc *, struct trap_frame *);
extern void MipsSwitchFPState16(struct proc *, struct trap_frame *);
@


1.42
log
@Count traps and fpu context switches.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.41 2012/04/06 20:11:18 miod Exp $ */
d88 3
a90 2
		cpu_info_secondaries = (struct cpu_info *)alloc_contiguous_pages(
			sizeof(struct cpu_info) * ncpusfound - 1);
d437 1
a437 1
	error = uvm_pglistalloc(roundup(size, USPACE), 0, 0xffffffff, 0, 0,
@


1.41
log
@Make the logic for PMAP_PREFER() and the logic, inside pmap, to do the
necessary cache coherency work wrt similar virtual indexes of different
physical pages, depending upon two distinct global variables, instead of
a shared one. R4000/R4400 VCE requires a 32KB mask for PMAP_PREFER, which
is otherwise not necessary for pmap coherency (especially since, on these
processors, only L1 uses virtual indexes, and the L1 size is not greater
than the page size, as we are using 16KB pages).
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.40 2012/03/28 20:44:23 miod Exp $ */
d359 1
@


1.40
log
@Work in progress support for the SGI Indigo, Indigo 2 and Indy systems
(IP20, IP22, IP24) in 64-bit mode, adapated from NetBSD. Currently limited
to headless operation, input and video drivers will get ported soon.

Should work on all R4000, R4440 and R5000 based systems. L2 cache on R5000SC
Indy not supported yet (coming soon), R4600 not supported yet either (coming
soon as well).

Tested to boot multiuser on: Indigo2 R4000SC, Indy R4000PC, Indy R4000SC,
Indy R5000SC, Indigo2 R4400SC. There are still glitches in the Ethernet driver
which are being looked at.

Expansion support is limited to the GIO E++ board; GIO boards with PCI-GIO
bridges not ported yet due to the lack of hardware, and this kind of driver
does not port blindly.

Most of this work comes from NetBSD, polishing and integration work, as well
as putting as many ``R4x00 in 64-bit mode'' erratas as necessary, by yours
truly.

More work is coming, as well as trying to get some easy way to boot install
kernels (as older PROM can only boot ECOFF binaries, which won't do for the
kernel).
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.39 2011/04/10 17:16:51 miod Exp $ */
d50 2
a51 3
vaddr_t	CpuCacheAliasMask;

int cpu_is_rm7k = 0;
d299 3
a301 3
	printf("cpu%d: Alias mask %p\n", cpuno, CpuCacheAliasMask);
	printf("cpu%d: Config Register %08x\n", cpuno, cp0_get_config());
	printf("cpu%d: Cache configuration %x\n",
@


1.39
log
@A last few NULL -> 0 corrections.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.38 2011/04/07 15:30:15 miod Exp $ */
d115 1
d120 4
a123 1
		if (ci->ci_l1instcachesize == 16384)
d125 2
a126 2
		else
			printf("MIPS R4000 CPU");
d191 1
d202 2
a203 7
	if (ch->type == MIPS_OCTEON)
		fptype = MIPS_SOFT;
	else {
		fptype = (ch->c1prid >> 8) & 0xff;
		vers_maj = (ch->c1prid >> 4) & 0x0f;
		vers_min = ch->c1prid & 0x0f;
	}
d270 1
a270 1
		printf("1 way");
d296 1
a296 1
	printf("cpu%d: Setsize %d:%d\n", cpuno,
d298 2
@


1.38
log
@Do not use NULL in integer comparisons. No functional change.
ok matthew@@ tedu@@, also eyeballed by at least krw@@ oga@@ kettenis@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.37 2011/03/31 20:37:44 miod Exp $ */
d437 1
a437 1
		return NULL;
@


1.37
log
@Recognize Loongson 3A processors, but don't accept to run on them yet, the
cache routines are not ready. This is mostly low-hanging fruit.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.36 2010/11/24 21:16:28 miod Exp $ */
d58 1
a58 1
	NULL, "cpu", DV_DULL, NULL, 0
@


1.36
log
@Floating-point emulation code for systems lacking proper FPU (i.e. Octeon),
enabled by option FPUEMUL.

This is pretty straightforward, except for conditional branch on FPU condition
codes emulation (bc1f/bc1fl/bc1t/bc1tl instructions): unlike most
RISC-with-delay-slots designs (m88k, sparc), the branch pipeline is not exposed
to the kernel on Mips, therefore we can not resume a branch without losing the
delay slot instruction.

Some other operating systems work around this issue by emulating the delay
slot instruction, but this is error-prone (and requires the kernel code to
be aware of all supported instructions of the processor it is currently running
on), some use dedicated breakpoints to single-step through the delay slot and
then resume the branch as expected, but this causes a lot of copy-on-write
allocations.

This code chooses a third path, of copying the delay slot instructions to run toa special `magic' page, followed by a special trap instruction to give control
back to the kernel. This makes sure the instruction will actually be run by the
processor, and that no more than one page per process is wasted, regardless of
the number of branches to emulate.

Tested on octeon (big-endian) by syuu@@ and on loongson (little-endian) by me.
Note that enabling option FPUEMUL in the kernel will completely disable the
hardware FPU, if there is one; there is currently no way to build a kernel
supporting both hardware and software FPU, and there is no reason to change
this until there is a strong need to support both.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.35 2010/09/13 21:59:07 syuu Exp $ */
d169 14
a182 1
		printf("STC Loongson2%c CPU", 'C' + vers_min);
@


1.35
log
@Added OCTEON in cpu type. ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.34 2010/09/09 10:59:01 syuu Exp $ */
d338 1
d349 1
d355 1
d365 1
@


1.34
log
@Move cache settings into hw_cpu_init_secondary() ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.33 2010/09/09 10:55:52 syuu Exp $ */
d172 3
d184 7
a190 3
	fptype = (ch->c1prid >> 8) & 0xff;
	vers_maj = (ch->c1prid >> 4) & 0x0f;
	vers_min = ch->c1prid & 0x0f;
@


1.33
log
@Fix compile error on option DEBUG ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.32 2010/08/30 08:52:10 syuu Exp $ */
d108 2
a109 15
	/*
	 * When attaching secondary processors, cache information is not
	 * available yet.  But since the MP-capable systems we run on
	 * currently all have R10k-style caches, we can quickly compute
	 * the needed values.
	 */
	if (!ISSET(ci->ci_flags, CPUF_PRIMARY)) {
		ci->ci_cacheways = 2;
		ci->ci_l1instcachesize = 32 * 1024;
		ci->ci_l1instcacheline = 64;
		ci->ci_l1datacachesize = 32 * 1024;
		ci->ci_l1datacacheline = 64;
		ci->ci_l2size = ch->l2size;
		ci->ci_l3size = 0;
	}
@


1.32
log
@ddbcpu for sgi. ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.31 2010/08/07 03:50:01 krw Exp $ */
d290 1
a290 1
	    ci->ci_l1instset, ci->ci_l1dataset);
@


1.31
log
@No "\n" needed at the end of panic() strings.

Bogus chunks pointed out by matthew@@ and miod@@. No cookies for
marco@@ and jasper@@.

ok deraadt@@ miod@@ matthew@@ jasper@@ macro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.30 2010/06/26 23:24:43 guenther Exp $ */
a370 1
#ifdef DEBUG
a382 1
#endif
@


1.30
log
@Don't #include <sys/user.h> into files that don't need the stuff
it defines.  In some cases, this means pulling in uvm.h or pcb.h
instead, but most of the inclusions were just noise.  Tested on
alpha, amd64, armish, hppa, i386, macpcc, sgi, sparc64, and vax,
mostly by krw and naddy.
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.29 2010/04/28 16:20:28 syuu Exp $ */
d92 1
a92 1
			panic("unable to allocate cpu_info\n");
@


1.29
log
@Storeing current cpu_info address into LLAddr register, for curcpu().
Instead of previous implementation, we won't use physical cpuid to fetch curcpu().
This requires to implement IP27/35 SMP.
Implemented getcurcpu() and setcurcpu() for it, smp_malloc() renamed alloc_contiguous_pages() because now it only allocate by page.
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.28 2010/03/28 17:09:36 miod Exp $ */
a31 1
#include <sys/user.h>
d34 2
@


1.28
log
@Correctly report the R16010 version.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.27 2010/02/28 18:01:39 miod Exp $ */
d44 1
a46 7

/*
 * Array of CPU info structures.  Must be statically-allocated because
 * curproc, etc. are used early.
 */

struct cpu_info *cpu_info[MAXCPUS] = { &cpu_info_primary };
d88 4
d96 1
a96 4
		ci = (struct cpu_info *)smp_malloc(sizeof(*ci));
		if (ci == NULL)
			panic("unable to allocate cpu_info\n");
		bzero((char *)ci, sizeof(*ci));
a99 1
		cpu_info[cpuno] = ci;
d370 15
d389 1
a389 1
       u_long i;
d391 1
a391 4
       for (i = 0; i < MAXCPUS; i++) {
               ci = cpu_info[i];
               if (ci == NULL)
                       continue;
d400 1
a400 1
       }
d416 1
a416 1
smp_malloc(size_t size)
d418 12
a429 22
       struct pglist mlist;
       struct vm_page *m;
       int error;
       vaddr_t va;
       paddr_t pa;

       if (size < PAGE_SIZE) {
	       va = (vaddr_t)malloc(size, M_DEVBUF, M_NOWAIT);
	       if (va == NULL)
		       return NULL;
	       error = pmap_extract(pmap_kernel(), va, &pa);
	       if (error == FALSE)
		       return NULL;
       } else { 
	       TAILQ_INIT(&mlist);
	       error = uvm_pglistalloc(size, 0, -1L, 0, 0,
		   &mlist, 1, UVM_PLA_NOWAIT);
	       if (error)
		       return NULL;
	       m = TAILQ_FIRST(&mlist);
	       pa = VM_PAGE_TO_PHYS(m);
       }
d431 1
a431 1
       return PHYS_TO_XKPHYS(pa, CCA_CACHED);
@


1.27
log
@Pass L2 cache size in struct cpu_hwinfo, so that bootstrap of secondary
processors can display correct data. Now cpu1 on octane is correctly
reported in dmesg.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.26 2010/02/02 01:29:56 syuu Exp $ */
d205 1
d217 6
a222 1
		printf("R1%d000 FPU", isr16k ? 6 : 4);
@


1.26
log
@lazy FP saving on uniprocessor, just like macppc.
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.25 2010/01/09 23:34:29 miod Exp $ */
d112 17
@


1.25
log
@Move cache information from global variables to per-cpu_info fields; this
allows processors with different cache sizes to be used.

Cache management routines now take a struct cpu_info * as first parameter.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.24 2010/01/09 20:33:16 miod Exp $ */
d314 1
d318 1
a327 3
	KASSERT(!ci->ci_fpuproc);


d329 1
a329 1
		MipsSwitchFPState(NULL, p->p_md.md_regs);
d331 1
a331 1
		MipsSwitchFPState16(NULL, p->p_md.md_regs);
@


1.24
log
@Define struct cpu_hwinfo, to hold hardware specific information about each
processor (instead of sys_config.cpu[]), and pass it in the attach_args
when attaching cpu devices.

This allows per-cpu information to be gathered late in the bootstrap process,
and not be limited by an arbitrary MAX_CPUS limit; this will suit IP27 and
IP35 systems better.

While there, use this information to make sure delay() uses the speed
information from the cpu it is invoked on.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.23 2010/01/08 01:35:52 syuu Exp $ */
d55 1
a55 15
u_int	CpuPrimaryInstCacheSize;
u_int	CpuPrimaryInstCacheLSize;
u_int	CpuPrimaryInstSetSize;
u_int	CpuPrimaryDataCacheSize;
u_int	CpuPrimaryDataCacheLSize;
u_int	CpuPrimaryDataSetSize;
u_int	CpuCacheAliasMask;
u_int	CpuSecondaryCacheSize;
u_int	CpuTertiaryCacheSize;
u_int	CpuNWayCache;
u_int	CpuCacheType;		/* R4K, R5K, RM7K */
u_int	CpuConfigRegister;
u_int	CpuStatusRegister;
u_int	CpuExternalCacheOn;	/* R5K, RM7K */
u_int	CpuOnboardCacheOn;	/* RM7K */
d120 1
a120 1
		if (CpuPrimaryInstCacheSize == 16384)
d234 2
a235 2
	printf("cpu%d: cache L1-I %dKB", cpuno, CpuPrimaryInstCacheSize / 1024);
	printf(" D %dKB ", CpuPrimaryDataCacheSize / 1024);
d237 1
a237 1
	switch (CpuNWayCache) {
d249 1
a249 1
	if (CpuSecondaryCacheSize != 0) {
d254 1
a254 1
			printf(", L2 %dKB 2 way", CpuSecondaryCacheSize / 1024);
d259 1
a259 1
			printf(", L2 %dKB 4 way", CpuSecondaryCacheSize / 1024);
d262 1
a262 1
			printf(", L2 %dKB direct", CpuSecondaryCacheSize / 1024);
d266 2
a267 2
	if (CpuTertiaryCacheSize != 0)
		printf(", L3 %dKB direct", CpuTertiaryCacheSize / 1024);
d272 5
a276 4
	    CpuPrimaryInstSetSize, CpuPrimaryDataSetSize);
	printf("cpu%d: Alias mask 0x%x\n", cpuno, CpuCacheAliasMask);
	printf("cpu%d: Config Register %x\n", cpuno, CpuConfigRegister);
	printf("cpu%d: Cache type %x\n", cpuno, CpuCacheType);
d278 1
a278 1
		u_int tmp = CpuConfigRegister;
d281 4
a284 4
		printf("K0 = %1d  ",0x7 & tmp);
		printf("SE = %1d  ",0x1 & (tmp>>3));
		printf("DB = %1d  ",0x1 & (tmp>>4));
		printf("IB = %1d\n",0x1 & (tmp>>5));
d286 4
a289 4
		printf("DC = %1d  ",0x7 & (tmp>>6));
		printf("IC = %1d  ",0x7 & (tmp>>9));
		printf("TE = %1d  ",0x1 & (tmp>>12));
		printf("EB = %1d\n",0x1 & (tmp>>13));
d291 4
a294 4
		printf("EM = %1d  ",0x1 & (tmp>>14));
		printf("BE = %1d  ",0x1 & (tmp>>15));
		printf("TC = %1d  ",0x1 & (tmp>>17));
		printf("EW = %1d\n",0x3 & (tmp>>18));
d296 4
a299 4
		printf("TS = %1d  ",0x3 & (tmp>>20));
		printf("EP = %1d  ",0xf & (tmp>>24));
		printf("EC = %1d  ",0x7 & (tmp>>28));
		printf("SC = %1d\n",0x1 & (tmp>>31));
d301 1
a301 1
	printf("cpu%d: Status Register %x\n", cpuno, CpuStatusRegister);
@


1.23
log
@MP-safe FPU handling. ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.22 2009/12/28 06:55:27 syuu Exp $ */
d83 1
a83 2
	struct cfdata *cf = match;
	struct mainbus_attach_args *maa = aux;
d86 1
a86 3
	if (strcmp(maa->maa_name, cpu_cd.cd_name) != 0)
		return 0;
	if (cf->cf_unit >= MAX_CPUS)
d95 2
d100 1
d125 1
d130 3
a132 1
	switch (sys_config.cpu[cpuno].type) {
d149 2
a150 2
		if (sys_config.cpu[cpuno].vers_maj > 2) {
			sys_config.cpu[cpuno].vers_maj -= 2;
d174 1
a174 1
		if (sys_config.cpu[cpuno].vers_maj < 2)
d184 1
a184 2
		printf("STC Loongson2%c CPU",
		    'C' + sys_config.cpu[cpuno].vers_min);
d188 1
a188 1
		printf("Unknown CPU type (0x%x)",sys_config.cpu[cpuno].type);
d192 2
a193 3
		printf(" rev %d.%d", sys_config.cpu[cpuno].vers_maj,
		    sys_config.cpu[cpuno].vers_min);
	printf(" %d MHz, ", sys_config.cpu[cpuno].clock / 1000000);
d196 4
a199 1
	switch (sys_config.cpu[cpuno].fptype) {
d237 1
a237 2
		printf("STC Loongson2%c FPU",
		    'C' + sys_config.cpu[cpuno].fpvers_min);
d241 1
a241 1
		printf("Unknown FPU type (0x%x)", sys_config.cpu[cpuno].fptype);
d245 1
a245 2
		printf(" rev %d.%d", sys_config.cpu[cpuno].fpvers_maj,
		    sys_config.cpu[cpuno].fpvers_min);
d264 1
a264 1
		switch (sys_config.cpu[cpuno].type) {
d290 1
a290 1
	if (sys_config.cpu[cpuno].fptype == MIPS_RM7000) {
@


1.22
log
@MP-safe pmap implemented, enable IPI in interrupt handler to avoid deadlock.
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.21 2009/12/02 01:42:14 syuu Exp $ */
d314 48
@


1.21
log
@use kstack for curprocpaddr instead of proc0paddr.
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.20 2009/11/26 14:14:08 syuu Exp $ */
a115 4
		ci->ci_ipiih = 
			(struct intrhand *)smp_malloc(sizeof(*ci->ci_ipiih));
		if (ci->ci_ipiih == NULL)
			panic("unable to allocate ipi intrhand\n");
d346 2
@


1.20
log
@initialize cpu_info correctly.
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.19 2009/11/25 17:39:51 syuu Exp $ */
d335 3
@


1.19
log
@IP30 IPI implementation.
Also few xheart modification for SMP.
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.18 2009/11/24 22:46:59 syuu Exp $ */
a107 1
		ci->ci_ipiih = NULL;
d115 1
@


1.18
log
@smp_malloc() implemented.
This function allocates memory using malloc or uvm_pglistalloc, then returns XKPHYS address of allocated memory.
It's for avoid using virtual address on secondary cpus in early stage, and also in TLB handler.
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.17 2009/11/22 19:41:41 syuu Exp $ */
d108 1
d116 4
d337 5
@


1.17
log
@ncpus, ncpufound values are corrected.
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.16 2009/10/30 08:13:57 syuu Exp $ */
d34 1
d74 1
a74 1
	sizeof(struct cpu_info), cpumatch, cpuattach
d98 1
a98 1
	struct cpu_info *ci = (struct cpu_info *)dev;
a108 1
		bcopy(dev, &ci->ci_dev, sizeof *dev);
d112 3
d118 1
a119 1
	cpu_info[cpuno] = ci;
d123 1
d337 29
@


1.16
log
@Support IP30 secondary cpu bootup. ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.15 2009/10/26 20:14:40 miod Exp $ */
a116 1
	ncpus++;
@


1.15
log
@Rename struct confargs to struct mainbus_attach_args for consistency and also
to prevent further abuse of it.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.14 2009/09/15 04:54:31 syuu Exp $ */
a101 3
#ifdef MULTIPROCESSOR
	cpuset_add(&cpus_running, ci);
#endif
d106 1
d316 13
@


1.14
log
@cpu status flag, cpuid added to cpu_info.
cpu_info pointer array, cpu_info iterator, cpu_number() implementation added.
constraint modifier fixed in lock.h to output correct assembly.
calling proc_trampoline_mp in exception.S.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.13 2009/08/06 21:11:39 miod Exp $ */
d83 1
a83 1
	struct confargs *ca = aux;
d86 1
a86 1
	if (strcmp(ca->ca_name, cpu_cd.cd_name) != 0)
d105 1
a105 1
	if(cpuno == 0) {
@


1.13
log
@Work in progress support for Loongson2E/2F processors; need option CPU_LOONGSON2
in the kernel to be brought in, due to invasive differences in tlb operation.
Comes with a separate cache operations file due to the cache being R5k-style
with R10k-style way number encoding.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.12 2009/06/17 18:18:21 miod Exp $ */
d42 11
d73 1
a73 1
	sizeof(struct device), cpumatch, cpuattach
d97 1
d102 22
d313 12
@


1.12
log
@R14000 processors with revision 3 and above are actually R16000 revision
1 and above, so report them as such.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.11 2007/10/18 04:32:25 miod Exp $ */
d88 1
d92 1
d144 5
d153 4
a156 3
	printf(" rev %d.%d %d MHz with ", sys_config.cpu[cpuno].vers_maj,
	    sys_config.cpu[cpuno].vers_min,
	    sys_config.cpu[cpuno].clock / 1000000);
d158 1
d161 1
a161 1
		printf("Software emulation float");
d196 5
d205 4
a208 2
	printf(" rev %d.%d\n", sys_config.cpu[cpuno].fpvers_maj,
	    sys_config.cpu[cpuno].fpvers_min);
d234 1
@


1.11
log
@No need to include <machine/pte.h> here.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.10 2007/05/07 18:42:13 kettenis Exp $ */
d87 1
d108 5
a112 1
		printf("MIPS R14000 CPU");
d164 1
a164 1
		printf("R14000 FPU");
@


1.10
log
@Move sgo to __HAVE_CPUINFO.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.9 2004/09/21 05:51:15 miod Exp $ */
a34 1
#include <machine/pte.h>
@


1.9
log
@Nuke commons.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.8 2004/09/20 10:29:57 pefo Exp $ */
d41 2
@


1.8
log
@Add support for R10K cpu class
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.7 2004/09/09 22:11:38 pefo Exp $ */
a38 1

d41 16
@


1.7
log
@Kernel moves to 64 bit. A few more tweaks when binutils is updated.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.6 2004/08/11 15:13:58 deraadt Exp $ */
d87 6
d108 1
a108 1
	case MIPS_RM52XX:
d133 1
a133 1
	case MIPS_R4010:
d136 1
a136 1
	case MIPS_R10010:
d139 7
a145 1
	case MIPS_R4210:
d157 1
a157 1
	case MIPS_RM52XX:
a165 1
	case MIPS_UNKF1:
d190 5
@


1.6
log
@ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.5 2004/08/10 20:28:13 deraadt Exp $ */
d198 1
a198 1
	if (fpu_id.cpu[cpuno].cp_imp == MIPS_RM7000) {
@


1.5
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.4 2004/08/10 20:15:47 deraadt Exp $ */
d68 1
a68 4
cpuattach(parent, dev, aux)
	struct device *parent;
	struct device *dev;
	void *aux;
d74 1
a74 2
	switch(sys_config.cpu[cpuno].type) {

d106 1
a106 1
		if (sys_config.cpu[cpuno].vers_maj < 2) {
d108 1
a108 1
		} else {
a109 1
		}
d120 2
a121 5
		sys_config.cpu[cpuno].vers_min,
		sys_config.cpu[cpuno].clock / 1000000);


	switch(sys_config.cpu[cpuno].fptype) {
d123 1
d159 5
a163 3
	printf(" rev %d.%d", sys_config.cpu[cpuno].fpvers_maj,
		sys_config.cpu[cpuno].fpvers_min);
	printf("\n");
d165 1
a165 5
	printf("cpu%d: cache L1-I %dKB", cpuno,
		CpuPrimaryInstCacheSize / 1024);
	printf(" D %dKB ",
		CpuPrimaryDataCacheSize / 1024);
	switch(CpuNWayCache) {
d176 1
d178 1
a178 1
		switch(sys_config.cpu[cpuno].type) {
a182 1

a186 1

d188 1
a188 1
	if (CpuTertiaryCacheSize != 0) {
a189 1
	}
d194 1
a194 1
		CpuPrimaryInstSetSize, CpuPrimaryDataSetSize);
d199 2
a200 2
		u_int tmp;
		tmp = CpuConfigRegister;
@


1.4
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.3 2004/08/09 21:00:54 pefo Exp $ */
d80 1
a80 1
		if(CpuPrimaryInstCacheSize == 16384)
d110 1
a110 1
		if(sys_config.cpu[cpuno].vers_maj < 2) {
d185 1
a185 1
	if(CpuSecondaryCacheSize != 0) {
d198 1
a198 1
	if(CpuTertiaryCacheSize != 0) {
d209 1
a209 1
	if(fpu_id.cpu[cpuno].cp_imp == MIPS_RM7000) {
@


1.3
log
@fixed printout
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.2 2004/08/09 14:57:26 pefo Exp $ */
d5 1
a5 1
 * 
d112 1
a112 2
		}	
		else {
d114 1
a114 1
		}	
d181 1
a181 1
	default:	
@


1.2
log
@Big cleanup. Removed some unused obsolete stuff and fixed copyrights
on some files. Arcbios support is now in, thus detects memorysize and cpu
clock frequency.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.1 2004/08/06 20:56:03 pefo Exp $ */
d125 3
a127 2
	printf(" Rev. %d.%d with ", sys_config.cpu[cpuno].vers_maj,
		sys_config.cpu[cpuno].vers_min);
d136 1
a136 1
		printf("MIPS R4010 FPC");
d139 1
a139 1
		printf("MIPS R10000 FPU");
d142 1
a142 1
		printf("NEC VR4200 FPC (ICE)");
d145 1
a145 1
		printf("QED R4600 Orion FPC");
d148 1
a148 1
		printf("QED R4700 Orion FPC");
d151 1
a151 1
		printf("MIPS R5000 based FPC");
d154 1
a154 1
		printf("PMC-Sierra RM52X0 FPC");
d157 1
a157 1
		printf("PMC-Sierra RM7000 FPC");
d160 1
a160 1
		printf("PMC-Sierra RM9000 FPC");
d167 1
a167 1
	printf(" Rev. %d.%d", sys_config.cpu[cpuno].fpvers_maj,
d171 4
a174 6
	printf("cpu%d: L1 Cache: I size %dkb(%d line),", cpuno,
		CpuPrimaryInstCacheSize / 1024,
		CpuPrimaryInstCacheLSize);
	printf(" D size %dkb(%d line), ",
		CpuPrimaryDataCacheSize / 1024,
		CpuPrimaryDataCacheLSize);
d177 1
a177 1
		printf("two way.\n");
d180 1
a180 1
		printf("four way.\n");
d183 1
a183 1
		printf("direct mapped.\n");
d190 1
a190 2
			printf("cpu%d: L2 Cache: Size %dkb, four way\n",
				cpuno, CpuSecondaryCacheSize / 1024);
d194 1
a194 2
			printf("cpu%d: L2 Cache: Size %dkb, direct mapped\n",
				cpuno, CpuSecondaryCacheSize / 1024);
d200 1
a200 2
		printf("cpu%d: L3 Cache: Size %dkb, direct mapped\n",
			cpuno, CpuTertiaryCacheSize / 1024);
d202 1
@


1.1
log
@initial mips64
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.4 1998/09/15 10:50:12 pefo Exp $ */
d4 1
a4 1
 * Copyright (c) 1997-2003 Opsycon AB (www.opsycon.se)
a13 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Opsycon AB, Sweden.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d40 2
a41 3
/* Definition of the driver for autoconfig. */
static int	cpumatch(struct device *, void *, void *);
static void	cpuattach(struct device *, struct device *, void *);
d52 2
a53 5
static int
cpumatch(parent, cfdata, aux)
	struct device *parent;
	void *cfdata;
	void *aux;
d55 1
d60 3
a62 1
		return (0);
d64 1
a64 1
	return (20);	/* Make CPU probe first */
d67 1
a67 1
static void
d73 1
d77 1
a77 1
	switch(sys_config.cpu.type) {
d110 1
a110 1
		if(sys_config.cpu.vers_maj < 2) {
d122 1
a122 1
		printf("Unknown CPU type (0x%x)",sys_config.cpu.type);
d125 2
a126 1
	printf(" Rev. %d.%d with ", sys_config.cpu.vers_maj, sys_config.cpu.vers_min);
d129 1
a129 1
	switch(fpu_id.cpu.cp_imp) {
d163 1
a163 1
		printf("Unknown FPU type (0x%x)", fpu_id.cpu.cp_imp);
d166 2
a167 1
	printf(" Rev. %d.%d", fpu_id.cpu.cp_majrev, fpu_id.cpu.cp_minrev);
d170 1
a170 2
	printf("        CPU clock %dMhz\n",sys_config.cpu.clock/1000000);
	printf("        L1 Cache: I size %dkb(%d line),",
d188 1
a188 1
		switch(fpu_id.cpu.cp_imp) {
d190 3
a192 2
			printf("        L2 Cache: Size %dkb, four way\n",
				CpuSecondaryCacheSize / 1024);
d196 2
a197 2
			printf("        L2 Cache: Size %dkb, direct mapped\n",
				CpuSecondaryCacheSize / 1024);
d203 2
a204 2
		printf("        L3 Cache: Size %dkb, direct mapped\n",
			CpuTertiaryCacheSize / 1024);
d208 6
a213 5
	printf("\tSetsize %d:%d\n", CpuPrimaryInstSetSize, CpuPrimaryDataSetSize);
	printf("\tAlias mask 0x%x\n", CpuCacheAliasMask);
	printf("\tConfig Register %x\n",CpuConfigRegister);
	printf("\tCache type %x\n", CpuCacheType);
	if(fpu_id.cpu.cp_imp == MIPS_RM7000) {
d216 1
a216 1
		printf("\t\t\t");
d221 1
a221 1
		printf("\t\t\t");
d226 1
a226 1
		printf("\t\t\t");
d231 1
a231 1
		printf("\t\t\t");
d237 1
a237 1
	printf("\tStatus Register %x\n",CpuStatusRegister);
@

