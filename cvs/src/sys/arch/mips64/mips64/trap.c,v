head	1.130;
access;
symbols
	OPENBSD_6_1:1.122.0.4
	OPENBSD_6_1_BASE:1.122
	OPENBSD_6_0:1.116.0.2
	OPENBSD_6_0_BASE:1.116
	OPENBSD_5_9:1.113.0.2
	OPENBSD_5_9_BASE:1.113
	OPENBSD_5_8:1.108.0.4
	OPENBSD_5_8_BASE:1.108
	OPENBSD_5_7:1.105.0.2
	OPENBSD_5_7_BASE:1.105
	OPENBSD_5_6:1.98.0.4
	OPENBSD_5_6_BASE:1.98
	OPENBSD_5_5:1.88.0.8
	OPENBSD_5_5_BASE:1.88
	OPENBSD_5_4:1.88.0.4
	OPENBSD_5_4_BASE:1.88
	OPENBSD_5_3:1.88.0.2
	OPENBSD_5_3_BASE:1.88
	OPENBSD_5_2:1.81.0.2
	OPENBSD_5_2_BASE:1.81
	OPENBSD_5_1_BASE:1.77
	OPENBSD_5_1:1.77.0.2
	OPENBSD_5_0:1.76.0.2
	OPENBSD_5_0_BASE:1.76
	OPENBSD_4_9:1.72.0.2
	OPENBSD_4_9_BASE:1.72
	OPENBSD_4_8:1.63.0.4
	OPENBSD_4_8_BASE:1.63
	OPENBSD_4_7:1.63.0.2
	OPENBSD_4_7_BASE:1.63
	OPENBSD_4_6:1.43.0.4
	OPENBSD_4_6_BASE:1.43
	OPENBSD_4_5:1.41.0.6
	OPENBSD_4_5_BASE:1.41
	OPENBSD_4_4:1.41.0.4
	OPENBSD_4_4_BASE:1.41
	OPENBSD_4_3:1.41.0.2
	OPENBSD_4_3_BASE:1.41
	OPENBSD_4_2:1.37.0.2
	OPENBSD_4_2_BASE:1.37
	OPENBSD_4_1:1.31.0.2
	OPENBSD_4_1_BASE:1.31
	OPENBSD_4_0:1.30.0.2
	OPENBSD_4_0_BASE:1.30
	OPENBSD_3_9:1.29.0.2
	OPENBSD_3_9_BASE:1.29
	OPENBSD_3_8:1.22.0.4
	OPENBSD_3_8_BASE:1.22
	OPENBSD_3_7:1.22.0.2
	OPENBSD_3_7_BASE:1.22
	OPENBSD_3_6:1.5.0.2
	OPENBSD_3_6_BASE:1.5;
locks; strict;
comment	@ * @;


1.130
date	2017.09.02.15.56.29;	author visa;	state Exp;
branches;
next	1.129;
commitid	1y6OLI6UaecTzk2S;

1.129
date	2017.08.30.15.54.33;	author visa;	state Exp;
branches;
next	1.128;
commitid	eFHqDC2bT1TxESep;

1.128
date	2017.08.26.15.21.48;	author visa;	state Exp;
branches;
next	1.127;
commitid	S6Yyp9OyfdlsuUW2;

1.127
date	2017.07.22.18.33.51;	author visa;	state Exp;
branches;
next	1.126;
commitid	iqxNFVfTsgJyqhp8;

1.126
date	2017.07.22.16.44.15;	author visa;	state Exp;
branches;
next	1.125;
commitid	c94wuOZY7FxauHO7;

1.125
date	2017.07.03.16.37.07;	author visa;	state Exp;
branches;
next	1.124;
commitid	cLkJgoxXHUxIEplu;

1.124
date	2017.05.30.15.39.04;	author mpi;	state Exp;
branches;
next	1.123;
commitid	PnZZkFEIj4rPydZo;

1.123
date	2017.04.20.15.42.26;	author visa;	state Exp;
branches;
next	1.122;
commitid	pxUSNsLcOM556nqP;

1.122
date	2017.01.21.05.42.03;	author guenther;	state Exp;
branches;
next	1.121;
commitid	CHRb0fCqa8XxUAMH;

1.121
date	2016.10.19.08.28.20;	author guenther;	state Exp;
branches;
next	1.120;
commitid	VoR9X3uHTxRSYC5r;

1.120
date	2016.10.19.08.23.37;	author guenther;	state Exp;
branches;
next	1.119;
commitid	cDua0teqoT9OVlTN;

1.119
date	2016.10.08.05.49.09;	author guenther;	state Exp;
branches;
next	1.118;
commitid	z63v1DilayzHcfkw;

1.118
date	2016.08.16.13.03.58;	author visa;	state Exp;
branches;
next	1.117;
commitid	6TiwRQZbesPVamIE;

1.117
date	2016.08.14.08.23.52;	author visa;	state Exp;
branches;
next	1.116;
commitid	at8t1tG4p7ou4Cj7;

1.116
date	2016.03.06.19.42.27;	author mpi;	state Exp;
branches;
next	1.115;
commitid	cyYKarj4qRTft4gD;

1.115
date	2016.03.01.11.56.00;	author mpi;	state Exp;
branches;
next	1.114;
commitid	CZXiyhU8oBcz6IpF;

1.114
date	2016.02.27.13.08.07;	author mpi;	state Exp;
branches;
next	1.113;
commitid	hnv9KfQtxhCytAnd;

1.113
date	2016.02.01.16.15.18;	author visa;	state Exp;
branches;
next	1.112;
commitid	fDCG9fyhqhLX230e;

1.112
date	2016.01.10.10.22.56;	author visa;	state Exp;
branches;
next	1.111;
commitid	DXqb5NK6W32O0C6j;

1.111
date	2015.12.31.04.25.51;	author visa;	state Exp;
branches;
next	1.110;
commitid	dVASB3mipffYF1KI;

1.110
date	2015.09.27.09.11.11;	author miod;	state Exp;
branches;
next	1.109;
commitid	gn4scnsliVA0DAAK;

1.109
date	2015.08.19.16.40.10;	author visa;	state Exp;
branches;
next	1.108;
commitid	pxGR9MR5MR7zN8Us;

1.108
date	2015.08.03.13.32.15;	author visa;	state Exp;
branches;
next	1.107;
commitid	uLeFhRNckOdiu4IG;

1.107
date	2015.07.19.17.00.39;	author visa;	state Exp;
branches;
next	1.106;
commitid	seuNPaNPXHoCvszz;

1.106
date	2015.06.05.16.35.24;	author deraadt;	state Exp;
branches;
next	1.105;
commitid	xUscMq6uJseBhZXw;

1.105
date	2015.02.08.05.40.48;	author uebayasi;	state Exp;
branches;
next	1.104;
commitid	8GeCiQaf2awKNwFE;

1.104
date	2015.02.08.05.36.51;	author uebayasi;	state Exp;
branches;
next	1.103;
commitid	ib91m8ejKqIbP9c0;

1.103
date	2015.02.08.00.34.45;	author uebayasi;	state Exp;
branches;
next	1.102;
commitid	ECni5ccl0AkmBfJE;

1.102
date	2014.11.16.12.30.58;	author deraadt;	state Exp;
branches;
next	1.101;
commitid	yv0ECmCdICvq576h;

1.101
date	2014.09.30.06.51.58;	author jmatthew;	state Exp;
branches;
next	1.100;
commitid	pUEUpP9FlbomZUiI;

1.100
date	2014.08.18.17.23.06;	author miod;	state Exp;
branches;
next	1.99;
commitid	77ihtBdMFBARPKhw;

1.99
date	2014.08.17.11.11.34;	author miod;	state Exp;
branches;
next	1.98;
commitid	Tg12K05stdWF38vo;

1.98
date	2014.06.12.20.52.15;	author kettenis;	state Exp;
branches;
next	1.97;
commitid	MTPdXvwX8Mc3M9xu;

1.97
date	2014.05.11.00.12.44;	author guenther;	state Exp;
branches;
next	1.96;

1.96
date	2014.05.11.00.05.38;	author guenther;	state Exp;
branches;
next	1.95;

1.95
date	2014.05.10.22.25.16;	author jasper;	state Exp;
branches;
next	1.94;

1.94
date	2014.05.10.05.33.00;	author guenther;	state Exp;
branches;
next	1.93;

1.93
date	2014.04.18.11.51.17;	author guenther;	state Exp;
branches;
next	1.92;

1.92
date	2014.04.09.21.10.35;	author miod;	state Exp;
branches;
next	1.91;

1.91
date	2014.03.26.19.38.18;	author miod;	state Exp;
branches;
next	1.90;

1.90
date	2014.03.26.05.23.42;	author guenther;	state Exp;
branches;
next	1.89;

1.89
date	2014.03.22.00.01.04;	author miod;	state Exp;
branches;
next	1.88;

1.88
date	2012.10.03.11.18.23;	author miod;	state Exp;
branches;
next	1.87;

1.87
date	2012.09.29.21.37.03;	author miod;	state Exp;
branches;
next	1.86;

1.86
date	2012.09.29.19.24.31;	author miod;	state Exp;
branches;
next	1.85;

1.85
date	2012.09.29.19.14.37;	author miod;	state Exp;
branches;
next	1.84;

1.84
date	2012.09.29.19.13.15;	author miod;	state Exp;
branches;
next	1.83;

1.83
date	2012.08.07.19.55.57;	author miod;	state Exp;
branches;
next	1.82;

1.82
date	2012.08.07.05.16.54;	author guenther;	state Exp;
branches;
next	1.81;

1.81
date	2012.04.11.14.38.55;	author mikeb;	state Exp;
branches;
next	1.80;

1.80
date	2012.04.10.15.59.21;	author miod;	state Exp;
branches;
next	1.79;

1.79
date	2012.04.09.16.56.21;	author miod;	state Exp;
branches;
next	1.78;

1.78
date	2012.03.28.20.44.23;	author miod;	state Exp;
branches;
next	1.77;

1.77
date	2011.11.16.20.50.19;	author deraadt;	state Exp;
branches;
next	1.76;

1.76
date	2011.07.11.15.40.47;	author guenther;	state Exp;
branches;
next	1.75;

1.75
date	2011.07.07.18.11.24;	author art;	state Exp;
branches;
next	1.74;

1.74
date	2011.07.06.21.41.37;	author art;	state Exp;
branches;
next	1.73;

1.73
date	2011.04.03.14.56.28;	author guenther;	state Exp;
branches;
next	1.72;

1.72
date	2010.11.24.21.16.28;	author miod;	state Exp;
branches;
next	1.71;

1.71
date	2010.11.24.21.01.03;	author miod;	state Exp;
branches;
next	1.70;

1.70
date	2010.10.24.15.39.18;	author miod;	state Exp;
branches;
next	1.69;

1.69
date	2010.09.21.21.59.44;	author miod;	state Exp;
branches;
next	1.68;

1.68
date	2010.09.21.20.29.17;	author miod;	state Exp;
branches;
next	1.67;

1.67
date	2010.09.17.00.36.32;	author miod;	state Exp;
branches;
next	1.66;

1.66
date	2010.09.17.00.25.11;	author miod;	state Exp;
branches;
next	1.65;

1.65
date	2010.09.14.19.35.13;	author miod;	state Exp;
branches;
next	1.64;

1.64
date	2010.09.12.18.30.19;	author miod;	state Exp;
branches;
next	1.63;

1.63
date	2010.01.21.17.50.44;	author miod;	state Exp;
branches;
next	1.62;

1.62
date	2010.01.18.18.27.32;	author miod;	state Exp;
branches;
next	1.61;

1.61
date	2010.01.18.16.57.46;	author miod;	state Exp;
branches;
next	1.60;

1.60
date	2010.01.16.23.28.10;	author miod;	state Exp;
branches;
next	1.59;

1.59
date	2010.01.14.07.24.43;	author miod;	state Exp;
branches;
next	1.58;

1.58
date	2010.01.09.23.34.29;	author miod;	state Exp;
branches;
next	1.57;

1.57
date	2010.01.08.01.35.52;	author syuu;	state Exp;
branches;
next	1.56;

1.56
date	2010.01.07.20.51.04;	author miod;	state Exp;
branches;
next	1.55;

1.55
date	2010.01.07.07.36.51;	author syuu;	state Exp;
branches;
next	1.54;

1.54
date	2010.01.01.15.04.00;	author miod;	state Exp;
branches;
next	1.53;

1.53
date	2009.12.28.06.55.27;	author syuu;	state Exp;
branches;
next	1.52;

1.52
date	2009.11.22.00.19.49;	author syuu;	state Exp;
branches;
next	1.51;

1.51
date	2009.11.22.00.07.04;	author miod;	state Exp;
branches;
next	1.50;

1.50
date	2009.11.21.23.28.15;	author syuu;	state Exp;
branches;
next	1.49;

1.49
date	2009.11.19.20.16.27;	author miod;	state Exp;
branches;
next	1.48;

1.48
date	2009.11.19.20.13.52;	author miod;	state Exp;
branches;
next	1.47;

1.47
date	2009.11.18.20.58.52;	author miod;	state Exp;
branches;
next	1.46;

1.46
date	2009.10.22.20.10.44;	author miod;	state Exp;
branches;
next	1.45;

1.45
date	2009.10.22.18.31.51;	author miod;	state Exp;
branches;
next	1.44;

1.44
date	2009.08.06.21.05.49;	author miod;	state Exp;
branches;
next	1.43;

1.43
date	2009.06.10.18.05.31;	author miod;	state Exp;
branches;
next	1.42;

1.42
date	2009.05.22.20.37.53;	author miod;	state Exp;
branches;
next	1.41;

1.41
date	2008.02.20.19.13.38;	author miod;	state Exp;
branches;
next	1.40;

1.40
date	2008.02.18.19.47.36;	author miod;	state Exp;
branches;
next	1.39;

1.39
date	2007.10.25.16.24.18;	author miod;	state Exp;
branches;
next	1.38;

1.38
date	2007.10.18.04.32.08;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2007.07.16.20.21.20;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2007.05.25.20.47.19;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2007.05.09.19.23.17;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2007.05.07.18.42.13;	author kettenis;	state Exp;
branches;
next	1.33;

1.33
date	2007.05.03.19.34.00;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2007.03.27.19.51.00;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2006.12.24.20.30.35;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2006.05.31.20.19.39;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2005.12.17.20.13.44;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2005.12.12.18.59.04;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2005.12.11.21.30.30;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2005.11.06.10.26.56;	author martin;	state Exp;
branches;
next	1.25;

1.25
date	2005.10.24.20.20.03;	author kettenis;	state Exp;
branches;
next	1.24;

1.24
date	2005.09.15.21.14.27;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2005.09.15.21.09.29;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2005.01.31.21.35.50;	author grange;	state Exp;
branches;
next	1.21;

1.21
date	2005.01.18.15.03.38;	author grange;	state Exp;
branches;
next	1.20;

1.20
date	2004.12.24.22.50.30;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2004.12.06.20.12.24;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2004.11.11.19.00.37;	author kettenis;	state Exp;
branches;
next	1.17;

1.17
date	2004.11.09.19.06.18;	author kettenis;	state Exp;
branches;
next	1.16;

1.16
date	2004.10.30.14.49.39;	author pefo;	state Exp;
branches;
next	1.15;

1.15
date	2004.10.30.14.48.59;	author pefo;	state Exp;
branches;
next	1.14;

1.14
date	2004.10.20.12.49.15;	author pefo;	state Exp;
branches;
next	1.13;

1.13
date	2004.10.08.07.45.15;	author grange;	state Exp;
branches;
next	1.12;

1.12
date	2004.09.23.08.42.38;	author pefo;	state Exp;
branches;
next	1.11;

1.11
date	2004.09.22.14.39.44;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2004.09.21.08.53.51;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2004.09.21.05.51.15;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2004.09.17.19.19.08;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2004.09.16.09.58.56;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2004.09.16.07.25.26;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2004.09.09.22.11.38;	author pefo;	state Exp;
branches;
next	1.4;

1.4
date	2004.08.10.20.28.13;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.10.20.15.47;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2004.08.08.14.21.27;	author pefo;	state Exp;
branches;
next	1.1;

1.1
date	2004.08.06.20.56.03;	author pefo;	state Exp;
branches;
next	;


desc
@@


1.130
log
@Let the kernel utilize the FPU if one is available, even when the
FPUEMUL option is enabled. This benefits OCTEON III systems which can
run floating-point operations natively.

Feedback from and OK miod@@; he also helped with testing.

Tested on octeon without FPU (CN5020, CN6120) and with FPU (CN7130),
as well as on sgi/IP27 (MP R16000), sgi/IP32 (R5000), and
loongson (3A1000).
@
text
@/*	$OpenBSD: trap.c,v 1.129 2017/08/30 15:54:33 visa Exp $	*/

/*
 * Copyright (c) 1988 University of Utah.
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department and Ralph Campbell.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * from: Utah Hdr: trap.c 1.32 91/04/06
 *
 *	from: @@(#)trap.c	8.5 (Berkeley) 1/11/94
 */


#include <sys/param.h>
#include <sys/systm.h>
#include <sys/exec.h>
#include <sys/proc.h>
#include <sys/kernel.h>
#include <sys/signalvar.h>
#include <sys/user.h>
#include <sys/syscall.h>
#include <sys/syscall_mi.h>
#include <sys/buf.h>
#include <sys/device.h>
#include <sys/atomic.h>
#ifdef PTRACE
#include <sys/ptrace.h>
#endif

#include <uvm/uvm_extern.h>

#include <machine/autoconf.h>
#include <machine/cpu.h>
#include <mips64/mips_cpu.h>
#include <machine/fpu.h>
#include <machine/frame.h>
#include <machine/mips_opcode.h>
#include <machine/regnum.h>
#include <machine/tcb.h>
#include <machine/trap.h>

#ifdef DDB
#include <mips64/db_machdep.h>
#include <ddb/db_output.h>
#include <ddb/db_sym.h>
#endif

#include <sys/syslog.h>

#define	USERMODE(ps)	(((ps) & SR_KSU_MASK) == SR_KSU_USER)

const char *trap_type[] = {
	"external interrupt",
	"TLB modification",
	"TLB miss (load or instr. fetch)",
	"TLB miss (store)",
	"address error (load or I-fetch)",
	"address error (store)",
	"bus error (I-fetch)",
	"bus error (load or store)",
	"system call",
	"breakpoint",
	"reserved instruction",
	"coprocessor unusable",
	"arithmetic overflow",
	"trap",
	"virtual coherency instruction",
	"floating point",
	"reserved 16",
	"reserved 17",
	"reserved 18",
	"reserved 19",
	"reserved 20",
	"reserved 21",
	"reserved 22",
	"watch",
	"reserved 24",
	"reserved 25",
	"reserved 26",
	"reserved 27",
	"reserved 28",
	"reserved 29",
	"reserved 30",
	"virtual coherency data"
};

#if defined(DDB) || defined(DEBUG)
struct trapdebug trapdebug[MAXCPUS * TRAPSIZE];
uint trppos[MAXCPUS];

void	stacktrace(struct trapframe *);
uint32_t kdbpeek(vaddr_t);
uint64_t kdbpeekd(vaddr_t);
#endif	/* DDB || DEBUG */

#if defined(DDB)
extern int db_ktrap(int, db_regs_t *);
#endif

void	ast(void);
extern void interrupt(struct trapframe *);
void	itsa(struct trapframe *, struct cpu_info *, struct proc *, int);
void	trap(struct trapframe *);
#ifdef PTRACE
int	ptrace_read_insn(struct proc *, vaddr_t, uint32_t *);
int	ptrace_write_insn(struct proc *, vaddr_t, uint32_t);
int	process_sstep(struct proc *, int);
#endif

/*
 * Handle an AST for the current process.
 */
void
ast(void)
{
	struct cpu_info *ci = curcpu();
	struct proc *p = ci->ci_curproc;

	p->p_md.md_astpending = 0;

	atomic_inc_int(&uvmexp.softs);
	mi_ast(p, ci->ci_want_resched);
	userret(p);
}

/*
 * Handle an exception.
 * In the case of a kernel trap, we return the pc where to resume if
 * pcb_onfault is set, otherwise, return old pc.
 */
void
trap(struct trapframe *trapframe)
{
	struct cpu_info *ci = curcpu();
	struct proc *p = ci->ci_curproc;
	int type;

	type = (trapframe->cause & CR_EXC_CODE) >> CR_EXC_CODE_SHIFT;

#if defined(CPU_R8000) && !defined(DEBUG_INTERRUPT)
	if (type != T_INT)
#endif
		trapdebug_enter(ci, trapframe, -1);

#ifdef CPU_R8000
	if (type != T_INT && type != T_SYSCALL)
#else
	if (type != T_SYSCALL)
#endif
		atomic_inc_int(&uvmexp.traps);
	if (USERMODE(trapframe->sr))
		type |= T_USER;

	/*
	 * Enable hardware interrupts if they were on before the trap;
	 * enable IPI interrupts only otherwise.
	 */
	switch (type) {
#ifdef CPU_R8000
	case T_INT:
	case T_INT | T_USER:
#endif
	case T_BREAK:
		break;
	default:
		if (ISSET(trapframe->sr, SR_INT_ENAB))
			enableintr();
		else {
#ifdef MULTIPROCESSOR
			ENABLEIPI();
#endif
		}
		break;
	}

#ifdef CPU_R8000
	/*
	 * Some exception causes on R8000 are actually detected by external
	 * circuitry, and as such are reported as external interrupts.
	 * On R8000 kernels, external interrupts vector to trap() instead of
	 * interrupt(), so that we can process these particular exceptions
	 * as if they were triggered as regular exceptions.
	 */
	if ((type & ~T_USER) == T_INT) {
		if (trapframe->cause & CR_VCE) {
#ifndef DEBUG_INTERRUPT
			trapdebug_enter(ci, trapframe, -1);
#endif
			panic("VCE or TLBX");
		}

		if (trapframe->cause & CR_FPE) {
#ifndef DEBUG_INTERRUPT
			trapdebug_enter(ci, trapframe, -1);
#endif
			atomic_inc_int(&uvmexp.traps);
			if (type & T_USER)
				refreshcreds(p);
			itsa(trapframe, ci, p, T_FPE | (type & T_USER));
			cp0_reset_cause(CR_FPE);
		}

		if (trapframe->cause & CR_INT_MASK) {
			/*
			 * Similar reality check as done in interrupt(), in
			 * case an interrupt occured between a write to
			 * COP_0_STATUS_REG and it taking effect.
			 * (I have never seen this occuring on R8000 but
			 *  this is cheap)
			 */
			if (ISSET(trapframe->sr, SR_INT_ENAB))
				interrupt(trapframe);
		}

		if ((trapframe->cause & CR_FPE) && (type & T_USER))
			userret(p);

		return;
	}
#endif

	if (type & T_USER)
		refreshcreds(p);

	itsa(trapframe, ci, p, type);

	if (type & T_USER)
		userret(p);
}

/*
 * Handle a single exception.
 */
void
itsa(struct trapframe *trapframe, struct cpu_info *ci, struct proc *p,
    int type)
{
	unsigned ucode = 0;
	vm_prot_t ftype;
	extern vaddr_t onfault_table[];
	int onfault;
	int signal, sicode;
	union sigval sv;
	struct pcb *pcb;

	switch (type) {
	case T_TLB_MOD:
		/* check for kernel address */
		if (trapframe->badvaddr < 0) {
			if (pmap_emulate_modify(pmap_kernel(),
			    trapframe->badvaddr)) {
				/* write to read only page in the kernel */
				ftype = PROT_WRITE;
				pcb = &p->p_addr->u_pcb;
				goto kernel_fault;
			}
			return;
		}
		/* FALLTHROUGH */

	case T_TLB_MOD+T_USER:
		if (pmap_emulate_modify(p->p_vmspace->vm_map.pmap,
		    trapframe->badvaddr)) {
			/* write to read only page */
			ftype = PROT_WRITE;
			pcb = &p->p_addr->u_pcb;
			goto fault_common_no_miss;
		}
		return;

	case T_TLB_LD_MISS:
	case T_TLB_ST_MISS:
		if (type == T_TLB_LD_MISS) {
#ifdef CPU_OCTEON
			vaddr_t pc;

			/*
			 * Check if the fault was caused by
			 * an instruction fetch.
			 */
			pc = trapframe->pc;
			if (trapframe->cause & CR_BR_DELAY)
				pc += 4;
			if (pc == trapframe->badvaddr)
				ftype = PROT_EXEC;
			else
#endif
			ftype = PROT_READ;
		} else
			ftype = PROT_WRITE;

		pcb = &p->p_addr->u_pcb;
		/* check for kernel address */
		if (trapframe->badvaddr < 0) {
			vaddr_t va;
			int rv;

	kernel_fault:
			va = trunc_page((vaddr_t)trapframe->badvaddr);
			onfault = pcb->pcb_onfault;
			pcb->pcb_onfault = 0;
			KERNEL_LOCK();
			rv = uvm_fault(kernel_map, va, 0, ftype);
			KERNEL_UNLOCK();
			pcb->pcb_onfault = onfault;
			if (rv == 0)
				return;
			if (onfault != 0) {
				pcb->pcb_onfault = 0;
				trapframe->pc = onfault_table[onfault];
				return;
			}
			goto err;
		}
		/*
		 * It is an error for the kernel to access user space except
		 * through the copyin/copyout routines.
		 */
		if (pcb->pcb_onfault != 0) {
			/*
			 * We want to resolve the TLB fault before invoking
			 * pcb_onfault if necessary.
			 */
			goto fault_common;
		} else {
			goto err;
		}

	case T_TLB_LD_MISS+T_USER: {
#ifdef CPU_OCTEON
		vaddr_t pc;

		/* Check if the fault was caused by an instruction fetch. */
		pc = trapframe->pc;
		if (trapframe->cause & CR_BR_DELAY)
			pc += 4;
		if (pc == trapframe->badvaddr)
			ftype = PROT_EXEC;
		else
#endif
		ftype = PROT_READ;
		pcb = &p->p_addr->u_pcb;
		goto fault_common;
	}

	case T_TLB_ST_MISS+T_USER:
		ftype = PROT_WRITE;
		pcb = &p->p_addr->u_pcb;
fault_common:

#ifdef CPU_R4000
		if (r4000_errata != 0) {
			if (eop_tlb_miss_handler(trapframe, ci, p) != 0)
				return;
		}
#endif

fault_common_no_miss:

#ifdef CPU_R4000
		if (r4000_errata != 0) {
			eop_cleanup(trapframe, p);
		}
#endif

	    {
		vaddr_t va;
		struct vmspace *vm;
		vm_map_t map;
		int rv;

		vm = p->p_vmspace;
		map = &vm->vm_map;
		va = trunc_page((vaddr_t)trapframe->badvaddr);

		onfault = pcb->pcb_onfault;
		pcb->pcb_onfault = 0;
		KERNEL_LOCK();

		rv = uvm_fault(map, va, 0, ftype);
		pcb->pcb_onfault = onfault;

		/*
		 * If this was a stack access we keep track of the maximum
		 * accessed stack size.  Also, if vm_fault gets a protection
		 * failure it is due to accessing the stack region outside
		 * the current limit and we need to reflect that as an access
		 * error.
		 */
		if (rv == 0 && (caddr_t)va >= vm->vm_maxsaddr)
			uvm_grow(p, va);

		KERNEL_UNLOCK();
		if (rv == 0)
			return;
		if (!USERMODE(trapframe->sr)) {
			if (onfault != 0) {
				pcb->pcb_onfault = 0;
				trapframe->pc =  onfault_table[onfault];
				return;
			}
			goto err;
		}

		ucode = ftype;
		signal = SIGSEGV;
		sicode = SEGV_MAPERR;
		if (rv == EACCES)
			sicode = SEGV_ACCERR;
		if (rv == EIO) {
			signal = SIGBUS;
			sicode = BUS_OBJERR;
		}
		break;
	    }

	case T_ADDR_ERR_LD+T_USER:	/* misaligned or kseg access */
	case T_ADDR_ERR_ST+T_USER:	/* misaligned or kseg access */
		ucode = 0;		/* XXX should be PROT_something */
		signal = SIGBUS;
		sicode = BUS_ADRALN;
		break;
	case T_BUS_ERR_IFETCH+T_USER:	/* BERR asserted to cpu */
	case T_BUS_ERR_LD_ST+T_USER:	/* BERR asserted to cpu */
		ucode = 0;		/* XXX should be PROT_something */
		signal = SIGBUS;
		sicode = BUS_OBJERR;
		break;

	case T_SYSCALL+T_USER:
	    {
		struct trapframe *locr0 = p->p_md.md_regs;
		struct sysent *callp;
		unsigned int code;
		register_t tpc;
		uint32_t branch = 0;
		int error, numarg, numsys;
		struct args {
			register_t i[8];
		} args;
		register_t rval[2];

		atomic_inc_int(&uvmexp.syscalls);

		/* compute next PC after syscall instruction */
		tpc = trapframe->pc; /* Remember if restart */
		if (trapframe->cause & CR_BR_DELAY) {
			/* Get the branch instruction. */
			if (copyin32((const void *)locr0->pc, &branch) != 0) {
				signal = SIGBUS;
				sicode = BUS_OBJERR;
				break;
			}

			locr0->pc = MipsEmulateBranch(locr0,
			    trapframe->pc, 0, branch);
		} else
			locr0->pc += 4;
		callp = p->p_p->ps_emul->e_sysent;
		numsys = p->p_p->ps_emul->e_nsysent;
		code = locr0->v0;
		switch (code) {
		case SYS_syscall:
		case SYS___syscall:
			/*
			 * Code is first argument, followed by actual args.
			 * __syscall provides the code as a quad to maintain
			 * proper alignment of 64-bit arguments on 32-bit
			 * platforms, which doesn't change anything here.
			 */
			code = locr0->a0;
			if (code >= numsys)
				callp += p->p_p->ps_emul->e_nosys; /* (illegal) */
			else
				callp += code;
			numarg = callp->sy_argsize / sizeof(register_t);
			args.i[0] = locr0->a1;
			args.i[1] = locr0->a2;
			args.i[2] = locr0->a3;
			if (numarg > 3) {
				args.i[3] = locr0->a4;
				args.i[4] = locr0->a5;
				args.i[5] = locr0->a6;
				args.i[6] = locr0->a7;
				if (numarg > 7)
					if ((error = copyin((void *)locr0->sp,
					    &args.i[7], sizeof(register_t))))
						goto bad;
			}
			break;
		default:
			if (code >= numsys)
				callp += p->p_p->ps_emul->e_nosys; /* (illegal) */
			else
				callp += code;

			numarg = callp->sy_narg;
			args.i[0] = locr0->a0;
			args.i[1] = locr0->a1;
			args.i[2] = locr0->a2;
			args.i[3] = locr0->a3;
			if (numarg > 4) {
				args.i[4] = locr0->a4;
				args.i[5] = locr0->a5;
				args.i[6] = locr0->a6;
				args.i[7] = locr0->a7;
			}
		}

		rval[0] = 0;
		rval[1] = locr0->v1;

#if defined(DDB) || defined(DEBUG)
		trapdebug[TRAPSIZE * ci->ci_cpuid + (trppos[ci->ci_cpuid] == 0 ?
		    TRAPSIZE : trppos[ci->ci_cpuid]) - 1].code = code;
#endif

		error = mi_syscall(p, code, callp, args.i, rval);

		switch (error) {
		case 0:
			locr0->v0 = rval[0];
			locr0->v1 = rval[1];
			locr0->a3 = 0;
			break;

		case ERESTART:
			locr0->pc = tpc;
			break;

		case EJUSTRETURN:
			break;	/* nothing to do */

		default:
		bad:
			locr0->v0 = error;
			locr0->a3 = 1;
		}

		mi_syscall_return(p, code, error, rval);

		return;
	    }

	case T_BREAK:
#ifdef DDB
		db_ktrap(type, trapframe);
#endif
		/* Reenable interrupts if necessary */
		if (trapframe->sr & SR_INT_ENAB) {
			enableintr();
		}
		return;

	case T_BREAK+T_USER:
	    {
		struct trapframe *locr0 = p->p_md.md_regs;
		caddr_t va;
		uint32_t branch = 0;
		uint32_t instr;

		/* compute address of break instruction */
		va = (caddr_t)trapframe->pc;
		if (trapframe->cause & CR_BR_DELAY) {
			va += 4;

			/* Read branch instruction. */
			if (copyin32((const void *)trapframe->pc,
			    &branch) != 0) {
				signal = SIGBUS;
				sicode = BUS_OBJERR;
				break;
			}
		}

		/* read break instruction */
		if (copyin32((const void *)va, &instr) != 0) {
			signal = SIGBUS;
			sicode = BUS_OBJERR;
			break;
		}

		switch ((instr & BREAK_VAL_MASK) >> BREAK_VAL_SHIFT) {
		case 6:	/* gcc range error */
			signal = SIGFPE;
			sicode = FPE_FLTSUB;
			/* skip instruction */
			if (trapframe->cause & CR_BR_DELAY)
				locr0->pc = MipsEmulateBranch(locr0,
				    trapframe->pc, 0, branch);
			else
				locr0->pc += 4;
			break;
		case 7:	/* gcc3 divide by zero */
			signal = SIGFPE;
			sicode = FPE_INTDIV;
			/* skip instruction */
			if (trapframe->cause & CR_BR_DELAY)
				locr0->pc = MipsEmulateBranch(locr0,
				    trapframe->pc, 0, branch);
			else
				locr0->pc += 4;
			break;
#ifdef PTRACE
		case BREAK_SSTEP_VAL:
			if (p->p_md.md_ss_addr == (long)va) {
#ifdef DEBUG
				printf("trap: %s (%d): breakpoint at %p "
				    "(insn %08x)\n",
				    p->p_p->ps_comm, p->p_p->ps_pid,
				    (void *)p->p_md.md_ss_addr,
				    p->p_md.md_ss_instr);
#endif

				/* Restore original instruction and clear BP */
				KERNEL_LOCK();
				process_sstep(p, 0);
				KERNEL_UNLOCK();
				sicode = TRAP_BRKPT;
			} else {
				sicode = TRAP_TRACE;
			}
			signal = SIGTRAP;
			break;
#endif
#ifdef FPUEMUL
		case BREAK_FPUEMUL_VAL:
			/*
			 * If this is a genuine FP emulation break,
			 * resume execution to our branch destination.
			 */
			if (!CPU_HAS_FPU(ci) &&
			    (p->p_md.md_flags & MDP_FPUSED) != 0 &&
			    p->p_md.md_fppgva + 4 == (vaddr_t)va) {
				struct vm_map *map = &p->p_vmspace->vm_map;

				p->p_md.md_flags &= ~MDP_FPUSED;
				locr0->pc = p->p_md.md_fpbranchva;

				/*
				 * Prevent access to the relocation page.
				 * XXX needs to be fixed to work with rthreads
				 */
				KERNEL_LOCK();
				uvm_fault_unwire(map, p->p_md.md_fppgva,
				    p->p_md.md_fppgva + PAGE_SIZE);
				KERNEL_UNLOCK();
				(void)uvm_map_protect(map, p->p_md.md_fppgva,
				    p->p_md.md_fppgva + PAGE_SIZE,
				    PROT_NONE, FALSE);
				return;
			}
			/* FALLTHROUGH */
#endif
		default:
			signal = SIGTRAP;
			sicode = TRAP_TRACE;
			break;
		}
		break;
	    }

	case T_IWATCH+T_USER:
	case T_DWATCH+T_USER:
	    {
		caddr_t va;
		/* compute address of trapped instruction */
		va = (caddr_t)trapframe->pc;
		if (trapframe->cause & CR_BR_DELAY)
			va += 4;
		printf("watch exception @@ %p\n", va);
		signal = SIGTRAP;
		sicode = TRAP_BRKPT;
		break;
	    }

	case T_TRAP+T_USER:
	    {
		struct trapframe *locr0 = p->p_md.md_regs;
		caddr_t va;
		uint32_t branch = 0;
		uint32_t instr;

		/* compute address of trap instruction */
		va = (caddr_t)trapframe->pc;
		if (trapframe->cause & CR_BR_DELAY) {
			va += 4;

			/* Read branch instruction. */
			if (copyin32((const void *)trapframe->pc,
			    &branch) != 0) {
				signal = SIGBUS;
				sicode = BUS_OBJERR;
				break;
			}
		}

		/* read break instruction */
		if (copyin32((const void *)va, &instr) != 0) {
			signal = SIGBUS;
			sicode = BUS_OBJERR;
			break;
		}

		if (trapframe->cause & CR_BR_DELAY)
			locr0->pc = MipsEmulateBranch(locr0,
			    trapframe->pc, 0, branch);
		else
			locr0->pc += 4;
		/*
		 * GCC 4 uses teq with code 7 to signal divide by
	 	 * zero at runtime. This is one instruction shorter
		 * than the BEQ + BREAK combination used by gcc 3.
		 */
		if ((instr & 0xfc00003f) == 0x00000034 /* teq */ &&
		    (instr & 0x001fffc0) == ((ZERO << 16) | (7 << 6))) {
			signal = SIGFPE;
			sicode = FPE_INTDIV;
		} else {
			signal = SIGEMT; /* Stuff it with something for now */
			sicode = 0;
		}
		break;
	    }

	case T_RES_INST+T_USER:
	    {
		register_t *regs = (register_t *)trapframe;
		caddr_t va;
		uint32_t branch = 0;
		InstFmt inst;

		/* Compute the instruction's address. */
		va = (caddr_t)trapframe->pc;
		if (trapframe->cause & CR_BR_DELAY) {
			va += 4;

			/* Get the branch instruction. */
			if (copyin32((const void *)trapframe->pc,
			    &branch) != 0) {
				signal = SIGBUS;
				sicode = BUS_OBJERR;
				break;
			}
		}

		/* Get the faulting instruction. */
		if (copyin32((const void *)va, &inst.word) != 0) {
			signal = SIGBUS;
			sicode = BUS_OBJERR;
			break;
		}
		
		/* Emulate "RDHWR rt, UserLocal". */
		if (inst.RType.op == OP_SPECIAL3 &&
		    inst.RType.rs == 0 &&
		    inst.RType.rd == 29 &&
		    inst.RType.shamt == 0 &&
		    inst.RType.func == OP_RDHWR) {
			regs[inst.RType.rt] = (register_t)TCB_GET(p);

			/* Figure out where to continue. */
			if (trapframe->cause & CR_BR_DELAY)
				trapframe->pc = MipsEmulateBranch(trapframe,
				    trapframe->pc, 0, branch);
			else
				trapframe->pc += 4;
			return;
		}

		signal = SIGILL;
		sicode = ILL_ILLOPC;
		break;
	    }

	case T_COP_UNUSABLE+T_USER:
		/*
		 * Note MIPS IV COP1X instructions issued with FPU
		 * disabled correctly report coprocessor 1 as the
		 * unusable coprocessor number.
		 */
		if ((trapframe->cause & CR_COP_ERR) != CR_COP1_ERR) {
			signal = SIGILL; /* only FPU instructions allowed */
			sicode = ILL_ILLOPC;
			break;
		}
		if (CPU_HAS_FPU(ci))
			enable_fpu(p);
		else
			MipsFPTrap(trapframe);
		return;

	case T_FPE:
		printf("FPU Trap: PC %lx CR %lx SR %lx\n",
			trapframe->pc, trapframe->cause, trapframe->sr);
		goto err;

	case T_FPE+T_USER:
		MipsFPTrap(trapframe);
		return;

	case T_OVFLOW+T_USER:
		signal = SIGFPE;
		sicode = FPE_FLTOVF;
		break;

	case T_ADDR_ERR_LD:	/* misaligned access */
	case T_ADDR_ERR_ST:	/* misaligned access */
	case T_BUS_ERR_LD_ST:	/* BERR asserted to cpu */
		pcb = &p->p_addr->u_pcb;
		if ((onfault = pcb->pcb_onfault) != 0) {
			pcb->pcb_onfault = 0;
			trapframe->pc = onfault_table[onfault];
			return;
		}
		goto err;

#ifdef CPU_R10000
	case T_BUS_ERR_IFETCH:
		/*
		 * At least R16000 processor have been found triggering
		 * reproduceable bus error on instruction fetch in the
		 * kernel code, which are trivially recoverable (and
		 * look like an obscure errata to me).
		 *
		 * Thus, ignore these exceptions if the faulting address
		 * is in the kernel.
		 */
	    {
		extern void *kernel_text;
		extern void *etext;
		vaddr_t va;

		va = (vaddr_t)trapframe->pc;
		if (trapframe->cause & CR_BR_DELAY)
			va += 4;
		if (va > (vaddr_t)&kernel_text && va < (vaddr_t)&etext)
			return;
	    }
		goto err;
#endif

	default:
	err:
		disableintr();
#if !defined(DDB) && defined(DEBUG)
		trapDump("trap", printf);
#endif
		printf("\nTrap cause = %d Frame %p\n", type, trapframe);
		printf("Trap PC %p RA %p fault %p\n",
		    (void *)trapframe->pc, (void *)trapframe->ra,
		    (void *)trapframe->badvaddr);
#ifdef DDB
		stacktrace(!USERMODE(trapframe->sr) ? trapframe : p->p_md.md_regs);
		db_ktrap(type, trapframe);
#endif
		panic("trap");
	}

#ifdef FPUEMUL
	/*
	 * If a relocated delay slot causes an exception, blame the
	 * original delay slot address - userland is not supposed to
	 * know anything about emulation bowels.
	 */
	if (!CPU_HAS_FPU(ci) && (p->p_md.md_flags & MDP_FPUSED) != 0 &&
	    trapframe->badvaddr == p->p_md.md_fppgva)
		trapframe->badvaddr = p->p_md.md_fpslotva;
#endif
	p->p_md.md_regs->pc = trapframe->pc;
	p->p_md.md_regs->cause = trapframe->cause;
	p->p_md.md_regs->badvaddr = trapframe->badvaddr;
	sv.sival_ptr = (void *)trapframe->badvaddr;
	KERNEL_LOCK();
	trapsignal(p, signal, ucode, sicode, sv);
	KERNEL_UNLOCK();
}

void
child_return(void *arg)
{
	struct proc *p = arg;
	struct trapframe *trapframe;

	trapframe = p->p_md.md_regs;
	trapframe->v0 = 0;
	trapframe->v1 = 1;
	trapframe->a3 = 0;

	KERNEL_UNLOCK();

	mi_child_return(p);
}

#if defined(DDB) || defined(DEBUG)
void
trapDump(const char *msg, int (*pr)(const char *, ...))
{
#ifdef MULTIPROCESSOR
	CPU_INFO_ITERATOR cii;
#endif
	struct cpu_info *ci;
	struct trapdebug *base, *ptrp;
	int i;
	uint pos;
	int s;

	s = splhigh();
	(*pr)("trapDump(%s)\n", msg);
#ifndef MULTIPROCESSOR
	ci = curcpu();
#else
	CPU_INFO_FOREACH(cii, ci)
#endif
	{
#ifdef MULTIPROCESSOR
		(*pr)("cpu%d\n", ci->ci_cpuid);
#endif
		/* walk in reverse order */
		pos = trppos[ci->ci_cpuid];
		base = trapdebug + ci->ci_cpuid * TRAPSIZE;
		for (i = TRAPSIZE - 1; i >= 0; i--) {
			if (pos + i >= TRAPSIZE)
				ptrp = base + pos + i - TRAPSIZE;
			else
				ptrp = base + pos + i;

			if (ptrp->cause == 0)
				break;

#ifdef CPU_R8000
			(*pr)("%s: PC %p CR 0x%016lx SR 0x%011lx\n",
			    trap_type[(ptrp->cause & CR_EXC_CODE) >>
			      CR_EXC_CODE_SHIFT],
			    ptrp->pc, ptrp->cause, ptrp->status);
#else
			(*pr)("%s: PC %p CR 0x%08lx SR 0x%08lx\n",
			    trap_type[(ptrp->cause & CR_EXC_CODE) >>
			      CR_EXC_CODE_SHIFT],
			    ptrp->pc, ptrp->cause & 0xffffffff,
			    ptrp->status & 0xffffffff);
#endif
			(*pr)(" RA %p SP %p ADR %p\n",
			    ptrp->ra, ptrp->sp, ptrp->vadr);
		}
	}

	splx(s);
}
#endif


/*
 * Return the resulting PC as if the branch was executed.
 */
register_t
MipsEmulateBranch(struct trapframe *tf, vaddr_t instPC, uint32_t fsr,
    uint32_t curinst)
{
	register_t *regsPtr = (register_t *)tf;
	InstFmt inst;
	vaddr_t retAddr;
	int condition;
	uint cc;

#define	GetBranchDest(InstPtr, inst) \
	    (InstPtr + 4 + ((short)inst.IType.imm << 2))

	inst.word = curinst;

	regsPtr[ZERO] = 0;	/* Make sure zero is 0x0 */

	switch ((int)inst.JType.op) {
	case OP_SPECIAL:
		switch ((int)inst.RType.func) {
		case OP_JR:
		case OP_JALR:
			retAddr = (vaddr_t)regsPtr[inst.RType.rs];
			break;
		default:
			retAddr = instPC + 4;
			break;
		}
		break;
	case OP_BCOND:
		switch ((int)inst.IType.rt) {
		case OP_BLTZ:
		case OP_BLTZL:
		case OP_BLTZAL:
		case OP_BLTZALL:
			if ((int64_t)(regsPtr[inst.RType.rs]) < 0)
				retAddr = GetBranchDest(instPC, inst);
			else
				retAddr = instPC + 8;
			break;
		case OP_BGEZ:
		case OP_BGEZL:
		case OP_BGEZAL:
		case OP_BGEZALL:
			if ((int64_t)(regsPtr[inst.RType.rs]) >= 0)
				retAddr = GetBranchDest(instPC, inst);
			else
				retAddr = instPC + 8;
			break;
		default:
			retAddr = instPC + 4;
			break;
		}
		break;
	case OP_J:
	case OP_JAL:
		retAddr = (inst.JType.target << 2) | (instPC & ~0x0fffffffUL);
		break;
	case OP_BEQ:
	case OP_BEQL:
		if (regsPtr[inst.RType.rs] == regsPtr[inst.RType.rt])
			retAddr = GetBranchDest(instPC, inst);
		else
			retAddr = instPC + 8;
		break;
	case OP_BNE:
	case OP_BNEL:
		if (regsPtr[inst.RType.rs] != regsPtr[inst.RType.rt])
			retAddr = GetBranchDest(instPC, inst);
		else
			retAddr = instPC + 8;
		break;
	case OP_BLEZ:
	case OP_BLEZL:
		if ((int64_t)(regsPtr[inst.RType.rs]) <= 0)
			retAddr = GetBranchDest(instPC, inst);
		else
			retAddr = instPC + 8;
		break;
	case OP_BGTZ:
	case OP_BGTZL:
		if ((int64_t)(regsPtr[inst.RType.rs]) > 0)
			retAddr = GetBranchDest(instPC, inst);
		else
			retAddr = instPC + 8;
		break;
	case OP_COP1:
		switch (inst.RType.rs) {
		case OP_BC:
			cc = (inst.RType.rt & COPz_BC_CC_MASK) >>
			    COPz_BC_CC_SHIFT;
			if ((inst.RType.rt & COPz_BC_TF_MASK) == COPz_BC_TRUE)
				condition = fsr & FPCSR_CONDVAL(cc);
			else
				condition = !(fsr & FPCSR_CONDVAL(cc));
			if (condition)
				retAddr = GetBranchDest(instPC, inst);
			else
				retAddr = instPC + 8;
			break;
		default:
			retAddr = instPC + 4;
		}
		break;
	default:
		retAddr = instPC + 4;
	}

	return (register_t)retAddr;
#undef	GetBranchDest
}

#ifdef PTRACE

int
ptrace_read_insn(struct proc *p, vaddr_t va, uint32_t *insn)
{
	struct iovec iov;
	struct uio uio;

	iov.iov_base = (caddr_t)insn;
	iov.iov_len = sizeof(uint32_t);
	uio.uio_iov = &iov;
	uio.uio_iovcnt = 1;
	uio.uio_offset = (off_t)va;
	uio.uio_resid = sizeof(uint32_t);
	uio.uio_segflg = UIO_SYSSPACE;
	uio.uio_rw = UIO_READ;
	uio.uio_procp = curproc;
	return process_domem(curproc, p->p_p, &uio, PT_READ_I);
}

int
ptrace_write_insn(struct proc *p, vaddr_t va, uint32_t insn)
{
	struct iovec iov;
	struct uio uio;

	iov.iov_base = (caddr_t)&insn;
	iov.iov_len = sizeof(uint32_t);
	uio.uio_iov = &iov;
	uio.uio_iovcnt = 1;
	uio.uio_offset = (off_t)va;
	uio.uio_resid = sizeof(uint32_t);
	uio.uio_segflg = UIO_SYSSPACE;
	uio.uio_rw = UIO_WRITE;
	uio.uio_procp = curproc;
	return process_domem(curproc, p->p_p, &uio, PT_WRITE_I);
}

/*
 * This routine is called by procxmt() to single step one instruction.
 * We do this by storing a break instruction after the current instruction,
 * resuming execution, and then restoring the old instruction.
 */
int
process_sstep(struct proc *p, int sstep)
{
	struct trapframe *locr0 = p->p_md.md_regs;
	int rc;
	uint32_t curinstr;
	vaddr_t va;

	if (sstep == 0) {
		/* clear the breakpoint */
		if (p->p_md.md_ss_addr != 0) {
			rc = ptrace_write_insn(p, p->p_md.md_ss_addr,
			    p->p_md.md_ss_instr);
#ifdef DIAGNOSTIC
			if (rc != 0)
				printf("WARNING: %s (%d): can't restore "
				    "instruction at %p: %08x\n",
				    p->p_p->ps_comm, p->p_p->ps_pid,
				    (void *)p->p_md.md_ss_addr,
				    p->p_md.md_ss_instr);
#endif
			p->p_md.md_ss_addr = 0;
		} else
			rc = 0;
		return rc;
	}

	/* read current instruction */
	rc = ptrace_read_insn(p, locr0->pc, &curinstr);
	if (rc != 0)
		return rc;

	/* compute next address after current location */
	if (curinstr != 0 /* nop */)
		va = (vaddr_t)MipsEmulateBranch(locr0,
		    locr0->pc, locr0->fsr, curinstr);
	else
		va = locr0->pc + 4;
#ifdef DIAGNOSTIC
	/* should not happen */
	if (p->p_md.md_ss_addr != 0) {
		printf("WARNING: %s (%d): breakpoint request "
		    "at %p, already set at %p\n",
		    p->p_p->ps_comm, p->p_p->ps_pid, (void *)va,
		    (void *)p->p_md.md_ss_addr);
		return EFAULT;
	}
#endif

	/* read next instruction */
	rc = ptrace_read_insn(p, va, &p->p_md.md_ss_instr);
	if (rc != 0)
		return rc;

	/* replace with a breakpoint instruction */
	rc = ptrace_write_insn(p, va, BREAK_SSTEP);
	if (rc != 0)
		return rc;

	p->p_md.md_ss_addr = va;

#ifdef DEBUG
	printf("%s (%d): breakpoint set at %p: %08x (pc %p %08x)\n",
		p->p_p->ps_comm, p->p_p->ps_pid, (void *)p->p_md.md_ss_addr,
		p->p_md.md_ss_instr, (void *)locr0->pc, curinstr);
#endif
	return 0;
}

#endif /* PTRACE */

#if defined(DDB) || defined(DEBUG)
#define MIPS_JR_RA	0x03e00008	/* instruction code for jr ra */

/* forward */
#if !defined(DDB)
const char *fn_name(vaddr_t);
#endif
void stacktrace_subr(struct trapframe *, int, int (*)(const char*, ...));

/*
 * Print a stack backtrace.
 */
void
stacktrace(struct trapframe *regs)
{
	stacktrace_subr(regs, 6, printf);
}

#ifdef CPU_R8000
#define	VALID_ADDRESS(va) \
	(((va) >= VM_MIN_KERNEL_ADDRESS && (va) < VM_MAX_KERNEL_ADDRESS) || \
	 IS_XKPHYS(va))
#else
#define	VALID_ADDRESS(va) \
	(((va) >= VM_MIN_KERNEL_ADDRESS && (va) < VM_MAX_KERNEL_ADDRESS) || \
	 IS_XKPHYS(va) || ((va) >= CKSEG0_BASE && (va) < CKSEG1_BASE))
#endif

void
stacktrace_subr(struct trapframe *regs, int count,
    int (*pr)(const char*, ...))
{
	vaddr_t pc, sp, ra, va, subr;
	register_t a0, a1, a2, a3;
	uint32_t instr, mask;
	InstFmt i;
	int more, stksize;
	extern char k_intr[];
	extern char k_general[];
#ifdef DDB
	db_expr_t diff;
	Elf_Sym *sym;
	char *symname;
#endif

	/* get initial values from the exception frame */
	sp = (vaddr_t)regs->sp;
	pc = (vaddr_t)regs->pc;
	ra = (vaddr_t)regs->ra;		/* May be a 'leaf' function */
	a0 = regs->a0;
	a1 = regs->a1;
	a2 = regs->a2;
	a3 = regs->a3;

/* Jump here when done with a frame, to start a new one */
loop:
#ifdef DDB
	symname = NULL;
#endif
	subr = 0;
	stksize = 0;

	if (count-- == 0) {
		ra = 0;
		goto end;
	}

	/* check for bad SP: could foul up next frame */
	if (sp & 3 || !VALID_ADDRESS(sp)) {
		(*pr)("SP %p: not in kernel\n", sp);
		ra = 0;
		goto end;
	}

	/* check for bad PC */
	if (pc & 3 || !VALID_ADDRESS(pc)) {
		(*pr)("PC %p: not in kernel\n", pc);
		ra = 0;
		goto end;
	}

#ifdef DDB
	/*
	 * Dig out the function from the symbol table.
	 * Watch out for function tail optimizations.
	 */
	sym = db_search_symbol(pc, DB_STGY_ANY, &diff);
	if (sym != NULL && diff == 0) {
		instr = kdbpeek(pc - 2 * sizeof(int));
		i.word = instr;
		if (i.JType.op == OP_JAL) {
			sym = db_search_symbol(pc - sizeof(int),
			    DB_STGY_ANY, &diff);
			if (sym != NULL && diff != 0)
				diff += sizeof(int);
		}
	}
	if (sym != NULL) {
		db_symbol_values(sym, &symname, 0);
		subr = pc - (vaddr_t)diff;
	}
#endif

	/*
	 * Find the beginning of the current subroutine by scanning backwards
	 * from the current PC for the end of the previous subroutine.
	 */
	if (!subr) {
		va = pc - sizeof(int);
		while ((instr = kdbpeek(va)) != MIPS_JR_RA)
			va -= sizeof(int);
		va += 2 * sizeof(int);	/* skip back over branch & delay slot */
		/* skip over nulls which might separate .o files */
		while ((instr = kdbpeek(va)) == 0)
			va += sizeof(int);
		subr = va;
	}

	/*
	 * Jump here for locore entry points for which the preceding
	 * function doesn't end in "j ra"
	 */
	/* scan forwards to find stack size and any saved registers */
	stksize = 0;
	more = 3;
	mask = 0;
	for (va = subr; more; va += sizeof(int),
	    more = (more == 3) ? 3 : more - 1) {
		/* stop if hit our current position */
		if (va >= pc)
			break;
		instr = kdbpeek(va);
		i.word = instr;
		switch (i.JType.op) {
		case OP_SPECIAL:
			switch (i.RType.func) {
			case OP_JR:
			case OP_JALR:
				more = 2; /* stop after next instruction */
				break;

			case OP_SYSCALL:
			case OP_BREAK:
				more = 1; /* stop now */
			};
			break;

		case OP_BCOND:
		case OP_J:
		case OP_JAL:
		case OP_BEQ:
		case OP_BNE:
		case OP_BLEZ:
		case OP_BGTZ:
			more = 2; /* stop after next instruction */
			break;

		case OP_COP0:
		case OP_COP1:
		case OP_COP2:
		case OP_COP3:
			switch (i.RType.rs) {
			case OP_BC:
				more = 2; /* stop after next instruction */
			};
			break;

		case OP_SD:
			/* look for saved registers on the stack */
			if (i.IType.rs != SP)
				break;
			/* only restore the first one */
			if (mask & (1 << i.IType.rt))
				break;
			mask |= (1 << i.IType.rt);
			switch (i.IType.rt) {
			case A0:
				a0 = kdbpeekd(sp + (int16_t)i.IType.imm);
				break;
			case A1:
				a1 = kdbpeekd(sp + (int16_t)i.IType.imm);
				break;
			case A2:
				a2 = kdbpeekd(sp + (int16_t)i.IType.imm);
				break;
			case A3:
				a3 = kdbpeekd(sp + (int16_t)i.IType.imm);
				break;
			case RA:
				ra = kdbpeekd(sp + (int16_t)i.IType.imm);
				break;
			}
			break;

		case OP_DADDI:
		case OP_DADDIU:
			/* look for stack pointer adjustment */
			if (i.IType.rs != SP || i.IType.rt != SP)
				break;
			stksize = -((int16_t)i.IType.imm);
		}
	}

#ifdef DDB
	if (symname == NULL)
		(*pr)("%p ", subr);
	else
		(*pr)("%s+%p ", symname, diff);
#else
	(*pr)("%s+%p ", fn_name(subr), pc - subr);
#endif
	(*pr)("(%llx,%llx,%llx,%llx) ", a0, a1, a2, a3);
	(*pr)(" ra %p sp %p, sz %d\n", ra, sp, stksize);

	if (subr == (vaddr_t)k_intr || subr == (vaddr_t)k_general) {
		if (subr == (vaddr_t)k_general)
			(*pr)("(KERNEL TRAP)\n");
		else
			(*pr)("(KERNEL INTERRUPT)\n");
		sp = *(register_t *)sp;
		pc = ((struct trapframe *)sp)->pc;
		ra = ((struct trapframe *)sp)->ra;
		sp = ((struct trapframe *)sp)->sp;
		goto loop;
	}

end:
	if (ra) {
		extern void *kernel_text;
		extern void *etext;

		if (pc == ra && stksize == 0)
			(*pr)("stacktrace: loop!\n");
		else if (ra < (vaddr_t)&kernel_text || ra > (vaddr_t)&etext)
			(*pr)("stacktrace: ra corrupted!\n");
		else {
			pc = ra;
			sp += stksize;
			ra = 0;
			goto loop;
		}
	} else {
		if (curproc)
			(*pr)("User-level: pid %d\n", curproc->p_p->ps_pid);
		else
			(*pr)("User-level: curproc NULL\n");
	}
}

#undef	VALID_ADDRESS

#if !defined(DDB)
/*
 * Functions ``special'' enough to print by name
 */
#ifdef __STDC__
#define Name(_fn)  { (void*)_fn, # _fn }
#else
#define Name(_fn) { _fn, "_fn"}
#endif
static const struct { void *addr; const char *name;} names[] = {
	Name(trap),
	{ 0, NULL }
};

/*
 * Map a function address to a string name, if known; or a hex string.
 */
const char *
fn_name(vaddr_t addr)
{
	static char buf[19];
	int i = 0;

	for (i = 0; names[i].name != NULL; i++)
		if (names[i].addr == (void*)addr)
			return (names[i].name);
	snprintf(buf, sizeof(buf), "%p", addr);
	return (buf);
}
#endif	/* !DDB */

#endif /* DDB || DEBUG */

#ifdef FPUEMUL
/*
 * Set up a successful branch emulation.
 * The delay slot instruction is copied to a reserved page, followed by a
 * trap instruction to get control back, and resume at the branch
 * destination.
 */
int
fpe_branch_emulate(struct proc *p, struct trapframe *tf, uint32_t insn,
    vaddr_t dest)
{
	struct vm_map *map = &p->p_vmspace->vm_map;
	InstFmt inst;
	int rc;

	/*
	 * Check the delay slot instruction: since it will run as a
	 * non-delay slot instruction, we want to reject branch instructions
	 * (which behaviour, when in a delay slot, is undefined anyway).
	 */

	inst = *(InstFmt *)&insn;
	rc = 0;
	switch ((int)inst.JType.op) {
	case OP_SPECIAL:
		switch ((int)inst.RType.func) {
		case OP_JR:
		case OP_JALR:
			rc = EINVAL;
			break;
		}
		break;
	case OP_BCOND:
		switch ((int)inst.IType.rt) {
		case OP_BLTZ:
		case OP_BLTZL:
		case OP_BLTZAL:
		case OP_BLTZALL:
		case OP_BGEZ:
		case OP_BGEZL:
		case OP_BGEZAL:
		case OP_BGEZALL:
			rc = EINVAL;
			break;
		}
		break;
	case OP_J:
	case OP_JAL:
	case OP_BEQ:
	case OP_BEQL:
	case OP_BNE:
	case OP_BNEL:
	case OP_BLEZ:
	case OP_BLEZL:
	case OP_BGTZ:
	case OP_BGTZL:
		rc = EINVAL;
		break;
	case OP_COP1:
		if (inst.RType.rs == OP_BC)	/* oh the irony */
			rc = EINVAL;
		break;
	}

	if (rc != 0) {
#ifdef DEBUG
		printf("%s: bogus delay slot insn %08x\n", __func__, insn);
#endif
		return rc;
	}

	/*
	 * Temporarily change protection over the page used to relocate
	 * the delay slot, and fault it in.
	 */

	rc = uvm_map_protect(map, p->p_md.md_fppgva,
	    p->p_md.md_fppgva + PAGE_SIZE, PROT_MASK, FALSE);
	if (rc != 0) {
#ifdef DEBUG
		printf("%s: uvm_map_protect on %p failed: %d\n",
		    __func__, (void *)p->p_md.md_fppgva, rc);
#endif
		return rc;
	}
	KERNEL_LOCK();
	rc = uvm_fault_wire(map, p->p_md.md_fppgva,
	    p->p_md.md_fppgva + PAGE_SIZE, PROT_MASK);
	KERNEL_UNLOCK();
	if (rc != 0) {
#ifdef DEBUG
		printf("%s: uvm_fault_wire on %p failed: %d\n",
		    __func__, (void *)p->p_md.md_fppgva, rc);
#endif
		goto err2;
	}

	rc = copyout(&insn, (void *)p->p_md.md_fppgva, sizeof insn);
	if (rc != 0) {
#ifdef DEBUG
		printf("%s: copyout %p failed %d\n",
		    __func__, (void *)p->p_md.md_fppgva, rc);
#endif
		goto err;
	}
	insn = BREAK_FPUEMUL;
	rc = copyout(&insn, (void *)(p->p_md.md_fppgva + 4), sizeof insn);
	if (rc != 0) {
#ifdef DEBUG
		printf("%s: copyout %p failed %d\n",
		    __func__, (void *)(p->p_md.md_fppgva + 4), rc);
#endif
		goto err;
	}

	(void)uvm_map_protect(map, p->p_md.md_fppgva,
	    p->p_md.md_fppgva + PAGE_SIZE, PROT_READ | PROT_EXEC, FALSE);
	p->p_md.md_fpbranchva = dest;
	p->p_md.md_fpslotva = (vaddr_t)tf->pc + 4;
	p->p_md.md_flags |= MDP_FPUSED;
	tf->pc = p->p_md.md_fppgva;
	pmap_proc_iflush(p->p_p, tf->pc, 2 * 4);

	return 0;

err:
	KERNEL_LOCK();
	uvm_fault_unwire(map, p->p_md.md_fppgva, p->p_md.md_fppgva + PAGE_SIZE);
	KERNEL_UNLOCK();
err2:
	(void)uvm_map_protect(map, p->p_md.md_fppgva,
	    p->p_md.md_fppgva + PAGE_SIZE, PROT_NONE, FALSE);
	return rc;
}
#endif
@


1.129
log
@Prefer copyin32() to copyin() when fetching instructions
from user space. This improves performance slightly.

Discussed with miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.128 2017/08/26 15:21:48 visa Exp $	*/
d664 2
a665 1
			if ((p->p_md.md_flags & MDP_FPUSED) != 0 &&
d819 4
a822 5
#ifdef FPUEMUL
		MipsFPTrap(trapframe);
#else
		enable_fpu(p);
#endif
d898 1
a898 1
	if ((p->p_md.md_flags & MDP_FPUSED) != 0 &&
@


1.128
log
@Use copyin32() instead of a direct memory load when fetching a branch
instruction for branch emulation. This ensures the userspace memory
access is properly guarded and that TLB faults are handled.

In order not to complicate the interface of MipsEmulateBranch(), each
caller now has to provide the branch instruction for the function.

Feedback from miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.127 2017/07/22 18:33:51 visa Exp $	*/
d609 5
a613 1
		copyin(va, &instr, sizeof(int32_t));
d730 5
a734 1
		copyin(va, &instr, sizeof(int32_t));
d779 1
a779 1
		if (copyin32((void *)va, &inst.word) != 0) {
@


1.127
log
@Rename variables for clarity.

It does not seem necessary to provide initial value for `sicode'.
When `signal' gets set, `sicode' is set as well.

OK deraadt@@, kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.126 2017/07/22 16:44:15 visa Exp $	*/
d468 1
d479 8
a486 1
		if (trapframe->cause & CR_BR_DELAY)
d488 2
a489 2
			    trapframe->pc, 0, 0);
		else
d589 1
d591 2
a592 2
		u_int32_t instr;
		struct trapframe *locr0 = p->p_md.md_regs;
d596 1
a596 1
		if (trapframe->cause & CR_BR_DELAY)
d599 9
d618 1
a618 1
				    trapframe->pc, 0, 0);
d628 1
a628 1
				    trapframe->pc, 0, 0);
d706 1
d708 2
a709 2
		u_int32_t instr;
		struct trapframe *locr0 = p->p_md.md_regs;
d713 1
a713 1
		if (trapframe->cause & CR_BR_DELAY)
d715 10
d730 1
a730 1
			    trapframe->pc, 0, 0);
d753 1
d758 1
a758 1
		if (trapframe->cause & CR_BR_DELAY)
d761 9
d788 1
a788 1
				    trapframe->pc, 0, 0);
d993 1
a993 4
	if (curinst != 0)
		inst = *(InstFmt *)&curinst;
	else
		inst = *(InstFmt *)instPC;
@


1.126
log
@Bring SIGBUS and SIGSEGV handling better in line with the other
architectures.

OK kettenis@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.125 2017/07/03 16:37:07 visa Exp $	*/
a269 1
	int i;
d274 1
a274 1
	int typ = 0;
d438 2
a439 2
		i = SIGSEGV;
		typ = SEGV_MAPERR;
d441 1
a441 1
			typ = SEGV_ACCERR;
d443 2
a444 2
			i = SIGBUS;
			typ = BUS_OBJERR;
d452 2
a453 2
		i = SIGBUS;
		typ = BUS_ADRALN;
d458 2
a459 2
		i = SIGBUS;
		typ = BUS_OBJERR;
d468 1
a468 1
		int numsys, error;
d500 1
a500 1
			i = callp->sy_argsize / sizeof(register_t);
d504 1
a504 1
			if (i > 3) {
d509 1
a509 1
				if (i > 7)
d521 1
a521 1
			i = callp->sy_narg;
d526 1
a526 1
			if (i > 4) {
d595 2
a596 2
			i = SIGFPE;
			typ = FPE_FLTSUB;
d605 2
a606 2
			i = SIGFPE;
			typ = FPE_INTDIV;
d629 1
a629 1
				typ = TRAP_BRKPT;
d631 1
a631 1
				typ = TRAP_TRACE;
d633 1
a633 1
			i = SIGTRAP;
d665 2
a666 2
			typ = TRAP_TRACE;
			i = SIGTRAP;
d681 2
a682 2
		i = SIGTRAP;
		typ = TRAP_BRKPT;
d711 2
a712 2
			i = SIGFPE;
			typ = FPE_INTDIV;
d714 2
a715 2
			i = SIGEMT;	/* Stuff it with something for now */
			typ = 0;
d733 2
a734 2
			i = SIGBUS;
			typ = BUS_OBJERR;
d755 2
a756 2
		i = SIGILL;
		typ = ILL_ILLOPC;
d767 2
a768 2
			i = SIGILL;	/* only FPU instructions allowed */
			typ = ILL_ILLOPC;
d788 2
a789 2
		i = SIGFPE;
		typ = FPE_FLTOVF;
d860 1
a860 1
	trapsignal(p, i, ucode, typ, sv);
@


1.125
log
@Use copyin32() instead of copyin() in RDHWR emulation.
This reduces emulation time about 5%.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.124 2017/05/30 15:39:04 mpi Exp $	*/
d423 3
a425 6
		if ((caddr_t)va >= vm->vm_maxsaddr) {
			if (rv == 0)
				uvm_grow(p, va);
			else if (rv == EACCES)
				rv = EFAULT;
		}
d441 6
@


1.124
log
@Kill db_sym_t.

ok deraadt@@, kettenis@@, jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.123 2017/04/20 15:42:26 visa Exp $	*/
d730 1
a730 1
		if (copyin(va, &inst, sizeof(inst)) != 0) {
@


1.123
log
@Make TCB address available to userspace via the UserLocal register.
This lets programs get the address without a system call on OCTEON II
and later.

Add UserLocal load emulation for systems that do not implement
the RDHWR instruction or the UserLocal register.

OK guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.122 2017/01/21 05:42:03 guenther Exp $	*/
d1209 1
a1209 1
	db_sym_t sym;
@


1.122
log
@p_comm is the process's command and isn't per thread, so move it from
struct proc to struct process.

ok deraadt@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.121 2016/10/19 08:28:20 guenther Exp $	*/
d71 1
d719 34
d756 1
@


1.121
log
@Change pmap_proc_iflush() to take a process instead of a proc
powerpc: rename second argument of pmap_proc_iflush() to match other archs

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.120 2016/10/19 08:23:37 guenther Exp $	*/
d617 1
a617 1
				    p->p_comm, p->p_p->ps_pid,
d1078 1
a1078 1
				    p->p_comm, p->p_p->ps_pid,
d1104 1
a1104 1
		    p->p_comm, p->p_p->ps_pid, (void *)va,
d1124 1
a1124 1
		p->p_comm, p->p_p->ps_pid, (void *)p->p_md.md_ss_addr,
@


1.120
log
@The first argument to process_domem() and its uio_procp should be curproc

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.119 2016/10/08 05:49:09 guenther Exp $	*/
d1537 1
a1537 1
	pmap_proc_iflush(p, tf->pc, 2 * 4);
@


1.119
log
@Various printf claim to report the PID, so actually report that and not the TID

Build testing assistance from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.118 2016/08/16 13:03:58 visa Exp $	*/
d1034 2
a1035 2
	uio.uio_procp = p;
	return process_domem(p, p, &uio, PT_READ_I);
d1052 2
a1053 2
	uio.uio_procp = p;
	return process_domem(p, p, &uio, PT_WRITE_I);
@


1.118
log
@Remove RM7000/RM9000-specific performance counter code. It originates
from PMON2000 and has not been enabled on OpenBSD.

Suggested by and ok miod@@ (after seeing a quad_t cleanup patch of mine)
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.117 2016/08/14 08:23:52 visa Exp $	*/
d617 1
a617 1
				    p->p_comm, p->p_pid,
d1078 1
a1078 1
				    p->p_comm, p->p_pid,
d1104 2
a1105 1
		    p->p_comm, p->p_pid, (void *)va, (void *)p->p_md.md_ss_addr);
d1124 1
a1124 1
		p->p_comm, p->p_pid, (void *)p->p_md.md_ss_addr,
d1375 1
a1375 1
			(*pr)("User-level: pid %d\n", curproc->p_pid);
@


1.117
log
@Utilize the TLB Execute-Inhibit bit with non-executable mappings on CPUs
that support the Execute-Inhibit exception. This makes user space W^X
effective on Octeon Plus and later Octeon versions.

Feedback from miod@@, thanks!
No objection from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.116 2016/03/06 19:42:27 mpi Exp $	*/
a72 2
#include <mips64/rm7000.h>

a677 6
#ifdef RM7K_PERFCNTR
		if (rm7k_watchintr(trapframe)) {
			/* Return to user, don't add any more overhead */
			return;
		}
#endif
a700 11
#ifdef RM7K_PERFCNTR
		if (instr == 0x040c0000) { /* Performance cntr trap */
			int result;

			result = rm7k_perfcntr(trapframe->a0, trapframe->a1,
						trapframe->a2, trapframe->a3);
			locr0->v0 = -result;
			/* Return to user, don't add any more overhead */
			return;
		} else
#endif
@


1.116
log
@Rename mips64's trap_frame into trapframe.

For coherency with other archs and in order to use it in MI code.

ok visa@@, tobiasu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.115 2016/03/01 11:56:00 mpi Exp $	*/
d307 19
a325 1
		ftype = (type == T_TLB_ST_MISS) ? PROT_WRITE : PROT_READ;
d363 12
a374 1
	case T_TLB_LD_MISS+T_USER:
d378 1
@


1.115
log
@DB_SYM_NULL -> NULL.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.114 2016/02/27 13:08:07 mpi Exp $	*/
d124 1
a124 1
void	stacktrace(struct trap_frame *);
d134 3
a136 3
extern void interrupt(struct trap_frame *);
void	itsa(struct trap_frame *, struct cpu_info *, struct proc *, int);
void	trap(struct trap_frame *);
d165 1
a165 1
trap(struct trap_frame *trapframe)
d268 1
a268 1
itsa(struct trap_frame *trapframe, struct cpu_info *ci, struct proc *p,
d433 1
a433 1
		struct trap_frame *locr0 = p->p_md.md_regs;
d552 1
a552 1
		struct trap_frame *locr0 = p->p_md.md_regs;
d665 1
a665 1
		struct trap_frame *locr0 = p->p_md.md_regs;
d819 1
a819 1
	struct trap_frame *trapframe;
d893 1
a893 1
MipsEmulateBranch(struct trap_frame *tf, vaddr_t instPC, uint32_t fsr,
d1053 1
a1053 1
	struct trap_frame *locr0 = p->p_md.md_regs;
d1127 1
a1127 1
void stacktrace_subr(struct trap_frame *, int, int (*)(const char*, ...));
d1133 1
a1133 1
stacktrace(struct trap_frame *regs)
d1149 1
a1149 1
stacktrace_subr(struct trap_frame *regs, int count,
d1340 3
a1342 3
		pc = ((struct trap_frame *)sp)->pc;
		ra = ((struct trap_frame *)sp)->ra;
		sp = ((struct trap_frame *)sp)->sp;
d1412 1
a1412 1
fpe_branch_emulate(struct proc *p, struct trap_frame *tf, uint32_t insn,
@


1.114
log
@Rename kdb_trap() into db_ktrap().

The goal is to include it in the list of functions that must not be
instrumented.  All ddb(8) functions should be in this list and have
their names start with 'db_'.

ok visa@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.113 2016/02/01 16:15:18 visa Exp $	*/
d1207 1
a1207 1
	if (sym != DB_SYM_NULL && diff == 0) {
d1213 1
a1213 1
			if (sym != DB_SYM_NULL && diff != 0)
d1217 1
a1217 1
	if (sym != DB_SYM_NULL) {
@


1.113
log
@Move modify bit emulation into pmap.c to gather pmap C code in one place.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.112 2016/01/10 10:22:56 visa Exp $	*/
d130 1
a130 1
extern int kdb_trap(int, db_regs_t *);
d540 1
a540 1
		kdb_trap(type, trapframe);
d791 1
a791 1
		kdb_trap(type, trapframe);
@


1.112
log
@Back out the MP pmap diff for rework. The code does not work on
non-PMAP_DIRECT systems due to lock recursion.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.111 2015/12/31 04:25:51 visa Exp $	*/
d284 2
a285 12
			pt_entry_t *pte, entry;
			paddr_t pa;
			vm_page_t pg;

			pte = kvtopte(trapframe->badvaddr);
			entry = *pte;
#ifdef DIAGNOSTIC
			if (!(entry & PG_V) || (entry & PG_M))
				panic("trap: ktlbmod: invalid pte");
#endif
			if (pmap_is_page_ro(pmap_kernel(),
			    trunc_page(trapframe->badvaddr), entry)) {
a290 11
			entry |= PG_M;
			*pte = entry;
			KERNEL_LOCK();
			pmap_update_kernel_page(trapframe->badvaddr & ~PGOFSET,
			    entry);
			pa = pfn_to_pad(entry);
			pg = PHYS_TO_VM_PAGE(pa);
			if (pg == NULL)
				panic("trap: ktlbmod: unmanaged page");
			pmap_set_modify(pg);
			KERNEL_UNLOCK();
d296 2
a297 16
	    {
		pt_entry_t *pte, entry;
		paddr_t pa;
		vm_page_t pg;
		pmap_t pmap = p->p_vmspace->vm_map.pmap;

		if (!(pte = pmap_segmap(pmap, trapframe->badvaddr)))
			panic("trap: utlbmod: invalid segmap");
		pte += uvtopte(trapframe->badvaddr);
		entry = *pte;
#ifdef DIAGNOSTIC
		if (!(entry & PG_V) || (entry & PG_M))
			panic("trap: utlbmod: invalid pte");
#endif
		if (pmap_is_page_ro(pmap,
		    trunc_page(trapframe->badvaddr), entry)) {
a302 11
		entry |= PG_M;
		*pte = entry;
		KERNEL_LOCK();
		pmap_update_user_page(pmap, (trapframe->badvaddr & ~PGOFSET), 
		    entry);
		pa = pfn_to_pad(entry);
		pg = PHYS_TO_VM_PAGE(pa);
		if (pg == NULL)
			panic("trap: utlbmod: unmanaged page");
		pmap_set_modify(pg);
		KERNEL_UNLOCK();
a303 1
	    }
@


1.111
log
@Protect mips64 pmap and pvlist structs with a mutex to make pmap
operations MP-safe. Tested on octeon and sgi (IP27, IP30).

Feedback from kettenis@@ long ago
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.110 2015/09/27 09:11:11 miod Exp $	*/
a287 1
			mtx_enter(&pmap_kernel()->pm_pte_mtx);
d290 1
a290 9
#ifdef MULTIPROCESSOR
			/* Another CPU might have changed the mapping. */
			if (!(entry & PG_V) || (entry & PG_M)) {
				pmap_update_kernel_page(
				    trapframe->badvaddr & ~PGOFSET, entry);
				mtx_leave(&pmap_kernel()->pm_pte_mtx);
				return;
			}
#else
a295 1
				mtx_leave(&pmap_kernel()->pm_pte_mtx);
d303 1
d311 1
a311 1
			mtx_leave(&pmap_kernel()->pm_pte_mtx);
a322 1
		mtx_enter(&pmap->pm_pte_mtx);
d327 1
a327 9
#ifdef MULTIPROCESSOR
		/* Another CPU might have changed the mapping. */
		if (!(entry & PG_V) || (entry & PG_M)) {
			pmap_update_user_page(pmap,
			    (trapframe->badvaddr & ~PGOFSET), entry);
			mtx_leave(&pmap->pm_pte_mtx);
			return;
		}
#else
a332 1
			mtx_leave(&pmap->pm_pte_mtx);
d340 1
d348 1
a348 1
		mtx_leave(&pmap->pm_pte_mtx);
@


1.110
log
@On R8000, make trap() behave closer to interrupt() when servicing a real
interrupt by not invoking refreshcreds(), but closer to itsa() when servicing
a trap-reported-as-interrupt by invoking userret() in that case.
No change on !defined(CPU_R8000) kernels.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.109 2015/08/19 16:40:10 visa Exp $	*/
d288 1
d291 9
a299 1
#ifdef DIAGNOSTIC
d305 1
a312 1
			KERNEL_LOCK();
d320 1
a320 1
			KERNEL_UNLOCK();
d332 1
d337 9
a345 1
#ifdef DIAGNOSTIC
d351 1
a358 1
		KERNEL_LOCK();
d366 1
a366 1
		KERNEL_UNLOCK();
@


1.109
log
@Prevent mips64 FPU emulation from corrupting the page queues
in MP systems.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.108 2015/08/03 13:32:15 visa Exp $	*/
a208 3
	if (type & T_USER)
		refreshcreds(p);

a217 8
		/*
		 * Similar reality check as done in interrupt(), in case
		 * an interrupt occured between a write to COP_0_STATUS_REG
		 * and it taking effect.
		 */
		if (!ISSET(trapframe->sr, SR_INT_ENAB))
			return;

d224 1
d229 3
a234 2
		if (trapframe->cause & CR_INT_MASK)
			interrupt(trapframe);
d236 17
a252 2
		return;	/* no userret */
	} else
d254 5
a258 1
		itsa(trapframe, ci, p, type);
@


1.108
log
@On mips64, enable IPIs before calling refreshcreds() in trap(), to
avoid a potential deadlock.

ok miod@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.107 2015/07/19 17:00:39 visa Exp $	*/
d659 1
d662 1
d1567 1
d1569 1
@


1.107
log
@Add proper kernel locking in the fpe_branch_emulate() function, to
prevent race conditions that could corrupt amap entries, among other
things.

ok miod@@ pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.106 2015/06/05 16:35:24 deraadt Exp $	*/
d184 1
a184 1
	if (USERMODE(trapframe->sr)) {
a185 2
		refreshcreds(p);
	}
d208 3
@


1.106
log
@trunc_page() generally.... succeeds at clearing the page offset
bits the first time it is called, so don't do it again.
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.105 2015/02/08 05:40:48 uebayasi Exp $	*/
d1523 1
d1526 1
@


1.105
log
@ANSI'fy.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d355 1
a355 1
			rv = uvm_fault(kernel_map, trunc_page(va), 0, ftype);
@


1.104
log
@Fix stack trace of tail calls.  From NetBSD.  OK miod@@
@
text
@d147 1
a147 1
ast()
d850 1
a850 2
child_return(arg)
	void *arg;
a1167 1
	struct trap_frame *regs;
@


1.103
log
@Give up tracing if RA is corrupted.  OK miod@@
@
text
@d1168 1
a1168 1
stacktrace(regs)
d1243 12
a1254 2
	db_symbol_values(sym, &symname, 0);
	if (sym != DB_SYM_NULL)
d1256 1
@


1.102
log
@Replace a plethora of historical protection options with just
PROT_NONE, PROT_READ, PROT_WRITE, and PROT_EXEC from mman.h.
PROT_MASK is introduced as the one true way of extracting those bits.
Remove UVM_ADV_* wrapper, using the standard names.
ok doug guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.101 2014/09/30 06:51:58 jmatthew Exp $	*/
d1373 3
d1378 2
@


1.101
log
@implement atomic operations using ll/sc, and convert rw_cas and callers of the
pre-existing atomics to match.

tested on sgi (octane) and octeon (erl)
ok miod@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.100 2014/08/18 17:23:06 miod Exp $	*/
d286 1
a286 1
				ftype = VM_PROT_WRITE;
d323 1
a323 1
			ftype = VM_PROT_WRITE;
d343 1
a343 1
		ftype = (type == T_TLB_ST_MISS) ? VM_PROT_WRITE : VM_PROT_READ;
d382 1
a382 1
		ftype = VM_PROT_READ;
d387 1
a387 1
		ftype = VM_PROT_WRITE;
d456 1
a456 1
		ucode = 0;		/* XXX should be VM_PROT_something */
d462 1
a462 1
		ucode = 0;		/* XXX should be VM_PROT_something */
d662 1
a662 1
				    UVM_PROT_NONE, FALSE);
d1501 1
a1501 1
	    p->p_md.md_fppgva + PAGE_SIZE, UVM_PROT_RWX, FALSE);
d1510 1
a1510 1
	    p->p_md.md_fppgva + PAGE_SIZE, UVM_PROT_RWX);
d1538 1
a1538 1
	    p->p_md.md_fppgva + PAGE_SIZE, UVM_PROT_RX, FALSE);
d1551 1
a1551 1
	    p->p_md.md_fppgva + PAGE_SIZE, UVM_PROT_NONE, FALSE);
@


1.100
log
@Sigh, ignoring instruction fetch bus errors for the kernel code should not
depend upon the address being at the beginning of a cache line, for we may
arrive in the middle of a line thanks to a branch. Noticed the hard way...
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.99 2014/08/17 11:11:34 miod Exp $	*/
d57 1
d154 1
a154 1
	atomic_add_int(&uvmexp.softs, 1);
d183 1
a183 1
		atomic_add_int(&uvmexp.traps, 1);
d479 1
a479 1
		atomic_add_int(&uvmexp.syscalls, 1);
@


1.99
log
@On kernels compiled with R10000 support, ignore (by simply returning)
`bus error upon instruction fetch' exceptions where the faulting address is
in the kernel, and at the very beginning of an I$ cache line.
(I've experienced these on an R16000 Fuel since several months already)
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.98 2014/06/12 20:52:15 kettenis Exp $	*/
d796 1
a796 2
		 * is in the kernel and at the beginning of an I$ cache
		 * line.
d806 1
a806 2
		if ((va & (/* R10K_L1I_LINE - 1 */ 64UL - 1)) == 0 &&
		    va > (vaddr_t)&kernel_text && va < (vaddr_t)&etext)
@


1.98
log
@Grab the kernel lock before cleaning up single-step breakpoints.  Should
prevent mips64 from hitting the same problem as found by tobiasu@@ on hppa.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.97 2014/05/11 00:12:44 guenther Exp $	*/
d786 27
@


1.97
log
@Move the increment of uvmexp.softs back to the caller of mi_ast():
it needs to be done atomicly on some MP archs and we don't have
atomic_add_int() everywhere yet.  Also, mi_ast() was meant to be inline.

noted by miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.96 2014/05/11 00:05:38 guenther Exp $	*/
d630 1
d632 1
@


1.96
log
@Pull in <sys/user.h> before <sys/syscall*.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.95 2014/05/10 22:25:16 jasper Exp $	*/
d153 1
@


1.95
log
@various format string fixes and remove -Wno-format from octeon

feedback/ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.94 2014/05/10 05:33:00 guenther Exp $	*/
d52 1
a54 1
#include <sys/user.h>
@


1.94
log
@Factor out the common ast bits into mi_ast()

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.93 2014/04/18 11:51:17 guenther Exp $	*/
d624 2
a625 1
				    p->p_md.md_ss_addr, p->p_md.md_ss_instr);
d760 1
a760 1
		printf("FPU Trap: PC %x CR %x SR %x\n",
d792 2
a793 1
		    trapframe->pc, trapframe->ra, trapframe->badvaddr);
d1074 2
a1075 1
				    p->p_md.md_ss_addr, p->p_md.md_ss_instr);
d1099 1
a1099 1
		    p->p_comm, p->p_pid, va, p->p_md.md_ss_addr);
d1118 2
a1119 2
		p->p_comm, p->p_pid,
		p->p_md.md_ss_addr, p->p_md.md_ss_instr, locr0->pc, curinstr);
d1476 1
a1476 1
		    __func__, p->p_md.md_fppgva, rc);
d1485 1
a1485 1
		    __func__, p->p_md.md_fppgva, rc);
d1494 1
a1494 1
		    __func__, p->p_md.md_fppgva, rc);
d1503 1
a1503 1
		    __func__, p->p_md.md_fppgva + 4, rc);
@


1.93
log
@Have each thread keeps its own (counted!) reference to the process's ucreds
to avoid possible use-after-free references when swapping ids in threaded
processes.  "Do I have the right creds?" checks are always made with the
threads creds.

Inspired by FreeBSD and NetBSD
"right time" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.92 2014/04/09 21:10:35 miod Exp $	*/
a150 2
	atomic_add_int(&uvmexp.softs, 1);

a151 7
	if (p->p_flag & P_OWEUPC) {
		KERNEL_LOCK();
		ADDUPROF(p);
		KERNEL_UNLOCK();
	}
	if (ci->ci_want_resched)
		preempt(NULL);
d153 1
@


1.92
log
@Make trapDump() take the printf-like function as a 2nd parameter.
No functional change; helps non-released kernels with extra debugging code (-:
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.91 2014/03/26 19:38:18 miod Exp $	*/
d192 1
@


1.91
log
@Service R4[04]00SC-specific virtual coherency exceptions directly from the
lowest bowels of the exception handling code, rather than in trap(). They
won't get recorded in the trap history, but there is a measurable speedup.

No change for non-CPU_R4000 kernels.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.90 2014/03/26 05:23:42 guenther Exp $	*/
d794 1
a794 1
		trapDump("trap");
d844 1
a844 1
trapDump(const char *msg)
a853 1
	int (*pr)(const char*, ...);
a854 5
#ifdef DDB
	pr = db_printf;
#else
	pr = printf;
#endif
@


1.90
log
@Move p_emul and p_sigcode from proc to process.
Tweak the handling of ktrace EMUL when changing ktracing: only
generate one per process (not one per thread) and pass the correct
proc pointer down to the VFS layer.  Permit generating of NAMI and
CSW records inside ktrace(2) itself.

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.89 2014/03/22 00:01:04 miod Exp $	*/
a789 28
#ifdef CPU_R4000
	case T_VCEI:
	case T_VCEI+T_USER:
	    {
		vaddr_t va = trapframe->badvaddr;
#ifdef DEBUG
		printf("VCEI trap, badvaddr %p\n", trapframe->badvaddr);
#endif
		/* HitWBInvalidate_S */
		__asm__ __volatile__ ("cache 0x17, 0(%0)" :: "r"(va));
		/* HitInvalidate_I */
		__asm__ __volatile__ ("cache 0x10, 0(%0)" :: "r"(va));
	    }
		return;
	case T_VCED:
	case T_VCED+T_USER:
	    {
		vaddr_t va = trapframe->badvaddr & ~3;
#ifdef DEBUG
		printf("VCED trap, badvaddr %p\n", trapframe->badvaddr);
#endif
		/* HitWBInvalidate_S */
		__asm__ __volatile__ ("cache 0x17, 0(%0)" :: "r"(va));
		/* HitInvalidate_D */
		__asm__ __volatile__ ("cache 0x11, 0(%0)" :: "r"(va));
	    }
		return;
#endif	/* CPU_R4000 */
d893 2
a894 1
			    ptrp->pc, ptrp->cause, ptrp->status);
@


1.89
log
@Second draft of my attempt to workaround the infamous R4000 end-of-page errata,
affecting R4000 processors revision 2.x and below (found on most R4000 Indigo
and a few R4000 Indy).

Since this errata gets triggered by TLB misses when the code flow crosses a
page boundary, this code attempts to identify code pages prone to trigger the
errata, and force the next page to be mapped for at least as long as the
current pc lies in the troublesome page, by creating wiring extra TLB entries.
These entries get recycled in a lazy-but-aggressive-enough way, either because
of context switches, or because of further tlb exceptions reaching trap().

The errata workaround code is only compiled on R4000-capable kernels (i.e.
sgi GENERIC-IP22 and nothing else), and only enabled on affected processors
(i.e. not on R4000 revision 3, or on R4400).

There is still room for improvemnt in unlucky cases, but in this simple enough
incarnation, this allows my R4000 2.2 Indigo to finally reliably boot multiuser,
even though both /sbin/init and /bin/sh contain code pages which can trigger
the errata.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.88 2012/10/03 11:18:23 miod Exp $	*/
d493 2
a494 2
		callp = p->p_emul->e_sysent;
		numsys = p->p_emul->e_nsysent;
d507 1
a507 1
				callp += p->p_emul->e_nosys; /* (illegal) */
d527 1
a527 1
				callp += p->p_emul->e_nosys; /* (illegal) */
@


1.88
log
@Split ever-growing mips <machine/cpu.h> into what 99% of the kernel needs,
which will remain in <machine/cpu.h>, and a new mips_cpu.h containing only the
goriest md details, which are only of interest to a handful set of files; this
is similar in spirit to what alpha does, but here <machine/cpu.h> does not
include the new file.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.87 2012/09/29 21:37:03 miod Exp $	*/
d272 1
d292 1
d329 2
a330 1
			goto fault_common;
d349 1
d357 2
a358 2
			onfault = p->p_addr->u_pcb.pcb_onfault;
			p->p_addr->u_pcb.pcb_onfault = 0;
d362 1
a362 1
			p->p_addr->u_pcb.pcb_onfault = onfault;
d366 1
a366 1
				p->p_addr->u_pcb.pcb_onfault = 0;
d376 1
a376 1
		if (p->p_addr->u_pcb.pcb_onfault != 0) {
d388 1
d393 1
d395 16
d421 2
a422 2
		onfault = p->p_addr->u_pcb.pcb_onfault;
		p->p_addr->u_pcb.pcb_onfault = 0;
d425 2
a426 2
		rv = uvm_fault(map, trunc_page(va), 0, ftype);
		p->p_addr->u_pcb.pcb_onfault = onfault;
d446 1
a446 1
				p->p_addr->u_pcb.pcb_onfault = 0;
d782 3
a784 2
		if ((onfault = p->p_addr->u_pcb.pcb_onfault) != 0) {
			p->p_addr->u_pcb.pcb_onfault = 0;
@


1.87
log
@Basic R8000 processor support. R8000 processors require MMU-specific code,
exception-specific code, clock-specific code, and L1 cache-specific code. L2
cache is per-design, of which only two exist: SGI Power Indigo2 (IP26) and SGI
Power Challenge (IP21) and are not covered by this commit.

R8000 processors also are 64-bit only processors with 64-bit coprocessor 0
registers, and lack so-called ``compatibility'' memory spaces allowing 32-bit
code to run with sign-extended addresses and registers.

The intrusive changes are covered by #ifdef CPU_R8000 stanzas. However,
trap() is split into a high-level wrapper and a new function, itsa(),
responsible for the actual trap servicing (which name couldn't be helped
because I'm an incorrigible punster). While an R8000 exception may cause
(via trap() ) multiple exceptions to be serviced, non-R8000 processors will
always service one exception in trap(), but they are nevertheless affected
by this code split.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.86 2012/09/29 19:24:31 miod Exp $	*/
d65 1
@


1.86
log
@Handle the coprocessor 0 cause and status registers as a 64 bit value now,
as some odd mips designs need moro than 32 bits in there. This causes a lot
of mechanical changes everywhere getsr() is used.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.85 2012/09/29 19:14:37 miod Exp $	*/
d132 2
a172 2
	int type, i;
	unsigned ucode = 0;
d174 3
a176 5
	vm_prot_t ftype;
	extern vaddr_t onfault_table[];
	int onfault;
	int typ = 0;
	union sigval sv;
d178 4
a181 1
	trapdebug_enter(ci, trapframe, -1);
d183 3
a185 1
	type = (trapframe->cause & CR_EXC_CODE) >> CR_EXC_CODE_SHIFT;
d187 1
d197 8
a204 1
	if (type != T_BREAK) {
d212 1
d215 57
d339 1
a339 3
		if (!USERMODE(trapframe->sr))
			return;
		goto out;
d419 2
a420 5
		if (rv == 0) {
			if (!USERMODE(trapframe->sr))
				return;
			goto out;
		}
a429 3
#ifdef ADEBUG
printf("SIG-SEGV @@%p pc %p, ra %p\n", trapframe->badvaddr, trapframe->pc, trapframe->ra);
#endif
a440 3
#ifdef ADEBUG
printf("SIG-BUSA @@%p pc %p, ra %p\n", trapframe->badvaddr, trapframe->pc, trapframe->ra);
#endif
a446 3
#ifdef ADEBUG
printf("SIG-BUSB @@%p pc %p, ra %p\n", trapframe->badvaddr, trapframe->pc, trapframe->ra);
#endif
d642 1
a642 1
				goto out;
a650 1

d666 1
a666 1
			goto out;
d700 1
a700 1
			goto out;
d740 1
a740 1
		goto out;
d749 1
a749 1
		goto out;
a826 5
out:
	/*
	 * Note: we should only get here if returning to user mode.
	 */
	userret(p);
d888 6
d898 1
d1158 5
d1166 1
d1344 3
a1346 1
		if (subr == (vaddr_t)k_intr)
a1347 2
		else
			(*pr)("(KERNEL TRAP)\n");
@


1.85
log
@Avoid an unnecessary copyin() call in the SYS__syscall handling path.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.84 2012/09/29 19:13:15 miod Exp $	*/
d839 1
a839 1
			(*pr)("%s: PC %p CR 0x%08x SR 0x%08x\n",
@


1.84
log
@Add a few more coprocessor 0 cause and config registers defines.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.83 2012/08/07 19:55:57 miod Exp $	*/
d399 1
a399 1
		unsigned long tpc;
d423 3
d441 4
a444 3
				if ((error = copyin((void *)locr0->sp,
				    &args.i[7], sizeof(register_t))))
					goto bad;
d755 1
d894 1
a894 1
			if ((int)(regsPtr[inst.RType.rs]) < 0)
d903 1
a903 1
			if ((int)(regsPtr[inst.RType.rs]) >= 0)
d933 1
a933 1
		if ((int)(regsPtr[inst.RType.rs]) <= 0)
d940 1
a940 1
		if ((int)(regsPtr[inst.RType.rs]) > 0)
@


1.83
log
@Handle __syscall as syscall, since these are identical on 64-bit platforms,
fixing an old n32-inherited bug in the process. Spotted during guenther@@'s
syscall factorization work.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.82 2012/08/07 05:16:54 guenther Exp $	*/
d672 1
a672 1
		if ((trapframe->cause & CR_COP_ERR) != 0x10000000) {
d794 1
a794 1
trapDump(char *msg)
@


1.82
log
@Move the common bits of syscall invocation and return handling into
an MI file, <sys/syscall_mi.h>, correcting inconsistencies and the
handling when copyin() of arguments fails.

Tested on i386, amd64, sparc64, and alpha (thanks naddy@@)
Any issues with other platforms will be fixed in tree.

header name from millert@@; ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.81 2012/04/11 14:38:55 mikeb Exp $	*/
d420 1
a442 27

		case SYS___syscall:
			/*
			 * Like syscall, but code is a quad, so as to maintain
			 * quad alignment for the rest of the arguments.
			 */
			code = locr0->a0;
			args.i[0] = locr0->a1;
			args.i[1] = locr0->a2;
			args.i[2] = locr0->a3;

			if (code >= numsys)
				callp += p->p_emul->e_nosys; /* (illegal) */
			else
				callp += code;
			i = callp->sy_argsize / sizeof(int);
			if (i > 3) {
				args.i[3] = locr0->a4;
				args.i[4] = locr0->a5;
				args.i[5] = locr0->a6;
				args.i[6] = locr0->a7;
				if ((error = copyin((void *)locr0->sp,
				    &args.i[7], sizeof(register_t))))
					goto bad;
			}
			break;

@


1.81
log
@The first ktrace record for a newly spawned thread is a return
from a fork syscall done by the parent.  Use __tfork, not rfork
here to match the ktrace records for the parent (CALL __tfork,
RET __tfork).  ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.80 2012/04/10 15:59:21 miod Exp $	*/
d53 1
a56 3
#ifdef KTRACE
#include <sys/ktrace.h>
#endif
a80 3
#include "systrace.h"
#include <dev/systrace.h>

d400 1
a400 1
		int numsys;
d437 3
a439 2
				i = copyin((void *)locr0->sp,
				    &args.i[7], sizeof(register_t));
d463 3
a465 2
				i = copyin((void *)locr0->sp, &args.i[7],
				    sizeof(register_t));
d487 1
a487 12
#ifdef SYSCALL_DEBUG
		KERNEL_LOCK();
		scdebug_call(p, code, args.i);
		KERNEL_UNLOCK();
#endif
#ifdef KTRACE
		if (KTRPOINT(p, KTR_SYSCALL)) {
			KERNEL_LOCK();
			ktrsyscall(p, code, callp->sy_argsize, args.i);
			KERNEL_UNLOCK();
		}
#endif
d490 1
d496 3
a498 16
#if NSYSTRACE > 0
		if (ISSET(p->p_flag, P_SYSTRACE)) {
			KERNEL_LOCK();
			i = systrace_redirect(code, p, args.i, rval);
			KERNEL_UNLOCK();
		} else
#endif
		{
			int nolock = (callp->sy_flags & SY_NOLOCK);
			if (!nolock)
				KERNEL_LOCK();
			i = (*callp->sy_call)(p, &args, rval);
			if (!nolock)
				KERNEL_UNLOCK();
		}
		switch (i) {
d513 2
a514 1
			locr0->v0 = i;
d517 4
a520 13
#ifdef SYSCALL_DEBUG
		KERNEL_LOCK();
		scdebug_ret(p, code, i, rval);
		KERNEL_UNLOCK();
#endif
#ifdef KTRACE
		if (KTRPOINT(p, KTR_SYSRET)) {
			KERNEL_LOCK();
			ktrsysret(p, code, i, rval[0]);
			KERNEL_UNLOCK();
		}
#endif
		goto out;
d815 1
a815 12
	userret(p);

#ifdef KTRACE
	if (KTRPOINT(p, KTR_SYSRET)) {
		KERNEL_LOCK();
		ktrsysret(p,
		    (p->p_flag & P_THREAD) ? SYS___tfork :
		    (p->p_p->ps_flags & PS_PPWAIT) ? SYS_vfork : SYS_fork,
		    0, 0);
		KERNEL_UNLOCK();
	}
#endif
@


1.80
log
@Count traps and fpu context switches.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.79 2012/04/09 16:56:21 miod Exp $	*/
d855 1
a855 1
		    (p->p_flag & P_THREAD) ? SYS_rfork :
@


1.79
log
@No need to round VCEI addresses, and VCED addresses only need to be rounded
to a word boundary.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.78 2012/03/28 20:44:23 miod Exp $	*/
d153 1
a153 1
	uvmexp.softs++;
d188 2
d411 1
a411 1
		uvmexp.syscalls++;
@


1.78
log
@Work in progress support for the SGI Indigo, Indigo 2 and Indy systems
(IP20, IP22, IP24) in 64-bit mode, adapated from NetBSD. Currently limited
to headless operation, input and video drivers will get ported soon.

Should work on all R4000, R4440 and R5000 based systems. L2 cache on R5000SC
Indy not supported yet (coming soon), R4600 not supported yet either (coming
soon as well).

Tested to boot multiuser on: Indigo2 R4000SC, Indy R4000PC, Indy R4000SC,
Indy R5000SC, Indigo2 R4400SC. There are still glitches in the Ethernet driver
which are being looked at.

Expansion support is limited to the GIO E++ board; GIO boards with PCI-GIO
bridges not ported yet due to the lack of hardware, and this kind of driver
does not port blindly.

Most of this work comes from NetBSD, polishing and integration work, as well
as putting as many ``R4x00 in 64-bit mode'' erratas as necessary, by yours
truly.

More work is coming, as well as trying to get some easy way to boot install
kernels (as older PROM can only boot ECOFF binaries, which won't do for the
kernel).
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.77 2011/11/16 20:50:19 deraadt Exp $	*/
d770 1
a770 2
		vaddr_t va = trapframe->badvaddr &
		    ~((vaddr_t)ci->ci_l1instcacheline - 1);
d783 1
a783 2
		vaddr_t va = trapframe->badvaddr &
		    ~((vaddr_t)ci->ci_l1datacacheline - 1);
@


1.77
log
@Make userret() MI.  On architectures which jammed stuff into it in the
past, pull that code out seperately.
ok guenther miod
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.76 2011/07/11 15:40:47 guenther Exp $	*/
d766 30
@


1.76
log
@Revert art@@'s moving around of the KERNEL_LOCK()/KERNEL_UNLOCK() calls,
as it causes hangs in some ports, including libsigsegv's configure script

confirmed by krw@@, landry@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.74 2011/07/06 21:41:37 art Exp $	*/
a142 12

static __inline__ void
userret(struct proc *p)
{
	int sig;

	/* take pending signals */
	while ((sig = CURSIG(p)) != 0)
		postsig(sig);

	p->p_cpu->ci_schedstate.spc_curpriority = p->p_priority = p->p_usrpri;
}
@


1.75
log
@There is a bunch of places in the kernel entry points where we don't
hold the kernel lock, but still need call one function that needs it.

Instead of grabbing the lock all over the place, move the locks into
the affected functions: trapsignal, scdebug*, ktrsyscall, ktrsysret,
systrace_redirect and ADDUPROF. In the cases we already hold the biglock
we'll just recurse.

kettenis@@, beck@@ ok
@
text
@d169 1
d171 1
d501 1
d503 1
d507 1
d509 1
d521 1
d523 1
d553 1
d555 1
d559 1
d561 1
d807 1
d809 1
d835 1
d840 1
@


1.74
log
@Clean up after P_BIGLOCK removal.
KERNEL_PROC_LOCK -> KERNEL_LOCK
KERNEL_PROC_UNLOCK -> KERNEL_UNLOCK

oga@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.73 2011/04/03 14:56:28 guenther Exp $	*/
a168 1
		KERNEL_LOCK();
a169 1
		KERNEL_UNLOCK();
a498 1
		KERNEL_LOCK();
a499 1
		KERNEL_UNLOCK();
a502 1
			KERNEL_LOCK();
a503 1
			KERNEL_UNLOCK();
a514 1
			KERNEL_LOCK();
a515 1
			KERNEL_UNLOCK();
a544 1
		KERNEL_LOCK();
a545 1
		KERNEL_UNLOCK();
a548 1
			KERNEL_LOCK();
a549 1
			KERNEL_UNLOCK();
a794 1
	KERNEL_LOCK();
a795 1
	KERNEL_UNLOCK();
a820 1
		KERNEL_LOCK();
a824 1
		KERNEL_UNLOCK();
@


1.73
log
@Move PPWAIT flag from struct proc to process, so that rthreads in
a vforked child behave correctly.  Have the parent in a vfork()
wait on a (different) flag in *its* process instead of the child
to prevent a possible use-after-free.  When ktracing the child
return from a fork, call it rfork if an rthread was created.

ok blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.72 2010/11/24 21:16:28 miod Exp $	*/
d169 1
a169 1
		KERNEL_PROC_LOCK(p);
d171 1
a171 1
		KERNEL_PROC_UNLOCK(p);
d276 1
a276 4
		if (USERMODE(trapframe->sr))
			KERNEL_PROC_LOCK(p);
		else
			KERNEL_LOCK();
d284 1
a284 4
		if (USERMODE(trapframe->sr))
			KERNEL_PROC_UNLOCK(p);
		else
			KERNEL_UNLOCK();
d348 1
a348 4
		if (USERMODE(trapframe->sr))
			KERNEL_PROC_LOCK(p);
		else
			KERNEL_LOCK();
d366 1
a366 4
		if (USERMODE(trapframe->sr))
			KERNEL_PROC_UNLOCK(p);
		else
			KERNEL_UNLOCK();
d501 1
a501 1
		KERNEL_PROC_LOCK(p);
d503 1
a503 1
		KERNEL_PROC_UNLOCK(p);
d507 1
a507 1
			KERNEL_PROC_LOCK(p);
d509 1
a509 1
			KERNEL_PROC_UNLOCK(p);
d521 1
a521 1
			KERNEL_PROC_LOCK(p);
d523 1
a523 1
			KERNEL_PROC_UNLOCK(p);
d529 1
a529 1
				KERNEL_PROC_LOCK(p);
d532 1
a532 1
				KERNEL_PROC_UNLOCK(p);
d553 1
a553 1
		KERNEL_PROC_LOCK(p);
d555 1
a555 1
		KERNEL_PROC_UNLOCK(p);
d559 1
a559 1
			KERNEL_PROC_LOCK(p);
d561 1
a561 1
			KERNEL_PROC_UNLOCK(p);
d807 1
a807 1
	KERNEL_PROC_LOCK(p);
d809 1
a809 1
	KERNEL_PROC_UNLOCK(p);
d829 1
a829 1
	KERNEL_PROC_UNLOCK(p);
d835 1
a835 1
		KERNEL_PROC_LOCK(p);
d840 1
a840 1
		KERNEL_PROC_UNLOCK(p);
@


1.72
log
@Floating-point emulation code for systems lacking proper FPU (i.e. Octeon),
enabled by option FPUEMUL.

This is pretty straightforward, except for conditional branch on FPU condition
codes emulation (bc1f/bc1fl/bc1t/bc1tl instructions): unlike most
RISC-with-delay-slots designs (m88k, sparc), the branch pipeline is not exposed
to the kernel on Mips, therefore we can not resume a branch without losing the
delay slot instruction.

Some other operating systems work around this issue by emulating the delay
slot instruction, but this is error-prone (and requires the kernel code to
be aware of all supported instructions of the processor it is currently running
on), some use dedicated breakpoints to single-step through the delay slot and
then resume the branch as expected, but this causes a lot of copy-on-write
allocations.

This code chooses a third path, of copying the delay slot instructions to run toa special `magic' page, followed by a special trap instruction to give control
back to the kernel. This makes sure the instruction will actually be run by the
processor, and that no more than one page per process is wasted, regardless of
the number of branches to emulate.

Tested on octeon (big-endian) by syuu@@ and on loongson (little-endian) by me.
Note that enabling option FPUEMUL in the kernel will completely disable the
hardware FPU, if there is one; there is currently no way to build a kernel
supporting both hardware and software FPU, and there is no reason to change
this until there is a strong need to support both.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.71 2010/11/24 21:01:03 miod Exp $	*/
d849 3
a851 1
		    (p->p_flag & P_PPWAIT) ? SYS_vfork : SYS_fork, 0, 0);
@


1.71
log
@Make sure ptrace_sstep(,0) actually clears breakpoints, by replacing the
ptrace guts with a logic similar to what the alpha port does.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.70 2010/10/24 15:39:18 miod Exp $	*/
d643 26
d759 3
a761 1

d763 1
d805 10
d1403 132
@


1.70
log
@Don't short-circuit userret() when returning from trap() in the rm7000
performance counter code path (which is not enabled at the moment).
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.69 2010/09/21 21:59:44 miod Exp $	*/
d139 3
a141 1
int	cpu_singlestep(struct proc *);
a563 2
		if (code == SYS_ptrace)
			Mips_SyncCache(curcpu());
a602 6
#if 0
		printf("trap: %s (%d) breakpoint %x at %x: (adr %x ins %x)\n",
			p->p_comm, p->p_pid, instr, trapframe->pc,
			p->p_md.md_ss_addr, p->p_md.md_ss_instr); /* XXX */
#endif

d627 6
a632 24
				struct uio uio;
				struct iovec iov;
				int error;

				/*
				 * Restore original instruction and clear BP
				 */
				iov.iov_base = (caddr_t)&p->p_md.md_ss_instr;
				iov.iov_len = sizeof(int);
				uio.uio_iov = &iov;
				uio.uio_iovcnt = 1;
				uio.uio_offset = (off_t)(long)va;
				uio.uio_resid = sizeof(int);
				uio.uio_segflg = UIO_SYSSPACE;
				uio.uio_rw = UIO_WRITE;
				uio.uio_procp = curproc;
				error = process_domem(curproc, p, &uio,
				    PT_WRITE_I);
				Mips_SyncCache(curcpu());

				if (error)
					printf("Warning: can't restore instruction at %x: %x\n",
					    p->p_md.md_ss_addr,
					    p->p_md.md_ss_instr);
d634 2
a635 1
				p->p_md.md_ss_addr = 0;
d992 36
d1034 1
a1034 2
cpu_singlestep(p)
	struct proc *p;
a1035 1
	vaddr_t va;
d1037 1
a1037 2
	int error;
	int bpinstr = BREAK_SSTEP;
d1039 19
a1057 2
	struct uio uio;
	struct iovec iov;
d1059 4
a1062 13
	/*
	 * Fetch what's at the current location.
	 */
	iov.iov_base = (caddr_t)&curinstr;
	iov.iov_len = sizeof(uint32_t);
	uio.uio_iov = &iov;
	uio.uio_iovcnt = 1;
	uio.uio_offset = (off_t)locr0->pc;
	uio.uio_resid = sizeof(uint32_t);
	uio.uio_segflg = UIO_SYSSPACE;
	uio.uio_rw = UIO_READ;
	uio.uio_procp = curproc;
	process_domem(curproc, p, &uio, PT_READ_I);
d1065 1
a1065 1
	if (curinstr != 0)
d1070 7
a1076 4
	if (p->p_md.md_ss_addr) {
		printf("SS %s (%d): breakpoint already set at %x (va %x)\n",
			p->p_comm, p->p_pid, p->p_md.md_ss_addr, va); /* XXX */
		return (EFAULT);
d1078 1
d1080 9
a1088 13
	/*
	 * Fetch what's at the current location.
	 */
	iov.iov_base = (caddr_t)&p->p_md.md_ss_instr;
	iov.iov_len = sizeof(int);
	uio.uio_iov = &iov;
	uio.uio_iovcnt = 1;
	uio.uio_offset = (off_t)va;
	uio.uio_resid = sizeof(int);
	uio.uio_segflg = UIO_SYSSPACE;
	uio.uio_rw = UIO_READ;
	uio.uio_procp = curproc;
	process_domem(curproc, p, &uio, PT_READ_I);
d1090 1
a1090 16
	/*
	 * Store breakpoint instruction at the "next" location now.
	 */
	iov.iov_base = (caddr_t)&bpinstr;
	iov.iov_len = sizeof(int);
	uio.uio_iov = &iov;
	uio.uio_iovcnt = 1;
	uio.uio_offset = (off_t)va;
	uio.uio_resid = sizeof(int);
	uio.uio_segflg = UIO_SYSSPACE;
	uio.uio_rw = UIO_WRITE;
	uio.uio_procp = curproc;
	error = process_domem(curproc, p, &uio, PT_WRITE_I);
	Mips_SyncCache(curcpu());
	if (error)
		return (EFAULT);
d1092 4
a1095 5
	p->p_md.md_ss_addr = va;
#if 0
	printf("SS %s (%d): breakpoint set at %x: %x (pc %x) br %x\n",
		p->p_comm, p->p_pid, p->p_md.md_ss_addr,
		p->p_md.md_ss_instr, locr0[PC], curinstr); /* XXX */
d1097 1
a1097 1
	return (0);
@


1.69
log
@Better not panic in MipsEmulateBranch() if the instruction is an unspecified
OP_BCOND subfunction.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.68 2010/09/21 20:29:17 miod Exp $	*/
d687 1
a687 1
			return;
d721 1
a721 1
			return;
@


1.68
log
@Replace the old floating point completion code with a C interface to the
MI softfloat code, implementing all MIPS IV specified floating point
operations.
Tested on R5000, R10000, R14000 and Loongson2F.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.67 2010/09/17 00:36:32 miod Exp $	*/
a924 1

a929 1

a940 1

d950 2
a951 8

		case OP_TGEI:
		case OP_TGEIU:
		case OP_TLTI:
		case OP_TLTIU:
		case OP_TEQI:
		case OP_TNEI:
			retAddr = instPC + 4;	/* Like syscall... */
a952 3

		default:
			panic("MipsEmulateBranch: Bad branch cond");
a954 1

a958 1

a965 1

a972 1

a979 1

a986 1

a1000 1

a1004 1

@


1.67
log
@Recognize MIPS IV extra FPU condition codes in MipsEmulateBranch().
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.66 2010/09/17 00:25:11 miod Exp $	*/
a135 2
extern void MipsFPTrap(u_int, u_int, u_int, union sigval);

a136 1
void	fpu_trapsignal(struct proc *, u_long, int, union sigval);
d746 5
d766 1
a766 2
		sv.sival_ptr = (void *)trapframe->pc;
		MipsFPTrap(trapframe->sr, trapframe->cause, trapframe->pc, sv);
a836 11
}

/*
 * Wrapper around trapsignal() for use by the floating point code.
 */
void
fpu_trapsignal(struct proc *p, u_long ucode, int typ, union sigval sv)
{
	KERNEL_PROC_LOCK(p);
	trapsignal(p, SIGFPE, ucode, typ, sv);
	KERNEL_PROC_UNLOCK(p);
@


1.66
log
@There is only one code for coprocessor BC opcodes, so don't bother to handle
a second (invalid) opcode; confirmed by all mips core documentation.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.65 2010/09/14 19:35:13 miod Exp $	*/
d67 1
d916 1
d1018 2
d1021 1
a1021 1
				condition = fsr & FPC_COND_BIT;
d1023 1
a1023 1
				condition = !(fsr & FPC_COND_BIT);
@


1.65
log
@Recognize the new sequence gcc4 uses to trap on divide by zero.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.64 2010/09/12 18:30:19 miod Exp $	*/
d1015 1
a1015 2
		case OP_BCx:
		case OP_BCy:
d1272 1
a1272 2
			case OP_BCx:
			case OP_BCy:
@


1.64
log
@Stricter types in MipsEmulateBranch(), and related cleanups.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.63 2010/01/21 17:50:44 miod Exp $	*/
d622 1
a622 1
		case 7:	/* gcc divide by zero */
d624 1
a624 1
			typ = FPE_FLTDIV;	/* XXX FPE_INTDIV ? */
d726 10
a735 1
		{
@


1.63
log
@Use db_printf() instead of printf() in db_dump_tlb_cmd() and trapDump(), so
that the output can be paused by ddb if it spans too many lines.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.62 2010/01/18 18:27:32 miod Exp $	*/
a61 1
#include <net/netisr.h>
d65 1
a65 1
#include <machine/trap.h>
d67 1
a67 3
#include <machine/intr.h>
#include <machine/autoconf.h>
#include <machine/pmap.h>
a68 1
#include <machine/frame.h>
d70 1
a73 2
#include <mips64/archtype.h>

a142 1
u_long	MipsEmulateBranch(struct trap_frame *, long, int, u_int);
a324 12
#if 0
		/*
		 * However we allow accesses to the top of user stack for
		 * compat emul data.
		 */
#define szsigcode ((long)(p->p_emul->e_esigcode - p->p_emul->e_sigcode))
		if (trapframe->badvaddr < VM_MAXUSER_ADDRESS &&
		    trapframe->badvaddr >= (long)STACKGAPBASE)
			goto fault_common;
#undef szsigcode
#endif

d437 4
a440 4
		if (trapframe->cause & CR_BR_DELAY) {
			locr0->pc = MipsEmulateBranch(locr0, trapframe->pc, 0, 0);
		}
		else {
a441 1
		}
d710 4
a713 3
		if (trapframe->cause & CR_BR_DELAY) {
			locr0->pc = MipsEmulateBranch(locr0, trapframe->pc, 0, 0);
		} else {
a714 1
		}
d898 3
a900 6
unsigned long
MipsEmulateBranch(framePtr, instPC, fpcCSR, curinst)
	struct trap_frame *framePtr;
	long instPC;
	int fpcCSR;
	u_int curinst;
d902 1
d904 1
a904 1
	unsigned long retAddr;
a905 1
	register_t *regsPtr = (register_t *)framePtr;
d908 1
a908 1
	    ((unsigned long)InstPtr + 4 + ((short)inst.IType.imm << 2))
d910 1
a910 2

	if (curinst)
d914 1
a914 4
#if 0
	printf("regsPtr=%x PC=%x Inst=%x fpcCsr=%x\n", regsPtr, instPC,
		inst.word, fpcCSR); /* XXX */
#endif
d922 1
a922 1
			retAddr = regsPtr[inst.RType.rs];
d969 1
a969 1
		retAddr = (inst.JType.target << 2) | (instPC & ~0x0fffffff);
d1009 1
a1009 1
				condition = fpcCSR & FPC_COND_BIT;
d1011 1
a1011 1
				condition = !(fpcCSR & FPC_COND_BIT);
d1027 1
a1027 1
	return (retAddr);
d1046 1
a1046 1
	int curinstr;
d1054 1
a1054 1
	iov.iov_len = sizeof(int);
d1058 1
a1058 1
	uio.uio_resid = sizeof(int);
d1065 4
a1068 4
	if (curinstr != 0) {
		va = MipsEmulateBranch(locr0, locr0->pc, locr0->fsr, curinstr);
	}
	else {
a1069 1
	}
@


1.62
log
@In stacktrace(), when aborting a traceback because of nonsensical pc or sp
value, don't print a final bogus traceback line.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.61 2010/01/18 16:57:46 miod Exp $	*/
d81 1
d870 1
d872 5
d878 1
a878 1
	printf("trapDump(%s)\n", msg);
d886 1
a886 1
		printf("cpu%d\n", ci->ci_cpuid);
d900 1
a900 1
			printf("%s: PC %p CR 0x%08x SR 0x%08x\n",
d904 1
a904 1
			printf(" RA %p SP %p ADR %p\n",
@


1.61
log
@Make trapdebug code MP-safe.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.60 2010/01/16 23:28:10 miod Exp $	*/
d859 1
a859 2
trapDump(msg)
	char *msg;
d865 1
a865 1
	struct trapdebug *ptrp;
d867 1
d878 3
d882 2
d885 4
a888 2
			ptrp = trapdebug + ci->ci_cpuid * TRAPSIZE;
			ptrp += (trppos[ci->ci_cpuid] + i) % TRAPSIZE;
d1204 1
a1204 1
		goto done;
d1211 1
a1211 1
		goto done;
a1325 1
done:
@


1.60
log
@Merge db_stack_trace_print() and stacktrace() logic, and have the former
invoke the latter to avoid duplicating code.
Fix the logic by looking for `sd' instructions for register saves only,
and read the whole 64-bit value then. Makes the backtraces less wrong.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.59 2010/01/14 07:24:43 miod Exp $	*/
d127 2
a128 1
struct trapdebug trapdebug[TRAPSIZE], *trp = trapdebug;
d190 1
a190 2
trap(trapframe)
	struct trap_frame *trapframe;
d192 1
d195 1
a195 1
	struct proc *p = curproc;
d202 1
a202 1
	trapdebug_enter(trapframe, -1);
d545 2
a546 4
		if (trp == trapdebug)
			trapdebug[TRAPSIZE - 1].code = code;
		else
			trp[-1].code = code;
d862 4
a870 1
	ptrp = trp;
d872 20
a891 3
	for (i = 0; i < TRAPSIZE; i++) {
		if (ptrp == trapdebug) {
			ptrp = &trapdebug[TRAPSIZE - 1];
a892 12
		else {
			ptrp--;
		}

		if (ptrp->cause == 0)
			break;

		printf("%s: PC %p CR 0x%x SR 0x%x\n",
		    trap_type[(ptrp->cause & CR_EXC_CODE) >> CR_EXC_CODE_SHIFT],
		    ptrp->pc, ptrp->cause, ptrp->status);

		printf(" RA %p SP %p ADR %p\n", ptrp->ra, ptrp->sp, ptrp->vadr);
@


1.59
log
@When trying to get a stack trace, consider CKSEG1 addresses as invalid, as the
kernel will never use them for code or stack.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.58 2010/01/09 23:34:29 miod Exp $	*/
d130 2
a131 1
int	kdbpeek(void *);
d1129 1
a1129 1
char *fn_name(long addr);
d1131 1
a1131 1
void stacktrace_subr(struct trap_frame *, int (*)(const char*, ...));
d1140 1
a1140 1
	stacktrace_subr(regs, printf);
d1148 2
a1149 3
stacktrace_subr(regs, printfn)
	struct trap_frame *regs;
	int (*printfn)(const char*, ...);
d1151 3
a1153 3
	vaddr_t pc, sp, fp, ra, va, subr;
	long a0, a1, a2, a3;
	unsigned instr, mask;
d1156 7
a1162 1
	unsigned int frames =  0;
a1166 1
	fp = (vaddr_t)regs->s8;
d1175 5
d1181 3
a1183 6
/* Jump here after a nonstandard (interrupt handler) frame */
	stksize = 0;
	subr = 0;
	if (frames++ > 6) {
		(*printfn)("stackframe count exceeded\n");
		return;
d1188 1
a1188 1
		(*printfn)("SP %p: not in kernel\n", sp);
a1189 1
		subr = 0;
d1195 1
a1195 1
		(*printfn)("PC %p: not in kernel\n", pc);
d1200 11
d1217 2
a1218 2
		while ((instr = kdbpeek((void *)va)) != MIPS_JR_RA)
		va -= sizeof(int);
d1221 1
a1221 1
		while ((instr = kdbpeek((void *)va)) == 0)
d1239 1
a1239 1
		instr = kdbpeek((void *)va);
a1275 1
		case OP_SW:
d1278 1
a1278 1
			if (i.IType.rs != 29)
d1285 2
a1286 2
			case 4: /* a0 */
				a0 = kdbpeek((void *)(sp + (short)i.IType.imm));
d1288 2
a1289 3

			case 5: /* a1 */
				a1 = kdbpeek((void *)(sp + (short)i.IType.imm));
d1291 2
a1292 3

			case 6: /* a2 */
				a2 = kdbpeek((void *)(sp + (short)i.IType.imm));
d1294 2
a1295 3

			case 7: /* a3 */
				a3 = kdbpeek((void *)(sp + (short)i.IType.imm));
d1297 2
a1298 3

			case 30: /* fp */
				fp = kdbpeek((void *)(sp + (short)i.IType.imm));
a1299 3

			case 31: /* ra */
				ra = kdbpeek((void *)(sp + (short)i.IType.imm));
a1302 2
		case OP_ADDI:
		case OP_ADDIU:
d1306 1
a1306 1
			if (i.IType.rs != 29 || i.IType.rt != 29)
d1308 1
a1308 1
			stksize = - ((short)i.IType.imm);
d1314 4
a1317 1
	db_printsym(pc, DB_STGY_ANY, printfn);
d1319 1
a1319 1
	(*printfn)("%s+%x", fn_name(subr), pc - subr);
d1321 14
a1334 5
	if (frames == 1)
		(*printfn)(" ra %p sp %p (%p,%p,%p,%p)\n",
		    ra, sp, a0, a1, a2, a3);
	else
		(*printfn)(" ra %p sp %p\n", ra, sp);
d1336 1
d1339 1
a1339 1
			(*printfn)("stacktrace: loop!\n");
d1348 1
a1348 1
			(*printfn)("User-level: pid %d\n", curproc->p_pid);
d1350 1
a1350 1
			(*printfn)("User-level: curproc NULL\n");
d1365 1
a1365 1
static struct { void *addr; char *name;} names[] = {
d1367 1
a1367 1
	{0, 0}
d1373 2
a1374 2
char *
fn_name(long addr)
d1376 1
a1376 1
	static char buf[17];
d1379 1
a1379 1
	for (i = 0; names[i].name; i++)
d1382 1
a1382 1
	snprintf(buf, sizeof(buf), "%x", addr);
@


1.58
log
@Move cache information from global variables to per-cpu_info fields; this
allows processors with different cache sizes to be used.

Cache management routines now take a struct cpu_info * as first parameter.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.57 2010/01/08 01:35:52 syuu Exp $	*/
d1144 1
a1144 1
	 IS_XKPHYS(va) || ((va) >= CKSEG0_BASE && (va) < CKSSEG_BASE))
a1185 24

#if 0
	/* Backtraces should contine through interrupts from kernel mode */
	if (pc >= (vaddr_t)MipsKernIntr && pc < (vaddr_t)MipsUserIntr) {
		(*printfn)("MipsKernIntr+%x: (%x, %x ,%x) -------\n",
		       pc - (vaddr_t)MipsKernIntr, a0, a1, a2);
		regs = (struct trap_frame *)(sp + STAND_ARG_SIZE);
		a0 = kdbpeek(&regs->a0);
		a1 = kdbpeek(&regs->a1);
		a2 = kdbpeek(&regs->a2);
		a3 = kdbpeek(&regs->a3);

		pc = kdbpeek(&regs->pc); /* exc_pc - pc at time of exception */
		ra = kdbpeek(&regs->ra); /* ra at time of exception */
		sp = kdbpeek(&regs->sp);
		goto specialframe;
	}
#endif


# define Between(x, y, z) \
		( ((x) <= (y)) && ((y) < (z)) )
# define pcBetween(a,b) \
		Between((vaddr_t)a, pc, (vaddr_t)b)
@


1.57
log
@MP-safe FPU handling. ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.56 2010/01/07 20:51:04 miod Exp $	*/
d583 1
a583 1
			Mips_SyncCache();
d671 1
a671 1
				Mips_SyncCache();
d1108 1
a1108 1
	Mips_SyncCache();
@


1.56
log
@Repair non-MULTIPROCESSOR kernel compilation.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.55 2010/01/07 07:36:51 syuu Exp $	*/
a90 2
struct	proc *machFPCurProcPtr;		/* pointer to last proc to use FP */

a136 2
extern void MipsSwitchFPState(struct proc *, struct trap_frame *);
extern void MipsSwitchFPState16(struct proc *, struct trap_frame *);
d763 1
a763 8
		if (p->p_md.md_regs->sr & SR_FR_32)
			MipsSwitchFPState(machFPCurProcPtr, p->p_md.md_regs);
		else
			MipsSwitchFPState16(machFPCurProcPtr, p->p_md.md_regs);

		machFPCurProcPtr = p;
		p->p_md.md_regs->sr |= SR_COP_1_BIT;
		p->p_md.md_flags |= MDP_FPUSED;
@


1.55
log
@Enable IPI interrrupt in trap. ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.54 2010/01/01 15:04:00 miod Exp $	*/
d218 2
a219 1
		else
d221 2
@


1.54
log
@Make sure we grab the kernel lock before invoking trapsignal().
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.53 2009/12/28 06:55:27 syuu Exp $	*/
d212 2
a213 1
	 * Enable hardware interrupts if they were on before the trap.
d215 2
a216 2
	if (trapframe->sr & SR_INT_ENAB) {
		if (type != T_BREAK) {
d218 2
a219 1
		}
@


1.53
log
@MP-safe pmap implemented, enable IPI in interrupt handler to avoid deadlock.
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.52 2009/11/22 00:19:49 syuu Exp $	*/
d144 1
d852 11
d913 2
a914 2
#define GetBranchDest(InstPtr, inst) \
	((unsigned long)InstPtr + 4 + ((short)inst.IType.imm << 2))
d917 1
a917 1
	if (curinst) {
d919 1
a919 2
	}
	else {
a920 1
	}
d1036 1
d1038 1
@


1.52
log
@Correct cording style.
ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.51 2009/11/22 00:07:04 miod Exp $	*/
d241 3
a243 1
			tlb_update(trapframe->badvaddr & ~PGOFSET, entry);
d249 1
d277 6
a282 2
		tlb_update((trapframe->badvaddr & ~PGOFSET) |
		    (pmap->pm_tlbpid << VMTLB_PID_SHIFT), entry);
d288 4
@


1.51
log
@Allow mips ports to override VM_{MIN,MAX}_KERNEL_ADDRESS, and provide the
address as a kernel variable for use by libkvm.

On sgi IP27 and IP30 kernels, use XKSEG instead of CKSSEG; this will allow
kernel KVM size to grow in the future if necessary.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.50 2009/11/21 23:28:15 syuu Exp $	*/
d545 1
a545 1
			if(!nolock)
d548 1
a548 1
			if(!nolock)
@


1.50
log
@mplock, rw_cas implemented
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.49 2009/11/19 20:16:27 miod Exp $	*/
d1125 4
a1138 1
	extern char edata[];
d1163 1
a1163 1
	if (sp & 3 || (!IS_XKPHYS(sp) && sp < CKSEG0_BASE)) {
d1195 1
a1195 2
	if (pc & 3 || (!IS_XKPHYS(pc) && pc < CKSEG0_BASE) ||
	    pc >= (vaddr_t)edata) {
d1340 2
@


1.49
log
@Rename KSEG* defines to CKSEG* to match their names in 64 bit mode; also
define more 64 bit spaces.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.48 2009/11/19 20:13:52 miod Exp $	*/
d175 1
d177 1
d298 1
d300 1
d356 5
d377 4
d516 1
d518 1
d521 2
a522 1
		if (KTRPOINT(p, KTR_SYSCALL))
d524 2
d535 1
d537 2
a538 1
		if (ISSET(p->p_flag, P_SYSTRACE))
d540 2
a541 1
		else
d543 4
d548 3
a550 1

d572 1
d574 1
d577 2
a578 1
		if (KTRPOINT(p, KTR_SYSRET))
d580 2
d804 1
d806 1
d826 2
d831 2
a832 1
	if (KTRPOINT(p, KTR_SYSRET))
d835 2
@


1.48
log
@Remove code allowing native binaries with O32 ABI to run, there aren't any...
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.47 2009/11/18 20:58:52 miod Exp $	*/
d1121 1
a1121 1
	if (sp & 3 || (!IS_XKPHYS(sp) && sp < KSEG0_BASE)) {
d1153 1
a1153 1
	if (pc & 3 || (!IS_XKPHYS(pc) && pc < KSEG0_BASE) ||
@


1.47
log
@Stricter type usage (width and signedness); first step towards 64 bit ptes.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.46 2009/10/22 20:10:44 miod Exp $	*/
d450 6
a455 18
				if (p->p_md.md_flags & MDP_O32) {
					int32_t p[5];

					i = copyin((int32_t *)locr0->sp + 4,
						p, 5 * sizeof(int32_t));
					args.i[3] = p[0];
					args.i[4] = p[1];
					args.i[5] = p[2];
					args.i[6] = p[3];
					args.i[7] = p[4];
				} else {
					args.i[3] = locr0->a4;
					args.i[4] = locr0->a5;
					args.i[5] = locr0->a6;
					args.i[6] = locr0->a7;
					i = copyin((void *)locr0->sp,
					    &args.i[7], sizeof(register_t));
				}
d464 4
a467 14
			if (p->p_md.md_flags & MDP_O32) {
				if (_QUAD_LOWWORD == 0) {
					code = locr0->a0;
				} else {
					code = locr0->a1;
				}
				args.i[0] = locr0->a2;
				args.i[1] = locr0->a3;
			} else {
				code = locr0->a0;
				args.i[0] = locr0->a1;
				args.i[1] = locr0->a2;
				args.i[2] = locr0->a3;
			}
d474 1
a474 12
			if (i > 2 && p->p_md.md_flags & MDP_O32) {
					int32_t p[6];

					i = copyin((int32_t *)locr0->sp + 4,
						p, 6 * sizeof(int32_t));
					args.i[2] = p[0];
					args.i[3] = p[1];
					args.i[4] = p[2];
					args.i[5] = p[3];
					args.i[6] = p[4];
					args.i[7] = p[5];
			} else if (i > 3) {
d496 4
a499 15
				if (p->p_md.md_flags & MDP_O32) {
					int32_t p[4];

					i = copyin((int32_t *)locr0->sp + 4,
						p, 4 * sizeof(int32_t));
					args.i[4] = p[0];
					args.i[5] = p[1];
					args.i[6] = p[2];
					args.i[7] = p[3];
				} else {
					args.i[4] = locr0->a4;
					args.i[5] = locr0->a5;
					args.i[6] = locr0->a6;
					args.i[7] = locr0->a7;
				}
@


1.46
log
@unifdef -DIMASK_EXTERNAL to the mips code. Support for interrupt masking at
coprocessor 0 sr level might come back in the future if hardware support
requires it, but at the moment it's getting in the way of larger changes.
``In the Attic, noone can hear you scream''
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.45 2009/10/22 18:31:51 miod Exp $	*/
d426 1
a426 1
		if ((int)trapframe->cause & CR_BR_DELAY) {
d616 1
a616 1
		if ((int)trapframe->cause & CR_BR_DELAY)
d633 1
a633 1
			if ((int)trapframe->cause & CR_BR_DELAY)
d643 1
a643 1
			if ((int)trapframe->cause & CR_BR_DELAY)
d700 1
a700 1
		if ((int)trapframe->cause & CR_BR_DELAY)
d722 1
a722 1
		if ((int)trapframe->cause & CR_BR_DELAY)
d727 1
a727 1
		if ((int)trapframe->cause & CR_BR_DELAY) {
@


1.45
log
@Remove a never hit debug panic I commited by accident sometime ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.44 2009/08/06 21:05:49 miod Exp $	*/
a212 3
#ifndef IMASK_EXTERNAL
			updateimask(trapframe->cpl);
#endif
a603 3
#ifndef IMASK_EXTERNAL
			updateimask(trapframe->cpl);
#endif
@


1.44
log
@Only compile RM7000 performance counter support if defined(RM7K_PERFCNTR).
This code needs to be cleaned up, and made more generic to work with other
processors counters as well.
@
text
@d1 1
a1 2
/*	$OpenBSD: trap.c,v 1.43 2009/06/10 18:05:31 miod Exp $	*/
/* tracked to 1.23 */
a44 3
/*
 *		THIS CODE SHOULD BE REWRITTEN!
 */
a172 2
if (p->p_md.md_astpending == 0)
panic("unexpected ast p %p astpending %p\n", p, &p->p_md.md_astpending);
@


1.43
log
@Switch sgi to per-process AST, and move ast() from interrupt.c to trap.c
where it can use userret() instead of duplicating it.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.42 2009/05/22 20:37:53 miod Exp $	*/
d715 1
d720 1
d744 1
d753 3
a755 2
		}
		else {
@


1.42
log
@Drop almost unused <machine/psl.h> on sgi; move USERMODE() definition from
there to trap.c which is its only user. This also cleans up multiple
inclusion of <machine/cpu.h> (because <machine/psl.h> includes it) in many
places.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.41 2008/02/20 19:13:38 miod Exp $	*/
a94 1
int	want_resched;	/* resched() was called */
d97 1
a97 1
char	*trap_type[] = {
d129 1
a129 1
	"virtual coherency data",
a132 1
extern register_t *tlbtrcptr;
d135 2
a136 5
void stacktrace(struct trap_frame *);
void logstacktrace(struct trap_frame *);
int  kdbpeek(void *);
/* extern functions printed by name in stack backtraces */
extern void idle(void);
d140 1
a140 1
int  kdb_trap(int, db_regs_t *);
d147 2
a148 1
void trap(struct trap_frame *);
d150 1
a150 1
int cpu_singlestep(struct proc *);
d152 1
a152 1
u_long MipsEmulateBranch(struct trap_frame *, long, int, u_int);
d167 23
a1135 7
}

void
logstacktrace(regs)
	struct trap_frame *regs;
{
	stacktrace_subr(regs, addlog);
@


1.41
log
@More dead includes and functions noone will mourn.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.40 2008/02/18 19:47:36 miod Exp $	*/
a70 1
#include <machine/psl.h>
a87 1
#include <sys/cdefs.h>
d92 2
@


1.40
log
@Use better types and fix tests for pc and sp being in kernel to really
handle XKPHYS addresses correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.39 2007/10/25 16:24:18 miod Exp $	*/
a72 1
#include <machine/pio.h>
@


1.39
log
@Be sure to enable interrupts on return from ddb if they were enabled before
the break.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.38 2007/10/18 04:32:08 miod Exp $	*/
d1132 1
a1132 1
	long pc, sp, fp, ra, va, subr;
d1141 4
a1144 4
	sp = regs->sp;
	pc = regs->pc;
	fp = regs->s8;
	ra = regs->ra;		/* May be a 'leaf' function */
d1162 1
a1162 1
	if (sp & 3 || (!IS_XKPHYS((vaddr_t)sp) && sp < KSEG0_BASE)) {
d1173 1
a1173 1
		       pc-(vaddr_t)MipsKernIntr, a0, a1, a2);
d1194 2
a1195 1
	if (pc & 3 || pc < KSEG0_BASE || pc >= (unsigned)edata) {
@


1.38
log
@Get rid of the silly union for mips pte. No functional change except
pmap.h now includes pte.h.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.37 2007/07/16 20:21:20 miod Exp $	*/
a197 2
	 * If it was off disable all (splhigh) so we don't accidently
	 * enable it when doing a spllower().
d206 1
a206 3
	} else
		splhigh();

d589 1
a590 1
	case T_BREAK:
d592 8
a600 1
#endif
@


1.37
log
@Do not reenabled interrupts when processing a ddb trap, for bad things may
happen; from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.36 2007/05/25 20:47:19 miod Exp $	*/
a75 1
#include <machine/pte.h>
d216 1
a216 2
			pt_entry_t *pte;
			unsigned int entry;
d221 1
a221 1
			entry = pte->pt_entry;
d233 1
a233 1
			pte->pt_entry = entry;
d246 1
a246 2
		pt_entry_t *pte;
		unsigned int entry;
d254 1
a254 1
		entry = pte->pt_entry;
d266 1
a266 1
		pte->pt_entry = entry;
@


1.36
log
@Unifdef TLB_TRACE and TLBTRACE, no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.35 2007/05/09 19:23:17 miod Exp $	*/
a201 1
/*XXX do in locore? */
d203 1
d205 1
a205 1
		updateimask(trapframe->cpl);
d207 2
a208 1
		enableintr();
@


1.35
log
@Change trap() into a void function, and restore pc from the trapframe instead
of having trap() return it. This makes trap() consistent with other
platforms, and its code smaller.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.34 2007/05/07 18:42:13 kettenis Exp $	*/
a862 17

#ifdef TLBTRACE
	if (tlbtrcptr != NULL) {
		register_t *next;

		printf("tlbtrace:\n");
		next = tlbtrcptr;
		do {
			if (next[0] != NULL) {
				printf("pc %p, va %p segtab %p pte %p\n",
				    next[0], next[1], next[2], next[3]);
			}
			next +=  4;
			next = (register_t *)((long)next & ~0x100);
		} while (next != tlbtrcptr);
	}
#endif
@


1.34
log
@Move sgo to __HAVE_CPUINFO.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.33 2007/05/03 19:34:00 miod Exp $	*/
d154 1
a154 1
register_t trap(struct trap_frame *);
d177 1
a177 1
register_t
d241 1
a241 1
			return (trapframe->pc);
d277 1
a277 1
			return (trapframe->pc);
d296 1
a296 1
				return (trapframe->pc);
d299 2
a300 1
				return (onfault_table[onfault]);
d367 1
a367 1
				return (trapframe->pc);
d373 2
a374 1
				return (onfault_table[onfault]);
d598 1
a598 1
		return(trapframe->pc);
d698 1
a698 1
			return (trapframe->pc);
d730 1
a730 1
			return (trapframe->pc);
d781 2
a782 1
			return (onfault_table[onfault]);
d793 2
a794 1
		printf("Trap PC %p RA %p\n", trapframe->pc, trapframe->ra);
a810 1
	return (trapframe->pc);
@


1.33
log
@Enable support for > 512MB of physical memory on mips64 systems, by using
XKPHYS instead of KSEG[01] for direct mappings.

Then, detect memory above 256MB on O2 by poking at the CRIME registers
(ARCbios will not report memory above 256MB, which is mapped above 1GB
physical, to the system), and add it to the UVM managed memory.

Tested on r5k, rm5200 and r10k with and without more than 256MB, matching
hinv reports in all cases. CRIME memory decoding based on a diff from
kettenis@@ in december 2005.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.32 2007/03/27 19:51:00 miod Exp $	*/
d169 1
a169 1
	curpriority = p->p_priority = p->p_usrpri;
@


1.32
log
@When trap() causes a panic, have stacktrace() use ddb to find the symbol
names if option DDB, instead of the fn_name() helper which only knows about
trap() anyway.

While there, do not attempt to print the function arguments after the first
frame, since they are known to be clobbered.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.31 2006/12/24 20:30:35 miod Exp $	*/
d1175 1
a1175 1
	if (sp & 3 || sp < KSEG0_BASE) {
@


1.31
log
@Define PROC_PC. Then, since profiling information is being reported in
statclock(), do not bother doing this in userret() anymore. As a result,
userret() does not need its pc and ticks arguments, simplify.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.30 2006/05/31 20:19:39 miod Exp $	*/
d1118 1
d1120 1
d1169 1
a1169 1
	if	(frames++ > 6) {
d1325 2
a1326 4
	(*printfn)("%s+%x ra %p sp %p (%p,%p,%p,%p)\n",
		fn_name(subr), pc - subr, ra, sp, a0, a1, a2, a3);
#if defined(_LP64)
	a0 = a1 = a2 = a3 = 0x00dead0000dead00;
d1328 1
a1328 1
	a0 = a1 = a2 = a3 = 0x00dead00;
d1330 5
d1353 1
d1382 1
d1384 1
a1384 1
#endif /* DDB */
@


1.30
log
@Reset pcb_onfault before invoking uvm_fault().
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.29 2005/12/17 20:13:44 miod Exp $	*/
d160 12
a183 1
	u_quad_t sticks;
a194 1
		sticks = p->p_sticks;
d806 1
a806 21
	/* take pending signals */
	while ((i = CURSIG(p)) != 0)
		postsig(i);
	p->p_priority = p->p_usrpri;
	astpending = 0;
	if (want_resched) {
		preempt(NULL);
		while ((i = CURSIG(p)) != 0)
			postsig(i);
	}

	/*
	 * If profiling, charge system time to the trapped pc.
	 */
	if (p->p_flag & P_PROFIL) {
		extern int psratio;

		addupc_task(p, trapframe->pc, (int)(p->p_sticks - sticks) * psratio);
	}

	curpriority = p->p_priority;
a815 1
	int i;
d822 1
a822 20
	/* take pending signals */
	while ((i = CURSIG(p)) != 0)
		postsig(i);
	p->p_priority = p->p_usrpri;
	astpending = 0;
	if (want_resched) {
		preempt(NULL);
		while ((i = CURSIG(p)) != 0)
			postsig(i);
	}

#if 0 /* Need sticks */
	if (p->p_flag & P_PROFIL) {
		extern int psratio;

		addupc_task(p, trapframe->pc, (int)(p->p_sticks - sticks) * psratio);
	}
#endif

	curpriority = p->p_priority;
@


1.29
log
@Rename ``dofault'' label to ``fault_common'', it just looks too close to
``default'' and thus can make your code reading experience more difficult...
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.28 2005/12/12 18:59:04 miod Exp $	*/
d175 1
d279 1
a279 1
		kernel_fault:
d281 2
d284 1
d287 1
a287 1
			if ((i = p->p_addr->u_pcb.pcb_onfault) != 0) {
d289 1
a289 1
				return (onfault_table[i]);
d295 6
a300 2
		 * through the copyin/copyout routines. However we allow
		 * accesses to the top of user stack for compat emul data.
d306 2
d309 5
a313 1
		if ((i = p->p_addr->u_pcb.pcb_onfault) == 0) {
d315 2
a317 2
#undef szsigcode
		goto fault_common;
d335 3
d339 2
a340 5
#if defined(VMFAULT_TRACE)
		printf("vm_fault(%p (pmap %p), %p (%p), %x, %d) -> %x at pc %p\n",
		    map, &vm->vm_map.pmap, va, trapframe->badvaddr, ftype, FALSE, rv, trapframe->pc);
printf("sp %p\n", trapframe->sp);
#endif
d360 1
a360 1
			if ((i = p->p_addr->u_pcb.pcb_onfault) != 0) {
d362 1
a362 1
				return (onfault_table[i]);
d767 1
a767 1
		if ((i = p->p_addr->u_pcb.pcb_onfault) != 0) {
d769 1
a769 1
			return (onfault_table[i]);
d771 1
a771 1
		/* FALLTHROUGH */
@


1.28
log
@Nuke leftover references to procfs_mem.h.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.27 2005/12/11 21:30:30 miod Exp $	*/
d254 1
a254 1
			goto dofault;
d297 1
a297 1
			goto dofault;
d300 1
a300 1
			goto dofault;
d303 1
a303 1
		goto dofault;
d307 1
a307 1
		goto dofault;
d311 1
a311 1
	dofault:
@


1.27
log
@Replace procfs_domem() with a similar interface, process_domem(), which lives
out of procfs and gets a ptrace request PT_{READ,WRITE}_{I,D} as argument;
also procfs_checkioperm() becomes process_checkioperm().

From art@@ some time ago; ok kettenis@@ pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.26 2005/11/06 10:26:56 martin Exp $	*/
d63 3
a66 1
#include <miscfs/procfs/procfs.h>
@


1.26
log
@byebye Mach macros

testing and ok kettenis@@, hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.25 2005/10/24 20:20:03 kettenis Exp $	*/
d633 2
a634 1
				error = procfs_domem(p, p, NULL, &uio);
d1071 1
a1071 1
	procfs_domem(curproc, p, NULL, &uio);
d1098 1
a1098 1
	procfs_domem(curproc, p, NULL, &uio);
d1112 1
a1112 1
	error = procfs_domem(curproc, p, NULL, &uio);
@


1.25
log
@Conditionalize singler-step code on PTRACE.
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.24 2005/09/15 21:14:27 miod Exp $	*/
d66 2
d215 1
a215 1
			    mips_trunc_page(trapframe->badvaddr), entry)) {
d249 1
a249 1
		    mips_trunc_page(trapframe->badvaddr), entry)) {
@


1.24
log
@In syscall(), do not recompute the struct proc * after the syscall has
succeeded. This used to be necessary for fork(), when returning in the child,
but we return in the child in child_return() which does TRT.

ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.23 2005/09/15 21:09:29 miod Exp $	*/
d151 1
d153 1
a574 2
		struct uio uio;
		struct iovec iov;
a575 1
		int error;
d612 1
d615 4
d646 1
d1037 2
d1122 2
@


1.23
log
@Change child_return() to record a proper ktrace record for vfork child
processes.

ok art@@ uwe@@ (some time ago)
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.22 2005/01/31 21:35:50 grange Exp $	*/
a531 8
		/*
		 * Reinitialize proc pointer `p' as it may be different
		 * if this is a child returning from fork syscall.
		 */
		p = curproc;
		locr0 = p->p_md.md_regs;

		trapdebug_enter(locr0, -code);
@


1.22
log
@Un-__P.

ok pefo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.21 2005/01/18 15:03:38 grange Exp $	*/
d840 2
a841 1
		ktrsysret(p, SYS_fork, 0, 0);
@


1.21
log
@Move rm7000.h file from sgi to mips64.

ok pefo@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.20 2004/12/24 22:50:30 miod Exp $	*/
d139 1
a139 1
extern void idle __P((void));
d1128 1
a1128 1
void stacktrace_subr __P((struct trap_frame *, int (*)(const char*, ...)));
d1150 1
a1150 1
	int (*printfn) __P((const char*, ...));
@


1.20
log
@{e,}intr{cnt,names} bye-bye.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.19 2004/12/06 20:12:24 miod Exp $	*/
d78 1
a78 1
#include <machine/rm7000.h>
@


1.19
log
@Use uvm_grow() to account for stack growth, rather than home-grown code
or nothing.
Inspired by a similar recent change in NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.18 2004/11/11 19:00:37 kettenis Exp $	*/
a145 1
extern u_long intrcnt[];
@


1.18
log
@Somewhat improve single-stepping.
ok pefo@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.17 2004/11/09 19:06:18 kettenis Exp $	*/
d276 1
a276 1
			if (rv == KERN_SUCCESS)
d330 4
a333 8
			if (rv == KERN_SUCCESS) {
				unsigned nss;

				nss = btoc(USRSTACK-(unsigned)va);
				if (nss > vm->vm_ssize)
					vm->vm_ssize = nss;
			} else if (rv == KERN_PROTECTION_FAILURE)
				rv = KERN_INVALID_ADDRESS;
d335 1
a335 1
		if (rv == KERN_SUCCESS) {
@


1.17
log
@Fix single-stepping.
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.16 2004/10/30 14:49:39 pefo Exp $	*/
d589 1
d640 1
a640 1
				i = procfs_domem(p, p, NULL, &uio);
d643 1
a643 1
				if (i < 0)
d1055 1
a1055 1
	int i;
d1087 1
a1087 1
	p->p_md.md_ss_addr = va;
d1114 1
a1114 1
	i = procfs_domem(curproc, p, NULL, &uio);
d1116 2
d1119 1
a1119 2
	if (i < 0)
		return (EFAULT);
@


1.16
log
@remove debug
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.15 2004/10/30 14:48:59 pefo Exp $	*/
d153 1
a153 1
u_long MipsEmulateBranch(struct trap_frame *, long, int, long);
d904 1
a904 1
MipsEmulateBranch(framePtr, instPC, fpcCSR, instptr)
d908 1
a908 1
	long instptr;
d919 2
a920 2
	if (instptr) {
		inst = *(InstFmt *)&instptr;
@


1.15
log
@Make the default boot partition p.
Migrate float exception code to 64 bit. Add a few new "uniplemented".
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.14 2004/10/20 12:49:15 pefo Exp $	*/
a742 1
printf("FPU Trap, pc=%p instr=0x%08x\n", trapframe->pc, *(int *)trapframe->pc);
@


1.14
log
@Fix some 64 bit address problems.
Some function names made more unique.
Other changes for the upcoming Origin 200 support.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.13 2004/10/08 07:45:15 grange Exp $	*/
d149 1
a149 1
extern void MipsFPTrap(u_int, u_int, u_int);
d743 3
a745 1
		MipsFPTrap(trapframe->sr, trapframe->cause, trapframe->pc);
d779 1
a779 1
	sv.sival_int = trapframe->badvaddr;
@


1.13
log
@Fix DDB/DEBUG ifdefs dance.

Help and ok from miod, ok pefo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.12 2004/09/23 08:42:38 pefo Exp $	*/
d852 1
d857 1
d860 2
a861 2
		if (trp == trapdebug) {
			trp = &trapdebug[TRAPSIZE - 1];
d864 1
a864 1
			trp--;
d867 1
a867 1
		if (trp->cause == 0)
d871 2
a872 2
		    trap_type[(trp->cause & CR_EXC_CODE) >> CR_EXC_CODE_SHIFT],
		    trp->pc, trp->cause, trp->status);
d874 1
a874 1
		printf("  RA %p SP %p ADR %p\n", trp->ra, trp->sp, trp->vadr);
@


1.12
log
@More pmap bugs cleaned out. Some old, some new.
Better structured pmap.c.
Evil still in there, more work to do.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.11 2004/09/22 14:39:44 miod Exp $	*/
d763 1
a763 1
#ifndef DDB
d768 1
a769 1
#ifdef DDB
@


1.11
log
@Add systrace support.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.10 2004/09/21 08:53:51 miod Exp $	*/
d219 1
a219 2
			trapframe->badvaddr &= ~PGOFSET;
			tlb_update(trapframe->badvaddr, entry);
d239 1
a239 1
		pte += (trapframe->badvaddr >> PGSHIFT) & (NPTEPG - 1);
d253 2
a254 3
		trapframe->badvaddr = (trapframe->badvaddr & ~PGOFSET) |
		    (pmap->pm_tlbpid << VMTLB_PID_SHIFT);
		tlb_update(trapframe->badvaddr, entry);
d588 1
d596 2
a597 1
		copyin(&instr, va, sizeof(int32_t));
d603 49
a651 1
		if (p->p_md.md_ss_addr != (long)va || instr != BREAK_SSTEP) {
d653 2
d656 1
a659 22
		/*
		 * Restore original instruction and clear BP
		 */
		iov.iov_base = (caddr_t)&p->p_md.md_ss_instr;
		iov.iov_len = sizeof(int);
		uio.uio_iov = &iov;
		uio.uio_iovcnt = 1;
		uio.uio_offset = (off_t)(long)va;
		uio.uio_resid = sizeof(int);
		uio.uio_segflg = UIO_SYSSPACE;
		uio.uio_rw = UIO_WRITE;
		uio.uio_procp = curproc;
		i = procfs_domem(p, p, NULL, &uio);
		Mips_SyncCache();

		if (i < 0)
			printf("Warning: can't restore instruction at %x: %x\n",
				p->p_md.md_ss_addr, p->p_md.md_ss_instr);

		p->p_md.md_ss_addr = 0;
		i = SIGTRAP;
		typ = TRAP_BRKPT;
d692 1
a692 1
		copyin(&instr, va, sizeof(int32_t));
d696 1
a696 2
		}
		else {
@


1.10
log
@trap() should return a 64 bit value now.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.9 2004/09/21 05:51:15 miod Exp $	*/
a49 3
#include "ppp.h"
#include "bridge.h"

d90 3
d533 6
a538 1
		i = (*callp->sy_call)(p, &args, rval);
@


1.9
log
@Nuke commons.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.8 2004/09/17 19:19:08 miod Exp $	*/
d151 1
a151 1
u_int trap(struct trap_frame *);
d160 1
a160 1
unsigned
d1016 1
a1016 1
	unsigned va;
d1158 1
a1158 1
	if (pc >= (unsigned)MipsKernIntr && pc < (unsigned)MipsUserIntr) {
d1160 1
a1160 1
		       pc-(unsigned)MipsKernIntr, a0, a1, a2);
d1178 1
a1178 1
		Between((unsigned)a, pc, (unsigned)b)
@


1.8
log
@Long-due mips pmap potpourri:
- un-__P()ee.
- remove splimp() protection.
- allow pmap_extract() to return FALSE, dammit!
  XXX some code under arch/mips64 considers pa == 0 as failure, instead
      of checking the return value of pmap_extract(). Free commits.
- do not peek at uvm vm_page flags for ref/mod accounting, but use real
  MD flags in pv lists, and implement pmap_is_* and pmap_clear_*, so uvm
  (which knows better) does the right thing.
- debug code #ifdef PMAPDEBUG, not #ifdef DIAGNOSTIC.
- merge pmap_init() and pmap_pinit(), pmap_destroy() and pmap_release(),
  and update comments.
- better pmap_enter() logic, from NetBSD.
- do not use IS_VM_PHYSADDR() to know if we can use PHYS_TO_VM_PAGE()
  unchecked. Instead, compute PHYS_TO_VM_PAGE(), and check it against
  NULL. Saves a vm_physseg_find() call each time.
- pass vm_page_t to internal function whenever possible, rather than
  paddr_t, so that PHYS_TO_VM_PAGE() needs not be computed again.
- in the same way, do not compute PHYS_TO_KSEG0(foo) several times in a
  row (though PHYS_TO_KSEG0 is trivial).
- allow userspace address to cross 0x80000000 (may be useful in the
  future).
- implement PMAP_CANFAIL.

As a bonus:
- switch from HAVE_PMAP_PHYSSEG to HAVE_VM_PAGE_MD.
- remove dead (pre-pmap_pv_pool) code.
- KNF fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.7 2004/09/16 09:58:56 miod Exp $	*/
d93 1
@


1.7
log
@Use preempt() instead of rolling our own version.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.6 2004/09/16 07:25:26 miod Exp $	*/
d198 1
a198 1
		if ((int)trapframe->badvaddr < 0) {
d201 2
a202 1
			vaddr_t pa;
d210 2
a211 1
			if (pmap_is_page_ro(pmap_kernel(), mips_trunc_page(trapframe->badvaddr), entry)) {
d221 2
a222 1
			if (!IS_VM_PHYSADDR(pa))
d224 1
a224 1
			PHYS_TO_VM_PAGE(pa)->flags &= ~PG_CLEAN;
d234 1
d242 1
a242 1
		if (!(entry & PG_V) || (entry & PG_M)) {
a243 1
		}
d245 2
a246 1
		if (pmap_is_page_ro(pmap, (vaddr_t)mips_trunc_page(trapframe->badvaddr), entry)) {
d253 2
a254 1
		trapframe->badvaddr = (trapframe->badvaddr & ~PGOFSET) | (pmap->pm_tlbpid << VMTLB_PID_SHIFT);
d257 2
a258 1
		if (!IS_VM_PHYSADDR(pa)) {
d260 1
a260 2
		}
		PHYS_TO_VM_PAGE(pa)->flags &= ~PG_CLEAN;
@


1.6
log
@``viritual'' is a virtual word and this is a real tree.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.5 2004/09/09 22:11:38 pefo Exp $	*/
d750 1
a750 15
		int s;

		/*
		 * Since we are curproc, clock will normally just change
		 * our priority without moving us from one queue to another
		 * (since the running process is not on a queue.)
		 * If that happened after we put ourselves on the run queue
		 * but before we switched, we might not be on the queue
		 * indicated by our priority.
		 */
		s = splstatclock();
		setrunqueue(p);
		p->p_stats->p_ru.ru_nivcsw++;
		mi_switch();
		splx(s);
d787 1
a787 15
		int s;

		/*
		 * Since we are curproc, clock will normally just change
		 * our priority without moving us from one queue to another
		 * (since the running process is not on a queue.)
		 * If that happened after we put ourselves on the run queue
		 * but before we switched, we might not be on the queue
		 * indicated by our priority.
		 */
		s = splstatclock();
		setrunqueue(p);
		p->p_stats->p_ru.ru_nivcsw++;
		mi_switch();
		splx(s);
@


1.5
log
@Kernel moves to 64 bit. A few more tweaks when binutils is updated.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.4 2004/08/10 20:28:13 deraadt Exp $	*/
d110 1
a110 1
	"viritual coherency instruction",
d127 1
a127 1
	"viritual coherency data",
@


1.4
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.3 2004/08/10 20:15:47 deraadt Exp $	*/
d168 1
a168 1
	extern unsigned onfault_table[];
d316 1
d431 2
a432 3
					i = copyin((void *)(locr0->sp +
					    7 * sizeof(register_t)), &args.i[7],
					    sizeof(register_t));
d478 1
a478 2
				i = copyin((void *)(locr0->sp +
				    7 * sizeof(register_t)), &args.i[7],
d605 1
a605 1
		uio.uio_offset = (off_t)(int)va;
d1171 2
a1172 2
	if (sp & 3 || sp < 0xffffffff80000000) {
		(*printfn)("SP 0x%x: not in kernel\n", sp);
d1203 2
a1204 2
	if (pc & 3 || pc < 0xffffffff80000000 || pc >= (unsigned)edata) {
		(*printfn)("PC 0x%x: not in kernel\n", pc);
@


1.3
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.2 2004/08/08 14:21:27 pefo Exp $	*/
d443 1
a443 1
				if(_QUAD_LOWWORD == 0) {
d633 1
a633 1
		if(rm7k_watchintr(trapframe)) {
d661 1
a661 1
		if(instr == 0x040c0000) { /* Performance cntr trap */
d906 1
a906 1
	if(instptr) {
d1062 1
a1062 1
	if(curinstr != 0) {
@


1.2
log
@Various fixes and cleanups from miod@@, tested and OK.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.1 2004/08/06 20:56:03 pefo Exp $	*/
d460 1
a460 1
				callp += code; 
d603 1
a603 1
		iov.iov_len = sizeof(int); 
d605 1
a605 1
		uio.uio_iovcnt = 1; 
d834 1
a834 1
#endif 
d1051 1
a1051 1
	iov.iov_len = sizeof(int); 
d1053 1
a1053 1
	uio.uio_iovcnt = 1; 
d1078 1
a1078 1
	iov.iov_len = sizeof(int); 
d1080 1
a1080 1
	uio.uio_iovcnt = 1; 
d1092 1
a1092 1
	iov.iov_len = sizeof(int); 
d1094 1
a1094 1
	uio.uio_iovcnt = 1; 
d1234 1
a1234 1
	     		      more = (more == 3) ? 3 : more - 1) {
@


1.1
log
@initial mips64
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.19 1998/09/30 12:40:41 pefo Exp $	*/
d186 1
a186 1
	if(trapframe->sr & SR_INT_ENAB) {
a293 3
		/* check for fuswintr() or suswintr() getting a page fault */
		if (i == 5)
			return (onfault_table[i]);
d556 1
a556 1
		if(code == SYS_ptrace)
@

