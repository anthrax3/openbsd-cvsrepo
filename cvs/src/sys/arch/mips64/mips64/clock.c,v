head	1.41;
access;
symbols
	OPENBSD_6_1:1.41.0.4
	OPENBSD_6_1_BASE:1.41
	OPENBSD_6_0:1.41.0.2
	OPENBSD_6_0_BASE:1.41
	OPENBSD_5_9:1.40.0.2
	OPENBSD_5_9_BASE:1.40
	OPENBSD_5_8:1.40.0.4
	OPENBSD_5_8_BASE:1.40
	OPENBSD_5_7:1.39.0.4
	OPENBSD_5_7_BASE:1.39
	OPENBSD_5_6:1.39.0.8
	OPENBSD_5_6_BASE:1.39
	OPENBSD_5_5:1.39.0.6
	OPENBSD_5_5_BASE:1.39
	OPENBSD_5_4:1.39.0.2
	OPENBSD_5_4_BASE:1.39
	OPENBSD_5_3:1.38.0.2
	OPENBSD_5_3_BASE:1.38
	OPENBSD_5_2:1.37.0.2
	OPENBSD_5_2_BASE:1.37
	OPENBSD_5_1_BASE:1.36
	OPENBSD_5_1:1.36.0.4
	OPENBSD_5_0:1.36.0.2
	OPENBSD_5_0_BASE:1.36
	OPENBSD_4_9:1.34.0.2
	OPENBSD_4_9_BASE:1.34
	OPENBSD_4_8:1.33.0.4
	OPENBSD_4_8_BASE:1.33
	OPENBSD_4_7:1.33.0.2
	OPENBSD_4_7_BASE:1.33
	OPENBSD_4_6:1.23.0.4
	OPENBSD_4_6_BASE:1.23
	OPENBSD_4_5:1.21.0.2
	OPENBSD_4_5_BASE:1.21
	OPENBSD_4_4:1.20.0.2
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.19.0.2
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.18.0.2
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.17.0.4
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.17.0.2
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.16.0.4
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.16.0.2
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.13.0.2
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.6.0.2
	OPENBSD_3_6_BASE:1.6;
locks; strict;
comment	@ * @;


1.41
date	2016.03.06.19.42.27;	author mpi;	state Exp;
branches;
next	1.40;
commitid	cyYKarj4qRTft4gD;

1.40
date	2015.05.01.11.17.22;	author miod;	state Exp;
branches;
next	1.39;
commitid	nmL9Wvs1cOBMQGl7;

1.39
date	2013.06.03.16.55.22;	author guenther;	state Exp;
branches;
next	1.38;

1.38
date	2012.10.03.11.18.23;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2012.07.14.19.50.12;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2011.07.10.17.47.41;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2011.05.10.07.42.16;	author syuu;	state Exp;
branches;
next	1.34;

1.34
date	2010.09.20.06.33.47;	author matthew;	state Exp;
branches;
next	1.33;

1.33
date	2010.02.28.17.23.25;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2010.01.09.20.33.16;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2009.12.28.06.55.27;	author syuu;	state Exp;
branches;
next	1.30;

1.30
date	2009.11.26.23.32.46;	author syuu;	state Exp;
branches;
next	1.29;

1.29
date	2009.11.22.22.15.25;	author syuu;	state Exp;
branches;
next	1.28;

1.28
date	2009.11.22.18.33.48;	author syuu;	state Exp;
branches;
next	1.27;

1.27
date	2009.11.21.23.28.14;	author syuu;	state Exp;
branches;
next	1.26;

1.26
date	2009.10.26.20.14.40;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2009.10.22.22.08.54;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2009.10.22.20.05.27;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2009.05.06.20.02.45;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2009.03.20.18.41.06;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2008.09.23.04.33.07;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2008.04.07.22.36.26;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2008.02.20.18.46.18;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2007.04.29.17.35.27;	author kettenis;	state Exp;
branches;
next	1.17;

1.17
date	2006.06.19.15.13.35;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2005.05.02.18.17.52;	author grange;	state Exp;
branches;
next	1.15;

1.15
date	2005.05.01.15.15.08;	author grange;	state Exp;
branches;
next	1.14;

1.14
date	2005.04.29.18.41.12;	author grange;	state Exp;
branches;
next	1.13;

1.13
date	2005.02.13.22.04.34;	author grange;	state Exp;
branches;
next	1.12;

1.12
date	2005.01.31.21.43.14;	author grange;	state Exp;
branches;
next	1.11;

1.11
date	2005.01.31.21.39.59;	author grange;	state Exp;
branches;
next	1.10;

1.10
date	2005.01.31.21.25.21;	author grange;	state Exp;
branches;
next	1.9;

1.9
date	2004.10.20.12.49.15;	author pefo;	state Exp;
branches;
next	1.8;

1.8
date	2004.09.24.14.22.49;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2004.09.16.09.23.21;	author pefo;	state Exp;
branches;
next	1.6;

1.6
date	2004.08.11.17.05.31;	author pefo;	state Exp;
branches;
next	1.5;

1.5
date	2004.08.10.20.15.47;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2004.08.10.13.45.40;	author pefo;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.09.21.01.32;	author pefo;	state Exp;
branches;
next	1.2;

1.2
date	2004.08.09.14.57.26;	author pefo;	state Exp;
branches;
next	1.1;

1.1
date	2004.08.06.20.56.03;	author pefo;	state Exp;
branches;
next	;


desc
@@


1.41
log
@Rename mips64's trap_frame into trapframe.

For coherency with other archs and in order to use it in MI code.

ok visa@@, tobiasu@@
@
text
@/*	$OpenBSD: clock.c,v 1.40 2015/05/01 11:17:22 miod Exp $ */

/*
 * Copyright (c) 2001-2004 Opsycon AB  (www.opsycon.se / www.opsycon.com)
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

/*
 * Clock code for systems using the on-cpu counter register, when both the
 * counter and comparator registers are available (i.e. everything MIPS-III
 * or MIPS-IV capable but the R8000).
 *
 * On most processors, this register counts at half the pipeline frequency.
 */

#include <sys/param.h>
#include <sys/kernel.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/evcount.h>

#include <machine/autoconf.h>
#include <machine/cpu.h>
#include <mips64/mips_cpu.h>

#include <mips64/dev/clockvar.h>

static struct evcount cp0_clock_count;
static int cp0_clock_irq = 5;

int	clockmatch(struct device *, void *, void *);
void	clockattach(struct device *, struct device *, void *);

struct cfdriver clock_cd = {
	NULL, "clock", DV_DULL
};

struct cfattach clock_ca = {
	sizeof(struct device), clockmatch, clockattach
};

void	cp0_startclock(struct cpu_info *);
uint32_t cp0_int5(uint32_t, struct trapframe *);

int
clockmatch(struct device *parent, void *vcf, void *aux)
{
	struct mainbus_attach_args *maa = aux;

#ifdef CPU_R8000
	return 0;	/* shouldn't be in the kernel configuration anyway */
#endif
	return strcmp(maa->maa_name, clock_cd.cd_name) == 0;
}

void
clockattach(struct device *parent, struct device *self, void *aux)
{
	printf(": int 5\n");

	/*
	 * We need to register the interrupt now, for idle_mask to
	 * be computed correctly.
	 */
	set_intr(INTPRI_CLOCK, CR_INT_5, cp0_int5);
	evcount_attach(&cp0_clock_count, "clock", &cp0_clock_irq);

	/* try to avoid getting clock interrupts early */
	cp0_set_compare(cp0_get_count() - 1);

	md_startclock = cp0_startclock;
}

/*
 *  Interrupt handler for targets using the internal count register
 *  as interval clock. Normally the system is run with the clock
 *  interrupt always enabled. Masking is done here and if the clock
 *  can not be run the tick is just counted and handled later when
 *  the clock is logically unmasked again.
 */
uint32_t
cp0_int5(uint32_t mask, struct trapframe *tf)
{
	u_int32_t clkdiff;
	struct cpu_info *ci = curcpu();

	/*
	 * If we got an interrupt before we got ready to process it,
	 * retrigger it as far as possible. cpu_initclocks() will
	 * take care of retriggering it correctly.
	 */
	if (ci->ci_clock_started == 0) {
		cp0_set_compare(cp0_get_count() - 1);

		return CR_INT_5;
	}

	/*
	 * Count how many ticks have passed since the last clock interrupt...
	 */
	clkdiff = cp0_get_count() - ci->ci_cpu_counter_last;
	while (clkdiff >= ci->ci_cpu_counter_interval) {
		ci->ci_cpu_counter_last += ci->ci_cpu_counter_interval;
		clkdiff = cp0_get_count() - ci->ci_cpu_counter_last;
		ci->ci_pendingticks++;
	}
	ci->ci_pendingticks++;
	ci->ci_cpu_counter_last += ci->ci_cpu_counter_interval;

	/*
	 * Set up next tick, and check if it has just been hit; in this
	 * case count it and schedule one tick ahead.
	 */
	cp0_set_compare(ci->ci_cpu_counter_last);
	clkdiff = cp0_get_count() - ci->ci_cpu_counter_last;
	if ((int)clkdiff >= 0) {
		ci->ci_cpu_counter_last += ci->ci_cpu_counter_interval;
		ci->ci_pendingticks++;
		cp0_set_compare(ci->ci_cpu_counter_last);
	}

	/*
	 * Process clock interrupt unless it is currently masked.
	 */
	if (tf->ipl < IPL_CLOCK) {
#ifdef MULTIPROCESSOR
		register_t sr;

		sr = getsr();
		ENABLEIPI();
#endif
		while (ci->ci_pendingticks) {
			cp0_clock_count.ec_count++;
			hardclock(tf);
			ci->ci_pendingticks--;
		}
#ifdef MULTIPROCESSOR
		setsr(sr);
#endif
	}

	return CR_INT_5;	/* Clock is always on 5 */
}

/*
 * Start the real-time and statistics clocks. Leave stathz 0 since there
 * are no other timers available.
 */
void
cp0_startclock(struct cpu_info *ci)
{
	int s;

#ifdef MULTIPROCESSOR
	if (!CPU_IS_PRIMARY(ci)) {
		s = splhigh();
		nanouptime(&ci->ci_schedstate.spc_runtime);
		splx(s);

		/* try to avoid getting clock interrupts early */
		cp0_set_compare(cp0_get_count() - 1);

		cp0_calibrate(ci);
	}
#endif

	/* Start the clock. */
	s = splclock();
	ci->ci_cpu_counter_interval =
	    (ci->ci_hw.clock / CP0_CYCLE_DIVIDER) / hz;
	ci->ci_cpu_counter_last = cp0_get_count() + ci->ci_cpu_counter_interval;
	cp0_set_compare(ci->ci_cpu_counter_last);
	ci->ci_clock_started++;
	splx(s);
}
@


1.40
log
@Do not grab the kernel lock for clock interrupts. Help and ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.39 2013/06/03 16:55:22 guenther Exp $ */
d64 1
a64 1
uint32_t cp0_int5(uint32_t, struct trap_frame *);
d103 1
a103 1
cp0_int5(uint32_t mask, struct trap_frame *tf)
@


1.39
log
@Convert some internal APIs to use timespecs instead of timevals

ok matthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.38 2012/10/03 11:18:23 miod Exp $ */
d149 1
a149 1
		/* Enable interrupts at this (hardware) level again */
a151 1
		__mp_lock(&kernel_lock);
a158 1
		__mp_unlock(&kernel_lock);
@


1.38
log
@Split ever-growing mips <machine/cpu.h> into what 99% of the kernel needs,
which will remain in <machine/cpu.h>, and a new mips_cpu.h containing only the
goriest md details, which are only of interest to a handful set of files; this
is similar in spirit to what alpha does, but here <machine/cpu.h> does not
include the new file.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.37 2012/07/14 19:50:12 miod Exp $ */
d180 1
a180 1
		microuptime(&ci->ci_schedstate.spc_runtime);
@


1.37
log
@Split the existing mips64 clock code into time-of-day and generic duties in
machdep.c, and internal clock interrupting on level 5, still in clock.c; this
will allow other clock sources to be used in the near future. (delay() will
remain tied to the internal clock)
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.36 2011/07/10 17:47:41 miod Exp $ */
d45 1
@


1.36
log
@Do not register the per-cpu counter as a system timecounter on MULTIPROCESSOR
kernels, as there is no way to sync the counters between all processors.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.35 2011/05/10 07:42:16 syuu Exp $ */
d29 8
a41 1
#include <sys/timetc.h>
d45 1
a46 1
#include <mips64/archtype.h>
d48 2
a49 2
static struct evcount clk_count;
static int clk_irq = 5;
d62 2
a63 22
void	clock_calibrate(struct cpu_info *);
uint32_t clock_int5(uint32_t, struct trap_frame *);

#ifndef MULTIPROCESSOR
u_int cp0_get_timecount(struct timecounter *);

struct timecounter cp0_timecounter = {
	cp0_get_timecount,	/* get_timecount */
	0,			/* no poll_pps */
	0xffffffff,		/* counter_mask */
	0,			/* frequency */
	"CP0",			/* name */
	0			/* quality */
};
#endif

#define	SECMIN	(60)		/* seconds per minute */
#define	SECHOUR	(60*SECMIN)	/* seconds per hour */

#define	YEARDAYS(year)	(((((year) + 1900) % 4) == 0 && \
			 ((((year) + 1900) % 100) != 0 || \
			  (((year) + 1900) % 400) == 0)) ? 366 : 365)
d70 4
a73 4
	if (strcmp(maa->maa_name, clock_cd.cd_name) != 0)
		return 0;

	return 10;	/* Try to get clock early */
d79 1
a79 1
	printf(": ticker on int5 using count register\n");
d85 3
a87 2
	set_intr(INTPRI_CLOCK, CR_INT_5, clock_int5);
	evcount_attach(&clk_count, "clock", &clk_irq);
d90 2
a94 9
 *	Clock interrupt code for machines using the on cpu chip
 *	counter register. This register counts at half the pipeline
 *	frequency so the frequency must be known and the options
 *	register wired to allow its use.
 *
 *	The code is enabled by setting 'cpu_counter_interval'.
 */

/*
d99 1
a99 1
 *  the clock is unmasked again.
d102 1
a102 1
clock_int5(uint32_t mask, struct trap_frame *tf)
d147 1
a147 1
		u_int32_t sr;
d154 1
a154 1
			clk_count.ec_count++;
a167 67
 * Wait "n" microseconds.
 */
void
delay(int n)
{
	int dly;
	int p, c;
	struct cpu_info *ci = curcpu();
	uint32_t delayconst;

	delayconst = ci->ci_delayconst;
	if (delayconst == 0)
#if CPU_OCTEON
		delayconst = bootcpu_hwinfo.clock;
#else
		delayconst = bootcpu_hwinfo.clock / 2;
#endif
	p = cp0_get_count();
	dly = (delayconst / 1000000) * n;
	while (dly > 0) {
		c = cp0_get_count();
		dly -= c - p;
		p = c;
	}
}

/*
 *	Mips machine independent clock routines.
 */

struct tod_desc sys_tod;

/*
 * Calibrate cpu clock against the TOD clock if available.
 */
void
clock_calibrate(struct cpu_info *ci)
{
	struct tod_desc *cd = &sys_tod;
	struct tod_time ct;
	u_int first_cp0, second_cp0, cycles_per_sec;
	int first_sec;

	if (cd->tod_get == NULL)
		return;

	(*cd->tod_get)(cd->tod_cookie, 0, &ct);
	first_sec = ct.sec;

	/* Let the clock tick one second. */
	do {
		first_cp0 = cp0_get_count();
		(*cd->tod_get)(cd->tod_cookie, 0, &ct);
	} while (ct.sec == first_sec);
	first_sec = ct.sec;
	/* Let the clock tick one more second. */
	do {
		second_cp0 = cp0_get_count();
		(*cd->tod_get)(cd->tod_cookie, 0, &ct);
	} while (ct.sec == first_sec);

	cycles_per_sec = second_cp0 - first_cp0;
	ci->ci_hw.clock = cycles_per_sec * 2;
	ci->ci_delayconst = cycles_per_sec;
}

/*
d172 1
a172 26
cpu_initclocks()
{
	struct cpu_info *ci = curcpu();

	hz = 100;
	profhz = 100;
	stathz = 0;	/* XXX no stat clock yet */

	clock_calibrate(ci);

	tick = 1000000 / hz;	/* number of micro-seconds between interrupts */
	tickadj = 240000 / (60 * hz);		/* can adjust 240ms in 60s */

#ifndef MULTIPROCESSOR
#ifdef CPU_OCTEON
	cp0_timecounter.tc_frequency = (uint64_t)ci->ci_hw.clock;
#else
	cp0_timecounter.tc_frequency = (uint64_t)ci->ci_hw.clock / 2;
#endif
	tc_init(&cp0_timecounter);
#endif
	cpu_startclock(ci);
}

void
cpu_startclock(struct cpu_info *ci)
d176 1
d185 1
a185 1
		clock_calibrate(ci);
d187 1
d191 2
a192 5
#ifdef CPU_OCTEON
	ci->ci_cpu_counter_interval = (ci->ci_hw.clock) / hz;
#else
	ci->ci_cpu_counter_interval = (ci->ci_hw.clock / 2) / hz;
#endif
a197 144

/*
 * We assume newhz is either stathz or profhz, and that neither will
 * change after being set up above.  Could recalculate intervals here
 * but that would be a drag.
 */
void
setstatclockrate(int newhz)
{
}

/*
 * This code is defunct after 2099. Will Unix still be here then??
 */
static short dayyr[12] = {
	0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334
};

/*
 * Initialize the time of day register, based on the time base which
 * is, e.g. from a filesystem.
 */
void
inittodr(time_t base)
{
	struct timespec ts;
	struct tod_time c;
	struct tod_desc *cd = &sys_tod;
	int days, yr;

	ts.tv_nsec = 0;

	if (base < 35 * SECYR) {
		printf("WARNING: preposterous time in file system");
		/* read the system clock anyway */
		base = 40 * SECYR;	/* 2010 */
	}

	/*
	 * Read RTC chip registers NOTE: Read routines are responsible
	 * for sanity checking clock. Dates after 19991231 should be
	 * returned as year >= 100.
	 */
	if (cd->tod_get) {
		(*cd->tod_get)(cd->tod_cookie, base, &c);
	} else {
		printf("WARNING: No TOD clock, believing file system.\n");
		goto bad;
	}

	days = 0;
	for (yr = 70; yr < c.year; yr++) {
		days += YEARDAYS(yr);
	}

	days += dayyr[c.mon - 1] + c.day - 1;
	if (YEARDAYS(c.year) == 366 && c.mon > 2) {
		days++;
	}

	/* now have days since Jan 1, 1970; the rest is easy... */
	ts.tv_sec = days * SECDAY + c.hour * 3600 + c.min * 60 + c.sec;
	tc_setclock(&ts);
	cd->tod_valid = 1;

	/*
	 * See if we gained/lost time.
	 */
	if (base < ts.tv_sec - 5*SECYR) {
		printf("WARNING: file system time much less than clock time\n");
	} else if (base > ts.tv_sec + 5*SECYR) {
		printf("WARNING: clock time much less than file system time\n");
		printf("WARNING: using file system time\n");
	} else {
		return;
	}

bad:
	ts.tv_sec = base;
	tc_setclock(&ts);
	cd->tod_valid = 1;
	printf("WARNING: CHECK AND RESET THE DATE!\n");
}

/*
 * Reset the TOD clock. This is done when the system is halted or
 * when the time is reset by the stime system call.
 */
void
resettodr()
{
	struct tod_time c;
	struct tod_desc *cd = &sys_tod;
	int t, t2;

	/*
	 *  Don't reset TOD if time has not been set!
	 */
	if (!cd->tod_valid)
		return;

	/* compute the day of week. 1 is Sunday*/
	t2 = time_second / SECDAY;
	c.dow = (t2 + 5) % 7 + 1;	/* 1/1/1970 was thursday */

	/* compute the year */
	t = 0;
	t2 = time_second / SECDAY;
	c.year = 69;
	while (t2 >= 0) {	/* whittle off years */
		t = t2;
		c.year++;
		t2 -= YEARDAYS(c.year);
	}

	/* t = month + day; separate */
	t2 = YEARDAYS(c.year);
	for (c.mon = 1; c.mon < 12; c.mon++) {
		if (t < dayyr[c.mon] + (t2 == 366 && c.mon > 1))
			break;
	}

	c.day = t - dayyr[c.mon - 1] + 1;
	if (t2 == 366 && c.mon > 2) {
		c.day--;
	}

	t = time_second % SECDAY;
	c.hour = t / 3600;
	t %= 3600;
	c.min = t / 60;
	c.sec = t % 60;

	if (cd->tod_set)
		(*cd->tod_set)(cd->tod_cookie, &c);
}

#ifndef MULTIPROCESSOR
u_int
cp0_get_timecount(struct timecounter *tc)
{
	return (cp0_get_count());
}
#endif
@


1.35
log
@octeon's internal counter clock speed is same as the processor clock. ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.34 2010/09/20 06:33:47 matthew Exp $ */
d58 1
d69 1
d271 1
d278 1
d447 1
a450 1
	/* XXX SMP */
d453 1
@


1.34
log
@Get rid of evcount's support for arranging counters in a tree
hierarchy.  Everything attached to a single root node anyway, so at
best we had a bush.

"i think it is good" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.33 2010/02/28 17:23:25 miod Exp $ */
d197 3
d201 1
d269 3
d273 1
d296 3
d300 1
@


1.33
log
@Add an explicit `delay constant' member to struct cpu_info, so that it can
be decoupled from the nominal processor speed.
While there, make sure delay() gets a proper delay constant if invoked before
cpu0 attaches (how could I miss that when introducing struct cpu_hwinfo?!?)
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.32 2010/01/09 20:33:16 miod Exp $ */
d97 1
a97 1
	evcount_attach(&clk_count, "clock", (void *)&clk_irq, &evcount_intr);
@


1.32
log
@Define struct cpu_hwinfo, to hold hardware specific information about each
processor (instead of sys_config.cpu[]), and pass it in the attach_args
when attaching cpu devices.

This allows per-cpu information to be gathered late in the bootstrap process,
and not be limited by an arbitrary MAX_CPUS limit; this will suit IP27 and
IP35 systems better.

While there, use this information to make sure delay() uses the speed
information from the cpu it is invoked on.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.31 2009/12/28 06:55:27 syuu Exp $ */
d193 1
d195 3
d199 1
a199 1
	dly = (ci->ci_hw.clock / 1000000) * n / 2;
d244 1
@


1.31
log
@MP-safe pmap implemented, enable IPI in interrupt handler to avoid deadlock.
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.30 2009/11/26 23:32:46 syuu Exp $ */
d55 1
d192 1
d195 1
a195 1
	dly = (sys_config.cpu[0].clock / 1000000) * n / 2;
d210 1
a210 2
 * Start the real-time and statistics clocks. Leave stathz 0 since there
 * are no other timers available.
d213 1
a213 1
cpu_initclocks()
d219 30
d255 1
a255 22
	/*
	 * Calibrate the cycle counter frequency.
	 */
	if (cd->tod_get != NULL) {
		(*cd->tod_get)(cd->tod_cookie, 0, &ct);
		first_sec = ct.sec;

		/* Let the clock tick one second. */
		do {
			first_cp0 = cp0_get_count();
			(*cd->tod_get)(cd->tod_cookie, 0, &ct);
		} while (ct.sec == first_sec);
		first_sec = ct.sec;
		/* Let the clock tick one more second. */
		do {
			second_cp0 = cp0_get_count();
			(*cd->tod_get)(cd->tod_cookie, 0, &ct);
		} while (ct.sec == first_sec);

		cycles_per_sec = second_cp0 - first_cp0;
		sys_config.cpu[0].clock = cycles_per_sec * 2;
	}
d260 1
a260 1
	cp0_timecounter.tc_frequency = sys_config.cpu[0].clock / 2;
d277 2
d283 1
a283 1
	ci->ci_cpu_counter_interval = cp0_timecounter.tc_frequency / hz;
d324 1
a324 1
		base = 38 * SECYR;	/* 2008 */
d429 1
@


1.30
log
@Now IPI can interrupt to clock interrupt handler.
It prevents deadlock with TLB shootdown and clock interrupt.
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.29 2009/11/22 22:15:25 syuu Exp $ */
d120 1
a120 1
	u_int32_t clkdiff, sr;
a122 4
	/* Enable interrupts at this (hardware) level again */
	sr = getsr();
	updateimask(mask);

d130 1
a130 1
		setsr(sr);
d163 4
d176 1
a178 1
	setsr(sr);
@


1.29
log
@removing unnecessary locks.
ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.28 2009/11/22 18:33:48 syuu Exp $ */
d120 1
a120 1
	u_int32_t clkdiff;
d123 4
d134 1
d166 3
d174 3
d178 1
@


1.28
log
@SMP support on MIPS clock.
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.26 2009/10/26 20:14:40 miod Exp $ */
a160 4
#ifdef MULTIPROCESSOR
		if (ci->ci_ipl < IPL_SCHED)
			__mp_lock(&kernel_lock);
#endif
a165 4
#ifdef MULTIPROCESSOR
		if (ci->ci_ipl < IPL_SCHED)
			__mp_unlock(&kernel_lock);
#endif
@


1.27
log
@mplock, rw_cas implemented
ok miod@@
@
text
@a56 5
int	clock_started;
u_int32_t cpu_counter_last;
u_int32_t cpu_counter_interval;
u_int32_t pendingticks;

d121 1
d128 1
a128 1
	if (clock_started == 0) {
d136 5
a140 5
	clkdiff = cp0_get_count() - cpu_counter_last;
	while (clkdiff >= cpu_counter_interval) {
		cpu_counter_last += cpu_counter_interval;
		clkdiff = cp0_get_count() - cpu_counter_last;
		pendingticks++;
d142 2
a143 2
	pendingticks++;
	cpu_counter_last += cpu_counter_interval;
d149 2
a150 2
	cp0_set_compare(cpu_counter_last);
	clkdiff = cp0_get_count() - cpu_counter_last;
d152 3
a154 3
		cpu_counter_last += cpu_counter_interval;
		pendingticks++;
		cp0_set_compare(cpu_counter_last);
d161 5
a165 2
		KERNEL_LOCK();
		while (pendingticks) {
d168 1
a168 1
			pendingticks--;
d170 4
a173 1
		KERNEL_UNLOCK();
d214 1
a214 1
	int s;
d248 16
d267 4
a270 4
	cpu_counter_interval = cp0_timecounter.tc_frequency / hz;
	cpu_counter_last = cp0_get_count() + cpu_counter_interval;
	cp0_set_compare(cpu_counter_last);
	clock_started++;
@


1.26
log
@Rename struct confargs to struct mainbus_attach_args for consistency and also
to prevent further abuse of it.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.25 2009/10/22 22:08:54 miod Exp $ */
d164 2
a165 1
	if (tf->ipl < IPL_CLOCK)
d171 2
@


1.25
log
@Completely overhaul interrupt handling on sgi. Cpu state now only stores a
logical IPL level, and per-platform (IP27/IP30/IP32) code will from the
necessary hardware mask registers.

This allows the use of more than one interrupt mask register. Also, the
generic (platform independent) interrupt code shrinks a lot, and the actual
interrupt handler chains and masking information is now per-platform private
data.

Interrupt dispatching is generated from a template; more routines will be
added to the template to reduce platform-specific changes and share as much
code as possible.

Tested on IP27, IP30, IP32 and IP35.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.24 2009/10/22 20:05:27 miod Exp $ */
d83 1
a83 1
	struct confargs *ca = aux;
d85 1
a85 1
	if (strcmp(ca->ca_name, clock_cd.cd_name) != 0)
@


1.24
log
@Replace intrmask_t with uint32_t. This types only describes interrupt masks
in the coprocessor 0 status register (coupled with ICR on rm7k/rm9k), and
may be completely alien to real hardware interrupt masks, so don't make
things unnecessary confusing.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.23 2009/05/06 20:02:45 miod Exp $ */
d164 1
a164 1
	if ((tf->cpl & SPL_CLOCKMASK) == 0) {
a169 1
	}
@


1.23
log
@Fix signedness of comparison used to know whether we have already reached
the next scheduled clock interrupt; the comparison would before always be
true, causing the clock to really run at hz/2.

While there, remove unused nanodelay() and attempt to clean clock
initialization a bit.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.22 2009/03/20 18:41:06 miod Exp $ */
d55 1
a55 1
intrmask_t clock_int5(intrmask_t, struct trap_frame *);
d122 2
a123 2
intrmask_t
clock_int5(intrmask_t mask, struct trap_frame *tf)
@


1.22
log
@Switch sgi to __HAVE_GENERIC_SOFT_INTERRUPTS.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.21 2008/09/23 04:33:07 miod Exp $ */
a55 1
void	clock_int5_init(void);
d57 1
a57 1
int	clock_started = 0;
d95 5
d101 3
d110 1
a110 1
 *	register wired to allow it's use.
a113 17
void
clock_int5_init()
{
        int s;

	hz = 100;
	profhz = 100;
	stathz = 0;	/* XXX no stat clock yet */

	evcount_attach(&clk_count, "clock", (void *)&clk_irq, &evcount_intr);

        s = splclock();
        cpu_counter_interval = sys_config.cpu[0].clock / (hz * 2);
        cpu_counter_last = cp0_get_count() + cpu_counter_interval * 4;
        cp0_set_compare(cpu_counter_last);
        splx(s);
}
d128 11
a138 1
	 * If clock is started count the tick, else just arm for a new.
d140 3
a142 1
	if (clock_started && cpu_counter_interval != 0) {
a143 6
		while (clkdiff >= cpu_counter_interval) {
			cpu_counter_last += cpu_counter_interval;
			clkdiff = cp0_get_count() - cpu_counter_last;
			pendingticks++;
		}
		cpu_counter_last += cpu_counter_interval;
a144 2
	} else {
		cpu_counter_last = cpu_counter_interval + cp0_get_count();
d146 2
d149 4
a153 1
	/* Make sure that next clock tick has not passed */
d155 1
a155 1
	if (clkdiff > 0) {
d161 4
a164 1
	if (clock_started && (tf->cpl & SPL_CLOCKMASK) == 0) {
a193 18
 * Wait "n" nanoseconds.
 */
void
nanodelay(int n)
{
	int dly;
	int p, c;

	p = cp0_get_count();
	dly = ((sys_config.cpu[0].clock * n) / 1000000000) / 2;
	while (dly > 0) {
		c = cp0_get_count();
		dly -= c - p;
		p = c;
	}
}

/*
d210 1
d212 3
a214 2
	/* Start the clock. */
	clock_int5_init();
d240 1
a240 1
	tickadj = 240000 / (60 * hz);           /* can adjust 240ms in 60s */
d245 5
d251 1
d260 1
a260 2
setstatclockrate(newhz)
	int newhz;
d346 1
a346 1
	register int t, t2;
@


1.21
log
@Fix uninitialized variable if the TOD clock value is horribly wrong.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.20 2008/04/07 22:36:26 miod Exp $ */
d162 1
a162 1
	if ((tf->cpl & SPL_CLOCKMASK) == 0) {
@


1.20
log
@Split clock attachment in two parts: a timecounter attachment (at mainbus),
and a time-of-day chip (wherever it gets found).
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.19 2008/02/20 18:46:18 miod Exp $ */
d368 1
@


1.19
log
@Completely overhault attachment rules on sgi. No more indirect configuration
inherited from OpenBSD/arc machines with ISA bus; mainbus children match on
device name and other hierarchies match on simplified locators.
As a bonus, attachment lines in dmesg will now print their locators.

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.18 2007/04/29 17:35:27 kettenis Exp $ */
a43 1
/* Definition of the driver for autoconfig. */
a45 3
intrmask_t clock_int5_dummy(intrmask_t, struct trap_frame *);
intrmask_t clock_int5(intrmask_t, struct trap_frame *);
void clock_int5_init(struct clock_softc *);
d52 1
a52 1
	sizeof(struct clock_softc), clockmatch, clockattach
d55 3
d82 1
a82 1
clockmatch(struct device *parent, void *cfdata, void *aux)
d84 1
a84 2
        struct confargs *ca = aux;
	struct cfdata *cf = cfdata;
d86 2
a87 3
        /* Make sure that we're looking for a clock. */
        if (strcmp(ca->ca_name, clock_cd.cd_name) != 0)
                return (0);
a88 2
	if (cf->cf_unit > 0)
		return 0;
d95 2
a96 27
	struct clock_softc *sc;

	md_clk_attach(parent, self, aux);
	sc = (struct clock_softc *)self;

	switch (sys_config.system_type) {
#if 0
	case ALGOR_P4032:
	case ALGOR_P5064:
	case MOMENTUM_CP7000:
	case MOMENTUM_CP7000G:
	case MOMENTUM_JAGUAR:
	case GALILEO_EV64240:
#endif
	case SGI_INDY:
	case SGI_O2:
	case SGI_O200:
	case SGI_OCTANE:
		printf(" ticker on int5 using count register");
		set_intr(INTPRI_CLOCK, CR_INT_5, clock_int5);
		break;

	default:
		panic("system clock handling code is missing");
	}

	printf("\n");
d108 1
a108 1
clock_int5_init(struct clock_softc *sc)
d112 6
a125 11
 *  Dummy count register interrupt handler used on some targets.
 *  Just resets the compare register and acknowledge the interrupt.
 */
intrmask_t
clock_int5_dummy(intrmask_t mask, struct trap_frame *tf)
{
        cp0_set_compare(0);      /* Shut up counter int's for a while */
	return CR_INT_5;	/* Clock is always on 5 */
}

/*
d213 2
d222 1
a222 1
	struct clock_softc *sc = (struct clock_softc *)clock_cd.cd_devs[0];
d227 2
a228 9
	hz = sc->sc_clock.clk_hz;
	stathz = sc->sc_clock.clk_stathz;
	profhz = sc->sc_clock.clk_profhz;

	evcount_attach(&clk_count, "clock", (void *)&clk_irq, &evcount_intr);

	/* Start the clock.  */
	if (sc->sc_clock.clk_init != NULL)
		(*sc->sc_clock.clk_init)(sc);
d233 2
a234 2
	if (sc->sc_clock.clk_get != NULL) {
		(*sc->sc_clock.clk_get)(sc, 0, &ct);
d240 1
a240 1
			(*sc->sc_clock.clk_get)(sc, 0, &ct);
d246 1
a246 1
			(*sc->sc_clock.clk_get)(sc, 0, &ct);
d289 1
a289 1
	struct clock_softc *sc = (struct clock_softc *)clock_cd.cd_devs[0];
d294 1
a294 1
	if (base < 15*SECYR) {
d297 1
a297 1
		base = 17*SECYR + 186*SECDAY + SECDAY/2;
d305 2
a306 2
	if (sc->sc_clock.clk_get) {
		(*sc->sc_clock.clk_get)(sc, base, &c);
d325 1
a325 1
	sc->sc_initted = 1;
d342 1
a342 1
	sc->sc_initted = 1;
d354 1
a354 1
	struct clock_softc *sc = (struct clock_softc *)clock_cd.cd_devs[0];
d358 1
a358 1
	 *  Don't reset clock if time has not been set!
d360 1
a360 1
	if (!sc->sc_initted) {
a361 1
	}
d394 2
a395 3
	if (sc->sc_clock.clk_set) {
		(*sc->sc_clock.clk_set)(sc, &c);
	}
@


1.18
log
@The cpu clock frequency we get from ARCBIOS may be off by something in the
order of 1%.  So calibrate the CP0 timecounter frequency using the TOD clock
if we have one.

"looks like good stuff" deraadt@@, also tested by jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.17 2006/06/19 15:13:35 deraadt Exp $ */
d52 1
a52 1
	NULL, "clock", DV_DULL, NULL, 0
a62 1
u_int32_t ticktime;
d92 1
a92 1
	if (cf->cf_unit >= 1)
d106 1
d113 1
d117 1
a119 1
		ticktime = sys_config.cpu[0].clock / 2000;
d123 1
a123 1
		panic("clockattach: it didn't get here.  really.");
@


1.17
log
@move clock_subr.c to a better place, and now it is always in the kernel
so that things can use it; tested on all architectures; ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.16 2005/05/02 18:17:52 grange Exp $ */
d255 3
d268 23
@


1.16
log
@We don't really like full stops in dmesg. ok pefo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.15 2005/05/01 15:15:08 grange Exp $ */
a75 2
#define	SECDAY	(24*SECHOUR)	/* seconds per day */
#define	SECYR	(365*SECDAY)	/* seconds per common year */
@


1.15
log
@Use quality 0 instead of 1000 for CP0 timecounter like
for i8254 on i386/amd64. Tested by kettenis@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.14 2005/04/29 18:41:12 grange Exp $ */
d118 1
a118 1
		printf(" ticker on int5 using count register.");
@


1.14
log
@So mips64 is our first arch that switches to using new MI
timecounter code.
The only available timecounter now is CP0 count register. We'll
have more once we get support for embedded CPUs like NEC VR41xx.

Tested on sgi by hshoexer@@ and kettenis@@; ok pefo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.13 2005/02/13 22:04:34 grange Exp $ */
d73 1
a73 1
	1000			/* quality */
@


1.13
log
@beliving -> believing typo;
spotted by miod (from the be300 dmesg ;-)
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.12 2005/01/31 21:43:14 grange Exp $ */
d34 1
d65 11
a245 32
 * Return the best possible estimate of the time in the timeval
 * to which tvp points.  We guarantee that the time will be greater
 * than the value obtained by a previous call.
 */
void
microtime(struct timeval *tvp)
{
	static struct timeval lasttime;
	u_int32_t clkdiff;
	int s = splclock();

	*tvp = time;
	clkdiff = (cp0_get_count() - cpu_counter_last) * 1000;
	tvp->tv_usec += clkdiff / ticktime;
	while (tvp->tv_usec >= 1000000) {
		tvp->tv_sec++;
		tvp->tv_usec -= 1000000;
	}

	if (tvp->tv_sec == lasttime.tv_sec &&
	    tvp->tv_usec <= lasttime.tv_usec) {
		tvp->tv_usec++;
		if (tvp->tv_usec >= 1000000) {
			tvp->tv_sec++;
			tvp->tv_usec -= 1000000;
		}
	}
	lasttime = *tvp;
	splx(s);
}

/*
d271 3
d302 1
d307 2
d338 2
a339 1
	time.tv_sec = days * SECDAY + c.hour * 3600 + c.min * 60 + c.sec;
d345 1
a345 1
	if (base < time.tv_sec - 5*SECYR) {
d347 1
a347 1
	} else if (base > time.tv_sec + 5*SECYR) {
d355 2
a356 1
	time.tv_sec = base;
d380 1
a380 1
	t2 = time.tv_sec / SECDAY;
d384 1
a384 1
	t2 = time.tv_sec / SECDAY;
d404 1
a404 1
	t = time.tv_sec % SECDAY;
d413 6
@


1.12
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.11 2005/01/31 21:39:59 grange Exp $ */
d337 1
a337 1
		printf("WARNING: No TOD clock, beliving file system.\n");
@


1.11
log
@tickadj is already declared in sys/kernel.h.

ok pefo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.10 2005/01/31 21:25:21 grange Exp $ */
d143 1
a143 1
clock_int5_dummy( intrmask_t mask, struct trap_frame *tf)
d157 1
a157 1
clock_int5( intrmask_t mask, struct trap_frame *tf)
@


1.10
log
@Move md_clk_attach() prototype to mips64/dev/clockvar.h.

ok pefo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.9 2004/10/20 12:49:15 pefo Exp $ */
a275 1
	extern int tickadj;
@


1.9
log
@Fix some 64 bit address problems.
Some function names made more unique.
Other changes for the upcoming Origin 200 support.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.8 2004/09/24 14:22:49 deraadt Exp $ */
a48 1
void	md_clk_attach(struct device *, struct device *, void *);
@


1.8
log
@new style interrupt counters; pefo ok
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.7 2004/09/16 09:23:21 pefo Exp $ */
d106 1
a113 1
		clock_int5(0,(struct trap_frame *)NULL);
d179 7
@


1.7
log
@Day of week count 1-7
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.6 2004/08/11 17:05:31 pefo Exp $ */
d33 1
d40 2
d182 1
d276 2
@


1.6
log
@fix microtime
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.5 2004/08/10 20:15:47 deraadt Exp $ */
d382 1
a382 1
	c.dow = (t2 + 5) % 7;	/* 1/1/1970 was thursday */
@


1.5
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.4 2004/08/10 13:45:40 pefo Exp $ */
a38 1
int	clock_started = 0;
d46 1
d56 1
a56 2
void	md_clk_attach(struct device *, struct device *, void *);

d60 1
d105 1
d225 2
a226 3
 * to which tvp points.  Unfortunately, we can't read the hardware registers.
 * We guarantee that the time will be greater than the value obtained by a
 * previous call.
d231 2
a233 1
	static struct timeval lasttime;
d236 3
a238 3
#ifdef notdef
		tvp->tv_usec += clkread();
		while (tvp->tv_usec >= 1000000) {
d242 1
a242 1
#endif
d244 6
a249 4
	    tvp->tv_usec <= lasttime.tv_usec &&
	    (tvp->tv_usec = lasttime.tv_usec + 1) >= 1000000) {
		tvp->tv_sec++;
		tvp->tv_usec -= 1000000;
a271 2

	printf("Starting clocks %d/%d/%d hz\n", hz, stathz, profhz);
@


1.4
log
@clean
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.3 2004/08/09 21:01:32 pefo Exp $ */
d5 1
a5 1
 * 
d187 1
a187 1
 * Wait "n" microseconds. 
d321 1
a321 1
	 */ 
@


1.3
log
@adding tod support to sgi
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.2 2004/08/09 14:57:26 pefo Exp $ */
a104 8
		break;

	case GALILEO_G9:
	case WG4308:
	case WG4309:
	case WG6000:
	case WG7000:
	case WG8168:
@


1.2
log
@Big cleanup. Removed some unused obsolete stuff and fixed copyrights
on some files. Arcbios support is now in, thus detects memorysize and cpu
clock frequency.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.1 2004/08/06 20:56:03 pefo Exp $ */
d103 1
a103 1
		printf(" clock on int5 using counter");
@


1.1
log
@initial mips64
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d137 1
a137 1
        cpu_counter_interval = sys_config.cpu.clock / (hz * 2);
d204 1
a204 1
	dly = (sys_config.cpu.clock / 1000000) * n / 2;
d222 1
a222 1
	dly = ((sys_config.cpu.clock * n) / 1000000000) / 2;
@

