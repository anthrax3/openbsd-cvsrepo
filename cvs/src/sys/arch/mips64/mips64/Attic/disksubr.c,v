head	1.62;
access;
symbols
	OPENBSD_4_1:1.36.0.2
	OPENBSD_4_1_BASE:1.36
	OPENBSD_4_0:1.22.0.2
	OPENBSD_4_0_BASE:1.22
	OPENBSD_3_9:1.10.0.2
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.7.0.2
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.6.0.2
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.5.0.2
	OPENBSD_3_6_BASE:1.5;
locks; strict;
comment	@ * @;


1.62
date	2007.06.18.21.46.41;	author deraadt;	state dead;
branches;
next	1.61;

1.61
date	2007.06.18.07.09.25;	author deraadt;	state Exp;
branches;
next	1.60;

1.60
date	2007.06.17.10.29.10;	author miod;	state Exp;
branches;
next	1.59;

1.59
date	2007.06.17.00.27.29;	author deraadt;	state Exp;
branches;
next	1.58;

1.58
date	2007.06.14.04.56.15;	author miod;	state Exp;
branches;
next	1.57;

1.57
date	2007.06.14.03.41.21;	author deraadt;	state Exp;
branches;
next	1.56;

1.56
date	2007.06.14.03.37.23;	author deraadt;	state Exp;
branches;
next	1.55;

1.55
date	2007.06.14.03.35.29;	author deraadt;	state Exp;
branches;
next	1.54;

1.54
date	2007.06.14.03.29.34;	author deraadt;	state Exp;
branches;
next	1.53;

1.53
date	2007.06.12.20.57.42;	author deraadt;	state Exp;
branches;
next	1.52;

1.52
date	2007.06.09.23.06.46;	author krw;	state Exp;
branches;
next	1.51;

1.51
date	2007.06.09.18.05.47;	author deraadt;	state Exp;
branches;
next	1.50;

1.50
date	2007.06.09.04.08.39;	author deraadt;	state Exp;
branches;
next	1.49;

1.49
date	2007.06.09.02.03.47;	author deraadt;	state Exp;
branches;
next	1.48;

1.48
date	2007.06.07.23.12.41;	author krw;	state Exp;
branches;
next	1.47;

1.47
date	2007.06.07.12.10.07;	author otto;	state Exp;
branches;
next	1.46;

1.46
date	2007.06.07.02.55.12;	author krw;	state Exp;
branches;
next	1.45;

1.45
date	2007.06.07.00.28.17;	author krw;	state Exp;
branches;
next	1.44;

1.44
date	2007.06.06.17.15.12;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2007.06.06.16.42.06;	author deraadt;	state Exp;
branches;
next	1.42;

1.42
date	2007.06.05.00.38.17;	author deraadt;	state Exp;
branches;
next	1.41;

1.41
date	2007.06.02.02.35.27;	author krw;	state Exp;
branches;
next	1.40;

1.40
date	2007.05.31.19.57.43;	author krw;	state Exp;
branches;
next	1.39;

1.39
date	2007.05.31.16.05.50;	author krw;	state Exp;
branches;
next	1.38;

1.38
date	2007.05.29.06.28.15;	author otto;	state Exp;
branches;
next	1.37;

1.37
date	2007.05.29.05.08.20;	author krw;	state Exp;
branches;
next	1.36;

1.36
date	2007.02.18.14.18.28;	author krw;	state Exp;
branches;
next	1.35;

1.35
date	2007.02.18.13.49.22;	author krw;	state Exp;
branches;
next	1.34;

1.34
date	2007.02.03.18.22.33;	author krw;	state Exp;
branches;
next	1.33;

1.33
date	2006.10.28.23.26.05;	author krw;	state Exp;
branches;
next	1.32;

1.32
date	2006.10.21.20.10.39;	author krw;	state Exp;
branches;
next	1.31;

1.31
date	2006.10.21.16.01.54;	author krw;	state Exp;
branches;
next	1.30;

1.30
date	2006.10.21.14.18.37;	author krw;	state Exp;
branches;
next	1.29;

1.29
date	2006.10.20.23.47.43;	author krw;	state Exp;
branches;
next	1.28;

1.28
date	2006.10.18.20.09.39;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2006.10.17.23.42.37;	author krw;	state Exp;
branches;
next	1.26;

1.26
date	2006.10.10.03.17.45;	author krw;	state Exp;
branches;
next	1.25;

1.25
date	2006.10.04.23.58.12;	author krw;	state Exp;
branches;
next	1.24;

1.24
date	2006.10.04.03.23.01;	author krw;	state Exp;
branches;
next	1.23;

1.23
date	2006.10.03.01.37.22;	author krw;	state Exp;
branches;
next	1.22;

1.22
date	2006.09.16.14.56.12;	author krw;	state Exp;
branches;
next	1.21;

1.21
date	2006.08.20.03.14.21;	author krw;	state Exp;
branches;
next	1.20;

1.20
date	2006.08.18.00.39.17;	author krw;	state Exp;
branches;
next	1.19;

1.19
date	2006.08.17.10.34.14;	author krw;	state Exp;
branches;
next	1.18;

1.18
date	2006.08.11.21.32.40;	author krw;	state Exp;
branches;
next	1.17;

1.17
date	2006.07.09.21.06.39;	author krw;	state Exp;
branches;
next	1.16;

1.16
date	2006.07.07.23.47.37;	author krw;	state Exp;
branches;
next	1.15;

1.15
date	2006.07.03.20.00.22;	author krw;	state Exp;
branches;
next	1.14;

1.14
date	2006.07.01.16.50.33;	author krw;	state Exp;
branches;
next	1.13;

1.13
date	2006.06.11.21.15.35;	author krw;	state Exp;
branches;
next	1.12;

1.12
date	2006.03.15.20.20.40;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2006.03.04.19.33.21;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2006.01.22.00.40.01;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2005.12.22.03.02.48;	author krw;	state Exp;
branches;
next	1.8;

1.8
date	2005.09.27.23.56.12;	author krw;	state Exp;
branches;
next	1.7;

1.7
date	2005.03.30.07.52.32;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2004.10.30.14.48.59;	author pefo;	state Exp;
branches;
next	1.5;

1.5
date	2004.08.23.14.24.56;	author pefo;	state Exp;
branches;
next	1.4;

1.4
date	2004.08.11.10.21.08;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.10.20.28.13;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2004.08.10.20.15.47;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2004.08.06.20.56.03;	author pefo;	state Exp;
branches;
next	;


desc
@@


1.62
log
@this is the sgi disksubr, not some mythical "all mips64 architectures can use it" balony
@
text
@/*	$OpenBSD: disksubr.c,v 1.61 2007/06/18 07:09:25 deraadt Exp $	*/

/*
 * Copyright (c) 1999 Michael Shalayeff
 * Copyright (c) 1997 Niklas Hallqvist
 * Copyright (c) 1996 Theo de Raadt
 * Copyright (c) 1982, 1986, 1988 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/device.h>
#include <sys/disklabel.h>
#include <sys/syslog.h>
#include <sys/disk.h>

char   *readbsdlabel(struct buf *, void (*)(struct buf *), int, int,
    int, struct disklabel *, int);
char   *readsgilabel(struct buf *, void (*)(struct buf *),
    struct disklabel *, struct cpu_disklabel *, int *, int *, int);

/*
 * Try to read a standard BSD disklabel at a certain sector.
 */
char *
readbsdlabel(struct buf *bp, void (*strat)(struct buf *),
    int cyl, int sec, int off, struct disklabel *lp,
    int spoofonly)
{
	/* don't read the on-disk label if we are in spoofed-only mode */
	if (spoofonly)
		return (NULL);

	bp->b_blkno = sec;
	bp->b_cylinder = cyl;
	bp->b_bcount = lp->d_secsize;
	bp->b_flags = B_BUSY | B_READ;
	(*strat)(bp);

	/* if successful, locate disk label within block and validate */
	if (biowait(bp))
		return ("disk label I/O error");

	return checkdisklabel(bp->b_data + LABELOFFSET, lp);
}

/*
 * Attempt to read a disk label from a device
 * using the indicated strategy routine.
 * The label must be partly set up before this:
 * secpercyl, secsize and anything required for a block i/o read
 * operation in the driver's strategy/start routines
 * must be filled in before calling us.
 *
 * Returns null on success and an error string on failure.
 */
char *
readdisklabel(dev_t dev, void (*strat)(struct buf *),
    struct disklabel *lp, struct cpu_disklabel *osdep, int spoofonly)
{
	struct buf *bp = NULL;
	char *msg;

	if ((msg = initdisklabel(lp)))
		goto done;

	/* get a buffer and initialize it */
	bp = geteblk((int)lp->d_secsize);
	bp->b_dev = dev;

	msg = readsgilabel(bp, strat, lp, osdep, 0, 0, spoofonly);
	if (msg == NULL)
		goto done;

	msg = readdoslabel(bp, strat, lp, osdep, 0, 0, spoofonly);
	if (msg == NULL)
		goto done;

#if defined(CD9660)
	if (iso_disklabelspoof(dev, strat, lp) == 0) {
		msg = NULL;
		goto done;
	}
#endif
#if defined(UDF)
	if (udf_disklabelspoof(dev, strat, lp) == 0) {
		msg = NULL;
		goto done;
	}
#endif

done:
	if (bp) {
		bp->b_flags |= B_INVAL;
		brelse(bp);
	}
	return (msg);
}

static struct {
	int m;
	int b;
} maptab[] = {
    { 0,	FS_BSDFFS},	{ 1,	FS_SWAP},	{ 10,	FS_BSDFFS},
    { 3,	FS_BSDFFS},	{ 4,	FS_BSDFFS},	{ 5,	FS_BSDFFS},
    { 6,	FS_BSDFFS},	{ 7,	FS_BSDFFS},	{ 15,	FS_OTHER},
    { 9,	FS_BSDFFS},	{ 2,	FS_UNUSED},	{ 11,	FS_BSDFFS},
    { 12,	FS_BSDFFS},	{ 13,	FS_BSDFFS},	{ 14,	FS_BSDFFS},
    { 8,	FS_BSDFFS}
};

char *
readsgilabel(struct buf *bp, void (*strat)(struct buf *),
    struct disklabel *lp, struct cpu_disklabel *osdep,
    int *partoffp, int *cylp, int spoofonly)
{
	struct sgilabel *dlp;
	char *msg = NULL;
	int i, *p, cs = 0;
	int fsoffs = 0;

	bp->b_blkno = 0;
	bp->b_cylinder = 0;
	bp->b_bcount = lp->d_secsize;
	bp->b_flags = B_BUSY | B_READ;
	(*strat)(bp);

	/* if successful, locate disk label within block and validate */
	if (biowait(bp)) {
		msg = "disk label I/O error";
		goto done;
	}

	dlp = (struct sgilabel *)(bp->b_data + LABELOFFSET);
	if (dlp->magic != htobe32(SGILABEL_MAGIC)) {
		fsoffs = 0;
		goto finished;
	}

	if (dlp->partitions[0].blocks == 0) {
		msg = "no BSD partition";
		goto done;
	}
	fsoffs = dlp->partitions[0].first;

	if (spoofonly)
		goto finished;

	p = (int *)dlp;
	i = sizeof(struct sgilabel) / sizeof(int);
	while (i--)
		cs += *p++;
	if (cs != 0) {
		msg = "sgilabel checksum error";
		goto done;
	}

	/* Set up partitions i-l if there is no BSD label. */
	lp->d_secsize = dlp->dp.dp_secbytes;
	lp->d_nsectors = dlp->dp.dp_secs;
	lp->d_ntracks = dlp->dp.dp_trks0;
	lp->d_ncylinders = dlp->dp.dp_cyls;
	lp->d_interleave = dlp->dp.dp_interleave;
	lp->d_npartitions = MAXPARTITIONS;

	for (i = 0; i < 16; i++) {
		int bsd = maptab[i].m;

		DL_SETPOFFSET(&lp->d_partitions[bsd],
		    dlp->partitions[i].first);
		DL_SETPSIZE(&lp->d_partitions[bsd],
		    dlp->partitions[i].blocks);
		lp->d_partitions[bsd].p_fstype = maptab[i].b;
		if (lp->d_partitions[bsd].p_fstype == FS_BSDFFS) {
			lp->d_partitions[bsd].p_fragblock =
			    DISKLABELV1_FFS_FRAGBLOCK(1024, 8);
			lp->d_partitions[bsd].p_cpg = 16;
		}
	}

	lp->d_version = 1;
	lp->d_flags = D_VENDOR;
	lp->d_checksum = 0;
	lp->d_checksum = dkcksum(lp);

finished:
	if (partoffp)
		*partoffp = fsoffs;

	if (spoofonly)
		goto done;

	bp->b_blkno = fsoffs + LABELSECTOR;
	bp->b_cylinder = 0;
	bp->b_bcount = lp->d_secsize;
	bp->b_flags = B_BUSY | B_READ;
	(*strat)(bp);
	if (biowait(bp)) {
		msg = "disk label I/O error";
		goto done;
	}

	return checkdisklabel(bp->b_data + LABELOFFSET, lp);

done:
	if (bp) {
		bp->b_flags |= B_INVAL;
		brelse(bp);
	}
	return (msg);
}

/*
 * Write disk label back to device after modification.
 */
int
writedisklabel(dev_t dev, void (*strat)(struct buf *),
    struct disklabel *lp, struct cpu_disklabel *osdep)
{
	int error = EIO, partoff = -1, cyl = 0;
	struct buf *bp = NULL;
	struct disklabel *dlp;

	/* get a buffer and initialize it */
	bp = geteblk((int)lp->d_secsize);
	bp->b_dev = dev;

	if (readsgilabel(bp, strat, lp, osdep, &partoff, &cyl, 1) != NULL &&
	    readdoslabel(bp, strat, lp, osdep, &partoff, &cyl, 1) != NULL)
		goto done;

	/* Read it in, slap the new label in, and write it back out */
	bp->b_blkno = partoff + LABELSECTOR;
	bp->b_cylinder = cyl;
	bp->b_bcount = lp->d_secsize;
	bp->b_flags = B_BUSY | B_READ;
	(*strat)(bp);
	if ((error = biowait(bp)) != 0)
		goto done;

	dlp = (struct disklabel *)(bp->b_data + LABELOFFSET);
	*dlp = *lp;
	bp->b_flags = B_BUSY | B_WRITE;
	(*strat)(bp);
	error = biowait(bp);

done:
	if (bp) {
		bp->b_flags |= B_INVAL;
		brelse(bp);
	}
	return (error);
}
@


1.61
log
@simplify error return case from writedisklabel()
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.60 2007/06/17 10:29:10 miod Exp $	*/
@


1.60
log
@Coerce this into compiling.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.59 2007/06/17 00:27:29 deraadt Exp $	*/
a211 1

d246 1
a246 1
	int error, partoff = -1, cyl = 0;
d254 3
a256 9
	/* find where the disklabel label should be placed */
	if (readsgilabel(bp, strat, lp, osdep, &partoff, &cyl, 1) == NULL)
		goto writeit;

	if (readdoslabel(bp, strat, lp, osdep, &partoff, &cyl, 1) == NULL)
		goto writeit;

	error = EIO;
	goto done;
a257 1
writeit:
@


1.59
log
@significantly simplified disklabel infrastructure.  MBR handling becomes MI
to support hotplug media on most architectures.  disklabel setup and
verification done using new helper functions.  Disklabels must *always*
have a correct checksum now.  Same code paths are used to learn on-disk
location disklabels, to avoid new errors sneaking in.  Tested on almost all
cases, testing help from todd, kettenis, krw, otto, dlg, robert, gwk, drahn
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.58 2007/06/14 04:56:15 miod Exp $	*/
a55 3
	struct disklabel *dlp;
	u_int16_t cksum;

d233 3
a235 3
	if (dbp) {
		dbp->b_flags |= B_INVAL;
		brelse(dbp);
a247 1
	char *msg = "no disk label";
d249 1
d256 1
a256 1
	if (readsgilabel(bp, strat, &dl, &cdl, &partoff, &cyl, 1) == NULL)
d259 1
a259 1
	if (readdoslabel(bp, strat, &dl, &cdl, &partoff, &cyl, 1) == NULL)
@


1.58
log
@Fix label name in writedisklabel().
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.57 2007/06/14 03:41:21 deraadt Exp $	*/
a32 10
 *
 *	@@(#)ufs_disksubr.c	7.16 (Berkeley) 5/4/91
 */

/*
 * This disksubr.c module started to take its present form on OpenBSD/alpha
 * but it was always thought it should be made completely MI and not need to
 * be in that alpha-specific tree at all.
 *
 * XXX HPUX disklabel is not understood yet.
a44 2
char   *readdoslabel(struct buf *, void (*)(struct buf *),
    struct disklabel *, struct cpu_disklabel *, int *, int *, int);
a46 1
void map_sgi_label(struct disklabel *, struct sgilabel *);
a56 1
	char *msg = NULL;
d70 2
a71 5
	if (biowait(bp)) {
		/* XXX we return the faked label built so far */
		msg = "disk label I/O error";
		return (msg);
	}
d73 1
a73 26
	/*
	 * If off is negative, search until the end of the sector for
	 * the label, otherwise, just look at the specific location
	 * we're given.
	 */
	dlp = (struct disklabel *)(bp->b_data + (off >= 0 ? off : 0));
	do {
		if (dlp->d_magic != DISKMAGIC || dlp->d_magic2 != DISKMAGIC) {
			if (msg == NULL)
				msg = "no disk label";
		} else {
			cksum = dkcksum(dlp);
			if (dlp->d_npartitions > MAXPARTITIONS || cksum != 0) {
				msg = "disk label corrupted";
			} else {
				*lp = *dlp;
				msg = NULL;
				break;
			}
		}
		if (off >= 0)
			break;
		dlp = (struct disklabel *)((char *)dlp + sizeof(int32_t));
	} while (dlp <= (struct disklabel *)(bp->b_data + lp->d_secsize -
	    sizeof(*dlp)));
	return (msg);
d91 1
a91 3
	char *msg = "no disk label";
	int i;
	struct disklabel minilabel, fallbacklabel;
d93 1
a93 7
	/* minimal requirements for archetypal disk label */
	if (lp->d_secsize < DEV_BSIZE)
		lp->d_secsize = DEV_BSIZE;
	if (DL_GETDSIZE(lp) == 0)
		DL_SETDSIZE(lp, MAXDISKSIZE);
	if (lp->d_secpercyl == 0) {
		msg = "invalid geometry";
a94 11
	}
	lp->d_npartitions = RAW_PART + 1;
	for (i = 0; i < RAW_PART; i++) {
		DL_SETPSIZE(&lp->d_partitions[i], 0);
		DL_SETPOFFSET(&lp->d_partitions[i], 0);
	}
	if (DL_GETPSIZE(&lp->d_partitions[RAW_PART]) == 0)
		DL_SETPSIZE(&lp->d_partitions[RAW_PART], DL_GETDSIZE(lp));
	DL_SETPOFFSET(&lp->d_partitions[RAW_PART], 0);
	lp->d_version = 1;
	minilabel = fallbacklabel = *lp;
d101 6
a106 13
	if (msg) {
		/* Fallback alternative XXX valid lp returned? */
		fallbacklabel = *lp;
		*lp = minilabel;
	}
	if (msg) {
		msg = readdoslabel(bp, strat, lp, osdep, 0, 0, spoofonly);
		if (msg) {
			/* Fallback alternative XXX always valid? */
			fallbacklabel = *lp;
			*lp = minilabel;
		}
	}
d109 1
a109 1
	if (msg && iso_disklabelspoof(dev, strat, lp) == 0)
d111 2
d115 1
a115 1
	if (msg && udf_disklabelspoof(dev, strat, lp) == 0)
d117 2
a120 4
	/* If there was an error, still provide a decent fake one.  */
	if (msg)
		*lp = fallbacklabel;

a125 1
	disklabeltokernlabel(lp);
d129 11
a139 27
/*
 * If dos partition table requested, attempt to load it and
 * find disklabel inside a DOS partition. Return buffer
 * for use in signalling errors if requested.
 *
 * We would like to check if each MBR has a valid BOOT_MAGIC, but
 * we cannot because it doesn't always exist. So.. we assume the
 * MBR is valid.
 */
char *
readdoslabel(bp, strat, lp, osdep, partoffp, cylp, spoofonly)
	struct buf *bp;
	void (*strat)(struct buf *);
	struct disklabel *lp;
	struct cpu_disklabel *osdep;
	int *partoffp;
	int *cylp;
	int spoofonly;
{
	struct dos_partition dp[NDOSPART], *dp2;
	struct partition *pp;
	unsigned long extoff = 0;
	unsigned int fattest;
	daddr64_t part_blkno = DOSBBSECTOR;
	char *msg = NULL;
	int dospartoff, cyl, i, ourpart = -1;
	int wander = 1, n = 0, loop = 0;
a140 174
	if (lp->d_secpercyl == 0) {
		msg = "invalid label, d_secpercyl == 0";
		return (msg);
	}
	if (lp->d_secsize == 0) {
		msg = "invalid label, d_secsize == 0";
		return (msg);
	}

	/* do dos partitions in the process of getting disklabel? */
	dospartoff = 0;
	cyl = LABELSECTOR / lp->d_secpercyl;

	/*
	 * Read dos partition table, follow extended partitions.
	 * Map the partitions to disklabel entries i-p
	 */
	while (wander && n < 8 && loop < 8) {
		loop++;
		wander = 0;
		if (part_blkno < extoff)
			part_blkno = extoff;

		/* read boot record */
		bp->b_blkno = part_blkno;
		bp->b_bcount = lp->d_secsize;
		bp->b_flags = B_BUSY | B_READ;
		bp->b_cylinder = part_blkno / lp->d_secpercyl;
		(*strat)(bp);

		/* if successful, wander through dos partition table */
		if (biowait(bp)) {
			msg = "dos partition I/O error";
			if (partoffp)
				*partoffp = -1;
			return (msg);
		}
		bcopy(bp->b_data + DOSPARTOFF, dp, sizeof(dp));

		if (ourpart == -1 && part_blkno == DOSBBSECTOR) {
			/* Search for our MBR partition */
			for (dp2=dp, i=0; i < NDOSPART && ourpart == -1;
			    i++, dp2++)
				if (letoh32(dp2->dp_size) &&
				    dp2->dp_typ == DOSPTYP_OPENBSD)
					ourpart = i;
			if (ourpart == -1)
				goto donot;
			/*
			 * This is our MBR partition. need sector
			 * address for SCSI/IDE, cylinder for
			 * ESDI/ST506/RLL
			 */
			dp2 = &dp[ourpart];
			dospartoff = letoh32(dp2->dp_start) + part_blkno;
			cyl = DPCYL(dp2->dp_scyl, dp2->dp_ssect);

			/* XXX build a temporary disklabel */
			DL_SETPSIZE(&lp->d_partitions[0], letoh32(dp2->dp_size));
			DL_SETPOFFSET(&lp->d_partitions[0],
			    letoh32(dp2->dp_start) + part_blkno);
			if (lp->d_ntracks == 0)
				lp->d_ntracks = dp2->dp_ehd + 1;
			if (lp->d_nsectors == 0)
				lp->d_nsectors = DPSECT(dp2->dp_esect);
			if (lp->d_secpercyl == 0)
				lp->d_secpercyl = lp->d_ntracks *
				    lp->d_nsectors;
		}
donot:
		/*
		 * In case the disklabel read below fails, we want to
		 * provide a fake label in i-p.
		 */
		for (dp2=dp, i=0; i < NDOSPART && n < 8; i++, dp2++) {
			pp = &lp->d_partitions[8+n];

			if (dp2->dp_typ == DOSPTYP_OPENBSD)
				continue;
			if (letoh32(dp2->dp_size) > DL_GETDSIZE(lp))
				continue;
			if (letoh32(dp2->dp_start) > DL_GETDSIZE(lp))
				continue;
			if (letoh32(dp2->dp_size) == 0)
				continue;
			if (letoh32(dp2->dp_start))
				DL_SETPOFFSET(pp,
				    letoh32(dp2->dp_start) + part_blkno);

			DL_SETPSIZE(pp, letoh32(dp2->dp_size));

			switch (dp2->dp_typ) {
			case DOSPTYP_UNUSED:
				pp->p_fstype = FS_UNUSED;
				n++;
				break;

			case DOSPTYP_LINUX:
				pp->p_fstype = FS_EXT2FS;
				n++;
				break;

			case DOSPTYP_FAT12:
			case DOSPTYP_FAT16S:
			case DOSPTYP_FAT16B:
			case DOSPTYP_FAT16L:
			case DOSPTYP_FAT32:
			case DOSPTYP_FAT32L:
				pp->p_fstype = FS_MSDOS;
				n++;
				break;
			case DOSPTYP_EXTEND:
			case DOSPTYP_EXTENDL:
				part_blkno = letoh32(dp2->dp_start) + extoff;
				if (!extoff) {
					extoff = letoh32(dp2->dp_start);
					part_blkno = 0;
				}
				wander = 1;
				break;
			default:
				pp->p_fstype = FS_OTHER;
				n++;
				break;
			}
		}
	}
	lp->d_bbsize = 8192;
	lp->d_sbsize = 64*1024;		/* XXX ? */
	lp->d_npartitions = MAXPARTITIONS;

	if (n == 0 && part_blkno == DOSBBSECTOR) {
		/* Check for a short jump instruction. */
		fattest = ((bp->b_data[0] << 8) & 0xff00) | (bp->b_data[2] &
		    0xff);
		if (fattest != 0xeb90 && fattest != 0xe900)
			goto notfat;

		/* Check for a valid bytes per sector value. */
		fattest = ((bp->b_data[12] << 8) & 0xff00) | (bp->b_data[11] &
		    0xff);
		if (fattest < 512 || fattest > 4096 || (fattest % 512 != 0))
			goto notfat;

		/* Check the end of sector marker. */
		fattest = ((bp->b_data[510] << 8) & 0xff00) | (bp->b_data[511] &
		    0xff);
		if (fattest != 0x55aa)
			goto notfat;

		/* Looks like a FAT filesystem. Spoof 'i'. */
		DL_SETPSIZE(&lp->d_partitions['i' - 'a'],
		    DL_GETPSIZE(&lp->d_partitions[RAW_PART]));
		DL_SETPOFFSET(&lp->d_partitions['i' - 'a'], 0);
		lp->d_partitions['i' - 'a'].p_fstype = FS_MSDOS;
	}
notfat:

	/* record the OpenBSD partition's placement for the caller */
	if (partoffp)
		*partoffp = dospartoff;
	if (cylp)
		*cylp = cyl;

	/* next, dig out disk label */
	msg = readbsdlabel(bp, strat, cyl, dospartoff + LABELSECTOR, -1,
	    lp, spoofonly);

	return (msg);
}

/*
 *
 */
d142 3
a144 8
readsgilabel(bp, strat, lp, osdep, partoffp, cylp, spoofonly)
	struct buf *bp;
	void (*strat)(struct buf *);
	struct disklabel *lp;
	struct cpu_disklabel *osdep;
	int *partoffp;
	int *cylp;
	int spoofonly;
d148 1
a150 7
	/* don't read the on-disk label if we are in spoofed-only mode */
	if (spoofonly)
		return (NULL);

	if (partoffp)
		*partoffp = -1;

d159 2
a160 3
		if (partoffp)
			*partoffp = -1;
		return "disk label I/O error";
d163 1
a163 1
	dlp = (struct sgilabel *)(bp->b_data);
d166 2
a167 2
	} else {
		int i, *p, cs;
d169 3
a171 21
		cs = 0;
		p = (int *)dlp;
		i = sizeof(struct sgilabel) / sizeof(int);
		while(i--)
			cs += *p++;
		if (cs != 0)
			return "sgilabel checksum error";

		/* Set up partitions i-l if there is no BSD label. */
		lp->d_secsize = dlp->dp.dp_secbytes;
		lp->d_nsectors = dlp->dp.dp_secs;
		lp->d_ntracks = dlp->dp.dp_trks0;
		lp->d_ncylinders = dlp->dp.dp_cyls;
		lp->d_interleave = dlp->dp.dp_interleave;
		lp->d_npartitions = MAXPARTITIONS;

		map_sgi_label(lp, dlp);

		fsoffs = dlp->partitions[0].first;
		if (dlp->partitions[0].blocks == 0)
			msg = "no BSD partition";
d173 1
d175 2
a176 2
	if (msg)
		return msg;
d178 8
a185 2
	if (partoffp)
		*partoffp = fsoffs;
d187 7
a193 17
	msg = readbsdlabel(bp, strat, 0, fsoffs + LABELSECTOR,
	    LABELOFFSET, lp, spoofonly);
	return msg;
}

void
map_sgi_label(struct disklabel *lp, struct sgilabel *dlp)
{
static struct {int m; int b;} maptab[] = {
        { 0,	FS_BSDFFS},	{ 1,	FS_SWAP},	{ 10,	FS_BSDFFS},
        { 3,	FS_BSDFFS},	{ 4,	FS_BSDFFS},	{ 5,	FS_BSDFFS},
        { 6,	FS_BSDFFS},	{ 7,	FS_BSDFFS},	{ 15,	FS_OTHER},
        { 9,	FS_BSDFFS},	{ 2,	FS_UNUSED},	{ 11,	FS_BSDFFS},
        { 12,	FS_BSDFFS},	{ 13,	FS_BSDFFS},	{ 14,	FS_BSDFFS},
        { 8,	FS_BSDFFS}
};
	int i;
d209 32
d250 1
a252 3
	struct disklabel dl;
	struct cpu_disklabel cdl;
	int labeloffset, error, partoff = 0, cyl = 0;
d258 19
a276 22
	dl = *lp;
	msg = readsgilabel(bp, strat, &dl, &cdl, &partoff, &cyl, 0);
	labeloffset = LABELOFFSET;
	if (msg) {
		dl = *lp;
		msg = readdoslabel(bp, strat, &dl, &cdl, &partoff, &cyl, 0);
		labeloffset = LABELOFFSET;
	}
	if (msg) {
		if (partoff == -1) {
			error = EIO;
			goto done;
		}

		/* Write it in the regular place with native byte order. */
		labeloffset = LABELOFFSET;
		bp->b_blkno = partoff + LABELSECTOR;
		bp->b_cylinder = cyl;
		bp->b_bcount = lp->d_secsize;
	}

	*(struct disklabel *)(bp->b_data + labeloffset) = *lp;
d278 2
@


1.57
log
@some spaces in the way
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.56 2007/06/14 03:37:23 deraadt Exp $	*/
d531 1
a531 1
			goto error;
d547 1
@


1.56
log
@excessive blank lines making the versions different
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.55 2007/06/14 03:35:29 deraadt Exp $	*/
d449 3
a451 3
		lp->d_secsize    = dlp->dp.dp_secbytes;
		lp->d_nsectors   = dlp->dp.dp_secs;
		lp->d_ntracks    = dlp->dp.dp_trks0;
@


1.55
log
@set the prototype disklabel to version 1
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.54 2007/06/14 03:29:34 deraadt Exp $	*/
a501 2


@


1.54
log
@do not depend on previous loop variable, use a constant instead
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.53 2007/06/12 20:57:42 deraadt Exp $	*/
d154 1
@


1.53
log
@all disksubr.c did their b_flags manipulation differently (and wrong).
correct and unify; ok thib miod
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.52 2007/06/09 23:06:46 krw Exp $	*/
d151 3
a153 3
	if (DL_GETPSIZE(&lp->d_partitions[i]) == 0)
		DL_SETPSIZE(&lp->d_partitions[i], DL_GETDSIZE(lp));
	DL_SETPOFFSET(&lp->d_partitions[i], 0);
@


1.52
log
@The differences in the last non-homogeneous bounds_check_with_label()
routines (alpha, vax) prove to be not worth keeping. Move
bounds_check_with_label() into the MI world. Eliminate unreliable and
almost certainly useless checks for overwriting a disklabel.

After discussion with deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.51 2007/06/09 18:05:47 deraadt Exp $	*/
d512 1
a512 1
	struct buf *bp;
d530 4
a533 2
		if (partoff == -1)
			return EIO;
d548 4
a551 2
	bp->b_flags |= B_INVAL;
	brelse(bp);
@


1.51
log
@unify DOSPTYP_FAT* code (some architectures missed a filesystem type or two)
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.50 2007/06/09 04:08:39 deraadt Exp $	*/
a548 56
}

/*
 * Determine the size of the transfer, and make sure it is
 * within the boundaries of the partition. Adjust transfer
 * if needed, and signal errors or early completion.
 */
int
bounds_check_with_label(struct buf *bp, struct disklabel *lp,
    struct cpu_disklabel *osdep, int wlabel)
{
#define blockpersec(count, lp) ((count) * (((lp)->d_secsize) / DEV_BSIZE))
	struct partition *p = lp->d_partitions + DISKPART(bp->b_dev);
	int labelsector = blockpersec(DL_GETPOFFSET(&lp->d_partitions[RAW_PART]), lp) +
	    LABELSECTOR;
	int sz = howmany(bp->b_bcount, DEV_BSIZE);

	/* avoid division by zero */
	if (lp->d_secpercyl == 0) {
		bp->b_error = EINVAL;
		goto bad;
	}

	/* beyond partition? */
	if (bp->b_blkno + sz > blockpersec(DL_GETPSIZE(p), lp)) {
		sz = blockpersec(DL_GETPSIZE(p), lp) - bp->b_blkno;
		if (sz == 0) {
			/* If exactly at end of disk, return EOF. */
			bp->b_resid = bp->b_bcount;
			return (-1);
		}
		if (sz < 0) {
			/* If past end of disk, return EINVAL. */
			bp->b_error = EINVAL;
			goto bad;
		}
		/* Otherwise, truncate request. */
		bp->b_bcount = sz << DEV_BSHIFT;
	}

	/* Overwriting disk label? */
	if (bp->b_blkno + blockpersec(DL_GETPOFFSET(p), lp) <= labelsector &&
	    bp->b_blkno + blockpersec(DL_GETPOFFSET(p), lp) + sz > labelsector &&
	    (bp->b_flags & B_READ) == 0 && !wlabel) {
		bp->b_error = EROFS;
		goto bad;
	}

	/* calculate cylinder for disksort to order transfers with */
	bp->b_cylinder = (bp->b_blkno + blockpersec(DL_GETPOFFSET(p), lp)) /
	    lp->d_secpercyl;
	return (1);

bad:
	bp->b_flags |= B_ERROR;
	return (-1);
@


1.50
log
@by hand i carefully found that all the differences in setdisklabel()
implimentations were simply either missing code, or spacing and such.
setdisklabel() can become MI now.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.49 2007/06/09 02:03:47 deraadt Exp $	*/
d330 1
a332 1
			case DOSPTYP_FAT16L:
d338 1
a338 2
				part_blkno =
				    letoh32(dp2->dp_start) + extoff;
@


1.49
log
@annoying spacing glitch which makes the diffs bigger
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.48 2007/06/07 23:12:41 krw Exp $	*/
a502 60
/*
 * Check new disk label for sensibility
 * before setting it.
 */
int
setdisklabel(struct disklabel *olp, struct disklabel *nlp,
    u_int openmask, struct cpu_disklabel *osdep)
{
	int i;
	struct partition *opp, *npp;

	/* sanity clause */
	if (nlp->d_secpercyl == 0 || nlp->d_secsize == 0 ||
	    (nlp->d_secsize % DEV_BSIZE) != 0)
		return (EINVAL);

	/*
	 * XXX Nice thought, but it doesn't work, if the intention was to
	 * force a reread at the next *readdisklabel call.  That does not
	 * happen.  There's still some use for it though as you can pseudo-
	 * partition the disk.
	 *
	 * Special case to allow disklabel to be invalidated.
	 */
	if (nlp->d_magic == 0xffffffff) {
		*olp = *nlp;
		return (0);
	}

	if (nlp->d_magic != DISKMAGIC || nlp->d_magic2 != DISKMAGIC ||
	    dkcksum(nlp) != 0)
		return (EINVAL);

	/* XXX missing check if other dos partitions will be overwritten */

	while (openmask != 0) {
		i = ffs(openmask) - 1;
		openmask &= ~(1 << i);
		if (nlp->d_npartitions <= i)
			return (EBUSY);
		opp = &olp->d_partitions[i];
		npp = &nlp->d_partitions[i];
		if (DL_GETPOFFSET(npp) != DL_GETPOFFSET(opp) ||
		    DL_GETPSIZE(npp) < DL_GETPSIZE(opp))
			return (EBUSY);
		/*
		 * Copy internally-set partition information
		 * if new label doesn't include it.		XXX
		 */
		if (npp->p_fstype == FS_UNUSED && opp->p_fstype != FS_UNUSED) {
			npp->p_fstype = opp->p_fstype;
			npp->p_fragblock = opp->p_fragblock;
			npp->p_cpg = opp->p_cpg;
		}
	}
	nlp->d_checksum = 0;
	nlp->d_checksum = dkcksum(nlp);
	*olp = *nlp;
	return (0);
}
@


1.48
log
@Fix typo introduced during ANSI-fication. Found by Rainer Giedat. MIPS
kernel compiles again.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.47 2007/06/07 12:10:07 otto Exp $	*/
d517 1
a517 1
		return(EINVAL);
@


1.47
log
@GET should have been SET
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.46 2007/06/07 02:55:12 krw Exp $	*/
d67 1
a67 1
    int spoofonly;
@


1.46
log
@Eliminate unnecessary duplicate defines *_LABELSECTOR and
*_LABELOFFSET.  Don't use osdep->labelsector since it will always be
LABELSECTOR, since we don't support extended DOS partitions holding
the OpenBSD disk label.

No functional change. Now only Alpha and Vax bounds_check_with_label
differ by more than comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.45 2007/06/07 00:28:17 krw Exp $	*/
d314 1
a314 1
			DL_GETPSIZE(pp, letoh32(dp2->dp_size));
@


1.45
log
@More bounds_check_with_label homogenization. Fix a couple of typos while
there.

'so go to it!' deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.44 2007/06/06 17:15:12 deraadt Exp $	*/
a173 4
	/* Record metainformation about the disklabel.  */
	if (msg == NULL) {
		osdep->labelsector = bp->b_blkno;
	}
d236 1
a236 1
	cyl = I386_LABELSECTOR / lp->d_secpercyl;
d391 1
a391 1
	msg = readbsdlabel(bp, strat, cyl, dospartoff + I386_LABELSECTOR, -1,
d469 2
a470 2
	msg = readbsdlabel(bp, strat, 0, fsoffs + SGI_LABELSECTOR,
	    SGI_LABELOFFSET, lp, spoofonly);
a581 6
	/*
	 * I once played with the thought of using osdep->label{tag,sector}
	 * as a cache for knowing where (and what) to write.  However, now I
	 * think it might be useful to reprobe if someone has written
	 * a newer disklabel of another type with disklabel(8) and -r.
	 */
d584 1
a584 1
	labeloffset = SGI_LABELOFFSET;
d588 1
a588 1
		labeloffset = I386_LABELOFFSET;
d624 1
a624 1
	    osdep->labelsector;
@


1.44
log
@now that all partition size/offsets are potentially 64-bit, change the
type of all variables to daddr64_t.  this includes the APIs for XXsize()
and XXdump(), all range checks inside bio drivers, internal variables
for disklabel handling, and even uvm's swap offsets.  re-read numerous
times by otto, miod, krw, thib to look for errors
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.43 2007/06/06 16:42:06 deraadt Exp $	*/
d649 1
a649 1
			goto done;
a674 1
done:
@


1.43
log
@a fair sprinking of knf, code movement, and sometimes character-by-character
accuracy so that the variious disksubr.c's can be compared easier.
setdisklabel() starts taking an int for openmask.
ok krw, and read by quite a few other people
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.42 2007/06/05 00:38:17 deraadt Exp $	*/
d224 1
a224 1
	daddr_t part_blkno = DOSBBSECTOR;
@


1.42
log
@use six new macros to access & store the 48-bit disklabel fields related
to size.  tested on almost all machines, double checked by miod and krw
next comes the type handling surrounding these values
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.41 2007/06/02 02:35:27 krw Exp $	*/
d65 3
a67 6
readbsdlabel(bp, strat, cyl, sec, off, lp, spoofonly)
	struct buf *bp;
	void (*strat)(struct buf *);
	int cyl, sec, off;
	struct disklabel *lp;
	int spoofonly;
d129 2
a130 6
readdisklabel(dev, strat, lp, osdep, spoofonly)
	dev_t dev;
	void (*strat)(struct buf *);
	struct disklabel *lp;
	struct cpu_disklabel *osdep;
	int spoofonly;
d165 1
a165 1
	}	
d402 1
a402 1
 * 
d449 1
a449 1
		if (cs != 0) 
d512 2
a513 4
setdisklabel(olp, nlp, openmask, osdep)
	struct disklabel *olp, *nlp;
	u_long openmask;
	struct cpu_disklabel *osdep;
d543 1
a543 1
		i = ffs((long)openmask) - 1;
d573 2
a574 5
writedisklabel(dev, strat, lp, osdep)
	dev_t dev;
	void (*strat)(struct buf *);
	struct disklabel *lp;
	struct cpu_disklabel *osdep;
@


1.41
log
@Rename cvtdisklabelv1 -> disklabeltokernlabel. It does more than just
convert version 0 to version 1 disklabels.

Suggested by deraadt@@.

ok deraadt@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.40 2007/05/31 19:57:43 krw Exp $	*/
d147 2
a148 2
	if (lp->d_secperunit == 0)
		lp->d_secperunit = 0x1fffffff;
d155 2
a156 2
		lp->d_partitions[i].p_size = 0;
		lp->d_partitions[i].p_offset = 0;
d158 3
a160 3
	if (lp->d_partitions[i].p_size == 0)
		lp->d_partitions[i].p_size = lp->d_secperunit;
	lp->d_partitions[i].p_offset = 0;
d294 3
a296 3
			lp->d_partitions[0].p_size = letoh32(dp2->dp_size);
			lp->d_partitions[0].p_offset =
			    letoh32(dp2->dp_start) + part_blkno;
d315 1
a315 1
			if (letoh32(dp2->dp_size) > lp->d_secperunit)
d317 1
a317 1
			if (letoh32(dp2->dp_start) > lp->d_secperunit)
d322 2
a323 2
				pp->p_offset =
				    letoh32(dp2->dp_start) + part_blkno;
d325 1
a325 1
			pp->p_size = letoh32(dp2->dp_size);
d388 3
a390 3
		lp->d_partitions['i' - 'a'].p_size =
		    lp->d_partitions[RAW_PART].p_size;
		lp->d_partitions['i' - 'a'].p_offset = 0;
d501 4
a504 2
		lp->d_partitions[bsd].p_offset = dlp->partitions[i].first;
		lp->d_partitions[bsd].p_size = dlp->partitions[i].blocks;
d558 2
a559 2
		if (npp->p_offset != opp->p_offset ||
		    npp->p_size < opp->p_size)
d645 1
a645 1
	int labelsector = blockpersec(lp->d_partitions[RAW_PART].p_offset, lp) +
d656 2
a657 2
	if (bp->b_blkno + sz > blockpersec(p->p_size, lp)) {
		sz = blockpersec(p->p_size, lp) - bp->b_blkno;
d673 2
a674 2
	if (bp->b_blkno + blockpersec(p->p_offset, lp) <= labelsector &&
	    bp->b_blkno + blockpersec(p->p_offset, lp) + sz > labelsector &&
d681 1
a681 1
	bp->b_cylinder = (bp->b_blkno + blockpersec(p->p_offset, lp)) /
@


1.40
log
@KNF, whitespace and comment rectification to make all
bounds_check_with_label() routines as identical as possible without
changing any code. Code nits and adjustments to come.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.39 2007/05/31 16:05:50 krw Exp $	*/
d204 1
a204 1
	cvtdisklabelv1(lp);
@


1.39
log
@Standardize on -1 as the error return value for
bounds_check_with_label. All callers check for <= 0, so no functional
change.

Feedback from miod@@.

ok weingart@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.38 2007/05/29 06:28:15 otto Exp $	*/
d638 2
a639 5
bounds_check_with_label(bp, lp, osdep, wlabel)
	struct buf *bp;
	struct disklabel *lp;
	struct cpu_disklabel *osdep;
	int wlabel;
d643 2
a644 2
	int labelsector = blockpersec(lp->d_partitions[RAW_PART].p_offset,
	    lp) + osdep->labelsector;
@


1.38
log
@Updated disklabel format to support larger disks and partitions. We
free room in struct partition by packing fragment size and
fragments/block more tighlty and use the resulting space to make
offset and size 48 bits.  For the disk part we use spare fields in
struct disklabel.  Kernel converts in-mem copy of the on-disk
label if needed, disklabel(8) writes new version.
We are careful to only change fields not used by bootloaders.
Conception of basic scheme by deraadt.
ok deraadt@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.37 2007/05/29 05:08:20 krw Exp $	*/
d689 1
a689 1
	return (0);
@


1.37
log
@Refactor readdisklabel() to ensure there is a single point of return, in
preparation for translating all disk labels visible to the kernel to
the soon to arrive V1 format.

ok otto@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.36 2007/02/18 14:18:28 krw Exp $	*/
d204 1
d505 2
a506 2
			lp->d_partitions[bsd].p_fsize = 1024;
			lp->d_partitions[bsd].p_frag = 8;
d565 1
a565 2
			npp->p_fsize = opp->p_fsize;
			npp->p_frag = opp->p_frag;
@


1.36
log
@Remove #ifdef/#endif's around MBR checking code. Remove now unused
option DISKLABEL_I386.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.35 2007/02/18 13:49:22 krw Exp $	*/
d149 4
a152 2
	if (lp->d_secpercyl == 0)
		return ("invalid geometry");
d199 1
@


1.35
log
@If no MBR partitions are found when spoofing a disklabel, try looking
for a bare FAT12/16/32 filesystem.  If one is found, spoof it as 'i'.
This enables iPod shuffles and other umass devices that are shipped
with a bare FAT32 filesystem to be used as install media. And
generally makes things easier for the user just trying to mount some
media, e.g.  floppies.

Does not make it safe to write a disklabel or MBR on such a device!
That will still obliterate the FAT filesystem.

Help and suggestions from tom@@ and deraadt@@. Feedback and suggestions
for future enhancements from espie@@ mickey@@ and peter@@.

ok tom@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.34 2007/02/03 18:22:33 krw Exp $	*/
a54 1
#if defined(DISKLABEL_I386)
a56 1
#endif
a170 1
#if defined(DISKLABEL_I386)
a178 1
#endif
a203 1
#if defined(DISKLABEL_I386)
a402 1
#endif
a601 1
#if defined(DISKLABEL_I386)
a606 1
#endif
@


1.34
log
@Don't spoof an msdosfs partition if it claims to start after the end
of the disk. Fixes the creation of spurious 'i' partitions on new iPod
Shuffle.  And other devices with no MBR, just a FAT32 filesystem.

Pointed out most recently by Stephan A. Rickauer for his sixth
generation, clip-on iPod shuffle.

Fix tested by Stephan.

ok pedro@@ tom@@ miod@@ 'nice' deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.33 2006/10/28 23:26:05 krw Exp $	*/
d231 1
d367 28
a394 1
	lp->d_npartitions = n > 0 ? n + 8 : 3;
@


1.33
log
@We don't currently write a disklabel into an OpenBSD ('A6') DOS MBR
extended partition except on alpha, hppa, hppa64 and mips64. So don't
spoof extended partitions as 'a' and try to read a disklabel from
them. Make all archs consistant.

When we can boot from extended partitions we can change to reading and
writing disklabels from them.

This means the first OpenBSD ('A6') extended partition will now be
ignored during spoofing, just as subsequent ones have always been.

Feedback from tom@@, weingart@@ and deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.32 2006/10/21 20:10:39 krw Exp $	*/
d316 2
@


1.32
log
@Don't try to spoof 0 length DOS MBR/EBR partitions. By skipping
partitions with 0 in the length field we don't need to test for
and skip partitions that are all zeros. Eliminating that code
allows elimination of a local pointer.

"0 length partitions are definately dead" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.31 2006/10/21 16:01:54 krw Exp $	*/
d275 1
a275 1
		if (ourpart == -1) {
@


1.31
log
@Some KNF cleanup.

De-register. Move declaration to top of function for DOS MBR
processing. Indent nit in macppc.

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.30 2006/10/21 14:18:37 krw Exp $	*/
d232 1
a232 1
	char *msg = NULL, *cp;
d317 2
a318 2
			if (letoh32(dp2->dp_size))
				pp->p_size = letoh32(dp2->dp_size);
d323 2
a326 11
				for (cp = (char *)dp2;
				    cp < (char *)(dp2 + 1); cp++)
					if (*cp)
						break;
				/*
				 * Was it all zeroes?  If so, it is
				 * an unused entry that we don't
				 * want to show.
				 */
				if (cp == (char *)(dp2 + 1))
				    continue;
@


1.30
log
@We have a pointer (pp), so use it in the DOSPTYP_UNUSED case rather
than lp->d_partitions[8+n++]. All other cases already use the pointer.

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.29 2006/10/20 23:47:43 krw Exp $	*/
d229 1
d311 1
a311 1
			struct partition *pp = &lp->d_partitions[8+n];
@


1.29
log
@Try again with local variable to avoid alignment issues.

"The dosparts member of cpu_disklabel was not used for any persistant
data. Eliminate it, and just use the data being read in while
processing MBR and EBR records.

Should be no functional change.

ok weingart@@ deraadt@@"
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.28 2006/10/18 20:09:39 deraadt Exp $	*/
d335 2
a336 2
				lp->d_partitions[8 + n++].p_fstype =
				    FS_UNUSED;
@


1.28
log
@back out disksubr changes ... since they violate strict alignment on
some architectures (kaboom); that will be fixed in the next iteration
hopefully!
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.26 2006/10/10 03:17:45 krw Exp $	*/
d228 3
a230 1
	struct dos_partition *dp = osdep->u._i386.dosparts, *dp2;
d233 1
a246 4
	if (dp) {
		daddr_t part_blkno = DOSBBSECTOR;
		unsigned long extoff = 0;
		int wander = 1, n = 0, loop = 0;
d248 57
d306 2
a307 2
		 * Read dos partition table, follow extended partitions.
		 * Map the partitions to disklabel entries i-p
d309 12
a320 22
		while (wander && n < 8 && loop < 8) {
			loop++;
			wander = 0;
			if (part_blkno < extoff)
				part_blkno = extoff;

			/* read boot record */
			bp->b_blkno = part_blkno;
			bp->b_bcount = lp->d_secsize;
			bp->b_flags = B_BUSY | B_READ;
			bp->b_cylinder = part_blkno / lp->d_secpercyl;
			(*strat)(bp);
 
			/* if successful, wander through dos partition table */
			if (biowait(bp)) {
				msg = "dos partition I/O error";
				if (partoffp)
					*partoffp = -1;
				return (msg);
			}
			bcopy(bp->b_data + DOSPARTOFF, dp,
			    NDOSPART * sizeof(*dp));
d322 6
a327 9
			if (ourpart == -1) {
				/* Search for our MBR partition */
				for (dp2=dp, i=0; i < NDOSPART && ourpart == -1;
				    i++, dp2++)
					if (letoh32(dp2->dp_size) &&
					    dp2->dp_typ == DOSPTYP_OPENBSD)
						ourpart = i;
				if (ourpart == -1)
					goto donot;
d329 3
a331 3
				 * This is our MBR partition. need sector
				 * address for SCSI/IDE, cylinder for
				 * ESDI/ST506/RLL
d333 10
a342 23
				dp2 = &dp[ourpart];
				dospartoff = letoh32(dp2->dp_start) + part_blkno;
				cyl = DPCYL(dp2->dp_scyl, dp2->dp_ssect);

				/* XXX build a temporary disklabel */
				lp->d_partitions[0].p_size = letoh32(dp2->dp_size);
				lp->d_partitions[0].p_offset =
				    letoh32(dp2->dp_start) + part_blkno;
				if (lp->d_ntracks == 0)
					lp->d_ntracks = dp2->dp_ehd + 1;
				if (lp->d_nsectors == 0)
					lp->d_nsectors = DPSECT(dp2->dp_esect);
				if (lp->d_secpercyl == 0)
					lp->d_secpercyl = lp->d_ntracks *
					    lp->d_nsectors;
			}
donot:
			/*
			 * In case the disklabel read below fails, we want to
			 * provide a fake label in i-p.
			 */
			for (dp2=dp, i=0; i < NDOSPART && n < 8; i++, dp2++) {
				struct partition *pp = &lp->d_partitions[8+n];
d344 16
a359 55
				if (dp2->dp_typ == DOSPTYP_OPENBSD)
					continue;
				if (letoh32(dp2->dp_size) > lp->d_secperunit)
					continue;
				if (letoh32(dp2->dp_size))
					pp->p_size = letoh32(dp2->dp_size);
				if (letoh32(dp2->dp_start))
					pp->p_offset =
					    letoh32(dp2->dp_start) + part_blkno;

				switch (dp2->dp_typ) {
				case DOSPTYP_UNUSED:
					for (cp = (char *)dp2;
					    cp < (char *)(dp2 + 1); cp++)
						if (*cp)
							break;
					/*
					 * Was it all zeroes?  If so, it is
					 * an unused entry that we don't
					 * want to show.
					 */
					if (cp == (char *)(dp2 + 1))
					    continue;
					lp->d_partitions[8 + n++].p_fstype =
					    FS_UNUSED;
					break;

				case DOSPTYP_LINUX:
					pp->p_fstype = FS_EXT2FS;
					n++;
					break;

				case DOSPTYP_FAT12:
				case DOSPTYP_FAT16S:
				case DOSPTYP_FAT16B:
				case DOSPTYP_FAT32:
				case DOSPTYP_FAT32L:
				case DOSPTYP_FAT16L:
					pp->p_fstype = FS_MSDOS;
					n++;
					break;
				case DOSPTYP_EXTEND:
				case DOSPTYP_EXTENDL:
					part_blkno =
					    letoh32(dp2->dp_start) + extoff;
					if (!extoff) {
						extoff = letoh32(dp2->dp_start);
						part_blkno = 0;
					}
					wander = 1;
					break;
				default:
					pp->p_fstype = FS_OTHER;
					n++;
					break;
d361 6
a368 3
		lp->d_bbsize = 8192;
		lp->d_sbsize = 64*1024;		/* XXX ? */
		lp->d_npartitions = n > 0 ? n + 8 : 3;
d370 3
@


1.27
log
@The dosparts member of cpu_disklabel was not used for any persistant
data. Eliminate it, and just use the data being read in while
processing MBR and EBR records.

Should be no functional change.

ok weingart@@ deraadt@@
@
text
@d228 1
a228 3
	struct dos_partition *dp, *dp2;
	unsigned long extoff = 0;
	daddr_t part_blkno = DOSBBSECTOR;
a230 1
	int wander = 1, n = 0, loop = 0;
d244 4
a248 57
	/*
	 * Read dos partition table, follow extended partitions.
	 * Map the partitions to disklabel entries i-p
	 */
	while (wander && n < 8 && loop < 8) {
		loop++;
		wander = 0;
		if (part_blkno < extoff)
			part_blkno = extoff;

		/* read boot record */
		bp->b_blkno = part_blkno;
		bp->b_bcount = lp->d_secsize;
		bp->b_flags = B_BUSY | B_READ;
		bp->b_cylinder = part_blkno / lp->d_secpercyl;
		(*strat)(bp);

		/* if successful, wander through dos partition table */
		if (biowait(bp)) {
			msg = "dos partition I/O error";
			if (partoffp)
				*partoffp = -1;
			return (msg);
		}
		dp = (struct dos_partition *)(bp->b_data + DOSPARTOFF);

		if (ourpart == -1) {
			/* Search for our MBR partition */
			for (dp2=dp, i=0; i < NDOSPART && ourpart == -1;
			    i++, dp2++)
				if (letoh32(dp2->dp_size) &&
				    dp2->dp_typ == DOSPTYP_OPENBSD)
					ourpart = i;
			if (ourpart == -1)
				goto donot;
			/*
			 * This is our MBR partition. need sector
			 * address for SCSI/IDE, cylinder for
			 * ESDI/ST506/RLL
			 */
			dp2 = &dp[ourpart];
			dospartoff = letoh32(dp2->dp_start) + part_blkno;
			cyl = DPCYL(dp2->dp_scyl, dp2->dp_ssect);

			/* XXX build a temporary disklabel */
			lp->d_partitions[0].p_size = letoh32(dp2->dp_size);
			lp->d_partitions[0].p_offset =
			    letoh32(dp2->dp_start) + part_blkno;
			if (lp->d_ntracks == 0)
				lp->d_ntracks = dp2->dp_ehd + 1;
			if (lp->d_nsectors == 0)
				lp->d_nsectors = DPSECT(dp2->dp_esect);
			if (lp->d_secpercyl == 0)
				lp->d_secpercyl = lp->d_ntracks *
				    lp->d_nsectors;
		}
donot:
d250 2
a251 2
		 * In case the disklabel read below fails, we want to
		 * provide a fake label in i-p.
d253 22
a274 2
		for (dp2=dp, i=0; i < NDOSPART && n < 8; i++, dp2++) {
			struct partition *pp = &lp->d_partitions[8+n];
d276 21
a296 8
			if (dp2->dp_typ == DOSPTYP_OPENBSD)
				continue;
			if (letoh32(dp2->dp_size) > lp->d_secperunit)
				continue;
			if (letoh32(dp2->dp_size))
				pp->p_size = letoh32(dp2->dp_size);
			if (letoh32(dp2->dp_start))
				pp->p_offset =
d298 15
d314 55
a368 38
			switch (dp2->dp_typ) {
			case DOSPTYP_UNUSED:
				for (cp = (char *)dp2;
				    cp < (char *)(dp2 + 1); cp++)
					if (*cp)
						break;
				/*
				 * Was it all zeroes?  If so, it is
				 * an unused entry that we don't
				 * want to show.
				 */
				if (cp == (char *)(dp2 + 1))
				    continue;
				lp->d_partitions[8 + n++].p_fstype =
				    FS_UNUSED;
				break;

			case DOSPTYP_LINUX:
				pp->p_fstype = FS_EXT2FS;
				n++;
				break;

			case DOSPTYP_FAT12:
			case DOSPTYP_FAT16S:
			case DOSPTYP_FAT16B:
			case DOSPTYP_FAT32:
			case DOSPTYP_FAT32L:
			case DOSPTYP_FAT16L:
				pp->p_fstype = FS_MSDOS;
				n++;
				break;
			case DOSPTYP_EXTEND:
			case DOSPTYP_EXTENDL:
				part_blkno =
				    letoh32(dp2->dp_start) + extoff;
				if (!extoff) {
					extoff = letoh32(dp2->dp_start);
					part_blkno = 0;
a369 6
				wander = 1;
				break;
			default:
				pp->p_fstype = FS_OTHER;
				n++;
				break;
d372 3
a375 3
	lp->d_bbsize = 8192;
	lp->d_sbsize = 64*1024;		/* XXX ? */
	lp->d_npartitions = n > 0 ? n + 8 : 3;
@


1.26
log
@Don't spoof a Free/NetBSD MBR partition as the 'a' partition in a
disklabel. Fixes 'double spoofing' of these partitions as both 'a' and
something in the 'i' to 'p' range.

OpenBSD changed its MBR partition type to 'A6' eight years ago.  As a
backward compatibility measure NetBSD and FreeBSD MBR partitions were
still spoofed as 'a' partitions when no OpenBSD partition could be
found. This bit of backward compatibility is no longer required.

'we can get rid of it' deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.25 2006/10/04 23:58:12 krw Exp $	*/
d228 3
a230 1
	struct dos_partition *dp = osdep->u._i386.dosparts, *dp2;
d233 1
a246 4
	if (dp) {
		daddr_t part_blkno = DOSBBSECTOR;
		unsigned long extoff = 0;
		int wander = 1, n = 0, loop = 0;
d248 57
d306 2
a307 2
		 * Read dos partition table, follow extended partitions.
		 * Map the partitions to disklabel entries i-p
d309 12
a320 22
		while (wander && n < 8 && loop < 8) {
			loop++;
			wander = 0;
			if (part_blkno < extoff)
				part_blkno = extoff;

			/* read boot record */
			bp->b_blkno = part_blkno;
			bp->b_bcount = lp->d_secsize;
			bp->b_flags = B_BUSY | B_READ;
			bp->b_cylinder = part_blkno / lp->d_secpercyl;
			(*strat)(bp);
 
			/* if successful, wander through dos partition table */
			if (biowait(bp)) {
				msg = "dos partition I/O error";
				if (partoffp)
					*partoffp = -1;
				return (msg);
			}
			bcopy(bp->b_data + DOSPARTOFF, dp,
			    NDOSPART * sizeof(*dp));
d322 6
a327 9
			if (ourpart == -1) {
				/* Search for our MBR partition */
				for (dp2=dp, i=0; i < NDOSPART && ourpart == -1;
				    i++, dp2++)
					if (letoh32(dp2->dp_size) &&
					    dp2->dp_typ == DOSPTYP_OPENBSD)
						ourpart = i;
				if (ourpart == -1)
					goto donot;
d329 3
a331 3
				 * This is our MBR partition. need sector
				 * address for SCSI/IDE, cylinder for
				 * ESDI/ST506/RLL
d333 10
a342 23
				dp2 = &dp[ourpart];
				dospartoff = letoh32(dp2->dp_start) + part_blkno;
				cyl = DPCYL(dp2->dp_scyl, dp2->dp_ssect);

				/* XXX build a temporary disklabel */
				lp->d_partitions[0].p_size = letoh32(dp2->dp_size);
				lp->d_partitions[0].p_offset =
				    letoh32(dp2->dp_start) + part_blkno;
				if (lp->d_ntracks == 0)
					lp->d_ntracks = dp2->dp_ehd + 1;
				if (lp->d_nsectors == 0)
					lp->d_nsectors = DPSECT(dp2->dp_esect);
				if (lp->d_secpercyl == 0)
					lp->d_secpercyl = lp->d_ntracks *
					    lp->d_nsectors;
			}
donot:
			/*
			 * In case the disklabel read below fails, we want to
			 * provide a fake label in i-p.
			 */
			for (dp2=dp, i=0; i < NDOSPART && n < 8; i++, dp2++) {
				struct partition *pp = &lp->d_partitions[8+n];
d344 16
a359 55
				if (dp2->dp_typ == DOSPTYP_OPENBSD)
					continue;
				if (letoh32(dp2->dp_size) > lp->d_secperunit)
					continue;
				if (letoh32(dp2->dp_size))
					pp->p_size = letoh32(dp2->dp_size);
				if (letoh32(dp2->dp_start))
					pp->p_offset =
					    letoh32(dp2->dp_start) + part_blkno;

				switch (dp2->dp_typ) {
				case DOSPTYP_UNUSED:
					for (cp = (char *)dp2;
					    cp < (char *)(dp2 + 1); cp++)
						if (*cp)
							break;
					/*
					 * Was it all zeroes?  If so, it is
					 * an unused entry that we don't
					 * want to show.
					 */
					if (cp == (char *)(dp2 + 1))
					    continue;
					lp->d_partitions[8 + n++].p_fstype =
					    FS_UNUSED;
					break;

				case DOSPTYP_LINUX:
					pp->p_fstype = FS_EXT2FS;
					n++;
					break;

				case DOSPTYP_FAT12:
				case DOSPTYP_FAT16S:
				case DOSPTYP_FAT16B:
				case DOSPTYP_FAT32:
				case DOSPTYP_FAT32L:
				case DOSPTYP_FAT16L:
					pp->p_fstype = FS_MSDOS;
					n++;
					break;
				case DOSPTYP_EXTEND:
				case DOSPTYP_EXTENDL:
					part_blkno =
					    letoh32(dp2->dp_start) + extoff;
					if (!extoff) {
						extoff = letoh32(dp2->dp_start);
						part_blkno = 0;
					}
					wander = 1;
					break;
				default:
					pp->p_fstype = FS_OTHER;
					n++;
					break;
d361 6
a368 3
		lp->d_bbsize = 8192;
		lp->d_sbsize = 64*1024;		/* XXX ? */
		lp->d_npartitions = n > 0 ? n + 8 : 3;
d370 3
@


1.25
log
@More instances of the same now unused variable as in alpha's
readdoslabel(). A bit of bad144 fallout.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.24 2006/10/04 03:23:01 krw Exp $	*/
a281 10
						ourpart = i;
				for (dp2=dp, i=0; i < NDOSPART && ourpart == -1;
				    i++, dp2++)
					if (letoh32(dp2->dp_size) &&
					    dp2->dp_typ == DOSPTYP_FREEBSD)
						ourpart = i;
				for (dp2=dp, i=0; i < NDOSPART && ourpart == -1;
				    i++, dp2++)
					if (letoh32(dp2->dp_size) &&
					    dp2->dp_typ == DOSPTYP_NETBSD)
@


1.24
log
@More tidying up after bad144. Remove references in comments and
don't include dkbad.h when nothing in it is used. Missed
arm/include/disklabel.h first time around.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.23 2006/10/03 01:37:22 krw Exp $	*/
a230 1
	dev_t dev;
@


1.23
log
@Don't load bad144 bad sector information into disklabels for archs that
don't have wd* in GENERIC, since wd* is the only place such info is
being used. First step of eliminating bad144 bad sector info from all
disklabels.

'go go go' deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.22 2006/09/16 14:56:12 krw Exp $	*/
d211 1
a211 2
 * find disklabel inside a DOS partition. Also, if bad block
 * table needed, attempt to extract it as well. Return buffer
@


1.22
log
@Revert new check for DOS partitions running past d_secperunit (e.g.
r1.54 of i386/disksubr.c). The check incorrectly handled extended
partitions. Possibly a symptom of a deeper problem with extended
partition offsets that will be addressed post-4.0.

Problem reported/fix tested by A. Velichinsky, cause diagnosed by
otto@@.

ok pedro@@ mickey@@ miod@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.21 2006/08/20 03:14:21 krw Exp $	*/
a229 1
	struct dkbad *db, *bdp = &DKBAD(osdep);
a397 42
	if (msg)
		return (msg);

	/* obtain bad sector table if requested and present */
	if (bdp && (lp->d_flags & D_BADSECT)) {
		/*
		 * get a new buffer and initialize it as callers trust the
		 * buffer given to us, to point at the disklabel sector.
		 */
		dev = bp->b_dev;
		bp = geteblk((int)lp->d_secsize);
		bp->b_dev = dev;

		i = 0;
		do {
			/* read a bad sector table */
			bp->b_flags = B_BUSY | B_READ;
			bp->b_blkno = lp->d_secperunit - lp->d_nsectors + i;
			if (lp->d_secsize > DEV_BSIZE)
				bp->b_blkno *= lp->d_secsize / DEV_BSIZE;
			else
				bp->b_blkno /= DEV_BSIZE / lp->d_secsize;
			bp->b_bcount = lp->d_secsize;
			bp->b_cylinder = lp->d_ncylinders - 1;
			(*strat)(bp);

			/* if successful, validate, otherwise try another */
			if (biowait(bp))
				msg = "bad sector table I/O error";
			else {
				db = (struct dkbad *)(bp->b_data);
#define DKBAD_MAGIC 0x4321
				if (db->bt_mbz == 0 &&
				    db->bt_flag == DKBAD_MAGIC) {
					msg = NULL;
					*bdp = *db;
					break;
				} else
					msg = "bad sector table corrupted";
			}
		} while ((bp->b_flags & B_ERROR) && (i += 2) < 10 &&
		    i < lp->d_nsectors);
a398 4
		/* Give back the bad block buffer.  */
		bp->b_flags |= B_INVAL;
		brelse(bp);
	}
@


1.21
log
@When spoofing an MSDOS disklabel, don't create partitions with a final
block past d_secperunit.

Fixes devices where bogus partitions with a starting offset >
d_secperunit were created. e.g. floppies formatted by Caldera DR-DOS.

ok pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.20 2006/08/18 00:39:17 krw Exp $	*/
a325 3
				u_int64_t blkno = (u_int64_t)part_blkno +
				    (u_int64_t)letoh32(dp2->dp_start) +
				    (u_int64_t)letoh32(dp2->dp_size);
d329 1
a329 1
				if (blkno > lp->d_secperunit)
@


1.20
log
@Oops. If you don't use a label, remove it.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.19 2006/08/17 10:34:14 krw Exp $	*/
d326 3
d332 1
a332 1
				if (letoh32(dp2->dp_size) > lp->d_secperunit)
@


1.19
log
@Check d_secpercyl in all readdisklable() functions, and have all of
them return 'invalid geometry' when d_secpercyl == 0. While there move
the check to a consistant location (after the check of d_secperunit)
and use a consistant idiom (i.e. some readdisklabel()'s have no 'done'
label).

prodded by thib@@ after a bad macppc experience. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.18 2006/08/11 21:32:40 krw Exp $	*/
a200 1
done:
@


1.18
log
@Use d_secperunit rather than 0x1fffffff as the default value for
RAW_PART's p_size. Since d_secperunit is initialized to 0x1fffffff if
not specified there should be no need to use the magic number again.
And if d_secperunit was specified then that value should be used
instead of the magic number.

This was already being done for hp300, luna88k, mac68k, mvme68k,
mvme88k.

Should be a no-op.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.17 2006/07/09 21:06:39 krw Exp $	*/
d151 2
a152 4
	if (lp->d_secpercyl == 0) {
		msg = "invalid geometry";
		goto done;
	}
@


1.17
log
@DISKLABEL_ALL was never used in hppa, hppa64, mips64 config files so
just eliminate the check to set DISKLABEL_I386 with it. If you want
DISKLABEL_I386, use that option.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.16 2006/07/07 23:47:37 krw Exp $	*/
d161 1
a161 1
		lp->d_partitions[i].p_size = 0x1fffffff;
@


1.16
log
@Unroll DLT_* logic into simple 'look for native disklabel, then try
DOS MBR' logic.

Leave DOS MBR logic inside #if defined(DISKLABEL_I386) blocks until
impact on install media can be evaluated. Eliminates most remnants
of cross-endian, cross-architecture disklabel processing attempts.

Fix some mips64 issues with last commit, found by kettenis@@.

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.15 2006/07/03 20:00:22 krw Exp $	*/
a51 5

/* The native defaults... */
#if defined(DISKLABEL_ALL) && !defined(DISKLABEL_I386)
#define DISKLABEL_I386
#endif
@


1.15
log
@Eliminate most of the #if/#endif maze in alpha, hppa, hppa64, and mips64
disklabel code that was intended to support cross-endian and cross-architecture
use of disklabels. Never actually used except for Alpha<->Amiga moves that now
can't happen anyway.

Leave native and DOS MBR disklabel code. Tested on alpha and hppa.

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.14 2006/07/01 16:50:33 krw Exp $	*/
d38 1
a38 1
 * This disksubr.c module started to take it's present form on OpenBSD/alpha
a67 2
static enum disklabel_tag probe_order[] = { LABELPROBES, -1 };

a147 1
	enum disklabel_tag *tp;
d174 6
a179 3
	for (tp = probe_order; msg && *tp != -1; tp++) {
		switch (*tp) {
		case DLT_I386:
d181 6
a186 16
			msg = readdoslabel(bp, strat, lp, osdep, 0, 0, spoofonly);
			if (msg)
				/* Fallback alternative */
				fallbacklabel = *lp;
#endif
			break;

		case DLT_SGI:
			msg = readsgilabel(bp, strat, lp, osdep, 0, 0, spoofonly);
			if (msg)
				/* Fallback alternative */
				fallbacklabel = *lp;
			break;

		default:
			panic("unrecognized disklabel tag %d", *tp);
a187 2
		if (msg)
			*lp = minilabel;
d189 1
a189 1

a192 1
		osdep->labeltag = *tp;
d531 1
a531 1
	    SGI_LABELOFFSET, BIG_ENDIAN, lp, spoofonly);
d584 1
a584 1
	 * partitition the disk.
a636 1
	enum disklabel_tag *tp;
d653 5
a657 1
	for (tp = probe_order; msg && *tp != -1; tp++) {
d659 3
a661 6
		switch (*tp) {
		case DLT_I386:
#if defined(DISKLABEL_I386)
			msg = readdoslabel(bp, strat, &dl, &cdl, &partoff,
			    &cyl, 0);
			labeloffset = I386_LABELOFFSET;
a662 13
			break;

		case DLT_SGI:
			msg = readsgilabel(bp, strat, &dl, &cdl, &partoff,
			    &cyl, 0);
			labeloffset = SGI_LABELOFFSET;
			break;

		default:
			panic("unrecognized disklabel tag %d", *tp);
		}
	}

@


1.14
log
@Eliminate redundant get_le() in favour of letoh32(). Add letoh32()
calls in alpha, hppa, hppa64 and mips63 when accessing the two DOS MBR
u_int32_t fields dp_size and dp_start.

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.13 2006/06/11 21:15:35 krw Exp $	*/
a41 3
 * XXX The DOS partitioning code is not endian-independent, only native
 * endian DOS partition tables can be parsed yet.
 *
d54 1
a54 3
#if defined(alpha) && !defined(DISKLABEL_ALPHA)
#define DISKLABEL_ALPHA
#elif (defined(i386) || defined(arc)) && !defined(DISKLABEL_I386)
a55 4
#elif defined(hppa) && !defined(DISKLABEL_HPPA)
#define DISKLABEL_HPPA
#elif defined(__sgi__) && !defined(DISKLABEL_SGI)
#define DISKLABEL_SGI
a57 2
#if defined(DISKLABEL_I386) || defined(DISKLABEL_ALPHA) || defined(DISKLABEL_HPPA) || defined(DISKLABEL_SGI) || defined(DISKLABEL_ALL)
void	swapdisklabel(struct disklabel *d);
d59 2
a60 3
    int, int, struct disklabel *, int);
#endif
#if defined(DISKLABEL_I386) || defined(DISKLABEL_ALL)
a63 5
#if defined(DISKLABEL_HPPA) || defined(DISKLABEL_ALL)
char   *readliflabel(struct buf *, void (*)(struct buf *),
    struct disklabel *, struct cpu_disklabel *, int *, int *, int);
#endif
#if defined(DISKLABEL_SGI) || defined(DISKLABEL_ALL)
a66 1
#endif
a69 49
#if defined(DISKLABEL_I386) || defined(DISKLABEL_ALPHA) || defined(DISKLABEL_HPPA) || defined(DISKLABEL_SGI) || defined(DISKLABEL_ALL)

/*
 * Byteswap all the fields that might be swapped.
 */
void
swapdisklabel(dlp)
	struct disklabel *dlp;
{
	int i;
	struct partition *pp;

	swap32(dlp->d_magic);
	swap16(dlp->d_type);
	swap16(dlp->d_subtype);
	swap32(dlp->d_secsize);
	swap32(dlp->d_nsectors);
	swap32(dlp->d_ntracks);
	swap32(dlp->d_ncylinders);
	swap32(dlp->d_secpercyl);
	swap32(dlp->d_secperunit);
	swap16(dlp->d_sparespertrack);
	swap16(dlp->d_sparespercyl);
	swap32(dlp->d_acylinders);
	swap16(dlp->d_rpm);
	swap16(dlp->d_interleave);
	swap16(dlp->d_trackskew);
	swap16(dlp->d_cylskew);
	swap32(dlp->d_headswitch);
	swap32(dlp->d_trkseek);
	swap32(dlp->d_flags);
	for (i = 0; i < NDDATA; i++)
		swap32(dlp->d_drivedata[i]);
	for (i = 0; i < NSPARE; i++)
		swap32(dlp->d_spare[i]);
	swap32(dlp->d_magic2);
	swap16(dlp->d_checksum);
	swap16(dlp->d_npartitions);
	swap32(dlp->d_bbsize);
	swap32(dlp->d_sbsize);
	for (i = 0; i < MAXPARTITIONS; i++) {
		pp = &dlp->d_partitions[i];
		swap32(pp->p_size);
		swap32(pp->p_offset);
		swap32(pp->p_fsize);
		swap16(pp->p_cpg);
	}
}

d74 1
a74 1
readbsdlabel(bp, strat, cyl, sec, off, endian, lp, spoofonly)
d77 1
a77 1
	int cyl, sec, off, endian;
a83 4
	u_int32_t magic;

	if (endian != LITTLE_ENDIAN && endian != BIG_ENDIAN)
		panic("readbsdlabel: unsupported byteorder %d", endian);
a101 2
	magic = endian == BIG_ENDIAN ? htobe32(DISKMAGIC) : htole32(DISKMAGIC);

d109 1
a109 1
		if (dlp->d_magic != magic || dlp->d_magic2 != magic) {
a113 2
			if (endian != BYTE_ORDER)
				swapdisklabel(dlp);
a115 3
				/* swap back if necessary.  */
				if (off < 0 && endian != BYTE_ORDER)
					swapdisklabel(dlp);
a117 5
				/* Recalc magic on foreign labels */
				if (endian != BYTE_ORDER) {
					lp->d_checksum = 0;
					lp->d_checksum = dkcksum(lp);
				}
a128 1
#endif
a178 7
		case DLT_ALPHA:
#if defined(DISKLABEL_ALPHA) || defined(DISKLABEL_ALL)
			msg = readbsdlabel(bp, strat, 0, ALPHA_LABELSECTOR,
			    ALPHA_LABELOFFSET, LITTLE_ENDIAN, lp, spoofonly);
#endif
			break;

d180 1
a180 1
#if defined(DISKLABEL_I386) || defined(DISKLABEL_ALL)
a187 6
		case DLT_HPPA:
#if defined(DISKLABEL_HPPA) || defined(DISKLABEL_ALL)
			msg = readliflabel(bp, strat, lp, osdep, 0, 0, spoofonly);
#endif
			break;

a188 1
#if defined(DISKLABEL_SGI) || defined(DISKLABEL_ALL)
a192 1
#endif
d229 1
a229 1
#if defined(DISKLABEL_I386) || defined(DISKLABEL_ALL)
d419 1
a419 1
	    LITTLE_ENDIAN, lp, spoofonly);
a470 165
#if defined(DISKLABEL_HPPA) || defined(DISKLABEL_ALL)
char *
readliflabel (bp, strat, lp, osdep, partoffp, cylp, spoofonly)
	struct buf *bp;
	void (*strat)(struct buf *);
	struct disklabel *lp;
	struct cpu_disklabel *osdep;
	int *partoffp;
	int *cylp;
	int spoofonly;
{
	int fsoff;

	/* read LIF volume header */
	bp->b_blkno = btodb(LIF_VOLSTART);
	bp->b_bcount = lp->d_secsize;
	bp->b_flags = B_BUSY | B_READ;
	bp->b_cylinder = btodb(LIF_VOLSTART) / lp->d_secpercyl;
	(*strat)(bp);

	if (biowait(bp)) {
		if (partoffp)
			*partoffp = -1;
		return "LIF volume header I/O error";
	}

	bcopy (bp->b_data, &osdep->u._hppa.lifvol, sizeof(struct lifvol));
	if (osdep->u._hppa.lifvol.vol_id != LIF_VOL_ID) {
		fsoff = 0;
	} else {
		struct lifdir *p;
		struct buf *dbp;
		dev_t dev;

		dev = bp->b_dev;
		dbp = geteblk(LIF_DIRSIZE);
		dbp->b_dev = dev;

		/* read LIF directory */
		dbp->b_blkno = lifstodb(osdep->u._hppa.lifvol.vol_addr);
		dbp->b_bcount = lp->d_secsize;
		dbp->b_flags = B_BUSY | B_READ;
		dbp->b_cylinder = dbp->b_blkno / lp->d_secpercyl;
		(*strat)(dbp);

		if (biowait(dbp)) {
			if (partoffp)
				*partoffp = -1;

			dbp->b_flags |= B_INVAL;
			brelse(dbp);
			return ("LIF directory I/O error");
		}

		bcopy(dbp->b_data, osdep->u._hppa.lifdir, LIF_DIRSIZE);
		dbp->b_flags |= B_INVAL;
		brelse(dbp);

		/* scan for LIF_DIR_FS dir entry */
		for (fsoff = -1,  p = &osdep->u._hppa.lifdir[0];
		    fsoff < 0 && p < &osdep->u._hppa.lifdir[LIF_NUMDIR]; p++) {
			if (p->dir_type == LIF_DIR_FS ||
			    p->dir_type == LIF_DIR_HPLBL)
				break;
		}

		if (p->dir_type == LIF_DIR_FS)
			fsoff = lifstodb(p->dir_addr);
		else if (p->dir_type == LIF_DIR_HPLBL) {
			struct hpux_label *hl;
			struct partition *pp;
			u_int8_t fstype;
			int i;

			dev = bp->b_dev;
			dbp = geteblk(LIF_DIRSIZE);
			dbp->b_dev = dev;

			/* read LIF directory */
			dbp->b_blkno = lifstodb(p->dir_addr);
			dbp->b_bcount = lp->d_secsize;
			dbp->b_flags = B_BUSY | B_READ;
			dbp->b_cylinder = dbp->b_blkno / lp->d_secpercyl;
			(*strat)(dbp);

			if (biowait(dbp)) {
				if (partoffp)
					*partoffp = -1;

				dbp->b_flags |= B_INVAL;
				brelse(dbp);
				return ("HOUX label I/O error");
			}

			bcopy(dbp->b_data, &osdep->u._hppa.hplabel,
			    sizeof(osdep->u._hppa.hplabel));
			dbp->b_flags |= B_INVAL;
			brelse(dbp);

			hl = &osdep->u._hppa.hplabel;
			if (hl->hl_magic1 != hl->hl_magic2 ||
			    hl->hl_magic != HPUX_MAGIC ||
			    hl->hl_version != 1) {
				if (partoffp)
					*partoffp = -1;

				return "HPUX label magic mismatch";
			}

			lp->d_bbsize = 8192;
			lp->d_sbsize = 8192;
			for (i = 0; i < MAXPARTITIONS; i++) {
				lp->d_partitions[i].p_size = 0;
				lp->d_partitions[i].p_offset = 0;
				lp->d_partitions[i].p_fstype = 0;
			}

			for (i = 0; i < HPUX_MAXPART; i++) {
				if (!hl->hl_flags[i])
					continue;

				if (hl->hl_flags[i] == HPUX_PART_ROOT) {
					pp = &lp->d_partitions[0];
					fstype = FS_BSDFFS;
				} else if (hl->hl_flags[i] == HPUX_PART_SWAP) {
					pp = &lp->d_partitions[1];
					fstype = FS_SWAP;
				} else if (hl->hl_flags[i] == HPUX_PART_BOOT) {
					pp = &lp->d_partitions[RAW_PART + 1];
					fstype = FS_BSDFFS;
				} else
					continue;

				pp->p_size = hl->hl_parts[i].hlp_length * 2;
				pp->p_offset = hl->hl_parts[i].hlp_start * 2;
				pp->p_fstype = fstype;
			}

			lp->d_partitions[RAW_PART].p_size = lp->d_secperunit;
			lp->d_partitions[RAW_PART].p_offset = 0;
			lp->d_partitions[RAW_PART].p_fstype = FS_UNUSED;
			lp->d_npartitions = MAXPARTITIONS;
			lp->d_magic = DISKMAGIC;
			lp->d_magic2 = DISKMAGIC;
			lp->d_checksum = 0;
			lp->d_checksum = dkcksum(lp);

			return (NULL);
		}

		/* if no suitable lifdir entry found assume zero */
		if (fsoff < 0) {
			fsoff = 0;
		}
	}

	if (partoffp)
		*partoffp = fsoff;

	return readbsdlabel(bp, strat, 0,  fsoff + HPPA_LABELSECTOR,
	    HPPA_LABELOFFSET, BIG_ENDIAN, lp, spoofonly);
}
#endif

#if defined(DISKLABEL_SGI) || defined(DISKLABEL_ALL)
a573 1
#endif
a653 1
#if defined(DISKLABEL_I386) || defined(DISKLABEL_HPPA) || defined(DISKLABEL_SGI) || defined(DISKLABEL_ALL)
d655 1
a655 3
#endif
	int labeloffset, error, i, endian, partoff = 0, cyl = 0;
	u_int64_t csum, *p;
a669 9
		case DLT_ALPHA:
#if defined(DISKLABEL_ALPHA) || defined(DISKLABEL_ALL)
			msg = readbsdlabel(bp, strat, 0, ALPHA_LABELSECTOR,
			    ALPHA_LABELOFFSET, LITTLE_ENDIAN, &dl, 0);
			labeloffset = ALPHA_LABELOFFSET;
			endian = LITTLE_ENDIAN;
#endif
			break;

d671 1
a671 1
#if defined(DISKLABEL_I386) || defined(DISKLABEL_ALL)
a674 10
			endian = LITTLE_ENDIAN;
#endif
			break;

		case DLT_HPPA:
#if defined(DISKLABEL_HPPA) || defined(DISKLABEL_ALL)
			msg = readliflabel(bp, strat, &dl, &cdl, &partoff,
			    &cyl, 0);
			labeloffset = HPPA_LABELOFFSET;
			endian = BIG_ENDIAN;
a678 1
#if defined(DISKLABEL_SGI) || defined(DISKLABEL_ALL)
a681 2
			endian = BIG_ENDIAN;
#endif
a694 1
		endian = BYTE_ORDER;
a699 7
	if (endian != BYTE_ORDER) {
		swapdisklabel(lp);
		/* recalc checksum */
		lp->d_checksum = 0;
		lp->d_checksum = dkcksum(lp);
	}

a700 7

	/* Alpha bootblocks are checksummed.  */
	if (*tp == DLT_ALPHA) {
		for (csum = i = 0, p = (u_int64_t *)bp->b_data; i < 63; i++)
			csum += *p++;
		*p = csum;
	}
@


1.13
log
@Amiga is no longer amoung us. Some architectures were too sentimental
to cut all ties when it left for the attic. Eliminate (theoretical)
ability to read Amiga disklabels on those architectures.

mips64 compile tested by miod@@

"whack away" deraadt@@ "my amiga runs 3.2" niklas@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.12 2006/03/15 20:20:40 miod Exp $	*/
d388 1
a388 1

d401 3
a403 3
				for (dp2=dp, i=0;
				    i < NDOSPART && ourpart == -1; i++, dp2++)
					if (dp2->dp_size &&
d406 3
a408 3
				for (dp2=dp, i=0;
				    i < NDOSPART && ourpart == -1; i++, dp2++)
					if (dp2->dp_size &&
d411 3
a413 3
				for (dp2=dp, i=0;
				    i < NDOSPART && ourpart == -1; i++, dp2++)
					if (dp2->dp_size &&
d424 1
a424 1
				dospartoff = dp2->dp_start + part_blkno;
d428 3
a430 3
				lp->d_partitions[0].p_size = dp2->dp_size;
				lp->d_partitions[0].p_offset = dp2->dp_start +
				    part_blkno;
d449 5
a453 3
				if (dp2->dp_size)
					pp->p_size = dp2->dp_size;
				if (dp2->dp_start)
d455 1
a455 1
					    dp2->dp_start + part_blkno;
d489 3
a491 1
					part_blkno = dp2->dp_start + extoff;
d493 1
a493 1
						extoff = dp2->dp_start;
@


1.12
log
@Nuke dk_establish(), no longer used.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.11 2006/03/04 19:33:21 miod Exp $	*/
a44 2
 * XXX Amiga RDB partitioning is not understood yet.
 *
a60 2
#elif defined(amiga) && !defined(DISKLABEL_AMIGA)
#define DISKLABEL_AMIGA
d67 1
a67 1
#if defined(DISKLABEL_I386) || defined(DISKLABEL_ALPHA) || defined(DISKLABEL_AMIGA) || defined(DISKLABEL_HPPA) || defined(DISKLABEL_SGI) || defined(DISKLABEL_ALL)
a75 4
#if defined(DISKLABEL_AMIGA) || defined(DISKLABEL_ALL)
char   *readamigalabel(struct buf *, void (*)(struct buf *),
    struct disklabel *, struct cpu_disklabel *, int);
#endif
d88 1
a88 1
#if defined(DISKLABEL_I386) || defined(DISKLABEL_ALPHA) || defined(DISKLABEL_AMIGA) || defined(DISKLABEL_HPPA) || defined(DISKLABEL_SGI) || defined(DISKLABEL_ALL)
a278 6
		case DLT_AMIGA:
#if defined(DISKLABEL_AMIGA) || defined(DISKLABEL_ALL)
			msg = readamigalabel(bp, strat, lp, osdep, spoofonly);
#endif
			break;

a565 20
#if defined(DISKLABEL_AMIGA) || defined(DISKLABEL_ALL)
/*
 * XXX RDB parsing is missing still.
 */
char *
readamigalabel(bp, strat, lp, osdep, spoofonly)
	struct buf *bp;
	void (*strat)(struct buf *);
	struct disklabel *lp;
	struct cpu_disklabel *osdep;
	int spoofonly;
{
	char *msg;

	msg = readbsdlabel(bp, strat, 0, AMIGA_LABELSECTOR, AMIGA_LABELOFFSET,
	    BIG_ENDIAN, lp, spoofonly);
	return (msg);
}
#endif

a948 8
#endif
			break;

		case DLT_AMIGA:
#if defined(DISKLABEL_AMIGA) || defined(DISKLABEL_ALL)
			msg = readamigalabel(bp, strat, &dl, &cdl, 0);
			labeloffset = AMIGA_LABELOFFSET;
			endian = BIG_ENDIAN;
@


1.11
log
@Typos grab bag of the month, eyeballed by jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.10 2006/01/22 00:40:01 miod Exp $	*/
a94 7

void
dk_establish(dk, dev)
	struct disk *dk;
	struct device *dev;
{
}
@


1.10
log
@b_cylin -> b_cylinder; no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.9 2005/12/22 03:02:48 krw Exp $	*/
d253 1
a253 1
	/* minimal requirements for archtypal disk label */
@


1.9
log
@'spoofonly' does not mean what I thought it meant. The whole point is
to read non-OpenBSD label information like MBRs and populate ('spoof')
the OpenBSD disk label appropriately. So avoiding an I/O when doing
'spoofonly' is to miss the whole point.

Backout all Sept. 26 and subsequent changes to disksubr.c files. The
original CD problem with I/O errors on blank media will be addressed
another way.

Should fix the ext3 vs amd64 problems discussed on misc@@. Thanks to
steven@@ for finally putting it terms that I understood.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.8 2005/09/27 23:56:12 krw Exp $	*/
a70 2
#define	b_cylin	b_resid

d176 1
a176 1
	bp->b_cylin = cyl;
d407 1
a407 1
			bp->b_cylin = part_blkno / lp->d_secpercyl;
d559 1
a559 1
			bp->b_cylin = lp->d_ncylinders - 1;
d624 1
a624 1
	bp->b_cylin = btodb(LIF_VOLSTART) / lp->d_secpercyl;
d649 1
a649 1
		dbp->b_cylin = dbp->b_blkno / lp->d_secpercyl;
d689 1
a689 1
			dbp->b_cylin = dbp->b_blkno / lp->d_secpercyl;
d797 1
a797 1
	bp->b_cylin = 0;
d1032 1
a1032 1
		bp->b_cylin = cyl;
d1111 1
a1111 1
	bp->b_cylin = (bp->b_blkno + blockpersec(p->p_offset, lp)) /
@


1.8
log
@Don't try to read the DOS label from the device if spoofonly is 1.
This changes the architectures which use code identical to the amd64
disksubr.c.

macppc seems different so it will be separate. The remaining archs
don't try to read a DOS label.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.7 2005/03/30 07:52:32 deraadt Exp $	*/
a403 5

			if (spoofonly) {
				bzero(dp, NDOSPART * sizeof(*dp));
				goto donot;
			}
@


1.7
log
@first approximation:  spoof UDF filesystem disklabels when we see them.
it is likely a slight bug or two will sneak in with this, so everyone
please keep an eye out on your disklabels
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.6 2004/10/30 14:48:59 pefo Exp $	*/
d404 5
@


1.6
log
@Make the default boot partition p.
Migrate float exception code to 64 bit. Add a few new "uniplemented".
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.5 2004/08/23 14:24:56 pefo Exp $	*/
d332 4
@


1.5
log
@new disklabel for sgi
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.16 2004/08/01 07:34:17 mickey Exp $	*/
d851 6
a856 6
        { 0,      FS_BSDFFS}, { 1,      FS_SWAP}, { 10,     FS_BSDFFS},
        { 3,      FS_BSDFFS}, { 4,      FS_BSDFFS}, { 5,      FS_BSDFFS},
        { 6,      FS_BSDFFS}, { 7,      FS_BSDFFS}, { 8,      FS_OTHER},
        { 9,      FS_BSDFFS}, { 2,      FS_UNUSED}, { 11,     FS_BSDFFS},
        { 12,     FS_BSDFFS}, { 13,     FS_BSDFFS}, { 14,     FS_BSDFFS},
        { 15,     FS_BSDFFS}
@


1.4
log
@spacing
@
text
@d1 1
a1 2
/*	$OpenBSD: disksubr.c,v 1.3 2004/08/10 20:28:13 deraadt Exp $	*/
/*	$NetBSD: disksubr.c,v 1.21 1996/05/03 19:42:03 christos Exp $	*/
d4 2
d18 1
a18 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d37 13
d58 12
a69 1
#include <mips64/archtype.h>
d73 24
a96 2
#define BOOT_MAGIC 0xAA55
#define BOOT_MAGIC_OFF (DOSPARTOFF+NDOSPART*sizeof(struct dos_partition))
d105 126
d233 1
a233 1
 * using the indicated stategy routine.
a238 9
 * If dos partition table requested, attempt to load it and
 * find disklabel inside a DOS partition. Also, if bad block
 * table needed, attempt to extract it as well. Return buffer
 * for use in signalling errors if requested.
 *
 * We would like to check if each MBR has a valid BOOT_MAGIC, but
 * we cannot because it doesn't always exist. So.. we assume the
 * MBR is valid.
 *
d244 1
a244 1
	void (*strat) __P((struct buf *));
d249 5
a253 6
	struct dos_partition *dp = osdep->dosparts, *dp2;
	struct dkbad *bdp = &DKBAD(osdep);
	struct buf *bp;
	struct disklabel *dlp;
	char *msg = NULL, *cp;
	int dospartoff, cyl, i, ourpart = -1;
d256 1
a256 1
	if (lp->d_secsize == 0)
d272 1
d278 105
d385 1
a385 1
	cyl = LABELSECTOR / lp->d_secpercyl;
d398 2
d411 3
a413 5
				goto done;
			}
			if (((int *)bp->b_data)[0] == 0x01084025 &&
			   ((int *)bp->b_data)[1] == 0x01294825) {
				goto nodoslabel;
d415 2
a416 1
			bcopy(bp->b_data + DOSPARTOFF, dp, NDOSPART * sizeof(*dp));
d420 3
a422 3
				for (dp2=dp, i=0; i < NDOSPART && ourpart == -1;
				    i++, dp2++)
					if (get_le(&dp2->dp_size) &&
d425 3
a427 3
				for (dp2=dp, i=0; i < NDOSPART && ourpart == -1;
				    i++, dp2++)
					if (get_le(&dp2->dp_size) &&
d430 3
a432 3
				for (dp2=dp, i=0; i < NDOSPART && ourpart == -1;
				    i++, dp2++)
					if (get_le(&dp2->dp_size) &&
d438 3
a440 2
				 * This is our MBR partition. need sector address
				 * for SCSI/IDE, cylinder for ESDI/ST506/RLL
d443 1
a443 1
				dospartoff = get_le(&dp2->dp_start) + part_blkno;
d447 3
a449 3
				lp->d_partitions[0].p_size = get_le(&dp2->dp_size);
				lp->d_partitions[0].p_offset =
					get_le(&dp2->dp_start) + part_blkno;
d468 3
a470 5
				if (get_le(&dp2->dp_size) > lp->d_secperunit)
					continue;
				if (get_le(&dp2->dp_size))
					pp->p_size = get_le(&dp2->dp_size);
				if (get_le(&dp2->dp_start))
d472 1
a472 1
					    get_le(&dp2->dp_start) + part_blkno;
d506 5
a510 3
					part_blkno = get_le(&dp2->dp_start) + extoff;
					if (!extoff)
						extoff = get_le(&dp2->dp_start);
d522 1
a522 1
		lp->d_npartitions = MAXPARTITIONS;
d525 5
a529 4
nodoslabel:
	/* don't read the on-disk label if we are in spoofed-only mode */
	if (spoofonly)
		goto done;
d532 4
a535 35
	bp->b_blkno = dospartoff + LABELSECTOR;
	bp->b_cylin = cyl;
	bp->b_bcount = lp->d_secsize;
	bp->b_flags = B_BUSY | B_READ;
	(*strat)(bp);

	/* if successful, locate disk label within block and validate */
	if (biowait(bp)) {
		/* XXX we return the faked label built so far */
		msg = "disk label I/O error";
		goto done;
	}
	for (dlp = (struct disklabel *)bp->b_data;
	    dlp <= (struct disklabel *)(bp->b_data + lp->d_secsize - sizeof(*dlp));
	    dlp = (struct disklabel *)((char *)dlp + sizeof(long))) {
		if (dlp->d_magic != DISKMAGIC || dlp->d_magic2 != DISKMAGIC) {
			if (msg == NULL)
				msg = "no disk label";
		} else if (dlp->d_npartitions > MAXPARTITIONS ||
			   dkcksum(dlp) != 0)
			msg = "disk label corrupted";
		else {
			*lp = *dlp;
			msg = NULL;
			break;
		}
	}

	if (msg) {
#if defined(CD9660)
		if (iso_disklabelspoof(dev, strat, lp) == 0)
			msg = NULL;
#endif
		goto done;
	}
d539 7
a545 1
		struct dkbad *db;
d561 1
a561 1
			if (biowait(bp)) {
d563 1
a563 1
			} else {
d566 2
a567 2
				if (db->bt_mbz == 0
					&& db->bt_flag == DKBAD_MAGIC) {
d575 5
a579 1
			i < lp->d_nsectors);
d581 17
d599 2
a600 3
done:
	bp->b_flags |= B_INVAL;
	brelse(bp);
d603 271
d893 8
a900 1
	/* special case to allow disklabel to be invalidated */
d913 1
a913 1
		i = ffs(openmask) - 1;
d919 2
a920 1
		if (npp->p_offset != opp->p_offset || npp->p_size < opp->p_size)
a941 1
 * XXX cannot handle OpenBSD partitions in extended partitions!
d946 1
a946 1
	void (*strat) __P((struct buf *));
d950 2
a951 1
	struct dos_partition *dp = osdep->dosparts, *dp2;
d953 6
a958 3
	struct disklabel *dlp;
	int error, dospartoff, cyl, i;
	int ourpart = -1;
d964 26
a989 10
	/* do dos partitions in the process of getting disklabel? */
	dospartoff = 0;
	cyl = LABELSECTOR / lp->d_secpercyl;
	if (dp) {
		/* read master boot record */
		bp->b_blkno = DOSBBSECTOR;
		bp->b_bcount = lp->d_secsize;
		bp->b_flags = B_BUSY | B_READ;
		bp->b_cylin = DOSBBSECTOR / lp->d_secpercyl;
		(*strat)(bp);
d991 7
a997 2
		if ((error = biowait(bp)) != 0)
			goto done;
d999 8
a1006 17
		if (((int *)bp->b_data)[0] == 0x01084025 &&
		    ((int *)bp->b_data)[1] == 0x01294825) {
			goto nodoslabel;
		}
		/* XXX how do we check veracity/bounds of this? */
		bcopy(bp->b_data + DOSPARTOFF, dp,
		    NDOSPART * sizeof(*dp));

		for (dp2=dp, i=0; i < NDOSPART && ourpart == -1; i++, dp2++)
			if (get_le(&dp2->dp_size) && dp2->dp_typ == DOSPTYP_OPENBSD)
				ourpart = i;
		for (dp2=dp, i=0; i < NDOSPART && ourpart == -1; i++, dp2++)
			if (get_le(&dp2->dp_size) && dp2->dp_typ == DOSPTYP_FREEBSD)
				ourpart = i;
		for (dp2=dp, i=0; i < NDOSPART && ourpart == -1; i++, dp2++)
			if (get_le(&dp2->dp_size) && dp2->dp_typ == DOSPTYP_NETBSD)
				ourpart = i;
d1008 8
a1015 2
		if (ourpart != -1) {
			dp2 = &dp[ourpart];
d1017 2
a1018 6
			/*
			 * need sector address for SCSI/IDE,
			 * cylinder for ESDI/ST506/RLL
			 */
			dospartoff = get_le(&dp2->dp_start);
			cyl = DPCYL(dp2->dp_scyl, dp2->dp_ssect);
d1022 20
a1041 7
nodoslabel:
	/* next, dig out disk label */
	bp->b_blkno = dospartoff + LABELSECTOR;
	bp->b_cylin = cyl;
	bp->b_bcount = lp->d_secsize;
	bp->b_flags = B_BUSY | B_READ;
	(*strat)(bp);
d1043 5
a1047 14
	/* if successful, locate disk label within block and validate */
	if ((error = biowait(bp)) != 0)
		goto done;
	for (dlp = (struct disklabel *)bp->b_data;
	    dlp <= (struct disklabel *)(bp->b_data + lp->d_secsize - sizeof(*dlp));
	    dlp = (struct disklabel *)((char *)dlp + sizeof(long))) {
		if (dlp->d_magic == DISKMAGIC && dlp->d_magic2 == DISKMAGIC &&
		    dkcksum(dlp) == 0) {
			*dlp = *lp;
			bp->b_flags = B_BUSY | B_WRITE;
			(*strat)(bp);
			error = biowait(bp);
			goto done;
		}
a1049 2
	/* Write it in the regular place. */
	*(struct disklabel *)bp->b_data = *lp;
a1052 1
	goto done;
a1053 1
done:
d1073 2
a1074 2
	int labelsector = blockpersec(lp->d_partitions[RAW_PART].p_offset, lp) +
	    LABELSECTOR;
d1077 7
a1101 1
#if LABELSECTOR != 0
a1102 1
#endif
@


1.3
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.2 2004/08/10 20:15:47 deraadt Exp $	*/
d122 1
a122 1
	        daddr_t part_blkno = DOSBBSECTOR;
d131 1
a131 1
		        loop++;
@


1.2
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.1 2004/08/06 20:56:03 pefo Exp $	*/
d146 1
a146 1
			if(((int *)bp->b_data)[0] == 0x01084025 &&
d433 2
a434 2
		if(((int *)bp->b_data)[0] == 0x01084025 &&
		   ((int *)bp->b_data)[1] == 0x01294825) {
@


1.1
log
@initial mips64
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.6 1998/10/03 21:18:55 millert Exp $	*/
d140 1
a140 1
		     
@

