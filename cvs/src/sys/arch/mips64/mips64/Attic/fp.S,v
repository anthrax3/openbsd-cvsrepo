head	1.10;
access;
symbols
	OPENBSD_4_8:1.9.0.4
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.2
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.7.0.22
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.18
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.16
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.14
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.12
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.10
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.8
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.6
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.4
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.2
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.5.0.2
	OPENBSD_3_6_BASE:1.5;
locks; strict;
comment	@# @;


1.10
date	2010.09.21.20.29.17;	author miod;	state dead;
branches;
next	1.9;

1.9
date	2010.02.08.19.26.46;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2009.08.09.13.41.30;	author jsing;	state Exp;
branches;
next	1.7;

1.7
date	2004.11.02.18.54.45;	author pefo;	state Exp;
branches;
next	1.6;

1.6
date	2004.10.30.14.48.59;	author pefo;	state Exp;
branches;
next	1.5;

1.5
date	2004.09.10.09.32.13;	author pefo;	state Exp;
branches;
next	1.4;

1.4
date	2004.09.10.08.58.27;	author pefo;	state Exp;
branches;
next	1.3;

1.3
date	2004.09.09.22.11.38;	author pefo;	state Exp;
branches;
next	1.2;

1.2
date	2004.08.15.18.35.58;	author pefo;	state Exp;
branches;
next	1.1;

1.1
date	2004.08.06.20.56.03;	author pefo;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Replace the old floating point completion code with a C interface to the
MI softfloat code, implementing all MIPS IV specified floating point
operations.
Tested on R5000, R10000, R14000 and Loongson2F.
@
text
@/*	$OpenBSD: fp.S,v 1.9 2010/02/08 19:26:46 miod Exp $	*/
/*
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Ralph Campbell.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	from: @@(#)fp.s	8.1 (Berkeley) 6/10/93
 *      $Id: fp.S,v 1.9 2010/02/08 19:26:46 miod Exp $
 */

/*
 * Standard header stuff.
 */

#include <machine/regdef.h>
#include <machine/asm.h>
#include <machine/regnum.h>
#include <machine/cpu.h>

#include "assym.h"

#define SEXP_INF	0xff
#define DEXP_INF	0x7ff
#define SEXP_BIAS	127
#define DEXP_BIAS	1023
#define SEXP_MIN	-126
#define DEXP_MIN	-1022
#define SEXP_MAX	127
#define DEXP_MAX	1023
#define WEXP_MAX	30		/* maximum unbiased exponent for int */
#define WEXP_MIN	-1		/* minimum unbiased exponent for int */
#define LEXP_MAX	62		/* maximum unbiased exponent for long */
#define LEXP_MIN	-1		/* minimum unbiased exponent for long */
#define SFRAC_BITS	23
#define DFRAC_BITS	52
#define SIMPL_ONE	0x00800000
#define DIMPL_ONE	0x0010000000000000
#define SLEAD_ZEROS	63 - 55
#define DLEAD_ZEROS	63 - 52
#define STICKYBIT	1
#define GUARDBIT	0x0000000080000000
#define DGUARDBIT	0x8000000000000000

#define SSIGNAL_NAN	0x00400000
#define DSIGNAL_NAN	0x00080000
#define SQUIET_NAN	0x003fffff
#define DQUIET_NAN	0x0007ffffffffffff
#define INT_MIN		0x80000000
#define INT_MAX		0x7fffffff
#define LONG_MIN	0x8000000000000000
#define LONG_MAX	0x7fffffffffffffff

#define COND_UNORDERED	0x1
#define COND_EQUAL	0x2
#define COND_LESS	0x4
#define COND_SIGNAL	0x8

/*----------------------------------------------------------------------------
 *
 * MipsEmulateFP --
 *
 *	Emulate unimplemented floating point operations.
 *	This routine should only be called by MipsFPInterrupt()
 *	and only if this is a COP1 instruction.
 *
 *	MipsEmulateFP(instr)
 *		unsigned instr;
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Floating point registers are modified according to instruction.
 *
 *----------------------------------------------------------------------------
 */
NON_LEAF(MipsEmulateFP, FRAMESZ(CF_SZ), ra)
	PTR_SUB	sp, sp, FRAMESZ(CF_SZ)
	PTR_S	ra, CF_RA_OFFS(sp)

	srl	v0, a0, 21			# get FMT field
	and	v0, v0, 0x1f			# mask FMT field
	dla	a3, func_s
	beq	v0, 0x10, 1f
	dla	a3, func_d
	beq	v0, 0x11, 1f
	dla	a3, func_w
	beq	v0, 0x14, 1f
	dla	a3, func_l
	beq	v0, 0x15, 1f
	b	ill				# illegal format

1:
	and	v1, a0, 0x3f			# mask FUNC field
	sll	v1, v1, 3			# align for table lookup
	daddu	v1, a3
	cfc1	a1, FPC_CSR			# get exception register
	ld	a3, (v1)			# switch on FUNC & FMT
	and	a1, a1, ~FPC_EXCEPTION_UNIMPL	# clear exception
	ctc1	a1, FPC_CSR
	j	a3

	.rdata
func_s:
	.dword	add_s		# 0
	.dword	sub_s		# 1
	.dword	mul_s		# 2
	.dword	div_s		# 3
	.dword	ill		# 4 (sqrt)
	.dword	abs_s		# 5
	.dword	mov_s		# 6
	.dword	neg_s		# 7
	.dword	round_l_s	# 8
	.dword	trunc_l_s	# 9
	.dword	ceil_l_s	# 10
	.dword	floor_l_s	# 11
	.dword	round_w_s	# 12
	.dword	trunc_w_s	# 13
	.dword	ceil_w_s	# 14
	.dword	floor_w_s	# 15
	.dword	ill		# 16
	.dword	ill		# 17
	.dword	ill		# 18
	.dword	ill		# 19
	.dword	ill		# 20
	.dword	ill		# 21
	.dword	ill		# 22
	.dword	ill		# 23
	.dword	ill		# 24
	.dword	ill		# 25
	.dword	ill		# 26
	.dword	ill		# 27
	.dword	ill		# 28
	.dword	ill		# 29
	.dword	ill		# 30
	.dword	ill		# 31
	.dword	ill		# 32
	.dword	cvt_d_s		# 33
	.dword	ill		# 34
	.dword	ill		# 35
	.dword	cvt_w_s		# 36
	.dword	cvt_l_s		# 37
	.dword	ill		# 38
	.dword	ill		# 39
	.dword	ill		# 40
	.dword	ill		# 41
	.dword	ill		# 42
	.dword	ill		# 43
	.dword	ill		# 44
	.dword	ill		# 45
	.dword	ill		# 46
	.dword	ill		# 47
	.dword	cmp_s		# 48
	.dword	cmp_s		# 49
	.dword	cmp_s		# 50
	.dword	cmp_s		# 51
	.dword	cmp_s		# 52
	.dword	cmp_s		# 53
	.dword	cmp_s		# 54
	.dword	cmp_s		# 55
	.dword	cmp_s		# 56
	.dword	cmp_s		# 57
	.dword	cmp_s		# 58
	.dword	cmp_s		# 59
	.dword	cmp_s		# 60
	.dword	cmp_s		# 61
	.dword	cmp_s		# 62
	.dword	cmp_s		# 63

func_d:
	.dword	add_d		# 0
	.dword	sub_d		# 1
	.dword	mul_d		# 2
	.dword	div_d		# 3
	.dword	ill		# 4 (sqrt)
	.dword	abs_d		# 5
	.dword	mov_d		# 6
	.dword	neg_d		# 7
	.dword	round_l_d	# 8
	.dword	trunc_l_d	# 9
	.dword	ceil_l_d	# 10
	.dword	floor_l_d	# 11
	.dword	round_w_d	# 12
	.dword	trunc_w_d	# 13
	.dword	ceil_w_d	# 14
	.dword	floor_w_d	# 15
	.dword	ill		# 16
	.dword	ill		# 17
	.dword	ill		# 18
	.dword	ill		# 19
	.dword	ill		# 20
	.dword	ill		# 21
	.dword	ill		# 22
	.dword	ill		# 23
	.dword	ill		# 24
	.dword	ill		# 25
	.dword	ill		# 26
	.dword	ill		# 27
	.dword	ill		# 28
	.dword	ill		# 29
	.dword	ill		# 30
	.dword	ill		# 31
	.dword	cvt_s_d		# 32
	.dword	ill		# 33
	.dword	ill		# 34
	.dword	ill		# 35
	.dword	cvt_w_d		# 36
	.dword	cvt_l_d		# 37
	.dword	ill		# 38
	.dword	ill		# 39
	.dword	ill		# 40
	.dword	ill		# 41
	.dword	ill		# 42
	.dword	ill		# 43
	.dword	ill		# 44
	.dword	ill		# 45
	.dword	ill		# 46
	.dword	ill		# 47
	.dword	cmp_d		# 48
	.dword	cmp_d		# 49
	.dword	cmp_d		# 50
	.dword	cmp_d		# 51
	.dword	cmp_d		# 52
	.dword	cmp_d		# 53
	.dword	cmp_d		# 54
	.dword	cmp_d		# 55
	.dword	cmp_d		# 56
	.dword	cmp_d		# 57
	.dword	cmp_d		# 58
	.dword	cmp_d		# 59
	.dword	cmp_d		# 60
	.dword	cmp_d		# 61
	.dword	cmp_d		# 62
	.dword	cmp_d		# 63

func_w:
	.dword	ill		# 0
	.dword	ill		# 1
	.dword	ill		# 2
	.dword	ill		# 3
	.dword	ill		# 4
	.dword	ill		# 5
	.dword	ill		# 6
	.dword	ill		# 7
	.dword	ill		# 8
	.dword	ill		# 9
	.dword	ill		# 10
	.dword	ill		# 11
	.dword	ill		# 12
	.dword	ill		# 13
	.dword	ill		# 14
	.dword	ill		# 15
	.dword	ill		# 16
	.dword	ill		# 17
	.dword	ill		# 18
	.dword	ill		# 19
	.dword	ill		# 20
	.dword	ill		# 21
	.dword	ill		# 22
	.dword	ill		# 23
	.dword	ill		# 24
	.dword	ill		# 25
	.dword	ill		# 26
	.dword	ill		# 27
	.dword	ill		# 28
	.dword	ill		# 29
	.dword	ill		# 30
	.dword	ill		# 31
	.dword	cvt_s_w		# 32
	.dword	cvt_d_w		# 33
	.dword	ill		# 34
	.dword	ill		# 35
	.dword	ill		# 36
	.dword	ill		# 37
	.dword	ill		# 38
	.dword	ill		# 39
	.dword	ill		# 40
	.dword	ill		# 41
	.dword	ill		# 42
	.dword	ill		# 43
	.dword	ill		# 44
	.dword	ill		# 45
	.dword	ill		# 46
	.dword	ill		# 47
	.dword	ill		# 48
	.dword	ill		# 49
	.dword	ill		# 50
	.dword	ill		# 51
	.dword	ill		# 52
	.dword	ill		# 53
	.dword	ill		# 54
	.dword	ill		# 55
	.dword	ill		# 56
	.dword	ill		# 57
	.dword	ill		# 58
	.dword	ill		# 59
	.dword	ill		# 60
	.dword	ill		# 61
	.dword	ill		# 62
	.dword	ill		# 63

func_l:
	.dword	ill		# 0
	.dword	ill		# 1
	.dword	ill		# 2
	.dword	ill		# 3
	.dword	ill		# 4
	.dword	ill		# 5
	.dword	ill		# 6
	.dword	ill		# 7
	.dword	ill		# 8
	.dword	ill		# 9
	.dword	ill		# 10
	.dword	ill		# 11
	.dword	ill		# 12
	.dword	ill		# 13
	.dword	ill		# 14
	.dword	ill		# 15
	.dword	ill		# 16
	.dword	ill		# 17
	.dword	ill		# 18
	.dword	ill		# 19
	.dword	ill		# 20
	.dword	ill		# 21
	.dword	ill		# 22
	.dword	ill		# 23
	.dword	ill		# 24
	.dword	ill		# 25
	.dword	ill		# 26
	.dword	ill		# 27
	.dword	ill		# 28
	.dword	ill		# 29
	.dword	ill		# 30
	.dword	ill		# 31
	.dword	cvt_s_l		# 32
	.dword	cvt_d_l		# 33
	.dword	ill		# 34
	.dword	ill		# 35
	.dword	ill		# 36
	.dword	ill		# 37
	.dword	ill		# 38
	.dword	ill		# 39
	.dword	ill		# 40
	.dword	ill		# 41
	.dword	ill		# 42
	.dword	ill		# 43
	.dword	ill		# 44
	.dword	ill		# 45
	.dword	ill		# 46
	.dword	ill		# 47
	.dword	ill		# 48
	.dword	ill		# 49
	.dword	ill		# 50
	.dword	ill		# 51
	.dword	ill		# 52
	.dword	ill		# 53
	.dword	ill		# 54
	.dword	ill		# 55
	.dword	ill		# 56
	.dword	ill		# 57
	.dword	ill		# 58
	.dword	ill		# 59
	.dword	ill		# 60
	.dword	ill		# 61
	.dword	ill		# 62
	.dword	ill		# 63

	.text

/*
 * Single precision subtract.
 */
sub_s:
	jal	get_ft_fs_s
	xor	ta0, 1				# negate FT sign bit
	b	add_sub_s
/*
 * Single precision add.
 */
add_s:
	jal	get_ft_fs_s
add_sub_s:
	bne	t1, SEXP_INF, 1f		# is FS an infinity?
	bne	ta1, SEXP_INF, result_fs_s	# if FT is not inf, result=FS
	bne	t2, zero, result_fs_s		# if FS is NAN, result is FS
	bne	ta2, zero, result_ft_s		# if FT is NAN, result is FT
	bne	t0, ta0, invalid_s		# both infinities same sign?
	b	result_fs_s			# result is in FS
1:
	beq	ta1, SEXP_INF, result_ft_s	# if FT is inf, result=FT
	bne	t1, zero, 4f			# is FS a denormalized num?
	beq	t2, zero, 3f			# is FS zero?
	bne	ta1, zero, 2f			# is FT a denormalized num?
	beq	ta2, zero, result_fs_s		# FT is zero, result=FS
	jal	renorm_fs_s
	jal	renorm_ft_s
	b	5f
2:
	jal	renorm_fs_s
	subu	ta1, ta1, SEXP_BIAS		# unbias FT exponent
	or	ta2, ta2, SIMPL_ONE		# set implied one bit
	b	5f
3:
	bne	ta1, zero, result_ft_s		# if FT != 0, result=FT
	bne	ta2, zero, result_ft_s
	and	v0, a1, FPC_ROUNDING_BITS	# get rounding mode
	bne	v0, FPC_ROUND_RM, 1f	# round to -infinity?
	or	t0, t0, ta0			# compute result sign
	b	result_fs_s
1:
	and	t0, ta0				# compute result sign
	b	result_fs_s
4:
	bne	ta1, zero, 2f			# is FT a denormalized num?
	beq	ta2, zero, result_fs_s		# FT is zero, result=FS
	subu	t1, SEXP_BIAS			# unbias FS exponent
	or	t2, SIMPL_ONE			# set implied one bit
	jal	renorm_ft_s
	b	5f
2:
	subu	t1, SEXP_BIAS			# unbias FS exponent
	or	t2, SIMPL_ONE			# set implied one bit
	subu	ta1, SEXP_BIAS			# unbias FT exponent
	or	ta2, SIMPL_ONE			# set implied one bit
/*
 * Perform the addition.
 */
5:
	move	t8, zero			# no shifted bits (sticky reg)
	beq	t1, ta1, 4f			# exp equal, no shift needed
	subu	v0, t1, ta1			# v0 = difference of exponents
	move	v1, v0				# v1 = abs(difference)
	bge	v0, zero, 1f
	negu	v1
1:
	ble	v1, SFRAC_BITS+2, 2f		# is difference too great?
	li	t8, STICKYBIT			# set the sticky bit
	bge	v0, zero, 1f			# check which exp is larger
	move	t1, ta1				# result exp is FTs
	move	t2, zero			# FSs fraction shifted is zero
	b	4f
1:
	move	ta2, zero			# FTs fraction shifted is zero
	b	4f
2:
	li	t9, 32				# compute 32 - abs(exp diff)
	subu	t9, t9, v1
	bgt	v0, zero, 3f			# if FS > FT, shift FTs frac
	move	t1, ta1				# FT > FS, result exp is FTs
	sll	t8, t2, t9			# save bits shifted out
	srl	t2, t2, v1			# shift FSs fraction
	b	4f
3:
	sll	t8, ta2, t9			# save bits shifted out
	srl	ta2, ta2, v1			# shift FTs fraction
4:
	bne	t0, ta0, 1f			# if signs differ, subtract
	addu	t2, t2, ta2			# add fractions
	b	norm_s
1:
	blt	t2, ta2, 3f			# subtract larger from smaller
	bne	t2, ta2, 2f			# if same, result=0
	move	t1, zero			# result=0
	move	t2, zero
	and	v0, a1, FPC_ROUNDING_BITS	# get rounding mode
	bne	v0, FPC_ROUND_RM, 1f	# round to -infinity?
	or	t0, t0, ta0			# compute result sign
	b	result_fs_s
1:
	and	t0, t0, ta0			# compute result sign
	b	result_fs_s
2:
	sltu	t9, zero, t8			# compute t2:zero - ta2:t8
	subu	t8, zero, t8
	subu	t2, t2, ta2			# subtract fractions
	subu	t2, t2, t9			# subtract barrow
	b	norm_s
3:
	move	t0, ta0				# sign of result = FTs
	sltu	t9, zero, t8			# compute ta2:zero - t2:t8
	subu	t8, zero, t8
	subu	t2, ta2, t2			# subtract fractions
	subu	t2, t2, t9			# subtract barrow
	b	norm_s

/*
 * Double precision subtract.
 */
sub_d:
	jal	get_ft_fs_d
	xor	ta0, ta0, 1			# negate sign bit
	b	add_sub_d
/*
 * Double precision add.
 */
add_d:
	jal	get_ft_fs_d
add_sub_d:
	bne	t1, DEXP_INF, 1f		# is FS an infinity?
	bne	ta1, DEXP_INF, result_fs_d	# if FT is not inf, result=FS
	bne	t2, zero, result_fs_d		# if FS is NAN, result is FS
	bne	ta2, zero, result_ft_d		# if FT is NAN, result is FT
	bne	t0, ta0, invalid_d		# both infinities same sign?
	b	result_fs_d			# result is in FS
1:
	beq	ta1, DEXP_INF, result_ft_d	# if FT is inf, result=FT
	bne	t1, zero, 4f			# is FS a denormalized num?
	beq	t2, zero, 3f			# is FS zero?
	bne	ta1, zero, 2f			# is FT a denormalized num?
	beq	ta2, zero, result_fs_d		# FT is zero, result=FS
	jal	renorm_fs_d
	jal	renorm_ft_d
	b	5f
2:
	jal	renorm_fs_d
	subu	ta1, ta1, DEXP_BIAS		# unbias FT exponent
	or	ta2, ta2, DIMPL_ONE		# set implied one bit
	b	5f
3:
	bne	ta1, zero, result_ft_d		# if FT != 0, result=FT
	bne	ta2, zero, result_ft_d
	and	v0, a1, FPC_ROUNDING_BITS	# get rounding mode
	bne	v0, FPC_ROUND_RM, 1f	# round to -infinity?
	or	t0, t0, ta0			# compute result sign
	b	result_fs_d
1:
	and	t0, t0, ta0			# compute result sign
	b	result_fs_d
4:
	bne	ta1, zero, 2f			# is FT a denormalized num?
	beq	ta2, zero, result_fs_d		# FT is zero, result=FS
	subu	t1, t1, DEXP_BIAS		# unbias FS exponent
	or	t2, t2, DIMPL_ONE		# set implied one bit
	jal	renorm_ft_d
	b	5f
2:
	subu	t1, t1, DEXP_BIAS		# unbias FS exponent
	or	t2, t2, DIMPL_ONE		# set implied one bit
	subu	ta1, ta1, DEXP_BIAS		# unbias FT exponent
	or	ta2, ta2, DIMPL_ONE		# set implied one bit
/*
 * Perform the addition.
 */
5:
	move	t8, zero			# no shifted bits (sticky reg)
	beq	t1, ta1, 4f			# no shift needed
	subu	v0, t1, ta1			# v0 = difference of exponents
	move	v1, v0				# v1 = abs(difference)
	bge	v0, zero, 1f
	negu	v1
1:
	ble	v1, DFRAC_BITS+2, 2f		# is difference too great?
	li	t8, STICKYBIT			# set the sticky bit
	bge	v0, zero, 1f			# check which exp is larger
	move	t1, ta1				# result exp is FTs
	move	t2, zero			# FSs fraction shifted is zero
	b	4f
1:
	move	ta2, zero			# FTs fraction shifted is zero
	b	4f
2:
	li	t9, 64
	subu	t9, t9, v1
	bge	v0, zero, 3f			# if FS > FT, shift FTs frac
	move	t1, ta1				# FT > FS, result exp is FTs
	dsll	t8, t2, t9			# save bits shifted out
	dsrl	t2, t2, v1
	b	4f
3:
	dsll	t8, ta2, t9			# save bits shifted out
	dsrl	ta2, ta2, v1
4:
	bne	t0, ta0, 1f			# if signs differ, subtract
	daddu	t2, ta2				# add fractions
	b	norm_d
1:
	blt	t2, ta2, 3f			# subtract larger from smaller
	bne	t2, ta2, 2f
	move	t1, zero			# result=0
	move	t2, zero
	and	v0, a1, FPC_ROUNDING_BITS	# get rounding mode
	bne	v0, FPC_ROUND_RM, 1f	# round to -infinity?
	or	t0, t0, ta0			# compute result sign
	b	result_fs_d
1:
	and	t0, t0, ta0			# compute result sign
	b	result_fs_d
2:
	sltu	t9, zero, t8			# compute t2:zero - ta2:t8
	dsubu	t8, zero, t8
	dsubu	t2, t2, ta2			# subtract fractions
	dsubu	t2, t2, t9			# subtract barrow
	b	norm_d
3:
	move	t0, ta0				# sign of result = FTs
	sltu	t9, zero, t8
	dsubu	t2, ta2, t2			# subtract fractions
	dsubu	t2, t2, t9			# subtract barrow
	b	norm_d

/*
 * Single precision multiply.
 */
mul_s:
	jal	get_ft_fs_s
	xor	t0, t0, ta0			# compute sign of result
	move	ta0, t0
	bne	t1, SEXP_INF, 2f		# is FS an infinity?
	bne	t2, zero, result_fs_s		# if FS is a NAN, result=FS
	bne	ta1, SEXP_INF, 1f		# FS is inf, is FT an infinity?
	bne	ta2, zero, result_ft_s		# if FT is a NAN, result=FT
	b	result_fs_s			# result is infinity
1:
	bne	ta1, zero, result_fs_s		# inf * zero? if no, result=FS
	bne	ta2, zero, result_fs_s
	b	invalid_s			# infinity * zero is invalid
2:
	bne	ta1, SEXP_INF, 1f		# FS != inf, is FT an infinity?
	bne	t1, zero, result_ft_s		# zero * inf? if no, result=FT
	bne	t2, zero, result_ft_s
	bne	ta2, zero, result_ft_s		# if FT is a NAN, result=FT
	b	invalid_s			# zero * infinity is invalid
1:
	bne	t1, zero, 1f			# is FS zero?
	beq	t2, zero, result_fs_s		# result is zero
	jal	renorm_fs_s
	b	2f
1:
	subu	t1, t1, SEXP_BIAS		# unbias FS exponent
	or	t2, t2, SIMPL_ONE		# set implied one bit
2:
	bne	ta1, zero, 1f			# is FT zero?
	beq	ta2, zero, result_ft_s		# result is zero
	jal	renorm_ft_s
	b	2f
1:
	subu	ta1, ta1, SEXP_BIAS		# unbias FT exponent
	or	ta2, ta2, SIMPL_ONE		# set implied one bit
2:
	addu	t1, t1, ta1			# compute result exponent
	addu	t1, t1, 9			# account for binary point
	multu	t2, ta2				# multiply fractions
	mflo	t8
	mfhi	t2
	b	norm_s

/*
 * Double precision multiply.
 */
mul_d:
	jal	get_ft_fs_d
	xor	t0, t0, ta0			# compute sign of result
	move	ta0, t0
	bne	t1, DEXP_INF, 2f		# is FS an infinity?
	bne	t2, zero, result_fs_d		# if FS is a NAN, result=FS
	bne	ta1, DEXP_INF, 1f		# FS is inf, is FT an infinity?
	bne	ta2, zero, result_ft_d		# if FT is a NAN, result=FT
	b	result_fs_d			# result is infinity
1:
	bne	ta1, zero, result_fs_d		# inf * zero? if no, result=FS
	bne	ta2, zero, result_fs_d
	b	invalid_d			# infinity * zero is invalid
2:
	bne	ta1, DEXP_INF, 1f		# FS != inf, is FT an infinity?
	bne	t1, zero, result_ft_d		# zero * inf? if no, result=FT
	bne	t2, zero, result_ft_d		# if FS is a NAN, result=FS
	bne	ta2, zero, result_ft_d		# if FT is a NAN, result=FT
	b	invalid_d			# zero * infinity is invalid
1:
	bne	t1, zero, 2f			# is FS zero?
	beq	t2, zero, result_fs_d		# result is zero
	jal	renorm_fs_d
	b	3f
2:
	subu	t1, t1, DEXP_BIAS		# unbias FS exponent
	or	t2, t2, DIMPL_ONE		# set implied one bit
3:
	bne	ta1, zero, 2f			# is FT zero?
	beq	ta2, zero, result_ft_d		# result is zero
	jal	renorm_ft_d
	b	3f
2:
	subu	ta1, ta1, DEXP_BIAS		# unbias FT exponent
	or	ta2, ta2, DIMPL_ONE		# set implied one bit
3:
	addu	t1, t1, ta1			# compute result exponent
	addu	t1, t1, 12			# ???
	dmultu	t2, ta2				# multiply fractions
	mflo	t8
	mfhi	t2
	b	norm_d

/*
 * Single precision divide.
 */
div_s:
	jal	get_ft_fs_s
	xor	t0, t0, ta0			# compute sign of result
	move	ta0, t0
	bne	t1, SEXP_INF, 1f		# is FS an infinity?
	bne	t2, zero, result_fs_s		# if FS is NAN, result is FS
	bne	ta1, SEXP_INF, result_fs_s	# is FT an infinity?
	bne	ta2, zero, result_ft_s		# if FT is NAN, result is FT
	b	invalid_s			# infinity/infinity is invalid
1:
	bne	ta1, SEXP_INF, 1f		# is FT an infinity?
	bne	ta2, zero, result_ft_s		# if FT is NAN, result is FT
	move	t1, zero			# x / infinity is zero
	move	t2, zero
	b	result_fs_s
1:
	bne	t1, zero, 2f			# is FS zero?
	bne	t2, zero, 1f
	bne	ta1, zero, result_fs_s		# FS=zero, is FT zero?
	beq	ta2, zero, invalid_s		# 0 / 0
	b	result_fs_s			# result = zero
1:
	jal	renorm_fs_s
	b	3f
2:
	subu	t1, t1, SEXP_BIAS		# unbias FS exponent
	or	t2, t2, SIMPL_ONE		# set implied one bit
3:
	bne	ta1, zero, 2f			# is FT zero?
	bne	ta2, zero, 1f
	or	a1, a1, FPC_EXCEPTION_DIV0 | FPC_STICKY_DIV0
	and	v0, a1, FPC_ENABLE_DIV0	# trap enabled?
	bne	v0, zero, fpe_trap
	ctc1	a1, FPC_CSR		# save exceptions
	li	t1, SEXP_INF			# result is infinity
	move	t2, zero
	b	result_fs_s
1:
	jal	renorm_ft_s
	b	3f
2:
	subu	ta1, ta1, SEXP_BIAS		# unbias FT exponent
	or	ta2, ta2, SIMPL_ONE		# set implied one bit
3:
	subu	t1, t1, ta1			# compute exponent
	subu	t1, t1, 3			# compensate for result position
	li	v0, SFRAC_BITS+3		# number of bits to divide
	move	t8, t2				# init dividend
	move	t2, zero			# init result
1:
	bltu	t8, ta2, 3f			# is dividend >= divisor?
2:
	subu	t8, t8, ta2			# subtract divisor from dividend
	or	t2, t2, 1			# remember that we did
	bne	t8, zero, 3f			# if not done, continue
	sll	t2, t2, v0			# shift result to final position
	b	norm_s
3:
	sll	t8, t8, 1			# shift dividend
	sll	t2, t2, 1			# shift result
	subu	v0, v0, 1			# are we done?
	bne	v0, zero, 1b			# no, continue
	b	norm_s

/*
 * Double precision divide.
 */
div_d:
	jal	get_ft_fs_d
	xor	t0, t0, ta0			# compute sign of result
	move	ta0, t0
	bne	t1, DEXP_INF, 1f		# is FS an infinity?
	bne	t2, zero, result_fs_d		# if FS is NAN, result is FS
	bne	ta1, DEXP_INF, result_fs_d	# is FT an infinity?
	bne	ta2, zero, result_ft_d		# if FT is NAN, result is FT
	b	invalid_d			# infinity/infinity is invalid
1:
	bne	ta1, DEXP_INF, 1f		# is FT an infinity?
	bne	ta2, zero, result_ft_d		# if FT is NAN, result is FT
	move	t1, zero			# x / infinity is zero
	move	t2, zero
	b	result_fs_d
1:
	bne	t1, zero, 2f			# is FS zero?
	bne	t2, zero, 1f
	bne	ta1, zero, result_fs_d		# FS=zero, is FT zero?
	beq	ta2, zero, invalid_d		# 0 / 0
	b	result_fs_d			# result = zero
1:
	jal	renorm_fs_d
	b	3f
2:
	subu	t1, t1, DEXP_BIAS		# unbias FS exponent
	or	t2, t2, DIMPL_ONE		# set implied one bit
3:
	bne	ta1, zero, 2f			# is FT zero?
	bne	ta2, zero, 1f
	or	a1, a1, FPC_EXCEPTION_DIV0 | FPC_STICKY_DIV0
	and	v0, a1, FPC_ENABLE_DIV0	# trap enabled?
	bne	v0, zero, fpe_trap
	ctc1	a1, FPC_CSR			# Save exceptions
	li	t1, DEXP_INF			# result is infinity
	move	t2, zero
	b	result_fs_d
1:
	jal	renorm_ft_d
	b	3f
2:
	subu	ta1, ta1, DEXP_BIAS		# unbias FT exponent
	or	ta2, ta2, DIMPL_ONE		# set implied one bit
3:
	subu	t1, t1, ta1			# compute exponent
	subu	t1, t1, 3			# compensate for result position
	li	v0, DFRAC_BITS+3		# number of bits to divide
	move	t8, t2				# init dividend
	move	t2, zero			# init result
1:
	bltu	t8, ta2, 3f			# is dividend >= divisor?
2:
	dsubu	t8, t8, ta2			# subtract divisor from dividend
	or	t2, t2, 1			# remember that we did
	bne	t8, zero, 3f			# if not done, continue
	dsll	t2, t2, v0			# shift upper part
	b	norm_d
3:
	dsll	t8, t8, 1			# shift dividend
	dsll	t2, t2, 1			# shift result
	subu	v0, v0, 1			# are we done?
	bne	v0, zero, 1b			# no, continue
	b	norm_d

/*
 * Single precision absolute value.
 */
abs_s:
	jal	get_fs_s
	move	t0, zero			# set sign positive
	b	result_fs_s

/*
 * Double precision absolute value.
 */
abs_d:
	jal	get_fs_d
	move	t0, zero			# set sign positive
	b	result_fs_d

/*
 * Single precision move.
 */
mov_s:
	jal	get_fs_s
	b	result_fs_s

/*
 * Double precision move.
 */
mov_d:
	jal	get_fs_d
	b	result_fs_d

/*
 * Single precision negate.
 */
neg_s:
	jal	get_fs_s
	xor	t0, t0, 1			# reverse sign
	b	result_fs_s

/*
 * Double precision negate.
 */
neg_d:
	jal	get_fs_d
	xor	t0, t0, 1			# reverse sign
	b	result_fs_d

/*
 * Convert double to single.
 */
cvt_s_d:
	jal	get_fs_d
	bne	t1, DEXP_INF, 1f		# is FS an infinity?
	li	t1, SEXP_INF			# convert to single
	dsll	t2, t2, 3			# convert D fraction to S
	b	result_fs_s
1:
	bne	t1, zero, 2f			# is FS zero?
	beq	t2, zero, result_fs_s		# result=0
	jal	renorm_fs_d
	subu	t1, t1, 3			# correct exp for shift below
	b	3f
2:
	subu	t1, t1, DEXP_BIAS		# unbias exponent
	or	t2, t2, DIMPL_ONE		# add implied one bit
3:
	dsll	t2, t2, 3			# convert D fraction to S
	b	norm_noshift_s

/*
 * Convert long integer to single.
 */
cvt_s_l:
	jal	get_fs_long
	b	cvt_s_int
/*
 * Convert integer to single.
 */
cvt_s_w:
	jal	get_fs_int
cvt_s_int:
	bne	t2, zero, 1f			# check for zero
	move	t1, zero
	b	result_fs_s
/*
 * Find out how many leading zero bits are in t2 and put in t9.
 */
1:
	move	v0, t2
	move	t9, zero
	dsrl	v1, v0, 32
	bne	v1, zero, 1f
	addu	t9, 32
	dsll	v0, 32
1:
	dsrl	v1, v0, 16
	bne	v1, zero, 1f
	addu	t9, 16
	dsll	v0, 16
1:
	dsrl	v1, v0, 24
	bne	v1, zero, 1f
	addu	t9, 8
	dsll	v0, 8
1:
	dsrl	v1, v0, 28
	bne	v1, zero, 1f
	addu	t9, 4
	dsll	v0, 4
1:
	dsrl	v1, v0, 30
	bne	v1, zero, 1f
	addu	t9, 2
	dsll	v0, 2
1:
	dsrl	v1, v0, 31
	bne	v1, zero, 1f
	addu	t9, 1
/*
 * Now shift t2 the correct number of bits.
 */
1:
	subu	t9, SLEAD_ZEROS			# dont count leading zeros
	li	t1, 23+32			# init exponent
	subu	t1, t1, t9			# compute exponent
	beq	t9, zero, 1f
	li	v0, 32
	blt	t9, zero, 2f			# if shift < 0, shift right
	subu	v0, v0, t9
	sll	t2, t2, t9			# shift left
1:
	add	t1, t1, SEXP_BIAS		# bias exponent
	and	t2, t2, ~SIMPL_ONE		# clear implied one bit
	b	result_fs_s
2:
	negu	t9				# shift right by t9
	subu	v0, v0, t9
	sll	t8, t2, v0			# save bits shifted out
	srl	t2, t2, t9
	b	norm_noshift_s

/*
 * Convert single to double.
 */
cvt_d_s:
	jal	get_fs_s
	dsll	t2, 32
	bne	t1, SEXP_INF, 1f		# is FS an infinity?
	li	t1, DEXP_INF			# convert to double
	b	result_fs_d
1:
	bne	t1, zero, 2f			# is FS denormalized or zero?
	beq	t2, zero, result_fs_d		# is FS zero?
	jal	renorm_fs_s
	move	t8, zero
	b	norm_d
2:
	addu	t1, t1, DEXP_BIAS - SEXP_BIAS	# bias exponent correctly
	dsrl	t2, t2, 3
	b	result_fs_d

/*
 * Convert long integer to double.
 */
cvt_d_l:
	jal	get_fs_long
	b	cvt_d_int
/*
 * Convert integer to double.
 */
cvt_d_w:
	jal	get_fs_int
cvt_d_int:
	bne	t2, zero, 1f			# check for zero
	move	t1, zero			# result=0
	b	result_fs_d
/*
 * Find out how many leading zero bits are in t2 and put in t9.
 */
1:
	move	v0, t2
	move	t9, zero
	dsrl	v1, v0, 32
	bne	v1, zero, 1f
	addu	t9, 32
	dsll	v0, 32
1:
	dsrl	v1, v0, 16
	bne	v1, zero, 1f
	addu	t9, 16
	dsll	v0, 16
1:
	dsrl	v1, v0, 24
	bne	v1, zero, 1f
	addu	t9, 8
	dsll	v0, 8
1:
	dsrl	v1, v0, 28
	bne	v1, zero, 1f
	addu	t9, 4
	dsll	v0, 4
1:
	dsrl	v1, v0, 30
	bne	v1, zero, 1f
	addu	t9, 2
	dsll	v0, 2
1:
	dsrl	v1, v0, 31
	bne	v1, zero, 1f
	addu	t9, 1
/*
 * Now shift t2 the correct number of bits.
 */
1:
	subu	t9, t9, DLEAD_ZEROS		# dont count leading zeros
	li	t1, DEXP_BIAS + 20		# init exponent
	subu	t1, t1, t9			# compute exponent
	beq	t9, zero, 1f
	li	v0, 64
	blt	t9, zero, 2f			# if shift < 0, shift right
	subu	v0, v0, t9
	dsll	t2, t2, t9			# shift left
1:
	and	t2, t2, ~DIMPL_ONE		# clear implied one bit
	b	result_fs_d
2:
	negu	t9				# shift right by t9
	subu	v0, v0, t9
	dsrl	t2, t2, t9
	and	t2, t2, ~DIMPL_ONE		# clear implied one bit
	b	result_fs_d

/*
 * Convert single to integer with specific rounding.
 */
round_w_s:
	li	t3, FPC_ROUND_RN
	b	do_cvt_w_s
trunc_w_s:
	li	t3, FPC_ROUND_RZ
	b	do_cvt_w_s
ceil_w_s:
	li	t3, FPC_ROUND_RP
	b	do_cvt_w_s
floor_w_s:
	li	t3, FPC_ROUND_RM
	b	do_cvt_w_s

/*
 * Convert single to integer.
 */
cvt_w_s:
	and	t3, a1, FPC_ROUNDING_BITS	# get rounding mode
do_cvt_w_s:
	jal	get_fs_s
	bne	t1, SEXP_INF, 1f		# is FS an infinity?
	bne	t2, zero, invalid_w		# invalid conversion
1:
	bne	t1, zero, 1f			# is FS zero?
	beq	t2, zero, result_fs_w		# result is zero
	move	t2, zero			# result is an inexact zero
	b	inexact_w
1:
	subu	t1, t1, SEXP_BIAS		# unbias exponent
	or	t2, t2, SIMPL_ONE		# add implied one bit
	dsll	t2, t2, DFRAC_BITS - SFRAC_BITS	# convert S fraction to D
	b	cvt_w

/*
 * Convert double to integer with specific rounding.
 */
round_w_d:
	li	t3, FPC_ROUND_RN
	b	do_cvt_w_d
trunc_w_d:
	li	t3, FPC_ROUND_RZ
	b	do_cvt_w_d
ceil_w_d:
	li	t3, FPC_ROUND_RP
	b	do_cvt_w_d
floor_w_d:
	li	t3, FPC_ROUND_RM
	b	do_cvt_w_d

/*
 * Convert double to integer.
 */
cvt_w_d:
	and	t3, a1, FPC_ROUNDING_BITS	# get rounding mode
do_cvt_w_d:
	jal	get_fs_d
	bne	t1, DEXP_INF, 1f		# is FS an infinity?
	bne	t2, zero, invalid_w		# invalid conversion
1:
	bne	t1, zero, 2f			# is FS zero?
	beq	t2, zero, result_fs_w		# result is zero
	move	t2, zero			# result is an inexact zero
	b	inexact_w
2:
	subu	t1, t1, DEXP_BIAS		# unbias exponent
	or	t2, t2, DIMPL_ONE		# add implied one bit
cvt_w:
	blt	t1, WEXP_MIN, underflow_w	# is exponent too small?
	li	v0, WEXP_MAX+1
	bgt	t1, v0, overflow_w		# is exponent too large?
	bne	t1, v0, 1f			# special check for INT_MIN
	beq	t0, zero, overflow_w		# if positive, overflow
	bne	t2, DIMPL_ONE, overflow_w
	li	t2, INT_MIN			# result is INT_MIN
	b	result_fs_w
1:
	subu	v0, t1, 20			# compute amount to shift
	beq	v0, zero, 2f			# is shift needed?
	li	v1, 64
	blt	v0, zero, 1f			# if shift < 0, shift right
	subu	v1, v1, v0			# shift left
	dsll	t2, t2, v0
	b	2f
1:
	negu	v0				# shift right by v0
	subu	v1, v1, v0
	dsll	t8, t2, v1			# save bits shifted out
	sltu	t8, zero, t8			# dont lose any ones
	dsrl	t2, t2, v0
/*
 * round (t0 is sign, t2:63-32 is integer part, t2:31-0 is fractional part).
 */
2:
	beq	t3, FPC_ROUND_RN, 3f		# round to nearest
	beq	t3, FPC_ROUND_RZ, 5f		# round to zero (truncate)
	beq	t3, FPC_ROUND_RP, 1f		# round to +infinity
	beq	t0, zero, 5f			# if sign is positive, truncate
	b	2f
1:
	bne	t0, zero, 5f			# if sign is negative, truncate
2:
	daddu	t2, t2, GUARDBIT		# add in fractional
	blt	t2, zero, overflow_w		# overflow?
	b	5f
3:
	daddu	t2, t2, GUARDBIT		# add in fractional
	blt	t2, zero, overflow_w		# overflow?
4:
	bne	v0, zero, 5f			# if rounded remainder is zero
	and	t2, 0xfffffffe00000000		#  clear LSB (round to nearest)
5:
	beq	t0, zero, 1f			# result positive?
	negu	t2				# convert to negative integer
1:
	dsll	v0, 32				# save fraction
	dsrl	t2, 32				# shift out fractional part
	beq	v0, zero, result_fs_w		# is result exact?
/*
 * Handle inexact exception.
 */
inexact_w:
	or	a1, a1, FPC_EXCEPTION_INEXACT | FPC_STICKY_INEXACT
	and	v0, a1, FPC_ENABLE_INEXACT
	bne	v0, zero, fpe_trap
	ctc1	a1, FPC_CSR		# save exceptions
	b	result_fs_w

/*
 * Conversions to integer which overflow will trap (if enabled),
 * or generate an inexact trap (if enabled),
 * or generate an invalid exception.
 */
overflow_w:
	or	a1, a1, FPC_EXCEPTION_OVERFLOW | FPC_STICKY_OVERFLOW
	and	v0, a1, FPC_ENABLE_OVERFLOW
	bne	v0, zero, fpe_trap
	and	v0, a1, FPC_ENABLE_INEXACT
	bne	v0, zero, inexact_w		# inexact traps enabled?
	b	invalid_w

/*
 * Conversions to integer which underflow will trap (if enabled),
 * or generate an inexact trap (if enabled),
 * or generate an invalid exception.
 */
underflow_w:
	or	a1, a1, FPC_EXCEPTION_UNDERFLOW | FPC_STICKY_UNDERFLOW
	and	v0, a1, FPC_ENABLE_UNDERFLOW
	bne	v0, zero, fpe_trap
	and	v0, a1, FPC_ENABLE_INEXACT
	bne	v0, zero, inexact_w		# inexact traps enabled?
	b	invalid_w

/*
 * Convert single to long integer with specific rounding.
 */
round_l_s:
	li	t3, FPC_ROUND_RN
	b	do_cvt_l_s
trunc_l_s:
	li	t3, FPC_ROUND_RZ
	b	do_cvt_l_s
ceil_l_s:
	li	t3, FPC_ROUND_RP
	b	do_cvt_l_s
floor_l_s:
	li	t3, FPC_ROUND_RM
	b	do_cvt_l_s

/*
 * Convert single to long integer.
 */
cvt_l_s:
	and	t3, a1, FPC_ROUNDING_BITS	# get rounding mode
do_cvt_l_s:
	jal	get_fs_s
	bne	t1, SEXP_INF, 1f		# is FS an infinity?
	bne	t2, zero, invalid_l		# invalid conversion
1:
	bne	t1, zero, 1f			# is FS zero?
	beq	t2, zero, result_fs_l		# result is zero
	move	t2, zero			# result is an inexact zero
	b	inexact_l
1:
	subu	t1, t1, SEXP_BIAS		# unbias exponent
	or	t2, t2, SIMPL_ONE		# add implied one bit
	dsll	t2, t2, DFRAC_BITS - SFRAC_BITS	# convert S fraction to D
	b	cvt_l

/*
 * Convert double to long integer with specific rounding.
 */
round_l_d:
	li	t3, FPC_ROUND_RN
	b	do_cvt_l_d
trunc_l_d:
	li	t3, FPC_ROUND_RZ
	b	do_cvt_l_d
ceil_l_d:
	li	t3, FPC_ROUND_RP
	b	do_cvt_l_d
floor_l_d:
	li	t3, FPC_ROUND_RM
	b	do_cvt_l_d

/*
 * Convert double to long integer.
 */
cvt_l_d:
	and	t3, a1, FPC_ROUNDING_BITS	# get rounding mode
do_cvt_l_d:
	jal	get_fs_d
	bne	t1, DEXP_INF, 1f		# is FS an infinity?
	bne	t2, zero, invalid_l		# invalid conversion
1:
	bne	t1, zero, 2f			# is FS zero?
	beq	t2, zero, result_fs_l		# result is zero
	move	t2, zero			# result is an inexact zero
	b	inexact_l
2:
	subu	t1, t1, DEXP_BIAS		# unbias exponent
	or	t2, t2, DIMPL_ONE		# add implied one bit
cvt_l:
	blt	t1, LEXP_MIN, underflow_l	# is exponent too small?
	li	v0, LEXP_MAX+1
	bgt	t1, v0, overflow_l		# is exponent too large?
	bne	t1, v0, 1f			# special check for LONG_MIN
	beq	t0, zero, overflow_l		# if positive, overflow
	bne	t2, DIMPL_ONE, overflow_l
	dli	t2, LONG_MIN			# result is LONG_MIN
	b	result_fs_l
1:
	subu	v0, t1, DFRAC_BITS		# compute amount to shift
	beq	v0, zero, 2f			# is shift needed?
	li	v1, 64
	blt	v0, zero, 1f			# if shift < 0, shift right
	subu	v1, v1, v0			# shift left
	dsll	t2, t2, v0
	b	2f
1:
	negu	v0				# shift right by v0
	subu	v1, v1, v0
	dsll	t8, t2, v1			# save bits shifted out
	sltu	t8, zero, t8			# dont lose any ones
	dsrl	t2, t2, v0
/*
 * round (t0 is sign, t2 is integer part).
 */
2:
	beq	t3, FPC_ROUND_RN, 3f		# round to nearest
	beq	t3, FPC_ROUND_RZ, 5f		# round to zero (truncate)
	beq	t3, FPC_ROUND_RP, 1f		# round to +infinity
	beq	t0, zero, 5f			# if sign is positive, truncate
	b	2f
1:
	bne	t0, zero, 5f			# if sign is negative, truncate
2:
	daddu	t2, t2, DGUARDBIT		# add in fractional
	blt	t2, zero, overflow_l		# overflow?
	b	5f
3:
	daddu	t2, t2, DGUARDBIT		# add in fractional
	blt	t2, zero, overflow_l		# overflow?
4:
	bne	v0, zero, 5f			# if rounded remainder is zero
	and	t2, 0xe000000000000000		#  clear LSB (round to nearest)
5:
	beq	t0, zero, 1f			# result positive?
	negu	t2				# convert to negative integer
1:
	b	result_fs_l
	nop
/*
 * Handle inexact exception.
 */
inexact_l:
	or	a1, a1, FPC_EXCEPTION_INEXACT | FPC_STICKY_INEXACT
	and	v0, a1, FPC_ENABLE_INEXACT
	bne	v0, zero, fpe_trap
	ctc1	a1, FPC_CSR		# save exceptions
	b	result_fs_l

/*
 * Conversions to integer which overflow will trap (if enabled),
 * or generate an inexact trap (if enabled),
 * or generate an invalid exception.
 */
overflow_l:
	or	a1, a1, FPC_EXCEPTION_OVERFLOW | FPC_STICKY_OVERFLOW
	and	v0, a1, FPC_ENABLE_OVERFLOW
	bne	v0, zero, fpe_trap
	and	v0, a1, FPC_ENABLE_INEXACT
	bne	v0, zero, inexact_l		# inexact traps enabled?
	b	invalid_l

/*
 * Conversions to integer which underflow will trap (if enabled),
 * or generate an inexact trap (if enabled),
 * or generate an invalid exception.
 */
underflow_l:
	or	a1, a1, FPC_EXCEPTION_UNDERFLOW | FPC_STICKY_UNDERFLOW
	and	v0, a1, FPC_ENABLE_UNDERFLOW
	bne	v0, zero, fpe_trap
	and	v0, a1, FPC_ENABLE_INEXACT
	bne	v0, zero, inexact_l		# inexact traps enabled?
	b	invalid_l

/*
 * Compare single.
 */
cmp_s:
	jal	get_cmp_s
	bne	t1, SEXP_INF, 1f		# is FS an infinity?
	bne	t2, zero, unordered		# FS is a NAN
1:
	bne	ta1, SEXP_INF, 2f		# is FT an infinity?
	bne	ta2, zero, unordered		# FT is a NAN
2:
	sll	t1, t1, SFRAC_BITS		# reassemble exp & frac
	or	t1, t1, t2
	sll	ta1, ta1, SFRAC_BITS		# reassemble exp & frac
	or	ta1, ta1, ta2
	beq	t0, zero, 1f			# is FS positive?
	negu	t1
1:
	beq	ta0, zero, 1f			# is FT positive?
	negu	ta1
1:
	li	v0, COND_LESS
	blt	t1, ta1, test_cond		# is FS < FT?
	li	v0, COND_EQUAL
	beq	t1, ta1, test_cond		# is FS == FT?
	move	v0, zero			# FS > FT
	b	test_cond

/*
 * Compare double.
 */
cmp_d:
	jal	get_cmp_d
	bne	t1, DEXP_INF, 1f		# is FS an infinity?
	bne	t2, zero, unordered		# FS is a NAN
1:
	bne	ta1, DEXP_INF, 2f		# is FT an infinity?
	bne	ta2, zero, unordered		# FT is a NAN
2:
	dsll	t1, t1, DFRAC_BITS		# reassemble exp & frac
	or	t1, t1, t2
	dsll	ta1, ta1, DFRAC_BITS		# reassemble exp & frac
	or	ta1, ta1, ta2
	beq	t0, zero, 1f			# is FS positive?
	dnegu	t1				# negate t1
1:
	beq	ta0, zero, 1f			# is FT positive?
	dnegu	ta1
1:
	li	v0, COND_LESS
	blt	t1, ta1, test_cond		# is FS(MSW) < FT(MSW)?
	li	v0, COND_EQUAL
	beq	t1, ta1, test_cond		# is FS(LSW) == FT(LSW)?
	move	v0, zero			# FS > FT
test_cond:
	and	v0, v0, a0			# condition match instruction?
set_cond:
	bne	v0, zero, 1f
	and	a1, a1, ~FPC_COND_BIT	# clear condition bit
	b	2f
1:
	or	a1, a1, FPC_COND_BIT	# set condition bit
2:
	ctc1	a1, FPC_CSR		# save condition bit
	b	done

unordered:
	and	v0, a0, COND_UNORDERED		# this cmp match unordered?
	bne	v0, zero, 1f
	and	a1, a1, ~FPC_COND_BIT	# clear condition bit
	b	2f
1:
	or	a1, a1, FPC_COND_BIT	# set condition bit
2:
	and	v0, a0, COND_SIGNAL
	beq	v0, zero, 1f			# is this a signaling cmp?
	or	a1, a1, FPC_EXCEPTION_INVALID | FPC_STICKY_INVALID
	and	v0, a1, FPC_ENABLE_INVALID
	bne	v0, zero, fpe_trap
1:
	ctc1	a1, FPC_CSR		# save condition bit
	b	done

/*
 * Determine the amount to shift the fraction in order to restore the
 * normalized position. After that, round and handle exceptions.
 */
norm_s:
	move	v0, t2
	move	t9, zero			# t9 = num of leading zeros
	bne	t2, zero, 1f
	move	v0, t8
	addu	t9, 32
1:
	srl	v1, v0, 16
	bne	v1, zero, 1f
	addu	t9, 16
	sll	v0, 16
1:
	srl	v1, v0, 24
	bne	v1, zero, 1f
	addu	t9, 8
	sll	v0, 8
1:
	srl	v1, v0, 28
	bne	v1, zero, 1f
	addu	t9, 4
	sll	v0, 4
1:
	srl	v1, v0, 30
	bne	v1, zero, 1f
	addu	t9, 2
	sll	v0, 2
1:
	srl	v1, v0, 31
	bne	v1, zero, 1f
	addu	t9, 1
/*
 * Now shift t2,t8 the correct number of bits.
 */
1:
	subu	t9, t9, SLEAD_ZEROS		# dont count leading zeros
	subu	t1, t1, t9			# adjust the exponent
	beq	t9, zero, norm_noshift_s
	li	v1, 32
	blt	t9, zero, 1f			# if shift < 0, shift right
	subu	v1, v1, t9
	sll	t2, t2, t9			# shift t2,t8 left
	srl	v0, t8, v1			# save bits shifted out
	or	t2, t2, v0
	sll	t8, t8, t9
	b	norm_noshift_s
1:
	negu	t9				# shift t2,t8 right by t9
	subu	v1, v1, t9
	sll	v0, t8, v1			# save bits shifted out
	sltu	v0, zero, v0			# be sure to save any one bits
	srl	t8, t8, t9
	or	t8, t8, v0
	sll	v0, t2, v1			# save bits shifted out
	or	t8, t8, v0
	srl	t2, t2, t9
norm_noshift_s:
	move	ta1, t1				# save unrounded exponent
	move	ta2, t2				# save unrounded fraction
	and	v0, a1, FPC_ROUNDING_BITS	# get rounding mode
	beq	v0, FPC_ROUND_RN, 3f	# round to nearest
	beq	v0, FPC_ROUND_RZ, 5f	# round to zero (truncate)
	beq	v0, FPC_ROUND_RP, 1f	# round to +infinity
	beq	t0, zero, 5f			# if sign is positive, truncate
	b	2f
1:
	bne	t0, zero, 5f			# if sign is negative, truncate
2:
	beq	t8, zero, 5f			# if exact, continue
	addu	t2, t2, 1			# add rounding bit
	bne	t2, SIMPL_ONE<<1, 5f		# need to adjust exponent?
	addu	t1, t1, 1			# adjust exponent
	srl	t2, t2, 1			# renormalize fraction
	b	5f
3:
	li	v0, GUARDBIT			# load guard bit for rounding
	addu	v0, v0, t8			# add remainder
	sltu	v1, v0, t8			# compute carry out
	beq	v1, zero, 4f			# if no carry, continue
	addu	t2, t2, 1			# add carry to result
	bne	t2, SIMPL_ONE<<1, 4f		# need to adjust exponent?
	addu	t1, t1, 1			# adjust exponent
	srl	t2, t2, 1			# renormalize fraction
4:
	bne	v0, zero, 5f			# if rounded remainder is zero
	and	t2, t2, ~1			#  clear LSB (round to nearest)
5:
	bgt	t1, SEXP_MAX, overflow_s	# overflow?
	blt	t1, SEXP_MIN, underflow_s	# underflow?
	bne	t8, zero, inexact_s		# is result inexact?
	addu	t1, t1, SEXP_BIAS		# bias exponent
	and	t2, t2, ~SIMPL_ONE		# clear implied one bit
	b	result_fs_s

/*
 * Handle inexact exception.
 */
inexact_s:
	addu	t1, t1, SEXP_BIAS		# bias exponent
	and	t2, t2, ~SIMPL_ONE		# clear implied one bit
inexact_nobias_s:
	jal	set_fd_s			# save result
	or	a1, a1, FPC_EXCEPTION_INEXACT | FPC_STICKY_INEXACT
	and	v0, a1, FPC_ENABLE_INEXACT
	bne	v0, zero, fpe_trap
	ctc1	a1, FPC_CSR		# save exceptions
	b	done

/*
 * Overflow will trap (if enabled),
 * or generate an inexact trap (if enabled),
 * or generate an infinity.
 */
overflow_s:
	or	a1, a1, FPC_EXCEPTION_OVERFLOW | FPC_STICKY_OVERFLOW
	and	v0, a1, FPC_ENABLE_OVERFLOW
	beq	v0, zero, 1f
	subu	t1, t1, 192			# bias exponent
	and	t2, t2, ~SIMPL_ONE		# clear implied one bit
	jal	set_fd_s			# save result
	b	fpe_trap
1:
	and	v0, a1, FPC_ROUNDING_BITS	# get rounding mode
	beq	v0, FPC_ROUND_RN, 3f	# round to nearest
	beq	v0, FPC_ROUND_RZ, 1f	# round to zero (truncate)
	beq	v0, FPC_ROUND_RP, 2f	# round to +infinity
	bne	t0, zero, 3f
1:
	li	t1, SEXP_MAX			# result is max finite
	li	t2, 0x007fffff
	b	inexact_s
2:
	bne	t0, zero, 1b
3:
	li	t1, SEXP_MAX + 1		# result is infinity
	move	t2, zero
	b	inexact_s

/*
 * In this implementation, "tininess" is detected "after rounding" and
 * "loss of accuracy" is detected as "an inexact result".
 */
underflow_s:
	and	v0, a1, FPC_ENABLE_UNDERFLOW
	beq	v0, zero, 1f
/*
 * Underflow is enabled so compute the result and trap.
 */
	addu	t1, t1, 192			# bias exponent
	and	t2, t2, ~SIMPL_ONE		# clear implied one bit
	jal	set_fd_s			# save result
	or	a1, a1, FPC_EXCEPTION_UNDERFLOW | FPC_STICKY_UNDERFLOW
	b	fpe_trap
/*
 * Underflow is not enabled so compute the result,
 * signal inexact result (if it is) and trap (if enabled).
 */
1:
	move	t1, ta1				# get unrounded exponent
	move	t2, ta2				# get unrounded fraction
	li	t9, SEXP_MIN			# compute shift amount
	subu	t9, t9, t1			# shift t2,t8 right by t9
	blt	t9, SFRAC_BITS+2, 3f		# shift all the bits out?
	move	t1, zero			# result is inexact zero
	move	t2, zero
	or	a1, a1, FPC_EXCEPTION_UNDERFLOW | FPC_STICKY_UNDERFLOW
/*
 * Now round the zero result.
 * Only need to worry about rounding to +- infinity when the sign matches.
 */
	and	v0, a1, FPC_ROUNDING_BITS	# get rounding mode
	beq	v0, FPC_ROUND_RN, inexact_nobias_s	# round to nearest
	beq	v0, FPC_ROUND_RZ, inexact_nobias_s	# round to zero
	beq	v0, FPC_ROUND_RP, 1f	# round to +infinity
	beq	t0, zero, inexact_nobias_s	# if sign is positive, truncate
	b	2f
1:
	bne	t0, zero, inexact_nobias_s	# if sign is negative, truncate
2:
	addu	t2, t2, 1			# add rounding bit
	b	inexact_nobias_s
3:
	li	v1, 32
	subu	v1, v1, t9
	sltu	v0, zero, t8			# be sure to save any one bits
	sll	t8, t2, v1			# save bits shifted out
	or	t8, t8, v0			# include sticky bits
	srl	t2, t2, t9
/*
 * Now round the denormalized result.
 */
	and	v0, a1, FPC_ROUNDING_BITS	# get rounding mode
	beq	v0, FPC_ROUND_RN, 3f	# round to nearest
	beq	v0, FPC_ROUND_RZ, 5f	# round to zero (truncate)
	beq	v0, FPC_ROUND_RP, 1f	# round to +infinity
	beq	t0, zero, 5f			# if sign is positive, truncate
	b	2f
1:
	bne	t0, zero, 5f			# if sign is negative, truncate
2:
	beq	t8, zero, 5f			# if exact, continue
	addu	t2, t2, 1			# add rounding bit
	b	5f
3:
	li	v0, GUARDBIT			# load guard bit for rounding
	addu	v0, v0, t8			# add remainder
	sltu	v1, v0, t8			# compute carry out
	beq	v1, zero, 4f			# if no carry, continue
	addu	t2, t2, 1			# add carry to result
4:
	bne	v0, zero, 5f			# if rounded remainder is zero
	and	t2, t2, ~1			#  clear LSB (round to nearest)
5:
	move	t1, zero			# denorm or zero exponent
	jal	set_fd_s			# save result
	beq	t8, zero, done			# check for exact result
	or	a1, a1, FPC_EXCEPTION_UNDERFLOW | FPC_STICKY_UNDERFLOW
	or	a1, a1, FPC_EXCEPTION_INEXACT | FPC_STICKY_INEXACT
	and	v0, a1, FPC_ENABLE_INEXACT
	bne	v0, zero, fpe_trap
	ctc1	a1, FPC_CSR		# save exceptions
	b	done

/*
 * Determine the amount to shift the fraction in order to restore the
 * normalized position. After that, round and handle exceptions.
 */
norm_d:
	move	v0, t2
	move	t9, zero			# t9 = num of leading zeros
	dsrl	v1, v0, 32
	bne	v1, zero, 1f
	addu	t9, 32
	dsll	v0, 32
1:
	dsrl	v1, v0, 16
	bne	v1, zero, 1f
	addu	t9, 16
	dsll	v0, 16
1:
	dsrl	v1, v0, 24
	bne	v1, zero, 1f
	addu	t9, 8
	dsll	v0, 8
1:
	dsrl	v1, v0, 28
	bne	v1, zero, 1f
	addu	t9, 4
	dsll	v0, 4
1:
	dsrl	v1, v0, 30
	bne	v1, zero, 1f
	addu	t9, 2
	dsll	v0, 2
1:
	dsrl	v1, v0, 31
	bne	v1, zero, 1f
	addu	t9, 1
/*
 * Now shift t2,t8 the correct number of bits.
 */
1:
	subu	t9, t9, DLEAD_ZEROS		# dont count leading zeros
	subu	t1, t1, t9			# adjust the exponent
	beq	t9, zero, norm_noshift_d
	li	v1, 64
	blt	t9, zero, 2f			# if shift < 0, shift right
	subu	v1, v1, t9
	dsll	t2, t2, t9			# shift left by t9
	dsrl	v0, t8, v1			# save bits shifted out
	or	t2, t2, v0
	dsll	t8, t8, t9
	b	norm_noshift_d
2:
	negu	t9				# shift right by t9
	subu	v1, v1, t9			#  (known to be < 32 bits)
	dsll	v0, t8, v1			# save bits shifted out
	sltu	v0, zero, v0			# be sure to save any one bits
	dsrl	t8, t8, t9
	or	t8, t8, v0
	dsll	v0, t2, v1			# save bits shifted out
	or	t8, t8, v0
	dsrl	t2, t2, t9
norm_noshift_d:
	move	ta1, t1				# save unrounded exponent
	move	ta2, t2				# save unrounded fraction (MS)
	and	v0, a1, FPC_ROUNDING_BITS	# get rounding mode
	beq	v0, FPC_ROUND_RN, 3f	# round to nearest
	beq	v0, FPC_ROUND_RZ, 5f	# round to zero (truncate)
	beq	v0, FPC_ROUND_RP, 1f	# round to +infinity
	beq	t0, zero, 5f			# if sign is positive, truncate
	b	2f
1:
	bne	t0, zero, 5f			# if sign is negative, truncate
2:
	beq	t8, zero, 5f			# if exact, continue
	daddu	t2, t2, 1			# add rounding bit
	bne	t2, DIMPL_ONE<<1, 5f		# need to adjust exponent?
	addu	t1, t1, 1			# adjust exponent
	dsrl	t2, t2, 1			# renormalize fraction
	b	5f
3:
	dli	v0, DGUARDBIT			# load guard bit for rounding
	addu	v0, v0, t8			# add remainder
	sltu	v1, v0, t8			# compute carry out
	beq	v1, zero, 4f			# branch if no carry
	daddu	t2, t2, 1			# add carry to result
	bne	t2, DIMPL_ONE<<1, 4f		# need to adjust exponent?
	addu	t1, t1, 1			# adjust exponent
	srl	t2, t2, 1			# renormalize fraction
4:
	bne	v0, zero, 5f			# if rounded remainder is zero
	and	t2, t2, ~1			#  clear LSB (round to nearest)
5:
	bgt	t1, DEXP_MAX, overflow_d	# overflow?
	blt	t1, DEXP_MIN, underflow_d	# underflow?
	bne	t8, zero, inexact_d		# is result inexact?
	addu	t1, t1, DEXP_BIAS		# bias exponent
	and	t2, t2, ~DIMPL_ONE		# clear implied one bit
	b	result_fs_d

/*
 * Handle inexact exception.
 */
inexact_d:
	addu	t1, t1, DEXP_BIAS		# bias exponent
	and	t2, t2, ~DIMPL_ONE		# clear implied one bit
inexact_nobias_d:
	jal	set_fd_d			# save result
	or	a1, a1, FPC_EXCEPTION_INEXACT | FPC_STICKY_INEXACT
	and	v0, a1, FPC_ENABLE_INEXACT
	bne	v0, zero, fpe_trap
	ctc1	a1, FPC_CSR		# save exceptions
	b	done

/*
 * Overflow will trap (if enabled),
 * or generate an inexact trap (if enabled),
 * or generate an infinity.
 */
overflow_d:
	or	a1, a1, FPC_EXCEPTION_OVERFLOW | FPC_STICKY_OVERFLOW
	and	v0, a1, FPC_ENABLE_OVERFLOW
	beq	v0, zero, 1f
	subu	t1, t1, 1536			# bias exponent
	and	t2, t2, ~DIMPL_ONE		# clear implied one bit
	jal	set_fd_d			# save result
	b	fpe_trap
1:
	and	v0, a1, FPC_ROUNDING_BITS	# get rounding mode
	beq	v0, FPC_ROUND_RN, 3f	# round to nearest
	beq	v0, FPC_ROUND_RZ, 1f	# round to zero (truncate)
	beq	v0, FPC_ROUND_RP, 2f	# round to +infinity
	bne	t0, zero, 3f
1:
	li	t1, DEXP_MAX			# result is max finite
	dli	t2, 0x000fffffffffffff
	b	inexact_d
2:
	bne	t0, zero, 1b
3:
	li	t1, DEXP_MAX + 1		# result is infinity
	move	t2, zero
	b	inexact_d

/*
 * In this implementation, "tininess" is detected "after rounding" and
 * "loss of accuracy" is detected as "an inexact result".
 */
underflow_d:
	and	v0, a1, FPC_ENABLE_UNDERFLOW
	beq	v0, zero, 1f
/*
 * Underflow is enabled so compute the result and trap.
 */
	addu	t1, t1, 1536			# bias exponent
	and	t2, t2, ~DIMPL_ONE		# clear implied one bit
	jal	set_fd_d			# save result
	or	a1, a1, FPC_EXCEPTION_UNDERFLOW | FPC_STICKY_UNDERFLOW
	b	fpe_trap
/*
 * Underflow is not enabled so compute the result,
 * signal inexact result (if it is) and trap (if enabled).
 */
1:
	move	t1, ta1				# get unrounded exponent
	move	t2, ta2				# get unrounded fraction (MS)
	li	t9, DEXP_MIN			# compute shift amount
	subu	t9, t9, t1			# shift t2,t8 right by t9
	blt	t9, DFRAC_BITS+2, 3f		# shift all the bits out?
	move	t1, zero			# result is inexact zero
	move	t2, zero
	or	a1, a1, FPC_EXCEPTION_UNDERFLOW | FPC_STICKY_UNDERFLOW
/*
 * Now round the zero result.
 * Only need to worry about rounding to +- infinity when the sign matches.
 */
	and	v0, a1, FPC_ROUNDING_BITS	# get rounding mode
	beq	v0, FPC_ROUND_RN, inexact_nobias_d	# round to nearest
	beq	v0, FPC_ROUND_RZ, inexact_nobias_d	# round to zero
	beq	v0, FPC_ROUND_RP, 1f	# round to +infinity
	beq	t0, zero, inexact_nobias_d	# if sign is positive, truncate
	b	2f
1:
	bne	t0, zero, inexact_nobias_d	# if sign is negative, truncate
2:
	daddu	t2, t2, 1			# add rounding bit
	b	inexact_nobias_d
3:
	li	v1, 64
	subu	v1, v1, t9
	sltu	v0, zero, t8			# be sure to save any one bits
	dsll	t8, t2, v1			# save bits shifted out
	or	t8, t8, v0			# include sticky bits
	dsrl	t2, t2, t9
/*
 * Now round the denormalized result.
 */
	and	v0, a1, FPC_ROUNDING_BITS	# get rounding mode
	beq	v0, FPC_ROUND_RN, 3f	# round to nearest
	beq	v0, FPC_ROUND_RZ, 5f	# round to zero (truncate)
	beq	v0, FPC_ROUND_RP, 1f	# round to +infinity
	beq	t0, zero, 5f			# if sign is positive, truncate
	b	2f
1:
	bne	t0, zero, 5f			# if sign is negative, truncate
2:
	beq	t8, zero, 5f			# if exact, continue
	daddu	t2, t2, 1			# add rounding bit
	b	5f
3:
	dli	v0, DGUARDBIT			# load guard bit for rounding
	daddu	v0, v0, t8			# add remainder
	sltu	v1, v0, t8			# compute carry out
	beq	v1, zero, 4f			# if no carry, continue
	daddu	t2, t2, 1			# add carry
4:
	bne	v0, zero, 5f			# if rounded remainder is zero
	and	t2, t2, ~1			#  clear LSB (round to nearest)
5:
	move	t1, zero			# denorm or zero exponent
	jal	set_fd_d			# save result
	beq	t8, zero, done			# check for exact result
	or	a1, a1, FPC_EXCEPTION_UNDERFLOW | FPC_STICKY_UNDERFLOW
	or	a1, a1, FPC_EXCEPTION_INEXACT | FPC_STICKY_INEXACT
	and	v0, a1, FPC_ENABLE_INEXACT
	bne	v0, zero, fpe_trap
	ctc1	a1, FPC_CSR		# save exceptions
	b	done

/*
 * Signal an invalid operation if the trap is enabled; otherwise,
 * the result is a quiet NAN.
 */
invalid_s:					# trap invalid operation
	or	a1, a1, FPC_EXCEPTION_INVALID | FPC_STICKY_INVALID
	and	v0, a1, FPC_ENABLE_INVALID
	bne	v0, zero, fpe_trap
	ctc1	a1, FPC_CSR		# save exceptions
	move	t0, zero			# result is a quiet NAN
	li	t1, SEXP_INF
	li	t2, SQUIET_NAN
	jal	set_fd_s			# save result (in t0,t1,t2)
	b	done

/*
 * Signal an invalid operation if the trap is enabled; otherwise,
 * the result is a quiet NAN.
 */
invalid_d:					# trap invalid operation
	or	a1, a1, FPC_EXCEPTION_INVALID | FPC_STICKY_INVALID
	and	v0, a1, FPC_ENABLE_INVALID
	bne	v0, zero, fpe_trap
	ctc1	a1, FPC_CSR		# save exceptions
	move	t0, zero			# result is a quiet NAN
	li	t1, DEXP_INF
	dli	t2, DQUIET_NAN
	jal	set_fd_d			# save result (in t0,t1,t2)
	b	done

/*
 * Signal an invalid operation if the trap is enabled; otherwise,
 * the result is INT_MAX or INT_MIN.
 */
invalid_w:					# trap invalid operation
	or	a1, a1, FPC_EXCEPTION_INVALID | FPC_STICKY_INVALID
	and	v0, a1, FPC_ENABLE_INVALID
	bne	v0, zero, fpe_trap
	ctc1	a1, FPC_CSR			# save exceptions
	bne	t0, zero, 1f
	li	t2, INT_MAX			# result is INT_MAX
	b	result_fs_w
1:
	li	t2, INT_MIN			# result is INT_MIN
	b	result_fs_w

/*
 * Signal an invalid operation if the trap is enabled; otherwise,
 * the result is LONG_MAX or LONG_MIN.
 */
invalid_l:					# trap invalid operation
	or	a1, a1, FPC_EXCEPTION_INVALID | FPC_STICKY_INVALID
	and	v0, a1, FPC_ENABLE_INVALID
	bne	v0, zero, fpe_trap
	ctc1	a1, FPC_CSR			# save exceptions
	bne	t0, zero, 1f
	dli	t2, LONG_MAX			# result is INT_MAX
	b	result_fs_l
1:
	dli	t2, LONG_MIN			# result is INT_MIN
	b	result_fs_l

/*
 * Trap if the hardware should have handled this case.
 */
fpe_trap:
	move	a2, a1				# code = FP CSR
	ctc1	a1, FPC_CSR			# save exceptions
	li	v0, 1
	b	done_err

/*
 * Send an illegal instruction signal to the current process.
 */
ill:
	ctc1	a1, FPC_CSR			# save exceptions
	move	a2, a0				# code = FP instruction
	li	v0, 1
	b	done_err

result_ft_s:
	move	t0, ta0				# result is FT
	move	t1, ta1
	move	t2, ta2
result_fs_s:					# result is FS
	jal	set_fd_s			# save result (in t0,t1,t2)
	b	done

result_fs_w:
	jal	set_fd_word			# save result (in t2)
	b	done

result_fs_l:
	move	t0, t2
	jal	set_fd_dword			# save result (in t0)
	b	done

result_ft_d:
	move	t0, ta0				# result is FT
	move	t1, ta1
	move	t2, ta2
result_fs_d:					# result is FS
	jal	set_fd_d			# save result (in t0,t1,t2)

done:
	li	v0, 0
done_err:
	PTR_L	ra, CF_RA_OFFS(sp)
	PTR_ADD	sp, sp, FRAMESZ(CF_SZ)
	j	ra
END(MipsEmulateFP)

/*----------------------------------------------------------------------------
 * get_fs_int --
 *
 *	Read (integer) the FS register (bits 15-11).
 *	This is an internal routine used by MipsEmulateFP only.
 *
 * Results:
 *	t0	contains the sign
 *	t2	contains the fraction
 *
 *----------------------------------------------------------------------------
 */
#define GET_FS_INT(n) \
	.rdata;				\
	.dword	get_fs_int_ ## n;	\
	.text;				\
get_fs_int_ ## n:			\
	mfc1	t2, $ ## n;		\
	b	get_fs_int_done

LEAF(get_fs_int, 0)
	srl	a3, a0, 11 - 3			# get FS field
	and	a3, a3, 0x1f << 3		# mask FS field
	ld	a3, get_fs_int_tbl(a3)		# switch on register number
	j	a3

	.rdata
get_fs_int_tbl:
	.text

	GET_FS_INT(f0)
	GET_FS_INT(f1)
	GET_FS_INT(f2)
	GET_FS_INT(f3)
	GET_FS_INT(f4)
	GET_FS_INT(f5)
	GET_FS_INT(f6)
	GET_FS_INT(f7)
	GET_FS_INT(f8)
	GET_FS_INT(f9)
	GET_FS_INT(f10)
	GET_FS_INT(f11)
	GET_FS_INT(f12)
	GET_FS_INT(f13)
	GET_FS_INT(f14)
	GET_FS_INT(f15)
	GET_FS_INT(f16)
	GET_FS_INT(f17)
	GET_FS_INT(f18)
	GET_FS_INT(f19)
	GET_FS_INT(f20)
	GET_FS_INT(f21)
	GET_FS_INT(f22)
	GET_FS_INT(f23)
	GET_FS_INT(f24)
	GET_FS_INT(f25)
	GET_FS_INT(f26)
	GET_FS_INT(f27)
	GET_FS_INT(f28)
	GET_FS_INT(f29)
	GET_FS_INT(f30)
	GET_FS_INT(f31)

get_fs_int_done:
	srl	t0, t2, 31		# init the sign bit
	bge	t2, zero, 1f
	negu	t2
	dsll	t2, 33
	dsrl	t2, 33
1:
	j	ra
END(get_fs_int)

/*----------------------------------------------------------------------------
 * get_fs_long --
 *
 *	Read (long integer) the FS register (bits 15-11).
 *	This is an internal routine used by MipsEmulateFP only.
 *
 * Results:
 *	t0	contains the sign
 *	t2	contains the fraction
 *
 *----------------------------------------------------------------------------
 */
#define GET_FS_LONG(n) \
	.rdata;				\
	.dword	get_fs_long_ ## n;	\
	.text;				\
get_fs_long_ ## n:			\
	dmfc1	t2, $ ## n;		\
	b	get_fs_long_done

LEAF(get_fs_long, 0)
	srl	a3, a0, 11 - 3			# get FS field
	and	a3, a3, 0x1f << 3		# mask FS field
	ld	a3, get_fs_long_tbl(a3)		# switch on register number
	j	a3

	.rdata
get_fs_long_tbl:
	.text

	GET_FS_LONG(f0)
	GET_FS_LONG(f1)
	GET_FS_LONG(f2)
	GET_FS_LONG(f3)
	GET_FS_LONG(f4)
	GET_FS_LONG(f5)
	GET_FS_LONG(f6)
	GET_FS_LONG(f7)
	GET_FS_LONG(f8)
	GET_FS_LONG(f9)
	GET_FS_LONG(f10)
	GET_FS_LONG(f11)
	GET_FS_LONG(f12)
	GET_FS_LONG(f13)
	GET_FS_LONG(f14)
	GET_FS_LONG(f15)
	GET_FS_LONG(f16)
	GET_FS_LONG(f17)
	GET_FS_LONG(f18)
	GET_FS_LONG(f19)
	GET_FS_LONG(f20)
	GET_FS_LONG(f21)
	GET_FS_LONG(f22)
	GET_FS_LONG(f23)
	GET_FS_LONG(f24)
	GET_FS_LONG(f25)
	GET_FS_LONG(f26)
	GET_FS_LONG(f27)
	GET_FS_LONG(f28)
	GET_FS_LONG(f29)
	GET_FS_LONG(f30)
	GET_FS_LONG(f31)

get_fs_long_done:
	dsrl	t0, t2, 63		# init the sign bit
	bge	t2, zero, 1f
	dnegu	t2
1:
	j	ra
END(get_fs_long)

/*----------------------------------------------------------------------------
 * get_ft_fs_s --
 *
 *	Read (single precision) the FT register (bits 20-16) and
 *	the FS register (bits 15-11) and break up into fields.
 *	This is an internal routine used by MipsEmulateFP only.
 *
 * Results:
 *	t0	contains the FS sign
 *	t1	contains the FS (biased) exponent
 *	t2	contains the FS fraction
 *	ta0	contains the FT sign
 *	ta1	contains the FT (biased) exponent
 *	ta2	contains the FT fraction
 *
 *----------------------------------------------------------------------------
 */
#define GET_FT_S(n) \
	.rdata;				\
	.dword	get_ft_s_ ## n;		\
	.text;				\
get_ft_s_ ## n:				\
	mfc1	ta0, $ ## n;		\
	b	get_ft_s_done

LEAF(get_ft_fs_s, 0)
	srl	a3, a0, 16 - 3			# get FT field
	and	a3, a3, 0x1f << 3		# mask FT field
	ld	a3, get_ft_s_tbl(a3)		# switch on register number
	j	a3

	.rdata
get_ft_s_tbl:
	.text

	GET_FT_S(f0)
	GET_FT_S(f1)
	GET_FT_S(f2)
	GET_FT_S(f3)
	GET_FT_S(f4)
	GET_FT_S(f5)
	GET_FT_S(f6)
	GET_FT_S(f7)
	GET_FT_S(f8)
	GET_FT_S(f9)
	GET_FT_S(f10)
	GET_FT_S(f11)
	GET_FT_S(f12)
	GET_FT_S(f13)
	GET_FT_S(f14)
	GET_FT_S(f15)
	GET_FT_S(f16)
	GET_FT_S(f17)
	GET_FT_S(f18)
	GET_FT_S(f19)
	GET_FT_S(f20)
	GET_FT_S(f21)
	GET_FT_S(f22)
	GET_FT_S(f23)
	GET_FT_S(f24)
	GET_FT_S(f25)
	GET_FT_S(f26)
	GET_FT_S(f27)
	GET_FT_S(f28)
	GET_FT_S(f29)
	GET_FT_S(f30)
	GET_FT_S(f31)

get_ft_s_done:
	srl	ta1, ta0, SFRAC_BITS		# get exponent
	and	ta1, ta1, 0xFF
	and	ta2, ta0, 0x7FFFFF		# get fraction
	srl	ta0, ta0, 31			# get sign
	bne	ta1, SEXP_INF, 1f		# is it a signaling NAN?
	and	v0, ta2, SSIGNAL_NAN
	bne	v0, zero, invalid_s
1:
	/* fall through to get FS */

/*----------------------------------------------------------------------------
 * get_fs_s --
 *
 *	Read (single precision) the FS register (bits 15-11) and
 *	break up into fields.
 *	This is an internal routine used by MipsEmulateFP only.
 *
 * Results:
 *	t0	contains the sign
 *	t1	contains the (biased) exponent
 *	t2	contains the fraction
 *
 *----------------------------------------------------------------------------
 */
#define GET_FS_S(n) \
	.rdata;				\
	.dword	get_fs_s_ ## n;		\
	.text;				\
get_fs_s_ ## n:				\
	mfc1	t0, $ ## n;		\
	b	get_fs_s_done

ALEAF(get_fs_s)
	srl	a3, a0, 11 - 3			# get FS field
	and	a3, a3, 0x1f << 3		# mask FS field
	ld	a3, get_fs_s_tbl(a3)		# switch on register number
	j	a3

	.rdata
get_fs_s_tbl:
	.text

	GET_FS_S(f0)
	GET_FS_S(f1)
	GET_FS_S(f2)
	GET_FS_S(f3)
	GET_FS_S(f4)
	GET_FS_S(f5)
	GET_FS_S(f6)
	GET_FS_S(f7)
	GET_FS_S(f8)
	GET_FS_S(f9)
	GET_FS_S(f10)
	GET_FS_S(f11)
	GET_FS_S(f12)
	GET_FS_S(f13)
	GET_FS_S(f14)
	GET_FS_S(f15)
	GET_FS_S(f16)
	GET_FS_S(f17)
	GET_FS_S(f18)
	GET_FS_S(f19)
	GET_FS_S(f20)
	GET_FS_S(f21)
	GET_FS_S(f22)
	GET_FS_S(f23)
	GET_FS_S(f24)
	GET_FS_S(f25)
	GET_FS_S(f26)
	GET_FS_S(f27)
	GET_FS_S(f28)
	GET_FS_S(f29)
	GET_FS_S(f30)
	GET_FS_S(f31)

get_fs_s_done:
	srl	t1, t0, SFRAC_BITS		# get exponent
	and	t1, t1, 0xFF
	and	t2, t0, 0x7FFFFF		# get fraction
	srl	t0, t0, 31			# get sign
	bne	t1, SEXP_INF, 1f		# is it a signaling NAN?
	and	v0, t2, SSIGNAL_NAN
	bne	v0, zero, invalid_s
1:
	j	ra
END(get_ft_fs_s)

/*----------------------------------------------------------------------------
 * get_ft_fs_d --
 *
 *	Read (double precision) the FT register (bits 20-16) and
 *	the FS register (bits 15-11) and break up into fields.
 *	This is an internal routine used by MipsEmulateFP only.
 *
 * Results:
 *	t0	contains the FS sign
 *	t1	contains the FS (biased) exponent
 *	t2	contains the FS fraction
 *	ta0	contains the FT sign
 *	ta1	contains the FT (biased) exponent
 *	ta2	contains the FT fraction
 *
 *----------------------------------------------------------------------------
 */
#define GET_FT_FS_D(n) \
	.rdata;				\
	.dword	get_ft_fs_d_ ## n;	\
	.text;				\
get_ft_fs_d_ ## n:			\
	dmfc1	ta2, $ ## n;		\
	b	get_ft_d_done

LEAF(get_ft_fs_d, 0)
	srl	a3, a0, 16 - 3			# get FT field
	and	a3, a3, 0x1f << 3		# mask FT field
	ld	a3, get_ft_d_tbl(a3)		# switch on register number
	j	a3

	.rdata
get_ft_d_tbl:
	.text

	GET_FT_FS_D(f0)
	GET_FT_FS_D(f1)
	GET_FT_FS_D(f2)
	GET_FT_FS_D(f3)
	GET_FT_FS_D(f4)
	GET_FT_FS_D(f5)
	GET_FT_FS_D(f6)
	GET_FT_FS_D(f7)
	GET_FT_FS_D(f8)
	GET_FT_FS_D(f9)
	GET_FT_FS_D(f10)
	GET_FT_FS_D(f11)
	GET_FT_FS_D(f12)
	GET_FT_FS_D(f13)
	GET_FT_FS_D(f14)
	GET_FT_FS_D(f15)
	GET_FT_FS_D(f16)
	GET_FT_FS_D(f17)
	GET_FT_FS_D(f18)
	GET_FT_FS_D(f19)
	GET_FT_FS_D(f20)
	GET_FT_FS_D(f21)
	GET_FT_FS_D(f22)
	GET_FT_FS_D(f23)
	GET_FT_FS_D(f24)
	GET_FT_FS_D(f25)
	GET_FT_FS_D(f26)
	GET_FT_FS_D(f27)
	GET_FT_FS_D(f28)
	GET_FT_FS_D(f29)
	GET_FT_FS_D(f30)
	GET_FT_FS_D(f31)

get_ft_d_done:
	dsrl	ta0, ta2, 63			# get sign
	dsrl	ta1, ta2, DFRAC_BITS		# get exponent
	and	ta1, ta1, 0x7FF
	dsll	ta2, 12
	dsrl	ta2, 12				# get fraction
	bne	ta1, DEXP_INF, 1f		# is it a signaling NAN?
	and	v0, ta2, DSIGNAL_NAN
	bne	v0, zero, invalid_d
1:
	/* fall through to get FS */

/*----------------------------------------------------------------------------
 * get_fs_d --
 *
 *	Read (double precision) the FS register (bits 15-11) and
 *	break up into fields.
 *	This is an internal routine used by MipsEmulateFP only.
 *
 * Results:
 *	t0	contains the sign
 *	t1	contains the (biased) exponent
 *	t2	contains the fraction
 *
 *----------------------------------------------------------------------------
 */
#define GET_FS_D(n) \
	.rdata;				\
	.dword	get_fs_d_ ## n;		\
	.text;				\
get_fs_d_ ## n:				\
	dmfc1	t2, $ ## n;		\
	b	get_fs_d_done

ALEAF(get_fs_d)
	srl	a3, a0, 11 - 3			# get FS field
	and	a3, a3, 0x1f << 3		# mask FS field
	ld	a3, get_fs_d_tbl(a3)		# switch on register number
	j	a3

	.rdata
get_fs_d_tbl:
	.text

	GET_FS_D(f0)
	GET_FS_D(f1)
	GET_FS_D(f2)
	GET_FS_D(f3)
	GET_FS_D(f4)
	GET_FS_D(f5)
	GET_FS_D(f6)
	GET_FS_D(f7)
	GET_FS_D(f8)
	GET_FS_D(f9)
	GET_FS_D(f10)
	GET_FS_D(f11)
	GET_FS_D(f12)
	GET_FS_D(f13)
	GET_FS_D(f14)
	GET_FS_D(f15)
	GET_FS_D(f16)
	GET_FS_D(f17)
	GET_FS_D(f18)
	GET_FS_D(f19)
	GET_FS_D(f20)
	GET_FS_D(f21)
	GET_FS_D(f22)
	GET_FS_D(f23)
	GET_FS_D(f24)
	GET_FS_D(f25)
	GET_FS_D(f26)
	GET_FS_D(f27)
	GET_FS_D(f28)
	GET_FS_D(f29)
	GET_FS_D(f30)
	GET_FS_D(f31)

get_fs_d_done:
	dsrl	t0, t2, 63			# get sign
	dsrl	t1, t2, DFRAC_BITS		# get exponent
	and	t1, t1, 0x7FF
	dsll	t2, 12
	dsrl	t2, 12				# get fraction
	bne	t1, DEXP_INF, 1f		# is it a signaling NAN?
	and	v0, t2, DSIGNAL_NAN
	bne	v0, zero, invalid_d
1:
	j	ra
END(get_ft_fs_d)

/*----------------------------------------------------------------------------
 * get_cmp_s --
 *
 *	Read (single precision) the FS register (bits 15-11) and
 *	the FT register (bits 20-16) and break up into fields.
 *	This is an internal routine used by MipsEmulateFP only.
 *
 * Results:
 *	t0	contains the sign
 *	t1	contains the (biased) exponent
 *	t2	contains the fraction
 *	ta0	contains the sign
 *	ta1	contains the (biased) exponent
 *	ta2	contains the fraction
 *
 *----------------------------------------------------------------------------
 */
#define CMP_FS_S(n) \
	.rdata;				\
	.dword	cmp_fs_s_ ## n;		\
	.text;				\
cmp_fs_s_ ## n:				\
	mfc1	t0, $ ## n;		\
	b	cmp_fs_s_done

LEAF(get_cmp_s, 0)
	srl	a3, a0, 11 - 3			# get FS field
	and	a3, a3, 0x1f << 3		# mask FS field
	ld	a3, cmp_fs_s_tbl(a3)		# switch on register number
	j	a3

	.rdata
cmp_fs_s_tbl:
	.text

	CMP_FS_S(f0)
	CMP_FS_S(f1)
	CMP_FS_S(f2)
	CMP_FS_S(f3)
	CMP_FS_S(f4)
	CMP_FS_S(f5)
	CMP_FS_S(f6)
	CMP_FS_S(f7)
	CMP_FS_S(f8)
	CMP_FS_S(f9)
	CMP_FS_S(f10)
	CMP_FS_S(f11)
	CMP_FS_S(f12)
	CMP_FS_S(f13)
	CMP_FS_S(f14)
	CMP_FS_S(f15)
	CMP_FS_S(f16)
	CMP_FS_S(f17)
	CMP_FS_S(f18)
	CMP_FS_S(f19)
	CMP_FS_S(f20)
	CMP_FS_S(f21)
	CMP_FS_S(f22)
	CMP_FS_S(f23)
	CMP_FS_S(f24)
	CMP_FS_S(f25)
	CMP_FS_S(f26)
	CMP_FS_S(f27)
	CMP_FS_S(f28)
	CMP_FS_S(f29)
	CMP_FS_S(f30)
	CMP_FS_S(f31)

cmp_fs_s_done:
	srl	t1, t0, SFRAC_BITS		# get exponent
	and	t1, t1, 0xFF
	and	t2, t0, 0x7FFFFF		# get fraction
	srl	t0, t0, 31			# get sign

#define CMP_FT_S(n) \
	.rdata;				\
	.dword	cmp_ft_s_ ## n;		\
	.text;				\
cmp_ft_s_ ## n:				\
	mfc1	ta0, $ ## n;		\
	b	cmp_ft_s_done

	srl	a3, a0, 16 - 3			# get FT field
	and	a3, a3, 0x1f << 3		# mask FT field
	ld	a3, cmp_ft_s_tbl(a3)		# switch on register number
	j	a3

	.rdata
cmp_ft_s_tbl:
	.text

	CMP_FT_S(f0)
	CMP_FT_S(f1)
	CMP_FT_S(f2)
	CMP_FT_S(f3)
	CMP_FT_S(f4)
	CMP_FT_S(f5)
	CMP_FT_S(f6)
	CMP_FT_S(f7)
	CMP_FT_S(f8)
	CMP_FT_S(f9)
	CMP_FT_S(f10)
	CMP_FT_S(f11)
	CMP_FT_S(f12)
	CMP_FT_S(f13)
	CMP_FT_S(f14)
	CMP_FT_S(f15)
	CMP_FT_S(f16)
	CMP_FT_S(f17)
	CMP_FT_S(f18)
	CMP_FT_S(f19)
	CMP_FT_S(f20)
	CMP_FT_S(f21)
	CMP_FT_S(f22)
	CMP_FT_S(f23)
	CMP_FT_S(f24)
	CMP_FT_S(f25)
	CMP_FT_S(f26)
	CMP_FT_S(f27)
	CMP_FT_S(f28)
	CMP_FT_S(f29)
	CMP_FT_S(f30)

cmp_ft_s_done:
	srl	ta1, ta0, SFRAC_BITS		# get exponent
	and	ta1, ta1, 0xFF
	and	ta2, ta0, 0x7FFFFF		# get fraction
	srl	ta0, ta0, 31			# get sign
	j	ra
END(get_cmp_s)

/*----------------------------------------------------------------------------
 * get_cmp_d --
 *
 *	Read (double precision) the FS register (bits 15-11) and
 *	the FT register (bits 20-16) and break up into fields.
 *	This is an internal routine used by MipsEmulateFP only.
 *
 * Results:
 *	t0	contains the sign
 *	t1	contains the (biased) exponent
 *	t2	contains the fraction
 *	ta0	contains the sign
 *	ta1	contains the (biased) exponent
 *	ta2	contains the fraction
 *
 *----------------------------------------------------------------------------
 */
#define CMP_FS_D(n) \
	.rdata;				\
	.dword	cmp_fs_d_ ## n;		\
	.text;				\
cmp_fs_d_ ## n:				\
	dmfc1	t2, $ ## n;		\
	b	cmp_fs_d_done

LEAF(get_cmp_d, 0)
	srl	a3, a0, 11 - 3			# get FS field
	and	a3, a3, 0x1f << 3		# mask FS field
	ld	a3, cmp_fs_d_tbl(a3)		# switch on register number
	j	a3

	.rdata
cmp_fs_d_tbl:
	.text

	CMP_FS_D(f0)
	CMP_FS_D(f1)
	CMP_FS_D(f2)
	CMP_FS_D(f3)
	CMP_FS_D(f4)
	CMP_FS_D(f5)
	CMP_FS_D(f6)
	CMP_FS_D(f7)
	CMP_FS_D(f8)
	CMP_FS_D(f9)
	CMP_FS_D(f10)
	CMP_FS_D(f11)
	CMP_FS_D(f12)
	CMP_FS_D(f13)
	CMP_FS_D(f14)
	CMP_FS_D(f15)
	CMP_FS_D(f16)
	CMP_FS_D(f17)
	CMP_FS_D(f18)
	CMP_FS_D(f19)
	CMP_FS_D(f20)
	CMP_FS_D(f21)
	CMP_FS_D(f22)
	CMP_FS_D(f23)
	CMP_FS_D(f24)
	CMP_FS_D(f25)
	CMP_FS_D(f26)
	CMP_FS_D(f27)
	CMP_FS_D(f28)
	CMP_FS_D(f29)
	CMP_FS_D(f30)
	CMP_FS_D(f31)

cmp_fs_d_done:
	dsrl	t0, t2, 63			# get sign
	dsrl	t1, t2, DFRAC_BITS		# get exponent
	and	t1, t1, 0x7FF
	dsll	t2, 12
	dsrl	t2, 12				# get fraction

#define CMP_FT_D(n) \
	.rdata;				\
	.dword	cmp_ft_d_ ## n;		\
	.text;				\
cmp_ft_d_ ## n:				\
	dmfc1	ta2, $ ## n;		\
	b	cmp_ft_d_done

	srl	a3, a0, 16 - 3			# get FT field
	and	a3, a3, 0x1f << 3		# mask FT field
	ld	a3, cmp_ft_d_tbl(a3)		# switch on register number
	j	a3

	.rdata
cmp_ft_d_tbl:
	.text

	CMP_FT_D(f0)
	CMP_FT_D(f1)
	CMP_FT_D(f2)
	CMP_FT_D(f3)
	CMP_FT_D(f4)
	CMP_FT_D(f5)
	CMP_FT_D(f6)
	CMP_FT_D(f7)
	CMP_FT_D(f8)
	CMP_FT_D(f9)
	CMP_FT_D(f10)
	CMP_FT_D(f11)
	CMP_FT_D(f12)
	CMP_FT_D(f13)
	CMP_FT_D(f14)
	CMP_FT_D(f15)
	CMP_FT_D(f16)
	CMP_FT_D(f17)
	CMP_FT_D(f18)
	CMP_FT_D(f19)
	CMP_FT_D(f20)
	CMP_FT_D(f21)
	CMP_FT_D(f22)
	CMP_FT_D(f23)
	CMP_FT_D(f24)
	CMP_FT_D(f25)
	CMP_FT_D(f26)
	CMP_FT_D(f27)
	CMP_FT_D(f28)
	CMP_FT_D(f29)
	CMP_FT_D(f30)
	CMP_FT_D(f31)

cmp_ft_d_done:
	dsrl	ta0, ta2, 63			# get sign
	dsrl	ta1, ta2, DFRAC_BITS		# get exponent
	and	ta1, ta1, 0x7FF
	dsll	ta2, 12
	dsrl	ta2, 12				# get fraction
	j	ra
END(get_cmp_d)

/*----------------------------------------------------------------------------
 * set_fd_s --
 *
 *	Write (single precision) the FD register (bits 10-6).
 *	This is an internal routine used by MipsEmulateFP only.
 *
 * Arguments:
 *	a0	contains the FP instruction
 *	t0	contains the sign
 *	t1	contains the (biased) exponent
 *	t2	contains the fraction
 *
 * set_fd_word --
 *
 *	Write (integer) the FD register (bits 10-6).
 *	This is an internal routine used by MipsEmulateFP only.
 *
 * Arguments:
 *	a0	contains the FP instruction
 *	t2	contains the integer
 *
 *----------------------------------------------------------------------------
 */
#define SET_FD_S(n) \
	.rdata;				\
	.dword	set_fd_s_ ## n;		\
	.text;				\
set_fd_s_ ## n:				\
	mtc1	t2, $ ## n;		\
	j	ra

LEAF(set_fd_s, 0)
	sll	t0, t0, 31			# position sign
	sll	t1, t1, SFRAC_BITS		# position exponent
	or	t2, t2, t0
	or	t2, t2, t1
ALEAF(set_fd_word)
	srl	a3, a0, 6 - 3			# get FD field
	and	a3, a3, 0x1f << 3		# mask FT field
	ld	a3, set_fd_s_tbl(a3)		# switch on register number
	j	a3

	.rdata
set_fd_s_tbl:
	.text

	SET_FD_S(f0)
	SET_FD_S(f1)
	SET_FD_S(f2)
	SET_FD_S(f3)
	SET_FD_S(f4)
	SET_FD_S(f5)
	SET_FD_S(f6)
	SET_FD_S(f7)
	SET_FD_S(f8)
	SET_FD_S(f9)
	SET_FD_S(f10)
	SET_FD_S(f11)
	SET_FD_S(f12)
	SET_FD_S(f13)
	SET_FD_S(f14)
	SET_FD_S(f15)
	SET_FD_S(f16)
	SET_FD_S(f17)
	SET_FD_S(f18)
	SET_FD_S(f19)
	SET_FD_S(f20)
	SET_FD_S(f21)
	SET_FD_S(f22)
	SET_FD_S(f23)
	SET_FD_S(f24)
	SET_FD_S(f25)
	SET_FD_S(f26)
	SET_FD_S(f27)
	SET_FD_S(f28)
	SET_FD_S(f29)
	SET_FD_S(f30)
	SET_FD_S(f31)

END(set_fd_s)

/*----------------------------------------------------------------------------
 * set_fd_d --
 *
 *	Write (double precision) the FT register (bits 10-6).
 *	This is an internal routine used by MipsEmulateFP only.
 *
 * Arguments:
 *	a0	contains the FP instruction
 *	t0	contains the sign
 *	t1	contains the (biased) exponent
 *	t2	contains the fraction
 *
 *----------------------------------------------------------------------------
 */
#define SET_FD_D(n) \
	.rdata;				\
	.dword	set_fd_d_ ## n;		\
	.text;				\
set_fd_d_ ## n:				\
	dmtc1	t0, $ ## n;		\
	j	ra

LEAF(set_fd_d, 0)
	dsll	t0, 63				# set sign
	dsll	t1, t1, DFRAC_BITS		# set exponent
	or	t0, t0, t1
	or	t0, t0, t2			# set fraction
ALEAF(set_fd_dword)
	srl	a3, a0, 6 - 3			# get FD field
	and	a3, a3, 0x1f << 3		# mask FD field
	ld	a3, set_fd_d_tbl(a3)		# switch on register number
	j	a3

	.rdata
set_fd_d_tbl:
	.text

	SET_FD_D(f0)
	SET_FD_D(f1)
	SET_FD_D(f2)
	SET_FD_D(f3)
	SET_FD_D(f4)
	SET_FD_D(f5)
	SET_FD_D(f6)
	SET_FD_D(f7)
	SET_FD_D(f8)
	SET_FD_D(f9)
	SET_FD_D(f10)
	SET_FD_D(f11)
	SET_FD_D(f12)
	SET_FD_D(f13)
	SET_FD_D(f14)
	SET_FD_D(f15)
	SET_FD_D(f16)
	SET_FD_D(f17)
	SET_FD_D(f18)
	SET_FD_D(f19)
	SET_FD_D(f20)
	SET_FD_D(f21)
	SET_FD_D(f22)
	SET_FD_D(f23)
	SET_FD_D(f24)
	SET_FD_D(f25)
	SET_FD_D(f26)
	SET_FD_D(f27)
	SET_FD_D(f28)
	SET_FD_D(f29)
	SET_FD_D(f30)
	SET_FD_D(f31)

END(set_fd_d)

/*----------------------------------------------------------------------------
 * renorm_fs_s --
 *
 * Results:
 *	t1	unbiased exponent
 *	t2	normalized fraction
 *
 *----------------------------------------------------------------------------
 */
LEAF(renorm_fs_s, 0)
/*
 * Find out how many leading zero bits are in t2 and put in t9.
 */
	move	v0, t2
	move	t9, zero
	srl	v1, v0, 16
	bne	v1, zero, 1f
	addu	t9, 16
	sll	v0, 16
1:
	srl	v1, v0, 24
	bne	v1, zero, 1f
	addu	t9, 8
	sll	v0, 8
1:
	srl	v1, v0, 28
	bne	v1, zero, 1f
	addu	t9, 4
	sll	v0, 4
1:
	srl	v1, v0, 30
	bne	v1, zero, 1f
	addu	t9, 2
	sll	v0, 2
1:
	srl	v1, v0, 31
	bne	v1, zero, 1f
	addu	t9, 1
/*
 * Now shift t2 the correct number of bits.
 */
1:
	subu	t9, t9, SLEAD_ZEROS	# dont count normal leading zeros
	li	t1, SEXP_MIN
	subu	t1, t1, t9		# adjust exponent
	sll	t2, t2, t9
	j	ra
END(renorm_fs_s)

/*----------------------------------------------------------------------------
 * renorm_fs_d --
 *
 * Results:
 *	t1	unbiased exponent
 *	t2	normalized fraction
 *
 *----------------------------------------------------------------------------
 */
LEAF(renorm_fs_d, 0)
/*
 * Find out how many leading zero bits are in t2 and put in t9.
 */
	move	v0, t2
	move	t9, zero
	dsrl	v1, v0, 32
	bne	v1, zero, 1f
	addu	t9, 32
	dsll	v0, 32
1:
	dsrl	v1, v0, 16
	bne	v1, zero, 1f
	addu	t9, 16
	dsll	v0, 16
1:
	dsrl	v1, v0, 24
	bne	v1, zero, 1f
	addu	t9, 8
	dsll	v0, 8
1:
	dsrl	v1, v0, 28
	bne	v1, zero, 1f
	addu	t9, 4
	dsll	v0, 4
1:
	dsrl	v1, v0, 30
	bne	v1, zero, 1f
	addu	t9, 2
	dsll	v0, 2
1:
	dsrl	v1, v0, 31
	bne	v1, zero, 1f
	addu	t9, 1
/*
 * Now shift t2 the correct number of bits.
 */
1:
	subu	t9, t9, DLEAD_ZEROS	# dont count normal leading zeros
	li	t1, DEXP_MIN
	subu	t1, t9			# adjust exponent
	dsll	t2, t9
	j	ra
END(renorm_fs_d)

/*----------------------------------------------------------------------------
 * renorm_ft_s --
 *
 * Results:
 *	ta1	unbiased exponent
 *	ta2	normalized fraction
 *
 *----------------------------------------------------------------------------
 */
LEAF(renorm_ft_s, 0)
/*
 * Find out how many leading zero bits are in ta2 and put in t9.
 */
	move	v0, ta2
	move	t9, zero
	srl	v1, v0, 16
	bne	v1, zero, 1f
	addu	t9, 16
	sll	v0, 16
1:
	srl	v1, v0, 24
	bne	v1, zero, 1f
	addu	t9, 8
	sll	v0, 8
1:
	srl	v1, v0, 28
	bne	v1, zero, 1f
	addu	t9, 4
	sll	v0, 4
1:
	srl	v1, v0, 30
	bne	v1, zero, 1f
	addu	t9, 2
	sll	v0, 2
1:
	srl	v1, v0, 31
	bne	v1, zero, 1f
	addu	t9, 1
/*
 * Now shift ta2 the correct number of bits.
 */
1:
	subu	t9, t9, SLEAD_ZEROS	# dont count normal leading zeros
	li	ta1, SEXP_MIN
	subu	ta1, t9			# adjust exponent
	sll	ta2, t9
	j	ra
END(renorm_ft_s)

/*----------------------------------------------------------------------------
 * renorm_ft_d --
 *
 * Results:
 *	ta1	unbiased exponent
 *	ta2	normalized fraction
 *
 *----------------------------------------------------------------------------
 */
LEAF(renorm_ft_d, 0)
/*
 * Find out how many leading zero bits are in ta2 and put in t9.
 */
	move	v0, ta2
	move	t9, zero
	dsrl	v1, v0, 32
	bne	v1, zero, 1f
	addu	t9, 32
	dsll	v0, 32
1:
	dsrl	v1, v0, 16
	bne	v1, zero, 1f
	addu	t9, 16
	dsll	v0, 16
1:
	dsrl	v1, v0, 24
	bne	v1, zero, 1f
	addu	t9, 8
	dsll	v0, 8
1:
	dsrl	v1, v0, 28
	bne	v1, zero, 1f
	addu	t9, 4
	dsll	v0, 4
1:
	dsrl	v1, v0, 30
	bne	v1, zero, 1f
	addu	t9, 2
	dsll	v0, 2
1:
	dsrl	v1, v0, 31
	bne	v1, zero, 1f
	addu	t9, 1
/*
 * Now shift ta2 the correct number of bits.
 */
1:
	subu	t9, t9, DLEAD_ZEROS	# dont count normal leading zeros
	li	ta1, DEXP_MIN
	subu	ta1, t9			# adjust exponent
	dsll	ta2, t9
	j	ra
END(renorm_ft_d)
@


1.9
log
@Minimal completion support for .l.s and .l.d routines, necessary for at
least the R5k and R10k family FPU which trap if the operands are too large
(i.e. positive unbiased exponent > fracbits).

This is quick and dirty band aid until that code is replaced with interface
code to the MI kernel softfloat code.
@
text
@d1 1
a1 1
/*	$OpenBSD: fp.S,v 1.8 2009/08/09 13:41:30 jsing Exp $	*/
d38 1
a38 1
 *      $Id: fp.S,v 1.8 2009/08/09 13:41:30 jsing Exp $
@


1.8
log
@Use the ANSI/ISO token paste operator. Requested by jsg@@

ok miod@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fp.S,v 1.7 2004/11/02 18:54:45 pefo Exp $	*/
d38 1
a38 1
 *      $Id: fp.S,v 1.7 2004/11/02 18:54:45 pefo Exp $
d62 2
d80 2
d139 1
a139 1
	.dword	ill		# 4
d143 4
a146 4
	.dword	ill		# 8
	.dword	ill		# 9
	.dword	ill		# 10
	.dword	ill		# 11
d172 1
a172 1
	.dword	ill		# 37
d205 1
a205 1
	.dword	ill		# 4
d209 4
a212 4
	.dword	ill		# 8
	.dword	ill		# 9
	.dword	ill		# 10
	.dword	ill		# 11
d238 1
a238 1
	.dword	ill		# 37
d1121 1
a1121 1
	dsll	t2, t2, 32 - 3			# convert S fraction to D
d1125 1
a1125 1
 * Convert single to integer with specific rounding.
d1245 155
d1410 1
a1410 1
	sll	t1, t1, 23			# reassemble exp & frac
d1412 1
a1412 1
	sll	ta1, ta1, 23			# reassemble exp & frac
d1438 1
a1438 1
	dsll	t1, t1, 52			# reassemble exp & frac
d1440 1
a1440 1
	dsll	ta1, ta1, 52			# reassemble exp & frac
d1982 16
d2027 5
d2260 1
a2260 1
	srl	ta1, ta0, 23			# get exponent
d2336 1
a2336 1
	srl	t1, t0, 23			# get exponent
d2417 1
a2417 1
	dsrl	ta1, ta2, 52			# get exponent
d2494 1
a2494 1
	dsrl	t1, t2, 52			# get exponent
d2574 1
a2574 1
	srl	t1, t0, 23			# get exponent
d2629 1
a2629 1
	srl	ta1, ta0, 23			# get exponent
d2706 1
a2706 1
	dsrl	t1, t2, 52			# get exponent
d2763 1
a2763 1
	dsrl	ta1, ta2, 52			# get exponent
d2803 1
a2803 1
	sll	t1, t1, 23			# position exponent
d2875 1
a2875 1
	dsll	t1, t1, 52			# set exponent
d2878 1
@


1.7
log
@missed reg index calc fix
@
text
@d1 1
a1 1
/*	$OpenBSD: fp.S,v 1.6 2004/10/30 14:48:59 pefo Exp $	*/
d38 1
a38 1
 *      $Id: fp.S,v 1.6 2004/10/30 14:48:59 pefo Exp $
d1881 1
a1881 1
	.dword	get_fs_int_/**/n;	\
d1883 2
a1884 2
get_fs_int_/**/n:			\
	mfc1	t2, $/**/n;		\
d1954 1
a1954 1
	.dword	get_fs_long_/**/n;	\
d1956 2
a1957 2
get_fs_long_/**/n:			\
	dmfc1	t2, $/**/n;		\
d2030 1
a2030 1
	.dword	get_ft_s_/**/n;		\
d2032 2
a2033 2
get_ft_s_/**/n:				\
	mfc1	ta0, $/**/n;		\
d2106 1
a2106 1
	.dword	get_fs_s_/**/n;		\
d2108 2
a2109 2
get_fs_s_/**/n:				\
	mfc1	t0, $/**/n;		\
d2186 1
a2186 1
	.dword	get_ft_fs_d_/**/n;	\
d2188 2
a2189 2
get_ft_fs_d_/**/n:			\
	dmfc1	ta2, $/**/n;		\
d2263 1
a2263 1
	.dword	get_fs_d_/**/n;		\
d2265 2
a2266 2
get_fs_d_/**/n:				\
	dmfc1	t2, $/**/n;		\
d2344 1
a2344 1
	.dword	cmp_fs_s_/**/n;		\
d2346 2
a2347 2
cmp_fs_s_/**/n:				\
	mfc1	t0, $/**/n;		\
d2401 1
a2401 1
	.dword	cmp_ft_s_/**/n;		\
d2403 2
a2404 2
cmp_ft_s_/**/n:				\
	mfc1	ta0, $/**/n;		\
d2475 1
a2475 1
	.dword	cmp_fs_d_/**/n;		\
d2477 2
a2478 2
cmp_fs_d_/**/n:				\
	dmfc1	t2, $/**/n;		\
d2533 1
a2533 1
	.dword	cmp_ft_d_/**/n;		\
d2535 2
a2536 2
cmp_ft_d_/**/n:				\
	dmfc1	ta2, $/**/n;		\
d2615 1
a2615 1
	.dword	set_fd_s_/**/n;		\
d2617 2
a2618 2
set_fd_s_/**/n:				\
	mtc1	t2, $/**/n;		\
d2687 1
a2687 1
	.dword	set_fd_d_/**/n;		\
d2689 2
a2690 2
set_fd_d_/**/n:				\
	dmtc1	t0, $/**/n;		\
@


1.6
log
@Make the default boot partition p.
Migrate float exception code to 64 bit. Add a few new "uniplemented".
@
text
@d1 1
a1 1
/*	$OpenBSD: fp.S,v 1.5 2004/09/10 09:32:13 pefo Exp $	*/
d38 1
a38 1
 *      $Id: fp.S,v 1.5 2004/09/10 09:32:13 pefo Exp $
d2270 2
a2271 2
	srl	a3, a0, 12 - 2			# get FS field (even regs only)
	and	a3, a3, 0xF << 2		# mask FS field
@


1.5
log
@Use correct register aliases wrt the __mips_n64 regdef.
@
text
@d1 1
a1 1
/*	$OpenBSD: fp.S,v 1.4 2004/09/10 08:58:27 pefo Exp $	*/
d38 1
a38 1
 *      $Id: fp.S,v 1.4 2004/09/10 08:58:27 pefo Exp $
d65 3
a67 3
#define DIMPL_ONE	0x00100000
#define SLEAD_ZEROS	31 - 23
#define DLEAD_ZEROS	31 - 20
d69 3
a71 1
#define GUARDBIT	0x80000000
d75 1
a75 2
#define DQUIET_NAN0	0x0007ffff
#define DQUIET_NAN1	0xffffffff
d89 2
a90 1
 *	This routine should only be called by MipsFPInterrupt().
d106 19
a124 12
/*
 * Decode the FMT field (bits 24-21) and FUNCTION field (bits 5-0).
 */
	srl	v0, a0, 21 - 2			# get FMT field
	and	v0, v0, 0xF << 2		# mask FMT field
	and	v1, a0, 0x3F			# mask FUNC field
	sll	v1, v1, 5			# align for table lookup
	bgt	v0, 4 << 2, ill			# illegal format

	or	v1, v1, v0
	cfc1	a1, FPC_CSR		# get exception register
	lw	a3, func_fmt_tbl(v1)		# switch on FUNC & FMT
d130 264
a393 513
func_fmt_tbl:
	.word	add_s		# 0
	.word	add_d		# 0
	.word	ill		# 0
	.word	ill		# 0
	.word	ill		# 0
	.word	ill		# 0
	.word	ill		# 0
	.word	ill		# 0
	.word	sub_s		# 1
	.word	sub_d		# 1
	.word	ill		# 1
	.word	ill		# 1
	.word	ill		# 1
	.word	ill		# 1
	.word	ill		# 1
	.word	ill		# 1
	.word	mul_s		# 2
	.word	mul_d		# 2
	.word	ill		# 2
	.word	ill		# 2
	.word	ill		# 2
	.word	ill		# 2
	.word	ill		# 2
	.word	ill		# 2
	.word	div_s		# 3
	.word	div_d		# 3
	.word	ill		# 3
	.word	ill		# 3
	.word	ill		# 3
	.word	ill		# 3
	.word	ill		# 3
	.word	ill		# 3
	.word	ill		# 4
	.word	ill		# 4
	.word	ill		# 4
	.word	ill		# 4
	.word	ill		# 4
	.word	ill		# 4
	.word	ill		# 4
	.word	ill		# 4
	.word	abs_s		# 5
	.word	abs_d		# 5
	.word	ill		# 5
	.word	ill		# 5
	.word	ill		# 5
	.word	ill		# 5
	.word	ill		# 5
	.word	ill		# 5
	.word	mov_s		# 6
	.word	mov_d		# 6
	.word	ill		# 6
	.word	ill		# 6
	.word	ill		# 6
	.word	ill		# 6
	.word	ill		# 6
	.word	ill		# 6
	.word	neg_s		# 7
	.word	neg_d		# 7
	.word	ill		# 7
	.word	ill		# 7
	.word	ill		# 7
	.word	ill		# 7
	.word	ill		# 7
	.word	ill		# 7
	.word	ill		# 8
	.word	ill		# 8
	.word	ill		# 8
	.word	ill		# 8
	.word	ill		# 8
	.word	ill		# 8
	.word	ill		# 8
	.word	ill		# 8
	.word	ill		# 9
	.word	ill		# 9
	.word	ill		# 9
	.word	ill		# 9
	.word	ill		# 9
	.word	ill		# 9
	.word	ill		# 9
	.word	ill		# 9
	.word	ill		# 10
	.word	ill		# 10
	.word	ill		# 10
	.word	ill		# 10
	.word	ill		# 10
	.word	ill		# 10
	.word	ill		# 10
	.word	ill		# 10
	.word	ill		# 11
	.word	ill		# 11
	.word	ill		# 11
	.word	ill		# 11
	.word	ill		# 11
	.word	ill		# 11
	.word	ill		# 11
	.word	ill		# 11
	.word	ill		# 12
	.word	ill		# 12
	.word	ill		# 12
	.word	ill		# 12
	.word	ill		# 12
	.word	ill		# 12
	.word	ill		# 12
	.word	ill		# 12
	.word	ill		# 13
	.word	ill		# 13
	.word	ill		# 13
	.word	ill		# 13
	.word	ill		# 13
	.word	ill		# 13
	.word	ill		# 13
	.word	ill		# 13
	.word	ill		# 14
	.word	ill		# 14
	.word	ill		# 14
	.word	ill		# 14
	.word	ill		# 14
	.word	ill		# 14
	.word	ill		# 14
	.word	ill		# 14
	.word	ill		# 15
	.word	ill		# 15
	.word	ill		# 15
	.word	ill		# 15
	.word	ill		# 15
	.word	ill		# 15
	.word	ill		# 15
	.word	ill		# 15
	.word	ill		# 16
	.word	ill		# 16
	.word	ill		# 16
	.word	ill		# 16
	.word	ill		# 16
	.word	ill		# 16
	.word	ill		# 16
	.word	ill		# 16
	.word	ill		# 17
	.word	ill		# 17
	.word	ill		# 17
	.word	ill		# 17
	.word	ill		# 17
	.word	ill		# 17
	.word	ill		# 17
	.word	ill		# 17
	.word	ill		# 18
	.word	ill		# 18
	.word	ill		# 18
	.word	ill		# 18
	.word	ill		# 18
	.word	ill		# 18
	.word	ill		# 18
	.word	ill		# 18
	.word	ill		# 19
	.word	ill		# 19
	.word	ill		# 19
	.word	ill		# 19
	.word	ill		# 19
	.word	ill		# 19
	.word	ill		# 19
	.word	ill		# 19
	.word	ill		# 20
	.word	ill		# 20
	.word	ill		# 20
	.word	ill		# 20
	.word	ill		# 20
	.word	ill		# 20
	.word	ill		# 20
	.word	ill		# 20
	.word	ill		# 21
	.word	ill		# 21
	.word	ill		# 21
	.word	ill		# 21
	.word	ill		# 21
	.word	ill		# 21
	.word	ill		# 21
	.word	ill		# 21
	.word	ill		# 22
	.word	ill		# 22
	.word	ill		# 22
	.word	ill		# 22
	.word	ill		# 22
	.word	ill		# 22
	.word	ill		# 22
	.word	ill		# 22
	.word	ill		# 23
	.word	ill		# 23
	.word	ill		# 23
	.word	ill		# 23
	.word	ill		# 23
	.word	ill		# 23
	.word	ill		# 23
	.word	ill		# 23
	.word	ill		# 24
	.word	ill		# 24
	.word	ill		# 24
	.word	ill		# 24
	.word	ill		# 24
	.word	ill		# 24
	.word	ill		# 24
	.word	ill		# 24
	.word	ill		# 25
	.word	ill		# 25
	.word	ill		# 25
	.word	ill		# 25
	.word	ill		# 25
	.word	ill		# 25
	.word	ill		# 25
	.word	ill		# 25
	.word	ill		# 26
	.word	ill		# 26
	.word	ill		# 26
	.word	ill		# 26
	.word	ill		# 26
	.word	ill		# 26
	.word	ill		# 26
	.word	ill		# 26
	.word	ill		# 27
	.word	ill		# 27
	.word	ill		# 27
	.word	ill		# 27
	.word	ill		# 27
	.word	ill		# 27
	.word	ill		# 27
	.word	ill		# 27
	.word	ill		# 28
	.word	ill		# 28
	.word	ill		# 28
	.word	ill		# 28
	.word	ill		# 28
	.word	ill		# 28
	.word	ill		# 28
	.word	ill		# 28
	.word	ill		# 29
	.word	ill		# 29
	.word	ill		# 29
	.word	ill		# 29
	.word	ill		# 29
	.word	ill		# 29
	.word	ill		# 29
	.word	ill		# 29
	.word	ill		# 30
	.word	ill		# 30
	.word	ill		# 30
	.word	ill		# 30
	.word	ill		# 30
	.word	ill		# 30
	.word	ill		# 30
	.word	ill		# 30
	.word	ill		# 31
	.word	ill		# 31
	.word	ill		# 31
	.word	ill		# 31
	.word	ill		# 31
	.word	ill		# 31
	.word	ill		# 31
	.word	ill		# 31
	.word	ill		# 32
	.word	cvt_s_d		# 32
	.word	ill		# 32
	.word	ill		# 32
	.word	cvt_s_w		# 32
	.word	ill		# 32
	.word	ill		# 32
	.word	ill		# 32
	.word	cvt_d_s		# 33
	.word	ill		# 33
	.word	ill		# 33
	.word	ill		# 33
	.word	cvt_d_w		# 33
	.word	ill		# 33
	.word	ill		# 33
	.word	ill		# 33
	.word	ill		# 34
	.word	ill		# 34
	.word	ill		# 34
	.word	ill		# 34
	.word	ill		# 34
	.word	ill		# 34
	.word	ill		# 34
	.word	ill		# 34
	.word	ill		# 35
	.word	ill		# 35
	.word	ill		# 35
	.word	ill		# 35
	.word	ill		# 35
	.word	ill		# 35
	.word	ill		# 35
	.word	ill		# 35
	.word	cvt_w_s		# 36
	.word	cvt_w_d		# 36
	.word	ill		# 36
	.word	ill		# 36
	.word	ill		# 36
	.word	ill		# 36
	.word	ill		# 36
	.word	ill		# 36
	.word	ill		# 37
	.word	ill		# 37
	.word	ill		# 37
	.word	ill		# 37
	.word	ill		# 37
	.word	ill		# 37
	.word	ill		# 37
	.word	ill		# 37
	.word	ill		# 38
	.word	ill		# 38
	.word	ill		# 38
	.word	ill		# 38
	.word	ill		# 38
	.word	ill		# 38
	.word	ill		# 38
	.word	ill		# 38
	.word	ill		# 39
	.word	ill		# 39
	.word	ill		# 39
	.word	ill		# 39
	.word	ill		# 39
	.word	ill		# 39
	.word	ill		# 39
	.word	ill		# 39
	.word	ill		# 40
	.word	ill		# 40
	.word	ill		# 40
	.word	ill		# 40
	.word	ill		# 40
	.word	ill		# 40
	.word	ill		# 40
	.word	ill		# 40
	.word	ill		# 41
	.word	ill		# 41
	.word	ill		# 41
	.word	ill		# 41
	.word	ill		# 41
	.word	ill		# 41
	.word	ill		# 41
	.word	ill		# 41
	.word	ill		# 42
	.word	ill		# 42
	.word	ill		# 42
	.word	ill		# 42
	.word	ill		# 42
	.word	ill		# 42
	.word	ill		# 42
	.word	ill		# 42
	.word	ill		# 43
	.word	ill		# 43
	.word	ill		# 43
	.word	ill		# 43
	.word	ill		# 43
	.word	ill		# 43
	.word	ill		# 43
	.word	ill		# 43
	.word	ill		# 44
	.word	ill		# 44
	.word	ill		# 44
	.word	ill		# 44
	.word	ill		# 44
	.word	ill		# 44
	.word	ill		# 44
	.word	ill		# 44
	.word	ill		# 45
	.word	ill		# 45
	.word	ill		# 45
	.word	ill		# 45
	.word	ill		# 45
	.word	ill		# 45
	.word	ill		# 45
	.word	ill		# 45
	.word	ill		# 46
	.word	ill		# 46
	.word	ill		# 46
	.word	ill		# 46
	.word	ill		# 46
	.word	ill		# 46
	.word	ill		# 46
	.word	ill		# 46
	.word	ill		# 47
	.word	ill		# 47
	.word	ill		# 47
	.word	ill		# 47
	.word	ill		# 47
	.word	ill		# 47
	.word	ill		# 47
	.word	ill		# 47
	.word	cmp_s		# 48
	.word	cmp_d		# 48
	.word	ill		# 48
	.word	ill		# 48
	.word	ill		# 48
	.word	ill		# 48
	.word	ill		# 48
	.word	ill		# 48
	.word	cmp_s		# 49
	.word	cmp_d		# 49
	.word	ill		# 49
	.word	ill		# 49
	.word	ill		# 49
	.word	ill		# 49
	.word	ill		# 49
	.word	ill		# 49
	.word	cmp_s		# 50
	.word	cmp_d		# 50
	.word	ill		# 50
	.word	ill		# 50
	.word	ill		# 50
	.word	ill		# 50
	.word	ill		# 50
	.word	ill		# 50
	.word	cmp_s		# 51
	.word	cmp_d		# 51
	.word	ill		# 51
	.word	ill		# 51
	.word	ill		# 51
	.word	ill		# 51
	.word	ill		# 51
	.word	ill		# 51
	.word	cmp_s		# 52
	.word	cmp_d		# 52
	.word	ill		# 52
	.word	ill		# 52
	.word	ill		# 52
	.word	ill		# 52
	.word	ill		# 52
	.word	ill		# 52
	.word	cmp_s		# 53
	.word	cmp_d		# 53
	.word	ill		# 53
	.word	ill		# 53
	.word	ill		# 53
	.word	ill		# 53
	.word	ill		# 53
	.word	ill		# 53
	.word	cmp_s		# 54
	.word	cmp_d		# 54
	.word	ill		# 54
	.word	ill		# 54
	.word	ill		# 54
	.word	ill		# 54
	.word	ill		# 54
	.word	ill		# 54
	.word	cmp_s		# 55
	.word	cmp_d		# 55
	.word	ill		# 55
	.word	ill		# 55
	.word	ill		# 55
	.word	ill		# 55
	.word	ill		# 55
	.word	ill		# 55
	.word	cmp_s		# 56
	.word	cmp_d		# 56
	.word	ill		# 56
	.word	ill		# 56
	.word	ill		# 56
	.word	ill		# 56
	.word	ill		# 56
	.word	ill		# 56
	.word	cmp_s		# 57
	.word	cmp_d		# 57
	.word	ill		# 57
	.word	ill		# 57
	.word	ill		# 57
	.word	ill		# 57
	.word	ill		# 57
	.word	ill		# 57
	.word	cmp_s		# 58
	.word	cmp_d		# 58
	.word	ill		# 58
	.word	ill		# 58
	.word	ill		# 58
	.word	ill		# 58
	.word	ill		# 58
	.word	ill		# 58
	.word	cmp_s		# 59
	.word	cmp_d		# 59
	.word	ill		# 59
	.word	ill		# 59
	.word	ill		# 59
	.word	ill		# 59
	.word	ill		# 59
	.word	ill		# 59
	.word	cmp_s		# 60
	.word	cmp_d		# 60
	.word	ill		# 60
	.word	ill		# 60
	.word	ill		# 60
	.word	ill		# 60
	.word	ill		# 60
	.word	ill		# 60
	.word	cmp_s		# 61
	.word	cmp_d		# 61
	.word	ill		# 61
	.word	ill		# 61
	.word	ill		# 61
	.word	ill		# 61
	.word	ill		# 61
	.word	ill		# 61
	.word	cmp_s		# 62
	.word	cmp_d		# 62
	.word	ill		# 62
	.word	ill		# 62
	.word	ill		# 62
	.word	ill		# 62
	.word	ill		# 62
	.word	ill		# 62
	.word	cmp_s		# 63
	.word	cmp_d		# 63
	.word	ill		# 63
	.word	ill		# 63
	.word	ill		# 63
	.word	ill		# 63
	.word	ill		# 63
	.word	ill		# 63
d401 1
a401 1
	xor	ta0, ta0, 1			# negate FT sign bit
d437 1
a437 1
	and	t0, t0, ta0			# compute result sign
d442 2
a443 2
	subu	t1, t1, SEXP_BIAS		# unbias FS exponent
	or	t2, t2, SIMPL_ONE		# set implied one bit
d447 4
a450 4
	subu	t1, t1, SEXP_BIAS		# unbias FS exponent
	or	t2, t2, SIMPL_ONE		# set implied one bit
	subu	ta1, ta1, SEXP_BIAS		# unbias FT exponent
	or	ta2, ta2, SIMPL_ONE		# set implied one bit
d456 1
a456 1
	beq	t1, ta1, 4f			# no shift needed
a527 1
	bne	t3, zero, result_fs_d
a528 1
	bne	ta3, zero, result_ft_d
d534 1
a534 3
	bne	t2, zero, 1f			# is FS zero?
	beq	t3, zero, 3f
1:
d536 1
a536 3
	bne	ta2, zero, 1f
	beq	ta3, zero, result_fs_d		# FT is zero, result=FS
1:
a547 1
	bne	ta3, zero, result_ft_d
d557 1
a557 3
	bne	ta2, zero, 1f
	beq	ta3, zero, result_fs_d		# FT is zero, result=FS
1:
a582 1
	move	t3, zero
a585 1
	move	ta3, zero
d588 2
a589 1
	li	t9, 32
d592 2
a593 16
	blt	v1, t9, 1f			# shift right by < 32?
	subu	v1, v1, t9
	subu	t9, t9, v1
	sll	t8, t2, t9			# save bits shifted out
	sltu	t9, zero, t3			# dont lose any one bits
	or	t8, t8, t9			# save sticky bit
	srl	t3, t2, v1			# shift FSs fraction
	move	t2, zero
	b	4f
1:
	subu	t9, t9, v1
	sll	t8, t3, t9			# save bits shifted out
	srl	t3, t3, v1			# shift FSs fraction
	sll	t9, t2, t9			# save bits shifted out of t2
	or	t3, t3, t9			# and put into t3
	srl	t2, t2, v1
d596 2
a597 14
	blt	v1, t9, 1f			# shift right by < 32?
	subu	v1, v1, t9
	subu	t9, t9, v1
	sll	t8, ta2, t9			# save bits shifted out
	srl	ta3, ta2, v1			# shift FTs fraction
	move	ta2, zero
	b	4f
1:
	subu	t9, t9, v1
	sll	t8, ta3, t9			# save bits shifted out
	srl	ta3, ta3, v1			# shift FTs fraction
	sll	t9, ta2, t9			# save bits shifted out of t2
	or	ta3, ta3, t9			# and put into t3
	srl	ta2, ta2, v1
d600 1
a600 4
	addu	t3, t3, ta3			# add fractions
	sltu	t9, t3, ta3			# compute carry
	addu	t2, t2, ta2			# add fractions
	addu	t2, t2, t9			# add carry
a604 2
	bltu	t3, ta3, 3f
	bne	t3, ta3, 2f			# if same, result=0
a606 1
	move	t3, zero
d615 4
a618 10
	beq	t8, zero, 1f			# compute t2:t3:zero - ta2:ta3:t8
	subu	t8, zero, t8
	sltu	v0, t3, 1			# compute barrow out
	subu	t3, t3, 1			# subtract barrow
	subu	t2, t2, v0
1:
	sltu	v0, t3, ta3
	subu	t3, t3, ta3			# subtract fractions
	subu	t2, t2, ta2			# subtract fractions
	subu	t2, t2, v0			# subtract barrow
d622 3
a624 10
	beq	t8, zero, 1f			# compute ta2:ta3:zero - t2:t3:t8
	subu	t8, zero, t8
	sltu	v0, ta3, 1			# compute barrow out
	subu	ta3, ta3, 1			# subtract barrow
	subu	ta2, ta2, v0
1:
	sltu	v0, ta3, t3
	subu	t3, ta3, t3			# subtract fractions
	subu	t2, ta2, t2			# subtract fractions
	subu	t2, t2, v0			# subtract barrow
a681 1
	bne	t3, zero, result_fs_d
a683 1
	bne	ta3, zero, result_ft_d
a687 1
	bne	ta3, zero, result_fs_d
a692 1
	bne	t3, zero, result_ft_d
a693 1
	bne	ta3, zero, result_ft_d
d697 1
a697 3
	bne	t2, zero, 1f
	beq	t3, zero, result_fs_d		# result is zero
1:
d705 1
a705 3
	bne	ta2, zero, 1f
	beq	ta3, zero, result_ft_d		# result is zero
1:
d714 2
a715 24
	multu	t3, ta3				# multiply fractions (low * low)
	move	ta0, t2				# free up t2,t3 for result
	move	ta1, t3
	mflo	a3				# save low order bits
	mfhi	t8
	not	v0, t8
	multu	ta0, ta3				# multiply FS(high) * FT(low)
	mflo	v1
	mfhi	t3				# init low result
	sltu	v0, v0, v1			# compute carry
	addu	t8, v1
	multu	ta1, ta2				# multiply FS(low) * FT(high)
	addu	t3, t3, v0			# add carry
	not	v0, t8
	mflo	v1
	mfhi	t2
	sltu	v0, v0, v1
	addu	t8, v1
	multu	ta0, ta2				# multiply FS(high) * FT(high)
	addu	t3, v0
	not	v1, t3
	sltu	v1, v1, t2
	addu	t3, t2
	not	v0, t3
a716 7
	addu	t2, v1
	mflo	v1
	sltu	v0, v0, v1
	addu	t2, v0
	addu	t3, v1
	sltu	a3, zero, a3			# reduce t8,a3 to just t8
	or	t8, a3
a794 1
	bne	t3, zero, result_fs_d
a796 1
	bne	ta3, zero, result_ft_d
a800 1
	bne	ta3, zero, result_ft_d
a802 1
	move	t3, zero
a806 1
	bne	t3, zero, 1f
d808 1
a808 2
	bne	ta2, zero, result_fs_d
	beq	ta3, zero, invalid_d		# 0 / 0
a818 1
	bne	ta3, zero, 1f
d822 1
a822 1
	ctc1	a1, FPC_CSR		# Save exceptions
a824 1
	move	t3, zero
a836 1
	move	t9, t3
a837 1
	move	t3, zero
a839 2
	bne	t8, ta2, 2f
	bltu	t9, ta3, 3f
d841 2
a842 5
	sltu	v1, t9, ta3			# subtract divisor from dividend
	subu	t9, t9, ta3
	subu	t8, t8, ta2
	subu	t8, t8, v1
	or	t3, t3, 1			# remember that we did
d844 1
a844 13
	bne	t9, zero, 3f
	li	v1, 32				# shift result to final position
	blt	v0, v1, 2f			# shift < 32 bits?
	subu	v0, v0, v1			# shift by > 32 bits
	sll	t2, t3, v0			# shift upper part
	move	t3, zero
	b	norm_d
2:
	subu	v1, v1, v0			# shift by < 32 bits
	sll	t2, t2, v0			# shift upper part
	srl	t9, t3, v1			# save bits shifted out
	or	t2, t2, t9			# and put into upper part
	sll	t3, t3, v0
d847 2
a848 8
	sll	t8, t8, 1			# shift dividend
	srl	v1, t9, 31			# save bit shifted out
	or	t8, t8, v1			# and put into upper part
	sll	t9, t9, 1
	sll	t2, t2, 1			# shift result
	srl	v1, t3, 31			# save bit shifted out
	or	t2, t2, v1			# and put into upper part
	sll	t3, t3, 1
a850 2
	sltu	v0, zero, t9			# be sure to save any one bits
	or	t8, t8, v0			# from the lower remainder
d906 1
a906 3
	sll	t2, t2, 3			# convert D fraction to S
	srl	t8, t3, 32 - 3
	or	t2, t2, t8
d910 1
a910 3
	bne	t2, zero, 1f
	beq	t3, zero, result_fs_s		# result=0
1:
d918 1
a918 4
	sll	t2, t2, 3			# convert D fraction to S
	srl	t8, t3, 32 - 3
	or	t2, t2, t8
	sll	t8, t3, 3
d922 6
d932 1
d942 6
a947 1
	srl	v1, v0, 16
d950 1
a950 1
	sll	v0, 16
d952 1
a952 1
	srl	v1, v0, 24
d955 1
a955 1
	sll	v0, 8
d957 1
a957 1
	srl	v1, v0, 28
d960 1
a960 1
	sll	v0, 4
d962 1
a962 1
	srl	v1, v0, 30
d965 1
a965 1
	sll	v0, 2
d967 1
a967 1
	srl	v1, v0, 31
d974 2
a975 2
	subu	t9, t9, SLEAD_ZEROS		# dont count leading zeros
	li	t1, 23				# init exponent
d998 1
a998 1
	move	t3, zero
d1010 1
a1010 2
	sll	t3, t2, 32 - 3			# convert S fraction to D
	srl	t2, t2, 3
d1014 6
d1024 1
a1026 1
	move	t3, zero
d1034 6
a1039 1
	srl	v1, v0, 16
d1042 1
a1042 1
	sll	v0, 16
d1044 1
a1044 1
	srl	v1, v0, 24
d1047 1
a1047 1
	sll	v0, 8
d1049 1
a1049 1
	srl	v1, v0, 28
d1052 1
a1052 1
	sll	v0, 4
d1054 1
a1054 1
	srl	v1, v0, 30
d1057 1
a1057 1
	sll	v0, 2
d1059 1
a1059 1
	srl	v1, v0, 31
d1070 1
a1070 1
	li	v0, 32
d1073 1
a1073 1
	sll	t2, t2, t9			# shift left
a1075 1
	move	t3, zero
d1080 1
a1080 2
	sll	t3, t2, v0
	srl	t2, t2, t9
d1085 16
d1104 2
d1117 1
a1117 2
	sll	t3, t2, 32 - 3			# convert S fraction to D
	srl	t2, t2, 3
d1121 16
d1140 2
a1144 1
	bne	t3, zero, invalid_w		# invalid conversion
d1147 1
a1147 3
	bne	t2, zero, 1f
	beq	t3, zero, result_fs_w		# result is zero
1:
a1159 1
	bne	t3, zero, overflow_w
d1165 1
a1165 1
	li	v1, 32
d1168 1
a1168 4
	sll	t2, t2, v0
	srl	t9, t3, v1			# save bits shifted out of t3
	or	t2, t2, t9			# and put into t2
	sll	t3, t3, v0			# shift FSs fraction
d1173 1
a1173 1
	sll	t8, t3, v1			# save bits shifted out
d1175 1
a1175 5
	srl	t3, t3, v0			# shift FSs fraction
	or	t3, t3, t8
	sll	t9, t2, v1			# save bits shifted out of t2
	or	t3, t3, t9			# and put into t3
	srl	t2, t2, v0
d1177 1
a1177 1
 * round result (t0 is sign, t2 is integer part, t3 is fractional part).
d1180 3
a1182 4
	and	v0, a1, FPC_ROUNDING_BITS	# get rounding mode
	beq	v0, FPC_ROUND_RN, 3f	# round to nearest
	beq	v0, FPC_ROUND_RZ, 5f	# round to zero (truncate)
	beq	v0, FPC_ROUND_RP, 1f	# round to +infinity
d1188 1
a1188 2
	beq	t3, zero, 5f			# if no fraction bits, continue
	addu	t2, t2, 1			# add rounding bit
d1192 1
a1192 5
	li	v0, GUARDBIT			# load guard bit for rounding
	addu	v0, v0, t3			# add remainder
	sltu	v1, v0, t3			# compute carry out
	beq	v1, zero, 4f			# if no carry, continue
	addu	t2, t2, 1			# add carry to result
d1196 1
a1196 1
	and	t2, t2, ~1			#  clear LSB (round to nearest)
d1201 3
a1203 1
	beq	t3, zero, result_fs_w		# is result exact?
d1274 1
a1274 2
	bne	t2, zero, unordered
	bne	t3, zero, unordered		# FS is a NAN
d1277 1
a1277 2
	bne	ta2, zero, unordered
	bne	ta3, zero, unordered		# FT is a NAN
d1279 1
a1279 1
	sll	t1, t1, 20			# reassemble exp & frac
d1281 1
a1281 1
	sll	ta1, ta1, 20			# reassemble exp & frac
d1284 1
a1284 5
	not	t3				# negate t1,t3
	not	t1
	addu	t3, t3, 1
	seq	v0, t3, zero			# compute carry
	addu	t1, t1, v0
d1287 1
a1287 5
	not	ta3				# negate ta1,ta3
	not	ta1
	addu	ta3, ta3, 1
	seq	v0, ta3, zero			# compute carry
	addu	ta1, ta1, v0
a1290 4
	move	v0, zero
	bne	t1, ta1, test_cond		# is FS(MSW) > FT(MSW)?
	li	v0, COND_LESS
	bltu	t3, ta3, test_cond		# is FS(LSW) < FT(LSW)?
d1292 1
a1292 1
	beq	t3, ta3, test_cond		# is FS(LSW) == FT(LSW)?
d1556 2
a1557 5
	bne	t2, zero, 1f
	move	v0, t3
	addu	t9, 32
	bne	t3, zero, 1f
	move	v0, t8
d1559 1
d1561 1
a1561 1
	srl	v1, v0, 16
d1564 1
a1564 1
	sll	v0, 16
d1566 1
a1566 1
	srl	v1, v0, 24
d1569 1
a1569 1
	sll	v0, 8
d1571 1
a1571 1
	srl	v1, v0, 28
d1574 1
a1574 1
	sll	v0, 4
d1576 1
a1576 1
	srl	v1, v0, 30
d1579 1
a1579 1
	sll	v0, 2
d1581 1
a1581 1
	srl	v1, v0, 31
d1585 1
a1585 1
 * Now shift t2,t3,t8 the correct number of bits.
d1591 1
a1591 1
	li	v1, 32
a1592 2
	blt	t9, v1, 1f			# shift by < 32?
	subu	t9, t9, v1			# shift by >= 32
d1594 2
a1595 2
	sll	t2, t3, t9			# shift left by t9
	srl	v0, t8, v1			# save bits shifted out
d1597 1
a1597 12
	sll	t3, t8, t9
	move	t8, zero
	b	norm_noshift_d
1:
	subu	v1, v1, t9
	sll	t2, t2, t9			# shift left by t9
	srl	v0, t3, v1			# save bits shifted out
	or	t2, t2, v0
	sll	t3, t3, t9
	srl	v0, t8, v1			# save bits shifted out
	or	t3, t3, v0
	sll	t8, t8, t9
d1602 1
a1602 1
	sll	v0, t8, v1			# save bits shifted out
d1604 1
a1604 1
	srl	t8, t8, t9
d1606 1
a1606 1
	sll	v0, t3, v1			# save bits shifted out
d1608 1
a1608 4
	srl	t3, t3, t9
	sll	v0, t2, v1			# save bits shifted out
	or	t3, t3, v0
	srl	t2, t2, t9
a1611 1
	move	ta3, t3				# save unrounded fraction (LS)
d1622 1
a1622 3
	addu	t3, t3, 1			# add rounding bit
	bne	t3, zero, 5f			# branch if no carry
	addu	t2, t2, 1			# add carry
d1625 1
a1625 1
	srl	t2, t2, 1			# renormalize fraction
d1628 1
a1628 1
	li	v0, GUARDBIT			# load guard bit for rounding
d1632 1
a1632 3
	addu	t3, t3, 1			# add carry
	bne	t3, zero, 4f			# branch if no carry
	addu	t2, t2, 1			# add carry to result
d1638 1
a1638 1
	and	t3, t3, ~1			#  clear LSB (round to nearest)
d1682 1
a1682 2
	li	t2, 0x000fffff
	li	t3, 0xffffffff
a1688 1
	move	t3, zero
a1712 1
	move	t3, ta3				# get unrounded fraction (LS)
a1717 1
	move	t3, zero
d1732 1
a1732 1
	addu	t3, t3, 1			# add rounding bit
d1735 1
a1735 3
	li	v1, 32
	blt	t9, v1, 1f			# shift by < 32?
	subu	t9, t9, v1			# shift right by >= 32
d1738 1
a1738 9
	sll	t8, t2, v1			# save bits shifted out
	or	t8, t8, v0			# include sticky bits
	srl	t3, t2, t9
	move	t2, zero
	b	2f
1:
	subu	v1, v1, t9			# shift right by t9
	sltu	v0, zero, t8			# be sure to save any one bits
	sll	t8, t3, v1			# save bits shifted out
d1740 1
a1740 4
	srl	t3, t3, t9
	sll	v0, t2, v1			# save bits shifted out
	or	t3, t3, v0
	srl	t2, t2, t9
a1743 1
2:
d1754 1
a1754 3
	addu	t3, t3, 1			# add rounding bit
	bne	t3, zero, 5f			# if no carry, continue
	addu	t2, t2, 1			# add carry
d1757 2
a1758 2
	li	v0, GUARDBIT			# load guard bit for rounding
	addu	v0, v0, t8			# add remainder
d1761 1
a1761 3
	addu	t3, t3, 1			# add rounding bit
	bne	t3, zero, 4f			# if no carry, continue
	addu	t2, t2, 1			# add carry
d1764 1
a1764 1
	and	t3, t3, ~1			#  clear LSB (round to nearest)
d1802 2
a1803 3
	li	t2, DQUIET_NAN0
	li	t3, DQUIET_NAN1
	jal	set_fd_d			# save result (in t0,t1,t2,t3)
d1814 1
a1814 1
	ctc1	a1, FPC_CSR		# save exceptions
a1855 1
	move	t3, ta3
d1857 1
a1857 1
	jal	set_fd_d			# save result (in t0,t1,t2,t3)
d1879 8
d1888 3
a1890 3
	srl	a3, a0, 12 - 2			# get FS field (even regs only)
	and	a3, a3, 0xF << 2		# mask FS field
	lw	a3, get_fs_int_tbl(a3)		# switch on register number
a1894 16
	.word	get_fs_int_f0
	.word	get_fs_int_f2
	.word	get_fs_int_f4
	.word	get_fs_int_f6
	.word	get_fs_int_f8
	.word	get_fs_int_f10
	.word	get_fs_int_f12
	.word	get_fs_int_f14
	.word	get_fs_int_f16
	.word	get_fs_int_f18
	.word	get_fs_int_f20
	.word	get_fs_int_f22
	.word	get_fs_int_f24
	.word	get_fs_int_f26
	.word	get_fs_int_f28
	.word	get_fs_int_f30
d1897 33
a1929 47
get_fs_int_f0:
	mfc1	t2, $f0
	b	get_fs_int_done
get_fs_int_f2:
	mfc1	t2, $f2
	b	get_fs_int_done
get_fs_int_f4:
	mfc1	t2, $f4
	b	get_fs_int_done
get_fs_int_f6:
	mfc1	t2, $f6
	b	get_fs_int_done
get_fs_int_f8:
	mfc1	t2, $f8
	b	get_fs_int_done
get_fs_int_f10:
	mfc1	t2, $f10
	b	get_fs_int_done
get_fs_int_f12:
	mfc1	t2, $f12
	b	get_fs_int_done
get_fs_int_f14:
	mfc1	t2, $f14
	b	get_fs_int_done
get_fs_int_f16:
	mfc1	t2, $f16
	b	get_fs_int_done
get_fs_int_f18:
	mfc1	t2, $f18
	b	get_fs_int_done
get_fs_int_f20:
	mfc1	t2, $f20
	b	get_fs_int_done
get_fs_int_f22:
	mfc1	t2, $f22
	b	get_fs_int_done
get_fs_int_f24:
	mfc1	t2, $f24
	b	get_fs_int_done
get_fs_int_f26:
	mfc1	t2, $f26
	b	get_fs_int_done
get_fs_int_f28:
	mfc1	t2, $f28
	b	get_fs_int_done
get_fs_int_f30:
	mfc1	t2, $f30
d1934 2
d1941 71
d2028 8
d2037 3
a2039 3
	srl	a3, a0, 17 - 2			# get FT field (even regs only)
	and	a3, a3, 0xF << 2		# mask FT field
	lw	a3, get_ft_s_tbl(a3)		# switch on register number
a2043 16
	.word	get_ft_s_f0
	.word	get_ft_s_f2
	.word	get_ft_s_f4
	.word	get_ft_s_f6
	.word	get_ft_s_f8
	.word	get_ft_s_f10
	.word	get_ft_s_f12
	.word	get_ft_s_f14
	.word	get_ft_s_f16
	.word	get_ft_s_f18
	.word	get_ft_s_f20
	.word	get_ft_s_f22
	.word	get_ft_s_f24
	.word	get_ft_s_f26
	.word	get_ft_s_f28
	.word	get_ft_s_f30
d2046 33
a2078 47
get_ft_s_f0:
	mfc1	ta0, $f0
	b	get_ft_s_done
get_ft_s_f2:
	mfc1	ta0, $f2
	b	get_ft_s_done
get_ft_s_f4:
	mfc1	ta0, $f4
	b	get_ft_s_done
get_ft_s_f6:
	mfc1	ta0, $f6
	b	get_ft_s_done
get_ft_s_f8:
	mfc1	ta0, $f8
	b	get_ft_s_done
get_ft_s_f10:
	mfc1	ta0, $f10
	b	get_ft_s_done
get_ft_s_f12:
	mfc1	ta0, $f12
	b	get_ft_s_done
get_ft_s_f14:
	mfc1	ta0, $f14
	b	get_ft_s_done
get_ft_s_f16:
	mfc1	ta0, $f16
	b	get_ft_s_done
get_ft_s_f18:
	mfc1	ta0, $f18
	b	get_ft_s_done
get_ft_s_f20:
	mfc1	ta0, $f20
	b	get_ft_s_done
get_ft_s_f22:
	mfc1	ta0, $f22
	b	get_ft_s_done
get_ft_s_f24:
	mfc1	ta0, $f24
	b	get_ft_s_done
get_ft_s_f26:
	mfc1	ta0, $f26
	b	get_ft_s_done
get_ft_s_f28:
	mfc1	ta0, $f28
	b	get_ft_s_done
get_ft_s_f30:
	mfc1	ta0, $f30
d2104 8
d2113 3
a2115 3
	srl	a3, a0, 12 - 2			# get FS field (even regs only)
	and	a3, a3, 0xF << 2		# mask FS field
	lw	a3, get_fs_s_tbl(a3)		# switch on register number
a2119 16
	.word	get_fs_s_f0
	.word	get_fs_s_f2
	.word	get_fs_s_f4
	.word	get_fs_s_f6
	.word	get_fs_s_f8
	.word	get_fs_s_f10
	.word	get_fs_s_f12
	.word	get_fs_s_f14
	.word	get_fs_s_f16
	.word	get_fs_s_f18
	.word	get_fs_s_f20
	.word	get_fs_s_f22
	.word	get_fs_s_f24
	.word	get_fs_s_f26
	.word	get_fs_s_f28
	.word	get_fs_s_f30
d2122 33
a2154 47
get_fs_s_f0:
	mfc1	t0, $f0
	b	get_fs_s_done
get_fs_s_f2:
	mfc1	t0, $f2
	b	get_fs_s_done
get_fs_s_f4:
	mfc1	t0, $f4
	b	get_fs_s_done
get_fs_s_f6:
	mfc1	t0, $f6
	b	get_fs_s_done
get_fs_s_f8:
	mfc1	t0, $f8
	b	get_fs_s_done
get_fs_s_f10:
	mfc1	t0, $f10
	b	get_fs_s_done
get_fs_s_f12:
	mfc1	t0, $f12
	b	get_fs_s_done
get_fs_s_f14:
	mfc1	t0, $f14
	b	get_fs_s_done
get_fs_s_f16:
	mfc1	t0, $f16
	b	get_fs_s_done
get_fs_s_f18:
	mfc1	t0, $f18
	b	get_fs_s_done
get_fs_s_f20:
	mfc1	t0, $f20
	b	get_fs_s_done
get_fs_s_f22:
	mfc1	t0, $f22
	b	get_fs_s_done
get_fs_s_f24:
	mfc1	t0, $f24
	b	get_fs_s_done
get_fs_s_f26:
	mfc1	t0, $f26
	b	get_fs_s_done
get_fs_s_f28:
	mfc1	t0, $f28
	b	get_fs_s_done
get_fs_s_f30:
	mfc1	t0, $f30
a2177 1
 *	t3	contains the FS remaining fraction
a2180 1
 *	ta3	contains the FT remaining fraction
d2184 8
d2193 3
a2195 3
	srl	a3, a0, 17 - 2			# get FT field (even regs only)
	and	a3, a3, 0xF << 2		# mask FT field
	lw	a3, get_ft_d_tbl(a3)		# switch on register number
a2199 16
	.word	get_ft_d_f0
	.word	get_ft_d_f2
	.word	get_ft_d_f4
	.word	get_ft_d_f6
	.word	get_ft_d_f8
	.word	get_ft_d_f10
	.word	get_ft_d_f12
	.word	get_ft_d_f14
	.word	get_ft_d_f16
	.word	get_ft_d_f18
	.word	get_ft_d_f20
	.word	get_ft_d_f22
	.word	get_ft_d_f24
	.word	get_ft_d_f26
	.word	get_ft_d_f28
	.word	get_ft_d_f30
d2202 33
a2234 63
get_ft_d_f0:
	mfc1	ta3, $f0
	mfc1	ta0, $f1
	b	get_ft_d_done
get_ft_d_f2:
	mfc1	ta3, $f2
	mfc1	ta0, $f3
	b	get_ft_d_done
get_ft_d_f4:
	mfc1	ta3, $f4
	mfc1	ta0, $f5
	b	get_ft_d_done
get_ft_d_f6:
	mfc1	ta3, $f6
	mfc1	ta0, $f7
	b	get_ft_d_done
get_ft_d_f8:
	mfc1	ta3, $f8
	mfc1	ta0, $f9
	b	get_ft_d_done
get_ft_d_f10:
	mfc1	ta3, $f10
	mfc1	ta0, $f11
	b	get_ft_d_done
get_ft_d_f12:
	mfc1	ta3, $f12
	mfc1	ta0, $f13
	b	get_ft_d_done
get_ft_d_f14:
	mfc1	ta3, $f14
	mfc1	ta0, $f15
	b	get_ft_d_done
get_ft_d_f16:
	mfc1	ta3, $f16
	mfc1	ta0, $f17
	b	get_ft_d_done
get_ft_d_f18:
	mfc1	ta3, $f18
	mfc1	ta0, $f19
	b	get_ft_d_done
get_ft_d_f20:
	mfc1	ta3, $f20
	mfc1	ta0, $f21
	b	get_ft_d_done
get_ft_d_f22:
	mfc1	ta3, $f22
	mfc1	ta0, $f23
	b	get_ft_d_done
get_ft_d_f24:
	mfc1	ta3, $f24
	mfc1	ta0, $f25
	b	get_ft_d_done
get_ft_d_f26:
	mfc1	ta3, $f26
	mfc1	ta0, $f27
	b	get_ft_d_done
get_ft_d_f28:
	mfc1	ta3, $f28
	mfc1	ta0, $f29
	b	get_ft_d_done
get_ft_d_f30:
	mfc1	ta3, $f30
	mfc1	ta0, $f31
d2236 2
a2237 1
	srl	ta1, ta0, 20			# get exponent
d2239 2
a2240 2
	and	ta2, ta0, 0xFFFFF			# get fraction
	srl	ta0, ta0, 31			# get sign
a2257 1
 *	t3	contains the remaining fraction
d2261 8
d2272 1
a2272 1
	lw	a3, get_fs_d_tbl(a3)		# switch on register number
a2276 16
	.word	get_fs_d_f0
	.word	get_fs_d_f2
	.word	get_fs_d_f4
	.word	get_fs_d_f6
	.word	get_fs_d_f8
	.word	get_fs_d_f10
	.word	get_fs_d_f12
	.word	get_fs_d_f14
	.word	get_fs_d_f16
	.word	get_fs_d_f18
	.word	get_fs_d_f20
	.word	get_fs_d_f22
	.word	get_fs_d_f24
	.word	get_fs_d_f26
	.word	get_fs_d_f28
	.word	get_fs_d_f30
d2279 33
a2311 63
get_fs_d_f0:
	mfc1	t3, $f0
	mfc1	t0, $f1
	b	get_fs_d_done
get_fs_d_f2:
	mfc1	t3, $f2
	mfc1	t0, $f3
	b	get_fs_d_done
get_fs_d_f4:
	mfc1	t3, $f4
	mfc1	t0, $f5
	b	get_fs_d_done
get_fs_d_f6:
	mfc1	t3, $f6
	mfc1	t0, $f7
	b	get_fs_d_done
get_fs_d_f8:
	mfc1	t3, $f8
	mfc1	t0, $f9
	b	get_fs_d_done
get_fs_d_f10:
	mfc1	t3, $f10
	mfc1	t0, $f11
	b	get_fs_d_done
get_fs_d_f12:
	mfc1	t3, $f12
	mfc1	t0, $f13
	b	get_fs_d_done
get_fs_d_f14:
	mfc1	t3, $f14
	mfc1	t0, $f15
	b	get_fs_d_done
get_fs_d_f16:
	mfc1	t3, $f16
	mfc1	t0, $f17
	b	get_fs_d_done
get_fs_d_f18:
	mfc1	t3, $f18
	mfc1	t0, $f19
	b	get_fs_d_done
get_fs_d_f20:
	mfc1	t3, $f20
	mfc1	t0, $f21
	b	get_fs_d_done
get_fs_d_f22:
	mfc1	t3, $f22
	mfc1	t0, $f23
	b	get_fs_d_done
get_fs_d_f24:
	mfc1	t3, $f24
	mfc1	t0, $f25
	b	get_fs_d_done
get_fs_d_f26:
	mfc1	t3, $f26
	mfc1	t0, $f27
	b	get_fs_d_done
get_fs_d_f28:
	mfc1	t3, $f28
	mfc1	t0, $f29
	b	get_fs_d_done
get_fs_d_f30:
	mfc1	t3, $f30
	mfc1	t0, $f31
d2313 2
a2314 1
	srl	t1, t0, 20			# get exponent
d2316 2
a2317 2
	and	t2, t0, 0xFFFFF			# get fraction
	srl	t0, t0, 31			# get sign
d2342 8
d2351 3
a2353 3
	srl	a3, a0, 12 - 2			# get FS field (even regs only)
	and	a3, a3, 0xF << 2		# mask FS field
	lw	a3, cmp_fs_s_tbl(a3)		# switch on register number
a2357 16
	.word	cmp_fs_s_f0
	.word	cmp_fs_s_f2
	.word	cmp_fs_s_f4
	.word	cmp_fs_s_f6
	.word	cmp_fs_s_f8
	.word	cmp_fs_s_f10
	.word	cmp_fs_s_f12
	.word	cmp_fs_s_f14
	.word	cmp_fs_s_f16
	.word	cmp_fs_s_f18
	.word	cmp_fs_s_f20
	.word	cmp_fs_s_f22
	.word	cmp_fs_s_f24
	.word	cmp_fs_s_f26
	.word	cmp_fs_s_f28
	.word	cmp_fs_s_f30
d2360 33
a2392 47
cmp_fs_s_f0:
	mfc1	t0, $f0
	b	cmp_fs_s_done
cmp_fs_s_f2:
	mfc1	t0, $f2
	b	cmp_fs_s_done
cmp_fs_s_f4:
	mfc1	t0, $f4
	b	cmp_fs_s_done
cmp_fs_s_f6:
	mfc1	t0, $f6
	b	cmp_fs_s_done
cmp_fs_s_f8:
	mfc1	t0, $f8
	b	cmp_fs_s_done
cmp_fs_s_f10:
	mfc1	t0, $f10
	b	cmp_fs_s_done
cmp_fs_s_f12:
	mfc1	t0, $f12
	b	cmp_fs_s_done
cmp_fs_s_f14:
	mfc1	t0, $f14
	b	cmp_fs_s_done
cmp_fs_s_f16:
	mfc1	t0, $f16
	b	cmp_fs_s_done
cmp_fs_s_f18:
	mfc1	t0, $f18
	b	cmp_fs_s_done
cmp_fs_s_f20:
	mfc1	t0, $f20
	b	cmp_fs_s_done
cmp_fs_s_f22:
	mfc1	t0, $f22
	b	cmp_fs_s_done
cmp_fs_s_f24:
	mfc1	t0, $f24
	b	cmp_fs_s_done
cmp_fs_s_f26:
	mfc1	t0, $f26
	b	cmp_fs_s_done
cmp_fs_s_f28:
	mfc1	t0, $f28
	b	cmp_fs_s_done
cmp_fs_s_f30:
	mfc1	t0, $f30
d2399 11
a2409 3
	srl	a3, a0, 17 - 2			# get FT field (even regs only)
	and	a3, a3, 0xF << 2		# mask FT field
	lw	a3, cmp_ft_s_tbl(a3)		# switch on register number
a2413 16
	.word	cmp_ft_s_f0
	.word	cmp_ft_s_f2
	.word	cmp_ft_s_f4
	.word	cmp_ft_s_f6
	.word	cmp_ft_s_f8
	.word	cmp_ft_s_f10
	.word	cmp_ft_s_f12
	.word	cmp_ft_s_f14
	.word	cmp_ft_s_f16
	.word	cmp_ft_s_f18
	.word	cmp_ft_s_f20
	.word	cmp_ft_s_f22
	.word	cmp_ft_s_f24
	.word	cmp_ft_s_f26
	.word	cmp_ft_s_f28
	.word	cmp_ft_s_f30
d2416 32
a2447 47
cmp_ft_s_f0:
	mfc1	ta0, $f0
	b	cmp_ft_s_done
cmp_ft_s_f2:
	mfc1	ta0, $f2
	b	cmp_ft_s_done
cmp_ft_s_f4:
	mfc1	ta0, $f4
	b	cmp_ft_s_done
cmp_ft_s_f6:
	mfc1	ta0, $f6
	b	cmp_ft_s_done
cmp_ft_s_f8:
	mfc1	ta0, $f8
	b	cmp_ft_s_done
cmp_ft_s_f10:
	mfc1	ta0, $f10
	b	cmp_ft_s_done
cmp_ft_s_f12:
	mfc1	ta0, $f12
	b	cmp_ft_s_done
cmp_ft_s_f14:
	mfc1	ta0, $f14
	b	cmp_ft_s_done
cmp_ft_s_f16:
	mfc1	ta0, $f16
	b	cmp_ft_s_done
cmp_ft_s_f18:
	mfc1	ta0, $f18
	b	cmp_ft_s_done
cmp_ft_s_f20:
	mfc1	ta0, $f20
	b	cmp_ft_s_done
cmp_ft_s_f22:
	mfc1	ta0, $f22
	b	cmp_ft_s_done
cmp_ft_s_f24:
	mfc1	ta0, $f24
	b	cmp_ft_s_done
cmp_ft_s_f26:
	mfc1	ta0, $f26
	b	cmp_ft_s_done
cmp_ft_s_f28:
	mfc1	ta0, $f28
	b	cmp_ft_s_done
cmp_ft_s_f30:
	mfc1	ta0, $f30
a2466 1
 *	t3	contains the remaining fraction
a2469 1
 *	ta3	contains the remaining fraction
d2473 8
d2482 3
a2484 3
	srl	a3, a0, 12 - 2			# get FS field (even regs only)
	and	a3, a3, 0xF << 2		# mask FS field
	lw	a3, cmp_fs_d_tbl(a3)		# switch on register number
a2488 16
	.word	cmp_fs_d_f0
	.word	cmp_fs_d_f2
	.word	cmp_fs_d_f4
	.word	cmp_fs_d_f6
	.word	cmp_fs_d_f8
	.word	cmp_fs_d_f10
	.word	cmp_fs_d_f12
	.word	cmp_fs_d_f14
	.word	cmp_fs_d_f16
	.word	cmp_fs_d_f18
	.word	cmp_fs_d_f20
	.word	cmp_fs_d_f22
	.word	cmp_fs_d_f24
	.word	cmp_fs_d_f26
	.word	cmp_fs_d_f28
	.word	cmp_fs_d_f30
d2491 33
a2523 63
cmp_fs_d_f0:
	mfc1	t3, $f0
	mfc1	t0, $f1
	b	cmp_fs_d_done
cmp_fs_d_f2:
	mfc1	t3, $f2
	mfc1	t0, $f3
	b	cmp_fs_d_done
cmp_fs_d_f4:
	mfc1	t3, $f4
	mfc1	t0, $f5
	b	cmp_fs_d_done
cmp_fs_d_f6:
	mfc1	t3, $f6
	mfc1	t0, $f7
	b	cmp_fs_d_done
cmp_fs_d_f8:
	mfc1	t3, $f8
	mfc1	t0, $f9
	b	cmp_fs_d_done
cmp_fs_d_f10:
	mfc1	t3, $f10
	mfc1	t0, $f11
	b	cmp_fs_d_done
cmp_fs_d_f12:
	mfc1	t3, $f12
	mfc1	t0, $f13
	b	cmp_fs_d_done
cmp_fs_d_f14:
	mfc1	t3, $f14
	mfc1	t0, $f15
	b	cmp_fs_d_done
cmp_fs_d_f16:
	mfc1	t3, $f16
	mfc1	t0, $f17
	b	cmp_fs_d_done
cmp_fs_d_f18:
	mfc1	t3, $f18
	mfc1	t0, $f19
	b	cmp_fs_d_done
cmp_fs_d_f20:
	mfc1	t3, $f20
	mfc1	t0, $f21
	b	cmp_fs_d_done
cmp_fs_d_f22:
	mfc1	t3, $f22
	mfc1	t0, $f23
	b	cmp_fs_d_done
cmp_fs_d_f24:
	mfc1	t3, $f24
	mfc1	t0, $f25
	b	cmp_fs_d_done
cmp_fs_d_f26:
	mfc1	t3, $f26
	mfc1	t0, $f27
	b	cmp_fs_d_done
cmp_fs_d_f28:
	mfc1	t3, $f28
	mfc1	t0, $f29
	b	cmp_fs_d_done
cmp_fs_d_f30:
	mfc1	t3, $f30
	mfc1	t0, $f31
d2525 2
a2526 1
	srl	t1, t0, 20			# get exponent
d2528 10
a2537 2
	and	t2, t0, 0xFFFFF			# get fraction
	srl	t0, t0, 31			# get sign
d2539 3
a2541 3
	srl	a3, a0, 17 - 2			# get FT field (even regs only)
	and	a3, a3, 0xF << 2		# mask FT field
	lw	a3, cmp_ft_d_tbl(a3)		# switch on register number
a2545 16
	.word	cmp_ft_d_f0
	.word	cmp_ft_d_f2
	.word	cmp_ft_d_f4
	.word	cmp_ft_d_f6
	.word	cmp_ft_d_f8
	.word	cmp_ft_d_f10
	.word	cmp_ft_d_f12
	.word	cmp_ft_d_f14
	.word	cmp_ft_d_f16
	.word	cmp_ft_d_f18
	.word	cmp_ft_d_f20
	.word	cmp_ft_d_f22
	.word	cmp_ft_d_f24
	.word	cmp_ft_d_f26
	.word	cmp_ft_d_f28
	.word	cmp_ft_d_f30
d2548 33
a2580 63
cmp_ft_d_f0:
	mfc1	ta3, $f0
	mfc1	ta0, $f1
	b	cmp_ft_d_done
cmp_ft_d_f2:
	mfc1	ta3, $f2
	mfc1	ta0, $f3
	b	cmp_ft_d_done
cmp_ft_d_f4:
	mfc1	ta3, $f4
	mfc1	ta0, $f5
	b	cmp_ft_d_done
cmp_ft_d_f6:
	mfc1	ta3, $f6
	mfc1	ta0, $f7
	b	cmp_ft_d_done
cmp_ft_d_f8:
	mfc1	ta3, $f8
	mfc1	ta0, $f9
	b	cmp_ft_d_done
cmp_ft_d_f10:
	mfc1	ta3, $f10
	mfc1	ta0, $f11
	b	cmp_ft_d_done
cmp_ft_d_f12:
	mfc1	ta3, $f12
	mfc1	ta0, $f13
	b	cmp_ft_d_done
cmp_ft_d_f14:
	mfc1	ta3, $f14
	mfc1	ta0, $f15
	b	cmp_ft_d_done
cmp_ft_d_f16:
	mfc1	ta3, $f16
	mfc1	ta0, $f17
	b	cmp_ft_d_done
cmp_ft_d_f18:
	mfc1	ta3, $f18
	mfc1	ta0, $f19
	b	cmp_ft_d_done
cmp_ft_d_f20:
	mfc1	ta3, $f20
	mfc1	ta0, $f21
	b	cmp_ft_d_done
cmp_ft_d_f22:
	mfc1	ta3, $f22
	mfc1	ta0, $f23
	b	cmp_ft_d_done
cmp_ft_d_f24:
	mfc1	ta3, $f24
	mfc1	ta0, $f25
	b	cmp_ft_d_done
cmp_ft_d_f26:
	mfc1	ta3, $f26
	mfc1	ta0, $f27
	b	cmp_ft_d_done
cmp_ft_d_f28:
	mfc1	ta3, $f28
	mfc1	ta0, $f29
	b	cmp_ft_d_done
cmp_ft_d_f30:
	mfc1	ta3, $f30
	mfc1	ta0, $f31
d2582 2
a2583 1
	srl	ta1, ta0, 20			# get exponent
d2585 2
a2586 2
	and	ta2, ta0, 0xFFFFF			# get fraction
	srl	ta0, ta0, 31			# get sign
d2613 8
d2627 3
a2629 3
	srl	a3, a0, 7 - 2			# get FD field (even regs only)
	and	a3, a3, 0xF << 2		# mask FT field
	lw	a3, set_fd_s_tbl(a3)		# switch on register number
a2633 16
	.word	set_fd_s_f0
	.word	set_fd_s_f2
	.word	set_fd_s_f4
	.word	set_fd_s_f6
	.word	set_fd_s_f8
	.word	set_fd_s_f10
	.word	set_fd_s_f12
	.word	set_fd_s_f14
	.word	set_fd_s_f16
	.word	set_fd_s_f18
	.word	set_fd_s_f20
	.word	set_fd_s_f22
	.word	set_fd_s_f24
	.word	set_fd_s_f26
	.word	set_fd_s_f28
	.word	set_fd_s_f30
d2636 33
a2668 48
set_fd_s_f0:
	mtc1	t2, $f0
	j	ra
set_fd_s_f2:
	mtc1	t2, $f2
	j	ra
set_fd_s_f4:
	mtc1	t2, $f4
	j	ra
set_fd_s_f6:
	mtc1	t2, $f6
	j	ra
set_fd_s_f8:
	mtc1	t2, $f8
	j	ra
set_fd_s_f10:
	mtc1	t2, $f10
	j	ra
set_fd_s_f12:
	mtc1	t2, $f12
	j	ra
set_fd_s_f14:
	mtc1	t2, $f14
	j	ra
set_fd_s_f16:
	mtc1	t2, $f16
	j	ra
set_fd_s_f18:
	mtc1	t2, $f18
	j	ra
set_fd_s_f20:
	mtc1	t2, $f20
	j	ra
set_fd_s_f22:
	mtc1	t2, $f22
	j	ra
set_fd_s_f24:
	mtc1	t2, $f24
	j	ra
set_fd_s_f26:
	mtc1	t2, $f26
	j	ra
set_fd_s_f28:
	mtc1	t2, $f28
	j	ra
set_fd_s_f30:
	mtc1	t2, $f30
	j	ra
a2681 1
 *	t3	contains the remaining fraction
d2685 8
d2694 2
a2695 2
	sll	t0, t0, 31			# set sign
	sll	t1, t1, 20			# set exponent
d2698 3
a2700 3
	srl	a3, a0, 7 - 2			# get FD field (even regs only)
	and	a3, a3, 0xF << 2		# mask FD field
	lw	a3, set_fd_d_tbl(a3)		# switch on register number
a2704 16
	.word	set_fd_d_f0
	.word	set_fd_d_f2
	.word	set_fd_d_f4
	.word	set_fd_d_f6
	.word	set_fd_d_f8
	.word	set_fd_d_f10
	.word	set_fd_d_f12
	.word	set_fd_d_f14
	.word	set_fd_d_f16
	.word	set_fd_d_f18
	.word	set_fd_d_f20
	.word	set_fd_d_f22
	.word	set_fd_d_f24
	.word	set_fd_d_f26
	.word	set_fd_d_f28
	.word	set_fd_d_f30
d2707 33
a2739 64
set_fd_d_f0:
	mtc1	t3, $f0
	mtc1	t0, $f1
	j	ra
set_fd_d_f2:
	mtc1	t3, $f2
	mtc1	t0, $f3
	j	ra
set_fd_d_f4:
	mtc1	t3, $f4
	mtc1	t0, $f5
	j	ra
set_fd_d_f6:
	mtc1	t3, $f6
	mtc1	t0, $f7
	j	ra
set_fd_d_f8:
	mtc1	t3, $f8
	mtc1	t0, $f9
	j	ra
set_fd_d_f10:
	mtc1	t3, $f10
	mtc1	t0, $f11
	j	ra
set_fd_d_f12:
	mtc1	t3, $f12
	mtc1	t0, $f13
	j	ra
set_fd_d_f14:
	mtc1	t3, $f14
	mtc1	t0, $f15
	j	ra
set_fd_d_f16:
	mtc1	t3, $f16
	mtc1	t0, $f17
	j	ra
set_fd_d_f18:
	mtc1	t3, $f18
	mtc1	t0, $f19
	j	ra
set_fd_d_f20:
	mtc1	t3, $f20
	mtc1	t0, $f21
	j	ra
set_fd_d_f22:
	mtc1	t3, $f22
	mtc1	t0, $f23
	j	ra
set_fd_d_f24:
	mtc1	t3, $f24
	mtc1	t0, $f25
	j	ra
set_fd_d_f26:
	mtc1	t3, $f26
	mtc1	t0, $f27
	j	ra
set_fd_d_f28:
	mtc1	t3, $f28
	mtc1	t0, $f29
	j	ra
set_fd_d_f30:
	mtc1	t3, $f30
	mtc1	t0, $f31
	j	ra
d2796 1
a2796 1
 *	t2,t3	normalized fraction
d2802 1
a2802 1
 * Find out how many leading zero bits are in t2,t3 and put in t9.
d2806 2
a2807 2
	bne	t2, zero, 1f
	move	v0, t3
d2809 1
d2811 1
a2811 1
	srl	v1, v0, 16
d2814 1
a2814 1
	sll	v0, 16
d2816 1
a2816 1
	srl	v1, v0, 24
d2819 1
a2819 1
	sll	v0, 8
d2821 1
a2821 1
	srl	v1, v0, 28
d2824 1
a2824 1
	sll	v0, 4
d2826 1
a2826 1
	srl	v1, v0, 30
d2829 1
a2829 1
	sll	v0, 2
d2831 1
a2831 1
	srl	v1, v0, 31
d2835 1
a2835 1
 * Now shift t2,t3 the correct number of bits.
d2840 2
a2841 13
	subu	t1, t1, t9		# adjust exponent
	li	v0, 32
	blt	t9, v0, 1f
	subu	t9, t9, v0		# shift fraction left >= 32 bits
	sll	t2, t3, t9
	move	t3, zero
	j	ra
1:
	subu	v0, v0, t9		# shift fraction left < 32 bits
	sll	t2, t2, t9
	srl	v1, t3, v0
	or	t2, t2, v1
	sll	t3, t3, t9
d2889 2
a2890 2
	subu	ta1, ta1, t9		# adjust exponent
	sll	ta2, ta2, t9
d2899 1
a2899 1
 *	ta2,ta3	normalized fraction
d2905 1
a2905 1
 * Find out how many leading zero bits are in ta2,ta3 and put in t9.
d2909 2
a2910 2
	bne	ta2, zero, 1f
	move	v0, ta3
d2912 1
d2914 1
a2914 1
	srl	v1, v0, 16
d2917 1
a2917 1
	sll	v0, 16
d2919 1
a2919 1
	srl	v1, v0, 24
d2922 1
a2922 1
	sll	v0, 8
d2924 1
a2924 1
	srl	v1, v0, 28
d2927 1
a2927 1
	sll	v0, 4
d2929 1
a2929 1
	srl	v1, v0, 30
d2932 1
a2932 1
	sll	v0, 2
d2934 1
a2934 1
	srl	v1, v0, 31
d2938 1
a2938 1
 * Now shift ta2,ta3 the correct number of bits.
d2943 2
a2944 13
	subu	ta1, ta1, t9		# adjust exponent
	li	v0, 32
	blt	t9, v0, 1f
	subu	t9, t9, v0		# shift fraction left >= 32 bits
	sll	ta2, ta3, t9
	move	ta3, zero
	j	ra
1:
	subu	v0, v0, t9		# shift fraction left < 32 bits
	sll	ta2, ta2, t9
	srl	v1, ta3, v0
	or	ta2, ta2, v1
	sll	ta3, ta3, t9
@


1.4
log
@Fix LEAF usage adding new extra arg. spotted by miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: fp.S,v 1.3 2004/09/09 22:11:38 pefo Exp $	*/
d38 1
a38 1
 *      $Id: fp.S,v 1.3 2004/09/09 22:11:38 pefo Exp $
d641 1
a641 1
	xor	ta4, ta4, 1			# negate FT sign bit
d650 1
a650 1
	bne	ta5, SEXP_INF, result_fs_s	# if FT is not inf, result=FS
d652 2
a653 2
	bne	ta6, zero, result_ft_s		# if FT is NAN, result is FT
	bne	t0, ta4, invalid_s		# both infinities same sign?
d656 1
a656 1
	beq	ta5, SEXP_INF, result_ft_s	# if FT is inf, result=FT
d659 2
a660 2
	bne	ta5, zero, 2f			# is FT a denormalized num?
	beq	ta6, zero, result_fs_s		# FT is zero, result=FS
d666 2
a667 2
	subu	ta5, ta5, SEXP_BIAS		# unbias FT exponent
	or	ta6, ta6, SIMPL_ONE		# set implied one bit
d670 2
a671 2
	bne	ta5, zero, result_ft_s		# if FT != 0, result=FT
	bne	ta6, zero, result_ft_s
d674 1
a674 1
	or	t0, t0, ta4			# compute result sign
d677 1
a677 1
	and	t0, t0, ta4			# compute result sign
d680 2
a681 2
	bne	ta5, zero, 2f			# is FT a denormalized num?
	beq	ta6, zero, result_fs_s		# FT is zero, result=FS
d689 2
a690 2
	subu	ta5, ta5, SEXP_BIAS		# unbias FT exponent
	or	ta6, ta6, SIMPL_ONE		# set implied one bit
d696 2
a697 2
	beq	t1, ta5, 4f			# no shift needed
	subu	v0, t1, ta5			# v0 = difference of exponents
d705 1
a705 1
	move	t1, ta5				# result exp is FTs
d709 1
a709 1
	move	ta6, zero			# FTs fraction shifted is zero
d715 1
a715 1
	move	t1, ta5				# FT > FS, result exp is FTs
d720 2
a721 2
	sll	t8, ta6, t9			# save bits shifted out
	srl	ta6, ta6, v1			# shift FTs fraction
d723 2
a724 2
	bne	t0, ta4, 1f			# if signs differ, subtract
	addu	t2, t2, ta6			# add fractions
d727 2
a728 2
	blt	t2, ta6, 3f			# subtract larger from smaller
	bne	t2, ta6, 2f			# if same, result=0
d733 1
a733 1
	or	t0, t0, ta4			# compute result sign
d736 1
a736 1
	and	t0, t0, ta4			# compute result sign
d739 1
a739 1
	sltu	t9, zero, t8			# compute t2:zero - ta6:t8
d741 1
a741 1
	subu	t2, t2, ta6			# subtract fractions
d745 2
a746 2
	move	t0, ta4				# sign of result = FTs
	sltu	t9, zero, t8			# compute ta6:zero - t2:t8
d748 1
a748 1
	subu	t2, ta6, t2			# subtract fractions
d757 1
a757 1
	xor	ta4, ta4, 1			# negate sign bit
d766 1
a766 1
	bne	ta5, DEXP_INF, result_fs_d	# if FT is not inf, result=FS
d769 3
a771 3
	bne	ta6, zero, result_ft_d		# if FT is NAN, result is FT
	bne	ta7, zero, result_ft_d
	bne	t0, ta4, invalid_d		# both infinities same sign?
d774 1
a774 1
	beq	ta5, DEXP_INF, result_ft_d	# if FT is inf, result=FT
d779 3
a781 3
	bne	ta5, zero, 2f			# is FT a denormalized num?
	bne	ta6, zero, 1f
	beq	ta7, zero, result_fs_d		# FT is zero, result=FS
d788 2
a789 2
	subu	ta5, ta5, DEXP_BIAS		# unbias FT exponent
	or	ta6, ta6, DIMPL_ONE		# set implied one bit
d792 3
a794 3
	bne	ta5, zero, result_ft_d		# if FT != 0, result=FT
	bne	ta6, zero, result_ft_d
	bne	ta7, zero, result_ft_d
d797 1
a797 1
	or	t0, t0, ta4			# compute result sign
d800 1
a800 1
	and	t0, t0, ta4			# compute result sign
d803 3
a805 3
	bne	ta5, zero, 2f			# is FT a denormalized num?
	bne	ta6, zero, 1f
	beq	ta7, zero, result_fs_d		# FT is zero, result=FS
d814 2
a815 2
	subu	ta5, ta5, DEXP_BIAS		# unbias FT exponent
	or	ta6, ta6, DIMPL_ONE		# set implied one bit
d821 2
a822 2
	beq	t1, ta5, 4f			# no shift needed
	subu	v0, t1, ta5			# v0 = difference of exponents
d830 1
a830 1
	move	t1, ta5				# result exp is FTs
d835 2
a836 2
	move	ta6, zero			# FTs fraction shifted is zero
	move	ta7, zero
d841 1
a841 1
	move	t1, ta5				# FT > FS, result exp is FTs
d863 3
a865 3
	sll	t8, ta6, t9			# save bits shifted out
	srl	ta7, ta6, v1			# shift FTs fraction
	move	ta6, zero
d869 5
a873 5
	sll	t8, ta7, t9			# save bits shifted out
	srl	ta7, ta7, v1			# shift FTs fraction
	sll	t9, ta6, t9			# save bits shifted out of t2
	or	ta7, ta7, t9			# and put into t3
	srl	ta6, ta6, v1
d875 4
a878 4
	bne	t0, ta4, 1f			# if signs differ, subtract
	addu	t3, t3, ta7			# add fractions
	sltu	t9, t3, ta7			# compute carry
	addu	t2, t2, ta6			# add fractions
d882 4
a885 4
	blt	t2, ta6, 3f			# subtract larger from smaller
	bne	t2, ta6, 2f
	bltu	t3, ta7, 3f
	bne	t3, ta7, 2f			# if same, result=0
d891 1
a891 1
	or	t0, t0, ta4			# compute result sign
d894 1
a894 1
	and	t0, t0, ta4			# compute result sign
d897 1
a897 1
	beq	t8, zero, 1f			# compute t2:t3:zero - ta6:ta7:t8
d903 3
a905 3
	sltu	v0, t3, ta7
	subu	t3, t3, ta7			# subtract fractions
	subu	t2, t2, ta6			# subtract fractions
d909 2
a910 2
	move	t0, ta4				# sign of result = FTs
	beq	t8, zero, 1f			# compute ta6:ta7:zero - t2:t3:t8
d912 7
a918 7
	sltu	v0, ta7, 1			# compute barrow out
	subu	ta7, ta7, 1			# subtract barrow
	subu	ta6, ta6, v0
1:
	sltu	v0, ta7, t3
	subu	t3, ta7, t3			# subtract fractions
	subu	t2, ta6, t2			# subtract fractions
d927 2
a928 2
	xor	t0, t0, ta4			# compute sign of result
	move	ta4, t0
d931 2
a932 2
	bne	ta5, SEXP_INF, 1f		# FS is inf, is FT an infinity?
	bne	ta6, zero, result_ft_s		# if FT is a NAN, result=FT
d935 2
a936 2
	bne	ta5, zero, result_fs_s		# inf * zero? if no, result=FS
	bne	ta6, zero, result_fs_s
d939 1
a939 1
	bne	ta5, SEXP_INF, 1f		# FS != inf, is FT an infinity?
d942 1
a942 1
	bne	ta6, zero, result_ft_s		# if FT is a NAN, result=FT
d953 2
a954 2
	bne	ta5, zero, 1f			# is FT zero?
	beq	ta6, zero, result_ft_s		# result is zero
d958 2
a959 2
	subu	ta5, ta5, SEXP_BIAS		# unbias FT exponent
	or	ta6, ta6, SIMPL_ONE		# set implied one bit
d961 1
a961 1
	addu	t1, t1, ta5			# compute result exponent
d963 1
a963 1
	multu	t2, ta6				# multiply fractions
d973 2
a974 2
	xor	t0, t0, ta4			# compute sign of result
	move	ta4, t0
d978 3
a980 3
	bne	ta5, DEXP_INF, 1f		# FS is inf, is FT an infinity?
	bne	ta6, zero, result_ft_d		# if FT is a NAN, result=FT
	bne	ta7, zero, result_ft_d
d983 3
a985 3
	bne	ta5, zero, result_fs_d		# inf * zero? if no, result=FS
	bne	ta6, zero, result_fs_d
	bne	ta7, zero, result_fs_d
d988 1
a988 1
	bne	ta5, DEXP_INF, 1f		# FS != inf, is FT an infinity?
d992 2
a993 2
	bne	ta6, zero, result_ft_d		# if FT is a NAN, result=FT
	bne	ta7, zero, result_ft_d
d1006 3
a1008 3
	bne	ta5, zero, 2f			# is FT zero?
	bne	ta6, zero, 1f
	beq	ta7, zero, result_ft_d		# result is zero
d1013 2
a1014 2
	subu	ta5, ta5, DEXP_BIAS		# unbias FT exponent
	or	ta6, ta6, DIMPL_ONE		# set implied one bit
d1016 1
a1016 1
	addu	t1, t1, ta5			# compute result exponent
d1018 3
a1020 3
	multu	t3, ta7				# multiply fractions (low * low)
	move	ta4, t2				# free up t2,t3 for result
	move	ta5, t3
d1024 1
a1024 1
	multu	ta4, ta7				# multiply FS(high) * FT(low)
d1029 1
a1029 1
	multu	ta5, ta6				# multiply FS(low) * FT(high)
d1036 1
a1036 1
	multu	ta4, ta6				# multiply FS(high) * FT(high)
d1057 2
a1058 2
	xor	t0, t0, ta4			# compute sign of result
	move	ta4, t0
d1061 2
a1062 2
	bne	ta5, SEXP_INF, result_fs_s	# is FT an infinity?
	bne	ta6, zero, result_ft_s		# if FT is NAN, result is FT
d1065 2
a1066 2
	bne	ta5, SEXP_INF, 1f		# is FT an infinity?
	bne	ta6, zero, result_ft_s		# if FT is NAN, result is FT
d1073 2
a1074 2
	bne	ta5, zero, result_fs_s		# FS=zero, is FT zero?
	beq	ta6, zero, invalid_s		# 0 / 0
d1083 2
a1084 2
	bne	ta5, zero, 2f			# is FT zero?
	bne	ta6, zero, 1f
d1096 2
a1097 2
	subu	ta5, ta5, SEXP_BIAS		# unbias FT exponent
	or	ta6, ta6, SIMPL_ONE		# set implied one bit
d1099 1
a1099 1
	subu	t1, t1, ta5			# compute exponent
d1105 1
a1105 1
	bltu	t8, ta6, 3f			# is dividend >= divisor?
d1107 1
a1107 1
	subu	t8, t8, ta6			# subtract divisor from dividend
d1124 2
a1125 2
	xor	t0, t0, ta4			# compute sign of result
	move	ta4, t0
d1129 3
a1131 3
	bne	ta5, DEXP_INF, result_fs_d	# is FT an infinity?
	bne	ta6, zero, result_ft_d		# if FT is NAN, result is FT
	bne	ta7, zero, result_ft_d
d1134 3
a1136 3
	bne	ta5, DEXP_INF, 1f		# is FT an infinity?
	bne	ta6, zero, result_ft_d		# if FT is NAN, result is FT
	bne	ta7, zero, result_ft_d
d1145 3
a1147 3
	bne	ta5, zero, result_fs_d		# FS=zero, is FT zero?
	bne	ta6, zero, result_fs_d
	beq	ta7, zero, invalid_d		# 0 / 0
d1156 3
a1158 3
	bne	ta5, zero, 2f			# is FT zero?
	bne	ta6, zero, 1f
	bne	ta7, zero, 1f
d1171 2
a1172 2
	subu	ta5, ta5, DEXP_BIAS		# unbias FT exponent
	or	ta6, ta6, DIMPL_ONE		# set implied one bit
d1174 1
a1174 1
	subu	t1, t1, ta5			# compute exponent
d1182 7
a1188 7
	bltu	t8, ta6, 3f			# is dividend >= divisor?
	bne	t8, ta6, 2f
	bltu	t9, ta7, 3f
2:
	sltu	v1, t9, ta7			# subtract divisor from dividend
	subu	t9, t9, ta7
	subu	t8, t8, ta6
d1583 2
a1584 2
	bne	ta5, SEXP_INF, 2f		# is FT an infinity?
	bne	ta6, zero, unordered		# FT is a NAN
d1588 2
a1589 2
	sll	ta5, ta5, 23			# reassemble exp & frac
	or	ta5, ta5, ta6
d1593 2
a1594 2
	beq	ta4, zero, 1f			# is FT positive?
	negu	ta5
d1597 1
a1597 1
	blt	t1, ta5, test_cond		# is FS < FT?
d1599 1
a1599 1
	beq	t1, ta5, test_cond		# is FS == FT?
d1612 3
a1614 3
	bne	ta5, DEXP_INF, 2f		# is FT an infinity?
	bne	ta6, zero, unordered
	bne	ta7, zero, unordered		# FT is a NAN
d1618 2
a1619 2
	sll	ta5, ta5, 20			# reassemble exp & frac
	or	ta5, ta5, ta6
d1627 6
a1632 6
	beq	ta4, zero, 1f			# is FT positive?
	not	ta7				# negate ta5,ta7
	not	ta5
	addu	ta7, ta7, 1
	seq	v0, ta7, zero			# compute carry
	addu	ta5, ta5, v0
d1635 1
a1635 1
	blt	t1, ta5, test_cond		# is FS(MSW) < FT(MSW)?
d1637 1
a1637 1
	bne	t1, ta5, test_cond		# is FS(MSW) > FT(MSW)?
d1639 1
a1639 1
	bltu	t3, ta7, test_cond		# is FS(LSW) < FT(LSW)?
d1641 1
a1641 1
	beq	t3, ta7, test_cond		# is FS(LSW) == FT(LSW)?
d1732 2
a1733 2
	move	ta5, t1				# save unrounded exponent
	move	ta6, t2				# save unrounded fraction
d1833 2
a1834 2
	move	t1, ta5				# get unrounded exponent
	move	t2, ta6				# get unrounded fraction
d1977 3
a1979 3
	move	ta5, t1				# save unrounded exponent
	move	ta6, t2				# save unrounded fraction (MS)
	move	ta7, t3				# save unrounded fraction (LS)
d2085 3
a2087 3
	move	t1, ta5				# get unrounded exponent
	move	t2, ta6				# get unrounded fraction (MS)
	move	t3, ta7				# get unrounded fraction (LS)
d2236 3
a2238 3
	move	t0, ta4				# result is FT
	move	t1, ta5
	move	t2, ta6
d2248 4
a2251 4
	move	t0, ta4				# result is FT
	move	t1, ta5
	move	t2, ta6
	move	t3, ta7
d2367 3
a2369 3
 *	ta4	contains the FT sign
 *	ta5	contains the FT (biased) exponent
 *	ta6	contains the FT fraction
d2400 1
a2400 1
	mfc1	ta4, $f0
d2403 1
a2403 1
	mfc1	ta4, $f2
d2406 1
a2406 1
	mfc1	ta4, $f4
d2409 1
a2409 1
	mfc1	ta4, $f6
d2412 1
a2412 1
	mfc1	ta4, $f8
d2415 1
a2415 1
	mfc1	ta4, $f10
d2418 1
a2418 1
	mfc1	ta4, $f12
d2421 1
a2421 1
	mfc1	ta4, $f14
d2424 1
a2424 1
	mfc1	ta4, $f16
d2427 1
a2427 1
	mfc1	ta4, $f18
d2430 1
a2430 1
	mfc1	ta4, $f20
d2433 1
a2433 1
	mfc1	ta4, $f22
d2436 1
a2436 1
	mfc1	ta4, $f24
d2439 1
a2439 1
	mfc1	ta4, $f26
d2442 1
a2442 1
	mfc1	ta4, $f28
d2445 1
a2445 1
	mfc1	ta4, $f30
d2447 6
a2452 6
	srl	ta5, ta4, 23			# get exponent
	and	ta5, ta5, 0xFF
	and	ta6, ta4, 0x7FFFFF		# get fraction
	srl	ta4, ta4, 31			# get sign
	bne	ta5, SEXP_INF, 1f		# is it a signaling NAN?
	and	v0, ta6, SSIGNAL_NAN
d2568 4
a2571 4
 *	ta4	contains the FT sign
 *	ta5	contains the FT (biased) exponent
 *	ta6	contains the FT fraction
 *	ta7	contains the FT remaining fraction
d2602 2
a2603 2
	mfc1	ta7, $f0
	mfc1	ta4, $f1
d2606 2
a2607 2
	mfc1	ta7, $f2
	mfc1	ta4, $f3
d2610 2
a2611 2
	mfc1	ta7, $f4
	mfc1	ta4, $f5
d2614 2
a2615 2
	mfc1	ta7, $f6
	mfc1	ta4, $f7
d2618 2
a2619 2
	mfc1	ta7, $f8
	mfc1	ta4, $f9
d2622 2
a2623 2
	mfc1	ta7, $f10
	mfc1	ta4, $f11
d2626 2
a2627 2
	mfc1	ta7, $f12
	mfc1	ta4, $f13
d2630 2
a2631 2
	mfc1	ta7, $f14
	mfc1	ta4, $f15
d2634 2
a2635 2
	mfc1	ta7, $f16
	mfc1	ta4, $f17
d2638 2
a2639 2
	mfc1	ta7, $f18
	mfc1	ta4, $f19
d2642 2
a2643 2
	mfc1	ta7, $f20
	mfc1	ta4, $f21
d2646 2
a2647 2
	mfc1	ta7, $f22
	mfc1	ta4, $f23
d2650 2
a2651 2
	mfc1	ta7, $f24
	mfc1	ta4, $f25
d2654 2
a2655 2
	mfc1	ta7, $f26
	mfc1	ta4, $f27
d2658 2
a2659 2
	mfc1	ta7, $f28
	mfc1	ta4, $f29
d2662 2
a2663 2
	mfc1	ta7, $f30
	mfc1	ta4, $f31
d2665 6
a2670 6
	srl	ta5, ta4, 20			# get exponent
	and	ta5, ta5, 0x7FF
	and	ta6, ta4, 0xFFFFF			# get fraction
	srl	ta4, ta4, 31			# get sign
	bne	ta5, DEXP_INF, 1f		# is it a signaling NAN?
	and	v0, ta6, DSIGNAL_NAN
d2802 3
a2804 3
 *	ta4	contains the sign
 *	ta5	contains the (biased) exponent
 *	ta6	contains the fraction
d2913 1
a2913 1
	mfc1	ta4, $f0
d2916 1
a2916 1
	mfc1	ta4, $f2
d2919 1
a2919 1
	mfc1	ta4, $f4
d2922 1
a2922 1
	mfc1	ta4, $f6
d2925 1
a2925 1
	mfc1	ta4, $f8
d2928 1
a2928 1
	mfc1	ta4, $f10
d2931 1
a2931 1
	mfc1	ta4, $f12
d2934 1
a2934 1
	mfc1	ta4, $f14
d2937 1
a2937 1
	mfc1	ta4, $f16
d2940 1
a2940 1
	mfc1	ta4, $f18
d2943 1
a2943 1
	mfc1	ta4, $f20
d2946 1
a2946 1
	mfc1	ta4, $f22
d2949 1
a2949 1
	mfc1	ta4, $f24
d2952 1
a2952 1
	mfc1	ta4, $f26
d2955 1
a2955 1
	mfc1	ta4, $f28
d2958 1
a2958 1
	mfc1	ta4, $f30
d2960 4
a2963 4
	srl	ta5, ta4, 23			# get exponent
	and	ta5, ta5, 0xFF
	and	ta6, ta4, 0x7FFFFF		# get fraction
	srl	ta4, ta4, 31			# get sign
d2979 4
a2982 4
 *	ta4	contains the sign
 *	ta5	contains the (biased) exponent
 *	ta6	contains the fraction
 *	ta7	contains the remaining fraction
d3107 2
a3108 2
	mfc1	ta7, $f0
	mfc1	ta4, $f1
d3111 2
a3112 2
	mfc1	ta7, $f2
	mfc1	ta4, $f3
d3115 2
a3116 2
	mfc1	ta7, $f4
	mfc1	ta4, $f5
d3119 2
a3120 2
	mfc1	ta7, $f6
	mfc1	ta4, $f7
d3123 2
a3124 2
	mfc1	ta7, $f8
	mfc1	ta4, $f9
d3127 2
a3128 2
	mfc1	ta7, $f10
	mfc1	ta4, $f11
d3131 2
a3132 2
	mfc1	ta7, $f12
	mfc1	ta4, $f13
d3135 2
a3136 2
	mfc1	ta7, $f14
	mfc1	ta4, $f15
d3139 2
a3140 2
	mfc1	ta7, $f16
	mfc1	ta4, $f17
d3143 2
a3144 2
	mfc1	ta7, $f18
	mfc1	ta4, $f19
d3147 2
a3148 2
	mfc1	ta7, $f20
	mfc1	ta4, $f21
d3151 2
a3152 2
	mfc1	ta7, $f22
	mfc1	ta4, $f23
d3155 2
a3156 2
	mfc1	ta7, $f24
	mfc1	ta4, $f25
d3159 2
a3160 2
	mfc1	ta7, $f26
	mfc1	ta4, $f27
d3163 2
a3164 2
	mfc1	ta7, $f28
	mfc1	ta4, $f29
d3167 2
a3168 2
	mfc1	ta7, $f30
	mfc1	ta4, $f31
d3170 4
a3173 4
	srl	ta5, ta4, 20			# get exponent
	and	ta5, ta5, 0x7FF
	and	ta6, ta4, 0xFFFFF			# get fraction
	srl	ta4, ta4, 31			# get sign
d3509 2
a3510 2
 *	ta5	unbiased exponent
 *	ta6	normalized fraction
d3516 1
a3516 1
 * Find out how many leading zero bits are in ta6 and put in t9.
d3518 1
a3518 1
	move	v0, ta6
d3544 1
a3544 1
 * Now shift ta6 the correct number of bits.
d3548 3
a3550 3
	li	ta5, SEXP_MIN
	subu	ta5, ta5, t9		# adjust exponent
	sll	ta6, ta6, t9
d3558 2
a3559 2
 *	ta5	unbiased exponent
 *	ta6,ta7	normalized fraction
d3565 1
a3565 1
 * Find out how many leading zero bits are in ta6,ta7 and put in t9.
d3567 1
a3567 1
	move	v0, ta6
d3569 2
a3570 2
	bne	ta6, zero, 1f
	move	v0, ta7
d3597 1
a3597 1
 * Now shift ta6,ta7 the correct number of bits.
d3601 2
a3602 2
	li	ta5, DEXP_MIN
	subu	ta5, ta5, t9		# adjust exponent
d3606 2
a3607 2
	sll	ta6, ta7, t9
	move	ta7, zero
d3611 4
a3614 4
	sll	ta6, ta6, t9
	srl	v1, ta7, v0
	or	ta6, ta6, v1
	sll	ta7, ta7, t9
@


1.3
log
@Kernel moves to 64 bit. A few more tweaks when binutils is updated.
@
text
@d1 1
a1 1
/*	$OpenBSD: fp.S,v 1.2 2004/08/15 18:35:58 pefo Exp $	*/
d38 1
a38 1
 *      $Id: fp.S,v 1.2 2004/08/15 18:35:58 pefo Exp $
d2275 1
a2275 1
LEAF(get_fs_int)
d2373 1
a2373 1
LEAF(get_ft_fs_s)
d2575 1
a2575 1
LEAF(get_ft_fs_d)
d2808 1
a2808 1
LEAF(get_cmp_s)
d2986 1
a2986 1
LEAF(get_cmp_d)
d3200 1
a3200 1
LEAF(set_fd_s)
d3296 1
a3296 1
LEAF(set_fd_d)
d3401 1
a3401 1
LEAF(renorm_fs_s)
d3450 1
a3450 1
LEAF(renorm_fs_d)
d3514 1
a3514 1
LEAF(renorm_ft_s)
d3563 1
a3563 1
LEAF(renorm_ft_d)
@


1.2
log
@gracefully handle FP traps
@
text
@d1 1
a1 1
/*	$OpenBSD: fp.S,v 1.1 2004/08/06 20:56:03 pefo Exp $	*/
d38 1
a38 1
 *      $Id: fp.S,v 1.1 2004/08/06 20:56:03 pefo Exp $
d641 1
a641 1
	xor	t4, t4, 1			# negate FT sign bit
d650 1
a650 1
	bne	t5, SEXP_INF, result_fs_s	# if FT is not inf, result=FS
d652 2
a653 2
	bne	t6, zero, result_ft_s		# if FT is NAN, result is FT
	bne	t0, t4, invalid_s		# both infinities same sign?
d656 1
a656 1
	beq	t5, SEXP_INF, result_ft_s	# if FT is inf, result=FT
d659 2
a660 2
	bne	t5, zero, 2f			# is FT a denormalized num?
	beq	t6, zero, result_fs_s		# FT is zero, result=FS
d666 2
a667 2
	subu	t5, t5, SEXP_BIAS		# unbias FT exponent
	or	t6, t6, SIMPL_ONE		# set implied one bit
d670 2
a671 2
	bne	t5, zero, result_ft_s		# if FT != 0, result=FT
	bne	t6, zero, result_ft_s
d674 1
a674 1
	or	t0, t0, t4			# compute result sign
d677 1
a677 1
	and	t0, t0, t4			# compute result sign
d680 2
a681 2
	bne	t5, zero, 2f			# is FT a denormalized num?
	beq	t6, zero, result_fs_s		# FT is zero, result=FS
d689 2
a690 2
	subu	t5, t5, SEXP_BIAS		# unbias FT exponent
	or	t6, t6, SIMPL_ONE		# set implied one bit
d696 2
a697 2
	beq	t1, t5, 4f			# no shift needed
	subu	v0, t1, t5			# v0 = difference of exponents
d705 1
a705 1
	move	t1, t5				# result exp is FTs
d709 1
a709 1
	move	t6, zero			# FTs fraction shifted is zero
d715 1
a715 1
	move	t1, t5				# FT > FS, result exp is FTs
d720 2
a721 2
	sll	t8, t6, t9			# save bits shifted out
	srl	t6, t6, v1			# shift FTs fraction
d723 2
a724 2
	bne	t0, t4, 1f			# if signs differ, subtract
	addu	t2, t2, t6			# add fractions
d727 2
a728 2
	blt	t2, t6, 3f			# subtract larger from smaller
	bne	t2, t6, 2f			# if same, result=0
d733 1
a733 1
	or	t0, t0, t4			# compute result sign
d736 1
a736 1
	and	t0, t0, t4			# compute result sign
d739 1
a739 1
	sltu	t9, zero, t8			# compute t2:zero - t6:t8
d741 1
a741 1
	subu	t2, t2, t6			# subtract fractions
d745 2
a746 2
	move	t0, t4				# sign of result = FTs
	sltu	t9, zero, t8			# compute t6:zero - t2:t8
d748 1
a748 1
	subu	t2, t6, t2			# subtract fractions
d757 1
a757 1
	xor	t4, t4, 1			# negate sign bit
d766 1
a766 1
	bne	t5, DEXP_INF, result_fs_d	# if FT is not inf, result=FS
d769 3
a771 3
	bne	t6, zero, result_ft_d		# if FT is NAN, result is FT
	bne	t7, zero, result_ft_d
	bne	t0, t4, invalid_d		# both infinities same sign?
d774 1
a774 1
	beq	t5, DEXP_INF, result_ft_d	# if FT is inf, result=FT
d779 3
a781 3
	bne	t5, zero, 2f			# is FT a denormalized num?
	bne	t6, zero, 1f
	beq	t7, zero, result_fs_d		# FT is zero, result=FS
d788 2
a789 2
	subu	t5, t5, DEXP_BIAS		# unbias FT exponent
	or	t6, t6, DIMPL_ONE		# set implied one bit
d792 3
a794 3
	bne	t5, zero, result_ft_d		# if FT != 0, result=FT
	bne	t6, zero, result_ft_d
	bne	t7, zero, result_ft_d
d797 1
a797 1
	or	t0, t0, t4			# compute result sign
d800 1
a800 1
	and	t0, t0, t4			# compute result sign
d803 3
a805 3
	bne	t5, zero, 2f			# is FT a denormalized num?
	bne	t6, zero, 1f
	beq	t7, zero, result_fs_d		# FT is zero, result=FS
d814 2
a815 2
	subu	t5, t5, DEXP_BIAS		# unbias FT exponent
	or	t6, t6, DIMPL_ONE		# set implied one bit
d821 2
a822 2
	beq	t1, t5, 4f			# no shift needed
	subu	v0, t1, t5			# v0 = difference of exponents
d830 1
a830 1
	move	t1, t5				# result exp is FTs
d835 2
a836 2
	move	t6, zero			# FTs fraction shifted is zero
	move	t7, zero
d841 1
a841 1
	move	t1, t5				# FT > FS, result exp is FTs
d863 3
a865 3
	sll	t8, t6, t9			# save bits shifted out
	srl	t7, t6, v1			# shift FTs fraction
	move	t6, zero
d869 5
a873 5
	sll	t8, t7, t9			# save bits shifted out
	srl	t7, t7, v1			# shift FTs fraction
	sll	t9, t6, t9			# save bits shifted out of t2
	or	t7, t7, t9			# and put into t3
	srl	t6, t6, v1
d875 4
a878 4
	bne	t0, t4, 1f			# if signs differ, subtract
	addu	t3, t3, t7			# add fractions
	sltu	t9, t3, t7			# compute carry
	addu	t2, t2, t6			# add fractions
d882 4
a885 4
	blt	t2, t6, 3f			# subtract larger from smaller
	bne	t2, t6, 2f
	bltu	t3, t7, 3f
	bne	t3, t7, 2f			# if same, result=0
d891 1
a891 1
	or	t0, t0, t4			# compute result sign
d894 1
a894 1
	and	t0, t0, t4			# compute result sign
d897 1
a897 1
	beq	t8, zero, 1f			# compute t2:t3:zero - t6:t7:t8
d903 3
a905 3
	sltu	v0, t3, t7
	subu	t3, t3, t7			# subtract fractions
	subu	t2, t2, t6			# subtract fractions
d909 2
a910 2
	move	t0, t4				# sign of result = FTs
	beq	t8, zero, 1f			# compute t6:t7:zero - t2:t3:t8
d912 7
a918 7
	sltu	v0, t7, 1			# compute barrow out
	subu	t7, t7, 1			# subtract barrow
	subu	t6, t6, v0
1:
	sltu	v0, t7, t3
	subu	t3, t7, t3			# subtract fractions
	subu	t2, t6, t2			# subtract fractions
d927 2
a928 2
	xor	t0, t0, t4			# compute sign of result
	move	t4, t0
d931 2
a932 2
	bne	t5, SEXP_INF, 1f		# FS is inf, is FT an infinity?
	bne	t6, zero, result_ft_s		# if FT is a NAN, result=FT
d935 2
a936 2
	bne	t5, zero, result_fs_s		# inf * zero? if no, result=FS
	bne	t6, zero, result_fs_s
d939 1
a939 1
	bne	t5, SEXP_INF, 1f		# FS != inf, is FT an infinity?
d942 1
a942 1
	bne	t6, zero, result_ft_s		# if FT is a NAN, result=FT
d953 2
a954 2
	bne	t5, zero, 1f			# is FT zero?
	beq	t6, zero, result_ft_s		# result is zero
d958 2
a959 2
	subu	t5, t5, SEXP_BIAS		# unbias FT exponent
	or	t6, t6, SIMPL_ONE		# set implied one bit
d961 1
a961 1
	addu	t1, t1, t5			# compute result exponent
d963 1
a963 1
	multu	t2, t6				# multiply fractions
d973 2
a974 2
	xor	t0, t0, t4			# compute sign of result
	move	t4, t0
d978 3
a980 3
	bne	t5, DEXP_INF, 1f		# FS is inf, is FT an infinity?
	bne	t6, zero, result_ft_d		# if FT is a NAN, result=FT
	bne	t7, zero, result_ft_d
d983 3
a985 3
	bne	t5, zero, result_fs_d		# inf * zero? if no, result=FS
	bne	t6, zero, result_fs_d
	bne	t7, zero, result_fs_d
d988 1
a988 1
	bne	t5, DEXP_INF, 1f		# FS != inf, is FT an infinity?
d992 2
a993 2
	bne	t6, zero, result_ft_d		# if FT is a NAN, result=FT
	bne	t7, zero, result_ft_d
d1006 3
a1008 3
	bne	t5, zero, 2f			# is FT zero?
	bne	t6, zero, 1f
	beq	t7, zero, result_ft_d		# result is zero
d1013 2
a1014 2
	subu	t5, t5, DEXP_BIAS		# unbias FT exponent
	or	t6, t6, DIMPL_ONE		# set implied one bit
d1016 1
a1016 1
	addu	t1, t1, t5			# compute result exponent
d1018 3
a1020 3
	multu	t3, t7				# multiply fractions (low * low)
	move	t4, t2				# free up t2,t3 for result
	move	t5, t3
d1024 1
a1024 1
	multu	t4, t7				# multiply FS(high) * FT(low)
d1029 1
a1029 1
	multu	t5, t6				# multiply FS(low) * FT(high)
d1036 1
a1036 1
	multu	t4, t6				# multiply FS(high) * FT(high)
d1057 2
a1058 2
	xor	t0, t0, t4			# compute sign of result
	move	t4, t0
d1061 2
a1062 2
	bne	t5, SEXP_INF, result_fs_s	# is FT an infinity?
	bne	t6, zero, result_ft_s		# if FT is NAN, result is FT
d1065 2
a1066 2
	bne	t5, SEXP_INF, 1f		# is FT an infinity?
	bne	t6, zero, result_ft_s		# if FT is NAN, result is FT
d1073 2
a1074 2
	bne	t5, zero, result_fs_s		# FS=zero, is FT zero?
	beq	t6, zero, invalid_s		# 0 / 0
d1083 2
a1084 2
	bne	t5, zero, 2f			# is FT zero?
	bne	t6, zero, 1f
d1096 2
a1097 2
	subu	t5, t5, SEXP_BIAS		# unbias FT exponent
	or	t6, t6, SIMPL_ONE		# set implied one bit
d1099 1
a1099 1
	subu	t1, t1, t5			# compute exponent
d1105 1
a1105 1
	bltu	t8, t6, 3f			# is dividend >= divisor?
d1107 1
a1107 1
	subu	t8, t8, t6			# subtract divisor from dividend
d1124 2
a1125 2
	xor	t0, t0, t4			# compute sign of result
	move	t4, t0
d1129 3
a1131 3
	bne	t5, DEXP_INF, result_fs_d	# is FT an infinity?
	bne	t6, zero, result_ft_d		# if FT is NAN, result is FT
	bne	t7, zero, result_ft_d
d1134 3
a1136 3
	bne	t5, DEXP_INF, 1f		# is FT an infinity?
	bne	t6, zero, result_ft_d		# if FT is NAN, result is FT
	bne	t7, zero, result_ft_d
d1145 3
a1147 3
	bne	t5, zero, result_fs_d		# FS=zero, is FT zero?
	bne	t6, zero, result_fs_d
	beq	t7, zero, invalid_d		# 0 / 0
d1156 3
a1158 3
	bne	t5, zero, 2f			# is FT zero?
	bne	t6, zero, 1f
	bne	t7, zero, 1f
d1171 2
a1172 2
	subu	t5, t5, DEXP_BIAS		# unbias FT exponent
	or	t6, t6, DIMPL_ONE		# set implied one bit
d1174 1
a1174 1
	subu	t1, t1, t5			# compute exponent
d1182 7
a1188 7
	bltu	t8, t6, 3f			# is dividend >= divisor?
	bne	t8, t6, 2f
	bltu	t9, t7, 3f
2:
	sltu	v1, t9, t7			# subtract divisor from dividend
	subu	t9, t9, t7
	subu	t8, t8, t6
d1583 2
a1584 2
	bne	t5, SEXP_INF, 2f		# is FT an infinity?
	bne	t6, zero, unordered		# FT is a NAN
d1588 2
a1589 2
	sll	t5, t5, 23			# reassemble exp & frac
	or	t5, t5, t6
d1593 2
a1594 2
	beq	t4, zero, 1f			# is FT positive?
	negu	t5
d1597 1
a1597 1
	blt	t1, t5, test_cond		# is FS < FT?
d1599 1
a1599 1
	beq	t1, t5, test_cond		# is FS == FT?
d1612 3
a1614 3
	bne	t5, DEXP_INF, 2f		# is FT an infinity?
	bne	t6, zero, unordered
	bne	t7, zero, unordered		# FT is a NAN
d1618 2
a1619 2
	sll	t5, t5, 20			# reassemble exp & frac
	or	t5, t5, t6
d1627 6
a1632 6
	beq	t4, zero, 1f			# is FT positive?
	not	t7				# negate t5,t7
	not	t5
	addu	t7, t7, 1
	seq	v0, t7, zero			# compute carry
	addu	t5, t5, v0
d1635 1
a1635 1
	blt	t1, t5, test_cond		# is FS(MSW) < FT(MSW)?
d1637 1
a1637 1
	bne	t1, t5, test_cond		# is FS(MSW) > FT(MSW)?
d1639 1
a1639 1
	bltu	t3, t7, test_cond		# is FS(LSW) < FT(LSW)?
d1641 1
a1641 1
	beq	t3, t7, test_cond		# is FS(LSW) == FT(LSW)?
d1732 2
a1733 2
	move	t5, t1				# save unrounded exponent
	move	t6, t2				# save unrounded fraction
d1833 2
a1834 2
	move	t1, t5				# get unrounded exponent
	move	t2, t6				# get unrounded fraction
d1977 3
a1979 3
	move	t5, t1				# save unrounded exponent
	move	t6, t2				# save unrounded fraction (MS)
	move	t7, t3				# save unrounded fraction (LS)
d2085 3
a2087 3
	move	t1, t5				# get unrounded exponent
	move	t2, t6				# get unrounded fraction (MS)
	move	t3, t7				# get unrounded fraction (LS)
d2236 3
a2238 3
	move	t0, t4				# result is FT
	move	t1, t5
	move	t2, t6
d2248 4
a2251 4
	move	t0, t4				# result is FT
	move	t1, t5
	move	t2, t6
	move	t3, t7
d2367 3
a2369 3
 *	t4	contains the FT sign
 *	t5	contains the FT (biased) exponent
 *	t6	contains the FT fraction
d2400 1
a2400 1
	mfc1	t4, $f0
d2403 1
a2403 1
	mfc1	t4, $f2
d2406 1
a2406 1
	mfc1	t4, $f4
d2409 1
a2409 1
	mfc1	t4, $f6
d2412 1
a2412 1
	mfc1	t4, $f8
d2415 1
a2415 1
	mfc1	t4, $f10
d2418 1
a2418 1
	mfc1	t4, $f12
d2421 1
a2421 1
	mfc1	t4, $f14
d2424 1
a2424 1
	mfc1	t4, $f16
d2427 1
a2427 1
	mfc1	t4, $f18
d2430 1
a2430 1
	mfc1	t4, $f20
d2433 1
a2433 1
	mfc1	t4, $f22
d2436 1
a2436 1
	mfc1	t4, $f24
d2439 1
a2439 1
	mfc1	t4, $f26
d2442 1
a2442 1
	mfc1	t4, $f28
d2445 1
a2445 1
	mfc1	t4, $f30
d2447 6
a2452 6
	srl	t5, t4, 23			# get exponent
	and	t5, t5, 0xFF
	and	t6, t4, 0x7FFFFF		# get fraction
	srl	t4, t4, 31			# get sign
	bne	t5, SEXP_INF, 1f		# is it a signaling NAN?
	and	v0, t6, SSIGNAL_NAN
d2568 4
a2571 4
 *	t4	contains the FT sign
 *	t5	contains the FT (biased) exponent
 *	t6	contains the FT fraction
 *	t7	contains the FT remaining fraction
d2602 2
a2603 2
	mfc1	t7, $f0
	mfc1	t4, $f1
d2606 2
a2607 2
	mfc1	t7, $f2
	mfc1	t4, $f3
d2610 2
a2611 2
	mfc1	t7, $f4
	mfc1	t4, $f5
d2614 2
a2615 2
	mfc1	t7, $f6
	mfc1	t4, $f7
d2618 2
a2619 2
	mfc1	t7, $f8
	mfc1	t4, $f9
d2622 2
a2623 2
	mfc1	t7, $f10
	mfc1	t4, $f11
d2626 2
a2627 2
	mfc1	t7, $f12
	mfc1	t4, $f13
d2630 2
a2631 2
	mfc1	t7, $f14
	mfc1	t4, $f15
d2634 2
a2635 2
	mfc1	t7, $f16
	mfc1	t4, $f17
d2638 2
a2639 2
	mfc1	t7, $f18
	mfc1	t4, $f19
d2642 2
a2643 2
	mfc1	t7, $f20
	mfc1	t4, $f21
d2646 2
a2647 2
	mfc1	t7, $f22
	mfc1	t4, $f23
d2650 2
a2651 2
	mfc1	t7, $f24
	mfc1	t4, $f25
d2654 2
a2655 2
	mfc1	t7, $f26
	mfc1	t4, $f27
d2658 2
a2659 2
	mfc1	t7, $f28
	mfc1	t4, $f29
d2662 2
a2663 2
	mfc1	t7, $f30
	mfc1	t4, $f31
d2665 6
a2670 6
	srl	t5, t4, 20			# get exponent
	and	t5, t5, 0x7FF
	and	t6, t4, 0xFFFFF			# get fraction
	srl	t4, t4, 31			# get sign
	bne	t5, DEXP_INF, 1f		# is it a signaling NAN?
	and	v0, t6, DSIGNAL_NAN
d2802 3
a2804 3
 *	t4	contains the sign
 *	t5	contains the (biased) exponent
 *	t6	contains the fraction
d2913 1
a2913 1
	mfc1	t4, $f0
d2916 1
a2916 1
	mfc1	t4, $f2
d2919 1
a2919 1
	mfc1	t4, $f4
d2922 1
a2922 1
	mfc1	t4, $f6
d2925 1
a2925 1
	mfc1	t4, $f8
d2928 1
a2928 1
	mfc1	t4, $f10
d2931 1
a2931 1
	mfc1	t4, $f12
d2934 1
a2934 1
	mfc1	t4, $f14
d2937 1
a2937 1
	mfc1	t4, $f16
d2940 1
a2940 1
	mfc1	t4, $f18
d2943 1
a2943 1
	mfc1	t4, $f20
d2946 1
a2946 1
	mfc1	t4, $f22
d2949 1
a2949 1
	mfc1	t4, $f24
d2952 1
a2952 1
	mfc1	t4, $f26
d2955 1
a2955 1
	mfc1	t4, $f28
d2958 1
a2958 1
	mfc1	t4, $f30
d2960 4
a2963 4
	srl	t5, t4, 23			# get exponent
	and	t5, t5, 0xFF
	and	t6, t4, 0x7FFFFF		# get fraction
	srl	t4, t4, 31			# get sign
d2979 4
a2982 4
 *	t4	contains the sign
 *	t5	contains the (biased) exponent
 *	t6	contains the fraction
 *	t7	contains the remaining fraction
d3107 2
a3108 2
	mfc1	t7, $f0
	mfc1	t4, $f1
d3111 2
a3112 2
	mfc1	t7, $f2
	mfc1	t4, $f3
d3115 2
a3116 2
	mfc1	t7, $f4
	mfc1	t4, $f5
d3119 2
a3120 2
	mfc1	t7, $f6
	mfc1	t4, $f7
d3123 2
a3124 2
	mfc1	t7, $f8
	mfc1	t4, $f9
d3127 2
a3128 2
	mfc1	t7, $f10
	mfc1	t4, $f11
d3131 2
a3132 2
	mfc1	t7, $f12
	mfc1	t4, $f13
d3135 2
a3136 2
	mfc1	t7, $f14
	mfc1	t4, $f15
d3139 2
a3140 2
	mfc1	t7, $f16
	mfc1	t4, $f17
d3143 2
a3144 2
	mfc1	t7, $f18
	mfc1	t4, $f19
d3147 2
a3148 2
	mfc1	t7, $f20
	mfc1	t4, $f21
d3151 2
a3152 2
	mfc1	t7, $f22
	mfc1	t4, $f23
d3155 2
a3156 2
	mfc1	t7, $f24
	mfc1	t4, $f25
d3159 2
a3160 2
	mfc1	t7, $f26
	mfc1	t4, $f27
d3163 2
a3164 2
	mfc1	t7, $f28
	mfc1	t4, $f29
d3167 2
a3168 2
	mfc1	t7, $f30
	mfc1	t4, $f31
d3170 4
a3173 4
	srl	t5, t4, 20			# get exponent
	and	t5, t5, 0x7FF
	and	t6, t4, 0xFFFFF			# get fraction
	srl	t4, t4, 31			# get sign
d3509 2
a3510 2
 *	t5	unbiased exponent
 *	t6	normalized fraction
d3516 1
a3516 1
 * Find out how many leading zero bits are in t6 and put in t9.
d3518 1
a3518 1
	move	v0, t6
d3544 1
a3544 1
 * Now shift t6 the correct number of bits.
d3548 3
a3550 3
	li	t5, SEXP_MIN
	subu	t5, t5, t9		# adjust exponent
	sll	t6, t6, t9
d3558 2
a3559 2
 *	t5	unbiased exponent
 *	t6,t7	normalized fraction
d3565 1
a3565 1
 * Find out how many leading zero bits are in t6,t7 and put in t9.
d3567 1
a3567 1
	move	v0, t6
d3569 2
a3570 2
	bne	t6, zero, 1f
	move	v0, t7
d3597 1
a3597 1
 * Now shift t6,t7 the correct number of bits.
d3601 2
a3602 2
	li	t5, DEXP_MIN
	subu	t5, t5, t9		# adjust exponent
d3606 2
a3607 2
	sll	t6, t7, t9
	move	t7, zero
d3611 4
a3614 4
	sll	t6, t6, t9
	srl	v1, t7, v0
	or	t6, t6, v1
	sll	t7, t7, t9
@


1.1
log
@initial mips64
@
text
@d1 1
a1 1
/*	$OpenBSD: fp.S,v 1.2 1998/03/16 09:03:31 pefo Exp $	*/
d38 1
a38 1
 *      $Id: fp.S,v 1.2 1998/03/16 09:03:31 pefo Exp $
d2222 3
a2224 2
	ctc1	a1, FPC_CSR		# save exceptions
	break	0
d2230 1
a2230 1
	ctc1	a1, FPC_CSR		# save exceptions
d2232 2
a2233 1
	break	0
d2256 2
@

