head	1.47;
access;
symbols
	OPENBSD_6_0:1.31.0.2
	OPENBSD_6_0_BASE:1.31
	OPENBSD_5_9:1.25.0.2
	OPENBSD_5_9_BASE:1.25
	OPENBSD_5_8:1.24.0.4
	OPENBSD_5_8_BASE:1.24
	OPENBSD_5_7:1.18.0.2
	OPENBSD_5_7_BASE:1.18
	OPENBSD_5_6:1.14.0.4
	OPENBSD_5_6_BASE:1.14
	OPENBSD_5_5:1.4.0.4
	OPENBSD_5_5_BASE:1.4;
locks; strict;
comment	@ * @;


1.47
date	2017.03.24.13.04.16;	author patrick;	state Exp;
branches;
next	1.46;
commitid	jfxW9D5Fd7sI3TnH;

1.46
date	2017.03.10.08.38.12;	author kettenis;	state Exp;
branches;
next	1.45;
commitid	vNzqF5LG38xxK8eP;

1.45
date	2016.10.25.00.04.59;	author jsg;	state Exp;
branches;
next	1.44;
commitid	kyDRkoOZHQsbTiU5;

1.44
date	2016.10.09.00.53.43;	author jsg;	state Exp;
branches;
next	1.43;
commitid	NJkwmASvm1yJz5Bo;

1.43
date	2016.10.08.17.02.48;	author tom;	state Exp;
branches;
next	1.42;
commitid	NmEL3NMPjnc2outi;

1.42
date	2016.10.05.07.44.24;	author patrick;	state Exp;
branches;
next	1.41;
commitid	rIdfUeWIVU4K3W95;

1.41
date	2016.10.05.07.29.59;	author patrick;	state Exp;
branches;
next	1.40;
commitid	WOkIaqGc4aRCRDhH;

1.40
date	2016.09.24.13.43.25;	author kettenis;	state Exp;
branches;
next	1.39;
commitid	K8bvq8OtVadfpwkG;

1.39
date	2016.09.01.09.05.37;	author kettenis;	state Exp;
branches;
next	1.38;
commitid	jTaEZEwUGj5NZMNt;

1.38
date	2016.08.26.11.59.04;	author kettenis;	state Exp;
branches;
next	1.37;
commitid	eHAV7iG810DcGo8p;

1.37
date	2016.08.19.15.31.10;	author kettenis;	state Exp;
branches;
next	1.36;
commitid	yTzABmim6A2WjrIA;

1.36
date	2016.08.15.21.04.32;	author patrick;	state Exp;
branches;
next	1.35;
commitid	eDrjUzPpQZN2eX5m;

1.35
date	2016.08.08.19.27.12;	author kettenis;	state Exp;
branches;
next	1.34;
commitid	9cxQ5QuyMM8g8ZRp;

1.34
date	2016.07.30.08.07.01;	author kettenis;	state Exp;
branches;
next	1.33;
commitid	teUDtJsNAbvKtKTN;

1.33
date	2016.07.26.22.10.10;	author patrick;	state Exp;
branches;
next	1.32;
commitid	QHTy0YAECnrTlcSQ;

1.32
date	2016.07.26.18.09.07;	author kettenis;	state Exp;
branches;
next	1.31;
commitid	5uhRXsGuhTSkEB7m;

1.31
date	2016.06.14.10.03.51;	author kettenis;	state Exp;
branches;
next	1.30;
commitid	hY1fXXVkwBC2K3rB;

1.30
date	2016.06.12.01.01.12;	author jsg;	state Exp;
branches;
next	1.29;
commitid	WgkkMNqo1l6ZR1GV;

1.29
date	2016.06.08.15.27.05;	author jsg;	state Exp;
branches;
next	1.28;
commitid	O8sdMmMKqczNQU5p;

1.28
date	2016.06.04.18.09.16;	author jsg;	state Exp;
branches;
next	1.27;
commitid	tYyT96DOGdhLjy9v;

1.27
date	2016.05.20.11.21.08;	author kettenis;	state Exp;
branches;
next	1.26;
commitid	YzQOQnj1SjkKjWD1;

1.26
date	2016.04.03.12.44.37;	author patrick;	state Exp;
branches;
next	1.25;
commitid	Ced5UDHDtOXkTk5C;

1.25
date	2016.01.31.01.04.24;	author jsg;	state Exp;
branches;
next	1.24;
commitid	WiwEkLxOCJ0TwK7V;

1.24
date	2015.05.19.03.30.54;	author jsg;	state Exp;
branches;
next	1.23;
commitid	l6xI4SC4UUe6il2U;

1.23
date	2015.05.19.00.05.59;	author jsg;	state Exp;
branches;
next	1.22;
commitid	bo8vCG1OOftVcP5V;

1.22
date	2015.05.15.15.35.43;	author jsg;	state Exp;
branches;
next	1.21;
commitid	AFNG6oUBgS2y44wd;

1.21
date	2015.05.12.04.31.10;	author jsg;	state Exp;
branches;
next	1.20;
commitid	tBinwSxs19VZuAFZ;

1.20
date	2015.05.10.15.56.28;	author jsg;	state Exp;
branches;
next	1.19;
commitid	MKYLBBkRhYmhiqiC;

1.19
date	2015.05.10.05.42.46;	author jsg;	state Exp;
branches;
next	1.18;
commitid	VGhQV5K8vrHdsIt6;

1.18
date	2015.01.18.10.17.42;	author jsg;	state Exp;
branches;
next	1.17;
commitid	EinLpFIBT92msrml;

1.17
date	2014.12.10.15.29.53;	author mikeb;	state Exp;
branches;
next	1.16;
commitid	qHQiR2HLROzvZr7B;

1.16
date	2014.11.16.12.30.56;	author deraadt;	state Exp;
branches;
next	1.15;
commitid	yv0ECmCdICvq576h;

1.15
date	2014.09.20.09.28.24;	author kettenis;	state Exp;
branches;
next	1.14;
commitid	IFRB8AkvBMXMTAKW;

1.14
date	2014.07.21.17.25.47;	author uebayasi;	state Exp;
branches;
next	1.13;
commitid	7QO4UJr3EKVAMc8t;

1.13
date	2014.07.13.22.53.38;	author uebayasi;	state Exp;
branches;
next	1.12;
commitid	wsdp3qtXGjMj98oD;

1.12
date	2014.07.13.22.13.06;	author uebayasi;	state Exp;
branches;
next	1.11;
commitid	qYPOd6Qi4aRBKldK;

1.11
date	2014.07.10.21.46.02;	author mpi;	state Exp;
branches;
next	1.10;
commitid	iYq3Z1ZWDKR3sS9G;

1.10
date	2014.07.10.20.37.41;	author uebayasi;	state Exp;
branches;
next	1.9;
commitid	3BJjMGXrqlV6GGra;

1.9
date	2014.07.10.12.13.48;	author uebayasi;	state Exp;
branches;
next	1.8;
commitid	aofvn6ceiucgjg4N;

1.8
date	2014.05.31.15.49.28;	author mpi;	state Exp;
branches;
next	1.7;
commitid	eA4Y0YE1IUzj6hpW;

1.7
date	2014.05.30.13.46.16;	author mpi;	state Exp;
branches;
next	1.6;

1.6
date	2014.03.29.18.09.28;	author guenther;	state Exp;
branches;
next	1.5;

1.5
date	2014.03.13.03.52.55;	author dlg;	state Exp;
branches;
next	1.4;

1.4
date	2013.11.13.17.30.44;	author syl;	state Exp;
branches;
next	1.3;

1.3
date	2013.11.13.07.03.11;	author uebayasi;	state Exp;
branches;
next	1.2;

1.2
date	2013.11.08.00.08.13;	author aalm;	state Exp;
branches;
next	1.1;

1.1
date	2013.10.30.20.20.23;	author syl;	state Exp;
branches;
next	;


desc
@@


1.47
log
@Mainline u-boot on the ClearFog seems to insert an empty memory region
into the /memory node which we happily physload into UVM.  This leads
to a quickly panic(9)ing system when there is actual physical memory
starting at zero due to how the physeg array is sorted when using the
binary search strategy.  To fix this, do not physload an empty memory
region.

ok jsg@@ kettenis@@
@
text
@/*	$OpenBSD: armv7_machdep.c,v 1.46 2017/03/10 08:38:12 kettenis Exp $ */
/*	$NetBSD: lubbock_machdep.c,v 1.2 2003/07/15 00:25:06 lukem Exp $ */

/*
 * Copyright (c) 2002, 2003  Genetec Corporation.  All rights reserved.
 * Written by Hiroyuki Bessho for Genetec Corporation.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of Genetec Corporation may not be used to endorse or 
 *    promote products derived from this software without specific prior
 *    written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY GENETEC CORPORATION ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL GENETEC CORPORATION
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * Machine dependant functions for kernel setup for 
 * Intel DBPXA250 evaluation board (a.k.a. Lubbock).
 * Based on iq80310_machhdep.c
 */
/*
 * Copyright (c) 2001 Wasabi Systems, Inc.
 * All rights reserved.
 *
 * Written by Jason R. Thorpe for Wasabi Systems, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed for the NetBSD Project by
 *	Wasabi Systems, Inc.
 * 4. The name of Wasabi Systems, Inc. may not be used to endorse
 *    or promote products derived from this software without specific prior
 *    written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY WASABI SYSTEMS, INC. ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL WASABI SYSTEMS, INC
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 1997,1998 Mark Brinicombe.
 * Copyright (c) 1997,1998 Causality Limited.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Mark Brinicombe
 *	for the NetBSD Project.
 * 4. The name of the company nor the name of the author may be used to
 *    endorse or promote products derived from this software without specific
 *    prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * Machine dependant functions for kernel setup for ARMv7 boards using
 * u-boot/EFI firmware.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/reboot.h>
#include <sys/termios.h>
#include <sys/socket.h>

#include <machine/db_machdep.h>
#include <machine/bootconfig.h>
#include <machine/machine_reg.h>
#include <machine/bus.h>

#include <arm/undefined.h>
#include <arm/machdep.h>
#include <arm/armv7/armv7var.h>
#include <armv7/armv7/armv7_machdep.h>

#include <dev/cons.h>
#include <dev/ofw/fdt.h>
#include <dev/ofw/openfirm.h>

#include <net/if.h>

#include <ddb/db_extern.h>

/* Kernel text starts 2MB in from the bottom of the kernel address space. */
#define	KERNEL_TEXT_BASE	(KERNEL_BASE + 0x00000000)
#define	KERNEL_VM_BASE		(KERNEL_BASE + 0x04000000)
#define KERNEL_VM_SIZE		VM_KERNEL_SPACE_SIZE

/*
 * Address to call from cpu_reset() to reset the machine.
 * This is machine architecture dependant as it varies depending
 * on where the ROM appears when you turn the MMU off.
 */

/* Define various stack sizes in pages */
#define IRQ_STACK_SIZE	1
#define ABT_STACK_SIZE	1
#define UND_STACK_SIZE	1

BootConfig bootconfig;		/* Boot config storage */
char *boot_args = NULL;
char *boot_file = "";
u_int cpu_reset_address = 0;

vaddr_t physical_start;
vaddr_t physical_freestart;
vaddr_t physical_freeend;
vaddr_t physical_end;
u_int free_pages;
int physmem = 0;

/*int debug_flags;*/
#ifndef PMAP_STATIC_L1S
int max_processes = 64;			/* Default number */
#endif	/* !PMAP_STATIC_L1S */

/* Physical and virtual addresses for some global pages */
pv_addr_t systempage;
pv_addr_t irqstack;
pv_addr_t undstack;
pv_addr_t abtstack;
extern pv_addr_t kernelstack;

vaddr_t msgbufphys;

extern u_int data_abort_handler_address;
extern u_int prefetch_abort_handler_address;
extern u_int undefined_handler_address;

uint32_t	board_id;

#define KERNEL_PT_SYS		0	/* Page table for mapping proc0 zero page */
#define KERNEL_PT_KERNEL	1	/* Page table for mapping kernel */
#define	KERNEL_PT_KERNEL_NUM	32
#define KERNEL_PT_VMDATA	(KERNEL_PT_KERNEL+KERNEL_PT_KERNEL_NUM)
				        /* Page tables for mapping kernel VM */
#define	KERNEL_PT_VMDATA_NUM	8	/* start with 16MB of KVM */
#define NUM_KERNEL_PTS		(KERNEL_PT_VMDATA + KERNEL_PT_VMDATA_NUM)

pv_addr_t kernel_pt_table[NUM_KERNEL_PTS];

extern struct user *proc0paddr;

/*
 * safepri is a safe priority for sleep to set for a spin-wait
 * during autoconfiguration or after a panic.
 */
int   safepri = 0;

/* Prototypes */

char	bootargs[MAX_BOOT_STRING];
int	bootstrap_bs_map(void *, uint64_t, bus_size_t, int,
    bus_space_handle_t *);
void	process_kernel_args(char *);
void	consinit(void);

bs_protos(bs_notimpl);

#ifndef CONSPEED
#define CONSPEED B115200	/* What u-boot */
#endif
#ifndef CONMODE
#define CONMODE ((TTYDEF_CFLAG & ~(CSIZE | CSTOPB | PARENB)) | CS8) /* 8N1 */
#endif

int comcnspeed = CONSPEED;
int comcnmode = CONMODE;

int stdout_node = 0;

void (*cpuresetfn)(void);
void (*powerdownfn)(void);

/*
 * void boot(int howto, char *bootstr)
 *
 * Reboots the system
 *
 * Deal with any syncing, unmounting, dumping and shutdown hooks,
 * then reset the CPU.
 */
__dead void
boot(int howto)
{
#ifdef DIAGNOSTIC
	/* info */
	printf("boot: howto=%08x curproc=%p\n", howto, curproc);
#endif

	if (cold) {
		if ((howto & RB_USERREQ) == 0)
			howto |= RB_HALT;
		goto haltsys;
	}

	/* Disable console buffering */
/*	cnpollc(1);*/

	/*
	 * If RB_NOSYNC was not specified sync the discs.
	 * Note: Unless cold is set to 1 here, syslogd will die during the
	 * unmount.  It looks like syslogd is getting woken up only to find
	 * that it cannot page part of the binary in as the filesystem has
	 * been unmounted.
	 */
	if ((howto & RB_NOSYNC) == 0)
		bootsync(howto);

	if_downall();

	uvm_shutdown();
	splhigh();
	cold = 1;

	if ((howto & (RB_DUMP | RB_HALT)) == RB_DUMP)
		dumpsys();

haltsys:
	config_suspend_all(DVACT_POWERDOWN);

	/* Make sure IRQ's are disabled */
	IRQdisable;

	if ((howto & RB_HALT) != 0) {
		if ((howto & RB_POWERDOWN) != 0) {
			printf("\nAttempting to power down...\n");
			delay(500000);
			if (powerdownfn)
				(*powerdownfn)();
		}

		printf("The operating system has halted.\n");
		printf("Please press any key to reboot.\n\n");
		cngetc();
	}

	printf("rebooting...\n");
	delay(500000);
	if (cpuresetfn)
		(*cpuresetfn)();
	printf("reboot failed; spinning\n");
	for (;;)
		continue;
	/* NOTREACHED */
}

static __inline
pd_entry_t *
read_ttb(void)
{
  long ttb;

  __asm volatile("mrc	p15, 0, %0, c2, c0, 0" : "=r" (ttb));


  return (pd_entry_t *)(ttb & ~((1<<14)-1));
}

#define VERBOSE_INIT_ARM

/*
 * simple memory mapping function used in early bootstrap stage
 * before pmap is initialized.
 * ignores cacheability and does map the sections with nocache.
 */
static vaddr_t section_free = 0xfd000000; /* XXX - huh */

int
bootstrap_bs_map(void *t, uint64_t bpa, bus_size_t size,
    int flags, bus_space_handle_t *bshp)
{
	u_long startpa, pa, endpa;
	vaddr_t va;
	pd_entry_t *pagedir = read_ttb();
	/* This assumes PA==VA for page directory */

	va = section_free;

	startpa = bpa & ~L1_S_OFFSET;
	endpa = (bpa + size) & ~L1_S_OFFSET;
	if ((bpa + size) & L1_S_OFFSET)
		endpa += L1_S_SIZE;

	*bshp = (bus_space_handle_t)(va + (bpa - startpa));

	for (pa = startpa; pa < endpa; pa += L1_S_SIZE, va += L1_S_SIZE)
		pmap_map_section((vaddr_t)pagedir, va, pa,
		    PROT_READ | PROT_WRITE, PTE_NOCACHE);

	cpu_tlb_flushD();

	section_free = va;

	return 0;
}

static void
copy_io_area_map(pd_entry_t *new_pd)
{
	pd_entry_t *cur_pd = read_ttb();
	vaddr_t va;

	for (va = MACHINE_IO_AREA_VBASE;
	     (cur_pd[va>>L1_S_SHIFT] & L1_TYPE_MASK) == L1_TYPE_S;
	     va += L1_S_SIZE) {

		new_pd[va>>L1_S_SHIFT] = cur_pd[va>>L1_S_SHIFT];
		if (va == (ARM_VECTORS_HIGH & ~(0x00400000 - 1)))
			break; /* STUPID */

	}
}

/*
 * u_int initarm(...)
 *
 * Initial entry point on startup. This gets called before main() is
 * entered.
 * It should be responsible for setting up everything that must be
 * in place when main is called.
 * This includes
 *   Taking a copy of the FDT.
 *   Initialising the physical console so characters can be printed.
 *   Setting up page tables for the kernel.
 */
u_int
initarm(void *arg0, void *arg1, void *arg2, paddr_t loadaddr)
{
	int loop, loop1, i, physsegs = VM_PHYSSEG_MAX;
	u_int l1pagetable;
	pv_addr_t kernel_l1pt;
	pv_addr_t fdt;
	struct fdt_reg reg;
	paddr_t memstart;
	psize_t memsize;
	paddr_t memend;
	void *config;
	size_t size;
	void *node;
	extern uint32_t esym; /* &_end if no symbols are loaded */

	/* early bus_space_map support */
	struct bus_space tmp_bs_tag;
	int	(*map_func_save)(void *, uint64_t, bus_size_t, int,
	    bus_space_handle_t *);

	if (arg0)
		esym = (uint32_t)arg0;

	board_id = (uint32_t)arg1;
	/*
	 * u-boot has decided the top four bits are
	 * 'compatibility revision' for sunxi
	 */
	if (board_id != 0xffffffff)
		board_id &= 0x0fffffff;

	/*
	 * Heads up ... Setup the CPU / MMU / TLB functions
	 */
	if (set_cpufuncs())
		panic("cpu not recognized!");

	/*
	 * Temporarily replace bus_space_map() functions so that
	 * console devices can get mapped.
	 *
	 * Note that this relies upon the fact that both regular
	 * and a4x bus_space tags use the same map function.
	 */
	tmp_bs_tag = armv7_bs_tag;
	map_func_save = armv7_bs_tag.bs_map;
	armv7_bs_tag.bs_map = bootstrap_bs_map;
	armv7_a4x_bs_tag.bs_map = bootstrap_bs_map;
	tmp_bs_tag.bs_map = bootstrap_bs_map;

	/*
	 * Now, map the FDT area.
	 *
	 * As we don't know the size of a possible FDT, map the size of a
	 * typical bootstrap bs map.  The FDT might not be aligned, so this
	 * might take up to two L1_S_SIZEd mappings.
	 *
	 * XXX: There's (currently) no way to unmap a bootstrap mapping, so
	 * we might lose a bit of the bootstrap address space.
	 */
	bootstrap_bs_map(NULL, (bus_addr_t)arg2, L1_S_SIZE, 0,
	    (bus_space_handle_t *)&config);

	if (!fdt_init(config) || fdt_get_size(config) == 0)
		panic("initarm: no FDT");

	node = fdt_find_node("/chosen");
	if (node != NULL) {
		char *args, *duid;
		int len;

		len = fdt_node_property(node, "bootargs", &args);
		if (len > 0)
			process_kernel_args(args);

		len = fdt_node_property(node, "openbsd,bootduid", &duid);
		if (len == sizeof(bootduid))
			memcpy(bootduid, duid, sizeof(bootduid));
	}

	node = fdt_find_node("/memory");
	if (node == NULL || fdt_get_reg(node, 0, &reg))
		panic("initarm: no memory specificed");

	memstart = reg.addr;
	memsize = reg.size;
	physical_start = reg.addr;
	physical_end = MIN(reg.addr + reg.size, (paddr_t)-PAGE_SIZE);

	platform_init();

	/* setup a serial console for very early boot */
	consinit();

	/* Talk to the user */
	printf("\nOpenBSD/armv7 booting ...\n");

	printf("arg0 %p arg1 %p arg2 %p\n", arg0, arg1, arg2);

#ifdef RAMDISK_HOOKS
	boothowto |= RB_DFLTROOT;
#endif /* RAMDISK_HOOKS */

	physical_freestart = (((unsigned long)esym - KERNEL_TEXT_BASE + 0xfff) & ~0xfff) + loadaddr;
	physical_freeend = MIN((uint64_t)physical_end, (paddr_t)-PAGE_SIZE);

	physmem = (physical_end - physical_start) / PAGE_SIZE;

#ifdef DEBUG
	/* Tell the user about the memory */
	printf("physmemory: %d pages at 0x%08lx -> 0x%08lx\n", physmem,
	    physical_start, physical_end - 1);
#endif

	/*
	 * Okay, the kernel starts 2MB in from the bottom of physical
	 * memory.  We are going to allocate our bootstrap pages downwards
	 * from there.
	 *
	 * We need to allocate some fixed page tables to get the kernel
	 * going.  We allocate one page directory and a number of page
	 * tables and store the physical addresses in the kernel_pt_table
	 * array.
	 *
	 * The kernel page directory must be on a 16K boundary.  The page
	 * tables must be on 4K bounaries.  What we do is allocate the
	 * page directory on the first 16K boundary that we encounter, and
	 * the page tables on 4K boundaries otherwise.  Since we allocate
	 * at least 3 L2 page tables, we are guaranteed to encounter at
	 * least one 16K aligned region.
	 */

#ifdef VERBOSE_INIT_ARM
	printf("Allocating page tables\n");
#endif

	free_pages = (physical_freeend - physical_freestart) / PAGE_SIZE;

#ifdef VERBOSE_INIT_ARM
	printf("freestart = 0x%08lx, free_pages = %d (0x%08x)\n",
	       physical_freestart, free_pages, free_pages);
#endif

	/* Define a macro to simplify memory allocation */
#define	valloc_pages(var, np)				\
	alloc_pages((var).pv_pa, (np));			\
	(var).pv_va = KERNEL_BASE + (var).pv_pa - loadaddr;

#define alloc_pages(var, np)				\
	(var) = physical_freestart;			\
	physical_freestart += ((np) * PAGE_SIZE);	\
	if (physical_freeend < physical_freestart)	\
		panic("initarm: out of memory");	\
	free_pages -= (np);				\
	memset((char *)(var), 0, ((np) * PAGE_SIZE));

	loop1 = 0;
	kernel_l1pt.pv_pa = 0;
	for (loop = 0; loop <= NUM_KERNEL_PTS; ++loop) {
		/* Are we 16KB aligned for an L1 ? */
		if (((physical_freestart) & (L1_TABLE_SIZE - 1)) == 0
		    && kernel_l1pt.pv_pa == 0) {
			valloc_pages(kernel_l1pt, L1_TABLE_SIZE / PAGE_SIZE);
		} else {
			valloc_pages(kernel_pt_table[loop1],
			    L2_TABLE_SIZE / PAGE_SIZE);
			++loop1;
		}
	}

	/* This should never be able to happen but better confirm that. */
	if (!kernel_l1pt.pv_pa || (kernel_l1pt.pv_pa & (L1_TABLE_SIZE-1)) != 0)
		panic("initarm: Failed to align the kernel page directory");

	/*
	 * Allocate a page for the system page mapped to V0x00000000
	 * This page will just contain the system vectors and can be
	 * shared by all processes.
	 */
	vector_page = ARM_VECTORS_HIGH;
	alloc_pages(systempage.pv_pa, 1);
	systempage.pv_va = vector_page;

	/* Allocate stacks for all modes */
	valloc_pages(irqstack, IRQ_STACK_SIZE);
	valloc_pages(abtstack, ABT_STACK_SIZE);
	valloc_pages(undstack, UND_STACK_SIZE);
	valloc_pages(kernelstack, UPAGES);

	/* Allocate enough pages for cleaning the Mini-Data cache. */

#ifdef VERBOSE_INIT_ARM
	printf("IRQ stack: p0x%08lx v0x%08lx\n", irqstack.pv_pa,
	    irqstack.pv_va);
	printf("ABT stack: p0x%08lx v0x%08lx\n", abtstack.pv_pa,
	    abtstack.pv_va);
	printf("UND stack: p0x%08lx v0x%08lx\n", undstack.pv_pa,
	    undstack.pv_va);
	printf("SVC stack: p0x%08lx v0x%08lx\n", kernelstack.pv_pa,
	    kernelstack.pv_va);
#endif

	/*
	 * Allocate pages for an FDT copy.
	 */
	size = fdt_get_size(config);
	valloc_pages(fdt, round_page(size) / PAGE_SIZE);
	memcpy((void *)fdt.pv_pa, config, size);

	/*
	 * XXX Defer this to later so that we can reclaim the memory
	 */
	alloc_pages(msgbufphys, round_page(MSGBUFSIZE) / PAGE_SIZE);

	/*
	 * Ok we have allocated physical pages for the primary kernel
	 * page tables
	 */

#ifdef VERBOSE_INIT_ARM
	printf("Creating L1 page table at 0x%08lx\n", kernel_l1pt.pv_pa);
#endif

	/*
	 * Now we start construction of the L1 page table
	 * We start by mapping the L2 page tables into the L1.
	 * This means that we can replace L1 mappings later on if necessary
	 */
	l1pagetable = kernel_l1pt.pv_pa;

	/* Map the L2 pages tables in the L1 page table */
	pmap_link_l2pt(l1pagetable, vector_page & ~(0x00400000 - 1),
	    &kernel_pt_table[KERNEL_PT_SYS]);

	for (loop = 0; loop < KERNEL_PT_KERNEL_NUM; loop++)
		pmap_link_l2pt(l1pagetable, KERNEL_BASE + loop * 0x00400000,
		    &kernel_pt_table[KERNEL_PT_KERNEL + loop]);

	for (loop = 0; loop < KERNEL_PT_VMDATA_NUM; loop++)
		pmap_link_l2pt(l1pagetable, KERNEL_VM_BASE + loop * 0x00400000,
		    &kernel_pt_table[KERNEL_PT_VMDATA + loop]);

	/* update the top of the kernel VM */
	pmap_curmaxkvaddr =
	    KERNEL_VM_BASE + (KERNEL_PT_VMDATA_NUM * 0x00400000);

#ifdef VERBOSE_INIT_ARM
	printf("Mapping kernel\n");
#endif

	/* Now we fill in the L2 pagetable for the kernel static code/data */
	{
		extern char etext[];
		size_t textsize = (u_int32_t) etext - KERNEL_TEXT_BASE;
		size_t totalsize = (u_int32_t) esym - KERNEL_TEXT_BASE;
		u_int logical;

		textsize = (textsize + PGOFSET) & ~PGOFSET;
		totalsize = (totalsize + PGOFSET) & ~PGOFSET;

		logical = 0x00000000;	/* offset of kernel in RAM */

		logical += pmap_map_chunk(l1pagetable, KERNEL_BASE + logical,
		    loadaddr + logical, textsize,
		    PROT_READ | PROT_EXEC, PTE_CACHE);
		logical += pmap_map_chunk(l1pagetable, KERNEL_BASE + logical,
		    loadaddr + logical, totalsize - textsize,
		    PROT_READ | PROT_WRITE, PTE_CACHE);
	}

#ifdef VERBOSE_INIT_ARM
	printf("Constructing L2 page tables\n");
#endif

	/* Map the stack pages */
	pmap_map_chunk(l1pagetable, irqstack.pv_va, irqstack.pv_pa,
	    IRQ_STACK_SIZE * PAGE_SIZE, PROT_READ | PROT_WRITE, PTE_CACHE);
	pmap_map_chunk(l1pagetable, abtstack.pv_va, abtstack.pv_pa,
	    ABT_STACK_SIZE * PAGE_SIZE, PROT_READ | PROT_WRITE, PTE_CACHE);
	pmap_map_chunk(l1pagetable, undstack.pv_va, undstack.pv_pa,
	    UND_STACK_SIZE * PAGE_SIZE, PROT_READ | PROT_WRITE, PTE_CACHE);
	pmap_map_chunk(l1pagetable, kernelstack.pv_va, kernelstack.pv_pa,
	    UPAGES * PAGE_SIZE, PROT_READ | PROT_WRITE, PTE_CACHE);

	pmap_map_chunk(l1pagetable, kernel_l1pt.pv_va, kernel_l1pt.pv_pa,
	    L1_TABLE_SIZE, PROT_READ | PROT_WRITE, PTE_PAGETABLE);

	for (loop = 0; loop < NUM_KERNEL_PTS; ++loop) {
		pmap_map_chunk(l1pagetable, kernel_pt_table[loop].pv_va,
		    kernel_pt_table[loop].pv_pa, L2_TABLE_SIZE,
		    PROT_READ | PROT_WRITE, PTE_PAGETABLE);
	}

	/* Map the Mini-Data cache clean area. */

	/* Map the vector page. */
	pmap_map_entry(l1pagetable, vector_page, systempage.pv_pa,
	    PROT_READ | PROT_WRITE, PTE_CACHE);

	/* Map the FDT. */
	pmap_map_chunk(l1pagetable, fdt.pv_va, fdt.pv_pa,
	    round_page(fdt_get_size((void *)fdt.pv_pa)),
	    PROT_READ | PROT_WRITE, PTE_CACHE);

	/*
	 * map integrated peripherals at same address in l1pagetable
	 * so that we can continue to use console.
	 */
	copy_io_area_map((pd_entry_t *)l1pagetable);

	/*
	 * Now we have the real page tables in place so we can switch to them.
	 * Once this is done we will be running with the REAL kernel page
	 * tables.
	 */
	setttb(kernel_l1pt.pv_pa);
	cpu_tlb_flushID();

	/*
	 * Moved from cpu_startup() as data_abort_handler() references
	 * this during uvm init
	 */
	proc0paddr = (struct user *)kernelstack.pv_va;
	proc0.p_addr = proc0paddr;

	arm32_vector_init(vector_page, ARM_VEC_ALL);

	/*
	 * Pages were allocated during the secondary bootstrap for the
	 * stacks for different CPU modes.
	 * We must now set the r13 registers in the different CPU modes to
	 * point to these stacks.
	 * Since the ARM stacks use STMFD etc. we must set r13 to the top end
	 * of the stack memory.
	 */

	set_stackptr(PSR_IRQ32_MODE,
	    irqstack.pv_va + IRQ_STACK_SIZE * PAGE_SIZE);
	set_stackptr(PSR_ABT32_MODE,
	    abtstack.pv_va + ABT_STACK_SIZE * PAGE_SIZE);
	set_stackptr(PSR_UND32_MODE,
	    undstack.pv_va + UND_STACK_SIZE * PAGE_SIZE);

	/*
	 * Well we should set a data abort handler.
	 * Once things get going this will change as we will need a proper
	 * handler.
	 * Until then we will use a handler that just panics but tells us
	 * why.
	 * Initialisation of the vectors will just panic on a data abort.
	 * This just fills in a slighly better one.
	 */

	data_abort_handler_address = (u_int)data_abort_handler;
	prefetch_abort_handler_address = (u_int)prefetch_abort_handler;
	undefined_handler_address = (u_int)undefinedinstruction_bounce;

	/* Now we can reinit the FDT, using the virtual address. */
	fdt_init((void *)fdt.pv_va);

	/* Initialise the undefined instruction handlers */
#ifdef VERBOSE_INIT_ARM
	printf("undefined ");
#endif
	undefined_init();

	/* Load memory into UVM. */
#ifdef VERBOSE_INIT_ARM
	printf("page ");
#endif
	uvm_setpagesize();        /* initialize PAGE_SIZE-dependent variables */
	uvm_page_physload(atop(physical_freestart), atop(physical_freeend),
	    atop(physical_freestart), atop(physical_freeend), 0);

	if (physical_start < loadaddr) {
		uvm_page_physload(atop(physical_start), atop(loadaddr),
		    atop(physical_start), atop(loadaddr), 0);
		physsegs--;
	}

	node = fdt_find_node("/memory");
	for (i = 1; i < physsegs; i++) {
		if (fdt_get_reg(node, i, &reg))
			break;
		if (reg.size == 0)
			continue;

		memstart = reg.addr;
		memend = MIN(reg.addr + reg.size, (paddr_t)-PAGE_SIZE);
		physmem += (memend - memstart) / PAGE_SIZE;
		uvm_page_physload(atop(memstart), atop(memend),
		    atop(memstart), atop(memend), 0);
	}

	/* Boot strap pmap telling it where the kernel page table is */
#ifdef VERBOSE_INIT_ARM
	printf("pmap ");
#endif
	pmap_bootstrap((pd_entry_t *)kernel_l1pt.pv_va, KERNEL_VM_BASE,
	    KERNEL_VM_BASE + KERNEL_VM_SIZE);

	vector_page_setprot(PROT_READ | PROT_EXEC);

	/*
	 * Restore proper bus_space operation, now that pmap is initialized.
	 */
	armv7_bs_tag.bs_map = map_func_save;
	armv7_a4x_bs_tag.bs_map = map_func_save;

#ifdef DDB
	db_machine_init();

	/* Firmware doesn't load symbols. */
	ddb_init();

	if (boothowto & RB_KDB)
		Debugger();
#endif
	printf("board type: %u\n", board_id);

	cpu_setup();

	/* We return the new stack pointer address */
	return(kernelstack.pv_va + USPACE_SVC_STACK_TOP);
}


void
process_kernel_args(char *args)
{
	char *cp = args;

	if (cp == NULL) {
		boothowto = RB_AUTOBOOT;
		return;
	}

	boothowto = 0;

	/* Make a local copy of the bootargs */
	strncpy(bootargs, cp, MAX_BOOT_STRING - sizeof(int));

	cp = bootargs;
	boot_file = bootargs;

	/* Skip the kernel image filename */
	while (*cp != ' ' && *cp != 0)
		++cp;

	if (*cp != 0)
		*cp++ = 0;

	while (*cp == ' ')
		++cp;

	boot_args = cp;

	printf("bootfile: %s\n", boot_file);
	printf("bootargs: %s\n", boot_args);

	/* Setup pointer to boot flags */
	while (*cp != '-')
		if (*cp++ == '\0')
			return;

	for (;*++cp;) {
		int fl;

		fl = 0;
		switch(*cp) {
		case 'a':
			fl |= RB_ASKNAME;
			break;
		case 'c':
			fl |= RB_CONFIG;
			break;
		case 'd':
			fl |= RB_KDB;
			break;
		case 's':
			fl |= RB_SINGLE;
			break;
		default:
			printf("unknown option `%c'\n", *cp);
			break;
		}
		boothowto |= fl;
	}
}

void *
fdt_find_cons(const char *name)
{
	char *alias = "serial0";
	char buf[128];
	char *stdout = NULL;
	char *p;
	void *node;

	/* First check if "stdout-path" is set. */
	node = fdt_find_node("/chosen");
	if (node) {
		if (fdt_node_property(node, "stdout-path", &stdout) > 0) {
			if (strchr(stdout, ':') != NULL) {
				strlcpy(buf, stdout, sizeof(buf));
				if ((p = strchr(buf, ':')) != NULL)
					*p = '\0';
				stdout = buf;
			}
			if (stdout[0] != '/') {
				/* It's an alias. */
				alias = stdout;
				stdout = NULL;
			}
		}
	}

	/* Perform alias lookup if necessary. */
	if (stdout == NULL) {
		node = fdt_find_node("/aliases");
		if (node)
			fdt_node_property(node, alias, &stdout);
	}

	/* Lookup the physical address of the interface. */
	if (stdout) {
		node = fdt_find_node(stdout);
		if (node && fdt_is_compatible(node, name)) {
			stdout_node = OF_finddevice(stdout);
			return (node);
		}
	}

	return (NULL);
}

void
consinit(void)
{
	static int consinit_called = 0;

	if (consinit_called != 0)
		return;

	consinit_called = 1;

	platform_init_cons();
}

void
board_startup(void)
{
        if (boothowto & RB_CONFIG) {
#ifdef BOOT_CONFIG
		user_config();
#else
		printf("kernel does not support -c; continuing..\n");
#endif
	}
}
@


1.46
log
@Lookup the /memory node again after we reinit the FDT.  This makes adding
additional memory segments provided by the device tree actually work.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: armv7_machdep.c,v 1.45 2016/10/25 00:04:59 jsg Exp $ */
d761 2
@


1.45
log
@Remove now unused disable_l2_if_needed interface.
ok kettenis@@ patrick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: armv7_machdep.c,v 1.44 2016/10/09 00:53:43 jsg Exp $ */
d757 1
@


1.44
log
@Add a power down function pointer so power down can work without the
platform abstraction.

ok tom@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: armv7_machdep.c,v 1.43 2016/10/08 17:02:48 tom Exp $ */
a466 1
	platform_disable_l2_if_needed();
@


1.43
log
@Simplify handling of cold reboot on armv7 to match other platforms

Suggested by and ok both patrick@@ and kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: armv7_machdep.c,v 1.42 2016/10/05 07:44:24 patrick Exp $ */
d222 1
d278 2
a279 1
			platform_powerdown();
@


1.42
log
@Some device trees use 64-bit intermediate virtual addresses.  This
means that even though the hardware in the end never leaves the 32-bit
address space, some addresses used solely in the device tree can be
bigger than 32-bit.  As bus_space_map(9) takes addresses of size
bus_addr_t, which is 32-bit on ARMv7, we cannot pass those virtual
addresses to the parent bus, even though it will be mapped back into a
32-bit address in the end.  To work around this, make bus_space_map(9)
take a 64-bit address.  Since this is implemented as a macro and
function pointer we can safely do that without harming any other
architecture.

ok kettenis@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: armv7_machdep.c,v 1.41 2016/10/05 07:29:59 patrick Exp $ */
d240 3
a242 13
		config_suspend_all(DVACT_POWERDOWN);
		if ((howto & (RB_HALT | RB_USERREQ)) != RB_USERREQ) {
			printf("The operating system has halted.\n");
			printf("Please press any key to reboot.\n\n");
			cngetc();
		}
		printf("rebooting...\n");
		delay(500000);
		if (cpuresetfn)
			(*cpuresetfn)();
		printf("reboot failed; spinning\n");
		while(1);
		/*NOTREACHED*/
d267 1
d290 2
a291 1
	for (;;) ;
@


1.41
log
@Introduce a global function pointer to reset the CPU akin to amd64 and
i386.  As newer ARMs where we use device tree from the get go don't
necessarily have a 'platform', this will allow drivers to hook
themselves as a way to reset the CPU.

ok jsg@@ kettenis@@ tom@@
@
text
@d1 1
a1 1
/*	$OpenBSD: armv7_machdep.c,v 1.40 2016/09/24 13:43:25 kettenis Exp $ */
d202 1
a202 1
int	bootstrap_bs_map(void *, bus_addr_t, bus_size_t, int,
d325 1
a325 1
bootstrap_bs_map(void *t, bus_addr_t bpa, bus_size_t size,
d400 1
a400 1
	int	(*map_func_save)(void *, bus_addr_t, bus_size_t, int,
@


1.40
log
@If the value of r0 upon entering the kernel is zero, interpret this as the
address of the end of the symbol table.  This will make it possible to get
rid of the code in the bootloader that patches up the kernel with the updated
esym value.

ok tom@@, patrick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: armv7_machdep.c,v 1.39 2016/09/01 09:05:37 kettenis Exp $ */
d221 2
d248 2
a249 1
		platform_watchdog_reset();
d296 2
a297 1
	platform_watchdog_reset();
@


1.39
log
@Avoid mapping the vector page W|X.  Map it using PROT_READ|PROT_WRITE
initially and change it to PROT_READ|PROT_EXEC as soon as we have called
pmap_bootstrap(), at which piint we're done modifying the page.

ok jsg@@, deraadt@@, patrick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: armv7_machdep.c,v 1.38 2016/08/26 11:59:04 kettenis Exp $ */
d379 1
a379 1
initarm(void *arg0, void *arg1, void *arg2)
a384 1
	paddr_t loadaddr;
d399 3
a401 1
	loadaddr = (paddr_t)arg0;
@


1.38
log
@Remove the code that switches around MMU domains on armv7.  MMU domains are
basically a relic from the past.  Using them doesn't make a lot of sense
the way our pmaps work.  Support for MMU domains isn't present in
long-descriptor translation table format, so it is clearly on its way out.

Based on a diff from Artituri Alm.

ok patrick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: armv7_machdep.c,v 1.37 2016/08/19 15:31:10 kettenis Exp $ */
d676 1
a676 1
	    PROT_READ | PROT_WRITE | PROT_EXEC, PTE_CACHE);
d776 2
@


1.37
log
@Map kernel .text read-only.

Spotted by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: armv7_machdep.c,v 1.36 2016/08/15 21:04:32 patrick Exp $ */
a693 6

	/* be a client to all domains */
	cpu_domains(0x55555555);
	/* Switch tables */

	cpu_domains((DOMAIN_CLIENT << (PMAP_DOMAIN_KERNEL*2)) | DOMAIN_CLIENT);
a695 1
	cpu_domains(DOMAIN_CLIENT << (PMAP_DOMAIN_KERNEL*2));
@


1.36
log
@Now that com(4) uses a different iot for the initial console and the
main attachment, the serial port is now longer recognized as console.
To fix this, store the OFW node of the initial console and check it
in the attachment driver.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: armv7_machdep.c,v 1.35 2016/08/08 19:27:12 kettenis Exp $ */
d643 1
a643 1
		    PROT_READ | PROT_WRITE | PROT_EXEC, PTE_CACHE);
@


1.35
log
@Move the cpu_setup() call to the end of initarm().  On Cortex-A53 processors
atomic instructions don't work unless the data cache is enabled.  This happens
in cpu_setup(), but that gets currently called from cpu_startup() which runs
after a number of kernel subsystems have been initialized.  Since some of
these subsystems use locks, which need atomic instructions, we fault on
Cortex-A53.  Since at the end of initarm() we're done setting up the pmap
and initializing other low-level sense, calling cpu_setup() here makes much
more sense.

Remove setting up proc0paddr as well from cpu_startup(), since that already
happens in initarm().

Tested on zaurus by deraadt@@.

ok jsg@@, patrick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: armv7_machdep.c,v 1.34 2016/07/30 08:07:01 kettenis Exp $ */
d127 1
d219 2
d908 2
a909 1
		if (node && fdt_is_compatible(node, name))
d911 1
@


1.34
log
@Stop pretending we can still boot without an FDT.  Remove the code paths
handling ATAGS and cleanup the early boot code.

ok patrick@@, tom@@, jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: armv7_machdep.c,v 1.33 2016/07/26 22:10:10 patrick Exp $ */
d797 2
@


1.33
log
@Rename struct fdt_memory to fdt_reg to match the member name
used in the fdt attach args and the device tree.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: armv7_machdep.c,v 1.32 2016/07/26 18:09:07 kettenis Exp $ */
d104 2
a105 9
 * Machine dependant functions for kernel setup for Intel IQ80310 evaluation
 * boards using RedBoot firmware.
 */

/*
 * DIP switches:
 *
 * S19: no-dot: set RB_KDB.  enter kgdb session.
 * S20: no-dot: set RB_SINGLE. don't go multi user mode.
a203 1
void	parse_uboot_tags(void *);
a204 1
void	bootconfig_dram(BootConfig *, psize_t *, psize_t *);
d371 1
a371 1
 *   Taking a copy of the boot configuration structure.
d373 1
a373 2
 *   Setting up page tables for the kernel
 *   Relocating the kernel to the bottom of physical memory
d383 1
d386 1
d388 2
d426 1
a426 1
	 * Now, map the bootconfig/FDT area.
d430 1
a430 3
	 * might take up to two L1_S_SIZEd mappings.  In the unlikely case
	 * that the FDT is bigger than L1_S_SIZE (0x00100000), we need to
	 * remap it.
a436 6
	if (fdt_init(config) && fdt_get_size(config) != 0) {
		uint32_t size = fdt_get_size(config);
		if (size > L1_S_SIZE)
			bootstrap_bs_map(NULL, (bus_addr_t)arg2, size, 0,
			    (bus_space_handle_t *)&config);
	}
d438 2
a439 7
	if (fdt_init(config) && fdt_get_size(config) != 0) {
		struct fdt_reg reg;
		void *node;

		node = fdt_find_node("/memory");
		if (node == NULL || fdt_get_reg(node, 0, &reg))
			panic("initarm: no memory specificed");
d441 22
a462 19
		memstart = reg.addr;
		memsize = reg.size;
		physical_start = reg.addr;
		physical_end = MIN(reg.addr + reg.size, (paddr_t)-PAGE_SIZE);

		node = fdt_find_node("/chosen");
		if (node != NULL) {
			char *args, *duid;
			int len;

			len = fdt_node_property(node, "bootargs", &args);
			if (len > 0)
				process_kernel_args(args);

			len = fdt_node_property(node, "openbsd,bootduid", &duid);
			if (len == sizeof(bootduid))
				memcpy(bootduid, duid, sizeof(bootduid));
		}
	}
a463 1
	/* XXX: Use FDT information. */
a474 23
	if (fdt_get_size(config) == 0) {
		parse_uboot_tags(config);

		/*
		 * Examine the boot args string for options we need to know about
		 * now.
		 */
		process_kernel_args(bootconfig.bootstring);

		/* normally u-boot will set up bootconfig.dramblocks */
		bootconfig_dram(&bootconfig, &memstart, &memsize);

		/*
		 * Set up the variables that define the availablilty of
		 * physical memory.
		 *
		 * XXX pmap_bootstrap() needs an enema.
		 */
		physical_start = bootconfig.dram[0].address;
		physical_end = MIN((uint64_t)physical_start +
		    (bootconfig.dram[0].pages * PAGE_SIZE), (paddr_t)-PAGE_SIZE);
	}

d479 2
a480 2
	physical_freestart = (((unsigned long)esym - KERNEL_TEXT_BASE +0xfff) & ~0xfff) + loadaddr;
	physical_freeend = MIN((uint64_t)memstart+memsize, (paddr_t)-PAGE_SIZE);
d581 3
a583 5
	if (fdt_get_size(config) != 0) {
		uint32_t size = fdt_get_size(config);
		valloc_pages(fdt, round_page(size) / PAGE_SIZE);
		memcpy((void *)fdt.pv_pa, config, size);
	}
a586 1
	 * XXX used by the RedBoot page tables.
d676 3
a678 4
	if (fdt.pv_va && fdt.pv_pa)
		pmap_map_chunk(l1pagetable, fdt.pv_va, fdt.pv_pa,
		    round_page(fdt_get_size((void *)fdt.pv_pa)),
		    PROT_READ | PROT_WRITE, PTE_CACHE);
d741 1
a741 2
	if (fdt.pv_va && fdt.pv_pa)
		fdt_init((void *)fdt.pv_va);
d763 3
a765 1
	physsegs = MIN(bootconfig.dramblocks, physsegs);
d767 5
a771 7
	for (i = 1; i < physsegs; i++) {
		paddr_t dramstart = bootconfig.dram[i].address;
		paddr_t dramend =  MIN((uint64_t)dramstart +
		    bootconfig.dram[i].pages * PAGE_SIZE, (paddr_t)-PAGE_SIZE);
		physmem += (dramend - dramstart) / PAGE_SIZE;
		uvm_page_physload(atop(dramstart), atop(dramend),
		    atop(dramstart), atop(dramend), 0);
a931 18
	}
}

void
bootconfig_dram(BootConfig *bootconfig, psize_t *memstart, psize_t *memsize)
{
	int loop;

	if (bootconfig->dramblocks == 0) 
		panic("%s: dramblocks not set up!", __func__);

	*memstart = bootconfig->dram[0].address;
	*memsize = bootconfig->dram[0].pages * PAGE_SIZE;
	printf("memory size derived from u-boot\n");
	for (loop = 0; loop < bootconfig->dramblocks; loop++) {
		printf("bootconf.mem[%d].address = %08x pages %d/0x%08x\n",
		    loop, bootconfig->dram[loop].address, bootconfig->dram[loop].pages,
			bootconfig->dram[loop].pages * PAGE_SIZE);
@


1.32
log
@Remove the restriction that the kernel needs to be loaded at the bottom of
physical memory.  This makes it possible to boot OpenBSD on platforms that
have physical memory start at address 0x00000000 as the EFI bootloader will
only attempt to load kernels at address 0x10000000 and above to work around
a bug in the u-boot EFI API layer.

ok patrick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: armv7_machdep.c,v 1.31 2016/06/14 10:03:51 kettenis Exp $ */
d453 1
a453 1
		struct fdt_memory mem;
d457 1
a457 1
		if (node == NULL || fdt_get_memory_address(node, 0, &mem))
d460 4
a463 4
		memstart = mem.addr;
		memsize = mem.size;
		physical_start = mem.addr;
		physical_end = MIN(mem.addr + mem.size, (paddr_t)-PAGE_SIZE);
@


1.31
log
@Make fdt_node_property() return -1 if the requested property can't be found
such that we can distinguish between non-existing properties and zero-length
properties.  This brings the FDT code in line with the real OFW
implementations.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: armv7_machdep.c,v 1.30 2016/06/12 01:01:12 jsg Exp $ */
d388 1
a388 1
	int loop, loop1, i, physsegs;
d392 1
d403 1
d519 1
a519 1
	physical_freestart = (((unsigned long)esym - KERNEL_TEXT_BASE +0xfff) & ~0xfff) + memstart;
d562 1
a562 1
	(var).pv_va = KERNEL_BASE + (var).pv_pa - physical_start;
d682 1
a682 1
		    physical_start + logical, textsize,
d685 1
a685 1
		    physical_start + logical, totalsize - textsize,
d802 7
a808 1
	physsegs = MIN(bootconfig.dramblocks, VM_PHYSSEG_MAX);
@


1.30
log
@Ignore everything after and including ':' in stdout-path when
finding the console node.  Characters after this are device specific
settings (baud etc).

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: armv7_machdep.c,v 1.29 2016/06/08 15:27:05 jsg Exp $ */
d915 1
a915 1
		if (fdt_node_property(node, "stdout-path", &stdout)) {
@


1.29
log
@Use fdt to find the console to initialise.  Try to use /chosen/stdout-path
if present otherwise fallback to /aliases/serial0.

Don't require a platform match to run the various console init functions
so the init functions will run for unknown board ids.

With and ok kettenis@@ on a earlier version.
@
text
@d1 1
a1 1
/*	$OpenBSD: armv7_machdep.c,v 1.28 2016/06/04 18:09:16 jsg Exp $ */
d907 1
d909 1
d916 6
@


1.28
log
@Remove model specific strings keyed off the board id.
We now pull the model string from fdt.
@
text
@d1 1
a1 1
/*	$OpenBSD: armv7_machdep.c,v 1.27 2016/05/20 11:21:08 kettenis Exp $ */
d901 36
@


1.27
log
@For FDT-based boots, look for a "openbsd,bootduid" property of the /chosen
node.  If it is present, copy its value into the bootduid variable for
DUID-based boot disk selection.

ok patrick@@, jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: armv7_machdep.c,v 1.26 2016/04/03 12:44:37 patrick Exp $ */
d486 1
a486 1
	printf("\n%s booting ...\n", platform_boot_name());
@


1.26
log
@Map the bootconfig/FDT area passed by u-boot and try to init FDT on it.
If we were passed an FDT, we can completely map the tree and later on
copy it somewhere in our control, so it's not overwritten by anything.

If we are passed a device tree, we need to grab the information we
otherwise would get from the bootinfo struct in another way.  We can use
the /memory node to parse the machine's memory information.  Bootargs are
stored in /chosen's bootargs property.

This allows us to boot up like before using the board id, but now also
allows us to make use of device tree information.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: armv7_machdep.c,v 1.25 2016/01/31 01:04:24 jsg Exp $ */
d465 10
a474 3
			char *bootargs;
			if (fdt_node_property(node, "bootargs", &bootargs))
				process_kernel_args(bootargs);
@


1.25
log
@Leonardo Guardati discovered a u-boot built with "Enable workarounds for
booting old kernels" was required to boot sunxi kernels with newer
versions of u-boot.

Unless built with OLD_SUNXI_KERNEL_COMPAT u-boot now uses the top four
bits of the board id for a 'compatibility revision'.  This was
supposedly for different handling of the pll5 dram clock, but we don't
touch that currently.  Mask these bits away so the kernel will boot from
a u-boot that doesn't have the option set.

Tested by Patrick Wildt on a Banana Pi R1 with current u-boot sources.
@
text
@d1 1
a1 1
/*	$OpenBSD: armv7_machdep.c,v 1.24 2015/05/19 03:30:54 jsg Exp $ */
d133 1
d391 1
d394 1
d429 43
a481 1
	parse_uboot_tags(arg2);
d483 23
a505 5
	/*
	 * Examine the boot args string for options we need to know about
	 * now.
	 */
	process_kernel_args(bootconfig.bootstring);
d507 1
a507 1
        boothowto |= RB_DFLTROOT;
d510 2
a511 24
	/* normally u-boot will set up bootconfig.dramblocks */
	bootconfig_dram(&bootconfig, &memstart, &memsize);

	/*
	 * Set up the variables that define the availablilty of
	 * physical memory.  For now, we're going to set
	 * physical_freestart to 0xa0200000 (where the kernel
	 * was loaded), and allocate the memory we need downwards.
	 * If we get too close to the page tables that RedBoot
	 * set up, we will panic.  We will update physical_freestart
	 * and physical_freeend later to reflect what pmap_bootstrap()
	 * wants to see.
	 *
	 * XXX pmap_bootstrap() needs an enema.
	 */
	physical_start = bootconfig.dram[0].address;
	physical_end = MIN((uint64_t)physical_start +
	    (bootconfig.dram[0].pages * PAGE_SIZE), (paddr_t)-PAGE_SIZE);

	{
		physical_freestart = (((unsigned long)esym - KERNEL_TEXT_BASE +0xfff) & ~0xfff) + memstart;
		physical_freeend = MIN((uint64_t)memstart+memsize,
		    (paddr_t)-PAGE_SIZE);
	}
d610 9
d709 6
d774 4
@


1.24
log
@Abstract the soc_machdep.c functions to allow a kernel to be built for
multiple socs.

From Patrick Wildt in bitrig with some additional changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: armv7_machdep.c,v 1.23 2015/05/19 00:05:59 jsg Exp $ */
d400 6
@


1.23
log
@use the same va entry point on all armv7 socs
Similiar changes were made in bitrig by Patrick Wildt.

As part of this change the physical load address for imx and sunxi have
changed.  Any u-boot settings that include it will need to be modified.

imx: 0x10800000 -> 0x10300000
sunxi: 0x40800000 -> 0x40300000

Tested by bmercer, canacar and myself.
ok bmercer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: armv7_machdep.c,v 1.22 2015/05/15 15:35:43 jsg Exp $ */
a406 2
	platform_disable_l2_if_needed();

d420 3
d427 1
a427 1
	printf("\n%s booting ...\n", platform_boot_name);
@


1.22
log
@Make board attaching table driven and move it out into the soc
directories.  Move the device tables while here as was done in bitrig.
With these changes the only use of the board id defines is in the soc
directories.

Tested by matthieu and djm on imx and myself on omap and sunxi (qemu).
ok djm@@, ok jasper@@ on an earlier version
@
text
@d1 1
a1 1
/*	$OpenBSD: armv7_machdep.c,v 1.21 2015/05/12 04:31:10 jsg Exp $ */
d212 1
d441 1
a441 1
	platform_bootconfig_dram(&bootconfig, &memstart, &memsize);
d851 18
@


1.21
log
@Raise VM_PHYSSEG_MAX to two and load an additional physical memory
segment if u-boot reports it.  Needed for the utilite where u-boot
reports two 1GB segments of physical memory.

From Patrick Wildt in bitrig with some additional sanity checks added.
@
text
@d1 1
a1 1
/*	$OpenBSD: armv7_machdep.c,v 1.20 2015/05/10 15:56:28 jsg Exp $ */
d758 1
a758 1
	platform_print_board_type();
@


1.20
log
@VM_MAX_KERNEL_ADDRESS is the end of the kva range not the end of
addressable virtual memory space but arm ports were using a value of
0xffffffff for this.

Instead of using a shared VM_MAX_KERNEL_ADDRESS define add md
VM_KERNEL_SPACE_SIZE defines based on the KERNEL_VM_SIZE values
from the respective machdep.c files.

djm's novena was hitting "panic: bufinit: can't reserve VM for buffers"
without a similiar change.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: armv7_machdep.c,v 1.19 2015/05/10 05:42:46 jsg Exp $ */
d386 1
a386 2
	int loop;
	int loop1;
d724 11
@


1.19
log
@limit physical memory to (paddr_t)-PAGE_SIZE (0xfffff000)

novena has 4GB of physical memory and it's u-boot tells us
memstart: 0x10000000
memsize:  0xf0000000

which would previously cause an overflow leading to
"panic: initarm: out of memory"

tweak from and ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: armv7_machdep.c,v 1.18 2015/01/18 10:17:42 jsg Exp $ */
d141 1
a141 9

/*
 * The range 0xc1000000 - 0xccffffff is available for kernel VM space
 * Core-logic registers and I/O mappings occupy 0xfd000000 - 0xffffffff
 */
/*
#define KERNEL_VM_SIZE		0x0C000000
*/
#define KERNEL_VM_SIZE		0x10000000
@


1.18
log
@unifdef IPKDB.  These codepaths are holdouts from NetBSD code and are
not used.
@
text
@d1 1
a1 1
/*	$OpenBSD: armv7_machdep.c,v 1.17 2014/12/10 15:29:53 mikeb Exp $ */
d464 2
a465 1
	physical_end = physical_start + (bootconfig.dram[0].pages * PAGE_SIZE);
d469 2
a470 1
		physical_freeend = memstart+memsize;
@


1.17
log
@retire shutdown hooks; ok deraadt, krw
@
text
@d1 1
a1 1
/*	$OpenBSD: armv7_machdep.c,v 1.16 2014/11/16 12:30:56 deraadt Exp $ */
a159 3
#ifdef IPKDB
#define UND_STACK_SIZE	2
#else
a160 1
#endif
a738 6
#ifdef IPKDB
	/* Initialise ipkdb */
	ipkdb_init();
	if (boothowto & RB_KDB)
		ipkdb_connect(0);
#endif
@


1.16
log
@Replace a plethora of historical protection options with just
PROT_NONE, PROT_READ, PROT_WRITE, and PROT_EXEC from mman.h.
PROT_MASK is introduced as the one true way of extracting those bits.
Remove UVM_ADV_* wrapper, using the standard names.
ok doug guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: armv7_machdep.c,v 1.15 2014/09/20 09:28:24 kettenis Exp $ */
a253 1
		doshutdownhooks();
a289 1
	doshutdownhooks();
@


1.15
log
@Use config_suspend_all(9).

ok mpi@@, uebayasi@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: armv7_machdep.c,v 1.14 2014/07/21 17:25:47 uebayasi Exp $ */
d358 1
a358 1
		    VM_PROT_READ | VM_PROT_WRITE, PTE_NOCACHE);
d629 1
a629 1
		    VM_PROT_READ|VM_PROT_WRITE|VM_PROT_EXECUTE, PTE_CACHE);
d632 1
a632 1
		    VM_PROT_READ|VM_PROT_WRITE, PTE_CACHE);
d641 1
a641 1
	    IRQ_STACK_SIZE * PAGE_SIZE, VM_PROT_READ|VM_PROT_WRITE, PTE_CACHE);
d643 1
a643 1
	    ABT_STACK_SIZE * PAGE_SIZE, VM_PROT_READ|VM_PROT_WRITE, PTE_CACHE);
d645 1
a645 1
	    UND_STACK_SIZE * PAGE_SIZE, VM_PROT_READ|VM_PROT_WRITE, PTE_CACHE);
d647 1
a647 1
	    UPAGES * PAGE_SIZE, VM_PROT_READ | VM_PROT_WRITE, PTE_CACHE);
d650 1
a650 1
	    L1_TABLE_SIZE, VM_PROT_READ | VM_PROT_WRITE, PTE_PAGETABLE);
d655 1
a655 1
		    VM_PROT_READ|VM_PROT_WRITE, PTE_PAGETABLE);
d662 1
a662 1
	    VM_PROT_READ|VM_PROT_WRITE|VM_PROT_EXECUTE, PTE_CACHE);
@


1.14
log
@boot(9): Reduce annoying style diffs

- Always use either: ((x & RB_XXX) != 0) or ((x & RB_XXX) == 0) in boolean
  context (mostly if (x), or x ? y : z)
  - prom_halt() in alpha is confirmed to take int as boolean

Converted by coccinelle.  No functional change intended.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a247 1
	struct device *mainbus;
a252 2
	mainbus = device_mainbus();

d255 1
a255 2
		if (mainbus != NULL)
			config_suspend(mainbus, DVACT_POWERDOWN);
d292 1
a292 2
	if (mainbus != NULL)
		config_suspend(mainbus, DVACT_POWERDOWN);
@


1.13
log
@boot(9): Cosmetic changes to improve diff'ability.
@
text
@d283 1
a283 1
	if (!(howto & RB_NOSYNC))
d302 2
a303 3
	if (howto & RB_HALT) {
		if (howto & RB_POWERDOWN) {

@


1.12
log
@Cosmetic changes to reduce diffs.
@
text
@d319 2
a320 2
	while(1);
	/*NOTREACHED*/
@


1.11
log
@Set cold to 1 before executing the DVACT_POWERDOWN handlers when halting or
rebooting a machine, like it is done in the hibernate case.

At least some USB host controller drivers rely on this to busy way instead
of sleeping.  Avoid a panic on macppc with an uhci(4) cardbus plugged in.

ok deraadt@@, uebayashi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: armv7_machdep.c,v 1.10 2014/07/10 20:37:41 uebayasi Exp $ */
d289 1
a289 1
	splhigh();		/* Disable interrupts. */
a291 1
	/* Do a dump if requested. */
a294 1
	/* Run any shutdown hooks */
@


1.10
log
@boot(9): More comment removal about cold/savectx() missed in previous
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d289 2
a290 3

	/* Say NO to interrupts */
	splhigh();
@


1.9
log
@boot(): Unify declarations

OK deraadt@@
@
text
@a255 4
	/*
	 * If we are still cold then hit the air brakes
	 * and crash to earth fast
	 */
@


1.8
log
@Revert previous diff setting cold to 1 on shutdown because it breaks machine
with softraid(4) disks.

softraid(4) is the last real consumer of the doshutdownhooks(9) API and it is
not trivial to convert its hook to a DVACT_POWERDOWN handler since the latter
does not allow to sleep.
@
text
@d1 1
a1 1
/*	$OpenBSD: armv7_machdep.c,v 1.7 2014/05/30 13:46:16 mpi Exp $ */
d245 1
a245 1
void
@


1.7
log
@Set cold to 1 before executing the DVACT_POWERDOWN handlers when halting or
rebooting a machine, like it is done in the hibernate case.

At least some USB host controller drivers rely on this to busy way instead
of sleeping.  Avoid a panic on macppc with an uhci(4) cardbus plugged in.

ok deraadt@@, uebayashi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: armv7_machdep.c,v 1.6 2014/03/29 18:09:28 guenther Exp $ */
d293 3
a295 2
	splhigh();		/* Disable interrupts. */
	cold = 1;
@


1.6
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: armv7_machdep.c,v 1.5 2014/03/13 03:52:55 dlg Exp $ */
d293 2
a294 3

	/* Say NO to interrupts */
	splhigh();
@


1.5
log
@get rid of the assumption that the head of the alldevs list is the
"mainbus" device. this breaks when mpath is enabled because it
attaches before mainbus and therefore takes the head position.

have autoconf provide device_mainbus() which looks up mainbus_cd,
and use that instead.

discussed with deraadt who just wants mpath stuff to move forward
despite there being many ways to shine this particular turd.
@
text
@d1 1
a1 1
/*	$OpenBSD: armv7_machdep.c,v 1.4 2013/11/13 17:30:44 syl Exp $ */
d336 1
a336 1
  __asm __volatile("mrc	p15, 0, %0, c2, c0, 0" : "=r" (ttb));
@


1.4
log
@Add missing includes.
Unbreak armv7 compilation.

ok rapha@@
"commit the fix" from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: armv7_machdep.c,v 1.3 2013/11/13 07:03:11 uebayasi Exp $ */
d248 1
d254 2
d262 2
a263 2
		if (!TAILQ_EMPTY(&alldevs))
			config_suspend(TAILQ_FIRST(&alldevs), DVACT_POWERDOWN);
d303 2
a304 2
	if (!TAILQ_EMPTY(&alldevs))
		config_suspend(TAILQ_FIRST(&alldevs), DVACT_POWERDOWN);
@


1.3
log
@boot(): Don't forget calling if_downall() and uvm_shutdown() on arm ports.

"Unification good" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d120 1
a120 1

d133 2
@


1.2
log
@fix bootstrap_bs_map to map more than one section.

ok patrick@@, fgsch@@
@
text
@d1 1
a1 1
/*	$OpenBSD: armv7_machdep.c,v 1.1 2013/10/30 20:20:23 syl Exp $ */
d284 4
@


1.1
log
@Put all the generic machdep code in armv7_machedep.c

Cleanup the machdep code removing:
- useless includes
- useless globals and prototypes
- useless #if 0 and #if 1
- some style(9) issues

This commit will make the bringup of new SoC easier.

ok patrick@@ jasper@@ rapha@@
@
text
@d1 1
a1 1
/*	$OpenBSD: beagle_machdep.c,v 1.2 2013/09/28 14:16:41 miod Exp $ */
d217 2
d338 1
a338 1
 * size and cacheability are ignored and map one section with nocache.
a341 2
int bootstrap_bs_map(void *t, bus_addr_t bpa, bus_size_t size,
    int flags, bus_space_handle_t *bshp);
d346 1
a346 1
	u_long startpa;
a351 1
	section_free += L1_S_SIZE;
a352 3
	/*
	startpa = trunc_page(bpa);
	*/
d354 10
a363 2
	pmap_map_section((vaddr_t)pagedir, va, startpa,
	    VM_PROT_READ | VM_PROT_WRITE, PTE_NOCACHE);
d366 1
a366 1
	*bshp = (bus_space_handle_t)(va + (bpa - startpa));
d368 1
a368 1
	return(0);
@

