head	1.14;
access;
symbols
	OPENBSD_6_2:1.14.0.4
	OPENBSD_6_2_BASE:1.14
	OPENBSD_6_1:1.13.0.4
	OPENBSD_6_1_BASE:1.13
	OPENBSD_6_0:1.6.0.2
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.5.0.2
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.3.0.4
	OPENBSD_5_8_BASE:1.3
	OPENBSD_5_7:1.2.0.2
	OPENBSD_5_7_BASE:1.2
	OPENBSD_5_6:1.2.0.6
	OPENBSD_5_6_BASE:1.2
	OPENBSD_5_5:1.2.0.4
	OPENBSD_5_5_BASE:1.2;
locks; strict;
comment	@# @;


1.14
date	2017.06.14.13.12.49;	author patrick;	state Exp;
branches;
next	1.13;
commitid	MrUJFiQ4a9fNTd1z;

1.13
date	2017.01.07.15.44.28;	author kettenis;	state Exp;
branches;
next	1.12;
commitid	dSbWh4CwdCtEl7lY;

1.12
date	2016.10.09.23.46.23;	author jsg;	state Exp;
branches;
next	1.11;
commitid	81NzNvE8jnVEgl5T;

1.11
date	2016.10.09.11.01.31;	author jsg;	state Exp;
branches;
next	1.10;
commitid	A23m4Bfb2UOb2aia;

1.10
date	2016.09.24.13.43.25;	author kettenis;	state Exp;
branches;
next	1.9;
commitid	K8bvq8OtVadfpwkG;

1.9
date	2016.08.26.11.59.04;	author kettenis;	state Exp;
branches;
next	1.8;
commitid	eHAV7iG810DcGo8p;

1.8
date	2016.08.18.09.28.22;	author kettenis;	state Exp;
branches;
next	1.7;
commitid	ryjYlYdRzLtqz6LU;

1.7
date	2016.07.26.18.09.07;	author kettenis;	state Exp;
branches;
next	1.6;
commitid	5uhRXsGuhTSkEB7m;

1.6
date	2016.04.25.04.46.57;	author jsg;	state Exp;
branches;
next	1.5;
commitid	XqdsV6PrfEUXwK4U;

1.5
date	2016.01.31.00.14.50;	author jsg;	state Exp;
branches;
next	1.4;
commitid	pbLjedMudUFrVMk6;

1.4
date	2016.01.23.15.38.48;	author jsg;	state Exp;
branches;
next	1.3;
commitid	aAkwV289kfxjTudu;

1.3
date	2015.05.18.23.56.47;	author jsg;	state Exp;
branches;
next	1.2;
commitid	qT2BOSH2K1QhmA5v;

1.2
date	2014.02.01.21.45.17;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2013.09.04.14.38.25;	author patrick;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Split early startup code out of armv7_start.S into locore0.S.  Adjust
link run so that this locore0.o is always at the start of the
executable.  But randomize the link order of all other .o files in the
kernel, so that their exec/rodata/data/bss segments land all over the
place.  Note that this commit does not yet unmap the early bootcode
since this is not as easy as on arm64.

As a result, the internal layout of every newly build bsd kernel is
different from past kernels.  Internal relative offsets are not known
to an outside attacker.  The only known offsets are in the startup code,
which has been unmapped.

Ramdisk kernels cannot be compiled like this, because they are gzip'd.
When the internal pointer references change, the compression dictionary
bloats and results in poorer compression.

With guidance and ok deraadt@@
@
text
@/*	$OpenBSD: armv7_start.S,v 1.13 2017/01/07 15:44:28 kettenis Exp $	*/
/*	$NetBSD: lubbock_start.S,v 1.1 2003/06/18 10:51:15 bsh Exp $ */

/*
 * Copyright (c) 2002, 2003  Genetec Corporation.  All rights reserved.
 * Written by Hiroyuki Bessho for Genetec Corporation.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of Genetec Corporation may not be used to endorse or 
 *    promote products derived from this software without specific prior
 *    written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY GENETEC CORPORATION ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL GENETEC CORPORATION
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <machine/asm.h>
#include <arm/sysreg.h>
#include <arm/armreg.h>
#include <arm/pte.h>

#undef	DOMAIN_CLIENT	/* XXX */
#include "assym.h"

#define HVC	.word	0xe1400070		@@ hvc

	.text

ENTRY(smc_call)
	smc	#0
	bx	lr

ENTRY(hvc_call)
	HVC
	bx	lr

/*-
 * Copyright (c) 2011
 *	Ben Gray <ben.r.gray@@gmail.com>.
 * All rights reserved.
 *
 * Based heavily on the Linux OMAP secure API
 *    Copyright (C) 2010 Texas Instruments, Inc.
 *    Written by Santosh Shilimkar <santosh.shilimkar@@ti.com>
 *
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 *	omap4_smc_call - issues a secure monitor API call
 *	@@r0: contains the monitor API number
 *	@@r1: contains the value to set
 * 
 *	This function will send a secure monitor call to the internal rom code in
 *	the trust mode. The rom code expects that r0 will contain the value and 
 *	r12 will contain the API number, so internally the function swaps the
 *	register settings around.  The trust mode code may also alter all the cpu
 *	registers so everything (including the lr register) is saved on the stack
 *	before the call.
 *
 *	RETURNS:
 *	nothing
 */
ENTRY(omap4_smc_call)
	stmfd   sp!, {r2-r12, lr}
	mov     r12, r0
	mov     r0, r1
	dsb	sy
	smc     #0
	ldmfd   sp!, {r2-r12, pc}
@


1.13
log
@Fill bootstrap translation table with zeroes before we use it and don't map
the vectors page at address 0 as we don't put them there.

ok patrick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: armv7_start.S,v 1.12 2016/10/09 23:46:23 jsg Exp $	*/
a40 2
#define ELR	.long	0xe12ef30e		@@ msr	ELR_hyp, lr
#define ERET	.long	0xe160006e		@@ eret
a41 153

/*
 * CPWAIT -- Canonical method to wait for CP15 update.
 * NOTE: Clobbers the specified temp reg.
 * copied from arm/arm/cpufunc_asm_xscale.S
 * XXX: better be in a common header file.
 */
#define	CPWAIT_BRANCH							 \
	sub	pc, pc, #4

#define	CPWAIT(tmp)							 \
	mrc	CP15_TTBR0(tmp)		/* arbitrary read of CP15 */	;\
	mov	tmp, tmp		/* wait for it to complete */	;\
	CPWAIT_BRANCH			/* branch to next insn */
	
/*
 * Kernel start routine for OMAP
 * this code is excuted at the very first after the kernel is loaded
 * by U-Boot.
 *
 * This code makes a number of assumptions.
 * 1) it is running in RAM.
 * 2) it is run at a fairly well known offset from the beginning of
 *    a ram section.
 * 3) the memory region around the kernel will be at least about 32MB
 * 4) memory just below the kernel can be used by the kernel
 * 5) memory at the start of the ram section may not be useable
 *    it may contain bootloader/u-boot
 * 6) the fdt/kernel parameters in arg r0-r2 may point outside the
 *    32MB of ram (it likely should be copied very early)
 *
 */
	.text

	.global	_C_LABEL(bootstrap_start)
_C_LABEL(bootstrap_start):
	/* Save U-Boot arguments */
	mov	r6, r0
	mov	r7, r1
	mov	r8, r2

	/*
	 *  Kernel is loaded in SDRAM (0xX0200000..), and is expected to run
	 *  in VA 0xc0200000..
	 *
	 * which base memory address the kernel is located is unknown
	 * however the kernel should be located at 0x00300000 offset
	 * from that ram area. copy the PC into a register and strip
	 * the low bits
	 */

	/*
	 * If we are running in HYP mode, try to get to SVC safely.
	 * Ensure IRQ, FIQ and Aborts are disabled in HYP mode before
	 * going to SVC.  If we are there already, just go ahead.
	 */
	mrs	r0, cpsr
	and	r0, r0, #(PSR_MODE)
	teq	r0, #(PSR_HYP32_MODE)
	bne	1f			/* If we are not in HYP, we're done */
	mrs	r0, cpsr
	bic	r0, r0, #(PSR_MODE)
	orr	r0, r0, #(PSR_SVC32_MODE)
	orr	r0, r0, #(PSR_I | PSR_F | PSR_A)
	msr	spsr_fsxc, r0
	adr	lr, 1f
	ELR
	ERET				/* Use the HYP LR to get into SVC */
1:

	/*
	 * Now that we are in SVC, build up pagetables and start up.
	 */
	mov r9, pc
	and r9, r9, #0xf0000000	// Leave the memory base in r9

	/* create the bootstrap MMU table at offset 0x00200000 */
	orr	r0, r9, #0x00200000
	mov	r3, #0
	mov	r2, #0
2:
	str	r3, [r0, r2]
	add	r2, r2, #4
	cmp	r2, #(L1_TABLE_SIZE)
	bne	2b

	adr	r4, mmu_init_table

	mov	r2, r9, lsr #18
	ldr	r3, [r4, #8]
	bic	r3, r3, #0xf0000000
	orr	r3, r3, r9
	str	r2, [r4, #4]
	str	r3, [r4, #8]
	str	r3, [r4, #0x14] // ram address for 0xc0000000

	/*
	 * the first entry has two fields that need to be updated for
	 * specific ram configuration of this board.
	 */
	b	4f

3:
	str	r3, [r0, r2]
	add	r2, r2, #4
	add	r3, r3, #(L1_S_SIZE)
	adds	r1, r1, #-1
	bhi	3b
4:	
	ldmia	r4!, {r1,r2,r3}   /* # of sections, PA|attr, VA */
	cmp	r1, #0
	bne	3b	

	mcr	CP15_TTBR0(r0)		/* Set TTB */
	mcr	CP15_TLBIALL(r0)	/* Flush TLB */

	/* Set the Domain Access register.  Very important! */
	mov     r0, #DOMAIN_CLIENT	/* We only use domain 0 */
	mcr	CP15_DACR(r0)	

	/* Enable MMU */
	mrc	CP15_SCTLR(r0)	
	orr	r0, r0, #CPU_CONTROL_MMU_ENABLE
	mcr	CP15_SCTLR(r0)	
	CPWAIT(r0)

	/* Restore U-Boot arguments */
	mov	r0, r6
	mov	r1, r7
	mov	r2, r8
	mov	r3, r9

	/* Jump to kernel code in TRUE VA */
	adr	r6, Lstart
	ldr	pc, [r6]

Lstart:
	.word	start

#define MMU_INIT(va,pa,n_sec,attr) \
	.word	n_sec					    ; \
	.word	4*((va)>>L1_S_SHIFT)			    ; \
	.word	(pa)|(attr)				    ;

mmu_init_table:
	/* map SDRAM VA==PA, WT cacheable */
	MMU_INIT(0x00000000, 0x00000000, 64,
		 L1_TYPE_S|L1_S_C|L1_S_V7_AP(AP_KRW)|L1_S_V7_AF)
	/* map VA 0xc0000000..0xc3ffffff to PA */
	MMU_INIT(0xc0000000, 0x00000000, 64,
		 L1_TYPE_S|L1_S_C|L1_S_V7_AP(AP_KRW)|L1_S_V7_AF)

	.word 0	/* end of table */
@


1.12
log
@Add psci(4) a driver for the reset and power down portion of the
ARM Power State Coordination Interface (PSCI) specification.

Tested with qemu-system-arm -M virt.

Feedback from patrick@@, ok kettenis@@ tom@@
@
text
@d1 1
a1 1
/*	$OpenBSD: armv7_start.S,v 1.11 2016/10/09 11:01:31 jsg Exp $	*/
d122 8
a138 2
	add	r3, r3, #0x01000000
	str	r3, [r4, #0x20] // ram address for 0x00000000 (vectors)
d144 1
a144 1
	b	3f
d146 1
a146 1
2:
d151 2
a152 2
	bhi	2b
3:	
d155 1
a155 1
	bne	2b	
d192 1
a192 2
mmu_init_table2:	
	/* map VA 0xc0000000..0xc3ffffff to PA 0xa0000000..0xa3ffffff */
a193 2
		 L1_TYPE_S|L1_S_C|L1_S_V7_AP(AP_KRW)|L1_S_V7_AF)
	MMU_INIT(0x00000000, 0x00000000, 1,
@


1.11
log
@Change raw dsb and smc opcodes to instructions.  The dsb encoding did
not set an option where as having just a 'dsb' instruction results in
the 'sy'/full system option being set.

Unknown/reserved options are supposed to result in a full system dsb
but the ARM ARM specifically calls this out as something software
should not rely on.

ok patrick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: armv7_start.S,v 1.10 2016/09/24 13:43:25 kettenis Exp $	*/
d43 1
d196 8
@


1.10
log
@If the value of r0 upon entering the kernel is zero, interpret this as the
address of the end of the symbol table.  This will make it possible to get
rid of the code in the bootloader that patches up the kernel with the updated
esym value.

ok tom@@, patrick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: armv7_start.S,v 1.9 2016/08/26 11:59:04 kettenis Exp $	*/
d248 2
a249 10
#if 0
	dsb
#else
	.word	0xf57ff040
#endif
#if 0
	smc     #0	/* XXX or #1 ??? */
#else
	.word	0xe1600070
#endif
a250 1

@


1.9
log
@Remove the code that switches around MMU domains on armv7.  MMU domains are
basically a relic from the past.  Using them doesn't make a lot of sense
the way our pmaps work.  Support for MMU domains isn't present in
long-descriptor translation table format, so it is clearly on its way out.

Based on a diff from Artituri Alm.

ok patrick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: armv7_start.S,v 1.8 2016/08/18 09:28:22 kettenis Exp $	*/
d164 1
a164 1
	mov	r0, r9
d167 1
@


1.8
log
@Separate out the Access Flag bit from the Access Permission bits in the
armv7 pmap.

ok tom@@
@
text
@d1 1
a1 1
/*	$OpenBSD: armv7_start.S,v 1.7 2016/07/26 18:09:07 kettenis Exp $	*/
d154 1
a154 1
        mov     r0, #((DOMAIN_CLIENT << (PMAP_DOMAIN_KERNEL*2)) | DOMAIN_CLIENT)
@


1.7
log
@Remove the restriction that the kernel needs to be loaded at the bottom of
physical memory.  This makes it possible to boot OpenBSD on platforms that
have physical memory start at address 0x00000000 as the EFI bootloader will
only attempt to load kernels at address 0x10000000 and above to work around
a bug in the u-boot EFI API layer.

ok patrick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: armv7_start.S,v 1.6 2016/04/25 04:46:57 jsg Exp $	*/
d182 2
a183 1
	MMU_INIT(0x00000000, 0x00000000, 64, L1_TYPE_S|L1_S_C|L1_S_V7_AP(AP_KRW))
d186 4
a189 2
	MMU_INIT(0xc0000000, 0x00000000, 64, L1_TYPE_S|L1_S_C|L1_S_V7_AP(AP_KRW))
	MMU_INIT(0x00000000, 0x00000000, 1, L1_TYPE_S|L1_S_C|L1_S_V7_AP(AP_KRW))
@


1.6
log
@Switch most of the cp14/cp15 use in .S files over to using sysreg.h

Matched and changed by a script, verified to cause no binary change with
armv7, armish, and zaurus kernels.

ok patrick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: armv7_start.S,v 1.5 2016/01/31 00:14:50 jsg Exp $	*/
d164 1
a164 1
	mov	r0, r6
@


1.5
log
@Switch from PSR_X_bit and X32_bit PSR macro names to just PSR_X.
This matches FreeBSD and makes things a bit more consistent.
Discussed with Patrick.
@
text
@d1 1
a1 1
/*	$OpenBSD: armv7_start.S,v 1.4 2016/01/23 15:38:48 jsg Exp $	*/
d34 1
d54 1
a54 1
	mrc	p15, 0, tmp, c2, c0, 0	/* arbitrary read of CP15 */	;\
d150 2
a151 2
	mcr	p15, 0, r0, c2, c0, 0	/* Set TTB */
	mcr	p15, 0, r0, c8, c7, 0	/* Flush TLB */
d155 1
a155 1
	mcr	p15, 0, r0, c3, c0, 0
d158 1
a158 1
	mrc	p15, 0, r0, c1, c0, 0
d160 1
a160 1
	mcr	p15, 0, r0, c1, c0, 0
@


1.4
log
@In some cases machines with virtualisation extensions will boot into a
HYP processor mode that has different memory management and register
behaviour among other things.  In this case switch to SVC mode to
prevent an early crash.

From Patrick Wildt based on code in FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: armv7_start.S,v 1.3 2015/05/18 23:56:47 jsg Exp $	*/
d105 1
a105 1
	orr	r0, r0, #(I32_bit | F32_bit | A32_bit)
@


1.3
log
@Make armv7 startup PIC. From Dale Rahn in bitrig.
Tested by bmercer, canacar and myself.
ok bmercer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: armv7_start.S,v 1.2 2014/02/01 21:45:17 miod Exp $	*/
d40 3
d93 22
a118 2

	/* build page table from scratch */
@


1.2
log
@Do not include <machine/pmap.h> from .S code, for it brings much too .S-unaware
headers. Instead, rely upon "assym.h" bringing the defines we need from it.
Found the hard way by nick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: armv7_start.S,v 1.1 2013/09/04 14:38:25 patrick Exp $	*/
a39 4
#ifndef SDRAM_START
#define SDRAM_START	0x80000000
#endif

d58 12
d80 8
a87 6
	/* Are we running on ROM ? */
	cmp     pc, #0x06000000
	bhi     bootstrap_start_ram

	/* move me to RAM
	 * XXX: we can use memcpy if it is PIC
a88 26
	ldr r1, Lcopy_size
	adr r0, _C_LABEL(bootstrap_start)
	add r1, r1, #3
	mov r1, r1, LSR #2
	mov r2, #SDRAM_START
	add r2, r2, #0x00200000
	mov r4, r2

5:	ldr r3,[r0],#4
	str r3,[r2],#4
	subs r1,r1,#1
	bhi 5b

	cmp	pc, r5
	/* Jump to RAM */
	ldr r0, Lstart_off

	blo 1f
	/* if we were running out of virtual mapped space, disable mmu */
	mov	r2, #0
	mov     r1, #(CPU_CONTROL_32BP_ENABLE | CPU_CONTROL_32BD_ENABLE)
	mcr     15, 0, r1, c1, c0, 0
	mcrne   15, 0, r2, c8, c7, 0    /* nail I+D TLB on ARMv4 and greater */
	
1:
	add pc, r4, r0
d90 2
a91 2
Lcopy_size:	.word _edata-_C_LABEL(bootstrap_start)
Lstart_off:	.word bootstrap_start_ram-_C_LABEL(bootstrap_start)
d93 1
a93 17
bootstrap_start_ram:	
	/*
	 *  Kernel is loaded in SDRAM (0xa0200000..), and is expected to run
	 *  in VA 0xc0200000..  
	 */

	mrc	p15, 0, r0, c2, c0, 0	/* get ttb prepared by redboot */
	adr	r4, mmu_init_table2
	
/*
#define BUILD_STARTUP_PAGETABLE
*/
#ifdef BUILD_STARTUP_PAGETABLE
	mrc	p15, 0, r2, c1, c0, 0
	mov	r2, #0
	tst	r2, #CPU_CONTROL_MMU_ENABLE /* we already have a page table? */
	bne	3f
d96 1
a96 1
	ldr	r0, Lstartup_pagetable
d98 15
a124 1
#endif
d155 2
a156 9
	
#ifdef BUILD_STARTUP_PAGETABLE
#ifndef STARTUP_PAGETABLE_ADDR
#define STARTUP_PAGETABLE_ADDR 0x82000000
#endif
Lstartup_pagetable:	.word	STARTUP_PAGETABLE_ADDR
mmu_init_table:	
	/* fill all table VA==PA */
	MMU_INIT(0x00000000, 0x00000000, 1<<(32-L1_S_SHIFT), L1_TYPE_S|L1_S_V7_AP(AP_KRW))
d158 1
a158 2
	MMU_INIT(SDRAM_START, SDRAM_START, 64, L1_TYPE_S|L1_S_C|L1_S_V7_AP(AP_KRW))
#endif
d161 2
a162 1
	MMU_INIT(0xc0000000, SDRAM_START, 64, L1_TYPE_S|L1_S_C|L1_S_V7_AP(AP_KRW))
@


1.1
log
@In the future, we shouldn't have one port port ARM SoC, that's just
ridiculous.  This is the first step for a common and generic ARM port
for ARMv7 SoCs.
@
text
@d1 1
a1 1
/*	$OpenBSD: beagle_start.S,v 1.5 2013/05/01 13:49:18 patrick Exp $	*/
d36 3
a38 1
#include <arm/pmap.h>		/* for PMAP_DOMAIN_KERNEL */
@

