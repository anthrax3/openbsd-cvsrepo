head	1.3;
access;
symbols;
locks; strict;
comment	@# @;


1.3
date	2017.07.25.19.37.27;	author kettenis;	state Exp;
branches;
next	1.2;
commitid	NKH2a0BTvt1S1PtK;

1.2
date	2017.07.23.10.11.27;	author kettenis;	state Exp;
branches;
next	1.1;
commitid	u9WyPp90HlfBfWem;

1.1
date	2017.06.14.13.12.49;	author patrick;	state Exp;
branches;
next	;
commitid	MrUJFiQ4a9fNTd1z;


desc
@@


1.3
log
@The Cortex-A17 TRM explicitly says that there is an intermediate table
walk cache and that its cache entries are associated with an ASID.
Our armv7 pmap doesn't use ASIDs and we only ever insert "global" page
table entries which match (and get flushed) regardless of the ASID.
The current ASID is specified vy the CONTEXTIDR register, which is
initialized to some "unknown" value.  And on my hardware that value
isn't zero!  So the intermediate table walk cache entries are tagged
with this unknown value.  But our TLB flushes are done with ASID 0.
This means that the intermediate table walk cache entries are never
flushed because the ASID doesn't match.  As a result the hardware may
look at the wrong page table page when looking up a translation.

So initialize CONTEXTIDR to zero before we initialize the first
level page table pointer, flush the TLB and enable the MMU.  Fixes
the hangs previously seen on Cortex-A12/A17.

ok patrick@@
@
text
@/*	$OpenBSD: locore0.S,v 1.2 2017/07/23 10:11:27 kettenis Exp $	*/
/*	$NetBSD: lubbock_start.S,v 1.1 2003/06/18 10:51:15 bsh Exp $ */

/*
 * Copyright (c) 2002, 2003  Genetec Corporation.  All rights reserved.
 * Written by Hiroyuki Bessho for Genetec Corporation.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of Genetec Corporation may not be used to endorse or
 *    promote products derived from this software without specific prior
 *    written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY GENETEC CORPORATION ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL GENETEC CORPORATION
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <machine/asm.h>
#include <arm/sysreg.h>
#include <arm/armreg.h>
#include <arm/pte.h>

#undef	DOMAIN_CLIENT	/* XXX */
#include "assym.h"

#define ELR	.long	0xe12ef30e		@@ msr	ELR_hyp, lr
#define ERET	.long	0xe160006e		@@ eret

/*
 * Kernel start routine for OMAP
 * this code is excuted at the very first after the kernel is loaded
 * by U-Boot.
 *
 * This code makes a number of assumptions.
 * 1) it is running in RAM.
 * 2) it is run at a fairly well known offset from the beginning of
 *    a ram section.
 * 3) the memory region around the kernel will be at least about 32MB
 * 4) memory just below the kernel can be used by the kernel
 * 5) memory at the start of the ram section may not be useable
 *    it may contain bootloader/u-boot
 * 6) the fdt/kernel parameters in arg r0-r2 may point outside the
 *    32MB of ram (it likely should be copied very early)
 *
 */
	.text

	.global	_C_LABEL(bootstrap_start)
_C_LABEL(bootstrap_start):
	/* Save U-Boot arguments */
	mov	r6, r0
	mov	r7, r1
	mov	r8, r2

	/*
	 *  Kernel is loaded in SDRAM (0xX0200000..), and is expected to run
	 *  in VA 0xc0200000..
	 *
	 * which base memory address the kernel is located is unknown
	 * however the kernel should be located at 0x00300000 offset
	 * from that ram area. copy the PC into a register and strip
	 * the low bits
	 */

	/*
	 * If we are running in HYP mode, try to get to SVC safely.
	 * Ensure IRQ, FIQ and Aborts are disabled in HYP mode before
	 * going to SVC.  If we are there already, just go ahead.
	 */
	mrs	r0, cpsr
	and	r0, r0, #(PSR_MODE)
	teq	r0, #(PSR_HYP32_MODE)
	bne	1f			/* If we are not in HYP, we're done */
	mrs	r0, cpsr
	bic	r0, r0, #(PSR_MODE)
	orr	r0, r0, #(PSR_SVC32_MODE)
	orr	r0, r0, #(PSR_I | PSR_F | PSR_A)
	msr	spsr_fsxc, r0
	adr	lr, 1f
	ELR
	ERET				/* Use the HYP LR to get into SVC */
1:

	/*
	 * Now that we are in SVC, build up pagetables and start up.
	 */
	mov r9, pc
	and r9, r9, #0xf0000000	// Leave the memory base in r9

	/* create the bootstrap MMU table at offset 0x00200000 */
	orr	r0, r9, #0x00200000
	mov	r3, #0
	mov	r2, #0
2:
	str	r3, [r0, r2]
	add	r2, r2, #4
	cmp	r2, #(L1_TABLE_SIZE)
	bne	2b

	adr	r4, mmu_init_table

	mov	r2, r9, lsr #18
	ldr	r3, [r4, #8]
	bic	r3, r3, #0xf0000000
	orr	r3, r3, r9
	str	r2, [r4, #4]
	str	r3, [r4, #8]
	str	r3, [r4, #0x14] // ram address for 0xc0000000

	/*
	 * the first entry has two fields that need to be updated for
	 * specific ram configuration of this board.
	 */
	b	4f

3:
	str	r3, [r0, r2]
	add	r2, r2, #4
	add	r3, r3, #(L1_S_SIZE)
	adds	r1, r1, #-1
	bhi	3b
4:
	ldmia	r4!, {r1,r2,r3}   /* # of sections, PA|attr, VA */
	cmp	r1, #0
	bne	3b

	/* Set ASID to zero */
	mov	r1, #0
	mcr	CP15_CONTEXTIDR(r1)
	isb

	mcr	CP15_TTBR0(r0)		/* Set TTB */
	mcr	CP15_TLBIALL(r0)	/* Flush TLB */

	/* Set the Domain Access register.  Very important! */
	mov     r0, #DOMAIN_CLIENT	/* We only use domain 0 */
	mcr	CP15_DACR(r0)
	isb

	/* Enable MMU */
	mrc	CP15_SCTLR(r0)
	orr	r0, r0, #CPU_CONTROL_MMU_ENABLE
	mcr	CP15_SCTLR(r0)
	isb

	/* Restore U-Boot arguments */
	mov	r0, r6
	mov	r1, r7
	mov	r2, r8
	mov	r3, r9

	/* Jump to kernel code in TRUE VA */
	adr	r6, Lstart
	ldr	pc, [r6]

Lstart:
	.word	start

#define MMU_INIT(va,pa,n_sec,attr) \
	.word	n_sec					    ; \
	.word	4*((va)>>L1_S_SHIFT)			    ; \
	.word	(pa)|(attr)				    ;

mmu_init_table:
	/* map SDRAM VA==PA, WT cacheable */
	MMU_INIT(0x00000000, 0x00000000, 64,
		 L1_TYPE_S|L1_S_C|L1_S_V7_AP(AP_KRW)|L1_S_V7_AF)
	/* map VA 0xc0000000..0xc3ffffff to PA */
	MMU_INIT(0xc0000000, 0x00000000, 64,
		 L1_TYPE_S|L1_S_C|L1_S_V7_AP(AP_KRW)|L1_S_V7_AF)

	.word 0	/* end of table */

	.text
@


1.2
log
@Replace CPWAIT with an isb instruction, which is the proper way to make sure
CP15 updates are visible.  Also add an isb instruction before switching on
the MMU to make sure that all the MMU-related CP15 registers updates are
visible.

Makes booting on a Cortex-A12/A17 get a bit further.

ok drahn@@, jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore0.S,v 1.1 2017/06/14 13:12:49 patrick Exp $	*/
d141 5
@


1.1
log
@Split early startup code out of armv7_start.S into locore0.S.  Adjust
link run so that this locore0.o is always at the start of the
executable.  But randomize the link order of all other .o files in the
kernel, so that their exec/rodata/data/bss segments land all over the
place.  Note that this commit does not yet unmap the early bootcode
since this is not as easy as on arm64.

As a result, the internal layout of every newly build bsd kernel is
different from past kernels.  Internal relative offsets are not known
to an outside attacker.  The only known offsets are in the startup code,
which has been unmapped.

Ramdisk kernels cannot be compiled like this, because they are gzip'd.
When the internal pointer references change, the compression dictionary
bloats and results in poorer compression.

With guidance and ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: armv7_start.S,v 1.13 2017/01/07 15:44:28 kettenis Exp $	*/
a44 14
 * CPWAIT -- Canonical method to wait for CP15 update.
 * NOTE: Clobbers the specified temp reg.
 * copied from arm/arm/cpufunc_asm_xscale.S
 * XXX: better be in a common header file.
 */
#define	CPWAIT_BRANCH							 \
	sub	pc, pc, #4

#define	CPWAIT(tmp)							 \
	mrc	CP15_TTBR0(tmp)		/* arbitrary read of CP15 */	;\
	mov	tmp, tmp		/* wait for it to complete */	;\
	CPWAIT_BRANCH			/* branch to next insn */

/*
d148 1
d154 1
a154 1
	CPWAIT(r0)
@

