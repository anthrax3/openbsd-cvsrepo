head	1.14;
access;
symbols
	OPENBSD_6_1:1.14.0.6
	OPENBSD_6_1_BASE:1.14
	OPENBSD_6_0:1.14.0.2
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.11.0.2
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.11.0.4
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.4.0.2
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.3.0.4
	OPENBSD_5_6_BASE:1.3
	OPENBSD_5_5:1.2.0.4
	OPENBSD_5_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.14
date	2016.06.04.18.09.16;	author jsg;	state Exp;
branches;
next	1.13;
commitid	tYyT96DOGdhLjy9v;

1.13
date	2016.05.01.21.07.40;	author patrick;	state Exp;
branches;
next	1.12;
commitid	9HmqUIjyMkt9s5Iw;

1.12
date	2016.04.10.12.24.13;	author jsg;	state Exp;
branches;
next	1.11;
commitid	cl4IWgFQEtumYPKk;

1.11
date	2015.07.15.21.09.40;	author jsg;	state Exp;
branches;
next	1.10;
commitid	lpOHULXxeFU5ykAG;

1.10
date	2015.05.19.03.30.54;	author jsg;	state Exp;
branches;
next	1.9;
commitid	l6xI4SC4UUe6il2U;

1.9
date	2015.05.15.15.35.43;	author jsg;	state Exp;
branches;
next	1.8;
commitid	AFNG6oUBgS2y44wd;

1.8
date	2015.05.12.04.40.31;	author jsg;	state Exp;
branches;
next	1.7;
commitid	KP7LXz9HkmGvvxAQ;

1.7
date	2015.05.08.03.38.26;	author jsg;	state Exp;
branches;
next	1.6;
commitid	zVOTE2eSG0EuTsRj;

1.6
date	2015.05.07.01.55.43;	author jsg;	state Exp;
branches;
next	1.5;
commitid	KhO2CJgSFKm4Q3Hj;

1.5
date	2015.03.29.03.24.17;	author jsg;	state Exp;
branches;
next	1.4;
commitid	hHVsAs6xtkSH9CXS;

1.4
date	2015.01.02.01.57.33;	author jsg;	state Exp;
branches;
next	1.3;
commitid	HaF7XDn04ChceeoJ;

1.3
date	2014.03.18.07.34.17;	author syl;	state Exp;
branches;
next	1.2;

1.2
date	2013.11.20.13.32.40;	author rapha;	state Exp;
branches;
next	1.1;

1.1
date	2013.11.06.19.08.06;	author syl;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Remove model specific strings keyed off the board id.
We now pull the model string from fdt.
@
text
@/* $OpenBSD: armv7.c,v 1.13 2016/05/01 21:07:40 patrick Exp $ */
/*
 * Copyright (c) 2005,2008 Dale Rahn <drahn@@openbsd.com>
 * Copyright (c) 2012-2013 Patrick Wildt <patrick@@blueri.se>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/types.h>
#include <sys/malloc.h>

#define _ARM32_BUS_DMA_PRIVATE
#include <machine/bus.h>
#include <arm/armv7/armv7var.h>
#include <armv7/armv7/armv7var.h>
#include <armv7/armv7/armv7_machdep.h>

struct arm32_bus_dma_tag armv7_bus_dma_tag = {
	0,
	0,
	NULL,
	_bus_dmamap_create,
	_bus_dmamap_destroy,
	_bus_dmamap_load,
	_bus_dmamap_load_mbuf,
	_bus_dmamap_load_uio,
	_bus_dmamap_load_raw,
	_bus_dmamap_unload,
	_bus_dmamap_sync,
	_bus_dmamem_alloc,
	_bus_dmamem_free,
	_bus_dmamem_map,
	_bus_dmamem_unmap,
	_bus_dmamem_mmap,
};

struct armv7_dev *armv7_devs = NULL;

#define DEVNAME(sc)	(sc)->sc_dv.dv_xname

/*
 * We do direct configuration of devices on this SoC "bus", so we
 * never call the child device's match function at all (it can be
 * NULL in the struct cfattach).
 */
int
armv7_submatch(struct device *parent, void *child, void *aux)
{
	struct cfdata *cf = child;
	struct armv7_attach_args *aa = aux;

	if (strcmp(cf->cf_driver->cd_name, aa->aa_dev->name) == 0)
		return (1);

	/* "These are not the droids you are looking for." */
	return (0);
}

void
armv7_set_devs(struct armv7_dev *devs)
{
	armv7_devs = devs;
}

struct armv7_dev *
armv7_find_dev(const char *name, int unit)
{
	struct armv7_dev *ad;

	if (armv7_devs == NULL)
		panic("%s: armv7_devs == NULL", __func__);

	for (ad = armv7_devs; ad->name != NULL; ad++) {
		if (ad->unit == unit && strcmp(ad->name, name) == 0)
			return (ad);
	}

	return (NULL);
}

extern char *hw_prod;

void
armv7_attach(struct device *parent, struct device *self, void *aux)
{
	struct armv7_softc *sc = (struct armv7_softc *)self;
	struct board_dev *bd;

	printf("\n");

	sc->sc_board_devs = platform_board_devs();

	/* Directly configure on-board devices (dev* in config file). */
	for (bd = sc->sc_board_devs; bd->name != NULL; bd++) {
		struct armv7_dev *ad = armv7_find_dev(bd->name, bd->unit);
		struct armv7_attach_args aa;

		if (ad == NULL) {
			printf("%s: device %s unit %d not found\n",
			    DEVNAME(sc), bd->name, bd->unit);
			continue;
		}

		memset(&aa, 0, sizeof(aa));
		aa.aa_dev = ad;
		aa.aa_iot = &armv7_bs_tag;
		aa.aa_dmat = &armv7_bus_dma_tag;

		if (config_found_sm(self, &aa, NULL, armv7_submatch) == NULL)
			printf("%s: device %s unit %d not configured\n",
			    DEVNAME(sc), bd->name, bd->unit);
	}
}

@


1.13
log
@Remove unused match function.  The armv7 platforms implement their own,
which are more specific.

ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: armv7.c,v 1.12 2016/04/10 12:24:13 jsg Exp $ */
a99 2
	int len;
	const char *name = platform_board_name();
d101 1
a101 11
	if (hw_prod == NULL && name != NULL) {
		len = strlen(name) + 1;
		hw_prod = malloc(len, M_DEVBUF, M_NOWAIT);
		if (hw_prod)
			strlcpy(hw_prod, name, len);
	}

	if (name != NULL)
		printf(": %s\n", name);
	else
		printf(": UNKNOWN BOARD %u\n", board_id);
@


1.12
log
@Don't try to get a board name string before attaching mainbus with the
platform abstraction.  The string is only displayed when attaching the
soc abstractions so this is not needed.  When arm mainbus becomes aware
of fdt it can show the /model property itself.
@
text
@d1 1
a1 1
/* $OpenBSD: armv7.c,v 1.11 2015/07/15 21:09:40 jsg Exp $ */
a90 6
}

int
armv7_match(struct device *parent, void *cfdata, void *aux)
{
	return (1);
@


1.11
log
@The exynos gic is not at a fixed offset from periphbase unlike
the other socs.  Handle this by setting variables in exynos{4,5}_init
functions and calling the board_init callback earlier.

tested by and ok bmercer@@
@
text
@d1 1
a1 1
/* $OpenBSD: armv7.c,v 1.10 2015/05/19 03:30:54 jsg Exp $ */
d21 3
d106 2
d109 6
a114 1
	sc->sc_board_devs = platform_board_devs();
d116 2
a117 2
	if (hw_prod)
		printf(": %s\n", hw_prod);
d120 2
@


1.10
log
@Abstract the soc_machdep.c functions to allow a kernel to be built for
multiple socs.

From Patrick Wildt in bitrig with some additional changes.
@
text
@d1 1
a1 1
/* $OpenBSD: armv7.c,v 1.9 2015/05/15 15:35:43 jsg Exp $ */
a103 1
	platform_board_init();
@


1.9
log
@Make board attaching table driven and move it out into the soc
directories.  Move the device tables while here as was done in bitrig.
With these changes the only use of the board id defines is in the soc
directories.

Tested by matthieu and djm on imx and myself on omap and sunxi (qemu).
ok djm@@, ok jasper@@ on an earlier version
@
text
@d1 1
a1 1
/* $OpenBSD: armv7.c,v 1.8 2015/05/12 04:40:31 jsg Exp $ */
d25 1
a25 4

#include "imx.h"
#include "omap.h"
#include "sunxi.h"
a97 12
struct board_dev * (*board_attach[])(void) = {
#if NIMX > 0
	imx_board_attach,
#endif
#if NOMAP > 0
	omap_board_attach,
#endif
#if NSUNXI > 0
	sunxi_board_attach,
#endif
};

a102 1
	int i;
d104 2
a105 5
	for (i = 0; i < nitems(board_attach); i++) {
		sc->sc_board_devs = board_attach[i]();
		if (sc->sc_board_devs != NULL)
			break;
	}
@


1.8
log
@imxiic is known to be broken don't try attaching it on utilite
@
text
@d1 1
a1 1
/* $OpenBSD: armv7.c,v 1.7 2015/05/08 03:38:26 jsg Exp $ */
d25 4
a28 1
#include <armv7/sunxi/sunxireg.h>
a52 295
struct board_dev hummingboard_devs[] = {
	{ "imxocotp",	0 },
	{ "imxccm",	0 },
	{ "imxiomuxc",	0 },
	{ "imxdog",	0 },
	{ "imxuart",	0 },
	{ "imxgpio",	0 },
	{ "imxgpio",	1 },
	{ "imxgpio",	2 },
	{ "imxgpio",	3 },
	{ "imxgpio",	4 },
	{ "imxgpio",	5 },
	{ "imxgpio",	6 },
	{ "imxesdhc",	1 },
	{ "ehci",	0 },
	{ "ehci",	1 },
	{ "imxenet",	0 },
	{ "ahci",	0 },
	{ NULL,		0 }
};

struct board_dev phyflex_imx6_devs[] = {
	{ "imxccm",	0 },
	{ "imxiomuxc",	0 },
	{ "imxdog",	0 },
	{ "imxocotp",	0 },
	{ "imxuart",	3 },
	{ "imxgpio",	0 },
	{ "imxgpio",	1 },
	{ "imxgpio",	2 },
	{ "imxgpio",	3 },
	{ "imxgpio",	4 },
	{ "imxgpio",	5 },
	{ "imxgpio",	6 },
	{ "imxesdhc",	1 },
	{ "imxesdhc",	2 },
	{ "ehci",	0 },
	{ "imxenet",	0 },
	{ "ahci",	0 },
	{ NULL,		0 }
};

struct board_dev sabrelite_devs[] = {
	{ "imxccm",	0 },
	{ "imxiomuxc",	0 },
	{ "imxdog",	0 },
	{ "imxocotp",	0 },
	{ "imxuart",	1 },
	{ "imxgpio",	0 },
	{ "imxgpio",	1 },
	{ "imxgpio",	2 },
	{ "imxgpio",	3 },
	{ "imxgpio",	4 },
	{ "imxgpio",	5 },
	{ "imxgpio",	6 },
	{ "imxesdhc",	2 },
	{ "imxesdhc",	3 },
	{ "ehci",	0 },
	{ "imxenet",	0 },
	{ "ahci",	0 },
	{ NULL,		0 }
};

struct board_dev sabresd_devs[] = {
	{ "imxocotp",	0 },
	{ "imxccm",	0 },
	{ "imxtemp",	0 },
	{ "imxiomuxc",	0 },
	{ "imxdog",	0 },
	{ "imxuart",	0 },
	{ "imxgpio",	0 },
	{ "imxgpio",	1 },
	{ "imxgpio",	2 },
	{ "imxgpio",	3 },
	{ "imxgpio",	4 },
	{ "imxgpio",	5 },
	{ "imxgpio",	6 },
	{ "imxesdhc",	1 },
	{ "imxesdhc",	2 },
	{ "imxesdhc",	3 },
	{ "ehci",	0 },
	{ "imxenet",	0 },
	{ "ahci",	0 },
	{ NULL,		0 }
};

struct board_dev udoo_devs[] = {
	{ "imxocotp",	0 },
	{ "imxccm",	0 },
	{ "imxiomuxc",	0 },
	{ "imxdog",	0 },
	{ "imxuart",	1 },
	{ "imxgpio",	0 },
	{ "imxgpio",	1 },
	{ "imxgpio",	2 },
	{ "imxgpio",	3 },
	{ "imxgpio",	4 },
	{ "imxgpio",	5 },
	{ "imxgpio",	6 },
	{ "imxesdhc",	2 },
	{ "imxesdhc",	3 },
	{ "ehci",	0 },
	{ "imxenet",	0 },
	{ "ahci",	0 },
	{ NULL,		0 }
};

struct board_dev utilite_devs[] = {
	{ "imxocotp",	0 },
	{ "imxccm",	0 },
	{ "imxiomuxc",	0 },
	{ "imxdog",	0 },
	{ "imxuart",	3 },
	{ "imxgpio",	0 },
	{ "imxgpio",	1 },
	{ "imxgpio",	2 },
	{ "imxgpio",	3 },
	{ "imxgpio",	4 },
	{ "imxgpio",	5 },
	{ "imxgpio",	6 },
	{ "imxesdhc",	2 },
	{ "ehci",	0 },
	{ "imxenet",	0 },
	{ "ahci",	0 },
	{ NULL,		0 }
};

struct board_dev novena_devs[] = {
	{ "imxccm",	0 },
	{ "imxiomuxc",	0 },
	{ "imxdog",	0 },
	{ "imxocotp",	0 },
	{ "imxuart",	1 },
	{ "imxgpio",	0 },
	{ "imxgpio",	1 },
	{ "imxgpio",	2 },
	{ "imxgpio",	3 },
	{ "imxgpio",	4 },
	{ "imxgpio",	5 },
	{ "imxgpio",	6 },
	{ "imxesdhc",	2 },
	{ "imxesdhc",	3 },
	{ "ehci",	0 },
	{ "imxenet",	0 },
	{ "ahci",	0 },
	{ NULL,		0 }
};

struct board_dev wandboard_devs[] = {
	{ "imxccm",	0 },
	{ "imxiomuxc",	0 },
	{ "imxdog",	0 },
	{ "imxocotp",	0 },
	{ "imxuart",	0 },
	{ "imxgpio",	0 },
	{ "imxgpio",	1 },
	{ "imxgpio",	2 },
	{ "imxgpio",	3 },
	{ "imxgpio",	4 },
	{ "imxgpio",	5 },
	{ "imxgpio",	6 },
	{ "imxenet",	0 },
	{ "imxesdhc",	2 },
	{ "imxesdhc",	0 },
	{ "ehci",	0 },
	{ "ahci",	0 },	/* only on quad, afaik. */
	{ NULL,		0 }
};
struct board_dev beagleboard_devs[] = {
	{ "prcm",	0 },
	{ "intc",	0 },
	{ "gptimer",	0 },
	{ "gptimer",	1 },
	{ "omdog",	0 },
	{ "omgpio",	0 },
	{ "omgpio",	1 },
	{ "omgpio",	2 },
	{ "omgpio",	3 },
	{ "omgpio",	4 },
	{ "omgpio",	5 },
	{ "ommmc",	0 },		/* HSMMC1 */
	{ "com",	2 },		/* UART3 */
	{ NULL,		0 }
};

struct board_dev beaglebone_devs[] = {
	{ "prcm",	0 },
	{ "sitaracm",	0 },
	{ "intc",	0 },
	{ "edma",	0 },
	{ "dmtimer",	0 },
	{ "dmtimer",	1 },
	{ "omdog",	0 },
	{ "omgpio",	0 },
	{ "omgpio",	1 },
	{ "omgpio",	2 },
	{ "omgpio",	3 },
	{ "tiiic",	0 },
	{ "tiiic",	1 },
	{ "tiiic",	2 },
	{ "ommmc",	0 },		/* HSMMC0 */
	{ "ommmc",	1 },		/* HSMMC1 */
	{ "com",	0 },		/* UART0 */
	{ "cpsw",	0 },
	{ NULL,		0 }
};

struct board_dev overo_devs[] = {
	{ "prcm",	0 },
	{ "intc",	0 },
	{ "gptimer",	0 },
	{ "gptimer",	1 },
	{ "omdog",	0 },
	{ "omgpio",	0 },
	{ "omgpio",	1 },
	{ "omgpio",	2 },
	{ "omgpio",	3 },
	{ "omgpio",	4 },
	{ "omgpio",	5 },
	{ "ommmc",	0 },		/* HSMMC1 */
	{ "com",	2 },		/* UART3 */
	{ NULL,		0 }
};

struct board_dev pandaboard_devs[] = {
	{ "omapid",	0 },
	{ "prcm",	0 },
	{ "omdog",	0 },
	{ "omgpio",	0 },
	{ "omgpio",	1 },
	{ "omgpio",	2 },
	{ "omgpio",	3 },
	{ "omgpio",	4 },
	{ "omgpio",	5 },
	{ "ommmc",	0 },		/* HSMMC1 */
	{ "com",	2 },		/* UART3 */
	{ "ehci",	0 },
	{ NULL,		0 }
};

struct board_dev sun4i_devs[] = {
	{ "sxipio",	0 },
	{ "sxiccmu",	0 },
	{ "a1xintc",	0 },
	{ "sxitimer",	0 },
	{ "sxitimer",	1 },
	{ "sxitimer",	2 },
	{ "sxidog",	0 },
	{ "sxirtc",	0 },
	{ "sxiuart",	0 },
	{ "sxiuart",	1 },
	{ "sxiuart",	2 },
	{ "sxiuart",	3 },
	{ "sxiuart",	4 },
	{ "sxiuart",	5 },
	{ "sxiuart",	6 },
	{ "sxiuart",	7 },
	{ "sxie",	0 },
	{ "ahci",	0 },
	{ "ehci",	0 },
	{ "ehci",	1 },
#if 0
	{ "ohci",	0 },
	{ "ohci",	1 },
#endif
	{ NULL,		0 }
};

struct board_dev sun7i_devs[] = {
	{ "sxipio",	0 },
	{ "sxiccmu",	0 },
	{ "sxitimer",	0 },
	{ "sxitimer",	1 },
	{ "sxitimer",	2 },
	{ "sxidog",	0 },
	{ "sxirtc",	0 },
	{ "sxiuart",	0 },
	{ "sxiuart",	1 },
	{ "sxiuart",	2 },
	{ "sxiuart",	3 },
	{ "sxiuart",	4 },
	{ "sxiuart",	5 },
	{ "sxiuart",	6 },
	{ "sxiuart",	7 },
	{ "sxie",	0 },
	{ "ahci",	0 },
	{ "ehci",	0 },
	{ "ehci",	1 },
#if 0
	{ "ohci",	0 },
	{ "ohci",	1 },
#endif
	{ NULL,		0 }
};

d99 14
d118 1
a118 2
	uint32_t issunxi = 0;
	bus_space_handle_t ioh;
d120 4
a123 81
	switch (board_id) {
	case BOARD_ID_IMX6_CUBOXI:
		printf(": i.MX6 SolidRun CuBox-i\n");
		imx6_init();
		sc->sc_board_devs = hummingboard_devs;
		break;
	case BOARD_ID_IMX6_HUMMINGBOARD:
		printf(": i.MX6 SolidRun HummingBoard\n");
		imx6_init();
		sc->sc_board_devs = hummingboard_devs;
		break;
	case BOARD_ID_IMX6_PHYFLEX:
		printf(": PhyFLEX-i.MX6\n");
		imx6_init();
		sc->sc_board_devs = phyflex_imx6_devs;
		break;
	case BOARD_ID_IMX6_SABRELITE:
		printf(": i.MX6 SABRE Lite\n");
		imx6_init();
		sc->sc_board_devs = sabrelite_devs;
		break;
	case BOARD_ID_IMX6_SABRESD:
		printf(": i.MX6 SABRE SD\n");
		imx6_init();
		sc->sc_board_devs = sabresd_devs;
		break;
	case BOARD_ID_IMX6_UDOO:
		printf(": i.MX6 UDOO\n");
		imx6_init();
		sc->sc_board_devs = udoo_devs;
		break;
	case BOARD_ID_IMX6_UTILITE:
		printf(": i.MX6 Utilite\n");
		imx6_init();
		sc->sc_board_devs = utilite_devs;
		break;
	case BOARD_ID_IMX6_NOVENA:
		printf(": i.MX6 Novena\n");
		imx6_init();
		sc->sc_board_devs = novena_devs;
		break;
	case BOARD_ID_IMX6_WANDBOARD:
		printf(": i.MX6 Wandboard\n");
		imx6_init();
		sc->sc_board_devs = wandboard_devs;
		break;
	case BOARD_ID_OMAP3_BEAGLE:
		printf(": BeagleBoard\n");
		omap3_init();
		sc->sc_board_devs = beagleboard_devs;
		break;
	case BOARD_ID_AM335X_BEAGLEBONE:
		printf(": BeagleBone\n");
		am335x_init();
		sc->sc_board_devs = beaglebone_devs;
		break;
	case BOARD_ID_OMAP3_OVERO:
		printf(": Gumstix Overo\n");
		omap3_init();
		sc->sc_board_devs = overo_devs;
		break;
	case BOARD_ID_OMAP4_PANDA:
		printf(": PandaBoard\n");
		omap4_init();
		sc->sc_board_devs = pandaboard_devs;
		break;
	case BOARD_ID_SUN4I_A10:
		printf(": A1X\n");
		sxia1x_init();
		sc->sc_board_devs = sun4i_devs;
		issunxi = 1;
		break;
	case BOARD_ID_SUN7I_A20:
		printf(": A20\n");
		sxia20_init();
		sc->sc_board_devs = sun7i_devs;
		issunxi = 1;
		break;
	default:
		printf("\n");
		panic("%s: board type 0x%x unknown", __func__, board_id);
d126 4
a129 12
	if (issunxi) {
		/*
		 * XXX think of a better place to do this, as there might
		 * be need for access by other drivers later.
		 */
		if (bus_space_map(&armv7_bs_tag, SYSCTRL_ADDR, SYSCTRL_SIZE, 0,
		    &ioh))
			panic("sunxi_attach: bus_space_map failed!");
		/* map the part of SRAM dedicated to EMAC to EMAC */
		bus_space_write_4(&armv7_bs_tag, ioh, 4,
		    bus_space_read_4(&armv7_bs_tag, ioh, 4) | (5 << 2));
	}
@


1.7
log
@Add initial board specific parts of novena support, tested by djm@@
While novena has it's own board id it's u-boot does not set it.
"setenv machid 10ad" in u-boot will set the novena board id (0x10ad/4269).
@
text
@d1 1
a1 1
/* $OpenBSD: armv7.c,v 1.6 2015/05/07 01:55:43 jsg Exp $ */
a169 1
	{ "imxiic",	2 },
@


1.6
log
@fix indentation
ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: armv7.c,v 1.5 2015/03/29 03:24:17 jsg Exp $ */
d178 21
d435 5
@


1.5
log
@initial support for the SABRE SD board
from Patrick Wildt in Bitrig
@
text
@d1 1
a1 1
/* $OpenBSD: armv7.c,v 1.4 2015/01/02 01:57:33 jsg Exp $ */
d464 1
a464 1
		panic("sunxi_attach: bus_space_map failed!");
@


1.4
log
@Add some additional i.MX6 board types from Bitrig.
CompuLab Utilite, SolidRun HummingBoard/CuBox-i and UDOO.
@
text
@d1 1
a1 1
/* $OpenBSD: armv7.c,v 1.3 2014/03/18 07:34:17 syl Exp $ */
d113 23
d399 5
@


1.3
log
@Add missing parts of the tiic driver.

inspired by rapha@@
ok rapha@@, jasper@@
@
text
@d1 1
a1 1
/* $OpenBSD: armv7.c,v 1.2 2013/11/20 13:32:40 rapha Exp $ */
d50 21
d113 42
d357 10
d376 10
@


1.2
log
@Add gpio(4) support for omap3/4 and am335x.

Feedback by patrick and syl, tested by syl on BeagleBoard and BBB.
ok syl@@
@
text
@d1 1
a1 1
/* $OpenBSD: armv7.c,v 1.1 2013/11/06 19:08:06 syl Exp $ */
d141 3
@


1.1
log
@forgot armv7/armv7 files...
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d137 4
@

