head	1.22;
access;
symbols
	OPENBSD_6_0:1.8.0.2
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.4.0.2
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.4.0.4
	OPENBSD_5_8_BASE:1.4;
locks; strict;
comment	@ * @;


1.22
date	2017.03.07.15.38.11;	author kettenis;	state Exp;
branches;
next	1.21;
commitid	x4dU0vykBmQPIlRd;

1.21
date	2017.03.06.07.41.58;	author kettenis;	state Exp;
branches;
next	1.20;
commitid	ElPtONkRhgn2bBpC;

1.20
date	2016.10.25.00.04.59;	author jsg;	state Exp;
branches;
next	1.19;
commitid	kyDRkoOZHQsbTiU5;

1.19
date	2016.10.23.18.50.34;	author kettenis;	state Exp;
branches;
next	1.18;
commitid	mOwNztTM0fyFumab;

1.18
date	2016.10.09.01.40.43;	author jsg;	state Exp;
branches;
next	1.17;
commitid	Of2rCa9qI1b33BPT;

1.17
date	2016.10.09.00.53.43;	author jsg;	state Exp;
branches;
next	1.16;
commitid	NJkwmASvm1yJz5Bo;

1.16
date	2016.10.05.22.06.48;	author kettenis;	state Exp;
branches;
next	1.15;
commitid	WddFsarPAXG7fLxc;

1.15
date	2016.10.05.07.29.59;	author patrick;	state Exp;
branches;
next	1.14;
commitid	WOkIaqGc4aRCRDhH;

1.14
date	2016.08.31.16.19.40;	author jsg;	state Exp;
branches;
next	1.13;
commitid	hkMa4gzwtj49TUef;

1.13
date	2016.08.20.15.44.04;	author kettenis;	state Exp;
branches;
next	1.12;
commitid	PxjV2jD6yVzqolQF;

1.12
date	2016.08.17.13.05.02;	author patrick;	state Exp;
branches;
next	1.11;
commitid	lvew3YexMpLMskOM;

1.11
date	2016.08.15.13.42.49;	author patrick;	state Exp;
branches;
next	1.10;
commitid	8OAWl0pWWtbE7YFk;

1.10
date	2016.08.10.06.51.57;	author kettenis;	state Exp;
branches;
next	1.9;
commitid	072w8y2APSQB4Ylc;

1.9
date	2016.08.07.17.46.36;	author kettenis;	state Exp;
branches;
next	1.8;
commitid	LdQbmNEKiIg0u5Hd;

1.8
date	2016.06.08.15.56.29;	author jsg;	state Exp;
branches;
next	1.7;
commitid	DMarQT2L9h5cAbcu;

1.7
date	2016.06.08.15.27.05;	author jsg;	state Exp;
branches;
next	1.6;
commitid	O8sdMmMKqczNQU5p;

1.6
date	2016.06.04.18.09.16;	author jsg;	state Exp;
branches;
next	1.5;
commitid	tYyT96DOGdhLjy9v;

1.5
date	2016.05.18.22.55.23;	author kettenis;	state Exp;
branches;
next	1.4;
commitid	3F9JV9gcDaM81aVG;

1.4
date	2015.07.15.21.09.40;	author jsg;	state Exp;
branches;
next	1.3;
commitid	lpOHULXxeFU5ykAG;

1.3
date	2015.06.08.06.33.16;	author jsg;	state Exp;
branches;
next	1.2;
commitid	TKnNVNES86I6ApFq;

1.2
date	2015.05.27.08.03.43;	author jsg;	state Exp;
branches;
next	1.1;
commitid	SU2brUwJ4Fiukt7J;

1.1
date	2015.05.19.03.30.54;	author jsg;	state Exp;
branches;
next	;
commitid	l6xI4SC4UUe6il2U;


desc
@@


1.22
log
@Unbreak the tree by removing the  "exynos.h" include and associated prototype.
Found the hard way by florian@@
@
text
@/*	$OpenBSD: platform.c,v 1.21 2017/03/06 07:41:58 kettenis Exp $	*/
/*
 * Copyright (c) 2014 Patrick Wildt <patrick@@blueri.se>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/types.h>
#include <sys/systm.h>

#include <machine/bus.h>

#include <arm/mainbus/mainbus.h>
#include <armv7/armv7/armv7var.h>
#include <armv7/armv7/armv7_machdep.h>
#include <arm/cortex/smc.h>

#include "omap.h"

static struct armv7_platform *platform;

void	agtimer_init(void);

void	exuart_init_cons(void);
void	imxuart_init_cons(void);
void	com_fdt_init_cons(void);
void	pluart_init_cons(void);

struct armv7_platform *omap_platform_match(void);

struct armv7_platform * (*plat_match[])(void) = {
#if NOMAP > 0
	omap_platform_match,
#endif
};

struct board_dev no_devs[] = {
	{ NULL,	0 }
};

void
platform_init(void)
{
	int i;

	agtimer_init();

	for (i = 0; i < nitems(plat_match); i++) {
		platform = plat_match[i]();
		if (platform != NULL)
			break;
	}

	if (platform == NULL)
		return;

	cpuresetfn = platform_watchdog_reset;
	powerdownfn = platform_powerdown;
	if (platform->board_init)
		platform->board_init();
}

void
platform_smc_write(bus_space_tag_t iot, bus_space_handle_t ioh, bus_size_t off,
    uint32_t op, uint32_t val)
{
	if (platform && platform->smc_write)
		platform->smc_write(iot, ioh, off, op, val);
	else
		bus_space_write_4(iot, ioh, off, val);
}

void
platform_init_cons(void)
{
	if (platform && platform->init_cons) {
		platform->init_cons();
		return;
	}
	exuart_init_cons();
	imxuart_init_cons();
	com_fdt_init_cons();
	pluart_init_cons();
}

void
platform_init_mainbus(struct device *self)
{
	if (platform && platform->init_mainbus)
		platform->init_mainbus(self);
	else
		mainbus_legacy_found(self, "cortex");
}

void
platform_watchdog_reset(void)
{
	if (platform && platform->watchdog_reset)
		platform->watchdog_reset();
}

void
platform_powerdown(void)
{
	if (platform && platform->powerdown)
		platform->powerdown();
}

struct board_dev *
platform_board_devs()
{
	if (platform && platform->devs)
		return (platform->devs);
	else
		return (no_devs);
}
@


1.21
log
@De-platformize exynos.  Disable exdisplay(4) for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: platform.c,v 1.20 2016/10/25 00:04:59 jsg Exp $	*/
a29 1
#include "exynos.h"
a40 1
struct armv7_platform *exynos_platform_match(void);
@


1.20
log
@Remove now unused disable_l2_if_needed interface.
ok kettenis@@ patrick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: platform.c,v 1.19 2016/10/23 18:50:34 kettenis Exp $	*/
a46 3
#endif
#if NEXYNOS > 0
	exynos_platform_match,
@


1.19
log
@De-platformize sunxi.  This removes the board initialization code that sets up
SRAM for the EMAC.  Instead we rely on u-boot setting this up for us.

ok jsg@@, patrick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: platform.c,v 1.18 2016/10/09 01:40:43 jsg Exp $	*/
a122 7
}

void
platform_disable_l2_if_needed(void)
{
	if (platform && platform->disable_l2_if_needed)
		platform->disable_l2_if_needed();
@


1.18
log
@Remove the vexpress platform abstraction and board id.  All the devices
that attached to vexpress have been converted to fdt so this is no
longer required.
@
text
@d1 1
a1 1
/*	$OpenBSD: platform.c,v 1.17 2016/10/09 00:53:43 jsg Exp $	*/
a29 1
#include "sunxi.h"
a41 1
struct armv7_platform *sunxi_platform_match(void);
a46 3
#endif
#if NSUNXI > 0
	sunxi_platform_match,
@


1.17
log
@Add a power down function pointer so power down can work without the
platform abstraction.

ok tom@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: platform.c,v 1.16 2016/10/05 22:06:48 kettenis Exp $	*/
a31 1
#include "vexpress.h"
a44 1
struct armv7_platform *vexpress_platform_match(void);
a54 3
#endif
#if NVEXPRESS > 0
	vexpress_platform_match,
@


1.16
log
@Make imxdog(4) set cpuresetfn, and remove all the imx platform that is no
longer needed, including the imx board IDs.

ok patrick@@, jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: platform.c,v 1.15 2016/10/05 07:29:59 patrick Exp $	*/
d84 1
@


1.15
log
@Introduce a global function pointer to reset the CPU akin to amd64 and
i386.  As newer ARMs where we use device tree from the get go don't
necessarily have a 'platform', this will allow drivers to hook
themselves as a way to reset the CPU.

ok jsg@@ kettenis@@ tom@@
@
text
@d1 1
a1 1
/*	$OpenBSD: platform.c,v 1.14 2016/08/31 16:19:40 jsg Exp $	*/
a28 1
#include "imx.h"
a42 1
struct armv7_platform *imx_platform_match(void);
a48 3
#if NIMX > 0
	imx_platform_match,
#endif
@


1.14
log
@pl011 and pl031 are licenseable peripherals from arm present in multiple socs.
Move the pluart and plrtc drivers for them out of the vexpress directory
and into dev to reflect this and rename the files to match the driver names.

discussed with patrick and kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: platform.c,v 1.13 2016/08/20 15:44:04 kettenis Exp $	*/
d84 6
a89 1
	if (platform && platform->board_init)
@


1.13
log
@Replace bcmmuart(4) with com(4).

ok patrick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: platform.c,v 1.12 2016/08/17 13:05:02 patrick Exp $	*/
d42 1
a42 1
void	pl011_init_cons(void);
d108 1
a108 1
	pl011_init_cons();
@


1.12
log
@Replace sxiuart(4) with the mostly compatible com(4).

The Synopsys DesignWare 8250 throws an interrupt if it detects a write
to LCR while it was busy.  Read the USR register to clear the interrupt
so we don't get flooded.

The sunxi machines also use a different frequency on the consoles.  As
we have no clock framework, especially not for early consoles, match on
known Allwinner compatibles to set a known frequency.

ok kettenis@@ mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: platform.c,v 1.11 2016/08/15 13:42:49 patrick Exp $	*/
a42 1
void	bcmmuart_init_cons(void);
a108 1
	bcmmuart_init_cons();
@


1.11
log
@Move the com(4) fdt attachment driver to a more generic location and
rename it to fit the typical scheme of such an attachment driver.

ok kettenis@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: platform.c,v 1.10 2016/08/10 06:51:57 kettenis Exp $	*/
a41 1
void	sxiuart_init_cons(void);
a108 1
	sxiuart_init_cons();
@


1.10
log
@Dynamically attach agtimer(4).  Since agtimer(4) also provides the delay()
function for platforms that have it, rework the code a bit such that it can
be used before agtimer(4) attaches.  Introduce a new agtimer_init()
function that checks whether the CPU implements the Generic Timer feature
and switches to agtimer_delay() if that feature is present.  Call this
function from the generic platform initialization code.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: platform.c,v 1.9 2016/08/07 17:46:36 kettenis Exp $	*/
d41 1
a41 1
void	omapuart_init_cons(void);
d109 1
a109 1
	omapuart_init_cons();
@


1.9
log
@Initial support for Raspberry Pi 2/3.  All the hard work done by patrick@@, I
just cleaned things up a bit.  Any bugs introduced in that process are
entirely mine.

This doesn't work yet.  But when it does, you'll need recent firmware from
the Raspberry Pi Foundation git repository at

  https://github.com/raspberrypi/firmware

The device tree for the Raspberry Pi is somewhat in flux as bits and pieces
to support the Raspberry Pi 2 and 3 are committed to the mainline Linux
kernel.
@
text
@d1 1
a1 1
/*	$OpenBSD: platform.c,v 1.8 2016/06/08 15:56:29 jsg Exp $	*/
d37 2
d78 3
a80 1
	
@


1.8
log
@stop requiring a matching platform to continue booting
@
text
@d1 1
a1 1
/*	$OpenBSD: platform.c,v 1.7 2016/06/08 15:27:05 jsg Exp $	*/
d42 1
d108 1
@


1.7
log
@Use fdt to find the console to initialise.  Try to use /chosen/stdout-path
if present otherwise fallback to /aliases/serial0.

Don't require a platform match to run the various console init functions
so the init functions will run for unknown board ids.

With and ok kettenis@@ on a earlier version.
@
text
@d1 1
a1 1
/*	$OpenBSD: platform.c,v 1.6 2016/06/04 18:09:16 jsg Exp $	*/
d24 1
d67 4
d81 2
a82 3
	if (platform == NULL)
		panic("no matching armv7 platform");
	platform->board_init();
d89 4
a92 1
	platform->smc_write(iot, ioh, off, op, val);
d112 1
a112 1
	if (platform->init_mainbus)
d114 2
d121 2
a122 1
	platform->watchdog_reset();
d128 2
a129 1
	platform->powerdown();
d135 2
a136 1
	platform->disable_l2_if_needed();
d142 4
a145 1
	return (platform->devs);
@


1.6
log
@Remove model specific strings keyed off the board id.
We now pull the model string from fdt.
@
text
@d1 1
a1 1
/*	$OpenBSD: platform.c,v 1.5 2016/05/18 22:55:23 kettenis Exp $	*/
d36 6
d91 9
a99 1
	platform->init_cons();
@


1.5
log
@Introduce a per-platform init_mainbus() hook that can be used to attach
platform-specific devices to mainbus before we start walking the FDT.

ok patrick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: platform.c,v 1.4 2015/07/15 21:09:40 jsg Exp $	*/
a74 6
const char *
platform_boot_name(void)
{
	return platform->boot_name;
}

a104 6
}

const char *
platform_board_name(void)
{
	return (platform->board_name());
@


1.4
log
@The exynos gic is not at a fixed offset from periphbase unlike
the other socs.  Handle this by setting variables in exynos{4,5}_init
functions and calling the board_init callback earlier.

tested by and ok bmercer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: platform.c,v 1.3 2015/06/08 06:33:16 jsg Exp $	*/
d92 7
@


1.3
log
@Add initial support for the ARM Versatile Express boards as emulated by
qemu with virtio memory ranges.

Unfortunately the vexpress-a9 and vexpress-a15 boards/targets have
different load addresses and memory maps.

Code for the PL011 UART and mmio virtio attachment from Patrick Wildt
in bitrig.
@
text
@d1 1
a1 1
/*	$OpenBSD: platform.c,v 1.2 2015/05/27 08:03:43 jsg Exp $	*/
d72 1
a121 6
}

void
platform_board_init()
{
	platform->board_init();
@


1.2
log
@call exynos_platform_match() if the kernel is compiled with exynos devices
@
text
@d1 1
a1 1
/*	$OpenBSD: platform.c,v 1.1 2015/05/19 03:30:54 jsg Exp $	*/
d32 1
d40 1
d54 3
@


1.1
log
@Abstract the soc_machdep.c functions to allow a kernel to be built for
multiple socs.

From Patrick Wildt in bitrig with some additional changes.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d31 1
d38 1
d49 3
@

