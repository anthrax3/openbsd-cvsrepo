head	1.11;
access;
symbols
	OPENBSD_6_1:1.10.0.4
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.6.0.2
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.5.0.2
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.4.0.4
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.3.0.2
	OPENBSD_5_7_BASE:1.3
	OPENBSD_5_6:1.3.0.6
	OPENBSD_5_6_BASE:1.3
	OPENBSD_5_5:1.3.0.4
	OPENBSD_5_5_BASE:1.3;
locks; strict;
comment	@ * @;


1.11
date	2017.09.08.05.36.51;	author deraadt;	state Exp;
branches;
next	1.10;
commitid	uRv5pa9QDlZaYgwD;

1.10
date	2017.01.21.08.26.49;	author patrick;	state Exp;
branches;
next	1.9;
commitid	dvP7gLmLqGu2JY3W;

1.9
date	2016.10.23.13.24.42;	author kettenis;	state Exp;
branches;
next	1.8;
commitid	PVFXxgJXFjCfvQJW;

1.8
date	2016.10.22.15.16.25;	author kettenis;	state Exp;
branches;
next	1.7;
commitid	mjaDtGaGcrXazKVz;

1.7
date	2016.10.21.20.03.57;	author kettenis;	state Exp;
branches;
next	1.6;
commitid	7N6EfXvKKufa9dai;

1.6
date	2016.07.18.19.22.45;	author kettenis;	state Exp;
branches;
next	1.5;
commitid	0a2tASojg35a7945;

1.5
date	2016.02.01.23.31.34;	author jsg;	state Exp;
branches;
next	1.4;
commitid	HIbXE0fxahKaPQDe;

1.4
date	2015.05.19.06.04.26;	author jsg;	state Exp;
branches;
next	1.3;
commitid	hW8LeyNtIeHmcHnV;

1.3
date	2013.11.06.19.03.07;	author syl;	state Exp;
branches;
next	1.2;

1.2
date	2013.10.27.12.58.53;	author jasper;	state Exp;
branches;
next	1.1;

1.1
date	2013.10.23.17.08.48;	author jasper;	state Exp;
branches;
next	;


desc
@@


1.11
log
@If you use sys/param.h, you don't need sys/types.h
@
text
@/*	$OpenBSD: sxitimer.c,v 1.10 2017/01/21 08:26:49 patrick Exp $	*/
/*
 * Copyright (c) 2007,2009 Dale Rahn <drahn@@openbsd.org>
 * Copyright (c) 2013 Raphael Graf <r@@undefined.ch>
 * Copyright (c) 2013 Artturi Alm
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/time.h>
#include <sys/evcount.h>
#include <sys/device.h>
#include <sys/timetc.h>
#include <dev/clock_subr.h>

#include <arm/cpufunc.h>

#include <machine/bus.h>
#include <machine/fdt.h>
#include <machine/intr.h>

#include <armv7/armv7/armv7var.h>
#include <dev/fdt/sunxireg.h>
/* #include <armv7/sunxi/sxipiovar.h> */

#include <dev/ofw/openfirm.h>
#include <dev/ofw/fdt.h>

#define	TIMER_IER 		0x00
#define	TIMER_ISR 		0x04
#define	TIMER_IRQ(x)		(1 << (x))

#define	TIMER_CTRL(x)		(0x10 + (0x10 * (x)))
#define	TIMER_INTV(x)		(0x14 + (0x10 * (x)))
#define	TIMER_CURR(x)		(0x18 + (0x10 * (x)))

/* A1X counter */
#define	CNT64_CTRL		0xa0
#define	CNT64_LOW		0xa4
#define	CNT64_HIGH		0xa8

#define	CNT64_CLR_EN		(1 << 0) /* clear enable */
#define	CNT64_RL_EN		(1 << 1) /* read latch enable */

#define	TIMER_ENABLE		(1 << 0)
#define	TIMER_RELOAD		(1 << 1)
#define	TIMER_CLK_SRC_MASK	(3 << 2)
#define	TIMER_OSC24M		(1 << 2)
#define	TIMER_PLL6_6		(2 << 2)
#define	TIMER_PRESC_1		(0 << 4)
#define	TIMER_PRESC_2		(1 << 4)
#define	TIMER_PRESC_4		(2 << 4)
#define	TIMER_PRESC_8		(3 << 4)
#define	TIMER_PRESC_16		(4 << 4)
#define	TIMER_PRESC_32		(5 << 4)
#define	TIMER_PRESC_64		(6 << 4)
#define	TIMER_PRESC_128		(7 << 4)
#define	TIMER_CONTINOUS		(0 << 7)
#define	TIMER_SINGLESHOT	(1 << 7)

#define	TICKTIMER		0
#define	STATTIMER		1
#define	CNTRTIMER		2

#define TIMER_SYNC		3

int	sxitimer_match(struct device *, void *, void *);
void	sxitimer_attach(struct device *, struct device *, void *);
int	sxitimer_tickintr(void *);
int	sxitimer_statintr(void *);
void	sxitimer_cpu_initclocks(void);
void	sxitimer_setstatclockrate(int);
uint64_t	sxitimer_readcnt64(void);
uint32_t	sxitimer_readcnt32(void);
void	sxitimer_sync(void);
void	sxitimer_delay(u_int);

u_int sxitimer_get_timecount(struct timecounter *);

static struct timecounter sxitimer_timecounter = {
	sxitimer_get_timecount, NULL, 0xffffffff, 0, "sxitimer", 0, NULL
};

bus_space_tag_t		sxitimer_iot;
bus_space_handle_t	sxitimer_ioh;

uint32_t sxitimer_freq[] = {
	TIMER0_FREQUENCY,
	TIMER1_FREQUENCY,
	TIMER2_FREQUENCY,
	0
};

uint32_t sxitimer_irq[] = {
	TIMER0_IRQ,
	TIMER1_IRQ,
	TIMER2_IRQ,
	0
};

uint32_t sxitimer_stat_tpi, sxitimer_tick_tpi;
uint32_t sxitimer_statvar, sxitimer_statmin;
uint32_t sxitimer_tick_nextevt, sxitimer_stat_nextevt;
uint32_t sxitimer_ticks_err_cnt, sxitimer_ticks_err_sum;

struct sxitimer_softc {
	struct device		sc_dev;
};

struct cfattach sxitimer_ca = {
	sizeof (struct sxitimer_softc), sxitimer_match, sxitimer_attach
};

struct cfdriver sxitimer_cd = {
	NULL, "sxitimer", DV_DULL
};

int
sxitimer_match(struct device *parent, void *match, void *aux)
{
	struct fdt_attach_args *faa = aux;
	int node;

	node = OF_finddevice("/");
	if (!OF_is_compatible(node, "allwinner,sun4i-a10") &&
	    !OF_is_compatible(node, "allwinner,sun5i-a10s") &&
	    !OF_is_compatible(node, "allwinner,sun5i-a13"))
		return 0;

	return OF_is_compatible(faa->fa_node, "allwinner,sun4i-a10-timer");
}

void
sxitimer_attach(struct device *parent, struct device *self, void *aux)
{
	struct fdt_attach_args *faa = aux;
	uint32_t freq, ival, now;

	KASSERT(faa->fa_nreg > 0);

	sxitimer_iot = faa->fa_iot;
	if (bus_space_map(sxitimer_iot, faa->fa_reg[0].addr,
	    faa->fa_reg[0].size, 0, &sxitimer_ioh))
		panic("%s: bus_space_map failed!", __func__);

	/* clear counter, loop until ready */
	bus_space_write_4(sxitimer_iot, sxitimer_ioh, CNT64_CTRL,
	    CNT64_CLR_EN); /* XXX as a side-effect counter clk src=OSC24M */
	while (bus_space_read_4(sxitimer_iot, sxitimer_ioh, CNT64_CTRL)
	    & CNT64_CLR_EN)
		continue;

	/* timers are down-counters, from interval to 0 */
	now = 0xffffffff; /* known big value */
	freq = sxitimer_freq[TICKTIMER];

	/* stop timer, and set clk src */
	bus_space_write_4(sxitimer_iot, sxitimer_ioh,
	    TIMER_CTRL(TICKTIMER), TIMER_OSC24M);

	ival = sxitimer_tick_tpi = freq / hz;
	sxitimer_tick_nextevt = now - ival;

	sxitimer_ticks_err_cnt = freq % hz;
	sxitimer_ticks_err_sum = 0;

	bus_space_write_4(sxitimer_iot, sxitimer_ioh,
	    TIMER_INTV(TICKTIMER), ival);

	/* timers are down-counters, from interval to 0 */
	now = 0xffffffff; /* known big value */
	freq = sxitimer_freq[STATTIMER];

	/* stop timer, and set clk src */
	bus_space_write_4(sxitimer_iot, sxitimer_ioh,
	    TIMER_CTRL(STATTIMER), TIMER_OSC24M);

	/* 100/1000 or 128/1024 ? */
	stathz = 128;
	profhz = 1024;
	sxitimer_setstatclockrate(stathz);

	ival = sxitimer_stat_tpi = freq / stathz;
	sxitimer_stat_nextevt = now - ival;

	bus_space_write_4(sxitimer_iot, sxitimer_ioh,
	    TIMER_INTV(STATTIMER), ival);

	/* timers are down-counters, from interval to 0 */
	now = 0xffffffff; /* known big value */
	freq = sxitimer_freq[CNTRTIMER];

	/* stop timer, and set clk src */
	bus_space_write_4(sxitimer_iot, sxitimer_ioh,
	    TIMER_CTRL(CNTRTIMER), TIMER_OSC24M);

	ival = now;

	sxitimer_timecounter.tc_frequency = freq;
	tc_init(&sxitimer_timecounter);
	arm_clock_register(sxitimer_cpu_initclocks, sxitimer_delay,
	    sxitimer_setstatclockrate, NULL);

	printf(": cntrtimer @@ %dKHz", freq / 1000);

	bus_space_write_4(sxitimer_iot, sxitimer_ioh,
	    TIMER_INTV(CNTRTIMER), ival);

	printf("\n");
}

/*
 * would be interesting to play with trigger mode while having one timer
 * in 32KHz mode, and the other timer running in sysclk mode and use
 * the high resolution speeds (matters more for delay than tick timer)
 */

void
sxitimer_cpu_initclocks(void)
{
	uint32_t isr, ier, ctrl;

	/* establish interrupts */
	arm_intr_establish(sxitimer_irq[TICKTIMER], IPL_CLOCK,
	    sxitimer_tickintr, NULL, "tick");
	arm_intr_establish(sxitimer_irq[STATTIMER], IPL_STATCLOCK,
	    sxitimer_statintr, NULL, "stattick");

	/* clear timer interrupt pending bits */
	isr = bus_space_read_4(sxitimer_iot, sxitimer_ioh, TIMER_ISR);
	isr |= TIMER_IRQ(STATTIMER) | TIMER_IRQ(TICKTIMER);
	bus_space_write_4(sxitimer_iot, sxitimer_ioh, TIMER_ISR, isr);

	/* enable timer IRQs */
	ier = bus_space_read_4(sxitimer_iot, sxitimer_ioh, TIMER_IER);
	ier |= TIMER_IRQ(STATTIMER) | TIMER_IRQ(TICKTIMER);
	bus_space_write_4(sxitimer_iot, sxitimer_ioh, TIMER_IER, ier);

	/* enable timers */
	ctrl = bus_space_read_4(sxitimer_iot, sxitimer_ioh,
	    TIMER_CTRL(CNTRTIMER));
	bus_space_write_4(sxitimer_iot, sxitimer_ioh,
	    TIMER_CTRL(CNTRTIMER),
	    ctrl | TIMER_ENABLE | TIMER_RELOAD | TIMER_CONTINOUS);

	ctrl = bus_space_read_4(sxitimer_iot, sxitimer_ioh,
	    TIMER_CTRL(STATTIMER));
	bus_space_write_4(sxitimer_iot, sxitimer_ioh,
	    TIMER_CTRL(STATTIMER),
	    ctrl | TIMER_ENABLE | TIMER_RELOAD | TIMER_SINGLESHOT);

	ctrl = bus_space_read_4(sxitimer_iot, sxitimer_ioh,
	    TIMER_CTRL(TICKTIMER));
	bus_space_write_4(sxitimer_iot, sxitimer_ioh,
	    TIMER_CTRL(TICKTIMER),
	    ctrl | TIMER_ENABLE | TIMER_RELOAD | TIMER_SINGLESHOT);
}

/* 
 * See comment in arm/xscale/i80321_clock.c
 *
 * Counter is count up, but with autoreload timers it is not possible
 * to detect how many interrupts passed while interrupts were blocked.
 * Also it is not possible to atomically add to the register.
 *
 * To work around this two timers are used, one is used as a reference
 * clock without reload, however we just disable the interrupt it
 * could generate.
 *
 * Internally this keeps track of when the next timer should fire
 * and based on that time and the current value of the reference
 * clock a number is written into the timer count register to schedule
 * the next event.
 */
/* XXX update above comment */
int
sxitimer_tickintr(void *frame)
{
	uint32_t now, nextevent;
	uint32_t val;
	int rc = 0;

	splassert(IPL_CLOCK);	

	/* clear timer pending interrupt bit */
	bus_space_write_4(sxitimer_iot, sxitimer_ioh,
	    TIMER_ISR, TIMER_IRQ(TICKTIMER));

	now = sxitimer_readcnt32();

	while ((int32_t)(now - sxitimer_tick_nextevt) < 0) {
		sxitimer_tick_nextevt -= sxitimer_tick_tpi;
		sxitimer_ticks_err_sum += sxitimer_ticks_err_cnt;

		while (sxitimer_ticks_err_sum  > hz) {
			sxitimer_tick_nextevt += 1;
			sxitimer_ticks_err_sum -= hz;
		}

		rc = 1;
		hardclock(frame);
	}
	nextevent = now - sxitimer_tick_nextevt;
	if (nextevent < 10 /* XXX */)
		nextevent = 10;

	if (nextevent > sxitimer_tick_tpi) {
		/*
		 * If interrupts are blocked too long, like during
		 * the root prompt or ddb, the timer can roll over,
		 * this will allow the system to continue to run
		 * even if time is lost.
		 */
		nextevent = sxitimer_tick_tpi;
		sxitimer_tick_nextevt = now;
	}

	val = bus_space_read_4(sxitimer_iot, sxitimer_ioh,
	    TIMER_CTRL(TICKTIMER));
	bus_space_write_4(sxitimer_iot, sxitimer_ioh,
	    TIMER_CTRL(TICKTIMER), val & ~TIMER_ENABLE);

	sxitimer_sync();

	bus_space_write_4(sxitimer_iot, sxitimer_ioh,
	    TIMER_INTV(TICKTIMER), nextevent);

	val = bus_space_read_4(sxitimer_iot, sxitimer_ioh,
	    TIMER_CTRL(TICKTIMER));
	bus_space_write_4(sxitimer_iot, sxitimer_ioh,
	    TIMER_CTRL(TICKTIMER),
	    val | TIMER_ENABLE | TIMER_RELOAD | TIMER_SINGLESHOT);

	return rc;
}

int
sxitimer_statintr(void *frame)
{
	uint32_t now, nextevent, r;
	uint32_t val;
	int rc = 0;

	splassert(IPL_STATCLOCK);	

	/* clear timer pending interrupt bit */
	bus_space_write_4(sxitimer_iot, sxitimer_ioh,
	    TIMER_ISR, TIMER_IRQ(STATTIMER));

	now = sxitimer_readcnt32();
	while ((int32_t)(now - sxitimer_stat_nextevt) < 0) {
		do {
			r = random() & (sxitimer_statvar -1);
		} while (r == 0); /* random == 0 not allowed */
		sxitimer_stat_nextevt -= sxitimer_statmin + r;
		rc = 1;
		statclock(frame);
	}

	nextevent = now - sxitimer_stat_nextevt;

	if (nextevent < 10 /* XXX */)
		nextevent = 10;

	if (nextevent > sxitimer_stat_tpi) {
		/*
		 * If interrupts are blocked too long, like during
		 * the root prompt or ddb, the timer can roll over,
		 * this will allow the system to continue to run
		 * even if time is lost.
		 */
		nextevent = sxitimer_stat_tpi;
		sxitimer_stat_nextevt = now;
	}

	val = bus_space_read_4(sxitimer_iot, sxitimer_ioh,
	    TIMER_CTRL(STATTIMER));
	bus_space_write_4(sxitimer_iot, sxitimer_ioh,
	    TIMER_CTRL(STATTIMER), val & ~TIMER_ENABLE);

	sxitimer_sync();

	bus_space_write_4(sxitimer_iot, sxitimer_ioh,
	    TIMER_INTV(STATTIMER), nextevent);

	val = bus_space_read_4(sxitimer_iot, sxitimer_ioh,
	    TIMER_CTRL(STATTIMER));
	bus_space_write_4(sxitimer_iot, sxitimer_ioh,
	    TIMER_CTRL(STATTIMER),
	    val | TIMER_ENABLE | TIMER_RELOAD | TIMER_SINGLESHOT);

	return rc;
}

uint64_t
sxitimer_readcnt64(void)
{
	uint32_t low, high;

	/* latch counter, loop until ready */
	bus_space_write_4(sxitimer_iot, sxitimer_ioh, CNT64_CTRL, CNT64_RL_EN);
	while (bus_space_read_4(sxitimer_iot, sxitimer_ioh, CNT64_CTRL)
	    & CNT64_RL_EN)
		continue;

	/*
	 * A10 usermanual doesn't mention anything about order, but fwiw
	 * iirc. A20 manual mentions that low should be read first.
	 */
	/* XXX check above */
	low = bus_space_read_4(sxitimer_iot, sxitimer_ioh, CNT64_LOW);
	high = bus_space_read_4(sxitimer_iot, sxitimer_ioh, CNT64_HIGH);
	return (uint64_t)high << 32 | low;
}

uint32_t
sxitimer_readcnt32(void)
{
	return bus_space_read_4(sxitimer_iot, sxitimer_ioh,
	    TIMER_CURR(CNTRTIMER));
}

void
sxitimer_sync(void)
{
	uint32_t now = sxitimer_readcnt32();

	while ((now - sxitimer_readcnt32()) < TIMER_SYNC)
		CPU_BUSY_CYCLE();
}

void
sxitimer_delay(u_int usecs)
{
	uint64_t oclock, timeout;

	oclock = sxitimer_readcnt64();
	timeout = oclock + (COUNTER_FREQUENCY / 1000000) * usecs;

	while (oclock < timeout)
		oclock = sxitimer_readcnt64();
}

void
sxitimer_setstatclockrate(int newhz)
{
	int minint, statint, s;
	
	s = splstatclock();

	statint = sxitimer_freq[STATTIMER] / newhz;
	/* calculate largest 2^n which is smaller than just over half statint */
	sxitimer_statvar = 0x40000000; /* really big power of two */
	minint = statint / 2 + 100;
	while (sxitimer_statvar > minint)
		sxitimer_statvar >>= 1;

	sxitimer_statmin = statint - (sxitimer_statvar >> 1);

	splx(s);

	/*
	 * XXX this allows the next stat timer to occur then it switches
	 * to the new frequency. Rather than switching instantly.
	 */
}

u_int
sxitimer_get_timecount(struct timecounter *tc)
{
	return (u_int)UINT_MAX - sxitimer_readcnt32();
}
@


1.10
log
@Move Allwinner drivers that will soon be used by OpenBSD/arm64
to the new MI FDT driver directory.

"go ahead" kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sxitimer.c,v 1.9 2016/10/23 13:24:42 kettenis Exp $	*/
a19 1
#include <sys/types.h>
@


1.9
log
@Only attach on sun4i and sun5i.  The timer implemented on later SoCs lacks
the 64-bit counter that we use as timecounter.  Those SoCs have a generic
timer so we don't need the SoC-specific one.
@
text
@d1 1
a1 1
/*	$OpenBSD: sxitimer.c,v 1.8 2016/10/22 15:16:25 kettenis Exp $	*/
d37 1
a37 1
#include <armv7/sunxi/sunxireg.h>
@


1.8
log
@Attach sxitimer(4) using the fdt.
@
text
@d1 1
a1 1
/*	$OpenBSD: sxitimer.c,v 1.7 2016/10/21 20:03:57 kettenis Exp $	*/
d136 7
@


1.7
log
@Run timers from the 24MHz; it seems the A10s doesn't have a reliable 32kHz
clock.  Fixes the clock on the Olimux A10s OLinuXino-Micro board.
@
text
@d1 1
a1 1
/*	$OpenBSD: sxitimer.c,v 1.6 2016/07/18 19:22:45 kettenis Exp $	*/
d33 1
d40 3
d81 1
d124 2
a125 2
struct cfattach	sxitimer_ca = {
	sizeof (struct sxitimer_softc), NULL, sxitimer_attach
d132 8
d141 1
a141 1
sxitimer_attach(struct device *parent, struct device *self, void *args)
d143 1
a143 1
	struct armv7_attach_args *aa = args;
a144 1
	int unit = self->dv_unit;
d146 1
a146 2
	if (unit != 0)
		goto skip_init;
d148 4
a151 5
	sxitimer_iot = aa->aa_iot;

	if (bus_space_map(sxitimer_iot, aa->aa_dev->mem[0].addr,
	    aa->aa_dev->mem[0].size, 0, &sxitimer_ioh))
		panic("sxitimer_attach: bus_space_map failed!");
a159 1
skip_init:
d162 1
a162 1
	freq = sxitimer_freq[unit];
d166 44
a209 1
	    TIMER_CTRL(unit), TIMER_OSC24M);
d211 1
a211 35
	switch (unit) { /* XXX more XXXXTIMER magic for less lines? */
	case TICKTIMER:
		ival = sxitimer_tick_tpi = freq / hz;
		sxitimer_tick_nextevt = now - ival;

		sxitimer_ticks_err_cnt = freq % hz;
		sxitimer_ticks_err_sum = 0;

		printf(": ticktimer %dhz @@ %dKHz", hz, freq / 1000);
		break;
	case STATTIMER:
		/* 100/1000 or 128/1024 ? */
		stathz = 128;
		profhz = 1024;
		sxitimer_setstatclockrate(stathz);

		ival = sxitimer_stat_tpi = freq / stathz;
		sxitimer_stat_nextevt = now - ival;

		printf(": stattimer %dhz @@ %dKHz", stathz, freq / 1000);
		break;
	case CNTRTIMER:
		ival = now;

		sxitimer_timecounter.tc_frequency = freq;
		tc_init(&sxitimer_timecounter);
		arm_clock_register(sxitimer_cpu_initclocks, sxitimer_delay,
		    sxitimer_setstatclockrate, NULL);

		printf(": cntrtimer @@ %dKHz", freq / 1000);
		break;
	default:
		panic("sxitimer_attach: unit = %d", unit);
		break;
	}
d214 1
a214 1
	    TIMER_INTV(unit), ival);
@


1.6
log
@Apparently we need to explicitly stop the timers before reloading them.  At
least this is what Linux does and it fixes a hang on the Olimex A10s boards.
While there, also preserve the clock selection when reloading the timer.

ok patrick@@, jsg@@, tom@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sxitimer.c,v 1.5 2016/02/01 23:31:34 jsg Exp $	*/
a54 3
#define	LOSC_CTRL		0x100
#define	OSC32K_SRC_SEL		(1 << 0)

a57 1
#define	TIMER_LSOSC		(0 << 2)
d131 1
a131 1
	uint32_t freq, ival, now, cr;
a149 5
	/* setup timers */
	cr = bus_space_read_4(sxitimer_iot, sxitimer_ioh, LOSC_CTRL);
	cr |= OSC32K_SRC_SEL; /* ext 32.768KHz OSC src */
	bus_space_write_4(sxitimer_iot, sxitimer_ioh, LOSC_CTRL, cr);

d157 1
a157 2
	    TIMER_CTRL(unit),
	    freq == 24000000 ? TIMER_OSC24M : TIMER_LSOSC);
d210 1
a210 1
	uint32_t isr, ier;
d229 2
d233 1
a233 1
	    TIMER_ENABLE | TIMER_RELOAD | TIMER_CONTINOUS);
d235 2
d239 1
a239 1
	    TIMER_ENABLE | TIMER_RELOAD | TIMER_SINGLESHOT);
d241 2
d245 1
a245 1
	    TIMER_ENABLE | TIMER_RELOAD | TIMER_SINGLESHOT);
@


1.5
log
@Remove A20 support in sxitimer, agtimer is now used instead.
From Artturi Alm.
@
text
@d1 1
a1 1
/*	$OpenBSD: sxitimer.c,v 1.4 2015/05/19 06:04:26 jsg Exp $	*/
d79 2
d88 1
d273 1
d311 7
d321 2
d325 1
a325 1
	    TIMER_ENABLE | TIMER_RELOAD | TIMER_SINGLESHOT);
d334 1
d369 7
d379 2
d383 1
a383 1
	    TIMER_ENABLE | TIMER_RELOAD | TIMER_SINGLESHOT);
d414 9
@


1.4
log
@rename global variables to not conflict with gptimer
@
text
@d1 1
a1 1
/*	$OpenBSD: sxitimer.c,v 1.3 2013/11/06 19:03:07 syl Exp $	*/
a46 5
/* A20 counter, relative to CPUCNTRS_ADDR */
#define	OSC24M_CNT64_CTRL	0x80
#define	OSC24M_CNT64_LOW	0x84
#define	OSC24M_CNT64_HIGH	0x88

a53 1
#define	CNT64_SYNCH		(1 << 4) /* sync to OSC24M counter */
a95 1
bus_space_handle_t	sxitimer_cntr_ioh;
a115 4
bus_addr_t cntr64_ctrl = CNT64_CTRL;
bus_addr_t cntr64_low = CNT64_LOW;
bus_addr_t cntr64_high = CNT64_HIGH;

d132 1
a132 1
	uint32_t freq, ival, now, cr, v;
a143 19

	if (board_id == BOARD_ID_SUN7I_A20) {
		if (bus_space_map(sxitimer_iot, CPUCNTRS_ADDR, CPUCNTRS_SIZE,
		    0, &sxitimer_cntr_ioh))
			panic("sxitimer_attach: bus_space_map failed!");

		cntr64_ctrl = OSC24M_CNT64_CTRL;
		cntr64_low = OSC24M_CNT64_LOW;
		cntr64_high = OSC24M_CNT64_HIGH;

		v = bus_space_read_4(sxitimer_iot, sxitimer_cntr_ioh,
		    cntr64_ctrl);
		bus_space_write_4(sxitimer_iot, sxitimer_cntr_ioh, cntr64_ctrl,
		    v | CNT64_SYNCH);
		bus_space_write_4(sxitimer_iot, sxitimer_cntr_ioh, cntr64_ctrl,
		    v & ~CNT64_SYNCH);
	} else
		sxitimer_cntr_ioh = sxitimer_ioh;

d145 1
a145 1
	bus_space_write_4(sxitimer_iot, sxitimer_cntr_ioh, cntr64_ctrl,
d147 1
a147 1
	while (bus_space_read_4(sxitimer_iot, sxitimer_cntr_ioh, cntr64_ctrl)
d371 2
a372 3
	bus_space_write_4(sxitimer_iot, sxitimer_cntr_ioh,
	    cntr64_ctrl, CNT64_RL_EN);
	while (bus_space_read_4(sxitimer_iot, sxitimer_cntr_ioh, cntr64_ctrl)
d381 2
a382 2
	low = bus_space_read_4(sxitimer_iot, sxitimer_cntr_ioh, cntr64_low);
	high = bus_space_read_4(sxitimer_iot, sxitimer_cntr_ioh, cntr64_high);
@


1.3
log
@After factorizing armv7_machdep code here is an effort to factorize all
the code present in omap/omap.c imx/imx.c and sunxi/sunxi.c

All this code looks quite the same, so we move it in a generic armv7/armv7.c

This is a step closer to only one kernel for all armv7 boards.

ok patrick@@, rapha@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sxitimer.c,v 1.2 2013/10/27 12:58:53 jasper Exp $	*/
d118 4
a121 4
uint32_t stat_tpi, tick_tpi;
uint32_t statvar, statmin;
uint32_t tick_nextevt, stat_nextevt;
uint32_t ticks_err_cnt, ticks_err_sum;
d198 2
a199 2
		ival = tick_tpi = freq / hz;
		tick_nextevt = now - ival;
d201 2
a202 2
		ticks_err_cnt = freq % hz;
		ticks_err_sum = 0;
d212 2
a213 2
		ival = stat_tpi = freq / stathz;
		stat_nextevt = now - ival;
d310 7
a316 7
	while ((int32_t)(now - tick_nextevt) < 0) {
		tick_nextevt -= tick_tpi;
		ticks_err_sum += ticks_err_cnt;

		while (ticks_err_sum  > hz) {
			tick_nextevt += 1;
			ticks_err_sum -= hz;
d322 1
a322 1
	nextevent = now - tick_nextevt;
d326 1
a326 1
	if (nextevent > tick_tpi) {
d333 2
a334 2
		nextevent = tick_tpi;
		tick_nextevt = now;
d360 1
a360 1
	while ((int32_t)(now - stat_nextevt) < 0) {
d362 1
a362 1
			r = random() & (statvar -1);
d364 1
a364 1
		stat_nextevt -= statmin + r;
d369 1
a369 1
	nextevent = now - stat_nextevt;
d374 1
a374 1
	if (nextevent > stat_tpi) {
d381 2
a382 2
		nextevent = stat_tpi;
		stat_nextevt = now;
d445 1
a445 1
	statvar = 0x40000000; /* really big power of two */
d447 2
a448 2
	while (statvar > minint)
		statvar >>= 1;
d450 1
a450 1
	statmin = statint - (statvar >> 1);
@


1.2
log
@Fix timer on for A20 as the address and offsets for the A20 counter were off.

from Markus Hennecke, ok aalm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sxitimer.c,v 1.1 2013/10/23 17:08:48 jasper Exp $	*/
d35 1
a35 1
#include <armv7/sunxi/sunxivar.h>
d142 1
a142 1
	struct sxi_attach_args	*sxi = args;
d149 1
a149 1
	sxitimer_iot = sxi->sxi_iot;
d151 2
a152 2
	if (bus_space_map(sxitimer_iot, sxi->sxi_dev->mem[0].addr,
	    sxi->sxi_dev->mem[0].size, 0, &sxitimer_ioh))
@


1.1
log
@rename 'allwinner' to 'sunxi' to actually match the SoC name instead of using
the vendor to follow our naming convention.

ok aalm@@ patrick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sxitimer.c,v 1.1 2013/10/22 13:22:19 jasper Exp $	*/
d47 4
a50 4
/* A20 counter */
#define	OSC24M_CNT64_CTRL	0x280
#define	OSC24M_CNT64_LOW	0x284
#define	OSC24M_CNT64_HIGH	0x288
@

