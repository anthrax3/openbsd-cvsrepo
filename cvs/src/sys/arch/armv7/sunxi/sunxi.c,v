head	1.21;
access;
symbols
	OPENBSD_6_0:1.13.0.2
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.8.0.2
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.6.0.4
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.3.0.2
	OPENBSD_5_7_BASE:1.3
	OPENBSD_5_6:1.3.0.6
	OPENBSD_5_6_BASE:1.3
	OPENBSD_5_5:1.3.0.4
	OPENBSD_5_5_BASE:1.3;
locks; strict;
comment	@ * @;


1.21
date	2016.10.22.15.16.25;	author kettenis;	state Exp;
branches;
next	1.20;
commitid	mjaDtGaGcrXazKVz;

1.20
date	2016.10.09.11.14.22;	author kettenis;	state Exp;
branches;
next	1.19;
commitid	aiJLMeOtKpZ2nF7H;

1.19
date	2016.10.08.09.50.14;	author kettenis;	state Exp;
branches;
next	1.18;
commitid	FICmyJkPAYUIRIay;

1.18
date	2016.08.27.11.39.59;	author kettenis;	state Exp;
branches;
next	1.17;
commitid	VAEfQIurUSrNJW4z;

1.17
date	2016.08.05.21.45.37;	author kettenis;	state Exp;
branches;
next	1.16;
commitid	cC1sDGu6YTDVjn44;

1.16
date	2016.08.05.21.39.02;	author kettenis;	state Exp;
branches;
next	1.15;
commitid	RjXyYfD5h3ri6Uqw;

1.15
date	2016.08.05.19.00.25;	author kettenis;	state Exp;
branches;
next	1.14;
commitid	PWnrMbYWs67oDQuR;

1.14
date	2016.07.27.22.03.52;	author mglocker;	state Exp;
branches;
next	1.13;
commitid	xx2Phm5ZgNg3j9ZC;

1.13
date	2016.07.17.17.45.14;	author kettenis;	state Exp;
branches;
next	1.12;
commitid	833saftytGI4pCvo;

1.12
date	2016.06.11.07.07.59;	author jsg;	state Exp;
branches;
next	1.11;
commitid	Zr64rpowLR8WCMql;

1.11
date	2016.06.11.06.42.16;	author jsg;	state Exp;
branches;
next	1.10;
commitid	P3TWFuwvfad353N2;

1.10
date	2016.06.04.18.09.16;	author jsg;	state Exp;
branches;
next	1.9;
commitid	tYyT96DOGdhLjy9v;

1.9
date	2016.05.02.15.27.24;	author patrick;	state Exp;
branches;
next	1.8;
commitid	gOMXBf6ijXFQHRgk;

1.8
date	2016.02.02.03.31.22;	author jsg;	state Exp;
branches;
next	1.7;
commitid	RbRzD1v0uZj2WQEC;

1.7
date	2016.01.31.04.39.05;	author jsg;	state Exp;
branches;
next	1.6;
commitid	EwOiowgzBwq38DmW;

1.6
date	2015.05.20.00.14.56;	author jsg;	state Exp;
branches;
next	1.5;
commitid	Y47vqpZ6HtQSLXGx;

1.5
date	2015.05.19.03.30.54;	author jsg;	state Exp;
branches;
next	1.4;
commitid	l6xI4SC4UUe6il2U;

1.4
date	2015.05.15.15.35.43;	author jsg;	state Exp;
branches;
next	1.3;
commitid	AFNG6oUBgS2y44wd;

1.3
date	2013.11.06.19.03.07;	author syl;	state Exp;
branches;
next	1.2;

1.2
date	2013.10.23.18.01.52;	author jasper;	state Exp;
branches;
next	1.1;

1.1
date	2013.10.23.17.08.48;	author jasper;	state Exp;
branches;
next	;


desc
@@


1.21
log
@Attach sxitimer(4) using the fdt.
@
text
@/* $OpenBSD: sunxi.c,v 1.20 2016/10/09 11:14:22 kettenis Exp $ */
/*
 * Copyright (c) 2005,2008 Dale Rahn <drahn@@openbsd.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/systm.h>

#include <machine/bus.h>

#include <arm/armv7/armv7var.h>
#include <arm/mainbus/mainbus.h>
#include <armv7/armv7/armv7var.h>
#include <armv7/sunxi/sunxireg.h>

#include <dev/ofw/fdt.h>

int	sunxi_match(struct device *, void *, void *);
void	sxia1x_init();
void	sxia20_init();

struct cfattach sunxi_ca = {
	sizeof(struct armv7_softc), sunxi_match, armv7_attach
};

struct cfdriver sunxi_cd = {
	NULL, "sunxi", DV_DULL
};

struct board_dev sun4i_devs[] = {
	{ NULL,		0 }
};

struct board_dev sun5i_devs[] = {
	{ NULL,		0 }
};

struct board_dev sun7i_devs[] = {
	{ NULL,		0 }
};

struct sunxi_soc {
	char			*compatible;
	struct board_dev	*devs;
	void			(*init)(void);
};

struct sunxi_soc sunxi_socs[] = {
	{
		"allwinner,sun4i-a10",
		sun4i_devs,
		sxia1x_init,
	},
	{
		"allwinner,sun5i-a10s",
		sun5i_devs,
		sxia1x_init,
	},
	{
		"allwinner,sun5i-r8",
		sun5i_devs,
		sxia1x_init,
	},
	{
		"allwinner,sun7i-a20",
		sun7i_devs,
		sxia20_init,
	},
	{
		"allwinner,sun8i-h3",
		sun7i_devs,
		sxia20_init,
	},
	{ NULL, NULL, NULL },
};

struct board_dev *
sunxi_board_devs(void)
{
	void *node;
	int i;

	node = fdt_find_node("/");
	if (node == NULL)
		return NULL;

	for (i = 0; sunxi_socs[i].compatible != NULL; i++) {
		if (fdt_is_compatible(node, sunxi_socs[i].compatible))
			return sunxi_socs[i].devs;
	}
	return NULL;
}

void
sunxi_board_init(void)
{
	bus_space_handle_t ioh;
	void *node;
	int i, match = 0;

	node = fdt_find_node("/");
	if (node == NULL)
		return;

	for (i = 0; sunxi_socs[i].compatible != NULL; i++) {
		if (fdt_is_compatible(node, sunxi_socs[i].compatible)) {
			sunxi_socs[i].init();
			match = 1;
			break;
		}
	}

	if (match) {
		if (bus_space_map(&armv7_bs_tag, SYSCTRL_ADDR, SYSCTRL_SIZE, 0,
		    &ioh))
			panic("sunxi_attach: bus_space_map failed!");
		/* map the part of SRAM dedicated to EMAC to EMAC */
		bus_space_write_4(&armv7_bs_tag, ioh, 4,
		    bus_space_read_4(&armv7_bs_tag, ioh, 4) | (5 << 2));
	}
}

int
sunxi_match(struct device *parent, void *cfdata, void *aux)
{
	union mainbus_attach_args *ma = (union mainbus_attach_args *)aux;
	struct cfdata *cf = (struct cfdata *)cfdata;

	if (ma->ma_name == NULL)
		return (0);

	if (strcmp(cf->cf_driver->cd_name, ma->ma_name) != 0)
		return (0);

	return (sunxi_board_devs() != NULL);
}
@


1.20
log
@Attach sxiccmu(4) using the fdt.

ok jsg@@
@
text
@d1 1
a1 1
/* $OpenBSD: sunxi.c,v 1.19 2016/10/08 09:50:14 kettenis Exp $ */
a42 3
	{ "sxitimer",	0 },
	{ "sxitimer",	1 },
	{ "sxitimer",	2 },
a46 3
	{ "sxitimer",	0 },
	{ "sxitimer",	1 },
	{ "sxitimer",	2 },
@


1.19
log
@Attach sxipio(4) using the fdt.

ok jsg@@, patrick@@
@
text
@d1 1
a1 1
/* $OpenBSD: sunxi.c,v 1.18 2016/08/27 11:39:59 kettenis Exp $ */
a42 1
	{ "sxiccmu",	0 },
a49 1
	{ "sxiccmu",	0 },
a56 1
	{ "sxiccmu",	0 },
@


1.18
log
@Add support for sun8i-h3, the Allwinner H3.  For this SoC, the device tree
contains a single clock control unit node that handles most clocks.  The
driver handles this through tables that describe the gating, reset signals
and the clock hierarchy.  This description is (deliberately) incomplete.  We
will add clocks on an as-needed basis.  You will need a recent device tree,
that includes a "allwinner,sun8i-h3-ccu" compatible node for things to work.

ok patrick@@
@
text
@d1 1
a1 1
/* $OpenBSD: sunxi.c,v 1.17 2016/08/05 21:45:37 kettenis Exp $ */
a42 1
	{ "sxipio",	0 },
a50 1
	{ "sxipio",	0 },
a58 1
	{ "sxipio",	0 },
@


1.17
log
@Dynamically attach sxidog(4).
@
text
@d1 1
a1 1
/* $OpenBSD: sunxi.c,v 1.16 2016/08/05 21:39:02 kettenis Exp $ */
d90 5
@


1.16
log
@Remove sxirtc(4) from the tables now that it attaches dynamically.
@
text
@d1 1
a1 1
/* $OpenBSD: sunxi.c,v 1.15 2016/08/05 19:00:25 kettenis Exp $ */
a47 1
	{ "sxidog",	0 },
a56 1
	{ "sxidog",	0 },
a62 1
	{ "sxidog",	0 },
@


1.15
log
@Switch the sunxi platform over to the new interrupt establish API.  This
involves turning sxiahci(4) into a real driver that dynamically attaches.
ehci(4) now also attaches dynamically.

ok jsg@@, patrick@@
@
text
@d1 1
a1 1
/* $OpenBSD: sunxi.c,v 1.14 2016/07/27 22:03:52 mglocker Exp $ */
a48 1
	{ "sxirtc",	0 },
a65 1
	{ "sxirtc",	0 },
@


1.14
log
@Get interrupts going for the Allwinner-R8 chip.

ok kettenis@@, patrick@@
@
text
@d1 1
a1 1
/* $OpenBSD: sunxi.c,v 1.13 2016/07/17 17:45:14 kettenis Exp $ */
a44 1
	{ "a1xintc",	0 },
a49 7
	{ "ahci",	0 },
	{ "ehci",	0 },
	{ "ehci",	1 },
#if 0
	{ "ohci",	0 },
	{ "ohci",	1 },
#endif
a55 1
	{ "a1xintc",	0 },
a59 4
	{ "ehci",	0 },
#if 0
	{ "ohci",	0 },
#endif
a67 7
	{ "ahci",	0 },
	{ "ehci",	0 },
	{ "ehci",	1 },
#if 0
	{ "ohci",	0 },
	{ "ohci",	1 },
#endif
@


1.13
log
@Attach sunxi(4) based on the compatible property of the root node of the
device tree like we do on omap.  Add preliminary support for the sun5i
variant which corresponds to the A13 and A10s SoCs.

ok patrick@@
@
text
@d1 1
a1 1
/* $OpenBSD: sunxi.c,v 1.12 2016/06/11 07:07:59 jsg Exp $ */
d105 5
@


1.12
log
@dynamically attach sxiuart using the FDT
@
text
@d1 1
a1 1
/* $OpenBSD: sunxi.c,v 1.11 2016/06/11 06:42:16 jsg Exp $ */
d28 2
d61 15
d91 7
a97 1
struct armv7_board sunxi_boards[] = {
d99 1
a99 1
		BOARD_ID_SUN4I_A10,
d104 6
a109 1
		BOARD_ID_SUN7I_A20,
d113 1
a113 1
	{ 0, NULL, NULL },
d119 1
d122 7
a128 3
	for (i = 0; sunxi_boards[i].board_id != 0; i++) {
		if (sunxi_boards[i].board_id == board_id)
			return (sunxi_boards[i].devs);
d130 1
a130 1
	return (NULL);
d137 1
d140 7
a146 3
	for (i = 0; sunxi_boards[i].board_id != 0; i++) {
		if (sunxi_boards[i].board_id == board_id) {
			sunxi_boards[i].init();
@


1.11
log
@dynamically attach sxie(4) using the FDT
@
text
@d1 1
a1 1
/* $OpenBSD: sunxi.c,v 1.10 2016/06/04 18:09:16 jsg Exp $ */
a48 8
	{ "sxiuart",	0 },
	{ "sxiuart",	1 },
	{ "sxiuart",	2 },
	{ "sxiuart",	3 },
	{ "sxiuart",	4 },
	{ "sxiuart",	5 },
	{ "sxiuart",	6 },
	{ "sxiuart",	7 },
a63 8
	{ "sxiuart",	0 },
	{ "sxiuart",	1 },
	{ "sxiuart",	2 },
	{ "sxiuart",	3 },
	{ "sxiuart",	4 },
	{ "sxiuart",	5 },
	{ "sxiuart",	6 },
	{ "sxiuart",	7 },
@


1.10
log
@Remove model specific strings keyed off the board id.
We now pull the model string from fdt.
@
text
@d1 1
a1 1
/* $OpenBSD: sunxi.c,v 1.9 2016/05/02 15:27:24 patrick Exp $ */
a56 1
	{ "sxie",	0 },
a79 1
	{ "sxie",	0 },
@


1.9
log
@Add check to armv7 platform bus match code, so that those busses only
attach if we are running in legacy mode.

ok jsg@@
@
text
@d1 1
a1 1
/* $OpenBSD: sunxi.c,v 1.8 2016/02/02 03:31:22 jsg Exp $ */
a94 1
		"Allwinner A1x",
a99 1
		"Allwinner A20",
d103 1
a103 1
	{ 0, NULL, NULL, NULL },
d111 1
a111 1
	for (i = 0; sunxi_boards[i].name != NULL; i++) {
d124 1
a124 1
	for (i = 0; sunxi_boards[i].name != NULL; i++) {
a139 12
}

const char *
sunxi_board_name(void)
{
	int i;

	for (i = 0; sunxi_boards[i].name != NULL; i++) {
		if (sunxi_boards[i].board_id == board_id)
			return (sunxi_boards[i].name);
	}
	return (NULL);
@


1.8
log
@remove uneeded break statements
@
text
@d1 1
a1 1
/* $OpenBSD: sunxi.c,v 1.7 2016/01/31 04:39:05 jsg Exp $ */
d24 1
d159 9
@


1.7
log
@Don't use sxitimer on Allwinner sun7i/A20.

sxitimer isn't generating hardclock ticks on Allwinner A20.  Fortunately
the Cortex A7 based Allwinner A20 has the ARM Generic Timer (agtimer)
available so use that.

To allow this to work sxirtc gets it's own mapping instead of using a
subregion of sxitimer.

From Patrick Wildt.
@
text
@d1 1
a1 1
/* $OpenBSD: sunxi.c,v 1.6 2015/05/20 00:14:56 jsg Exp $ */
d149 1
a149 1
		if (sunxi_boards[i].board_id == board_id) {
a150 2
			break;
		}
@


1.6
log
@add per soc match functions instead of using armv7_match
@
text
@d1 1
a1 1
/* $OpenBSD: sunxi.c,v 1.5 2015/05/19 03:30:54 jsg Exp $ */
a69 3
	{ "sxitimer",	0 },
	{ "sxitimer",	1 },
	{ "sxitimer",	2 },
@


1.5
log
@Abstract the soc_machdep.c functions to allow a kernel to be built for
multiple socs.

From Patrick Wildt in bitrig with some additional changes.
@
text
@d1 1
a1 1
/* $OpenBSD: sunxi.c,v 1.4 2015/05/15 15:35:43 jsg Exp $ */
d27 3
a29 2
void sxia1x_init();
void sxia20_init();
d32 1
a32 1
	sizeof(struct armv7_softc), armv7_match, armv7_attach
d158 6
@


1.4
log
@Make board attaching table driven and move it out into the soc
directories.  Move the device tables while here as was done in bitrig.
With these changes the only use of the board id defines is in the soc
directories.

Tested by matthieu and djm on imx and myself on omap and sunxi (qemu).
ok djm@@, ok jasper@@ on an earlier version
@
text
@d1 1
a1 1
/* $OpenBSD: sunxi.c,v 1.3 2013/11/06 19:03:07 syl Exp $ */
d27 3
d109 11
d121 2
a122 2
struct board_dev *
sunxi_board_attach(void)
a123 1
	struct board_dev *devs = NULL;
d125 1
a125 1
	int i;
d130 1
a130 1
			devs = sunxi_boards[i].devs;
d135 1
a135 1
	if (devs) {
a142 2

	return (devs);
@


1.3
log
@After factorizing armv7_machdep code here is an effort to factorize all
the code present in omap/omap.c imx/imx.c and sunxi/sunxi.c

All this code looks quite the same, so we move it in a generic armv7/armv7.c

This is a step closer to only one kernel for all armv7 boards.

ok patrick@@, rapha@@
@
text
@d1 1
a1 1
/* $OpenBSD: sunxi.c,v 1.2 2013/10/23 18:01:52 jasper Exp $ */
d23 1
d25 1
d34 113
@


1.2
log
@rename some defines as well
@
text
@d1 1
a1 1
/* $OpenBSD: sunxi.c,v 1.1 2013/10/23 17:08:48 jasper Exp $ */
a19 8
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/reboot.h>
#define _ARM32_BUS_DMA_PRIVATE
/* #include <machine/bus.h> */
#include <arch/arm/armv7/armv7var.h>
#include <armv7/sunxi/sunxivar.h>
#include <armv7/sunxi/sunxireg.h>
d21 1
a21 81
struct arm32_bus_dma_tag sunxi_bus_dma_tag = {
	0,
	0,
	NULL,
	_bus_dmamap_create,
	_bus_dmamap_destroy,
	_bus_dmamap_load,
	_bus_dmamap_load_mbuf,
	_bus_dmamap_load_uio,
	_bus_dmamap_load_raw,
	_bus_dmamap_unload,
	_bus_dmamap_sync,
	_bus_dmamem_alloc,
	_bus_dmamem_free,
	_bus_dmamem_map,
	_bus_dmamem_unmap,
	_bus_dmamem_mmap,
};

struct board_dev {
	char *name;
	int unit;
};

struct board_dev sun4i_devs[] = {
	{ "sxipio",	0 },
	{ "sxiccmu",	0 },
	{ "a1xintc",	0 },
	{ "sxitimer",	0 },
	{ "sxitimer",	1 },
	{ "sxitimer",	2 },
	{ "sxidog",	0 },
	{ "sxirtc",	0 },
	{ "sxiuart",	0 },
	{ "sxiuart",	1 },
	{ "sxiuart",	2 },
	{ "sxiuart",	3 },
	{ "sxiuart",	4 },
	{ "sxiuart",	5 },
	{ "sxiuart",	6 },
	{ "sxiuart",	7 },
	{ "sxie",	0 },
	{ "ahci",	0 },
	{ "ehci",	0 },
	{ "ehci",	1 },
#if 0
	{ "ohci",	0 },
	{ "ohci",	1 },
#endif
	{ NULL,		0 }
};

struct board_dev sun7i_devs[] = {
	{ "sxipio",	0 },
	{ "sxiccmu",	0 },
	{ "sxitimer",	0 },
	{ "sxitimer",	1 },
	{ "sxitimer",	2 },
	{ "sxidog",	0 },
	{ "sxirtc",	0 },
	{ "sxiuart",	0 },
	{ "sxiuart",	1 },
	{ "sxiuart",	2 },
	{ "sxiuart",	3 },
	{ "sxiuart",	4 },
	{ "sxiuart",	5 },
	{ "sxiuart",	6 },
	{ "sxiuart",	7 },
	{ "sxie",	0 },
	{ "ahci",	0 },
	{ "ehci",	0 },
	{ "ehci",	1 },
#if 0
	{ "ohci",	0 },
	{ "ohci",	1 },
#endif
	{ NULL,		0 }
};

struct board_dev *board_devs;
struct sxi_dev *sunxi_devs = NULL;
d23 1
a23 13
extern void sxia1x_init(void);
extern void sxia20_init(void);

struct sunxi_softc {
	struct device		sc_dev;
	bus_space_tag_t		sc_iot;
	bus_space_handle_t	sc_ioh;
	bus_dma_tag_t		sc_dmat;
};

int	sunxi_match(struct device *, void *, void *);
void	sunxi_attach(struct device *, struct device *, void *);
int	sxi_submatch(struct device *, void *, void *);
d26 1
a26 1
	sizeof(struct sunxi_softc), sunxi_match, sunxi_attach
a31 102

int
sunxi_match(struct device *parent, void *cfdata, void *aux)
{
	return 1;
}

void
sunxi_attach(struct device *parent, struct device *self, void *aux)
{
	struct sunxi_softc *sc = (struct sunxi_softc *)self;
	struct board_dev *bd;
	sc->sc_iot = &armv7_bs_tag;
	sc->sc_dmat = &sunxi_bus_dma_tag;

	switch (board_id) {
	case BOARD_ID_SUN4I_A10:
		printf(": A1X\n");
		sxia1x_init();
		board_devs = sun4i_devs;
		break;
	case BOARD_ID_SUN7I_A20:
		printf(": A20\n");
		sxia20_init();
		board_devs = sun7i_devs;
		break;
	default:
		printf("\n");
		panic("sunxi_attach: board type 0x%x unknown", board_id);
	}

#if 1
	/*
	 * XXX think of a better place to do this, as there might
	 * be need for access by other drivers later.
	 */
	if (bus_space_map(sc->sc_iot, SYSCTRL_ADDR, SYSCTRL_SIZE, 0,
	    &sc->sc_ioh))
		panic("sunxi_attach: bus_space_map failed!");
	/* map the part of SRAM dedicated to EMAC to EMAC */
	SXISET4(sc, 4, 5 << 2);
#endif

	/* Directly configure on-board devices (dev* in config file). */
	for (bd = board_devs; bd->name != NULL; bd++) {
		struct sxi_dev *sxid = sxi_find_dev(bd->name, bd->unit);
		struct sxi_attach_args sxi;

		if (sxid == NULL) {
			printf("%s: device %s unit %d not found\n",
			    self->dv_xname, bd->name, bd->unit);
			continue;
		}

		memset(&sxi, 0, sizeof(sxi));
		sxi.sxi_dev = sxid;
		sxi.sxi_iot = sc->sc_iot;
		sxi.sxi_dmat = sc->sc_dmat;

		if (config_found_sm(self, &sxi, NULL, sxi_submatch) == NULL)
			printf("%s: device %s unit %d not configured\n",
			    self->dv_xname, bd->name, bd->unit);
	}
}

/*
 * We do direct configuration of devices on this SoC "bus", so we
 * never call the child device's match function at all (it can be
 * NULL in the struct cfattach).
 */
int
sxi_submatch(struct device *parent, void *child, void *aux)
{
	struct cfdata *cf = child;
	struct sxi_attach_args *sxi = aux;

	if (strcmp(cf->cf_driver->cd_name, sxi->sxi_dev->name) == 0)
		return 1;

	return 0;
}

void
sxi_set_devs(struct sxi_dev *devs)
{
	sunxi_devs = devs;
}

struct sxi_dev *
sxi_find_dev(const char *name, int unit)
{
	struct sxi_dev *sxid;

	if (sunxi_devs == NULL)
		panic("sunxi_find_dev: sunxi_devs == NULL");

	for (sxid = sunxi_devs; sxid->name != NULL; sxid++)
		if (sxid->unit == unit && strcmp(sxid->name, name) == 0)
			return sxid;

	return NULL;
}
@


1.1
log
@rename 'allwinner' to 'sunxi' to actually match the SoC name instead of using
the vendor to follow our naming convention.

ok aalm@@ patrick@@
@
text
@d1 1
a1 1
/* $OpenBSD: sunxi.c,v 1.1 2013/10/22 13:22:18 jasper Exp $ */
d172 1
a172 1
	AWSET4(sc, 4, 5 << 2);
@

