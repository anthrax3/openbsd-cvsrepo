head	1.9;
access;
symbols
	OPENBSD_6_0:1.6.0.4
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.6.0.2
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.4.0.8
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.2
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.4
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.3.0.4
	OPENBSD_5_5_BASE:1.3;
locks; strict;
comment	@ * @;


1.9
date	2017.01.08.14.12.32;	author kettenis;	state Exp;
branches;
next	1.8;
commitid	eZnU2CPm680aLMPL;

1.8
date	2017.01.08.13.25.07;	author kettenis;	state Exp;
branches;
next	1.7;
commitid	OPDzaXGLmCCIwbpN;

1.7
date	2016.08.05.21.29.23;	author kettenis;	state Exp;
branches;
next	1.6;
commitid	Xq7LuNuhuMX8kXoV;

1.6
date	2016.02.01.23.36.57;	author jsg;	state Exp;
branches;
next	1.5;
commitid	fm1sx6wSe0OeGUZ4;

1.5
date	2016.01.31.04.39.05;	author jsg;	state Exp;
branches;
next	1.4;
commitid	EwOiowgzBwq38DmW;

1.4
date	2014.04.25.09.49.33;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2013.11.06.19.03.07;	author syl;	state Exp;
branches;
next	1.2;

1.2
date	2013.10.23.18.01.52;	author jasper;	state Exp;
branches;
next	1.1;

1.1
date	2013.10.23.17.08.48;	author jasper;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Add support for the RTC found on the Allwinner H3.
@
text
@/*	$OpenBSD: sxirtc.c,v 1.8 2017/01/08 13:25:07 kettenis Exp $	*/
/*
 * Copyright (c) 2008 Mark Kettenis
 * Copyright (c) 2013 Artturi Alm
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/systm.h>

#include <dev/clock_subr.h>

#include <machine/bus.h>
#include <machine/fdt.h>

#include <armv7/armv7/armv7var.h>
#include <armv7/sunxi/sunxireg.h>

#include <dev/ofw/openfirm.h>
#include <dev/ofw/fdt.h>

#define	SXIRTC_YYMMDD		0x04
#define	SXIRTC_HHMMSS		0x08
#define	SXIRTC_YYMMDD_A31	0x10
#define	SXIRTC_HHMMSS_A31	0x14

#define LEAPYEAR(y)        \
    (((y) % 4 == 0 &&    \
    (y) % 100 != 0) ||    \
    (y) % 400 == 0) 


extern todr_chip_handle_t todr_handle;

struct sxirtc_softc {
	struct device		sc_dev;
	bus_space_tag_t		sc_iot;
	bus_space_handle_t	sc_ioh;
	bus_size_t		sc_yymmdd;
	bus_size_t		sc_hhmmss;
	uint32_t		base_year;
	uint32_t		year_mask;
	uint32_t		leap_shift;
};

int	sxirtc_match(struct device *, void *, void *);
void	sxirtc_attach(struct device *, struct device *, void *);

struct cfattach sxirtc_ca = {
	sizeof(struct sxirtc_softc), sxirtc_match, sxirtc_attach
};

struct cfdriver sxirtc_cd = {
	NULL, "sxirtc", DV_DULL
};

int	sxirtc_gettime(todr_chip_handle_t, struct timeval *);
int	sxirtc_settime(todr_chip_handle_t, struct timeval *);

int
sxirtc_match(struct device *parent, void *match, void *aux)
{
	struct fdt_attach_args *faa = aux;

	return (OF_is_compatible(faa->fa_node, "allwinner,sun4i-a10-rtc") ||
	    OF_is_compatible(faa->fa_node, "allwinner,sun7i-a20-rtc") ||
	    OF_is_compatible(faa->fa_node, "allwinner,sun6i-a31-rtc"));
}

void
sxirtc_attach(struct device *parent, struct device *self, void *aux)
{
	struct sxirtc_softc *sc = (struct sxirtc_softc *)self;
	struct fdt_attach_args *faa = aux;
	todr_chip_handle_t handle;

	if (faa->fa_nreg < 1)
		return;

	handle = malloc(sizeof(struct todr_chip_handle), M_DEVBUF, M_NOWAIT);
	if (handle == NULL)
		panic("sxirtc_attach: couldn't allocate todr_handle");

	sc->sc_iot = faa->fa_iot;
	if (bus_space_map(sc->sc_iot, faa->fa_reg[0].addr,
	    faa->fa_reg[0].size, 0, &sc->sc_ioh))
		panic("sxirtc_attach: bus_space_map failed!");

	if (OF_is_compatible(faa->fa_node, "allwinner,sun6i-a31-rtc")) {
		sc->sc_yymmdd = SXIRTC_YYMMDD_A31;
		sc->sc_hhmmss = SXIRTC_HHMMSS_A31;
	} else {
		sc->sc_yymmdd = SXIRTC_YYMMDD;
		sc->sc_hhmmss = SXIRTC_HHMMSS;
	}

	if (OF_is_compatible(faa->fa_node, "allwinner,sun7i-a20-rtc")) {
		sc->base_year = 1970;
		sc->year_mask = 0xff;
		sc->leap_shift = 24;
	} else {
		sc->base_year = 2010;
		sc->year_mask = 0x3f;
		sc->leap_shift = 22;
	}

	handle->cookie = self;
	handle->todr_gettime = sxirtc_gettime;
	handle->todr_settime = sxirtc_settime;
	handle->todr_getcal = NULL;
	handle->todr_setcal = NULL;
	handle->bus_cookie = NULL;
	handle->todr_setwen = NULL;
	todr_handle = handle;

	printf("\n");
}

int
sxirtc_gettime(todr_chip_handle_t handle, struct timeval *tv)
{
	struct sxirtc_softc *sc = (struct sxirtc_softc *)handle->cookie;
	struct clock_ymdhms dt;
	uint32_t reg;

	reg = SXIREAD4(sc, sc->sc_hhmmss);
	dt.dt_sec = reg & 0x3f;
	dt.dt_min = reg >> 8 & 0x3f;
	dt.dt_hour = reg >> 16 & 0x1f;
	dt.dt_wday = reg >> 29 & 0x07;

	reg = SXIREAD4(sc, sc->sc_yymmdd);
	dt.dt_day = reg & 0x1f;
	dt.dt_mon = reg >> 8 & 0x0f;
	dt.dt_year = (reg >> 16 & sc->year_mask) + sc->base_year;

	if (dt.dt_sec > 59 || dt.dt_min > 59 ||
	    dt.dt_hour > 23 || dt.dt_wday > 6 ||
	    dt.dt_day > 31 || dt.dt_day == 0 ||
	    dt.dt_mon > 12 || dt.dt_mon == 0)
		return 1;

	tv->tv_sec = clock_ymdhms_to_secs(&dt);
	tv->tv_usec = 0;
	return 0;
}

int
sxirtc_settime(todr_chip_handle_t handle, struct timeval *tv)
{
	struct sxirtc_softc *sc = (struct sxirtc_softc *)handle->cookie;
	struct clock_ymdhms dt;

	clock_secs_to_ymdhms(tv->tv_sec, &dt);

	if (dt.dt_sec > 59 || dt.dt_min > 59 ||
	    dt.dt_hour > 23 || dt.dt_wday > 6 ||
	    dt.dt_day > 31 || dt.dt_day == 0 ||
	    dt.dt_mon > 12 || dt.dt_mon == 0)
		return 1;

	SXICMS4(sc, sc->sc_hhmmss, 0xe0000000 | 0x1f0000 | 0x3f00 | 0x3f,
	    dt.dt_sec | (dt.dt_min << 8) | (dt.dt_hour << 16) |
	    (dt.dt_wday << 29));

	SXICMS4(sc, sc->sc_yymmdd, 0x00400000 | (sc->year_mask << 16) |
	    0x0f00 | 0x1f, dt.dt_day | (dt.dt_mon << 8) |
	    ((dt.dt_year - sc->base_year) << 16) |
	    (LEAPYEAR(dt.dt_year) << sc->leap_shift));

	return 0;
}
@


1.8
log
@Specify correct size for the softc.
@
text
@d1 1
a1 1
/*	$OpenBSD: sxirtc.c,v 1.7 2016/08/05 21:29:23 kettenis Exp $	*/
d35 4
a38 2
#define	SXIRTC_YYMMDD	0x04
#define	SXIRTC_HHMMSS	0x08
d52 2
d79 2
a80 1
	    OF_is_compatible(faa->fa_node, "allwinner,sun7i-a20-rtc"));
d102 8
d139 1
a139 1
	reg = SXIREAD4(sc, SXIRTC_HHMMSS);
d145 1
a145 1
	reg = SXIREAD4(sc, SXIRTC_YYMMDD);
d175 1
a175 1
	SXICMS4(sc, SXIRTC_HHMMSS, 0xe0000000 | 0x1f0000 | 0x3f00 | 0x3f,
d179 1
a179 1
	SXICMS4(sc, SXIRTC_YYMMDD, 0x00400000 | (sc->year_mask << 16) |
@


1.7
log
@Dynamically attach sxirtc(4); another board_id check bites the dust.
@
text
@d1 1
a1 1
/*	$OpenBSD: sxirtc.c,v 1.6 2016/02/01 23:36:57 jsg Exp $	*/
d59 1
a59 1
	sizeof(struct device), sxirtc_match, sxirtc_attach
@


1.6
log
@Add A20 support to sxirtc.
From Artturi Alm.
@
text
@d1 1
a1 1
/*	$OpenBSD: sxirtc.c,v 1.5 2016/01/31 04:39:05 jsg Exp $	*/
d27 1
d32 3
d55 1
d59 1
a59 1
	sizeof(struct device), NULL, sxirtc_attach
d69 9
d79 1
a79 1
sxirtc_attach(struct device *parent, struct device *self, void *args)
d82 1
a82 1
	struct armv7_attach_args *aa = args;
d85 3
d92 3
a94 3
	sc->sc_iot = aa->aa_iot;
	if (bus_space_map(sc->sc_iot, aa->aa_dev->mem[0].addr,
	    aa->aa_dev->mem[0].size, 0, &sc->sc_ioh))
d97 1
a97 1
	if (board_id == BOARD_ID_SUN7I_A20) {
@


1.5
log
@Don't use sxitimer on Allwinner sun7i/A20.

sxitimer isn't generating hardclock ticks on Allwinner A20.  Fortunately
the Cortex A7 based Allwinner A20 has the ARM Generic Timer (agtimer)
available so use that.

To allow this to work sxirtc gets it's own mapping instead of using a
subregion of sxitimer.

From Patrick Wildt.
@
text
@d1 1
a1 1
/*	$OpenBSD: sxirtc.c,v 1.4 2014/04/25 09:49:33 jsg Exp $	*/
a17 3
/* XXX this doesn't support A20 yet. */
	/* year & 0xff on A20, 0x3f on A10 */
	/* leap << 24 on A20, << 22 on A10 */
a39 3
/* XXX other way around than bus_space_subregion? */
extern bus_space_handle_t sxitimer_ioh;

d46 3
d78 11
a88 1
		panic("sxirtc_attach: bus_space_subregion failed!");
d118 1
a118 1
	dt.dt_year = (reg >> 16 & 0x3f) + 2010; /* 0xff on A20 */
d149 4
a152 3
	SXICMS4(sc, SXIRTC_YYMMDD, 0x00400000 | 0x003f0000 | 0x0f00 | 0x1f,
	   dt.dt_day | (dt.dt_mon << 8) | ((dt.dt_year - 2010) << 16) |
	   (LEAPYEAR(dt.dt_year) << 22));
@


1.4
log
@test dt_min for invalid minute values instead of testing dt_sec twice
ok bmercer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sxirtc.c,v 1.3 2013/11/06 19:03:07 syl Exp $	*/
d34 2
a35 2
#define	SXIRTC_YYMMDD	0x00
#define	SXIRTC_HHMMSS	0x04
d79 2
a80 2
	if (bus_space_subregion(sc->sc_iot, sxitimer_ioh,
	    aa->aa_dev->mem[0].addr, aa->aa_dev->mem[0].size, &sc->sc_ioh))
@


1.3
log
@After factorizing armv7_machdep code here is an effort to factorize all
the code present in omap/omap.c imx/imx.c and sunxi/sunxi.c

All this code looks quite the same, so we move it in a generic armv7/armv7.c

This is a step closer to only one kernel for all armv7 boards.

ok patrick@@, rapha@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sxirtc.c,v 1.2 2013/10/23 18:01:52 jasper Exp $	*/
d113 1
a113 1
	if (dt.dt_sec > 59 || dt.dt_sec > 59 ||
d132 1
a132 1
	if (dt.dt_sec > 59 || dt.dt_sec > 59 ||
@


1.2
log
@rename some defines as well
@
text
@d1 1
a1 1
/*	$OpenBSD: sxirtc.c,v 1.1 2013/10/23 17:08:48 jasper Exp $	*/
d31 2
a32 1
#include <armv7/sunxi/sunxivar.h>
d71 1
a71 1
	struct sxi_attach_args *sxi = args;
d78 1
a78 1
	sc->sc_iot = sxi->sxi_iot;
d80 1
a80 1
	    sxi->sxi_dev->mem[0].addr, sxi->sxi_dev->mem[0].size, &sc->sc_ioh))
@


1.1
log
@rename 'allwinner' to 'sunxi' to actually match the SoC name instead of using
the vendor to follow our naming convention.

ok aalm@@ patrick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sxirtc.c,v 1.1 2013/10/22 13:22:19 jasper Exp $	*/
d33 2
a34 2
#define	AWRTC_YYMMDD	0x00
#define	AWRTC_HHMMSS	0x04
d101 1
a101 1
	reg = AWREAD4(sc, AWRTC_HHMMSS);
d107 1
a107 1
	reg = AWREAD4(sc, AWRTC_YYMMDD);
d137 1
a137 1
	AWCMS4(sc, AWRTC_HHMMSS, 0xe0000000 | 0x1f0000 | 0x3f00 | 0x3f,
d141 1
a141 1
	AWCMS4(sc, AWRTC_YYMMDD, 0x00400000 | 0x003f0000 | 0x0f00 | 0x1f,
@

