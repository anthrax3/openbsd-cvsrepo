head	1.25;
access;
symbols
	OPENBSD_6_2_BASE:1.25
	OPENBSD_6_1:1.25.0.4
	OPENBSD_6_1_BASE:1.25
	OPENBSD_6_0:1.16.0.2
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.13.0.2
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.9.0.4
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.5.0.6
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.4
	OPENBSD_5_5_BASE:1.5;
locks; strict;
comment	@ * @;


1.25
date	2017.01.22.10.17.37;	author dlg;	state Exp;
branches;
next	1.24;
commitid	VyLWTsbepAOk7VQM;

1.24
date	2017.01.21.08.26.49;	author patrick;	state Exp;
branches;
next	1.23;
commitid	dvP7gLmLqGu2JY3W;

1.23
date	2016.10.22.11.00.02;	author jsg;	state Exp;
branches;
next	1.22;
commitid	9CuMylwr8Whz5fr3;

1.22
date	2016.09.11.21.44.30;	author kettenis;	state Exp;
branches;
next	1.21;
commitid	NMpsKfhXzYlj3oH8;

1.21
date	2016.08.22.19.38.42;	author kettenis;	state Exp;
branches;
next	1.20;
commitid	AWEuLmWaMD4V4bOJ;

1.20
date	2016.08.15.09.20.47;	author kettenis;	state Exp;
branches;
next	1.19;
commitid	1mI3TWwpa7QhLscb;

1.19
date	2016.08.05.22.19.23;	author kettenis;	state Exp;
branches;
next	1.18;
commitid	pRTf0EwiQCIso5lt;

1.18
date	2016.08.05.19.00.25;	author kettenis;	state Exp;
branches;
next	1.17;
commitid	PWnrMbYWs67oDQuR;

1.17
date	2016.07.27.11.45.02;	author patrick;	state Exp;
branches;
next	1.16;
commitid	yc14meyJgxIAcvAg;

1.16
date	2016.06.12.06.58.39;	author jsg;	state Exp;
branches;
next	1.15;
commitid	oSJVVPiG4YJSxzwY;

1.15
date	2016.06.11.06.42.16;	author jsg;	state Exp;
branches;
next	1.14;
commitid	P3TWFuwvfad353N2;

1.14
date	2016.04.13.11.34.00;	author mpi;	state Exp;
branches;
next	1.13;
commitid	RI1iBTF6Zaycxppg;

1.13
date	2015.11.25.03.09.58;	author dlg;	state Exp;
branches;
next	1.12;
commitid	B0kwmVGiD5DVx4kv;

1.12
date	2015.11.24.17.11.38;	author mpi;	state Exp;
branches;
next	1.11;
commitid	5gdEnqVoJuTuwdTu;

1.11
date	2015.11.20.03.35.22;	author dlg;	state Exp;
branches;
next	1.10;
commitid	eYnPulzvLjDImPCa;

1.10
date	2015.10.27.15.07.56;	author mpi;	state Exp;
branches;
next	1.9;
commitid	ZjlKfjAUbdx7mqMd;

1.9
date	2015.06.24.09.40.53;	author mpi;	state Exp;
branches;
next	1.8;
commitid	MVWrtktB46JRxFWT;

1.8
date	2015.04.03.06.48.58;	author mpi;	state Exp;
branches;
next	1.7;
commitid	bDbDwAwh1hMPl5Dh;

1.7
date	2014.12.22.02.26.53;	author tedu;	state Exp;
branches;
next	1.6;
commitid	2Ez9mHW0jDzojG4V;

1.6
date	2014.08.21.14.24.08;	author mpi;	state Exp;
branches;
next	1.5;
commitid	5eFitDmQJIvEdtoI;

1.5
date	2013.11.06.19.03.07;	author syl;	state Exp;
branches;
next	1.4;

1.4
date	2013.10.26.20.20.22;	author jasper;	state Exp;
branches;
next	1.3;

1.3
date	2013.10.24.08.28.11;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2013.10.23.18.01.52;	author jasper;	state Exp;
branches;
next	1.1;

1.1
date	2013.10.23.17.08.48;	author jasper;	state Exp;
branches;
next	;


desc
@@


1.25
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@/*	$OpenBSD: sxie.c,v 1.24 2017/01/21 08:26:49 patrick Exp $	*/
/*
 * Copyright (c) 2012-2013 Patrick Wildt <patrick@@blueri.se>
 * Copyright (c) 2013 Artturi Alm
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/* TODO this should use dedicated dma for RX, atleast */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/sockio.h>
#include <sys/queue.h>
#include <sys/malloc.h>
#include <sys/device.h>
#include <sys/evcount.h>
#include <sys/socket.h>
#include <sys/timeout.h>
#include <sys/mbuf.h>
#include <machine/intr.h>
#include <machine/bus.h>
#include <machine/fdt.h>

#include "bpfilter.h"

#include <net/if.h>
#include <net/if_media.h>
#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <dev/mii/mii.h>
#include <dev/mii/miivar.h>

#include <dev/fdt/sunxireg.h>

#include <dev/ofw/openfirm.h>
#include <dev/ofw/ofw_clock.h>
#include <dev/ofw/ofw_pinctrl.h>
#include <dev/ofw/fdt.h>

/* configuration registers */
#define	SXIE_CR			0x0000
#define	SXIE_TXMODE		0x0004
#define	SXIE_TXFLOW		0x0008
#define	SXIE_TXCR0		0x000c
#define	SXIE_TXCR1		0x0010
#define	SXIE_TXINS		0x0014
#define	SXIE_TXPKTLEN0		0x0018
#define	SXIE_TXPKTLEN1		0x001c
#define	SXIE_TXSR		0x0020
#define	SXIE_TXIO0		0x0024
#define	SXIE_TXIO1		0x0028
#define	SXIE_TXTSVL0		0x002c
#define	SXIE_TXTSVH0		0x0030
#define	SXIE_TXTSVL1		0x0034
#define	SXIE_TXTSVH1		0x0038
#define	SXIE_RXCR		0x003c
#define	SXIE_RXHASH0		0x0040
#define	SXIE_RXHASH1		0x0044
#define	SXIE_RXSR		0x0048
#define	SXIE_RXIO		0x004C
#define	SXIE_RXFBC		0x0050
#define	SXIE_INTCR		0x0054
#define	SXIE_INTSR		0x0058
#define	SXIE_MACCR0		0x005C
#define	SXIE_MACCR1		0x0060
#define	SXIE_MACIPGT		0x0064
#define	SXIE_MACIPGR		0x0068
#define	SXIE_MACCLRT		0x006C
#define	SXIE_MACMFL		0x0070
#define	SXIE_MACSUPP		0x0074
#define	SXIE_MACTEST		0x0078
#define	SXIE_MACMCFG		0x007C
#define	SXIE_MACMCMD		0x0080
#define	SXIE_MACMADR		0x0084
#define	SXIE_MACMWTD		0x0088
#define	SXIE_MACMRDD		0x008C
#define	SXIE_MACMIND		0x0090
#define	SXIE_MACSSRR		0x0094
#define	SXIE_MACA0		0x0098
#define	SXIE_MACA1		0x009c
#define	SXIE_MACA2		0x00a0

/* i once spent hours on pretty defines, cvs up ate 'em. these shall do */
#define SXIE_INTR_ENABLE		0x010f
#define SXIE_INTR_DISABLE	0x0000
#define SXIE_INTR_CLEAR		0x0000

#define SXIE_TX_FIFO0		0x0001
#define SXIE_TX_FIFO1		0x0002

#define	SXIE_RX_ENABLE		0x0004
#define	SXIE_TX_ENABLE		0x0003
#define	SXIE_RXTX_ENABLE		0x0007

#define	SXIE_RXDRQM		0x0002
#define	SXIE_RXTM		0x0004
#define	SXIE_RXFLUSH		0x0008
#define	SXIE_RXPA		0x0010
#define	SXIE_RXPCF		0x0020
#define	SXIE_RXPCRCE		0x0040
#define	SXIE_RXPLE		0x0080
#define	SXIE_RXPOR		0x0100
#define	SXIE_RXUCAD		0x10000
#define	SXIE_RXDAF		0x20000
#define	SXIE_RXMCO		0x100000
#define	SXIE_RXMHF		0x200000
#define	SXIE_RXBCO		0x400000
#define	SXIE_RXSAF		0x1000000
#define	SXIE_RXSAIF		0x2000000

#define	SXIE_MACRXFC		0x0004
#define	SXIE_MACTXFC		0x0008
#define SXIE_MACSOFTRESET	0x8000

#define	SXIE_MACDUPLEX		0x0001	/* full = 1 */
#define	SXIE_MACFLC		0x0002
#define	SXIE_MACHF		0x0004
#define	SXIE_MACDCRC		0x0008
#define	SXIE_MACCRC		0x0010
#define	SXIE_MACPC		0x0020
#define	SXIE_MACVC		0x0040
#define	SXIE_MACADP		0x0080
#define	SXIE_MACPRE		0x0100
#define	SXIE_MACLPE		0x0200
#define	SXIE_MACNB		0x1000
#define	SXIE_MACBNB		0x2000
#define	SXIE_MACED		0x4000

#define	SXIE_RX_ERRLENOOR	0x0040
#define	SXIE_RX_ERRLENCHK	0x0020
#define	SXIE_RX_ERRCRC		0x0010
#define	SXIE_RX_ERRRCV		0x0008 /* XXX receive code violation ? */
#define	SXIE_RX_ERRMASK		0x0070

#define	SXIE_MII_TIMEOUT	100
#define SXIE_MAX_RXD		8
#define SXIE_MAX_PKT_SIZE	ETHER_MAX_DIX_LEN

#define SXIE_ROUNDUP(size, unit) (((size) + (unit) - 1) & ~((unit) - 1))

struct sxie_softc {
	struct device			sc_dev;
	struct arpcom			sc_ac;
	struct mii_data			sc_mii;
	int				sc_phyno;
	bus_space_tag_t			sc_iot;
	bus_space_handle_t		sc_ioh;
	bus_space_handle_t		sc_sid_ioh;
	void				*sc_ih; /* Interrupt handler */
	uint32_t			intr_status; /* soft interrupt status */
	uint32_t			pauseframe;
	uint32_t			txf_inuse;
};

struct sxie_softc *sxie_sc;

int	sxie_match(struct device *, void *, void *);
void	sxie_attach(struct device *, struct device *, void *);
void	sxie_setup_interface(struct sxie_softc *, struct device *);
void	sxie_socware_init(struct sxie_softc *);
int	sxie_ioctl(struct ifnet *, u_long, caddr_t);
void	sxie_start(struct ifnet *);
void	sxie_watchdog(struct ifnet *);
void	sxie_init(struct sxie_softc *);
void	sxie_stop(struct sxie_softc *);
void	sxie_reset(struct sxie_softc *);
void	sxie_iff(struct sxie_softc *, struct ifnet *);
int	sxie_intr(void *);
void	sxie_recv(struct sxie_softc *);
int	sxie_miibus_readreg(struct device *, int, int);
void	sxie_miibus_writereg(struct device *, int, int, int);
void	sxie_miibus_statchg(struct device *);
int	sxie_ifm_change(struct ifnet *);
void	sxie_ifm_status(struct ifnet *, struct ifmediareq *);

struct cfattach sxie_ca = {
	sizeof (struct sxie_softc), sxie_match, sxie_attach
};

struct cfdriver sxie_cd = {
	NULL, "sxie", DV_IFNET
};

int
sxie_match(struct device *parent, void *match, void *aux)
{
	struct fdt_attach_args *faa = aux;

	return OF_is_compatible(faa->fa_node, "allwinner,sun4i-a10-emac");
}

void
sxie_attach(struct device *parent, struct device *self, void *aux)
{
	struct sxie_softc *sc = (struct sxie_softc *) self;
	struct fdt_attach_args *faa = aux;
	struct mii_data *mii;
	struct ifnet *ifp;
	int s;

	if (faa->fa_nreg < 1)
		return;

	pinctrl_byname(faa->fa_node, "default");

	sc->sc_iot = faa->fa_iot;

	if (bus_space_map(sc->sc_iot, faa->fa_reg[0].addr,
	    faa->fa_reg[0].size, 0, &sc->sc_ioh))
		panic("sxie_attach: bus_space_map ioh failed!");

	if (bus_space_map(sc->sc_iot, SID_ADDR, SID_SIZE, 0, &sc->sc_sid_ioh))
		panic("sxie_attach: bus_space_map sid_ioh failed!");

	clock_enable_all(faa->fa_node);

	sxie_socware_init(sc);
	sc->txf_inuse = 0;

	sc->sc_ih = arm_intr_establish_fdt(faa->fa_node, IPL_NET,
	    sxie_intr, sc, sc->sc_dev.dv_xname);

	s = splnet();

	printf(", address %s\n", ether_sprintf(sc->sc_ac.ac_enaddr));

	/* XXX verify flags & capabilities */
	ifp = &sc->sc_ac.ac_if;
	ifp->if_softc = sc;
	strlcpy(ifp->if_xname, sc->sc_dev.dv_xname, IFNAMSIZ);
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ifp->if_ioctl = sxie_ioctl;
	ifp->if_start = sxie_start;
	ifp->if_watchdog = sxie_watchdog;
	ifp->if_capabilities = IFCAP_VLAN_MTU; /* XXX status check in recv? */

	IFQ_SET_MAXLEN(&ifp->if_snd, 1);

	/* Initialize MII/media info. */
	mii = &sc->sc_mii;
	mii->mii_ifp = ifp;
	mii->mii_readreg = sxie_miibus_readreg;
	mii->mii_writereg = sxie_miibus_writereg;
	mii->mii_statchg = sxie_miibus_statchg;

	ifmedia_init(&mii->mii_media, 0, sxie_ifm_change, sxie_ifm_status);
	mii_attach(self, mii, 0xffffffff, MII_PHY_ANY, MII_OFFSET_ANY, 0);

	if (LIST_FIRST(&mii->mii_phys) == NULL) {
		ifmedia_add(&mii->mii_media, IFM_ETHER | IFM_NONE, 0, NULL);
		ifmedia_set(&mii->mii_media, IFM_ETHER | IFM_NONE);
	} else
		ifmedia_set(&mii->mii_media, IFM_ETHER | IFM_AUTO);

	if_attach(ifp);
	ether_ifattach(ifp);
	splx(s);

	sxie_sc = sc;
}

void
sxie_socware_init(struct sxie_softc *sc)
{
	int have_mac = 0;
	uint32_t reg;

	/* MII clock cfg */
	SXICMS4(sc, SXIE_MACMCFG, 15 << 2, 13 << 2);

	SXIWRITE4(sc, SXIE_INTCR, SXIE_INTR_DISABLE);
	SXISET4(sc, SXIE_INTSR, SXIE_INTR_CLEAR);

	/*
	 * If u-boot doesn't set emac, use the Security ID area
	 * to generate a consistent MAC address of.
	 */
	reg = SXIREAD4(sc, SXIE_MACA0);
	if (reg != 0) {
		sc->sc_ac.ac_enaddr[3] = reg >> 16 & 0xff;
		sc->sc_ac.ac_enaddr[4] = reg >> 8 & 0xff;
		sc->sc_ac.ac_enaddr[5] = reg & 0xff;
		reg = SXIREAD4(sc, SXIE_MACA1);
		sc->sc_ac.ac_enaddr[0] = reg >> 16 & 0xff;
		sc->sc_ac.ac_enaddr[1] = reg >> 8 & 0xff;
		sc->sc_ac.ac_enaddr[2] = reg & 0xff;

		have_mac = 1;
	}

	reg = bus_space_read_4(sc->sc_iot, sc->sc_sid_ioh, 0x0);

	if (!have_mac && reg != 0) {
		sc->sc_ac.ac_enaddr[0] = 0x02;
		sc->sc_ac.ac_enaddr[1] = reg & 0xff;
		reg = bus_space_read_4(sc->sc_iot, sc->sc_sid_ioh, 0x0c);
		sc->sc_ac.ac_enaddr[2] = reg >> 24 & 0xff;
		sc->sc_ac.ac_enaddr[3] = reg >> 16 & 0xff;
		sc->sc_ac.ac_enaddr[4] = reg >> 8 & 0xff;
		sc->sc_ac.ac_enaddr[5] = reg & 0xff;

		have_mac = 1;
	}

	if (!have_mac)
		ether_fakeaddr(&sc->sc_ac.ac_if);

	sc->sc_phyno = 1;
}

void
sxie_setup_interface(struct sxie_softc *sc, struct device *dev)
{
	uint32_t clr_m, set_m;

	/* configure TX */
	SXICMS4(sc, SXIE_TXMODE, 3, 1);	/* cpu mode */

	/* configure RX */
	clr_m = SXIE_RXDRQM | SXIE_RXTM | SXIE_RXPA | SXIE_RXPCF |
	    SXIE_RXPCRCE | SXIE_RXPLE | SXIE_RXMHF | SXIE_RXSAF |
	    SXIE_RXSAIF;
	set_m = SXIE_RXPOR | SXIE_RXUCAD | SXIE_RXDAF | SXIE_RXBCO;
	SXICMS4(sc, SXIE_RXCR, clr_m, set_m);

	/* configure MAC */
	SXISET4(sc, SXIE_MACCR0, SXIE_MACTXFC | SXIE_MACRXFC);
	clr_m =	SXIE_MACHF | SXIE_MACDCRC | SXIE_MACVC | SXIE_MACADP |
	    SXIE_MACPRE | SXIE_MACLPE | SXIE_MACNB | SXIE_MACBNB |
	    SXIE_MACED;
	set_m = SXIE_MACFLC | SXIE_MACCRC | SXIE_MACPC;
	set_m |= sxie_miibus_readreg(dev, sc->sc_phyno, 0) >> 8 & 1;
	SXICMS4(sc, SXIE_MACCR1, clr_m, set_m);

	/* XXX */
	SXIWRITE4(sc, SXIE_MACIPGT, 0x0015);
	SXIWRITE4(sc, SXIE_MACIPGR, 0x0c12);

	/* XXX set collision window */
	SXIWRITE4(sc, SXIE_MACCLRT, 0x370f);

	/* set max frame length */
	SXIWRITE4(sc, SXIE_MACMFL, SXIE_MAX_PKT_SIZE);

	/* set lladdr */
	SXIWRITE4(sc, SXIE_MACA0,
	    sc->sc_ac.ac_enaddr[3] << 16 |
	    sc->sc_ac.ac_enaddr[4] << 8 |
	    sc->sc_ac.ac_enaddr[5]);
	SXIWRITE4(sc, SXIE_MACA1,
	    sc->sc_ac.ac_enaddr[0] << 16 |
	    sc->sc_ac.ac_enaddr[1] << 8 |
	    sc->sc_ac.ac_enaddr[2]);

	sxie_reset(sc);
	/* XXX possibly missing delay in here. */
}

void
sxie_init(struct sxie_softc *sc)
{
	struct ifnet *ifp = &sc->sc_ac.ac_if;
	struct device *dev = (struct device *)sc;
	int phyreg;
	
	sxie_reset(sc);

	SXIWRITE4(sc, SXIE_INTCR, SXIE_INTR_DISABLE);

	SXISET4(sc, SXIE_INTSR, SXIE_INTR_CLEAR);

	SXISET4(sc, SXIE_RXCR, SXIE_RXFLUSH);

	/* soft reset */
	SXICLR4(sc, SXIE_MACCR0, SXIE_MACSOFTRESET);

	/* zero rx counter */
	SXIWRITE4(sc, SXIE_RXFBC, 0);

	sxie_setup_interface(sc, dev);

	/* power up PHY */
	sxie_miibus_writereg(dev, sc->sc_phyno, 0,
	    sxie_miibus_readreg(dev, sc->sc_phyno, 0) & ~(1 << 11));
	delay(1000);
	phyreg = sxie_miibus_readreg(dev, sc->sc_phyno, 0);

	/* set duplex */
	SXICMS4(sc, SXIE_MACCR1, 1, phyreg >> 8 & 1);

	/* set speed */
	SXICMS4(sc, SXIE_MACSUPP, 1 << 8, (phyreg >> 13 & 1) << 8);

	SXISET4(sc, SXIE_CR, SXIE_RXTX_ENABLE);

	/* Indicate we are up and running. */
	ifp->if_flags |= IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	SXISET4(sc, SXIE_INTCR, SXIE_INTR_ENABLE);

	sxie_start(ifp);
}

int
sxie_intr(void *arg)
{
	struct sxie_softc *sc = arg;
	struct ifnet *ifp = &sc->sc_ac.ac_if;
	uint32_t pending;

	SXIWRITE4(sc, SXIE_INTCR, SXIE_INTR_DISABLE);

	pending = SXIREAD4(sc, SXIE_INTSR);
	SXIWRITE4(sc, SXIE_INTSR, pending);

	/*
	 * Handle incoming packets.
	 */
	if (pending & 0x0100) {
		if (ifp->if_flags & IFF_RUNNING)
			sxie_recv(sc);
	}

	if (pending & (SXIE_TX_FIFO0 | SXIE_TX_FIFO1)) {
		ifq_clr_oactive(&ifp->if_snd);
		sc->txf_inuse &= ~pending;
		if (sc->txf_inuse == 0)
			ifp->if_timer = 0;
		else
			ifp->if_timer = 5;
	}

	if (ifp->if_flags & IFF_RUNNING && !IFQ_IS_EMPTY(&ifp->if_snd))
		sxie_start(ifp);

	SXISET4(sc, SXIE_INTCR, SXIE_INTR_ENABLE);

	return 1;
}

/*
 * XXX there's secondary tx fifo to be used.
 */
void
sxie_start(struct ifnet *ifp)
{
	struct sxie_softc *sc = ifp->if_softc;
	struct mbuf *m;
	struct mbuf *head;
	uint8_t *td;
	uint32_t fifo;
	uint32_t txbuf[SXIE_MAX_PKT_SIZE / sizeof(uint32_t)]; /* XXX !!! */

	if (sc->txf_inuse == (SXIE_TX_FIFO0 | SXIE_TX_FIFO1))
		ifq_set_oactive(&ifp->if_snd);

	if (!(ifp->if_flags & IFF_RUNNING) || ifq_is_oactive(&ifp->if_snd))
		return;

	td = (uint8_t *)&txbuf[0];
	m = NULL;
	head = NULL;
trynext:
	m = ifq_deq_begin(&ifp->if_snd);
	if (m == NULL)
		return;

	if (m->m_pkthdr.len > SXIE_MAX_PKT_SIZE) {
		ifq_deq_commit(&ifp->if_snd, m);
		printf("sxie_start: packet too big\n");
		m_freem(m);
		return;
	}

	if (sc->txf_inuse == (SXIE_TX_FIFO0 | SXIE_TX_FIFO1)) {
		ifq_deq_rollback(&ifp->if_snd, m);
		printf("sxie_start: tx fifos in use.\n");
		ifq_set_oactive(&ifp->if_snd);
		return;
	}

	/* select fifo */
	if (sc->txf_inuse & SXIE_TX_FIFO0) {
		sc->txf_inuse |= SXIE_TX_FIFO1;
		fifo = 1;
	} else {
		sc->txf_inuse |= SXIE_TX_FIFO0;
		fifo = 0;
	}
	SXIWRITE4(sc, SXIE_TXINS, fifo);

	/* set packet length */
	SXIWRITE4(sc, SXIE_TXPKTLEN0 + (fifo * 4), m->m_pkthdr.len);

	/* copy the actual packet to fifo XXX through 'align buffer'.. */
	m_copydata(m, 0, m->m_pkthdr.len, (caddr_t)td);
	bus_space_write_multi_4(sc->sc_iot, sc->sc_ioh,
	    SXIE_TXIO0 + (fifo * 4),
	    (uint32_t *)td, SXIE_ROUNDUP(m->m_pkthdr.len, 4) >> 2);

	/* transmit to PHY from fifo */
	SXISET4(sc, SXIE_TXCR0 + (fifo * 4), 1);
	ifp->if_timer = 5;
	ifq_deq_commit(&ifp->if_snd, m);

#if NBPFILTER > 0
	if (ifp->if_bpf)
		bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_OUT);
#endif
	m_freem(m);

	goto trynext;
}

void
sxie_stop(struct sxie_softc *sc)
{
	struct ifnet *ifp = &sc->sc_ac.ac_if;

	sxie_reset(sc);

	ifp->if_flags &= ~IFF_RUNNING;
	ifp->if_timer = 0;
	ifq_clr_oactive(&ifp->if_snd);
}

void
sxie_reset(struct sxie_softc *sc)
{
	/* reset the controller */
	SXIWRITE4(sc, SXIE_CR, 0);
	delay(200);
	SXIWRITE4(sc, SXIE_CR, 1);
	delay(200);
}

void
sxie_watchdog(struct ifnet *ifp)
{
	struct sxie_softc *sc = ifp->if_softc;
	if (sc->pauseframe) {
		ifp->if_timer = 5;
		return;
	}
	printf("%s: watchdog tx timeout\n", sc->sc_dev.dv_xname);
	ifp->if_oerrors++;
	sxie_init(sc);
	sxie_start(ifp);
}

/*
 * XXX DMA?
 */
void
sxie_recv(struct sxie_softc *sc)
{
	struct ifnet *ifp = &sc->sc_ac.ac_if;
	uint32_t fbc, reg;
	struct mbuf_list ml = MBUF_LIST_INITIALIZER();
	struct mbuf *m;
	uint16_t pktstat;
	int16_t pktlen;
	int rlen;
	char rxbuf[SXIE_MAX_PKT_SIZE]; /* XXX !!! */
trynext:
	fbc = SXIREAD4(sc, SXIE_RXFBC);
	if (!fbc)
		goto done;

	/*
	 * first bit of MSB is packet valid flag,
	 * it is 'padded' with 0x43414d = "MAC"
	 */
	reg = SXIREAD4(sc, SXIE_RXIO);
	if (reg != 0x0143414d) {	/* invalid packet */
		/* disable, flush, enable */
		SXICLR4(sc, SXIE_CR, SXIE_RX_ENABLE);
		SXISET4(sc, SXIE_RXCR, SXIE_RXFLUSH);
		while (SXIREAD4(sc, SXIE_RXCR) & SXIE_RXFLUSH);
		SXISET4(sc, SXIE_CR, SXIE_RX_ENABLE);

		goto err_out;
	}
	
	reg = SXIREAD4(sc, SXIE_RXIO);
	pktstat = (uint16_t)reg >> 16;
	pktlen = (int16_t)reg; /* length of useful data */

	if (pktstat & SXIE_RX_ERRMASK || pktlen < ETHER_MIN_LEN) {
		ifp->if_ierrors++;
		goto trynext;
	}
	if (pktlen > SXIE_MAX_PKT_SIZE)
		pktlen = SXIE_MAX_PKT_SIZE; /* XXX is truncating ok? */

	/* read the actual packet from fifo XXX through 'align buffer'.. */
	if (pktlen & 3)
		rlen = SXIE_ROUNDUP(pktlen, 4);
	else
		rlen = pktlen;
	bus_space_read_multi_4(sc->sc_iot, sc->sc_ioh,
	    SXIE_RXIO, (uint32_t *)&rxbuf[0], rlen >> 2);

	m = m_devget(&rxbuf[0], pktlen, ETHER_ALIGN);
	if (m == NULL) {
		ifp->if_ierrors++;
		goto err_out;
	}

	ml_enqueue(&ml, m);
	goto trynext;
err_out:
	ifp->if_ierrors++;
done:
	if_input(ifp, &ml);
}

int
sxie_ioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
{
	struct sxie_softc *sc = ifp->if_softc;
	struct ifreq *ifr = (struct ifreq *)data;
	int s, error = 0;

	s = splnet();

	switch (cmd) {
	case SIOCSIFADDR:
		if (!(ifp->if_flags & IFF_UP)) {
			ifp->if_flags |= IFF_UP;
			sxie_init(sc);
		}
		break;
	case SIOCSIFFLAGS:
		if (ifp->if_flags & IFF_UP) {
			if (ifp->if_flags & IFF_RUNNING)
				error = ENETRESET;
			else
				sxie_init(sc);
		} else if (ifp->if_flags & IFF_RUNNING)
			sxie_stop(sc);
		break;
	case SIOCGIFMEDIA:
	case SIOCSIFMEDIA:
		error = ifmedia_ioctl(ifp, ifr, &sc->sc_mii.mii_media, cmd);
		break;
	default:
		error = ether_ioctl(ifp, &sc->sc_ac, cmd, data);
	}
	if (error == ENETRESET) {
		if (ifp->if_flags & IFF_RUNNING)
			sxie_iff(sc, ifp);
		error = 0;
	}

	splx(s);
	return error;
}

void
sxie_iff(struct sxie_softc *sc, struct ifnet *ifp)
{
	/* XXX set interface features */
}

/*
 * MII
 */
int
sxie_miibus_readreg(struct device *dev, int phy, int reg)
{
	struct sxie_softc *sc = (struct sxie_softc *)dev;
	int timo = SXIE_MII_TIMEOUT;

	SXIWRITE4(sc, SXIE_MACMADR, phy << 8 | reg);

	SXIWRITE4(sc, SXIE_MACMCMD, 1);
	while (SXIREAD4(sc, SXIE_MACMIND) & 1 && --timo)
		delay(10);
#ifdef DIAGNOSTIC
	if (!timo)
		printf("%s: sxie_miibus_readreg timeout.\n",
		    sc->sc_dev.dv_xname);
#endif

	SXIWRITE4(sc, SXIE_MACMCMD, 0);
	
	return SXIREAD4(sc, SXIE_MACMRDD) & 0xffff;
}

void
sxie_miibus_writereg(struct device *dev, int phy, int reg, int val)
{
	struct sxie_softc *sc = (struct sxie_softc *)dev;
	int timo = SXIE_MII_TIMEOUT;

	SXIWRITE4(sc, SXIE_MACMADR, phy << 8 | reg);

	SXIWRITE4(sc, SXIE_MACMCMD, 1);
	while (SXIREAD4(sc, SXIE_MACMIND) & 1 && --timo)
		delay(10);
#ifdef DIAGNOSTIC
	if (!timo)
		printf("%s: sxie_miibus_readreg timeout.\n",
		    sc->sc_dev.dv_xname);
#endif

	SXIWRITE4(sc, SXIE_MACMCMD, 0);

	SXIWRITE4(sc, SXIE_MACMWTD, val);
}

void
sxie_miibus_statchg(struct device *dev)
{
	/* XXX */
#if 0
	struct sxie_softc *sc = (struct sxie_softc *)dev;

	switch (IFM_SUBTYPE(sc->sc_mii.mii_media_active)) {
	case IFM_10_T:
	case IFM_100_TX:
	/*case IFM_1000_T: only on GMAC */
		break;
	default:
		break;
	}
#endif
}

int
sxie_ifm_change(struct ifnet *ifp)
{
	struct sxie_softc *sc = ifp->if_softc;
	struct mii_data *mii = &sc->sc_mii;

	if (mii->mii_instance) {
		struct mii_softc *miisc;

		LIST_FOREACH(miisc, &mii->mii_phys, mii_list)
			mii_phy_reset(miisc);
	}
	return mii_mediachg(mii);
}

void
sxie_ifm_status(struct ifnet *ifp, struct ifmediareq *ifmr)
{
	struct sxie_softc *sc = (struct sxie_softc *)ifp->if_softc;

	mii_pollstat(&sc->sc_mii);
	ifmr->ifm_active = sc->sc_mii.mii_media_active;
	ifmr->ifm_status = sc->sc_mii.mii_media_status;
}
@


1.24
log
@Move Allwinner drivers that will soon be used by OpenBSD/arm64
to the new MI FDT driver directory.

"go ahead" kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sxie.c,v 1.23 2016/10/22 11:00:02 jsg Exp $	*/
a442 4
		if (pending & SXIE_TX_FIFO0)
			ifp->if_opackets++;
		if (pending & SXIE_TX_FIFO1)
			ifp->if_opackets++;
@


1.23
log
@Stop setting MIIF_AUTOTSLEEP in sxie(4)

This can lead to tsleep in an interrupt context.
Tested by and ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sxie.c,v 1.22 2016/09/11 21:44:30 kettenis Exp $	*/
d49 1
a49 1
#include <armv7/sunxi/sunxireg.h>
@


1.22
log
@Properly keep track of which of the two tx FIFOs is in use.  Fixes the

    sxie0: watchdog tx timeout

issue that appears when doing anything that tries to transmit a significant
number of packets.

ok mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sxie.c,v 1.21 2016/08/22 19:38:42 kettenis Exp $	*/
a260 1
	mii->mii_flags = MIIF_AUTOTSLEEP;
@


1.21
log
@Use new clock API.
@
text
@d1 1
a1 1
/*	$OpenBSD: sxie.c,v 1.20 2016/08/15 09:20:47 kettenis Exp $	*/
d104 3
d442 1
a442 3
	pending &= 3;

	if (pending) {
d444 3
a446 4
		sc->txf_inuse--;
		ifp->if_opackets++;
		if (pending == 3) { /* 2 packets got sent */
			sc->txf_inuse--;
d448 1
a448 1
		}
d476 1
a476 1
	if (sc->txf_inuse > 1)
d497 1
a497 1
	if (sc->txf_inuse > 1) {
d505 7
a511 1
	fifo = sc->txf_inuse;
a512 2

	sc->txf_inuse++;
@


1.20
log
@Use pinctrl to configure the pins used by the EMAC.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sxie.c,v 1.19 2016/08/05 22:19:23 kettenis Exp $	*/
a48 1
#include <armv7/armv7/armv7var.h>
a49 1
#include <armv7/sunxi/sxiccmuvar.h>
d52 1
d228 2
a280 2

	sxiccmu_enablemodule(CCMU_EMAC);
@


1.19
log
@Use m_devget(4).  From Artturi Alm.
@
text
@d1 1
a1 1
/*	$OpenBSD: sxie.c,v 1.18 2016/08/05 19:00:25 kettenis Exp $	*/
a51 1
#include <armv7/sunxi/sxipiovar.h>
d54 1
d218 2
d278 1
a278 1
	int i, have_mac = 0;
a280 2
	for (i = 0; i < SXIPIO_EMAC_NPINS; i++)
		sxipio_setcfg(i, 2); /* mux pins to EMAC */
@


1.18
log
@Switch the sunxi platform over to the new interrupt establish API.  This
involves turning sxiahci(4) into a real driver that dynamically attaches.
ehci(4) now also attaches dynamically.

ok jsg@@, patrick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sxie.c,v 1.17 2016/07/27 11:45:02 patrick Exp $	*/
a181 1
struct mbuf * sxie_newbuf(void);
a603 4
	m = sxie_newbuf();
	if (m == NULL)
		goto err_out;

a614 4
	m->m_pkthdr.len = m->m_len = pktlen;
	/* XXX m->m_pkthdr.csum_flags ? */
	m_adj(m, ETHER_ALIGN);

d622 6
a627 1
	memcpy(mtod(m, char *), (char *)&rxbuf[0], pktlen);
a676 18
}

struct mbuf *
sxie_newbuf(void)
{
	struct mbuf *m;

	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m == NULL)
		return (NULL);

	MCLGET(m, M_DONTWAIT);
	if (!(m->m_flags & M_EXT)) {
		m_freem(m);
		return (NULL);
	}

	return (m);
@


1.17
log
@Instead of passing the raw reg property to simplebus nodes,
pass a pre-processed array of fdt_reg structs.  This means
that the drivers don't have to understand the cell properties
themselves but can rely on the 64-bit addr/size pairs.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sxie.c,v 1.16 2016/06/12 06:58:39 jsg Exp $	*/
d214 1
a214 1
	int s, irq;
d216 1
a216 1
	if (faa->fa_nreg != 1 || (faa->fa_nintr != 1 && faa->fa_nintr != 3))
a218 5
	if (faa->fa_nintr == 1)
		irq = faa->fa_intr[0];
	else
		irq = faa->fa_intr[1];

d231 1
a231 1
	sc->sc_ih = arm_intr_establish(irq, IPL_NET,
@


1.16
log
@Handle both the nintr 1 (allwinner a10/cortex a8) and
nintr 3 (allwinner a20/cortex a7) cases.
@
text
@d1 1
a1 1
/*	$OpenBSD: sxie.c,v 1.15 2016/06/11 06:42:16 jsg Exp $	*/
d55 1
d216 1
a216 1
	if (faa->fa_nreg != 2 || (faa->fa_nintr != 1 && faa->fa_nintr != 3))
d226 2
a227 2
	if (bus_space_map(sc->sc_iot, faa->fa_reg[0],
	    faa->fa_reg[1], 0, &sc->sc_ioh))
@


1.15
log
@dynamically attach sxie(4) using the FDT
@
text
@d1 1
a1 1
/*	$OpenBSD: sxie.c,v 1.14 2016/04/13 11:34:00 mpi Exp $	*/
d213 1
a213 1
	int s;
d215 1
a215 1
	if (faa->fa_nreg < 2 || faa->fa_nintr != 1)
d218 5
d235 1
a235 1
	sc->sc_ih = arm_intr_establish(faa->fa_intr[0], IPL_NET,
@


1.14
log
@G/C IFQ_SET_READY().
@
text
@d1 1
a1 1
/*	$OpenBSD: sxie.c,v 1.13 2015/11/25 03:09:58 dlg Exp $	*/
d33 1
d54 2
d170 1
d191 1
a191 1
	sizeof (struct sxie_softc), NULL, sxie_attach
d198 8
d207 1
a207 1
sxie_attach(struct device *parent, struct device *self, void *args)
a208 1
	struct armv7_attach_args *aa = args;
d210 1
d215 4
a218 1
	sc->sc_iot = aa->aa_iot;
d220 2
a221 2
	if (bus_space_map(sc->sc_iot, aa->aa_dev->mem[0].addr,
	    aa->aa_dev->mem[0].size, 0, &sc->sc_ioh))
d230 1
a230 1
	sc->sc_ih = arm_intr_establish(aa->aa_dev->irq[0], IPL_NET,
@


1.13
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sxie.c,v 1.12 2015/11/24 17:11:38 mpi Exp $	*/
a232 1
	IFQ_SET_READY(&ifp->if_snd);
@


1.12
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@d1 1
a1 1
/*	$OpenBSD: sxie.c,v 1.11 2015/11/20 03:35:22 dlg Exp $	*/
d399 1
a399 1
	ifp->if_flags &= ~IFF_OACTIVE;
d429 1
a429 1
		ifp->if_flags &= ~IFF_OACTIVE;
d464 1
a464 1
		ifp->if_flags |= IFF_OACTIVE;
d466 1
a466 1
	if ((ifp->if_flags & (IFF_OACTIVE | IFF_RUNNING)) != IFF_RUNNING)
d487 1
a487 1
		ifp->if_flags |= IFF_OACTIVE;
d527 1
a527 1
	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
d529 1
@


1.11
log
@shuffle struct ifqueue so in flight mbufs are protected by a mutex.

the code is refactored so the IFQ macros call newly implemented ifq
functions. the ifq code is split so each discipline (priq and hfsc
in our case) is an opaque set of operations that the common ifq
code can call. the common code does the locking, accounting (ifq_len
manipulation), and freeing of the mbuf if the disciplines enqueue
function rejects it. theyre kind of like bufqs in the block layer
with their fifo and nscan disciplines.

the new api also supports atomic switching of disciplines at runtime.
the hfsc setup in pf_ioctl.c has been tweaked to build a complete
hfsc_if structure which it attaches to the send queue in a single
operation, rather than attaching to the interface up front and
building up a list of queues.

the send queue is now mutexed, which raises the expectation that
packets can be enqueued or purged on one cpu while another cpu is
dequeueing them in a driver for transmission. a lot of drivers use
IFQ_POLL to peek at an mbuf and attempt to fit it on the ring before
committing to it with a later IFQ_DEQUEUE operation. if the mbuf
gets freed in between the POLL and DEQUEUE operations, fireworks
will ensue.

to avoid this, the ifq api introduces ifq_deq_begin, ifq_deq_rollback,
and ifq_deq_commit. ifq_deq_begin allows a driver to take the ifq
mutex and get a reference to the mbuf they wish to try and tx. if
there's space, they can ifq_deq_commit it to remove the mbuf and
release the mutex. if there's no space, ifq_deq_rollback simply
releases the mutex. this api was developed to make updating the
drivers using IFQ_POLL easy, instead of having to do significant
semantic changes to avoid POLL that we cannot test on all the
hardware.

the common code has been tested pretty hard, and all the driver
modifications are straightforward except for de(4). if that breaks
it can be dealt with later.

ok mpi@@ jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sxie.c,v 1.10 2015/10/27 15:07:56 mpi Exp $	*/
a36 1
#include <net/if_dl.h>
@


1.10
log
@arp_ifinit() is no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: sxie.c,v 1.9 2015/06/24 09:40:53 mpi Exp $	*/
d474 1
a474 1
	IFQ_POLL(&ifp->if_snd, m);
d479 1
d486 1
d510 1
a510 1
	IFQ_DEQUEUE(&ifp->if_snd, m);
@


1.9
log
@Increment if_ipackets in if_input().

Note that pseudo-drivers not using if_input() are not affected by this
conversion.

ok mikeb@@, kettenis@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sxie.c,v 1.8 2015/04/03 06:48:58 mpi Exp $	*/
a628 1
	struct ifaddr *ifa = (struct ifaddr *)data;
a638 2
		if (ifa->ifa_addr->sa_family == AF_INET)
			arp_ifinit(&sc->sc_ac, ifa);
@


1.8
log
@Convert to if_input().

Tested by jsg@@ with Qemu
@
text
@d1 1
a1 1
/*	$OpenBSD: sxie.c,v 1.7 2014/12/22 02:26:53 tedu Exp $	*/
a602 1
	ifp->if_ipackets++;
@


1.7
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: sxie.c,v 1.6 2014/08/21 14:24:08 mpi Exp $	*/
d562 1
d571 1
a571 1
		return;
a603 1
	m->m_pkthdr.rcvif = ifp;
d617 1
a617 6
	/* push the packet up */
#if NBPFILTER > 0
	if (ifp->if_bpf)
		bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_IN);
#endif
	ether_input_mbuf(ifp, m);
d621 2
@


1.6
log
@Kill the remaining <netinet/in_systm.h> inclusion!
@
text
@d1 1
a1 1
/*	$OpenBSD: sxie.c,v 1.5 2013/11/06 19:03:07 syl Exp $	*/
a643 1
#ifdef INET
a645 1
#endif
@


1.5
log
@After factorizing armv7_machdep code here is an effort to factorize all
the code present in omap/omap.c imx/imx.c and sunxi/sunxi.c

All this code looks quite the same, so we move it in a generic armv7/armv7.c

This is a step closer to only one kernel for all armv7 boards.

ok patrick@@, rapha@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sxie.c,v 1.4 2013/10/26 20:20:22 jasper Exp $	*/
a42 1
#ifdef INET
a43 2
#include <netinet/in_systm.h>
#include <netinet/ip.h>
a44 1
#endif
@


1.4
log
@on certain boards (like the pcduino) u-boot doesn't setup the MAC address for
us, in this case calculate an address based on the Security ID (SID) to ensure
we get a unique address.

tested on pcduino to ensure a unique address and verified by aalm@@ on cubieboard
(where u-boot does setup the MAC address).

ok aalm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sxie.c,v 1.3 2013/10/24 08:28:11 mpi Exp $	*/
d53 1
a54 1
#include <armv7/sunxi/sunxivar.h>
d202 1
a202 1
	struct sxi_attach_args *sxi = args;
d208 1
a208 1
	sc->sc_iot = sxi->sxi_iot;
d210 2
a211 2
	if (bus_space_map(sc->sc_iot, sxi->sxi_dev->mem[0].addr,
	    sxi->sxi_dev->mem[0].size, 0, &sc->sc_ioh))
d220 1
a220 1
	sc->sc_ih = arm_intr_establish(sxi->sxi_dev->irq[0], IPL_NET,
@


1.3
log
@in_var.h is not needed.

ok patrick@@, jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sxie.c,v 1.2 2013/10/23 18:01:52 jasper Exp $	*/
d53 1
d163 1
d214 3
a222 2
	printf("\n");

d225 1
a225 2
	printf("%s: address %s\n", sc->sc_dev.dv_xname,
	    ether_sprintf(sc->sc_ac.ac_enaddr));
d267 1
a267 1
	int i;
d280 4
a283 2
#if 1
	/* set lladdr with values set in u-boot */
d285 28
a312 14
	sc->sc_ac.ac_enaddr[3] = reg >> 16 & 0xff;
	sc->sc_ac.ac_enaddr[4] = reg >> 8 & 0xff;
	sc->sc_ac.ac_enaddr[5] = reg & 0xff;
	reg = SXIREAD4(sc, SXIE_MACA1);
	sc->sc_ac.ac_enaddr[0] = reg >> 16 & 0xff;
	sc->sc_ac.ac_enaddr[1] = reg >> 8 & 0xff;
	sc->sc_ac.ac_enaddr[2] = reg & 0xff;
#else
	/* set lladdr */
	memset(sc->sc_ac.ac_enaddr, 0xff, ETHER_ADDR_LEN);
	arc4random_buf(sc->sc_ac.ac_enaddr, ETHER_ADDR_LEN);
	sc->sc_ac.ac_enaddr[0] &= ~3;
	sc->sc_ac.ac_enaddr[0] |= 2;
#endif
@


1.2
log
@rename some defines as well
@
text
@d1 1
a1 1
/*	$OpenBSD: sxie.c,v 1.1 2013/10/23 17:08:48 jasper Exp $	*/
a45 1
#include <netinet/in_var.h>
@


1.1
log
@rename 'allwinner' to 'sunxi' to actually match the SoC name instead of using
the vendor to follow our naming convention.

ok aalm@@ patrick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sxie.c,v 1.1 2013/10/22 13:22:19 jasper Exp $	*/
d59 41
a99 41
#define	AWE_CR			0x0000
#define	AWE_TXMODE		0x0004
#define	AWE_TXFLOW		0x0008
#define	AWE_TXCR0		0x000c
#define	AWE_TXCR1		0x0010
#define	AWE_TXINS		0x0014
#define	AWE_TXPKTLEN0		0x0018
#define	AWE_TXPKTLEN1		0x001c
#define	AWE_TXSR		0x0020
#define	AWE_TXIO0		0x0024
#define	AWE_TXIO1		0x0028
#define	AWE_TXTSVL0		0x002c
#define	AWE_TXTSVH0		0x0030
#define	AWE_TXTSVL1		0x0034
#define	AWE_TXTSVH1		0x0038
#define	AWE_RXCR		0x003c
#define	AWE_RXHASH0		0x0040
#define	AWE_RXHASH1		0x0044
#define	AWE_RXSR		0x0048
#define	AWE_RXIO		0x004C
#define	AWE_RXFBC		0x0050
#define	AWE_INTCR		0x0054
#define	AWE_INTSR		0x0058
#define	AWE_MACCR0		0x005C
#define	AWE_MACCR1		0x0060
#define	AWE_MACIPGT		0x0064
#define	AWE_MACIPGR		0x0068
#define	AWE_MACCLRT		0x006C
#define	AWE_MACMFL		0x0070
#define	AWE_MACSUPP		0x0074
#define	AWE_MACTEST		0x0078
#define	AWE_MACMCFG		0x007C
#define	AWE_MACMCMD		0x0080
#define	AWE_MACMADR		0x0084
#define	AWE_MACMWTD		0x0088
#define	AWE_MACMRDD		0x008C
#define	AWE_MACMIND		0x0090
#define	AWE_MACSSRR		0x0094
#define	AWE_MACA0		0x0098
#define	AWE_MACA1		0x009c
#define	AWE_MACA2		0x00a0
d102 51
a152 51
#define AWE_INTR_ENABLE		0x010f
#define AWE_INTR_DISABLE	0x0000
#define AWE_INTR_CLEAR		0x0000

#define	AWE_RX_ENABLE		0x0004
#define	AWE_TX_ENABLE		0x0003
#define	AWE_RXTX_ENABLE		0x0007

#define	AWE_RXDRQM		0x0002
#define	AWE_RXTM		0x0004
#define	AWE_RXFLUSH		0x0008
#define	AWE_RXPA		0x0010
#define	AWE_RXPCF		0x0020
#define	AWE_RXPCRCE		0x0040
#define	AWE_RXPLE		0x0080
#define	AWE_RXPOR		0x0100
#define	AWE_RXUCAD		0x10000
#define	AWE_RXDAF		0x20000
#define	AWE_RXMCO		0x100000
#define	AWE_RXMHF		0x200000
#define	AWE_RXBCO		0x400000
#define	AWE_RXSAF		0x1000000
#define	AWE_RXSAIF		0x2000000

#define	AWE_MACRXFC		0x0004
#define	AWE_MACTXFC		0x0008
#define AWE_MACSOFTRESET	0x8000

#define	AWE_MACDUPLEX		0x0001	/* full = 1 */
#define	AWE_MACFLC		0x0002
#define	AWE_MACHF		0x0004
#define	AWE_MACDCRC		0x0008
#define	AWE_MACCRC		0x0010
#define	AWE_MACPC		0x0020
#define	AWE_MACVC		0x0040
#define	AWE_MACADP		0x0080
#define	AWE_MACPRE		0x0100
#define	AWE_MACLPE		0x0200
#define	AWE_MACNB		0x1000
#define	AWE_MACBNB		0x2000
#define	AWE_MACED		0x4000

#define	AWE_RX_ERRLENOOR	0x0040
#define	AWE_RX_ERRLENCHK	0x0020
#define	AWE_RX_ERRCRC		0x0010
#define	AWE_RX_ERRRCV		0x0008 /* XXX receive code violation ? */
#define	AWE_RX_ERRMASK		0x0070

#define	AWE_MII_TIMEOUT	100
#define AWE_MAX_RXD		8
#define AWE_MAX_PKT_SIZE	ETHER_MAX_DIX_LEN
d154 1
a154 1
#define AWE_ROUNDUP(size, unit) (((size) + (unit) - 1) & ~((unit) - 1))
d269 1
a269 1
	for (i = 0; i < AWPIO_EMAC_NPINS; i++)
d274 1
a274 1
	AWCMS4(sc, AWE_MACMCFG, 15 << 2, 13 << 2);
d276 2
a277 2
	AWWRITE4(sc, AWE_INTCR, AWE_INTR_DISABLE);
	AWSET4(sc, AWE_INTSR, AWE_INTR_CLEAR);
d281 1
a281 1
	reg = AWREAD4(sc, AWE_MACA0);
d285 1
a285 1
	reg = AWREAD4(sc, AWE_MACA1);
d306 1
a306 1
	AWCMS4(sc, AWE_TXMODE, 3, 1);	/* cpu mode */
d309 5
a313 5
	clr_m = AWE_RXDRQM | AWE_RXTM | AWE_RXPA | AWE_RXPCF |
	    AWE_RXPCRCE | AWE_RXPLE | AWE_RXMHF | AWE_RXSAF |
	    AWE_RXSAIF;
	set_m = AWE_RXPOR | AWE_RXUCAD | AWE_RXDAF | AWE_RXBCO;
	AWCMS4(sc, AWE_RXCR, clr_m, set_m);
d316 5
a320 5
	AWSET4(sc, AWE_MACCR0, AWE_MACTXFC | AWE_MACRXFC);
	clr_m =	AWE_MACHF | AWE_MACDCRC | AWE_MACVC | AWE_MACADP |
	    AWE_MACPRE | AWE_MACLPE | AWE_MACNB | AWE_MACBNB |
	    AWE_MACED;
	set_m = AWE_MACFLC | AWE_MACCRC | AWE_MACPC;
d322 1
a322 1
	AWCMS4(sc, AWE_MACCR1, clr_m, set_m);
d325 2
a326 2
	AWWRITE4(sc, AWE_MACIPGT, 0x0015);
	AWWRITE4(sc, AWE_MACIPGR, 0x0c12);
d329 1
a329 1
	AWWRITE4(sc, AWE_MACCLRT, 0x370f);
d332 1
a332 1
	AWWRITE4(sc, AWE_MACMFL, AWE_MAX_PKT_SIZE);
d335 1
a335 1
	AWWRITE4(sc, AWE_MACA0,
d339 1
a339 1
	AWWRITE4(sc, AWE_MACA1,
d357 1
a357 1
	AWWRITE4(sc, AWE_INTCR, AWE_INTR_DISABLE);
d359 1
a359 1
	AWSET4(sc, AWE_INTSR, AWE_INTR_CLEAR);
d361 1
a361 1
	AWSET4(sc, AWE_RXCR, AWE_RXFLUSH);
d364 1
a364 1
	AWCLR4(sc, AWE_MACCR0, AWE_MACSOFTRESET);
d367 1
a367 1
	AWWRITE4(sc, AWE_RXFBC, 0);
d378 1
a378 1
	AWCMS4(sc, AWE_MACCR1, 1, phyreg >> 8 & 1);
d381 1
a381 1
	AWCMS4(sc, AWE_MACSUPP, 1 << 8, (phyreg >> 13 & 1) << 8);
d383 1
a383 1
	AWSET4(sc, AWE_CR, AWE_RXTX_ENABLE);
d389 1
a389 1
	AWSET4(sc, AWE_INTCR, AWE_INTR_ENABLE);
d401 1
a401 1
	AWWRITE4(sc, AWE_INTCR, AWE_INTR_DISABLE);
d403 2
a404 2
	pending = AWREAD4(sc, AWE_INTSR);
	AWWRITE4(sc, AWE_INTSR, pending);
d433 1
a433 1
	AWSET4(sc, AWE_INTCR, AWE_INTR_ENABLE);
d449 1
a449 1
	uint32_t txbuf[AWE_MAX_PKT_SIZE / sizeof(uint32_t)]; /* XXX !!! */
d465 1
a465 1
	if (m->m_pkthdr.len > AWE_MAX_PKT_SIZE) {
d479 1
a479 1
	AWWRITE4(sc, AWE_TXINS, fifo);
d484 1
a484 1
	AWWRITE4(sc, AWE_TXPKTLEN0 + (fifo * 4), m->m_pkthdr.len);
d489 2
a490 2
	    AWE_TXIO0 + (fifo * 4),
	    (uint32_t *)td, AWE_ROUNDUP(m->m_pkthdr.len, 4) >> 2);
d493 1
a493 1
	AWSET4(sc, AWE_TXCR0 + (fifo * 4), 1);
d521 1
a521 1
	AWWRITE4(sc, AWE_CR, 0);
d523 1
a523 1
	AWWRITE4(sc, AWE_CR, 1);
d553 1
a553 1
	char rxbuf[AWE_MAX_PKT_SIZE]; /* XXX !!! */
d555 1
a555 1
	fbc = AWREAD4(sc, AWE_RXFBC);
d563 1
a563 1
	reg = AWREAD4(sc, AWE_RXIO);
d566 4
a569 4
		AWCLR4(sc, AWE_CR, AWE_RX_ENABLE);
		AWSET4(sc, AWE_RXCR, AWE_RXFLUSH);
		while (AWREAD4(sc, AWE_RXCR) & AWE_RXFLUSH);
		AWSET4(sc, AWE_CR, AWE_RX_ENABLE);
d578 1
a578 1
	reg = AWREAD4(sc, AWE_RXIO);
d582 1
a582 1
	if (pktstat & AWE_RX_ERRMASK || pktlen < ETHER_MIN_LEN) {
d586 2
a587 2
	if (pktlen > AWE_MAX_PKT_SIZE)
		pktlen = AWE_MAX_PKT_SIZE; /* XXX is truncating ok? */
d597 1
a597 1
		rlen = AWE_ROUNDUP(pktlen, 4);
d601 1
a601 1
	    AWE_RXIO, (uint32_t *)&rxbuf[0], rlen >> 2);
d693 1
a693 1
	int timo = AWE_MII_TIMEOUT;
d695 1
a695 1
	AWWRITE4(sc, AWE_MACMADR, phy << 8 | reg);
d697 2
a698 2
	AWWRITE4(sc, AWE_MACMCMD, 1);
	while (AWREAD4(sc, AWE_MACMIND) & 1 && --timo)
d706 1
a706 1
	AWWRITE4(sc, AWE_MACMCMD, 0);
d708 1
a708 1
	return AWREAD4(sc, AWE_MACMRDD) & 0xffff;
d715 1
a715 1
	int timo = AWE_MII_TIMEOUT;
d717 1
a717 1
	AWWRITE4(sc, AWE_MACMADR, phy << 8 | reg);
d719 2
a720 2
	AWWRITE4(sc, AWE_MACMCMD, 1);
	while (AWREAD4(sc, AWE_MACMIND) & 1 && --timo)
d728 1
a728 1
	AWWRITE4(sc, AWE_MACMCMD, 0);
d730 1
a730 1
	AWWRITE4(sc, AWE_MACMWTD, val);
@

