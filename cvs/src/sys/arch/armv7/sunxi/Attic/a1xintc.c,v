head	1.9;
access;
symbols
	OPENBSD_6_0:1.7.0.4
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.2
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.6.0.4
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.4.0.2
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.4
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.3.0.4
	OPENBSD_5_5_BASE:1.3;
locks; strict;
comment	@ * @;


1.9
date	2016.08.05.20.38.17;	author kettenis;	state dead;
branches;
next	1.8;
commitid	0UKrx15wJC7DcQ7u;

1.8
date	2016.08.05.19.00.25;	author kettenis;	state Exp;
branches;
next	1.7;
commitid	PWnrMbYWs67oDQuR;

1.7
date	2016.01.31.00.14.50;	author jsg;	state Exp;
branches;
next	1.6;
commitid	pbLjedMudUFrVMk6;

1.6
date	2015.05.20.03.49.23;	author jsg;	state Exp;
branches;
next	1.5;
commitid	5bX9oiRmCoApfSjg;

1.5
date	2015.05.19.06.09.35;	author jsg;	state Exp;
branches;
next	1.4;
commitid	YzkyNQmP2W2qgU2u;

1.4
date	2014.07.12.18.44.41;	author tedu;	state Exp;
branches;
next	1.3;
commitid	uKVPYMN2MLxdZxzH;

1.3
date	2013.11.06.19.03.07;	author syl;	state Exp;
branches;
next	1.2;

1.2
date	2013.10.23.18.01.52;	author jasper;	state Exp;
branches;
next	1.1;

1.1
date	2013.10.23.17.08.47;	author jasper;	state Exp;
branches;
next	;


desc
@@


1.9
log
@We don't want drivers with numbers in their names.

Requested by deraadt@@
@
text
@/*	$OpenBSD: a1xintc.c,v 1.8 2016/08/05 19:00:25 kettenis Exp $	*/
/*
 * Copyright (c) 2007,2009 Dale Rahn <drahn@@openbsd.org>
 * Copyright (c) 2013 Artturi Alm
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/queue.h>
#include <sys/malloc.h>
#include <sys/device.h>
#include <sys/evcount.h>

#include <machine/bus.h>
#include <machine/fdt.h>

#include <armv7/armv7/armv7var.h>
#include <armv7/sunxi/sunxireg.h>
#include <armv7/sunxi/a1xintc.h>

#include <dev/ofw/openfirm.h>
#include <dev/ofw/fdt.h>

#ifdef DEBUG_INTC
#define DPRINTF(x)	do { if (a1xintcdebug) printf x; } while (0)
#define DPRINTFN(n,x)	do { if (a1xintcdebug>(n)) printf x; } while (0)
int	a1xintcdebug = 10;
char *ipl_strtbl[NIPL] = {
	"IPL_NONE",
	"IPL_SOFT",
	"IPL_SOFTCLOCK",
	"IPL_SOFTNET",
	"IPL_SOFTTTY",
	"IPL_BIO|IPL_USB",
	"IPL_NET",
	"IPL_TTY",
	"IPL_VM",
	"IPL_AUDIO",
	"IPL_CLOCK",
	"IPL_STATCLOCK",
	"IPL_SCHED|IPL_HIGH"
};
#else
#define DPRINTF(x)
#define DPRINTFN(n,x)
#endif

#define NIRQ			96
#define NBANKS			3
#define NIRQPRIOREGS		5

/* registers */
#define INTC_VECTOR_REG		0x00
#define INTC_BASE_ADR_REG	0x04
#define INTC_PROTECTION_REG	0x08
#define INTC_NMI_CTRL_REG	0x0c

#define INTC_IRQ_PENDING_REG0	0x10
#define INTC_IRQ_PENDING_REG1	0x14
#define INTC_IRQ_PENDING_REG2	0x18

#define INTC_SELECT_REG0	0x30
#define INTC_SELECT_REG1	0x34
#define INTC_SELECT_REG2	0x38

#define INTC_ENABLE_REG0	0x40
#define INTC_ENABLE_REG1	0x44
#define INTC_ENABLE_REG2	0x48

#define INTC_MASK_REG0		0x50
#define INTC_MASK_REG1		0x54
#define INTC_MASK_REG2		0x58

#define INTC_RESP_REG0		0x60
#define INTC_RESP_REG1		0x64
#define INTC_RESP_REG2		0x68

#define INTC_PRIO_REG0		0x80
#define INTC_PRIO_REG1		0x84
#define INTC_PRIO_REG2		0x88
#define INTC_PRIO_REG3		0x8c
#define INTC_PRIO_REG4		0x90

#define INTC_IRQ_PENDING_REG(_b)	(0x10 + ((_b) * 4))
#define INTC_FIQ_PENDING_REG(_b)	(0x20 + ((_b) * 4))
#define INTC_SELECT_REG(_b)		(0x30 + ((_b) * 4))
#define INTC_ENABLE_REG(_b)		(0x40 + ((_b) * 4))
#define INTC_MASK_REG(_b)		(0x50 + ((_b) * 4))
#define INTC_RESP_REG(_b)		(0x60 + ((_b) * 4))
#define INTC_PRIO_REG(_b)		(0x80 + ((_b) * 4))

#define IRQ2REG32(i)		(((i) >> 5) & 0x3)
#define IRQ2BIT32(i)		((i) & 0x1f)

#define IRQ2REG16(i)		(((i) >> 4) & 0x5)
#define IRQ2BIT16(i)		(((i) & 0x0f) * 2)

#define INTC_IRQ_HIPRIO		0x3
#define INTC_IRQ_ENABLED	0x2
#define INTC_IRQ_DISABLED	0x1
#define INTC_IRQ_LOWPRIO	0x0
#define INTC_PRIOCLEAR(i)	(~(INTC_IRQ_HIPRIO << IRQ2BIT16((i))))
#define INTC_PRIOENABLE(i)	(INTC_IRQ_ENABLED << IRQ2BIT16((i)))
#define INTC_PRIOHI(i)		(INTC_IRQ_HIPRIO << IRQ2BIT16((i)))


struct intrhand {
	TAILQ_ENTRY(intrhand) ih_list;	/* link on intrq list */
	int (*ih_func)(void *);		/* handler */
	void *ih_arg;			/* arg for handler */
	int ih_ipl;			/* IPL_* */
	int ih_irq;			/* IRQ number */
	struct evcount	ih_count;
	char *ih_name;
};

struct intrq {
	TAILQ_HEAD(, intrhand) iq_list;	/* handler list */
	int iq_irq;			/* IRQ to mask while handling */
	int iq_levels;			/* IPL_*'s this IRQ has */
	int iq_ist;			/* share type */
};

volatile int a1xsoftint_pending;

struct intrq a1xintc_handler[NIRQ];
u_int32_t a1xintc_smask[NIPL];
u_int32_t a1xintc_imask[NBANKS][NIPL];
struct interrupt_controller a1xintc_ic;

bus_space_tag_t		a1xintc_iot;
bus_space_handle_t	a1xintc_ioh;
int			a1xintc_nirq;

int	a1xintc_match(struct device *, void *, void *);
void	a1xintc_attach(struct device *, struct device *, void *);
int	a1xintc_spllower(int);
int	a1xintc_splraise(int);
void	a1xintc_setipl(int);
void	a1xintc_calc_masks(void);
void	*a1xintc_intr_establish_fdt(void *, int *, int, int (*)(void *),
	    void *, char *);

struct cfattach	a1xintc_ca = {
	sizeof (struct device), a1xintc_match, a1xintc_attach
};

struct cfdriver a1xintc_cd = {
	NULL, "a1xintc", DV_DULL
};

int a1xintc_attached = 0;

int
a1xintc_match(struct device *parent, void *match, void *aux)
{
	struct fdt_attach_args *faa = aux;

	return OF_is_compatible(faa->fa_node, "allwinner,sun4i-a10-ic");
}

void
a1xintc_attach(struct device *parent, struct device *self, void *aux)
{
	struct fdt_attach_args *faa = aux;
	int i, j;

	a1xintc_iot = faa->fa_iot;
	if (bus_space_map(a1xintc_iot, faa->fa_reg[0].addr,
	    faa->fa_reg[0].size, 0, &a1xintc_ioh))
		panic("a1xintc_attach: bus_space_map failed!");

	/* disable/mask/clear all interrupts */
	for (i = 0; i < NBANKS; i++) {
		bus_space_write_4(a1xintc_iot, a1xintc_ioh, INTC_ENABLE_REG(i), 0);
		bus_space_write_4(a1xintc_iot, a1xintc_ioh, INTC_MASK_REG(i), 0);
		bus_space_write_4(a1xintc_iot, a1xintc_ioh, INTC_IRQ_PENDING_REG(i),
		    0xffffffff);
		for (j = 0; j < NIPL; j++)
			a1xintc_imask[i][j] = 0;
	}

	/* XXX */
	bus_space_write_4(a1xintc_iot, a1xintc_ioh, INTC_PROTECTION_REG, 1);
	bus_space_write_4(a1xintc_iot, a1xintc_ioh, INTC_NMI_CTRL_REG, 0);

	for (i = 0; i < NIRQ; i++)
		TAILQ_INIT(&a1xintc_handler[i].iq_list);

	a1xintc_calc_masks();

	arm_init_smask();
	a1xintc_attached = 1;

	/* insert self as interrupt handler */
	arm_set_intr_handler(a1xintc_splraise, a1xintc_spllower, a1xintc_splx,
	    a1xintc_setipl,
	    a1xintc_intr_establish, a1xintc_intr_disestablish, a1xintc_intr_string,
	    a1xintc_irq_handler);
	a1xintc_setipl(IPL_HIGH);  /* XXX ??? */
	enable_interrupts(PSR_I);
	printf("\n");

	a1xintc_ic.ic_node = faa->fa_node;
	a1xintc_ic.ic_establish = a1xintc_intr_establish_fdt;
	arm_intr_register_fdt(&a1xintc_ic);
}

void
a1xintc_calc_masks(void)
{
	struct cpu_info *ci = curcpu();
	int irq;
	struct intrhand *ih;
	int i;

	for (irq = 0; irq < NIRQ; irq++) {
		int max = IPL_NONE;
		int min = IPL_HIGH;
		TAILQ_FOREACH(ih, &a1xintc_handler[irq].iq_list, ih_list) {
			if (ih->ih_ipl > max)
				max = ih->ih_ipl;
			if (ih->ih_ipl < min)
				min = ih->ih_ipl;
		}

		a1xintc_handler[irq].iq_irq = max;

		if (max == IPL_NONE)
			min = IPL_NONE;

#ifdef DEBUG_INTC
		if (min != IPL_NONE) {
			printf("irq %d to block at %d %d reg %d bit %d\n",
			    irq, max, min, IRQ2REG32(irq),
			    IRQ2BIT32(irq));
		}
#endif
		/* Enable interrupts at lower levels, clear -> enable */
		for (i = 0; i < min; i++)
			a1xintc_imask[IRQ2REG32(irq)][i] &=
			    ~(1 << IRQ2BIT32(irq));
		for (; i < NIPL; i++)
			a1xintc_imask[IRQ2REG32(irq)][i] |=
			    (1 << IRQ2BIT32(irq));
		/* XXX - set enable/disable, priority */ 
	}

	a1xintc_setipl(ci->ci_cpl);
}

void
a1xintc_splx(int new)
{
	struct cpu_info *ci = curcpu();
	a1xintc_setipl(new);

	if (ci->ci_ipending & arm_smask[ci->ci_cpl])
		arm_do_pending_intr(ci->ci_cpl);
}

int
a1xintc_spllower(int new)
{
	struct cpu_info *ci = curcpu();
	int old = ci->ci_cpl;
	a1xintc_splx(new);
	return (old);
}

int
a1xintc_splraise(int new)
{
	struct cpu_info *ci = curcpu();
	int old;
	old = ci->ci_cpl;

	/*
	 * setipl must always be called because there is a race window
	 * where the variable is updated before the mask is set
	 * an interrupt occurs in that window without the mask always
	 * being set, the hardware might not get updated on the next
	 * splraise completely messing up spl protection.
	 */
	if (old > new)
		new = old;

	a1xintc_setipl(new);
  
	return (old);
}

void
a1xintc_setipl(int new)
{
	struct cpu_info *ci = curcpu();
	int i, psw;
#if 1
	/*
	 * XXX not needed, because all interrupts are disabled
	 * by default, so touching maskregs has no effect, i hope.
	 */
	if (a1xintc_attached == 0) {
		ci->ci_cpl = new;
		return;
	}
#endif
	psw = disable_interrupts(PSR_I);
	ci->ci_cpl = new;
	for (i = 0; i < NBANKS; i++)
		bus_space_write_4(a1xintc_iot, a1xintc_ioh,
		    INTC_MASK_REG(i), a1xintc_imask[i][new]);
	restore_interrupts(psw);
}

void
a1xintc_irq_handler(void *frame)
{
	struct intrhand *ih;
	void *arg;
	uint32_t pr;
	int irq, prio, s;

	irq = bus_space_read_4(a1xintc_iot, a1xintc_ioh, INTC_VECTOR_REG) >> 2;
	if (irq == 0)
		return;

	prio = a1xintc_handler[irq].iq_irq;
	s = a1xintc_splraise(prio);
	splassert(prio);

	pr = bus_space_read_4(a1xintc_iot, a1xintc_ioh,
	    INTC_ENABLE_REG(IRQ2REG32(irq)));
	bus_space_write_4(a1xintc_iot, a1xintc_ioh,
	    INTC_ENABLE_REG(IRQ2REG32(irq)),
	    pr & ~(1 << IRQ2BIT32(irq)));

	/* clear pending */
	pr = bus_space_read_4(a1xintc_iot, a1xintc_ioh,
	    INTC_IRQ_PENDING_REG(IRQ2REG32(irq)));
	bus_space_write_4(a1xintc_iot, a1xintc_ioh,
	    INTC_IRQ_PENDING_REG(IRQ2REG32(irq)),
	    pr | (1 << IRQ2BIT32(irq)));

	pr = bus_space_read_4(a1xintc_iot, a1xintc_ioh,
	    INTC_ENABLE_REG(IRQ2REG32(irq)));
	bus_space_write_4(a1xintc_iot, a1xintc_ioh,
	    INTC_ENABLE_REG(IRQ2REG32(irq)),
	    pr | (1 << IRQ2BIT32(irq)));

	TAILQ_FOREACH(ih, &a1xintc_handler[irq].iq_list, ih_list) {
		if (ih->ih_arg != 0)
			arg = ih->ih_arg;
		else
			arg = frame;

		if (ih->ih_func(arg)) 
			ih->ih_count.ec_count++;
	}
	a1xintc_splx(s);
}

void *
a1xintc_intr_establish(int irq, int level, int (*func)(void *),
    void *arg, char *name)
{
	int psw;
	struct intrhand *ih;
	uint32_t er;

	if (irq <= 0 || irq >= NIRQ)
		panic("intr_establish: bogus irq %d %s\n", irq, name);

	DPRINTF(("intr_establish: irq %d level %d [%s]\n", irq, level,
	    name != NULL ? name : "NULL"));

	psw = disable_interrupts(PSR_I);

	/* no point in sleeping unless someone can free memory. */
	ih = (struct intrhand *)malloc (sizeof *ih, M_DEVBUF,
	    cold ? M_NOWAIT : M_WAITOK);
	if (ih == NULL)
		panic("intr_establish: can't malloc handler info\n");
	ih->ih_func = func;
	ih->ih_arg = arg;
	ih->ih_ipl = level;
	ih->ih_irq = irq;
	ih->ih_name = name;

	TAILQ_INSERT_TAIL(&a1xintc_handler[irq].iq_list, ih, ih_list);

	if (name != NULL)
		evcount_attach(&ih->ih_count, name, &ih->ih_irq);

	er = bus_space_read_4(a1xintc_iot, a1xintc_ioh,
	    INTC_ENABLE_REG(IRQ2REG32(irq)));
	bus_space_write_4(a1xintc_iot, a1xintc_ioh,
	    INTC_ENABLE_REG(IRQ2REG32(irq)),
	    er | (1 << IRQ2BIT32(irq)));

	a1xintc_calc_masks();
	
	restore_interrupts(psw);
	return (ih);
}

void *
a1xintc_intr_establish_fdt(void *cookie, int *cell, int level,
    int (*func)(void *), void *arg, char *name)
{
	return a1xintc_intr_establish(cell[0], level, func, arg, name);
}

void
a1xintc_intr_disestablish(void *cookie)
{
	struct intrhand *ih = cookie;
	int irq = ih->ih_irq;
	int psw;
	uint32_t er;

	psw = disable_interrupts(PSR_I);

	TAILQ_REMOVE(&a1xintc_handler[irq].iq_list, ih, ih_list);

	if (ih->ih_name != NULL)
		evcount_detach(&ih->ih_count);

	free(ih, M_DEVBUF, 0);

	er = bus_space_read_4(a1xintc_iot, a1xintc_ioh,
	    INTC_ENABLE_REG(IRQ2REG32(irq)));
	bus_space_write_4(a1xintc_iot, a1xintc_ioh,
	    INTC_ENABLE_REG(IRQ2REG32(irq)),
	    er & ~(1 << IRQ2BIT32(irq)));

	a1xintc_calc_masks();

	restore_interrupts(psw);
}

const char *
a1xintc_intr_string(void *cookie)
{
	return "asd?";
}
@


1.8
log
@Switch the sunxi platform over to the new interrupt establish API.  This
involves turning sxiahci(4) into a real driver that dynamically attaches.
ehci(4) now also attaches dynamically.

ok jsg@@, patrick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: a1xintc.c,v 1.7 2016/01/31 00:14:50 jsg Exp $	*/
@


1.7
log
@Switch from PSR_X_bit and X32_bit PSR macro names to just PSR_X.
This matches FreeBSD and makes things a bit more consistent.
Discussed with Patrick.
@
text
@d1 1
a1 1
/*	$OpenBSD: a1xintc.c,v 1.6 2015/05/20 03:49:23 jsg Exp $	*/
d27 1
d33 3
d141 1
d147 1
d153 2
d157 1
a157 1
	sizeof (struct device), NULL, a1xintc_attach
d166 8
d175 1
a175 1
a1xintc_attach(struct device *parent, struct device *self, void *args)
d177 1
a177 1
	struct armv7_attach_args *aa = args;
d180 3
a182 3
	a1xintc_iot = aa->aa_iot;
	if (bus_space_map(a1xintc_iot, aa->aa_dev->mem[0].addr,
	    aa->aa_dev->mem[0].size, 0, &a1xintc_ioh))
d215 4
d376 2
a377 1
a1xintc_intr_establish(int irq, int lvl, int (*f)(void *), void *arg, char *name)
d386 1
a386 1
	DPRINTF(("intr_establish: irq %d level %d [%s]\n", irq, lvl,
d396 1
a396 1
	ih->ih_func = f;
d398 1
a398 1
	ih->ih_ipl = lvl;
d417 7
@


1.6
log
@Remove cubieboard specific gpio led setting.
From Artturi Alm in bitrig.
@
text
@d1 1
a1 1
/*	$OpenBSD: a1xintc.c,v 1.5 2015/05/19 06:09:35 jsg Exp $	*/
d197 1
a197 1
	enable_interrupts(I32_bit);
d300 1
a300 1
	psw = disable_interrupts(I32_bit);
d368 1
a368 1
	psw = disable_interrupts(I32_bit);
d406 1
a406 1
	psw = disable_interrupts(I32_bit);
@


1.5
log
@change names to not conflict with omap intc
From Patrick Wildt in bitrig
@
text
@d1 1
a1 1
/*	$OpenBSD: a1xintc.c,v 1.4 2014/07/12 18:44:41 tedu Exp $	*/
a29 1
#include <armv7/sunxi/sxipiovar.h>
a318 4
	if (irq == 1)
		sxipio_togglepin(SXIPIO_LED_BLUE);

	sxipio_setpin(SXIPIO_LED_GREEN);
a352 2

	sxipio_clrpin(SXIPIO_LED_GREEN);
@


1.4
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: a1xintc.c,v 1.3 2013/11/06 19:03:07 syl Exp $	*/
d34 3
a36 3
#define DPRINTF(x)	do { if (intcdebug) printf x; } while (0)
#define DPRINTFN(n,x)	do { if (intcdebug>(n)) printf x; } while (0)
int	intcdebug = 10;
d133 1
a133 1
volatile int softint_pending;
d135 7
a141 7
struct intrq intc_handler[NIRQ];
u_int32_t intc_smask[NIPL];
u_int32_t intc_imask[NBANKS][NIPL];

bus_space_tag_t		intc_iot;
bus_space_handle_t	intc_ioh;
int			intc_nirq;
d144 4
a147 4
int	intc_spllower(int);
int	intc_splraise(int);
void	intc_setipl(int);
void	intc_calc_masks(void);
d157 1
a157 1
int intc_attached = 0;
d165 3
a167 3
	intc_iot = aa->aa_iot;
	if (bus_space_map(intc_iot, aa->aa_dev->mem[0].addr,
	    aa->aa_dev->mem[0].size, 0, &intc_ioh))
d172 3
a174 3
		bus_space_write_4(intc_iot, intc_ioh, INTC_ENABLE_REG(i), 0);
		bus_space_write_4(intc_iot, intc_ioh, INTC_MASK_REG(i), 0);
		bus_space_write_4(intc_iot, intc_ioh, INTC_IRQ_PENDING_REG(i),
d177 1
a177 1
			intc_imask[i][j] = 0;
d181 2
a182 2
	bus_space_write_4(intc_iot, intc_ioh, INTC_PROTECTION_REG, 1);
	bus_space_write_4(intc_iot, intc_ioh, INTC_NMI_CTRL_REG, 0);
d185 1
a185 1
		TAILQ_INIT(&intc_handler[i].iq_list);
d187 1
a187 1
	intc_calc_masks();
d190 1
a190 1
	intc_attached = 1;
d193 5
a197 5
	arm_set_intr_handler(intc_splraise, intc_spllower, intc_splx,
	    intc_setipl,
	    intc_intr_establish, intc_intr_disestablish, intc_intr_string,
	    intc_irq_handler);
	intc_setipl(IPL_HIGH);  /* XXX ??? */
d203 1
a203 1
intc_calc_masks(void)
d213 1
a213 1
		TAILQ_FOREACH(ih, &intc_handler[irq].iq_list, ih_list) {
d220 1
a220 1
		intc_handler[irq].iq_irq = max;
d234 1
a234 1
			intc_imask[IRQ2REG32(irq)][i] &=
d237 1
a237 1
			intc_imask[IRQ2REG32(irq)][i] |=
d242 1
a242 1
	intc_setipl(ci->ci_cpl);
d246 1
a246 1
intc_splx(int new)
d249 1
a249 1
	intc_setipl(new);
d256 1
a256 1
intc_spllower(int new)
d260 1
a260 1
	intc_splx(new);
d265 1
a265 1
intc_splraise(int new)
d281 1
a281 1
	intc_setipl(new);
d287 1
a287 1
intc_setipl(int new)
d296 1
a296 1
	if (intc_attached == 0) {
d304 2
a305 2
		bus_space_write_4(intc_iot, intc_ioh,
		    INTC_MASK_REG(i), intc_imask[i][new]);
d310 1
a310 1
intc_irq_handler(void *frame)
d317 1
a317 1
	irq = bus_space_read_4(intc_iot, intc_ioh, INTC_VECTOR_REG) >> 2;
d325 2
a326 2
	prio = intc_handler[irq].iq_irq;
	s = intc_splraise(prio);
d329 1
a329 1
	pr = bus_space_read_4(intc_iot, intc_ioh,
d331 1
a331 1
	bus_space_write_4(intc_iot, intc_ioh,
d336 1
a336 1
	pr = bus_space_read_4(intc_iot, intc_ioh,
d338 1
a338 1
	bus_space_write_4(intc_iot, intc_ioh,
d342 1
a342 1
	pr = bus_space_read_4(intc_iot, intc_ioh,
d344 1
a344 1
	bus_space_write_4(intc_iot, intc_ioh,
d348 1
a348 1
	TAILQ_FOREACH(ih, &intc_handler[irq].iq_list, ih_list) {
d357 1
a357 1
	intc_splx(s);
d363 1
a363 1
intc_intr_establish(int irq, int lvl, int (*f)(void *), void *arg, char *name)
d388 1
a388 1
	TAILQ_INSERT_TAIL(&intc_handler[irq].iq_list, ih, ih_list);
d393 1
a393 1
	er = bus_space_read_4(intc_iot, intc_ioh,
d395 1
a395 1
	bus_space_write_4(intc_iot, intc_ioh,
d399 1
a399 1
	intc_calc_masks();
d406 1
a406 1
intc_intr_disestablish(void *cookie)
d415 1
a415 1
	TAILQ_REMOVE(&intc_handler[irq].iq_list, ih, ih_list);
d422 1
a422 1
	er = bus_space_read_4(intc_iot, intc_ioh,
d424 1
a424 1
	bus_space_write_4(intc_iot, intc_ioh,
d428 1
a428 1
	intc_calc_masks();
d434 1
a434 1
intc_intr_string(void *cookie)
@


1.3
log
@After factorizing armv7_machdep code here is an effort to factorize all
the code present in omap/omap.c imx/imx.c and sunxi/sunxi.c

All this code looks quite the same, so we move it in a generic armv7/armv7.c

This is a step closer to only one kernel for all armv7 boards.

ok patrick@@, rapha@@
@
text
@d1 1
a1 1
/*	$OpenBSD: a1xintc.c,v 1.2 2013/10/23 18:01:52 jasper Exp $	*/
d420 1
a420 1
	free(ih, M_DEVBUF);
@


1.2
log
@rename some defines as well
@
text
@d1 1
a1 1
/*	$OpenBSD: a1xintc.c,v 1.1 2013/10/23 17:08:47 jasper Exp $	*/
d28 1
a28 1
#include <armv7/sunxi/sunxivar.h>
d162 1
a162 1
	struct sxi_attach_args *sxi = args;
d165 3
a167 3
	intc_iot = sxi->sxi_iot;
	if (bus_space_map(intc_iot, sxi->sxi_dev->mem[0].addr,
	    sxi->sxi_dev->mem[0].size, 0, &intc_ioh))
@


1.1
log
@rename 'allwinner' to 'sunxi' to actually match the SoC name instead of using
the vendor to follow our naming convention.

ok aalm@@ patrick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: a1xintc.c,v 1.1 2013/10/22 13:22:18 jasper Exp $	*/
d321 1
a321 1
		sxipio_togglepin(AWPIO_LED_BLUE);
d323 1
a323 1
	sxipio_setpin(AWPIO_LED_GREEN);
d359 1
a359 1
	sxipio_clrpin(AWPIO_LED_GREEN);
@

