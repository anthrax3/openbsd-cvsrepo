head	1.30;
access;
symbols
	OPENBSD_6_0:1.5.0.12
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.8
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.10
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.2
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.6
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.4
	OPENBSD_5_5_BASE:1.5;
locks; strict;
comment	@ * @;


1.30
date	2017.01.21.08.26.49;	author patrick;	state dead;
branches;
next	1.29;
commitid	dvP7gLmLqGu2JY3W;

1.29
date	2017.01.21.05.19.08;	author patrick;	state Exp;
branches;
next	1.28;
commitid	LtkfDH5eXOZYyysD;

1.28
date	2017.01.21.03.51.18;	author kettenis;	state Exp;
branches;
next	1.27;
commitid	y4fUZmguUdvJiKhD;

1.27
date	2017.01.07.23.33.53;	author kettenis;	state Exp;
branches;
next	1.26;
commitid	aoFSs5b4GhRkR4cV;

1.26
date	2016.11.21.20.22.43;	author kettenis;	state Exp;
branches;
next	1.25;
commitid	P0h3rXhlljKcHst8;

1.25
date	2016.11.10.19.59.22;	author kettenis;	state Exp;
branches;
next	1.24;
commitid	nrCkxGiQZ3219iAC;

1.24
date	2016.11.08.20.22.26;	author kettenis;	state Exp;
branches;
next	1.23;
commitid	4huUCnIE2HbSnEWJ;

1.23
date	2016.11.08.19.44.42;	author kettenis;	state Exp;
branches;
next	1.22;
commitid	W0SnHvcfLLe3UFIW;

1.22
date	2016.11.08.19.25.44;	author kettenis;	state Exp;
branches;
next	1.21;
commitid	uErTlM21bD2XvOAw;

1.21
date	2016.10.09.11.14.22;	author kettenis;	state Exp;
branches;
next	1.20;
commitid	aiJLMeOtKpZ2nF7H;

1.20
date	2016.10.07.18.52.36;	author patrick;	state Exp;
branches;
next	1.19;
commitid	WuWyuifwcMpBhMnQ;

1.19
date	2016.09.10.23.09.03;	author kettenis;	state Exp;
branches;
next	1.18;
commitid	FVP247MMbetTUKeZ;

1.18
date	2016.08.28.20.17.10;	author kettenis;	state Exp;
branches;
next	1.17;
commitid	TuyMwFNsS4pZzgsw;

1.17
date	2016.08.27.16.41.52;	author kettenis;	state Exp;
branches;
next	1.16;
commitid	ajOTj5HYCjsagXJt;

1.16
date	2016.08.27.11.39.59;	author kettenis;	state Exp;
branches;
next	1.15;
commitid	VAEfQIurUSrNJW4z;

1.15
date	2016.08.26.08.30.24;	author mglocker;	state Exp;
branches;
next	1.14;
commitid	eAHPqpB7WnO0a8sE;

1.14
date	2016.08.23.19.13.37;	author kettenis;	state Exp;
branches;
next	1.13;
commitid	uzTtc2JP9YoKkYRJ;

1.13
date	2016.08.22.19.43.49;	author kettenis;	state Exp;
branches;
next	1.12;
commitid	IiiUdIuGEOPnzEbK;

1.12
date	2016.08.22.19.29.32;	author kettenis;	state Exp;
branches;
next	1.11;
commitid	ldkB4qxFXOKLY2VA;

1.11
date	2016.08.22.18.18.35;	author kettenis;	state Exp;
branches;
next	1.10;
commitid	deX4EgQdbidsW3Da;

1.10
date	2016.08.22.06.48.38;	author kettenis;	state Exp;
branches;
next	1.9;
commitid	9rGQeyDrnUUh38v8;

1.9
date	2016.08.21.23.01.57;	author kettenis;	state Exp;
branches;
next	1.8;
commitid	G9U9s9KNnyPALW9a;

1.8
date	2016.08.21.21.39.59;	author kettenis;	state Exp;
branches;
next	1.7;
commitid	Uk3h51eKktO4asDH;

1.7
date	2016.08.20.19.34.44;	author kettenis;	state Exp;
branches;
next	1.6;
commitid	pBrtz3ycwJ2RLO5P;

1.6
date	2016.08.13.21.48.44;	author kettenis;	state Exp;
branches;
next	1.5;
commitid	2qTKU16ulv0qgTac;

1.5
date	2013.11.26.20.33.12;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2013.11.06.19.03.07;	author syl;	state Exp;
branches;
next	1.3;

1.3
date	2013.11.01.21.15.05;	author aalm;	state Exp;
branches;
next	1.2;

1.2
date	2013.10.23.18.01.52;	author jasper;	state Exp;
branches;
next	1.1;

1.1
date	2013.10.23.17.08.48;	author jasper;	state Exp;
branches;
next	;


desc
@@


1.30
log
@Move Allwinner drivers that will soon be used by OpenBSD/arm64
to the new MI FDT driver directory.

"go ahead" kettenis@@
@
text
@/*	$OpenBSD: sxiccmu.c,v 1.29 2017/01/21 05:19:08 patrick Exp $	*/
/*
 * Copyright (c) 2007,2009 Dale Rahn <drahn@@openbsd.org>
 * Copyright (c) 2013 Artturi Alm
 * Copyright (c) 2016 Mark Kettenis <kettenis@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/time.h>
#include <sys/device.h>

#include <machine/bus.h>
#include <machine/fdt.h>
#include <machine/intr.h>

#include <armv7/sunxi/sunxireg.h>

#include <dev/ofw/openfirm.h>
#include <dev/ofw/ofw_clock.h>
#include <dev/ofw/fdt.h>

#ifdef DEBUG_CCMU
#define DPRINTF(x)	do { printf x; } while (0)
#else
#define DPRINTF(x)
#endif

struct sxiccmu_ccu_bit {
	uint16_t reg;
	uint8_t bit;
	uint8_t parent;
};

#include "sxiccmu_clocks.h"

struct sxiccmu_softc {
	struct device		sc_dev;
	bus_space_tag_t		sc_iot;
	bus_space_handle_t	sc_ioh;

	struct sxiccmu_ccu_bit	*sc_gates;
	int			sc_ngates;
	struct clock_device	sc_cd;

	struct sxiccmu_ccu_bit	*sc_resets;
	int			sc_nresets;
	struct reset_device	sc_rd;

	uint32_t		(*sc_get_frequency)(struct sxiccmu_softc *,
				    uint32_t);
	int			(*sc_set_frequency)(struct sxiccmu_softc *,
				    uint32_t, uint32_t);
};

int	sxiccmu_match(struct device *, void *, void *);
void	sxiccmu_attach(struct device *, struct device *, void *);

struct cfattach	sxiccmu_ca = {
	sizeof (struct sxiccmu_softc), sxiccmu_match, sxiccmu_attach
};

struct cfdriver sxiccmu_cd = {
	NULL, "sxiccmu", DV_DULL
};

void sxiccmu_attach_clock(struct sxiccmu_softc *, int);

uint32_t sxiccmu_ccu_get_frequency(void *, uint32_t *);
int	sxiccmu_ccu_set_frequency(void *, uint32_t *, uint32_t);
void	sxiccmu_ccu_enable(void *, uint32_t *, int);
void	sxiccmu_ccu_reset(void *, uint32_t *, int);

uint32_t sxiccmu_a64_get_frequency(struct sxiccmu_softc *, uint32_t);
int	sxiccmu_a64_set_frequency(struct sxiccmu_softc *, uint32_t, uint32_t);
uint32_t sxiccmu_h3_get_frequency(struct sxiccmu_softc *, uint32_t);
int	sxiccmu_h3_set_frequency(struct sxiccmu_softc *, uint32_t, uint32_t);

int
sxiccmu_match(struct device *parent, void *match, void *aux)
{
	struct fdt_attach_args *faa = aux;

	if (faa->fa_node == OF_finddevice("/clocks")) {
		int node = OF_parent(faa->fa_node);

		return (OF_is_compatible(node, "allwinner,sun4i-a10") ||
		    OF_is_compatible(node, "allwinner,sun5i-a10s") ||
		    OF_is_compatible(node, "allwinner,sun5i-r8") ||
		    OF_is_compatible(node, "allwinner,sun50i-a64") ||
		    OF_is_compatible(node, "allwinner,sun7i-a20") ||
		    OF_is_compatible(node, "allwinner,sun8i-h3") ||
		    OF_is_compatible(node, "allwinner,sun9i-a80"));
	}

	return (OF_is_compatible(faa->fa_node, "allwinner,sun50i-a64-ccu") ||
	    OF_is_compatible(faa->fa_node, "allwinner,sun8i-h3-ccu"));
}

void
sxiccmu_attach(struct device *parent, struct device *self, void *aux)
{
	struct sxiccmu_softc *sc = (struct sxiccmu_softc *)self;
	struct fdt_attach_args *faa = aux;
	int node = faa->fa_node;

	sc->sc_iot = faa->fa_iot;
	if (faa->fa_nreg > 0 && bus_space_map(sc->sc_iot,
	    faa->fa_reg[0].addr, faa->fa_reg[0].size, 0, &sc->sc_ioh))
		panic("%s: bus_space_map failed!", __func__);

	printf("\n");

	if (OF_is_compatible(node, "allwinner,sun50i-a64-ccu")) {
		KASSERT(faa->fa_nreg > 0);
		sc->sc_gates = sun50i_a64_gates;
		sc->sc_ngates = nitems(sun50i_a64_gates);
		sc->sc_resets = sun50i_a64_resets;
		sc->sc_nresets = nitems(sun50i_a64_resets);
		sc->sc_get_frequency = sxiccmu_a64_get_frequency;
		sc->sc_set_frequency = sxiccmu_a64_set_frequency;
	} else if (OF_is_compatible(node, "allwinner,sun8i-h3-ccu")) {
		KASSERT(faa->fa_nreg > 0);
		sc->sc_gates = sun8i_h3_gates;
		sc->sc_ngates = nitems(sun8i_h3_gates);
		sc->sc_resets = sun8i_h3_resets;
		sc->sc_nresets = nitems(sun8i_h3_resets);
		sc->sc_get_frequency = sxiccmu_h3_get_frequency;
		sc->sc_set_frequency = sxiccmu_h3_set_frequency;
	} else {
		for (node = OF_child(node); node; node = OF_peer(node))
			sxiccmu_attach_clock(sc, node);
	}

	if (sc->sc_gates) {
		sc->sc_cd.cd_node = node;
		sc->sc_cd.cd_cookie = sc;
		sc->sc_cd.cd_get_frequency = sxiccmu_ccu_get_frequency;
		sc->sc_cd.cd_set_frequency = sxiccmu_ccu_set_frequency;
		sc->sc_cd.cd_enable = sxiccmu_ccu_enable;
		clock_register(&sc->sc_cd);
	}

	if (sc->sc_resets) {
		sc->sc_rd.rd_node = node;
		sc->sc_rd.rd_cookie = sc;
		sc->sc_rd.rd_reset = sxiccmu_ccu_reset;
		reset_register(&sc->sc_rd);
	}
}

/*
 * Device trees for the Allwinner SoCs have basically a clock node per
 * register of the clock control unit.  Attaching a separate driver to
 * each of them would be crazy, so we handle them here.
 */

struct sxiccmu_clock {
	int sc_node;
	bus_space_tag_t sc_iot;
	bus_space_handle_t sc_ioh;

	struct clock_device sc_cd;
	struct reset_device sc_rd;
};

struct sxiccmu_device {
	const char *compat;
	uint32_t (*get_frequency)(void *, uint32_t *);
	int	(*set_frequency)(void *, uint32_t *, uint32_t);
	void	(*enable)(void *, uint32_t *, int);
	void	(*reset)(void *, uint32_t *, int);
};

uint32_t sxiccmu_gen_get_frequency(void *, uint32_t *);
uint32_t sxiccmu_osc_get_frequency(void *, uint32_t *);
uint32_t sxiccmu_pll6_get_frequency(void *, uint32_t *);
void	sxiccmu_pll6_enable(void *, uint32_t *, int);
uint32_t sxiccmu_apb1_get_frequency(void *, uint32_t *);
int	sxiccmu_gmac_set_frequency(void *, uint32_t *, uint32_t);
int	sxiccmu_mmc_set_frequency(void *, uint32_t *, uint32_t);
void	sxiccmu_mmc_enable(void *, uint32_t *, int);
void	sxiccmu_gate_enable(void *, uint32_t *, int);
void	sxiccmu_reset(void *, uint32_t *, int);

struct sxiccmu_device sxiccmu_devices[] = {
	{
		.compat = "allwinner,sun4i-a10-osc-clk",
		.get_frequency = sxiccmu_osc_get_frequency,
	},
	{
		.compat = "allwinner,sun4i-a10-pll6-clk",
		.get_frequency = sxiccmu_pll6_get_frequency,
		.enable = sxiccmu_pll6_enable
	},
	{
		.compat = "allwinner,sun4i-a10-apb1-clk",
		.get_frequency = sxiccmu_apb1_get_frequency,
	},
	{
		.compat = "allwinner,sun4i-a10-ahb-gates-clk",
		.get_frequency = sxiccmu_gen_get_frequency,
		.enable = sxiccmu_gate_enable
	},
	{
		.compat = "allwinner,sun4i-a10-apb0-gates-clk",
		.get_frequency = sxiccmu_gen_get_frequency,
		.enable = sxiccmu_gate_enable
	},
	{
		.compat = "allwinner,sun4i-a10-apb1-gates-clk",
		.get_frequency = sxiccmu_gen_get_frequency,
		.enable = sxiccmu_gate_enable
	},
	{
		.compat = "allwinner,sun4i-a10-mmc-clk",
		.set_frequency = sxiccmu_mmc_set_frequency,
		.enable = sxiccmu_mmc_enable
	},
	{
		.compat = "allwinner,sun4i-a10-usb-clk",
		.get_frequency = sxiccmu_gen_get_frequency,
		.enable = sxiccmu_gate_enable,
		.reset = sxiccmu_reset
	},
	{
		.compat = "allwinner,sun5i-a10s-ahb-gates-clk",
		.get_frequency = sxiccmu_gen_get_frequency,
		.enable = sxiccmu_gate_enable
	},
	{
		.compat = "allwinner,sun5i-a10s-apb0-gates-clk",
		.get_frequency = sxiccmu_gen_get_frequency,
		.enable = sxiccmu_gate_enable
	},
	{
		.compat = "allwinner,sun5i-a10s-apb1-gates-clk",
		.get_frequency = sxiccmu_gen_get_frequency,
		.enable = sxiccmu_gate_enable
	},
	{
		.compat = "allwinner,sun5i-a13-ahb-gates-clk",
		.get_frequency = sxiccmu_gen_get_frequency,
		.enable = sxiccmu_gate_enable
	},
	{
		.compat = "allwinner,sun5i-a13-apb0-gates-clk",
		.get_frequency = sxiccmu_gen_get_frequency,
		.enable = sxiccmu_gate_enable
	},
	{
		.compat = "allwinner,sun5i-a13-apb1-gates-clk",
		.get_frequency = sxiccmu_gen_get_frequency,
		.enable = sxiccmu_gate_enable
	},
	{
		.compat = "allwinner,sun5i-a13-usb-clk",
		.get_frequency = sxiccmu_gen_get_frequency,
		.enable = sxiccmu_gate_enable,
		.reset = sxiccmu_reset
	},
	{
		.compat = "allwinner,sun6i-a31-ahb1-reset",
		.reset = sxiccmu_reset
	},
	{
		.compat = "allwinner,sun6i-a31-clock-reset",
		.reset = sxiccmu_reset
	},
	{
		.compat = "allwinner,sun7i-a20-ahb-gates-clk",
		.get_frequency = sxiccmu_gen_get_frequency,
		.enable = sxiccmu_gate_enable
	},
	{
		.compat = "allwinner,sun7i-a20-apb0-gates-clk",
		.get_frequency = sxiccmu_gen_get_frequency,
		.enable = sxiccmu_gate_enable
	},
	{
		.compat = "allwinner,sun7i-a20-apb1-gates-clk",
		.get_frequency = sxiccmu_gen_get_frequency,
		.enable = sxiccmu_gate_enable
	},
	{
		.compat = "allwinner,sun7i-a20-gmac-clk",
		.set_frequency = sxiccmu_gmac_set_frequency
	},
	{
		.compat = "allwinner,sun8i-h3-apb0-gates-clk",
		.get_frequency = sxiccmu_gen_get_frequency,
		.enable = sxiccmu_gate_enable
	},
	{
		.compat = "allwinner,sun9i-a80-apb1-clk",
		.get_frequency = sxiccmu_apb1_get_frequency,
	},
	{
		.compat = "allwinner,sun9i-a80-ahb0-gates-clk",
		.get_frequency = sxiccmu_gen_get_frequency,
		.enable = sxiccmu_gate_enable
	},
	{
		.compat = "allwinner,sun9i-a80-ahb1-gates-clk",
		.get_frequency = sxiccmu_gen_get_frequency,
		.enable = sxiccmu_gate_enable
	},
	{
		.compat = "allwinner,sun9i-a80-ahb2-gates-clk",
		.get_frequency = sxiccmu_gen_get_frequency,
		.enable = sxiccmu_gate_enable
	},
	{
		.compat = "allwinner,sun9i-a80-apb0-gates-clk",
		.get_frequency = sxiccmu_gen_get_frequency,
		.enable = sxiccmu_gate_enable
	},
	{
		.compat = "allwinner,sun9i-a80-apb1-gates-clk",
		.get_frequency = sxiccmu_gen_get_frequency,
		.enable = sxiccmu_gate_enable
	},
	{
		.compat = "allwinner,sun9i-a80-apbs-gates-clk",
		.get_frequency = sxiccmu_gen_get_frequency,
		.enable = sxiccmu_gate_enable
	},
	{
		.compat = "allwinner,sun9i-a80-mmc-clk",
		.set_frequency = sxiccmu_mmc_set_frequency,
		.enable = sxiccmu_mmc_enable
	},
	{
		.compat = "allwinner,sun9i-a80-usb-mod-clk",
		.get_frequency = sxiccmu_gen_get_frequency,
		.enable = sxiccmu_gate_enable,
		.reset = sxiccmu_reset
	},
	{
		.compat = "allwinner,sun9i-a80-usb-phy-clk",
		.get_frequency = sxiccmu_gen_get_frequency,
		.enable = sxiccmu_gate_enable,
		.reset = sxiccmu_reset
	},
};

void
sxiccmu_attach_clock(struct sxiccmu_softc *sc, int node)
{
	struct sxiccmu_clock *clock;
	uint32_t reg[2];
	int i;

	for (i = 0; i < nitems(sxiccmu_devices); i++)
		if (OF_is_compatible(node, sxiccmu_devices[i].compat))
			break;
	if (i == nitems(sxiccmu_devices))
		return;

	clock = malloc(sizeof(*clock), M_DEVBUF, M_WAITOK);
	clock->sc_node = node;

	if (OF_getpropintarray(node, "reg", reg, sizeof(reg)) == sizeof(reg)) {
		clock->sc_iot = sc->sc_iot;
		if (bus_space_map(clock->sc_iot, reg[0], reg[1], 0,
		    &clock->sc_ioh)) {
			printf("%s: can't map registers", sc->sc_dev.dv_xname);
			free(clock, M_DEVBUF, sizeof(*clock));
			return;
		}
	}

	clock->sc_cd.cd_node = node;
	clock->sc_cd.cd_cookie = clock;
	clock->sc_cd.cd_get_frequency = sxiccmu_devices[i].get_frequency;
	clock->sc_cd.cd_set_frequency = sxiccmu_devices[i].set_frequency;
	clock->sc_cd.cd_enable = sxiccmu_devices[i].enable;
	clock_register(&clock->sc_cd);

	if (sxiccmu_devices[i].reset) {
		clock->sc_rd.rd_node = node;
		clock->sc_rd.rd_cookie = clock;
		clock->sc_rd.rd_reset = sxiccmu_devices[i].reset;
		reset_register(&clock->sc_rd);
	}
}

/*
 * A "generic" function that simply gets the clock frequency from the
 * parent clock.  Useful for clock gating devices that don't scale
 * their clocks.
 */
uint32_t
sxiccmu_gen_get_frequency(void *cookie, uint32_t *cells)
{
	struct sxiccmu_clock *sc = cookie;

	return clock_get_frequency(sc->sc_node, NULL);
}

uint32_t
sxiccmu_osc_get_frequency(void *cookie, uint32_t *cells)
{
	struct sxiccmu_clock *sc = cookie;

	return OF_getpropint(sc->sc_node, "clock-frequency", 24000000);
}

#define CCU_PLL6_ENABLE			(1U << 31)
#define CCU_PLL6_BYPASS_EN		(1U << 30)
#define CCU_PLL6_SATA_CLK_EN		(1U << 14)
#define CCU_PLL6_FACTOR_N(x)		(((x) >> 8) & 0x1f)
#define CCU_PLL6_FACTOR_N_MASK		(0x1f << 8)
#define CCU_PLL6_FACTOR_N_SHIFT		8
#define CCU_PLL6_FACTOR_K(x)		(((x) >> 4) & 0x3)
#define CCU_PLL6_FACTOR_K_MASK		(0x3 << 4)
#define CCU_PLL6_FACTOR_K_SHIFT		4
#define CCU_PLL6_FACTOR_M(x)		(((x) >> 0) & 0x3)
#define CCU_PLL6_FACTOR_M_MASK		(0x3 << 0)
#define CCU_PLL6_FACTOR_M_SHIFT		0

uint32_t
sxiccmu_pll6_get_frequency(void *cookie, uint32_t *cells)
{
	struct sxiccmu_clock *sc = cookie;
	uint32_t reg, k, m, n, freq;
	uint32_t idx = cells[0];

	/* XXX Assume bypass is disabled. */
	reg = SXIREAD4(sc, 0);
	k = CCU_PLL6_FACTOR_K(reg) + 1;
	m = CCU_PLL6_FACTOR_M(reg) + 1;
	n = CCU_PLL6_FACTOR_N(reg);

	freq = clock_get_frequency_idx(sc->sc_node, 0);
	switch (idx) {
	case 0:	
		return (freq * n * k) / m / 6;		/* pll6_sata */
	case 1:	
		return (freq * n * k) / 2;		/* pll6_other */
	case 2:	
		return (freq * n * k);			/* pll6 */
	case 3:
		return (freq * n * k) / 4;		/* pll6_div_4 */
	}

	return 0;
}

void
sxiccmu_pll6_enable(void *cookie, uint32_t *cells, int on)
{
	struct sxiccmu_clock *sc = cookie;
	uint32_t idx = cells[0];
	uint32_t reg;

	/* 
	 * Since this clock has several outputs, we never turn it off.
	 */

	reg = SXIREAD4(sc, 0);
	switch (idx) {
	case 0:			/* pll6_sata */
		if (on)
			reg |= CCU_PLL6_SATA_CLK_EN;
		else
			reg &= ~CCU_PLL6_SATA_CLK_EN;
		/* FALLTHROUGH */
	case 1:			/* pll6_other */
	case 2:			/* pll6 */
	case 3:			/* pll6_div_4 */
		if (on)
			reg |= CCU_PLL6_ENABLE;
	}
	SXIWRITE4(sc, 0, reg);
}

#define CCU_APB1_CLK_RAT_N(x)		(((x) >> 16) & 0x3)
#define CCU_APB1_CLK_RAT_M(x)		(((x) >> 0) & 0x1f)
#define CCU_APB1_CLK_SRC_SEL(x)		(((x) >> 24) & 0x3)

uint32_t
sxiccmu_apb1_get_frequency(void *cookie, uint32_t *cells)
{
	struct sxiccmu_clock *sc = cookie;
	uint32_t reg, m, n, freq;
	int idx;

	reg = SXIREAD4(sc, 0);
	m = CCU_APB1_CLK_RAT_M(reg);
	n = CCU_APB1_CLK_RAT_N(reg);
	idx = CCU_APB1_CLK_SRC_SEL(reg);

	freq = clock_get_frequency_idx(sc->sc_node, idx);
	return freq / (1 << n) / (m + 1);
}

#define	CCU_GMAC_CLK_PIT		(1 << 2)
#define	CCU_GMAC_CLK_TCS		(3 << 0)
#define	CCU_GMAC_CLK_TCS_MII		0
#define	CCU_GMAC_CLK_TCS_EXT_125	1
#define	CCU_GMAC_CLK_TCS_INT_RGMII	2

int
sxiccmu_gmac_set_frequency(void *cookie, uint32_t *cells, uint32_t freq)
{
	struct sxiccmu_clock *sc = cookie;

	switch (freq) {
	case 25000000:		/* MMI, 25 MHz */
		SXICMS4(sc, 0, CCU_GMAC_CLK_PIT|CCU_GMAC_CLK_TCS,
		    CCU_GMAC_CLK_TCS_MII);
		break;
	case 125000000:		/* RGMII, 125 MHz */
		SXICMS4(sc, 0, CCU_GMAC_CLK_PIT|CCU_GMAC_CLK_TCS,
		    CCU_GMAC_CLK_PIT|CCU_GMAC_CLK_TCS_INT_RGMII);
		break;
	default:
		return -1;
	}

	return 0;
}

#define CCU_SDx_SCLK_GATING		(1U << 31)
#define CCU_SDx_CLK_SRC_SEL_OSC24M	(0 << 24)
#define CCU_SDx_CLK_SRC_SEL_PLL6	(1 << 24)
#define CCU_SDx_CLK_SRC_SEL_PLL5	(2 << 24)
#define CCU_SDx_CLK_SRC_SEL_MASK	(3 << 24)
#define CCU_SDx_CLK_DIV_RATIO_N_MASK	(3 << 16)
#define CCU_SDx_CLK_DIV_RATIO_N_SHIFT	16
#define CCU_SDx_CLK_DIV_RATIO_M_MASK	(7 << 0)
#define CCU_SDx_CLK_DIV_RATIO_M_SHIFT	0

int
sxiccmu_mmc_do_set_frequency(struct sxiccmu_clock *sc, uint32_t freq,
    uint32_t parent_freq)
{
	uint32_t reg, m, n;
	uint32_t clk_src;

	switch (freq) {
	case 400000:
		n = 2, m = 15;
		clk_src = CCU_SDx_CLK_SRC_SEL_OSC24M;
		break;
	case 25000000:
	case 26000000:
	case 50000000:
	case 52000000:
		n = 0, m = 0;
		clk_src = CCU_SDx_CLK_SRC_SEL_PLL6;
		while ((parent_freq / (1 << n) / 16) > freq)
			n++;
		while ((parent_freq / (1 << n) / (m + 1)) > freq)
			m++;
		break;
	default:
		return -1;
	}

	reg = SXIREAD4(sc, 0);
	reg &= ~CCU_SDx_CLK_SRC_SEL_MASK;
	reg |= clk_src;
	reg &= ~CCU_SDx_CLK_DIV_RATIO_N_MASK;
	reg |= n << CCU_SDx_CLK_DIV_RATIO_N_SHIFT;
	reg &= ~CCU_SDx_CLK_DIV_RATIO_M_MASK;
	reg |= m << CCU_SDx_CLK_DIV_RATIO_M_SHIFT;
	SXIWRITE4(sc, 0, reg);

	return 0;
}

int
sxiccmu_mmc_set_frequency(void *cookie, uint32_t *cells, uint32_t freq)
{
	struct sxiccmu_clock *sc = cookie;
	uint32_t parent_freq;

	if (cells[0] != 0)
		return -1;

	parent_freq = clock_get_frequency_idx(sc->sc_node, 1);
	return sxiccmu_mmc_do_set_frequency(sc, freq, parent_freq);
}

void
sxiccmu_mmc_enable(void *cookie, uint32_t *cells, int on)
{
	struct sxiccmu_clock *sc = cookie;

	if (cells[0] != 0)
		return;

	if (on)
		SXISET4(sc, 0, CCU_SDx_SCLK_GATING);
	else
		SXICLR4(sc, 0, CCU_SDx_SCLK_GATING);
}

void
sxiccmu_gate_enable(void *cookie, uint32_t *cells, int on)
{
	struct sxiccmu_clock *sc = cookie;
	int reg = cells[0] / 32;
	int bit = cells[0] % 32;

	if (on) {
		clock_enable(sc->sc_node, NULL);
		SXISET4(sc, reg * 4, (1U << bit));
	} else {
		SXICLR4(sc, reg * 4, (1U << bit));
		clock_disable(sc->sc_node, NULL);
	}
}

void
sxiccmu_reset(void *cookie, uint32_t *cells, int assert)
{
	struct sxiccmu_clock *sc = cookie;
	int reg = cells[0] / 32;
	int bit = cells[0] % 32;

	if (assert)
		SXICLR4(sc, reg * 4, (1U << bit));
	else
		SXISET4(sc, reg * 4, (1U << bit));
}

/*
 * Device trees for the Allwinner A80 have most of the clock nodes
 * replaced with a single clock control unit node.
 */

uint32_t
sxiccmu_ccu_get_frequency(void *cookie, uint32_t *cells)
{
	struct sxiccmu_softc *sc = cookie;
	uint32_t idx = cells[0];
	uint32_t parent;

	if (idx < sc->sc_ngates && sc->sc_gates[idx].parent) {
		parent = sc->sc_gates[idx].parent;
		return sxiccmu_ccu_get_frequency(sc, &parent);
	}

	return sc->sc_get_frequency(sc, idx);
}

uint32_t
sxiccmu_a64_get_frequency(struct sxiccmu_softc *sc, uint32_t idx)
{
	switch (idx) {
	case A64_CLK_PLL_PERIPH0:
		/* XXX default value. */
		return 600000000;
	case A64_CLK_PLL_PERIPH0_2X:
		return sxiccmu_a64_get_frequency(sc, A64_CLK_PLL_PERIPH0) * 2;
	case A64_CLK_APB2:
		/* XXX Controlled by a MUX. */
		return 24000000;
	}

	printf("%s: 0x%08x\n", __func__, idx);
	return 0;
}

uint32_t
sxiccmu_h3_get_frequency(struct sxiccmu_softc *sc, uint32_t idx)
{
	switch (idx) {
	case H3_CLK_PLL_PERIPH0:
		/* XXX default value. */
		return 600000000;
	case H3_CLK_APB2:
		/* XXX Controlled by a MUX. */
		return 24000000;
	}

	printf("%s: 0x%08x\n", __func__, idx);
	return 0;
}

int
sxiccmu_ccu_set_frequency(void *cookie, uint32_t *cells, uint32_t freq)
{
	struct sxiccmu_softc *sc = cookie;
	uint32_t idx = cells[0];

	return sc->sc_set_frequency(sc, idx, freq);
}

int
sxiccmu_a64_set_frequency(struct sxiccmu_softc *sc, uint32_t idx, uint32_t freq)
{
	struct sxiccmu_clock clock;
	uint32_t parent, parent_freq;

	switch (idx) {
	case A64_CLK_MMC0:
	case A64_CLK_MMC1:
	case A64_CLK_MMC2:
		clock.sc_iot = sc->sc_iot;
		bus_space_subregion(sc->sc_iot, sc->sc_ioh,
		    sc->sc_gates[idx].reg, 4, &clock.sc_ioh);
		parent = A64_CLK_PLL_PERIPH0_2X;
		parent_freq = sxiccmu_ccu_get_frequency(sc, &parent);
		return sxiccmu_mmc_do_set_frequency(&clock, freq, parent_freq);
	}

	printf("%s: 0x%08x\n", __func__, idx);
	return -1;
}

int
sxiccmu_h3_set_frequency(struct sxiccmu_softc *sc, uint32_t idx, uint32_t freq)
{
	struct sxiccmu_clock clock;
	uint32_t parent, parent_freq;

	switch (idx) {
	case H3_CLK_MMC0:
	case H3_CLK_MMC1:
	case H3_CLK_MMC2:
		clock.sc_iot = sc->sc_iot;
		bus_space_subregion(sc->sc_iot, sc->sc_ioh,
		    sc->sc_gates[idx].reg, 4, &clock.sc_ioh);
		parent = H3_CLK_PLL_PERIPH0;
		parent_freq = sxiccmu_ccu_get_frequency(sc, &parent);
		return sxiccmu_mmc_do_set_frequency(&clock, freq, parent_freq);
	}

	printf("%s: 0x%08x\n", __func__, idx);
	return -1;
}

void
sxiccmu_ccu_enable(void *cookie, uint32_t *cells, int on)
{
	struct sxiccmu_softc *sc = cookie;
	uint32_t idx = cells[0];
	int reg, bit;

	if (idx >= sc->sc_ngates || sc->sc_gates[idx].reg == 0) {
		printf("%s: 0x%08x\n", __func__, cells[0]);
		return;
	}

	reg = sc->sc_gates[idx].reg;
	bit = sc->sc_gates[idx].bit;

	if (on)
		SXISET4(sc, reg, (1U << bit));
	else
		SXICLR4(sc, reg, (1U << bit));
}

void
sxiccmu_ccu_reset(void *cookie, uint32_t *cells, int assert)
{
	struct sxiccmu_softc *sc = cookie;
	uint32_t idx = cells[0];
	int reg, bit;

	if (idx >= sc->sc_nresets || sc->sc_resets[idx].reg == 0) {
		printf("%s: 0x%08x\n", __func__, cells[0]);
		return;
	}

	reg = sc->sc_resets[idx].reg;
	bit = sc->sc_resets[idx].bit;
	
	if (assert)
		SXICLR4(sc, reg, (1U << bit));
	else
		SXISET4(sc, reg, (1U << bit));
}
@


1.29
log
@Implement EHCI and MMC clock support for the Allwinner A64 SoC.
Unfortunately this does not yet enable us to use the MMC on the
Pine64.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sxiccmu.c,v 1.28 2017/01/21 03:51:18 kettenis Exp $	*/
@


1.28
log
@Split out the Allwinner H3 specific clock code into its own functions and
call those via a function pointer such that we can support other SoCs by
simply adding new functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: sxiccmu.c,v 1.27 2017/01/07 23:33:53 kettenis Exp $	*/
a27 2
#include <arm/cpufunc.h>

d89 2
d105 1
d111 2
a112 1
	return OF_is_compatible(faa->fa_node, "allwinner,sun8i-h3-ccu");
d129 9
a137 1
	if (OF_is_compatible(node, "allwinner,sun8i-h3-ccu")) {
d666 18
d706 22
@


1.27
log
@Make getting the parent clock for the SD/MMC controller work on the
Allwinner H3.
@
text
@d1 1
a1 1
/*	$OpenBSD: sxiccmu.c,v 1.26 2016/11/21 20:22:43 kettenis Exp $	*/
d66 5
d91 3
d133 2
d652 6
d667 1
a667 1
	printf("%s: 0x%08x\n", __func__, cells[0]);
d675 8
a683 1
	uint32_t idx = cells[0];
d698 1
a698 1
	printf("%s: 0x%08x\n", __func__, cells[0]);
@


1.26
log
@Add support for "allwinner,sun9i-a80-usb-mod-clk" and
"allwinner,sun9i-a80-usb-phy-clk" compatile clocks.

Enable parent clock of clock gates.
@
text
@d1 1
a1 1
/*	$OpenBSD: sxiccmu.c,v 1.25 2016/11/10 19:59:22 kettenis Exp $	*/
d531 2
a532 1
sxiccmu_mmc_set_frequency(void *cookie, uint32_t *cells, uint32_t freq)
a533 1
	struct sxiccmu_clock *sc = cookie;
a535 4
	uint32_t parent_freq;

	if (cells[0] != 0)
		return -1;
a547 1
		parent_freq = clock_get_frequency_idx(sc->sc_node, 1);
d569 13
d643 3
d661 1
a666 1
		idx = 0;
d670 3
a672 1
		return sxiccmu_mmc_set_frequency(&clock, &idx, freq);
@


1.25
log
@Add support for "allwinner,sun9i-a80-apb1-clk" compatible clocks.

This makes the serial console work properly and makes Cubieboard4 go
multi-user.
@
text
@d1 1
a1 1
/*	$OpenBSD: sxiccmu.c,v 1.24 2016/11/08 20:22:26 kettenis Exp $	*/
d328 12
d595 2
a596 1
	if (on)
d598 1
a598 1
	else
d600 2
@


1.24
log
@Add a few more easy sun9i-a80 clocks.
@
text
@d1 1
a1 1
/*	$OpenBSD: sxiccmu.c,v 1.23 2016/11/08 19:44:42 kettenis Exp $	*/
d288 4
@


1.23
log
@Add support for "allwinner,sun9i-a80-mmc-clk" compatible clocks.
@
text
@d1 1
a1 1
/*	$OpenBSD: sxiccmu.c,v 1.22 2016/11/08 19:25:44 kettenis Exp $	*/
d286 30
@


1.22
log
@Add support for sun9i-a80, the Allwinner A80.
@
text
@d1 1
a1 1
/*	$OpenBSD: sxiccmu.c,v 1.21 2016/10/09 11:14:22 kettenis Exp $	*/
d288 5
@


1.21
log
@Attach sxiccmu(4) using the fdt.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sxiccmu.c,v 1.20 2016/10/07 18:52:36 patrick Exp $	*/
d98 2
a99 1
		    OF_is_compatible(node, "allwinner,sun8i-h3"));
@


1.20
log
@Fixup comment by removing a word.

"free commit" kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sxiccmu.c,v 1.19 2016/09/10 23:09:03 kettenis Exp $	*/
d31 1
a33 1
#include <armv7/armv7/armv7var.h>
d38 1
d68 1
d72 1
a72 1
	sizeof (struct sxiccmu_softc), NULL, sxiccmu_attach
d86 18
d105 1
a105 1
sxiccmu_attach(struct device *parent, struct device *self, void *args)
d108 2
a109 4
	struct armv7_attach_args *aa = args;
	int node;

	sc->sc_iot = aa->aa_iot;
d111 4
a114 7
	if (bus_space_map(sc->sc_iot, aa->aa_dev->mem[0].addr,
	    aa->aa_dev->mem[0].size, 0, &sc->sc_ioh))
		panic("sxiccmu_attach: bus_space_map failed!");

	node = OF_finddevice("/clocks");
	if (node == -1)
		panic("%s: can't find clocks", __func__);
a117 7
	for (node = OF_child(node); node; node = OF_peer(node))
		sxiccmu_attach_clock(sc, node);

	node = OF_finddevice("/soc/clock@@01c20000");
	if (node == -1)
		return;

d119 1
d124 3
d128 1
a128 1
		
@


1.19
log
@Use PLL6 as a parent clock for the SDx clocks for frequencies > 400 kHz.
This makes sximmc(4) much faster since we can actually provide the appropriate
clock rates for the modern SD cards.  This uncovered a bug in the code that
calculated the PLL6 output frequencies, which this commit also fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: sxiccmu.c,v 1.18 2016/08/28 20:17:10 kettenis Exp $	*/
d321 1
a321 1
 * parent clock.  Useful for clock gating devices that don't scale the
@


1.18
log
@Add a few missing sunxi-h3 clocks and resets.
@
text
@d1 1
a1 1
/*	$OpenBSD: sxiccmu.c,v 1.17 2016/08/27 16:41:52 kettenis Exp $	*/
d371 1
a371 1
		return (freq * n * k) / m / 2;		/* pll6_other */
d373 1
a373 1
		return (freq * n * k) / m;		/* pll6 */
d375 1
a375 1
		return (freq * n * k) / m / 4;		/* pll6_div_4 */
d471 2
d480 1
d485 1
a485 1
		/* XXX OSC24M */
d487 6
d500 1
a500 1
	reg |= CCU_SDx_CLK_SRC_SEL_OSC24M;
@


1.17
log
@Add support for the SD/MMC clock to the geberic clock code and use it in
sximmc(4).
@
text
@d1 1
a1 1
/*	$OpenBSD: sxiccmu.c,v 1.16 2016/08/27 11:39:59 kettenis Exp $	*/
d246 4
@


1.16
log
@Add support for sun8i-h3, the Allwinner H3.  For this SoC, the device tree
contains a single clock control unit node that handles most clocks.  The
driver handles this through tables that describe the gating, reset signals
and the clock hierarchy.  This description is (deliberately) incomplete.  We
will add clocks on an as-needed basis.  You will need a recent device tree,
that includes a "allwinner,sun8i-h3-ccu" compatible node for things to work.

ok patrick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sxiccmu.c,v 1.15 2016/08/26 08:30:24 mglocker Exp $	*/
a34 1
#include <armv7/sunxi/sxiccmuvar.h>
a44 11
#define CCMU_SDx_CLK(x)			(0x88 + (x) * 4)
#define CCMU_SDx_CLK_GATING		(1U << 31)
#define CCMU_SDx_CLK_SRC_GATING_OSC24M	(0 << 24)
#define CCMU_SDx_CLK_SRC_GATING_PLL6	(1 << 24)
#define CCMU_SDx_CLK_SRC_GATING_PLL5	(2 << 24)
#define CCMU_SDx_CLK_SRC_GATING_MASK	(3 << 24)
#define CCMU_SDx_CLK_FACTOR_N		(3 << 16)
#define CCMU_SDx_CLK_FACTOR_N_SHIFT	16
#define CCMU_SDx_CLK_FACTOR_M		(7 << 0)
#define CCMU_SDx_CLK_FACTOR_M_SHIFT	0

d163 2
d198 5
d452 59
d567 15
d583 1
a583 1
	return 0;
a625 30
}


void
sxiccmu_set_sd_clock(int mod, int freq)
{
	struct sxiccmu_softc *sc = sxiccmu_cd.cd_devs[0];
	uint32_t clk;
	int m, n;

	if (freq <= 400000) {
		n = 2;
		if (freq > 0)
			m = ((24000000 / (1 << n)) / freq) - 1;
		else
			m = 15;
	} else {
		n = 0;
		m = 0;
	}
	
	clk = SXIREAD4(sc, CCMU_SDx_CLK(mod - CCMU_SDMMC0));
	clk &= ~CCMU_SDx_CLK_SRC_GATING_MASK;
	clk |= CCMU_SDx_CLK_SRC_GATING_OSC24M;
	clk &= ~CCMU_SDx_CLK_FACTOR_N;
	clk |= n << CCMU_SDx_CLK_FACTOR_N_SHIFT;
	clk &= ~CCMU_SDx_CLK_FACTOR_M;
	clk |= m << CCMU_SDx_CLK_FACTOR_M_SHIFT;
	clk |= CCMU_SDx_CLK_GATING;
	SXIWRITE4(sc, CCMU_SDx_CLK(mod - CCMU_SDMMC0), clk);
@


1.15
log
@Remove unused prototype for sxiccmu_enablemodule().

ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: sxiccmu.c,v 1.14 2016/08/23 19:13:37 kettenis Exp $	*/
d5 1
d57 8
d69 8
d91 5
d117 27
d146 6
d250 4
d272 5
d482 77
@


1.14
log
@Add support for the usb clock on sun5i-a13 as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: sxiccmu.c,v 1.13 2016/08/22 19:43:49 kettenis Exp $	*/
a62 1
void	sxiccmu_enablemodule(int);
@


1.13
log
@Remove unused code and definitions.
@
text
@d1 1
a1 1
/*	$OpenBSD: sxiccmu.c,v 1.12 2016/08/22 19:29:32 kettenis Exp $	*/
d188 6
@


1.12
log
@Add support for the gmac clock.
@
text
@d1 1
a1 1
/*	$OpenBSD: sxiccmu.c,v 1.11 2016/08/22 18:18:35 kettenis Exp $	*/
a44 57
#define	CCMU_SCLK_GATING		(1U << 31)
#define	CCMU_GET_CLK_DIV_RATIO_N(x)	(((x) >> 16) & 0x03)
#define	CCMU_GET_CLK_DIV_RATIO_M(x)	((x) & 0x07)

#define	CCMU_PLL6_CFG			0x28
#define	CCMU_PLL6_EN			(1U << 31)
#define	CCMU_PLL6_BYPASS_EN		(1 << 30)
#define	CCMU_PLL6_SATA_CLK_EN		(1 << 14)
#define	CCMU_PLL6_FACTOR_N		(31 << 8)
#define	CCMU_PLL6_FACTOR_K		(3 << 4)
#define	CCMU_PLL6_FACTOR_M		(3 << 0)

#define	CCMU_AHB_GATING0		0x60
#define	CCMU_AHB_GATING_USB0		(1 << 0)
#define	CCMU_AHB_GATING_EHCI0		(1 << 1)
#define	CCMU_AHB_GATING_OHCI0		(1 << 2)
#define	CCMU_AHB_GATING_EHCI1		(1 << 3)
#define	CCMU_AHB_GATING_OHCI1		(1 << 4)
#define	CCMU_AHB_GATING_SS		(1 << 5)
#define	CCMU_AHB_GATING_DMA		(1 << 6)
#define	CCMU_AHB_GATING_BIST		(1 << 7)
#define	CCMU_AHB_GATING_SDMMCx(x)	(1 << (8 + (x)))
#define	CCMU_AHB_GATING_NAND		(1 << 13)
#define	CCMU_AHB_GATING_EMAC		(1 << 17)
#define	CCMU_AHB_GATING_SATA		(1 << 25)

#define	CCMU_AHB_GATING1		0x64
#define	CCMU_AHB_GATING_MALI400		(1 << 20)
#define	CCMU_AHB_GATING_MP		(1 << 18)
#define	CCMU_AHB_GATING_GMAC		(1 << 17)
#define	CCMU_AHB_GATING_DE_FE1		(1 << 15)
#define	CCMU_AHB_GATING_DE_FE0		(1 << 14)
#define	CCMU_AHB_GATING_DE_BE1		(1 << 13)
#define	CCMU_AHB_GATING_DE_BE0		(1 << 12)
#define	CCMU_AHB_GATING_HDMI		(1 << 11)
#define	CCMU_AHB_GATING_CSI1		(1 << 9)
#define	CCMU_AHB_GATING_CSI0		(1 << 8)
#define	CCMU_AHB_GATING_LCD1		(1 << 5)
#define	CCMU_AHB_GATING_LCD0		(1 << 4)
#define	CCMU_AHB_GATING_TVE1		(1 << 3)
#define	CCMU_AHB_GATING_TVE0		(1 << 2)
#define	CCMU_AHB_GATING_TVD		(1 << 1)
#define	CCMU_AHB_GATING_VE		(1 << 0)

#define	CCMU_APB_GATING0		0x68
#define	CCMU_APB_GATING_PIO		(1 << 5)
#define	CCMU_APB_GATING1		0x6c
#define	CCMU_APB_GATING_UARTx(x)	(1 << (16 + (x)))
#define	CCMU_APB_GATING_TWIx(x)		(1 << (x))
#define	CCMU_APB_GATING_TWI4		(1 << 15)

#define	CCMU_NAND_CLK			0x80
#define	CCMU_NAND_CLK_SRC_GATING_OSC24M	(0 << 24)
#define	CCMU_NAND_CLK_SRC_GATING_PLL6	(1 << 24)
#define	CCMU_NAND_CLK_SRC_GATING_PLL5	(2 << 24)
#define	CCMU_NAND_CLK_SRC_GATING_MASK	(3 << 24)

a55 26
#define	CCMU_SATA_CLK			0xc8
#define	CCMU_SATA_CLK_SRC_GATING	(1 << 24)

#define	CCMU_USB_CLK			0xcc
#define	CCMU_USB_PHY			(1 << 8)
#define	CCMU_SCLK_GATING_OHCI1		(1 << 7)
#define	CCMU_SCLK_GATING_OHCI0		(1 << 6)
#define	CCMU_OHCI_CLK_SRC		(1 << 4)
#define	CCMU_USB2_RESET			(1 << 2)
#define	CCMU_USB1_RESET			(1 << 1)
#define	CCMU_USB0_RESET			(1 << 0)

#define	CCMU_GMAC_CLK_REG		0x164
#define	CCMU_GMAC_CLK_TXC_DIV		(0x3 << 8)
#define	CCMU_GMAC_CLK_TXC_DIV_1000	0
#define	CCMU_GMAC_CLK_TXC_DIV_100	1
#define	CCMU_GMAC_CLK_TXC_DIV_10	2
#define	CCMU_GMAC_CLK_RXDC		(0x7 << 5)
#define	CCMU_GMAC_CLK_RXIE		(1 << 4)
#define	CCMU_GMAC_CLK_TXIE		(1 << 3)
#define	CCMU_GMAC_CLK_PIT		(1 << 2)
#define	CCMU_GMAC_CLK_TCS		(0x3 << 0)
#define	CCMU_GMAC_CLK_TCS_MII		0
#define	CCMU_GMAC_CLK_TCS_EXT_125	1
#define	CCMU_GMAC_CLK_TCS_INT_RGMII	2

a411 169
}

/* XXX spl? */
void
sxiccmu_enablemodule(int mod)
{
	struct sxiccmu_softc *sc = sxiccmu_cd.cd_devs[0];
	uint32_t reg;

	DPRINTF(("\nsxiccmu_enablemodule: mod %d\n", mod));

	/* XXX reorder? */
	switch (mod) {
	case CCMU_EHCI0:
		SXISET4(sc, CCMU_AHB_GATING0, CCMU_AHB_GATING_EHCI0);
		SXISET4(sc, CCMU_USB_CLK, CCMU_USB1_RESET | CCMU_USB_PHY);
		break;
	case CCMU_EHCI1:
		SXISET4(sc, CCMU_AHB_GATING0, CCMU_AHB_GATING_EHCI1);
		SXISET4(sc, CCMU_USB_CLK, CCMU_USB2_RESET | CCMU_USB_PHY);
		break;
	case CCMU_OHCI0:
		SXISET4(sc, CCMU_USB_CLK, CCMU_OHCI_CLK_SRC);
		SXISET4(sc, CCMU_AHB_GATING0, CCMU_AHB_GATING_OHCI0);
		SXISET4(sc, CCMU_USB_CLK, CCMU_SCLK_GATING_OHCI0);
		break;
	case CCMU_OHCI1:
		SXISET4(sc, CCMU_USB_CLK, CCMU_OHCI_CLK_SRC);
		SXISET4(sc, CCMU_AHB_GATING0, CCMU_AHB_GATING_OHCI1);
		SXISET4(sc, CCMU_USB_CLK, CCMU_SCLK_GATING_OHCI1);
		break;
	case CCMU_AHCI:
		reg = SXIREAD4(sc, CCMU_PLL6_CFG);
		reg &= ~(CCMU_PLL6_BYPASS_EN | CCMU_PLL6_FACTOR_M |
		    CCMU_PLL6_FACTOR_N);
		reg |= CCMU_PLL6_EN | CCMU_PLL6_SATA_CLK_EN;
		reg |= 25 << 8;
		reg |= (reg >> 4 & 3);
		SXIWRITE4(sc, CCMU_PLL6_CFG, reg);

		SXISET4(sc, CCMU_AHB_GATING0, CCMU_AHB_GATING_SATA);
		delay(1000);

		SXIWRITE4(sc, CCMU_SATA_CLK, CCMU_SCLK_GATING);
		break;
	case CCMU_EMAC:
		SXISET4(sc, CCMU_AHB_GATING0, CCMU_AHB_GATING_EMAC);
		break;
	case CCMU_GMAC_MII:
		SXISET4(sc, CCMU_AHB_GATING1, CCMU_AHB_GATING_GMAC);
		SXICMS4(sc, CCMU_GMAC_CLK_REG,
		    CCMU_GMAC_CLK_PIT|CCMU_GMAC_CLK_TCS,
		    CCMU_GMAC_CLK_TCS_MII);
		break;
	case CCMU_GMAC_RGMII:
		SXISET4(sc, CCMU_AHB_GATING1, CCMU_AHB_GATING_GMAC);
		SXICMS4(sc, CCMU_GMAC_CLK_REG,
		    CCMU_GMAC_CLK_PIT|CCMU_GMAC_CLK_TCS,
		    CCMU_GMAC_CLK_PIT|CCMU_GMAC_CLK_TCS_INT_RGMII);
		break;
	case CCMU_DMA:
		SXISET4(sc, CCMU_AHB_GATING0, CCMU_AHB_GATING_DMA);
		break;
	case CCMU_UART0:
	case CCMU_UART1:
	case CCMU_UART2:
	case CCMU_UART3:
	case CCMU_UART4:
	case CCMU_UART5:
	case CCMU_UART6:
	case CCMU_UART7:
		SXISET4(sc, CCMU_APB_GATING1,
		    CCMU_APB_GATING_UARTx(mod - CCMU_UART0));
		break;
	case CCMU_SDMMC0:
	case CCMU_SDMMC1:
	case CCMU_SDMMC2:
	case CCMU_SDMMC3:
		SXISET4(sc, CCMU_AHB_GATING0,
		    CCMU_AHB_GATING_SDMMCx(mod - CCMU_SDMMC0));
		break;
	case CCMU_TWI0:
	case CCMU_TWI1:
	case CCMU_TWI2:
	case CCMU_TWI3:
	case CCMU_TWI4:
		SXISET4(sc, CCMU_APB_GATING1, mod == CCMU_TWI4
		    ? CCMU_APB_GATING_TWI4
		    : CCMU_APB_GATING_TWIx(mod - CCMU_TWI0));
		break;
	case CCMU_PIO:
		SXISET4(sc, CCMU_APB_GATING0, CCMU_APB_GATING_PIO);
		break;
	default:
		break;
	}
}

void
sxiccmu_disablemodule(int mod)
{
	struct sxiccmu_softc *sc = sxiccmu_cd.cd_devs[0];

	DPRINTF(("\nsxiccmu_disablemodule: mod %d\n", mod));

	switch (mod) {
	case CCMU_EHCI0:
		SXICLR4(sc, CCMU_AHB_GATING0, CCMU_AHB_GATING_EHCI0);
		SXICLR4(sc, CCMU_USB_CLK, CCMU_USB1_RESET | CCMU_USB_PHY);
		break;
	case CCMU_EHCI1:
		SXICLR4(sc, CCMU_AHB_GATING0, CCMU_AHB_GATING_EHCI1);
		SXICLR4(sc, CCMU_USB_CLK, CCMU_USB2_RESET | CCMU_USB_PHY);
		break;
	case CCMU_OHCI0:
		SXICLR4(sc, CCMU_AHB_GATING0, CCMU_AHB_GATING_OHCI0);
		SXICLR4(sc, CCMU_USB_CLK, CCMU_SCLK_GATING_OHCI0);
	case CCMU_OHCI1:
		SXICLR4(sc, CCMU_AHB_GATING0, CCMU_AHB_GATING_OHCI1);
		SXICLR4(sc, CCMU_USB_CLK, CCMU_SCLK_GATING_OHCI1);
		break;
	case CCMU_AHCI:
		/* XXX possibly wrong */
		SXICLR4(sc, CCMU_AHB_GATING0, CCMU_AHB_GATING_SATA);
		SXIWRITE4(sc, CCMU_SATA_CLK, 0);
		break;
	case CCMU_EMAC:
		SXICLR4(sc, CCMU_AHB_GATING0, CCMU_AHB_GATING_EMAC);
		break;
	case CCMU_GMAC_MII:
	case CCMU_GMAC_RGMII:
		SXICLR4(sc, CCMU_AHB_GATING1, CCMU_AHB_GATING_GMAC);
		break;
	case CCMU_DMA:
		SXICLR4(sc, CCMU_AHB_GATING0, CCMU_AHB_GATING_DMA);
		break;
	case CCMU_UART0:
	case CCMU_UART1:
	case CCMU_UART2:
	case CCMU_UART3:
	case CCMU_UART4:
	case CCMU_UART5:
	case CCMU_UART6:
	case CCMU_UART7:
		SXICLR4(sc, CCMU_APB_GATING1,
		    CCMU_APB_GATING_UARTx(mod - CCMU_UART0));
		break;
	case CCMU_SDMMC0:
	case CCMU_SDMMC1:
	case CCMU_SDMMC2:
	case CCMU_SDMMC3:
		SXICLR4(sc, CCMU_AHB_GATING0,
		    CCMU_AHB_GATING_SDMMCx(mod - CCMU_SDMMC0));
		break;
	case CCMU_TWI0:
	case CCMU_TWI1:
	case CCMU_TWI2:
	case CCMU_TWI3:
	case CCMU_TWI4:
		SXICLR4(sc, CCMU_APB_GATING1, mod == CCMU_TWI4
		    ? CCMU_APB_GATING_TWI4
		    : CCMU_APB_GATING_TWIx(mod - CCMU_TWI0));
		break;
	case CCMU_PIO:
		SXICLR4(sc, CCMU_APB_GATING0, CCMU_APB_GATING_PIO);
		break;
	default:
		break;
	}
@


1.11
log
@Add support for the usb clock.  Also implements reset signal support.
@
text
@d1 1
a1 1
/*	$OpenBSD: sxiccmu.c,v 1.10 2016/08/22 06:48:38 kettenis Exp $	*/
d193 1
d203 1
d287 4
d322 1
d442 27
@


1.10
log
@Add code to enable the pll6 clock.
@
text
@d1 1
a1 1
/*	$OpenBSD: sxiccmu.c,v 1.9 2016/08/21 23:01:57 kettenis Exp $	*/
d182 1
a182 1
	struct clock_device sc_cd;
d185 3
a187 1
	int sc_node;
d194 1
d203 1
d235 6
d318 7
d448 13
@


1.9
log
@Add support for all the ahb, apb0 and apb1 clock gating devices on sun4i,
sun5i and sun7i.
@
text
@d1 1
a1 1
/*	$OpenBSD: sxiccmu.c,v 1.8 2016/08/21 21:39:59 kettenis Exp $	*/
d197 1
a198 1

d209 1
d331 3
d335 2
d338 2
d341 2
d370 28
@


1.8
log
@Implement some fundamental clocks using the new clock framework.

ok patrick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sxiccmu.c,v 1.7 2016/08/20 19:34:44 kettenis Exp $	*/
d213 55
@


1.7
log
@Add some code to set the SD/MMC clocks.
@
text
@d1 1
a1 1
/*	$OpenBSD: sxiccmu.c,v 1.6 2016/08/13 21:48:44 kettenis Exp $	*/
d23 1
d36 3
d156 2
d163 1
d171 4
d176 162
@


1.6
log
@Add GMAC clock support.  Based on an earlier diff from patrick@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: sxiccmu.c,v 1.5 2013/11/26 20:33:12 deraadt Exp $	*/
d98 11
d334 29
@


1.5
log
@1 << 31 cleanup.  Eitan Adler pointed out that there has been a
resurrection of the bad idiom in the tree.
sufficient review by miod, kettenis, tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: sxiccmu.c,v 1.4 2013/11/06 19:03:07 syl Exp $	*/
d67 18
d110 14
d202 12
d282 4
@


1.4
log
@After factorizing armv7_machdep code here is an effort to factorize all
the code present in omap/omap.c imx/imx.c and sunxi/sunxi.c

All this code looks quite the same, so we move it in a generic armv7/armv7.c

This is a step closer to only one kernel for all armv7 boards.

ok patrick@@, rapha@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sxiccmu.c,v 1.3 2013/11/01 21:15:05 aalm Exp $	*/
d41 1
a41 1
#define	CCMU_SCLK_GATING		(1 << 31)
d46 1
a46 1
#define	CCMU_PLL6_EN			(1 << 31)
@


1.3
log
@adds a few modules used by upcoming drivers, and support for disabling
modules.

ok jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sxiccmu.c,v 1.2 2013/10/23 18:01:52 jasper Exp $	*/
d31 2
a32 1
#include <armv7/sunxi/sunxivar.h>
d113 1
a113 1
	struct sxi_attach_args *sxi = args;
d115 1
a115 1
	sc->sc_iot = sxi->sxi_iot;
d117 2
a118 2
	if (bus_space_map(sc->sc_iot, sxi->sxi_dev->mem[0].addr,
	    sxi->sxi_dev->mem[0].size, 0, &sc->sc_ioh))
@


1.2
log
@rename some defines as well
@
text
@d1 1
a1 1
/*	$OpenBSD: sxiccmu.c,v 1.1 2013/10/23 17:08:48 jasper Exp $	*/
d61 1
a61 4
#define	CCMU_AHB_GATING_SDMMC0		(1 << 8)
#define	CCMU_AHB_GATING_SDMMC1		(1 << 9)
#define	CCMU_AHB_GATING_SDMMC2		(1 << 10)
#define	CCMU_AHB_GATING_SDMMC3		(1 << 11)
d71 1
d86 1
d132 1
d142 9
a150 2
	case CCMU_OHCI:
		panic("sxiccmu_enablemodule: XXX OHCI!");
d180 90
a269 1
		SXISET4(sc, CCMU_APB_GATING1, CCMU_APB_GATING_UARTx(mod - CCMU_UART0));
@


1.1
log
@rename 'allwinner' to 'sunxi' to actually match the SoC name instead of using
the vendor to follow our naming convention.

ok aalm@@ patrick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sxiccmu.c,v 1.1 2013/10/22 13:22:19 jasper Exp $	*/
d135 2
a136 2
		AWSET4(sc, CCMU_AHB_GATING0, CCMU_AHB_GATING_EHCI0);
		AWSET4(sc, CCMU_USB_CLK, CCMU_USB1_RESET | CCMU_USB_PHY);
d139 2
a140 2
		AWSET4(sc, CCMU_AHB_GATING0, CCMU_AHB_GATING_EHCI1);
		AWSET4(sc, CCMU_USB_CLK, CCMU_USB2_RESET | CCMU_USB_PHY);
d146 1
a146 1
		reg = AWREAD4(sc, CCMU_PLL6_CFG);
d152 1
a152 1
		AWWRITE4(sc, CCMU_PLL6_CFG, reg);
d154 1
a154 1
		AWSET4(sc, CCMU_AHB_GATING0, CCMU_AHB_GATING_SATA);
d157 1
a157 1
		AWWRITE4(sc, CCMU_SATA_CLK, CCMU_SCLK_GATING);
d160 1
a160 1
		AWSET4(sc, CCMU_AHB_GATING0, CCMU_AHB_GATING_EMAC);
d163 1
a163 1
		AWSET4(sc, CCMU_AHB_GATING0, CCMU_AHB_GATING_DMA);
d173 1
a173 1
		AWSET4(sc, CCMU_APB_GATING1, CCMU_APB_GATING_UARTx(mod - CCMU_UART0));
@

