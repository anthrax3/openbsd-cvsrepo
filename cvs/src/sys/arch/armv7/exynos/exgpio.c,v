head	1.6;
access;
symbols
	OPENBSD_6_0:1.3.0.2
	OPENBSD_6_0_BASE:1.3
	OPENBSD_5_9:1.2.0.2
	OPENBSD_5_9_BASE:1.2
	OPENBSD_5_8:1.2.0.4
	OPENBSD_5_8_BASE:1.2
	OPENBSD_5_7:1.1.0.2
	OPENBSD_5_7_BASE:1.1;
locks; strict;
comment	@ * @;


1.6
date	2017.03.11.17.06.27;	author kettenis;	state Exp;
branches;
next	1.5;
commitid	SjddWWzvFeCA1z6J;

1.5
date	2017.03.05.20.53.19;	author kettenis;	state Exp;
branches;
next	1.4;
commitid	NkmnZmNzQt5qa35Q;

1.4
date	2016.07.26.22.10.10;	author patrick;	state Exp;
branches;
next	1.3;
commitid	QHTy0YAECnrTlcSQ;

1.3
date	2016.04.24.00.57.23;	author patrick;	state Exp;
branches;
next	1.2;
commitid	LnsUZ9pocLJscsAz;

1.2
date	2015.05.27.00.06.14;	author jsg;	state Exp;
branches;
next	1.1;
commitid	G6QP18Ap4gF8hOTp;

1.1
date	2015.01.26.02.48.24;	author bmercer;	state Exp;
branches;
next	;
commitid	PStGWtijE9UAf7Yd;


desc
@@


1.6
log
@Hook up exgpio(4) to the gpio framework.
@
text
@/* $OpenBSD: exgpio.c,v 1.5 2017/03/05 20:53:19 kettenis Exp $ */
/*
 * Copyright (c) 2007,2009 Dale Rahn <drahn@@openbsd.org>
 * Copyright (c) 2012-2013 Patrick Wildt <patrick@@blueri.se>
 * Copyright (c) 2017 Mark Kettenis <kettenis@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/malloc.h>

#include <machine/bus.h>
#include <machine/fdt.h>
#include <machine/intr.h>

#include <dev/ofw/openfirm.h>
#include <dev/ofw/ofw_gpio.h>
#include <dev/ofw/ofw_pinctrl.h>
#include <dev/ofw/fdt.h>

#define GPXCON(x)	((x) + 0x0000)
#define  GPXCON_INPUT	0
#define  GPXCON_OUTPUT	1
#define GPXDAT(x)	((x) + 0x0004)
#define GPXPUD(x)	((x) + 0x0008)
#define GPXDRV(x)	((x) + 0x000c)

#define GPX_NUM_PINS	8

#define HREAD4(sc, reg)							\
	(bus_space_read_4((sc)->sc_iot, (sc)->sc_ioh, (reg)))
#define HWRITE4(sc, reg, val)						\
	bus_space_write_4((sc)->sc_iot, (sc)->sc_ioh, (reg), (val))

struct exgpio_bank {
	const char name[8];
	bus_addr_t addr;
};

struct exgpio_controller {
	struct gpio_controller ec_gc;
	struct exgpio_bank *ec_bank;
	struct exgpio_softc *ec_sc;
};

struct exgpio_softc {
	struct device		sc_dev;
	bus_space_tag_t		sc_iot;
	bus_space_handle_t	sc_ioh;

	struct exgpio_bank	*sc_banks;
	int			sc_nbanks;
};

int exgpio_match(struct device *, void *, void *);
void exgpio_attach(struct device *, struct device *, void *);

struct cfattach	exgpio_ca = {
	sizeof (struct exgpio_softc), exgpio_match, exgpio_attach
};

struct cfdriver exgpio_cd = {
	NULL, "exgpio", DV_DULL
};

/* Exynos 5420/5422 */
struct exgpio_bank exynos5420_banks[] = {
	/* Controller 0 */
	{ "gpy7", 0x0000 },
	{ "gpx0", 0x0c00 },
	{ "gpx1", 0x0c20 },
	{ "gpx2", 0x0c40 },
	{ "gpx3", 0x0c60 },

	/* Controller 1 */
	{ "gpc0", 0x0000 },
	{ "gpc1", 0x0020 },
	{ "gpc2", 0x0040 },
	{ "gpc3", 0x0060 },
	{ "gpc4", 0x0080 },
	{ "gpd1", 0x00a0 },
	{ "gpy0", 0x00c0 },
	{ "gpy1", 0x00e0 },
	{ "gpy2", 0x0100 },
	{ "gpy3", 0x0120 },
	{ "gpy4", 0x0140 },
	{ "gpy5", 0x0160 },
	{ "gpy6", 0x0180 },

	/* Controller 2 */
	{ "gpe0", 0x0000 },
	{ "gpe1", 0x0020 },
	{ "gpf0", 0x0040 },
	{ "gpf1", 0x0060 },
	{ "gpg0", 0x0080 },
	{ "gpg1", 0x00a0 },
	{ "gpg2", 0x00c0 },
	{ "gpj4", 0x00e0 },

	/* Controller 3 */
	{ "gpa0", 0x0000 },
	{ "gpa1", 0x0020 },
	{ "gpa2", 0x0040 },
	{ "gpb0", 0x0060 },
	{ "gpb1", 0x0080 },
	{ "gpb2", 0x00a0 },
	{ "gpb3", 0x00c0 },
	{ "gpb4", 0x00e0 },
	{ "gph0", 0x0100 },

	/* Controller 4 */
	{ "gpz", 0x0000 },
};

struct exgpio_bank *exgpio_bank(struct exgpio_softc *, const char *);
int	exgpio_pinctrl(uint32_t, void *);
void	exgpio_config_pin(void *, uint32_t *, int);
int	exgpio_get_pin(void *, uint32_t *);
void	exgpio_set_pin(void *, uint32_t *, int);

int
exgpio_match(struct device *parent, void *match, void *aux)
{
	struct fdt_attach_args *faa = aux;

	return OF_is_compatible(faa->fa_node, "samsung,exynos5420-pinctrl");
}

void
exgpio_attach(struct device *parent, struct device *self, void *aux)
{
	struct exgpio_softc *sc = (struct exgpio_softc *)self;
	struct fdt_attach_args *faa = aux;
	struct exgpio_controller *ec;
	struct exgpio_bank *bank;
	char name[8];
	int node;
	int len;

	sc->sc_iot = faa->fa_iot;

	if (bus_space_map(sc->sc_iot, faa->fa_reg[0].addr,
	    faa->fa_reg[0].size, 0, &sc->sc_ioh))
		panic("%s: bus_space_map failed!", __func__);

	if (OF_is_compatible(faa->fa_node, "samsung,exynos5420-pinctrl")) {
		sc->sc_banks = exynos5420_banks;
		sc->sc_nbanks = nitems(exynos5420_banks);
	}

	KASSERT(sc->sc_banks);
	pinctrl_register(faa->fa_node, exgpio_pinctrl, sc);

	for (node = OF_child(faa->fa_node); node; node = OF_peer(node)) {
		if (OF_getproplen(node, "gpio-controller") < 0)
			continue;

		len = OF_getprop(node, "name", &name, sizeof(name));
		if (len <= 0 || len >= sizeof(name))
			continue;

		bank = exgpio_bank(sc, name);
		if (bank == NULL)
			continue;

		ec = malloc(sizeof(*ec), M_DEVBUF, M_WAITOK);
		ec->ec_bank = exgpio_bank(sc, name);
		ec->ec_sc = sc;
		ec->ec_gc.gc_node = node;
		ec->ec_gc.gc_cookie = ec;
		ec->ec_gc.gc_config_pin = exgpio_config_pin;
		ec->ec_gc.gc_get_pin = exgpio_get_pin;
		ec->ec_gc.gc_set_pin = exgpio_set_pin;
		gpio_controller_register(&ec->ec_gc);
	}

	printf("\n");
}

struct exgpio_bank *
exgpio_bank(struct exgpio_softc *sc, const char *name)
{
	int i;

	for (i = 0; i < sc->sc_nbanks; i++) {
		if (strcmp(name, sc->sc_banks[i].name) == 0)
			return &sc->sc_banks[i];
	}

	return NULL;
}

int
exgpio_pinctrl(uint32_t phandle, void *cookie)
{
	struct exgpio_softc *sc = cookie;
	char *pins, *bank_name, *pin_name;
	struct exgpio_bank *bank;
	uint32_t func, val, pud, drv;
	uint32_t reg;
	int node;
	int len;
	int pin;

	node = OF_getnodebyphandle(phandle);
	if (node == 0)
		return -1;

	len = OF_getproplen(node, "samsung,pins");
	if (len <= 0)
		return -1;

	pins = malloc(len, M_TEMP, M_WAITOK);
	OF_getprop(node, "samsung,pins", pins, len);

	func = OF_getpropint(node, "samsung,pin-function", 0);
	val = OF_getpropint(node, "samsung,pin-val", 0);
	pud = OF_getpropint(node, "samsung,pin-pud", 1);
	drv = OF_getpropint(node, "samsung,pin-drv", 0);

	bank_name = pins;
	while (bank_name < pins + len) {
		pin_name = strchr(bank_name, '-');
		if (pin_name == NULL)
			goto fail;
		*pin_name++ = 0;
		pin = *pin_name - '0';
		if (pin < 0 || pin >= GPX_NUM_PINS)
			goto fail;

		bank = exgpio_bank(sc, bank_name);
		if (bank == NULL)
			goto fail;

		reg = HREAD4(sc, GPXCON(bank->addr));
		reg &= ~(0xf << (pin * 4));
		reg |= (func << (pin * 4));
		HWRITE4(sc, GPXCON(bank->addr), reg);

		reg = HREAD4(sc, GPXDAT(bank->addr));
		if (val)
			reg |= (1 << pin);
		else
			reg &= ~(1 << pin);
		HWRITE4(sc, GPXDAT(bank->addr), reg);

		reg = HREAD4(sc, GPXPUD(bank->addr));
		reg &= ~(0x3 << (pin * 2));
		reg |= (pud << (pin * 2));
		HWRITE4(sc, GPXPUD(bank->addr), reg);

		reg = HREAD4(sc, GPXDRV(bank->addr));
		reg &= ~(0x3 << (pin * 2));
		reg |= (drv << (pin * 2));
		HWRITE4(sc, GPXDRV(bank->addr), reg);

		bank_name = pin_name + 2;
	}

	free(pins, M_TEMP, len);
	return 0;

fail:
	free(pins, M_TEMP, len);
	return -1;
}

void
exgpio_config_pin(void *cookie, uint32_t *cells, int config)
{
	struct exgpio_controller *ec = cookie;
	uint32_t pin = cells[0];
	uint32_t val;
	int func;

	if (pin >= GPX_NUM_PINS)
		return;

	func = (config & GPIO_CONFIG_OUTPUT) ? GPXCON_OUTPUT : GPXCON_INPUT;
	val = HREAD4(ec->ec_sc, GPXCON(ec->ec_bank->addr));
	val &= ~(0xf << (pin * 4));
	val |= (func << (pin * 4));
	HWRITE4(ec->ec_sc, GPXCON(ec->ec_bank->addr), val);
}

int
exgpio_get_pin(void *cookie, uint32_t *cells)
{
	struct exgpio_controller *ec = cookie;
	uint32_t pin = cells[0];
	uint32_t flags = cells[1];
	uint32_t reg;
	int val;

	if (pin >= GPX_NUM_PINS)
		return 0;

	reg = HREAD4(ec->ec_sc, GPXDAT(ec->ec_bank->addr));
	reg &= (1 << pin);
	val = (reg >> pin) & 1;
	if (flags & GPIO_ACTIVE_LOW)
		val = !val;
	return val;
}

void
exgpio_set_pin(void *cookie, uint32_t *cells, int val)
{
	struct exgpio_controller *ec = cookie;
	uint32_t pin = cells[0];
	uint32_t flags = cells[1];
	uint32_t reg;

	if (pin >= GPX_NUM_PINS)
		return;

	reg = HREAD4(ec->ec_sc, GPXDAT(ec->ec_bank->addr));
	if (flags & GPIO_ACTIVE_LOW)
		val = !val;
	if (val)
		reg |= (1 << pin);
	else
		reg &= ~(1 << pin);
	HWRITE4(ec->ec_sc, GPXDAT(ec->ec_bank->addr), reg);
}
@


1.5
log
@Turn exgpio(4) into a pinctrl driver.
@
text
@d1 1
a1 1
/* $OpenBSD: exgpio.c,v 1.4 2016/07/26 22:10:10 patrick Exp $ */
d30 1
d35 2
d41 2
d53 6
d128 5
a132 1
int exgpio_pinctrl(uint32_t, void *);
d147 5
d164 1
d166 24
d193 13
d210 2
a211 2
	char *pins;
	char *bank, *next;
a216 1
	int i;
d234 35
a268 40
	bank = pins;
	while (bank < pins + len) {
		next = strchr(bank, '-');
		if (next == NULL)
			return -1;
		*next++ = 0;
		pin = *next++ - '0';
		if (pin < 0 || pin > 7)
			return -1;
		next++;

		for (i = 0; i < sc->sc_nbanks; i++) {
			if (strcmp(bank, sc->sc_banks[i].name) != 0)
				break;

			reg = HREAD4(sc, GPXCON(sc->sc_banks[i].addr));
			reg &= ~(0xf << (pin * 4));
			reg |= (func << (pin * 4));
			HWRITE4(sc, GPXCON(sc->sc_banks[i].addr), reg);

			reg = HREAD4(sc, GPXDAT(sc->sc_banks[i].addr));
			if (val)
				reg |= (1 << pin);
			else
				reg &= ~(1 << pin);
			HWRITE4(sc, GPXDAT(sc->sc_banks[i].addr), reg);

			reg = HREAD4(sc, GPXPUD(sc->sc_banks[i].addr));
			reg &= ~(0x3 << (pin * 2));
			reg |= (pud << (pin * 2));
			HWRITE4(sc, GPXPUD(sc->sc_banks[i].addr), reg);

			reg = HREAD4(sc, GPXDRV(sc->sc_banks[i].addr));
			reg &= ~(0x3 << (pin * 2));
			reg |= (drv << (pin * 2));
			HWRITE4(sc, GPXDRV(sc->sc_banks[i].addr), reg);
			break;
		}
		if (i == sc->sc_nbanks)
			return -1;
d270 1
a270 1
		bank = next;
d275 63
@


1.4
log
@Rename struct fdt_memory to fdt_reg to match the member name
used in the fdt attach args and the device tree.

ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: exgpio.c,v 1.3 2016/04/24 00:57:23 patrick Exp $ */
d5 1
a21 1
#include <sys/queue.h>
a23 3
#include <sys/evcount.h>

#include <arm/cpufunc.h>
a25 1
#if NFDT > 0
a26 1
#endif
d29 18
a46 32
#include <armv7/armv7/armv7var.h>
#include <armv7/exynos/exgpiovar.h>

/* Exynos5 registers */
#define GPIO_BANK_SIZE		0x20
#define GPIO_BANK(x)		(GPIO_BANK_SIZE * ((x) / 8))
#define GPIO_CON(x)		(GPIO_BANK(x) + 0x00)
#define GPIO_DAT(x)		(GPIO_BANK(x) + 0x04)
#define GPIO_PULL(x)		(GPIO_BANK(x) + 0x08)
#define GPIO_DRV(x)		(GPIO_BANK(x) + 0x0c)
#define GPIO_PDN_CON(x)		(GPIO_BANK(x) + 0x10)
#define GPIO_PDN_PULL(x)	(GPIO_BANK(x) + 0x14)

/* bits and bytes */
#define GPIO_PIN(x)		((x) % 8)
#define GPIO_CON_INPUT(x)	(0x0 << (GPIO_PIN(x) << 2))
#define GPIO_CON_OUTPUT(x)	(0x1 << (GPIO_PIN(x) << 2))
#define GPIO_CON_IRQ(x)		(0xf << (GPIO_PIN(x) << 2))
#define GPIO_CON_MASK(x)	(0xf << (GPIO_PIN(x) << 2))
#define GPIO_DAT_SET(x)		(0x1 << (GPIO_PIN(x) << 0))
#define GPIO_DAT_MASK(x)	(0x1 << (GPIO_PIN(x) << 0))
#define GPIO_PULL_NONE(x)	(0x0 << (GPIO_PIN(x) << 1))
#define GPIO_PULL_DOWN(x)	(0x1 << (GPIO_PIN(x) << 1))
#define GPIO_PULL_UP(x)		(0x3 << (GPIO_PIN(x) << 1))
#define GPIO_PULL_MASK(x)	(0x3 << (GPIO_PIN(x) << 1))
#define GPIO_DRV_1X(x)		(0x0 << (GPIO_PIN(x) << 1))
#define GPIO_DRV_2X(x)		(0x1 << (GPIO_PIN(x) << 1))
#define GPIO_DRV_3X(x)		(0x2 << (GPIO_PIN(x) << 1))
#define GPIO_DRV_4X(x)		(0x3 << (GPIO_PIN(x) << 1))
#define GPIO_DRV_MASK(x)	(0x3 << (GPIO_PIN(x) << 1))

#define GPIO_PINS_PER_BANK	8
d52 3
a54 9
	int			sc_ngpio;
	unsigned int (*sc_get_bit)(struct exgpio_softc *sc,
	    unsigned int gpio);
	void (*sc_set_bit)(struct exgpio_softc *sc,
	    unsigned int gpio);
	void (*sc_clear_bit)(struct exgpio_softc *sc,
	    unsigned int gpio);
	void (*sc_set_dir)(struct exgpio_softc *sc,
	    unsigned int gpio, unsigned int dir);
d57 2
a58 11
int exgpio_match(struct device *parent, void *v, void *aux);
void exgpio_attach(struct device *parent, struct device *self, void *args);

struct exgpio_softc *exgpio_pin_to_inst(unsigned int);
unsigned int exgpio_pin_to_offset(unsigned int);
unsigned int exgpio_v5_get_bit(struct exgpio_softc *, unsigned int);
void exgpio_v5_set_bit(struct exgpio_softc *, unsigned int);
void exgpio_v5_clear_bit(struct exgpio_softc *, unsigned int);
void exgpio_v5_set_dir(struct exgpio_softc *, unsigned int, unsigned int);
unsigned int exgpio_v5_get_dir(struct exgpio_softc *, unsigned int);

a60 3
	sizeof (struct exgpio_softc), NULL, exgpio_attach
};
struct cfattach	exgpio_fdt_ca = {
d68 51
d120 1
a120 1
exgpio_match(struct device *parent, void *v, void *aux)
d122 1
a122 6
#if NFDT > 0
	struct armv7_attach_args *aa = aux;

	if (fdt_node_compatible("samsung,exynos5250-pinctrl", aa->aa_node))
		return 1;
#endif
d124 1
a124 1
	return 0;
d128 1
a128 1
exgpio_attach(struct device *parent, struct device *self, void *args)
d130 7
a136 20
	struct armv7_attach_args *aa = args;
	struct exgpio_softc *sc = (struct exgpio_softc *) self;
	struct armv7mem mem;

	sc->sc_iot = aa->aa_iot;
#if NFDT > 0
	if (aa->aa_node) {
		struct fdt_reg reg;
		if (fdt_get_reg(aa->aa_node, 0, &reg))
			panic("%s: could not extract memory data from FDT",
			    __func__);
		mem.addr = reg.addr;
		mem.size = reg.size;
	} else
#endif
	{
		mem.addr = aa->aa_dev->mem[0].addr;
		mem.size = aa->aa_dev->mem[0].size;
	}
	if (bus_space_map(sc->sc_iot, mem.addr, mem.size, 0, &sc->sc_ioh))
d139 4
a142 6
	sc->sc_ngpio = (mem.size / GPIO_BANK_SIZE) * GPIO_PINS_PER_BANK;

	sc->sc_get_bit  = exgpio_v5_get_bit;
	sc->sc_set_bit = exgpio_v5_set_bit;
	sc->sc_clear_bit = exgpio_v5_clear_bit;
	sc->sc_set_dir = exgpio_v5_set_dir;
d144 1
a145 5

	/* XXX - IRQ */
	/* XXX - SYSCONFIG */
	/* XXX - CTRL */
	/* XXX - DEBOUNCE */
d148 2
a149 2
struct exgpio_softc *
exgpio_pin_to_inst(unsigned int gpio)
d151 8
d161 56
a216 16
	for (i = 0; exgpio_cd.cd_devs[i] != NULL; i++)
	{
		struct exgpio_softc *sc = exgpio_cd.cd_devs[i];
		if (gpio < sc->sc_ngpio)
			return sc;
		else
			gpio -= sc->sc_ngpio;
	}

	return NULL;
}

unsigned int
exgpio_pin_to_offset(unsigned int gpio)
{
	int i;
d218 1
a218 7
	for (i = 0; exgpio_cd.cd_devs[i] != NULL; i++)
	{
		struct exgpio_softc *sc = exgpio_cd.cd_devs[i];
		if (gpio < sc->sc_ngpio)
			return gpio;
		else
			gpio -= sc->sc_ngpio;
d221 1
a222 103
}

unsigned int
exgpio_get_bit(unsigned int gpio)
{
	struct exgpio_softc *sc = exgpio_pin_to_inst(gpio);

	return sc->sc_get_bit(sc, gpio);
}

void
exgpio_set_bit(unsigned int gpio)
{
	struct exgpio_softc *sc = exgpio_pin_to_inst(gpio);

	sc->sc_set_bit(sc, gpio);
}

void
exgpio_clear_bit(unsigned int gpio)
{
	struct exgpio_softc *sc = exgpio_pin_to_inst(gpio);

	sc->sc_clear_bit(sc, gpio);
}
void
exgpio_set_dir(unsigned int gpio, unsigned int dir)
{
	struct exgpio_softc *sc = exgpio_pin_to_inst(gpio);

	sc->sc_set_dir(sc, gpio, dir);
}

unsigned int
exgpio_v5_get_bit(struct exgpio_softc *sc, unsigned int gpio)
{
	u_int32_t val;

	gpio = exgpio_pin_to_offset(gpio);
	val = bus_space_read_4(sc->sc_iot, sc->sc_ioh, GPIO_DAT(gpio));

	return !!(val & GPIO_DAT_SET(gpio));
}

void
exgpio_v5_set_bit(struct exgpio_softc *sc, unsigned int gpio)
{
	u_int32_t val;

	gpio = exgpio_pin_to_offset(gpio);
	val = bus_space_read_4(sc->sc_iot, sc->sc_ioh, GPIO_DAT(gpio));

	bus_space_write_4(sc->sc_iot, sc->sc_ioh, GPIO_DAT(gpio),
		val | GPIO_DAT_SET(gpio));
}

void
exgpio_v5_clear_bit(struct exgpio_softc *sc, unsigned int gpio)
{
	u_int32_t val;

	gpio = exgpio_pin_to_offset(gpio);
	val = bus_space_read_4(sc->sc_iot, sc->sc_ioh, GPIO_DAT(gpio));

	bus_space_write_4(sc->sc_iot, sc->sc_ioh, GPIO_DAT(gpio),
		val & ~GPIO_DAT_MASK(gpio));
}

void
exgpio_v5_set_dir(struct exgpio_softc *sc, unsigned int gpio, unsigned int dir)
{
	int s;
	u_int32_t val;

	gpio = exgpio_pin_to_offset(gpio);
	s = splhigh();

	val = bus_space_read_4(sc->sc_iot, sc->sc_ioh, GPIO_CON(gpio));
	val &= ~GPIO_CON_OUTPUT(gpio);
	if (dir == EXGPIO_DIR_OUT)
		val |= GPIO_CON_OUTPUT(gpio);
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, GPIO_CON(gpio), val);

	splx(s);
}

unsigned int
exgpio_v5_get_dir(struct exgpio_softc *sc, unsigned int gpio)
{
	int s;
	u_int32_t val;

	gpio = exgpio_pin_to_offset(gpio);
	s = splhigh();

	val = bus_space_read_4(sc->sc_iot, sc->sc_ioh, GPIO_CON(gpio));
	if (val & GPIO_CON_OUTPUT(gpio))
		val = EXGPIO_DIR_OUT;
	else
		val = EXGPIO_DIR_IN;

	splx(s);
	return val;
@


1.3
log
@New FDT-enabled busses will use a new "fdt" attribute.  Unfortunately
this attribute is currently already defined.  This define is only used
to disable the unused FDT functionality in the exynos and virtio code.
As the FDT code will be developed in a different manner than the way
those drivers are written today and the functionality has never been
enabled, simply remove the attribute and its users.

ok jsg@@
@
text
@d1 1
a1 1
/* $OpenBSD: exgpio.c,v 1.2 2015/05/27 00:06:14 jsg Exp $ */
d128 2
a129 2
		struct fdt_memory fdtmem;
		if (fdt_get_memory_address(aa->aa_node, 0, &fdtmem))
d132 2
a133 2
		mem.addr = fdtmem.addr;
		mem.size = fdtmem.size;
@


1.2
log
@make the exynos code compile without fdt
ok bmercer@@
@
text
@d1 1
a1 1
/* $OpenBSD: exgpio.c,v 1.1 2015/01/26 02:48:24 bmercer Exp $ */
a17 2

#include "fdt.h"
@


1.1
log
@Import the exynos work into tree. This is from Bitrig. Discussed with and OK jsg, also OK from krw.
@
text
@d1 1
a1 1
/* $OpenBSD: omgpio.c,v 1.8 2011/11/10 19:37:01 uwe Exp $ */
d19 2
d31 1
d33 1
d110 1
d115 1
d125 1
a125 1
	struct fdt_memory mem;
d128 1
d130 2
a131 1
		if (fdt_get_memory_address(aa->aa_node, 0, &mem))
d134 5
a138 1
	} else {
@

