head	1.9;
access;
symbols;
locks; strict;
comment	@ * @;


1.9
date	2016.08.22.09.37.27;	author kettenis;	state Exp;
branches;
next	1.8;
commitid	BqGQnZokWAsjVREe;

1.8
date	2016.08.20.15.44.04;	author kettenis;	state Exp;
branches;
next	1.7;
commitid	PxjV2jD6yVzqolQF;

1.7
date	2016.08.20.10.41.54;	author kettenis;	state Exp;
branches;
next	1.6;
commitid	Ic0Equ3YR9llzwHL;

1.6
date	2016.08.17.13.44.48;	author patrick;	state Exp;
branches;
next	1.5;
commitid	2t26vuwVZWqFwyfl;

1.5
date	2016.08.17.13.26.40;	author patrick;	state Exp;
branches;
next	1.4;
commitid	fSGPJMf9eWymnChy;

1.4
date	2016.08.17.13.05.02;	author patrick;	state Exp;
branches;
next	1.3;
commitid	lvew3YexMpLMskOM;

1.3
date	2016.08.15.21.04.32;	author patrick;	state Exp;
branches;
next	1.2;
commitid	eDrjUzPpQZN2eX5m;

1.2
date	2016.08.15.14.17.34;	author patrick;	state Exp;
branches;
next	1.1;
commitid	BTJlstqMxP8G6Bha;

1.1
date	2016.08.15.13.42.49;	author patrick;	state Exp;
branches;
next	;
commitid	8OAWl0pWWtbE7YFk;


desc
@@


1.9
log
@Use the new clock API to get the clock frequency from the device tree and the
actual hardware that controls the clock.  This gets rid of all the hardcoded
clock frequencies for specific hardware.

Tested by jsg@@ on the BBB, mglocker@@ on the C.H.I.P. and myself on the
Banana Pi and Raspberry Pi 3.

ok jsg@@
@
text
@/* $OpenBSD: com_fdt.c,v 1.8 2016/08/20 15:44:04 kettenis Exp $ */
/*
 * Copyright (c) 2016 Patrick Wildt <patrick@@blueri.se>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/tty.h>

#include <machine/intr.h>
#include <machine/bus.h>
#include <machine/fdt.h>

#include <dev/ic/comreg.h>
#include <dev/ic/comvar.h>
#include <dev/cons.h>

/* pick up armv7_a4x_bs_tag */
#include <arch/arm/armv7/armv7var.h>

#include <armv7/armv7/armv7var.h>
#include <armv7/armv7/armv7_machdep.h>

#include <dev/ofw/fdt.h>
#include <dev/ofw/openfirm.h>
#include <dev/ofw/ofw_clock.h>
#include <dev/ofw/ofw_pinctrl.h>

#define com_usr 31	/* Synopsys DesignWare UART */

int	com_fdt_match(struct device *, void *, void *);
void	com_fdt_attach(struct device *, struct device *, void *);
int	com_fdt_intr_designware(void *);

extern int comcnspeed;
extern int comcnmode;

struct com_fdt_softc {
	struct com_softc	 sc;
	struct bus_space	 sc_iot;
};

struct cfattach com_fdt_ca = {
	sizeof (struct com_fdt_softc), com_fdt_match, com_fdt_attach
};

int com_fdt_cngetc(dev_t);
void com_fdt_cnputc(dev_t, int);
void com_fdt_cnpollc(dev_t, int);

struct consdev com_fdt_cons = {
	NULL, NULL, com_fdt_cngetc, com_fdt_cnputc, com_fdt_cnpollc, NULL,
	NODEV, CN_LOWPRI
};

void
com_fdt_init_cons(void)
{
	struct fdt_reg reg;
	void *node;

	if ((node = fdt_find_cons("brcm,bcm2835-aux-uart")) == NULL &&
	    (node = fdt_find_cons("snps,dw-apb-uart")) == NULL &&
	    (node = fdt_find_cons("ti,omap3-uart")) == NULL &&
	    (node = fdt_find_cons("ti,omap4-uart")) == NULL)
			return;
	if (fdt_get_reg(node, 0, &reg))
		return;

	/*
	 * Figuring out the clock frequency is rather complicated as
	 * on many SoCs this requires traversing a fair amount of the
	 * clock tree.  Instead we rely on the firmware to set up the
	 * console for us and bypass the cominit() call that
	 * comcnattach() does by doing the minimal setup here.
	 */

	comconsiot = &armv7_a4x_bs_tag;
	if (bus_space_map(comconsiot, reg.addr, reg.size, 0, &comconsioh))
		return;

	comconsrate = comcnspeed;
	comconscflag = comcnmode;
	cn_tab = &com_fdt_cons;
}

int
com_fdt_match(struct device *parent, void *match, void *aux)
{
	struct fdt_attach_args *faa = aux;

	return (OF_is_compatible(faa->fa_node, "brcm,bcm2835-aux-uart") ||
	    OF_is_compatible(faa->fa_node, "snps,dw-apb-uart") ||
	    OF_is_compatible(faa->fa_node, "ti,omap3-uart") ||
	    OF_is_compatible(faa->fa_node, "ti,omap4-uart"));
}

void
com_fdt_attach(struct device *parent, struct device *self, void *aux)
{
	struct com_fdt_softc *sc = (struct com_fdt_softc *)self;
	struct fdt_attach_args *faa = aux;
	int (*intr)(void *) = comintr;
	uint32_t freq;

	if (faa->fa_nreg < 1)
		return;

	clock_enable(faa->fa_node, NULL);

	/*
	 * Determine the clock frequency after enabling the clock.
	 * This gives the clock code a chance to configure the
	 * appropriate frequency for us.
	 */
	freq = OF_getpropint(faa->fa_node, "clock-frequency", 0);
	if (freq == 0)
		freq = clock_get_frequency(faa->fa_node, NULL);

	/*
	 * XXX This sucks.  We need to get rid of the a4x bus tag
	 * altogether.  For this we will need to change com(4).
	 */
	sc->sc_iot = armv7_a4x_bs_tag;
	sc->sc_iot.bs_cookie = faa->fa_iot->bs_cookie;
	sc->sc_iot.bs_map = faa->fa_iot->bs_map;

	sc->sc.sc_iot = &sc->sc_iot;
	sc->sc.sc_iobase = faa->fa_reg[0].addr;
	sc->sc.sc_uarttype = COM_UART_16550;
	sc->sc.sc_frequency = freq ? freq : COM_FREQ;

	if (OF_is_compatible(faa->fa_node, "snps,dw-apb-uart"))
		intr = com_fdt_intr_designware;

	if (OF_is_compatible(faa->fa_node, "ti,omap3-uart") ||
	    OF_is_compatible(faa->fa_node, "ti,omap4-uart"))
		sc->sc.sc_uarttype = COM_UART_TI16750;

	if (stdout_node == faa->fa_node) {
		SET(sc->sc.sc_hwflags, COM_HW_CONSOLE);
		SET(sc->sc.sc_swflags, COM_SW_SOFTCAR);
		comconsfreq = sc->sc.sc_frequency;
	}

	if (bus_space_map(sc->sc.sc_iot, sc->sc.sc_iobase,
	    faa->fa_reg[0].size, 0, &sc->sc.sc_ioh)) {
		printf("%s: bus_space_map failed\n", __func__);
		return;
	}

	pinctrl_byname(faa->fa_node, "default");

	com_attach_subr(&sc->sc);

	arm_intr_establish_fdt(faa->fa_node, IPL_TTY, intr,
	    sc, sc->sc.sc_dev.dv_xname);
}

int
com_fdt_intr_designware(void *cookie)
{
	struct com_softc *sc = cookie;

	bus_space_read_1(sc->sc_iot, sc->sc_ioh, com_usr);

	return comintr(sc);
}

int
com_fdt_cngetc(dev_t dev)
{
	return com_common_getc(comconsiot, comconsioh);
}

void
com_fdt_cnputc(dev_t dev, int c)
{
	com_common_putc(comconsiot, comconsioh, c);
}

void
com_fdt_cnpollc(dev_t dev, int on)
{
}
@


1.8
log
@Replace bcmmuart(4) with com(4).

ok patrick@@
@
text
@d1 1
a1 1
/* $OpenBSD: com_fdt.c,v 1.7 2016/08/20 10:41:54 kettenis Exp $ */
d39 1
d117 1
a117 1
	int node;
d122 11
d144 1
a144 1
	sc->sc.sc_frequency = COM_FREQ;
a148 3
	if (OF_is_compatible(faa->fa_node, "brcm,bcm2835-aux-uart"))
		sc->sc.sc_frequency = 500000000;

d150 1
a150 1
	    OF_is_compatible(faa->fa_node, "ti,omap4-uart")) {
a151 9
		sc->sc.sc_frequency = 48000000;
	}

	if ((node = OF_finddevice("/")) != 0 &&
	    (OF_is_compatible(node, "allwinner,sun4i-a10") ||
	    OF_is_compatible(node, "allwinner,sun5i-a10s") ||
	    OF_is_compatible(node, "allwinner,sun5i-r8") ||
	    OF_is_compatible(node, "allwinner,sun7i-a20")))
		sc->sc.sc_frequency = 24000000;
@


1.7
log
@Figuring out the clock frequency used for a com(4) device on armv7 is hard.
Avoid doing so for the early console and instead rely on the firmware to
set up the right baud rate and such.

ok visa@@, millert@@, jsg@@
@
text
@d1 1
a1 1
/* $OpenBSD: com_fdt.c,v 1.6 2016/08/17 13:44:48 patrick Exp $ */
d74 4
a77 3
	if ((node = fdt_find_cons("ti,omap3-uart")) == NULL &&
	    (node = fdt_find_cons("ti,omap4-uart")) == NULL &&
	    (node = fdt_find_cons("snps,dw-apb-uart")) == NULL)
d84 1
a84 1
	 * om many SoCs this requires traversing a fair amount of the
d104 4
a107 3
	return (OF_is_compatible(faa->fa_node, "ti,omap3-uart") ||
	    OF_is_compatible(faa->fa_node, "ti,omap4-uart") ||
	    OF_is_compatible(faa->fa_node, "snps,dw-apb-uart"));
d131 2
a132 2
	sc->sc.sc_frequency = 48000000;
	sc->sc.sc_uarttype = COM_UART_TI16750;
d134 1
a134 2
	if (OF_is_compatible(faa->fa_node, "snps,dw-apb-uart")) {
		sc->sc.sc_uarttype = COM_UART_16550;
d136 8
@


1.6
log
@Nothing from the original Wasabi code remains, so replace the copyright
with the standard ISC license.

ok kettenis@@ jsg@@
@
text
@d1 1
a1 1
/* $OpenBSD: com_fdt.c,v 1.5 2016/08/17 13:26:40 patrick Exp $ */
d29 1
d59 9
a72 1
	int freq = 48000000;
d81 15
a95 10
	if ((node = fdt_find_node("/")) != NULL &&
	    (fdt_is_compatible(node, "allwinner,sun4i-a10") ||
	    fdt_is_compatible(node, "allwinner,sun5i-a10s") ||
	    fdt_is_compatible(node, "allwinner,sun5i-r8") ||
	    fdt_is_compatible(node, "allwinner,sun7i-a20")))
		freq = 24000000;

	comcnattach(&armv7_a4x_bs_tag, reg.addr, comcnspeed, freq,
	    comcnmode);
	comdefaultrate = comcnspeed;
d147 1
d172 17
@


1.5
log
@Remove bogus suspend/resume code from armv7 com(4) attachment driver.
The code initially arrived when the zaurus driver was copied.  As we
don't suspend on ARMv7, just get rid of it.

Prompted by jsg@@ and kettenis@@.
@
text
@d1 1
a1 1
/* $OpenBSD: com_fdt.c,v 1.4 2016/08/17 13:05:02 patrick Exp $ */
d3 1
a3 2
 * Copyright 2003 Wasabi Systems, Inc.
 * All rights reserved.
d5 3
a7 1
 * Written by Steve C. Woodford for Wasabi Systems, Inc.
d9 7
a15 27
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed for the NetBSD Project by
 *      Wasabi Systems, Inc.
 * 4. The name of Wasabi Systems, Inc. may not be used to endorse
 *    or promote products derived from this software without specific prior
 *    written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY WASABI SYSTEMS, INC. ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL WASABI SYSTEMS, INC
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
@


1.4
log
@Replace sxiuart(4) with the mostly compatible com(4).

The Synopsys DesignWare 8250 throws an interrupt if it detects a write
to LCR while it was busy.  Read the USR register to clear the interrupt
so we don't get flooded.

The sunxi machines also use a different frequency on the consoles.  As
we have no clock framework, especially not for early consoles, match on
known Allwinner compatibles to set a known frequency.

ok kettenis@@ mglocker@@
@
text
@d1 1
a1 1
/* $OpenBSD: com_fdt.c,v 1.3 2016/08/15 21:04:32 patrick Exp $ */
a58 2
#define com_isr 8
#define ISR_RECV	(ISR_RXPL | ISR_XMODE | ISR_RCVEIR)
a62 1
int	com_fdt_activate(struct device *, int);
d74 1
a74 2
	sizeof (struct com_fdt_softc), com_fdt_match, com_fdt_attach, NULL,
	com_fdt_activate
a165 27
}

int
com_fdt_activate(struct device *self, int act)
{
	struct com_softc *sc = (struct com_softc *)self;
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	struct tty *tp = sc->sc_tty;

	switch (act) {
	case DVACT_SUSPEND:
		break;
	case DVACT_RESUME:
		if (sc->enabled) {
			sc->sc_initialize = 1;
			comparam(tp, &tp->t_termios);
			bus_space_write_1(iot, ioh, com_ier, sc->sc_ier);

			if (ISSET(sc->sc_hwflags, COM_HW_SIR)) {
				bus_space_write_1(iot, ioh, com_isr,
				    ISR_RECV);
			}
		}
		break;
	}
	return 0;
@


1.3
log
@Now that com(4) uses a different iot for the initial console and the
main attachment, the serial port is now longer recognized as console.
To fix this, store the OFW node of the initial console and check it
in the attachment driver.

ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: com_fdt.c,v 1.2 2016/08/15 14:17:34 patrick Exp $ */
d61 1
d66 1
d86 1
d88 3
a90 2
	if ((node = fdt_find_cons("ti,omap3-uart")) == NULL)
		if ((node = fdt_find_cons("ti,omap4-uart")) == NULL)
d95 8
a102 1
	comcnattach(&armv7_a4x_bs_tag, reg.addr, comcnspeed, 48000000,
d113 2
a114 1
	    OF_is_compatible(faa->fa_node, "ti,omap4-uart"));
d122 2
d141 12
d168 1
a168 1
	(void)arm_intr_establish_fdt(faa->fa_node, IPL_TTY, comintr,
d197 10
@


1.2
log
@Allow com(4) to make use of the simplebus address translation.
This typically works for every simplebus client, but com(4) did not
make use of the supplied bus tag.  Instead it references the global
a4x bus tag.  This is needed as the ARM com(4) controllers use 4-byte
spaced registers, while com(4) operates on 1-byte.  To be able to make
use of the address translation, copy the a4x bus tag and replace the
cookie and map function with the one supplied by simplebus.

ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: com_fdt.c,v 1.1 2016/08/15 13:42:49 patrick Exp $ */
d126 5
@


1.1
log
@Move the com(4) fdt attachment driver to a more generic location and
rename it to fit the typical scheme of such an attachment driver.

ok kettenis@@ jsg@@
@
text
@d1 1
a1 1
/* $OpenBSD: omap_com.c,v 1.10 2016/08/12 03:22:41 jsg Exp $ */
d69 5
d75 1
a75 1
	sizeof (struct com_softc), com_fdt_match, com_fdt_attach, NULL,
d108 1
a108 1
	struct com_softc *sc = (struct com_softc *)self;
d114 12
a125 4
	sc->sc_iot = &armv7_a4x_bs_tag; /* XXX: This sucks */
	sc->sc_iobase = faa->fa_reg[0].addr;
	sc->sc_frequency = 48000000;
	sc->sc_uarttype = COM_UART_TI16750;
d127 2
a128 2
	if (bus_space_map(sc->sc_iot, sc->sc_iobase,
	    faa->fa_reg[0].size, 0, &sc->sc_ioh)) {
d135 1
a135 1
	com_attach_subr(sc);
d138 1
a138 1
	    sc, sc->sc_dev.dv_xname);
@

