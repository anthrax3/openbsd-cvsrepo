head	1.11;
access;
symbols
	OPENBSD_6_1:1.10.0.4
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.8.0.2
	OPENBSD_6_0_BASE:1.8;
locks; strict;
comment	@ * @;


1.11
date	2017.06.08.19.40.49;	author patrick;	state Exp;
branches;
next	1.10;
commitid	wggsK9muT75G8UEE;

1.10
date	2016.10.06.18.15.44;	author kettenis;	state Exp;
branches;
next	1.9;
commitid	BQmlDk49Vlbp1uQn;

1.9
date	2016.09.24.13.40.12;	author kettenis;	state Exp;
branches;
next	1.8;
commitid	wtbC8osG5m0rEk4i;

1.8
date	2016.06.21.15.39.51;	author kettenis;	state Exp;
branches;
next	1.7;
commitid	H62QnVb04q7pku6e;

1.7
date	2016.05.17.23.16.10;	author kettenis;	state Exp;
branches;
next	1.6;
commitid	zHlQmqIwgrycxqlS;

1.6
date	2016.05.17.22.41.20;	author kettenis;	state Exp;
branches;
next	1.5;
commitid	NNtn5vXpUWa3YUEk;

1.5
date	2016.05.17.21.26.32;	author kettenis;	state Exp;
branches;
next	1.4;
commitid	3n9DvpmBesrJfZVA;

1.4
date	2016.05.14.21.22.56;	author kettenis;	state Exp;
branches;
next	1.3;
commitid	Oen2JBO8jzcomo5a;

1.3
date	2016.05.14.20.00.24;	author kettenis;	state Exp;
branches;
next	1.2;
commitid	tHmXcV1FdW3Zog5T;

1.2
date	2016.05.14.18.26.39;	author kettenis;	state Exp;
branches;
next	1.1;
commitid	nX17WkgmZpcIGnB2;

1.1
date	2016.05.14.17.55.15;	author kettenis;	state Exp;
branches;
next	;
commitid	IdQZw2Pw0GuFYXCI;


desc
@@


1.11
log
@Remove esym (.data) patching.  Thanks to Mark we stopped requiring this
and with the random-order kernel we shouldn't be doing that anyway.

ok kettenis@@
@
text
@/*	$OpenBSD: exec.c,v 1.10 2016/10/06 18:15:44 kettenis Exp $	*/

/*
 * Copyright (c) 2006, 2016 Mark Kettenis
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/reboot.h>
#include <dev/cons.h>

#include <lib/libkern/libkern.h>
#include <lib/libsa/loadfile.h>
#include <sys/exec_elf.h>

#include <efi.h>
#include <stand/boot/cmd.h>

#include "efiboot.h"
#include "libsa.h"

typedef void (*startfuncp)(void *, void *, void *) __attribute__ ((noreturn));

void
run_loadfile(u_long *marks, int howto)
{
	u_long esym = marks[MARK_END] & 0x0fffffff;
	char args[256];
	char *cp;
	void *fdt;
	uint32_t board_id = 0;

	snprintf(args, sizeof(args) - 8, "%s:%s", cmd.bootdev, cmd.image);
	cp = args + strlen(args);

	*cp++ = ' ';
	*cp = '-';
        if (howto & RB_ASKNAME)
                *++cp = 'a';
        if (howto & RB_CONFIG)
                *++cp = 'c';
        if (howto & RB_SINGLE)
                *++cp = 's';
        if (howto & RB_KDB)
                *++cp = 'd';
        if (*cp == '-')
		*--cp = 0;
	else
		*++cp = 0;

	fdt = efi_makebootargs(args, &board_id);

	efi_cleanup();

	(*(startfuncp)(marks[MARK_ENTRY]))((void *)esym, (void *)board_id, fdt);

	/* NOTREACHED */
}
@


1.10
log
@Remove board IDs for the i.MX platform.  The kernel doesn't need them anymore.
Make sure we pass 0 as the board ID instead of random garbage if we don't
find a matching compatible string.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.9 2016/09/24 13:40:12 kettenis Exp $	*/
a37 2
	Elf_Ehdr *elf = (Elf_Ehdr *)marks[MARK_SYM];
	Elf_Shdr *shp = (Elf_Shdr *)(marks[MARK_SYM] + elf->e_shoff);
a38 1
	u_long offset = 0;
a42 16
	int i;

	/*
	 * Tell locore.S where the symbol table ends by setting
	 * 'esym', which should be the first word in the .data
	 * section.
	 */
	for (i = 0; i < elf->e_shnum; i++) {
		/* XXX Assume .data is the first writable segment. */
		if (shp[i].sh_flags & SHF_WRITE) {
			/* XXX We have to store the virtual address. */
			esym |= shp[i].sh_addr & 0xf0000000;
			*(u_long *)(LOADADDR(shp[i].sh_addr)) = esym;
			break;
		}
	}
@


1.9
log
@Pass esym to the kernel in r0.  Since u-boot passes 0 in this register, we
can easily determine that the value passed is valid and use it to initialize
the kernel symbol tableo.

ok tom@@, patrick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.8 2016/06/21 15:39:51 kettenis Exp $	*/
d45 1
a45 1
	uint32_t board_id;
@


1.8
log
@Remove code to generate uboot tags.  It hardcoded information for a single
board and a device tree is required by our kernel now.

ok patrick@@, jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.7 2016/05/17 23:16:10 kettenis Exp $	*/
d85 1
a85 1
	(*(startfuncp)(marks[MARK_ENTRY]))(NULL, (void *)board_id, fdt);
@


1.7
log
@Fix a few more warnings such that this compiles again.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.6 2016/05/17 22:41:20 kettenis Exp $	*/
a20 1
#include <machine/bootconfig.h>
a32 2
extern void *fdt;

a34 43
struct uboot_tag_header {
	uint32_t	size;
	uint32_t	tag;
};
struct uboot_tag_core {
	uint32_t	flags;
	uint32_t	pagesize;
	uint32_t	rootdev;
};
struct uboot_tag_serialnr {
	uint32_t	low;
	uint32_t	high;
};
struct uboot_tag_revision {
	uint32_t	rev;
};
struct uboot_tag_mem32 {
	uint32_t	size;
	uint32_t	start;
};
struct uboot_tag_cmdline {
	char		cmdline[64];
};

#define ATAG_CORE	0x54410001
#define	ATAG_MEM	0x54410002
#define	ATAG_CMDLINE	0x54410009
#define	ATAG_SERIAL	0x54410006
#define	ATAG_REVISION	0x54410007
#define	ATAG_NONE	0x00000000
struct uboot_tag {
	struct uboot_tag_header hdr;
	union {
		struct uboot_tag_core		core;
		struct uboot_tag_mem32		mem;
		struct uboot_tag_revision	rev;
		struct uboot_tag_serialnr	serialnr;
		struct uboot_tag_cmdline	cmdline;
	} u;
};

struct uboot_tag tags[3];

a81 14
	if (fdt == 0) {
		tags[0].hdr.tag = ATAG_MEM;
		tags[0].hdr.size = sizeof(struct uboot_tag) / sizeof(uint32_t);
		tags[0].u.mem.start = 0x10000000;
		tags[0].u.mem.size = 0x80000000;
		tags[1].hdr.tag = ATAG_CMDLINE;
		tags[1].hdr.size = sizeof(struct uboot_tag) / sizeof(uint32_t);
		strlcpy(tags[1].u.cmdline.cmdline, args,
			sizeof(tags[1].u.cmdline.cmdline));

		memcpy((void *)0x10000000, tags, sizeof(tags));
		fdt = (void *)0x10000000;
		board_id = 4821;
	}
@


1.6
log
@Enable -Wall -Werror.  Fix warnings uncovered by this.

Set board IDs for i.IMX6 boards based on the "compatible" property of the
root node for now to ease the transition to full FDT support in the
kernel.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.5 2016/05/17 21:26:32 kettenis Exp $	*/
d24 1
d32 1
@


1.5
log
@Add support for passing an FDT.  The bootloader will update the "bootargs"
property of the "/chosen" node to pass arguments to the kernel.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.4 2016/05/14 21:22:56 kettenis Exp $	*/
d89 1
d125 1
a125 1
	fdt = efi_makebootargs(args);
d138 1
d143 1
a143 1
	(*(startfuncp)(marks[MARK_ENTRY]))(NULL, (void *)4821, fdt);
@


1.4
log
@Since GetTime() doesn't work on U-Boot, use timer events to simulate a clock
that ticks at every second.  This makes the boot prompt timeout work.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.3 2016/05/14 20:00:24 kettenis Exp $	*/
d20 3
a24 2

#ifdef BOOT_ELF
a25 1
#endif
d27 1
a27 1
#include <sys/reboot.h>
a28 1
#include <machine/bootconfig.h>
d30 1
a30 1
#include <efi.h>
d32 1
a32 1
extern EFI_BOOT_SERVICES *BS;
d88 1
d124 10
a133 8
	tags[0].hdr.tag = ATAG_MEM;
	tags[0].hdr.size = sizeof(struct uboot_tag) / sizeof(uint32_t);
	tags[0].u.mem.start = 0x10000000;
	tags[0].u.mem.size = 0x80000000;
	tags[1].hdr.tag = ATAG_CMDLINE;
	tags[1].hdr.size = sizeof(struct uboot_tag) / sizeof(uint32_t);
	strlcpy(tags[1].u.cmdline.cmdline, args,
	    sizeof(tags[1].u.cmdline.cmdline));
d135 3
a137 1
	memcpy((void *)0x10000000, tags, sizeof(tags));
d141 1
a141 1
	(*(startfuncp)(marks[MARK_ENTRY]))(NULL, (void *)4821, (void *)0x10000000);
@


1.3
log
@Handle boot options, and pass the boot device to the kernel.  The boot device
is currently hardcoded to be sd0.  Still need to figure out how we will do
proper boot device selection when we start using the FDT.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.2 2016/05/14 18:26:39 kettenis Exp $	*/
d135 1
a135 1
	BS->ExitBootServices(NULL, 0);
@


1.2
log
@Tell the kernel where its symbols are.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.1 2016/05/14 17:55:15 kettenis Exp $	*/
d58 1
a58 1
	char		cmdline[1];
d78 1
a78 1
struct uboot_tag tags[2];
a82 1
#ifdef BOOT_ELF
d87 1
a104 4
#endif

#if 0
	cp = (char *)0x00200000 - MAX_BOOT_STRING - 1;
d106 2
a107 1
#define      BOOT_STRING_MAGIC 0x4f425344
d109 14
a122 18
	*(int *)cp = BOOT_STRING_MAGIC;

	cp += sizeof(int);
	snprintf(cp, MAX_BOOT_STRING, "%s:%s -", cmd.bootdev, cmd.image);

	while (*cp != '\0')
		cp++;
	if (howto & RB_ASKNAME)
		*cp++ = 'a';
	if (howto & RB_CONFIG)
		*cp++ = 'c';
	if (howto & RB_KDB)
		*cp++ = 'd';
	if (howto & RB_SINGLE)
		*cp++ = 's';

	*cp = '\0';
#endif
d125 1
a125 1
	tags[0].hdr.size = sizeof(struct uboot_tag);
d128 4
@


1.1
log
@Initial stab at an EFI bootloader for armv7.  Bits and pieces from FreeBSD
and our amd64 EFI bootloader.  The current code works on a 2GB CuBox-i,
but probably not on anything else.  It needs a u-boot with EFI loader
support.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a82 1
#if 0
d86 2
a87 1
	u_long esym = marks[MARK_END];
d100 2
a101 2
			esym |= shp[i].sh_addr & 0xff000000;
			*(u_long *)(shp[i].sh_addr & 0x00ffffff) = esym;
d106 2
a128 1

@

