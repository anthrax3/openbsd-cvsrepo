head	1.8;
access;
symbols
	OPENBSD_6_1:1.8.0.4
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.5.0.2
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.2.0.8
	OPENBSD_5_9_BASE:1.2
	OPENBSD_5_8:1.2.0.10
	OPENBSD_5_8_BASE:1.2
	OPENBSD_5_7:1.2.0.2
	OPENBSD_5_7_BASE:1.2
	OPENBSD_5_6:1.2.0.6
	OPENBSD_5_6_BASE:1.2
	OPENBSD_5_5:1.2.0.4
	OPENBSD_5_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.8
date	2016.09.18.18.16.00;	author kettenis;	state Exp;
branches;
next	1.7;
commitid	baEd1JYtYxyO1XyV;

1.7
date	2016.09.10.18.33.01;	author jsg;	state Exp;
branches;
next	1.6;
commitid	cFRL5ZcH1S6dcfC1;

1.6
date	2016.08.06.17.18.38;	author kettenis;	state Exp;
branches;
next	1.5;
commitid	cnh4dl1psoWEBlsr;

1.5
date	2016.07.10.20.53.04;	author patrick;	state Exp;
branches;
next	1.4;
commitid	YenWd0D9XgmRfZX4;

1.4
date	2016.07.10.17.17.22;	author kettenis;	state Exp;
branches;
next	1.3;
commitid	mwEIet9uuVdqaYQW;

1.3
date	2016.07.10.11.46.28;	author kettenis;	state Exp;
branches;
next	1.2;
commitid	hkXva6w0XSlF6284;

1.2
date	2013.11.06.19.03.07;	author syl;	state Exp;
branches;
next	1.1;

1.1
date	2013.09.06.20.45.54;	author patrick;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Convert imxccm(4) and imxiomuxc(4) to attach using the fdt.  Use the "early"
locator to attach them before other drivers that might need their services.

ok patrick@@, jsg@@
@
text
@/* $OpenBSD: imxiomuxc.c,v 1.7 2016/09/10 18:33:01 jsg Exp $ */
/*
 * Copyright (c) 2013 Patrick Wildt <patrick@@blueri.se>
 * Copyright (c) 2016 Mark Kettenis <kettenis@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/queue.h>
#include <sys/malloc.h>
#include <sys/device.h>
#include <sys/evcount.h>
#include <sys/socket.h>
#include <sys/timeout.h>

#include <machine/intr.h>
#include <machine/bus.h>
#include <machine/fdt.h>

#include <armv7/imx/imxiomuxcvar.h>

#include <dev/ofw/openfirm.h>
#include <dev/ofw/ofw_pinctrl.h>
#include <dev/ofw/fdt.h>

/* registers */
#define IOMUXC_GPR1			0x004
#define IOMUXC_GPR8			0x020
#define IOMUXC_GPR12			0x030
#define IOMUXC_GPR13			0x034

/* bits and bytes */
#define IOMUXC_GPR1_REF_SSP_EN					(1 << 16)
#define IOMUXC_GPR1_TEST_POWERDOWN				(1 << 18)

#define IOMUXC_GPR8_PCS_TX_DEEMPH_GEN1				(0 << 0)
#define IOMUXC_GPR8_PCS_TX_DEEMPH_GEN2_3P5DB			(0 << 6)
#define IOMUXC_GPR8_PCS_TX_DEEMPH_GEN2_6DB			(20 << 12)
#define IOMUXC_GPR8_PCS_TX_SWING_FULL				(127 << 18)
#define IOMUXC_GPR8_PCS_TX_SWING_LOW				(127 << 25)

#define IOMUXC_GPR12_LOS_LEVEL_MASK				(0x1f << 4)
#define IOMUXC_GPR12_LOS_LEVEL_9				(9 << 4)
#define IOMUXC_GPR12_APPS_PM_XMT_PME				(1 << 9)
#define IOMUXC_GPR12_APPS_LTSSM_ENABLE				(1 << 10)
#define IOMUXC_GPR12_APPS_INIT_RST				(1 << 11)
#define IOMUXC_GPR12_DEVICE_TYPE_RC				(2 << 12)
#define IOMUXC_GPR12_DEVICE_TYPE_MASK				(3 << 12)
#define IOMUXC_GPR12_APPS_PM_XMT_TURNOFF			(1 << 16)

#define IOMUXC_GPR13_SATA_PHY_1_FAST_EDGE_RATE			(0x00 << 0)
#define IOMUXC_GPR13_SATA_PHY_1_SLOW_EDGE_RATE			(0x02 << 0)
#define IOMUXC_GPR13_SATA_PHY_1_EDGE_RATE_MASK			0x3
#define IOMUXC_GPR13_SATA_PHY_2_1104V				(0x11 << 2)
#define IOMUXC_GPR13_SATA_PHY_3_333DB				(0x00 << 7)
#define IOMUXC_GPR13_SATA_PHY_4_9_16				(0x04 << 11)
#define IOMUXC_GPR13_SATA_PHY_5_SS				(0x01 << 14)
#define IOMUXC_GPR13_SATA_SPEED_3G				(0x01 << 15)
#define IOMUXC_GPR13_SATA_PHY_6					(0x03 << 16)
#define IOMUXC_GPR13_SATA_PHY_7_SATA2M				(0x12 << 19)
#define IOMUXC_GPR13_SATA_PHY_8_30DB				(0x05 << 24)
#define IOMUXC_GPR13_SATA_MASK					0x07FFFFFD

#define IOMUXC_PAD_CTL_SRE_SLOW		(1 << 0)
#define IOMUXC_PAD_CTL_SRE_FAST		(1 << 0)
#define IOMUXC_PAD_CTL_DSE_HIZ		(0 << 3)
#define IOMUXC_PAD_CTL_DSE_240OHM	(1 << 3)
#define IOMUXC_PAD_CTL_DSE_120OHM	(2 << 3)
#define IOMUXC_PAD_CTL_DSE_80OHM	(3 << 3)
#define IOMUXC_PAD_CTL_DSE_60OHM	(4 << 3)
#define IOMUXC_PAD_CTL_DSE_48OHM	(5 << 3)
#define IOMUXC_PAD_CTL_DSE_40OHM	(6 << 3)
#define IOMUXC_PAD_CTL_DSE_34OHM	(7 << 3)
#define IOMUXC_PAD_CTL_SPEED_TBD	(0 << 6)
#define IOMUXC_PAD_CTL_SPEED_LOW	(1 << 6)
#define IOMUXC_PAD_CTL_SPEED_MED	(2 << 6)
#define IOMUXC_PAD_CTL_SPEED_MAX	(3 << 6)
#define IOMUXC_PAD_CTL_ODE_DISABLED	(0 << 11)
#define IOMUXC_PAD_CTL_ODE_ENABLED	(1 << 11)
#define IOMUXC_PAD_CTL_PKE_DISABLED	(0 << 12)
#define IOMUXC_PAD_CTL_PKE_ENABLED	(1 << 12)
#define IOMUXC_PAD_CTL_PUE_KEEP		(0 << 13)
#define IOMUXC_PAD_CTL_PUE_PULL		(1 << 13)
#define IOMUXC_PAD_CTL_PUS_100K_OHM_PD	(0 << 14)
#define IOMUXC_PAD_CTL_PUS_47K_OHM_PU	(1 << 14)
#define IOMUXC_PAD_CTL_PUS_100K_OHM_PU	(2 << 14)
#define IOMUXC_PAD_CTL_PUS_22K_OHM_PU	(3 << 14)
#define IOMUXC_PAD_CTL_HYS_DISABLED	(0 << 16)
#define IOMUXC_PAD_CTL_HYS_ENABLED	(1 << 16)

#define IOMUXC_IMX6Q_I2C_PAD_CTRL	(IOMUXC_PAD_CTL_SRE_FAST | IOMUXC_PAD_CTL_ODE_ENABLED | \
		IOMUXC_PAD_CTL_PKE_ENABLED | IOMUXC_PAD_CTL_PUE_PULL | IOMUXC_PAD_CTL_DSE_40OHM | \
		IOMUXC_PAD_CTL_PUS_100K_OHM_PU | IOMUXC_PAD_CTL_HYS_ENABLED | IOMUXC_PAD_CTL_SPEED_MED)

#define IOMUX_CONFIG_SION		(1 << 4)

#define IMX_PINCTRL_NO_PAD_CTL		(1 << 31)
#define IMX_PINCTRL_SION		(1 << 30)

struct imxiomuxc_softc {
	struct device		sc_dev;
	bus_space_tag_t		sc_iot;
	bus_space_handle_t	sc_ioh;
};

struct imxiomuxc_softc *imxiomuxc_sc;

int	imxiomuxc_match(struct device *, void *, void *);
void	imxiomuxc_attach(struct device *, struct device *, void *);

struct cfattach imxiomuxc_ca = {
	sizeof (struct imxiomuxc_softc), imxiomuxc_match, imxiomuxc_attach
};

struct cfdriver imxiomuxc_cd = {
	NULL, "imxiomuxc", DV_DULL
};

int	imxiomuxc_pinctrl(uint32_t, void *);

int
imxiomuxc_match(struct device *parent, void *match, void *aux)
{
	struct fdt_attach_args *faa = aux;

	return (OF_is_compatible(faa->fa_node, "fsl,imx6q-iomuxc") ||
	    OF_is_compatible(faa->fa_node, "fsl,imx6dl-iomuxc") ||
	    OF_is_compatible(faa->fa_node, "fsl,imx6sl-iomuxc") ||
	    OF_is_compatible(faa->fa_node, "fsl,imx6sx-iomuxc") ||
	    OF_is_compatible(faa->fa_node, "fsl,imx6ul-iomuxc"));
}

void
imxiomuxc_attach(struct device *parent, struct device *self, void *aux)
{
	struct imxiomuxc_softc *sc = (struct imxiomuxc_softc *)self;
	struct fdt_attach_args *faa = aux;

	KASSERT(faa->fa_nreg >= 1);

	sc->sc_iot = faa->fa_iot;
	if (bus_space_map(sc->sc_iot, faa->fa_reg[0].addr,
	    faa->fa_reg[0].size, 0, &sc->sc_ioh))
		panic("%s: bus_space_map failed!", __func__);

	pinctrl_register(faa->fa_node, imxiomuxc_pinctrl, sc);
	imxiomuxc_sc = sc;
	printf("\n");
}

int
imxiomuxc_pinctrl(uint32_t phandle, void *cookie)
{
	struct imxiomuxc_softc *sc = cookie;
	char name[31];
	uint32_t *pins;
	int npins;
	int node;
	int len;
	int i;

	node = OF_getnodebyphandle(phandle);
	if (node == 0)
		return -1;

	OF_getprop(node, "name", name, sizeof(name));
	name[sizeof(name) - 1] = 0;

	len = OF_getproplen(node, "fsl,pins");
	if (len <= 0)
		return -1;

	pins = malloc(len, M_TEMP, M_WAITOK);
	OF_getpropintarray(node, "fsl,pins", pins, len);
	npins = len / (6 * sizeof(uint32_t));

	for (i = 0; i < npins; i++) {
		uint32_t mux_reg = pins[6 * i + 0];
		uint32_t conf_reg = pins[6 * i + 1];
		uint32_t input_reg = pins[6 * i + 2];
		uint32_t mux_val = pins[6 * i + 3];
		uint32_t conf_val = pins[6 * i + 5];
		uint32_t input_val = pins[6 * i + 4];
		uint32_t val;

		/* Set MUX mode. */
		if (conf_val & IMX_PINCTRL_SION)
			mux_val |= IOMUX_CONFIG_SION;
		bus_space_write_4(sc->sc_iot, sc->sc_ioh, mux_reg, mux_val);

		/* Set PAD config. */
		if ((conf_val & IMX_PINCTRL_NO_PAD_CTL) == 0)
			bus_space_write_4(sc->sc_iot, sc->sc_ioh,
			    conf_reg, conf_val);

		/* Set input select. */
		if ((input_val >> 24) == 0xff) {
			/*
			 * Magic value used to clear or set specific
			 * bits in the general purpose registers.
			 */
			uint8_t shift = (input_val >> 16) & 0xff;
			uint8_t width = (input_val >> 8) & 0xff;
			uint32_t clr = ((1 << width) - 1) << shift;
			uint32_t set = (input_val & 0xff) << shift;

			val = bus_space_read_4(sc->sc_iot, sc->sc_ioh,
			    input_reg);
			val &= ~clr;
			val |= set;
			bus_space_write_4(sc->sc_iot, sc->sc_ioh,
			    input_reg, val);
		} else if (input_reg != 0) {
			bus_space_write_4(sc->sc_iot, sc->sc_ioh,
			    input_reg, input_val);
		}
	}

	free(pins, M_TEMP, len);
	return 0;
}

void
imxiomuxc_enable_sata(void)
{
	struct imxiomuxc_softc *sc = imxiomuxc_sc;

	bus_space_write_4(sc->sc_iot, sc->sc_ioh, IOMUXC_GPR13,
	    (bus_space_read_4(sc->sc_iot, sc->sc_ioh, IOMUXC_GPR13) & ~IOMUXC_GPR13_SATA_MASK) |
		IOMUXC_GPR13_SATA_PHY_1_FAST_EDGE_RATE | IOMUXC_GPR13_SATA_PHY_2_1104V |
		IOMUXC_GPR13_SATA_PHY_3_333DB | IOMUXC_GPR13_SATA_PHY_4_9_16 |
		IOMUXC_GPR13_SATA_SPEED_3G | IOMUXC_GPR13_SATA_PHY_6 |
		IOMUXC_GPR13_SATA_PHY_7_SATA2M | IOMUXC_GPR13_SATA_PHY_8_30DB);

	bus_space_write_4(sc->sc_iot, sc->sc_ioh, IOMUXC_GPR13,
	    (bus_space_read_4(sc->sc_iot, sc->sc_ioh, IOMUXC_GPR13) & ~IOMUXC_GPR13_SATA_PHY_1_SLOW_EDGE_RATE) |
		IOMUXC_GPR13_SATA_PHY_1_SLOW_EDGE_RATE);
}

void
imxiomuxc_enable_pcie(void)
{
	struct imxiomuxc_softc *sc = imxiomuxc_sc;

	bus_space_write_4(sc->sc_iot, sc->sc_ioh, IOMUXC_GPR12,
	    bus_space_read_4(sc->sc_iot, sc->sc_ioh, IOMUXC_GPR12) & ~IOMUXC_GPR12_APPS_LTSSM_ENABLE);
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, IOMUXC_GPR12,
	    (bus_space_read_4(sc->sc_iot, sc->sc_ioh, IOMUXC_GPR12) & ~IOMUXC_GPR12_DEVICE_TYPE_MASK) |
		IOMUXC_GPR12_DEVICE_TYPE_RC);
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, IOMUXC_GPR12,
	    (bus_space_read_4(sc->sc_iot, sc->sc_ioh, IOMUXC_GPR12) & ~IOMUXC_GPR12_LOS_LEVEL_MASK) |
		IOMUXC_GPR12_LOS_LEVEL_9);

	bus_space_write_4(sc->sc_iot, sc->sc_ioh, IOMUXC_GPR8,
	    bus_space_read_4(sc->sc_iot, sc->sc_ioh, IOMUXC_GPR8) |
		IOMUXC_GPR8_PCS_TX_DEEMPH_GEN1 | IOMUXC_GPR8_PCS_TX_DEEMPH_GEN2_3P5DB |
		IOMUXC_GPR8_PCS_TX_DEEMPH_GEN2_6DB | IOMUXC_GPR8_PCS_TX_SWING_FULL |
		IOMUXC_GPR8_PCS_TX_SWING_LOW);
}

void
imxiomuxc_pcie_refclk(int enable)
{
	struct imxiomuxc_softc *sc = imxiomuxc_sc;

	bus_space_write_4(sc->sc_iot, sc->sc_ioh, IOMUXC_GPR1,
	    bus_space_read_4(sc->sc_iot, sc->sc_ioh, IOMUXC_GPR1) & ~IOMUXC_GPR1_REF_SSP_EN);

	if (enable)
		bus_space_write_4(sc->sc_iot, sc->sc_ioh, IOMUXC_GPR1,
		    bus_space_read_4(sc->sc_iot, sc->sc_ioh, IOMUXC_GPR1) | IOMUXC_GPR1_REF_SSP_EN);
}

void
imxiomuxc_pcie_test_powerdown(int enable)
{
	struct imxiomuxc_softc *sc = imxiomuxc_sc;

	bus_space_write_4(sc->sc_iot, sc->sc_ioh, IOMUXC_GPR1,
	    bus_space_read_4(sc->sc_iot, sc->sc_ioh, IOMUXC_GPR1) & ~IOMUXC_GPR1_TEST_POWERDOWN);

	if (enable)
		bus_space_write_4(sc->sc_iot, sc->sc_ioh, IOMUXC_GPR1,
		    bus_space_read_4(sc->sc_iot, sc->sc_ioh, IOMUXC_GPR1) | IOMUXC_GPR1_TEST_POWERDOWN);
}
@


1.7
log
@Correct the path to the iomuxc fdt node so pinctrl setup will run.
Noticed when looking into a regression on sabre lite with fec(4)
bisected by matthieu@@.  This fixes the sabre lite problems with fec and
also recent problems with the i2c rtc on cubox.

ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: imxiomuxc.c,v 1.6 2016/08/06 17:18:38 kettenis Exp $ */
d30 1
a31 1
#include <armv7/armv7/armv7var.h>
d36 1
d120 2
a121 2
void imxiomuxc_attach(struct device *parent, struct device *self, void *args);
int imxiomuxc_pinctrl(uint32_t, void *);
d124 1
a124 1
	sizeof (struct imxiomuxc_softc), NULL, imxiomuxc_attach
d131 14
d146 1
a146 1
imxiomuxc_attach(struct device *parent, struct device *self, void *args)
d148 2
a149 12
	struct armv7_attach_args *aa = args;
	struct imxiomuxc_softc *sc = (struct imxiomuxc_softc *) self;
	int node;

	sc->sc_iot = aa->aa_iot;
	if (bus_space_map(sc->sc_iot, aa->aa_dev->mem[0].addr,
	    aa->aa_dev->mem[0].size, 0, &sc->sc_ioh))
		panic("imxiomuxc_attach: bus_space_map failed!");

	node = OF_finddevice("/soc/aips-bus@@02000000/iomuxc@@020e0000");
	if (node != -1)
		pinctrl_register(node, imxiomuxc_pinctrl, sc);
d151 9
a160 1
	imxiomuxc_sc = sc;
@


1.6
log
@Switch imx over to the generic pinctrl API.

ok patrick@@
@
text
@d1 1
a1 1
/* $OpenBSD: imxiomuxc.c,v 1.5 2016/07/10 20:53:04 patrick Exp $ */
d142 1
a142 1
	node = OF_finddevice("/dev/soc/iomuxc@@020e0000");
@


1.5
log
@Not all i.MX6 devices have a pinctrl property in their device nodes.
In that case, soft fail and return instead of allocating buffer with
a bogus size.

ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: imxiomuxc.c,v 1.4 2016/07/10 17:17:22 kettenis Exp $ */
d35 1
d120 1
a120 1
int imxiomuxc_pinctrl(uint32_t);
d135 1
d142 4
d151 1
a151 1
imxiomuxc_pinctrlbyid(int node, int id)
d153 2
a154 50
	char pinctrl[32];
	uint32_t *phandles;
	int len, i;

	snprintf(pinctrl, sizeof(pinctrl), "pinctrl-%d", id);
	len = OF_getproplen(node, pinctrl);
	if (len <= 0)
		return -1;

	phandles = malloc(len, M_TEMP, M_WAITOK);
	OF_getpropintarray(node, pinctrl, phandles, len);
	for (i = 0; i < len / sizeof(uint32_t); i++)
		imxiomuxc_pinctrl(phandles[i]);
	free(phandles, M_TEMP, len);
	return 0;
}

int
imxiomuxc_pinctrlbyname(int node, const char *config)
{
	char *names;
	char *name;
	char *end;
	int id = 0;
	int len;

	len = OF_getproplen(node, "pinctrl-names");
	if (len <= 0)
		return -1;

	names = malloc(len, M_TEMP, M_WAITOK);
	OF_getprop(node, "pinctrl-names", names, len);
	end = names + len;
	name = names;
	while (name < end) {
		if (strcmp(name, config) == 0) {
			free(names, M_TEMP, len);
			return imxiomuxc_pinctrlbyid(node, id);
		}
		name += strlen(name) + 1;
		id++;
	}
	free(names, M_TEMP, len);
	return -1;
}

int
imxiomuxc_pinctrl(uint32_t phandle)
{
	struct imxiomuxc_softc *sc = imxiomuxc_sc;
d164 3
@


1.4
log
@Fix typo.  Pointed out by patrick@@
@
text
@d1 1
a1 1
/* $OpenBSD: imxiomuxc.c,v 1.3 2016/07/10 11:46:28 kettenis Exp $ */
d175 1
a175 1
		printf("no pinctrl-names\n");
@


1.3
log
@Add support for handling pinctrl device tree bindings to imxiomuxc(4).
These are used to do board-specific setup of mux settings and pad
configuration.

ok jsg@@, patrick@@
@
text
@d1 1
a1 1
/* $OpenBSD: imxiomuxc.c,v 1.2 2013/11/06 19:03:07 syl Exp $ */
d4 1
a4 1
 * Copyright (c) 2016 Mark Kettenus <kettenis@@openbsd.org>
@


1.2
log
@After factorizing armv7_machdep code here is an effort to factorize all
the code present in omap/omap.c imx/imx.c and sunxi/sunxi.c

All this code looks quite the same, so we move it in a generic armv7/armv7.c

This is a step closer to only one kernel for all armv7 boards.

ok patrick@@, rapha@@
@
text
@d1 1
a1 1
/* $OpenBSD: imxiomuxc.c,v 1.1 2013/09/06 20:45:54 patrick Exp $ */
d4 1
d27 1
d30 1
d32 3
a41 21
#define IOMUXC_MUX_CTL_PAD_EIM_EB2	0x08C
#define IOMUXC_MUX_CTL_PAD_EIM_DATA16	0x090
#define IOMUXC_MUX_CTL_PAD_EIM_DATA17	0x094
#define IOMUXC_MUX_CTL_PAD_EIM_DATA18	0x098
#define IOMUXC_MUX_CTL_PAD_EIM_DATA21	0x0A4
#define IOMUXC_MUX_CTL_PAD_EIM_DATA28	0x0C4

#define IOMUXC_PAD_CTL_PAD_EIM_EB2	0x3A0
#define IOMUXC_PAD_CTL_PAD_EIM_DATA16	0x3A4
#define IOMUXC_PAD_CTL_PAD_EIM_DATA17	0x3A8
#define IOMUXC_PAD_CTL_PAD_EIM_DATA18	0x3AC
#define IOMUXC_PAD_CTL_PAD_EIM_DATA21	0x3B8
#define IOMUXC_PAD_CTL_PAD_EIM_DATA28	0x3D8

#define IOMUXC_I2C1_SCL_IN_SELECT_INPUT	0x898
#define IOMUXC_I2C1_SDA_IN_SELECT_INPUT	0x89C
#define IOMUXC_I2C2_SCL_IN_SELECT_INPUT	0x8A0
#define IOMUXC_I2C2_SDA_IN_SELECT_INPUT	0x8A4
#define IOMUXC_I2C3_SCL_IN_SELECT_INPUT	0x8A8
#define IOMUXC_I2C3_SDA_IN_SELECT_INPUT	0x8AC

d107 3
d119 1
a119 5
void imxiomuxc_enable_sata(void);
void imxiomuxc_enable_i2c(int);
void imxiomuxc_enable_pcie(void);
void imxiomuxc_pcie_refclk(int);
void imxiomuxc_pcie_test_powerdown(int);
d144 117
a322 40
}

void
imxiomuxc_enable_i2c(int x)
{
	struct imxiomuxc_softc *sc = imxiomuxc_sc;

	/* let's just use EIM for those */
	switch (x) {
		case 0:
			/* scl in select */
			bus_space_write_4(sc->sc_iot, sc->sc_ioh, IOMUXC_MUX_CTL_PAD_EIM_DATA21, IOMUX_CONFIG_SION | 6);
			bus_space_write_4(sc->sc_iot, sc->sc_ioh, IOMUXC_I2C1_SCL_IN_SELECT_INPUT, 0);
			bus_space_write_4(sc->sc_iot, sc->sc_ioh, IOMUXC_PAD_CTL_PAD_EIM_DATA21, IOMUXC_IMX6Q_I2C_PAD_CTRL);
			/* sda in select */
			bus_space_write_4(sc->sc_iot, sc->sc_ioh, IOMUXC_MUX_CTL_PAD_EIM_DATA28, IOMUX_CONFIG_SION | 1);
			bus_space_write_4(sc->sc_iot, sc->sc_ioh, IOMUXC_I2C1_SDA_IN_SELECT_INPUT, 0);
			bus_space_write_4(sc->sc_iot, sc->sc_ioh, IOMUXC_PAD_CTL_PAD_EIM_DATA28, IOMUXC_IMX6Q_I2C_PAD_CTRL);
			break;
		case 1:
			/* scl in select */
			bus_space_write_4(sc->sc_iot, sc->sc_ioh, IOMUXC_MUX_CTL_PAD_EIM_EB2, IOMUX_CONFIG_SION | 6);
			bus_space_write_4(sc->sc_iot, sc->sc_ioh, IOMUXC_I2C2_SCL_IN_SELECT_INPUT, 0);
			bus_space_write_4(sc->sc_iot, sc->sc_ioh, IOMUXC_PAD_CTL_PAD_EIM_EB2, IOMUXC_IMX6Q_I2C_PAD_CTRL);
			/* sda in select */
			bus_space_write_4(sc->sc_iot, sc->sc_ioh, IOMUXC_MUX_CTL_PAD_EIM_DATA16, IOMUX_CONFIG_SION | 6);
			bus_space_write_4(sc->sc_iot, sc->sc_ioh, IOMUXC_I2C2_SDA_IN_SELECT_INPUT, 0);
			bus_space_write_4(sc->sc_iot, sc->sc_ioh, IOMUXC_PAD_CTL_PAD_EIM_DATA16, IOMUXC_IMX6Q_I2C_PAD_CTRL);
			break;
		case 2:
			/* scl in select */
			bus_space_write_4(sc->sc_iot, sc->sc_ioh, IOMUXC_MUX_CTL_PAD_EIM_DATA17, IOMUX_CONFIG_SION | 6);
			bus_space_write_4(sc->sc_iot, sc->sc_ioh, IOMUXC_I2C3_SCL_IN_SELECT_INPUT, 0);
			bus_space_write_4(sc->sc_iot, sc->sc_ioh, IOMUXC_PAD_CTL_PAD_EIM_DATA17, IOMUXC_IMX6Q_I2C_PAD_CTRL);
			/* sda in select */
			bus_space_write_4(sc->sc_iot, sc->sc_ioh, IOMUXC_MUX_CTL_PAD_EIM_DATA18, IOMUX_CONFIG_SION | 6);
			bus_space_write_4(sc->sc_iot, sc->sc_ioh, IOMUXC_I2C3_SDA_IN_SELECT_INPUT, 0);
			bus_space_write_4(sc->sc_iot, sc->sc_ioh, IOMUXC_PAD_CTL_PAD_EIM_DATA18, IOMUXC_IMX6Q_I2C_PAD_CTRL);
			break;
	}
@


1.1
log
@Support for FreeScale's i.MX6 SoC.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d28 1
a28 1
#include <armv7/imx/imxvar.h>
d148 1
a148 1
	struct imx_attach_args *ia = args;
d151 3
a153 3
	sc->sc_iot = ia->ia_iot;
	if (bus_space_map(sc->sc_iot, ia->ia_dev->mem[0].addr,
	    ia->ia_dev->mem[0].size, 0, &sc->sc_ioh))
@

