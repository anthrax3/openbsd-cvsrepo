head	1.36;
access;
symbols
	OPENBSD_6_1_BASE:1.36
	OPENBSD_6_0:1.25.0.2
	OPENBSD_6_0_BASE:1.25
	OPENBSD_5_9:1.13.0.2
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.12.0.4
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.5.0.2
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.4.0.6
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.4
	OPENBSD_5_5_BASE:1.4;
locks; strict;
comment	@ * @;


1.36
date	2017.01.21.05.42.03;	author guenther;	state Exp;
branches;
next	1.35;
commitid	CHRb0fCqa8XxUAMH;

1.35
date	2016.12.28.22.45.24;	author kettenis;	state Exp;
branches;
next	1.34;
commitid	zBEXGFcEf8Xpb4cn;

1.34
date	2016.09.05.12.45.44;	author mglocker;	state Exp;
branches;
next	1.33;
commitid	D2WOLs0sadSln43N;

1.33
date	2016.09.05.12.24.24;	author mglocker;	state Exp;
branches;
next	1.32;
commitid	cxubhjDAUQf0eWRL;

1.32
date	2016.09.05.11.29.55;	author mglocker;	state Exp;
branches;
next	1.31;
commitid	mJYXlf1wSIIwyikr;

1.31
date	2016.08.27.17.32.35;	author kettenis;	state Exp;
branches;
next	1.30;
commitid	JwK0sk8q2r5BjTcd;

1.30
date	2016.08.13.11.08.58;	author kettenis;	state Exp;
branches;
next	1.29;
commitid	9dTfX4Q5LcTRvutP;

1.29
date	2016.08.08.10.10.56;	author kettenis;	state Exp;
branches;
next	1.28;
commitid	xBZTtEOXRx7ELxnc;

1.28
date	2016.08.06.17.18.38;	author kettenis;	state Exp;
branches;
next	1.27;
commitid	cnh4dl1psoWEBlsr;

1.27
date	2016.08.04.15.52.52;	author kettenis;	state Exp;
branches;
next	1.26;
commitid	WNhzA3xU3jFFVhST;

1.26
date	2016.07.27.11.45.02;	author patrick;	state Exp;
branches;
next	1.25;
commitid	yc14meyJgxIAcvAg;

1.25
date	2016.07.11.14.54.18;	author kettenis;	state Exp;
branches;
next	1.24;
commitid	U7d3KueUoBcgSI74;

1.24
date	2016.07.10.11.46.28;	author kettenis;	state Exp;
branches;
next	1.23;
commitid	hkXva6w0XSlF6284;

1.23
date	2016.06.14.14.41.03;	author kettenis;	state Exp;
branches;
next	1.22;
commitid	EHIj62JHRWr7AWSt;

1.22
date	2016.06.13.12.24.05;	author kettenis;	state Exp;
branches;
next	1.21;
commitid	R2LRt1qTHmKu0B25;

1.21
date	2016.06.09.15.38.30;	author kettenis;	state Exp;
branches;
next	1.20;
commitid	mdntq3kwoQcLMJEO;

1.20
date	2016.05.19.09.54.18;	author jsg;	state Exp;
branches;
next	1.19;
commitid	YOVLhJEd9hDJJgxl;

1.19
date	2016.05.15.22.10.24;	author kettenis;	state Exp;
branches;
next	1.18;
commitid	ZiMekJWZJYwfAbux;

1.18
date	2016.05.08.20.22.03;	author kettenis;	state Exp;
branches;
next	1.17;
commitid	JiQxb3tnI5sfYFOm;

1.17
date	2016.05.07.00.11.31;	author jsg;	state Exp;
branches;
next	1.16;
commitid	EzUovD7wEWSYlaBR;

1.16
date	2016.05.06.20.24.35;	author kettenis;	state Exp;
branches;
next	1.15;
commitid	x7clAlBNHWj2e6NC;

1.15
date	2016.05.05.11.01.08;	author kettenis;	state Exp;
branches;
next	1.14;
commitid	tXZ4cDDS7O2NIM1F;

1.14
date	2016.05.01.16.04.39;	author kettenis;	state Exp;
branches;
next	1.13;
commitid	rwmsBKqrjX2EodCO;

1.13
date	2016.01.10.14.11.43;	author kettenis;	state Exp;
branches;
next	1.12;
commitid	hXWKWq7NLwPiJ2vl;

1.12
date	2015.05.30.03.20.54;	author jsg;	state Exp;
branches;
next	1.11;
commitid	pLSM5P5P7M8wocrH;

1.11
date	2015.05.30.02.17.36;	author jsg;	state Exp;
branches;
next	1.10;
commitid	UF9mqL72sfyuXztw;

1.10
date	2015.05.17.12.28.03;	author jsg;	state Exp;
branches;
next	1.9;
commitid	EOSs8zkylOuJ0AbK;

1.9
date	2015.05.17.11.18.05;	author jsg;	state Exp;
branches;
next	1.8;
commitid	OQjYVRacKEuEPwBm;

1.8
date	2015.05.15.17.01.18;	author jsg;	state Exp;
branches;
next	1.7;
commitid	gjgGa2XQ19CHARyr;

1.7
date	2015.05.08.03.38.26;	author jsg;	state Exp;
branches;
next	1.6;
commitid	zVOTE2eSG0EuTsRj;

1.6
date	2015.03.29.03.24.17;	author jsg;	state Exp;
branches;
next	1.5;
commitid	hHVsAs6xtkSH9CXS;

1.5
date	2015.01.02.01.57.33;	author jsg;	state Exp;
branches;
next	1.4;
commitid	HaF7XDn04ChceeoJ;

1.4
date	2013.11.06.19.03.07;	author syl;	state Exp;
branches;
next	1.3;

1.3
date	2013.10.27.20.27.09;	author aalm;	state Exp;
branches;
next	1.2;

1.2
date	2013.10.21.15.30.38;	author patrick;	state Exp;
branches;
next	1.1;

1.1
date	2013.09.06.20.45.53;	author patrick;	state Exp;
branches;
next	;


desc
@@


1.36
log
@p_comm is the process's command and isn't per thread, so move it from
struct proc to struct process.

ok deraadt@@ kettenis@@
@
text
@/*	$OpenBSD: imxesdhc.c,v 1.35 2016/12/28 22:45:24 kettenis Exp $	*/
/*
 * Copyright (c) 2009 Dale Rahn <drahn@@openbsd.org>
 * Copyright (c) 2006 Uwe Stuehler <uwe@@openbsd.org>
 * Copyright (c) 2012-2013 Patrick Wildt <patrick@@blueri.se>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/* i.MX SD/MMC support derived from /sys/dev/sdmmc/sdhc.c */

#include <sys/param.h>
#include <sys/device.h>
#include <sys/kernel.h>
#include <sys/kthread.h>
#include <sys/malloc.h>
#include <sys/systm.h>
#include <machine/bus.h>
#include <machine/fdt.h>

#include <dev/sdmmc/sdmmcchip.h>
#include <dev/sdmmc/sdmmcvar.h>

#include <dev/ofw/openfirm.h>
#include <dev/ofw/ofw_clock.h>
#include <dev/ofw/ofw_gpio.h>
#include <dev/ofw/ofw_pinctrl.h>
#include <dev/ofw/ofw_regulator.h>
#include <dev/ofw/fdt.h>

/* registers */
#define SDHC_DS_ADDR				0x00
#define SDHC_BLK_ATT				0x04
#define SDHC_CMD_ARG				0x08
#define SDHC_CMD_XFR_TYP			0x0c
#define SDHC_CMD_RSP0				0x10
#define SDHC_CMD_RSP1				0x14
#define SDHC_CMD_RSP2				0x18
#define SDHC_CMD_RSP3				0x1c
#define SDHC_DATA_BUFF_ACC_PORT			0x20
#define SDHC_PRES_STATE				0x24
#define SDHC_PROT_CTRL				0x28
#define SDHC_SYS_CTRL				0x2c
#define SDHC_INT_STATUS				0x30
#define SDHC_INT_STATUS_EN			0x34
#define SDHC_INT_SIGNAL_EN			0x38
#define SDHC_AUTOCMD12_ERR_STATUS		0x3c
#define SDHC_HOST_CTRL_CAP			0x40
#define SDHC_WTMK_LVL				0x44
#define SDHC_MIX_CTRL				0x48
#define SDHC_FORCE_EVENT			0x50
#define SDHC_ADMA_ERR_STATUS			0x54
#define SDHC_ADMA_SYS_ADDR			0x58
#define SDHC_DLL_CTRL				0x60
#define SDHC_DLL_STATUS				0x64
#define SDHC_CLK_TUNE_CTRL_STATUS		0x68
#define SDHC_VEND_SPEC				0xc0
#define SDHC_MMC_BOOT				0xc4
#define SDHC_VEND_SPEC2				0xc8
#define SDHC_HOST_CTRL_VER			0xfc

/* bits and bytes */
#define SDHC_BLK_ATT_BLKCNT_MAX			0xffff
#define SDHC_BLK_ATT_BLKCNT_SHIFT		16
#define SDHC_BLK_ATT_BLKSIZE_SHIFT		0
#define SDHC_CMD_XFR_TYP_CMDINDX_SHIFT		24
#define SDHC_CMD_XFR_TYP_CMDINDX_SHIFT_MASK	(0x3f << SDHC_CMD_XFR_TYP_CMDINDX_SHIFT)
#define SDHC_CMD_XFR_TYP_CMDTYP_SHIFT		22
#define SDHC_CMD_XFR_TYP_DPSEL_SHIFT		21
#define SDHC_CMD_XFR_TYP_DPSEL			(1 << SDHC_CMD_XFR_TYP_DPSEL_SHIFT)
#define SDHC_CMD_XFR_TYP_CICEN_SHIFT		20
#define SDHC_CMD_XFR_TYP_CICEN			(1 << SDHC_CMD_XFR_TYP_CICEN_SHIFT)
#define SDHC_CMD_XFR_TYP_CCCEN_SHIFT		19
#define SDHC_CMD_XFR_TYP_CCCEN			(1 << SDHC_CMD_XFR_TYP_CCCEN_SHIFT)
#define SDHC_CMD_XFR_TYP_RSPTYP_SHIFT		16
#define SDHC_CMD_XFR_TYP_RSP_NONE		(0x0 << SDHC_CMD_XFR_TYP_RSPTYP_SHIFT)
#define SDHC_CMD_XFR_TYP_RSP136			(0x1 << SDHC_CMD_XFR_TYP_RSPTYP_SHIFT)
#define SDHC_CMD_XFR_TYP_RSP48			(0x2 << SDHC_CMD_XFR_TYP_RSPTYP_SHIFT)
#define SDHC_CMD_XFR_TYP_RSP48B			(0x3 << SDHC_CMD_XFR_TYP_RSPTYP_SHIFT)
#define SDHC_PRES_STATE_WPSPL			(1 << 19)
#define SDHC_PRES_STATE_BREN			(1 << 11)
#define SDHC_PRES_STATE_BWEN			(1 << 10)
#define SDHC_PRES_STATE_SDSTB			(1 << 3)
#define SDHC_PRES_STATE_DLA			(1 << 2)
#define SDHC_PRES_STATE_CDIHB			(1 << 1)
#define SDHC_PRES_STATE_CIHB			(1 << 0)
#define SDHC_SYS_CTRL_RSTA			(1 << 24)
#define SDHC_SYS_CTRL_RSTC			(1 << 25)
#define SDHC_SYS_CTRL_RSTD			(1 << 26)
#define SDHC_SYS_CTRL_CLOCK_MASK		(0xfff << 4)
#define SDHC_SYS_CTRL_CLOCK_DIV_SHIFT		4
#define SDHC_SYS_CTRL_CLOCK_PRE_SHIFT		8
#define SDHC_SYS_CTRL_DTOCV_SHIFT		16
#define SDHC_INT_STATUS_CC			(1 << 0)
#define SDHC_INT_STATUS_TC			(1 << 1)
#define SDHC_INT_STATUS_BGE			(1 << 2)
#define SDHC_INT_STATUS_DINT			(1 << 3)
#define SDHC_INT_STATUS_BWR			(1 << 4)
#define SDHC_INT_STATUS_BRR			(1 << 5)
#define SDHC_INT_STATUS_CINS			(1 << 6)
#define SDHC_INT_STATUS_CRM			(1 << 7)
#define SDHC_INT_STATUS_CINT			(1 << 8)
#define SDHC_INT_STATUS_CTOE			(1 << 16)
#define SDHC_INT_STATUS_CCE			(1 << 17)
#define SDHC_INT_STATUS_CEBE			(1 << 18)
#define SDHC_INT_STATUS_CIC			(1 << 19)
#define SDHC_INT_STATUS_DTOE			(1 << 20)
#define SDHC_INT_STATUS_DCE			(1 << 21)
#define SDHC_INT_STATUS_DEBE			(1 << 22)
#define SDHC_INT_STATUS_DMAE			(1 << 28)
#define SDHC_INT_STATUS_CMD_ERR			(SDHC_INT_STATUS_CIC | SDHC_INT_STATUS_CEBE | SDHC_INT_STATUS_CCE)
#define SDHC_INT_STATUS_ERR			(SDHC_INT_STATUS_CTOE | SDHC_INT_STATUS_CCE | SDHC_INT_STATUS_CEBE | \
						 SDHC_INT_STATUS_CIC | SDHC_INT_STATUS_DTOE | SDHC_INT_STATUS_DCE | \
						 SDHC_INT_STATUS_DEBE | SDHC_INT_STATUS_DMAE)
#define SDHC_MIX_CTRL_DMAEN			(1 << 0)
#define SDHC_MIX_CTRL_BCEN			(1 << 1)
#define SDHC_MIX_CTRL_AC12EN			(1 << 2)
#define SDHC_MIX_CTRL_DTDSEL			(1 << 4)
#define SDHC_MIX_CTRL_MSBSEL			(1 << 5)
#define SDHC_PROT_CTRL_DTW_MASK			(0x3 << 1)
#define SDHC_PROT_CTRL_DTW_4BIT			(1 << 1)
#define SDHC_PROT_CTRL_DTW_8BIT			(1 << 2)
#define SDHC_PROT_CTRL_DMASEL_MASK		(0x3 << 8)
#define SDHC_PROT_CTRL_DMASEL_SDMA		(0x0 << 8)
#define SDHC_PROT_CTRL_DMASEL_ADMA1		(0x1 << 8)
#define SDHC_PROT_CTRL_DMASEL_ADMA2		(0x2 << 8)
#define SDHC_HOST_CTRL_CAP_MBL_SHIFT		16
#define SDHC_HOST_CTRL_CAP_MBL_MASK		0x7
#define SDHC_HOST_CTRL_CAP_ADMAS		(1 << 20)
#define SDHC_HOST_CTRL_CAP_HSS			(1 << 21)
#define SDHC_HOST_CTRL_CAP_VS33			(1 << 24)
#define SDHC_HOST_CTRL_CAP_VS30			(1 << 25)
#define SDHC_HOST_CTRL_CAP_VS18			(1 << 26)
#define SDHC_VEND_SPEC_FRC_SDCLK_ON		(1 << 8)
#define SDHC_WTMK_LVL_RD_WML_SHIFT		0
#define SDHC_WTMK_LVL_RD_BRST_LEN_SHIFT		8
#define SDHC_WTMK_LVL_WR_WML_SHIFT		16
#define SDHC_WTMK_LVL_WR_BRST_LEN_SHIFT		24

#define SDHC_COMMAND_TIMEOUT			hz
#define SDHC_BUFFER_TIMEOUT			hz
#define SDHC_TRANSFER_TIMEOUT			hz
#define SDHC_DMA_TIMEOUT			(3 * hz)

#define SDHC_ADMA2_VALID			(1 << 0)
#define SDHC_ADMA2_END				(1 << 1)
#define SDHC_ADMA2_INT				(1 << 2)
#define SDHC_ADMA2_ACT				(3 << 4)
#define SDHC_ADMA2_ACT_NOP			(0 << 4)
#define SDHC_ADMA2_ACT_TRANS			(2 << 4)
#define SDHC_ADMA2_ACT_LINK			(3 << 4)

struct sdhc_adma2_descriptor32 {
	uint16_t	attribute;
	uint16_t	length;
	uint32_t	address;
} __packed;


int	imxesdhc_match(struct device *, void *, void *);
void	imxesdhc_attach(struct device *, struct device *, void *);

struct imxesdhc_softc {
	struct device		 sc_dev;
	bus_space_tag_t		 sc_iot;
	bus_space_handle_t	 sc_ioh;
	bus_dma_tag_t		 sc_dmat;
	void			*sc_ih;		/* interrupt handler */
	int			 sc_node;
	uint32_t		 sc_gpio[3];
	uint32_t		 sc_vmmc;
	uint32_t		 sc_pwrseq;
	uint32_t		 sc_vdd;
	u_int sc_flags;

	struct device		*sdmmc;		/* generic SD/MMC device */
	int			 clockbit;	/* clock control bit */
	u_int			 clkbase;	/* base clock freq. in KHz */
	int			 maxblklen;	/* maximum block length */
	int			 flags;		/* flags for this host */
	uint32_t		 ocr;		/* OCR value from caps */
	uint32_t		 intr_status;	/* soft interrupt status */
	uint32_t		 intr_error_status;

	bus_dmamap_t		 adma_map;
	bus_dma_segment_t	 adma_segs[1];
	caddr_t			 adma2;
};

/* Host controller functions called by the attachment driver. */
int	imxesdhc_intr(void *);

void	imxesdhc_clock_enable(uint32_t);
void	imxesdhc_pwrseq_pre(uint32_t);
void	imxesdhc_pwrseq_post(uint32_t);

/* RESET MODES */
#define MMC_RESET_DAT	1
#define MMC_RESET_CMD	2
#define MMC_RESET_ALL	(MMC_RESET_CMD|MMC_RESET_DAT)

#define HDEVNAME(sc)	((sc)->sc_dev.dv_xname)

/* flag values */
#define SHF_USE_DMA	0x0001

/* SDHC should only be accessed with 4 byte reads or writes. */
#define HREAD4(sc, reg)							\
	(bus_space_read_4((sc)->sc_iot, (sc)->sc_ioh, (reg)))
#define HWRITE4(sc, reg, val)						\
	bus_space_write_4((sc)->sc_iot, (sc)->sc_ioh, (reg), (val))
#define HSET4(sc, reg, bits)						\
	HWRITE4((sc), (reg), HREAD4((sc), (reg)) | (bits))
#define HCLR4(sc, reg, bits)						\
	HWRITE4((sc), (reg), HREAD4((sc), (reg)) & ~(bits))

int	imxesdhc_host_reset(sdmmc_chipset_handle_t);
uint32_t imxesdhc_host_ocr(sdmmc_chipset_handle_t);
int	imxesdhc_host_maxblklen(sdmmc_chipset_handle_t);
int	imxesdhc_card_detect(sdmmc_chipset_handle_t);
int	imxesdhc_bus_power(sdmmc_chipset_handle_t, uint32_t);
int	imxesdhc_bus_clock(sdmmc_chipset_handle_t, int, int);
int	imxesdhc_bus_width(sdmmc_chipset_handle_t, int);
void	imxesdhc_card_intr_mask(sdmmc_chipset_handle_t, int);
void	imxesdhc_card_intr_ack(sdmmc_chipset_handle_t);
void	imxesdhc_exec_command(sdmmc_chipset_handle_t, struct sdmmc_command *);
int	imxesdhc_start_command(struct imxesdhc_softc *, struct sdmmc_command *);
int	imxesdhc_wait_state(struct imxesdhc_softc *, uint32_t, uint32_t);
int	imxesdhc_soft_reset(struct imxesdhc_softc *, int);
int	imxesdhc_wait_intr(struct imxesdhc_softc *, int, int);
void	imxesdhc_transfer_data(struct imxesdhc_softc *, struct sdmmc_command *);
void	imxesdhc_read_data(struct imxesdhc_softc *, u_char *, int);
void	imxesdhc_write_data(struct imxesdhc_softc *, u_char *, int);

//#define SDHC_DEBUG
#ifdef SDHC_DEBUG
int imxesdhcdebug = 20;
#define DPRINTF(n,s)	do { if ((n) <= imxesdhcdebug) printf s; } while (0)
#else
#define DPRINTF(n,s)	do {} while(0)
#endif

struct sdmmc_chip_functions imxesdhc_functions = {
	/* host controller reset */
	imxesdhc_host_reset,
	/* host controller capabilities */
	imxesdhc_host_ocr,
	imxesdhc_host_maxblklen,
	/* card detection */
	imxesdhc_card_detect,
	/* bus power and clock frequency */
	imxesdhc_bus_power,
	imxesdhc_bus_clock,
	imxesdhc_bus_width,
	/* command execution */
	imxesdhc_exec_command,
	/* card interrupt */
	imxesdhc_card_intr_mask,
	imxesdhc_card_intr_ack
};

struct cfdriver imxesdhc_cd = {
	NULL, "imxesdhc", DV_DULL
};

struct cfattach imxesdhc_ca = {
	sizeof(struct imxesdhc_softc), imxesdhc_match, imxesdhc_attach
};

int
imxesdhc_match(struct device *parent, void *match, void *aux)
{
	struct fdt_attach_args *faa = aux;

	return OF_is_compatible(faa->fa_node, "fsl,imx6q-usdhc");
}

void
imxesdhc_attach(struct device *parent, struct device *self, void *aux)
{
	struct imxesdhc_softc *sc = (struct imxesdhc_softc *) self;
	struct fdt_attach_args *faa = aux;
	struct sdmmcbus_attach_args saa;
	int error = 1;
	uint32_t caps;
	uint32_t width;

	if (faa->fa_nreg < 1)
		return;

	sc->sc_node = faa->fa_node;
	sc->sc_dmat = faa->fa_dmat;
	sc->sc_iot = faa->fa_iot;
	if (bus_space_map(sc->sc_iot, faa->fa_reg[0].addr,
	    faa->fa_reg[0].size, 0, &sc->sc_ioh))
		panic("imxesdhc_attach: bus_space_map failed!");

	printf("\n");

	pinctrl_byname(faa->fa_node, "default");

	sc->sc_ih = arm_intr_establish_fdt(faa->fa_node, IPL_SDMMC,
	   imxesdhc_intr, sc, sc->sc_dev.dv_xname);

	OF_getpropintarray(sc->sc_node, "cd-gpios", sc->sc_gpio,
	    sizeof(sc->sc_gpio));
	gpio_controller_config_pin(sc->sc_gpio, GPIO_CONFIG_INPUT);

	sc->sc_vmmc = OF_getpropint(sc->sc_node, "vmmc-supply", 0);
	sc->sc_pwrseq = OF_getpropint(sc->sc_node, "mmc-pwrseq", 0);

	/*
	 * Reset the host controller and enable interrupts.
	 */
	if (imxesdhc_host_reset(sc))
		return;

	/* Determine host capabilities. */
	caps = HREAD4(sc, SDHC_HOST_CTRL_CAP);

	/* Use DMA if the host system and the controller support it. */
	if (ISSET(caps, SDHC_HOST_CTRL_CAP_ADMAS))
		SET(sc->flags, SHF_USE_DMA);

	/*
	 * Determine the base clock frequency. (2.2.24)
	 */
	sc->clkbase = clock_get_frequency(faa->fa_node, "per");

	printf("%s: %d MHz base clock\n", DEVNAME(sc), sc->clkbase / 1000);

	/*
	 * Determine SD bus voltage levels supported by the controller.
	 */
	if (caps & SDHC_HOST_CTRL_CAP_VS18)
		SET(sc->ocr, MMC_OCR_1_65V_1_95V);
	if (caps & SDHC_HOST_CTRL_CAP_VS30)
		SET(sc->ocr, MMC_OCR_2_9V_3_0V | MMC_OCR_3_0V_3_1V);
	if (caps & SDHC_HOST_CTRL_CAP_VS33)
		SET(sc->ocr, MMC_OCR_3_2V_3_3V | MMC_OCR_3_3V_3_4V);

	/*
	 * Determine max block size.
	 */
	switch ((caps >> SDHC_HOST_CTRL_CAP_MBL_SHIFT)
	    & SDHC_HOST_CTRL_CAP_MBL_MASK) {
	case 0:
		sc->maxblklen = 512;
		break;
	case 1:
		sc->maxblklen = 1024;
		break;
	case 2:
		sc->maxblklen = 2048;
		break;
	case 3:
		sc->maxblklen = 4096;
		break;
	default:
		sc->maxblklen = 512;
		printf("invalid capability blocksize in capa %08x,"
		    " trying 512\n", caps);
	}

	/* somewhere this blksize might be used instead of the device's */
	sc->maxblklen = 512;

	if (ISSET(sc->flags, SHF_USE_DMA)) {
		int rseg;

		/* Allocate ADMA2 descriptor memory */
		error = bus_dmamem_alloc(sc->sc_dmat, PAGE_SIZE, PAGE_SIZE,
		    PAGE_SIZE, sc->adma_segs, 1, &rseg,
		    BUS_DMA_WAITOK | BUS_DMA_ZERO);
		if (error)
			goto adma_done;
		error = bus_dmamem_map(sc->sc_dmat, sc->adma_segs, rseg,
		    PAGE_SIZE, &sc->adma2, BUS_DMA_WAITOK | BUS_DMA_COHERENT);
		if (error) {
			bus_dmamem_free(sc->sc_dmat, sc->adma_segs, rseg);
			goto adma_done;
		}
		error = bus_dmamap_create(sc->sc_dmat, PAGE_SIZE, 1, PAGE_SIZE,
		    0, BUS_DMA_WAITOK, &sc->adma_map);
		if (error) {
			bus_dmamem_unmap(sc->sc_dmat, sc->adma2, PAGE_SIZE);
			bus_dmamem_free(sc->sc_dmat, sc->adma_segs, rseg);
			goto adma_done;
		}
		error = bus_dmamap_load(sc->sc_dmat, sc->adma_map,
		    sc->adma2, PAGE_SIZE, NULL,
		    BUS_DMA_WAITOK | BUS_DMA_WRITE);
		if (error) {
			bus_dmamap_destroy(sc->sc_dmat, sc->adma_map);
			bus_dmamem_unmap(sc->sc_dmat, sc->adma2, PAGE_SIZE);
			bus_dmamem_free(sc->sc_dmat, sc->adma_segs, rseg);
			goto adma_done;
		}

	adma_done:
		if (error) {
			printf("%s: can't allocate DMA descriptor table\n",
			    DEVNAME(sc));
			CLR(sc->flags, SHF_USE_DMA);
		}
	}

	/*
	 * Attach the generic SD/MMC bus driver.  (The bus driver must
	 * not invoke any chipset functions before it is attached.)
	 */
	bzero(&saa, sizeof(saa));
	saa.saa_busname = "sdmmc";
	saa.sct = &imxesdhc_functions;
	saa.sch = sc;
	saa.dmat = sc->sc_dmat;
	if (ISSET(sc->flags, SHF_USE_DMA))
		saa.caps |= SMC_CAPS_DMA;
	
	if (caps & SDHC_HOST_CTRL_CAP_HSS)
		saa.caps |= SMC_CAPS_MMC_HIGHSPEED;

	width = OF_getpropint(sc->sc_node, "bus-width", 1);
	if (width >= 8)
		saa.caps |= SMC_CAPS_8BIT_MODE;
	if (width >= 4)
		saa.caps |= SMC_CAPS_4BIT_MODE;

	sc->sdmmc = config_found(&sc->sc_dev, &saa, NULL);
	if (sc->sdmmc == NULL) {
		error = 0;
		return;
	}
}

void
imxesdhc_clock_enable(uint32_t phandle)
{
	uint32_t gpios[3];
	int node;

	node = OF_getnodebyphandle(phandle);
	if (node == 0)
		return;

	if (!OF_is_compatible(node, "gpio-gate-clock"))
		return;

	pinctrl_byname(node, "default");

	OF_getpropintarray(node, "enable-gpios", gpios, sizeof(gpios));
	gpio_controller_config_pin(&gpios[0], GPIO_CONFIG_OUTPUT);
	gpio_controller_set_pin(&gpios[0], 1);
}

void
imxesdhc_pwrseq_pre(uint32_t phandle)
{
	uint32_t *gpios, *gpio;
	uint32_t clocks;
	int node;
	int len;

	node = OF_getnodebyphandle(phandle);
	if (node == 0)
		return;

	if (!OF_is_compatible(node, "mmc-pwrseq-simple"))
		return;

	pinctrl_byname(node, "default");

	clocks = OF_getpropint(node, "clocks", 0);
	if (clocks)
		imxesdhc_clock_enable(clocks);

	len = OF_getproplen(node, "reset-gpios");
	if (len <= 0)
		return;

	gpios = malloc(len, M_TEMP, M_WAITOK);
	OF_getpropintarray(node, "reset-gpios", gpios, len);

	gpio = gpios;
	while (gpio && gpio < gpios + (len / sizeof(uint32_t))) {
		gpio_controller_config_pin(gpio, GPIO_CONFIG_OUTPUT);
		gpio_controller_set_pin(gpio, 1);
		gpio = gpio_controller_next_pin(gpio);
	}

	free(gpios, M_TEMP, len);
}

void
imxesdhc_pwrseq_post(uint32_t phandle)
{
	uint32_t *gpios, *gpio;
	int node;
	int len;

	node = OF_getnodebyphandle(phandle);
	if (node == 0)
		return;

	if (!OF_is_compatible(node, "mmc-pwrseq-simple"))
		return;

	len = OF_getproplen(node, "reset-gpios");
	if (len <= 0)
		return;

	gpios = malloc(len, M_TEMP, M_WAITOK);
	OF_getpropintarray(node, "reset-gpios", gpios, len);

	gpio = gpios;
	while (gpio && gpio < gpios + (len / sizeof(uint32_t))) {
		gpio_controller_set_pin(gpio, 0);
		gpio = gpio_controller_next_pin(gpio);
	}

	free(gpios, M_TEMP, len);
}

/*
 * Reset the host controller.  Called during initialization, when
 * cards are removed, upon resume, and during error recovery.
 */
int
imxesdhc_host_reset(sdmmc_chipset_handle_t sch)
{
	struct imxesdhc_softc *sc = sch;
	u_int32_t imask;
	int error;
	int s;

	s = splsdmmc();

	/* Disable all interrupts. */
	HWRITE4(sc, SDHC_INT_STATUS_EN, 0);
	HWRITE4(sc, SDHC_INT_SIGNAL_EN, 0);

	/*
	 * Reset the entire host controller and wait up to 100ms for
	 * the controller to clear the reset bit.
	 */
	if ((error = imxesdhc_soft_reset(sc, SDHC_SYS_CTRL_RSTA)) != 0) {
		splx(s);
		return (error);
	}

	/* Set data timeout counter value to max for now. */
	HSET4(sc, SDHC_SYS_CTRL, 0xe << SDHC_SYS_CTRL_DTOCV_SHIFT);

	/* Enable interrupts. */
	imask = SDHC_INT_STATUS_CC | SDHC_INT_STATUS_TC |
	    SDHC_INT_STATUS_BGE | SDHC_INT_STATUS_DINT |
	    SDHC_INT_STATUS_BRR | SDHC_INT_STATUS_BWR;

	imask |= SDHC_INT_STATUS_CTOE | SDHC_INT_STATUS_CCE |
	    SDHC_INT_STATUS_CEBE | SDHC_INT_STATUS_CIC |
	    SDHC_INT_STATUS_DTOE | SDHC_INT_STATUS_DCE |
	    SDHC_INT_STATUS_DEBE | SDHC_INT_STATUS_DMAE;

	HWRITE4(sc, SDHC_INT_STATUS_EN, imask);
	HWRITE4(sc, SDHC_INT_SIGNAL_EN, imask);

	/* Switch back to no-DMA/SDMA. */
	HCLR4(sc, SDHC_PROT_CTRL, SDHC_PROT_CTRL_DMASEL_MASK);

	/* Switch back to 1-bit bus. */
	HCLR4(sc, SDHC_PROT_CTRL, SDHC_PROT_CTRL_DTW_MASK);

	/* Set watermarks and burst lengths to something sane. */
	HWRITE4(sc, SDHC_WTMK_LVL,
	   (64 << SDHC_WTMK_LVL_RD_WML_SHIFT) |
	   (16 << SDHC_WTMK_LVL_RD_BRST_LEN_SHIFT) |
	   (64 << SDHC_WTMK_LVL_WR_WML_SHIFT) |
	   (16 << SDHC_WTMK_LVL_WR_BRST_LEN_SHIFT));

	splx(s);
	return 0;
}

uint32_t
imxesdhc_host_ocr(sdmmc_chipset_handle_t sch)
{
	struct imxesdhc_softc *sc = sch;

	return sc->ocr;
}

int
imxesdhc_host_maxblklen(sdmmc_chipset_handle_t sch)
{
	struct imxesdhc_softc *sc = sch;

	return sc->maxblklen;
}

/*
 * Return non-zero if the card is currently inserted.
 */
int
imxesdhc_card_detect(sdmmc_chipset_handle_t sch)
{
	struct imxesdhc_softc *sc = sch;

	if (OF_getproplen(sc->sc_node, "non-removable") == 0)
		return 1;

	return gpio_controller_get_pin(sc->sc_gpio);
}

/*
 * Set or change SD bus voltage and enable or disable SD bus power.
 * Return zero on success.
 */
int
imxesdhc_bus_power(sdmmc_chipset_handle_t sch, uint32_t ocr)
{
	struct imxesdhc_softc *sc = sch;
	uint32_t vdd = 0;

	ocr &= sc->ocr;
	if (ISSET(ocr, MMC_OCR_3_2V_3_3V|MMC_OCR_3_3V_3_4V))
		vdd = 3300000;
	else if (ISSET(ocr, MMC_OCR_2_9V_3_0V|MMC_OCR_3_0V_3_1V))
		vdd = 3000000;
	else if (ISSET(ocr, MMC_OCR_1_65V_1_95V))
		vdd = 1800000;

	if (sc->sc_vdd == 0 && vdd > 0)
		imxesdhc_pwrseq_pre(sc->sc_pwrseq);

	/* enable mmc power */
	if (sc->sc_vmmc && vdd > 0)
		regulator_enable(sc->sc_vmmc);

	if (sc->sc_vdd == 0 && vdd > 0)
		imxesdhc_pwrseq_post(sc->sc_pwrseq);

	sc->sc_vdd = vdd;
	return 0;
}

/*
 * Set or change SDCLK frequency or disable the SD clock.
 * Return zero on success.
 */
int
imxesdhc_bus_clock(sdmmc_chipset_handle_t sch, int freq, int timing)
{
	struct imxesdhc_softc *sc = sch;
	int div, pre_div, cur_freq, s;
	int error = 0;

	s = splsdmmc();

	if (sc->clkbase / 16 > freq) {
		for (pre_div = 2; pre_div < 256; pre_div *= 2)
			if ((sc->clkbase / pre_div) <= (freq * 16))
				break;
	} else
		pre_div = 2;

	if (sc->clkbase == freq)
		pre_div = 1;

	for (div = 1; div <= 16; div++)
		if ((sc->clkbase / (div * pre_div)) <= freq)
			break;

	div -= 1;
	pre_div >>= 1;

	cur_freq = sc->clkbase / (pre_div * 2) / (div + 1);

	/* disable force CLK ouput active */
	HCLR4(sc, SDHC_VEND_SPEC, SDHC_VEND_SPEC_FRC_SDCLK_ON);

	/* wait while clock is unstable */
	if ((error = imxesdhc_wait_state(sc,
	    SDHC_PRES_STATE_SDSTB, SDHC_PRES_STATE_SDSTB)) != 0)
		goto ret;

	HCLR4(sc, SDHC_SYS_CTRL, SDHC_SYS_CTRL_CLOCK_MASK);
	HSET4(sc, SDHC_SYS_CTRL,
	    (div << SDHC_SYS_CTRL_CLOCK_DIV_SHIFT) |
	    (pre_div << SDHC_SYS_CTRL_CLOCK_PRE_SHIFT));

	/* wait while clock is unstable */
	if ((error = imxesdhc_wait_state(sc,
	    SDHC_PRES_STATE_SDSTB, SDHC_PRES_STATE_SDSTB)) != 0)
		goto ret;

ret:
	splx(s);
	return error;
}

int
imxesdhc_bus_width(sdmmc_chipset_handle_t sch, int width)
{
	struct imxesdhc_softc *sc = sch;
	uint32_t reg;
	int s;

	if (width != 1 && width != 4 && width != 8)
		return (1);

	s = splsdmmc();

	reg = HREAD4(sc, SDHC_PROT_CTRL) & ~SDHC_PROT_CTRL_DTW_MASK;
	if (width == 4)
		reg |= SDHC_PROT_CTRL_DTW_4BIT;
	else if (width == 8)
		reg |= SDHC_PROT_CTRL_DTW_8BIT;
	HWRITE4(sc, SDHC_PROT_CTRL, reg);

	splx(s);

	return (0);
}

void
imxesdhc_card_intr_mask(sdmmc_chipset_handle_t sch, int enable)
{
	printf("imxesdhc_card_intr_mask\n");
	/* - this is SDIO card interrupt */
	struct imxesdhc_softc *sc = sch;

	if (enable) {
		HSET4(sc, SDHC_INT_STATUS_EN, SDHC_INT_STATUS_CINT);
		HSET4(sc, SDHC_INT_SIGNAL_EN, SDHC_INT_STATUS_CINT);
	} else {
		HCLR4(sc, SDHC_INT_STATUS_EN, SDHC_INT_STATUS_CINT);
		HCLR4(sc, SDHC_INT_SIGNAL_EN, SDHC_INT_STATUS_CINT);
	}
}

void
imxesdhc_card_intr_ack(sdmmc_chipset_handle_t sch)
{
	struct imxesdhc_softc *sc = sch;

	printf("imxesdhc_card_intr_ack\n");

	HWRITE4(sc, SDHC_INT_STATUS, SDHC_INT_STATUS_CINT);
}

int
imxesdhc_wait_state(struct imxesdhc_softc *sc, uint32_t mask, uint32_t value)
{
	uint32_t state;
	int timeout;

	state = HREAD4(sc, SDHC_PRES_STATE);
	DPRINTF(3,("%s: wait_state %x %x %x)\n",
	    HDEVNAME(sc), mask, value, state));
	for (timeout = 1000; timeout > 0; timeout--) {
		if (((state = HREAD4(sc, SDHC_PRES_STATE)) & mask) == value)
			return 0;
		delay(10);
	}
	DPRINTF(0,("%s: timeout waiting for %x, state %x\n",
	    HDEVNAME(sc), value, state));

	return ETIMEDOUT;
}

void
imxesdhc_exec_command(sdmmc_chipset_handle_t sch, struct sdmmc_command *cmd)
{
	struct imxesdhc_softc *sc = sch;
	int error;

	/*
	 * Start the command, or mark `cmd' as failed and return.
	 */
	error = imxesdhc_start_command(sc, cmd);
	if (error != 0) {
		cmd->c_error = error;
		SET(cmd->c_flags, SCF_ITSDONE);
		return;
	}

	/*
	 * Wait until the command phase is done, or until the command
	 * is marked done for any other reason.
	 */
	if (!imxesdhc_wait_intr(sc, SDHC_INT_STATUS_CC, SDHC_COMMAND_TIMEOUT)) {
		cmd->c_error = ETIMEDOUT;
		SET(cmd->c_flags, SCF_ITSDONE);
		return;
	}

	/*
	 * The host controller removes bits [0:7] from the response
	 * data (CRC) and we pass the data up unchanged to the bus
	 * driver (without padding).
	 */
	if (cmd->c_error == 0 && ISSET(cmd->c_flags, SCF_RSP_PRESENT)) {
		if (ISSET(cmd->c_flags, SCF_RSP_136)) {
			cmd->c_resp[0] = HREAD4(sc, SDHC_CMD_RSP0);
			cmd->c_resp[1] = HREAD4(sc, SDHC_CMD_RSP1);
			cmd->c_resp[2] = HREAD4(sc, SDHC_CMD_RSP2);
			cmd->c_resp[3] = HREAD4(sc, SDHC_CMD_RSP3);
#ifdef SDHC_DEBUG
			printf("resp[0] 0x%08x\nresp[1] 0x%08x\n"
			    "resp[2] 0x%08x\nresp[3] 0x%08x\n",
			    cmd->c_resp[0],
			    cmd->c_resp[1],
			    cmd->c_resp[2],
			    cmd->c_resp[3]);
#endif
		} else  {
			cmd->c_resp[0] = HREAD4(sc, SDHC_CMD_RSP0);
#ifdef SDHC_DEBUG
			printf("resp[0] 0x%08x\n", cmd->c_resp[0]);
#endif
		}
	}

	/*
	 * If the command has data to transfer in any direction,
	 * execute the transfer now.
	 */
	if (cmd->c_error == 0 && cmd->c_data)
		imxesdhc_transfer_data(sc, cmd);

	DPRINTF(1,("%s: cmd %u done (flags=%#x error=%d)\n",
	    HDEVNAME(sc), cmd->c_opcode, cmd->c_flags, cmd->c_error));
	SET(cmd->c_flags, SCF_ITSDONE);
}

int
imxesdhc_start_command(struct imxesdhc_softc *sc, struct sdmmc_command *cmd)
{
	struct sdhc_adma2_descriptor32 *desc = (void *)sc->adma2;
	u_int32_t blksize = 0;
	u_int32_t blkcount = 0;
	u_int32_t command;
	int error;
	int seg;
	int s;

	DPRINTF(1,("%s: start cmd %u arg=%#x data=%p dlen=%d flags=%#x "
	    "proc=\"%s\"\n", HDEVNAME(sc), cmd->c_opcode, cmd->c_arg,
	    cmd->c_data, cmd->c_datalen, cmd->c_flags, curproc ?
	    curproc->p_p->ps_comm : ""));

	/*
	 * The maximum block length for commands should be the minimum
	 * of the host buffer size and the card buffer size. (1.7.2)
	 */

	/* Fragment the data into proper blocks. */
	if (cmd->c_datalen > 0) {
		blksize = MIN(cmd->c_datalen, cmd->c_blklen);
		blkcount = cmd->c_datalen / blksize;
		if (cmd->c_datalen % blksize > 0) {
			/* XXX: Split this command. (1.7.4) */
			printf("%s: data not a multiple of %d bytes\n",
			    HDEVNAME(sc), blksize);
			return EINVAL;
		}
	}

	/* Check limit imposed by 9-bit block count. (1.7.2) */
	if (blkcount > SDHC_BLK_ATT_BLKCNT_MAX) {
		printf("%s: too much data\n", HDEVNAME(sc));
		return EINVAL;
	}

	/* Check for write protection. */
	if (!ISSET(cmd->c_flags, SCF_CMD_READ)) {
		if (!(HREAD4(sc, SDHC_PRES_STATE) & SDHC_PRES_STATE_WPSPL)) {
			printf("%s: card is write protected\n",
			    HDEVNAME(sc));
			return EINVAL;
		}
	}

	/* Prepare transfer mode register value. (2.2.5) */
	command = 0;

	if (ISSET(cmd->c_flags, SCF_CMD_READ))
		command |= SDHC_MIX_CTRL_DTDSEL;
	if (blkcount > 0) {
		command |= SDHC_MIX_CTRL_BCEN;
		if (blkcount > 1) {
			command |= SDHC_MIX_CTRL_MSBSEL;
			command |= SDHC_MIX_CTRL_AC12EN;
		}
	}
	if (cmd->c_dmamap && cmd->c_datalen > 0 &&
	    ISSET(sc->flags, SHF_USE_DMA))
		command |= SDHC_MIX_CTRL_DMAEN;

	command |= (cmd->c_opcode << SDHC_CMD_XFR_TYP_CMDINDX_SHIFT) &
	   SDHC_CMD_XFR_TYP_CMDINDX_SHIFT_MASK;

	if (ISSET(cmd->c_flags, SCF_RSP_CRC))
		command |= SDHC_CMD_XFR_TYP_CCCEN;
	if (ISSET(cmd->c_flags, SCF_RSP_IDX))
		command |= SDHC_CMD_XFR_TYP_CICEN;
	if (cmd->c_data != NULL)
		command |= SDHC_CMD_XFR_TYP_DPSEL;

	if (!ISSET(cmd->c_flags, SCF_RSP_PRESENT))
		command |= SDHC_CMD_XFR_TYP_RSP_NONE;
	else if (ISSET(cmd->c_flags, SCF_RSP_136))
		command |= SDHC_CMD_XFR_TYP_RSP136;
	else if (ISSET(cmd->c_flags, SCF_RSP_BSY))
		command |= SDHC_CMD_XFR_TYP_RSP48B;
	else
		command |= SDHC_CMD_XFR_TYP_RSP48;

	/* Wait until command and data inhibit bits are clear. (1.5) */
	if ((error = imxesdhc_wait_state(sc, SDHC_PRES_STATE_CIHB, 0)) != 0)
		return error;

	s = splsdmmc();

	/* Set DMA start address if SHF_USE_DMA is set. */
	if (cmd->c_dmamap && ISSET(sc->flags, SHF_USE_DMA)) {
		for (seg = 0; seg < cmd->c_dmamap->dm_nsegs; seg++) {
			bus_addr_t paddr =
			    cmd->c_dmamap->dm_segs[seg].ds_addr;
			uint16_t len =
			    cmd->c_dmamap->dm_segs[seg].ds_len == 65536 ?
			    0 : cmd->c_dmamap->dm_segs[seg].ds_len;
			uint16_t attr;

			attr = SDHC_ADMA2_VALID | SDHC_ADMA2_ACT_TRANS;
			if (seg == cmd->c_dmamap->dm_nsegs - 1)
				attr |= SDHC_ADMA2_END;

			desc[seg].attribute = htole16(attr);
			desc[seg].length = htole16(len);
			desc[seg].address = htole32(paddr);
		}

		desc[cmd->c_dmamap->dm_nsegs].attribute = htole16(0);

		bus_dmamap_sync(sc->sc_dmat, sc->adma_map, 0, PAGE_SIZE,
		    BUS_DMASYNC_PREWRITE);

		HCLR4(sc, SDHC_PROT_CTRL, SDHC_PROT_CTRL_DMASEL_MASK);
		HSET4(sc, SDHC_PROT_CTRL, SDHC_PROT_CTRL_DMASEL_ADMA2);

		HWRITE4(sc, SDHC_ADMA_SYS_ADDR,
		    sc->adma_map->dm_segs[0].ds_addr);
	}

	/*
	 * Start a CPU data transfer.  Writing to the high order byte
	 * of the SDHC_COMMAND register triggers the SD command. (1.5)
	 */
	HWRITE4(sc, SDHC_BLK_ATT, blkcount << SDHC_BLK_ATT_BLKCNT_SHIFT |
	    blksize << SDHC_BLK_ATT_BLKSIZE_SHIFT);
	HWRITE4(sc, SDHC_CMD_ARG, cmd->c_arg);
	HWRITE4(sc, SDHC_MIX_CTRL,
	    (HREAD4(sc, SDHC_MIX_CTRL) & (0xf << 22)) | (command & 0xffff));
	HWRITE4(sc, SDHC_CMD_XFR_TYP, command);

	splx(s);
	return 0;
}

void
imxesdhc_transfer_data(struct imxesdhc_softc *sc, struct sdmmc_command *cmd)
{
	u_char *datap = cmd->c_data;
	int i, datalen;
	int mask;
	int error;

	if (cmd->c_dmamap) {
		int status;

		error = 0;
		for (;;) {
			status = imxesdhc_wait_intr(sc,
			    SDHC_INT_STATUS_DINT|SDHC_INT_STATUS_TC,
			    SDHC_DMA_TIMEOUT);
			if (status & SDHC_INT_STATUS_TC)
				break;
			if (!status) {
				error = ETIMEDOUT;
				break;
			}
		}

		bus_dmamap_sync(sc->sc_dmat, sc->adma_map, 0, PAGE_SIZE,
		    BUS_DMASYNC_POSTWRITE);
		goto done;
	}

	mask = ISSET(cmd->c_flags, SCF_CMD_READ) ?
	    SDHC_PRES_STATE_BREN : SDHC_PRES_STATE_BWEN;
	error = 0;
	datalen = cmd->c_datalen;

	DPRINTF(1,("%s: resp=%#x datalen=%d\n",
	    HDEVNAME(sc), MMC_R1(cmd->c_resp), datalen));

	while (datalen > 0) {
		if (!imxesdhc_wait_intr(sc,
		    SDHC_INT_STATUS_BRR | SDHC_INT_STATUS_BWR,
		    SDHC_BUFFER_TIMEOUT)) {
			error = ETIMEDOUT;
			break;
		}

		if ((error = imxesdhc_wait_state(sc, mask, mask)) != 0)
			break;

		/* FIXME: wait a bit, else it fails */
		delay(100);
		i = MIN(datalen, cmd->c_blklen);
		if (ISSET(cmd->c_flags, SCF_CMD_READ))
			imxesdhc_read_data(sc, datap, i);
		else
			imxesdhc_write_data(sc, datap, i);

		datap += i;
		datalen -= i;
	}

	if (error == 0 && !imxesdhc_wait_intr(sc, SDHC_INT_STATUS_TC,
	    SDHC_TRANSFER_TIMEOUT))
		error = ETIMEDOUT;

done:
	if (error != 0)
		cmd->c_error = error;
	SET(cmd->c_flags, SCF_ITSDONE);

	DPRINTF(1,("%s: data transfer done (error=%d)\n",
	    HDEVNAME(sc), cmd->c_error));
}

void
imxesdhc_read_data(struct imxesdhc_softc *sc, u_char *datap, int datalen)
{
	while (datalen > 3) {
		*(uint32_t *)datap = HREAD4(sc, SDHC_DATA_BUFF_ACC_PORT);
		datap += 4;
		datalen -= 4;
	}
	if (datalen > 0) {
		uint32_t rv = HREAD4(sc, SDHC_DATA_BUFF_ACC_PORT);
		do {
			*datap++ = rv & 0xff;
			rv = rv >> 8;
		} while (--datalen > 0);
	}
}

void
imxesdhc_write_data(struct imxesdhc_softc *sc, u_char *datap, int datalen)
{
	while (datalen > 3) {
		DPRINTF(3,("%08x\n", *(uint32_t *)datap));
		HWRITE4(sc, SDHC_DATA_BUFF_ACC_PORT, *((uint32_t *)datap));
		datap += 4;
		datalen -= 4;
	}
	if (datalen > 0) {
		uint32_t rv = *datap++;
		if (datalen > 1)
			rv |= *datap++ << 8;
		if (datalen > 2)
			rv |= *datap++ << 16;
		DPRINTF(3,("rv %08x\n", rv));
		HWRITE4(sc, SDHC_DATA_BUFF_ACC_PORT, rv);
	}
}

/* Prepare for another command. */
int
imxesdhc_soft_reset(struct imxesdhc_softc *sc, int mask)
{
	int timo;

	DPRINTF(1,("%s: software reset reg=%#x\n", HDEVNAME(sc), mask));

	/* disable force CLK ouput active */
	HCLR4(sc, SDHC_VEND_SPEC, SDHC_VEND_SPEC_FRC_SDCLK_ON);

	/* reset */
	HSET4(sc, SDHC_SYS_CTRL, mask);
	delay(10);

	for (timo = 1000; timo > 0; timo--) {
		if (!ISSET(HREAD4(sc, SDHC_SYS_CTRL), mask))
			break;
		delay(10);
	}
	if (timo == 0) {
		DPRINTF(1,("%s: timeout reg=%#x\n", HDEVNAME(sc),
		    HREAD4(sc, SDHC_SYS_CTRL)));
		return ETIMEDOUT;
	}

	return 0;
}

int
imxesdhc_wait_intr(struct imxesdhc_softc *sc, int mask, int timo)
{
	int status;
	int s;

	mask |= SDHC_INT_STATUS_ERR;
	s = splsdmmc();

	/* enable interrupts for brr and bwr */
	if (mask & (SDHC_INT_STATUS_BRR | SDHC_INT_STATUS_BWR))
		HSET4(sc, SDHC_INT_SIGNAL_EN,
		    (SDHC_INT_STATUS_BRR | SDHC_INT_STATUS_BWR));

	status = sc->intr_status & mask;
	while (status == 0) {
		if (tsleep(&sc->intr_status, PWAIT, "hcintr", timo)
		    == EWOULDBLOCK) {
			status |= SDHC_INT_STATUS_ERR;
			break;
		}
		status = sc->intr_status & mask;
	}
	sc->intr_status &= ~status;
	DPRINTF(2,("%s: intr status %#x error %#x\n", HDEVNAME(sc), status,
	    sc->intr_error_status));

	/* Command timeout has higher priority than command complete. */
	if (ISSET(status, SDHC_INT_STATUS_ERR)) {
		sc->intr_error_status = 0;
		(void)imxesdhc_soft_reset(sc,
		    SDHC_SYS_CTRL_RSTC | SDHC_SYS_CTRL_RSTD);
		status = 0;
	}

	splx(s);
	return status;
}

/*
 * Established by attachment driver at interrupt priority IPL_SDMMC.
 */
int
imxesdhc_intr(void *arg)
{
	struct imxesdhc_softc *sc = arg;

	u_int32_t status;

	/* Find out which interrupts are pending. */
	status = HREAD4(sc, SDHC_INT_STATUS);

	/* disable interrupts for brr and bwr, else we get flooded */
	if (status & (SDHC_INT_STATUS_BRR | SDHC_INT_STATUS_BWR))
		HCLR4(sc, SDHC_INT_SIGNAL_EN,
		    (SDHC_INT_STATUS_BRR | SDHC_INT_STATUS_BWR));

	/* Acknowledge the interrupts we are about to handle. */
	HWRITE4(sc, SDHC_INT_STATUS, status);
	DPRINTF(2,("%s: interrupt status=0x%08x\n", HDEVNAME(sc), status));

	/*
	 * Service error interrupts.
	 */
	if (ISSET(status, SDHC_INT_STATUS_CMD_ERR |
	    SDHC_INT_STATUS_CTOE | SDHC_INT_STATUS_DTOE)) {
		sc->intr_status |= status;
		sc->intr_error_status |= status & 0xffff0000;
		wakeup(&sc->intr_status);
	}

	/*
	 * Wake up the blocking process to service command
	 * related interrupt(s).
	 */
	if (ISSET(status, SDHC_INT_STATUS_BRR | SDHC_INT_STATUS_BWR |
	    SDHC_INT_STATUS_TC | SDHC_INT_STATUS_CC)) {
		sc->intr_status |= status;
		wakeup(&sc->intr_status);
	}

	/*
	 * Service SD card interrupts.
	 */
	if (ISSET(status, SDHC_INT_STATUS_CINT)) {
		DPRINTF(0,("%s: card interrupt\n", HDEVNAME(sc)));
		HCLR4(sc, SDHC_INT_STATUS, SDHC_INT_STATUS_CINT);
		sdmmc_card_intr(sc->sdmmc);
	}

	return 1;
}
@


1.35
log
@Use the generic clock framework.

ok jsg@@, patrick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: imxesdhc.c,v 1.34 2016/09/05 12:45:44 mglocker Exp $	*/
d860 1
a860 1
	    curproc->p_comm : ""));
@


1.34
log
@Some spacing/knf while here.  No functional changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: imxesdhc.c,v 1.33 2016/09/05 12:24:24 mglocker Exp $	*/
a33 3
#include <armv7/armv7/armv7var.h>
#include <armv7/imx/imxccmvar.h>

d35 1
a185 1
	int			 unit;		/* unit id */
a300 1
	sc->unit = (faa->fa_reg[0].addr & 0xc000) >> 14;
d338 1
a338 1
	sc->clkbase = imxccm_get_usdhx(sc->unit + 1);
@


1.33
log
@No point to jump to an empty return label in a void function.
@
text
@d1 1
a1 1
/*	$OpenBSD: imxesdhc.c,v 1.32 2016/09/05 11:29:55 mglocker Exp $	*/
a21 1

d44 29
a72 29
#define SDHC_DS_ADDR			0x00
#define SDHC_BLK_ATT			0x04
#define SDHC_CMD_ARG			0x08
#define SDHC_CMD_XFR_TYP		0x0c
#define SDHC_CMD_RSP0			0x10
#define SDHC_CMD_RSP1			0x14
#define SDHC_CMD_RSP2			0x18
#define SDHC_CMD_RSP3			0x1c
#define SDHC_DATA_BUFF_ACC_PORT		0x20
#define SDHC_PRES_STATE			0x24
#define SDHC_PROT_CTRL			0x28
#define SDHC_SYS_CTRL			0x2c
#define SDHC_INT_STATUS			0x30
#define SDHC_INT_STATUS_EN		0x34
#define SDHC_INT_SIGNAL_EN		0x38
#define SDHC_AUTOCMD12_ERR_STATUS	0x3c
#define SDHC_HOST_CTRL_CAP		0x40
#define SDHC_WTMK_LVL			0x44
#define SDHC_MIX_CTRL			0x48
#define SDHC_FORCE_EVENT		0x50
#define SDHC_ADMA_ERR_STATUS		0x54
#define SDHC_ADMA_SYS_ADDR		0x58
#define SDHC_DLL_CTRL			0x60
#define SDHC_DLL_STATUS			0x64
#define SDHC_CLK_TUNE_CTRL_STATUS	0x68
#define SDHC_VEND_SPEC			0xc0
#define SDHC_MMC_BOOT			0xc4
#define SDHC_VEND_SPEC2			0xc8
#define SDHC_HOST_CTRL_VER		0xfc
d152 12
a163 12
#define SDHC_COMMAND_TIMEOUT	hz
#define SDHC_BUFFER_TIMEOUT	hz
#define SDHC_TRANSFER_TIMEOUT	hz
#define SDHC_DMA_TIMEOUT	(3*hz)

#define SDHC_ADMA2_VALID	(1<<0)
#define SDHC_ADMA2_END		(1<<1)
#define SDHC_ADMA2_INT		(1<<2)
#define SDHC_ADMA2_ACT		(3<<4)
#define SDHC_ADMA2_ACT_NOP	(0<<4)
#define SDHC_ADMA2_ACT_TRANS	(2<<4)
#define SDHC_ADMA2_ACT_LINK	(3<<4)
d176 10
a185 10
	struct device sc_dev;
	bus_space_tag_t		sc_iot;
	bus_space_handle_t	sc_ioh;
	bus_dma_tag_t		sc_dmat;
	void			*sc_ih; /* Interrupt handler */
	int			sc_node;
	uint32_t		sc_gpio[3];
	uint32_t		sc_vmmc;
	uint32_t		sc_pwrseq;
	uint32_t		sc_vdd;
d188 13
a200 13
	int unit;			/* unit id */
	struct device *sdmmc;		/* generic SD/MMC device */
	int clockbit;			/* clock control bit */
	u_int clkbase;			/* base clock frequency in KHz */
	int maxblklen;			/* maximum block length */
	int flags;			/* flags for this host */
	uint32_t ocr;			/* OCR value from capabilities */
	uint32_t intr_status;		/* soft interrupt status */
	uint32_t intr_error_status;	/*  */

	bus_dmamap_t adma_map;
	bus_dma_segment_t adma_segs[1];
	caddr_t adma2;
d218 1
a218 1
#define SHF_USE_DMA		0x0001
a425 1

d602 1
d610 1
d696 2
a697 1
	if ((error = imxesdhc_wait_state(sc, SDHC_PRES_STATE_SDSTB, SDHC_PRES_STATE_SDSTB)) != 0)
d701 3
a703 1
	HSET4(sc, SDHC_SYS_CTRL, (div << SDHC_SYS_CTRL_CLOCK_DIV_SHIFT) | (pre_div << SDHC_SYS_CTRL_CLOCK_PRE_SHIFT));
d706 2
a707 1
	if ((error = imxesdhc_wait_state(sc, SDHC_PRES_STATE_SDSTB, SDHC_PRES_STATE_SDSTB)) != 0)
d758 2
a760 1
	struct imxesdhc_softc *sc = sch;
d770 1
d772 2
a773 2
	DPRINTF(3,("%s: wait_state %x %x %x)\n", HDEVNAME(sc),
	    mask, value, state));
d779 3
a781 2
	DPRINTF(0,("%s: timeout waiting for %x, state %x\n", HDEVNAME(sc),
	    value, state));
a821 1

d823 6
a828 1
			printf("resp[0] 0x%08x\nresp[1] 0x%08x\nresp[2] 0x%08x\nresp[3] 0x%08x\n", cmd->c_resp[0], cmd->c_resp[1], cmd->c_resp[2], cmd->c_resp[3]);
d1019 2
a1020 2
	DPRINTF(1,("%s: resp=%#x datalen=%d\n", HDEVNAME(sc),
	    MMC_R1(cmd->c_resp), datalen));
d1023 2
a1024 1
		if (!imxesdhc_wait_intr(sc, SDHC_INT_STATUS_BRR | SDHC_INT_STATUS_BWR,
d1135 2
a1136 1
		HSET4(sc, SDHC_INT_SIGNAL_EN, (SDHC_INT_STATUS_BRR | SDHC_INT_STATUS_BWR));
d1154 2
a1155 1
		(void)imxesdhc_soft_reset(sc, SDHC_SYS_CTRL_RSTC | SDHC_SYS_CTRL_RSTD);
d1178 2
a1179 1
		HCLR4(sc, SDHC_INT_SIGNAL_EN, (SDHC_INT_STATUS_BRR | SDHC_INT_STATUS_BWR));
d1183 1
a1183 2
	DPRINTF(2,("%s: interrupt status=0x%08x\n", HDEVNAME(sc),
	    status));
d1213 1
@


1.32
log
@Remove some unused bits.

ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: imxesdhc.c,v 1.31 2016/08/27 17:32:35 kettenis Exp $	*/
d331 1
a331 1
		goto err;
d448 1
a448 1
		goto err;
a449 5
	
	return;

err:
	return;
@


1.31
log
@Initialize vdd to 0 in imxesdhc_bus_power() to avoiud using it uninitialized.
@
text
@d1 1
a1 1
/*	$OpenBSD: imxesdhc.c,v 1.30 2016/08/13 11:08:58 kettenis Exp $	*/
a195 1
//	u_int8_t regs[14];		/* host controller state */
a204 3
int	imxesdhc_host_found(struct imxesdhc_softc *, bus_space_tag_t,
	    bus_space_handle_t, bus_size_t, int);
void	imxesdhc_shutdown(void *);
a542 12
}

/*
 * Shutdown hook established by or called from attachment driver.
 */
void
imxesdhc_shutdown(void *arg)
{
	struct imxesdhc_softc *sc = arg;

	/* XXX chip locks up if we don't disable it before reboot. */
	(void)imxesdhc_host_reset(sc);
@


1.30
log
@Use regulalator API instead of private functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: imxesdhc.c,v 1.29 2016/08/08 10:10:56 kettenis Exp $	*/
d657 1
a657 1
	uint32_t vdd;
@


1.29
log
@Implement mmc power sequencing; makes the sdo interface on the cubox-i work
and see the BCM4330 wireless (for which we don't have a driver yet).

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: imxesdhc.c,v 1.28 2016/08/06 17:18:38 kettenis Exp $	*/
d41 1
a210 1
void	imxesdhc_enable_vbus(uint32_t);
a461 29
imxesdhc_enable_vbus(uint32_t phandle)
{
	uint32_t gpio[3];
	int active;
	int node;

	node = OF_getnodebyphandle(phandle);
	if (node == 0)
		return;

	if (!OF_is_compatible(node, "regulator-fixed"))
		return;

	pinctrl_byname(node, "default");

	if (OF_getproplen(node, "enable-active-high") == 0)
		active = 1;
	else
		active = 0;

	if (OF_getpropintarray(node, "gpio", gpio,
	    sizeof(gpio)) != sizeof(gpio))
		return;
	
	gpio_controller_config_pin(gpio, GPIO_CONFIG_OUTPUT);
	gpio_controller_set_pin(gpio, active);
}

void
d672 1
a672 1
		imxesdhc_enable_vbus(sc->sc_vmmc);
@


1.28
log
@Switch imx over to the generic pinctrl API.

ok patrick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: imxesdhc.c,v 1.27 2016/08/04 15:52:52 kettenis Exp $	*/
d183 3
a206 1
void	imxesdhc_power(int, void *);
d210 5
d328 3
d461 86
a547 3
/*
 * Power hook established by or called from attachment driver.
 */
d549 1
a549 1
imxesdhc_power(int why, void *arg)
d551 25
d685 22
@


1.27
log
@Dynamically attach ampintc(4) and make it register itself as an interrupt
controller.  Switch all i.MX6 devices over to the new FDT-aware interrupt
establish API and enable imxgpc(4).

This may break other platforms that use ampintc(4) as their interrupt
controller.  We will fix this as soon as possible by switching them over
to the new interrupt establish API as well.

This also removes the hack in fec(4) to avoid the gpio-based interrupt
workaround.  This commit is an essential step on the road to fix that
issue properly.

ok patrick@@, jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: imxesdhc.c,v 1.26 2016/07/27 11:45:02 patrick Exp $	*/
a36 2
#include <armv7/imx/imxgpiovar.h>
#include <armv7/imx/imxiomuxcvar.h>
d40 1
d312 1
a312 1
	imxiomuxc_pinctrlbyname(faa->fa_node, "default");
@


1.26
log
@Instead of passing the raw reg property to simplebus nodes,
pass a pre-processed array of fdt_reg structs.  This means
that the drivers don't have to understand the cell properties
themselves but can rely on the 64-bit addr/size pairs.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: imxesdhc.c,v 1.25 2016/07/11 14:54:18 kettenis Exp $	*/
d300 1
a300 1
	if (faa->fa_nreg < 1 || faa->fa_nintr < 3)
d315 1
a315 1
	sc->sc_ih = arm_intr_establish(faa->fa_intr[1], IPL_SDMMC,
@


1.25
log
@Use gpio framework to implement card detect instead of hardcoding particular
gpios based on board IDs.

ok visa@@, jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: imxesdhc.c,v 1.24 2016/07/10 11:46:28 kettenis Exp $	*/
d42 1
d300 1
a300 1
	if (faa->fa_nreg < 2 || faa->fa_nintr < 3)
d303 1
a303 1
	sc->unit = (faa->fa_reg[0] & 0xc000) >> 14;
d307 2
a308 2
	if (bus_space_map(sc->sc_iot, faa->fa_reg[0],
	    faa->fa_reg[1], 0, &sc->sc_ioh))
@


1.24
log
@Add support for handling pinctrl device tree bindings to imxiomuxc(4).
These are used to do board-specific setup of mux settings and pad
configuration.

ok jsg@@, patrick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: imxesdhc.c,v 1.23 2016/06/14 14:41:03 kettenis Exp $	*/
d41 1
d182 1
d317 4
a552 1
	int gpio;
d557 1
a557 76
	switch (board_id)
	{
	case BOARD_ID_IMX6_CUBOXI:
	case BOARD_ID_IMX6_HUMMINGBOARD:
		switch (sc->unit) {
			case 1:
				gpio = 0*32 + 4;
				break;
			default:
				return 0;
		}
		imxgpio_set_dir(gpio, IMXGPIO_DIR_IN);
		return imxgpio_get_bit(gpio) ? 0 : 1;
	case BOARD_ID_IMX6_SABRELITE:
		switch (sc->unit) {
			case 2:
				gpio = 6*32 + 0;
				break;
			case 3:
				gpio = 1*32 + 6;
				break;
			default:
				return 0;
		}
		imxgpio_set_dir(gpio, IMXGPIO_DIR_IN);
		return imxgpio_get_bit(gpio) ? 0 : 1;
	case BOARD_ID_IMX6_SABRESD:
		switch (sc->unit) {
			case 1:
				gpio = 1*32 + 2;
				break;
			case 2:
				gpio = 1*32 + 0;
				break;
			default:
				return 0;
		}
		imxgpio_set_dir(gpio, IMXGPIO_DIR_IN);
		return imxgpio_get_bit(gpio) ? 0 : 1;
	case BOARD_ID_IMX6_UTILITE:
		switch (sc->unit) {
			case 2:
				gpio = 6*32 + 1;
				break;
			default:
				return 0;
		}
		imxgpio_set_dir(gpio, IMXGPIO_DIR_IN);
		return imxgpio_get_bit(gpio) ? 0 : 1;
	case BOARD_ID_IMX6_NOVENA:
		switch (sc->unit) {
			case 1:
				gpio = 0*32 + 4;
				break;
			default:
				return 0;
		}
		imxgpio_set_dir(gpio, IMXGPIO_DIR_IN);
		return imxgpio_get_bit(gpio) ? 0 : 1;
	case BOARD_ID_IMX6_WANDBOARD:
		switch (sc->unit) {
			case 0:
				gpio = 0*32 + 2;
				break;
			case 2:
				gpio = 2*32 + 9;
				break;
			default:
				return 0;
		}
		imxgpio_set_dir(gpio, IMXGPIO_DIR_IN);
		return imxgpio_get_bit(gpio) ? 0 : 1;
	default:
		printf("%s: unhandled board\n", __func__);
		return 1;
	}
@


1.23
log
@If the FDT node has a "non-removable" property, return 1 from the card
detect function.  Remove the board-specific return 1 cases as they all
match the case of a "non-removable" property.

Note that this introduces a

  sdmmc0: can't enable card

message on the CuBox-i as is has the internal eMMC controller enabled in
its device tree even though there is no eMMC soldered onto the board.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: imxesdhc.c,v 1.22 2016/06/13 12:24:05 kettenis Exp $	*/
d38 1
d309 2
@


1.22
log
@Use "bus-width" property to determine whether 4-bit and 8-bit mode are
supported.
@
text
@d1 1
a1 1
/*	$OpenBSD: imxesdhc.c,v 1.21 2016/06/09 15:38:30 kettenis Exp $	*/
a197 1

d546 3
a582 2
			case 3:
				return 1;
a587 7
	case BOARD_ID_IMX6_UDOO:
		switch (sc->unit) {
			case 2:
				return 1;
			default:
				return 0;
		}
a602 3
			/* no card detect */
			case 2:
				return 1;
@


1.21
log
@Dynamically attach imxesdhc(4) using the FDT.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: imxesdhc.c,v 1.20 2016/05/19 09:54:18 jsg Exp $	*/
d179 1
d295 1
d301 1
a417 1
	saa.caps = SMC_CAPS_4BIT_MODE;
d424 6
@


1.20
log
@Remove the PHYTEC phyFLEX support code, patrick says he no longer
has the hardware for the eval kit.

ok patrick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: imxesdhc.c,v 1.19 2016/05/15 22:10:24 kettenis Exp $	*/
d30 1
d39 2
d170 2
a171 3
void imxesdhc_attach(struct device *parent, struct device *self, void *args);

#include <machine/bus.h>
d275 1
a275 1
	sizeof(struct imxesdhc_softc), NULL, imxesdhc_attach
d278 8
d287 1
a287 1
imxesdhc_attach(struct device *parent, struct device *self, void *args)
d289 14
a302 11
	struct imxesdhc_softc		*sc = (struct imxesdhc_softc *) self;
	struct armv7_attach_args	*aa = args;
	struct sdmmcbus_attach_args	 saa;
	int				 error = 1;
	uint32_t			 caps;

	sc->unit = aa->aa_dev->unit;
	sc->sc_dmat = aa->aa_dmat;
	sc->sc_iot = aa->aa_iot;
	if (bus_space_map(sc->sc_iot, aa->aa_dev->mem[0].addr,
	    aa->aa_dev->mem[0].size, 0, &sc->sc_ioh))
d307 1
a307 3
	/* XXX DMA channels? */

	sc->sc_ih = arm_intr_establish(aa->aa_dev->irq[0], IPL_SDMMC,
d326 1
a326 1
	sc->clkbase = imxccm_get_usdhx(aa->aa_dev->unit + 1);
@


1.19
log
@Map the ADMA2 descriptor table use BUS_DMA_COHERENT and add a missing
bus_dmamap_sync(9).  Doesn't really fix anything, but adding the missing
sync makes the code more correct.  Using BUS_DMA_COHERENT avoids some
cache flushes.
@
text
@d1 1
a1 1
/*	$OpenBSD: imxesdhc.c,v 1.18 2016/05/08 20:22:03 kettenis Exp $	*/
a534 13
				break;
			default:
				return 0;
		}
		imxgpio_set_dir(gpio, IMXGPIO_DIR_IN);
		return imxgpio_get_bit(gpio) ? 0 : 1;
	case BOARD_ID_IMX6_PHYFLEX:
		switch (sc->unit) {
			case 1:
				gpio = 0*32 + 4;
				break;
			case 2:
				gpio = 0*32 + 27;
@


1.18
log
@Add DMA support.  It uses ADMA2 "Internal DMA" that is compatible with the
SD Host Controller standard.

ok patrick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: imxesdhc.c,v 1.17 2016/05/07 00:11:31 jsg Exp $	*/
d365 1
a365 1
		    PAGE_SIZE, &sc->adma2, BUS_DMA_WAITOK);
d979 2
@


1.17
log
@add support for changing the bus width and set the 4-bit mode capability
ok patrick@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: imxesdhc.c,v 1.16 2016/05/06 20:24:35 kettenis Exp $	*/
d130 4
a133 1
#define SDHC_PROT_CTRL_DMASEL_SDMA_MASK		(0x3 << 8)
d136 1
d143 1
d145 1
d150 16
d175 1
d189 4
d286 1
d308 4
d317 2
d355 40
d405 4
d477 1
a477 4
	    SDHC_INT_STATUS_BGE |
#ifdef SDHC_DMA
	    SHDC_INT_STATUS_DINT;
#else
a478 1
#endif
d488 2
a489 3
	// Use no or simple DMA
	HWRITE4(sc, SDHC_PROT_CTRL,
	    HREAD4(sc, SDHC_PROT_CTRL) & ~SDHC_PROT_CTRL_DMASEL_SDMA_MASK);
d494 7
d823 1
d828 1
d859 1
a859 1
	/* setup for PIO, check for write protection */
a867 14
#ifdef SDHC_DMA
	/* set watermark level */
	uint32_t wml = blksize / sizeof(uint32_t);
	if (ISSET(cmd->c_flags, SCF_CMD_READ)) {
		if (wml > 16)
			wml = 16;
		HWRITE4(sc, SDHC_WTMK_LVL, wml << SDHC_WTMK_LVL_RD_WML_SHIFT);
	} else {
		if (wml > 128)
			wml = 128;
		HWRITE4(sc, SDHC_WTMK_LVL, wml << SDHC_WTMK_LVL_WR_WML_SHIFT);
	}
#endif

a874 3
#ifdef SDHC_DMA
		command |= SDHC_MIX_CTRL_DMAEN;
#endif
d880 3
d909 31
a943 4
#ifdef SDHC_DMA
	if (cmd->c_data)
		HWRITE4(sc, SDHC_DS_ADDR, (uint32_t)cmd->c_data);
#endif
a957 1
#ifndef SDHC_DMA
d959 1
a959 3
	int i;
#endif
	int datalen;
d963 19
a989 1
#ifndef SDHC_DMA
a1010 1
#endif
d1016 1
a1140 1
#ifndef SDHC_DMA
a1143 1
#endif
@


1.16
log
@Reset the bus width back to 1-bit when resetting the host.  Makes imxesdhc(4)
work on the cubox-i, whereu-boot leaves the controller in 4-bit mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: imxesdhc.c,v 1.15 2016/05/05 11:01:08 kettenis Exp $	*/
d202 1
d233 1
a233 1
	NULL,
d330 1
d610 24
@


1.15
log
@Add Dual Data Rate support for eMMC at 52MHz.
@
text
@d1 1
a1 1
/*	$OpenBSD: imxesdhc.c,v 1.14 2016/05/01 16:04:39 kettenis Exp $	*/
d127 3
d415 3
@


1.14
log
@Add support for changing the bus width to the sdmmc subsystem and the sdhc(4)
controller.  Use this to switch SD cards to a 4-bit bus if they support it.

ok deraadt@@, jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: imxesdhc.c,v 1.13 2016/01/10 14:11:43 kettenis Exp $	*/
d198 1
a198 1
int	imxesdhc_bus_clock(sdmmc_chipset_handle_t, int);
d558 1
a558 1
imxesdhc_bus_clock(sdmmc_chipset_handle_t sch, int freq)
@


1.13
log
@Seems the voltage bit defenitions in sdmmcreg.h for voltages below 2V
are not quite right.  At least I can't find them in any of the MMC and
SD card documentation I can find on the interwebs.  Instead there is a
single "low voltage bit" that indicates support for the 1.65-1.95V or
1.70-1.95V range depending on the document you're reading.  Go with the
1.65-1.95V range as that is what Linux does.

Necessary (but not sufficient) to make the eMMC on the ASUS X205TA work.

ok jsg@@ (who did the armv7 bits)
@
text
@d1 1
a1 1
/*	$OpenBSD: imxesdhc.c,v 1.12 2015/05/30 03:20:54 jsg Exp $	*/
d229 1
@


1.12
log
@Set the sdmmc(4) emmc highspeed flag if the capability register claims
it is supported.
@
text
@d1 1
a1 1
/*	$OpenBSD: imxesdhc.c,v 1.11 2015/05/30 02:17:36 jsg Exp $	*/
d284 1
a284 1
		SET(sc->ocr, MMC_OCR_1_7V_1_8V | MMC_OCR_1_8V_1_9V);
@


1.11
log
@fix the build when SDHC_DEBUG is defined
@
text
@d1 1
a1 1
/*	$OpenBSD: imxesdhc.c,v 1.10 2015/05/17 12:28:03 jsg Exp $	*/
d130 1
d325 2
@


1.10
log
@Checking the dts files turned up some more imx sdhc problems.
- use the correct CD gpios on phyflex and wandboard usdhc3 (unit 2)
- udoo has just the one sd slot with no CD
@
text
@d1 1
a1 1
/*	$OpenBSD: imxesdhc.c,v 1.9 2015/05/17 11:18:05 jsg Exp $	*/
d638 1
a638 1
	DPRINTF(0,("%s: timeout waiting for %x\n", HDEVNAME(sc),
d713 1
a713 1
	DPRINTF(1,("%s: start cmd %u arg=%#x data=%#x dlen=%d flags=%#x "
d1004 1
a1004 1
	    status, status));
@


1.9
log
@add missing calls to set the gpio direction before reading the
card detect gpio on phyflex/sabre lite/wandboard
@
text
@d1 1
a1 1
/*	$OpenBSD: imxesdhc.c,v 1.8 2015/05/15 17:01:18 jsg Exp $	*/
d440 7
a446 1
		gpio = 0*32 + 4;
a448 1
		break;
d452 1
a452 1
				gpio = 0*32 + 2;
d455 1
a455 1
				gpio = 4*32 + 22;
a491 6
			/*
			 * One of these is the SD card, another the wifi
			 * the third is not connected (?)
			 */
			case 0:
			case 1:
d493 1
a493 3
			case 3:
				gpio = 3*32 + 9;
				break;
a496 1
		return 1;
d526 1
a526 1
				gpio = 3*32 + 9;
@


1.8
log
@Decrement the unit numbers on the novena sdhc devices.  The imx6 dts
files seem to have labels numbered one higher than the nodes they are
assigned to.

Tested by djm
@
text
@d1 1
a1 1
/*	$OpenBSD: imxesdhc.c,v 1.7 2015/05/08 03:38:26 jsg Exp $	*/
d455 1
d468 1
a496 1
				return 1;
d535 1
@


1.7
log
@Add initial board specific parts of novena support, tested by djm@@
While novena has it's own board id it's u-boot does not set it.
"setenv machid 10ad" in u-boot will set the novena board id (0x10ad/4269).
@
text
@d1 1
a1 1
/*	$OpenBSD: imxesdhc.c,v 1.6 2015/03/29 03:24:17 jsg Exp $	*/
d512 1
a512 1
			case 2:
d515 2
a516 2
			/* no card detect for uSD */
			case 3:
@


1.6
log
@initial support for the SABRE SD board
from Patrick Wildt in Bitrig
@
text
@d1 1
a1 1
/*	$OpenBSD: imxesdhc.c,v 1.5 2015/01/02 01:57:33 jsg Exp $	*/
d505 13
@


1.5
log
@Add some additional i.MX6 board types from Bitrig.
CompuLab Utilite, SolidRun HummingBoard/CuBox-i and UDOO.
@
text
@d1 1
a1 1
/*	$OpenBSD: imxesdhc.c,v 1.4 2013/11/06 19:03:07 syl Exp $	*/
d467 15
@


1.4
log
@After factorizing armv7_machdep code here is an effort to factorize all
the code present in omap/omap.c imx/imx.c and sunxi/sunxi.c

All this code looks quite the same, so we move it in a generic armv7/armv7.c

This is a step closer to only one kernel for all armv7 boards.

ok patrick@@, rapha@@
@
text
@d1 1
a1 1
/*	$OpenBSD: imxesdhc.c,v 1.3 2013/10/27 20:27:09 aalm Exp $	*/
d438 6
d467 27
@


1.3
log
@fix card-detect pins for wandboard.
we count from zero, unlike freescale.

spotted by and ok patrick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: imxesdhc.c,v 1.2 2013/10/21 15:30:38 patrick Exp $	*/
d34 1
a34 1
#include <armv7/imx/imxvar.h>
d247 1
a247 1
	struct imx_attach_args		*ia = args;
d252 4
a255 4
	sc->unit = ia->ia_dev->unit;
	sc->sc_iot = ia->ia_iot;
	if (bus_space_map(sc->sc_iot, ia->ia_dev->mem[0].addr,
	    ia->ia_dev->mem[0].size, 0, &sc->sc_ioh))
d262 1
a262 1
	sc->sc_ih = arm_intr_establish(ia->ia_dev->irq[0], IPL_SDMMC,
d277 1
a277 1
	sc->clkbase = imxccm_get_usdhx(ia->ia_dev->unit + 1);
@


1.2
log
@Add SDHC card detect GPIO pins for the i.MX6 Wandboard.

From Artturi Alm.
@
text
@d1 1
a1 1
/*	$OpenBSD: imxesdhc.c,v 1.1 2013/09/06 20:45:53 patrick Exp $	*/
d464 1
a464 1
			case 1:
d467 1
a467 1
			case 3:
@


1.1
log
@Support for FreeScale's i.MX6 SoC.
@
text
@d1 1
a1 1
/*	$OpenBSD: imxesdhc.c,v 1.14 2011/11/15 21:46:44 drahn Exp $	*/
d462 12
d475 1
@

