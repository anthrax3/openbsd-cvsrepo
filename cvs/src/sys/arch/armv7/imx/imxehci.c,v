head	1.19;
access;
symbols
	OPENBSD_6_1_BASE:1.19
	OPENBSD_6_0:1.13.0.2
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.8.0.2
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.4
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.4.0.4
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.3.0.4
	OPENBSD_5_5_BASE:1.3;
locks; strict;
comment	@ * @;


1.19
date	2016.12.28.22.45.24;	author kettenis;	state Exp;
branches;
next	1.18;
commitid	zBEXGFcEf8Xpb4cn;

1.18
date	2016.10.02.06.36.39;	author kettenis;	state Exp;
branches;
next	1.17;
commitid	IMFyKh2keS7O5Fww;

1.17
date	2016.08.13.11.08.58;	author kettenis;	state Exp;
branches;
next	1.16;
commitid	9dTfX4Q5LcTRvutP;

1.16
date	2016.08.06.17.18.38;	author kettenis;	state Exp;
branches;
next	1.15;
commitid	cnh4dl1psoWEBlsr;

1.15
date	2016.08.04.15.52.52;	author kettenis;	state Exp;
branches;
next	1.14;
commitid	WNhzA3xU3jFFVhST;

1.14
date	2016.07.27.11.45.02;	author patrick;	state Exp;
branches;
next	1.13;
commitid	yc14meyJgxIAcvAg;

1.13
date	2016.07.13.09.12.46;	author kettenis;	state Exp;
branches;
next	1.12;
commitid	dlBAVY29tffOOmo2;

1.12
date	2016.07.12.15.16.00;	author kettenis;	state Exp;
branches;
next	1.11;
commitid	5guFvXYe4Pb7Zb6W;

1.11
date	2016.07.10.11.46.28;	author kettenis;	state Exp;
branches;
next	1.10;
commitid	hkXva6w0XSlF6284;

1.10
date	2016.07.09.12.32.50;	author kettenis;	state Exp;
branches;
next	1.9;
commitid	F6qY7qK1yCCGr9gt;

1.9
date	2016.05.19.09.54.18;	author jsg;	state Exp;
branches;
next	1.8;
commitid	YOVLhJEd9hDJJgxl;

1.8
date	2015.05.30.08.09.19;	author jsg;	state Exp;
branches;
next	1.7;
commitid	m3FKhfSWabYRpsiu;

1.7
date	2015.03.29.03.24.17;	author jsg;	state Exp;
branches;
next	1.6;
commitid	hHVsAs6xtkSH9CXS;

1.6
date	2015.01.17.02.57.16;	author jsg;	state Exp;
branches;
next	1.5;
commitid	pSigUqHouiPZjjTj;

1.5
date	2015.01.02.01.57.33;	author jsg;	state Exp;
branches;
next	1.4;
commitid	HaF7XDn04ChceeoJ;

1.4
date	2014.05.19.13.11.31;	author mpi;	state Exp;
branches;
next	1.3;

1.3
date	2013.11.26.20.33.11;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2013.11.06.19.03.07;	author syl;	state Exp;
branches;
next	1.1;

1.1
date	2013.09.06.20.45.53;	author patrick;	state Exp;
branches;
next	;


desc
@@


1.19
log
@Use the generic clock framework.

ok jsg@@, patrick@@
@
text
@/*	$OpenBSD: imxehci.c,v 1.18 2016/10/02 06:36:39 kettenis Exp $ */
/*
 * Copyright (c) 2012-2013 Patrick Wildt <patrick@@blueri.se>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/kernel.h>
#include <sys/rwlock.h>
#include <sys/timeout.h>

#include <machine/intr.h>
#include <machine/bus.h>
#include <machine/fdt.h>

#include <dev/usb/usb.h>
#include <dev/usb/usbdi.h>
#include <dev/usb/usbdivar.h>
#include <dev/usb/usb_mem.h>

#include <armv7/armv7/armv7var.h>
#include <armv7/imx/imxccmvar.h>

#include <dev/ofw/openfirm.h>
#include <dev/ofw/ofw_clock.h>
#include <dev/ofw/ofw_gpio.h>
#include <dev/ofw/ofw_pinctrl.h>
#include <dev/ofw/ofw_regulator.h>
#include <dev/ofw/fdt.h>

#include <dev/usb/ehcireg.h>
#include <dev/usb/ehcivar.h>

/* usb phy */
#define USBPHY_PWD			0x00
#define USBPHY_CTRL			0x30
#define USBPHY_CTRL_SET			0x34
#define USBPHY_CTRL_CLR			0x38
#define USBPHY_CTRL_TOG			0x3c

#define USBPHY_CTRL_ENUTMILEVEL2	(1 << 14)
#define USBPHY_CTRL_ENUTMILEVEL3	(1 << 15)
#define USBPHY_CTRL_CLKGATE		(1 << 30)
#define USBPHY_CTRL_SFTRST		(1U << 31)

/* ehci */
#define USB_EHCI_OFFSET			0x100

#define EHCI_PS_PTS_UTMI_MASK	((1 << 25) | (3 << 30))

/* usb non-core */
#define USBNC_USB_OTG_CTRL		0x00
#define USBNC_USB_UH1_CTRL		0x04

#define USBNC_USB_OTG_CTRL_OVER_CUR_POL	(1 << 8)
#define USBNC_USB_OTG_CTRL_OVER_CUR_DIS	(1 << 7)
#define USBNC_USB_UH1_CTRL_OVER_CUR_POL	(1 << 8)
#define USBNC_USB_UH1_CTRL_OVER_CUR_DIS	(1 << 7)

int	imxehci_match(struct device *, void *, void *);
void	imxehci_attach(struct device *, struct device *, void *);
int	imxehci_detach(struct device *, int);

struct imxehci_softc {
	struct ehci_softc	sc;
	void			*sc_ih;
	bus_space_handle_t	uh_ioh;
	bus_space_handle_t	ph_ioh;
	bus_space_handle_t	nc_ioh;
};

struct cfattach imxehci_ca = {
	sizeof (struct imxehci_softc), imxehci_match, imxehci_attach,
	imxehci_detach
};

struct cfdriver imxehci_cd = {
	NULL, "imxehci", DV_DULL
};

int
imxehci_match(struct device *parent, void *match, void *aux)
{
	struct fdt_attach_args *faa = aux;

	return OF_is_compatible(faa->fa_node, "fsl,imx27-usb");
}

void
imxehci_attach(struct device *parent, struct device *self, void *aux)
{
	struct imxehci_softc *sc = (struct imxehci_softc *)self;
	struct fdt_attach_args *faa = aux;
	usbd_status r;
	char *devname = sc->sc.sc_bus.bdev.dv_xname;
	uint32_t phy[1], misc[2];
	uint32_t phy_reg[2];
	uint32_t misc_reg[2];
	uint32_t vbus;
	int node;

	if (faa->fa_nreg < 1)
		return;

	if (OF_getpropintarray(faa->fa_node, "fsl,usbphy",
	    phy, sizeof(phy)) != sizeof(phy))
		return;

	if (OF_getpropintarray(faa->fa_node, "fsl,usbmisc",
	    misc, sizeof(misc)) != sizeof(misc))
		return;

	node = OF_getnodebyphandle(phy[0]);
	if (node == 0)
		return;

	if (OF_getpropintarray(node, "reg", phy_reg,
	    sizeof(phy_reg)) != sizeof(phy_reg))
		return;

	node = OF_getnodebyphandle(misc[0]);
	if (node == 0)
		return;

	if (OF_getpropintarray(node, "reg", misc_reg,
	    sizeof(misc_reg)) != sizeof(misc_reg))
		return;

	sc->sc.iot = faa->fa_iot;
	sc->sc.sc_bus.dmatag = faa->fa_dmat;
	sc->sc.sc_size = faa->fa_reg[0].size - USB_EHCI_OFFSET;
	sc->sc.sc_flags = EHCIF_USBMODE;

	/* Map I/O space */
	if (bus_space_map(sc->sc.iot, faa->fa_reg[0].addr,
	    faa->fa_reg[0].size, 0, &sc->uh_ioh)) {
		printf(": cannot map mem space\n");
		goto out;
	}
	if (bus_space_subregion(sc->sc.iot, sc->uh_ioh, USB_EHCI_OFFSET,
	    sc->sc.sc_size, &sc->sc.ioh)) {
		printf(": cannot map mem space\n");
		goto mem0;
	}

	if (bus_space_map(sc->sc.iot, phy_reg[0],
	    phy_reg[1], 0, &sc->ph_ioh)) {
		printf(": cannot map mem space\n");
		goto mem1;
	}

	if (bus_space_map(sc->sc.iot, misc_reg[0],
	    misc_reg[1], 0, &sc->nc_ioh)) {
		printf(": cannot map mem space\n");
		goto mem2;
	}

	printf("\n");

	pinctrl_byname(faa->fa_node, "default");
	clock_enable(faa->fa_node, NULL);
	delay(1000);

	/* enable usb bus power */
	vbus = OF_getpropint(faa->fa_node, "vbus-supply", 0);
	if (vbus)
		regulator_enable(vbus);

	switch (misc[1]) {
	case 0:
		/* disable the carger detection, else signal on DP will be poor */
		imxccm_disable_usb1_chrg_detect();
		/* power host 0 */
		imxccm_enable_pll_usb1();

		/* over current and polarity setting */
		bus_space_write_4(sc->sc.iot, sc->nc_ioh, USBNC_USB_OTG_CTRL,
		    bus_space_read_4(sc->sc.iot, sc->nc_ioh, USBNC_USB_OTG_CTRL) |
		    (USBNC_USB_OTG_CTRL_OVER_CUR_POL | USBNC_USB_OTG_CTRL_OVER_CUR_DIS));
		break;
	case 1:
		/* disable the carger detection, else signal on DP will be poor */
		imxccm_disable_usb2_chrg_detect();
		/* power host 1 */
		imxccm_enable_pll_usb2();

		/* over current and polarity setting */
		bus_space_write_4(sc->sc.iot, sc->nc_ioh, USBNC_USB_UH1_CTRL,
		    bus_space_read_4(sc->sc.iot, sc->nc_ioh, USBNC_USB_UH1_CTRL) |
		    (USBNC_USB_UH1_CTRL_OVER_CUR_POL | USBNC_USB_UH1_CTRL_OVER_CUR_DIS));
		break;
	}

	bus_space_write_4(sc->sc.iot, sc->ph_ioh, USBPHY_CTRL_CLR,
	    USBPHY_CTRL_CLKGATE);

	/* Disable interrupts, so we don't get any spurious ones. */
	sc->sc.sc_offs = EREAD1(&sc->sc, EHCI_CAPLENGTH);
	EOWRITE2(&sc->sc, EHCI_USBINTR, 0);

	/* Stop then Reset */
	uint32_t val = EOREAD4(&sc->sc, EHCI_USBCMD);
	val &= ~EHCI_CMD_RS;
	EOWRITE4(&sc->sc, EHCI_USBCMD, val);

	while (EOREAD4(&sc->sc, EHCI_USBCMD) & EHCI_CMD_RS)
		;

	val = EOREAD4(&sc->sc, EHCI_USBCMD);
	val |= EHCI_CMD_HCRESET;
	EOWRITE4(&sc->sc, EHCI_USBCMD, val);

	while (EOREAD4(&sc->sc, EHCI_USBCMD) & EHCI_CMD_HCRESET)
		;

	/* Reset USBPHY module */
	bus_space_write_4(sc->sc.iot, sc->ph_ioh, USBPHY_CTRL_SET, USBPHY_CTRL_SFTRST);

	delay(10);

	/* Remove CLKGATE and SFTRST */
	bus_space_write_4(sc->sc.iot, sc->ph_ioh, USBPHY_CTRL_CLR,
	    USBPHY_CTRL_CLKGATE | USBPHY_CTRL_SFTRST);

	delay(10);

	/* Power up the PHY */
	bus_space_write_4(sc->sc.iot, sc->ph_ioh, USBPHY_PWD, 0);

	/* enable FS/LS device */
	bus_space_write_4(sc->sc.iot, sc->ph_ioh, USBPHY_CTRL_SET,
	    USBPHY_CTRL_ENUTMILEVEL2 | USBPHY_CTRL_ENUTMILEVEL3);

	/* set host mode */
	EOWRITE4(&sc->sc, EHCI_USBMODE,
	    EOREAD4(&sc->sc, EHCI_USBMODE) | EHCI_USBMODE_CM_HOST);

	/* set to UTMI mode */
	EOWRITE4(&sc->sc, EHCI_PORTSC(1),
	    EOREAD4(&sc->sc, EHCI_PORTSC(1)) & ~EHCI_PS_PTS_UTMI_MASK);

	sc->sc_ih = arm_intr_establish_fdt(faa->fa_node, IPL_USB,
	    ehci_intr, &sc->sc, devname);
	if (sc->sc_ih == NULL) {
		printf(": unable to establish interrupt\n");
		goto mem3;
	}

	strlcpy(sc->sc.sc_vendor, "i.MX6", sizeof(sc->sc.sc_vendor));
	r = ehci_init(&sc->sc);
	if (r != USBD_NORMAL_COMPLETION) {
		printf("%s: init failed, error=%d\n", devname, r);
		goto intr;
	}

	config_found(self, &sc->sc.sc_bus, usbctlprint);

	goto out;

intr:
	arm_intr_disestablish(sc->sc_ih);
	sc->sc_ih = NULL;
mem3:
	bus_space_unmap(sc->sc.iot, sc->nc_ioh, misc_reg[1]);
mem2:
	bus_space_unmap(sc->sc.iot, sc->ph_ioh, phy_reg[1]);
mem1:
mem0:
	bus_space_unmap(sc->sc.iot, sc->sc.ioh, faa->fa_reg[0].size);
	sc->sc.sc_size = 0;
out:
	return;
}

int
imxehci_detach(struct device *self, int flags)
{
	struct imxehci_softc		*sc = (struct imxehci_softc *)self;
	int				rv;

	rv = ehci_detach(self, flags);
	if (rv)
		return (rv);

	if (sc->sc_ih != NULL) {
		arm_intr_disestablish(sc->sc_ih);
		sc->sc_ih = NULL;
	}

	if (sc->sc.sc_size) {
		bus_space_unmap(sc->sc.iot, sc->sc.ioh, sc->sc.sc_size);
		sc->sc.sc_size = 0;
	}

	return (0);
}
@


1.18
log
@Save and restore the (non-standard) USBMODE register around a reset of the
controller.  This register controls whether the controller is in device or
host mode on many dual role controllers and gets reset during a reset of
the controller, placing the controller in (non-functional) idle mode.  By
saving and restoring it, we keep the controller in host mode.  Since this is
a non-standard register, add a new EHCIF_USBMODE flag and only do the save and
restore if it has been set.

Makes the upper "OTG" port of the Cubox-i work.

ok mpi@@, jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: imxehci.c,v 1.17 2016/08/13 11:08:58 kettenis Exp $ */
d38 1
d174 1
a174 2

	imxccm_enable_usboh3();
@


1.17
log
@Use regulalator API instead of private functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: imxehci.c,v 1.16 2016/08/06 17:18:38 kettenis Exp $ */
a60 3
#define EHCI_USBMODE			0xa8

#define EHCI_USBMODE_HOST		(3 << 0)
d144 1
d248 2
a249 2
	EWRITE4(&sc->sc, EHCI_USBMODE,
	    EREAD4(&sc->sc, EHCI_USBMODE) | EHCI_USBMODE_HOST);
@


1.16
log
@Switch imx over to the generic pinctrl API.

ok patrick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: imxehci.c,v 1.15 2016/08/04 15:52:52 kettenis Exp $ */
d40 1
a78 2
void	imxehci_enable_vbus(uint32_t);

d182 1
a182 1
		imxehci_enable_vbus(vbus);
a310 29
}

void
imxehci_enable_vbus(uint32_t phandle)
{
	uint32_t gpio[3];
	int active;
	int node;

	node = OF_getnodebyphandle(phandle);
	if (node == 0)
		return;

	if (!OF_is_compatible(node, "regulator-fixed"))
		return;

	pinctrl_byname(node, "default");

	if (OF_getproplen(node, "enable-active-high") == 0)
		active = 1;
	else
		active = 0;

	if (OF_getpropintarray(node, "gpio", gpio,
	    sizeof(gpio)) != sizeof(gpio))
		return;
	
	gpio_controller_config_pin(gpio, GPIO_CONFIG_OUTPUT);
	gpio_controller_set_pin(gpio, active);
@


1.15
log
@Dynamically attach ampintc(4) and make it register itself as an interrupt
controller.  Switch all i.MX6 devices over to the new FDT-aware interrupt
establish API and enable imxgpc(4).

This may break other platforms that use ampintc(4) as their interrupt
controller.  We will fix this as soon as possible by switching them over
to the new interrupt establish API as well.

This also removes the hack in fec(4) to avoid the gpio-based interrupt
workaround.  This commit is an essential step on the road to fix that
issue properly.

ok patrick@@, jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: imxehci.c,v 1.14 2016/07/27 11:45:02 patrick Exp $ */
a35 1
#include <armv7/imx/imxiomuxcvar.h>
d39 1
d175 1
a175 1
	imxiomuxc_pinctrlbyname(faa->fa_node, "default");
d328 1
a328 1
	imxiomuxc_pinctrlbyname(node, "default");
@


1.14
log
@Instead of passing the raw reg property to simplebus nodes,
pass a pre-processed array of fdt_reg structs.  This means
that the drivers don't have to understand the cell properties
themselves but can rely on the 64-bit addr/size pairs.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: imxehci.c,v 1.13 2016/07/13 09:12:46 kettenis Exp $ */
d118 1
a118 1
	if (faa->fa_nreg < 1 || faa->fa_nintr < 3)
d258 1
a258 1
	sc->sc_ih = arm_intr_establish(faa->fa_intr[1], IPL_USB,
@


1.13
log
@Use the device tree voltage regulator information to supply power to the USB
bus.  For this only supports "fixed" regulators that are controlled through a
gpio.  But this covers all the case we currently handle with board ID specific
code.  Note that the old code did explicitly remove power first on some boards,
which would reset bus-powered devices/hubs on the bus.  The new code doesn't do
this.  If that causes problems we can revisit the issue.  The boards that would
be affected are sabrelight/nitrogen6x and utilite.

The plan is to evolve this into a generic regulator framework that supports
more complex regulator types as well.

ok jsg@@, patrick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: imxehci.c,v 1.12 2016/07/12 15:16:00 kettenis Exp $ */
d40 1
d118 1
a118 1
	if (faa->fa_nreg < 2 || faa->fa_nintr < 3)
d147 1
a147 1
	sc->sc.sc_size = faa->fa_reg[1] - USB_EHCI_OFFSET;
d150 2
a151 2
	if (bus_space_map(sc->sc.iot, faa->fa_reg[0],
	    faa->fa_reg[1], 0, &sc->uh_ioh)) {
d285 1
a285 1
	bus_space_unmap(sc->sc.iot, sc->sc.ioh, faa->fa_reg[1]);
@


1.12
log
@Turn ehci(4) glue code for the i.MX6 platform into its own imxehci(4) driver
such that we can don't end up with conflicting attachments of other
SoC-specific glue code.

ok jsg@@, patrick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: imxehci.c,v 1.11 2016/07/10 11:46:28 kettenis Exp $ */
a35 1
#include <armv7/imx/imxgpiovar.h>
d39 1
a72 7
/* board specific */
#define EHCI_HUMMINGBOARD_USB_H1_PWR	0
#define EHCI_HUMMINGBOARD_USB_OTG_PWR	(2*32+22)
#define EHCI_NITROGEN6X_USB_HUB_RST	(6*32+12)
#define EHCI_SABRESD_USB_PWR		(0*32+29)
#define EHCI_UTILITE_USB_HUB_RST	(6*32+8)

d77 2
d114 1
d179 4
a182 29
	if (misc[1] == 1) {
		/* enable usb port power */
		switch (board_id) {
		case BOARD_ID_IMX6_CUBOXI:
		case BOARD_ID_IMX6_HUMMINGBOARD:
			imxgpio_set_bit(EHCI_HUMMINGBOARD_USB_H1_PWR);
			imxgpio_set_dir(EHCI_HUMMINGBOARD_USB_H1_PWR, IMXGPIO_DIR_OUT);
			delay(10);
			break;
		case BOARD_ID_IMX6_SABRELITE:
			imxgpio_clear_bit(EHCI_NITROGEN6X_USB_HUB_RST);
			imxgpio_set_dir(EHCI_NITROGEN6X_USB_HUB_RST, IMXGPIO_DIR_OUT);
			delay(1000 * 2);
			imxgpio_set_bit(EHCI_NITROGEN6X_USB_HUB_RST);
			delay(10);
			break;
		case BOARD_ID_IMX6_SABRESD:
			imxgpio_set_bit(EHCI_SABRESD_USB_PWR);
			imxgpio_set_dir(EHCI_SABRESD_USB_PWR, IMXGPIO_DIR_OUT);
			delay(10);
			break;
		case BOARD_ID_IMX6_UTILITE:
			imxgpio_clear_bit(EHCI_UTILITE_USB_HUB_RST);
			imxgpio_set_dir(EHCI_UTILITE_USB_HUB_RST, IMXGPIO_DIR_OUT);
			delay(10);
			imxgpio_set_bit(EHCI_UTILITE_USB_HUB_RST);
			delay(1000);
			break;
		}
d184 13
d206 1
a206 20
	} else if (misc[1] == 0) {
		/* enable usb port power */
		switch (board_id) {
		case BOARD_ID_IMX6_CUBOXI:
		case BOARD_ID_IMX6_HUMMINGBOARD:
			imxgpio_set_dir(EHCI_HUMMINGBOARD_USB_OTG_PWR, IMXGPIO_DIR_OUT);
			imxgpio_set_bit(EHCI_HUMMINGBOARD_USB_OTG_PWR);
			delay(10);
			break;
		}

		/* disable the carger detection, else signal on DP will be poor */
		imxccm_disable_usb1_chrg_detect();
		/* power host 0 */
		imxccm_enable_pll_usb1();

		/* over current and polarity setting */
		bus_space_write_4(sc->sc.iot, sc->nc_ioh, USBNC_USB_OTG_CTRL,
		    bus_space_read_4(sc->sc.iot, sc->nc_ioh, USBNC_USB_OTG_CTRL) |
		    (USBNC_USB_OTG_CTRL_OVER_CUR_POL | USBNC_USB_OTG_CTRL_OVER_CUR_DIS));
d311 29
@


1.11
log
@Add support for handling pinctrl device tree bindings to imxiomuxc(4).
These are used to do board-specific setup of mux settings and pad
configuration.

ok jsg@@, patrick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: imxehci.c,v 1.10 2016/07/09 12:32:50 kettenis Exp $ */
d95 4
@


1.10
log
@Dynamically attach i.MX6 ehci(4) using the FDT.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: imxehci.c,v 1.9 2016/05/19 09:54:18 jsg Exp $ */
d37 1
d173 2
@


1.9
log
@Remove the PHYTEC phyFLEX support code, patrick says he no longer
has the hardware for the eval kit.

ok patrick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: imxehci.c,v 1.8 2015/05/30 08:09:19 jsg Exp $ */
d27 1
d38 2
d56 2
a71 6
/* port specific addresses */
#define USBOTG_EHCI_ADDR	0x02184100
#define USBUH1_EHCI_ADDR	0x02184300
#define USBUH2_EHCI_ADDR	0x02184500
#define USBUH3_EHCI_ADDR	0x02184700

d79 1
d92 2
a93 2
	sizeof (struct imxehci_softc), NULL, imxehci_attach,
	imxehci_detach, NULL
d96 8
d107 3
a109 3
	struct imxehci_softc	*sc = (struct imxehci_softc *)self;
	struct armv7_attach_args *aa = aux;
	usbd_status		r;
d111 35
a145 4

	sc->sc.iot = aa->aa_iot;
	sc->sc.sc_bus.dmatag = aa->aa_dmat;
	sc->sc.sc_size = aa->aa_dev->mem[0].size;
d148 2
a149 2
	if (bus_space_map(sc->sc.iot, aa->aa_dev->mem[0].addr,
		aa->aa_dev->mem[0].size, 0, &sc->sc.ioh)) {
d153 2
a154 3

	if (bus_space_map(sc->sc.iot, aa->aa_dev->mem[1].addr,
		aa->aa_dev->mem[1].size, 0, &sc->uh_ioh)) {
d159 2
a160 2
	if (bus_space_map(sc->sc.iot, aa->aa_dev->mem[2].addr,
		aa->aa_dev->mem[2].size, 0, &sc->ph_ioh)) {
d165 2
a166 2
	if (bus_space_map(sc->sc.iot, aa->aa_dev->mem[3].addr,
		aa->aa_dev->mem[3].size, 0, &sc->nc_ioh)) {
d176 1
a176 1
	if (aa->aa_dev->mem[0].addr == USBUH1_EHCI_ADDR) {
d178 1
a178 2
		switch (board_id)
		{
d215 1
a215 1
	} else if (aa->aa_dev->mem[0].addr == USBOTG_EHCI_ADDR) {
d217 1
a217 2
		switch (board_id)
		{
d285 1
a285 1
	sc->sc_ih = arm_intr_establish(aa->aa_dev->irq[0], IPL_USB,
d307 1
a307 1
	bus_space_unmap(sc->sc.iot, sc->nc_ioh, aa->aa_dev->mem[3].addr);
d309 1
a309 1
	bus_space_unmap(sc->sc.iot, sc->ph_ioh, aa->aa_dev->mem[2].addr);
a310 1
	bus_space_unmap(sc->sc.iot, sc->uh_ioh, aa->aa_dev->mem[1].addr);
d312 1
a312 1
	bus_space_unmap(sc->sc.iot, sc->sc.ioh, sc->sc.sc_size);
@


1.8
log
@Set the usb otg port on the cubox to host mode and attach ehci to it.
While ehci attaches, devices don't seem to be recognised in the otg port.
From Patrick Wildt in bitrig.
@
text
@d1 1
a1 1
/*	$OpenBSD: imxehci.c,v 1.7 2015/03/29 03:24:17 jsg Exp $ */
a76 2
#define EHCI_PHYFLEX_USB_H1_PWR		0
#define EHCI_PHYFLEX_USB_OTG_PWR	111
a141 6
		case BOARD_ID_IMX6_PHYFLEX:
			imxgpio_set_dir(EHCI_PHYFLEX_USB_H1_PWR, IMXGPIO_DIR_OUT);
			delay(10);
			imxgpio_set_bit(EHCI_PHYFLEX_USB_H1_PWR);
			delay(10);
			break;
@


1.7
log
@initial support for the SABRE SD board
from Patrick Wildt in Bitrig
@
text
@d1 1
a1 1
/*	$OpenBSD: imxehci.c,v 1.6 2015/01/17 02:57:16 jsg Exp $ */
d53 1
a53 1
#define EHCI_USBMODE			0x68
d59 1
d62 2
d67 6
a136 36
	/* enable usb port power */
	switch (board_id)
	{
	case BOARD_ID_IMX6_PHYFLEX:
		imxgpio_set_dir(EHCI_PHYFLEX_USB_H1_PWR, IMXGPIO_DIR_OUT);
		delay(10);
		imxgpio_set_bit(EHCI_PHYFLEX_USB_H1_PWR);
		delay(10);
		break;
	case BOARD_ID_IMX6_CUBOXI:
	case BOARD_ID_IMX6_HUMMINGBOARD:
		imxgpio_set_bit(EHCI_HUMMINGBOARD_USB_H1_PWR);
		imxgpio_set_dir(EHCI_HUMMINGBOARD_USB_H1_PWR, IMXGPIO_DIR_OUT);
		delay(10);
		break;
	case BOARD_ID_IMX6_SABRELITE:
		imxgpio_clear_bit(EHCI_NITROGEN6X_USB_HUB_RST);
		imxgpio_set_dir(EHCI_NITROGEN6X_USB_HUB_RST, IMXGPIO_DIR_OUT);
		delay(1000 * 2);
		imxgpio_set_bit(EHCI_NITROGEN6X_USB_HUB_RST);
		delay(10);
		break;
	case BOARD_ID_IMX6_SABRESD:
		imxgpio_set_bit(EHCI_SABRESD_USB_PWR);
		imxgpio_set_dir(EHCI_SABRESD_USB_PWR, IMXGPIO_DIR_OUT);
		delay(10);
		break;
	case BOARD_ID_IMX6_UTILITE:
		imxgpio_clear_bit(EHCI_UTILITE_USB_HUB_RST);
		imxgpio_set_dir(EHCI_UTILITE_USB_HUB_RST, IMXGPIO_DIR_OUT);
		delay(10);
		imxgpio_set_bit(EHCI_UTILITE_USB_HUB_RST);
		delay(1000);
		break;
	}

d139 69
a207 9
	/* disable the carger detection, else signal on DP will be poor */
	imxccm_disable_usb2_chrg_detect();
	/* power host 1 */
	imxccm_enable_pll_usb2();

	/* over current and polarity setting */
	bus_space_write_4(sc->sc.iot, sc->nc_ioh, USBNC_USB_UH1_CTRL,
	    bus_space_read_4(sc->sc.iot, sc->nc_ioh, USBNC_USB_UH1_CTRL) |
	    (USBNC_USB_UH1_CTRL_OVER_CUR_POL | USBNC_USB_UH1_CTRL_OVER_CUR_DIS));
@


1.6
log
@More complete gpio reset sequences for SABRE Lite/Nitrogen6X.
From Patrick Wildt in Bitrig.
@
text
@d1 1
a1 1
/*	$OpenBSD: imxehci.c,v 1.5 2015/01/02 01:57:33 jsg Exp $ */
d70 1
d148 5
@


1.5
log
@Add some additional i.MX6 board types from Bitrig.
CompuLab Utilite, SolidRun HummingBoard/CuBox-i and UDOO.
@
text
@d1 1
a1 1
/*	$OpenBSD: imxehci.c,v 1.4 2014/05/19 13:11:31 mpi Exp $ */
d140 7
@


1.4
log
@There is no need to remember which usb(4) device is the child of an USB
host controller because autoconf(9) already does it.

Breakage reported by todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: imxehci.c,v 1.3 2013/11/26 20:33:11 deraadt Exp $ */
d65 3
d70 1
d135 13
@


1.3
log
@1 << 31 cleanup.  Eitan Adler pointed out that there has been a
resurrection of the bad idiom in the tree.
sufficient review by miod, kettenis, tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: imxehci.c,v 1.2 2013/11/06 19:03:07 syl Exp $ */
d208 1
a208 2
	sc->sc.sc_child = config_found((void *)sc, &sc->sc.sc_bus,
	    usbctlprint);
d234 1
a234 1
	rv = ehci_detach(&sc->sc, flags);
@


1.2
log
@After factorizing armv7_machdep code here is an effort to factorize all
the code present in omap/omap.c imx/imx.c and sunxi/sunxi.c

All this code looks quite the same, so we move it in a generic armv7/armv7.c

This is a step closer to only one kernel for all armv7 boards.

ok patrick@@, rapha@@
@
text
@d1 1
a1 1
/*	$OpenBSD: imxehci.c,v 1.1 2013/09/06 20:45:53 patrick Exp $ */
d50 1
a50 1
#define USBPHY_CTRL_SFTRST		(1 << 31)
@


1.1
log
@Support for FreeScale's i.MX6 SoC.
@
text
@d1 1
a1 1
/*	$OpenBSD: imxehci.c,v 1.10 2011/11/10 19:37:01 uwe Exp $ */
d33 1
a33 1
#include <armv7/imx/imxvar.h>
d88 1
a88 1
	struct imx_attach_args	*ia = aux;
d92 3
a94 3
	sc->sc.iot = ia->ia_iot;
	sc->sc.sc_bus.dmatag = ia->ia_dmat;
	sc->sc.sc_size = ia->ia_dev->mem[0].size;
d97 2
a98 2
	if (bus_space_map(sc->sc.iot, ia->ia_dev->mem[0].addr,
		ia->ia_dev->mem[0].size, 0, &sc->sc.ioh)) {
d103 2
a104 2
	if (bus_space_map(sc->sc.iot, ia->ia_dev->mem[1].addr,
		ia->ia_dev->mem[1].size, 0, &sc->uh_ioh)) {
d109 2
a110 2
	if (bus_space_map(sc->sc.iot, ia->ia_dev->mem[2].addr,
		ia->ia_dev->mem[2].size, 0, &sc->ph_ioh)) {
d115 2
a116 2
	if (bus_space_map(sc->sc.iot, ia->ia_dev->mem[3].addr,
		ia->ia_dev->mem[3].size, 0, &sc->nc_ioh)) {
d194 1
a194 1
	sc->sc_ih = arm_intr_establish(ia->ia_dev->irq[0], IPL_USB,
d217 1
a217 1
	bus_space_unmap(sc->sc.iot, sc->nc_ioh, ia->ia_dev->mem[3].addr);
d219 1
a219 1
	bus_space_unmap(sc->sc.iot, sc->ph_ioh, ia->ia_dev->mem[2].addr);
d221 1
a221 1
	bus_space_unmap(sc->sc.iot, sc->uh_ioh, ia->ia_dev->mem[1].addr);
@

