head	1.19;
access;
symbols
	OPENBSD_6_0:1.19.0.2
	OPENBSD_6_0_BASE:1.19
	OPENBSD_5_9:1.15.0.2
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.15.0.4
	OPENBSD_5_8_BASE:1.15
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.7.0.6
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.4
	OPENBSD_5_5_BASE:1.7;
locks; strict;
comment	@ * @;


1.19
date	2016.06.08.15.27.05;	author jsg;	state Exp;
branches;
next	1.18;
commitid	O8sdMmMKqczNQU5p;

1.18
date	2016.06.04.18.09.16;	author jsg;	state Exp;
branches;
next	1.17;
commitid	tYyT96DOGdhLjy9v;

1.17
date	2016.05.19.09.54.18;	author jsg;	state Exp;
branches;
next	1.16;
commitid	YOVLhJEd9hDJJgxl;

1.16
date	2016.05.18.22.55.23;	author kettenis;	state Exp;
branches;
next	1.15;
commitid	3F9JV9gcDaM81aVG;

1.15
date	2015.05.19.03.30.54;	author jsg;	state Exp;
branches;
next	1.14;
commitid	l6xI4SC4UUe6il2U;

1.14
date	2015.05.19.00.05.59;	author jsg;	state Exp;
branches;
next	1.13;
commitid	bo8vCG1OOftVcP5V;

1.13
date	2015.05.15.15.35.43;	author jsg;	state Exp;
branches;
next	1.12;
commitid	AFNG6oUBgS2y44wd;

1.12
date	2015.05.08.03.38.26;	author jsg;	state Exp;
branches;
next	1.11;
commitid	zVOTE2eSG0EuTsRj;

1.11
date	2015.03.29.03.24.17;	author jsg;	state Exp;
branches;
next	1.10;
commitid	hHVsAs6xtkSH9CXS;

1.10
date	2015.01.22.14.33.01;	author krw;	state Exp;
branches;
next	1.9;
commitid	zVCYt6mjbluLi3jT;

1.9
date	2015.01.13.01.33.45;	author jsg;	state Exp;
branches;
next	1.8;
commitid	DJTli2QRXzPBGWNP;

1.8
date	2015.01.02.01.57.33;	author jsg;	state Exp;
branches;
next	1.7;
commitid	HaF7XDn04ChceeoJ;

1.7
date	2013.11.06.19.03.07;	author syl;	state Exp;
branches;
next	1.6;

1.6
date	2013.10.30.20.20.23;	author syl;	state Exp;
branches;
next	1.5;

1.5
date	2013.10.28.09.15.09;	author patrick;	state Exp;
branches;
next	1.4;

1.4
date	2013.10.05.23.05.12;	author patrick;	state Exp;
branches;
next	1.3;

1.3
date	2013.09.28.14.16.41;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2013.09.28.12.40.28;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2013.09.06.20.45.53;	author patrick;	state Exp;
branches;
next	;


desc
@@


1.19
log
@Use fdt to find the console to initialise.  Try to use /chosen/stdout-path
if present otherwise fallback to /aliases/serial0.

Don't require a platform match to run the various console init functions
so the init functions will run for unknown board ids.

With and ok kettenis@@ on a earlier version.
@
text
@/*	$OpenBSD: imx_machdep.c,v 1.18 2016/06/04 18:09:16 jsg Exp $	*/
/*
 * Copyright (c) 2013 Sylvestre Gallon <ccna.syl@@gmail.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/types.h>
#include <sys/systm.h>
#include <sys/termios.h>

#include <machine/bus.h>
#include <machine/bootconfig.h>

#include <dev/ic/comreg.h>
#include <dev/ic/comvar.h>

#include <arm/cortex/smc.h>
#include <arm/armv7/armv7var.h>
#include <arm/mainbus/mainbus.h>
#include <armv7/armv7/armv7var.h>
#include <armv7/imx/imxuartvar.h>
#include <armv7/armv7/armv7_machdep.h>

extern void imxdog_reset(void);
extern struct board_dev *imx_board_devs(void);
extern void imx_board_init(void);

void
imx_platform_smc_write(bus_space_tag_t iot, bus_space_handle_t ioh, bus_size_t off,
    uint32_t op, uint32_t val)
{
	bus_space_write_4(iot, ioh, off, val);
}

void
imx_platform_init_mainbus(struct device *self)
{
	mainbus_legacy_found(self, "cortex");
	mainbus_legacy_found(self, "imx");
}

void
imx_platform_watchdog_reset(void)
{
	imxdog_reset();
}

void
imx_platform_powerdown(void)
{

}

void
imx_platform_disable_l2_if_needed(void)
{

}

void
imx_platform_board_init(void)
{
	imx_board_init();
}

struct armv7_platform imx_platform = {
	.board_init = imx_platform_board_init,
	.smc_write = imx_platform_smc_write,
	.watchdog_reset = imx_platform_watchdog_reset,
	.powerdown = imx_platform_powerdown,
	.disable_l2_if_needed = imx_platform_disable_l2_if_needed,
	.init_mainbus = imx_platform_init_mainbus,
};

struct armv7_platform *
imx_platform_match(void)
{
	struct board_dev *devs;

	devs = imx_board_devs();
	if (devs == NULL)
		return (NULL);

	imx_platform.devs = devs;
	return (&imx_platform);
}
@


1.18
log
@Remove model specific strings keyed off the board id.
We now pull the model string from fdt.
@
text
@d1 1
a1 1
/*	$OpenBSD: imx_machdep.c,v 1.17 2016/05/19 09:54:18 jsg Exp $	*/
a38 2
extern int comcnspeed;
extern int comcnmode;
a47 31
imx_platform_init_cons(void)
{
	paddr_t paddr;

	switch (board_id) {
	/* UART1 */
	case BOARD_ID_IMX6_CUBOXI:
	case BOARD_ID_IMX6_HUMMINGBOARD:
	case BOARD_ID_IMX6_SABRESD:
	case BOARD_ID_IMX6_WANDBOARD:
		paddr = 0x02020000;
		break;
	/* UART2 */
	case BOARD_ID_IMX6_SABRELITE:
	case BOARD_ID_IMX6_UDOO:
	case BOARD_ID_IMX6_NOVENA:
		paddr = 0x021e8000;
		break;
	/* UART4 */
	case BOARD_ID_IMX6_UTILITE:
		paddr = 0x021f0000;
		break;
	default:
		printf("board type %x unknown", board_id);
		return;
		/* XXX - HELP */
	}
	imxuartcnattach(&armv7_bs_tag, paddr, comcnspeed, comcnmode);
}

void
a80 1
	.init_cons = imx_platform_init_cons,
@


1.17
log
@Remove the PHYTEC phyFLEX support code, patrick says he no longer
has the hardware for the eval kit.

ok patrick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: imx_machdep.c,v 1.16 2016/05/18 22:55:23 kettenis Exp $	*/
a36 1
extern char *imx_board_name(void);
a98 6
const char *
imx_platform_board_name(void)
{
	return (imx_board_name());
}

a111 2
	.boot_name = "OpenBSD/imx",
	.board_name = imx_platform_board_name,
@


1.16
log
@Introduce a per-platform init_mainbus() hook that can be used to attach
platform-specific devices to mainbus before we start walking the FDT.

ok patrick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: imx_machdep.c,v 1.15 2015/05/19 03:30:54 jsg Exp $	*/
a69 1
	case BOARD_ID_IMX6_PHYFLEX:
@


1.15
log
@Abstract the soc_machdep.c functions to allow a kernel to be built for
multiple socs.

From Patrick Wildt in bitrig with some additional changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: imx_machdep.c,v 1.14 2015/05/19 00:05:59 jsg Exp $	*/
d31 1
d83 7
d128 1
@


1.14
log
@use the same va entry point on all armv7 socs
Similiar changes were made in bitrig by Patrick Wildt.

As part of this change the physical load address for imx and sunxi have
changed.  Any u-boot settings that include it will need to be modified.

imx: 0x10800000 -> 0x10300000
sunxi: 0x40800000 -> 0x40300000

Tested by bmercer, canacar and myself.
ok bmercer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: imx_machdep.c,v 1.13 2015/05/15 15:35:43 jsg Exp $	*/
d37 2
a38 1
extern int32_t amptimer_frequency;
a41 2
const char *platform_boot_name = "OpenBSD/imx";

d43 1
a43 1
platform_smc_write(bus_space_tag_t iot, bus_space_handle_t ioh, bus_size_t off,
d50 1
a50 1
platform_init_cons(void)
d82 1
a82 1
platform_watchdog_reset(void)
d88 1
a88 1
platform_powerdown(void)
d94 1
a94 1
platform_board_name(void)
d100 7
a106 1
platform_disable_l2_if_needed(void)
d108 22
d131 2
@


1.13
log
@Make board attaching table driven and move it out into the soc
directories.  Move the device tables while here as was done in bitrig.
With these changes the only use of the board id defines is in the soc
directories.

Tested by matthieu and djm on imx and myself on omap and sunxi (qemu).
ok djm@@, ok jasper@@ on an earlier version
@
text
@d1 1
a1 1
/*	$OpenBSD: imx_machdep.c,v 1.12 2015/05/08 03:38:26 jsg Exp $	*/
a97 17
}

void
platform_bootconfig_dram(BootConfig *bootconfig, psize_t *memstart, psize_t *memsize)
{
	if (bootconfig->dramblocks == 0) {
		*memstart = SDRAM_START;
		*memsize = 0x10000000; /* 256 MB */
		/* Fake bootconfig structure for the benefit of pmap.c */
		/* XXX must make the memory description h/w independant */
		bootconfig->dram[0].address = *memstart;
		bootconfig->dram[0].pages = *memsize / PAGE_SIZE;
		bootconfig->dramblocks = 1;
	} else {
		*memstart = bootconfig->dram[0].address;
		*memsize = bootconfig->dram[0].pages * PAGE_SIZE;
	}
@


1.12
log
@Add initial board specific parts of novena support, tested by djm@@
While novena has it's own board id it's u-boot does not set it.
"setenv machid 10ad" in u-boot will set the novena board id (0x10ad/4269).
@
text
@d1 1
a1 1
/*	$OpenBSD: imx_machdep.c,v 1.11 2015/03/29 03:24:17 jsg Exp $	*/
d36 1
d94 2
a95 2
void
platform_print_board_type(void)
d97 1
a97 40
	switch (board_id) {
	case BOARD_ID_IMX6_CUBOXI:
		amptimer_frequency = 396 * 1000 * 1000;
		printf("board type: CuBox-i\n");
		break;
	case BOARD_ID_IMX6_HUMMINGBOARD:
		amptimer_frequency = 396 * 1000 * 1000;
		printf("board type: HummingBoard\n");
		break;
	case BOARD_ID_IMX6_PHYFLEX:
		amptimer_frequency = 396 * 1000 * 1000;
		printf("board type: phyFLEX-i.MX6\n");
		break;
	case BOARD_ID_IMX6_SABRELITE:
		amptimer_frequency = 396 * 1000 * 1000;
		printf("board type: SABRE Lite\n");
		break;
	case BOARD_ID_IMX6_SABRESD:
		amptimer_frequency = 396 * 1000 * 1000;
		printf("board type: SABRE SD\n");
		break;
	case BOARD_ID_IMX6_UDOO:
		amptimer_frequency = 396 * 1000 * 1000;
		printf("board type: UDOO\n");
		break;
	case BOARD_ID_IMX6_UTILITE:
		amptimer_frequency = 396 * 1000 * 1000;
		printf("board type: Utilite\n");
		break;
	case BOARD_ID_IMX6_NOVENA:
		amptimer_frequency = 396 * 1000 * 1000;
		printf("board type: Novena\n");
		break;
	case BOARD_ID_IMX6_WANDBOARD:
		amptimer_frequency = 396 * 1000 * 1000;
		printf("board type: Wandboard\n");
		break;
	default:
		printf("board type %x unknown\n", board_id);
	}
@


1.11
log
@initial support for the SABRE SD board
from Patrick Wildt in Bitrig
@
text
@d1 1
a1 1
/*	$OpenBSD: imx_machdep.c,v 1.10 2015/01/22 14:33:01 krw Exp $	*/
d65 1
d124 4
@


1.10
log
@Replace some obvious '$OpenBSD' and '$OpenBSD:' typos with '$OpenBSD$'.

Pointed out by dickman@@.

ok sthen@@ phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d55 1
d58 1
d62 6
a71 4
	case BOARD_ID_IMX6_SABRELITE:
	case BOARD_ID_IMX6_UDOO:
		paddr = 0x021e8000;
		break;
d111 4
@


1.9
log
@Add missing Utilite case in imx_platform_init_cons()
spotted by Patrick Wildt
@
text
@d1 1
a1 1
/*	$OpenBSD	*/
@


1.8
log
@Add some additional i.MX6 board types from Bitrig.
CompuLab Utilite, SolidRun HummingBoard/CuBox-i and UDOO.
@
text
@d61 1
@


1.7
log
@After factorizing armv7_machdep code here is an effort to factorize all
the code present in omap/omap.c imx/imx.c and sunxi/sunxi.c

All this code looks quite the same, so we move it in a generic armv7/armv7.c

This is a step closer to only one kernel for all armv7 boards.

ok patrick@@, rapha@@
@
text
@d55 5
d64 1
a66 3
	case BOARD_ID_IMX6_WANDBOARD:
		paddr = 0x02020000;
		break;
d91 8
d106 8
@


1.6
log
@Put all the generic machdep code in armv7_machedep.c

Cleanup the machdep code removing:
- useless includes
- useless globals and prototypes
- useless #if 0 and #if 1
- some style(9) issues

This commit will make the bringup of new SoC easier.

ok patrick@@ jasper@@ rapha@@
@
text
@d31 1
a31 1
#include <armv7/imx/imxvar.h>
@


1.5
log
@We need to make sure that the kernel symbols area isn't marked as free
space.  For this we only have to use the esym marker instead of _end.
@
text
@d1 1
a1 70
/*	$OpenBSD: imx_machdep.c,v 1.4 2013/10/05 23:05:12 patrick Exp $ */
/*	$NetBSD: lubbock_machdep.c,v 1.2 2003/07/15 00:25:06 lukem Exp $ */

/*
 * Copyright (c) 2002, 2003  Genetec Corporation.  All rights reserved.
 * Written by Hiroyuki Bessho for Genetec Corporation.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of Genetec Corporation may not be used to endorse or 
 *    promote products derived from this software without specific prior
 *    written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY GENETEC CORPORATION ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL GENETEC CORPORATION
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * Machine dependant functions for kernel setup for 
 * Intel DBPXA250 evaluation board (a.k.a. Lubbock).
 * Based on iq80310_machhdep.c
 */
/*
 * Copyright (c) 2001 Wasabi Systems, Inc.
 * All rights reserved.
 *
 * Written by Jason R. Thorpe for Wasabi Systems, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed for the NetBSD Project by
 *	Wasabi Systems, Inc.
 * 4. The name of Wasabi Systems, Inc. may not be used to endorse
 *    or promote products derived from this software without specific prior
 *    written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY WASABI SYSTEMS, INC. ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL WASABI SYSTEMS, INC
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

d3 1
a3 31
 * Copyright (c) 1997,1998 Mark Brinicombe.
 * Copyright (c) 1997,1998 Causality Limited.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Mark Brinicombe
 *	for the NetBSD Project.
 * 4. The name of the company nor the name of the author may be used to
 *    endorse or promote products derived from this software without specific
 *    prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d5 11
a15 9
 * Machine dependant functions for kernel setup for Intel IQ80310 evaluation
 * boards using RedBoot firmware.
 */

/*
 * DIP switches:
 *
 * S19: no-dot: set RB_KDB.  enter kgdb session.
 * S20: no-dot: set RB_SINGLE. don't go multi user mode.
d19 1
a19 1
#include <sys/device.h>
a20 5
#include <sys/kernel.h>
#include <sys/exec.h>
#include <sys/proc.h>
#include <sys/msgbuf.h>
#include <sys/reboot.h>
d23 1
a23 12
#include <uvm/uvm_extern.h>

#include <sys/conf.h>
#include <sys/queue.h>
#include <sys/device.h>
#include <dev/cons.h>
#include <dev/ic/smc91cxxreg.h>

#include <machine/db_machdep.h>
#include <ddb/db_sym.h>
#include <ddb/db_extern.h>

a24 5
#include <machine/bus.h>
#include <machine/cpu.h>
#include <machine/frame.h>
#include <arm/undefined.h>
#include <arm/machdep.h>
d26 2
a27 2
#include <arm/armv7/armv7reg.h>
#include <arm/armv7/armv7var.h>
d30 1
a30 1
#include <machine/machine_reg.h>
a31 105

#include "wsdisplay.h"

/* Kernel text starts 2MB in from the bottom of the kernel address space. */
#define	KERNEL_TEXT_BASE	(KERNEL_BASE + 0x00000000)
#define	KERNEL_VM_BASE		(KERNEL_BASE + 0x04000000)

/*
 * The range 0xc1000000 - 0xccffffff is available for kernel VM space
 * Core-logic registers and I/O mappings occupy 0xfd000000 - 0xffffffff
 */
/*
#define KERNEL_VM_SIZE		0x0C000000
*/
#define KERNEL_VM_SIZE		0x10000000


/*
 * Address to call from cpu_reset() to reset the machine.
 * This is machine architecture dependant as it varies depending
 * on where the ROM appears when you turn the MMU off.
 */

u_int cpu_reset_address = 0;

/* Define various stack sizes in pages */
#define IRQ_STACK_SIZE	1
#define ABT_STACK_SIZE	1
#ifdef IPKDB
#define UND_STACK_SIZE	2
#else
#define UND_STACK_SIZE	1
#endif

BootConfig bootconfig;		/* Boot config storage */
char *boot_args = NULL;
char *boot_file = "";

vaddr_t physical_start;
vaddr_t physical_freestart;
vaddr_t physical_freeend;
vaddr_t physical_end;
u_int free_pages;
vaddr_t pagetables_start;
int physmem = 0;

/*int debug_flags;*/
#ifndef PMAP_STATIC_L1S
int max_processes = 64;			/* Default number */
#endif	/* !PMAP_STATIC_L1S */

/* Physical and virtual addresses for some global pages */
pv_addr_t systempage;
pv_addr_t irqstack;
pv_addr_t undstack;
pv_addr_t abtstack;
extern pv_addr_t kernelstack;
pv_addr_t minidataclean;

vaddr_t msgbufphys;

extern u_int data_abort_handler_address;
extern u_int prefetch_abort_handler_address;
extern u_int undefined_handler_address;

#ifdef PMAP_DEBUG
extern int pmap_debug_level;
#endif

uint32_t	board_id;

#define KERNEL_PT_SYS		0	/* Page table for mapping proc0 zero page */
#define KERNEL_PT_KERNEL	1	/* Page table for mapping kernel */
#define	KERNEL_PT_KERNEL_NUM	32
#define KERNEL_PT_VMDATA	(KERNEL_PT_KERNEL+KERNEL_PT_KERNEL_NUM)
				        /* Page tables for mapping kernel VM */
#define	KERNEL_PT_VMDATA_NUM	8	/* start with 16MB of KVM */
#define NUM_KERNEL_PTS		(KERNEL_PT_VMDATA + KERNEL_PT_VMDATA_NUM)

pv_addr_t kernel_pt_table[NUM_KERNEL_PTS];

extern struct user *proc0paddr;

/*
 * safepri is a safe priority for sleep to set for a spin-wait
 * during autoconfiguration or after a panic.
 */
int   safepri = 0;

/* Prototypes */

void	imxdog_reset(void);
void	imx_powerdown(void);
void	imx_reset(void);

char	bootargs[MAX_BOOT_STRING];
void	process_kernel_args(char *);

void	consinit(void);
void	early_clkman(u_int, int);
void	kgdb_port_init(void);
void	change_clock(uint32_t v);

bs_protos(bs_notimpl);

d33 1
a33 5
#include "com.h"
#if NCOM > 0
#include <dev/ic/comreg.h>
#include <dev/ic/comvar.h>
#endif
d35 4
a38 6
#ifndef CONSPEED
#define CONSPEED B115200	/* What u-boot */
#endif
#ifndef CONMODE
#define CONMODE ((TTYDEF_CFLAG & ~(CSIZE | CSTOPB | PARENB)) | CS8) /* 8N1 */
#endif
d40 1
a40 4
int comcnspeed = CONSPEED;
int comcnmode = CONMODE;

extern int32_t amptimer_frequency;
a41 3
/*
 *
 */
d43 2
a44 1
imx_powerdown(void)
d46 1
a48 8
/*
 * void boot(int howto, char *bootstr)
 *
 * Reboots the system
 *
 * Deal with any syncing, unmounting, dumping and shutdown hooks,
 * then reset the CPU.
 */
d50 1
a50 1
boot(int howto)
d52 1
a52 25
#ifdef DIAGNOSTIC
	/* info */
	printf("boot: howto=%08x curproc=%p\n", howto, curproc);
#endif

	/*
	 * If we are still cold then hit the air brakes
	 * and crash to earth fast
	 */
	if (cold) {
		doshutdownhooks();
		if (!TAILQ_EMPTY(&alldevs))
			config_suspend(TAILQ_FIRST(&alldevs), DVACT_POWERDOWN);
		if ((howto & (RB_HALT | RB_USERREQ)) != RB_USERREQ) {
			printf("The operating system has halted.\n");
			printf("Please press any key to reboot.\n\n");
			cngetc();
		}
		printf("rebooting...\n");
		delay(500000);
		imxdog_reset();
		printf("reboot failed; spinning\n");
		while(1);
		/*NOTREACHED*/
	}
d54 14
a67 39
	/* Disable console buffering */
/*	cnpollc(1);*/

	/*
	 * If RB_NOSYNC was not specified sync the discs.
	 * Note: Unless cold is set to 1 here, syslogd will die during the
	 * unmount.  It looks like syslogd is getting woken up only to find
	 * that it cannot page part of the binary in as the filesystem has
	 * been unmounted.
	 */
	if (!(howto & RB_NOSYNC))
		bootsync(howto);

	/* Say NO to interrupts */
	splhigh();

	/* Do a dump if requested. */
	if ((howto & (RB_DUMP | RB_HALT)) == RB_DUMP)
		dumpsys();
	
	/* Run any shutdown hooks */
	doshutdownhooks();
	if (!TAILQ_EMPTY(&alldevs))
		config_suspend(TAILQ_FIRST(&alldevs), DVACT_POWERDOWN);

	/* Make sure IRQ's are disabled */
	IRQdisable;

	if (howto & RB_HALT) {
		if (howto & RB_POWERDOWN) {

			printf("\nAttempting to power down...\n");
			delay(500000);
			imx_powerdown();
		}

		printf("The operating system has halted.\n");
		printf("Please press any key to reboot.\n\n");
		cngetc();
d69 1
a69 7

	printf("rebooting...\n");
	delay(500000);
	imxdog_reset();
	printf("reboot failed; spinning\n");
	while(1);
	/*NOTREACHED*/
d72 2
a73 3
static __inline
pd_entry_t *
read_ttb(void)
d75 1
a75 6
  long ttb;

  __asm __volatile("mrc	p15, 0, %0, c2, c0, 0" : "=r" (ttb));


  return (pd_entry_t *)(ttb & ~((1<<14)-1));
d78 2
a79 16
#if 1
#define VERBOSE_INIT_ARM
#endif

/*
 * simple memory mapping function used in early bootstrap stage
 * before pmap is initialized.
 * size and cacheability are ignored and map one section with nocache.
 */
static vaddr_t section_free = 0xfd000000; /* XXX - huh */

int bootstrap_bs_map(void *t, bus_addr_t bpa, bus_size_t size,
    int flags, bus_space_handle_t *bshp);
int
bootstrap_bs_map(void *t, bus_addr_t bpa, bus_size_t size,
    int flags, bus_space_handle_t *bshp)
a80 15
	u_long startpa;
	vaddr_t va;
	pd_entry_t *pagedir = read_ttb();
	/* This assumes PA==VA for page directory */

	va = section_free;
	section_free += L1_S_SIZE;

	/*
	startpa = trunc_page(bpa);
	*/
	startpa = bpa & ~L1_S_OFFSET;
	pmap_map_section((vaddr_t)pagedir, va, startpa, 
	    VM_PROT_READ | VM_PROT_WRITE, PTE_NOCACHE);
	cpu_tlb_flushD();
a81 3
	*bshp = (bus_space_handle_t)(va + (bpa - startpa));

	return(0);
d84 2
a85 43
static void
copy_io_area_map(pd_entry_t *new_pd)
{
	pd_entry_t *cur_pd = read_ttb();
	vaddr_t va;

	for (va = MACHINE_IO_AREA_VBASE;
	     (cur_pd[va>>L1_S_SHIFT] & L1_TYPE_MASK) == L1_TYPE_S;
	     va += L1_S_SIZE) {

		new_pd[va>>L1_S_SHIFT] = cur_pd[va>>L1_S_SHIFT];
		if (va == (ARM_VECTORS_HIGH & ~(0x00400000 - 1)))
			break; /* STUPID */

	}
}

void parse_uboot_tags(void *);
void imx_reset() {
	uint16_t* wcr = (uint16_t*)0x020bc000;
	uint16_t* wsr = (uint16_t*)0x020bc002;
	*wcr = 0;
	*wsr = 0x5555;
	*wsr = 0xaaaa;
	*wcr = 1;
	*wcr = 1;
}

/*
 * u_int initarm(...)
 *
 * Initial entry point on startup. This gets called before main() is
 * entered.
 * It should be responsible for setting up everything that must be
 * in place when main is called.
 * This includes
 *   Taking a copy of the boot configuration structure.
 *   Initialising the physical console so characters can be printed.
 *   Setting up page tables for the kernel
 *   Relocating the kernel to the bottom of physical memory
 */
u_int
initarm(void *arg0, void *arg1, void *arg2)
a86 396
	int loop;
	int loop1;
	u_int l1pagetable;
	pv_addr_t kernel_l1pt;
	paddr_t memstart;
	psize_t memsize;
	extern u_int32_t esym;  /* &_end if no symbols are loaded */

#if 0
	int led_data = 0;
#endif
	/* early bus_space_map support */
	struct bus_space tmp_bs_tag;
	int	(*map_func_save)(void *, bus_addr_t, bus_size_t, int, 
	    bus_space_handle_t *);

	board_id = (uint32_t)arg1;

	/*
	 * Heads up ... Setup the CPU / MMU / TLB functions
	 */
	if (set_cpufuncs())
		panic("cpu not recognized!");

#if 0
	/* Calibrate the delay loop. */
#endif

	/*
	 * Temporarily replace bus_space_map() functions so that
	 * console devices can get mapped.
	 *
	 * Note that this relies upon the fact that both regular
	 * and a4x bus_space tags use the same map function.
	 */
#if defined(CPU_ARMv7) 
	tmp_bs_tag = armv7_bs_tag;
	map_func_save = armv7_bs_tag.bs_map;
	armv7_bs_tag.bs_map = bootstrap_bs_map;
	armv7_a4x_bs_tag.bs_map = bootstrap_bs_map;
#endif
	tmp_bs_tag.bs_map = bootstrap_bs_map;

	/* setup a serial console for very early boot */
	consinit();

	/* Talk to the user */
	printf("\nOpenBSD/imx booting ...\n");

	printf("arg0 %p arg1 %p arg2 %p\n", arg0, arg1, arg2);
	parse_uboot_tags(arg2);

	/*
	 * Examine the boot args string for options we need to know about
	 * now.
	 */
	process_kernel_args(bootconfig.bootstring);
#ifdef RAMDISK_HOOKS
        boothowto |= RB_DFLTROOT;
#endif /* RAMDISK_HOOKS */

	/* normally u-boot will set up bootconfig.dramblocks */
	if (bootconfig.dramblocks == 0) {
		memstart = SDRAM_START;
		memsize = 0x10000000; /* 256 MB */
		/* Fake bootconfig structure for the benefit of pmap.c */
		/* XXX must make the memory description h/w independant */
		bootconfig.dram[0].address = memstart;
		bootconfig.dram[0].pages = memsize / PAGE_SIZE;
		bootconfig.dramblocks = 1;
	} else {
		memstart = bootconfig.dram[0].address;
		memsize = bootconfig.dram[0].pages * PAGE_SIZE;
	}

	/*
	 * Set up the variables that define the availablilty of
	 * physical memory.  For now, we're going to set
	 * physical_freestart to 0xa0200000 (where the kernel
	 * was loaded), and allocate the memory we need downwards.
	 * If we get too close to the page tables that RedBoot
	 * set up, we will panic.  We will update physical_freestart
	 * and physical_freeend later to reflect what pmap_bootstrap()
	 * wants to see.
	 *
	 * XXX pmap_bootstrap() needs an enema.
	 */
	physical_start = bootconfig.dram[0].address;
	physical_end = physical_start + (bootconfig.dram[0].pages * PAGE_SIZE);

	{
		physical_freestart = (((unsigned long)esym - KERNEL_TEXT_BASE +0xfff) & ~0xfff) + memstart;
		physical_freeend = memstart+memsize;
	}

	physmem = (physical_end - physical_start) / PAGE_SIZE;

#ifdef DEBUG
	/* Tell the user about the memory */
	printf("physmemory: %d pages at 0x%08lx -> 0x%08lx\n", physmem,
	    physical_start, physical_end - 1);
#endif

	/*
	 * Okay, the kernel starts 2MB in from the bottom of physical
	 * memory.  We are going to allocate our bootstrap pages downwards
	 * from there.
	 *
	 * We need to allocate some fixed page tables to get the kernel
	 * going.  We allocate one page directory and a number of page
	 * tables and store the physical addresses in the kernel_pt_table
	 * array.
	 *
	 * The kernel page directory must be on a 16K boundary.  The page
	 * tables must be on 4K bounaries.  What we do is allocate the
	 * page directory on the first 16K boundary that we encounter, and
	 * the page tables on 4K boundaries otherwise.  Since we allocate
	 * at least 3 L2 page tables, we are guaranteed to encounter at
	 * least one 16K aligned region.
	 */

#ifdef VERBOSE_INIT_ARM
	printf("Allocating page tables\n");
#endif

	free_pages = (physical_freeend - physical_freestart) / PAGE_SIZE;

#ifdef VERBOSE_INIT_ARM
	printf("freestart = 0x%08lx, free_pages = %d (0x%08x)\n",
	       physical_freestart, free_pages, free_pages);
#endif

	/* Define a macro to simplify memory allocation */
#define	valloc_pages(var, np)				\
	alloc_pages((var).pv_pa, (np));			\
	(var).pv_va = KERNEL_BASE + (var).pv_pa - physical_start;

#define alloc_pages(var, np)				\
	(var) = physical_freestart;			\
	physical_freestart += ((np) * PAGE_SIZE);	\
	if (physical_freeend < physical_freestart)	\
		panic("initarm: out of memory");	\
	free_pages -= (np);				\
	memset((char *)(var), 0, ((np) * PAGE_SIZE));

	loop1 = 0;
	kernel_l1pt.pv_pa = 0;
	for (loop = 0; loop <= NUM_KERNEL_PTS; ++loop) {
		/* Are we 16KB aligned for an L1 ? */
		if (((physical_freestart) & (L1_TABLE_SIZE - 1)) == 0
		    && kernel_l1pt.pv_pa == 0) {
			valloc_pages(kernel_l1pt, L1_TABLE_SIZE / PAGE_SIZE);
		} else {
			valloc_pages(kernel_pt_table[loop1],
			    L2_TABLE_SIZE / PAGE_SIZE);
			++loop1;
		}
	}

	/* This should never be able to happen but better confirm that. */
	if (!kernel_l1pt.pv_pa || (kernel_l1pt.pv_pa & (L1_TABLE_SIZE-1)) != 0)
		panic("initarm: Failed to align the kernel page directory");

	/*
	 * Allocate a page for the system page mapped to V0x00000000
	 * This page will just contain the system vectors and can be
	 * shared by all processes.
	 */
	vector_page = ARM_VECTORS_HIGH;
	alloc_pages(systempage.pv_pa, 1);
	systempage.pv_va = vector_page;

	/* Allocate stacks for all modes */
	valloc_pages(irqstack, IRQ_STACK_SIZE);
	valloc_pages(abtstack, ABT_STACK_SIZE);
	valloc_pages(undstack, UND_STACK_SIZE);
	valloc_pages(kernelstack, UPAGES);

	/* Allocate enough pages for cleaning the Mini-Data cache. */

#ifdef VERBOSE_INIT_ARM
	printf("IRQ stack: p0x%08lx v0x%08lx\n", irqstack.pv_pa,
	    irqstack.pv_va); 
	printf("ABT stack: p0x%08lx v0x%08lx\n", abtstack.pv_pa,
	    abtstack.pv_va); 
	printf("UND stack: p0x%08lx v0x%08lx\n", undstack.pv_pa,
	    undstack.pv_va); 
	printf("SVC stack: p0x%08lx v0x%08lx\n", kernelstack.pv_pa,
	    kernelstack.pv_va); 
#endif

	/*
	 * XXX Defer this to later so that we can reclaim the memory
	 * XXX used by the RedBoot page tables.
	 */
	alloc_pages(msgbufphys, round_page(MSGBUFSIZE) / PAGE_SIZE);

	/*
	 * Ok we have allocated physical pages for the primary kernel
	 * page tables
	 */

#ifdef VERBOSE_INIT_ARM
	printf("Creating L1 page table at 0x%08lx\n", kernel_l1pt.pv_pa);
#endif

	/*
	 * Now we start construction of the L1 page table
	 * We start by mapping the L2 page tables into the L1.
	 * This means that we can replace L1 mappings later on if necessary
	 */
	l1pagetable = kernel_l1pt.pv_pa;

	/* Map the L2 pages tables in the L1 page table */
	pmap_link_l2pt(l1pagetable, vector_page & ~(0x00400000 - 1),
	    &kernel_pt_table[KERNEL_PT_SYS]);

	for (loop = 0; loop < KERNEL_PT_KERNEL_NUM; loop++)
		pmap_link_l2pt(l1pagetable, KERNEL_BASE + loop * 0x00400000,
		    &kernel_pt_table[KERNEL_PT_KERNEL + loop]);

	for (loop = 0; loop < KERNEL_PT_VMDATA_NUM; loop++)
		pmap_link_l2pt(l1pagetable, KERNEL_VM_BASE + loop * 0x00400000,
		    &kernel_pt_table[KERNEL_PT_VMDATA + loop]);

	/* update the top of the kernel VM */
	pmap_curmaxkvaddr =
	    KERNEL_VM_BASE + (KERNEL_PT_VMDATA_NUM * 0x00400000);

#ifdef VERBOSE_INIT_ARM
	printf("Mapping kernel\n");
#endif

	/* Now we fill in the L2 pagetable for the kernel static code/data */
	{
		extern char etext[];
		size_t textsize = (u_int32_t) etext - KERNEL_TEXT_BASE;
		size_t totalsize = (u_int32_t) esym - KERNEL_TEXT_BASE;
		u_int logical;

		textsize = (textsize + PGOFSET) & ~PGOFSET;
		totalsize = (totalsize + PGOFSET) & ~PGOFSET;
		
		logical = 0x00000000;	/* offset of kernel in RAM */

		logical += pmap_map_chunk(l1pagetable, KERNEL_BASE + logical,
		    physical_start + logical, textsize,
		    VM_PROT_READ|VM_PROT_WRITE|VM_PROT_EXECUTE, PTE_CACHE);
		logical += pmap_map_chunk(l1pagetable, KERNEL_BASE + logical,
		    physical_start + logical, totalsize - textsize,
		    VM_PROT_READ|VM_PROT_WRITE, PTE_CACHE);
	}

#ifdef VERBOSE_INIT_ARM
	printf("Constructing L2 page tables\n");
#endif

	/* Map the stack pages */
	pmap_map_chunk(l1pagetable, irqstack.pv_va, irqstack.pv_pa,
	    IRQ_STACK_SIZE * PAGE_SIZE, VM_PROT_READ|VM_PROT_WRITE, PTE_CACHE);
	pmap_map_chunk(l1pagetable, abtstack.pv_va, abtstack.pv_pa,
	    ABT_STACK_SIZE * PAGE_SIZE, VM_PROT_READ|VM_PROT_WRITE, PTE_CACHE);
	pmap_map_chunk(l1pagetable, undstack.pv_va, undstack.pv_pa,
	    UND_STACK_SIZE * PAGE_SIZE, VM_PROT_READ|VM_PROT_WRITE, PTE_CACHE);
	pmap_map_chunk(l1pagetable, kernelstack.pv_va, kernelstack.pv_pa,
	    UPAGES * PAGE_SIZE, VM_PROT_READ | VM_PROT_WRITE, PTE_CACHE);

	pmap_map_chunk(l1pagetable, kernel_l1pt.pv_va, kernel_l1pt.pv_pa,
	    L1_TABLE_SIZE, VM_PROT_READ | VM_PROT_WRITE, PTE_PAGETABLE);

	for (loop = 0; loop < NUM_KERNEL_PTS; ++loop) {
		pmap_map_chunk(l1pagetable, kernel_pt_table[loop].pv_va,
		    kernel_pt_table[loop].pv_pa, L2_TABLE_SIZE,
		    VM_PROT_READ|VM_PROT_WRITE, PTE_PAGETABLE);
	}

	/* Map the Mini-Data cache clean area. */

	/* Map the vector page. */
#if 0
	/* MULTI-ICE requires that page 0 is NC/NB so that it can download the
	 * cache-clean code there.  */
	pmap_map_entry(l1pagetable, vector_page, systempage.pv_pa,
	    VM_PROT_READ|VM_PROT_WRITE|VM_PROT_EXECUTE, PTE_NOCACHE);
#else
	pmap_map_entry(l1pagetable, vector_page, systempage.pv_pa,
	    VM_PROT_READ|VM_PROT_WRITE|VM_PROT_EXECUTE, PTE_CACHE);
#endif

	/*
	 * map integrated peripherals at same address in l1pagetable
	 * so that we can continue to use console.
	 */
	copy_io_area_map((pd_entry_t *)l1pagetable);


	/*
	 * Now we have the real page tables in place so we can switch to them.
	 * Once this is done we will be running with the REAL kernel page
	 * tables.
	 */

	/* be a client to all domains */
	cpu_domains(0x55555555);
	/* Switch tables */

	cpu_domains((DOMAIN_CLIENT << (PMAP_DOMAIN_KERNEL*2)) | DOMAIN_CLIENT);
	setttb(kernel_l1pt.pv_pa);
	cpu_tlb_flushID();
	cpu_domains(DOMAIN_CLIENT << (PMAP_DOMAIN_KERNEL*2));

	/*
	 * Moved from cpu_startup() as data_abort_handler() references
	 * this during uvm init
	 */
	proc0paddr = (struct user *)kernelstack.pv_va;
	proc0.p_addr = proc0paddr;

	arm32_vector_init(vector_page, ARM_VEC_ALL);

	/*
	 * Pages were allocated during the secondary bootstrap for the
	 * stacks for different CPU modes.
	 * We must now set the r13 registers in the different CPU modes to
	 * point to these stacks.
	 * Since the ARM stacks use STMFD etc. we must set r13 to the top end
	 * of the stack memory.
	 */

	set_stackptr(PSR_IRQ32_MODE,
	    irqstack.pv_va + IRQ_STACK_SIZE * PAGE_SIZE);
	set_stackptr(PSR_ABT32_MODE,
	    abtstack.pv_va + ABT_STACK_SIZE * PAGE_SIZE);
	set_stackptr(PSR_UND32_MODE,
	    undstack.pv_va + UND_STACK_SIZE * PAGE_SIZE);

	/*
	 * Well we should set a data abort handler.
	 * Once things get going this will change as we will need a proper
	 * handler.
	 * Until then we will use a handler that just panics but tells us
	 * why.
	 * Initialisation of the vectors will just panic on a data abort.
	 * This just fills in a slighly better one.
	 */

	data_abort_handler_address = (u_int)data_abort_handler;
	prefetch_abort_handler_address = (u_int)prefetch_abort_handler;
	undefined_handler_address = (u_int)undefinedinstruction_bounce;

	/* Initialise the undefined instruction handlers */
#ifdef VERBOSE_INIT_ARM
	printf("undefined ");
#endif
	undefined_init();

	/* Load memory into UVM. */
#ifdef VERBOSE_INIT_ARM
	printf("page ");
#endif
	uvm_setpagesize();        /* initialize PAGE_SIZE-dependent variables */
	uvm_page_physload(atop(physical_freestart), atop(physical_freeend),
	    atop(physical_freestart), atop(physical_freeend), 0);

	/* Boot strap pmap telling it where the kernel page table is */
#ifdef VERBOSE_INIT_ARM
	printf("pmap ");
#endif
	pmap_bootstrap((pd_entry_t *)kernel_l1pt.pv_va, KERNEL_VM_BASE,
	    KERNEL_VM_BASE + KERNEL_VM_SIZE);

#ifdef IPKDB
	/* Initialise ipkdb */
	ipkdb_init();
	if (boothowto & RB_KDB)
		ipkdb_connect(0);
#endif

	/*
	 * Restore proper bus_space operation, now that pmap is initialized.
	 */
#if defined(CPU_ARMv7) 
	armv7_bs_tag.bs_map = map_func_save;
	armv7_a4x_bs_tag.bs_map = map_func_save;
#endif

#ifdef DDB
	db_machine_init();

	/* Firmware doesn't load symbols. */
	ddb_init();

	if (boothowto & RB_KDB)
		Debugger();
#endif

a102 3

	/* We return the new stack pointer address */
	return(kernelstack.pv_va + USPACE_SVC_STACK_TOP);
a104 1

d106 1
a106 1
process_kernel_args(char *args)
d108 11
a118 85
	char *cp = args;

	if (cp == NULL) {
		boothowto = RB_AUTOBOOT;
		return;
	}

	boothowto = 0;

	/* Make a local copy of the bootargs */
	strncpy(bootargs, cp, MAX_BOOT_STRING - sizeof(int));

	cp = bootargs;
	boot_file = bootargs;

	/* Skip the kernel image filename */
	while (*cp != ' ' && *cp != 0)
		++cp;

	if (*cp != 0)
		*cp++ = 0;

	while (*cp == ' ')
		++cp;

	boot_args = cp;

	printf("bootfile: %s\n", boot_file);
	printf("bootargs: %s\n", boot_args);

	/* Setup pointer to boot flags */
	while (*cp != '-')
		if (*cp++ == '\0')
			return;

	for (;*++cp;) {
		int fl;

		fl = 0;
		switch(*cp) {
		case 'a':
			fl |= RB_ASKNAME;
			break;
		case 'c':
			fl |= RB_CONFIG;
			break;
		case 'd':
			fl |= RB_KDB;
			break;
		case 's':
			fl |= RB_SINGLE;
			break;
		default:
			printf("unknown option `%c'\n", *cp);
			break;
		}
		boothowto |= fl;
	}
}

void
consinit(void)
{
	static int consinit_called = 0;
	paddr_t paddr;

	if (consinit_called != 0)
		return;

	consinit_called = 1;

	switch (board_id) {
	case BOARD_ID_IMX6_PHYFLEX:
		paddr = 0x021f0000;
		break;
	case BOARD_ID_IMX6_SABRELITE:
		paddr = 0x021e8000;
		break;
	case BOARD_ID_IMX6_WANDBOARD:
		paddr = 0x02020000;
		break;
	default:
		printf("board type %x unknown", board_id);
		return;
		/* XXX - HELP */
a119 1
	imxuartcnattach(&armv7_bs_tag, paddr, comcnspeed, comcnmode);
a121 3

//int glass_console = 0;

d123 1
a123 1
board_startup(void)
a124 8
        if (boothowto & RB_CONFIG) {
#ifdef BOOT_CONFIG
		user_config();
#else
		printf("kernel does not support -c; continuing..\n");
#endif
	}
}
a125 5
void
platform_smc_write(bus_space_tag_t iot, bus_space_handle_t ioh, bus_size_t off,
    uint32_t op, uint32_t val)
{
	bus_space_write_4(iot, ioh, off, val);
@


1.4
log
@Support for the i.MX6-based Wandboard Quad.

From Artturi Alm.
@
text
@d1 1
a1 1
/*	$OpenBSD: imx_machdep.c,v 1.3 2013/09/28 14:16:41 miod Exp $ */
d468 1
d553 1
a553 2
		extern char _end[];
		physical_freestart = (((unsigned long)_end - KERNEL_TEXT_BASE +0xfff) & ~0xfff) + memstart;
d697 1
a697 1
		extern char etext[], _end[];
d699 1
a699 1
		size_t totalsize = (u_int32_t) _end - KERNEL_TEXT_BASE;
@


1.3
log
@A few missing config_suspend(, DVACT_POWERDOWN) constructs after
doshutdownhooks() calls.
XXX arm-based ports ought to really share their reboot code.
@
text
@d1 1
a1 1
/*	$OpenBSD: imx_machdep.c,v 1.2 2013/09/28 12:40:28 miod Exp $ */
d867 4
d960 3
@


1.2
log
@In boot(), do not iterate over alldevs if it's empty (i.e. halting from ddb
with ddb entered early with boot -d or from UKC).
@
text
@d1 1
a1 1
/*	$OpenBSD: imx_machdep.c,v 1.1 2013/09/06 20:45:53 patrick Exp $ */
d304 2
@


1.1
log
@Support for FreeScale's i.MX6 SoC.
@
text
@d1 1
a1 1
/*	$OpenBSD: beagle_machdep.c,v 1.15 2012/08/30 15:51:13 deraadt Exp $ */
d339 2
a340 1
	config_suspend(TAILQ_FIRST(&alldevs), DVACT_POWERDOWN);
@

