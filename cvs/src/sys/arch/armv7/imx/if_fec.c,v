head	1.20;
access;
symbols
	OPENBSD_6_1:1.20.0.4
	OPENBSD_6_1_BASE:1.20
	OPENBSD_6_0:1.10.0.4
	OPENBSD_6_0_BASE:1.10;
locks; strict;
comment	@ * @;


1.20
date	2017.01.22.10.17.37;	author dlg;	state Exp;
branches;
next	1.19;
commitid	VyLWTsbepAOk7VQM;

1.19
date	2016.10.21.22.34.00;	author jsg;	state Exp;
branches;
next	1.18;
commitid	Ug5cFKL0YuvxHmSJ;

1.18
date	2016.09.22.12.43.22;	author kettenis;	state Exp;
branches;
next	1.17;
commitid	X0jN9eym2VDWuoEe;

1.17
date	2016.09.21.10.28.47;	author kettenis;	state Exp;
branches;
next	1.16;
commitid	WSNINXXJy6z4z9R9;

1.16
date	2016.08.19.18.25.53;	author kettenis;	state Exp;
branches;
next	1.15;
commitid	VacxF4TCR6CiTq0y;

1.15
date	2016.08.06.17.18.38;	author kettenis;	state Exp;
branches;
next	1.14;
commitid	cnh4dl1psoWEBlsr;

1.14
date	2016.08.06.04.03.20;	author jsg;	state Exp;
branches;
next	1.13;
commitid	AkUhRkxAbnYpTsop;

1.13
date	2016.08.04.15.52.52;	author kettenis;	state Exp;
branches;
next	1.12;
commitid	WNhzA3xU3jFFVhST;

1.12
date	2016.08.04.14.14.05;	author kettenis;	state Exp;
branches;
next	1.11;
commitid	I260rblEVARmCbQQ;

1.11
date	2016.07.27.11.45.02;	author patrick;	state Exp;
branches;
next	1.10;
commitid	yc14meyJgxIAcvAg;

1.10
date	2016.07.23.14.39.10;	author kettenis;	state Exp;
branches;
next	1.9;
commitid	3ExDHgZWePmU2P0m;

1.9
date	2016.07.22.13.20.30;	author jsg;	state Exp;
branches;
next	1.8;
commitid	tPzbImnnkVRtCteJ;

1.8
date	2016.07.21.02.32.23;	author jsg;	state Exp;
branches;
next	1.7;
commitid	J7FyhifKWIqJz3bV;

1.7
date	2016.07.14.14.05.51;	author kettenis;	state Exp;
branches;
next	1.6;
commitid	FYysnOHRpADNSsEr;

1.6
date	2016.07.11.14.56.18;	author kettenis;	state Exp;
branches;
next	1.5;
commitid	6KOEoE8OaM2bF6DZ;

1.5
date	2016.07.10.11.46.28;	author kettenis;	state Exp;
branches;
next	1.4;
commitid	hkXva6w0XSlF6284;

1.4
date	2016.07.09.12.39.28;	author kettenis;	state Exp;
branches;
next	1.3;
commitid	OPaRXnvRNvQe7e30;

1.3
date	2016.06.22.20.15.31;	author kettenis;	state Exp;
branches;
next	1.2;
commitid	IR1OBJbqYVPiito6;

1.2
date	2016.06.12.13.02.06;	author kettenis;	state Exp;
branches;
next	1.1;
commitid	OAwuwG6755ENLV7d;

1.1
date	2016.06.03.01.36.46;	author jsg;	state Exp;
branches;
next	;
commitid	YA7F4i0IfchI1r7q;


desc
@@


1.20
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@/* $OpenBSD: if_fec.c,v 1.19 2016/10/21 22:34:00 jsg Exp $ */
/*
 * Copyright (c) 2012-2013 Patrick Wildt <patrick@@blueri.se>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/sockio.h>
#include <sys/queue.h>
#include <sys/malloc.h>
#include <sys/device.h>
#include <sys/evcount.h>
#include <sys/socket.h>
#include <sys/timeout.h>
#include <sys/mbuf.h>
#include <machine/intr.h>
#include <machine/bus.h>
#include <machine/fdt.h>

#include "bpfilter.h"

#include <net/if.h>
#include <net/if_media.h>
#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <dev/mii/mii.h>
#include <dev/mii/miivar.h>
#include <dev/mii/miidevs.h>

#include <armv7/armv7/armv7var.h>
#include <armv7/imx/imxccmvar.h>
#include <armv7/imx/imxgpiovar.h>

#include <dev/ofw/openfirm.h>
#include <dev/ofw/ofw_gpio.h>
#include <dev/ofw/ofw_pinctrl.h>
#include <dev/ofw/fdt.h>

/* configuration registers */
#define ENET_EIR		0x004
#define ENET_EIMR		0x008
#define ENET_RDAR		0x010
#define ENET_TDAR		0x014
#define ENET_ECR		0x024
#define ENET_MMFR		0x040
#define ENET_MSCR		0x044
#define ENET_MIBC		0x064
#define ENET_RCR		0x084
#define ENET_TCR		0x0C4
#define ENET_PALR		0x0E4
#define ENET_PAUR		0x0E8
#define ENET_OPD		0x0EC
#define ENET_IAUR		0x118
#define ENET_IALR		0x11C
#define ENET_GAUR		0x120
#define ENET_GALR		0x124
#define ENET_TFWR		0x144
#define ENET_RDSR		0x180
#define ENET_TDSR		0x184
#define ENET_MRBR		0x188
#define ENET_RSFL		0x190
#define ENET_RSEM		0x194
#define ENET_RAEM		0x198
#define ENET_RAFL		0x19C
#define ENET_TSEM		0x1A0
#define ENET_TAEM		0x1A4
#define ENET_TAFL		0x1A8
#define ENET_TIPG		0x1AC
#define ENET_FTRL		0x1B0
#define ENET_TACC		0x1C0
#define ENET_RACC		0x1C4

#define ENET_RDAR_RDAR		(1 << 24)
#define ENET_TDAR_TDAR		(1 << 24)
#define ENET_ECR_RESET		(1 << 0)
#define ENET_ECR_ETHEREN	(1 << 1)
#define ENET_ECR_EN1588		(1 << 4)
#define ENET_ECR_SPEED		(1 << 5)
#define ENET_ECR_DBSWP		(1 << 8)
#define ENET_MMFR_TA		(2 << 16)
#define ENET_MMFR_RA_SHIFT	18
#define ENET_MMFR_PA_SHIFT	23
#define ENET_MMFR_OP_WR		(1 << 28)
#define ENET_MMFR_OP_RD		(2 << 28)
#define ENET_MMFR_ST		(1 << 30)
#define ENET_RCR_MII_MODE	(1 << 2)
#define ENET_RCR_PROM		(1 << 3)
#define ENET_RCR_FCE		(1 << 5)
#define ENET_RCR_RGMII_MODE	(1 << 6)
#define ENET_RCR_RMII_10T	(1 << 9)
#define ENET_RCR_MAX_FL(x)	(((x) & 0x3fff) << 16)
#define ENET_TCR_FDEN		(1 << 2)
#define ENET_EIR_MII		(1 << 23)
#define ENET_EIR_RXF		(1 << 25)
#define ENET_EIR_TXF		(1 << 27)
#define ENET_TFWR_STRFWD	(1 << 8)

/* statistics counters */

/* 1588 control */
#define ENET_ATCR		0x400
#define ENET_ATVR		0x404
#define ENET_ATOFF		0x408
#define ENET_ATPER		0x40C
#define ENET_ATCOR		0x410
#define ENET_ATINC		0x414
#define ENET_ATSTMP		0x418

/* capture / compare block */
#define ENET_TGSR		0x604
#define ENET_TCSR0		0x608
#define ENET_TCCR0		0x60C
#define ENET_TCSR1		0x610
#define ENET_TCCR1		0x614
#define ENET_TCSR2		0x618
#define ENET_TCCR2		0x61C
#define ENET_TCSR3		0x620
#define ENET_TCCR3		0x624

#define ENET_MII_CLK		2500
#define ENET_ALIGNMENT		16

#define HREAD4(sc, reg)							\
	(bus_space_read_4((sc)->sc_iot, (sc)->sc_ioh, (reg)))
#define HWRITE4(sc, reg, val)						\
	bus_space_write_4((sc)->sc_iot, (sc)->sc_ioh, (reg), (val))
#define HSET4(sc, reg, bits)						\
	HWRITE4((sc), (reg), HREAD4((sc), (reg)) | (bits))
#define HCLR4(sc, reg, bits)						\
	HWRITE4((sc), (reg), HREAD4((sc), (reg)) & ~(bits))

/* what should we use? */
#define ENET_MAX_TXD		32
#define ENET_MAX_RXD		32

#define ENET_MAX_PKT_SIZE	1536

#define ENET_ROUNDUP(size, unit) (((size) + (unit) - 1) & ~((unit) - 1))

/* buffer descriptor status bits */
#define ENET_RXD_EMPTY		(1 << 15)
#define ENET_RXD_WRAP		(1 << 13)
#define ENET_RXD_LAST		(1 << 11)
#define ENET_RXD_MISS		(1 << 8)
#define ENET_RXD_BC		(1 << 7)
#define ENET_RXD_MC		(1 << 6)
#define ENET_RXD_LG		(1 << 5)
#define ENET_RXD_NO		(1 << 4)
#define ENET_RXD_CR		(1 << 2)
#define ENET_RXD_OV		(1 << 1)
#define ENET_RXD_TR		(1 << 0)

#define ENET_TXD_READY		(1 << 15)
#define ENET_TXD_WRAP		(1 << 13)
#define ENET_TXD_LAST		(1 << 11)
#define ENET_TXD_TC		(1 << 10)
#define ENET_TXD_ABC		(1 << 9)
#define ENET_TXD_STATUS_MASK	0x3ff

#ifdef ENET_ENHANCED_BD
/* enhanced */
#define ENET_RXD_INT		(1 << 23)

#define ENET_TXD_INT		(1 << 30)
#endif

/*
 * Bus dma allocation structure used by
 * fec_dma_malloc and fec_dma_free.
 */
struct fec_dma_alloc {
	bus_addr_t		dma_paddr;
	caddr_t			dma_vaddr;
	bus_dma_tag_t		dma_tag;
	bus_dmamap_t		dma_map;
	bus_dma_segment_t	dma_seg;
	bus_size_t		dma_size;
	int			dma_nseg;
};

struct fec_buf_desc {
	uint16_t data_length;		/* payload's length in bytes */
	uint16_t status;		/* BD's status (see datasheet) */
	uint32_t data_pointer;		/* payload's buffer address */
#ifdef ENET_ENHANCED_BD
	uint32_t enhanced_status;	/* enhanced status with IEEE 1588 */
	uint32_t reserved0;		/* reserved */
	uint32_t update_done;		/* buffer descriptor update done */
	uint32_t timestamp;		/* IEEE 1588 timestamp */
	uint32_t reserved1[2];		/* reserved */
#endif
};

struct fec_buffer {
	uint8_t data[ENET_MAX_PKT_SIZE];
};

struct fec_softc {
	struct device		sc_dev;
	struct arpcom		sc_ac;
	struct mii_data		sc_mii;
	int			sc_node;
	bus_space_tag_t		sc_iot;
	bus_space_handle_t	sc_ioh;
	void			*sc_ih; /* Interrupt handler */
	bus_dma_tag_t		sc_dma_tag;
	struct fec_dma_alloc	txdma;		/* bus_dma glue for tx desc */
	struct fec_buf_desc	*tx_desc_base;
	struct fec_dma_alloc	rxdma;		/* bus_dma glue for rx desc */
	struct fec_buf_desc	*rx_desc_base;
	struct fec_dma_alloc	tbdma;		/* bus_dma glue for packets */
	struct fec_buffer	*tx_buffer_base;
	struct fec_dma_alloc	rbdma;		/* bus_dma glue for packets */
	struct fec_buffer	*rx_buffer_base;
	int			cur_tx;
	int			cur_rx;
	struct timeout		sc_tick;
};

struct fec_softc *fec_sc;

int fec_match(struct device *, void *, void *);
void fec_attach(struct device *, struct device *, void *);
void fec_phy_init(struct fec_softc *, struct mii_softc *);
int fec_ioctl(struct ifnet *, u_long, caddr_t);
void fec_start(struct ifnet *);
int fec_encap(struct fec_softc *, struct mbuf *);
void fec_init_txd(struct fec_softc *);
void fec_init_rxd(struct fec_softc *);
void fec_init(struct fec_softc *);
void fec_stop(struct fec_softc *);
void fec_iff(struct fec_softc *);
struct mbuf * fec_newbuf(void);
int fec_intr(void *);
void fec_recv(struct fec_softc *);
void fec_tick(void *);
int fec_miibus_readreg(struct device *, int, int);
void fec_miibus_writereg(struct device *, int, int, int);
void fec_miibus_statchg(struct device *);
int fec_ifmedia_upd(struct ifnet *);
void fec_ifmedia_sts(struct ifnet *, struct ifmediareq *);
int fec_dma_malloc(struct fec_softc *, bus_size_t, struct fec_dma_alloc *);
void fec_dma_free(struct fec_softc *, struct fec_dma_alloc *);

struct cfattach fec_ca = {
	sizeof (struct fec_softc), fec_match, fec_attach
};

struct cfdriver fec_cd = {
	NULL, "fec", DV_IFNET
};

int
fec_match(struct device *parent, void *match, void *aux)
{
	struct fdt_attach_args *faa = aux;

	return OF_is_compatible(faa->fa_node, "fsl,imx6q-fec");
}

void
fec_attach(struct device *parent, struct device *self, void *aux)
{
	struct fec_softc *sc = (struct fec_softc *) self;
	struct fdt_attach_args *faa = aux;
	struct mii_data *mii;
	struct mii_softc *child;
	struct ifnet *ifp;
	int tsize, rsize, tbsize, rbsize, s;
	uint32_t phy_reset_gpio[3];
	uint32_t phy_reset_duration;

	if (faa->fa_nreg < 1)
		return;

	sc->sc_node = faa->fa_node;
	sc->sc_iot = faa->fa_iot;
	if (bus_space_map(sc->sc_iot, faa->fa_reg[0].addr,
	    faa->fa_reg[0].size, 0, &sc->sc_ioh))
		panic("fec_attach: bus_space_map failed!");

	sc->sc_dma_tag = faa->fa_dmat;

	pinctrl_byname(faa->fa_node, "default");

	/* power it up */
	imxccm_enable_enet();

	/* reset PHY */
	if (OF_getpropintarray(faa->fa_node, "phy-reset-gpios", phy_reset_gpio,
	    sizeof(phy_reset_gpio)) == sizeof(phy_reset_gpio)) {
		phy_reset_duration = OF_getpropint(faa->fa_node,
		    "phy-reset-duration", 1);
		if (phy_reset_duration > 1000)
			phy_reset_duration = 1;

		/*
		 * The Linux people really screwed the pooch here.
		 * The Linux kernel always treats the gpio as
		 * active-low, even if it is marked as active-high in
		 * the device tree.  As a result the device tree for
		 * many boards incorrectly marks the gpio as
		 * active-high.  
		 */
		phy_reset_gpio[2] = GPIO_ACTIVE_LOW;
		gpio_controller_config_pin(phy_reset_gpio, GPIO_CONFIG_OUTPUT);

		/*
		 * On some Cubox-i machines we need to hold the PHY in
		 * reset a little bit longer than specified.
		 */
		gpio_controller_set_pin(phy_reset_gpio, 1);
		delay((phy_reset_duration + 1) * 1000);
		gpio_controller_set_pin(phy_reset_gpio, 0);
		delay(1000);
	}
	printf("\n");

	/* Figure out the hardware address. Must happen before reset. */
	OF_getprop(faa->fa_node, "local-mac-address", sc->sc_ac.ac_enaddr,
	    sizeof(sc->sc_ac.ac_enaddr));

	/* reset the controller */
	HSET4(sc, ENET_ECR, ENET_ECR_RESET);
	while(HREAD4(sc, ENET_ECR) & ENET_ECR_RESET);

	HWRITE4(sc, ENET_EIMR, 0);
	HWRITE4(sc, ENET_EIR, 0xffffffff);

	sc->sc_ih = arm_intr_establish_fdt(faa->fa_node, IPL_NET,
	    fec_intr, sc, sc->sc_dev.dv_xname);

	tsize = ENET_MAX_TXD * sizeof(struct fec_buf_desc);
	tsize = ENET_ROUNDUP(tsize, PAGE_SIZE);

	if (fec_dma_malloc(sc, tsize, &sc->txdma)) {
		printf("%s: Unable to allocate tx_desc memory\n",
		    sc->sc_dev.dv_xname);
		goto bad;
	}
	sc->tx_desc_base = (struct fec_buf_desc *)sc->txdma.dma_vaddr;

	rsize = ENET_MAX_RXD * sizeof(struct fec_buf_desc);
	rsize = ENET_ROUNDUP(rsize, PAGE_SIZE);

	if (fec_dma_malloc(sc, rsize, &sc->rxdma)) {
		printf("%s: Unable to allocate rx_desc memory\n",
		    sc->sc_dev.dv_xname);
		goto txdma;
	}
	sc->rx_desc_base = (struct fec_buf_desc *)sc->rxdma.dma_vaddr;

	tbsize = ENET_MAX_TXD * ENET_MAX_PKT_SIZE;
	tbsize = ENET_ROUNDUP(tbsize, PAGE_SIZE);

	if (fec_dma_malloc(sc, tbsize, &sc->tbdma)) {
		printf("%s: Unable to allocate tx_buffer memory\n",
		    sc->sc_dev.dv_xname);
		goto rxdma;
	}
	sc->tx_buffer_base = (struct fec_buffer *)sc->tbdma.dma_vaddr;

	rbsize = ENET_MAX_RXD * ENET_MAX_PKT_SIZE;
	rbsize = ENET_ROUNDUP(rbsize, PAGE_SIZE);

	if (fec_dma_malloc(sc, rbsize, &sc->rbdma)) {
		printf("%s: Unable to allocate rx_buffer memory\n",
		    sc->sc_dev.dv_xname);
		goto tbdma;
	}
	sc->rx_buffer_base = (struct fec_buffer *)sc->rbdma.dma_vaddr;

	sc->cur_tx = 0;
	sc->cur_rx = 0;

	s = splnet();

	ifp = &sc->sc_ac.ac_if;
	ifp->if_softc = sc;
	strlcpy(ifp->if_xname, sc->sc_dev.dv_xname, IFNAMSIZ);
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ifp->if_ioctl = fec_ioctl;
	ifp->if_start = fec_start;
	ifp->if_capabilities = IFCAP_VLAN_MTU;

	printf("%s: address %s\n", sc->sc_dev.dv_xname,
	    ether_sprintf(sc->sc_ac.ac_enaddr));

	/* initialize the MII clock */
	HWRITE4(sc, ENET_MSCR,
	    (((imxccm_get_fecclk() + (ENET_MII_CLK << 2) - 1) / (ENET_MII_CLK << 2)) << 1) | 0x100);

	/* Initialize MII/media info. */
	mii = &sc->sc_mii;
	mii->mii_ifp = ifp;
	mii->mii_readreg = fec_miibus_readreg;
	mii->mii_writereg = fec_miibus_writereg;
	mii->mii_statchg = fec_miibus_statchg;

	ifmedia_init(&mii->mii_media, 0, fec_ifmedia_upd, fec_ifmedia_sts);
	mii_attach(self, mii, 0xffffffff, MII_PHY_ANY, MII_OFFSET_ANY, 0);

	child = LIST_FIRST(&mii->mii_phys);
	if (child)
		fec_phy_init(sc, child);

	if (LIST_FIRST(&mii->mii_phys) == NULL) {
		ifmedia_add(&mii->mii_media, IFM_ETHER | IFM_NONE, 0, NULL);
		ifmedia_set(&mii->mii_media, IFM_ETHER | IFM_NONE);
	} else
		ifmedia_set(&mii->mii_media, IFM_ETHER | IFM_AUTO);

	if_attach(ifp);
	ether_ifattach(ifp);
	splx(s);

	timeout_set(&sc->sc_tick, fec_tick, sc);

	fec_sc = sc;
	return;

tbdma:
	fec_dma_free(sc, &sc->tbdma);
rxdma:
	fec_dma_free(sc, &sc->rxdma);
txdma:
	fec_dma_free(sc, &sc->txdma);
bad:
	bus_space_unmap(sc->sc_iot, sc->sc_ioh, faa->fa_reg[0].size);
}

void
fec_phy_init(struct fec_softc *sc, struct mii_softc *child)
{
	struct device *dev = (struct device *)sc;
	int phy = child->mii_phy;
	uint32_t reg;

	if (child->mii_oui == MII_OUI_ATHEROS &&
	    child->mii_model == MII_MODEL_ATHEROS_AR8035) {
		/* disable SmartEEE */
		fec_miibus_writereg(dev, phy, 0x0d, 0x0003);
		fec_miibus_writereg(dev, phy, 0x0e, 0x805d);
		fec_miibus_writereg(dev, phy, 0x0d, 0x4003);
		reg = fec_miibus_readreg(dev, phy, 0x0e);
		fec_miibus_writereg(dev, phy, 0x0e, reg & ~0x0100);

		/* enable 125MHz clk output */
		fec_miibus_writereg(dev, phy, 0x0d, 0x0007);
		fec_miibus_writereg(dev, phy, 0x0e, 0x8016);
		fec_miibus_writereg(dev, phy, 0x0d, 0x4007);

		reg = fec_miibus_readreg(dev, phy, 0x0e) & 0xffe3;
		fec_miibus_writereg(dev, phy, 0x0e, reg | 0x18);

		/* tx clock delay */
		fec_miibus_writereg(dev, phy, 0x1d, 0x0005);
		reg = fec_miibus_readreg(dev, phy, 0x1e);
		fec_miibus_writereg(dev, phy, 0x1e, reg | 0x0100);

		PHY_RESET(child);
	}

	if (child->mii_oui == MII_OUI_MICREL &&
	    child->mii_model == MII_MODEL_MICREL_KSZ9021) {
		uint32_t rxc, rxdv, txc, txen;
		uint32_t rxd0, rxd1, rxd2, rxd3;
		uint32_t txd0, txd1, txd2, txd3;
		uint32_t val;

		rxc = OF_getpropint(sc->sc_node, "rxc-skew-ps", 1400) / 200;
		rxdv = OF_getpropint(sc->sc_node, "rxdv-skew-ps", 1400) / 200;
		txc = OF_getpropint(sc->sc_node, "txc-skew-ps", 1400) / 200;
		txen = OF_getpropint(sc->sc_node, "txen-skew-ps", 1400) / 200;
		rxd0 = OF_getpropint(sc->sc_node, "rxd0-skew-ps", 1400) / 200;
		rxd1 = OF_getpropint(sc->sc_node, "rxd1-skew-ps", 1400) / 200;
		rxd2 = OF_getpropint(sc->sc_node, "rxd2-skew-ps", 1400) / 200;
		rxd3 = OF_getpropint(sc->sc_node, "rxd3-skew-ps", 1400) / 200;
		txd0 = OF_getpropint(sc->sc_node, "txd0-skew-ps", 1400) / 200;
		txd1 = OF_getpropint(sc->sc_node, "txd1-skew-ps", 1400) / 200;
		txd2 = OF_getpropint(sc->sc_node, "txd2-skew-ps", 1400) / 200;
		txd3 = OF_getpropint(sc->sc_node, "txd3-skew-ps", 1400) / 200;

		val = ((rxc & 0xf) << 12) | ((rxdv & 0xf) << 8) |
		    ((txc & 0xf) << 4) | ((txen & 0xf) << 0);
		fec_miibus_writereg(dev, phy, 0x0b, 0x8104);
		fec_miibus_writereg(dev, phy, 0x0c, val);

		val = ((rxd3 & 0xf) << 12) | ((rxd2 & 0xf) << 8) |
		    ((rxd1 & 0xf) << 4) | ((rxd0 & 0xf) << 0);
		fec_miibus_writereg(dev, phy, 0x0b, 0x8105);
		fec_miibus_writereg(dev, phy, 0x0c, val);

		val = ((txd3 & 0xf) << 12) | ((txd2 & 0xf) << 8) |
		    ((txd1 & 0xf) << 4) | ((txd0 & 0xf) << 0);
		fec_miibus_writereg(dev, phy, 0x0b, 0x8106);
		fec_miibus_writereg(dev, phy, 0x0c, val);
	}

	if (child->mii_oui == MII_OUI_MICREL &&
	    child->mii_model == MII_MODEL_MICREL_KSZ9031) {
		uint32_t rxc, rxdv, txc, txen;
		uint32_t rxd0, rxd1, rxd2, rxd3;
		uint32_t txd0, txd1, txd2, txd3;
		uint32_t val;

		rxc = OF_getpropint(sc->sc_node, "rxc-skew-ps", 900) / 60;
		rxdv = OF_getpropint(sc->sc_node, "rxdv-skew-ps", 420) / 60;
		txc = OF_getpropint(sc->sc_node, "txc-skew-ps", 900) / 60;
		txen = OF_getpropint(sc->sc_node, "txen-skew-ps", 420) / 60;
		rxd0 = OF_getpropint(sc->sc_node, "rxd0-skew-ps", 420) / 60;
		rxd1 = OF_getpropint(sc->sc_node, "rxd1-skew-ps", 420) / 60;
		rxd2 = OF_getpropint(sc->sc_node, "rxd2-skew-ps", 420) / 60;
		rxd3 = OF_getpropint(sc->sc_node, "rxd3-skew-ps", 420) / 60;
		txd0 = OF_getpropint(sc->sc_node, "txd0-skew-ps", 420) / 60;
		txd1 = OF_getpropint(sc->sc_node, "txd1-skew-ps", 420) / 60;
		txd2 = OF_getpropint(sc->sc_node, "txd2-skew-ps", 420) / 60;
		txd3 = OF_getpropint(sc->sc_node, "txd3-skew-ps", 420) / 60;

		val = ((rxdv & 0xf) << 4) || ((txen & 0xf) << 0);
		fec_miibus_writereg(dev, phy, 0x0d, 0x0002);
		fec_miibus_writereg(dev, phy, 0x0e, 0x0004);
		fec_miibus_writereg(dev, phy, 0x0d, 0x4002);
		fec_miibus_writereg(dev, phy, 0x0e, val);

		val = ((rxd3 & 0xf) << 12) | ((rxd2 & 0xf) << 8) |
		    ((rxd1 & 0xf) << 4) | ((rxd0 & 0xf) << 0);
		fec_miibus_writereg(dev, phy, 0x0d, 0x0002);
		fec_miibus_writereg(dev, phy, 0x0e, 0x0005);
		fec_miibus_writereg(dev, phy, 0x0d, 0x4002);
		fec_miibus_writereg(dev, phy, 0x0e, val);

		val = ((txd3 & 0xf) << 12) | ((txd2 & 0xf) << 8) |
		    ((txd1 & 0xf) << 4) | ((txd0 & 0xf) << 0);
		fec_miibus_writereg(dev, phy, 0x0d, 0x0002);
		fec_miibus_writereg(dev, phy, 0x0e, 0x0006);
		fec_miibus_writereg(dev, phy, 0x0d, 0x4002);
		fec_miibus_writereg(dev, phy, 0x0e, val);

		val = ((txc & 0x1f) << 5) || ((rxc & 0x1f) << 0);
		fec_miibus_writereg(dev, phy, 0x0d, 0x0002);
		fec_miibus_writereg(dev, phy, 0x0e, 0x0008);
		fec_miibus_writereg(dev, phy, 0x0d, 0x4002);
		fec_miibus_writereg(dev, phy, 0x0e, val);
	}
}

void
fec_init_rxd(struct fec_softc *sc)
{
	int i;

	memset(sc->rx_desc_base, 0, ENET_MAX_RXD * sizeof(struct fec_buf_desc));

	for (i = 0; i < ENET_MAX_RXD; i++)
	{
		sc->rx_desc_base[i].status = ENET_RXD_EMPTY;
		sc->rx_desc_base[i].data_pointer = sc->rbdma.dma_paddr + i * ENET_MAX_PKT_SIZE;
#ifdef ENET_ENHANCED_BD
		sc->rx_desc_base[i].enhanced_status = ENET_RXD_INT;
#endif
	}

	sc->rx_desc_base[i - 1].status |= ENET_RXD_WRAP;
}

void
fec_init_txd(struct fec_softc *sc)
{
	int i;

	memset(sc->tx_desc_base, 0, ENET_MAX_TXD * sizeof(struct fec_buf_desc));

	for (i = 0; i < ENET_MAX_TXD; i++)
	{
		sc->tx_desc_base[i].data_pointer = sc->tbdma.dma_paddr + i * ENET_MAX_PKT_SIZE;
	}

	sc->tx_desc_base[i - 1].status |= ENET_TXD_WRAP;
}

void
fec_init(struct fec_softc *sc)
{
	struct ifnet *ifp = &sc->sc_ac.ac_if;
	int speed = 0;

	/* reset the controller */
	HSET4(sc, ENET_ECR, ENET_ECR_RESET);
	while(HREAD4(sc, ENET_ECR) & ENET_ECR_RESET);

	/* set hw address */
	HWRITE4(sc, ENET_PALR,
	    (sc->sc_ac.ac_enaddr[0] << 24) |
	    (sc->sc_ac.ac_enaddr[1] << 16) |
	    (sc->sc_ac.ac_enaddr[2] << 8) |
	     sc->sc_ac.ac_enaddr[3]);
	HWRITE4(sc, ENET_PAUR,
	    (sc->sc_ac.ac_enaddr[4] << 24) |
	    (sc->sc_ac.ac_enaddr[5] << 16));

	/* clear outstanding interrupts */
	HWRITE4(sc, ENET_EIR, 0xffffffff);

	/* set max receive buffer size, 3-0 bits always zero for alignment */
	HWRITE4(sc, ENET_MRBR, ENET_MAX_PKT_SIZE);

	/* set descriptor */
	HWRITE4(sc, ENET_TDSR, sc->txdma.dma_paddr);
	HWRITE4(sc, ENET_RDSR, sc->rxdma.dma_paddr);

	/* init descriptor */
	fec_init_txd(sc);
	fec_init_rxd(sc);

	/* set it to full-duplex */
	HWRITE4(sc, ENET_TCR, ENET_TCR_FDEN);

	/*
	 * Set max frame length to 1518 or 1522 with VLANs,
	 * pause frames and promisc mode.
	 * XXX: RGMII mode - phy dependant
	 */
	HWRITE4(sc, ENET_RCR,
	    ENET_RCR_MAX_FL(1522) | ENET_RCR_RGMII_MODE | ENET_RCR_MII_MODE |
	    ENET_RCR_FCE);

	bus_space_write_4(sc->sc_iot, sc->sc_ioh, ENET_MSCR,
	    (((imxccm_get_fecclk() + (ENET_MII_CLK << 2) - 1) / (ENET_MII_CLK << 2)) << 1) | 0x100);

	/* RX FIFO treshold and pause */
	HWRITE4(sc, ENET_RSEM, 0x84);
	HWRITE4(sc, ENET_RSFL, 16);
	HWRITE4(sc, ENET_RAEM, 8);
	HWRITE4(sc, ENET_RAFL, 8);
	HWRITE4(sc, ENET_OPD, 0xFFF0);

	/* do store and forward, only i.MX6, needs to be set correctly else */
	HWRITE4(sc, ENET_TFWR, ENET_TFWR_STRFWD);

	/* enable gigabit-ethernet and set it to support little-endian */
	switch (IFM_SUBTYPE(sc->sc_mii.mii_media_active)) {
	case IFM_1000_T:  /* Gigabit */
		speed |= ENET_ECR_SPEED;
		break;
	default:
		speed &= ~ENET_ECR_SPEED;
	}
	HWRITE4(sc, ENET_ECR, ENET_ECR_ETHEREN | speed | ENET_ECR_DBSWP);

#ifdef ENET_ENHANCED_BD
	HSET4(sc, ENET_ECR, ENET_ECR_EN1588);
#endif

	/* rx descriptors are ready */
	HWRITE4(sc, ENET_RDAR, ENET_RDAR_RDAR);

	/* program promiscuous mode and multicast filters */
	fec_iff(sc);

	timeout_add_sec(&sc->sc_tick, 1);

	/* Indicate we are up and running. */
	ifp->if_flags |= IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	/* enable interrupts for tx/rx */
	HWRITE4(sc, ENET_EIMR, ENET_EIR_TXF | ENET_EIR_RXF);

	fec_start(ifp);
}

void
fec_stop(struct fec_softc *sc)
{
	struct ifnet *ifp = &sc->sc_ac.ac_if;

	/*
	 * Mark the interface down and cancel the watchdog timer.
	 */
	ifp->if_flags &= ~IFF_RUNNING;
	ifp->if_timer = 0;
	ifq_clr_oactive(&ifp->if_snd);

	timeout_del(&sc->sc_tick);

	/* reset the controller */
	HSET4(sc, ENET_ECR, ENET_ECR_RESET);
	while(HREAD4(sc, ENET_ECR) & ENET_ECR_RESET);
}

void
fec_iff(struct fec_softc *sc)
{
	struct arpcom *ac = &sc->sc_ac;
	struct ifnet *ifp = &sc->sc_ac.ac_if;
	struct ether_multi *enm;
	struct ether_multistep step;
	uint64_t ghash = 0, ihash = 0;
	uint32_t h;

	ifp->if_flags &= ~IFF_ALLMULTI;

	if (ifp->if_flags & IFF_PROMISC) {
		ifp->if_flags |= IFF_ALLMULTI;
		ihash = 0xffffffffffffffffLLU;
	} else if (ac->ac_multirangecnt > 0) {
		ifp->if_flags |= IFF_ALLMULTI;
		ghash = 0xffffffffffffffffLLU;
	} else {
		ETHER_FIRST_MULTI(step, ac, enm);
		while (enm != NULL) {
			h = ether_crc32_le(enm->enm_addrlo, ETHER_ADDR_LEN);

			ghash |= 1LLU << (((uint8_t *)&h)[3] >> 2);

			ETHER_NEXT_MULTI(step, enm);
		}
	}

	HWRITE4(sc, ENET_GAUR, (uint32_t)(ghash >> 32));
	HWRITE4(sc, ENET_GALR, (uint32_t)ghash);

	HWRITE4(sc, ENET_IAUR, (uint32_t)(ihash >> 32));
	HWRITE4(sc, ENET_IALR, (uint32_t)ihash);
}

int
fec_ioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
{
	struct fec_softc *sc = ifp->if_softc;
	struct ifreq *ifr = (struct ifreq *)data;
	int s, error = 0;

	s = splnet();

	switch (cmd) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		if (!(ifp->if_flags & IFF_RUNNING))
			fec_init(sc);
		break;

	case SIOCSIFFLAGS:
		if (ifp->if_flags & IFF_UP) {
			if (ifp->if_flags & IFF_RUNNING)
				error = ENETRESET;
			else
				fec_init(sc);
		} else {
			if (ifp->if_flags & IFF_RUNNING)
				fec_stop(sc);
		}
		break;

	case SIOCGIFMEDIA:
	case SIOCSIFMEDIA:
		error = ifmedia_ioctl(ifp, ifr, &sc->sc_mii.mii_media, cmd);
		break;

	default:
		error = ether_ioctl(ifp, &sc->sc_ac, cmd, data);
	}

	if (error == ENETRESET) {
		if (ifp->if_flags & IFF_RUNNING)
			fec_iff(sc);
		error = 0;
	}

	splx(s);
	return(error);
}

void
fec_start(struct ifnet *ifp)
{
	struct fec_softc *sc = ifp->if_softc;
	struct mbuf *m_head = NULL;

	if (ifq_is_oactive(&ifp->if_snd) || !(ifp->if_flags & IFF_RUNNING))
		return;

	for (;;) {
		m_head = ifq_deq_begin(&ifp->if_snd);
		if (m_head == NULL)
			break;

		if (fec_encap(sc, m_head)) {
			ifq_deq_rollback(&ifp->if_snd, m_head);
			ifq_set_oactive(&ifp->if_snd);
			break;
		}

		ifq_deq_commit(&ifp->if_snd, m_head);

#if NBPFILTER > 0
		if (ifp->if_bpf)
			bpf_mtap(ifp->if_bpf, m_head, BPF_DIRECTION_OUT);
#endif

		m_freem(m_head);
	}
}

int
fec_encap(struct fec_softc *sc, struct mbuf *m)
{
	if (sc->tx_desc_base[sc->cur_tx].status & ENET_TXD_READY) {
		printf("fec: tx queue full!\n");
		return EIO;
	}

	if (m->m_pkthdr.len > ENET_MAX_PKT_SIZE) {
		printf("fec: packet too big\n");
		return EIO;
	}

	/* copy in the actual packet */
	m_copydata(m, 0, m->m_pkthdr.len, (caddr_t)sc->tx_buffer_base[sc->cur_tx].data);

	sc->tx_desc_base[sc->cur_tx].data_length = m->m_pkthdr.len;

	sc->tx_desc_base[sc->cur_tx].status &= ~ENET_TXD_STATUS_MASK;
	sc->tx_desc_base[sc->cur_tx].status |= (ENET_TXD_READY | ENET_TXD_LAST | ENET_TXD_TC);

#ifdef ENET_ENHANCED_BD
	sc->tx_desc_base[sc->cur_tx].enhanced_status = ENET_TXD_INT;
	sc->tx_desc_base[sc->cur_tx].update_done = 0;
#endif

	bus_dmamap_sync(sc->tbdma.dma_tag, sc->tbdma.dma_map,
	    ENET_MAX_PKT_SIZE * sc->cur_tx, ENET_MAX_PKT_SIZE,
	    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);

	bus_dmamap_sync(sc->txdma.dma_tag, sc->txdma.dma_map,
	    sizeof(struct fec_buf_desc) * sc->cur_tx,
	    sizeof(struct fec_buf_desc),
	    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);


	/* tx descriptors are ready */
	HWRITE4(sc, ENET_TDAR, ENET_TDAR_TDAR);

	if (sc->tx_desc_base[sc->cur_tx].status & ENET_TXD_WRAP)
		sc->cur_tx = 0;
	else
		sc->cur_tx++;

	return 0;
}

struct mbuf *
fec_newbuf(void)
{
	struct mbuf *m;

	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m == NULL)
		return (NULL);

	MCLGET(m, M_DONTWAIT);
	if (!(m->m_flags & M_EXT)) {
		m_freem(m);
		return (NULL);
	}

	return (m);
}

/*
 * Established by attachment driver at interrupt priority IPL_NET.
 */
int
fec_intr(void *arg)
{
	struct fec_softc *sc = arg;
	struct ifnet *ifp = &sc->sc_ac.ac_if;
	u_int32_t status;

	/* Find out which interrupts are pending. */
	status = HREAD4(sc, ENET_EIR);

	/* Acknowledge the interrupts we are about to handle. */
	HWRITE4(sc, ENET_EIR, status);

	/*
	 * Handle incoming packets.
	 */
	if (ISSET(status, ENET_EIR_RXF)) {
		if (ifp->if_flags & IFF_RUNNING)
			fec_recv(sc);
	}

	/* Try to transmit. */
	if (ifp->if_flags & IFF_RUNNING && !IFQ_IS_EMPTY(&ifp->if_snd))
		fec_start(ifp);

	return 1;
}

void
fec_recv(struct fec_softc *sc)
{
	struct ifnet *ifp = &sc->sc_ac.ac_if;
	struct mbuf_list ml = MBUF_LIST_INITIALIZER();

	bus_dmamap_sync(sc->rbdma.dma_tag, sc->rbdma.dma_map,
	    0, sc->rbdma.dma_size,
	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);

	bus_dmamap_sync(sc->rxdma.dma_tag, sc->rxdma.dma_map,
	    0, sc->rxdma.dma_size,
	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);

	while (!(sc->rx_desc_base[sc->cur_rx].status & ENET_RXD_EMPTY))
	{
		struct mbuf *m;
		m = fec_newbuf();

		if (m == NULL) {
			ifp->if_ierrors++;
			goto done;
		}

		m->m_pkthdr.len = m->m_len = sc->rx_desc_base[sc->cur_rx].data_length;
		m_adj(m, ETHER_ALIGN);

		memcpy(mtod(m, char *), sc->rx_buffer_base[sc->cur_rx].data,
		    sc->rx_desc_base[sc->cur_rx].data_length);

		sc->rx_desc_base[sc->cur_rx].status |= ENET_RXD_EMPTY;
		sc->rx_desc_base[sc->cur_rx].data_length = 0;

		bus_dmamap_sync(sc->rbdma.dma_tag, sc->rbdma.dma_map,
		    ENET_MAX_PKT_SIZE * sc->cur_rx, ENET_MAX_PKT_SIZE,
		    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);

		bus_dmamap_sync(sc->rxdma.dma_tag, sc->rxdma.dma_map,
		    sizeof(struct fec_buf_desc) * sc->cur_rx,
		    sizeof(struct fec_buf_desc),
		    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);

		if (sc->rx_desc_base[sc->cur_rx].status & ENET_RXD_WRAP)
			sc->cur_rx = 0;
		else
			sc->cur_rx++;

		ml_enqueue(&ml, m);
	}

done:
	/* rx descriptors are ready */
	HWRITE4(sc, ENET_RDAR, ENET_RDAR_RDAR);

	if_input(ifp, &ml);
}

void
fec_tick(void *arg)
{
	struct fec_softc *sc = arg;
	int s;

	s = splnet();
	mii_tick(&sc->sc_mii);
	splx(s);

	timeout_add_sec(&sc->sc_tick, 1);
}

/*
 * MII
 * Interrupts need ENET_ECR_ETHEREN to be set,
 * so we just read the interrupt status registers.
 */
int
fec_miibus_readreg(struct device *dev, int phy, int reg)
{
	int r = 0;
	struct fec_softc *sc = (struct fec_softc *)dev;

	HSET4(sc, ENET_EIR, ENET_EIR_MII);

	bus_space_write_4(sc->sc_iot, sc->sc_ioh, ENET_MMFR,
	    ENET_MMFR_ST | ENET_MMFR_OP_RD | ENET_MMFR_TA |
	    phy << ENET_MMFR_PA_SHIFT | reg << ENET_MMFR_RA_SHIFT);

	while(!(HREAD4(sc, ENET_EIR) & ENET_EIR_MII));

	r = bus_space_read_4(sc->sc_iot, sc->sc_ioh, ENET_MMFR);

	return (r & 0xffff);
}

void
fec_miibus_writereg(struct device *dev, int phy, int reg, int val)
{
	struct fec_softc *sc = (struct fec_softc *)dev;

	HSET4(sc, ENET_EIR, ENET_EIR_MII);

	bus_space_write_4(sc->sc_iot, sc->sc_ioh, ENET_MMFR,
	    ENET_MMFR_ST | ENET_MMFR_OP_WR | ENET_MMFR_TA |
	    phy << ENET_MMFR_PA_SHIFT | reg << ENET_MMFR_RA_SHIFT |
	    (val & 0xffff));

	while(!(HREAD4(sc, ENET_EIR) & ENET_EIR_MII));

	return;
}

void
fec_miibus_statchg(struct device *dev)
{
	struct fec_softc *sc = (struct fec_softc *)dev;
	uint32_t ecr, rcr;

	ecr = HREAD4(sc, ENET_ECR) & ~ENET_ECR_SPEED;
	rcr = HREAD4(sc, ENET_RCR) & ~ENET_RCR_RMII_10T;
	switch (IFM_SUBTYPE(sc->sc_mii.mii_media_active)) {
	case IFM_1000_T:  /* Gigabit */
		ecr |= ENET_ECR_SPEED;
		break;
	case IFM_100_TX:
		break;
	case IFM_10_T:
		rcr |= ENET_RCR_RMII_10T;
		break;
	}
	HWRITE4(sc, ENET_ECR, ecr);
	HWRITE4(sc, ENET_RCR, rcr);

	return;
}

int
fec_ifmedia_upd(struct ifnet *ifp)
{
	struct fec_softc *sc = ifp->if_softc;
	struct mii_data *mii = &sc->sc_mii;
	int err;
	if (mii->mii_instance) {
		struct mii_softc *miisc;

		LIST_FOREACH(miisc, &mii->mii_phys, mii_list)
			mii_phy_reset(miisc);
	}
	err = mii_mediachg(mii);
	return (err);
}

void
fec_ifmedia_sts(struct ifnet *ifp, struct ifmediareq *ifmr)
{
	struct fec_softc *sc = ifp->if_softc;
	struct mii_data *mii = &sc->sc_mii;

	mii_pollstat(mii);

	ifmr->ifm_active = mii->mii_media_active;
	ifmr->ifm_status = mii->mii_media_status;
}

/*
 * Manage DMA'able memory.
 */
int
fec_dma_malloc(struct fec_softc *sc, bus_size_t size,
    struct fec_dma_alloc *dma)
{
	int r;

	dma->dma_tag = sc->sc_dma_tag;
	r = bus_dmamem_alloc(dma->dma_tag, size, ENET_ALIGNMENT, 0, &dma->dma_seg,
	    1, &dma->dma_nseg, BUS_DMA_NOWAIT);
	if (r != 0) {
		printf("%s: fec_dma_malloc: bus_dmammem_alloc failed; "
			"size %lu, error %d\n", sc->sc_dev.dv_xname,
			(unsigned long)size, r);
		goto fail_0;
	}

	r = bus_dmamem_map(dma->dma_tag, &dma->dma_seg, dma->dma_nseg, size,
	    &dma->dma_vaddr, BUS_DMA_NOWAIT|BUS_DMA_COHERENT);
	if (r != 0) {
		printf("%s: fec_dma_malloc: bus_dmammem_map failed; "
			"size %lu, error %d\n", sc->sc_dev.dv_xname,
			(unsigned long)size, r);
		goto fail_1;
	}

	r = bus_dmamap_create(dma->dma_tag, size, 1,
	    size, 0, BUS_DMA_NOWAIT, &dma->dma_map);
	if (r != 0) {
		printf("%s: fec_dma_malloc: bus_dmamap_create failed; "
			"error %u\n", sc->sc_dev.dv_xname, r);
		goto fail_2;
	}

	r = bus_dmamap_load(dma->dma_tag, dma->dma_map,
			    dma->dma_vaddr, size, NULL,
			    BUS_DMA_NOWAIT);
	if (r != 0) {
		printf("%s: fec_dma_malloc: bus_dmamap_load failed; "
			"error %u\n", sc->sc_dev.dv_xname, r);
		goto fail_3;
	}

	dma->dma_size = size;
	dma->dma_paddr = dma->dma_map->dm_segs[0].ds_addr;
	return (0);

fail_3:
	bus_dmamap_destroy(dma->dma_tag, dma->dma_map);
fail_2:
	bus_dmamem_unmap(dma->dma_tag, dma->dma_vaddr, size);
fail_1:
	bus_dmamem_free(dma->dma_tag, &dma->dma_seg, dma->dma_nseg);
fail_0:
	dma->dma_map = NULL;
	dma->dma_tag = NULL;

	return (r);
}

void
fec_dma_free(struct fec_softc *sc, struct fec_dma_alloc *dma)
{
	if (dma->dma_tag == NULL)
		return;

	if (dma->dma_map != NULL) {
		bus_dmamap_sync(dma->dma_tag, dma->dma_map, 0,
		    dma->dma_map->dm_mapsize,
		    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);
		bus_dmamap_unload(dma->dma_tag, dma->dma_map);
		bus_dmamem_unmap(dma->dma_tag, dma->dma_vaddr, dma->dma_size);
		bus_dmamem_free(dma->dma_tag, &dma->dma_seg, dma->dma_nseg);
		bus_dmamap_destroy(dma->dma_tag, dma->dma_map);
	}
	dma->dma_tag = NULL;
}
@


1.19
log
@Stop setting MIIF_AUTOTSLEEP in fec(4)

This can lead to tsleep in an interrupt context, which resulted in the
following panic:

kernel diagnostic assertion "p->p_wchan == NULL" failed: file
 "/usr/src/sys/kern/kern_sched.c", line 333

    TID   PPID   PGRP    UID  S       FLAGS  WAIT          COMMAND
  86009      0      0      0  2  0x40014200  miiaut        idle0

Reported by matthieu@@ with sabre lite, analysis by guenther@@
ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_fec.c,v 1.18 2016/09/22 12:43:22 kettenis Exp $ */
a812 2

		ifp->if_opackets++;
@


1.18
log
@Periodically call mii_tick() like all our other ethernet drivers that use
mii(4).  Should fix the link negotiation issues that people have been seeing.

ok jsg@@, mikeb@@, guenther@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_fec.c,v 1.17 2016/09/21 10:28:47 kettenis Exp $ */
a415 1
	mii->mii_flags = MIIF_AUTOTSLEEP;
@


1.17
log
@Remove some dead code and only enable tx and rx interrupts.

ok patrick@@, tom@@, mikeb@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_fec.c,v 1.16 2016/08/19 18:25:53 kettenis Exp $ */
d234 1
d253 1
d435 2
d679 2
d703 2
d977 13
@


1.16
log
@Seems we need to hold the PHY into reset a little bit longer.  Without it
Theo's Cubox-i comes up without working Ethernet after a warm boot.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_fec.c,v 1.15 2016/08/06 17:18:38 kettenis Exp $ */
a223 1
	uint32_t		intr_status;	/* soft interrupt status */
a251 1
int fec_wait_intr(struct fec_softc *, int, int);
a680 1
	HWRITE4(sc, ENET_EIMR, 0xffffffff);
a899 9
	 * Wake up the blocking process to service command
	 * related interrupt(s).
	 */
	if (ISSET(status, ENET_EIR_MII)) {
		sc->intr_status |= status;
		wakeup(&sc->intr_status);
	}

	/*
a968 22
}

int
fec_wait_intr(struct fec_softc *sc, int mask, int timo)
{
	int status;
	int s;

	s = splnet();

	status = sc->intr_status;
	while (status == 0) {
		if (tsleep(&sc->intr_status, PWAIT, "hcintr", timo)
		    == EWOULDBLOCK) {
			break;
		}
		status = sc->intr_status;
	}
	sc->intr_status &= ~status;

	splx(s);
	return status;
@


1.15
log
@Switch imx over to the generic pinctrl API.

ok patrick@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_fec.c,v 1.14 2016/08/06 04:03:20 jsg Exp $ */
d323 1
d325 4
a328 1
		gpio_controller_config_pin(phy_reset_gpio, GPIO_CONFIG_OUTPUT);
d330 1
a330 1
		delay(phy_reset_duration * 1000);
@


1.14
log
@remove now unused board specific phy defines
@
text
@d1 1
a1 1
/* $OpenBSD: if_fec.c,v 1.13 2016/08/04 15:52:52 kettenis Exp $ */
a49 1
#include <armv7/imx/imxiomuxcvar.h>
d53 1
d301 1
a301 1
	imxiomuxc_pinctrlbyname(faa->fa_node, "default");
@


1.13
log
@Dynamically attach ampintc(4) and make it register itself as an interrupt
controller.  Switch all i.MX6 devices over to the new FDT-aware interrupt
establish API and enable imxgpc(4).

This may break other platforms that use ampintc(4) as their interrupt
controller.  We will fix this as soon as possible by switching them over
to the new interrupt establish API as well.

This also removes the hack in fec(4) to avoid the gpio-based interrupt
workaround.  This commit is an essential step on the road to fix that
issue properly.

ok patrick@@, jsg@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_fec.c,v 1.12 2016/08/04 14:14:05 kettenis Exp $ */
a138 11

#define ENET_HUMMINGBOARD_PHY_RST		(3*32+15)
#define ENET_SABRELITE_PHY			6
#define ENET_SABRELITE_PHY_RST			(2*32+23)
#define ENET_SABRESD_PHY_RST			(0*32+25)
#define ENET_NITROGEN6X_PHY_RST			(0*32+27)
#define ENET_UDOO_PHY				6
#define ENET_UDOO_PHY_RST			(2*32+23)
#define ENET_UDOO_PWR				(1*32+31)
#define ENET_NOVENA_PHY				7
#define ENET_NOVENA_PHY_RST			(2*32+23)
@


1.12
log
@After fixing up some of the AR8035 PHY registers, issue a reset.  This seems
to fix autonegotiation at 100BaseTX.  Drop the bit of code that powers up
the PHY as the reset should already take care of that.

ok patrick@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_fec.c,v 1.11 2016/07/27 11:45:02 patrick Exp $ */
a297 1
	uint32_t intr[8];
a303 4
	if (OF_getpropintarray(faa->fa_node, "interrupts-extended",
	    intr, sizeof(intr)) < sizeof(intr))
		intr[2] = 0x76;

d354 1
a354 1
	sc->sc_ih = arm_intr_establish(intr[2], IPL_NET,
@


1.11
log
@Instead of passing the raw reg property to simplebus nodes,
pass a pre-processed array of fdt_reg structs.  This means
that the drivers don't have to understand the cell properties
themselves but can rely on the 64-bit addr/size pairs.

ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_fec.c,v 1.10 2016/07/23 14:39:10 kettenis Exp $ */
d489 1
a489 4
		/* phy power */
		reg = fec_miibus_readreg(dev, phy, 0x00);
		if (reg & 0x0800)
			fec_miibus_writereg(dev, phy, 0x00, reg & ~0x0800);
@


1.10
log
@The linux kernel treated the "phy-reset-gpio" as active-low regardless of what
the device tree says.  As a result many device trees encode it as active-high
when active-low is needed.  For now just override the device tree.

ok jsg@@, patrick@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_fec.c,v 1.9 2016/07/22 13:20:30 jsg Exp $ */
d54 1
d302 1
a302 1
	if (faa->fa_nreg < 2)
d311 2
a312 2
	if (bus_space_map(sc->sc_iot, faa->fa_reg[0],
	    faa->fa_reg[1], 0, &sc->sc_ioh))
d457 1
a457 1
	bus_space_unmap(sc->sc_iot, sc->sc_ioh, faa->fa_reg[1]);
@


1.9
log
@Fallback to the known fec irq number on imx.6 if the fdt
interrupts-extended property is missing or not the size we expect.

Some dtbs implement a workaround for "ERR006687 ENET: Only the ENET
wake-up interrupt request can wake the system from Wait mode" suggested
by the IMX6DQCE errata document to set an undocumented gpio mux mode and
handle the interrupt via gpio.

We don't support gpio interrupts yet, hopefully this change is enough
to make interrupts work on wandboard and sabre lite again till we do.

Discussed with kettenis and patrick, tested on sabre lite by patrick.
@
text
@d1 1
a1 1
/* $OpenBSD: if_fec.c,v 1.8 2016/07/21 02:32:23 jsg Exp $ */
d329 10
d340 2
a342 2
		delay(phy_reset_duration * 1000);
		gpio_controller_set_pin(phy_reset_gpio, 1);
@


1.8
log
@set and clear the 10baseT bit in statchg
ok patrick@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_fec.c,v 1.7 2016/07/14 14:05:51 kettenis Exp $ */
d306 1
a306 1
		return;
@


1.7
log
@Do board-specific delay/skew corrections for the Micrel KSZ9021 and KSZ9031
PHYs based on device tree properties instead of the board ID.  Untested as
I don't have the hardware.

ok jsg@@, patrick@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_fec.c,v 1.6 2016/07/11 14:56:18 kettenis Exp $ */
d106 1
d1054 1
a1054 1
	int ecr;
d1056 2
a1057 1
	ecr = HREAD4(sc, ENET_ECR);
d1062 5
a1066 2
	default:
		ecr &= ~ENET_ECR_SPEED;
d1069 1
@


1.6
log
@Use gpio framework to implement hardware reset of the PHY instead of
hardcoding particular gpios based on board IDs.

ok visa@@, jsg@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_fec.c,v 1.5 2016/07/10 11:46:28 kettenis Exp $ */
d228 1
a228 1
	int			sc_phyno;
a249 1
void fec_chip_init(struct fec_softc *);
d307 1
d406 3
a408 2
	/* initialize the chip */
	fec_chip_init(sc);
a448 88
fec_chip_init(struct fec_softc *sc)
{
	struct device *dev = (struct device *) sc;
	int phy = 0;

	bus_space_write_4(sc->sc_iot, sc->sc_ioh, ENET_MSCR,
	    (((imxccm_get_fecclk() + (ENET_MII_CLK << 2) - 1) / (ENET_MII_CLK << 2)) << 1) | 0x100);

	switch (board_id)
	{
	case BOARD_ID_IMX6_SABRELITE:
		phy = ENET_SABRELITE_PHY;
		break;
	case BOARD_ID_IMX6_UDOO:
		phy = ENET_UDOO_PHY;
		break;
	case BOARD_ID_IMX6_NOVENA:
		phy = ENET_NOVENA_PHY;
		break;
	}

	switch (board_id)
	{
	case BOARD_ID_IMX6_UDOO:	/* Micrel KSZ9031 */
		/* prefer master mode */
		fec_miibus_writereg(dev, phy, 0x9, 0x1c00);

		/* control data pad skew */
		fec_miibus_writereg(dev, phy, 0x0d, 0x0002);
		fec_miibus_writereg(dev, phy, 0x0e, 0x0004);
		fec_miibus_writereg(dev, phy, 0x0d, 0x4002);
		fec_miibus_writereg(dev, phy, 0x0e, 0x0000);

		/* rx data pad skew */
		fec_miibus_writereg(dev, phy, 0x0d, 0x0002);
		fec_miibus_writereg(dev, phy, 0x0e, 0x0005);
		fec_miibus_writereg(dev, phy, 0x0d, 0x4002);
		fec_miibus_writereg(dev, phy, 0x0e, 0x0000);

		/* tx data pad skew */
		fec_miibus_writereg(dev, phy, 0x0d, 0x0002);
		fec_miibus_writereg(dev, phy, 0x0e, 0x0006);
		fec_miibus_writereg(dev, phy, 0x0d, 0x4002);
		fec_miibus_writereg(dev, phy, 0x0e, 0x0000);

		/* gtx and rx data pad skew */
		fec_miibus_writereg(dev, phy, 0x0d, 0x0002);
		fec_miibus_writereg(dev, phy, 0x0e, 0x0008);
		fec_miibus_writereg(dev, phy, 0x0d, 0x4002);
		fec_miibus_writereg(dev, phy, 0x0e, 0x03ff);
		break;
	case BOARD_ID_IMX6_SABRELITE:	/* Micrel KSZ9021 */
		/* prefer master mode */
		fec_miibus_writereg(dev, phy, 0x9, 0x1f00);

		/* min rx data delay */
		fec_miibus_writereg(dev, phy, 0x0b, 0x8105);
		fec_miibus_writereg(dev, phy, 0x0c, 0x0000);

		/* min tx data delay */
		fec_miibus_writereg(dev, phy, 0x0b, 0x8106);
		fec_miibus_writereg(dev, phy, 0x0c, 0x0000);

		/* max rx/tx clock delay, min rx/tx control delay */
		fec_miibus_writereg(dev, phy, 0x0b, 0x8104);
		fec_miibus_writereg(dev, phy, 0x0c, 0xf0f0);
		fec_miibus_writereg(dev, phy, 0x0b, 0x104);

		/* enable all interrupts */
		fec_miibus_writereg(dev, phy, 0x1b, 0xff00);
		break;
	case BOARD_ID_IMX6_NOVENA:	/* Micrel KSZ9021 */
		/* TXEN_SKEW_PS/TXC_SKEW_PS/RXDV_SKEW_PS/RXC_SKEW_PS */
		fec_miibus_writereg(dev, phy, 0x0b, 0x8104);
		fec_miibus_writereg(dev, phy, 0x0c, 0xf0f0);

		/* RXD0_SKEW_PS/RXD1_SKEW_PS/RXD2_SKEW_PS/RXD3_SKEW_PS */
		fec_miibus_writereg(dev, phy, 0x0b, 0x8105);
		fec_miibus_writereg(dev, phy, 0x0c, 0x0000);

		/* TXD0_SKEW_PS/TXD1_SKEW_PS/TXD2_SKEW_PS/TXD3_SKEW_PS */
		fec_miibus_writereg(dev, phy, 0x0b, 0x8106);
		fec_miibus_writereg(dev, phy, 0x0c, 0xffff);
		break;
	}
}

void
d481 83
@


1.5
log
@Add support for handling pinctrl device tree bindings to imxiomuxc(4).
These are used to do board-specific setup of mux settings and pad
configuration.

ok jsg@@, patrick@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_fec.c,v 1.4 2016/07/09 12:39:28 kettenis Exp $ */
d53 1
d298 2
d320 13
a332 49
	switch (board_id)
	{
	case BOARD_ID_IMX6_CUBOXI:
	case BOARD_ID_IMX6_HUMMINGBOARD:
		/* We need to reset the AR8035 PHY twice. */
		imxgpio_clear_bit(ENET_HUMMINGBOARD_PHY_RST);
		imxgpio_set_dir(ENET_HUMMINGBOARD_PHY_RST, IMXGPIO_DIR_OUT);
		delay(2000);
		imxgpio_set_bit(ENET_HUMMINGBOARD_PHY_RST);
		delay(2000);
		imxgpio_clear_bit(ENET_HUMMINGBOARD_PHY_RST);
		delay(2000);
		imxgpio_set_bit(ENET_HUMMINGBOARD_PHY_RST);
		delay(2000);
		break;
	case BOARD_ID_IMX6_SABRELITE:
		/* SABRE Lite PHY reset */
		imxgpio_clear_bit(ENET_SABRELITE_PHY_RST);
		imxgpio_set_dir(ENET_SABRELITE_PHY_RST, IMXGPIO_DIR_OUT);
		imxgpio_clear_bit(ENET_NITROGEN6X_PHY_RST);
		imxgpio_set_dir(ENET_NITROGEN6X_PHY_RST, IMXGPIO_DIR_OUT);
		delay(1000 * 10);
		imxgpio_set_bit(ENET_SABRELITE_PHY_RST);
		imxgpio_set_bit(ENET_NITROGEN6X_PHY_RST);
		delay(100);
		break;
	case BOARD_ID_IMX6_SABRESD:
		imxgpio_clear_bit(ENET_SABRESD_PHY_RST);
		imxgpio_set_dir(ENET_SABRESD_PHY_RST, IMXGPIO_DIR_OUT);
		delay(1000 * 10);
		imxgpio_set_bit(ENET_SABRESD_PHY_RST);
		delay(100);
		break;
	case BOARD_ID_IMX6_UDOO:
		imxgpio_set_bit(ENET_UDOO_PWR);
		imxgpio_set_dir(ENET_UDOO_PWR, IMXGPIO_DIR_OUT);
		imxgpio_clear_bit(ENET_UDOO_PHY_RST);
		imxgpio_set_dir(ENET_UDOO_PHY_RST, IMXGPIO_DIR_OUT);
		delay(1000 * 1);
		imxgpio_set_bit(ENET_UDOO_PHY_RST);
		delay(1000 * 100);
		break;
	case BOARD_ID_IMX6_NOVENA:
		imxgpio_clear_bit(ENET_NOVENA_PHY_RST);
		imxgpio_set_dir(ENET_NOVENA_PHY_RST, IMXGPIO_DIR_OUT);
		delay(1000 * 10);
		imxgpio_set_bit(ENET_NOVENA_PHY_RST);
		delay(100);
		break;
@


1.4
log
@Perform PHY-specific initialization based on the PHY ID instead of the
board ID for the AR8031/AR8035.

ok jsg@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_fec.c,v 1.3 2016/06/22 20:15:31 kettenis Exp $ */
d50 1
a50 1
#include <armv7/imx/imxocotpvar.h>
d311 2
@


1.3
log
@Fetch MAC address from FDT.

ok jsg@@, patrick@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_fec.c,v 1.2 2016/06/12 13:02:06 kettenis Exp $ */
d45 1
a136 1
#define ENET_HUMMINGBOARD_PHY			0
a139 1
#define ENET_SABRESD_PHY			1
a140 1
#define ENET_NITROGEN6X_PHY			6
a144 2
#define ENET_UTILITE_PHY			0
#define ENET_WANDBOARD_PHY			1
d250 1
d293 1
d451 4
a482 1
	uint32_t reg;
a488 4
	case BOARD_ID_IMX6_CUBOXI:
	case BOARD_ID_IMX6_HUMMINGBOARD:
		phy = ENET_HUMMINGBOARD_PHY;
		break;
a491 3
	case BOARD_ID_IMX6_SABRESD:
		phy = ENET_SABRESD_PHY;
		break;
a494 3
	case BOARD_ID_IMX6_UTILITE:
		phy = ENET_UTILITE_PHY;
		break;
a497 3
	case BOARD_ID_IMX6_WANDBOARD:
		phy = ENET_WANDBOARD_PHY;
		break;
d563 12
a574 5
	case BOARD_ID_IMX6_CUBOXI:		/* AR8035 */
	case BOARD_ID_IMX6_HUMMINGBOARD:	/* AR8035 */
	case BOARD_ID_IMX6_SABRESD:		/* AR8031 */
	case BOARD_ID_IMX6_UTILITE:
	case BOARD_ID_IMX6_WANDBOARD:		/* AR8031 */
d582 1
a582 1
		/* enable 125MHz clk output for AR8031 */
a598 1
		break;
@


1.2
log
@Dynamically attach fec(4) using the FDT.

ok jsg@@, patrick@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_fec.c,v 1.1 2016/06/03 01:36:46 jsg Exp $ */
a252 2
int fec_enaddr_valid(u_char *);
void fec_enaddr(struct fec_softc *);
d370 2
a371 1
	fec_enaddr(sc);
a473 52
}

/* Try to determine a valid hardware address */
void
fec_enaddr(struct fec_softc *sc)
{
	u_int32_t tmp;
	u_char enaddr[6];

	/* XXX serial EEPROM */
	/* XXX FDT */

	/* Try to get an address from COTP */
	memset(enaddr, 0xff, ETHER_ADDR_LEN);
	imxocotp_get_ethernet_address(enaddr);
	if (fec_enaddr_valid(enaddr)) {
		memcpy(sc->sc_ac.ac_enaddr, enaddr, ETHER_ADDR_LEN);
		return;
	}

	/* The firmware or bootloader may have already set an address */
	tmp = HREAD4(sc, ENET_PALR);
	sc->sc_ac.ac_enaddr[0] = (tmp >> 24) & 0xff;
	sc->sc_ac.ac_enaddr[1] = (tmp >> 16) & 0xff;
	sc->sc_ac.ac_enaddr[2] = (tmp >> 8) & 0xff;
	sc->sc_ac.ac_enaddr[3] = tmp & 0xff;
	tmp = HREAD4(sc, ENET_PAUR);
	sc->sc_ac.ac_enaddr[4] = (tmp >> 24) & 0xff;
	sc->sc_ac.ac_enaddr[5] = (tmp >> 16) & 0xff;
	if (fec_enaddr_valid(sc->sc_ac.ac_enaddr))
		return;

	/* No usable address found, use a random one */
	printf("%s: no hardware address found, using random\n",
	    sc->sc_dev.dv_xname);
	ether_fakeaddr(&sc->sc_ac.ac_if);
}

int
fec_enaddr_valid(u_char addr[6])
{
	/* Multicast */
	if (ETHER_IS_MULTICAST(addr))
		return 0;
	/* All 0/1 */
	if (addr[0] == 0 && addr[1] == 0 && addr[2] == 0 &&
	    addr[3] == 0 && addr[4] == 0 && addr[5] == 0)
		return 0;
	if (addr[0] == 0xff && addr[1] == 0xff && addr[2] == 0xff &&
	    addr[3] == 0xff && addr[4] == 0xff && addr[5] == 0xff)
		return 0;
	return 1;
@


1.1
log
@rename imxenet to fec
ok patrick@@ kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d30 1
d51 2
d251 1
d277 1
a277 1
	sizeof (struct fec_softc), NULL, fec_attach
d284 8
d293 1
a293 1
fec_attach(struct device *parent, struct device *self, void *args)
a294 1
	struct armv7_attach_args *aa = args;
d296 1
d300 4
d305 7
a311 3
	sc->sc_iot = aa->aa_iot;
	if (bus_space_map(sc->sc_iot, aa->aa_dev->mem[0].addr,
	    aa->aa_dev->mem[0].size, 0, &sc->sc_ioh))
d314 1
a314 1
	sc->sc_dma_tag = aa->aa_dmat;
d381 1
a381 1
	sc->sc_ih = arm_intr_establish(aa->aa_dev->irq[0], IPL_NET,
d474 1
a474 1
	bus_space_unmap(sc->sc_iot, sc->sc_ioh, aa->aa_dev->mem[0].size);
@

