head	1.13;
access;
symbols
	OPENBSD_6_1_BASE:1.13
	OPENBSD_6_0:1.8.0.2
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.2.0.8
	OPENBSD_5_9_BASE:1.2
	OPENBSD_5_8:1.2.0.10
	OPENBSD_5_8_BASE:1.2
	OPENBSD_5_7:1.2.0.2
	OPENBSD_5_7_BASE:1.2
	OPENBSD_5_6:1.2.0.6
	OPENBSD_5_6_BASE:1.2
	OPENBSD_5_5:1.2.0.4
	OPENBSD_5_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.13
date	2017.03.06.06.44.46;	author kettenis;	state Exp;
branches;
next	1.12;
commitid	AyjphL8JeVmPKaZF;

1.12
date	2016.12.28.22.45.24;	author kettenis;	state Exp;
branches;
next	1.11;
commitid	zBEXGFcEf8Xpb4cn;

1.11
date	2016.08.06.17.18.38;	author kettenis;	state Exp;
branches;
next	1.10;
commitid	cnh4dl1psoWEBlsr;

1.10
date	2016.08.04.15.52.52;	author kettenis;	state Exp;
branches;
next	1.9;
commitid	WNhzA3xU3jFFVhST;

1.9
date	2016.07.27.11.45.02;	author patrick;	state Exp;
branches;
next	1.8;
commitid	yc14meyJgxIAcvAg;

1.8
date	2016.07.10.11.46.28;	author kettenis;	state Exp;
branches;
next	1.7;
commitid	hkXva6w0XSlF6284;

1.7
date	2016.06.09.12.35.46;	author kettenis;	state Exp;
branches;
next	1.6;
commitid	HvVxTDmFrZhsQ7sv;

1.6
date	2016.05.21.12.37.28;	author kettenis;	state Exp;
branches;
next	1.5;
commitid	G3o1EvQ7WmmxJj2I;

1.5
date	2016.05.20.20.33.54;	author kettenis;	state Exp;
branches;
next	1.4;
commitid	oFunV3wf5Td6k1oz;

1.4
date	2016.05.17.00.04.35;	author kettenis;	state Exp;
branches;
next	1.3;
commitid	CijrNWNJP9xbGk7R;

1.3
date	2016.05.16.21.38.35;	author kettenis;	state Exp;
branches;
next	1.2;
commitid	hzX1Pxf3g9MyJ3RL;

1.2
date	2013.11.06.19.03.07;	author syl;	state Exp;
branches;
next	1.1;

1.1
date	2013.09.06.20.45.53;	author patrick;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Remove unused unit number from softc.
@
text
@/* $OpenBSD: imxiic.c,v 1.12 2016/12/28 22:45:24 kettenis Exp $ */
/*
 * Copyright (c) 2013 Patrick Wildt <patrick@@blueri.se>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/device.h>
#include <sys/kernel.h>
#include <sys/systm.h>

#include <machine/bus.h>
#include <machine/fdt.h>

#include <armv7/imx/imxiicvar.h>

#include <dev/ofw/openfirm.h>
#include <dev/ofw/ofw_clock.h>
#include <dev/ofw/ofw_pinctrl.h>
#include <dev/ofw/fdt.h>

/* registers */
#define I2C_IADR	0x00
#define I2C_IFDR	0x04
#define I2C_I2CR	0x08
#define I2C_I2SR	0x0C
#define I2C_I2DR	0x10

#define I2C_I2CR_RSTA	(1 << 2)
#define I2C_I2CR_TXAK	(1 << 3)
#define I2C_I2CR_MTX	(1 << 4)
#define I2C_I2CR_MSTA	(1 << 5)
#define I2C_I2CR_IIEN	(1 << 6)
#define I2C_I2CR_IEN	(1 << 7)
#define I2C_I2SR_RXAK	(1 << 0)
#define I2C_I2SR_IIF	(1 << 1)
#define I2C_I2SR_IBB	(1 << 5)

struct imxiic_softc {
	struct device		sc_dev;
	bus_space_tag_t		sc_iot;
	bus_space_handle_t	sc_ioh;
	bus_size_t		sc_ios;
	void			*sc_ih;
	int			sc_node;

	struct rwlock		sc_buslock;
	struct i2c_controller	i2c_tag;

	uint16_t		frequency;
	uint16_t		intr_status;
	uint16_t		stopped;
};

int imxiic_match(struct device *, void *, void *);
void imxiic_attach(struct device *, struct device *, void *);
int imxiic_detach(struct device *, int);
void imxiic_setspeed(struct imxiic_softc *, u_int);
int imxiic_intr(void *);
int imxiic_wait_intr(struct imxiic_softc *, int, int);
int imxiic_wait_state(struct imxiic_softc *, uint32_t, uint32_t);
int imxiic_read(struct imxiic_softc *, int, void *, int);
int imxiic_write(struct imxiic_softc *, int, const void *, int,
    const void *, int);

int imxiic_i2c_acquire_bus(void *, int);
void imxiic_i2c_release_bus(void *, int);
int imxiic_i2c_exec(void *, i2c_op_t, i2c_addr_t, const void *, size_t,
    void *, size_t, int);

#define HREAD2(sc, reg)							\
	(bus_space_read_2((sc)->sc_iot, (sc)->sc_ioh, (reg)))
#define HWRITE2(sc, reg, val)						\
	bus_space_write_2((sc)->sc_iot, (sc)->sc_ioh, (reg), (val))
#define HSET2(sc, reg, bits)						\
	HWRITE2((sc), (reg), HREAD2((sc), (reg)) | (bits))
#define HCLR2(sc, reg, bits)						\
	HWRITE2((sc), (reg), HREAD2((sc), (reg)) & ~(bits))

void imxiic_scan(struct device *, struct i2cbus_attach_args *, void *);

struct cfattach imxiic_ca = {
	sizeof(struct imxiic_softc), imxiic_match, imxiic_attach,
	imxiic_detach
};

struct cfdriver imxiic_cd = {
	NULL, "imxiic", DV_DULL
};

int
imxiic_match(struct device *parent, void *match, void *aux)
{
	struct fdt_attach_args *faa = aux;

	return OF_is_compatible(faa->fa_node, "fsl,imx21-i2c");
}

void
imxiic_attach(struct device *parent, struct device *self, void *aux)
{
	struct imxiic_softc *sc = (struct imxiic_softc *)self;
	struct fdt_attach_args *faa = aux;

	if (faa->fa_nreg < 1)
		return;

	sc->sc_iot = faa->fa_iot;
	sc->sc_ios = faa->fa_reg[0].size;
	sc->sc_node = faa->fa_node;
	if (bus_space_map(sc->sc_iot, faa->fa_reg[0].addr,
	    faa->fa_reg[0].size, 0, &sc->sc_ioh))
		panic("imxiic_attach: bus_space_map failed!");

#if 0
	sc->sc_ih = arm_intr_establish_fdt(faa->fa_node, IPL_BIO,
	    imxiic_intr, sc, sc->sc_dev.dv_xname);
#endif

	printf("\n");

	/* set iomux pins */
	pinctrl_byname(faa->fa_node, "default");

	/* set speed to 100kHz */
	imxiic_setspeed(sc, 100);

	/* reset */
	HWRITE2(sc, I2C_I2CR, 0);
	HWRITE2(sc, I2C_I2SR, 0);

	sc->stopped = 1;
	rw_init(&sc->sc_buslock, sc->sc_dev.dv_xname);

	struct i2cbus_attach_args iba;

	sc->i2c_tag.ic_cookie = sc;
	sc->i2c_tag.ic_acquire_bus = imxiic_i2c_acquire_bus;
	sc->i2c_tag.ic_release_bus = imxiic_i2c_release_bus;
	sc->i2c_tag.ic_exec = imxiic_i2c_exec;

	bzero(&iba, sizeof iba);
	iba.iba_name = "iic";
	iba.iba_tag = &sc->i2c_tag;
	iba.iba_bus_scan = imxiic_scan;
	iba.iba_bus_scan_arg = &sc->sc_node;
	config_found(&sc->sc_dev, &iba, iicbus_print);
}

void
imxiic_setspeed(struct imxiic_softc *sc, u_int speed)
{
	if (!sc->frequency) {
		uint32_t i2c_clk_rate;
		uint32_t div;
		int i;

		i2c_clk_rate = clock_get_frequency(sc->sc_node, NULL);
		div = (i2c_clk_rate + speed - 1) / speed;
		if (div < imxiic_clk_div[0][0])
			i = 0;
		else if (div > imxiic_clk_div[49][0])
			i = 49;
		else
			for (i = 0; imxiic_clk_div[i][0] < div; i++);

		sc->frequency = imxiic_clk_div[i][1];
	}

	HWRITE2(sc, I2C_IFDR, sc->frequency);
}

#if 0
int
imxiic_intr(void *arg)
{
	struct imxiic_softc *sc = arg;
	u_int16_t status;

	status = HREAD2(sc, I2C_I2SR);

	if (ISSET(status, I2C_I2SR_IIF)) {
		/* acknowledge the interrupts */
		HWRITE2(sc, I2C_I2SR,
		    HREAD2(sc, I2C_I2SR) & ~I2C_I2SR_IIF);

		sc->intr_status |= status;
		wakeup(&sc->intr_status);
	}

	return (0);
}

int
imxiic_wait_intr(struct imxiic_softc *sc, int mask, int timo)
{
	int status;
	int s;

	s = splbio();

	status = sc->intr_status & mask;
	while (status == 0) {
		if (tsleep(&sc->intr_status, PWAIT, "hcintr", timo)
		    == EWOULDBLOCK) {
			break;
		}
		status = sc->intr_status & mask;
	}
	status = sc->intr_status & mask;
	sc->intr_status &= ~status;

	splx(s);
	return status;
}
#endif

int
imxiic_wait_state(struct imxiic_softc *sc, uint32_t mask, uint32_t value)
{
	uint32_t state;
	int timeout;
	state = HREAD2(sc, I2C_I2SR);
	for (timeout = 1000; timeout > 0; timeout--) {
		if (((state = HREAD2(sc, I2C_I2SR)) & mask) == value)
			return 0;
		delay(10);
	}
	return ETIMEDOUT;
}

int
imxiic_read(struct imxiic_softc *sc, int addr, void *data, int len)
{
	int i;

	HWRITE2(sc, I2C_I2DR, (addr << 1) | 1);

	if (imxiic_wait_state(sc, I2C_I2SR_IIF, I2C_I2SR_IIF))
		return (EIO);
	HCLR2(sc, I2C_I2SR, I2C_I2SR_IIF);
	if (HREAD2(sc, I2C_I2SR) & I2C_I2SR_RXAK)
		return (EIO);

	HCLR2(sc, I2C_I2CR, I2C_I2CR_MTX);
	if (len - 1)
		HCLR2(sc, I2C_I2CR, I2C_I2CR_TXAK);

	/* dummy read */
	HREAD2(sc, I2C_I2DR);

	for (i = 0; i < len; i++) {
		if (imxiic_wait_state(sc, I2C_I2SR_IIF, I2C_I2SR_IIF))
			return (EIO);
		HCLR2(sc, I2C_I2SR, I2C_I2SR_IIF);

		if (i == (len - 1)) {
			HCLR2(sc, I2C_I2CR, I2C_I2CR_MSTA | I2C_I2CR_MTX);
			imxiic_wait_state(sc, I2C_I2SR_IBB, 0);
			sc->stopped = 1;
		} else if (i == (len - 2)) {
			HSET2(sc, I2C_I2CR, I2C_I2CR_TXAK);
		}
		((uint8_t*)data)[i] = HREAD2(sc, I2C_I2DR);
	}

	return 0;
}

int
imxiic_write(struct imxiic_softc *sc, int addr, const void *cmd, int cmdlen,
    const void *data, int len)
{
	int i;

	HWRITE2(sc, I2C_I2DR, addr << 1);

	if (imxiic_wait_state(sc, I2C_I2SR_IIF, I2C_I2SR_IIF))
		return (EIO);
	HCLR2(sc, I2C_I2SR, I2C_I2SR_IIF);
	if (HREAD2(sc, I2C_I2SR) & I2C_I2SR_RXAK)
		return (EIO);

	for (i = 0; i < cmdlen; i++) {
		HWRITE2(sc, I2C_I2DR, ((uint8_t*)cmd)[i]);
		if (imxiic_wait_state(sc, I2C_I2SR_IIF, I2C_I2SR_IIF))
			return (EIO);
		HCLR2(sc, I2C_I2SR, I2C_I2SR_IIF);
		if (HREAD2(sc, I2C_I2SR) & I2C_I2SR_RXAK)
			return (EIO);
	}

	for (i = 0; i < len; i++) {
		HWRITE2(sc, I2C_I2DR, ((uint8_t*)data)[i]);
		if (imxiic_wait_state(sc, I2C_I2SR_IIF, I2C_I2SR_IIF))
			return (EIO);
		HCLR2(sc, I2C_I2SR, I2C_I2SR_IIF);
		if (HREAD2(sc, I2C_I2SR) & I2C_I2SR_RXAK)
			return (EIO);
	}
	return 0;
}

int
imxiic_i2c_acquire_bus(void *cookie, int flags)
{
	struct imxiic_softc *sc = cookie;

	rw_enter(&sc->sc_buslock, RW_WRITE);

	/* clock gating */
	clock_enable(sc->sc_node, NULL);

	/* set speed to 100kHz */
	imxiic_setspeed(sc, 100);

	/* enable the controller */
	HWRITE2(sc, I2C_I2SR, 0);
	HWRITE2(sc, I2C_I2CR, I2C_I2CR_IEN);

	/* wait for it to be stable */
	delay(50);

	return 0;
}

void
imxiic_i2c_release_bus(void *cookie, int flags)
{
	struct imxiic_softc *sc = cookie;

	HWRITE2(sc, I2C_I2CR, 0);

	rw_exit(&sc->sc_buslock);
}

int
imxiic_i2c_exec(void *cookie, i2c_op_t op, i2c_addr_t addr,
    const void *cmdbuf, size_t cmdlen, void *buf, size_t len, int flags)
{
	struct imxiic_softc *sc = cookie;
	int ret = 0;

	if (!I2C_OP_STOP_P(op))
		return EINVAL;
	if (I2C_OP_READ_P(op) && cmdlen > 0)
		return EINVAL;

	/* start transaction */
	HSET2(sc, I2C_I2CR, I2C_I2CR_MSTA);

	if (imxiic_wait_state(sc, I2C_I2SR_IBB, I2C_I2SR_IBB)) {
		ret = EIO;
		goto fail;
	}

	sc->stopped = 0;

	HSET2(sc, I2C_I2CR, I2C_I2CR_IIEN | I2C_I2CR_MTX | I2C_I2CR_TXAK);

	if (I2C_OP_READ_P(op)) {
		ret = imxiic_read(sc, addr, buf, len);
	} else {
		ret = imxiic_write(sc, addr, cmdbuf, cmdlen, buf, len);
	}

fail:
	if (!sc->stopped) {
		HCLR2(sc, I2C_I2CR, I2C_I2CR_MSTA | I2C_I2CR_MTX);
		imxiic_wait_state(sc, I2C_I2SR_IBB, 0);
		sc->stopped = 1;
	}

	return ret;
}

int
imxiic_detach(struct device *self, int flags)
{
	struct imxiic_softc *sc = (struct imxiic_softc *)self;

	HWRITE2(sc, I2C_IADR, 0);
	HWRITE2(sc, I2C_IFDR, 0);
	HWRITE2(sc, I2C_I2CR, 0);
	HWRITE2(sc, I2C_I2SR, 0);

	bus_space_unmap(sc->sc_iot, sc->sc_ioh, sc->sc_ios);
	return 0;
}

void
imxiic_scan(struct device *self, struct i2cbus_attach_args *iba, void *aux)
{
	int iba_node = *(int *)aux;
	extern int iic_print(void *, const char *);
	struct i2c_attach_args ia;
	char name[32];
	uint32_t reg[1];
	int node;

	for (node = OF_child(iba_node); node; node = OF_peer(node)) {
		memset(name, 0, sizeof(name));
		memset(reg, 0, sizeof(reg));

		if (OF_getprop(node, "compatible", name, sizeof(name)) == -1)
			continue;
		if (name[0] == '\0')
			continue;

		if (OF_getprop(node, "reg", &reg, sizeof(reg)) != sizeof(reg))
			continue;

		memset(&ia, 0, sizeof(ia));
		ia.ia_tag = iba->iba_tag;
		ia.ia_addr = bemtoh32(&reg[0]);
		ia.ia_name = name;
		ia.ia_cookie = &node;
	
		config_found(self, &ia, iic_print);
	}
}
@


1.12
log
@Use the generic clock framework.

ok jsg@@, patrick@@
@
text
@d1 1
a1 1
/* $OpenBSD: imxiic.c,v 1.11 2016/08/06 17:18:38 kettenis Exp $ */
a56 1
	int			unit;
a121 1
	sc->unit = (faa->fa_reg[0].addr & 0xc000) >> 14;
@


1.11
log
@Switch imx over to the generic pinctrl API.

ok patrick@@
@
text
@d1 1
a1 1
/* $OpenBSD: imxiic.c,v 1.10 2016/08/04 15:52:52 kettenis Exp $ */
a20 2
#include <sys/kthread.h>
#include <sys/malloc.h>
d22 1
a25 2
#include <armv7/armv7/armv7var.h>
#include <armv7/imx/imxccmvar.h>
d29 1
d171 1
a171 1
		i2c_clk_rate = imxccm_get_ipg_perclk();
d325 1
a325 1
	imxccm_enable_i2c(sc->unit);
@


1.10
log
@Dynamically attach ampintc(4) and make it register itself as an interrupt
controller.  Switch all i.MX6 devices over to the new FDT-aware interrupt
establish API and enable imxgpc(4).

This may break other platforms that use ampintc(4) as their interrupt
controller.  We will fix this as soon as possible by switching them over
to the new interrupt establish API as well.

This also removes the hack in fec(4) to avoid the gpio-based interrupt
workaround.  This commit is an essential step on the road to fix that
issue properly.

ok patrick@@, jsg@@
@
text
@d1 1
a1 1
/* $OpenBSD: imxiic.c,v 1.9 2016/07/27 11:45:02 patrick Exp $ */
a27 1
#include <armv7/imx/imxiomuxcvar.h>
d32 1
d138 1
a138 1
	imxiomuxc_pinctrlbyname(faa->fa_node, "default");
@


1.9
log
@Instead of passing the raw reg property to simplebus nodes,
pass a pre-processed array of fdt_reg structs.  This means
that the drivers don't have to understand the cell properties
themselves but can rely on the 64-bit addr/size pairs.

ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: imxiic.c,v 1.8 2016/07/10 11:46:28 kettenis Exp $ */
d131 1
a131 1
	sc->sc_ih = arm_intr_establish(aa->aa_dev->irq[0], IPL_BIO,
@


1.8
log
@Add support for handling pinctrl device tree bindings to imxiomuxc(4).
These are used to do board-specific setup of mux settings and pad
configuration.

ok jsg@@, patrick@@
@
text
@d1 1
a1 1
/* $OpenBSD: imxiic.c,v 1.7 2016/06/09 12:35:46 kettenis Exp $ */
d33 1
d119 1
a119 1
	if (faa->fa_nreg < 2)
d123 1
a123 1
	sc->sc_ios = faa->fa_reg[1];
d125 3
a127 3
	sc->unit = (faa->fa_reg[0] & 0xc000) >> 14;
	if (bus_space_map(sc->sc_iot, faa->fa_reg[0],
	    faa->fa_reg[1], 0, &sc->sc_ioh))
@


1.7
log
@Make use of the information about the node passed down to us by simplebus(4).

ok jsg@@
@
text
@d1 1
a1 1
/* $OpenBSD: imxiic.c,v 1.6 2016/05/21 12:37:28 kettenis Exp $ */
d137 1
a137 1
	imxiomuxc_enable_i2c(sc->unit);
@


1.6
log
@Dynamically attach imxiic(4) and use the FDT to enumerate devices on i2c
busses.  Users of the CuBox-i and Hummingboard now need to boot with an FDT
to see the RTC.

ok jsg@@, patrick@@
@
text
@d1 1
a1 1
/* $OpenBSD: imxiic.c,v 1.5 2016/05/20 20:33:54 kettenis Exp $ */
a116 1
	uint32_t reg[2];
d118 1
a118 1
	if (OF_getprop(faa->fa_node, "reg", &reg, sizeof(reg)) != sizeof(reg))
d122 1
a122 1
	sc->sc_ios = bemtoh32(&reg[1]);
d124 3
a126 3
	sc->unit = (bemtoh32(&reg[0]) & 0xc000) >> 14;
	if (bus_space_map(sc->sc_iot, bemtoh32(&reg[0]),
	    bemtoh32(&reg[1]), 0, &sc->sc_ioh))
@


1.5
log
@Change the identification string to "nxp,pcf8523" as this is what is stored
in the FDT.
@
text
@d1 1
a1 1
/* $OpenBSD: imxiic.c,v 1.4 2016/05/17 00:04:35 kettenis Exp $ */
d25 1
d32 2
d57 1
d68 1
d96 2
a97 1
	sizeof(struct imxiic_softc), NULL, imxiic_attach, imxiic_detach
d104 8
d113 1
a113 1
imxiic_attach(struct device *parent, struct device *self, void *args)
d116 5
a120 1
	struct armv7_attach_args *aa = args;
d122 6
a127 5
	sc->sc_iot = aa->aa_iot;
	sc->sc_ios = aa->aa_dev->mem[0].size;
	sc->unit = aa->aa_dev->unit;
	if (bus_space_map(sc->sc_iot, aa->aa_dev->mem[0].addr,
	    aa->aa_dev->mem[0].size, 0, &sc->sc_ioh))
d161 1
d409 1
d412 21
a432 5

	memset(&ia, 0, sizeof(ia));
	ia.ia_tag = iba->iba_tag;
	ia.ia_addr = 0x68;
	ia.ia_name = "npx,pcf8523";
d434 2
a435 1
	config_found(self, &ia, iic_print);
@


1.4
log
@Enable the pcf8523 RTC on Hummingboard and CuBox-i.

ok patrick@@
@
text
@d1 1
a1 1
/* $OpenBSD: imxiic.c,v 1.3 2016/05/16 21:38:35 kettenis Exp $ */
d395 1
a395 1
	ia.ia_name = "pcf8523";
@


1.3
log
@Make this actually work.  This makes the following changes:

- Move most of the bus setup stuff to imxiic_i2c_acquire_bus()
- Move the teardown to imxiic_i2c_release_bus()
- Always clear the IIF flag
- Allow cmd and data for write operations.

Some i2c operations are still rejected, but this works well enough to use
pcfrtc(4).

ok patrick@@
@
text
@d1 1
a1 1
/* $OpenBSD: imxiic.c,v 1.2 2013/11/06 19:03:07 syl Exp $ */
d88 1
d141 2
a142 1
	config_found(&sc->sc_dev, &iba, NULL);
d384 14
@


1.2
log
@After factorizing armv7_machdep code here is an effort to factorize all
the code present in omap/omap.c imx/imx.c and sunxi/sunxi.c

All this code looks quite the same, so we move it in a generic armv7/armv7.c

This is a step closer to only one kernel for all armv7 boards.

ok patrick@@, rapha@@
@
text
@d1 1
a1 1
/* $OpenBSD: imxiic.c,v 1.1 2013/09/06 20:45:53 patrick Exp $ */
d70 3
a72 3
int imxiic_start(struct imxiic_softc *, int, int, void *, int);
int imxiic_read(struct imxiic_softc *, int, int, void *, int);
int imxiic_write(struct imxiic_softc *, int, int, const void *, int);
d226 1
a226 1
imxiic_read(struct imxiic_softc *sc, int addr, int subaddr, void *data, int len)
d230 1
a230 1
	HWRITE2(sc, I2C_I2DR, addr | 1);
d234 1
a234 1
	while(!(HREAD2(sc, I2C_I2SR) & I2C_I2SR_IIF));
d239 1
a239 1
	if (len)
d248 2
d264 2
a265 1
imxiic_write(struct imxiic_softc *sc, int addr, int subaddr, const void *data, int len)
d269 1
a269 1
	HWRITE2(sc, I2C_I2DR, addr);
d273 1
d277 9
d290 1
d302 16
a317 1
	return (rw_enter(&sc->sc_buslock, RW_WRITE));
d325 3
a327 1
	(void) rw_exit(&sc->sc_buslock);
d335 1
a335 20
	uint32_t ret = 0;
	u_int8_t cmd = 0;

	if (!I2C_OP_STOP_P(op) || cmdlen > 1)
		return (EINVAL);

	if (cmdlen > 0)
		cmd = *(u_int8_t *)cmdbuf;

	addr &= 0x7f;

	/* clock gating */
	imxccm_enable_i2c(sc->unit);

	/* set speed to 100kHz */
	imxiic_setspeed(sc, 100);

	/* enable the controller */
	HWRITE2(sc, I2C_I2SR, 0);
	HWRITE2(sc, I2C_I2CR, I2C_I2CR_IEN);
d337 4
a340 2
	/* wait for it to be stable */
	delay(50);
d346 1
a346 1
		ret = (EIO);
d355 1
a355 2
		if (imxiic_read(sc, (addr << 1), cmd, buf, len) != 0)
			ret = (EIO);
d357 1
a357 2
		if (imxiic_write(sc, (addr << 1), cmd, buf, len) != 0)
			ret = (EIO);
a365 2

	HWRITE2(sc, I2C_I2CR, 0);
@


1.1
log
@Support for FreeScale's i.MX6 SoC.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d26 1
a26 1
#include <armv7/imx/imxvar.h>
d101 1
a101 1
	struct imx_attach_args *ia = args;
d103 5
a107 5
	sc->sc_iot = ia->ia_iot;
	sc->sc_ios = ia->ia_dev->mem[0].size;
	sc->unit = ia->ia_dev->unit;
	if (bus_space_map(sc->sc_iot, ia->ia_dev->mem[0].addr,
	    ia->ia_dev->mem[0].size, 0, &sc->sc_ioh))
d111 1
a111 1
	sc->sc_ih = arm_intr_establish(ia->ia_dev->irq[0], IPL_BIO,
@

