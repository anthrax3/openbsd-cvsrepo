head	1.7;
access;
symbols
	OPENBSD_6_1:1.7.0.2
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.5.0.2
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.3.0.6
	OPENBSD_5_9_BASE:1.3
	OPENBSD_5_8:1.3.0.8
	OPENBSD_5_8_BASE:1.3
	OPENBSD_5_7:1.3.0.2
	OPENBSD_5_7_BASE:1.3
	OPENBSD_5_6:1.3.0.4
	OPENBSD_5_6_BASE:1.3
	OPENBSD_5_5:1.2.0.4
	OPENBSD_5_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.7
date	2016.08.04.15.52.52;	author kettenis;	state Exp;
branches;
next	1.6;
commitid	WNhzA3xU3jFFVhST;

1.6
date	2016.07.27.11.45.02;	author patrick;	state Exp;
branches;
next	1.5;
commitid	yc14meyJgxIAcvAg;

1.5
date	2016.07.12.19.17.49;	author kettenis;	state Exp;
branches;
next	1.4;
commitid	j8BR8WPk8oGLOlFW;

1.4
date	2016.06.09.12.39.17;	author kettenis;	state Exp;
branches;
next	1.3;
commitid	5vNPvRRkE4tnKZEK;

1.3
date	2014.04.14.04.42.22;	author dlg;	state Exp;
branches;
next	1.2;

1.2
date	2013.11.06.19.03.07;	author syl;	state Exp;
branches;
next	1.1;

1.1
date	2013.09.06.20.45.53;	author patrick;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Dynamically attach ampintc(4) and make it register itself as an interrupt
controller.  Switch all i.MX6 devices over to the new FDT-aware interrupt
establish API and enable imxgpc(4).

This may break other platforms that use ampintc(4) as their interrupt
controller.  We will fix this as soon as possible by switching them over
to the new interrupt establish API as well.

This also removes the hack in fec(4) to avoid the gpio-based interrupt
workaround.  This commit is an essential step on the road to fix that
issue properly.

ok patrick@@, jsg@@
@
text
@/* $OpenBSD: imxahci.c,v 1.6 2016/07/27 11:45:02 patrick Exp $ */
/*
 * Copyright (c) 2013 Patrick Wildt <patrick@@blueri.se>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/device.h>
#include <sys/queue.h>

#include <machine/bus.h>
#include <machine/fdt.h>

#include <dev/ic/ahcireg.h>
#include <dev/ic/ahcivar.h>

#include <armv7/armv7/armv7var.h>
#include <armv7/imx/imxccmvar.h>
#include <armv7/imx/imxiomuxcvar.h>

#include <dev/ofw/openfirm.h>
#include <dev/ofw/fdt.h>

/* registers */
#define SATA_CAP		0x000
#define SATA_GHC		0x004
#define SATA_IS			0x008
#define SATA_PI			0x00C
#define SATA_VS			0x010
#define SATA_CCC_CTL		0x014
#define SATA_CCC_PORTS		0x018
#define SATA_CAP2		0x024
#define SATA_BISTAFR		0x0A0
#define SATA_BISTCR		0x0A4
#define SATA_BISTFCTR		0x0A8
#define SATA_BSTSR		0x0AC
#define SATA_OOBR		0x0BC
#define SATA_GPCR		0x0D0
#define SATA_GPSR		0x0D4
#define SATA_TIMER1MS		0x0E0
#define SATA_TESTR		0x0F4
#define SATA_VERSIONR		0x0F8
#define SATA_P0CLB		0x100
#define SATA_P0FB		0x108
#define SATA_P0IS		0x110
#define SATA_P0IE		0x114
#define SATA_P0CMD		0x118
#define SATA_P0TFD		0x120
#define SATA_P0SIG		0x124
#define SATA_P0SSTS		0x128
#define SATA_P0SCTL		0x12C
#define SATA_P0SERR		0x130
#define SATA_P0SACT		0x134
#define SATA_P0CI		0x138
#define SATA_P0SNTF		0x13C
#define SATA_P0DMACR		0x170
#define SATA_P0PHYCR		0x178
#define SATA_P0PHYSR		0x17C

#define SATA_CAP_SSS		(1 << 27)
#define SATA_GHC_HR		(1 << 0)
#define SATA_P0PHYCR_TEST_PDDQ	(1 << 20)

int	imxahci_match(struct device *, void *, void *);
void	imxahci_attach(struct device *, struct device *, void *);
int	imxahci_detach(struct device *, int);
int	imxahci_activate(struct device *, int);

extern int ahci_intr(void *);

struct imxahci_softc {
	struct ahci_softc	sc;
};

struct cfattach imxahci_ca = {
	sizeof(struct imxahci_softc),
	imxahci_match,
	imxahci_attach,
	imxahci_detach,
	imxahci_activate
};

struct cfdriver imxahci_cd = {
	NULL, "imxahci", DV_DULL
};

int
imxahci_match(struct device *parent, void *match, void *aux)
{
	struct fdt_attach_args *faa = aux;

	return OF_is_compatible(faa->fa_node, "fsl,imx6q-ahci");
}

void
imxahci_attach(struct device *parent, struct device *self, void *aux)
{
	struct imxahci_softc *imxsc = (struct imxahci_softc *) self;
	struct ahci_softc *sc = &imxsc->sc;
	struct fdt_attach_args *faa = aux;
	uint32_t timeout = 0x100000;

	if (faa->fa_nreg < 1)
		return;

	sc->sc_iot = faa->fa_iot;
	sc->sc_ios = faa->fa_reg[0].size;
	sc->sc_dmat = faa->fa_dmat;

	if (bus_space_map(sc->sc_iot, faa->fa_reg[0].addr,
	    faa->fa_reg[0].size, 0, &sc->sc_ioh))
		panic("imxahci_attach: bus_space_map failed!");

	sc->sc_ih = arm_intr_establish_fdt(faa->fa_node, IPL_BIO,
	    ahci_intr, sc, sc->sc_dev.dv_xname);
	if (sc->sc_ih == NULL) {
		printf(": unable to establish interrupt\n");
		goto unmap;
	}

	/* power it up */
	imxccm_enable_sata();
	delay(100);

	/* power phy up */
	imxiomuxc_enable_sata();

	/* setup */
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, SATA_P0PHYCR,
	    bus_space_read_4(sc->sc_iot, sc->sc_ioh, SATA_P0PHYCR) & ~SATA_P0PHYCR_TEST_PDDQ);

	bus_space_write_4(sc->sc_iot, sc->sc_ioh, SATA_GHC, SATA_GHC_HR);

	while (!bus_space_read_4(sc->sc_iot, sc->sc_ioh, SATA_VERSIONR));

	bus_space_write_4(sc->sc_iot, sc->sc_ioh, SATA_CAP,
	    bus_space_read_4(sc->sc_iot, sc->sc_ioh, SATA_CAP) | SATA_CAP_SSS);

	bus_space_write_4(sc->sc_iot, sc->sc_ioh, SATA_PI, 1);

	bus_space_write_4(sc->sc_iot, sc->sc_ioh, SATA_TIMER1MS, imxccm_get_ahbclk());

	while (!(bus_space_read_4(sc->sc_iot, sc->sc_ioh, SATA_P0SSTS) & 0xF) && timeout--);

	printf(":");

	if (ahci_attach(sc) != 0) {
		/* error printed by ahci_attach */
		goto irq;
	}

	return;
irq:
	arm_intr_disestablish(sc->sc_ih);
unmap:
	bus_space_unmap(sc->sc_iot, sc->sc_ioh, sc->sc_ios);
}

int
imxahci_detach(struct device *self, int flags)
{
	struct imxahci_softc *imxsc = (struct imxahci_softc *) self;
	struct ahci_softc *sc = &imxsc->sc;

	ahci_detach(sc, flags);
	bus_space_unmap(sc->sc_iot, sc->sc_ioh, sc->sc_ios);
	return 0;
}

int
imxahci_activate(struct device *self, int act)
{
	struct imxahci_softc *imxsc = (struct imxahci_softc *) self;
	struct ahci_softc *sc = &imxsc->sc;

	return ahci_activate((struct device *)sc, act);
}
@


1.6
log
@Instead of passing the raw reg property to simplebus nodes,
pass a pre-processed array of fdt_reg structs.  This means
that the drivers don't have to understand the cell properties
themselves but can rely on the 64-bit addr/size pairs.

ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: imxahci.c,v 1.5 2016/07/12 19:17:49 kettenis Exp $ */
d118 1
a118 1
	if (faa->fa_nreg < 1 || faa->fa_nintr < 3)
d129 1
a129 1
	sc->sc_ih = arm_intr_establish(faa->fa_intr[1], IPL_BIO,
@


1.5
log
@Turn ahci(4) glue code for the i.MX6 platform into its own imxahci(4) driver
such that we can don't end up with conflicting attachments of other
SoC-specific glue code.
@
text
@d1 1
a1 1
/* $OpenBSD: imxahci.c,v 1.4 2016/06/09 12:39:17 kettenis Exp $ */
d37 1
d118 1
a118 1
	if (faa->fa_nreg < 2 || faa->fa_nintr < 3)
d122 1
a122 1
	sc->sc_ios = faa->fa_reg[1];
d125 2
a126 2
	if (bus_space_map(sc->sc_iot, faa->fa_reg[0],
	    faa->fa_reg[1], 0, &sc->sc_ioh))
@


1.4
log
@Dynamically attach i.MX6 ahci(4) using the FDT.

ok jsg@@
@
text
@d1 1
a1 1
/* $OpenBSD: imxahci.c,v 1.3 2014/04/14 04:42:22 dlg Exp $ */
d98 1
a98 1
	NULL, "ahci", DV_DULL
@


1.3
log
@move the hardware structures into ahcireg.h.
@
text
@d1 1
a1 1
/* $OpenBSD: imxahci.c,v 1.2 2013/11/06 19:03:07 syl Exp $ */
d27 1
d36 2
d78 1
d91 1
a91 1
	NULL,
d101 8
d110 1
a110 1
imxahci_attach(struct device *parent, struct device *self, void *args)
a111 1
	struct armv7_attach_args *aa = args;
d114 1
d117 6
a122 3
	sc->sc_iot = aa->aa_iot;
	sc->sc_ios = aa->aa_dev->mem[0].size;
	sc->sc_dmat = aa->aa_dmat;
d124 2
a125 2
	if (bus_space_map(sc->sc_iot, aa->aa_dev->mem[0].addr,
	    aa->aa_dev->mem[0].size, 0, &sc->sc_ioh))
d128 1
a128 1
	sc->sc_ih = arm_intr_establish(aa->aa_dev->irq[0], IPL_BIO,
d158 2
@


1.2
log
@After factorizing armv7_machdep code here is an effort to factorize all
the code present in omap/omap.c imx/imx.c and sunxi/sunxi.c

All this code looks quite the same, so we move it in a generic armv7/armv7.c

This is a step closer to only one kernel for all armv7 boards.

ok patrick@@, rapha@@
@
text
@d1 1
a1 1
/* $OpenBSD: imxahci.c,v 1.1 2013/09/06 20:45:53 patrick Exp $ */
d28 1
@


1.1
log
@Support for FreeScale's i.MX6 SoC.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d30 1
a30 1
#include <armv7/imx/imxvar.h>
d99 1
a99 1
	struct imx_attach_args *ia = args;
d104 3
a106 3
	sc->sc_iot = ia->ia_iot;
	sc->sc_ios = ia->ia_dev->mem[0].size;
	sc->sc_dmat = ia->ia_dmat;
d108 2
a109 2
	if (bus_space_map(sc->sc_iot, ia->ia_dev->mem[0].addr,
	    ia->ia_dev->mem[0].size, 0, &sc->sc_ioh))
d112 1
a112 1
	sc->sc_ih = arm_intr_establish(ia->ia_dev->irq[0], IPL_BIO,
@

