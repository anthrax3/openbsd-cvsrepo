head	1.43;
access;
symbols
	OPENBSD_6_2:1.43.0.2
	OPENBSD_6_2_BASE:1.43
	OPENBSD_6_1:1.42.0.4
	OPENBSD_6_1_BASE:1.42
	OPENBSD_6_0:1.37.0.2
	OPENBSD_6_0_BASE:1.37
	OPENBSD_5_9:1.32.0.2
	OPENBSD_5_9_BASE:1.32
	OPENBSD_5_8:1.26.0.4
	OPENBSD_5_8_BASE:1.26
	OPENBSD_5_7:1.24.0.2
	OPENBSD_5_7_BASE:1.24
	OPENBSD_5_6:1.22.0.4
	OPENBSD_5_6_BASE:1.22
	OPENBSD_5_5:1.21.0.4
	OPENBSD_5_5_BASE:1.21;
locks; strict;
comment	@ * @;


1.43
date	2017.04.30.16.45.45;	author mpi;	state Exp;
branches;
next	1.42;
commitid	2Gtqjzrin9LL2yHk;

1.42
date	2017.01.22.10.17.37;	author dlg;	state Exp;
branches;
next	1.41;
commitid	VyLWTsbepAOk7VQM;

1.41
date	2016.10.02.23.38.32;	author jsg;	state Exp;
branches;
next	1.40;
commitid	C4BAOQmrwpL8jOkx;

1.40
date	2016.08.12.03.22.41;	author jsg;	state Exp;
branches;
next	1.39;
commitid	HjeMmhWIXnaMRjR3;

1.39
date	2016.08.06.10.07.45;	author jsg;	state Exp;
branches;
next	1.38;
commitid	tIvsLgDtJFao46i9;

1.38
date	2016.07.27.11.45.02;	author patrick;	state Exp;
branches;
next	1.37;
commitid	yc14meyJgxIAcvAg;

1.37
date	2016.07.17.02.45.05;	author jsg;	state Exp;
branches;
next	1.36;
commitid	j81PfDWuSi4hn2JG;

1.36
date	2016.07.09.04.25.44;	author jsg;	state Exp;
branches;
next	1.35;
commitid	S739HXPPDRR7IU4q;

1.35
date	2016.06.26.09.06.35;	author jsg;	state Exp;
branches;
next	1.34;
commitid	CMQxDZf1xqtqsVBC;

1.34
date	2016.04.13.11.33.59;	author mpi;	state Exp;
branches;
next	1.33;
commitid	RI1iBTF6Zaycxppg;

1.33
date	2016.03.02.01.31.41;	author canacar;	state Exp;
branches;
next	1.32;
commitid	w2ru4puSJYkJp19d;

1.32
date	2016.01.07.04.41.17;	author canacar;	state Exp;
branches;
next	1.31;
commitid	886kAeE2U5zb4KWI;

1.31
date	2015.11.25.11.12.53;	author mpi;	state Exp;
branches;
next	1.30;
commitid	rr3Wi6PELxUfYlN5;

1.30
date	2015.11.25.03.09.57;	author dlg;	state Exp;
branches;
next	1.29;
commitid	B0kwmVGiD5DVx4kv;

1.29
date	2015.11.12.10.23.08;	author dlg;	state Exp;
branches;
next	1.28;
commitid	rxdbSCsRnCasiIOD;

1.28
date	2015.10.27.15.07.56;	author mpi;	state Exp;
branches;
next	1.27;
commitid	ZjlKfjAUbdx7mqMd;

1.27
date	2015.08.25.13.13.12;	author bmercer;	state Exp;
branches;
next	1.26;
commitid	spUm0eBetyuFvF40;

1.26
date	2015.06.24.09.40.53;	author mpi;	state Exp;
branches;
next	1.25;
commitid	MVWrtktB46JRxFWT;

1.25
date	2015.03.16.16.21.21;	author mpi;	state Exp;
branches;
next	1.24;
commitid	MA43YhheWiorqCKc;

1.24
date	2014.12.22.02.26.53;	author tedu;	state Exp;
branches;
next	1.23;
commitid	2Ez9mHW0jDzojG4V;

1.23
date	2014.08.18.17.56.45;	author miod;	state Exp;
branches;
next	1.22;
commitid	fXTg0ZycJiavkN0e;

1.22
date	2014.05.06.14.44.08;	author jasper;	state Exp;
branches;
next	1.21;

1.21
date	2013.11.26.20.33.11;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2013.11.15.14.31.52;	author fgsch;	state Exp;
branches;
next	1.19;

1.19
date	2013.11.06.19.03.07;	author syl;	state Exp;
branches;
next	1.18;

1.18
date	2013.09.12.10.28.03;	author dlg;	state Exp;
branches;
next	1.17;

1.17
date	2013.09.12.04.42.03;	author dlg;	state Exp;
branches;
next	1.16;

1.16
date	2013.09.12.04.23.28;	author dlg;	state Exp;
branches;
next	1.15;

1.15
date	2013.09.12.03.09.34;	author dlg;	state Exp;
branches;
next	1.14;

1.14
date	2013.09.12.02.55.03;	author dlg;	state Exp;
branches;
next	1.13;

1.13
date	2013.09.12.02.20.17;	author dlg;	state Exp;
branches;
next	1.12;

1.12
date	2013.09.12.01.44.14;	author dlg;	state Exp;
branches;
next	1.11;

1.11
date	2013.09.12.01.13.10;	author dlg;	state Exp;
branches;
next	1.10;

1.10
date	2013.09.12.01.11.15;	author dlg;	state Exp;
branches;
next	1.9;

1.9
date	2013.09.12.01.02.21;	author dlg;	state Exp;
branches;
next	1.8;

1.8
date	2013.09.12.00.19.11;	author dlg;	state Exp;
branches;
next	1.7;

1.7
date	2013.09.12.00.14.57;	author dlg;	state Exp;
branches;
next	1.6;

1.6
date	2013.09.12.00.06.05;	author dlg;	state Exp;
branches;
next	1.5;

1.5
date	2013.09.11.23.43.20;	author dlg;	state Exp;
branches;
next	1.4;

1.4
date	2013.09.11.23.40.15;	author dlg;	state Exp;
branches;
next	1.3;

1.3
date	2013.09.11.23.34.50;	author dlg;	state Exp;
branches;
next	1.2;

1.2
date	2013.09.11.23.20.03;	author dlg;	state Exp;
branches;
next	1.1;

1.1
date	2013.09.04.14.38.30;	author patrick;	state Exp;
branches;
next	;


desc
@@


1.43
log
@Rename Debugger() into db_enter().

Using a name with the 'db_' prefix makes it invisible from the dynamic
profiler.

ok deraadt@@, kettenis@@, visa@@
@
text
@/* $OpenBSD: if_cpsw.c,v 1.42 2017/01/22 10:17:37 dlg Exp $ */
/*	$NetBSD: if_cpsw.c,v 1.3 2013/04/17 14:36:34 bouyer Exp $	*/

/*
 * Copyright (c) 2013 Jonathan A. Kollasch
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*-
 * Copyright (c) 2012 Damjan Marion <dmarion@@Freebsd.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/sockio.h>
#include <sys/mbuf.h>
#include <sys/pool.h>
#include <sys/queue.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/timeout.h>
#include <sys/socket.h>

#include <machine/bus.h>
#include <machine/fdt.h>

#include <net/if.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <dev/mii/mii.h>
#include <dev/mii/miivar.h>

#include <arch/armv7/armv7/armv7var.h>
#include <arch/armv7/omap/if_cpswreg.h>

#include <dev/ofw/openfirm.h>
#include <dev/ofw/ofw_pinctrl.h>
#include <dev/ofw/fdt.h>

#define CPSW_TXFRAGS	16

#define OMAP2SCM_MAC_ID0_LO	0x630
#define OMAP2SCM_MAC_ID0_HI	0x634

#define CPSW_CPPI_RAM_SIZE (0x2000)
#define CPSW_CPPI_RAM_TXDESCS_SIZE (CPSW_CPPI_RAM_SIZE/2)
#define CPSW_CPPI_RAM_RXDESCS_SIZE \
    (CPSW_CPPI_RAM_SIZE - CPSW_CPPI_RAM_TXDESCS_SIZE)
#define CPSW_CPPI_RAM_TXDESCS_BASE (CPSW_CPPI_RAM_OFFSET + 0x0000)
#define CPSW_CPPI_RAM_RXDESCS_BASE \
    (CPSW_CPPI_RAM_OFFSET + CPSW_CPPI_RAM_TXDESCS_SIZE)

#define CPSW_NTXDESCS (CPSW_CPPI_RAM_TXDESCS_SIZE/sizeof(struct cpsw_cpdma_bd))
#define CPSW_NRXDESCS (CPSW_CPPI_RAM_RXDESCS_SIZE/sizeof(struct cpsw_cpdma_bd))

#define CPSW_PAD_LEN (ETHER_MIN_LEN - ETHER_CRC_LEN)

#define TXDESC_NEXT(x) cpsw_txdesc_adjust((x), 1)
#define TXDESC_PREV(x) cpsw_txdesc_adjust((x), -1)

#define RXDESC_NEXT(x) cpsw_rxdesc_adjust((x), 1)
#define RXDESC_PREV(x) cpsw_rxdesc_adjust((x), -1)

struct cpsw_ring_data {
	bus_dmamap_t		 tx_dm[CPSW_NTXDESCS];
	struct mbuf		*tx_mb[CPSW_NTXDESCS];
	bus_dmamap_t		 rx_dm[CPSW_NRXDESCS];
	struct mbuf		*rx_mb[CPSW_NRXDESCS];
};

struct cpsw_port_config {
	uint8_t			 enaddr[ETHER_ADDR_LEN];
	int			 phy_id;
	int			 rgmii;
	int			 vlan;
};

struct cpsw_softc {
	struct device		 sc_dev;
	bus_space_tag_t		 sc_bst;
	bus_space_handle_t	 sc_bsh;
	bus_dma_tag_t		 sc_bdt;
	bus_space_handle_t	 sc_bsh_txdescs;
	bus_space_handle_t	 sc_bsh_rxdescs;
	bus_addr_t		 sc_txdescs_pa;
	bus_addr_t		 sc_rxdescs_pa;

	struct arpcom		 sc_ac;
	struct mii_data		 sc_mii;

	struct cpsw_ring_data	*sc_rdp;
	volatile u_int		 sc_txnext;
	volatile u_int		 sc_txhead;
	volatile u_int		 sc_rxhead;

	void			*sc_rxthih;
	void			*sc_rxih;
	void			*sc_txih;
	void			*sc_miscih;

	void			*sc_txpad;
	bus_dmamap_t		 sc_txpad_dm;
#define sc_txpad_pa sc_txpad_dm->dm_segs[0].ds_addr

	volatile bool		 sc_txrun;
	volatile bool		 sc_rxrun;
	volatile bool		 sc_txeoq;
	volatile bool		 sc_rxeoq;
	struct timeout		 sc_tick;
	int			 sc_active_port;

	struct cpsw_port_config	 sc_port_config[2];
};

#define DEVNAME(_sc) ((_sc)->sc_dev.dv_xname)

int	cpsw_match(struct device *, void *, void *);
void	cpsw_attach(struct device *, struct device *, void *);

void	cpsw_start(struct ifnet *);
int	cpsw_ioctl(struct ifnet *, u_long, caddr_t);
void	cpsw_watchdog(struct ifnet *);
int	cpsw_init(struct ifnet *);
void	cpsw_stop(struct ifnet *);

int	cpsw_mii_readreg(struct device *, int, int);
void	cpsw_mii_writereg(struct device *, int, int, int);
void	cpsw_mii_statchg(struct device *);

void	cpsw_tick(void *);

int	cpsw_new_rxbuf(struct cpsw_softc * const, const u_int);
int	cpsw_mediachange(struct ifnet *);
void	cpsw_mediastatus(struct ifnet *, struct ifmediareq *);

int	cpsw_rxthintr(void *);
int	cpsw_rxintr(void *);
int	cpsw_txintr(void *);
int	cpsw_miscintr(void *);

void	cpsw_get_port_config(struct cpsw_port_config *, int);

struct cfattach cpsw_ca = {
	sizeof(struct cpsw_softc),
	cpsw_match,
	cpsw_attach
};

struct cfdriver cpsw_cd = {
	NULL,
	"cpsw",
	DV_IFNET
};

static inline u_int
cpsw_txdesc_adjust(u_int x, int y)
{
	return (((x) + y) & (CPSW_NTXDESCS - 1));
}

static inline u_int
cpsw_rxdesc_adjust(u_int x, int y)
{
	return (((x) + y) & (CPSW_NRXDESCS - 1));
}

static inline void
cpsw_set_txdesc_next(struct cpsw_softc * const sc, const u_int i, uint32_t n)
{
	const bus_size_t o = sizeof(struct cpsw_cpdma_bd) * i + 0;
	bus_space_write_4(sc->sc_bst, sc->sc_bsh_txdescs, o, n);
}

static inline void
cpsw_set_rxdesc_next(struct cpsw_softc * const sc, const u_int i, uint32_t n)
{
	const bus_size_t o = sizeof(struct cpsw_cpdma_bd) * i + 0;
	bus_space_write_4(sc->sc_bst, sc->sc_bsh_rxdescs, o, n);
}

static inline void
cpsw_get_txdesc(struct cpsw_softc * const sc, const u_int i,
    struct cpsw_cpdma_bd * const bdp)
{
	const bus_size_t o = sizeof(struct cpsw_cpdma_bd) * i;
	bus_space_read_region_4(sc->sc_bst, sc->sc_bsh_txdescs, o,
	    (uint32_t *)bdp, 4);
}

static inline void
cpsw_set_txdesc(struct cpsw_softc * const sc, const u_int i,
    struct cpsw_cpdma_bd * const bdp)
{
	const bus_size_t o = sizeof(struct cpsw_cpdma_bd) * i;
	bus_space_write_region_4(sc->sc_bst, sc->sc_bsh_txdescs, o,
	    (uint32_t *)bdp, 4);
}

static inline void
cpsw_get_rxdesc(struct cpsw_softc * const sc, const u_int i,
    struct cpsw_cpdma_bd * const bdp)
{
	const bus_size_t o = sizeof(struct cpsw_cpdma_bd) * i;
	bus_space_read_region_4(sc->sc_bst, sc->sc_bsh_rxdescs, o,
	    (uint32_t *)bdp, 4);
}

static inline void
cpsw_set_rxdesc(struct cpsw_softc * const sc, const u_int i,
    struct cpsw_cpdma_bd * const bdp)
{
	const bus_size_t o = sizeof(struct cpsw_cpdma_bd) * i;
	bus_space_write_region_4(sc->sc_bst, sc->sc_bsh_rxdescs, o,
	    (uint32_t *)bdp, 4);
}

static inline bus_addr_t
cpsw_txdesc_paddr(struct cpsw_softc * const sc, u_int x)
{
	KASSERT(x < CPSW_NTXDESCS);
	return sc->sc_txdescs_pa + sizeof(struct cpsw_cpdma_bd) * x;
}

static inline bus_addr_t
cpsw_rxdesc_paddr(struct cpsw_softc * const sc, u_int x)
{
	KASSERT(x < CPSW_NRXDESCS);
	return sc->sc_rxdescs_pa + sizeof(struct cpsw_cpdma_bd) * x;
}

static void
cpsw_mdio_init(struct cpsw_softc *sc)
{
	uint32_t alive, link;
	u_int tries;

	sc->sc_active_port = 0;

	/* Initialze MDIO - ENABLE, PREAMBLE=0, FAULTENB, CLKDIV=0xFF */
	/* TODO Calculate MDCLK=CLK/(CLKDIV+1) */
	bus_space_write_4(sc->sc_bst, sc->sc_bsh, MDIOCONTROL,
	    (1<<30) | (1<<18) | 0xFF);

	for(tries = 0; tries < 1000; tries++) {
		alive = bus_space_read_4(sc->sc_bst, sc->sc_bsh, MDIOALIVE) & 3;
		if (alive)
			break;
		delay(1);
	}

	if (alive == 0) {
		printf("%s: no PHY is alive\n", DEVNAME(sc));
		return;
	}

	link = bus_space_read_4(sc->sc_bst, sc->sc_bsh, MDIOLINK) & 3;

	if (alive == 3) {
		/* both ports are alive, prefer one with link */
		if (link == 2)
			sc->sc_active_port = 1;
	} else if (alive == 2)
		sc->sc_active_port = 1;

	/* Select the port to monitor */
	bus_space_write_4(sc->sc_bst, sc->sc_bsh, MDIOUSERPHYSEL0,
	    sc->sc_active_port);
}

int
cpsw_match(struct device *parent, void *match, void *aux)
{
	struct fdt_attach_args *faa = aux;

	return OF_is_compatible(faa->fa_node, "ti,cpsw");
}

void
cpsw_attach(struct device *parent, struct device *self, void *aux)
{
	struct cpsw_softc *sc = (struct cpsw_softc *)self;
	struct fdt_attach_args *faa = aux;
	struct arpcom * const ac = &sc->sc_ac;
	struct ifnet * const ifp = &ac->ac_if;
	u_int32_t idver;
	int error;
	int node;
	u_int i;
	uint32_t memsize;
	char name[32];

	if (faa->fa_nreg < 1)
		return;

	/*
	 * fa_reg[0].size is size of CPSW_SS and CPSW_PORT
	 * fa_reg[1].size is size of CPSW_WR
	 * we map a size that is a superset of both
	 */
	memsize = 0x4000;

	pinctrl_byname(faa->fa_node, "default");

	for (node = OF_child(faa->fa_node); node; node = OF_peer(node)) {
		memset(name, 0, sizeof(name));

		if (OF_getprop(node, "compatible", name, sizeof(name)) == -1)
			continue;

		if (strcmp(name, "ti,davinci_mdio") != 0)
			continue;
		pinctrl_byname(node, "default");
	}

	timeout_set(&sc->sc_tick, cpsw_tick, sc);

	cpsw_get_port_config(sc->sc_port_config, faa->fa_node);
	memcpy(sc->sc_ac.ac_enaddr, sc->sc_port_config[0].enaddr,
	    ETHER_ADDR_LEN);

	sc->sc_rxthih = arm_intr_establish_fdt_idx(faa->fa_node, 0, IPL_NET,
	    cpsw_rxthintr, sc, DEVNAME(sc));
	sc->sc_rxih = arm_intr_establish_fdt_idx(faa->fa_node, 1, IPL_NET,
	    cpsw_rxintr, sc, DEVNAME(sc));
	sc->sc_txih = arm_intr_establish_fdt_idx(faa->fa_node, 2, IPL_NET,
	    cpsw_txintr, sc, DEVNAME(sc));
	sc->sc_miscih = arm_intr_establish_fdt_idx(faa->fa_node, 3, IPL_NET,
	    cpsw_miscintr, sc, DEVNAME(sc));

	sc->sc_bst = faa->fa_iot;
	sc->sc_bdt = faa->fa_dmat;

	error = bus_space_map(sc->sc_bst, faa->fa_reg[0].addr,
	    memsize, 0, &sc->sc_bsh);
	if (error) {
		printf("can't map registers: %d\n", error);
		return;
	}

	sc->sc_txdescs_pa = faa->fa_reg[0].addr +
	    CPSW_CPPI_RAM_TXDESCS_BASE;
	error = bus_space_subregion(sc->sc_bst, sc->sc_bsh,
	    CPSW_CPPI_RAM_TXDESCS_BASE, CPSW_CPPI_RAM_TXDESCS_SIZE,
	    &sc->sc_bsh_txdescs);
	if (error) {
		printf("can't subregion tx ring SRAM: %d\n", error);
		return;
	}

	sc->sc_rxdescs_pa = faa->fa_reg[0].addr +
	    CPSW_CPPI_RAM_RXDESCS_BASE;
	error = bus_space_subregion(sc->sc_bst, sc->sc_bsh,
	    CPSW_CPPI_RAM_RXDESCS_BASE, CPSW_CPPI_RAM_RXDESCS_SIZE,
	    &sc->sc_bsh_rxdescs);
	if (error) {
		printf("can't subregion rx ring SRAM: %d\n", error);
		return;
	}

	sc->sc_rdp = malloc(sizeof(*sc->sc_rdp), M_TEMP, M_WAITOK);
	KASSERT(sc->sc_rdp != NULL);

	for (i = 0; i < CPSW_NTXDESCS; i++) {
		if ((error = bus_dmamap_create(sc->sc_bdt, MCLBYTES,
		    CPSW_TXFRAGS, MCLBYTES, 0, 0,
		    &sc->sc_rdp->tx_dm[i])) != 0) {
			printf("unable to create tx DMA map: %d\n", error);
		}
		sc->sc_rdp->tx_mb[i] = NULL;
	}

	for (i = 0; i < CPSW_NRXDESCS; i++) {
		if ((error = bus_dmamap_create(sc->sc_bdt, MCLBYTES, 1,
		    MCLBYTES, 0, 0, &sc->sc_rdp->rx_dm[i])) != 0) {
			printf("unable to create rx DMA map: %d\n", error);
		}
		sc->sc_rdp->rx_mb[i] = NULL;
	}

	sc->sc_txpad = dma_alloc(ETHER_MIN_LEN, PR_WAITOK | PR_ZERO);
	KASSERT(sc->sc_txpad != NULL);
	bus_dmamap_create(sc->sc_bdt, ETHER_MIN_LEN, 1, ETHER_MIN_LEN, 0,
	    BUS_DMA_WAITOK, &sc->sc_txpad_dm);
	bus_dmamap_load(sc->sc_bdt, sc->sc_txpad_dm, sc->sc_txpad,
	    ETHER_MIN_LEN, NULL, BUS_DMA_WAITOK|BUS_DMA_WRITE);
	bus_dmamap_sync(sc->sc_bdt, sc->sc_txpad_dm, 0, ETHER_MIN_LEN,
	    BUS_DMASYNC_PREWRITE);

	idver = bus_space_read_4(sc->sc_bst, sc->sc_bsh, CPSW_SS_IDVER);
	printf(": version %d.%d (%d), address %s\n",
	    CPSW_SS_IDVER_MAJ(idver), CPSW_SS_IDVER_MIN(idver),
	    CPSW_SS_IDVER_RTL(idver), ether_sprintf(ac->ac_enaddr));

	ifp->if_softc = sc;
	ifp->if_capabilities = IFCAP_VLAN_MTU;
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ifp->if_start = cpsw_start;
	ifp->if_ioctl = cpsw_ioctl;
	ifp->if_watchdog = cpsw_watchdog;
	IFQ_SET_MAXLEN(&ifp->if_snd, CPSW_NTXDESCS - 1);
	memcpy(ifp->if_xname, DEVNAME(sc), IFNAMSIZ);

	cpsw_stop(ifp);

	sc->sc_mii.mii_ifp = ifp;
	sc->sc_mii.mii_readreg = cpsw_mii_readreg;
	sc->sc_mii.mii_writereg = cpsw_mii_writereg;
	sc->sc_mii.mii_statchg = cpsw_mii_statchg;

	cpsw_mdio_init(sc);

	ifmedia_init(&sc->sc_mii.mii_media, 0, cpsw_mediachange,
	    cpsw_mediastatus);
	mii_attach(self, &sc->sc_mii, 0xffffffff,
	    sc->sc_port_config[0].phy_id, MII_OFFSET_ANY, 0);
	if (LIST_FIRST(&sc->sc_mii.mii_phys) == NULL) {
		printf("no PHY found!\n");
		ifmedia_add(&sc->sc_mii.mii_media,
		    IFM_ETHER|IFM_MANUAL, 0, NULL);
		ifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER|IFM_MANUAL);
	} else {
		ifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER|IFM_AUTO);
	}

	if_attach(ifp);
	ether_ifattach(ifp);

	return;
}

int
cpsw_mediachange(struct ifnet *ifp)
{
	struct cpsw_softc *sc = ifp->if_softc;

	if (LIST_FIRST(&sc->sc_mii.mii_phys))
		mii_mediachg(&sc->sc_mii);

	return (0);
}

void
cpsw_mediastatus(struct ifnet *ifp, struct ifmediareq *ifmr)
{
	struct cpsw_softc *sc = ifp->if_softc;

	if (LIST_FIRST(&sc->sc_mii.mii_phys)) {
		mii_pollstat(&sc->sc_mii);
		ifmr->ifm_active = sc->sc_mii.mii_media_active;
		ifmr->ifm_status = sc->sc_mii.mii_media_status;
	}
}

void
cpsw_start(struct ifnet *ifp)
{
	struct cpsw_softc * const sc = ifp->if_softc;
	struct cpsw_ring_data * const rdp = sc->sc_rdp;
	struct cpsw_cpdma_bd bd;
	struct mbuf *m;
	bus_dmamap_t dm;
	u_int eopi = ~0;
	u_int seg;
	u_int txfree;
	int txstart = -1;
	int error;
	bool pad;
	u_int mlen;

	if (!ISSET(ifp->if_flags, IFF_RUNNING) ||
	    ifq_is_oactive(&ifp->if_snd) ||
	    IFQ_IS_EMPTY(&ifp->if_snd))
		return;

	if (sc->sc_txnext >= sc->sc_txhead)
		txfree = CPSW_NTXDESCS - 1 + sc->sc_txhead - sc->sc_txnext;
	else
		txfree = sc->sc_txhead - sc->sc_txnext - 1;

	for (;;) {
		if (txfree <= CPSW_TXFRAGS) {
			ifq_set_oactive(&ifp->if_snd);
			break;
		}

		IFQ_DEQUEUE(&ifp->if_snd, m);
		if (m == NULL)
			break;

		dm = rdp->tx_dm[sc->sc_txnext];
		error = bus_dmamap_load_mbuf(sc->sc_bdt, dm, m, BUS_DMA_NOWAIT);
		switch (error) {
		case 0:
			break;

		case EFBIG: /* mbuf chain is too fragmented */
			if (m_defrag(m, M_DONTWAIT) == 0 &&
			    bus_dmamap_load_mbuf(sc->sc_bdt, dm, m,
			    BUS_DMA_NOWAIT) == 0)
				break;

			/* FALLTHROUGH */
		default:
			m_freem(m);
			ifp->if_oerrors++;
			continue;
		}

		mlen = dm->dm_mapsize;
		pad = mlen < CPSW_PAD_LEN;

		KASSERT(rdp->tx_mb[sc->sc_txnext] == NULL);
		rdp->tx_mb[sc->sc_txnext] = m;

#if NBPFILTER > 0
		if (ifp->if_bpf)
			bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_OUT);
#endif

		bus_dmamap_sync(sc->sc_bdt, dm, 0, dm->dm_mapsize,
		    BUS_DMASYNC_PREWRITE);

		if (txstart == -1)
			txstart = sc->sc_txnext;
		eopi = sc->sc_txnext;
		for (seg = 0; seg < dm->dm_nsegs; seg++) {
			bd.next = cpsw_txdesc_paddr(sc,
			    TXDESC_NEXT(sc->sc_txnext));
			bd.bufptr = dm->dm_segs[seg].ds_addr;
			bd.bufoff = 0;
			bd.buflen = dm->dm_segs[seg].ds_len;
			bd.pktlen = 0;
			bd.flags = 0;

			if (seg == 0) {
				bd.flags = CPDMA_BD_OWNER | CPDMA_BD_SOP;
				bd.pktlen = MAX(mlen, CPSW_PAD_LEN);
			}

			if (seg == dm->dm_nsegs - 1 && !pad)
				bd.flags |= CPDMA_BD_EOP;

			cpsw_set_txdesc(sc, sc->sc_txnext, &bd);
			txfree--;
			eopi = sc->sc_txnext;
			sc->sc_txnext = TXDESC_NEXT(sc->sc_txnext);
		}
		if (pad) {
			bd.next = cpsw_txdesc_paddr(sc,
			    TXDESC_NEXT(sc->sc_txnext));
			bd.bufptr = sc->sc_txpad_pa;
			bd.bufoff = 0;
			bd.buflen = CPSW_PAD_LEN - mlen;
			bd.pktlen = 0;
			bd.flags = CPDMA_BD_EOP;

			cpsw_set_txdesc(sc, sc->sc_txnext, &bd);
			txfree--;
			eopi = sc->sc_txnext;
			sc->sc_txnext = TXDESC_NEXT(sc->sc_txnext);
		}
	}

	if (txstart >= 0) {
		ifp->if_timer = 5;
		/* terminate the new chain */
		KASSERT(eopi == TXDESC_PREV(sc->sc_txnext));
		cpsw_set_txdesc_next(sc, TXDESC_PREV(sc->sc_txnext), 0);
		
		/* link the new chain on */
		cpsw_set_txdesc_next(sc, TXDESC_PREV(txstart),
		    cpsw_txdesc_paddr(sc, txstart));
		if (sc->sc_txeoq) {
			/* kick the dma engine */
			sc->sc_txeoq = false;
			bus_space_write_4(sc->sc_bst, sc->sc_bsh, CPSW_CPDMA_TX_HDP(0),
			    cpsw_txdesc_paddr(sc, txstart));
		}
	}
}

int
cpsw_ioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
{
	struct cpsw_softc *sc = ifp->if_softc;
	struct ifreq *ifr = (struct ifreq *)data;
	int s = splnet();
	int error = 0;

	switch (cmd) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		/* FALLTHROUGH */
	case SIOCSIFFLAGS:
		if (ifp->if_flags & IFF_UP) {
			if (ifp->if_flags & IFF_RUNNING)
				error = ENETRESET;
			else
				cpsw_init(ifp);
		} else {
			if (ifp->if_flags & IFF_RUNNING)
				cpsw_stop(ifp);
		}
		break;
	case SIOCSIFMEDIA:
		ifr->ifr_media &= ~IFM_ETH_FMASK;
		/* FALLTHROUGH */
	case SIOCGIFMEDIA:
		error = ifmedia_ioctl(ifp, ifr, &sc->sc_mii.mii_media, cmd);
		break;
	default:
		error = ether_ioctl(ifp, &sc->sc_ac, cmd, data);
		break;
	}
	if (error == ENETRESET) {
		if (ifp->if_flags & IFF_RUNNING)
			cpsw_init(ifp);
		error = 0;
	}

	splx(s);

	return error;
}

void
cpsw_watchdog(struct ifnet *ifp)
{
	printf("%s: device timeout\n", ifp->if_xname);

	ifp->if_oerrors++;
	cpsw_init(ifp);
	cpsw_start(ifp);
}

static int
cpsw_mii_wait(struct cpsw_softc * const sc, int reg)
{
	u_int tries;

	for(tries = 0; tries < 1000; tries++) {
		if ((bus_space_read_4(sc->sc_bst, sc->sc_bsh, reg) & (1U << 31)) == 0)
			return 0;
		delay(1);
	}
	return ETIMEDOUT;
}

int
cpsw_mii_readreg(struct device *dev, int phy, int reg)
{
	struct cpsw_softc * const sc = (struct cpsw_softc *)dev;
	uint32_t v;

	if (cpsw_mii_wait(sc, MDIOUSERACCESS0) != 0)
		return 0;

	bus_space_write_4(sc->sc_bst, sc->sc_bsh, MDIOUSERACCESS0, (1U << 31) |
	    ((reg & 0x1F) << 21) | ((phy & 0x1F) << 16));

	if (cpsw_mii_wait(sc, MDIOUSERACCESS0) != 0)
		return 0;

	v = bus_space_read_4(sc->sc_bst, sc->sc_bsh, MDIOUSERACCESS0);
	if (v & (1 << 29))
		return v & 0xffff;
	else
		return 0;
}

void
cpsw_mii_writereg(struct device *dev, int phy, int reg, int val)
{
	struct cpsw_softc * const sc = (struct cpsw_softc *)dev;
	uint32_t v;

	KASSERT((val & 0xffff0000UL) == 0);

	if (cpsw_mii_wait(sc, MDIOUSERACCESS0) != 0)
		goto out;

	bus_space_write_4(sc->sc_bst, sc->sc_bsh, MDIOUSERACCESS0, (1U << 31) | (1 << 30) |
	    ((reg & 0x1F) << 21) | ((phy & 0x1F) << 16) | val);

	if (cpsw_mii_wait(sc, MDIOUSERACCESS0) != 0)
		goto out;

	v = bus_space_read_4(sc->sc_bst, sc->sc_bsh, MDIOUSERACCESS0);
	if ((v & (1 << 29)) == 0)
out:
		printf("%s error\n", __func__);

}

void
cpsw_mii_statchg(struct device *self)
{
	return;
}

int
cpsw_new_rxbuf(struct cpsw_softc * const sc, const u_int i)
{
	struct cpsw_ring_data * const rdp = sc->sc_rdp;
	const u_int h = RXDESC_PREV(i);
	struct cpsw_cpdma_bd bd;
	struct mbuf *m;
	int error = ENOBUFS;

	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m == NULL) {
		goto reuse;
	}

	MCLGET(m, M_DONTWAIT);
	if ((m->m_flags & M_EXT) == 0) {
		m_freem(m);
		goto reuse;
	}

	/* We have a new buffer, prepare it for the ring. */

	if (rdp->rx_mb[i] != NULL)
		bus_dmamap_unload(sc->sc_bdt, rdp->rx_dm[i]);

	m->m_len = m->m_pkthdr.len = MCLBYTES;

	rdp->rx_mb[i] = m;

	error = bus_dmamap_load_mbuf(sc->sc_bdt, rdp->rx_dm[i], rdp->rx_mb[i],
	    BUS_DMA_READ|BUS_DMA_NOWAIT);
	if (error) {
		printf("can't load rx DMA map %d: %d\n", i, error);
	}

	bus_dmamap_sync(sc->sc_bdt, rdp->rx_dm[i],
	    0, rdp->rx_dm[i]->dm_mapsize, BUS_DMASYNC_PREREAD);

	error = 0;

reuse:
	/* (re-)setup the descriptor */
	bd.next = 0;
	bd.bufptr = rdp->rx_dm[i]->dm_segs[0].ds_addr;
	bd.bufoff = 0;
	bd.buflen = MIN(0x7ff, rdp->rx_dm[i]->dm_segs[0].ds_len);
	bd.pktlen = 0;
	bd.flags = CPDMA_BD_OWNER;

	cpsw_set_rxdesc(sc, i, &bd);
	/* and link onto ring */
	cpsw_set_rxdesc_next(sc, h, cpsw_rxdesc_paddr(sc, i));

	return error;
}

int
cpsw_init(struct ifnet *ifp)
{
	struct cpsw_softc * const sc = ifp->if_softc;
	struct arpcom *ac = &sc->sc_ac;
	struct mii_data * const mii = &sc->sc_mii;
	int i;

	cpsw_stop(ifp);

	sc->sc_txnext = 0;
	sc->sc_txhead = 0;

	/* Reset wrapper */
	bus_space_write_4(sc->sc_bst, sc->sc_bsh, CPSW_WR_SOFT_RESET, 1);
	while(bus_space_read_4(sc->sc_bst, sc->sc_bsh, CPSW_WR_SOFT_RESET) & 1);

	/* Reset SS */
	bus_space_write_4(sc->sc_bst, sc->sc_bsh, CPSW_SS_SOFT_RESET, 1);
	while(bus_space_read_4(sc->sc_bst, sc->sc_bsh, CPSW_SS_SOFT_RESET) & 1);

	/* Clear table (30) and enable ALE(31) and set passthrough (4) */
	bus_space_write_4(sc->sc_bst, sc->sc_bsh, CPSW_ALE_CONTROL, (3 << 30) | 0x10);

	/* Reset and init Sliver port 1 and 2 */
	for (i = 0; i < 2; i++) {
		/* Reset */
		bus_space_write_4(sc->sc_bst, sc->sc_bsh, CPSW_SL_SOFT_RESET(i), 1);
		while(bus_space_read_4(sc->sc_bst, sc->sc_bsh, CPSW_SL_SOFT_RESET(i)) & 1);
		/* Set Slave Mapping */
		bus_space_write_4(sc->sc_bst, sc->sc_bsh, CPSW_SL_RX_PRI_MAP(i), 0x76543210);
		bus_space_write_4(sc->sc_bst, sc->sc_bsh, CPSW_PORT_P_TX_PRI_MAP(i+1), 0x33221100);
		bus_space_write_4(sc->sc_bst, sc->sc_bsh, CPSW_SL_RX_MAXLEN(i), 0x5f2);
		/* Set MAC Address */
		bus_space_write_4(sc->sc_bst, sc->sc_bsh, CPSW_PORT_P_SA_HI(i+1),
		    ac->ac_enaddr[0] | (ac->ac_enaddr[1] << 8) |
		    (ac->ac_enaddr[2] << 16) | (ac->ac_enaddr[3] << 24));
		bus_space_write_4(sc->sc_bst, sc->sc_bsh, CPSW_PORT_P_SA_LO(i+1),
		    ac->ac_enaddr[4] | (ac->ac_enaddr[5] << 8));

		/* Set MACCONTROL for ports 0,1: FULLDUPLEX(0), GMII_EN(5),
		   IFCTL_A(15), IFCTL_B(16) FIXME */
		bus_space_write_4(sc->sc_bst, sc->sc_bsh, CPSW_SL_MACCONTROL(i),
		    1 | (1<<5) | (1<<15) | (1<<16));

		/* Set ALE port to forwarding(3) on the active port */
		if (i == sc->sc_active_port)
			bus_space_write_4(sc->sc_bst, sc->sc_bsh, CPSW_ALE_PORTCTL(i+1), 3);
	}

	/* Set Host Port Mapping */
	bus_space_write_4(sc->sc_bst, sc->sc_bsh, CPSW_PORT_P0_CPDMA_TX_PRI_MAP, 0x76543210);
	bus_space_write_4(sc->sc_bst, sc->sc_bsh, CPSW_PORT_P0_CPDMA_RX_CH_MAP, 0);

	/* Set ALE port to forwarding(3) */
	bus_space_write_4(sc->sc_bst, sc->sc_bsh, CPSW_ALE_PORTCTL(0), 3);

	bus_space_write_4(sc->sc_bst, sc->sc_bsh, CPSW_SS_PTYPE, 0);
	bus_space_write_4(sc->sc_bst, sc->sc_bsh, CPSW_SS_STAT_PORT_EN, 7);

	bus_space_write_4(sc->sc_bst, sc->sc_bsh, CPSW_CPDMA_SOFT_RESET, 1);
	while(bus_space_read_4(sc->sc_bst, sc->sc_bsh, CPSW_CPDMA_SOFT_RESET) & 1);

	for (i = 0; i < 8; i++) {
		bus_space_write_4(sc->sc_bst, sc->sc_bsh, CPSW_CPDMA_TX_HDP(i), 0);
		bus_space_write_4(sc->sc_bst, sc->sc_bsh, CPSW_CPDMA_RX_HDP(i), 0);
		bus_space_write_4(sc->sc_bst, sc->sc_bsh, CPSW_CPDMA_TX_CP(i), 0);
		bus_space_write_4(sc->sc_bst, sc->sc_bsh, CPSW_CPDMA_RX_CP(i), 0);
	}

	bus_space_set_region_4(sc->sc_bst, sc->sc_bsh_txdescs, 0, 0,
	    CPSW_CPPI_RAM_TXDESCS_SIZE/4);

	sc->sc_txhead = 0;
	sc->sc_txnext = 0;

	bus_space_write_4(sc->sc_bst, sc->sc_bsh, CPSW_CPDMA_RX_FREEBUFFER(0), 0);

	bus_space_set_region_4(sc->sc_bst, sc->sc_bsh_rxdescs, 0, 0,
	    CPSW_CPPI_RAM_RXDESCS_SIZE/4);

	/* Initialize RX Buffer Descriptors */
	cpsw_set_rxdesc_next(sc, RXDESC_PREV(0), 0);
	for (i = 0; i < CPSW_NRXDESCS; i++) {
		cpsw_new_rxbuf(sc, i);
	}
	sc->sc_rxhead = 0;

	/* align layer 3 header to 32-bit */
	bus_space_write_4(sc->sc_bst, sc->sc_bsh, CPSW_CPDMA_RX_BUFFER_OFFSET, ETHER_ALIGN);

	/* Clear all interrupt Masks */
	bus_space_write_4(sc->sc_bst, sc->sc_bsh, CPSW_CPDMA_RX_INTMASK_CLEAR, 0xFFFFFFFF);
	bus_space_write_4(sc->sc_bst, sc->sc_bsh, CPSW_CPDMA_TX_INTMASK_CLEAR, 0xFFFFFFFF);

	/* Enable TX & RX DMA */
	bus_space_write_4(sc->sc_bst, sc->sc_bsh, CPSW_CPDMA_TX_CONTROL, 1);
	bus_space_write_4(sc->sc_bst, sc->sc_bsh, CPSW_CPDMA_RX_CONTROL, 1);

	/* Enable interrupt pacing for C0 RX/TX (IMAX set to max intr/ms allowed) */
#define CPSW_VBUSP_CLK_MHZ	2400	/* hardcoded for BBB */
	bus_space_write_4(sc->sc_bst, sc->sc_bsh, CPSW_WR_C_RX_IMAX(0), 2);
	bus_space_write_4(sc->sc_bst, sc->sc_bsh, CPSW_WR_C_TX_IMAX(0), 2);
	bus_space_write_4(sc->sc_bst, sc->sc_bsh, CPSW_WR_INT_CONTROL, 3 << 16 | CPSW_VBUSP_CLK_MHZ/4);

	/* Enable TX and RX interrupt receive for core 0 */
	bus_space_write_4(sc->sc_bst, sc->sc_bsh, CPSW_WR_C_TX_EN(0), 1);
	bus_space_write_4(sc->sc_bst, sc->sc_bsh, CPSW_WR_C_RX_EN(0), 1);
	bus_space_write_4(sc->sc_bst, sc->sc_bsh, CPSW_WR_C_MISC_EN(0), 0x1F);

	/* Enable host Error Interrupt */
	bus_space_write_4(sc->sc_bst, sc->sc_bsh, CPSW_CPDMA_DMA_INTMASK_SET, 2);

	/* Enable interrupts for TX and RX Channel 0 */
	bus_space_write_4(sc->sc_bst, sc->sc_bsh, CPSW_CPDMA_TX_INTMASK_SET, 1);
	bus_space_write_4(sc->sc_bst, sc->sc_bsh, CPSW_CPDMA_RX_INTMASK_SET, 1);

	/* Ack stalled irqs */
	bus_space_write_4(sc->sc_bst, sc->sc_bsh, CPSW_CPDMA_CPDMA_EOI_VECTOR, CPSW_INTROFF_RXTH);
	bus_space_write_4(sc->sc_bst, sc->sc_bsh, CPSW_CPDMA_CPDMA_EOI_VECTOR, CPSW_INTROFF_RX);
	bus_space_write_4(sc->sc_bst, sc->sc_bsh, CPSW_CPDMA_CPDMA_EOI_VECTOR, CPSW_INTROFF_TX);
	bus_space_write_4(sc->sc_bst, sc->sc_bsh, CPSW_CPDMA_CPDMA_EOI_VECTOR, CPSW_INTROFF_MISC);

	cpsw_mdio_init(sc);

	mii_mediachg(mii);

	/* Write channel 0 RX HDP */
	bus_space_write_4(sc->sc_bst, sc->sc_bsh, CPSW_CPDMA_RX_HDP(0), cpsw_rxdesc_paddr(sc, 0));
	sc->sc_rxrun = true;
	sc->sc_rxeoq = false;

	sc->sc_txrun = true;
	sc->sc_txeoq = true;

	ifp->if_flags |= IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	timeout_add_sec(&sc->sc_tick, 1);

	return 0;
}

void
cpsw_stop(struct ifnet *ifp)
{
	struct cpsw_softc * const sc = ifp->if_softc;
	struct cpsw_ring_data * const rdp = sc->sc_rdp;
	u_int i;

#if 0
	/* XXX find where disable comes from */
	printf("%s: ifp %p disable %d\n", __func__, ifp, disable);
#endif
	if ((ifp->if_flags & IFF_RUNNING) == 0)
		return;

	timeout_del(&sc->sc_tick);

	mii_down(&sc->sc_mii);

	bus_space_write_4(sc->sc_bst, sc->sc_bsh, CPSW_CPDMA_TX_INTMASK_CLEAR, 1);
	bus_space_write_4(sc->sc_bst, sc->sc_bsh, CPSW_CPDMA_RX_INTMASK_CLEAR, 1);
	bus_space_write_4(sc->sc_bst, sc->sc_bsh, CPSW_WR_C_TX_EN(0), 0x0);
	bus_space_write_4(sc->sc_bst, sc->sc_bsh, CPSW_WR_C_RX_EN(0), 0x0);
	bus_space_write_4(sc->sc_bst, sc->sc_bsh, CPSW_WR_C_MISC_EN(0), 0x1F);

	bus_space_write_4(sc->sc_bst, sc->sc_bsh, CPSW_CPDMA_TX_TEARDOWN, 0);
	bus_space_write_4(sc->sc_bst, sc->sc_bsh, CPSW_CPDMA_RX_TEARDOWN, 0);
	i = 0;
	while ((sc->sc_txrun || sc->sc_rxrun) && i < 10000) {
		delay(10);
		if ((sc->sc_txrun == true) && cpsw_txintr(sc) == 0)
			sc->sc_txrun = false;
		if ((sc->sc_rxrun == true) && cpsw_rxintr(sc) == 0)
			sc->sc_rxrun = false;
		i++;
	}
	/* printf("%s toredown complete in %u\n", __func__, i); */

	/* Reset wrapper */
	bus_space_write_4(sc->sc_bst, sc->sc_bsh, CPSW_WR_SOFT_RESET, 1);
	while(bus_space_read_4(sc->sc_bst, sc->sc_bsh, CPSW_WR_SOFT_RESET) & 1);

	/* Reset SS */
	bus_space_write_4(sc->sc_bst, sc->sc_bsh, CPSW_SS_SOFT_RESET, 1);
	while(bus_space_read_4(sc->sc_bst, sc->sc_bsh, CPSW_SS_SOFT_RESET) & 1);

	for (i = 0; i < 2; i++) {
		bus_space_write_4(sc->sc_bst, sc->sc_bsh, CPSW_SL_SOFT_RESET(i), 1);
		while(bus_space_read_4(sc->sc_bst, sc->sc_bsh, CPSW_SL_SOFT_RESET(i)) & 1);
	}

	/* Reset CPDMA */
	bus_space_write_4(sc->sc_bst, sc->sc_bsh, CPSW_CPDMA_SOFT_RESET, 1);
	while(bus_space_read_4(sc->sc_bst, sc->sc_bsh, CPSW_CPDMA_SOFT_RESET) & 1);

	/* Release any queued transmit buffers. */
	for (i = 0; i < CPSW_NTXDESCS; i++) {
		bus_dmamap_unload(sc->sc_bdt, rdp->tx_dm[i]);
		m_freem(rdp->tx_mb[i]);
		rdp->tx_mb[i] = NULL;
	}

	ifp->if_flags &= ~IFF_RUNNING;
	ifp->if_timer = 0;
	ifq_clr_oactive(&ifp->if_snd);

	/* XXX Not sure what this is doing calling disable here
	    where is disable set?
	*/
#if 0
	if (!disable)
		return;
#endif

	for (i = 0; i < CPSW_NRXDESCS; i++) {
		bus_dmamap_unload(sc->sc_bdt, rdp->rx_dm[i]);
		m_freem(rdp->rx_mb[i]);
		rdp->rx_mb[i] = NULL;
	}
}

int
cpsw_rxthintr(void *arg)
{
	struct cpsw_softc * const sc = arg;

	/* this won't deassert the interrupt though */
	bus_space_write_4(sc->sc_bst, sc->sc_bsh, CPSW_CPDMA_CPDMA_EOI_VECTOR, CPSW_INTROFF_RXTH);

	return 1;
}

int
cpsw_rxintr(void *arg)
{
	struct cpsw_softc * const sc = arg;
	struct ifnet * const ifp = &sc->sc_ac.ac_if;
	struct cpsw_ring_data * const rdp = sc->sc_rdp;
	struct cpsw_cpdma_bd bd;
	bus_dmamap_t dm;
	struct mbuf_list ml = MBUF_LIST_INITIALIZER();
	struct mbuf *m;
	u_int i;
	u_int len, off;

	sc->sc_rxeoq = false;
	
	for (;;) {
		KASSERT(sc->sc_rxhead < CPSW_NRXDESCS);

		i = sc->sc_rxhead;
		dm = rdp->rx_dm[i];
		m = rdp->rx_mb[i];

		KASSERT(dm != NULL);
		KASSERT(m != NULL);

		cpsw_get_rxdesc(sc, i, &bd);

		if (bd.flags & CPDMA_BD_OWNER)
			break;

		if (bd.flags & CPDMA_BD_TDOWNCMPLT) {
			sc->sc_rxrun = false;
			goto done;
		}

		bus_dmamap_sync(sc->sc_bdt, dm, 0, dm->dm_mapsize,
		    BUS_DMASYNC_POSTREAD);

		if (cpsw_new_rxbuf(sc, i) != 0) {
			/* drop current packet, reuse buffer for new */
			ifp->if_ierrors++;
			goto next;
		}

		if ((bd.flags & (CPDMA_BD_SOP|CPDMA_BD_EOP)) !=
		    (CPDMA_BD_SOP|CPDMA_BD_EOP)) {
			if (bd.flags & CPDMA_BD_SOP) {
				printf("cpsw: rx packet too large\n");
				ifp->if_ierrors++;
			}
			m_freem(m);
			goto next;
		}

		off = bd.bufoff;
		len = bd.pktlen;

		if (bd.flags & CPDMA_BD_PASSCRC)
			len -= ETHER_CRC_LEN;

		m->m_pkthdr.len = m->m_len = len;
		m->m_data += off;

		ml_enqueue(&ml, m);

next:
		sc->sc_rxhead = RXDESC_NEXT(sc->sc_rxhead);
		if (bd.flags & CPDMA_BD_EOQ) {
			sc->sc_rxeoq = true;
			sc->sc_rxrun = false;
		}
		bus_space_write_4(sc->sc_bst, sc->sc_bsh, CPSW_CPDMA_RX_CP(0),
		    cpsw_rxdesc_paddr(sc, i));
	}

	if (sc->sc_rxeoq) {
		bus_space_write_4(sc->sc_bst, sc->sc_bsh, CPSW_CPDMA_RX_HDP(0),
				  cpsw_rxdesc_paddr(sc, sc->sc_rxhead));
		sc->sc_rxrun = true;
		sc->sc_rxeoq = false;
	}

	bus_space_write_4(sc->sc_bst, sc->sc_bsh, CPSW_CPDMA_CPDMA_EOI_VECTOR,
	    CPSW_INTROFF_RX);

done:
	if_input(ifp, &ml);

	return 1;
}

void
cpsw_tick(void *arg)
{
	struct cpsw_softc *sc = arg;
	int s;

	s = splnet();
	mii_tick(&sc->sc_mii);
	splx(s);

	timeout_add_sec(&sc->sc_tick, 1);
}

int
cpsw_txintr(void *arg)
{
	struct cpsw_softc * const sc = arg;
	struct ifnet * const ifp = &sc->sc_ac.ac_if;
	struct cpsw_ring_data * const rdp = sc->sc_rdp;
	struct cpsw_cpdma_bd bd;
	bool handled = false;
	uint32_t tx0_cp;
	u_int cpi;

	KASSERT(sc->sc_txrun);

	tx0_cp = bus_space_read_4(sc->sc_bst, sc->sc_bsh, CPSW_CPDMA_TX_CP(0));

	if (tx0_cp == 0xfffffffc) {
		bus_space_write_4(sc->sc_bst, sc->sc_bsh, CPSW_CPDMA_TX_CP(0), 0xfffffffc);
		bus_space_write_4(sc->sc_bst, sc->sc_bsh, CPSW_CPDMA_TX_HDP(0), 0);
		sc->sc_txrun = false;
		return 0;
	}

	for (;;) {
		tx0_cp = bus_space_read_4(sc->sc_bst, sc->sc_bsh, CPSW_CPDMA_TX_CP(0));
		cpi = (tx0_cp - sc->sc_txdescs_pa) /
		    sizeof(struct cpsw_cpdma_bd);
		KASSERT(sc->sc_txhead < CPSW_NTXDESCS);

		cpsw_get_txdesc(sc, sc->sc_txhead, &bd);

		if (bd.buflen == 0) {
			/* db_enter(); */
		}

		if ((bd.flags & CPDMA_BD_SOP) == 0)
			goto next;

		if (bd.flags & CPDMA_BD_OWNER) {
			printf("pwned %x %x %x\n", cpi, sc->sc_txhead,
			    sc->sc_txnext);
			break;
		}

		if (bd.flags & CPDMA_BD_TDOWNCMPLT) {
			sc->sc_txrun = false;
			return 1;
		}

		bus_dmamap_sync(sc->sc_bdt, rdp->tx_dm[sc->sc_txhead],
		    0, rdp->tx_dm[sc->sc_txhead]->dm_mapsize,
		    BUS_DMASYNC_POSTWRITE);
		bus_dmamap_unload(sc->sc_bdt, rdp->tx_dm[sc->sc_txhead]);

		m_freem(rdp->tx_mb[sc->sc_txhead]);
		rdp->tx_mb[sc->sc_txhead] = NULL;

		handled = true;

		ifq_clr_oactive(&ifp->if_snd);

next:
		if ((bd.flags & (CPDMA_BD_EOP|CPDMA_BD_EOQ)) ==
		    (CPDMA_BD_EOP|CPDMA_BD_EOQ))
			sc->sc_txeoq = true;

		if (sc->sc_txhead == cpi) {
			bus_space_write_4(sc->sc_bst, sc->sc_bsh, CPSW_CPDMA_TX_CP(0),
			    cpsw_txdesc_paddr(sc, cpi));
			sc->sc_txhead = TXDESC_NEXT(sc->sc_txhead);
			break;
		}
		sc->sc_txhead = TXDESC_NEXT(sc->sc_txhead);
		if (sc->sc_txeoq == true)
			break;
	}

	bus_space_write_4(sc->sc_bst, sc->sc_bsh, CPSW_CPDMA_CPDMA_EOI_VECTOR, CPSW_INTROFF_TX);

	if ((sc->sc_txnext != sc->sc_txhead) && sc->sc_txeoq) {
		if (bus_space_read_4(sc->sc_bst, sc->sc_bsh, CPSW_CPDMA_TX_HDP(0)) == 0) {
			sc->sc_txeoq = false;
			bus_space_write_4(sc->sc_bst, sc->sc_bsh, CPSW_CPDMA_TX_HDP(0),
			    cpsw_txdesc_paddr(sc, sc->sc_txhead));
		}
	}

	if (handled && sc->sc_txnext == sc->sc_txhead)
		ifp->if_timer = 0;

	if (handled)
		cpsw_start(ifp);

	return handled;
}

int
cpsw_miscintr(void *arg)
{
	struct cpsw_softc * const sc = arg;
	uint32_t miscstat;
	uint32_t dmastat;
	uint32_t stat;

	miscstat = bus_space_read_4(sc->sc_bst, sc->sc_bsh, CPSW_WR_C_MISC_STAT(0));
	printf("%s %x FIRE\n", __func__, miscstat);

	if (miscstat & CPSW_MISC_HOST_PEND) {
		/* Host Error */
		dmastat = bus_space_read_4(sc->sc_bst, sc->sc_bsh, CPSW_CPDMA_DMA_INTSTAT_MASKED);
		printf("CPSW_CPDMA_DMA_INTSTAT_MASKED %x\n", dmastat);

		printf("rxhead %02x\n", sc->sc_rxhead);

		stat = bus_space_read_4(sc->sc_bst, sc->sc_bsh, CPSW_CPDMA_DMASTATUS);
		printf("CPSW_CPDMA_DMASTATUS %x\n", stat);
		stat = bus_space_read_4(sc->sc_bst, sc->sc_bsh, CPSW_CPDMA_TX_HDP(0));
		printf("CPSW_CPDMA_TX0_HDP %x\n", stat);
		stat = bus_space_read_4(sc->sc_bst, sc->sc_bsh, CPSW_CPDMA_TX_CP(0));
		printf("CPSW_CPDMA_TX0_CP %x\n", stat);
		stat = bus_space_read_4(sc->sc_bst, sc->sc_bsh, CPSW_CPDMA_RX_HDP(0));
		printf("CPSW_CPDMA_RX0_HDP %x\n", stat);
		stat = bus_space_read_4(sc->sc_bst, sc->sc_bsh, CPSW_CPDMA_RX_CP(0));
		printf("CPSW_CPDMA_RX0_CP %x\n", stat);

		/* db_enter(); */

		bus_space_write_4(sc->sc_bst, sc->sc_bsh, CPSW_CPDMA_DMA_INTMASK_CLEAR, dmastat);
		dmastat = bus_space_read_4(sc->sc_bst, sc->sc_bsh, CPSW_CPDMA_DMA_INTSTAT_MASKED);
		printf("CPSW_CPDMA_DMA_INTSTAT_MASKED %x\n", dmastat);
	}

	bus_space_write_4(sc->sc_bst, sc->sc_bsh, CPSW_CPDMA_CPDMA_EOI_VECTOR, CPSW_INTROFF_MISC);

	return 1;
}

void
cpsw_get_port_config(struct cpsw_port_config *conf, int pnode)
{
	char mode[32];
	uint32_t phy_id[2];
	int node;
	int port = 0;

	for (node = OF_child(pnode); node; node = OF_peer(node)) {
		if (OF_getprop(node, "local-mac-address", conf[port].enaddr,
		    sizeof(conf[port].enaddr)) != sizeof(conf[port].enaddr))
			continue;

		conf[port].vlan = OF_getpropint(node, "dual_emac_res_vlan", 0);

		if (OF_getpropintarray(node, "phy_id", phy_id,
		    sizeof(phy_id)) == sizeof(phy_id))
			conf[port].phy_id = phy_id[1];

		if (OF_getprop(node, "phy-mode", mode, sizeof(mode)) > 0 &&
		    !strcmp(mode, "rgmii"))
			conf[port].rgmii = 1;
		else
			conf[port].rgmii = 0;

		if (port == 0)
			port = 1;
	}
}
@


1.42
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_cpsw.c,v 1.41 2016/10/02 23:38:32 jsg Exp $ */
d1178 1
a1178 1
			/* Debugger(); */
d1271 1
a1271 1
		/* Debugger(); */
@


1.41
log
@Set IFCAP_VLAN_MTU capability in cpsw(4).  Avoids
"ifconfig: SIOCSETVLAN: No buffer space available" when creating vlan
interfaces without first lowering the mtu.  Reported by Steven Chamberlain,
diagnosed by mikeb@@, patch from Brad.  ok bmercer@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_cpsw.c,v 1.40 2016/08/12 03:22:41 jsg Exp $ */
a1201 2

		ifp->if_opackets++;
@


1.40
log
@Switch omap to the generic ofw pinctrl framework.

ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_cpsw.c,v 1.39 2016/08/06 10:07:45 jsg Exp $ */
d447 1
a447 1
	ifp->if_capabilities = 0;
@


1.39
log
@Dynamically attach intc(4) using the FDT and switch omap/am335x
drivers that use the FDT over to the FDT interrupt establish API.

ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_cpsw.c,v 1.38 2016/07/27 11:45:02 patrick Exp $ */
a86 1
#include <arch/armv7/omap/sitara_cm.h>
d89 1
d354 1
a354 1
	sitara_cm_pinctrlbyname(faa->fa_node, "default");
d364 1
a364 1
		sitara_cm_pinctrlbyname(node, "default");
@


1.38
log
@Instead of passing the raw reg property to simplebus nodes,
pass a pre-processed array of fdt_reg structs.  This means
that the drivers don't have to understand the cell properties
themselves but can rely on the 64-bit addr/size pairs.

ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_cpsw.c,v 1.37 2016/07/17 02:45:05 jsg Exp $ */
a340 1
	uint32_t intr[4];
d344 1
a344 1
	if (faa->fa_nreg < 1 || (faa->fa_nintr != 4 && faa->fa_nintr != 12))
a346 7
	for (i = 0; i < 4; i++) {
		if (faa->fa_nintr == 4)
			intr[i] = faa->fa_intr[i];
		else
			intr[i] = faa->fa_intr[(3 * i) + 1];
	}

d373 8
a380 8
	sc->sc_rxthih = arm_intr_establish(intr[0], IPL_NET, cpsw_rxthintr, sc,
	    DEVNAME(sc));
	sc->sc_rxih = arm_intr_establish(intr[1], IPL_NET, cpsw_rxintr, sc,
	    DEVNAME(sc));
	sc->sc_txih = arm_intr_establish(intr[2], IPL_NET, cpsw_txintr, sc,
	    DEVNAME(sc));
	sc->sc_miscih = arm_intr_establish(intr[3], IPL_NET, cpsw_miscintr, sc,
	    DEVNAME(sc));
@


1.37
log
@Adapt kettenis' pinctrl changes in imx to sitaracm and
pinctrl-single,pins to handle mux settings and pad configuration.

The fdt data has offsets from the start of the pinmux address range so
the am335x specific pinmux offset from the scm base is added to the
offsets.  This as not a new driver as sitaracm does manual table
driven pad configuration for gpio.  If all the offsets in the
ti_padconf_devmap table were reduced by the am335x pinmux offset (0x800)
it may make sense to map only the pinmux memory region and not the
scm superset.

looks good kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_cpsw.c,v 1.36 2016/07/09 04:25:44 jsg Exp $ */
d90 1
d345 1
a345 1
	if (faa->fa_nreg < 2 || (faa->fa_nintr != 4 && faa->fa_nintr != 12))
d356 2
a357 2
	 * fa_reg[1] is size of CPSW_SS and CPSW_PORT
	 * fa_reg[3] is size of CPSW_WR
d393 1
a393 1
	error = bus_space_map(sc->sc_bst, faa->fa_reg[0],
d400 1
a400 1
	sc->sc_txdescs_pa = faa->fa_reg[0] +
d410 1
a410 1
	sc->sc_rxdescs_pa = faa->fa_reg[0] +
@


1.36
log
@Use mac address and phy id from the fdt.  Store settings for a second
port as well, though we still only handle a single port for now.
ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_cpsw.c,v 1.35 2016/06/26 09:06:35 jsg Exp $ */
d87 1
d338 1
d342 1
d360 13
@


1.35
log
@Dynamically attach cpsw(4) with the FDT.
@
text
@d1 1
a1 1
/* $OpenBSD: if_cpsw.c,v 1.34 2016/04/13 11:33:59 mpi Exp $ */
a85 1
#include <arch/armv7/omap/sitara_cm.h>
d121 7
d161 2
d191 1
a191 1
void	cpsw_get_mac_addr(struct cpsw_softc *);
a280 21
void
cpsw_get_mac_addr(struct cpsw_softc *sc)
{
	struct arpcom *ac = &sc->sc_ac;
	u_int32_t	mac_lo = 0, mac_hi = 0;

	sitara_cm_reg_read_4(OMAP2SCM_MAC_ID0_LO, &mac_lo);
	sitara_cm_reg_read_4(OMAP2SCM_MAC_ID0_HI, &mac_hi);

	if ((mac_lo == 0) && (mac_hi == 0))
		printf("%s: invalid ethernet address\n", DEVNAME(sc));
	else {
		ac->ac_enaddr[0] = (mac_hi >>  0) & 0xff;
		ac->ac_enaddr[1] = (mac_hi >>  8) & 0xff;
		ac->ac_enaddr[2] = (mac_hi >> 16) & 0xff;
		ac->ac_enaddr[3] = (mac_hi >> 24) & 0xff;
		ac->ac_enaddr[4] = (mac_lo >>  0) & 0xff;
		ac->ac_enaddr[5] = (mac_lo >>  8) & 0xff;
	}
}

d360 3
a362 1
	cpsw_get_mac_addr(sc);
d458 1
a458 1
	    MII_PHY_ANY, MII_OFFSET_ANY, 0);
d1274 30
@


1.34
log
@G/C IFQ_SET_READY().
@
text
@d1 1
a1 1
/* $OpenBSD: if_cpsw.c,v 1.33 2016/03/02 01:31:41 canacar Exp $ */
d70 1
d89 2
d159 1
d187 1
a187 1
	NULL,
d333 8
d345 1
a345 1
	struct armv7_attach_args *aa = aux;
d351 19
d375 8
a382 8
	sc->sc_rxthih = arm_intr_establish(aa->aa_dev->irq[0] +
	    CPSW_INTROFF_RXTH, IPL_NET, cpsw_rxthintr, sc, DEVNAME(sc));
	sc->sc_rxih = arm_intr_establish(aa->aa_dev->irq[0] +
	    CPSW_INTROFF_RX, IPL_NET, cpsw_rxintr, sc, DEVNAME(sc));
	sc->sc_txih = arm_intr_establish(aa->aa_dev->irq[0] +
	    CPSW_INTROFF_TX, IPL_NET, cpsw_txintr, sc, DEVNAME(sc));
	sc->sc_miscih = arm_intr_establish(aa->aa_dev->irq[0] +
	    CPSW_INTROFF_MISC, IPL_NET, cpsw_miscintr, sc, DEVNAME(sc));
d384 2
a385 2
	sc->sc_bst = aa->aa_iot;
	sc->sc_bdt = aa->aa_dmat;
d387 2
a388 2
	error = bus_space_map(sc->sc_bst, aa->aa_dev->mem[0].addr,
	    aa->aa_dev->mem[0].size, 0, &sc->sc_bsh);
d394 1
a394 1
	sc->sc_txdescs_pa = aa->aa_dev->mem[0].addr +
d404 1
a404 1
	sc->sc_rxdescs_pa = aa->aa_dev->mem[0].addr +
@


1.33
log
@Detect and only enable the port that is actually used.
The unused port, if enabled, fills up and triggers flow
control, blocking transmit and causing device timeouts.

Also enable interrupt pacing to limit interrupts at 2K/s.

Reported and fix tested by Anthony Eden.
ok dlg@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_cpsw.c,v 1.32 2016/01/07 04:41:17 canacar Exp $ */
a423 1
	IFQ_SET_READY(&ifp->if_snd);
@


1.32
log
@Handle receive queue full condition instead of hanging.This can be
triggered by flodding the interface. Also drop received packets
that span multiple buffers (which should not happen).
Tested on Beagle Bone Black by jsg@@
ok bmercer@@, djm@@, jsg@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_cpsw.c,v 1.31 2015/11/25 11:12:53 mpi Exp $ */
d151 1
d290 39
d434 2
d821 1
a821 1
		/* Set MACCONTROL for ports 0,1: FULLDUPLEX(1), GMII_EN(5),
d826 3
a828 2
		/* Set ALE port to forwarding(3) */
		bus_space_write_4(sc->sc_bst, sc->sc_bsh, CPSW_ALE_PORTCTL(i+1), 3);
d880 6
d904 1
a904 3
	/* Initialze MDIO - ENABLE, PREAMBLE=0, FAULTENB, CLKDIV=0xFF */
	/* TODO Calculate MDCLK=CLK/(CLKDIV+1) */
	bus_space_write_4(sc->sc_bst, sc->sc_bsh, MDIOCONTROL, (1<<30) | (1<<18) | 0xFF);
@


1.31
log
@Small fixes related to the IFF_OACTIVE removal.
@
text
@d1 1
a1 1
/* $OpenBSD: if_cpsw.c,v 1.30 2015/11/25 03:09:57 dlg Exp $ */
d981 2
a1002 5
		if ((bd.flags & (CPDMA_BD_SOP|CPDMA_BD_EOP)) !=
		    (CPDMA_BD_SOP|CPDMA_BD_EOP)) {
			/* Debugger(); */
		}

a1004 1
		bus_dmamap_unload(sc->sc_bdt, dm);
d1012 10
d1037 1
a1037 3
			break;
		} else {
			sc->sc_rxeoq = false;
d1044 4
a1047 2
		printf("rxeoq\n");
		/* Debugger(); */
@


1.30
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_cpsw.c,v 1.29 2015/11/12 10:23:08 dlg Exp $ */
d938 1
a938 1
	ifp->if_flags &= ~IFF_RUNNING);
@


1.29
log
@get rid of IFQ_POLL.

IFQ_POLL(&ifp->if_snd, m);
if (m == NULL)
	return;
IFQ_DEQUEUE(&ifp->if_snd, m);

is the same as

IFQ_DEQUEUE(&ifp->if_snd, m);
if (m == NULL)
	return;

ok mpi@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_cpsw.c,v 1.28 2015/10/27 15:07:56 mpi Exp $ */
d453 1
a453 1
	    ISSET(ifp->if_flags, IFF_OACTIVE) ||
d464 1
a464 1
			SET(ifp->if_flags, IFF_OACTIVE);
d870 1
a870 1
	ifp->if_flags &= ~IFF_OACTIVE;
d938 1
a938 1
	ifp->if_flags &= ~(IFF_RUNNING|IFF_OACTIVE);
d940 1
d1126 1
a1126 1
		ifp->if_flags &= ~IFF_OACTIVE;
@


1.28
log
@arp_ifinit() is no longer needed.
@
text
@d1 1
a1 1
/* $OpenBSD: if_cpsw.c,v 1.27 2015/08/25 13:13:12 bmercer Exp $ */
d468 1
a468 1
		IFQ_POLL(&ifp->if_snd, m);
a470 2

		IFQ_DEQUEUE(&ifp->if_snd, m);
@


1.27
log
@Put the device name into the timeout message. OK jsg@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_cpsw.c,v 1.26 2015/06/24 09:40:53 mpi Exp $ */
a569 1
	struct ifaddr *ifa = (struct ifaddr *)data;
d577 1
a577 3
		if (ifa->ifa_addr->sa_family == AF_INET)
			arp_ifinit(&sc->sc_ac, ifa);

@


1.26
log
@Increment if_ipackets in if_input().

Note that pseudo-drivers not using if_input() are not affected by this
conversion.

ok mikeb@@, kettenis@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_cpsw.c,v 1.25 2015/03/16 16:21:21 mpi Exp $ */
d616 1
a616 1
	printf("device timeout\n");
@


1.25
log
@Convert to if_input(), tested by jsg@@.
@
text
@d1 1
a1 1
/* $OpenBSD: if_cpsw.c,v 1.24 2014/12/22 02:26:53 tedu Exp $ */
a1027 2

		ifp->if_ipackets++;
@


1.24
log
@unifdef INET
@
text
@d1 1
a1 1
/* $OpenBSD: if_cpsw.c,v 1.23 2014/08/18 17:56:45 miod Exp $ */
d980 1
d1002 1
a1002 1
			return 1;
a1025 1
		m->m_pkthdr.rcvif = ifp;
d1031 1
a1031 5
#if NBPFILTER > 0
		if (ifp->if_bpf)
			bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_IN);
#endif
		ether_input_mbuf(ifp, m);
d1050 5
a1054 1
	bus_space_write_4(sc->sc_bst, sc->sc_bsh, CPSW_CPDMA_CPDMA_EOI_VECTOR, CPSW_INTROFF_RX);
@


1.23
log
@Explicitely need <sys/pool.h> now.
@
text
@d1 1
a1 1
/* $OpenBSD: if_cpsw.c,v 1.22 2014/05/06 14:44:08 jasper Exp $ */
a577 1
#ifdef INET
a579 1
#endif
@


1.22
log
@remove cpsw_{read,write}_4 wrapper functions and just use the real
bus_space_{read,write}_4 instead.

tested by nick@@, ok bmercer@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_cpsw.c,v 1.21 2013/11/26 20:33:11 deraadt Exp $ */
d62 1
@


1.21
log
@1 << 31 cleanup.  Eitan Adler pointed out that there has been a
resurrection of the bad idiom in the tree.
sufficient review by miod, kettenis, tedu
@
text
@d1 1
a1 1
/* $OpenBSD: if_cpsw.c,v 1.20 2013/11/15 14:31:52 fgsch Exp $ */
a202 13
static inline uint32_t
cpsw_read_4(struct cpsw_softc * const sc, bus_size_t const offset)
{
	return bus_space_read_4(sc->sc_bst, sc->sc_bsh, offset);
}

static inline void
cpsw_write_4(struct cpsw_softc * const sc, bus_size_t const offset,
    uint32_t const value)
{
	bus_space_write_4(sc->sc_bst, sc->sc_bsh, offset, value);
}

d371 1
a371 1
	idver = cpsw_read_4(sc, CPSW_SS_IDVER);
d559 1
a559 1
			cpsw_write_4(sc, CPSW_CPDMA_TX_HDP(0),
d630 1
a630 1
		if ((cpsw_read_4(sc, reg) & (1U << 31)) == 0)
d646 1
a646 1
	cpsw_write_4(sc, MDIOUSERACCESS0, (1U << 31) |
d652 1
a652 1
	v = cpsw_read_4(sc, MDIOUSERACCESS0);
d670 1
a670 1
	cpsw_write_4(sc, MDIOUSERACCESS0, (1U << 31) | (1 << 30) |
d676 1
a676 1
	v = cpsw_read_4(sc, MDIOUSERACCESS0);
d759 2
a760 2
	cpsw_write_4(sc, CPSW_WR_SOFT_RESET, 1);
	while(cpsw_read_4(sc, CPSW_WR_SOFT_RESET) & 1);
d763 2
a764 2
	cpsw_write_4(sc, CPSW_SS_SOFT_RESET, 1);
	while(cpsw_read_4(sc, CPSW_SS_SOFT_RESET) & 1);
d767 1
a767 1
	cpsw_write_4(sc, CPSW_ALE_CONTROL, (3 << 30) | 0x10);
d772 2
a773 2
		cpsw_write_4(sc, CPSW_SL_SOFT_RESET(i), 1);
		while(cpsw_read_4(sc, CPSW_SL_SOFT_RESET(i)) & 1);
d775 3
a777 3
		cpsw_write_4(sc, CPSW_SL_RX_PRI_MAP(i), 0x76543210);
		cpsw_write_4(sc, CPSW_PORT_P_TX_PRI_MAP(i+1), 0x33221100);
		cpsw_write_4(sc, CPSW_SL_RX_MAXLEN(i), 0x5f2);
d779 1
a779 1
		cpsw_write_4(sc, CPSW_PORT_P_SA_HI(i+1),
d782 1
a782 1
		cpsw_write_4(sc, CPSW_PORT_P_SA_LO(i+1),
d787 1
a787 1
		cpsw_write_4(sc, CPSW_SL_MACCONTROL(i),
d791 1
a791 1
		cpsw_write_4(sc, CPSW_ALE_PORTCTL(i+1), 3);
d795 2
a796 2
	cpsw_write_4(sc, CPSW_PORT_P0_CPDMA_TX_PRI_MAP, 0x76543210);
	cpsw_write_4(sc, CPSW_PORT_P0_CPDMA_RX_CH_MAP, 0);
d799 1
a799 1
	cpsw_write_4(sc, CPSW_ALE_PORTCTL(0), 3);
d801 2
a802 2
	cpsw_write_4(sc, CPSW_SS_PTYPE, 0);
	cpsw_write_4(sc, CPSW_SS_STAT_PORT_EN, 7);
d804 2
a805 2
	cpsw_write_4(sc, CPSW_CPDMA_SOFT_RESET, 1);
	while(cpsw_read_4(sc, CPSW_CPDMA_SOFT_RESET) & 1);
d808 4
a811 4
		cpsw_write_4(sc, CPSW_CPDMA_TX_HDP(i), 0);
		cpsw_write_4(sc, CPSW_CPDMA_RX_HDP(i), 0);
		cpsw_write_4(sc, CPSW_CPDMA_TX_CP(i), 0);
		cpsw_write_4(sc, CPSW_CPDMA_RX_CP(i), 0);
d820 1
a820 1
	cpsw_write_4(sc, CPSW_CPDMA_RX_FREEBUFFER(0), 0);
d833 1
a833 1
	cpsw_write_4(sc, CPSW_CPDMA_RX_BUFFER_OFFSET, ETHER_ALIGN);
d836 2
a837 2
	cpsw_write_4(sc, CPSW_CPDMA_RX_INTMASK_CLEAR, 0xFFFFFFFF);
	cpsw_write_4(sc, CPSW_CPDMA_TX_INTMASK_CLEAR, 0xFFFFFFFF);
d840 2
a841 2
	cpsw_write_4(sc, CPSW_CPDMA_TX_CONTROL, 1);
	cpsw_write_4(sc, CPSW_CPDMA_RX_CONTROL, 1);
d844 3
a846 3
	cpsw_write_4(sc, CPSW_WR_C_TX_EN(0), 1);
	cpsw_write_4(sc, CPSW_WR_C_RX_EN(0), 1);
	cpsw_write_4(sc, CPSW_WR_C_MISC_EN(0), 0x1F);
d849 1
a849 1
	cpsw_write_4(sc, CPSW_CPDMA_DMA_INTMASK_SET, 2);
d852 2
a853 2
	cpsw_write_4(sc, CPSW_CPDMA_TX_INTMASK_SET, 1);
	cpsw_write_4(sc, CPSW_CPDMA_RX_INTMASK_SET, 1);
d856 4
a859 4
	cpsw_write_4(sc, CPSW_CPDMA_CPDMA_EOI_VECTOR, CPSW_INTROFF_RXTH);
	cpsw_write_4(sc, CPSW_CPDMA_CPDMA_EOI_VECTOR, CPSW_INTROFF_RX);
	cpsw_write_4(sc, CPSW_CPDMA_CPDMA_EOI_VECTOR, CPSW_INTROFF_TX);
	cpsw_write_4(sc, CPSW_CPDMA_CPDMA_EOI_VECTOR, CPSW_INTROFF_MISC);
d863 1
a863 1
	cpsw_write_4(sc, MDIOCONTROL, (1<<30) | (1<<18) | 0xFF);
d868 1
a868 1
	cpsw_write_4(sc, CPSW_CPDMA_RX_HDP(0), cpsw_rxdesc_paddr(sc, 0));
d901 5
a905 5
	cpsw_write_4(sc, CPSW_CPDMA_TX_INTMASK_CLEAR, 1);
	cpsw_write_4(sc, CPSW_CPDMA_RX_INTMASK_CLEAR, 1);
	cpsw_write_4(sc, CPSW_WR_C_TX_EN(0), 0x0);
	cpsw_write_4(sc, CPSW_WR_C_RX_EN(0), 0x0);
	cpsw_write_4(sc, CPSW_WR_C_MISC_EN(0), 0x1F);
d907 2
a908 2
	cpsw_write_4(sc, CPSW_CPDMA_TX_TEARDOWN, 0);
	cpsw_write_4(sc, CPSW_CPDMA_RX_TEARDOWN, 0);
d921 2
a922 2
	cpsw_write_4(sc, CPSW_WR_SOFT_RESET, 1);
	while(cpsw_read_4(sc, CPSW_WR_SOFT_RESET) & 1);
d925 2
a926 2
	cpsw_write_4(sc, CPSW_SS_SOFT_RESET, 1);
	while(cpsw_read_4(sc, CPSW_SS_SOFT_RESET) & 1);
d929 2
a930 2
		cpsw_write_4(sc, CPSW_SL_SOFT_RESET(i), 1);
		while(cpsw_read_4(sc, CPSW_SL_SOFT_RESET(i)) & 1);
d934 2
a935 2
	cpsw_write_4(sc, CPSW_CPDMA_SOFT_RESET, 1);
	while(cpsw_read_4(sc, CPSW_CPDMA_SOFT_RESET) & 1);
d968 1
a968 1
	cpsw_write_4(sc, CPSW_CPDMA_CPDMA_EOI_VECTOR, CPSW_INTROFF_RXTH);
d1046 1
a1046 1
		cpsw_write_4(sc, CPSW_CPDMA_RX_CP(0),
d1055 1
a1055 1
	cpsw_write_4(sc, CPSW_CPDMA_CPDMA_EOI_VECTOR, CPSW_INTROFF_RX);
d1086 1
a1086 1
	tx0_cp = cpsw_read_4(sc, CPSW_CPDMA_TX_CP(0));
d1089 2
a1090 2
		cpsw_write_4(sc, CPSW_CPDMA_TX_CP(0), 0xfffffffc);
		cpsw_write_4(sc, CPSW_CPDMA_TX_HDP(0), 0);
d1096 1
a1096 1
		tx0_cp = cpsw_read_4(sc, CPSW_CPDMA_TX_CP(0));
d1141 1
a1141 1
			cpsw_write_4(sc, CPSW_CPDMA_TX_CP(0),
d1151 1
a1151 1
	cpsw_write_4(sc, CPSW_CPDMA_CPDMA_EOI_VECTOR, CPSW_INTROFF_TX);
d1154 1
a1154 1
		if (cpsw_read_4(sc, CPSW_CPDMA_TX_HDP(0)) == 0) {
d1156 1
a1156 1
			cpsw_write_4(sc, CPSW_CPDMA_TX_HDP(0),
d1178 1
a1178 1
	miscstat = cpsw_read_4(sc, CPSW_WR_C_MISC_STAT(0));
d1183 1
a1183 1
		dmastat = cpsw_read_4(sc, CPSW_CPDMA_DMA_INTSTAT_MASKED);
d1188 1
a1188 1
		stat = cpsw_read_4(sc, CPSW_CPDMA_DMASTATUS);
d1190 1
a1190 1
		stat = cpsw_read_4(sc, CPSW_CPDMA_TX_HDP(0));
d1192 1
a1192 1
		stat = cpsw_read_4(sc, CPSW_CPDMA_TX_CP(0));
d1194 1
a1194 1
		stat = cpsw_read_4(sc, CPSW_CPDMA_RX_HDP(0));
d1196 1
a1196 1
		stat = cpsw_read_4(sc, CPSW_CPDMA_RX_CP(0));
d1201 2
a1202 2
		cpsw_write_4(sc, CPSW_CPDMA_DMA_INTMASK_CLEAR, dmastat);
		dmastat = cpsw_read_4(sc, CPSW_CPDMA_DMA_INTSTAT_MASKED);
d1206 1
a1206 1
	cpsw_write_4(sc, CPSW_CPDMA_CPDMA_EOI_VECTOR, CPSW_INTROFF_MISC);
@


1.20
log
@Start cleaning this driver. No functional change.
input and ok to move forward dlg@@ patrick@@ syl@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_cpsw.c,v 1.19 2013/11/06 19:03:07 syl Exp $ */
d643 1
a643 1
		if ((cpsw_read_4(sc, reg) & (1 << 31)) == 0)
d659 1
a659 1
	cpsw_write_4(sc, MDIOUSERACCESS0, (1 << 31) |
d683 1
a683 1
	cpsw_write_4(sc, MDIOUSERACCESS0, (1 << 31) | (1 << 30) |
@


1.19
log
@After factorizing armv7_machdep code here is an effort to factorize all
the code present in omap/omap.c imx/imx.c and sunxi/sunxi.c

All this code looks quite the same, so we move it in a generic armv7/armv7.c

This is a step closer to only one kernel for all armv7 boards.

ok patrick@@, rapha@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_cpsw.c,v 1.18 2013/09/12 10:28:03 dlg Exp $ */
a110 13
/* __BIT(n): nth bit, where __BIT(0) == 0x1. */
#define __BIT(__n) \
    (((uint32_t)(__n) >= NBBY * sizeof(uint32_t)) ? 0 : ((uint32_t)1 << (uint32_t)(__n)))

/* __BITS(m, n): bits m through n, m < n. */
#define __BITS(__m, __n) \
    ((__BIT(MAX((__m), (__n)) + 1) - 1) ^ (__BIT(MIN((__m), (__n))) - 1))

/* find least significant bit that is set */
#define __LOWEST_SET_BIT(__mask) ((((__mask) - 1) & (__mask)) ^ (__mask))

#define __SHIFTOUT(__x, __mask) (((__x) & (__mask)) / __LOWEST_SET_BIT(__mask))

d235 2
a236 4
	uint32_t * const dp = bdp->word;
	const bus_size_t c = nitems(bdp->word);

	bus_space_read_region_4(sc->sc_bst, sc->sc_bsh_txdescs, o, dp, c);
d244 2
a245 4
	uint32_t * const dp = bdp->word;
	const bus_size_t c = nitems(bdp->word);

	bus_space_write_region_4(sc->sc_bst, sc->sc_bsh_txdescs, o, dp, c);
d253 2
a254 4
	uint32_t * const dp = bdp->word;
	const bus_size_t c = nitems(bdp->word);

	bus_space_read_region_4(sc->sc_bst, sc->sc_bsh_rxdescs, o, dp, c);
d262 2
a263 4
	uint32_t * const dp = bdp->word;
	const bus_size_t c = nitems(bdp->word);

	bus_space_write_region_4(sc->sc_bst, sc->sc_bsh_rxdescs, o, dp, c);
a453 1
	uint32_t * const dw = bd.word;
a455 1
	u_int sopi;	/* Start of Packet Index */
d521 1
a521 1
		sopi = eopi = sc->sc_txnext;
d523 1
a523 1
			dw[0] = cpsw_txdesc_paddr(sc,
d525 10
a534 7
			dw[1] = dm->dm_segs[seg].ds_addr;
			dw[2] = dm->dm_segs[seg].ds_len;
			dw[3] = 0;

			if (seg == 0)
				dw[3] |= CPDMA_BD_SOP | CPDMA_BD_OWNER |
				    MAX(mlen, CPSW_PAD_LEN);
d537 1
a537 1
				dw[3] |= CPDMA_BD_EOP;
d545 1
a545 1
			dw[0] = cpsw_txdesc_paddr(sc,
d547 5
a551 3
			dw[1] = sc->sc_txpad_pa;
			dw[2] = CPSW_PAD_LEN - mlen;
			dw[3] = CPDMA_BD_EOP;
d643 1
a643 1
		if ((cpsw_read_4(sc, reg) & __BIT(31)) == 0)
d666 1
a666 1
	if (v & __BIT(29))
d690 1
a690 1
	if ((v & __BIT(29)) == 0)
a707 1
	uint32_t * const dw = bd.word;
d744 6
a749 4
	dw[0] = 0;
	dw[1] = rdp->rx_dm[i]->dm_segs[0].ds_addr;
	dw[2] = MIN(0x7ff, rdp->rx_dm[i]->dm_segs[0].ds_len);
	dw[3] = CPDMA_BD_OWNER;
a992 1
	const uint32_t * const dw = bd.word;
d1010 1
a1010 1
		if (ISSET(dw[3], CPDMA_BD_OWNER))
d1013 1
a1013 1
		if (ISSET(dw[3], CPDMA_BD_TDOWNCMPLT)) {
d1018 1
a1018 1
		if ((dw[3] & (CPDMA_BD_SOP|CPDMA_BD_EOP)) !=
d1033 2
a1034 2
		off = __SHIFTOUT(dw[2], (uint32_t)__BITS(26, 16));
		len = __SHIFTOUT(dw[3], (uint32_t)__BITS(10,  0));
d1036 1
a1036 1
		if (ISSET(dw[3], CPDMA_BD_PASSCRC))
d1053 1
a1053 1
		if (ISSET(dw[3], CPDMA_BD_EOQ)) {
a1092 1
	const uint32_t * const dw = bd.word;
a1107 2
	cpi = (tx0_cp - sc->sc_txdescs_pa) / sizeof(struct cpsw_cpdma_bd);

d1116 1
a1116 1
		if (dw[2] == 0) {
d1120 1
a1120 1
		if (ISSET(dw[3], CPDMA_BD_SOP) == 0)
d1123 1
a1123 1
		if (ISSET(dw[3], CPDMA_BD_OWNER)) {
d1129 1
a1129 1
		if (ISSET(dw[3], CPDMA_BD_TDOWNCMPLT)) {
d1149 2
a1150 1
		if (ISSET(dw[3], CPDMA_BD_EOP) && ISSET(dw[3], CPDMA_BD_EOQ)) {
d1152 1
a1152 1
		}
d1160 1
a1160 2
		if (ISSET(dw[3], CPDMA_BD_EOP) && ISSET(dw[3], CPDMA_BD_EOQ)) {
			sc->sc_txeoq = true;
a1161 1
		}
d1194 1
a1194 4
#define CPSW_MISC_HOST_PEND __BIT32(2)
#define CPSW_MISC_STAT_PEND __BIT32(3)

	if (ISSET(miscstat, CPSW_MISC_HOST_PEND)) {
@


1.18
log
@add a missing bus_dmamap_unload in the rx completion path.
@
text
@d1 1
a1 1
/* $OpenBSD: if_cpsw.c,v 1.17 2013/09/12 04:42:03 dlg Exp $ */
d83 1
a83 1
#include <arch/armv7/omap/omapvar.h>
d326 1
a326 1
	struct omap_attach_args *oa = aux;
d337 1
a337 1
	sc->sc_rxthih = arm_intr_establish(oa->oa_dev->irq[0] +
d339 1
a339 1
	sc->sc_rxih = arm_intr_establish(oa->oa_dev->irq[0] +
d341 1
a341 1
	sc->sc_txih = arm_intr_establish(oa->oa_dev->irq[0] +
d343 1
a343 1
	sc->sc_miscih = arm_intr_establish(oa->oa_dev->irq[0] +
d346 2
a347 2
	sc->sc_bst = oa->oa_iot;
	sc->sc_bdt = oa->oa_dmat;
d349 2
a350 2
	error = bus_space_map(sc->sc_bst, oa->oa_dev->mem[0].addr,
	    oa->oa_dev->mem[0].size, 0, &sc->sc_bsh);
d356 1
a356 1
	sc->sc_txdescs_pa = oa->oa_dev->mem[0].addr +
d366 1
a366 1
	sc->sc_rxdescs_pa = oa->oa_dev->mem[0].addr +
@


1.17
log
@allocate the pad for the short ethernet frames with dma_alloc instead of
malloc. shouldnt make a difference on this platform, but is more correct.
@
text
@d1 1
a1 1
/* $OpenBSD: if_cpsw.c,v 1.16 2013/09/12 04:23:28 dlg Exp $ */
d1043 1
@


1.16
log
@print version on attach
@
text
@d1 1
a1 1
/* $OpenBSD: if_cpsw.c,v 1.15 2013/09/12 03:09:34 dlg Exp $ */
d396 1
a396 4
	/* XXX Not sure if this is the correct way to do this. orig below.
	    sc->sc_txpad = kmem_zalloc(ETHER_MIN_LEN, KM_SLEEP);
	*/
	sc->sc_txpad = malloc(ETHER_MIN_LEN, M_TEMP, M_WAITOK);
@


1.15
log
@use the amount of memory that was mapped to set the length of the packet
in the descriptors rather than a cribbed version of m_length().
@
text
@d1 1
a1 1
/* $OpenBSD: if_cpsw.c,v 1.13 2013/09/12 02:20:17 dlg Exp $ */
d329 1
d408 4
a411 1
	printf(": address %s\n", ether_sprintf(ac->ac_enaddr));
@


1.14
log
@get rid of unused macros
@
text
@a203 18
/*
 * Return the number of bytes in the mbuf chain, m.
 */
static __inline u_int
m_length(const struct mbuf *m)
{
	const struct mbuf *m0;
	u_int pktlen;

	if ((m->m_flags & M_PKTHDR) != 0)
		return m->m_pkthdr.len;

	pktlen = 0;
	for (m0 = m; m0 != NULL; m0 = m0->m_next)
		pktlen += m0->m_len;
	return pktlen;
}

d527 1
a527 1
		mlen = m_length(m);
@


1.13
log
@dont print out where the rx and tx descs are. noone cares.
@
text
@d1 1
a1 1
/* $OpenBSD: if_cpsw.c,v 1.12 2013/09/12 01:44:14 dlg Exp $ */
a120 6

#define __PRIuBIT	PRIuMAX
#define __PRIuBITS	__PRIuBIT

#define __PRIxBIT	PRIxMAX
#define __PRIxBITS	__PRIxBIT
@


1.12
log
@rearrange cpsw_start() a bit.

- cope with errors more consistently, which will avoid us leaking
  mbufs in failure paths.
- use m_defrag when we get EFBIG back from bus_dmamap_load_mbuf
  rather than printf and lose.
- shuffle some ops to be more like other drivers we have.
@
text
@d1 1
a1 1
/* $OpenBSD: if_cpsw.c,v 1.11 2013/09/12 01:13:10 dlg Exp $ */
a387 1
	printf(" txdescs at %p", (void *)sc->sc_bsh_txdescs);
a397 1
	printf(" rxdescs at %p", (void *)sc->sc_bsh_rxdescs);
d431 1
a431 1
	printf(", address %s\n", ether_sprintf(ac->ac_enaddr));
@


1.11
log
@sc_ih is unused.
@
text
@d1 1
a1 1
/* $OpenBSD: if_cpsw.c,v 1.10 2013/09/12 01:11:15 dlg Exp $ */
d512 3
a514 2
	if (__predict_false((ifp->if_flags & (IFF_RUNNING|IFF_OACTIVE)) !=
	    IFF_RUNNING)) {
a515 1
	}
d522 6
a527 1
	while (txfree > 0) {
d532 2
d535 10
d546 2
a547 4
		error = bus_dmamap_load_mbuf(sc->sc_bdt, dm, m, BUS_DMA_NOWAIT);
		if (error == EFBIG) {
			printf("won't fit\n");
			IFQ_DEQUEUE(&ifp->if_snd, m);
a550 9
		} else if (error != 0) {
			printf("error\n");
			break;
		}

		if (dm->dm_nsegs + 1 >= txfree) {
			ifp->if_flags |= IFF_OACTIVE;
			bus_dmamap_unload(sc->sc_bdt, dm);
			break;
d558 5
a562 1
		IFQ_DEQUEUE(&ifp->if_snd, m);
a600 4
#if NBPFILTER > 0
		if (ifp->if_bpf)
			bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_OUT);
#endif
@


1.10
log
@more consistent whitespace for structs and function prototypes.
@
text
@d1 1
a1 1
/* $OpenBSD: if_cpsw.c,v 1.9 2013/09/12 01:02:21 dlg Exp $ */
a149 1
	void			*sc_ih;
@


1.9
log
@wrap some long lines better.
@
text
@d1 1
a1 1
/* $OpenBSD: if_cpsw.c,v 1.7 2013/09/12 00:14:57 dlg Exp $ */
d131 4
a134 4
	bus_dmamap_t tx_dm[CPSW_NTXDESCS];
	struct mbuf *tx_mb[CPSW_NTXDESCS];
	bus_dmamap_t rx_dm[CPSW_NRXDESCS];
	struct mbuf *rx_mb[CPSW_NRXDESCS];
d138 25
a162 21
	struct device  sc_dev;
	bus_space_tag_t sc_bst;
	bus_space_handle_t sc_bsh;
	bus_dma_tag_t sc_bdt;
	bus_space_handle_t sc_bsh_txdescs;
	bus_space_handle_t sc_bsh_rxdescs;
	bus_addr_t sc_txdescs_pa;
	bus_addr_t sc_rxdescs_pa;
	struct arpcom sc_ac;
	struct mii_data sc_mii;
	void *sc_ih;
	struct cpsw_ring_data *sc_rdp;
	volatile u_int sc_txnext;
	volatile u_int sc_txhead;
	volatile u_int sc_rxhead;
	void *sc_rxthih;
	void *sc_rxih;
	void *sc_txih;
	void *sc_miscih;
	void *sc_txpad;
	bus_dmamap_t sc_txpad_dm;
d164 6
a169 5
	volatile bool sc_txrun;
	volatile bool sc_rxrun;
	volatile bool sc_txeoq;
	volatile bool sc_rxeoq;
	struct timeout sc_tick;
d174 1
a174 2
void	cpsw_get_mac_addr(struct cpsw_softc *);
void cpsw_attach(struct device *, struct device *, void *);
d176 5
a180 5
void cpsw_start(struct ifnet *);
int cpsw_ioctl(struct ifnet *, u_long, caddr_t);
void cpsw_watchdog(struct ifnet *);
int cpsw_init(struct ifnet *);
void cpsw_stop(struct ifnet *);
d182 3
a184 3
int cpsw_mii_readreg(struct device *, int, int);
void cpsw_mii_writereg(struct device *, int, int, int);
void cpsw_mii_statchg(struct device *);
d186 1
a186 1
void cpsw_tick(void *);
d188 1
a188 1
int cpsw_new_rxbuf(struct cpsw_softc * const, const u_int);
d192 6
a197 4
int cpsw_rxthintr(void *);
int cpsw_rxintr(void *);
int cpsw_txintr(void *);
int cpsw_miscintr(void *);
d212 2
a213 2
 *  * Return the number of bytes in the mbuf chain, m.
 *   */
@


1.8
log
@get rid of CPSW_PRINTF
@
text
@d355 8
a362 8
	sc->sc_rxthih = arm_intr_establish(oa->oa_dev->irq[0] + CPSW_INTROFF_RXTH,
	    IPL_NET, cpsw_rxthintr, sc, DEVNAME(sc));
	sc->sc_rxih = arm_intr_establish(oa->oa_dev->irq[0] + CPSW_INTROFF_RX,
	    IPL_NET, cpsw_rxintr, sc, DEVNAME(sc));
	sc->sc_txih = arm_intr_establish(oa->oa_dev->irq[0] + CPSW_INTROFF_TX,
	    IPL_NET, cpsw_txintr, sc, DEVNAME(sc));
	sc->sc_miscih = arm_intr_establish(oa->oa_dev->irq[0] + CPSW_INTROFF_MISC,
	    IPL_NET, cpsw_miscintr, sc, DEVNAME(sc));
d367 2
a368 2
	error = bus_space_map(sc->sc_bst, oa->oa_dev->mem[0].addr, oa->oa_dev->mem[0].size, 0,
	    &sc->sc_bsh);
d374 2
a375 1
	sc->sc_txdescs_pa = oa->oa_dev->mem[0].addr + CPSW_CPPI_RAM_TXDESCS_BASE;
d385 2
a386 1
	sc->sc_rxdescs_pa = oa->oa_dev->mem[0].addr + CPSW_CPPI_RAM_RXDESCS_BASE;
d449 2
a450 1
	mii_attach(self, &sc->sc_mii, 0xffffffff, MII_PHY_ANY, MII_OFFSET_ANY, 0);
d831 2
a832 1
		cpsw_write_4(sc, CPSW_SL_MACCONTROL(i), 1 | (1<<5) | (1<<15) | (1<<16));
d1144 2
a1145 1
		cpi = (tx0_cp - sc->sc_txdescs_pa) / sizeof(struct cpsw_cpdma_bd);
a1147 1

d1158 2
a1159 1
			printf("pwned %x %x %x\n", cpi, sc->sc_txhead, sc->sc_txnext);
@


1.7
log
@get rid of sc->sc_enaddr and only use sc->sc_ac.ac_enaddr to store
the mac address. this should also make it possible to have ifconfig
set the mac address.
@
text
@d1 1
a1 1
/* $OpenBSD: if_cpsw.c,v 1.4 2013/09/11 23:40:15 dlg Exp $ */
d329 3
a331 4
	if ((mac_lo == 0) && (mac_hi == 0)) {
		CPSW_PRINTF(sc, "%s(%d): Invalid Ethernet address!\n",
		    __FILE__, __LINE__);
	} else {
@


1.6
log
@#define DEVNAME(_sc) ((_sc)->sc_dev.dv_xname)
@
text
@a159 1
	uint8_t sc_enaddr[ETHER_ADDR_LEN];
d323 1
d333 6
a338 6
			sc->sc_enaddr[0] = (mac_hi >>  0) & 0xff;
			sc->sc_enaddr[1] = (mac_hi >>  8) & 0xff;
			sc->sc_enaddr[2] = (mac_hi >> 16) & 0xff;
			sc->sc_enaddr[3] = (mac_hi >> 24) & 0xff;
			sc->sc_enaddr[4] = (mac_lo >>  0) & 0xff;
			sc->sc_enaddr[5] = (mac_lo >>  8) & 0xff;
d427 1
a427 1
	printf(", address %s\n", ether_sprintf(sc->sc_enaddr));
a457 1
	memcpy(sc->sc_ac.ac_enaddr, sc->sc_enaddr, ETHER_ADDR_LEN);
d791 1
d822 2
a823 2
		    sc->sc_enaddr[0] | (sc->sc_enaddr[1] << 8) |
		    (sc->sc_enaddr[2] << 16) | (sc->sc_enaddr[3] << 24));
d825 1
a825 1
		    sc->sc_enaddr[4] | (sc->sc_enaddr[5] << 8));
@


1.5
log
@remove some #if 0 that was being used as a model for intr establishment.
@
text
@d168 2
d357 1
a357 1
	    IPL_NET, cpsw_rxthintr, sc, sc->sc_dev.dv_xname);
d359 1
a359 1
	    IPL_NET, cpsw_rxintr, sc, sc->sc_dev.dv_xname);
d361 1
a361 1
	    IPL_NET, cpsw_txintr, sc, sc->sc_dev.dv_xname);
d363 1
a363 1
	    IPL_NET, cpsw_miscintr, sc, sc->sc_dev.dv_xname);
d437 1
a437 1
	memcpy(ifp->if_xname, sc->sc_dev.dv_xname, IFNAMSIZ);
@


1.4
log
@some whitespace fixes, spaces to tabs mostly
@
text
@d1 1
a1 1
/* $OpenBSD: if_cpsw.c,v 1.3 2013/09/11 23:34:50 dlg Exp $ */
a353 10
#if 0
	/* XXX Start here, we need to setup the interrupt properly */
	sc->sc_ihc0 = arm_intr_establish(aa->aa_intr, IPL_USB,
	    ohci_intr, &sc->sc, sc->sc.sc_bus.bdev.dv_xname);
	 	int irqno,
	 	int level,
	 	int (*func)(void *),
	 	void *cookie,
	 	char *name;
#endif
@


1.3
log
@rename sc_ec in the softc to sc_ac, like all our other drivers.
@
text
@d1 1
a1 1
/* $OpenBSD: if_cpsw.c,v 1.2 2013/09/11 23:20:03 dlg Exp $ */
d112 1
a112 1
#define __BIT(__n)      \
d116 2
a117 2
#define __BITS(__m, __n)        \
        ((__BIT(MAX((__m), (__n)) + 1) - 1) ^ (__BIT(MIN((__m), (__n))) - 1))
d122 2
a123 2
#define __PRIuBIT       PRIuMAX
#define __PRIuBITS      __PRIuBIT
d125 2
a126 2
#define __PRIxBIT       PRIxMAX
#define __PRIxBITS      __PRIxBIT
d193 3
a195 1
        sizeof (struct cpsw_softc), NULL, cpsw_attach
d199 3
a201 1
        NULL, "cpsw", DV_IFNET
d210 2
a211 2
        const struct mbuf *m0;
        u_int pktlen;
d213 2
a214 2
        if ((m->m_flags & M_PKTHDR) != 0)
                return m->m_pkthdr.len;
d216 4
a219 4
        pktlen = 0;
        for (m0 = m; m0 != NULL; m0 = m0->m_next)
                pktlen += m0->m_len;
        return pktlen;
d356 6
a361 6
        sc->sc_ihc0 = arm_intr_establish(aa->aa_intr, IPL_USB,
            ohci_intr, &sc->sc, sc->sc.sc_bus.bdev.dv_xname);
	 	int irqno, 
	 	int level, 
	 	int (*func)(void *), 
	 	void *cookie, 
d364 1
a364 1
	sc->sc_rxthih = arm_intr_establish(oa->oa_dev->irq[0] + CPSW_INTROFF_RXTH, 
d487 1
a487 1
        struct cpsw_softc *sc = ifp->if_softc;
d490 3
a492 3
        	mii_pollstat(&sc->sc_mii);
        	ifmr->ifm_active = sc->sc_mii.mii_media_active;
        	ifmr->ifm_status = sc->sc_mii.mii_media_status;
@


1.2
log
@the sc_name member of cpsw_softc is unused, so remove it.
@
text
@d1 1
a1 1
/* $OpenBSD: if_cpsw.c,v 1.1 2013/09/04 14:38:30 patrick Exp $ */
d146 1
a146 1
	struct arpcom sc_ec;
d341 2
a342 2
	struct arpcom * const ec = &sc->sc_ec;
	struct ifnet * const ifp = &ec->ac_if;
a449 3
#if 0
	sc->sc_ec.ec_mii = &sc->sc_mii;
#endif
d462 1
a462 1
	memcpy(sc->sc_ec.ac_enaddr, sc->sc_enaddr, ETHER_ADDR_LEN);
d627 1
a627 1
			arp_ifinit(&sc->sc_ec, ifa);
d648 1
a648 1
		error = ether_ioctl(ifp, &sc->sc_ec, cmd, data);
d1022 1
a1022 1
	struct ifnet * const ifp = &sc->sc_ec.ac_if;
d1122 1
a1122 1
	struct ifnet * const ifp = &sc->sc_ec.ac_if;
@


1.1
log
@In the future, we shouldn't have one port port ARM SoC, that's just
ridiculous.  This is the first step for a common and generic ARM port
for ARMv7 SoCs.
@
text
@d1 1
a1 1
/* $OpenBSD: if_cpsw.c,v 1.5 2013/07/15 17:30:22 rapha Exp $ */
a138 1
	const char sc_name;
@

