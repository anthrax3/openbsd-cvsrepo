head	1.31;
access;
symbols
	OPENBSD_6_1:1.31.0.4
	OPENBSD_6_1_BASE:1.31
	OPENBSD_6_0:1.26.0.2
	OPENBSD_6_0_BASE:1.26
	OPENBSD_5_9:1.15.0.2
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.14.0.4
	OPENBSD_5_8_BASE:1.14
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.12.0.6
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.12.0.4
	OPENBSD_5_5_BASE:1.12;
locks; strict;
comment	@ * @;


1.31
date	2017.01.21.05.42.03;	author guenther;	state Exp;
branches;
next	1.30;
commitid	CHRb0fCqa8XxUAMH;

1.30
date	2016.10.08.03.42.20;	author jsg;	state Exp;
branches;
next	1.29;
commitid	kbq2iz3Fzl2PIvr0;

1.29
date	2016.08.12.03.22.41;	author jsg;	state Exp;
branches;
next	1.28;
commitid	HjeMmhWIXnaMRjR3;

1.28
date	2016.08.06.10.07.45;	author jsg;	state Exp;
branches;
next	1.27;
commitid	tIvsLgDtJFao46i9;

1.27
date	2016.07.27.11.45.02;	author patrick;	state Exp;
branches;
next	1.26;
commitid	yc14meyJgxIAcvAg;

1.26
date	2016.07.17.02.45.05;	author jsg;	state Exp;
branches;
next	1.25;
commitid	j81PfDWuSi4hn2JG;

1.25
date	2016.07.15.22.28.25;	author tom;	state Exp;
branches;
next	1.24;
commitid	0i9Cnw8CMZ9dPro7;

1.24
date	2016.06.18.09.59.35;	author jsg;	state Exp;
branches;
next	1.23;
commitid	s8XeyuseMFPWkGbd;

1.23
date	2016.06.18.05.59.26;	author jsg;	state Exp;
branches;
next	1.22;
commitid	bnlg9HFFbmynQBKE;

1.22
date	2016.06.05.07.56.07;	author jsg;	state Exp;
branches;
next	1.21;
commitid	AXS3EFkrpQ9RuDKz;

1.21
date	2016.05.20.23.07.05;	author jsg;	state Exp;
branches;
next	1.20;
commitid	nrywrrOKxkX4P0fg;

1.20
date	2016.05.07.00.18.23;	author jsg;	state Exp;
branches;
next	1.19;
commitid	Fjn21gkID0Guqlxy;

1.19
date	2016.05.05.11.01.08;	author kettenis;	state Exp;
branches;
next	1.18;
commitid	tXZ4cDDS7O2NIM1F;

1.18
date	2016.05.02.07.38.34;	author jsg;	state Exp;
branches;
next	1.17;
commitid	X6qZIqq3LFDYXzcO;

1.17
date	2016.05.02.03.01.36;	author jsg;	state Exp;
branches;
next	1.16;
commitid	Glc2wf1iOsMbk9JK;

1.16
date	2016.05.01.16.04.39;	author kettenis;	state Exp;
branches;
next	1.15;
commitid	rwmsBKqrjX2EodCO;

1.15
date	2016.01.10.14.11.43;	author kettenis;	state Exp;
branches;
next	1.14;
commitid	hXWKWq7NLwPiJ2vl;

1.14
date	2015.05.30.02.17.36;	author jsg;	state Exp;
branches;
next	1.13;
commitid	UF9mqL72sfyuXztw;

1.13
date	2014.11.04.13.18.04;	author jsg;	state Exp;
branches;
next	1.12;
commitid	tpfBJkKDQRPVZio5;

1.12
date	2013.12.04.12.31.14;	author syl;	state Exp;
branches;
next	1.11;

1.11
date	2013.11.12.17.51.52;	author fgsch;	state Exp;
branches;
next	1.10;

1.10
date	2013.11.06.19.03.07;	author syl;	state Exp;
branches;
next	1.9;

1.9
date	2013.10.28.20.45.20;	author syl;	state Exp;
branches;
next	1.8;

1.8
date	2013.10.24.19.39.46;	author syl;	state Exp;
branches;
next	1.7;

1.7
date	2013.10.18.15.23.58;	author syl;	state Exp;
branches;
next	1.6;

1.6
date	2013.10.18.06.34.10;	author syl;	state Exp;
branches;
next	1.5;

1.5
date	2013.10.14.18.53.52;	author syl;	state Exp;
branches;
next	1.4;

1.4
date	2013.10.14.18.51.56;	author syl;	state Exp;
branches;
next	1.3;

1.3
date	2013.10.14.18.49.19;	author syl;	state Exp;
branches;
next	1.2;

1.2
date	2013.09.12.12.03.15;	author rapha;	state Exp;
branches;
next	1.1;

1.1
date	2013.09.04.14.38.31;	author patrick;	state Exp;
branches;
next	;


desc
@@


1.31
log
@p_comm is the process's command and isn't per thread, so move it from
struct proc to struct process.

ok deraadt@@ kettenis@@
@
text
@/*	$OpenBSD: ommmc.c,v 1.30 2016/10/08 03:42:20 jsg Exp $	*/

/*
 * Copyright (c) 2009 Dale Rahn <drahn@@openbsd.org>
 * Copyright (c) 2006 Uwe Stuehler <uwe@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/* Omap SD/MMC support derived from /sys/dev/sdmmc/sdhc.c */


#include <sys/param.h>
#include <sys/device.h>
#include <sys/kernel.h>
#include <sys/kthread.h>
#include <sys/malloc.h>
#include <sys/systm.h>
#include <machine/bus.h>
#include <machine/fdt.h>

#include <dev/sdmmc/sdmmcchip.h>
#include <dev/sdmmc/sdmmcvar.h>

#include <armv7/armv7/armv7var.h>
#include <armv7/omap/prcmvar.h>

#include <dev/ofw/openfirm.h>
#include <dev/ofw/ofw_pinctrl.h>
#include <dev/ofw/fdt.h>

/*
 * NOTE: on OMAP4430/AM335x these registers skew by 0x100
 * this is handled by mapping at base address + 0x100
 */
/* registers */
#define MMCHS_SYSCONFIG	0x010
#define MMCHS_SYSSTATUS	0x014
#define MMCHS_CSRE	0x024
#define MMCHS_SYSTEST	0x028
#define  MMCHS_SYSTEST_SDCD	(1 << 15)
#define MMCHS_CON	0x02C
#define  MMCHS_CON_INIT	(1<<1)
#define  MMCHS_CON_DW8	(1<<5)
#define  MMCHS_CON_OD	(1<<0)
#define MMCHS_PWCNT	0x030
#define MMCHS_BLK	0x104
#define  MMCHS_BLK_NBLK_MAX	0xffff
#define  MMCHS_BLK_NBLK_SHIFT	16
#define  MMCHS_BLK_NBLK_MASK	(MMCHS_BLK_NBLK_MAX<<MMCHS_BLK_NBLK_SHIFT)
#define  MMCHS_BLK_BLEN_MAX	0x400
#define  MMCHS_BLK_BLEN_SHIFT	0
#define  MMCHS_BLK_BLEN_MASK	(MMCHS_BLK_BLEN_MAX<<MMCHS_BLK_BLEN_SHIFT)
#define MMCHS_ARG	0x108
#define MMCHS_CMD	0x10C
#define  MMCHS_CMD_INDX_SHIFT		24
#define  MMCHS_CMD_INDX_SHIFT_MASK	(0x3f << MMCHS_CMD_INDX_SHIFT)
#define	 MMCHS_CMD_CMD_TYPE_SHIFT	22
#define	 MMCHS_CMD_DP_SHIFT		21
#define	 MMCHS_CMD_DP			(1 << MMCHS_CMD_DP_SHIFT)
#define	 MMCHS_CMD_CICE_SHIFT		20
#define	 MMCHS_CMD_CICE			(1 << MMCHS_CMD_CICE_SHIFT)
#define	 MMCHS_CMD_CCCE_SHIFT		19
#define	 MMCHS_CMD_CCCE			(1 << MMCHS_CMD_CCCE_SHIFT)
#define	 MMCHS_CMD_RSP_TYPE_SHIFT	16
#define  MMCHS_CMD_RESP_NONE		(0x0 << MMCHS_CMD_RSP_TYPE_SHIFT)
#define  MMCHS_CMD_RESP136		(0x1 << MMCHS_CMD_RSP_TYPE_SHIFT)
#define  MMCHS_CMD_RESP48		(0x2 << MMCHS_CMD_RSP_TYPE_SHIFT)
#define  MMCHS_CMD_RESP48B		(0x3 << MMCHS_CMD_RSP_TYPE_SHIFT)
#define  MMCHS_CMD_MSBS			(1 << 5)
#define  MMCHS_CMD_DDIR			(1 << 4)
#define  MMCHS_CMD_ACEN			(1 << 2)
#define  MMCHS_CMD_BCE			(1 << 1)
#define  MMCHS_CMD_DE			(1 << 0)
#define MMCHS_RSP10	0x110
#define MMCHS_RSP32	0x114
#define MMCHS_RSP54	0x118
#define MMCHS_RSP76	0x11C
#define MMCHS_DATA	0x120
#define MMCHS_PSTATE	0x124
#define  MMCHS_PSTATE_CLEV	(1<<24)
#define  MMCHS_PSTATE_DLEV_SH	20
#define  MMCHS_PSTATE_DLEV_M	(0xf << MMCHS_PSTATE_DLEV_SH)
#define  MMCHS_PSTATE_BRE	(1<<11)
#define  MMCHS_PSTATE_BWE	(1<<10)
#define  MMCHS_PSTATE_RTA	(1<<9)
#define  MMCHS_PSTATE_WTA	(1<<8)
#define  MMCHS_PSTATE_DLA	(1<<2)
#define  MMCHS_PSTATE_DATI	(1<<1)
#define  MMCHS_PSTATE_CMDI	(1<<0)
#define  MMCHS_PSTATE_FMT "\20" \
    "\x098_CLEV" \
    "\x08b_BRE" \
    "\x08a_BWE" \
    "\x089_RTA" \
    "\x088_WTA" \
    "\x082_DLA" \
    "\x081_DATI" \
    "\x080_CMDI"
#define MMCHS_HCTL	0x128
#define  MMCHS_HCTL_SDVS_SHIFT	9
#define  MMCHS_HCTL_SDVS_MASK	(0x7<<MMCHS_HCTL_SDVS_SHIFT)
#define  MMCHS_HCTL_SDVS_V18	(0x5<<MMCHS_HCTL_SDVS_SHIFT)
#define  MMCHS_HCTL_SDVS_V30	(0x6<<MMCHS_HCTL_SDVS_SHIFT)
#define  MMCHS_HCTL_SDVS_V33	(0x7<<MMCHS_HCTL_SDVS_SHIFT)
#define  MMCHS_HCTL_SDBP	(1<<8)
#define  MMCHS_HCTL_HSPE	(1<<2)
#define  MMCHS_HCTL_DTW		(1<<1)
#define MMCHS_SYSCTL	0x12C
#define  MMCHS_SYSCTL_SRD	(1<<26)
#define  MMCHS_SYSCTL_SRC	(1<<25)
#define  MMCHS_SYSCTL_SRA	(1<<24)
#define  MMCHS_SYSCTL_DTO_SH	16
#define  MMCHS_SYSCTL_DTO_MASK	0x000f0000
#define  MMCHS_SYSCTL_CLKD_SH	6
#define  MMCHS_SYSCTL_CLKD_MASK	0x0000ffc0
#define  MMCHS_SYSCTL_CEN	(1<<2)
#define  MMCHS_SYSCTL_ICS	(1<<1)
#define  MMCHS_SYSCTL_ICE	(1<<0)
#define MMCHS_STAT	0x130
#define  MMCHS_STAT_BADA	(1<<29)
#define  MMCHS_STAT_CERR	(1<<28)
#define  MMCHS_STAT_ACE		(1<<24)
#define  MMCHS_STAT_DEB		(1<<22)
#define  MMCHS_STAT_DCRC	(1<<21)
#define  MMCHS_STAT_DTO		(1<<20)
#define  MMCHS_STAT_CIE		(1<<19)
#define  MMCHS_STAT_CEB		(1<<18)
#define  MMCHS_STAT_CCRC	(1<<17)
#define  MMCHS_STAT_CTO		(1<<16)
#define  MMCHS_STAT_ERRI	(1<<15)
#define  MMCHS_STAT_OBI		(1<<9)
#define  MMCHS_STAT_CIRQ	(1<<8)
#define  MMCHS_STAT_BRR		(1<<5)
#define  MMCHS_STAT_BWR		(1<<4)
#define  MMCHS_STAT_BGE		(1<<2)
#define  MMCHS_STAT_TC		(1<<1)
#define  MMCHS_STAT_CC		(1<<0)
#define  MMCHS_STAT_FMT "\20" \
    "\x09d_BADA" \
    "\x09c_CERR" \
    "\x098_ACE" \
    "\x096_DEB" \
    "\x095_DCRC" \
    "\x094_DTO" \
    "\x093_CIE" \
    "\x092_CEB" \
    "\x091_CCRC" \
    "\x090_CTO" \
    "\x08f_ERRI" \
    "\x089_OBI" \
    "\x088_CIRQ" \
    "\x085_BRR" \
    "\x084_BWR" \
    "\x082_BGE" \
    "\x081_TC" \
    "\x080_CC"
#define MMCHS_IE	0x134
#define MMCHS_ISE	0x138
#define MMCHS_AC12	0x13C
#define MMCHS_CAPA	0x140
#define  MMCHS_CAPA_VS18	(1 << 26)
#define  MMCHS_CAPA_VS30	(1 << 25)
#define  MMCHS_CAPA_VS33	(1 << 24)
#define  MMCHS_CAPA_SRS		(1 << 23)
#define  MMCHS_CAPA_DS		(1 << 22)
#define  MMCHS_CAPA_HSS		(1 << 21)
#define  MMCHS_CAPA_MBL_SHIFT	16
#define  MMCHS_CAPA_MBL_MASK	(3 << MMCHS_CAPA_MBL_SHIFT)
#define MMCHS_CUR_CAPA	0x148
#define MMCHS_REV	0x1fc

#define SDHC_COMMAND_TIMEOUT	hz
#define SDHC_BUFFER_TIMEOUT	hz
#define SDHC_TRANSFER_TIMEOUT	hz

int ommmc_match(struct device *, void *, void *);
void ommmc_attach(struct device *, struct device *, void *);

struct ommmc_softc {
	struct device sc_dev;
	bus_space_tag_t		sc_iot;
	bus_space_handle_t	sc_ioh;
	void			*sc_ih; /* Interrupt handler */
	uint32_t		sc_flags;
#define FL_HSS		(1 << 0)

	struct device *sdmmc;		/* generic SD/MMC device */
	int clockbit;			/* clock control bit */
	uint32_t clkbase;		/* base clock frequency in KHz */
	int maxblklen;			/* maximum block length */
	int flags;			/* flags for this host */
	uint32_t ocr;			/* OCR value from capabilities */
	uint32_t intr_status;		/* soft interrupt status */
	uint32_t intr_error_status;	/*  */
};


/* Host controller functions called by the attachment driver. */
int	ommmc_host_found(struct ommmc_softc *, bus_space_tag_t,
	    bus_space_handle_t, bus_size_t, int);
void	ommmc_power(int, void *);
void	ommmc_shutdown(void *);
int	ommmc_intr(void *);

/* RESET MODES */
#define MMC_RESET_DAT	1
#define MMC_RESET_CMD	2
#define MMC_RESET_ALL	(MMC_RESET_CMD|MMC_RESET_DAT)

/* flag values */
#define SHF_USE_DMA		0x0001

#define HREAD4(sc, reg)							\
	(bus_space_read_4((sc)->sc_iot, (sc)->sc_ioh, (reg)))
#define HWRITE4(sc, reg, val)						\
	bus_space_write_4((sc)->sc_iot, (sc)->sc_ioh, (reg), (val))
#define HSET4(sc, reg, bits)						\
	HWRITE4((sc), (reg), HREAD4((sc), (reg)) | (bits))
#define HCLR4(sc, reg, bits)						\
	HWRITE4((sc), (reg), HREAD4((sc), (reg)) & ~(bits))

int	ommmc_host_reset(sdmmc_chipset_handle_t);
uint32_t ommmc_host_ocr(sdmmc_chipset_handle_t);
int	ommmc_host_maxblklen(sdmmc_chipset_handle_t);
int	ommmc_card_detect(sdmmc_chipset_handle_t);
int	ommmc_bus_power(sdmmc_chipset_handle_t, uint32_t);
int	ommmc_bus_clock(sdmmc_chipset_handle_t, int, int);
int	ommmc_bus_width(sdmmc_chipset_handle_t, int);
void	ommmc_card_intr_mask(sdmmc_chipset_handle_t, int);
void	ommmc_card_intr_ack(sdmmc_chipset_handle_t);
void	ommmc_exec_command(sdmmc_chipset_handle_t, struct sdmmc_command *);
int	ommmc_start_command(struct ommmc_softc *, struct sdmmc_command *);
int	ommmc_wait_state(struct ommmc_softc *, uint32_t, uint32_t);
int	ommmc_soft_reset(struct ommmc_softc *, int);
int	ommmc_wait_intr(struct ommmc_softc *, int, int);
void	ommmc_transfer_data(struct ommmc_softc *, struct sdmmc_command *);
void	ommmc_read_data(struct ommmc_softc *, uint8_t *, int);
void	ommmc_write_data(struct ommmc_softc *, uint8_t *, int);

/* #define SDHC_DEBUG */
#ifdef SDHC_DEBUG
int ommmcdebug = 20;
#define DPRINTF(n,s)	do { if ((n) <= ommmcdebug) printf s; } while (0)
void	ommmc_dump_regs(struct ommmc_softc *);
#else
#define DPRINTF(n,s)	do {} while(0)
#endif

struct sdmmc_chip_functions ommmc_functions = {
	/* host controller reset */
	ommmc_host_reset,
	/* host controller capabilities */
	ommmc_host_ocr,
	ommmc_host_maxblklen,
	/* card detection */
	ommmc_card_detect,
	/* bus power and clock frequency */
	ommmc_bus_power,
	ommmc_bus_clock,
	ommmc_bus_width,
	/* command execution */
	ommmc_exec_command,
	/* card interrupt */
	ommmc_card_intr_mask,
	ommmc_card_intr_ack
};

struct cfdriver ommmc_cd = {
	NULL, "ommmc", DV_DULL
};

struct cfattach ommmc_ca = {
	sizeof(struct ommmc_softc), ommmc_match, ommmc_attach
};

int
ommmc_match(struct device *parent, void *match, void *aux)
{
	struct fdt_attach_args *faa = aux;

	return (OF_is_compatible(faa->fa_node, "ti,omap3-hsmmc") ||
	    OF_is_compatible(faa->fa_node, "ti,omap4-hsmmc"));
}

void
ommmc_attach(struct device *parent, struct device *self, void *aux)
{
	struct ommmc_softc		*sc = (struct ommmc_softc *) self;
	struct fdt_attach_args		*faa = aux;
	struct sdmmcbus_attach_args	 saa;
	uint32_t			 caps, width;
	uint32_t			 addr, size;
	int				 len, unit;
	char				 hwmods[128];

	if (faa->fa_nreg < 1)
		return;

	if (faa->fa_reg[0].size <= 0x100)
		return;

	if (OF_is_compatible(faa->fa_node, "ti,omap4-hsmmc")) {
		addr = faa->fa_reg[0].addr + 0x100;
		size = faa->fa_reg[0].size - 0x100;
	} else {
		addr = faa->fa_reg[0].addr;
		size = faa->fa_reg[0].size;
	}

	unit = 0;
	if ((len = OF_getprop(faa->fa_node, "ti,hwmods", hwmods,
	    sizeof(hwmods))) == 5) {
		if (!strncmp(hwmods, "mmc", 3) &&
		    (hwmods[3] > '0') && (hwmods[3] <= '9'))
			unit = hwmods[3] - '1';
	}

	sc->sc_iot = faa->fa_iot;
	if (bus_space_map(sc->sc_iot, addr, size, 0, &sc->sc_ioh))
		panic("%s: bus_space_map failed!", __func__);

	printf("\n");

	pinctrl_byname(faa->fa_node, "default");

	/* Enable ICLKEN, FCLKEN? */
	prcm_enablemodule(PRCM_MMC0 + unit);

	sc->sc_ih = arm_intr_establish_fdt(faa->fa_node, IPL_SDMMC,
	    ommmc_intr, sc, DEVNAME(sc));
	if (sc->sc_ih == NULL) {
		printf("%s: cannot map interrupt\n", DEVNAME(sc));
		goto err;
	}

	/* Controller Voltage Capabilities Initialization */
	HSET4(sc, MMCHS_CAPA, MMCHS_CAPA_VS18 | MMCHS_CAPA_VS30);

#ifdef SDHC_DEBUG
	ommmc_dump_regs(sc);
#endif

	/*
	 * Reset the host controller and enable interrupts.
	 */
	ommmc_host_reset(sc);

	/* Determine host capabilities. */
	caps = HREAD4(sc, MMCHS_CAPA);

#if 0
	/* we want this !! */
	/* Use DMA if the host system and the controller support it. */
	if (usedma && ISSET(caps, SDHC_DMA_SUPPORT))
		SET(sc->flags, SHF_USE_DMA);
#endif

	/*
	 * Determine the base clock frequency. (2.2.24)
	 */

	sc->clkbase = 96 * 1000;
#if 0
	if (SDHC_BASE_FREQ_KHZ(caps) != 0)
		sc->clkbase = SDHC_BASE_FREQ_KHZ(caps);
#endif
	if (sc->clkbase == 0) {
		/* The attachment driver must tell us. */
		printf("%s: base clock frequency unknown\n", DEVNAME(sc));
		goto err;
	} else if (sc->clkbase < 10000 || sc->clkbase > 96000) {
		/* SDHC 1.0 supports only 10-63 MHz. */
		printf("%s: base clock frequency out of range: %u MHz\n",
		    DEVNAME(sc), sc->clkbase / 1000);
		goto err;
	}

	/*
	 * XXX Set the data timeout counter value according to
	 * capabilities. (2.2.15)
	 */


	/*
	 * Determine SD bus voltage levels supported by the controller.
	 */
	if (caps & MMCHS_CAPA_VS18)
		SET(sc->ocr, MMC_OCR_1_65V_1_95V);
	if (caps & MMCHS_CAPA_VS30)
		SET(sc->ocr, MMC_OCR_2_9V_3_0V | MMC_OCR_3_0V_3_1V);
	if (caps & MMCHS_CAPA_VS33)
		SET(sc->ocr, MMC_OCR_3_2V_3_3V | MMC_OCR_3_3V_3_4V);

	/*
	 * Omap max block size is fixed (single buffer), could limit
	 * this to 512 for double buffering, but dont see the point.
	 */
	switch ((caps & MMCHS_CAPA_MBL_MASK) >> MMCHS_CAPA_MBL_SHIFT) {
	case 0:
		sc->maxblklen = 512;
		break;
	case 1:
		sc->maxblklen = 1024;
		break;
	case 2:
		sc->maxblklen = 2048;
		break;
	default:
		sc->maxblklen = 512;
		printf("invalid capability blocksize in capa %08x,"
		    " trying 512\n", HREAD4(sc, MMCHS_CAPA));
	}
	/*
	 * MMC does not support blksize > 512 yet
	 */
	sc->maxblklen = 512;
	/*
	 * Attach the generic SD/MMC bus driver.  (The bus driver must
	 * not invoke any chipset functions before it is attached.)
	 */
	bzero(&saa, sizeof(saa));
	saa.saa_busname = "sdmmc";
	saa.sct = &ommmc_functions;
	saa.sch = sc;
	if (OF_getproplen(faa->fa_node, "ti,needs-special-hs-handling") == 0 &&
	    (caps & MMCHS_CAPA_HSS)) {
		sc->sc_flags |= FL_HSS;
		saa.caps |= SMC_CAPS_MMC_HIGHSPEED | SMC_CAPS_SD_HIGHSPEED;
	}
	width = OF_getpropint(faa->fa_node, "bus-width", 1);
	/* with bbb emmc width > 1 ommmc_wait_intr MMCHS_STAT_CC times out */
	if (unit != 0)
		width = 1;
	if (width >= 8)
		saa.caps |= SMC_CAPS_8BIT_MODE;
	if (width >= 4)
		saa.caps |= SMC_CAPS_4BIT_MODE;

	sc->sdmmc = config_found(&sc->sc_dev, &saa, NULL);
	if (sc->sdmmc == NULL) {
		printf("%s: can't attach sdmmc\n", DEVNAME(sc));
		goto err;
	}

	return;
err:
	if (sc->sc_ih != NULL)
		arm_intr_disestablish(sc->sc_ih);
	bus_space_unmap(sc->sc_iot, sc->sc_ioh, size);
}


/*
 * Power hook established by or called from attachment driver.
 */
void
ommmc_power(int why, void *arg)
{
#if 0
	struct ommmc_softc *sc = arg;
	int n, i;
#endif

	switch(why) {
	case DVACT_SUSPEND:
		/* XXX poll for command completion or suspend command
		 * in progress */

		/* Save the host controller state. */
#if 0
		for (i = 0; i < sizeof sc->regs; i++)
			sc->regs[i] = HREAD1(sc, i);
#endif
		break;

	case DVACT_RESUME:
		/* Restore the host controller state. */
#if 0
		(void)ommmc_host_reset(sc);
		for (i = 0; i < sizeof sc->regs; i++)
			HWRITE1(sc, i, sc->regs[i]);
#endif
		break;
	}
}

/*
 * Shutdown hook established by or called from attachment driver.
 */
void
ommmc_shutdown(void *arg)
{
	struct ommmc_softc *sc = arg;

	/* XXX chip locks up if we don't disable it before reboot. */
	(void)ommmc_host_reset(sc);
}

/*
 * Reset the host controller.  Called during initialization, when
 * cards are removed, upon resume, and during error recovery.
 */
int
ommmc_host_reset(sdmmc_chipset_handle_t sch)
{
	struct ommmc_softc *sc = sch;
	uint32_t imask;
	int error;
	int s;

	s = splsdmmc();

	/* Disable all interrupts. */
	HWRITE4(sc, MMCHS_IE, 0);
	HWRITE4(sc, MMCHS_ISE, 0);

	/*
	 * Reset the entire host controller and wait up to 100ms for
	 * the controller to clear the reset bit.
	 */
	if ((error = ommmc_soft_reset(sc, MMCHS_SYSCTL_SRA)) != 0) {
		splx(s);
		return (error);
	}

#if 0
	HSET4(sc, MMCHS_CON, MMCHS_CON_INIT);
	HWRITE4(sc, MMCHS_CMD, 0);
	delay(100); /* should delay 1ms */

	HWRITE4(sc, MMCHS_STAT, MMCHS_STAT_CC);
	HCLR4(sc, MMCHS_CON, MMCHS_CON_INIT);
	HWRITE4(sc, MMCHS_STAT, ~0);
#endif


	/* Set data timeout counter value to max for now. */
	HSET4(sc, MMCHS_SYSCTL, 0xe << MMCHS_SYSCTL_DTO_SH);

	/* Enable interrupts. */
	imask = MMCHS_STAT_BRR | MMCHS_STAT_BWR | MMCHS_STAT_BGE |
	    MMCHS_STAT_TC | MMCHS_STAT_CC;

	imask |= MMCHS_STAT_BADA | MMCHS_STAT_CERR | MMCHS_STAT_DEB |
	    MMCHS_STAT_DCRC | MMCHS_STAT_DTO | MMCHS_STAT_CIE |
	    MMCHS_STAT_CEB | MMCHS_STAT_CCRC | MMCHS_STAT_CTO;

	HWRITE4(sc, MMCHS_IE, imask);
	HWRITE4(sc, MMCHS_ISE, imask);

	/* Switch back to 1-bit bus. */
	HCLR4(sc, MMCHS_CON, MMCHS_CON_DW8);
	HCLR4(sc, MMCHS_HCTL, MMCHS_HCTL_DTW);

	splx(s);
	return (0);
}

uint32_t
ommmc_host_ocr(sdmmc_chipset_handle_t sch)
{
	struct ommmc_softc *sc = sch;
	return (sc->ocr);
}

int
ommmc_host_maxblklen(sdmmc_chipset_handle_t sch)
{
	struct ommmc_softc *sc = sch;
	return (sc->maxblklen);
}

/*
 * Return non-zero if the card is currently inserted.
 */
int
ommmc_card_detect(sdmmc_chipset_handle_t sch)
{
	struct ommmc_softc *sc = sch;
	return !ISSET(HREAD4(sc, MMCHS_SYSTEST), MMCHS_SYSTEST_SDCD) ?
	    1 : 0;
}

/*
 * Set or change SD bus voltage and enable or disable SD bus power.
 * Return zero on success.
 */
int
ommmc_bus_power(sdmmc_chipset_handle_t sch, uint32_t ocr)
{
	struct ommmc_softc *sc = sch;
	uint32_t vdd;
	uint32_t reg;
	int s;

	s = splsdmmc();

	/*
	 * Disable bus power before voltage change.
	 */
	HCLR4(sc, MMCHS_HCTL, MMCHS_HCTL_SDBP);

	/* If power is disabled, reset the host and return now. */
	if (ocr == 0) {
		splx(s);
		(void)ommmc_host_reset(sc);
		return (0);
	}

	/*
	 * Select the maximum voltage according to capabilities.
	 */
	ocr &= sc->ocr;

	if (ISSET(ocr, MMC_OCR_3_2V_3_3V | MMC_OCR_3_3V_3_4V))
		vdd = MMCHS_HCTL_SDVS_V33;
	else if (ISSET(ocr, MMC_OCR_2_9V_3_0V | MMC_OCR_3_0V_3_1V))
		vdd = MMCHS_HCTL_SDVS_V30;
	else if (ISSET(ocr, MMC_OCR_1_65V_1_95V))
		vdd = MMCHS_HCTL_SDVS_V18;
	else {
		/* Unsupported voltage level requested. */
		splx(s);
		return (EINVAL);
	}

	/*
	 * Enable bus power.  Wait at least 1 ms (or 74 clocks) plus
	 * voltage ramp until power rises.
	 */
	reg = HREAD4(sc, MMCHS_HCTL);
	reg &= ~MMCHS_HCTL_SDVS_MASK;
	reg |= vdd;
	HWRITE4(sc, MMCHS_HCTL, reg);

	HSET4(sc, MMCHS_HCTL, MMCHS_HCTL_SDBP);
	delay(10000); /* XXX */

	/*
	 * The host system may not power the bus due to battery low,
	 * etc.  In that case, the host controller should clear the
	 * bus power bit.
	 */
	if (!ISSET(HREAD4(sc, MMCHS_HCTL), MMCHS_HCTL_SDBP)) {
		splx(s);
		return (ENXIO);
	}

	splx(s);
	return (0);
}

/*
 * Return the smallest possible base clock frequency divisor value
 * for the CLOCK_CTL register to produce `freq' (KHz).
 */
static int
ommmc_clock_divisor(struct ommmc_softc *sc, uint32_t freq)
{
	int div;
	uint32_t maxclk = MMCHS_SYSCTL_CLKD_MASK>>MMCHS_SYSCTL_CLKD_SH;

	for (div = 1; div <= maxclk; div++)
		if ((sc->clkbase / div) <= freq) {
			return (div);
		}

	printf("divisor failure\n");
	/* No divisor found. */
	return (-1);
}

/*
 * Set or change SDCLK frequency or disable the SD clock.
 * Return zero on success.
 */
int
ommmc_bus_clock(sdmmc_chipset_handle_t sch, int freq, int timing)
{
	int error = 0;
	struct ommmc_softc *sc = sch;
	uint32_t reg;
	int s;
	int div;
	int timo;

	s = splsdmmc();

	/* Must not stop the clock if commands are in progress. */
	for (timo = 1000; timo > 0; timo--) {
		if (!ISSET(HREAD4(sc, MMCHS_PSTATE),
		    MMCHS_PSTATE_CMDI|MMCHS_PSTATE_DATI))
			break;
		delay(10);
	}
	if (timo == 0) {
		error = ETIMEDOUT;
		goto ret;
	}

	/*
	 * Stop SD clock before changing the frequency.
	 */
	HCLR4(sc, MMCHS_SYSCTL, MMCHS_SYSCTL_CEN);
	if (freq == SDMMC_SDCLK_OFF)
		goto ret;

	/*
	 * Set the minimum base clock frequency divisor.
	 */
	if ((div = ommmc_clock_divisor(sc, freq)) < 0) {
		/* Invalid base clock frequency or `freq' value. */
		error = EINVAL;
		goto ret;
	}
	reg = HREAD4(sc, MMCHS_SYSCTL);
	reg &= ~MMCHS_SYSCTL_CLKD_MASK;
	reg |= div << MMCHS_SYSCTL_CLKD_SH;
	HWRITE4(sc, MMCHS_SYSCTL, reg);

	if ((timing == SDMMC_TIMING_HIGHSPEED) && (sc->sc_flags & FL_HSS))
		HSET4(sc, MMCHS_HCTL, MMCHS_HCTL_HSPE);
	else
		HCLR4(sc, MMCHS_HCTL, MMCHS_HCTL_HSPE);

	/*
	 * Start internal clock.  Wait 10ms for stabilization.
	 */
	HSET4(sc, MMCHS_SYSCTL, MMCHS_SYSCTL_ICE);
	for (timo = 1000; timo > 0; timo--) {
		if (ISSET(HREAD4(sc, MMCHS_SYSCTL), MMCHS_SYSCTL_ICS))
			break;
		delay(10);
	}
	if (timo == 0) {
		error = ETIMEDOUT;
		goto ret;
	}

	/*
	 * Enable SD clock.
	 */
	HSET4(sc, MMCHS_SYSCTL, MMCHS_SYSCTL_CEN);
ret:
	splx(s);
	return (error);
}

int
ommmc_bus_width(sdmmc_chipset_handle_t sch, int width)
{
	struct ommmc_softc *sc = sch;
	int s;

	if (width != 1 && width != 4 && width != 8)
		return (1);

	s = splsdmmc();

	if (width == 8)
		HSET4(sc, MMCHS_CON, MMCHS_CON_DW8);
	else
		HCLR4(sc, MMCHS_CON, MMCHS_CON_DW8);

	if (width == 4)
		HSET4(sc, MMCHS_HCTL, MMCHS_HCTL_DTW);
	else if (width == 1)
		HCLR4(sc, MMCHS_HCTL, MMCHS_HCTL_DTW);

	splx(s);

	return (0);
}

void
ommmc_card_intr_mask(sdmmc_chipset_handle_t sch, int enable)
{
	/* - this is SDIO card interrupt */
	struct ommmc_softc *sc = sch;

	if (enable) {
		HSET4(sc, MMCHS_IE, MMCHS_STAT_CIRQ);
		HSET4(sc, MMCHS_ISE, MMCHS_STAT_CIRQ);
	} else {
		HCLR4(sc, MMCHS_IE, MMCHS_STAT_CIRQ);
		HCLR4(sc, MMCHS_ISE, MMCHS_STAT_CIRQ);
	}
}

void
ommmc_card_intr_ack(sdmmc_chipset_handle_t sch)
{
	struct ommmc_softc *sc = sch;

	HWRITE4(sc, MMCHS_STAT, MMCHS_STAT_CIRQ);
}

int
ommmc_wait_state(struct ommmc_softc *sc, uint32_t mask, uint32_t value)
{
	uint32_t state;
	int timeout;

	state = HREAD4(sc, MMCHS_PSTATE);
	DPRINTF(3,("%s: wait_state %x %x %x(state=%b)\n", DEVNAME(sc),
	    mask, value, state, state, MMCHS_PSTATE_FMT));
	for (timeout = 1000; timeout > 0; timeout--) {
		if (((state = HREAD4(sc, MMCHS_PSTATE)) & mask) == value)
			return (0);
		delay(10);
	}
	DPRINTF(0,("%s: timeout waiting for %x (state=%b)\n", DEVNAME(sc),
	    value, state, MMCHS_PSTATE_FMT));
	return (ETIMEDOUT);
}

void
ommmc_exec_command(sdmmc_chipset_handle_t sch, struct sdmmc_command *cmd)
{
	struct ommmc_softc *sc = sch;
	int error;

	/*
	 * Start the MMC command, or mark `cmd' as failed and return.
	 */
	error = ommmc_start_command(sc, cmd);
	if (error != 0) {
		cmd->c_error = error;
		SET(cmd->c_flags, SCF_ITSDONE);
		return;
	}

	/*
	 * Wait until the command phase is done, or until the command
	 * is marked done for any other reason.
	 */
	if (!ommmc_wait_intr(sc, MMCHS_STAT_CC, SDHC_COMMAND_TIMEOUT)) {
		cmd->c_error = ETIMEDOUT;
		SET(cmd->c_flags, SCF_ITSDONE);
		return;
	}

	/*
	 * The host controller removes bits [0:7] from the response
	 * data (CRC) and we pass the data up unchanged to the bus
	 * driver (without padding).
	 */
	if (cmd->c_error == 0 && ISSET(cmd->c_flags, SCF_RSP_PRESENT)) {
		if (ISSET(cmd->c_flags, SCF_RSP_136)) {
			uint32_t v0,v1,v2,v3;
			v0 = HREAD4(sc, MMCHS_RSP10);
			v1 = HREAD4(sc, MMCHS_RSP32);
			v2 = HREAD4(sc, MMCHS_RSP54);
			v3 = HREAD4(sc, MMCHS_RSP76);

			cmd->c_resp[0] = (v0 >> 8) | ((v1 & 0xff)  << 24);
			cmd->c_resp[1] = (v1 >> 8) | ((v2 & 0xff)  << 24);
			cmd->c_resp[2] = (v2 >> 8) | ((v3 & 0xff)  << 24);
			cmd->c_resp[3] = v3 >> 8;
#ifdef SDHC_DEBUG
			printf("resp[0] 0x%08x\nresp[1] 0x%08x\nresp[2] 0x%08x\nresp[3] 0x%08x\n", cmd->c_resp[0], cmd->c_resp[1], cmd->c_resp[2], cmd->c_resp[3]);
#endif
		} else  {
			cmd->c_resp[0] = HREAD4(sc, MMCHS_RSP10);
#ifdef SDHC_DEBUG
			printf("resp[0] 0x%08x\n", cmd->c_resp[0]);
#endif
		}
	}

	/*
	 * If the command has data to transfer in any direction,
	 * execute the transfer now.
	 */
	if (cmd->c_error == 0 && cmd->c_data != NULL)
		ommmc_transfer_data(sc, cmd);

#if 0
	/* Turn off the LED. */
	HCLR1(sc, SDHC_HOST_CTL, SDHC_LED_ON);
#endif

	DPRINTF(1,("%s: cmd %u done (flags=%#x error=%d)\n",
	    DEVNAME(sc), cmd->c_opcode, cmd->c_flags, cmd->c_error));
	SET(cmd->c_flags, SCF_ITSDONE);
}

int
ommmc_start_command(struct ommmc_softc *sc, struct sdmmc_command *cmd)
{
	uint32_t blksize = 0;
	uint32_t blkcount = 0;
	uint32_t command;
	int error;
	int s;

	DPRINTF(1,("%s: start cmd %u arg=%#x data=%p dlen=%d flags=%#x "
	    "proc=\"%s\"\n", DEVNAME(sc), cmd->c_opcode, cmd->c_arg,
	    cmd->c_data, cmd->c_datalen, cmd->c_flags, curproc ?
	    curproc->p_p->ps_comm : ""));

	/*
	 * The maximum block length for commands should be the minimum
	 * of the host buffer size and the card buffer size. (1.7.2)
	 */

	/* Fragment the data into proper blocks. */
	if (cmd->c_datalen > 0) {
		blksize = MIN(cmd->c_datalen, cmd->c_blklen);
		blkcount = cmd->c_datalen / blksize;
		if (cmd->c_datalen % blksize > 0) {
			/* XXX: Split this command. (1.7.4) */
			printf("%s: data not a multiple of %d bytes\n",
			    DEVNAME(sc), blksize);
			return (EINVAL);
		}
	}

	/* Check limit imposed by 9-bit block count. (1.7.2) */
	if (blkcount > MMCHS_BLK_NBLK_MAX) {
		printf("%s: too much data\n", DEVNAME(sc));
		return (EINVAL);
	}

	/* Prepare transfer mode register value. (2.2.5) */
	command = 0;
	if (ISSET(cmd->c_flags, SCF_CMD_READ))
		command |= MMCHS_CMD_DDIR;
	if (blkcount > 0) {
		command |= MMCHS_CMD_BCE;
		if (blkcount > 1) {
			command |= MMCHS_CMD_MSBS;
			/* XXX only for memory commands? */
			command |= MMCHS_CMD_ACEN;
		}
	}
#ifdef notyet
	if (ISSET(sc->flags, SHF_USE_DMA))
		command |= MMCHS_CMD_DE;
#endif

	/*
	 * Prepare command register value. (2.2.6)
	 */
	command |= (cmd->c_opcode << MMCHS_CMD_INDX_SHIFT) &
	   MMCHS_CMD_INDX_SHIFT_MASK;

	if (ISSET(cmd->c_flags, SCF_RSP_CRC))
		command |= MMCHS_CMD_CCCE;
	if (ISSET(cmd->c_flags, SCF_RSP_IDX))
		command |= MMCHS_CMD_CICE;
	if (cmd->c_data != NULL)
		command |= MMCHS_CMD_DP;

	if (!ISSET(cmd->c_flags, SCF_RSP_PRESENT))
		command |= MMCHS_CMD_RESP_NONE;
	else if (ISSET(cmd->c_flags, SCF_RSP_136))
		command |= MMCHS_CMD_RESP136;
	else if (ISSET(cmd->c_flags, SCF_RSP_BSY))
		command |= MMCHS_CMD_RESP48B;
	else
		command |= MMCHS_CMD_RESP48;

	/* Wait until command and data inhibit bits are clear. (1.5) */
	if ((error = ommmc_wait_state(sc, MMCHS_PSTATE_CMDI, 0)) != 0)
		return (error);

	s = splsdmmc();

#if 0
	/* Alert the user not to remove the card. */
	HSET1(sc, SDHC_HOST_CTL, SDHC_LED_ON);
#endif

	/* XXX: Set DMA start address if SHF_USE_DMA is set. */

	DPRINTF(1,("%s: cmd=%#x blksize=%d blkcount=%d\n",
	    DEVNAME(sc), command, blksize, blkcount));

	/*
	 * Start a CPU data transfer.  Writing to the high order byte
	 * of the SDHC_COMMAND register triggers the SD command. (1.5)
	 */
	HWRITE4(sc, MMCHS_BLK, (blkcount << MMCHS_BLK_NBLK_SHIFT) |
	    (blksize << MMCHS_BLK_BLEN_SHIFT));
	HWRITE4(sc, MMCHS_ARG, cmd->c_arg);
	HWRITE4(sc, MMCHS_CMD, command);

	splx(s);
	return (0);
}

void
ommmc_transfer_data(struct ommmc_softc *sc, struct sdmmc_command *cmd)
{
	uint8_t *datap = cmd->c_data;
	int i, datalen;
	int mask;
	int error;

	mask = ISSET(cmd->c_flags, SCF_CMD_READ) ?
	    MMCHS_PSTATE_BRE : MMCHS_PSTATE_BWE;
	error = 0;
	datalen = cmd->c_datalen;

	DPRINTF(1,("%s: resp=%#x datalen=%d\n", DEVNAME(sc),
	    MMC_R1(cmd->c_resp), datalen));

	while (datalen > 0) {
		if (!ommmc_wait_intr(sc, MMCHS_STAT_BRR| MMCHS_STAT_BWR,
		    SDHC_BUFFER_TIMEOUT)) {
			error = ETIMEDOUT;
			break;
		}

		if ((error = ommmc_wait_state(sc, mask, mask)) != 0)
			break;

		i = MIN(datalen, cmd->c_blklen);
		if (ISSET(cmd->c_flags, SCF_CMD_READ))
			ommmc_read_data(sc, datap, i);
		else
			ommmc_write_data(sc, datap, i);

		datap += i;
		datalen -= i;
	}

	if (error == 0 && !ommmc_wait_intr(sc, MMCHS_STAT_TC,
	    SDHC_TRANSFER_TIMEOUT))
		error = ETIMEDOUT;

	if (error != 0)
		cmd->c_error = error;
	SET(cmd->c_flags, SCF_ITSDONE);

	DPRINTF(1,("%s: data transfer done (error=%d)\n",
	    DEVNAME(sc), cmd->c_error));
}

void
ommmc_read_data(struct ommmc_softc *sc, uint8_t *datap, int datalen)
{
	while (datalen > 3) {
		*(uint32_t *)datap = HREAD4(sc, MMCHS_DATA);
		datap += 4;
		datalen -= 4;
	}
	if (datalen > 0) {
		uint32_t rv = HREAD4(sc, MMCHS_DATA);
		do {
			*datap++ = rv & 0xff;
			rv = rv >> 8;
		} while (--datalen > 0);
	}
}

void
ommmc_write_data(struct ommmc_softc *sc, uint8_t *datap, int datalen)
{
	while (datalen > 3) {
		DPRINTF(3,("%08x\n", *(uint32_t *)datap));
		HWRITE4(sc, MMCHS_DATA, *((uint32_t *)datap));
		datap += 4;
		datalen -= 4;
	}
	if (datalen > 0) {
		uint32_t rv = *datap++;
		if (datalen > 1)
			rv |= *datap++ << 8;
		if (datalen > 2)
			rv |= *datap++ << 16;
		DPRINTF(3,("rv %08x\n", rv));
		HWRITE4(sc, MMCHS_DATA, rv);
	}
}

/* Prepare for another command. */
int
ommmc_soft_reset(struct ommmc_softc *sc, int mask)
{

	int timo;

	DPRINTF(1,("%s: software reset reg=%#x\n", DEVNAME(sc), mask));

	HSET4(sc, MMCHS_SYSCTL, mask);
	/*
	 * If we read the software reset register too fast after writing it we
	 * can get back a zero that means the reset hasn't started yet rather
	 * than that the reset is complete. Per TI recommendations, work around
	 * it by reading until we see the reset bit asserted, then read until
	 * it's clear.
	 */
	for (timo = 1000; timo > 0; timo--) {
		if (ISSET(HREAD4(sc, MMCHS_SYSCTL), mask))
			break;
		delay(1);
	}
	for (timo = 1000; timo > 0; timo--) {
		if (!ISSET(HREAD4(sc, MMCHS_SYSCTL), mask))
			break;
		delay(10);
	}
	if (timo == 0) {
		DPRINTF(1,("%s: timeout reg=%#x\n", DEVNAME(sc),
		    HREAD4(sc, MMCHS_SYSCTL)));
		return (ETIMEDOUT);
	}

	return (0);
}

int
ommmc_wait_intr(struct ommmc_softc *sc, int mask, int timo)
{
	int status;
	int s;

	mask |= MMCHS_STAT_ERRI;

	s = splsdmmc();
	status = sc->intr_status & mask;
	while (status == 0) {
		if (tsleep(&sc->intr_status, PWAIT, "hcintr", timo)
		    == EWOULDBLOCK) {
			status |= MMCHS_STAT_ERRI;
			break;
		}
		status = sc->intr_status & mask;
	}
	sc->intr_status &= ~status;

	DPRINTF(2,("%s: intr status %#x error %#x\n", DEVNAME(sc), status,
	    sc->intr_error_status));

	/* Command timeout has higher priority than command complete. */
	if (ISSET(status, MMCHS_STAT_ERRI)) {
		sc->intr_error_status = 0;
		(void)ommmc_soft_reset(sc, MMCHS_SYSCTL_SRC|MMCHS_SYSCTL_SRD);
		status = 0;
	}

	splx(s);
	return (status);
}

/*
 * Established by attachment driver at interrupt priority IPL_SDMMC.
 */
int
ommmc_intr(void *arg)
{
	struct ommmc_softc *sc = arg;

	uint32_t status;

	/* Find out which interrupts are pending. */
	status = HREAD4(sc, MMCHS_STAT);

	/* Acknowledge the interrupts we are about to handle. */
	HWRITE4(sc, MMCHS_STAT, status);
	DPRINTF(2,("%s: interrupt status=%b\n", DEVNAME(sc),
	    status, MMCHS_STAT_FMT));

	/*
	 * Service error interrupts.
	 */
	if (ISSET(status, MMCHS_STAT_ERRI)) {
		if (ISSET(status, MMCHS_STAT_CTO|
		    MMCHS_STAT_DTO)) {
			sc->intr_status |= status;
			sc->intr_error_status |= status & 0xffff0000;
			wakeup(&sc->intr_status);
		}
	}

#if 0
	/*
	 * Wake up the sdmmc event thread to scan for cards.
	 */
	if (ISSET(status, SDHC_CARD_REMOVAL|SDHC_CARD_INSERTION))
		ommmc_needs_discover(sc->sdmmc);
#endif

	/*
	 * Wake up the blocking process to service command
	 * related interrupt(s).
	 */
	if (ISSET(status, MMCHS_STAT_BRR|
	    MMCHS_STAT_BWR|MMCHS_STAT_TC|
	    MMCHS_STAT_CC)) {
		sc->intr_status |= status;
		wakeup(&sc->intr_status);
	}

	/*
	 * Service SD card interrupts.
	 */
	if (ISSET(status, MMCHS_STAT_CIRQ)) {
		DPRINTF(0,("%s: card interrupt\n", DEVNAME(sc)));
		HCLR4(sc, MMCHS_STAT, MMCHS_STAT_CIRQ);
		sdmmc_card_intr(sc->sdmmc);
	}
	return 1;
}

#ifdef SDHC_DEBUG
void
ommmc_dump_regs(struct ommmc_softc *sc)
{
}
#endif
@


1.30
log
@Only set the highspeed bit in bus_clock if highspeed is supported
by the controller.  Needed as the bus_clock callback is called with
SDMMC_TIMING_HIGHSPEED even if the controller capability is not set.
Required to raise the bus width on pandaboard which doesn't have the
highspeed capability.

As anything other than 1 bit mode results in the emmc on the bbb
timing out waiting for command completion, limit higher bus
modes to the first hsmmc controller.  This at least lets 4 bit
modes work with sd cards on bbb and pandaboard.
@
text
@d1 1
a1 1
/*	$OpenBSD: ommmc.c,v 1.29 2016/08/12 03:22:41 jsg Exp $	*/
d911 1
a911 1
	    curproc->p_comm : ""));
@


1.29
log
@Switch omap to the generic ofw pinctrl framework.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ommmc.c,v 1.28 2016/08/06 10:07:45 jsg Exp $	*/
d196 1
d302 1
a302 1
	uint32_t			 caps;
d436 13
a448 2
	if (caps & MMCHS_CAPA_HSS)
		saa.caps |= SMC_CAPS_MMC_HIGHSPEED;
d732 3
a734 1
	if (timing == SDMMC_TIMING_LEGACY)
a735 2
	else
		HSET4(sc, MMCHS_HCTL, MMCHS_HCTL_HSPE);
@


1.28
log
@Dynamically attach intc(4) using the FDT and switch omap/am335x
drivers that use the FDT over to the FDT interrupt establish API.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ommmc.c,v 1.27 2016/07/27 11:45:02 patrick Exp $	*/
a36 1
#include <armv7/omap/sitara_cm.h>
d39 1
d334 1
a334 1
	sitara_cm_pinctrlbyname(faa->fa_node, "default");
@


1.27
log
@Instead of passing the raw reg property to simplebus nodes,
pass a pre-processed array of fdt_reg structs.  This means
that the drivers don't have to understand the cell properties
themselves but can rely on the 64-bit addr/size pairs.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ommmc.c,v 1.26 2016/07/17 02:45:05 jsg Exp $	*/
d302 1
a302 1
	uint32_t			 addr, size, irq;
d306 1
a306 1
	if (faa->fa_nreg != 1 || (faa->fa_nintr != 1 && faa->fa_nintr != 3))
a319 5
	if (faa->fa_nintr == 1)
		irq = faa->fa_intr[0];
	else
		irq = faa->fa_intr[1];

d339 1
a339 1
	sc->sc_ih = arm_intr_establish(irq, IPL_SDMMC,
@


1.26
log
@Adapt kettenis' pinctrl changes in imx to sitaracm and
pinctrl-single,pins to handle mux settings and pad configuration.

The fdt data has offsets from the start of the pinmux address range so
the am335x specific pinmux offset from the scm base is added to the
offsets.  This as not a new driver as sitaracm does manual table
driven pad configuration for gpio.  If all the offsets in the
ti_padconf_devmap table were reduced by the am335x pinmux offset (0x800)
it may make sense to map only the pinmux memory region and not the
scm superset.

looks good kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ommmc.c,v 1.25 2016/07/15 22:28:25 tom Exp $	*/
d40 1
d306 1
a306 1
	if (faa->fa_nreg != 2 || (faa->fa_nintr != 1 && faa->fa_nintr != 3))
d309 1
a309 1
	if (faa->fa_reg[1] <= 0x100)
d313 2
a314 2
		addr = faa->fa_reg[0] + 0x100;
		size = faa->fa_reg[1] - 0x100;
d316 2
a317 2
		addr = faa->fa_reg[0];
		size = faa->fa_reg[1];
@


1.25
log
@Remove duplicated line in omap mmc driver, which would cause
clkbase to be set to 0 (if it wasn't all commented out anyway).

ok patrick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ommmc.c,v 1.24 2016/06/18 09:59:35 jsg Exp $	*/
d37 1
d337 2
@


1.24
log
@Stop setting the 4-bit mode capability flag for now.

Writing to the bbb emmc (but not reading) gives errors otherwise.
This does not occur with an sd card on bbb but apparently does on panda.
@
text
@d1 1
a1 1
/*	$OpenBSD: ommmc.c,v 1.23 2016/06/18 05:59:26 jsg Exp $	*/
a375 1
		sc->clkbase = SDHC_BASE_FREQ_KHZ(caps);
@


1.23
log
@Dynamically attach ommmc with fdt.  Offset the start of the memory region
by 0x100 for nodes compatible with "ti,omap4-hsmmc" to get the same
offsets as omap3.  Handle both the nintr 1 (omap3/am335x) and nintr 3
(omap4) cases in attach.  Ideally the "interrupts" property will be
handled by the interrupt controller drivers directly in future.
@
text
@d1 1
a1 1
/*	$OpenBSD: ommmc.c,v 1.22 2016/06/05 07:56:07 jsg Exp $	*/
a436 1
	saa.caps = SMC_CAPS_4BIT_MODE;
@


1.22
log
@Reset the bus width back to 1-bit when resetting the host.
Similar changes were made to imxesdhc(4).
@
text
@d1 1
a1 1
/*	$OpenBSD: ommmc.c,v 1.21 2016/05/20 23:07:05 jsg Exp $	*/
d30 1
d38 2
d185 2
a186 1
void ommmc_attach(struct device *parent, struct device *self, void *args);
d281 1
a281 1
	sizeof(struct ommmc_softc), NULL, ommmc_attach
d284 9
d294 1
a294 1
ommmc_attach(struct device *parent, struct device *self, void *args)
d297 1
a297 1
	struct armv7_attach_args	*aa = args;
d300 30
d331 2
a332 3
	sc->sc_iot = aa->aa_iot;
	if (bus_space_map(sc->sc_iot, aa->aa_dev->mem[0].addr,
	    aa->aa_dev->mem[0].size, 0, &sc->sc_ioh))
d338 1
a338 1
	prcm_enablemodule(PRCM_MMC0 + aa->aa_dev->unit);
d340 1
a340 1
	sc->sc_ih = arm_intr_establish(aa->aa_dev->irq[0], IPL_SDMMC,
d451 1
a451 1
	bus_space_unmap(sc->sc_iot, sc->sc_ioh, aa->aa_dev->mem[0].size);
@


1.21
log
@Add a workaround for software reset described in the TI docs where we
have to poll for software reset bits to be set after writing before
polling for them to clear.  This seems to resolve problems with ommmc
sometimes not attaching properly with recent u-boot versions.  Adapted
from FreeBSD svn rev 275950.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ommmc.c,v 1.20 2016/05/07 00:18:23 jsg Exp $	*/
d510 4
@


1.20
log
@set the high speed enable bit if the timing isn't SDMMC_TIMING_LEGACY
ok patrick@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ommmc.c,v 1.19 2016/05/05 11:01:08 kettenis Exp $	*/
d1044 12
a1055 1
	delay(10);
@


1.19
log
@Add Dual Data Rate support for eMMC at 52MHz.
@
text
@d1 1
a1 1
/*	$OpenBSD: ommmc.c,v 1.18 2016/05/02 07:38:34 jsg Exp $	*/
d676 5
@


1.18
log
@add an empty ommmc_dump_regs() to fix the SDHC_DEBUG build
@
text
@d1 1
a1 1
/*	$OpenBSD: ommmc.c,v 1.17 2016/05/02 03:01:36 jsg Exp $	*/
d231 1
a231 1
int	ommmc_bus_clock(sdmmc_chipset_handle_t, int);
d634 1
a634 1
ommmc_bus_clock(sdmmc_chipset_handle_t sch, int freq)
@


1.17
log
@add support for changing the bus width to ommmc and set the 4-bit mode
capability

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ommmc.c,v 1.16 2016/05/01 16:04:39 kettenis Exp $	*/
d1147 7
@


1.16
log
@Add support for changing the bus width to the sdmmc subsystem and the sdhc(4)
controller.  Use this to switch SD cards to a 4-bit bus if they support it.

ok deraadt@@, jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ommmc.c,v 1.15 2016/01/10 14:11:43 kettenis Exp $	*/
d232 1
d264 1
a264 1
	NULL,
d395 1
a395 1
	saa.caps = 0;
d698 26
@


1.15
log
@Seems the voltage bit defenitions in sdmmcreg.h for voltages below 2V
are not quite right.  At least I can't find them in any of the MMC and
SD card documentation I can find on the interwebs.  Instead there is a
single "low voltage bit" that indicates support for the 1.65-1.95V or
1.70-1.95V range depending on the document you're reading.  Go with the
1.65-1.95V range as that is what Linux does.

Necessary (but not sufficient) to make the eMMC on the ASUS X205TA work.

ok jsg@@ (who did the armv7 bits)
@
text
@d1 1
a1 1
/*	$OpenBSD: ommmc.c,v 1.14 2015/05/30 02:17:36 jsg Exp $	*/
d263 1
@


1.14
log
@fix the build when SDHC_DEBUG is defined
@
text
@d1 1
a1 1
/*	$OpenBSD: ommmc.c,v 1.13 2014/11/04 13:18:04 jsg Exp $	*/
d356 1
a356 1
		SET(sc->ocr, MMC_OCR_1_7V_1_8V | MMC_OCR_1_8V_1_9V);
d573 1
a573 1
	else if (ISSET(ocr, MMC_OCR_1_7V_1_8V | MMC_OCR_1_8V_1_9V))
@


1.13
log
@Uncomment code that does voltage capabilities initialisation.  Without
this using an sd card with my rev C BeagleBone Black won't work.  Should
fix similiar problems reported by Gerke Preussner and Andrew Hills on arm@@

ok syl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ommmc.c,v 1.12 2013/12/04 12:31:14 syl Exp $	*/
d820 1
a820 1
	DPRINTF(1,("%s: start cmd %u arg=%#x data=%#x dlen=%d flags=%#x "
@


1.12
log
@Looks like the eMMC does no like block read request lower than block
size. Rever the bsize to default 512 to fix the problem while a proper
fix is worked on.

Spotted by rapha@@
ok rapha@@, fgsch@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ommmc.c,v 1.11 2013/11/12 17:51:52 fgsch Exp $	*/
a302 2
#if 0
	/* XXX - IIRC firmware should set this */
a304 1
#endif
@


1.11
log
@Implement sd card detection. Fixes the `sdmmc0: can't enable card' on bbb
when there is no card.
Tested on pandaboard by patrick@@, ok patrick@@ and syl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ommmc.c,v 1.10 2013/11/06 19:03:07 syl Exp $	*/
d384 4
@


1.10
log
@After factorizing armv7_machdep code here is an effort to factorize all
the code present in omap/omap.c imx/imx.c and sunxi/sunxi.c

All this code looks quite the same, so we move it in a generic armv7/armv7.c

This is a step closer to only one kernel for all armv7 boards.

ok patrick@@, rapha@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ommmc.c,v 1.9 2013/10/28 20:45:20 syl Exp $	*/
d46 1
a531 1
#if 0
d533 1
a533 1
	return ISSET(HREAD4(sc, SDHC_PRESENT_STATE), SDHC_CARD_INSERTED) ?
a534 3
#else
	return (1); /* XXX */
#endif
@


1.9
log
@Enable blocksize > 512 and cleanup ommmc_attach().

ok patrick@@.
With some input from Dale Rahn, Thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: ommmc.c,v 1.8 2013/10/24 19:39:46 syl Exp $	*/
d34 1
a34 1
#include <armv7/omap/omapvar.h>
d281 1
a281 1
	struct omap_attach_args		*oa = args;
d285 3
a287 3
	sc->sc_iot = oa->oa_iot;
	if (bus_space_map(sc->sc_iot, oa->oa_dev->mem[0].addr,
	    oa->oa_dev->mem[0].size, 0, &sc->sc_ioh))
d293 1
a293 1
	prcm_enablemodule(PRCM_MMC0 + oa->oa_dev->unit);
d295 1
a295 1
	sc->sc_ih = arm_intr_establish(oa->oa_dev->irq[0], IPL_SDMMC,
d405 1
a405 1
	bus_space_unmap(sc->sc_iot, sc->sc_ioh, oa->oa_dev->mem[0].size);
@


1.8
log
@Do not rely on u-boot to enable mmc clocks.

ok patrick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ommmc.c,v 1.7 2013/10/18 15:23:58 syl Exp $	*/
a282 1
	int				 error = 1;
d297 4
d315 1
a315 1
	(void)ommmc_host_reset(sc);
a382 3

	sc->maxblklen = 512; /* XXX */

d397 1
a397 1
		error = 0;
a401 1

d403 3
a405 1
	return;
@


1.7
log
@Move mmc base address registers workaround where it belongs.

ok patrick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ommmc.c,v 1.6 2013/10/18 06:34:10 syl Exp $	*/
a285 2
	/* XXX - ICLKEN, FCLKEN? */

d293 2
a294 2
	/* XXX DMA channels? */
	/* FIXME prcm_enableclock(sc->clockbit); */
@


1.6
log
@Replace sc->sc_dev.dv_xname by DEVNAME macro that is defined in
sdmmcvar.h. Also remove the redundant macro HDEVNAME.

ok patrick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ommmc.c,v 1.5 2013/10/14 18:53:52 syl Exp $	*/
a282 1
	int				 baseaddr;
a287 7
	baseaddr = oa->oa_dev->mem[0].addr;
	if (board_id == BOARD_ID_OMAP4_PANDA ||
	    board_id == BOARD_ID_AM335X_BEAGLEBONE) {
		/* omap4430 has mmc registers offset +0x100 */
		baseaddr += 0x100;
	}

d289 2
a290 2
	if (bus_space_map(sc->sc_iot, baseaddr, oa->oa_dev->mem[0].size,
	    0, &sc->sc_ioh))
@


1.5
log
@Fix a couple of style(9) nits.

ok patrick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ommmc.c,v 1.4 2013/10/14 18:51:56 syl Exp $	*/
a212 2
#define HDEVNAME(sc)	((sc)->sc_dev.dv_xname)

d307 1
a307 1
	    ommmc_intr, sc, sc->sc_dev.dv_xname);
d346 1
a346 2
		printf("%s: base clock frequency unknown\n",
		    sc->sc_dev.dv_xname);
d351 1
a351 1
		    sc->sc_dev.dv_xname, sc->clkbase / 1000);
d739 1
a739 1
	DPRINTF(3,("%s: wait_state %x %x %x(state=%b)\n", HDEVNAME(sc),
d746 1
a746 1
	DPRINTF(0,("%s: timeout waiting for %x (state=%b)\n", HDEVNAME(sc),
d818 1
a818 1
	    HDEVNAME(sc), cmd->c_opcode, cmd->c_flags, cmd->c_error));
d832 1
a832 1
	    "proc=\"%s\"\n", HDEVNAME(sc), cmd->c_opcode, cmd->c_arg,
d848 1
a848 1
			    HDEVNAME(sc), blksize);
d855 1
a855 1
		printf("%s: too much data\n", HDEVNAME(sc));
d912 1
a912 1
	    HDEVNAME(sc), command, blksize, blkcount));
d940 1
a940 1
	DPRINTF(1,("%s: resp=%#x datalen=%d\n", HDEVNAME(sc),
d972 1
a972 1
	    HDEVNAME(sc), cmd->c_error));
d1019 1
a1019 1
	DPRINTF(1,("%s: software reset reg=%#x\n", HDEVNAME(sc), mask));
d1029 1
a1029 1
		DPRINTF(1,("%s: timeout reg=%#x\n", HDEVNAME(sc),
d1057 1
a1057 1
	DPRINTF(2,("%s: intr status %#x error %#x\n", HDEVNAME(sc), status,
d1086 1
a1086 1
	DPRINTF(2,("%s: interrupt status=%b\n", HDEVNAME(sc),
d1124 1
a1124 1
		DPRINTF(0,("%s: card interrupt\n", HDEVNAME(sc)));
@


1.4
log
@Add some consistency using uint_t everywhere instead of mixing uint_t
and u_int_t.

ok patrick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ommmc.c,v 1.3 2013/10/14 18:49:19 syl Exp $	*/
d339 1
a339 1
	
d413 1
a413 1
	
d492 1
a492 1
	}	
d512 1
a512 1
	imask |= MMCHS_STAT_BADA | MMCHS_STAT_CERR | MMCHS_STAT_DEB | 
d520 1
a520 1
	return 0;
d527 1
a527 1
	return sc->ocr;
d534 1
a534 1
	return sc->maxblklen;
d548 1
a548 1
	return 1; /* XXX */
d575 1
a575 1
		return 0;
d592 1
a592 1
		return EINVAL;
d614 1
a614 1
		return ENXIO;
d618 1
a618 1
	return 0;
d638 1
a638 1
	return -1;
d668 1
a668 1
	
d709 1
a709 1
	return error;
d746 1
a746 1
			return 0;
d751 1
a751 1
	return ETIMEDOUT;
d833 1
a833 1
	
d852 1
a852 1
			return EINVAL;
d859 1
a859 1
		return EINVAL;
d903 1
a903 1
		return error;
d921 1
a921 1
	HWRITE4(sc, MMCHS_BLK, (blkcount << MMCHS_BLK_NBLK_SHIFT) | 
d927 1
a927 1
	return 0;
d1019 1
a1019 1
	
d1062 1
a1062 1
	
d1071 1
a1071 1
	return status;
@


1.3
log
@Tedu some heavy debug code that is not needed anymore.

No functional changes.

ok patrick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ommmc.c,v 1.2 2013/09/12 12:03:15 rapha Exp $	*/
d188 1
a188 1
	u_int sc_flags;
d192 1
a192 1
	u_int clkbase;			/* base clock frequency in KHz */
a195 1
//	u_int8_t regs[14];		/* host controller state */
d241 2
a242 2
void	ommmc_read_data(struct ommmc_softc *, u_char *, int);
void	ommmc_write_data(struct ommmc_softc *, u_char *, int);
d287 1
a287 1
	u_int32_t			 caps;
d475 1
a475 1
	u_int32_t imask;
d626 1
a626 1
ommmc_clock_divisor(struct ommmc_softc *sc, u_int freq)
d828 3
a830 3
	u_int32_t blksize = 0;
	u_int32_t blkcount = 0;
	u_int32_t command;
d933 1
a933 1
	u_char *datap = cmd->c_data;
d979 1
a979 1
ommmc_read_data(struct ommmc_softc *sc, u_char *datap, int datalen)
d996 1
a996 1
ommmc_write_data(struct ommmc_softc *sc, u_char *datap, int datalen)
d1082 1
a1082 1
	u_int32_t status;
@


1.2
log
@Enable the eMMC on the BeagleBone Black.

ok patrick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ommmc.c,v 1.1 2013/09/04 14:38:31 patrick Exp $	*/
a218 67
/* MMCHS should only be accessed with 4 byte reads or writes. */
#if 0
struct regtbl {
	char* name;
	uint32_t reg;
} tblname[] = {
	{"MMCHS_SYSCONFIG", MMCHS_SYSCONFIG},
	{"MMCHS_SYSSTATUS", MMCHS_SYSSTATUS},
	{"MMCHS_CSRE", MMCHS_CSRE},
	{"MMCHS_SYSTEST", MMCHS_SYSTEST},
	{"MMCHS_CON", MMCHS_CON},
	{"MMCHS_PWCNT", MMCHS_PWCNT},
	{"MMCHS_BLK", MMCHS_BLK},
	{"MMCHS_ARG", MMCHS_ARG},
	{"MMCHS_CMD", MMCHS_CMD},
	{"MMCHS_RSP10", MMCHS_RSP10},
	{"MMCHS_RSP32", MMCHS_RSP32},
	{"MMCHS_RSP54", MMCHS_RSP54},
	{"MMCHS_RSP76", MMCHS_RSP76},
	{"MMCHS_DATA", MMCHS_DATA},
	{"MMCHS_PSTATE", MMCHS_PSTATE},
	{"MMCHS_HCTL", MMCHS_HCTL},
	{"MMCHS_SYSCTL", MMCHS_SYSCTL},
	{"MMCHS_STAT", MMCHS_STAT},
	{"MMCHS_IE", MMCHS_IE},
	{"MMCHS_ISE", MMCHS_ISE},
	{"MMCHS_AC12", MMCHS_AC12},
	{"MMCHS_CAPA", MMCHS_CAPA},
	{"MMCHS_CUR_CAPA", MMCHS_CUR_CAPA},
	{NULL, 0 }
};
uint32_t HREAD4(struct ommmc_softc *sc, uint32_t reg);
void HWRITE4(struct ommmc_softc *sc, uint32_t reg, uint32_t val);
uint32_t HREAD4(struct ommmc_softc *sc, uint32_t reg)
{
	uint32_t val;
	int i;
	char *regname = "???";
	for (i = 0; tblname[i].name != NULL; i++) {
		if (tblname[i].reg == reg) {
			regname = tblname[i].name;
			break;
		}
	}
	val = (bus_space_read_4((sc)->sc_iot, (sc)->sc_ioh, (reg)));
	printf("read reg[%s] = %x\n", regname, val);
	return val;

}
void HWRITE4(struct ommmc_softc *sc, uint32_t reg, uint32_t val)
{
	char *regname = "???";
	int i;
	for (i = 0; tblname[i].name != NULL; i++) {
		if (tblname[i].reg == reg) {
			regname = tblname[i].name;
			break;
		}
	}
	printf("write reg[%s] = %x\n", regname, val);
	bus_space_write_4((sc)->sc_iot, (sc)->sc_ioh, (reg), (val));
}
#define HSET4(sc, reg, bits)						\
	HWRITE4((sc), (reg), HREAD4((sc), (reg)) | (bits))
#define HCLR4(sc, reg, bits)						\
	HWRITE4((sc), (reg), HREAD4((sc), (reg)) & ~(bits))
#else
a226 1
#endif
a1133 42

#ifdef SDHC_DEBUG

struct { 
	char * name;
	uint32_t off;
	} 	reglist[] = {
	{ "MMCHS_SYSCONFIG",	0x010 },
	{ "MMCHS_SYSSTATUS",	0x014 },
	{ "MMCHS_CSRE",		0x024 },
	{ "MMCHS_SYSTEST",	0x028 },
	{ "MMCHS_CON",		0x02C },
	{ "MMCHS_PWCNT",	0x030 },
	{ "MMCHS_BLK",		0x104 },
	{ "MMCHS_ARG",		0x108 },
	{ "MMCHS_CMD",		0x10C },
	{ "MMCHS_RSP10",	0x110 },
	{ "MMCHS_RSP32",	0x114 },
	{ "MMCHS_RSP54",	0x118 },
	{ "MMCHS_RSP76",	0x11C },
	{ "MMCHS_DATA",		0x120 },
	{ "MMCHS_PSTATE",	0x124 },
	{ "MMCHS_HCTL",		0x128 },
	{ "MMCHS_SYSCTL",	0x12C },
	{ "MMCHS_STAT",		0x130 },
	{ "MMCHS_IE",		0x134 },
	{ "MMCHS_ISE",		0x138 },
	{ "MMCHS_AC12",		0x13C },
	{ "MMCHS_CAPA",		0x140 },
	{ "MMCHS_CUR_CAPA",	0x148 },
	{ NULL,	0x0 }
};
void
ommmc_dump_regs(struct ommmc_softc *sc)
{
	int i;
	for (i = 0; reglist[i].name != NULL; i++) {
		printf("reg %s = %08x\n", reglist[i].name,
		    HREAD4(sc, reglist[i].off));
	}
}
#endif
@


1.1
log
@In the future, we shouldn't have one port port ARM SoC, that's just
ridiculous.  This is the first step for a common and generic ARM port
for ARMv7 SoCs.
@
text
@d1 1
a1 1
/*	$OpenBSD: ommmc.c,v 1.17 2013/08/25 18:22:59 stsp Exp $	*/
d48 2
d111 1
d356 1
a394 1
#if 0
d396 1
a396 1
	caps = HREAD4(sc, SDHC_CAPABILITIES);
d398 1
d436 1
a436 1
	if (HREAD4(sc, MMCHS_CAPA) & MMCHS_CAPA_VS18)
d438 1
a438 1
	if (HREAD4(sc, MMCHS_CAPA) & MMCHS_CAPA_VS30)
d440 1
a440 1
	if (HREAD4(sc, MMCHS_CAPA) & MMCHS_CAPA_VS33)
d447 1
a447 2
	switch ((HREAD4(sc, MMCHS_CAPA) & MMCHS_CAPA_MBL_MASK)
	    >> MMCHS_CAPA_MBL_SHIFT) {
d473 3
d669 2
a670 2
	reg &= MMCHS_HCTL_SDVS_MASK;
	reg = vdd;
a725 1
#ifdef DIAGNOSTIC
d727 11
a737 5
	if (ISSET(HREAD4(sc, MMCHS_PSTATE), MMCHS_PSTATE_CMDI|MMCHS_PSTATE_DATI)
	    && ommmc_card_detect(sc))
		printf("ommmc_sdclk_frequency_select: command in progress\n");
#endif

@

