head	1.21;
access;
symbols
	OPENBSD_6_2:1.21.0.2
	OPENBSD_6_2_BASE:1.21
	OPENBSD_6_1:1.21.0.4
	OPENBSD_6_1_BASE:1.21
	OPENBSD_6_0:1.16.0.2
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.8.0.2
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.4.0.2
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.6
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.4
	OPENBSD_5_5_BASE:1.4;
locks; strict;
comment	@ * @;


1.21
date	2017.03.01.04.36.45;	author jsg;	state Exp;
branches;
next	1.20;
commitid	FvS9GmYzNBxKJE49;

1.20
date	2016.10.03.01.59.20;	author jsg;	state Exp;
branches;
next	1.19;
commitid	3fibvKh5HnTb4IKT;

1.19
date	2016.08.11.04.33.06;	author jsg;	state Exp;
branches;
next	1.18;
commitid	RjguXQv1MwBBCk6s;

1.18
date	2016.08.11.01.53.18;	author jsg;	state Exp;
branches;
next	1.17;
commitid	8d7pfhv9A9vfWoLW;

1.17
date	2016.08.06.10.07.45;	author jsg;	state Exp;
branches;
next	1.16;
commitid	tIvsLgDtJFao46i9;

1.16
date	2016.07.10.03.04.00;	author jsg;	state Exp;
branches;
next	1.15;
commitid	wQK3wvLjiVFxZ4Cd;

1.15
date	2016.06.26.09.06.35;	author jsg;	state Exp;
branches;
next	1.14;
commitid	CMQxDZf1xqtqsVBC;

1.14
date	2016.06.26.07.25.05;	author jsg;	state Exp;
branches;
next	1.13;
commitid	v9jtqNaGlLrYhcFN;

1.13
date	2016.06.26.05.16.33;	author jsg;	state Exp;
branches;
next	1.12;
commitid	f0l6MGjSmDe958Pt;

1.12
date	2016.06.19.14.27.35;	author jsg;	state Exp;
branches;
next	1.11;
commitid	EAq933IGu4UbAbmj;

1.11
date	2016.06.18.05.59.26;	author jsg;	state Exp;
branches;
next	1.10;
commitid	bnlg9HFFbmynQBKE;

1.10
date	2016.06.04.18.09.16;	author jsg;	state Exp;
branches;
next	1.9;
commitid	tYyT96DOGdhLjy9v;

1.9
date	2016.05.02.15.27.24;	author patrick;	state Exp;
branches;
next	1.8;
commitid	gOMXBf6ijXFQHRgk;

1.8
date	2016.02.02.03.31.22;	author jsg;	state Exp;
branches;
next	1.7;
commitid	RbRzD1v0uZj2WQEC;

1.7
date	2015.05.20.00.14.56;	author jsg;	state Exp;
branches;
next	1.6;
commitid	Y47vqpZ6HtQSLXGx;

1.6
date	2015.05.19.03.30.54;	author jsg;	state Exp;
branches;
next	1.5;
commitid	l6xI4SC4UUe6il2U;

1.5
date	2015.05.15.15.35.43;	author jsg;	state Exp;
branches;
next	1.4;
commitid	AFNG6oUBgS2y44wd;

1.4
date	2013.11.06.19.03.07;	author syl;	state Exp;
branches;
next	1.3;

1.3
date	2013.10.10.19.40.02;	author syl;	state Exp;
branches;
next	1.2;

1.2
date	2013.09.12.12.03.15;	author rapha;	state Exp;
branches;
next	1.1;

1.1
date	2013.09.04.14.38.30;	author patrick;	state Exp;
branches;
next	;


desc
@@


1.21
log
@remove remaining parts of the table driven approach to attaching edma
@
text
@/* $OpenBSD: omap.c,v 1.20 2016/10/03 01:59:20 jsg Exp $ */
/*
 * Copyright (c) 2005,2008 Dale Rahn <drahn@@openbsd.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/systm.h>

#include <machine/bus.h>

#include <arm/mainbus/mainbus.h>
#include <armv7/armv7/armv7var.h>

#include <dev/ofw/fdt.h>

int	omap_match(struct device *, void *, void *);
void	omap3_init();
void	omap4_init();
void	am335x_init();

struct cfattach omap_ca = {
	sizeof(struct armv7_softc), omap_match, armv7_attach
};

struct cfdriver omap_cd = {
	NULL, "omap", DV_DULL
};

struct board_dev omap3_dev[] = {
	{ "prcm",	0 },
	{ "gptimer",	0 },
	{ "gptimer",	1 },
	{ NULL,		0 }
};

struct board_dev am33xx_dev[] = {
	{ "prcm",	0 },
	{ "dmtimer",	0 },
	{ "dmtimer",	1 },
	{ NULL,		0 }
};

struct board_dev omap4_dev[] = {
	{ "omapid",	0 },
	{ "prcm",	0 },
	{ NULL,		0 }
};

struct omap_soc {
	char			*compatible;
	struct board_dev	*devs;
	void			(*init)(void);
};

struct omap_soc omap_socs[] = {
	{
		"ti,omap3",
		omap3_dev,
		omap3_init,
	},
	{
		"ti,am33xx",
		am33xx_dev,
		am335x_init,
	},
	{
		"ti,omap4",
		omap4_dev,
		omap4_init,
	},
	{ NULL, NULL, NULL },
};

struct board_dev *
omap_board_devs(void)
{
	void *node;
	int i;

	node = fdt_find_node("/");
	if (node == NULL)
		return NULL;

	for (i = 0; omap_socs[i].compatible != NULL; i++) {
		if (fdt_is_compatible(node, omap_socs[i].compatible))
			return omap_socs[i].devs;
	}
	return NULL;
}

void
omap_board_init(void)
{
	void *node;
	int i;

	node = fdt_find_node("/");
	if (node == NULL)
		return;

	for (i = 0; omap_socs[i].compatible != NULL; i++) {
		if (fdt_is_compatible(node, omap_socs[i].compatible)) {
			omap_socs[i].init();
			break;
		}
	}
}

int
omap_match(struct device *parent, void *cfdata, void *aux)
{
	union mainbus_attach_args *ma = (union mainbus_attach_args *)aux;
	struct cfdata *cf = (struct cfdata *)cfdata;

	if (ma->ma_name == NULL)
		return (0);

	if (strcmp(cf->cf_driver->cd_name, ma->ma_name) != 0)
		return (0);

	return (omap_board_devs() != NULL);
}
@


1.20
log
@Disable sitaracm and add a new ompinmux driver for omap pin muxing/pad
configuration that attaches with the fdt and writes values to registers
based on the pinctrl data in the fdt.  Handles 16 bit values
(OMAP3/OMAP4) and 32 bit values (AM335x/AM57xx).

Feedback from and ok kettenis@@ tom@@ on an earlier version.
@
text
@d1 1
a1 1
/* $OpenBSD: omap.c,v 1.19 2016/08/11 04:33:06 jsg Exp $ */
a49 1
	{ "edma",	0 },
@


1.19
log
@Dynamically attach omgpio(4) using the FDT.

am335x has a compatible string of "ti,omap4-gpio" and has the same
offsets as omap4, so combine the omap4 and am335x cases when setting up
function pointers.
@
text
@d1 1
a1 1
/* $OpenBSD: omap.c,v 1.18 2016/08/11 01:53:18 jsg Exp $ */
a49 1
	{ "sitaracm",	0 },
@


1.18
log
@Dynamically attach omehci using the FDT.
ok kettenis@@ patrick@@
@
text
@d1 1
a1 1
/* $OpenBSD: omap.c,v 1.17 2016/08/06 10:07:45 jsg Exp $ */
a44 6
	{ "omgpio",	0 },
	{ "omgpio",	1 },
	{ "omgpio",	2 },
	{ "omgpio",	3 },
	{ "omgpio",	4 },
	{ "omgpio",	5 },
a53 4
	{ "omgpio",	0 },
	{ "omgpio",	1 },
	{ "omgpio",	2 },
	{ "omgpio",	3 },
a59 6
	{ "omgpio",	0 },
	{ "omgpio",	1 },
	{ "omgpio",	2 },
	{ "omgpio",	3 },
	{ "omgpio",	4 },
	{ "omgpio",	5 },
@


1.17
log
@Dynamically attach intc(4) using the FDT and switch omap/am335x
drivers that use the FDT over to the FDT interrupt establish API.

ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: omap.c,v 1.16 2016/07/10 03:04:00 jsg Exp $ */
a75 1
	{ "ehci",	0 },
@


1.16
log
@Instead of attaching the omap device based on board ids follow imx
and match based on the compatible property of the root node in the fdt.

Each of am33xx, omap3, and omap4 have their own list of devices to
attach.
@
text
@d1 1
a1 1
/* $OpenBSD: omap.c,v 1.15 2016/06/26 09:06:35 jsg Exp $ */
a42 1
	{ "intc",	0 },
a56 1
	{ "intc",	0 },
@


1.15
log
@Dynamically attach cpsw(4) with the FDT.
@
text
@d1 1
a1 1
/* $OpenBSD: omap.c,v 1.14 2016/06/26 07:25:05 jsg Exp $ */
d26 2
d41 1
a41 1
struct board_dev beagleboard_devs[] = {
d55 1
a55 1
struct board_dev beaglebone_devs[] = {
d69 2
a70 1
struct board_dev overo_devs[] = {
a71 3
	{ "intc",	0 },
	{ "gptimer",	0 },
	{ "gptimer",	1 },
d78 1
d82 4
a85 11
struct board_dev pandaboard_devs[] = {
	{ "omapid",	0 },
	{ "prcm",	0 },
	{ "omgpio",	0 },
	{ "omgpio",	1 },
	{ "omgpio",	2 },
	{ "omgpio",	3 },
	{ "omgpio",	4 },
	{ "omgpio",	5 },
	{ "ehci",	0 },
	{ NULL,		0 }
d88 1
a88 1
struct armv7_board omap_boards[] = {
d90 2
a91 2
		BOARD_ID_OMAP3_BEAGLE,
		beagleboard_devs,
d95 2
a96 2
		BOARD_ID_AM335X_BEAGLEBONE,
		beaglebone_devs,
d100 2
a101 7
		BOARD_ID_OMAP3_OVERO,
		overo_devs,
		omap3_init,
	},
	{
		BOARD_ID_OMAP4_PANDA,
		pandaboard_devs,
d104 1
a104 1
	{ 0, NULL, NULL },
d110 1
d113 7
a119 3
	for (i = 0; omap_boards[i].board_id != 0; i++) {
		if (omap_boards[i].board_id == board_id)
			return (omap_boards[i].devs);
d121 1
a121 1
	return (NULL);
d127 1
d130 7
a136 3
	for (i = 0; omap_boards[i].board_id != 0; i++) {
		if (omap_boards[i].board_id == board_id) {
			omap_boards[i].init();
@


1.14
log
@Dynamically attach tiiic using the FDT.

Only match on omap4 compatible controllers such as the one in the
am335x on bbb.  omap3 has different register offsets and a different
compatible string.

This reuses kettenis' fdt i2c scan function from imxiic(4).
@
text
@d1 1
a1 1
/* $OpenBSD: omap.c,v 1.13 2016/06/26 05:16:33 jsg Exp $ */
a63 1
	{ "cpsw",	0 },
@


1.13
log
@Dynamically attach omdog(4) using the FDT.
@
text
@d1 1
a1 1
/* $OpenBSD: omap.c,v 1.12 2016/06/19 14:27:35 jsg Exp $ */
a63 3
	{ "tiiic",	0 },
	{ "tiiic",	1 },
	{ "tiiic",	2 },
@


1.12
log
@dynamically attach omap uart with fdt
@
text
@d1 1
a1 1
/* $OpenBSD: omap.c,v 1.11 2016/06/18 05:59:26 jsg Exp $ */
a43 1
	{ "omdog",	0 },
a59 1
	{ "omdog",	0 },
a75 1
	{ "omdog",	0 },
a87 1
	{ "omdog",	0 },
@


1.11
log
@Dynamically attach ommmc with fdt.  Offset the start of the memory region
by 0x100 for nodes compatible with "ti,omap4-hsmmc" to get the same
offsets as omap3.  Handle both the nintr 1 (omap3/am335x) and nintr 3
(omap4) cases in attach.  Ideally the "interrupts" property will be
handled by the interrupt controller drivers directly in future.
@
text
@d1 1
a1 1
/* $OpenBSD: omap.c,v 1.10 2016/06/04 18:09:16 jsg Exp $ */
a50 1
	{ "com",	2 },		/* UART3 */
a68 1
	{ "com",	0 },		/* UART0 */
a84 1
	{ "com",	2 },		/* UART3 */
a97 1
	{ "com",	2 },		/* UART3 */
@


1.10
log
@Remove model specific strings keyed off the board id.
We now pull the model string from fdt.
@
text
@d1 1
a1 1
/* $OpenBSD: omap.c,v 1.9 2016/05/02 15:27:24 patrick Exp $ */
a50 1
	{ "ommmc",	0 },		/* HSMMC1 */
a69 2
	{ "ommmc",	0 },		/* HSMMC0 */
	{ "ommmc",	1 },		/* HSMMC1 */
a86 1
	{ "ommmc",	0 },		/* HSMMC1 */
a100 1
	{ "ommmc",	0 },		/* HSMMC1 */
@


1.9
log
@Add check to armv7 platform bus match code, so that those busses only
attach if we are running in legacy mode.

ok jsg@@
@
text
@d1 1
a1 1
/* $OpenBSD: omap.c,v 1.8 2016/02/02 03:31:22 jsg Exp $ */
a113 1
		"TI OMAP3 BeagleBoard",
a118 1
		"TI AM335x BeagleBone",
a123 1
		"Gumstix OMAP3 Overo",
a128 1
		"TI OMAP4 PandaBoard",
d132 1
a132 1
	{ 0, NULL, NULL, NULL },
d140 1
a140 1
	for (i = 0; omap_boards[i].name != NULL; i++) {
d152 1
a152 1
	for (i = 0; omap_boards[i].name != NULL; i++) {
a157 12
}

const char *
omap_board_name(void)
{
	int i;

	for (i = 0; omap_boards[i].name != NULL; i++) {
		if (omap_boards[i].board_id == board_id)
			return (omap_boards[i].name);
	}
	return (NULL);
@


1.8
log
@remove uneeded break statements
@
text
@d1 1
a1 1
/* $OpenBSD: omap.c,v 1.7 2015/05/20 00:14:56 jsg Exp $ */
d23 1
d179 9
@


1.7
log
@add per soc match functions instead of using armv7_match
@
text
@d1 1
a1 1
/* $OpenBSD: omap.c,v 1.6 2015/05/19 03:30:54 jsg Exp $ */
d169 1
a169 1
		if (omap_boards[i].board_id == board_id) {
a170 2
			break;
		}
@


1.6
log
@Abstract the soc_machdep.c functions to allow a kernel to be built for
multiple socs.

From Patrick Wildt in bitrig with some additional changes.
@
text
@d1 1
a1 1
/* $OpenBSD: omap.c,v 1.5 2015/05/15 15:35:43 jsg Exp $ */
d25 4
a28 3
void omap3_init();
void omap4_init();
void am335x_init();
d31 1
a31 1
	sizeof(struct armv7_softc), armv7_match, armv7_attach
d175 6
@


1.5
log
@Make board attaching table driven and move it out into the soc
directories.  Move the device tables while here as was done in bitrig.
With these changes the only use of the board id defines is in the soc
directories.

Tested by matthieu and djm on imx and myself on omap and sunxi (qemu).
ok djm@@, ok jasper@@ on an earlier version
@
text
@d1 1
a1 1
/* $OpenBSD: omap.c,v 1.4 2013/11/06 19:03:07 syl Exp $ */
d25 4
d138 13
a150 1
omap_board_attach(void)
a156 1
			return (omap_boards[i].devs);
a159 1
	return (NULL);
@


1.4
log
@After factorizing armv7_machdep code here is an effort to factorize all
the code present in omap/omap.c imx/imx.c and sunxi/sunxi.c

All this code looks quite the same, so we move it in a generic armv7/armv7.c

This is a step closer to only one kernel for all armv7 boards.

ok patrick@@, rapha@@
@
text
@d1 1
a1 1
/* $OpenBSD: omap.c,v 1.3 2013/10/10 19:40:02 syl Exp $ */
d33 128
@


1.3
log
@Add edma driver. This driver add support for am335x edma3 controller.

With some more work, it will allow us to speed-up ommmc driver.

ok patrick@@.
@
text
@d1 1
a1 1
/* $OpenBSD: omap.c,v 1.2 2013/09/12 12:03:15 rapha Exp $ */
d20 1
a20 4
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/reboot.h>
#define _ARM32_BUS_DMA_PRIVATE
a21 21
#include <arch/arm/armv7/armv7var.h>
#include <armv7/omap/omapvar.h>

struct arm32_bus_dma_tag omap_bus_dma_tag = {
	0,
	0,
	NULL,
	_bus_dmamap_create,
	_bus_dmamap_destroy,
	_bus_dmamap_load,
	_bus_dmamap_load_mbuf,
	_bus_dmamap_load_uio,
	_bus_dmamap_load_raw,
	_bus_dmamap_unload,
	_bus_dmamap_sync,
	_bus_dmamem_alloc,
	_bus_dmamem_free,
	_bus_dmamem_map,
	_bus_dmamem_unmap,
	_bus_dmamem_mmap,
};
d23 1
a23 81
struct board_dev {
	char *name;
	int unit;
};

struct board_dev beagleboard_devs[] = {
	{ "prcm",	0 },
	{ "intc",	0 },
	{ "gptimer",	0 },
	{ "gptimer",	1 },
	{ "omdog",	0 },
	{ "omgpio",	0 },
	{ "omgpio",	1 },
	{ "omgpio",	2 },
	{ "omgpio",	3 },
	{ "omgpio",	4 },
	{ "omgpio",	5 },
	{ "ommmc",	0 },		/* HSMMC1 */
	{ "com",	2 },		/* UART3 */
	{ NULL,		0 }
};

struct board_dev beaglebone_devs[] = {
	{ "prcm",	0 },
	{ "sitaracm",	0 },
	{ "intc",	0 },
	{ "edma",	0 },
	{ "dmtimer",	0 },
	{ "dmtimer",	1 },
	{ "omdog",	0 },
	{ "ommmc",	0 },		/* HSMMC0 */
	{ "ommmc",	1 },		/* HSMMC1 */
	{ "com",	0 },		/* UART0 */
	{ "cpsw",	0 },
	{ NULL,		0 }
};

struct board_dev overo_devs[] = {
	{ "prcm",	0 },
	{ "intc",	0 },
	{ "gptimer",	0 },
	{ "gptimer",	1 },
	{ "omdog",	0 },
	{ "omgpio",	0 },
	{ "omgpio",	1 },
	{ "omgpio",	2 },
	{ "omgpio",	3 },
	{ "omgpio",	4 },
	{ "omgpio",	5 },
	{ "ommmc",	0 },		/* HSMMC1 */
	{ "com",	2 },		/* UART3 */
	{ NULL,		0 }
};

struct board_dev pandaboard_devs[] = {
	{ "omapid",	0 },
	{ "prcm",	0 },
	{ "omdog",	0 },
	{ "omgpio",	0 },
	{ "omgpio",	1 },
	{ "omgpio",	2 },
	{ "omgpio",	3 },
	{ "omgpio",	4 },
	{ "omgpio",	5 },
	{ "ommmc",	0 },		/* HSMMC1 */
	{ "com",	2 },		/* UART3 */
	{ "ehci",	0 },
	{ NULL,		0 }
};

struct board_dev *board_devs;

struct omap_dev *omap_devs = NULL;

struct omap_softc {
	struct device sc_dv;
};

int	omap_match(struct device *, void *, void *);
void	omap_attach(struct device *, struct device *, void *);
int	omap_submatch(struct device *, void *, void *);
d26 1
a26 1
	sizeof(struct omap_softc), omap_match, omap_attach
a32 98
int
omap_match(struct device *parent, void *cfdata, void *aux)
{
	return (1);
}

void
omap_attach(struct device *parent, struct device *self, void *aux)
{
	struct board_dev *bd;

	switch (board_id) {
	case BOARD_ID_OMAP3_BEAGLE:
		printf(": BeagleBoard\n");
		omap3_init();
		board_devs = beagleboard_devs;
		break;
	case BOARD_ID_AM335X_BEAGLEBONE:
		printf(": BeagleBone\n");
		am335x_init();
		board_devs = beaglebone_devs;
		break;
	case BOARD_ID_OMAP3_OVERO:
		printf(": Gumstix Overo\n");
		omap3_init();
		board_devs = overo_devs;
		break;
	case BOARD_ID_OMAP4_PANDA:
		printf(": PandaBoard\n");
		omap4_init();
		board_devs = pandaboard_devs;
		break;
	default:
		printf("\n");
		panic("%s: board type 0x%x unknown", __func__, board_id);
	}

	/* Directly configure on-board devices (dev* in config file). */
	for (bd = board_devs; bd->name != NULL; bd++) {
		struct omap_dev *od = omap_find_dev(bd->name, bd->unit);
		struct omap_attach_args oa;

		if (od == NULL) {
			printf("%s: device %s unit %d not found\n",
			    self->dv_xname, bd->name, bd->unit);
			continue;
		}

		memset(&oa, 0, sizeof(oa));
		oa.oa_dev = od;
		oa.oa_iot = &armv7_bs_tag;
		oa.oa_dmat = &omap_bus_dma_tag;

		if (config_found_sm(self, &oa, NULL, omap_submatch) == NULL)
			printf("%s: device %s unit %d not configured\n",
			    self->dv_xname, bd->name, bd->unit);
	}
}

/*
 * We do direct configuration of devices on this SoC "bus", so we
 * never call the child device's match function at all (it can be
 * NULL in the struct cfattach).
 */
int
omap_submatch(struct device *parent, void *child, void *aux)
{
	struct cfdata *cf = child;
	struct omap_attach_args *oa = aux;

	if (strcmp(cf->cf_driver->cd_name, oa->oa_dev->name) == 0)
		return (1);

	/* "These are not the droids you are looking for." */
	return (0);
}

void
omap_set_devs(struct omap_dev *devs)
{
	omap_devs = devs;
}

struct omap_dev *
omap_find_dev(const char *name, int unit)
{
	struct omap_dev *od;

	if (omap_devs == NULL)
		panic("%s: omap_devs == NULL", __func__);

	for (od = omap_devs; od->name != NULL; od++) {
		if (od->unit == unit && strcmp(od->name, name) == 0)
			return (od);
	}

	return (NULL);
}
@


1.2
log
@Enable the eMMC on the BeagleBone Black.

ok patrick@@
@
text
@d1 1
a1 1
/* $OpenBSD: omap.c,v 1.1 2013/09/04 14:38:30 patrick Exp $ */
d73 1
@


1.1
log
@In the future, we shouldn't have one port port ARM SoC, that's just
ridiculous.  This is the first step for a common and generic ARM port
for ARMv7 SoCs.
@
text
@d1 1
a1 1
/* $OpenBSD: omap.c,v 1.10 2013/06/14 23:13:54 patrick Exp $ */
d77 1
@

