head	1.9;
access;
symbols
	SMP_SYNC_A:1.9
	SMP_SYNC_B:1.9
	UBC_SYNC_A:1.9
	UBC_SYNC_B:1.9
	OPENBSD_2_8:1.8.0.2
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.7.0.10
	OPENBSD_2_7_BASE:1.7
	SMP:1.7.0.8
	SMP_BASE:1.7
	kame_19991208:1.7
	OPENBSD_2_6:1.7.0.6
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.4
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.2
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.4.0.2
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.3.0.2
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	WGRISC_1_0:1.1.1.1
	PEFO:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2001.02.07.07.47.06;	author art;	state dead;
branches;
next	1.8;

1.8
date	2000.09.26.14.03.55;	author art;	state Exp;
branches;
next	1.7;

1.7
date	98.09.25.09.20.55;	author todd;	state Exp;
branches
	1.7.8.1;
next	1.6;

1.6
date	98.07.07.06.56.15;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	98.07.07.03.02.51;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.11.23.05.22.00;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	97.08.24.12.01.15;	author pefo;	state Exp;
branches;
next	1.2;

1.2
date	97.02.23.21.59.33;	author pefo;	state Exp;
branches;
next	1.1;

1.1
date	97.02.06.16.02.45;	author pefo;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	97.02.06.16.02.45;	author pefo;	state Exp;
branches;
next	;

1.7.8.1
date	2001.05.14.21.40.06;	author niklas;	state dead;
branches;
next	;


desc
@@


1.9
log
@We need to loose some weight.
If someone feels very opposed to this, the code is left in the Attic.
Just revive and _make_it_work_.
@
text
@/*	$OpenBSD: conf.c,v 1.8 2000/09/26 14:03:55 art Exp $ */

/*
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Ralph Campbell.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	from: @@(#)conf.c	8.2 (Berkeley) 11/14/93
 *      $Id: conf.c,v 1.8 2000/09/26 14:03:55 art Exp $
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/ioctl.h>
#include <sys/proc.h>
#include <sys/vnode.h>
#include <sys/tty.h>
#include <sys/conf.h>

int	ttselect	__P((dev_t, int, struct proc *));

/*
 *	Block devices.
 */

#include "vnd.h"
bdev_decl(vnd);
bdev_decl(sw);
#include "sd.h"
bdev_decl(sd);
#include "cd.h"
bdev_decl(cd);
#if notyet
#include "fdc.h"
bdev_decl(fd);
#endif
#include "wdc.h"
bdev_decl(wd);
#include "acd.h"
bdev_decl(acd);
#include "fl.h"
bdev_decl(fl);

struct bdevsw	bdevsw[] =
{
	bdev_disk_init(NSD,sd),		/* 0: SCSI disk */
	bdev_swap_init(1,sw),		/* 1: should be here swap pseudo-dev */
	bdev_disk_init(NVND,vnd),	/* 2: vnode disk driver */
	bdev_disk_init(NCD,cd),		/* 3: SCSI CD-ROM */
	bdev_disk_init(NWDC,wd),	/* 4: ST506/ESDI/IDE disk */
	bdev_disk_init(NACD,cd),	/* 5: ATAPI CD-ROM */
	bdev_notdef(),			/* 6:  */
	bdev_notdef(),			/* 7: Floppy disk driver */
	bdev_notdef(),			/* 8:  */
	bdev_notdef(),			/* 9:  */
	bdev_disk_init(NFL,fl),		/* 10: Flash ram disk driver */
	bdev_notdef(),			/* 11:  */
	bdev_notdef(),			/* 12:  */
	bdev_notdef(),			/* 13:  */
	bdev_notdef(),			/* 14:  */
	bdev_notdef(),			/* 15:  */
};

int	nblkdev = sizeof (bdevsw) / sizeof (bdevsw[0]);

/*
 *	Character devices.
 */


cdev_decl(cn);
cdev_decl(sw);
cdev_decl(ctty);
cdev_decl(random);
#define mmread mmrw
#define mmwrite mmrw
dev_type_read(mmrw);
cdev_decl(mm);
#include "pty.h"
#define	ptstty		ptytty
#define	ptsioctl	ptyioctl
cdev_decl(pts);
#define	ptctty		ptytty
#define	ptcioctl	ptyioctl
cdev_decl(ptc);
cdev_decl(log);
cdev_decl(fd);
#include "st.h"
cdev_decl(st);
cdev_decl(vnd);
#include "bpfilter.h"
cdev_decl(bpf);
#include "com.h"
cdev_decl(com);
cdev_decl(sd);
cdev_decl(cd);
#include "uk.h"
cdev_decl(uk);
cdev_decl(wd);
cdev_decl(acd);
cdev_decl(fl);

#ifdef XFS
#include <xfs/nxfs.h>
cdev_decl(xfs_dev);
#endif

#ifdef IPFILTER
#define NIPF 1
#else
#define NIPF 0
#endif

struct cdevsw	cdevsw[] =
{
	cdev_cn_init(1,cn),		/* 0: virtual console */
	cdev_swap_init(1,sw),		/* 1: /dev/drum (swap pseudo-device) */
	cdev_ctty_init(1,ctty),		/* 2: controlling terminal */
	cdev_mm_init(1,mm),		/* 3: /dev/{null,mem,kmem,...} */
	cdev_tty_init(NPTY,pts),	/* 4: pseudo-tty slave */
	cdev_ptc_init(NPTY,ptc),	/* 5: pseudo-tty master */
	cdev_log_init(1,log),		/* 6: /dev/klog */
	cdev_fd_init(1,filedesc),	/* 7: file descriptor pseudo-dev */
	cdev_disk_init(NCD,cd),		/* 8: SCSI CD */
	cdev_disk_init(NSD,sd),		/* 9: SCSI disk */
	cdev_tape_init(NST,st),		/* 10: SCSI tape */
	cdev_disk_init(NVND,vnd),	/* 11: vnode disk */
	cdev_bpftun_init(NBPFILTER,bpf),/* 12: berkeley packet filter */
	cdev_notdef(),			/* 13: Floppy disk */
	cdev_notdef(),			/* 14: builtin pc style console dev */
	cdev_notdef(),			/* 15: builtin PS2 style mouse */
	cdev_notdef(),			/* 16: lpt paralell printer interface */
	cdev_tty_init(NCOM,com),	/* 17: com 16C450 serial interface */
	cdev_disk_init(NWDC,wd),	/* 18: ST506/ESDI/IDE disk */
	cdev_disk_init(NACD,acd),	/* 19: ATAPI CD-ROM */
	cdev_tty_init(NPTY,pts),	/* 20: pseudo-tty slave */
	cdev_ptc_init(NPTY,ptc),	/* 21: pseudo-tty master */
	cdev_disk_init(NFL,fl),		/* 22: Flash memory driver */
	cdev_notdef(),			/* 23: */
	cdev_notdef(),			/* 24: */
	cdev_notdef(),			/* 25: */
	cdev_notdef(),			/* 26: */
	cdev_notdef(),			/* 27: */
	cdev_notdef(),			/* 28: */
	cdev_notdef(),			/* 29: */
	cdev_notdef(),			/* 30: */
	cdev_gen_ipf(NIPF,ipl),         /* 31: IP filter log */
	cdev_uk_init(NUK,uk),		/* 32: unknown SCSI */
	cdev_random_init(1,random),	/* 33: random data source */
	cdev_notdef(),			/* 34: */
	cdev_notdef(),			/* 35: */
	cdev_notdef(),			/* 36: */
	cdev_notdef(),			/* 37: */
	cdev_notdef(),			/* 38: */
	cdev_notdef(),			/* 39: */
	cdev_notdef(),			/* 30: */
	cdev_notdef(),			/* 41: */
	cdev_notdef(),			/* 42: */
	cdev_notdef(),			/* 43: */
	cdev_notdef(),			/* 44: */
	cdev_notdef(),			/* 45: */
	cdev_notdef(),			/* 46: */
	cdev_notdef(),			/* 47: */
	cdev_notdef(),			/* 48: */
	cdev_notdef(),			/* 49: */
	cdev_notdef(),			/* 50: */
#ifdef XFS
	cdev_xfs_init(NXFS,xfs_dev),	/* 51: xfs communication device */
#else
	cdev_notdef(),			/* 51: */
#endif
};

int	nchrdev = sizeof (cdevsw) / sizeof (cdevsw[0]);

int	mem_no = 2; 	/* major device number of memory special file */

/*
 * Swapdev is a fake device implemented
 * in sw.c used only internally to get to swstrategy.
 * It cannot be provided to the users, because the
 * swstrategy routine munches the b_dev and b_blkno entries
 * before calling the appropriate driver.  This would horribly
 * confuse, e.g. the hashing routines. Instead, /dev/drum is
 * provided as a character (raw) device.
 */
dev_t	swapdev = makedev(1, 0);

/*
 * Routine that identifies /dev/mem and /dev/kmem.
 *
 * A minimal stub routine can always return 0.
 */
iskmemdev(dev)
	dev_t dev;
{

#ifdef COMPAT_BSD44
	if (major(dev) == 2 && (minor(dev) == 0 || minor(dev) == 1))
#else
	if (major(dev) == 3 && (minor(dev) == 0 || minor(dev) == 1))
#endif
		return (1);
	return (0);
}

/*
 * Returns true if def is /dev/zero
 */
iszerodev(dev)
	dev_t dev;
{
#ifdef COMPAT_BSD44
	return (major(dev) == 2 && minor(dev) == 12);
#else
	return (major(dev) == 3 && minor(dev) == 12);
#endif
}

dev_t
getnulldev()
{
	return makedev(3, 2);
}


static int chrtoblktbl[] =  {
      /* VCHR */      /* VBLK */
	/* 0 */		NODEV,
	/* 1 */		NODEV,
	/* 2 */		NODEV,
	/* 3 */		NODEV,
	/* 4 */		NODEV,
	/* 5 */		NODEV,
	/* 6 */		NODEV,
	/* 7 */		NODEV,
	/* 8 */		NODEV,
	/* 9 */		0,
	/* 10 */	NODEV,
	/* 11 */	2,
	/* 12 */	NODEV,
	/* 13 */	7,
	/* 14 */	NODEV,
	/* 15 */	NODEV,
	/* 16 */	NODEV,
	/* 17 */	NODEV,
	/* 18 */	4,
	/* 19 */	5,
	/* 20 */	NODEV,
	/* 21 */	NODEV,
	/* 22 */	10,
};

/*
 * Routine to convert from character to block device number.
 *
 * A minimal stub routine can always return NODEV.
 */
chrtoblk(dev)
	dev_t dev;
{
	int blkmaj;

	if (major(dev) >= nchrdev ||
	    major(dev) > sizeof(chrtoblktbl)/sizeof(chrtoblktbl[0]))
		return (NODEV);
	blkmaj = chrtoblktbl[major(dev)];
	if (blkmaj == NODEV)
		return (NODEV);
	return (makedev(blkmaj, minor(dev)));
}

/*
 * Convert a character device number to a block device number.
 */
dev_t
blktochr(dev)
	dev_t dev;
{
	int blkmaj = major(dev);
	int i;

	if (blkmaj >= nblkdev)
		return (NODEV);
	for (i = 0; i < sizeof(chrtoblktbl)/sizeof(chrtoblktbl[0]); i++)
		if (blkmaj == chrtoblktbl[i])
			return (makedev(i, minor(dev)));
	return (NODEV);
}

/*
 * This entire table could be autoconfig()ed but that would mean that
 * the kernel's idea of the console would be out of sync with that of
 * the standalone boot.  I think it best that they both use the same
 * known algorithm unless we see a pressing need otherwise.
 */
#include <dev/cons.h>

cons_decl(pc);
cons_decl(com);

struct	consdev constab[] = {
#if NPC + NVT > 0
	cons_init(pc),
#endif
#if NCOM > 0
	cons_init(com),
#endif
	{ 0 },
};
@


1.8
log
@Implement getnulldev that returns the dev_t for "/dev/null".
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.c,v 1.7 1998/09/25 09:20:55 todd Exp $ */
d39 1
a39 1
 *      $Id: conf.c,v 1.7 1998/09/25 09:20:55 todd Exp $
@


1.7
log
@o xfs is in the house (thanks art, for getting me started)
o all but vax are major 51
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.c,v 1.6 1998/07/07 06:56:15 deraadt Exp $ */
d39 1
a39 1
 *      $Id: conf.c,v 1.6 1998/07/07 06:56:15 deraadt Exp $
d249 6
@


1.7.8.1
log
@Continue the aborted merge of current just before 2.9 was cut into the
SMP branch.  Note that this will not make any progress of SMP functionality,
it is just merging of new code from the trunk into the old branch.
Please do not ask me questions about SMP status because of this mail,
instead go read the archives of smp@@openbsd.org, where I mailed about
these commits some week ago.  Another note: I am doing this in chunks now,
so as to not lock too much of the tree for long times
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.c,v 1.7 1998/09/25 09:20:55 todd Exp $ */
d39 1
a39 1
 *      $Id: conf.c,v 1.7 1998/09/25 09:20:55 todd Exp $
@


1.6
log
@oops, i did not handle nchrdev correctly
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.c,v 1.5 1998/07/07 03:02:51 deraadt Exp $ */
d39 1
a39 1
 *      $Id: conf.c,v 1.5 1998/07/07 03:02:51 deraadt Exp $
d134 4
d181 22
@


1.5
log
@fix chrtoblk() so that it returne ENODEV for entries beyond the end of the table
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.c,v 1.4 1997/11/23 05:22:00 mickey Exp $ */
d39 1
a39 1
 *      $Id: conf.c,v 1.4 1997/11/23 05:22:00 mickey Exp $
d226 1
a226 2
#define MAXDEV	57
static int chrtoblktbl[MAXDEV] =  {
d263 1
a263 1
	if (major(dev) >= MAXDEV ||
@


1.4
log
@use MI cdev_decl(ipl)
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.c,v 1.3 1997/08/24 12:01:15 pefo Exp $ */
d39 1
a39 1
 *      $Id: conf.c,v 1.3 1997/08/24 12:01:15 pefo Exp $
a251 34
	/* 23 */	NODEV,
	/* 24 */	NODEV,
	/* 25 */	NODEV,
	/* 26 */	NODEV,
	/* 27 */	NODEV,
	/* 28 */	NODEV,
	/* 29 */	NODEV,
	/* 30 */	NODEV,
	/* 31 */	NODEV,
	/* 32 */	NODEV,
	/* 33 */	NODEV,
	/* 34 */	NODEV,
	/* 35 */	NODEV,
	/* 36 */	NODEV,
	/* 37 */	NODEV,
	/* 38 */	NODEV,
	/* 39 */	NODEV,
	/* 40 */	NODEV,
	/* 41 */	NODEV,
	/* 42 */	NODEV,
	/* 43 */	NODEV,
	/* 44 */	NODEV,
	/* 45 */	NODEV,
	/* 46 */	NODEV,
	/* 47 */	NODEV,
	/* 48 */	NODEV,
	/* 49 */	NODEV,
	/* 50 */	NODEV,
	/* 51 */	NODEV,
	/* 52 */	NODEV,
	/* 53 */	NODEV,
	/* 54 */	NODEV,
	/* 55 */	NODEV,
	/* 56 */	NODEV,
d253 1
d264 5
a268 1
	if (major(dev) >= MAXDEV || (blkmaj = chrtoblktbl[major(dev)]) == NODEV)
@


1.3
log
@New stuff
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.c,v 1.2 1997/02/23 21:59:33 pefo Exp $ */
d39 1
a39 1
 *      $Id: conf.c,v 1.2 1997/02/23 21:59:33 pefo Exp $
a134 2
/* open, close, read, ioctl */
cdev_decl(ipl);
@


1.2
log
@First cut of Flash memory disk. Needs more work though...
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.c,v 1.1.1.1 1997/02/06 16:02:45 pefo Exp $ */
d39 1
a39 1
 *      $Id: conf.c,v 1.1.1.1 1997/02/06 16:02:45 pefo Exp $
d72 2
a73 2
#include "flash.h"
bdev_decl(flash);
d87 1
a87 1
	bdev_disk_init(NFLASH,flash),	/* 10: Flash ram disk driver */
d132 1
a132 1
cdev_decl(flash);
d167 1
a167 1
	cdev_disk_init(NFLASH,flash),	/* 22: Flash memory driver */
d253 1
a253 1
	/* 22 */	NODEV,
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.c,v 1.7 1996/10/19 13:26:04 mickey Exp $ */
d39 1
a39 1
 *      $Id: conf.c,v 1.7 1996/10/19 13:26:04 mickey Exp $
d72 2
d87 1
a87 1
	bdev_notdef(),			/* 10:  */
a100 17
/* open, close, read, write, ioctl, tty, mmap */
#define cdev_pc_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
	dev_init(c,n,write), dev_init(c,n,ioctl), dev_init(c,n,stop), \
	dev_init(c,n,tty), ttselect, dev_init(c,n,mmap), D_TTY }

/* open, close, write, ioctl */
#define	cdev_lpt_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), (dev_type_read((*))) enodev, \
	dev_init(c,n,write), dev_init(c,n,ioctl), (dev_type_stop((*))) enodev, \
	0, seltrue, (dev_type_mmap((*))) enodev }

/* open, close, write, ioctl */
#define	cdev_spkr_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), (dev_type_read((*))) enodev, \
	dev_init(c,n,write), dev_init(c,n,ioctl), (dev_type_stop((*))) enodev, \
	0, seltrue, (dev_type_mmap((*))) enodev }
a120 4
#ifdef notyet
#include "fdc.h"
bdev_decl(fd);
#endif
a125 2
#include "lpt.h"
cdev_decl(lpt);
a126 5
#ifdef notyet
#include "pc.h"
cdev_decl(pc);
cdev_decl(pms);
#endif
d132 2
d161 1
a161 1
	cdev_lpt_init(NLPT,lpt),	/* 16: lpt paralell printer interface */
d167 1
a167 1
	cdev_notdef(),			/* 22: */
@


1.1.1.1
log
@Import of WGRISC port. (Willowglen R3081 board)
@
text
@@
