head	1.15;
access;
symbols
	OPENBSD_4_9:1.14.0.4
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.14.0.2
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.12.0.2
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.11.0.10
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.6
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.4
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.2
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.10.0.14
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.12
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.10
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.10.0.8
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.6
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.4
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.10.0.2
	OPENBSD_3_6_BASE:1.10
	SMP_SYNC_A:1.10
	SMP_SYNC_B:1.10
	OPENBSD_3_5:1.9.0.2
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.8.0.2
	OPENBSD_3_4_BASE:1.8
	UBC_SYNC_A:1.6
	OPENBSD_3_3:1.6.0.4
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4
	UBC_SYNC_B:1.6
	UBC:1.2.0.2
	UBC_BASE:1.2
	OPENBSD_3_0:1.1.0.4
	OPENBSD_3_0_BASE:1.1
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.15
date	2011.07.07.19.16.42;	author deraadt;	state dead;
branches;
next	1.14;

1.14
date	2010.06.28.14.13.30;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2010.04.12.12.57.52;	author tedu;	state Exp;
branches;
next	1.12;

1.12
date	2009.10.31.12.00.07;	author fgsch;	state Exp;
branches;
next	1.11;

1.11
date	2008.01.23.16.37.57;	author jsing;	state Exp;
branches;
next	1.10;

1.10
date	2004.05.14.20.38.32;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2004.01.14.20.50.48;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2003.08.15.20.32.14;	author tedu;	state Exp;
branches;
next	1.7;

1.7
date	2003.06.03.21.09.01;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2002.06.12.03.49.58;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2002.06.08.15.47.31;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2002.03.14.01.26.41;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2002.02.15.20.45.30;	author nordin;	state Exp;
branches;
next	1.2;

1.2
date	2001.11.06.22.45.54;	author miod;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2001.06.26.21.57.40;	author smurph;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2001.11.13.21.04.15;	author niklas;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2002.03.06.02.04.45;	author niklas;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2002.03.28.10.36.03;	author niklas;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2003.03.27.23.52.16;	author niklas;	state Exp;
branches;
next	1.1.2.5;

1.1.2.5
date	2003.06.07.11.13.18;	author ho;	state Exp;
branches;
next	1.1.2.6;

1.1.2.6
date	2004.02.19.10.49.09;	author niklas;	state Exp;
branches;
next	1.1.2.7;

1.1.2.7
date	2004.06.05.23.10.54;	author niklas;	state Exp;
branches;
next	;

1.2.2.1
date	2002.06.11.03.37.22;	author art;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2002.10.29.00.28.08;	author art;	state Exp;
branches;
next	;


desc
@@


1.15
log
@remove mvmeppc; it is really rough shape.  ok drahn miod
@
text
@/*	$OpenBSD: bugtty.c,v 1.14 2010/06/28 14:13:30 deraadt Exp $ */

/* Copyright (c) 1998 Steve Murphree, Jr.
 * Copyright (c) 1995 Dale Rahn.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/ioctl.h>
#include <sys/device.h>
#include <sys/tty.h>
#include <sys/proc.h>
#include <sys/uio.h>
#include <sys/queue.h>

#include <machine/autoconf.h>
#include <machine/bugio.h>
#include <machine/conf.h>
#include <machine/cpu.h>

#include <dev/cons.h>

#include "bugtty.h"

int bugttymatch(struct device *parent, void *self, void *aux);
void bugttyattach(struct device *parent, struct device *self, void *aux);

struct cfattach bugtty_ca = {
        sizeof(struct device), bugttymatch, bugttyattach
};

struct cfdriver bugtty_cd = {
        NULL, "bugtty", DV_TTY
};

/* prototypes */
cons_decl(bugtty);
cdev_decl(bugtty);

int bugttymctl(dev_t dev, int bits, int how);
int bugttyparam(struct tty *tp, struct termios *tm);
void bugtty_chkinput(void);

#define DIALOUT(x) ((x) & 0x80)
#define SWFLAGS(dev) (bugttyswflags | (DIALOUT(dev) ? TIOCFLAG_SOFTCAR : 0))

#define BUGBUF 80
char bugtty_ibuffer[BUGBUF+1];
volatile char *pinchar = bugtty_ibuffer;
char bug_obuffer[BUGBUF+1];

#define	BUGTTYS	4
struct tty *bugtty_tty[BUGTTYS];

int
bugttymatch(parent, self, aux)
	struct device *parent;
	void *self;
	void *aux;
{
	struct confargs *ca = aux;

	if (strcmp(ca->ca_name, bugtty_cd.cd_name) != 0)
		return (0);

	return (1);
}

void
bugttyattach(parent, self, aux)
	struct device *parent;
	struct device *self;
	void *aux;
{
	printf(": fallback console\n");
}

#define BUGTTYUNIT(x) ((x) & (0x7f))
void bugttyoutput(struct tty *tp);

int bugttydefaultrate = TTYDEF_SPEED;
int bugttyswflags;

struct tty *
bugttytty(dev)
	dev_t dev;
{
	int unit;
	unit = BUGTTYUNIT(dev);
	if (unit >= BUGTTYS) {
		return (NULL);
	}
	return bugtty_tty[unit];
}

int
bugttymctl(dev, bits, how)
	dev_t dev;
	int bits, how;
{
	int s;

	/*printf("mctl: dev %x, bits %x, how %x,",dev, bits, how);*/

	/* settings are currently ignored */
	s = spltty();
	switch (how) {
	case DMSET:
		break;
	case DMBIC:
		break;
	case DMBIS:
		break;
	case DMGET:
		break;
	}
	splx(s);

	bits = 0;
	/* proper defaults? */
	bits |= TIOCM_DTR;
	bits |= TIOCM_RTS;
	bits |= TIOCM_CTS;
	bits |= TIOCM_CD;
	/* bits |= TIOCM_RI; */
	bits |= TIOCM_DSR;

	/* printf("retbits %x\n", bits); */
	return (bits);
}

int
bugttyopen(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
{
	int s, unit = BUGTTYUNIT(dev);
	struct tty *tp;

	s = spltty();
	if (bugtty_tty[unit]) {
		tp = bugtty_tty[unit];
	} else {
		tp = bugtty_tty[unit] = ttymalloc(0);
	}
	tp->t_oproc = bugttyoutput;
	tp->t_param = NULL;
	tp->t_dev = dev;

	if ((tp->t_state & TS_ISOPEN) == 0) {
		tp->t_state |= TS_WOPEN;
		ttychars(tp);
		if (tp->t_ispeed == 0) {
			/*
			 * only when cleared do we reset to defaults.
			 */
			tp->t_iflag = TTYDEF_IFLAG;
			tp->t_oflag = TTYDEF_OFLAG;
			tp->t_cflag = TTYDEF_CFLAG;
			tp->t_lflag = TTYDEF_LFLAG;
			tp->t_ispeed = tp->t_ospeed = bugttydefaultrate;
		}
		/* bugtty does not have carrier */
		tp->t_cflag |= CLOCAL;
		/*
		 * do these all the time
		 */
		if (bugttyswflags & TIOCFLAG_CLOCAL)
			tp->t_cflag |= CLOCAL;
		if (bugttyswflags & TIOCFLAG_CRTSCTS)
			tp->t_cflag |= CRTSCTS;
		if (bugttyswflags & TIOCFLAG_MDMBUF)
			tp->t_cflag |= MDMBUF;
		bugttyparam(tp, &tp->t_termios);
		ttsetwater(tp);

		(void)bugttymctl(dev, TIOCM_DTR | TIOCM_RTS, DMSET);
		/*
		if ((SWFLAGS(dev) & TIOCFLAG_SOFTCAR) ||
		    (bugttymctl(dev, 0, DMGET) & TIOCM_CD))
			tp->t_state |= TS_CARR_ON;
		else
			tp->t_state &= ~TS_CARR_ON;
		*/
		tp->t_state |= TS_CARR_ON;
	} else if (tp->t_state & TS_XCLUDE && suser(p, 0) != 0) {
		splx(s);
		return (EBUSY);
	}

	/*
	 * if NONBLOCK requested, ignore carrier
	 */
/*
	if (flag & O_NONBLOCK)
		goto done;
*/

	splx(s);
	/*
	 * Reset the tty pointer, as there could have been a dialout
	 * use of the tty with a dialin open waiting.
	 */
	tp->t_dev = dev;
	return ((*linesw[tp->t_line].l_open)(dev, tp, p));
}

int
bugttyparam(tp, tm)
	struct tty *tp;
	struct termios *tm;
{
	return (0);
}

void
bugttyoutput(tp)
	struct tty *tp;
{
	int cc, s, cnt;

	/* only supports one unit */

	if ((tp->t_state & TS_ISOPEN) == 0)
		return;

	s = spltty();
	cc = tp->t_outq.c_cc;
	while (cc > 0) {
		cnt = min(BUGBUF, cc);
		cnt = q_to_b(&tp->t_outq, bug_obuffer, cnt);
		mvmeprom_outstr(bug_obuffer, &bug_obuffer[cnt]);
		cc -= cnt;
	}
	splx(s);
}

int
bugttyclose(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
{
	int unit = BUGTTYUNIT(dev);
	struct tty *tp = bugtty_tty[unit];

	(*linesw[tp->t_line].l_close)(tp, flag, p);

	ttyclose(tp);
#if 0
	bugtty_tty[unit] = NULL;
#endif
	return (0);
}

int
bugttyread(dev, uio, flag)
	dev_t dev;
	struct uio *uio;
	int flag;
{
	struct tty *tp;

	if ((tp = bugtty_tty[BUGTTYUNIT(dev)]) == NULL)
		return (ENXIO);
	return ((*linesw[tp->t_line].l_read)(tp, uio, flag));
}

/* only to be called at splclk() */
void
bugtty_chkinput()
{
	struct tty *tp;

	tp = bugtty_tty[0]; /* assumes console on the first port... */
	if (tp == NULL)
		return;

	while (mvmeprom_instat() != 0) {
		u_char c = mvmeprom_getchar() & 0xff;
		(*linesw[tp->t_line].l_rint)(c, tp);
	}
}

int
bugttywrite(dev, uio, flag)
	dev_t dev;
	struct uio *uio;
	int flag;
{
#if 0
	/* bypass tty output routines. */
	int i, cnt, s;
	int oldoff;

	s = spltty();
	oldoff = uio->uio_offset;
	do  {
		uiomove(bug_obuffer, BUGBUF, uio);
		bugoutstr(bug_obuffer, &bug_obuffer[uio->uio_offset - oldoff]);
		oldoff = uio->uio_offset;
	} while (uio->uio_resid != 0);
	splx(s);

	return (0);
#else
	struct tty *tp;
	if((tp = bugtty_tty[BUGTTYUNIT(dev)]) == NULL)
		return (ENXIO);
	return ((*linesw[tp->t_line].l_write)(tp, uio, flag));
#endif
}

int
bugttyioctl(dev, cmd, data, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
{
	int unit = BUGTTYUNIT(dev);
	struct tty *tp = bugtty_tty[unit];
	int error;

	if (!tp)
		return (ENXIO);

	error = (*linesw[tp->t_line].l_ioctl)(tp, cmd, data, flag, p);
	if (error >= 0)
		return (error);

	error = ttioctl(tp, cmd, data, flag, p);
	if (error >= 0)
		return (error);

	switch (cmd) {
	case TIOCSBRK:
		/* */
		break;

	case TIOCCBRK:
		/* */
		break;

	case TIOCSDTR:
		(void) bugttymctl(dev, TIOCM_DTR | TIOCM_RTS, DMBIS);
		break;

	case TIOCCDTR:
		(void) bugttymctl(dev, TIOCM_DTR | TIOCM_RTS, DMBIC);
		break;

	case TIOCMSET:
		(void) bugttymctl(dev, *(int *) data, DMSET);
		break;

	case TIOCMBIS:
		(void) bugttymctl(dev, *(int *) data, DMBIS);
		break;

	case TIOCMBIC:
		(void) bugttymctl(dev, *(int *) data, DMBIC);
		break;

	case TIOCMGET:
		*(int *)data = bugttymctl(dev, 0, DMGET);
		break;
	case TIOCGFLAGS:
		*(int *)data = SWFLAGS(dev);
		break;
	case TIOCSFLAGS:
		error = suser(p, 0);
		if (error != 0)
			return (EPERM);

		bugttyswflags = *(int *)data;
		bugttyswflags &= /* only allow valid flags */
		    (TIOCFLAG_SOFTCAR | TIOCFLAG_CLOCAL | TIOCFLAG_CRTSCTS);
		break;
	default:
		return (ENOTTY);
	}

	return (0);
}

int
bugttystop(tp, flag)
	struct tty *tp;
	int flag;
{
	int s;

	s = spltty();
	if (tp->t_state & TS_BUSY) {
		if ((tp->t_state & TS_TTSTOP) == 0)
			tp->t_state |= TS_FLUSH;
	}
	splx(s);
	return (0);
}

/*
 * bugtty is the last possible choice for a console device.
 */
void
bugttycnprobe(cp)
	struct consdev *cp;
{
	int maj;

	/* locate the major number */
	for (maj = 0; maj < nchrdev; maj++)
		if (cdevsw[maj].d_open == bugttyopen)
			break;

	cp->cn_dev = makedev(maj, 0);
	cp->cn_pri = CN_LOWPRI;
}

void
bugttycninit(cp)
	struct consdev *cp;
{
	/* Nothing to do */
}

int
bugttycngetc(dev)
	dev_t dev;
{
	return (mvmeprom_getchar());
}

void
bugttycnputc(dev, c)
	dev_t dev;
	char c;
{
	mvmeprom_outchar(c);
}
@


1.14
log
@Allow tty drivers to request larger buffers at attach time using a
max-baud-rate hint.  Adjust TTYHOG (the nearly full logic) to this new
situation.  The larger buffers are required by the very high speed
KDDI devices in Japan (CF com, or USB ucom) so those are the only two
drivers which currently ask for a larger buffer size.
ok yasuoka miod
@
text
@d1 1
a1 1
/*	$OpenBSD: bugtty.c,v 1.13 2010/04/12 12:57:52 tedu Exp $ */
@


1.13
log
@Some of the line disciplines want to check for suser.  Better to pass them
a process instead of using curproc.  ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: bugtty.c,v 1.12 2009/10/31 12:00:07 fgsch Exp $ */
d168 1
a168 1
		tp = bugtty_tty[unit] = ttymalloc();
@


1.12
log
@Use suser when possible. Suggested by miod@@.
miod@@ deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: bugtty.c,v 1.11 2008/01/23 16:37:57 jsing Exp $ */
d229 1
a229 1
	return ((*linesw[tp->t_line].l_open)(dev, tp));
d271 1
a271 1
	(*linesw[tp->t_line].l_close)(tp, flag);
@


1.11
log
@Cleanup cn_pri. Change constants to more meaningful names, rather than
the hp300 related ones currently in use. CN_NORMAL becomes CN_LOWPRI,
CN_INTERNAL becomes CN_MIDPRI and CN_REMOTE becomes CN_HIGHPRI.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bugtty.c,v 1.10 2004/05/14 20:38:32 miod Exp $ */
d210 1
a210 1
	} else if (tp->t_state & TS_XCLUDE && p->p_ucred->cr_uid != 0) {
@


1.10
log
@Attach a working bugtty device - userland needs at least a console tty.
@
text
@d1 1
a1 1
/*	$OpenBSD: bugtty.c,v 1.9 2004/01/14 20:50:48 miod Exp $ */
d443 1
a443 1
	cp->cn_pri = CN_NORMAL;
@


1.9
log
@Do not fill more than the first three fields of cfdriver structures unless
necessary. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: bugtty.c,v 1.8 2003/08/15 20:32:14 tedu Exp $ */
d3 1
a3 1
/* Copyright (c) 1998 Steve Murphree, Jr. 
d6 1
a6 1
 *   
d28 1
a28 1
 */  
a35 1
#include <sys/conf.h>
d41 1
d53 1
a53 1
};      
d65 1
d75 2
a76 13
struct tty *bugtty_tty[NBUGTTY];

/*
	int	ca_bustype;
	void	*ca_vaddr;
	void	*ca_paddr;
	int	ca_offset;
	int	ca_len;
	int	ca_ipl;
	int	ca_vec;
	char	*ca_name;
	void	*ca_master;	 points to bus-dependent data 
*/
d84 5
d98 1
a98 1
	printf(": bugtty\n");
d107 1
a107 1
struct tty * 
d113 1
a113 1
	if (unit >= 4) {
d244 1
a244 1
	int cc, s, cnt ;
d289 1
a289 1
		return (ENXIO); 
d293 16
d354 1
a354 1
	if (error >= 0) 
d397 1
a397 1
		error = suser(p, 0); 
d399 1
a399 1
			return (EPERM); 
d436 1
a436 1
	
@


1.8
log
@change arguments to suser.  suser now takes the process, and a flags
argument.  old cred only calls user suser_ucred.  this will allow future
work to more flexibly implement the idea of a root process.  looks like
something i saw in freebsd, but a little different.
use of suser_ucred vs suser in file system code should be looked at again,
for the moment semantics remain unchanged.
review and input from art@@  testing and further review miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bugtty.c,v 1.7 2003/06/03 21:09:01 deraadt Exp $ */
d56 1
a56 1
        NULL, "bugtty", DV_TTY, 0
@


1.7
log
@terms 3 & 4 cleanup based on "terms" file
@
text
@d1 1
a1 1
/*	$OpenBSD: bugtty.c,v 1.6 2002/06/12 03:49:58 miod Exp $ */
d386 1
a386 1
		error = suser(p->p_ucred, &p->p_acflag); 
@


1.6
log
@cnputc() will take care of the necessary cr->cr/lf translation, so don't
do it in those consoles either.
@
text
@d1 2
a2 1
/*	$OpenBSD: bugtty.c,v 1.5 2002/06/08 15:47:31 miod Exp $ */
d15 1
a15 4
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *   This product includes software developed by Dale Rahn.
 * 4. The name of the author may not be used to endorse or promote products
@


1.5
log
@Fix device and console device prototypes.
@
text
@d1 1
a1 1
/*	$OpenBSD: bugtty.c,v 1.4 2002/03/14 01:26:41 millert Exp $ */
a455 2
	if (c == '\n')
		mvmeprom_outchar('\r');
@


1.4
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: bugtty.c,v 1.3 2002/02/15 20:45:30 nordin Exp $ */
a40 1
#include <dev/cons.h>
d43 1
a43 1
#include <machine/prom.h>
d46 2
d62 2
a63 11
int bugttycnprobe(struct consdev *cp);
int bugttycninit(struct consdev *cp);
int bugttycngetc(dev_t dev);
void bugttycnputc(dev_t dev, char c);

int bugttyopen(dev_t dev, int flag, int mode, struct proc *p);
int bugttyclose(dev_t dev, int flag, int mode, struct proc *p);
int bugttyread(dev_t dev, struct uio *uio, int flag);
int bugttywrite(dev_t dev, struct uio *uio, int flag);
int bugttyioctl(dev_t dev, int cmd, caddr_t data, int flag, struct proc *p);
int bugttystop(struct tty *tp, int flag);
a64 1
struct tty *bugttytty(dev_t dev);
a299 21
/* only to be called at splclk() */
void
bugtty_chkinput()
{
	struct tty *tp;
	int rc = 0;
	tp = bugtty_tty[0]; /* Kinda ugly hack */
	if (tp == NULL )
		return;

	if ((rc = mvmeprom_instat()) != 0) {
		while (mvmeprom_instat() != 0) {
			u_char c = mvmeprom_getchar() & 0xff;
			(*linesw[tp->t_line].l_rint)(c, tp);
		}
		/*
		wakeup(tp);
		*/
	}
}

d332 1
a332 1
	int cmd;
d422 1
a422 1
int
a434 1
	return (1);
d437 1
a437 1
int
a441 1
	return 0;
@


1.3
log
@Don't cast nonexistent return value from splx to (void). ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bugtty.c,v 1.2 2001/11/06 22:45:54 miod Exp $ */
d49 2
a50 2
int bugttymatch __P((struct device *parent, void *self, void *aux));
void bugttyattach __P((struct device *parent, struct device *self, void *aux));
d61 15
a75 15
int bugttycnprobe __P((struct consdev *cp));
int bugttycninit __P((struct consdev *cp));
int bugttycngetc __P((dev_t dev));
void bugttycnputc __P((dev_t dev, char c));

int bugttyopen __P((dev_t dev, int flag, int mode, struct proc *p));
int bugttyclose __P((dev_t dev, int flag, int mode, struct proc *p));
int bugttyread __P((dev_t dev, struct uio *uio, int flag));
int bugttywrite __P((dev_t dev, struct uio *uio, int flag));
int bugttyioctl __P((dev_t dev, int cmd, caddr_t data, int flag, struct proc *p));
int bugttystop __P((struct tty *tp, int flag));

struct tty *bugttytty __P((dev_t dev));
int bugttymctl __P((dev_t dev, int bits, int how));
int bugttyparam __P((struct tty *tp, struct termios *tm));
d118 1
a118 1
void bugttyoutput __P((struct tty *tp));
@


1.2
log
@-Wall -Werror cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: bugtty.c,v 1.1 2001/06/26 21:57:40 smurph Exp $ */
d156 1
a156 1
	(void)splx(s);
@


1.2.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: bugtty.c,v 1.2 2001/11/06 22:45:54 miod Exp $ */
d41 1
d44 1
a44 1
#include <machine/bugio.h>
a46 2
#include <dev/cons.h>

d49 2
a50 2
int bugttymatch(struct device *parent, void *self, void *aux);
void bugttyattach(struct device *parent, struct device *self, void *aux);
d61 15
a75 5
cons_decl(bugtty);
cdev_decl(bugtty);

int bugttymctl(dev_t dev, int bits, int how);
int bugttyparam(struct tty *tp, struct termios *tm);
d118 1
a118 1
void bugttyoutput(struct tty *tp);
d156 1
a156 1
	splx(s);
d309 21
d362 1
a362 1
	u_long cmd;
d452 1
a452 1
void
d465 1
d468 1
a468 1
void
d473 1
@


1.2.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: bugtty.c,v 1.2.2.1 2002/06/11 03:37:22 art Exp $ */
d456 2
@


1.1
log
@Initial import of mvmeppc.
@
text
@d1 1
a1 1
/*	$OpenBSD: bugtty.c,v 1.7 2001/03/09 05:44:38 smurph Exp $ */
a104 1
	struct confargs *ca = aux;
@


1.1.2.1
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d105 1
@


1.1.2.2
log
@Merge in trunk
@
text
@d156 1
a156 1
	splx(s);
@


1.1.2.3
log
@Merge in -current from about a week ago
@
text
@d49 2
a50 2
int bugttymatch(struct device *parent, void *self, void *aux);
void bugttyattach(struct device *parent, struct device *self, void *aux);
d61 15
a75 15
int bugttycnprobe(struct consdev *cp);
int bugttycninit(struct consdev *cp);
int bugttycngetc(dev_t dev);
void bugttycnputc(dev_t dev, char c);

int bugttyopen(dev_t dev, int flag, int mode, struct proc *p);
int bugttyclose(dev_t dev, int flag, int mode, struct proc *p);
int bugttyread(dev_t dev, struct uio *uio, int flag);
int bugttywrite(dev_t dev, struct uio *uio, int flag);
int bugttyioctl(dev_t dev, int cmd, caddr_t data, int flag, struct proc *p);
int bugttystop(struct tty *tp, int flag);

struct tty *bugttytty(dev_t dev);
int bugttymctl(dev_t dev, int bits, int how);
int bugttyparam(struct tty *tp, struct termios *tm);
d118 1
a118 1
void bugttyoutput(struct tty *tp);
@


1.1.2.4
log
@Sync the SMP branch with 3.3
@
text
@d41 1
d44 1
a44 1
#include <machine/bugio.h>
a46 2
#include <dev/cons.h>

d61 11
a71 2
cons_decl(bugtty);
cdev_decl(bugtty);
d73 1
d309 21
d362 1
a362 1
	u_long cmd;
d452 1
a452 1
void
d465 1
d468 1
a468 1
void
d473 1
d488 2
@


1.1.2.5
log
@Sync SMP branch to -current
@
text
@a1 1

d14 4
a17 1
 * 3. The name of the author may not be used to endorse or promote products
@


1.1.2.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d56 1
a56 1
        NULL, "bugtty", DV_TTY
d386 1
a386 1
		error = suser(p, 0); 
@


1.1.2.7
log
@Merge with the trunk
@
text
@d3 1
a3 1
/* Copyright (c) 1998 Steve Murphree, Jr.
d6 1
a6 1
 *
d28 1
a28 1
 */
d36 1
a41 1
#include <machine/conf.h>
d53 1
a53 1
};
a64 1
void bugtty_chkinput(void);
d74 13
a86 2
#define	BUGTTYS	4
struct tty *bugtty_tty[BUGTTYS];
a93 5
	struct confargs *ca = aux;

	if (strcmp(ca->ca_name, bugtty_cd.cd_name) != 0)
		return (0);

d103 1
a103 1
	printf(": fallback console\n");
d112 1
a112 1
struct tty *
d118 1
a118 1
	if (unit >= BUGTTYS) {
d249 1
a249 1
	int cc, s, cnt;
d294 1
a294 1
		return (ENXIO);
a297 16
/* only to be called at splclk() */
void
bugtty_chkinput()
{
	struct tty *tp;

	tp = bugtty_tty[0]; /* assumes console on the first port... */
	if (tp == NULL)
		return;

	while (mvmeprom_instat() != 0) {
		u_char c = mvmeprom_getchar() & 0xff;
		(*linesw[tp->t_line].l_rint)(c, tp);
	}
}

d343 1
a343 1
	if (error >= 0)
d386 1
a386 1
		error = suser(p, 0);
d388 1
a388 1
			return (EPERM);
d425 1
a425 1

@


