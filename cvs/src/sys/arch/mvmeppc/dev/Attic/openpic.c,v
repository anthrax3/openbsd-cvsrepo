head	1.25;
access;
symbols
	OPENBSD_4_9:1.23.0.2
	OPENBSD_4_9_BASE:1.23
	OPENBSD_4_8:1.22.0.14
	OPENBSD_4_8_BASE:1.22
	OPENBSD_4_7:1.22.0.10
	OPENBSD_4_7_BASE:1.22
	OPENBSD_4_6:1.22.0.12
	OPENBSD_4_6_BASE:1.22
	OPENBSD_4_5:1.22.0.8
	OPENBSD_4_5_BASE:1.22
	OPENBSD_4_4:1.22.0.6
	OPENBSD_4_4_BASE:1.22
	OPENBSD_4_3:1.22.0.4
	OPENBSD_4_3_BASE:1.22
	OPENBSD_4_2:1.22.0.2
	OPENBSD_4_2_BASE:1.22
	OPENBSD_4_1:1.21.0.4
	OPENBSD_4_1_BASE:1.21
	OPENBSD_4_0:1.21.0.2
	OPENBSD_4_0_BASE:1.21
	OPENBSD_3_9:1.20.0.6
	OPENBSD_3_9_BASE:1.20
	OPENBSD_3_8:1.20.0.4
	OPENBSD_3_8_BASE:1.20
	OPENBSD_3_7:1.20.0.2
	OPENBSD_3_7_BASE:1.20
	OPENBSD_3_6:1.17.0.2
	OPENBSD_3_6_BASE:1.17
	SMP_SYNC_A:1.16
	SMP_SYNC_B:1.16
	OPENBSD_3_5:1.13.0.2
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	UBC_SYNC_A:1.9
	OPENBSD_3_3:1.9.0.4
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.2
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	UBC_SYNC_B:1.9
	UBC:1.6.0.2
	UBC_BASE:1.6
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	SMP:1.2.0.2;
locks; strict;
comment	@ * @;


1.25
date	2011.07.07.19.16.42;	author deraadt;	state dead;
branches;
next	1.24;

1.24
date	2011.04.15.20.40.06;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2010.09.20.06.33.47;	author matthew;	state Exp;
branches;
next	1.22;

1.22
date	2007.05.29.18.10.43;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2006.03.12.02.49.49;	author brad;	state Exp;
branches;
next	1.20;

1.20
date	2004.12.24.22.50.30;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2004.11.19.22.11.54;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2004.11.19.22.10.24;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2004.07.14.11.37.07;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2004.05.15.22.08.04;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2004.05.14.18.29.39;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2004.05.08.20.10.12;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2004.02.01.22.30.42;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2004.01.30.22.24.27;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2004.01.29.10.58.06;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.02.23.27.53;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2002.06.08.15.49.52;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.14.03.15.58;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.03.14.01.26.41;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.11.06.22.45.54;	author miod;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2001.11.06.19.53.15;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2001.09.11.20.05.24;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2001.07.06.05.14.29;	author smurph;	state Exp;
branches;
next	1.2;

1.2
date	2001.06.27.04.32.45;	author art;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2001.06.26.21.57.41;	author smurph;	state Exp;
branches;
next	;

1.2.2.1
date	2001.10.31.03.01.20;	author nate;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2001.11.13.21.04.15;	author niklas;	state Exp;
branches;
next	1.2.2.3;

1.2.2.3
date	2002.03.28.10.36.03;	author niklas;	state Exp;
branches;
next	1.2.2.4;

1.2.2.4
date	2003.03.27.23.52.16;	author niklas;	state Exp;
branches;
next	1.2.2.5;

1.2.2.5
date	2003.06.07.11.13.18;	author ho;	state Exp;
branches;
next	1.2.2.6;

1.2.2.6
date	2004.02.19.10.49.09;	author niklas;	state Exp;
branches;
next	1.2.2.7;

1.2.2.7
date	2004.06.05.23.10.54;	author niklas;	state Exp;
branches;
next	;

1.6.2.1
date	2002.06.11.03.37.22;	author art;	state Exp;
branches;
next	;


desc
@@


1.25
log
@remove mvmeppc; it is really rough shape.  ok drahn miod
@
text
@/*	$OpenBSD: openpic.c,v 1.24 2011/04/15 20:40:06 deraadt Exp $	*/

/*-
 * Copyright (c) 1995 Per Fogelstrom
 * Copyright (c) 1993, 1994 Charles M. Hannum.
 * Copyright (c) 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * William Jolitz and Don Ahn.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)isa.c	7.2 (Berkeley) 5/12/91
 */

#include <sys/param.h>
#include <sys/device.h>
#include <sys/ioctl.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/systm.h>

#include <uvm/uvm_extern.h>

#include <ddb/db_var.h>

#include <machine/atomic.h>
#include <machine/autoconf.h>
#include <machine/intr.h>
#include <machine/psl.h>
#include <machine/pio.h>

#include <mvmeppc/dev/openpicreg.h>
#include <mvmeppc/dev/ravenvar.h>
#include <mvmeppc/dev/ravenreg.h>

#define ICU_LEN		32
#define LEGAL_IRQ(x)	((x >= 0) && (x < ICU_LEN))
#define IO_ICU1		(isaspace_va + 0x20)
#define IO_ICU2		(isaspace_va + 0xa0)
#define IO_ELCR1	(isaspace_va + 0x4d0)
#define IO_ELCR2	(isaspace_va + 0x4d1)
#define IRQ_SLAVE	2
#define ICU_OFFSET	0
#define PIC_OFFSET	16

#define	PIC_SPURIOUS	0xff

unsigned char icu1_val = 0xff;
unsigned char icu2_val = 0xff;
unsigned char elcr1_val = 0x00;
unsigned char elcr2_val = 0x00;

int intrtype[ICU_LEN], intrmask[ICU_LEN], intrlevel[ICU_LEN];
struct intrhand *intrhand[ICU_LEN];
int hwirq[ICU_LEN], virq[ICU_LEN];
unsigned int imen = 0xffffffff;
int virq_max;

int fakeintr(void *);
const char *intr_typename(int type);
void intr_calculatemasks(void);
static __inline int cntlzw(int x);
int mapirq(int irq);
void openpic_enable_irq_mask(int irq_mask);

#define HWIRQ_MAX 27
#define HWIRQ_MASK 0x0fffffff

static __inline u_int openpic_read(int);
static __inline void openpic_write(int, u_int);
void openpic_enable_irq(int, int);
void openpic_disable_irq(int);
void openpic_init(void);
void openpic_set_priority(int, int);
static __inline int openpic_iack(int);
static __inline void openpic_eoi(int);
void openpic_initirq(int, int, int);

void i8259_init(void);
int i8259_intr(void);
void i8259_enable_irq(int, int);
void i8259_disable_irq(int);
void i8259_eoi(int);
void *i8259_intr_establish(void *, int, int, int, int (*)(void *), void *,
    char *);
void i8259_set_irq_mask(void);

struct openpic_softc {
	struct device sc_dev;
};

int openpic_match(struct device *parent, void *cf, void *aux);
void openpic_attach(struct device *, struct device *, void *);
void openpic_do_pending_int(void);
void ext_intr_openpic(void);

struct cfattach openpic_ca = {
	sizeof(struct openpic_softc), openpic_match, openpic_attach
};

struct cfdriver openpic_cd = {
	NULL, "openpic", DV_DULL
};

/*
 * ISA IRQ for PCI IRQ to MPIC IRQ routing.
 * From MVME2600APG tables 5.2 and 5.3
 */
const struct pci_route {
	int pci;
	int openpic;
} pci_routes[] = {
	{ 10, 2 },
	{ 11, 5 },
	{ 14, 3 },
	{ 15, 4 },
	{ 0, 0 }
};

int
openpic_match(parent, cf, aux)
	struct device *parent;
	void *cf;
	void *aux;
{
	/* We must be a child of the raven device */
	if (strcmp(parent->dv_cfdata->cf_driver->cd_name, "raven") != 0)
		return (0);
	/* If there is a raven, then there is a mpic! */
	return 1;
}

u_int8_t *interrupt_reg;
typedef void (void_f) (void);
extern void_f *pending_int_f;
int abort_switch (void *arg);
int i8259_dummy(void *arg);

typedef int mac_intr_handle_t;

typedef void *(intr_establish_t)(void *, int, int, int, int (*)(void *),
    void *, char *);
typedef void (intr_disestablish_t)(void *, void *);

vaddr_t openpic_base;
extern vaddr_t isaspace_va;

void * openpic_intr_establish(void *, int, int, int, int (*)(void *), void *,
    char *);
void openpic_intr_disestablish(void *, void *);
void openpic_collect_preconf_intr(void);

void
openpic_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	extern intr_establish_t *intr_establish_func;
	extern intr_disestablish_t *intr_disestablish_func;

	if ((openpic_base = (vaddr_t)mapiodev(MPCIC_BASE, MPCIC_SIZE)) == NULL) {
		printf(": can't map MPCIC!\n");
		return;
	}

	/* the ICU area in isa space already mapped */

	printf(": version 0x%x", openpic_read(OPENPIC_FEATURE) & 0xFF);

	i8259_init();
	openpic_init();

	pending_int_f = openpic_do_pending_int;
	intr_establish_func = i8259_intr_establish;
	intr_disestablish_func = openpic_intr_disestablish;

	openpic_collect_preconf_intr();

	/*
	 * i8259 interrupts are chained to openpic interrupt #0
	 */
	openpic_intr_establish(parent, 0x00, IST_LEVEL, IPL_HIGH,
	    i8259_dummy, NULL, "8259 Interrupt");

	i8259_intr_establish(parent, 0x08, IST_EDGE, IPL_HIGH,
	    abort_switch, NULL, "abort button");

	printf("\n");
}

void
openpic_collect_preconf_intr()
{
	int i;

	for (i = 0; i < ppc_configed_intr_cnt; i++) {
#ifdef DEBUG
		printf("\n\t%s irq %d level %d fun %x arg %x",
		    ppc_configed_intr[i].ih_what, ppc_configed_intr[i].ih_irq,
		    ppc_configed_intr[i].ih_level, ppc_configed_intr[i].ih_fun,
		    ppc_configed_intr[i].ih_arg);
#endif
		openpic_intr_establish(NULL, ppc_configed_intr[i].ih_irq,
		    IST_LEVEL, ppc_configed_intr[i].ih_level,
		    ppc_configed_intr[i].ih_fun, ppc_configed_intr[i].ih_arg,
		    ppc_configed_intr[i].ih_what);
	}
}

int
abort_switch(void *arg)
{
#ifdef DDB
	if (db_console)
		Debugger();
#else
	printf("Abort button pressed, debugger not available.\n");
#endif
	return 1;
}

int
i8259_dummy(void *arg)
{
	/* All the 8259 handling happens in ext_intr_openpic(), actually. */
	return 1;
}

int
fakeintr(arg)
	void *arg;
{
	return 0;
}

/*
 * Register an ISA interrupt handler.
 */
void *
i8259_intr_establish(lcv, irq, type, level, ih_fun, ih_arg, what)
	void * lcv;
	int irq;
	int type;
	int level;
	int (*ih_fun)(void *);
	void *ih_arg;
	char *what;
{
	struct intrhand **p, *q, *ih;
	static struct intrhand fakehand;

	fakehand.ih_next = NULL;
	fakehand.ih_fun = fakeintr;

#if 0
	printf("i8259_intr_establish, %d, %s", irq, (type == IST_EDGE) ? "EDGE":"LEVEL"));
#endif
	irq = mapirq(irq + ICU_OFFSET);

	/* no point in sleeping unless someone can free memory. */
	ih = malloc(sizeof *ih, M_DEVBUF, cold ? M_NOWAIT : M_WAITOK);
	if (ih == NULL)
		panic("i8259_intr_establish: can't malloc handler info");

	if (!LEGAL_IRQ(irq) || type == IST_NONE)
		panic("i8259_intr_establish: bogus irq or type");

	switch (intrtype[irq]) {
	case IST_EDGE:
		intr_shared_edge = 1;
		/* FALLTHROUGH */
	case IST_LEVEL:
		if (type == intrtype[irq])
			break;
	case IST_PULSE:
		if (type != IST_NONE)
			panic("intr_establish: can't share %s with %s",
			    intr_typename(intrtype[irq]),
			    intr_typename(type));
		break;
	}

	/*
	 * Figure out where to put the handler.
	 * This is O(N^2), but we want to preserve the order, and N is
	 * generally small.
	 */
	for (p = &intrhand[irq]; (q = *p) != NULL; p = &q->ih_next)
		;

	/*
	 * Actually install a fake handler momentarily, since we might be doing
	 * this with interrupts enabled and don't want the real routine called
	 * until masking is set up.
	 */
	fakehand.ih_level = level;
	*p = &fakehand;

	intr_calculatemasks();

	/*
	 * Poke the real handler in now.
	 */
	ih->ih_fun = ih_fun;
	ih->ih_arg = ih_arg;
	ih->ih_next = NULL;
	ih->ih_level = level;
	ih->ih_irq = irq;
	ih->ih_what = what;
	evcount_attach(&ih->ih_count, what, &ih->ih_irq);
	*p = ih;

	return (ih);
}


/*
 * Register a PCI interrupt handler.
 */
void *
openpic_intr_establish(lcv, irq, type, level, ih_fun, ih_arg, what)
	void * lcv;
	int irq;
	int type;
	int level;
	int (*ih_fun)(void *);
	void *ih_arg;
	char *what;
{
	struct intrhand **p, *q, *ih;
	static struct intrhand fakehand;
	const struct pci_route *pr;

	fakehand.ih_next = NULL;
	fakehand.ih_fun = fakeintr;

	for (pr = pci_routes; pr->pci != 0; pr++)
		if (pr->pci == irq) {
			irq = pr->openpic;
			break;
		}

	irq = mapirq(irq + PIC_OFFSET);

	/* no point in sleeping unless someone can free memory. */
	ih = malloc(sizeof *ih, M_DEVBUF, cold ? M_NOWAIT : M_WAITOK);
	if (ih == NULL)
		panic("intr_establish: can't malloc handler info");

	if (!LEGAL_IRQ(irq) || type == IST_NONE)
		panic("intr_establish: bogus irq or type");

	switch (intrtype[irq]) {
	case IST_EDGE:
		intr_shared_edge = 1;
		/* FALLTHROUGH */
	case IST_LEVEL:
		if (type == intrtype[irq])
			break;
	case IST_PULSE:
		if (type != IST_NONE)
			panic("intr_establish: can't share %s with %s",
			    intr_typename(intrtype[irq]),
			    intr_typename(type));
		break;
	}

	/*
	 * Figure out where to put the handler.
	 * This is O(N^2), but we want to preserve the order, and N is
	 * generally small.
	 */
	for (p = &intrhand[irq]; (q = *p) != NULL; p = &q->ih_next)
		;

	/*
	 * Actually install a fake handler momentarily, since we might be doing
	 * this with interrupts enabled and don't want the real routine called
	 * until masking is set up.
	 */
	fakehand.ih_level = level;
	*p = &fakehand;

	intr_calculatemasks();

	/*
	 * Poke the real handler in now.
	 */
	ih->ih_fun = ih_fun;
	ih->ih_arg = ih_arg;
	ih->ih_next = NULL;
	ih->ih_level = level;
	ih->ih_irq = irq;
	ih->ih_what = what;
	evcount_attach(&ih->ih_count, what, (void *)&ih->ih_irq);
	*p = ih;

	return (ih);
}

/*
 * Deregister an interrupt handler.
 */
void
openpic_intr_disestablish(lcp, arg)
	void *lcp;
	void *arg;
{
	struct intrhand *ih = arg;
	int irq = ih->ih_irq;
	struct intrhand **p, *q;

	if (!LEGAL_IRQ(irq))
		panic("intr_disestablish: bogus irq");

	/*
	 * Remove the handler from the chain.
	 * This is O(n^2), too.
	 */
	for (p = &intrhand[irq]; (q = *p) != NULL && q != ih; p = &q->ih_next)
		;
	if (q)
		*p = q->ih_next;
	else
		panic("intr_disestablish: handler not registered");

	evcount_detach(&ih->ih_count);
	free((void *)ih, M_DEVBUF);

	intr_calculatemasks();

	if (intrhand[irq] == NULL)
		intrtype[irq] = IST_NONE;
}

const char *
intr_typename(type)
	int type;
{

	switch (type) {
	case IST_NONE :
		return ("none");
	case IST_PULSE:
		return ("pulsed");
	case IST_EDGE:
		return ("edge-triggered");
	case IST_LEVEL:
		return ("level-triggered");
#ifdef DIAGNOSTIC
	default:
		panic("intr_typename: invalid type %d", type);
#endif
	}
}

/*
 * Recalculate the interrupt masks from scratch.
 * We could code special registry and deregistry versions of this function that
 * would be faster, but the code would be nastier, and we don't expect this to
 * happen very much anyway.
 */
void
intr_calculatemasks()
{
	int irq, hirq, level, levels;
	struct intrhand *q;
	int irqs;

	/* First, figure out which levels each IRQ uses. */
	for (irq = 0; irq < ICU_LEN; irq++) {
		levels = 0;
		for (q = intrhand[irq]; q; q = q->ih_next)
			levels |= 1 << q->ih_level;
		intrlevel[irq] = levels;
	}

	/* Then figure out which IRQs use each level. */
	for (level = IPL_NONE; level < IPL_NUM; level++) {
		irqs = 0;
		for (irq = 0; irq < ICU_LEN; irq++)
			if (intrlevel[irq] & (1 << level))
				irqs |= 1 << irq;
		imask[level] = irqs | SINT_MASK;
	}

	/*
	 * There are tty, network and disk drivers that use free() at interrupt
	 * time, so vm > (tty | net | bio).
	 *
	 * Enforce a hierarchy that gives slow devices a better chance at not
	 * dropping data.
	 */
	imask[IPL_NET] |= imask[IPL_BIO];
	imask[IPL_TTY] |= imask[IPL_NET];
	imask[IPL_VM] |= imask[IPL_TTY];
	imask[IPL_CLOCK] |= imask[IPL_VM] | SPL_CLOCK;

	/*
	 * These are pseudo-levels.
	 */
	imask[IPL_NONE] = 0x00000000;
	imask[IPL_HIGH] = 0xffffffff;

	/* And eventually calculate the complete masks. */
	for (irq = 0; irq < ICU_LEN; irq++) {
		irqs = 1 << irq;
		for (q = intrhand[irq]; q; q = q->ih_next)
			irqs |= imask[q->ih_level];
		intrmask[irq] = irqs | SINT_MASK;
	}

	/* Lastly, determine which IRQs are actually in use. */
	irqs = 0;
	for (irq = 0; irq < ICU_LEN; irq++) {
		hirq = hwirq[irq];
		if (hirq < 0)
			continue;

		if (intrhand[irq]) {
			irqs |= 1 << irq;

			if (hirq >= PIC_OFFSET)
				openpic_enable_irq(hirq, intrtype[irq]);
			else
				i8259_enable_irq(hirq, intrtype[irq]);
		} else {
			if (hirq >= PIC_OFFSET)
				openpic_disable_irq(hirq);
			else
				i8259_disable_irq(hirq);
		}
	}

	/* always enable the chained 8259 interrupt */
	i8259_enable_irq(IRQ_SLAVE, IST_EDGE);

	imen = ~irqs;
	i8259_set_irq_mask();
}

/*
 * Map 64 irqs into 32 (bits).
 */
int
mapirq(irq)
	int irq;
{
	int v;

#ifdef DIAGNOSTIC
	if (irq < 0 || irq >= ICU_LEN)
		panic("invalid irq");
#endif

	virq_max++;
	v = virq_max;
	if (v > HWIRQ_MAX)
		panic("virq overflow");

	hwirq[v] = irq;
	virq[irq] = v;
#ifdef DEBUG
	printf("mapirq %x to %x\n", irq, v);
#endif

	return v;
}

/*
 * Count leading zeros.
 */
static __inline int
cntlzw(x)
	int x;
{
	int a;

	__asm __volatile ("cntlzw %0,%1" : "=r"(a) : "r"(x));
	return a;
}

void
openpic_do_pending_int()
{
	struct intrhand *ih;
	int irq;
	int pcpl;
	int hwpend;
	int s;
	static int processing;

	if (processing)
		return;

	processing = 1;
	pcpl = splhigh();		/* Turn off all */
	s = ppc_intr_disable();

	hwpend = ipending & ~pcpl;	/* Do now unmasked pendings */
	imen &= ~hwpend;
	openpic_enable_irq_mask(~imen);

	hwpend &= HWIRQ_MASK;
	while (hwpend) {
		irq = 31 - cntlzw(hwpend);
		hwpend &= ~(1L << irq);
		ih = intrhand[irq];
		while (ih) {
			if ((*ih->ih_fun)(ih->ih_arg))
				ih->ih_count.ec_count++;
			ih = ih->ih_next;
		}
	}

	do {
		if ((ipending & SINT_CLOCK) & ~pcpl) {
			ipending &= ~SINT_CLOCK;
			softclock();
		}
		if ((ipending & SINT_NET) & ~pcpl) {
			extern int netisr;
			int pisr;

			ipending &= ~SINT_NET;
			while ((pisr = netisr) != 0) {
				atomic_clearbits_int(&netisr, pisr);
				softnet(pisr);
			}
		}
#if 0
		if ((ipending & SINT_TTY) & ~pcpl) {
			ipending &= ~SINT_TTY;
			softtty();
		}
#endif
	} while (ipending & (SINT_NET|SINT_CLOCK/*|SINT_TTY*/) & ~cpl);
	ipending &= pcpl;
	cpl = pcpl;	/* Don't use splx... we are here already! */

#if 0
	i8259_set_irq_mask();
#endif

	ppc_intr_enable(s);
	processing = 0;
}

u_int
openpic_read(reg)
	int reg;
{
	char *addr = (void *)(openpic_base + reg);

	return in32rb(addr);
}

void
openpic_write(reg, val)
	int reg;
	u_int val;
{
	char *addr = (void *)(openpic_base + reg);

	out32rb(addr, val);
}

void
openpic_enable_irq_mask(irq_mask)
	int irq_mask;
{
	int irq, hirq;

	for (irq = 0; irq <= virq_max; irq++) {
		hirq = hwirq[irq];
		if (hirq < 0)
			continue;

		if (irq_mask & (1 << irq)) {
			if (hirq >= PIC_OFFSET)
				openpic_enable_irq(hirq, intrtype[irq]);
			else
				i8259_enable_irq(hirq, intrtype[irq]);
		} else {
			if (hirq >= PIC_OFFSET)
				openpic_disable_irq(hirq);
			else
				i8259_disable_irq(hirq);
		}
	}

	i8259_set_irq_mask();
}

void
openpic_enable_irq(irq, type)
	int irq;
	int type;
{
	u_int x, isrc;

#ifdef DIAGNOSTIC
	/* skip invalid irqs */
	if (irq < PIC_OFFSET)
		panic("openpic_enable_irq: invalid irq %x", irq);
#endif
	irq -= PIC_OFFSET;

	x = openpic_read(OPENPIC_SRC_VECTOR(irq));

	isrc = x & ~(OPENPIC_IMASK | OPENPIC_SENSE_LEVEL |
	    OPENPIC_POLARITY_POSITIVE | OPENPIC_ACTIVITY);
	if (irq == 0)
		isrc |= OPENPIC_POLARITY_POSITIVE;
	if (type == IST_LEVEL)
		isrc |= OPENPIC_SENSE_LEVEL;
	else
		isrc |= OPENPIC_SENSE_EDGE;

	/* Ack all pending interrupts if this one is pending. */
	while (x & OPENPIC_ACTIVITY) {
		(void)openpic_iack(0);
		openpic_eoi(0);
		x = openpic_read(OPENPIC_SRC_VECTOR(irq));
	}

	if (x != isrc)
		openpic_write(OPENPIC_SRC_VECTOR(irq), isrc);
}

void
openpic_disable_irq(irq)
	int irq;
{
	u_int x;

	/* skip invalid irqs */
	if (irq >= PIC_OFFSET)
		irq -= PIC_OFFSET;

	x = openpic_read(OPENPIC_SRC_VECTOR(irq));
	x |= OPENPIC_IMASK;
	openpic_write(OPENPIC_SRC_VECTOR(irq), x);
}

void
i8259_set_irq_mask(void)
{
	if (icu2_val != 0xff) {
		/* Turn on the second IC */
		icu1_val &= ~(1 << IRQ_SLAVE);
	} else {
		icu1_val |= (1 << IRQ_SLAVE);
	}

	outb(IO_ICU1 + 1, icu1_val);
	outb(IO_ICU2 + 1, icu2_val);
	outb(IO_ELCR1, elcr1_val);
	outb(IO_ELCR2, elcr2_val);
}

void
i8259_disable_irq(irq)
	int irq;
{
#ifdef DIAGNOSTIC
	/* skip invalid irqs */
	if (irq < 0 || irq >= PIC_OFFSET)
		panic("i8259_disable_irq: invalid irq %x", irq);
#endif

	if (irq < 8) {
		icu1_val |= 1 << irq;
		elcr1_val &= ~(1 << irq);
	} else {
		irq -= 8;
		icu2_val |= 1 << irq;
		elcr2_val &= ~(1 << irq);
	}
}

void
i8259_enable_irq(irq, type)
	int irq, type;
{
#ifdef DIAGNOSTIC
	/* skip invalid irqs */
	if (irq < 0 || irq >= PIC_OFFSET)
		panic("i8259_enable_irq: invalid irq %x", irq);
#endif

	if (irq < 8) {
		icu1_val &= ~(1 << irq);
		if (type == IST_LEVEL)
			elcr1_val |= (1 << irq);
		else
			elcr1_val &= ~(1 << irq);
	} else {
		irq -= 8;
		icu2_val &= ~(1 << irq);
		if (type == IST_LEVEL)
			elcr2_val |= (1 << irq);
		else
			elcr2_val &= ~(1 << irq);
	}
}

void
i8259_eoi(int irq)
{
#ifdef DIAGNOSTIC
	/* skip invalid irqs */
	if (irq < 0 || irq >= PIC_OFFSET)
		panic("i8259_eoi: invalid irq %x", irq);
#endif

	if (irq < 8)
		outb(IO_ICU1, 0x60 | irq);
	else {
		outb(IO_ICU2, 0x60 | (irq - 8));
		/*
		 * Do not ack on the master unless there are no
		 * other interrupts pending on the slave
		 * controller!
		 */
		outb(IO_ICU2, 0x0b);
		if (inb(IO_ICU2) == 0)
			outb(IO_ICU1, 0x60 | IRQ_SLAVE);
	}
}

void
openpic_set_priority(cpu, pri)
	int cpu, pri;
{
	u_int x;

	x = openpic_read(OPENPIC_CPU_PRIORITY(cpu));
	x &= ~OPENPIC_CPU_PRIORITY_MASK;
	x |= pri;
	openpic_write(OPENPIC_CPU_PRIORITY(cpu), x);
}

int
openpic_iack(cpu)
	int cpu;
{
	return openpic_read(OPENPIC_IACK(cpu)) & OPENPIC_VECTOR_MASK;
}

void
openpic_eoi(cpu)
	int cpu;
{
	openpic_write(OPENPIC_EOI(cpu), 0);
	openpic_read(OPENPIC_EOI(cpu));
}

void
i8259_init(void)
{
	/* initialize 8259's */
	outb(IO_ICU1, 0x11);		/* reset; program device, four bytes */
	outb(IO_ICU1+1, ICU_OFFSET);	/* starting at this vector index */
	outb(IO_ICU1+1, 1 << IRQ_SLAVE);	/* slave on line 2 */
	outb(IO_ICU1+1, 1);		/* 8086 mode */
	outb(IO_ICU1+1, 0xff);		/* leave interrupts masked */
	/* init interrupt controller 2 */
	outb(IO_ICU2, 0x11);		/* reset; program device, four bytes */
	outb(IO_ICU2+1, ICU_OFFSET+8);	/* staring at this vector index */
	outb(IO_ICU2+1, IRQ_SLAVE);
	outb(IO_ICU2+1, 1);		/* 8086 mode */
	outb(IO_ICU2+1, 0xff);		/* leave interrupts masked */
}

int
i8259_intr(void)
{
	int irq;

	/*
	 * Perform an interrupt acknowledge cycle on controller 1
	 */
	outb(IO_ICU1, 0x0c);
	irq = inb(IO_ICU1) & 7;

	if (irq == IRQ_SLAVE) {
		/*
		 * Interrupt is cascaded so perform interrupt
		 * acknowledge on controller 2
		 */
		outb(IO_ICU2, 0x0c);
		irq = (inb(IO_ICU2) & 7) + 8;
		if (irq == 15) {
			outb(IO_ICU2, 0x0b);
			if ((inb(IO_ICU2) & 0x80) == 0) {
#ifdef DIAGNOSTIC
				printf("spurious interrupt on ICU2\n");
#endif
				return PIC_SPURIOUS;
			}
		}
	} else if (irq == 7) {
		/*
		 * This may be a spurious interrupt
		 *
		 * Read the interrupt status register. If the most
		 * significant bit is not set then there is no valid
		 * interrupt
		 */
		outb(IO_ICU1, 0x0b);
		if ((inb(IO_ICU1) & 0x80) == 0) {
#ifdef DIAGNOSTIC
			printf("spurious interrupt on ICU1\n");
#endif
			return PIC_SPURIOUS;
		}
	}

	return (ICU_OFFSET + irq);
}

void
ext_intr_openpic()
{
	int irq, realirq;
	int r_imen;
	int pcpl, ocpl;
	struct intrhand *ih;

	pcpl = cpl;

	realirq = openpic_iack(0);

	while (realirq != PIC_SPURIOUS) {
		if (realirq == 0x00) {
			/*
			 * Interrupt from the PCI/ISA bridge. PCI interrupts
			 * are shadowed on the ISA PIC for compatibility with
			 * MVME1600, so simply handle the ISA PIC.
			 */
			realirq = i8259_intr();
			openpic_eoi(0);
			if (realirq == PIC_SPURIOUS)
				break;
		} else {
			realirq += PIC_OFFSET;
		}

		irq = virq[realirq];

		/* XXX check range */

		r_imen = 1 << irq;

		if ((pcpl & r_imen) != 0) {
			ipending |= r_imen;		/* Masked! Mark this as pending */
			if (realirq >= PIC_OFFSET) {
				openpic_disable_irq(realirq);
				openpic_eoi(0);
			} else {
				i8259_disable_irq(realirq);
				i8259_set_irq_mask();
				i8259_eoi(realirq);
			}
		} else {
			if (realirq >= PIC_OFFSET) {
				openpic_disable_irq(realirq);
			} else {
				i8259_disable_irq(realirq);
				i8259_set_irq_mask();
			}

			ocpl = splraise(intrmask[irq]);

			ih = intrhand[irq];
			while (ih) {
				if ((*ih->ih_fun)(ih->ih_arg))
					ih->ih_count.ec_count++;
				ih = ih->ih_next;
			}

			uvmexp.intrs++;
			__asm__ volatile("":::"memory");
			cpl = ocpl;
			__asm__ volatile("":::"memory");

			if (realirq >= PIC_OFFSET) {
				openpic_eoi(0);
				openpic_enable_irq(realirq, intrtype[irq]);
			} else {
				i8259_eoi(realirq);
				i8259_enable_irq(realirq, intrtype[irq]);
				i8259_set_irq_mask();
			}
		}

		realirq = openpic_iack(0);
	}
	ppc_intr_enable(1);

	splx(pcpl);	 /* Process pendings. */
}

void
openpic_initirq(int irq, int pol, int sense)
{
	u_int x;

	x = (irq & OPENPIC_VECTOR_MASK);
	x |= OPENPIC_IMASK;
	x |= (pol ? OPENPIC_POLARITY_POSITIVE : OPENPIC_POLARITY_NEGATIVE);
	x |= (sense ? OPENPIC_SENSE_LEVEL : OPENPIC_SENSE_EDGE);
	x |= 8 << OPENPIC_PRIORITY_SHIFT;
	openpic_write(OPENPIC_SRC_VECTOR(irq), x);
}

void
openpic_init()
{
	int irq;
	u_int x;

	/* disable all interrupts and init hwirq[] */
	for (irq = 0; irq < ICU_LEN; irq++) {
		hwirq[irq] = -1;
		intrtype[irq] = IST_NONE;
		intrmask[irq] = 0;
		intrlevel[irq] = 0;
		intrhand[irq] = NULL;
		openpic_write(OPENPIC_SRC_VECTOR(irq), OPENPIC_IMASK);
	}
	openpic_set_priority(0, 15);

	/* we don't need 8259 pass through mode */
	x = openpic_read(OPENPIC_CONFIG);
	x |= OPENPIC_CONFIG_8259_PASSTHRU_DISABLE;
	openpic_write(OPENPIC_CONFIG, x);

	/* send all interrupts to cpu 0 */
	for (irq = 0; irq < ICU_LEN; irq++)
		openpic_write(OPENPIC_SRC_DEST(irq), CPU(0));

	/* special case for intr src 0 */
	openpic_initirq(0, 1, 0);
	for (irq = 1; irq < ICU_LEN; irq++) {
		openpic_initirq(irq, 0, 1);
	}

	/* XXX set spurious intr vector */
#if 0
	openpic_write(OPENPIC_SPURIOUS_VECTOR, 0xFF);
#endif

	/* unmask interrupts for cpu 0 */
	openpic_set_priority(0, 0);

	/* clear all pending interrunts */	/* < ICU_LEN ? */
	for (irq = 0; irq < PIC_OFFSET; irq++) {
		openpic_iack(0);
		openpic_eoi(0);
	}

	for (irq = 0; irq < PIC_OFFSET; irq++) {	/* < ICU_LEN ? */
		i8259_disable_irq(irq);
		openpic_disable_irq(irq);
	}

	i8259_set_irq_mask();

	install_extint(ext_intr_openpic);
}
@


1.24
log
@More than a decade ago, interrupt handlers on sparc started returning 0
(interrupt was not for me), 1 (positive interrupt was for me), or -1
(i am not sure...).  We have continued with this practice in as many
drivers as possible, throughout the tree.

This makes some of the architectures use that information in their
interrupt handler calling code -- if 1 is returned (and we know
this specific machine does not have edge-shared interrupts), we
finish servicing other possible handlers on the same pin.  If the
interrupt pin remains asserted (from a different device), we will
end up back in the interrupt servicing code of course... but this is
cheaper than calling all the chained interrupts on a pin.

This does of course count on shared level interrupts being properly
sorted by IPL.

There have been some concerns about starvation of drivers which
incorrectly return 1.  Those drivers should be hunted down so that
they return -1.

(other architectures will follow)

ok kettenis drahn dlg miod
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.23 2010/09/20 06:33:47 matthew Exp $	*/
@


1.23
log
@Get rid of evcount's support for arranging counters in a tree
hierarchy.  Everything attached to a single root node anyway, so at
best we had a bush.

"i think it is good" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.22 2007/05/29 18:10:43 miod Exp $	*/
d294 2
d379 2
@


1.22
log
@Use atomic operations to operate on netisr, instead of clearing it at splhigh.
This changes nothing on legacy architectures, but is a bit faster (and simpler)
on the interesting ones.
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.21 2006/03/12 02:49:49 brad Exp $	*/
d332 1
a332 1
	evcount_attach(&ih->ih_count, what, (void *)&ih->ih_irq, &evcount_intr);
d415 1
a415 1
	evcount_attach(&ih->ih_count, what, (void *)&ih->ih_irq, &evcount_intr);
@


1.21
log
@IPL_IMP -> IPL_VM

ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.20 2004/12/24 22:50:30 miod Exp $	*/
d50 1
d643 2
a644 2
			int pisr = netisr;
			netisr = 0;
d646 4
a649 1
			softnet(pisr);
@


1.20
log
@{e,}intr{cnt,names} bye-bye.
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.19 2004/11/19 22:11:54 miod Exp $	*/
d508 1
a508 1
	 * time, so imp > (tty | net | bio).
d515 2
a516 2
	imask[IPL_IMP] |= imask[IPL_TTY];
	imask[IPL_CLOCK] |= imask[IPL_IMP] | SPL_CLOCK;
@


1.19
log
@Be more conservative in openpic_enable_irq() and only reprogram the vector
register if it changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.18 2004/11/19 22:10:24 miod Exp $	*/
a966 1
		intrcnt[realirq]++;
@


1.18
log
@Better i8259 slave handling:
- check for spurious interrupt conditions.
- do not ack the slave irq on the master unless there are really no more
  interrupts to be serviced on the slave.
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.17 2004/07/14 11:37:07 miod Exp $	*/
d716 1
a716 1
	u_int x;
d725 14
a738 2
	while ((x = openpic_read(OPENPIC_SRC_VECTOR(irq))) & OPENPIC_ACTIVITY) {
		x = openpic_iack(0);
d740 1
d743 2
a744 12
	x &= ~(OPENPIC_IMASK|OPENPIC_SENSE_LEVEL|OPENPIC_SENSE_EDGE|
			 OPENPIC_POLARITY_POSITIVE);
#if 1
	if (irq == 0) {
		x |= OPENPIC_POLARITY_POSITIVE;
	}
#endif
	if (type == IST_LEVEL)
		x |= OPENPIC_SENSE_LEVEL;
	else
		x |= OPENPIC_SENSE_EDGE;
	openpic_write(OPENPIC_SRC_VECTOR(irq), x);
@


1.17
log
@Switch to evcount interrupt counters.
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.16 2004/05/15 22:08:04 miod Exp $	*/
d106 1
a106 1
static __inline void i8259_eoi(int);
d821 1
a821 1
static __inline void
d834 8
a841 1
		outb(IO_ICU1, 0x60 | IRQ_SLAVE);
d907 9
@


1.16
log
@Be more careful when using hwirq[] values.
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.15 2004/05/14 18:29:39 miod Exp $	*/
a81 2
struct evcnt evirq[ICU_LEN];

a326 1
	ih->ih_count = 0;
d331 1
a409 1
	ih->ih_count = 0;
d414 1
d445 2
d622 1
d629 2
a630 1
			(*ih->ih_fun)(ih->ih_arg);
a632 2

		evirq[hwirq[irq]].ev_count++;
d976 2
a977 1
				(*ih->ih_fun)(ih->ih_arg);
d985 1
a985 3
#if 0
			evirq[realirq].ev_count++;
#endif
@


1.15
log
@Really working interrupt engine, at least on both 2600 flavours.
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.14 2004/05/08 20:10:12 miod Exp $	*/
d485 1
a485 1
	int irq, level, levels;
d535 4
d542 2
a543 2
			if (hwirq[irq] >= PIC_OFFSET)
				openpic_enable_irq(hwirq[irq], intrtype[irq]);
d545 1
a545 1
				i8259_enable_irq(hwirq[irq], intrtype[irq]);
d547 2
a548 2
			if (hwirq[irq] >= PIC_OFFSET)
				openpic_disable_irq(hwirq[irq]);
d550 1
a550 1
				i8259_disable_irq(hwirq[irq]);
d688 6
a693 1
	int irq;
a694 1
	for (irq = 0; irq <= virq_max; irq++)
d696 2
a697 2
			if (hwirq[irq] >= PIC_OFFSET)
				openpic_enable_irq(hwirq[irq], intrtype[irq]);
d699 1
a699 1
				i8259_enable_irq(hwirq[irq], intrtype[irq]);
d701 2
a702 2
			if (hwirq[irq] >= PIC_OFFSET)
				openpic_disable_irq(hwirq[irq]);
d704 1
a704 1
				i8259_disable_irq(hwirq[irq]);
d706 1
d718 1
d720 4
a723 4
	if (irq < 0)
		return;
	if (irq >= PIC_OFFSET)
		irq -= PIC_OFFSET;
d782 1
a782 1
		return;
d802 1
a802 1
		return;
d827 1
a827 1
		return;
d829 1
@


1.14
log
@Correct values for the pci_routes[] pci-to-mpic interrupt routing table,
per the MVME2600APG.
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.13 2004/02/01 22:30:42 miod Exp $	*/
d69 2
d100 1
a100 1
static __inline int openpic_read_irq(int);
a547 1
		imen = ~irqs;
d552 2
d578 2
a579 2
#if 0
	printf("\nmapirq %x to %x\n", irq, v);
d611 2
a613 1
	processing = 1;
a614 1
	pcpl = splhigh();		/* Turn off all */
d657 1
a658 1
	ppc_intr_enable(s);
d716 1
a716 1
		x = openpic_read_irq(0);
d771 1
a771 1
	if (irq < 0 || irq > 15)
d791 1
a791 1
	if (irq < 0 || irq > 15)
d816 1
a816 1
	if (irq < 0 || irq > 15)
d840 1
a840 1
openpic_read_irq(cpu)
d899 4
a902 1
			return 0xff;
d905 1
d919 1
a919 1
	realirq = openpic_read_irq(0);
d921 1
a921 1
	while (realirq != 0xff) {
d923 5
d930 2
a931 2
			if (realirq == 0xff)
				continue;
a955 1
				openpic_eoi(0);
a958 1
				i8259_eoi(realirq);
a964 4
#if 0
				ppc_intr_enable(1);
#endif

a965 4

#if 0
				ppc_intr_disable();
#endif
d976 2
a977 1
			if (realirq >= PIC_OFFSET)
d979 2
a980 1
			else {
d986 1
a986 1
		realirq = openpic_read_irq(0);
a987 1

d1048 1
a1048 1
		openpic_read_irq(0);
@


1.13
log
@More work in attempt to get interrupts working reliably:
- do not update 8259 masks after every modification, but let the code
  responsible for the changes update it at the most appropriate time.
- be sure to correctly acknowledge interrupts on the 8259.
- and various cleaning.

This still fails when interrupts come too fast, at the moment.
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.12 2004/01/30 22:24:27 miod Exp $	*/
d128 4
d137 1
a137 1
	{ 11, 4 },
d139 1
a139 1
	{ 15, 5 },
@


1.12
log
@Some cleaning and sync to the macppc openpic code.
No functional result.
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.11 2004/01/29 10:58:06 miod Exp $	*/
d106 1
a138 2
int isaintrs;

d156 1
a156 1
int i8259_dummy (void *arg);
d160 2
a161 2
typedef void *(intr_establish_t)(void *, mac_intr_handle_t,
    int, int, int (*)(void *), void *, char *);
a195 1
#if 1
a196 1
#endif
d198 5
a203 3
#if 1
	openpic_intr_establish(parent, 0x00, IST_LEVEL, IPL_HIGH,
	    i8259_dummy, (void *)0x00, "8259 Interrupt");
d205 1
a205 2
	    abort_switch, (void *)0x08, "abort button");
#endif
d214 1
d244 1
d256 1
a256 1
 * Register an interrupt handler.
d259 1
a259 1
i8259_intr_establish(lcv, irq, type, level, ih_fun, ih_arg, name)
d266 1
a266 1
	char *name;
a269 1
	extern int cold;
a276 1
	isaintrs++;
a287 3
	case IST_NONE:
		intrtype[irq] = type;
		break;
d310 1
a310 1
	 * this with interrupts enabled and DON'T WANt the real routine called
d327 1
d335 1
a335 1
 * Register an interrupt handler.
d338 1
a338 1
openpic_intr_establish(lcv, irq, type, level, ih_fun, ih_arg, name)
d345 1
a345 1
	char *name;
a349 1
	extern int cold;
d354 5
a358 5
	pr = pci_routes;
	while (pr->pci !=0) {
		irq = (pr->pci == irq) ? pr->openpic : irq;
		pr++;
	}
a370 3
	case IST_NONE:
		intrtype[irq] = type;
		break;
d393 1
a393 1
	 * this with interrupts enabled and DON'T WANt the real routine called
d410 1
d479 1
a479 1
	int irq, level;
d481 1
d485 1
a485 1
		int levels = 0;
d493 1
a493 1
		int irqs = 0;
d520 1
a520 1
		int irqs = 1 << irq;
d527 14
a540 15
	{
		int irqs = 0;
		for (irq = 0; irq < ICU_LEN; irq++) {
			if (intrhand[irq]) {
				irqs |= 1 << irq;
				if (hwirq[irq] >= PIC_OFFSET)
					openpic_enable_irq(hwirq[irq], intrtype[irq]);
				else
					i8259_enable_irq(hwirq[irq], intrtype[irq]);
			} else {
				if (hwirq[irq] >= PIC_OFFSET)
					openpic_disable_irq(hwirq[irq]);
				else
					i8259_disable_irq(hwirq[irq]);
			}
d544 4
a547 3
#if 0
	i8259_enable_irq(2, IST_EDGE);
#endif
d583 1
a583 1
int x;
a587 1

a590 1

d604 1
a607 2
	s = ppc_intr_disable();

a623 2
	/*out32rb(INT_ENABLE_REG, ~imen);*/

d642 1
a642 1
	} while (ipending & (SINT_NET|SINT_CLOCK|SINT_TTY) & ~cpl);
d645 6
a651 1
	processing = 0;
d679 1
a679 1
	for ( irq = 0; irq <= virq_max; irq++) {
d691 2
a692 1
	}
d762 3
a764 1
	if (irq < 0)
d766 3
a768 1
	if (irq < 8)
d770 6
a775 3
	else
		icu2_val |= 1 << (irq - 8);
	i8259_set_irq_mask();
d782 1
d784 1
a784 1
	if (irq < 0)
d786 2
d802 16
a817 1
	i8259_set_irq_mask();
a849 1
#if 0
a861 1
#endif
d872 1
a872 1
	outb(IO_ICU1, 0x0C);
d880 1
a880 1
		outb(IO_ICU2, 0x0C);
d890 2
a891 2
		outb(IO_ICU1, 0x0B);
		if (~inb(IO_ICU1) & 0x80)
d893 1
d916 2
d929 1
a929 3
			if (realirq >= ICU_OFFSET)
				i8259_disable_irq(realirq);
			else {
d932 4
d938 1
a938 3
			if (realirq >= ICU_OFFSET)
				i8259_disable_irq(realirq);
			else {
d941 4
d946 1
d951 1
d953 1
d957 1
d959 1
d970 3
a972 1
			if (realirq >= ICU_OFFSET)
d974 2
a975 2
			else
				openpic_enable_irq(realirq, intrtype[irq]);
d1049 2
@


1.11
log
@Map the raven, pcic, and isa/pci io space virtual rather than 1:1.
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.10 2003/06/02 23:27:53 millert Exp $	*/
a38 4
#if 0
#define OP_DEBUG
#endif 

d45 4
a48 1
#include <uvm/uvm.h>
d54 1
d59 6
a64 6
#define ICU_LEN 32
#define LEGAL_IRQ(x) ((x >= 0) && (x < ICU_LEN))
#define IO_ICU1	(isaspace_va + 0x20)
#define IO_ICU2	(isaspace_va + 0xA0)
#define IO_ELCR1	(isaspace_va + 0x4D0)
#define IO_ELCR2	(isaspace_va + 0x4D1)
a73 2
#define SET_ICUS()	(outb(IO_ICU1 + 1, imen), outb(IO_ICU2 + 1, imen >> 8))

d77 1
a77 1
unsigned int imen	/* = 0xffffffff */; /* XXX */
d92 15
a106 16
static   __inline u_int openpic_read(int);
static   __inline void openpic_write(int, u_int);
void  openpic_enable_irq(int, int);
void  openpic_disable_irq(int);
void  openpic_init(void);
void  openpic_set_priority(int, int);
void  openpic_set_vec_pri(int, int);
static   __inline int openpic_read_irq(int);
static   __inline void openpic_eoi(int);
void openpic_initirq(int, int, int, int, int);

void  i8259_init(void);
int   i8259_intr(void);
void  i8259_enable_irq(int, int);
void  i8259_disable_irq(int);
void  *i8259_intr_establish(void *, int, int, int, int (*)(void *), void *,
d108 1
a108 1
void  i8259_set_irq_mask(void);
d114 4
a117 4
int   openpic_match(struct device *parent, void *cf, void *aux);
void  openpic_attach(struct device *, struct device *, void *);
void  openpic_do_pending_int(void);
void  ext_intr_openpic(void);
d119 1
a119 1
struct cfattach openpic_ca = { 
d141 1
a141 1
openpic_match(parent, cf, aux) 
d154 1
a154 1
typedef void  (void_f) (void);
d161 1
a161 1
typedef void  *(intr_establish_t)(void *, mac_intr_handle_t,
d194 2
a195 3
	intr_establish_func  = i8259_intr_establish;
	intr_disestablish_func  = openpic_intr_disestablish;
	install_extint(ext_intr_openpic);
d204 1
a204 1
							  i8259_dummy, (void *)0x00, "8259 Interrupt");
d206 1
a206 1
								abort_switch, (void *)0x08, "abort button");
d208 1
a208 1
	
d219 3
a221 3
				 ppc_configed_intr[i].ih_what, ppc_configed_intr[i].ih_irq,
				 ppc_configed_intr[i].ih_level, ppc_configed_intr[i].ih_fun,
				 ppc_configed_intr[i].ih_arg);
d224 3
a226 3
									  IST_LEVEL, ppc_configed_intr[i].ih_level,
									  ppc_configed_intr[i].ih_fun, ppc_configed_intr[i].ih_arg,
									  ppc_configed_intr[i].ih_what);
d234 2
a235 2
	printf("Abort button pressed, entering debugger.\n");
	Debugger();
a251 1

d273 1
a273 1
	fakehand.ih_fun  = fakeintr;
d357 1
a357 1
	fakehand.ih_fun  = fakeintr;
d386 2
a387 2
			   intr_typename(intrtype[irq]),
			   intr_typename(type));
d488 1
a488 3
#ifdef OP_DEBUG
	printf("intr_calculatemasks() ");
#endif 
d491 1
a491 1
		register int levels = 0;
d498 2
a499 2
	for (level = 0; level < 5; level++) {
		register int irqs = 0;
d509 1
a509 4
	 */
	imask[IPL_IMP] |= imask[IPL_TTY] | imask[IPL_NET] | imask[IPL_BIO];

	/*
a512 1
	imask[IPL_TTY] |= imask[IPL_NET] | imask[IPL_BIO];
d514 3
d526 1
a526 1
		register int irqs = 1 << irq;
d534 1
a534 1
		register int irqs = 0;
d538 3
a540 1
				if (hwirq[irq] < PIC_OFFSET)
a541 2
				else
					openpic_enable_irq(hwirq[irq], intrtype[irq]);
d549 1
d553 1
a553 1
#endif 
d565 1
d568 2
d606 1
a606 1
	int emsr, dmsr;
a611 3
#ifdef OP_DEBUG
	printf("openpic_do_pending_int()\n");
#endif 
d613 1
d615 1
a615 3
	asm volatile("mfmsr %0" : "=r"(emsr));
	dmsr = emsr & ~PSL_EE;
	asm volatile("mtmsr %0" :: "r"(dmsr));
a619 1

d647 7
a653 1
	} while (ipending & (SINT_NET|SINT_CLOCK) & ~cpl);
d656 1
a656 1
	asm volatile("mtmsr %0" :: "r"(emsr));
d665 1
a665 1
	
d684 1
a684 3
#ifdef OP_DEBUG
	printf("openpic_enable_irq_mask()\n");
#endif 
d706 1
d708 1
a708 1
	if (irq == -1)
a711 3
#ifdef OP_DEBUG
	printf("enabeling irq %d, %s, val = 0x%x\n", irq, (type == IST_EDGE) ? "EDGE":"LEVEL", openpic_read(OPENPIC_SRC_VECTOR(irq)));
#endif 
d713 1
a713 1
	while((x = openpic_read(OPENPIC_SRC_VECTOR(irq))) & OPENPIC_ACTIVITY){
a715 3
#ifdef OP_DEBUG
		printf("x=0x%x\n", x);
#endif 
d717 1
a717 1
	
d724 2
a725 2
#endif 
	if (type == IST_LEVEL) {
d727 1
a727 1
	} else {
a728 5
	}
#ifdef OP_DEBUG
	printf("enabeling irq %d, %s, %s, val 0x%08x\n", irq, (type == IST_EDGE) ? "EDGE":"LEVEL", (x & OPENPIC_POLARITY_POSITIVE) ? "H":"L", x);
#endif 

d737 1
a743 4
#ifdef OP_DEBUG
	printf("disabeling irq %d, val 0x%08x\n", irq, x);
#endif 

d747 1
a747 1
void 
d750 1
a750 1
	if (icu2_val != 0xFF) {
d752 1
a752 4
#ifdef OP_DEBUG
		printf("turning on ICU2\n");
#endif 
		icu1_val &= ~(1 << 2);
d754 1
a754 1
		icu1_val |= (1 << 2);
a760 4
#ifdef OP_DEBUG
	printf("ICU  %x-%x\n", icu2_val, icu1_val);
	printf("ELCR %x-%x\n", elcr2_val, elcr1_val);
#endif 
d767 1
a767 1
	if (irq == -1)
d772 1
a772 1
		icu2_val	|= 1 << (irq - 8);
a773 3
#ifdef OP_DEBUG
	printf("disabeling isa irq %d\n", irq);
#endif 
d776 1
a776 1
void 
d778 1
a778 1
	int irq, type; 
d781 1
a781 1
	if (irq == -1)
d783 1
a783 1
	if ( irq < 8 ){
d785 1
a785 1
		if (type == IST_LEVEL) {
d787 1
a787 1
		} else {
a788 1
		}
d790 6
a795 6
		icu2_val	&= ~(1 << (irq - 8));
		if (type == IST_LEVEL) {
			elcr2_val |= (1 << (irq - 8));
		} else {
			elcr2_val &= ~(1 << (irq - 8));
		}
a797 4
#ifdef OP_DEBUG
	printf("enabeling isa irq %d, %s\n", irq, (type == IST_EDGE) ? "EDGE":"LEVEL");
#endif 

d843 1
a843 1
#endif 
d856 2
a857 4
#ifdef OP_DEBUG
	printf("isa intr = %d\n", irq);
#endif 
	if (irq == 2) {
d864 1
a864 1
	} else if (irq==7) {
d870 2
a871 2
* interrupt
*/
d873 2
a874 2
		if (~inb(IO_ICU1)&0x80)
			return 0xFF;
d884 1
a884 1
	int pcpl;
d887 1
a887 4
#ifdef OP_DEBUG
	printf("Interrupt!\n");
#endif 
	pcpl = splhigh();			/* Turn off all */
a889 3
#ifdef OP_DEBUG
	printf("irq %d\n", realirq);
#endif 
d891 1
a891 1
	while (realirq != 0xFF) {
a893 3
#ifdef OP_DEBUG
			printf("irq2 %d\n", realirq);
#endif 
d895 1
a895 1
			if (realirq == 0xFF)
d910 1
a910 1
			else
d912 2
d915 8
d925 2
d928 2
d932 1
d934 4
d939 5
a945 2
		openpic_eoi(0);

d949 3
a951 1
	splx(pcpl);		 /* Process pendings. */
d955 1
a955 1
openpic_set_vec_pri(int irq, int pri)
a957 5
	x = openpic_read(OPENPIC_SRC_VECTOR(irq));
	x &= ~OPENPIC_PRIORITY_MASK;
	x |= pri << OPENPIC_PRIORITY_SHIFT;
	openpic_write(OPENPIC_SRC_VECTOR(irq), x);
}
d959 1
a959 5
void
openpic_initirq(int irq, int pri, int vec, int pol, int sense)
{
	u_int x;
	x = (vec & OPENPIC_VECTOR_MASK);
d963 1
a963 1
	x |= pri << OPENPIC_PRIORITY_SHIFT;
d976 4
a979 4
      intrtype[irq] = IST_NONE;
      intrmask[irq] = 0;
      intrlevel[irq] = 0;
      intrhand[irq] = NULL;
a981 1
	
d994 1
a994 2
	openpic_initirq(0, 8, 0, 1, 0);

d996 1
a996 1
		openpic_initirq(irq, 8, irq, 0, 1);
d1000 3
a1002 1
	openpic_write(OPENPIC_SPURIOUS_VECTOR, 0xFF);   
d1007 1
a1007 1
	/* clear all pending interrunts */
d1013 1
a1013 1
	for (irq = 0; irq < PIC_OFFSET; irq++) {
@


1.10
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.9 2002/06/08 15:49:52 miod Exp $	*/
d61 4
a64 4
#define IO_ICU1	(RAVEN_P_ISA_IO_SPACE + 0x20)
#define IO_ICU2	(RAVEN_P_ISA_IO_SPACE + 0xA0)
#define IO_ELCR1	(RAVEN_P_ISA_IO_SPACE + 0x4D0)
#define IO_ELCR2	(RAVEN_P_ISA_IO_SPACE + 0x4D1)
d76 3
a78 3
static int intrtype[ICU_LEN], intrmask[ICU_LEN], intrlevel[ICU_LEN];
static struct intrhand *intrhand[ICU_LEN] = { 0};
static int hwirq[ICU_LEN], virq[ICU_LEN];
d80 1
a80 1
static int virq_max = 0;
d84 3
a86 3
static int fakeintr(void *);
static char *intr_typename(int type);
static void intr_calculatemasks(void);
d88 1
a88 1
static int mapirq(int irq);
a90 2
static struct raven_reg *ravenp = (struct raven_reg *)NULL;

d123 1
a123 3
	sizeof(struct openpic_softc),
	openpic_match,
	openpic_attach
d130 1
a130 1
struct pci_route {
d141 1
a141 1
static int isaintrs = 0;
d145 3
a147 3
struct device *parent;
void *cf;
void *aux;
a151 7
	/* don't attach more than once. */
	if (ravenp != (struct raven_reg *)NULL) {
#ifdef DIAGNOSTIC
		printf("openpic: trying to attach more than once!");
#endif
		return (0);
	}
d159 2
a160 2
static int abort_switch (void *arg);
static int i8259_dummy (void *arg);
d168 3
a170 1
static vaddr_t openpic_base;
d178 2
a179 2
struct device *parent, *self;
void *aux;
d183 7
a189 5
#if 0
	extern intr_establish_t *mac_intr_establish_func;
	extern intr_disestablish_t *mac_intr_disestablish_func;
#endif 
	openpic_base = (vaddr_t)mapiodev(MPCIC_REG, 0x22000);
a198 4
#if 0
	mac_intr_establish_func  = openpic_intr_establish;
	mac_intr_disestablish_func  = openpic_intr_disestablish;
#endif 
d234 2
a235 2
static int
abort_switch (void *arg)
d246 2
a247 2
static int
i8259_dummy (void *arg)
d252 1
a252 1
static int
d254 1
a254 1
void *arg;
d265 7
a271 7
void * lcv;
int irq;
int type;
int level;
int (*ih_fun)(void *);
void *ih_arg;
char *name;
a284 3
#if 0
	printf("vI %d ", irq);
#endif
d305 2
a306 2
					intr_typename(intrtype[irq]),
					intr_typename(type));
d348 7
a354 7
void * lcv;
int irq;
int type;
int level;
int (*ih_fun)(void *);
void *ih_arg;
char *name;
d358 1
a358 1
	struct pci_route *pr;
a363 4
#if 0
	printf("mac_intr_establish, hI %d L %d ", irq, type);
#endif

a370 3
#if 0
	printf("vI %d ", irq);
#endif
d391 2
a392 2
					intr_typename(intrtype[irq]),
					intr_typename(type));
d433 2
a434 2
void *lcp;
void *arg;
d461 1
a461 2

static char *
d463 1
a463 1
int type;
d475 1
a477 2
#if 1 /* XXX */
		return ("unknown");
d488 1
a488 1
static void
d562 1
d566 1
a566 1
static int
d568 1
a568 1
int irq;
d665 1
a665 1
int reg;
d674 2
a675 2
int reg;
u_int val;
d684 1
a684 1
int irq_mask;
d707 2
a708 2
int irq;
int type;
d749 1
a749 1
int irq;
d790 1
a790 1
int irq;
d806 1
a806 1
int irq, type; 
d835 1
a835 1
int cpu, pri;
d847 1
a847 1
int cpu;
d854 1
a854 1
int cpu;
d860 2
a861 1
void i8259_init(void)
d879 2
a880 1
int i8259_intr(void)
d974 2
a975 1
void openpic_set_vec_pri(int irq, int pri)
d984 2
a985 1
void openpic_initirq(int irq, int pri, int vec, int pol, int sense)
@


1.9
log
@Strict prototypes, and some KNF touches while there.
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.8 2002/03/14 03:15:58 millert Exp $	*/
d20 1
a20 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.8
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.7 2002/03/14 01:26:41 millert Exp $	*/
d90 1
a90 1
static void intr_calculatemasks();
d104 1
a104 1
void  openpic_init();
d109 1
d115 3
a117 2
void  *i8259_intr_establish( void * lcv, int irq, int type, int level,
									  int (*ih_fun)(void *), void *ih_arg, char *name);
d125 2
a126 2
void  openpic_do_pending_int();
void  ext_intr_openpic();
d179 3
a181 3
typedef void     *(intr_establish_t)(void *, mac_intr_handle_t,
														int, int, int (*func)(void *), void *, char *);
typedef void     (intr_disestablish_t)(void *, void *);
d184 4
a187 4
void * openpic_intr_establish( void * lcv, int irq, int type, int level,
										 int (*ih_fun)(void *), void *ih_arg, char *name);
void openpic_intr_disestablish( void *lcp, void *arg);
void openpic_collect_preconf_intr();
@


1.7
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.6 2001/11/06 22:45:54 miod Exp $	*/
d177 2
a178 2
typedef void     *(intr_establish_t) __P((void *, mac_intr_handle_t,
														int, int, int (*func)(void *), void *, char *));
@


1.6
log
@-Wall -Werror cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.5 2001/11/06 19:53:15 miod Exp $	*/
d88 1
a88 1
static int fakeintr __P((void *));
d100 4
a103 4
static   __inline u_int openpic_read __P((int));
static   __inline void openpic_write __P((int, u_int));
void  openpic_enable_irq __P((int, int));
void  openpic_disable_irq __P((int));
d105 9
a113 9
void  openpic_set_priority __P((int, int));
void  openpic_set_vec_pri __P((int, int));
static   __inline int openpic_read_irq __P((int));
static   __inline void openpic_eoi __P((int));

void  i8259_init __P((void));
int   i8259_intr __P((void));
void  i8259_enable_irq __P((int, int));
void  i8259_disable_irq __P((int));
d115 1
a115 1
									  int (*ih_fun) __P((void *)), void *ih_arg, char *name);
d121 2
a122 2
int   openpic_match __P((struct device *parent, void *cf, void *aux));
void  openpic_attach __P((struct device *, struct device *, void *));
d179 1
a179 1
typedef void     (intr_disestablish_t) __P((void *, void *));
d183 1
a183 1
										 int (*ih_fun) __P((void *)), void *ih_arg, char *name);
d282 1
a282 1
int (*ih_fun) __P((void *));
d368 1
a368 1
int (*ih_fun) __P((void *));
@


1.6.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.6 2001/11/06 22:45:54 miod Exp $	*/
d88 1
a88 1
static int fakeintr(void *);
d90 1
a90 1
static void intr_calculatemasks(void);
d100 16
a115 18
static   __inline u_int openpic_read(int);
static   __inline void openpic_write(int, u_int);
void  openpic_enable_irq(int, int);
void  openpic_disable_irq(int);
void  openpic_init(void);
void  openpic_set_priority(int, int);
void  openpic_set_vec_pri(int, int);
static   __inline int openpic_read_irq(int);
static   __inline void openpic_eoi(int);
void openpic_initirq(int, int, int, int, int);

void  i8259_init(void);
int   i8259_intr(void);
void  i8259_enable_irq(int, int);
void  i8259_disable_irq(int);
void  *i8259_intr_establish(void *, int, int, int, int (*)(void *), void *,
    char *);
void  i8259_set_irq_mask(void);
d121 4
a124 4
int   openpic_match(struct device *parent, void *cf, void *aux);
void  openpic_attach(struct device *, struct device *, void *);
void  openpic_do_pending_int(void);
void  ext_intr_openpic(void);
d177 3
a179 3
typedef void  *(intr_establish_t)(void *, mac_intr_handle_t,
    int, int, int (*)(void *), void *, char *);
typedef void (intr_disestablish_t)(void *, void *);
d182 4
a185 4
void * openpic_intr_establish(void *, int, int, int, int (*)(void *), void *,
    char *);
void openpic_intr_disestablish(void *, void *);
void openpic_collect_preconf_intr(void);
d282 1
a282 1
int (*ih_fun)(void *);
d368 1
a368 1
int (*ih_fun)(void *);
@


1.5
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.4 2001/09/11 20:05:24 miod Exp $	*/
a92 1
static int read_irq();
d140 5
a144 5
	10, 2,
	11, 4,
	14, 3,
	15, 5,
	0, 0,
a154 2
	struct confargs *ca = aux;

a191 2
	struct confargs *ca = aux;
	struct openpic_softc *sc = (void *)self;
d845 1
a845 1
			elcr2_val |= (1 << irq - 8);
d847 1
a847 1
			elcr2_val &= ~(1 << irq - 8);
@


1.4
log
@Don't include <vm/vm_kern.h> if you don't need foo_map.
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.3 2001/07/06 05:14:29 smurph Exp $	*/
a52 1
#include <vm/vm.h>
@


1.3
log
@resolve compile problems
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.2 2001/06/27 04:32:45 art Exp $	*/
a53 1
#include <vm/vm_kern.h>
@


1.2
log
@whack old vm
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.1 2001/06/26 21:57:41 smurph Exp $	*/
d69 2
d72 3
a74 1
#define ICU_OFFSET	16
d77 2
d83 1
a83 1
static struct intrhand *intrhand[ICU_LEN] = { 0 };
d85 1
a85 1
unsigned int imen /* = 0xffffffff */; /* XXX */
d103 16
a118 17

static	__inline u_int openpic_read __P((int));
static	__inline void openpic_write __P((int, u_int));
void	openpic_enable_irq __P((int, int));
void	openpic_disable_irq __P((int));
void	openpic_init();
void	openpic_set_priority __P((int, int));
void	openpic_set_vec_pri __P((int, int));
static	__inline int openpic_read_irq __P((int));
static	__inline void openpic_eoi __P((int));

void	i8259_init __P((void));
int	i8259_intr __P((void));
void	i8259_enable_irq __P((int));
void	i8259_disable_irq __P((int));
void	*i8259_intr_establish( void * lcv, int irq, int type, int level,
		int (*ih_fun) __P((void *)), void *ih_arg, char *name);
d124 4
a127 4
int	openpic_match __P((struct device *parent, void *cf, void *aux));
void	openpic_attach __P((struct device *, struct device *, void *));
void	openpic_do_pending_int();
void	ext_intr_openpic();
d154 3
a156 3
	struct device *parent;
	void *cf;
	void *aux;
d164 1
a164 1
	if (ravenp != (struct raven_reg *)NULL){
d168 1
a168 1
		return(0);
d183 1
a183 1
            int, int, int (*func)(void *), void *, char *));
d186 1
a186 1
vaddr_t openpic_base;
d188 1
a188 1
	int (*ih_fun) __P((void *)), void *ih_arg, char *name);
d194 2
a195 2
	struct device *parent, *self;
	void *aux;
d205 1
a205 1
	openpic_base = (vaddr_t)MPCIC_REG/* mapiodev (MPCIC_REG, 0x22000)*/;
d213 1
a213 1
	intr_establish_func  = openpic_intr_establish;
d220 1
a220 1
	
d225 1
d227 2
a228 3

	intr_establish_func(parent, 0x00, IST_LEVEL, IPL_HIGH,
		i8259_dummy, (void *)0x00, "8259 Interrupt");
d230 1
a230 1
		abort_switch, (void *)0x08, "abort button");
d232 1
a232 3
/*	
	ppc_intr_enable(1);
*/
d243 3
a245 3
		    ppc_configed_intr[i].ih_what, ppc_configed_intr[i].ih_irq,
		    ppc_configed_intr[i].ih_level, ppc_configed_intr[i].ih_fun,
		    ppc_configed_intr[i].ih_arg);
d248 3
a250 3
		    IST_LEVEL, ppc_configed_intr[i].ih_level,
		    ppc_configed_intr[i].ih_fun, ppc_configed_intr[i].ih_arg,
		    ppc_configed_intr[i].ih_what);
d274 1
a274 1
	void *arg;
d285 7
a291 7
	void * lcv;
	int irq;
	int type;
	int level;
	int (*ih_fun) __P((void *));
	void *ih_arg;
	char *name;
d301 1
a301 1
printf("i8259_intr_establish, hI %d L %d ", irq, type);
d306 1
a306 1
printf("vI %d ", irq);
d328 2
a329 2
			    intr_typename(intrtype[irq]),
			    intr_typename(type));
d371 7
a377 7
	void * lcv;
	int irq;
	int type;
	int level;
	int (*ih_fun) __P((void *));
	void *ih_arg;
	char *name;
d381 1
a381 1
        struct pci_route *pr;
d388 1
a388 1
printf("mac_intr_establish, hI %d L %d ", irq, type);
d397 1
a397 1
	irq = mapirq(irq);
d399 1
a399 1
printf("vI %d ", irq);
d421 2
a422 2
			    intr_typename(intrtype[irq]),
			    intr_typename(type));
d463 2
a464 2
	void *lcp;
	void *arg;
d494 1
a494 1
	int type;
d498 1
a498 1
        case IST_NONE :
d500 1
a500 1
        case IST_PULSE:
d502 1
a502 1
        case IST_EDGE:
d504 1
a504 1
        case IST_LEVEL:
d578 3
a580 3
				if (hwirq[irq] >= ICU_OFFSET)
					i8259_enable_irq(hwirq[irq]);
				else 
d583 2
a584 2
				if (hwirq[irq] >= ICU_OFFSET)
                                        i8259_disable_irq(hwirq[irq]);
d586 1
a586 1
					openpic_disable_irq(hwirq[irq]);
d591 1
a591 1
	i8259_enable_irq(2);
d599 1
a599 1
	int irq;
d613 1
a613 1
printf("\nmapirq %x to %x\n", irq, v);
d624 1
a624 1
	int x;
d665 1
a665 1
		while(ih) {
d676 1
a676 1
		if((ipending & SINT_CLOCK) & ~pcpl) {
d680 1
a680 1
		if((ipending & SINT_NET) & ~pcpl) {
d696 1
a696 1
	int reg;
d699 1
a699 1

d705 2
a706 2
	int reg;
	u_int val;
d723 2
a724 2
			if (hwirq[irq] >= ICU_OFFSET)
				i8259_enable_irq(hwirq[irq]);
d726 1
a726 1
				openpic_enable_irq(hwirq[irq], intrtype[irq]);
d728 3
a730 1
			if (hwirq[irq] >= ICU_OFFSET)
a731 2
			else 
				openpic_disable_irq(hwirq[irq]);
d738 2
a739 2
	int irq;
	int type;
d743 1
a743 1
	if (irq == -1) 
d745 13
d759 7
a765 2
	x = openpic_read(OPENPIC_SRC_VECTOR(irq));
	x &= ~(OPENPIC_IMASK|OPENPIC_SENSE_LEVEL|OPENPIC_SENSE_EDGE);
d772 1
a772 1
	printf("enabeling irq %d, type %d, val 0x%08x\n", irq, type, x);
d780 1
a780 1
	int irq;
d784 3
a786 3
	if (irq == -1) 
		return;
	
d792 1
a792 1
	
d799 1
a799 1
        if (icu2_val != 0xFF) {
d801 4
a804 1
                icu1_val &= ~(1 << 2);
d806 1
a806 1
                icu1_val |= (1 << 2);
d810 7
a816 1
        outb(IO_ICU2 + 1, icu2_val);
d823 7
a829 7
        if (irq >= ICU_OFFSET)
                irq -= ICU_OFFSET;
        if (irq < 8)
                icu1_val |= 1 << irq;
        else
                icu2_val |= 1 << (irq - 8);
        i8259_set_irq_mask();
d836 2
a837 2
i8259_enable_irq(irq)
int irq; 
d839 19
a857 8

        if (irq >= ICU_OFFSET)
                irq -= ICU_OFFSET;
        if ( irq < 8 )
                icu1_val &= ~(1 << irq);
        else
                icu2_val &= ~(1 << (irq - 8));
        i8259_set_irq_mask();
d859 1
a859 1
	printf("enabeling isa irq %d\n", irq);
d866 1
a866 1
        int cpu, pri;
d878 1
a878 1
	int cpu;
d885 1
a885 1
        int cpu;
d887 2
a888 2
        openpic_write(OPENPIC_EOI(cpu), 0);
        openpic_read(OPENPIC_EOI(cpu));
d893 1
d897 1
a897 1
	outb(IO_ICU1+1, 1 << IRQ_SLAVE); /* slave on line 2 */
d900 1
a900 1
        /* init interrupt controller 2 */
d906 1
d913 5
a917 5
        /*
         * Perform an interrupt acknowledge cycle on controller 1
         */
        outb(IO_ICU1, 0x0C);
        irq = inb(IO_ICU1) & 7;
d921 4
a924 17
        if (irq == 2)
        {
                /*
                 * Interrupt is cascaded so perform interrupt
                 * acknowledge on controller 2
                 */
                outb(IO_ICU2, 0x0C);
                irq = (inb(IO_ICU2) & 7) + 8;
        }
        else if (irq==7)
        {
                /*
                 * This may be a spurious interrupt
                 *
                 * Read the interrupt status register. If the most
                 * significant bit is not set then there is no valid
		 * interrupt
d926 10
d937 1
a937 1
		if(~inb(IO_ICU1)&0x80)
d954 1
a954 1
	pcpl = splhigh();       /* Turn off all */
d961 2
a962 2
	while ((realirq != 0xFF) && (realirq != 0xAA)) {
		if (realirq == 0x00){
d967 1
a967 1
                        openpic_eoi(0);
d971 1
a971 1
		
d980 1
a980 1
			ipending |= r_imen;     /* Masked! Mark this as pending */
d983 1
a983 1
			else 
d1000 1
a1000 1
	splx(pcpl);     /* Process pendings. */
d1005 1
a1005 1
        u_int x;
d1014 1
a1014 1
        u_int x;
d1026 3
a1028 3
        int irq;
        u_int x;
        
d1030 20
a1049 15
        for (irq = 0; irq < ICU_LEN; irq++){
                hwirq[irq] = -1;
                openpic_write(OPENPIC_SRC_VECTOR(irq), OPENPIC_IMASK);
	}
        openpic_set_priority(0, 15);

        /* we don't need 8259 pass through mode */
        x = openpic_read(OPENPIC_CONFIG);
        x |= OPENPIC_CONFIG_8259_PASSTHRU_DISABLE;
        openpic_write(OPENPIC_CONFIG, x);

        /* send all interrupts to cpu 0 */
        for (irq = 0; irq < ICU_LEN; irq++)
                openpic_write(OPENPIC_SRC_DEST(irq), CPU(0));
        
d1052 1
a1052 1
	
d1054 5
a1058 2
                openpic_initirq(irq, 8, irq, 0, 1);
        }
d1060 1
a1060 4
        /* XXX set spurious intr vector */
	openpic_write(OPENPIC_SPURIOUS_VECTOR, 0xFF);
        
	/* unmask interrupts for cpu 0 */	
d1063 5
a1067 5
        /* clear all pending interrunts */
        for (irq = 0; irq < ICU_OFFSET; irq++) {
                openpic_read_irq(0);
                openpic_eoi(0);
        }
d1069 1
a1069 1
        for (irq = 0; irq < ICU_OFFSET; irq++){
d1071 1
a1071 1
                openpic_disable_irq(irq);
d1073 1
a1073 1
        
@


1.2.2.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.2 2001/06/27 04:32:45 art Exp $	*/
d54 1
a68 2
#define IO_ELCR1	(RAVEN_P_ISA_IO_SPACE + 0x4D0)
#define IO_ELCR2	(RAVEN_P_ISA_IO_SPACE + 0x4D1)
d70 1
a70 3
#define ICU_OFFSET	0
#define PIC_OFFSET	16

a72 2
unsigned char elcr1_val = 0x00;
unsigned char elcr2_val = 0x00;
d77 1
a77 1
static struct intrhand *intrhand[ICU_LEN] = { 0};
d79 1
a79 1
unsigned int imen	/* = 0xffffffff */; /* XXX */
d97 17
a113 16
static   __inline u_int openpic_read __P((int));
static   __inline void openpic_write __P((int, u_int));
void  openpic_enable_irq __P((int, int));
void  openpic_disable_irq __P((int));
void  openpic_init();
void  openpic_set_priority __P((int, int));
void  openpic_set_vec_pri __P((int, int));
static   __inline int openpic_read_irq __P((int));
static   __inline void openpic_eoi __P((int));

void  i8259_init __P((void));
int   i8259_intr __P((void));
void  i8259_enable_irq __P((int, int));
void  i8259_disable_irq __P((int));
void  *i8259_intr_establish( void * lcv, int irq, int type, int level,
									  int (*ih_fun) __P((void *)), void *ih_arg, char *name);
d119 4
a122 4
int   openpic_match __P((struct device *parent, void *cf, void *aux));
void  openpic_attach __P((struct device *, struct device *, void *));
void  openpic_do_pending_int();
void  ext_intr_openpic();
d149 3
a151 3
struct device *parent;
void *cf;
void *aux;
d159 1
a159 1
	if (ravenp != (struct raven_reg *)NULL) {
d163 1
a163 1
		return (0);
d178 1
a178 1
														int, int, int (*func)(void *), void *, char *));
d181 1
a181 1
static vaddr_t openpic_base;
d183 1
a183 1
										 int (*ih_fun) __P((void *)), void *ih_arg, char *name);
d189 2
a190 2
struct device *parent, *self;
void *aux;
d200 1
a200 1
	openpic_base = (vaddr_t)mapiodev(MPCIC_REG, 0x22000);
d208 1
a208 1
	intr_establish_func  = i8259_intr_establish;
d215 1
a215 1

d220 1
d222 2
a223 3
#if 1
	openpic_intr_establish(parent, 0x00, IST_LEVEL, IPL_HIGH,
							  i8259_dummy, (void *)0x00, "8259 Interrupt");
d225 1
a225 1
								abort_switch, (void *)0x08, "abort button");
d227 3
a229 1
	
d240 3
a242 3
				 ppc_configed_intr[i].ih_what, ppc_configed_intr[i].ih_irq,
				 ppc_configed_intr[i].ih_level, ppc_configed_intr[i].ih_fun,
				 ppc_configed_intr[i].ih_arg);
d245 3
a247 3
									  IST_LEVEL, ppc_configed_intr[i].ih_level,
									  ppc_configed_intr[i].ih_fun, ppc_configed_intr[i].ih_arg,
									  ppc_configed_intr[i].ih_what);
d271 1
a271 1
void *arg;
d282 7
a288 7
void * lcv;
int irq;
int type;
int level;
int (*ih_fun) __P((void *));
void *ih_arg;
char *name;
d298 1
a298 1
	printf("i8259_intr_establish, %d, %s", irq, (type == IST_EDGE) ? "EDGE":"LEVEL"));
d303 1
a303 1
	printf("vI %d ", irq);
d325 2
a326 2
					intr_typename(intrtype[irq]),
					intr_typename(type));
d368 7
a374 7
void * lcv;
int irq;
int type;
int level;
int (*ih_fun) __P((void *));
void *ih_arg;
char *name;
d378 1
a378 1
	struct pci_route *pr;
d385 1
a385 1
	printf("mac_intr_establish, hI %d L %d ", irq, type);
d394 1
a394 1
	irq = mapirq(irq + PIC_OFFSET);
d396 1
a396 1
	printf("vI %d ", irq);
d418 2
a419 2
					intr_typename(intrtype[irq]),
					intr_typename(type));
d460 2
a461 2
void *lcp;
void *arg;
d491 1
a491 1
int type;
d495 1
a495 1
	case IST_NONE :
d497 1
a497 1
	case IST_PULSE:
d499 1
a499 1
	case IST_EDGE:
d501 1
a501 1
	case IST_LEVEL:
d575 3
a577 3
				if (hwirq[irq] < PIC_OFFSET)
					i8259_enable_irq(hwirq[irq], intrtype[irq]);
				else
d580 3
a582 1
				if (hwirq[irq] >= PIC_OFFSET)
a583 2
				else
					i8259_disable_irq(hwirq[irq]);
d588 1
a588 1
	i8259_enable_irq(2, IST_EDGE);
d596 1
a596 1
int irq;
d610 1
a610 1
	printf("\nmapirq %x to %x\n", irq, v);
d621 1
a621 1
int x;
d662 1
a662 1
		while (ih) {
d673 1
a673 1
		if ((ipending & SINT_CLOCK) & ~pcpl) {
d677 1
a677 1
		if ((ipending & SINT_NET) & ~pcpl) {
d693 1
a693 1
int reg;
d696 1
a696 1
	
d702 2
a703 2
int reg;
u_int val;
d720 3
a722 1
			if (hwirq[irq] >= PIC_OFFSET)
a723 2
			else
				i8259_enable_irq(hwirq[irq], intrtype[irq]);
d725 3
a727 1
			if (hwirq[irq] >= PIC_OFFSET)
a728 2
			else
				i8259_disable_irq(hwirq[irq]);
d735 2
a736 2
int irq;
int type;
d740 1
a740 1
	if (irq == -1)
a741 13
	if (irq >= PIC_OFFSET)
		irq -= PIC_OFFSET;
#ifdef OP_DEBUG
	printf("enabeling irq %d, %s, val = 0x%x\n", irq, (type == IST_EDGE) ? "EDGE":"LEVEL", openpic_read(OPENPIC_SRC_VECTOR(irq)));
#endif 

	while((x = openpic_read(OPENPIC_SRC_VECTOR(irq))) & OPENPIC_ACTIVITY){
		x = openpic_read_irq(0);
		openpic_eoi(0);
#ifdef OP_DEBUG
		printf("x=0x%x\n", x);
#endif 
	}
d743 2
a744 7
	x &= ~(OPENPIC_IMASK|OPENPIC_SENSE_LEVEL|OPENPIC_SENSE_EDGE|
			 OPENPIC_POLARITY_POSITIVE);
#if 1
	if (irq == 0) {
		x |= OPENPIC_POLARITY_POSITIVE;
	}
#endif 
d751 1
a751 1
	printf("enabeling irq %d, %s, %s, val 0x%08x\n", irq, (type == IST_EDGE) ? "EDGE":"LEVEL", (x & OPENPIC_POLARITY_POSITIVE) ? "H":"L", x);
d759 1
a759 1
int irq;
d763 3
a765 3
	if (irq >= PIC_OFFSET)
		irq -= PIC_OFFSET;

d771 1
a771 1

d778 1
a778 1
	if (icu2_val != 0xFF) {
d780 1
a780 4
#ifdef OP_DEBUG
		printf("turning on ICU2\n");
#endif 
		icu1_val &= ~(1 << 2);
d782 1
a782 1
		icu1_val |= (1 << 2);
d786 1
a786 7
	outb(IO_ICU2 + 1, icu2_val);
	outb(IO_ELCR1, elcr1_val);
	outb(IO_ELCR2, elcr2_val);
#ifdef OP_DEBUG
	printf("ICU  %x-%x\n", icu2_val, icu1_val);
	printf("ELCR %x-%x\n", elcr2_val, elcr1_val);
#endif 
d793 7
a799 7
	if (irq == -1)
		return;
	if (irq < 8)
		icu1_val |= 1 << irq;
	else
		icu2_val	|= 1 << (irq - 8);
	i8259_set_irq_mask();
d806 2
a807 2
i8259_enable_irq(irq, type)
int irq, type; 
d809 8
a816 19
	/* skip invalid irqs */
	if (irq == -1)
		return;
	if ( irq < 8 ){
		icu1_val &= ~(1 << irq);
		if (type == IST_LEVEL) {
			elcr1_val |= (1 << irq);
		} else {
			elcr1_val &= ~(1 << irq);
		}
	} else {
		icu2_val	&= ~(1 << (irq - 8));
		if (type == IST_LEVEL) {
			elcr2_val |= (1 << irq - 8);
		} else {
			elcr2_val &= ~(1 << irq - 8);
		}
	}
	i8259_set_irq_mask();
d818 1
a818 1
	printf("enabeling isa irq %d, %s\n", irq, (type == IST_EDGE) ? "EDGE":"LEVEL");
d825 1
a825 1
int cpu, pri;
d837 1
a837 1
int cpu;
d844 1
a844 1
int cpu;
d846 2
a847 2
	openpic_write(OPENPIC_EOI(cpu), 0);
	openpic_read(OPENPIC_EOI(cpu));
a851 1
#if 0
d855 1
a855 1
	outb(IO_ICU1+1, 1 << IRQ_SLAVE);	/* slave on line 2 */
d858 1
a858 1
	/* init interrupt controller 2 */
a863 1
#endif 
d870 5
a874 5
	/*
	 * Perform an interrupt acknowledge cycle on controller 1
	 */
	outb(IO_ICU1, 0x0C);
	irq = inb(IO_ICU1) & 7;
d878 17
a894 4
	if (irq == 2) {
		/*
		 * Interrupt is cascaded so perform interrupt
		 * acknowledge on controller 2
a895 10
		outb(IO_ICU2, 0x0C);
		irq = (inb(IO_ICU2) & 7) + 8;
	} else if (irq==7) {
		/*
		 * This may be a spurious interrupt
		 *
		 * Read the interrupt status register. If the most
		 * significant bit is not set then there is no valid
* interrupt
*/
d897 1
a897 1
		if (~inb(IO_ICU1)&0x80)
d914 1
a914 1
	pcpl = splhigh();			/* Turn off all */
d921 2
a922 2
	while (realirq != 0xFF) {
		if (realirq == 0x00) {
d927 1
a927 1
			openpic_eoi(0);
d931 1
a931 1

d940 1
a940 1
			ipending |= r_imen;		/* Masked! Mark this as pending */
d943 1
a943 1
			else
d960 1
a960 1
	splx(pcpl);		 /* Process pendings. */
d965 1
a965 1
	u_int x;
d974 1
a974 1
	u_int x;
d986 3
a988 3
	int irq;
	u_int x;

d990 15
a1004 20
	for (irq = 0; irq < ICU_LEN; irq++) {
		hwirq[irq] = -1;
      intrtype[irq] = IST_NONE;
      intrmask[irq] = 0;
      intrlevel[irq] = 0;
      intrhand[irq] = NULL;
		openpic_write(OPENPIC_SRC_VECTOR(irq), OPENPIC_IMASK);
	}
	
	openpic_set_priority(0, 15);

	/* we don't need 8259 pass through mode */
	x = openpic_read(OPENPIC_CONFIG);
	x |= OPENPIC_CONFIG_8259_PASSTHRU_DISABLE;
	openpic_write(OPENPIC_CONFIG, x);

	/* send all interrupts to cpu 0 */
	for (irq = 0; irq < ICU_LEN; irq++)
		openpic_write(OPENPIC_SRC_DEST(irq), CPU(0));

d1007 1
a1007 1

d1009 2
a1010 5
		openpic_initirq(irq, 8, irq, 0, 1);
	}

	/* XXX set spurious intr vector */
	openpic_write(OPENPIC_SPURIOUS_VECTOR, 0xFF);   
d1012 4
a1015 1
	/* unmask interrupts for cpu 0 */
d1018 5
a1022 5
	/* clear all pending interrunts */
	for (irq = 0; irq < PIC_OFFSET; irq++) {
		openpic_read_irq(0);
		openpic_eoi(0);
	}
d1024 1
a1024 1
	for (irq = 0; irq < PIC_OFFSET; irq++) {
d1026 1
a1026 1
		openpic_disable_irq(irq);
d1028 1
a1028 1

@


1.2.2.2
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d53 1
d94 1
d142 5
a146 5
	{ 10, 2 },
	{ 11, 4 },
	{ 14, 3 },
	{ 15, 5 },
	{ 0, 0 }
d157 2
d196 2
d851 1
a851 1
			elcr2_val |= (1 << (irq - 8));
d853 1
a853 1
			elcr2_val &= ~(1 << (irq - 8));
@


1.2.2.3
log
@Merge in -current from about a week ago
@
text
@d88 1
a88 1
static int fakeintr(void *);
d100 4
a103 4
static   __inline u_int openpic_read(int);
static   __inline void openpic_write(int, u_int);
void  openpic_enable_irq(int, int);
void  openpic_disable_irq(int);
d105 9
a113 9
void  openpic_set_priority(int, int);
void  openpic_set_vec_pri(int, int);
static   __inline int openpic_read_irq(int);
static   __inline void openpic_eoi(int);

void  i8259_init(void);
int   i8259_intr(void);
void  i8259_enable_irq(int, int);
void  i8259_disable_irq(int);
d115 1
a115 1
									  int (*ih_fun)(void *), void *ih_arg, char *name);
d121 2
a122 2
int   openpic_match(struct device *parent, void *cf, void *aux);
void  openpic_attach(struct device *, struct device *, void *);
d177 3
a179 3
typedef void     *(intr_establish_t)(void *, mac_intr_handle_t,
														int, int, int (*func)(void *), void *, char *);
typedef void     (intr_disestablish_t)(void *, void *);
d183 1
a183 1
										 int (*ih_fun)(void *), void *ih_arg, char *name);
d282 1
a282 1
int (*ih_fun)(void *);
d368 1
a368 1
int (*ih_fun)(void *);
@


1.2.2.4
log
@Sync the SMP branch with 3.3
@
text
@d90 1
a90 1
static void intr_calculatemasks(void);
d104 1
a104 1
void  openpic_init(void);
a108 1
void openpic_initirq(int, int, int, int, int);
d114 2
a115 3
void  *i8259_intr_establish(void *, int, int, int, int (*)(void *), void *,
    char *);
void  i8259_set_irq_mask(void);
d123 2
a124 2
void  openpic_do_pending_int(void);
void  ext_intr_openpic(void);
d177 3
a179 3
typedef void  *(intr_establish_t)(void *, mac_intr_handle_t,
    int, int, int (*)(void *), void *, char *);
typedef void (intr_disestablish_t)(void *, void *);
d182 4
a185 4
void * openpic_intr_establish(void *, int, int, int, int (*)(void *), void *,
    char *);
void openpic_intr_disestablish(void *, void *);
void openpic_collect_preconf_intr(void);
@


1.2.2.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.2.2.4 2003/03/27 23:52:16 niklas Exp $	*/
d20 5
a24 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.2.2.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d39 4
d49 1
a49 4

#include <uvm/uvm_extern.h>

#include <ddb/db_var.h>
a54 1

d59 6
a64 6
#define ICU_LEN		32
#define LEGAL_IRQ(x)	((x >= 0) && (x < ICU_LEN))
#define IO_ICU1		(isaspace_va + 0x20)
#define IO_ICU2		(isaspace_va + 0xa0)
#define IO_ELCR1	(isaspace_va + 0x4d0)
#define IO_ELCR2	(isaspace_va + 0x4d1)
d74 7
a80 5
int intrtype[ICU_LEN], intrmask[ICU_LEN], intrlevel[ICU_LEN];
struct intrhand *intrhand[ICU_LEN];
int hwirq[ICU_LEN], virq[ICU_LEN];
unsigned int imen = 0xffffffff;
int virq_max;
d84 3
a86 3
int fakeintr(void *);
const char *intr_typename(int type);
void intr_calculatemasks(void);
d88 1
a88 1
int mapirq(int irq);
d91 2
d96 16
a111 16
static __inline u_int openpic_read(int);
static __inline void openpic_write(int, u_int);
void openpic_enable_irq(int, int);
void openpic_disable_irq(int);
void openpic_init(void);
void openpic_set_priority(int, int);
static __inline int openpic_read_irq(int);
static __inline void openpic_eoi(int);
void openpic_initirq(int, int, int);

void i8259_init(void);
int i8259_intr(void);
void i8259_enable_irq(int, int);
void i8259_disable_irq(int);
static __inline void i8259_eoi(int);
void *i8259_intr_establish(void *, int, int, int, int (*)(void *), void *,
d113 1
a113 1
void i8259_set_irq_mask(void);
d119 9
a127 7
int openpic_match(struct device *parent, void *cf, void *aux);
void openpic_attach(struct device *, struct device *, void *);
void openpic_do_pending_int(void);
void ext_intr_openpic(void);

struct cfattach openpic_ca = {
	sizeof(struct openpic_softc), openpic_match, openpic_attach
d134 1
a134 1
const struct pci_route {
d145 2
d148 4
a151 4
openpic_match(parent, cf, aux)
	struct device *parent;
	void *cf;
	void *aux;
d156 7
d168 1
a168 1
typedef void (void_f) (void);
d170 2
a171 2
int abort_switch (void *arg);
int i8259_dummy(void *arg);
d175 2
a176 2
typedef void *(intr_establish_t)(void *, int, int, int, int (*)(void *),
    void *, char *);
d179 1
a179 3
vaddr_t openpic_base;
extern vaddr_t isaspace_va;

d187 2
a188 2
	struct device *parent, *self;
	void *aux;
d192 5
a196 7

	if ((openpic_base = (vaddr_t)mapiodev(MPCIC_BASE, MPCIC_SIZE)) == NULL) {
		printf(": can't map MPCIC!\n");
		return;
	}

	/* the ICU area in isa space already mapped */
d204 7
a210 2
	intr_establish_func = i8259_intr_establish;
	intr_disestablish_func = openpic_intr_disestablish;
d212 1
d214 2
d217 1
a217 3
	/*
	 * i8259 interrupts are chained to openpic interrupt #0
	 */
d219 1
a219 2
	    i8259_dummy, NULL, "8259 Interrupt");

d221 3
a223 2
	    abort_switch, NULL, "abort button");

a230 1

d234 3
a236 3
		    ppc_configed_intr[i].ih_what, ppc_configed_intr[i].ih_irq,
		    ppc_configed_intr[i].ih_level, ppc_configed_intr[i].ih_fun,
		    ppc_configed_intr[i].ih_arg);
d239 3
a241 3
		    IST_LEVEL, ppc_configed_intr[i].ih_level,
		    ppc_configed_intr[i].ih_fun, ppc_configed_intr[i].ih_arg,
		    ppc_configed_intr[i].ih_what);
d245 2
a246 2
int
abort_switch(void *arg)
d249 2
a250 2
	if (db_console)
		Debugger();
d257 2
a258 2
int
i8259_dummy(void *arg)
a259 1
	/* All the 8259 handling happens in ext_intr_openpic(), actually. */
d263 1
a263 1
int
d265 1
a265 1
	void *arg;
d267 1
d272 1
a272 1
 * Register an ISA interrupt handler.
d275 8
a282 8
i8259_intr_establish(lcv, irq, type, level, ih_fun, ih_arg, what)
	void * lcv;
	int irq;
	int type;
	int level;
	int (*ih_fun)(void *);
	void *ih_arg;
	char *what;
d286 1
d289 1
a289 1
	fakehand.ih_fun = fakeintr;
d294 1
d296 3
d309 3
d319 2
a320 2
			    intr_typename(intrtype[irq]),
			    intr_typename(type));
d334 1
a334 1
	 * this with interrupts enabled and don't want the real routine called
a350 1
	ih->ih_what = what;
d358 1
a358 1
 * Register a PCI interrupt handler.
d361 8
a368 8
openpic_intr_establish(lcv, irq, type, level, ih_fun, ih_arg, what)
	void * lcv;
	int irq;
	int type;
	int level;
	int (*ih_fun)(void *);
	void *ih_arg;
	char *what;
d372 2
a373 1
	const struct pci_route *pr;
d376 1
a376 1
	fakehand.ih_fun = fakeintr;
d378 9
a386 5
	for (pr = pci_routes; pr->pci != 0; pr++)
		if (pr->pci == irq) {
			irq = pr->openpic;
			break;
		}
d389 3
d402 3
d412 2
a413 2
			    intr_typename(intrtype[irq]),
			    intr_typename(type));
d427 1
a427 1
	 * this with interrupts enabled and don't want the real routine called
a443 1
	ih->ih_what = what;
d454 2
a455 2
	void *lcp;
	void *arg;
d482 2
a483 1
const char *
d485 1
a485 1
	int type;
a496 1
#ifdef DIAGNOSTIC
d499 2
d511 1
a511 1
void
d514 1
a514 1
	int irq, level, levels;
d516 3
a518 2
	int irqs;

d521 1
a521 1
		levels = 0;
d528 2
a529 2
	for (level = IPL_NONE; level < IPL_NUM; level++) {
		irqs = 0;
d539 4
a542 1
	 *
d546 1
a547 3
	imask[IPL_TTY] |= imask[IPL_NET];
	imask[IPL_IMP] |= imask[IPL_TTY];
	imask[IPL_CLOCK] |= imask[IPL_IMP] | SPL_CLOCK;
d557 1
a557 1
		irqs = 1 << irq;
d564 15
a578 14
	irqs = 0;
	for (irq = 0; irq < ICU_LEN; irq++) {
		if (intrhand[irq]) {
			irqs |= 1 << irq;

			if (hwirq[irq] >= PIC_OFFSET)
				openpic_enable_irq(hwirq[irq], intrtype[irq]);
			else
				i8259_enable_irq(hwirq[irq], intrtype[irq]);
		} else {
			if (hwirq[irq] >= PIC_OFFSET)
				openpic_disable_irq(hwirq[irq]);
			else
				i8259_disable_irq(hwirq[irq]);
a579 1
		imen = ~irqs;
d581 3
a583 4

	/* always enable the chained 8259 interrupt */
	i8259_enable_irq(IRQ_SLAVE, IST_EDGE);
	i8259_set_irq_mask();
a584 1

d588 1
a588 1
int
d590 1
a590 1
	int irq;
a593 1
#ifdef DIAGNOSTIC
a595 2
#endif

d615 1
a615 1
	int x;
d620 1
d624 1
d632 1
a632 1
	int s;
d638 3
a640 1
	s = ppc_intr_disable();
d642 4
a646 1
	pcpl = splhigh();		/* Turn off all */
d650 1
d664 2
d678 1
a678 7
#if 0
		if ((ipending & SINT_TTY) & ~pcpl) {
			ipending &= ~SINT_TTY;
			softtty();
		}
#endif
	} while (ipending & (SINT_NET|SINT_CLOCK/*|SINT_TTY*/) & ~cpl);
d681 1
a681 5

#if 0
	i8259_set_irq_mask();
#endif

a682 1
	ppc_intr_enable(s);
d687 1
a687 1
	int reg;
d690 1
a690 1

d696 2
a697 2
	int reg;
	u_int val;
d706 1
a706 1
	int irq_mask;
d709 4
a712 2

	for (irq = 0; irq <= virq_max; irq++)
d724 1
a724 2

	i8259_set_irq_mask();
d729 2
a730 2
	int irq;
	int type;
a732 1

d734 1
a734 1
	if (irq < 0)
d738 3
d742 1
a742 1
	while ((x = openpic_read(OPENPIC_SRC_VECTOR(irq))) & OPENPIC_ACTIVITY) {
d745 3
d749 1
a749 1

d756 2
a757 2
#endif
	if (type == IST_LEVEL)
d759 1
a759 1
	else
d761 5
d771 1
a771 1
	int irq;
a773 1

d780 4
d787 1
a787 1
void
d790 1
a790 1
	if (icu2_val != 0xff) {
d792 4
a795 1
		icu1_val &= ~(1 << IRQ_SLAVE);
d797 1
a797 1
		icu1_val |= (1 << IRQ_SLAVE);
d804 4
d812 1
a812 1
	int irq;
d814 1
a814 3
#ifdef DIAGNOSTIC
	/* skip invalid irqs */
	if (irq < 0 || irq > 15)
d816 1
a816 3
#endif

	if (irq < 8) {
d818 6
a823 6
		elcr1_val &= ~(1 << irq);
	} else {
		irq -= 8;
		icu2_val |= 1 << irq;
		elcr2_val &= ~(1 << irq);
	}
d826 1
a826 1
void
d828 1
a828 1
	int irq, type;
a829 1
#ifdef DIAGNOSTIC
d831 1
a831 1
	if (irq < 0 || irq > 15)
d833 1
a833 3
#endif

	if (irq < 8) {
d835 1
a835 1
		if (type == IST_LEVEL)
d837 1
a837 1
		else
d839 1
d841 6
a846 6
		irq -= 8;
		icu2_val &= ~(1 << irq);
		if (type == IST_LEVEL)
			elcr2_val |= (1 << irq);
		else
			elcr2_val &= ~(1 << irq);
d848 4
a851 1
}
a852 14
static __inline void
i8259_eoi(int irq)
{
#ifdef DIAGNOSTIC
	/* skip invalid irqs */
	if (irq < 0 || irq > 15)
		return;
#endif
	if (irq < 8)
		outb(IO_ICU1, 0x60 | irq);
	else {
		outb(IO_ICU2, 0x60 | (irq - 8));
		outb(IO_ICU1, 0x60 | IRQ_SLAVE);
	}
d857 1
a857 1
	int cpu, pri;
d869 1
a869 1
	int cpu;
d876 1
a876 1
	int cpu;
d882 1
a882 2
void
i8259_init(void)
d884 1
d897 1
d900 1
a900 2
int
i8259_intr(void)
d907 1
a907 1
	outb(IO_ICU1, 0x0c);
d909 4
a912 2

	if (irq == IRQ_SLAVE) {
d917 1
a917 1
		outb(IO_ICU2, 0x0c);
d919 1
a919 1
	} else if (irq == 7) {
d925 5
a929 6
		 * interrupt
		 */
		outb(IO_ICU1, 0x0b);
		if ((inb(IO_ICU1) & 0x80) == 0) {
			return 0xff;
		}
d939 1
a939 1
	int pcpl, ocpl;
d942 4
a945 1
	pcpl = cpl;
d948 3
d952 1
a952 1
	while (realirq != 0xff) {
d955 3
d959 1
a959 1
			if (realirq == 0xff)
a960 2
		} else {
			realirq += PIC_OFFSET;
d972 3
a974 1
			if (realirq >= PIC_OFFSET) {
a975 6
				openpic_eoi(0);
			} else {
				i8259_disable_irq(realirq);
				i8259_set_irq_mask();
				i8259_eoi(realirq);
			}
a976 11
			if (realirq >= PIC_OFFSET) {
				openpic_disable_irq(realirq);
				openpic_eoi(0);
			} else {
				i8259_disable_irq(realirq);
				i8259_set_irq_mask();
				i8259_eoi(realirq);
			}

			ocpl = splraise(intrmask[irq]);

a978 4
#if 0
				ppc_intr_enable(1);
#endif

a979 4

#if 0
				ppc_intr_disable();
#endif
a981 1

a982 4
			__asm__ volatile("":::"memory");
			cpl = ocpl;
			__asm__ volatile("":::"memory");
#if 0
a983 7
#endif
			if (realirq >= PIC_OFFSET)
				openpic_enable_irq(realirq, intrtype[irq]);
			else {
				i8259_enable_irq(realirq, intrtype[irq]);
				i8259_set_irq_mask();
			}
d986 2
d991 2
a992 1
	ppc_intr_enable(1);
d994 7
a1000 1
	splx(pcpl);	 /* Process pendings. */
d1003 1
a1003 2
void
openpic_initirq(int irq, int pol, int sense)
d1006 1
a1006 2

	x = (irq & OPENPIC_VECTOR_MASK);
d1010 1
a1010 1
	x |= 8 << OPENPIC_PRIORITY_SHIFT;
d1023 4
a1026 4
		intrtype[irq] = IST_NONE;
		intrmask[irq] = 0;
		intrlevel[irq] = 0;
		intrhand[irq] = NULL;
d1029 1
d1042 2
a1043 1
	openpic_initirq(0, 1, 0);
d1045 1
a1045 1
		openpic_initirq(irq, 0, 1);
d1049 1
a1049 3
#if 0
	openpic_write(OPENPIC_SPURIOUS_VECTOR, 0xFF);
#endif
d1054 1
a1054 1
	/* clear all pending interrunts */	/* < ICU_LEN ? */
d1060 1
a1060 1
	for (irq = 0; irq < PIC_OFFSET; irq++) {	/* < ICU_LEN ? */
a1063 2

	i8259_set_irq_mask();
@


1.2.2.7
log
@Merge with the trunk
@
text
@a68 2
#define	PIC_SPURIOUS	0xff

d98 1
a98 1
static __inline int openpic_iack(int);
a127 4
/*
 * ISA IRQ for PCI IRQ to MPIC IRQ routing.
 * From MVME2600APG tables 5.2 and 5.3
 */
d133 1
a133 1
	{ 11, 5 },
d135 1
a135 1
	{ 15, 4 },
d479 1
a479 1
	int irq, hirq, level, levels;
a528 4
		hirq = hwirq[irq];
		if (hirq < 0)
			continue;

d532 2
a533 2
			if (hirq >= PIC_OFFSET)
				openpic_enable_irq(hirq, intrtype[irq]);
d535 1
a535 1
				i8259_enable_irq(hirq, intrtype[irq]);
d537 2
a538 2
			if (hirq >= PIC_OFFSET)
				openpic_disable_irq(hirq);
d540 1
a540 1
				i8259_disable_irq(hirq);
d542 1
a546 2

	imen = ~irqs;
d571 2
a572 2
#ifdef DEBUG
	printf("mapirq %x to %x\n", irq, v);
d604 1
d606 1
a607 2
	s = ppc_intr_disable();

d650 1
a651 1
	processing = 0;
d677 1
a677 6
	int irq, hirq;

	for (irq = 0; irq <= virq_max; irq++) {
		hirq = hwirq[irq];
		if (hirq < 0)
			continue;
d679 1
d681 2
a682 2
			if (hirq >= PIC_OFFSET)
				openpic_enable_irq(hirq, intrtype[irq]);
d684 1
a684 1
				i8259_enable_irq(hirq, intrtype[irq]);
d686 2
a687 2
			if (hirq >= PIC_OFFSET)
				openpic_disable_irq(hirq);
d689 1
a689 1
				i8259_disable_irq(hirq);
a690 1
	}
a701 1
#ifdef DIAGNOSTIC
d703 4
a706 4
	if (irq < PIC_OFFSET)
		panic("openpic_enable_irq: invalid irq %x", irq);
#endif
	irq -= PIC_OFFSET;
d709 1
a709 1
		x = openpic_iack(0);
d764 2
a765 2
	if (irq < 0 || irq >= PIC_OFFSET)
		panic("i8259_disable_irq: invalid irq %x", irq);
d784 2
a785 2
	if (irq < 0 || irq >= PIC_OFFSET)
		panic("i8259_enable_irq: invalid irq %x", irq);
d809 2
a810 2
	if (irq < 0 || irq >= PIC_OFFSET)
		panic("i8259_eoi: invalid irq %x", irq);
a811 1

d833 1
a833 1
openpic_iack(cpu)
d892 1
a892 4
#ifdef DIAGNOSTIC
			printf("spurious interrupt on ICU1\n");
#endif
			return PIC_SPURIOUS;
a894 1

d908 1
a908 1
	realirq = openpic_iack(0);
d910 1
a910 1
	while (realirq != PIC_SPURIOUS) {
a911 5
			/*
			 * Interrupt from the PCI/ISA bridge. PCI interrupts
			 * are shadowed on the ISA PIC for compatibility with
			 * MVME1600, so simply handle the ISA PIC.
			 */
d914 2
a915 2
			if (realirq == PIC_SPURIOUS)
				break;
d940 1
d944 1
d951 4
d956 4
d970 1
a970 2
			if (realirq >= PIC_OFFSET) {
				openpic_eoi(0);
d972 1
a972 2
			} else {
				i8259_eoi(realirq);
d978 1
a978 1
		realirq = openpic_iack(0);
d980 1
d1041 1
a1041 1
		openpic_iack(0);
@


1.1
log
@Initial import of mvmeppc.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a52 1
#ifdef UVM
a55 1
#endif
a950 1
#ifdef UVM
a951 2
#else
#endif
@

