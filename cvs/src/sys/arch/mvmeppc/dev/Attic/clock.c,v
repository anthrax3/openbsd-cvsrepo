head	1.11;
access;
symbols
	OPENBSD_4_9:1.10.0.26
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.10.0.24
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.20
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.10.0.22
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.18
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.16
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.14
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.12
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.10
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.8
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.10.0.6
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.4
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.2
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.9.0.2
	OPENBSD_3_6_BASE:1.9
	SMP_SYNC_A:1.9
	SMP_SYNC_B:1.9
	OPENBSD_3_5:1.8.0.2
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.5.0.6
	OPENBSD_3_4_BASE:1.5
	UBC_SYNC_A:1.5
	OPENBSD_3_3:1.5.0.4
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4
	UBC_SYNC_B:1.5
	UBC:1.3.0.2
	UBC_BASE:1.3
	OPENBSD_3_0:1.2.0.2
	OPENBSD_3_0_BASE:1.2
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.11
date	2011.07.07.19.16.42;	author deraadt;	state dead;
branches;
next	1.10;

1.10
date	2004.12.24.22.50.30;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2004.05.14.20.38.32;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2004.01.28.23.50.16;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2004.01.26.22.55.52;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2003.11.25.21.16.44;	author drahn;	state Exp;
branches;
next	1.5;

1.5
date	2002.06.08.15.49.52;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2002.03.14.01.26.41;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.11.06.22.45.54;	author miod;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2001.07.06.05.14.29;	author smurph;	state Exp;
branches;
next	1.1;

1.1
date	2001.06.26.21.57.40;	author smurph;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2001.10.31.03.01.20;	author nate;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2001.11.13.21.04.15;	author niklas;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2002.03.28.10.36.03;	author niklas;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2003.03.27.23.52.16;	author niklas;	state Exp;
branches;
next	1.1.2.5;

1.1.2.5
date	2004.02.19.10.49.09;	author niklas;	state Exp;
branches;
next	1.1.2.6;

1.1.2.6
date	2004.06.05.23.10.54;	author niklas;	state Exp;
branches;
next	;

1.3.2.1
date	2002.06.11.03.37.22;	author art;	state Exp;
branches;
next	;


desc
@@


1.11
log
@remove mvmeppc; it is really rough shape.  ok drahn miod
@
text
@/*	$OpenBSD: clock.c,v 1.10 2004/12/24 22:50:30 miod Exp $	*/
/*	$NetBSD: clock.c,v 1.1 1996/09/30 16:34:40 ws Exp $	*/

/*
 * Copyright (C) 1995, 1996 Wolfgang Solfrank.
 * Copyright (C) 1995, 1996 TooLs GmbH.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by TooLs GmbH.
 * 4. The name of TooLs GmbH may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY TOOLS GMBH ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL TOOLS GMBH BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/kernel.h>
#include <sys/systm.h>

#include <machine/pio.h>
#include <machine/intr.h>
#include <machine/powerpc.h>

#include "bugtty.h"

void resettodr(void);
void decr_intr(struct clockframe *);
void calc_delayconst(void);

/*
 * Initially we assume a processor with a bus frequency of 12.5 MHz.
 */
static u_long ticks_per_sec = 3125000;
static u_long ns_per_tick = 320;
static long ticks_per_intr;
static volatile u_long lasttb;

/*
 * BCD to decimal and decimal to BCD.
 */
#define FROMBCD(x)      (((x) >> 4) * 10 + ((x) & 0xf))
#define TOBCD(x)        (((x) / 10 * 16) + ((x) % 10))

#define SECDAY          (24 * 60 * 60)
#define SECYR           (SECDAY * 365)
#define LEAPYEAR(y)     (((y) & 3) == 0)
#define YEAR0		1900

tps_t *tps;
clock_read_t *clock_read;
clock_write_t *clock_write;
time_read_t  *time_read;
time_write_t *time_write;

static u_int32_t chiptotime(int, int, int, int, int, int);

/* event tracking variables, when the next event of each time should occur */
u_int64_t nexttimerevent, prevtb, nextstatevent;

/* vars for stats */
int statint;
u_int32_t statvar;
u_int32_t statmin;

struct chiptime {
	int     sec;
	int     min;
	int     hour;
	int     wday;
	int     day;
	int     mon;
	int     year;
};

static void timetochip(struct chiptime *c);

/*
 * For now we let the machine run with boot time, not changing the clock
 * at inittodr at all.
 *
 * We might continue to do this due to setting up the real wall clock with
 * a user level utility in the future.
 */

/* ARGSUSED */
void
inittodr(time_t base)
{
	int sec, min, hour, day, mon, year;

	int badbase = 0, waszero = base == 0;

	if (base < 5 * SECYR) {
		/*
		 * If base is 0, assume filesystem time is just unknown
		 * instead of preposterous. Don't bark.
		 */
		if (base != 0)
			printf("WARNING: preposterous time in file system\n");
		/* not going to use it anyway, if the chip is readable */
		base = 21*SECYR + 186*SECDAY + SECDAY/2;
		badbase = 1;
	}

	if (clock_read != NULL ) {
		(*clock_read)( &sec, &min, &hour, &day, &mon, &year);
		time.tv_sec = chiptotime(sec, min, hour, day, mon, year);
	} else if (time_read != NULL) {
		u_int32_t cursec;
		(*time_read)(&cursec);
		time.tv_sec = cursec;
	} else {
		/* force failure */
		time.tv_sec = 0;
	} 

	if (time.tv_sec == 0) {
		printf("WARNING: unable to get date/time");
		/*
		 * Believe the time in the file system for lack of
		 * anything better, resetting the clock.
		 */
		time.tv_sec = base;
		if (!badbase)
			resettodr();
	} else {
		int deltat;

		time.tv_sec += tz.tz_minuteswest * 60;
		if (tz.tz_dsttime)
			time.tv_sec -= 3600;

		deltat = time.tv_sec - base;

		if (deltat < 0)
			deltat = -deltat;
		if (waszero || deltat < 2 * SECDAY)
			return;
		printf("WARNING: clock %s %d days",
		    time.tv_sec < base ? "lost" : "gained", deltat / SECDAY);

		if (time.tv_sec < base && deltat > 1000 * SECDAY) {
			printf(", using FS time");
			time.tv_sec = base;
		}
	}
	printf(" -- CHECK AND RESET THE DATE!\n");
}

/*
 * This code is defunct after 2068.
 * Will Unix still be here then??
 */
const short dayyr[12] =
    { 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334};

static u_int32_t
chiptotime(int sec, int min, int hour, int day, int mon, int year)
{
	int days, yr;

	sec = FROMBCD(sec);
	min = FROMBCD(min);
	hour = FROMBCD(hour);
	day = FROMBCD(day);
	mon = FROMBCD(mon);
	year = FROMBCD(year) + YEAR0;

	/* simple sanity checks */
	if (year < 1970 || mon < 1 || mon > 12 || day < 1 || day > 31)
		return (0);
	days = 0;
	for (yr = 1970; yr < year; yr++)
		days += LEAPYEAR(yr) ? 366 : 365;
	days += dayyr[mon - 1] + day - 1;
	if (LEAPYEAR(yr) && mon > 2)
		days++;
	/* now have days since Jan 1, 1970; the rest is easy... */
	return (days * SECDAY + hour * 3600 + min * 60 + sec);
}

void
timetochip(struct chiptime *c)
{
	int t, t2, t3, now = time.tv_sec;

	/* January 1 1970 was a Thursday (4 in unix wdays) */
	/* compute the days since the epoch */
	t2 = now / SECDAY;

	t3 = (t2 + 4) % 7;	/* day of week */
	c->wday = TOBCD(t3 + 1);

	/* compute the year */
	t = 69;
	while (t2 >= 0) {	/* whittle off years */
		t3 = t2;
		t++;
		t2 -= LEAPYEAR(t) ? 366 : 365;
	}
	c->year = t;

	/* t3 = month + day; separate */
	t = LEAPYEAR(t);
	for (t2 = 1; t2 < 12; t2++)
		if (t3 < (dayyr[t2] + ((t && (t2 > 1)) ? 1:0)))
			break;

	/* t2 is month */
	c->mon = t2;
	c->day = t3 - dayyr[t2 - 1] + 1;
	if (t && t2 > 2)
		c->day--;

	/* the rest is easy */
	t = now % SECDAY;
	c->hour = t / 3600;
	t %= 3600;
	c->min = t / 60;
	c->sec = t % 60;

	c->sec = TOBCD(c->sec);
	c->min = TOBCD(c->min);
	c->hour = TOBCD(c->hour);
	c->day = TOBCD(c->day);
	c->mon = TOBCD(c->mon);
	c->year = TOBCD((c->year - YEAR0) % 100);
}


/*
 * Similar to the above
 */
void
resettodr()
{
	struct timeval curtime = time;
	if (clock_write != NULL) {
		struct chiptime c;
		timetochip(&c);
		(*clock_write)(c.sec, c.min, c.hour, c.day, c.mon, c.year);
	} else if (time_write != NULL) {
		curtime.tv_sec -= tz.tz_minuteswest * 60;
		if (tz.tz_dsttime) {
			curtime.tv_sec += 3600;
		}
		(*time_write)(curtime.tv_sec);
	}
}

volatile int statspending;

void
decr_intr(struct clockframe *frame)
{
	u_int64_t tb;
	u_int64_t nextevent;
	int nstats;
	int s;

	/*
	 * Check whether we are initialized.
	 */
	if (!ticks_per_intr)
		return;

	/*
	 * Based on the actual time delay since the last decrementer reload,
	 * we arrange for earlier interrupt next time.
	 */

	tb = ppc_mftb();
	while (nexttimerevent <= tb)
		nexttimerevent += ticks_per_intr;

	prevtb = nexttimerevent - ticks_per_intr;

	for (nstats = 0; nextstatevent <= tb; nstats++) {
		int r;
		do {
			r = random() & (statvar - 1);
		} while (r == 0); /* random == 0 not allowed */
		nextstatevent += statmin + r;
	}

	if (nexttimerevent < nextstatevent)
		nextevent = nexttimerevent;
	else
		nextevent = nextstatevent;

	/*
	 * Need to work about the near constant skew this introduces???
	 * reloading tb here could cause a missed tick.
	 */
	ppc_mtdec(nextevent - tb);

	if (cpl & SPL_CLOCK) {
		statspending += nstats;
	} else {
		nstats += statspending;
		statspending = 0;

		s = splclock();

		/*
		 * Reenable interrupts
		 */
		ppc_intr_enable(1);

		/*
		 * Do standard timer interrupt stuff.
		 * Do softclock stuff only on the last iteration.
		 */
		frame->pri = s | SINT_CLOCK;
		while (lasttb < prevtb - ticks_per_intr) {
			/* sync lasttb with hardclock */
			lasttb += ticks_per_intr;
			hardclock(frame);
		}

		frame->pri = s;
		while (lasttb < prevtb) {
			/* sync lasttb with hardclock */
			lasttb += ticks_per_intr;
			hardclock(frame);
#if NBUGTTY > 0
			{
				extern void bugtty_chkinput(void);
				bugtty_chkinput();
			}
#endif
		}

		while (nstats-- > 0)
			statclock(frame);

		splx(s);
		ppc_intr_disable();

		/*
		 * If a tick has occurred while dealing with these,
		 * don't service it now, delay until the next tick.
		 */
	}
}

void
cpu_initclocks()
{
	int intrstate;
	int r;
	int minint;
	u_int64_t nextevent;

	intrstate = ppc_intr_disable();

	stathz = 100;
	profhz = 1000; /* must be a multiple of stathz */

	/* init secondary clock to stathz */
	statint = ticks_per_sec / stathz;
	statvar = 0x40000000; /* really big power of two */
	/* find largest 2^n which is nearly smaller than statint/2 */
	minint = statint / 2 + 100;
	while (statvar > minint)
		statvar >>= 1;

	statmin = statint - (statvar >> 1);

	lasttb = ppc_mftb();
	nexttimerevent = lasttb + ticks_per_intr;
	do {
		r = random() & (statvar - 1);
	} while (r == 0); /* random == 0 not allowed */
	nextstatevent = lasttb + statmin + r;

	if (nexttimerevent < nextstatevent)
		nextevent = nexttimerevent;
	else
		nextevent = nextstatevent;

	ppc_mtdec(nextevent - lasttb);
	ppc_intr_enable(intrstate);
}

void
calc_delayconst(void)
{
	int s;

	ticks_per_sec = (*tps)();
	s = ppc_intr_disable();
	ns_per_tick = 1000000000 / ticks_per_sec;
	ticks_per_intr = ticks_per_sec / hz;
	ppc_intr_enable(s);
}

/*
 * Fill in *tvp with current time with microsecond resolution.
 */
void
microtime(struct timeval *tvp)
{
	u_int64_t tb;
	u_int32_t ticks;
	int s;

	s = ppc_intr_disable();
	tb = ppc_mftb();
	ticks = ((tb - lasttb) * ns_per_tick) / 1000;
	*tvp = time;
	ppc_intr_enable(s);
	tvp->tv_usec += ticks;
	while (tvp->tv_usec >= 1000000) {
		tvp->tv_usec -= 1000000;
		tvp->tv_sec++;
	}
}

/*
 * Wait for about n microseconds (us) (at least!).
 */
void
delay(unsigned n)
{
	u_int64_t tb;
	u_int32_t tbh, tbl, scratch;

	tb = ppc_mftb();
	tb += (n * 1000 + ns_per_tick - 1) / ns_per_tick;
	tbh = tb >> 32;
	tbl = (u_int32_t)tb;
	asm ("1: mftbu %0; cmplw %0,%1; blt 1b; bgt 2f;"
	     " mftb %0; cmplw %0,%2; blt 1b; 2:"
	     :: "r"(scratch), "r"(tbh), "r"(tbl));
}

void
setstatclockrate(int newhz)
{
	int minint;
	int intrstate;

	intrstate = ppc_intr_disable();

	statint = ticks_per_sec / newhz;
	statvar = 0x40000000; /* really big power of two */
	/* find largest 2^n which is nearly smaller than statint/2 */
	minint = statint / 2 + 100;
	while (statvar > minint)
		statvar >>= 1;

	statmin = statint - (statvar >> 1);
	ppc_intr_enable(intrstate);

	/*
	 * XXX this allows the next stat timer to occur then it switches
	 * to the new frequency. Rather than switching instantly.
	 */
}
@


1.10
log
@{e,}intr{cnt,names} bye-bye.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.9 2004/05/14 20:38:32 miod Exp $	*/
@


1.9
log
@Attach a working bugtty device - userland needs at least a console tty.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.8 2004/01/28 23:50:16 miod Exp $	*/
a304 3
	/* only count timer ticks for CLK_IRQ */
	intrcnt[PPC_STAT_IRQ] += nstats;

a336 1
			intrcnt[PPC_CLK_IRQ]++;
a343 1
			intrcnt[PPC_CLK_IRQ]++;
@


1.8
log
@More clock handling cleanup:
- move clock callbacks outside the firmware structure
- map the clock virtual. A bit tricky because it needs to be mapped before
  autoconf...
- compensate for the removal of 1:1 segment 8 mapping
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.7 2004/01/26 22:55:52 miod Exp $	*/
d43 2
d350 6
@


1.7
log
@Mostly sync with other ppc-based ports. This should be factorized someday...
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.6 2003/11/25 21:16:44 drahn Exp $	*/
d66 6
d122 2
a123 2
	if (fw->clock_read != NULL ) {
		(fw->clock_read)( &sec, &min, &hour, &day, &mon, &year);
d125 3
a127 3
	} else if (fw->time_read != NULL) {
		u_long cursec;
		(fw->time_read)(&cursec);
d255 1
a255 1
	if (fw->clock_write != NULL) {
d258 2
a259 2
		(fw->clock_write)(c.sec, c.min, c.hour, c.day, c.mon, c.year);
	} else if (fw->time_write != NULL) {
d264 1
a264 1
		(fw->time_write)(curtime.tv_sec);
d407 1
a407 1
	ticks_per_sec = ppc_tps();
@


1.6
log
@Allow mvmeppc to compile again. not a supported arch.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.5 2002/06/08 15:49:52 miod Exp $	*/
d52 1
a52 1
static long ticks_per_intr = 0;
d66 9
a74 2
static u_long
chiptotime(int sec, int min, int hour, int day, int mon, int year);
d98 1
a98 2
inittodr(base)
time_t base;
d127 1
d151 6
a156 1
				 time.tv_sec < base ? "lost" : "gained", deltat / SECDAY);
d166 1
a166 1
{ 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334};
d168 2
a169 3
static u_long
chiptotime(sec, min, hour, day, mon, year)
int sec, min, hour, day, mon, year;
d194 1
a194 2
timetochip(c)
	register struct chiptime *c;
d196 1
a196 1
	register int t, t2, t3, now = time.tv_sec;
d262 2
a263 4
volatile int tickspending;
#if 0
static unsigned cnt = 1001;
#endif
d265 1
a265 2
decr_intr(frame)
	struct clockframe *frame;
d267 4
a270 5
	int msr;
	u_long tb;
	long tick;
	int nticks;
	int pri;
d277 1
a277 9
#if 0
	cnt++;
	if (cnt > 1000) {
		printf("decr int\n");
		cnt = 0;
	}
#endif 
	intrcnt[PPC_CLK_IRQ]++;
	
d282 23
a304 4
	asm ("mftb %0; mfdec %1" : "=r"(tb), "=r"(tick));
	for (nticks = 0; tick < 0; nticks++)
		tick += ticks_per_intr;
	asm volatile ("mtdec %0" :: "r"(tick));
d306 2
a307 2
	 * lasttb is used during microtime. Set it to the virtual
	 * start of this tick interval.
d309 7
a315 1
	lasttb = tb + tick - ticks_per_intr;
d317 1
a317 1
	pri = splclock();
a318 5
	if (pri & SPL_CLOCK) {
		tickspending += nticks;
	} else {
		nticks += tickspending;
		tickspending = 0;
d322 1
a322 2
		asm volatile ("mfmsr %0; ori %0, %0, %1; mtmsr %0"
						  : "=r"(msr) : "K"(PSL_EE));
d328 5
a332 2
		frame->pri = pri | SINT_CLOCK;
		while (--nticks > 0)
d334 20
a353 2
		frame->pri = pri;
		hardclock(frame);
a354 6
	splx(pri);
#if 0
	if (cnt == 0) 
		printf("derc int done.\n");
#endif 

d360 34
a393 6
	int msr, scratch;
	asm volatile ("mfmsr %0; andi. %1, %0, %2; mtmsr %1"
					  : "=r"(msr), "=r"(scratch) : "K"((u_short)~PSL_EE));
	asm volatile ("mftb %0" : "=r"(lasttb));
	asm volatile ("mtdec %0" :: "r"(ticks_per_intr));
	asm volatile ("mtmsr %0" :: "r"(msr));
d397 1
a397 1
calc_delayconst()
d399 1
a399 1
	int msr, scratch;
d402 1
a402 2
	asm volatile ("mfmsr %0; andi. %1, %0, %2; mtmsr %1"
					  : "=r"(msr), "=r"(scratch) : "K"((u_short)~PSL_EE));
d405 1
a405 12
	asm volatile ("mtmsr %0" :: "r"(msr));
}

static inline u_quad_t
mftb(void)
{
	u_long scratch;
	u_quad_t tb;

	asm ("1: mftbu %0; mftb %0+1; mftbu %1; cmpw 0,%0,%1; bne 1b"
		  : "=r"(tb), "=r"(scratch));
	return tb;
d412 1
a412 2
microtime(tvp)
struct timeval *tvp;
d414 7
a420 8
	u_long tb;
	u_long ticks;
	int msr, scratch;

	asm volatile ("mfmsr %0; andi. %1,%0,%2; mtmsr %1"
					  : "=r"(msr), "=r"(scratch) : "K"((u_short)~PSL_EE));
	asm ("mftb %0" : "=r"(tb));
	ticks = (tb - lasttb) * ns_per_tick;
d422 1
a422 2
	asm volatile ("mtmsr %0" :: "r"(msr));
	ticks /= 1000;
d434 1
a434 2
delay(n)
unsigned n;
d436 2
a437 2
	u_quad_t tb;
	u_long tbh, tbl, scratch;
d439 1
a439 1
	tb = mftb();
d442 1
a442 1
	tbl = tb;
d444 2
a445 4
		  " mftb %0; cmplw %0,%2; blt 1b; 2:"
		  :: "r"(scratch), "r"(tbh), "r"(tbl));

	tb = mftb();
a447 3
/*
 * Nothing to do.
 */
d449 1
a449 2
setstatclockrate(arg)
int arg;
d451 19
a469 1
	/* Do nothing */
@


1.5
log
@Strict prototypes, and some KNF touches while there.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.4 2002/03/14 01:26:41 millert Exp $	*/
d252 1
@


1.4
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.3 2001/11/06 22:45:54 miod Exp $	*/
d43 4
a46 1
void resettodr();
d257 1
a257 1
struct clockframe *frame;
d349 1
a349 1
mftb()
@


1.3
log
@-Wall -Werror cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.2 2001/07/06 05:14:29 smurph Exp $	*/
d64 1
a64 1
chiptotime __P((int sec, int min, int hour, int day, int mon, int year));
d76 1
a76 1
static void timetochip __P((struct chiptime *c));
@


1.3.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.3 2001/11/06 22:45:54 miod Exp $	*/
d43 1
a43 4
void resettodr(void);
void decr_intr(struct clockframe *);
void calc_delayconst(void);

d64 1
a64 1
chiptotime(int sec, int min, int hour, int day, int mon, int year);
d76 1
a76 1
static void timetochip(struct chiptime *c);
d254 1
a254 1
	struct clockframe *frame;
d346 1
a346 1
mftb(void)
@


1.2
log
@resolve compile problems
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.1 2001/06/26 21:57:40 smurph Exp $	*/
d37 1
d249 1
d251 1
d270 1
a270 1
		printf("derc int\n");
a334 2
	int qhandle, phandle;
	char name[32];
@


1.1
log
@Initial import of mvmeppc.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.9 2000/09/06 18:15:49 matthieu Exp $	*/
d248 1
d264 7
a270 1

d272 1
a272 1

d311 5
@


1.1.2.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.1 2001/06/26 21:57:40 smurph Exp $	*/
a247 1
static unsigned cnt = 1001;
d263 1
a263 7
#if 0
	cnt++;
	if (cnt > 1000) {
		printf("derc int\n");
		cnt = 0;
	}
#endif 
d265 1
a265 1
	
a303 5
#if 0
	if (cnt == 0) 
		printf("derc int done.\n");
#endif 

@


1.1.2.2
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a36 1
#include <sys/systm.h>
a247 1
#if 0
a248 1
#endif
d267 1
a267 1
		printf("decr int\n");
d332 2
@


1.1.2.3
log
@Merge in -current from about a week ago
@
text
@d64 1
a64 1
chiptotime(int sec, int min, int hour, int day, int mon, int year);
d76 1
a76 1
static void timetochip(struct chiptime *c);
@


1.1.2.4
log
@Sync the SMP branch with 3.3
@
text
@d43 1
a43 4
void resettodr(void);
void decr_intr(struct clockframe *);
void calc_delayconst(void);

d254 1
a254 1
	struct clockframe *frame;
d346 1
a346 1
mftb(void)
@


1.1.2.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d52 1
a52 1
static long ticks_per_intr;
d66 2
a67 15
tps_t *tps;
clock_read_t *clock_read;
clock_write_t *clock_write;
time_read_t  *time_read;
time_write_t *time_write;

static u_int32_t chiptotime(int, int, int, int, int, int);

/* event tracking variables, when the next event of each time should occur */
u_int64_t nexttimerevent, prevtb, nextstatevent;

/* vars for stats */
int statint;
u_int32_t statvar;
u_int32_t statmin;
d91 2
a92 1
inittodr(time_t base)
d110 2
a111 2
	if (clock_read != NULL ) {
		(*clock_read)( &sec, &min, &hour, &day, &mon, &year);
d113 3
a115 3
	} else if (time_read != NULL) {
		u_int32_t cursec;
		(*time_read)(&cursec);
a120 1

d144 1
a144 6
		    time.tv_sec < base ? "lost" : "gained", deltat / SECDAY);

		if (time.tv_sec < base && deltat > 1000 * SECDAY) {
			printf(", using FS time");
			time.tv_sec = base;
		}
d154 1
a154 1
    { 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334};
d156 3
a158 2
static u_int32_t
chiptotime(int sec, int min, int hour, int day, int mon, int year)
d183 2
a184 1
timetochip(struct chiptime *c)
d186 1
a186 1
	int t, t2, t3, now = time.tv_sec;
d239 1
a239 1
	if (clock_write != NULL) {
d242 2
a243 2
		(*clock_write)(c.sec, c.min, c.hour, c.day, c.mon, c.year);
	} else if (time_write != NULL) {
d248 1
a248 1
		(*time_write)(curtime.tv_sec);
d252 3
a254 2
volatile int statspending;

d256 2
a257 1
decr_intr(struct clockframe *frame)
d259 5
a263 4
	u_int64_t tb;
	u_int64_t nextevent;
	int nstats;
	int s;
d270 9
a278 1

d283 4
a286 23

	tb = ppc_mftb();
	while (nexttimerevent <= tb)
		nexttimerevent += ticks_per_intr;

	prevtb = nexttimerevent - ticks_per_intr;

	for (nstats = 0; nextstatevent <= tb; nstats++) {
		int r;
		do {
			r = random() & (statvar - 1);
		} while (r == 0); /* random == 0 not allowed */
		nextstatevent += statmin + r;
	}

	/* only count timer ticks for CLK_IRQ */
	intrcnt[PPC_STAT_IRQ] += nstats;

	if (nexttimerevent < nextstatevent)
		nextevent = nexttimerevent;
	else
		nextevent = nextstatevent;

d288 2
a289 2
	 * Need to work about the near constant skew this introduces???
	 * reloading tb here could cause a missed tick.
d291 3
a293 1
	ppc_mtdec(nextevent - tb);
d295 2
a296 2
	if (cpl & SPL_CLOCK) {
		statspending += nstats;
d298 2
a299 5
		nstats += statspending;
		statspending = 0;

		s = splclock();

d303 2
a304 1
		ppc_intr_enable(1);
d310 2
a311 5
		frame->pri = s | SINT_CLOCK;
		while (lasttb < prevtb - ticks_per_intr) {
			/* sync lasttb with hardclock */
			lasttb += ticks_per_intr;
			intrcnt[PPC_CLK_IRQ]++;
d313 8
a320 9
		}

		frame->pri = s;
		while (lasttb < prevtb) {
			/* sync lasttb with hardclock */
			lasttb += ticks_per_intr;
			intrcnt[PPC_CLK_IRQ]++;
			hardclock(frame);
		}
a321 11
		while (nstats-- > 0)
			statclock(frame);

		splx(s);
		ppc_intr_disable();

		/*
		 * If a tick has occurred while dealing with these,
		 * don't service it now, delay until the next tick.
		 */
	}
d327 6
a332 34
	int intrstate;
	int r;
	int minint;
	u_int64_t nextevent;

	intrstate = ppc_intr_disable();

	stathz = 100;
	profhz = 1000; /* must be a multiple of stathz */

	/* init secondary clock to stathz */
	statint = ticks_per_sec / stathz;
	statvar = 0x40000000; /* really big power of two */
	/* find largest 2^n which is nearly smaller than statint/2 */
	minint = statint / 2 + 100;
	while (statvar > minint)
		statvar >>= 1;

	statmin = statint - (statvar >> 1);

	lasttb = ppc_mftb();
	nexttimerevent = lasttb + ticks_per_intr;
	do {
		r = random() & (statvar - 1);
	} while (r == 0); /* random == 0 not allowed */
	nextstatevent = lasttb + statmin + r;

	if (nexttimerevent < nextstatevent)
		nextevent = nexttimerevent;
	else
		nextevent = nextstatevent;

	ppc_mtdec(nextevent - lasttb);
	ppc_intr_enable(intrstate);
d336 1
a336 1
calc_delayconst(void)
d338 1
a338 1
	int s;
d340 3
a342 2
	ticks_per_sec = (*tps)();
	s = ppc_intr_disable();
d345 12
a356 1
	ppc_intr_enable(s);
d363 2
a364 1
microtime(struct timeval *tvp)
d366 8
a373 7
	u_int64_t tb;
	u_int32_t ticks;
	int s;

	s = ppc_intr_disable();
	tb = ppc_mftb();
	ticks = ((tb - lasttb) * ns_per_tick) / 1000;
d375 2
a376 1
	ppc_intr_enable(s);
d388 2
a389 1
delay(unsigned n)
d391 2
a392 2
	u_int64_t tb;
	u_int32_t tbh, tbl, scratch;
d394 1
a394 1
	tb = ppc_mftb();
d397 1
a397 1
	tbl = (u_int32_t)tb;
d399 4
a402 2
	     " mftb %0; cmplw %0,%2; blt 1b; 2:"
	     :: "r"(scratch), "r"(tbh), "r"(tbl));
d405 3
d409 2
a410 1
setstatclockrate(int newhz)
d412 1
a412 19
	int minint;
	int intrstate;

	intrstate = ppc_intr_disable();

	statint = ticks_per_sec / newhz;
	statvar = 0x40000000; /* really big power of two */
	/* find largest 2^n which is nearly smaller than statint/2 */
	minint = statint / 2 + 100;
	while (statvar > minint)
		statvar >>= 1;

	statmin = statint - (statvar >> 1);
	ppc_intr_enable(intrstate);

	/*
	 * XXX this allows the next stat timer to occur then it switches
	 * to the new frequency. Rather than switching instantly.
	 */
@


1.1.2.6
log
@Merge with the trunk
@
text
@a42 2
#include "bugtty.h"

a347 6
#if NBUGTTY > 0
			{
				extern void bugtty_chkinput(void);
				bugtty_chkinput();
			}
#endif
@


