head	1.14;
access;
symbols
	OPENBSD_4_9:1.12.0.4
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.12.0.2
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.11.0.2
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.11.0.4
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.9.0.4
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.2
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.8.0.4
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.2
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.7.0.14
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.12
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.10
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.8
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.6
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.4
	OPENBSD_3_6_BASE:1.7
	SMP_SYNC_A:1.7
	SMP_SYNC_B:1.7
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.5.0.6
	OPENBSD_3_4_BASE:1.5
	UBC_SYNC_A:1.5
	OPENBSD_3_3:1.5.0.4
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4
	UBC_SYNC_B:1.5
	UBC:1.3.0.2
	UBC_BASE:1.3
	OPENBSD_3_0:1.2.0.2
	OPENBSD_3_0_BASE:1.2
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.14
date	2011.07.07.19.16.42;	author deraadt;	state dead;
branches;
next	1.13;

1.13
date	2011.03.23.16.54.36;	author pirofti;	state Exp;
branches;
next	1.12;

1.12
date	2010.04.04.12.49.30;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2009.05.31.17.42.13;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2009.04.20.00.42.06;	author oga;	state Exp;
branches;
next	1.9;

1.9
date	2008.06.26.05.42.12;	author ray;	state Exp;
branches;
next	1.8;

1.8
date	2007.04.10.18.02.48;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.04.21.13.37;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2003.11.25.21.16.44;	author drahn;	state Exp;
branches;
next	1.5;

1.5
date	2002.06.08.15.49.57;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2002.03.14.01.26.41;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.11.05.17.25.58;	author art;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2001.09.23.01.42.38;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2001.06.26.21.57.43;	author smurph;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2001.10.31.03.01.20;	author nate;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2001.11.13.21.04.15;	author niklas;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2002.03.28.10.36.03;	author niklas;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2003.03.27.23.52.16;	author niklas;	state Exp;
branches;
next	1.1.2.5;

1.1.2.5
date	2004.02.19.10.49.09;	author niklas;	state Exp;
branches;
next	;

1.3.2.1
date	2002.06.11.03.37.22;	author art;	state Exp;
branches;
next	;


desc
@@


1.14
log
@remove mvmeppc; it is really rough shape.  ok drahn miod
@
text
@/*	$NetBSD: bus.h,v 1.1 2001/06/06 17:37:37 matt Exp $	*/
/*	$OpenBSD: bus_mi.h,v 1.13 2011/03/23 16:54:36 pirofti Exp $	*/

/*-
 * Copyright (c) 1996, 1997, 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,
 * NASA Ames Research Center.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 1996 Charles M. Hannum.  All rights reserved.
 * Copyright (c) 1996 Jason R. Thorpe.  All rights reserved.
 * Copyright (c) 1996 Christopher G. Demetriou.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Christopher G. Demetriou
 *	for the NetBSD Project.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 1997 Per Fogelstrom.  All rights reserved.
 * Copyright (c) 1996 Niklas Hallqvist.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Christopher G. Demetriou
 *	for the NetBSD Project.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef _MACHINE_BUS_MI_H_
#define _MACHINE_BUS_MI_H_

#include <machine/pio.h>

/*
 * Bus access types.
 */
typedef u_int32_t bus_addr_t;
typedef u_int32_t bus_size_t;
typedef u_int32_t bus_space_handle_t;
typedef const struct ppc_bus_space *bus_space_tag_t;

struct ppc_bus_space {
	u_int32_t pbs_type;
	bus_addr_t pbs_offset;
	bus_addr_t pbs_base;
	bus_addr_t pbs_limit;
	int (*pbs_map)(bus_space_tag_t, bus_addr_t, bus_size_t, int,
	    bus_space_handle_t *);
	void (*pbs_unmap)(bus_space_tag_t, bus_space_handle_t,
	    bus_size_t);
	int (*pbs_alloc)(bus_space_tag_t, bus_addr_t, bus_addr_t,
	    bus_size_t, bus_size_t align, bus_size_t, int, bus_addr_t *,
	    bus_space_handle_t *);
	void (*pbs_free)(bus_space_tag_t, bus_space_handle_t, bus_size_t);
};

#define BUS_SPACE_MAP_CACHEABLE		0x01
#define BUS_SPACE_MAP_LINEAR		0x02
#define BUS_SPACE_MAP_PREFETCHABLE	0x04

#ifdef __STDC__
#define CAT(a,b)	a##b
#define CAT3(a,b,c)	a##b##c
#else
#define CAT(a,b)	a/**/b
#define CAT3(a,b,c)	a/**/b/**/c
#endif

/*
 * Access methods for bus resources
 */

#define __BUS_SPACE_HAS_STREAM_METHODS

/*
 *	int bus_space_map(bus_space_tag_t t, bus_addr_t addr,
 *	    bus_size_t size, int flags, bus_space_handle_t *bshp);
 *
 * Map a region of bus space.
 */

#define bus_space_map(t, a, s, f, hp)	\
    ((*(t)->pbs_map)((t), (a), (s), (f), (hp)))

/*
 *	int bus_space_unmap(bus_space_tag_t t,
 *	    bus_space_handle_t bsh, bus_size_t size);
 *
 * Unmap a region of bus space.
 */

#define bus_space_unmap(t, h, s)					\
    ((void)(*(t)->pbs_unmap)((t), (h), (s)))

/*
 *	int bus_space_subregion(bus_space_tag_t t,
 *	    bus_space_handle_t bsh, bus_size_t offset, bus_size_t size,
 *	    bus_space_handle_t *nbshp);
 *
 * Get a new handle for a subregion of an already-mapped area of bus space.
 */

#define bus_space_subregion(t, h, o, s, hp)				\
    ((*(hp) = (h) + (o)), 0)

/*
 *	int bus_space_alloc(bus_space_tag_t t, bus_addr_t rstart,
 *	    bus_addr_t rend, bus_size_t size, bus_size_t align,
 *	    bus_size_t boundary, int flags, bus_addr_t *bpap,
 *	    bus_space_handle_t *bshp);
 *
 * Allocate a region of bus space.
 */

#define bus_space_alloc(t, rs, re, s, a, b, f, ap, hp)			\
    ((*(t)->pbs_alloc)((t), (rs), (re), (s), (a), (b), (f), (ap), (hp)))

/*
 *	int bus_space_free(bus_space_tag_t t,
 *	    bus_space_handle_t bsh, bus_size_t size);
 *
 * Free a region of bus space.
 */

#define bus_space_free(t, h, s)						\
    ((void)(*(t)->pbs_free)((t), (h), (s)))

/*
 *	u_intN_t bus_space_read_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset);
 *
 * Read a 1, 2, 4, or 8 byte quantity from bus space
 * described by tag/handle/offset.
 */

#define bus_space_read(n,m)						      \
static __inline CAT3(u_int,m,_t)					      \
CAT(bus_space_read_,n)(bus_space_tag_t tag, bus_space_handle_t bsh,	      \
    bus_size_t offset)							      \
{									      \
	return CAT3(in,m,rb)((volatile CAT3(u_int,m,_t) *)(bsh + (offset)));  \
}

bus_space_read(1,8)
bus_space_read(2,16)
bus_space_read(4,32)
#define bus_space_read_8	!!! bus_space_read_8 unimplemented !!!

/*
 *	u_intN_t bus_space_read_stream_N(bus_space_tag_t tag,
 *	     bus_space_handle_t bsh, bus_size_t offset);
 *
 * Read a 2, 4, or 8 byte stream quantity from bus space
 * described by tag/handle/offset.
 */

#define bus_space_read_stream(n,m)					      \
static __inline CAT3(u_int,m,_t)					      \
CAT(bus_space_read_stream_,n)(bus_space_tag_t tag, bus_space_handle_t bsh,    \
    bus_size_t offset)							      \
{									      \
	return CAT(in,m)((volatile CAT3(u_int,m,_t) *)(bsh + (offset)));      \
}

bus_space_read_stream(2,16)
bus_space_read_stream(4,32)
#define bus_space_read_stream_8	!!! bus_space_read_stream_8 unimplemented !!!

/*
 *	void bus_space_read_multi_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset,
 *	    u_intN_t *addr, size_t count);
 *
 * Read `count' 1, 2, 4, or 8 byte quantities from bus space
 * described by tag/handle/offset and copy into buffer provided.
 */

#define bus_space_read_multi(n,m)					     \
static __inline void							     \
CAT(bus_space_read_multi_,n)(bus_space_tag_t tag, bus_space_handle_t bsh,    \
     bus_size_t offset, CAT3(u_int,m,_t) *addr, size_t count)		     \
{									     \
	while (count--)							     \
		*addr++ = CAT(bus_space_read_,n)(tag, bsh, offset);	     \
}

bus_space_read_multi(1,8)
bus_space_read_multi(2,16)
bus_space_read_multi(4,32)
#define bus_space_read_multi_8	!!! bus_space_read_multi_8 not implemented !!!

#if 0
/*
 *	void bus_space_read_multi_stream_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset,
 *	    u_intN_t *addr, size_t count);
 *
 * Read `count' 2, 4, or 8 byte stream quantities from bus space
 * described by tag/handle/offset and copy into buffer provided.
 */

#define bus_space_read_multi_stream(n,m)				      \
static __inline void							      \
CAT(bus_space_read_multi_stream_,n)(bus_space_tag_t tag,		      \
     bus_space_handle_t bsh,						      \
     bus_size_t offset, CAT3(u_int,m,_t) *addr, size_t count)		      \
{									      \
	CAT(ins,m)((volatile CAT3(u_int,m,_t) *)(bsh + (offset)),	      \
	    (CAT3(u_int,m,_t) *)addr, (size_t)count);			      \
}

bus_space_read_multi_stream(2,16)
bus_space_read_multi_stream(4,32)
#define bus_space_read_multi_stream_8					      \
	!!! bus_space_read_multi_stream_8 not implemented !!!

/*
 *      void bus_space_write_N(bus_space_tag_t tag,
 *	  bus_space_handle_t bsh, bus_size_t offset,
 *	  u_intN_t value);
 *
 * Write the 1, 2, 4, or 8 byte value `value' to bus space
 * described by tag/handle/offset.
 */
#endif

#define bus_space_write(n,m)						     \
static __inline void							     \
CAT(bus_space_write_,n)(bus_space_tag_t tag, bus_space_handle_t bsh,	     \
    bus_size_t offset, CAT3(u_int,m,_t) x)				     \
{									     \
	CAT3(out,m,rb)((volatile CAT3(u_int,m,_t) *)(bsh + (offset)), x);    \
}

bus_space_write(1,8)
bus_space_write(2,16)
bus_space_write(4,32)
#define bus_space_write_8	!!! bus_space_write_8 unimplemented !!!

/*
 *	void bus_space_write_stream_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset,
 *	    u_intN_t value);
 *
 * Write the 2, 4, or 8 byte stream value `value' to bus space
 * described by tag/handle/offset.
 */

#define bus_space_write_stream(n,m)					      \
static __inline void							      \
CAT(bus_space_write_stream_,n)(bus_space_tag_t tag, bus_space_handle_t bsh,   \
    bus_size_t offset, CAT3(u_int,m,_t) x)				      \
{									      \
	CAT(out,m)((volatile CAT3(u_int,m,_t) *)(bsh + (offset)), x);	      \
}

bus_space_write_stream(2,16)
bus_space_write_stream(4,32)
#define bus_space_write_stream_8 !!! bus_space_write_stream_8 unimplemented !!!

/*
 *	void bus_space_write_multi_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset,
 *	    const u_intN_t *addr, size_t count);
 *
 * Write `count' 1, 2, 4, or 8 byte quantities from the buffer
 * provided to bus space described by tag/handle/offset.
 */

#define bus_space_write_multi(n,m)					      \
static __inline void							      \
CAT(bus_space_write_multi_,n)(bus_space_tag_t tag, bus_space_handle_t bsh,    \
    bus_size_t offset, const CAT3(u_int,m,_t) *addr, size_t count)	      \
{									      \
	while (count--)							      \
		CAT(bus_space_write_,n)(tag, bsh, offset, *addr++);	      \
}

bus_space_write_multi(1,8)
bus_space_write_multi(2,16)
bus_space_write_multi(4,32)
#define bus_space_write_multi_8	!!! bus_space_write_multi_8 not implemented !!!

#if 0
/*
 *      void bus_space_write_multi_stream_N(bus_space_tag_t tag,
 *	  bus_space_handle_t bsh, bus_size_t offset,
 *	  const u_intN_t *addr, size_t count);
 *
 * Write `count' 2, 4, or 8 byte stream quantities from the buffer
 * provided to bus space described by tag/handle/offset.
 */

#define bus_space_write_multi_stream(n,m)				     \
static __inline void							     \
CAT(bus_space_write_multi_stream_,n)(bus_space_tag_t tag,		     \
     bus_space_handle_t bsh,						     \
     bus_size_t offset, const CAT3(u_int,m,_t) *addr, size_t count)	     \
{									     \
	CAT(outs,m)((volatile CAT3(u_int,m,_t) *)(bsh + (offset)),	     \
	    (CAT3(u_int,m,_t) *)addr, (size_t)count);			     \
}

bus_space_write_multi_stream(2,16)
bus_space_write_multi_stream(4,32)
#define bus_space_write_multi_stream_8					     \
	!!! bus_space_write_multi_stream_8 not implemented !!!
#endif

/*
 *      void bus_space_read_region_N(bus_space_tag_t tag,
 *	  bus_space_handle_t bsh, bus_size_t offset,
 *	  u_intN_t *addr, size_t count);
 *
 * Read `count' 1, 2, 4, or 8 byte quantities from bus space
 * described by tag/handle and starting at `offset' and copy into
 * buffer provided.
 */
static __inline void bus_space_read_region_1(bus_space_tag_t,
	bus_space_handle_t, bus_size_t, u_int8_t *, size_t);
static __inline void bus_space_read_region_2(bus_space_tag_t,
	bus_space_handle_t, bus_size_t, u_int16_t *, size_t);
static __inline void bus_space_read_region_4(bus_space_tag_t,
	bus_space_handle_t, bus_size_t, u_int32_t *, size_t);

static __inline void
bus_space_read_region_1(tag, bsh, offset, addr, count)
	bus_space_tag_t tag;
	bus_space_handle_t bsh;
	bus_size_t offset;
	u_int8_t *addr;
	size_t count;
{
	volatile u_int8_t *s;

	s = (volatile u_int8_t *)(bsh + offset);
	while (count--)
		*addr++ = *s++;
	__asm__ volatile("eieio; sync");
}

static __inline void
bus_space_read_region_2(tag, bsh, offset, addr, count)
	bus_space_tag_t tag;
	bus_space_handle_t bsh;
	bus_size_t offset;
	u_int16_t *addr;
	size_t count;
{
	volatile u_int16_t *s;

	s = (volatile u_int16_t *)(bsh + offset);
	while (count--)
		__asm__ volatile("lhbrx %0, 0, %1" :
			"=r"(*addr++) : "r"(s++));
	__asm__ volatile("eieio; sync");
}

static __inline void
bus_space_read_region_4(tag, bsh, offset, addr, count)
	bus_space_tag_t tag;
	bus_space_handle_t bsh;
	bus_size_t offset;
	u_int32_t *addr;
	size_t count;
{
	volatile u_int32_t *s;

	s = (volatile u_int32_t *)(bsh + offset);
	while (count--)
		__asm__ volatile("lwbrx %0, 0, %1" :
			"=r"(*addr++) : "r"(s++));
	__asm__ volatile("eieio; sync");
}

#define bus_space_read_region_8	!!! bus_space_read_region_8 unimplemented !!!

/*
 *	void bus_space_read_region_stream_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset,
 *	    u_intN_t *addr, size_t count);
 *
 * Read `count' 2, 4, or 8 byte stream quantities from bus space
 * described by tag/handle and starting at `offset' and copy into
 * buffer provided.
 */
static __inline void bus_space_read_region_stream_2(bus_space_tag_t,
	bus_space_handle_t, bus_size_t, u_int16_t *, size_t);
static __inline void bus_space_read_region_stream_4(bus_space_tag_t,
	bus_space_handle_t, bus_size_t, u_int32_t *, size_t);

static __inline void
bus_space_read_region_stream_2(tag, bsh, offset, addr, count)
	bus_space_tag_t tag;
	bus_space_handle_t bsh;
	bus_size_t offset;
	u_int16_t *addr;
	size_t count;
{
	volatile u_int16_t *s;

	s = (volatile u_int16_t *)(bsh + offset);
	while (count--)
		*addr++ = *s++;
	__asm__ volatile("eieio; sync");
}

static __inline void
bus_space_read_region_stream_4(tag, bsh, offset, addr, count)
	bus_space_tag_t tag;
	bus_space_handle_t bsh;
	bus_size_t offset;
	u_int32_t *addr;
	size_t count;
{
	volatile u_int32_t *s;

	s = (volatile u_int32_t *)(bsh + offset);
	while (count--)
		*addr++ = *s++;
	__asm__ volatile("eieio; sync");
}

#define bus_space_read_region_stream_8					      \
	!!! bus_space_read_region_stream_8 unimplemented !!!

/*
 *	void bus_space_write_region_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset,
 *	    const u_intN_t *addr, size_t count);
 *
 * Write `count' 1, 2, 4, or 8 byte quantities from the buffer provided
 * to bus space described by tag/handle starting at `offset'.
 */
static __inline void bus_space_write_region_1(bus_space_tag_t,
	bus_space_handle_t, bus_size_t, const u_int8_t *, size_t);
static __inline void bus_space_write_region_2(bus_space_tag_t,
	bus_space_handle_t, bus_size_t, const u_int16_t *, size_t);
static __inline void bus_space_write_region_4(bus_space_tag_t,
	bus_space_handle_t, bus_size_t, const u_int32_t *, size_t);

static __inline void
bus_space_write_region_1(tag, bsh, offset, addr, count)
	bus_space_tag_t tag;
	bus_space_handle_t bsh;
	bus_size_t offset;
	const u_int8_t *addr;
	size_t count;
{
	volatile u_int8_t *d;

	d = (volatile u_int8_t *)(bsh + offset);
	while (count--)
		*d++ = *addr++;
	__asm__ volatile("eieio; sync");
}

static __inline void
bus_space_write_region_2(tag, bsh, offset, addr, count)
	bus_space_tag_t tag;
	bus_space_handle_t bsh;
	bus_size_t offset;
	const u_int16_t *addr;
	size_t count;
{
	volatile u_int16_t *d;

	d = (volatile u_int16_t *)(bsh + offset);
	while (count--)
		__asm__ volatile("sthbrx %0, 0, %1" ::
			"r"(*addr++), "r"(d++));
	__asm__ volatile("eieio; sync");
}

static __inline void
bus_space_write_region_4(tag, bsh, offset, addr, count)
	bus_space_tag_t tag;
	bus_space_handle_t bsh;
	bus_size_t offset;
	const u_int32_t *addr;
	size_t count;
{
	volatile u_int32_t *d;

	d = (volatile u_int32_t *)(bsh + offset);
	while (count--)
		__asm__ volatile("stwbrx %0, 0, %1" ::
			"r"(*addr++), "r"(d++));
	__asm__ volatile("eieio; sync");
}

#define bus_space_write_region_8 !!! bus_space_write_region_8 unimplemented !!!

/*
 *	void bus_space_write_region_stream_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset,
 *	    const u_intN_t *addr, size_t count);
 *
 * Write `count' 2, 4, or 8 byte stream quantities from the buffer provided
 * to bus space described by tag/handle starting at `offset'.
 */
static __inline void bus_space_write_region_stream_2(bus_space_tag_t,
	bus_space_handle_t, bus_size_t, const u_int16_t *, size_t);
static __inline void bus_space_write_region_stream_4(bus_space_tag_t,
	bus_space_handle_t, bus_size_t, const u_int32_t *, size_t);

static __inline void
bus_space_write_region_stream_2(tag, bsh, offset, addr, count)
	bus_space_tag_t tag;
	bus_space_handle_t bsh;
	bus_size_t offset;
	const u_int16_t *addr;
	size_t count;
{
	volatile u_int16_t *d;

	d = (volatile u_int16_t *)(bsh + offset);
	while (count--)
		*d++ = *addr++;
	__asm__ volatile("eieio; sync");
}

static __inline void
bus_space_write_region_stream_4(tag, bsh, offset, addr, count)
	bus_space_tag_t tag;
	bus_space_handle_t bsh;
	bus_size_t offset;
	const u_int32_t *addr;
	size_t count;
{
	volatile u_int32_t *d;

	d = (volatile u_int32_t *)(bsh + offset);
	while (count--)
		*d++ = *addr++;
	__asm__ volatile("eieio; sync");
}

#define bus_space_write_region_stream_8					      \
	 !!! bus_space_write_region_stream_8 unimplemented !!!

/*
 *	void bus_space_set_multi_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset, u_intN_t val,
 *	    size_t count);
 *
 * Write the 1, 2, 4, or 8 byte value `val' to bus space described
 * by tag/handle/offset `count' times.
 */
static __inline void bus_space_set_multi_1(bus_space_tag_t,
	bus_space_handle_t, bus_size_t, u_int8_t, size_t);
static __inline void bus_space_set_multi_2(bus_space_tag_t,
	bus_space_handle_t, bus_size_t, u_int16_t, size_t);
static __inline void bus_space_set_multi_4(bus_space_tag_t,
	bus_space_handle_t, bus_size_t, u_int32_t, size_t);

static __inline void
bus_space_set_multi_1(tag, bsh, offset, val, count)
	bus_space_tag_t tag;
	bus_space_handle_t bsh;
	bus_size_t offset;
	u_int8_t val;
	size_t count;
{
	volatile u_int8_t *d;

	d = (volatile u_int8_t *)(bsh + offset);
	while (count--)
		*d = val;
	__asm__ volatile("eieio; sync");
}

static __inline void
bus_space_set_multi_2(tag, bsh, offset, val, count)
	bus_space_tag_t tag;
	bus_space_handle_t bsh;
	bus_size_t offset;
	u_int16_t val;
	size_t count;
{
	volatile u_int16_t *d;

	d = (volatile u_int16_t *)(bsh + offset);
	while (count--)
		__asm__ volatile("sthbrx %0, 0, %1" ::
			"r"(val), "r"(d));
	__asm__ volatile("eieio; sync");
}

static __inline void
bus_space_set_multi_4(tag, bsh, offset, val, count)
	bus_space_tag_t tag;
	bus_space_handle_t bsh;
	bus_size_t offset;
	u_int32_t val;
	size_t count;
{
	volatile u_int32_t *d;

	d = (volatile u_int32_t *)(bsh + offset);
	while (count--)
		__asm__ volatile("stwbrx %0, 0, %1" ::
			"r"(val), "r"(d));
	__asm__ volatile("eieio; sync");
}

#define bus_space_set_multi_8 !!! bus_space_set_multi_8 unimplemented !!!

/*
 *	void bus_space_set_multi_stream_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset, u_intN_t val,
 *	    size_t count);
 *
 * Write the 2, 4, or 8 byte stream value `val' to bus space described
 * by tag/handle/offset `count' times.
 */
static __inline void bus_space_set_multi_stream_2(bus_space_tag_t,
	bus_space_handle_t, bus_size_t, u_int16_t, size_t);
static __inline void bus_space_set_multi_stream_4(bus_space_tag_t,
	bus_space_handle_t, bus_size_t, u_int32_t, size_t);

static __inline void
bus_space_set_multi_stream_2(tag, bsh, offset, val, count)
	bus_space_tag_t tag;
	bus_space_handle_t bsh;
	bus_size_t offset;
	u_int16_t val;
	size_t count;
{
	volatile u_int16_t *d;

	d = (volatile u_int16_t *)(bsh + offset);
	while (count--)
		*d = val;
	__asm__ volatile("eieio; sync");
}

static __inline void
bus_space_set_multi_stream_4(tag, bsh, offset, val, count)
	bus_space_tag_t tag;
	bus_space_handle_t bsh;
	bus_size_t offset;
	u_int32_t val;
	size_t count;
{
	volatile u_int32_t *d;

	d = (volatile u_int32_t *)(bsh + offset);
	while (count--)
		*d = val;
	__asm__ volatile("eieio; sync");
}

#define bus_space_set_multi_stream_8					      \
	!!! bus_space_set_multi_stream_8 unimplemented !!!

/*
 *	void bus_space_set_region_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset, u_intN_t val,
 *	    size_t count);
 *
 * Write `count' 1, 2, 4, or 8 byte value `val' to bus space described
 * by tag/handle starting at `offset'.
 */
static __inline void bus_space_set_region_1(bus_space_tag_t,
	bus_space_handle_t, bus_size_t, u_int8_t, size_t);
static __inline void bus_space_set_region_2(bus_space_tag_t,
	bus_space_handle_t, bus_size_t, u_int16_t, size_t);
static __inline void bus_space_set_region_4(bus_space_tag_t,
	bus_space_handle_t, bus_size_t, u_int32_t, size_t);

static __inline void
bus_space_set_region_1(tag, bsh, offset, val, count)
	bus_space_tag_t tag;
	bus_space_handle_t bsh;
	bus_size_t offset;
	u_int8_t val;
	size_t count;
{
	volatile u_int8_t *d;

	d = (volatile u_int8_t *)(bsh + offset);
	while (count--)
		*d++ = val;
	__asm__ volatile("eieio; sync");
}

static __inline void
bus_space_set_region_2(tag, bsh, offset, val, count)
	bus_space_tag_t tag;
	bus_space_handle_t bsh;
	bus_size_t offset;
	u_int16_t val;
	size_t count;
{
	volatile u_int16_t *d;

	d = (volatile u_int16_t *)(bsh + offset);
	while (count--)
		__asm__ volatile("sthbrx %0, 0, %1" ::
			"r"(val), "r"(d++));
	__asm__ volatile("eieio; sync");
}

static __inline void
bus_space_set_region_4(tag, bsh, offset, val, count)
	bus_space_tag_t tag;
	bus_space_handle_t bsh;
	bus_size_t offset;
	u_int32_t val;
	size_t count;
{
	volatile u_int32_t *d;

	d = (volatile u_int32_t *)(bsh + offset);
	while (count--)
		__asm__ volatile("stwbrx %0, 0, %1" ::
			"r"(val), "r"(d++));
	__asm__ volatile("eieio; sync");
}

#define bus_space_set_region_8 !!! bus_space_set_region_8 unimplemented !!!

/*
 *	void bus_space_set_region_stream_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset, u_intN_t val,
 *	    size_t count);
 *
 * Write `count' 2, 4, or 8 byte stream value `val' to bus space described
 * by tag/handle starting at `offset'.
 */
static __inline void bus_space_set_region_stream_2(bus_space_tag_t,
	bus_space_handle_t, bus_size_t, u_int16_t, size_t);
static __inline void bus_space_set_region_stream_4(bus_space_tag_t,
	bus_space_handle_t, bus_size_t, u_int32_t, size_t);


static __inline void
bus_space_set_region_stream_2(tag, bsh, offset, val, count)
	bus_space_tag_t tag;
	bus_space_handle_t bsh;
	bus_size_t offset;
	u_int16_t val;
	size_t count;
{
	volatile u_int16_t *d;

	d = (volatile u_int16_t *)(bsh + offset);
	while (count--)
		*d++ = val;
	__asm__ volatile("eieio; sync");
}

static __inline void
bus_space_set_region_stream_4(tag, bsh, offset, val, count)
	bus_space_tag_t tag;
	bus_space_handle_t bsh;
	bus_size_t offset;
	u_int32_t val;
	size_t count;
{
	volatile u_int32_t *d;

	d = (volatile u_int32_t *)(bsh + offset);
	while (count--)
		*d++ = val;
	__asm__ volatile("eieio; sync");
}

#define bus_space_set_region_stream_8					      \
	!!! bus_space_set_region_stream_8 unimplemented !!!

/*
 *	void bus_space_copy_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh1, bus_size_t off1,
 *	    bus_space_handle_t bsh2, bus_size_t off2,
 *	    size_t count);
 *
 * Copy `count' 1, 2, 4, or 8 byte values from bus space starting
 * at tag/bsh1/off1 to bus space starting at tag/bsh2/off2.
 */

static __inline void bus_space_copy_1(bus_space_tag_t,
	bus_space_handle_t, bus_size_t, bus_space_handle_t,
	bus_size_t, size_t);
static __inline void bus_space_copy_2(bus_space_tag_t,
	bus_space_handle_t, bus_size_t, bus_space_handle_t,
	bus_size_t, size_t);
static __inline void bus_space_copy_4(bus_space_tag_t,
	bus_space_handle_t, bus_size_t, bus_space_handle_t,
	bus_size_t, size_t);

static __inline void
bus_space_copy_1(t, h1, o1, h2, o2, c)
	bus_space_tag_t t;
	bus_space_handle_t h1;
	bus_size_t o1;
	bus_space_handle_t h2;
	bus_size_t o2;
	size_t c;
{
	bus_addr_t addr1 = h1 + o1;
	bus_addr_t addr2 = h2 + o2;

	if (addr1 >= addr2) {
		/* src after dest: copy forward */
		for (; c != 0; c--, addr1++, addr2++)
			*(volatile u_int8_t *)(addr2) =
			    *(volatile u_int8_t *)(addr1);
	} else {
		/* dest after src: copy backwards */
		for (addr1 += (c - 1), addr2 += (c - 1);
		    c != 0; c--, addr1--, addr2--)
			*(volatile u_int8_t *)(addr2) =
			    *(volatile u_int8_t *)(addr1);
	}
}

static __inline void
bus_space_copy_2(t, h1, o1, h2, o2, c)
	bus_space_tag_t t;
	bus_space_handle_t h1;
	bus_size_t o1;
	bus_space_handle_t h2;
	bus_size_t o2;
	size_t c;
{
	bus_addr_t addr1 = h1 + o1;
	bus_addr_t addr2 = h2 + o2;

	if (addr1 >= addr2) {
		/* src after dest: copy forward */
		for (; c != 0; c--, addr1 += 2, addr2 += 2)
			*(volatile u_int16_t *)(addr2) =
			    *(volatile u_int16_t *)(addr1);
	} else {
		/* dest after src: copy backwards */
		for (addr1 += 2 * (c - 1), addr2 += 2 * (c - 1);
		    c != 0; c--, addr1 -= 2, addr2 -= 2)
			*(volatile u_int16_t *)(addr2) =
			    *(volatile u_int16_t *)(addr1);
	}
}

static __inline void
bus_space_copy_4(t, h1, o1, h2, o2, c)
	bus_space_tag_t t;
	bus_space_handle_t h1;
	bus_size_t o1;
	bus_space_handle_t h2;
	bus_size_t o2;
	size_t c;
{
	bus_addr_t addr1 = h1 + o1;
	bus_addr_t addr2 = h2 + o2;

	if (addr1 >= addr2) {
		/* src after dest: copy forward */
		for (; c != 0; c--, addr1 += 4, addr2 += 4)
			*(volatile u_int32_t *)(addr2) =
			    *(volatile u_int32_t *)(addr1);
	} else {
		/* dest after src: copy backwards */
		for (addr1 += 4 * (c - 1), addr2 += 4 * (c - 1);
		    c != 0; c--, addr1 -= 4, addr2 -= 4)
			*(volatile u_int32_t *)(addr2) =
			    *(volatile u_int32_t *)(addr1);
	}
}

#define bus_space_copy_8	!!! bus_space_copy_8 unimplemented !!!

/*
 * Bus read/write barrier methods.
 *
 *	void bus_space_barrier(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset,
 *	    bus_size_t len, int flags);
 *
 */
#define bus_space_barrier(t, h, o, l, f)	\
     ((void)((void)(t), (void)(h), (void)(o), (void)(l), (void)(f)))
#define BUS_SPACE_BARRIER_READ	0x01	/* force read barrier */
#define BUS_SPACE_BARRIER_WRITE	0x02	/* force write barrier */

/*
 * Bus DMA methods.
 */

/*
 * Flags used in various bus DMA methods.
 */
#define	BUS_DMA_WAITOK		0x000	/* safe to sleep (pseudo-flag) */
#define	BUS_DMA_NOWAIT		0x001	/* not safe to sleep */
#define	BUS_DMA_ALLOCNOW	0x002	/* perform resource allocation now */
#define	BUS_DMA_COHERENT	0x008	/* hint: map memory DMA coherent */
#define	BUS_DMA_BUS1		0x010	/* placeholders for bus functions... */
#define	BUS_DMA_BUS2		0x020
#define	BUS_DMA_BUS3		0x040
#define	BUS_DMA_BUS4		0x080
#define	BUS_DMA_READ		0x100	/* mapping is device -> memory only */
#define	BUS_DMA_WRITE		0x200	/* mapping is memory -> device only */
#define	BUS_DMA_STREAMING	0x400	/* hint: sequential, unidirectional */
#define	BUS_DMA_ZERO		0x800	/* zero memory in dmamem_alloc */

/* Forwards needed by prototypes below. */
struct mbuf;
struct uio;

#define BUS_DMASYNC_PREREAD	0x01
#define BUS_DMASYNC_POSTREAD	0x02
#define BUS_DMASYNC_PREWRITE	0x04
#define BUS_DMASYNC_POSTWRITE	0x08

typedef struct powerpc_bus_dma_tag		*bus_dma_tag_t;
typedef struct powerpc_bus_dmamap		*bus_dmamap_t;

/*
 *	bus_dma_segment_t
 *
 *	Describes a single contiguous DMA transaction.  Values
 *	are suitable for programming into DMA registers.
 */
struct powerpc_bus_dma_segment {
	bus_addr_t	ds_addr;	/* DMA address */
	bus_size_t	ds_len;		/* length of transfer */
};
typedef struct powerpc_bus_dma_segment  bus_dma_segment_t;

/*
 *	bus_dma_tag_t
 *
 *	A machine-dependent opaque type describing the implementation of
 *	DMA for a given bus.
 */

struct powerpc_bus_dma_tag {
	/*
	 * The `bounce threshold' is checked while we are loading
	 * the DMA map.  If the physical address of the segment
	 * exceeds the threshold, an error will be returned.  The
	 * caller can then take whatever action is necessary to
	 * bounce the transfer.  If this value is 0, it will be
	 * ignored.
	 */
	bus_addr_t _bounce_thresh;

	/*
	 * DMA mapping methods.
	 */
	int	(*_dmamap_create)(bus_dma_tag_t, bus_size_t, int,
		    bus_size_t, bus_size_t, int, bus_dmamap_t *);
	void	(*_dmamap_destroy)(bus_dma_tag_t, bus_dmamap_t);
	int	(*_dmamap_load)(bus_dma_tag_t, bus_dmamap_t, void *,
		    bus_size_t, struct proc *, int);
	int	(*_dmamap_load_mbuf)(bus_dma_tag_t, bus_dmamap_t,
		    struct mbuf *, int);
	int	(*_dmamap_load_uio)(bus_dma_tag_t, bus_dmamap_t,
		    struct uio *, int);
	int	(*_dmamap_load_raw)(bus_dma_tag_t, bus_dmamap_t,
		    bus_dma_segment_t *, int, bus_size_t, int);
	void	(*_dmamap_unload)(bus_dma_tag_t, bus_dmamap_t);
	void	    (*_dmamap_sync)(bus_dma_tag_t, bus_dmamap_t,
		    bus_addr_t, bus_size_t, int);
	
	/*
	 * DMA memory utility functions.
	 */
	int	(*_dmamem_alloc)(bus_dma_tag_t, bus_size_t, bus_size_t,
		    bus_size_t, bus_dma_segment_t *, int, int *, int);
	void	(*_dmamem_free)(bus_dma_tag_t,
		    bus_dma_segment_t *, int);
	int	(*_dmamem_map)(bus_dma_tag_t, bus_dma_segment_t *,
		    int, size_t, caddr_t *, int);
	void	(*_dmamem_unmap)(bus_dma_tag_t, caddr_t, size_t);
	paddr_t	(*_dmamem_mmap)(bus_dma_tag_t, bus_dma_segment_t *,
		    int, off_t, int, int);
};

#define bus_dmamap_create(t, s, n, m, b, f, p)			\
	(*(t)->_dmamap_create)((t), (s), (n), (m), (b), (f), (p))
#define bus_dmamap_destroy(t, p)				\
	(*(t)->_dmamap_destroy)((t), (p))
#define bus_dmamap_load(t, m, b, s, p, f)			\
	(*(t)->_dmamap_load)((t), (m), (b), (s), (p), (f))
#define bus_dmamap_load_mbuf(t, m, b, f)			\
	(*(t)->_dmamap_load_mbuf)((t), (m), (b), (f))
#define bus_dmamap_load_uio(t, m, u, f)				\
	(*(t)->_dmamap_load_uio)((t), (m), (u), (f))
#define bus_dmamap_load_raw(t, m, sg, n, s, f)			\
	(*(t)->_dmamap_load_raw)((t), (m), (sg), (n), (s), (f))
#define bus_dmamap_unload(t, p)					\
	(*(t)->_dmamap_unload)((t), (p))
#define	bus_dmamap_sync(t, p, a, l, o)				\
	(void)((t)->_dmamap_sync ?				\
	    (*(t)->_dmamap_sync)((t), (p), (a), (l), (o)) : (void)0)

#define bus_dmamem_alloc(t, s, a, b, sg, n, r, f)		\
	(*(t)->_dmamem_alloc)((t), (s), (a), (b), (sg), (n), (r), (f))
#define bus_dmamem_free(t, sg, n)				\
	(*(t)->_dmamem_free)((t), (sg), (n))
#define bus_dmamem_map(t, sg, n, s, k, f)			\
	(*(t)->_dmamem_map)((t), (sg), (n), (s), (k), (f))
#define bus_dmamem_unmap(t, k, s)				\
	(*(t)->_dmamem_unmap)((t), (k), (s))
#define bus_dmamem_mmap(t, sg, n, o, p, f)			\
	(*(t)->_dmamem_mmap)((t), (sg), (n), (o), (p), (f))

/*
 *	bus_dmamap_t
 *
 *	Describes a DMA mapping.
 */
struct powerpc_bus_dmamap {
	/*
	 * PRIVATE MEMBERS: not for use by machine-independent code.
	 */
	bus_size_t	_dm_size;	/* largest DMA transfer mappable */
	int		_dm_segcnt;	/* number of segs this map can map */
	bus_size_t	_dm_maxsegsz;	/* largest possible segment */
	bus_size_t	_dm_boundary;	/* don't cross this */
	bus_addr_t	_dm_bounce_thresh; /* bounce threshold; see tag */
	int		_dm_flags;	/* misc. flags */

	void		*_dm_cookie;	/* cookie for bus-specific functions */

	/*
	 * PUBLIC MEMBERS: these are used by machine-independent code.
	 */
	bus_size_t	dm_mapsize;	/* size of the mapping */
	int		dm_nsegs;	/* # valid segments in mapping */
	bus_dma_segment_t dm_segs[1];	/* segments; variable length */
};

#ifdef _POWERPC_BUS_DMA_PRIVATE
int	_bus_dmamap_create(bus_dma_tag_t, bus_size_t, int, bus_size_t,
	    bus_size_t, int, bus_dmamap_t *);
void	_bus_dmamap_destroy(bus_dma_tag_t, bus_dmamap_t);
int	_bus_dmamap_load(bus_dma_tag_t, bus_dmamap_t, void *,
	    bus_size_t, struct proc *, int);
int	_bus_dmamap_load_mbuf(bus_dma_tag_t, bus_dmamap_t,
	    struct mbuf *, int);
int	_bus_dmamap_load_uio(bus_dma_tag_t, bus_dmamap_t,
	    struct uio *, int);
int	_bus_dmamap_load_raw(bus_dma_tag_t, bus_dmamap_t,
	    bus_dma_segment_t *, int, bus_size_t, int);
void	_bus_dmamap_unload(bus_dma_tag_t, bus_dmamap_t);
void	_bus_dmamap_sync(bus_dma_tag_t, bus_dmamap_t, bus_addr_t,
	    bus_size_t, int);

int	_bus_dmamem_alloc(bus_dma_tag_t tag, bus_size_t size,
	    bus_size_t alignment, bus_size_t boundary,
	    bus_dma_segment_t *segs, int nsegs, int *rsegs, int flags);
void	_bus_dmamem_free(bus_dma_tag_t tag, bus_dma_segment_t *segs,
	    int nsegs);
int	_bus_dmamem_map(bus_dma_tag_t tag, bus_dma_segment_t *segs,
	    int nsegs, size_t size, caddr_t *kvap, int flags);
void	_bus_dmamem_unmap(bus_dma_tag_t tag, caddr_t kva,
	    size_t size);
paddr_t _bus_dmamem_mmap(bus_dma_tag_t tag, bus_dma_segment_t *segs,
	    int nsegs, off_t off, int prot, int flags);

int	_bus_dmamem_alloc_range(bus_dma_tag_t tag, bus_size_t size,
	    bus_size_t alignment, bus_size_t boundary,
	    bus_dma_segment_t *segs, int nsegs, int *rsegs, int flags,
	    paddr_t low, paddr_t high);
#endif /* _POWERPC_BUS_DMA_PRIVATE */
#endif /* _MACHINE_BUS_MI_H_ */
@


1.13
log
@Normalize sentinel. Use _MACHINE_*_H_ and _<ARCH>_*_H_ properly and consitently.

Discussed and okay drahn@@. Okay deraadt@@.
@
text
@d2 1
a2 1
/*	$OpenBSD: bus_mi.h,v 1.12 2010/04/04 12:49:30 miod Exp $	*/
@


1.12
log
@OpenBSD uses bus_space_copy_#, not bus_space_copy_region_#. Make sure only the
first name is used, and remove any #define foo_region foo compatibility
defines.
Also, on sparc64, do not provide a `raw' version of bus_space_copy.
@
text
@d2 1
a2 1
/*	$OpenBSD: bus_mi.h,v 1.11 2009/05/31 17:42:13 miod Exp $	*/
d97 2
a98 2
#ifndef _POWERPC_BUS_H_
#define _POWERPC_BUS_H_
d1136 1
a1136 1
#endif /* _POWERPC_BUS_H_ */
@


1.11
log
@Remove BUS_DMAMEM_NOSYNC definition. Its name is not consistent with
other BUS_DMA_xxx flag names, and nothing uses it.

ok many@@
@
text
@d2 1
a2 1
/*	$OpenBSD: bus_mi.h,v 1.10 2009/04/20 00:42:06 oga Exp $	*/
d842 1
a842 1
 *	void bus_space_copy_region_N(bus_space_tag_t tag,
d851 1
a851 1
static __inline void bus_space_copy_region_1(bus_space_tag_t,
d854 1
a854 1
static __inline void bus_space_copy_region_2(bus_space_tag_t,
d857 1
a857 1
static __inline void bus_space_copy_region_4(bus_space_tag_t,
d862 1
a862 1
bus_space_copy_region_1(t, h1, o1, h2, o2, c)
d888 1
a888 1
bus_space_copy_region_2(t, h1, o1, h2, o2, c)
d914 1
a914 1
bus_space_copy_region_4(t, h1, o1, h2, o2, c)
d939 1
a939 1
#define bus_space_copy_region_8	!!! bus_space_copy_region_8 unimplemented !!!
@


1.10
log
@Add a BUS_DMA_ZERO flag for bus_dmamem_alloc() to return zeroed memory.

Saves every damned driver calling bzero(), and continues the M_ZERO,
PR_ZERO symmetry.
@
text
@d2 1
a2 1
/*	$OpenBSD: bus_mi.h,v 1.9 2008/06/26 05:42:12 ray Exp $	*/
a963 1
#define	BUS_DMAMEM_NOSYNC	0x004
@


1.9
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d2 1
a2 1
/*	$OpenBSD: bus_mi.h,v 1.8 2007/04/10 18:02:48 miod Exp $	*/
d973 1
@


1.8
log
@Remove unused BUS_SPACE_ALIGNED_POINTER, __BUS_SPACE_ADDRESS_SANITY and
__BUS_SPACE_ALIGNED_ADDRESS.
@
text
@d2 1
a2 1
/*	$OpenBSD: bus_mi.h,v 1.7 2003/12/04 21:13:37 miod Exp $	*/
a19 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.7
log
@Typos
@
text
@d2 1
a2 1
/*	$OpenBSD: bus_mi.h,v 1.6 2003/11/25 21:16:44 drahn Exp $	*/
a959 2

#define BUS_SPACE_ALIGNED_POINTER(p, t) ALIGNED_POINTER(p, t)
@


1.6
log
@Allow mvmeppc to compile again. not a supported arch.
@
text
@d2 1
a2 1
/*	$OpenBSD: bus_mi.h,v 1.5 2002/06/08 15:49:57 miod Exp $	*/
d1093 1
a1093 1
	 * PRIVATE MEMBERS: not for use my machine-independent code.
@


1.5
log
@Strict prototypes, and some KNF touches while there.
@
text
@d1 2
a2 2
/*      $NetBSD: bus.h,v 1.1 2001/06/06 17:37:37 matt Exp $        */
/*      $OpenBSD: bus_mi.h,v 1.4 2002/03/14 01:26:41 millert Exp $        */
d22 2
a23 2
 *      This product includes software developed by the NetBSD
 *      Foundation, Inc. and its contributors.
d56 2
a57 2
 *      This product includes software developed by Christopher G. Demetriou
 *      for the NetBSD Project.
d87 2
a88 2
 *      This product includes software developed by Christopher G. Demetriou
 *      for the NetBSD Project.
d118 12
a129 12
        u_int32_t pbs_type;
        bus_addr_t pbs_offset;
        bus_addr_t pbs_base;
        bus_addr_t pbs_limit;
        int (*pbs_map)(bus_space_tag_t, bus_addr_t, bus_size_t, int,
            bus_space_handle_t *);
        void (*pbs_unmap)(bus_space_tag_t, bus_space_handle_t,
            bus_size_t);
        int (*pbs_alloc)(bus_space_tag_t, bus_addr_t, bus_addr_t,
            bus_size_t, bus_size_t align, bus_size_t, int, bus_addr_t *,
            bus_space_handle_t *);
        void (*pbs_free)(bus_space_tag_t, bus_space_handle_t, bus_size_t);
d132 3
a134 3
#define BUS_SPACE_MAP_CACHEABLE         0x01
#define BUS_SPACE_MAP_LINEAR            0x02
#define BUS_SPACE_MAP_PREFETCHABLE        0x04
d137 2
a138 2
#define CAT(a,b)        a##b
#define CAT3(a,b,c)     a##b##c
d140 2
a141 2
#define CAT(a,b)        a/**/b
#define CAT3(a,b,c)     a/**/b/**/c
d151 2
a152 2
 *      int bus_space_map(bus_space_tag_t t, bus_addr_t addr,
 *          bus_size_t size, int flags, bus_space_handle_t *bshp);
d157 1
a157 1
#define bus_space_map(t, a, s, f, hp)                                   \
d161 2
a162 2
 *      int bus_space_unmap(bus_space_tag_t t,
 *          bus_space_handle_t bsh, bus_size_t size);
d167 1
a167 1
#define bus_space_unmap(t, h, s)                                        \
d171 3
a173 3
 *      int bus_space_subregion(bus_space_tag_t t,
 *          bus_space_handle_t bsh, bus_size_t offset, bus_size_t size,
 *          bus_space_handle_t *nbshp);
d178 1
a178 1
#define bus_space_subregion(t, h, o, s, hp)                             \
d182 4
a185 4
 *      int bus_space_alloc(bus_space_tag_t t, bus_addr_t rstart,
 *          bus_addr_t rend, bus_size_t size, bus_size_t align,
 *          bus_size_t boundary, int flags, bus_addr_t *bpap,
 *          bus_space_handle_t *bshp);
d190 1
a190 1
#define bus_space_alloc(t, rs, re, s, a, b, f, ap, hp)                  \
d194 2
a195 2
 *      int bus_space_free(bus_space_tag_t t,
 *          bus_space_handle_t bsh, bus_size_t size);
d200 1
a200 1
#define bus_space_free(t, h, s)                                                \
d204 2
a205 2
 *      u_intN_t bus_space_read_N(bus_space_tag_t tag,
 *          bus_space_handle_t bsh, bus_size_t offset);
d211 6
a216 6
#define bus_space_read(n,m)                                                   \
static __inline CAT3(u_int,m,_t)                                              \
CAT(bus_space_read_,n)(bus_space_tag_t tag, bus_space_handle_t bsh,           \
     bus_size_t offset)                                                       \
{                                                                             \
        return CAT3(in,m,rb)((volatile CAT3(u_int,m,_t) *)(bsh + (offset)));  \
d222 1
a222 1
#define bus_space_read_8        !!! bus_space_read_8 unimplemented !!!
d225 2
a226 2
 *      u_intN_t bus_space_read_stream_N(bus_space_tag_t tag,
 *          bus_space_handle_t bsh, bus_size_t offset);
d232 2
a233 2
#define bus_space_read_stream(n,m)                                            \
static __inline CAT3(u_int,m,_t)                                              \
d235 3
a237 3
     bus_size_t offset)                                                       \
{                                                                             \
        return CAT(in,m)((volatile CAT3(u_int,m,_t) *)(bsh + (offset)));  \
d242 1
a242 1
#define bus_space_read_stream_8        !!! bus_space_read_stream_8 unimplemented !!!
d245 3
a247 3
 *      void bus_space_read_multi_N(bus_space_tag_t tag,
 *          bus_space_handle_t bsh, bus_size_t offset,
 *          u_intN_t *addr, size_t count);
d253 7
a259 7
#define bus_space_read_multi(n,m)                                             \
static __inline void                                                          \
CAT(bus_space_read_multi_,n)(bus_space_tag_t tag, bus_space_handle_t bsh,     \
     bus_size_t offset, CAT3(u_int,m,_t) *addr, size_t count)                 \
{                                                                             \
	while (count--)							      \
		*addr++ = CAT(bus_space_read_,n)(tag, bsh, offset);	      \
d265 1
a265 1
#define bus_space_read_multi_8        !!! bus_space_read_multi_8 not implemented !!!
d269 3
a271 3
 *      void bus_space_read_multi_stream_N(bus_space_tag_t tag,
 *          bus_space_handle_t bsh, bus_size_t offset,
 *          u_intN_t *addr, size_t count);
d277 8
a284 8
#define bus_space_read_multi_stream(n,m)                                      \
static __inline void                                                          \
CAT(bus_space_read_multi_stream_,n)(bus_space_tag_t tag,                      \
     bus_space_handle_t bsh,                                                  \
     bus_size_t offset, CAT3(u_int,m,_t) *addr, size_t count)                 \
{                                                                             \
        CAT(ins,m)((volatile CAT3(u_int,m,_t) *)(bsh + (offset)),              \
            (CAT3(u_int,m,_t) *)addr, (size_t)count);                              \
d289 2
a290 2
#define bus_space_read_multi_stream_8                                              \
        !!! bus_space_read_multi_stream_8 not implemented !!!
d294 2
a295 2
 *          bus_space_handle_t bsh, bus_size_t offset,
 *          u_intN_t value);
d302 6
a307 6
#define bus_space_write(n,m)                                                  \
static __inline void                                                          \
CAT(bus_space_write_,n)(bus_space_tag_t tag, bus_space_handle_t bsh,          \
     bus_size_t offset, CAT3(u_int,m,_t) x)                                   \
{                                                                             \
        CAT3(out,m,rb)((volatile CAT3(u_int,m,_t) *)(bsh + (offset)), x);     \
d313 1
a313 1
#define bus_space_write_8        !!! bus_space_write_8 unimplemented !!!
d316 3
a318 3
 *      void bus_space_write_stream_N(bus_space_tag_t tag,
 *          bus_space_handle_t bsh, bus_size_t offset,
 *          u_intN_t value);
d324 2
a325 2
#define bus_space_write_stream(n,m)                                           \
static __inline void                                                          \
d327 3
a329 3
     bus_size_t offset, CAT3(u_int,m,_t) x)                                   \
{                                                                             \
        CAT(out,m)((volatile CAT3(u_int,m,_t) *)(bsh + (offset)), x);     \
d337 3
a339 3
 *      void bus_space_write_multi_N(bus_space_tag_t tag,
 *          bus_space_handle_t bsh, bus_size_t offset,
 *          const u_intN_t *addr, size_t count);
d345 2
a346 2
#define bus_space_write_multi(n,m)                                            \
static __inline void                                                          \
d348 2
a349 2
     bus_size_t offset, const CAT3(u_int,m,_t) *addr, size_t count)           \
{                                                                             \
d357 1
a357 1
#define bus_space_write_multi_8        !!! bus_space_write_multi_8 not implemented !!!
d362 2
a363 2
 *          bus_space_handle_t bsh, bus_size_t offset,
 *          const u_intN_t *addr, size_t count);
d369 8
a376 8
#define bus_space_write_multi_stream(n,m)                                     \
static __inline void                                                          \
CAT(bus_space_write_multi_stream_,n)(bus_space_tag_t tag,                     \
     bus_space_handle_t bsh,                                                  \
     bus_size_t offset, const CAT3(u_int,m,_t) *addr, size_t count)           \
{                                                                             \
        CAT(outs,m)((volatile CAT3(u_int,m,_t) *)(bsh + (offset)),              \
            (CAT3(u_int,m,_t) *)addr, (size_t)count);                              \
d381 2
a382 2
#define bus_space_write_multi_stream_8                                              \
        !!! bus_space_write_multi_stream_8 not implemented !!!
d387 2
a388 2
 *          bus_space_handle_t bsh, bus_size_t offset,
 *          u_intN_t *addr, size_t count);
d395 1
a395 1
        bus_space_handle_t, bus_size_t, u_int8_t *, size_t);
d397 1
a397 1
        bus_space_handle_t, bus_size_t, u_int16_t *, size_t);
d399 1
a399 1
        bus_space_handle_t, bus_size_t, u_int32_t *, size_t);
d403 12
a414 12
        bus_space_tag_t tag;
        bus_space_handle_t bsh;
        bus_size_t offset;
        u_int8_t *addr;
        size_t count;
{
        volatile u_int8_t *s;

        s = (volatile u_int8_t *)(bsh + offset);
        while (count--)
                *addr++ = *s++;
        __asm__ volatile("eieio; sync");
d419 13
a431 13
        bus_space_tag_t tag;
        bus_space_handle_t bsh;
        bus_size_t offset;
        u_int16_t *addr;
        size_t count;
{
        volatile u_int16_t *s;

        s = (volatile u_int16_t *)(bsh + offset);
        while (count--)
                __asm__ volatile("lhbrx %0, 0, %1" :
                        "=r"(*addr++) : "r"(s++));
        __asm__ volatile("eieio; sync");
d436 5
a440 5
        bus_space_tag_t tag;
        bus_space_handle_t bsh;
        bus_size_t offset;
        u_int32_t *addr;
        size_t count;
d442 1
a442 1
        volatile u_int32_t *s;
d444 5
a448 5
        s = (volatile u_int32_t *)(bsh + offset);
        while (count--)
                __asm__ volatile("lwbrx %0, 0, %1" :
                        "=r"(*addr++) : "r"(s++));
        __asm__ volatile("eieio; sync");
d451 1
a451 1
#define bus_space_read_region_8        !!! bus_space_read_region_8 unimplemented !!!
d454 3
a456 3
 *      void bus_space_read_region_stream_N(bus_space_tag_t tag,
 *          bus_space_handle_t bsh, bus_size_t offset,
 *          u_intN_t *addr, size_t count);
d463 1
a463 1
        bus_space_handle_t, bus_size_t, u_int16_t *, size_t);
d465 1
a465 1
        bus_space_handle_t, bus_size_t, u_int32_t *, size_t);
d469 12
a480 12
        bus_space_tag_t tag;
        bus_space_handle_t bsh;
        bus_size_t offset;
        u_int16_t *addr;
        size_t count;
{
        volatile u_int16_t *s;

        s = (volatile u_int16_t *)(bsh + offset);
        while (count--)
                *addr++ = *s++;
        __asm__ volatile("eieio; sync");
d485 5
a489 5
        bus_space_tag_t tag;
        bus_space_handle_t bsh;
        bus_size_t offset;
        u_int32_t *addr;
        size_t count;
d491 1
a491 1
        volatile u_int32_t *s;
d493 4
a496 4
        s = (volatile u_int32_t *)(bsh + offset);
        while (count--)
                *addr++ = *s++;
        __asm__ volatile("eieio; sync");
d499 2
a500 2
#define bus_space_read_region_stream_8                                              \
        !!! bus_space_read_region_stream_8 unimplemented !!!
d503 3
a505 3
 *      void bus_space_write_region_N(bus_space_tag_t tag,
 *          bus_space_handle_t bsh, bus_size_t offset,
 *          const u_intN_t *addr, size_t count);
d511 1
a511 1
        bus_space_handle_t, bus_size_t, const u_int8_t *, size_t);
d513 1
a513 1
        bus_space_handle_t, bus_size_t, const u_int16_t *, size_t);
d515 1
a515 1
        bus_space_handle_t, bus_size_t, const u_int32_t *, size_t);
d519 12
a530 12
        bus_space_tag_t tag;
        bus_space_handle_t bsh;
        bus_size_t offset;
        const u_int8_t *addr;
        size_t count;
{
        volatile u_int8_t *d;

        d = (volatile u_int8_t *)(bsh + offset);
        while (count--)
                *d++ = *addr++;
        __asm__ volatile("eieio; sync");
d535 13
a547 13
        bus_space_tag_t tag;
        bus_space_handle_t bsh;
        bus_size_t offset;
        const u_int16_t *addr;
        size_t count;
{
        volatile u_int16_t *d;

        d = (volatile u_int16_t *)(bsh + offset);
        while (count--)
                __asm__ volatile("sthbrx %0, 0, %1" ::
                        "r"(*addr++), "r"(d++));
        __asm__ volatile("eieio; sync");
d552 13
a564 13
        bus_space_tag_t tag;
        bus_space_handle_t bsh;
        bus_size_t offset;
        const u_int32_t *addr;
        size_t count;
{
        volatile u_int32_t *d;

        d = (volatile u_int32_t *)(bsh + offset);
        while (count--)
                __asm__ volatile("stwbrx %0, 0, %1" ::
                        "r"(*addr++), "r"(d++));
        __asm__ volatile("eieio; sync");
d570 3
a572 3
 *      void bus_space_write_region_stream_N(bus_space_tag_t tag,
 *          bus_space_handle_t bsh, bus_size_t offset,
 *          const u_intN_t *addr, size_t count);
d578 1
a578 1
        bus_space_handle_t, bus_size_t, const u_int16_t *, size_t);
d580 1
a580 1
        bus_space_handle_t, bus_size_t, const u_int32_t *, size_t);
d584 12
a595 12
        bus_space_tag_t tag;
        bus_space_handle_t bsh;
        bus_size_t offset;
        const u_int16_t *addr;
        size_t count;
{
        volatile u_int16_t *d;

        d = (volatile u_int16_t *)(bsh + offset);
        while (count--)
                *d++ = *addr++;
        __asm__ volatile("eieio; sync");
d600 5
a604 5
        bus_space_tag_t tag;
        bus_space_handle_t bsh;
        bus_size_t offset;
        const u_int32_t *addr;
        size_t count;
d606 1
a606 1
        volatile u_int32_t *d;
d608 4
a611 4
        d = (volatile u_int32_t *)(bsh + offset);
        while (count--)
                *d++ = *addr++;
        __asm__ volatile("eieio; sync");
d614 2
a615 2
#define bus_space_write_region_stream_8                                              \
         !!! bus_space_write_region_stream_8 unimplemented !!!
d618 3
a620 3
 *      void bus_space_set_multi_N(bus_space_tag_t tag,
 *          bus_space_handle_t bsh, bus_size_t offset, u_intN_t val,
 *          size_t count);
d626 1
a626 1
        bus_space_handle_t, bus_size_t, u_int8_t, size_t);
d628 1
a628 1
        bus_space_handle_t, bus_size_t, u_int16_t, size_t);
d630 1
a630 1
        bus_space_handle_t, bus_size_t, u_int32_t, size_t);
d634 12
a645 12
        bus_space_tag_t tag;
        bus_space_handle_t bsh;
        bus_size_t offset;
        u_int8_t val;
        size_t count;
{
        volatile u_int8_t *d;

        d = (volatile u_int8_t *)(bsh + offset);
        while (count--)
                *d = val;
        __asm__ volatile("eieio; sync");
d650 13
a662 13
        bus_space_tag_t tag;
        bus_space_handle_t bsh;
        bus_size_t offset;
        u_int16_t val;
        size_t count;
{
        volatile u_int16_t *d;

        d = (volatile u_int16_t *)(bsh + offset);
        while (count--)
                __asm__ volatile("sthbrx %0, 0, %1" ::
                        "r"(val), "r"(d));
        __asm__ volatile("eieio; sync");
d667 13
a679 13
        bus_space_tag_t tag;
        bus_space_handle_t bsh;
        bus_size_t offset;
        u_int32_t val;
        size_t count;
{
        volatile u_int32_t *d;

        d = (volatile u_int32_t *)(bsh + offset);
        while (count--)
                __asm__ volatile("stwbrx %0, 0, %1" ::
                        "r"(val), "r"(d));
        __asm__ volatile("eieio; sync");
d685 3
a687 3
 *      void bus_space_set_multi_stream_N(bus_space_tag_t tag,
 *          bus_space_handle_t bsh, bus_size_t offset, u_intN_t val,
 *          size_t count);
d693 1
a693 1
        bus_space_handle_t, bus_size_t, u_int16_t, size_t);
d695 1
a695 1
        bus_space_handle_t, bus_size_t, u_int32_t, size_t);
d699 12
a710 12
        bus_space_tag_t tag;
        bus_space_handle_t bsh;
        bus_size_t offset;
        u_int16_t val;
        size_t count;
{
        volatile u_int16_t *d;

        d = (volatile u_int16_t *)(bsh + offset);
        while (count--)
                *d = val;
        __asm__ volatile("eieio; sync");
d715 5
a719 5
        bus_space_tag_t tag;
        bus_space_handle_t bsh;
        bus_size_t offset;
        u_int32_t val;
        size_t count;
d721 1
a721 1
        volatile u_int32_t *d;
d723 4
a726 4
        d = (volatile u_int32_t *)(bsh + offset);
        while (count--)
                *d = val;
        __asm__ volatile("eieio; sync");
d729 2
a730 2
#define bus_space_set_multi_stream_8                                              \
        !!! bus_space_set_multi_stream_8 unimplemented !!!
d733 3
a735 3
 *      void bus_space_set_region_N(bus_space_tag_t tag,
 *          bus_space_handle_t bsh, bus_size_t offset, u_intN_t val,
 *          size_t count);
d741 1
a741 1
        bus_space_handle_t, bus_size_t, u_int8_t, size_t);
d743 1
a743 1
        bus_space_handle_t, bus_size_t, u_int16_t, size_t);
d745 1
a745 1
        bus_space_handle_t, bus_size_t, u_int32_t, size_t);
d749 12
a760 12
        bus_space_tag_t tag;
        bus_space_handle_t bsh;
        bus_size_t offset;
        u_int8_t val;
        size_t count;
{
        volatile u_int8_t *d;

        d = (volatile u_int8_t *)(bsh + offset);
        while (count--)
                *d++ = val;
        __asm__ volatile("eieio; sync");
d765 13
a777 13
        bus_space_tag_t tag;
        bus_space_handle_t bsh;
        bus_size_t offset;
        u_int16_t val;
        size_t count;
{
        volatile u_int16_t *d;

        d = (volatile u_int16_t *)(bsh + offset);
        while (count--)
                __asm__ volatile("sthbrx %0, 0, %1" ::
                        "r"(val), "r"(d++));
        __asm__ volatile("eieio; sync");
d782 13
a794 13
        bus_space_tag_t tag;
        bus_space_handle_t bsh;
        bus_size_t offset;
        u_int32_t val;
        size_t count;
{
        volatile u_int32_t *d;

        d = (volatile u_int32_t *)(bsh + offset);
        while (count--)
                __asm__ volatile("stwbrx %0, 0, %1" ::
                        "r"(val), "r"(d++));
        __asm__ volatile("eieio; sync");
d800 3
a802 3
 *      void bus_space_set_region_stream_N(bus_space_tag_t tag,
 *          bus_space_handle_t bsh, bus_size_t offset, u_intN_t val,
 *          size_t count);
d808 1
a808 1
        bus_space_handle_t, bus_size_t, u_int16_t, size_t);
d810 1
a810 1
        bus_space_handle_t, bus_size_t, u_int32_t, size_t);
d815 12
a826 12
        bus_space_tag_t tag;
        bus_space_handle_t bsh;
        bus_size_t offset;
        u_int16_t val;
        size_t count;
{
        volatile u_int16_t *d;

        d = (volatile u_int16_t *)(bsh + offset);
        while (count--)
                *d++ = val;
        __asm__ volatile("eieio; sync");
d831 5
a835 5
        bus_space_tag_t tag;
        bus_space_handle_t bsh;
        bus_size_t offset;
        u_int32_t val;
        size_t count;
d837 1
a837 1
        volatile u_int32_t *d;
d839 4
a842 4
        d = (volatile u_int32_t *)(bsh + offset);
        while (count--)
                *d++ = val;
        __asm__ volatile("eieio; sync");
d845 2
a846 2
#define bus_space_set_region_stream_8                                              \
        !!! bus_space_set_region_stream_8 unimplemented !!!
d849 4
a852 4
 *      void bus_space_copy_region_N(bus_space_tag_t tag,
 *          bus_space_handle_t bsh1, bus_size_t off1,
 *          bus_space_handle_t bsh2, bus_size_t off2,
 *          size_t count);
d859 2
a860 2
        bus_space_handle_t, bus_size_t, bus_space_handle_t,
        bus_size_t, size_t);
d862 2
a863 2
        bus_space_handle_t, bus_size_t, bus_space_handle_t,
        bus_size_t, size_t);
d865 2
a866 2
        bus_space_handle_t, bus_size_t, bus_space_handle_t,
        bus_size_t, size_t);
d870 22
a891 22
        bus_space_tag_t t;
        bus_space_handle_t h1;
        bus_size_t o1;
        bus_space_handle_t h2;
        bus_size_t o2;
        size_t c;
{
        bus_addr_t addr1 = h1 + o1;
        bus_addr_t addr2 = h2 + o2;

        if (addr1 >= addr2) {
                /* src after dest: copy forward */
                for (; c != 0; c--, addr1++, addr2++)
                        *(volatile u_int8_t *)(addr2) =
                            *(volatile u_int8_t *)(addr1);
        } else {
                /* dest after src: copy backwards */
                for (addr1 += (c - 1), addr2 += (c - 1);
                    c != 0; c--, addr1--, addr2--)
                        *(volatile u_int8_t *)(addr2) =
                            *(volatile u_int8_t *)(addr1);
        }
d896 22
a917 22
        bus_space_tag_t t;
        bus_space_handle_t h1;
        bus_size_t o1;
        bus_space_handle_t h2;
        bus_size_t o2;
        size_t c;
{
        bus_addr_t addr1 = h1 + o1;
        bus_addr_t addr2 = h2 + o2;

        if (addr1 >= addr2) {
                /* src after dest: copy forward */
                for (; c != 0; c--, addr1 += 2, addr2 += 2)
                        *(volatile u_int16_t *)(addr2) =
                            *(volatile u_int16_t *)(addr1);
        } else {
                /* dest after src: copy backwards */
                for (addr1 += 2 * (c - 1), addr2 += 2 * (c - 1);
                    c != 0; c--, addr1 -= 2, addr2 -= 2)
                        *(volatile u_int16_t *)(addr2) =
                            *(volatile u_int16_t *)(addr1);
        }
d922 22
a943 22
        bus_space_tag_t t;
        bus_space_handle_t h1;
        bus_size_t o1;
        bus_space_handle_t h2;
        bus_size_t o2;
        size_t c;
{
        bus_addr_t addr1 = h1 + o1;
        bus_addr_t addr2 = h2 + o2;

        if (addr1 >= addr2) {
                /* src after dest: copy forward */
                for (; c != 0; c--, addr1 += 4, addr2 += 4)
                        *(volatile u_int32_t *)(addr2) =
                            *(volatile u_int32_t *)(addr1);
        } else {
                /* dest after src: copy backwards */
                for (addr1 += 4 * (c - 1), addr2 += 4 * (c - 1);
                    c != 0; c--, addr1 -= 4, addr2 -= 4)
                        *(volatile u_int32_t *)(addr2) =
                            *(volatile u_int32_t *)(addr1);
        }
d946 1
a946 1
#define bus_space_copy_region_8        !!! bus_space_copy_region_8 unimplemented !!!
d951 3
a953 3
 *      void bus_space_barrier(bus_space_tag_t tag,
 *          bus_space_handle_t bsh, bus_size_t offset,
 *          bus_size_t len, int flags);
d956 4
a959 4
#define bus_space_barrier(t, h, o, l, f)        \
        ((void)((void)(t), (void)(h), (void)(o), (void)(l), (void)(f)))
#define BUS_SPACE_BARRIER_READ        0x01                /* force read barrier */
#define BUS_SPACE_BARRIER_WRITE        0x02                /* force write barrier */
d970 12
a981 9
#define BUS_DMA_WAITOK                0x00        /* safe to sleep (pseudo-flag) */
#define BUS_DMA_NOWAIT                0x01        /* not safe to sleep */
#define BUS_DMA_ALLOCNOW        0x02        /* perform resource allocation now */
#define BUS_DMA_COHERENT        0x04        /* hint: map memory DMA coherent */
#define BUS_DMA_STREAMING        0x08        /* hint: sequential, unidirectional */
#define BUS_DMA_BUS1                0x10        /* placeholders for bus functions... */
#define BUS_DMA_BUS2                0x20
#define BUS_DMA_BUS3                0x40
#define BUS_DMA_BUS4                0x80
d992 2
a993 2
typedef struct powerpc_bus_dma_tag              *bus_dma_tag_t;
typedef struct powerpc_bus_dmamap               *bus_dmamap_t;
d996 1
a996 1
 *      bus_dma_segment_t
d998 2
a999 2
 *      Describes a single contiguous DMA transaction.  Values
 *      are suitable for programming into DMA registers.
d1002 2
a1003 2
        bus_addr_t        ds_addr;        /* DMA address */
        bus_size_t        ds_len;                /* length of transfer */
d1008 1
a1008 1
 *      bus_dma_tag_t
d1010 2
a1011 2
 *      A machine-dependent opaque type describing the implementation of
 *      DMA for a given bus.
d1015 25
a1039 25
        /*
         * The `bounce threshold' is checked while we are loading
         * the DMA map.  If the physical address of the segment
         * exceeds the threshold, an error will be returned.  The
         * caller can then take whatever action is necessary to
         * bounce the transfer.  If this value is 0, it will be
         * ignored.
         */
        bus_addr_t _bounce_thresh;

        /*
         * DMA mapping methods.
         */
        int        (*_dmamap_create)(bus_dma_tag_t, bus_size_t, int,
                    bus_size_t, bus_size_t, int, bus_dmamap_t *);
        void        (*_dmamap_destroy)(bus_dma_tag_t, bus_dmamap_t);
        int        (*_dmamap_load)(bus_dma_tag_t, bus_dmamap_t, void *,
                    bus_size_t, struct proc *, int);
        int        (*_dmamap_load_mbuf)(bus_dma_tag_t, bus_dmamap_t,
                    struct mbuf *, int);
        int        (*_dmamap_load_uio)(bus_dma_tag_t, bus_dmamap_t,
                    struct uio *, int);
        int        (*_dmamap_load_raw)(bus_dma_tag_t, bus_dmamap_t,
                    bus_dma_segment_t *, int, bus_size_t, int);
        void        (*_dmamap_unload)(bus_dma_tag_t, bus_dmamap_t);
d1042 1
a1042 1
        
d1044 11
a1054 11
         * DMA memory utility functions.
         */
        int        (*_dmamem_alloc)(bus_dma_tag_t, bus_size_t, bus_size_t,
                    bus_size_t, bus_dma_segment_t *, int, int *, int);
        void        (*_dmamem_free)(bus_dma_tag_t,
                    bus_dma_segment_t *, int);
        int        (*_dmamem_map)(bus_dma_tag_t, bus_dma_segment_t *,
                    int, size_t, caddr_t *, int);
        void        (*_dmamem_unmap)(bus_dma_tag_t, caddr_t, size_t);
        paddr_t        (*_dmamem_mmap)(bus_dma_tag_t, bus_dma_segment_t *,
                    int, off_t, int, int);
d1057 14
a1070 14
#define bus_dmamap_create(t, s, n, m, b, f, p)                        \
        (*(t)->_dmamap_create)((t), (s), (n), (m), (b), (f), (p))
#define bus_dmamap_destroy(t, p)                                \
        (*(t)->_dmamap_destroy)((t), (p))
#define bus_dmamap_load(t, m, b, s, p, f)                        \
        (*(t)->_dmamap_load)((t), (m), (b), (s), (p), (f))
#define bus_dmamap_load_mbuf(t, m, b, f)                        \
        (*(t)->_dmamap_load_mbuf)((t), (m), (b), (f))
#define bus_dmamap_load_uio(t, m, u, f)                                \
        (*(t)->_dmamap_load_uio)((t), (m), (u), (f))
#define bus_dmamap_load_raw(t, m, sg, n, s, f)                        \
        (*(t)->_dmamap_load_raw)((t), (m), (sg), (n), (s), (f))
#define bus_dmamap_unload(t, p)                                        \
        (*(t)->_dmamap_unload)((t), (p))
d1075 10
a1084 10
#define bus_dmamem_alloc(t, s, a, b, sg, n, r, f)                \
        (*(t)->_dmamem_alloc)((t), (s), (a), (b), (sg), (n), (r), (f))
#define bus_dmamem_free(t, sg, n)                                \
        (*(t)->_dmamem_free)((t), (sg), (n))
#define bus_dmamem_map(t, sg, n, s, k, f)                        \
        (*(t)->_dmamem_map)((t), (sg), (n), (s), (k), (f))
#define bus_dmamem_unmap(t, k, s)                                \
        (*(t)->_dmamem_unmap)((t), (k), (s))
#define bus_dmamem_mmap(t, sg, n, o, p, f)                        \
        (*(t)->_dmamem_mmap)((t), (sg), (n), (o), (p), (f))
d1087 1
a1087 1
 *      bus_dmamap_t
d1089 1
a1089 1
 *      Describes a DMA mapping.
d1092 18
a1109 18
        /*
         * PRIVATE MEMBERS: not for use my machine-independent code.
         */
        bus_size_t        _dm_size;        /* largest DMA transfer mappable */
        int                _dm_segcnt;        /* number of segs this map can map */
        bus_size_t        _dm_maxsegsz;        /* largest possible segment */
        bus_size_t        _dm_boundary;        /* don't cross this */
        bus_addr_t        _dm_bounce_thresh; /* bounce threshold; see tag */
        int                _dm_flags;        /* misc. flags */

        void                *_dm_cookie;        /* cookie for bus-specific functions */

        /*
         * PUBLIC MEMBERS: these are used by machine-independent code.
         */
        bus_size_t        dm_mapsize;        /* size of the mapping */
        int                dm_nsegs;        /* # valid segments in mapping */
        bus_dma_segment_t dm_segs[1];        /* segments; variable length */
d1113 12
a1124 12
int     _bus_dmamap_create(bus_dma_tag_t, bus_size_t, int, bus_size_t,
            bus_size_t, int, bus_dmamap_t *);
void    _bus_dmamap_destroy(bus_dma_tag_t, bus_dmamap_t);
int     _bus_dmamap_load(bus_dma_tag_t, bus_dmamap_t, void *,
            bus_size_t, struct proc *, int);
int     _bus_dmamap_load_mbuf(bus_dma_tag_t, bus_dmamap_t,
            struct mbuf *, int);
int     _bus_dmamap_load_uio(bus_dma_tag_t, bus_dmamap_t,
            struct uio *, int);
int     _bus_dmamap_load_raw(bus_dma_tag_t, bus_dmamap_t,
            bus_dma_segment_t *, int, bus_size_t, int);
void    _bus_dmamap_unload(bus_dma_tag_t, bus_dmamap_t);
d1128 9
a1136 9
int     _bus_dmamem_alloc(bus_dma_tag_t tag, bus_size_t size,
            bus_size_t alignment, bus_size_t boundary,
            bus_dma_segment_t *segs, int nsegs, int *rsegs, int flags);
void    _bus_dmamem_free(bus_dma_tag_t tag, bus_dma_segment_t *segs,
            int nsegs);
int     _bus_dmamem_map(bus_dma_tag_t tag, bus_dma_segment_t *segs,
            int nsegs, size_t size, caddr_t *kvap, int flags);
void    _bus_dmamem_unmap(bus_dma_tag_t tag, caddr_t kva,
            size_t size);
d1138 1
a1138 1
            int nsegs, off_t off, int prot, int flags);
d1140 4
a1143 4
int     _bus_dmamem_alloc_range(bus_dma_tag_t tag, bus_size_t size,
            bus_size_t alignment, bus_size_t boundary,
            bus_dma_segment_t *segs, int nsegs, int *rsegs, int flags,
            paddr_t low, paddr_t high);
@


1.4
log
@First round of __P removal in sys
@
text
@d2 1
a2 1
/*      $OpenBSD: bus_mi.h,v 1.3 2001/11/05 17:25:58 art Exp $        */
d258 2
a259 2
        CAT3(ins,m,rb)((volatile CAT3(u_int,m,_t) *)(bsh + (offset)),              \
            (CAT3(u_int,m,_t) *)addr, (size_t)count);                              \
d267 1
d300 1
d350 2
a351 2
        CAT3(outs,m,rb)((volatile CAT3(u_int,m,_t) *)(bsh + (offset)),              \
            (CAT3(u_int,m,_t) *)addr, (size_t)count);                              \
d359 1
d383 1
@


1.3
log
@Switch everything to the new bus_dmamap_sync API.
Most work by Wilbern Cobb <vedge@@csoft.org> with some fixes from me, mickey@@
and drahn@@.
@
text
@d2 1
a2 1
/*      $OpenBSD: bus_mi.h,v 1.2 2001/09/23 01:42:38 miod Exp $        */
d122 5
a126 5
        int (*pbs_map) __P((bus_space_tag_t, bus_addr_t, bus_size_t, int,
            bus_space_handle_t *));
        void (*pbs_unmap) __P((bus_space_tag_t, bus_space_handle_t,
            bus_size_t));
        int (*pbs_alloc) __P((bus_space_tag_t, bus_addr_t, bus_addr_t,
d128 2
a129 2
            bus_space_handle_t *));
        void (*pbs_free) __P((bus_space_tag_t, bus_space_handle_t, bus_size_t));
d151 2
a152 2
 *      int bus_space_map  __P((bus_space_tag_t t, bus_addr_t addr,
 *          bus_size_t size, int flags, bus_space_handle_t *bshp));
d161 2
a162 2
 *      int bus_space_unmap __P((bus_space_tag_t t,
 *          bus_space_handle_t bsh, bus_size_t size));
d171 1
a171 1
 *      int bus_space_subregion __P((bus_space_tag_t t,
d173 1
a173 1
 *          bus_space_handle_t *nbshp));
d182 1
a182 1
 *      int bus_space_alloc __P((bus_space_tag_t t, bus_addr_t rstart,
d185 1
a185 1
 *          bus_space_handle_t *bshp));
d194 2
a195 2
 *      int bus_space_free __P((bus_space_tag_t t,
 *          bus_space_handle_t bsh, bus_size_t size));
d204 2
a205 2
 *      u_intN_t bus_space_read_N __P((bus_space_tag_t tag,
 *          bus_space_handle_t bsh, bus_size_t offset));
d225 2
a226 2
 *      u_intN_t bus_space_read_stream_N __P((bus_space_tag_t tag,
 *          bus_space_handle_t bsh, bus_size_t offset));
d245 1
a245 1
 *      void bus_space_read_multi_N __P((bus_space_tag_t tag,
d247 1
a247 1
 *          u_intN_t *addr, size_t count));
d268 1
a268 1
 *      void bus_space_read_multi_stream_N __P((bus_space_tag_t tag,
d270 1
a270 1
 *          u_intN_t *addr, size_t count));
d292 1
a292 1
 *      void bus_space_write_N __P((bus_space_tag_t tag,
d294 1
a294 1
 *          u_intN_t value));
d314 1
a314 1
 *      void bus_space_write_stream_N __P((bus_space_tag_t tag,
d316 1
a316 1
 *          u_intN_t value));
d335 1
a335 1
 *      void bus_space_write_multi_N __P((bus_space_tag_t tag,
d337 1
a337 1
 *          const u_intN_t *addr, size_t count));
d358 1
a358 1
 *      void bus_space_write_multi_stream_N __P((bus_space_tag_t tag,
d360 1
a360 1
 *          const u_intN_t *addr, size_t count));
d382 1
a382 1
 *      void bus_space_read_region_N __P((bus_space_tag_t tag,
d384 1
a384 1
 *          u_intN_t *addr, size_t count));
d390 6
a395 6
static __inline void bus_space_read_region_1 __P((bus_space_tag_t,
        bus_space_handle_t, bus_size_t, u_int8_t *, size_t));
static __inline void bus_space_read_region_2 __P((bus_space_tag_t,
        bus_space_handle_t, bus_size_t, u_int16_t *, size_t));
static __inline void bus_space_read_region_4 __P((bus_space_tag_t,
        bus_space_handle_t, bus_size_t, u_int32_t *, size_t));
d450 1
a450 1
 *      void bus_space_read_region_stream_N __P((bus_space_tag_t tag,
d452 1
a452 1
 *          u_intN_t *addr, size_t count));
d458 4
a461 4
static __inline void bus_space_read_region_stream_2 __P((bus_space_tag_t,
        bus_space_handle_t, bus_size_t, u_int16_t *, size_t));
static __inline void bus_space_read_region_stream_4 __P((bus_space_tag_t,
        bus_space_handle_t, bus_size_t, u_int32_t *, size_t));
d499 1
a499 1
 *      void bus_space_write_region_N __P((bus_space_tag_t tag,
d501 1
a501 1
 *          const u_intN_t *addr, size_t count));
d506 6
a511 6
static __inline void bus_space_write_region_1 __P((bus_space_tag_t,
        bus_space_handle_t, bus_size_t, const u_int8_t *, size_t));
static __inline void bus_space_write_region_2 __P((bus_space_tag_t,
        bus_space_handle_t, bus_size_t, const u_int16_t *, size_t));
static __inline void bus_space_write_region_4 __P((bus_space_tag_t,
        bus_space_handle_t, bus_size_t, const u_int32_t *, size_t));
d566 1
a566 1
 *      void bus_space_write_region_stream_N __P((bus_space_tag_t tag,
d568 1
a568 1
 *          const u_intN_t *addr, size_t count));
d573 4
a576 4
static __inline void bus_space_write_region_stream_2 __P((bus_space_tag_t,
        bus_space_handle_t, bus_size_t, const u_int16_t *, size_t));
static __inline void bus_space_write_region_stream_4 __P((bus_space_tag_t,
        bus_space_handle_t, bus_size_t, const u_int32_t *, size_t));
d614 1
a614 1
 *      void bus_space_set_multi_N __P((bus_space_tag_t tag,
d616 1
a616 1
 *          size_t count));
d621 6
a626 6
static __inline void bus_space_set_multi_1 __P((bus_space_tag_t,
        bus_space_handle_t, bus_size_t, u_int8_t, size_t));
static __inline void bus_space_set_multi_2 __P((bus_space_tag_t,
        bus_space_handle_t, bus_size_t, u_int16_t, size_t));
static __inline void bus_space_set_multi_4 __P((bus_space_tag_t,
        bus_space_handle_t, bus_size_t, u_int32_t, size_t));
d681 1
a681 1
 *      void bus_space_set_multi_stream_N __P((bus_space_tag_t tag,
d683 1
a683 1
 *          size_t count));
d688 4
a691 4
static __inline void bus_space_set_multi_stream_2 __P((bus_space_tag_t,
        bus_space_handle_t, bus_size_t, u_int16_t, size_t));
static __inline void bus_space_set_multi_stream_4 __P((bus_space_tag_t,
        bus_space_handle_t, bus_size_t, u_int32_t, size_t));
d729 1
a729 1
 *      void bus_space_set_region_N __P((bus_space_tag_t tag,
d731 1
a731 1
 *          size_t count));
d736 6
a741 6
static __inline void bus_space_set_region_1 __P((bus_space_tag_t,
        bus_space_handle_t, bus_size_t, u_int8_t, size_t));
static __inline void bus_space_set_region_2 __P((bus_space_tag_t,
        bus_space_handle_t, bus_size_t, u_int16_t, size_t));
static __inline void bus_space_set_region_4 __P((bus_space_tag_t,
        bus_space_handle_t, bus_size_t, u_int32_t, size_t));
d796 1
a796 1
 *      void bus_space_set_region_stream_N __P((bus_space_tag_t tag,
d798 1
a798 1
 *          size_t count));
d803 4
a806 4
static __inline void bus_space_set_region_stream_2 __P((bus_space_tag_t,
        bus_space_handle_t, bus_size_t, u_int16_t, size_t));
static __inline void bus_space_set_region_stream_4 __P((bus_space_tag_t,
        bus_space_handle_t, bus_size_t, u_int32_t, size_t));
d845 1
a845 1
 *      void bus_space_copy_region_N __P((bus_space_tag_t tag,
d848 1
a848 1
 *          size_t count));
d854 1
a854 1
static __inline void bus_space_copy_region_1 __P((bus_space_tag_t,
d856 2
a857 2
        bus_size_t, size_t));
static __inline void bus_space_copy_region_2 __P((bus_space_tag_t,
d859 2
a860 2
        bus_size_t, size_t));
static __inline void bus_space_copy_region_4 __P((bus_space_tag_t,
d862 1
a862 1
        bus_size_t, size_t));
d947 1
a947 1
 *      void bus_space_barrier __P((bus_space_tag_t tag,
d949 1
a949 1
 *          bus_size_t len, int flags));
d1021 14
a1034 14
        int        (*_dmamap_create) __P((bus_dma_tag_t, bus_size_t, int,
                    bus_size_t, bus_size_t, int, bus_dmamap_t *));
        void        (*_dmamap_destroy) __P((bus_dma_tag_t, bus_dmamap_t));
        int        (*_dmamap_load) __P((bus_dma_tag_t, bus_dmamap_t, void *,
                    bus_size_t, struct proc *, int));
        int        (*_dmamap_load_mbuf) __P((bus_dma_tag_t, bus_dmamap_t,
                    struct mbuf *, int));
        int        (*_dmamap_load_uio) __P((bus_dma_tag_t, bus_dmamap_t,
                    struct uio *, int));
        int        (*_dmamap_load_raw) __P((bus_dma_tag_t, bus_dmamap_t,
                    bus_dma_segment_t *, int, bus_size_t, int));
        void        (*_dmamap_unload) __P((bus_dma_tag_t, bus_dmamap_t));
	void	    (*_dmamap_sync) __P((bus_dma_tag_t, bus_dmamap_t,
		    bus_addr_t, bus_size_t, int));
d1039 9
a1047 9
        int        (*_dmamem_alloc) __P((bus_dma_tag_t, bus_size_t, bus_size_t,
                    bus_size_t, bus_dma_segment_t *, int, int *, int));
        void        (*_dmamem_free) __P((bus_dma_tag_t,
                    bus_dma_segment_t *, int));
        int        (*_dmamem_map) __P((bus_dma_tag_t, bus_dma_segment_t *,
                    int, size_t, caddr_t *, int));
        void        (*_dmamem_unmap) __P((bus_dma_tag_t, caddr_t, size_t));
        paddr_t        (*_dmamem_mmap) __P((bus_dma_tag_t, bus_dma_segment_t *,
                    int, off_t, int, int));
d1106 14
a1119 14
int     _bus_dmamap_create __P((bus_dma_tag_t, bus_size_t, int, bus_size_t,
            bus_size_t, int, bus_dmamap_t *));
void    _bus_dmamap_destroy __P((bus_dma_tag_t, bus_dmamap_t));
int     _bus_dmamap_load __P((bus_dma_tag_t, bus_dmamap_t, void *,
            bus_size_t, struct proc *, int));
int     _bus_dmamap_load_mbuf __P((bus_dma_tag_t, bus_dmamap_t,
            struct mbuf *, int));
int     _bus_dmamap_load_uio __P((bus_dma_tag_t, bus_dmamap_t,
            struct uio *, int));
int     _bus_dmamap_load_raw __P((bus_dma_tag_t, bus_dmamap_t,
            bus_dma_segment_t *, int, bus_size_t, int));
void    _bus_dmamap_unload __P((bus_dma_tag_t, bus_dmamap_t));
void	_bus_dmamap_sync __P((bus_dma_tag_t, bus_dmamap_t, bus_addr_t,
	    bus_size_t, int));
d1121 1
a1121 1
int     _bus_dmamem_alloc __P((bus_dma_tag_t tag, bus_size_t size,
d1123 9
a1131 9
            bus_dma_segment_t *segs, int nsegs, int *rsegs, int flags));
void    _bus_dmamem_free __P((bus_dma_tag_t tag, bus_dma_segment_t *segs,
            int nsegs));
int     _bus_dmamem_map __P((bus_dma_tag_t tag, bus_dma_segment_t *segs,
            int nsegs, size_t size, caddr_t *kvap, int flags));
void    _bus_dmamem_unmap __P((bus_dma_tag_t tag, caddr_t kva,
            size_t size));
paddr_t _bus_dmamem_mmap __P((bus_dma_tag_t tag, bus_dma_segment_t *segs,
            int nsegs, off_t off, int prot, int flags));
d1133 1
a1133 1
int     _bus_dmamem_alloc_range __P((bus_dma_tag_t tag, bus_size_t size,
d1136 1
a1136 1
            paddr_t low, paddr_t high));
@


1.3.2.1
log
@Sync UBC branch to -current
@
text
@d2 1
a2 1
/*      $OpenBSD: bus_mi.h,v 1.3 2001/11/05 17:25:58 art Exp $        */
d122 5
a126 5
        int (*pbs_map)(bus_space_tag_t, bus_addr_t, bus_size_t, int,
            bus_space_handle_t *);
        void (*pbs_unmap)(bus_space_tag_t, bus_space_handle_t,
            bus_size_t);
        int (*pbs_alloc)(bus_space_tag_t, bus_addr_t, bus_addr_t,
d128 2
a129 2
            bus_space_handle_t *);
        void (*pbs_free)(bus_space_tag_t, bus_space_handle_t, bus_size_t);
d151 2
a152 2
 *      int bus_space_map(bus_space_tag_t t, bus_addr_t addr,
 *          bus_size_t size, int flags, bus_space_handle_t *bshp);
d161 2
a162 2
 *      int bus_space_unmap(bus_space_tag_t t,
 *          bus_space_handle_t bsh, bus_size_t size);
d171 1
a171 1
 *      int bus_space_subregion(bus_space_tag_t t,
d173 1
a173 1
 *          bus_space_handle_t *nbshp);
d182 1
a182 1
 *      int bus_space_alloc(bus_space_tag_t t, bus_addr_t rstart,
d185 1
a185 1
 *          bus_space_handle_t *bshp);
d194 2
a195 2
 *      int bus_space_free(bus_space_tag_t t,
 *          bus_space_handle_t bsh, bus_size_t size);
d204 2
a205 2
 *      u_intN_t bus_space_read_N(bus_space_tag_t tag,
 *          bus_space_handle_t bsh, bus_size_t offset);
d225 2
a226 2
 *      u_intN_t bus_space_read_stream_N(bus_space_tag_t tag,
 *          bus_space_handle_t bsh, bus_size_t offset);
d245 1
a245 1
 *      void bus_space_read_multi_N(bus_space_tag_t tag,
d247 1
a247 1
 *          u_intN_t *addr, size_t count);
d258 2
a259 2
	while (count--)							      \
		*addr++ = CAT(bus_space_read_,n)(tag, bsh, offset);	      \
a266 1
#if 0
d268 1
a268 1
 *      void bus_space_read_multi_stream_N(bus_space_tag_t tag,
d270 1
a270 1
 *          u_intN_t *addr, size_t count);
d292 1
a292 1
 *      void bus_space_write_N(bus_space_tag_t tag,
d294 1
a294 1
 *          u_intN_t value);
a298 1
#endif
d314 1
a314 1
 *      void bus_space_write_stream_N(bus_space_tag_t tag,
d316 1
a316 1
 *          u_intN_t value);
d335 1
a335 1
 *      void bus_space_write_multi_N(bus_space_tag_t tag,
d337 1
a337 1
 *          const u_intN_t *addr, size_t count);
d348 2
a349 2
	while (count--)							      \
		CAT(bus_space_write_,n)(tag, bsh, offset, *addr++);	      \
a356 1
#if 0
d358 1
a358 1
 *      void bus_space_write_multi_stream_N(bus_space_tag_t tag,
d360 1
a360 1
 *          const u_intN_t *addr, size_t count);
a379 1
#endif
d382 1
a382 1
 *      void bus_space_read_region_N(bus_space_tag_t tag,
d384 1
a384 1
 *          u_intN_t *addr, size_t count);
d390 6
a395 6
static __inline void bus_space_read_region_1(bus_space_tag_t,
        bus_space_handle_t, bus_size_t, u_int8_t *, size_t);
static __inline void bus_space_read_region_2(bus_space_tag_t,
        bus_space_handle_t, bus_size_t, u_int16_t *, size_t);
static __inline void bus_space_read_region_4(bus_space_tag_t,
        bus_space_handle_t, bus_size_t, u_int32_t *, size_t);
d450 1
a450 1
 *      void bus_space_read_region_stream_N(bus_space_tag_t tag,
d452 1
a452 1
 *          u_intN_t *addr, size_t count);
d458 4
a461 4
static __inline void bus_space_read_region_stream_2(bus_space_tag_t,
        bus_space_handle_t, bus_size_t, u_int16_t *, size_t);
static __inline void bus_space_read_region_stream_4(bus_space_tag_t,
        bus_space_handle_t, bus_size_t, u_int32_t *, size_t);
d499 1
a499 1
 *      void bus_space_write_region_N(bus_space_tag_t tag,
d501 1
a501 1
 *          const u_intN_t *addr, size_t count);
d506 6
a511 6
static __inline void bus_space_write_region_1(bus_space_tag_t,
        bus_space_handle_t, bus_size_t, const u_int8_t *, size_t);
static __inline void bus_space_write_region_2(bus_space_tag_t,
        bus_space_handle_t, bus_size_t, const u_int16_t *, size_t);
static __inline void bus_space_write_region_4(bus_space_tag_t,
        bus_space_handle_t, bus_size_t, const u_int32_t *, size_t);
d566 1
a566 1
 *      void bus_space_write_region_stream_N(bus_space_tag_t tag,
d568 1
a568 1
 *          const u_intN_t *addr, size_t count);
d573 4
a576 4
static __inline void bus_space_write_region_stream_2(bus_space_tag_t,
        bus_space_handle_t, bus_size_t, const u_int16_t *, size_t);
static __inline void bus_space_write_region_stream_4(bus_space_tag_t,
        bus_space_handle_t, bus_size_t, const u_int32_t *, size_t);
d614 1
a614 1
 *      void bus_space_set_multi_N(bus_space_tag_t tag,
d616 1
a616 1
 *          size_t count);
d621 6
a626 6
static __inline void bus_space_set_multi_1(bus_space_tag_t,
        bus_space_handle_t, bus_size_t, u_int8_t, size_t);
static __inline void bus_space_set_multi_2(bus_space_tag_t,
        bus_space_handle_t, bus_size_t, u_int16_t, size_t);
static __inline void bus_space_set_multi_4(bus_space_tag_t,
        bus_space_handle_t, bus_size_t, u_int32_t, size_t);
d681 1
a681 1
 *      void bus_space_set_multi_stream_N(bus_space_tag_t tag,
d683 1
a683 1
 *          size_t count);
d688 4
a691 4
static __inline void bus_space_set_multi_stream_2(bus_space_tag_t,
        bus_space_handle_t, bus_size_t, u_int16_t, size_t);
static __inline void bus_space_set_multi_stream_4(bus_space_tag_t,
        bus_space_handle_t, bus_size_t, u_int32_t, size_t);
d729 1
a729 1
 *      void bus_space_set_region_N(bus_space_tag_t tag,
d731 1
a731 1
 *          size_t count);
d736 6
a741 6
static __inline void bus_space_set_region_1(bus_space_tag_t,
        bus_space_handle_t, bus_size_t, u_int8_t, size_t);
static __inline void bus_space_set_region_2(bus_space_tag_t,
        bus_space_handle_t, bus_size_t, u_int16_t, size_t);
static __inline void bus_space_set_region_4(bus_space_tag_t,
        bus_space_handle_t, bus_size_t, u_int32_t, size_t);
d796 1
a796 1
 *      void bus_space_set_region_stream_N(bus_space_tag_t tag,
d798 1
a798 1
 *          size_t count);
d803 4
a806 4
static __inline void bus_space_set_region_stream_2(bus_space_tag_t,
        bus_space_handle_t, bus_size_t, u_int16_t, size_t);
static __inline void bus_space_set_region_stream_4(bus_space_tag_t,
        bus_space_handle_t, bus_size_t, u_int32_t, size_t);
d845 1
a845 1
 *      void bus_space_copy_region_N(bus_space_tag_t tag,
d848 1
a848 1
 *          size_t count);
d854 1
a854 1
static __inline void bus_space_copy_region_1(bus_space_tag_t,
d856 2
a857 2
        bus_size_t, size_t);
static __inline void bus_space_copy_region_2(bus_space_tag_t,
d859 2
a860 2
        bus_size_t, size_t);
static __inline void bus_space_copy_region_4(bus_space_tag_t,
d862 1
a862 1
        bus_size_t, size_t);
d947 1
a947 1
 *      void bus_space_barrier(bus_space_tag_t tag,
d949 1
a949 1
 *          bus_size_t len, int flags);
d1021 14
a1034 14
        int        (*_dmamap_create)(bus_dma_tag_t, bus_size_t, int,
                    bus_size_t, bus_size_t, int, bus_dmamap_t *);
        void        (*_dmamap_destroy)(bus_dma_tag_t, bus_dmamap_t);
        int        (*_dmamap_load)(bus_dma_tag_t, bus_dmamap_t, void *,
                    bus_size_t, struct proc *, int);
        int        (*_dmamap_load_mbuf)(bus_dma_tag_t, bus_dmamap_t,
                    struct mbuf *, int);
        int        (*_dmamap_load_uio)(bus_dma_tag_t, bus_dmamap_t,
                    struct uio *, int);
        int        (*_dmamap_load_raw)(bus_dma_tag_t, bus_dmamap_t,
                    bus_dma_segment_t *, int, bus_size_t, int);
        void        (*_dmamap_unload)(bus_dma_tag_t, bus_dmamap_t);
	void	    (*_dmamap_sync)(bus_dma_tag_t, bus_dmamap_t,
		    bus_addr_t, bus_size_t, int);
d1039 9
a1047 9
        int        (*_dmamem_alloc)(bus_dma_tag_t, bus_size_t, bus_size_t,
                    bus_size_t, bus_dma_segment_t *, int, int *, int);
        void        (*_dmamem_free)(bus_dma_tag_t,
                    bus_dma_segment_t *, int);
        int        (*_dmamem_map)(bus_dma_tag_t, bus_dma_segment_t *,
                    int, size_t, caddr_t *, int);
        void        (*_dmamem_unmap)(bus_dma_tag_t, caddr_t, size_t);
        paddr_t        (*_dmamem_mmap)(bus_dma_tag_t, bus_dma_segment_t *,
                    int, off_t, int, int);
d1106 14
a1119 14
int     _bus_dmamap_create(bus_dma_tag_t, bus_size_t, int, bus_size_t,
            bus_size_t, int, bus_dmamap_t *);
void    _bus_dmamap_destroy(bus_dma_tag_t, bus_dmamap_t);
int     _bus_dmamap_load(bus_dma_tag_t, bus_dmamap_t, void *,
            bus_size_t, struct proc *, int);
int     _bus_dmamap_load_mbuf(bus_dma_tag_t, bus_dmamap_t,
            struct mbuf *, int);
int     _bus_dmamap_load_uio(bus_dma_tag_t, bus_dmamap_t,
            struct uio *, int);
int     _bus_dmamap_load_raw(bus_dma_tag_t, bus_dmamap_t,
            bus_dma_segment_t *, int, bus_size_t, int);
void    _bus_dmamap_unload(bus_dma_tag_t, bus_dmamap_t);
void	_bus_dmamap_sync(bus_dma_tag_t, bus_dmamap_t, bus_addr_t,
	    bus_size_t, int);
d1121 1
a1121 1
int     _bus_dmamem_alloc(bus_dma_tag_t tag, bus_size_t size,
d1123 9
a1131 9
            bus_dma_segment_t *segs, int nsegs, int *rsegs, int flags);
void    _bus_dmamem_free(bus_dma_tag_t tag, bus_dma_segment_t *segs,
            int nsegs);
int     _bus_dmamem_map(bus_dma_tag_t tag, bus_dma_segment_t *segs,
            int nsegs, size_t size, caddr_t *kvap, int flags);
void    _bus_dmamem_unmap(bus_dma_tag_t tag, caddr_t kva,
            size_t size);
paddr_t _bus_dmamem_mmap(bus_dma_tag_t tag, bus_dma_segment_t *segs,
            int nsegs, off_t off, int prot, int flags);
d1133 1
a1133 1
int     _bus_dmamem_alloc_range(bus_dma_tag_t tag, bus_size_t size,
d1136 1
a1136 1
            paddr_t low, paddr_t high);
@


1.2
log
@Worst abuse of C, ever.
@
text
@d2 1
a2 1
/*      $OpenBSD: bus_mi.h,v 1.1 2001/06/26 21:57:43 smurph Exp $        */
d980 4
a983 9
/*
 * Operations performed by bus_dmamap_sync().
 */
typedef enum {
	BUS_DMASYNC_PREREAD	= 0x01,	/* pre-read synchronization */
	BUS_DMASYNC_POSTREAD	= 0x02,	/* post-read synchronization */
	BUS_DMASYNC_PREWRITE	= 0x04,	/* pre-write synchronization */
	BUS_DMASYNC_POSTWRITE	= 0x08	/* post-write synchronization */
} bus_dmasync_op_t;
d1033 2
a1034 1
	void	    (*_dmamap_sync) __P((bus_dma_tag_t , bus_dmamap_t, bus_dmasync_op_t));
d1064 1
a1064 1
#define	bus_dmamap_sync(t, p, o)				\
d1066 1
a1066 1
	    (*(t)->_dmamap_sync)((t), (p), (o)) : (void)0)
d1118 2
a1119 1
void	_bus_dmamap_sync __P((bus_dma_tag_t, bus_dmamap_t, bus_dmasync_op_t));
@


1.1
log
@Initial import of mvmeppc.
@
text
@d2 1
a2 1
/*      $OpenBSD: bus.h,v 1.1 1997/10/13 10:53:42 pefo Exp $        */
a108 7
typedef enum {
	BUS_DMASYNC_POSTREAD,
	BUS_DMASYNC_POSTWRITE,
	BUS_DMASYNC_PREREAD,
	BUS_DMASYNC_PREWRITE
} bus_dmasync_op_t;

d983 6
a988 4
#define BUS_DMASYNC_PREREAD        0x01        /* pre-read synchronization */
#define BUS_DMASYNC_POSTREAD        0x02        /* post-read synchronization */
#define BUS_DMASYNC_PREWRITE        0x04        /* pre-write synchronization */
#define BUS_DMASYNC_POSTWRITE        0x08        /* post-write synchronization */
@


1.1.2.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d2 1
a2 1
/*      $OpenBSD: bus_mi.h,v 1.1 2001/06/26 21:57:43 smurph Exp $        */
d109 7
d990 4
a993 6
typedef enum {
	BUS_DMASYNC_PREREAD	= 0x01,	/* pre-read synchronization */
	BUS_DMASYNC_POSTREAD	= 0x02,	/* post-read synchronization */
	BUS_DMASYNC_PREWRITE	= 0x04,	/* pre-write synchronization */
	BUS_DMASYNC_POSTWRITE	= 0x08	/* post-write synchronization */
} bus_dmasync_op_t;
@


1.1.2.2
log
@Merge in -current
@
text
@d2 1
a2 1
/*      $OpenBSD$        */
d980 9
a988 4
#define BUS_DMASYNC_PREREAD	0x01
#define BUS_DMASYNC_POSTREAD	0x02
#define BUS_DMASYNC_PREWRITE	0x04
#define BUS_DMASYNC_POSTWRITE	0x08
d1038 1
a1038 2
	void	    (*_dmamap_sync) __P((bus_dma_tag_t, bus_dmamap_t,
		    bus_addr_t, bus_size_t, int));
d1068 1
a1068 1
#define	bus_dmamap_sync(t, p, a, l, o)				\
d1070 1
a1070 1
	    (*(t)->_dmamap_sync)((t), (p), (a), (l), (o)) : (void)0)
d1122 1
a1122 2
void	_bus_dmamap_sync __P((bus_dma_tag_t, bus_dmamap_t, bus_addr_t,
	    bus_size_t, int));
@


1.1.2.3
log
@Merge in -current from about a week ago
@
text
@d122 5
a126 5
        int (*pbs_map)(bus_space_tag_t, bus_addr_t, bus_size_t, int,
            bus_space_handle_t *);
        void (*pbs_unmap)(bus_space_tag_t, bus_space_handle_t,
            bus_size_t);
        int (*pbs_alloc)(bus_space_tag_t, bus_addr_t, bus_addr_t,
d128 2
a129 2
            bus_space_handle_t *);
        void (*pbs_free)(bus_space_tag_t, bus_space_handle_t, bus_size_t);
d151 2
a152 2
 *      int bus_space_map(bus_space_tag_t t, bus_addr_t addr,
 *          bus_size_t size, int flags, bus_space_handle_t *bshp);
d161 2
a162 2
 *      int bus_space_unmap(bus_space_tag_t t,
 *          bus_space_handle_t bsh, bus_size_t size);
d171 1
a171 1
 *      int bus_space_subregion(bus_space_tag_t t,
d173 1
a173 1
 *          bus_space_handle_t *nbshp);
d182 1
a182 1
 *      int bus_space_alloc(bus_space_tag_t t, bus_addr_t rstart,
d185 1
a185 1
 *          bus_space_handle_t *bshp);
d194 2
a195 2
 *      int bus_space_free(bus_space_tag_t t,
 *          bus_space_handle_t bsh, bus_size_t size);
d204 2
a205 2
 *      u_intN_t bus_space_read_N(bus_space_tag_t tag,
 *          bus_space_handle_t bsh, bus_size_t offset);
d225 2
a226 2
 *      u_intN_t bus_space_read_stream_N(bus_space_tag_t tag,
 *          bus_space_handle_t bsh, bus_size_t offset);
d245 1
a245 1
 *      void bus_space_read_multi_N(bus_space_tag_t tag,
d247 1
a247 1
 *          u_intN_t *addr, size_t count);
d268 1
a268 1
 *      void bus_space_read_multi_stream_N(bus_space_tag_t tag,
d270 1
a270 1
 *          u_intN_t *addr, size_t count);
d292 1
a292 1
 *      void bus_space_write_N(bus_space_tag_t tag,
d294 1
a294 1
 *          u_intN_t value);
d314 1
a314 1
 *      void bus_space_write_stream_N(bus_space_tag_t tag,
d316 1
a316 1
 *          u_intN_t value);
d335 1
a335 1
 *      void bus_space_write_multi_N(bus_space_tag_t tag,
d337 1
a337 1
 *          const u_intN_t *addr, size_t count);
d358 1
a358 1
 *      void bus_space_write_multi_stream_N(bus_space_tag_t tag,
d360 1
a360 1
 *          const u_intN_t *addr, size_t count);
d382 1
a382 1
 *      void bus_space_read_region_N(bus_space_tag_t tag,
d384 1
a384 1
 *          u_intN_t *addr, size_t count);
d390 6
a395 6
static __inline void bus_space_read_region_1(bus_space_tag_t,
        bus_space_handle_t, bus_size_t, u_int8_t *, size_t);
static __inline void bus_space_read_region_2(bus_space_tag_t,
        bus_space_handle_t, bus_size_t, u_int16_t *, size_t);
static __inline void bus_space_read_region_4(bus_space_tag_t,
        bus_space_handle_t, bus_size_t, u_int32_t *, size_t);
d450 1
a450 1
 *      void bus_space_read_region_stream_N(bus_space_tag_t tag,
d452 1
a452 1
 *          u_intN_t *addr, size_t count);
d458 4
a461 4
static __inline void bus_space_read_region_stream_2(bus_space_tag_t,
        bus_space_handle_t, bus_size_t, u_int16_t *, size_t);
static __inline void bus_space_read_region_stream_4(bus_space_tag_t,
        bus_space_handle_t, bus_size_t, u_int32_t *, size_t);
d499 1
a499 1
 *      void bus_space_write_region_N(bus_space_tag_t tag,
d501 1
a501 1
 *          const u_intN_t *addr, size_t count);
d506 6
a511 6
static __inline void bus_space_write_region_1(bus_space_tag_t,
        bus_space_handle_t, bus_size_t, const u_int8_t *, size_t);
static __inline void bus_space_write_region_2(bus_space_tag_t,
        bus_space_handle_t, bus_size_t, const u_int16_t *, size_t);
static __inline void bus_space_write_region_4(bus_space_tag_t,
        bus_space_handle_t, bus_size_t, const u_int32_t *, size_t);
d566 1
a566 1
 *      void bus_space_write_region_stream_N(bus_space_tag_t tag,
d568 1
a568 1
 *          const u_intN_t *addr, size_t count);
d573 4
a576 4
static __inline void bus_space_write_region_stream_2(bus_space_tag_t,
        bus_space_handle_t, bus_size_t, const u_int16_t *, size_t);
static __inline void bus_space_write_region_stream_4(bus_space_tag_t,
        bus_space_handle_t, bus_size_t, const u_int32_t *, size_t);
d614 1
a614 1
 *      void bus_space_set_multi_N(bus_space_tag_t tag,
d616 1
a616 1
 *          size_t count);
d621 6
a626 6
static __inline void bus_space_set_multi_1(bus_space_tag_t,
        bus_space_handle_t, bus_size_t, u_int8_t, size_t);
static __inline void bus_space_set_multi_2(bus_space_tag_t,
        bus_space_handle_t, bus_size_t, u_int16_t, size_t);
static __inline void bus_space_set_multi_4(bus_space_tag_t,
        bus_space_handle_t, bus_size_t, u_int32_t, size_t);
d681 1
a681 1
 *      void bus_space_set_multi_stream_N(bus_space_tag_t tag,
d683 1
a683 1
 *          size_t count);
d688 4
a691 4
static __inline void bus_space_set_multi_stream_2(bus_space_tag_t,
        bus_space_handle_t, bus_size_t, u_int16_t, size_t);
static __inline void bus_space_set_multi_stream_4(bus_space_tag_t,
        bus_space_handle_t, bus_size_t, u_int32_t, size_t);
d729 1
a729 1
 *      void bus_space_set_region_N(bus_space_tag_t tag,
d731 1
a731 1
 *          size_t count);
d736 6
a741 6
static __inline void bus_space_set_region_1(bus_space_tag_t,
        bus_space_handle_t, bus_size_t, u_int8_t, size_t);
static __inline void bus_space_set_region_2(bus_space_tag_t,
        bus_space_handle_t, bus_size_t, u_int16_t, size_t);
static __inline void bus_space_set_region_4(bus_space_tag_t,
        bus_space_handle_t, bus_size_t, u_int32_t, size_t);
d796 1
a796 1
 *      void bus_space_set_region_stream_N(bus_space_tag_t tag,
d798 1
a798 1
 *          size_t count);
d803 4
a806 4
static __inline void bus_space_set_region_stream_2(bus_space_tag_t,
        bus_space_handle_t, bus_size_t, u_int16_t, size_t);
static __inline void bus_space_set_region_stream_4(bus_space_tag_t,
        bus_space_handle_t, bus_size_t, u_int32_t, size_t);
d845 1
a845 1
 *      void bus_space_copy_region_N(bus_space_tag_t tag,
d848 1
a848 1
 *          size_t count);
d854 1
a854 1
static __inline void bus_space_copy_region_1(bus_space_tag_t,
d856 2
a857 2
        bus_size_t, size_t);
static __inline void bus_space_copy_region_2(bus_space_tag_t,
d859 2
a860 2
        bus_size_t, size_t);
static __inline void bus_space_copy_region_4(bus_space_tag_t,
d862 1
a862 1
        bus_size_t, size_t);
d947 1
a947 1
 *      void bus_space_barrier(bus_space_tag_t tag,
d949 1
a949 1
 *          bus_size_t len, int flags);
d1021 14
a1034 14
        int        (*_dmamap_create)(bus_dma_tag_t, bus_size_t, int,
                    bus_size_t, bus_size_t, int, bus_dmamap_t *);
        void        (*_dmamap_destroy)(bus_dma_tag_t, bus_dmamap_t);
        int        (*_dmamap_load)(bus_dma_tag_t, bus_dmamap_t, void *,
                    bus_size_t, struct proc *, int);
        int        (*_dmamap_load_mbuf)(bus_dma_tag_t, bus_dmamap_t,
                    struct mbuf *, int);
        int        (*_dmamap_load_uio)(bus_dma_tag_t, bus_dmamap_t,
                    struct uio *, int);
        int        (*_dmamap_load_raw)(bus_dma_tag_t, bus_dmamap_t,
                    bus_dma_segment_t *, int, bus_size_t, int);
        void        (*_dmamap_unload)(bus_dma_tag_t, bus_dmamap_t);
	void	    (*_dmamap_sync)(bus_dma_tag_t, bus_dmamap_t,
		    bus_addr_t, bus_size_t, int);
d1039 9
a1047 9
        int        (*_dmamem_alloc)(bus_dma_tag_t, bus_size_t, bus_size_t,
                    bus_size_t, bus_dma_segment_t *, int, int *, int);
        void        (*_dmamem_free)(bus_dma_tag_t,
                    bus_dma_segment_t *, int);
        int        (*_dmamem_map)(bus_dma_tag_t, bus_dma_segment_t *,
                    int, size_t, caddr_t *, int);
        void        (*_dmamem_unmap)(bus_dma_tag_t, caddr_t, size_t);
        paddr_t        (*_dmamem_mmap)(bus_dma_tag_t, bus_dma_segment_t *,
                    int, off_t, int, int);
d1106 14
a1119 14
int     _bus_dmamap_create(bus_dma_tag_t, bus_size_t, int, bus_size_t,
            bus_size_t, int, bus_dmamap_t *);
void    _bus_dmamap_destroy(bus_dma_tag_t, bus_dmamap_t);
int     _bus_dmamap_load(bus_dma_tag_t, bus_dmamap_t, void *,
            bus_size_t, struct proc *, int);
int     _bus_dmamap_load_mbuf(bus_dma_tag_t, bus_dmamap_t,
            struct mbuf *, int);
int     _bus_dmamap_load_uio(bus_dma_tag_t, bus_dmamap_t,
            struct uio *, int);
int     _bus_dmamap_load_raw(bus_dma_tag_t, bus_dmamap_t,
            bus_dma_segment_t *, int, bus_size_t, int);
void    _bus_dmamap_unload(bus_dma_tag_t, bus_dmamap_t);
void	_bus_dmamap_sync(bus_dma_tag_t, bus_dmamap_t, bus_addr_t,
	    bus_size_t, int);
d1121 1
a1121 1
int     _bus_dmamem_alloc(bus_dma_tag_t tag, bus_size_t size,
d1123 9
a1131 9
            bus_dma_segment_t *segs, int nsegs, int *rsegs, int flags);
void    _bus_dmamem_free(bus_dma_tag_t tag, bus_dma_segment_t *segs,
            int nsegs);
int     _bus_dmamem_map(bus_dma_tag_t tag, bus_dma_segment_t *segs,
            int nsegs, size_t size, caddr_t *kvap, int flags);
void    _bus_dmamem_unmap(bus_dma_tag_t tag, caddr_t kva,
            size_t size);
paddr_t _bus_dmamem_mmap(bus_dma_tag_t tag, bus_dma_segment_t *segs,
            int nsegs, off_t off, int prot, int flags);
d1133 1
a1133 1
int     _bus_dmamem_alloc_range(bus_dma_tag_t tag, bus_size_t size,
d1136 1
a1136 1
            paddr_t low, paddr_t high);
@


1.1.2.4
log
@Sync the SMP branch with 3.3
@
text
@d258 2
a259 2
	while (count--)							      \
		*addr++ = CAT(bus_space_read_,n)(tag, bsh, offset);	      \
a266 1
#if 0
a298 1
#endif
d348 2
a349 2
	while (count--)							      \
		CAT(bus_space_write_,n)(tag, bsh, offset, *addr++);	      \
a356 1
#if 0
a379 1
#endif
@


1.1.2.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 2
a2 2
/*	$NetBSD: bus.h,v 1.1 2001/06/06 17:37:37 matt Exp $	*/
/*	$OpenBSD$	*/
d22 2
a23 2
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
d56 2
a57 2
 *	This product includes software developed by Christopher G. Demetriou
 *	for the NetBSD Project.
d87 2
a88 2
 *	This product includes software developed by Christopher G. Demetriou
 *	for the NetBSD Project.
d118 12
a129 12
	u_int32_t pbs_type;
	bus_addr_t pbs_offset;
	bus_addr_t pbs_base;
	bus_addr_t pbs_limit;
	int (*pbs_map)(bus_space_tag_t, bus_addr_t, bus_size_t, int,
	    bus_space_handle_t *);
	void (*pbs_unmap)(bus_space_tag_t, bus_space_handle_t,
	    bus_size_t);
	int (*pbs_alloc)(bus_space_tag_t, bus_addr_t, bus_addr_t,
	    bus_size_t, bus_size_t align, bus_size_t, int, bus_addr_t *,
	    bus_space_handle_t *);
	void (*pbs_free)(bus_space_tag_t, bus_space_handle_t, bus_size_t);
d132 3
a134 3
#define BUS_SPACE_MAP_CACHEABLE		0x01
#define BUS_SPACE_MAP_LINEAR		0x02
#define BUS_SPACE_MAP_PREFETCHABLE	0x04
d137 2
a138 2
#define CAT(a,b)	a##b
#define CAT3(a,b,c)	a##b##c
d140 2
a141 2
#define CAT(a,b)	a/**/b
#define CAT3(a,b,c)	a/**/b/**/c
d151 2
a152 2
 *	int bus_space_map(bus_space_tag_t t, bus_addr_t addr,
 *	    bus_size_t size, int flags, bus_space_handle_t *bshp);
d157 1
a157 1
#define bus_space_map(t, a, s, f, hp)	\
d161 2
a162 2
 *	int bus_space_unmap(bus_space_tag_t t,
 *	    bus_space_handle_t bsh, bus_size_t size);
d167 1
a167 1
#define bus_space_unmap(t, h, s)					\
d171 3
a173 3
 *	int bus_space_subregion(bus_space_tag_t t,
 *	    bus_space_handle_t bsh, bus_size_t offset, bus_size_t size,
 *	    bus_space_handle_t *nbshp);
d178 1
a178 1
#define bus_space_subregion(t, h, o, s, hp)				\
d182 4
a185 4
 *	int bus_space_alloc(bus_space_tag_t t, bus_addr_t rstart,
 *	    bus_addr_t rend, bus_size_t size, bus_size_t align,
 *	    bus_size_t boundary, int flags, bus_addr_t *bpap,
 *	    bus_space_handle_t *bshp);
d190 1
a190 1
#define bus_space_alloc(t, rs, re, s, a, b, f, ap, hp)			\
d194 2
a195 2
 *	int bus_space_free(bus_space_tag_t t,
 *	    bus_space_handle_t bsh, bus_size_t size);
d200 1
a200 1
#define bus_space_free(t, h, s)						\
d204 2
a205 2
 *	u_intN_t bus_space_read_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset);
d211 6
a216 6
#define bus_space_read(n,m)						      \
static __inline CAT3(u_int,m,_t)					      \
CAT(bus_space_read_,n)(bus_space_tag_t tag, bus_space_handle_t bsh,	      \
    bus_size_t offset)							      \
{									      \
	return CAT3(in,m,rb)((volatile CAT3(u_int,m,_t) *)(bsh + (offset)));  \
d222 1
a222 1
#define bus_space_read_8	!!! bus_space_read_8 unimplemented !!!
d225 2
a226 2
 *	u_intN_t bus_space_read_stream_N(bus_space_tag_t tag,
 *	     bus_space_handle_t bsh, bus_size_t offset);
d232 2
a233 2
#define bus_space_read_stream(n,m)					      \
static __inline CAT3(u_int,m,_t)					      \
d235 3
a237 3
    bus_size_t offset)							      \
{									      \
	return CAT(in,m)((volatile CAT3(u_int,m,_t) *)(bsh + (offset)));      \
d242 1
a242 1
#define bus_space_read_stream_8	!!! bus_space_read_stream_8 unimplemented !!!
d245 3
a247 3
 *	void bus_space_read_multi_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset,
 *	    u_intN_t *addr, size_t count);
d253 7
a259 7
#define bus_space_read_multi(n,m)					     \
static __inline void							     \
CAT(bus_space_read_multi_,n)(bus_space_tag_t tag, bus_space_handle_t bsh,    \
     bus_size_t offset, CAT3(u_int,m,_t) *addr, size_t count)		     \
{									     \
	while (count--)							     \
		*addr++ = CAT(bus_space_read_,n)(tag, bsh, offset);	     \
d265 1
a265 1
#define bus_space_read_multi_8	!!! bus_space_read_multi_8 not implemented !!!
d269 3
a271 3
 *	void bus_space_read_multi_stream_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset,
 *	    u_intN_t *addr, size_t count);
d277 8
a284 8
#define bus_space_read_multi_stream(n,m)				      \
static __inline void							      \
CAT(bus_space_read_multi_stream_,n)(bus_space_tag_t tag,		      \
     bus_space_handle_t bsh,						      \
     bus_size_t offset, CAT3(u_int,m,_t) *addr, size_t count)		      \
{									      \
	CAT(ins,m)((volatile CAT3(u_int,m,_t) *)(bsh + (offset)),	      \
	    (CAT3(u_int,m,_t) *)addr, (size_t)count);			      \
d289 2
a290 2
#define bus_space_read_multi_stream_8					      \
	!!! bus_space_read_multi_stream_8 not implemented !!!
d294 2
a295 2
 *	  bus_space_handle_t bsh, bus_size_t offset,
 *	  u_intN_t value);
d302 6
a307 6
#define bus_space_write(n,m)						     \
static __inline void							     \
CAT(bus_space_write_,n)(bus_space_tag_t tag, bus_space_handle_t bsh,	     \
    bus_size_t offset, CAT3(u_int,m,_t) x)				     \
{									     \
	CAT3(out,m,rb)((volatile CAT3(u_int,m,_t) *)(bsh + (offset)), x);    \
d313 1
a313 1
#define bus_space_write_8	!!! bus_space_write_8 unimplemented !!!
d316 3
a318 3
 *	void bus_space_write_stream_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset,
 *	    u_intN_t value);
d324 2
a325 2
#define bus_space_write_stream(n,m)					      \
static __inline void							      \
d327 3
a329 3
    bus_size_t offset, CAT3(u_int,m,_t) x)				      \
{									      \
	CAT(out,m)((volatile CAT3(u_int,m,_t) *)(bsh + (offset)), x);	      \
d337 3
a339 3
 *	void bus_space_write_multi_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset,
 *	    const u_intN_t *addr, size_t count);
d345 2
a346 2
#define bus_space_write_multi(n,m)					      \
static __inline void							      \
d348 2
a349 2
    bus_size_t offset, const CAT3(u_int,m,_t) *addr, size_t count)	      \
{									      \
d357 1
a357 1
#define bus_space_write_multi_8	!!! bus_space_write_multi_8 not implemented !!!
d362 2
a363 2
 *	  bus_space_handle_t bsh, bus_size_t offset,
 *	  const u_intN_t *addr, size_t count);
d369 8
a376 8
#define bus_space_write_multi_stream(n,m)				     \
static __inline void							     \
CAT(bus_space_write_multi_stream_,n)(bus_space_tag_t tag,		     \
     bus_space_handle_t bsh,						     \
     bus_size_t offset, const CAT3(u_int,m,_t) *addr, size_t count)	     \
{									     \
	CAT(outs,m)((volatile CAT3(u_int,m,_t) *)(bsh + (offset)),	     \
	    (CAT3(u_int,m,_t) *)addr, (size_t)count);			     \
d381 2
a382 2
#define bus_space_write_multi_stream_8					     \
	!!! bus_space_write_multi_stream_8 not implemented !!!
d387 2
a388 2
 *	  bus_space_handle_t bsh, bus_size_t offset,
 *	  u_intN_t *addr, size_t count);
d395 1
a395 1
	bus_space_handle_t, bus_size_t, u_int8_t *, size_t);
d397 1
a397 1
	bus_space_handle_t, bus_size_t, u_int16_t *, size_t);
d399 1
a399 1
	bus_space_handle_t, bus_size_t, u_int32_t *, size_t);
d403 12
a414 12
	bus_space_tag_t tag;
	bus_space_handle_t bsh;
	bus_size_t offset;
	u_int8_t *addr;
	size_t count;
{
	volatile u_int8_t *s;

	s = (volatile u_int8_t *)(bsh + offset);
	while (count--)
		*addr++ = *s++;
	__asm__ volatile("eieio; sync");
d419 13
a431 13
	bus_space_tag_t tag;
	bus_space_handle_t bsh;
	bus_size_t offset;
	u_int16_t *addr;
	size_t count;
{
	volatile u_int16_t *s;

	s = (volatile u_int16_t *)(bsh + offset);
	while (count--)
		__asm__ volatile("lhbrx %0, 0, %1" :
			"=r"(*addr++) : "r"(s++));
	__asm__ volatile("eieio; sync");
d436 5
a440 5
	bus_space_tag_t tag;
	bus_space_handle_t bsh;
	bus_size_t offset;
	u_int32_t *addr;
	size_t count;
d442 1
a442 1
	volatile u_int32_t *s;
d444 5
a448 5
	s = (volatile u_int32_t *)(bsh + offset);
	while (count--)
		__asm__ volatile("lwbrx %0, 0, %1" :
			"=r"(*addr++) : "r"(s++));
	__asm__ volatile("eieio; sync");
d451 1
a451 1
#define bus_space_read_region_8	!!! bus_space_read_region_8 unimplemented !!!
d454 3
a456 3
 *	void bus_space_read_region_stream_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset,
 *	    u_intN_t *addr, size_t count);
d463 1
a463 1
	bus_space_handle_t, bus_size_t, u_int16_t *, size_t);
d465 1
a465 1
	bus_space_handle_t, bus_size_t, u_int32_t *, size_t);
d469 12
a480 12
	bus_space_tag_t tag;
	bus_space_handle_t bsh;
	bus_size_t offset;
	u_int16_t *addr;
	size_t count;
{
	volatile u_int16_t *s;

	s = (volatile u_int16_t *)(bsh + offset);
	while (count--)
		*addr++ = *s++;
	__asm__ volatile("eieio; sync");
d485 5
a489 5
	bus_space_tag_t tag;
	bus_space_handle_t bsh;
	bus_size_t offset;
	u_int32_t *addr;
	size_t count;
d491 1
a491 1
	volatile u_int32_t *s;
d493 4
a496 4
	s = (volatile u_int32_t *)(bsh + offset);
	while (count--)
		*addr++ = *s++;
	__asm__ volatile("eieio; sync");
d499 2
a500 2
#define bus_space_read_region_stream_8					      \
	!!! bus_space_read_region_stream_8 unimplemented !!!
d503 3
a505 3
 *	void bus_space_write_region_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset,
 *	    const u_intN_t *addr, size_t count);
d511 1
a511 1
	bus_space_handle_t, bus_size_t, const u_int8_t *, size_t);
d513 1
a513 1
	bus_space_handle_t, bus_size_t, const u_int16_t *, size_t);
d515 1
a515 1
	bus_space_handle_t, bus_size_t, const u_int32_t *, size_t);
d519 12
a530 12
	bus_space_tag_t tag;
	bus_space_handle_t bsh;
	bus_size_t offset;
	const u_int8_t *addr;
	size_t count;
{
	volatile u_int8_t *d;

	d = (volatile u_int8_t *)(bsh + offset);
	while (count--)
		*d++ = *addr++;
	__asm__ volatile("eieio; sync");
d535 13
a547 13
	bus_space_tag_t tag;
	bus_space_handle_t bsh;
	bus_size_t offset;
	const u_int16_t *addr;
	size_t count;
{
	volatile u_int16_t *d;

	d = (volatile u_int16_t *)(bsh + offset);
	while (count--)
		__asm__ volatile("sthbrx %0, 0, %1" ::
			"r"(*addr++), "r"(d++));
	__asm__ volatile("eieio; sync");
d552 13
a564 13
	bus_space_tag_t tag;
	bus_space_handle_t bsh;
	bus_size_t offset;
	const u_int32_t *addr;
	size_t count;
{
	volatile u_int32_t *d;

	d = (volatile u_int32_t *)(bsh + offset);
	while (count--)
		__asm__ volatile("stwbrx %0, 0, %1" ::
			"r"(*addr++), "r"(d++));
	__asm__ volatile("eieio; sync");
d570 3
a572 3
 *	void bus_space_write_region_stream_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset,
 *	    const u_intN_t *addr, size_t count);
d578 1
a578 1
	bus_space_handle_t, bus_size_t, const u_int16_t *, size_t);
d580 1
a580 1
	bus_space_handle_t, bus_size_t, const u_int32_t *, size_t);
d584 12
a595 12
	bus_space_tag_t tag;
	bus_space_handle_t bsh;
	bus_size_t offset;
	const u_int16_t *addr;
	size_t count;
{
	volatile u_int16_t *d;

	d = (volatile u_int16_t *)(bsh + offset);
	while (count--)
		*d++ = *addr++;
	__asm__ volatile("eieio; sync");
d600 5
a604 5
	bus_space_tag_t tag;
	bus_space_handle_t bsh;
	bus_size_t offset;
	const u_int32_t *addr;
	size_t count;
d606 1
a606 1
	volatile u_int32_t *d;
d608 4
a611 4
	d = (volatile u_int32_t *)(bsh + offset);
	while (count--)
		*d++ = *addr++;
	__asm__ volatile("eieio; sync");
d614 2
a615 2
#define bus_space_write_region_stream_8					      \
	 !!! bus_space_write_region_stream_8 unimplemented !!!
d618 3
a620 3
 *	void bus_space_set_multi_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset, u_intN_t val,
 *	    size_t count);
d626 1
a626 1
	bus_space_handle_t, bus_size_t, u_int8_t, size_t);
d628 1
a628 1
	bus_space_handle_t, bus_size_t, u_int16_t, size_t);
d630 1
a630 1
	bus_space_handle_t, bus_size_t, u_int32_t, size_t);
d634 12
a645 12
	bus_space_tag_t tag;
	bus_space_handle_t bsh;
	bus_size_t offset;
	u_int8_t val;
	size_t count;
{
	volatile u_int8_t *d;

	d = (volatile u_int8_t *)(bsh + offset);
	while (count--)
		*d = val;
	__asm__ volatile("eieio; sync");
d650 13
a662 13
	bus_space_tag_t tag;
	bus_space_handle_t bsh;
	bus_size_t offset;
	u_int16_t val;
	size_t count;
{
	volatile u_int16_t *d;

	d = (volatile u_int16_t *)(bsh + offset);
	while (count--)
		__asm__ volatile("sthbrx %0, 0, %1" ::
			"r"(val), "r"(d));
	__asm__ volatile("eieio; sync");
d667 13
a679 13
	bus_space_tag_t tag;
	bus_space_handle_t bsh;
	bus_size_t offset;
	u_int32_t val;
	size_t count;
{
	volatile u_int32_t *d;

	d = (volatile u_int32_t *)(bsh + offset);
	while (count--)
		__asm__ volatile("stwbrx %0, 0, %1" ::
			"r"(val), "r"(d));
	__asm__ volatile("eieio; sync");
d685 3
a687 3
 *	void bus_space_set_multi_stream_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset, u_intN_t val,
 *	    size_t count);
d693 1
a693 1
	bus_space_handle_t, bus_size_t, u_int16_t, size_t);
d695 1
a695 1
	bus_space_handle_t, bus_size_t, u_int32_t, size_t);
d699 12
a710 12
	bus_space_tag_t tag;
	bus_space_handle_t bsh;
	bus_size_t offset;
	u_int16_t val;
	size_t count;
{
	volatile u_int16_t *d;

	d = (volatile u_int16_t *)(bsh + offset);
	while (count--)
		*d = val;
	__asm__ volatile("eieio; sync");
d715 5
a719 5
	bus_space_tag_t tag;
	bus_space_handle_t bsh;
	bus_size_t offset;
	u_int32_t val;
	size_t count;
d721 1
a721 1
	volatile u_int32_t *d;
d723 4
a726 4
	d = (volatile u_int32_t *)(bsh + offset);
	while (count--)
		*d = val;
	__asm__ volatile("eieio; sync");
d729 2
a730 2
#define bus_space_set_multi_stream_8					      \
	!!! bus_space_set_multi_stream_8 unimplemented !!!
d733 3
a735 3
 *	void bus_space_set_region_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset, u_intN_t val,
 *	    size_t count);
d741 1
a741 1
	bus_space_handle_t, bus_size_t, u_int8_t, size_t);
d743 1
a743 1
	bus_space_handle_t, bus_size_t, u_int16_t, size_t);
d745 1
a745 1
	bus_space_handle_t, bus_size_t, u_int32_t, size_t);
d749 12
a760 12
	bus_space_tag_t tag;
	bus_space_handle_t bsh;
	bus_size_t offset;
	u_int8_t val;
	size_t count;
{
	volatile u_int8_t *d;

	d = (volatile u_int8_t *)(bsh + offset);
	while (count--)
		*d++ = val;
	__asm__ volatile("eieio; sync");
d765 13
a777 13
	bus_space_tag_t tag;
	bus_space_handle_t bsh;
	bus_size_t offset;
	u_int16_t val;
	size_t count;
{
	volatile u_int16_t *d;

	d = (volatile u_int16_t *)(bsh + offset);
	while (count--)
		__asm__ volatile("sthbrx %0, 0, %1" ::
			"r"(val), "r"(d++));
	__asm__ volatile("eieio; sync");
d782 13
a794 13
	bus_space_tag_t tag;
	bus_space_handle_t bsh;
	bus_size_t offset;
	u_int32_t val;
	size_t count;
{
	volatile u_int32_t *d;

	d = (volatile u_int32_t *)(bsh + offset);
	while (count--)
		__asm__ volatile("stwbrx %0, 0, %1" ::
			"r"(val), "r"(d++));
	__asm__ volatile("eieio; sync");
d800 3
a802 3
 *	void bus_space_set_region_stream_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset, u_intN_t val,
 *	    size_t count);
d808 1
a808 1
	bus_space_handle_t, bus_size_t, u_int16_t, size_t);
d810 1
a810 1
	bus_space_handle_t, bus_size_t, u_int32_t, size_t);
d815 12
a826 12
	bus_space_tag_t tag;
	bus_space_handle_t bsh;
	bus_size_t offset;
	u_int16_t val;
	size_t count;
{
	volatile u_int16_t *d;

	d = (volatile u_int16_t *)(bsh + offset);
	while (count--)
		*d++ = val;
	__asm__ volatile("eieio; sync");
d831 5
a835 5
	bus_space_tag_t tag;
	bus_space_handle_t bsh;
	bus_size_t offset;
	u_int32_t val;
	size_t count;
d837 1
a837 1
	volatile u_int32_t *d;
d839 4
a842 4
	d = (volatile u_int32_t *)(bsh + offset);
	while (count--)
		*d++ = val;
	__asm__ volatile("eieio; sync");
d845 2
a846 2
#define bus_space_set_region_stream_8					      \
	!!! bus_space_set_region_stream_8 unimplemented !!!
d849 4
a852 4
 *	void bus_space_copy_region_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh1, bus_size_t off1,
 *	    bus_space_handle_t bsh2, bus_size_t off2,
 *	    size_t count);
d859 2
a860 2
	bus_space_handle_t, bus_size_t, bus_space_handle_t,
	bus_size_t, size_t);
d862 2
a863 2
	bus_space_handle_t, bus_size_t, bus_space_handle_t,
	bus_size_t, size_t);
d865 2
a866 2
	bus_space_handle_t, bus_size_t, bus_space_handle_t,
	bus_size_t, size_t);
d870 22
a891 22
	bus_space_tag_t t;
	bus_space_handle_t h1;
	bus_size_t o1;
	bus_space_handle_t h2;
	bus_size_t o2;
	size_t c;
{
	bus_addr_t addr1 = h1 + o1;
	bus_addr_t addr2 = h2 + o2;

	if (addr1 >= addr2) {
		/* src after dest: copy forward */
		for (; c != 0; c--, addr1++, addr2++)
			*(volatile u_int8_t *)(addr2) =
			    *(volatile u_int8_t *)(addr1);
	} else {
		/* dest after src: copy backwards */
		for (addr1 += (c - 1), addr2 += (c - 1);
		    c != 0; c--, addr1--, addr2--)
			*(volatile u_int8_t *)(addr2) =
			    *(volatile u_int8_t *)(addr1);
	}
d896 22
a917 22
	bus_space_tag_t t;
	bus_space_handle_t h1;
	bus_size_t o1;
	bus_space_handle_t h2;
	bus_size_t o2;
	size_t c;
{
	bus_addr_t addr1 = h1 + o1;
	bus_addr_t addr2 = h2 + o2;

	if (addr1 >= addr2) {
		/* src after dest: copy forward */
		for (; c != 0; c--, addr1 += 2, addr2 += 2)
			*(volatile u_int16_t *)(addr2) =
			    *(volatile u_int16_t *)(addr1);
	} else {
		/* dest after src: copy backwards */
		for (addr1 += 2 * (c - 1), addr2 += 2 * (c - 1);
		    c != 0; c--, addr1 -= 2, addr2 -= 2)
			*(volatile u_int16_t *)(addr2) =
			    *(volatile u_int16_t *)(addr1);
	}
d922 22
a943 22
	bus_space_tag_t t;
	bus_space_handle_t h1;
	bus_size_t o1;
	bus_space_handle_t h2;
	bus_size_t o2;
	size_t c;
{
	bus_addr_t addr1 = h1 + o1;
	bus_addr_t addr2 = h2 + o2;

	if (addr1 >= addr2) {
		/* src after dest: copy forward */
		for (; c != 0; c--, addr1 += 4, addr2 += 4)
			*(volatile u_int32_t *)(addr2) =
			    *(volatile u_int32_t *)(addr1);
	} else {
		/* dest after src: copy backwards */
		for (addr1 += 4 * (c - 1), addr2 += 4 * (c - 1);
		    c != 0; c--, addr1 -= 4, addr2 -= 4)
			*(volatile u_int32_t *)(addr2) =
			    *(volatile u_int32_t *)(addr1);
	}
d946 1
a946 1
#define bus_space_copy_region_8	!!! bus_space_copy_region_8 unimplemented !!!
d951 3
a953 3
 *	void bus_space_barrier(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset,
 *	    bus_size_t len, int flags);
d956 4
a959 4
#define bus_space_barrier(t, h, o, l, f)	\
     ((void)((void)(t), (void)(h), (void)(o), (void)(l), (void)(f)))
#define BUS_SPACE_BARRIER_READ	0x01	/* force read barrier */
#define BUS_SPACE_BARRIER_WRITE	0x02	/* force write barrier */
d970 9
a978 12
#define	BUS_DMA_WAITOK		0x000	/* safe to sleep (pseudo-flag) */
#define	BUS_DMA_NOWAIT		0x001	/* not safe to sleep */
#define	BUS_DMA_ALLOCNOW	0x002	/* perform resource allocation now */
#define	BUS_DMAMEM_NOSYNC	0x004
#define	BUS_DMA_COHERENT	0x008	/* hint: map memory DMA coherent */
#define	BUS_DMA_BUS1		0x010	/* placeholders for bus functions... */
#define	BUS_DMA_BUS2		0x020
#define	BUS_DMA_BUS3		0x040
#define	BUS_DMA_BUS4		0x080
#define	BUS_DMA_READ		0x100	/* mapping is device -> memory only */
#define	BUS_DMA_WRITE		0x200	/* mapping is memory -> device only */
#define	BUS_DMA_STREAMING	0x400	/* hint: sequential, unidirectional */
d989 2
a990 2
typedef struct powerpc_bus_dma_tag		*bus_dma_tag_t;
typedef struct powerpc_bus_dmamap		*bus_dmamap_t;
d993 1
a993 1
 *	bus_dma_segment_t
d995 2
a996 2
 *	Describes a single contiguous DMA transaction.  Values
 *	are suitable for programming into DMA registers.
d999 2
a1000 2
	bus_addr_t	ds_addr;	/* DMA address */
	bus_size_t	ds_len;		/* length of transfer */
d1005 1
a1005 1
 *	bus_dma_tag_t
d1007 2
a1008 2
 *	A machine-dependent opaque type describing the implementation of
 *	DMA for a given bus.
d1012 25
a1036 25
	/*
	 * The `bounce threshold' is checked while we are loading
	 * the DMA map.  If the physical address of the segment
	 * exceeds the threshold, an error will be returned.  The
	 * caller can then take whatever action is necessary to
	 * bounce the transfer.  If this value is 0, it will be
	 * ignored.
	 */
	bus_addr_t _bounce_thresh;

	/*
	 * DMA mapping methods.
	 */
	int	(*_dmamap_create)(bus_dma_tag_t, bus_size_t, int,
		    bus_size_t, bus_size_t, int, bus_dmamap_t *);
	void	(*_dmamap_destroy)(bus_dma_tag_t, bus_dmamap_t);
	int	(*_dmamap_load)(bus_dma_tag_t, bus_dmamap_t, void *,
		    bus_size_t, struct proc *, int);
	int	(*_dmamap_load_mbuf)(bus_dma_tag_t, bus_dmamap_t,
		    struct mbuf *, int);
	int	(*_dmamap_load_uio)(bus_dma_tag_t, bus_dmamap_t,
		    struct uio *, int);
	int	(*_dmamap_load_raw)(bus_dma_tag_t, bus_dmamap_t,
		    bus_dma_segment_t *, int, bus_size_t, int);
	void	(*_dmamap_unload)(bus_dma_tag_t, bus_dmamap_t);
d1039 1
a1039 1
	
d1041 11
a1051 11
	 * DMA memory utility functions.
	 */
	int	(*_dmamem_alloc)(bus_dma_tag_t, bus_size_t, bus_size_t,
		    bus_size_t, bus_dma_segment_t *, int, int *, int);
	void	(*_dmamem_free)(bus_dma_tag_t,
		    bus_dma_segment_t *, int);
	int	(*_dmamem_map)(bus_dma_tag_t, bus_dma_segment_t *,
		    int, size_t, caddr_t *, int);
	void	(*_dmamem_unmap)(bus_dma_tag_t, caddr_t, size_t);
	paddr_t	(*_dmamem_mmap)(bus_dma_tag_t, bus_dma_segment_t *,
		    int, off_t, int, int);
d1054 14
a1067 14
#define bus_dmamap_create(t, s, n, m, b, f, p)			\
	(*(t)->_dmamap_create)((t), (s), (n), (m), (b), (f), (p))
#define bus_dmamap_destroy(t, p)				\
	(*(t)->_dmamap_destroy)((t), (p))
#define bus_dmamap_load(t, m, b, s, p, f)			\
	(*(t)->_dmamap_load)((t), (m), (b), (s), (p), (f))
#define bus_dmamap_load_mbuf(t, m, b, f)			\
	(*(t)->_dmamap_load_mbuf)((t), (m), (b), (f))
#define bus_dmamap_load_uio(t, m, u, f)				\
	(*(t)->_dmamap_load_uio)((t), (m), (u), (f))
#define bus_dmamap_load_raw(t, m, sg, n, s, f)			\
	(*(t)->_dmamap_load_raw)((t), (m), (sg), (n), (s), (f))
#define bus_dmamap_unload(t, p)					\
	(*(t)->_dmamap_unload)((t), (p))
d1072 10
a1081 10
#define bus_dmamem_alloc(t, s, a, b, sg, n, r, f)		\
	(*(t)->_dmamem_alloc)((t), (s), (a), (b), (sg), (n), (r), (f))
#define bus_dmamem_free(t, sg, n)				\
	(*(t)->_dmamem_free)((t), (sg), (n))
#define bus_dmamem_map(t, sg, n, s, k, f)			\
	(*(t)->_dmamem_map)((t), (sg), (n), (s), (k), (f))
#define bus_dmamem_unmap(t, k, s)				\
	(*(t)->_dmamem_unmap)((t), (k), (s))
#define bus_dmamem_mmap(t, sg, n, o, p, f)			\
	(*(t)->_dmamem_mmap)((t), (sg), (n), (o), (p), (f))
d1084 1
a1084 1
 *	bus_dmamap_t
d1086 1
a1086 1
 *	Describes a DMA mapping.
d1089 18
a1106 18
	/*
	 * PRIVATE MEMBERS: not for use by machine-independent code.
	 */
	bus_size_t	_dm_size;	/* largest DMA transfer mappable */
	int		_dm_segcnt;	/* number of segs this map can map */
	bus_size_t	_dm_maxsegsz;	/* largest possible segment */
	bus_size_t	_dm_boundary;	/* don't cross this */
	bus_addr_t	_dm_bounce_thresh; /* bounce threshold; see tag */
	int		_dm_flags;	/* misc. flags */

	void		*_dm_cookie;	/* cookie for bus-specific functions */

	/*
	 * PUBLIC MEMBERS: these are used by machine-independent code.
	 */
	bus_size_t	dm_mapsize;	/* size of the mapping */
	int		dm_nsegs;	/* # valid segments in mapping */
	bus_dma_segment_t dm_segs[1];	/* segments; variable length */
d1110 12
a1121 12
int	_bus_dmamap_create(bus_dma_tag_t, bus_size_t, int, bus_size_t,
	    bus_size_t, int, bus_dmamap_t *);
void	_bus_dmamap_destroy(bus_dma_tag_t, bus_dmamap_t);
int	_bus_dmamap_load(bus_dma_tag_t, bus_dmamap_t, void *,
	    bus_size_t, struct proc *, int);
int	_bus_dmamap_load_mbuf(bus_dma_tag_t, bus_dmamap_t,
	    struct mbuf *, int);
int	_bus_dmamap_load_uio(bus_dma_tag_t, bus_dmamap_t,
	    struct uio *, int);
int	_bus_dmamap_load_raw(bus_dma_tag_t, bus_dmamap_t,
	    bus_dma_segment_t *, int, bus_size_t, int);
void	_bus_dmamap_unload(bus_dma_tag_t, bus_dmamap_t);
d1125 9
a1133 9
int	_bus_dmamem_alloc(bus_dma_tag_t tag, bus_size_t size,
	    bus_size_t alignment, bus_size_t boundary,
	    bus_dma_segment_t *segs, int nsegs, int *rsegs, int flags);
void	_bus_dmamem_free(bus_dma_tag_t tag, bus_dma_segment_t *segs,
	    int nsegs);
int	_bus_dmamem_map(bus_dma_tag_t tag, bus_dma_segment_t *segs,
	    int nsegs, size_t size, caddr_t *kvap, int flags);
void	_bus_dmamem_unmap(bus_dma_tag_t tag, caddr_t kva,
	    size_t size);
d1135 1
a1135 1
	    int nsegs, off_t off, int prot, int flags);
d1137 4
a1140 4
int	_bus_dmamem_alloc_range(bus_dma_tag_t tag, bus_size_t size,
	    bus_size_t alignment, bus_size_t boundary,
	    bus_dma_segment_t *segs, int nsegs, int *rsegs, int flags,
	    paddr_t low, paddr_t high);
@


