head	1.3;
access;
symbols
	SMP_SYNC_A:1.3
	SMP_SYNC_B:1.3
	UBC_SYNC_A:1.3
	OPENBSD_3_1:1.2.0.2
	OPENBSD_3_1_BASE:1.2
	UBC_SYNC_B:1.3
	UBC:1.1.0.6
	UBC_BASE:1.1
	OPENBSD_3_0:1.1.0.4
	OPENBSD_3_0_BASE:1.1
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.3
date	2002.06.08.16.02.13;	author miod;	state dead;
branches;
next	1.2;

1.2
date	2002.03.14.01.26.41;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2001.06.26.21.57.39;	author smurph;	state Exp;
branches
	1.1.2.1
	1.1.6.1;
next	;

1.1.2.1
date	2002.03.28.10.36.03;	author niklas;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2003.03.27.23.52.16;	author niklas;	state dead;
branches;
next	;

1.1.6.1
date	2002.06.11.03.37.22;	author art;	state dead;
branches;
next	;


desc
@@


1.3
log
@One ddb to rule them all.

Move the ddb files form macppc/macppc to powerpc/ddb, so that mvmeppc
can benefit from the better ddb that was in macppc.
db_interface.c is left as an md part.
@
text
@/*	$OpenBSD: db_interface.c,v 1.2 2002/03/14 01:26:41 millert Exp $	*/

#include <sys/param.h>
#include <sys/proc.h>
#include <sys/systm.h>

#include <machine/db_machdep.h>
#include <machine/frame.h>

#include <ddb/db_sym.h>
#include <ddb/db_command.h>
#include <ddb/db_extern.h>
#include <ddb/db_access.h>
#include <ddb/db_output.h>

extern label_t *db_recover;

void ddb_trap(void);                   /* Call into trap_subr.S */
int ddb_trap_glue(struct trapframe *); /* Called from trap_subr.S */

void
Debugger()
{
#ifdef DDB
	ddb_trap();
#else
	mvmeprom_retunr();
#endif 
}

int
ddb_trap_glue(frame)
        struct trapframe *frame;
{
        if (!(frame->srr1 & PSL_PR)
            && (frame->exc == EXC_TRC
                || (frame->exc == EXC_PGM
                    && (frame->srr1 & 0x20000))
                || frame->exc == EXC_BPT)) {

                bcopy(frame->fixreg, DDB_REGS->r, 32 * sizeof(u_int32_t));
                DDB_REGS->iar = frame->srr0;
                DDB_REGS->msr = frame->srr1;

                db_trap(T_BREAKPOINT, 0);

                bcopy(DDB_REGS->r, frame->fixreg, 32 * sizeof(u_int32_t));

                return 1;
        }
        return 0;
}

struct db_command db_machine_cmds[] =
{
    {(char  *) 0,}
};

void
kdb_init()
{
#ifdef DB_MACHINE_COMMANDS
	db_machine_commands_install(db_machine_cmds);
#endif
	ddb_init();

	db_printf("ddb enabled\n");
}

int
kdb_trap(type, v)
        int type;
        void *v;
{
        struct trapframe *frame = v;

        switch (type) {
        case T_BREAKPOINT:
        case -1:
                break;
        default:
                if (db_recover != 0) {
                        db_error("Faulted in DDB; continuing...\n");
                        /*NOTREACHED*/
                }
        }

        /* XXX Should switch to kdb's own stack here. */

        bcopy(frame->fixreg, DDB_REGS->r, 32 * sizeof(u_int32_t));
        DDB_REGS->iar = frame->srr0;
        DDB_REGS->msr = frame->srr1;

        db_trap(T_BREAKPOINT, 0);

        bcopy(DDB_REGS->r, frame->fixreg, 32 * sizeof(u_int32_t));
        frame->srr0 = DDB_REGS->iar;
        frame->srr1 = DDB_REGS->msr;

        return 1;
}

@


1.2
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.1 2001/06/26 21:57:39 smurph Exp $	*/
@


1.1
log
@Initial import of mvmeppc.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.3 1999/07/05 20:23:08 rahnds Exp $	*/
d18 2
a19 2
void ddb_trap __P((void));                   /* Call into trap_subr.S */
int ddb_trap_glue __P((struct trapframe *)); /* Called from trap_subr.S */
@


1.1.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.1 2001/06/26 21:57:39 smurph Exp $	*/
@


1.1.2.1
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d18 2
a19 2
void ddb_trap(void);                   /* Call into trap_subr.S */
int ddb_trap_glue(struct trapframe *); /* Called from trap_subr.S */
@


1.1.2.2
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.1.2.1 2002/03/28 10:36:03 niklas Exp $	*/
@


