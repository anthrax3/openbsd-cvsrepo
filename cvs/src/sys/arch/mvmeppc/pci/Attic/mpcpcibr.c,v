head	1.22;
access;
symbols
	OPENBSD_4_9:1.21.0.2
	OPENBSD_4_9_BASE:1.21
	OPENBSD_4_8:1.20.0.4
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.20.0.2
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.19.0.4
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.18.0.10
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.18.0.8
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.18.0.6
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.18.0.4
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.18.0.2
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.17.0.4
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.17.0.2
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.16.0.4
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.16.0.2
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.15.0.4
	OPENBSD_3_6_BASE:1.15
	SMP_SYNC_A:1.15
	SMP_SYNC_B:1.15
	OPENBSD_3_5:1.15.0.2
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	UBC_SYNC_A:1.11
	OPENBSD_3_3:1.10.0.4
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.2
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	UBC_SYNC_B:1.10
	UBC:1.7.0.2
	UBC_BASE:1.7
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.22
date	2011.07.07.19.16.43;	author deraadt;	state dead;
branches;
next	1.21;

1.21
date	2010.12.04.17.06.31;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2009.08.22.02.54.50;	author mk;	state Exp;
branches;
next	1.19;

1.19
date	2009.03.30.09.51.54;	author kettenis;	state Exp;
branches;
next	1.18;

1.18
date	2006.12.14.17.36.12;	author kettenis;	state Exp;
branches;
next	1.17;

1.17
date	2005.11.07.02.19.46;	author brad;	state Exp;
branches;
next	1.16;

1.16
date	2004.11.19.22.11.07;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2004.01.29.20.27.37;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2004.01.29.10.58.10;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2004.01.28.23.50.19;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2003.12.20.22.40.27;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2003.05.11.19.41.11;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2002.06.08.15.50.01;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.14.03.15.58;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.14.01.26.41;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.11.06.22.46.00;	author miod;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2001.11.06.19.53.15;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2001.09.21.02.11.58;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2001.09.02.19.41.40;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2001.08.17.22.26.58;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	2001.07.06.05.14.31;	author smurph;	state Exp;
branches;
next	1.1;

1.1
date	2001.06.26.21.57.56;	author smurph;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2001.10.31.03.01.21;	author nate;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2001.11.13.21.04.16;	author niklas;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2002.03.28.10.36.04;	author niklas;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2003.03.27.23.52.17;	author niklas;	state Exp;
branches;
next	1.1.2.5;

1.1.2.5
date	2003.05.13.19.41.07;	author ho;	state Exp;
branches;
next	1.1.2.6;

1.1.2.6
date	2004.02.19.10.49.10;	author niklas;	state Exp;
branches;
next	;

1.7.2.1
date	2002.06.11.03.37.23;	author art;	state Exp;
branches;
next	1.7.2.2;

1.7.2.2
date	2003.05.19.21.49.43;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.22
log
@remove mvmeppc; it is really rough shape.  ok drahn miod
@
text
@/*	$OpenBSD: mpcpcibr.c,v 1.21 2010/12/04 17:06:31 miod Exp $ */

/*
 * Copyright (c) 2001 Steve Murphree, Jr.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed under OpenBSD for RTMX Inc
 *      by Per Fogelstrom, Opsycon AB.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

/*
 * Motorola 'Raven' PCI BUS Bridge driver.
 * specialized hooks for different config methods.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/device.h>
#include <sys/proc.h>
#include <uvm/uvm_extern.h>

#include <machine/autoconf.h>
#include <machine/bus.h>
#include <machine/pcb.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>

#include <mvmeppc/pci/pcibrvar.h>
#include <mvmeppc/dev/ravenreg.h>
#include <mvmeppc/dev/ravenvar.h>

int    mpcpcibrmatch(struct device *, void *, void *);
void   mpcpcibrattach(struct device *, struct device *, void *);

void   mpc_attach_hook(struct device *, struct device *,
    struct pcibus_attach_args *);
int    mpc_bus_maxdevs(void *, int);
pcitag_t mpc_make_tag(void *, int, int, int);
void   mpc_decompose_tag(void *, pcitag_t, int *, int *, int *);
int	mpc_conf_size(void *, pcitag_t);
pcireg_t mpc_conf_read(void *, pcitag_t, int);
void   mpc_conf_write(void *, pcitag_t, int, pcireg_t);

int      mpc_intr_map(void *, pcitag_t, int, int, pci_intr_handle_t *);
const char *mpc_intr_string(void *, pci_intr_handle_t);
int	 mpc_intr_line(void *, pci_intr_handle_t);
void     *mpc_intr_establish(void *, pci_intr_handle_t,
    int, int (*)(void *), void *, const char *);
void     mpc_intr_disestablish(void *, void *);
int      mpc_ether_hw_addr(struct ppc_pci_chipset *, u_int8_t *);

void mpc_cfg_write_1(struct pcibr_config *, u_int32_t, u_int8_t);
void mpc_cfg_write_2(struct pcibr_config *, u_int32_t, u_int16_t);
void mpc_cfg_write_4(struct pcibr_config *, u_int32_t, u_int32_t);

u_int8_t mpc_cfg_read_1(struct pcibr_config *, u_int32_t);
u_int16_t mpc_cfg_read_2(struct pcibr_config *, u_int32_t);
u_int32_t mpc_cfg_read_4(struct pcibr_config *, u_int32_t);

u_int32_t pci_iack(void);
u_int32_t mpc_gen_config_reg(void *, pcitag_t, int);

struct cfattach mpcpcibr_ca = {
	sizeof(struct pcibr_softc), mpcpcibrmatch, mpcpcibrattach,
};

struct cfdriver mpcpcibr_cd = {
	NULL, "mpcpcibr", DV_DULL,
};

int      mpcpcibrprint(void *, const char *pnp);

struct pcibr_config mpc_config;

struct powerpc_bus_dma_tag pci_bus_dma_tag = {
	NULL,
	_bus_dmamap_create,
	_bus_dmamap_destroy,
	_bus_dmamap_load,
	_bus_dmamap_load_mbuf,
	_bus_dmamap_load_uio,
	_bus_dmamap_load_raw,
	_bus_dmamap_unload,
	_bus_dmamap_sync,
	_bus_dmamem_alloc,
	_bus_dmamem_free,
	_bus_dmamem_map,
	_bus_dmamem_unmap,
	_bus_dmamem_mmap
};

extern u_int8_t *ravenregs;
extern vaddr_t isaspace_va;

struct raven_setup {
	unsigned int	pci_reg;
	u_int32_t	value;
};

const struct raven_setup raven_prep_setup[] = {
	/* PCI registers */
	{ RAVEN_PCI_MEM, RAVEN_PCI_MEM_VAL },
	{ RAVEN_PCI_PSADD0, RAVEN_PCI_PSADD0_VAL },
	{ RAVEN_PCI_PSOFF0, RAVEN_PCI_PSOFF0_VAL },
	{ RAVEN_PCI_PSADD1, RAVEN_PCI_PSADD1_VAL },
	{ RAVEN_PCI_PSOFF1, RAVEN_PCI_PSOFF1_VAL },
	{ RAVEN_PCI_PSADD2, RAVEN_PCI_PSADD2_VAL },
	{ RAVEN_PCI_PSOFF2, RAVEN_PCI_PSOFF2_VAL },
	{ RAVEN_PCI_PSADD3, RAVEN_PCI_PSADD3_VAL },
	{ RAVEN_PCI_PSOFF3, RAVEN_PCI_PSOFF3_VAL },

#ifdef notyet
	/* Universe PCI registers */
	{ 0x100, 0xc0825100 },
	{ 0x104, 0x01000000 },
	{ 0x108, 0x30000000 },
	{ 0x10c, 0x00000000 },
	{ 0x114, 0xc0425100 },
	{ 0x118, 0x30000000 },
	{ 0x11c, 0x38000000 },
	{ 0x120, 0x00000000 },
	{ 0x128, 0x00000000 },
	{ 0x12c, 0x00000000 },
	{ 0x130, 0x00000000 },
	{ 0x134, 0x00000000 },
	{ 0x13c, 0x00000000 },
	{ 0x140, 0x00000000 },
	{ 0x144, 0x00000000 },
	{ 0x148, 0x00000000 },
	{ 0x188, 0xc0a05338 },

	/* Default Universe VME Slave Map */
	{ 0xf00, 0xc0f20001 },
	{ 0xf04, 0x40000000 },
	{ 0xf08, 0x40001000 },
	{ 0xf0c, 0xc0001000 },
	{ 0xf14, 0xe0f200c0 },
	{ 0xf18, 0x10000000 },
	{ 0xf1c, 0x20000000 },
	{ 0xf20, 0x70000000 },
	{ 0xf28, 0x00000000 },
	{ 0xf2c, 0x00000000 },
	{ 0xf30, 0x00000000 },
	{ 0xf34, 0x00000000 },
	{ 0xf3c, 0x00000000 },
	{ 0xf40, 0x00000000 },
	{ 0xf44, 0x00000000 },
	{ 0xf48, 0x00000000 },
#endif

	{ 0, 0 },
};

int
mpcpcibrmatch(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	/* We must be a child of the raven device */
	if (strcmp(parent->dv_cfdata->cf_driver->cd_name, "raven") != 0)
		return (0);

	return 1;
}

void
mpcpcibrattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct pcibr_softc *sc = (struct pcibr_softc *)self;
	struct pcibr_config *lcp;
	struct pcibus_attach_args pba;
	const struct raven_setup *rs;

	lcp = sc->sc_pcibr = &mpc_config;

	sc->sc_membus_space = prep_mem_space_tag;
	sc->sc_iobus_space = prep_io_space_tag;

	lcp->lc_pc.pc_conf_v = lcp;
	lcp->lc_pc.pc_attach_hook = mpc_attach_hook;
	lcp->lc_pc.pc_bus_maxdevs = mpc_bus_maxdevs;
	lcp->lc_pc.pc_make_tag = mpc_make_tag;
	lcp->lc_pc.pc_decompose_tag = mpc_decompose_tag;
	lcp->lc_pc.pc_conf_size = mpc_conf_size;
	lcp->lc_pc.pc_conf_read = mpc_conf_read;
	lcp->lc_pc.pc_conf_write = mpc_conf_write;
	lcp->lc_pc.pc_ether_hw_addr = mpc_ether_hw_addr;
	lcp->lc_iot = &sc->sc_iobus_space;
	lcp->lc_memt = &sc->sc_membus_space;

	lcp->ioh_cf8 = (PREP_CONFIG_ADD - RAVEN_P_ISA_IO_SPACE) +
		(bus_space_handle_t)isaspace_va;
	lcp->ioh_cfc = (PREP_CONFIG_DAT - RAVEN_P_ISA_IO_SPACE) +
		(bus_space_handle_t)isaspace_va;

	lcp->config_type = 0;

	lcp->lc_pc.pc_intr_v = lcp;
	lcp->lc_pc.pc_intr_map = mpc_intr_map;
	lcp->lc_pc.pc_intr_string = mpc_intr_string;
	lcp->lc_pc.pc_intr_line = mpc_intr_line;
	lcp->lc_pc.pc_intr_establish = mpc_intr_establish;
	lcp->lc_pc.pc_intr_disestablish = mpc_intr_disestablish;

	printf(": revision 0x%x\n", 
	    mpc_cfg_read_1(lcp, RAVEN_PCI_REVID));

	bzero(&pba, sizeof(pba));
	pba.pba_dmat = &pci_bus_dma_tag;

	pba.pba_busname = "pci";
	pba.pba_iot = &sc->sc_iobus_space;
	pba.pba_memt = &sc->sc_membus_space;
	pba.pba_pc = &lcp->lc_pc;
	pba.pba_domain = pci_ndomains++;
	pba.pba_bus = 0; 

	/*
	 * Set up PREP environment
	 */

	*(u_int32_t *)(ravenregs + RAVEN_MSADD0) = RAVEN_MSADD0_PREP;
	*(u_int32_t *)(ravenregs + RAVEN_MSOFF0) = RAVEN_MSOFF0_PREP;
	*(u_int32_t *)(ravenregs + RAVEN_MSADD1) = RAVEN_MSADD1_PREP;
	*(u_int32_t *)(ravenregs + RAVEN_MSOFF1) = RAVEN_MSOFF1_PREP;
	*(u_int32_t *)(ravenregs + RAVEN_MSADD2) = RAVEN_MSADD2_PREP;
	*(u_int32_t *)(ravenregs + RAVEN_MSOFF2) = RAVEN_MSOFF2_PREP;
	*(u_int32_t *)(ravenregs + RAVEN_MSADD3) = RAVEN_MSADD3_PREP;
	*(u_int32_t *)(ravenregs + RAVEN_MSOFF3) = RAVEN_MSOFF3_PREP;

	for (rs = raven_prep_setup; rs->pci_reg != 0; rs++) {
		mpc_cfg_write_4(lcp, rs->pci_reg, rs->value);
	}

	/* enable mem and io mapping, and bus master */
	mpc_cfg_write_2(lcp, RAVEN_PCI_CMD, 
	    RAVEN_CMD_IOSP | RAVEN_CMD_MEMSP | RAVEN_CMD_MASTR);

	config_found(self, &pba, mpcpcibrprint);
}

int
mpcpcibrprint(aux, pnp)
	void *aux;
	const char *pnp;
{
	struct pcibus_attach_args *pba = aux;

	if (pnp)
		printf("%s at %s", pba->pba_busname, pnp);
	printf(" bus %d", pba->pba_bus);
	return (UNCONF);
}

void
mpc_attach_hook(parent, self, pba)
	struct device *parent, *self;
	struct pcibus_attach_args *pba;
{
}

int
mpc_ether_hw_addr(p, ethaddr)
	struct ppc_pci_chipset *p;
	u_int8_t *ethaddr;
{
	printf("mpc_ether_hw_addr not supported\n");
	return (0);
}

int
mpc_bus_maxdevs(cpv, busno)
	void *cpv;
	int busno;
{
	return (32);
}

#define BUS_SHIFT 16
#define DEVICE_SHIFT 11
#define FNC_SHIFT 8

pcitag_t
mpc_make_tag(cpv, bus, dev, fnc)
	void *cpv;
	int bus, dev, fnc;
{
	return (bus << BUS_SHIFT) | (dev << DEVICE_SHIFT) | (fnc << FNC_SHIFT);
}

void
mpc_decompose_tag(cpv, tag, busp, devp, fncp)
	void *cpv;
	pcitag_t tag;
	int *busp, *devp, *fncp;
{
	if (busp != NULL)
		*busp = (tag >> BUS_SHIFT) & 0xff;
	if (devp != NULL)
		*devp = (tag >> DEVICE_SHIFT) & 0x1f;
	if (fncp != NULL)
		*fncp = (tag >> FNC_SHIFT) & 0x7;
}

u_int32_t
mpc_gen_config_reg(cpv, tag, offset)
	void *cpv;
	pcitag_t tag;
	int offset;
{
#if 0
	struct pcibr_config *cp = cpv;
	unsigned int bus, dev, fcn;
#endif
	u_int32_t reg;

#if 0
	mpc_decompose_tag(cpv, tag, &bus, &dev, &fcn);

	if (cp->config_type & 1) {
		/* Config Mechanism #2 */
		if (bus == 0) {
			if (dev < 11) {
				return 0xffffffff;
			}
			/*
			 * Need to do config type 0 operation
			 *  1 << (11?+dev) | fcn << 8 | reg
			 * 11? is because pci spec states
			 * that 11-15 is reserved.
			 */
			reg = 1 << (dev) | fcn << 8 | offset;

		} else {
			if (dev > 15) {
				return 0xffffffff;
			}
			/*
			 * config type 1 
			 */
			reg =  tag  | offset | 1;

		}
	} else {
#else
	{
#endif
		/* config mechanism #2, type 0 */
		/* standard cf8/cfc config */
		reg =  0x80000000 | tag  | offset;

	}
	return reg;
}

int
mpc_conf_size(void *cpv, pcitag_t tag)
{
	return PCI_CONFIG_SPACE_SIZE;
}

/*#define DEBUG_CONFIG */
pcireg_t
mpc_conf_read(cpv, tag, offset)
	void *cpv;
	pcitag_t tag;
	int offset;
{
	struct pcibr_config *cp = cpv;
	pcireg_t data;
	u_int32_t reg;
	int s;
	int daddr = 0;
	faultbuf env;
	void *oldh;

	if (offset & 3 ||
	    offset < 0 || offset >= PCI_CONFIG_SPACE_SIZE) {
#ifdef DEBUG_CONFIG
		printf ("pci_conf_read: bad reg %x\n", offset);
#endif
		return (~0);
	}

	reg = mpc_gen_config_reg(cpv, tag, offset);
	/* if invalid tag, return -1 */
	if (reg == 0xffffffff) {
		return (~0);
	}

	if ((cp->config_type & 2) && (offset & 0x04)) {
		daddr += 4;
	}

	s = splhigh();

	oldh = curpcb->pcb_onfault;
	if (setfault(&env)) {
		/* did we fault during the read? */
		curpcb->pcb_onfault = oldh;
		return (~0);
	}

	bus_space_write_4(cp->lc_iot, cp->ioh_cf8, 0, reg);
	bus_space_read_4(cp->lc_iot, cp->ioh_cf8, 0); /* XXX */
	data = bus_space_read_4(cp->lc_iot, cp->ioh_cfc, daddr);
	bus_space_write_4(cp->lc_iot, cp->ioh_cf8, 0, 0); /* disable */
	bus_space_read_4(cp->lc_iot, cp->ioh_cf8, 0); /* XXX */

	curpcb->pcb_onfault = oldh;

	splx(s);
#ifdef DEBUG_CONFIG
	if (!((offset == 0) && (data == 0xffffffff))) {
		unsigned int bus, dev, fcn;
		mpc_decompose_tag(cpv, tag, &bus, &dev, &fcn);
		printf("mpc_conf_read bus %x dev %x fcn %x offset %x", bus, dev, fcn,
				 offset);
		printf(" daddr %x reg %x",daddr, reg);
		printf(" data %x\n", data);
	}
#endif

	return (data);
}

void
mpc_conf_write(cpv, tag, offset, data)
	void *cpv;
	pcitag_t tag;
	int offset;
	pcireg_t data;
{
	struct pcibr_config *cp = cpv;
	u_int32_t reg;
	int s;
	int daddr = 0;

	reg = mpc_gen_config_reg(cpv, tag, offset);

	/* if invalid tag, return ??? */
	if (reg == 0xffffffff) {
		return;
	}
	if ((cp->config_type & 2) && (offset & 0x04))
		daddr += 4;

#ifdef DEBUG_CONFIG
	{
		unsigned int bus, dev, fcn;
		mpc_decompose_tag(cpv, tag, &bus, &dev, &fcn);
		printf("mpc_conf_write bus %x dev %x fcn %x offset %x", bus,
				 dev, fcn, offset);
		printf(" daddr %x reg %x",daddr, reg);
		printf(" data %x\n", data);
	}
#endif

	s = splhigh();

	bus_space_write_4(cp->lc_iot, cp->ioh_cf8, 0, reg);
	bus_space_read_4(cp->lc_iot, cp->ioh_cf8, 0); /* XXX */
	bus_space_write_4(cp->lc_iot, cp->ioh_cfc, daddr, data);
	bus_space_write_4(cp->lc_iot, cp->ioh_cf8, 0, 0); /* disable */
	bus_space_read_4(cp->lc_iot, cp->ioh_cf8, 0); /* XXX */

	splx(s);
}

/*ARGSUSED*/
int
mpc_intr_map(lcv, bustag, buspin, line, ihp)
	void *lcv;
	pcitag_t bustag;
	int buspin, line;
	pci_intr_handle_t *ihp;
{
	int error = 0;

	*ihp = -1;
	if (buspin == 0) {
		error = 1; /* No IRQ used. */
	} else if (buspin > 4) {
		printf("mpc_intr_map: bad interrupt pin %d\n", buspin);
		error = 1;
	}

	if (!error)
		*ihp = line;
	return error;
}

const char *
mpc_intr_string(lcv, ih)
	void *lcv;
	pci_intr_handle_t ih;
{
	static char str[16];

	snprintf(str, sizeof str, "irq %ld", ih);
	return (str);
}

int
mpc_intr_line(lcv, ih)
	void *lcv;
	pci_intr_handle_t ih;
{
	return (ih);
}

typedef void     *(intr_establish_t)(void *, pci_intr_handle_t, int, int,
    int (*func)(void *), void *, char *);
typedef void     (intr_disestablish_t)(void *, void *);
extern intr_establish_t *intr_establish_func;
extern intr_disestablish_t *intr_disestablish_func;

void *
mpc_intr_establish(lcv, ih, level, func, arg, name)
	void *lcv;
	pci_intr_handle_t ih;
	int level;
	int (*func)(void *);
	void *arg;
	const char *name;
{
	return (*intr_establish_func)(lcv, ih, IST_LEVEL, level, func, arg,
		name);
}

void
mpc_intr_disestablish(lcv, cookie)
	void *lcv, *cookie;
{
	(*intr_disestablish_func)(lcv, cookie);
}

u_int32_t
pci_iack()
{
	/* do pci IACK cycle */
	/* this should be bus allocated. */
	volatile u_int8_t *iack = ravenregs + RAVEN_PIACK;
	u_int8_t val;

	val = *iack;
	return val;
}

void
mpc_cfg_write_1(cp, reg, val)
	struct pcibr_config *cp;
	u_int32_t reg;
	u_int8_t val;
{
	int s;

	s = splhigh();
	bus_space_write_4(cp->lc_iot, cp->ioh_cf8, 0, RAVEN_REGOFFS(reg));
	bus_space_write_1(cp->lc_iot, cp->ioh_cfc, 0, val);
	splx(s);
}

void
mpc_cfg_write_2(cp, reg, val)
	struct pcibr_config *cp;
	u_int32_t reg;
	u_int16_t val;
{
	int s;

	s = splhigh();
	bus_space_write_4(cp->lc_iot, cp->ioh_cf8, 0, RAVEN_REGOFFS(reg));
	bus_space_write_2(cp->lc_iot, cp->ioh_cfc, 0, val);
	splx(s);
}

void
mpc_cfg_write_4(cp, reg, val)
	struct pcibr_config *cp;
	u_int32_t reg;
	u_int32_t val;
{
	int s;

	s = splhigh();
	bus_space_write_4(cp->lc_iot, cp->ioh_cf8, 0, RAVEN_REGOFFS(reg));
	bus_space_write_4(cp->lc_iot, cp->ioh_cfc, 0, val);
	splx(s);
}

u_int8_t
mpc_cfg_read_1(cp, reg)
	struct pcibr_config *cp;
	u_int32_t reg;
{
	u_int8_t _v_;
	int s;

	s = splhigh();
	bus_space_write_4(cp->lc_iot, cp->ioh_cf8, 0, RAVEN_REGOFFS(reg));
	_v_ = bus_space_read_1(cp->lc_iot, cp->ioh_cfc, 0);
	splx(s);
	return (_v_);
}

u_int16_t
mpc_cfg_read_2(cp, reg)
	struct pcibr_config *cp;
	u_int32_t reg;
{
	u_int16_t _v_;
	int s;

	s = splhigh();
	bus_space_write_4(cp->lc_iot, cp->ioh_cf8, 0, RAVEN_REGOFFS(reg));
	_v_ = bus_space_read_2(cp->lc_iot, cp->ioh_cfc, 0);
	splx(s);
	return (_v_);
}

u_int32_t
mpc_cfg_read_4(cp, reg)
	struct pcibr_config *cp;
	u_int32_t reg;
{
	u_int32_t _v_;
	int s;

	s = splhigh();
	bus_space_write_4(cp->lc_iot, cp->ioh_cf8, 0, RAVEN_REGOFFS(reg));
	_v_ = bus_space_read_4(cp->lc_iot, cp->ioh_cfc, 0);
	splx(s);
	return (_v_);
}
@


1.21
log
@Introduce a new pci routine, pci_conf_size(), which returns the size of a
given pcitag_t configuration address space. Currently, all pci controllers
will return the usual 0x100 bytes of PCI configuration space, but this will
eventually change on PCIe-capable controlers.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibr.c,v 1.20 2009/08/22 02:54:50 mk Exp $ */
@


1.20
log
@Constify the what/name parameter of pci_intr_establish().

Tested by myself, sthen, oga, kettenis, and jasper.
Input from sthen and jasper.

ok kettenis

(Manpage follows shortly.)
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibr.c,v 1.19 2009/03/30 09:51:54 kettenis Exp $ */
d68 1
d214 1
d386 6
d407 2
a408 1
	if (offset & 3 || offset < 0 || offset >= 0x100) {
@


1.19
log
@bzero pci attach args
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibr.c,v 1.18 2006/12/14 17:36:12 kettenis Exp $ */
d75 1
a75 1
    int, int (*)(void *), void *, char *);
d546 1
a546 1
	char *name;
@


1.18
log
@Make pci subsystem aware of domains.  Each host bridge gets assigned a unique
domain number such that we can distinguish between busses with the same bus
number that are behind different host bridges.  Domains can be accessed by
using different device nodes.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibr.c,v 1.17 2005/11/07 02:19:46 brad Exp $ */
d235 2
@


1.17
log
@remove vtophys() on *ppc.

ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibr.c,v 1.16 2004/11/19 22:11:07 miod Exp $ */
d241 1
@


1.16
log
@Better Raven PREP initialization, per the book, with an evil book mistake
corrected.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibr.c,v 1.15 2004/01/29 20:27:37 miod Exp $ */
a277 15
}

/*
 *  Get PCI physical address from given virtual address.
 *  XXX Note that cross page boundaries are *not* guaranteed to work!
 */
paddr_t
vtophys(vaddr_t va)
{
	paddr_t pa;

	if (pmap_extract(pmap_kernel(), va, &pa) == FALSE)
		return NULL;

	return PHYS_TO_PCI_MEM(pa);
@


1.15
log
@Some more cleaning and sync with other ppc ports, in order to help with a
future factorization of the pci bridge code.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibr.c,v 1.14 2004/01/29 10:58:10 miod Exp $ */
d122 59
d201 1
d243 4
a246 2
#if 0
	/* set up prep environment */
d256 4
a259 23
	/* set up PCI local bus */
	mpc_cfg_write_4(lcp, RAVEN_PCI_MEM, MPCIC_BASE);
	mpc_cfg_write_4(lcp, RAVEN_PCI_PSADD0, RAVEN_PCI_PSADD0_VAL);
	mpc_cfg_write_4(lcp, RAVEN_PCI_PSOFF0, RAVEN_PCI_PSOFF0_VAL);
	mpc_cfg_write_4(lcp, RAVEN_PCI_PSADD1, RAVEN_PCI_PSADD1_VAL);
	mpc_cfg_write_4(lcp, RAVEN_PCI_PSOFF1, RAVEN_PCI_PSOFF1_VAL);
	mpc_cfg_write_4(lcp, RAVEN_PCI_PSADD2, RAVEN_PCI_PSADD2_VAL);
	mpc_cfg_write_4(lcp, RAVEN_PCI_PSOFF2, RAVEN_PCI_PSOFF2_VAL);
	mpc_cfg_write_4(lcp, RAVEN_PCI_PSADD3, RAVEN_PCI_PSADD3_VAL);
	mpc_cfg_write_4(lcp, RAVEN_PCI_PSOFF3, RAVEN_PCI_PSOFF3_VAL);

	/* set up VME -> PCI local bus */

	mpc_cfg_write_4(lcp, 0x100, 0x0);
	mpc_cfg_write_4(lcp, 0x114, 0x0);
	mpc_cfg_write_4(lcp, 0x128, 0x0);
	mpc_cfg_write_4(lcp, 0x13C, 0x0);

	mpc_cfg_write_4(lcp, 0xF00, 0x0);
	mpc_cfg_write_4(lcp, 0xF14, 0x0);
	mpc_cfg_write_4(lcp, 0xF28, 0x0);
	mpc_cfg_write_4(lcp, 0xF3C, 0x0);
#endif 
d262 1
a262 1
	    RAVEN_CMD_IOSP|RAVEN_CMD_MEMSP|RAVEN_CMD_MASTR);
d285 1
a285 1
vtophys(paddr_t pa)
d287 1
a287 1
	vaddr_t va = (vaddr_t) pa;
d289 2
a290 5
	if (va < VM_MIN_KERNEL_ADDRESS)
		pa = va;
	else
		if (pmap_extract(pmap_kernel(), va, &pa) != 0)
			return NULL;
d292 1
a292 1
	return pa;
d351 1
d354 1
d357 1
d385 3
d568 1
a568 1
	/* XXX We should probably do something clever here.... later */
d590 1
d604 1
d617 1
a618 1
	int s;
d631 1
a632 1
	int s;
d646 1
a647 1
	int s;
d661 1
a662 1
	int s;
@


1.14
log
@Map the raven, pcic, and isa/pci io space virtual rather than 1:1.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibr.c,v 1.13 2004/01/28 23:50:19 miod Exp $ */
a48 1
#include <machine/bat.h>
d50 2
d58 1
a101 10
/*
 * config types
 * bit meanings
 * 0 - standard cf8/cfc type configurations,
 *     sometimes the base addresses for these are different
 * 1 - Config Method #2 configuration - uni-north
 *
 * 2 - 64 bit config bus, data for accesses &4 is at daddr+4;
 */

d130 1
a130 4
#if 0
	if (strcmp(ca->ca_name, mpcpcibr_cd.cd_name) != 0)
		return (0);
#endif 
a141 1
	char *bridge;
a144 3
	/*
addbatmap(RAVEN_V_PCI_MEM_SPACE, RAVEN_P_PCI_MEM_SPACE, BAT_I);
*/
d173 2
a174 3
	printf(": Raven, Revision 0x%x.\n", 
			 mpc_cfg_read_1(lcp, RAVEN_PCI_REVID));
	bridge = "RAVEN";
d182 1
a182 3
/*	
	pba.pba_flags = PCI_FLAGS_MEM_ENABLED | PCI_FLAGS_IO_ENABLED;
*/
d185 8
a192 8
	*(unsigned int *)RAVEN_MSADD0 = RAVEN_MSADD0_PREP;
	*(unsigned int *)RAVEN_MSOFF0 = RAVEN_MSOFF0_PREP;
	*(unsigned int *)RAVEN_MSADD1 = RAVEN_MSADD1_PREP;
	*(unsigned int *)RAVEN_MSOFF1 = RAVEN_MSOFF1_PREP;
	*(unsigned int *)RAVEN_MSADD2 = RAVEN_MSADD2_PREP;
	*(unsigned int *)RAVEN_MSOFF2 = RAVEN_MSOFF2_PREP;
	*(unsigned int *)RAVEN_MSADD3 = RAVEN_MSADD3_PREP;
	*(unsigned int *)RAVEN_MSOFF3 = RAVEN_MSOFF3_PREP;
d195 1
d247 4
a250 5
		return pa;
	else {
		if (pmap_extract(pmap_kernel(), va, &pa))
			return pa;
	}
d252 1
a252 1
	return NULL;
a357 1

d362 2
d366 1
d368 1
d375 1
a375 1
		return 0xffffffff;
d384 7
d397 2
d432 1
a432 1
	if ((cp->config_type & 2) && (offset & 0x04)) {
d434 1
a434 1
	}
d457 1
a457 1

d469 1
a469 2
		/* No IRQ used. */
		error = 1;
d515 1
a515 1
											name);
@


1.13
log
@More clock handling cleanup:
- move clock callbacks outside the firmware structure
- map the clock virtual. A bit tricky because it needs to be mapped before
  autoconf...
- compensate for the removal of 1:1 segment 8 mapping
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibr.c,v 1.12 2003/12/20 22:40:27 miod Exp $ */
d127 3
d174 4
a177 2
	lcp->ioh_cf8 = PREP_CONFIG_ADD;
	lcp->ioh_cfc = PREP_CONFIG_DAT;
d537 1
a537 1
	volatile u_int8_t *iack = (u_int8_t *)RAVEN_PIACK;
d552 1
a552 2
	bus_space_write_4(cp->lc_iot, cp->ioh_cf8, 0,
							RAVEN_REGOFFS(reg));
@


1.12
log
@Pass -Wformat
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibr.c,v 1.11 2003/05/11 19:41:11 deraadt Exp $ */
d62 1
a62 1
									 struct pcibus_attach_args *);
a141 1
int pci_map_a = 0;
d253 10
a262 13
#if 0
vm_offset_t
vtophys(p)
vaddr_t p;
{
	vm_offset_t pa;
	vm_offset_t va;

	va = (vm_offset_t)p;
	if ((vm_offset_t)va < VM_MIN_KERNEL_ADDRESS) {
		pa = va;
	} else {
		pmap_extract(vm_map_pmap(phys_map), va, (paddr_t *)&pa);
a263 2
	return (pa | ((pci_map_a == 1) ? RAVEN_PCI_CPUMEM : 0 ));
}
d265 1
a265 23
#else 
vm_offset_t
vtophys(p)
vaddr_t p;
{
	vm_offset_t pa;
	vm_offset_t va;
	extern int segment8_mapped;
	extern int segmentC_mapped;

	va = (vm_offset_t)p;
	/* This crap gets maped by bats 1:1 */
	if (segment8_mapped && (va >= 0x80000000 && va < 0x90000000)) {
		pa = va;
	} else if (segmentC_mapped && (va >= 0xC0000000 && va < 0xD0000000)) {
		pa = va;
	} else if (va >= 0xF0000000) {
		pa = va;
	} else if ((vm_offset_t)va < VM_MIN_KERNEL_ADDRESS) {
			pa = va;
	} else if (pmap_extract(pmap_kernel(), va, &pa))
		return pa;
	return va;
a266 1
#endif 
a326 5
	/*
	static int spin = 0;
	while (spin > 85);
	spin++;
	*/
d501 2
a502 2
typedef void     *(intr_establish_t)(void *, pci_intr_handle_t,
														int, int, int (*func)(void *), void *, char *);
@


1.11
log
@string cleaning; krw ok
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibr.c,v 1.10 2002/06/08 15:50:01 miod Exp $ */
d523 1
a523 1
	snprintf(str, sizeof str, "irq %d", ih);
@


1.10
log
@Strict prototypes, and some KNF touches while there.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibr.c,v 1.9 2002/03/14 03:15:58 millert Exp $ */
d523 1
a523 1
	sprintf(str, "irq %d", ih);
@


1.9
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibr.c,v 1.8 2002/03/14 01:26:41 millert Exp $ */
d73 1
a73 1
											 int, int (*func)(void *), void *, char *);
d77 7
a83 12
void
mpc_cfg_write_1( struct pcibr_config *cp, u_int32_t reg, u_int8_t val);
void
mpc_cfg_write_2( struct pcibr_config *cp, u_int32_t reg, u_int16_t val);
void
mpc_cfg_write_4( struct pcibr_config *cp, u_int32_t reg, u_int32_t val);

u_int8_t
mpc_cfg_read_1( struct pcibr_config *cp, u_int32_t reg);

u_int16_t
mpc_cfg_read_2( struct pcibr_config *cp, u_int32_t reg);
d85 2
a86 2
u_int32_t
mpc_cfg_read_4( struct pcibr_config *cp, u_int32_t reg);
d96 1
a96 1
static int      mpcpcibrprint(void *, const char *pnp);
d129 2
a130 2
struct device *parent;
void *match, *aux;
d145 2
a146 2
struct device *parent, *self;
void *aux;
d232 1
a232 1
						 RAVEN_CMD_IOSP|RAVEN_CMD_MEMSP|RAVEN_CMD_MASTR);
d237 1
a237 1
static int
d239 2
a240 2
void *aux;
const char *pnp;
d299 2
a300 2
struct device *parent, *self;
struct pcibus_attach_args *pba;
d306 2
a307 2
struct ppc_pci_chipset *p;
u_int8_t *ethaddr;
d315 2
a316 2
void *cpv;
int busno;
d327 2
a328 2
void *cpv;
int bus, dev, fnc;
d335 3
a337 3
void *cpv;
pcitag_t tag;
int *busp, *devp, *fncp;
d347 1
a347 1
static u_int32_t
d349 3
a351 3
void *cpv;
pcitag_t tag;
int offset;
d400 3
a402 3
void *cpv;
pcitag_t tag;
int offset;
d451 4
a454 4
void *cpv;
pcitag_t tag;
int offset;
pcireg_t data;
d495 4
a498 4
void *lcv;
pcitag_t bustag;
int buspin, line;
pci_intr_handle_t *ihp;
d518 2
a519 2
void *lcv;
pci_intr_handle_t ih;
d543 6
a548 6
void *lcv;
pci_intr_handle_t ih;
int level;
int (*func)(void *);
void *arg;
char *name;
d556 1
a556 1
void *lcv, *cookie;
d575 3
a577 3
struct pcibr_config *cp;
u_int32_t reg;
u_int8_t val;
d589 3
a591 3
struct pcibr_config *cp;
u_int32_t reg;
u_int16_t val;
d602 3
a604 3
struct pcibr_config *cp;
u_int32_t reg;
u_int32_t val;
d616 2
a617 2
struct pcibr_config *cp;
u_int32_t reg;
d631 2
a632 2
struct pcibr_config *cp;
u_int32_t reg;
d646 2
a647 2
struct pcibr_config *cp;
u_int32_t reg;
@


1.8
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibr.c,v 1.7 2001/11/06 22:46:00 miod Exp $ */
d72 2
a73 2
void     *mpc_intr_establish __P((void *, pci_intr_handle_t,
											 int, int (*func)(void *), void *, char *));
d540 2
a541 2
typedef void     *(intr_establish_t) __P((void *, pci_intr_handle_t,
														int, int, int (*func)(void *), void *, char *));
@


1.7
log
@-Wall -Werror cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibr.c,v 1.6 2001/11/06 19:53:15 miod Exp $ */
d58 2
a59 2
int    mpcpcibrmatch __P((struct device *, void *, void *));
void   mpcpcibrattach __P((struct device *, struct device *, void *));
d61 11
a71 11
void   mpc_attach_hook __P((struct device *, struct device *,
									 struct pcibus_attach_args *));
int    mpc_bus_maxdevs __P((void *, int));
pcitag_t mpc_make_tag __P((void *, int, int, int));
void   mpc_decompose_tag __P((void *, pcitag_t, int *, int *, int *));
pcireg_t mpc_conf_read __P((void *, pcitag_t, int));
void   mpc_conf_write __P((void *, pcitag_t, int, pcireg_t));

int      mpc_intr_map __P((void *, pcitag_t, int, int, pci_intr_handle_t *));
const char *mpc_intr_string __P((void *, pci_intr_handle_t));
int	 mpc_intr_line __P((void *, pci_intr_handle_t));
d74 2
a75 2
void     mpc_intr_disestablish __P((void *, void *));
int      mpc_ether_hw_addr __P((struct ppc_pci_chipset *, u_int8_t *));
d101 1
a101 1
static int      mpcpcibrprint __P((void *, const char *pnp));
d542 1
a542 1
typedef void     (intr_disestablish_t) __P((void *, void *));
d551 1
a551 1
int (*func) __P((void *));
@


1.7.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibr.c,v 1.7 2001/11/06 22:46:00 miod Exp $ */
d58 2
a59 2
int    mpcpcibrmatch(struct device *, void *, void *);
void   mpcpcibrattach(struct device *, struct device *, void *);
d61 15
a75 23
void   mpc_attach_hook(struct device *, struct device *,
									 struct pcibus_attach_args *);
int    mpc_bus_maxdevs(void *, int);
pcitag_t mpc_make_tag(void *, int, int, int);
void   mpc_decompose_tag(void *, pcitag_t, int *, int *, int *);
pcireg_t mpc_conf_read(void *, pcitag_t, int);
void   mpc_conf_write(void *, pcitag_t, int, pcireg_t);

int      mpc_intr_map(void *, pcitag_t, int, int, pci_intr_handle_t *);
const char *mpc_intr_string(void *, pci_intr_handle_t);
int	 mpc_intr_line(void *, pci_intr_handle_t);
void     *mpc_intr_establish(void *, pci_intr_handle_t,
    int, int (*)(void *), void *, char *);
void     mpc_intr_disestablish(void *, void *);
int      mpc_ether_hw_addr(struct ppc_pci_chipset *, u_int8_t *);

void mpc_cfg_write_1(struct pcibr_config *, u_int32_t, u_int8_t);
void mpc_cfg_write_2(struct pcibr_config *, u_int32_t, u_int16_t);
void mpc_cfg_write_4(struct pcibr_config *, u_int32_t, u_int32_t);

u_int8_t mpc_cfg_read_1(struct pcibr_config *, u_int32_t);
u_int16_t mpc_cfg_read_2(struct pcibr_config *, u_int32_t);
u_int32_t mpc_cfg_read_4(struct pcibr_config *, u_int32_t);
d77 15
a91 2
u_int32_t pci_iack(void);
u_int32_t mpc_gen_config_reg(void *, pcitag_t, int);
d101 1
a101 1
int      mpcpcibrprint(void *, const char *pnp);
d134 2
a135 2
	struct device *parent;
	void *match, *aux;
d150 2
a151 2
	struct device *parent, *self;
	void *aux;
d237 1
a237 1
	    RAVEN_CMD_IOSP|RAVEN_CMD_MEMSP|RAVEN_CMD_MASTR);
d242 1
a242 1
int
d244 2
a245 2
	void *aux;
	const char *pnp;
d304 2
a305 2
	struct device *parent, *self;
	struct pcibus_attach_args *pba;
d311 2
a312 2
	struct ppc_pci_chipset *p;
	u_int8_t *ethaddr;
d320 2
a321 2
	void *cpv;
	int busno;
d332 2
a333 2
	void *cpv;
	int bus, dev, fnc;
d340 3
a342 3
	void *cpv;
	pcitag_t tag;
	int *busp, *devp, *fncp;
d352 1
a352 1
u_int32_t
d354 3
a356 3
	void *cpv;
	pcitag_t tag;
	int offset;
d405 3
a407 3
	void *cpv;
	pcitag_t tag;
	int offset;
d456 4
a459 4
	void *cpv;
	pcitag_t tag;
	int offset;
	pcireg_t data;
d500 4
a503 4
	void *lcv;
	pcitag_t bustag;
	int buspin, line;
	pci_intr_handle_t *ihp;
d523 2
a524 2
	void *lcv;
	pci_intr_handle_t ih;
d540 3
a542 3
typedef void     *(intr_establish_t)(void *, pci_intr_handle_t,
														int, int, int (*func)(void *), void *, char *);
typedef void     (intr_disestablish_t)(void *, void *);
d548 6
a553 6
	void *lcv;
	pci_intr_handle_t ih;
	int level;
	int (*func)(void *);
	void *arg;
	char *name;
d561 1
a561 1
	void *lcv, *cookie;
d580 3
a582 3
	struct pcibr_config *cp;
	u_int32_t reg;
	u_int8_t val;
d594 3
a596 3
	struct pcibr_config *cp;
	u_int32_t reg;
	u_int16_t val;
d607 3
a609 3
	struct pcibr_config *cp;
	u_int32_t reg;
	u_int32_t val;
d621 2
a622 2
	struct pcibr_config *cp;
	u_int32_t reg;
d636 2
a637 2
	struct pcibr_config *cp;
	u_int32_t reg;
d651 2
a652 2
	struct pcibr_config *cp;
	u_int32_t reg;
@


1.7.2.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d523 1
a523 1
	snprintf(str, sizeof str, "irq %d", ih);
@


1.6
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibr.c,v 1.5 2001/09/21 02:11:58 miod Exp $ */
a136 3
	struct confargs *ca = aux;
	int found = 0;

a153 1
	struct confargs *ca = aux;
a155 1
	int map, node;
a156 1
	int of_node = 0;
d394 1
a394 1
		/* config mechanism #2, type 0
a412 1
	int device;
a413 1
	int handle; 
a463 1
	int handle; 
a504 2
	struct pcibr_config *lcp = lcv;
	pci_chipset_tag_t pc = &lcp->lc_pc; 
a505 3
	int route;
	int lvl;
	int device;
@


1.5
log
@phys_map declaration comes from <vm/vm.h>, no need to declare it locally.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibr.c,v 1.4 2001/09/02 19:41:40 miod Exp $ */
d46 1
a46 1
#include <vm/vm.h>
@


1.4
log
@Fix typos, update vtophys() prototype.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibr.c,v 1.3 2001/08/17 22:26:58 mickey Exp $ */
a56 2

extern vm_map_t phys_map;
@


1.3
log
@provide a way to get the number used for irq line, not only a string
representation, this is needed for devices like cbb which pass
the interrupt line down to the cardbus attachment and not
getting the right line before pci_intr_map() has done it's
dirty deed.
tested on i386 by jason@@, compiles on alpha by art@@.
ppc and mveppc are to be test-compiled, but should work (;
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibr.c,v 1.2 2001/07/06 05:14:31 smurph Exp $ */
d264 2
a265 2
 *  Get PCI physical address from given viritual address.
 *  XXX Note that cross page boundarys are *not* garantueed to work!
d270 1
a270 1
void *p;
d287 1
a287 1
void *p;
@


1.2
log
@resolve compile problems
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibus.c,v 1.23 2001/03/03 05:40:01 drahn Exp $ */
d73 1
d193 1
d546 8
@


1.1
log
@Initial import of mvmeppc.
@
text
@d64 1
a64 1
                            struct pcibus_attach_args *));
d74 1
a74 1
                                  int, int (*func)(void *), void *, char *));
d95 1
a95 1
        sizeof(struct pcibr_softc), mpcpcibrmatch, mpcpcibrattach,
d99 1
a99 1
        NULL, "mpcpcibr", DV_DULL,
d117 14
a130 14
        NULL,
        _bus_dmamap_create,
        _bus_dmamap_destroy,
        _bus_dmamap_load,
        _bus_dmamap_load_mbuf,
        _bus_dmamap_load_uio,
        _bus_dmamap_load_raw,
        _bus_dmamap_unload,
        _bus_dmamap_sync,
        _bus_dmamem_alloc,
        _bus_dmamem_free,
        _bus_dmamem_map,
        _bus_dmamem_unmap,
        _bus_dmamem_mmap
d138 2
a139 2
        struct confargs *ca = aux;
        int found = 0;
d141 3
a143 3
        /* We must be a child of the raven device */
        if (strcmp(parent->dv_cfdata->cf_driver->cd_name, "raven") != 0)
                return (0);
d145 2
a146 2
        if (strcmp(ca->ca_name, mpcpcibr_cd.cd_name) != 0)
                return (0);
d148 1
a148 1
        return 1;
d157 7
a163 7
        struct pcibr_softc *sc = (struct pcibr_softc *)self;
        struct confargs *ca = aux;
        struct pcibr_config *lcp;
        struct pcibus_attach_args pba;
        int map, node;
        char *bridge;
        int of_node = 0;
d165 1
a165 1
        lcp = sc->sc_pcibr = &mpc_config;
d167 5
a171 5
        /*
	addbatmap(RAVEN_V_PCI_MEM_SPACE, RAVEN_P_PCI_MEM_SPACE, BAT_I);
	*/
        sc->sc_membus_space = prep_mem_space_tag;
        sc->sc_iobus_space = prep_io_space_tag;
d173 32
a204 32
        lcp->lc_pc.pc_conf_v = lcp;
        lcp->lc_pc.pc_attach_hook = mpc_attach_hook;
        lcp->lc_pc.pc_bus_maxdevs = mpc_bus_maxdevs;
        lcp->lc_pc.pc_make_tag = mpc_make_tag;
        lcp->lc_pc.pc_decompose_tag = mpc_decompose_tag;
        lcp->lc_pc.pc_conf_read = mpc_conf_read;
        lcp->lc_pc.pc_conf_write = mpc_conf_write;
        lcp->lc_pc.pc_ether_hw_addr = mpc_ether_hw_addr;
        lcp->lc_iot = &sc->sc_iobus_space;
        lcp->lc_memt = &sc->sc_membus_space;

        lcp->ioh_cf8 = PREP_CONFIG_ADD;
        lcp->ioh_cfc = PREP_CONFIG_DAT;

        lcp->config_type = 0;

        lcp->lc_pc.pc_intr_v = lcp;
        lcp->lc_pc.pc_intr_map = mpc_intr_map;
        lcp->lc_pc.pc_intr_string = mpc_intr_string;
        lcp->lc_pc.pc_intr_establish = mpc_intr_establish;
        lcp->lc_pc.pc_intr_disestablish = mpc_intr_disestablish;

        printf(": Raven, Revision 0x%x.\n", 
               mpc_cfg_read_1(lcp, RAVEN_PCI_REVID));
        bridge = "RAVEN";
        pba.pba_dmat = &pci_bus_dma_tag;

        pba.pba_busname = "pci";
        pba.pba_iot = &sc->sc_iobus_space;
        pba.pba_memt = &sc->sc_membus_space;
        pba.pba_pc = &lcp->lc_pc;
        pba.pba_bus = 0; 
d206 1
a206 1
   pba.pba_flags = PCI_FLAGS_MEM_ENABLED | PCI_FLAGS_IO_ENABLED;
d208 32
a239 32
#if 1
        /* set up prep environment */
        *(unsigned int *)RAVEN_MSADD0 = RAVEN_MSADD0_PREP;
        *(unsigned int *)RAVEN_MSOFF0 = RAVEN_MSOFF0_PREP;
        *(unsigned int *)RAVEN_MSADD1 = RAVEN_MSADD1_PREP;
        *(unsigned int *)RAVEN_MSOFF1 = RAVEN_MSOFF1_PREP;
        *(unsigned int *)RAVEN_MSADD2 = RAVEN_MSADD2_PREP;
        *(unsigned int *)RAVEN_MSOFF2 = RAVEN_MSOFF2_PREP;
        *(unsigned int *)RAVEN_MSADD3 = RAVEN_MSADD3_PREP;
        *(unsigned int *)RAVEN_MSOFF3 = RAVEN_MSOFF3_PREP;

        /* set up PCI local bus */
        mpc_cfg_write_4(lcp, RAVEN_PCI_PSADD0, RAVEN_PCI_PSADD0_VAL);
        mpc_cfg_write_4(lcp, RAVEN_PCI_PSOFF0, RAVEN_PCI_PSOFF0_VAL);
        mpc_cfg_write_4(lcp, RAVEN_PCI_PSADD1, RAVEN_PCI_PSADD1_VAL);
        mpc_cfg_write_4(lcp, RAVEN_PCI_PSOFF1, RAVEN_PCI_PSOFF1_VAL);
        mpc_cfg_write_4(lcp, RAVEN_PCI_PSADD2, RAVEN_PCI_PSADD2_VAL);
        mpc_cfg_write_4(lcp, RAVEN_PCI_PSOFF2, RAVEN_PCI_PSOFF2_VAL);
        mpc_cfg_write_4(lcp, RAVEN_PCI_PSADD3, RAVEN_PCI_PSADD3_VAL);
        mpc_cfg_write_4(lcp, RAVEN_PCI_PSOFF3, RAVEN_PCI_PSOFF3_VAL);

        /* set up VME -> PCI local bus */

        mpc_cfg_write_4(lcp, 0x100, 0x0);
        mpc_cfg_write_4(lcp, 0x114, 0x0);
        mpc_cfg_write_4(lcp, 0x128, 0x0);
        mpc_cfg_write_4(lcp, 0x13C, 0x0);

        mpc_cfg_write_4(lcp, 0xF00, 0x0);
        mpc_cfg_write_4(lcp, 0xF14, 0x0);
        mpc_cfg_write_4(lcp, 0xF28, 0x0);
        mpc_cfg_write_4(lcp, 0xF3C, 0x0);
d241 3
a243 3
        /* enable mem and io mapping, and bus master */
        mpc_cfg_write_2(lcp, RAVEN_PCI_CMD, 
                        RAVEN_CMD_IOSP|RAVEN_CMD_MEMSP|RAVEN_CMD_MASTR);
d245 1
a245 1
        config_found(self, &pba, mpcpcibrprint);
d253 1
a253 1
        struct pcibus_attach_args *pba = aux;
d255 4
a258 4
        if (pnp)
                printf("%s at %s", pba->pba_busname, pnp);
        printf(" bus %d", pba->pba_bus);
        return (UNCONF);
d270 2
a271 2
        vm_offset_t pa;
        vm_offset_t va;
d273 7
a279 7
        va = (vm_offset_t)p;
        if ((vm_offset_t)va < VM_MIN_KERNEL_ADDRESS) {
                pa = va;
        } else {
                pmap_extract(vm_map_pmap(phys_map), va, (paddr_t *)&pa);
        }
        return (pa | ((pci_map_a == 1) ? RAVEN_PCI_CPUMEM : 0 ));
d285 1
a285 1
	void *p;
d287 2
a288 2
        vm_offset_t pa;
        vm_offset_t va;
d292 4
a295 6
        va = (vm_offset_t)p;
        /* This crap gets maped by bats 1:1 */
        if ((vm_offset_t)va < VM_MIN_KERNEL_ADDRESS) {
                pa = va;
        } else if (segment8_mapped && (va >= 0x80000000 && va < 0x90000000)) {
                pa = va;
d297 5
a301 1
                pa = va;
d303 2
a304 2
                return pa;
        return va;
d320 2
a321 2
        printf("mpc_ether_hw_addr not supported\n");
        return (0);
d329 1
a329 1
        return (32);
d341 1
a341 1
        return (bus << BUS_SHIFT) | (dev << DEVICE_SHIFT) | (fnc << FNC_SHIFT);
d350 6
a355 6
        if (busp != NULL)
                *busp = (tag >> BUS_SHIFT) & 0xff;
        if (devp != NULL)
                *devp = (tag >> DEVICE_SHIFT) & 0x1f;
        if (fncp != NULL)
                *fncp = (tag >> FNC_SHIFT) & 0x7;
d364 39
a402 39
        struct pcibr_config *cp = cpv;
        unsigned int bus, dev, fcn;
        u_int32_t reg;
        /*
        static int spin = 0;
        while (spin > 85);
        spin++;
        */

        mpc_decompose_tag(cpv, tag, &bus, &dev, &fcn);

        if (cp->config_type & 1) {
                /* Config Mechanism #2 */
                if (bus == 0) {
                        if (dev < 11) {
                                return 0xffffffff;
                        }
                        /*
                         * Need to do config type 0 operation
                         *  1 << (11?+dev) | fcn << 8 | reg
                         * 11? is because pci spec states
                         * that 11-15 is reserved.
                         */
                        reg = 1 << (dev) | fcn << 8 | offset;

                } else {
                        if (dev > 15) {
                                return 0xffffffff;
                        }
                        /*
                         * config type 1 
                         */
                        reg =  tag  | offset | 1;

                }
        } else {
                /* config mechanism #2, type 0
                /* standard cf8/cfc config */
                reg =  0x80000000 | tag  | offset;
d404 2
a405 2
        }
        return reg;
d415 1
a415 1
        struct pcibr_config *cp = cpv;
d417 29
a445 29
        pcireg_t data;
        u_int32_t reg;
        int device;
        int s;
        int handle; 
        int daddr = 0;

        if (offset & 3 || offset < 0 || offset >= 0x100) {
                printf ("pci_conf_read: bad reg %x\n", offset);
                return (~0);
        }

        reg = mpc_gen_config_reg(cpv, tag, offset);
        /* if invalid tag, return -1 */
        if (reg == 0xffffffff) {
                return 0xffffffff;
        }

        if ((cp->config_type & 2) && (offset & 0x04)) {
                daddr += 4;
        }

        s = splhigh();

        bus_space_write_4(cp->lc_iot, cp->ioh_cf8, 0, reg);
        bus_space_read_4(cp->lc_iot, cp->ioh_cf8, 0); /* XXX */
        data = bus_space_read_4(cp->lc_iot, cp->ioh_cfc, daddr);
        bus_space_write_4(cp->lc_iot, cp->ioh_cf8, 0, 0); /* disable */
        bus_space_read_4(cp->lc_iot, cp->ioh_cf8, 0); /* XXX */
d447 1
a447 1
        splx(s);
d449 8
a456 8
        if (!((offset == 0) && (data == 0xffffffff))) {
                unsigned int bus, dev, fcn;
                mpc_decompose_tag(cpv, tag, &bus, &dev, &fcn);
                printf("mpc_conf_read bus %x dev %x fcn %x offset %x", bus, dev, fcn,
                       offset);
                printf(" daddr %x reg %x",daddr, reg);
                printf(" data %x\n", data);
        }
d459 1
a459 1
        return (data);
d469 15
a483 15
        struct pcibr_config *cp = cpv;
        u_int32_t reg;
        int s;
        int handle; 
        int daddr = 0;

        reg = mpc_gen_config_reg(cpv, tag, offset);

        /* if invalid tag, return ??? */
        if (reg == 0xffffffff) {
                return;
        }
        if ((cp->config_type & 2) && (offset & 0x04)) {
                daddr += 4;
        }
d485 8
a492 8
        {
                unsigned int bus, dev, fcn;
                mpc_decompose_tag(cpv, tag, &bus, &dev, &fcn);
                printf("mpc_conf_write bus %x dev %x fcn %x offset %x", bus,
                       dev, fcn, offset);
                printf(" daddr %x reg %x",daddr, reg);
                printf(" data %x\n", data);
        }
d495 1
a495 1
        s = splhigh();
d497 5
a501 5
        bus_space_write_4(cp->lc_iot, cp->ioh_cf8, 0, reg);
        bus_space_read_4(cp->lc_iot, cp->ioh_cf8, 0); /* XXX */
        bus_space_write_4(cp->lc_iot, cp->ioh_cfc, daddr, data);
        bus_space_write_4(cp->lc_iot, cp->ioh_cf8, 0, 0); /* disable */
        bus_space_read_4(cp->lc_iot, cp->ioh_cf8, 0); /* XXX */
d503 1
a503 1
        splx(s);
d514 19
a532 19
        struct pcibr_config *lcp = lcv;
        pci_chipset_tag_t pc = &lcp->lc_pc; 
        int error = 0;
        int route;
        int lvl;
        int device;

        *ihp = -1;
        if (buspin == 0) {
                /* No IRQ used. */
                error = 1;
        } else if (buspin > 4) {
                printf("mpc_intr_map: bad interrupt pin %d\n", buspin);
                error = 1;
        }

        if (!error)
                *ihp = line;
        return error;
d540 1
a540 1
        static char str[16];
d542 2
a543 2
        sprintf(str, "irq %d", ih);
        return (str);
d547 1
a547 1
                                          int, int, int (*func)(void *), void *, char *));
d561 2
a562 2
        return (*intr_establish_func)(lcv, ih, IST_LEVEL, level, func, arg,
                                      name);
d569 1
a569 1
        /* XXX We should probably do something clever here.... later */
d575 4
a578 4
        /* do pci IACK cycle */
        /* this should be bus allocated. */
        volatile u_int8_t *iack = (u_int8_t *)RAVEN_PIACK;
        u_int8_t val;
d580 2
a581 2
        val = *iack;
        return val;
d590 6
a595 6
        int s;
        s = splhigh();
        bus_space_write_4(cp->lc_iot, cp->ioh_cf8, 0,
                          RAVEN_REGOFFS(reg));
        bus_space_write_1(cp->lc_iot, cp->ioh_cfc, 0, val);
        splx(s);
d604 5
a608 5
        int s;
        s = splhigh();
        bus_space_write_4(cp->lc_iot, cp->ioh_cf8, 0, RAVEN_REGOFFS(reg));
        bus_space_write_2(cp->lc_iot, cp->ioh_cfc, 0, val);
        splx(s);
d618 5
a622 5
        int s;
        s = splhigh();
        bus_space_write_4(cp->lc_iot, cp->ioh_cf8, 0, RAVEN_REGOFFS(reg));
        bus_space_write_4(cp->lc_iot, cp->ioh_cfc, 0, val);
        splx(s);
d630 1
a630 1
        u_int8_t _v_;
d632 6
a637 6
        int s;
        s = splhigh();
        bus_space_write_4(cp->lc_iot, cp->ioh_cf8, 0, RAVEN_REGOFFS(reg));
        _v_ = bus_space_read_1(cp->lc_iot, cp->ioh_cfc, 0);
        splx(s);
        return (_v_);
d645 1
a645 1
        u_int16_t _v_;
d647 6
a652 6
        int s;
        s = splhigh();
        bus_space_write_4(cp->lc_iot, cp->ioh_cf8, 0, RAVEN_REGOFFS(reg));
        _v_ = bus_space_read_2(cp->lc_iot, cp->ioh_cfc, 0);
        splx(s);
        return (_v_);
d660 1
a660 1
        u_int32_t _v_;
d662 6
a667 6
        int s;
        s = splhigh();
        bus_space_write_4(cp->lc_iot, cp->ioh_cf8, 0, RAVEN_REGOFFS(reg));
        _v_ = bus_space_read_4(cp->lc_iot, cp->ioh_cfc, 0);
        splx(s);
        return (_v_);
@


1.1.2.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibr.c,v 1.1 2001/06/26 21:57:56 smurph Exp $ */
d58 2
d64 1
a64 1
									 struct pcibus_attach_args *));
a72 1
int	 mpc_intr_line __P((void *, pci_intr_handle_t));
d74 1
a74 1
											 int, int (*func)(void *), void *, char *));
d95 1
a95 1
	sizeof(struct pcibr_softc), mpcpcibrmatch, mpcpcibrattach,
d99 1
a99 1
	NULL, "mpcpcibr", DV_DULL,
d117 14
a130 14
	NULL,
	_bus_dmamap_create,
	_bus_dmamap_destroy,
	_bus_dmamap_load,
	_bus_dmamap_load_mbuf,
	_bus_dmamap_load_uio,
	_bus_dmamap_load_raw,
	_bus_dmamap_unload,
	_bus_dmamap_sync,
	_bus_dmamem_alloc,
	_bus_dmamem_free,
	_bus_dmamem_map,
	_bus_dmamem_unmap,
	_bus_dmamem_mmap
d138 2
a139 2
	struct confargs *ca = aux;
	int found = 0;
d141 3
a143 3
	/* We must be a child of the raven device */
	if (strcmp(parent->dv_cfdata->cf_driver->cd_name, "raven") != 0)
		return (0);
d145 2
a146 2
	if (strcmp(ca->ca_name, mpcpcibr_cd.cd_name) != 0)
		return (0);
d148 1
a148 1
	return 1;
d157 7
a163 7
	struct pcibr_softc *sc = (struct pcibr_softc *)self;
	struct confargs *ca = aux;
	struct pcibr_config *lcp;
	struct pcibus_attach_args pba;
	int map, node;
	char *bridge;
	int of_node = 0;
d165 1
a165 1
	lcp = sc->sc_pcibr = &mpc_config;
d167 5
a171 5
	/*
addbatmap(RAVEN_V_PCI_MEM_SPACE, RAVEN_P_PCI_MEM_SPACE, BAT_I);
*/
	sc->sc_membus_space = prep_mem_space_tag;
	sc->sc_iobus_space = prep_io_space_tag;
d173 32
a204 33
	lcp->lc_pc.pc_conf_v = lcp;
	lcp->lc_pc.pc_attach_hook = mpc_attach_hook;
	lcp->lc_pc.pc_bus_maxdevs = mpc_bus_maxdevs;
	lcp->lc_pc.pc_make_tag = mpc_make_tag;
	lcp->lc_pc.pc_decompose_tag = mpc_decompose_tag;
	lcp->lc_pc.pc_conf_read = mpc_conf_read;
	lcp->lc_pc.pc_conf_write = mpc_conf_write;
	lcp->lc_pc.pc_ether_hw_addr = mpc_ether_hw_addr;
	lcp->lc_iot = &sc->sc_iobus_space;
	lcp->lc_memt = &sc->sc_membus_space;

	lcp->ioh_cf8 = PREP_CONFIG_ADD;
	lcp->ioh_cfc = PREP_CONFIG_DAT;

	lcp->config_type = 0;

	lcp->lc_pc.pc_intr_v = lcp;
	lcp->lc_pc.pc_intr_map = mpc_intr_map;
	lcp->lc_pc.pc_intr_string = mpc_intr_string;
	lcp->lc_pc.pc_intr_line = mpc_intr_line;
	lcp->lc_pc.pc_intr_establish = mpc_intr_establish;
	lcp->lc_pc.pc_intr_disestablish = mpc_intr_disestablish;

	printf(": Raven, Revision 0x%x.\n", 
			 mpc_cfg_read_1(lcp, RAVEN_PCI_REVID));
	bridge = "RAVEN";
	pba.pba_dmat = &pci_bus_dma_tag;

	pba.pba_busname = "pci";
	pba.pba_iot = &sc->sc_iobus_space;
	pba.pba_memt = &sc->sc_membus_space;
	pba.pba_pc = &lcp->lc_pc;
	pba.pba_bus = 0; 
d206 1
a206 1
	pba.pba_flags = PCI_FLAGS_MEM_ENABLED | PCI_FLAGS_IO_ENABLED;
d208 32
a239 32
#if 0
	/* set up prep environment */
	*(unsigned int *)RAVEN_MSADD0 = RAVEN_MSADD0_PREP;
	*(unsigned int *)RAVEN_MSOFF0 = RAVEN_MSOFF0_PREP;
	*(unsigned int *)RAVEN_MSADD1 = RAVEN_MSADD1_PREP;
	*(unsigned int *)RAVEN_MSOFF1 = RAVEN_MSOFF1_PREP;
	*(unsigned int *)RAVEN_MSADD2 = RAVEN_MSADD2_PREP;
	*(unsigned int *)RAVEN_MSOFF2 = RAVEN_MSOFF2_PREP;
	*(unsigned int *)RAVEN_MSADD3 = RAVEN_MSADD3_PREP;
	*(unsigned int *)RAVEN_MSOFF3 = RAVEN_MSOFF3_PREP;

	/* set up PCI local bus */
	mpc_cfg_write_4(lcp, RAVEN_PCI_PSADD0, RAVEN_PCI_PSADD0_VAL);
	mpc_cfg_write_4(lcp, RAVEN_PCI_PSOFF0, RAVEN_PCI_PSOFF0_VAL);
	mpc_cfg_write_4(lcp, RAVEN_PCI_PSADD1, RAVEN_PCI_PSADD1_VAL);
	mpc_cfg_write_4(lcp, RAVEN_PCI_PSOFF1, RAVEN_PCI_PSOFF1_VAL);
	mpc_cfg_write_4(lcp, RAVEN_PCI_PSADD2, RAVEN_PCI_PSADD2_VAL);
	mpc_cfg_write_4(lcp, RAVEN_PCI_PSOFF2, RAVEN_PCI_PSOFF2_VAL);
	mpc_cfg_write_4(lcp, RAVEN_PCI_PSADD3, RAVEN_PCI_PSADD3_VAL);
	mpc_cfg_write_4(lcp, RAVEN_PCI_PSOFF3, RAVEN_PCI_PSOFF3_VAL);

	/* set up VME -> PCI local bus */

	mpc_cfg_write_4(lcp, 0x100, 0x0);
	mpc_cfg_write_4(lcp, 0x114, 0x0);
	mpc_cfg_write_4(lcp, 0x128, 0x0);
	mpc_cfg_write_4(lcp, 0x13C, 0x0);

	mpc_cfg_write_4(lcp, 0xF00, 0x0);
	mpc_cfg_write_4(lcp, 0xF14, 0x0);
	mpc_cfg_write_4(lcp, 0xF28, 0x0);
	mpc_cfg_write_4(lcp, 0xF3C, 0x0);
d241 3
a243 3
	/* enable mem and io mapping, and bus master */
	mpc_cfg_write_2(lcp, RAVEN_PCI_CMD, 
						 RAVEN_CMD_IOSP|RAVEN_CMD_MEMSP|RAVEN_CMD_MASTR);
d245 1
a245 1
	config_found(self, &pba, mpcpcibrprint);
d253 1
a253 1
	struct pcibus_attach_args *pba = aux;
d255 4
a258 4
	if (pnp)
		printf("%s at %s", pba->pba_busname, pnp);
	printf(" bus %d", pba->pba_bus);
	return (UNCONF);
d262 2
a263 2
 *  Get PCI physical address from given virtual address.
 *  XXX Note that cross page boundaries are *not* guaranteed to work!
d268 1
a268 1
vaddr_t p;
d270 2
a271 2
	vm_offset_t pa;
	vm_offset_t va;
d273 7
a279 7
	va = (vm_offset_t)p;
	if ((vm_offset_t)va < VM_MIN_KERNEL_ADDRESS) {
		pa = va;
	} else {
		pmap_extract(vm_map_pmap(phys_map), va, (paddr_t *)&pa);
	}
	return (pa | ((pci_map_a == 1) ? RAVEN_PCI_CPUMEM : 0 ));
d285 1
a285 1
vaddr_t p;
d287 2
a288 2
	vm_offset_t pa;
	vm_offset_t va;
d292 6
a297 4
	va = (vm_offset_t)p;
	/* This crap gets maped by bats 1:1 */
	if (segment8_mapped && (va >= 0x80000000 && va < 0x90000000)) {
		pa = va;
d299 1
a299 5
		pa = va;
	} else if (va >= 0xF0000000) {
		pa = va;
	} else if ((vm_offset_t)va < VM_MIN_KERNEL_ADDRESS) {
			pa = va;
d301 2
a302 2
		return pa;
	return va;
d318 2
a319 2
	printf("mpc_ether_hw_addr not supported\n");
	return (0);
d327 1
a327 1
	return (32);
d339 1
a339 1
	return (bus << BUS_SHIFT) | (dev << DEVICE_SHIFT) | (fnc << FNC_SHIFT);
d348 6
a353 6
	if (busp != NULL)
		*busp = (tag >> BUS_SHIFT) & 0xff;
	if (devp != NULL)
		*devp = (tag >> DEVICE_SHIFT) & 0x1f;
	if (fncp != NULL)
		*fncp = (tag >> FNC_SHIFT) & 0x7;
d362 39
a400 10
	struct pcibr_config *cp = cpv;
	unsigned int bus, dev, fcn;
	u_int32_t reg;
	/*
	static int spin = 0;
	while (spin > 85);
	spin++;
	*/

	mpc_decompose_tag(cpv, tag, &bus, &dev, &fcn);
d402 2
a403 31
	if (cp->config_type & 1) {
		/* Config Mechanism #2 */
		if (bus == 0) {
			if (dev < 11) {
				return 0xffffffff;
			}
			/*
			 * Need to do config type 0 operation
			 *  1 << (11?+dev) | fcn << 8 | reg
			 * 11? is because pci spec states
			 * that 11-15 is reserved.
			 */
			reg = 1 << (dev) | fcn << 8 | offset;

		} else {
			if (dev > 15) {
				return 0xffffffff;
			}
			/*
			 * config type 1 
			 */
			reg =  tag  | offset | 1;

		}
	} else {
		/* config mechanism #2, type 0
		/* standard cf8/cfc config */
		reg =  0x80000000 | tag  | offset;

	}
	return reg;
d413 1
a413 1
	struct pcibr_config *cp = cpv;
d415 29
a443 29
	pcireg_t data;
	u_int32_t reg;
	int device;
	int s;
	int handle; 
	int daddr = 0;

	if (offset & 3 || offset < 0 || offset >= 0x100) {
		printf ("pci_conf_read: bad reg %x\n", offset);
		return (~0);
	}

	reg = mpc_gen_config_reg(cpv, tag, offset);
	/* if invalid tag, return -1 */
	if (reg == 0xffffffff) {
		return 0xffffffff;
	}

	if ((cp->config_type & 2) && (offset & 0x04)) {
		daddr += 4;
	}

	s = splhigh();

	bus_space_write_4(cp->lc_iot, cp->ioh_cf8, 0, reg);
	bus_space_read_4(cp->lc_iot, cp->ioh_cf8, 0); /* XXX */
	data = bus_space_read_4(cp->lc_iot, cp->ioh_cfc, daddr);
	bus_space_write_4(cp->lc_iot, cp->ioh_cf8, 0, 0); /* disable */
	bus_space_read_4(cp->lc_iot, cp->ioh_cf8, 0); /* XXX */
d445 1
a445 1
	splx(s);
d447 8
a454 8
	if (!((offset == 0) && (data == 0xffffffff))) {
		unsigned int bus, dev, fcn;
		mpc_decompose_tag(cpv, tag, &bus, &dev, &fcn);
		printf("mpc_conf_read bus %x dev %x fcn %x offset %x", bus, dev, fcn,
				 offset);
		printf(" daddr %x reg %x",daddr, reg);
		printf(" data %x\n", data);
	}
d457 1
a457 1
	return (data);
d467 15
a481 15
	struct pcibr_config *cp = cpv;
	u_int32_t reg;
	int s;
	int handle; 
	int daddr = 0;

	reg = mpc_gen_config_reg(cpv, tag, offset);

	/* if invalid tag, return ??? */
	if (reg == 0xffffffff) {
		return;
	}
	if ((cp->config_type & 2) && (offset & 0x04)) {
		daddr += 4;
	}
d483 8
a490 8
	{
		unsigned int bus, dev, fcn;
		mpc_decompose_tag(cpv, tag, &bus, &dev, &fcn);
		printf("mpc_conf_write bus %x dev %x fcn %x offset %x", bus,
				 dev, fcn, offset);
		printf(" daddr %x reg %x",daddr, reg);
		printf(" data %x\n", data);
	}
d493 1
a493 1
	s = splhigh();
d495 5
a499 5
	bus_space_write_4(cp->lc_iot, cp->ioh_cf8, 0, reg);
	bus_space_read_4(cp->lc_iot, cp->ioh_cf8, 0); /* XXX */
	bus_space_write_4(cp->lc_iot, cp->ioh_cfc, daddr, data);
	bus_space_write_4(cp->lc_iot, cp->ioh_cf8, 0, 0); /* disable */
	bus_space_read_4(cp->lc_iot, cp->ioh_cf8, 0); /* XXX */
d501 1
a501 1
	splx(s);
d512 19
a530 19
	struct pcibr_config *lcp = lcv;
	pci_chipset_tag_t pc = &lcp->lc_pc; 
	int error = 0;
	int route;
	int lvl;
	int device;

	*ihp = -1;
	if (buspin == 0) {
		/* No IRQ used. */
		error = 1;
	} else if (buspin > 4) {
		printf("mpc_intr_map: bad interrupt pin %d\n", buspin);
		error = 1;
	}

	if (!error)
		*ihp = line;
	return error;
d538 1
a538 5
	static char str[16];

	sprintf(str, "irq %d", ih);
	return (str);
}
d540 2
a541 6
int
mpc_intr_line(lcv, ih)
	void *lcv;
	pci_intr_handle_t ih;
{
	return (ih);
d545 1
a545 1
														int, int, int (*func)(void *), void *, char *));
d559 2
a560 2
	return (*intr_establish_func)(lcv, ih, IST_LEVEL, level, func, arg,
											name);
d567 1
a567 1
	/* XXX We should probably do something clever here.... later */
d573 4
a576 4
	/* do pci IACK cycle */
	/* this should be bus allocated. */
	volatile u_int8_t *iack = (u_int8_t *)RAVEN_PIACK;
	u_int8_t val;
d578 2
a579 2
	val = *iack;
	return val;
d588 6
a593 6
	int s;
	s = splhigh();
	bus_space_write_4(cp->lc_iot, cp->ioh_cf8, 0,
							RAVEN_REGOFFS(reg));
	bus_space_write_1(cp->lc_iot, cp->ioh_cfc, 0, val);
	splx(s);
d602 5
a606 5
	int s;
	s = splhigh();
	bus_space_write_4(cp->lc_iot, cp->ioh_cf8, 0, RAVEN_REGOFFS(reg));
	bus_space_write_2(cp->lc_iot, cp->ioh_cfc, 0, val);
	splx(s);
d616 5
a620 5
	int s;
	s = splhigh();
	bus_space_write_4(cp->lc_iot, cp->ioh_cf8, 0, RAVEN_REGOFFS(reg));
	bus_space_write_4(cp->lc_iot, cp->ioh_cfc, 0, val);
	splx(s);
d628 1
a628 1
	u_int8_t _v_;
d630 6
a635 6
	int s;
	s = splhigh();
	bus_space_write_4(cp->lc_iot, cp->ioh_cf8, 0, RAVEN_REGOFFS(reg));
	_v_ = bus_space_read_1(cp->lc_iot, cp->ioh_cfc, 0);
	splx(s);
	return (_v_);
d643 1
a643 1
	u_int16_t _v_;
d645 6
a650 6
	int s;
	s = splhigh();
	bus_space_write_4(cp->lc_iot, cp->ioh_cf8, 0, RAVEN_REGOFFS(reg));
	_v_ = bus_space_read_2(cp->lc_iot, cp->ioh_cfc, 0);
	splx(s);
	return (_v_);
d658 1
a658 1
	u_int32_t _v_;
d660 6
a665 6
	int s;
	s = splhigh();
	bus_space_write_4(cp->lc_iot, cp->ioh_cf8, 0, RAVEN_REGOFFS(reg));
	_v_ = bus_space_read_4(cp->lc_iot, cp->ioh_cfc, 0);
	splx(s);
	return (_v_);
@


1.1.2.2
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d46 1
a46 1
#include <uvm/uvm_extern.h>
d137 3
d157 1
d160 1
d162 1
d400 1
a400 1
		/* config mechanism #2, type 0 */
d419 1
d421 1
d472 1
d514 2
d517 3
@


1.1.2.3
log
@Merge in -current from about a week ago
@
text
@d58 2
a59 2
int    mpcpcibrmatch(struct device *, void *, void *);
void   mpcpcibrattach(struct device *, struct device *, void *);
d61 15
a75 15
void   mpc_attach_hook(struct device *, struct device *,
									 struct pcibus_attach_args *);
int    mpc_bus_maxdevs(void *, int);
pcitag_t mpc_make_tag(void *, int, int, int);
void   mpc_decompose_tag(void *, pcitag_t, int *, int *, int *);
pcireg_t mpc_conf_read(void *, pcitag_t, int);
void   mpc_conf_write(void *, pcitag_t, int, pcireg_t);

int      mpc_intr_map(void *, pcitag_t, int, int, pci_intr_handle_t *);
const char *mpc_intr_string(void *, pci_intr_handle_t);
int	 mpc_intr_line(void *, pci_intr_handle_t);
void     *mpc_intr_establish(void *, pci_intr_handle_t,
											 int, int (*func)(void *), void *, char *);
void     mpc_intr_disestablish(void *, void *);
int      mpc_ether_hw_addr(struct ppc_pci_chipset *, u_int8_t *);
d101 1
a101 1
static int      mpcpcibrprint(void *, const char *pnp);
d540 3
a542 3
typedef void     *(intr_establish_t)(void *, pci_intr_handle_t,
														int, int, int (*func)(void *), void *, char *);
typedef void     (intr_disestablish_t)(void *, void *);
d551 1
a551 1
int (*func)(void *);
@


1.1.2.4
log
@Sync the SMP branch with 3.3
@
text
@d73 1
a73 1
    int, int (*)(void *), void *, char *);
d77 12
a88 7
void mpc_cfg_write_1(struct pcibr_config *, u_int32_t, u_int8_t);
void mpc_cfg_write_2(struct pcibr_config *, u_int32_t, u_int16_t);
void mpc_cfg_write_4(struct pcibr_config *, u_int32_t, u_int32_t);

u_int8_t mpc_cfg_read_1(struct pcibr_config *, u_int32_t);
u_int16_t mpc_cfg_read_2(struct pcibr_config *, u_int32_t);
u_int32_t mpc_cfg_read_4(struct pcibr_config *, u_int32_t);
d90 2
a91 2
u_int32_t pci_iack(void);
u_int32_t mpc_gen_config_reg(void *, pcitag_t, int);
d101 1
a101 1
int      mpcpcibrprint(void *, const char *pnp);
d134 2
a135 2
	struct device *parent;
	void *match, *aux;
d150 2
a151 2
	struct device *parent, *self;
	void *aux;
d237 1
a237 1
	    RAVEN_CMD_IOSP|RAVEN_CMD_MEMSP|RAVEN_CMD_MASTR);
d242 1
a242 1
int
d244 2
a245 2
	void *aux;
	const char *pnp;
d304 2
a305 2
	struct device *parent, *self;
	struct pcibus_attach_args *pba;
d311 2
a312 2
	struct ppc_pci_chipset *p;
	u_int8_t *ethaddr;
d320 2
a321 2
	void *cpv;
	int busno;
d332 2
a333 2
	void *cpv;
	int bus, dev, fnc;
d340 3
a342 3
	void *cpv;
	pcitag_t tag;
	int *busp, *devp, *fncp;
d352 1
a352 1
u_int32_t
d354 3
a356 3
	void *cpv;
	pcitag_t tag;
	int offset;
d405 3
a407 3
	void *cpv;
	pcitag_t tag;
	int offset;
d456 4
a459 4
	void *cpv;
	pcitag_t tag;
	int offset;
	pcireg_t data;
d500 4
a503 4
	void *lcv;
	pcitag_t bustag;
	int buspin, line;
	pci_intr_handle_t *ihp;
d523 2
a524 2
	void *lcv;
	pci_intr_handle_t ih;
d548 6
a553 6
	void *lcv;
	pci_intr_handle_t ih;
	int level;
	int (*func)(void *);
	void *arg;
	char *name;
d561 1
a561 1
	void *lcv, *cookie;
d580 3
a582 3
	struct pcibr_config *cp;
	u_int32_t reg;
	u_int8_t val;
d594 3
a596 3
	struct pcibr_config *cp;
	u_int32_t reg;
	u_int16_t val;
d607 3
a609 3
	struct pcibr_config *cp;
	u_int32_t reg;
	u_int32_t val;
d621 2
a622 2
	struct pcibr_config *cp;
	u_int32_t reg;
d636 2
a637 2
	struct pcibr_config *cp;
	u_int32_t reg;
d651 2
a652 2
	struct pcibr_config *cp;
	u_int32_t reg;
@


1.1.2.5
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibr.c,v 1.1.2.4 2003/03/27 23:52:17 niklas Exp $ */
d523 1
a523 1
	snprintf(str, sizeof str, "irq %d", ih);
@


1.1.2.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d49 1
a50 2
#include <machine/pcb.h>

a56 1
#include <mvmeppc/dev/ravenvar.h>
d62 1
a62 1
    struct pcibus_attach_args *);
d100 10
a126 3
extern u_int8_t *ravenregs;
extern vaddr_t isaspace_va;

d135 4
a138 1

d142 1
d151 1
d155 3
d172 2
a173 4
	lcp->ioh_cf8 = (PREP_CONFIG_ADD - RAVEN_P_ISA_IO_SPACE) +
		(bus_space_handle_t)isaspace_va;
	lcp->ioh_cfc = (PREP_CONFIG_DAT - RAVEN_P_ISA_IO_SPACE) +
		(bus_space_handle_t)isaspace_va;
d184 3
a186 2
	printf(": revision 0x%x\n", 
	    mpc_cfg_read_1(lcp, RAVEN_PCI_REVID));
d194 3
a196 1

d199 8
a206 8
	*(u_int32_t *)(ravenregs + RAVEN_MSADD0) = RAVEN_MSADD0_PREP;
	*(u_int32_t *)(ravenregs + RAVEN_MSOFF0) = RAVEN_MSOFF0_PREP;
	*(u_int32_t *)(ravenregs + RAVEN_MSADD1) = RAVEN_MSADD1_PREP;
	*(u_int32_t *)(ravenregs + RAVEN_MSOFF1) = RAVEN_MSOFF1_PREP;
	*(u_int32_t *)(ravenregs + RAVEN_MSADD2) = RAVEN_MSADD2_PREP;
	*(u_int32_t *)(ravenregs + RAVEN_MSOFF2) = RAVEN_MSOFF2_PREP;
	*(u_int32_t *)(ravenregs + RAVEN_MSADD3) = RAVEN_MSADD3_PREP;
	*(u_int32_t *)(ravenregs + RAVEN_MSOFF3) = RAVEN_MSOFF3_PREP;
a208 1
	mpc_cfg_write_4(lcp, RAVEN_PCI_MEM, MPCIC_BASE);
d254 4
a257 2
paddr_t
vtophys(paddr_t pa)
d259 2
a260 1
	vaddr_t va = (vaddr_t) pa;
d262 2
a263 1
	if (va < VM_MIN_KERNEL_ADDRESS)
d265 5
a269 3
	else
		if (pmap_extract(pmap_kernel(), va, &pa) != 0)
			return NULL;
d271 23
a293 1
	return pa;
d295 1
d356 5
d405 1
a409 2
	faultbuf env;
	void *oldh;
a411 1
#ifdef DEBUG_CONFIG
a412 1
#endif
d419 1
a419 1
		return (~0);
a427 7
	oldh = curpcb->pcb_onfault;
	if (setfault(&env)) {
		/* did we fault during the read? */
		curpcb->pcb_onfault = oldh;
		return (~0);
	}

a433 2
	curpcb->pcb_onfault = oldh;

d467 1
a467 1
	if ((cp->config_type & 2) && (offset & 0x04))
d469 1
a469 1

d492 1
a492 1
/*ARGSUSED*/
d504 2
a505 1
		error = 1; /* No IRQ used. */
d523 1
a523 1
	snprintf(str, sizeof str, "irq %ld", ih);
d535 2
a536 2
typedef void     *(intr_establish_t)(void *, pci_intr_handle_t, int, int,
    int (*func)(void *), void *, char *);
d551 1
a551 1
		name);
d566 1
a566 1
	volatile u_int8_t *iack = ravenregs + RAVEN_PIACK;
d581 2
a582 1
	bus_space_write_4(cp->lc_iot, cp->ioh_cf8, 0, RAVEN_REGOFFS(reg));
@


