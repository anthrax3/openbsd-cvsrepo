head	1.70;
access;
symbols
	OPENBSD_4_9:1.64.0.2
	OPENBSD_4_9_BASE:1.64
	OPENBSD_4_8:1.63.0.4
	OPENBSD_4_8_BASE:1.63
	OPENBSD_4_7:1.63.0.2
	OPENBSD_4_7_BASE:1.63
	OPENBSD_4_6:1.58.0.4
	OPENBSD_4_6_BASE:1.58
	OPENBSD_4_5:1.56.0.4
	OPENBSD_4_5_BASE:1.56
	OPENBSD_4_4:1.56.0.2
	OPENBSD_4_4_BASE:1.56
	OPENBSD_4_3:1.55.0.2
	OPENBSD_4_3_BASE:1.55
	OPENBSD_4_2:1.53.0.2
	OPENBSD_4_2_BASE:1.53
	OPENBSD_4_1:1.51.0.2
	OPENBSD_4_1_BASE:1.51
	OPENBSD_4_0:1.49.0.2
	OPENBSD_4_0_BASE:1.49
	OPENBSD_3_9:1.48.0.2
	OPENBSD_3_9_BASE:1.48
	OPENBSD_3_8:1.47.0.4
	OPENBSD_3_8_BASE:1.47
	OPENBSD_3_7:1.47.0.2
	OPENBSD_3_7_BASE:1.47
	OPENBSD_3_6:1.46.0.2
	OPENBSD_3_6_BASE:1.46
	SMP_SYNC_A:1.45
	SMP_SYNC_B:1.45
	OPENBSD_3_5:1.44.0.2
	OPENBSD_3_5_BASE:1.44
	OPENBSD_3_4:1.32.0.2
	OPENBSD_3_4_BASE:1.32
	UBC_SYNC_A:1.31
	OPENBSD_3_3:1.30.0.2
	OPENBSD_3_3_BASE:1.30
	OPENBSD_3_2:1.27.0.2
	OPENBSD_3_2_BASE:1.27
	OPENBSD_3_1:1.24.0.2
	OPENBSD_3_1_BASE:1.24
	UBC_SYNC_B:1.28
	UBC:1.17.0.2
	UBC_BASE:1.17
	OPENBSD_3_0:1.10.0.2
	OPENBSD_3_0_BASE:1.10
	SMP:1.2.0.2;
locks; strict;
comment	@ * @;


1.70
date	2011.07.07.19.16.43;	author deraadt;	state dead;
branches;
next	1.69;

1.69
date	2011.07.05.04.48.01;	author guenther;	state Exp;
branches;
next	1.68;

1.68
date	2011.06.26.22.40.00;	author deraadt;	state Exp;
branches;
next	1.67;

1.67
date	2011.06.05.19.41.07;	author deraadt;	state Exp;
branches;
next	1.66;

1.66
date	2011.04.18.21.44.55;	author guenther;	state Exp;
branches;
next	1.65;

1.65
date	2011.04.15.04.52.39;	author guenther;	state Exp;
branches;
next	1.64;

1.64
date	2010.12.21.14.56.24;	author claudio;	state Exp;
branches;
next	1.63;

1.63
date	2009.08.22.02.54.50;	author mk;	state Exp;
branches;
next	1.62;

1.62
date	2009.08.11.19.17.17;	author miod;	state Exp;
branches;
next	1.61;

1.61
date	2009.08.11.18.46.32;	author miod;	state Exp;
branches;
next	1.60;

1.60
date	2009.08.09.10.40.17;	author blambert;	state Exp;
branches;
next	1.59;

1.59
date	2009.08.02.16.28.39;	author beck;	state Exp;
branches;
next	1.58;

1.58
date	2009.06.15.17.01.26;	author beck;	state Exp;
branches;
next	1.57;

1.57
date	2009.06.03.21.30.20;	author beck;	state Exp;
branches;
next	1.56;

1.56
date	2008.04.09.16.58.10;	author deraadt;	state Exp;
branches;
next	1.55;

1.55
date	2008.01.23.16.37.57;	author jsing;	state Exp;
branches;
next	1.54;

1.54
date	2007.11.04.13.43.39;	author martin;	state Exp;
branches;
next	1.53;

1.53
date	2007.05.26.20.26.51;	author pedro;	state Exp;
branches;
next	1.52;

1.52
date	2007.05.23.20.33.47;	author pvalchev;	state Exp;
branches;
next	1.51;

1.51
date	2007.02.27.01.04.01;	author deraadt;	state Exp;
branches;
next	1.50;

1.50
date	2007.02.26.21.30.18;	author miod;	state Exp;
branches;
next	1.49;

1.49
date	2006.06.30.16.14.31;	author miod;	state Exp;
branches;
next	1.48;

1.48
date	2005.12.17.07.31.26;	author miod;	state Exp;
branches;
next	1.47;

1.47
date	2004.11.17.20.26.02;	author miod;	state Exp;
branches;
next	1.46;

1.46
date	2004.06.24.22.35.56;	author drahn;	state Exp;
branches;
next	1.45;

1.45
date	2004.05.06.20.15.08;	author miod;	state Exp;
branches;
next	1.44;

1.44
date	2004.01.29.21.30.02;	author miod;	state Exp;
branches;
next	1.43;

1.43
date	2004.01.28.23.50.19;	author miod;	state Exp;
branches;
next	1.42;

1.42
date	2004.01.26.22.58.15;	author miod;	state Exp;
branches;
next	1.41;

1.41
date	2004.01.25.23.04.11;	author miod;	state Exp;
branches;
next	1.40;

1.40
date	2004.01.25.21.41.30;	author miod;	state Exp;
branches;
next	1.39;

1.39
date	2004.01.24.21.10.33;	author miod;	state Exp;
branches;
next	1.38;

1.38
date	2004.01.23.10.40.01;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2004.01.22.20.45.20;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2003.12.20.22.40.27;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2003.11.25.21.16.44;	author drahn;	state Exp;
branches;
next	1.34;

1.34
date	2003.11.06.21.09.35;	author mickey;	state Exp;
branches;
next	1.33;

1.33
date	2003.09.22.21.39.40;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2003.08.06.21.08.06;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	2003.04.06.18.54.19;	author ho;	state Exp;
branches;
next	1.30;

1.30
date	2003.02.26.21.54.44;	author drahn;	state Exp;
branches;
next	1.29;

1.29
date	2002.12.17.23.11.32;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2002.10.13.18.26.12;	author krw;	state Exp;
branches;
next	1.27;

1.27
date	2002.07.20.19.24.56;	author art;	state Exp;
branches;
next	1.26;

1.26
date	2002.06.08.15.48.58;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2002.06.07.01.01.40;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2002.03.23.13.28.34;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	2002.03.14.03.15.58;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2002.03.14.01.26.41;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2002.02.17.22.59.53;	author maja;	state Exp;
branches;
next	1.20;

1.20
date	2002.01.23.17.51.52;	author art;	state Exp;
branches;
next	1.19;

1.19
date	2002.01.23.17.35.56;	author art;	state Exp;
branches;
next	1.18;

1.18
date	2002.01.16.20.50.17;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2001.12.08.02.24.06;	author art;	state Exp;
branches
	1.17.2.1;
next	1.16;

1.16
date	2001.11.28.16.13.29;	author art;	state Exp;
branches;
next	1.15;

1.15
date	2001.11.28.13.47.39;	author art;	state Exp;
branches;
next	1.14;

1.14
date	2001.11.09.15.25.55;	author art;	state Exp;
branches;
next	1.13;

1.13
date	2001.11.07.01.18.00;	author art;	state Exp;
branches;
next	1.12;

1.12
date	2001.11.06.22.46.00;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2001.11.06.19.53.15;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2001.09.19.20.50.57;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	2001.09.12.00.23.34;	author art;	state Exp;
branches;
next	1.8;

1.8
date	2001.09.11.20.10.00;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2001.08.27.21.15.17;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2001.08.23.14.01.03;	author art;	state Exp;
branches;
next	1.5;

1.5
date	2001.08.23.12.02.04;	author art;	state Exp;
branches;
next	1.4;

1.4
date	2001.07.25.13.25.32;	author art;	state Exp;
branches;
next	1.3;

1.3
date	2001.07.06.05.14.30;	author smurph;	state Exp;
branches;
next	1.2;

1.2
date	2001.06.27.04.32.46;	author art;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2001.06.26.21.57.54;	author smurph;	state Exp;
branches;
next	;

1.2.2.1
date	2001.10.31.03.01.21;	author nate;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2001.11.13.21.04.15;	author niklas;	state Exp;
branches;
next	1.2.2.3;

1.2.2.3
date	2002.03.06.02.04.46;	author niklas;	state Exp;
branches;
next	1.2.2.4;

1.2.2.4
date	2002.03.28.10.36.03;	author niklas;	state Exp;
branches;
next	1.2.2.5;

1.2.2.5
date	2002.03.30.00.42.38;	author niklas;	state Exp;
branches;
next	1.2.2.6;

1.2.2.6
date	2003.03.27.23.52.17;	author niklas;	state Exp;
branches;
next	1.2.2.7;

1.2.2.7
date	2003.05.13.19.41.07;	author ho;	state Exp;
branches;
next	1.2.2.8;

1.2.2.8
date	2004.02.19.10.49.10;	author niklas;	state Exp;
branches;
next	1.2.2.9;

1.2.2.9
date	2004.06.05.23.10.54;	author niklas;	state Exp;
branches;
next	;

1.17.2.1
date	2002.01.31.22.55.20;	author niklas;	state Exp;
branches;
next	1.17.2.2;

1.17.2.2
date	2002.06.11.03.37.22;	author art;	state Exp;
branches;
next	1.17.2.3;

1.17.2.3
date	2002.10.29.00.28.08;	author art;	state Exp;
branches;
next	1.17.2.4;

1.17.2.4
date	2003.05.19.21.49.43;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.70
log
@remove mvmeppc; it is really rough shape.  ok drahn miod
@
text
@/*	$OpenBSD: machdep.c,v 1.69 2011/07/05 04:48:01 guenther Exp $	*/
/*	$NetBSD: machdep.c,v 1.4 1996/10/16 19:33:11 ws Exp $	*/

/*
 * Copyright (C) 1995, 1996 Wolfgang Solfrank.
 * Copyright (C) 1995, 1996 TooLs GmbH.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by TooLs GmbH.
 * 4. The name of TooLs GmbH may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY TOOLS GMBH ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL TOOLS GMBH BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/buf.h>
#include <sys/timeout.h>
#include <sys/exec.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/mount.h>
#include <sys/msgbuf.h>
#include <sys/proc.h>
#include <sys/signalvar.h>
#include <sys/reboot.h>
#include <sys/syscallargs.h>
#include <sys/syslog.h>
#include <sys/extent.h>
#include <sys/systm.h>
#include <sys/user.h>

#include <machine/bat.h>
#include <machine/bugio.h>
#include <machine/pmap.h>
#include <machine/powerpc.h>
#include <machine/trap.h>
#include <machine/autoconf.h>
#include <machine/bus.h>
#include <machine/conf.h>
#include <machine/pio.h>
#include <machine/prom.h>

#include <dev/cons.h>

#include <net/if.h>
#include <uvm/uvm_extern.h>

#ifdef DDB
#include <machine/db_machdep.h>
#include <ddb/db_access.h>
#include <ddb/db_sym.h>
#include <ddb/db_extern.h>
#endif

void initppc(u_int, u_int, char *);
void dumpsys(void);
int lcsplx(int);
void myetheraddr(u_char *);

/*
 * Global variables used here and there
 */
struct pcb *curpcb;
struct pmap *curpm;
struct proc *fpuproc;

extern struct user *proc0paddr;

/* 
 * This is to fake out the console routines, while booting.
 */
cons_decl(boot);
#define bootcnpollc nullcnpollc

static struct consdev bootcons = {
	NULL, 
	NULL, 
	bootcngetc, 
	bootcnputc,
	bootcnpollc,
	NULL,
	makedev(14, 0), 
	CN_LOWPRI,
};

struct bat battable[16];

struct vm_map *exec_map = NULL;
struct vm_map *phys_map = NULL;

int ppc_malloc_ok;

#ifndef SYS_TYPE
/* XXX Hardwire it for now */
#define SYS_TYPE MVME
#endif

int system_type = SYS_TYPE;	/* XXX Hardwire it for now */

struct firmware *fw = NULL;
extern struct firmware ppc1_firmware;

/*
 * Extent maps to manage I/O. Allocate storage for 8 regions in each,
 * initially. Later devio_malloc_safe will indicate that it's safe to
 * use malloc() to dynamically allocate region descriptors.
 */
static long devio_ex_storage[EXTENT_FIXED_STORAGE_SIZE(8) / sizeof (long)];
struct extent *devio_ex;
static int devio_malloc_safe = 0;

void
initppc(startkernel, endkernel, args)
	u_int startkernel, endkernel;
	char *args;
{
	extern void *trapcode; extern int trapsize;
	extern void *dsitrap; extern int dsisize;
	extern void *isitrap; extern int isisize;
	extern void *alitrap; extern int alisize;
	extern void *decrint; extern int decrsize;
	extern void *tlbimiss; extern int tlbimsize;
	extern void *tlbdlmiss; extern int tlbdlmsize;
	extern void *tlbdsmiss; extern int tlbdsmsize;
#ifdef DDB
	extern void *ddblow; extern int ddbsize;
#endif 
	extern void consinit(void);
	extern void *msgbuf_addr;
	int exc, scratch;

	proc0.p_addr = proc0paddr;
	bzero(proc0.p_addr, sizeof *proc0.p_addr);
		
	fw = &ppc1_firmware; /*  Just PPC1-Bug for now... */
	buginit();

	curpcb = &proc0paddr->u_pcb;
	
	curpm = curpcb->pcb_pmreal = curpcb->pcb_pm = pmap_kernel();

	/* startup fake console driver.  It will be replaced by consinit() */
	cn_tab = &bootcons;

	/*
	 * Initialize BAT registers to unmapped to not generate
	 * overlapping mappings below.
	 */
	ppc_mtibat0u(0);
	ppc_mtibat1u(0);
	ppc_mtibat2u(0);
	ppc_mtibat3u(0);
	ppc_mtdbat0u(0);
	ppc_mtdbat1u(0);
	ppc_mtdbat2u(0);
	ppc_mtdbat3u(0);
	
	/*
	 * Set up initial BAT table
	 */
	battable[0].batl = BATL(0x00000000, BAT_M);
	battable[0].batu = BATU(0x00000000);
	
	/*
	 * Now setup fixed bat registers
	 *
	 * Note that we still run in real mode, and the BAT
	 * registers were cleared above.
	 */
	/* IBAT0 used for initial 256 MB segment */
	ppc_mtibat0l(battable[0].batl);
	ppc_mtibat0u(battable[0].batu);

	/* DBAT0 used similar */
	ppc_mtdbat0l(battable[0].batl);
	ppc_mtdbat0u(battable[0].batu);

	/*
	 * Set up trap vectors
	 */
	for (exc = EXC_RSVD; exc <= EXC_LAST; exc += 0x100) {
		switch (exc) {
		default:
			bcopy(&trapcode, (void *)exc, (size_t)&trapsize);
			break;
		case EXC_EXI:
			/*
			 * This one is (potentially) installed during autoconf
			 */
			break;

		case EXC_DSI:
			bcopy(&dsitrap, (void *)exc, (size_t)&dsisize);
			break;
		case EXC_ISI:
			bcopy(&isitrap, (void *)exc, (size_t)&isisize);
			break;
		case EXC_ALI:
			bcopy(&alitrap, (void *)exc, (size_t)&alisize);
			break;
		case EXC_DECR:
			bcopy(&decrint, (void *)exc, (size_t)&decrsize);
			break;
		case EXC_IMISS:
			bcopy(&tlbimiss, (void *)exc, (size_t)&tlbimsize);
			break;
		case EXC_DLMISS:
			bcopy(&tlbdlmiss, (void *)exc, (size_t)&tlbdlmsize);
			break;
		case EXC_DSMISS:
			bcopy(&tlbdsmiss, (void *)exc, (size_t)&tlbdsmsize);
			break;
#ifdef DDB
		case EXC_PGM:
		case EXC_TRC:
		case EXC_BPT:
			bcopy(&ddblow, (void *)exc, (size_t)&ddbsize);
			break;
#endif
		}
	}

	/* Grr, ALTIVEC_UNAVAIL is a vector not ~0xff aligned: 0x0f20 */
	bcopy(&trapcode, (void *)0xf20, (size_t)&trapsize);

	/*
	 * since trapsize is > 0x20, we just overwrote the EXC_PERF handler
	 * since we do not use it, we will "share" it with the EXC_VEC,
	 * we dont support EXC_VEC either.
	 * should be a 'ba 0xf20 written' at address 0xf00, but we
	 * do not generate EXC_PERF exceptions...
	 */

	syncicache((void *)EXC_RST, EXC_LAST - EXC_RST + 0x100);
	
	/*
	 * Initialize pmap module.
	 */
	uvmexp.pagesize = 4096;
	uvm_setpagesize();
	pmap_bootstrap(startkernel, endkernel);

#if 1
	/* MVME2[67]00 max out at 256MB, and we need BAT2 for now. */
#else
	/* use BATs to map 1GB memory, no pageable BATs now */
	if (physmem > atop(0x10000000)) {
		ppc_mtdbat1l(BATL(0x10000000, BAT_M));
		ppc_mtdbat1u(BATU(0x10000000));
	}
	if (physmem > atop(0x20000000)) {
		ppc_mtdbat2l(BATL(0x20000000, BAT_M));
		ppc_mtdbat2u(BATU(0x20000000));
	}
	if (physmem > atop(0x30000000)) {
		ppc_mtdbat3l(BATL(0x30000000, BAT_M));
		ppc_mtdbat3u(BATU(0x30000000));
	}
#endif

	/*
	 * Now enable translation (and machine checks/recoverable interrupts).
	 * This will also start using the exception vector prefix of 0x000.
	 */
	(fw->vmon)();

	__asm__ volatile ("eieio; mfmsr %0; ori %0,%0,%1; mtmsr %0; sync;isync"
		      : "=r"(scratch) : "K"(PSL_IR|PSL_DR|PSL_ME|PSL_RI));

	/*
	 * use the memory provided by pmap_bootstrap for message buffer
	 */
	initmsgbuf(msgbuf_addr, MSGBUFSIZE);

#ifdef DDB
#ifdef notyet
	db_machine_init();
#endif
	ddb_init();
#endif
	
	/*
	 * Set up extents for pci mappings
	 * Is this too late?
	 * 
	 * what are good start and end values here??
	 * 0x0 - 0x80000000 mcu bus
	 * MAP A				MAP B
	 * 0x80000000 - 0xbfffffff io		0x80000000 - 0xefffffff mem
	 * 0xc0000000 - 0xffffffff mem		0xf0000000 - 0xffffffff io
	 * 
	 * of course bsd uses 0xe and 0xf
	 * So the BSD PPC memory map will look like this
	 * 0x0 - 0x80000000 memory (whatever is filled)
	 * 0x80000000 - 0xdfffffff (pci space, memory or io)
	 * 0xe0000000 - kernel vm segment
	 * 0xf0000000 - kernel map segment (user space mapped here)
	 */

	devio_ex = extent_create("devio", 0x80000000, 0xffffffff, M_DEVBUF,
		(caddr_t)devio_ex_storage, sizeof(devio_ex_storage),
		EX_NOCOALESCE|EX_NOWAIT);

	/*
	 * Now we can set up the console as mapping is enabled.
	 */
	consinit();
	
	if (boothowto & RB_CONFIG) {
#ifdef BOOT_CONFIG
		user_config();
#else
		printf("kernel does not support -c; continuing..\n");
#endif
	}

#ifdef DDB
	if (boothowto & RB_KDB)
		Debugger();
#endif
}

void
install_extint(handler)
	void (*handler)(void);
{
	extern caddr_t extint, extsize;
	extern u_long extint_call;
	u_long offset = (u_long)handler - (u_long)&extint_call;
	int msr;
	
#ifdef	DIAGNOSTIC
	if (offset > 0x1ffffff)
		panic("install_extint: too far away");
#endif
	msr = ppc_intr_disable();
	extint_call = (extint_call & 0xfc000003) | offset;
	bcopy(&extint, (void *)EXC_EXI, (size_t)&extsize);
	syncicache((void *)&extint_call, sizeof extint_call);
	syncicache((void *)EXC_EXI, (int)&extsize);
	ppc_intr_enable(msr);
}

/*
 * Machine dependent startup code.
 */
void
cpu_startup()
{
	vaddr_t minaddr, maxaddr;

	proc0.p_addr = proc0paddr;

	printf("%s", version);
	
	printf("real mem = %u (%uMB)\n", ptoa(physmem),
	    ptoa(physmem)/1024/1024);

	/*
	 * Allocate a submap for exec arguments.  This map effectively
	 * limits the number of processes exec'ing at any time.
	 */
	minaddr = vm_map_min(kernel_map);
	exec_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr, 16 * NCARGS,
	    VM_MAP_PAGEABLE, FALSE, NULL);

	/*
	 * Allocate a submap for physio
	 */
	phys_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
	    VM_PHYS_SIZE, 0, FALSE, NULL);
	ppc_malloc_ok = 1;
	
	printf("avail mem = %lu (%luMB)\n", ptoa(uvmexp.free),
	    ptoa(uvmexp.free) / 1024 / 1024);

	/*
	 * Set up the buffers.
	 */
	bufinit();

	/*
	 * Set up early mappings
	 */
	devio_malloc_safe = 1;
	nvram_map();
	prep_bus_space_init();	
}

/*
 * consinit
 * Initialize system console.
 */
void
consinit()
{
	static int cons_initted = 0;

	if (cons_initted)
		return;
	cn_tab = NULL;
	cninit();
	cons_initted = 1;
}

/*
 * Clear registers on exec
 */
void
setregs(p, pack, stack, retval)
	struct proc *p;
	struct exec_package *pack;
	u_long stack;
	register_t *retval;
{
	u_int32_t newstack;
	u_int32_t pargs;
	u_int32_t args[4];

	struct trapframe *tf = trapframe(p);
	pargs = -roundup(-stack + 8, 16);
	newstack = (u_int32_t)(pargs - 32);

	copyin ((void *)(VM_MAX_ADDRESS-0x10), &args, 0x10);
	
	bzero(tf, sizeof *tf);
	tf->fixreg[1] = newstack;
	tf->fixreg[3] = retval[0] = args[1];	/* XXX */
	tf->fixreg[4] = retval[1] = args[0];	/* XXX */
	tf->fixreg[5] = args[2];		/* XXX */
	tf->fixreg[6] = args[3];		/* XXX */
	tf->srr0 = pack->ep_entry;
	tf->srr1 = PSL_MBO | PSL_USERSET | PSL_FE_DFLT;
	p->p_addr->u_pcb.pcb_flags = 0;
}

/*
 * Send a signal to process.
 */
void
sendsig(catcher, sig, mask, code, type, val)
	sig_t catcher;
	int sig, mask;
	u_long code;
	int type;
	union sigval val;
{
	struct proc *p = curproc;
	struct trapframe *tf;
	struct sigframe *fp, frame;
	struct sigacts *psp = p->p_sigacts;
	int oldonstack;
	
	frame.sf_signum = sig;
	
	tf = trapframe(p);
	oldonstack = p->p_sigstk.ss_flags & SS_ONSTACK;
	
	/*
	 * Allocate stack space for signal handler.
	 */
	if ((p->p_sigstk.ss_flags & SS_DISABLE) == 0
	    && !oldonstack
	    && (psp->ps_sigonstack & sigmask(sig))) {
		fp = (struct sigframe *)(p->p_sigstk.ss_sp
					 + p->p_sigstk.ss_size);
		p->p_sigstk.ss_flags |= SS_ONSTACK;
	} else
		fp = (struct sigframe *)tf->fixreg[1];

	fp = (struct sigframe *)((int)(fp - 1) & ~0xf);
	
	/*
	 * Generate signal context for SYS_sigreturn.
	 */
	frame.sf_sc.sc_onstack = oldonstack;
	frame.sf_sc.sc_mask = mask;
	frame.sf_sip = NULL;
	bcopy(tf, &frame.sf_sc.sc_frame, sizeof *tf);
	if (psp->ps_siginfo & sigmask(sig)) {
		frame.sf_sip = &fp->sf_si;
		initsiginfo(&frame.sf_si, sig, code, type, val);
	}
	if (copyout(&frame, fp, sizeof frame) != 0)
		sigexit(p, SIGILL);
	

	tf->fixreg[1] = (int)fp;
	tf->lr = (int)catcher;
	tf->fixreg[3] = (int)sig;
	tf->fixreg[4] = (psp->ps_siginfo & sigmask(sig)) ? (int)&fp->sf_si : 0;
	tf->fixreg[5] = (int)&fp->sf_sc;
	tf->srr0 = p->p_sigcode;

#if WHEN_WE_ONLY_FLUSH_DATA_WHEN_DOING_PMAP_ENTER
	pmap_extract(vm_map_pmap(&p->p_vmspace->vm_map),tf->srr0, &pa);
	syncicache(pa, (p->p_emul->e_esigcode - p->p_emul->e_sigcode));
#endif
}

/*
 * System call to cleanup state after a signal handler returns.
 */
int
sys_sigreturn(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_sigreturn_args /* {
		syscallarg(struct sigcontext *) sigcntxp;
	} */ *uap = v;
	struct sigcontext sc;
	struct trapframe *tf;
	int error;
	
	if ((error = copyin(SCARG(uap, sigcntxp), &sc, sizeof sc)) != 0)
		return error;
	tf = trapframe(p);
	if ((sc.sc_frame.srr1 & PSL_USERSTATIC) != (tf->srr1 & PSL_USERSTATIC))
		return EINVAL;
	bcopy(&sc.sc_frame, tf, sizeof *tf);
	if (sc.sc_onstack & 1)
		p->p_sigstk.ss_flags |= SS_ONSTACK;
	else
		p->p_sigstk.ss_flags &= ~SS_ONSTACK;
	p->p_sigmask = sc.sc_mask & ~sigcantmask;
	return EJUSTRETURN;
}

/*
 * Machine dependent system variables.
 * None for now.
 */
int
cpu_sysctl(name, namelen, oldp, oldlenp, newp, newlen, p)
	int *name;
	u_int namelen;
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
	struct proc *p;
{
	/* all sysctl names at this level are terminal */
	if (namelen != 1)
		return ENOTDIR;
	switch (name[0]) {
	default:
		return EOPNOTSUPP;
	}
}

void
dumpsys()
{
	printf("dumpsys: TBD\n");
}

volatile int cpl, ipending, astpending;
int imask[IPL_NUM];

int
lcsplx(ipl)
	int ipl;
{
	int oldcpl;

	oldcpl = cpl;
	splx(ipl);
	return oldcpl;
}

/*
 * Halt or reboot the machine after syncing/dumping according to howto.
 */
void
boot(howto)
	int howto;
{
	static int syncing;
	static char str[256];

	boothowto = howto;
	if (!cold && !(howto & RB_NOSYNC) && !syncing) {
		syncing = 1;
		vfs_shutdown();		/* sync */
		
		/*
		 * If we've been adjusting the clock, the todr
		 * will be out of synch; adjust it now unless
		 * the system was sitting in ddb.
		 */
		if ((howto & RB_TIMEBAD) == 0) {
			resettodr();
		} else {
			printf("WARNING: not updating battery clock\n");
		}
	}
	if_downall();

	uvm_shutdown();
	splhigh();
	if (howto & RB_HALT) {
		doshutdownhooks();
		printf("halted\n\n");
		(fw->exit)();
	}
	if (!cold && (howto & RB_DUMP))
		dumpsys();
	doshutdownhooks();
	printf("rebooting\n\n");

	(fw->boot)(str);
	for (;;) ;	/* spinning */
}

/*
 *  Get Ethernet address for the onboard ethernet chip.
 */
void
myetheraddr(cp)
	u_char *cp;
{
	struct mvmeprom_brdid brdid;

	mvmeprom_brdid(&brdid);
	bcopy(&brdid.etheraddr, cp, 6);
}

typedef void  (void_f) (void);
void_f *pending_int_f = NULL;

/* call the bus/interrupt controller specific pending interrupt handler
 * would be nice if the offlevel interrupt code was handled here
 * instead of being in each of the specific handler code
 */
void
do_pending_int()
{
	if (pending_int_f != NULL) {
		(*pending_int_f)();
	}
}

/* 
 * one attempt at interrupt stuff..
 *
 */
#include <dev/pci/pcivar.h>
typedef void     *(intr_establish_t)(void *, pci_intr_handle_t,
            int, int, int (*func)(void *), void *, char *);
typedef void     (intr_disestablish_t)(void *, void *);

int ppc_configed_intr_cnt = 0;
struct intrhand ppc_configed_intr[MAX_PRECONF_INTR];

void *ppc_intr_establish(void *, pci_intr_handle_t, int, int, int (*)(void *),
    void *, const char *);
void ppc_intr_setup(intr_establish_t *, intr_disestablish_t *);
void ppc_intr_enable(int);
int ppc_intr_disable(void);

void *
ppc_intr_establish(lcv, ih, type, level, func, arg, name)
	void *lcv;
	pci_intr_handle_t ih;
	int type;
	int level;
	int (*func)(void *);
	void *arg;
	const char *name;
{
	if (ppc_configed_intr_cnt < MAX_PRECONF_INTR) {
		ppc_configed_intr[ppc_configed_intr_cnt].ih_fun = func;
		ppc_configed_intr[ppc_configed_intr_cnt].ih_arg = arg;
		ppc_configed_intr[ppc_configed_intr_cnt].ih_level = level;
		ppc_configed_intr[ppc_configed_intr_cnt].ih_irq = ih;
		ppc_configed_intr[ppc_configed_intr_cnt].ih_what = name;
		ppc_configed_intr_cnt++;
	} else {
		panic("ppc_intr_establish called before interrupt controller"
			" configured: driver %s has too many interrupts", name);
	}
	/* disestablish is going to be tricky to supported for these :-) */
	return (void *)ppc_configed_intr_cnt;
}

intr_establish_t *intr_establish_func = ppc_intr_establish;
intr_disestablish_t *intr_disestablish_func;

void
ppc_intr_setup(intr_establish_t *establish, intr_disestablish_t *disestablish)
{
	intr_establish_func = establish;
	intr_disestablish_func = disestablish;
}

vaddr_t ppc_kvm_stolen = VM_KERN_ADDRESS_SIZE;

void *
mapiodev(pa, len)
	paddr_t pa;
	psize_t len;
{
	paddr_t spa;
	vaddr_t vaddr, va;
	int off;
	int size;

	spa = trunc_page(pa);
	off = pa - spa;
	size = round_page(off+len);

	if (ppc_malloc_ok == 0) {
		/* need to steal vm space before kernel vm is initialized */
		va = VM_MIN_KERNEL_ADDRESS + ppc_kvm_stolen;
		ppc_kvm_stolen += size;
		if (ppc_kvm_stolen > PPC_SEGMENT_LENGTH) {
			panic("ppc_kvm_stolen: out of space");
		}
	} else {
		va = uvm_km_valloc_wait(phys_map, size);
	}

	if (va == 0) 
		return NULL;

	for (vaddr = va; size > 0; size -= PAGE_SIZE) {
		pmap_kenter_cache(vaddr, spa,
			VM_PROT_READ | VM_PROT_WRITE, PMAP_CACHE_DEFAULT);
		spa += PAGE_SIZE;
		vaddr += PAGE_SIZE;
	}
	return (void *) (va+off);
}
void 
unmapiodev(kva, p_size)
	void *kva;
	psize_t p_size;
{
	vaddr_t vaddr;
	int size;

	size = p_size;

	vaddr = trunc_page((vaddr_t)kva);

	uvm_km_free_wakeup(phys_map, vaddr, size);

	for (; size > 0; size -= PAGE_SIZE) {
		pmap_remove(pmap_kernel(), vaddr,  vaddr+PAGE_SIZE-1);
		vaddr += PAGE_SIZE;
	}
	pmap_update(pmap_kernel());
}

/* bcopy(), error on fault */
int
kcopy(from, to, size)
	const void *from;
	void *to;
	size_t size;
{
	faultbuf env;
	void *oldh = curproc->p_addr->u_pcb.pcb_onfault;

	if (setfault(&env)) {
		curproc->p_addr->u_pcb.pcb_onfault = oldh;
		return EFAULT;
	}
	bcopy(from, to, size);
	curproc->p_addr->u_pcb.pcb_onfault = oldh;

	return 0;
}
@


1.69
log
@Recommit the reverted sigacts change now that the NFS use-after-free
problem has been tracked down.  This fixes the sharing of the signal
handling state: shared bits go in sigacts, per-rthread bits goes in
struct proc.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.68 2011/06/26 22:40:00 deraadt Exp $	*/
@


1.68
log
@if_downall() cannot be done MI in sys_reboot() because vfs_shutdown()
might need network (ie. nfs).  Move the call to the MD boot() routines.
This cause for boot hangs diagnosed by kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.67 2011/06/05 19:41:07 deraadt Exp $	*/
d477 1
a477 1
	oldonstack = psp->ps_sigstk.ss_flags & SS_ONSTACK;
d482 1
a482 1
	if ((psp->ps_flags & SAS_ALTSTACK)
d485 3
a487 3
		fp = (struct sigframe *)(psp->ps_sigstk.ss_sp
					 + psp->ps_sigstk.ss_size);
		psp->ps_sigstk.ss_flags |= SS_ONSTACK;
d544 1
a544 1
		p->p_sigacts->ps_sigstk.ss_flags |= SS_ONSTACK;
d546 1
a546 1
		p->p_sigacts->ps_sigstk.ss_flags &= ~SS_ONSTACK;
@


1.67
log
@Move the bufcachepercent setting code to MI locations -- set it to 42%
for now; that is unlikely to hit some of the remaining starvation bugs.
Repair the bufpages calculation too; i386 was doing it ahead of time
(incorrectly) and then re-calculating it.
ok thib
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.66 2011/04/18 21:44:55 guenther Exp $	*/
d65 1
d620 1
@


1.66
log
@Revert the sigacts diff: NFS can apparently retain pointers to processes
until they're zombies and then send them signals (for intr mounts).  Until
that is untangled, the sigacts change is unsafe.  sthen@@ was the victim
for this one
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.64 2010/12/21 14:56:24 claudio Exp $	*/
a103 14

/* 
 * Declare these as initialized data so we can patch them.
 */
#ifndef BUFCACHEPERCENT
#define BUFCACHEPERCENT 5
#endif

#ifdef BUFPAGES
int bufpages = BUFPAGES;
#else
int bufpages = 0;
#endif
int bufcachepercent = BUFCACHEPERCENT;
@


1.65
log
@Correct the sharing of the signal handling state: stuff that should
be shared (p_sigignore, p_sigcatch, P_NOCLDSTOP, P_NOCLDWAIT) moves
to struct sigacts, wihle stuff that should be per rthread (ps_oldmask,
SAS_OLDMASK, ps_sigstk) moves to struct proc.  Treat the coredumping
state bits (ps_sig, ps_code, ps_type, ps_sigval) as per-rthread
until our locking around coredumping is better.

Oh, and remove the old SunOS-compat ps_usertramp member.

"I like the sound of this" tedu@@
@
text
@d490 1
a490 1
	oldonstack = p->p_sigstk.ss_flags & SS_ONSTACK;
d495 1
a495 1
	if ((p->p_sigstk.ss_flags & SS_DISABLE) == 0
d498 3
a500 3
		fp = (struct sigframe *)(p->p_sigstk.ss_sp
					 + p->p_sigstk.ss_size);
		p->p_sigstk.ss_flags |= SS_ONSTACK;
d557 1
a557 1
		p->p_sigstk.ss_flags |= SS_ONSTACK;
d559 1
a559 1
		p->p_sigstk.ss_flags &= ~SS_ONSTACK;
@


1.64
log
@Convert netisr to a normal soft interrupt instead of hanving MD code
for it. This makes the netisr a real C function which will help further
development. No noticable performance change on i386 and amd64.
With input from kettenis@@ and miod@@ additional OKs mikeb@@ and henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.63 2009/08/22 02:54:50 mk Exp $	*/
d490 1
a490 1
	oldonstack = psp->ps_sigstk.ss_flags & SS_ONSTACK;
d495 1
a495 1
	if ((psp->ps_flags & SAS_ALTSTACK)
d498 3
a500 3
		fp = (struct sigframe *)(psp->ps_sigstk.ss_sp
					 + psp->ps_sigstk.ss_size);
		psp->ps_sigstk.ss_flags |= SS_ONSTACK;
d557 1
a557 1
		p->p_sigacts->ps_sigstk.ss_flags |= SS_ONSTACK;
d559 1
a559 1
		p->p_sigacts->ps_sigstk.ss_flags &= ~SS_ONSTACK;
@


1.63
log
@Constify the what/name parameter of pci_intr_establish().

Tested by myself, sthen, oga, kettenis, and jasper.
Input from sthen and jasper.

ok kettenis

(Manpage follows shortly.)
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.62 2009/08/11 19:17:17 miod Exp $	*/
a51 2
#include <net/netisr.h>

a594 16
int netisr;

/*
 * Soft networking interrupts.
 */
void
softnet(isr)
	int isr;
{
#define	DONETISR(flag, func) \
	if (isr & (1 << (flag))) \
		(func)();

#include <net/netisr_dispatch.h>
#undef	DONETISR
}
@


1.62
log
@Do not bother initializing bufpages in the md code if the computation is
exactly the same the mi could will use if bufinit() is invoked with
bufpages == 0.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.61 2009/08/11 18:46:32 miod Exp $	*/
d709 1
a709 1
    void *, char *);
d722 1
a722 1
	char *name;
@


1.61
log
@With the SysV memory allocation changes, allocsys() doesn't do anything
anymore. Get rid of it completely.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.60 2009/08/09 10:40:17 blambert Exp $	*/
a392 7

	/*
	 * Determine how many buffers to allocate.
	 * We allocate bufcachepercent% of memory for buffer space.
	 */
	if (bufpages == 0)
		bufpages = physmem * bufcachepercent / 100;
@


1.60
log
@Rototill system V message queues.

No longer allocate a static amount of memory for messages in MD
boot path; message queues, message metadata, and message data now
all use dynamic memory, which means that runtime sysctls should now
be trivial to implement.

Since I'm going to be around all week to fix any breakage, this should
probably just go in now.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.59 2009/08/02 16:28:39 beck Exp $	*/
a137 2
caddr_t allocsys(caddr_t);

a384 2
	int sz;
	caddr_t v;
a394 10
	 * Find out how much space we need, allocate it,
	 * and then give everything true virtual addresses.
	 */
	sz = (int)allocsys((caddr_t)0);
	if ((v = (caddr_t)uvm_km_zalloc(kernel_map, round_page(sz))) == 0)
		panic("startup: no room for tables");
	if (allocsys(v) - v != sz)
		panic("startup: table size inconsistency");

	/*
a429 13
}

/*
 * Allocate space for system data structures.
 */
caddr_t
allocsys(v)
	caddr_t v;
{
#define	valloc(name, type, num) \
	v = (caddr_t)(((name) = (type *)v) + (num))

	return v;
@


1.59
log
@
Dynamic buffer cache support - a re-commit of what was backed out
after c2k9

allows buffer cache to be extended and grow/shrink dynamically

tested by many, ok oga@@, "why not just commit it" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.58 2009/06/15 17:01:26 beck Exp $	*/
a46 3
#ifdef SYSVMSG
#include <sys/msg.h>
#endif
a454 7

#ifdef	SYSVMSG
	valloc(msgpool, char, msginfo.msgmax);
	valloc(msgmaps, struct msgmap, msginfo.msgseg);
	valloc(msghdrs, struct msg, msginfo.msgtql);
	valloc(msqids, struct msqid_ds, msginfo.msgmni);
#endif
@


1.58
log
@Back out all the buffer cache changes I committed during c2k9. This reverts three
commits:

1) The sysctl allowing bufcachepercent to be changed at boot time.
2) The change moving the buffer cache hash chains to a red-black tree
3) The dynamic buffer cache (Which depended on the earlier too).

ok on the backout from marco and todd
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.57 2009/06/03 21:30:20 beck Exp $	*/
a416 6

	/* Restrict to at most 25% filled kvm */
	if (bufpages >
	    (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) / PAGE_SIZE / 4) 
		bufpages = (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) /
		    PAGE_SIZE / 4;
@


1.57
log
@add kern.bufcachepercent sysctl to allow adjusting the buffer cache
size on a running system.
ok art@@, oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.56 2008/04/09 16:58:10 deraadt Exp $	*/
d417 6
@


1.56
log
@Add new stub uvm_shutdown() and call it from the right place in MD boot()
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.56 2008/04/09 16:50:29 deraadt Exp $	*/
a416 6

	/* Restrict to at most 25% filled kvm */
	if (bufpages >
	    (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) / PAGE_SIZE / 4) 
		bufpages = (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) /
		    PAGE_SIZE / 4;
@


1.55
log
@Cleanup cn_pri. Change constants to more meaningful names, rather than
the hp300 related ones currently in use. CN_NORMAL becomes CN_LOWPRI,
CN_INTERNAL becomes CN_MIDPRI and CN_REMOTE becomes CN_HIGHPRI.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.54 2007/11/04 13:43:39 martin Exp $	*/
d701 2
@


1.54
log
@replace even more ctob/btoc with ptoa/atop
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.53 2007/05/26 20:26:51 pedro Exp $	*/
d107 1
a107 1
	CN_NORMAL,
@


1.53
log
@Dynamic buffer cache. Initial diff from mickey@@, okay art@@ beck@@ toby@@
deraadt@@ dlg@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.52 2007/05/23 20:33:47 pvalchev Exp $	*/
d287 1
a287 1
	if (physmem > btoc(0x10000000)) {
d291 1
a291 1
	if (physmem > btoc(0x20000000)) {
d295 1
a295 1
	if (physmem > btoc(0x30000000)) {
d398 2
a399 2
	printf("real mem = %u (%uMB)\n", ctob(physmem),
	    ctob(physmem)/1024/1024);
@


1.52
log
@Print real/available memory in MB as well as bytes in dmesg, and unify
architectures to print it the same way.
ok henning, miod; i386 part from tom
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.51 2007/02/27 01:04:01 deraadt Exp $	*/
a112 6
#ifdef NBUF
int	nbuf = NBUF;
#else
int	nbuf = 0;
#endif

d390 1
a390 1
	int sz, i;
a392 1
	int base, residual;
d412 2
a413 2
	 * Now allocate buffers proper.  They are different than the above
	 * in that they usually occupy more virtual memory than physical.
d415 8
a422 35
	sz = MAXBSIZE * nbuf;
	if (uvm_map(kernel_map, (vaddr_t *) &buffers, round_page(sz),
	    NULL, UVM_UNKNOWN_OFFSET, 0,
	    UVM_MAPFLAG(UVM_PROT_NONE, UVM_PROT_NONE, UVM_INH_NONE,
	      UVM_ADV_NORMAL, 0)))
		panic("cpu_startup: cannot allocate VM for buffers");
	/*
	addr = (vaddr_t)buffers;
	*/
	base = bufpages / nbuf;
	residual = bufpages % nbuf;
	if (base >= MAXBSIZE) {
		/* Don't want to alloc more physical mem than ever needed */
		base = MAXBSIZE;
		residual = 0;
	}
	for (i = 0; i < nbuf; i++) {
		vsize_t curbufsize;
		vaddr_t curbuf;
		struct vm_page *pg;
		
		curbuf = (vaddr_t)buffers + i * MAXBSIZE;
		curbufsize = PAGE_SIZE * (i < residual ? base + 1 : base);
		while (curbufsize) {
			pg = uvm_pagealloc(NULL, 0, NULL, 0);
			if (pg == NULL)
				panic("cpu_startup: not enough memory for"
					" buffer cache");
			pmap_kenter_pa(curbuf, VM_PAGE_TO_PHYS(pg),
					VM_PROT_READ|VM_PROT_WRITE);
			curbuf += PAGE_SIZE;
			curbufsize -= PAGE_SIZE;
		}
	}
	pmap_update(pmap_kernel());
d441 1
a441 3
	printf("using %d buffers containing %d bytes of memory\n", nbuf,
	    bufpages * PAGE_SIZE);
	
a471 22
	/*
	 * Decide on buffer space to use.
	 */
	if (bufpages == 0)
		bufpages = physmem * bufcachepercent / 100;
	if (nbuf == 0) {
		nbuf = bufpages;
		if (nbuf < 16)
			nbuf = 16;
	}
	/* Restrict to at most 35% filled kvm */
	if (nbuf >
	    (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) / MAXBSIZE * 35 / 100)
		nbuf = (VM_MAX_KERNEL_ADDRESS - VM_MIN_KERNEL_ADDRESS) /
		    MAXBSIZE * 35 / 100;

	/* More buffer pages than fits into the buffers is senseless.  */
	if (bufpages > nbuf * MAXBSIZE / PAGE_SIZE)
		bufpages = nbuf * MAXBSIZE / PAGE_SIZE;

	valloc(buf, struct buf, nbuf);
	
@


1.51
log
@previous commit ppc machines.  has miod been reading tech-kern too much,
and is he trying to emulate them?
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.49 2006/06/30 16:14:31 miod Exp $	*/
d405 2
a406 1
	printf("real mem = %d (%dK)\n", ctob(physmem), ctob(physmem)/1024);
d473 2
a474 2
	printf("avail mem = %ld (%ldK)\n", ptoa(uvmexp.free),
	    ptoa(uvmexp.free) / 1024);
@


1.50
log
@Zero rval[1] in setregs.
@
text
@a576 2

	retval[1] = 0;
@


1.49
log
@Old typos bite the dust.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.48 2005/12/17 07:31:26 miod Exp $	*/
d577 2
@


1.48
log
@Get rid of deprecated vm_{offset,size}_t types for good, use {p,v}{addr,size}_t
instead; looked at millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.47 2004/11/17 20:26:02 miod Exp $	*/
d151 1
a151 1
 * initially. Later devio_malloc_safe will indicate that it's save to
@


1.47
log
@Remove dead or unused code; minor syncs with macppc code.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.46 2004/06/24 22:35:56 drahn Exp $	*/
d398 1
a398 1
	vm_offset_t minaddr, maxaddr;
d438 2
a439 2
		vm_size_t curbufsize;
		vm_offset_t curbuf;
d442 1
a442 1
		curbuf = (vm_offset_t)buffers + i * MAXBSIZE;
@


1.46
log
@Do a better job at containing powerpc specific #defines to PPC_...
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.45 2004/05/06 20:15:08 miod Exp $	*/
d47 3
a54 5
#include <uvm/uvm_extern.h>

#ifdef SYSVMSG
#include <sys/msg.h>
#endif
d64 1
d68 4
a82 1
void nameinterrupt(int, char *);
d94 1
a94 2
 *  XXX this is to fake out the console routines, while 
 *  booting. New and improved! :-) smurph
d96 2
a97 1
#include <dev/cons.h>
a98 6
int  bootcnprobe(struct consdev *);
int  bootcninit(struct consdev *);
void bootcnputc(dev_t, char);
int  bootcngetc(dev_t);
extern void nullcnpollc(dev_t, int);
#define bootcnpollc nullcnpollc
d100 2
a101 2
	(void (*))NULL, 
	(void (*))NULL, 
d103 1
a103 1
	(void (*))bootcnputc,
d105 3
a107 3
   (void (*))NULL,
   makedev(14,0), 
   1
d322 3
a470 1
	devio_malloc_safe = 1;
d485 1
a488 1
	
d517 3
a519 3
	/* Restrict to at most 70% filled kvm */
	if (nbuf * MAXBSIZE >
	    (VM_MAX_KERNEL_ADDRESS - VM_MIN_KERNEL_ADDRESS) * 7 / 10)
d521 1
a521 1
		    MAXBSIZE * 7 / 10;
d633 1
a633 1
	tf->fixreg[4] = (psp->ps_siginfo & sigmask(sig)) ? (int)&fp->sf_si : NULL;
a855 138
#if 0
/* BUS functions */
int
bus_space_map(t, bpa, size, cacheable, bshp)
	bus_space_tag_t t;
	bus_addr_t bpa;
	bus_size_t size;
	int cacheable;
	bus_space_handle_t *bshp;
{
	int error;
	
	if  (POWERPC_BUS_TAG_BASE(t) == 0) {
		/* if bus has base of 0 fail. */
		return 1;
	}
	bpa |= POWERPC_BUS_TAG_BASE(t);
	if ((error = extent_alloc_region(devio_ex, bpa, size, EX_NOWAIT |
		(ppc_malloc_ok ? EX_MALLOCOK : 0))))
	{
		return error;
	}
	if ((bpa >= 0x80000000) && ((bpa+size) < 0x90000000)) {
		if (segment8_mapped) {
			*bshp = bpa;
			return 0;
		}
	}
	if (error  = bus_mem_add_mapping(bpa, size, cacheable, bshp)) {
		if (extent_free(devio_ex, bpa, size, EX_NOWAIT | 
			(ppc_malloc_ok ? EX_MALLOCOK : 0)))
		{
			printf("bus_space_map: pa 0x%x, size 0x%x\n",
				bpa, size);
			printf("bus_space_map: can't free region\n");
		}
	}
	return 0;
}
bus_addr_t bus_space_unmap_p(bus_space_tag_t t, bus_space_handle_t bsh,
			  bus_size_t size);
void bus_space_unmap(bus_space_tag_t t, bus_space_handle_t bsh,
			  bus_size_t size);
bus_addr_t
bus_space_unmap_p(t, bsh, size)
	bus_space_tag_t t;
	bus_space_handle_t bsh;
	bus_size_t size;
{
	bus_addr_t paddr;

	pmap_extract(pmap_kernel(), bsh, &paddr);
	bus_space_unmap((t), (bsh), (size));
	return paddr ;
}
void
bus_space_unmap(t, bsh, size)
	bus_space_tag_t t;
	bus_space_handle_t bsh;
	bus_size_t size;
{
	bus_addr_t sva;
	bus_size_t off, len;
	bus_addr_t bpa;

	/* should this verify that the proper size is freed? */
	sva = trunc_page(bsh);
	off = bsh - sva;
	len = size+off;

	uvm_km_free_wakeup(phys_map, sva, len);
#if 0
	pmap_extract(pmap_kernel(), sva, &bpa);
	if (extent_free(devio_ex, bpa, size, EX_NOWAIT | 
		(ppc_malloc_ok ? EX_MALLOCOK : 0)))
	{
		printf("bus_space_map: pa 0x%x, size 0x%x\n",
			bpa, size);
		printf("bus_space_map: can't free region\n");
	}
#endif
	pmap_remove(vm_map_pmap(phys_map), sva, sva+len);
	pmap_update(vm_map_pmap(phys_map));
}

int
bus_mem_add_mapping(bpa, size, cacheable, bshp)
	bus_addr_t bpa;
	bus_size_t size;
	int cacheable;
	bus_space_handle_t *bshp;
{
	bus_addr_t vaddr;
	bus_addr_t spa, epa;
	bus_size_t off;
	int len;

	spa = trunc_page(bpa);
	epa = bpa + size;
	off = bpa - spa;
	len = size+off;

#if 0
	if (epa <= spa) {
		panic("bus_mem_add_mapping: overflow");
	}
#endif
	if (ppc_malloc_ok == 0) { 
		bus_size_t alloc_size;

		/* need to steal vm space before kernel vm is initialized */
		alloc_size = trunc_page(size + NBPG);

		vaddr = VM_MIN_KERNEL_ADDRESS + ppc_kvm_stolen;
		ppc_kvm_stolen -= alloc_size;
		if (ppc_kvm_stolen > PPC_SEGMENT_LENGTH) {
			panic("ppc_kvm_stolen, out of space");
		}
	} else {
		vaddr = uvm_km_valloc_wait(phys_map, len);
	}
	*bshp = vaddr + off;
#ifdef DEBUG_BUS_MEM_ADD_MAPPING
	printf("mapping %x size %x to %x vbase %x\n", 
		bpa, size, *bshp, spa);
#endif
	for (; len > 0; len -= NBPG) {
		pmap_kenter_cache(vaddr, spa,
			VM_PROT_READ | VM_PROT_WRITE,
			cacheable ? PMAP_CACHE_WT : PMAP_CACHE_DEFAULT);
		spa += NBPG;
		vaddr += NBPG;
	}
	return 0;
}

#endif /* 0 */

d906 1
a906 1
	for (; size > 0; size -= NBPG) {
a912 120
#if 0

/*
 * probably should be ppc_space_copy
 */

#define _CONCAT(A,B) A ## B
#define __C(A,B)	_CONCAT(A,B)

#define BUS_SPACE_COPY_N(BYTES,TYPE) 					\
void 									\
__C(bus_space_copy_,BYTES)(v, h1, o1, h2, o2, c)			\
	void *v;							\
	bus_space_handle_t h1, h2;					\
	bus_size_t o1, o2, c;						\
{									\
	TYPE val;							\
	TYPE *src, *dst;						\
	int i;								\
									\
	src = (TYPE *) (h1+o1);						\
	dst = (TYPE *) (h2+o2);						\
									\
	if (h1 == h2 && o2 > o1) {					\
		for (i = c; i > 0; i--) {				\
			dst[i] = src[i];				\
		}							\
	} else {							\
		for (i = 0; i < c; i++) {				\
			dst[i] = src[i];				\
		}							\
	}								\
}
BUS_SPACE_COPY_N(1,u_int8_t)
BUS_SPACE_COPY_N(2,u_int16_t)
BUS_SPACE_COPY_N(4,u_int32_t)

#define BUS_SPACE_SET_REGION_N(BYTES,TYPE)				\
void									\
__C(bus_space_set_region_,BYTES)(v, h, o, val, c)			\
	void *v;							\
	bus_space_handle_t h;						\
	TYPE val;							\
	bus_size_t c;							\
{									\
	TYPE *dst;							\
	int i;								\
									\
	dst = (TYPE *) (h+o);						\
	for (i = 0; i < c; i++) {					\
		dst[i] = val;						\
	}								\
}

BUS_SPACE_SET_REGION_N(1,u_int8_t)
BUS_SPACE_SET_REGION_N(2,u_int16_t)
BUS_SPACE_SET_REGION_N(4,u_int32_t)

#define BUS_SPACE_READ_RAW_MULTI_N(BYTES,SHIFT,TYPE)			\
void									\
__C(bus_space_read_raw_multi_,BYTES)(bst, h, o, dst, size)		\
	bus_space_tag_t bst;						\
	bus_space_handle_t h;						\
	bus_addr_t o;							\
	u_int8_t *dst;							\
	bus_size_t size;						\
{									\
	TYPE *src;							\
	TYPE *rdst = (TYPE *)dst;					\
	int i;								\
	int count = size >> SHIFT;					\
									\
	src = (TYPE *)(h+o);						\
	for (i = 0; i < count; i++) {					\
		rdst[i] = *src;						\
		__asm__("eieio");					\
	}								\
}
BUS_SPACE_READ_RAW_MULTI_N(1,0,u_int8_t)
BUS_SPACE_READ_RAW_MULTI_N(2,1,u_int16_t)
BUS_SPACE_READ_RAW_MULTI_N(4,2,u_int32_t)

#define BUS_SPACE_WRITE_RAW_MULTI_N(BYTES,SHIFT,TYPE)			\
void									\
__C(bus_space_write_raw_multi_,BYTES)(bst, h, o, src, size)		\
	bus_space_tag_t bst;						\
	bus_space_handle_t h;						\
	bus_addr_t o;							\
	const u_int8_t *src;						\
	bus_size_t size;						\
{									\
	int i;								\
	TYPE *dst;							\
	TYPE *rsrc = (TYPE *)src;					\
	int count = size >> SHIFT;					\
									\
	dst = (TYPE *)(h+o);						\
	for (i = 0; i < count; i++) {					\
		*dst = rsrc[i];						\
		__asm__("eieio");					\
	}								\
}

BUS_SPACE_WRITE_RAW_MULTI_N(1,0,u_int8_t)
BUS_SPACE_WRITE_RAW_MULTI_N(2,1,u_int16_t)
BUS_SPACE_WRITE_RAW_MULTI_N(4,2,u_int32_t)

int
bus_space_subregion(t, bsh, offset, size, nbshp)
	bus_space_tag_t t;
	bus_space_handle_t bsh;
	bus_size_t offset, size;
	bus_space_handle_t *nbshp;
{
	*nbshp = bsh + offset;
	return (0);
}

#endif /* 0 */

a930 31
}
void
nameinterrupt(replace, newstr)
	int replace;
	char *newstr;
{
#define NENTRIES 66
	char intrname[NENTRIES][30];
	char *p, *src;
	int i;
	extern char intrnames[];
	extern char eintrnames[];

	if (replace >= NENTRIES) {
		return;
	}
	src = intrnames;

	for (i = 0; i < NENTRIES; i++) {
		src += strlcpy(intrname[i], src, 30);
		src+=1; /* skip the NUL */
	}

	strlcat(intrname[replace], "/", sizeof intrname[replace]);
	strlcat(intrname[replace], newstr, sizeof intrname[replace]);

	p = intrnames;
	for (i = 0; i < NENTRIES; i++) {
		p += strlcpy(p, intrname[i], eintrnames - p);
		p += 1; /* skip the NUL */
	}
@


1.45
log
@Typo
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.44 2004/01/29 21:30:02 miod Exp $	*/
d973 1
a973 1
		if (ppc_kvm_stolen > SEGMENT_LENGTH) {
d1014 1
a1014 1
		if (ppc_kvm_stolen > SEGMENT_LENGTH) {
@


1.44
log
@Have the bootloader pass RB_ flags, as well as the boot device, to the kernel,
and have the kernel process them correctly.

Right now code to match the BUG's idea of the boot device with the kernel's is
missing.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.43 2004/01/28 23:50:19 miod Exp $	*/
d840 1
a840 1
			" configured: driver %s too many interrupts", name);
@


1.43
log
@More clock handling cleanup:
- move clock callbacks outside the firmware structure
- map the clock virtual. A bit tricky because it needs to be mapped before
  autoconf...
- compensate for the removal of 1:1 segment 8 mapping
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.42 2004/01/26 22:58:15 miod Exp $	*/
a147 3
char *bootpath;
char bootpathbuf[512];

a324 30
	/*
	 * Parse arg string.
	 */

	/* make a copy of the args! */
	strncpy(bootpathbuf, args, 512);
	bootpath= &bootpathbuf[0];
	args = bootpath;
	while ( *++args && *args != ' ');
	if (*args) {
		*args++ = 0;
		while (*args) {
			switch (*args++) {
			case 'a':
				boothowto |= RB_ASKNAME;
				break;
			case 's':
				boothowto |= RB_SINGLE;
				break;
			case 'd':
				boothowto |= RB_KDB;
				break;
			case 'c':
				boothowto |= RB_CONFIG;
				break;
			}
		}
	}
	bootpath= &bootpathbuf[0];

d401 1
a401 2
	v = (caddr_t)proc0paddr + USPACE;
	
@


1.42
log
@Map segment 8 with a BAT again for now, for NVRAM access. This is only
temporary.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.41 2004/01/25 23:04:11 miod Exp $	*/
d139 1
a139 1
int ppc_malloc_ok = 0;
a164 4
/* HACK - XXX */
int segment8_mapped = 1;
int segmentC_mapped = 0;

a215 2
	battable[8].batl = BATL(0x80000000, BAT_I);
	battable[8].batu = BATU(0x80000000);
a230 4
	/* DBAT2 used for ISA space */
	ppc_mtdbat2l(battable[8].batl);
	ppc_mtdbat2u(battable[8].batu);

d506 1
d518 4
a522 1
	devio_malloc_safe = 1;
d798 1
a798 1
		ppc_exit();
d805 2
a806 2
	ppc_boot(str);
	while(1) /* forever */;
a811 1
void mvmeprom_brdid(struct mvmeprom_brdid *);
d1043 7
a1049 3
	if ((pa >= 0x80000000) && ((pa+len) < 0x90000000)) {
		if (segment8_mapped) {
			return (void *)pa;
d1051 2
a1053 1
	va = vaddr = uvm_km_valloc_wait(phys_map, size);
d1058 1
a1058 1
	for (; size > 0; size -= NBPG) {
d1061 2
a1062 2
		spa += NBPG;
		vaddr += NBPG;
d1081 2
a1082 2
		pmap_remove(pmap_kernel(), vaddr,  vaddr+NBPG-1);
		vaddr += NBPG;
@


1.41
log
@Do not BAT anything but the kernel for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.40 2004/01/25 21:41:30 miod Exp $	*/
d166 1
a166 1
int segment8_mapped = 0;
d220 2
d237 4
d307 1
a307 1
	/* MVME2[67]00 max out at 256MB */
@


1.40
log
@Get rid of ppc_[gs]et_msr(), use ppc_m[ft]msr() instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.39 2004/01/24 21:10:33 miod Exp $	*/
d218 2
a219 12
	battable[0x0].batl = BATL(0x00000000, BAT_M);
	battable[0x0].batu = BATU(0x00000000);
	battable[0x8].batl = BATL(0x80000000, BAT_I);
	battable[0x8].batu = BATU(0x80000000);
	battable[0x9].batl = BATL(0x90000000, BAT_I);
	battable[0x9].batu = BATU(0x90000000);
	battable[0xf].batl = BATL(0xf0000000, BAT_I);
	battable[0xf].batu = BATU(0xf0000000);
	
	/* XXX */
	segment8_mapped = 1;
	segmentC_mapped = 0;
a234 12
	/* DBAT1, DBAT2 -> PCI I/O space */
	ppc_mtdbat1l(battable[8].batl);
	ppc_mtdbat1u(battable[8].batu);
	ppc_mtdbat2l(battable[9].batl);
	ppc_mtdbat2u(battable[9].batu);

	/* IBAT3, DBAT3 -> Raven and BUG */
	ppc_mtibat3l(battable[0x0f].batl);
	ppc_mtibat3u(battable[0x0f].batu);
	ppc_mtdbat3l(battable[0x0f].batl);
	ppc_mtdbat3u(battable[0x0f].batu);

a291 3

	uvmexp.pagesize = 4096;
	uvm_setpagesize();
d296 2
d301 1
a301 1
	/* MVME2[67]00 max out at 256MB, and we need the other BAT anyway */
@


1.39
log
@Preserve SPRG0-SPRG3 around BUG calls, as required in the PPC1Bug UM;
reminded by drahn@@, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.38 2004/01/23 10:40:01 miod Exp $	*/
a113 3
u_int32_t	ppc_get_msr(void);
u_int32_t	ppc_set_msr(u_int32_t);

a138 1
int astpending;
d174 8
a181 8
	extern caddr_t trapcode, trapsize;
	extern caddr_t dsitrap, dsisize;
	extern caddr_t isitrap, isisize;
	extern caddr_t alitrap, alisize;
	extern caddr_t decrint, decrsize;
	extern caddr_t tlbimiss, tlbimsize;
	extern caddr_t tlbdlmiss, tlbdlmsize;
	extern caddr_t tlbdsmiss, tlbdsmsize;
d183 1
a183 1
	extern caddr_t ddblow, ddbsize;
d201 1
a201 1
	
d272 1
a272 1
			bcopy(&dsitrap, (void *)EXC_DSI, (size_t)&dsisize);
d275 1
a275 1
			bcopy(&isitrap, (void *)EXC_ISI, (size_t)&isisize);
d278 1
a278 1
			bcopy(&alitrap, (void *)EXC_ALI, (size_t)&alisize);
d281 1
a281 1
			bcopy(&decrint, (void *)EXC_DECR, (size_t)&decrsize);
d284 1
a284 1
			bcopy(&tlbimiss, (void *)EXC_IMISS, (size_t)&tlbimsize);
d287 1
a287 1
			bcopy(&tlbdlmiss, (void *)EXC_DLMISS, (size_t)&tlbdlmsize);
d290 1
a290 1
			bcopy(&tlbdsmiss, (void *)EXC_DSMISS, (size_t)&tlbdsmsize);
a406 1
	prep_bus_space_init();	
a422 4
	/*
	 * Replace with real console.
	 */
	cninit();
d544 1
a911 17
}

u_int32_t
ppc_get_msr(void)
{
	u_int32_t msr;
	__asm__ volatile("mfmsr %0" : "=r"(msr));
	return(msr);
}

u_int32_t
ppc_set_msr(msr)
	u_int32_t msr;
{
	__asm__ volatile("mtmsr %0" :: "r"(msr));
	__asm__ volatile("mfmsr %0" : "=r"(msr));
	return(msr);
@


1.38
log
@Nuke last common.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.37 2004/01/22 20:45:20 miod Exp $	*/
d60 1
a189 1
	extern void callback(void *);
d197 1
a531 1
#if 1
a532 1
#endif
@


1.37
log
@Make locore and the early initialization code closer to other ppc ports;
also remove ipkbd and other dead code.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.36 2003/12/20 22:40:27 miod Exp $	*/
d770 2
a771 2
volatile int cpl, ipending, astpending, tickspending;
int imask[IPL_NUM/*7*/];
@


1.36
log
@Pass -Wformat
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.35 2003/11/25 21:16:44 drahn Exp $	*/
a33 3
/*
#include "machine/ipkdb.h"
*/
a78 1
void systype(char *);
a169 1
int segment0_mapped = 0;
a171 2
extern int where;

a187 3
#if NIPKDB > 0
	extern caddr_t ipkdblow, ipkdbsize;
#endif
a197 1
where = 3;
d209 8
a216 8
	__asm__ volatile ("mtibatu 0,%0" :: "r"(0));
	__asm__ volatile ("mtibatu 1,%0" :: "r"(0));
	__asm__ volatile ("mtibatu 2,%0" :: "r"(0));
	__asm__ volatile ("mtibatu 3,%0" :: "r"(0));
	__asm__ volatile ("mtdbatu 0,%0" :: "r"(0));
	__asm__ volatile ("mtdbatu 1,%0" :: "r"(0));
	__asm__ volatile ("mtdbatu 2,%0" :: "r"(0));
	__asm__ volatile ("mtdbatu 3,%0" :: "r"(0));
d219 1
a219 1
	 * Set up initial BAT table to only map the lowest 256 MB area
d221 2
a222 19
	battable[0].batl = BATL(0x00000000, BAT_M);
	battable[0].batu = BATU(0x00000000);

	/* map all of possible physical memory, ick */
	battable[0x1].batl = BATL(0x10000000, BAT_M);
	battable[0x1].batu = BATU(0x10000000);
	battable[0x2].batl = BATL(0x20000000, BAT_M);
	battable[0x2].batu = BATU(0x20000000);
	battable[0x3].batl = BATL(0x30000000, BAT_M);
	battable[0x3].batu = BATU(0x30000000);
	battable[0x4].batl = BATL(0x40000000, BAT_M);
	battable[0x4].batu = BATU(0x40000000);
	battable[0x5].batl = BATL(0x50000000, BAT_M);
	battable[0x5].batu = BATU(0x50000000);
	battable[0x6].batl = BATL(0x60000000, BAT_M);
	battable[0x6].batu = BATU(0x60000000);
	battable[0x7].batl = BATL(0x70000000, BAT_M);
	battable[0x7].batu = BATU(0x70000000);

d227 2
a228 2
	battable[0xa].batl = BATL(0xf0000000, BAT_I);
	battable[0xa].batu = BATU(0xf0000000);
d230 1
a230 1
	segment0_mapped = 1;
d241 3
a243 2
	__asm__ volatile ("mtibatl 0,%0; mtibatu 0,%1"
		      :: "r"(battable[0].batl), "r"(battable[0].batu));
d245 2
a246 2
	__asm__ volatile ("mtdbatl 0,%0; mtdbatu 0,%1"
		      :: "r"(battable[0].batl), "r"(battable[0].batu));
d248 11
a258 26
#if 0
	__asm__ volatile ("mtdbatl 1,%0; mtdbatu 1,%1"
		      :: "r"(battable[1].batl), "r"(battable[1].batu));
	__asm__ volatile ("sync;isync");
#endif
	/* IBAT1 used for last 256 MB segment  ROM */
	__asm__ volatile ("mtibatl 1,%0; mtibatu 1,%1"
		      :: "r"(battable[0xa].batl), "r"(battable[0xa].batu));
	/* DBAT1 used similar */
	__asm__ volatile ("mtdbatl 1,%0; mtdbatu 1,%1"
		      :: "r"(battable[0xa].batl), "r"(battable[0xa].batu));
	/* IBAT2 used for last 256 MB segment  ROM */
	__asm__ volatile ("mtibatl 2,%0; mtibatu 2,%1"
		      :: "r"(battable[0x8].batl), "r"(battable[0x8].batu));
	/* DBAT2 used similar */
	__asm__ volatile ("mtdbatl 2,%0; mtdbatu 2,%1"
		      :: "r"(battable[0x8].batl), "r"(battable[0x8].batu));
	
#if 0
	/* IBAT3 used for last 256 MB segment  ROM */
	__asm__ volatile ("mtibatl 3,%0; mtibatu 3,%1"
		      :: "r"(battable[0x3].batl), "r"(battable[0x3].batu));
	/* DBAT3 used similar */
	__asm__ volatile ("mtdbatl 3,%0; mtdbatu 3,%1"
		      :: "r"(battable[0x3].batl), "r"(battable[0x3].batu));
#endif
d263 1
a263 1
	for (exc = EXC_RSVD; exc <= EXC_LAST; exc += 0x100)
d273 1
d295 1
a295 1
#if NIPKDB > 0 || defined(DDB)
a298 1
#ifdef DDB
a299 3
#else
			bcopy(&ipkdblow, (void *)exc, (size_t)&ipkdbsize);
#endif 
d303 1
d326 17
d348 1
a348 1
	ppc_vmon();
a357 11
	/*                                                              
	 * Look at arguments passed to us and compute boothowto.      
	 * Default to SINGLE and ASKNAME if no args or
	 * SINGLE and DFLTROOT if this is a ramdisk kernel.                     
	 */                                                               
#ifdef RAMDISK_HOOKS
	boothowto = RB_SINGLE | RB_DFLTROOT;
#else
	boothowto = RB_AUTOBOOT;
#endif /* RAMDISK_HOOKS */

a430 3
#ifdef OWF
	ofwconprobe();
#endif 
a431 8
#if NIPKDB > 0
	/*
	 * Now trap to IPKDB
	 */
	ipkdb_init();
	if (boothowto & RB_KDB)
		ipkdb_connect(0);
#else
a435 1
#endif
d445 1
a445 1
	int omsr, msr;
d451 1
a451 2
	__asm__ volatile ("mfmsr %0; andi. %1, %0, %2; mtmsr %1"
		      : "=r"(omsr), "=r"(msr) : "K"((u_short)~PSL_EE));
d456 1
a456 1
	__asm__ volatile ("mtmsr %0" :: "r"(omsr));
d493 3
a495 3
		    NULL, UVM_UNKNOWN_OFFSET, 0,
		    UVM_MAPFLAG(UVM_PROT_NONE, UVM_PROT_NONE, UVM_INH_NONE,
				UVM_ADV_NORMAL, 0)))
d531 3
a548 1
	
d628 1
a628 1
	u_int32_t       args[4];
a662 3
#if WHEN_WE_ONLY_FLUSH_DATA_WHEN_DOING_PMAP_ENTER
	int pa;
#endif
d680 1
d771 1
a771 1
int imask[7];
a805 3
#if 0
	char *what;
#endif
d836 1
a869 37
/*
 * set system type from string
 */
void
systype(char *name)
{
	/* this table may be order specific if substrings match several
	 * computers but a longer string matches a specific 
	 */
	int i;
	struct systyp {
		char *name;
		char *systypename;
		int type;
	} systypes[] = {
		{ "MOT",	"(PWRSTK) MCG powerstack family", PWRSTK },
		{ "V-I Power",	"(POWER4e) V-I ppc vme boards ",  POWER4e},
		{ "iMac",	"(APPL) Apple iMac ",  APPL},
		{ "PowerMac",	"(APPL) Apple PowerMac ",  APPL},
		{ "PowerBook",	"(APPL) Apple Powerbook ",  APPL},
		{ NULL,"",0}
	};
	for (i = 0; systypes[i].name != NULL; i++) {
		if (strncmp( name , systypes[i].name,
			strlen (systypes[i].name)) == 0)
		{
			system_type = systypes[i].type;
			printf("recognized system type of %s as %s\n",
				name, systypes[i].systypename);
			break;
		}
	}
	if (system_type == OFWMACH) {
		printf("System type %snot recognized, good luck\n",
			name);
	}
}
d1098 1
a1098 1
	va = vaddr = uvm_km_valloc(phys_map, size);
a1125 3
#if 0
		pmap_remove(vm_map_pmap(phys_map), vaddr, vaddr+NBPG-1);
#else
a1126 1
#endif
d1260 1
a1260 1
	register void *oldh = curproc->p_addr->u_pcb.pcb_onfault;
@


1.35
log
@Allow mvmeppc to compile again. not a supported arch.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.34 2003/11/06 21:09:35 mickey Exp $	*/
d592 2
a593 2
	printf("avail mem = %d (%dK)\n", ptoa(uvmexp.free),
	    ptoa(uvmexp.free)/1024);
@


1.34
log
@move netisr definition into md code to allow arch provide suitable allocation; tested on most archs
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.33 2003/09/22 21:39:40 miod Exp $	*/
a1010 27
}

/*
 * General functions to enable and disable interrupts
 * without having inlined assembly code in many functions,
 * should be moved into a header file for inlining the function
 * so it is faster
 */
void
ppc_intr_enable(int enable)
{
	u_int32_t emsr, dmsr;
	if (enable != 0)  {
		__asm__ volatile("mfmsr %0" : "=r"(emsr));
		dmsr = emsr | PSL_EE;
		__asm__ volatile("mtmsr %0" :: "r"(dmsr));
	}
}

int
ppc_intr_disable(void)
{
	u_int32_t emsr, dmsr;
	__asm__ volatile("mfmsr %0" : "=r"(emsr));
	dmsr = emsr & ~PSL_EE;
	__asm__ volatile("mtmsr %0" :: "r"(dmsr));
	return (emsr & PSL_EE);
@


1.33
log
@Off-by-ones, from aaron@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.32 2003/08/06 21:08:06 millert Exp $	*/
d823 1
@


1.32
log
@Remove some double semicolons (hmm, do two semis equal a maxi?).
I've skipped the GNU stuff for now.  From Patrick Latifi.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.31 2003/04/06 18:54:19 ho Exp $	*/
d1403 1
a1403 1
	if (replace > NENTRIES) {
@


1.31
log
@strcat/strcpy/sprintf cleanup. krw@@, anil@@ ok. art@@ tested sparc64.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.30 2003/02/26 21:54:44 drahn Exp $	*/
d1002 1
a1002 1
intr_establish_t *intr_establish_func = ppc_intr_establish;;
@


1.30
log
@Remove an unnecessary structure copy from useage of setfault(), call
by reference, not by value, ok matthieu#, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.29 2002/12/17 23:11:32 millert Exp $	*/
d1413 2
a1414 2
	strcat(intrname[replace], "/");
	strcat(intrname[replace], newstr);
@


1.29
log
@Make SysV-style shared memory and semaphore limits sysctl'able.
Instead of allocating a static amount of memory for the data
structures via valloc() in allocsys(), allocate things dynamically
using pool(9) when possible and malloc(9) when not.  The various
members of struct seminfo and struct shminfo are in kern.seminfo
and kern.shminfo respectively (not all members of kern.seminfo are
changable).

The data structures used still leave something to be desired but
things are not made worse in that respect by this commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.28 2002/10/13 18:26:12 krw Exp $	*/
d1382 1
a1382 1
	if (setfault(env)) {
@


1.28
log
@Remove more '\n's from panic() statements.  From Chris Kuethe.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.27 2002/07/20 19:24:56 art Exp $	*/
a56 6
#ifdef SYSVSHM
#include <sys/shm.h>
#endif
#ifdef SYSVSEM
#include <sys/sem.h>
#endif
a616 11
#ifdef	SYSVSHM
	shminfo.shmmax = shmmaxpgs;
	shminfo.shmall = shmmaxpgs;
	shminfo.shmseg = shmseg;
	valloc(shmsegs, struct shmid_ds, shminfo.shmmni);
#endif
#ifdef	SYSVSEM
	valloc(sema, struct semid_ds, seminfo.semmni);
	valloc(sem, struct sem, seminfo.semmns);
	valloc(semu, int, (seminfo.semmnu * seminfo.semusz) / sizeof(int));
#endif
@


1.27
log
@Instead of copying out the signal trampoline on top of the stack, create
an uvm aobj, copy out the signal trampoline into it and share that page
among all processes for the same emulation.

This also requires us to actually be able to tell signal code where the
trampoline is located, so introduce a new field in struct proc - p_sigcode
that is a pointer to sigcode. This allows us to remove all the ugly
calculations of the signal trampoline address done in every sendsig
function in the tree (that's why so many files are changed).

Tested by various people. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.26 2002/06/08 15:48:58 miod Exp $	*/
d1013 1
a1013 1
			" configured: driver %s too many interrupts\n", name);
@


1.26
log
@Strict prototypes, fix lcsplx() behaviour as per macppc, and a few
other fixes here and there.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.25 2002/06/07 01:01:40 miod Exp $	*/
d771 1
a771 2
	tf->srr0 = (int)(((char *)PS_STRINGS)
			 - (p->p_emul->e_esigcode - p->p_emul->e_sigcode));
@


1.25
log
@Switch mvmeppc to the current powerpc pmap scheme.
Only compile-tested so far, since the VME rack is not in the room yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.24 2002/03/23 13:28:34 espie Exp $	*/
d84 7
d206 1
d213 2
a214 7
	/*
	 * XXX We use the page just above the interrupt vector as
	 * message buffer
	 */
	initmsgbuf((void *)0x3000, MSGBUFSIZE);
	where = 3;
	
d307 1
d355 11
a375 1
	ppc_vmon();
d381 1
d386 5
d396 1
a396 1
#ifdef RAMDISK_HOOKS                                         
d429 6
a434 1
	}			
d461 1
a461 1
    */
a487 1
	kdb_init();
a491 1

d532 1
a532 1
	printf("real mem = %d\n", ctob(physmem));
d582 1
d598 2
a599 1
	printf("avail mem = %d\n", ptoa(uvmexp.free));
d849 6
a854 43
#ifdef	INET
#include "ether.h"
#if NETHER > 0
	if (isr & (1 << NETISR_ARP))
		arpintr();
#endif
	if (isr & (1 << NETISR_IP))
		ipintr();
#endif
#ifdef INET6
	if (isr & (1 << NETISR_IPV6))
		ip6intr();
#endif
#ifdef NETATALK
	if (isr & (1 << NETISR_ATALK))
		atintr();
#endif
#ifdef	IMP
	if (isr & (1 << NETISR_IMP))
		impintr();
#endif
#ifdef	NS
	if (isr & (1 << NETISR_NS))
		nsintr();
#endif
#ifdef	ISO
	if (isr & (1 << NETISR_ISO))
		clnlintr();
#endif
#ifdef	CCITT
	if (isr & (1 << NETISR_CCITT))
		ccittintr();
#endif
#include "ppp.h"
#if NPPP > 0
	if (isr & (1 << NETISR_PPP))
		pppintr();
#endif
#include "bridge.h"
#if NBRIDGE > 0
	if (isr & (1 << NETISR_BRIDGE))
		bridgeintr();
#endif
d857 1
a857 1
void
d861 3
d865 1
a879 1
	char *ap = str;
d914 1
d988 6
@


1.24
log
@Add variables for config(8) -e time tweak of systemV shared memory
parameters.

Ok millert@@, miod@@, maja@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.23 2002/03/14 03:15:58 millert Exp $	*/
d1076 2
a1189 1
		ppc_kvm_size -= alloc_size;
d1191 5
a1195 1
		vaddr = VM_MIN_KERNEL_ADDRESS + ppc_kvm_size;
@


1.23
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.22 2002/03/14 01:26:41 millert Exp $	*/
d599 3
@


1.22
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.21 2002/02/17 22:59:53 maja Exp $	*/
d672 1
a672 1
	copyin ((void*)(VM_MAX_ADDRESS-0x10), &args, 0x10);
d987 2
a988 2
typedef void     *(intr_establish_t) __P((void *, pci_intr_handle_t,
            int, int, int (*func)(void *), void *, char *));
d1237 1
a1237 1
	return (void*) (va+off);
@


1.21
log
@Patch from Daniel Lucq <daniel@@lucq.org>

The patch allows you to change the value of NMBCLUSTERS, BUFCACHEPERCENT
and NKMEMPAGES using the config command, instead of recompiling the kernel.

This is the kernel part of the patch. I have compiled it on i386, sparc64,
alpha and macppc. -moj ok art@@ maja@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.20 2002/01/23 17:51:52 art Exp $	*/
d99 5
a103 5
int  bootcnprobe __P((struct consdev *));
int  bootcninit __P((struct consdev *));
void bootcnputc __P((dev_t, char));
int  bootcngetc __P((dev_t));
extern void nullcnpollc __P((dev_t, int));
d116 2
a117 2
u_int32_t	ppc_get_msr __P((void));
u_int32_t	ppc_set_msr __P((u_int32_t));
d160 1
a160 1
caddr_t allocsys __P((caddr_t));
d197 2
a198 2
	extern void consinit __P((void));
	extern void callback __P((void *));
d473 1
a473 1
	void (*handler) __P((void));
d989 1
a989 1
typedef void     (intr_disestablish_t) __P((void *, void *));
d1000 1
a1000 1
	int (*func) __P((void *));
d1112 4
a1115 4
bus_addr_t bus_space_unmap_p __P((bus_space_tag_t t, bus_space_handle_t bsh,
			  bus_size_t size));
void bus_space_unmap __P((bus_space_tag_t t, bus_space_handle_t bsh,
			  bus_size_t size));
@


1.20
log
@move mb_map allocation to mbinit()
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.19 2002/01/23 17:35:56 art Exp $	*/
d127 5
d137 1
a612 3
#ifndef BUFCACHEPERCENT
#define BUFCACHEPERCENT 5
#endif
d617 1
a617 1
		bufpages = physmem * BUFCACHEPERCENT / 100;
@


1.19
log
@move definition of mb_map from zillions of machdep.c to uipc_mbuf.c
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.18 2002/01/16 20:50:17 miod Exp $	*/
a567 4

	mb_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
	    VM_MBUF_SIZE, VM_MAP_INTRSAFE, FALSE, NULL);

@


1.18
log
@Don't include <sys/map.h> when you don't need what's in it.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.17 2001/12/08 02:24:06 art Exp $	*/
a135 1
struct vm_map *mb_map = NULL;
@


1.17
log
@Sprinkle pmap_update calls where relevant and some other
misc pmap usage fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.16 2001/11/28 16:13:29 art Exp $	*/
a42 1
#include <sys/map.h>
@


1.17.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.20 2002/01/23 17:51:52 art Exp $	*/
d43 1
d137 1
d570 4
@


1.17.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.17.2.1 2002/01/31 22:55:20 niklas Exp $	*/
a83 7
void initppc(u_int, u_int, char *);
void dumpsys(void);
int lcsplx(int);
void myetheraddr(u_char *);
void systype(char *);
void nameinterrupt(int, char *);

d99 5
a103 5
int  bootcnprobe(struct consdev *);
int  bootcninit(struct consdev *);
void bootcnputc(dev_t, char);
int  bootcngetc(dev_t);
extern void nullcnpollc(dev_t, int);
d116 2
a117 2
u_int32_t	ppc_get_msr(void);
u_int32_t	ppc_set_msr(u_int32_t);
a126 5

#ifndef BUFCACHEPERCENT
#define BUFCACHEPERCENT 5
#endif

a131 1
int bufcachepercent = BUFCACHEPERCENT;
d154 1
a154 1
caddr_t allocsys(caddr_t);
d191 2
a192 3
	extern void consinit(void);
	extern void callback(void *);
	extern void *msgbuf_addr;
d199 7
a205 2

where = 3;
a297 1

a344 11
	/* Grr, ALTIVEC_UNAVAIL is a vector not ~0xff aligned: 0x0f20 */
	bcopy(&trapcode, (void *)0xf20, (size_t)&trapsize);

	/*
	 * since trapsize is > 0x20, we just overwrote the EXC_PERF handler
	 * since we do not use it, we will "share" it with the EXC_VEC,
	 * we dont support EXC_VEC either.
	 * should be a 'ba 0xf20 written' at address 0xf00, but we
	 * do not generate EXC_PERF exceptions...
	 */

d355 1
a360 1
	ppc_vmon();
a364 5
	/*
	 * use the memory provided by pmap_bootstrap for message buffer
	 */
	initmsgbuf(msgbuf_addr, MSGBUFSIZE);

d370 1
a370 1
#ifdef RAMDISK_HOOKS
d403 1
a403 6
	}
	bootpath= &bootpathbuf[0];

#ifdef DDB
	ddb_init();
#endif
d430 1
a430 1
	 */
d457 1
d462 1
d467 1
a467 1
	void (*handler)(void);
d503 1
a503 1
	printf("real mem = %d (%dK)\n", ctob(physmem), ctob(physmem)/1024);
a552 1
	pmap_update(pmap_kernel());
d568 1
a568 2
	printf("avail mem = %d (%dK)\n", ptoa(uvmexp.free),
	    ptoa(uvmexp.free)/1024);
a592 3
	shminfo.shmmax = shmmaxpgs;
	shminfo.shmall = shmmaxpgs;
	shminfo.shmseg = shmseg;
d607 3
d614 1
a614 1
		bufpages = physmem * bufcachepercent / 100;
d669 1
a669 1
	copyin ((void *)(VM_MAX_ADDRESS-0x10), &args, 0x10);
d818 43
a860 6
#define	DONETISR(flag, func) \
	if (isr & (1 << (flag))) \
		(func)();

#include <net/netisr_dispatch.h>
#undef	DONETISR
d863 1
a863 1
int
a866 3
	int oldcpl;

	oldcpl = cpl;
a867 1
	return oldcpl;
d882 1
a916 1
void mvmeprom_brdid(struct mvmeprom_brdid *);
d984 3
a986 3
typedef void     *(intr_establish_t)(void *, pci_intr_handle_t,
            int, int, int (*func)(void *), void *, char *);
typedef void     (intr_disestablish_t)(void *, void *);
a990 6
void *ppc_intr_establish(void *, pci_intr_handle_t, int, int, int (*)(void *),
    void *, char *);
void ppc_intr_setup(intr_establish_t *, intr_disestablish_t *);
void ppc_intr_enable(int);
int ppc_intr_disable(void);

d997 1
a997 1
	int (*func)(void *);
a1069 2
vaddr_t ppc_kvm_stolen = VM_KERN_ADDRESS_SIZE;

d1109 4
a1112 4
bus_addr_t bus_space_unmap_p(bus_space_tag_t t, bus_space_handle_t bsh,
			  bus_size_t size);
void bus_space_unmap(bus_space_tag_t t, bus_space_handle_t bsh,
			  bus_size_t size);
d1182 1
d1184 1
a1184 5
		vaddr = VM_MIN_KERNEL_ADDRESS + ppc_kvm_stolen;
		ppc_kvm_stolen -= alloc_size;
		if (ppc_kvm_stolen > SEGMENT_LENGTH) {
			panic("ppc_kvm_stolen, out of space");
		}
d1234 1
a1234 1
	return (void *) (va+off);
@


1.17.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.17.2.2 2002/06/11 03:37:22 art Exp $	*/
d771 2
a772 1
	tf->srr0 = p->p_sigcode;
d1014 1
a1014 1
			" configured: driver %s too many interrupts", name);
@


1.17.2.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d57 6
d623 11
d1399 1
a1399 1
	if (setfault(&env)) {
d1430 2
a1431 2
	strlcat(intrname[replace], "/", sizeof intrname[replace]);
	strlcat(intrname[replace], newstr, sizeof intrname[replace]);
@


1.16
log
@zap some typedefs.
vm_map_t -> struct vm_map *
vm_map_entry_t -> struct vm_map_entry *
simple_lock_data_t -> struct simplelock

(uvm not done yet, coming in the next commit)
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.15 2001/11/28 13:47:39 art Exp $	*/
d1158 1
d1264 1
a1264 1
	return;
@


1.15
log
@Sync in more uvm changes from NetBSD.
This time we're getting rid of KERN_* and VM_PAGER_* error codes and
use errnos instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.14 2001/11/09 15:25:55 art Exp $	*/
d136 3
a138 3
vm_map_t exec_map = NULL;
vm_map_t mb_map = NULL;
vm_map_t phys_map = NULL;
@


1.14
log
@nswbuf hasn't been used for ages. gc.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.13 2001/11/07 01:18:00 art Exp $	*/
d525 1
a525 1
				UVM_ADV_NORMAL, 0)) != KERN_SUCCESS)
@


1.13
log
@Add an alignment argument to uvm_map that specifies an alignment hint
for the virtual address.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.12 2001/11/06 22:46:00 miod Exp $	*/
a122 1
int	nswbuf = 0;
a635 5
	if (nswbuf == 0) {
		nswbuf = (nbuf / 2) & ~1;
		if (nswbuf > 256)
			nswbuf = 256;
	}
@


1.12
log
@-Wall -Werror cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.11 2001/11/06 19:53:15 miod Exp $	*/
d524 1
a524 1
		    NULL, UVM_UNKNOWN_OFFSET,
@


1.11
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.10 2001/09/19 20:50:57 mickey Exp $	*/
d34 1
d36 1
d180 8
a187 11
	int phandle, qhandle;
	char name[32];
	struct machvec *mp;
	extern trapcode, trapsize;
	extern dsitrap, dsisize;
	extern isitrap, isisize;
	extern alitrap, alisize;
	extern decrint, decrsize;
	extern tlbimiss, tlbimsize;
	extern tlbdlmiss, tlbdlmsize;
	extern tlbdsmiss, tlbdsmsize;
d189 1
a189 1
	extern ddblow, ddbsize;
d192 1
a192 1
	extern ipkdblow, ipkdbsize;
a196 1
	u_int32_t msr;
d472 1
a472 1
	extern extint, extsize;
d710 1
d712 1
d777 1
a777 1
	if (error = copyin(SCARG(uap, sigcntxp), &sc, sizeof sc))
d894 1
a894 1
	char *ap = str, *ap1 = ap;
d1205 3
a1207 6
#if 0
		pmap_enter(vm_map_pmap(phys_map), vaddr, spa,
#else
		pmap_enter(pmap_kernel(), vaddr, spa,
#endif
			VM_PROT_READ | VM_PROT_WRITE, PMAP_WIRED /* XXX */);
d1240 2
a1241 6
#if 0
		pmap_enter(vm_map_pmap(phys_map), vaddr, spa,
#else
		pmap_enter(pmap_kernel(), vaddr, spa,
#endif
			VM_PROT_READ | VM_PROT_WRITE, PMAP_WIRED/* XXX */);
d1403 1
a1403 1
		curpcb->pcb_onfault = 0;
@


1.10
log
@merge vm/vm_kern.h into uvm/uvm_extern.h; art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.9 2001/09/12 00:23:34 art Exp $	*/
a53 1
#include <vm/vm.h>
@


1.9
log
@mbutl no more
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.8 2001/09/11 20:10:00 miod Exp $	*/
d55 1
a55 1
#include <vm/vm_kern.h>
@


1.8
log
@Fix uvm_km_suballoc() usage flags. ok art@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.7 2001/08/27 21:15:17 miod Exp $	*/
d575 1
a575 1
	mb_map = uvm_km_suballoc(kernel_map, (vm_offset_t *)&mbutl, &maxaddr,
@


1.7
log
@cold is in <sys/systm.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.6 2001/08/23 14:01:03 art Exp $	*/
d565 1
a565 1
	    TRUE, FALSE, NULL);
d571 1
a571 1
	    VM_PHYS_SIZE, TRUE, FALSE, NULL);
d576 1
a576 1
	    VM_MBUF_SIZE, FALSE, FALSE, NULL);
@


1.6
log
@We can now move timeout_init into main().
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.5 2001/08/23 12:02:04 art Exp $	*/
a91 1
extern int cold;
@


1.5
log
@Remove even more old timeout tentacles.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.4 2001/07/25 13:25:32 art Exp $	*/
a578 5
	/*
	 * Initialize timeouts.
	 */
	timeout_init();
	
@


1.4
log
@Change the pmap_enter interface to merge access_type and the wired boolean
and arbitrary flags into one argument.

One new flag is PMAP_CANFAIL that tells pmap_enter that it can fail if there
are not enough resources to satisfy the request. If this flag is not passed,
pmap_enter should panic as it should have done before this change (XXX - many
pmaps are still not doing that).

Only i386 and alpha implement CANFAIL for now.

Includes uvm updates from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.3 2001/07/06 05:14:30 smurph Exp $	*/
a607 1
	valloc(timeouts, struct timeout, ntimeout);
@


1.3
log
@resolve compile problems
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.2 2001/06/27 04:32:46 art Exp $	*/
d1218 1
a1218 1
			VM_PROT_READ | VM_PROT_WRITE, TRUE, 0/* XXX */);
d1256 1
a1256 1
			VM_PROT_READ | VM_PROT_WRITE, TRUE, 0/* XXX */);
@


1.2
log
@whack old vm
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.1 2001/06/26 21:57:54 smurph Exp $	*/
a171 1
unsigned char fw_vectors[0x3000];
a204 1
	bcopy((void *)0, &fw_vectors[0], 0x3000);
d219 1
a219 3
#ifdef STEVE_DEBUG
	printf("initmsgbuf() done.\n");
#endif 
a304 4
#ifdef STEVE_DEBUG
	printf("bats mapped.\n");
#endif 
#if 1
a317 1
#if 1
a326 1
#endif
a352 4
#endif
#ifdef STEVE_DEBUG
	printf("vectors set.\n");
#endif 
a356 3
#ifdef STEVE_DEBUG
	printf("page size set.\n");
#endif 
a361 1
	/*(fw->vmon)();*/
a363 14
#ifdef STEVE_DEBUG
	printf("pmap_bootstrap() done.\n");
	/* mvmeprom_return(); */
#endif 
	msr = ppc_get_msr();
	msr &= ~PSL_IP;
	ppc_set_msr(msr);
#ifdef STEVE_DEBUG
	printf("msr == 0x%08x\n", msr);
	printf("bit == %032b\n", msr);
	printf("made it!\n");
	/* mvmeprom_return(); */
#endif 

a371 3
#if 1 /*def STEVE_DEBUG*/
	printf("translation enabled.\n");
#endif 
d411 1
a411 6
#if 0
	ddb_init((int)(esym - (&_end)), &_end, esym);
#endif
#ifdef STEVE_DEBUG
	printf("boothowto == %d\n", boothowto);
#endif 
a429 3
#ifdef STEVE_DEBUG
	printf("before extent_create()\n");
#endif 
a434 3
#ifdef STEVE_DEBUG
	printf("extent_create() done.\n");
#endif 
d437 1
a437 4
         */
#ifdef STEVE_DEBUG
	printf("before consinit()\n");
#endif 
d439 1
a439 4
#ifdef STEVE_DEBUG
	printf("consinit() done.\n");
#endif 
	/* while using openfirmware, run userconfig */
a450 3
#ifdef STEVE_DEBUG
	printf("cninit() done.\n");
#endif 
a469 9
	/*
	 * Figure out ethernet address.
	 */
#if 0
	(void)power4e_get_eth_addr();
#endif 
#ifdef STEVE_DEBUG
	printf("return to locore.\n");
#endif 
d908 1
a908 4
#if 0
		/* resettodr does not currently do anything, address
		 * this later
		 */
a918 1
#endif
a924 3
		/*
		(fw->exit)();
		*/
a930 3
	/*
        (fw->boot)();
	*/
@


1.2.2.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.2 2001/06/27 04:32:46 art Exp $	*/
d55 1
a55 1
#include <uvm/uvm_extern.h>
d92 1
d172 1
d206 1
d221 3
a223 1
	
d309 4
d326 1
d336 1
d363 4
d371 3
d379 1
d382 14
d404 3
d446 6
a451 1
	
d470 3
d478 3
d483 4
a486 1
    */
d488 4
a491 1
	
d503 3
d525 9
d630 1
a630 1
	    VM_MAP_PAGEABLE, FALSE, NULL);
d636 1
a636 1
	    VM_PHYS_SIZE, 0, FALSE, NULL);
d640 2
a641 2
	mb_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
	    VM_MBUF_SIZE, VM_MAP_INTRSAFE, FALSE, NULL);
d643 5
d672 1
d972 4
a975 1
		
d986 1
d993 3
d1002 3
d1292 1
a1292 1
			VM_PROT_READ | VM_PROT_WRITE, PMAP_WIRED /* XXX */);
d1330 1
a1330 1
			VM_PROT_READ | VM_PROT_WRITE, PMAP_WIRED/* XXX */);
@


1.2.2.2
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a33 1
/*
a34 1
*/
d54 1
d122 1
d179 11
a189 8
	extern caddr_t trapcode, trapsize;
	extern caddr_t dsitrap, dsisize;
	extern caddr_t isitrap, isisize;
	extern caddr_t alitrap, alisize;
	extern caddr_t decrint, decrsize;
	extern caddr_t tlbimiss, tlbimsize;
	extern caddr_t tlbdlmiss, tlbdlmsize;
	extern caddr_t tlbdsmiss, tlbdsmsize;
d191 1
a191 1
	extern caddr_t ddblow, ddbsize;
d194 1
a194 1
	extern caddr_t ipkdblow, ipkdbsize;
d199 1
d475 1
a475 1
	extern caddr_t extint, extsize;
d527 1
a527 1
		    NULL, UVM_UNKNOWN_OFFSET, 0,
d640 5
a712 1
#if WHEN_WE_ONLY_FLUSH_DATA_WHEN_DOING_PMAP_ENTER
a713 1
#endif
d778 1
a778 1
	if ((error = copyin(SCARG(uap, sigcntxp), &sc, sizeof sc)) != 0)
d895 1
a895 1
	char *ap = str;
d1206 6
a1211 3
		pmap_kenter_cache(vaddr, spa,
			VM_PROT_READ | VM_PROT_WRITE,
			cacheable ? PMAP_CACHE_WT : PMAP_CACHE_DEFAULT);
d1244 6
a1249 2
		pmap_kenter_cache(vaddr, spa,
			VM_PROT_READ | VM_PROT_WRITE, PMAP_CACHE_DEFAULT);
d1411 1
a1411 1
		curproc->p_addr->u_pcb.pcb_onfault = oldh;
@


1.2.2.3
log
@Merge in trunk
@
text
@d43 1
a127 5

#ifndef BUFCACHEPERCENT
#define BUFCACHEPERCENT 5
#endif

a132 1
int bufcachepercent = BUFCACHEPERCENT;
d136 3
a138 2
struct vm_map *exec_map = NULL;
struct vm_map *phys_map = NULL;
d570 4
d613 3
d620 1
a620 1
		bufpages = physmem * bufcachepercent / 100;
a1157 1
	pmap_update(vm_map_pmap(phys_map));
d1263 1
a1263 1
	pmap_update(pmap_kernel());
@


1.2.2.4
log
@Merge in -current from about a week ago
@
text
@d99 5
a103 5
int  bootcnprobe(struct consdev *);
int  bootcninit(struct consdev *);
void bootcnputc(dev_t, char);
int  bootcngetc(dev_t);
extern void nullcnpollc(dev_t, int);
d116 2
a117 2
u_int32_t	ppc_get_msr(void);
u_int32_t	ppc_set_msr(u_int32_t);
d160 1
a160 1
caddr_t allocsys(caddr_t);
d197 2
a198 2
	extern void consinit(void);
	extern void callback(void *);
d473 1
a473 1
	void (*handler)(void);
d672 1
a672 1
	copyin ((void *)(VM_MAX_ADDRESS-0x10), &args, 0x10);
d987 3
a989 3
typedef void     *(intr_establish_t)(void *, pci_intr_handle_t,
            int, int, int (*func)(void *), void *, char *);
typedef void     (intr_disestablish_t)(void *, void *);
d1000 1
a1000 1
	int (*func)(void *);
d1112 4
a1115 4
bus_addr_t bus_space_unmap_p(bus_space_tag_t t, bus_space_handle_t bsh,
			  bus_size_t size);
void bus_space_unmap(bus_space_tag_t t, bus_space_handle_t bsh,
			  bus_size_t size);
d1237 1
a1237 1
	return (void *) (va+off);
@


1.2.2.5
log
@Manual merge of changes long forgotten
@
text
@d529 1
a529 1
				UVM_ADV_NORMAL, 0)))
@


1.2.2.6
log
@Sync the SMP branch with 3.3
@
text
@d57 6
a83 7
void initppc(u_int, u_int, char *);
void dumpsys(void);
int lcsplx(int);
void myetheraddr(u_char *);
void systype(char *);
void nameinterrupt(int, char *);

a198 1
	extern void *msgbuf_addr;
d205 7
a211 2

where = 3;
a303 1

a350 11
	/* Grr, ALTIVEC_UNAVAIL is a vector not ~0xff aligned: 0x0f20 */
	bcopy(&trapcode, (void *)0xf20, (size_t)&trapsize);

	/*
	 * since trapsize is > 0x20, we just overwrote the EXC_PERF handler
	 * since we do not use it, we will "share" it with the EXC_VEC,
	 * we dont support EXC_VEC either.
	 * should be a 'ba 0xf20 written' at address 0xf00, but we
	 * do not generate EXC_PERF exceptions...
	 */

d361 1
a366 1
	ppc_vmon();
a370 5
	/*
	 * use the memory provided by pmap_bootstrap for message buffer
	 */
	initmsgbuf(msgbuf_addr, MSGBUFSIZE);

d376 1
a376 1
#ifdef RAMDISK_HOOKS
d409 1
a409 6
	}
	bootpath= &bootpathbuf[0];

#ifdef DDB
	ddb_init();
#endif
d436 1
a436 1
	 */
d463 1
d468 1
d509 1
a509 1
	printf("real mem = %d (%dK)\n", ctob(physmem), ctob(physmem)/1024);
a558 1
	pmap_update(pmap_kernel());
d574 1
a574 2
	printf("avail mem = %d (%dK)\n", ptoa(uvmexp.free),
	    ptoa(uvmexp.free)/1024);
d598 8
d743 2
a744 1
	tf->srr0 = p->p_sigcode;
d821 43
a863 6
#define	DONETISR(flag, func) \
	if (isr & (1 << (flag))) \
		(func)();

#include <net/netisr_dispatch.h>
#undef	DONETISR
d866 1
a866 1
int
a869 3
	int oldcpl;

	oldcpl = cpl;
a870 1
	return oldcpl;
d885 1
a919 1
void mvmeprom_brdid(struct mvmeprom_brdid *);
a993 6
void *ppc_intr_establish(void *, pci_intr_handle_t, int, int, int (*)(void *),
    void *, char *);
void ppc_intr_setup(intr_establish_t *, intr_disestablish_t *);
void ppc_intr_enable(int);
int ppc_intr_disable(void);

d1013 1
a1013 1
			" configured: driver %s too many interrupts", name);
a1072 2
vaddr_t ppc_kvm_stolen = VM_KERN_ADDRESS_SIZE;

d1185 1
d1187 1
a1187 5
		vaddr = VM_MIN_KERNEL_ADDRESS + ppc_kvm_stolen;
		ppc_kvm_stolen -= alloc_size;
		if (ppc_kvm_stolen > SEGMENT_LENGTH) {
			panic("ppc_kvm_stolen, out of space");
		}
d1394 1
a1394 1
	if (setfault(&env)) {
@


1.2.2.7
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.2.2.6 2003/03/27 23:52:17 niklas Exp $	*/
d1413 2
a1414 2
	strlcat(intrname[replace], "/", sizeof intrname[replace]);
	strlcat(intrname[replace], newstr, sizeof intrname[replace]);
@


1.2.2.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d34 3
a62 1
#include <machine/bugio.h>
d82 1
d117 3
d145 2
a146 1
int ppc_malloc_ok;
d155 3
d172 7
d184 8
a191 8
	extern void *trapcode; extern int trapsize;
	extern void *dsitrap; extern int dsisize;
	extern void *isitrap; extern int isisize;
	extern void *alitrap; extern int alisize;
	extern void *decrint; extern int decrsize;
	extern void *tlbimiss; extern int tlbimsize;
	extern void *tlbdlmiss; extern int tlbdlmsize;
	extern void *tlbdsmiss; extern int tlbdsmsize;
d193 1
a193 1
	extern void *ddblow; extern int ddbsize;
d195 3
d199 1
a206 1
	buginit();
d208 1
d215 1
a215 1

d220 8
a227 8
	ppc_mtibat0u(0);
	ppc_mtibat1u(0);
	ppc_mtibat2u(0);
	ppc_mtibat3u(0);
	ppc_mtdbat0u(0);
	ppc_mtdbat1u(0);
	ppc_mtdbat2u(0);
	ppc_mtdbat3u(0);
d230 1
a230 1
	 * Set up initial BAT table
d234 27
d269 5
a273 2
	ppc_mtibat0l(battable[0].batl);
	ppc_mtibat0u(battable[0].batu);
d275 26
a300 3
	/* DBAT0 used similar */
	ppc_mtdbat0l(battable[0].batl);
	ppc_mtdbat0u(battable[0].batu);
d305 1
a305 1
	for (exc = EXC_RSVD; exc <= EXC_LAST; exc += 0x100) {
a314 1

d316 1
a316 1
			bcopy(&dsitrap, (void *)exc, (size_t)&dsisize);
d319 1
a319 1
			bcopy(&isitrap, (void *)exc, (size_t)&isisize);
d322 1
a322 1
			bcopy(&alitrap, (void *)exc, (size_t)&alisize);
d325 1
a325 1
			bcopy(&decrint, (void *)exc, (size_t)&decrsize);
d328 1
a328 1
			bcopy(&tlbimiss, (void *)exc, (size_t)&tlbimsize);
d331 1
a331 1
			bcopy(&tlbdlmiss, (void *)exc, (size_t)&tlbdlmsize);
d334 1
a334 1
			bcopy(&tlbdsmiss, (void *)exc, (size_t)&tlbdsmsize);
d336 1
a336 1
#ifdef DDB
d340 1
d342 3
a347 1
	}
d361 3
a367 2
	uvmexp.pagesize = 4096;
	uvm_setpagesize();
a369 17
#if 1
	/* MVME2[67]00 max out at 256MB, and we need BAT2 for now. */
#else
	/* use BATs to map 1GB memory, no pageable BATs now */
	if (physmem > btoc(0x10000000)) {
		ppc_mtdbat1l(BATL(0x10000000, BAT_M));
		ppc_mtdbat1u(BATU(0x10000000));
	}
	if (physmem > btoc(0x20000000)) {
		ppc_mtdbat2l(BATL(0x20000000, BAT_M));
		ppc_mtdbat2u(BATU(0x20000000));
	}
	if (physmem > btoc(0x30000000)) {
		ppc_mtdbat3l(BATL(0x30000000, BAT_M));
		ppc_mtdbat3u(BATU(0x30000000));
	}
#endif
d375 1
a375 1
	(fw->vmon)();
d385 41
d448 1
d465 7
d473 8
d485 1
d495 1
a495 1
	int msr;
d501 2
a502 1
	msr = ppc_intr_disable();
d507 1
a507 1
	ppc_intr_enable(msr);
d520 2
a521 1

d544 3
a546 3
	    NULL, UVM_UNKNOWN_OFFSET, 0,
	    UVM_MAPFLAG(UVM_PROT_NONE, UVM_PROT_NONE, UVM_INH_NONE,
	      UVM_ADV_NORMAL, 0)))
a581 1
	minaddr = vm_map_min(kernel_map);
a590 1
	devio_malloc_safe = 1;
d592 2
a593 2
	printf("avail mem = %ld (%ldK)\n", ptoa(uvmexp.free),
	    ptoa(uvmexp.free) / 1024);
d597 1
d603 1
a603 5
	/*
	 * Set up early mappings
	 */
	nvram_map();
	prep_bus_space_init();	
d677 1
a677 1
	u_int32_t args[4];
d712 3
a731 1

d821 2
a822 3
volatile int cpl, ipending, astpending;
int imask[IPL_NUM];
int netisr;
d856 3
d883 1
a883 1
		(fw->exit)();
d889 2
a890 3

	(fw->boot)(str);
	for (;;) ;	/* spinning */
d896 1
d922 37
d1002 1
a1002 1
intr_establish_t *intr_establish_func = ppc_intr_establish;
d1012 44
d1209 3
a1211 7

	if (ppc_malloc_ok == 0) {
		/* need to steal vm space before kernel vm is initialized */
		va = VM_MIN_KERNEL_ADDRESS + ppc_kvm_stolen;
		ppc_kvm_stolen += size;
		if (ppc_kvm_stolen > SEGMENT_LENGTH) {
			panic("ppc_kvm_stolen: out of space");
a1212 2
	} else {
		va = uvm_km_valloc_wait(phys_map, size);
d1214 1
d1219 1
a1219 1
	for (vaddr = va; size > 0; size -= PAGE_SIZE) {
d1222 2
a1223 2
		spa += PAGE_SIZE;
		vaddr += PAGE_SIZE;
d1242 6
a1247 2
		pmap_remove(pmap_kernel(), vaddr,  vaddr+PAGE_SIZE-1);
		vaddr += PAGE_SIZE;
d1380 1
a1380 1
	void *oldh = curproc->p_addr->u_pcb.pcb_onfault;
d1403 1
a1403 1
	if (replace >= NENTRIES) {
@


1.2.2.9
log
@Merge with the trunk
@
text
@d840 1
a840 1
			" configured: driver %s has too many interrupts", name);
@


1.1
log
@Initial import of mvmeppc.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.54 2001/03/01 23:19:34 drahn Exp $	*/
a136 2
#ifdef UVM
/* ??? */
a139 1
#endif
a367 1
#ifdef UVM
a369 3
#else
	vm_set_page_size();
#endif
a580 1
#ifdef UVM
a582 4
#else
	if ((v = (caddr_t)kmem_alloc(kernel_map, round_page(sz))) == 0)
		panic("startup: no room for tables");
#endif
a590 1
#ifdef UVM
a598 7
#else
	buffer_map = kmem_suballoc(kernel_map, &minaddr, &maxaddr, sz, TRUE);
	buffers = (char *)minaddr;
	if (vm_map_find(buffer_map, vm_object_allocate(sz), (vm_offset_t)0,
	   &minaddr, sz, FALSE) != KERN_SUCCESS)
		panic("startup: cannot allocate buffers");
#endif
a612 1
#ifdef UVM
a622 5
#else
		vm_map_pageable(buffer_map, curbuf, curbuf + curbufsize,
		    FALSE);
		vm_map_simplify(buffer_map, curbuf);
#endif
a628 1
#ifdef UVM
a630 4
#else
	exec_map = kmem_suballoc(kernel_map, &minaddr, &maxaddr, 16 * NCARGS,
	    TRUE);
#endif
a634 1
#ifdef UVM
a636 4
#else
	phys_map = kmem_suballoc(kernel_map, &minaddr, &maxaddr, VM_PHYS_SIZE,
	    TRUE);
#endif
a639 1
#ifdef UVM
d642 1
a642 5
#else
	mb_map = kmem_suballoc(kernel_map, (vm_offset_t *)&mbutl, &maxaddr,
	    VM_MBUF_SIZE, FALSE);
#endif
	
a647 1
#ifdef UVM
a648 3
#else
	printf("avail mem = %d\n", ptoa(cnt.v_free_count));
#endif
a715 3
#if !defined(UVM)
	valloc(swbuf, struct buf, nswbuf);
#endif
a1233 1
#ifdef UVM
a1234 3
#else
	kmem_free_wakeup(phys_map, sva, len);
#endif
a1278 1
#ifdef UVM
a1279 3
#else
		vaddr = kmem_alloc_wait(phys_map, len);
#endif
a1318 1
#ifdef UVM
a1319 3
#else
	va = vaddr = kmem_alloc(phys_map, size);
#endif
a1347 1
#ifdef UVM
a1348 3
#else
	kmem_free_wakeup(phys_map, vaddr, size);
#endif
@

