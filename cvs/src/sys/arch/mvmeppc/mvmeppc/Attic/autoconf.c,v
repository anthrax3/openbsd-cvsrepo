head	1.24;
access;
symbols
	OPENBSD_4_9:1.23.0.6
	OPENBSD_4_9_BASE:1.23
	OPENBSD_4_8:1.23.0.4
	OPENBSD_4_8_BASE:1.23
	OPENBSD_4_7:1.23.0.2
	OPENBSD_4_7_BASE:1.23
	OPENBSD_4_6:1.22.0.8
	OPENBSD_4_6_BASE:1.22
	OPENBSD_4_5:1.22.0.4
	OPENBSD_4_5_BASE:1.22
	OPENBSD_4_4:1.22.0.2
	OPENBSD_4_4_BASE:1.22
	OPENBSD_4_3:1.20.0.2
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.19.0.2
	OPENBSD_4_2_BASE:1.19
	OPENBSD_4_1:1.14.0.6
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.14.0.4
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.14.0.2
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.13.0.2
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.12.0.2
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.9.0.4
	OPENBSD_3_6_BASE:1.9
	SMP_SYNC_A:1.9
	SMP_SYNC_B:1.9
	OPENBSD_3_5:1.9.0.2
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.7.0.2
	OPENBSD_3_4_BASE:1.7
	UBC_SYNC_A:1.6
	OPENBSD_3_3:1.5.0.4
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4
	UBC_SYNC_B:1.5
	UBC:1.3.0.2
	UBC_BASE:1.3
	OPENBSD_3_0:1.2.0.2
	OPENBSD_3_0_BASE:1.2
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.24
date	2011.07.07.19.16.43;	author deraadt;	state dead;
branches;
next	1.23;

1.23
date	2009.08.29.11.41.34;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2008.07.21.04.35.54;	author todd;	state Exp;
branches;
next	1.21;

1.21
date	2008.03.30.22.29.09;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2007.11.04.13.43.39;	author martin;	state Exp;
branches;
next	1.19;

1.19
date	2007.06.01.23.14.07;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2007.06.01.19.25.10;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2007.05.29.20.36.48;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2007.05.04.19.30.55;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2007.05.04.03.44.44;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2005.12.27.18.31.10;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2005.04.21.00.15.42;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2004.12.25.23.02.25;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2004.11.17.20.26.38;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2004.10.23.08.21.27;	author mjc;	state Exp;
branches;
next	1.9;

1.9
date	2004.01.29.21.30.02;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2004.01.29.10.57.09;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2003.06.02.23.27.53;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2003.04.06.18.54.19;	author ho;	state Exp;
branches;
next	1.5;

1.5
date	2002.06.08.15.50.00;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2002.03.14.01.26.41;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.12.05.23.58.41;	author tdeval;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2001.09.19.21.32.19;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2001.06.26.21.57.52;	author smurph;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2001.10.31.03.01.21;	author nate;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2002.03.06.02.04.46;	author niklas;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2002.03.28.10.36.03;	author niklas;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2003.03.27.23.52.17;	author niklas;	state Exp;
branches;
next	1.1.2.5;

1.1.2.5
date	2003.05.13.19.41.07;	author ho;	state Exp;
branches;
next	1.1.2.6;

1.1.2.6
date	2003.06.07.11.13.18;	author ho;	state Exp;
branches;
next	1.1.2.7;

1.1.2.7
date	2004.02.19.10.49.09;	author niklas;	state Exp;
branches;
next	;

1.3.2.1
date	2002.06.11.03.37.22;	author art;	state Exp;
branches;
next	1.3.2.2;

1.3.2.2
date	2003.05.19.21.49.43;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.24
log
@remove mvmeppc; it is really rough shape.  ok drahn miod
@
text
@/*	$OpenBSD: autoconf.c,v 1.23 2009/08/29 11:41:34 miod Exp $	*/
/*
 * Copyright (c) 1996, 1997 Per Fogelstrom
 * Copyright (c) 1995 Theo de Raadt
 * Copyright (c) 1988 University of Utah.
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department and Ralph Campbell.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * from: Utah Hdr: autoconf.c 1.31 91/01/21
 *
 *	from: @@(#)autoconf.c	8.1 (Berkeley) 6/10/93
 *      $Id: autoconf.c,v 1.23 2009/08/29 11:41:34 miod Exp $
 */

/*
 * Setup the system to run on the current machine.
 *
 * cpu_configure() is called at boot time.  Available
 * devices are determined (from possibilities mentioned in ioconf.c),
 * and the drivers are initialized.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/disklabel.h>
#include <sys/conf.h>
#include <sys/reboot.h>
#include <sys/device.h>

#include <machine/autoconf.h>
#include <machine/bugio.h>

extern void	dumpconf(void);
void calc_delayconst(void);	/* clock.c */

/*
 * The following several variables are related to
 * the configuration process, and are used in initializing
 * the machine.
 */
int	cold = 1;	/* if 1, still working on cold-start */
int	bootdev;	/* boot device as provided by locore */
struct device *bootdv = NULL;

/*
 *  Configure all devices found that we know about.
 *  This is done at boot time.
 */
void
cpu_configure()
{
	(void)splhigh();	/* To be really sure.. */
	calc_delayconst();

	if (config_rootfound("mainbus", "mainbus") == 0)
		panic("no mainbus found");

	ppc_intr_enable(1);
	spl0();

	/*
	 * We can not select the root device yet, because we use bugtty
	 * as the console for now, and it requires the clock to be ticking
	 * for proper operation (think boot -a ...)
	 */
	cold = 0;
}

void
diskconf(void)
{
	printf("boot device: %s\n",
	    (bootdv != NULL) ? bootdv->dv_xname : "<unknown>");
	setroot(bootdv, 0, RB_USERREQ);
#if 0
	dumpconf();
#endif
}

/*
 * Crash dump handling.
 */
u_long dumpmag = 0x8fca0101;		/* magic number */
int dumpsize = 0;			/* size of dump in pages */
long dumplo = -1;			/* blocks */

/*
 * This is called by configure to set dumplo and dumpsize.
 * Dumps always skip the first CLBYTES of disk space
 * in case there might be a disk label stored there.
 * If there is extra space, put dump at the end to
 * reduce the chance that swapping trashes it.
 */
#if 0
void
dumpconf(void)
{
	int nblks;	/* size of dump area */

	if (dumpdev == NODEV ||
	    (nblks = (bdevsw[major(dumpdev)].d_psize)(dumpdev)) == 0)
		return;
	if (nblks <= ctod(1))
		return;

	dumpsize = atop(IOM_END + ptoa(dumpmem_high));

	/* Always skip the first CLBYTES, in case there is a label there. */
	if (dumplo < ctod(1))
		dumplo = ctod(1);

	/* Put dump at end of partition, and make it fit. */
	if (dumpsize > dtoc(nblks - dumplo))
		dumpsize = dtoc(nblks - dumplo);
	if (dumplo < nblks - ctod(dumpsize))
		dumplo = nblks - ctod(dumpsize);
}
#endif

struct nam2blk nam2blk[] = {
	{ "wd",		0 },
	{ "sd",		2 },
	{ "rd",		17 },
	{ "raid",	19 },
	{ "vnd",	14 },
	{ NULL,		-1 }
};
@


1.23
log
@Remove unused getdevunit(), only sparc and sparc64 have a need for it.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.22 2008/07/21 04:35:54 todd Exp $	*/
d40 1
a40 1
 *      $Id: autoconf.c,v 1.22 2008/07/21 04:35:54 todd Exp $
@


1.22
log
@nam2blk[] needs a "vnd" entry for some things (like softraid)
ok marco@@ no objection miod@@ need this for regress djm@@ no objection krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.21 2008/03/30 22:29:09 deraadt Exp $	*/
d40 1
a40 1
 *      $Id: autoconf.c,v 1.21 2008/03/30 22:29:09 deraadt Exp $
a62 1
struct device *getdevunit(char *, int);
a147 28

/*
 * find a device matching "name" and unit number
 */
struct device *
getdevunit(name, unit)
	char *name;
	int unit;
{
	struct device *dev = TAILQ_FIRST(&alldevs);
	char num[10], fullname[16];
	int lunit;

	/* compute length of name and decimal expansion of unit number */
	snprintf(num, sizeof num, "%d", unit);
	lunit = strlen(num);
	if (strlen(name) + lunit >= sizeof(fullname) - 1)
		panic("config_attach: device name too long");

	strlcpy(fullname, name, sizeof fullname);
	strlcat(fullname, num, sizeof fullname);

	while (strcmp(dev->dv_xname, fullname) != 0) {
		if ((dev = TAILQ_NEXT(dev, dv_list)) == NULL)
			return NULL;
	}
	return dev;
}
@


1.21
log
@nam2blk[] clearly must contain "rd" ... found by krw
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.20 2007/11/04 13:43:39 martin Exp $	*/
d40 1
a40 1
 *      $Id: autoconf.c,v 1.20 2007/11/04 13:43:39 martin Exp $
d183 1
@


1.20
log
@replace even more ctob/btoc with ptoa/atop
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.19 2007/06/01 23:14:07 deraadt Exp $	*/
d40 1
a40 1
 *      $Id: autoconf.c,v 1.19 2007/06/01 23:14:07 deraadt Exp $
d181 1
@


1.19
log
@remove ofw devices which we don't use; that way of mixing devices is crazy
(means i also don not have to fix the daddr_t problems)
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.18 2007/06/01 19:25:10 deraadt Exp $	*/
d40 1
a40 1
 *      $Id: autoconf.c,v 1.18 2007/06/01 19:25:10 deraadt Exp $
d136 1
a136 1
	dumpsize = btoc(IOM_END + ctob(dumpmem_high));
@


1.18
log
@some architectures called setroot() from cpu_configure(), *way* before some
subsystems were enabled.  others used a *md_diskconf -> diskconf() method to
make sure init_main could "do late setroot".  Change all architectures to
have diskconf(), use it directly & late.  tested by todd and myself on most
architectures, ok miod too
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.18 2007/06/01 19:20:46 deraadt Exp $	*/
d40 1
a40 1
 *      $Id: autoconf.c,v 1.18 2007/06/01 19:20:46 deraadt Exp $
a180 1
	{ "ofdisk",	4 },
@


1.17
log
@start of dumpconf() unification, which one day we can pray will be MI
(and part of setroot); ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.16 2007/05/04 19:30:55 deraadt Exp $	*/
d40 1
a40 1
 *      $Id: autoconf.c,v 1.16 2007/05/04 19:30:55 deraadt Exp $
a63 1
void diskconf(void);
a95 2
	md_diskconf = diskconf;

d100 1
a100 1
diskconf()
@


1.16
log
@make findblkmajor() and findblkname() MI; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.15 2007/05/04 03:44:44 deraadt Exp $	*/
d40 1
a40 1
 *      $Id: autoconf.c,v 1.15 2007/05/04 03:44:44 deraadt Exp $
d129 1
a129 1
dumpconf()
a131 1
	int maj;
d133 2
a134 1
	if (dumpdev == NODEV)
a135 6
	maj = major(dumpdev);
	if (maj < 0 || maj >= nblkdev)
		panic("dumpconf: bad dumpdev=0x%x", dumpdev);
	if (bdevsw[maj].d_psize == NULL)
		return;
	nblks = (*bdevsw[maj].d_psize)(dumpdev);
@


1.15
log
@setroot() was a ugly mix of MI and MD code, with different bugs on different
machines.  Instead -- build one solid clean MI version, and thenchange all
the architectures to use it.  ok various people, tested on almost all cases.
(it is a 10094 line diff..)
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.14 2005/12/27 18:31:10 miod Exp $	*/
d40 1
a40 1
 *      $Id: autoconf.c,v 1.14 2005/12/27 18:31:10 miod Exp $
d187 1
a187 4
const struct {
	char	*name;
	int	maj;
} nam2blk[] = {
d192 1
a193 23

int
findblkmajor(struct device *dv)
{
	char *name = dv->dv_xname;
	int i;

	for (i = 0; i < sizeof(nam2blk)/sizeof(nam2blk[0]); i++)
		if (!strncmp(name, nam2blk[i].name, strlen(nam2blk[i].name)))
			return (nam2blk[i].maj);
	return (-1);
}

char *
findblkname(int maj)
{
	int i;

	for (i = 0; i < sizeof(nam2blk)/sizeof(nam2blk[0]); i++)
		if (nam2blk[i].maj == maj)
			return (nam2blk[i].name);
	return (NULL);
}
@


1.14
log
@Remove unused sw_nblks field of struct swdevt. Then, remove swapconf()
which duplicates work done by uvm_swap_init().
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.13 2005/04/21 00:15:42 deraadt Exp $	*/
d40 1
a40 1
 *      $Id: autoconf.c,v 1.13 2005/04/21 00:15:42 deraadt Exp $
a61 2
struct  device *parsedisk(char *, int, int, dev_t *);
void    setroot(void);
a62 3
int findblkmajor(struct device *);
char *findblkname(int);
struct device *getdisk(char *, int, int, dev_t *);
d105 3
a107 1
	setroot();
a158 300
const struct nam2blk {
	char *name;
	int  maj;
} nam2blk[] = {
	{ "wd",		0 },	/* 0 = wd */
	{ "sd",		2 },	/* 2 = sd */
	{ "ofdisk",	4 },	/* 4 = ofdisk */
	{ "raid",	19 },	/* 19 = raid */
};

int
findblkmajor(dv)
	struct device *dv;
{
	char *name = dv->dv_xname;
	int i;

	for (i = 0; i < sizeof(nam2blk)/sizeof(nam2blk[0]); ++i)
		if (strncmp(name, nam2blk[i].name, strlen(nam2blk[i].name)) == 0)
			return (nam2blk[i].maj);
	return (-1);
}

char *
findblkname(maj)
	int maj;
{
	int i;

	for (i = 0; i < sizeof(nam2blk)/sizeof(nam2blk[0]); ++i)
		if (nam2blk[i].maj == maj)
			return (nam2blk[i].name);
	return (NULL);
}

struct device *
getdisk(str, len, defpart, devp)
	char *str;
	int len, defpart;
	dev_t *devp;
{
	struct device *dv;

	if ((dv = parsedisk(str, len, defpart, devp)) == NULL) {
		printf("use one of:");
		TAILQ_FOREACH(dv, &alldevs, dv_list) {
			if (dv->dv_class == DV_DISK)
				printf(" %s[a-p]", dv->dv_xname);
#ifdef NFSCLIENT
			if (dv->dv_class == DV_IFNET)
				printf(" %s", dv->dv_xname); 
#endif
		}
		printf(" halt\n");
	}
	return (dv);
}

struct device *
parsedisk(str, len, defpart, devp)
	char *str;
	int len, defpart;
	dev_t *devp;
{
	struct device *dv;
	char *cp, c;
	int majdev, part;

	if (len == 0)
		return (NULL);

	if (len == 4 && strcmp(str, "halt") == 0)
		boot(RB_HALT);

	cp = str + len - 1;
	c = *cp;
	if (c >= 'a' && (c - 'a') < MAXPARTITIONS) {
		part = c - 'a';
		*cp = '\0';
	} else
		part = defpart;

	TAILQ_FOREACH(dv, &alldevs, dv_list) {
		if (dv->dv_class == DV_DISK &&
		    strcmp(str, dv->dv_xname) == 0) {
			majdev = findblkmajor(dv);
			if (majdev < 0)
				panic("parsedisk");
			*devp = MAKEDISKDEV(majdev, dv->dv_unit, part);
			break;
		}
#ifdef NFSCLIENT
		if (dv->dv_class == DV_IFNET &&
		    strcmp(str, dv->dv_xname) == 0) {
			*devp = NODEV;
			break;
		}
#endif
	}

	*cp = c;
	return (dv);
}

/*
 * Attempt to find the device from which we were booted.
 * If we can do so, and not instructed not to do so,
 * change rootdev to correspond to the load device.
 */
void
setroot()
{
	int  majdev, unit, part, len;
	dev_t temp;
	struct swdevt *swp;
	struct device *dv;
	dev_t nrootdev, nswapdev = NODEV;
	char buf[128];
#if defined(NFSCLIENT)
	extern char *nfsbootdevname;
#endif

	/*
	 * (raid) device auto-configuration could have returned
	 * the root device's id in rootdev.  Check this case.
	 */
	if (rootdev != NODEV) {
		majdev = major(rootdev);
		unit = DISKUNIT(rootdev);
		part = DISKPART(rootdev);

		len = snprintf(buf, sizeof buf, "%s%d", findblkname(majdev),
			unit);
		if (len == -1 || len >= sizeof(buf))
			panic("setroot: device name too long");

		bootdv = getdisk(buf, len, part, &rootdev);
	}

	printf("boot device: %s\n",
	    (bootdv != NULL) ? bootdv->dv_xname : "<unknown>");

	/*
	 * If 'swap generic' and we couldn't determine the boot device,
	 * ask the user.
	 */
	if (mountroot == NULL && bootdv == NULL)
		boothowto |= RB_ASKNAME;

	if (boothowto & RB_ASKNAME) {
		for (;;) {
			printf("root device ");
			if (bootdv != NULL)
				printf("(default %s%c)",
				    bootdv->dv_xname,
				    bootdv->dv_class == DV_DISK ? 'a' : ' ');
			printf(": ");
			len = getsn(buf, sizeof(buf));
			if (len == 0 && bootdv != NULL) {
				strlcpy(buf, bootdv->dv_xname, sizeof buf);
				len = strlen(buf);
			}
			if (len > 0 && buf[len - 1] == '*') {
				buf[--len] = '\0';
				dv = getdisk(buf, len, 1, &nrootdev);
				if (dv != NULL) {
					bootdv = dv;
					nswapdev = nrootdev;
					goto gotswap;
				}
			}
			dv = getdisk(buf, len, 0, &nrootdev);
			if (dv != NULL) {
				bootdv = dv;
				break;
			}
		}

		/*
		 * because swap must be on same device as root, for
		 * network devices this is easy.
		 */
		if (bootdv->dv_class == DV_IFNET) {
			goto gotswap;
		}
		for (;;) {
			printf("swap device ");
			if (bootdv != NULL)
				printf("(default %s%c)",
				    bootdv->dv_xname,
				    bootdv->dv_class == DV_DISK ? 'b' : ' ');
			printf(": ");
			len = getsn(buf, sizeof(buf));
			if (len == 0 && bootdv != NULL) {
				switch (bootdv->dv_class) {
				case DV_IFNET:
					nswapdev = NODEV;
					break;
				case DV_DISK:
					nswapdev = MAKEDISKDEV(major(nrootdev),
					    DISKUNIT(nrootdev), 1);
					break;
				case DV_TAPE:
				case DV_TTY:
				case DV_DULL:
				case DV_CPU:
					break;
				}
				break;
			}
			dv = getdisk(buf, len, 1, &nswapdev);
			if (dv) {
				if (dv->dv_class == DV_IFNET)
					nswapdev = NODEV;
				break;
			}
		}

gotswap:
		rootdev = nrootdev;
		dumpdev = nswapdev;
		swdevt[0].sw_dev = nswapdev;
		swdevt[1].sw_dev = NODEV;
	} else if (mountroot == NULL) {
		/*
		 * `swap generic': Use the device the ROM told us to use.
		 */
		if (bootdv == NULL)
			panic("boot device not known");

		majdev = findblkmajor(bootdv);
		if (majdev >= 0) {
			/*
			 * Root and Swap are on disk.
			 * Boot is always from partition 0.
			 */
			rootdev = MAKEDISKDEV(majdev, bootdv->dv_unit, 0);
			nswapdev = MAKEDISKDEV(majdev, bootdv->dv_unit, 1);
			dumpdev = nswapdev;
		} else {
			/*
			 *  Root and Swap are on net.
			 */	
			nswapdev = dumpdev = NODEV;
		}
		swdevt[0].sw_dev = nswapdev;
		swdevt[1].sw_dev = NODEV;
	} else {
		/*
		 * `root DEV swap DEV': honour rootdev/swdevt.
		 * rootdev/swdevt/mountroot already properly set.
		 */
		return;
	}

	switch (bootdv->dv_class) {
#if defined(NFSCLIENT)
	case DV_IFNET:
		mountroot = nfs_mountroot;
		nfsbootdevname = bootdv->dv_xname;
		return;
#endif
#if defined(FFS)
	case DV_DISK:
		mountroot = dk_mountroot;
		majdev = major(rootdev);
		unit = DISKUNIT(rootdev);
		printf("root on %s%c\n", bootdv->dv_xname,
		    DISKPART(rootdev) + 'a');
		break;
#endif
	default:
		printf("can't figure root, hope your kernel is right\n");
		return;
	}

	/*
	 * Make the swap partition on the root drive the primary swap.
	 */
	temp = NODEV;
	for (swp = swdevt; swp->sw_dev != NODEV; swp++) {
		if (majdev == major(swp->sw_dev) &&
		    unit == DISKUNIT(swp->sw_dev)) {
			temp = swdevt[0].sw_dev;
			swdevt[0].sw_dev = swp->sw_dev;
			swp->sw_dev = temp;
			break;
		}
	}
	if (swp->sw_dev == NODEV)
		return;

	/*
	 * If dumpdev was the same as the old primary swap device, move
	 * it to the new primary swap device.
	 */
	if (temp == dumpdev)
		dumpdev = swdevt[0].sw_dev;
}

d185 33
@


1.13
log
@correct idiom for snprintf failure handling; ok beck
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.12 2004/12/25 23:02:25 miod Exp $	*/
d40 1
a40 1
 *      $Id: autoconf.c,v 1.12 2004/12/25 23:02:25 miod Exp $
a63 1
void	swapconf(void);
a110 22
	swapconf();
}

/*
 * Configure swap space and related parameters.
 */
void
swapconf()
{
	struct swdevt *swp;
	int nblks;

	for (swp = swdevt; swp->sw_dev != NODEV; swp++) {
		if (bdevsw[major(swp->sw_dev)].d_psize) {
			nblks =
			  (*bdevsw[major(swp->sw_dev)].d_psize)(swp->sw_dev);
			if (nblks != -1 &&
			    (swp->sw_nblks == 0 || swp->sw_nblks > nblks))
				swp->sw_nblks = nblks;
			swp->sw_nblks = ctod(dtoc(swp->sw_nblks));
		}
	}
@


1.12
log
@Use list and queue macros where applicable to make the code easier to read;
no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.11 2004/11/17 20:26:38 miod Exp $	*/
d40 1
a40 1
 *      $Id: autoconf.c,v 1.11 2004/11/17 20:26:38 miod Exp $
d318 1
a318 1
		if (len >= sizeof(buf))
@


1.11
log
@Enable interrupts after autoconf.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.10 2004/10/23 08:21:27 mjc Exp $	*/
d40 1
a40 1
 *      $Id: autoconf.c,v 1.10 2004/10/23 08:21:27 mjc Exp $
d230 1
a230 2
		for (dv = alldevs.tqh_first; dv != NULL;
		    dv = dv->dv_list.tqe_next) {
d267 1
a267 1
	for (dv = alldevs.tqh_first; dv != NULL; dv = dv->dv_list.tqe_next) {
d493 1
a493 1
	struct device *dev = alldevs.tqh_first;
d507 1
a507 1
		if ((dev = dev->dv_list.tqe_next) == NULL)
@


1.10
log
@configure() -> cpu_configure()
ok grange@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.9 2004/01/29 21:30:02 miod Exp $	*/
d40 1
a40 1
 *      $Id: autoconf.c,v 1.9 2004/01/29 21:30:02 miod Exp $
d68 2
a69 2
struct device * getdisk(char *, int, int, dev_t *);
struct device * getdevunit(char *, int);
d94 3
a96 1
	(void)spl0();
d99 3
a101 2
	 * We can not know which is our root disk, defer
	 * until we can checksum blocks to figure it out.
d104 1
d107 1
a107 5
/*
 * Now that we are fully operational, we can checksum the
 * disks, and using some heuristics, hopefully are able to
 * always determine the correct root disk.
 */
a110 13
	/*
	 * Configure root, swap, and dump area.  This is
	 * currently done by running the same checksum
	 * algorithm over all known disks, as was done in
	 * /boot.  Then we basically fixup the *dev vars
	 * from the info we gleaned from this.
	dkcsumattach();
	 * - XXX
	 */

#if 0
	rootconf();
#endif
a112 3
#if 0
	dumpconf();
#endif
@


1.9
log
@Have the bootloader pass RB_ flags, as well as the boot device, to the kernel,
and have the kernel process them correctly.

Right now code to match the BUG's idea of the boot device with the kernel's is
missing.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.8 2004/01/29 10:57:09 miod Exp $	*/
d40 1
a40 1
 *      $Id: autoconf.c,v 1.8 2004/01/29 10:57:09 miod Exp $
d46 1
a46 1
 * Configure() is called at boot time.  Available
@


1.8
log
@Allow "halt" as a root device, to return to the BUG, as done on some other
platforms.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.7 2003/06/02 23:27:53 millert Exp $	*/
d40 1
a40 1
 *      $Id: autoconf.c,v 1.7 2003/06/02 23:27:53 millert Exp $
d68 1
a68 1
static struct device * getdisk(char *, int, int, dev_t *);
a69 3
static struct devmap * findtype(char **);
void makebootdev(char *cp);
int getpno(char **);
d79 1
a79 1
char	bootdev[16];	/* to hold boot dev name */
d137 2
a138 2
	register struct swdevt *swp;
	register int nblks;
d201 1
a201 1
static	struct nam2blk {
d236 1
a236 1
static struct device *
d242 1
a242 1
	register struct device *dv;
d266 2
a267 2
	register struct device *dv;
	register char *cp, c;
d314 1
a314 1
	int  majdev, mindev, unit, part, len;
a319 1

a323 5
	printf("bootpath: '%s'\n", bootpath);
	makebootdev(bootpath);
	if(boothowto & RB_DFLTROOT)
		return;		/* Boot compiled in */

d341 9
a349 12
	/* Lookup boot device from boot if not set by configuration */
	if(bootdv == NULL) {
		bootdv = parsedisk(bootdev, strlen(bootdev), 0, &temp);
	}
	if(bootdv == NULL) {
		printf("boot device: lookup '%s' failed.\n", bootdev);
		boothowto |= RB_ASKNAME; /* Don't Panic :-) */
		/* boothowto |= RB_SINGLE; */
	}
	else {
		printf("boot device: %s.\n", bootdv->dv_xname);
	}
d355 3
a357 4
				 printf("(default %s%c)",
					bootdv->dv_xname,
					bootdv->dv_class == DV_DISK
						? 'a' : ' ');
d379 1
d391 2
a392 2
					bootdv->dv_xname,
					bootdv->dv_class == DV_DISK?'b':' ');
d425 1
a425 2
	}
	else if(mountroot == NULL) {
a432 1

d441 1
a441 2
		}
		else {
a448 1

a449 1

d464 1
a467 1
		mindev = minor(rootdev);
d469 2
a470 2
		part = DISKPART(rootdev);
		printf("root on %s%c\n", bootdv->dv_xname, part + 'a');
d472 1
d479 1
a479 1
	 * XXX: What is this doing?
a527 97
}

struct devmap {
	char *att;
	char *dev;
	int   type;
};
#define	T_IFACE	0x10

#define	T_BUS	0x00
#define	T_SCSI	0x11
#define	T_IDE	0x12
#define	T_DISK	0x21

static struct devmap *
findtype(s)
	char **s;
{
	static struct devmap devmap[] = {
		{ "/pci@@",	NULL, T_BUS },
		{ "/pci",	NULL, T_BUS },
		{ "/mac-io@@",	NULL, T_BUS },
		{ "/mac-io",	NULL, T_BUS },
		{ "/@@",		NULL, T_BUS },
		{ "/scsi@@",	"sd", T_SCSI },
		{ "/ide",	"wd", T_IDE },
		{ "/ata",	"wd", T_IDE },
		{ "/disk@@",	"sd", T_DISK },
		{ "/disk",	"wd", T_DISK },
		{ NULL, NULL }
	};
	struct devmap *dp = &devmap[0];

	while (dp->att) {
		if (strncmp (*s, dp->att, strlen(dp->att)) == 0) {
			*s += strlen(dp->att);
			break;
		}
		dp++;
	}
	if (dp->att == NULL) {
		printf("string [%s]not found\n", *s);
	}
	return(dp);
}

/*
 * Look at the string 'bp' and decode the boot device.
 * Boot names look like: '/pci/scsi@@c/disk@@0,0/bsd'
 *                       '/pci/mac-io/ide@@20000/disk@@0,0/bsd
 *                       '/pci/mac-io/ide/disk/bsd
 */
void
makebootdev(bp)
	char *bp;
{
	int	unit;
	char   *dev, *cp;
	struct devmap *dp;

	cp = bp;
	do {
		while(*cp && *cp != '/') {
			cp++;
		}
		dp = findtype(&cp);
		if (!dp->att) {
			printf("Warning: boot device unrecognized: %s\n", bp);
			return;
		}
	} while((dp->type & T_IFACE) == 0);

	dev = dp->dev;
	while(*cp && *cp != '/')
		cp++;
	dp = findtype(&cp);
	if (!dp->att || dp->type != T_DISK) {
		printf("Warning: boot device unrecognized: %s\n", bp);
		return;
	}
	unit = getpno(&cp);
	snprintf(bootdev, sizeof bootdev, "%s%d%c", dev, unit, 'a');
}

int
getpno(cp)
	char **cp;
{
	int val = 0;
	char *cx = *cp;

	while(*cx && *cx >= '0' && *cx <= '9') {
		val = val * 10 + *cx - '0';
		cx++;
	}
	*cp = cx;
	return val;
@


1.7
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.6 2003/04/06 18:54:19 ho Exp $	*/
d40 1
a40 1
 *      $Id: autoconf.c,v 1.6 2003/04/06 18:54:19 ho Exp $
d95 1
a95 6
	/*
	if(system_type == OFWMACH) {
		ofrootfound();
	}
	*/
	if(config_rootfound("mainbus", "mainbus") == 0)
d258 1
a258 1
		printf("\n");
d275 4
@


1.6
log
@strcat/strcpy/sprintf cleanup. krw@@, anil@@ ok. art@@ tested sparc64.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.5 2002/06/08 15:50:00 miod Exp $	*/
d21 1
a21 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d40 1
a40 1
 *      $Id: autoconf.c,v 1.5 2002/06/08 15:50:00 miod Exp $
@


1.5
log
@Strict prototypes, and some KNF touches while there.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.4 2002/03/14 01:26:41 millert Exp $	*/
d44 1
a44 1
 *      $Id: autoconf.c,v 1.4 2002/03/14 01:26:41 millert Exp $
d347 2
a348 1
		len = sprintf(buf, "%s%d", findblkname(majdev), unit);
d379 1
a379 1
				strcpy(buf, bootdv->dv_xname);
d536 1
a536 1
	sprintf(num, "%d", unit);
d541 2
a542 2
	strcpy(fullname, name);
	strcat(fullname, num);
d630 1
a630 1
	sprintf(bootdev, "%s%d%c", dev, unit, 'a');
@


1.4
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.3 2001/12/05 23:58:41 tdeval Exp $	*/
d44 1
a44 1
 *      $Id: autoconf.c,v 1.3 2001/12/05 23:58:41 tdeval Exp $
d64 1
d77 2
a78 1
void diskconf();
@


1.3
log
@Enable rootdev auto-configuration by device drivers during boot.
Add support for "raid" devices (prepare future raidframe changes).

OK deraadt@@, Reviewed by drahn@@, jason@@, mickey@@ and miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.2 2001/09/19 21:32:19 miod Exp $	*/
d44 1
a44 1
 *      $Id: autoconf.c,v 1.2 2001/09/19 21:32:19 miod Exp $
d65 11
a75 11
struct  device *parsedisk __P((char *, int, int, dev_t *));
void    setroot __P((void));
void	swapconf __P((void));
extern void	dumpconf __P((void));
int findblkmajor __P((struct device *));
char *findblkname __P((int));
static struct device * getdisk __P((char *, int, int, dev_t *));
struct device * getdevunit __P((char *, int));
static struct devmap * findtype __P((char **));
void makebootdev __P((char *cp));
int getpno __P((char **));
@


1.3.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.3 2001/12/05 23:58:41 tdeval Exp $	*/
d44 1
a44 1
 *      $Id: autoconf.c,v 1.3 2001/12/05 23:58:41 tdeval Exp $
a63 1
#include <machine/bugio.h>
d65 12
a76 13
struct  device *parsedisk(char *, int, int, dev_t *);
void    setroot(void);
void	swapconf(void);
extern void	dumpconf(void);
int findblkmajor(struct device *);
char *findblkname(int);
static struct device * getdisk(char *, int, int, dev_t *);
struct device * getdevunit(char *, int);
static struct devmap * findtype(char **);
void makebootdev(char *cp);
int getpno(char **);
void diskconf(void);
void calc_delayconst(void);	/* clock.c */
@


1.3.2.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d44 1
a44 1
 *      $Id$
d347 1
a347 2
		len = snprintf(buf, sizeof buf, "%s%d", findblkname(majdev),
			unit);
d378 1
a378 1
				strlcpy(buf, bootdv->dv_xname, sizeof buf);
d535 1
a535 1
	snprintf(num, sizeof num, "%d", unit);
d540 2
a541 2
	strlcpy(fullname, name, sizeof fullname);
	strlcat(fullname, num, sizeof fullname);
d629 1
a629 1
	snprintf(bootdev, sizeof bootdev, "%s%d%c", dev, unit, 'a');
@


1.2
log
@Now is a good time to commit this cosmetic maxpartition-related change...
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.1 2001/06/26 21:57:52 smurph Exp $	*/
d44 1
a44 1
 *      $Id: autoconf.c,v 1.1 2001/06/26 21:57:52 smurph Exp $
d69 2
a70 1
static int findblkmajor __P((struct device *));
d218 1
d221 1
a221 1
static int
d226 1
a226 1
	register int i;
d229 1
a229 1
		if (strncmp(name, nam2blk[i].name, strlen(nam2blk[0].name)) == 0)
d231 13
a243 1
	 return (-1);
d335 16
@


1.1
log
@Initial import of mvmeppc.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.10 2000/04/04 02:11:47 rahnds Exp $	*/
d44 1
a44 1
 *      $Id: autoconf.c,v 1.10 2000/04/04 02:11:47 rahnds Exp $
d245 1
a245 1
				printf(" %s[a-h]", dv->dv_xname);
@


1.1.2.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.1 2001/06/26 21:57:52 smurph Exp $	*/
d44 1
a44 1
 *      $Id: autoconf.c,v 1.1 2001/06/26 21:57:52 smurph Exp $
d245 1
a245 1
				printf(" %s[a-p]", dv->dv_xname);
@


1.1.2.2
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d44 1
a44 1
 *      $Id$
d69 1
a69 2
int findblkmajor __P((struct device *));
char *findblkname __P((int));
a216 1
	{ "raid",	19 },	/* 19 = raid */
d219 1
a219 1
int
d224 1
a224 1
	int i;
d227 1
a227 1
		if (strncmp(name, nam2blk[i].name, strlen(nam2blk[i].name)) == 0)
d229 1
a229 13
	return (-1);
}

char *
findblkname(maj)
	int maj;
{
	int i;

	for (i = 0; i < sizeof(nam2blk)/sizeof(nam2blk[0]); ++i)
		if (nam2blk[i].maj == maj)
			return (nam2blk[i].name);
	return (NULL);
a320 16

	/*
	 * (raid) device auto-configuration could have returned
	 * the root device's id in rootdev.  Check this case.
	 */
	if (rootdev != NODEV) {
		majdev = major(rootdev);
		unit = DISKUNIT(rootdev);
		part = DISKPART(rootdev);

		len = sprintf(buf, "%s%d", findblkname(majdev), unit);
		if (len >= sizeof(buf))
			panic("setroot: device name too long");

		bootdv = getdisk(buf, len, part, &rootdev);
	}
@


1.1.2.3
log
@Merge in -current from about a week ago
@
text
@d65 11
a75 11
struct  device *parsedisk(char *, int, int, dev_t *);
void    setroot(void);
void	swapconf(void);
extern void	dumpconf(void);
int findblkmajor(struct device *);
char *findblkname(int);
static struct device * getdisk(char *, int, int, dev_t *);
struct device * getdevunit(char *, int);
static struct devmap * findtype(char **);
void makebootdev(char *cp);
int getpno(char **);
@


1.1.2.4
log
@Sync the SMP branch with 3.3
@
text
@a63 1
#include <machine/bugio.h>
d76 1
a76 2
void diskconf(void);
void calc_delayconst(void);	/* clock.c */
@


1.1.2.5
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.1.2.4 2003/03/27 23:52:17 niklas Exp $	*/
d44 1
a44 1
 *      $Id: autoconf.c,v 1.1.2.4 2003/03/27 23:52:17 niklas Exp $
d347 1
a347 2
		len = snprintf(buf, sizeof buf, "%s%d", findblkname(majdev),
			unit);
d378 1
a378 1
				strlcpy(buf, bootdv->dv_xname, sizeof buf);
d535 1
a535 1
	snprintf(num, sizeof num, "%d", unit);
d540 2
a541 2
	strlcpy(fullname, name, sizeof fullname);
	strlcat(fullname, num, sizeof fullname);
d629 1
a629 1
	snprintf(bootdev, sizeof bootdev, "%s%d%c", dev, unit, 'a');
@


1.1.2.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.1.2.5 2003/05/13 19:41:07 ho Exp $	*/
d21 5
a25 1
 * 3. Neither the name of the University nor the names of its contributors
d44 1
a44 1
 *      $Id: autoconf.c,v 1.1.2.5 2003/05/13 19:41:07 ho Exp $
@


1.1.2.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d40 1
a40 1
 *      $Id$
d68 1
a68 1
struct device * getdisk(char *, int, int, dev_t *);
d70 3
d82 1
a82 1
int	bootdev;	/* boot device as provided by locore */
d95 6
a100 1
	if (config_rootfound("mainbus", "mainbus") == 0)
d145 2
a146 2
	struct swdevt *swp;
	int nblks;
d209 1
a209 1
const struct nam2blk {
d244 1
a244 1
struct device *
d250 1
a250 1
	struct device *dv;
d263 1
a263 1
		printf(" halt\n");
d274 2
a275 2
	struct device *dv;
	char *cp, c;
a279 4

	if (len == 4 && strcmp(str, "halt") == 0)
		boot(RB_HALT);

d318 1
a318 1
	int  majdev, unit, part, len;
d324 1
d329 5
d351 12
a362 9
	printf("boot device: %s\n",
	    (bootdv != NULL) ? bootdv->dv_xname : "<unknown>");

	/*
	 * If 'swap generic' and we couldn't determine the boot device,
	 * ask the user.
	 */
	if (mountroot == NULL && bootdv == NULL)
		boothowto |= RB_ASKNAME;
d368 4
a371 3
				printf("(default %s%c)",
				    bootdv->dv_xname,
				    bootdv->dv_class == DV_DISK ? 'a' : ' ');
a392 1

d404 2
a405 2
				    bootdv->dv_xname,
				    bootdv->dv_class == DV_DISK ? 'b' : ' ');
d438 2
a439 1
	} else if (mountroot == NULL) {
d447 1
d456 2
a457 1
		} else {
d465 1
d467 1
a481 1
#if defined(FFS)
d485 1
d487 2
a488 2
		printf("root on %s%c\n", bootdv->dv_xname,
		    DISKPART(rootdev) + 'a');
a489 1
#endif
d496 1
a496 1
	 * Make the swap partition on the root drive the primary swap.
d545 97
@


