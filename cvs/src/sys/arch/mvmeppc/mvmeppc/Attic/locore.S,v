head	1.14;
access;
symbols
	OPENBSD_4_9:1.13.0.12
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.10
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.6
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.13.0.8
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.4
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.2
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.12.0.10
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.12.0.8
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.6
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.4
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.12.0.2
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.11.0.2
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.10.0.2
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.7.0.2
	OPENBSD_3_6_BASE:1.7
	SMP_SYNC_A:1.6
	SMP_SYNC_B:1.6
	OPENBSD_3_5:1.6.0.2
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.3.0.6
	OPENBSD_3_4_BASE:1.3
	UBC_SYNC_A:1.3
	OPENBSD_3_3:1.3.0.4
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.2
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.1.0.8
	OPENBSD_3_1_BASE:1.1
	UBC_SYNC_B:1.3
	UBC:1.1.0.6
	UBC_BASE:1.1
	OPENBSD_3_0:1.1.0.4
	OPENBSD_3_0_BASE:1.1
	SMP:1.1.0.2;
locks; strict;
comment	@# @;


1.14
date	2011.07.07.19.16.43;	author deraadt;	state dead;
branches;
next	1.13;

1.13
date	2008.07.28.19.08.46;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2005.11.24.12.08.16;	author pedro;	state Exp;
branches;
next	1.11;

1.11
date	2005.08.02.21.27.58;	author drahn;	state Exp;
branches;
next	1.10;

1.10
date	2004.12.24.22.50.30;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2004.11.17.20.10.26;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2004.11.16.17.08.09;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2004.06.24.22.35.56;	author drahn;	state Exp;
branches;
next	1.6;

1.6
date	2004.01.29.21.30.02;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2004.01.28.23.57.48;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2004.01.22.20.45.20;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2002.07.24.02.29.57;	author drahn;	state Exp;
branches;
next	1.2;

1.2
date	2002.06.07.01.01.40;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2001.06.26.21.57.54;	author smurph;	state Exp;
branches
	1.1.2.1
	1.1.6.1;
next	;

1.1.2.1
date	2003.03.27.23.52.17;	author niklas;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2004.02.19.10.49.10;	author niklas;	state Exp;
branches;
next	;

1.1.6.1
date	2002.06.11.03.37.22;	author art;	state Exp;
branches;
next	1.1.6.2;

1.1.6.2
date	2002.10.29.00.28.08;	author art;	state Exp;
branches;
next	;


desc
@@


1.14
log
@remove mvmeppc; it is really rough shape.  ok drahn miod
@
text
@/*	$OpenBSD: locore.S,v 1.13 2008/07/28 19:08:46 miod Exp $	*/
/*	$NetBSD: locore.S,v 1.2 1996/10/16 19:33:09 ws Exp $	*/

/*
 * Copyright (C) 1995, 1996 Wolfgang Solfrank.
 * Copyright (C) 1995, 1996 TooLs GmbH.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by TooLs GmbH.
 * 4. The name of TooLs GmbH may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY TOOLS GMBH ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL TOOLS GMBH BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include "assym.h"

#include <sys/syscall.h>

#include <machine/asm.h>
#include <machine/param.h>
#include <machine/pmap.h>
#include <machine/psl.h>
#include <machine/trap.h>

/*
 * Globals
 */
	.globl	_C_LABEL(esym),_C_LABEL(proc0paddr)
	.type	_C_LABEL(esym),@@object
	.type	_C_LABEL(proc0paddr),@@object
	.data
_C_LABEL(esym):		.long	0	/* end of symbol table */
_C_LABEL(proc0paddr):	.long	0	/* proc0 p_addr */
idle_u:			.long	0	/* fake uarea during idle after exit */

/*
 * Startup entry
 */
_ENTRY(_C_LABEL(kernel_text))
_ENTRY(_ASM_LABEL(start))
/*
 * Arguments to start for mvmeppc
 * r1 - stack provided by firmware/bootloader
 * r3 - boot flags
 * r4 - boot device
 * r5 - firmware pointer (NULL for PPC1bug)
 * r6 - arg list (NULL)
 * r7 - length (0)
 * r8 - end of symbol table
 */
	.globl	start
	.type start,@@function
start:
	li	%r0,0
	mtmsr	%r0			/* Disable FPU/MMU/exceptions */
	isync

	/* save boot device and flags */
	lis	%r9, _C_LABEL(boothowto)@@ha
	stw	%r3, _C_LABEL(boothowto)@@l(%r9)
	lis	%r9, _C_LABEL(bootdev)@@ha
	stw	%r4, _C_LABEL(bootdev)@@l(%r9)

/* compute end of kernel memory */
#if defined(DDB)
	lis	%r9,_C_LABEL(esym)@@ha
	stw	%r8,_C_LABEL(esym)@@l(%r9)	/* save for symbol handling */
#else
	lis	%r8,_end@@ha
	addi	%r8,%r8,_end@@l
#endif
	li	%r9,PGOFSET
	add	%r8,%r8,%r9
	andc	%r8,%r8,%r9
	lis	%r9,idle_u@@ha
	stw	%r8,idle_u@@l(%r9)
	addi	%r8,%r8,USPACE		/* space for idle_u */
	lis	%r9,_C_LABEL(proc0paddr)@@ha
	stw	%r8,_C_LABEL(proc0paddr)@@l(%r9)
	addi	%r1,%r8,USPACE-FRAMELEN	/* stackpointer for proc0 */
	mr	%r4,%r1			/* end of mem reserved for kernel */
	li	%r0,0
	stwu	%r0,-16(%r1)		/* end of stack chain */

	lis	%r3,start@@ha
	addi	%r3,%r3,start@@l
	mr	%r5,%r6			/* args string */
	bl	_C_LABEL(initppc)
	bl	_C_LABEL(main)
	b	_C_LABEL(PPC1_exit)

/*
 * No processes are runnable, so loop waiting for one.
 * Separate label here for accounting purposes.
 */
_C_LABEL(idle):
	mfmsr	%r3
	/* disable interrupts while manipulating runque */
	andi.	%r3,%r3,~PSL_EE@@l
	mtmsr	%r3

	lis	%r8,_C_LABEL(whichqs)@@ha
	lwz	%r9,_C_LABEL(whichqs)@@l(%r8)

	or.	%r9,%r9,%r9
	bne-	_C_LABEL(sw1)			/* at least one queue non-empty */

	ori	%r3,%r3,PSL_EE		/* reenable ints again */
	mtmsr	%r3
	isync
	sync
	/* low power mode */
	mfmsr	%r3
	oris	%r3, %r3, PSL_POW@@h
	mtmsr	%r3
	isync

/* May do some power saving here? */

	b	_C_LABEL(idle)

/*
 * switchexit gets called from cpu_exit to free the user structure
 * and kernel stack of the current process.
 */
_ENTRY(_C_LABEL(switchexit))
/* First switch to the idle pcb/kernel stack */
	lis	%r6,idle_u@@ha
	lwz	%r6,idle_u@@l(%r6)
	lis	%r7,_C_LABEL(curpcb)@@ha
	stw	%r6,_C_LABEL(curpcb)@@l(%r7)
	addi	%r1,%r6,USPACE-16	/* 16 bytes are reserved at stack top */
	/*
	 * Schedule the vmspace and stack to be freed (the proc arg is
	 * already in r3).
	 */
	bl	_C_LABEL(exit2)

	/* Fall through to cpu_switch to actually select another proc */
	li	%r3,0			/* indicate exited process */

/* Fall through to cpu_switch to actually select another proc */

/*
 * void cpu_switch(struct proc *p)
 * Find a runnable process and switch to it.
 */
_ENTRY(_C_LABEL(cpu_switch))
	mflr	%r0			/* save lr */
	stw	%r0,4(%r1)
	stwu	%r1,-16(%r1)
	stw	%r31,12(%r1)
	stw	%r30,8(%r1)

	mr	%r30,%r3
	lis	%r3,_C_LABEL(curproc)@@ha
	li	%r31,0
	/* Zero to not accumulate cpu time */
	stw	%r31,_C_LABEL(curproc)@@l(%r3)
	lis	%r3,_C_LABEL(curpcb)@@ha
	lwz	%r31,_C_LABEL(curpcb)@@l(%r3)

	li	%r3,0
	bl	_C_LABEL(lcsplx)
	stw	%r3,PCB_SPL(%r31)	/* save spl */

/* Find a new process */
	mfmsr	%r3
	andi.	%r3,%r3,~PSL_EE@@l	/* disable interrupts while
					   manipulating runque */
	mtmsr	%r3
	isync

	lis	%r8,_C_LABEL(whichqs)@@ha
	lwz	%r9,_C_LABEL(whichqs)@@l(%r8)

	or.	%r9,%r9,%r9
	beq-	_C_LABEL(idle)		/* all queues empty */
_C_LABEL(sw1):
	cntlzw	%r10,%r9
	lis	%r4,_C_LABEL(qs)@@ha
	addi	%r4,%r4,_C_LABEL(qs)@@l
	slwi	%r3,%r10,3
	add	%r3,%r3,%r4		/* select queue */

	lwz	%r31,P_FORW(%r3)	/* unlink first proc from queue */
	lwz	%r4,P_FORW(%r31)
	stw	%r4,P_FORW(%r3)
	stw	%r3,P_BACK(%r4)

	cmpl	0,%r3,%r4			/* queue empty? */
	bne	1f

	lis	%r3,0x80000000@@ha
	srw	%r3,%r3,%r10
	andc	%r9,%r9,%r3
	stw	%r9,_C_LABEL(whichqs)@@l(%r8)	/* mark it empty */

1:
	stw	%r3,P_BACK(%r31)		/* probably superfluous */

	lis	%r4,_C_LABEL(curproc)@@ha
	stw	%r31,_C_LABEL(curproc)@@l(%r4)	/* record new process */

	li	%r3,SONPROC
	stb	%r3,P_STAT(%r31)

	mfmsr	%r3
	ori	%r3,%r3,PSL_EE		/* Now we can interrupt again */
	mtmsr	%r3

	cmpl	0,%r31,%r30		/* is it the same process? */
	beq	switch_return

	or.	%r30,%r30,%r30		/* old process was exiting? */
	beq	switch_exited

	mfsr	%r10,PPC_USER_SR	/* save PPC_USER_SR for copyin/copyout*/
	mfcr	%r11			/* save cr */
	mr	%r12,%r2		/* save r2 */
	stwu	%r1,-SFRAMELEN(%r1)	/* still running on old stack */
	stmw	%r10,8(%r1)
	lwz	%r3,P_ADDR(%r30)
	stw	%r1,PCB_SP(%r3)		/* save SP */

switch_exited:
	/* disable interrupts while actually switching */
	mfmsr	%r3
	andi.	%r3,%r3,~PSL_EE@@l
	mtmsr	%r3

	lwz	%r4,P_ADDR(%r31)
	lis	%r5,_C_LABEL(curpcb)@@ha
	stw	%r4,_C_LABEL(curpcb)@@l(%r5)	/* indicate new pcb */

	lwz	%r5,PCB_PMR(%r4)

	/* save real pmap pointer for spill fill */
	lis	%r6,_C_LABEL(curpm)@@ha
	stwu	%r5,_C_LABEL(curpm)@@l(%r6)
	stwcx.	%r5,%r0,%r6		/* clear possible reservation */

	addic.	%r5,%r5,64
	li	%r6,0
	mfsr	%r8,PPC_KERNEL_SR	/* save kernel SR */
1:
	addis	%r6,%r6,-0x10000000@@ha	/* set new procs segment registers */
	or.	%r6,%r6,%r6		/* This is done from the real address pmap */
	lwzu	%r7,-4(%r5)		/* so we don't have to worry */
	mtsrin	%r7,%r6			/* about accessibility */
	bne	1b
	mtsr	PPC_KERNEL_SR,%r8	/* restore kernel SR */
	isync

	lwz	%r1,PCB_SP(%r4)		/* get new procs SP */

	ori	%r3,%r3,PSL_EE		/* interrupts are okay again */
	mtmsr	%r3

	lmw	%r10,8(%r1)		/* get other regs */
	lwz	%r1,0(%r1)		/* get saved SP */
	mr	%r2,%r12		/* get saved r2 */
	mtcr	%r11			/* get saved cr */
	isync
	mtsr	PPC_USER_SR,%r10	/* get saved PPC_USER_SR */
	isync

switch_return:
	mr	%r30,%r7		/* save proc pointer */
	lwz	%r3,PCB_SPL(%r4)
	bl	_C_LABEL(lcsplx)

	mr	%r3,%r30		/* curproc for special fork returns */

	lwz	%r31,12(%r1)
	lwz	%r30,8(%r1)
	addi	%r1,%r1,16
	lwz	%r0,4(%r1)
	mtlr	%r0
	blr


/*
 * Data used during primary/secondary traps/interrupts
 */
#define	tempsave	0x2e0		/* primary save area for trap handling */
#define	disisave	0x3e0		/* primary save area for dsi/isi traps */
#define	INTSTK	(8*1024)		/* 8K interrupt stack */
	.data
intstk:	.space	INTSTK			/* interrupt stack */
	.global _C_LABEL(intr_depth)
	.type  _C_LABEL(intr_depth),@@object
_C_LABEL(intr_depth):
	.long	-1			/* in-use marker */
#define	SPILLSTK 1024			/* 1K spill stack */
.lcomm	spillstk,SPILLSTK,8

/*
 * This code gets copied to all the trap vectors
 * except ISI/DSI, ALI, and the interrupts
 */
	.text
	.globl	_C_LABEL(trapcode),_C_LABEL(trapsize)
	.type	_C_LABEL(trapcode),@@function
	.type	_C_LABEL(trapsize),@@object
_C_LABEL(trapcode):
	mtsprg	1,%r1			/* save SP */
	stmw	%r28,tempsave(%r0)	/* free r28-r31 */
	mflr	%r28			/* save LR */
	mfcr	%r29			/* save CR */

	/* Test whether we already had PR set */
	mfsrr1	%r31
	mtcr	%r31
	bc	4,17,1f			/* branch if PSL_PR is clear */
	lis	%r1,_C_LABEL(curpcb)@@ha
	lwz	%r1,_C_LABEL(curpcb)@@l(%r1)
	addi	%r1,%r1,USPACE		/* stack is top of user struct */
1:
	bla	s_trap
_C_LABEL(trapsize) =	.-_C_LABEL(trapcode)

/*
 * For ALI: has to save DSISR and DAR
 */
	.globl	_C_LABEL(alitrap),_C_LABEL(alisize)
_C_LABEL(alitrap):
	mtsprg	1,%r1			/* save SP */
	stmw	%r28,tempsave(0)	/* free r28-r31 */
	mfdar	%r30
	mfdsisr	%r31
	stmw	%r30,tempsave+16(0)
	mflr	%r28			/* save LR */
	mfcr	%r29			/* save CR */

	/* Test whether we already had PR set */
	mfsrr1	%r31
	mtcr	%r31
	bc	4,17,1f			/* branch if PSL_PR is clear */
	lis	%r1,_C_LABEL(curpcb)@@ha
	lwz	%r1,_C_LABEL(curpcb)@@l(%r1)
	addi	%r1,%r1,USPACE		/* stack is top of user struct */
1:
	bla	s_trap
_C_LABEL(alisize) =	.-_C_LABEL(alitrap)

/*
 * Similar to the above for DSI
 * Has to handle BAT spills
 * and standard pagetable spills
 */
	.globl	_C_LABEL(dsitrap),_C_LABEL(dsisize)
	.type	_C_LABEL(dsitrap),@@function
	.type	_C_LABEL(dsisize),@@object
_C_LABEL(dsitrap):
	stmw	%r28,disisave(0)	/* free r28-r31 */
	mfcr	%r29			/* save CR */
	mfxer	%r30			/* save XER */
	mtsprg	2,%r30			/* in SPRG2 */
	mfsrr1	%r31			/* test kernel mode */
#if 0
	mtcr	%r31
	bc	12,17,1f		/* branch if PSL_PR is set */
	mfdar	%r31			/* get fault address */
	rlwinm	%r31,%r31,7,25,28	/* get segment * 8 */
	addis	%r31,%r31,_C_LABEL(battable)@@ha
	lwz	%r30,_C_LABEL(battable)@@l(%r31)	/* get batu */
	mtcr	%r30
	bc	4,30,1f			/* branch if supervisor valid is false */
	lwz	%r31,_C_LABEL(battable)+4@@l(%r31)	/* get batl */
/* We randomly use the highest two bat registers here */
	mftb	%r28
	andi.	%r28,%r28,1
	bne	2f
	mtdbatu	2,%r30
	mtdbatl	2,%r31
	b	3f
2:
	mtdbatu	3,%r30
	mtdbatl	3,%r31
3:
	mfsprg	%r30,2			/* restore XER */
	mtxer	%r30
	mtcr	%r29			/* restore CR */
	lmw	%r28,disisave(0)	/* restore r28-r31 */
	rfi				/* return to trapped code */
1:
#endif
	mflr	%r28			/* save LR */
	bla	s_dsitrap
_C_LABEL(dsisize) =	.-_C_LABEL(dsitrap)

/*
 * Similar to the above for ISI
 */
	.globl	_C_LABEL(isitrap),_C_LABEL(isisize)
	.type	_C_LABEL(isitrap),@@function
	.type	_C_LABEL(isisize),@@object
_C_LABEL(isitrap):
	stmw	%r28,disisave(0)	/* free r28-r31 */
	mflr	%r28			/* save LR */
	mfcr	%r29			/* save CR */
	mfsrr1	%r31			/* test kernel mode */
#if 0
	mtcr	%r31
	bc	12,17,1f		/* branch if PSL_PR is set */
	mfsrr0	%r31			/* get fault address */
	rlwinm	%r31,%r31,7,25,28		/* get segment * 8 */
	addis	%r31,%r31,_C_LABEL(battable)@@ha
	lwz	%r30,_C_LABEL(battable)@@l(%r31)	/* get batu */
	mtcr	%r30
	bc	4,30,1f			/* branch if supervisor valid is false */
	mtibatu	3,%r30
	lwz	%r30,_C_LABEL(battable)+4@@l(%r31)	/* get batl */
	mtibatl	3,%r30
	mtcr	%r29			/* restore CR */
	lmw	%r28,disisave(0)	/* restore r28-r31 */
	rfi				/* return to trapped code */
1:
#endif
	bla	s_isitrap
_C_LABEL(isisize) =	.-_C_LABEL(isitrap)

/*
 * This one for the external interrupt handler.
 */
	.globl	_C_LABEL(extint),_C_LABEL(extsize)
	.type	_C_LABEL(extint),@@function
	.type	_C_LABEL(extsize),@@object
_C_LABEL(extint):
	mtsprg	1,%r1			/* save SP */
	stmw	%r28,tempsave(0)	/* free r28-r31 */
	mflr	%r28			/* save LR */
	mfcr	%r29			/* save CR */
	mfxer	%r30			/* save XER */
	lis	%r1,intstk+INTSTK@@ha	/* get interrupt stack */
	addi	%r1,%r1,intstk+INTSTK@@l
	lwz	%r31,0(%r1)		/* were we already running on intstk? */
	addic.	%r31,%r31,%r1
	stw	%r31,0(%r1)
	beq	1f
	mfsprg	%r1,1			/* yes, get old SP */
1:
	ba	extintr
_C_LABEL(extsize) =	.-_C_LABEL(extint)

/*
 * And this one for the decrementer interrupt handler.
 */
	.globl	_C_LABEL(decrint),_C_LABEL(decrsize)
	.type	_C_LABEL(decrint),@@function
	.type	_C_LABEL(decrsize),@@object
_C_LABEL(decrint):
	mtsprg	1,%r1			/* save SP */
	stmw	%r28,tempsave(0)	/* free r28-r31 */
	mflr	%r28			/* save LR */
	mfcr	%r29			/* save CR */
	mfxer	%r30			/* save XER */
	lis	%r1,intstk+INTSTK@@ha	/* get interrupt stack */
	addi	%r1,%r1,intstk+INTSTK@@l
	lwz	%r31,0(%r1)		/* were we already running on intstk? */
	addic.	%r31,%r31,%r1
	stw	%r31,0(%r1)
	beq	1f
	mfsprg	%r1,1			/* yes, get old SP */
1:
	ba	decrintr
_C_LABEL(decrsize) =	.-_C_LABEL(decrint)

/*
 * Now the tlb software load for 603 processors:
 * (Code essentially from the 603e User Manual, Chapter 5)
 */
#define	DMISS	976
#define	DCMP	977
#define	HASH1	978
#define	HASH2	979
#define	IMISS	980
#define	ICMP	981
#define	RPA	982

#define	bdneq	bdnzf 2,
#define	tlbli	.long	0x7c0007e4+0x800*
#define	tlbld	.long	0x7c0007a4+0x800*

	.globl	_C_LABEL(tlbimiss),_C_LABEL(tlbimsize)
	.type	_C_LABEL(tlbimiss),@@function
	.type	_C_LABEL(tlbimsize),@@object
_C_LABEL(tlbimiss):
	mfspr	%r2,HASH1		/* get first pointer */
	li	%r1,8
	mfctr	%r0			/* save counter */
	mfspr	%r3,ICMP		/* get first compare value */
	addi	%r2,%r2,-8		/* predec pointer */
1:
	mtctr	%r1			/* load counter */
2:
	lwzu	%r1,8(%r2)		/* get next pte */
	cmpl	0,%r1,%r3		/* see if found pte */
	bdneq	2b			/* loop if not eq */
	bne	3f			/* not found */
	lwz	%r1,4(%r2)		/* load tlb entry lower word */
	andi.	%r3,%r1,8		/* check G-bit */
	bne	4f			/* if guarded, take ISI */
	mtctr	%r0			/* restore counter */
	mfspr	%r0,IMISS		/* get the miss address for the tlbli */
	mfsrr1	%r3			/* get the saved cr0 bits */
	mtcrf	0x80,%r3		/* and restore */
	ori	%r1,%r1,0x100		/* set the reference bit */
	mtspr	RPA,%r1			/* set the pte */
	srwi	%r1,%r1,8		/* get byte 7 of pte */
	tlbli	0			/* load the itlb */
	stb	%r1,6(%r2)		/* update page table */
	rfi

3:	/* not found in pteg */
	andi.	%r1,%r3,0x40		/* have we already done second hash? */
	bne	5f
	mfspr	%r2,HASH2		/* get the second pointer */
	ori	%r3,%r3,0x40		/* change the compare value */
	li	%r1,8
	addi	%r2,%r2,-8		/* predec pointer */
	b	1b
4:	/* guarded */
	mfsrr1	%r3
	andi.	%r2,%r3,0xffff		/* clean upper srr1 */
	addis	%r2,%r2,0x800		/* set srr<4> to flag prot violation */
	b	6f
5:	/* not found anywhere */
	mfsrr1	%r3
	andi.	%r2,%r3,0xffff		/* clean upper srr1 */
	addis	%r2,%r2,0x4000		/* set srr1<1> to flag pte not found */
6:
	mtctr	%r0			/* restore counter */
	mtsrr1	%r2
	mfmsr	%r0
	xoris	%r0,%r0,2		/* flip the msr<tgpr> bit */
	mtcrf	0x80,%r3		/* restore cr0 */
	mtmsr	%r0			/* now with native gprs */
	isync
	ba	EXC_ISI
_C_LABEL(tlbimsize) =	.-_C_LABEL(tlbimiss)

	.globl	_C_LABEL(tlbdlmiss),_C_LABEL(tlbdlmsize)
	.type	_C_LABEL(tlbdlmiss),@@function
	.type	_C_LABEL(tlbdlmsize),@@object
_C_LABEL(tlbdlmiss):
	mfspr	%r2,HASH1		/* get first pointer */
	li	%r1,8
	mfctr	%r0			/* save counter */
	mfspr	%r3,DCMP		/* get first compare value */
	addi	%r2,%r2,-8		/* predec pointer */
1:
	mtctr	%r1			/* load counter */
2:
	lwzu	%r1,8(%r2)		/* get next pte */
	cmpl	0,%r1,%r3		/* see if found pte */
	bdneq	2b			/* loop if not eq */
	bne	3f			/* not found */
	lwz	%r1,4(%r2)		/* load tlb entry lower word */
	mtctr	%r0			/* restore counter */
	mfspr	%r0,DMISS		/* get the miss address for the tlbld */
	mfsrr1	%r3			/* get the saved cr0 bits */
	mtcrf	0x80,%r3		/* and restore */
	ori	%r1,%r1,0x100		/* set the reference bit */
	mtspr	RPA,%r1			/* set the pte */
	srwi	%r1,%r1,8		/* get byte 7 of pte */
	tlbld	0			/* load the dtlb */
	stb	%r1,6(%r2)		/* update page table */
	rfi

3:	/* not found in pteg */
	andi.	%r1,%r3,0x40		/* have we already done second hash? */
	bne	5f
	mfspr	%r2,HASH2		/* get the second pointer */
	ori	%r3,%r3,0x40		/* change the compare value */
	li	%r1,8
	addi	%r2,%r2,-8		/* predec pointer */
	b	1b
5:	/* not found anywhere */
	mfsrr1	%r3
	lis	%r1,0x4000		/* set dsisr<1> to flag pte not found */
	mtctr	%r0			/* restore counter */
	andi.	%r2,%r3,0xffff		/* clean upper srr1 */
	mtsrr1	%r2
	mtdsisr	%r1			/* load the dsisr */
	mfspr	%r1,DMISS		/* get the miss address */
	mtdar	%r1			/* put in dar */
	mfmsr	%r0
	xoris	%r0,%r0,2		/* flip the msr<tgpr> bit */
	mtcrf	0x80,%r3		/* restore cr0 */
	mtmsr	%r0			/* now with native gprs */
	isync
	ba	EXC_DSI
_C_LABEL(tlbdlmsize) =	.-_C_LABEL(tlbdlmiss)

	.globl	_C_LABEL(tlbdsmiss),_C_LABEL(tlbdsmsize)
	.type	_C_LABEL(tlbdsmiss),@@function
	.type	_C_LABEL(tlbdsmsize),@@object
_C_LABEL(tlbdsmiss):
	mfspr	%r2,HASH1		/* get first pointer */
	li	%r1,8
	mfctr	%r0			/* save counter */
	mfspr	%r3,DCMP		/* get first compare value */
	addi	%r2,%r2,-8		/* predec pointer */
1:
	mtctr	%r1			/* load counter */
2:
	lwzu	%r1,8(%r2)		/* get next pte */
	cmpl	0,%r1,%r3		/* see if found pte */
	bdneq	2b			/* loop if not eq */
	bne	3f			/* not found */
	lwz	%r1,4(%r2)		/* load tlb entry lower word */
	andi.	%r3,%r1,0x80		/* check the C-bit */
	beq	4f
5:
	mtctr	%r0			/* restore counter */
	mfspr	%r0,DMISS		/* get the miss address for the tlbld */
	mfsrr1	%r3			/* get the saved cr0 bits */
	mtcrf	0x80,%r3		/* and restore */
	mtspr	RPA,%r1			/* set the pte */
	tlbld	0			/* load the dtlb */
	rfi

3:	/* not found in pteg */
	andi.	%r1,%r3,0x40		/* have we already done second hash? */
	bne	5f
	mfspr	%r2,HASH2		/* get the second pointer */
	ori	%r3,%r3,0x40		/* change the compare value */
	li	%r1,8
	addi	%r2,%r2,-8		/* predec pointer */
	b	1b
4:	/* found, but C-bit = 0 */
	rlwinm.	%r3,%r1,30,0,1		/* test PP */
	bge-	7f
	andi.	%r3,%r1,1
	beq+	8f
9:	/* found, but protection violation (PP==00)*/
	mfsrr1	%r3
	lis	%r1,0xa00	/* indicate protection violation on store */
	b	1f
7:	/* found, PP=1x */
	mfspr	%r3,DMISS		/* get the miss address */
	mfsrin	%r1,%r3			/* get the segment register */
	mfsrr1	%r3
	rlwinm	%r3,%r3,18,31,31	/* get PR-bit */
	rlwnm.	%r2,%r2,3,1,1		/* get the key */
	bne-	9b			/* protection violation */
8:	/* found, set reference/change bits */
	lwz	%r1,4(%r2)		/* reload tlb entry */
	ori	%r1,%r1,0x180
	sth	%r1,6(%r2)
	b	5b
5:	/* not found anywhere */
	mfsrr1	%r3
	lis	%r1,0x4200		/* set dsisr<1> to flag pte not found */
					/* dsisr<6> to flag store */
1:
	mtctr	%r0			/* restore counter */
	andi.	%r2,%r3,0xffff		/* clean upper srr1 */
	mtsrr1	%r2
	mtdsisr	%r1			/* load the dsisr */
	mfspr	%r1,DMISS		/* get the miss address */
	mtdar	%r1			/* put in dar */
	mfmsr	%r0
	xoris	%r0,%r0,2		/* flip the msr<tgpr> bit */
	mtcrf	0x80,%r3		/* restore cr0 */
	mtmsr	%r0			/* now with native gprs */
	isync
	ba	EXC_DSI
_C_LABEL(tlbdsmsize) =	.-_C_LABEL(tlbdsmiss)

#ifdef DDB
#define ddbsave	0xde0		/* primary save area for DDB */
/*
 * In case of DDB we want a separate trap catcher for it
 */
	.local	ddbstk
	.comm	ddbstk,INTSTK,8	/* ddb stack */

	.globl	_C_LABEL(ddblow),_C_LABEL(ddbsize)
_C_LABEL(ddblow):
	mtsprg	1,%r1			/* save SP */
	stmw	%r28,ddbsave(0)		/* free r28-r31 */
	mflr	%r28			/* save LR */
	mfcr	%r29			/* save CR */
	lis	%r1,ddbstk+INTSTK@@ha	/* get new SP */
	addi	%r1,%r1,ddbstk+INTSTK@@l
	bla	ddbtrap
_C_LABEL(ddbsize) =	.-_C_LABEL(ddblow)
#endif  /* DDB */


/*
 * FRAME_SETUP assumes:
 *	SPRG1		SP (1)
 *	savearea	r28-r31,DAR,DSISR	(DAR & DSISR only for DSI traps)
 *	28		LR
 *	29		CR
 *	1		kernel stack
 *	LR		trap type
 *	SRR0/1		as at start of trap
 */
#define	FRAME_SETUP(savearea)						\
/* Have to enable translation to allow access of kernel stack: */	\
	mfsrr0	%r30;							\
	mfsrr1	%r31;							\
	stmw	%r30,savearea+24(0);					\
	mfmsr	%r30;							\
	ori	%r30,%r30,(PSL_DR|PSL_IR);				\
	mtmsr	%r30;							\
	isync;								\
	mfsprg	%r31,1;							\
	stwu	%r31,-FRAMELEN(%r1);					\
	stw	%r0,FRAME_0+8(%r1);					\
	stw	%r31,FRAME_1+8(%r1);					\
	stw	%r28,FRAME_LR+8(%r1);					\
	stw	%r29,FRAME_CR+8(%r1);					\
	lmw	%r28,savearea(0);					\
	stmw	%r2,FRAME_2+8(%r1);					\
	lmw	%r28,savearea+16(0);					\
	mfxer	%r3;							\
	mfctr	%r4;							\
	mflr	%r5;							\
	andi.	%r5,%r5,0xff00;						\
	stw	%r3,FRAME_XER+8(%r1);					\
	stw	%r4,FRAME_CTR+8(%r1);					\
	stw	%r5,FRAME_EXC+8(%r1);					\
	stw	%r28,FRAME_DAR+8(%r1);					\
	stw	%r29,FRAME_DSISR+8(%r1);				\
	stw	%r30,FRAME_SRR0+8(%r1);					\
	stw	%r31,FRAME_SRR1+8(%r1)

#define	FRAME_LEAVE(savearea)						\
/* Now restore regs: */							\
	lwz	%r2,FRAME_SRR0+8(%r1);					\
	lwz	%r3,FRAME_SRR1+8(%r1);					\
	lwz	%r4,FRAME_CTR+8(%r1);					\
	lwz	%r5,FRAME_XER+8(%r1);					\
	lwz	%r6,FRAME_LR+8(%r1);					\
	lwz	%r7,FRAME_CR+8(%r1);					\
	stw	%r2,savearea(0);					\
	stw	%r3,savearea+4(0);					\
	mtctr	%r4;							\
	mtxer	%r5;							\
	mtlr	%r6;							\
	mtsprg	1,%r7;			/* save cr */			\
	lmw	%r2,FRAME_2+8(%r1);					\
	lwz	%r0,FRAME_0+8(%r1);					\
	lwz	%r1,FRAME_1+8(%r1);					\
	mtsprg	2,%r2;			/* save r2 & r3 */		\
	mtsprg	3,%r3;							\
/* Disable translation, machine check and recoverability: */		\
	mfmsr	%r2;							\
	lis	%r3,(PSL_DR|PSL_IR|PSL_ME|PSL_RI)@@ha;			\
	addi	%r3,%r3,(PSL_DR|PSL_IR|PSL_ME|PSL_RI)@@l;		\
	andc	%r2,%r2,%r3;						\
	mtmsr	%r2;							\
	isync;								\
/* Decide whether we return to user mode: */				\
	lwz	%r3,savearea+4(0);					\
	mtcr	%r3;							\
	bc	4,17,1f;		/* branch if PSL_PR is false */	\
/* Restore user & kernel access SR: */					\
	lis	%r2,_C_LABEL(curpm)@@ha;	/* get real address of pmap */	\
	lwz	%r2,_C_LABEL(curpm)@@l(%r2);				\
	lwz	%r3,PM_USRSR(%r2);					\
	mtsr	PPC_USER_SR,%r3;					\
	lwz	%r3,PM_KERNELSR(%r2);					\
	mtsr	PPC_KERNEL_SR,%r3;					\
1:	mfsprg	%r2,1;			/* restore cr */		\
	mtcr	%r2;							\
	lwz	%r2,savearea(0);					\
	lwz	%r3,savearea+4(0);					\
	mtsrr0	%r2;							\
	mtsrr1	%r3;							\
	mfsprg	%r2,2;			/* restore r2 & r3 */		\
	mfsprg	%r3,3

/*
 * Preamble code for DSI/ISI traps
 */
disitrap:
	lmw	%r30,disisave(0)
	stmw	%r30,tempsave(0)
	lmw	%r30,disisave+8(0)
	stmw	%r30,tempsave+8(0)
	mfdar	%r30
	mfdsisr	%r31
	stmw	%r30,tempsave+16(0)
realtrap:
	/* Test whether we already had PR set */
	mfsrr1	%r1
	mtcr	%r1
	/* restore SP (might have been overwritten) */
	mfsprg	%r1,1
	bc	4,17,s_trap		/* branch if PSL_PR is false */
	lis	%r1,_C_LABEL(curpcb)@@ha
	lwz	%r1,_C_LABEL(curpcb)@@l(%r1)
	addi	%r1,%r1,USPACE		/* stack is top of user struct */
/*
 * Now the common trap catching code.
 */
s_trap:
/* First have to enable KERNEL mapping */
	lis	%r31,PPC_KERNEL_SEGMENT@@ha
	addi	%r31,%r31,PPC_KERNEL_SEGMENT@@l
	mtsr	PPC_KERNEL_SR,%r31
	FRAME_SETUP(tempsave)
/* Now we can recover interrupts again: */
	mfmsr	%r7
	mfsrr1	%r31
	andi.	%r31,%r31,PSL_EE	/* restore EE from previous context */
	or	%r7,%r7,%r31
	ori	%r7,%r7,(PSL_ME|PSL_RI)
	mtmsr	%r7
	isync
/* Call C trap code: */
trapagain:
	addi	%r3,%r1,8
	bl	_C_LABEL(trap)
trapexit:
/* Disable interrupts: */
	mfmsr	%r3
	andi.	%r3,%r3,~PSL_EE@@l
	mtmsr	%r3
/* Test AST pending: */
	lwz	%r5,FRAME_SRR1+8(%r1)
	mtcr	%r5
	bc	4,17,1f			/* branch if PSL_PR is false */
	lis	%r3,_C_LABEL(astpending)@@ha
	lwz	%r4,_C_LABEL(astpending)@@l(%r3)
	andi.	%r4,%r4,1
	beq	1f
	li	%r6,EXC_AST
	stw	%r6,FRAME_EXC+8(%r1)
	b	trapagain
1:
	FRAME_LEAVE(tempsave)
	rfi

/*
 * Child comes here at the end of a fork.
 * Mostly similar to the above.
 */
	.globl	_C_LABEL(fork_trampoline)
	.type	_C_LABEL(fork_trampoline),@@function
_C_LABEL(fork_trampoline):
	li	%r3,0
	bl	_C_LABEL(lcsplx)
	mtlr	%r31
	mr	%r3,%r30
	blrl				/* jump indirect to r31 */
	b	trapexit

/*
 * DSI second stage fault handler
 */
s_dsitrap:
	mfdsisr	%r31			/* test if this is spill fault */
	mtcr	%r31
	mtsprg	1,%r1			/* save SP */
	bc	4,1,disitrap		/* branch if table miss is false */
	lis	%r1,spillstk+SPILLSTK@@ha
	addi	%r1,%r1,spillstk+SPILLSTK@@l	/* get spill stack */
	stwu	%r1,-52(%r1)
	stw	%r0,48(%r1)		/* save non-volatile registers */
	stw	%r3,44(%r1)
	stw	%r4,40(%r1)
	stw	%r5,36(%r1)
	stw	%r6,32(%r1)
	stw	%r7,28(%r1)
	stw	%r8,24(%r1)
	stw	%r9,20(%r1)
	stw	%r10,16(%r1)
	stw	%r11,12(%r1)
	stw	%r12,8(%r1)
	mfxer	%r30			/* save XER */
	mtsprg	2,%r30
	mflr	%r30			/* save trap type */
	mfctr	%r31			/* & CTR */
	mfdar	%r3
	mfsrr1	%r4
	mfdsisr	%r5
	li	%r6, 0
s_pte_spill:
	bl	_C_LABEL(pte_spill_r)	/* try a spill */
	cmpwi	0,%r3,0
	mtctr	%r31			/* restore CTR */
	mtlr	%r30			/* and trap type */
	mfsprg	%r31,2			/* get saved XER */
	mtxer	%r31			/* restore XER */
	lwz	%r12,8(%r1)		/* restore non-volatile registers */
	lwz	%r11,12(%r1)
	lwz	%r10,16(%r1)
	lwz	%r9,20(%r1)
	lwz	%r8,24(%r1)
	lwz	%r7,28(%r1)
	lwz	%r6,32(%r1)
	lwz	%r5,36(%r1)
	lwz	%r4,40(%r1)
	lwz	%r3,44(%r1)
	lwz	%r0,48(%r1)
	beq	disitrap
	mfsprg	%r1,1			/* restore SP */
	mtcr	%r29			/* restore CR */
	mtlr	%r28			/* restore LR */
	lmw	%r28,disisave(0)	/* restore r28-r31 */
	rfi				/* return to trapped code */

/*
 * ISI second stage fault handler
 */
s_isitrap:
	mfsrr1	%r31			/* test if this may be a spill fault */
	mtcr	%r31
	mtsprg	1,%r1			/* save SP */
	bc	4,%r1,disitrap		/* branch if table miss is false */
	lis	%r1,spillstk+SPILLSTK@@ha
	addi	%r1,%r1,spillstk+SPILLSTK@@l	/* get spill stack */
	stwu	%r1,-52(%r1)
	stw	%r0,48(%r1)		/* save non-volatile registers */
	stw	%r3,44(%r1)
	stw	%r4,40(%r1)
	stw	%r5,36(%r1)
	stw	%r6,32(%r1)
	stw	%r7,28(%r1)
	stw	%r8,24(%r1)
	stw	%r9,20(%r1)
	stw	%r10,16(%r1)
	stw	%r11,12(%r1)
	stw	%r12,8(%r1)
	mfxer	%r30			/* save XER */
	mtsprg	2,%r30
	mflr	%r30			/* save trap type */
	mfctr	%r31			/* & ctr */
	mfsrr0	%r3
	mfsrr1	%r4
	li	%r5, 0
	li	%r6, 1
	b	s_pte_spill		/* above */

/*
 * External interrupt second level handler
 */
#define	INTRENTER							\
/* Save non-volatile registers: */					\
	stwu	%r1,-88(%r1);		/* temporarily */		\
	stw	%r0,84(%r1);						\
	mfsprg	%r0,1;			/* get original SP */		\
	stw	%r0,0(%r1);		/* and store it */		\
	stw	%r3,80(%r1);						\
	stw	%r4,76(%r1);						\
	stw	%r5,72(%r1);						\
	stw	%r6,68(%r1);						\
	stw	%r7,64(%r1);						\
	stw	%r8,60(%r1);						\
	stw	%r9,56(%r1);						\
	stw	%r10,52(%r1);						\
	stw	%r11,48(%r1);						\
	stw	%r12,44(%r1);						\
	stw	%r28,40(%r1);		/* saved LR */			\
	stw	%r29,36(%r1);		/* saved CR */			\
	stw	%r30,32(%r1);		/* saved XER */			\
	lmw	%r28,tempsave(0);	/* restore r28-r31 */		\
	mfctr	%r6;							\
	lis	%r5,_C_LABEL(intr_depth)@@ha;				\
	lwz	%r5,_C_LABEL(intr_depth)@@l(%r5);			\
	mfsrr0	%r4;							\
	mfsrr1	%r3;							\
	stw	%r6,28(%r1);						\
	stw	%r5,20(%r1);						\
	stw	%r4,12(%r1);						\
	stw	%r3,8(%r1);						\
/* interrupts are recoverable here, and enable translation */		\
	lis	%r3,(PPC_KERNEL_SEGMENT|SR_SUKEY|SR_PRKEY)@@ha;		\
	addi	%r3,%r3,(PPC_KERNEL_SEGMENT|SR_SUKEY|SR_PRKEY)@@l;	\
	mtsr	PPC_KERNEL_SR,%r3;					\
	mfmsr	%r5;							\
	ori	%r5,%r5,(PSL_IR|PSL_DR|PSL_RI);				\
	mtmsr	%r5;							\
	isync

	.globl	_C_LABEL(extint_call)
	.type	_C_LABEL(extint_call),@@function
extintr:
	INTRENTER
_C_LABEL(extint_call):
	bl	_C_LABEL(extint_call)		/* to be filled in later */
intr_exit:
/* Disable interrupts (should already be disabled) and MMU here: */
	mfmsr	%r3
	andi.	%r3,%r3,~(PSL_EE|PSL_ME|PSL_RI|PSL_DR|PSL_IR)@@l
	mtmsr	%r3
	isync
/* restore possibly overwritten registers: */
	lwz	%r12,44(%r1)
	lwz	%r11,48(%r1)
	lwz	%r10,52(%r1)
	lwz	%r9,56(%r1)
	lwz	%r8,60(%r1)
	lwz	%r7,64(%r1)
	lwz	%r6,8(%r1)
	lwz	%r5,12(%r1)
	lwz	%r4,28(%r1)
	lwz	%r3,32(%r1)
	mtsrr1	%r6
	mtsrr0	%r5
	mtctr	%r4
	mtxer	%r3
/* Returning to user mode? */
	mtcr	%r6			/* saved SRR1 */
	bc	4,17,1f			/* branch if PSL_PR is false */
	lis	%r3,_C_LABEL(curpm)@@ha	/* get current pmap real address */
	lwz	%r3,_C_LABEL(curpm)@@l(%r3)
	lwz	%r3,PM_KERNELSR(%r3)
	mtsr	PPC_KERNEL_SR,%r3		/* Restore kernel SR */
	lis	%r3,_C_LABEL(astpending)@@ha	/* Test AST pending */
	lwz	%r4,_C_LABEL(astpending)@@l(%r3)
	andi.	%r4,%r4,1
	beq	1f
/* Setup for entry to realtrap: */
	lwz	%r3,0(%r1)		/* get saved SP */
	mtsprg	%r1,3
	li	%r6,EXC_AST
	stmw	%r28,tempsave(0)	/* establish tempsave again */
	mtlr	%r6
	lwz	%r28,40(%r1)		/* saved LR */
	lwz	%r29,36(%r1)		/* saved CR */
	lwz	%r6,68(%r1)
	lwz	%r5,72(%r1)
	lwz	%r4,76(%r1)
	lwz	%r3,80(%r1)
	lwz	%r0,84(%r1)
	lis	%r30,_C_LABEL(intr_depth)@@ha	/* adjust reentrancy count */
	lwz	%r31,_C_LABEL(intr_depth)@@l(%r30)
	addi	%r31,%r31,-1
	stw	%r31,_C_LABEL(intr_depth)@@l(%r30)
	b	realtrap
1:
/* Here is the normal exit of extintr: */
	lwz	%r5,36(%r1)
	lwz	%r6,40(%r1)
	mtcr	%r5
	mtlr	%r6
	lwz	%r6,68(%r1)
	lwz	%r5,72(%r1)
	lis	%r3,_C_LABEL(intr_depth)@@ha	/* adjust reentrancy count */
	lwz	%r4,_C_LABEL(intr_depth)@@l(%r3)
	addi	%r4,%r4,-1
	stw	%r4,_C_LABEL(intr_depth)@@l(%r3)
	lwz	%r4,76(%r1)
	lwz	%r3,80(%r1)
	lwz	%r0,84(%r1)
	lwz	%r1,0(%r1)
	rfi

/*
 * Decrementer interrupt second level handler
 */
decrintr:
	INTRENTER
	addi	%r3,%r1,8			/* intr frame */
	bl	_C_LABEL(decr_intr)
	b	intr_exit


/*
 * int setfault()
 *
 * Similar to setjmp to setup for handling faults on accesses to user memory.
 * Any routine using this may only call bcopy, either the form below,
 * or the (currently used) C code optimized, so it doesn't use any non-volatile
 * registers.
 */
	.globl	_C_LABEL(setfault)
	.type	_C_LABEL(setfault),@@function
_C_LABEL(setfault):
	mflr	%r0
	mfcr	%r12
	mfmsr	%r2
	lis	%r4,_C_LABEL(curpcb)@@ha
	lwz	%r4,_C_LABEL(curpcb)@@l(%r4)
	stw	%r3,PCB_FAULT(%r4)
	stw	%r0,0(%r3)
	stw	%r2,4(%r3)
	stw	%r1,8(%r3)
	stmw	%r12,12(%r3)
	li	%r3,0
	blr

/*
 * The following code gets copied to the top of the user stack on process
 * execution.  It does signal trampolining on signal delivery.
 *
 * On entry r1 points to a struct sigframe at bottom of current stack.
 * All other registers are unchanged.
 */
	.globl	_C_LABEL(sigcode),_C_LABEL(esigcode)
	.type	_C_LABEL(sigcode),@@function
	.type	_C_LABEL(esigcode),@@function
_C_LABEL(sigcode):
	addi	%r1,%r1,-((16+FPSIG_SIZEOF+15)& ~0xf)		/* reserved space for callee */
	addi	%r6,%r1,8
	stfd	%f0,0(%r6)
	stfd	%f1,8(%r6)
	stfd	%f2,16(%r6)
	stfd	%f3,24(%r6)
	stfd	%f4,32(%r6)
	stfd	%f5,40(%r6)
	stfd	%f6,48(%r6)
	stfd	%f7,56(%r6)
	stfd	%f8,64(%r6)
	stfd	%f9,72(%r6)
	stfd	%f10,80(%r6)
	stfd	%f11,88(%r6)
	stfd	%f12,96(%r6)
	stfd	%f13,104(%r6)
	mffs	%f0
	stfd	%f0,112(%r6)
	lfd	%f0,0(%r6)	/* restore the clobbered register */
		
	blrl
	addi	%r6,%r1,8
	lfd	%f0,112(%r6)
	mtfsf	0xff,%f0
	lfd	%f0,0(%r6)
	lfd	%f1,8(%r6)
	lfd	%f2,16(%r6)
	lfd	%f3,24(%r6)
	lfd	%f4,32(%r6)
	lfd	%f5,40(%r6)
	lfd	%f6,48(%r6)
	lfd	%f7,56(%r6)
	lfd	%f8,64(%r6)
	lfd	%f9,72(%r6)
	lfd	%f10,80(%r6)
	lfd	%f11,88(%r6)
	lfd	%f12,96(%r6)
	lfd	%f13,104(%r6)
	addi	%r3,%r1,((16+FPSIG_SIZEOF+15)&~0xf)+SF_SC	/* compute &sf_sc */
	li	%r0,SYS_sigreturn
	sc				/* sigreturn(scp) */
	li	%r0,SYS_exit
	sc				/* exit(errno) */
_C_LABEL(esigcode):


#ifdef DDB
/*
 * Deliberate entry to ddbtrap
 */
	.globl	_C_LABEL(ddb_trap)
_C_LABEL(ddb_trap):
	mtsprg	%r1,1
	mfmsr	%r3
	mtsrr1	%r3
	andi.	%r3,%r3,~(PSL_EE|PSL_ME)@@l
	mtmsr	%r3				/* disable interrupts */
	isync
	stmw	%r28,ddbsave(0)
	mflr	%r28
	li	%r29,EXC_BPT
	mtlr	%r29
	mfcr	%r29
	mtsrr0	%r28

/*
 * Now the ddb trap catching code.
 */
ddbtrap:
	FRAME_SETUP(ddbsave)
/* Call C trap code: */
	addi	%r3,%r1,8
	bl	_C_LABEL(ddb_trap_glue)
	or.	%r3,%r3,%r3
	bne	ddbleave
/* This wasn't for DDB, so switch to real trap: */
	lwz	%r3,FRAME_EXC+8(%r1)	/* save exception */
	stw	%r3,ddbsave+8(0)
	FRAME_LEAVE(ddbsave)
	mtsprg	%r1,1			/* prepare for entrance to realtrap */
	stmw	%r28,tempsave(0)
	mflr	%r28
	mfcr	%r29
	lwz	%r31,ddbsave+8(0)
	mtlr	%r31
	b	realtrap
ddbleave:
	FRAME_LEAVE(ddbsave)
	rfi
#endif /* DDB */

@


1.13
log
@No longer clear ci_want_resched within cpu_switchto(), now that it's done
in the MI code.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.12 2005/11/24 12:08:16 pedro Exp $	*/
@


1.12
log
@Remove kernfs, okay deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.11 2005/08/02 21:27:58 drahn Exp $	*/
a219 5
	/* just did this resched thing, clear resched */
	li	%r3,0
	lis	%r4,_C_LABEL(want_resched)@@ha
	stw	%r3,_C_LABEL(want_resched)@@l(%r4)

@


1.11
log
@Save floating point context on signals, same diff as macppc
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.10 2004/12/24 22:50:30 miod Exp $	*/
d85 1
a85 1
#if defined(DDB) || defined(KERNFS)
@


1.10
log
@{e,}intr{cnt,names} bye-bye.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.9 2004/11/17 20:10:26 miod Exp $	*/
d1128 20
a1147 1
	addi	%r1,%r1,-16		/* reserved space for callee */
d1149 18
a1166 1
	addi	%r3,%r1,16+8		/* compute &sf_sc */
@


1.9
log
@Add register prefixes and generally match macppc locore.S now; diff between
both locore is useful now.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.8 2004/11/16 17:08:09 miod Exp $	*/
a1136 53


	.data
	.globl	_C_LABEL(intrnames)
	.type	_C_LABEL(intrnames),@@object
	.globl	_C_LABEL(eintrnames)
	.type	_C_LABEL(eintrnames),@@object
_C_LABEL(intrnames):
	.string "irq0" "irq1" "irq2" "irq3"
	.string "irq4" "irq5" "irq6" "irq7"
	.string "irq8" "irq9" "irq10" "irq11"
	.string "irq12" "irq13" "irq14" "irq15"
	.string "irq16" "irq17" "irq18" "irq19"
	.string "irq20" "irq21" "irq22" "irq23"
	.string "irq24" "irq25" "irq26" "irq27"
	.string "irq28" "irq29" "irq30" "irq31"
	.string "irq32" "irq33" "irq34" "irq35"
	.string "irq36" "irq37" "irq38" "irq39"
	.string "irq40" "irq41" "irq42" "irq43"
	.string "irq44" "irq45" "irq46" "irq47"
	.string "irq48" "irq49" "irq50" "irq51"
	.string "irq52" "irq53" "irq54" "irq55"
	.string "irq56" "irq57" "irq58" "irq59"
	.string "irq60" "irq61" "irq62" "irq63"
	.string "clock"
	.string "stat"
	.space 512
_C_LABEL(eintrnames):
	.align 4
	.globl	_C_LABEL(intrcnt)
	.type	_C_LABEL(intrcnt),@@object
	.globl	_C_LABEL(eintrcnt)
	.type	_C_LABEL(eintrcnt),@@object
_C_LABEL(intrcnt):
	.long 0,0,0,0
	.long 0,0,0,0
	.long 0,0,0,0
	.long 0,0,0,0
	.long 0,0,0,0
	.long 0,0,0,0
	.long 0,0,0,0
	.long 0,0,0,0
	.long 0,0,0,0
	.long 0,0,0,0
	.long 0,0,0,0
	.long 0,0,0,0
	.long 0,0,0,0
	.long 0,0,0,0
	.long 0,0,0,0
	.long 0,0,0,0
	.long 0
	.long 0
_C_LABEL(eintrcnt):
@


1.8
log
@Set p_stat to SONPROC in cpu_switch() after picking a proc to run.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.7 2004/06/24 22:35:56 drahn Exp $	*/
d74 2
a75 2
	li	0,0 /*(PSL_FP)*/
	mtmsr	0			/* Disable FPU/MMU/exceptions */
d86 2
a87 2
	lis	9,_C_LABEL(esym)@@ha
	stw	8,_C_LABEL(esym)@@l(9)	/* save for symbol handling */
d89 2
a90 2
	lis	8,_end@@ha
	addi	8,8,_end@@l
d92 16
a107 16
	li	9,PGOFSET
	add	8,8,9
	andc	8,8,9
	lis	9,idle_u@@ha
	stw	8,idle_u@@l(9)
	addi	8,8,USPACE		/* space for idle_u */
	lis	9,_C_LABEL(proc0paddr)@@ha
	stw	8,_C_LABEL(proc0paddr)@@l(9)
	addi	1,8,USPACE-FRAMELEN	/* stackpointer for proc0 */
	mr	4,1			/* end of mem reserved for kernel */
	li	0,0
	stwu	0,-16(1)		/* end of stack chain */

	lis	3,start@@ha
	addi	3,3,start@@l
	mr	5,6			/* args string */
d117 1
a117 1
	mfmsr	3
d119 2
a120 2
	andi.	3,3,~PSL_EE@@l
	mtmsr	3
d122 2
a123 2
	lis	8,_C_LABEL(whichqs)@@ha
	lwz	9,_C_LABEL(whichqs)@@l(8)
d125 1
a125 1
	or.	9,9,9
d128 2
a129 2
	ori	3,3,PSL_EE		/* reenable ints again */
	mtmsr	3
d133 3
a135 3
	mfmsr	3
	oris	3, 3, PSL_POW@@h
	mtmsr	3
d148 5
a152 5
	lis	6,idle_u@@ha
	lwz	6,idle_u@@l(6)
	lis	7,_C_LABEL(curpcb)@@ha
	stw	6,_C_LABEL(curpcb)@@l(7)
	addi	1,6,USPACE-16		/* 16 bytes are reserved at stack top */
d157 1
a157 1
	bl      _C_LABEL(exit2)
d160 1
a160 2
	li      3,0                     /* indicate exited process */

d169 9
a177 9
	mflr	0			/* save lr */
	stw	0,4(1)
	stwu	1,-16(1)
	stw	31,12(1)
	stw	30,8(1)

	mr	30,3
	lis	3,_C_LABEL(curproc)@@ha
	li	31,0
d179 3
a181 3
	stw	31,_C_LABEL(curproc)@@l(3)
	lis	3,_C_LABEL(curpcb)@@ha
	lwz	31,_C_LABEL(curpcb)@@l(3)
d183 1
a183 1
	li	3,0
d185 1
a185 1
	stw	3,PCB_SPL(31)		/* save spl */
d188 2
a189 2
	mfmsr	3
	andi.	3,3,~PSL_EE@@l		/* disable interrupts while
d191 1
a191 1
	mtmsr	3
d194 2
a195 2
	lis	8,_C_LABEL(whichqs)@@ha
	lwz	9,_C_LABEL(whichqs)@@l(8)
d197 2
a198 2
	or.	9,9,9
	beq-	_C_LABEL(idle)			/* all queues empty */
d200 10
a209 10
	cntlzw	10,9
	lis	4,_C_LABEL(qs)@@ha
	addi	4,4,_C_LABEL(qs)@@l
	slwi	3,10,3
	add	3,3,4			/* select queue */

	lwz	31,P_FORW(3)		/* unlink first proc from queue */
	lwz	4,P_FORW(31)
	stw	4,P_FORW(3)
	stw	3,P_BACK(4)
d211 1
a211 1
	cmpl	0,3,4			/* queue empty? */
d214 4
a217 4
	lis	3,0x80000000@@ha
	srw	3,3,10
	andc	9,9,3
	stw	9,_C_LABEL(whichqs)@@l(8)	/* mark it empty */
d220 4
a223 4
	/* just did this resched thing */
	li	3,0
	lis	4,_C_LABEL(want_resched)@@ha
	stw	3,_C_LABEL(want_resched)@@l(4)
d225 1
a225 1
	stw	3,P_BACK(31)		/* probably superfluous */
d227 2
a228 2
	lis	4,_C_LABEL(curproc)@@ha
	stw	31,_C_LABEL(curproc)@@l(4)	/* record new process */
d233 3
a235 3
	mfmsr	3
	ori	3,3,PSL_EE		/* Now we can interrupt again */
	mtmsr	3
d237 1
a237 1
	cmpl	0,31,30			/* is it the same process? */
d240 1
a240 1
	or.	30,30,30		/* old process was exiting? */
d243 7
a249 7
	mfsr	10,PPC_USER_SR		/* save USER_SR for copyin/copyout */
	mfcr	11			/* save cr */
	mr	12,2			/* save r2 */
	stwu	1,-SFRAMELEN(1)		/* still running on old stack */
	stmw	10,8(1)
	lwz	3,P_ADDR(30)
	stw	1,PCB_SP(3)		/* save SP */
d253 7
a259 7
	mfmsr	3
	andi.	3,3,~PSL_EE@@l
	mtmsr	3

	lwz	4,P_ADDR(31)
	lis	5,_C_LABEL(curpcb)@@ha
	stw	4,_C_LABEL(curpcb)@@l(5)		/* indicate new pcb */
d261 1
a261 1
	lwz	5,PCB_PMR(4)
d264 7
a270 7
	lis	6,_C_LABEL(curpm)@@ha
	stwu	5,_C_LABEL(curpm)@@l(6)
	stwcx.	5,0,6			/* clear possible reservation */

	addic.	5,5,64
	li	6,0
	mfsr	8,PPC_KERNEL_SR		/* save kernel SR */
d272 4
a275 4
	addis	6,6,-0x10000000@@ha	/* set new procs segment registers */
	or.	6,6,6			/* This is done from the real address pmap */
	lwzu	7,-4(5)			/* so we don't have to worry */
	mtsrin	7,6			/* about accessibility */
d277 1
a277 1
	mtsr	PPC_KERNEL_SR,8		/* restore kernel SR */
d280 1
a280 1
	lwz	1,PCB_SP(4)		/* get new procs SP */
d282 2
a283 2
	ori	3,3,PSL_EE		/* interrupts are okay again */
	mtmsr	3
d285 4
a288 4
	lmw	10,8(1)			/* get other regs */
	lwz	1,0(1)			/* get saved SP */
	mr	2,12			/* get saved r2 */
	mtcr	11			/* get saved cr */
d290 1
a290 1
	mtsr	PPC_USER_SR,10		/* get saved USER_SR */
d294 2
a295 2
	mr	30,7			/* save proc pointer */
	lwz	3,PCB_SPL(4)
d298 1
a298 1
	mr	3,30			/* curproc for special fork returns */
d300 5
a304 5
	lwz	31,12(1)
	lwz	30,8(1)
	addi	1,1,16
	lwz	0,4(1)
	mtlr	0
d325 1
a325 1
 * except ISI/DSI, ALI, the interrupts
d332 4
a335 4
	mtsprg	1,1			/* save SP */
	stmw	28,tempsave(0)		/* free r28-r31 */
	mflr	28			/* save LR */
	mfcr	29			/* save CR */
d338 2
a339 2
	mfsrr1	31
	mtcr	31
d341 3
a343 3
	lis	1,_C_LABEL(curpcb)@@ha
	lwz	1,_C_LABEL(curpcb)@@l(1)
	addi	1,1,USPACE		/* stack is top of user struct */
d351 1
a351 1
	.globl  _C_LABEL(alitrap),_C_LABEL(alisize)
d353 7
a359 7
	mtsprg  1,1                     /* save SP */
	stmw    28,tempsave(0)          /* free r28-r31 */
	mfdar   30
	mfdsisr 31
	stmw    30,tempsave+16(0)
	mflr    28                      /* save LR */
	mfcr    29                      /* save CR */
d362 6
a367 6
	mfsrr1  31
	mtcr    31
	bc      4,17,1f                 /* branch if PSL_PR is clear */
	lis     1,_C_LABEL(curpcb)@@ha
	lwz     1,_C_LABEL(curpcb)@@l(1)
	addi    1,1,USPACE              /* stack is top of user struct */
d369 2
a370 2
	bla     s_trap
_C_LABEL(alisize) = .-_C_LABEL(alitrap)
d381 5
a385 5
	stmw	28,disisave(0)		/* free r28-r31 */
	mfcr	29			/* save CR */
	mfxer	30			/* save XER */
	mtsprg	2,30			/* in SPRG2 */
	mfsrr1	31			/* test kernel mode */
d387 1
a387 1
	mtcr	31
d389 5
a393 5
	mfdar	31			/* get fault address */
	rlwinm	31,31,7,25,28		/* get segment * 8 */
	addis	31,31,_C_LABEL(battable)@@ha
	lwz	30,_C_LABEL(battable)@@l(31)	/* get batu */
	mtcr	30
d395 1
a395 1
	lwz	31,_C_LABEL(battable)+4@@l(31)	/* get batl */
d397 2
a398 2
	mftb	28
	andi.	28,28,1
d400 2
a401 2
	mtdbatu	2,30
	mtdbatl	2,31
d404 2
a405 2
	mtdbatu	3,30
	mtdbatl	3,31
d407 4
a410 4
	mfsprg	30,2			/* restore XER */
	mtxer	30
	mtcr	29			/* restore CR */
	lmw	28,disisave(0)		/* restore r28-r31 */
d414 1
a414 1
	mflr	28			/* save LR */
d425 4
a428 4
	stmw	28,disisave(0)		/* free r28-r31 */
	mflr	28			/* save LR */
	mfcr	29			/* save CR */
	mfsrr1	31			/* test kernel mode */
d430 1
a430 1
	mtcr	31
d432 5
a436 5
	mfsrr0	31			/* get fault address */
	rlwinm	31,31,7,25,28		/* get segment * 8 */
	addis	31,31,_C_LABEL(battable)@@ha
	lwz	30,_C_LABEL(battable)@@l(31)	/* get batu */
	mtcr	30
d438 5
a442 5
	mtibatu	3,30
	lwz	30,_C_LABEL(battable)+4@@l(31)	/* get batl */
	mtibatl	3,30
	mtcr	29			/* restore CR */
	lmw	28,disisave(0)		/* restore r28-r31 */
d456 10
a465 10
	mtsprg	1,1			/* save SP */
	stmw	28,tempsave(0)		/* free r28-r31 */
	mflr	28			/* save LR */
	mfcr	29			/* save CR */
	mfxer	30			/* save XER */
	lis	1,intstk+INTSTK@@ha	/* get interrupt stack */
	addi	1,1,intstk+INTSTK@@l
	lwz	31,0(1)			/* were we already running on intstk? */
	addic.	31,31,1
	stw	31,0(1)
d467 1
a467 1
	mfsprg	1,1			/* yes, get old SP */
d479 10
a488 10
	mtsprg	1,1			/* save SP */
	stmw	28,tempsave(0)		/* free r28-r31 */
	mflr	28			/* save LR */
	mfcr	29			/* save CR */
	mfxer	30			/* save XER */
	lis	1,intstk+INTSTK@@ha	/* get interrupt stack */
	addi	1,1,intstk+INTSTK@@l
	lwz	31,0(1)			/* were we already running on intstk? */
	addic.	31,31,1
	stw	31,0(1)
d490 1
a490 1
	mfsprg	1,1			/* yes, get old SP */
d515 5
a519 5
	mfspr	2,HASH1			/* get first pointer */
	li	1,8
	mfctr	0			/* save counter */
	mfspr	3,ICMP			/* get first compare value */
	addi	2,2,-8			/* predec pointer */
d521 1
a521 1
	mtctr	1			/* load counter */
d523 2
a524 2
	lwzu	1,8(2)			/* get next pte */
	cmpl	0,1,3			/* see if found pte */
d527 2
a528 2
	lwz	1,4(2)			/* load tlb entry lower word */
	andi.	3,1,8			/* check G-bit */
d530 7
a536 7
	mtctr	0			/* restore counter */
	mfspr	0,IMISS			/* get the miss address for the tlbli */
	mfsrr1	3			/* get the saved cr0 bits */
	mtcrf	0x80,3			/* and restore */
	ori	1,1,0x100		/* set the reference bit */
	mtspr	RPA,1			/* set the pte */
	srwi	1,1,8			/* get byte 7 of pte */
d538 1
a538 1
	stb	1,6(2)			/* update page table */
d542 1
a542 1
	andi.	1,3,0x40		/* have we already done second hash? */
d544 4
a547 4
	mfspr	2,HASH2			/* get the second pointer */
	ori	3,3,0x40		/* change the compare value */
	li	1,8
	addi	2,2,-8			/* predec pointer */
d550 3
a552 3
	mfsrr1	3
	andi.	2,3,0xffff		/* clean upper srr1 */
	addis	2,2,0x800		/* set srr<4> to flag prot violation */
d555 3
a557 3
	mfsrr1	3
	andi.	2,3,0xffff		/* clean upper srr1 */
	addis	2,2,0x4000		/* set srr1<1> to flag pte not found */
d559 6
a564 6
	mtctr	0			/* restore counter */
	mtsrr1	2
	mfmsr	0
	xoris	0,0,2			/* flip the msr<tgpr> bit */
	mtcrf	0x80,3			/* restore cr0 */
	mtmsr	0			/* now with native gprs */
d573 5
a577 5
	mfspr	2,HASH1			/* get first pointer */
	li	1,8
	mfctr	0			/* save counter */
	mfspr	3,DCMP			/* get first compare value */
	addi	2,2,-8			/* predec pointer */
d579 1
a579 1
	mtctr	1			/* load counter */
d581 2
a582 2
	lwzu	1,8(2)			/* get next pte */
	cmpl	0,1,3			/* see if found pte */
d585 8
a592 8
	lwz	1,4(2)			/* load tlb entry lower word */
	mtctr	0			/* restore counter */
	mfspr	0,DMISS			/* get the miss address for the tlbld */
	mfsrr1	3			/* get the saved cr0 bits */
	mtcrf	0x80,3			/* and restore */
	ori	1,1,0x100		/* set the reference bit */
	mtspr	RPA,1			/* set the pte */
	srwi	1,1,8			/* get byte 7 of pte */
d594 1
a594 1
	stb	1,6(2)			/* update page table */
d598 1
a598 1
	andi.	1,3,0x40		/* have we already done second hash? */
d600 4
a603 4
	mfspr	2,HASH2			/* get the second pointer */
	ori	3,3,0x40		/* change the compare value */
	li	1,8
	addi	2,2,-8			/* predec pointer */
d606 12
a617 12
	mfsrr1	3
	lis	1,0x4000		/* set dsisr<1> to flag pte not found */
	mtctr	0			/* restore counter */
	andi.	2,3,0xffff		/* clean upper srr1 */
	mtsrr1	2
	mtdsisr	1			/* load the dsisr */
	mfspr	1,DMISS			/* get the miss address */
	mtdar	1			/* put in dar */
	mfmsr	0
	xoris	0,0,2			/* flip the msr<tgpr> bit */
	mtcrf	0x80,3			/* restore cr0 */
	mtmsr	0			/* now with native gprs */
d626 5
a630 5
	mfspr	2,HASH1			/* get first pointer */
	li	1,8
	mfctr	0			/* save counter */
	mfspr	3,DCMP			/* get first compare value */
	addi	2,2,-8			/* predec pointer */
d632 1
a632 1
	mtctr	1			/* load counter */
d634 2
a635 2
	lwzu	1,8(2)			/* get next pte */
	cmpl	0,1,3			/* see if found pte */
d638 2
a639 2
	lwz	1,4(2)			/* load tlb entry lower word */
	andi.	3,1,0x80		/* check the C-bit */
d642 5
a646 5
	mtctr	0			/* restore counter */
	mfspr	0,DMISS			/* get the miss address for the tlbld */
	mfsrr1	3			/* get the saved cr0 bits */
	mtcrf	0x80,3			/* and restore */
	mtspr	RPA,1			/* set the pte */
d651 1
a651 1
	andi.	1,3,0x40		/* have we already done second hash? */
d653 4
a656 4
	mfspr	2,HASH2			/* get the second pointer */
	ori	3,3,0x40		/* change the compare value */
	li	1,8
	addi	2,2,-8			/* predec pointer */
d659 1
a659 1
	rlwinm.	3,1,30,0,1		/* test PP */
d661 1
a661 1
	andi.	3,1,1
d664 2
a665 2
	mfsrr1	3
	lis	1,0xa00		/* indicate protection violation on store */
d668 5
a672 5
	mfspr	3,DMISS			/* get the miss address */
	mfsrin	1,3			/* get the segment register */
	mfsrr1	3
	rlwinm	3,3,18,31,31		/* get PR-bit */
	rlwnm.	2,2,3,1,1		/* get the key */
d675 3
a677 3
	lwz	1,4(2)			/* reload tlb entry */
	ori	1,1,0x180
	sth	1,6(2)
d680 2
a681 2
	mfsrr1	3
	lis	1,0x4200		/* set dsisr<1> to flag pte not found */
d684 10
a693 10
	mtctr	0			/* restore counter */
	andi.	2,3,0xffff		/* clean upper srr1 */
	mtsrr1	2
	mtdsisr	1			/* load the dsisr */
	mfspr	1,DMISS			/* get the miss address */
	mtdar	1			/* put in dar */
	mfmsr	0
	xoris	0,0,2			/* flip the msr<tgpr> bit */
	mtcrf	0x80,3			/* restore cr0 */
	mtmsr	0			/* now with native gprs */
d699 1
a699 1
#define ddbsave        0xde0                /* primary save area for DDB */
d703 2
a704 2
        .local        ddbstk
        .comm        ddbstk,INTSTK,8                /* ddb stack */
d706 1
a706 1
        .globl        _C_LABEL(ddblow),_C_LABEL(ddbsize)
d708 8
a715 8
        mtsprg        1,1                        /* save SP */
        stmw        28,ddbsave(0)                /* free r28-r31 */
        mflr        28                        /* save LR */
        mfcr        29                        /* save CR */
        lis        1,ddbstk+INTSTK@@ha        /* get new SP */
        addi        1,1,ddbstk+INTSTK@@l
        bla        ddbtrap
_C_LABEL(ddbsize) = .-_C_LABEL(ddblow)
d731 6
a736 6
	mfsrr0	30;							\
	mfsrr1	31;							\
	stmw	30,savearea+24(0);					\
	mfmsr	30;							\
	ori	30,30,(PSL_DR|PSL_IR);					\
	mtmsr	30;							\
d738 20
a757 20
	mfsprg	31,1;							\
	stwu	31,-FRAMELEN(1);					\
	stw	0,FRAME_0+8(1);						\
	stw	31,FRAME_1+8(1);					\
	stw	28,FRAME_LR+8(1);					\
	stw	29,FRAME_CR+8(1);					\
	lmw	28,savearea(0);						\
	stmw	2,FRAME_2+8(1);						\
	lmw	28,savearea+16(0);					\
	mfxer	3;							\
	mfctr	4;							\
	mflr	5;							\
	andi.	5,5,0xff00;						\
	stw	3,FRAME_XER+8(1);					\
	stw	4,FRAME_CTR+8(1);					\
	stw	5,FRAME_EXC+8(1);					\
	stw	28,FRAME_DAR+8(1);					\
	stw	29,FRAME_DSISR+8(1);					\
	stw	30,FRAME_SRR0+8(1);					\
	stw	31,FRAME_SRR1+8(1)
d761 17
a777 17
	lwz	2,FRAME_SRR0+8(1);					\
	lwz	3,FRAME_SRR1+8(1);					\
	lwz	4,FRAME_CTR+8(1);					\
	lwz	5,FRAME_XER+8(1);					\
	lwz	6,FRAME_LR+8(1);					\
	lwz	7,FRAME_CR+8(1);					\
	stw	2,savearea(0);						\
	stw	3,savearea+4(0);					\
	mtctr	4;							\
	mtxer	5;							\
	mtlr	6;							\
	mtsprg	1,7;			/* save cr */			\
	lmw	2,FRAME_2+8(1);						\
	lwz	0,FRAME_0+8(1);						\
	lwz	1,FRAME_1+8(1);						\
	mtsprg	2,2;			/* save r2 & r3 */		\
	mtsprg	3,3;							\
d779 5
a783 5
	mfmsr	2;							\
	lis	3,(PSL_DR|PSL_IR|PSL_ME|PSL_RI)@@ha;			\
	addi	3,3,(PSL_DR|PSL_IR|PSL_ME|PSL_RI)@@l;			\
	andc	2,2,3;							\
	mtmsr	2;							\
d786 2
a787 2
	lwz	3,savearea+4(0);					\
	mtcr	3;							\
d790 14
a803 14
	lis	2,_C_LABEL(curpm)@@ha;	/* get real address of pmap */	\
	lwz	2,_C_LABEL(curpm)@@l(2);					\
	lwz	3,PM_USRSR(2);						\
	mtsr	PPC_USER_SR,3;						\
	lwz	3,PM_KERNELSR(2);					\
	mtsr	PPC_KERNEL_SR,3;					\
1:	mfsprg	2,1;			/* restore cr */		\
	mtcr	2;							\
	lwz	2,savearea(0);						\
	lwz	3,savearea+4(0);					\
	mtsrr0	2;							\
	mtsrr1	3;							\
	mfsprg	2,2;			/* restore r2 & r3 */		\
	mfsprg	3,3
d809 7
a815 7
	lmw	30,disisave(0)
	stmw	30,tempsave(0)
	lmw	30,disisave+8(0)
	stmw	30,tempsave+8(0)
	mfdar	30
	mfdsisr	31
	stmw	30,tempsave+16(0)
d818 2
a819 2
	mfsrr1	1
	mtcr	1
d821 1
a821 1
	mfsprg	1,1
d823 3
a825 3
	lis	1,_C_LABEL(curpcb)@@ha
	lwz	1,_C_LABEL(curpcb)@@l(1)
	addi	1,1,USPACE		/* stack is top of user struct */
d831 3
a833 3
	lis	31,PPC_KERNEL_SEGMENT@@ha
	addi	31,31,PPC_KERNEL_SEGMENT@@l
	mtsr	PPC_KERNEL_SR,31
d836 1
a836 1
	mfmsr	7
d840 2
a841 2
	ori	7,7,(PSL_ME|PSL_RI)
	mtmsr	7
d845 1
a845 1
	addi	3,1,8
d849 3
a851 3
	mfmsr	3
	andi.	3,3,~PSL_EE@@l
	mtmsr	3
d853 2
a854 2
	lwz	5,FRAME_SRR1+8(1)
	mtcr	5
d856 3
a858 3
	lis	3,_C_LABEL(astpending)@@ha
	lwz	4,_C_LABEL(astpending)@@l(3)
	andi.	4,4,1
d860 2
a861 2
	li	6,EXC_AST
	stw	6,FRAME_EXC+8(1)
d874 1
a874 1
	xor	3,3,3
d876 2
a877 2
	mtlr	31
	mr	3,30
d885 3
a887 3
	mfdsisr	31			/* test if this is spill fault */
	mtcr	31
	mtsprg	1,1			/* save SP */
d889 22
a910 22
	lis	1,spillstk+SPILLSTK@@ha
	addi	1,1,spillstk+SPILLSTK@@l	/* get spill stack */
	stwu	1,-52(1)
	stw	0,48(1)			/* save non-volatile registers */
	stw	3,44(1)
	stw	4,40(1)
	stw	5,36(1)
	stw	6,32(1)
	stw	7,28(1)
	stw	8,24(1)
	stw	9,20(1)
	stw	10,16(1)
	stw	11,12(1)
	stw	12,8(1)
	mfxer	30			/* save XER */
	mtsprg	2,30
	mflr	30			/* save trap type */
	mfctr	31			/* & CTR */
	mfdar	3
	mfsrr1	4
	mfdsisr	5
	li	6, 0
d913 16
a928 16
	cmpwi	0,3,0
	mtctr	31			/* restore CTR */
	mtlr	30			/* and trap type */
	mfsprg	31,2			/* get saved XER */
	mtxer	31			/* restore XER */
	lwz	12,8(1)			/* restore non-volatile registers */
	lwz	11,12(1)
	lwz	10,16(1)
	lwz	9,20(1)
	lwz	8,24(1)
	lwz	7,28(1)
	lwz	6,32(1)
	lwz	5,36(1)
	lwz	4,40(1)
	lwz	3,44(1)
	lwz	0,48(1)
d930 4
a933 4
	mfsprg	1,1			/* restore SP */
	mtcr	29			/* restore CR */
	mtlr	28			/* restore LR */
	lmw	28,disisave(0)		/* restore r28-r31 */
d940 26
a965 26
	mfsrr1	31			/* test if this may be a spill fault */
	mtcr	31
	mtsprg	1,1			/* save SP */
	bc	4,1,disitrap		/* branch if table miss is false */
	lis	1,spillstk+SPILLSTK@@ha
	addi	1,1,spillstk+SPILLSTK@@l	/* get spill stack */
	stwu	1,-52(1)
	stw	0,48(1)			/* save non-volatile registers */
	stw	3,44(1)
	stw	4,40(1)
	stw	5,36(1)
	stw	6,32(1)
	stw	7,28(1)
	stw	8,24(1)
	stw	9,20(1)
	stw	10,16(1)
	stw	11,12(1)
	stw	12,8(1)
	mfxer	30			/* save XER */
	mtsprg	2,30
	mflr	30			/* save trap type */
	mfctr	31			/* & ctr */
	mfsrr0	3
	mfsrr1	4
	li	5, 0
	li	6, 1
d973 27
a999 27
	stwu	1,-88(1);		/* temporarily */		\
	stw	0,84(1);						\
	mfsprg	0,1;			/* get original SP */		\
	stw	0,0(1);			/* and store it */		\
	stw	3,80(1);						\
	stw	4,76(1);						\
	stw	5,72(1);						\
	stw	6,68(1);						\
	stw	7,64(1);						\
	stw	8,60(1);						\
	stw	9,56(1);						\
	stw	10,52(1);						\
	stw	11,48(1);						\
	stw	12,44(1);						\
	stw	28,40(1);		/* saved LR */			\
	stw	29,36(1);		/* saved CR */			\
	stw	30,32(1);		/* saved XER */			\
	lmw	28,tempsave(0);		/* restore r28-r31 */		\
	mfctr	6;							\
	lis	5,_C_LABEL(intr_depth)@@ha;				\
	lwz	5,_C_LABEL(intr_depth)@@l(5);				\
	mfsrr0	4;							\
	mfsrr1	3;							\
	stw	6,28(1);						\
	stw	5,20(1);						\
	stw	4,12(1);						\
	stw	3,8(1);							\
d1001 6
a1006 6
	lis	3,(PPC_KERNEL_SEGMENT|SR_SUKEY|SR_PRKEY)@@ha;		\
	addi	3,3,(PPC_KERNEL_SEGMENT|SR_SUKEY|SR_PRKEY)@@l;		\
	mtsr	PPC_KERNEL_SR,3;					\
	mfmsr	5;							\
	ori	5,5,(PSL_IR|PSL_DR|PSL_RI);				\
	mtmsr	5;							\
d1017 3
a1019 3
	mfmsr	3
	andi.	3,3,~(PSL_EE|PSL_ME|PSL_RI|PSL_DR|PSL_IR)@@l
	mtmsr	3
d1022 14
a1035 14
	lwz	12,44(1)
	lwz	11,48(1)
	lwz	10,52(1)
	lwz	9,56(1)
	lwz	8,60(1)
	lwz	7,64(1)
	lwz	6,8(1)
	lwz	5,12(1)
	lwz	4,28(1)
	lwz	3,32(1)
	mtsrr1	6
	mtsrr0	5
	mtctr	4
	mtxer	3
d1037 1
a1037 1
	mtcr	6			/* saved SRR1 */
d1039 7
a1045 7
	lis	3,_C_LABEL(curpm)@@ha	/* get current pmap real address */
	lwz	3,_C_LABEL(curpm)@@l(3)
	lwz	3,PM_KERNELSR(3)
	mtsr	PPC_KERNEL_SR,3		/* Restore kernel SR */
	lis	3,_C_LABEL(astpending)@@ha	/* Test AST pending */
	lwz	4,_C_LABEL(astpending)@@l(3)
	andi.	4,4,1
d1048 16
a1063 16
	lwz	3,0(1)			/* get saved SP */
	mtsprg	1,3
	li	6,EXC_AST
	stmw	28,tempsave(0)		/* establish tempsave again */
	mtlr	6
	lwz	28,40(1)		/* saved LR */
	lwz	29,36(1)		/* saved CR */
	lwz	6,68(1)
	lwz	5,72(1)
	lwz	4,76(1)
	lwz	3,80(1)
	lwz	0,84(1)
	lis	30,_C_LABEL(intr_depth)@@ha	/* adjust reentrancy count */
	lwz	31,_C_LABEL(intr_depth)@@l(30)
	addi	31,31,-1
	stw	31,_C_LABEL(intr_depth)@@l(30)
d1067 14
a1080 14
	lwz	5,36(1)
	lwz	6,40(1)
	mtcr	5
	mtlr	6
	lwz	6,68(1)
	lwz	5,72(1)
	lis	3,_C_LABEL(intr_depth)@@ha	/* adjust reentrancy count */
	lwz	4,_C_LABEL(intr_depth)@@l(3)
	addi	4,4,-1
	stw	4,_C_LABEL(intr_depth)@@l(3)
	lwz	4,76(1)
	lwz	3,80(1)
	lwz	0,84(1)
	lwz	1,0(1)
d1088 1
a1088 1
	addi	3,1,8			/* intr frame */
d1104 10
a1113 10
	mflr	0
	mfcr	12
	mfmsr	2
	lis	4,_C_LABEL(curpcb)@@ha
	lwz	4,_C_LABEL(curpcb)@@l(4)
	stw	3,PCB_FAULT(4)
	stw	0,0(3)
	stw	2,4(3)
	stw	1,8(3)
	stmw	12,12(3)
d1128 1
a1128 1
	addi	1,1,-16			/* reserved space for callee */
d1130 2
a1131 2
	addi	3,1,16+8		/* compute &sf_sc */
	li	0,SYS_sigreturn
d1133 1
a1133 1
	li	0,SYS_exit
d1140 4
a1143 4
	.globl   _C_LABEL(intrnames)
	.type   _C_LABEL(intrnames),@@object
	.globl   _C_LABEL(eintrnames)
	.type   _C_LABEL(eintrnames),@@object
d1162 1
a1162 1
	.string	"stat"
d1166 4
a1169 4
	.globl   _C_LABEL(intrcnt)
	.type   _C_LABEL(intrcnt),@@object
	.globl   _C_LABEL(eintrcnt)
	.type   _C_LABEL(eintrcnt),@@object
d1195 1
a1195 1
        .globl        _C_LABEL(ddb_trap)
d1197 12
a1208 12
        mtsprg        1,1
        mfmsr        3
        mtsrr1        3
        andi.        3,3,~(PSL_EE|PSL_ME)@@l
        mtmsr        3                        /* disable interrupts */
        isync
        stmw        28,ddbsave(0)
        mflr        28
        li        29,EXC_BPT
        mtlr        29
        mfcr        29
        mtsrr0        28
d1214 1
a1214 1
        FRAME_SETUP(ddbsave)
d1216 4
a1219 4
        addi        3,1,8
        bl        _C_LABEL(ddb_trap_glue)
        or.        3,3,3
        bne        ddbleave
d1221 10
a1230 10
        lwz        3,FRAME_EXC+8(1)        /* save exception */
        stw        3,ddbsave+8(0)
        FRAME_LEAVE(ddbsave)
        mtsprg        1,1		/* prepare for entrance to realtrap */
        stmw        28,tempsave(0)
        mflr        28
        mfcr        29
        lwz        31,ddbsave+8(0)
        mtlr        31
        b        realtrap
d1232 2
a1233 2
        FRAME_LEAVE(ddbsave)
        rfi
@


1.7
log
@Do a better job at containing powerpc specific #defines to PPC_...
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.6 2004/01/29 21:30:02 miod Exp $	*/
d230 3
@


1.6
log
@Have the bootloader pass RB_ flags, as well as the boot device, to the kernel,
and have the kernel process them correctly.

Right now code to match the BUG's idea of the boot device with the kernel's is
missing.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.5 2004/01/28 23:57:48 miod Exp $	*/
d241 1
a241 1
	mfsr	10,USER_SR		/* save USER_SR for copyin/copyout */
d268 1
a268 1
	mfsr	8,KERNEL_SR		/* save kernel SR */
d275 1
a275 1
	mtsr	KERNEL_SR,8		/* restore kernel SR */
d288 1
a288 1
	mtsr	USER_SR,10		/* get saved USER_SR */
d791 1
a791 1
	mtsr	USER_SR,3;						\
d793 1
a793 1
	mtsr	KERNEL_SR,3;						\
d829 3
a831 3
	lis	31,KERNEL_SEGMENT@@ha
	addi	31,31,KERNEL_SEGMENT@@l
	mtsr	KERNEL_SR,31
d999 3
a1001 3
	lis	3,(KERNEL_SEGMENT|SR_SUKEY|SR_PRKEY)@@ha;		\
	addi	3,3,(KERNEL_SEGMENT|SR_SUKEY|SR_PRKEY)@@l;		\
	mtsr	KERNEL_SR,3;						\
d1040 1
a1040 1
	mtsr	KERNEL_SR,3		/* Restore kernel SR */
@


1.5
log
@Return to BUG if main() returns, rather than falling through the scheduler...
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.4 2004/01/22 20:45:20 miod Exp $	*/
d61 2
a62 1
/* arguments to start
d64 2
a65 2
 * r3 - unused	(controller address for PPC1bug)
 * r4 - unused	(bootdev for PPC1bug)
d67 2
a68 2
 * r6 - arg list
 * r7 - length
d77 6
@


1.4
log
@Make locore and the early initialization code closer to other ppc ports;
also remove ipkbd and other dead code.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.3 2002/07/24 02:29:57 drahn Exp $	*/
d61 1
a61 1
/* arguments to start 
d81 1
a81 1
#else 
d97 1
a97 1
	
d103 1
a103 5
#if 0
	b	_C_LABEL(OF_exit)
#else
	/* XXX bugreturn */
#endif	
d120 1
a120 1
	
d130 1
a130 1
	
d155 1
a155 1
	
d199 1
a199 1
	
d1152 1
a1152 1
	.string "clock" 
@


1.3
log
@- change pte_spill_X() to take an extra parameter to determine if
  the fault is a EXE fault or R/W fault.

- mask/or the SR_NOEXEC bit into the segment register value
  when the number of executable pages becomes 0/non-zero.

- create segments with SR_NOEXEC set, will be cleared when first
  exec mapping in the segment is created.

- allow pte_spill_X() to deal with a new type of fault, page mapped
  but non executable, when execute was requested.

Adds up to - non-exec stack support.
[keep mvmeppc in sync]
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.2 2002/06/07 01:01:40 miod Exp $	*/
a34 2
#include "machine/ipkdb.h"

a55 4
	.globl _C_LABEL(where)
	.type  _C_LABEL(where),@@object
_C_LABEL(where):	.long	0

d95 1
a95 1
	xor	0,0,0
a97 4
	li	0, 2
	lis	9,_C_LABEL(where)@@ha
	stw	0,_C_LABEL(where)@@l(9)

d103 1
a103 1
#if 0	
d105 2
a108 37
#define LED_ADDR 0x800008c0
_ENTRY(_C_LABEL(led_dbg))
	stwu	1,-32(1)
	mflr	0
	stw	0,36(1)

	stw	4,8(1)
	stw	5,12(1)
	stw	6,16(1)
	stw	7,20(1)
	mfmsr	5

	mr	6,5
	ori	6,6,(PSL_IR|PSL_DR)@@l	/* turn on MMU */
	mtmsr	6
	sync
	isync

	lis	4,LED_ADDR@@ha
	addi	4,4,LED_ADDR@@l
	li	7,0
	ori	3,3,0x2000
	sthbrx	3,7,4

	sync
	mtmsr	5
	isync
	lwz	4,8(1)
	lwz	5,12(1)
	lwz	6,16(1)
	lwz	7,20(1)

	lwz	0,36(1)
	mtlr	0
	addi	1,1,32
	blr

d115 2
a116 1
	andi.	3,3,~PSL_EE@@l		/* disable interrupts while manipulating runque */
d175 3
a177 2
	xor	31,31,31
	stw	31,_C_LABEL(curproc)@@l(3) /* Zero to not accumulate cpu time */
d181 1
a181 1
	xor	3,3,3
d215 1
a215 1
	stw	9,_C_LABEL(whichqs)@@l(8)		/* mark it empty */
d218 2
a219 1
	xor	3,3,3
d221 1
a221 1
	stw	3,_C_LABEL(want_resched)@@l(4)	/* just did this resched thing */
d247 1
d249 1
a249 1
	andi.	3,3,~PSL_EE@@l		/* disable interrupts while actually switching */
d257 2
d260 1
a260 1
	stwu	5,_C_LABEL(curpm)@@l(6)		/* save real pmap pointer for spill fill */
d293 1
a293 1
	mr	3,30			/* get curproc for special fork returns */
d320 1
a320 2
 * (except ISI/DSI, ALI, the interrupts, and possibly the debugging traps
 * when using IPKDB).
d331 2
a332 1
/* Test whether we already had PR set */
d355 2
a356 1
/* Test whether we already had PR set */
d381 1
d408 1
d424 1
d440 1
d660 1
a660 1
	lis	1,0xa00			/* indicate protection violation on store */
a712 20
#if NIPKDB > 0
#define	ipkdbsave	0xde0		/* primary save area for IPKDB */
/*
 * In case of IPKDB we want a separate trap catcher for it
 */
.lcomm	ipkdbstk,INTSTK			/* ipkdb stack */

	.globl	_C_LABEL(ipkdblow),_C_LABEL(ipkdbsize)
	.type	_C_LABEL(ipkdblow),@@function
	.type	_C_LABEL(ipkdbsize),@@object
_C_LABEL(ipkdblow):
	mtsprg	1,1			/* save SP */
	stmw	28,ipkdbsave(0)		/* free r28-r31 */
	lis	1,ipkdbstk+INTSTK@@ha	/* get new SP */
	addi	1,1,ipkdbstk+INTSTK@@l
	mflr	28
	mfcr	29
	bla	ipkdbtrap
_C_LABEL(ipkdbsize) =	.-_C_LABEL(ipkdblow)
#endif	/* NIPKDB > 0 */
d812 1
a812 1
/* Test whether we already had PR set */
d815 2
a816 1
	mfsprg	1,1			/* restore SP (might have been overwritten) */
d832 4
a835 1
	ori	7,7,(PSL_EE|PSL_ME|PSL_RI)
d880 1
a880 1
	mfdsisr	31			/* test whether this may be a spill fault */
d935 1
a935 1
	mfsrr1	31			/* test whether this may be a spill fault */
a1086 126
#ifdef DDB
/*
 * Deliberate entry to ddbtrap
 */
        .globl        _C_LABEL(ddb_trap)
_C_LABEL(ddb_trap):
        mtsprg        1,1
        mfmsr        3
        mtsrr1        3
        andi.        3,3,~(PSL_EE|PSL_ME)@@l
        mtmsr        3                        /* disable interrupts */
        isync
        stmw        28,ddbsave(0)
        mflr        28
        li        29,EXC_BPT
        mtlr        29
        mfcr        29
        mtsrr0        28

/*
 * Now the ddb trap catching code.
 */
ddbtrap:
        FRAME_SETUP(ddbsave)
/* Call C trap code: */
        addi        3,1,8
        bl        _C_LABEL(ddb_trap_glue)
        or.        3,3,3
        bne        ddbleave
/* This wasn't for DDB, so switch to real trap: */
        lwz        3,FRAME_EXC+8(1)        /* save exception */
        stw        3,ddbsave+8(0)
        FRAME_LEAVE(ddbsave)
        mtsprg        1,1                        /* prepare for entrance to realtrap */
        stmw        28,tempsave(0)
        mflr        28
        mfcr        29
        lwz        31,ddbsave+8(0)
        mtlr        31
        b        realtrap
ddbleave:
        FRAME_LEAVE(ddbsave)
        rfi
#endif /* DDB */

#if NIPKDB > 0
/*
 * Deliberate entry to ipkdbtrap
 */
	.globl	_C_LABEL(ipkdb_trap)
	.type	_C_LABEL(ipkdb_trap),@@function
_C_LABEL(ipkdb_trap):
	
	mtsprg	2,2
	mfmsr	3
	mtsrr1	3
	andi.	3,3,~(PSL_EE|PSL_ME)@@l
	mtmsr	3			/* disable interrupts */
	isync
	stmw	28,ipkdbsave(0)
	mflr	28
	li	29,EXC_BPT
	mtlr	29
	mfcr	29
	mtsrr0	28

/*
 * Now the ipkdb trap catching code.
 */
ipkdbtrap:
	FRAME_SETUP(ipkdbsave)
/* Call C trap code: */
	addi	3,1,8
	bl	_C_LABEL(ipkdb_trap_glue)
	or.	3,3,3
	bne	ipkdbleave
/* This wasn't for IPKDB, so switch to real trap: */
	lwz	3,FRAME_EXC+8(1)	/* save exception */
	stw	3,ipkdbsave+8(0)
	FRAME_LEAVE(ipkdbsave)
	mtsprg	1,1			/* prepare for entrance to realtrap */
	stmw	28,tempsave(0)
	mflr	28
	mfcr	29
	lwz	31,ipkdbsave+8(0)
	mtlr	31
	b	realtrap
ipkdbleave:
	FRAME_LEAVE(ipkdbsave)
	rfi

ipkdbfault:
	ba	_C_LABEL(ipkdbfault)
_C_LABEL(ipkdbfault):
	mfsrr0	3
	addi	3,3,4
	mtsrr0	3
	li	3,-1
	rfi

/*
 * int ipkdbfbyte(unsigned char *p)
 */
	.globl	_C_LABEL(ipkdbfbyte)
	.type	_C_LABEL(ipkdbfbyte),@@function
_C_LABEL(ipkdbfbyte):
	li	9,EXC_DSI		/* establish new fault routine */
	lwz	5,0(9)
	lis	6,ipkdbfault@@ha
	lwz	6,ipkdbfault@@l(6)
	stw	6,0(9)
#ifdef	IPKDBUSERHACK
	lis	8,_C_LABEL(ipkdbsr)@@ha
	lwz	8,_C_LABEL(ipkdbsr)@@l(8)
	mtsr	USER_SR,8
	isync
#endif
	dcbst	0,9			/* flush data... */
	sync
	icbi	0,9			/* and instruction caches */
	lbz	3,0(3)			/* fetch data */
	stw	5,0(9)			/* restore previous fault handler */
	dcbst	0,9			/* and flush data... */
	sync
	icbi	0,9			/* and instruction caches */
	blr
a1088 33
 * int ipkdbsbyte(unsigned char *p, int c)
 */
	.globl	_C_LABEL(ipkdbsbyte)
	.type	_C_LABEL(ipkdbsbyte),@@function
_C_LABEL(ipkdbsbyte):
	li	9,EXC_DSI		/* establish new fault routine */
	lwz	5,0(9)
	lis	6,ipkdbfault@@ha
	lwz	6,ipkdbfault@@l(6)
	stw	6,0(9)
#ifdef	IPKDBUSERHACK
	lis	8,_C_LABEL(ipkdbsr)@@ha
	lwz	8,_C_LABEL(ipkdbsr)@@l(8)
	mtsr	USER_SR,8
	isync
#endif
	dcbst	0,9			/* flush data... */
	sync
	icbi	0,9			/* and instruction caches */
	mr	6,3
	xor	3,3,3
	stb	4,0(6)
	dcbst	0,6			/* Now do appropriate flushes to data... */
	sync
	icbi	0,6			/* and instruction caches */
	stw	5,0(9)			/* restore previous fault handler */
	dcbst	0,9			/* and flush data... */
	sync
	icbi	0,9			/* and instruction caches */	
	blr
#endif	/* NIPKDB > 0 */
	
/*
d1109 1
a1109 1
	xor	3,3,3
d1157 1
d1183 1
d1185 46
@


1.2
log
@Switch mvmeppc to the current powerpc pmap scheme.
Only compile-tested so far, since the VME rack is not in the room yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.1 2001/06/26 21:57:54 smurph Exp $	*/
d955 1
d1010 1
@


1.1
log
@Initial import of mvmeppc.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.13 2000/06/30 02:37:21 rahnds Exp $	*/
d948 2
d953 2
d956 2
a957 2
	bl	_C_LABEL(pte_spill)		/* try a spill */
	or.	3,3,3
d1007 2
@


1.1.2.1
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a947 2
	mfxer	30			/* save XER */
	mtsprg	2,30
a950 3
	mfsrr1	4
	mfdsisr	5
	li	6, 0
d952 2
a953 2
	bl	_C_LABEL(pte_spill_r)	/* try a spill */
	cmpwi	0,3,0
a1002 3
	mfsrr1	4
	li	5, 0
	li	6, 1
@


1.1.2.2
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d35 2
d58 4
d67 1
a67 2
/*
 * Arguments to start for mvmeppc
d69 2
a70 2
 * r3 - boot flags
 * r4 - boot device
d72 2
a73 2
 * r6 - arg list (NULL)
 * r7 - length (0)
a82 6
	/* save boot device and flags */
	lis	%r9, _C_LABEL(boothowto)@@ha
	stw	%r3, _C_LABEL(boothowto)@@l(%r9)
	lis	%r9, _C_LABEL(bootdev)@@ha
	stw	%r4, _C_LABEL(bootdev)@@l(%r9)

d87 1
a87 1
#else
d101 1
a101 1
	li	0,0
d103 4
d113 40
a152 1
	b	_C_LABEL(PPC1_exit)
d160 1
a160 2
	/* disable interrupts while manipulating runque */
	andi.	3,3,~PSL_EE@@l
d168 1
a168 1

d178 1
a178 1

d203 1
a203 1

d219 2
a220 3
	li	31,0
	/* Zero to not accumulate cpu time */
	stw	31,_C_LABEL(curproc)@@l(3)
d224 1
a224 1
	li	3,0
d246 1
a246 1

d258 1
a258 1
	stw	9,_C_LABEL(whichqs)@@l(8)	/* mark it empty */
d261 1
a261 2
	/* just did this resched thing */
	li	3,0
d263 1
a263 1
	stw	3,_C_LABEL(want_resched)@@l(4)
a288 1
	/* disable interrupts while actually switching */
d290 1
a290 1
	andi.	3,3,~PSL_EE@@l
a297 2

	/* save real pmap pointer for spill fill */
d299 1
a299 1
	stwu	5,_C_LABEL(curpm)@@l(6)
d332 1
a332 1
	mr	3,30			/* curproc for special fork returns */
d359 2
a360 1
 * except ISI/DSI, ALI, the interrupts
d371 1
a371 2

	/* Test whether we already had PR set */
d394 1
a394 2

	/* Test whether we already had PR set */
a418 1
#if 0
a444 1
#endif
a459 1
#if 0
a474 1
#endif
d694 1
a694 1
	lis	1,0xa00		/* indicate protection violation on store */
d747 20
d866 1
a866 1
	/* Test whether we already had PR set */
d869 1
a869 2
	/* restore SP (might have been overwritten) */
	mfsprg	1,1
d885 1
a885 4
	mfsrr1	%r31
	andi.	%r31,%r31,PSL_EE	/* restore EE from previous context */
	or	%r7,%r7,%r31
	ori	7,7,(PSL_ME|PSL_RI)
d930 1
a930 1
	mfdsisr	31			/* test if this is spill fault */
d985 1
a985 1
	mfsrr1	31			/* test if this may be a spill fault */
d1137 18
d1157 141
d1318 1
a1318 1
	li	%r3,0
d1365 1
a1365 2
	.string "clock"
	.string	"stat"
a1390 1
	.long 0
a1391 46

#ifdef DDB
/*
 * Deliberate entry to ddbtrap
 */
        .globl        _C_LABEL(ddb_trap)
_C_LABEL(ddb_trap):
        mtsprg        1,1
        mfmsr        3
        mtsrr1        3
        andi.        3,3,~(PSL_EE|PSL_ME)@@l
        mtmsr        3                        /* disable interrupts */
        isync
        stmw        28,ddbsave(0)
        mflr        28
        li        29,EXC_BPT
        mtlr        29
        mfcr        29
        mtsrr0        28

/*
 * Now the ddb trap catching code.
 */
ddbtrap:
        FRAME_SETUP(ddbsave)
/* Call C trap code: */
        addi        3,1,8
        bl        _C_LABEL(ddb_trap_glue)
        or.        3,3,3
        bne        ddbleave
/* This wasn't for DDB, so switch to real trap: */
        lwz        3,FRAME_EXC+8(1)        /* save exception */
        stw        3,ddbsave+8(0)
        FRAME_LEAVE(ddbsave)
        mtsprg        1,1		/* prepare for entrance to realtrap */
        stmw        28,tempsave(0)
        mflr        28
        mfcr        29
        lwz        31,ddbsave+8(0)
        mtlr        31
        b        realtrap
ddbleave:
        FRAME_LEAVE(ddbsave)
        rfi
#endif /* DDB */

@


1.1.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.1 2001/06/26 21:57:54 smurph Exp $	*/
a947 2
	mfxer	30			/* save XER */
	mtsprg	2,30
a950 2
	mfsrr1	4
	mfdsisr	5
d952 2
a953 2
	bl	_C_LABEL(pte_spill_r)	/* try a spill */
	cmpwi	0,3,0
a1002 2
	mfsrr1	4
	li	5, 0
@


1.1.6.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.1.6.1 2002/06/11 03:37:22 art Exp $	*/
a954 1
	li	6, 0
a1008 1
	li	6, 1
@


