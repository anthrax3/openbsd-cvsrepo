head	1.19;
access;
symbols
	OPENBSD_4_9:1.18.0.14
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.18.0.12
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.18.0.8
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.18.0.10
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.18.0.6
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.18.0.4
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.18.0.2
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.16.0.8
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.16.0.6
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.16.0.4
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.16.0.2
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.15.0.4
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.15.0.2
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.14.0.4
	OPENBSD_3_6_BASE:1.14
	SMP_SYNC_A:1.14
	SMP_SYNC_B:1.14
	OPENBSD_3_5:1.14.0.2
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.9.0.6
	OPENBSD_3_4_BASE:1.9
	UBC_SYNC_A:1.9
	OPENBSD_3_3:1.9.0.4
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.2
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	UBC_SYNC_B:1.9
	UBC:1.4.0.2
	UBC_BASE:1.4
	OPENBSD_3_0:1.2.0.2
	OPENBSD_3_0_BASE:1.2
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.19
date	2011.07.07.19.16.43;	author deraadt;	state dead;
branches;
next	1.18;

1.18
date	2008.01.23.16.37.57;	author jsing;	state Exp;
branches;
next	1.17;

1.17
date	2007.11.04.13.43.39;	author martin;	state Exp;
branches;
next	1.16;

1.16
date	2005.12.17.07.31.26;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2004.11.17.20.24.44;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2004.01.29.10.58.08;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2004.01.28.23.50.19;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2004.01.26.20.38.53;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2004.01.25.21.41.31;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2004.01.24.22.15.58;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2002.06.12.03.49.59;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2002.06.08.15.50.00;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2002.06.07.01.01.40;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2002.03.14.03.15.58;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.03.14.01.26.41;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.11.06.22.46.00;	author miod;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2001.11.06.19.53.15;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2001.09.11.20.05.24;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2001.06.26.21.57.54;	author smurph;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2001.10.31.03.01.21;	author nate;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2001.11.13.21.04.15;	author niklas;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2002.03.28.10.36.04;	author niklas;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2003.03.27.23.52.17;	author niklas;	state Exp;
branches;
next	1.1.2.5;

1.1.2.5
date	2004.02.19.10.49.10;	author niklas;	state Exp;
branches;
next	;

1.4.2.1
date	2002.06.11.03.37.23;	author art;	state Exp;
branches;
next	1.4.2.2;

1.4.2.2
date	2002.10.29.00.28.08;	author art;	state Exp;
branches;
next	;


desc
@@


1.19
log
@remove mvmeppc; it is really rough shape.  ok drahn miod
@
text
@/*	$OpenBSD: ppc1_machdep.c,v 1.18 2008/01/23 16:37:57 jsing Exp $	*/
/*	$NetBSD: ofw_machdep.c,v 1.1 1996/09/30 16:34:50 ws Exp $	*/

/*
 * Copyright (C) 1996 Wolfgang Solfrank.
 * Copyright (C) 1996 TooLs GmbH.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by TooLs GmbH.
 * 4. The name of TooLs GmbH may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY TOOLS GMBH ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL TOOLS GMBH BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
#include <sys/param.h>
#include <sys/conf.h>
#include <sys/extent.h>
#include <sys/systm.h>

#include <uvm/uvm_extern.h>

#include <machine/powerpc.h>
#include <machine/autoconf.h>
#include <machine/bugio.h>

#include <mvmeppc/dev/nvramreg.h>
#include <mvmeppc/dev/ravenreg.h>

#include <dev/cons.h>

void PPC1_exit(void) __attribute__((__noreturn__));
void PPC1_boot(char *bootspec) __attribute__((__noreturn__));
void PPC1_mem_regions(struct mem_region **memp, struct mem_region **availp);
void PPC1_vmon(void);

unsigned char PPC1_nvram_rd(unsigned long offset);
void PPC1_nvram_wr(unsigned long offset, unsigned char val);
unsigned long PPC1_tps(void);

int PPC1_clock_read(int *sec, int *min, int *hour, int *day, int *mon, int *yr);
int PPC1_clock_write(int sec, int min, int hour, int day, int mon, int yr);

vsize_t size_memory(void);

struct firmware ppc1_firmware = {
	PPC1_mem_regions,
	PPC1_exit,
	PPC1_boot,
	PPC1_vmon,
#ifdef FW_HAS_PUTC
	mvmeprom_outchar,
#endif
};

#define	PPC1_REGIONS	32
struct mem_region PPC1mem[PPC1_REGIONS + 1], PPC1avail[PPC1_REGIONS + 3];

/*
 * 1 - Figure and find the end of local memory. This is now a Bug call.  
 *     This requires that the correct amount of local memory be entered 
 *     in the Bug environment.  (see: Bug ENV command.)
 * 2 - Start looking from the megabyte after the end of the kernel data,
 *     until we find non-memory to figure the total memory available.
 * 3 - Initialize from the end of local memory to the end of total 
 *     memory.  (As required by some VME memory boards) - smurph
 */
#define MAXPHYSMEM	0x10000000	/* max physical memory */

vsize_t
size_memory(void)
{
	volatile unsigned int *look;
	unsigned int *max;
	extern char *end;
	vsize_t total_mem;
#ifdef USE_BUG
	vsize_t local_mem;
#endif

#ifdef USE_BUG
	bugenvrd();	/* read the bug environment */
	local_mem = (vsize_t)bug_localmemsize();
#endif 
#define PATTERN   0x5a5a5a5a
#define STRIDE    (4*1024) 	/* 4k at a time */
#define Roundup(value, stride) (((unsigned)(value) + (stride) - 1) & ~((stride)-1))
	/*
	 * count it up.
	 */
	max = (void *)MAXPHYSMEM;
	for (look = (void *)Roundup(&end, STRIDE); look < max;
		 look = (int *)((unsigned)look + STRIDE)) {
		unsigned save;

		/* if can't access, we've reached the end */
		if (badaddr((char *)look, 4)) {
#if defined(DEBUG)
			printf("%x\n", look);
#endif
			look = (int *)((int)look - STRIDE);
			break;
		}

		/*
		 * If we write a value, we expect to read the same value back.
		 * We'll do this twice, the 2nd time with the opposite bit
		 * pattern from the first, to make sure we check all bits.
		 */
		save = *look;
		if (*look = PATTERN, *look != PATTERN)
			break;
		if (*look = ~PATTERN, *look != ~PATTERN)
			break;
		*look = save;
	}
	physmem = atop(trunc_page((unsigned)look)); /* in pages */
	total_mem = trunc_page((unsigned)look);
#ifdef USE_BUG
	/* Initialize the off-board (non-local) memory. */
	printf("Initializing %d bytes of off-board memory.\n", total_mem - local_mem);
	bzero((void *)local_mem, total_mem - local_mem);
#endif
	return (total_mem);
}

/*
 * This is called during initppc, before the system is really initialized.
 * It shall provide the total and the available regions of RAM.
 * Both lists must have a zero-size entry as terminator.
 * The available regions need not take the kernel into account, but needs
 * to provide space for two additional entry beyond the terminating one.
 */
void
PPC1_mem_regions(memp, availp)
	struct mem_region **memp, **availp;
{
	extern char *start;

	/*
	 * Get memory.
	 */
	PPC1mem[0].start = 0;
	PPC1mem[0].size = size_memory();

	/*
	 * PPC1Bug manual states that the BUG uses ``about 768KB'' at the
	 * top at the physical memory, but then only shows 512KB in the
	 * example!
	 * Reserve 1MB to be on the safe side.
	 *
	 * We also need to reserve space below kernelstart, if only because
	 * the trap vectors lie there.
	 */
	PPC1avail[0].start = (u_long)&start;
	PPC1avail[0].size = PPC1mem[0].size - 1024 * 1024 - PPC1avail[0].start;

	*memp = PPC1mem;
	*availp = PPC1avail;
}

void
PPC1_vmon()
{
	/*
	 * Now is a good time to setup the clock callbacks, though this
	 * could have been done earlier...
	 */
	clock_read = PPC1_clock_read;
	clock_write = PPC1_clock_write;
	tps = PPC1_tps;
}

void
PPC1_exit()
{
	mvmeprom_return();
	for (;;) ;
}

void
PPC1_boot(bootspec)
	char *bootspec;
{
	u_int32_t msr, i = 10000;

	/* set exception prefix high - to the prom */
	msr = ppc_mfmsr();
	msr |= PSL_IP;
	ppc_mtmsr(msr);

	/* make sure bit 0 (reset) is a 0 */
	outb(0x80000092, inb(0x80000092) & ~1L);
	/* signal a reset to system control port A - soft reset */
	outb(0x80000092, inb(0x92) | 1);

	while (i != 0) i++;
	panic("restart failed");
	mvmeprom_return();
	printf("PPC1_boot returned!");		/* just in case */
	for (;;) ;
}

/*
 * Clock and NVRAM functions
 *
 * This needs to become a real device, but it needs to be mapped early
 * because we need to setup the clocks before autoconf.
 */

vaddr_t	isaspace_va;

void
nvram_map()
{
	int error;
	extern struct extent *devio_ex;
	extern int ppc_malloc_ok;

	if ((error = extent_alloc_region(devio_ex, RAVEN_P_ISA_IO_SPACE,
	    ISA_SIZE, EX_NOWAIT | (ppc_malloc_ok ? EX_MALLOCOK : 0))) != 0)
		panic("nvram_map: can't map ISA space, extent error %d", error);

	if ((isaspace_va = (vaddr_t)mapiodev(RAVEN_P_ISA_IO_SPACE,
	    ISA_SIZE)) == NULL)
		panic("nvram_map: map failed");
}

unsigned char
PPC1_nvram_rd(addr)
	unsigned long addr;
{
	outb(isaspace_va + NVRAM_S0, addr);
	outb(isaspace_va + NVRAM_S1, addr>>8);
	return inb(isaspace_va + NVRAM_DATA);
}

void
PPC1_nvram_wr(addr, val)
	unsigned long addr; 
	unsigned char val;
{
	outb(isaspace_va + NVRAM_S0, addr);
	outb(isaspace_va + NVRAM_S1, addr>>8);
	outb(isaspace_va + NVRAM_DATA, val);
}

/* Function to get ticks per second. */
unsigned long
PPC1_tps()
{
	unsigned long start_val, ticks;
	unsigned char val, sec;

	/* Start RTC */
	val = PPC1_nvram_rd(RTC_CONTROLB);
	PPC1_nvram_wr(RTC_CONTROLA, (val & (~RTC_CB_STOP)));
	val = PPC1_nvram_rd(RTC_CONTROLA);
	PPC1_nvram_wr(RTC_CONTROLA, (val & (~RTC_CA_READ)));

	/* look at seconds. */
	sec = PPC1_nvram_rd(RTC_SECONDS);
	for (;;) {
		if (PPC1_nvram_rd(RTC_SECONDS) != sec)
			break;
	}

	start_val = ppc_mfdec();

	/* wait until it changes. */
	sec = PPC1_nvram_rd(RTC_SECONDS);
	for (;;) {
		if (PPC1_nvram_rd(RTC_SECONDS) != sec)
			break;
	}
	ticks = start_val - ppc_mfdec();
	return (ticks);
}

int
PPC1_clock_write(int sec, int min, int hour, int day, int mon, int yr)
{
	unsigned char val;

	/* write command */
	val = PPC1_nvram_rd(RTC_CONTROLA);
	PPC1_nvram_wr(RTC_CONTROLA, (val | RTC_CA_WRITE));

	PPC1_nvram_wr(RTC_SECONDS, sec);
	PPC1_nvram_wr(RTC_MINUTES, min);
	PPC1_nvram_wr(RTC_HOURS, hour);
	PPC1_nvram_wr(RTC_MONTH, mon);
	PPC1_nvram_wr(RTC_DAY_OF_MONTH, day);
	PPC1_nvram_wr(RTC_YEAR, yr);

	/* cancel write */
	PPC1_nvram_wr(RTC_CONTROLA, val);

	return 0;
}

int
PPC1_clock_read(int *sec, int *min, int *hour, int *day, int *mon, int *yr)
{
	unsigned char val;
	int i;

	/* Is there time? */
	val = PPC1_nvram_rd(RTC_CONTROLB);
	PPC1_nvram_wr(RTC_CONTROLA, (val & (~RTC_CB_STOP)));
	val = PPC1_nvram_rd(RTC_CONTROLA);
	val &= ~RTC_CA_READ;
	PPC1_nvram_wr(RTC_CONTROLA, val);

	/* Read the seconds value. */
	*sec = PPC1_nvram_rd(RTC_SECONDS);

	/* Wait for a new second. */
	for (i = 0 ; i < 1000000 ; i++) { 
		if (PPC1_nvram_rd(RTC_SECONDS) != *sec) {
			break;
		}
	}

	/* stop time. */
	PPC1_nvram_wr(RTC_CONTROLA, (val | RTC_CA_READ));

	*sec = PPC1_nvram_rd(RTC_SECONDS);
	*min = PPC1_nvram_rd(RTC_MINUTES);
	*hour = PPC1_nvram_rd(RTC_HOURS);
	*day = PPC1_nvram_rd(RTC_DAY_OF_MONTH);
	*mon = PPC1_nvram_rd(RTC_MONTH);
	*yr = PPC1_nvram_rd(RTC_YEAR);

	/* restart time. */
	PPC1_nvram_wr(RTC_CONTROLA, val);
	return 0;
}

/*
 * Boot console routines: 
 * Enables printing of boot messages before consinit().
 */
cons_decl(boot);

void
bootcnprobe(struct consdev *cp)
{
	cp->cn_dev = makedev(14, 0);
	cp->cn_pri = CN_LOWPRI;
}

void
bootcninit(struct consdev *cp)
{
	/* Nothing to do */
}

int
bootcngetc(dev_t dev)
{
	return (mvmeprom_getchar());
}

void
bootcnputc(dev_t dev, int c)
{
	mvmeprom_outchar(c);
}
@


1.18
log
@Cleanup cn_pri. Change constants to more meaningful names, rather than
the hp300 related ones currently in use. CN_NORMAL becomes CN_LOWPRI,
CN_INTERNAL becomes CN_MIDPRI and CN_REMOTE becomes CN_HIGHPRI.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ppc1_machdep.c,v 1.17 2007/11/04 13:43:39 martin Exp $	*/
@


1.17
log
@replace even more ctob/btoc with ptoa/atop
@
text
@d1 1
a1 1
/*	$OpenBSD: ppc1_machdep.c,v 1.16 2005/12/17 07:31:26 miod Exp $	*/
d368 1
a368 1
	cp->cn_pri = CN_NORMAL;
@


1.16
log
@Get rid of deprecated vm_{offset,size}_t types for good, use {p,v}{addr,size}_t
instead; looked at millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ppc1_machdep.c,v 1.15 2004/11/17 20:24:44 miod Exp $	*/
d135 1
a135 1
	physmem = btoc(trunc_page((unsigned)look)); /* in pages */
@


1.15
log
@Correct *cnputc() prototypes.
@
text
@d1 1
a1 1
/*	$OpenBSD: ppc1_machdep.c,v 1.14 2004/01/29 10:58:08 miod Exp $	*/
d62 1
a62 1
vm_offset_t size_memory(void);
d88 1
a88 1
vm_offset_t
d94 1
a94 1
	vm_offset_t total_mem;
d96 1
a96 1
	vm_offset_t local_mem;
d101 1
a101 1
	local_mem = (vm_offset_t)bug_localmemsize();
@


1.14
log
@Map the raven, pcic, and isa/pci io space virtual rather than 1:1.
@
text
@d1 1
a1 1
/*	$OpenBSD: ppc1_machdep.c,v 1.13 2004/01/28 23:50:19 miod Exp $	*/
d54 1
d365 1
a365 2
bootcnprobe(cp)
	struct consdev *cp;
d372 1
a372 2
bootcninit(cp)
	struct consdev *cp;
d378 1
a378 2
bootcngetc(dev)
	dev_t dev;
d384 1
a384 3
bootcnputc(dev, c)
	dev_t dev;
	char c;
@


1.13
log
@More clock handling cleanup:
- move clock callbacks outside the firmware structure
- map the clock virtual. A bit tricky because it needs to be mapped before
  autoconf...
- compensate for the removal of 1:1 segment 8 mapping
@
text
@d1 1
a1 1
/*	$OpenBSD: ppc1_machdep.c,v 1.12 2004/01/26 20:38:53 miod Exp $	*/
d44 1
d46 1
d228 1
a228 1
vaddr_t	nvram_va;
d237 3
a239 3
	if ((error = extent_alloc_region(devio_ex, NVRAM_PA, NVRAM_SIZE,
	    EX_NOWAIT | (ppc_malloc_ok ? EX_MALLOCOK : 0))) != 0)
		panic("nvram_map: can't map NVRAM, extent error %d", error);
d241 2
a242 1
	if ((nvram_va = (vaddr_t)mapiodev(NVRAM_PA, NVRAM_SIZE)) == NULL)
d250 3
a252 3
	outb(nvram_va + NVRAM_S0, addr);
	outb(nvram_va + NVRAM_S1, addr>>8);
	return inb(nvram_va + NVRAM_DATA);
d260 3
a262 3
	outb(nvram_va + NVRAM_S0, addr);
	outb(nvram_va + NVRAM_S1, addr>>8);
	outb(nvram_va + NVRAM_DATA, val);
@


1.12
log
@Make sure, when reporting available memory to the common PowerPC code, to
neither stomp over the BUG nor precioussssss data...
@
text
@d1 1
a1 1
/*	$OpenBSD: ppc1_machdep.c,v 1.11 2004/01/25 21:41:31 miod Exp $	*/
a34 1
#include <sys/buf.h>
d36 1
a36 7
#include <sys/device.h>
#include <sys/disk.h>
#include <sys/disklabel.h>
#include <sys/fcntl.h>
#include <sys/ioctl.h>
#include <sys/malloc.h>
#include <sys/stat.h>
d56 2
a57 4
int PPC1_clock_read(int *sec, int *min, int *hour, int *day,
								 int *mon, int *yr);
int PPC1_clock_write(int sec, int min, int hour, int day,
								  int mon, int yr);
a65 7
	PPC1_nvram_rd,
	PPC1_nvram_wr,
	PPC1_tps,
	PPC1_clock_read,
	PPC1_clock_write,
	NULL,
	NULL,
d67 1
a67 1
	mvmeprom_outchar;
d180 7
a192 1
	panic("PPC1_exit returned!");		/* just in case */
d195 1
d219 24
d247 3
a249 3
	outb(NVRAM_S0, addr);
	outb(NVRAM_S1, addr>>8);
	return inb(NVRAM_DATA);
d257 3
a259 3
	outb(NVRAM_S0, addr);
	outb(NVRAM_S1, addr>>8);
	outb(NVRAM_DATA, val);
d282 1
a282 1
	start_val = ppc_get_spr(SPR_DEC);
d290 1
a290 1
	ticks = start_val - ppc_get_spr(SPR_DEC);
@


1.11
log
@Get rid of ppc_[gs]et_msr(), use ppc_m[ft]msr() instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: ppc1_machdep.c,v 1.10 2004/01/24 22:15:58 miod Exp $	*/
d169 2
a170 2
	bzero(&PPC1mem[0], sizeof(struct mem_region) * PPC1_REGIONS);
	bzero(&PPC1avail[0], sizeof(struct mem_region) * PPC1_REGIONS);
d177 11
a187 1
	PPC1avail[0] = PPC1mem[0];
@


1.10
log
@Correctly size physical memory.
@
text
@d1 1
a1 1
/*	$OpenBSD: ppc1_machdep.c,v 1.9 2002/06/12 03:49:59 miod Exp $	*/
d88 1
a88 1
static struct mem_region PPC1mem[PPC1_REGIONS + 1], PPC1avail[PPC1_REGIONS + 3];
d202 1
a202 1
	msr = ppc_get_msr();
d204 1
a204 1
	ppc_set_msr(msr);
@


1.9
log
@cnputc() will take care of the necessary cr->cr/lf translation, so don't
do it in those consoles either.
@
text
@d1 1
a1 1
/*	$OpenBSD: ppc1_machdep.c,v 1.8 2002/06/08 15:50:00 miod Exp $	*/
d123 1
a123 1
	for (look = (void *)Roundup(end, STRIDE); look < max;
a147 1
look = (unsigned int *)0x03f00000;	/* XXX */
@


1.8
log
@Strict prototypes, and some KNF touches while there.
@
text
@d1 1
a1 1
/*	$OpenBSD: ppc1_machdep.c,v 1.7 2002/06/07 01:01:40 miod Exp $	*/
a362 2
	if (c == '\n')
		mvmeprom_outchar('\r');
@


1.7
log
@Switch mvmeppc to the current powerpc pmap scheme.
Only compile-tested so far, since the VME rack is not in the room yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: ppc1_machdep.c,v 1.6 2002/03/14 03:15:58 millert Exp $	*/
d50 1
a50 1
#include <machine/prom.h>
d68 2
d148 1
a148 1
	look = (unsigned int *)0x02000000;
d193 2
a194 2
	panic ("PPC1_exit returned!");		/* just in case */
	while (1);
d198 1
a198 1
char *bootspec;
d212 2
a213 2
	while ( i != 0 ) i++;
	panic("restart failed\n");
d215 2
a216 2
	printf ("PPC1_boot returned!");		/* just in case */
	while (1);
d219 3
a221 2
unsigned char PPC1_nvram_rd(addr)
unsigned long addr;
d228 4
a231 3
void PPC1_nvram_wr(addr, val)
unsigned long addr; 
unsigned char val;
d239 2
a240 2

unsigned long PPC1_tps(void)
d253 1
a253 1
	while (1) {
d262 1
a262 1
	while (1) {
d270 2
a271 2
int PPC1_clock_write(int sec, int min, int hour, int day,
							int mon, int yr)
d292 2
a293 2
int PPC1_clock_read(int *sec, int *min, int *hour, int *day,
						  int *mon, int *yr)
d334 3
a336 1
int
d338 1
a338 1
struct consdev *cp;
a341 1
	return (1);
d344 1
a344 1
int
d346 1
a346 1
struct consdev *cp;
a348 1
	return (1);
d353 1
a353 1
dev_t dev;
d360 2
a361 2
dev_t dev;
char c;
a366 1

@


1.6
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: ppc1_machdep.c,v 1.5 2002/03/14 01:26:41 millert Exp $	*/
d166 1
a166 1
struct mem_region **memp, **availp;
a167 2
	extern int avail_start;

d176 1
a176 2
	PPC1avail[0].start = avail_start;
	PPC1avail[0].size = (PPC1mem[0].size - avail_start);
@


1.5
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: ppc1_machdep.c,v 1.4 2001/11/06 22:46:00 miod Exp $	*/
d120 3
a122 3
	max = (void*)MAXPHYSMEM;
	for (look = (void*)Roundup(end, STRIDE); look < max;
		 look = (int*)((unsigned)look + STRIDE)) {
@


1.4
log
@-Wall -Werror cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: ppc1_machdep.c,v 1.3 2001/11/06 19:53:15 miod Exp $	*/
d55 12
a66 12
void PPC1_exit __P((void)) __attribute__((__noreturn__));
void PPC1_boot __P((char *bootspec)) __attribute__((__noreturn__));
void PPC1_mem_regions __P((struct mem_region **memp, struct mem_region **availp));
void PPC1_vmon __P((void));
unsigned char PPC1_nvram_rd __P((unsigned long offset));
void PPC1_nvram_wr __P((unsigned long offset, unsigned char val));
unsigned long PPC1_tps __P((void));

int PPC1_clock_read __P((int *sec, int *min, int *hour, int *day,
								 int *mon, int *yr));
int PPC1_clock_write __P((int sec, int min, int hour, int day,
								  int mon, int yr));
@


1.4.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ppc1_machdep.c,v 1.4 2001/11/06 22:46:00 miod Exp $	*/
d50 1
a50 1
#include <machine/bugio.h>
d55 12
a66 14
void PPC1_exit(void) __attribute__((__noreturn__));
void PPC1_boot(char *bootspec) __attribute__((__noreturn__));
void PPC1_mem_regions(struct mem_region **memp, struct mem_region **availp);
void PPC1_vmon(void);
unsigned char PPC1_nvram_rd(unsigned long offset);
void PPC1_nvram_wr(unsigned long offset, unsigned char val);
unsigned long PPC1_tps(void);

int PPC1_clock_read(int *sec, int *min, int *hour, int *day,
								 int *mon, int *yr);
int PPC1_clock_write(int sec, int min, int hour, int day,
								  int mon, int yr);

vm_offset_t size_memory(void);
d120 3
a122 3
	max = (void *)MAXPHYSMEM;
	for (look = (void *)Roundup(end, STRIDE); look < max;
		 look = (int *)((unsigned)look + STRIDE)) {
d146 1
a146 1
look = (unsigned int *)0x03f00000;	/* XXX */
d166 1
a166 1
	struct mem_region **memp, **availp;
d168 2
d178 2
a179 1
	PPC1avail[0] = PPC1mem[0];
d194 2
a195 2
	panic("PPC1_exit returned!");		/* just in case */
	for (;;) ;
d199 1
a199 1
	char *bootspec;
d213 2
a214 2
	while (i != 0) i++;
	panic("restart failed");
d216 2
a217 2
	printf("PPC1_boot returned!");		/* just in case */
	for (;;) ;
d220 2
a221 3
unsigned char
PPC1_nvram_rd(addr)
	unsigned long addr;
d228 3
a230 4
void
PPC1_nvram_wr(addr, val)
	unsigned long addr; 
	unsigned char val;
d238 2
a239 2
unsigned long
PPC1_tps()
d252 1
a252 1
	for (;;) {
d261 1
a261 1
	for (;;) {
d269 2
a270 2
int
PPC1_clock_write(int sec, int min, int hour, int day, int mon, int yr)
d291 2
a292 2
int
PPC1_clock_read(int *sec, int *min, int *hour, int *day, int *mon, int *yr)
d333 1
a333 3
cons_decl(boot);

void
d335 1
a335 1
	struct consdev *cp;
d339 1
d342 1
a342 1
void
d344 1
a344 1
	struct consdev *cp;
d347 1
d352 1
a352 1
	dev_t dev;
d359 2
a360 2
	dev_t dev;
	char c;
d366 1
@


1.4.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ppc1_machdep.c,v 1.4.2.1 2002/06/11 03:37:23 art Exp $	*/
d363 2
@


1.3
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: ppc1_machdep.c,v 1.2 2001/09/11 20:05:24 miod Exp $	*/
d105 5
a109 1
	vm_offset_t local_mem, total_mem;
a167 1
	int phandle, i, j, cnt;
@


1.2
log
@Don't include <vm/vm_kern.h> if you don't need foo_map.
@
text
@d1 1
a1 1
/*	$OpenBSD: ppc1_machdep.c,v 1.1 2001/06/26 21:57:54 smurph Exp $	*/
d46 1
a46 1
#include <vm/vm.h>
@


1.1
log
@Initial import of mvmeppc.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.21 2001/03/03 05:33:47 drahn Exp $	*/
a46 1
#include <vm/vm_kern.h>
@


1.1.2.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: ppc1_machdep.c,v 1.1 2001/06/26 21:57:54 smurph Exp $	*/
d47 1
@


1.1.2.2
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d46 1
a46 1
#include <uvm/uvm_extern.h>
d105 1
a105 5
	vm_offset_t total_mem;
#ifdef USE_BUG
	vm_offset_t local_mem;
#endif

d164 1
@


1.1.2.3
log
@Merge in -current from about a week ago
@
text
@d55 12
a66 12
void PPC1_exit(void) __attribute__((__noreturn__));
void PPC1_boot(char *bootspec) __attribute__((__noreturn__));
void PPC1_mem_regions(struct mem_region **memp, struct mem_region **availp);
void PPC1_vmon(void);
unsigned char PPC1_nvram_rd(unsigned long offset);
void PPC1_nvram_wr(unsigned long offset, unsigned char val);
unsigned long PPC1_tps(void);

int PPC1_clock_read(int *sec, int *min, int *hour, int *day,
								 int *mon, int *yr);
int PPC1_clock_write(int sec, int min, int hour, int day,
								  int mon, int yr);
d120 3
a122 3
	max = (void *)MAXPHYSMEM;
	for (look = (void *)Roundup(end, STRIDE); look < max;
		 look = (int *)((unsigned)look + STRIDE)) {
@


1.1.2.4
log
@Sync the SMP branch with 3.3
@
text
@d50 1
a50 1
#include <machine/bugio.h>
a67 2
vm_offset_t size_memory(void);

d146 1
a146 1
look = (unsigned int *)0x03f00000;	/* XXX */
d166 1
a166 1
	struct mem_region **memp, **availp;
d168 2
d178 2
a179 1
	PPC1avail[0] = PPC1mem[0];
d194 2
a195 2
	panic("PPC1_exit returned!");		/* just in case */
	for (;;) ;
d199 1
a199 1
	char *bootspec;
d213 2
a214 2
	while (i != 0) i++;
	panic("restart failed");
d216 2
a217 2
	printf("PPC1_boot returned!");		/* just in case */
	for (;;) ;
d220 2
a221 3
unsigned char
PPC1_nvram_rd(addr)
	unsigned long addr;
d228 3
a230 4
void
PPC1_nvram_wr(addr, val)
	unsigned long addr; 
	unsigned char val;
d238 2
a239 2
unsigned long
PPC1_tps()
d252 1
a252 1
	for (;;) {
d261 1
a261 1
	for (;;) {
d269 2
a270 2
int
PPC1_clock_write(int sec, int min, int hour, int day, int mon, int yr)
d291 2
a292 2
int
PPC1_clock_read(int *sec, int *min, int *hour, int *day, int *mon, int *yr)
d333 1
a333 3
cons_decl(boot);

void
d335 1
a335 1
	struct consdev *cp;
d339 1
d342 1
a342 1
void
d344 1
a344 1
	struct consdev *cp;
d347 1
d352 1
a352 1
	dev_t dev;
d359 2
a360 2
	dev_t dev;
	char c;
d362 2
d366 1
@


1.1.2.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d35 1
d37 7
a43 1
#include <sys/extent.h>
a50 1

a51 1
#include <mvmeppc/dev/ravenreg.h>
d63 4
a66 2
int PPC1_clock_read(int *sec, int *min, int *hour, int *day, int *mon, int *yr);
int PPC1_clock_write(int sec, int min, int hour, int day, int mon, int yr);
d75 7
d83 1
a83 1
	mvmeprom_outchar,
d88 1
a88 1
struct mem_region PPC1mem[PPC1_REGIONS + 1], PPC1avail[PPC1_REGIONS + 3];
d123 1
a123 1
	for (look = (void *)Roundup(&end, STRIDE); look < max;
d148 1
d170 2
a171 2
	extern char *start;

d178 1
a178 11
	/*
	 * PPC1Bug manual states that the BUG uses ``about 768KB'' at the
	 * top at the physical memory, but then only shows 512KB in the
	 * example!
	 * Reserve 1MB to be on the safe side.
	 *
	 * We also need to reserve space below kernelstart, if only because
	 * the trap vectors lie there.
	 */
	PPC1avail[0].start = (u_long)&start;
	PPC1avail[0].size = PPC1mem[0].size - 1024 * 1024 - PPC1avail[0].start;
a186 7
	/*
	 * Now is a good time to setup the clock callbacks, though this
	 * could have been done earlier...
	 */
	clock_read = PPC1_clock_read;
	clock_write = PPC1_clock_write;
	tps = PPC1_tps;
d193 1
a195 1

d203 1
a203 1
	msr = ppc_mfmsr();
d205 1
a205 1
	ppc_mtmsr(msr);
a218 25
/*
 * Clock and NVRAM functions
 *
 * This needs to become a real device, but it needs to be mapped early
 * because we need to setup the clocks before autoconf.
 */

vaddr_t	isaspace_va;

void
nvram_map()
{
	int error;
	extern struct extent *devio_ex;
	extern int ppc_malloc_ok;

	if ((error = extent_alloc_region(devio_ex, RAVEN_P_ISA_IO_SPACE,
	    ISA_SIZE, EX_NOWAIT | (ppc_malloc_ok ? EX_MALLOCOK : 0))) != 0)
		panic("nvram_map: can't map ISA space, extent error %d", error);

	if ((isaspace_va = (vaddr_t)mapiodev(RAVEN_P_ISA_IO_SPACE,
	    ISA_SIZE)) == NULL)
		panic("nvram_map: map failed");
}

d223 3
a225 3
	outb(isaspace_va + NVRAM_S0, addr);
	outb(isaspace_va + NVRAM_S1, addr>>8);
	return inb(isaspace_va + NVRAM_DATA);
d233 3
a235 3
	outb(isaspace_va + NVRAM_S0, addr);
	outb(isaspace_va + NVRAM_S1, addr>>8);
	outb(isaspace_va + NVRAM_DATA, val);
d258 1
a258 1
	start_val = ppc_mfdec();
d266 1
a266 1
	ticks = start_val - ppc_mfdec();
@


