head	1.19;
access;
symbols
	OPENBSD_5_6:1.18.0.4
	OPENBSD_5_6_BASE:1.18
	OPENBSD_5_5:1.17.0.4
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.16.0.8
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.16.0.6
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.4
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.2
	OPENBSD_5_0:1.11.0.2
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.9.0.2
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.7.0.10
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.6
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.8
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.4
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.2
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.6.0.16
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.14
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.12
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.10
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.6.0.8
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.6
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.4
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.6.0.2
	OPENBSD_3_6_BASE:1.6
	SMP_SYNC_A:1.5
	SMP_SYNC_B:1.5
	OPENBSD_3_5:1.5.0.2
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.4.0.2
	OPENBSD_3_4_BASE:1.4
	UBC_SYNC_A:1.3
	OPENBSD_3_3:1.3.0.6
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.4
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.2
	OPENBSD_3_1_BASE:1.3
	UBC_SYNC_B:1.3
	UBC:1.2.0.6
	UBC_BASE:1.2
	SMP:1.2.0.4
	OPENBSD_3_0:1.2.0.2
	OPENBSD_3_0_BASE:1.2;
locks; strict;
comment	@ * @;


1.19
date	2014.11.22.15.02.28;	author deraadt;	state dead;
branches;
next	1.18;
commitid	rH4FDTIbh81WkVKX;

1.18
date	2014.07.06.12.13.18;	author miod;	state Exp;
branches;
next	1.17;
commitid	90snogpxXf9c8FLl;

1.17
date	2013.09.29.21.30.50;	author jmc;	state Exp;
branches;
next	1.16;

1.16
date	2012.02.12.00.53.10;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2012.02.11.23.48.55;	author krw;	state Exp;
branches;
next	1.14;

1.14
date	2012.01.11.16.15.02;	author jsing;	state Exp;
branches;
next	1.13;

1.13
date	2012.01.01.16.11.13;	author jsing;	state Exp;
branches;
next	1.12;

1.12
date	2011.12.28.13.53.23;	author jsing;	state Exp;
branches;
next	1.11;

1.11
date	2011.04.10.10.06.09;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2011.03.13.00.13.53;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2010.11.20.13.10.42;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2010.11.19.18.11.21;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2008.06.26.05.42.13;	author ray;	state Exp;
branches;
next	1.6;

1.6
date	2004.06.24.16.31.02;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2004.01.11.23.59.22;	author pvalchev;	state Exp;
branches;
next	1.4;

1.4
date	2003.08.25.23.36.46;	author tedu;	state Exp;
branches;
next	1.3;

1.3
date	2002.03.14.01.26.46;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2001.09.06.19.24.47;	author jason;	state Exp;
branches
	1.2.4.1
	1.2.6.1;
next	1.1;

1.1
date	2001.09.06.19.23.43;	author jason;	state Exp;
branches;
next	;

1.2.4.1
date	2001.10.31.03.07.59;	author nate;	state Exp;
branches;
next	1.2.4.2;

1.2.4.2
date	2002.03.28.11.23.52;	author niklas;	state Exp;
branches;
next	1.2.4.3;

1.2.4.3
date	2004.02.19.10.50.01;	author niklas;	state Exp;
branches;
next	;

1.2.6.1
date	2002.06.11.03.38.44;	author art;	state Exp;
branches;
next	;


desc
@@


1.19
log
@Switch to using MI installboot, after a conversation with stsp.  He will
need this soon.
install tested by jsg
@
text
@/*	$OpenBSD: installboot.c,v 1.18 2014/07/06 12:13:18 miod Exp $	*/
/*	$NetBSD: installboot.c,v 1.8 2001/02/19 22:48:59 cgd Exp $ */

/*-
 * Copyright (c) 2012 Joel Sing <jsing@@openbsd.org>
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Paul Kranenburg.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/disklabel.h>
#include <sys/dkio.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <sys/time.h>

#include <dev/biovar.h>
#include <dev/softraidvar.h>

#include <ufs/ffs/fs.h>

#include <err.h>
#include <fcntl.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <util.h>

int	verbose, nowrite;
char	*dev, *blkstore;
size_t	blksize;

static void	usage(void);
int 		main(int, char *[]);
static void	write_bootblk(int);

static int	sr_volume(int, int *, int *);
static void	sr_installboot(int);
static void	sr_install_bootblk(int, int, int);

static void
usage(void)
{
	extern char *__progname;

	fprintf(stderr, "usage: %s [-nv] bootblk device\n", __progname);
	exit(1);
}

int
main(int argc, char *argv[])
{
	char		*blkfile, *realdev;
	int		vol = -1, ndisks = 0, disk;
	int		c, devfd, blkfd;
	struct stat	sb;

	while ((c = getopt(argc, argv, "nv")) != -1) {
		switch (c) {
		case 'n':
			/* Do not actually write the bootblock to disk. */
			nowrite = 1;
			break;
		case 'v':
			/* Chat */
			verbose = 1;
			break;
		default:
			usage();
		}
	}

	if (argc - optind < 2)
		usage();

	blkfile = argv[optind++];
	dev = argv[optind];

	if (verbose)
		printf("bootblk: %s\n", blkfile);

	if ((blkfd = open(blkfile, O_RDONLY)) < 0)
		err(1, "open: %s", blkfile);

	if (fstat(blkfd, &sb) == -1)
		err(1, "fstat: %s", blkfile);
	if (sb.st_size == 0)
		errx(1, "%s is empty", blkfile);

	blksize = howmany(sb.st_size, DEV_BSIZE) * DEV_BSIZE;
	if (blksize > SBSIZE - DEV_BSIZE)
		errx(1, "boot blocks too big");
	if ((blkstore = malloc(blksize)) == NULL)
		err(1, "malloc: %s", blkfile);
	bzero(blkstore, blksize);
	if (read(blkfd, blkstore, sb.st_size) != sb.st_size)
		err(1, "read: %s", blkfile);

	if ((devfd = opendev(dev, (nowrite ? O_RDONLY : O_RDWR),
	    OPENDEV_PART, &realdev)) < 0)
		err(1, "open: %s", realdev);
	if (verbose)
		printf("device: %s\n", realdev);

	if (sr_volume(devfd, &vol, &ndisks)) {

		/* Install boot loader in softraid volume. */
		sr_installboot(devfd);

		/* Install bootblk on each disk that is part of this volume. */
		for (disk = 0; disk < ndisks; disk++)
			sr_install_bootblk(devfd, vol, disk);

	} else {

		/* Write boot blocks to device. */
		write_bootblk(devfd);

	}

	close(devfd);

	return 0;
}

static void
write_bootblk(int devfd)
{
	/*
	 * Write bootblock into the superblock.
	 */

	if (nowrite)
		return;

	if (lseek(devfd, DEV_BSIZE, SEEK_SET) != DEV_BSIZE)
		err(1, "lseek boot block");

	/* Sync filesystems (to clean in-memory superblock?) */
	sync();

	if (write(devfd, blkstore, blksize) != blksize)
		err(1, "write boot block");
}

static int
sr_volume(int devfd, int *vol, int *disks)
{
	struct	bioc_inq bi;
	struct	bioc_vol bv;
	int	rv, i;

	/* Get volume information. */
	memset(&bi, 0, sizeof(bi));
	rv = ioctl(devfd, BIOCINQ, &bi);
	if (rv == -1)
		return 0;

	/* XXX - softraid volumes will always have a "softraid0" controller. */
	if (strncmp(bi.bi_dev, "softraid0", sizeof("softraid0")))
		return 0;

	/* Locate specific softraid volume. */
	for (i = 0; i < bi.bi_novol; i++) {

		memset(&bv, 0, sizeof(bv));
		bv.bv_volid = i;
		rv = ioctl(devfd, BIOCVOL, &bv);
		if (rv == -1)
			err(1, "BIOCVOL");

		if (strncmp(dev, bv.bv_dev, sizeof(bv.bv_dev)) == 0) {
			*vol = i;
			*disks = bv.bv_nodisk;
			break;
		}

	}

	if (verbose)
		fprintf(stderr, "%s: softraid volume with %i disk(s)\n",
		    dev, *disks);

	return 1;
}

static void
sr_installboot(int devfd)
{
	struct bioc_installboot bb;
	int rv;

	/*
	 * Install boot loader into softraid boot loader storage area.
	 */
	bb.bb_bootldr = "XXX";
	bb.bb_bootldr_size = sizeof("XXX");
	bb.bb_bootblk = blkstore;
	bb.bb_bootblk_size = blksize;
	strncpy(bb.bb_dev, dev, sizeof(bb.bb_dev));
	if (!nowrite) {
		if (verbose)
			fprintf(stderr, "%s: installing boot loader on "
			    "softraid volume\n", dev);
		rv = ioctl(devfd, BIOCINSTALLBOOT, &bb);
		if (rv != 0)
			errx(1, "softraid installboot failed");
	}
}

static void
sr_install_bootblk(int devfd, int vol, int disk)
{
	struct bioc_disk bd;
	char *realdev;
	char part;
	int diskfd;
	int rv;

	/* Get device name for this disk/chunk. */
	memset(&bd, 0, sizeof(bd));
	bd.bd_volid = vol;
	bd.bd_diskid = disk;
	rv = ioctl(devfd, BIOCDISK, &bd);
	if (rv == -1)
		err(1, "BIOCDISK");

	/* Check disk status. */
	if (bd.bd_status != BIOC_SDONLINE && bd.bd_status != BIOC_SDREBUILD) {
		fprintf(stderr, "softraid chunk %u not online - skipping...\n",
		    disk);
		return;	
	}

	if (strlen(bd.bd_vendor) < 1)
		errx(1, "invalid disk name");
	part = bd.bd_vendor[strlen(bd.bd_vendor) - 1];
	if (part < 'a' || part >= 'a' + MAXPARTITIONS)
		errx(1, "invalid partition %c\n", part);
	bd.bd_vendor[strlen(bd.bd_vendor) - 1] = '\0';

	/* Open device. */
	if ((diskfd = opendev(bd.bd_vendor, (nowrite ? O_RDONLY : O_RDWR),
	    OPENDEV_PART, &realdev)) < 0)
		err(1, "open: %s", realdev);

	if (verbose)
		fprintf(stderr, "%s%c: installing boot blocks on %s\n",
		    bd.bd_vendor, part, realdev);

	/* Write boot blocks to device. */
	write_bootblk(diskfd);

	close(diskfd);
}
@


1.18
log
@Build with -Wall. Make sure main() returns zero.
(found the hard way by building with -fstack-shuffle)
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.17 2013/09/29 21:30:50 jmc Exp $	*/
@


1.17
log
@various fixes to sync usage() with SYNOPSIS, and make these pages a bit
more consistent;

feedback/ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.16 2012/02/12 00:53:10 deraadt Exp $	*/
d37 1
d148 2
d217 1
a217 3
	struct stat sb;
	int fd, i, rv;
	u_char *p;
a240 3
	struct disklabel dl;
	struct partition *pp;
	uint32_t poffset;
@


1.16
log
@this breaks ramdisk builds.  misses release
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.14 2012/01/11 16:15:02 jsing Exp $	*/
d71 1
a71 1
	fprintf(stderr, "Usage: %s [-nv] <bootblk> <device>\n", __progname);
@


1.15
log
@Don't compare command line input to softraid device names. Parse
out the intended device name from the realdev constructed by
opendev(). Should fix the issue found by stsp@@ in trying to install
a boot-from-softraid sparc64.

ok deraadt@@
@
text
@a129 5
	dev = strdup(realdev + 6); /* Skip the "/dev/r" */
	if (dev == NULL)
		err(1, "strdup of realdev failed");
	dev[strlen(dev)-1] = '\0'; /* And chop off the 'c'. */

a145 1
	free(dev);
@


1.14
log
@Teach OpenBSD/sparc64 installboot(8) about softraid volumes. This makes
root on softraid possible, although the kernel still needs to be loaded
from a non-softraid partition.
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.13 2012/01/01 16:11:13 jsing Exp $	*/
d130 5
d151 1
@


1.13
log
@Improve/clean up sparc64 installboot:

- Use opendev() like we do for installboot on many other archs.

- Use the term bootblock rather than prototype for the first-stage, since
  we install it verbatim.

- Read the bootblock into a zeroed buffer rather than messing around with
  mmap() and zeroing the end of the space.

- Make man page consistent with respect to the first-stage bootblock and
  second-stage boot program.

ok kettenis@@ jmc@@ (for the man part)
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.10 2011/03/13 00:13:53 deraadt Exp $	*/
d5 1
d35 4
d40 4
a43 2
#include <sys/stat.h>
#include <sys/mman.h>
d45 1
d56 1
d60 5
d79 1
a80 1
	size_t		blksize;
a123 4
	if (nowrite)
		return 0;

	/* Write boot blocks into the superblock. */
d129 30
d167 1
d169 112
a280 1
	close(devfd);
d282 1
a282 1
	return 0;
@


1.12
log
@The sparc64 installboot is for sparc64 only - remove all of the non-sparc64
related code.

ok kettenis@@
@
text
@d44 1
d47 1
a47 1
char	*boot, *proto, *dev;
d64 4
a67 5
	int c, devfd, protofd;
	char *protostore;
	size_t protosize;
	size_t blanklen;
	struct stat sb;
d72 1
a72 1
			/* Do not actually write the bootblock to disk */
d87 1
a87 1
	proto = argv[optind++];
d90 2
a91 4
	if (verbose) {
		printf("proto: %s\n", proto);
		printf("device: %s\n", dev);
	}
d93 2
a94 2
	if ((protofd = open(proto, O_RDONLY)) < 0)
		err(1, "open: %s", proto);
d96 2
a97 2
	if (fstat(protofd, &sb) == -1)
		err(1, "fstat: %s", proto);
d99 1
a99 1
		errx(1, "%s is empty", proto);
d101 8
a108 9
	/* there must be a better way */
	blanklen = DEV_BSIZE - ((sb.st_size + DEV_BSIZE) & (DEV_BSIZE - 1));
	protosize = sb.st_size + blanklen;
	if ((protostore = mmap(0, protosize, PROT_READ|PROT_WRITE, MAP_PRIVATE,
	    protofd, 0)) == MAP_FAILED)
		err(1, "mmap: %s", proto);
	/* and provide the rest of the block */
	if (blanklen)
		memset(protostore + sb.st_size, 0, blanklen);
d113 6
a118 7
	/* Write patched proto bootblocks into the superblock */
	if (protosize > SBSIZE - DEV_BSIZE)
		errx(1, "proto bootblocks too big");

	if ((devfd = open(dev, O_RDWR, 0)) < 0)
		err(1, "open: %s", dev);

d120 1
a120 1
		err(1, "lseek bootstrap");
d125 2
a126 2
	if (write(devfd, protostore, protosize) != protosize)
		err(1, "write bootstrap");
@


1.11
log
@NULL -> 0
@
text
@a33 1
#include <sys/mount.h>
a35 1
#include <sys/sysctl.h>
a36 3
#include <sys/utsname.h>
#include <ufs/ufs/dinode.h>
#include <ufs/ufs/dir.h>
a38 1
#include <a.out.h>
a39 1
#include <nlist.h>
d45 1
a45 3
#include "loadfile.h"

int	verbose, nowrite, sparc64, uflag, hflag = 1;
a47 28
#if 0
#ifdef __ELF__
#define SYMNAME(a)	a
#else
#define SYMNAME(a)	__CONCAT("_",a)
#endif
#else
/* XXX: Hack in libc nlist works with both formats */
#define SYMNAME(a)	"_"a
#endif

struct nlist nl[] = {
#define X_BLOCKTABLE	0
	{ {SYMNAME("block_table")} },
#define X_BLOCKCOUNT	1
	{ {SYMNAME("block_count")} },
#define X_BLOCKSIZE	2
	{ {SYMNAME("block_size")} },
	{ {NULL} }
};
daddr32_t *block_table;		/* block number array in prototype image */
int32_t	*block_count_p;		/* size of this array */
int32_t	*block_size_p;		/* filesystem block size */
int32_t	max_block_count;

char		*loadprotoblocks(char *, size_t *);
int		loadblocknums(char *, int);
static void	devread(int, void *, daddr32_t, size_t, char *);
d52 1
a52 1
usage()
a54 1
	const char *progname = __progname;
d56 1
a56 10
	if (sparc64)
		(void)fprintf(stderr,
		    "Usage: %s [-nv] <bootblk> <device>\n"
		    "       %s -U [-nv] <boot> <proto> <device>\n",
		    progname, progname);
	else
		(void)fprintf(stderr,
		    "Usage: %s [-nv] <boot> <proto> <device>\n"
		    "       %s -u [-n] [-v] <bootblk> <device>\n",
		    progname, progname);
d61 1
a61 3
main(argc, argv)
	int argc;
	char *argv[];
d63 5
a67 13
	int	c;
	int	devfd;
	char	*protostore;
	size_t	protosize;
	struct	utsname utsname;

	/*
	 * For UltraSPARC machines, we turn on the uflag by default.
	 */
	if (uname(&utsname) == -1)
		err(1, "uname");
	if (strcmp(utsname.machine, "sparc64") == 0)
		sparc64 = uflag = 1;
d69 1
a69 1
	while ((c = getopt(argc, argv, "a:nhuUv")) != -1) {
a70 7
		case 'a':
			warnx("-a option is obsolete");
			break;
		case 'h':	/* Note: for backwards compatibility */
			/* Don't strip a.out header */
			warnx("-h option is obsolete");
			break;
a74 8
		case 'u':
			/* UltraSPARC boot block */
			uflag = 1;
			break;
		case 'U':
			/* Force non-ultrasparc */
			uflag = 0;
			break;
d84 2
a85 8
	if (uflag) {
		if (argc - optind < 2)
			usage();
	} else {
		if (argc - optind < 3)
			usage();
		boot = argv[optind++];
	}
a90 2
		if (!uflag)
			printf("boot: %s\n", boot);
d95 17
a111 38
	/* Load proto blocks into core */
	if (uflag == 0) {
		if ((protostore = loadprotoblocks(proto, &protosize)) == NULL)
			exit(1);

		/* Open and check raw disk device */
		if ((devfd = open(dev, O_RDONLY, 0)) < 0)
			err(1, "open: %s", dev);

		/* Extract and load block numbers */
		if (loadblocknums(boot, devfd) != 0)
			exit(1);

		(void)close(devfd);
	} else {
		struct stat sb;
		int protofd;
		size_t blanklen;

		if ((protofd = open(proto, O_RDONLY)) < 0)
			err(1, "open: %s", proto);

		if (fstat(protofd, &sb) == -1)
			err(1, "fstat: %s", proto);
		if (sb.st_size == 0)
			errx(1, "%s is empty", proto);

		/* there must be a better way */
		blanklen = DEV_BSIZE - ((sb.st_size + DEV_BSIZE) & (DEV_BSIZE - 1));
		protosize = sb.st_size + blanklen;
		if ((protostore = mmap(0, (size_t)protosize,
		    PROT_READ|PROT_WRITE, MAP_PRIVATE,
		    protofd, 0)) == MAP_FAILED)
			err(1, "mmap: %s", proto);
		/* and provide the rest of the block */
		if (blanklen)
			memset(protostore + sb.st_size, 0, blanklen);
	}
a130 76
	(void)close(devfd);
	return 0;
}

char *
loadprotoblocks(fname, size)
	char *fname;
	size_t *size;
{
	int	fd, sz;
	u_long	ap, bp, st, en;
	u_long	marks[MARK_MAX];

	/* Locate block number array in proto file */
	if (nlist(fname, nl) != 0) {
		warnx("nlist: %s: symbols not found", fname);
		return NULL;
	}
	if (nl[X_BLOCKTABLE].n_type != N_DATA + N_EXT) {
		warnx("nlist: %s: wrong type", nl[X_BLOCKTABLE].n_un.n_name);
		return NULL;
	}
	if (nl[X_BLOCKCOUNT].n_type != N_DATA + N_EXT) {
		warnx("nlist: %s: wrong type", nl[X_BLOCKCOUNT].n_un.n_name);
		return NULL;
	}
	if (nl[X_BLOCKSIZE].n_type != N_DATA + N_EXT) {
		warnx("nlist: %s: wrong type", nl[X_BLOCKSIZE].n_un.n_name);
		return NULL;
	}

	marks[MARK_START] = 0;
	if ((fd = loadfile(fname, marks, COUNT_TEXT|COUNT_DATA)) == -1)
		return NULL;
	(void)close(fd);

	sz = (marks[MARK_END] - marks[MARK_START]) + (hflag ? 32 : 0);
	sz = roundup(sz, DEV_BSIZE);
	st = marks[MARK_START];
	en = marks[MARK_ENTRY];

	if ((ap = (u_long)malloc(sz)) == 0) {
		warn("malloc: %s", "");
		return NULL;
	}

	bp = ap + (hflag ? 32 : 0);
	marks[MARK_START] = bp - st;
	if ((fd = loadfile(fname, marks, LOAD_TEXT|LOAD_DATA)) == -1) {
		free((void *)ap);
		return NULL;
	}
	(void)close(fd);

	block_table = (daddr32_t *) (bp + nl[X_BLOCKTABLE].n_value - st);
	block_count_p = (int32_t *)(bp + nl[X_BLOCKCOUNT].n_value - st);
	block_size_p = (int32_t *) (bp + nl[X_BLOCKSIZE].n_value - st);
	if ((int)(u_long)block_table & 3) {
		warn("%s: invalid address: block_table = %p",
		     fname, block_table);
		free((void *)ap);
		return NULL;
	}
	if ((int)(u_long)block_count_p & 3) {
		warn("%s: invalid address: block_count_p = %p",
		     fname, block_count_p);
		free((void *)ap);
		return NULL;
	}
	if ((int)(u_long)block_size_p & 3) {
		warn("%s: invalid address: block_size_p = %p",
		     fname, block_size_p);
		free((void *)ap);
		return NULL;
	}
	max_block_count = *block_count_p;
d132 1
a132 147
	if (verbose) {
		printf("%s: entry point %#lx\n", fname, en);
		printf("%s: a.out header %s\n", fname,
		    hflag ? "left on" : "stripped off");
		printf("proto bootblock size %d\n", sz);
		printf("room for %d filesystem blocks at %#lx\n",
		    max_block_count, nl[X_BLOCKTABLE].n_value);
	}

	if (hflag) {
		/*
		 * We convert the a.out header in-vitro into something that
		 * Sun PROMs understand.
		 * Old-style (sun4) ROMs do not expect a header at all, so
		 * we turn the first two words into code that gets us past
		 * the 32-byte header where the actual code begins. In assembly
		 * speak:
		 *	.word	MAGIC		! a NOP
		 *	ba,a	start		!
		 *	.skip	24		! pad
		 * start:
		 */
#define SUN_MAGIC	0x01030107
#define SUN4_BASTART	0x30800007	/* i.e.: ba,a `start' */
		*((int *)ap) = SUN_MAGIC;
		*((int *)ap + 1) = SUN4_BASTART;
	}

	*size = sz;
	return (char *)ap;
}

static void
devread(fd, buf, blk, size, msg)
	int	fd;
	void	*buf;
	daddr32_t	blk;
	size_t	size;
	char	*msg;
{
	if (lseek(fd, dbtob(blk), SEEK_SET) != dbtob(blk))
		err(1, "%s: devread: lseek", msg);

	if (read(fd, buf, size) != size)
		err(1, "%s: devread: read", msg);
}

static char sblock[SBSIZE];

int
loadblocknums(boot, devfd)
char	*boot;
int	devfd;
{
	int		i, fd;
	struct	stat	statbuf;
	struct	statfs	statfsbuf;
	struct fs	*fs;
	char		*buf;
	daddr32_t		blk, *ap;
	struct ufs1_dinode	*ip;
	int		ndb;

	/*
	 * Open 2nd-level boot program and record the block numbers
	 * it occupies on the filesystem represented by `devfd'.
	 */
	if ((fd = open(boot, O_RDONLY)) < 0)
		err(1, "open: %s", boot);

	if (fstatfs(fd, &statfsbuf) != 0)
		err(1, "statfs: %s", boot);

	if (strncmp(statfsbuf.f_fstypename, "ffs", MFSNAMELEN) &&
	    strncmp(statfsbuf.f_fstypename, "ufs", MFSNAMELEN)) {
		errx(1, "%s: must be on an FFS filesystem", boot);
	}

	if (fsync(fd) != 0)
		err(1, "fsync: %s", boot);

	if (fstat(fd, &statbuf) != 0)
		err(1, "fstat: %s", boot);

	close(fd);

	/* Read superblock */
	devread(devfd, sblock, btodb(SBOFF), SBSIZE, "superblock");
	fs = (struct fs *)sblock;

	/* Read inode */
	if ((buf = malloc(fs->fs_bsize)) == NULL)
		errx(1, "No memory for filesystem block");

	blk = fsbtodb(fs, ino_to_fsba(fs, statbuf.st_ino));
	devread(devfd, buf, blk, fs->fs_bsize, "inode");
	ip = (struct ufs1_dinode *)(buf) + ino_to_fsbo(fs, statbuf.st_ino);

	/*
	 * Register filesystem block size.
	 */
	*block_size_p = fs->fs_bsize;

	/*
	 * Get the block numbers; we don't handle fragments
	 */
	ndb = howmany(ip->di_size, fs->fs_bsize);
	if (ndb > max_block_count)
		errx(1, "%s: Too many blocks", boot);

	/*
	 * Register block count.
	 */
	*block_count_p = ndb;

	if (verbose)
		printf("%s: block numbers: ", boot);
	ap = ip->di_db;
	for (i = 0; i < NDADDR && *ap && ndb; i++, ap++, ndb--) {
		blk = fsbtodb(fs, *ap);
		block_table[i] = blk;
		if (verbose)
			printf("%d ", blk);
	}
	if (verbose)
		printf("\n");

	if (ndb == 0)
		return 0;

	/*
	 * Just one level of indirections; there isn't much room
	 * for more in the 1st-level bootblocks anyway.
	 */
	if (verbose)
		printf("%s: block numbers (indirect): ", boot);
	blk = ip->di_ib[0];
	devread(devfd, buf, blk, fs->fs_bsize, "indirect block");
	ap = (daddr32_t *)buf;
	for (; i < NINDIR(fs) && *ap && ndb; i++, ap++, ndb--) {
		blk = fsbtodb(fs, *ap);
		block_table[i] = blk;
		if (verbose)
			printf("%d ", blk);
	}
	if (verbose)
		printf("\n");
a133 2
	if (ndb)
		errx(1, "%s: Too many blocks", boot);
@


1.10
log
@Change daddr_t to daddr32_t.  The bootblocks on our architectures only
do 32-bit block spanning.  If later on we get some that can/should do
64-bit, that can be done now using daddr64_t (but of course, we are taking
this step to finalize the daddr_t 64-bit conversion).
ok miod krw
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.9 2010/11/20 13:10:42 deraadt Exp $	*/
d273 1
a273 1
	if ((ap = (u_long)malloc(sz)) == NULL) {
@


1.9
log
@some more installboot cleanup from gapz@@dud-t.org
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.8 2010/11/19 18:11:21 deraadt Exp $	*/
d77 1
a77 1
daddr_t	*block_table;		/* block number array in prototype image */
d84 1
a84 1
static void	devread(int, void *, daddr_t, size_t, char *);
d286 1
a286 1
	block_table = (daddr_t *) (bp + nl[X_BLOCKTABLE].n_value - st);
d345 1
a345 1
	daddr_t	blk;
d368 1
a368 1
	daddr_t		blk, *ap;
d447 1
a447 1
	ap = (daddr_t *)buf;
@


1.8
log
@gapz@@dud-t . org noted that sparc64 installboot crashes if the bootblock is
zero-sized.  Apply similar fixes to installboot for other architectures.
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.7 2008/06/26 05:42:13 ray Exp $	*/
d197 1
a197 1
		if (fstat(protofd, &sb) < 0)
@


1.7
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.6 2004/06/24 16:31:02 deraadt Exp $	*/
d199 2
@


1.6
log
@free() correct object; andrushock@@korovino.net
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.5 2004/01/11 23:59:22 pvalchev Exp $	*/
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.5
log
@in ANSI world, "string1" "string2" is enough for concatecation
gcc3 bitches as "str1"##"str2" is not a valid token; ok espie
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.4 2003/08/25 23:36:46 tedu Exp $	*/
d285 2
a286 1
	if ((fd = loadfile(fname, marks, LOAD_TEXT|LOAD_DATA)) == -1)
d288 1
d297 1
a297 1
		free((void *)bp);
d303 1
a303 1
		free((void *)bp);
d309 1
a309 1
		free((void *)bp);
@


1.4
log
@rename struct dinode to ufs1_dinode.  clears the namespace and makes
way for some future work.  no function changes yet.
help testing otto@@ and markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.3 2002/03/14 01:26:46 millert Exp $	*/
d72 1
a72 1
#define SYMNAME(a)	__CONCAT("_",a)
@


1.3
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.2 2001/09/06 19:24:47 jason Exp $	*/
d372 1
a372 1
	struct dinode	*ip;
d408 1
a408 1
	ip = (struct dinode *)(buf) + ino_to_fsbo(fs, statbuf.st_ino);
@


1.2
log
@Oops, forgot rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d89 5
a93 5
char		*loadprotoblocks __P((char *, size_t *));
int		loadblocknums __P((char *, int));
static void	devread __P((int, void *, daddr_t, size_t, char *));
static void	usage __P((void));
int 		main __P((int, char *[]));
@


1.2.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.2 2001/09/06 19:24:47 jason Exp $	*/
d89 5
a93 5
char		*loadprotoblocks(char *, size_t *);
int		loadblocknums(char *, int);
static void	devread(int, void *, daddr_t, size_t, char *);
static void	usage(void);
int 		main(int, char *[]);
@


1.2.4.1
log
@Sync the SMP branch to something just after 3.0
@
text
@@


1.2.4.2
log
@Merge in -current from about a week ago
@
text
@d89 5
a93 5
char		*loadprotoblocks(char *, size_t *);
int		loadblocknums(char *, int);
static void	devread(int, void *, daddr_t, size_t, char *);
static void	usage(void);
int 		main(int, char *[]);
@


1.2.4.3
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d72 1
a72 1
#define SYMNAME(a)	"_"a
d372 1
a372 1
	struct ufs1_dinode	*ip;
d408 1
a408 1
	ip = (struct ufs1_dinode *)(buf) + ino_to_fsbo(fs, statbuf.st_ino);
@


1.1
log
@installboot (from netbsd)
@
text
@d1 1
@

