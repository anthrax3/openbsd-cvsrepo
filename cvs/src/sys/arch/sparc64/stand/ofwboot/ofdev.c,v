head	1.25;
access;
symbols
	OPENBSD_6_2:1.25.0.10
	OPENBSD_6_2_BASE:1.25
	OPENBSD_6_1:1.25.0.8
	OPENBSD_6_1_BASE:1.25
	OPENBSD_6_0:1.25.0.4
	OPENBSD_6_0_BASE:1.25
	OPENBSD_5_9:1.25.0.2
	OPENBSD_5_9_BASE:1.25
	OPENBSD_5_8:1.24.0.6
	OPENBSD_5_8_BASE:1.24
	OPENBSD_5_7:1.24.0.2
	OPENBSD_5_7_BASE:1.24
	OPENBSD_5_6:1.22.0.4
	OPENBSD_5_6_BASE:1.22
	OPENBSD_5_5:1.20.0.4
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.18.0.2
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.17.0.8
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.6
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.4
	OPENBSD_5_0:1.17.0.2
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.16.0.2
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.14.0.2
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.12.0.2
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.10.0.4
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.9.0.8
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.6
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.4
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.2
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.8.0.4
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.2
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.6.0.12
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.10
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.8
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.6.0.6
	OPENBSD_3_6_BASE:1.6
	SMP_SYNC_A:1.6
	SMP_SYNC_B:1.6
	OPENBSD_3_5:1.6.0.4
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.2
	OPENBSD_3_4_BASE:1.6
	UBC_SYNC_A:1.6
	OPENBSD_3_3:1.4.0.4
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.3.0.2
	OPENBSD_3_1_BASE:1.3
	UBC_SYNC_B:1.4
	UBC:1.2.0.6
	UBC_BASE:1.2
	SMP:1.2.0.4
	OPENBSD_3_0:1.2.0.2
	OPENBSD_3_0_BASE:1.2
	SPARC64:1.1.1.1
	NETBSD:1.1.1;
locks; strict;
comment	@ * @;


1.25
date	2015.10.01.16.08.20;	author krw;	state Exp;
branches;
next	1.24;
commitid	43YBo4Ce0DxgFS6N;

1.24
date	2014.12.09.18.05.16;	author stsp;	state Exp;
branches;
next	1.23;
commitid	p8TgAnVNHMlozyJa;

1.23
date	2014.11.26.20.30.41;	author stsp;	state Exp;
branches;
next	1.22;
commitid	e315CjZvNnS0qsAl;

1.22
date	2014.06.08.16.01.00;	author jsg;	state Exp;
branches;
next	1.21;
commitid	32JwqlXjVGr8WBuP;

1.21
date	2014.06.08.15.34.05;	author jsg;	state Exp;
branches;
next	1.20;
commitid	NfonAtw3fV5s32sp;

1.20
date	2013.11.05.00.51.58;	author krw;	state Exp;
branches;
next	1.19;

1.19
date	2013.10.20.10.11.17;	author krw;	state Exp;
branches;
next	1.18;

1.18
date	2013.06.11.16.42.12;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2011.03.13.00.13.53;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2010.09.08.15.25.43;	author jsing;	state Exp;
branches;
next	1.15;

1.15
date	2010.09.08.14.52.26;	author jsing;	state Exp;
branches;
next	1.14;

1.14
date	2010.05.09.19.45.51;	author kettenis;	state Exp;
branches;
next	1.13;

1.13
date	2010.04.23.15.25.21;	author jsing;	state Exp;
branches;
next	1.12;

1.12
date	2009.11.04.12.03.57;	author jsing;	state Exp;
branches;
next	1.11;

1.11
date	2009.08.17.14.23.09;	author jsing;	state Exp;
branches;
next	1.10;

1.10
date	2009.05.21.23.45.48;	author krw;	state Exp;
branches;
next	1.9;

1.9
date	2007.05.29.06.28.15;	author otto;	state Exp;
branches;
next	1.8;

1.8
date	2006.07.27.20.41.29;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2006.03.04.19.33.21;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2003.05.13.01.48.55;	author jason;	state Exp;
branches;
next	1.5;

1.5
date	2003.04.06.18.54.20;	author ho;	state Exp;
branches;
next	1.4;

1.4
date	2002.07.10.20.30.15;	author jsyn;	state Exp;
branches;
next	1.3;

1.3
date	2002.03.14.01.26.46;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2001.08.20.19.55.33;	author jason;	state Exp;
branches
	1.2.4.1
	1.2.6.1;
next	1.1;

1.1
date	2001.08.18.15.50.50;	author jason;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.08.18.15.50.50;	author jason;	state Exp;
branches;
next	;

1.2.4.1
date	2001.10.31.03.07.59;	author nate;	state Exp;
branches;
next	1.2.4.2;

1.2.4.2
date	2002.03.28.11.23.52;	author niklas;	state Exp;
branches;
next	1.2.4.3;

1.2.4.3
date	2003.03.27.23.42.38;	author niklas;	state Exp;
branches;
next	1.2.4.4;

1.2.4.4
date	2003.05.13.19.41.09;	author ho;	state Exp;
branches;
next	1.2.4.5;

1.2.4.5
date	2003.05.16.00.29.41;	author niklas;	state Exp;
branches;
next	;

1.2.6.1
date	2002.06.11.03.38.44;	author art;	state Exp;
branches;
next	1.2.6.2;

1.2.6.2
date	2002.10.29.00.28.12;	author art;	state Exp;
branches;
next	1.2.6.3;

1.2.6.3
date	2003.05.19.21.46.58;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.25
log
@Remove more blinding trailing whitespace.
@
text
@/*	$OpenBSD: ofdev.c,v 1.24 2014/12/09 18:05:16 stsp Exp $	*/
/*	$NetBSD: ofdev.c,v 1.1 2000/08/20 14:58:41 mrg Exp $	*/

/*
 * Copyright (C) 1995, 1996 Wolfgang Solfrank.
 * Copyright (C) 1995, 1996 TooLs GmbH.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by TooLs GmbH.
 * 4. The name of TooLs GmbH may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY TOOLS GMBH ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL TOOLS GMBH BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/*
 * Device I/O routines using Open Firmware
 */
#include <sys/param.h>
#include <sys/disklabel.h>
#ifdef NETBOOT
#include <netinet/in.h>
#endif

#include <lib/libsa/stand.h>
#include <lib/libsa/ufs.h>
#include <lib/libsa/cd9660.h>
#ifdef NETBOOT
#include <lib/libsa/nfs.h>
#endif

#ifdef SOFTRAID
#include <sys/queue.h>
#include <dev/softraidvar.h>
#include "disk.h"
#endif

#include <dev/sun/disklabel.h>
#include "ofdev.h"

extern char bootdev[];

/*
 * This is ugly.  A path on a sparc machine is something like this:
 *
 *	[device] [-<options] [path] [-options] [otherstuff] [-<more options]
 *
 */

static char *
filename(char *str, char *ppart)
{
	char *cp, *lp;
	char savec;
	int dhandle;
	char devtype[16];

	lp = str;
	devtype[0] = 0;
	*ppart = 0;
	for (cp = str; *cp; lp = cp) {
		/* For each component of the path name... */
		while (*++cp && *cp != '/');
		savec = *cp;
		*cp = 0;
		/* ...look whether there is a device with this name */
		dhandle = OF_finddevice(str);
		DNPRINTF(BOOT_D_OFDEV, "filename: OF_finddevice(%s) says %x\n",
		    str, dhandle);
		*cp = savec;
		if (dhandle == -1) {
			/* if not, lp is the delimiter between device and path */
			/* if the last component was a block device... */
			if (!strcmp(devtype, "block")) {
				/* search for arguments */
				DNPRINTF(BOOT_D_OFDEV, "filename: hunting for "
				    "arguments in %s\n", str);
				for (cp = lp;
				     --cp >= str && *cp != '/' && *cp != '-';);
				if (cp >= str && *cp == '-') {
					/* found arguments, make firmware ignore them */
					*cp = 0;
					for (cp = lp; *--cp && *cp != ',';);
					if (*++cp >= 'a' && *cp <= 'a' + MAXPARTITIONS)
						*ppart = *cp;
				}
			}
			DNPRINTF(BOOT_D_OFDEV, "filename: found %s\n", lp);
			return lp;
		} else if (OF_getprop(dhandle, "device_type", devtype, sizeof devtype) < 0)
			devtype[0] = 0;
	}
	DNPRINTF(BOOT_D_OFDEV, "filename: not found\n", lp);
	return 0;
}

int
strategy(void *devdata, int rw, daddr32_t blk, size_t size, void *buf,
    size_t *rsize)
{
	struct of_dev *dev = devdata;
	u_quad_t pos;
	int n;

	if (rw != F_READ)
		return EPERM;
#ifdef SOFTRAID
	/* Intercept strategy for softraid volumes. */
	if (dev->type == OFDEV_SOFTRAID)
		return sr_strategy(bootdev_dip->sr_vol, rw,
		    blk, size, buf, rsize);
#endif
	if (dev->type != OFDEV_DISK)
		panic("strategy");

	DNPRINTF(BOOT_D_OFDEV, "strategy: block %lx, partition offset %lx, "
	    "blksz %lx\n", (long)blk, (long)dev->partoff, (long)dev->bsize);
	DNPRINTF(BOOT_D_OFDEV, "strategy: seek position should be: %lx\n",
	    (long)((blk + dev->partoff) * dev->bsize));
	pos = (u_quad_t)(blk + dev->partoff) * dev->bsize;

	for (;;) {
		DNPRINTF(BOOT_D_OFDEV, "strategy: seeking to %lx\n", (long)pos);
		if (OF_seek(dev->handle, pos) < 0)
			break;
		DNPRINTF(BOOT_D_OFDEV, "strategy: reading %lx at %p\n",
		    (long)size, buf);
		n = OF_read(dev->handle, buf, size);
		if (n == -2)
			continue;
		if (n < 0)
			break;
		*rsize = n;
		return 0;
	}
	return EIO;
}

static int
devclose(struct open_file *of)
{
	struct of_dev *op = of->f_devdata;

#ifdef NETBOOT
	if (op->type == OFDEV_NET)
		net_close(op);
#endif
#ifdef SOFTRAID
	if (op->type == OFDEV_SOFTRAID) {
		op->handle = -1;
		return 0;
	}
#endif
	OF_close(op->handle);
	op->handle = -1;
	return 0;
}

struct devsw devsw[1] = {
	"OpenFirmware",
	strategy,
	(int (*)(struct open_file *, ...))nodev,
	devclose,
	noioctl
};
int ndevs = sizeof devsw / sizeof devsw[0];

#ifdef SPARC_BOOT_UFS
static struct fs_ops file_system_ufs = {
	ufs_open, ufs_close, ufs_read, ufs_write, ufs_seek, ufs_stat
};
#endif
#ifdef SPARC_BOOT_HSFS
static struct fs_ops file_system_cd9660 = {
	cd9660_open, cd9660_close, cd9660_read, cd9660_write, cd9660_seek,
	    cd9660_stat
};
#endif
#ifdef NETBOOT
static struct fs_ops file_system_nfs = {
	nfs_open, nfs_close, nfs_read, nfs_write, nfs_seek, nfs_stat
};
#endif

struct fs_ops file_system[3];
int nfsys;

static struct of_dev ofdev = {
	-1,
};

char opened_name[256];

static u_long
get_long(const void *p)
{
	const unsigned char *cp = p;

	return cp[0] | (cp[1] << 8) | (cp[2] << 16) | (cp[3] << 24);
}

/************************************************************************
 *
 * The rest of this was taken from arch/sparc64/scsi/sun_disklabel.c
 * and then substantially rewritten by Gordon W. Ross
 *
 ************************************************************************/

/* What partition types to assume for Sun disklabels: */
static u_char
sun_fstypes[8] = {
	FS_BSDFFS,	/* a */
	FS_SWAP,	/* b */
	FS_OTHER,	/* c - whole disk */
	FS_BSDFFS,	/* d */
	FS_BSDFFS,	/* e */
	FS_BSDFFS,	/* f */
	FS_BSDFFS,	/* g */
	FS_BSDFFS,	/* h */
};

/*
 * Given a struct sun_disklabel, assume it has an extended partition
 * table and compute the correct value for sl_xpsum.
 */
static __inline u_int
sun_extended_sum(struct sun_disklabel *sl, void *end)
{
	u_int sum, *xp, *ep;

	xp = (u_int *)&sl->sl_xpmag;
	ep = (u_int *)end;

	sum = 0;
	for (; xp < ep; xp++)
		sum += *xp;
	return (sum);
}

/*
 * Given a SunOS disk label, set lp to a BSD disk label.
 * The BSD label is cleared out before this is called.
 */
static int
disklabel_sun_to_bsd(struct sun_disklabel *sl, struct disklabel *lp)
{
	struct sun_preamble *preamble = (struct sun_preamble *)sl;
	struct sun_partinfo *ppp;
	struct sun_dkpart *spp;
	struct partition *npp;
	u_short cksum = 0, *sp1, *sp2;
	int i, secpercyl;

	/* Verify the XOR check. */
	sp1 = (u_short *)sl;
	sp2 = (u_short *)(sl + 1);
	while (sp1 < sp2)
		cksum ^= *sp1++;
	if (cksum != 0)
		return (EINVAL);	/* SunOS disk label, bad checksum */

	/* Format conversion. */
	lp->d_magic = DISKMAGIC;
	lp->d_magic2 = DISKMAGIC;
	lp->d_flags = D_VENDOR;
	memcpy(lp->d_packname, sl->sl_text, sizeof(lp->d_packname));

	lp->d_secsize = DEV_BSIZE;
	lp->d_nsectors = sl->sl_nsectors;
	lp->d_ntracks = sl->sl_ntracks;
	lp->d_ncylinders = sl->sl_ncylinders;

	secpercyl = sl->sl_nsectors * sl->sl_ntracks;
	lp->d_secpercyl = secpercyl;
	if (DL_GETDSIZE(lp) == 0)
		DL_SETDSIZE(lp, (u_int64_t)secpercyl * sl->sl_ncylinders);
	lp->d_version = 1;

	memcpy(&lp->d_uid, &sl->sl_uid, sizeof(lp->d_uid));

	lp->d_acylinders = sl->sl_acylinders;

	lp->d_npartitions = MAXPARTITIONS;
	/* These are as defined in <ufs/ffs/fs.h> */
	lp->d_bbsize = 8192;	/* XXX */
	lp->d_sbsize = 8192;	/* XXX */

	for (i = 0; i < 8; i++) {
		spp = &sl->sl_part[i];
		npp = &lp->d_partitions[i];
		DL_SETPOFFSET(npp, spp->sdkp_cyloffset * secpercyl);
		DL_SETPSIZE(npp, spp->sdkp_nsectors);
		if (DL_GETPSIZE(npp) == 0) {
			npp->p_fstype = FS_UNUSED;
		} else {
			npp->p_fstype = sun_fstypes[i];
			if (npp->p_fstype == FS_BSDFFS) {
				/*
				 * The sun label does not store the FFS fields,
				 * so just set them with default values here.
				 */
				npp->p_fragblock =
				    DISKLABELV1_FFS_FRAGBLOCK(2048, 8);
				npp->p_cpg = 16;
			}
		}
	}

	/* Clear "extended" partition info, tentatively */
	for (i = 0; i < SUNXPART; i++) {
		npp = &lp->d_partitions[i+8];
		DL_SETPOFFSET(npp, 0);
		DL_SETPSIZE(npp, 0);
		npp->p_fstype = FS_UNUSED;
	}

	/* Check to see if there's an "extended" partition table
	 * SL_XPMAG partitions had checksums up to just before the
	 * (new) sl_types variable, while SL_XPMAGTYP partitions have
	 * checksums up to the just before the (new) sl_xxx1 variable.
	 * Also, disklabels created prior to the addition of sl_uid will
	 * have a checksum to just before the sl_uid variable.
	 */
	if ((sl->sl_xpmag == SL_XPMAG &&
	    sun_extended_sum(sl, &sl->sl_types) == sl->sl_xpsum) ||
	    (sl->sl_xpmag == SL_XPMAGTYP &&
	    sun_extended_sum(sl, &sl->sl_uid) == sl->sl_xpsum) ||
	    (sl->sl_xpmag == SL_XPMAGTYP &&
	    sun_extended_sum(sl, &sl->sl_xxx1) == sl->sl_xpsum)) {
		/*
		 * There is.  Copy over the "extended" partitions.
		 * This code parallels the loop for partitions a-h.
		 */
		for (i = 0; i < SUNXPART; i++) {
			spp = &sl->sl_xpart[i];
			npp = &lp->d_partitions[i+8];
			DL_SETPOFFSET(npp, spp->sdkp_cyloffset * secpercyl);
			DL_SETPSIZE(npp, spp->sdkp_nsectors);
			if (DL_GETPSIZE(npp) == 0) {
				npp->p_fstype = FS_UNUSED;
				continue;
			}
			npp->p_fstype = FS_BSDFFS;
			npp->p_fragblock =
			    DISKLABELV1_FFS_FRAGBLOCK(2048, 8);
			npp->p_cpg = 16;
		}
		if (sl->sl_xpmag == SL_XPMAGTYP) {
			for (i = 0; i < MAXPARTITIONS; i++) {
				npp = &lp->d_partitions[i];
				npp->p_fstype = sl->sl_types[i];
				npp->p_fragblock = sl->sl_fragblock[i];
				npp->p_cpg = sl->sl_cpg[i];
			}
		}
	} else if (preamble->sl_nparts <= 8) {
		/*
		 * A more traditional Sun label.  Recognise certain filesystem
		 * types from it, if they are available.
		 */
		i = preamble->sl_nparts;
		if (i == 0)
			i = 8;

		npp = &lp->d_partitions[i-1];
		ppp = &preamble->sl_part[i-1];
		for (; i > 0; i--, npp--, ppp--) {
			if (npp->p_size == 0)
				continue;
			if ((ppp->spi_tag == 0) && (ppp->spi_flag == 0))
				continue;

			switch (ppp->spi_tag) {
			case SPTAG_SUNOS_ROOT:
			case SPTAG_SUNOS_USR:
			case SPTAG_SUNOS_VAR:
			case SPTAG_SUNOS_HOME:
				npp->p_fstype = FS_BSDFFS;
				npp->p_fragblock =
				    DISKLABELV1_FFS_FRAGBLOCK(2048, 8);
				npp->p_cpg = 16;
				break;
			case SPTAG_LINUX_EXT2:
				npp->p_fstype = FS_EXT2FS;
				break;
			default:
				/* FS_SWAP for _SUNOS_SWAP and _LINUX_SWAP? */
				npp->p_fstype = FS_UNUSED;
				break;
			}
		}
	}

	lp->d_checksum = 0;
	lp->d_checksum = dkcksum(lp);
	DNPRINTF(BOOT_D_OFDEV, "disklabel_sun_to_bsd: success!\n");
	return (0);
}

/*
 * Find a valid disklabel.
 */
static char *
search_label(struct of_dev *devp, u_long off, char *buf, struct disklabel *lp,
    u_long off0)
{
	size_t read;
	struct mbr_partition *p;
	int i;
	u_long poff;

	struct disklabel *dlp;
	struct sun_disklabel *slp;
	int error;

	/* minimal requirements for archetypal disk label */
	if (DL_GETDSIZE(lp) == 0)
		DL_SETDSIZE(lp, 0x1fffffff);
	lp->d_npartitions = MAXPARTITIONS;
	if (DL_GETPSIZE(&lp->d_partitions[0]) == 0)
		DL_SETPSIZE(&lp->d_partitions[0], 0x1fffffff);
	DL_SETPOFFSET(&lp->d_partitions[0], 0);

	if (strategy(devp, F_READ, off, DEV_BSIZE, buf, &read)
	    || read != DEV_BSIZE)
		return ("Cannot read label");

	/* Check for a disk label. */
	dlp = (struct disklabel *) (buf + LABELOFFSET);
	if (dlp->d_magic == DISKMAGIC) {
		if (dkcksum(dlp))
			return ("corrupt disk label");
		*lp = *dlp;
		DNPRINTF(BOOT_D_OFDEV, "search_label: found disk label\n");
		return (NULL);
	}

	/* Check for a Sun disk label (for PROM compatibility). */
	slp = (struct sun_disklabel *)buf;
	if (slp->sl_magic == SUN_DKMAGIC) {
		if (disklabel_sun_to_bsd(slp, lp) != 0)
			return ("corrupt disk label");
		DNPRINTF(BOOT_D_OFDEV, "search_label: found disk label\n");
		return (NULL);
	}

	return ("no disk label");
}

int
load_disklabel(struct of_dev *ofdev, struct disklabel *label)
{
	char buf[DEV_BSIZE];
	size_t read;
	int error = 0;
	char *errmsg = NULL;

	/* First try to find a disklabel without MBR partitions */
	DNPRINTF(BOOT_D_OFDEV, "load_disklabel: trying to read disklabel\n");
	if (strategy(ofdev, F_READ,
		     LABELSECTOR, DEV_BSIZE, buf, &read) != 0
	    || read != DEV_BSIZE
	    || (errmsg = getdisklabel(buf, label))) {
#ifdef BOOT_DEBUG
		if (errmsg)
			DNPRINTF(BOOT_D_OFDEV,
			    "load_disklabel: getdisklabel says %s\n", errmsg);
#endif
		/* Else try MBR partitions */
		errmsg = search_label(ofdev, LABELSECTOR, buf,
		    label, 0);
		if (errmsg) {
			printf("load_disklabel: search_label says %s\n",
			    errmsg);
			error = ERDLAB;
		}
	}

	return (error);
}

int
devopen(struct open_file *of, const char *name, char **file)
{
	char *cp;
	char partition;
	char fname[256];
	char buf[DEV_BSIZE];
	struct disklabel label;
	int handle, part;
	int error = 0;
#ifdef SOFTRAID
	char volno;
#endif

	if (ofdev.handle != -1)
		panic("devopen");
	if (of->f_flags != F_READ)
		return EPERM;
	DNPRINTF(BOOT_D_OFDEV, "devopen: you want %s\n", name);
	if (strlcpy(fname, name, sizeof fname) >= sizeof fname)
		return ENAMETOOLONG;
#ifdef SOFTRAID
	if (bootdev_dip) {
		if (fname[0] == 's' && fname[1] == 'r' &&
		    '0' <= fname[2] && fname[2] <= '9') {
			volno = fname[2];
			if ('a' <= fname[3] &&
			    fname[3] <= 'a' + MAXPARTITIONS) {
				partition = fname[3];
				if (fname[4] == ':')
					cp = &fname[5];
				else
					cp = &fname[4];
			} else {
				partition = 'a';
				cp = &fname[3];
			}
		} else {
			volno = '0';
			partition = 'a';
			cp = &fname[0];
		}
		snprintf(buf, sizeof buf, "sr%c:%c", volno, partition);
		if (strlcpy(opened_name, buf, sizeof opened_name)
		    >= sizeof opened_name)
			return ENAMETOOLONG;
		*file = opened_name + strlen(opened_name);
		if (!*cp) {
			if (strlcpy(buf, DEFAULT_KERNEL, sizeof buf)
			    >= sizeof buf)
				return ENAMETOOLONG;
		} else {
			if (snprintf(buf, sizeof buf, "%s%s",
			    *cp == '/' ? "" : "/", cp) >= sizeof buf)
				return ENAMETOOLONG;
		}
		if (strlcat(opened_name, buf, sizeof opened_name) >=
		    sizeof opened_name)
			return ENAMETOOLONG;
	} else {
#endif
		cp = filename(fname, &partition);
		if (cp) {
			if (strlcpy(buf, cp, sizeof buf) >= sizeof buf)
				return ENAMETOOLONG;
			*cp = 0;
		}
		if (!cp || !*buf) {
			if (strlcpy(buf, DEFAULT_KERNEL, sizeof buf)
			    >= sizeof buf)
				return ENAMETOOLONG;
		}
		if (!*fname) {
			if (strlcpy(fname, bootdev, sizeof fname)
			    >= sizeof fname)
				return ENAMETOOLONG;
		}
		if (strlcpy(opened_name, fname,
		    partition ? (sizeof opened_name) - 2 : sizeof opened_name)
		    >= sizeof opened_name)
			return ENAMETOOLONG;
		if (partition) {
			cp = opened_name + strlen(opened_name);
			*cp++ = ':';
			*cp++ = partition;
			*cp = 0;
		}
		if (*buf != '/') {
			if (strlcat(opened_name, "/", sizeof opened_name) >=
			    sizeof opened_name)
				return ENAMETOOLONG;
		}
		if (strlcat(opened_name, buf, sizeof opened_name) >=
		    sizeof opened_name)
			return ENAMETOOLONG;
		*file = opened_name + strlen(fname) + 1;
#ifdef SOFTRAID
	}
#endif
	DNPRINTF(BOOT_D_OFDEV, "devopen: trying %s\n", fname);
#ifdef SOFTRAID
	if (bootdev_dip) {
		/* Redirect to the softraid boot volume. */
		struct partition *pp;

		bzero(&ofdev, sizeof ofdev);
		ofdev.type = OFDEV_SOFTRAID;

		if (partition) {
			if (partition < 'a' ||
			    partition >= 'a' + MAXPARTITIONS) {
				printf("invalid partition '%c'\n", partition);
				return EINVAL;
			}
			part = partition - 'a';
			pp = &bootdev_dip->disklabel.d_partitions[part];
			if (pp->p_fstype == FS_UNUSED || pp->p_size == 0) {
				printf("invalid partition '%c'\n", partition);
				return EINVAL;
			}
			bootdev_dip->sr_vol->sbv_part = partition;
		} else
			bootdev_dip->sr_vol->sbv_part = 'a';

		of->f_dev = devsw;
		of->f_devdata = &ofdev;

#ifdef SPARC_BOOT_UFS
		bcopy(&file_system_ufs, &file_system[nfsys++], sizeof file_system[0]);
#else
#error "-DSOFTRAID requires -DSPARC_BOOT_UFS"
#endif
		return 0;
	}
#endif
	if ((handle = OF_finddevice(fname)) == -1)
		return ENOENT;
	DNPRINTF(BOOT_D_OFDEV, "devopen: found %s\n", fname);
	if (OF_getprop(handle, "name", buf, sizeof buf) < 0)
		return ENXIO;
	DNPRINTF(BOOT_D_OFDEV, "devopen: %s is called %s\n", fname, buf);
	if (OF_getprop(handle, "device_type", buf, sizeof buf) < 0)
		return ENXIO;
	DNPRINTF(BOOT_D_OFDEV, "devopen: %s is a %s device\n", fname, buf);
	DNPRINTF(BOOT_D_OFDEV, "devopen: opening %s\n", fname);
	if ((handle = OF_open(fname)) == -1) {
		DNPRINTF(BOOT_D_OFDEV, "devopen: open of %s failed\n", fname);
		return ENXIO;
	}
	DNPRINTF(BOOT_D_OFDEV, "devopen: %s is now open\n", fname);
	bzero(&ofdev, sizeof ofdev);
	ofdev.handle = handle;
	ofdev.type = OFDEV_DISK;
	ofdev.bsize = DEV_BSIZE;
	if (!strcmp(buf, "block")) {
		error = load_disklabel(&ofdev, &label);
		if (error && error != ERDLAB)
			goto bad;
		else if (error == ERDLAB) {
			if (partition)
				/* User specified a parititon, but there is none */
				goto bad;
			/* No, label, just use complete disk */
			ofdev.partoff = 0;
		} else {
			part = partition ? partition - 'a' : 0;
			ofdev.partoff = label.d_partitions[part].p_offset;
			DNPRINTF(BOOT_D_OFDEV, "devopen: setting partition %d "
			    "offset %x\n", part, ofdev.partoff);
		}

		of->f_dev = devsw;
		of->f_devdata = &ofdev;
#ifdef SPARC_BOOT_UFS
		bcopy(&file_system_ufs, &file_system[nfsys++], sizeof file_system[0]);
#endif
#ifdef SPARC_BOOT_HSFS
		bcopy(&file_system_cd9660, &file_system[nfsys++],
		    sizeof file_system[0]);
#endif
		DNPRINTF(BOOT_D_OFDEV, "devopen: return 0\n");
		return 0;
	}
#ifdef NETBOOT
	if (!strcmp(buf, "network")) {
		ofdev.type = OFDEV_NET;
		of->f_dev = devsw;
		of->f_devdata = &ofdev;
		bcopy(&file_system_nfs, file_system, sizeof file_system[0]);
		nfsys = 1;
		if (error = net_open(&ofdev))
			goto bad;
		return 0;
	}
#endif
	error = EFTYPE;
bad:
	DNPRINTF(BOOT_D_OFDEV, "devopen: error %d, cannot open device\n",
	    error);
	OF_close(handle);
	ofdev.handle = -1;
	return error;
}
@


1.24
log
@Check strlcpy(), strlcat(), and snprintf() return values in sparc64 ofwboot.
tweak and ok millert@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ofdev.c,v 1.23 2014/11/26 20:30:41 stsp Exp $	*/
d75 1
a75 1
	
d122 1
a122 1
	
d133 1
a133 1
	
d136 1
a136 1
	DNPRINTF(BOOT_D_OFDEV, "strategy: seek position should be: %lx\n", 
d139 1
a139 1
	
d162 1
a162 1
#ifdef NETBOOT	
d216 1
a216 1
	
d433 1
a433 1
	
d490 1
a490 1
		if (errmsg) { 
d611 1
a611 1
			    	printf("invalid partition '%c'\n", partition);
d617 1
a617 1
			    	printf("invalid partition '%c'\n", partition);
d670 1
a670 1
		
@


1.23
log
@Introduce softraid boot support to sparc64 ofwboot.
sparc64 machines should now be able to boot from softraid raid1 and crypto.
Tested on sun blade100, sunfire v240, and sun t1000 ldom guests.
Lots of encouragement from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ofdev.c,v 1.22 2014/06/08 16:01:00 jsg Exp $	*/
d519 2
a520 1
	strlcpy(fname, name, sizeof fname);
d543 3
a545 1
		strlcpy(opened_name, buf, sizeof opened_name);
d547 12
a558 6
		if (!*cp)
			strlcpy(buf, DEFAULT_KERNEL, sizeof buf);
		else
			snprintf(buf, sizeof buf, "%s%s",
			    *cp == '/' ? "" : "/", cp);
		strlcat(opened_name, buf, sizeof opened_name);
d563 2
a564 1
			strlcpy(buf, cp, sizeof buf);
d567 14
a580 6
		if (!cp || !*buf)
			strlcpy(buf, DEFAULT_KERNEL, sizeof buf);
		if (!*fname)
			strlcpy(fname, bootdev, sizeof fname);
		strlcpy(opened_name, fname,
		    partition ? (sizeof opened_name) - 2 : sizeof opened_name);
d587 8
a594 3
		if (*buf != '/')
			strlcat(opened_name, "/", sizeof opened_name);
		strlcat(opened_name, buf, sizeof opened_name);
@


1.22
log
@Remove an incorrect bzero() that was zeroing the
size of the pointer instead of the size of the buffer.
Removal suggested by deraadt@@ as no code uses the buffer
after the zeroing.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofdev.c,v 1.21 2014/06/08 15:34:05 jsg Exp $	*/
d50 6
d115 1
a115 1
static int
d125 6
d166 6
d174 1
a428 1
	static int recursion;
d469 32
a508 2
	size_t read;
	char *errmsg = NULL;
d510 3
d520 54
a573 4
	cp = filename(fname, &partition);
	if (cp) {
		strlcpy(buf, cp, sizeof buf);
		*cp = 0;
d575 35
a609 10
	if (!cp || !*buf)
		strlcpy(buf, DEFAULT_KERNEL, sizeof buf);
	if (!*fname)
		strlcpy(fname, bootdev, sizeof fname);
	strlcpy(opened_name, fname, sizeof opened_name);
	if (partition) {
		cp = opened_name + strlen(opened_name);
		*cp++ = ':';
		*cp++ = partition;
		*cp = 0;
d611 1
a611 5
	if (*buf != '/')
		strlcat(opened_name, "/", sizeof opened_name);
	strlcat(opened_name, buf, sizeof opened_name);
	*file = opened_name + strlen(fname) + 1;
	DNPRINTF(BOOT_D_OFDEV, "devopen: trying %s\n", fname);
d629 2
d632 4
a635 25
		ofdev.type = OFDEV_DISK;
		ofdev.bsize = DEV_BSIZE;
		/* First try to find a disklabel without MBR partitions */
		DNPRINTF(BOOT_D_OFDEV, "devopen: trying to read disklabel\n");
		if (strategy(&ofdev, F_READ,
			     LABELSECTOR, DEV_BSIZE, buf, &read) != 0
		    || read != DEV_BSIZE
		    || (errmsg = getdisklabel(buf, &label))) {
#ifdef BOOT_DEBUG
			if (errmsg)
				DNPRINTF(BOOT_D_OFDEV,
				    "devopen: getdisklabel says %s\n", errmsg);
#endif
			/* Else try MBR partitions */
			errmsg = search_label(&ofdev, LABELSECTOR, buf,
			    &label, 0);
			if (errmsg) { 
				printf("devopen: search_label says %s\n", errmsg);
				error = ERDLAB;
			}
			if (error && error != ERDLAB)
				goto bad;
		}

		if (error == ERDLAB) {
@


1.21
log
@instead of reading past the end of the sun_fstypes array
assume FS_BSDFFS for partitions 8-15 in extended sun labels
as suggested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ofdev.c,v 1.20 2013/11/05 00:51:58 krw Exp $	*/
a446 1
	bzero(buf, sizeof(buf));
@


1.20
log
@Replace direct references to p_size, p_offset and d_secperunit with
DL_[GET|SET]PSIZE(), DL_[GET|SET]POFFSET(), DL_[GET|SET]DSIZE() in
order to get|set correct value that includes the high bits of the
value.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofdev.c,v 1.19 2013/10/20 10:11:17 krw Exp $	*/
d342 4
a345 6
			npp->p_fstype = sun_fstypes[i+8];
			if (npp->p_fstype == FS_BSDFFS) {
				npp->p_fragblock =
				    DISKLABELV1_FFS_FRAGBLOCK(2048, 8);
				npp->p_cpg = 16;
			}
@


1.19
log
@(daddr_t) -> (u_int64_t) when multiplying ncylinders * secpercyl to
get disk size, since DL_SETDSIZE() takes disk sector values, not
512-byte block values.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofdev.c,v 1.18 2013/06/11 16:42:12 deraadt Exp $	*/
d419 2
a420 2
	if (lp->d_secperunit == 0)
		lp->d_secperunit = 0x1fffffff;
d422 3
a424 3
	if (lp->d_partitions[0].p_size == 0)
		lp->d_partitions[0].p_size = 0x1fffffff;
	lp->d_partitions[0].p_offset = 0;
@


1.18
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: ofdev.c,v 1.17 2011/03/13 00:13:53 deraadt Exp $	*/
d275 1
a275 1
		DL_SETDSIZE(lp, (daddr_t)secpercyl * sl->sl_ncylinders);
@


1.17
log
@Change daddr_t to daddr32_t.  The bootblocks on our architectures only
do 32-bit block spanning.  If later on we get some that can/should do
64-bit, that can be done now using daddr64_t (but of course, we are taking
this step to finalize the daddr_t 64-bit conversion).
ok miod krw
@
text
@d1 1
a1 1
/*	$OpenBSD: ofdev.c,v 1.16 2010/09/08 15:25:43 jsing Exp $	*/
d275 1
a275 1
		DL_SETDSIZE(lp, (daddr64_t)secpercyl * sl->sl_ncylinders);
@


1.16
log
@Use the offset value passed into search_label() and call it with
LABELSECTOR instead of a hardcoded 0. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofdev.c,v 1.15 2010/09/08 14:52:26 jsing Exp $	*/
d110 1
a110 1
strategy(void *devdata, int rw, daddr_t blk, size_t size, void *buf,
@


1.15
log
@Sync disklabel_sun_to_bsd() with sparc64/disksubr.c. This gives us access
to the extended partition information and allows for correct
identification of parition types.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofdev.c,v 1.13 2010/04/23 15:25:21 jsing Exp $	*/
d426 1
a426 1
	if (strategy(devp, F_READ, LABELSECTOR, DEV_BSIZE, buf, &read)
d525 2
a526 1
			errmsg = search_label(&ofdev, 0, buf, &label, 0);
@


1.14
log
@Since libsa/stand.h provides an extern declaration of devsw[], we should make
it static here.  Makes gcc4 happier.
@
text
@d222 18
a240 2
 * Returns NULL on success, else an error string.
 *
d243 2
a244 2
static char *
disklabel_sun_to_bsd(char *cp, struct disklabel *lp)
d246 3
a248 1
	struct sun_disklabel *sl;
d250 1
a250 1
	struct sun_dkpart *spp;
a251 3
	u_short cksum, *sp1, *sp2;

	sl = (struct sun_disklabel *)cp;
a255 1
	cksum = 0;
d259 1
a259 1
		return("SunOS disk label, bad checksum");
d264 1
d267 3
a269 3
	lp->d_secsize = 512;
	lp->d_nsectors   = sl->sl_nsectors;
	lp->d_ntracks    = sl->sl_ntracks;
d273 6
a278 2
	lp->d_secpercyl  = secpercyl;
	lp->d_secperunit = secpercyl * sl->sl_ncylinders;
d280 1
a280 1
	lp->d_acylinders   = sl->sl_acylinders;
d290 3
a292 5
		npp->p_offset = spp->sdkp_cyloffset * secpercyl;
		npp->p_size = spp->sdkp_nsectors;
		DNPRINTF(BOOT_D_OFDEV, "partition %d start %x size %x\n",
		    i, (int)npp->p_offset, (int)npp->p_size);
		if (npp->p_size == 0) {
d302 80
a381 1
				    DISKLABELV1_FFS_FRAGBLOCK(1024, 8);
d383 8
d398 1
a398 1
	return (NULL);
d429 2
a430 1
	/* Check for a NetBSD disk label. */
d434 1
a434 1
			return ("NetBSD disk label corrupted");
d436 1
a436 1
		DNPRINTF(BOOT_D_OFDEV, "search_label: found NetBSD label\n");
d441 7
a447 4
	slp = (struct sun_disklabel *) buf;
	if (slp->sl_magic == SUN_DKMAGIC)
		return (disklabel_sun_to_bsd(buf, lp));

@


1.13
log
@Recycle unused disklabel fields in order to create a disklabel unique
identifier, allowing the disk to be identified without relying on the
device name.

ok deraadt@@ krw@@ beck@@ marco@@ todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ofdev.c,v 1.11 2009/08/17 14:23:09 jsing Exp $	*/
d158 1
a158 1
static struct devsw devsw[1] = {
@


1.12
log
@Replace the #ifdef NON_DEBUG and #ifdef NOTDEF_DEBUG mess with more sane
DPRINTF/DNPRINTF() debugging.
@
text
@a260 1
	lp->d_sparespercyl = sl->sl_sparespercyl;
a261 2
	lp->d_rpm          = sl->sl_rpm;
	lp->d_interleave   = sl->sl_interleave;
@


1.11
log
@Use ANSI function declarations. No binary change.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ofdev.c,v 1.9 2007/05/29 06:28:15 otto Exp $	*/
d80 2
a81 4
#ifdef NOTDEF_DEBUG
		printf("filename: OF_finddevice(%s) says %x\n",
		       str, dhandle);
#endif
d88 2
a89 3
#ifdef NOTDEF_DEBUG
				printf("filename: hunting for arguments in %s\n", str);
#endif
d100 1
a100 3
#ifdef NOTDEF_DEBUG
			printf("filename: found %s\n",lp);
#endif
d105 1
a105 3
#ifdef NOTDEF_DEBUG
	printf("filename: not found\n",lp);
#endif
d122 4
a125 6
#ifdef NON_DEBUG
	printf("strategy: block %lx, partition offset %lx, blksz %lx\n", 
	       (long)blk, (long)dev->partoff, (long)dev->bsize);
	printf("strategy: seek position should be: %lx\n", 
	       (long)((blk + dev->partoff) * dev->bsize));
#endif
d129 1
a129 3
#ifdef NON_DEBUG
		printf("strategy: seeking to %lx\n", (long)pos);
#endif
d132 2
a133 3
#ifdef NON_DEBUG
		printf("strategy: reading %lx at %p\n", (long)size, buf);
#endif
d200 1
d276 2
a277 3
#ifdef NOTDEF_DEBUG
		printf("partition %d start %x size %x\n", i, (int)npp->p_offset, (int)npp->p_size);
#endif
d296 1
a296 3
#ifdef NOTDEF_DEBUG
	printf("disklabel_sun_to_bsd: success!\n");
#endif
d334 1
a334 3
#ifdef NOTDEF_DEBUG
		printf("search_label: found NetBSD label\n");
#endif
d365 1
a365 3
#ifdef NOTDEF_DEBUG
	printf("devopen: you want %s\n", name);
#endif
d387 1
a387 3
#ifdef NOTDEF_DEBUG
	printf("devopen: trying %s\n", fname);
#endif
d390 1
a390 3
#ifdef NOTDEF_DEBUG
	printf("devopen: found %s\n", fname);
#endif
d393 1
a393 3
#ifdef NOTDEF_DEBUG
	printf("devopen: %s is called %s\n", fname, buf);
#endif
d396 2
a397 6
#ifdef NOTDEF_DEBUG
	printf("devopen: %s is a %s device\n", fname, buf);
#endif
#ifdef NOTDEF_DEBUG
	printf("devopen: opening %s\n", fname);
#endif
d399 1
a399 3
#ifdef NOTDEF_DEBUG
		printf("devopen: open of %s failed\n", fname);
#endif
d402 1
a402 3
#ifdef NOTDEF_DEBUG
	printf("devopen: %s is now open\n", fname);
#endif
d409 1
a409 3
#ifdef NOTDEF_DEBUG
		printf("devopen: trying to read disklabel\n");
#endif
d414 4
a417 2
#ifdef NOTDEF_DEBUG
			if (errmsg) printf("devopen: getdisklabel says %s\n", errmsg);
d438 2
a439 4
#ifdef NOTDEF_DEBUG
			printf("devopen: setting partition %d offset %x\n",
			       part, ofdev.partoff);
#endif
d451 1
a451 3
#ifdef NOTDEF_DEBUG
		printf("devopen: return 0\n");
#endif
d468 2
a469 3
#ifdef NOTDEF_DEBUG
	printf("devopen: error %d, cannot open device\n", error);
#endif
@


1.10
log
@The only value that d_npartitions should have is MAXPARTITIONS.
@
text
@d63 1
a63 3
filename(str, ppart)
	char *str;
	char *ppart;
d117 2
a118 7
strategy(devdata, rw, blk, size, buf, rsize)
	void *devdata;
	int rw;
	daddr_t blk;
	size_t size;
	void *buf;
	size_t *rsize;
d158 1
a158 2
devclose(of)
	struct open_file *of;
d206 1
a206 2
get_long(p)
	const void *p;
d239 1
a239 3
disklabel_sun_to_bsd(cp, lp)
	char *cp;
	struct disklabel *lp;
d318 2
a319 6
search_label(devp, off, buf, lp, off0)
	struct of_dev *devp;
	u_long off;
	char *buf;
	struct disklabel *lp;
	u_long off0;
d365 1
a365 4
devopen(of, name, file)
	struct open_file *of;
	const char *name;
	char **file;
@


1.9
log
@Updated disklabel format to support larger disks and partitions. We
free room in struct partition by packing fragment size and
fragments/block more tighlty and use the resulting space to make
offset and size 48 bits.  For the disk part we use spare fields in
struct disklabel.  Kernel converts in-mem copy of the on-disk
label if needed, disklabel(8) writes new version.
We are careful to only change fields not used by bootloaders.
Conception of basic scheme by deraadt.
ok deraadt@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ofdev.c,v 1.8 2006/07/27 20:41:29 deraadt Exp $	*/
d288 1
a288 1
	lp->d_npartitions = 8;
d349 1
a349 1
	lp->d_npartitions = 1;
@


1.8
log
@remove weird floppyboot garbage; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: ofdev.c,v 1.7 2006/03/04 19:33:21 miod Exp $	*/
d310 2
a311 2
				npp->p_fsize = 1024;
				npp->p_frag = 8;
@


1.7
log
@Typos grab bag of the month, eyeballed by jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ofdev.c,v 1.6 2003/05/13 01:48:55 jason Exp $	*/
a211 1
int floppyboot;
a435 1
	floppyboot = !strcmp(buf, "floppy");
@


1.6
log
@kill a stupid warning
@
text
@d1 1
a1 1
/*	$OpenBSD: ofdev.c,v 1.5 2003/04/06 18:54:20 ho Exp $	*/
d347 1
a347 1
	/* minimal requirements for archtypal disk label */
@


1.5
log
@strcat/strcpy/sprintf cleanup. krw@@, anil@@ ok. art@@ tested sparc64.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofdev.c,v 1.4 2002/07/10 20:30:15 jsyn Exp $	*/
d468 1
d470 1
@


1.4
log
@'sez' is not an english word; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ofdev.c,v 1.3 2002/03/14 01:26:46 millert Exp $	*/
d403 1
a403 1
	strcpy(fname, name);
d406 1
a406 1
		strcpy(buf, cp);
d410 1
a410 1
		strcpy(buf, DEFAULT_KERNEL);
d412 2
a413 2
		strcpy(fname, bootdev);
	strcpy(opened_name, fname);
d421 2
a422 2
		strcat(opened_name, "/");
	strcat(opened_name, buf);
@


1.3
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: ofdev.c,v 1.2 2001/08/20 19:55:33 jason Exp $	*/
d83 1
a83 1
		printf("filename: OF_finddevice(%s) sez %x\n",
d468 1
a468 1
			if (errmsg) printf("devopen: getdisklabel sez %s\n", errmsg);
d472 1
a472 1
				printf("devopen: search_label sez %s\n", errmsg);
@


1.2
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d181 1
a181 1
	(int (*)__P((struct open_file *, ...)))nodev,
@


1.2.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ofdev.c,v 1.2 2001/08/20 19:55:33 jason Exp $	*/
d181 1
a181 1
	(int (*)(struct open_file *, ...))nodev,
@


1.2.6.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ofdev.c,v 1.2.6.1 2002/06/11 03:38:44 art Exp $	*/
d83 1
a83 1
		printf("filename: OF_finddevice(%s) says %x\n",
d468 1
a468 1
			if (errmsg) printf("devopen: getdisklabel says %s\n", errmsg);
d472 1
a472 1
				printf("devopen: search_label says %s\n", errmsg);
@


1.2.6.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d403 1
a403 1
	strlcpy(fname, name, sizeof fname);
d406 1
a406 1
		strlcpy(buf, cp, sizeof buf);
d410 1
a410 1
		strlcpy(buf, DEFAULT_KERNEL, sizeof buf);
d412 2
a413 2
		strlcpy(fname, bootdev, sizeof fname);
	strlcpy(opened_name, fname, sizeof opened_name);
d421 2
a422 2
		strlcat(opened_name, "/", sizeof opened_name);
	strlcat(opened_name, buf, sizeof opened_name);
a467 1
#ifdef NOTDEF_DEBUG
a468 1
#endif
@


1.2.4.1
log
@Sync the SMP branch to something just after 3.0
@
text
@@


1.2.4.2
log
@Merge in -current from about a week ago
@
text
@d181 1
a181 1
	(int (*)(struct open_file *, ...))nodev,
@


1.2.4.3
log
@Sync the SMP branch with 3.3
@
text
@d83 1
a83 1
		printf("filename: OF_finddevice(%s) says %x\n",
d468 1
a468 1
			if (errmsg) printf("devopen: getdisklabel says %s\n", errmsg);
d472 1
a472 1
				printf("devopen: search_label says %s\n", errmsg);
@


1.2.4.4
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofdev.c,v 1.2.4.3 2003/03/27 23:42:38 niklas Exp $	*/
d403 1
a403 1
	strlcpy(fname, name, sizeof fname);
d406 1
a406 1
		strlcpy(buf, cp, sizeof buf);
d410 1
a410 1
		strlcpy(buf, DEFAULT_KERNEL, sizeof buf);
d412 2
a413 2
		strlcpy(fname, bootdev, sizeof fname);
	strlcpy(opened_name, fname, sizeof opened_name);
d421 2
a422 2
		strlcat(opened_name, "/", sizeof opened_name);
	strlcat(opened_name, buf, sizeof opened_name);
@


1.2.4.5
log
@merge the trunk so we will get the genfs and locking fixes
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a467 1
#ifdef NOTDEF_DEBUG
a468 1
#endif
@


1.1
log
@Initial revision
@
text
@d1 1
@


1.1.1.1
log
@Enough of NetBSD/sparc64 for ofwboot to compile/link
@
text
@@
