head	1.27;
access;
symbols
	OPENBSD_6_2:1.27.0.6
	OPENBSD_6_2_BASE:1.27
	OPENBSD_6_1:1.27.0.4
	OPENBSD_6_1_BASE:1.27
	OPENBSD_6_0:1.25.0.2
	OPENBSD_6_0_BASE:1.25
	OPENBSD_5_9:1.24.0.2
	OPENBSD_5_9_BASE:1.24
	OPENBSD_5_8:1.23.0.6
	OPENBSD_5_8_BASE:1.23
	OPENBSD_5_7:1.23.0.2
	OPENBSD_5_7_BASE:1.23
	OPENBSD_5_6:1.20.0.6
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.20.0.4
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.19.0.2
	OPENBSD_5_4_BASE:1.19
	OPENBSD_5_3:1.18.0.10
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.18.0.8
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.6
	OPENBSD_5_0:1.18.0.4
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.18.0.2
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.16.0.4
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.16.0.2
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.14.0.12
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.14.0.8
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.14.0.6
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.14.0.4
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.14.0.2
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.12.0.4
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.2
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.11.0.10
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.8
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.11.0.6
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.4
	OPENBSD_3_6_BASE:1.11
	SMP_SYNC_A:1.11
	SMP_SYNC_B:1.11
	OPENBSD_3_5:1.11.0.2
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	UBC_SYNC_A:1.7
	OPENBSD_3_3:1.6.0.6
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.4
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	UBC_SYNC_B:1.6
	UBC:1.4.0.6
	UBC_BASE:1.4
	SMP:1.4.0.4
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	SPARC64:1.1.1.1
	NETBSD:1.1.1;
locks; strict;
comment	@ * @;


1.27
date	2016.09.11.17.53.26;	author jsing;	state Exp;
branches;
next	1.26;
commitid	BqYFMxtCOwuz1mwM;

1.26
date	2016.09.11.15.54.11;	author jsing;	state Exp;
branches;
next	1.25;
commitid	m28Q0aUDbVqwDb3p;

1.25
date	2016.03.07.13.21.51;	author naddy;	state Exp;
branches;
next	1.24;
commitid	EDvRPKRZUDEEb6oR;

1.24
date	2015.11.16.19.33.52;	author miod;	state Exp;
branches;
next	1.23;
commitid	5gnqUR6VheSiU9SF;

1.23
date	2014.12.11.10.52.07;	author stsp;	state Exp;
branches;
next	1.22;
commitid	AcCMrLP5TaKCllOs;

1.22
date	2014.12.09.18.05.16;	author stsp;	state Exp;
branches;
next	1.21;
commitid	p8TgAnVNHMlozyJa;

1.21
date	2014.11.26.20.30.41;	author stsp;	state Exp;
branches;
next	1.20;
commitid	e315CjZvNnS0qsAl;

1.20
date	2013.12.28.21.00.21;	author kettenis;	state Exp;
branches;
next	1.19;

1.19
date	2013.03.21.21.51.01;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2010.08.25.12.53.38;	author jsing;	state Exp;
branches;
next	1.17;

1.17
date	2010.08.21.17.22.42;	author jsing;	state Exp;
branches;
next	1.16;

1.16
date	2009.11.04.12.03.57;	author jsing;	state Exp;
branches;
next	1.15;

1.15
date	2009.08.17.14.23.09;	author jsing;	state Exp;
branches;
next	1.14;

1.14
date	2007.05.29.00.03.13;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2007.05.03.18.38.11;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2006.07.27.20.41.28;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2004.01.03.21.17.43;	author pvalchev;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.10.02.42.58;	author brad;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.03.15.59.03;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2003.06.01.17.00.40;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2003.05.11.20.22.20;	author mdw;	state Exp;
branches;
next	1.6;

1.6
date	2002.03.14.03.16.01;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.03.14.01.26.46;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.08.23.14.35.53;	author art;	state Exp;
branches
	1.4.4.1
	1.4.6.1;
next	1.3;

1.3
date	2001.08.20.19.55.33;	author jason;	state Exp;
branches;
next	1.2;

1.2
date	2001.08.19.16.46.04;	author art;	state Exp;
branches;
next	1.1;

1.1
date	2001.08.18.15.50.55;	author jason;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.08.18.15.50.55;	author jason;	state Exp;
branches;
next	;

1.4.4.1
date	2001.10.31.03.07.59;	author nate;	state Exp;
branches;
next	1.4.4.2;

1.4.4.2
date	2002.03.28.11.23.52;	author niklas;	state Exp;
branches;
next	1.4.4.3;

1.4.4.3
date	2003.05.13.19.41.09;	author ho;	state Exp;
branches;
next	1.4.4.4;

1.4.4.4
date	2003.06.07.11.14.46;	author ho;	state Exp;
branches;
next	1.4.4.5;

1.4.4.5
date	2004.02.19.10.50.02;	author niklas;	state Exp;
branches;
next	;

1.4.6.1
date	2002.06.11.03.38.44;	author art;	state Exp;
branches;
next	1.4.6.2;

1.4.6.2
date	2003.05.19.21.46.58;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.27
log
@Switch sparc64 boot code to libsa MI softraid.
@
text
@/*	$OpenBSD: boot.c,v 1.26 2016/09/11 15:54:11 jsing Exp $	*/
/*	$NetBSD: boot.c,v 1.3 2001/05/31 08:55:19 mrg Exp $	*/
/*
 * Copyright (c) 1997, 1999 Eduardo E. Horvath.  All rights reserved.
 * Copyright (c) 1997 Jason R. Thorpe.  All rights reserved.
 * Copyright (C) 1995, 1996 Wolfgang Solfrank.
 * Copyright (C) 1995, 1996 TooLs GmbH.
 * All rights reserved.
 *
 * ELF support derived from NetBSD/alpha's boot loader, written
 * by Christopher G. Demetriou.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by TooLs GmbH.
 * 4. The name of TooLs GmbH may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY TOOLS GMBH ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL TOOLS GMBH BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * First try for the boot code
 *
 * Input syntax is:
 *	[promdev[{:|,}partition]]/[filename] [flags]
 */

#define ELFSIZE 64

#include <lib/libsa/stand.h>

#include <sys/param.h>
#include <sys/exec.h>
#include <sys/exec_elf.h>
#include <sys/reboot.h>
#include <sys/disklabel.h>
#include <machine/boot_flag.h>

#include <machine/cpu.h>

#ifdef SOFTRAID
#include <sys/param.h>
#include <sys/queue.h>
#include <dev/biovar.h>
#include <dev/softraidvar.h>
#include <lib/libsa/softraid.h>

#include "disk.h"
#include "softraid_sparc64.h"
#endif

#include "ofdev.h"
#include "openfirm.h"

#ifdef BOOT_DEBUG
uint32_t	boot_debug = 0
		    /* | BOOT_D_OFDEV */
		    /* | BOOT_D_OFNET */
		;
#endif

#define	MEG	(1024*1024)

/*
 * Boot device is derived from ROM provided information, or if there is none,
 * this list is used in sequence, to find a kernel.
 */
char *kernels[] = {
	"bsd",
	NULL
};

char bootdev[128];
char bootfile[128];
int boothowto;
int debug;

char rnddata[BOOTRANDOM_MAX];

int	elf64_exec(int, Elf64_Ehdr *, u_int64_t *, void **, void **);

/*
 *	parse:
 *		[kernel-name] [-options]
 *	leave kernel-name in passed-in string
 *	put options into *howtop
 *	return -1 iff syntax error (no - before options)
 */

static int
parseargs(char *str, int *howtop)
{
	char *cp;
	int i;

	*howtop = 0;
	cp = str;
	while (*cp == ' ')
		++cp;
	if (*cp != '-') {
		while (*cp && *cp != ' ')
			*str++ = *cp++;
		while (*cp == ' ')
			++cp;
	}
	*str = 0;
	switch(*cp) {
	default:
		printf ("boot options string <%s> must start with -\n", cp);
		return -1;
	case 0:
		return 0;
	case '-':
		break;
	}

	++cp;
	while (*cp) {
		BOOT_FLAG(*cp, *howtop);
		/* handle specialties */
		switch (*cp++) {
		case 'd':
			if (!debug) debug = 1;
			break;
		case 'D':
			debug = 2;
			break;
		}
	}
	return 0;
}


static void
chain(u_int64_t pentry, char *args, void *ssym, void *esym)
{
	extern char end[];
	void (*entry)();
	int l, machine_tag;
	long newargs[3];

	entry = (void *)(long)pentry;

	/*
	 * When we come in args consists of a pointer to the boot
	 * string.  We need to fix it so it takes into account
	 * other params such as romp.
	 */

	/*
	 * Stash pointer to end of symbol table after the argument
	 * strings.
	 */
	l = strlen(args) + 1;
	bcopy(&esym, args + l, sizeof(esym));
	l += sizeof(esym);

	/*
	 * Tell the kernel we're an OpenFirmware system.
	 */
#define SPARC_MACHINE_OPENFIRMWARE		0x44444230
	machine_tag = SPARC_MACHINE_OPENFIRMWARE;
	bcopy(&machine_tag, args + l, sizeof(machine_tag));
	l += sizeof(machine_tag);

	/* 
	 * Since we don't need the boot string (we can get it from /chosen)
	 * we won't pass it in.  Just pass in esym and magic #
	 */
	newargs[0] = SPARC_MACHINE_OPENFIRMWARE;
	newargs[1] = (long)esym;
	newargs[2] = (long)ssym;
	args = (char *)newargs;
	l = sizeof(newargs);

#ifdef DEBUG
	printf("chain: calling OF_chain(%x, %x, %x, %x, %x)\n",
	    (void *)RELOC, end - (char *)RELOC, entry, args, l);
#endif
	/* if -D is set then pause in the PROM. */
	if (debug > 1) OF_enter();
	OF_chain((void *)RELOC, ((end - (char *)RELOC)+PAGE_SIZE)%PAGE_SIZE,
	    entry, args, l);
	panic("chain");
}

int
loadfile(int fd, char *args)
{
	union {
		Elf64_Ehdr elf64;
	} hdr;
	int rval;
	u_int64_t entry = 0;
	void *ssym;
	void *esym;

	ssym = NULL;
	esym = NULL;

	/* Load the header. */
#ifdef DEBUG
	printf("loadfile: reading header\n");
#endif
	if ((rval = read(fd, &hdr, sizeof(hdr))) != sizeof(hdr)) {
		if (rval == -1)
			printf("read header: %s\n", strerror(errno));
		else
			printf("read header: short read (only %d of %d)\n",
			    rval, sizeof(hdr));
		rval = 1;
		goto err;
	}

	/* Determine file type, load kernel. */
	if (bcmp(hdr.elf64.e_ident, ELFMAG, SELFMAG) == 0 &&
	    hdr.elf64.e_ident[EI_CLASS] == ELFCLASS64) {
		printf("Booting %s\n", opened_name);
		rval = elf64_exec(fd, &hdr.elf64, &entry, &ssym, &esym);
	} else {
		rval = 1;
		printf("unknown executable format\n");
	}

	if (rval)
		goto err;

	printf(" start=0x%lx\n", (unsigned long)entry);

	close(fd);

#ifdef SOFTRAID
	sr_clear_keys();
#endif
	chain(entry, args, ssym, esym);
	/* NOTREACHED */

 err:
	close(fd);
	return (rval);
}

int
loadrandom(char *path, char *buf, size_t buflen)
{
	struct stat sb;
	int fd, i;

#define O_RDONLY	0

	fd = open(path, O_RDONLY);
	if (fd == -1)
		return -1;
	if (fstat(fd, &sb) == -1 ||
	    sb.st_uid != 0 ||
	    (sb.st_mode & (S_IWOTH|S_IROTH)))
		goto fail;
	if (read(fd, buf, buflen) != buflen)
		goto fail;
	close(fd);
 	return 0;
fail:
	close(fd);
	return (-1);
}

#ifdef SOFTRAID
/* Set bootdev_dip to the software boot volume, if specified. */
static int
srbootdev(const char *bootline)
{
	struct sr_boot_volume *bv;
	struct diskinfo *dip;
	int unit;

	bootdev_dip = NULL;

	/* 
	 * Look for softraid disks in bootline.
	 * E.g. 'sr0', 'sr0:bsd', or 'sr0a:/bsd'
	 */
	if (bootline[0] == 's' && bootline[1] == 'r' &&
	    '0' <= bootline[2] && bootline[2] <= '9') {
		unit = bootline[2] - '0';

		/* Create a fake diskinfo for this softraid volume. */
		SLIST_FOREACH(bv, &sr_volumes, sbv_link)
			if (bv->sbv_unit == unit)
				break;
		if (bv == NULL) {
			printf("Unknown device: sr%d\n", unit);
			return ENODEV;
		}

		if ((bv->sbv_flags & BIOC_SCBOOTABLE) == 0) {
			printf("device sr%d is not bootable\n", unit);
			return ENODEV;
		}

		if (bv->sbv_level == 'C' && bv->sbv_keys == NULL)
			if (sr_crypto_decrypt_keys(bv) != 0)
				return EPERM;

		if (bv->sbv_diskinfo == NULL) {
			dip = alloc(sizeof(struct diskinfo));
			bzero(dip, sizeof(*dip));
			dip->sr_vol = bv;
			bv->sbv_diskinfo = dip;
		}

		/* strategy() and devopen() will use bootdev_dip */
		bootdev_dip = bv->sbv_diskinfo;

		/* Attempt to read disklabel. */
		bv->sbv_part = 'c';
		if (sr_getdisklabel(bv, &dip->disklabel)) {
			free(bv->sbv_diskinfo, sizeof(struct diskinfo));
			bv->sbv_diskinfo = NULL;
			bootdev_dip = NULL;
			return ERDLAB;
		}
	}

	return 0;
}
#endif

int
main(void)
{
	extern char version[];
	int chosen;
	char bootline[512];		/* Should check size? */
	char *cp;
	int i, fd, len;
#ifdef SOFTRAID
	int err;
#endif
	char **bootlp;
	char *just_bootline[2];
	
	printf(">> OpenBSD BOOT %s\n", version);

	/*
	 * Get the boot arguments from Openfirmware
	 */
	if ((chosen = OF_finddevice("/chosen")) == -1 ||
	    OF_getprop(chosen, "bootpath", bootdev, sizeof bootdev) < 0 ||
	    OF_getprop(chosen, "bootargs", bootline, sizeof bootline) < 0) {
		printf("Invalid Openfirmware environment\n");
		exit();
	}

#ifdef SOFTRAID
	diskprobe();
	srprobe();
	err = srbootdev(bootline);
	if (err) {
		printf("Cannot boot from softraid: %s\n", strerror(err));
		_rtt();
	}
#endif

	/*
	 * case 1:	boot net -a
	 *			-> getln loop
	 * case 2:	boot net kernel [options]
	 *			-> boot kernel, getln loop
	 * case 3:	boot net [options]
	 *			-> iterate boot list, getln loop
	 */

	bootlp = kernels;
	if (parseargs(bootline, &boothowto) == -1 ||
	    (boothowto & RB_ASKNAME)) {
		bootlp = 0;
	} else if (*bootline) {
		just_bootline[0] = bootline;
		just_bootline[1] = 0;
		bootlp = just_bootline;
	}
	for (;;) {
		if (bootlp) {
			cp = *bootlp++;
			if (!cp) {
				printf("\n");
				bootlp = 0;
				kernels[0] = 0;	/* no more iteration */
			} else if (cp != bootline) {
				printf("Trying %s...\n", cp);
				if (strlcpy(bootline, cp, sizeof bootline)
				    >= sizeof bootline) {
					printf("bootargs too long: %s\n",
					    bootline);
					_rtt();
				}	
			}
		}
		if (!bootlp) {
			printf("Boot: ");
			getln(bootline, sizeof bootline);
			if (parseargs(bootline, &boothowto) == -1)
				continue;
			if (!*bootline) {
				bootlp = kernels;
				continue;
			}
			if (strcmp(bootline, "exit") == 0 ||
			    strcmp(bootline, "halt") == 0) {
				_rtt();
			}
		}
		if (loadrandom(BOOTRANDOM, rnddata, sizeof(rnddata)))
			printf("open %s: %s\n", opened_name, strerror(errno));
		if ((fd = open(bootline, 0)) < 0) {
			printf("open %s: %s\n", opened_name, strerror(errno));
			continue;
		}
		len = snprintf(bootline, sizeof bootline, "%s%s%s%s",
		    opened_name,
		    (boothowto & RB_ASKNAME) ? " -a" : "",
		    (boothowto & RB_SINGLE) ? " -s" : "",
		    (boothowto & RB_KDB) ? " -d" : "");
		if (len >= sizeof bootline) {
			printf("bootargs too long: %s\n", bootline);
			_rtt();
		}
		/* XXX void, for now */
#ifdef DEBUG
		if (debug)
			printf("main: Calling loadfile(fd, %s)\n", bootline);
#endif
		(void)loadfile(fd, bootline);
	}
	return 0;
}
@


1.26
log
@Rename softraid boot files, which are currently in an MD location. This
will allow us to bring in a MI softraid.{c,h} in lib/libsa.
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.25 2016/03/07 13:21:51 naddy Exp $	*/
d64 1
@


1.25
log
@Sync no-argument function declaration and definition by adding (void).
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.24 2015/11/16 19:33:52 miod Exp $	*/
d66 1
a66 1
#include "softraid.h"
@


1.24
log
@Replace unbounded gets() in libsa with getln() which takes a buffer size,
and convert all gets() users.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.23 2014/12/11 10:52:07 stsp Exp $	*/
d346 1
a346 1
main()
@


1.23
log
@Delete #ifdef'd code that hasn't been compiled in years from sparc64 ofwboot.
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.22 2014/12/09 18:05:16 stsp Exp $	*/
d383 1
a383 1
	 *			-> gets loop
d385 1
a385 1
	 *			-> boot kernel, gets loop
d387 1
a387 1
	 *			-> iterate boot list, gets loop
d418 1
a418 1
			gets(bootline);
@


1.22
log
@Check strlcpy(), strlcat(), and snprintf() return values in sparc64 ofwboot.
tweak and ok millert@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.21 2014/11/26 20:30:41 stsp Exp $	*/
a98 17
#if 0
static void
prom2boot(char *dev)
{
	char *cp, *lp = 0;
	int handle;
	char devtype[16];
	
	for (cp = dev; *cp; cp++)
		if (*cp == ':')
			lp = cp;
	if (!lp)
		lp = cp;
	*lp = 0;
}
#endif

a160 1
	freeall();
a435 4
#ifdef	__notyet__
		OF_setprop(chosen, "bootpath", opened_name, strlen(opened_name) + 1);
		cp = bootline;
#else
a444 4
#endif
#ifdef	__notyet__
		OF_setprop(chosen, "bootargs", bootline, strlen(bootline) + 1);
#endif
@


1.21
log
@Introduce softraid boot support to sparc64 ofwboot.
sparc64 machines should now be able to boot from softraid raid1 and crypto.
Tested on sun blade100, sunfire v240, and sun t1000 ldom guests.
Lots of encouragement from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.20 2013/12/28 21:00:21 kettenis Exp $	*/
d370 1
a370 1
	int i, fd;
d426 6
a431 1
				strlcpy(bootline, cp, sizeof bootline);
d458 9
a466 1
		strlcpy(bootline, opened_name, sizeof bootline);
a467 6
		if (boothowto & RB_ASKNAME)
			strlcat(bootline, " -a", sizeof bootline);
		if (boothowto & RB_SINGLE)
			strlcat(bootline, " -s", sizeof bootline);
		if (boothowto & RB_KDB)
			strlcat(bootline, " -d", sizeof bootline);
@


1.20
log
@Try to load entropy data from disk:/etc/random.seed.  Then, insert this into
the ELF openbsd.randomdata of the kernel, so that it has entropy right from
the start.
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.19 2013/03/21 21:51:01 deraadt Exp $	*/
d59 10
d267 3
d302 61
d371 3
d389 10
a453 2
		cp = bootline + strlen(bootline);
		*cp++ = ' ';
a454 1
		*cp = '-';
d456 1
a456 1
			*++cp = 'a';
d458 1
a458 1
			*++cp = 's';
d460 1
a460 5
			*++cp = 'd';
		if (*cp == '-')
			*--cp = 0;
		else
			*++cp = 0;
@


1.19
log
@NBPG -> PAGE_SIZE, PGSHIFT -> PAGE_SHIFT, PGOFSET -> PAGE_MASK
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.18 2010/08/25 12:53:38 jsing Exp $	*/
d85 2
d266 24
d356 2
@


1.18
log
@Remove the SPARC_BOOT_ELF define and associated machinery since it does
not make sense to compile ofwboot without support for ELF. Whilst here,
nuke the unused SPARC_BOOT_NFS define and compile elf64_exec.c as an
object rather than including it in boot.c.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.17 2010/08/21 17:22:42 jsing Exp $	*/
d205 2
a206 1
	OF_chain((void *)RELOC, ((end - (char *)RELOC)+NBPG)%NBPG, entry, args, l);
@


1.17
log
@Rename file to reflect that it handles 64 bit ELF only.

ok miod@@ (some time ago)
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.15 2009/08/17 14:23:09 jsing Exp $	*/
a84 2

#ifdef SPARC_BOOT_ELF
a85 1
#endif
a212 1
#ifdef SPARC_BOOT_ELF
a213 1
#endif
a237 1
#ifdef SPARC_BOOT_ELF
d240 1
d242 1
a242 3
	} else
#endif
	{
a260 4

#ifdef SPARC_BOOT_ELF
#include "elf64_exec.c"
#endif /* SPARC_BOOT_ELF */
@


1.16
log
@Replace the #ifdef NON_DEBUG and #ifdef NOTDEF_DEBUG mess with more sane
DPRINTF/DNPRINTF() debugging.
@
text
@d270 1
a270 1
#include "elfXX_exec.c"
@


1.15
log
@Use ANSI function declarations. No binary change.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.13 2007/05/03 18:38:11 deraadt Exp $	*/
d61 7
@


1.14
log
@remove support for many alternative kernel choices -- only try /bsd and
not the other stupid names.  that feature was retarded.  tested on a few
architectures by a few people
@
text
@d85 1
a85 2
prom2boot(dev)
	char *dev;
d109 1
a109 3
parseargs(str, howtop)
	char *str;
	int *howtop;
d153 1
a153 5
chain(pentry, args, ssym, esym)
	u_int64_t pentry;
	char *args;
	void *ssym;
	void *esym;
d206 1
a206 3
loadfile(fd, args)
	int fd;
	char *args;
@


1.13
log
@sensible version strings; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.12 2006/07/27 20:41:28 deraadt Exp $	*/
a69 1
	"obsd",
@


1.12
log
@remove weird floppyboot garbage; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.11 2004/01/03 21:17:43 pvalchev Exp $	*/
d287 1
a287 1
	printf(">> %s", version);
d325 1
a325 1
				printf(": trying %s...\n", cp);
@


1.11
log
@shut gcc up; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.10 2003/06/10 02:42:58 brad Exp $	*/
a262 7

	/* XXX this should be replaced w/ a mountroothook. */
	if (floppyboot) {
		printf("Please insert root disk and press ENTER ");
		getchar();
		printf("\n");
	}
@


1.10
log
@- rip out support for a.out and 32-bit kernels
- cleanup and simplify Makefile
jason@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.9 2003/06/03 15:59:03 deraadt Exp $	*/
d283 1
a283 1
void
d383 1
@


1.9
log
@What is it up with you sparc64 people.  Do you like sitting on critical
fixes?
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.8 2003/06/01 17:00:40 deraadt Exp $	*/
d46 1
a46 3
#ifdef ELFSIZE
#undef	ELFSIZE		/* We use both. */
#endif
a80 1
int	elf32_exec(int, Elf32_Ehdr *, u_int64_t *, void **, void **);
a83 4
#ifdef SPARC_BOOT_AOUT
int	aout_exec(int, struct exec *, u_int64_t *, void **);
#endif

a218 3
#ifdef SPARC_BOOT_AOUT
		struct exec aout;
#endif
a219 1
		Elf32_Ehdr elf32;
a245 5
#ifdef SPARC_BOOT_AOUT
	if (N_BADMAG(hdr.aout) == 0 && N_GETMID(hdr.aout) == MID_SPARC) {
		rval = aout_exec(fd, &hdr.aout, &entry, &esym);
	} else
#endif
d247 1
a247 4
	if (bcmp(hdr.elf32.e_ident, ELFMAG, SELFMAG) == 0 &&
	    hdr.elf32.e_ident[EI_CLASS] == ELFCLASS32) {
		rval = elf32_exec(fd, &hdr.elf32, &entry, &ssym, &esym);
	} else if (bcmp(hdr.elf64.e_ident, ELFMAG, SELFMAG) == 0 &&
a278 77
#ifdef SPARC_BOOT_AOUT
int
aout_exec(fd, hdr, entryp, esymp)
	int fd;
	struct exec *hdr;
	u_int64_t *entryp;
	void **esymp;
{
	void *addr;
	int n, *paddr;

#ifdef DEBUG
	printf("auout_exec: ");
#endif
	/* Display the load address (entry point) for a.out. */
	printf("Booting %s @@ 0x%lx\n", opened_name, hdr->a_entry);
	addr = (void *)((u_int64_t)hdr->a_entry);

	/*
	 * Determine memory needed for kernel and allocate it from
	 * the firmware.
	 */
	n = hdr->a_text + hdr->a_data + hdr->a_bss + hdr->a_syms + sizeof(int);
	if ((paddr = OF_claim(addr, n, 0)) == (int *)-1)
		panic("cannot claim memory");

	/* Load text. */
	lseek(fd, N_TXTOFF(*hdr), SEEK_SET);
	printf("%lu", hdr->a_text);
	if (read(fd, paddr, hdr->a_text) != hdr->a_text) {
		printf("read text: %s\n", strerror(errno));
		return (1);
	}
	syncicache((void *)paddr, hdr->a_text);

	/* Load data. */
	printf("+%lu", hdr->a_data);
	if (read(fd, (void *)paddr + hdr->a_text, hdr->a_data) != hdr->a_data) {
		printf("read data: %s\n", strerror(errno));
		return (1);
	}

	/* Zero BSS. */
	printf("+%lu", hdr->a_bss);
	bzero((void *)paddr + hdr->a_text + hdr->a_data, hdr->a_bss);

	/* Symbols. */
	*esymp = paddr;
	paddr = (int *)((void *)paddr + hdr->a_text + hdr->a_data + hdr->a_bss);
	*paddr++ = hdr->a_syms;
	if (hdr->a_syms) {
		printf(" [%lu", hdr->a_syms);
		if (read(fd, paddr, hdr->a_syms) != hdr->a_syms) {
			printf("read symbols: %s\n", strerror(errno));
			return (1);
		}
		paddr = (int *)((void *)paddr + hdr->a_syms);
		if (read(fd, &n, sizeof(int)) != sizeof(int)) {
			printf("read symbols: %s\n", strerror(errno));
			return (1);
		}
		if (OF_claim((void *)paddr, n + sizeof(int), 0) == (void *)-1)
			panic("cannot claim memory");
		*paddr++ = n;
		if (read(fd, paddr, n - sizeof(int)) != n - sizeof(int)) {
			printf("read symbols: %s\n", strerror(errno));
			return (1);
		}
		printf("+%d]", n - sizeof(int));
		*esymp = paddr + (n - sizeof(int));
	}

	*entryp = hdr->a_entry;
	return (0);
}
#endif /* SPARC_BOOT_AOUT */

a279 12
#if 1
/* New style */

#ifdef ELFSIZE
#undef ELFSIZE
#endif

#define ELFSIZE	32
#include "elfXX_exec.c"

#undef ELFSIZE
#define ELFSIZE	64
a280 147

#else
/* Old style */
int
elf32_exec(fd, elf, entryp, ssymp, esymp)
	int fd;
	Elf32_Ehdr *elf;
	u_int64_t *entryp;
	void **ssymp;
	void **esymp;
{
	Elf32_Shdr *shp;
	Elf32_Off off;
	void *addr;
	size_t size;
	int i, first = 1;
	long align;
	int n;

	/*
	 * Don't display load address for ELF; it's encoded in
	 * each section.
	 */
#ifdef DEBUG
	printf("elf_exec: ");
#endif
	printf("Booting %s\n", opened_name);

	for (i = 0; i < elf->e_phnum; i++) {
		Elf32_Phdr phdr;
		(void)lseek(fd, elf->e_phoff + sizeof(phdr) * i, SEEK_SET);
		if (read(fd, (void *)&phdr, sizeof(phdr)) != sizeof(phdr)) {
			printf("read phdr: %s\n", strerror(errno));
			return (1);
		}
		if (phdr.p_type != PT_LOAD ||
		    (phdr.p_flags & (PF_W|PF_X)) == 0)
			continue;

		/* Read in segment. */
		printf("%s%lu@@0x%lx", first ? "" : "+", phdr.p_filesz,
		    (u_long)phdr.p_vaddr);
		(void)lseek(fd, phdr.p_offset, SEEK_SET);

		/* 
		 * If the segment's VA is aligned on a 4MB boundary, align its
		 * request 4MB aligned physical memory.  Otherwise use default
		 * alignment.
		 */
		align = phdr.p_align;
		if ((phdr.p_vaddr & (4*MEG-1)) == 0)
			align = 4*MEG;
		if (OF_claim((void *)phdr.p_vaddr, phdr.p_memsz, phdr.p_align) ==
		    (void *)-1)
			panic("cannot claim memory");
		if (read(fd, (void *)phdr.p_vaddr, phdr.p_filesz) !=
		    phdr.p_filesz) {
			printf("read segment: %s\n", strerror(errno));
			return (1);
		}
		syncicache((void *)phdr.p_vaddr, phdr.p_filesz);

		/* Zero BSS. */
		if (phdr.p_filesz < phdr.p_memsz) {
			printf("+%lu@@0x%lx", phdr.p_memsz - phdr.p_filesz,
			    (u_long)(phdr.p_vaddr + phdr.p_filesz));
			bzero((void *)phdr.p_vaddr + phdr.p_filesz,
			    phdr.p_memsz - phdr.p_filesz);
		}
		first = 0;
	}

	printf(" \n");

#if 1 /* I want to rethink this... --thorpej@@netbsd.org */
	/*
	 * Compute the size of the symbol table.
	 */
	size = sizeof(Elf32_Ehdr) + (elf->e_shnum * sizeof(Elf32_Shdr));
	shp = addr = alloc(elf->e_shnum * sizeof(Elf32_Shdr));
	(void)lseek(fd, elf->e_shoff, SEEK_SET);
	if (read(fd, addr, elf->e_shnum * sizeof(Elf32_Shdr)) !=
	    elf->e_shnum * sizeof(Elf32_Shdr)) {
		printf("read section headers: %s\n", strerror(errno));
		return (1);
	}
	for (i = 0; i < elf->e_shnum; i++, shp++) {
		if (shp->sh_type == SHT_NULL)
			continue;
		if (shp->sh_type != SHT_SYMTAB &&
		    shp->sh_type != SHT_STRTAB) {
			shp->sh_offset = 0; 
			shp->sh_type = SHT_NOBITS;
			continue;
		}
		size += shp->sh_size;
	}
	shp = addr;

	/*
	 * Reserve memory for the symbols.
	 */
	if ((addr = OF_claim(0, size, NBPG)) == (void *)-1)
		panic("no space for symbol table");

	/*
	 * Copy the headers.
	 */
	elf->e_phoff = 0;
	elf->e_shoff = sizeof(Elf32_Ehdr);
	elf->e_phentsize = 0;
	elf->e_phnum = 0;
	bcopy(elf, addr, sizeof(Elf32_Ehdr));
	bcopy(shp, addr + sizeof(Elf32_Ehdr), elf->e_shnum * sizeof(Elf32_Shdr));
	free(shp, elf->e_shnum * sizeof(Elf32_Shdr));
	*ssymp = addr;

	/*
	 * Now load the symbol sections themselves.
	 */
	shp = addr + sizeof(Elf32_Ehdr);
	addr += sizeof(Elf32_Ehdr) + (elf->e_shnum * sizeof(Elf32_Shdr));
	off = sizeof(Elf32_Ehdr) + (elf->e_shnum * sizeof(Elf32_Shdr));
	for (first = 1, i = 0; i < elf->e_shnum; i++, shp++) {
		if (shp->sh_type == SHT_SYMTAB ||
		    shp->sh_type == SHT_STRTAB) {
			if (first)
				printf("symbols @@ 0x%lx ", (u_long)addr);
			printf("%s%d", first ? "" : "+", shp->sh_size);
			(void)lseek(fd, shp->sh_offset, SEEK_SET);
			if (read(fd, addr, shp->sh_size) != shp->sh_size) {
				printf("read symbols: %s\n", strerror(errno));
				return (1);
			}
			addr += (shp->sh_size+3)&(~3);
			shp->sh_offset = off;
			off += (shp->sh_size+3)&(~3);
			first = 0;
		}
	}
	*esymp = addr;
#endif /* 0 */

	*entryp = elf->e_entry;
	return (0);
}
#endif
@


1.8
log
@strcpy/strcat/sprintf removal in all bootblocks.  various testing by
various people.  outside of some messy things in src/gnu, only one
thing in the main tree now violates this rule: bind
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.7 2003/05/11 20:22:20 mdw Exp $	*/
d71 2
a72 2
	"bsd ",
	"obsd ",
@


1.7
log
@don't run off end of strings and use bad pointers
iterate boot list at most once
allow kernel names with - in them
complain about option strings that do not start with -
distinguish between short read & bad read
don't quit if a file can be opened but can't be booted
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.6 2002/03/14 03:16:01 millert Exp $	*/
d212 1
a212 1
	       (void *)RELOC, end - (char *)RELOC, entry, args, l);
d251 1
a251 1
				rval, sizeof(hdr));
d266 1
a266 2
	} else
	if (bcmp(hdr.elf64.e_ident, ELFMAG, SELFMAG) == 0 &&
d478 2
a479 2
		if (shp->sh_type != SHT_SYMTAB
		    && shp->sh_type != SHT_STRTAB) {
d513 2
a514 2
		if (shp->sh_type == SHT_SYMTAB
		    || shp->sh_type == SHT_STRTAB) {
d554 3
a556 3
	if ((chosen = OF_finddevice("/chosen")) == -1
	    || OF_getprop(chosen, "bootpath", bootdev, sizeof bootdev) < 0
	    || OF_getprop(chosen, "bootargs", bootline, sizeof bootline) < 0) {
d571 2
a572 2
	if (parseargs(bootline, &boothowto) == -1
			|| (boothowto & RB_ASKNAME)) {
d588 1
a588 1
				strcpy(bootline, cp);
d600 2
a601 2
			if (strcmp(bootline, "exit") == 0
					|| strcmp(bootline, "halt") == 0) {
d613 1
a613 1
		strcpy(bootline, opened_name);
@


1.6
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.5 2002/03/14 01:26:46 millert Exp $	*/
a75 1
char *kernelname;
d109 9
a117 1
static void
d125 19
a143 13
	/* Allow user to drop back to the PROM. */
	if (strcmp(str, "exit") == 0 || strcmp(str, "halt") == 0)
		_rtt();

	/* Insert the kernel name if it is not there. */
	if (str[0] == 0 || str[0] == '-') {
		/* Move args down the string */
		i=0;
		for (cp = str + strlen(kernelname); str[i]; i++)
			cp[i] = str[i];
		/* Copy over kernelname */
		for (i = 0; kernelname[i]; i++)
			str[i] = kernelname[i];
d145 2
a146 8
	*howtop = 0;
	for (cp = str; *cp; cp++)
		if (*cp == ' ' || *cp == '-')
			break;
	if (!*cp)
		return;
	
	*cp++ = 0;
a156 2
		default:
			break;
d159 1
a238 1
	rval = 1;
d246 7
a252 2
	if (read(fd, &hdr, sizeof(hdr)) != sizeof(hdr)) {
		printf("read header: %s\n", strerror(errno));
d273 1
d547 2
a549 3
	/* Initialize kernelname */
	kernelname = kernels[0];

d561 32
a592 6
	/*prom2boot(bootdev);*/
	kernelname = kernels[0];
	parseargs(bootline, &boothowto);
	for (i=0;;) {
		kernelname = kernels[i];
		if (boothowto & RB_ASKNAME) {
d595 10
a604 1
			parseargs(bootline, &boothowto);
d606 1
a606 3
		if ((fd = open(bootline, 0)) >= 0)
			break;
		if (errno)
d608 1
a608 11
		/*
		 * if we have are not in askname mode, and we aren't using the
		 * prom bootfile, try the next one (if it exits).  otherwise,
		 * go into askname mode.
		 */
		if ((boothowto & RB_ASKNAME) == 0 &&
		    i != -1 && kernels[++i]) {
			printf(": trying %s...\n", kernels[i]);
		} else {
			printf("\n");
			boothowto |= RB_ASKNAME;
a609 17
	}
#ifdef	__notyet__
	OF_setprop(chosen, "bootpath", opened_name, strlen(opened_name) + 1);
	cp = bootline;
#else
	strcpy(bootline, opened_name);
	cp = bootline + strlen(bootline);
	*cp++ = ' ';
#endif
	*cp = '-';
	if (boothowto & RB_ASKNAME)
		*++cp = 'a';
	if (boothowto & RB_SINGLE)
		*++cp = 's';
	if (boothowto & RB_KDB)
		*++cp = 'd';
	if (*cp == '-')
d611 2
a612 1
		*cp = 0;
d614 15
a628 4
		*--cp = 0;
#endif
	else
		*++cp = 0;
d630 1
a630 1
	OF_setprop(chosen, "bootargs", bootline, strlen(bootline) + 1);
d632 1
a632 1
	/* XXX void, for now */
d634 2
a635 2
	if (debug)
		printf("main: Calling loadfile(fd, %s)\n", bootline);
d637 2
a638 3
	(void)loadfile(fd, bootline);

	_rtt();
@


1.5
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.4 2001/08/23 14:35:53 art Exp $	*/
d169 1
a169 1
	entry = (void*)(long)pentry;
d445 1
a445 1
			bzero((void*)phdr.p_vaddr + phdr.p_filesz,
@


1.4
log
@Remove DEBUG, it's too chatty.
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.3 2001/08/20 19:55:33 jason Exp $	*/
d84 2
a85 2
int	elf32_exec __P((int, Elf32_Ehdr *, u_int64_t *, void **, void **));
int	elf64_exec __P((int, Elf64_Ehdr *, u_int64_t *, void **, void **));
d89 1
a89 1
int	aout_exec __P((int, struct exec *, u_int64_t *, void **));
@


1.4.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.4 2001/08/23 14:35:53 art Exp $	*/
d84 2
a85 2
int	elf32_exec(int, Elf32_Ehdr *, u_int64_t *, void **, void **);
int	elf64_exec(int, Elf64_Ehdr *, u_int64_t *, void **, void **);
d89 1
a89 1
int	aout_exec(int, struct exec *, u_int64_t *, void **);
d169 1
a169 1
	entry = (void *)(long)pentry;
d445 1
a445 1
			bzero((void *)phdr.p_vaddr + phdr.p_filesz,
@


1.4.6.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d76 1
d110 1
a110 9
/*
 *	parse:
 *		[kernel-name] [-options]
 *	leave kernel-name in passed-in string
 *	put options into *howtop
 *	return -1 iff syntax error (no - before options)
 */

static int
d118 14
d133 7
a139 21
	cp = str;
	while (*cp == ' ')
		++cp;
	if (*cp != '-') {
		while (*cp && *cp != ' ')
			*str++ = *cp++;
		while (*cp == ' ')
			++cp;
	}
	*str = 0;
	switch(*cp) {
	default:
		printf ("boot options string <%s> must start with -\n", cp);
		return -1;
	case 0:
		return 0;
	case '-':
		break;
	}

	++cp;
d150 2
a153 1
	return 0;
d233 1
d241 2
a242 7
	if ((rval = read(fd, &hdr, sizeof(hdr))) != sizeof(hdr)) {
		if (rval == -1)
			printf("read header: %s\n", strerror(errno));
		else
			printf("read header: short read (only %d of %d)\n",
				rval, sizeof(hdr));
		rval = 1;
a262 1
		rval = 1;
a535 2
	char **bootlp;
	char *just_bootline[2];
d537 3
d551 6
a556 32

	/*
	 * case 1:	boot net -a
	 *			-> gets loop
	 * case 2:	boot net kernel [options]
	 *			-> boot kernel, gets loop
	 * case 3:	boot net [options]
	 *			-> iterate boot list, gets loop
	 */

	bootlp = kernels;
	if (parseargs(bootline, &boothowto) == -1
			|| (boothowto & RB_ASKNAME)) {
		bootlp = 0;
	} else if (*bootline) {
		just_bootline[0] = bootline;
		just_bootline[1] = 0;
		bootlp = just_bootline;
	}
	for (;;) {
		if (bootlp) {
			cp = *bootlp++;
			if (!cp) {
				printf("\n");
				bootlp = 0;
				kernels[0] = 0;	/* no more iteration */
			} else if (cp != bootline) {
				printf(": trying %s...\n", cp);
				strcpy(bootline, cp);
			}
		}
		if (!bootlp) {
d559 1
a559 10
			if (parseargs(bootline, &boothowto) == -1)
				continue;
			if (!*bootline) {
				bootlp = kernels;
				continue;
			}
			if (strcmp(bootline, "exit") == 0
					|| strcmp(bootline, "halt") == 0) {
				_rtt();
			}
d561 3
a563 1
		if ((fd = open(bootline, 0)) < 0) {
d565 11
a575 1
			continue;
d577 17
d595 1
a595 2
		OF_setprop(chosen, "bootpath", opened_name, strlen(opened_name) + 1);
		cp = bootline;
d597 4
a600 15
		strcpy(bootline, opened_name);
		cp = bootline + strlen(bootline);
		*cp++ = ' ';
#endif
		*cp = '-';
		if (boothowto & RB_ASKNAME)
			*++cp = 'a';
		if (boothowto & RB_SINGLE)
			*++cp = 's';
		if (boothowto & RB_KDB)
			*++cp = 'd';
		if (*cp == '-')
			*--cp = 0;
		else
			*++cp = 0;
d602 1
a602 1
		OF_setprop(chosen, "bootargs", bootline, strlen(bootline) + 1);
d604 1
a604 1
		/* XXX void, for now */
d606 2
a607 2
		if (debug)
			printf("main: Calling loadfile(fd, %s)\n", bootline);
d609 3
a611 2
		(void)loadfile(fd, bootline);
	}
@


1.4.4.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.4.4.2
log
@Merge in -current from about a week ago
@
text
@d84 2
a85 2
int	elf32_exec(int, Elf32_Ehdr *, u_int64_t *, void **, void **);
int	elf64_exec(int, Elf64_Ehdr *, u_int64_t *, void **, void **);
d89 1
a89 1
int	aout_exec(int, struct exec *, u_int64_t *, void **);
d169 1
a169 1
	entry = (void *)(long)pentry;
d445 1
a445 1
			bzero((void *)phdr.p_vaddr + phdr.p_filesz,
@


1.4.4.3
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.4.4.2 2002/03/28 11:23:52 niklas Exp $	*/
d76 1
d110 1
a110 9
/*
 *	parse:
 *		[kernel-name] [-options]
 *	leave kernel-name in passed-in string
 *	put options into *howtop
 *	return -1 iff syntax error (no - before options)
 */

static int
d118 14
d133 7
a139 21
	cp = str;
	while (*cp == ' ')
		++cp;
	if (*cp != '-') {
		while (*cp && *cp != ' ')
			*str++ = *cp++;
		while (*cp == ' ')
			++cp;
	}
	*str = 0;
	switch(*cp) {
	default:
		printf ("boot options string <%s> must start with -\n", cp);
		return -1;
	case 0:
		return 0;
	case '-':
		break;
	}

	++cp;
d150 2
a153 1
	return 0;
d233 1
d241 2
a242 7
	if ((rval = read(fd, &hdr, sizeof(hdr))) != sizeof(hdr)) {
		if (rval == -1)
			printf("read header: %s\n", strerror(errno));
		else
			printf("read header: short read (only %d of %d)\n",
				rval, sizeof(hdr));
		rval = 1;
a262 1
		rval = 1;
a535 2
	char **bootlp;
	char *just_bootline[2];
d537 3
d551 6
a556 32

	/*
	 * case 1:	boot net -a
	 *			-> gets loop
	 * case 2:	boot net kernel [options]
	 *			-> boot kernel, gets loop
	 * case 3:	boot net [options]
	 *			-> iterate boot list, gets loop
	 */

	bootlp = kernels;
	if (parseargs(bootline, &boothowto) == -1
			|| (boothowto & RB_ASKNAME)) {
		bootlp = 0;
	} else if (*bootline) {
		just_bootline[0] = bootline;
		just_bootline[1] = 0;
		bootlp = just_bootline;
	}
	for (;;) {
		if (bootlp) {
			cp = *bootlp++;
			if (!cp) {
				printf("\n");
				bootlp = 0;
				kernels[0] = 0;	/* no more iteration */
			} else if (cp != bootline) {
				printf(": trying %s...\n", cp);
				strcpy(bootline, cp);
			}
		}
		if (!bootlp) {
d559 1
a559 10
			if (parseargs(bootline, &boothowto) == -1)
				continue;
			if (!*bootline) {
				bootlp = kernels;
				continue;
			}
			if (strcmp(bootline, "exit") == 0
					|| strcmp(bootline, "halt") == 0) {
				_rtt();
			}
d561 3
a563 1
		if ((fd = open(bootline, 0)) < 0) {
d565 11
a575 1
			continue;
d577 17
d595 1
a595 2
		OF_setprop(chosen, "bootpath", opened_name, strlen(opened_name) + 1);
		cp = bootline;
d597 4
a600 15
		strcpy(bootline, opened_name);
		cp = bootline + strlen(bootline);
		*cp++ = ' ';
#endif
		*cp = '-';
		if (boothowto & RB_ASKNAME)
			*++cp = 'a';
		if (boothowto & RB_SINGLE)
			*++cp = 's';
		if (boothowto & RB_KDB)
			*++cp = 'd';
		if (*cp == '-')
			*--cp = 0;
		else
			*++cp = 0;
d602 1
a602 1
		OF_setprop(chosen, "bootargs", bootline, strlen(bootline) + 1);
d604 1
a604 1
		/* XXX void, for now */
d606 2
a607 2
		if (debug)
			printf("main: Calling loadfile(fd, %s)\n", bootline);
d609 3
a611 2
		(void)loadfile(fd, bootline);
	}
@


1.4.4.4
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.4.4.3 2003/05/13 19:41:09 ho Exp $	*/
d71 2
a72 2
	"bsd",
	"obsd",
d212 1
a212 1
	    (void *)RELOC, end - (char *)RELOC, entry, args, l);
d251 1
a251 1
			    rval, sizeof(hdr));
d266 2
a267 1
	} else if (bcmp(hdr.elf64.e_ident, ELFMAG, SELFMAG) == 0 &&
d479 2
a480 2
		if (shp->sh_type != SHT_SYMTAB &&
		    shp->sh_type != SHT_STRTAB) {
d514 2
a515 2
		if (shp->sh_type == SHT_SYMTAB ||
		    shp->sh_type == SHT_STRTAB) {
d555 3
a557 3
	if ((chosen = OF_finddevice("/chosen")) == -1 ||
	    OF_getprop(chosen, "bootpath", bootdev, sizeof bootdev) < 0 ||
	    OF_getprop(chosen, "bootargs", bootline, sizeof bootline) < 0) {
d572 2
a573 2
	if (parseargs(bootline, &boothowto) == -1 ||
	    (boothowto & RB_ASKNAME)) {
d589 1
a589 1
				strlcpy(bootline, cp, sizeof bootline);
d601 2
a602 2
			if (strcmp(bootline, "exit") == 0 ||
			    strcmp(bootline, "halt") == 0) {
d614 1
a614 1
		strlcpy(bootline, opened_name, sizeof bootline);
@


1.4.4.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d46 3
a48 1
#define ELFSIZE 64
d83 1
d87 4
d226 3
d230 1
d257 5
d263 4
a266 1
	if (bcmp(hdr.elf64.e_ident, ELFMAG, SELFMAG) == 0 &&
d298 77
d376 8
d385 151
d538 1
a538 1
int
a637 1
	return 0;
@


1.3
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a2 1
#define DEBUG
@


1.2
log
@shorter list of kernels to boot.
@
text
@d1 1
@


1.1
log
@Initial revision
@
text
@d71 2
a72 13
	"netbsd ",
	"netbsd.gz ",
	"netbsd.old ",
	"netbsd.old.gz ",
	"onetbsd ",
	"onetbsd.gz ",
	"vmunix ",
#ifdef notyet
	"netbsd.pl ",
	"netbsd.pl.gz ",
	"netbsd.el ",
	"netbsd.el.gz ",
#endif
@


1.1.1.1
log
@Enough of NetBSD/sparc64 for ofwboot to compile/link
@
text
@@
