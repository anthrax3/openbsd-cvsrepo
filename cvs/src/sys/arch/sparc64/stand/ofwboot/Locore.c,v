head	1.14;
access;
symbols
	OPENBSD_6_0:1.13.0.8
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.4
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.13.0.6
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.9.0.22
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.9.0.20
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.16
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.14
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.12
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.10
	OPENBSD_5_0:1.9.0.8
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.6
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.4
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.2
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.8.0.8
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.4
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.2
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.7.0.6
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.4
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.2
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.6.0.2
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.5.0.14
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.12
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.10
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.8
	OPENBSD_3_6_BASE:1.5
	SMP_SYNC_A:1.5
	SMP_SYNC_B:1.5
	OPENBSD_3_5:1.5.0.6
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.4
	OPENBSD_3_4_BASE:1.5
	UBC_SYNC_A:1.5
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.4.0.4
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4
	UBC_SYNC_B:1.5
	UBC:1.2.0.6
	UBC_BASE:1.2
	SMP:1.2.0.4
	OPENBSD_3_0:1.2.0.2
	OPENBSD_3_0_BASE:1.2
	SPARC64:1.1.1.1
	NETBSD:1.1.1;
locks; strict;
comment	@ * @;


1.14
date	2016.09.11.17.53.26;	author jsing;	state Exp;
branches;
next	1.13;
commitid	BqYFMxtCOwuz1mwM;

1.13
date	2014.12.11.10.52.07;	author stsp;	state Exp;
branches;
next	1.12;
commitid	AcCMrLP5TaKCllOs;

1.12
date	2014.11.26.20.30.41;	author stsp;	state Exp;
branches;
next	1.11;
commitid	e315CjZvNnS0qsAl;

1.11
date	2014.11.26.19.47.03;	author stsp;	state Exp;
branches;
next	1.10;
commitid	ywlATwyfTUsHpX58;

1.10
date	2014.10.16.20.47.52;	author kettenis;	state Exp;
branches;
next	1.9;
commitid	bJH04ZWfhne253Lb;

1.9
date	2009.08.17.14.23.09;	author jsing;	state Exp;
branches;
next	1.8;

1.8
date	2008.07.05.23.03.04;	author kettenis;	state Exp;
branches;
next	1.7;

1.7
date	2007.01.16.14.39.57;	author tsi;	state Exp;
branches;
next	1.6;

1.6
date	2006.08.31.21.28.35;	author kettenis;	state Exp;
branches;
next	1.5;

1.5
date	2002.10.12.01.09.44;	author krw;	state Exp;
branches;
next	1.4;

1.4
date	2002.03.14.03.16.01;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2002.03.14.01.26.46;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2001.08.20.19.55.33;	author jason;	state Exp;
branches
	1.2.4.1
	1.2.6.1;
next	1.1;

1.1
date	2001.08.18.15.51.10;	author jason;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.08.18.15.51.10;	author jason;	state Exp;
branches;
next	;

1.2.4.1
date	2001.10.31.03.07.59;	author nate;	state Exp;
branches;
next	1.2.4.2;

1.2.4.2
date	2002.03.28.11.23.52;	author niklas;	state Exp;
branches;
next	1.2.4.3;

1.2.4.3
date	2003.03.27.23.42.38;	author niklas;	state Exp;
branches;
next	;

1.2.6.1
date	2002.06.11.03.38.44;	author art;	state Exp;
branches;
next	1.2.6.2;

1.2.6.2
date	2002.10.29.00.28.12;	author art;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Switch sparc64 boot code to libsa MI softraid.
@
text
@/*	$OpenBSD: Locore.c,v 1.13 2014/12/11 10:52:07 stsp Exp $	*/
/*	$NetBSD: Locore.c,v 1.1 2000/08/20 14:58:36 mrg Exp $	*/

/*
 * Copyright (C) 1995, 1996 Wolfgang Solfrank.
 * Copyright (C) 1995, 1996 TooLs GmbH.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by TooLs GmbH.
 * 4. The name of TooLs GmbH may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY TOOLS GMBH ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL TOOLS GMBH BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <lib/libsa/stand.h>

#include "openfirm.h"

#include <machine/cpu.h>

static vaddr_t OF_claim_virt(vaddr_t vaddr, int len);
static vaddr_t OF_alloc_virt(int len, int align);
static int OF_free_virt(vaddr_t vaddr, int len);
static vaddr_t OF_map_phys(paddr_t paddr, off_t size, vaddr_t vaddr, int mode);
static paddr_t OF_alloc_phys(int len, int align);
static int OF_free_phys(paddr_t paddr, int len);

extern int openfirmware(void *);

void setup(void);

__dead void
_rtt(void)
{
	struct {
		cell_t name;
		cell_t nargs;
		cell_t nreturns;
	} args;

#ifdef SOFTRAID
	sr_clear_keys();
#endif

	args.name = ADR2CELL("exit");
	args.nargs = 0;
	args.nreturns = 0;
	openfirmware(&args);
	while (1);			/* just in case */
}

void
OF_enter(void)
{
	struct {
		cell_t name;
		cell_t nargs;
		cell_t nreturns;
	} args;

	args.name = ADR2CELL("enter");
	args.nargs = 0;
	args.nreturns = 0;
	openfirmware(&args);
}

int
OF_finddevice(char *name)
{
	struct {
		cell_t name;
		cell_t nargs;
		cell_t nreturns;
		cell_t device;
		cell_t phandle;
	} args;

	args.name = ADR2CELL("finddevice");
	args.nargs = 1;
	args.nreturns = 1;
	args.device = ADR2CELL(name);
	if (openfirmware(&args) == -1)
		return -1;
	return args.phandle;
}

int
OF_instance_to_package(int ihandle)
{
	struct {
		cell_t name;
		cell_t nargs;
		cell_t nreturns;
		cell_t ihandle;
		cell_t phandle;
	} args;

	args.name = ADR2CELL("instance-to-package");
	args.nargs = 1;
	args.nreturns = 1;
	args.ihandle = HDL2CELL(ihandle);
	if (openfirmware(&args) == -1)
		return -1;
	return args.phandle;
}

int
OF_getprop(int handle, char *prop, void *buf, int buflen)
{
	struct {
		cell_t name;
		cell_t nargs;
		cell_t nreturns;
		cell_t phandle;
		cell_t prop;
		cell_t buf;
		cell_t buflen;
		cell_t size;
	} args;

	args.name = ADR2CELL("getprop");
	args.nargs = 4;
	args.nreturns = 1;
	args.phandle = HDL2CELL(handle);
	args.prop = ADR2CELL(prop);
	args.buf = ADR2CELL(buf);
	args.buflen = buflen;
	if (openfirmware(&args) == -1)
		return -1;
	return args.size;
}

int
OF_open(char *dname)
{
	struct {
		cell_t name;
		cell_t nargs;
		cell_t nreturns;
		cell_t dname;
		cell_t handle;
	} args;

	args.name = ADR2CELL("open");
	args.nargs = 1;
	args.nreturns = 1;
	args.dname = ADR2CELL(dname);
	if (openfirmware(&args) == -1 ||
	    args.handle == 0)
		return -1;
	return args.handle;
}

void
OF_close(int handle)
{
	struct {
		cell_t name;
		cell_t nargs;
		cell_t nreturns;
		cell_t handle;
	} args;

	args.name = ADR2CELL("close");
	args.nargs = 1;
	args.nreturns = 0;
	args.handle = HDL2CELL(handle);
	openfirmware(&args);
}

int
OF_write(int handle, void *addr, int len)
{
	struct {
		cell_t name;
		cell_t nargs;
		cell_t nreturns;
		cell_t ihandle;
		cell_t addr;
		cell_t len;
		cell_t actual;
	} args;

	args.name = ADR2CELL("write");
	args.nargs = 3;
	args.nreturns = 1;
	args.ihandle = HDL2CELL(handle);
	args.addr = ADR2CELL(addr);
	args.len = len;
	if (openfirmware(&args) == -1)
		return -1;
	return args.actual;
}

int
OF_read(int handle, void *addr, int len)
{
	struct {
		cell_t name;
		cell_t nargs;
		cell_t nreturns;
		cell_t ihandle;
		cell_t addr;
		cell_t len;
		cell_t actual;
	} args;

	args.name = ADR2CELL("read");
	args.nargs = 3;
	args.nreturns = 1;
	args.ihandle = HDL2CELL(handle);
	args.addr = ADR2CELL(addr);
	args.len = len;
	if (openfirmware(&args) == -1) {
		return -1;
	}
	return args.actual;
}

int
OF_seek(int handle, u_quad_t pos)
{
	struct {
		cell_t name;
		cell_t nargs;
		cell_t nreturns;
		cell_t handle;
		cell_t poshi;
		cell_t poslo;
		cell_t status;
	} args;

	args.name = ADR2CELL("seek");
	args.nargs = 3;
	args.nreturns = 1;
	args.handle = HDL2CELL(handle);
	args.poshi = HDQ2CELL_HI(pos);
	args.poslo = HDQ2CELL_LO(pos);
	if (openfirmware(&args) == -1) {
		return -1;
	}
	return args.status;
}

void
OF_release(void *virt, u_int size)
{
	struct {
		cell_t name;
		cell_t nargs;
		cell_t nreturns;
		cell_t virt;
		cell_t size;
	} args;

	args.name = ADR2CELL("release");
	args.nargs = 2;
	args.nreturns = 0;
	args.virt = ADR2CELL(virt);
	args.size = size;
	openfirmware(&args);
}

int
OF_milliseconds(void)
{
	struct {
		cell_t name;
		cell_t nargs;
		cell_t nreturns;
		cell_t ms;
	} args;

	args.name = ADR2CELL("milliseconds");
	args.nargs = 0;
	args.nreturns = 1;
	openfirmware(&args);
	return args.ms;
}

void
OF_chain(void *virt, u_int size, void (*entry)(), void *arg, u_int len)
{
	extern int64_t romp;

	entry(0, arg, len, (unsigned long)romp, (unsigned long)romp);
	panic("OF_chain: kernel returned!");
	__asm("ta 2" : :);
}

static u_int stdin;
static u_int stdout;
static u_int mmuh = -1;
static u_int memh = -1;

void
setup(void)
{
	u_int chosen;

	if ((chosen = OF_finddevice("/chosen")) == -1)
		_rtt();
	if (OF_getprop(chosen, "stdin", &stdin, sizeof(stdin)) != sizeof(stdin)
	    || OF_getprop(chosen, "stdout", &stdout, sizeof(stdout)) != sizeof(stdout)
	    || OF_getprop(chosen, "mmu", &mmuh, sizeof(mmuh)) != sizeof(mmuh)
	    || OF_getprop(chosen, "memory", &memh, sizeof(memh)) != sizeof(memh))
		_rtt();
}

/*
 * The following need either the handle to memory or the handle to the MMU.
 */

/*
 * Grab some address space from the prom
 *
 * Only works while the prom is actively mapping us.
 */
static vaddr_t
OF_claim_virt(vaddr_t vaddr, int len)
{
	struct {
		cell_t name;
		cell_t nargs;
		cell_t nreturns;
		cell_t method;
		cell_t ihandle;
		cell_t align;
		cell_t len;
		cell_t vaddr;
		cell_t status;
		cell_t retaddr;
	} args;

	args.name = ADR2CELL("call-method");
	args.nargs = 5;
	args.nreturns = 2;
	args.method = ADR2CELL("claim");
	args.ihandle = HDL2CELL(mmuh);
	args.align = 0;
	args.len = len;
	args.vaddr = ADR2CELL(vaddr);
	if (openfirmware(&args) != 0)
		return -1LL;
	return (vaddr_t)args.retaddr;
}

/*
 * Request some address space from the prom
 *
 * Only works while the prom is actively mapping us.
 */
static vaddr_t
OF_alloc_virt(int len, int align)
{
	int retaddr=-1;
	struct {
		cell_t name;
		cell_t nargs;
		cell_t nreturns;
		cell_t method;
		cell_t ihandle;
		cell_t align;
		cell_t len;
		cell_t status;
		cell_t retaddr;
	} args;

	args.name = ADR2CELL("call-method");
	args.nargs = 4;
	args.nreturns = 2;
	args.method = ADR2CELL("claim");
	args.ihandle = HDL2CELL(mmuh);
	args.align = align;
	args.len = len;
	args.retaddr = ADR2CELL(&retaddr);
	if (openfirmware(&args) != 0)
		return -1LL;
	return (vaddr_t)args.retaddr;
}

/*
 * Release some address space to the prom
 *
 * Only works while the prom is actively mapping us.
 */
static int
OF_free_virt(vaddr_t vaddr, int len)
{
	struct {
		cell_t name;
		cell_t nargs;
		cell_t nreturns;
		cell_t method;
		cell_t ihandle;
		cell_t len;
		cell_t vaddr;
	} args;

	args.name = ADR2CELL("call-method");
	args.nargs = 4;
	args.nreturns = 0;
	args.method = ADR2CELL("release");
	args.ihandle = HDL2CELL(mmuh);
	args.vaddr = ADR2CELL(vaddr);
	args.len = len;
	return openfirmware(&args);
}


/*
 * Have prom map in some memory
 *
 * Only works while the prom is actively mapping us.
 */
static vaddr_t
OF_map_phys(paddr_t paddr, off_t size, vaddr_t vaddr, int mode)
{
	struct {
		cell_t name;
		cell_t nargs;
		cell_t nreturns;
		cell_t method;
		cell_t ihandle;
		cell_t mode;
		cell_t size;
		cell_t vaddr;
		cell_t paddr_hi;
		cell_t paddr_lo;
		cell_t status;
		cell_t retaddr;
	} args;

	args.name = ADR2CELL("call-method");
	args.nargs = 7;
	args.nreturns = 1;
	args.method = ADR2CELL("map");
	args.ihandle = HDL2CELL(mmuh);
	args.mode = mode;
	args.size = size;
	args.vaddr = ADR2CELL(vaddr);
	args.paddr_hi = HDQ2CELL_HI(paddr);
	args.paddr_lo = HDQ2CELL_LO(paddr);

	if (openfirmware(&args) == -1)
		return -1;
	if (args.status)
		return -1;
	return (vaddr_t)args.retaddr;
}


/*
 * Request some RAM from the prom
 *
 * Only works while the prom is actively mapping us.
 */
static paddr_t
OF_alloc_phys(int len, int align)
{
	struct {
		cell_t name;
		cell_t nargs;
		cell_t nreturns;
		cell_t method;
		cell_t ihandle;
		cell_t align;
		cell_t len;
		cell_t status;
		cell_t phys_hi;
		cell_t phys_lo;
	} args;

	args.name = ADR2CELL("call-method");
	args.nargs = 4;
	args.nreturns = 3;
	args.method = ADR2CELL("claim");
	args.ihandle = HDL2CELL(memh);
	args.align = align;
	args.len = len;
	if (openfirmware(&args) != 0)
		return -1LL;
	return (paddr_t)CELL2HDQ(args.phys_hi, args.phys_lo);
}


/*
 * Free some RAM to prom
 *
 * Only works while the prom is actively mapping us.
 */
static int
OF_free_phys(paddr_t phys, int len)
{
	struct {
		cell_t name;
		cell_t nargs;
		cell_t nreturns;
		cell_t method;
		cell_t ihandle;
		cell_t len;
		cell_t phys_hi;
		cell_t phys_lo;
	} args;

	args.name = ADR2CELL("call-method");
	args.nargs = 5;
	args.nreturns = 0;
	args.method = ADR2CELL("release");
	args.ihandle = HDL2CELL(memh);
	args.len = len;
	args.phys_hi = HDQ2CELL_HI(phys);
	args.phys_lo = HDQ2CELL_LO(phys);
	return openfirmware(&args);
}


/*
 * Claim virtual memory -- does not map it in.
 */

void *
OF_claim(void *virt, u_int size, u_int align)
{
	/*
	 * Sun Ultra machines run the firmware with VM enabled,
	 * so you need to handle allocating and mapping both
	 * virtual and physical memory.  Ugh.
	 */
	paddr_t paddr;
	void * newvirt = NULL;

	if (virt == NULL) {
		virt = (void *)OF_alloc_virt(size, align);
		if (virt == (void *)-1LL) {
			printf("OF_alloc_virt(%d,%d) failed w/%x\n",
			       size, align, virt);
			return virt;
		}
	} else {
		newvirt = (void *)OF_claim_virt((vaddr_t)virt, size);
		if (newvirt == (void *)-1LL) {
			printf("OF_claim_virt(%x,%d) failed w/%x\n",
			       virt, size, newvirt);
			return newvirt;
		}
		virt = newvirt;
	}
	if ((paddr = OF_alloc_phys(size, align)) == (paddr_t)-1LL) {
		printf("OF_alloc_phys(%d,%d) failed\n", size, align);
		OF_free_virt((vaddr_t)virt, size);
		return (void *)-1LL;
	}
	if (OF_map_phys(paddr, size, (vaddr_t)virt, -1) == -1) {
		printf("OF_map_phys(%x,%d,%x,%d) failed\n",
		       paddr, size, virt, -1);
		OF_free_phys((paddr_t)paddr, size);
		OF_free_virt((vaddr_t)virt, size);
		return (void *)-1LL;
	}
	return virt;
}

int
OF_peer(int phandle)
{
	struct {
		cell_t name;
		cell_t nargs;
		cell_t nreturns;
		cell_t phandle;
		cell_t sibling;
	} args;

	args.name = ADR2CELL("peer");
	args.nargs = 1;
	args.nreturns = 1;
	args.phandle = HDL2CELL(phandle);
	if (openfirmware(&args) == -1)
		return 0;
	return args.sibling;
}

int
OF_child(int phandle)
{
	struct {
		cell_t name;
		cell_t nargs;
		cell_t nreturns;
		cell_t phandle;
		cell_t child;
	} args;
	
	args.name = ADR2CELL("child");
	args.nargs = 1;
	args.nreturns = 1;
	args.phandle = HDL2CELL(phandle);
	if (openfirmware(&args) == -1)
		return 0;
	return args.child;
}

int
OF_package_to_path(int phandle, char *buf, int buflen)
{
	struct {
		cell_t name;
		cell_t nargs;
		cell_t nreturns;
		cell_t phandle;
		cell_t buf;
		cell_t buflen;
		cell_t length;
	} args;
	
	if (buflen > PAGE_SIZE)
		return -1;
	args.name = ADR2CELL("package-to-path");
	args.nargs = 3;
	args.nreturns = 1;
	args.phandle = HDL2CELL(phandle);
	args.buf = ADR2CELL(buf);
	args.buflen = buflen;
	if (openfirmware(&args) < 0)
		return -1;
	return args.length;
}

void
putchar(int c)
{
	char ch = c;

	if (c == '\n')
		putchar('\r');
	OF_write(stdout, &ch, 1);
}

int
getchar(void)
{
	unsigned char ch = '\0';
	int l;

	while ((l = OF_read(stdin, &ch, 1)) != 1)
		if (l != -2 && l != 0)
			return -1;
	return ch;
}

int
cngetc(void)
{
	return getchar();
}
@


1.13
log
@Delete #ifdef'd code that hasn't been compiled in years from sparc64 ofwboot.
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: Locore.c,v 1.12 2014/11/26 20:30:41 stsp Exp $	*/
d36 1
d670 6
@


1.12
log
@Introduce softraid boot support to sparc64 ofwboot.
sparc64 machines should now be able to boot from softraid raid1 and crypto.
Tested on sun blade100, sunfire v240, and sun t1000 ldom guests.
Lots of encouragement from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: Locore.c,v 1.11 2014/11/26 19:47:03 stsp Exp $	*/
a50 20
#if 0
#ifdef XCOFF_GLUE
asm (".text; .globl _entry; _entry: .long _start,0,0");
#endif

__dead void
_start(void *vpd, int res, int (*openfirm)(void *), char *arg, int argl)
{
	extern char etext[];

#ifdef	FIRMWORKSBUGS
	syncicache((void *)RELOC, etext - (char *)RELOC);
#endif
	openfirmware = openfirm;	/* Save entry to Open Firmware */
	setup();
	main(arg, argl);
	exit();
}
#endif

a151 28
#ifdef	__notyet__	/* Has a bug on FirePower */
int
OF_setprop(u_int handle, char *prop, void *buf, int len)
{
	struct {
		cell_t name;
		cell_t nargs;
		cell_t nreturns;
		cell_t phandle;
		cell_t prop;
		cell_t buf;
		cell_t len;
		cell_t size;
	} args;

	args.name = ADR2CELL("setprop");
	args.nargs = 4;
	args.nreturns = 1;
	args.phandle = HDL2CELL(handle);
	args.prop = ADR2CELL(prop);
	args.buf = ADR2CELL(buf);
	args.len = len;
	if (openfirmware(&args) == -1)
		return -1;
	return args.size;
}
#endif

a303 12
#ifdef __notyet
	extern int debug;
	struct {
		cell_t name;
		cell_t nargs;
		cell_t nreturns;
		cell_t virt;
		cell_t size;
		cell_t entry;
		cell_t arg;
		cell_t len;
	} args;
a304 17
	args.name = ADR2CELL("chain");
	args.nargs = 5;
	args.nreturns = 0;
	args.virt = ADR2CELL(virt);
	args.size = size;
	args.entry = ADR2CELL(entry);
	args.arg = ADR2CELL(arg);
	args.len = len;
	openfirmware(&args);
	if (debug) {
		printf("OF_chain: prom returned!\n");

	/* OK, firmware failed us.  Try calling prog directly */
		printf("Calling entry(0, %p, %x, %lx, %lx)\n", arg, len,
			(unsigned long)romp, (unsigned long)romp);
	}
#endif
a353 6
#ifdef	__notyet
	if (mmuh == -1 && ((mmuh = get_mmu_handle()) == -1)) {
		printf("OF_claim_virt: cannot get mmuh\r\n");
		return -1LL;
	}
#endif
a387 6
#ifdef	__notyet
	if (mmuh == -1 && ((mmuh = get_mmu_handle()) == -1)) {
		printf("OF_alloc_virt: cannot get mmuh\r\n");
		return -1LL;
	}
#endif
a418 6
#ifdef	__notyet
	if (mmuh == -1 && ((mmuh = get_mmu_handle()) == -1)) {
		printf("OF_free_virt: cannot get mmuh\r\n");
		return -1;
	}
#endif
a452 6
#ifdef	__notyet
	if (mmuh == -1 && ((mmuh = get_mmu_handle()) == -1)) {
		printf("OF_map_phys: cannot get mmuh\r\n");
		return 0LL;
	}
#endif
a492 6
#ifdef	__notyet
	if (memh == -1 && ((memh = get_memory_handle()) == -1)) {
		printf("OF_alloc_phys: cannot get memh\r\n");
		return -1LL;
	}
#endif
a524 6
#ifdef	__notyet
	if (memh == -1 && ((memh = get_memory_handle()) == -1)) {
		printf("OF_free_phys: cannot get memh\r\n");
		return -1;
	}
#endif
d544 5
a548 29
#define SUNVMOF
#ifndef SUNVMOF
	struct {
		cell_t name;
		cell_t nargs;
		cell_t nreturns;
		cell_t virt;
		cell_t size;
		cell_t align;
		cell_t baseaddr;
	} args;


	args.name = ADR2CELL("claim");
	args.nargs = 3;
	args.nreturns = 1;
	args.virt = virt;
	args.size = size;
	args.align = align;
	if (openfirmware(&args) == -1)
		return (void *)-1;
	return (void *)args.baseaddr;
#else
/*
 * Sun Ultra machines run the firmware with VM enabled,
 * so you need to handle allocating and mapping both
 * virtual and physical memory.  Ugh.
 */

a580 1
#endif
@


1.11
log
@Copy some Open Firmware interface functions from the kernel to ofwboot.
Will be needed soon.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: Locore.c,v 1.10 2014/10/16 20:47:52 kettenis Exp $	*/
d79 4
@


1.10
log
@The "close" word doesn't return any arguments.

Pointed out by Mark Cave-Ayland.
@
text
@d1 1
a1 1
/*	$OpenBSD: Locore.c,v 1.9 2009/08/17 14:23:09 jsing Exp $	*/
d717 65
@


1.9
log
@Use ANSI function declarations. No binary change.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: Locore.c,v 1.7 2007/01/16 14:39:57 tsi Exp $	*/
d229 1
a229 1
	args.nreturns = 1;
@


1.8
log
@Apparantly the "chain" OpenFirmware interface always fails so don't bother
with it.  Makes the bootloader work on the v1280 where the firmware breaks
into the firmware debugger instead of returning failure.
@
text
@d57 1
a57 6
_start(vpd, res, openfirm, arg, argl)
	void *vpd;
	int res;
	int (*openfirm)(void *);
	char *arg;
	int argl;
d72 1
a72 1
_rtt()
d88 1
a88 1
OF_enter()
d103 1
a103 2
OF_finddevice(name)
	char *name;
d123 1
a123 2
OF_instance_to_package(ihandle)
	int ihandle;
d143 1
a143 5
OF_getprop(handle, prop, buf, buflen)
	int handle;
	char *prop;
	void *buf;
	int buflen;
d170 1
a170 5
OF_setprop(handle, prop, buf, len)
	u_int handle;
	char *prop;
	void *buf;
	int len;
d197 1
a197 2
OF_open(dname)
	char *dname;
d218 1
a218 2
OF_close(handle)
	int handle;
d235 1
a235 4
OF_write(handle, addr, len)
	int handle;
	void *addr;
	int len;
d259 1
a259 4
OF_read(handle, addr, len)
	int handle;
	void *addr;
	int len;
d284 1
a284 3
OF_seek(handle, pos)
	int handle;
	u_quad_t pos;
d309 1
a309 3
OF_release(virt, size)
	void *virt;
	u_int size;
d328 1
a328 1
OF_milliseconds()
d345 1
a345 6
OF_chain(virt, size, entry, arg, len)
	void *virt;
	u_int size;
	void (*entry)();
	void *arg;
	u_int len;
d389 1
a389 1
setup()
d412 1
a412 3
OF_claim_virt(vaddr, len)
vaddr_t vaddr;
int len;
d452 1
a452 3
OF_alloc_virt(len, align)
int len;
int align;
d492 1
a492 3
OF_free_virt(vaddr, len)
vaddr_t vaddr;
int len;
d527 1
a527 5
OF_map_phys(paddr, size, vaddr, mode)
paddr_t paddr;
off_t size;
vaddr_t vaddr;
int mode;
d575 1
a575 3
OF_alloc_phys(len, align)
int len;
int align;
d615 1
a615 3
OF_free_phys(phys, len)
paddr_t phys;
int len;
d651 1
a651 4
OF_claim(virt, size, align)
	void *virt;
	u_int size;
	u_int align;
d719 1
a719 2
putchar(c)
	int c;
d729 1
a729 1
getchar()
@


1.7
log
@Remove unnecessary ampersands in ADR2CELL macro invocations;
Change OF_printf references to printf, given the former doesn't exist;
Clean up formatting, whitespace, unused code, etc.

ok miod@@, kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: Locore.c,v 1.6 2006/08/31 21:28:35 kettenis Exp $	*/
d380 1
d409 1
@


1.6
log
@Fix handling of 64-bit quantities in Open Firmware's client interface.
Spotted by tsi@@, and shamelessly stolen from his diff.  Fixes several
UltraSPARC-III machines wich have more than one memory bank filled.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: Locore.c,v 1.5 2002/10/12 01:09:44 krw Exp $	*/
d40 6
a45 8
vaddr_t OF_claim_virt(vaddr_t vaddr, int len);
vaddr_t OF_alloc_virt(int len, int align);
int OF_free_virt(vaddr_t vaddr, int len);
int OF_unmap_virt(vaddr_t vaddr, int len);
vaddr_t OF_map_phys(paddr_t paddr, off_t size, vaddr_t vaddr, int mode);
paddr_t OF_alloc_phys(int len, int align);
paddr_t OF_claim_phys(paddr_t phys, int len);
int OF_free_phys(paddr_t paddr, int len);
d118 1
a118 1
	
d139 1
a139 1
	
d166 1
a166 1
	
d197 1
a197 1
	
d222 1
a222 1
	
d243 1
a243 1
	
d320 1
a320 1
	
d345 1
a345 1
	
d363 1
a363 1
	
d422 1
a422 1
	
d436 1
a436 1
/* 
d441 1
a441 1
vaddr_t
d461 1
a461 1
		OF_printf("OF_claim_virt: cannot get mmuh\r\n");
d473 1
a473 1
	if(openfirmware(&args) != 0)
d475 1
a475 1
	return args.retaddr;
d478 1
a478 1
/* 
d483 1
a483 1
vaddr_t
d503 1
a503 1
		OF_printf("OF_alloc_virt: cannot get mmuh\r\n");
d515 1
a515 1
	if(openfirmware(&args) != 0)
d520 1
a520 1
/* 
d525 1
a525 1
int
d542 1
a542 1
		OF_printf("OF_claim_virt: cannot get mmuh\r\n");
d557 1
a557 37
/* 
 * Unmap some address space
 *
 * Only works while the prom is actively mapping us.
 */
int
OF_unmap_virt(vaddr, len)
vaddr_t vaddr;
int len;
{
	struct {
		cell_t name;
		cell_t nargs;
		cell_t nreturns;
		cell_t method;
		cell_t ihandle;
		cell_t len;
		cell_t vaddr;
	} args;

#ifdef	__notyet
	if (mmuh == -1 && ((mmuh = get_mmu_handle()) == -1)) {
		OF_printf("OF_claim_virt: cannot get mmuh\r\n");
		return -1;
	}
#endif
	args.name = ADR2CELL("call-method");
	args.nargs = 4;
	args.nreturns = 0;
	args.method = ADR2CELL("unmap");
	args.ihandle = HDL2CELL(mmuh);
	args.vaddr = ADR2CELL(vaddr);
	args.len = len;
	return openfirmware(&args);
}

/* 
d562 1
a562 1
vaddr_t
d586 1
a586 1
		OF_printf("OF_map_phys: cannot get mmuh\r\n");
d609 1
a609 1
/* 
d614 1
a614 1
paddr_t
d634 1
a634 1
		OF_printf("OF_alloc_phys: cannot get memh\r\n");
d645 1
a645 1
	if(openfirmware(&args) != 0)
a649 25
/* 
 * Request some specific RAM from the prom
 *
 * Only works while the prom is actively mapping us.
 */
paddr_t
OF_claim_phys(phys, len)
paddr_t phys;
int len;
{
	struct {
		cell_t name;
		cell_t nargs;
		cell_t nreturns;
		cell_t method;
		cell_t ihandle;
		cell_t align;
		cell_t len;
		cell_t phys_hi;
		cell_t phys_lo;
		cell_t status;
		cell_t res;
		cell_t rphys_hi;
		cell_t rphys_lo;
	} args;
d651 1
a651 21
#ifdef	__notyet
	if (memh == -1 && ((memh = get_memory_handle()) == -1)) {
		OF_printf("OF_alloc_phys: cannot get memh\r\n");
		return 0LL;
	}
#endif
	args.name = ADR2CELL("call-method");
	args.nargs = 6;
	args.nreturns = 4;
	args.method = ADR2CELL("claim");
	args.ihandle = HDL2CELL(memh);
	args.align = 0;
	args.len = len;
	args.phys_hi = HDQ2CELL_HI(phys);
	args.phys_lo = HDQ2CELL_LO(phys);
	if(openfirmware(&args) != 0)
		return 0LL;
	return (paddr_t)CELL2HDQ(args.phys_hi, args.phys_lo);
}

/* 
d656 1
a656 1
int
d674 1
a674 1
		OF_printf("OF_free_phys: cannot get memh\r\n");
d721 1
a721 1
	return args.baseaddr;
d733 5
a737 3
		if ((virt = (void *)OF_alloc_virt(size, align)) == (void *)-1) {
			printf("OF_alloc_virt(%d,%d) failed w/%x\n", size, align, virt);
			return (void *)-1;
d740 5
a744 3
		if ((newvirt = (void *)OF_claim_virt((vaddr_t)virt, size)) == (void *)-1) {
			printf("OF_claim_virt(%x,%d) failed w/%x\n", virt, size, newvirt);
			return (void *)-1;
d746 1
d748 1
a748 1
	if ((paddr = OF_alloc_phys(size, align)) == -1) {
d751 1
a751 1
		return (void *)-1;
d754 2
a755 1
		printf("OF_map_phys(%x,%d,%x,%d) failed\n", paddr, size, virt, -1);
d758 1
a758 1
		return (void *)-1;
d760 1
a760 1
	return (void *)virt;
@


1.5
log
@Remove more '\n's from panic() statements. Both trailing and leading.

Diff generated by Chris Kuethe.
@
text
@d1 1
a1 1
/*	$OpenBSD: Locore.c,v 1.4 2002/03/14 03:16:01 millert Exp $	*/
d327 2
a328 2
	args.poshi = HDL2CELL(pos >> 32);
	args.poslo = HDL2CELL(pos);
d477 1
a477 1
	return args.retaddr; /* Kluge till we go 64-bit */
d513 1
a513 1
	args.ihandle = mmuh;
d519 1
a519 1
	return (vaddr_t)args.retaddr; /* Kluge till we go 64-bit */
d636 2
a637 2
	args.paddr_hi = ADR2CELL(paddr>>32);
	args.paddr_lo = ADR2CELL(paddr);
a656 1
	paddr_t paddr;
d685 1
a685 2
	paddr = (paddr_t)(args.phys_hi<<32)|((unsigned int)(args.phys_lo));
	return paddr; /* Kluge till we go 64-bit */
a697 1
	paddr_t paddr;
d727 2
a728 2
	args.phys_hi = HDL2CELL(phys>>32);
	args.phys_lo = HDL2CELL(phys);
d731 1
a731 2
	paddr = (paddr_t)(args.rphys_hi<<32)|((unsigned int)(args.rphys_lo));
	return paddr;
d767 2
a768 2
	args.phys_hi = HDL2CELL(phys>>32);
	args.phys_lo = HDL2CELL(phys);
@


1.4
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: Locore.c,v 1.3 2002/03/14 01:26:46 millert Exp $	*/
d411 1
a411 1
	panic("OF_chain: kernel returned!\n");
@


1.3
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: Locore.c,v 1.2 2001/08/20 19:55:33 jason Exp $	*/
d817 1
a817 1
	void* newvirt = NULL;
d820 1
a820 1
		if ((virt = (void*)OF_alloc_virt(size, align)) == (void*)-1) {
d825 1
a825 1
		if ((newvirt = (void*)OF_claim_virt((vaddr_t)virt, size)) == (void*)-1) {
@


1.2
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d40 8
a47 8
vaddr_t OF_claim_virt __P((vaddr_t vaddr, int len));
vaddr_t OF_alloc_virt __P((int len, int align));
int OF_free_virt __P((vaddr_t vaddr, int len));
int OF_unmap_virt __P((vaddr_t vaddr, int len));
vaddr_t OF_map_phys __P((paddr_t paddr, off_t size, vaddr_t vaddr, int mode));
paddr_t OF_alloc_phys __P((int len, int align));
paddr_t OF_claim_phys __P((paddr_t phys, int len));
int OF_free_phys __P((paddr_t paddr, int len));
d51 1
a51 1
void setup __P((void));
@


1.2.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: Locore.c,v 1.2 2001/08/20 19:55:33 jason Exp $	*/
d40 8
a47 8
vaddr_t OF_claim_virt(vaddr_t vaddr, int len);
vaddr_t OF_alloc_virt(int len, int align);
int OF_free_virt(vaddr_t vaddr, int len);
int OF_unmap_virt(vaddr_t vaddr, int len);
vaddr_t OF_map_phys(paddr_t paddr, off_t size, vaddr_t vaddr, int mode);
paddr_t OF_alloc_phys(int len, int align);
paddr_t OF_claim_phys(paddr_t phys, int len);
int OF_free_phys(paddr_t paddr, int len);
d51 1
a51 1
void setup(void);
d817 1
a817 1
	void * newvirt = NULL;
d820 1
a820 1
		if ((virt = (void *)OF_alloc_virt(size, align)) == (void *)-1) {
d825 1
a825 1
		if ((newvirt = (void *)OF_claim_virt((vaddr_t)virt, size)) == (void *)-1) {
@


1.2.6.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: Locore.c,v 1.2.6.1 2002/06/11 03:38:44 art Exp $	*/
d411 1
a411 1
	panic("OF_chain: kernel returned!");
@


1.2.4.1
log
@Sync the SMP branch to something just after 3.0
@
text
@@


1.2.4.2
log
@Merge in -current from about a week ago
@
text
@d40 8
a47 8
vaddr_t OF_claim_virt(vaddr_t vaddr, int len);
vaddr_t OF_alloc_virt(int len, int align);
int OF_free_virt(vaddr_t vaddr, int len);
int OF_unmap_virt(vaddr_t vaddr, int len);
vaddr_t OF_map_phys(paddr_t paddr, off_t size, vaddr_t vaddr, int mode);
paddr_t OF_alloc_phys(int len, int align);
paddr_t OF_claim_phys(paddr_t phys, int len);
int OF_free_phys(paddr_t paddr, int len);
d51 1
a51 1
void setup(void);
d817 1
a817 1
	void * newvirt = NULL;
d820 1
a820 1
		if ((virt = (void *)OF_alloc_virt(size, align)) == (void *)-1) {
d825 1
a825 1
		if ((newvirt = (void *)OF_claim_virt((vaddr_t)virt, size)) == (void *)-1) {
@


1.2.4.3
log
@Sync the SMP branch with 3.3
@
text
@d411 1
a411 1
	panic("OF_chain: kernel returned!");
@


1.1
log
@Initial revision
@
text
@d1 1
@


1.1.1.1
log
@Enough of NetBSD/sparc64 for ofwboot to compile/link
@
text
@@
