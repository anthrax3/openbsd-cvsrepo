head	1.9;
access;
symbols
	OPENBSD_4_8:1.7.0.10
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.6
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.8
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.4
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.2
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.6.0.6
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.4
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.2
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.5.0.14
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.12
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.10
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.8
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.6
	OPENBSD_3_6_BASE:1.5
	SMP_SYNC_A:1.5
	SMP_SYNC_B:1.5
	OPENBSD_3_5:1.5.0.4
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.2
	OPENBSD_3_4_BASE:1.5
	UBC_SYNC_A:1.4
	OPENBSD_3_3:1.4.0.6
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.4
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4
	UBC_SYNC_B:1.4
	UBC:1.3.0.6
	UBC_BASE:1.3
	SMP:1.3.0.4
	OPENBSD_3_0:1.3.0.2
	OPENBSD_3_0_BASE:1.3
	SPARC64:1.1.1.1
	NETBSD:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2010.08.21.17.22.42;	author jsing;	state dead;
branches;
next	1.8;

1.8
date	2010.08.21.17.09.49;	author jsing;	state Exp;
branches;
next	1.7;

1.7
date	2008.07.05.22.59.14;	author kettenis;	state Exp;
branches;
next	1.6;

1.6
date	2007.01.12.20.16.19;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2003.06.10.02.42.58;	author brad;	state Exp;
branches;
next	1.4;

1.4
date	2002.03.14.03.16.01;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.09.20.23.26.02;	author jason;	state Exp;
branches
	1.3.4.1
	1.3.6.1;
next	1.2;

1.2
date	2001.08.20.19.55.33;	author jason;	state Exp;
branches;
next	1.1;

1.1
date	2001.08.18.15.50.55;	author jason;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.08.18.15.50.55;	author jason;	state Exp;
branches;
next	;

1.3.4.1
date	2001.10.31.03.07.59;	author nate;	state Exp;
branches;
next	1.3.4.2;

1.3.4.2
date	2002.03.28.11.23.52;	author niklas;	state Exp;
branches;
next	1.3.4.3;

1.3.4.3
date	2004.02.19.10.50.02;	author niklas;	state Exp;
branches;
next	;

1.3.6.1
date	2002.06.11.03.38.44;	author art;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Rename file to reflect that it handles 64 bit ELF only.

ok miod@@ (some time ago)
@
text
@/*	$OpenBSD: elfXX_exec.c,v 1.8 2010/08/21 17:09:49 jsing Exp $	*/
/*	$NetBSD: elfXX_exec.c,v 1.2 2001/08/15 20:08:15 eeh Exp $	*/

/*
 * Copyright (c) 1998-2000 Eduardo Horvath.  All rights reserved.
 * Copyright (c) 1997 Jason R. Thorpe.  All rights reserved.
 * Copyright (C) 1995, 1996 Wolfgang Solfrank.
 * Copyright (C) 1995, 1996 TooLs GmbH.
 * All rights reserved.
 *
 * ELF support derived from NetBSD/alpha's boot loader, written
 * by Christopher G. Demetriou.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by TooLs GmbH.
 * 4. The name of TooLs GmbH may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY TOOLS GMBH ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL TOOLS GMBH BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * First try for the boot code
 *
 * Input syntax is:
 *	[promdev[{:|,}partition]]/[filename] [flags]
 */

#define	ELFSIZE		64
#define	MB		(1024 * 1024)

#define ELF_ALIGN(x)	(((x) + 7) & (~7))

int
elf64_exec(int fd, Elf_Ehdr *elf, u_int64_t *entryp, void **ssymp, void **esymp){ 
	Elf_Shdr *shp;
	Elf_Off off;
	void *addr;
	size_t size;
	u_int align;
	int i, first = 1;
	int n;

	/*
	 * Don't display load address for ELF; it's encoded in
	 * each section.
	 */
#ifdef DEBUG
	printf("elf%d_exec: ", ELFSIZE);
#endif
	printf("Booting %s\n", opened_name);

	for (i = 0; i < elf->e_phnum; i++) {
		Elf_Phdr phdr;
		size = lseek(fd, (size_t)(elf->e_phoff + sizeof(phdr) * i),
		    SEEK_SET);
		if (read(fd, (void *)&phdr, sizeof(phdr)) != sizeof(phdr)) {
			printf("read phdr: %s\n", strerror(errno));
			return (1);
		}
		if (phdr.p_type != PT_LOAD ||
		    (phdr.p_flags & (PF_W|PF_X)) == 0)
			continue;

		/* Read in segment. */
		printf("%s%lu@@0x%lx", first ? "" : "+", (u_long)phdr.p_filesz,
		    (u_long)phdr.p_vaddr);
		(void)lseek(fd, (size_t)phdr.p_offset, SEEK_SET);
		/* 
		 * If the segment's VA is aligned on a 4MB boundary, align its
		 * request 4MB aligned physical memory.  Otherwise use default
		 * alignment.  Make sure BSS is extended to a 4MB boundary, too.
		 */
		align = phdr.p_align;
		if ((phdr.p_vaddr & (4 * MB - 1)) == 0)
			align = 4 * MB;
		if (phdr.p_filesz < phdr.p_memsz)
			phdr.p_memsz = roundup(phdr.p_memsz, 4 * MB);
		phdr.p_memsz = roundup(phdr.p_memsz, NBPG);
		if (OF_claim((void *)(long)phdr.p_vaddr, phdr.p_memsz, align) ==
		    (void *)-1)
			panic("cannot claim memory");
		if (read(fd, (void *)(long)phdr.p_vaddr, phdr.p_filesz) !=
		    phdr.p_filesz) {
			printf("read segment: %s\n", strerror(errno));
			return (1);
		}
		syncicache((void *)(long)phdr.p_vaddr, phdr.p_filesz);

		/* Zero BSS. */
		if (phdr.p_filesz < phdr.p_memsz) {
			printf("+%lu@@0x%lx", (u_long)phdr.p_memsz - phdr.p_filesz,
			    (u_long)(phdr.p_vaddr + phdr.p_filesz));
			bzero((void *)(long)phdr.p_vaddr + phdr.p_filesz,
			    (size_t)phdr.p_memsz - phdr.p_filesz);
		}
		first = 0;
	}

	printf(" \n");

	/*
	 * Compute the size of the symbol table.
	 */
	size = sizeof(Elf_Ehdr) + (elf->e_shnum * sizeof(Elf_Shdr));
	shp = addr = alloc(elf->e_shnum * sizeof(Elf_Shdr));
	(void)lseek(fd, (off_t)elf->e_shoff, SEEK_SET);
	if (read(fd, addr, (size_t)(elf->e_shnum * sizeof(Elf_Shdr))) !=
	    elf->e_shnum * sizeof(Elf_Shdr)) {
		printf("read section headers: %s\n", strerror(errno));
		return (1);
	}
	for (i = 0; i < elf->e_shnum; i++, shp++) {
		if (shp->sh_type == SHT_NULL)
			continue;
		if (shp->sh_type != SHT_SYMTAB
		    && shp->sh_type != SHT_STRTAB) {
			shp->sh_offset = 0; 
			continue;
		}
		size += shp->sh_size;
	}
	shp = addr;

	/*
	 * Reserve memory for the symbols.
	 */
	if ((addr = OF_claim(0, roundup(size, NBPG), NBPG)) == (void *)-1)
		panic("no space for symbol table");

	/*
	 * Copy the headers.
	 */
	elf->e_phoff = 0;
	elf->e_shoff = sizeof(Elf_Ehdr);
	elf->e_phentsize = 0;
	elf->e_phnum = 0;
	bcopy(elf, addr, sizeof(Elf_Ehdr));
	bcopy(shp, addr + sizeof(Elf_Ehdr), elf->e_shnum * sizeof(Elf_Shdr));
	free(shp, elf->e_shnum * sizeof(Elf_Shdr));
	*ssymp = addr;

	/*
	 * Now load the symbol sections themselves.
	 */
	shp = addr + sizeof(Elf_Ehdr);
	size = sizeof(Elf_Ehdr) + (elf->e_shnum * sizeof(Elf_Shdr));
	size = ELF_ALIGN(size);
	addr += size;
	off = size;
	for (first = 1, i = 0; i < elf->e_shnum; i++, shp++) {
		if (shp->sh_type == SHT_SYMTAB
		    || shp->sh_type == SHT_STRTAB) {
			if (first)
				printf("symbols @@ 0x%lx ", (u_long)addr);
			printf("%s%d", first ? "" : "+", (int)shp->sh_size);
			(void)lseek(fd, shp->sh_offset, SEEK_SET);
			if (read(fd, addr, shp->sh_size) != shp->sh_size) {
				printf("read symbols: %s\n", strerror(errno));
				return (1);
			}
			addr += ELF_ALIGN(shp->sh_size);
			shp->sh_offset = off;
			off += ELF_ALIGN(shp->sh_size);
			first = 0;
		}
	}
	*esymp = addr;

	*entryp = elf->e_entry;
	return (0);
}

#undef ELF_ALIGN
@


1.8
log
@We only need to load 64 bit kernels on sparc64. Clean up the ELF boot code
and let exec_elf.h do the right thing.

ok miod@@ (some time ago)
@
text
@d1 1
a1 1
/*	$OpenBSD: elfXX_exec.c,v 1.6 2007/01/12 20:16:19 miod Exp $	*/
@


1.7
log
@Round up memory allocations to page size.  Apparently sane firmware versions do
this automatically, but the braindead firmware on the v1280 doesn't do this
and makes the allocation fail.
@
text
@d47 2
a48 3
#define CONCAT(x,y)	__CONCAT(x,y)
#define CAT3(s,m,e)	CONCAT(s,CONCAT(m,e))
#define	MEG	(1024*1024)
d50 1
a50 4
#if 0
int	CAT3(elf,ELFSIZE,_exec)(int, CAT3(Elf,ELFSIZE,_Ehdr) *, u_int64_t *, void **, void **);
#endif
#define ELF_ALIGN(x)	(((x)+7)&(~7))
d53 3
a55 9
CAT3(elf, ELFSIZE, _exec)(fd, elf, entryp, ssymp, esymp)
	int fd;
	CAT3(Elf,ELFSIZE,_Ehdr) *elf;
	u_int64_t *entryp;
	void **ssymp;
	void **esymp;
{
	CAT3(Elf,ELFSIZE,_Shdr) *shp;
	CAT3(Elf,ELFSIZE,_Off) off;
d72 3
a74 2
		CAT3(Elf,ELFSIZE,_Phdr) phdr;
		size = lseek(fd, (size_t)(elf->e_phoff + sizeof(phdr) * i), SEEK_SET);
d93 2
a94 2
		if ((phdr.p_vaddr & (4*MEG-1)) == 0)
			align = 4*MEG;
d96 1
a96 1
			phdr.p_memsz = roundup(phdr.p_memsz, 4*MEG);
d123 2
a124 2
	size = sizeof(CAT3(Elf,ELFSIZE,_Ehdr)) + (elf->e_shnum * sizeof(CAT3(Elf,ELFSIZE,_Shdr)));
	shp = addr = alloc(elf->e_shnum * sizeof(CAT3(Elf,ELFSIZE,_Shdr)));
d126 2
a127 2
	if (read(fd, addr, (size_t)(elf->e_shnum * sizeof(CAT3(Elf,ELFSIZE,_Shdr)))) !=
	    elf->e_shnum * sizeof(CAT3(Elf,ELFSIZE,_Shdr))) {
d153 1
a153 1
	elf->e_shoff = sizeof(CAT3(Elf,ELFSIZE,_Ehdr));
d156 3
a158 4
	bcopy(elf, addr, sizeof(CAT3(Elf,ELFSIZE,_Ehdr)));
	bcopy(shp, addr + sizeof(CAT3(Elf,ELFSIZE,_Ehdr)), 
	      elf->e_shnum * sizeof(CAT3(Elf,ELFSIZE,_Shdr)));
	free(shp, elf->e_shnum * sizeof(CAT3(Elf,ELFSIZE,_Shdr)));
d164 2
a165 3
	shp = addr + sizeof(CAT3(Elf,ELFSIZE,_Ehdr));
	size = sizeof(CAT3(Elf,ELFSIZE,_Ehdr)) +
		(elf->e_shnum * sizeof(CAT3(Elf,ELFSIZE,_Shdr)));
@


1.6
log
@Do not force the section header to SHT_NOBITS for non-symbol sections;
crank bootloader version.
@
text
@d1 1
a1 1
/*	$OpenBSD: elfXX_exec.c,v 1.5 2003/06/10 02:42:58 brad Exp $	*/
d105 2
a106 1
			phdr.p_memsz = (phdr.p_memsz + 4*MEG) & ~(4*MEG-1);
d155 1
a155 1
	if ((addr = OF_claim(0, size, NBPG)) == (void *)-1)
@


1.5
log
@- rip out support for a.out and 32-bit kernels
- cleanup and simplify Makefile
jason@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: elfXX_exec.c,v 1.4 2002/03/14 03:16:01 millert Exp $	*/
a144 1
			shp->sh_type = SHT_NOBITS;
@


1.4
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: elfXX_exec.c,v 1.3 2001/09/20 23:26:02 jason Exp $	*/
a53 3
#if defined(ELFSIZE) && (ELFSIZE == 32)
#define ELF_ALIGN(x)	(((x)+3)&(~3))
#elif defined(ELFSIZE) && (ELFSIZE == 64)
a54 3
#else
#error ELFSIZE must be either 32 or 64!
#endif
@


1.3
log
@From NetBSD: allow loading of kernels with bss+data > 4M
@
text
@d1 1
a1 1
/*	$OpenBSD: elfXX_exec.c,v 1.2 2001/08/20 19:55:33 jason Exp $	*/
d52 1
a52 1
int	CAT3(elf,ELFSIZE,_exec) __P((int, CAT3(Elf,ELFSIZE,_Ehdr) *, u_int64_t *, void **, void **));
d126 1
a126 1
			bzero((void*)(long)phdr.p_vaddr + phdr.p_filesz,
@


1.3.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: elfXX_exec.c,v 1.3 2001/09/20 23:26:02 jason Exp $	*/
d52 1
a52 1
int	CAT3(elf,ELFSIZE,_exec)(int, CAT3(Elf,ELFSIZE,_Ehdr) *, u_int64_t *, void **, void **);
d126 1
a126 1
			bzero((void *)(long)phdr.p_vaddr + phdr.p_filesz,
@


1.3.4.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.3.4.2
log
@Merge in -current from about a week ago
@
text
@d52 1
a52 1
int	CAT3(elf,ELFSIZE,_exec)(int, CAT3(Elf,ELFSIZE,_Ehdr) *, u_int64_t *, void **, void **);
d126 1
a126 1
			bzero((void *)(long)phdr.p_vaddr + phdr.p_filesz,
@


1.3.4.3
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d54 3
d58 3
@


1.2
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d111 1
a111 1
			phdr.p_memsz = 4*MEG;
@


1.1
log
@Initial revision
@
text
@d1 1
@


1.1.1.1
log
@Enough of NetBSD/sparc64 for ofwboot to compile/link
@
text
@@
