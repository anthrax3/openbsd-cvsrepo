head	1.27;
access;
symbols
	OPENBSD_6_1:1.27.0.6
	OPENBSD_6_1_BASE:1.27
	OPENBSD_6_0:1.27.0.2
	OPENBSD_6_0_BASE:1.27
	OPENBSD_5_9:1.26.0.6
	OPENBSD_5_9_BASE:1.26
	OPENBSD_5_8:1.26.0.8
	OPENBSD_5_8_BASE:1.26
	OPENBSD_5_7:1.26.0.2
	OPENBSD_5_7_BASE:1.26
	OPENBSD_5_6:1.26.0.4
	OPENBSD_5_6_BASE:1.26
	OPENBSD_5_5:1.25.0.8
	OPENBSD_5_5_BASE:1.25
	OPENBSD_5_4:1.25.0.4
	OPENBSD_5_4_BASE:1.25
	OPENBSD_5_3:1.25.0.2
	OPENBSD_5_3_BASE:1.25
	OPENBSD_5_2:1.23.0.12
	OPENBSD_5_2_BASE:1.23
	OPENBSD_5_1_BASE:1.23
	OPENBSD_5_1:1.23.0.10
	OPENBSD_5_0:1.23.0.8
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.23.0.6
	OPENBSD_4_9_BASE:1.23
	OPENBSD_4_8:1.23.0.4
	OPENBSD_4_8_BASE:1.23
	OPENBSD_4_7:1.23.0.2
	OPENBSD_4_7_BASE:1.23
	OPENBSD_4_6:1.22.0.6
	OPENBSD_4_6_BASE:1.22
	OPENBSD_4_5:1.22.0.2
	OPENBSD_4_5_BASE:1.22
	OPENBSD_4_4:1.19.0.2
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.15.0.2
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.11.0.2
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.10.0.2
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.9.0.14
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.12
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.10
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.8
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.6
	OPENBSD_3_6_BASE:1.9
	SMP_SYNC_A:1.9
	SMP_SYNC_B:1.9
	OPENBSD_3_5:1.9.0.4
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	UBC_SYNC_A:1.9
	OPENBSD_3_3:1.8.0.2
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.7.0.2
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	UBC_SYNC_B:1.7
	UBC:1.3.0.6
	UBC_BASE:1.3
	SMP:1.3.0.4
	OPENBSD_3_0:1.3.0.2
	OPENBSD_3_0_BASE:1.3;
locks; strict;
comment	@ * @;


1.27
date	2016.03.07.13.21.51;	author naddy;	state Exp;
branches;
next	1.26;
commitid	EDvRPKRZUDEEb6oR;

1.26
date	2014.03.29.18.09.30;	author guenther;	state Exp;
branches;
next	1.25;

1.25
date	2012.11.07.16.31.03;	author kettenis;	state Exp;
branches;
next	1.24;

1.24
date	2012.08.29.20.33.16;	author kettenis;	state Exp;
branches;
next	1.23;

1.23
date	2009.11.30.22.59.29;	author kettenis;	state Exp;
branches;
next	1.22;

1.22
date	2009.01.20.14.48.32;	author kettenis;	state Exp;
branches;
next	1.21;

1.21
date	2008.08.10.14.13.05;	author kettenis;	state Exp;
branches;
next	1.20;

1.20
date	2008.08.07.21.25.48;	author kettenis;	state Exp;
branches;
next	1.19;

1.19
date	2008.07.12.07.37.25;	author kettenis;	state Exp;
branches;
next	1.18;

1.18
date	2008.07.05.23.06.06;	author kettenis;	state Exp;
branches;
next	1.17;

1.17
date	2008.04.15.22.39.26;	author kettenis;	state Exp;
branches;
next	1.16;

1.16
date	2008.03.08.19.46.59;	author kettenis;	state Exp;
branches;
next	1.15;

1.15
date	2008.01.06.16.09.49;	author kettenis;	state Exp;
branches;
next	1.14;

1.14
date	2008.01.03.22.33.49;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2007.11.28.20.05.30;	author kettenis;	state Exp;
branches;
next	1.12;

1.12
date	2007.09.03.22.15.40;	author kettenis;	state Exp;
branches;
next	1.11;

1.11
date	2007.03.13.19.27.50;	author kettenis;	state Exp;
branches;
next	1.10;

1.10
date	2006.10.27.19.59.14;	author kettenis;	state Exp;
branches;
next	1.9;

1.9
date	2003.05.16.22.14.13;	author henric;	state Exp;
branches;
next	1.8;

1.8
date	2003.02.17.01.29.20;	author henric;	state Exp;
branches;
next	1.7;

1.7
date	2002.06.15.17.23.31;	author art;	state Exp;
branches;
next	1.6;

1.6
date	2002.06.09.23.04.38;	author mdw;	state Exp;
branches;
next	1.5;

1.5
date	2002.04.02.15.14.23;	author jason;	state Exp;
branches;
next	1.4;

1.4
date	2002.03.14.01.26.45;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.09.20.21.08.50;	author jason;	state Exp;
branches
	1.3.4.1
	1.3.6.1;
next	1.2;

1.2
date	2001.08.20.20.23.52;	author jason;	state Exp;
branches;
next	1.1;

1.1
date	2001.08.18.19.49.57;	author art;	state Exp;
branches;
next	;

1.3.4.1
date	2001.10.31.03.07.58;	author nate;	state Exp;
branches;
next	1.3.4.2;

1.3.4.2
date	2002.03.28.11.23.52;	author niklas;	state Exp;
branches;
next	1.3.4.3;

1.3.4.3
date	2003.03.27.23.42.36;	author niklas;	state Exp;
branches;
next	1.3.4.4;

1.3.4.4
date	2003.06.07.11.14.45;	author ho;	state Exp;
branches;
next	;

1.3.6.1
date	2002.06.11.03.38.43;	author art;	state Exp;
branches;
next	1.3.6.2;

1.3.6.2
date	2002.10.29.00.28.11;	author art;	state Exp;
branches;
next	1.3.6.3;

1.3.6.3
date	2003.05.19.21.46.57;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.27
log
@Sync no-argument function declaration and definition by adding (void).
ok mpi@@
@
text
@/*	$OpenBSD: ctlreg.h,v 1.26 2014/03/29 18:09:30 guenther Exp $	*/
/*	$NetBSD: ctlreg.h,v 1.28 2001/08/06 23:55:34 eeh Exp $ */

/*
 * Copyright (c) 1996-2001 Eduardo Horvath
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR  ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR  BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */
/*
 * Copyright (c) 2001 Jake Burkholder.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#ifndef _SPARC64_CTLREG_
#define _SPARC64_CTLREG_

/*
 * Sun 4u control registers. (includes address space definitions
 * and some registers in control space).
 */

/*
 * membar operand macros for use in other macros when # is a special
 * character.  Keep these in sync with what the hardware expects.
 */
#define C_Lookaside     (0)
#define C_MemIssue      (1)
#define C_Sync          (2)
#define M_LoadLoad      (0)
#define M_StoreLoad     (1)
#define M_LoadStore     (2)
#define M_StoreStore    (3)

#define CMASK_SHIFT     (4)
#define MMASK_SHIFT     (0)

#define CMASK_GEN(bit)  ((1 << (bit)) << CMASK_SHIFT)
#define MMASK_GEN(bit)  ((1 << (bit)) << MMASK_SHIFT)

/*
 * The Alternate address spaces. 
 * 
 * 0x00-0x7f are privileged 
 * 0x80-0xff can be used by users
 */

#define	ASI_LITTLE	0x08		/* This bit should make an ASI little endian */

#define	ASI_NUCLEUS			0x04	/* [4u] kernel address space */
#define	ASI_NUCLEUS_LITTLE		0x0c	/* [4u] kernel address space, little endian */

#define	ASI_AS_IF_USER_PRIMARY		0x10	/* [4u] primary user address space */
#define	ASI_AS_IF_USER_SECONDARY	0x11	/* [4u] secondary user address space */

#define	ASI_PHYS_CACHED			0x14	/* [4u] MMU bypass to main memory */
#define	ASI_PHYS_NON_CACHED		0x15	/* [4u] MMU bypass to I/O location */

#define	ASI_AS_IF_USER_PRIMARY_LITTLE	0x18	/* [4u] primary user address space, little endian  */
#define	ASI_AS_IF_USER_SECONDARY_LITTIE	0x19	/* [4u] secondary user address space, little endian  */

#define	ASI_PHYS_CACHED_LITTLE		0x1c	/* [4u] MMU bypass to main memory, little endian */
#define	ASI_PHYS_NON_CACHED_LITTLE	0x1d	/* [4u] MMU bypass to I/O location, little endian */

#define	ASI_SCRATCHPAD			0x20	/* [4v] scratchpad registers */
#define	ASI_MMU_CONTEXTID		0x21	/* [4v] MMU context */

#define	ASI_NUCLEUS_QUAD_LDD		0x24	/* [4u] use w/LDDA to load 128-bit item */
#define	ASI_QUEUE			0x25	/* [4v] interrupt queue registers */
#define	ASI_NUCLEUS_QUAD_LDD_LITTLE	0x2c	/* [4u] use w/LDDA to load 128-bit item, little endian */

#define	ASI_FLUSH_D_PAGE_PRIMARY	0x38	/* [4u] flush D-cache page using primary context */
#define	ASI_FLUSH_D_PAGE_SECONDARY	0x39	/* [4u] flush D-cache page using secondary context */
#define	ASI_FLUSH_D_CTX_PRIMARY		0x3a	/* [4u] flush D-cache context using primary context */
#define	ASI_FLUSH_D_CTX_SECONDARY	0x3b	/* [4u] flush D-cache context using secondary context */

#define ASI_DCACHE_INVALIDATE		0x42	/* [III] invalidate D-cache */
#define ASI_DCACHE_UTAG			0x43	/* [III] diagnostic access to D-cache micro tag */
#define ASI_DCACHE_SNOOP_TAG		0x44	/* [III] diagnostic access to D-cache snoop tag RAM */

#define	ASI_LSU_CONTROL_REGISTER	0x45	/* [4u] load/store unit control register */

#define	ASI_DCACHE_DATA			0x46	/* [4u] diagnostic access to D-cache data RAM */
#define	ASI_DCACHE_TAG			0x47	/* [4u] diagnostic access to D-cache tag RAM */

#define	ASI_INTR_DISPATCH_STATUS	0x48	/* [4u] interrupt dispatch status register */
#define	ASI_INTR_RECEIVE		0x49	/* [4u] interrupt receive status register */
#define	ASI_MID_REG			0x4a	/* [4u] hardware config and MID */
#define	ASI_ERROR_EN_REG		0x4b	/* [4u] asynchronous error enables */
#define	ASI_AFSR			0x4c	/* [4u] asynchronous fault status register */
#define	ASI_AFAR			0x4d	/* [4u] asynchronous fault address register */

#define	ASI_SCRATCH			0x4f	/* [VI] scratch registers */

#define	ASI_ICACHE_DATA			0x66	/* [4u] diagnostic access to D-cache data RAM */
#define	ASI_ICACHE_TAG			0x67	/* [4u] diagnostic access to D-cache tag RAM */
#define	ASI_FLUSH_I_PAGE_PRIMARY	0x68	/* [4u] flush D-cache page using primary context */
#define	ASI_FLUSH_I_PAGE_SECONDARY	0x69	/* [4u] flush D-cache page using secondary context */
#define	ASI_FLUSH_I_CTX_PRIMARY		0x6a	/* [4u] flush D-cache context using primary context */
#define	ASI_FLUSH_I_CTX_SECONDARY	0x6b	/* [4u] flush D-cache context using secondary context */

#define	ASI_BLOCK_AS_IF_USER_PRIMARY	0x70	/* [4u] primary user address space, block loads/stores */
#define	ASI_BLOCK_AS_IF_USER_SECONDARY	0x71	/* [4u] secondary user address space, block loads/stores */

#define	ASI_ECACHE_DIAG			0x76	/* [4u] diag access to E-cache tag and data */
#define	ASI_DATAPATH_ERR_REG_WRITE	0x77	/* [4u] ASI is reused */

#define	ASI_BLOCK_AS_IF_USER_PRIMARY_LITTLE	0x78	/* [4u] primary user address space, block loads/stores */
#define	ASI_BLOCK_AS_IF_USER_SECONDARY_LITTLE	0x79	/* [4u] secondary user address space, block loads/stores */

#define	ASI_INTERRUPT_RECEIVE_DATA	0x7f	/* [4u] interrupt receive data registers {0,1,2} */
#define	ASI_DATAPATH_ERR_REG_READ	0x7f	/* [4u] read access to datapath error registers (ASI reused) */

#define	ASI_PRIMARY			0x80	/* [4u] primary address space */
#define	ASI_SECONDARY			0x81	/* [4u] secondary address space */
#define	ASI_PRIMARY_NOFAULT		0x82	/* [4u] primary address space, no fault */
#define	ASI_SECONDARY_NOFAULT		0x83	/* [4u] secondary address space, no fault */

#define	ASI_PRIMARY_LITTLE		0x88	/* [4u] primary address space, little endian */
#define	ASI_SECONDARY_LITTLE		0x89	/* [4u] secondary address space, little endian */
#define	ASI_PRIMARY_NOFAULT_LITTLE	0x8a	/* [4u] primary address space, no fault, little endian */
#define	ASI_SECONDARY_NOFAULT_LITTLE	0x8b	/* [4u] secondary address space, no fault, little endian */

#define	ASI_PST8_PRIMARY		0xc0	/* [VIS] Eight 8-bit partial store, primary */
#define	ASI_PST8_SECONDARY		0xc1	/* [VIS] Eight 8-bit partial store, secondary */
#define	ASI_PST16_PRIMARY		0xc2	/* [VIS] Four 16-bit partial store, primary */
#define	ASI_PST16_SECONDARY		0xc3	/* [VIS] Fout 16-bit partial store, secondary */
#define	ASI_PST32_PRIMARY		0xc4	/* [VIS] Two 32-bit partial store, primary */
#define	ASI_PST32_SECONDARY		0xc5	/* [VIS] Two 32-bit partial store, secondary */

#define	ASI_PST8_PRIMARY_LITTLE		0xc8	/* [VIS] Eight 8-bit partial store, primary, little endian */
#define	ASI_PST8_SECONDARY_LITTLE	0xc9	/* [VIS] Eight 8-bit partial store, secondary, little endian */
#define	ASI_PST16_PRIMARY_LITTLE	0xca	/* [VIS] Four 16-bit partial store, primary, little endian */
#define	ASI_PST16_SECONDARY_LITTLE	0xcb	/* [VIS] Fout 16-bit partial store, secondary, little endian */
#define	ASI_PST32_PRIMARY_LITTLE	0xcc	/* [VIS] Two 32-bit partial store, primary, little endian */
#define	ASI_PST32_SECONDARY_LITTLE	0xcd	/* [VIS] Two 32-bit partial store, secondary, little endian */

#define	ASI_FL8_PRIMARY			0xd0	/* [VIS] One 8-bit load/store floating, primary */
#define	ASI_FL8_SECONDARY		0xd1	/* [VIS] One 8-bit load/store floating, secondary */
#define	ASI_FL16_PRIMARY		0xd2	/* [VIS] One 16-bit load/store floating, primary */
#define	ASI_FL16_SECONDARY		0xd3	/* [VIS] One 16-bit load/store floating, secondary */

#define	ASI_FL8_PRIMARY_LITTLE		0xd8	/* [VIS] One 8-bit load/store floating, primary, little endian */
#define	ASI_FL8_SECONDARY_LITTLE	0xd9	/* [VIS] One 8-bit load/store floating, secondary, little endian */
#define	ASI_FL16_PRIMARY_LITTLE		0xda	/* [VIS] One 16-bit load/store floating, primary, little endian */
#define	ASI_FL16_SECONDARY_LITTLE	0xdb	/* [VIS] One 16-bit load/store floating, secondary, little endian */

#define	ASI_BLOCK_COMMIT_PRIMARY	0xe0	/* [4u] block store with commit, primary */
#define	ASI_BLOCK_COMMIT_SECONDARY	0xe1	/* [4u] block store with commit, secondary */
#define	ASI_BLOCK_PRIMARY		0xf0	/* [4u] block load/store, primary */
#define	ASI_BLOCK_SECONDARY		0xf1	/* [4u] block load/store, secondary */
#define	ASI_BLOCK_PRIMARY_LITTLE	0xf8	/* [4u] block load/store, primary, little endian */
#define	ASI_BLOCK_SECONDARY_LITTLE	0xf9	/* [4u] block load/store, secondary, little endian */


/*
 * These are the shorter names used by Solaris
 */

#define	ASI_N		ASI_NUCLEUS
#define	ASI_NL		ASI_NUCLEUS_LITTLE
#define	ASI_AIUP	ASI_AS_IF_USER_PRIMARY
#define	ASI_AIUS	ASI_AS_IF_USER_SECONDARY
#define	ASI_AIUPL	ASI_AS_IF_USER_PRIMARY_LITTLE
#define	ASI_AIUSL	ASI_AS_IF_USER_SECONDARY_LITTLE
#define	ASI_P		ASI_PRIMARY
#define	ASI_S		ASI_SECONDARY
#define	ASI_PNF		ASI_PRIMARY_NOFAULT
#define	ASI_SNF		ASI_SECONDARY_NOFAULT
#define	ASI_PL		ASI_PRIMARY_LITTLE
#define	ASI_SL		ASI_SECONDARY_LITTLE
#define	ASI_PNFL	ASI_PRIMARY_NOFAULT_LITTLE
#define	ASI_SNFL	ASI_SECONDARY_NOFAULT_LITTLE
#define	ASI_FL8_P	ASI_FL8_PRIMARY
#define	ASI_FL8_S	ASI_FL8_SECONDARY
#define	ASI_FL16_P	ASI_FL16_PRIMARY
#define	ASI_FL16_S	ASI_FL16_SECONDARY
#define	ASI_FL8_PL	ASI_FL8_PRIMARY_LITTLE
#define	ASI_FL8_SL	ASI_FL8_SECONDARY_LITTLE
#define	ASI_FL16_PL	ASI_FL16_PRIMARY_LITTLE
#define	ASI_FL16_SL	ASI_FL16_SECONDARY_LITTLE
#define	ASI_BLK_AIUP	ASI_BLOCK_AS_IF_USER_PRIMARY
#define	ASI_BLK_AIUPL	ASI_BLOCK_AS_IF_USER_PRIMARY_LITTLE
#define	ASI_BLK_AIUS	ASI_BLOCK_AS_IF_USER_SECONDARY
#define	ASI_BLK_AIUSL	ASI_BLOCK_AS_IF_USER_SECONDARY_LITTLE
#define	ASI_BLK_COMMIT_P		ASI_BLOCK_COMMIT_PRIMARY
#define	ASI_BLK_COMMIT_PRIMARY		ASI_BLOCK_COMMIT_PRIMARY
#define	ASI_BLK_COMMIT_S		ASI_BLOCK_COMMIT_SECONDARY
#define	ASI_BLK_COMMIT_SECONDARY	ASI_BLOCK_COMMIT_SECONDARY
#define	ASI_BLK_P			ASI_BLOCK_PRIMARY
#define	ASI_BLK_PL			ASI_BLOCK_PRIMARY_LITTLE
#define	ASI_BLK_S			ASI_BLOCK_SECONDARY
#define	ASI_BLK_SL			ASI_BLOCK_SECONDARY_LITTLE

/* Alternative spellings */
#define ASI_PRIMARY_NO_FAULT		ASI_PRIMARY_NOFAULT
#define ASI_PRIMARY_NO_FAULT_LITTLE	ASI_PRIMARY_NOFAULT_LITTLE
#define ASI_SECONDARY_NO_FAULT		ASI_SECONDARY_NOFAULT
#define ASI_SECONDARY_NO_FAULT_LITTLE	ASI_SECONDARY_NOFAULT_LITTLE

#define	PHYS_ASI(x)	(((x) | 0x09) == 0x1d)
#define	LITTLE_ASI(x)	((x) & ASI_LITTLE)

/*
 * %tick: cpu cycle counter
 */
#define	TICK_NPT	0x8000000000000000	/* trap on non priv access */
#define	TICK_TICKS	0x7fffffffffffffff	/* counter bits */

/* 
 * The following are 4u control registers
 */

/* Get the CPU's UPA port ID */
#define	UPA_CR_MID(x)		(((x) >> 17) & 0x1f)
#define	CPU_UPAID		UPA_CR_MID(ldxa(0, ASI_MID_REG))

/* Get the CPU's Fireplane agent ID */
#define FIREPLANE_CR_AID(x)	(((x) >> 17) & 0x3ff)
#define CPU_FIREPLANEID		FIREPLANE_CR_AID(ldxa(0, ASI_MID_REG))

/* Get the CPU's Jupiter Bus interrupt target ID */
#define JUPITER_CR_ITID(x)	((x) & 0x3ff)
#define CPU_JUPITERID		JUPITER_CR_ITID(ldxa(0, ASI_MID_REG))

/*
 * [4u] MMU and Cache Control Register (MCCR)
 * use ASI = 0x45
 */
#define	ASI_MCCR	ASI_LSU_CONTROL_REGISTER
#define	MCCR		0x00

/* MCCR Bits and their meanings */
#define	MCCR_DMMU_EN	0x08
#define	MCCR_IMMU_EN	0x04
#define	MCCR_DCACHE_EN	0x02
#define	MCCR_ICACHE_EN	0x01


/*
 * MMU control registers
 */

/* Choose an MMU */
#define	ASI_DMMU		0x58
#define	ASI_IMMU		0x50

/* Other assorted MMU ASIs */
#define	ASI_IMMU_8KPTR		0x51
#define	ASI_IMMU_64KPTR		0x52
#define	ASI_IMMU_DATA_IN	0x54
#define	ASI_IMMU_TLB_DATA	0x55
#define	ASI_IMMU_TLB_TAG	0x56
#define	ASI_DMMU_8KPTR		0x59
#define	ASI_DMMU_64KPTR		0x5a
#define	ASI_DMMU_DATA_IN	0x5c
#define	ASI_DMMU_TLB_DATA	0x5d
#define	ASI_DMMU_TLB_TAG	0x5e

/* 
 * The following are the control registers 
 * They work on both MMUs unless noted.
 * III = cheetah only
 *
 * Register contents are defined later on individual registers.
 */
#define	TSB_TAG_TARGET		0x0
#define	TLB_DATA_IN		0x0
#define	CTX_PRIMARY		0x08	/* primary context -- DMMU only */
#define	CTX_SECONDARY		0x10	/* secondary context -- DMMU only */
#define	SFSR			0x18
#define	SFAR			0x20	/* fault address -- DMMU only */
#define	TSB			0x28
#define	TLB_TAG_ACCESS		0x30
#define	VIRTUAL_WATCHPOINT	0x38
#define	PHYSICAL_WATCHPOINT	0x40
#define TSB_PEXT		0x48	/* III primary ext */
#define TSB_SEXT		0x50	/* III 2ndary ext -- DMMU only */
#define TSB_NEXT		0x58	/* III nucleus ext */

/* Tag Target bits */
#define	TAG_TARGET_VA_MASK	0x03ffffffffffffffffLL
#define	TAG_TARGET_VA(x)	(((x)<<22)&TAG_TARGET_VA_MASK)
#define	TAG_TARGET_CONTEXT(x)	((x)>>48)
#define	TAG_TARGET(c,v)		((((uint64_t)c)<<48)|(((uint64_t)v)&TAG_TARGET_VA_MASK))

/* SFSR bits for both D_SFSR and I_SFSR */
#define	SFSR_NF			0x1000000	/* Non-faulting load */
#define	SFSR_ASI(x)		((x)>>16)
#define	SFSR_TM			0x0008000	/* TLB miss  */
#define	SFSR_FT_VA_OOR_2	0x0002000	/* IMMU: jumpl or return to unsupportd VA */
#define	SFSR_FT_VA_OOR_1	0x0001000	/* fault at unsupported VA */
#define	SFSR_FT_NFO		0x0000800	/* DMMU: Access to page marked NFO */
#define	SFSR_ILL_ASI		0x0000400	/* DMMU: Illegal (unsupported) ASI */
#define	SFSR_FT_IO_ATOMIC	0x0000200	/* DMMU: Atomic access to noncacheable page */
#define	SFSR_FT_ILL_NF		0x0000100	/* DMMU: NF load or flush to page marked E (has side effects) */
#define	SFSR_FT_PRIV		0x0000080	/* Privilege violation */
#define	SFSR_FT_E		0x0000040	/* DMUU: value of E bit associated address */
#define	SFSR_CTXT(x)		(((x)>>4)&0x3)
#define	SFSR_CTXT_IS_PRIM(x)	(SFSR_CTXT(x)==0x00)
#define	SFSR_CTXT_IS_SECOND(x)	(SFSR_CTXT(x)==0x01)
#define	SFSR_CTXT_IS_NUCLEUS(x)	(SFSR_CTXT(x)==0x02)
#define	SFSR_PRIV		0x0000008	/* value of PSTATE.PRIV for faulting access */
#define	SFSR_W			0x0000004 	/* DMMU: attempted write */
#define	SFSR_OW			0x0000002 	/* Overwrite; prev fault was still valid */
#define	SFSR_FV			0x0000001	/* Fault is valid */
#define	SFSR_FT	(SFSR_FT_VA_OOR_2|SFSR_FT_VA_OOR_1|SFSR_FT_NFO|SFSR_ILL_ASI|SFSR_FT_IO_ATOMIC|SFSR_FT_ILL_NF|SFSR_FT_PRIV)

#define	SFSR_BITS "\20\31NF\20TM\16VAT\15VAD\14NFO\13ASI\12A\11NF\10PRIV\7E\6NUCLEUS\5SECONDCTX\4PRIV\3W\2OW\1FV"

/* ASFR bits */
#define	ASFR_ME			0x100000000LL
#define	ASFR_PRIV		0x080000000LL
#define	ASFR_ISAP		0x040000000LL
#define	ASFR_ETP		0x020000000LL
#define	ASFR_IVUE		0x010000000LL
#define	ASFR_TO			0x008000000LL
#define	ASFR_BERR		0x004000000LL
#define	ASFR_LDP		0x002000000LL
#define	ASFR_CP			0x001000000LL
#define	ASFR_WP			0x000800000LL
#define	ASFR_EDP		0x000400000LL
#define	ASFR_UE			0x000200000LL
#define	ASFR_CE			0x000100000LL
#define	ASFR_ETS		0x0000f0000LL
#define	ASFT_P_SYND		0x00000ffffLL

#define	AFSR_BITS "\20" \
    "\20ME\37PRIV\36ISAP\35ETP\34IVUE\33TO\32BERR\31LDP\30CP\27WP\26EDP" \
    "\25UE\24CE"

/*  
 * Here's the spitfire TSB control register bits.
 * 
 * Each TSB entry is 16-bytes wide.  The TSB must be size aligned
 */
#define	TSB_SIZE_512		0x0	/* 8kB, etc. */	
#define	TSB_SIZE_1K		0x01
#define	TSB_SIZE_2K		0x02	
#define	TSB_SIZE_4K		0x03	
#define	TSB_SIZE_8K		0x04
#define	TSB_SIZE_16K		0x05
#define	TSB_SIZE_32K		0x06
#define	TSB_SIZE_64K		0x07
#define	TSB_SPLIT		0x1000
#define	TSB_BASE		0xffffffffffffe000

/*  TLB Tag Access bits */
#define	TLB_TAG_ACCESS_VA	0xffffffffffffe000
#define	TLB_TAG_ACCESS_CTX	0x0000000000001fff

/*
 * TLB demap registers.  TTEs are defined in v9pte.h
 *
 * Use the address space to select between IMMU and DMMU.
 * The address of the register selects which context register
 * to read the ASI from.  
 *
 * The data stored in the register is interpreted as the VA to
 * use.  The DEMAP_CTX_<> registers ignore the address and demap the
 * entire ASI.
 * 
 */
#define	ASI_IMMU_DEMAP			0x57	/* [4u] IMMU TLB demap */
#define	ASI_DMMU_DEMAP			0x5f	/* [4u] IMMU TLB demap */

#define	DEMAP_PAGE_NUCLEUS		((0x02)<<4)	/* Demap page from kernel AS */
#define	DEMAP_PAGE_PRIMARY		((0x00)<<4)	/* Demap a page from primary CTXT */
#define	DEMAP_PAGE_SECONDARY		((0x01)<<4)	/* Demap page from secondary CTXT (DMMU only) */
#define	DEMAP_CTX_NUCLEUS		((0x06)<<4)	/* Demap all of kernel CTXT */
#define	DEMAP_CTX_PRIMARY		((0x04)<<4)	/* Demap all of primary CTXT */
#define	DEMAP_CTX_SECONDARY		((0x05)<<4)	/* Demap all of secondary CTXT */

/*
 * Interrupt registers.  This really gets hairy.
 */

/* IRSR -- Interrupt Receive Status Ragister */
#define	ASI_IRSR	0x49
#define	IRSR		0x00
#define	IRSR_BUSY	0x020
#define	IRSR_MID(x)	(x&0x1f)

/* IRDR -- Interrupt Receive Data Registers */
#define	ASI_IRDR	0x7f
#define	IRDR_0H		0x40
#define	IRDR_0L		0x48	/* unimplemented */
#define	IRDR_1H		0x50
#define	IRDR_1L		0x58	/* unimplemented */
#define	IRDR_2H		0x60
#define	IRDR_2L		0x68	/* unimplemented */
#define	IRDR_3H		0x70	/* unimplemented */
#define	IRDR_3L		0x78	/* unimplemented */

/* SOFTINT ASRs */
#define	SET_SOFTINT	%asr20	/* Sets these bits */
#define	CLEAR_SOFTINT	%asr21	/* Clears these bits */
#define	SOFTINT		%asr22	/* Reads the register */
#define	TICK_CMPR	%asr23

#define	TICK_INT	0x01	/* level-14 clock tick */
#define	SOFTINT1	(0x1<<1)
#define	SOFTINT2	(0x1<<2)
#define	SOFTINT3	(0x1<<3)
#define	SOFTINT4	(0x1<<4)
#define	SOFTINT5	(0x1<<5)
#define	SOFTINT6	(0x1<<6)
#define	SOFTINT7	(0x1<<7)
#define	SOFTINT8	(0x1<<8)
#define	SOFTINT9	(0x1<<9)
#define	SOFTINT10	(0x1<<10)
#define	SOFTINT11	(0x1<<11)
#define	SOFTINT12	(0x1<<12)
#define	SOFTINT13	(0x1<<13)
#define	SOFTINT14	(0x1<<14)
#define	SOFTINT15	(0x1<<15)
#define	STICK_INT	(0x1<<16)

/* Interrupt Dispatch -- usually reserved for cross-calls */
#define	ASR_IDSR	0x48 /* Interrupt dispatch status reg */
#define	IDSR		0x00
#define	IDSR_NACK	0x02
#define	IDSR_BUSY	0x01

#define	ASI_INTERRUPT_DISPATCH		0x77	/* [4u] spitfire interrupt dispatch regs */

/* Interrupt delivery initiation */
#define	IDCR(x)		((((u_int64_t)(x)) << 14) | 0x70)

#define	IDDR_0H		0x40	/* Store data to send in these regs */
#define	IDDR_0L		0x48	/* unimplemented */
#define	IDDR_1H		0x50
#define	IDDR_1L		0x58	/* unimplemented */
#define	IDDR_2H		0x60
#define	IDDR_2L		0x68	/* unimplemented */
#define	IDDR_3H		0x80	/* unimplemented */
#define	IDDR_3L		0x88	/* unimplemented */

/*
 * Error registers 
 */

/* Since we won't try to fix async errs, we don't care about the bits in the regs */
#define	ASI_AFAR	0x4d	/* Asynchronous fault address register */
#define	AFAR		0x00
#define	ASI_AFSR	0x4c	/* Asynchronous fault status register */
#define	AFSR		0x00

#define	ASI_P_EER	0x4b	/* Error enable register */
#define	P_EER		0x00
#define	P_EER_ISAPEN	0x04	/* Enable fatal on ISAP */
#define	P_EER_NCEEN	0x02	/* Enable trap on uncorrectable errs */
#define	P_EER_CEEN	0x01	/* Enable trap on correctable errs */

#define	ASI_DATAPATH_READ	0x7f /* Read the regs */
#define	ASI_DATAPATH_WRITE	0x77 /* Write to the regs */
#define	P_DPER_0	0x00	/* Datapath err reg 0 */
#define	P_DPER_1	0x18	/* Datapath err reg 1 */
#define	P_DCR_0		0x20	/* Datapath control reg 0 */
#define	P_DCR_1		0x38	/* Datapath control reg 0 */


/* From sparc64/asm.h which I think I'll deprecate since it makes bus.h a pain. */

#ifndef _LOCORE
/*
 * GCC __asm constructs for doing assembly stuff.
 */

/*
 * ``Routines'' to load and store from/to alternate address space.
 * The location can be a variable, the asi value (address space indicator)
 * must be a constant.
 *
 * N.B.: You can put as many special functions here as you like, since
 * they cost no kernel space or time if they are not used.
 *
 * These were static inline functions, but gcc screws up the constraints
 * on the address space identifiers (the "n"umeric value part) because
 * it inlines too late, so we have to use the funny valued-macro syntax.
 */

/* 
 * Apparently the definition of bypass ASIs is that they all use the 
 * D$ so we need to flush the D$ to make sure we don't get data pollution.
 */

#define sparc_membar(mask) do {						\
	if (mask)							\
		__asm volatile("membar %0" : : "n" (mask) : "memory");	\
	else								\
		__asm volatile("" : : : "memory");			\
} while(0)

#define membar sparc_membar
#define Lookaside       CMASK_GEN(C_Lookaside)
#define MemIssue        CMASK_GEN(C_MemIssue)
#define Sync            CMASK_GEN(C_Sync)
#define LoadLoad        MMASK_GEN(M_LoadLoad)
#define StoreLoad       MMASK_GEN(M_StoreLoad)
#define LoadStore       MMASK_GEN(M_LoadStore)
#define StoreStore      MMASK_GEN(M_StoreStore)

#define sparc_wr(name, val, xor)					\
do {									\
	if (__builtin_constant_p(xor))					\
		__asm volatile("wr %%g0, %0, %%" #name			\
		    : : "rI" ((val) ^ (xor)) : "%g0");			\
	else								\
		__asm volatile("wr %0, %1, %%" #name			\
		    : : "r" (val), "rI" (xor) : "%g0");			\
} while(0)

#define sparc_wrpr(name, val, xor)					\
do {									\
	if (__builtin_constant_p(xor))					\
		__asm volatile("wrpr %%g0, %0, %%" #name		\
		    : : "rI" ((val) ^ (xor)) : "%g0");			\
	else								\
		__asm volatile("wrpr %0, %1, %%" #name			\
		    : : "r" (val), "rI" (xor) : "%g0");			\
	__asm volatile("" : : : "memory");				\
} while(0)


#define sparc_rd(name) sparc_rd_ ## name()
#define GEN_RD(name)							\
extern __inline u_int64_t sparc_rd_ ## name(void);			\
extern __inline u_int64_t						\
sparc_rd_ ## name()							\
{									\
	u_int64_t r;							\
	__asm volatile("rd %%" #name ", %0" :				\
	    "=r" (r) : : "%g0");					\
	return (r);							\
}

#define sparc_rdpr(name) sparc_rdpr_ ## name()
#define GEN_RDPR(name)							\
extern __inline u_int64_t sparc_rdpr_ ## name(void);			\
extern __inline u_int64_t						\
sparc_rdpr_ ## name()							\
{									\
	u_int64_t r;							\
	__asm volatile("rdpr %%" #name ", %0" :				\
	    "=r" (r) : : "%g0");					\
	return (r);							\
}

GEN_RD(asi);
GEN_RD(fprs);
GEN_RD(asr22);
GEN_RD(sys_tick);
GEN_RD(sys_tick_cmpr);
GEN_RDPR(tick);
GEN_RDPR(tba);
GEN_RDPR(pstate);
GEN_RDPR(pil);
GEN_RDPR(cwp);
GEN_RDPR(cansave);
GEN_RDPR(canrestore);
GEN_RDPR(cleanwin);
GEN_RDPR(otherwin);
GEN_RDPR(wstate);
GEN_RDPR(ver);
/*
 * Before adding GEN_RDPRs for other registers, see Errata 50 (E.g,. in
 * the US-IIi manual) regarding tstate, pc and npc reads.
 */

/* Generate ld*a/st*a functions for non-constant ASI's. */
#define LDNC_GEN(tp, o)							\
	extern __inline tp o ## _asi(paddr_t);				\
	extern __inline tp						\
	o ## _asi(paddr_t va)						\
	{								\
		tp r;							\
		__asm volatile(						\
		    #o " [%1] %%asi, %0"				\
		    : "=r" (r)						\
		    : "r" ((volatile tp *)va)				\
		    : "%g0");						\
		return (r);						\
	}								\
	extern __inline tp o ## _nc(paddr_t, int);			\
	extern __inline tp						\
	o ## _nc(paddr_t va, int asi)					\
	{								\
		sparc_wr(asi, asi, 0);					\
		return (o ## _asi(va));					\
	}

LDNC_GEN(u_char, lduba);
LDNC_GEN(u_short, lduha);
LDNC_GEN(u_int, lduwa);
LDNC_GEN(u_int64_t, ldxa);

LDNC_GEN(int, lda);

#define LDC_GEN(va, asi, op, opa, type) ({				\
	type __r ## op ## type;						\
	if(asi == ASI_PRIMARY  || 					\
	    (sizeof(type) == 1 && asi == ASI_PRIMARY_LITTLE))		\
		__r ## op ## type = *((volatile type *)va);		\
	else								\
		__asm volatile(#opa " [%1] " #asi ", %0"		\
		    : "=r" (__r ## op ## type)				\
		    : "r" ((volatile type *)va)				\
		    : "%g0");						\
	__r ## op ## type;						\
})

#ifdef __OPTIMIZE__
#define LD_GENERIC(va, asi, op, type) (__builtin_constant_p(asi) ?	\
	LDC_GEN((va), asi, op, op ## a, type) : op ## a_nc((va), asi))
#else /* __OPTIMIZE */
#define LD_GENERIC(va, asi, op, type) (op ## a_nc((va), asi))
#endif /* __OPTIMIZE__ */

#define lduba(va, asi)	LD_GENERIC(va, asi, ldub, u_int8_t)
#define lduha(va, asi)	LD_GENERIC(va, asi, lduh, u_int16_t)
#define lduwa(va, asi)	LD_GENERIC(va, asi, lduw, u_int32_t)
#define ldxa(va, asi)	LD_GENERIC(va, asi, ldx, u_int64_t)

#define STNC_GEN(tp, o)							\
	extern __inline void o ## _asi(paddr_t, tp);			\
	extern __inline void						\
	o ## _asi(paddr_t va, tp val)					\
	{								\
		__asm volatile(						\
		    #o " %0, [%1] %%asi"				\
		    :							\
		    : "r" (val), "r" ((volatile tp *)va)		\
		    : "memory");					\
	}								\
	extern __inline void o ## _nc(paddr_t, int, tp);		\
	extern __inline void						\
	o ## _nc(paddr_t va, int asi, tp val)				\
	{								\
		sparc_wr(asi, asi, 0);					\
		o ## _asi(va, val);					\
	}

STNC_GEN(u_int8_t, stba);
STNC_GEN(u_int16_t, stha);
STNC_GEN(u_int32_t, stwa);
STNC_GEN(u_int64_t, stxa);

STNC_GEN(u_int, sta);

#define STC_GEN(va, asi, val, op, opa, type) ({				\
	if(asi == ASI_PRIMARY ||					\
	    (sizeof(type) == 1 && asi == ASI_PRIMARY_LITTLE))		\
		*((volatile type *)va) = val;				\
	else								\
		__asm volatile(#opa " %0, [%1] " #asi			\
		    : : "r" (val), "r" ((volatile type *)va)		\
		    : "memory");					\
	})

#ifdef __OPTIMIZE__
#define ST_GENERIC(va, asi, val, op, type) (__builtin_constant_p(asi) ?	\
	STC_GEN((va), (asi), (val), op, op ## a, type) :		\
	op ## a_nc((va), asi, (val)))
#else /* __OPTIMIZE__ */
#define ST_GENERIC(va, asi, val, op, type) (op ## a_nc((va), asi, (val)))
#endif /* __OPTIMIZE__ */

#define stba(va, asi, val)	ST_GENERIC(va, asi, val, stb, u_int8_t)
#define stha(va, asi, val)	ST_GENERIC(va, asi, val, sth, u_int16_t)
#define stwa(va, asi, val)	ST_GENERIC(va, asi, val, stw, u_int32_t)
#define stxa(va, asi, val)	ST_GENERIC(va, asi, val, stx, u_int64_t)


extern __inline void asi_set(int);
extern __inline
void asi_set(int asi)
{
	sparc_wr(asi, asi, 0);
}

extern __inline u_int8_t asi_get(void);
extern __inline
u_int8_t asi_get(void)
{
	return sparc_rd(asi);
}

/* flush address from instruction cache */
extern __inline void flush(void *);
extern __inline
void flush(void *p)
{
	__asm volatile("flush %0"
	    : : "r" (p)
	    : "memory");
}

/* Read 64-bit %tick and %sys_tick registers. */
#define tick() (sparc_rdpr(tick) & TICK_TICKS)
#define sys_tick() (sparc_rd(sys_tick) & TICK_TICKS)
extern u_int64_t stick(void);

extern void tick_enable(void);

extern void tickcmpr_set(u_int64_t);
extern void sys_tickcmpr_set(u_int64_t);
extern void stickcmpr_set(u_int64_t);

#endif /* _LOCORE */
#endif /* _SPARC64_CTLREG_ */
@


1.26
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ctlreg.h,v 1.25 2012/11/07 16:31:03 kettenis Exp $	*/
d721 1
a721 1
u_int8_t asi_get()
@


1.25
log
@Enable %tick access for userland on sun4u systems (sun4v systems already have
this enabled).

ok pirofti@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ctlreg.h,v 1.24 2012/08/29 20:33:16 kettenis Exp $	*/
d525 5
a529 5
#define sparc_membar(mask) do {                                         \
        if (mask)                                                       \
                __asm __volatile("membar %0" : : "n" (mask) : "memory");\
        else                                                            \
                __asm __volatile("" : : : "memory");                    \
d544 1
a544 1
		__asm __volatile("wr %%g0, %0, %%" #name		\
d547 1
a547 1
		__asm __volatile("wr %0, %1, %%" #name			\
d554 1
a554 1
		__asm __volatile("wrpr %%g0, %0, %%" #name		\
d557 1
a557 1
		__asm __volatile("wrpr %0, %1, %%" #name		\
d559 1
a559 1
	__asm __volatile("" : : : "memory");				\
d570 1
a570 1
	__asm __volatile("rd %%" #name ", %0" :				\
d582 1
a582 1
	__asm __volatile("rdpr %%" #name ", %0" :			\
d615 1
a615 1
		__asm __volatile(					\
d643 1
a643 1
		__asm __volatile(#opa " [%1] " #asi ", %0"		\
d667 1
a667 1
		__asm __volatile(					\
d693 1
a693 1
		__asm __volatile(#opa " %0, [%1] " #asi			\
d731 1
a731 1
	__asm __volatile("flush %0"
@


1.24
log
@The low-level guts to support MTP (Multi-Threaded Processing) on the
Fujitsu SPARC64-VI and SPARC64-VII CPUs.  Since the two threads on each core
share the TLBs of the core we cannot enter different mappings for the same
virtual address.  Instead we use a scratch register to store the per-cpu
pointer.  This is very similar to what we do on sun4v.

For now we still only attach the first thread of each SPARC64-VI/VII core
since we currently don't handle the VMT (Vertical Multi-Threading) of the
SPARC64-VI very well.
@
text
@d1 1
a1 1
/*	$OpenBSD: ctlreg.h,v 1.19 2008/07/12 07:37:25 kettenis Exp $	*/
d740 2
@


1.23
log
@Add inline function to read %fprs.
@
text
@d1 1
a1 1
/*	$OpenBSD: ctlreg.h,v 1.22 2009/01/20 14:48:32 kettenis Exp $	*/
d129 2
@


1.22
log
@Add a few more inline functions to read priviliged registers.
@
text
@d1 1
a1 1
/*	$OpenBSD: ctlreg.h,v 1.21 2008/08/10 14:13:05 kettenis Exp $	*/
d586 1
@


1.21
log
@Use the STICK logic on UltraSPARC-IIe to generate clock interrupts.
@
text
@d1 1
a1 1
/*	$OpenBSD: ctlreg.h,v 1.20 2008/08/07 21:25:48 kettenis Exp $	*/
a588 1
GEN_RDPR(cwp);
d590 1
d593 6
a598 1
GEN_RDPR(tba);
@


1.20
log
@Use %sys_tick to generate clock interrupts on systems that have it.
@
text
@d1 1
a1 1
/*	$OpenBSD: ctlreg.h,v 1.19 2008/07/12 07:37:25 kettenis Exp $	*/
d731 1
d735 1
@


1.19
log
@Add macros to get the appropriate interrupt target ID for non-UPA CPUs and
use them in cpu_myid().
@
text
@d1 1
a1 1
/*	$OpenBSD: ctlreg.h,v 1.17 2008/04/15 22:39:26 kettenis Exp $	*/
d587 2
d728 1
a728 1
/* read 64-bit %tick register */
d730 1
d733 1
@


1.18
log
@Add function to read %tba.
@
text
@d249 3
d253 7
a259 3
/* Get the CPU's UPAID */
#define	UPA_CR_MID(x)	(((x)>>17)&0x1f)	
#define	CPU_UPAID	UPA_CR_MID(ldxa(0, ASI_MID_REG))
@


1.17
log
@Add workaround for UltraSPARC-II errata, where writes to %tick_cmpr would
sometimes fail, which would result in the periodic clock interrupts on a CPU
stop.

Spotted in a NetBSD commit message, loosely based on code in OpenSolaris.
@
text
@d1 1
a1 1
/*	$OpenBSD: ctlreg.h,v 1.16 2008/03/08 19:46:59 kettenis Exp $	*/
d584 1
@


1.16
log
@Add som sun4v-specific ASIs.
@
text
@d1 1
a1 1
/*	$OpenBSD: ctlreg.h,v 1.15 2008/01/06 16:09:49 kettenis Exp $	*/
d721 1
a721 1
extern void next_tick(long);
@


1.15
log
@Add STICK_INT.
@
text
@d1 1
a1 1
/*	$OpenBSD: ctlreg.h,v 1.14 2008/01/03 22:33:49 miod Exp $	*/
d102 3
d106 1
@


1.14
log
@Add an explicit clobber to prevent gcc from reordering instructions around
sparc_wrpr(), similar to the psl.h changes years ago; ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ctlreg.h,v 1.13 2007/11/28 20:05:30 kettenis Exp $	*/
d441 1
@


1.13
log
@Garbage collect sparc_cas() and sparc_casx().  We have equivalent functions
in <machine/atomic.h> now and they're not used anywhere in our tree.
@
text
@d1 1
a1 1
/*	$OpenBSD: ctlreg.h,v 1.12 2007/09/03 22:15:40 kettenis Exp $	*/
d545 1
@


1.12
log
@Fix a few interrupt dispatch/receive register definitions.
@
text
@d1 1
a1 1
/*	$OpenBSD: ctlreg.h,v 1.11 2007/03/13 19:27:50 kettenis Exp $	*/
a509 22

extern __inline u_int32_t sparc_cas(u_int32_t *, u_int32_t, u_int32_t);
extern __inline u_int32_t
sparc_cas(u_int32_t *rs1, u_int32_t rs2, u_int32_t rd)
{
	__asm __volatile("casa [%1] ASI_PRIMARY, %2, %0"
	    : "+r" (rd)
	    : "r" (rs1), "r" (rs2)
	    : "memory" );
	return (rd);
}

extern __inline u_int64_t sparc_casx(u_int64_t *, u_int64_t, u_int64_t);
extern __inline u_int64_t
sparc_casx(u_int64_t *rs1, u_int64_t rs2, u_int64_t rd)
{
	__asm __volatile("casxa [%1] ASI_PRIMARY, %3, %0"
	    : "+r" (rd)
	    : "r" (rs1), "r" (rs2)
	    : "memory" );
	return (rd);
}
@


1.11
log
@Add two more SFSR bits found on UltraSPARC-III cpus.
@
text
@d1 1
a1 1
/*	$OpenBSD: ctlreg.h,v 1.10 2006/10/27 19:59:14 kettenis Exp $	*/
d449 5
a453 2
#define	IDCR(x)		(((x)<<14)&0x70)	/* Store anything to this address to dispatch crosscall to CPU (x) */
#define	IDDR_0H		0x40			/* Store data to send in these regs */
d459 2
a460 2
#define	IDDR_3H		0x70	/* unimplemented */
#define	IDDR_3L		0x78	/* unimplemented */
@


1.10
log
@Add a few UltraSPARC-III ASI's.
@
text
@d1 1
a1 1
/*	$OpenBSD: ctlreg.h,v 1.9 2003/05/16 22:14:13 henric Exp $	*/
d312 1
d314 9
a322 8
#define	SFSR_FT_VA_OOR_2	0x02000 /* IMMU: jumpl or return to unsupportd VA */
#define	SFSR_FT_VA_OOR_1	0x01000 /* fault at unsupported VA */
#define	SFSR_FT_NFO		0x00800	/* DMMU: Access to page marked NFO */
#define	SFSR_ILL_ASI		0x00400	/* DMMU: Illegal (unsupported) ASI */
#define	SFSR_FT_IO_ATOMIC	0x00200	/* DMMU: Atomic access to noncacheable page */
#define	SFSR_FT_ILL_NF		0x00100	/* DMMU: NF load or flush to page marked E (has side effects) */
#define	SFSR_FT_PRIV		0x00080	/* Privilege violation */
#define	SFSR_FT_E		0x00040	/* DMUU: value of E bit associated address */
d327 4
a330 4
#define	SFSR_PRIV		0x00008	/* value of PSTATE.PRIV for faulting access */
#define	SFSR_W			0x00004 /* DMMU: attempted write */
#define	SFSR_OW			0x00002 /* Overwrite; prev vault was still valid */
#define	SFSR_FV			0x00001	/* Fault is valid */
d333 1
a333 1
#define	SFSR_BITS "\20\16VAT\15VAD\14NFO\13ASI\12A\11NF\10PRIV\7E\6NUCLEUS\5SECONDCTX\4PRIV\3W\2OW\1FV"
@


1.9
log
@Clean up low-level sparc register access wrappers.  Specify clobbers for
everything (so gcc doesn't assume everything is clobbered).

ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ctlreg.h,v 1.8 2003/02/17 01:29:20 henric Exp $	*/
d109 4
@


1.8
log
@
Add support for the Sun Enterprise 450
Reduce the size of a GENERIC kernel by ~190k
Remove the nasty pointer/bus_space_handle_t casts
Adds debug bus_space code including the ability to trace
    bus operations (it actually works now).

The following rules are now followed (and verfified by the debug
code):

1.  A "bus_space_handle_t" may only be used with the
    "bus_space_tag_t" that created it.
2.  Only "bus_space_map()" may create "bus_space_handle_t"s.
3.  A "bus_space_handle_t" may not be modified after it has
    been created (other than being destroyed by "bus_space_unmap()").


Thanks to help from mcbride, marc, jason, drahn, to anyone that might
have slipped my mind at the moment.

ok jason@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ctlreg.h,v 1.7 2002/06/15 17:23:31 art Exp $	*/
d52 2
a77 24
#ifndef __ASSEMBLER__
#define Lookaside       CMASK_GEN(C_Lookaside)
#define MemIssue        CMASK_GEN(C_MemIssue)
#define Sync            CMASK_GEN(C_Sync)
#define LoadLoad        MMASK_GEN(M_LoadLoad)
#define StoreLoad       MMASK_GEN(M_StoreLoad)
#define LoadStore       MMASK_GEN(M_LoadStore)
#define StoreStore      MMASK_GEN(M_StoreStore)
#endif

#define casa(rs1, rs2, rd, asi) ({                                      \
	u_int __rd = (u_int32_t)(rd);                                   \
	__asm __volatile("casa [%1] %2, %3, %0"                         \
	    : "+r" (__rd) : "r" (rs1), "n" (asi), "r" (rs2));           \
	__rd;                                                           \
})

#define casxa(rs1, rs2, rd, asi) ({                                     \
	u_long __rd = (u_int64_t)(rd);                                  \
	__asm __volatile("casxa [%1] %2, %3, %0"                        \
	    : "+r" (__rd) : "r" (rs1), "n" (asi), "r" (rs2));           \
	__rd;                                                           \
})

d502 95
d599 1
a599 1
	extern __inline tp o ## _nc(paddr_t, int);			\
d601 1
a601 1
	o ## _nc(paddr_t va, int asi)					\
d605 1
a605 1
		    "wr %2, 0, %%asi;" #o " [%1] %%asi, %0"		\
d607 2
a608 1
		    : "r" ((volatile tp *)va), "r" (asi));		\
d611 1
a611 1
	extern __inline tp o ## _asi(paddr_t);				\
d613 1
a613 1
	o ## _asi(paddr_t va)						\
d615 2
a616 6
		tp r;							\
		__asm __volatile(					\
		    #o " [%1] %%asi, %0"				\
		    : "=r" (r)						\
		    : "r" ((volatile tp *)va));				\
		return (r);						\
a630 2
		/*__asm __volatile(#op " [%1], %0"			\
		    : "=r" (__r ## op ## type) : "r" (va));*/		\
d634 2
a635 1
		    : "r" ((volatile type *)va));			\
d641 8
a648 8
	LDC_GEN(va, asi, op, op ## a, type) : op ## a_nc(va, asi))
#else
#define LD_GENERIC(va, asi, op, type) (op ## a_nc(va, asi))
#endif

#define lduba(va, asi)	LD_GENERIC(va, asi, ldub, u_char)
#define lduha(va, asi)	LD_GENERIC(va, asi, lduh, u_short)
#define lduwa(va, asi)	LD_GENERIC(va, asi, lduw, u_int)
a650 3
#define ldua(va, asi)	LD_GENERIC(va, asi, ldu, u_int)
#define lda(va, asi)	LD_GENERIC(va, asi, ld, int)

a651 9
	extern __inline void o ## _nc(paddr_t, int, tp);		\
	extern __inline void						\
	o ## _nc(paddr_t va, int asi, tp val)				\
	{                                                               \
		__asm __volatile(					\
		    "wr %2, 0, %%asi;" #o " %0, [%1] %%asi"		\
		    :							\
		    : "r" (val), "r" ((volatile tp *)va), "r" (asi));	\
	}								\
d655 1
a655 1
	{                                                               \
d659 9
a667 1
		    : "r" (val), "r" ((volatile tp *)va) );		\
d670 3
a672 3
STNC_GEN(u_char, stba);
STNC_GEN(u_short, stha);
STNC_GEN(u_int, stwa);
a680 2
		/*__asm __volatile(#op " %0, [%1] " 			\
		    : : "r" (val), "r" ((volatile type *)va));*/	\
d683 2
a684 1
		    : : "r" (val), "r" ((volatile type *)va));		\
d689 5
a693 4
	STC_GEN(va, asi, val, op, op ## a, type) : op ## a_nc(va, asi, val))
#else
#define ST_GENERIC(va, asi, val, op, type) (op ## a_nc(va, asi, val))
#endif
a699 27
#define sta(va, asi, val)	ST_GENERIC(va, asi, val, st, u_int)

#define membar(mask) do {                                               \
	__asm __volatile("membar %0" : : "n" (mask) : "memory");        \
} while (0)

#define rd(name) ({                                                     \
	u_int64_t __sr;                                                 \
	__asm __volatile("rd %%" #name ", %0" : "=r" (__sr) :);         \
	__sr;                                                           \
})

#define wr(name, val, xor) do {                                         \
	__asm __volatile("wr %0, %1, %%" #name                          \
	    : : "r" (val), "rI" (xor));                                 \
} while (0)

#define rdpr(name) ({                                                   \
	u_int64_t __pr;                                                 \
	__asm __volatile("rdpr %%" #name", %0" : "=r" (__pr) :);        \
	__pr;                                                           \
})

#define wrpr(name, val, xor) do {                                       \
	__asm __volatile("wrpr %0, %1, %%" #name                        \
	    : : "r" (val), "rI" (xor));                                 \
} while (0)
d705 1
a705 1
	wr(asi, asi, 0);
d712 1
a712 1
	return rd(asi);
d715 4
a718 3

static __inline u_long
intr_disable(void)
d720 3
a722 5
	u_long s;

	s = rdpr(pstate);
	wrpr(pstate, s & ~PSTATE_IE, 0);
	return (s);
a723 60
#define intr_restore(s) wrpr(pstate, (s), 0)

/*
 * In some places, it is required that the store is directly followed by a
 * membar #Sync. Don't trust the compiler to not insert instructions in
 * between. We also need to disable interrupts completely.
 */
#define stxa_sync(va, asi, val) do {					\
	u_long stxa_sync_s;						\
	stxa_sync_s = intr_disable();					\
	if(PHYS_ASI(asi)) {						\
		__asm __volatile(					\
		    "stxa %g0, [%0] #ASI_DCACHE_TAG; membar #Sync"	\
		    : : "r" (va & ~0x1f));				\
	}								\
	__asm __volatile("stxa %0, [%1] %2; membar #Sync"		\
	    : : "r" (val), "r" (va), "n" (asi));			\
	if(PHYS_ASI(asi)) {						\
		__asm __volatile(					\
		    "stxa %g0, [%0] #ASI_DCACHE_TAG; membar #Sync"	\
		    : : "r" (va & ~0x1f));				\
	}								\
	intr_restore(stxa_sync_s);					\
} while (0)

/* flush address from data cache */
#define	flush(loc) ({ \
	__asm __volatile("flush %0" : : \
	     "r" ((unsigned long)(loc))); \
})

/* The following two enable or disable the dcache in the LSU control register */
#define	dcenable() ({ \
	int res; \
	__asm __volatile("ldxa [%%g0] %1,%0; or %0,%2,%0; stxa %0,[%%g0] %1; membar #Sync" \
		: "r" (res) : "n" (ASI_MCCR), "n" (MCCR_DCACHE_EN)); \
})
#define	dcdisable() ({ \
	int res; \
	__asm __volatile("ldxa [%%g0] %1,%0; andn %0,%2,%0; stxa %0,[%%g0] %1; membar #Sync" \
		: "r" (res) : "n" (ASI_MCCR), "n" (MCCR_DCACHE_EN)); \
})

/*
 * SPARC V9 memory barrier instructions.
 */
/* Make all stores complete before next store */
#define	membar_storestore() membar(StoreStore)
/* Make all loads complete before next store */ 
#define	membar_loadstore() membar(LoadStore)
/* Make all stores complete before next load */ 
#define	membar_storeload() membar(StoreLoad)
/* Make all loads complete before next load */
#define	membar_loadload() membar(LoadLoad)
/* Complete all outstanding memory operations and exceptions */
#define	membar_sync() membar(Sync)
/* Complete all outstanding memory operations */
#define	membar_memissue() membar(MemIssue)
/* Complete all outstanding stores before any new loads */
#define	membar_lookaside() membar(Lookaside)
d726 1
a726 5
#define	tick() ({ \
	register u_long _tick_tmp; \
	__asm __volatile("rdpr %%tick, %0" : "=r" (_tick_tmp) :); \
	_tick_tmp; \
})
d729 3
a731 1
#endif
@


1.7
log
@Decruftification.

We will never have a.out kernels.
We will never have 32-bit kernels.
We will never have sun4c, sun4 and sun4m support in the sparc64 kernels.
We don't need support old netbsd libc.
The cpu will never be identified as some of the sun4c and sun4m types.
We don't need the gazillion of fields in cpuinfo that the sparc port uses.
Just generally remove dead code.

This is just a first step in making this meess readable.
@
text
@d1 1
a1 1
/*	$OpenBSD: ctlreg.h,v 1.6 2002/06/09 23:04:38 mdw Exp $	*/
d26 26
d59 42
d250 1
a250 1
#define	PHYS_ASI(x)	(((x) | 0x08) == 0x1c)
d524 51
a574 18
static __inline__ u_char lduba(paddr_t loc, int asi);
static __inline__ u_short lduha(paddr_t loc, int asi);
static __inline__ u_int lda(paddr_t loc, int asi);
static __inline__ int ldswa(paddr_t loc, int asi);
static __inline__ u_int64_t ldxa(paddr_t loc, int asi);
static __inline__ u_int64_t ldda(paddr_t loc, int asi);

static __inline__ void stba(paddr_t loc, int asi, u_char value);
static __inline__ void stha(paddr_t loc, int asi, u_short value);
static __inline__ void sta(paddr_t loc, int asi, u_int value);
static __inline__ void stxa(paddr_t loc, int asi, u_int64_t value);
static __inline__ void stda(paddr_t loc, int asi, u_int64_t value);

#if 0
static __inline__ unsigned int casa(paddr_t loc, int asi, 
	unsigned int value, unsigned int oldvalue);
static __inline__ u_int64_t casxa(paddr_t loc, int asi, 
	u_int64_t value, u_int64_t oldvalue);
d577 52
a628 4
static __inline__ u_char 
lduba(paddr_t loc, int asi) 
{
	register unsigned int _lduba_v;
d630 16
a645 16
	if (PHYS_ASI(asi)) {
		__asm __volatile("wr %3,%%g0,%%asi; "
" andn %2,0x1f,%0; stxa %%g0,[%0] %4; membar #Sync; "
" lduba [%2]%%asi,%0; andn %2,0x1f,%1; membar #Sync; "
" stxa %%g0,[%1] %4; membar #Sync; wr %%g0, 0x82, %%asi" :
				 "=&r" (_lduba_v), "=r" (loc):
				 "r" ((unsigned long)(loc)), 
				 "r" (asi), "n" (ASI_DCACHE_TAG));
	} else {
		__asm __volatile("wr %2,%%g0,%%asi; "
" lduba [%1]%%asi,%0; wr %%g0, 0x82, %%asi" :
				 "=r" (_lduba_v) :
				 "r" ((unsigned long)(loc)), "r" (asi));
	}
	return (_lduba_v);
}
d647 10
a656 5
/* load half-word from alternate address space */
static __inline__ u_short 
lduha(paddr_t loc, int asi) 
{
	register unsigned int _lduha_v;
d658 4
a661 16
	if (PHYS_ASI(asi)) {
		__asm __volatile("wr %3,%%g0,%%asi; "
" andn %2,0x1f,%0; stxa %%g0,[%0] %4; membar #Sync; "
" lduha [%2]%%asi,%0; andn %2,0x1f,%1; membar #Sync; "
" stxa %%g0,[%1] %4; membar #Sync; "
" wr %%g0, 0x82, %%asi" : "=&r" (_lduha_v), "=r" (loc) :
				 "r" ((unsigned long)(loc)), 
				 "r" (asi), "n" (ASI_DCACHE_TAG));
	} else {
		__asm __volatile("wr %2,%%g0,%%asi; lduha [%1]%%asi,%0; "
" wr %%g0, 0x82, %%asi" : 
				 "=r" (_lduha_v) :
				 "r" ((unsigned long)(loc)), "r" (asi));
	}
	return (_lduha_v);
}
d663 3
a665 3
/* load unsigned int from alternate address space */
static __inline__ u_int 
lda(paddr_t loc, int asi)
d667 1
a667 16
	register unsigned int _lda_v;

	if (PHYS_ASI(asi)) {
		__asm __volatile("wr %3,%%g0,%%asi; "
" andn %2,0x1f,%0; stxa %%g0,[%0] %4; membar #Sync; "
" lda [%2]%%asi,%0; andn %2,0x1f,%1; membar #Sync; "
" stxa %%g0,[%1] %4; membar #Sync; "
" wr %%g0, 0x82, %%asi" : "=&r" (_lda_v), "=r" (loc) :
				 "r" ((unsigned long)(loc)), 
				 "r" (asi), "n" (ASI_DCACHE_TAG));
	} else {
		__asm __volatile("wr %2,%%g0,%%asi; lda [%1]%%asi,%0" : 
				 "=r" (_lda_v) :
				 "r" ((unsigned long)(loc)), "r" (asi));
	}
	return (_lda_v);
d670 3
a672 3
/* load signed int from alternate address space */
static __inline__ int 
ldswa(paddr_t loc, int asi)
d674 1
a674 17
	register int _lda_v;

	if (PHYS_ASI(asi)) {
		__asm __volatile("wr %3,%%g0,%%asi; "
" andn %2,0x1f,%0; stxa %%g0,[%0] %4; membar #Sync; "
" ldswa [%2]%%asi,%0; andn %2,0x1f,%1; membar #Sync; "
" stxa %%g0,[%1] %4; membar #Sync; "
" wr %%g0, 0x82, %%asi" : "=&r" (_lda_v), "=r" (loc) :
				 "r" ((unsigned long)(loc)), 
				 "r" (asi), "n" (ASI_DCACHE_TAG));
	} else {
		__asm __volatile("wr %2,%%g0,%%asi; "
" ldswa [%1]%%asi,%0; wr %%g0, 0x82, %%asi" : 
				 "=r" (_lda_v) :
				 "r" ((unsigned long)(loc)), "r" (asi));
	}
	return (_lda_v);
a676 5
/* load 64-bit int from alternate address space -- these should never be used */
static __inline__ u_int64_t
ldda(paddr_t loc, int asi)
{
	register long long _lda_v;
d678 2
a679 20
	if (PHYS_ASI(asi)) {
		__asm __volatile("wr %3,%%g0,%%asi; "
" andn %2,0x1f,%0; stxa %%g0,[%0] %4; membar #Sync; "
" ldda [%2]%%asi,%0; andn %2,0x1f,%1; membar #Sync; "
" stxa %%g0,[%1] %4; membar #Sync; "
" wr %%g0, 0x82, %%asi" : "=&r" (_lda_v), "=&r" (loc) :
				 "r" ((unsigned long)(loc)), 
				 "r" (asi), "n" (ASI_DCACHE_TAG));
	} else {
		__asm __volatile("wr %2,%%g0,%%asi; "
" ldda [%1]%%asi,%0; wr %%g0, 0x82, %%asi" : 
				 "=r" (_lda_v) :
				 "r" ((unsigned long)(loc)), "r" (asi));
	}
	return (_lda_v);
}

/* native load 64-bit int from alternate address space w/64-bit compiler*/
static __inline__ u_int64_t
ldxa(paddr_t loc, int asi)
d681 1
a681 1
	register unsigned long _lda_v;
d683 3
a685 15
	if (PHYS_ASI(asi)) {
		__asm __volatile("wr %3,%%g0,%%asi; "
" andn %2,0x1f,%0; stxa %%g0,[%0] %4; membar #Sync; "
" ldxa [%2]%%asi,%0; andn %2,0x1f,%1; membar #Sync; "
" stxa %%g0,[%1] %4; membar #Sync; "
" wr %%g0, 0x82, %%asi" : "=&r" (_lda_v), "=r" (loc) :
				 "r" ((unsigned long)(loc)), 
				 "r" (asi), "n" (ASI_DCACHE_TAG));
	} else {
		__asm __volatile("wr %2,%%g0,%%asi; "
" ldxa [%1]%%asi,%0; wr %%g0, 0x82, %%asi" : 
				 "=r" (_lda_v) :
				 "r" ((unsigned long)(loc)), "r" (asi));
	}
	return (_lda_v);
d687 1
d689 22
a710 95
/* store byte to alternate address space */
static __inline__ void 
stba(paddr_t loc, int asi, u_char value)
{
	if (PHYS_ASI(asi)) {
		__asm __volatile("wr %3,%%g0,%%asi; stba %1,[%2]%%asi;"
" andn %2,0x1f,%0; membar #Sync; stxa %%g0,[%0] %4; membar #Sync; "
" wr %%g0, 0x82, %%asi" : 
			"=&r" (loc) :
			"r" ((int)(value)), "r" ((unsigned long)(loc)),
			"r" (asi), "n" (ASI_DCACHE_TAG));
	} else {
		__asm __volatile("wr %2,%%g0,%%asi; stba %0,[%1]%%asi; "
" wr %%g0, 0x82, %%asi" : :
			"r" ((int)(value)), "r" ((unsigned long)(loc)),
			"r" (asi));
	}
}

/* store half-word to alternate address space */
static __inline__ void
stha(paddr_t loc, int asi, u_short value)
{
	if (PHYS_ASI(asi)) {
		__asm __volatile("wr %3,%%g0,%%asi; stha %1,[%2]%%asi;"
" andn %2,0x1f,%0; membar #Sync; stxa %%g0,[%0] %4; membar #Sync; "
" wr %%g0, 0x82, %%asi" : 
			"=&r" (loc) :
			"r" ((int)(value)), "r" ((unsigned long)(loc)),
			"r" (asi), "n" (ASI_DCACHE_TAG) : "memory");
	} else {
		__asm __volatile("wr %2,%%g0,%%asi; stha %0,[%1]%%asi; "
" wr %%g0, 0x82, %%asi" : :
			"r" ((int)(value)), "r" ((unsigned long)(loc)),
			"r" (asi) : "memory");
	}
}

/* store int to alternate address space */
static __inline__ void
sta(paddr_t loc, int asi, u_int value)
{
	if (PHYS_ASI(asi)) {
		__asm __volatile("wr %3,%%g0,%%asi; sta %1,[%2]%%asi;"
" andn %2,0x1f,%0; membar #Sync; stxa %%g0,[%0] %4; membar #Sync; "
" wr %%g0, 0x82, %%asi" : 
			"=&r" (loc) :
			"r" ((int)(value)), "r" ((unsigned long)(loc)),
			"r" (asi), "n" (ASI_DCACHE_TAG) : "memory");
	} else {
		__asm __volatile("wr %2,%%g0,%%asi; sta %0,[%1]%%asi; "
" wr %%g0, 0x82, %%asi" : :
			"r" ((int)(value)), "r" ((unsigned long)(loc)),
			"r" (asi) : "memory");
	}
}

/* store 64-bit int to alternate address space */
static __inline__ void
stda(paddr_t loc, int asi, u_int64_t value)
{
	if (PHYS_ASI(asi)) {
		__asm __volatile("wr %3,%%g0,%%asi; stda %1,[%2]%%asi;"
" andn %2,0x1f,%0; membar #Sync; stxa %%g0,[%0] %4; membar #Sync; "
" wr %%g0, 0x82, %%asi" :
			"=&r" (loc) :
			"r" ((long long)(value)), "r" ((unsigned long)(loc)),
			"r" (asi), "n" (ASI_DCACHE_TAG) : "memory");
	} else {
		__asm __volatile("wr %2,%%g0,%%asi; stda %0,[%1]%%asi; "
" wr %%g0, 0x82, %%asi" : :
			"r" ((long long)(value)), "r" ((unsigned long)(loc)),
			"r" (asi) : "memory");
	}
}

/* native store 64-bit int to alternate address space w/64-bit compiler*/
static __inline__ void
stxa(paddr_t loc, int asi, u_int64_t value)
{
	if (PHYS_ASI(asi)) {
		__asm __volatile("wr %3,%%g0,%%asi; stxa %1,[%2]%%asi;"
" andn %2,0x1f,%0; membar #Sync; stxa %%g0,[%0] %4; membar #Sync; "
" wr %%g0, 0x82, %%asi" : 
			"=&r" (asi) :
			"r" ((unsigned long)(value)),
			"r" ((unsigned long)(loc)),
			"r" (asi), "n" (ASI_DCACHE_TAG) : "memory");
	} else {
		__asm __volatile("wr %2,%%g0,%%asi; stxa %0,[%1]%%asi; "
" wr %%g0, 0x82, %%asi" : :
			"r" ((unsigned long)(value)),
			"r" ((unsigned long)(loc)), "r" (asi) : "memory");
	}
}
a717 10
/* Flush a D$ line */
#if 0
#define	flushline(loc) ({ \
	stxa(((paddr_t)loc)&(~0x1f), (ASI_DCACHE_TAG), 0); \
        membar_sync(); \
})
#else
#define	flushline(loc)
#endif

d734 1
a734 1
#define	membar_storestore() __asm __volatile("membar #StoreStore" : :)
d736 1
a736 1
#define	membar_loadstore() __asm __volatile("membar #LoadStore" : :)
d738 1
a738 1
#define	membar_storeload() __asm __volatile("membar #StoreLoad" : :)
d740 1
a740 1
#define	membar_loadload() __asm __volatile("membar #LoadLoad" : :)
d742 1
a742 1
#define	membar_sync() __asm __volatile("membar #Sync" : :)
d744 1
a744 1
#define	membar_memissue() __asm __volatile("membar #MemIssue" : :)
d746 1
a746 1
#define	membar_lookaside() __asm __volatile("membar #Lookaside" : :)
@


1.6
log
@Added registers in cheetah
@
text
@d1 1
a1 1
/*	$OpenBSD: ctlreg.h,v 1.5 2002/04/02 15:14:23 jason Exp $	*/
a475 1
#ifdef __arch64__
a496 26
#else
static __inline__ u_char 
lduba(paddr_t loc, int asi) 
{
	register unsigned int _lduba_v, _loc_hi, _pstate;

	_loc_hi = (((u_int64_t)loc)>>32);
	if (PHYS_ASI(asi)) {
		__asm __volatile("wr %4,%%g0,%%asi; "
" andn %2,0x1f,%0; stxa %%g0,[%0] %5; rdpr %%pstate,%1; "
" sllx %3,32,%0; or %0,%2,%0; wrpr %1,8,%%pstate; "
" membar #Sync; lduba [%0]%%asi,%0; wrpr %1,0,%%pstate; "
" andn %2,0x1f,%1; membar #Sync; stxa %%g0,[%1] %5; "
" membar #Sync; wr %%g0, 0x82, %%asi" :
				 "=&r" (_lduba_v),  "=&r" (_pstate) :
				 "r" ((unsigned long)(loc)), "r" (_loc_hi),
				 "r" (asi), "n" (ASI_DCACHE_TAG));
	} else {
		__asm __volatile("wr %3,%%g0,%%asi; sllx %2,32,%0; "
" or %0,%1,%0; lduba [%0]%%asi,%0; wr %%g0, 0x82, %%asi" : "=&r" (_lduba_v) :
				 "r" ((unsigned long)(loc)), 
				 "r" (_loc_hi), "r" (asi));
	}
	return (_lduba_v);
}
#endif
a497 1
#ifdef __arch64__
a519 7
#else
/* load half-word from alternate address space */
static __inline__ u_short 
lduha(paddr_t loc, int asi) {
	register unsigned int _lduha_v, _loc_hi, _pstate;

	_loc_hi = (((u_int64_t)loc)>>32);
a520 20
	if (PHYS_ASI(asi)) {
		__asm __volatile("wr %4,%%g0,%%asi; rdpr %%pstate,%1; "
" andn %2,0x1f,%0; stxa %%g0,[%0] %5; wrpr %1,8,%%pstate; sllx %3,32,%0; "
" or %0,%2,%0; membar #Sync; lduha [%0]%%asi,%0; wrpr %1,0,%%pstate; "
" andn %2,0x1f,%1; membar #Sync; stxa %%g0,[%1] %5; "
" membar #Sync; wr %%g0, 0x82, %%asi" :
				 "=&r" (_lduha_v), "=&r" (_pstate) :
				 "r" ((unsigned long)(loc)), "r" (_loc_hi),
				 "r" (asi), "n" (ASI_DCACHE_TAG));
	} else {
		__asm __volatile("wr %3,%%g0,%%asi; sllx %2,32,%0; "
" or %0,%1,%0; lduha [%0]%%asi,%0; wr %%g0, 0x82, %%asi" : "=&r" (_lduha_v) :
				 "r" ((unsigned long)(loc)), "r" (_loc_hi), "r" (asi));
	}
	return (_lduha_v);
}
#endif


#ifdef __arch64__
a564 51
#else	/* __arch64__ */
/* load unsigned int from alternate address space */
static __inline__ u_int 
lda(paddr_t loc, int asi)
{
	register unsigned int _lda_v, _loc_hi, _pstate;

	_loc_hi = (((u_int64_t)loc)>>32);
	if (PHYS_ASI(asi)) {
		__asm __volatile("wr %4,%%g0,%%asi; rdpr %%pstate,%1;"
" andn %2,0x1f,%0; stxa %%g0,[%0] %5; wrpr %1,8,%%pstate; "
" sllx %3,32,%0; or %0,%2,%0; membar #Sync;lda [%0]%%asi,%0; "
" wrpr %1,0,%%pstate; andn %2,0x1f,%1; membar #Sync; "
" stxa %%g0,[%1] %5; membar #Sync; "
" wr %%g0, 0x82, %%asi" : "=&r" (_lda_v), "=&r" (_pstate) :
				 "r" ((unsigned long)(loc)), "r" (_loc_hi),
				 "r" (asi), "n" (ASI_DCACHE_TAG));
	} else {
		__asm __volatile("wr %3,%%g0,%%asi; sllx %2,32,%0; "
" or %0,%1,%0; lda [%0]%%asi,%0; wr %%g0, 0x82, %%asi" : "=&r" (_lda_v) :
				 "r" ((unsigned long)(loc)), 
				 "r" (_loc_hi), "r" (asi));
	}
	return (_lda_v);
}

/* load signed int from alternate address space */
static __inline__ int
ldswa(paddr_t loc, int asi)
{
	register int _lda_v, _loc_hi, _pstate;

	_loc_hi = (((u_int64_t)loc)>>32);
	if (PHYS_ASI(asi)) {
		__asm __volatile("wr %4,%%g0,%%asi; rdpr %%pstate,%1;"
" andn %2,0x1f,%0; stxa %%g0,[%0] %5; wrpr %1,8,%%pstate; sllx %3,32,%0;"
" or %0,%2,%0; membar #Sync; ldswa [%0]%%asi,%0; wrpr %1,0,%%pstate; "
" andn %2,0x1f,%1; membar #Sync; stxa %%g0,[%1] %5; membar #Sync; "
" wr %%g0, 0x82, %%asi" :
				 "=&r" (_lda_v), "=&r" (_pstate) :
				 "r" ((unsigned long)(loc)), "r" (_loc_hi),
				 "r" (asi), "n" (ASI_DCACHE_TAG));
	} else {
		__asm __volatile("wr %3,%%g0,%%asi; sllx %2,32,%0; "
" or %0,%1,%0; ldswa [%0]%%asi,%0; wr %%g0, 0x82, %%asi" : "=&r" (_lda_v) :
				 "r" ((unsigned long)(loc)), 
				 "r" (_loc_hi), "r" (asi));
	}
	return (_lda_v);
}
#endif /* __arch64__ */
a565 1
#ifdef	__arch64__
a587 26
#else
/* load 64-bit int from alternate address space */
static __inline__ u_int64_t
ldda(paddr_t loc, int asi)
{
	register long long _lda_v, _loc_hi, _pstate;

	_loc_hi = (((u_int64_t)loc)>>32);
	if (PHYS_ASI(asi)) {
		__asm __volatile("wr %4,%%g0,%%asi; rdpr %%pstate,%1;"
" andn %2,0x1f,%0; rdpr %%pstate,%1; stxa %%g0,[%0] %5; wrpr %1,8,%%pstate;"
" sllx %3,32,%0; or %0,%2,%0; membar #Sync; ldda [%0]%%asi,%0; wrpr %1,0,%%pstate; "
" andn %2,0x1f,%1; membar #Sync; stxa %%g0,[%1] %5; membar #Sync; "
" wr %%g0, 0x82, %%asi" :
				 "=&r" (_lda_v), "=&r" (_pstate) :
				 "r" ((unsigned long)(loc)), "r" (_loc_hi), 
				 "r" (asi), "n" (ASI_DCACHE_TAG));
	} else {
		__asm __volatile("wr %3,%%g0,%%asi; sllx %2,32,%0; "
" or %0,%1,%0; ldda [%0]%%asi,%0; wr %%g0, 0x82, %%asi" : "=&r" (_lda_v) :
				 "r" ((unsigned long)(loc)), "r" (_loc_hi), "r" (asi));
	}
	return (_lda_v);
}
#endif

a588 1
#ifdef __arch64__
a610 28
#else
/* native load 64-bit int from alternate address space w/32-bit compiler*/
static __inline__ u_int64_t
ldxa(paddr_t loc, int asi)
{
	register unsigned long _ldxa_lo, _ldxa_hi, _loc_hi;

	_loc_hi = (((u_int64_t)loc)>>32);
	if (PHYS_ASI(asi)) {
		__asm __volatile("wr %4,%%g0,%%asi; "
" andn %2,0x1f,%0; rdpr %%pstate,%1; stxa %%g0,[%0] %5; "
" sllx %3,32,%0; wrpr %1,8,%%pstate; or %0,%2,%0; membar #Sync; ldxa [%0]%%asi,%0; "
" wrpr %1,0,%%pstate; andn %2,0x1f,%1; membar #Sync; stxa %%g0,[%1] %5; membar #Sync; "
" srlx %0,32,%1; srl %0,0,%0; wr %%g0, 0x82, %%asi" :
				 "=&r" (_ldxa_lo), "=&r" (_ldxa_hi) :
				 "r" ((unsigned long)(loc)), "r" (_loc_hi),
				 "r" (asi), "n" (ASI_DCACHE_TAG));
	} else {
		__asm __volatile("wr %4,%%g0,%%asi; sllx %3,32,%0; "
" or %0,%2,%0; ldxa [%0]%%asi,%0; srlx %0,32,%1; "
" srl %0,0,%0;; wr %%g0, 0x82, %%asi" :
				 "=&r" (_ldxa_lo), "=&r" (_ldxa_hi) :
				 "r" ((unsigned long)(loc)), "r" (_loc_hi),
				 "r" (asi));
	}
	return ((((int64_t)_ldxa_hi)<<32)|_ldxa_lo);
}
#endif
a612 1
#ifdef __arch64__
a629 23
#else
static __inline__ void 
stba(paddr_t loc, int asi, u_char value)
{
	register int _loc_hi, _pstate;

	_loc_hi = (((u_int64_t)loc)>>32);
	if (PHYS_ASI(asi)) {
		__asm __volatile("wr %5,%%g0,%%asi; sllx %4,32,%0; rdpr %%pstate,%1;"
" or %3,%0,%0; wrpr %1,8,%%pstate; stba %2,[%0]%%asi; wrpr %1,0,%%pstate; "
" andn %0,0x1f,%1;  membar #Sync; stxa %%g0,[%1] %6; membar #Sync; "
" wr %%g0, 0x82, %%asi" :
				 "=&r" (_loc_hi), "=&r" (_pstate) :
				 "r" ((int)(value)), "r" ((unsigned long)(loc)),
				 "r" (_loc_hi), "r" (asi), "n" (ASI_DCACHE_TAG));
	} else {
		__asm __volatile("wr %4,%%g0,%%asi; sllx %3,32,%0; "
" or %2,%0,%0; stba %1,[%0]%%asi; wr %%g0, 0x82, %%asi" : "=&r" (_loc_hi) :
				 "r" ((int)(value)), "r" ((unsigned long)(loc)),
				 "r" (_loc_hi), "r" (asi));
	}
}
#endif
a631 1
#ifdef __arch64__
a648 25
#else
static __inline__ void
stha(paddr_t loc, int asi, u_short value)
{
	register int _loc_hi, _pstate;

	_loc_hi = (((u_int64_t)loc)>>32);
	if (PHYS_ASI(asi)) {
		__asm __volatile("wr %5,%%g0,%%asi; sllx %4,32,%0; rdpr %%pstate,%1;"
" or %3,%0,%0; wrpr %1,8,%%pstate; stha %2,[%0]%%asi; wrpr %1,0,%%pstate; "
" andn %0,0x1f,%1;  membar #Sync; stxa %%g0,[%1] %6; membar #Sync; "
" wr %%g0, 0x82, %%asi" :
			"=&r" (_loc_hi), "=&r" (_pstate) :
			"r" ((int)(value)), "r" ((unsigned long)(loc)),
			"r" (_loc_hi), "r" (asi),
			"n" (ASI_DCACHE_TAG) : "memory");
	} else {
		__asm __volatile("wr %4,%%g0,%%asi; sllx %3,32,%0; "
" or %2,%0,%0; stha %1,[%0]%%asi; wr %%g0, 0x82, %%asi" : "=&r" (_loc_hi) :
				 "r" ((int)(value)), "r" ((unsigned long)(loc)),
				 "r" (_loc_hi), "r" (asi) : "memory");
	}
}
#endif

a650 1
#ifdef __arch64__
a667 24
#else
static __inline__ void
sta(paddr_t loc, int asi, u_int value)
{
	register int _loc_hi, _pstate;

	_loc_hi = (((u_int64_t)loc)>>32);
	if (PHYS_ASI(asi)) {
		__asm __volatile("wr %5,%%g0,%%asi; sllx %4,32,%0; rdpr %%pstate,%1;"
" or %3,%0,%0; wrpr %1,8,%%pstate; sta %2,[%0]%%asi; wrpr %1,0,%%pstate; "
" andn %0,0x1f,%1;  membar #Sync; stxa %%g0,[%1] %6; membar #Sync; "
" wr %%g0, 0x82, %%asi" :
			"=&r" (_loc_hi), "=&r" (_pstate) :
			"r" ((int)(value)), "r" ((unsigned long)(loc)),
			"r" (_loc_hi), "r" (asi),
			"n" (ASI_DCACHE_TAG) : "memory");
	} else {
		__asm __volatile("wr %4,%%g0,%%asi; sllx %3,32,%0; "
" or %2,%0,%0; sta %1,[%0]%%asi; wr %%g0, 0x82, %%asi" : "=&r" (_loc_hi) :
				 "r" ((int)(value)), "r" ((unsigned long)(loc)),
				 "r" (_loc_hi), "r" (asi) : "memory");
	}
}
#endif
a669 1
#ifdef __arch64__
a686 5
#else
static __inline__ void
stda(paddr_t loc, int asi, u_int64_t value)
{
	register int _loc_hi, _pstate;
a687 21
	_loc_hi = (((u_int64_t)loc)>>32);
	if (PHYS_ASI(asi)) {
		__asm __volatile("wr %5,%%g0,%%asi; sllx %4,32,%0; rdpr %%pstate,%1; "
" or %3,%0,%0; wrpr %1,8,%%pstate; stda %2,[%0]%%asi; wrpr %1,0,%%pstate;"
" andn %0,0x1f,%1;  membar #Sync; stxa %%g0,[%1] %6; membar #Sync; "
" wr %%g0, 0x82, %%asi" :
			"=&r" (_loc_hi), "=&r" (_pstate) :
			"r" ((long long)(value)), "r" ((unsigned long)(loc)),
			"r" (_loc_hi), "r" (asi),
			"n" (ASI_DCACHE_TAG) : "memory");
	} else {
		__asm __volatile("wr %4,%%g0,%%asi; sllx %3,32,%0; "
" or %2,%0,%0; stda %1,[%0]%%asi; wr %%g0, 0x82, %%asi" :
			"=&r" (_loc_hi) :
			"r" ((long long)(value)), "r" ((unsigned long)(loc)),
			"r" (_loc_hi), "r" (asi) : "memory");
	}
}
#endif

#ifdef __arch64__
a706 98
#else
/* native store 64-bit int to alternate address space w/32-bit compiler*/
static __inline__ void
stxa(paddr_t loc, int asi, u_int64_t value)
{
	int _stxa_lo, _stxa_hi, _loc_hi;

	_stxa_lo = value; 
	_stxa_hi = ((u_int64_t)value)>>32;
	_loc_hi = (((u_int64_t)(u_long)loc)>>32);

	if (PHYS_ASI(asi)) {
		__asm __volatile("wr %7,%%g0,%%asi; sllx %4,32,%1; sllx %6,32,%0; "
" or %1,%3,%1; rdpr %%pstate,%2; or %0,%5,%0; wrpr %2,8,%%pstate; "
" stxa %1,[%0]%%asi; wrpr %2,0,%%pstate; andn %0,0x1f,%1; "
" membar #Sync; stxa %%g0,[%1] %8; membar #Sync; wr %%g0, 0x82, %%asi" :
				 "=&r" (_loc_hi), "=&r" (_stxa_hi), 
				 "=&r" ((int)(_stxa_lo)) :
				 "r" ((int)(_stxa_lo)), "r" ((int)(_stxa_hi)),
				 "r" ((unsigned long)(loc)), "r" (_loc_hi),
				 "r" (asi), "n" (ASI_DCACHE_TAG) : "memory");
	} else {
		__asm __volatile("wr %6,%%g0,%%asi; sllx %3,32,%1; sllx %5,32,%0; "
" or %1,%2,%1; or %0,%4,%0; stxa %1,[%0]%%asi; wr %%g0, 0x82, %%asi" :
				 "=&r" (_loc_hi), "=&r" (_stxa_hi) :
				 "r" ((int)(_stxa_lo)), "r" ((int)(_stxa_hi)),
				 "r" ((unsigned long)(loc)), "r" (_loc_hi),
				 "r" (asi) : "memory");
	}
}
#endif

#if 0
#ifdef __arch64__
/* native store 64-bit int to alternate address space w/64-bit compiler*/
static __inline__ u_int64_t
casxa(paddr_t loc, int asi, u_int64_t value, u_int64_t oldvalue)
{
	if (PHYS_ASI(asi)) {
		__asm __volatile("wr %4,%%g0,%%asi; casxa [%3]%%asi,%2,%1;"
" andn %3,0x1f,%0; membar #Sync; stxa %%g0,[%0] %5; membar #Sync; "
" wr %%g0, 0x82, %%asi" :
			"=&r" (loc), "+r" (value) :
			"r" ((unsigned long)(oldvalue)),
			"r" ((unsigned long)(loc)),
			"r" (asi), "n" (ASI_DCACHE_TAG) : "memory");
	} else {
		__asm __volatile("wr %3,%%g0,%%asi; casxa [%1]%%asi,%2,%0; "
" wr %%g0, 0x82, %%asi" :
			"+r" (value) :
			"r" ((unsigned long)(loc)), "r" (oldvalue), "r" (asi) :
			"memory");
	}
	return (value);
}
#else
/* native store 64-bit int to alternate address space w/32-bit compiler*/
static __inline__ u_int64_t
casxa(paddr_t loc, int asi, u_int64_t value, u_int64_t oldvalue)
{
	int _casxa_lo, _casxa_hi, _loc_hi, _oval_hi;

	_casxa_lo = value; 
	_casxa_hi = ((u_int64_t)value)>>32;
	_oval_hi = ((u_int64_t)oldvalue)>>32;
	_loc_hi = (((u_int64_t)(u_long)loc)>>32);

#ifdef __notyet
/*
 * gcc cannot handle this since it thinks it has >10 asm operands.
 */
	if (PHYS_ASI(asi)) {
		__asm __volatile("wr %6,%%g0,%%asi; sllx %1,32,%1; sllx %0,32,%0; "
" sllx %3,32,%3; or %1,%2,%1; rdpr %%pstate,%2; or %0,%4,%0; or %3,%5,%3; "
" wrpr %2,8,%%pstate; casxa [%0]%%asi,%3,%1; wrpr %2,0,%%pstate; " 
" andn %0,0x1f,%3;  membar #Sync; stxa %%g0,[%3] %7; membar #Sync; "
" sll %1,0,%2; srax %1,32,%1; wr %%g0, 0x82, %%asi " :
			"+r" (_loc_hi), "+r" (_casxa_hi),
			"+r" (_casxa_lo), "+r" (_oval_hi) :
			"r" ((unsigned long)(loc)),
			"r" ((unsigned int)(oldvalue)),
			"r" (asi), "n" (ASI_DCACHE_TAG));
	} else {
		__asm __volatile("wr %7,%%g0,%%asi; sllx %1,32,%1; sllx %5,32,%0; "
" or %1,%2,%1; sllx %3,32,%2; or %0,%4,%0; or %2,%4,%2; "
" casxa [%0]%%asi,%2,%1; sll %1,0,%2; srax %o1,32,%o1; wr %%g0, 0x82, %%asi " :
			"=&r" (_loc_hi), "+r" (_casxa_hi), "+r" (_casxa_lo) :
			"r" ((int)(_oval_hi)), "r" ((int)(oldvalue)),
			"r" ((unsigned long)(loc)), "r" (_loc_hi),
			"r" (asi) : "memory");
	}
#endif
	return (((u_int64_t)_casxa_hi<<32)|(u_int64_t)_casxa_lo);
}
#endif
#endif /* 0 */


a753 1
#ifdef __arch64__
a759 9
#else
/* read 64-bit %tick register on 32-bit system */
#define	tick() ({ \
	register u_int _tick_hi = 0, _tick_lo = 0; \
	__asm __volatile("rdpr %%tick, %0; srl %0,0,%1; srlx %0,32,%0 " \
		: "=r" (_tick_hi), "=r" (_tick_lo) : ); \
	(((u_int64_t)_tick_hi)<<32)|((u_int64_t)_tick_lo); \
})
#endif
@


1.5
log
@bit defns for %tick (basically the ticker bits and the npt bit)
@
text
@d1 1
a1 1
/*	$OpenBSD: ctlreg.h,v 1.4 2002/03/14 01:26:45 millert Exp $	*/
d237 1
d251 3
@


1.4
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: ctlreg.h,v 1.3 2001/09/20 21:08:50 jason Exp $	*/
d184 6
@


1.3
log
@correct %b strings
@
text
@d1 1
a1 1
/*	$OpenBSD: ctlreg.h,v 1.2 2001/08/20 20:23:52 jason Exp $	*/
d446 12
a457 12
static __inline__ u_char lduba __P((paddr_t loc, int asi));
static __inline__ u_short lduha __P((paddr_t loc, int asi));
static __inline__ u_int lda __P((paddr_t loc, int asi));
static __inline__ int ldswa __P((paddr_t loc, int asi));
static __inline__ u_int64_t ldxa __P((paddr_t loc, int asi));
static __inline__ u_int64_t ldda __P((paddr_t loc, int asi));

static __inline__ void stba __P((paddr_t loc, int asi, u_char value));
static __inline__ void stha __P((paddr_t loc, int asi, u_short value));
static __inline__ void sta __P((paddr_t loc, int asi, u_int value));
static __inline__ void stxa __P((paddr_t loc, int asi, u_int64_t value));
static __inline__ void stda __P((paddr_t loc, int asi, u_int64_t value));
d460 4
a463 4
static __inline__ unsigned int casa __P((paddr_t loc, int asi, 
	unsigned int value, unsigned int oldvalue));
static __inline__ u_int64_t casxa __P((paddr_t loc, int asi, 
	u_int64_t value, u_int64_t oldvalue));
d1123 1
a1123 1
extern void next_tick __P((long));
@


1.3.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ctlreg.h,v 1.3 2001/09/20 21:08:50 jason Exp $	*/
a184 6
/*
 * %tick: cpu cycle counter
 */
#define	TICK_NPT	0x8000000000000000	/* trap on non priv access */
#define	TICK_TICKS	0x7fffffffffffffff	/* counter bits */

d446 12
a457 12
static __inline__ u_char lduba(paddr_t loc, int asi);
static __inline__ u_short lduha(paddr_t loc, int asi);
static __inline__ u_int lda(paddr_t loc, int asi);
static __inline__ int ldswa(paddr_t loc, int asi);
static __inline__ u_int64_t ldxa(paddr_t loc, int asi);
static __inline__ u_int64_t ldda(paddr_t loc, int asi);

static __inline__ void stba(paddr_t loc, int asi, u_char value);
static __inline__ void stha(paddr_t loc, int asi, u_short value);
static __inline__ void sta(paddr_t loc, int asi, u_int value);
static __inline__ void stxa(paddr_t loc, int asi, u_int64_t value);
static __inline__ void stda(paddr_t loc, int asi, u_int64_t value);
d460 4
a463 4
static __inline__ unsigned int casa(paddr_t loc, int asi, 
	unsigned int value, unsigned int oldvalue);
static __inline__ u_int64_t casxa(paddr_t loc, int asi, 
	u_int64_t value, u_int64_t oldvalue);
d1123 1
a1123 1
extern void next_tick(long);
@


1.3.6.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ctlreg.h,v 1.3.6.1 2002/06/11 03:38:43 art Exp $	*/
a236 1
 * III = cheetah only
a249 3
#define TSB_PEXT		0x48	/* III primary ext */
#define TSB_SEXT		0x50	/* III 2ndary ext -- DMMU only */
#define TSB_NEXT		0x58	/* III nucleus ext */
d472 1
d494 26
d521 1
d544 7
d552 20
d616 51
d668 1
d691 26
d718 1
d741 28
d771 1
d789 23
d814 1
d832 25
d859 1
d877 24
d903 1
d921 5
d927 21
d967 98
d1112 1
d1119 9
@


1.3.6.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a25 28
/*
 * Copyright (c) 2001 Jake Burkholder.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#ifndef _SPARC64_CTLREG_
#define _SPARC64_CTLREG_
a32 18
 * membar operand macros for use in other macros when # is a special
 * character.  Keep these in sync with what the hardware expects.
 */
#define C_Lookaside     (0)
#define C_MemIssue      (1)
#define C_Sync          (2)
#define M_LoadLoad      (0)
#define M_StoreLoad     (1)
#define M_LoadStore     (2)
#define M_StoreStore    (3)

#define CMASK_SHIFT     (4)
#define MMASK_SHIFT     (0)

#define CMASK_GEN(bit)  ((1 << (bit)) << CMASK_SHIFT)
#define MMASK_GEN(bit)  ((1 << (bit)) << MMASK_SHIFT)

/*
d182 1
a182 1
#define	PHYS_ASI(x)	(((x) | 0x09) == 0x1d)
d456 278
a733 135
extern __inline u_int32_t sparc_cas(u_int32_t *, u_int32_t, u_int32_t);
extern __inline u_int32_t
sparc_cas(u_int32_t *rs1, u_int32_t rs2, u_int32_t rd)
{
	__asm __volatile("casa [%1] ASI_PRIMARY, %2, %0"
	    : "+r" (rd)
	    : "r" (rs1), "r" (rs2)
	    : "memory" );
	return (rd);
}

extern __inline u_int64_t sparc_casx(u_int64_t *, u_int64_t, u_int64_t);
extern __inline u_int64_t
sparc_casx(u_int64_t *rs1, u_int64_t rs2, u_int64_t rd)
{
	__asm __volatile("casxa [%1] ASI_PRIMARY, %3, %0"
	    : "+r" (rd)
	    : "r" (rs1), "r" (rs2)
	    : "memory" );
	return (rd);
}

#define sparc_membar(mask) do {                                         \
        if (mask)                                                       \
                __asm __volatile("membar %0" : : "n" (mask) : "memory");\
        else                                                            \
                __asm __volatile("" : : : "memory");                    \
} while(0)

#define membar sparc_membar
#define Lookaside       CMASK_GEN(C_Lookaside)
#define MemIssue        CMASK_GEN(C_MemIssue)
#define Sync            CMASK_GEN(C_Sync)
#define LoadLoad        MMASK_GEN(M_LoadLoad)
#define StoreLoad       MMASK_GEN(M_StoreLoad)
#define LoadStore       MMASK_GEN(M_LoadStore)
#define StoreStore      MMASK_GEN(M_StoreStore)

#define sparc_wr(name, val, xor)					\
do {									\
	if (__builtin_constant_p(xor))					\
		__asm __volatile("wr %%g0, %0, %%" #name		\
		    : : "rI" ((val) ^ (xor)) : "%g0");			\
	else								\
		__asm __volatile("wr %0, %1, %%" #name			\
		    : : "r" (val), "rI" (xor) : "%g0");			\
} while(0)

#define sparc_wrpr(name, val, xor)					\
do {									\
	if (__builtin_constant_p(xor))					\
		__asm __volatile("wrpr %%g0, %0, %%" #name		\
		    : : "rI" ((val) ^ (xor)) : "%g0");			\
	else								\
		__asm __volatile("wrpr %0, %1, %%" #name		\
		    : : "r" (val), "rI" (xor) : "%g0");			\
} while(0)


#define sparc_rd(name) sparc_rd_ ## name()
#define GEN_RD(name)							\
extern __inline u_int64_t sparc_rd_ ## name(void);			\
extern __inline u_int64_t						\
sparc_rd_ ## name()							\
{									\
	u_int64_t r;							\
	__asm __volatile("rd %%" #name ", %0" :				\
	    "=r" (r) : : "%g0");					\
	return (r);							\
}

#define sparc_rdpr(name) sparc_rdpr_ ## name()
#define GEN_RDPR(name)							\
extern __inline u_int64_t sparc_rdpr_ ## name(void);			\
extern __inline u_int64_t						\
sparc_rdpr_ ## name()							\
{									\
	u_int64_t r;							\
	__asm __volatile("rdpr %%" #name ", %0" :			\
	    "=r" (r) : : "%g0");					\
	return (r);							\
}

GEN_RD(asi);
GEN_RD(asr22);
GEN_RDPR(cwp);
GEN_RDPR(tick);
GEN_RDPR(pstate);
GEN_RDPR(pil);
GEN_RDPR(ver);
/*
 * Before adding GEN_RDPRs for other registers, see Errata 50 (E.g,. in
 * the US-IIi manual) regarding tstate, pc and npc reads.
 */

/* Generate ld*a/st*a functions for non-constant ASI's. */
#define LDNC_GEN(tp, o)							\
	extern __inline tp o ## _asi(paddr_t);				\
	extern __inline tp						\
	o ## _asi(paddr_t va)						\
	{								\
		tp r;							\
		__asm __volatile(					\
		    #o " [%1] %%asi, %0"				\
		    : "=r" (r)						\
		    : "r" ((volatile tp *)va)				\
		    : "%g0");						\
		return (r);						\
	}								\
	extern __inline tp o ## _nc(paddr_t, int);			\
	extern __inline tp						\
	o ## _nc(paddr_t va, int asi)					\
	{								\
		sparc_wr(asi, asi, 0);					\
		return (o ## _asi(va));					\
	}

LDNC_GEN(u_char, lduba);
LDNC_GEN(u_short, lduha);
LDNC_GEN(u_int, lduwa);
LDNC_GEN(u_int64_t, ldxa);

LDNC_GEN(int, lda);

#define LDC_GEN(va, asi, op, opa, type) ({				\
	type __r ## op ## type;						\
	if(asi == ASI_PRIMARY  || 					\
	    (sizeof(type) == 1 && asi == ASI_PRIMARY_LITTLE))		\
		__r ## op ## type = *((volatile type *)va);		\
	else								\
		__asm __volatile(#opa " [%1] " #asi ", %0"		\
		    : "=r" (__r ## op ## type)				\
		    : "r" ((volatile type *)va)				\
		    : "%g0");						\
	__r ## op ## type;						\
d736 17
a752 85
#ifdef __OPTIMIZE__
#define LD_GENERIC(va, asi, op, type) (__builtin_constant_p(asi) ?	\
	LDC_GEN((va), asi, op, op ## a, type) : op ## a_nc((va), asi))
#else /* __OPTIMIZE */
#define LD_GENERIC(va, asi, op, type) (op ## a_nc((va), asi))
#endif /* __OPTIMIZE__ */

#define lduba(va, asi)	LD_GENERIC(va, asi, ldub, u_int8_t)
#define lduha(va, asi)	LD_GENERIC(va, asi, lduh, u_int16_t)
#define lduwa(va, asi)	LD_GENERIC(va, asi, lduw, u_int32_t)
#define ldxa(va, asi)	LD_GENERIC(va, asi, ldx, u_int64_t)

#define STNC_GEN(tp, o)							\
	extern __inline void o ## _asi(paddr_t, tp);			\
	extern __inline void						\
	o ## _asi(paddr_t va, tp val)					\
	{								\
		__asm __volatile(					\
		    #o " %0, [%1] %%asi"				\
		    :							\
		    : "r" (val), "r" ((volatile tp *)va)		\
		    : "memory");					\
	}								\
	extern __inline void o ## _nc(paddr_t, int, tp);		\
	extern __inline void						\
	o ## _nc(paddr_t va, int asi, tp val)				\
	{								\
		sparc_wr(asi, asi, 0);					\
		o ## _asi(va, val);					\
	}

STNC_GEN(u_int8_t, stba);
STNC_GEN(u_int16_t, stha);
STNC_GEN(u_int32_t, stwa);
STNC_GEN(u_int64_t, stxa);

STNC_GEN(u_int, sta);

#define STC_GEN(va, asi, val, op, opa, type) ({				\
	if(asi == ASI_PRIMARY ||					\
	    (sizeof(type) == 1 && asi == ASI_PRIMARY_LITTLE))		\
		*((volatile type *)va) = val;				\
	else								\
		__asm __volatile(#opa " %0, [%1] " #asi			\
		    : : "r" (val), "r" ((volatile type *)va)		\
		    : "memory");					\
	})

#ifdef __OPTIMIZE__
#define ST_GENERIC(va, asi, val, op, type) (__builtin_constant_p(asi) ?	\
	STC_GEN((va), (asi), (val), op, op ## a, type) :		\
	op ## a_nc((va), asi, (val)))
#else /* __OPTIMIZE__ */
#define ST_GENERIC(va, asi, val, op, type) (op ## a_nc((va), asi, (val)))
#endif /* __OPTIMIZE__ */

#define stba(va, asi, val)	ST_GENERIC(va, asi, val, stb, u_int8_t)
#define stha(va, asi, val)	ST_GENERIC(va, asi, val, sth, u_int16_t)
#define stwa(va, asi, val)	ST_GENERIC(va, asi, val, stw, u_int32_t)
#define stxa(va, asi, val)	ST_GENERIC(va, asi, val, stx, u_int64_t)


extern __inline void asi_set(int);
extern __inline
void asi_set(int asi)
{
	sparc_wr(asi, asi, 0);
}

extern __inline u_int8_t asi_get(void);
extern __inline
u_int8_t asi_get()
{
	return sparc_rd(asi);
}

/* flush address from instruction cache */
extern __inline void flush(void *);
extern __inline
void flush(void *p)
{
	__asm __volatile("flush %0"
	    : : "r" (p)
	    : "memory");
}
d755 5
a759 1
#define tick() (sparc_rdpr(tick) & TICK_TICKS)
d762 1
a762 3

#endif /* _LOCORE */
#endif /* _SPARC64_CTLREG_ */
@


1.3.4.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.3.4.2
log
@Merge in -current from about a week ago
@
text
@d446 12
a457 12
static __inline__ u_char lduba(paddr_t loc, int asi);
static __inline__ u_short lduha(paddr_t loc, int asi);
static __inline__ u_int lda(paddr_t loc, int asi);
static __inline__ int ldswa(paddr_t loc, int asi);
static __inline__ u_int64_t ldxa(paddr_t loc, int asi);
static __inline__ u_int64_t ldda(paddr_t loc, int asi);

static __inline__ void stba(paddr_t loc, int asi, u_char value);
static __inline__ void stha(paddr_t loc, int asi, u_short value);
static __inline__ void sta(paddr_t loc, int asi, u_int value);
static __inline__ void stxa(paddr_t loc, int asi, u_int64_t value);
static __inline__ void stda(paddr_t loc, int asi, u_int64_t value);
d460 4
a463 4
static __inline__ unsigned int casa(paddr_t loc, int asi, 
	unsigned int value, unsigned int oldvalue);
static __inline__ u_int64_t casxa(paddr_t loc, int asi, 
	u_int64_t value, u_int64_t oldvalue);
d1123 1
a1123 1
extern void next_tick(long);
@


1.3.4.3
log
@Sync the SMP branch with 3.3
@
text
@a25 26
/*
 * Copyright (c) 2001 Jake Burkholder.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

a32 42
 * membar operand macros for use in other macros when # is a special
 * character.  Keep these in sync with what the hardware expects.
 */
#define C_Lookaside     (0)
#define C_MemIssue      (1)
#define C_Sync          (2)
#define M_LoadLoad      (0)
#define M_StoreLoad     (1)
#define M_LoadStore     (2)
#define M_StoreStore    (3)

#define CMASK_SHIFT     (4)
#define MMASK_SHIFT     (0)

#define CMASK_GEN(bit)  ((1 << (bit)) << CMASK_SHIFT)
#define MMASK_GEN(bit)  ((1 << (bit)) << MMASK_SHIFT)

#ifndef __ASSEMBLER__
#define Lookaside       CMASK_GEN(C_Lookaside)
#define MemIssue        CMASK_GEN(C_MemIssue)
#define Sync            CMASK_GEN(C_Sync)
#define LoadLoad        MMASK_GEN(M_LoadLoad)
#define StoreLoad       MMASK_GEN(M_StoreLoad)
#define LoadStore       MMASK_GEN(M_LoadStore)
#define StoreStore      MMASK_GEN(M_StoreStore)
#endif

#define casa(rs1, rs2, rd, asi) ({                                      \
	u_int __rd = (u_int32_t)(rd);                                   \
	__asm __volatile("casa [%1] %2, %3, %0"                         \
	    : "+r" (__rd) : "r" (rs1), "n" (asi), "r" (rs2));           \
	__rd;                                                           \
})

#define casxa(rs1, rs2, rd, asi) ({                                     \
	u_long __rd = (u_int64_t)(rd);                                  \
	__asm __volatile("casxa [%1] %2, %3, %0"                        \
	    : "+r" (__rd) : "r" (rs1), "n" (asi), "r" (rs2));           \
	__rd;                                                           \
})

/*
d182 1
a182 1
#define	PHYS_ASI(x)	(((x) | 0x09) == 0x1d)
a184 6
/*
 * %tick: cpu cycle counter
 */
#define	TICK_NPT	0x8000000000000000	/* trap on non priv access */
#define	TICK_TICKS	0x7fffffffffffffff	/* counter bits */

a230 1
 * III = cheetah only
a243 3
#define TSB_PEXT		0x48	/* III primary ext */
#define TSB_SEXT		0x50	/* III 2ndary ext -- DMMU only */
#define TSB_NEXT		0x58	/* III nucleus ext */
d446 295
a740 45
/* Generate ld*a/st*a functions for non-constant ASI's. */
#define LDNC_GEN(tp, o)							\
	extern __inline tp o ## _nc(paddr_t, int);			\
	extern __inline tp						\
	o ## _nc(paddr_t va, int asi)					\
	{								\
		tp r;							\
		__asm __volatile(					\
		    "wr %2, 0, %%asi;" #o " [%1] %%asi, %0"		\
		    : "=r" (r)						\
		    : "r" ((volatile tp *)va), "r" (asi));		\
		return (r);						\
	}								\
	extern __inline tp o ## _asi(paddr_t);				\
	extern __inline tp						\
	o ## _asi(paddr_t va)						\
	{								\
		tp r;							\
		__asm __volatile(					\
		    #o " [%1] %%asi, %0"				\
		    : "=r" (r)						\
		    : "r" ((volatile tp *)va));				\
		return (r);						\
	}

LDNC_GEN(u_char, lduba);
LDNC_GEN(u_short, lduha);
LDNC_GEN(u_int, lduwa);
LDNC_GEN(u_int64_t, ldxa);

LDNC_GEN(int, lda);

#define LDC_GEN(va, asi, op, opa, type) ({				\
	type __r ## op ## type;						\
	if(asi == ASI_PRIMARY  || 					\
	    (sizeof(type) == 1 && asi == ASI_PRIMARY_LITTLE))		\
		__r ## op ## type = *((volatile type *)va);		\
		/*__asm __volatile(#op " [%1], %0"			\
		    : "=r" (__r ## op ## type) : "r" (va));*/		\
	else								\
		__asm __volatile(#opa " [%1] " #asi ", %0"		\
		    : "=r" (__r ## op ## type)				\
		    : "r" ((volatile type *)va));			\
	__r ## op ## type;						\
})
d742 21
a762 76
#ifdef __OPTIMIZE__
#define LD_GENERIC(va, asi, op, type) (__builtin_constant_p(asi) ?	\
	LDC_GEN(va, asi, op, op ## a, type) : op ## a_nc(va, asi))
#else
#define LD_GENERIC(va, asi, op, type) (op ## a_nc(va, asi))
#endif

#define lduba(va, asi)	LD_GENERIC(va, asi, ldub, u_char)
#define lduha(va, asi)	LD_GENERIC(va, asi, lduh, u_short)
#define lduwa(va, asi)	LD_GENERIC(va, asi, lduw, u_int)
#define ldxa(va, asi)	LD_GENERIC(va, asi, ldx, u_int64_t)

#define ldua(va, asi)	LD_GENERIC(va, asi, ldu, u_int)
#define lda(va, asi)	LD_GENERIC(va, asi, ld, int)

#define STNC_GEN(tp, o)							\
	extern __inline void o ## _nc(paddr_t, int, tp);		\
	extern __inline void						\
	o ## _nc(paddr_t va, int asi, tp val)				\
	{                                                               \
		__asm __volatile(					\
		    "wr %2, 0, %%asi;" #o " %0, [%1] %%asi"		\
		    :							\
		    : "r" (val), "r" ((volatile tp *)va), "r" (asi));	\
	}								\
	extern __inline void o ## _asi(paddr_t, tp);			\
	extern __inline void						\
	o ## _asi(paddr_t va, tp val)					\
	{                                                               \
		__asm __volatile(					\
		    #o " %0, [%1] %%asi"				\
		    :							\
		    : "r" (val), "r" ((volatile tp *)va) );		\
	}

STNC_GEN(u_char, stba);
STNC_GEN(u_short, stha);
STNC_GEN(u_int, stwa);
STNC_GEN(u_int64_t, stxa);

STNC_GEN(u_int, sta);

#define STC_GEN(va, asi, val, op, opa, type) ({				\
	if(asi == ASI_PRIMARY ||					\
	    (sizeof(type) == 1 && asi == ASI_PRIMARY_LITTLE))		\
		*((volatile type *)va) = val;				\
		/*__asm __volatile(#op " %0, [%1] " 			\
		    : : "r" (val), "r" ((volatile type *)va));*/	\
	else								\
		__asm __volatile(#opa " %0, [%1] " #asi			\
		    : : "r" (val), "r" ((volatile type *)va));		\
	})

#ifdef __OPTIMIZE__
#define ST_GENERIC(va, asi, val, op, type) (__builtin_constant_p(asi) ?	\
	STC_GEN(va, asi, val, op, op ## a, type) : op ## a_nc(va, asi, val))
#else
#define ST_GENERIC(va, asi, val, op, type) (op ## a_nc(va, asi, val))
#endif

#define stba(va, asi, val)	ST_GENERIC(va, asi, val, stb, u_int8_t)
#define stha(va, asi, val)	ST_GENERIC(va, asi, val, sth, u_int16_t)
#define stwa(va, asi, val)	ST_GENERIC(va, asi, val, stw, u_int32_t)
#define stxa(va, asi, val)	ST_GENERIC(va, asi, val, stx, u_int64_t)

#define sta(va, asi, val)	ST_GENERIC(va, asi, val, st, u_int)

#define membar(mask) do {                                               \
	__asm __volatile("membar %0" : : "n" (mask) : "memory");        \
} while (0)

#define rd(name) ({                                                     \
	u_int64_t __sr;                                                 \
	__asm __volatile("rd %%" #name ", %0" : "=r" (__sr) :);         \
	__sr;                                                           \
})
d764 24
a787 10
#define wr(name, val, xor) do {                                         \
	__asm __volatile("wr %0, %1, %%" #name                          \
	    : : "r" (val), "rI" (xor));                                 \
} while (0)

#define rdpr(name) ({                                                   \
	u_int64_t __pr;                                                 \
	__asm __volatile("rdpr %%" #name", %0" : "=r" (__pr) :);        \
	__pr;                                                           \
})
d789 17
a805 4
#define wrpr(name, val, xor) do {                                       \
	__asm __volatile("wrpr %0, %1, %%" #name                        \
	    : : "r" (val), "rI" (xor));                                 \
} while (0)
d807 4
a810 3
extern __inline void asi_set(int);
extern __inline
void asi_set(int asi)
d812 13
a824 1
	wr(asi, asi, 0);
d826 5
d832 24
a855 3
extern __inline u_int8_t asi_get(void);
extern __inline
u_int8_t asi_get()
d857 13
a869 1
	return rd(asi);
d871 5
d877 18
d896 4
a899 2
static __inline u_long
intr_disable(void)
d901 39
a939 1
	u_long s;
d941 74
a1014 3
	s = rdpr(pstate);
	wrpr(pstate, s & ~PSTATE_IE, 0);
	return (s);
d1016 11
a1026 1
#define intr_restore(s) wrpr(pstate, (s), 0)
d1028 1
d1030 1
a1030 3
 * In some places, it is required that the store is directly followed by a
 * membar #Sync. Don't trust the compiler to not insert instructions in
 * between. We also need to disable interrupts completely.
d1032 27
a1058 17
#define stxa_sync(va, asi, val) do {					\
	u_long stxa_sync_s;						\
	stxa_sync_s = intr_disable();					\
	if(PHYS_ASI(asi)) {						\
		__asm __volatile(					\
		    "stxa %g0, [%0] #ASI_DCACHE_TAG; membar #Sync"	\
		    : : "r" (va & ~0x1f));				\
	}								\
	__asm __volatile("stxa %0, [%1] %2; membar #Sync"		\
	    : : "r" (val), "r" (va), "n" (asi));			\
	if(PHYS_ASI(asi)) {						\
		__asm __volatile(					\
		    "stxa %g0, [%0] #ASI_DCACHE_TAG; membar #Sync"	\
		    : : "r" (va & ~0x1f));				\
	}								\
	intr_restore(stxa_sync_s);					\
} while (0)
d1066 10
d1092 1
a1092 1
#define	membar_storestore() membar(StoreStore)
d1094 1
a1094 1
#define	membar_loadstore() membar(LoadStore)
d1096 1
a1096 1
#define	membar_storeload() membar(StoreLoad)
d1098 1
a1098 1
#define	membar_loadload() membar(LoadLoad)
d1100 1
a1100 1
#define	membar_sync() membar(Sync)
d1102 1
a1102 1
#define	membar_memissue() membar(MemIssue)
d1104 1
a1104 1
#define	membar_lookaside() membar(Lookaside)
d1106 1
d1113 9
@


1.3.4.4
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ctlreg.h,v 1.3.4.3 2003/03/27 23:42:36 niklas Exp $	*/
a51 2
#ifndef _SPARC64_CTLREG_
#define _SPARC64_CTLREG_
d76 24
a523 95
extern __inline u_int32_t sparc_cas(u_int32_t *, u_int32_t, u_int32_t);
extern __inline u_int32_t
sparc_cas(u_int32_t *rs1, u_int32_t rs2, u_int32_t rd)
{
	__asm __volatile("casa [%1] ASI_PRIMARY, %2, %0"
	    : "+r" (rd)
	    : "r" (rs1), "r" (rs2)
	    : "memory" );
	return (rd);
}

extern __inline u_int64_t sparc_casx(u_int64_t *, u_int64_t, u_int64_t);
extern __inline u_int64_t
sparc_casx(u_int64_t *rs1, u_int64_t rs2, u_int64_t rd)
{
	__asm __volatile("casxa [%1] ASI_PRIMARY, %3, %0"
	    : "+r" (rd)
	    : "r" (rs1), "r" (rs2)
	    : "memory" );
	return (rd);
}

#define sparc_membar(mask) do {                                         \
        if (mask)                                                       \
                __asm __volatile("membar %0" : : "n" (mask) : "memory");\
        else                                                            \
                __asm __volatile("" : : : "memory");                    \
} while(0)

#define membar sparc_membar
#define Lookaside       CMASK_GEN(C_Lookaside)
#define MemIssue        CMASK_GEN(C_MemIssue)
#define Sync            CMASK_GEN(C_Sync)
#define LoadLoad        MMASK_GEN(M_LoadLoad)
#define StoreLoad       MMASK_GEN(M_StoreLoad)
#define LoadStore       MMASK_GEN(M_LoadStore)
#define StoreStore      MMASK_GEN(M_StoreStore)

#define sparc_wr(name, val, xor)					\
do {									\
	if (__builtin_constant_p(xor))					\
		__asm __volatile("wr %%g0, %0, %%" #name		\
		    : : "rI" ((val) ^ (xor)) : "%g0");			\
	else								\
		__asm __volatile("wr %0, %1, %%" #name			\
		    : : "r" (val), "rI" (xor) : "%g0");			\
} while(0)

#define sparc_wrpr(name, val, xor)					\
do {									\
	if (__builtin_constant_p(xor))					\
		__asm __volatile("wrpr %%g0, %0, %%" #name		\
		    : : "rI" ((val) ^ (xor)) : "%g0");			\
	else								\
		__asm __volatile("wrpr %0, %1, %%" #name		\
		    : : "r" (val), "rI" (xor) : "%g0");			\
} while(0)


#define sparc_rd(name) sparc_rd_ ## name()
#define GEN_RD(name)							\
extern __inline u_int64_t sparc_rd_ ## name(void);			\
extern __inline u_int64_t						\
sparc_rd_ ## name()							\
{									\
	u_int64_t r;							\
	__asm __volatile("rd %%" #name ", %0" :				\
	    "=r" (r) : : "%g0");					\
	return (r);							\
}

#define sparc_rdpr(name) sparc_rdpr_ ## name()
#define GEN_RDPR(name)							\
extern __inline u_int64_t sparc_rdpr_ ## name(void);			\
extern __inline u_int64_t						\
sparc_rdpr_ ## name()							\
{									\
	u_int64_t r;							\
	__asm __volatile("rdpr %%" #name ", %0" :			\
	    "=r" (r) : : "%g0");					\
	return (r);							\
}

GEN_RD(asi);
GEN_RD(asr22);
GEN_RDPR(cwp);
GEN_RDPR(tick);
GEN_RDPR(pstate);
GEN_RDPR(pil);
GEN_RDPR(ver);
/*
 * Before adding GEN_RDPRs for other registers, see Errata 50 (E.g,. in
 * the US-IIi manual) regarding tstate, pc and npc reads.
 */

d526 11
d545 1
a545 2
		    : "r" ((volatile tp *)va)				\
		    : "%g0");						\
a546 7
	}								\
	extern __inline tp o ## _nc(paddr_t, int);			\
	extern __inline tp						\
	o ## _nc(paddr_t va, int asi)					\
	{								\
		sparc_wr(asi, asi, 0);					\
		return (o ## _asi(va));					\
d561 2
d566 1
a566 2
		    : "r" ((volatile type *)va)				\
		    : "%g0");						\
d572 8
a579 8
	LDC_GEN((va), asi, op, op ## a, type) : op ## a_nc((va), asi))
#else /* __OPTIMIZE */
#define LD_GENERIC(va, asi, op, type) (op ## a_nc((va), asi))
#endif /* __OPTIMIZE__ */

#define lduba(va, asi)	LD_GENERIC(va, asi, ldub, u_int8_t)
#define lduha(va, asi)	LD_GENERIC(va, asi, lduh, u_int16_t)
#define lduwa(va, asi)	LD_GENERIC(va, asi, lduw, u_int32_t)
d582 3
d586 9
d598 1
a598 1
	{								\
d602 1
a602 9
		    : "r" (val), "r" ((volatile tp *)va)		\
		    : "memory");					\
	}								\
	extern __inline void o ## _nc(paddr_t, int, tp);		\
	extern __inline void						\
	o ## _nc(paddr_t va, int asi, tp val)				\
	{								\
		sparc_wr(asi, asi, 0);					\
		o ## _asi(va, val);					\
d605 3
a607 3
STNC_GEN(u_int8_t, stba);
STNC_GEN(u_int16_t, stha);
STNC_GEN(u_int32_t, stwa);
d616 2
d620 1
a620 2
		    : : "r" (val), "r" ((volatile type *)va)		\
		    : "memory");					\
d625 4
a628 5
	STC_GEN((va), (asi), (val), op, op ## a, type) :		\
	op ## a_nc((va), asi, (val)))
#else /* __OPTIMIZE__ */
#define ST_GENERIC(va, asi, val, op, type) (op ## a_nc((va), asi, (val)))
#endif /* __OPTIMIZE__ */
d635 27
d667 1
a667 1
	sparc_wr(asi, asi, 0);
d674 1
a674 1
	return sparc_rd(asi);
d677 3
a679 4
/* flush address from instruction cache */
extern __inline void flush(void *);
extern __inline
void flush(void *p)
d681 5
a685 3
	__asm __volatile("flush %0"
	    : : "r" (p)
	    : "memory");
d687 60
d749 5
a753 1
#define tick() (sparc_rdpr(tick) & TICK_TICKS)
d756 1
a756 3

#endif /* _LOCORE */
#endif /* _SPARC64_CTLREG_ */
@


1.2
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d271 1
a271 9
#if 0
/* Old bits */
#define	SFSR_BITS "\40\16VAT\15VAD\14NFO\13ASI\12A\11NF\10PRIV\7E\6NUCLEUS\5SECONDCTX\4PRIV\3W\2OW\1FV"
#else
/* New bits */
#define	SFSR_BITS "\177\20" \
	"f\20\30ASI\0" "b\16VAT\0" "b\15VAD\0" "b\14NFO\0" "b\13ASI\0" "b\12A\0" "b\11NF\0" "b\10PRIV\0" \
	 "b\7E\0" "b\6NUCLEUS\0" "b\5SECONDCTX\0" "b\4PRIV\0" "b\3W\0" "b\2OW\0" "b\1FV\0"
#endif
d290 3
a292 5
#define	AFSR_BITS "\177\20" \
        "b\40ME\0"      "b\37PRIV\0"    "b\36ISAP\0"    "b\35ETP\0" \
        "b\34IVUE\0"    "b\33TO\0"      "b\32BERR\0"    "b\31LDP\0" \
        "b\30CP\0"      "b\27WP\0"      "b\26EDP\0"     "b\25UE\0" \
        "b\24CE\0"      "f\20\4ETS\0"   "f\0\20P_SYND\0"
@


1.1
log
@More includes from NetBSD.
No modifications.
@
text
@d1 1
@

