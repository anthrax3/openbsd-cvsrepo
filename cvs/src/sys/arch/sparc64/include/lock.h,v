head	1.10;
access;
symbols
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.10.0.8
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.4
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.10.0.6
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.9.0.6
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.9.0.4
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.8.0.2
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.7.0.8
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.6
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.4
	OPENBSD_5_0:1.7.0.2
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.5.0.4
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.2
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.4.0.6
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.8
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.4
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.2
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.3.0.2
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.1.0.2
	OPENBSD_4_2_BASE:1.1;
locks; strict;
comment	@ * @;


1.10
date	2015.02.11.00.14.11;	author dlg;	state Exp;
branches;
next	1.9;
commitid	OPUATglsyqcmeG4g;

1.9
date	2014.01.30.00.51.13;	author dlg;	state Exp;
branches;
next	1.8;

1.8
date	2013.05.21.20.05.30;	author tedu;	state Exp;
branches;
next	1.7;

1.7
date	2011.07.02.22.19.16;	author guenther;	state Exp;
branches;
next	1.6;

1.6
date	2011.03.23.16.54.37;	author pirofti;	state Exp;
branches;
next	1.5;

1.5
date	2010.04.27.21.15.01;	author kettenis;	state Exp;
branches;
next	1.4;

1.4
date	2008.05.02.19.52.27;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2008.01.01.23.37.16;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2007.11.05.20.19.22;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2007.05.01.18.56.31;	author miod;	state Exp;
branches;
next	;


desc
@@


1.10
log
@make the rwlock implementation MI.

each arch used to have to provide an rw_cas operation, but now we
have the rwlock code build its own version. on smp machines it uses
atomic_cas_ulong. on uniproc machines it avoids interlocked
instructions by using straight loads and stores. this is safe because
rwlocks are only used from process context and processes are currently
not preemptible in our kernel. so alpha/ppc/etc might get a benefit.

ok miod@@ kettenis@@ deraadt@@
@
text
@/*	$OpenBSD: lock.h,v 1.9 2014/01/30 00:51:13 dlg Exp $	*/

/* public domain */

#ifndef	_MACHINE_LOCK_H_
#define	_MACHINE_LOCK_H_

#endif	/* _MACHINE_LOCK_H_ */
@


1.9
log
@move sparc64 behind the MI atomic api.

this basically replaces sparc64_cas and sparc64_casx with atomic_cas_uint
and atomic_cas_ulong respectively. it then builds atomic_add and
atomic_sub out of those. this avoids the gcc atomic builtins that
the MI atomic_foo api uses by default, so we dont get the extra
membars that the builtins do but the atomic_foo api doesnt promise.

it also fixes up the code that used to use sparc64_{cas,casx} to
use the atomic_cas api instead.

use of the sparc64 membar() macros are left untouched for now.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lock.h,v 1.8 2013/05/21 20:05:30 tedu Exp $	*/
a6 4

#include <sys/atomic.h>

#define	rw_cas(p, o, n)		(atomic_cas_ulong(p, o, n) != o)
@


1.8
log
@remove unused cpu_lock code (where it is truly unused). it is not
part of the future we have planned. middling ok from a few
@
text
@d1 1
a1 1
/*	$OpenBSD: lock.h,v 1.7 2011/07/02 22:19:16 guenther Exp $	*/
d8 1
a8 2
#include <machine/atomic.h>
#include <machine/ctlreg.h>
d10 1
a10 1
#define	rw_cas(p, o, n)		(sparc64_casx(p, o, n) != o)
@


1.7
log
@Per recommandation in the the sparc docs, use unlocked reads when
spinning on a contended lock.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lock.h,v 1.6 2011/03/23 16:54:37 pirofti Exp $	*/
a9 46

typedef volatile u_int8_t __cpu_simple_lock_t;

#define	__SIMPLELOCK_LOCKED	0xff
#define	__SIMPLELOCK_UNLOCKED	0x00

static __inline__ void
__cpu_simple_lock_init(__cpu_simple_lock_t *l)
{
	*l = __SIMPLELOCK_UNLOCKED;
}

static __inline__ u_int8_t
__cpu_ldstub(__cpu_simple_lock_t *l)
{
	u_int8_t old;

	__asm__ __volatile__
	    ("ldstub [%1], %0" : "=&r" (old) : "r" (l) : "memory");
	return old;
}

static __inline__ void
__cpu_simple_lock(__cpu_simple_lock_t *l)
{
	while (__cpu_ldstub(l) != __SIMPLELOCK_UNLOCKED)
		while (*l != __SIMPLELOCK_UNLOCKED)
			;
	membar(LoadLoad | LoadStore);	/* only needed for PSO and RMO */
}

static __inline__ int
__cpu_simple_lock_try(__cpu_simple_lock_t *l)
{
	if (__cpu_ldstub(l) != __SIMPLELOCK_UNLOCKED)
		return (0);
	membar(LoadLoad | LoadStore);	/* only needed for PSO and RMO */
	return (1);
}

static __inline__ void
__cpu_simple_unlock(__cpu_simple_lock_t *l)
{
	membar(StoreStore | LoadStore);	/* only needed for PSO and RMO */
	*l = __SIMPLELOCK_UNLOCKED;
}
@


1.6
log
@Normalize sentinel. Use _MACHINE_*_H_ and _<ARCH>_*_H_ properly and consitently.

Discussed and okay drahn@@. Okay deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: lock.h,v 1.5 2010/04/27 21:15:01 kettenis Exp $	*/
d22 10
d35 4
a38 8
	__cpu_simple_lock_t old;

	do {
		old = __SIMPLELOCK_LOCKED;
		__asm__ __volatile__
		    ("ldstub [%0], %1" : "=r" (l), "=r" (old) : "0" (l));
		membar(LoadLoad | LoadStore);
	} while (old != __SIMPLELOCK_UNLOCKED);
d44 4
a47 7
	__cpu_simple_lock_t old = __SIMPLELOCK_LOCKED;

	__asm__ __volatile__
	    ("ldstub [%0], %1" : "=r" (l), "=r" (old) : "0" (l));
	membar(LoadLoad | LoadStore);

	return (old == __SIMPLELOCK_UNLOCKED);
d53 1
a53 1
	membar(StoreStore | LoadStore);
@


1.5
log
@Fix inline assembler to make it acceptable to gcc4.  Based on a diff from
guenther@@ for sparc, pointed out to me by miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: lock.h,v 1.4 2008/05/02 19:52:27 miod Exp $	*/
d5 2
a6 2
#ifndef	_SPARC64_LOCK_H_
#define	_SPARC64_LOCK_H_
d56 1
a56 1
#endif	/* _SPARC64_LOCK_H_ */
@


1.4
log
@Implement rw_cas correctly, unlike previous revision where I was obviously
on drugs; ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lock.h,v 1.3 2008/01/01 23:37:16 miod Exp $	*/
d30 1
a30 1
		    ("ldstub %0, %1" : "=m" (*l), "=r" (old) : "0" (*l));
d41 1
a41 1
	    ("ldstub %0, %1" : "=m" (*l), "=r" (old) : "0" (*l));
@


1.3
log
@Implement an MP-safe rw_cas() based upon the casx instruction; ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lock.h,v 1.2 2007/11/05 20:19:22 miod Exp $	*/
d54 1
a54 1
#define	rw_cas_sparc64	(sparc64_casx(p, o, n) != o)
@


1.2
log
@Sprinkle a few holy membars around memory writes.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lock.h,v 1.1 2007/05/01 18:56:31 miod Exp $	*/
d8 1
d53 2
@


1.1
log
@Provide <machine/lock.h> on all platforms, so that MI code may #include it
unconditionnaly.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d8 2
d30 1
d41 1
d49 1
@

