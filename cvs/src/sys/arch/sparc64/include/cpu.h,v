head	1.89;
access;
symbols
	OPENBSD_6_1:1.89.0.2
	OPENBSD_6_1_BASE:1.89
	OPENBSD_6_0:1.88.0.4
	OPENBSD_6_0_BASE:1.88
	OPENBSD_5_9:1.88.0.2
	OPENBSD_5_9_BASE:1.88
	OPENBSD_5_8:1.87.0.4
	OPENBSD_5_8_BASE:1.87
	OPENBSD_5_7:1.86.0.2
	OPENBSD_5_7_BASE:1.86
	OPENBSD_5_6:1.85.0.4
	OPENBSD_5_6_BASE:1.85
	OPENBSD_5_5:1.83.0.6
	OPENBSD_5_5_BASE:1.83
	OPENBSD_5_4:1.83.0.2
	OPENBSD_5_4_BASE:1.83
	OPENBSD_5_3:1.81.0.2
	OPENBSD_5_3_BASE:1.81
	OPENBSD_5_2:1.78.0.6
	OPENBSD_5_2_BASE:1.78
	OPENBSD_5_1_BASE:1.78
	OPENBSD_5_1:1.78.0.4
	OPENBSD_5_0:1.78.0.2
	OPENBSD_5_0_BASE:1.78
	OPENBSD_4_9:1.75.0.2
	OPENBSD_4_9_BASE:1.75
	OPENBSD_4_8:1.72.0.6
	OPENBSD_4_8_BASE:1.72
	OPENBSD_4_7:1.72.0.2
	OPENBSD_4_7_BASE:1.72
	OPENBSD_4_6:1.72.0.4
	OPENBSD_4_6_BASE:1.72
	OPENBSD_4_5:1.71.0.2
	OPENBSD_4_5_BASE:1.71
	OPENBSD_4_4:1.63.0.2
	OPENBSD_4_4_BASE:1.63
	OPENBSD_4_3:1.55.0.2
	OPENBSD_4_3_BASE:1.55
	OPENBSD_4_2:1.40.0.2
	OPENBSD_4_2_BASE:1.40
	OPENBSD_4_1:1.37.0.2
	OPENBSD_4_1_BASE:1.37
	OPENBSD_4_0:1.35.0.2
	OPENBSD_4_0_BASE:1.35
	OPENBSD_3_9:1.34.0.2
	OPENBSD_3_9_BASE:1.34
	OPENBSD_3_8:1.31.0.2
	OPENBSD_3_8_BASE:1.31
	OPENBSD_3_7:1.30.0.2
	OPENBSD_3_7_BASE:1.30
	OPENBSD_3_6:1.29.0.2
	OPENBSD_3_6_BASE:1.29
	SMP_SYNC_A:1.24
	SMP_SYNC_B:1.24
	OPENBSD_3_5:1.24.0.4
	OPENBSD_3_5_BASE:1.24
	OPENBSD_3_4:1.24.0.2
	OPENBSD_3_4_BASE:1.24
	UBC_SYNC_A:1.20
	OPENBSD_3_3:1.19.0.2
	OPENBSD_3_3_BASE:1.19
	OPENBSD_3_2:1.15.0.2
	OPENBSD_3_2_BASE:1.15
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	UBC_SYNC_B:1.15
	UBC:1.6.0.2
	UBC_BASE:1.6
	SMP:1.5.0.4
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	SPARC64:1.1.1.1
	NETBSD:1.1.1;
locks; strict;
comment	@ * @;


1.89
date	2016.08.17.11.09.01;	author dlg;	state Exp;
branches;
next	1.88;
commitid	eDxQlBEYZrWROsO8;

1.88
date	2015.08.28.23.28.39;	author kettenis;	state Exp;
branches;
next	1.87;
commitid	IIvmUURykkPFbth0;

1.87
date	2015.07.02.01.33.59;	author dlg;	state Exp;
branches;
next	1.86;
commitid	HBmwORlhlW47BLMN;

1.86
date	2014.10.15.21.54.13;	author sebastia;	state Exp;
branches;
next	1.85;
commitid	iILELoWbp7ppxRUV;

1.85
date	2014.07.11.10.53.07;	author uebayasi;	state Exp;
branches;
next	1.84;
commitid	CaCLs5fTSVpJlqFi;

1.84
date	2014.03.29.18.09.30;	author guenther;	state Exp;
branches;
next	1.83;

1.83
date	2013.05.31.17.00.59;	author tedu;	state Exp;
branches;
next	1.82;

1.82
date	2013.03.12.09.37.16;	author mpi;	state Exp;
branches;
next	1.81;

1.81
date	2013.02.12.08.06.22;	author mpi;	state Exp;
branches;
next	1.80;

1.80
date	2013.02.11.17.05.25;	author mpi;	state Exp;
branches;
next	1.79;

1.79
date	2012.12.02.07.03.31;	author guenther;	state Exp;
branches;
next	1.78;

1.78
date	2011.07.06.22.26.44;	author kettenis;	state Exp;
branches;
next	1.77;

1.77
date	2011.06.24.19.47.49;	author naddy;	state Exp;
branches;
next	1.76;

1.76
date	2011.03.23.16.54.37;	author pirofti;	state Exp;
branches;
next	1.75;

1.75
date	2010.12.21.14.56.24;	author claudio;	state Exp;
branches;
next	1.74;

1.74
date	2010.11.27.19.41.48;	author miod;	state Exp;
branches;
next	1.73;

1.73
date	2010.09.28.20.27.55;	author miod;	state Exp;
branches;
next	1.72;

1.72
date	2009.03.26.17.24.33;	author oga;	state Exp;
branches;
next	1.71;

1.71
date	2009.01.23.19.16.39;	author kettenis;	state Exp;
branches;
next	1.70;

1.70
date	2008.11.22.18.12.32;	author art;	state Exp;
branches;
next	1.69;

1.69
date	2008.10.15.23.23.50;	author deraadt;	state Exp;
branches;
next	1.68;

1.68
date	2008.10.10.08.05.45;	author art;	state Exp;
branches;
next	1.67;

1.67
date	2008.10.09.08.43.43;	author art;	state Exp;
branches;
next	1.66;

1.66
date	2008.08.10.14.13.05;	author kettenis;	state Exp;
branches;
next	1.65;

1.65
date	2008.08.07.21.25.48;	author kettenis;	state Exp;
branches;
next	1.64;

1.64
date	2008.08.07.18.46.04;	author kettenis;	state Exp;
branches;
next	1.63;

1.63
date	2008.07.18.23.43.31;	author art;	state Exp;
branches;
next	1.62;

1.62
date	2008.07.04.22.03.30;	author kettenis;	state Exp;
branches;
next	1.61;

1.61
date	2008.04.17.19.52.27;	author kettenis;	state Exp;
branches;
next	1.60;

1.60
date	2008.04.13.16.32.55;	author kettenis;	state Exp;
branches;
next	1.59;

1.59
date	2008.03.31.22.14.01;	author kettenis;	state Exp;
branches;
next	1.58;

1.58
date	2008.03.23.23.46.21;	author kettenis;	state Exp;
branches;
next	1.57;

1.57
date	2008.03.17.23.10.21;	author kettenis;	state Exp;
branches;
next	1.56;

1.56
date	2008.03.15.22.05.51;	author kettenis;	state Exp;
branches;
next	1.55;

1.55
date	2008.02.20.09.44.47;	author robert;	state Exp;
branches;
next	1.54;

1.54
date	2008.02.18.10.37.20;	author robert;	state Exp;
branches;
next	1.53;

1.53
date	2008.01.19.17.42.05;	author kettenis;	state Exp;
branches;
next	1.52;

1.52
date	2007.10.31.22.46.52;	author kettenis;	state Exp;
branches;
next	1.51;

1.51
date	2007.10.21.21.00.38;	author kettenis;	state Exp;
branches;
next	1.50;

1.50
date	2007.10.20.16.54.49;	author miod;	state Exp;
branches;
next	1.49;

1.49
date	2007.10.18.20.44.47;	author kettenis;	state Exp;
branches;
next	1.48;

1.48
date	2007.10.16.19.22.49;	author kettenis;	state Exp;
branches;
next	1.47;

1.47
date	2007.10.16.19.13.53;	author kettenis;	state Exp;
branches;
next	1.46;

1.46
date	2007.09.30.21.34.20;	author kettenis;	state Exp;
branches;
next	1.45;

1.45
date	2007.09.09.14.59.37;	author kettenis;	state Exp;
branches;
next	1.44;

1.44
date	2007.09.09.12.57.40;	author kettenis;	state Exp;
branches;
next	1.43;

1.43
date	2007.09.09.08.55.26;	author kettenis;	state Exp;
branches;
next	1.42;

1.42
date	2007.09.08.17.13.17;	author kettenis;	state Exp;
branches;
next	1.41;

1.41
date	2007.09.04.20.36.52;	author kettenis;	state Exp;
branches;
next	1.40;

1.40
date	2007.05.14.21.38.08;	author kettenis;	state Exp;
branches;
next	1.39;

1.39
date	2007.05.02.18.46.06;	author kettenis;	state Exp;
branches;
next	1.38;

1.38
date	2007.03.15.10.22.30;	author art;	state Exp;
branches;
next	1.37;

1.37
date	2006.12.24.20.30.35;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2006.11.29.12.26.14;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2006.06.21.21.53.32;	author jason;	state Exp;
branches;
next	1.34;

1.34
date	2006.02.22.22.17.07;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2005.11.11.16.50.19;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2005.09.21.21.08.35;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2005.04.26.18.54.38;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2004.10.01.18.18.49;	author jason;	state Exp;
branches;
next	1.29;

1.29
date	2004.08.09.10.13.21;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2004.06.21.23.12.14;	author art;	state Exp;
branches;
next	1.27;

1.27
date	2004.06.20.08.25.30;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2004.06.20.06.47.31;	author art;	state Exp;
branches;
next	1.25;

1.25
date	2004.06.13.21.49.20;	author niklas;	state Exp;
branches;
next	1.24;

1.24
date	2003.07.10.15.26.54;	author jason;	state Exp;
branches;
next	1.23;

1.23
date	2003.07.09.23.56.16;	author jason;	state Exp;
branches;
next	1.22;

1.22
date	2003.06.24.21.54.39;	author henric;	state Exp;
branches;
next	1.21;

1.21
date	2003.06.02.23.27.56;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2003.05.16.22.14.13;	author henric;	state Exp;
branches;
next	1.19;

1.19
date	2003.03.21.22.59.09;	author jason;	state Exp;
branches;
next	1.18;

1.18
date	2003.03.20.23.05.30;	author henric;	state Exp;
branches;
next	1.17;

1.17
date	2003.02.12.06.32.59;	author jason;	state Exp;
branches;
next	1.16;

1.16
date	2003.02.10.10.47.58;	author jason;	state Exp;
branches;
next	1.15;

1.15
date	2002.08.02.04.22.04;	author jason;	state Exp;
branches;
next	1.14;

1.14
date	2002.08.02.04.17.05;	author jason;	state Exp;
branches;
next	1.13;

1.13
date	2002.06.14.04.17.59;	author art;	state Exp;
branches;
next	1.12;

1.12
date	2002.06.11.10.57.51;	author art;	state Exp;
branches;
next	1.11;

1.11
date	2002.06.07.21.33.43;	author nordin;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.27.15.12.22;	author jason;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.14.03.16.00;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.14.01.26.45;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.01.21.48.23;	author jason;	state Exp;
branches;
next	1.6;

1.6
date	2001.11.06.18.41.10;	author art;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2001.09.04.15.19.16;	author jason;	state Exp;
branches
	1.5.4.1;
next	1.4;

1.4
date	2001.08.19.05.12.47;	author art;	state Exp;
branches;
next	1.3;

1.3
date	2001.08.18.20.20.09;	author art;	state Exp;
branches;
next	1.2;

1.2
date	2001.08.18.15.27.30;	author art;	state Exp;
branches;
next	1.1;

1.1
date	2001.08.18.04.16.40;	author jason;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.08.18.04.16.40;	author jason;	state Exp;
branches;
next	;

1.5.4.1
date	2001.10.31.03.07.58;	author nate;	state Exp;
branches;
next	1.5.4.2;

1.5.4.2
date	2001.11.13.21.04.17;	author niklas;	state Exp;
branches;
next	1.5.4.3;

1.5.4.3
date	2002.03.06.02.04.47;	author niklas;	state Exp;
branches;
next	1.5.4.4;

1.5.4.4
date	2002.03.28.11.23.52;	author niklas;	state Exp;
branches;
next	1.5.4.5;

1.5.4.5
date	2003.03.27.23.42.36;	author niklas;	state Exp;
branches;
next	1.5.4.6;

1.5.4.6
date	2003.06.07.11.14.45;	author ho;	state Exp;
branches;
next	1.5.4.7;

1.5.4.7
date	2004.02.19.10.50.00;	author niklas;	state Exp;
branches;
next	1.5.4.8;

1.5.4.8
date	2004.06.06.05.23.39;	author tedu;	state Exp;
branches;
next	1.5.4.9;

1.5.4.9
date	2004.06.06.23.36.28;	author deraadt;	state Exp;
branches;
next	;

1.6.2.1
date	2002.06.11.03.38.43;	author art;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2002.10.29.00.28.11;	author art;	state Exp;
branches;
next	1.6.2.3;

1.6.2.3
date	2003.05.19.21.46.57;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.89
log
@use a register variable to get at the curcpu pointer in %g7

this lets us define curcpu(), cpu_number(), etc as derefs of this
variable rather than having to write asm to copy it into another
register for the same derefs.

this provides shorter inlined code that wastes less registers.

ok kettenis@@ who notes we use this these on other archs already
@
text
@/*	$OpenBSD: cpu.h,v 1.88 2015/08/28 23:28:39 kettenis Exp $	*/
/*	$NetBSD: cpu.h,v 1.28 2001/06/14 22:56:58 thorpej Exp $ */

/*
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
 *
 * All advertising materials mentioning features or use of this software
 * must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Lawrence Berkeley Laboratory.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)cpu.h	8.4 (Berkeley) 1/5/94
 */

#ifndef _MACHINE_CPU_H_
#define _MACHINE_CPU_H_

/*
 * CTL_MACHDEP definitions.
 */
		/*		1	formerly: booted kernel name */
#define	CPU_LED_BLINK		2	/* int: blink leds? */
#define	CPU_ALLOWAPERTURE	3	/* allow xf86 operations */
#define	CPU_CPUTYPE		4	/* cpu type */
#define	CPU_CECCERRORS		5	/* Correctable ECC errors */
#define	CPU_CECCLAST		6	/* Correctable ECC last fault addr */
		/*		7	formerly: soft reset via keyboard */
#define	CPU_MAXID		8	/* number of valid machdep ids */

#define	CTL_MACHDEP_NAMES {			\
	{ 0, 0 },				\
	{ 0, 0 },				\
	{ "led_blink", CTLTYPE_INT },		\
	{ "allowaperture", CTLTYPE_INT },	\
	{ "cputype", CTLTYPE_INT },		\
	{ "ceccerrs", CTLTYPE_INT },		\
	{ "cecclast", CTLTYPE_QUAD },		\
	{ 0, 0 },				\
}

#ifdef _KERNEL
/*
 * Exported definitions unique to SPARC cpu support.
 */

#include <machine/ctlreg.h>
#include <machine/psl.h>
#include <machine/reg.h>
#include <machine/intr.h>

#include <sys/sched.h>

/*
 * The cpu_info structure is part of a 64KB structure mapped both the kernel
 * pmap and a single locked TTE a CPUINFO_VA for that particular processor.
 * Each processor's cpu_info is accessible at CPUINFO_VA only for that
 * processor.  Other processors can access that through an additional mapping
 * in the kernel pmap.
 *
 * The 64KB page contains:
 *
 * cpu_info
 * interrupt stack (all remaining space)
 * idle PCB
 * idle stack (STACKSPACE - sizeof(PCB))
 * 32KB TSB
 */

struct cpu_info {
	/*
	 * SPARC cpu_info structures live at two VAs: one global
	 * VA (so each CPU can access any other CPU's cpu_info)
	 * and an alias VA CPUINFO_VA which is the same on each
	 * CPU and maps to that CPU's cpu_info.  Since the alias
	 * CPUINFO_VA is how we locate our cpu_info, we have to
	 * self-reference the global VA so that we can return it
	 * in the curcpu() macro.
	 */
	struct cpu_info * volatile ci_self;

	/* Most important fields first */
	struct proc		*ci_curproc;
	struct pcb		*ci_cpcb;	/* also initial stack */
	struct cpu_info		*ci_next;

	struct proc		*ci_fpproc;
	int			ci_number;
	int			ci_flags;
	int			ci_upaid;
#ifdef MULTIPROCESSOR
	int			ci_itid;
	struct srp_hazard	ci_srp_hazards[SRP_HAZARD_NUM];
#endif
	int			ci_node;
	u_int32_t 		ci_randseed;
	struct schedstate_percpu ci_schedstate; /* scheduler state */

	int			ci_want_resched;
	int			ci_handled_intr_level;
	void			*ci_intrpending[16][8];
	u_int64_t		ci_tick;
	struct intrhand		ci_tickintr;

	volatile int		ci_ddb_paused;
#define CI_DDB_RUNNING		0
#define CI_DDB_SHOULDSTOP	1
#define CI_DDB_STOPPED		2
#define CI_DDB_ENTERDDB		3
#define CI_DDB_INDDB		4

	/* Spinning up the CPU */
	void			(*ci_spinup)(void); /* spinup routine */
	void			*ci_initstack;
	paddr_t			ci_paddr;	/* Phys addr of this structure. */

#ifdef SUN4V
	struct rwindow64	ci_rw;
	u_int64_t		ci_rwsp;

	paddr_t			ci_mmfsa;
	paddr_t			ci_cpumq;
	paddr_t			ci_devmq;

	paddr_t			ci_cpuset;
	paddr_t			ci_mondo;
#endif

	int			ci_pci_probe;
	int			ci_pci_fault;

#ifdef DIAGNOSTIC
	int	ci_mutex_level;
#endif
#ifdef GPROF
	struct gmonparam *ci_gmon;
#endif
};

#define CPUF_RUNNING	0x0001		/* CPU is running */

extern struct cpu_info *cpus;

#ifdef MULTIPROCESSOR

register struct cpu_info *__curcpu asm ("%g7");

#define curcpu()	(__curcpu->ci_self)
#define cpu_number()	(__curcpu->ci_number)

#define CPU_IS_PRIMARY(ci)	((ci)->ci_number == 0)
#define CPU_INFO_ITERATOR	int
#define CPU_INFO_FOREACH(cii, ci)					\
	for (cii = 0, ci = cpus; ci != NULL; ci = ci->ci_next)
#define CPU_INFO_UNIT(ci)	((ci)->ci_number)
#define MAXCPUS	256

void	cpu_boot_secondary_processors(void);

void	sparc64_send_ipi(int, void (*)(void), u_int64_t, u_int64_t);
void	sparc64_broadcast_ipi(void (*)(void), u_int64_t, u_int64_t);

void	cpu_unidle(struct cpu_info *);

#else /* MULTIPROCESSOR */

#define	__curcpu	((struct cpu_info *)CPUINFO_VA)
#define curcpu()	__curcpu
#define cpu_number()	0

#define CPU_IS_PRIMARY(ci)	1
#define CPU_INFO_ITERATOR	int
#define CPU_INFO_FOREACH(cii, ci)					\
	for (cii = 0, ci = curcpu(); ci != NULL; ci = NULL)
#define CPU_INFO_UNIT(ci)	0
#define MAXCPUS 1

#define cpu_unidle(ci)

#endif /* MULTIPROCESSOR */

#define curpcb		__curcpu->ci_cpcb
#define fpproc		__curcpu->ci_fpproc

#define CPU_BUSY_CYCLE()	do {} while (0)

/*
 * Arguments to hardclock, softclock and gatherstats encapsulate the
 * previous machine state in an opaque clockframe.  The ipl is here
 * as well for strayintr (see locore.s:interrupt and intr.c:strayintr).
 */
struct clockframe {
	struct trapframe64 t;
	int saved_intr_level;
};

#define	CLKF_USERMODE(framep)	(((framep)->t.tf_tstate & TSTATE_PRIV) == 0)
#define	CLKF_PC(framep)		((framep)->t.tf_pc)
#define	CLKF_INTR(framep)	((framep)->saved_intr_level != 0)

extern void (*cpu_start_clock)(void);

#define aston(p)	((p)->p_md.md_astpending = 1)

/*
 * Preempt the current process if in interrupt from user mode,
 * or after the current trap/syscall if in system mode.
 */
extern void need_resched(struct cpu_info *);
#define clear_resched(ci) (ci)->ci_want_resched = 0

/*
 * This is used during profiling to integrate system time.
 */
#define	PROC_PC(p)	((p)->p_md.md_tf->tf_pc)
#define	PROC_STACK(p)	((p)->p_md.md_tf->tf_out[6] + (2048-1))	/* BIAS */

/*
 * Give a profiling tick to the current process when the user profiling
 * buffer pages are invalid.  On the sparc, request an ast to send us
 * through trap(), marking the proc as needing a profiling tick.
 */
#define	need_proftick(p)	aston(p)

void signotify(struct proc *);

/* cpu.c */
int	cpu_myid(void);
/* machdep.c */
int	ldcontrolb(caddr_t);
void	dumpconf(void);
caddr_t	reserve_dumppages(caddr_t);
/* clock.c */
struct timeval;
int	clockintr(void *);/* level 10 (clock) interrupt code */
int	statintr(void *);	/* level 14 (statclock) interrupt code */
/* locore.s */
struct fpstate64;
void	savefpstate(struct fpstate64 *);
void	loadfpstate(struct fpstate64 *);
void	clearfpstate(void);
u_int64_t	probeget(paddr_t, int, int);
#define	 write_all_windows() __asm volatile("flushw" : : )
void	write_user_windows(void);
void 	proc_trampoline(void);
struct pcb;
void	snapshot(struct pcb *);
struct frame *getfp(void);
int	xldcontrolb(caddr_t, struct pcb *);
void	copywords(const void *, void *, size_t);
void	qcopy(const void *, void *, size_t);
void	qzero(void *, size_t);
void	switchtoctx(int);
/* trap.c */
void	pmap_unuse_final(struct proc *);
int	rwindow_save(struct proc *);
/* vm_machdep.c */
void	fpusave_cpu(struct cpu_info *, int);
void	fpusave_proc(struct proc *, int);
/* cons.c */
int	cnrom(void);
/* zs.c */
void zsconsole(struct tty *, int, int, void (**)(struct tty *, int));
/* fb.c */
void	fb_unblank(void);
/* tda.c */
void	tda_full_blast(void);
/* emul.c */
int	emulinstr(vaddr_t, struct trapframe64 *);
int	emul_qf(int32_t, struct proc *, union sigval, struct trapframe64 *);
int	emul_popc(int32_t, struct proc *, union sigval, struct trapframe64 *);

/*
 *
 * The SPARC has a Trap Base Register (TBR) which holds the upper 20 bits
 * of the trap vector table.  The next eight bits are supplied by the
 * hardware when the trap occurs, and the bottom four bits are always
 * zero (so that we can shove up to 16 bytes of executable code---exactly
 * four instructions---into each trap vector).
 *
 * The hardware allocates half the trap vectors to hardware and half to
 * software.
 *
 * Traps have priorities assigned (lower number => higher priority).
 */

struct trapvec {
	int	tv_instr[8];		/* the eight instructions */
};
extern struct trapvec trapbase[];	/* the 256 vectors */

extern void wzero(void *, u_int);
extern void wcopy(const void *, void *, u_int);

struct blink_led {
	void (*bl_func)(void *, int);
	void *bl_arg;
	SLIST_ENTRY(blink_led) bl_next;
};

extern void blink_led_register(struct blink_led *);

#ifdef MULTIPROCESSOR
#include <sys/mplock.h>
#endif

#endif /* _KERNEL */
#endif /* _MACHINE_CPU_H_ */
@


1.88
log
@Add support for switching CPUs in ddb on sparc64.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.87 2015/07/02 01:33:59 dlg Exp $	*/
a171 3
#define curpcb		curcpu()->ci_cpcb
#define fpproc		curcpu()->ci_fpproc

d174 1
a174 7
#define	cpu_number()	(curcpu()->ci_number)

extern __inline struct cpu_info *curcpu(void);
extern __inline struct cpu_info *
curcpu(void)
{
	struct cpu_info *ci;
d176 2
a177 3
	__asm volatile("mov %%g7, %0" : "=r"(ci));
	return (ci->ci_self);
}
d193 1
a193 1
#else
d195 2
a197 1
#define	curcpu()	((struct cpu_info *)CPUINFO_VA)
d208 4
a211 1
#endif
@


1.87
log
@introduce srp, which according to the manpage i wrote is short for
"shared reference pointers".

srp allows concurrent access to a data structure by multiple cpus
while avoiding interlocking cpu opcodes. it manages its own reference
counts and the garbage collection of those data structure to avoid
use after frees.

internally srp is a twisted version of hazard pointers, which are
a relative of RCU.

jmatthew wrote the bulk of a hazard pointer implementation and
changed bpf to use it to allow mpsafe access to bpfilters. however,
at s2k15 we were trying to apply it to other data structures but
the memory overhead of every hazard pointer would have blown out
significantly in several uses cases. a bulk of our time at s2k15
was spent reworking hazard pointers into srp.

this diff adds the srp api and adds the necessary metadata to struct
cpuinfo on our MP architectures. srp on uniprocessor platforms has
alternate code that is optimised because it knows there'll be no
concurrent access to data by multiple cpus.

srp is made available to the system via param.h, so it should be
available everywhere in the kernel.

the docs likely need improvement cos im too close to the implementation.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.86 2014/10/15 21:54:13 sebastia Exp $	*/
d132 7
@


1.86
log
@move CPU_BUSY_CYCLES define out of #ifdef/else MULTIPROCESSOR, its meant to
be for both cases.

OK ketennis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.85 2014/07/11 10:53:07 uebayasi Exp $	*/
d121 1
@


1.85
log
@CPU_BUSY_CYCLE(): A new MI statement for busy loop power reduction

The new CPU_BUSY_CYCLE() may be put in a busy loop body so that CPU can reduce
power consumption, as Linux's cpu_relax() and FreeBSD's cpu_spinwait().  To
start minimally, use PAUSE on i386/amd64 and empty on others.  The name is
chosen following the existing cpu_idle_*() functions.  Naming and API may be
polished later.

OK kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d209 2
a211 2

#endif
@


1.84
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.83 2013/05/31 17:00:59 tedu Exp $	*/
d208 2
@


1.83
log
@remove counters for simplelocks
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.82 2013/03/12 09:37:16 mpi Exp $	*/
d177 1
a177 1
	__asm __volatile("mov %%g7, %0" : "=r"(ci));
d267 1
a267 1
#define	 write_all_windows() __asm __volatile("flushw" : : )
@


1.82
log
@Fix kernel profiling on MP systems by using per-CPU buffers and teach
kgmon(8) to deal with them, this time without public header changes.

Previously various CPUs were iterating over the same global buffer at
the same time to modify it and never ended.

This diff includes some ideas submited by Thor Simon to NetBSD via miod@@.

ok deraadt@@, mikeb@@, haesbaert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.81 2013/02/12 08:06:22 mpi Exp $	*/
a130 4

	/* DEBUG/DIAGNOSTIC stuff */
	u_long			ci_spin_locks;	/* # of spin locks held */
	u_long			ci_simple_locks;/* # of simple locks held */
@


1.81
log
@Back out per-CPU kernel profiling, it shouldn't modify a public header
at this moment.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.80 2013/02/11 17:05:25 mpi Exp $	*/
d158 3
@


1.80
log
@Fix kernel profiling on MP systems by using per-CPU buffer. Previously
various CPUs were iterating over the same global buffer at the same
time to modify it and never ended.

This diff includes some ideas submited by Thor Simon to NetBSD via miod@@.

ok mikeb@@, haesbaert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.79 2012/12/02 07:03:31 guenther Exp $	*/
a157 3
#endif
#ifdef GPROF
	struct gmonparam *ci_gmon;
@


1.79
log
@Determine whether we're currently on the alternative signal stack
dynamically, by comparing the stack pointer against the altstack
base and size, so that you get the correct answer if you longjmp
out of the signal handler, as tested by regress/sys/kern/stackjmp/.
Also, fix alt stack handling on vax, where it was completely broken.

Testing and corrections by miod@@, krw@@, tobiasu@@, pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.78 2011/07/06 22:26:44 kettenis Exp $	*/
d158 3
@


1.78
log
@Handle pci_conf_read() faults on reading non-existent registers that result
in master aborts.  Return 0xffffffff to emulate what happens on non-perfect
architectures in that case.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.77 2011/06/24 19:47:49 naddy Exp $	*/
d241 1
@


1.77
log
@machdep.kbdreset enables a shutdown by Ctrl-Alt-Del on amd64 and
i386.  Stop abusing it on other archs for controling a shutdown by
pressing the soft power button:

* Add a MI sysctl hw.allowpowerdown; if set to 1 (the default) it
  allows a power button shutdown.
* Make acpi(4)/acpibtn(4) honor hw.allowpowerdown.
* Switch the various power button intercepts on landisk, sgi, sparc64
  and zaurus over to hw.allowpowerdown.
* Garbage collect the machdep.kbdreset sysctl on all archs other than
  amd64 and i386.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.76 2011/03/23 16:54:37 pirofti Exp $	*/
d152 3
@


1.76
log
@Normalize sentinel. Use _MACHINE_*_H_ and _<ARCH>_*_H_ properly and consitently.

Discussed and okay drahn@@. Okay deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.75 2010/12/21 14:56:24 claudio Exp $	*/
d50 1
d56 1
a56 1
#define	CPU_KBDRESET		7	/* soft reset via keyboard */
d67 1
a67 1
	{ "kbdreset", CTLTYPE_INT },		\
@


1.75
log
@Convert netisr to a normal soft interrupt instead of hanving MD code
for it. This makes the netisr a real C function which will help further
development. No noticable performance change on i386 and amd64.
With input from kettenis@@ and miod@@ additional OKs mikeb@@ and henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.74 2010/11/27 19:41:48 miod Exp $	*/
d44 2
a45 2
#ifndef _CPU_H_
#define _CPU_H_
d328 1
a328 1
#endif /* _CPU_H_ */
@


1.74
log
@Misaligned load/store recovery code in the kernel, enabled by T_FIXALIGN
userland traps on a per-process basis, were necessary for *some* SunOS
binaries on sparc, which had to compiled with explicit misaligned access code
generation (i.e. for vendors to release a working SunOS/sparc version of their
code until they could fix their bogus code).

There is no reason to keep this code on sparc64, and now that we don't provide
COMPAT_SUNOS anymore, there is no reason to keep this code on sparc.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.73 2010/09/28 20:27:55 miod Exp $	*/
a222 2

void setsoftnet(void);
@


1.73
log
@Implement a per-cpu held mutex counter if DIAGNOSTIC on all non-x86 platforms,
to complete matthew@@'s commit of a few days ago, and drop __HAVE_CPU_MUTEX_LEVEL
define. With help from, and ok deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.72 2009/03/26 17:24:33 oga Exp $	*/
a290 1
int	fixalign(struct proc *, struct trapframe64 *);
@


1.72
log
@Remove cpu_wait(). It's original use was to be called from the reaper so
MD code would free resources that couldn't be freed until we were no
longer running in that processor. However, it's is unused on all
architectures since mikeb@@'s tss changes on x86 earlier in the year.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.71 2009/01/23 19:16:39 kettenis Exp $	*/
d150 4
@


1.71
log
@Make write_user_windows() do what the name suggests: flush user windows instead
of all windows.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.70 2008/11/22 18:12:32 art Exp $	*/
a202 6

/*
 * definitions of cpu-dependent requirements
 * referenced in generic code
 */
#define	cpu_wait(p)	/* nothing */
@


1.70
log
@The last parts of cpu_unidle. i386, amd64 and sparc64
In short, make cpu_unidle do what signotify used to do and
make signotify use cpu_unidle.
Also, include a cpu_unidle in need_resched, it won't change much right now
but will be needed in the future.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.69 2008/10/15 23:23:50 deraadt Exp $	*/
d268 1
a268 1
#define	 write_user_windows() __asm __volatile("flushw" : : )
@


1.69
log
@make random(9) return per-cpu values (by saving the seed in the cpuinfo),
which are uniform for the profclock on each cpu in a SMP system (but using
a different seed for each cpu).  on all cpus, avoid seeding with a value out
of the [0, 2^31-1] range (since that is not stable)
ok kettenis drahn
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.68 2008/10/10 08:05:45 art Exp $	*/
d186 1
a186 1
void	smp_signotify(struct proc *);
d199 2
@


1.68
log
@Define MAXCPUS on all architectures.
For now, sparc64 is arbitrarily set to 256 (only architecture that didn't have
a practical limit in the code on the number of cpus).
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.67 2008/10/09 08:43:43 art Exp $	*/
d122 1
@


1.67
log
@Implement CPU_INFO_UNIT for everyone, not just MP kernels.
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.66 2008/08/10 14:13:05 kettenis Exp $	*/
d178 1
d197 1
@


1.66
log
@Use the STICK logic on UltraSPARC-IIe to generate clock interrupts.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.65 2008/08/07 21:25:48 kettenis Exp $	*/
d195 1
@


1.65
log
@Use %sys_tick to generate clock interrupts on systems that have it.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.64 2008/08/07 18:46:04 kettenis Exp $	*/
a252 2
int	tickintr(void *); /* level 10 (tick) interrupt code */
int	sys_tickintr(void *); /* level 10 (sys_tick) interrupt code */
a254 2
void	tick_start(void);
void	sys_tick_start(void);
@


1.64
log
@Give each CPU its own `struct intrhand' for %tick interrupts.  Fixes a
problem where the clock would stop ticking on some CPUs because of lost
ticks.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.63 2008/07/18 23:43:31 art Exp $	*/
d218 2
d254 1
d258 1
@


1.63
log
@Add a macro that clears the want_resched flag that need_resched sets.
Right now when mi_switch picks up the same proc, we didn't clear the
flag which would mean that every time we service an AST we would attempt
a context switch. For some architectures, amd64 being probably the
most extreme, that meant attempting to context switch for every
trap and interrupt.

Now we clear_resched explicitly after every context switch, even if it
didn't do anything. Which also allows us to remove some more code
in cpu_switchto (not done yet).

miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.62 2008/07/04 22:03:30 kettenis Exp $	*/
d128 1
@


1.62
log
@Change trapbase from a pointer to a variable-length array such that it can
actually be used to access trap vectors.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.61 2008/04/17 19:52:27 kettenis Exp $	*/
d226 1
@


1.61
log
@Really try to schedule clock ticks at fixed intervals.  Make sure hardclock()
gets called for every clock tick, even if we miss one.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.60 2008/04/13 16:32:55 kettenis Exp $	*/
d307 1
a307 1
extern struct trapvec *trapbase;	/* the 256 vectors */
@


1.60
log
@Use %g7 to store a pointer `struct cpu_info', and use it whereever possible.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.59 2008/03/31 22:14:01 kettenis Exp $	*/
d127 1
@


1.59
log
@Make MULTIPROCESSOR kernels work on sun4v.  Won't gracefully halt, powerdown
or reboot yet, but that will (hopefully) be fixed in the near future.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.58 2008/03/23 23:46:21 kettenis Exp $	*/
d165 1
a165 4
	if (CPU_ISSUN4V) {
		__asm __volatile("nop" : : : "memory");
		return (struct cpu_info *)ldxa(0, ASI_SCRATCHPAD);
	}
d167 2
a168 1
	return (((struct cpu_info *)CPUINFO_VA)->ci_self);
@


1.58
log
@Add code to initialize CPUs on sun4v.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.57 2008/03/17 23:10:21 kettenis Exp $	*/
d160 12
a171 1
#define	curcpu()	(((struct cpu_info *)CPUINFO_VA)->ci_self)
@


1.57
log
@Remove KGDB code.  It was never converted to 64-bit, and just makes locore.s
even more unreadable.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.56 2008/03/15 22:05:51 kettenis Exp $	*/
d136 12
@


1.56
log
@Make GENERIC.MP work on the e10k.  The e10k is a bit funky since UPA only
supports 32 ports, and a machine with up to 64 CPUs obviously needs more.
So the machine has a special ASIC that does port translation, and because
of that we need to distinguish between port ID's and interrupt target ID's.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.55 2008/02/20 09:44:47 robert Exp $	*/
a257 3
#ifdef KGDB
void zs_kgdb_init(void);
#endif
a261 6
/* kgdb_stub.c */
#ifdef KGDB
void kgdb_attach(int (*)(void *), void (*)(void *, int), void *);
void kgdb_connect(int);
void kgdb_panic(void);
#endif
@


1.55
log
@make tda(4) run the fans at maximum speed when we are about to drop
drop to ddb(4) in order to avoid overheating in case of a system crash.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.54 2008/02/18 10:37:20 robert Exp $	*/
d118 3
d219 2
@


1.54
log
@remove the definition of amd7930_trap(), it is not used anywhere.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.53 2008/01/19 17:42:05 kettenis Exp $	*/
d258 2
@


1.53
log
@Simplify CLKF_INTR by making it look at the saved interrupt level,
instead of the stack pointer.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.52 2007/10/31 22:46:52 kettenis Exp $	*/
a248 2
/* amd7930intr.s */
void	amd7930_trap(void);
@


1.52
log
@Overhaul fpu context save/restore code, making it more similar to what we do
on i386 and amd64.  Don't let IPIs in when saving fpu context by disabling
interrupts.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.51 2007/10/21 21:00:38 kettenis Exp $	*/
a181 1
 * Note that CLKF_INTR is valid only if CLKF_USERMODE is false.
a182 2
extern int intstack[];
extern int eintstack[];
d185 1
d190 1
a190 3
#define	CLKF_INTR(framep)	((!CLKF_USERMODE(framep))&&\
				(((framep)->t.tf_kstack < (vaddr_t)EINTSTACK)&&\
				((framep)->t.tf_kstack > (vaddr_t)INTSTACK)))
@


1.51
log
@Don't use next_tick() to start the clock ticking on secondary CPUs.  This
would fail from time to time on UltraSPARC-I and UltraSPARC-II CPUs.
Inspired by code in FreeBSD.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.50 2007/10/20 16:54:49 miod Exp $	*/
d251 2
a252 1
void	save_and_clear_fpstate(struct proc *);
@


1.50
log
@Make sure to send an ipi to the processor a given proc runs on in signotify(),
in the MULTIPROCESOR case.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.49 2007/10/18 20:44:47 kettenis Exp $	*/
d229 1
@


1.49
log
@Don't try to send IPIs to CPUs that aren't running (yet).
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.48 2007/10/16 19:22:49 kettenis Exp $	*/
d157 2
@


1.48
log
@Make lazy fpu context switching work for MULTIPROCESSOR kernels.  Tested by
many.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.47 2007/10/16 19:13:53 kettenis Exp $	*/
d116 1
d134 2
@


1.47
log
@Another cpu_switchto() leftover.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.46 2007/09/30 21:34:20 kettenis Exp $	*/
d228 1
d244 2
@


1.46
log
@Move intrpending array into 'struct cpu_info'.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.45 2007/09/09 14:59:37 kettenis Exp $	*/
a239 2
/* locore2.c */
void	remrq(struct proc *);
@


1.45
log
@Add a few missing bits to include/cpu.h required for MULTIPROCESSOR kernels.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.44 2007/09/09 12:57:40 kettenis Exp $	*/
d122 1
@


1.44
log
@Make fpproc per-cpu.  This turns fpproc into a macro, so adjust fpu/fpu.c
to avoid collisions.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.43 2007/09/09 08:55:26 kettenis Exp $	*/
d98 11
d117 1
d135 22
d164 1
a164 2
#define curpcb		curcpu()->ci_cpcb
#define fpproc		curcpu()->ci_fpproc
a170 5
#if 1
#define cpu_number()	0
#else
#define	cpu_number()	(curcpu()->ci_number)
#endif
d296 4
@


1.43
log
@Make handled_intr_level per-cpu.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.42 2007/09/08 17:13:17 kettenis Exp $	*/
d131 1
a184 7

/*
 * Only one process may own the FPU state.
 *
 * XXX this must be per-cpu (eventually)
 */
extern	struct proc *fpproc;	/* FPU owner */
@


1.42
log
@Make the ast on sparc64 per-process instead of global.  Necessary to make
signal delivery more reliable once we go smp (although the code for that
is still missing).

"in principle, this looks good" art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.41 2007/09/04 20:36:52 kettenis Exp $	*/
d109 1
@


1.41
log
@UltraSPARC CPUs always have an on-chip FPU.  There really is no need to have
the code to detect the various FPUs of earlier SPARC V7 and V8 CPUs.

ok deraadt@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.40 2007/05/14 21:38:08 kettenis Exp $	*/
d162 1
a162 1
extern	int want_ast;
d168 1
a168 1
#define	need_resched(ci)	(ci->ci_want_resched = 1, want_ast = 1)
d180 1
a180 1
#define	need_proftick(p)	do { want_ast = 1; } while (0)
d182 1
a182 5
/*
 * Notify the current process (p) that it has a signal pending,
 * process as soon as possible.
 */
#define	signotify(p)		(want_ast = 1)
@


1.40
log
@Move want_resched into struct cpu_info.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.39 2007/05/02 18:46:06 kettenis Exp $	*/
a193 1
extern	int foundfpu;		/* true => we have an FPU */
@


1.39
log
@Move sparc64 to __HAVE_CPUINFO.

ok miod@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.38 2007/03/15 10:22:30 art Exp $	*/
d108 2
d168 1
a168 2
extern	int want_resched;	/* resched() was called */
#define	need_resched(ci)	(want_resched = 1, want_ast = 1)
@


1.38
log
@Since p_flag is often manipulated in interrupts and without biglock
it's a good idea to use atomic.h operations on it. This mechanic
change updates all bit operations on p_flag to atomic_{set,clear}bits_int.

Only exception is that P_OWEUPC is set by MI code before calling
need_proftick and it's automatically cleared by ADDUPC. There's
no reason for MD handling of that flag since everyone handles it the
same way.

kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.37 2006/12/24 20:30:35 miod Exp $	*/
a118 1
extern struct cpu_info cpu_info_store;
a119 3
#if 1
#define	curcpu()	(&cpu_info_store)
#else
d121 7
a127 1
#endif
@


1.37
log
@Define PROC_PC. Then, since profiling information is being reported in
statclock(), do not bother doing this in userret() anymore. As a result,
userret() does not need its pc and ticks arguments, simplify.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.36 2006/11/29 12:26:14 miod Exp $	*/
d177 1
a177 1
#define	need_proftick(p)	((p)->p_flag |= P_OWEUPC, want_ast = 1)
@


1.36
log
@Remove cpu_swapin() and cpu_swapout(), they are no longer necessary (except
for cpu_swapin() on hppa* which is kept).
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.35 2006/06/21 21:53:32 jason Exp $	*/
d166 5
@


1.35
log
@add the machdep.kbdreset logic to sparc64 (stuff to use it is coming)
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.34 2006/02/22 22:17:07 miod Exp $	*/
a130 2
#define	cpu_swapin(p)	/* nothing */
#define	cpu_swapout(p)	/* nothing */
@


1.34
log
@Remove unused probeset() function.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.33 2005/11/11 16:50:19 miod Exp $	*/
d55 2
a56 1
#define	CPU_MAXID		7	/* number of valid machdep ids */
d66 1
@


1.33
log
@Remove machdep.booted_kernel sysctl of questionable usefulness.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.32 2005/09/21 21:08:35 miod Exp $	*/
a201 1
int	probeset(paddr_t, int, int, u_int64_t);
@


1.32
log
@isbad() is only used on SMD disks on sparc; remove it on other platforms.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.31 2005/04/26 18:54:38 miod Exp $	*/
a49 1
#define	CPU_BOOTED_KERNEL	1	/* string: booted kernel name */
d59 1
a59 1
	{ "booted_kernel", CTLTYPE_STRING },	\
@


1.31
log
@Remove unused hooks for periodic pcons polling.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.30 2004/10/01 18:18:49 jason Exp $	*/
a188 3
/* disksubr.c */
struct dkbad;
int isbad(struct dkbad *bt, int, int, int);
@


1.30
log
@add a blink_led API (shaves ~1k from GENERIC) rather than have the same
logic in 3 files.  Devices register a function to be called to turn the
led on and off based on load average. (Note: rerun config and make depend)
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.29 2004/08/09 10:13:21 miod Exp $	*/
a156 14
/*
 * Software interrupt request `register'.
 */
#ifdef DEPRECATED
union sir {
	int	sir_any;
	char	sir_which[4];
} sir;

#define SIR_NET		0
#define SIR_CLOCK	1
#endif

void setsoftint(void);
@


1.29
log
@Needs a non-empty pmap_unuse_final() as sparc.
Spotted by: art@@ No cookie for: deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.28 2004/06/21 23:12:14 art Exp $	*/
d281 8
@


1.28
log
@Put back the moving of schedstate_percpu into sched.h. This time expose
it to userland so that i386 builds (other architectures didn't show the
problem).

deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.27 2004/06/20 08:25:30 deraadt Exp $	*/
d235 1
a235 1
void	kill_user_windows(struct proc *);
@


1.27
log
@nope, tree breakage in libpthread.  too tough to run a make build?
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.25 2004/06/13 21:49:20 niklas Exp $	*/
d78 1
a78 1
#include <sys/proc.h>
@


1.26
log
@Move schedstate_percpu into sched.h so that we don't have to include
proc.h in cpu.h on __HAVE_CPU_INFO architectures. cpu.h is usually included
in param.h.

This also removes the horrible kludge with ifdef SYS_PROC_H in sched.h
by simply converting the inline functions into macros.

With a few suggestions from nordin@@

deraadt@@ ok
@
text
@d78 1
a78 1
#include <sys/sched.h>
@


1.25
log
@debranch SMP, have fun
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d78 1
a78 1
#include <sys/proc.h>
@


1.24
log
@- working emulation for POPC instruction
- good start are fully decoding LDQF(A)/STQF(A)
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.23 2003/07/09 23:56:16 jason Exp $	*/
d78 1
a78 27
/*#include <sys/sched.h> */

/*
 * CPU states.
 * XXX Not really scheduler state, but no other good place to put
 * it right now, and it really is per-CPU.
 */
#define CP_USER         0
#define CP_NICE         1
#define CP_SYS          2
#define CP_INTR         3
#define CP_IDLE         4
#define CPUSTATES       5
 
/*
 * Per-CPU scheduler state.
 */
struct schedstate_percpu {
	struct timeval spc_runtime;     /* time curproc started running */
	__volatile int spc_flags;       /* flags; see below */
	u_int spc_schedticks;           /* ticks for schedclock() */
	u_int64_t spc_cp_time[CPUSTATES]; /* CPU state statistics */
	u_char spc_curpriority;         /* usrpri of curproc */
	int spc_rrticks;                /* ticks until roundrobin() */
	int spc_pscnt;			/* prof/stat counter */
	int spc_psdiv;			/* prof/stat divisor */
};
d180 1
a180 1
#define	need_resched()		(want_resched = 1, want_ast = 1)
@


1.23
log
@part of infrastructure to deal with emulated stqf/ldqf:
T_ILLINST handler fetches instruction and decodes it.  If it's stqf, ldqf,
stqfa, or ldqfa call emulation instead of SIGILL directly.
Note: this still SIGILL's in the end, the emulation isn't done yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.22 2003/06/24 21:54:39 henric Exp $	*/
d283 2
a284 1
int	emul_qf(int32_t, struct proc *, union sigval);
@


1.22
log
@Add a "where" argument to the sparc64 interrupt code.  This lets us
associate a name with each interrupt handler.  This is not visible
outside the kernel (yet).

ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.21 2003/06/02 23:27:56 millert Exp $	*/
d283 1
@


1.21
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.20 2003/05/16 22:14:13 henric Exp $	*/
a76 1
#include <sparc64/sparc64/intreg.h>
a195 6
extern struct intrhand soft01intr, soft01net, soft01clock;

#if 0
#define setsoftint()	send_softint(-1, IPL_SOFTINT, &soft01intr)
#define setsoftnet()	send_softint(-1, IPL_SOFTNET, &soft01net)
#else
a197 1
#endif
a228 23
/*
 * Interrupt handler chains.  Interrupt handlers should return 0 for
 * ``not me'' or 1 (``I took care of it'').  intr_establish() inserts a
 * handler into the list.  The handler is called with its (single)
 * argument, or with a pointer to a clockframe if ih_arg is NULL.
 */
struct intrhand {
	int			(*ih_fun)(void *);
	void			*ih_arg;
	short			ih_number;	/* interrupt number */
						/* the H/W provides */
	char			ih_pil;		/* interrupt priority */
	volatile char		ih_busy;	/* handler is on list */
	struct intrhand		*ih_next;	/* global list */
	struct intrhand		*ih_pending;	/* pending list */
	volatile u_int64_t	*ih_map;	/* Interrupt map reg */
	volatile u_int64_t	*ih_clr;	/* clear interrupt reg */
};
extern struct intrhand *intrhand[];
extern struct intrhand *intrlev[MAXINTNUM];

void	intr_establish(int level, struct intrhand *);

a246 4
#if 0
void	write_all_windows(void);
void	write_user_windows(void);
#else
a248 1
#endif
@


1.20
log
@Clean up low-level sparc register access wrappers.  Specify clobbers for
everything (so gcc doesn't assume everything is clobbered).

ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.19 2003/03/21 22:59:09 jason Exp $	*/
d25 1
a25 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.19
log
@install a real handler for correctable ECC errors and make a count of
them available via sysctl (doc update in a bit); ok millert.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.18 2003/03/20 23:05:30 henric Exp $	*/
d77 1
@


1.18
log
@The current code tries to use the same field in the interrupt handler as
both a "next" pointer for a singly-linked list and as an in-use flag.
This obviously does not work all that well.  This change adds a separate
ih_busy flag to mark the handler as in-use, leaving ih_pending for use by
the list code.

Testing by *many* (thanks).

ok miod jason
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.17 2003/02/12 06:32:59 jason Exp $	*/
d57 4
a60 2
#define CPU_CPUTYPE		4	/* cpu type */
#define	CPU_MAXID		5	/* number of valid machdep ids */
d68 2
@


1.17
log
@Kill more commons in sparc64 code
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.16 2003/02/10 10:47:58 jason Exp $	*/
d248 1
d250 1
a250 1
	struct intrhand		*ih_pending;	/* interrupt queued */
@


1.16
log
@fix sparc64 specific commons
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.15 2002/08/02 04:22:04 jason Exp $	*/
d206 1
a206 1
int	want_ast;
d212 1
a212 1
int	want_resched;		/* resched() was called */
@


1.15
log
@add string for cputype (bad art =)
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.14 2002/08/02 04:17:05 jason Exp $	*/
d233 2
a234 2
struct	proc *fpproc;		/* FPU owner */
int	foundfpu;		/* true => we have an FPU */
@


1.14
log
@whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.13 2002/06/14 04:17:59 art Exp $	*/
d65 1
@


1.13
log
@support for getting the cpu type through sysctl, same as on sparc.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.12 2002/06/11 10:57:51 art Exp $	*/
d64 1
a64 1
	{ "allowaperture", CTLTYPE_INT },		\
@


1.12
log
@nuke unused stuff
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.11 2002/06/07 21:33:43 nordin Exp $	*/
d57 2
a58 1
#define	CPU_MAXID		4	/* number of valid machdep ids */
@


1.11
log
@Remove obsolete CLKF_BASEPRI(). ok niklas@@, miod@@ and art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.10 2002/03/27 15:12:22 jason Exp $	*/
a255 3
/* cpu.c */
paddr_t cpu_alloc(void);
u_int64_t cpu_init(paddr_t, int);
@


1.10
log
@Need APERTURE so we can read/write pci configuration with securelevel > 0
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.9 2002/03/14 03:16:00 millert Exp $	*/
a175 1
#define	CLKF_BASEPRI(framep)	(((framep)->t.tf_oldpil) == 0)
@


1.9
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.8 2002/03/14 01:26:45 millert Exp $	*/
d56 2
a57 1
#define	CPU_MAXID		3	/* number of valid machdep ids */
d63 1
@


1.8
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.7 2002/02/01 21:48:23 jason Exp $	*/
d302 1
a302 1
void zsconsole __P((struct tty *, int, int, void (**)(struct tty *, int)));
d310 1
a310 1
void kgdb_attach __P((int (*)(void *), void (*)(void *, int), void *));
@


1.7
log
@Clean up auxio a bit and add machdep.led_blink sysctl (like sparc),
portions from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.6 2001/11/06 18:41:10 art Exp $	*/
d134 1
a134 1
	void			(*ci_spinup) __P((void)); /* spinup routine */
d199 2
a200 2
void setsoftint __P((void));
void setsoftnet __P((void));
d240 1
a240 1
	int			(*ih_fun) __P((void *));
d253 1
a253 1
void	intr_establish __P((int level, struct intrhand *));
d256 2
a257 2
paddr_t cpu_alloc __P((void));
u_int64_t cpu_init __P((paddr_t, int));
d260 1
a260 1
int isbad __P((struct dkbad *bt, int, int, int));
d262 3
a264 3
int	ldcontrolb __P((caddr_t));
void	dumpconf __P((void));
caddr_t	reserve_dumppages __P((caddr_t));
d267 3
a269 3
int	tickintr __P((void *)); /* level 10 (tick) interrupt code */
int	clockintr __P((void *));/* level 10 (clock) interrupt code */
int	statintr __P((void *));	/* level 14 (statclock) interrupt code */
d272 4
a275 4
void	savefpstate __P((struct fpstate64 *));
void	loadfpstate __P((struct fpstate64 *));
u_int64_t	probeget __P((paddr_t, int, int));
int	probeset __P((paddr_t, int, int, u_int64_t));
d277 2
a278 2
void	write_all_windows __P((void));
void	write_user_windows __P((void));
d283 1
a283 1
void 	proc_trampoline __P((void));
d285 7
a291 7
void	snapshot __P((struct pcb *));
struct frame *getfp __P((void));
int	xldcontrolb __P((caddr_t, struct pcb *));
void	copywords __P((const void *, void *, size_t));
void	qcopy __P((const void *, void *, size_t));
void	qzero __P((void *, size_t));
void	switchtoctx __P((int));
d293 1
a293 1
void	remrq __P((struct proc *));
d295 2
a296 2
void	kill_user_windows __P((struct proc *));
int	rwindow_save __P((struct proc *));
d298 1
a298 1
void	amd7930_trap __P((void));
d300 1
a300 1
int	cnrom __P((void));
d304 1
a304 1
void zs_kgdb_init __P((void));
d307 1
a307 1
void	fb_unblank __P((void));
d311 2
a312 2
void kgdb_connect __P((int));
void kgdb_panic __P((void));
d315 2
a316 2
int	fixalign __P((struct proc *, struct trapframe64 *));
int	emulinstr __P((vaddr_t, struct trapframe64 *));
d337 2
a338 2
extern void wzero __P((void *, u_int));
extern void wcopy __P((const void *, void *, u_int));
@


1.6
log
@Let fork1, uvm_fork, and cpu_fork take a function/argument pair as argument,
instead of doing fork1, cpu_set_kpc. This lets us retire cpu_set_kpc and
avoid a multiprocessor race.

This commit breaks vax because it doesn't look like any other arch, someone
working on vax might want to look at this and try to adapt the code to be
more like the rest of the world.

Idea and uvm parts from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.5 2001/09/04 15:19:16 jason Exp $	*/
d55 2
a56 1
#define	CPU_MAXID		2	/* number of valid machdep ids */
d61 1
@


1.6.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.6 2001/11/06 18:41:10 art Exp $	*/
d55 1
a55 3
#define	CPU_LED_BLINK		2	/* int: blink leds? */
#define	CPU_ALLOWAPERTURE	3	/* allow xf86 operations */
#define	CPU_MAXID		4	/* number of valid machdep ids */
a59 2
	{ "led_blink", CTLTYPE_INT },		\
	{ "allowaperture", CTLTYPE_INT },		\
d132 1
a132 1
	void			(*ci_spinup)(void); /* spinup routine */
d172 1
d197 2
a198 2
void setsoftint(void);
void setsoftnet(void);
d238 1
a238 1
	int			(*ih_fun)(void *);
d251 1
a251 1
void	intr_establish(int level, struct intrhand *);
d254 2
a255 2
paddr_t cpu_alloc(void);
u_int64_t cpu_init(paddr_t, int);
d258 1
a258 1
int isbad(struct dkbad *bt, int, int, int);
d260 3
a262 3
int	ldcontrolb(caddr_t);
void	dumpconf(void);
caddr_t	reserve_dumppages(caddr_t);
d265 3
a267 3
int	tickintr(void *); /* level 10 (tick) interrupt code */
int	clockintr(void *);/* level 10 (clock) interrupt code */
int	statintr(void *);	/* level 14 (statclock) interrupt code */
d270 4
a273 4
void	savefpstate(struct fpstate64 *);
void	loadfpstate(struct fpstate64 *);
u_int64_t	probeget(paddr_t, int, int);
int	probeset(paddr_t, int, int, u_int64_t);
d275 2
a276 2
void	write_all_windows(void);
void	write_user_windows(void);
d281 1
a281 1
void 	proc_trampoline(void);
d283 7
a289 7
void	snapshot(struct pcb *);
struct frame *getfp(void);
int	xldcontrolb(caddr_t, struct pcb *);
void	copywords(const void *, void *, size_t);
void	qcopy(const void *, void *, size_t);
void	qzero(void *, size_t);
void	switchtoctx(int);
d291 1
a291 1
void	remrq(struct proc *);
d293 2
a294 2
void	kill_user_windows(struct proc *);
int	rwindow_save(struct proc *);
d296 1
a296 1
void	amd7930_trap(void);
d298 1
a298 1
int	cnrom(void);
d300 1
a300 1
void zsconsole(struct tty *, int, int, void (**)(struct tty *, int));
d302 1
a302 1
void zs_kgdb_init(void);
d305 1
a305 1
void	fb_unblank(void);
d308 3
a310 3
void kgdb_attach(int (*)(void *), void (*)(void *, int), void *);
void kgdb_connect(int);
void kgdb_panic(void);
d313 2
a314 2
int	fixalign(struct proc *, struct trapframe64 *);
int	emulinstr(vaddr_t, struct trapframe64 *);
d335 2
a336 2
extern void wzero(void *, u_int);
extern void wcopy(const void *, void *, u_int);
@


1.6.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.6.2.1 2002/06/11 03:38:43 art Exp $	*/
d57 1
a57 2
#define CPU_CPUTYPE		4	/* cpu type */
#define	CPU_MAXID		5	/* number of valid machdep ids */
d63 1
a63 2
	{ "allowaperture", CTLTYPE_INT },	\
	{ "cputype", CTLTYPE_INT },		\
d256 3
@


1.6.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d57 2
a58 4
#define	CPU_CPUTYPE		4	/* cpu type */
#define	CPU_CECCERRORS		5	/* Correctable ECC errors */
#define	CPU_CECCLAST		6	/* Correctable ECC last fault addr */
#define	CPU_MAXID		7	/* number of valid machdep ids */
a65 2
	{ "ceccerrs", CTLTYPE_INT },		\
	{ "cecclast", CTLTYPE_QUAD },		\
a72 1
#include <machine/ctlreg.h>
d206 1
a206 1
extern	int want_ast;
d212 1
a212 1
extern	int want_resched;	/* resched() was called */
d233 2
a234 2
extern	struct proc *fpproc;	/* FPU owner */
extern	int foundfpu;		/* true => we have an FPU */
a247 1
	volatile char		ih_busy;	/* handler is on list */
d249 1
a249 1
	struct intrhand		*ih_pending;	/* pending list */
@


1.5
log
@Don't explicitly size the intrhand array in the extern declaration (from netbsd)
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.4 2001/08/19 05:12:47 art Exp $	*/
a294 1
void	child_return __P((struct proc *));
@


1.5.4.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.5.4.2
log
@Merge in -current
@
text
@d295 1
@


1.5.4.3
log
@Merge in trunk
@
text
@d55 1
a55 2
#define	CPU_LED_BLINK		2	/* int: blink leds? */
#define	CPU_MAXID		3	/* number of valid machdep ids */
a59 1
	{ "led_blink", CTLTYPE_INT },		\
@


1.5.4.4
log
@Merge in -current from about a week ago
@
text
@d134 1
a134 1
	void			(*ci_spinup)(void); /* spinup routine */
d199 2
a200 2
void setsoftint(void);
void setsoftnet(void);
d240 1
a240 1
	int			(*ih_fun)(void *);
d253 1
a253 1
void	intr_establish(int level, struct intrhand *);
d256 2
a257 2
paddr_t cpu_alloc(void);
u_int64_t cpu_init(paddr_t, int);
d260 1
a260 1
int isbad(struct dkbad *bt, int, int, int);
d262 3
a264 3
int	ldcontrolb(caddr_t);
void	dumpconf(void);
caddr_t	reserve_dumppages(caddr_t);
d267 3
a269 3
int	tickintr(void *); /* level 10 (tick) interrupt code */
int	clockintr(void *);/* level 10 (clock) interrupt code */
int	statintr(void *);	/* level 14 (statclock) interrupt code */
d272 4
a275 4
void	savefpstate(struct fpstate64 *);
void	loadfpstate(struct fpstate64 *);
u_int64_t	probeget(paddr_t, int, int);
int	probeset(paddr_t, int, int, u_int64_t);
d277 2
a278 2
void	write_all_windows(void);
void	write_user_windows(void);
d283 1
a283 1
void 	proc_trampoline(void);
d285 7
a291 7
void	snapshot(struct pcb *);
struct frame *getfp(void);
int	xldcontrolb(caddr_t, struct pcb *);
void	copywords(const void *, void *, size_t);
void	qcopy(const void *, void *, size_t);
void	qzero(void *, size_t);
void	switchtoctx(int);
d293 1
a293 1
void	remrq(struct proc *);
d295 2
a296 2
void	kill_user_windows(struct proc *);
int	rwindow_save(struct proc *);
d298 1
a298 1
void	amd7930_trap(void);
d300 1
a300 1
int	cnrom(void);
d302 1
a302 1
void zsconsole(struct tty *, int, int, void (**)(struct tty *, int));
d304 1
a304 1
void zs_kgdb_init(void);
d307 1
a307 1
void	fb_unblank(void);
d310 3
a312 3
void kgdb_attach(int (*)(void *), void (*)(void *, int), void *);
void kgdb_connect(int);
void kgdb_panic(void);
d315 2
a316 2
int	fixalign(struct proc *, struct trapframe64 *);
int	emulinstr(vaddr_t, struct trapframe64 *);
d337 2
a338 2
extern void wzero(void *, u_int);
extern void wcopy(const void *, void *, u_int);
@


1.5.4.5
log
@Sync the SMP branch with 3.3
@
text
@d56 1
a56 5
#define	CPU_ALLOWAPERTURE	3	/* allow xf86 operations */
#define	CPU_CPUTYPE		4	/* cpu type */
#define	CPU_CECCERRORS		5	/* Correctable ECC errors */
#define	CPU_CECCLAST		6	/* Correctable ECC last fault addr */
#define	CPU_MAXID		7	/* number of valid machdep ids */
a61 4
	{ "allowaperture", CTLTYPE_INT },	\
	{ "cputype", CTLTYPE_INT },		\
	{ "ceccerrs", CTLTYPE_INT },		\
	{ "cecclast", CTLTYPE_QUAD },		\
d174 1
d203 1
a203 1
extern	int want_ast;
d209 1
a209 1
extern	int want_resched;	/* resched() was called */
d230 2
a231 2
extern	struct proc *fpproc;	/* FPU owner */
extern	int foundfpu;		/* true => we have an FPU */
a244 1
	volatile char		ih_busy;	/* handler is on list */
d246 1
a246 1
	struct intrhand		*ih_pending;	/* pending list */
d255 3
@


1.5.4.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.5.4.5 2003/03/27 23:42:36 niklas Exp $	*/
d25 5
a29 1
 * 3. Neither the name of the University nor the names of its contributors
a76 1
#include <machine/ctlreg.h>
@


1.5.4.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d77 1
d197 6
d205 1
d237 23
d278 4
d284 1
a318 2
int	emul_qf(int32_t, struct proc *, union sigval, struct trapframe64 *);
int	emul_popc(int32_t, struct proc *, union sigval, struct trapframe64 *);
@


1.5.4.8
log
@need_resched macro needs to take ci arg to be compat with MP function
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.5.4.7 2004/02/19 10:50:00 niklas Exp $	*/
d206 1
a206 1
#define	need_resched(ci)	(want_resched = 1, want_ast = 1)
@


1.5.4.9
log
@sched.h and proc.h contain a weird dependency; but sparc64 needs an
actual defn of schedstate_percpu, so put it in proc.h instead
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.5.4.8 2004/06/06 05:23:39 tedu Exp $	*/
d78 27
a104 1
#include <sys/proc.h>
@


1.4
log
@proto for child_return
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.3 2001/08/18 20:20:09 art Exp $	*/
d248 1
a248 1
extern struct intrhand *intrhand[15];
@


1.3
log
@ - Don't include sys/sched.h for now.
 - Our need_resched doesn't take an argument.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.2 2001/08/18 15:27:30 art Exp $	*/
d295 1
@


1.2
log
@Get rid of the opt_ PITA.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.1.1.1 2001/08/18 04:16:40 jason Exp $	*/
d72 1
a72 1
#include <sys/sched.h>
d208 1
a208 1
#define	need_resched(ci)	(want_resched = 1, want_ast = 1)
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a65 5

#if !defined(_LKM)
#include "opt_multiprocessor.h"
#include "opt_lockdebug.h"
#endif
@


1.1.1.1
log
@Enough of NetBSD/sparc64 to get compilable/working bootblk... more to come.
@
text
@@
