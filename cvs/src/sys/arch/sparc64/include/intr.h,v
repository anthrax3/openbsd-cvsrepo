head	1.20;
access;
symbols
	OPENBSD_6_2:1.20.0.2
	OPENBSD_6_2_BASE:1.20
	OPENBSD_6_1:1.20.0.4
	OPENBSD_6_1_BASE:1.20
	OPENBSD_6_0:1.19.0.2
	OPENBSD_6_0_BASE:1.19
	OPENBSD_5_9:1.18.0.2
	OPENBSD_5_9_BASE:1.18
	OPENBSD_5_8:1.16.0.12
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.16.0.4
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.16.0.8
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.16.0.6
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.16.0.2
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.14.0.8
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.6
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.4
	OPENBSD_5_0:1.14.0.2
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.12.0.12
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.12.0.10
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.6
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.12.0.8
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.12.0.4
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.12.0.2
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.9.0.2
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.8.0.14
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.12
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.10
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.8
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.6
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.4
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8
	SMP_SYNC_A:1.6
	SMP_SYNC_B:1.6
	OPENBSD_3_5:1.6.0.4
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.2
	OPENBSD_3_4_BASE:1.6
	UBC_SYNC_A:1.5
	OPENBSD_3_3:1.5.0.4
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.3.0.2
	OPENBSD_3_1_BASE:1.3
	UBC_SYNC_B:1.5
	UBC:1.1.0.4
	UBC_BASE:1.1
	SMP:1.1.0.2
	OPENBSD_3_0:1.1.1.1.0.2
	OPENBSD_3_0_BASE:1.1.1.1
	SPARC64:1.1.1.1
	NETBSD:1.1.1;
locks; strict;
comment	@ * @;


1.20
date	2016.08.17.10.49.09;	author dlg;	state Exp;
branches;
next	1.19;
commitid	CHLHnJl03NYMvtN5;

1.19
date	2016.06.13.01.08.13;	author dlg;	state Exp;
branches;
next	1.18;
commitid	xgGjlZUxf6R8Dc1y;

1.18
date	2015.09.27.11.29.20;	author kettenis;	state Exp;
branches;
next	1.17;
commitid	Um3BvP4zKyWaKQpf;

1.17
date	2015.09.13.11.47.59;	author kettenis;	state Exp;
branches;
next	1.16;
commitid	Dakou02Cw7MmHVO0;

1.16
date	2013.05.17.18.26.37;	author kettenis;	state Exp;
branches;
next	1.15;

1.15
date	2013.05.13.17.46.42;	author kettenis;	state Exp;
branches;
next	1.14;

1.14
date	2011.03.23.17.02.33;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2011.03.23.16.54.37;	author pirofti;	state Exp;
branches;
next	1.12;

1.12
date	2008.06.26.05.42.13;	author ray;	state Exp;
branches;
next	1.11;

1.11
date	2008.04.28.18.55.39;	author kettenis;	state Exp;
branches;
next	1.10;

1.10
date	2008.03.12.20.52.36;	author kettenis;	state Exp;
branches;
next	1.9;

1.9
date	2008.02.14.19.07.56;	author kettenis;	state Exp;
branches;
next	1.8;

1.8
date	2004.06.28.01.47.41;	author aaron;	state Exp;
branches;
next	1.7;

1.7
date	2004.06.23.01.17.01;	author aaron;	state Exp;
branches;
next	1.6;

1.6
date	2003.06.24.21.54.39;	author henric;	state Exp;
branches;
next	1.5;

1.5
date	2002.06.11.05.01.17;	author art;	state Exp;
branches;
next	1.4;

1.4
date	2002.05.21.16.15.53;	author art;	state Exp;
branches;
next	1.3;

1.3
date	2002.03.14.03.16.00;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2002.03.14.01.26.45;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2001.08.18.04.16.40;	author jason;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.4.1;
next	;

1.1.1.1
date	2001.08.18.04.16.40;	author jason;	state Exp;
branches;
next	;

1.1.2.1
date	2001.10.31.03.07.58;	author nate;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2002.03.28.11.23.52;	author niklas;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2003.03.27.23.42.36;	author niklas;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2004.02.19.10.50.00;	author niklas;	state Exp;
branches;
next	;

1.1.4.1
date	2002.06.11.03.38.43;	author art;	state Exp;
branches;
next	1.1.4.2;

1.1.4.2
date	2002.10.29.00.28.11;	author art;	state Exp;
branches;
next	;


desc
@@


1.20
log
@we have some spare interrupt levels, so move softnet above softclock.

ok kettenis@@
@
text
@/*	$OpenBSD: intr.h,v 1.19 2016/06/13 01:08:13 dlg Exp $	*/
/*	$NetBSD: intr.h,v 1.8 2001/01/14 23:50:30 thorpej Exp $ */

/*-
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Paul Kranenburg.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef _MACHINE_INTR_H_
#define _MACHINE_INTR_H_

#include <sparc64/sparc64/intreg.h>

#include <sys/evcount.h>

/*
 * Interrupt handler chains.  Interrupt handlers should return 0 for
 * ``not me'' or 1 (``I took care of it'').  intr_establish() inserts a
 * handler into the list.  The handler is called with its (single)
 * argument, or with a pointer to a clockframe if ih_arg is NULL.
 */
struct intrhand {
	int			(*ih_fun)(void *);
	void			*ih_arg;
	short			ih_number;	/* interrupt number */
						/* the H/W provides */
	char			ih_pil;		/* interrupt priority */
	char			ih_mpsafe;
	struct intrhand		*ih_next;	/* global list */
	struct intrhand		*ih_pending;	/* pending list */
	volatile u_int64_t	*ih_map;	/* interrupt map reg */
	volatile u_int64_t	*ih_clr;	/* clear interrupt reg */
	void			(*ih_ack)(struct intrhand *);
	struct evcount		ih_count;	/* # of interrupts */
	const void		*ih_bus;	/* parent bus */
	struct cpu_info		*ih_cpu;	/* target */
	char			ih_name[32];	/* device name */
};

extern struct intrhand *intrlev[MAXINTNUM];

void    intr_establish(int, struct intrhand *);

/* XXX - arbitrary numbers; no interpretation is defined yet */
#define	IPL_NONE	0		/* nothing */
#define	IPL_SOFTINT	1		/* softint */
#define	IPL_SOFTCLOCK	1		/* timeouts */
#define	IPL_SOFTNET	2		/* protocol stack */
#define	IPL_BIO		PIL_BIO		/* block I/O */
#define	IPL_NET		PIL_NET		/* network */
#define	IPL_SOFTTTY	4		/* delayed terminal handling */
#define	IPL_TTY		PIL_TTY		/* terminal */
#define	IPL_VM		PIL_VM		/* memory allocation */
#define	IPL_AUDIO	PIL_AUD		/* audio */
#define	IPL_CLOCK	PIL_CLOCK	/* clock */
#define	IPL_SERIAL	PIL_SER		/* serial */
#define	IPL_SCHED	PIL_SCHED	/* scheduler */
#define	IPL_LOCK	PIL_LOCK	/* locks */
#define	IPL_STATCLOCK	PIL_STATCLOCK	/* statclock */
#define	IPL_HIGH	PIL_HIGH	/* everything */

#define spl0()		_spl(IPL_NONE)
#define splsoftclock()	_splraise(IPL_SOFTCLOCK)
#define splsoftnet()	_splraise(IPL_SOFTNET)
#define splbio()	_splraise(IPL_BIO)
#define splnet()	_splraise(IPL_NET)
#define splsofttty()	_splraise(IPL_SOFTTTY)
#define spltty()	_splraise(IPL_TTY)
#define splvm()		_splraise(IPL_VM)
#define splaudio()	_splraise(IPL_AUDIO)
#define splclock()	_splraise(IPL_CLOCK)
#define splserial()	_splraise(IPL_SERIAL)
#define splsched()	_splraise(IPL_SCHED)
#define spllock()	_splraise(IPL_LOCK)
#define splstatclock()	_splraise(IPL_STATCLOCK)
#define splhigh()	_splraise(IPL_HIGH)
#define splx(_oldipl)	_splx(_oldipl)

#define splzs()		splserial()

#define	IPL_MPSAFE	0x100

int	 splraise(int);
void	 intr_barrier(void *);

void	*softintr_establish(int, void (*)(void *), void *);
void	 softintr_disestablish(void *);
void	 softintr_schedule(void *);

#endif /* _MACHINE_INTR_H_ */
@


1.19
log
@rework sparc64 splfoo functions to be more consistent with other archs

this also moves us toward having an MI splraise().

sparc64 (and sparc) are different to the other archs because they
have macros that build templates. each spl uses that macro to create
an instance of an inline function specific to that spl call.

this moves it to having a single splraise inline that the spl api is
defined with. eg, #define splfoo() _splraise(IPL_FOO).

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.18 2015/09/27 11:29:20 kettenis Exp $	*/
d72 1
a72 1
#define	IPL_SOFTNET	1		/* protocol stack */
a86 1
#define splsoftint()	_splraise(IPL_SOFTINT)
@


1.18
log
@Store the target CPU in "struct intrhand" and use it in intr_barrier().
Also use it wherever we configure the hardware to direct interrupts to the
right CPU.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.17 2015/09/13 11:47:59 kettenis Exp $	*/
d86 20
d108 1
@


1.17
log
@Introduce intr_barrier(4), an interface that guarantees that an interrupt
handler that was running has finished.

ok miod@@, guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.16 2013/05/17 18:26:37 kettenis Exp $	*/
d60 1
@


1.16
log
@Implement IPL_MPSAFE for pci bus interrupt handlers.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.15 2013/05/13 17:46:42 kettenis Exp $	*/
d86 2
@


1.15
log
@Implement support for running interrupt handlers without taking the kernel
lock, by adding a new BUS_INTR_ESTABLISH_MPSAFE flag for use with the
(sparc64-specific) bus_intr_establish(9) interface.  Add support for this
flag to schizo(4); other bus drivers will ignore it for now.  While there,
remove the BUS_INTR_ESTABLISH_FASTTRAP flag which serves no purpose.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.14 2011/03/23 17:02:33 deraadt Exp $	*/
d82 1
a82 1
#define IPL_STATCLOCK	PIL_STATCLOCK	/* statclock */
d84 2
@


1.14
log
@Including <sparc64/intreg.h> here is ugly, but intr.h only comes from
<machine/cpu.h> if _KERNEL is defined.  The bootblocks are stupid, and
for now they need this.  We need more namespace cleanup, for sure.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.13 2011/03/23 16:54:37 pirofti Exp $	*/
d52 1
@


1.13
log
@Normalize sentinel. Use _MACHINE_*_H_ and _<ARCH>_*_H_ properly and consitently.

Discussed and okay drahn@@. Okay deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.12 2008/06/26 05:42:13 ray Exp $	*/
a35 1
#ifndef _MACHINE_INTR_H_
a36 1
#endif
@


1.12
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.11 2008/04/28 18:55:39 kettenis Exp $	*/
d33 2
a34 2
#ifndef _SPARC64_INTR_H_
#define _SPARC64_INTR_H_
d36 1
a36 1
#ifndef _SPARC64_INTREG_H_
d90 1
a90 1
#endif /* _SPARC64_INTR_H_ */
@


1.11
log
@Rename IPL_SOFTSERIAL to IPL_SOFTTTY.  Sprinkle some KNF while I'm there.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.10 2008/03/12 20:52:36 kettenis Exp $	*/
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.10
log
@Introduce a per-handler interrupt acknowledgement function.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.9 2008/02/14 19:07:56 kettenis Exp $	*/
d82 1
a82 1
#define	IPL_SOFTSERIAL	4		/* serial */
d93 3
a95 8
void *
softintr_establish(int level, void (*fun)(void *), void *arg);

void
softintr_disestablish(void *cookie);

void
softintr_schedule(void *cookie);
@


1.9
log
@Make sure an interrupt handler does not get on the per-cpu list of pending
interrupts twice, with one exception: interrupt handlers are allowed to be on
the tail of said lists (needed for clock interrupts on MP kernels).
Prevents losing interrupts.  Makes usb keyboard as console work on Sun Blade
1000/2000 with MP kernels.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.8 2004/06/28 01:47:41 aaron Exp $	*/
d65 1
@


1.8
log
@Use new event counter API for interrupt counting on sparc64.  deraadt@@ tholo@@
drahn@@ millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.7 2004/06/23 01:17:01 aaron Exp $	*/
a60 1
	volatile char		ih_busy;	/* handler is on list */
@


1.7
log
@tabs vs spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.6 2003/06/24 21:54:39 henric Exp $	*/
d47 2
d66 1
a66 1
	u_int64_t		ih_count;	/* # of interrupts */
d68 1
a68 1
	char			ih_name[1];	/* device name */
@


1.6
log
@Add a "where" argument to the sparc64 interrupt code.  This lets us
associate a name with each interrupt handler.  This is not visible
outside the kernel (yet).

ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.5 2002/06/11 05:01:17 art Exp $	*/
d54 13
a66 13
        int                     (*ih_fun)(void *);
        void                    *ih_arg;
        short                   ih_number;      /* interrupt number */
                                                /* the H/W provides */
        char                    ih_pil;         /* interrupt priority */
        volatile char           ih_busy;        /* handler is on list */
        struct intrhand         *ih_next;       /* global list */
        struct intrhand         *ih_pending;    /* pending list */
        volatile u_int64_t      *ih_map;        /* interrupt map reg */
        volatile u_int64_t      *ih_clr;        /* clear interrupt reg */
        u_int64_t               ih_count;       /* # of interrupts */
        const void              *ih_bus;        /* parent bus */
        char                    ih_name[1];     /* device name */
@


1.5
log
@define IPL_STATCLOCK.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.4 2002/05/21 16:15:53 art Exp $	*/
d40 33
d99 2
@


1.4
log
@Implement splassert just like it's on sparc.
This also requires a change to rename {PIL,IPL}_IMP to {PIL,IPL}_VM.
XXX - We should get rid of PIL_*.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.3 2002/03/14 03:16:00 millert Exp $	*/
d55 1
@


1.3
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.2 2002/03/14 01:26:45 millert Exp $	*/
d49 1
a49 1
#define	IPL_IMP		PIL_IMP		/* memory allocation */
@


1.2
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.1 2001/08/18 04:16:40 jason Exp $	*/
d58 1
a58 1
softintr_establish __P((int level, void (*fun)(void *), void *arg));
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d61 1
a61 1
softintr_disestablish __P((void *cookie));
d64 1
a64 1
softintr_schedule __P((void *cookie));
@


1.1.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.1 2001/08/18 04:16:40 jason Exp $	*/
d49 1
a49 1
#define	IPL_VM		PIL_VM		/* memory allocation */
d58 1
a58 1
softintr_establish(int level, void (*fun)(void *), void *arg);
d61 1
a61 1
softintr_disestablish(void *cookie);
d64 1
a64 1
softintr_schedule(void *cookie);
@


1.1.4.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.1.4.1 2002/06/11 03:38:43 art Exp $	*/
a54 1
#define IPL_STATCLOCK	PIL_STATCLOCK	/* statclock */
@


1.1.2.1
log
@Sync the SMP branch to something just after 3.0
@
text
@@


1.1.2.2
log
@Merge in -current from about a week ago
@
text
@d58 1
a58 1
softintr_establish(int level, void (*fun)(void *), void *arg);
d61 1
a61 1
softintr_disestablish(void *cookie);
d64 1
a64 1
softintr_schedule(void *cookie);
@


1.1.2.3
log
@Sync the SMP branch with 3.3
@
text
@d49 1
a49 1
#define	IPL_VM		PIL_VM		/* memory allocation */
a54 1
#define IPL_STATCLOCK	PIL_STATCLOCK	/* statclock */
@


1.1.2.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@a39 33
#ifndef _SPARC64_INTR_H_
#define _SPARC64_INTR_H_

#ifndef _SPARC64_INTREG_H_
#include <sparc64/sparc64/intreg.h>
#endif

/*
 * Interrupt handler chains.  Interrupt handlers should return 0 for
 * ``not me'' or 1 (``I took care of it'').  intr_establish() inserts a
 * handler into the list.  The handler is called with its (single)
 * argument, or with a pointer to a clockframe if ih_arg is NULL.
 */
struct intrhand {
        int                     (*ih_fun)(void *);
        void                    *ih_arg;
        short                   ih_number;      /* interrupt number */
                                                /* the H/W provides */
        char                    ih_pil;         /* interrupt priority */
        volatile char           ih_busy;        /* handler is on list */
        struct intrhand         *ih_next;       /* global list */
        struct intrhand         *ih_pending;    /* pending list */
        volatile u_int64_t      *ih_map;        /* interrupt map reg */
        volatile u_int64_t      *ih_clr;        /* clear interrupt reg */
        u_int64_t               ih_count;       /* # of interrupts */
        const void              *ih_bus;        /* parent bus */
        char                    ih_name[1];     /* device name */
};

extern struct intrhand *intrlev[MAXINTNUM];

void    intr_establish(int, struct intrhand *);

a65 2

#endif /* _SPARC64_INTR_H_ */
@


1.1.1.1
log
@Enough of NetBSD/sparc64 to get compilable/working bootblk... more to come.
@
text
@@
