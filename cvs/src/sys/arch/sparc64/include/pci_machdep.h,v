head	1.33;
access;
symbols
	OPENBSD_6_2:1.33.0.4
	OPENBSD_6_2_BASE:1.33
	OPENBSD_6_1:1.33.0.6
	OPENBSD_6_1_BASE:1.33
	OPENBSD_6_0:1.33.0.2
	OPENBSD_6_0_BASE:1.33
	OPENBSD_5_9:1.32.0.8
	OPENBSD_5_9_BASE:1.32
	OPENBSD_5_8:1.32.0.10
	OPENBSD_5_8_BASE:1.32
	OPENBSD_5_7:1.32.0.2
	OPENBSD_5_7_BASE:1.32
	OPENBSD_5_6:1.32.0.6
	OPENBSD_5_6_BASE:1.32
	OPENBSD_5_5:1.32.0.4
	OPENBSD_5_5_BASE:1.32
	OPENBSD_5_4:1.31.0.4
	OPENBSD_5_4_BASE:1.31
	OPENBSD_5_3:1.31.0.2
	OPENBSD_5_3_BASE:1.31
	OPENBSD_5_2:1.30.0.4
	OPENBSD_5_2_BASE:1.30
	OPENBSD_5_1_BASE:1.30
	OPENBSD_5_1:1.30.0.2
	OPENBSD_5_0:1.29.0.2
	OPENBSD_5_0_BASE:1.29
	OPENBSD_4_9:1.25.0.2
	OPENBSD_4_9_BASE:1.25
	OPENBSD_4_8:1.24.0.2
	OPENBSD_4_8_BASE:1.24
	OPENBSD_4_7:1.23.0.2
	OPENBSD_4_7_BASE:1.23
	OPENBSD_4_6:1.21.0.6
	OPENBSD_4_6_BASE:1.21
	OPENBSD_4_5:1.21.0.2
	OPENBSD_4_5_BASE:1.21
	OPENBSD_4_4:1.19.0.4
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.19.0.2
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.17.0.2
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.15.0.4
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.15.0.2
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.14.0.2
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.13.0.4
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.13.0.2
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.12.0.6
	OPENBSD_3_6_BASE:1.12
	SMP_SYNC_A:1.12
	SMP_SYNC_B:1.12
	OPENBSD_3_5:1.12.0.4
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.12.0.2
	OPENBSD_3_4_BASE:1.12
	UBC_SYNC_A:1.12
	OPENBSD_3_3:1.11.0.2
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.9.0.2
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	UBC_SYNC_B:1.9
	UBC:1.4.0.6
	UBC_BASE:1.4
	SMP:1.4.0.4
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4;
locks; strict;
comment	@ * @;


1.33
date	2016.05.04.14.30.01;	author kettenis;	state Exp;
branches;
next	1.32;
commitid	n9OfCKyY3NAvSMg8;

1.32
date	2013.11.05.10.12.35;	author mpi;	state Exp;
branches;
next	1.31;

1.31
date	2012.08.29.09.32.09;	author kettenis;	state Exp;
branches;
next	1.30;

1.30
date	2011.10.10.19.42.36;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2011.07.06.05.08.50;	author kettenis;	state Exp;
branches;
next	1.28;

1.28
date	2011.06.26.18.20.36;	author kettenis;	state Exp;
branches;
next	1.27;

1.27
date	2011.05.21.20.46.11;	author kettenis;	state Exp;
branches;
next	1.26;

1.26
date	2011.05.21.17.43.09;	author kettenis;	state Exp;
branches;
next	1.25;

1.25
date	2010.12.04.17.06.32;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2010.06.29.22.08.29;	author jordan;	state Exp;
branches;
next	1.23;

1.23
date	2009.08.22.02.54.51;	author mk;	state Exp;
branches;
next	1.22;

1.22
date	2009.07.20.23.40.43;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2008.12.06.19.59.38;	author tedu;	state Exp;
branches;
next	1.20;

1.20
date	2008.12.06.04.31.24;	author tedu;	state Exp;
branches;
next	1.19;

1.19
date	2008.01.19.11.13.43;	author kettenis;	state Exp;
branches;
next	1.18;

1.18
date	2007.11.25.00.38.49;	author kettenis;	state Exp;
branches;
next	1.17;

1.17
date	2007.08.04.16.39.15;	author kettenis;	state Exp;
branches;
next	1.16;

1.16
date	2007.04.01.12.26.15;	author kettenis;	state Exp;
branches;
next	1.15;

1.15
date	2006.03.19.02.43.38;	author brad;	state Exp;
branches;
next	1.14;

1.14
date	2005.09.04.20.40.53;	author brad;	state Exp;
branches;
next	1.13;

1.13
date	2004.12.02.02.41.02;	author brad;	state Exp;
branches;
next	1.12;

1.12
date	2003.05.16.06.59.12;	author henric;	state Exp;
branches;
next	1.11;

1.11
date	2003.02.17.01.29.20;	author henric;	state Exp;
branches;
next	1.10;

1.10
date	2003.01.13.16.04.38;	author jason;	state Exp;
branches;
next	1.9;

1.9
date	2002.06.09.23.28.21;	author jason;	state Exp;
branches;
next	1.8;

1.8
date	2002.06.09.05.26.12;	author jason;	state Exp;
branches;
next	1.7;

1.7
date	2002.06.09.04.16.46;	author jason;	state Exp;
branches;
next	1.6;

1.6
date	2002.06.08.18.06.02;	author jason;	state Exp;
branches;
next	1.5;

1.5
date	2002.04.03.16.54.19;	author jason;	state Exp;
branches;
next	1.4;

1.4
date	2001.08.25.10.13.29;	author art;	state Exp;
branches
	1.4.4.1
	1.4.6.1;
next	1.3;

1.3
date	2001.08.22.20.08.55;	author art;	state Exp;
branches;
next	1.2;

1.2
date	2001.08.20.20.23.52;	author jason;	state Exp;
branches;
next	1.1;

1.1
date	2001.08.19.05.21.37;	author jason;	state Exp;
branches;
next	;

1.4.4.1
date	2001.10.31.03.07.58;	author nate;	state Exp;
branches;
next	1.4.4.2;

1.4.4.2
date	2003.03.27.23.42.36;	author niklas;	state Exp;
branches;
next	1.4.4.3;

1.4.4.3
date	2003.06.07.11.14.45;	author ho;	state Exp;
branches;
next	;

1.4.6.1
date	2002.06.11.03.38.43;	author art;	state Exp;
branches;
next	1.4.6.2;

1.4.6.2
date	2002.10.29.00.28.11;	author art;	state Exp;
branches;
next	1.4.6.3;

1.4.6.3
date	2003.05.19.21.46.57;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.33
log
@Initial support for MSI-X.  Only supported on amd64 for now.  I have diffs to
actually use this in em(4) and xhci(4), but I'm not committing those yet
because we almost certainly need to save and restore the MSI-X registers
during suspend/resume.  However, this allows mpi@@ to play with multiple-vector
support in networking hardware.

Requested by mpi@@
ok mlarkin@@, mikeb@@
@
text
@/*	$OpenBSD: pci_machdep.h,v 1.32 2013/11/05 10:12:35 mpi Exp $	*/
/* $NetBSD: pci_machdep.h,v 1.7 2001/07/20 00:07:14 eeh Exp $ */

/*
 * Copyright (c) 1999 Matthew R. Green
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#ifndef _MACHINE_PCI_MACHDEP_H_
#define _MACHINE_PCI_MACHDEP_H_

/*
 * Forward declarations.
 */
struct pci_attach_args;

/*
 * define some bits used to glue into the common PCI code.
 */

typedef struct sparc_pci_chipset *pci_chipset_tag_t;

#define PCI_INTR_MSI		0x80000000
typedef u_int pci_intr_handle_t;

/* 
 * The stuuuuuuupid allegedly MI PCI code expects pcitag_t to be a
 * scalar type.  But we really need to store both the OFW node and
 * the bus/device/function info in it.  (We'd like to store more, 
 * like all the ofw properties, but we don't need to.)  Luckily,
 * both are 32-bit values, so we can squeeze them into a u_int64_t
 * with a little help from some macros.
 */

#define	PCITAG_NODE(x)		(int)(((x)>>32)&0xffffffff)
#define	PCITAG_OFFSET(x)	((x)&0xffffffff)
#define	PCITAG_BUS(t)		((PCITAG_OFFSET(t)>>16)&0xff)
#define	PCITAG_DEV(t)		((PCITAG_OFFSET(t)>>11)&0x1f)
#define	PCITAG_FUN(t)		((PCITAG_OFFSET(t)>>8)&0x7)
#define	PCITAG_CREATE(n,b,d,f)	(((u_int64_t)(n)<<32)|((b)<<16)|((d)<<11)|((f)<<8))
#define	PCITAG_SETNODE(t,n)	((t)&0xffffffff)|(((n)<<32)
typedef u_int64_t pcitag_t; 

struct sparc_pci_chipset {
	void			*cookie;
	bus_space_tag_t		bustag;
	bus_space_handle_t	bushandle;
	int			rootnode;	/* PCI controller */
	int			busnode[256];
	int (*conf_size)(pci_chipset_tag_t, pcitag_t);
	pcireg_t (*conf_read)(pci_chipset_tag_t, pcitag_t, int);
	void (*conf_write)(pci_chipset_tag_t, pcitag_t, int, pcireg_t);
	int (*intr_map)(struct pci_attach_args *, pci_intr_handle_t *);
};

void		pci_attach_hook(struct device *, struct device *,
				     struct pcibus_attach_args *);
int		pci_bus_maxdevs(pci_chipset_tag_t, int);
pcitag_t	pci_make_tag(pci_chipset_tag_t, int, int, int);
void		pci_decompose_tag(pci_chipset_tag_t, pcitag_t, int *, int *,
		    int *);
int		pci_conf_size(pci_chipset_tag_t, pcitag_t);
pcireg_t	pci_conf_read(pci_chipset_tag_t, pcitag_t, int);
void		pci_conf_write(pci_chipset_tag_t, pcitag_t, int,
				    pcireg_t);
int		pci_intr_map(struct pci_attach_args *, pci_intr_handle_t *);
int		pci_intr_map_msi(struct pci_attach_args *, pci_intr_handle_t *);
#define		pci_intr_map_msix(pa, vec, ihp)	(-1)
int		pci_intr_line(pci_chipset_tag_t, pci_intr_handle_t);
const char	*pci_intr_string(pci_chipset_tag_t, pci_intr_handle_t);
void		*pci_intr_establish(pci_chipset_tag_t, pci_intr_handle_t,
				 int, int (*)(void *), void *, const char *);
void		pci_intr_disestablish(pci_chipset_tag_t, void *);

void		pci_msi_enable(pci_chipset_tag_t, pcitag_t, bus_addr_t, int);

int		sparc64_pci_enumerate_bus(struct pci_softc *,
		    int (*match)(struct pci_attach_args *),
		    struct pci_attach_args *);

#define PCI_MACHDEP_ENUMERATE_BUS sparc64_pci_enumerate_bus

#define	pci_probe_device_hook(c, a)	(0)

#define	pci_min_powerstate(c, t)	(PCI_PMCSR_STATE_D3)
#define	pci_set_powerstate_md(c, t, s, p)

#define pciide_machdep_compat_intr_establish(a, b, c, d, e) (NULL)
#define pciide_machdep_compat_intr_disestablish(a, b) do { } while (0)

#define	pci_dev_postattach(a, b)

#endif /* _MACHINE_PCI_MACHDEP_H_ */
@


1.32
log
@Add a stub for the new MD hook needed to handle ACPI Power Resources.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.h,v 1.31 2012/08/29 09:32:09 kettenis Exp $	*/
d91 1
@


1.31
log
@Implement pci_min_powerstate().
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.h,v 1.30 2011/10/10 19:42:36 miod Exp $	*/
d108 1
@


1.30
log
@Introduce pci_probe_device_hook(pci_chipset_tag_t, struct pci_attach_args *).
This mandatory function will get invoked in pci_probe_device(), and allows
a pci host driver to alter the pci_attach_args passed to a device when
attaching.

This function will also, if returning non-zero, cause the device to be
skipped completely during all the phases of the PCI device discovery
(i.e. ressource enumeration, ressource assignment, and actual attachment).
This particular feature is experimental and might be reverted in the future
(or the scope narrowed to device attachment only).

A dummy #define pci_probe_device_hook() 0 is added to all platforms except
sgi, where real functions (currently only returning 0) are added; real meat
will be added shortly.

Discussed at s2k11, no objection from the usual suspects.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.h,v 1.29 2011/07/06 05:08:50 kettenis Exp $	*/
d106 2
@


1.29
log
@Move pci_msi_enable() out of the vpci(4) driver into the MD pci(4) code.
Soon to be used by pyro(4) as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.h,v 1.28 2011/06/26 18:20:36 kettenis Exp $	*/
d104 2
@


1.28
log
@Implement pci_intr_map_msi().
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.h,v 1.27 2011/05/21 20:46:11 kettenis Exp $	*/
d96 2
@


1.27
log
@It's better to have the pci_intr_map_msi() stub return -1.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.h,v 1.26 2011/05/21 17:43:09 kettenis Exp $	*/
d45 2
d90 1
a105 1
#define pci_intr_map_msi(a, b)		(-1)
@


1.26
log
@Add pci_intr_map_msi() stub.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.h,v 1.25 2010/12/04 17:06:32 miod Exp $	*/
d103 1
a103 1
#define pci_intr_map_msi(a, b)		(1)
@


1.25
log
@Introduce a new pci routine, pci_conf_size(), which returns the size of a
given pcitag_t configuration address space. Currently, all pci controllers
will return the usual 0x100 bytes of PCI configuration space, but this will
eventually change on PCIe-capable controlers.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.h,v 1.24 2010/06/29 22:08:29 jordan Exp $	*/
d103 1
@


1.24
log
@Add support for mapping ACPI to PCI devices
ok kettenis, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.h,v 1.23 2009/08/22 02:54:51 mk Exp $	*/
d71 1
d83 1
@


1.23
log
@Constify the what/name parameter of pci_intr_establish().

Tested by myself, sthen, oga, kettenis, and jasper.
Input from sthen and jasper.

ok kettenis

(Manpage follows shortly.)
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.h,v 1.22 2009/07/20 23:40:43 miod Exp $	*/
d100 2
@


1.22
log
@Pass a pci_chipset_tag_t to pci_intr_line(), to eventually allow the
logic to be chipset dependent; no functional change yet.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.h,v 1.21 2008/12/06 19:59:38 tedu Exp $	*/
d89 1
a89 1
				 int, int (*)(void *), void *, char *);
@


1.21
log
@revert all changes related to the mpsafe intr handler.  i screwed up the commit
and even then it didn't work.  we have higher standards than this.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.h,v 1.20 2008/12/06 04:31:24 tedu Exp $	*/
d86 1
a86 1
int		pci_intr_line(pci_intr_handle_t);
@


1.20
log
@mpsafe intr_establish that doesn't get biglock, so that we may dream of the day when this is useful.
mostly macro magic that does nothing.  only actually useful on amd64 for now, compliments of art.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.h,v 1.19 2008/01/19 11:13:43 kettenis Exp $	*/
a89 2
#define		pci_intr_establish_mpsafe(t,h,l,f,a,w)	\
	pci_intr_establish(t,h,l,f,a,w)
@


1.19
log
@Make host bridges provide their own implementation of pci_conf_read() and
pci_conf_write() and give pyro(4) an implementation suitable for PCIe.  For
psycho(4) and schizo(4), go back to the origional implementation.  This gets
rid of the 'tagshift' member of pci_chipset_tag_t, and clears the way for
sun4v.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.h,v 1.18 2007/11/25 00:38:49 kettenis Exp $	*/
d90 2
@


1.18
log
@Give the CarBus side of CardBus-PCI bridges a bus number, since OpenFirmware
doesn't do it for us.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.h,v 1.17 2007/08/04 16:39:15 kettenis Exp $	*/
d71 2
a72 1
	int			tagshift;
@


1.17
log
@Add missing pci_intr_line() implementation.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.h,v 1.16 2007/04/01 12:26:15 kettenis Exp $	*/
d70 1
@


1.16
log
@Shift tags when converting them into an address offset.  Necessary to support
access to PCIe config space, which is larger than normal PCI config space.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.h,v 1.15 2006/03/19 02:43:38 brad Exp $	*/
d84 1
@


1.15
log
@rev 1.86

make the "generic" PCI bus enumeration code the standard case which
gets used if nothing else is defined in MD headers,
introduce a "PCI_MACHDEP_ENUMERATE_BUS" CPP definition which can
be used by MD headers (just 1 port atm) to plug in special code

rev 1.62

* Implement a machine-dependent pci_enumerate_bus() for sparc64 which
  uses OFW device nodes to enumerate the bus.  When a PCI bus that is
  behind a bridge is attached, pci_attach_hook() allocates a new PCI
  chipset tag for the new bus and sets it's "curnode" to the OFW node
  of the bridge.  This is used as a starting point when enumerating
  that bus.  Root busses get the OFW node of the host bridge (psycho).

rev 1.59

Split the code that enumerates the PCI bus and that actually probes
for a device into two functions:

* pci_probe_device() actually probes/attaches the device specified
  by the provide pcitag_t.

* pci_enumerate_bus() enumerates the bus, and calls pci_probe_device()
  for each device on the bus.  A pci_enumerate_bus_generic() is provided
  which implements the old method of doing this: If something found at
  dev0/func0, determine number of functions and probe each one.

From NetBSD

ok kettenis@@

Tested on a good number of amd64/i386/macppc/sparc64 systems
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.h,v 1.14 2005/09/04 20:40:53 brad Exp $	*/
d66 1
a66 1
	void			*cookie;	/* psycho_pbm, but sssh! */
d70 1
@


1.14
log
@remove unused NetBSD pci_intr_evcnt() function.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.h,v 1.13 2004/12/02 02:41:02 brad Exp $	*/
a35 6
 * We want to control both device & function probe order.
 */
#define		__PCI_BUS_DEVORDER
#define		__PCI_DEV_FUNCORDER

/*
a69 1
	int			curnode;	/* Current OFW node */
a74 6
#ifdef __PCI_BUS_DEVORDER
int		pci_bus_devorder(pci_chipset_tag_t, int, char *);
#endif
#ifdef __PCI_DEV_FUNCORDER
int		pci_dev_funcorder(pci_chipset_tag_t, int, int, char *);
#endif
d87 6
@


1.13
log
@Add pci_decompose_tag() for sparc64.

From NetBSD

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.h,v 1.12 2003/05/16 06:59:12 henric Exp $	*/
a96 1
const struct evcnt *pci_intr_evcnt(pci_chipset_tag_t, pci_intr_handle_t);
@


1.12
log
@The sparc64 proms do not map all interrupt vectors.  Instead of
trying to use the interrupt pin (or is it that the PCI
function?) as the interrupt vector, this computes the vector
from the PCI bus, slot, and pin.  This will only change mappings
on psycho-based machines (*not* sabre, i.e., IIi/e) and only for
those vectors reported as nonsense INRs (INO 0-3).

This should fix the mapping of non-bridge expansion cards on U60
and E450, and other psycho boxen.  U30 seems to do its own
thing.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.h,v 1.11 2003/02/17 01:29:20 henric Exp $	*/
d36 1
a36 1
 * We want to contro both device & function probe order.
a62 3
#define	PCITAG_BUS(t)		(((t) >> 16) & 0xff)
#define	PCITAG_DEV(t)		(((t) >> 11) & 0x1f)
#define	PCITAG_FUNC(t)		(((t) >>  8) & 0x07)
d64 3
d90 2
@


1.11
log
@
Add support for the Sun Enterprise 450
Reduce the size of a GENERIC kernel by ~190k
Remove the nasty pointer/bus_space_handle_t casts
Adds debug bus_space code including the ability to trace
    bus operations (it actually works now).

The following rules are now followed (and verfified by the debug
code):

1.  A "bus_space_handle_t" may only be used with the
    "bus_space_tag_t" that created it.
2.  Only "bus_space_map()" may create "bus_space_handle_t"s.
3.  A "bus_space_handle_t" may not be modified after it has
    been created (other than being destroyed by "bus_space_unmap()").


Thanks to help from mcbride, marc, jason, drahn, to anyone that might
have slipped my mind at the moment.

ok jason@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.h,v 1.10 2003/01/13 16:04:38 jason Exp $	*/
d77 1
a77 1

@


1.10
log
@Don't use a global variable to determine which pci_conf* function to call,
store function pointers in the pci_chipset_tag_t (ie. fix an ugly hack
I did during the hackathon last year).
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.h,v 1.9 2002/06/09 23:28:21 jason Exp $	*/
d73 2
a74 2
	pcireg_t		(*conf_read)(pci_chipset_tag_t, pcitag_t, int);
	void			(*conf_write)(pci_chipset_tag_t, pcitag_t, int, pcireg_t);
@


1.9
log
@2^5 not 5, duh, sorry matthieu
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.h,v 1.8 2002/06/09 05:26:12 jason Exp $	*/
a52 6
struct sparc_pci_chipset {
	void			*cookie;	/* psycho_pbm, but sssh! */
	int			rootnode;	/* PCI controller */
	int			curnode;	/* Current OFW node */
};

d71 8
a89 2
void		pci_conf_setfunc(pcireg_t (*rd)(pci_chipset_tag_t, pcitag_t, int),
    void (*wr)(pci_chipset_tag_t, pcitag_t, int, pcireg_t));
@


1.8
log
@Ah, seems we've seen this problem before (macro's with wrong name)
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.h,v 1.7 2002/06/09 04:16:46 jason Exp $	*/
d70 1
a70 1
#define	PCITAG_DEV(t)		(((t) >> 11) & 0x05)
@


1.7
log
@add PCITAG_BUS/DEV/FUNC for decoding PCI tags
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.h,v 1.6 2002/06/08 18:06:02 jason Exp $	*/
d69 3
a71 3
#define	PCITAG_BUS(t)		(((x) >> 16) & 0xff)
#define	PCITAG_DEV(t)		(((x) >> 11) & 0x05)
#define	PCITAG_FUNC(t)		(((x) >>  8) & 0x07)
@


1.6
log
@make pci_conf_{read|write} indirect functions so we can overload them
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.h,v 1.5 2002/04/03 16:54:19 jason Exp $	*/
d69 3
@


1.5
log
@in PCITAG_SETNODE s/t/x to match usage; from netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.h,v 1.4 2001/08/25 10:13:29 art Exp $	*/
d85 2
@


1.4
log
@Change pci_intr_map to take pci_attach_args as an argument.
All callers actually took all arguments to pci_intr_map from pci_attach_args
structs, so this simplifies code.
This also allows more complicated interrupt assignment schemes like the one
on sparc64.

This makes sparc64 pci interrupts work.

Inspired by the same change in NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.h,v 1.3 2001/08/22 20:08:55 art Exp $	*/
d71 1
a71 1
#define	PCITAG_SETNODE(t,n)	((x)&0xffffffff)|(((n)<<32)
@


1.4.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.h,v 1.4 2001/08/25 10:13:29 art Exp $	*/
a68 3
#define	PCITAG_BUS(t)		(((t) >> 16) & 0xff)
#define	PCITAG_DEV(t)		(((t) >> 11) & 0x05)
#define	PCITAG_FUNC(t)		(((t) >>  8) & 0x07)
d71 1
a71 1
#define	PCITAG_SETNODE(t,n)	((t)&0xffffffff)|(((n)<<32)
a84 2
void		pci_conf_setfunc(pcireg_t (*rd)(pci_chipset_tag_t, pcitag_t, int),
    void (*wr)(pci_chipset_tag_t, pcitag_t, int, pcireg_t));
@


1.4.6.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.h,v 1.4.6.1 2002/06/11 03:38:43 art Exp $	*/
d70 1
a70 1
#define	PCITAG_DEV(t)		(((t) >> 11) & 0x1f)
@


1.4.6.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d53 6
a76 8
struct sparc_pci_chipset {
	void			*cookie;	/* psycho_pbm, but sssh! */
	bus_space_tag_t		bustag;
	bus_space_handle_t	bushandle;
	int			rootnode;	/* PCI controller */
	int			curnode;	/* Current OFW node */
	int (*intr_map)(struct pci_attach_args *, pci_intr_handle_t *);
};
d88 2
@


1.4.4.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.4.4.2
log
@Sync the SMP branch with 3.3
@
text
@d53 6
a68 3
#define	PCITAG_BUS(t)		(((t) >> 16) & 0xff)
#define	PCITAG_DEV(t)		(((t) >> 11) & 0x1f)
#define	PCITAG_FUNC(t)		(((t) >>  8) & 0x07)
d71 1
a71 1
#define	PCITAG_SETNODE(t,n)	((t)&0xffffffff)|(((n)<<32)
a73 8
struct sparc_pci_chipset {
	void			*cookie;	/* psycho_pbm, but sssh! */
	bus_space_tag_t		bustag;
	bus_space_handle_t	bushandle;
	int			rootnode;	/* PCI controller */
	int			curnode;	/* Current OFW node */

};
@


1.4.4.3
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.h,v 1.4.4.2 2003/03/27 23:42:36 niklas Exp $	*/
d77 1
a77 1
	int (*intr_map)(struct pci_attach_args *, pci_intr_handle_t *);
@


1.3
log
@Fix interrupt establishing.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.h,v 1.2 2001/08/20 20:23:52 jason Exp $	*/
d88 1
a88 2
int		pci_intr_map(pci_chipset_tag_t, pcitag_t, int, int,
			pci_intr_handle_t *);
@


1.2
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d88 2
a89 1
int		pci_intr_map(struct pci_attach_args *, pci_intr_handle_t *);
d93 1
a93 1
					 int, int (*)(void *), void *);
d95 3
@


1.1
log
@Lot of stuff... Some from NetBSD, some from OpenBSD, minor modifications
@
text
@d1 1
@

