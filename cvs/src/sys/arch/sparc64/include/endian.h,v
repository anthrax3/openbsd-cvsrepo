head	1.7;
access;
symbols
	OPENBSD_6_1:1.7.0.10
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.7.0.8
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.4
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.7.0.6
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.6.0.4
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.3.0.14
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.10
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.8
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.6
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.4
	OPENBSD_5_0:1.3.0.2
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.2.0.22
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.20
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.2.0.16
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.18
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.14
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.2.0.12
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3:1.2.0.10
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_2:1.2.0.8
	OPENBSD_4_2_BASE:1.2
	OPENBSD_4_1:1.2.0.6
	OPENBSD_4_1_BASE:1.2
	OPENBSD_4_0:1.2.0.4
	OPENBSD_4_0_BASE:1.2
	OPENBSD_3_9:1.2.0.2
	OPENBSD_3_9_BASE:1.2
	OPENBSD_3_8:1.1.0.20
	OPENBSD_3_8_BASE:1.1
	OPENBSD_3_7:1.1.0.18
	OPENBSD_3_7_BASE:1.1
	OPENBSD_3_6:1.1.0.16
	OPENBSD_3_6_BASE:1.1
	SMP_SYNC_A:1.1
	SMP_SYNC_B:1.1
	OPENBSD_3_5:1.1.0.14
	OPENBSD_3_5_BASE:1.1
	OPENBSD_3_4:1.1.0.12
	OPENBSD_3_4_BASE:1.1
	UBC_SYNC_A:1.1
	OPENBSD_3_3:1.1.0.10
	OPENBSD_3_3_BASE:1.1
	OPENBSD_3_2:1.1.0.8
	OPENBSD_3_2_BASE:1.1
	OPENBSD_3_1:1.1.0.6
	OPENBSD_3_1_BASE:1.1
	UBC_SYNC_B:1.1
	UBC:1.1.0.4
	UBC_BASE:1.1
	SMP:1.1.0.2
	OPENBSD_3_0:1.1.1.1.0.2
	OPENBSD_3_0_BASE:1.1.1.1
	SPARC64:1.1.1.1
	NETBSD:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2014.10.22.23.56.47;	author dlg;	state Exp;
branches;
next	1.6;
commitid	W6i4CJDuhqS3nLLJ;

1.6
date	2014.07.12.16.25.09;	author guenther;	state Exp;
branches;
next	1.5;
commitid	r9gXh8PA6rI3P7q2;

1.5
date	2014.03.25.03.53.35;	author dlg;	state Exp;
branches;
next	1.4;

1.4
date	2014.03.14.10.47.21;	author dlg;	state Exp;
branches;
next	1.3;

1.3
date	2011.03.11.15.17.08;	author pirofti;	state Exp;
branches;
next	1.2;

1.2
date	2005.12.13.00.35.23;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2001.08.18.04.16.40;	author jason;	state Exp;
branches
	1.1.1.1
	1.1.2.1;
next	;

1.1.1.1
date	2001.08.18.04.16.40;	author jason;	state Exp;
branches;
next	;

1.1.2.1
date	2001.10.31.03.07.58;	author nate;	state Exp;
branches;
next	;


desc
@@


1.7
log
@make [bl]emtoh{16,32,64} take volatile const foo *, not volatile foo *

while in the manpage add volatile where the code has it too.

ok miod@@ guenther@@
@
text
@/*	$OpenBSD: endian.h,v 1.6 2014/07/12 16:25:09 guenther Exp $	*/

#ifndef _MACHINE_ENDIAN_H_
#define _MACHINE_ENDIAN_H_

#define	_BYTE_ORDER _BIG_ENDIAN

#ifdef _KERNEL

#define __ASI_P_L	0x88 /* == ASI_PRIMARY_LITTLE */

static inline __uint16_t
__mswap16(volatile const __uint16_t *m)
{
	__uint16_t v;

	__asm("lduha [%1] %2, %0 ! %3"
	    : "=r" (v)
	    : "r" (m), "n" (__ASI_P_L), "m" (*m));

	return (v);
}

static inline __uint32_t
__mswap32(volatile const __uint32_t *m)
{
	__uint32_t v;

	__asm("lduwa [%1] %2, %0 ! %3"
	    : "=r" (v)
	    : "r" (m), "n" (__ASI_P_L), "m" (*m));

	return (v);
}

static inline __uint64_t
__mswap64(volatile const __uint64_t *m)
{
	__uint64_t v;

	__asm("ldxa [%1] %2, %0 ! %3"
	    : "=r" (v)
	    : "r" (m), "n" (__ASI_P_L), "m" (*m));

	return (v);
}

static inline void
__swapm16(volatile __uint16_t *m, __uint16_t v)
{
	__asm("stha %1, [%2] %3 ! %0"
	    : "=m" (*m)
	    : "r" (v), "r" (m), "n" (__ASI_P_L));
}

static inline void
__swapm32(volatile __uint32_t *m, __uint32_t v)
{
	__asm("stwa %1, [%2] %3 ! %0"
	    : "=m" (*m)
	    : "r" (v), "r" (m), "n" (__ASI_P_L));
}

static inline void
__swapm64(volatile __uint64_t *m, __uint64_t v)
{
	__asm("stxa %1, [%2] %3 ! %0"
	    : "=m" (*m)
	    : "r" (v), "r" (m), "n" (__ASI_P_L));
}

#undef __ASI_P_L

#define __HAVE_MD_SWAPIO

#endif  /* _KERNEL */

#define __STRICT_ALIGNMENT

#ifndef __FROM_SYS__ENDIAN
#include <sys/endian.h>
#endif

#endif /* _MACHINE_ENDIAN_H_ */
@


1.6
log
@Tackle the endian.h mess.  Make it so that:
 * you can #include <sys/endian.h> instead of <machine/endian.h>,
   and ditto <endian.h>  (fixes code that pulls in <sys/endian.h> first)

 * those will always export the symbols that POSIX specified for
   <endian.h>, including the new {be,le}{16,32,64}toh() set.  c.f.
	http://austingroupbugs.net/view.php?id=162

   if __BSD_VISIBLE then you also get the symbols that our <machine/endian.h>
   currently exports (ntohs, NTOHS, dlg's bemtoh*, etc)

 * when doing POSIX compiles (not __BSD_VISIBLE), then <netinet/in.h> and
   <arpa/inet.h> will *stop* exporting the extra symbols like BYTE_ORDER
   and betoh*

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: endian.h,v 1.5 2014/03/25 03:53:35 dlg Exp $	*/
d13 1
a13 1
__mswap16(volatile __uint16_t *m)
d25 1
a25 1
__mswap32(volatile __uint32_t *m)
d37 1
a37 1
__mswap64(volatile __uint64_t *m)
@


1.5
log
@the memory constraints are correct on the MD_SWAPIO bits, so we dont need
the extra restrictions that __volatile provides on the __asm statements.
@
text
@d1 1
a1 1
/*	$OpenBSD: endian.h,v 1.4 2014/03/14 10:47:21 dlg Exp $	*/
d10 1
a10 1
#define ASI_P_L	0x88
d19 1
a19 1
	    : "r" (m), "n" (ASI_P_L), "m" (*m));
d31 1
a31 1
	    : "r" (m), "n" (ASI_P_L), "m" (*m));
d43 1
a43 1
	    : "r" (m), "n" (ASI_P_L), "m" (*m));
d53 1
a53 1
	    : "r" (v), "r" (m), "n" (ASI_P_L));
d61 1
a61 1
	    : "r" (v), "r" (m), "n" (ASI_P_L));
d69 1
a69 1
	    : "r" (v), "r" (m), "n" (ASI_P_L));
d72 1
a72 1
#undef ASI_P_L
d74 1
a74 1
#define MD_SWAPIO
d78 3
d82 1
a82 2

#define __STRICT_ALIGNMENT
@


1.4
log
@provide an MI api for doing byteswapping loads and stores. some
archs have instrutions that can do this, and the rest that dont get
to use wrappers around the byteswap(3) api.

this provides MI backends for sparc64 and powerpc which get a big
benefit from this because byteswapping in registers is really hard
for them.

the intended use case is for reading and writing bits of dma memory
handed to and from hardware.

discussed with miod@@ guenther@@ deraadt@@
ok miod@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: endian.h,v 1.3 2011/03/11 15:17:08 pirofti Exp $	*/
d17 1
a17 1
	__asm __volatile("lduha [%1] %2, %0 ! %3"
d29 1
a29 1
	__asm __volatile("lduwa [%1] %2, %0 ! %3"
d41 1
a41 1
	__asm __volatile("ldxa [%1] %2, %0 ! %3"
d51 1
a51 1
	__asm __volatile("stha %1, [%2] %3 ! %0"
d59 1
a59 1
	__asm __volatile("stwa %1, [%2] %3 ! %0"
d67 1
a67 1
	__asm __volatile("stxa %1, [%2] %3 ! %0"
@


1.3
log
@Use _MACHINE_ENDIAN_H_ for this is The Right Thing To Do.

Okay guenther@@, millert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: endian.h,v 1.2 2005/12/13 00:35:23 millert Exp $	*/
d7 71
@


1.2
log
@First step in include files overhaul.  Use __FOO_VISIBLE (as defined
in sys/cdefs.h) instead of _FOO_SOURCE.  Also fix several namespace
pollution issues, including the byte order defines.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: endian.h,v 1.1 2001/08/18 04:16:40 jason Exp $	*/
d3 2
a4 2
#ifndef _SPARC64_ENDIAN_H_
#define _SPARC64_ENDIAN_H_
d11 1
a11 1
#endif /* _SPARC64_ENDIAN_H_ */
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d6 1
a6 1
#define	BYTE_ORDER BIG_ENDIAN
@


1.1.2.1
log
@Sync the SMP branch to something just after 3.0
@
text
@@


1.1.1.1
log
@Enough of NetBSD/sparc64 to get compilable/working bootblk... more to come.
@
text
@@
