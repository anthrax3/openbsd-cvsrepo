head	1.33;
access;
symbols
	OPENBSD_6_1:1.31.0.4
	OPENBSD_6_1_BASE:1.31
	OPENBSD_6_0:1.30.0.2
	OPENBSD_6_0_BASE:1.30
	OPENBSD_5_9:1.29.0.10
	OPENBSD_5_9_BASE:1.29
	OPENBSD_5_8:1.29.0.12
	OPENBSD_5_8_BASE:1.29
	OPENBSD_5_7:1.29.0.4
	OPENBSD_5_7_BASE:1.29
	OPENBSD_5_6:1.29.0.8
	OPENBSD_5_6_BASE:1.29
	OPENBSD_5_5:1.29.0.6
	OPENBSD_5_5_BASE:1.29
	OPENBSD_5_4:1.29.0.2
	OPENBSD_5_4_BASE:1.29
	OPENBSD_5_3:1.28.0.2
	OPENBSD_5_3_BASE:1.28
	OPENBSD_5_2:1.27.0.4
	OPENBSD_5_2_BASE:1.27
	OPENBSD_5_1_BASE:1.27
	OPENBSD_5_1:1.27.0.2
	OPENBSD_5_0:1.26.0.2
	OPENBSD_5_0_BASE:1.26
	OPENBSD_4_9:1.25.0.8
	OPENBSD_4_9_BASE:1.25
	OPENBSD_4_8:1.25.0.6
	OPENBSD_4_8_BASE:1.25
	OPENBSD_4_7:1.25.0.2
	OPENBSD_4_7_BASE:1.25
	OPENBSD_4_6:1.25.0.4
	OPENBSD_4_6_BASE:1.25
	OPENBSD_4_5:1.24.0.4
	OPENBSD_4_5_BASE:1.24
	OPENBSD_4_4:1.24.0.2
	OPENBSD_4_4_BASE:1.24
	OPENBSD_4_3:1.23.0.4
	OPENBSD_4_3_BASE:1.23
	OPENBSD_4_2:1.23.0.2
	OPENBSD_4_2_BASE:1.23
	OPENBSD_4_1:1.20.0.2
	OPENBSD_4_1_BASE:1.20
	OPENBSD_4_0:1.19.0.2
	OPENBSD_4_0_BASE:1.19
	OPENBSD_3_9:1.18.0.2
	OPENBSD_3_9_BASE:1.18
	OPENBSD_3_8:1.17.0.2
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.16.0.8
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.16.0.6
	OPENBSD_3_6_BASE:1.16
	SMP_SYNC_A:1.16
	SMP_SYNC_B:1.16
	OPENBSD_3_5:1.16.0.4
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.16.0.2
	OPENBSD_3_4_BASE:1.16
	UBC_SYNC_A:1.15
	OPENBSD_3_3:1.15.0.2
	OPENBSD_3_3_BASE:1.15
	OPENBSD_3_2:1.13.0.2
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.12.0.2
	OPENBSD_3_1_BASE:1.12
	UBC_SYNC_B:1.13
	UBC:1.7.0.6
	UBC_BASE:1.7
	SMP:1.7.0.4
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7;
locks; strict;
comment	@ * @;


1.33
date	2017.05.25.03.19.39;	author dlg;	state Exp;
branches;
next	1.32;
commitid	gx8rjMxrMcqYnydg;

1.32
date	2017.05.08.00.27.45;	author dlg;	state Exp;
branches;
next	1.31;
commitid	miRwMNEodfMJO0uz;

1.31
date	2017.02.13.01.34.37;	author dlg;	state Exp;
branches;
next	1.30;
commitid	ihv1aK4oNUnQGV0q;

1.30
date	2016.05.04.18.26.12;	author kettenis;	state Exp;
branches;
next	1.29;
commitid	M6mvq0S4zf7jMQ41;

1.29
date	2013.05.13.17.46.42;	author kettenis;	state Exp;
branches;
next	1.28;

1.28
date	2013.01.22.23.56.31;	author dlg;	state Exp;
branches;
next	1.27;

1.27
date	2011.09.27.20.47.30;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2011.03.23.16.54.37;	author pirofti;	state Exp;
branches;
next	1.25;

1.25
date	2009.04.20.00.42.06;	author oga;	state Exp;
branches;
next	1.24;

1.24
date	2008.06.26.05.42.13;	author ray;	state Exp;
branches;
next	1.23;

1.23
date	2007.08.04.16.44.15;	author kettenis;	state Exp;
branches;
next	1.22;

1.22
date	2007.05.29.09.54.25;	author sobrado;	state Exp;
branches;
next	1.21;

1.21
date	2007.04.10.18.02.48;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2006.12.30.21.19.24;	author claudio;	state Exp;
branches;
next	1.19;

1.19
date	2006.06.07.19.13.07;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2006.01.06.18.53.05;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2005.07.10.00.23.11;	author brad;	state Exp;
branches;
next	1.16;

1.16
date	2003.06.24.21.54.39;	author henric;	state Exp;
branches;
next	1.15;

1.15
date	2003.03.06.08.26.08;	author henric;	state Exp;
branches;
next	1.14;

1.14
date	2003.02.17.01.29.20;	author henric;	state Exp;
branches;
next	1.13;

1.13
date	2002.05.13.19.31.32;	author jason;	state Exp;
branches;
next	1.12;

1.12
date	2002.03.14.03.16.00;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2002.03.14.01.26.45;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.07.18.08.08;	author jason;	state Exp;
branches;
next	1.9;

1.9
date	2002.02.19.05.03.42;	author jason;	state Exp;
branches;
next	1.8;

1.8
date	2002.02.05.18.34.39;	author jason;	state Exp;
branches;
next	1.7;

1.7
date	2001.09.26.21.30.27;	author jason;	state Exp;
branches
	1.7.4.1
	1.7.6.1;
next	1.6;

1.6
date	2001.09.06.14.04.35;	author art;	state Exp;
branches;
next	1.5;

1.5
date	2001.08.30.19.50.26;	author jason;	state Exp;
branches;
next	1.4;

1.4
date	2001.08.23.14.24.58;	author art;	state Exp;
branches;
next	1.3;

1.3
date	2001.08.22.20.11.09;	author art;	state Exp;
branches;
next	1.2;

1.2
date	2001.08.20.20.23.52;	author jason;	state Exp;
branches;
next	1.1;

1.1
date	2001.08.18.19.49.57;	author art;	state Exp;
branches;
next	;

1.7.4.1
date	2001.10.31.03.07.58;	author nate;	state Exp;
branches;
next	1.7.4.2;

1.7.4.2
date	2002.03.06.02.04.47;	author niklas;	state Exp;
branches;
next	1.7.4.3;

1.7.4.3
date	2002.03.28.11.23.52;	author niklas;	state Exp;
branches;
next	1.7.4.4;

1.7.4.4
date	2003.03.27.23.42.36;	author niklas;	state Exp;
branches;
next	1.7.4.5;

1.7.4.5
date	2004.02.19.10.50.00;	author niklas;	state Exp;
branches;
next	;

1.7.6.1
date	2002.06.11.03.38.43;	author art;	state Exp;
branches;
next	1.7.6.2;

1.7.6.2
date	2003.05.19.21.46.57;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.33
log
@tweak sparc64 membars as a step toward making them usable in userland.

specifically, dont rely on magic in ctlreg to implement membars. moving
that to atomic.h would add a lot of pollution to the namespace, so
move to passing the membar options to a single __membar macro.

this tweaks everything that was using the ctlreg backend to either use
an appropriate membar_foo(), or to use __membar() in the MD code.

ok kettenis@@
@
text
@/*	$OpenBSD: bus.h,v 1.32 2017/05/08 00:27:45 dlg Exp $	*/
/*	$NetBSD: bus.h,v 1.31 2001/09/21 15:30:41 wiz Exp $	*/

/*-
 * Copyright (c) 1996, 1997, 1998, 2001 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,
 * NASA Ames Research Center.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 1997-1999, 2001 Eduardo E. Horvath. All rights reserved.
 * Copyright (c) 1996 Charles M. Hannum.  All rights reserved.
 * Copyright (c) 1996 Christopher G. Demetriou.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Christopher G. Demetriou
 *	for the NetBSD Project.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef _MACHINE_BUS_H_
#define _MACHINE_BUS_H_

#include <sys/atomic.h>

/*
 * Debug hooks
 */

#define	BSDB_ACCESS	0x01
#define BSDB_MAP	0x02
#define BSDB_ASSERT	0x04
#define BSDB_MAPDETAIL	0x08
#define	BSDB_ALL_ACCESS	0x10
extern int bus_space_debug;

#define BSHDB_ACCESS	0x01
#define BSHDB_NO_ACCESS	0x02

#if defined(BUS_SPACE_DEBUG)
#ifndef _MACHINE_BUS_H_
#include <sys/systm.h>
#endif
#define BUS_SPACE_PRINTF(l, s) do {				\
	if(bus_space_debug & (l)) printf s;			\
} while(0)
#define BUS_SPACE_TRACE(t, h, s) do {				\
	if ( (((bus_space_debug & BSDB_ALL_ACCESS) != 0) &&	\
		(((h).bh_flags & BSHDB_NO_ACCESS) == 0)) ||	\
	     (((bus_space_debug & BSDB_ACCESS) != 0) &&		\
		(((h).bh_flags & BSHDB_ACCESS) != 0)))		\
		printf s;					\
	} while(0)
#define BUS_SPACE_SET_FLAGS(t, h, f) ((h).bh_flags |= (f))
#define BUS_SPACE_CLEAR_FLAGS(t, h, f) ((h).bh_flags &= ~(f))
#define BUS_SPACE_FLAG_DECL(s)	int s
#define BUS_SPACE_SAVE_FLAGS(t, h, s) (s = (h).bh_flags)
#define BUS_SPACE_RESTORE_FLAGS(t, h, s) (s = (h).bh_flags)
#define BUS_SPACE_ASSERT(t, h, o, n) do {			\
	if (bus_space_debug & BSDB_ASSERT)			\
		bus_space_assert(t, &(h), o, n);		\
	} while(0)
#else /* BUS_SPACE_DEBUG */
#define BUS_SPACE_PRINTF(l, s)
#define BUS_SPACE_TRACE(t, h, s)
#define BUS_SPACE_SET_FLAGS(t, h, f)
#define BUS_SPACE_CLEAR_FLAGS(t, h, f)
#define BUS_SPACE_FLAG_DECL(s)
#define BUS_SPACE_SAVE_FLAGS(t, h, s)
#define BUS_SPACE_RESTORE_FLAGS(t, h, s)
#define BUS_SPACE_ASSERT(t, h, o, n)
#endif /* BUS_SPACE_DEBUG */


/*
 * UPA and SBus spaces are non-cached and big endian
 * (except for RAM and PROM)
 *
 * PCI spaces are non-cached and little endian
 */

enum bus_type { 
	UPA_BUS_SPACE,
	SBUS_BUS_SPACE,
	PCI_CONFIG_BUS_SPACE,
	PCI_IO_BUS_SPACE,
	PCI_MEMORY_BUS_SPACE,
	LAST_BUS_SPACE
}; 
/* For backwards compatibility */
#define SPARC_BUS_SPACE	UPA_BUS_SPACE

/*
 * Bus address and size types
 */
typedef const struct sparc_bus_space_tag	*bus_space_tag_t;
typedef u_long	bus_addr_t;
typedef u_long	bus_size_t;


typedef struct _bus_space_handle {
        paddr_t		bh_ptr;
#ifdef BUS_SPACE_DEBUG
	bus_space_tag_t	bh_tag;
	bus_size_t	bh_size;
	int		bh_flags;
#endif
} bus_space_handle_t;

/* For buses which have an iospace. */
#define BUS_ADDR_IOSPACE(x)     ((x)>>32)
#define BUS_ADDR_PADDR(x)       ((x)&0xffffffff)
#define BUS_ADDR(io, pa)        ((((bus_addr_t)io)<<32)|(pa))

/*
 * Access methods for bus resources and address space.
 */

struct sparc_bus_space_tag {
	void	*cookie;
	bus_space_tag_t	parent;
	enum bus_type default_type;
        u_int8_t	asi;
        u_int8_t	sasi;
	char	name[32];

	int     (*sparc_bus_alloc)(bus_space_tag_t, 
		bus_space_tag_t,
		bus_addr_t, bus_addr_t,
		bus_size_t, bus_size_t, bus_size_t, 
		int, bus_addr_t *, bus_space_handle_t *);

	void	(*sparc_bus_free)(bus_space_tag_t, 
		bus_space_tag_t,
		bus_space_handle_t, bus_size_t);

	int	(*sparc_bus_map)(bus_space_tag_t,
		bus_space_tag_t,
		bus_addr_t,	bus_size_t,
		int, bus_space_handle_t *);

	int	(*sparc_bus_protect)(bus_space_tag_t,
		bus_space_tag_t,
		bus_space_handle_t, bus_size_t, int);

	int	(*sparc_bus_unmap)(bus_space_tag_t,
		bus_space_tag_t,
		bus_space_handle_t, bus_size_t);

	int	(*sparc_bus_subregion)(bus_space_tag_t,
		bus_space_tag_t,
		bus_space_handle_t, bus_size_t,
		bus_size_t, bus_space_handle_t *);

	paddr_t	(*sparc_bus_mmap)(bus_space_tag_t,
		bus_space_tag_t,
		bus_addr_t, off_t, int, int);

	void	*(*sparc_intr_establish)(bus_space_tag_t,
		bus_space_tag_t,
		int, int, int,
		int (*)(void *), void *,
		const char *);

	bus_addr_t (*sparc_bus_addr)(bus_space_tag_t,
		bus_space_tag_t, bus_space_handle_t);
};

/*
 * Bus space function prototypes.
 */
int		bus_space_alloc(
				bus_space_tag_t,
				bus_addr_t,		/* reg start */
				bus_addr_t,		/* reg end */
				bus_size_t,		/* size */
				bus_size_t,		/* alignment */
				bus_size_t,		/* boundary */
				int,			/* flags */
				bus_addr_t *, 
				bus_space_handle_t *);
void		bus_space_free(
				bus_space_tag_t,
				bus_space_handle_t,
				bus_size_t);
int		bus_space_map(
				bus_space_tag_t,
				bus_addr_t,
				bus_size_t,
				int,			/*flags*/
				bus_space_handle_t *);
int		bus_space_protect(
				bus_space_tag_t,
				bus_space_handle_t,
				bus_size_t,
				int);			/*flags*/
int		bus_space_unmap(
				bus_space_tag_t,
				bus_space_handle_t,
				bus_size_t);
int		bus_space_subregion(
				bus_space_tag_t,
				bus_space_handle_t,
				bus_size_t,
				bus_size_t,
				bus_space_handle_t *);
static void	bus_space_barrier(
				bus_space_tag_t,
				bus_space_handle_t,
				bus_size_t,
				bus_size_t,
				int);
paddr_t		bus_space_mmap(
				bus_space_tag_t,
				bus_addr_t,		/*addr*/
				off_t,			/*offset*/
				int,			/*prot*/
				int);			/*flags*/
void	       *bus_intr_establish(
				bus_space_tag_t,
				int,			/*bus-specific intr*/
				int,			/*device class level,
							  see machine/intr.h*/
				int,			/*flags*/
				int (*)(void *),	/*handler*/
				void *,			/*handler arg*/
				const char *);		/*what*/
void	       *bus_intr_allocate(
				bus_space_tag_t,
				int (*)(void *),	/*handler*/
				void *,			/*handler arg*/
				int,			/*number*/
				int,			/*pil*/
				volatile u_int64_t *,	/*map*/
				volatile u_int64_t *,	/*clr*/
				const char *);		/*what*/
void		bus_intr_free(void *);
void		bus_space_render_tag(
				bus_space_tag_t,
				char *,
				size_t);
void	       *bus_space_vaddr(
				bus_space_tag_t,
				bus_space_handle_t);

#ifdef BUS_SPACE_DEBUG
void bus_space_assert(bus_space_tag_t,
	const bus_space_handle_t *,
	bus_size_t, int);
void bus_space_render_tag(bus_space_tag_t, char*, size_t);
#endif /* BUS_SPACE_DEBUG */


#define _BS_PRECALL(t,f)		\
	while (t->f == NULL)		\
		t = t->parent;
#define _BS_POSTCALL

#define _BS_CALL(t,f)			\
	(*(t)->f)

/* flags for bus_space_barrier() */
#define	BUS_SPACE_BARRIER_READ	0x01		/* force read barrier */
#define	BUS_SPACE_BARRIER_WRITE	0x02		/* force write barrier */

static inline void
bus_space_barrier(t, h, o, s, f)
	bus_space_tag_t t;
	bus_space_handle_t h;
	bus_size_t o;
	bus_size_t s;
	int f;
{
#ifdef notyet
	switch (f) {
	case (BUS_SPACE_BARRIER_READ|BUS_SPACE_BARRIER_WRITE):
		__membar("#LoadLoad|#StoreStore");
		break;
	case BUS_SPACE_BARRIER_READ:
		membar("#LoadLoad");
		break;
	case BUS_SPACE_BARRIER_WRITE:
		membar("#StoreStore");
		break;
	default:
		break;
	}
#else
	__membar("#Sync");
#endif
}

#include <sparc64/sparc64/busop.h>

/* flags for bus space map functions */
#define BUS_SPACE_MAP_CACHEABLE		0x0001
#define BUS_SPACE_MAP_LINEAR		0x0002
#define BUS_SPACE_MAP_READONLY		0x0004
#define BUS_SPACE_MAP_PREFETCHABLE	0x0008
#define BUS_SPACE_MAP_PROMADDRESS	0x0010
#define BUS_SPACE_MAP_BUS1	0x0100	/* placeholders for bus functions... */
#define BUS_SPACE_MAP_BUS2	0x0200
#define BUS_SPACE_MAP_BUS3	0x0400
#define BUS_SPACE_MAP_BUS4	0x0800


/* flags for bus_intr_establish() */
#define BUS_INTR_ESTABLISH_MPSAFE	0x0001
#define BUS_INTR_ESTABLISH_SOFTINTR	0x0002

/*
 * Flags used in various bus DMA methods.
 */
#define	BUS_DMA_WAITOK		0x0000	/* safe to sleep (pseudo-flag) */
#define	BUS_DMA_NOWAIT		0x0001	/* not safe to sleep */
#define	BUS_DMA_ALLOCNOW	0x0002	/* perform resource allocation now */
#define	BUS_DMA_COHERENT	0x0004	/* hint: map memory DMA coherent */
#define	BUS_DMA_NOWRITE		0x0008	/* I suppose the following two should default on */
#define	BUS_DMA_BUS1		0x0010	/* placeholders for bus functions... */
#define	BUS_DMA_BUS2		0x0020
#define	BUS_DMA_BUS3		0x0040
#define	BUS_DMA_BUS4		0x0080
#define	BUS_DMA_STREAMING	0x0100	/* hint: sequential, unidirectional */
#define	BUS_DMA_READ		0x0200	/* mapping is device -> memory only */
#define	BUS_DMA_WRITE		0x0400	/* mapping is memory -> device only */
#define	BUS_DMA_ZERO		0x0800	/* zero memory in dmamem_alloc */
#define	BUS_DMA_OVERRUN		0x1000  /* tolerate DMA overruns */
#define	BUS_DMA_64BIT		0x2000	/* device handles 64bit dva */

#define	BUS_DMA_NOCACHE		BUS_DMA_BUS1
#define	BUS_DMA_DVMA		BUS_DMA_BUS2	/* Don't bother with alignment */
#define	BUS_DMA_24BIT		BUS_DMA_BUS3	/* 24bit device */

#define BUS_DMA_RAW	BUS_DMA_STREAMING

/* Forwards needed by prototypes below. */
struct mbuf;
struct uio;

/*
 * Operations performed by bus_dmamap_sync().
 */
#define	BUS_DMASYNC_PREREAD	0x01	/* pre-read synchronization */
#define	BUS_DMASYNC_POSTREAD	0x02	/* post-read synchronization */
#define	BUS_DMASYNC_PREWRITE	0x04	/* pre-write synchronization */
#define	BUS_DMASYNC_POSTWRITE	0x08	/* post-write synchronization */

typedef struct sparc_bus_dma_tag	*bus_dma_tag_t;
typedef struct sparc_bus_dmamap		*bus_dmamap_t;

/*
 *	bus_dma_segment_t
 *
 *	Describes a single contiguous DMA transaction.  Values
 *	are suitable for programming into DMA registers.
 */
struct sparc_bus_dma_segment {
	bus_addr_t	ds_addr;	/* DVMA address */
	bus_size_t	ds_len;		/* length of transfer */
	/*
	 * The following is to support bus_dmamem_alloc()'s
	 * odd interface.  Only the values in the first
	 * segment are used.  This means that 3/5ths of
	 * most segments are useless space (and mbufs use 1024
	 * segments).
	 */
	bus_size_t	_ds_boundary;	/* don't cross this */
	bus_size_t	_ds_align;	/* align to this */
	void		*_ds_mlist;	/* XXX - dmamap_alloc'ed pages */
};
typedef struct sparc_bus_dma_segment	bus_dma_segment_t;


/*
 *	bus_dma_tag_t
 *
 *	A machine-dependent opaque type describing the implementation of
 *	DMA for a given bus.
 */
struct sparc_bus_dma_tag {
	void	*_cookie;		/* cookie used in the guts */
	struct sparc_bus_dma_tag* _parent;

	/*
	 * DMA mapping methods.
	 */
	int	(*_dmamap_create)(bus_dma_tag_t, bus_dma_tag_t, bus_size_t,
		    int, bus_size_t, bus_size_t, int, bus_dmamap_t *);
	void	(*_dmamap_destroy)(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t);
	int	(*_dmamap_load)(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t,
		    void *, bus_size_t, struct proc *, int);
	int	(*_dmamap_load_mbuf)(bus_dma_tag_t, bus_dma_tag_t,
		    bus_dmamap_t, struct mbuf *, int);
	int	(*_dmamap_load_uio)(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t,
		    struct uio *, int);
	int	(*_dmamap_load_raw)(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t,
		    bus_dma_segment_t *, int, bus_size_t, int);
	void	(*_dmamap_unload)(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t);
	void	(*_dmamap_sync)(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t,
		    bus_addr_t, bus_size_t, int);

	/*
	 * DMA memory utility functions.
	 */
	int	(*_dmamem_alloc)(bus_dma_tag_t, bus_dma_tag_t, bus_size_t,
		    bus_size_t, bus_size_t, bus_dma_segment_t *, int, int *,
		    int);
	void	(*_dmamem_free)(bus_dma_tag_t, bus_dma_tag_t,
		    bus_dma_segment_t *, int);
	int	(*_dmamem_map)(bus_dma_tag_t, bus_dma_tag_t,
		    bus_dma_segment_t *, int, size_t, caddr_t *, int);
	void	(*_dmamem_unmap)(bus_dma_tag_t, bus_dma_tag_t, caddr_t,
		    size_t);
	paddr_t	(*_dmamem_mmap)(bus_dma_tag_t, bus_dma_tag_t,
		    bus_dma_segment_t *, int, off_t, int, int);
};

#define _BD_PRECALL(t,f)		\
	while (t->f == NULL) {		\
		t = t->_parent;		\
	}
#define _BD_CALL(t,f)			\
	(*(t)->f)
#define _BD_POSTCALL

static inline int
bus_dmamap_create(bus_dma_tag_t t, bus_size_t s, int n, bus_size_t m,
    bus_size_t b, int f, bus_dmamap_t *p)
{
	int r;
	const bus_dma_tag_t t0 = t;
	_BD_PRECALL(t, _dmamap_create);
	r = _BD_CALL(t, _dmamap_create)(t, t0, s, n, m, b, f, p);
	_BD_POSTCALL;
	return (r);
}
static inline void
bus_dmamap_destroy(bus_dma_tag_t t, bus_dmamap_t p)
{
	const bus_dma_tag_t t0 = t;
	_BD_PRECALL(t, _dmamap_destroy);
	_BD_CALL(t, _dmamap_destroy)(t, t0, p);
	_BD_POSTCALL;
}
static inline int
bus_dmamap_load(bus_dma_tag_t t, bus_dmamap_t m, void *b, bus_size_t s,
    struct proc *p, int f)
{
	const bus_dma_tag_t t0 = t;
	int r;
	_BD_PRECALL(t, _dmamap_load);
	r = _BD_CALL(t, _dmamap_load)(t, t0, m, b, s, p, f);
	_BD_POSTCALL;
	return (r);
}
static inline int
bus_dmamap_load_mbuf(bus_dma_tag_t t, bus_dmamap_t m, struct mbuf *b,
    int f)
{
	const bus_dma_tag_t t0 = t;
	int r;
	_BD_PRECALL(t, _dmamap_load_mbuf);
	r = _BD_CALL(t, _dmamap_load_mbuf)(t, t0, m, b, f);
	_BD_POSTCALL;
	return (r);
}
static inline int
bus_dmamap_load_uio(bus_dma_tag_t t, bus_dmamap_t m, struct uio * u, int f)
{
	const bus_dma_tag_t t0 = t;
	int r;
	_BD_PRECALL(t, _dmamap_load_uio);
	r = _BD_CALL(t, _dmamap_load_uio)(t, t0, m, u, f);
	_BD_POSTCALL;
	return (r);
}
static inline int
bus_dmamap_load_raw(bus_dma_tag_t t, bus_dmamap_t m, bus_dma_segment_t *sg,
    int n, bus_size_t s, int f)
{
	const bus_dma_tag_t t0 = t;
	int r;
	_BD_PRECALL(t, _dmamap_load_raw);
	r = _BD_CALL(t, _dmamap_load_raw)(t, t0, m, sg, n, s, f);
	_BD_POSTCALL;
	return (r);
}
static inline void
bus_dmamap_unload(bus_dma_tag_t t, bus_dmamap_t p)
{
	const bus_dma_tag_t t0 = t;
	_BD_PRECALL(t, _dmamap_unload);
	_BD_CALL(t, _dmamap_unload)(t, t0, p);
	_BD_POSTCALL;
}
static inline void
bus_dmamap_sync(bus_dma_tag_t t, bus_dmamap_t p, bus_addr_t o, bus_size_t l,
    int ops)
{
	const bus_dma_tag_t t0 = t;
	_BD_PRECALL(t, _dmamap_sync);
	_BD_CALL(t, _dmamap_sync)(t, t0, p, o, l, ops);
	_BD_POSTCALL;
}
static inline int
bus_dmamem_alloc(bus_dma_tag_t t, bus_size_t s, bus_size_t a, bus_size_t b,
    bus_dma_segment_t *sg, int n, int *r, int f)
{
	const bus_dma_tag_t t0 = t;
	int ret;
	_BD_PRECALL(t, _dmamem_alloc);
	ret = _BD_CALL(t, _dmamem_alloc)(t, t0, s, a, b, sg, n, r, f);
	_BD_POSTCALL;
	return (ret);
}
static inline void
bus_dmamem_free(bus_dma_tag_t t, bus_dma_segment_t *sg, int n)
{
	const bus_dma_tag_t t0 = t;
	_BD_PRECALL(t, _dmamem_free);
	_BD_CALL(t, _dmamem_free)(t, t0, sg, n);
	_BD_POSTCALL;
}
static inline int
bus_dmamem_map(bus_dma_tag_t t, bus_dma_segment_t *sg, int n, size_t s,
    caddr_t *k, int f)
{
	const bus_dma_tag_t t0 = t;
	int r;
	_BD_PRECALL(t, _dmamem_map);
	r = _BD_CALL(t, _dmamem_map)(t, t0, sg, n, s, k, f);
	_BD_POSTCALL;
	return (r);
}
static inline void
bus_dmamem_unmap(bus_dma_tag_t t, caddr_t k, size_t s)
{
	const bus_dma_tag_t t0 = t;
	_BD_PRECALL(t, _dmamem_unmap);
	_BD_CALL(t, _dmamem_unmap)(t, t0, k, s);
	_BD_POSTCALL;
}
static inline paddr_t
bus_dmamem_mmap(bus_dma_tag_t t, bus_dma_segment_t *sg, int n, off_t o, int p,
    int f)
{
	const bus_dma_tag_t t0 = t;
	int r;
	_BD_PRECALL(t, _dmamem_mmap);
	r = _BD_CALL(t, _dmamem_mmap)(t, t0, sg, n, o, p, f);
	_BD_POSTCALL;
	return (r);
}

/*
 *	bus_dmamap_t
 *
 *	Describes a DMA mapping.
 */
struct sparc_bus_dmamap {
	/*
	 * PRIVATE MEMBERS: not for use by machine-independent code.
	 */
	bus_addr_t	_dm_dvmastart;	/* start and size of allocated */
	bus_size_t	_dm_dvmasize;	/* DVMA segment for this map */

	bus_size_t	_dm_size;	/* largest DMA transfer mappable */
	bus_size_t	_dm_maxsegsz;	/* largest possible segment */
	bus_size_t	_dm_boundary;	/* don't cross this */
	int		_dm_segcnt;	/* number of segs this map can map */
	int		_dm_flags;	/* misc. flags */
#define _DM_TYPE_LOAD	0
#define _DM_TYPE_SEGS	1
#define _DM_TYPE_UIO	2
#define _DM_TYPE_MBUF	3
	int		_dm_type;	/* mapping type: raw, uio, mbuf, etc */
	void		*_dm_source;	/* source mbuf/uio/etc. for unload */

	void		*_dm_cookie;	/* cookie for bus-specific functions */

	/*
	 * PUBLIC MEMBERS: these are used by machine-independent code.
	 */
	bus_size_t	dm_mapsize;	/* size of the mapping */
	int		dm_nsegs;	/* # valid segments in mapping */

	bus_dma_segment_t dm_segs[1];	/* segments; variable length */
};

#endif /* _MACHINE_BUS_H_ */

@


1.32
log
@add a BUS_DMA_64BIT flag to bus_dma on all our archs.

this is so drivers can advertise that they can handle 64 dma addresses
to the platform. it may choose to handle dmamaps differently based
on this flag.

tweaks and ok tom@@
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.30 2016/05/04 18:26:12 kettenis Exp $	*/
d69 1
a69 1
#include <machine/ctlreg.h>
d322 1
a322 1
		membar(LoadLoad|StoreStore);
d325 1
a325 1
		membar(LoadLoad);
d328 1
a328 1
		membar(StoreStore);
d334 1
a334 1
	membar(Sync);
@


1.31
log
@whitespace tweak. no functional change.
@
text
@d373 1
@


1.30
log
@Some hardware (such as the onboard dc(4) of the Netra X1) has a broken DMA
engine that might attempt to read beyond the end of the buffer that was
programmed.  The IOMMU catches this "DMA overrun" and throws an unrecoverable
error at us, at which point we have no choice but to panic.  To avoid this
implement a BUS_DMA_OVERRUN flag that maps an additional scratch page at the
end of the vdma address range.  DMA requests will spill over into this page,
which just returns zeroes.

Thanks to matthieu@@ for giving me access to a machine with the problem.

ok deraadt@@, beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.29 2013/05/13 17:46:42 kettenis Exp $	*/
d372 1
a372 1
#define BUS_DMA_OVERRUN		0x1000  /* tolerate DMA overruns */
@


1.29
log
@Implement support for running interrupt handlers without taking the kernel
lock, by adding a new BUS_INTR_ESTABLISH_MPSAFE flag for use with the
(sparc64-specific) bus_intr_establish(9) interface.  Add support for this
flag to schizo(4); other bus drivers will ignore it for now.  While there,
remove the BUS_INTR_ESTABLISH_FASTTRAP flag which serves no purpose.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.28 2013/01/22 23:56:31 dlg Exp $	*/
d359 14
a372 13
#define	BUS_DMA_WAITOK		0x000	/* safe to sleep (pseudo-flag) */
#define	BUS_DMA_NOWAIT		0x001	/* not safe to sleep */
#define	BUS_DMA_ALLOCNOW	0x002	/* perform resource allocation now */
#define	BUS_DMA_COHERENT	0x004	/* hint: map memory DMA coherent */
#define	BUS_DMA_NOWRITE		0x008	/* I suppose the following two should default on */
#define	BUS_DMA_BUS1		0x010	/* placeholders for bus functions... */
#define	BUS_DMA_BUS2		0x020
#define	BUS_DMA_BUS3		0x040
#define	BUS_DMA_BUS4		0x080
#define	BUS_DMA_STREAMING	0x100	/* hint: sequential, unidirectional */
#define	BUS_DMA_READ		0x200	/* mapping is device -> memory only */
#define	BUS_DMA_WRITE		0x400	/* mapping is memory -> device only */
#define	BUS_DMA_ZERO		0x800	/* zero memory in dmamem_alloc */
@


1.28
log
@pull the guts of bus_space_barrier into the inline function in the header.
there's only one implementation of it on sparc64, so we shouldnt need to
iterate up a chain of bus_space_tags to get to it.

because the only argument that is used inside the function is the flags,
this can generally be inlined to a single membar opcode. this leaves that
op as membar(Sync) for now while kettenis@@ thinks about what changing it
might mean.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.27 2011/09/27 20:47:30 miod Exp $	*/
d352 3
a354 3
/* flags for intr_establish() */
#define BUS_INTR_ESTABLISH_FASTTRAP	1
#define BUS_INTR_ESTABLISH_SOFTINTR	2
@


1.27
log
@Make bus_addr_t and bus_size_t u_long types, instead of either uint32_t or
uint64_t, depending upon the platform; this makes the declaration of these
types consistent accross all our supported platform, and we do not intend
to support a platform where bus_addr_t could be larger than the size of the
cpu register. Requested by deraadt@@ during s2k11
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.26 2011/03/23 16:54:37 pirofti Exp $	*/
a199 5
	void	(*sparc_bus_barrier)(bus_space_tag_t,
		bus_space_tag_t,
		bus_space_handle_t, bus_size_t,
		bus_size_t, int);

d307 4
d319 17
a335 4
	const bus_space_tag_t t0 = t;
	_BS_PRECALL(t, sparc_bus_barrier);
	_BS_CALL(t, sparc_bus_barrier)(t, t0, h, o, s, f);
	_BS_POSTCALL;
a354 4

/* flags for bus_space_barrier() */
#define	BUS_SPACE_BARRIER_READ	0x01		/* force read barrier */
#define	BUS_SPACE_BARRIER_WRITE	0x02		/* force write barrier */
@


1.26
log
@Normalize sentinel. Use _MACHINE_*_H_ and _<ARCH>_*_H_ properly and consitently.

Discussed and okay drahn@@. Okay deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.25 2009/04/20 00:42:06 oga Exp $	*/
d142 2
a143 2
typedef u_int64_t	bus_addr_t;
typedef u_int64_t	bus_size_t;
@


1.25
log
@Add a BUS_DMA_ZERO flag for bus_dmamem_alloc() to return zeroed memory.

Saves every damned driver calling bzero(), and continues the M_ZERO,
PR_ZERO symmetry.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.24 2008/06/26 05:42:13 ray Exp $	*/
d66 2
a67 2
#ifndef _SPARC_BUS_H_
#define _SPARC_BUS_H_
d86 1
a86 1
#ifndef __SYSTM_H__
d625 1
a625 1
#endif /* _SPARC_BUS_H_ */
@


1.24
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.23 2007/08/04 16:44:15 kettenis Exp $	*/
d363 1
@


1.23
log
@Add sparc_bus_addr member to struct sparc_bus_space_tag.  This function maps
a bus_space_handle_t back to a bus_addr_t.  Needed for rbus.
Only implemented for mainbus(4) and psycho(4) for now; schizo(4) and pyro(4)
will follow soon.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.22 2007/05/29 09:54:25 sobrado Exp $	*/
a19 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.22
log
@use the right capitalization for `SBus'

ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.21 2007/04/10 18:02:48 miod Exp $	*/
d222 2
@


1.21
log
@Remove unused BUS_SPACE_ALIGNED_POINTER, __BUS_SPACE_ADDRESS_SANITY and
__BUS_SPACE_ALIGNED_ADDRESS.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.20 2006/12/30 21:19:24 claudio Exp $	*/
d128 1
a128 1
 * UPA and SBUS spaces are non-cached and big endian
@


1.20
log
@Remove __BUS_SPACE_HAS_STREAM_METHODS, the stream methods are a netbsd-ism.
discussed with miod@@ who has the same changes hiding in one of his trees.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.19 2006/06/07 19:13:07 miod Exp $	*/
a351 2

#define BUS_SPACE_ALIGNED_POINTER(p, t) ALIGNED_POINTER(p, t)
@


1.19
log
@Remove unused bus_space_probe().
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.18 2006/01/06 18:53:05 millert Exp $	*/
a143 2

#define __BUS_SPACE_HAS_STREAM_METHODS	1
@


1.18
log
@Adapt things to use __type_t instead of _BSD_TYPE_T_
Add new sys/_types.h header
Include machine/_types.h or sys/_types.h where applicable
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.17 2005/07/10 00:23:11 brad Exp $	*/
a353 16

/*
 * Device space probe assistant.
 * The optional callback function's arguments are:
 *	the temporary virtual address
 *	the passed `arg' argument
 */
int bus_space_probe(
		bus_space_tag_t,
		bus_addr_t,
		bus_size_t,			/* probe size */
		size_t,				/* offset */
		int,				/* flags */
		int (*)(void *, void *),	/* callback function */
		void *);			/* callback arg */

@


1.17
log
@remove two unused flags
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.16 2003/06/24 21:54:39 henric Exp $	*/
a75 1
#include <machine/types.h>
@


1.16
log
@Add a "where" argument to the sparc64 interrupt code.  This lets us
associate a name with each interrupt handler.  This is not visible
outside the kernel (yet).

ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.15 2003/03/06 08:26:08 henric Exp $	*/
a78 2
#define	__HAS_NEW_BUS_DMAMAP_SYNC

a406 2

#define __HAVE_NEW_BUS_DMAMAP_SYNC
@


1.15
log
@The existing IOMMU code had a rounding problem that was most noticeable
on faster systems under heavy network load.  This replaces some of the
unreadable iommu functions with something a little less dense and a lot
less crash prone.

The bus_dma function pointer/cookie handling was broken.  Change them
to work like the stacked bus_space drivers (where "work" is the key
word).

Tested my many (thanks).

ok jason@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.14 2003/02/17 01:29:20 henric Exp $	*/
d224 2
a225 1
		int (*)(void *), void *);
d286 12
a297 1
				void *);		/*handler arg*/
@


1.14
log
@
Add support for the Sun Enterprise 450
Reduce the size of a GENERIC kernel by ~190k
Remove the nasty pointer/bus_space_handle_t casts
Adds debug bus_space code including the ability to trace
    bus operations (it actually works now).

The following rules are now followed (and verfified by the debug
code):

1.  A "bus_space_handle_t" may only be used with the
    "bus_space_tag_t" that created it.
2.  Only "bus_space_map()" may create "bus_space_handle_t"s.
3.  A "bus_space_handle_t" may not be modified after it has
    been created (other than being destroyed by "bus_space_unmap()").


Thanks to help from mcbride, marc, jason, drahn, to anyone that might
have slipped my mind at the moment.

ok jason@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.13 2002/05/13 19:31:32 jason Exp $	*/
d99 3
a101 1
#define BUS_SPACE_PRINTF(l, s) do { if(bus_space_debug & (l)) printf s; } while(0)
d118 1
a118 1
#else
d127 1
a127 1
#endif
a227 6
#ifdef BUS_SPACE_DEBUG
void bus_space_assert(bus_space_tag_t,
	const bus_space_handle_t *,
	bus_size_t, int);
void bus_space_render_tag(bus_space_tag_t, char*, size_t);
#endif /* BUS_SPACE_DEBUG */
d294 8
d412 7
d439 8
a446 8
	int	(*_dmamap_create)(bus_dma_tag_t, bus_size_t, int,
		    bus_size_t, bus_size_t, int, bus_dmamap_t *);
	void	(*_dmamap_destroy)(bus_dma_tag_t, bus_dmamap_t);
	int	(*_dmamap_load)(bus_dma_tag_t, bus_dmamap_t, void *,
		    bus_size_t, struct proc *, int);
	int	(*_dmamap_load_mbuf)(bus_dma_tag_t, bus_dmamap_t,
		    struct mbuf *, int);
	int	(*_dmamap_load_uio)(bus_dma_tag_t, bus_dmamap_t,
d448 1
a448 1
	int	(*_dmamap_load_raw)(bus_dma_tag_t, bus_dmamap_t,
d450 2
a451 2
	void	(*_dmamap_unload)(bus_dma_tag_t, bus_dmamap_t);
	void	(*_dmamap_sync)(bus_dma_tag_t, bus_dmamap_t,
d457 4
a460 3
	int	(*_dmamem_alloc)(bus_dma_tag_t, bus_size_t, bus_size_t,
		    bus_size_t, bus_dma_segment_t *, int, int *, int);
	void	(*_dmamem_free)(bus_dma_tag_t,
d462 6
a467 5
	int	(*_dmamem_map)(bus_dma_tag_t, bus_dma_segment_t *,
		    int, size_t, caddr_t *, int);
	void	(*_dmamem_unmap)(bus_dma_tag_t, caddr_t, size_t);
	paddr_t	(*_dmamem_mmap)(bus_dma_tag_t, bus_dma_segment_t *,
		    int, off_t, int, int);
d470 136
a605 28
#define	bus_dmamap_create(t, s, n, m, b, f, p)			\
	(*(t)->_dmamap_create)((t), (s), (n), (m), (b), (f), (p))
#define	bus_dmamap_destroy(t, p)				\
	(*(t)->_dmamap_destroy)((t), (p))
#define	bus_dmamap_load(t, m, b, s, p, f)			\
	(*(t)->_dmamap_load)((t), (m), (b), (s), (p), (f))
#define	bus_dmamap_load_mbuf(t, m, b, f)			\
	(*(t)->_dmamap_load_mbuf)((t), (m), (b), (f))
#define	bus_dmamap_load_uio(t, m, u, f)				\
	(*(t)->_dmamap_load_uio)((t), (m), (u), (f))
#define	bus_dmamap_load_raw(t, m, sg, n, s, f)			\
	(*(t)->_dmamap_load_raw)((t), (m), (sg), (n), (s), (f))
#define	bus_dmamap_unload(t, p)					\
	(*(t)->_dmamap_unload)((t), (p))
#define	bus_dmamap_sync(t, p, o, l, ops)			\
	(void)((t)->_dmamap_sync ?				\
	    (*(t)->_dmamap_sync)((t), (p), (o), (l), (ops)) : (void)0)

#define	bus_dmamem_alloc(t, s, a, b, sg, n, r, f)		\
	(*(t)->_dmamem_alloc)((t), (s), (a), (b), (sg), (n), (r), (f))
#define	bus_dmamem_free(t, sg, n)				\
	(*(t)->_dmamem_free)((t), (sg), (n))
#define	bus_dmamem_map(t, sg, n, s, k, f)			\
	(*(t)->_dmamem_map)((t), (sg), (n), (s), (k), (f))
#define	bus_dmamem_unmap(t, k, s)				\
	(*(t)->_dmamem_unmap)((t), (k), (s))
#define	bus_dmamem_mmap(t, sg, n, o, p, f)			\
	(*(t)->_dmamem_mmap)((t), (sg), (n), (o), (p), (f))
d628 2
a629 2
	int		_dm_type;	/* type of mapping: raw, uio, mbuf, etc */
	void		*_dm_source;	/* source mbuf, uio, etc. needed for unload */
d638 1
a640 34

#ifdef _SPARC_BUS_DMA_PRIVATE
int	_bus_dmamap_create(bus_dma_tag_t, bus_size_t, int, bus_size_t,
	    bus_size_t, int, bus_dmamap_t *);
void	_bus_dmamap_destroy(bus_dma_tag_t, bus_dmamap_t);
int	_bus_dmamap_load(bus_dma_tag_t, bus_dmamap_t, void *,
	    bus_size_t, struct proc *, int);
int	_bus_dmamap_load_mbuf(bus_dma_tag_t, bus_dmamap_t,
	    struct mbuf *, int);
int	_bus_dmamap_load_uio(bus_dma_tag_t, bus_dmamap_t,
	    struct uio *, int);
int	_bus_dmamap_load_raw(bus_dma_tag_t, bus_dmamap_t,
	    bus_dma_segment_t *, int, bus_size_t, int);
void	_bus_dmamap_unload(bus_dma_tag_t, bus_dmamap_t);
void	_bus_dmamap_sync(bus_dma_tag_t, bus_dmamap_t, bus_addr_t,
	    bus_size_t, int);

int	_bus_dmamem_alloc(bus_dma_tag_t tag, bus_size_t size,
	    bus_size_t alignment, bus_size_t boundary,
	    bus_dma_segment_t *segs, int nsegs, int *rsegs, int flags);
void	_bus_dmamem_free(bus_dma_tag_t tag, bus_dma_segment_t *segs,
	    int nsegs);
int	_bus_dmamem_map(bus_dma_tag_t tag, bus_dma_segment_t *segs,
	    int nsegs, size_t size, caddr_t *kvap, int flags);
void	_bus_dmamem_unmap(bus_dma_tag_t tag, caddr_t kva,
	    size_t size);
paddr_t	_bus_dmamem_mmap(bus_dma_tag_t tag, bus_dma_segment_t *segs,
	    int nsegs, off_t off, int prot, int flags);

int	_bus_dmamem_alloc_range(bus_dma_tag_t tag, bus_size_t size,
	    bus_size_t alignment, bus_size_t boundary,
	    bus_dma_segment_t *segs, int nsegs, int *rsegs, int flags,
	    vaddr_t low, vaddr_t high);
#endif /* _SPARC_BUS_DMA_PRIVATE */
@


1.13
log
@add BUS_DMA_24BIT flag (for braindead lance implementations)
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.12 2002/03/14 03:16:00 millert Exp $	*/
d87 3
d92 36
a142 2
extern int bus_type_asi[];
extern int bus_stream_asi[];
d151 1
a151 2
typedef	u_int64_t	bus_space_handle_t;
typedef enum bus_type	bus_type_t;
d155 10
d166 3
a168 3
#define	BUS_ADDR_IOSPACE(x)	((x)>>32)
#define	BUS_ADDR_PADDR(x)	((x)&0xffffffff)
#define	BUS_ADDR(io, pa)	(((io)<<32)|(pa))
a172 1
typedef struct sparc_bus_space_tag	*bus_space_tag_t;
d175 1
a175 1
	void		*cookie;
d177 4
a180 1
	int		type;
d183 1
d189 1
d193 7
a199 2
		bus_type_t, bus_addr_t,	bus_size_t,
		int, vaddr_t, bus_space_handle_t *);
d202 1
d206 1
d211 1
d216 1
d220 1
d226 6
a231 17
#if 0
/*
 * The following macro could be used to generate the bus_space*() functions
 * but it uses a gcc extension and is ANSI-only.
#define PROTO_bus_space_xxx(bus_space_tag_t t, ...)
#define RETURNTYPE_bus_space_xxx	void *
#define BUSFUN(name, returntype, t, args...)			\
	__inline__ RETURNTYPE_##name				\
	bus_##name PROTO_##name					\
	{							\
		while (t->sparc_##name == NULL)			\
			t = t->parent;				\
		return (*(t)->sparc_##name)(t, args);		\
	}
 */
#endif

d235 1
a235 1
static int	bus_space_alloc(
d245 1
a245 1
static void	bus_space_free(
d249 1
a249 1
static int	bus_space_map(
d255 1
a255 1
static int	bus_space_map2(
d257 1
a257 2
				bus_type_t,
				bus_addr_t,
d259 2
a260 4
				int,			/*flags*/
				vaddr_t,		/*preferred vaddr*/
				bus_space_handle_t *);
static int	bus_space_unmap(
d264 1
a264 1
static int	bus_space_subregion(
d276 1
a276 1
static paddr_t	bus_space_mmap(
d282 1
a282 1
static void	*bus_intr_establish(
d290 7
d298 4
a302 1
/* This macro finds the first "upstream" implementation of method `f' */
d304 1
a304 27
	while (t->f == NULL)		\
		t = t->parent;		\
	return (*(t)->f)

__inline__ int
bus_space_alloc(t, rs, re, s, a, b, f, ap, hp)
	bus_space_tag_t t;
	bus_addr_t	rs;
	bus_addr_t	re;
	bus_size_t	s;
	bus_size_t	a;
	bus_size_t	b;
	int		f;
	bus_addr_t	*ap;
	bus_space_handle_t *hp;
{
	_BS_CALL(t, sparc_bus_alloc)(t, rs, re, s, a, b, f, ap, hp);
}

__inline__ void
bus_space_free(t, h, s)
	bus_space_tag_t	t;
	bus_space_handle_t	h;
	bus_size_t	s;
{
	_BS_CALL(t, sparc_bus_free)(t, h, s);
}
d306 1
a306 68
__inline__ int
bus_space_map(t, a, s, f, hp)
	bus_space_tag_t	t;
	bus_addr_t	a;
	bus_size_t	s;
	int		f;
	bus_space_handle_t *hp;
{
	_BS_CALL(t, sparc_bus_map)(t, 0, a, s, f, 0, hp);
}

__inline__ int
bus_space_map2(t, bt, a, s, f, v, hp)
	bus_space_tag_t	t;
	bus_type_t	bt;
	bus_addr_t	a;
	bus_size_t	s;
	int		f;
	vaddr_t	v;
	bus_space_handle_t *hp;
{
	_BS_CALL(t, sparc_bus_map)(t, bt, a, s, f, v, hp);
}

__inline__ int
bus_space_unmap(t, h, s)
	bus_space_tag_t t;
	bus_space_handle_t h;
	bus_size_t	s;
{
	_BS_CALL(t, sparc_bus_unmap)(t, h, s);
}

__inline__ int
bus_space_subregion(t, h, o, s, hp)
	bus_space_tag_t	t;
	bus_space_handle_t h;
	bus_size_t	o;
	bus_size_t	s;
	bus_space_handle_t *hp;
{
	_BS_CALL(t, sparc_bus_subregion)(t, h, o, s, hp);
}

__inline__ paddr_t
bus_space_mmap(t, a, o, p, f)
	bus_space_tag_t	t;
	bus_addr_t	a;
	off_t		o;
	int		p;
	int		f;
{
	_BS_CALL(t, sparc_bus_mmap)(t, a, o, p, f);
}

__inline__ void *
bus_intr_establish(t, p, l, f, h, a)
	bus_space_tag_t t;
	int	p;
	int	l;
	int	f;
	int	(*h)(void *);
	void	*a;
{
	_BS_CALL(t, sparc_intr_establish)(t, p, l, f, h, a);
}

__inline__ void
d314 4
a317 1
	_BS_CALL(t, sparc_bus_barrier)(t, h, o, s, f);
d320 1
a320 6
#if 1
/* XXXX Things get complicated if we use unmapped register accesses. */
#define	bus_space_vaddr(t, h)	(vaddr_t)(h)
#else
void * bus_space_vaddr(bus_space_tag_t space, bus_space_handle_t handle);
#endif
d327 1
a349 1
		bus_type_t,
a357 1016
/*
 *	u_intN_t bus_space_read_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset);
 *
 * Read a 1, 2, 4, or 8 byte quantity from bus space
 * described by tag/handle/offset.
 */
#ifndef BUS_SPACE_DEBUG
#define	bus_space_read_1(t, h, o)					\
	    lduba((h) + (o), bus_type_asi[(t)->type])

#define	bus_space_read_2(t, h, o)					\
	    lduha((h) + (o), bus_type_asi[(t)->type])

#define	bus_space_read_4(t, h, o)					\
	    lda((h) + (o), bus_type_asi[(t)->type])

#define	bus_space_read_8(t, h, o)					\
	    ldxa((h) + (o), bus_type_asi[(t)->type])
#else
#define	bus_space_read_1(t, h, o) ({					\
	unsigned char __bv =				      		\
	    lduba((h) + (o), bus_type_asi[(t)->type]);			\
	if (bus_space_debug & BSDB_ACCESS)				\
	printf("bsr1(%llx + %llx, %x) -> %x\n", (long long)(h),		\
		(long long)(o),						\
		bus_type_asi[(t)->type], (unsigned int) __bv);		\
	__bv; })

#define	bus_space_read_2(t, h, o) ({					\
	unsigned short __bv =				      		\
	    lduha((h) + (o), bus_type_asi[(t)->type]);			\
	if (bus_space_debug & BSDB_ACCESS)				\
	printf("bsr2(%llx + %llx, %x) -> %x\n", (long long)(h),		\
		(long long)(o),						\
		bus_type_asi[(t)->type], (unsigned int)__bv);		\
	__bv; })

#define	bus_space_read_4(t, h, o) ({					\
	unsigned int __bv =				      		\
	    lda((h) + (o), bus_type_asi[(t)->type]);			\
	if (bus_space_debug & BSDB_ACCESS)				\
	printf("bsr4(%llx + %llx, %x) -> %x\n", (long long)(h),		\
		(long long)(o),						\
		bus_type_asi[(t)->type], __bv);				\
	__bv; })

#define	bus_space_read_8(t, h, o) ({					\
	u_int64_t __bv =				      		\
	    ldxa((h) + (o), bus_type_asi[(t)->type]);			\
	if (bus_space_debug & BSDB_ACCESS)				\
	printf("bsr8(%llx + %llx, %x) -> %llx\n", (long long)(h),	\
		(long long)(o),						\
		bus_type_asi[(t)->type], (long long)__bv);		\
	__bv; })
#endif
/*
 *	void bus_space_read_multi_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset,
 *	    u_intN_t *addr, size_t count);
 *
 * Read `count' 1, 2, 4, or 8 byte quantities from bus space
 * described by tag/handle/offset and copy into buffer provided.
 */

#define	bus_space_read_multi_1(t, h, o, a, c) do {			\
	int i = c;							\
	u_int8_t *p = (u_int8_t *)a;					\
	while (i-- > 0)							\
		*p++ = bus_space_read_1(t, h, o);			\
} while (0)

#define	bus_space_read_multi_2(t, h, o, a, c) do {			\
	int i = c;							\
	u_int16_t *p = (u_int16_t *)a;					\
	while (i-- > 0)							\
		*p++ = bus_space_read_2(t, h, o);			\
} while (0)

#define	bus_space_read_multi_4(t, h, o, a, c) do {			\
	int i = c;							\
	u_int32_t *p = (u_int32_t *)a;					\
	while (i-- > 0)							\
		*p++ = bus_space_read_4(t, h, o);			\
} while (0)

#define	bus_space_read_multi_8(t, h, o, a, c) do {			\
	int i = c;							\
	u_int64_t *p = (u_int64_t *)a;					\
	while (i-- > 0)							\
		*p++ = bus_space_read_8(t, h, o);			\
} while (0)

/*
 *	void bus_space_write_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset,
 *	    u_intN_t value);
 *
 * Write the 1, 2, 4, or 8 byte value `value' to bus space
 * described by tag/handle/offset.
 */
#ifndef BUS_SPACE_DEBUG
#define	bus_space_write_1(t, h, o, v)					\
	((void)(stba((h) + (o), bus_type_asi[(t)->type], (v))))

#define	bus_space_write_2(t, h, o, v)					\
	((void)(stha((h) + (o), bus_type_asi[(t)->type], (v))))

#define	bus_space_write_4(t, h, o, v)					\
	((void)(sta((h) + (o), bus_type_asi[(t)->type], (v))))

#define	bus_space_write_8(t, h, o, v)					\
	((void)(stxa((h) + (o), bus_type_asi[(t)->type], (v))))
#else
#define	bus_space_write_1(t, h, o, v) ({				\
	if (bus_space_debug & BSDB_ACCESS)				\
	printf("bsw1(%llx + %llx, %x) <- %x\n", (long long)(h),		\
		(long long)(o),						\
		bus_type_asi[(t)->type], (unsigned int) v);		\
	((void)(stba((h) + (o), bus_type_asi[(t)->type], (v))));  })

#define	bus_space_write_2(t, h, o, v) ({				\
	if (bus_space_debug & BSDB_ACCESS)				\
	printf("bsw2(%llx + %llx, %x) <- %x\n", (long long)(h),		\
		(long long)(o),						\
		bus_type_asi[(t)->type], (unsigned int) v);		\
	((void)(stha((h) + (o), bus_type_asi[(t)->type], (v)))); })

#define	bus_space_write_4(t, h, o, v) ({				\
	if (bus_space_debug & BSDB_ACCESS)				\
	printf("bsw4(%llx + %llx, %x) <- %x\n", (long long)(h),		\
		(long long)(o),						\
		bus_type_asi[(t)->type], (unsigned int) v);		\
	((void)(sta((h) + (o), bus_type_asi[(t)->type], (v)))); })

#define	bus_space_write_8(t, h, o, v) ({				\
	if (bus_space_debug & BSDB_ACCESS)				\
	printf("bsw8(%llx + %llx, %x) <- %llx\n", (long long)(h),	\
		(long long)(o),						\
		bus_type_asi[(t)->type], (long long) v);		\
	((void)(stxa((h) + (o), bus_type_asi[(t)->type], (v)))); })
#endif
/*
 *	void bus_space_write_multi_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset,
 *	    const u_intN_t *addr, size_t count);
 *
 * Write `count' 1, 2, 4, or 8 byte quantities from the buffer
 * provided to bus space described by tag/handle/offset.
 */

#define	bus_space_write_multi_1(t, h, o, a, c) do {			\
	int i = c;							\
	u_int8_t *p = (u_int8_t *)a;					\
	while (i-- > 0)							\
		bus_space_write_1(t, h, o, *p++);			\
} while (0)

#define bus_space_write_multi_2(t, h, o, a, c) do {			\
	int i = c;							\
	u_int16_t *p = (u_int16_t *)a;					\
	while (i-- > 0)							\
		bus_space_write_2(t, h, o, *p++);			\
} while (0)

#define bus_space_write_multi_4(t, h, o, a, c) do {			\
	int i = c;							\
	u_int32_t *p = (u_int32_t *)a;					\
	while (i-- > 0)							\
		bus_space_write_4(t, h, o, *p++);			\
} while (0)

#define bus_space_write_multi_8(t, h, o, a, c) do {			\
	int i = c;							\
	u_int64_t *p = (u_int64_t *)a;					\
	while (i-- > 0)							\
		bus_space_write_8(t, h, o, *p++);			\
} while (0)

/*
 *	void bus_space_set_multi_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset, u_intN_t val,
 *	    size_t count);
 *
 * Write the 1, 2, 4, or 8 byte value `val' to bus space described
 * by tag/handle/offset `count' times.
 */

#define bus_space_set_multi_1(t, h, o, v, c) do {			\
	int i = c;							\
	while (i-- > 0)							\
		bus_space_write_1(t, h, o, v);				\
} while (0)

#define bus_space_set_multi_2(t, h, o, v, c) do {			\
	int i = c;							\
	while (i-- > 0)							\
		bus_space_write_2(t, h, o, v);				\
} while (0)

#define bus_space_set_multi_4(t, h, o, v, c) do {			\
	int i = c;							\
	while (i-- > 0)							\
		bus_space_write_4(t, h, o, v);				\
} while (0)

#define bus_space_set_multi_8(t, h, o, v, c) do {			\
	int i = c;							\
	while (i-- > 0)							\
		bus_space_write_8(t, h, o, v);				\
} while (0)

/*
 *	void bus_space_read_region_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t off,
 *	    u_intN_t *addr, bus_size_t count);
 *
 */
static void bus_space_read_region_1(bus_space_tag_t,
	bus_space_handle_t,
	bus_size_t,
	u_int8_t *,
	bus_size_t);
static void bus_space_read_region_2(bus_space_tag_t,
	bus_space_handle_t,
	bus_size_t,
	u_int16_t *,
	bus_size_t);
static void bus_space_read_region_4(bus_space_tag_t,
	bus_space_handle_t,
	bus_size_t,
	u_int32_t *,
	bus_size_t);
static void bus_space_read_region_8(bus_space_tag_t,
	bus_space_handle_t,
	bus_size_t,
	u_int64_t *,
	bus_size_t);

static __inline__ void
bus_space_read_region_1(t, h, o, a, c)
	bus_space_tag_t		t;
	bus_space_handle_t	h;
	bus_size_t		o, c;
	u_int8_t		*a;
{
	for (; c; a++, c--, o++)
		*a = bus_space_read_1(t, h, o);
}
static __inline__ void
bus_space_read_region_2(t, h, o, a, c)
	bus_space_tag_t		t;
	bus_space_handle_t	h;
	bus_size_t		o, c;
	u_int16_t		*a;
{
	for (; c; a++, c--, o+=2)
		*a = bus_space_read_2(t, h, o);
 }
static __inline__ void
bus_space_read_region_4(t, h, o, a, c)
	bus_space_tag_t		t;
	bus_space_handle_t	h;
	bus_size_t		o, c;
	u_int32_t		*a;
{
	for (; c; a++, c--, o+=4)
		*a = bus_space_read_4(t, h, o);
}
static __inline__ void
bus_space_read_region_8(t, h, o, a, c)
	bus_space_tag_t		t;
	bus_space_handle_t	h;
	bus_size_t		o, c;
	u_int64_t		*a;
{
	for (; c; a++, c--, o+=8)
		*a = bus_space_read_8(t, h, o);
}

/*
 *	void bus_space_write_region_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t off,
 *	    u_intN_t *addr, bus_size_t count);
 *
 */
static void bus_space_write_region_1(bus_space_tag_t,
	bus_space_handle_t,
	bus_size_t,
	const u_int8_t *,
	bus_size_t);
static void bus_space_write_region_2(bus_space_tag_t,
	bus_space_handle_t,
	bus_size_t,
	const u_int16_t *,
	bus_size_t);
static void bus_space_write_region_4(bus_space_tag_t,
	bus_space_handle_t,
	bus_size_t,
	const u_int32_t *,
	bus_size_t);
static void bus_space_write_region_8(bus_space_tag_t,
	bus_space_handle_t,
	bus_size_t,
	const u_int64_t *,
	bus_size_t);
static __inline__ void
bus_space_write_region_1(t, h, o, a, c)
	bus_space_tag_t		t;
	bus_space_handle_t	h;
	bus_size_t		o, c;
	const u_int8_t		*a;
{
	for (; c; a++, c--, o++)
		bus_space_write_1(t, h, o, *a);
}

static __inline__ void
bus_space_write_region_2(t, h, o, a, c)
	bus_space_tag_t		t;
	bus_space_handle_t	h;
	bus_size_t		o, c;
	const u_int16_t		*a;
{
	for (; c; a++, c--, o+=2)
		bus_space_write_2(t, h, o, *a);
}

static __inline__ void
bus_space_write_region_4(t, h, o, a, c)
	bus_space_tag_t		t;
	bus_space_handle_t	h;
	bus_size_t		o, c;
	const u_int32_t		*a;
{
	for (; c; a++, c--, o+=4)
		bus_space_write_4(t, h, o, *a);
}

static __inline__ void
bus_space_write_region_8(t, h, o, a, c)
	bus_space_tag_t		t;
	bus_space_handle_t	h;
	bus_size_t		o, c;
	const u_int64_t		*a;
{
	for (; c; a++, c--, o+=8)
		bus_space_write_8(t, h, o, *a);
}


/*
 *	void bus_space_set_region_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t off,
 *	    u_intN_t *addr, bus_size_t count);
 *
 */
static void bus_space_set_region_1(bus_space_tag_t,
	bus_space_handle_t,
	bus_size_t,
	const u_int8_t,
	bus_size_t);
static void bus_space_set_region_2(bus_space_tag_t,
	bus_space_handle_t,
	bus_size_t,
	const u_int16_t,
	bus_size_t);
static void bus_space_set_region_4(bus_space_tag_t,
	bus_space_handle_t,
	bus_size_t,
	const u_int32_t,
	bus_size_t);
static void bus_space_set_region_8(bus_space_tag_t,
	bus_space_handle_t,
	bus_size_t,
	const u_int64_t,
	bus_size_t);

static __inline__ void
bus_space_set_region_1(t, h, o, v, c)
	bus_space_tag_t		t;
	bus_space_handle_t	h;
	bus_size_t		o, c;
	const u_int8_t		v;
{
	for (; c; c--, o++)
		bus_space_write_1(t, h, o, v);
}

static __inline__ void
bus_space_set_region_2(t, h, o, v, c)
	bus_space_tag_t		t;
	bus_space_handle_t	h;
	bus_size_t		o, c;
	const u_int16_t		v;
{
	for (; c; c--, o+=2)
		bus_space_write_2(t, h, o, v);
}

static __inline__ void
bus_space_set_region_4(t, h, o, v, c)
	bus_space_tag_t		t;
	bus_space_handle_t	h;
	bus_size_t		o, c;
	const u_int32_t		v;
{
	for (; c; c--, o+=4)
		bus_space_write_4(t, h, o, v);
}

static __inline__ void
bus_space_set_region_8(t, h, o, v, c)
	bus_space_tag_t		t;
	bus_space_handle_t	h;
	bus_size_t		o, c;
	const u_int64_t		v;
{
	for (; c; c--, o+=8)
		bus_space_write_8(t, h, o, v);
}


/*
 *	void bus_space_copy_region_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh1, bus_size_t off1,
 *	    bus_space_handle_t bsh2, bus_size_t off2,
 *	    bus_size_t count);
 *
 * Copy `count' 1, 2, 4, or 8 byte values from bus space starting
 * at tag/bsh1/off1 to bus space starting at tag/bsh2/off2.
 */
static void bus_space_copy_region_1(bus_space_tag_t,
	bus_space_handle_t,
	bus_size_t,
	bus_space_handle_t,
	bus_size_t,
	bus_size_t);
static void bus_space_copy_region_2(bus_space_tag_t,
	bus_space_handle_t,
	bus_size_t,
	bus_space_handle_t,
	bus_size_t,
	bus_size_t);
static void bus_space_copy_region_4(bus_space_tag_t,
	bus_space_handle_t,
	bus_size_t,
	bus_space_handle_t,
	bus_size_t,
	bus_size_t);
static void bus_space_copy_region_8(bus_space_tag_t,
	bus_space_handle_t,
	bus_size_t,
	bus_space_handle_t,
	bus_size_t,
	bus_size_t);


static __inline__ void
bus_space_copy_region_1(t, h1, o1, h2, o2, c)
	bus_space_tag_t		t;
	bus_space_handle_t	h1, h2;
	bus_size_t		o1, o2;
	bus_size_t		c;
{
	for (; c; c--, o1++, o2++)
	    bus_space_write_1(t, h1, o1, bus_space_read_1(t, h2, o2));
}

static __inline__ void
bus_space_copy_region_2(t, h1, o1, h2, o2, c)
	bus_space_tag_t		t;
	bus_space_handle_t	h1, h2;
	bus_size_t		o1, o2;
	bus_size_t		c;
{
	for (; c; c--, o1+=2, o2+=2)
	    bus_space_write_2(t, h1, o1, bus_space_read_2(t, h2, o2));
}

static __inline__ void
bus_space_copy_region_4(t, h1, o1, h2, o2, c)
	bus_space_tag_t		t;
	bus_space_handle_t	h1, h2;
	bus_size_t		o1, o2;
	bus_size_t		c;
{
	for (; c; c--, o1+=4, o2+=4)
	    bus_space_write_4(t, h1, o1, bus_space_read_4(t, h2, o2));
}

static __inline__ void
bus_space_copy_region_8(t, h1, o1, h2, o2, c)
	bus_space_tag_t		t;
	bus_space_handle_t	h1, h2;
	bus_size_t		o1, o2;
	bus_size_t		c;
{
	for (; c; c--, o1+=8, o2+=8)
	    bus_space_write_8(t, h1, o1, bus_space_read_8(t, h2, o2));
}

/*
 *	u_intN_t bus_space_read_stream_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset);
 *
 * Read a 1, 2, 4, or 8 byte quantity from bus space
 * described by tag/handle/offset.
 */
#ifndef BUS_SPACE_DEBUG
#define	bus_space_read_stream_1(t, h, o)				\
	    lduba((h) + (o), bus_stream_asi[(t)->type])

#define	bus_space_read_stream_2(t, h, o)				\
	    lduha((h) + (o), bus_stream_asi[(t)->type])

#define	bus_space_read_stream_4(t, h, o)				\
	    lda((h) + (o), bus_stream_asi[(t)->type])

#define	bus_space_read_stream_8(t, h, o)				\
	    ldxa((h) + (o), bus_stream_asi[(t)->type])
#else
#define	bus_space_read_stream_1(t, h, o) ({				\
	unsigned char __bv =				      		\
	    lduba((h) + (o), bus_stream_asi[(t)->type]);		\
	if (bus_space_debug & BSDB_ACCESS)				\
	printf("bsr1(%llx + %llx, %x) -> %x\n", (long long)(h),		\
		(long long)(o),						\
		bus_stream_asi[(t)->type], (unsigned int) __bv);	\
	__bv; })

#define	bus_space_read_stream_2(t, h, o) ({				\
	unsigned short __bv =				      		\
	    lduha((h) + (o), bus_stream_asi[(t)->type]);		\
	if (bus_space_debug & BSDB_ACCESS)				\
	printf("bsr2(%llx + %llx, %x) -> %x\n", (long long)(h),		\
		(long long)(o),						\
		bus_stream_asi[(t)->type], (unsigned int)__bv);		\
	__bv; })

#define	bus_space_read_stream_4(t, h, o) ({				\
	unsigned int __bv =				      		\
	    lda((h) + (o), bus_stream_asi[(t)->type]);			\
	if (bus_space_debug & BSDB_ACCESS)				\
	printf("bsr4(%llx + %llx, %x) -> %x\n", (long long)(h),		\
		(long long)(o),						\
		bus_stream_asi[(t)->type], __bv);			\
	__bv; })

#define	bus_space_read_stream_8(t, h, o) ({				\
	u_int64_t __bv =				      		\
	    ldxa((h) + (o), bus_stream_asi[(t)->type]);			\
	if (bus_space_debug & BSDB_ACCESS)				\
	printf("bsr8(%llx + %llx, %x) -> %llx\n", (long long)(h),	\
		(long long)(o),						\
		bus_stream_asi[(t)->type], (long long)__bv);		\
	__bv; })
#endif
/*
 *	void bus_space_read_multi_stream_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset,
 *	    u_intN_t *addr, size_t count);
 *
 * Read `count' 1, 2, 4, or 8 byte quantities from bus space
 * described by tag/handle/offset and copy into buffer provided.
 */

#define	bus_space_read_multi_stream_1(t, h, o, a, c) do {		\
	int i = c;							\
	u_int8_t *p = (u_int8_t *)a;					\
	while (i-- > 0)							\
		*p++ = bus_space_read_stream_1(t, h, o);		\
} while (0)

#define	bus_space_read_multi_stream_2(t, h, o, a, c) do {		\
	int i = c;							\
	u_int16_t *p = (u_int16_t *)a;					\
	while (i-- > 0)							\
		*p++ = bus_space_read_stream_2(t, h, o);		\
} while (0)

#define	bus_space_read_multi_stream_4(t, h, o, a, c) do {		\
	int i = c;							\
	u_int32_t *p = (u_int32_t *)a;					\
	while (i-- > 0)							\
		*p++ = bus_space_read_stream_4(t, h, o);		\
} while (0)

#define	bus_space_read_multi_stream_8(t, h, o, a, c) do {		\
	int i = c;							\
	u_int64_t *p = (u_int64_t *)a;					\
	while (i-- > 0)							\
		*p++ = bus_space_read_stream_8(t, h, o);		\
} while (0)

/*
 *	void bus_space_write_stream_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset,
 *	    u_intN_t value);
 *
 * Write the 1, 2, 4, or 8 byte value `value' to bus space
 * described by tag/handle/offset.
 */
#ifndef BUS_SPACE_DEBUG
#define	bus_space_write_stream_1(t, h, o, v)				\
	((void)(stba((h) + (o), bus_stream_asi[(t)->type], (v))))

#define	bus_space_write_stream_2(t, h, o, v)				\
	((void)(stha((h) + (o), bus_stream_asi[(t)->type], (v))))

#define	bus_space_write_stream_4(t, h, o, v)				\
	((void)(sta((h) + (o), bus_stream_asi[(t)->type], (v))))

#define	bus_space_write_stream_8(t, h, o, v)				\
	((void)(stxa((h) + (o), bus_stream_asi[(t)->type], (v))))
#else
#define	bus_space_write_stream_1(t, h, o, v) ({				\
	if (bus_space_debug & BSDB_ACCESS)				\
	printf("bsw1(%llx + %llx, %x) <- %x\n", (long long)(h),		\
		(long long)(o),						\
		bus_stream_asi[(t)->type], (unsigned int) v);		\
	((void)(stba((h) + (o), bus_stream_asi[(t)->type], (v))));  })

#define	bus_space_write_stream_2(t, h, o, v) ({				\
	if (bus_space_debug & BSDB_ACCESS)				\
	printf("bsw2(%llx + %llx, %x) <- %x\n", (long long)(h),		\
		(long long)(o),						\
		bus_stream_asi[(t)->type], (unsigned int) v);		\
	((void)(stha((h) + (o), bus_stream_asi[(t)->type], (v)))); })

#define	bus_space_write_stream_4(t, h, o, v) ({				\
	if (bus_space_debug & BSDB_ACCESS)				\
	printf("bsw4(%llx + %llx, %x) <- %x\n", (long long)(h),		\
		(long long)(o),						\
		bus_stream_asi[(t)->type], (unsigned int) v);		\
	((void)(sta((h) + (o), bus_stream_asi[(t)->type], (v)))); })

#define	bus_space_write_stream_8(t, h, o, v) ({				\
	if (bus_space_debug & BSDB_ACCESS)				\
	printf("bsw8(%llx + %llx, %x) <- %llx\n", (long long)(h),	\
		(long long)(o),						\
		bus_stream_asi[(t)->type], (long long) v);		\
	((void)(stxa((h) + (o), bus_stream_asi[(t)->type], (v)))); })
#endif
/*
 *	void bus_space_write_multi_stream_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset,
 *	    const u_intN_t *addr, size_t count);
 *
 * Write `count' 1, 2, 4, or 8 byte quantities from the buffer
 * provided to bus space described by tag/handle/offset.
 */

#define	bus_space_write_multi_stream_1(t, h, o, a, c) do {		\
	int i = c;							\
	u_int8_t *p = (u_int8_t *)a;					\
	while (i-- > 0)							\
		bus_space_write_stream_1(t, h, o, *p++);		\
} while (0)

#define bus_space_write_multi_stream_2(t, h, o, a, c) do {		\
	int i = c;							\
	u_int16_t *p = (u_int16_t *)a;					\
	while (i-- > 0)							\
		bus_space_write_stream_2(t, h, o, *p++);		\
} while (0)

#define bus_space_write_multi_stream_4(t, h, o, a, c) do {		\
	int i = c;							\
	u_int32_t *p = (u_int32_t *)a;					\
	while (i-- > 0)							\
		bus_space_write_stream_4(t, h, o, *p++);		\
} while (0)

#define bus_space_write_multi_stream_8(t, h, o, a, c) do {		\
	int i = c;							\
	u_int64_t *p = (u_int64_t *)a;					\
	while (i-- > 0)							\
		bus_space_write_stream_8(t, h, o, *p++);		\
} while (0)

/*
 *	void bus_space_set_multi_stream_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset, u_intN_t val,
 *	    size_t count);
 *
 * Write the 1, 2, 4, or 8 byte value `val' to bus space described
 * by tag/handle/offset `count' times.
 */

#define bus_space_set_multi_stream_1(t, h, o, v, c) do {		\
	int i = c;							\
	while (i-- > 0)							\
		bus_space_write_stream_1(t, h, o, v);			\
} while (0)

#define bus_space_set_multi_stream_2(t, h, o, v, c) do {		\
	int i = c;							\
	while (i-- > 0)							\
		bus_space_write_stream_2(t, h, o, v);			\
} while (0)

#define bus_space_set_multi_stream_4(t, h, o, v, c) do {		\
	int i = c;							\
	while (i-- > 0)							\
		bus_space_write_stream_4(t, h, o, v);			\
} while (0)

#define bus_space_set_multi_stream_8(t, h, o, v, c) do {		\
	int i = c;							\
	while (i-- > 0)							\
		bus_space_write_stream_8(t, h, o, v);			\
} while (0)

/*
 *	void bus_space_read_region_stream_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t off,
 *	    u_intN_t *addr, bus_size_t count);
 *
 */
static void bus_space_read_region_stream_1(bus_space_tag_t,
	bus_space_handle_t,
	bus_size_t,
	u_int8_t *,
	bus_size_t);
static void bus_space_read_region_stream_2(bus_space_tag_t,
	bus_space_handle_t,
	bus_size_t,
	u_int16_t *,
	bus_size_t);
static void bus_space_read_region_stream_4(bus_space_tag_t,
	bus_space_handle_t,
	bus_size_t,
	u_int32_t *,
	bus_size_t);
static void bus_space_read_region_stream_8(bus_space_tag_t,
	bus_space_handle_t,
	bus_size_t,
	u_int64_t *,
	bus_size_t);

static __inline__ void
bus_space_read_region_stream_1(t, h, o, a, c)
	bus_space_tag_t		t;
	bus_space_handle_t	h;
	bus_size_t		o, c;
	u_int8_t		*a;
{
	for (; c; a++, c--, o++)
		*a = bus_space_read_stream_1(t, h, o);
}
static __inline__ void
bus_space_read_region_stream_2(t, h, o, a, c)
	bus_space_tag_t		t;
	bus_space_handle_t	h;
	bus_size_t		o, c;
	u_int16_t		*a;
{
	for (; c; a++, c--, o+=2)
		*a = bus_space_read_stream_2(t, h, o);
 }
static __inline__ void
bus_space_read_region_stream_4(t, h, o, a, c)
	bus_space_tag_t		t;
	bus_space_handle_t	h;
	bus_size_t		o, c;
	u_int32_t		*a;
{
	for (; c; a++, c--, o+=4)
		*a = bus_space_read_stream_4(t, h, o);
}
static __inline__ void
bus_space_read_region_stream_8(t, h, o, a, c)
	bus_space_tag_t		t;
	bus_space_handle_t	h;
	bus_size_t		o, c;
	u_int64_t		*a;
{
	for (; c; a++, c--, o+=8)
		*a = bus_space_read_stream_8(t, h, o);
}

/*
 *	void bus_space_write_region_stream_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t off,
 *	    u_intN_t *addr, bus_size_t count);
 *
 */
static void bus_space_write_region_stream_1(bus_space_tag_t,
	bus_space_handle_t,
	bus_size_t,
	const u_int8_t *,
	bus_size_t);
static void bus_space_write_region_stream_2(bus_space_tag_t,
	bus_space_handle_t,
	bus_size_t,
	const u_int16_t *,
	bus_size_t);
static void bus_space_write_region_stream_4(bus_space_tag_t,
	bus_space_handle_t,
	bus_size_t,
	const u_int32_t *,
	bus_size_t);
static void bus_space_write_region_stream_8(bus_space_tag_t,
	bus_space_handle_t,
	bus_size_t,
	const u_int64_t *,
	bus_size_t);
static __inline__ void
bus_space_write_region_stream_1(t, h, o, a, c)
	bus_space_tag_t		t;
	bus_space_handle_t	h;
	bus_size_t		o, c;
	const u_int8_t		*a;
{
	for (; c; a++, c--, o++)
		bus_space_write_stream_1(t, h, o, *a);
}

static __inline__ void
bus_space_write_region_stream_2(t, h, o, a, c)
	bus_space_tag_t		t;
	bus_space_handle_t	h;
	bus_size_t		o, c;
	const u_int16_t		*a;
{
	for (; c; a++, c--, o+=2)
		bus_space_write_stream_2(t, h, o, *a);
}

static __inline__ void
bus_space_write_region_stream_4(t, h, o, a, c)
	bus_space_tag_t		t;
	bus_space_handle_t	h;
	bus_size_t		o, c;
	const u_int32_t		*a;
{
	for (; c; a++, c--, o+=4)
		bus_space_write_stream_4(t, h, o, *a);
}

static __inline__ void
bus_space_write_region_stream_8(t, h, o, a, c)
	bus_space_tag_t		t;
	bus_space_handle_t	h;
	bus_size_t		o, c;
	const u_int64_t		*a;
{
	for (; c; a++, c--, o+=8)
		bus_space_write_stream_8(t, h, o, *a);
}


/*
 *	void bus_space_set_region_stream_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t off,
 *	    u_intN_t *addr, bus_size_t count);
 *
 */
static void bus_space_set_region_stream_1(bus_space_tag_t,
	bus_space_handle_t,
	bus_size_t,
	const u_int8_t,
	bus_size_t);
static void bus_space_set_region_stream_2(bus_space_tag_t,
	bus_space_handle_t,
	bus_size_t,
	const u_int16_t,
	bus_size_t);
static void bus_space_set_region_stream_4(bus_space_tag_t,
	bus_space_handle_t,
	bus_size_t,
	const u_int32_t,
	bus_size_t);
static void bus_space_set_region_stream_8(bus_space_tag_t,
	bus_space_handle_t,
	bus_size_t,
	const u_int64_t,
	bus_size_t);

static __inline__ void
bus_space_set_region_stream_1(t, h, o, v, c)
	bus_space_tag_t		t;
	bus_space_handle_t	h;
	bus_size_t		o, c;
	const u_int8_t		v;
{
	for (; c; c--, o++)
		bus_space_write_stream_1(t, h, o, v);
}

static __inline__ void
bus_space_set_region_stream_2(t, h, o, v, c)
	bus_space_tag_t		t;
	bus_space_handle_t	h;
	bus_size_t		o, c;
	const u_int16_t		v;
{
	for (; c; c--, o+=2)
		bus_space_write_stream_2(t, h, o, v);
}

static __inline__ void
bus_space_set_region_stream_4(t, h, o, v, c)
	bus_space_tag_t		t;
	bus_space_handle_t	h;
	bus_size_t		o, c;
	const u_int32_t		v;
{
	for (; c; c--, o+=4)
		bus_space_write_stream_4(t, h, o, v);
}

static __inline__ void
bus_space_set_region_stream_8(t, h, o, v, c)
	bus_space_tag_t		t;
	bus_space_handle_t	h;
	bus_size_t		o, c;
	const u_int64_t		v;
{
	for (; c; c--, o+=8)
		bus_space_write_stream_8(t, h, o, v);
}


/*
 *	void bus_space_copy_region_stream_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh1, bus_size_t off1,
 *	    bus_space_handle_t bsh2, bus_size_t off2,
 *	    bus_size_t count);
 *
 * Copy `count' 1, 2, 4, or 8 byte values from bus space starting
 * at tag/bsh1/off1 to bus space starting at tag/bsh2/off2.
 */
static void bus_space_copy_region_stream_1(bus_space_tag_t,
	bus_space_handle_t,
	bus_size_t,
	bus_space_handle_t,
	bus_size_t,
	bus_size_t);
static void bus_space_copy_region_stream_2(bus_space_tag_t,
	bus_space_handle_t,
	bus_size_t,
	bus_space_handle_t,
	bus_size_t,
	bus_size_t);
static void bus_space_copy_region_stream_4(bus_space_tag_t,
	bus_space_handle_t,
	bus_size_t,
	bus_space_handle_t,
	bus_size_t,
	bus_size_t);
static void bus_space_copy_region_stream_8(bus_space_tag_t,
	bus_space_handle_t,
	bus_size_t,
	bus_space_handle_t,
	bus_size_t,
	bus_size_t);


static __inline__ void
bus_space_copy_region_stream_1(t, h1, o1, h2, o2, c)
	bus_space_tag_t		t;
	bus_space_handle_t	h1, h2;
	bus_size_t		o1, o2;
	bus_size_t		c;
{
	for (; c; c--, o1++, o2++)
	    bus_space_write_stream_1(t, h1, o1, bus_space_read_stream_1(t, h2, o2));
}

static __inline__ void
bus_space_copy_region_stream_2(t, h1, o1, h2, o2, c)
	bus_space_tag_t		t;
	bus_space_handle_t	h1, h2;
	bus_size_t		o1, o2;
	bus_size_t		c;
{
	for (; c; c--, o1+=2, o2+=2)
	    bus_space_write_stream_2(t, h1, o1, bus_space_read_stream_2(t, h2, o2));
}

static __inline__ void
bus_space_copy_region_stream_4(t, h1, o1, h2, o2, c)
	bus_space_tag_t		t;
	bus_space_handle_t	h1, h2;
	bus_size_t		o1, o2;
	bus_size_t		c;
{
	for (; c; c--, o1+=4, o2+=4)
	    bus_space_write_stream_4(t, h1, o1, bus_space_read_stream_4(t, h2, o2));
}

static __inline__ void
bus_space_copy_region_stream_8(t, h1, o1, h2, o2, c)
	bus_space_tag_t		t;
	bus_space_handle_t	h1, h2;
	bus_size_t		o1, o2;
	bus_size_t		c;
{
	for (; c; c--, o1+=8, o2+=8)
	    bus_space_write_stream_8(t, h1, o1, bus_space_read_8(t, h2, o2));
}

/* OpenBSD "raw" wrappers around the NetBSD "stream" methods. */
/* XXXART - I'm lazy so I'll only implement the ones I need. */
#define BUS_DMA_RAW	BUS_DMA_STREAMING
#define bus_space_read_raw_multi_2(t, h, o, a, c) \
	bus_space_read_multi_stream_2(t, h, o, (u_int8_t *)(a), c/2)
#define bus_space_write_raw_multi_2(t, h, o, a, c) \
	bus_space_write_multi_stream_2(t, h, o, (u_int8_t *)(a), c/2)
#define bus_space_read_raw_multi_4(t, h, o, a, c) \
	bus_space_read_multi_stream_4(t, h, o, (u_int8_t *)(a), c/4)
#define bus_space_write_raw_multi_4(t, h, o, a, c) \
	bus_space_write_multi_stream_4(t, h, o, (u_int8_t *)(a), c/4)

d380 2
d555 1
@


1.12
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.11 2002/03/14 01:26:45 millert Exp $	*/
d1433 1
@


1.11
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.10 2002/03/07 18:08:08 jason Exp $	*/
d160 1
a160 1
	void	*(*sparc_intr_establish) __P((bus_space_tag_t,
d162 1
a162 1
		int (*)(void *), void *));
d236 1
a236 1
static void	*bus_intr_establish __P((
d243 1
a243 1
				void *));		/*handler arg*/
d386 1
a386 1
int bus_space_probe __P((
d394 1
a394 1
		void *));			/* callback arg */
@


1.10
log
@Clean up BUS_DMA_* flags, and make sure all arch's define:
BUS_DMA_READ, BUS_DMA_WRITE, and BUS_DMA_STREAMING
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.9 2002/02/19 05:03:42 jason Exp $	*/
d134 1
a134 1
	int     (*sparc_bus_alloc) __P((bus_space_tag_t, 
d137 1
a137 1
		int, bus_addr_t *, bus_space_handle_t *));
d139 2
a140 2
	void	(*sparc_bus_free) __P((bus_space_tag_t, 
		bus_space_handle_t, bus_size_t));
d142 1
a142 1
	int	(*sparc_bus_map) __P((bus_space_tag_t,
d144 1
a144 1
		int, vaddr_t, bus_space_handle_t *));
d146 2
a147 2
	int	(*sparc_bus_unmap) __P((bus_space_tag_t,
		bus_space_handle_t, bus_size_t));
d149 1
a149 1
	int	(*sparc_bus_subregion) __P((bus_space_tag_t,
d151 1
a151 1
		bus_size_t, bus_space_handle_t *));
d153 1
a153 1
	void	(*sparc_bus_barrier) __P((bus_space_tag_t,
d155 1
a155 1
		bus_size_t, int));
d157 2
a158 2
	paddr_t	(*sparc_bus_mmap) __P((bus_space_tag_t,
		bus_addr_t, off_t, int, int));
d162 1
a162 1
		int (*) __P((void *)), void *));
d170 1
a170 1
#define PROTO_bus_space_xxx		__P((bus_space_tag_t t, ...))
d186 1
a186 1
static int	bus_space_alloc __P((
d195 2
a196 2
				bus_space_handle_t *));
static void	bus_space_free __P((
d199 2
a200 2
				bus_size_t));
static int	bus_space_map __P((
d205 2
a206 2
				bus_space_handle_t *));
static int	bus_space_map2 __P((
d213 2
a214 2
				bus_space_handle_t *));
static int	bus_space_unmap __P((
d217 2
a218 2
				bus_size_t));
static int	bus_space_subregion __P((
d223 2
a224 2
				bus_space_handle_t *));
static void	bus_space_barrier __P((
d229 2
a230 2
				int));
static paddr_t	bus_space_mmap __P((
d235 1
a235 1
				int));			/*flags*/
d242 1
a242 1
				int (*) __P((void *)),	/*handler*/
d337 1
a337 1
	int	(*h)__P((void *));
d358 1
a358 1
void * bus_space_vaddr __P((bus_space_tag_t space, bus_space_handle_t handle));
d393 1
a393 1
		int (*) __P((void *, void *)),	/* callback function */
d398 2
a399 2
 *	u_intN_t bus_space_read_N __P((bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset));
d454 1
a454 1
 *	void bus_space_read_multi_N __P((bus_space_tag_t tag,
d456 1
a456 1
 *	    u_intN_t *addr, size_t count));
d491 1
a491 1
 *	void bus_space_write_N __P((bus_space_tag_t tag,
d493 1
a493 1
 *	    u_intN_t value));
d540 1
a540 1
 *	void bus_space_write_multi_N __P((bus_space_tag_t tag,
d542 1
a542 1
 *	    const u_intN_t *addr, size_t count));
d577 1
a577 1
 *	void bus_space_set_multi_N __P((bus_space_tag_t tag,
d579 1
a579 1
 *	    size_t count));
d610 1
a610 1
 *	void bus_space_read_region_N __P((bus_space_tag_t tag,
d612 1
a612 1
 *	    u_intN_t *addr, bus_size_t count));
d615 1
a615 1
static void bus_space_read_region_1 __P((bus_space_tag_t,
d619 2
a620 2
	bus_size_t));
static void bus_space_read_region_2 __P((bus_space_tag_t,
d624 2
a625 2
	bus_size_t));
static void bus_space_read_region_4 __P((bus_space_tag_t,
d629 2
a630 2
	bus_size_t));
static void bus_space_read_region_8 __P((bus_space_tag_t,
d634 1
a634 1
	bus_size_t));
d678 1
a678 1
 *	void bus_space_write_region_N __P((bus_space_tag_t tag,
d680 1
a680 1
 *	    u_intN_t *addr, bus_size_t count));
d683 1
a683 1
static void bus_space_write_region_1 __P((bus_space_tag_t,
d687 2
a688 2
	bus_size_t));
static void bus_space_write_region_2 __P((bus_space_tag_t,
d692 2
a693 2
	bus_size_t));
static void bus_space_write_region_4 __P((bus_space_tag_t,
d697 2
a698 2
	bus_size_t));
static void bus_space_write_region_8 __P((bus_space_tag_t,
d702 1
a702 1
	bus_size_t));
d749 1
a749 1
 *	void bus_space_set_region_N __P((bus_space_tag_t tag,
d751 1
a751 1
 *	    u_intN_t *addr, bus_size_t count));
d754 1
a754 1
static void bus_space_set_region_1 __P((bus_space_tag_t,
d758 2
a759 2
	bus_size_t));
static void bus_space_set_region_2 __P((bus_space_tag_t,
d763 2
a764 2
	bus_size_t));
static void bus_space_set_region_4 __P((bus_space_tag_t,
d768 2
a769 2
	bus_size_t));
static void bus_space_set_region_8 __P((bus_space_tag_t,
d773 1
a773 1
	bus_size_t));
d821 1
a821 1
 *	void bus_space_copy_region_N __P((bus_space_tag_t tag,
d824 1
a824 1
 *	    bus_size_t count));
d829 1
a829 1
static void bus_space_copy_region_1 __P((bus_space_tag_t,
d834 2
a835 2
	bus_size_t));
static void bus_space_copy_region_2 __P((bus_space_tag_t,
d840 2
a841 2
	bus_size_t));
static void bus_space_copy_region_4 __P((bus_space_tag_t,
d846 2
a847 2
	bus_size_t));
static void bus_space_copy_region_8 __P((bus_space_tag_t,
d852 1
a852 1
	bus_size_t));
d900 2
a901 2
 *	u_intN_t bus_space_read_stream_N __P((bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset));
d956 1
a956 1
 *	void bus_space_read_multi_stream_N __P((bus_space_tag_t tag,
d958 1
a958 1
 *	    u_intN_t *addr, size_t count));
d993 1
a993 1
 *	void bus_space_write_stream_N __P((bus_space_tag_t tag,
d995 1
a995 1
 *	    u_intN_t value));
d1042 1
a1042 1
 *	void bus_space_write_multi_stream_N __P((bus_space_tag_t tag,
d1044 1
a1044 1
 *	    const u_intN_t *addr, size_t count));
d1079 1
a1079 1
 *	void bus_space_set_multi_stream_N __P((bus_space_tag_t tag,
d1081 1
a1081 1
 *	    size_t count));
d1112 1
a1112 1
 *	void bus_space_read_region_stream_N __P((bus_space_tag_t tag,
d1114 1
a1114 1
 *	    u_intN_t *addr, bus_size_t count));
d1117 1
a1117 1
static void bus_space_read_region_stream_1 __P((bus_space_tag_t,
d1121 2
a1122 2
	bus_size_t));
static void bus_space_read_region_stream_2 __P((bus_space_tag_t,
d1126 2
a1127 2
	bus_size_t));
static void bus_space_read_region_stream_4 __P((bus_space_tag_t,
d1131 2
a1132 2
	bus_size_t));
static void bus_space_read_region_stream_8 __P((bus_space_tag_t,
d1136 1
a1136 1
	bus_size_t));
d1180 1
a1180 1
 *	void bus_space_write_region_stream_N __P((bus_space_tag_t tag,
d1182 1
a1182 1
 *	    u_intN_t *addr, bus_size_t count));
d1185 1
a1185 1
static void bus_space_write_region_stream_1 __P((bus_space_tag_t,
d1189 2
a1190 2
	bus_size_t));
static void bus_space_write_region_stream_2 __P((bus_space_tag_t,
d1194 2
a1195 2
	bus_size_t));
static void bus_space_write_region_stream_4 __P((bus_space_tag_t,
d1199 2
a1200 2
	bus_size_t));
static void bus_space_write_region_stream_8 __P((bus_space_tag_t,
d1204 1
a1204 1
	bus_size_t));
d1251 1
a1251 1
 *	void bus_space_set_region_stream_N __P((bus_space_tag_t tag,
d1253 1
a1253 1
 *	    u_intN_t *addr, bus_size_t count));
d1256 1
a1256 1
static void bus_space_set_region_stream_1 __P((bus_space_tag_t,
d1260 2
a1261 2
	bus_size_t));
static void bus_space_set_region_stream_2 __P((bus_space_tag_t,
d1265 2
a1266 2
	bus_size_t));
static void bus_space_set_region_stream_4 __P((bus_space_tag_t,
d1270 2
a1271 2
	bus_size_t));
static void bus_space_set_region_stream_8 __P((bus_space_tag_t,
d1275 1
a1275 1
	bus_size_t));
d1323 1
a1323 1
 *	void bus_space_copy_region_stream_N __P((bus_space_tag_t tag,
d1326 1
a1326 1
 *	    bus_size_t count));
d1331 1
a1331 1
static void bus_space_copy_region_stream_1 __P((bus_space_tag_t,
d1336 2
a1337 2
	bus_size_t));
static void bus_space_copy_region_stream_2 __P((bus_space_tag_t,
d1342 2
a1343 2
	bus_size_t));
static void bus_space_copy_region_stream_4 __P((bus_space_tag_t,
d1348 2
a1349 2
	bus_size_t));
static void bus_space_copy_region_stream_8 __P((bus_space_tag_t,
d1354 1
a1354 1
	bus_size_t));
d1480 14
a1493 14
	int	(*_dmamap_create) __P((bus_dma_tag_t, bus_size_t, int,
		    bus_size_t, bus_size_t, int, bus_dmamap_t *));
	void	(*_dmamap_destroy) __P((bus_dma_tag_t, bus_dmamap_t));
	int	(*_dmamap_load) __P((bus_dma_tag_t, bus_dmamap_t, void *,
		    bus_size_t, struct proc *, int));
	int	(*_dmamap_load_mbuf) __P((bus_dma_tag_t, bus_dmamap_t,
		    struct mbuf *, int));
	int	(*_dmamap_load_uio) __P((bus_dma_tag_t, bus_dmamap_t,
		    struct uio *, int));
	int	(*_dmamap_load_raw) __P((bus_dma_tag_t, bus_dmamap_t,
		    bus_dma_segment_t *, int, bus_size_t, int));
	void	(*_dmamap_unload) __P((bus_dma_tag_t, bus_dmamap_t));
	void	(*_dmamap_sync) __P((bus_dma_tag_t, bus_dmamap_t,
		    bus_addr_t, bus_size_t, int));
d1498 9
a1506 9
	int	(*_dmamem_alloc) __P((bus_dma_tag_t, bus_size_t, bus_size_t,
		    bus_size_t, bus_dma_segment_t *, int, int *, int));
	void	(*_dmamem_free) __P((bus_dma_tag_t,
		    bus_dma_segment_t *, int));
	int	(*_dmamem_map) __P((bus_dma_tag_t, bus_dma_segment_t *,
		    int, size_t, caddr_t *, int));
	void	(*_dmamem_unmap) __P((bus_dma_tag_t, caddr_t, size_t));
	paddr_t	(*_dmamem_mmap) __P((bus_dma_tag_t, bus_dma_segment_t *,
		    int, off_t, int, int));
d1573 14
a1586 14
int	_bus_dmamap_create __P((bus_dma_tag_t, bus_size_t, int, bus_size_t,
	    bus_size_t, int, bus_dmamap_t *));
void	_bus_dmamap_destroy __P((bus_dma_tag_t, bus_dmamap_t));
int	_bus_dmamap_load __P((bus_dma_tag_t, bus_dmamap_t, void *,
	    bus_size_t, struct proc *, int));
int	_bus_dmamap_load_mbuf __P((bus_dma_tag_t, bus_dmamap_t,
	    struct mbuf *, int));
int	_bus_dmamap_load_uio __P((bus_dma_tag_t, bus_dmamap_t,
	    struct uio *, int));
int	_bus_dmamap_load_raw __P((bus_dma_tag_t, bus_dmamap_t,
	    bus_dma_segment_t *, int, bus_size_t, int));
void	_bus_dmamap_unload __P((bus_dma_tag_t, bus_dmamap_t));
void	_bus_dmamap_sync __P((bus_dma_tag_t, bus_dmamap_t, bus_addr_t,
	    bus_size_t, int));
d1588 1
a1588 1
int	_bus_dmamem_alloc __P((bus_dma_tag_t tag, bus_size_t size,
d1590 9
a1598 9
	    bus_dma_segment_t *segs, int nsegs, int *rsegs, int flags));
void	_bus_dmamem_free __P((bus_dma_tag_t tag, bus_dma_segment_t *segs,
	    int nsegs));
int	_bus_dmamem_map __P((bus_dma_tag_t tag, bus_dma_segment_t *segs,
	    int nsegs, size_t size, caddr_t *kvap, int flags));
void	_bus_dmamem_unmap __P((bus_dma_tag_t tag, caddr_t kva,
	    size_t size));
paddr_t	_bus_dmamem_mmap __P((bus_dma_tag_t tag, bus_dma_segment_t *segs,
	    int nsegs, off_t off, int prot, int flags));
d1600 1
a1600 1
int	_bus_dmamem_alloc_range __P((bus_dma_tag_t tag, bus_size_t size,
d1603 1
a1603 1
	    vaddr_t low, vaddr_t high));
@


1.9
log
@From NetBSD:
change some debug printfs to make gcc happy
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.8 2002/02/05 18:34:39 jason Exp $	*/
d1423 1
a1423 1
#define	BUS_DMA_BUS1		0x010	
a1429 1

@


1.8
log
@Implement vgafb_mmap() fully
From NetBSD: change bus_space_mmap() prototype to standard one
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.7 2001/09/26 21:30:27 jason Exp $	*/
d421 2
a422 2
	printf("bsr1(%llx + %llx, %x) -> %x\n", (u_int64_t)(h),		\
		(u_int64_t)(o),						\
d430 2
a431 2
	printf("bsr2(%llx + %llx, %x) -> %x\n", (u_int64_t)(h),		\
		(u_int64_t)(o),						\
d439 2
a440 2
	printf("bsr4(%llx + %llx, %x) -> %x\n", (u_int64_t)(h),		\
		(u_int64_t)(o),						\
d448 3
a450 3
	printf("bsr8(%llx + %llx, %x) -> %llx\n", (u_int64_t)(h),	\
		(u_int64_t)(o),						\
		bus_type_asi[(t)->type], __bv);				\
d513 2
a514 2
	printf("bsw1(%llx + %llx, %x) <- %x\n", (u_int64_t)(h),		\
		(u_int64_t)(o),						\
d520 2
a521 2
	printf("bsw2(%llx + %llx, %x) <- %x\n", (u_int64_t)(h),		\
		(u_int64_t)(o),						\
d527 2
a528 2
	printf("bsw4(%llx + %llx, %x) <- %x\n", (u_int64_t)(h),		\
		(u_int64_t)(o),						\
d534 3
a536 3
	printf("bsw8(%llx + %llx, %x) <- %llx\n", (u_int64_t)(h),	\
		(u_int64_t)(o),						\
		bus_type_asi[(t)->type], (u_int64_t) v);		\
d921 1
a921 1
	    lduba((h) + (o), bus_stream_asi[(t)->type]);			\
d923 3
a925 3
	printf("bsr1(%llx + %llx, %x) -> %x\n", (u_int64_t)(h),		\
		(u_int64_t)(o),						\
		bus_stream_asi[(t)->type], (unsigned int) __bv);		\
d930 1
a930 1
	    lduha((h) + (o), bus_stream_asi[(t)->type]);			\
d932 2
a933 2
	printf("bsr2(%llx + %llx, %x) -> %x\n", (u_int64_t)(h),		\
		(u_int64_t)(o),						\
d937 1
a937 1
#define	bus_space_read_stream_4(t, h, o) ({					\
d941 3
a943 3
	printf("bsr4(%llx + %llx, %x) -> %x\n", (u_int64_t)(h),		\
		(u_int64_t)(o),						\
		bus_stream_asi[(t)->type], __bv);				\
d946 1
a946 1
#define	bus_space_read_stream_8(t, h, o) ({					\
d950 3
a952 3
	printf("bsr8(%llx + %llx, %x) -> %llx\n", (u_int64_t)(h),	\
		(u_int64_t)(o),						\
		bus_stream_asi[(t)->type], __bv);				\
d964 1
a964 1
#define	bus_space_read_multi_stream_1(t, h, o, a, c) do {			\
d968 1
a968 1
		*p++ = bus_space_read_stream_1(t, h, o);			\
d971 1
a971 1
#define	bus_space_read_multi_stream_2(t, h, o, a, c) do {			\
d975 1
a975 1
		*p++ = bus_space_read_stream_2(t, h, o);			\
d978 1
a978 1
#define	bus_space_read_multi_stream_4(t, h, o, a, c) do {			\
d982 1
a982 1
		*p++ = bus_space_read_stream_4(t, h, o);			\
d985 1
a985 1
#define	bus_space_read_multi_stream_8(t, h, o, a, c) do {			\
d989 1
a989 1
		*p++ = bus_space_read_stream_8(t, h, o);			\
d1001 1
a1001 1
#define	bus_space_write_stream_1(t, h, o, v)					\
d1004 1
a1004 1
#define	bus_space_write_stream_2(t, h, o, v)					\
d1007 1
a1007 1
#define	bus_space_write_stream_4(t, h, o, v)					\
d1010 1
a1010 1
#define	bus_space_write_stream_8(t, h, o, v)					\
d1015 2
a1016 2
	printf("bsw1(%llx + %llx, %x) <- %x\n", (u_int64_t)(h),		\
		(u_int64_t)(o),						\
d1022 2
a1023 2
	printf("bsw2(%llx + %llx, %x) <- %x\n", (u_int64_t)(h),		\
		(u_int64_t)(o),						\
d1029 2
a1030 2
	printf("bsw4(%llx + %llx, %x) <- %x\n", (u_int64_t)(h),		\
		(u_int64_t)(o),						\
d1036 3
a1038 3
	printf("bsw8(%llx + %llx, %x) <- %llx\n", (u_int64_t)(h),	\
		(u_int64_t)(o),						\
		bus_stream_asi[(t)->type], (u_int64_t) v);		\
d1050 1
a1050 1
#define	bus_space_write_multi_stream_1(t, h, o, a, c) do {			\
d1054 1
a1054 1
		bus_space_write_stream_1(t, h, o, *p++);			\
d1057 1
a1057 1
#define bus_space_write_multi_stream_2(t, h, o, a, c) do {			\
d1061 1
a1061 1
		bus_space_write_stream_2(t, h, o, *p++);			\
d1064 1
a1064 1
#define bus_space_write_multi_stream_4(t, h, o, a, c) do {			\
d1068 1
a1068 1
		bus_space_write_stream_4(t, h, o, *p++);			\
d1071 1
a1071 1
#define bus_space_write_multi_stream_8(t, h, o, a, c) do {			\
d1075 1
a1075 1
		bus_space_write_stream_8(t, h, o, *p++);			\
d1087 1
a1087 1
#define bus_space_set_multi_stream_1(t, h, o, v, c) do {			\
d1090 1
a1090 1
		bus_space_write_stream_1(t, h, o, v);				\
d1093 1
a1093 1
#define bus_space_set_multi_stream_2(t, h, o, v, c) do {			\
d1096 1
a1096 1
		bus_space_write_stream_2(t, h, o, v);				\
d1099 1
a1099 1
#define bus_space_set_multi_stream_4(t, h, o, v, c) do {			\
d1102 1
a1102 1
		bus_space_write_stream_4(t, h, o, v);				\
d1105 1
a1105 1
#define bus_space_set_multi_stream_8(t, h, o, v, c) do {			\
d1108 1
a1108 1
		bus_space_write_stream_8(t, h, o, v);				\
@


1.7
log
@missed in previous merge with NetBSD:
handle dma boundaries better
@
text
@d1 2
a2 2
/*	$OpenBSD: bus.h,v 1.6 2001/09/06 14:04:35 art Exp $	*/
/*	$NetBSD: bus.h,v 1.28 2001/07/19 15:32:19 thorpej Exp $	*/
d119 5
d134 29
a162 41
	int	(*sparc_bus_map) __P((
				bus_space_tag_t,
				bus_type_t,
				bus_addr_t,
				bus_size_t,
				int,			/*flags*/
				vaddr_t,		/*preferred vaddr*/
				bus_space_handle_t *));
	int	(*sparc_bus_unmap) __P((
				bus_space_tag_t,
				bus_space_handle_t,
				bus_size_t));
	int	(*sparc_bus_subregion) __P((
				bus_space_tag_t,
				bus_space_handle_t,
				bus_size_t,		/*offset*/
				bus_size_t,		/*size*/
				bus_space_handle_t *));

	void	(*sparc_bus_barrier) __P((
				bus_space_tag_t,
				bus_space_handle_t,
				bus_size_t,		/*offset*/
				bus_size_t,		/*size*/
				int));			/*flags*/

	int	(*sparc_bus_mmap) __P((
				bus_space_tag_t,
				bus_type_t,		/**/
				bus_addr_t,		/**/
				int,			/*flags*/
				bus_space_handle_t *));

	void	*(*sparc_intr_establish) __P((
				bus_space_tag_t,
				int,			/*bus-specific intr*/
				int,			/*device class level,
							  see machine/intr.h*/
				int,			/*flags*/
				int (*) __P((void *)),	/*handler*/
				void *));		/*handler arg*/
d186 14
d230 1
a230 1
static int	bus_space_mmap __P((
d232 4
a235 4
				bus_type_t,		/**/
				bus_addr_t,		/**/
				int,			/*flags*/
				bus_space_handle_t *));
d253 24
d284 1
a284 1
	_BS_CALL(t, sparc_bus_map)((t), 0, (a), (s), (f), 0, (hp));
d320 2
a321 2
__inline__ int
bus_space_mmap(t, bt, a, f, hp)
a322 1
	bus_type_t	bt;
d324 2
a326 1
	bus_space_handle_t *hp;
d328 1
a328 1
	_BS_CALL(t, sparc_bus_mmap)(t, bt, a, f, hp);
d354 5
a358 8

#if 0
int	bus_space_alloc __P((bus_space_tag_t t, bus_addr_t rstart,
	    bus_addr_t rend, bus_size_t size, bus_size_t align,
	    bus_size_t boundary, int flags, bus_addr_t *addrp,
	    bus_space_handle_t *bshp));
void	bus_space_free __P((bus_space_tag_t t, bus_space_handle_t bsh,
	    bus_size_t size));
@


1.7.6.1
log
@Sync UBC branch to -current
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: bus.h,v 1.31 2001/09/21 15:30:41 wiz Exp $	*/
a118 5
/* For buses which have an iospace. */
#define	BUS_ADDR_IOSPACE(x)	((x)>>32)
#define	BUS_ADDR_PADDR(x)	((x)&0xffffffff)
#define	BUS_ADDR(io, pa)	(((io)<<32)|(pa))

d129 41
a169 29
	int     (*sparc_bus_alloc)(bus_space_tag_t, 
		bus_addr_t, bus_addr_t,
		bus_size_t, bus_size_t, bus_size_t, 
		int, bus_addr_t *, bus_space_handle_t *);

	void	(*sparc_bus_free)(bus_space_tag_t, 
		bus_space_handle_t, bus_size_t);

	int	(*sparc_bus_map)(bus_space_tag_t,
		bus_type_t, bus_addr_t,	bus_size_t,
		int, vaddr_t, bus_space_handle_t *);

	int	(*sparc_bus_unmap)(bus_space_tag_t,
		bus_space_handle_t, bus_size_t);

	int	(*sparc_bus_subregion)(bus_space_tag_t,
		bus_space_handle_t, bus_size_t,
		bus_size_t, bus_space_handle_t *);

	void	(*sparc_bus_barrier)(bus_space_tag_t,
		bus_space_handle_t, bus_size_t,
		bus_size_t, int);

	paddr_t	(*sparc_bus_mmap)(bus_space_tag_t,
		bus_addr_t, off_t, int, int);

	void	*(*sparc_intr_establish)(bus_space_tag_t,
		int, int, int,
		int (*)(void *), void *);
d177 1
a177 1
#define PROTO_bus_space_xxx(bus_space_tag_t t, ...)
d193 1
a193 15
static int	bus_space_alloc(
				bus_space_tag_t,
				bus_addr_t,		/* reg start */
				bus_addr_t,		/* reg end */
				bus_size_t,		/* size */
				bus_size_t,		/* alignment */
				bus_size_t,		/* boundary */
				int,			/* flags */
				bus_addr_t *, 
				bus_space_handle_t *);
static void	bus_space_free(
				bus_space_tag_t,
				bus_space_handle_t,
				bus_size_t);
static int	bus_space_map(
d198 2
a199 2
				bus_space_handle_t *);
static int	bus_space_map2(
d206 2
a207 2
				bus_space_handle_t *);
static int	bus_space_unmap(
d210 2
a211 2
				bus_size_t);
static int	bus_space_subregion(
d216 2
a217 2
				bus_space_handle_t *);
static void	bus_space_barrier(
d222 2
a223 2
				int);
static paddr_t	bus_space_mmap(
d225 5
a229 5
				bus_addr_t,		/*addr*/
				off_t,			/*offset*/
				int,			/*prot*/
				int);			/*flags*/
static void	*bus_intr_establish(
d235 2
a236 2
				int (*)(void *),	/*handler*/
				void *);		/*handler arg*/
a245 24
bus_space_alloc(t, rs, re, s, a, b, f, ap, hp)
	bus_space_tag_t t;
	bus_addr_t	rs;
	bus_addr_t	re;
	bus_size_t	s;
	bus_size_t	a;
	bus_size_t	b;
	int		f;
	bus_addr_t	*ap;
	bus_space_handle_t *hp;
{
	_BS_CALL(t, sparc_bus_alloc)(t, rs, re, s, a, b, f, ap, hp);
}

__inline__ void
bus_space_free(t, h, s)
	bus_space_tag_t	t;
	bus_space_handle_t	h;
	bus_size_t	s;
{
	_BS_CALL(t, sparc_bus_free)(t, h, s);
}

__inline__ int
d253 1
a253 1
	_BS_CALL(t, sparc_bus_map)(t, 0, a, s, f, 0, hp);
d289 2
a290 2
__inline__ paddr_t
bus_space_mmap(t, a, o, p, f)
d292 1
a293 2
	off_t		o;
	int		p;
d295 1
d297 1
a297 1
	_BS_CALL(t, sparc_bus_mmap)(t, a, o, p, f);
d306 1
a306 1
	int	(*h)(void *);
d323 8
a330 5
#if 1
/* XXXX Things get complicated if we use unmapped register accesses. */
#define	bus_space_vaddr(t, h)	(vaddr_t)(h)
#else
void * bus_space_vaddr(bus_space_tag_t space, bus_space_handle_t handle);
d358 1
a358 1
int bus_space_probe(
d365 2
a366 2
		int (*)(void *, void *),	/* callback function */
		void *);			/* callback arg */
d370 2
a371 2
 *	u_intN_t bus_space_read_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset);
d393 2
a394 2
	printf("bsr1(%llx + %llx, %x) -> %x\n", (long long)(h),		\
		(long long)(o),						\
d402 2
a403 2
	printf("bsr2(%llx + %llx, %x) -> %x\n", (long long)(h),		\
		(long long)(o),						\
d411 2
a412 2
	printf("bsr4(%llx + %llx, %x) -> %x\n", (long long)(h),		\
		(long long)(o),						\
d420 3
a422 3
	printf("bsr8(%llx + %llx, %x) -> %llx\n", (long long)(h),	\
		(long long)(o),						\
		bus_type_asi[(t)->type], (long long)__bv);		\
d426 1
a426 1
 *	void bus_space_read_multi_N(bus_space_tag_t tag,
d428 1
a428 1
 *	    u_intN_t *addr, size_t count);
d463 1
a463 1
 *	void bus_space_write_N(bus_space_tag_t tag,
d465 1
a465 1
 *	    u_intN_t value);
d485 2
a486 2
	printf("bsw1(%llx + %llx, %x) <- %x\n", (long long)(h),		\
		(long long)(o),						\
d492 2
a493 2
	printf("bsw2(%llx + %llx, %x) <- %x\n", (long long)(h),		\
		(long long)(o),						\
d499 2
a500 2
	printf("bsw4(%llx + %llx, %x) <- %x\n", (long long)(h),		\
		(long long)(o),						\
d506 3
a508 3
	printf("bsw8(%llx + %llx, %x) <- %llx\n", (long long)(h),	\
		(long long)(o),						\
		bus_type_asi[(t)->type], (long long) v);		\
d512 1
a512 1
 *	void bus_space_write_multi_N(bus_space_tag_t tag,
d514 1
a514 1
 *	    const u_intN_t *addr, size_t count);
d549 1
a549 1
 *	void bus_space_set_multi_N(bus_space_tag_t tag,
d551 1
a551 1
 *	    size_t count);
d582 1
a582 1
 *	void bus_space_read_region_N(bus_space_tag_t tag,
d584 1
a584 1
 *	    u_intN_t *addr, bus_size_t count);
d587 1
a587 1
static void bus_space_read_region_1(bus_space_tag_t,
d591 2
a592 2
	bus_size_t);
static void bus_space_read_region_2(bus_space_tag_t,
d596 2
a597 2
	bus_size_t);
static void bus_space_read_region_4(bus_space_tag_t,
d601 2
a602 2
	bus_size_t);
static void bus_space_read_region_8(bus_space_tag_t,
d606 1
a606 1
	bus_size_t);
d650 1
a650 1
 *	void bus_space_write_region_N(bus_space_tag_t tag,
d652 1
a652 1
 *	    u_intN_t *addr, bus_size_t count);
d655 1
a655 1
static void bus_space_write_region_1(bus_space_tag_t,
d659 2
a660 2
	bus_size_t);
static void bus_space_write_region_2(bus_space_tag_t,
d664 2
a665 2
	bus_size_t);
static void bus_space_write_region_4(bus_space_tag_t,
d669 2
a670 2
	bus_size_t);
static void bus_space_write_region_8(bus_space_tag_t,
d674 1
a674 1
	bus_size_t);
d721 1
a721 1
 *	void bus_space_set_region_N(bus_space_tag_t tag,
d723 1
a723 1
 *	    u_intN_t *addr, bus_size_t count);
d726 1
a726 1
static void bus_space_set_region_1(bus_space_tag_t,
d730 2
a731 2
	bus_size_t);
static void bus_space_set_region_2(bus_space_tag_t,
d735 2
a736 2
	bus_size_t);
static void bus_space_set_region_4(bus_space_tag_t,
d740 2
a741 2
	bus_size_t);
static void bus_space_set_region_8(bus_space_tag_t,
d745 1
a745 1
	bus_size_t);
d793 1
a793 1
 *	void bus_space_copy_region_N(bus_space_tag_t tag,
d796 1
a796 1
 *	    bus_size_t count);
d801 1
a801 1
static void bus_space_copy_region_1(bus_space_tag_t,
d806 2
a807 2
	bus_size_t);
static void bus_space_copy_region_2(bus_space_tag_t,
d812 2
a813 2
	bus_size_t);
static void bus_space_copy_region_4(bus_space_tag_t,
d818 2
a819 2
	bus_size_t);
static void bus_space_copy_region_8(bus_space_tag_t,
d824 1
a824 1
	bus_size_t);
d872 2
a873 2
 *	u_intN_t bus_space_read_stream_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset);
d893 1
a893 1
	    lduba((h) + (o), bus_stream_asi[(t)->type]);		\
d895 3
a897 3
	printf("bsr1(%llx + %llx, %x) -> %x\n", (long long)(h),		\
		(long long)(o),						\
		bus_stream_asi[(t)->type], (unsigned int) __bv);	\
d902 1
a902 1
	    lduha((h) + (o), bus_stream_asi[(t)->type]);		\
d904 2
a905 2
	printf("bsr2(%llx + %llx, %x) -> %x\n", (long long)(h),		\
		(long long)(o),						\
d909 1
a909 1
#define	bus_space_read_stream_4(t, h, o) ({				\
d913 3
a915 3
	printf("bsr4(%llx + %llx, %x) -> %x\n", (long long)(h),		\
		(long long)(o),						\
		bus_stream_asi[(t)->type], __bv);			\
d918 1
a918 1
#define	bus_space_read_stream_8(t, h, o) ({				\
d922 3
a924 3
	printf("bsr8(%llx + %llx, %x) -> %llx\n", (long long)(h),	\
		(long long)(o),						\
		bus_stream_asi[(t)->type], (long long)__bv);		\
d928 1
a928 1
 *	void bus_space_read_multi_stream_N(bus_space_tag_t tag,
d930 1
a930 1
 *	    u_intN_t *addr, size_t count);
d936 1
a936 1
#define	bus_space_read_multi_stream_1(t, h, o, a, c) do {		\
d940 1
a940 1
		*p++ = bus_space_read_stream_1(t, h, o);		\
d943 1
a943 1
#define	bus_space_read_multi_stream_2(t, h, o, a, c) do {		\
d947 1
a947 1
		*p++ = bus_space_read_stream_2(t, h, o);		\
d950 1
a950 1
#define	bus_space_read_multi_stream_4(t, h, o, a, c) do {		\
d954 1
a954 1
		*p++ = bus_space_read_stream_4(t, h, o);		\
d957 1
a957 1
#define	bus_space_read_multi_stream_8(t, h, o, a, c) do {		\
d961 1
a961 1
		*p++ = bus_space_read_stream_8(t, h, o);		\
d965 1
a965 1
 *	void bus_space_write_stream_N(bus_space_tag_t tag,
d967 1
a967 1
 *	    u_intN_t value);
d973 1
a973 1
#define	bus_space_write_stream_1(t, h, o, v)				\
d976 1
a976 1
#define	bus_space_write_stream_2(t, h, o, v)				\
d979 1
a979 1
#define	bus_space_write_stream_4(t, h, o, v)				\
d982 1
a982 1
#define	bus_space_write_stream_8(t, h, o, v)				\
d987 2
a988 2
	printf("bsw1(%llx + %llx, %x) <- %x\n", (long long)(h),		\
		(long long)(o),						\
d994 2
a995 2
	printf("bsw2(%llx + %llx, %x) <- %x\n", (long long)(h),		\
		(long long)(o),						\
d1001 2
a1002 2
	printf("bsw4(%llx + %llx, %x) <- %x\n", (long long)(h),		\
		(long long)(o),						\
d1008 3
a1010 3
	printf("bsw8(%llx + %llx, %x) <- %llx\n", (long long)(h),	\
		(long long)(o),						\
		bus_stream_asi[(t)->type], (long long) v);		\
d1014 1
a1014 1
 *	void bus_space_write_multi_stream_N(bus_space_tag_t tag,
d1016 1
a1016 1
 *	    const u_intN_t *addr, size_t count);
d1022 1
a1022 1
#define	bus_space_write_multi_stream_1(t, h, o, a, c) do {		\
d1026 1
a1026 1
		bus_space_write_stream_1(t, h, o, *p++);		\
d1029 1
a1029 1
#define bus_space_write_multi_stream_2(t, h, o, a, c) do {		\
d1033 1
a1033 1
		bus_space_write_stream_2(t, h, o, *p++);		\
d1036 1
a1036 1
#define bus_space_write_multi_stream_4(t, h, o, a, c) do {		\
d1040 1
a1040 1
		bus_space_write_stream_4(t, h, o, *p++);		\
d1043 1
a1043 1
#define bus_space_write_multi_stream_8(t, h, o, a, c) do {		\
d1047 1
a1047 1
		bus_space_write_stream_8(t, h, o, *p++);		\
d1051 1
a1051 1
 *	void bus_space_set_multi_stream_N(bus_space_tag_t tag,
d1053 1
a1053 1
 *	    size_t count);
d1059 1
a1059 1
#define bus_space_set_multi_stream_1(t, h, o, v, c) do {		\
d1062 1
a1062 1
		bus_space_write_stream_1(t, h, o, v);			\
d1065 1
a1065 1
#define bus_space_set_multi_stream_2(t, h, o, v, c) do {		\
d1068 1
a1068 1
		bus_space_write_stream_2(t, h, o, v);			\
d1071 1
a1071 1
#define bus_space_set_multi_stream_4(t, h, o, v, c) do {		\
d1074 1
a1074 1
		bus_space_write_stream_4(t, h, o, v);			\
d1077 1
a1077 1
#define bus_space_set_multi_stream_8(t, h, o, v, c) do {		\
d1080 1
a1080 1
		bus_space_write_stream_8(t, h, o, v);			\
d1084 1
a1084 1
 *	void bus_space_read_region_stream_N(bus_space_tag_t tag,
d1086 1
a1086 1
 *	    u_intN_t *addr, bus_size_t count);
d1089 1
a1089 1
static void bus_space_read_region_stream_1(bus_space_tag_t,
d1093 2
a1094 2
	bus_size_t);
static void bus_space_read_region_stream_2(bus_space_tag_t,
d1098 2
a1099 2
	bus_size_t);
static void bus_space_read_region_stream_4(bus_space_tag_t,
d1103 2
a1104 2
	bus_size_t);
static void bus_space_read_region_stream_8(bus_space_tag_t,
d1108 1
a1108 1
	bus_size_t);
d1152 1
a1152 1
 *	void bus_space_write_region_stream_N(bus_space_tag_t tag,
d1154 1
a1154 1
 *	    u_intN_t *addr, bus_size_t count);
d1157 1
a1157 1
static void bus_space_write_region_stream_1(bus_space_tag_t,
d1161 2
a1162 2
	bus_size_t);
static void bus_space_write_region_stream_2(bus_space_tag_t,
d1166 2
a1167 2
	bus_size_t);
static void bus_space_write_region_stream_4(bus_space_tag_t,
d1171 2
a1172 2
	bus_size_t);
static void bus_space_write_region_stream_8(bus_space_tag_t,
d1176 1
a1176 1
	bus_size_t);
d1223 1
a1223 1
 *	void bus_space_set_region_stream_N(bus_space_tag_t tag,
d1225 1
a1225 1
 *	    u_intN_t *addr, bus_size_t count);
d1228 1
a1228 1
static void bus_space_set_region_stream_1(bus_space_tag_t,
d1232 2
a1233 2
	bus_size_t);
static void bus_space_set_region_stream_2(bus_space_tag_t,
d1237 2
a1238 2
	bus_size_t);
static void bus_space_set_region_stream_4(bus_space_tag_t,
d1242 2
a1243 2
	bus_size_t);
static void bus_space_set_region_stream_8(bus_space_tag_t,
d1247 1
a1247 1
	bus_size_t);
d1295 1
a1295 1
 *	void bus_space_copy_region_stream_N(bus_space_tag_t tag,
d1298 1
a1298 1
 *	    bus_size_t count);
d1303 1
a1303 1
static void bus_space_copy_region_stream_1(bus_space_tag_t,
d1308 2
a1309 2
	bus_size_t);
static void bus_space_copy_region_stream_2(bus_space_tag_t,
d1314 2
a1315 2
	bus_size_t);
static void bus_space_copy_region_stream_4(bus_space_tag_t,
d1320 2
a1321 2
	bus_size_t);
static void bus_space_copy_region_stream_8(bus_space_tag_t,
d1326 1
a1326 1
	bus_size_t);
d1395 1
a1395 1
#define	BUS_DMA_BUS1		0x010	/* placeholders for bus functions... */
d1403 1
a1405 1
#define	BUS_DMA_24BIT		BUS_DMA_BUS3	/* 24bit device */
d1453 14
a1466 14
	int	(*_dmamap_create)(bus_dma_tag_t, bus_size_t, int,
		    bus_size_t, bus_size_t, int, bus_dmamap_t *);
	void	(*_dmamap_destroy)(bus_dma_tag_t, bus_dmamap_t);
	int	(*_dmamap_load)(bus_dma_tag_t, bus_dmamap_t, void *,
		    bus_size_t, struct proc *, int);
	int	(*_dmamap_load_mbuf)(bus_dma_tag_t, bus_dmamap_t,
		    struct mbuf *, int);
	int	(*_dmamap_load_uio)(bus_dma_tag_t, bus_dmamap_t,
		    struct uio *, int);
	int	(*_dmamap_load_raw)(bus_dma_tag_t, bus_dmamap_t,
		    bus_dma_segment_t *, int, bus_size_t, int);
	void	(*_dmamap_unload)(bus_dma_tag_t, bus_dmamap_t);
	void	(*_dmamap_sync)(bus_dma_tag_t, bus_dmamap_t,
		    bus_addr_t, bus_size_t, int);
d1471 9
a1479 9
	int	(*_dmamem_alloc)(bus_dma_tag_t, bus_size_t, bus_size_t,
		    bus_size_t, bus_dma_segment_t *, int, int *, int);
	void	(*_dmamem_free)(bus_dma_tag_t,
		    bus_dma_segment_t *, int);
	int	(*_dmamem_map)(bus_dma_tag_t, bus_dma_segment_t *,
		    int, size_t, caddr_t *, int);
	void	(*_dmamem_unmap)(bus_dma_tag_t, caddr_t, size_t);
	paddr_t	(*_dmamem_mmap)(bus_dma_tag_t, bus_dma_segment_t *,
		    int, off_t, int, int);
d1546 14
a1559 14
int	_bus_dmamap_create(bus_dma_tag_t, bus_size_t, int, bus_size_t,
	    bus_size_t, int, bus_dmamap_t *);
void	_bus_dmamap_destroy(bus_dma_tag_t, bus_dmamap_t);
int	_bus_dmamap_load(bus_dma_tag_t, bus_dmamap_t, void *,
	    bus_size_t, struct proc *, int);
int	_bus_dmamap_load_mbuf(bus_dma_tag_t, bus_dmamap_t,
	    struct mbuf *, int);
int	_bus_dmamap_load_uio(bus_dma_tag_t, bus_dmamap_t,
	    struct uio *, int);
int	_bus_dmamap_load_raw(bus_dma_tag_t, bus_dmamap_t,
	    bus_dma_segment_t *, int, bus_size_t, int);
void	_bus_dmamap_unload(bus_dma_tag_t, bus_dmamap_t);
void	_bus_dmamap_sync(bus_dma_tag_t, bus_dmamap_t, bus_addr_t,
	    bus_size_t, int);
d1561 1
a1561 1
int	_bus_dmamem_alloc(bus_dma_tag_t tag, bus_size_t size,
d1563 9
a1571 9
	    bus_dma_segment_t *segs, int nsegs, int *rsegs, int flags);
void	_bus_dmamem_free(bus_dma_tag_t tag, bus_dma_segment_t *segs,
	    int nsegs);
int	_bus_dmamem_map(bus_dma_tag_t tag, bus_dma_segment_t *segs,
	    int nsegs, size_t size, caddr_t *kvap, int flags);
void	_bus_dmamem_unmap(bus_dma_tag_t tag, caddr_t kva,
	    size_t size);
paddr_t	_bus_dmamem_mmap(bus_dma_tag_t tag, bus_dma_segment_t *segs,
	    int nsegs, off_t off, int prot, int flags);
d1573 1
a1573 1
int	_bus_dmamem_alloc_range(bus_dma_tag_t tag, bus_size_t size,
d1576 1
a1576 1
	    vaddr_t low, vaddr_t high);
@


1.7.6.2
log
@sync
@
text
@a86 3
#define BSDB_ASSERT	0x04
#define BSDB_MAPDETAIL	0x08
#define	BSDB_ALL_ACCESS	0x10
a88 38
#define BSHDB_ACCESS	0x01
#define BSHDB_NO_ACCESS	0x02

#if defined(BUS_SPACE_DEBUG)
#ifndef __SYSTM_H__
#include <sys/systm.h>
#endif
#define BUS_SPACE_PRINTF(l, s) do {				\
	if(bus_space_debug & (l)) printf s;			\
} while(0)
#define BUS_SPACE_TRACE(t, h, s) do {				\
	if ( (((bus_space_debug & BSDB_ALL_ACCESS) != 0) &&	\
		(((h).bh_flags & BSHDB_NO_ACCESS) == 0)) ||	\
	     (((bus_space_debug & BSDB_ACCESS) != 0) &&		\
		(((h).bh_flags & BSHDB_ACCESS) != 0)))		\
		printf s;					\
	} while(0)
#define BUS_SPACE_SET_FLAGS(t, h, f) ((h).bh_flags |= (f))
#define BUS_SPACE_CLEAR_FLAGS(t, h, f) ((h).bh_flags &= ~(f))
#define BUS_SPACE_FLAG_DECL(s)	int s
#define BUS_SPACE_SAVE_FLAGS(t, h, s) (s = (h).bh_flags)
#define BUS_SPACE_RESTORE_FLAGS(t, h, s) (s = (h).bh_flags)
#define BUS_SPACE_ASSERT(t, h, o, n) do {			\
	if (bus_space_debug & BSDB_ASSERT)			\
		bus_space_assert(t, &(h), o, n);		\
	} while(0)
#else /* BUS_SPACE_DEBUG */
#define BUS_SPACE_PRINTF(l, s)
#define BUS_SPACE_TRACE(t, h, s)
#define BUS_SPACE_SET_FLAGS(t, h, f)
#define BUS_SPACE_CLEAR_FLAGS(t, h, f)
#define BUS_SPACE_FLAG_DECL(s)
#define BUS_SPACE_SAVE_FLAGS(t, h, s)
#define BUS_SPACE_RESTORE_FLAGS(t, h, s)
#define BUS_SPACE_ASSERT(t, h, o, n)
#endif /* BUS_SPACE_DEBUG */


d104 2
d114 2
a115 1
typedef const struct sparc_bus_space_tag	*bus_space_tag_t;
a118 10

typedef struct _bus_space_handle {
        paddr_t		bh_ptr;
#ifdef BUS_SPACE_DEBUG
	bus_space_tag_t	bh_tag;
	bus_size_t	bh_size;
	int		bh_flags;
#endif
} bus_space_handle_t;

d120 3
a122 3
#define BUS_ADDR_IOSPACE(x)     ((x)>>32)
#define BUS_ADDR_PADDR(x)       ((x)&0xffffffff)
#define BUS_ADDR(io, pa)        ((((bus_addr_t)io)<<32)|(pa))
d127 1
d130 1
a130 1
	void	*cookie;
d132 1
a132 4
	enum bus_type default_type;
        u_int8_t	asi;
        u_int8_t	sasi;
	char	name[32];
a134 1
		bus_space_tag_t,
a139 1
		bus_space_tag_t,
d143 2
a144 7
		bus_space_tag_t,
		bus_addr_t,	bus_size_t,
		int, bus_space_handle_t *);

	int	(*sparc_bus_protect)(bus_space_tag_t,
		bus_space_tag_t,
		bus_space_handle_t, bus_size_t, int);
a146 1
		bus_space_tag_t,
a149 1
		bus_space_tag_t,
a153 1
		bus_space_tag_t,
a157 1
		bus_space_tag_t,
a160 1
		bus_space_tag_t,
d166 17
d186 1
a186 1
int		bus_space_alloc(
d196 1
a196 1
void		bus_space_free(
d200 1
a200 1
int		bus_space_map(
d206 1
a206 1
int		bus_space_protect(
d208 2
a209 1
				bus_space_handle_t,
d211 4
a214 2
				int);			/*flags*/
int		bus_space_unmap(
d218 1
a218 1
int		bus_space_subregion(
d230 1
a230 1
paddr_t		bus_space_mmap(
d236 1
a236 1
void	       *bus_intr_establish(
a243 7
void		bus_space_render_tag(
				bus_space_tag_t,
				char *,
				size_t);
void	       *bus_space_vaddr(
				bus_space_tag_t,
				bus_space_handle_t);
a244 6
#ifdef BUS_SPACE_DEBUG
void bus_space_assert(bus_space_tag_t,
	const bus_space_handle_t *,
	bus_size_t, int);
void bus_space_render_tag(bus_space_tag_t, char*, size_t);
#endif /* BUS_SPACE_DEBUG */
d246 73
d320 10
a329 4
#define _BS_PRECALL(t,f)		\
	while (t->f == NULL)		\
		t = t->parent;
#define _BS_POSTCALL
d331 11
a341 2
#define _BS_CALL(t,f)			\
	(*(t)->f)
d343 1
a343 1
static inline void
d351 1
a351 4
	const bus_space_tag_t t0 = t;
	_BS_PRECALL(t, sparc_bus_barrier);
	_BS_CALL(t, sparc_bus_barrier)(t, t0, h, o, s, f);
	_BS_POSTCALL;
d354 6
a359 1
#include <sparc64/sparc64/busop.h>
a365 1
#define BUS_SPACE_MAP_PROMADDRESS	0x0010
d388 1
d397 1016
a1434 2
#define BUS_DMA_RAW	BUS_DMA_STREAMING

a1460 7
	/*
	 * The following is to support bus_dmamem_alloc()'s
	 * odd interface.  Only the values in the first
	 * segment are used.  This means that 3/5ths of
	 * most segments are useless space (and mbufs use 1024
	 * segments).
	 */
d1481 8
a1488 8
	int	(*_dmamap_create)(bus_dma_tag_t, bus_dma_tag_t, bus_size_t,
		    int, bus_size_t, bus_size_t, int, bus_dmamap_t *);
	void	(*_dmamap_destroy)(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t);
	int	(*_dmamap_load)(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t,
		    void *, bus_size_t, struct proc *, int);
	int	(*_dmamap_load_mbuf)(bus_dma_tag_t, bus_dma_tag_t,
		    bus_dmamap_t, struct mbuf *, int);
	int	(*_dmamap_load_uio)(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t,
d1490 1
a1490 1
	int	(*_dmamap_load_raw)(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t,
d1492 2
a1493 2
	void	(*_dmamap_unload)(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t);
	void	(*_dmamap_sync)(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t,
d1499 3
a1501 4
	int	(*_dmamem_alloc)(bus_dma_tag_t, bus_dma_tag_t, bus_size_t,
		    bus_size_t, bus_size_t, bus_dma_segment_t *, int, int *,
		    int);
	void	(*_dmamem_free)(bus_dma_tag_t, bus_dma_tag_t,
d1503 5
a1507 6
	int	(*_dmamem_map)(bus_dma_tag_t, bus_dma_tag_t,
		    bus_dma_segment_t *, int, size_t, caddr_t *, int);
	void	(*_dmamem_unmap)(bus_dma_tag_t, bus_dma_tag_t, caddr_t,
		    size_t);
	paddr_t	(*_dmamem_mmap)(bus_dma_tag_t, bus_dma_tag_t,
		    bus_dma_segment_t *, int, off_t, int, int);
d1510 28
a1537 136
#define _BD_PRECALL(t,f)		\
	while (t->f == NULL) {		\
		t = t->_parent;		\
	}
#define _BD_CALL(t,f)			\
	(*(t)->f)
#define _BD_POSTCALL

static inline int
bus_dmamap_create(bus_dma_tag_t t, bus_size_t s, int n, bus_size_t m,
    bus_size_t b, int f, bus_dmamap_t *p)
{
	int r;
	const bus_dma_tag_t t0 = t;
	_BD_PRECALL(t, _dmamap_create);
	r = _BD_CALL(t, _dmamap_create)(t, t0, s, n, m, b, f, p);
	_BD_POSTCALL;
	return (r);
}
static inline void
bus_dmamap_destroy(bus_dma_tag_t t, bus_dmamap_t p)
{
	const bus_dma_tag_t t0 = t;
	_BD_PRECALL(t, _dmamap_destroy);
	_BD_CALL(t, _dmamap_destroy)(t, t0, p);
	_BD_POSTCALL;
}
static inline int
bus_dmamap_load(bus_dma_tag_t t, bus_dmamap_t m, void *b, bus_size_t s,
    struct proc *p, int f)
{
	const bus_dma_tag_t t0 = t;
	int r;
	_BD_PRECALL(t, _dmamap_load);
	r = _BD_CALL(t, _dmamap_load)(t, t0, m, b, s, p, f);
	_BD_POSTCALL;
	return (r);
}
static inline int
bus_dmamap_load_mbuf(bus_dma_tag_t t, bus_dmamap_t m, struct mbuf *b,
    int f)
{
	const bus_dma_tag_t t0 = t;
	int r;
	_BD_PRECALL(t, _dmamap_load_mbuf);
	r = _BD_CALL(t, _dmamap_load_mbuf)(t, t0, m, b, f);
	_BD_POSTCALL;
	return (r);
}
static inline int
bus_dmamap_load_uio(bus_dma_tag_t t, bus_dmamap_t m, struct uio * u, int f)
{
	const bus_dma_tag_t t0 = t;
	int r;
	_BD_PRECALL(t, _dmamap_load_uio);
	r = _BD_CALL(t, _dmamap_load_uio)(t, t0, m, u, f);
	_BD_POSTCALL;
	return (r);
}
static inline int
bus_dmamap_load_raw(bus_dma_tag_t t, bus_dmamap_t m, bus_dma_segment_t *sg,
    int n, bus_size_t s, int f)
{
	const bus_dma_tag_t t0 = t;
	int r;
	_BD_PRECALL(t, _dmamap_load_raw);
	r = _BD_CALL(t, _dmamap_load_raw)(t, t0, m, sg, n, s, f);
	_BD_POSTCALL;
	return (r);
}
static inline void
bus_dmamap_unload(bus_dma_tag_t t, bus_dmamap_t p)
{
	const bus_dma_tag_t t0 = t;
	_BD_PRECALL(t, _dmamap_unload);
	_BD_CALL(t, _dmamap_unload)(t, t0, p);
	_BD_POSTCALL;
}
static inline void
bus_dmamap_sync(bus_dma_tag_t t, bus_dmamap_t p, bus_addr_t o, bus_size_t l,
    int ops)
{
	const bus_dma_tag_t t0 = t;
	_BD_PRECALL(t, _dmamap_sync);
	_BD_CALL(t, _dmamap_sync)(t, t0, p, o, l, ops);
	_BD_POSTCALL;
}
static inline int
bus_dmamem_alloc(bus_dma_tag_t t, bus_size_t s, bus_size_t a, bus_size_t b,
    bus_dma_segment_t *sg, int n, int *r, int f)
{
	const bus_dma_tag_t t0 = t;
	int ret;
	_BD_PRECALL(t, _dmamem_alloc);
	ret = _BD_CALL(t, _dmamem_alloc)(t, t0, s, a, b, sg, n, r, f);
	_BD_POSTCALL;
	return (ret);
}
static inline void
bus_dmamem_free(bus_dma_tag_t t, bus_dma_segment_t *sg, int n)
{
	const bus_dma_tag_t t0 = t;
	_BD_PRECALL(t, _dmamem_free);
	_BD_CALL(t, _dmamem_free)(t, t0, sg, n);
	_BD_POSTCALL;
}
static inline int
bus_dmamem_map(bus_dma_tag_t t, bus_dma_segment_t *sg, int n, size_t s,
    caddr_t *k, int f)
{
	const bus_dma_tag_t t0 = t;
	int r;
	_BD_PRECALL(t, _dmamem_map);
	r = _BD_CALL(t, _dmamem_map)(t, t0, sg, n, s, k, f);
	_BD_POSTCALL;
	return (r);
}
static inline void
bus_dmamem_unmap(bus_dma_tag_t t, caddr_t k, size_t s)
{
	const bus_dma_tag_t t0 = t;
	_BD_PRECALL(t, _dmamem_unmap);
	_BD_CALL(t, _dmamem_unmap)(t, t0, k, s);
	_BD_POSTCALL;
}
static inline paddr_t
bus_dmamem_mmap(bus_dma_tag_t t, bus_dma_segment_t *sg, int n, off_t o, int p,
    int f)
{
	const bus_dma_tag_t t0 = t;
	int r;
	_BD_PRECALL(t, _dmamem_mmap);
	r = _BD_CALL(t, _dmamem_mmap)(t, t0, sg, n, o, p, f);
	_BD_POSTCALL;
	return (r);
}
d1560 2
a1561 2
	int		_dm_type;	/* mapping type: raw, uio, mbuf, etc */
	void		*_dm_source;	/* source mbuf/uio/etc. for unload */
a1569 1

d1573 34
a1607 1

@


1.7.4.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.7.4.2
log
@Merge in trunk
@
text
@d2 1
a2 1
/*	$NetBSD: bus.h,v 1.31 2001/09/21 15:30:41 wiz Exp $	*/
a118 5
/* For buses which have an iospace. */
#define	BUS_ADDR_IOSPACE(x)	((x)>>32)
#define	BUS_ADDR_PADDR(x)	((x)&0xffffffff)
#define	BUS_ADDR(io, pa)	(((io)<<32)|(pa))

d129 41
a169 29
	int     (*sparc_bus_alloc) __P((bus_space_tag_t, 
		bus_addr_t, bus_addr_t,
		bus_size_t, bus_size_t, bus_size_t, 
		int, bus_addr_t *, bus_space_handle_t *));

	void	(*sparc_bus_free) __P((bus_space_tag_t, 
		bus_space_handle_t, bus_size_t));

	int	(*sparc_bus_map) __P((bus_space_tag_t,
		bus_type_t, bus_addr_t,	bus_size_t,
		int, vaddr_t, bus_space_handle_t *));

	int	(*sparc_bus_unmap) __P((bus_space_tag_t,
		bus_space_handle_t, bus_size_t));

	int	(*sparc_bus_subregion) __P((bus_space_tag_t,
		bus_space_handle_t, bus_size_t,
		bus_size_t, bus_space_handle_t *));

	void	(*sparc_bus_barrier) __P((bus_space_tag_t,
		bus_space_handle_t, bus_size_t,
		bus_size_t, int));

	paddr_t	(*sparc_bus_mmap) __P((bus_space_tag_t,
		bus_addr_t, off_t, int, int));

	void	*(*sparc_intr_establish) __P((bus_space_tag_t,
		int, int, int,
		int (*) __P((void *)), void *));
a192 14
static int	bus_space_alloc __P((
				bus_space_tag_t,
				bus_addr_t,		/* reg start */
				bus_addr_t,		/* reg end */
				bus_size_t,		/* size */
				bus_size_t,		/* alignment */
				bus_size_t,		/* boundary */
				int,			/* flags */
				bus_addr_t *, 
				bus_space_handle_t *));
static void	bus_space_free __P((
				bus_space_tag_t,
				bus_space_handle_t,
				bus_size_t));
d223 1
a223 1
static paddr_t	bus_space_mmap __P((
d225 4
a228 4
				bus_addr_t,		/*addr*/
				off_t,			/*offset*/
				int,			/*prot*/
				int));			/*flags*/
a245 24
bus_space_alloc(t, rs, re, s, a, b, f, ap, hp)
	bus_space_tag_t t;
	bus_addr_t	rs;
	bus_addr_t	re;
	bus_size_t	s;
	bus_size_t	a;
	bus_size_t	b;
	int		f;
	bus_addr_t	*ap;
	bus_space_handle_t *hp;
{
	_BS_CALL(t, sparc_bus_alloc)(t, rs, re, s, a, b, f, ap, hp);
}

__inline__ void
bus_space_free(t, h, s)
	bus_space_tag_t	t;
	bus_space_handle_t	h;
	bus_size_t	s;
{
	_BS_CALL(t, sparc_bus_free)(t, h, s);
}

__inline__ int
d253 1
a253 1
	_BS_CALL(t, sparc_bus_map)(t, 0, a, s, f, 0, hp);
d289 2
a290 2
__inline__ paddr_t
bus_space_mmap(t, a, o, p, f)
d292 1
a293 2
	off_t		o;
	int		p;
d295 1
d297 1
a297 1
	_BS_CALL(t, sparc_bus_mmap)(t, a, o, p, f);
d323 8
a330 5
#if 1
/* XXXX Things get complicated if we use unmapped register accesses. */
#define	bus_space_vaddr(t, h)	(vaddr_t)(h)
#else
void * bus_space_vaddr __P((bus_space_tag_t space, bus_space_handle_t handle));
d393 2
a394 2
	printf("bsr1(%llx + %llx, %x) -> %x\n", (long long)(h),		\
		(long long)(o),						\
d402 2
a403 2
	printf("bsr2(%llx + %llx, %x) -> %x\n", (long long)(h),		\
		(long long)(o),						\
d411 2
a412 2
	printf("bsr4(%llx + %llx, %x) -> %x\n", (long long)(h),		\
		(long long)(o),						\
d420 3
a422 3
	printf("bsr8(%llx + %llx, %x) -> %llx\n", (long long)(h),	\
		(long long)(o),						\
		bus_type_asi[(t)->type], (long long)__bv);		\
d485 2
a486 2
	printf("bsw1(%llx + %llx, %x) <- %x\n", (long long)(h),		\
		(long long)(o),						\
d492 2
a493 2
	printf("bsw2(%llx + %llx, %x) <- %x\n", (long long)(h),		\
		(long long)(o),						\
d499 2
a500 2
	printf("bsw4(%llx + %llx, %x) <- %x\n", (long long)(h),		\
		(long long)(o),						\
d506 3
a508 3
	printf("bsw8(%llx + %llx, %x) <- %llx\n", (long long)(h),	\
		(long long)(o),						\
		bus_type_asi[(t)->type], (long long) v);		\
d893 1
a893 1
	    lduba((h) + (o), bus_stream_asi[(t)->type]);		\
d895 3
a897 3
	printf("bsr1(%llx + %llx, %x) -> %x\n", (long long)(h),		\
		(long long)(o),						\
		bus_stream_asi[(t)->type], (unsigned int) __bv);	\
d902 1
a902 1
	    lduha((h) + (o), bus_stream_asi[(t)->type]);		\
d904 2
a905 2
	printf("bsr2(%llx + %llx, %x) -> %x\n", (long long)(h),		\
		(long long)(o),						\
d909 1
a909 1
#define	bus_space_read_stream_4(t, h, o) ({				\
d913 3
a915 3
	printf("bsr4(%llx + %llx, %x) -> %x\n", (long long)(h),		\
		(long long)(o),						\
		bus_stream_asi[(t)->type], __bv);			\
d918 1
a918 1
#define	bus_space_read_stream_8(t, h, o) ({				\
d922 3
a924 3
	printf("bsr8(%llx + %llx, %x) -> %llx\n", (long long)(h),	\
		(long long)(o),						\
		bus_stream_asi[(t)->type], (long long)__bv);		\
d936 1
a936 1
#define	bus_space_read_multi_stream_1(t, h, o, a, c) do {		\
d940 1
a940 1
		*p++ = bus_space_read_stream_1(t, h, o);		\
d943 1
a943 1
#define	bus_space_read_multi_stream_2(t, h, o, a, c) do {		\
d947 1
a947 1
		*p++ = bus_space_read_stream_2(t, h, o);		\
d950 1
a950 1
#define	bus_space_read_multi_stream_4(t, h, o, a, c) do {		\
d954 1
a954 1
		*p++ = bus_space_read_stream_4(t, h, o);		\
d957 1
a957 1
#define	bus_space_read_multi_stream_8(t, h, o, a, c) do {		\
d961 1
a961 1
		*p++ = bus_space_read_stream_8(t, h, o);		\
d973 1
a973 1
#define	bus_space_write_stream_1(t, h, o, v)				\
d976 1
a976 1
#define	bus_space_write_stream_2(t, h, o, v)				\
d979 1
a979 1
#define	bus_space_write_stream_4(t, h, o, v)				\
d982 1
a982 1
#define	bus_space_write_stream_8(t, h, o, v)				\
d987 2
a988 2
	printf("bsw1(%llx + %llx, %x) <- %x\n", (long long)(h),		\
		(long long)(o),						\
d994 2
a995 2
	printf("bsw2(%llx + %llx, %x) <- %x\n", (long long)(h),		\
		(long long)(o),						\
d1001 2
a1002 2
	printf("bsw4(%llx + %llx, %x) <- %x\n", (long long)(h),		\
		(long long)(o),						\
d1008 3
a1010 3
	printf("bsw8(%llx + %llx, %x) <- %llx\n", (long long)(h),	\
		(long long)(o),						\
		bus_stream_asi[(t)->type], (long long) v);		\
d1022 1
a1022 1
#define	bus_space_write_multi_stream_1(t, h, o, a, c) do {		\
d1026 1
a1026 1
		bus_space_write_stream_1(t, h, o, *p++);		\
d1029 1
a1029 1
#define bus_space_write_multi_stream_2(t, h, o, a, c) do {		\
d1033 1
a1033 1
		bus_space_write_stream_2(t, h, o, *p++);		\
d1036 1
a1036 1
#define bus_space_write_multi_stream_4(t, h, o, a, c) do {		\
d1040 1
a1040 1
		bus_space_write_stream_4(t, h, o, *p++);		\
d1043 1
a1043 1
#define bus_space_write_multi_stream_8(t, h, o, a, c) do {		\
d1047 1
a1047 1
		bus_space_write_stream_8(t, h, o, *p++);		\
d1059 1
a1059 1
#define bus_space_set_multi_stream_1(t, h, o, v, c) do {		\
d1062 1
a1062 1
		bus_space_write_stream_1(t, h, o, v);			\
d1065 1
a1065 1
#define bus_space_set_multi_stream_2(t, h, o, v, c) do {		\
d1068 1
a1068 1
		bus_space_write_stream_2(t, h, o, v);			\
d1071 1
a1071 1
#define bus_space_set_multi_stream_4(t, h, o, v, c) do {		\
d1074 1
a1074 1
		bus_space_write_stream_4(t, h, o, v);			\
d1077 1
a1077 1
#define bus_space_set_multi_stream_8(t, h, o, v, c) do {		\
d1080 1
a1080 1
		bus_space_write_stream_8(t, h, o, v);			\
@


1.7.4.3
log
@Merge in -current from about a week ago
@
text
@d134 1
a134 1
	int     (*sparc_bus_alloc)(bus_space_tag_t, 
d137 1
a137 1
		int, bus_addr_t *, bus_space_handle_t *);
d139 2
a140 2
	void	(*sparc_bus_free)(bus_space_tag_t, 
		bus_space_handle_t, bus_size_t);
d142 1
a142 1
	int	(*sparc_bus_map)(bus_space_tag_t,
d144 1
a144 1
		int, vaddr_t, bus_space_handle_t *);
d146 2
a147 2
	int	(*sparc_bus_unmap)(bus_space_tag_t,
		bus_space_handle_t, bus_size_t);
d149 1
a149 1
	int	(*sparc_bus_subregion)(bus_space_tag_t,
d151 1
a151 1
		bus_size_t, bus_space_handle_t *);
d153 1
a153 1
	void	(*sparc_bus_barrier)(bus_space_tag_t,
d155 1
a155 1
		bus_size_t, int);
d157 2
a158 2
	paddr_t	(*sparc_bus_mmap)(bus_space_tag_t,
		bus_addr_t, off_t, int, int);
d160 1
a160 1
	void	*(*sparc_intr_establish)(bus_space_tag_t,
d162 1
a162 1
		int (*)(void *), void *);
d170 1
a170 1
#define PROTO_bus_space_xxx(bus_space_tag_t t, ...)
d186 1
a186 1
static int	bus_space_alloc(
d195 2
a196 2
				bus_space_handle_t *);
static void	bus_space_free(
d199 2
a200 2
				bus_size_t);
static int	bus_space_map(
d205 2
a206 2
				bus_space_handle_t *);
static int	bus_space_map2(
d213 2
a214 2
				bus_space_handle_t *);
static int	bus_space_unmap(
d217 2
a218 2
				bus_size_t);
static int	bus_space_subregion(
d223 2
a224 2
				bus_space_handle_t *);
static void	bus_space_barrier(
d229 2
a230 2
				int);
static paddr_t	bus_space_mmap(
d235 2
a236 2
				int);			/*flags*/
static void	*bus_intr_establish(
d242 2
a243 2
				int (*)(void *),	/*handler*/
				void *);		/*handler arg*/
d337 1
a337 1
	int	(*h)(void *);
d358 1
a358 1
void * bus_space_vaddr(bus_space_tag_t space, bus_space_handle_t handle);
d386 1
a386 1
int bus_space_probe(
d393 2
a394 2
		int (*)(void *, void *),	/* callback function */
		void *);			/* callback arg */
d398 2
a399 2
 *	u_intN_t bus_space_read_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset);
d454 1
a454 1
 *	void bus_space_read_multi_N(bus_space_tag_t tag,
d456 1
a456 1
 *	    u_intN_t *addr, size_t count);
d491 1
a491 1
 *	void bus_space_write_N(bus_space_tag_t tag,
d493 1
a493 1
 *	    u_intN_t value);
d540 1
a540 1
 *	void bus_space_write_multi_N(bus_space_tag_t tag,
d542 1
a542 1
 *	    const u_intN_t *addr, size_t count);
d577 1
a577 1
 *	void bus_space_set_multi_N(bus_space_tag_t tag,
d579 1
a579 1
 *	    size_t count);
d610 1
a610 1
 *	void bus_space_read_region_N(bus_space_tag_t tag,
d612 1
a612 1
 *	    u_intN_t *addr, bus_size_t count);
d615 1
a615 1
static void bus_space_read_region_1(bus_space_tag_t,
d619 2
a620 2
	bus_size_t);
static void bus_space_read_region_2(bus_space_tag_t,
d624 2
a625 2
	bus_size_t);
static void bus_space_read_region_4(bus_space_tag_t,
d629 2
a630 2
	bus_size_t);
static void bus_space_read_region_8(bus_space_tag_t,
d634 1
a634 1
	bus_size_t);
d678 1
a678 1
 *	void bus_space_write_region_N(bus_space_tag_t tag,
d680 1
a680 1
 *	    u_intN_t *addr, bus_size_t count);
d683 1
a683 1
static void bus_space_write_region_1(bus_space_tag_t,
d687 2
a688 2
	bus_size_t);
static void bus_space_write_region_2(bus_space_tag_t,
d692 2
a693 2
	bus_size_t);
static void bus_space_write_region_4(bus_space_tag_t,
d697 2
a698 2
	bus_size_t);
static void bus_space_write_region_8(bus_space_tag_t,
d702 1
a702 1
	bus_size_t);
d749 1
a749 1
 *	void bus_space_set_region_N(bus_space_tag_t tag,
d751 1
a751 1
 *	    u_intN_t *addr, bus_size_t count);
d754 1
a754 1
static void bus_space_set_region_1(bus_space_tag_t,
d758 2
a759 2
	bus_size_t);
static void bus_space_set_region_2(bus_space_tag_t,
d763 2
a764 2
	bus_size_t);
static void bus_space_set_region_4(bus_space_tag_t,
d768 2
a769 2
	bus_size_t);
static void bus_space_set_region_8(bus_space_tag_t,
d773 1
a773 1
	bus_size_t);
d821 1
a821 1
 *	void bus_space_copy_region_N(bus_space_tag_t tag,
d824 1
a824 1
 *	    bus_size_t count);
d829 1
a829 1
static void bus_space_copy_region_1(bus_space_tag_t,
d834 2
a835 2
	bus_size_t);
static void bus_space_copy_region_2(bus_space_tag_t,
d840 2
a841 2
	bus_size_t);
static void bus_space_copy_region_4(bus_space_tag_t,
d846 2
a847 2
	bus_size_t);
static void bus_space_copy_region_8(bus_space_tag_t,
d852 1
a852 1
	bus_size_t);
d900 2
a901 2
 *	u_intN_t bus_space_read_stream_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset);
d956 1
a956 1
 *	void bus_space_read_multi_stream_N(bus_space_tag_t tag,
d958 1
a958 1
 *	    u_intN_t *addr, size_t count);
d993 1
a993 1
 *	void bus_space_write_stream_N(bus_space_tag_t tag,
d995 1
a995 1
 *	    u_intN_t value);
d1042 1
a1042 1
 *	void bus_space_write_multi_stream_N(bus_space_tag_t tag,
d1044 1
a1044 1
 *	    const u_intN_t *addr, size_t count);
d1079 1
a1079 1
 *	void bus_space_set_multi_stream_N(bus_space_tag_t tag,
d1081 1
a1081 1
 *	    size_t count);
d1112 1
a1112 1
 *	void bus_space_read_region_stream_N(bus_space_tag_t tag,
d1114 1
a1114 1
 *	    u_intN_t *addr, bus_size_t count);
d1117 1
a1117 1
static void bus_space_read_region_stream_1(bus_space_tag_t,
d1121 2
a1122 2
	bus_size_t);
static void bus_space_read_region_stream_2(bus_space_tag_t,
d1126 2
a1127 2
	bus_size_t);
static void bus_space_read_region_stream_4(bus_space_tag_t,
d1131 2
a1132 2
	bus_size_t);
static void bus_space_read_region_stream_8(bus_space_tag_t,
d1136 1
a1136 1
	bus_size_t);
d1180 1
a1180 1
 *	void bus_space_write_region_stream_N(bus_space_tag_t tag,
d1182 1
a1182 1
 *	    u_intN_t *addr, bus_size_t count);
d1185 1
a1185 1
static void bus_space_write_region_stream_1(bus_space_tag_t,
d1189 2
a1190 2
	bus_size_t);
static void bus_space_write_region_stream_2(bus_space_tag_t,
d1194 2
a1195 2
	bus_size_t);
static void bus_space_write_region_stream_4(bus_space_tag_t,
d1199 2
a1200 2
	bus_size_t);
static void bus_space_write_region_stream_8(bus_space_tag_t,
d1204 1
a1204 1
	bus_size_t);
d1251 1
a1251 1
 *	void bus_space_set_region_stream_N(bus_space_tag_t tag,
d1253 1
a1253 1
 *	    u_intN_t *addr, bus_size_t count);
d1256 1
a1256 1
static void bus_space_set_region_stream_1(bus_space_tag_t,
d1260 2
a1261 2
	bus_size_t);
static void bus_space_set_region_stream_2(bus_space_tag_t,
d1265 2
a1266 2
	bus_size_t);
static void bus_space_set_region_stream_4(bus_space_tag_t,
d1270 2
a1271 2
	bus_size_t);
static void bus_space_set_region_stream_8(bus_space_tag_t,
d1275 1
a1275 1
	bus_size_t);
d1323 1
a1323 1
 *	void bus_space_copy_region_stream_N(bus_space_tag_t tag,
d1326 1
a1326 1
 *	    bus_size_t count);
d1331 1
a1331 1
static void bus_space_copy_region_stream_1(bus_space_tag_t,
d1336 2
a1337 2
	bus_size_t);
static void bus_space_copy_region_stream_2(bus_space_tag_t,
d1342 2
a1343 2
	bus_size_t);
static void bus_space_copy_region_stream_4(bus_space_tag_t,
d1348 2
a1349 2
	bus_size_t);
static void bus_space_copy_region_stream_8(bus_space_tag_t,
d1354 1
a1354 1
	bus_size_t);
d1423 1
a1423 1
#define	BUS_DMA_BUS1		0x010	/* placeholders for bus functions... */
d1431 1
d1481 14
a1494 14
	int	(*_dmamap_create)(bus_dma_tag_t, bus_size_t, int,
		    bus_size_t, bus_size_t, int, bus_dmamap_t *);
	void	(*_dmamap_destroy)(bus_dma_tag_t, bus_dmamap_t);
	int	(*_dmamap_load)(bus_dma_tag_t, bus_dmamap_t, void *,
		    bus_size_t, struct proc *, int);
	int	(*_dmamap_load_mbuf)(bus_dma_tag_t, bus_dmamap_t,
		    struct mbuf *, int);
	int	(*_dmamap_load_uio)(bus_dma_tag_t, bus_dmamap_t,
		    struct uio *, int);
	int	(*_dmamap_load_raw)(bus_dma_tag_t, bus_dmamap_t,
		    bus_dma_segment_t *, int, bus_size_t, int);
	void	(*_dmamap_unload)(bus_dma_tag_t, bus_dmamap_t);
	void	(*_dmamap_sync)(bus_dma_tag_t, bus_dmamap_t,
		    bus_addr_t, bus_size_t, int);
d1499 9
a1507 9
	int	(*_dmamem_alloc)(bus_dma_tag_t, bus_size_t, bus_size_t,
		    bus_size_t, bus_dma_segment_t *, int, int *, int);
	void	(*_dmamem_free)(bus_dma_tag_t,
		    bus_dma_segment_t *, int);
	int	(*_dmamem_map)(bus_dma_tag_t, bus_dma_segment_t *,
		    int, size_t, caddr_t *, int);
	void	(*_dmamem_unmap)(bus_dma_tag_t, caddr_t, size_t);
	paddr_t	(*_dmamem_mmap)(bus_dma_tag_t, bus_dma_segment_t *,
		    int, off_t, int, int);
d1574 14
a1587 14
int	_bus_dmamap_create(bus_dma_tag_t, bus_size_t, int, bus_size_t,
	    bus_size_t, int, bus_dmamap_t *);
void	_bus_dmamap_destroy(bus_dma_tag_t, bus_dmamap_t);
int	_bus_dmamap_load(bus_dma_tag_t, bus_dmamap_t, void *,
	    bus_size_t, struct proc *, int);
int	_bus_dmamap_load_mbuf(bus_dma_tag_t, bus_dmamap_t,
	    struct mbuf *, int);
int	_bus_dmamap_load_uio(bus_dma_tag_t, bus_dmamap_t,
	    struct uio *, int);
int	_bus_dmamap_load_raw(bus_dma_tag_t, bus_dmamap_t,
	    bus_dma_segment_t *, int, bus_size_t, int);
void	_bus_dmamap_unload(bus_dma_tag_t, bus_dmamap_t);
void	_bus_dmamap_sync(bus_dma_tag_t, bus_dmamap_t, bus_addr_t,
	    bus_size_t, int);
d1589 1
a1589 1
int	_bus_dmamem_alloc(bus_dma_tag_t tag, bus_size_t size,
d1591 9
a1599 9
	    bus_dma_segment_t *segs, int nsegs, int *rsegs, int flags);
void	_bus_dmamem_free(bus_dma_tag_t tag, bus_dma_segment_t *segs,
	    int nsegs);
int	_bus_dmamem_map(bus_dma_tag_t tag, bus_dma_segment_t *segs,
	    int nsegs, size_t size, caddr_t *kvap, int flags);
void	_bus_dmamem_unmap(bus_dma_tag_t tag, caddr_t kva,
	    size_t size);
paddr_t	_bus_dmamem_mmap(bus_dma_tag_t tag, bus_dma_segment_t *segs,
	    int nsegs, off_t off, int prot, int flags);
d1601 1
a1601 1
int	_bus_dmamem_alloc_range(bus_dma_tag_t tag, bus_size_t size,
d1604 1
a1604 1
	    vaddr_t low, vaddr_t high);
@


1.7.4.4
log
@Sync the SMP branch with 3.3
@
text
@a86 3
#define BSDB_ASSERT	0x04
#define BSDB_MAPDETAIL	0x08
#define	BSDB_ALL_ACCESS	0x10
a88 38
#define BSHDB_ACCESS	0x01
#define BSHDB_NO_ACCESS	0x02

#if defined(BUS_SPACE_DEBUG)
#ifndef __SYSTM_H__
#include <sys/systm.h>
#endif
#define BUS_SPACE_PRINTF(l, s) do {				\
	if(bus_space_debug & (l)) printf s;			\
} while(0)
#define BUS_SPACE_TRACE(t, h, s) do {				\
	if ( (((bus_space_debug & BSDB_ALL_ACCESS) != 0) &&	\
		(((h).bh_flags & BSHDB_NO_ACCESS) == 0)) ||	\
	     (((bus_space_debug & BSDB_ACCESS) != 0) &&		\
		(((h).bh_flags & BSHDB_ACCESS) != 0)))		\
		printf s;					\
	} while(0)
#define BUS_SPACE_SET_FLAGS(t, h, f) ((h).bh_flags |= (f))
#define BUS_SPACE_CLEAR_FLAGS(t, h, f) ((h).bh_flags &= ~(f))
#define BUS_SPACE_FLAG_DECL(s)	int s
#define BUS_SPACE_SAVE_FLAGS(t, h, s) (s = (h).bh_flags)
#define BUS_SPACE_RESTORE_FLAGS(t, h, s) (s = (h).bh_flags)
#define BUS_SPACE_ASSERT(t, h, o, n) do {			\
	if (bus_space_debug & BSDB_ASSERT)			\
		bus_space_assert(t, &(h), o, n);		\
	} while(0)
#else /* BUS_SPACE_DEBUG */
#define BUS_SPACE_PRINTF(l, s)
#define BUS_SPACE_TRACE(t, h, s)
#define BUS_SPACE_SET_FLAGS(t, h, f)
#define BUS_SPACE_CLEAR_FLAGS(t, h, f)
#define BUS_SPACE_FLAG_DECL(s)
#define BUS_SPACE_SAVE_FLAGS(t, h, s)
#define BUS_SPACE_RESTORE_FLAGS(t, h, s)
#define BUS_SPACE_ASSERT(t, h, o, n)
#endif /* BUS_SPACE_DEBUG */


d104 2
d114 2
a115 1
typedef const struct sparc_bus_space_tag	*bus_space_tag_t;
a118 10

typedef struct _bus_space_handle {
        paddr_t		bh_ptr;
#ifdef BUS_SPACE_DEBUG
	bus_space_tag_t	bh_tag;
	bus_size_t	bh_size;
	int		bh_flags;
#endif
} bus_space_handle_t;

d120 3
a122 3
#define BUS_ADDR_IOSPACE(x)     ((x)>>32)
#define BUS_ADDR_PADDR(x)       ((x)&0xffffffff)
#define BUS_ADDR(io, pa)        ((((bus_addr_t)io)<<32)|(pa))
d127 1
d130 1
a130 1
	void	*cookie;
d132 1
a132 4
	enum bus_type default_type;
        u_int8_t	asi;
        u_int8_t	sasi;
	char	name[32];
a134 1
		bus_space_tag_t,
a139 1
		bus_space_tag_t,
d143 2
a144 7
		bus_space_tag_t,
		bus_addr_t,	bus_size_t,
		int, bus_space_handle_t *);

	int	(*sparc_bus_protect)(bus_space_tag_t,
		bus_space_tag_t,
		bus_space_handle_t, bus_size_t, int);
a146 1
		bus_space_tag_t,
a149 1
		bus_space_tag_t,
a153 1
		bus_space_tag_t,
a157 1
		bus_space_tag_t,
a160 1
		bus_space_tag_t,
d166 17
d186 1
a186 1
int		bus_space_alloc(
d196 1
a196 1
void		bus_space_free(
d200 1
a200 1
int		bus_space_map(
d206 1
a206 1
int		bus_space_protect(
d208 2
a209 1
				bus_space_handle_t,
d211 4
a214 2
				int);			/*flags*/
int		bus_space_unmap(
d218 1
a218 1
int		bus_space_subregion(
d230 1
a230 1
paddr_t		bus_space_mmap(
d236 1
a236 1
void	       *bus_intr_establish(
a243 7
void		bus_space_render_tag(
				bus_space_tag_t,
				char *,
				size_t);
void	       *bus_space_vaddr(
				bus_space_tag_t,
				bus_space_handle_t);
a244 6
#ifdef BUS_SPACE_DEBUG
void bus_space_assert(bus_space_tag_t,
	const bus_space_handle_t *,
	bus_size_t, int);
void bus_space_render_tag(bus_space_tag_t, char*, size_t);
#endif /* BUS_SPACE_DEBUG */
d246 73
d320 10
a329 4
#define _BS_PRECALL(t,f)		\
	while (t->f == NULL)		\
		t = t->parent;
#define _BS_POSTCALL
d331 11
a341 2
#define _BS_CALL(t,f)			\
	(*(t)->f)
d343 1
a343 1
static inline void
d351 1
a351 4
	const bus_space_tag_t t0 = t;
	_BS_PRECALL(t, sparc_bus_barrier);
	_BS_CALL(t, sparc_bus_barrier)(t, t0, h, o, s, f);
	_BS_POSTCALL;
d354 6
a359 1
#include <sparc64/sparc64/busop.h>
a365 1
#define BUS_SPACE_MAP_PROMADDRESS	0x0010
d388 1
d397 1016
a1432 3
#define	BUS_DMA_24BIT		BUS_DMA_BUS3	/* 24bit device */

#define BUS_DMA_RAW	BUS_DMA_STREAMING
a1459 7
	/*
	 * The following is to support bus_dmamem_alloc()'s
	 * odd interface.  Only the values in the first
	 * segment are used.  This means that 3/5ths of
	 * most segments are useless space (and mbufs use 1024
	 * segments).
	 */
d1480 8
a1487 8
	int	(*_dmamap_create)(bus_dma_tag_t, bus_dma_tag_t, bus_size_t,
		    int, bus_size_t, bus_size_t, int, bus_dmamap_t *);
	void	(*_dmamap_destroy)(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t);
	int	(*_dmamap_load)(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t,
		    void *, bus_size_t, struct proc *, int);
	int	(*_dmamap_load_mbuf)(bus_dma_tag_t, bus_dma_tag_t,
		    bus_dmamap_t, struct mbuf *, int);
	int	(*_dmamap_load_uio)(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t,
d1489 1
a1489 1
	int	(*_dmamap_load_raw)(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t,
d1491 2
a1492 2
	void	(*_dmamap_unload)(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t);
	void	(*_dmamap_sync)(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t,
d1498 3
a1500 4
	int	(*_dmamem_alloc)(bus_dma_tag_t, bus_dma_tag_t, bus_size_t,
		    bus_size_t, bus_size_t, bus_dma_segment_t *, int, int *,
		    int);
	void	(*_dmamem_free)(bus_dma_tag_t, bus_dma_tag_t,
d1502 5
a1506 6
	int	(*_dmamem_map)(bus_dma_tag_t, bus_dma_tag_t,
		    bus_dma_segment_t *, int, size_t, caddr_t *, int);
	void	(*_dmamem_unmap)(bus_dma_tag_t, bus_dma_tag_t, caddr_t,
		    size_t);
	paddr_t	(*_dmamem_mmap)(bus_dma_tag_t, bus_dma_tag_t,
		    bus_dma_segment_t *, int, off_t, int, int);
d1509 28
a1536 136
#define _BD_PRECALL(t,f)		\
	while (t->f == NULL) {		\
		t = t->_parent;		\
	}
#define _BD_CALL(t,f)			\
	(*(t)->f)
#define _BD_POSTCALL

static inline int
bus_dmamap_create(bus_dma_tag_t t, bus_size_t s, int n, bus_size_t m,
    bus_size_t b, int f, bus_dmamap_t *p)
{
	int r;
	const bus_dma_tag_t t0 = t;
	_BD_PRECALL(t, _dmamap_create);
	r = _BD_CALL(t, _dmamap_create)(t, t0, s, n, m, b, f, p);
	_BD_POSTCALL;
	return (r);
}
static inline void
bus_dmamap_destroy(bus_dma_tag_t t, bus_dmamap_t p)
{
	const bus_dma_tag_t t0 = t;
	_BD_PRECALL(t, _dmamap_destroy);
	_BD_CALL(t, _dmamap_destroy)(t, t0, p);
	_BD_POSTCALL;
}
static inline int
bus_dmamap_load(bus_dma_tag_t t, bus_dmamap_t m, void *b, bus_size_t s,
    struct proc *p, int f)
{
	const bus_dma_tag_t t0 = t;
	int r;
	_BD_PRECALL(t, _dmamap_load);
	r = _BD_CALL(t, _dmamap_load)(t, t0, m, b, s, p, f);
	_BD_POSTCALL;
	return (r);
}
static inline int
bus_dmamap_load_mbuf(bus_dma_tag_t t, bus_dmamap_t m, struct mbuf *b,
    int f)
{
	const bus_dma_tag_t t0 = t;
	int r;
	_BD_PRECALL(t, _dmamap_load_mbuf);
	r = _BD_CALL(t, _dmamap_load_mbuf)(t, t0, m, b, f);
	_BD_POSTCALL;
	return (r);
}
static inline int
bus_dmamap_load_uio(bus_dma_tag_t t, bus_dmamap_t m, struct uio * u, int f)
{
	const bus_dma_tag_t t0 = t;
	int r;
	_BD_PRECALL(t, _dmamap_load_uio);
	r = _BD_CALL(t, _dmamap_load_uio)(t, t0, m, u, f);
	_BD_POSTCALL;
	return (r);
}
static inline int
bus_dmamap_load_raw(bus_dma_tag_t t, bus_dmamap_t m, bus_dma_segment_t *sg,
    int n, bus_size_t s, int f)
{
	const bus_dma_tag_t t0 = t;
	int r;
	_BD_PRECALL(t, _dmamap_load_raw);
	r = _BD_CALL(t, _dmamap_load_raw)(t, t0, m, sg, n, s, f);
	_BD_POSTCALL;
	return (r);
}
static inline void
bus_dmamap_unload(bus_dma_tag_t t, bus_dmamap_t p)
{
	const bus_dma_tag_t t0 = t;
	_BD_PRECALL(t, _dmamap_unload);
	_BD_CALL(t, _dmamap_unload)(t, t0, p);
	_BD_POSTCALL;
}
static inline void
bus_dmamap_sync(bus_dma_tag_t t, bus_dmamap_t p, bus_addr_t o, bus_size_t l,
    int ops)
{
	const bus_dma_tag_t t0 = t;
	_BD_PRECALL(t, _dmamap_sync);
	_BD_CALL(t, _dmamap_sync)(t, t0, p, o, l, ops);
	_BD_POSTCALL;
}
static inline int
bus_dmamem_alloc(bus_dma_tag_t t, bus_size_t s, bus_size_t a, bus_size_t b,
    bus_dma_segment_t *sg, int n, int *r, int f)
{
	const bus_dma_tag_t t0 = t;
	int ret;
	_BD_PRECALL(t, _dmamem_alloc);
	ret = _BD_CALL(t, _dmamem_alloc)(t, t0, s, a, b, sg, n, r, f);
	_BD_POSTCALL;
	return (ret);
}
static inline void
bus_dmamem_free(bus_dma_tag_t t, bus_dma_segment_t *sg, int n)
{
	const bus_dma_tag_t t0 = t;
	_BD_PRECALL(t, _dmamem_free);
	_BD_CALL(t, _dmamem_free)(t, t0, sg, n);
	_BD_POSTCALL;
}
static inline int
bus_dmamem_map(bus_dma_tag_t t, bus_dma_segment_t *sg, int n, size_t s,
    caddr_t *k, int f)
{
	const bus_dma_tag_t t0 = t;
	int r;
	_BD_PRECALL(t, _dmamem_map);
	r = _BD_CALL(t, _dmamem_map)(t, t0, sg, n, s, k, f);
	_BD_POSTCALL;
	return (r);
}
static inline void
bus_dmamem_unmap(bus_dma_tag_t t, caddr_t k, size_t s)
{
	const bus_dma_tag_t t0 = t;
	_BD_PRECALL(t, _dmamem_unmap);
	_BD_CALL(t, _dmamem_unmap)(t, t0, k, s);
	_BD_POSTCALL;
}
static inline paddr_t
bus_dmamem_mmap(bus_dma_tag_t t, bus_dma_segment_t *sg, int n, off_t o, int p,
    int f)
{
	const bus_dma_tag_t t0 = t;
	int r;
	_BD_PRECALL(t, _dmamem_mmap);
	r = _BD_CALL(t, _dmamem_mmap)(t, t0, sg, n, o, p, f);
	_BD_POSTCALL;
	return (r);
}
d1559 2
a1560 2
	int		_dm_type;	/* mapping type: raw, uio, mbuf, etc */
	void		*_dm_source;	/* source mbuf/uio/etc. for unload */
a1568 1

d1572 34
a1606 1

@


1.7.4.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d224 1
a224 2
		int (*)(void *), void *,
		const char *);
d285 1
a285 12
				void *,			/*handler arg*/
				const char *);		/*what*/
void	       *bus_intr_allocate(
				bus_space_tag_t,
				int (*)(void *),	/*handler*/
				void *,			/*handler arg*/
				int,			/*number*/
				int,			/*pil*/
				volatile u_int64_t *,	/*map*/
				volatile u_int64_t *,	/*clr*/
				const char *);		/*what*/
void		bus_intr_free(void *);
@


1.6
log
@define BUS_DMA_RAW
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.5 2001/08/30 19:50:26 jason Exp $	*/
d42 1
a42 1
 * Copyright (c) 1997-1999 Eduardo E. Horvath. All rights reserved.
d1518 1
a1518 1
	 * PRIVATE MEMBERS: not for use my machine-independent code.
d1520 3
d1533 1
a1533 1
	void		*_dm_source;	/* source mbuf, uio, etc. needed for unload *///////////////////////
@


1.5
log
@add __HAS_NEW_BUS_DMAMAP_SYNC
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.4 2001/08/23 14:24:58 art Exp $	*/
d1375 1
@


1.4
log
@fix args in stream -> raw conversion.
I just love the knights who say NiH!
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.3 2001/08/22 20:11:09 art Exp $	*/
d78 2
@


1.3
log
@Some "raw" wrappers around "stream" methods.

Also, define __HAVE_NEW_BUS_DMAMAP_SYNC, we will have to start converting
code to using the five-argument variant on bus_dmamap_sync.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.2 2001/08/20 20:23:52 jason Exp $	*/
d1374 1
a1374 1
	bus_space_read_multi_stream_2(t, h, o, (u_int8_t *)(a), c)
d1376 1
a1376 1
	bus_space_write_multi_stream_2(t, h, o, (u_int8_t *)(a), c)
d1378 1
a1378 1
	bus_space_read_multi_stream_4(t, h, o, (u_int8_t *)(a), c)
d1380 1
a1380 1
	bus_space_write_multi_stream_4(t, h, o, (u_int8_t *)(a), c)
@


1.2
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d1371 10
d1415 2
@


1.1
log
@More includes from NetBSD.
No modifications.
@
text
@d1 1
@

