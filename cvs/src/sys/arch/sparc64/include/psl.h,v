head	1.32;
access;
symbols
	OPENBSD_6_2_BASE:1.32
	OPENBSD_6_1:1.31.0.6
	OPENBSD_6_1_BASE:1.31
	OPENBSD_6_0:1.31.0.2
	OPENBSD_6_0_BASE:1.31
	OPENBSD_5_9:1.28.0.6
	OPENBSD_5_9_BASE:1.28
	OPENBSD_5_8:1.28.0.8
	OPENBSD_5_8_BASE:1.28
	OPENBSD_5_7:1.28.0.2
	OPENBSD_5_7_BASE:1.28
	OPENBSD_5_6:1.28.0.4
	OPENBSD_5_6_BASE:1.28
	OPENBSD_5_5:1.27.0.18
	OPENBSD_5_5_BASE:1.27
	OPENBSD_5_4:1.27.0.14
	OPENBSD_5_4_BASE:1.27
	OPENBSD_5_3:1.27.0.12
	OPENBSD_5_3_BASE:1.27
	OPENBSD_5_2:1.27.0.10
	OPENBSD_5_2_BASE:1.27
	OPENBSD_5_1_BASE:1.27
	OPENBSD_5_1:1.27.0.8
	OPENBSD_5_0:1.27.0.6
	OPENBSD_5_0_BASE:1.27
	OPENBSD_4_9:1.27.0.4
	OPENBSD_4_9_BASE:1.27
	OPENBSD_4_8:1.27.0.2
	OPENBSD_4_8_BASE:1.27
	OPENBSD_4_7:1.26.0.2
	OPENBSD_4_7_BASE:1.26
	OPENBSD_4_6:1.26.0.4
	OPENBSD_4_6_BASE:1.26
	OPENBSD_4_5:1.25.0.4
	OPENBSD_4_5_BASE:1.25
	OPENBSD_4_4:1.25.0.2
	OPENBSD_4_4_BASE:1.25
	OPENBSD_4_3:1.23.0.4
	OPENBSD_4_3_BASE:1.23
	OPENBSD_4_2:1.23.0.2
	OPENBSD_4_2_BASE:1.23
	OPENBSD_4_1:1.22.0.2
	OPENBSD_4_1_BASE:1.22
	OPENBSD_4_0:1.21.0.2
	OPENBSD_4_0_BASE:1.21
	OPENBSD_3_9:1.19.0.4
	OPENBSD_3_9_BASE:1.19
	OPENBSD_3_8:1.19.0.2
	OPENBSD_3_8_BASE:1.19
	OPENBSD_3_7:1.12.0.2
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.11.0.6
	OPENBSD_3_6_BASE:1.11
	SMP_SYNC_A:1.11
	SMP_SYNC_B:1.11
	OPENBSD_3_5:1.11.0.4
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	UBC_SYNC_A:1.9
	OPENBSD_3_3:1.8.0.4
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4
	UBC_SYNC_B:1.8
	UBC:1.2.0.6
	UBC_BASE:1.2
	SMP:1.2.0.4
	OPENBSD_3_0:1.2.0.2
	OPENBSD_3_0_BASE:1.2
	SPARC64:1.1.1.1
	NETBSD:1.1.1;
locks; strict;
comment	@ * @;


1.32
date	2017.05.25.03.19.39;	author dlg;	state Exp;
branches;
next	1.31;
commitid	gx8rjMxrMcqYnydg;

1.31
date	2016.06.13.01.08.13;	author dlg;	state Exp;
branches;
next	1.30;
commitid	xgGjlZUxf6R8Dc1y;

1.30
date	2016.06.07.06.37.33;	author dlg;	state Exp;
branches;
next	1.29;
commitid	dmTQ1og9kfP20jHH;

1.29
date	2016.03.07.13.21.51;	author naddy;	state Exp;
branches;
next	1.28;
commitid	EDvRPKRZUDEEb6oR;

1.28
date	2014.03.29.18.09.30;	author guenther;	state Exp;
branches;
next	1.27;

1.27
date	2010.05.31.21.39.56;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2009.03.15.19.40.40;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2008.07.05.20.53.33;	author kettenis;	state Exp;
branches;
next	1.24;

1.24
date	2008.05.24.19.59.06;	author kettenis;	state Exp;
branches;
next	1.23;

1.23
date	2007.05.16.19.37.06;	author thib;	state Exp;
branches;
next	1.22;

1.22
date	2006.12.14.15.10.32;	author kettenis;	state Exp;
branches;
next	1.21;

1.21
date	2006.05.20.14.18.35;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2006.03.12.03.00.32;	author brad;	state Exp;
branches;
next	1.19;

1.19
date	2005.06.29.07.17.22;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2005.06.29.07.11.14;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2005.06.29.06.30.18;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2005.05.31.09.31.16;	author art;	state Exp;
branches;
next	1.15;

1.15
date	2005.05.29.03.20.40;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2005.05.25.23.17.47;	author niklas;	state Exp;
branches;
next	1.13;

1.13
date	2005.04.19.15.29.48;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	2005.01.05.18.42.28;	author fgsch;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.02.23.27.56;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2003.05.23.02.00.51;	author henric;	state Exp;
branches;
next	1.9;

1.9
date	2003.05.16.22.14.13;	author henric;	state Exp;
branches;
next	1.8;

1.8
date	2002.06.15.17.23.31;	author art;	state Exp;
branches;
next	1.7;

1.7
date	2002.06.11.05.01.17;	author art;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.21.16.15.53;	author art;	state Exp;
branches;
next	1.5;

1.5
date	2002.04.29.07.35.23;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2002.03.14.03.16.01;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2002.03.14.01.26.45;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2001.08.18.19.46.04;	author art;	state Exp;
branches
	1.2.4.1
	1.2.6.1;
next	1.1;

1.1
date	2001.08.18.04.16.40;	author jason;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.08.18.04.16.40;	author jason;	state Exp;
branches;
next	;

1.2.4.1
date	2001.10.31.03.07.58;	author nate;	state Exp;
branches;
next	1.2.4.2;

1.2.4.2
date	2002.03.28.11.23.52;	author niklas;	state Exp;
branches;
next	1.2.4.3;

1.2.4.3
date	2003.03.27.23.42.36;	author niklas;	state Exp;
branches;
next	1.2.4.4;

1.2.4.4
date	2003.06.07.11.14.45;	author ho;	state Exp;
branches;
next	;

1.2.6.1
date	2002.06.11.03.38.43;	author art;	state Exp;
branches;
next	1.2.6.2;

1.2.6.2
date	2002.10.29.00.28.11;	author art;	state Exp;
branches;
next	1.2.6.3;

1.2.6.3
date	2003.05.19.21.46.57;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.32
log
@tweak sparc64 membars as a step toward making them usable in userland.

specifically, dont rely on magic in ctlreg to implement membars. moving
that to atomic.h would add a lot of pollution to the namespace, so
move to passing the membar options to a single __membar macro.

this tweaks everything that was using the ctlreg backend to either use
an appropriate membar_foo(), or to use __membar() in the MD code.

ok kettenis@@
@
text
@/*	$OpenBSD: psl.h,v 1.31 2016/06/13 01:08:13 dlg Exp $	*/
/*	$NetBSD: psl.h,v 1.20 2001/04/13 23:30:05 thorpej Exp $ */

/*
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
 *
 * All advertising materials mentioning features or use of this software
 * must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Lawrence Berkeley Laboratory.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)psl.h	8.1 (Berkeley) 6/11/93
 */

#ifndef _SPARC64_PSL_
#define _SPARC64_PSL_

/* Interesting spl()s */
#define PIL_SCSI	3
#define PIL_BIO		5
#define PIL_VIDEO	5
#define PIL_TTY		6
#define PIL_NET		6
#define PIL_VM		7
#define	PIL_AUD		8
#define PIL_CLOCK	10
#define PIL_FD		11
#define PIL_SER		12
#define PIL_STATCLOCK	14
#define PIL_HIGH	15
#define PIL_SCHED	PIL_STATCLOCK
#define PIL_LOCK	PIL_HIGH

/* 
 * SPARC V9 CCR register
 */

#define ICC_C	0x01L
#define ICC_V	0x02L
#define ICC_Z	0x04L
#define ICC_N	0x08L
#define XCC_SHIFT	4
#define XCC_C	(ICC_C<<XCC_SHIFT)
#define XCC_V	(ICC_V<<XCC_SHIFT)
#define XCC_Z	(ICC_Z<<XCC_SHIFT)
#define XCC_N	(ICC_N<<XCC_SHIFT)


/*
 * SPARC V9 PSTATE register (what replaces the PSR in V9)
 *
 * Here's the layout:
 *
 *    11   10    9     8   7  6   5     4     3     2     1   0
 *  +------------------------------------------------------------+
 *  | IG | MG | CLE | TLE | MM | RED | PEF | AM | PRIV | IE | AG |
 *  +------------------------------------------------------------+
 */

#define PSTATE_IG	0x800	/* enable spitfire interrupt globals */
#define PSTATE_MG	0x400	/* enable spitfire MMU globals */
#define PSTATE_CLE	0x200	/* current little endian */
#define PSTATE_TLE	0x100	/* traps little endian */
#define PSTATE_MM	0x0c0	/* memory model */
#define PSTATE_MM_TSO	0x000	/* total store order */
#define PSTATE_MM_PSO	0x040	/* partial store order */
#define PSTATE_MM_RMO	0x080	/* Relaxed memory order */
#define PSTATE_RED	0x020	/* RED state */
#define PSTATE_PEF	0x010	/* enable floating point */
#define PSTATE_AM	0x008	/* 32-bit address masking */
#define PSTATE_PRIV	0x004	/* privileged mode */
#define PSTATE_IE	0x002	/* interrupt enable */
#define PSTATE_AG	0x001	/* enable alternate globals */

#define PSTATE_BITS "\20\14IG\13MG\12CLE\11TLE\10\7MM\6RED\5PEF\4AM\3PRIV\2IE\1AG"


/*
 * 32-bit code requires TSO or at best PSO since that's what's supported on
 * SPARC V8 and earlier machines.
 *
 * 64-bit code sets the memory model in the ELF header.
 *
 * We're running kernel code in TSO for the moment so we don't need to worry
 * about possible memory barrier bugs.
 */

#define PSTATE_PROM	(PSTATE_MM_TSO|PSTATE_PRIV)
#define PSTATE_NUCLEUS	(PSTATE_MM_TSO|PSTATE_PRIV|PSTATE_AG)
#define PSTATE_KERN	(PSTATE_MM_TSO|PSTATE_PRIV)
#define PSTATE_INTR	(PSTATE_KERN|PSTATE_IE)
#define PSTATE_USER32	(PSTATE_MM_TSO|PSTATE_AM|PSTATE_IE)
#define PSTATE_USER	(PSTATE_MM_RMO|PSTATE_IE)


/*
 * SPARC V9 TSTATE register
 *
 *   39 32 31 24 23 18  17   8	7 5 4   0
 *  +-----+-----+-----+--------+---+-----+
 *  | CCR | ASI |  -  | PSTATE | - | CWP |
 *  +-----+-----+-----+--------+---+-----+
 */

#define TSTATE_CWP		0x01f
#define TSTATE_PSTATE		0x6ff00
#define TSTATE_PSTATE_SHIFT	8
#define TSTATE_ASI		0xff000000LL
#define TSTATE_ASI_SHIFT	24
#define TSTATE_CCR		0xff00000000LL
#define TSTATE_CCR_SHIFT	32

/* Leftover SPARC V8 PSTATE stuff */
#define PSR_ICC 0x00f00000
#define PSRCC_TO_TSTATE(x)	(((int64_t)(x)&PSR_ICC)<<(TSTATE_CCR_SHIFT-19))
#define TSTATECCR_TO_PSR(x)	(((x)&TSTATE_CCR)>>(TSTATE_CCR_SHIFT-19))

/*
 * These are here to simplify life.
 */
#define TSTATE_IG	(PSTATE_IG<<TSTATE_PSTATE_SHIFT)
#define TSTATE_MG	(PSTATE_MG<<TSTATE_PSTATE_SHIFT)
#define TSTATE_CLE	(PSTATE_CLE<<TSTATE_PSTATE_SHIFT)
#define TSTATE_TLE	(PSTATE_TLE<<TSTATE_PSTATE_SHIFT)
#define TSTATE_MM	(PSTATE_MM<<TSTATE_PSTATE_SHIFT)
#define TSTATE_MM_TSO	(PSTATE_MM_TSO<<TSTATE_PSTATE_SHIFT)
#define TSTATE_MM_PSO	(PSTATE_MM_PSO<<TSTATE_PSTATE_SHIFT)
#define TSTATE_MM_RMO	(PSTATE_MM_RMO<<TSTATE_PSTATE_SHIFT)
#define TSTATE_RED	(PSTATE_RED<<TSTATE_PSTATE_SHIFT)
#define TSTATE_PEF	(PSTATE_PEF<<TSTATE_PSTATE_SHIFT)
#define TSTATE_AM	(PSTATE_AM<<TSTATE_PSTATE_SHIFT)
#define TSTATE_PRIV	(PSTATE_PRIV<<TSTATE_PSTATE_SHIFT)
#define TSTATE_IE	(PSTATE_IE<<TSTATE_PSTATE_SHIFT)
#define TSTATE_AG	(PSTATE_AG<<TSTATE_PSTATE_SHIFT)

#define TSTATE_BITS "\20\14IG\13MG\12CLE\11TLE\10\7MM\6RED\5PEF\4AM\3PRIV\2IE\1AG"

#define TSTATE_KERN	((PSTATE_KERN)<<TSTATE_PSTATE_SHIFT)
#define TSTATE_USER	((PSTATE_USER)<<TSTATE_PSTATE_SHIFT)
/*
 * SPARC V9 VER version register.
 *
 *  63   48 47  32 31  24 23 16 15    8 7 5 4      0
 * +-------+------+------+-----+-------+---+--------+
 * | manuf | impl | mask |  -  | maxtl | - | maxwin |
 * +-------+------+------+-----+-------+---+--------+
 *
 */

#define VER_MANUF	0xffff000000000000ULL
#define VER_MANUF_SHIFT	48
#define VER_IMPL	0x0000ffff00000000ULL
#define VER_IMPL_SHIFT	32
#define VER_MASK	0x00000000ff000000ULL
#define VER_MASK_SHIFT	24
#define VER_MAXTL	0x000000000000ff00ULL
#define VER_MAXTL_SHIFT	8
#define VER_MAXWIN	0x000000000000001fULL

#define IMPL_SPARC64		0x01 /* SPARC64 */
#define IMPL_SPARC64_II		0x02 /* SPARC64-II */
#define IMPL_SPARC64_III	0x03 /* SPARC64-III */
#define IMPL_SPARC64_IV		0x04 /* SPARC64-IV */
#define IMPL_ZEUS		0x05 /* SPARC64-V */
#define IMPL_OLYMPUS_C		0x06 /* SPARC64-VI */
#define IMPL_JUPITER		0x07 /* SPARC64-VII */
#define IMPL_SPITFIRE		0x10 /* UltraSPARC */
#define IMPL_BLACKBIRD		0x11 /* UltraSPARC-II */
#define IMPL_SABRE		0x12 /* UltraSPARC-IIi */
#define IMPL_HUMMINGBIRD	0x13 /* UltraSPARC-IIe */
#define IMPL_CHEETAH		0x14 /* UltraSPARC-III */
#define IMPL_CHEETAH_PLUS	0x15 /* UltraSPARC-III+ */
#define IMPL_JALAPENO		0x16 /* UltraSPARC-IIIi */
#define IMPL_JAGUAR		0x18 /* UltraSPARC-IV */
#define IMPL_PANTHER		0x19 /* UltraSPARC-IV+ */
#define IMPL_SERRANO		0x22 /* UltraSPARC-IIIi+ */

/*
 * Here are a few things to help us transition between user and kernel mode:
 */

/* Memory models */
#define KERN_MM		PSTATE_MM_TSO
#define USER_MM		PSTATE_MM_RMO

/* 
 * Register window handlers.  These point to generic routines that check the
 * stack pointer and then vector to the real handler.  We could optimize this
 * if we could guarantee only 32-bit or 64-bit stacks.
 */
#define WSTATE_KERN	027
#define WSTATE_USER	022

#define CWP		0x01f

/* 64-byte alignment -- this seems the best place to put this. */
#define BLOCK_SIZE	64
#define BLOCK_ALIGN	0x3f

#if defined(_KERNEL) && !defined(_LOCORE)

extern u_int64_t ver;	/* Copy of v9 version register.  We need to read this only once, in locore.s. */
#ifndef SPLDEBUG
extern __inline void splx(int);
#endif

#ifdef DIAGNOSTIC
/*
 * Although this function is implemented in MI code, it must be in this MD
 * header because we don't want this header to include MI includes.
 */
void splassert_fail(int, int, const char *);
extern int splassert_ctl;
void splassert_check(int, const char *);
#define splassert(__wantipl) do {			\
	if (splassert_ctl > 0) {			\
		splassert_check(__wantipl, __func__);	\
	}						\
} while (0)
#define splsoftassert(wantipl) splassert(wantipl)
#else
#define splassert(wantipl)	do { /* nada */ } while (0)
#define splsoftassert(wantipl)	do { /* nada */ } while (0)
#endif

/*
 * GCC pseudo-functions for manipulating privileged registers
 */
extern __inline u_int64_t getpstate(void);
extern __inline
u_int64_t getpstate(void)
{
	return (sparc_rdpr(pstate));
}

extern __inline void setpstate(u_int64_t);
extern __inline void setpstate(u_int64_t newpstate)
{
	sparc_wrpr(pstate, newpstate, 0);
}

extern __inline int getcwp(void);
extern __inline
int getcwp(void)
{
	return (sparc_rdpr(cwp));
}

extern __inline void setcwp(u_int64_t);
extern __inline void
setcwp(u_int64_t newcwp)
{
	sparc_wrpr(cwp, newcwp, 0);
}

extern __inline u_int64_t getver(void);
extern __inline
u_int64_t getver(void)
{
	return (sparc_rdpr(ver));
}

extern __inline u_int64_t intr_disable(void);
extern __inline u_int64_t
intr_disable(void)
{
	u_int64_t s;

	s = sparc_rdpr(pstate);
	sparc_wrpr(pstate, s & ~PSTATE_IE, 0);
	return (s);
}

extern __inline void intr_restore(u_int64_t);
extern __inline void
intr_restore(u_int64_t s)
{
	sparc_wrpr(pstate, s, 0);
}

extern __inline void stxa_sync(u_int64_t, u_int64_t, u_int64_t);
extern __inline void
stxa_sync(u_int64_t va, u_int64_t asi, u_int64_t val)
{
	u_int64_t s = intr_disable();
	stxa_nc(va, asi, val);
	__asm volatile("membar #Sync" : : : "memory");
	intr_restore(s);
}

static inline int
_spl(int newipl)
{
	int oldpil;

	__asm volatile(	"    rdpr %%pil, %0		\n"
			"    wrpr %%g0, %1, %%pil	\n"
	    : "=&r" (oldpil)
	    : "I" (newipl)
	    : "%g0");
	__asm volatile("" : : : "memory");

	return (oldpil);
}

/* A non-priority-decreasing version of SPL */
static inline int
_splraise(int newpil)
{
	int oldpil;

	oldpil = sparc_rdpr(pil);
	if (newpil > oldpil)
		sparc_wrpr(pil, newpil, 0);
        return (oldpil);
}

static inline void
_splx(int newpil)
{
	sparc_wrpr(pil, newpil, 0);
}

#endif /* KERNEL && !_LOCORE */

#endif /* _SPARC64_PSL_ */
@


1.31
log
@rework sparc64 splfoo functions to be more consistent with other archs

this also moves us toward having an MI splraise().

sparc64 (and sparc) are different to the other archs because they
have macros that build templates. each spl uses that macro to create
an instance of an inline function specific to that spl call.

this moves it to having a single splraise inline that the spl api is
defined with. eg, #define splfoo() _splraise(IPL_FOO).

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: psl.h,v 1.30 2016/06/07 06:37:33 dlg Exp $	*/
d316 1
a316 1
	membar(Sync);
@


1.30
log
@remove splsoftfd and splausoft

theyre unused.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: psl.h,v 1.29 2016/03/07 13:21:51 naddy Exp $	*/
d320 11
a330 3
/*
 * GCC pseudo-functions for manipulating PIL
 */
d332 1
a332 12
#ifdef SPLDEBUG
void prom_printf(const char *fmt, ...);
extern int printspl;
#define SPLPRINT(x)	if(printspl) { int i=10000000; prom_printf x ; while(i--); }
#define	SPL(name, newpil)						\
extern __inline int name##X(const char *, int);				\
extern __inline int name##X(const char *file, int line)			\
{									\
	u_int64_t oldpil = sparc_rdpr(pil);				\
	SPLPRINT(("{%s:%d %d=>%d}", file, line, oldpil, newpil));	\
	sparc_wrpr(pil, newpil, 0);					\
	return (oldpil);						\
d334 1
d336 4
a339 11
#define	SPLHOLD(name, newpil) \
extern __inline int name##X(const char *, int);				\
extern __inline int name##X(const char * file, int line)		\
{									\
	int oldpil = sparc_rdpr(pil);					\
	if (__predict_false((u_int64_t)newpil <= oldpil))		\
		return (oldpil);					\
	SPLPRINT(("{%s:%d %d->!d}", file, line, oldpil, newpil));	\
	sparc_wrpr(pil, newpil, 0);					\
	return (oldpil);						\
}
d341 4
a344 44
#else
#define SPLPRINT(x)	
#define	SPL(name, newpil)						\
extern __inline int name(void);						\
extern __inline int name()						\
{									\
	int oldpil;							\
	__asm volatile("    rdpr %%pil, %0		\n"		\
			 "    wrpr %%g0, %1, %%pil	\n"		\
	    : "=&r" (oldpil)						\
	    : "n" (newpil)						\
	    : "%g0");							\
	__asm volatile("" : : : "memory");				\
	return (oldpil);						\
}
/* A non-priority-decreasing version of SPL */
#define	SPLHOLD(name, newpil)						\
extern __inline int name(void);						\
extern __inline int name()						\
{									\
	int oldpil;							\
									\
	if (newpil <= 1) {						\
		__asm volatile("    rdpr	%%pil, %0	\n"	\
				 "    brnz,pn	%0, 1f		\n"	\
				 "     nop			\n"	\
				 "    wrpr	%%g0, %1, %%pil	\n"	\
				 "1:				\n"	\
	    : "=&r" (oldpil)						\
	    : "I" (newpil)						\
	    : "%g0");							\
	} else {							\
		__asm volatile("    rdpr	%%pil, %0	\n"	\
				 "    cmp	%0, %1 - 1	\n"	\
				 "    bgu,pn	%%xcc, 1f	\n"	\
				 "     nop			\n"	\
				 "    wrpr	%%g0, %1, %%pil	\n"	\
				 "1:				\n"	\
	    : "=&r" (oldpil)						\
	    : "I" (newpil)						\
	    : "cc");							\
	}								\
	__asm volatile("" : : : "memory");				\
	return (oldpil);						\
a345 10
#endif

SPL(spl0, 0)

SPLHOLD(splsoftint, 1)
#define	splsoftclock	splsoftint
#define	splsoftnet	splsoftint

/* Block devices */
SPLHOLD(splbio, PIL_BIO)
d347 2
a348 57
/* network hardware interrupts are at level 6 */
SPLHOLD(splnet, PIL_NET)

/* tty input runs at software level 6 */
SPLHOLD(spltty, PIL_TTY)

/*
 * Memory allocation (must be as high as highest network, tty, or disk device)
 */
SPLHOLD(splvm, PIL_VM)

SPLHOLD(splclock, PIL_CLOCK)

/* fd hardware interrupts are at level 11 */
SPLHOLD(splfd, PIL_FD)

/* zs hardware interrupts are at level 12 */
SPLHOLD(splzs, PIL_SER)
SPLHOLD(splserial, PIL_SER)

/* audio hardware interrupts are at level 13 */
SPLHOLD(splaudio, PIL_AUD)

/* second sparc timer interrupts at level 14 */
SPLHOLD(splstatclock, PIL_STATCLOCK)

SPLHOLD(splsched, PIL_SCHED)
SPLHOLD(spllock, PIL_LOCK)

SPLHOLD(splhigh, PIL_HIGH)

/* splx does not have a return value */
#ifdef SPLDEBUG

#define	spl0()		spl0X(__FILE__, __LINE__)
#define	splsoftint()	splsoftintX(__FILE__, __LINE__)
#define	splbio()	splbioX(__FILE__, __LINE__)
#define	splnet()	splnetX(__FILE__, __LINE__)
#define	spltty()	splttyX(__FILE__, __LINE__)
#define	splvm()		splvmX(__FILE__, __LINE__)
#define	splclock()	splclockX(__FILE__, __LINE__)
#define	splfd()		splfdX(__FILE__, __LINE__)
#define	splzs()		splzsX(__FILE__, __LINE__)
#define	splserial()	splzerialX(__FILE__, __LINE__)
#define	splaudio()	splaudioX(__FILE__, __LINE__)
#define	splstatclock()	splstatclockX(__FILE__, __LINE__)
#define	splsched()	splschedX(__FILE__, __LINE__)
#define	spllock()	spllockX(__FILE__, __LINE__)
#define	splhigh()	splhighX(__FILE__, __LINE__)
#define splx(x)		splxX((x),__FILE__, __LINE__)

extern __inline void splxX(u_int64_t, const char *, int);
extern __inline void
splxX(u_int64_t newpil, const char *file, int line)
#else
extern __inline void splx(int newpil)
#endif
a349 4
#ifdef SPLDEBUG
	u_int64_t oldpil = sparc_rdpr(pil);
	SPLPRINT(("{%d->%d}", oldpil, newpil));
#endif
d352 1
@


1.29
log
@Sync no-argument function declaration and definition by adding (void).
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: psl.h,v 1.28 2014/03/29 18:09:30 guenther Exp $	*/
a48 2
#define PIL_FDSOFT	4
#define PIL_AUSOFT	4
a402 6
/* audio software interrupts are at software level 4 */
SPLHOLD(splausoft, PIL_AUSOFT)

/* floppy software interrupts are at software level 4 too */
SPLHOLD(splfdsoft, PIL_FDSOFT)

a441 2
#define	splausoft()	splausoftX(__FILE__, __LINE__)
#define	splfdsoft()	splfdsoftX(__FILE__, __LINE__)
@


1.28
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: psl.h,v 1.27 2010/05/31 21:39:56 deraadt Exp $	*/
d262 1
a262 1
u_int64_t getpstate()
d275 1
a275 1
int getcwp()
d289 1
a289 1
u_int64_t getver()
d296 1
a296 1
intr_disable()
@


1.27
log
@there is no spllpt(), since lpt's are just tty devices (call tty functions,
and thus should be using spltty()
from Matthew Dempsky
ok oga guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: psl.h,v 1.26 2009/03/15 19:40:40 miod Exp $	*/
d359 1
a359 1
	__asm __volatile("    rdpr %%pil, %0		\n"		\
d364 1
a364 1
	__asm __volatile("" : : : "memory");				\
d375 1
a375 1
		__asm __volatile("    rdpr	%%pil, %0	\n"	\
d384 1
a384 1
		__asm __volatile("    rdpr	%%pil, %0	\n"	\
d394 1
a394 1
	__asm __volatile("" : : : "memory");				\
@


1.26
log
@Introduce splsoftassert(), similar to splassert() but for soft interrupt
levels. This will allow for platforms where soft interrupt levels do not
map to real hardware interrupt levels to have soft ipl values overlapping
hard ipl values without breaking spl asserts.
@
text
@d1 1
a1 1
/*	$OpenBSD: psl.h,v 1.25 2008/07/05 20:53:33 kettenis Exp $	*/
a53 1
#define PIL_LPT		6
a419 3
/* parallel port runs at software level 6 */
SPLHOLD(spllpt, PIL_LPT)

a454 1
#define	spllpt()	spllptX(__FILE__, __LINE__)
@


1.25
log
@The firmware on the v1280 changes %wstate behind our back.  Work around this
problem by adopting the same encoding used by Solaris for the kernel windows.
Note that this involves rearranging the trap vector tables, both fur sun4u and
for sun4v.
@
text
@d1 1
a1 1
/*	$OpenBSD: psl.h,v 1.24 2008/05/24 19:59:06 kettenis Exp $	*/
d252 1
d254 2
a255 1
#define splassert(wantipl) do { /* nada */ } while (0)
@


1.24
log
@Add VER.impl values for Fujitsu CPUs.
@
text
@d1 1
a1 1
/*	$OpenBSD: psl.h,v 1.23 2007/05/16 19:37:06 thib Exp $	*/
d223 1
a223 1
#define WSTATE_KERN	026
@


1.23
log
@splassert_ctl defaults to 1 now, so dont wrap the checks for
splassert_ctl > 0 in __predict_false().

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: psl.h,v 1.22 2006/12/14 15:10:32 kettenis Exp $	*/
d195 4
@


1.22
log
@Add defines for several SPARC-V9 implementations.
@
text
@d1 1
a1 1
/*	$OpenBSD: psl.h,v 1.21 2006/05/20 14:18:35 miod Exp $	*/
d244 1
a244 1
	if (__predict_false(splassert_ctl > 0)) {	\
@


1.21
log
@Put explicit barriers in in-line spl functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: psl.h,v 1.20 2006/03/12 03:00:32 brad Exp $	*/
d191 14
@


1.20
log
@remove splimp.
@
text
@d1 1
a1 1
/*	$OpenBSD: psl.h,v 1.19 2005/06/29 07:17:22 deraadt Exp $	*/
d345 1
d375 1
@


1.19
log
@some pendantic stuff from henric
@
text
@d1 1
a1 1
/*	$OpenBSD: psl.h,v 1.18 2005/06/29 07:11:14 deraadt Exp $	*/
a405 1
#define	splimp splvm
@


1.18
log
@one PSR_ variable stayed; from henric
@
text
@d1 1
a1 1
/*	$OpenBSD: psl.h,v 1.17 2005/06/29 06:30:18 deraadt Exp $	*/
d170 2
a171 2
#define TSTATE_KERN	((TSTATE_KERN)<<TSTATE_PSTATE_SHIFT)
#define TSTATE_USER	((TSTATE_USER)<<TSTATE_PSTATE_SHIFT)
d182 1
a182 1
#define VER_MANUF	0xffff000000000000LL
d184 1
a184 1
#define VER_IMPL	0x0000ffff00000000LL
d186 1
a186 1
#define VER_MASK	0x00000000ff000000LL
d188 1
a188 1
#define VER_MAXTL	0x000000000000ff00LL
d190 1
a190 1
#define VER_MAXWIN	0x000000000000001fLL
@


1.17
log
@remove v7/v8 stuff; from henric
@
text
@d1 1
a1 1
/*	$OpenBSD: psl.h,v 1.16 2005/05/31 09:31:16 art Exp $	*/
d145 2
@


1.16
log
@IPL_SCHED should block statclock on architectures where the scheduler
is clocked by the statclock.

miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: psl.h,v 1.15 2005/05/29 03:20:40 deraadt Exp $	*/
a45 30

/*
 * SPARC Process Status Register (in psl.h for hysterical raisins).  This
 * doesn't exist on the V9.
 *
 * The picture in the Sun manuals looks like this:
 *					     1 1
 *	 31   28 27   24 23   20 19	  14 3 2 11    8 7 6 5 4       0
 *	+-------+-------+-------+-----------+-+-+-------+-+-+-+---------+
 *	|  impl |  ver	|  icc	|  reserved |E|E|  pil	|S|P|E|	  CWP	|
 *	|	|	|n z v c|	    |C|F|	| |S|T|		|
 *	+-------+-------+-------+-----------+-+-+-------+-+-+-+---------+
 */

#define PSR_IMPL	0xf0000000	/* implementation */
#define PSR_VER		0x0f000000	/* version */
#define PSR_ICC		0x00f00000	/* integer condition codes */
#define PSR_N		0x00800000	/* negative */
#define PSR_Z		0x00400000	/* zero */
#define PSR_O		0x00200000	/* overflow */
#define PSR_C		0x00100000	/* carry */
#define PSR_EC		0x00002000	/* coprocessor enable */
#define PSR_EF		0x00001000	/* FP enable */
#define PSR_PIL		0x00000f00	/* interrupt level */
#define PSR_S		0x00000080	/* supervisor (kernel) mode */
#define PSR_PS		0x00000040	/* previous supervisor mode (traps) */
#define PSR_ET		0x00000020	/* trap enable */
#define PSR_CWP		0x0000001f	/* current window pointer */

#define PSR_BITS "\20\16EC\15EF\10S\7PS\6ET"
@


1.15
log
@sched work by niklas and art backed out; causes panics
@
text
@d1 1
a1 1
/*	$OpenBSD: psl.h,v 1.13 2005/04/19 15:29:48 mickey Exp $	*/
d93 1
a93 1
#define PIL_SCHED	PIL_CLOCK
@


1.14
log
@This patch is mortly art's work and was done *a year* ago.  Art wants to thank
everyone for the prompt review and ok of this work ;-)  Yeah, that includes me
too, or maybe especially me.  I am sorry.

Change the sched_lock to a mutex. This fixes, among other things, the infamous
"telnet localhost &" problem.  The real bug in that case was that the sched_lock
which is by design a non-recursive lock, was recursively acquired, and not
enough releases made us hold the lock in the idle loop, blocking scheduling
on the other processors.  Some of the other processors would hold the biglock though,
which made it impossible for cpu 0 to enter the kernel...  A nice deadlock.
Let me just say debugging this for days just to realize that it was all fixed
in an old diff noone ever ok'd was somewhat of an anti-climax.

This diff also changes splsched to be correct for all our architectures.
@
text
@d93 1
a93 1
#define PIL_SCHED	PIL_STATCLOCK
@


1.13
log
@nothing uses spllowersoftclock() anymore
@
text
@d1 1
a1 1
/*	$OpenBSD: psl.h,v 1.12 2005/01/05 18:42:28 fgsch Exp $	*/
d93 1
a93 1
#define PIL_SCHED	PIL_CLOCK
@


1.12
log
@PIL_AUD should be lower than PIL_SCHED, otherwise the audio code may
leave setrunnable() in a bad state; problem reported by robert@@, miod@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: psl.h,v 1.11 2003/06/02 23:27:56 millert Exp $	*/
a407 2
SPL(spllowersoftclock, 1)

a459 1
#define	spllowersoftclock() spllowersoftclockX(__FILE__, __LINE__)
@


1.11
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: psl.h,v 1.10 2003/05/23 02:00:51 henric Exp $	*/
d87 1
a90 1
#define	PIL_AUD		13
@


1.10
log
@For some reason, gcc seems to assume that if an inline assembly statement
has arguments but no clobbers, then everything is clobbered.  The in-tree
gcc also likes to insert redundant "sra"s.  These changes help gcc generate
somewhat better code for the spl*() functions.  This change shrank my GENERIC
kernel by 27136 bytes.

ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: psl.h,v 1.9 2003/05/16 22:14:13 henric Exp $	*/
d25 1
a25 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.9
log
@Clean up low-level sparc register access wrappers.  Specify clobbers for
everything (so gcc doesn't assume everything is clobbered).

ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: psl.h,v 1.8 2002/06/15 17:23:31 art Exp $	*/
d250 1
a250 1
static __inline void splx(int);
d343 8
a350 9
#define	SPL(name, newpil) \
static __inline int name##X(const char *, int); \
static __inline int name##X(const char *file, int line) \
{ \
	int oldpil; \
	__asm __volatile("rdpr %%pil,%0" : "=r" (oldpil)); \
	SPLPRINT(("{%s:%d %d=>%d}", file, line, oldpil, newpil)); \
	__asm __volatile("wrpr %%g0,%0,%%pil" : : "n" (newpil)); \
	return (oldpil); \
d354 9
a362 10
static __inline int name##X(const char *, int); \
static __inline int name##X(const char * file, int line) \
{ \
	int oldpil; \
	__asm __volatile("rdpr %%pil,%0" : "=r" (oldpil)); \
	if (newpil <= oldpil) \
		return oldpil; \
	SPLPRINT(("{%s:%d %d->!d}", file, line, oldpil, newpil)); \
	__asm __volatile("wrpr %%g0,%0,%%pil" : : "n" (newpil)); \
	return (oldpil); \
d367 11
a377 8
#define	SPL(name, newpil) \
static __inline int name(void); \
static __inline int name() \
{ \
	int oldpil; \
	__asm __volatile("rdpr %%pil,%0" : "=r" (oldpil)); \
	__asm __volatile("wrpr %%g0,%0,%%pil" : : "n" (newpil)); \
	return (oldpil); \
d380 27
a406 10
#define	SPLHOLD(name, newpil) \
static __inline int name(void); \
static __inline int name() \
{ \
	int oldpil; \
	__asm __volatile("rdpr %%pil,%0" : "=r" (oldpil)); \
	if (newpil <= oldpil) \
		return oldpil; \
	__asm __volatile("wrpr %%g0,%0,%%pil" : : "n" (newpil)); \
	return (oldpil); \
a463 12
/* Keep gcc happy -- reduce warnings */
#if 0
static __inline void splx(newpil)
	int newpil;
{
	int pil;

	__asm __volatile("rdpr %%pil,%0" : "=r" (pil));
	SPLPRINT(("{%d->%d}", pil, newpil)); \
	__asm __volatile("wrpr %%g0,%0,%%pil" : : "rn" (newpil));
}
#endif
d465 1
a465 1
#define	spl0()	spl0X(__FILE__, __LINE__)
d486 3
a488 4
static __inline void splxX(int, const char *, int);
static __inline void splxX(newpil, file, line)
	int newpil, line;
	const char *file;
d490 1
a490 2
static __inline void splx(newpil)
	int newpil;
d493 5
a497 5
	int pil;

	__asm __volatile("rdpr %%pil,%0" : "=r" (pil));
	SPLPRINT(("{%d->%d}", pil, newpil)); \
	__asm __volatile("wrpr %%g0,%0,%%pil" : : "rn" (newpil));
@


1.8
log
@Decruftification.

We will never have a.out kernels.
We will never have 32-bit kernels.
We will never have sun4c, sun4 and sun4m support in the sparc64 kernels.
We don't need support old netbsd libc.
The cpu will never be identified as some of the sun4c and sun4m types.
We don't need the gazillion of fields in cpuinfo that the sparc port uses.
Just generally remove dead code.

This is just a first step in making this meess readable.
@
text
@d1 1
a1 1
/*	$OpenBSD: psl.h,v 1.7 2002/06/11 05:01:17 art Exp $	*/
d48 2
a49 1
#ifndef PSR_IMPL
d56 2
a57 2
 *	                                     1 1
 *	 31   28 27   24 23   20 19       14 3 2 11    8 7 6 5 4       0
d59 2
a60 2
 *	|  impl |  ver  |  icc  |  reserved |E|E|  pil  |S|P|E|   CWP   |
 *	|       |       |n z v c|           |C|F|       | |S|T|         |
a248 4
static __inline int getpstate(void);
static __inline void setpstate(int);
static __inline int getcwp(void);
static __inline void setcwp(int);
a251 1
static __inline u_int64_t getver(void);
d273 3
a275 1
static __inline int getpstate()
d277 2
a278 1
	int pstate;
d280 4
a283 2
	__asm __volatile("rdpr %%pstate,%0" : "=r" (pstate));
	return (pstate);
d286 3
a288 2
static __inline void setpstate(newpstate)
	int newpstate;
d290 1
a290 1
	__asm __volatile("wrpr %0,0,%%pstate" : : "r" (newpstate));
d293 3
a295 1
static __inline int getcwp()
d297 2
a298 1
	int cwp;
d300 5
a304 2
	__asm __volatile("rdpr %%cwp,%0" : "=r" (cwp));
	return (cwp);
d307 3
a309 2
static __inline void setcwp(newcwp)
	int newcwp;
d311 5
a315 1
	__asm __volatile("wrpr %0,0,%%cwp" : : "r" (newcwp));
d318 3
a320 1
static __inline u_int64_t getver()
d322 2
a323 1
	u_int64_t ver;
d325 8
a332 2
	__asm __volatile("rdpr %%ver,%0" : "=r" (ver));
	return (ver);
d497 1
a497 1
#endif /* PSR_IMPL */
@


1.7
log
@define IPL_STATCLOCK.
@
text
@d1 1
a1 1
/*	$OpenBSD: psl.h,v 1.6 2002/05/21 16:15:53 art Exp $	*/
a152 1
#ifdef __arch64__
a158 8
#else
#define PSTATE_PROM	(PSTATE_MM_TSO|PSTATE_PRIV)
#define PSTATE_NUCLEUS	(PSTATE_MM_TSO|PSTATE_AM|PSTATE_PRIV|PSTATE_AG)
#define PSTATE_KERN	(PSTATE_MM_TSO|PSTATE_AM|PSTATE_PRIV)
#define PSTATE_INTR	(PSTATE_KERN|PSTATE_IE)
#define PSTATE_USER32	(PSTATE_MM_TSO|PSTATE_AM|PSTATE_IE)
#define PSTATE_USER	(PSTATE_MM_TSO|PSTATE_AM|PSTATE_IE)
#endif
@


1.6
log
@Implement splassert just like it's on sparc.
This also requires a change to rename {PIL,IPL}_IMP to {PIL,IPL}_VM.
XXX - We should get rid of PIL_*.
@
text
@d1 1
a1 1
/*	$OpenBSD: psl.h,v 1.5 2002/04/29 07:35:23 miod Exp $	*/
d94 1
d424 1
a424 1
SPLHOLD(splstatclock, 14)
@


1.5
log
@Define placeholders for art's splassert() debugging stuff on all arches.
Currently as no-ops everywhere.

ok art@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: psl.h,v 1.4 2002/03/14 03:16:01 millert Exp $	*/
d89 1
a89 1
#define PIL_IMP		7
d265 16
a280 2
/* SPL asserts */
#define	splassert(wantipl)	/* nothing */
d407 1
a407 1
SPLHOLD(splvm, PIL_IMP)
@


1.4
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: psl.h,v 1.3 2002/03/14 01:26:45 millert Exp $	*/
d264 3
@


1.3
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: psl.h,v 1.2 2001/08/18 19:46:04 art Exp $	*/
d313 2
a314 2
static __inline int name##X(const char*, int); \
static __inline int name##X(const char* file, int line) \
d324 2
a325 2
static __inline int name##X(const char*, int); \
static __inline int name##X(const char* file, int line) \
d449 1
a449 1
static __inline void splxX(int, const char*, int);
d452 1
a452 1
	const char* file;
@


1.2
log
@We still need splimp.
@
text
@d1 1
a1 1
/*	$OpenBSD: psl.h,v 1.1.1.1 2001/08/18 04:16:40 jason Exp $	*/
d256 4
a259 4
static __inline int getpstate __P((void));
static __inline void setpstate __P((int));
static __inline int getcwp __P((void));
static __inline void setcwp __P((int));
d261 1
a261 1
static __inline void splx __P((int));
d263 1
a263 1
static __inline u_int64_t getver __P((void));
d309 1
a309 1
void prom_printf __P((const char *fmt, ...));
d313 1
a313 1
static __inline int name##X __P((const char*, int)); \
d324 1
a324 1
static __inline int name##X __P((const char*, int)); \
d339 1
a339 1
static __inline int name __P((void)); \
d349 1
a349 1
static __inline int name __P((void)); \
d449 1
a449 1
static __inline void splxX __P((int, const char*, int));
@


1.2.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: psl.h,v 1.2 2001/08/18 19:46:04 art Exp $	*/
d89 1
a89 1
#define PIL_VM		7
d256 4
a259 4
static __inline int getpstate(void);
static __inline void setpstate(int);
static __inline int getcwp(void);
static __inline void setcwp(int);
d261 1
a261 19
static __inline void splx(int);
#endif
static __inline u_int64_t getver(void);

#ifdef DIAGNOSTIC
/*
 * Although this function is implemented in MI code, it must be in this MD
 * header because we don't want this header to include MI includes.
 */
void splassert_fail(int, int, const char *);
extern int splassert_ctl;
void splassert_check(int, const char *);
#define splassert(__wantipl) do {			\
	if (__predict_false(splassert_ctl > 0)) {	\
		splassert_check(__wantipl, __func__);	\
	}						\
} while (0)
#else
#define splassert(wantipl) do { /* nada */ } while (0)
d263 1
d309 1
a309 1
void prom_printf(const char *fmt, ...);
d313 2
a314 2
static __inline int name##X(const char *, int); \
static __inline int name##X(const char *file, int line) \
d324 2
a325 2
static __inline int name##X(const char *, int); \
static __inline int name##X(const char * file, int line) \
d339 1
a339 1
static __inline int name(void); \
d349 1
a349 1
static __inline int name(void); \
d390 1
a390 1
SPLHOLD(splvm, PIL_VM)
d449 1
a449 1
static __inline void splxX(int, const char *, int);
d452 1
a452 1
	const char *file;
@


1.2.6.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: psl.h,v 1.2.6.1 2002/06/11 03:38:43 art Exp $	*/
a93 1
#define PIL_STATCLOCK	14
d152 1
d159 8
d423 1
a423 1
SPLHOLD(splstatclock, PIL_STATCLOCK)
@


1.2.6.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d48 1
a48 2
#ifndef _SPARC64_PSL_
#define _SPARC64_PSL_
d55 2
a56 2
 *					     1 1
 *	 31   28 27   24 23   20 19	  14 3 2 11    8 7 6 5 4       0
d58 2
a59 2
 *	|  impl |  ver	|  icc	|  reserved |E|E|  pil	|S|P|E|	  CWP	|
 *	|	|	|n z v c|	    |C|F|	| |S|T|		|
d248 4
d255 1
d277 1
a277 3
extern __inline u_int64_t getpstate(void);
extern __inline
u_int64_t getpstate()
d279 1
a279 2
	return (sparc_rdpr(pstate));
}
d281 2
a282 4
extern __inline void setpstate(u_int64_t);
extern __inline void setpstate(u_int64_t newpstate)
{
	sparc_wrpr(pstate, newpstate, 0);
d285 2
a286 3
extern __inline int getcwp(void);
extern __inline
int getcwp()
d288 1
a288 1
	return (sparc_rdpr(cwp));
d291 1
a291 3
extern __inline void setcwp(u_int64_t);
extern __inline void
setcwp(u_int64_t newcwp)
d293 1
a293 2
	sparc_wrpr(cwp, newcwp, 0);
}
d295 2
a296 5
extern __inline u_int64_t getver(void);
extern __inline
u_int64_t getver()
{
	return (sparc_rdpr(ver));
d299 2
a300 3
extern __inline u_int64_t intr_disable(void);
extern __inline u_int64_t
intr_disable()
d302 1
a302 5
	u_int64_t s;

	s = sparc_rdpr(pstate);
	sparc_wrpr(pstate, s & ~PSTATE_IE, 0);
	return (s);
d305 1
a305 3
extern __inline void intr_restore(u_int64_t);
extern __inline void
intr_restore(u_int64_t s)
d307 1
a307 2
	sparc_wrpr(pstate, s, 0);
}
d309 2
a310 8
extern __inline void stxa_sync(u_int64_t, u_int64_t, u_int64_t);
extern __inline void
stxa_sync(u_int64_t va, u_int64_t asi, u_int64_t val)
{
	u_int64_t s = intr_disable();
	stxa_nc(va, asi, val);
	membar(Sync);
	intr_restore(s);
d475 1
a475 1
#endif /* _SPARC64_PSL_ */
@


1.2.4.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.2.4.2
log
@Merge in -current from about a week ago
@
text
@d256 4
a259 4
static __inline int getpstate(void);
static __inline void setpstate(int);
static __inline int getcwp(void);
static __inline void setcwp(int);
d261 1
a261 1
static __inline void splx(int);
d263 1
a263 1
static __inline u_int64_t getver(void);
d309 1
a309 1
void prom_printf(const char *fmt, ...);
d313 2
a314 2
static __inline int name##X(const char *, int); \
static __inline int name##X(const char *file, int line) \
d324 2
a325 2
static __inline int name##X(const char *, int); \
static __inline int name##X(const char * file, int line) \
d339 1
a339 1
static __inline int name(void); \
d349 1
a349 1
static __inline int name(void); \
d449 1
a449 1
static __inline void splxX(int, const char *, int);
d452 1
a452 1
	const char *file;
@


1.2.4.3
log
@Sync the SMP branch with 3.3
@
text
@d89 1
a89 1
#define PIL_VM		7
a93 1
#define PIL_STATCLOCK	14
d152 1
d159 8
a264 17
#ifdef DIAGNOSTIC
/*
 * Although this function is implemented in MI code, it must be in this MD
 * header because we don't want this header to include MI includes.
 */
void splassert_fail(int, int, const char *);
extern int splassert_ctl;
void splassert_check(int, const char *);
#define splassert(__wantipl) do {			\
	if (__predict_false(splassert_ctl > 0)) {	\
		splassert_check(__wantipl, __func__);	\
	}						\
} while (0)
#else
#define splassert(wantipl) do { /* nada */ } while (0)
#endif

d390 1
a390 1
SPLHOLD(splvm, PIL_VM)
d406 1
a406 1
SPLHOLD(splstatclock, PIL_STATCLOCK)
@


1.2.4.4
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: psl.h,v 1.2.4.3 2003/03/27 23:42:36 niklas Exp $	*/
d25 5
a29 1
 * 3. Neither the name of the University nor the names of its contributors
d48 1
a48 2
#ifndef _SPARC64_PSL_
#define _SPARC64_PSL_
d55 2
a56 2
 *					     1 1
 *	 31   28 27   24 23   20 19	  14 3 2 11    8 7 6 5 4       0
d58 2
a59 2
 *	|  impl |  ver	|  icc	|  reserved |E|E|  pil	|S|P|E|	  CWP	|
 *	|	|	|n z v c|	    |C|F|	| |S|T|		|
d248 4
d253 1
a253 1
extern __inline void splx(int);
d255 1
d277 1
a277 3
extern __inline u_int64_t getpstate(void);
extern __inline
u_int64_t getpstate()
d279 1
a279 2
	return (sparc_rdpr(pstate));
}
d281 2
a282 4
extern __inline void setpstate(u_int64_t);
extern __inline void setpstate(u_int64_t newpstate)
{
	sparc_wrpr(pstate, newpstate, 0);
d285 2
a286 3
extern __inline int getcwp(void);
extern __inline
int getcwp()
d288 1
a288 1
	return (sparc_rdpr(cwp));
d291 1
a291 3
extern __inline void setcwp(u_int64_t);
extern __inline void
setcwp(u_int64_t newcwp)
d293 1
a293 2
	sparc_wrpr(cwp, newcwp, 0);
}
d295 2
a296 5
extern __inline u_int64_t getver(void);
extern __inline
u_int64_t getver()
{
	return (sparc_rdpr(ver));
d299 2
a300 3
extern __inline u_int64_t intr_disable(void);
extern __inline u_int64_t
intr_disable()
d302 1
a302 5
	u_int64_t s;

	s = sparc_rdpr(pstate);
	sparc_wrpr(pstate, s & ~PSTATE_IE, 0);
	return (s);
d305 1
a305 3
extern __inline void intr_restore(u_int64_t);
extern __inline void
intr_restore(u_int64_t s)
d307 1
a307 2
	sparc_wrpr(pstate, s, 0);
}
d309 2
a310 8
extern __inline void stxa_sync(u_int64_t, u_int64_t, u_int64_t);
extern __inline void
stxa_sync(u_int64_t va, u_int64_t asi, u_int64_t val)
{
	u_int64_t s = intr_disable();
	stxa_nc(va, asi, val);
	membar(Sync);
	intr_restore(s);
d321 9
a329 8
#define	SPL(name, newpil)						\
extern __inline int name##X(const char *, int);				\
extern __inline int name##X(const char *file, int line)			\
{									\
	u_int64_t oldpil = sparc_rdpr(pil);				\
	SPLPRINT(("{%s:%d %d=>%d}", file, line, oldpil, newpil));	\
	sparc_wrpr(pil, newpil, 0);					\
	return (oldpil);						\
d333 10
a342 9
extern __inline int name##X(const char *, int);				\
extern __inline int name##X(const char * file, int line)		\
{									\
	int oldpil = sparc_rdpr(pil);					\
	if (__predict_false((u_int64_t)newpil <= oldpil))		\
		return (oldpil);					\
	SPLPRINT(("{%s:%d %d->!d}", file, line, oldpil, newpil));	\
	sparc_wrpr(pil, newpil, 0);					\
	return (oldpil);						\
d347 8
a354 11
#define	SPL(name, newpil)						\
extern __inline int name(void);						\
extern __inline int name()						\
{									\
	int oldpil;							\
	__asm __volatile("    rdpr %%pil, %0		\n"		\
			 "    wrpr %%g0, %1, %%pil	\n"		\
	    : "=&r" (oldpil)						\
	    : "n" (newpil)						\
	    : "%g0");							\
	return (oldpil);						\
d357 10
a366 27
#define	SPLHOLD(name, newpil)						\
extern __inline int name(void);						\
extern __inline int name()						\
{									\
	int oldpil;							\
									\
	if (newpil <= 1) {						\
		__asm __volatile("    rdpr	%%pil, %0	\n"	\
				 "    brnz,pn	%0, 1f		\n"	\
				 "     nop			\n"	\
				 "    wrpr	%%g0, %1, %%pil	\n"	\
				 "1:				\n"	\
	    : "=&r" (oldpil)						\
	    : "I" (newpil)						\
	    : "%g0");							\
	} else {							\
		__asm __volatile("    rdpr	%%pil, %0	\n"	\
				 "    cmp	%0, %1 - 1	\n"	\
				 "    bgu,pn	%%xcc, 1f	\n"	\
				 "     nop			\n"	\
				 "    wrpr	%%g0, %1, %%pil	\n"	\
				 "1:				\n"	\
	    : "=&r" (oldpil)						\
	    : "I" (newpil)						\
	    : "cc");							\
	}								\
	return (oldpil);						\
d424 12
d437 1
a437 1
#define	spl0()		spl0X(__FILE__, __LINE__)
d458 4
a461 3
extern __inline void splxX(u_int64_t, const char *, int);
extern __inline void
splxX(u_int64_t newpil, const char *file, int line)
d463 2
a464 1
extern __inline void splx(int newpil)
d467 5
a471 5
#ifdef SPLDEBUG
	u_int64_t oldpil = sparc_rdpr(pil);
	SPLPRINT(("{%d->%d}", oldpil, newpil));
#endif
	sparc_wrpr(pil, newpil, 0);
d475 1
a475 1
#endif /* _SPARC64_PSL_ */
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d391 1
@


1.1.1.1
log
@Enough of NetBSD/sparc64 to get compilable/working bootblk... more to come.
@
text
@@
