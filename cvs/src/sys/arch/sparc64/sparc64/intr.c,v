head	1.56;
access;
symbols
	OPENBSD_6_2:1.56.0.2
	OPENBSD_6_2_BASE:1.56
	OPENBSD_6_1:1.55.0.6
	OPENBSD_6_1_BASE:1.55
	OPENBSD_6_0:1.55.0.2
	OPENBSD_6_0_BASE:1.55
	OPENBSD_5_9:1.54.0.2
	OPENBSD_5_9_BASE:1.54
	OPENBSD_5_8:1.52.0.6
	OPENBSD_5_8_BASE:1.52
	OPENBSD_5_7:1.52.0.2
	OPENBSD_5_7_BASE:1.52
	OPENBSD_5_6:1.49.0.4
	OPENBSD_5_6_BASE:1.49
	OPENBSD_5_5:1.46.0.4
	OPENBSD_5_5_BASE:1.46
	OPENBSD_5_4:1.45.0.2
	OPENBSD_5_4_BASE:1.45
	OPENBSD_5_3:1.43.0.8
	OPENBSD_5_3_BASE:1.43
	OPENBSD_5_2:1.43.0.6
	OPENBSD_5_2_BASE:1.43
	OPENBSD_5_1_BASE:1.43
	OPENBSD_5_1:1.43.0.4
	OPENBSD_5_0:1.43.0.2
	OPENBSD_5_0_BASE:1.43
	OPENBSD_4_9:1.39.0.2
	OPENBSD_4_9_BASE:1.39
	OPENBSD_4_8:1.36.0.2
	OPENBSD_4_8_BASE:1.36
	OPENBSD_4_7:1.34.0.2
	OPENBSD_4_7_BASE:1.34
	OPENBSD_4_6:1.33.0.6
	OPENBSD_4_6_BASE:1.33
	OPENBSD_4_5:1.33.0.2
	OPENBSD_4_5_BASE:1.33
	OPENBSD_4_4:1.32.0.2
	OPENBSD_4_4_BASE:1.32
	OPENBSD_4_3:1.30.0.2
	OPENBSD_4_3_BASE:1.30
	OPENBSD_4_2:1.26.0.2
	OPENBSD_4_2_BASE:1.26
	OPENBSD_4_1:1.23.0.8
	OPENBSD_4_1_BASE:1.23
	OPENBSD_4_0:1.23.0.6
	OPENBSD_4_0_BASE:1.23
	OPENBSD_3_9:1.23.0.4
	OPENBSD_3_9_BASE:1.23
	OPENBSD_3_8:1.23.0.2
	OPENBSD_3_8_BASE:1.23
	OPENBSD_3_7:1.22.0.4
	OPENBSD_3_7_BASE:1.22
	OPENBSD_3_6:1.22.0.2
	OPENBSD_3_6_BASE:1.22
	SMP_SYNC_A:1.20
	SMP_SYNC_B:1.20
	OPENBSD_3_5:1.20.0.2
	OPENBSD_3_5_BASE:1.20
	OPENBSD_3_4:1.17.0.2
	OPENBSD_3_4_BASE:1.17
	UBC_SYNC_A:1.16
	OPENBSD_3_3:1.13.0.2
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.11.0.2
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	UBC_SYNC_B:1.11
	UBC:1.6.0.2
	UBC_BASE:1.6
	SMP:1.5.0.4
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5;
locks; strict;
comment	@ * @;


1.56
date	2017.04.30.16.45.45;	author mpi;	state Exp;
branches;
next	1.55;
commitid	2Gtqjzrin9LL2yHk;

1.55
date	2016.06.13.01.08.13;	author dlg;	state Exp;
branches;
next	1.54;
commitid	xgGjlZUxf6R8Dc1y;

1.54
date	2015.09.27.11.29.20;	author kettenis;	state Exp;
branches;
next	1.53;
commitid	Um3BvP4zKyWaKQpf;

1.53
date	2015.09.13.11.47.59;	author kettenis;	state Exp;
branches;
next	1.52;
commitid	Dakou02Cw7MmHVO0;

1.52
date	2014.10.05.11.40.37;	author dlg;	state Exp;
branches;
next	1.51;
commitid	8oirAgg1jotcmokb;

1.51
date	2014.10.05.11.32.43;	author dlg;	state Exp;
branches;
next	1.50;
commitid	YqLTBM9rT2mJ42AY;

1.50
date	2014.10.05.11.30.33;	author dlg;	state Exp;
branches;
next	1.49;
commitid	RO6QCGOHg5k2q5dU;

1.49
date	2014.07.12.18.44.43;	author tedu;	state Exp;
branches;
next	1.48;
commitid	uKVPYMN2MLxdZxzH;

1.48
date	2014.05.10.12.29.58;	author kettenis;	state Exp;
branches;
next	1.47;

1.47
date	2014.03.29.18.09.30;	author guenther;	state Exp;
branches;
next	1.46;

1.46
date	2014.01.21.10.19.31;	author dlg;	state Exp;
branches;
next	1.45;

1.45
date	2013.05.13.17.46.42;	author kettenis;	state Exp;
branches;
next	1.44;

1.44
date	2013.05.12.18.48.53;	author kettenis;	state Exp;
branches;
next	1.43;

1.43
date	2011.06.27.17.07.19;	author deraadt;	state Exp;
branches;
next	1.42;

1.42
date	2011.06.27.17.04.46;	author jsing;	state Exp;
branches;
next	1.41;

1.41
date	2011.06.26.21.35.12;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2011.06.24.19.08.46;	author kettenis;	state Exp;
branches;
next	1.39;

1.39
date	2010.12.21.14.56.24;	author claudio;	state Exp;
branches;
next	1.38;

1.38
date	2010.09.27.17.39.43;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2010.09.20.06.33.47;	author matthew;	state Exp;
branches;
next	1.36;

1.36
date	2010.07.07.15.35.23;	author kettenis;	state Exp;
branches;
next	1.35;

1.35
date	2010.04.16.22.35.24;	author kettenis;	state Exp;
branches;
next	1.34;

1.34
date	2009.11.25.15.22.44;	author kettenis;	state Exp;
branches;
next	1.33;

1.33
date	2008.08.09.20.42.28;	author kettenis;	state Exp;
branches;
next	1.32;

1.32
date	2008.04.28.20.55.10;	author kettenis;	state Exp;
branches;
next	1.31;

1.31
date	2008.03.12.20.52.36;	author kettenis;	state Exp;
branches;
next	1.30;

1.30
date	2008.02.14.19.07.56;	author kettenis;	state Exp;
branches;
next	1.29;

1.29
date	2007.09.22.20.04.51;	author kettenis;	state Exp;
branches;
next	1.28;

1.28
date	2007.09.17.01.33.33;	author krw;	state Exp;
branches;
next	1.27;

1.27
date	2007.09.09.08.55.27;	author kettenis;	state Exp;
branches;
next	1.26;

1.26
date	2007.05.29.18.10.43;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2007.05.29.09.53.57;	author sobrado;	state Exp;
branches;
next	1.24;

1.24
date	2007.03.16.09.28.38;	author art;	state Exp;
branches;
next	1.23;

1.23
date	2005.04.26.18.54.39;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2004.06.28.01.47.41;	author aaron;	state Exp;
branches;
next	1.21;

1.21
date	2004.06.20.04.50.24;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2004.01.10.09.10.07;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2003.11.06.21.09.35;	author mickey;	state Exp;
branches;
next	1.18;

1.18
date	2003.10.01.06.01.55;	author cloder;	state Exp;
branches;
next	1.17;

1.17
date	2003.06.12.01.07.31;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2003.05.17.03.53.39;	author jason;	state Exp;
branches;
next	1.15;

1.15
date	2003.05.16.23.55.00;	author jason;	state Exp;
branches;
next	1.14;

1.14
date	2003.05.16.17.18.15;	author jason;	state Exp;
branches;
next	1.13;

1.13
date	2003.03.20.23.05.30;	author henric;	state Exp;
branches;
next	1.12;

1.12
date	2003.02.17.01.29.20;	author henric;	state Exp;
branches;
next	1.11;

1.11
date	2002.07.23.13.58.23;	author art;	state Exp;
branches;
next	1.10;

1.10
date	2002.05.22.00.58.26;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2002.05.21.16.15.53;	author art;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.14.01.26.45;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.01.10.00.06.17;	author nordin;	state Exp;
branches;
next	1.6;

1.6
date	2001.11.28.05.32.11;	author jason;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2001.09.21.02.02.22;	author art;	state Exp;
branches
	1.5.4.1;
next	1.4;

1.4
date	2001.09.20.21.29.26;	author jason;	state Exp;
branches;
next	1.3;

1.3
date	2001.09.04.15.25.52;	author jason;	state Exp;
branches;
next	1.2;

1.2
date	2001.08.20.20.23.53;	author jason;	state Exp;
branches;
next	1.1;

1.1
date	2001.08.19.05.21.38;	author jason;	state Exp;
branches;
next	;

1.5.4.1
date	2001.10.31.03.07.59;	author nate;	state Exp;
branches;
next	1.5.4.2;

1.5.4.2
date	2001.12.05.00.39.13;	author niklas;	state Exp;
branches;
next	1.5.4.3;

1.5.4.3
date	2002.03.06.02.04.47;	author niklas;	state Exp;
branches;
next	1.5.4.4;

1.5.4.4
date	2002.03.28.11.23.52;	author niklas;	state Exp;
branches;
next	1.5.4.5;

1.5.4.5
date	2003.03.27.23.42.37;	author niklas;	state Exp;
branches;
next	1.5.4.6;

1.5.4.6
date	2003.06.07.11.14.45;	author ho;	state Exp;
branches;
next	1.5.4.7;

1.5.4.7
date	2004.02.19.10.50.00;	author niklas;	state Exp;
branches;
next	;

1.6.2.1
date	2002.01.31.22.55.24;	author niklas;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2002.06.11.03.38.43;	author art;	state Exp;
branches;
next	1.6.2.3;

1.6.2.3
date	2002.10.29.00.28.12;	author art;	state Exp;
branches;
next	1.6.2.4;

1.6.2.4
date	2003.05.19.21.46.57;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.56
log
@Rename Debugger() into db_enter().

Using a name with the 'db_' prefix makes it invisible from the dynamic
profiler.

ok deraadt@@, kettenis@@, visa@@
@
text
@/*	$OpenBSD: intr.c,v 1.55 2016/06/13 01:08:13 dlg Exp $	*/
/*	$NetBSD: intr.c,v 1.39 2001/07/19 23:38:11 eeh Exp $ */

/*
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
 *
 * All advertising materials mentioning features or use of this software
 * must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Lawrence Berkeley Laboratory.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT OT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)intr.c	8.3 (Berkeley) 11/11/93
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/malloc.h>

#include <dev/cons.h>

#include <machine/atomic.h>
#include <machine/cpu.h>
#include <machine/ctlreg.h>
#include <machine/instr.h>
#include <machine/trap.h>

/* Grab interrupt map stuff (what is it doing there???) */
#include <sparc64/dev/iommureg.h>

/*
 * The following array is to used by locore.s to map interrupt packets
 * to the proper IPL to send ourselves a softint.  It should be filled
 * in as the devices are probed.  We should eventually change this to a
 * vector table and call these things directly.
 */
struct intrhand *intrlev[MAXINTNUM];

void	strayintr(const struct trapframe64 *, int);
int	softintr(void *);
int	intr_handler(struct trapframe64 *, struct intrhand *);
int	intr_list_handler(void *);
void	intr_ack(struct intrhand *);

/*
 * Stray interrupt handler.  Clear it if possible.
 * If not, and if we get 10 interrupts in 10 seconds, panic.
 */
int ignore_stray = 1;
int straycnt[16];

void
strayintr(const struct trapframe64 *fp, int vectored)
{
	static int straytime, nstray;
	int timesince;
#if 0
	extern int swallow_zsintrs;
#endif

	if (fp->tf_pil < 16)
		straycnt[(int)fp->tf_pil]++;

	if (ignore_stray)
		return;

	/* If we're in polled mode ignore spurious interrupts */
	if ((fp->tf_pil == PIL_SER) /* && swallow_zsintrs */) return;

	printf("stray interrupt ipl %u pc=%llx npc=%llx pstate=%llb "
	    "vectored=%d\n", fp->tf_pil, fp->tf_pc, fp->tf_npc,
	    fp->tf_tstate >> TSTATE_PSTATE_SHIFT, PSTATE_BITS, vectored);

	timesince = time_second - straytime;
	if (timesince <= 10) {
		if (++nstray > 500)
			panic("crazy interrupts");
	} else {
		straytime = time_second;
		nstray = 1;
	}
#ifdef DDB
	db_enter();
#endif
}

int
intr_handler(struct trapframe64 *tf, struct intrhand *ih)
{
	int rc;
#ifdef MULTIPROCESSOR
	int need_lock;

	if (ih->ih_mpsafe)
		need_lock = 0;
	else
		need_lock = tf->tf_pil < PIL_SCHED && tf->tf_pil != PIL_CLOCK;

	if (need_lock)
		KERNEL_LOCK();
#endif
	rc = (*ih->ih_fun)(ih->ih_arg ? ih->ih_arg : tf);
#ifdef MULTIPROCESSOR
	if (need_lock)
		KERNEL_UNLOCK();
#endif
	return rc;
}

/*
 * Level 1 software interrupt (could also be SBus level 1 interrupt).
 * Three possible reasons:
 *	Network software interrupt
 *	Soft clock interrupt
 */

/*
 * PCI devices can share interrupts so we need to have
 * a handler to hand out interrupts.
 */
int
intr_list_handler(void *arg)
{
	struct cpu_info *ci = curcpu();
	struct intrhand *ih = arg;
	int claimed = 0, rv, ipl = ci->ci_handled_intr_level;

	while (ih) {
		sparc_wrpr(pil, ih->ih_pil, 0);
		ci->ci_handled_intr_level = ih->ih_pil;

		rv = ih->ih_fun(ih->ih_arg);
		if (rv) {
			ih->ih_count.ec_count++;
			claimed = 1;
			if (rv == 1)
				break;
		}

		ih = ih->ih_next;
	}
	sparc_wrpr(pil, ipl, 0);
	ci->ci_handled_intr_level = ipl;

	return (claimed);
}

void
intr_ack(struct intrhand *ih)
{
	*ih->ih_clr = INTCLR_IDLE;
}

/*
 * Attach an interrupt handler to the vector chain for the given level.
 * This is not possible if it has been taken away as a fast vector.
 */
void
intr_establish(int level, struct intrhand *ih)
{
	struct intrhand *q;
	u_int64_t m, id;
	int s;

	s = splhigh();

	/*
	 * This is O(N^2) for long chains, but chains are never long
	 * and we do want to preserve order.
	 */
	ih->ih_pil = level; /* XXXX caller should have done this before */
	ih->ih_pending = 0; /* XXXX caller should have done this before */
	ih->ih_next = NULL;
	ih->ih_cpu = cpus;
	if (ih->ih_clr)
		ih->ih_ack = intr_ack;
	else
		ih->ih_ack = NULL;

	/*
	 * Store in fast lookup table
	 */
#ifdef NOT_DEBUG
	if (!ih->ih_number) {
		printf("\nintr_establish: NULL vector fun %p arg %p pil %p",
			  ih->ih_fun, ih->ih_arg, ih->ih_number, ih->ih_pil);
		db_enter();
	}
#endif

	if (ih->ih_number <= 0 || ih->ih_number >= MAXINTNUM)
		panic("intr_establish: bad intr number %x", ih->ih_number);

	if (strlen(ih->ih_name) == 0)
		evcount_attach(&ih->ih_count, "unknown", NULL);
	else
		evcount_attach(&ih->ih_count, ih->ih_name, NULL);

	q = intrlev[ih->ih_number];
	if (q == NULL) {
		/* No interrupt already there, just put handler in place. */
		intrlev[ih->ih_number] = ih;
	} else {
		struct intrhand *nih, *pih;
		int ipl;

		/*
		 * Interrupt is already there.  We need to create a
		 * new interrupt handler and interpose it.
		 */
#ifdef DEBUG
		printf("intr_establish: intr reused %x\n", ih->ih_number);
#endif
		if (q->ih_fun != intr_list_handler) {
			nih = malloc(sizeof(struct intrhand),
			    M_DEVBUF, M_NOWAIT | M_ZERO);
			if (nih == NULL)
				panic("intr_establish");

			nih->ih_fun = intr_list_handler;
			nih->ih_arg = q;
			nih->ih_number = q->ih_number;
			nih->ih_pil = min(q->ih_pil, ih->ih_pil);
			nih->ih_map = q->ih_map;
			nih->ih_clr = q->ih_clr;
			nih->ih_ack = q->ih_ack;
			q->ih_ack = NULL;

			intrlev[ih->ih_number] = q = nih;
		} else
			q->ih_pil = min(q->ih_pil, ih->ih_pil);

		ih->ih_ack = NULL;

		/* Add ih to list in priority order. */
		pih = q;
		nih = pih->ih_arg;
		ipl = nih->ih_pil;
		while (nih && ih->ih_pil <= nih->ih_pil) {
			ipl = nih->ih_pil;
			pih = nih;
			nih = nih->ih_next;
		}
#if DEBUG
		printf("intr_establish: inserting pri %i after %i\n",
		    ih->ih_pil, ipl);
#endif
		if (pih == q) {
			ih->ih_next = pih->ih_arg;
			pih->ih_arg = ih;
		} else {
			ih->ih_next = pih->ih_next;
			pih->ih_next = ih;
		}
	}

	if (ih->ih_clr != NULL)			/* Set interrupt to idle */
		*ih->ih_clr = INTCLR_IDLE;

	if (ih->ih_map) {
		id = CPU_UPAID;
		m = *ih->ih_map;
		if (INTTID(m) != id) {
#ifdef DEBUG
			printf("\nintr_establish: changing map 0x%llx -> ", m);
#endif
			m = (m & ~INTMAP_TID) | (id << INTTID_SHIFT);
#ifdef DEBUG
			printf("0x%llx (id=%llx) ", m, id);
#endif
		}
		m |= INTMAP_V;
		*ih->ih_map = m;
	}

#ifdef DEBUG
	printf("\nintr_establish: vector %x pil %x mapintr %p "
	    "clrintr %p fun %p arg %p target %d",
	    ih->ih_number, ih->ih_pil, (void *)ih->ih_map,
	    (void *)ih->ih_clr, (void *)ih->ih_fun,
	    (void *)ih->ih_arg, (int)(ih->ih_map ? INTTID(*ih->ih_map) : -1));
#endif

	splx(s);
}

int
splraise(int ipl)
{
	return (_splraise(ipl));
}

void
intr_barrier(void *cookie)
{
	struct intrhand *ih = cookie;

	sched_barrier(ih->ih_cpu);
}

void *
softintr_establish(int level, void (*fun)(void *), void *arg)
{
	struct intrhand *ih;

	if (level == IPL_TTY)
		level = IPL_SOFTTTY;

	ih = malloc(sizeof(*ih), M_DEVBUF, M_WAITOK | M_ZERO);
	ih->ih_fun = (int (*)(void *))fun;	/* XXX */
	ih->ih_arg = arg;
	ih->ih_pil = level;
	ih->ih_pending = 0;
	ih->ih_ack = NULL;
	ih->ih_clr = NULL;
	return (ih);
}

void
softintr_disestablish(void *cookie)
{
	struct intrhand *ih = cookie;

	free(ih, M_DEVBUF, sizeof(*ih));
}

void
softintr_schedule(void *cookie)
{
	struct intrhand *ih = cookie;

	send_softint(-1, ih->ih_pil, ih);
}

#ifdef DIAGNOSTIC
void
splassert_check(int wantipl, const char *func)
{
	struct cpu_info *ci = curcpu();
	int oldipl;

	__asm volatile("rdpr %%pil,%0" : "=r" (oldipl));

	if (oldipl < wantipl) {
		splassert_fail(wantipl, oldipl, func);
	}

	if (ci->ci_handled_intr_level > wantipl) {
		/*
		 * XXX - need to show difference between what's blocked and
		 * what's running.
		 */
		splassert_fail(wantipl, ci->ci_handled_intr_level, func);
	}
}
#endif
@


1.55
log
@rework sparc64 splfoo functions to be more consistent with other archs

this also moves us toward having an MI splraise().

sparc64 (and sparc) are different to the other archs because they
have macros that build templates. each spl uses that macro to create
an instance of an inline function specific to that spl call.

this moves it to having a single splraise inline that the spl api is
defined with. eg, #define splfoo() _splraise(IPL_FOO).

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.54 2015/09/27 11:29:20 kettenis Exp $	*/
d112 1
a112 1
	Debugger();
d216 1
a216 1
		Debugger();
@


1.54
log
@Store the target CPU in "struct intrhand" and use it in intr_barrier().
Also use it wherever we configure the hardware to direct interrupts to the
right CPU.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.53 2015/09/13 11:47:59 kettenis Exp $	*/
d314 6
@


1.53
log
@Introduce intr_barrier(4), an interface that guarantees that an interrupt
handler that was running has finished.

ok miod@@, guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.52 2014/10/05 11:40:37 dlg Exp $	*/
d203 1
d317 1
a317 1
intr_barrier(void *ih)
d319 3
a321 1
	sched_barrier(NULL);
@


1.52
log
@pass size to free.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.51 2014/10/05 11:32:43 dlg Exp $	*/
d313 6
@


1.51
log
@dont need to cast pointers to/from void *

no binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.50 2014/10/05 11:30:33 dlg Exp $	*/
d336 3
a338 1
	free(cookie, M_DEVBUF, 0);
@


1.50
log
@ansify function definitions.

no binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.49 2014/07/12 18:44:43 tedu Exp $	*/
d330 1
a330 1
	return (void *)ih;
d342 1
a342 1
	struct intrhand *ih = (struct intrhand *)cookie;
@


1.49
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.48 2014/05/10 12:29:58 kettenis Exp $	*/
d82 1
a82 3
strayintr(fp, vectored)
	const struct trapframe64 *fp;
	int vectored;
d316 1
a316 4
softintr_establish(level, fun, arg)
	int level; 
	void (*fun)(void *);
	void *arg;
d334 1
a334 2
softintr_disestablish(cookie)
	void *cookie;
d340 1
a340 2
softintr_schedule(cookie)
	void *cookie;
@


1.48
log
@A few more straightforward format string fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.47 2014/03/29 18:09:30 guenther Exp $	*/
d342 1
a342 1
	free(cookie, M_DEVBUF);
@


1.47
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.46 2014/01/21 10:19:31 dlg Exp $	*/
d101 3
a103 4
	printf("stray interrupt ipl %u pc=%llx npc=%llx pstate=%b "
	    "vectored=%d\n", fp->tf_pil, (unsigned long long)fp->tf_pc,
	    (unsigned long long)fp->tf_npc, fp->tf_tstate>>TSTATE_PSTATE_SHIFT,
	    PSTATE_BITS, vectored);
@


1.46
log
@use KERNEL_LOCK and KERNEL_UNLOCK instead of fumbling with kernel_lock
directly.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.45 2013/05/13 17:46:42 kettenis Exp $	*/
d362 1
a362 1
	__asm __volatile("rdpr %%pil,%0" : "=r" (oldipl));
@


1.45
log
@Implement support for running interrupt handlers without taking the kernel
lock, by adding a new BUS_INTR_ESTABLISH_MPSAFE flag for use with the
(sparc64-specific) bus_intr_establish(9) interface.  Add support for this
flag to schizo(4); other bus drivers will ignore it for now.  While there,
remove the BUS_INTR_ESTABLISH_FASTTRAP flag which serves no purpose.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.44 2013/05/12 18:48:53 kettenis Exp $	*/
d132 1
a132 1
		__mp_lock(&kernel_lock);
d137 1
a137 1
		__mp_unlock(&kernel_lock);
@


1.44
log
@Take the kernel lock and call the actual interrupt handler from a
single C function.  Inspired by the change made to amd64/i386 by ratchov@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.43 2011/06/27 17:07:19 deraadt Exp $	*/
d126 4
a129 1
	need_lock = tf->tf_pil < PIL_SCHED && tf->tf_pil != PIL_CLOCK;
@


1.43
log
@If an shared interrupt handler returns -1, continue running other handlers.
If it returns 1, skip calling the handlers further down the list.  The
interrupt pin will remain asserted, and the handler will be called on the
next go-around.  This makes sparc64 "similar" to other architectures.
ok kettenis jsing
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.42 2011/06/27 17:04:46 jsing Exp $	*/
d70 1
d119 20
a372 21
#endif

#ifdef MULTIPROCESSOR

void sparc64_intlock(struct trapframe64 *);
void sparc64_intunlock(struct trapframe64 *);

void
sparc64_intlock(struct trapframe64 *tf)
{
	if (tf->tf_pil < PIL_SCHED && tf->tf_pil != PIL_CLOCK)
		__mp_lock(&kernel_lock);
}

void
sparc64_intunlock(struct trapframe64 *tf)
{
	if (tf->tf_pil < PIL_SCHED && tf->tf_pil != PIL_CLOCK)
		__mp_unlock(&kernel_lock);
}

@


1.42
log
@When adding interrupt handlers to a chain, install them in priority order.
This results in the higher IPL handlers being run first.

ok deraadt@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.40 2011/06/24 19:08:46 kettenis Exp $	*/
d134 1
a134 1
	int claimed = 0, ipl = ci->ci_handled_intr_level;
d140 2
a141 1
		if (ih->ih_fun(ih->ih_arg)) {
d144 2
@


1.41
log
@In the shared interrupt handler, return the pil and ci_handled_intr_level
to the level they were at before we started splraise'ing for the various
handlers.
with jsing, ok kettenis
@
text
@d208 2
a209 1
		struct intrhand *nih;
d234 2
a235 4
		} else {
			if (ih->ih_pil < q->ih_pil)
				q->ih_pil = ih->ih_pil;
		}
d239 20
a258 3
		/* Add the ih to the head of the list */
		ih->ih_next = q->ih_arg;
		q->ih_arg = ih;
@


1.40
log
@We should only ack a shared interrupt once, after we've run all the handlers.
So let the intr_list_handler do this, and prevent the real handlers from doing
it as well.

tested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.39 2010/12/21 14:56:24 claudio Exp $	*/
d134 1
a134 1
	int claimed = 0;
d147 2
@


1.39
log
@Convert netisr to a normal soft interrupt instead of hanving MD code
for it. This makes the netisr a real C function which will help further
development. No noticable performance change on i386 and amd64.
With input from kettenis@@ and miod@@ additional OKs mikeb@@ and henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.38 2010/09/27 17:39:43 deraadt Exp $	*/
d228 1
d235 2
@


1.38
log
@must use M_WAITOK here; run into by landry
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.37 2010/09/20 06:33:47 matthew Exp $	*/
a50 2
#include <net/netisr.h>

a69 1
int	softnet(void *);
a123 31

int netisr;

int
softnet(fp)
	void *fp;
{
	int n;
	
	while ((n = netisr) != 0) {
		atomic_clearbits_int(&netisr, n);
	
#define DONETISR(bit, fn)						\
		do {							\
			if (n & (1 << bit))				\
				fn();					\
		} while (0)

#include <net/netisr_dispatch.h>

#undef DONETISR
	}
	return (1);
}

struct intrhand soft01net = { softnet, NULL, 1 };

void 
setsoftnet() {
	send_softint(-1, IPL_SOFTNET, &soft01net);
}
@


1.37
log
@Get rid of evcount's support for arranging counters in a tree
hierarchy.  Everything attached to a single root node anyway, so at
best we had a bush.

"i think it is good" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.36 2010/07/07 15:35:23 kettenis Exp $	*/
d315 1
a315 1
	ih = malloc(sizeof(*ih), M_DEVBUF, M_ZERO);
@


1.36
log
@Don't grab the kernel lock for clock interrupts.  Prevents deadlocks when
running stuff that depends on mutexes without holding the kernel lock.

ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.35 2010/04/16 22:35:24 kettenis Exp $	*/
d231 1
a231 1
		evcount_attach(&ih->ih_count, "unknown", NULL, &evcount_intr);
d233 1
a233 1
		evcount_attach(&ih->ih_count, ih->ih_name, NULL, &evcount_intr);
@


1.35
log
@Fix handling of shared interrupts.  Make sure we use the lowest priority of
all the interrupt handles when reprioritizing the interrupt on reception,
but always run the handler at the desired priority.  Make sure
ci_handled_intr_level is set correctly.  Gets rid of splassert warnings
seem on many of the PCIe systems with mpi(4).

tested by deraadt@@, jbg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.34 2009/11/25 15:22:44 kettenis Exp $	*/
d372 1
a372 1
	if(tf->tf_pil < PIL_SCHED)
d379 1
a379 1
	if(tf->tf_pil < PIL_SCHED)
@


1.34
log
@Clear any pending interrupts.  This should not matter, since we're at splhigh(),
but I get the feeling this may be an issue for some of the schizo(4) error
interrupts.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.33 2008/08/09 20:42:28 kettenis Exp $	*/
d166 1
d171 3
d178 1
d258 1
a258 1
			nih->ih_pil = q->ih_pil;
d264 3
d277 1
a277 1
	if(ih->ih_map) {
@


1.33
log
@Fix counting of shared (PCI) interrupts.  Remove some useless debug code
and unused variables.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.32 2008/04/28 20:55:10 kettenis Exp $	*/
d266 3
a283 3

	if (ih->ih_clr != NULL)			/* Set interrupt to idle */
		*ih->ih_clr = INTCLR_IDLE;
@


1.32
log
@Convert IPL_TTY into IPL_SOFTTTY when establishing soft interruptsi, like we
do on other platforms.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.31 2008/03/12 20:52:36 kettenis Exp $	*/
a158 2
int fastvec = 0;

d164 1
a164 2
intr_list_handler(arg)
	void * arg;
d166 1
a167 1
	struct intrhand *ih = (struct intrhand *)arg;
d169 4
a172 10
	if (!arg) panic("intr_list_handler: no handlers!");
	while (ih && !claimed) {
		claimed = (*ih->ih_fun)(ih->ih_arg);
#ifdef DEBUG
		{
			extern int intrdebug;
			if (intrdebug & 1)
				printf("intr %p %x arg %p %s\n",
					ih, ih->ih_number, ih->ih_arg,
					claimed ? "claimed" : "");
a173 1
#endif
d176 1
d191 1
a191 3
intr_establish(level, ih)
	int level;
	struct intrhand *ih;
d198 1
a243 1

d245 2
a246 2
			nih = (struct intrhand *)malloc(sizeof(struct intrhand),
			    M_DEVBUF, M_NOWAIT);
d249 10
a258 5
			/* Point the old IH at the new handler */
			*nih = *q;
			q->ih_fun = intr_list_handler;
			q->ih_arg = (void *)nih;
			nih->ih_next = NULL;
d260 1
a260 5
		nih = (struct intrhand *)malloc(sizeof(struct intrhand),
		    M_DEVBUF, M_NOWAIT);
		if (nih == NULL)
			panic("intr_establish");
		*nih = *ih;
d262 2
a263 2
		nih->ih_next = (struct intrhand *)q->ih_arg;
		q->ih_arg = (void *)nih;
a279 6
	} else {
#ifdef DEBUG
		printf(	"\n**********************\n"
			"********************** intr_establish: no map register\n"
			"**********************\n");
#endif
@


1.31
log
@Introduce a per-handler interrupt acknowledgement function.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.30 2008/02/14 19:07:56 kettenis Exp $	*/
d319 3
@


1.30
log
@Make sure an interrupt handler does not get on the per-cpu list of pending
interrupts twice, with one exception: interrupt handlers are allowed to be on
the tail of said lists (needed for clock interrupts on MP kernels).
Prevents losing interrupts.  Makes usb keyboard as console work on Sun Blade
1000/2000 with MP kernels.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.29 2007/09/22 20:04:51 kettenis Exp $	*/
d74 1
d189 5
d216 4
d325 1
@


1.29
log
@Add kernel locking.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.28 2007/09/17 01:33:33 krw Exp $	*/
a207 1
	ih->ih_busy = 0;    /* XXXX caller should have done this before */
a313 1
	ih->ih_busy = 0;
@


1.28
log
@Only the most obvious bzero() -> M_ZERO changes. No cast changes, no
MALLOC/FREE, etc. Just adding M_ZERO to malloc() and deleting an
immediately adjacent bzero().
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.27 2007/09/09 08:55:27 kettenis Exp $	*/
d358 21
@


1.27
log
@Make handled_intr_level per-cpu.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.26 2007/05/29 18:10:43 miod Exp $	*/
d311 1
a311 2
	ih = malloc(sizeof(*ih), M_DEVBUF, 0);
	bzero(ih, sizeof(*ih));
@


1.26
log
@Use atomic operations to operate on netisr, instead of clearing it at splhigh.
This changes nothing on legacy architectures, but is a bit faster (and simpler)
on the interesting ones.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.25 2007/05/29 09:53:57 sobrado Exp $	*/
a81 2
int handled_intr_level;	/* interrupt level that we're handling now */

d342 1
d351 1
a351 1
	if (handled_intr_level > wantipl) {
d356 1
a356 1
		splassert_fail(wantipl, handled_intr_level, func);
@


1.25
log
@use the right capitalization for `SBus'

ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.24 2007/03/16 09:28:38 art Exp $	*/
d53 1
d135 1
a135 1
	int n, s;
d137 2
a138 4
	s = splhigh();
	n = netisr;
	netisr = 0;
	splx(s);
d140 6
a145 4
#define DONETISR(bit, fn) do {		\
	if (n & (1 << bit))		\
		fn();			\
} while (0)
d147 1
d149 1
@


1.24
log
@Timecounters for sparc64. The cleanest and easiest timecounter
implementation this far. Uses the %tick register (as microtime was
using before).

kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.23 2005/04/26 18:54:39 miod Exp $	*/
d122 1
a122 1
 * Level 1 software interrupt (could also be Sbus level 1 interrupt).
@


1.23
log
@Remove unused hooks for periodic pcons polling.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.22 2004/06/28 01:47:41 aaron Exp $	*/
d108 1
a108 1
	timesince = time.tv_sec - straytime;
d113 1
a113 1
		straytime = time.tv_sec;
@


1.22
log
@Use new event counter API for interrupt counting on sparc64.  deraadt@@ tholo@@
drahn@@ millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.21 2004/06/20 04:50:24 miod Exp $	*/
a43 2
#include "pcons.h"

a126 11
int
softintr(fp)
	void *fp;
{
#if NPCONS >0
	extern void pcons_dopoll(void);

	pcons_dopoll();
#endif
	return (1);
}
a149 1
struct intrhand soft01intr = { softintr, NULL, 1 };
a150 5

void 
setsoftint() {
	send_softint(-1, IPL_SOFTINT, &soft01intr);
}
@


1.21
log
@Silence intr_establish a bit more; makes the dmesg on U2 suddenly edible.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.20 2004/01/10 09:10:07 deraadt Exp $	*/
d243 5
@


1.20
log
@spelling; jjy2+@@pitt.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.19 2003/11/06 21:09:35 mickey Exp $	*/
d283 2
a284 1
		if(INTTID(m) != id) {
d286 1
d288 1
d290 1
d294 1
a294 2
	}
	else {
@


1.19
log
@move netisr definition into md code to allow arch provide suitable allocation; tested on most archs
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.18 2003/10/01 06:01:55 cloder Exp $	*/
d106 1
a106 1
	    "vecttored=%d\n", fp->tf_pil, (unsigned long long)fp->tf_pc,
@


1.18
log
@Fix off-by-one.
OK jason@@, henric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.17 2003/06/12 01:07:31 deraadt Exp $	*/
d140 2
@


1.17
log
@final bits of obvious UCB term 3 removal
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.16 2003/05/17 03:53:39 jason Exp $	*/
d239 1
a239 1
	if (ih->ih_number <= 0 || ih->ih_number > MAXINTNUM)
@


1.16
log
@nuke intrhand, it isn't used and it overloads ih_next incorrectly... grr
ok henric, mdw (based on diff from henric, so he's biased =)
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.15 2003/05/16 23:55:00 jason Exp $	*/
d25 1
a25 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.15
log
@fix up interrupt code (ie, actually deref the ih_clr ptr correctly)
and kill some debug code
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.14 2003/05/16 17:18:15 jason Exp $	*/
a167 1
#if 1
d172 1
a176 25
#endif

/*
 * Level 15 interrupts are special, and not vectored here.
 * Only `prewired' interrupts appear here; boot-time configured devices
 * are attached via intr_establish() below.
 */
struct intrhand *intrhand[16] = {
	NULL,			/*  0 = error */
	&soft01intr,		/*  1 = software level 1 + Sbus */
	NULL,	 		/*  2 = Sbus level 2 (4m: Sbus L1) */
	NULL,			/*  3 = SCSI + DMA + Sbus level 3 (4m: L2,lpt)*/
	NULL,			/*  4 = software level 4 (tty softint) (scsi) */
	NULL,			/*  5 = Ethernet + Sbus level 4 (4m: Sbus L3) */
	NULL,			/*  6 = software level 6 (not used) (4m: enet)*/
	NULL,			/*  7 = video + Sbus level 5 */
	NULL,			/*  8 = Sbus level 6 */
	NULL,			/*  9 = Sbus level 7 */
	NULL,			/* 10 = counter 0 = clock */
	NULL,			/* 11 = floppy */
	NULL,			/* 12 = zs hardware interrupt */
	NULL,			/* 13 = audio chip */
	NULL,			/* 14 = counter 1 = profiling timer */
	NULL			/* 15 = async faults */
};
d218 1
a218 1
	register struct intrhand **p, *q;
a230 3
	for (p = &intrhand[level]; (q = *p) != NULL; p = &q->ih_next)
		continue;
	*p = ih;
@


1.14
log
@move the interrupt idle stuff to the generic intr_establish function
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.13 2003/03/20 23:05:30 henric Exp $	*/
d286 1
a286 1
		printf("\nintr_establish: intr reused %x", ih->ih_number);
a308 7
#ifdef DEBUG
	printf("\nintr_establish: vector %x pil %x mapintr %p "
	    "clrintr %p fun %p arg %p target %d",
	    ih->ih_number, ih->ih_pil, (void *)ih->ih_map,
	    (void *)ih->ih_clr, (void *)ih->ih_fun,
	    (void *)ih->ih_arg, (int)(ih->ih_map ? INTTID(*ih->ih_map) : -1));
#endif
a315 1
			*ih->ih_map = m;
d318 2
d330 9
a338 1
		ih->ih_clr = INTCLR_IDLE;
@


1.13
log
@The current code tries to use the same field in the interrupt handler as
both a "next" pointer for a singly-linked list and as an in-use flag.
This obviously does not work all that well.  This change adds a separate
ih_busy flag to mark the handler as in-use, leaving ih_pending for use by
the list code.

Testing by *many* (thanks).

ok miod jason
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.12 2003/02/17 01:29:20 henric Exp $	*/
d334 3
@


1.12
log
@
Add support for the Sun Enterprise 450
Reduce the size of a GENERIC kernel by ~190k
Remove the nasty pointer/bus_space_handle_t casts
Adds debug bus_space code including the ability to trace
    bus operations (it actually works now).

The following rules are now followed (and verfified by the debug
code):

1.  A "bus_space_handle_t" may only be used with the
    "bus_space_tag_t" that created it.
2.  Only "bus_space_map()" may create "bus_space_handle_t"s.
3.  A "bus_space_handle_t" may not be modified after it has
    been created (other than being destroyed by "bus_space_unmap()").


Thanks to help from mcbride, marc, jason, drahn, to anyone that might
have slipped my mind at the moment.

ok jason@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.11 2002/07/23 13:58:23 art Exp $	*/
d253 1
d351 1
@


1.11
log
@When handling an interrupt record the interrupt level we're handling
in a global variable (not mp safe!). Use that value for the reverse
splassert check.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.10 2002/05/22 00:58:26 deraadt Exp $	*/
d64 3
d109 2
a110 2
	printf("stray interrupt ipl %u pc=%llx npc=%llx pstate=%b vecttored=%d\n",
	    fp->tf_pil, (unsigned long long)fp->tf_pc,
d244 1
d264 1
a264 1
		printf("\nintr_establish: NULL vector fun %p arg %p pil %p\n",
d285 1
a285 1
		printf("intr_establish: intr reused %x\n", ih->ih_number);
d308 1
a308 2

#ifdef NOT_DEBUG
d310 1
a310 1
	    "clrintr %p fun %p arg %p\n",
d313 18
a330 1
	    (void *)ih->ih_arg);
d332 1
@


1.10
log
@let !DIAGOSTIC kernels build
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.9 2002/05/21 16:15:53 art Exp $	*/
d84 2
d360 8
@


1.9
log
@Implement splassert just like it's on sparc.
This also requires a change to rename {PIL,IPL}_IMP to {PIL,IPL}_VM.
XXX - We should get rid of PIL_*.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.8 2002/03/14 01:26:45 millert Exp $	*/
d348 1
d360 1
a360 1

@


1.8
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.7 2002/01/10 00:06:17 nordin Exp $	*/
d347 13
@


1.7
log
@Check result from malloc(9) when using M_NOWAIT. jason@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.6 2001/11/28 05:32:11 jason Exp $	*/
d72 4
a75 4
void	strayintr __P((const struct trapframe64 *, int));
int	softintr __P((void *));
int	softnet __P((void *));
int	intr_list_handler __P((void *));
d133 1
a133 1
	extern void pcons_dopoll __P((void));
d317 1
a317 1
	void (*fun) __P((void *));
d324 1
a324 1
	ih->ih_fun = (int (*) __P((void *)))fun;	/* XXX */
@


1.6
log
@rewrite large chunks of intr_establish to make it more clear what's going on.
Also, while here, fix a work around (hack) for the problem of more than 3
devices sharing a particular level (make a copy of the interrupt handler
rather than modifying the one added to the pil table).  This allows
qec+qe (and probably qfe) to get through autoconf without hanging.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.5 2001/09/21 02:02:22 art Exp $	*/
d285 2
d295 2
@


1.6.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.7 2002/01/10 00:06:17 nordin Exp $	*/
a284 2
			if (nih == NULL)
				panic("intr_establish");
a292 2
		if (nih == NULL)
			panic("intr_establish");
@


1.6.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.6.2.1 2002/01/31 22:55:24 niklas Exp $	*/
d72 4
a75 4
void	strayintr(const struct trapframe64 *, int);
int	softintr(void *);
int	softnet(void *);
int	intr_list_handler(void *);
d133 1
a133 1
	extern void pcons_dopoll(void);
d317 1
a317 1
	void (*fun)(void *);
d324 1
a324 1
	ih->ih_fun = (int (*)(void *))fun;	/* XXX */
a346 14

#ifdef DIAGNOSTIC
void
splassert_check(int wantipl, const char *func)
{
	int oldipl;

	__asm __volatile("rdpr %%pil,%0" : "=r" (oldipl));

	if (oldipl < wantipl) {
		splassert_fail(wantipl, oldipl, func);
	}
}
#endif
@


1.6.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.6.2.2 2002/06/11 03:38:43 art Exp $	*/
a83 2
int handled_intr_level;	/* interrupt level that we're handling now */

a357 8
	}

	if (handled_intr_level > wantipl) {
		/*
		 * XXX - need to show difference between what's blocked and
		 * what's running.
		 */
		splassert_fail(wantipl, handled_intr_level, func);
@


1.6.2.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a63 3
/* Grab interrupt map stuff (what is it doing there???) */
#include <sparc64/dev/iommureg.h>

d106 2
a107 2
	printf("stray interrupt ipl %u pc=%llx npc=%llx pstate=%b "
	    "vecttored=%d\n", fp->tf_pil, (unsigned long long)fp->tf_pc,
d165 1
a169 1

d174 25
d240 1
a240 2
	struct intrhand *q;
	u_int64_t m, id;
a248 1
	ih->ih_busy = 0;    /* XXXX caller should have done this before */
d251 3
d260 1
a260 1
		printf("\nintr_establish: NULL vector fun %p arg %p pil %p",
d305 1
a305 23
	if(ih->ih_map) {
		id = CPU_UPAID;
		m = *ih->ih_map;
		if(INTTID(m) != id) {
			printf("\nintr_establish: changing map 0x%llx -> ", m);
			m = (m & ~INTMAP_TID) | (id << INTTID_SHIFT);
			printf("0x%llx (id=%llx) ", m, id);
		}
		m |= INTMAP_V;
		*ih->ih_map = m;
	}
	else {
#ifdef DEBUG
		printf(	"\n**********************\n"
			"********************** intr_establish: no map register\n"
			"**********************\n");
#endif
	}

	if (ih->ih_clr != NULL)			/* Set interrupt to idle */
		*ih->ih_clr = INTCLR_IDLE;

#ifdef DEBUG
d307 1
a307 1
	    "clrintr %p fun %p arg %p target %d",
d310 1
a310 1
	    (void *)ih->ih_arg, (int)(ih->ih_map ? INTTID(*ih->ih_map) : -1));
a328 1
	ih->ih_busy = 0;
@


1.5
log
@Shared interrupts are not that uncommon. Stop chatting about it.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.4 2001/09/20 21:29:26 jason Exp $	*/
d250 1
a250 1
		;
d252 1
d263 15
a277 7
	if (ih->ih_number < MAXINTNUM && ih->ih_number >= 0) {
		if ((q = intrlev[ih->ih_number])) {
			struct intrhand *nih;
			/*
			 * Interrupt is already there.  We need to create a
			 * new interrupt handler and interpose it.
			 */
d279 1
a279 2
			printf("intr_establish: intr reused %x\n", 
				ih->ih_number);
d282 8
a289 13
			if (q->ih_fun != intr_list_handler) {
				nih = (struct intrhand *)
					malloc(sizeof(struct intrhand),
						M_DEVBUF, M_NOWAIT);
				/* Point the old IH at the new handler */
				*nih = *q;
				q->ih_fun = intr_list_handler;
				q->ih_arg = (void *)nih;
				nih->ih_next = NULL;
			}
			/* Add the ih to the head of the list */
			ih->ih_next = (struct intrhand *)q->ih_arg;
			q->ih_arg = (void *)ih;
d291 8
a298 2
		else
			intrlev[ih->ih_number] = ih;
d300 5
a304 6
		printf("\nintr_establish: vector %x pil %x mapintr %p "
			"clrintr %p fun %p arg %p\n",
			ih->ih_number, ih->ih_pil, (void *)ih->ih_map,
			(void *)ih->ih_clr, (void *)ih->ih_fun,
			(void *)ih->ih_arg);
		/*Debugger();*/
d306 1
a306 2
	} else
		panic("intr_establish: bad intr number %x", ih->ih_number);
@


1.5.4.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.5.4.2
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.5.4.1 2001/10/31 03:07:59 nate Exp $	*/
d250 1
a250 1
		continue;
a251 1

d262 7
a268 15

	if (ih->ih_number <= 0 || ih->ih_number > MAXINTNUM)
		panic("intr_establish: bad intr number %x", ih->ih_number);

	q = intrlev[ih->ih_number];
	if (q == NULL) {
		/* No interrupt already there, just put handler in place. */
		intrlev[ih->ih_number] = ih;
	} else {
		struct intrhand *nih;

		/*
		 * Interrupt is already there.  We need to create a
		 * new interrupt handler and interpose it.
		 */
d270 2
a271 1
		printf("intr_establish: intr reused %x\n", ih->ih_number);
d274 13
a286 8
		if (q->ih_fun != intr_list_handler) {
			nih = (struct intrhand *)malloc(sizeof(struct intrhand),
			    M_DEVBUF, M_NOWAIT);
			/* Point the old IH at the new handler */
			*nih = *q;
			q->ih_fun = intr_list_handler;
			q->ih_arg = (void *)nih;
			nih->ih_next = NULL;
d288 2
a289 8
		nih = (struct intrhand *)malloc(sizeof(struct intrhand),
		    M_DEVBUF, M_NOWAIT);
		*nih = *ih;
		/* Add the ih to the head of the list */
		nih->ih_next = (struct intrhand *)q->ih_arg;
		q->ih_arg = (void *)nih;
	}

d291 6
a296 5
	printf("\nintr_establish: vector %x pil %x mapintr %p "
	    "clrintr %p fun %p arg %p\n",
	    ih->ih_number, ih->ih_pil, (void *)ih->ih_map,
	    (void *)ih->ih_clr, (void *)ih->ih_fun,
	    (void *)ih->ih_arg);
d298 2
a299 1

@


1.5.4.3
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a284 2
			if (nih == NULL)
				panic("intr_establish");
a292 2
		if (nih == NULL)
			panic("intr_establish");
@


1.5.4.4
log
@Merge in -current from about a week ago
@
text
@d72 4
a75 4
void	strayintr(const struct trapframe64 *, int);
int	softintr(void *);
int	softnet(void *);
int	intr_list_handler(void *);
d133 1
a133 1
	extern void pcons_dopoll(void);
d317 1
a317 1
	void (*fun)(void *);
d324 1
a324 1
	ih->ih_fun = (int (*)(void *))fun;	/* XXX */
@


1.5.4.5
log
@Sync the SMP branch with 3.3
@
text
@a63 3
/* Grab interrupt map stuff (what is it doing there???) */
#include <sparc64/dev/iommureg.h>

a83 2
int handled_intr_level;	/* interrupt level that we're handling now */

d104 2
a105 2
	printf("stray interrupt ipl %u pc=%llx npc=%llx pstate=%b "
	    "vecttored=%d\n", fp->tf_pil, (unsigned long long)fp->tf_pc,
a238 1
	u_int64_t m, id;
a246 1
	ih->ih_busy = 0;    /* XXXX caller should have done this before */
d258 1
a258 1
		printf("\nintr_establish: NULL vector fun %p arg %p pil %p",
d279 1
a279 1
		printf("\nintr_establish: intr reused %x", ih->ih_number);
d302 2
a303 1
#ifdef DEBUG
d305 1
a305 1
	    "clrintr %p fun %p arg %p target %d",
d308 1
a308 18
	    (void *)ih->ih_arg, (int)(ih->ih_map ? INTTID(*ih->ih_map) : -1));
#endif

	if(ih->ih_map) {
		id = CPU_UPAID;
		m = *ih->ih_map;
		if(INTTID(m) != id) {
			printf("\nintr_establish: changing map 0x%llx -> ", m);
			m = (m & ~INTMAP_TID) | (id << INTTID_SHIFT);
			*ih->ih_map = m;
			printf("0x%llx (id=%llx) ", m, id);
		}
	}
	else {
#ifdef DEBUG
		printf(	"\n**********************\n"
			"********************** intr_establish: no map register\n"
			"**********************\n");
a309 1
	}
a326 1
	ih->ih_busy = 0;
a346 22

#ifdef DIAGNOSTIC
void
splassert_check(int wantipl, const char *func)
{
	int oldipl;

	__asm __volatile("rdpr %%pil,%0" : "=r" (oldipl));

	if (oldipl < wantipl) {
		splassert_fail(wantipl, oldipl, func);
	}

	if (handled_intr_level > wantipl) {
		/*
		 * XXX - need to show difference between what's blocked and
		 * what's running.
		 */
		splassert_fail(wantipl, handled_intr_level, func);
	}
}
#endif
@


1.5.4.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.5.4.5 2003/03/27 23:42:37 niklas Exp $	*/
d168 1
a172 1

d177 25
d243 1
a243 1
	struct intrhand *q;
d256 3
d286 1
a286 1
		printf("intr_establish: intr reused %x\n", ih->ih_number);
d309 7
d323 1
a325 2
		m |= INTMAP_V;
		*ih->ih_map = m;
a333 11

	if (ih->ih_clr != NULL)			/* Set interrupt to idle */
		*ih->ih_clr = INTCLR_IDLE;

#ifdef DEBUG
	printf("\nintr_establish: vector %x pil %x mapintr %p "
	    "clrintr %p fun %p arg %p target %d",
	    ih->ih_number, ih->ih_pil, (void *)ih->ih_map,
	    (void *)ih->ih_clr, (void *)ih->ih_fun,
	    (void *)ih->ih_arg, (int)(ih->ih_map ? INTTID(*ih->ih_map) : -1));
#endif
@


1.5.4.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d25 5
a29 1
 * 3. Neither the name of the University nor the names of its contributors
d110 1
a110 1
	    "vectored=%d\n", fp->tf_pil, (unsigned long long)fp->tf_pc,
a144 2
int netisr;

d243 1
a243 1
	if (ih->ih_number <= 0 || ih->ih_number >= MAXINTNUM)
@


1.4
log
@Our printf has %b, use it and don't bother with snprintf stuff.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.3 2001/09/04 15:25:52 jason Exp $	*/
d269 1
d272 1
@


1.3
log
@add entry to async faults to intrhand array (from netbsd)
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.2 2001/08/20 20:23:53 jason Exp $	*/
a90 1
	char buf[256];
d104 1
a104 3
	snprintf(buf, sizeof(buf), "%b", fp->tf_tstate>>TSTATE_PSTATE_SHIFT,
		PSTATE_BITS);
	printf("stray interrupt ipl %u pc=%llx npc=%llx pstate=%s vecttored=%d\n",
d106 2
a107 1
	    (unsigned long long)fp->tf_npc, buf, vectored);
@


1.2
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d181 1
a181 1
struct intrhand *intrhand[15] = {
d196 2
a197 1
	NULL			/* 14 = counter 1 = profiling timer */
@


1.1
log
@Lot of stuff... Some from NetBSD, some from OpenBSD, minor modifications
@
text
@d1 1
@

