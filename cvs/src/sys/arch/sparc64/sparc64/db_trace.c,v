head	1.13;
access;
symbols
	OPENBSD_6_1_BASE:1.13
	OPENBSD_6_0:1.10.0.8
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.4
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.10.0.6
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.9.0.32
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.9.0.30
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.26
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.24
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.22
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.20
	OPENBSD_5_0:1.9.0.18
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.16
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.14
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.10
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.12
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.8
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.6
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.4
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.2
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.8.0.2
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.7.0.16
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.14
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.12
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.10
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.8
	OPENBSD_3_6_BASE:1.7
	SMP_SYNC_A:1.7
	SMP_SYNC_B:1.7
	OPENBSD_3_5:1.7.0.6
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.7.0.4
	OPENBSD_3_4_BASE:1.7
	UBC_SYNC_A:1.7
	OPENBSD_3_3:1.7.0.2
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4
	UBC_SYNC_B:1.7
	UBC:1.2.0.6
	UBC_BASE:1.2
	SMP:1.2.0.4
	OPENBSD_3_0:1.2.0.2
	OPENBSD_3_0_BASE:1.2;
locks; strict;
comment	@ * @;


1.13
date	2017.01.24.00.58.55;	author mpi;	state Exp;
branches;
next	1.12;
commitid	r0ks7yUPmANG37rA;

1.12
date	2016.09.11.03.14.04;	author guenther;	state Exp;
branches;
next	1.11;
commitid	CTJERhMeok0roRjS;

1.11
date	2016.09.10.17.59.53;	author guenther;	state Exp;
branches;
next	1.10;
commitid	6WlFLEPgYY7c4kSh;

1.10
date	2015.02.09.09.21.30;	author miod;	state Exp;
branches;
next	1.9;
commitid	yX211148OePJhQ1v;

1.9
date	2007.08.15.20.10.08;	author kettenis;	state Exp;
branches;
next	1.8;

1.8
date	2006.11.29.12.24.17;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2002.10.09.21.10.48;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.18.09.49.17;	author art;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.16.13.01.41;	author art;	state Exp;
branches;
next	1.4;

1.4
date	2002.03.14.03.16.01;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2002.03.14.01.26.45;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2001.08.20.20.23.53;	author jason;	state Exp;
branches
	1.2.4.1
	1.2.6.1;
next	1.1;

1.1
date	2001.08.19.16.05.12;	author art;	state Exp;
branches;
next	;

1.2.4.1
date	2001.10.31.03.07.58;	author nate;	state Exp;
branches;
next	1.2.4.2;

1.2.4.2
date	2002.03.28.11.23.52;	author niklas;	state Exp;
branches;
next	1.2.4.3;

1.2.4.3
date	2003.03.27.23.42.37;	author niklas;	state Exp;
branches;
next	;

1.2.6.1
date	2002.06.11.03.38.43;	author art;	state Exp;
branches;
next	1.2.6.2;

1.2.6.2
date	2002.10.29.00.28.12;	author art;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Rename pfind(9) into tfind(9) to reflect that it deals with threads.

While here document prfind(9.

with and ok guenther@@
@
text
@/*	$OpenBSD: db_trace.c,v 1.12 2016/09/11 03:14:04 guenther Exp $	*/
/*	$NetBSD: db_trace.c,v 1.23 2001/07/10 06:06:16 eeh Exp $ */

/*
 * Mach Operating System
 * Copyright (c) 1991,1990 Carnegie Mellon University
 * All Rights Reserved.
 *
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

#include <sys/param.h>
#include <sys/proc.h>
#include <sys/systm.h>
#include <sys/user.h>
#include <machine/db_machdep.h>
#include <machine/ctlreg.h>

#include <ddb/db_access.h>
#include <ddb/db_sym.h>
#include <ddb/db_interface.h>
#include <ddb/db_output.h>

void db_dump_fpstate(db_expr_t, int, db_expr_t, char *);
void db_dump_window(db_expr_t, int, db_expr_t, char *);
void db_dump_stack(db_expr_t, int, db_expr_t, char *);
void db_dump_trap(db_expr_t, int, db_expr_t, char *);
void db_dump_ts(db_expr_t, int, db_expr_t, char *);
void db_print_window(u_int64_t);

#if 0
#define INKERNEL(va)	(((vaddr_t)(va)) >= VM_MIN_KERNEL_ADDRESS) /* Not really true, y'know */
#else
#define INKERNEL(va)	1	/* Everything's in the kernel now. 8^) */
#endif

#define	KLOAD(x)	probeget((paddr_t)(u_long)&(x), ASI_PRIMARY, sizeof(x))
#define ULOAD(x)	probeget((paddr_t)(u_long)&(x), ASI_AIUS, sizeof(x))

void
db_stack_trace_print(db_expr_t addr, int have_addr, db_expr_t count,
    char *modif, int (*pr)(const char *, ...))
{
	vaddr_t		frame;
	boolean_t	kernel_only = TRUE;
	boolean_t	trace_thread = FALSE;
	char		c, *cp = modif;

	while ((c = *cp++) != 0) {
		if (c == 't')
			trace_thread = TRUE;
		if (c == 'u')
			kernel_only = FALSE;
	}

	if (!have_addr)
		frame = (vaddr_t)DDB_TF->tf_out[6];
	else {
		if (trace_thread) {
			struct proc *p;
			struct user *u;
			(*pr)("trace: pid %d ", (int)addr);
			p = tfind(addr);
			if (p == NULL) {
				(*pr)("not found\n");
				return;
			}
			u = p->p_addr;
			frame = (vaddr_t)u->u_pcb.pcb_sp;
			(*pr)("at %p\n", frame);
		} else {
			frame = (vaddr_t)addr;
		}
	}

	if ((frame & 1) == 0) {
		db_printf("WARNING: corrupt frame at %lx\n", frame);
		return;
	}

	while (count--) {
		int		i;
		db_expr_t	offset;
		char		*name;
		db_addr_t	pc;
		struct frame64	*f64;

		/*
		 * Switch to frame that contains arguments
		 */

		f64 = (struct frame64 *)(frame + BIAS);
		pc = (db_addr_t)KLOAD(f64->fr_pc);

		frame = KLOAD(f64->fr_fp);

		if (kernel_only) {
			if (pc < KERNBASE || pc >= KERNEND)
				break;
			if (frame < KERNBASE)
				break;
		} else {
			if (frame == 0 || frame == (vaddr_t)-1)
				break;
		}
#if 0
		if (!INKERNEL(frame))
			break;
#endif

		db_find_sym_and_offset(pc, &name, &offset);
		if (name == NULL)
			name = "?";

		(*pr)("%s(", name);

		if ((frame & 1) == 0) {
			db_printf(")\nWARNING: corrupt frame at %lx\n", frame);
			break;
		}

		/*
		 * Print %i0..%i5; hope these still reflect the
		 * actual arguments somewhat...
		 */
		f64 = (struct frame64 *)(frame + BIAS);
		for (i = 0; i < 5; i++)
			(*pr)("%lx, ", (long)KLOAD(f64->fr_arg[i]));
		(*pr)("%lx) at ", (long)KLOAD(f64->fr_arg[i]));
		db_printsym(pc, DB_STGY_PROC, pr);
		(*pr)("\n");
	}
}


void
db_dump_window(db_expr_t addr, int have_addr, db_expr_t count, char *modif)
{
	int i;
	u_int64_t frame = DDB_TF->tf_out[6];

	/* Addr is really window number */
	if (!have_addr)
		addr = 0;

	/* Traverse window stack */
	for (i = 0; i < addr && frame; i++) {
		if ((frame & 1) == 0)
			break;
		frame = ((struct frame64 *)(frame + BIAS))->fr_fp;
	}

	if ((frame & 1) == 0) {
		db_printf("WARNING: corrupt frame at %llx\n", frame);
		return;
	}

	db_printf("Window %lx ", addr);
	db_print_window(frame);
}

void
db_print_window(u_int64_t frame)
{
	struct frame64 *f = (struct frame64 *)(frame + BIAS);

	db_printf("frame64 %p locals, ins:\n", f);
	if (INKERNEL(f)) {
		db_printf("%llx %llx %llx %llx ",
			  (unsigned long long)f->fr_local[0],
			  (unsigned long long)f->fr_local[1],
			  (unsigned long long)f->fr_local[2],
			  (unsigned long long)f->fr_local[3]);
		db_printf("%llx %llx %llx %llx\n",
			  (unsigned long long)f->fr_local[4],
			  (unsigned long long)f->fr_local[5],
			  (unsigned long long)f->fr_local[6],
			  (unsigned long long)f->fr_local[7]);
		db_printf("%llx %llx %llx %llx ",
			  (unsigned long long)f->fr_arg[0],
			  (unsigned long long)f->fr_arg[1],
			  (unsigned long long)f->fr_arg[2],
			  (unsigned long long)f->fr_arg[3]);
		db_printf("%llx %llx %llx=sp %llx=pc:",
			  (unsigned long long)f->fr_arg[4],
			  (unsigned long long)f->fr_arg[5],
			  (unsigned long long)f->fr_fp,
			  (unsigned long long)f->fr_pc);
		/* Sometimes this don't work.  Dunno why. */
		db_printsym(f->fr_pc, DB_STGY_PROC, db_printf);
		db_printf("\n");
	} else {
		struct frame64 fr;

		if (copyin(f, &fr, sizeof(fr)))
			return;
		f = &fr;
		db_printf("%llx %llx %llx %llx ",
			  (unsigned long long)f->fr_local[0],
			  (unsigned long long)f->fr_local[1],
			  (unsigned long long)f->fr_local[2],
			  (unsigned long long)f->fr_local[3]);
		db_printf("%llx %llx %llx %llx\n",
			  (unsigned long long)f->fr_local[4],
			  (unsigned long long)f->fr_local[5],
			  (unsigned long long)f->fr_local[6],
			  (unsigned long long)f->fr_local[7]);
		db_printf("%llx %llx %llx %llx ",
			  (unsigned long long)f->fr_arg[0],
			  (unsigned long long)f->fr_arg[1],
			  (unsigned long long)f->fr_arg[2],
			  (unsigned long long)f->fr_arg[3]);
		db_printf("%llx %llx %llx=sp %llx=pc",
			  (unsigned long long)f->fr_arg[4],
			  (unsigned long long)f->fr_arg[5],
			  (unsigned long long)f->fr_fp,
			  (unsigned long long)f->fr_pc);
		db_printf("\n");
	}
}

void
db_dump_stack(db_expr_t addr, int have_addr, db_expr_t count, char *modif)
{
	int		i;
	u_int64_t	frame, oldframe;
	boolean_t	kernel_only = TRUE;
	char		c, *cp = modif;

	while ((c = *cp++) != 0)
		if (c == 'u')
			kernel_only = FALSE;

	if (count == -1)
		count = 65535;

	if (!have_addr)
		frame = DDB_TF->tf_out[6];
	else
		frame = addr;

	/* Traverse window stack */
	oldframe = 0;
	for (i = 0; i < count && frame; i++) {
		if (oldframe == frame) {
			db_printf("WARNING: stack loop at %llx\n", frame);
			break;
		}
		oldframe = frame;

		if ((frame & 1) == 0) {
			db_printf("WARNING: corrupt stack at %llx\n", frame);
			break;
		}

		frame += BIAS;
		if (!INKERNEL(((struct frame64 *)frame))
		    && kernel_only) break;
		db_printf("Window %x ", i);
		db_print_window(frame - BIAS);
		if (!INKERNEL(((struct frame64 *)frame))) {
			copyin(&((struct frame64 *)frame)->fr_fp, &frame,
			    sizeof(frame));
		} else
			frame = ((struct frame64 *)frame)->fr_fp;
	}

}


void
db_dump_trap(db_expr_t addr, int have_addr, db_expr_t count, char *modif)
{
	struct trapframe64 *tf;

	/* Use our last trapframe? */
	tf = &ddb_regs.ddb_tf;
	{
		/* Or the user trapframe? */
		register char c, *cp = modif;
		while ((c = *cp++) != 0)
			if (c == 'u')
				tf = curproc->p_md.md_tf;
	}
	/* Or an arbitrary trapframe */
	if (have_addr)
		tf = (struct trapframe64 *)addr;

	db_printf("Trapframe %p:\ttstate: %llx\tpc: %llx\tnpc: %llx\n",
		  tf, (unsigned long long)tf->tf_tstate,
		  (unsigned long long)tf->tf_pc,
		  (unsigned long long)tf->tf_npc);
	db_printf("y: %x\tpil: %d\toldpil: %d\tfault: %llx\tkstack: %llx\ttt: %x\nGlobals:\n",
		  (int)tf->tf_y, (int)tf->tf_pil, (int)tf->tf_oldpil,
		  (unsigned long long)tf->tf_fault,
		  (unsigned long long)tf->tf_kstack, (int)tf->tf_tt);
	db_printf("%016llx %016llx %016llx %016llx\n",
		  (unsigned long long)tf->tf_global[0],
		  (unsigned long long)tf->tf_global[1],
		  (unsigned long long)tf->tf_global[2],
		  (unsigned long long)tf->tf_global[3]);
	db_printf("%016llx %016llx %016llx %016llx\nouts:\n",
		  (unsigned long long)tf->tf_global[4],
		  (unsigned long long)tf->tf_global[5],
		  (unsigned long long)tf->tf_global[6],
		  (unsigned long long)tf->tf_global[7]);
	db_printf("%016llx %016llx %016llx %016llx\n",
		  (unsigned long long)tf->tf_out[0],
		  (unsigned long long)tf->tf_out[1],
		  (unsigned long long)tf->tf_out[2],
		  (unsigned long long)tf->tf_out[3]);
	db_printf("%016llx %016llx %016llx %016llx\nlocals:\n",
		  (unsigned long long)tf->tf_out[4],
		  (unsigned long long)tf->tf_out[5],
		  (unsigned long long)tf->tf_out[6],
		  (unsigned long long)tf->tf_out[7]);
	db_printf("%016llx %016llx %016llx %016llx\n",
		  (unsigned long long)tf->tf_local[0],
		  (unsigned long long)tf->tf_local[1],
		  (unsigned long long)tf->tf_local[2],
		  (unsigned long long)tf->tf_local[3]);
	db_printf("%016llx %016llx %016llx %016llx\nins:\n",
		  (unsigned long long)tf->tf_local[4],
		  (unsigned long long)tf->tf_local[5],
		  (unsigned long long)tf->tf_local[6],
		  (unsigned long long)tf->tf_local[7]);
	db_printf("%016llx %016llx %016llx %016llx\n",
		  (unsigned long long)tf->tf_in[0],
		  (unsigned long long)tf->tf_in[1],
		  (unsigned long long)tf->tf_in[2],
		  (unsigned long long)tf->tf_in[3]);
	db_printf("%016llx %016llx %016llx %016llx\n",
		  (unsigned long long)tf->tf_in[4],
		  (unsigned long long)tf->tf_in[5],
		  (unsigned long long)tf->tf_in[6],
		  (unsigned long long)tf->tf_in[7]);
#if 0
	if (tf == curproc->p_md.md_tf) {
		struct rwindow32 *kstack = (struct rwindow32 *)(((caddr_t)tf)+CCFSZ);
		db_printf("ins (from stack):\n%016llx %016llx %016llx %016llx\n",
			  (int64_t)kstack->rw_local[0],
			  (int64_t)kstack->rw_local[1],
			  (int64_t)kstack->rw_local[2],
			  (int64_t)kstack->rw_local[3]);
		db_printf("%016llx %016llx %016llx %016llx\n",
			  (int64_t)kstack->rw_local[4],
			  (int64_t)kstack->rw_local[5],
			  (int64_t)kstack->rw_local[6],
			  (int64_t)kstack->rw_local[7]);
	}
#endif
}

void
db_dump_fpstate(db_expr_t addr, int have_addr, db_expr_t count, char *modif)
{
	struct fpstate64 *fpstate;

	/* Use our last trapframe? */
	fpstate = &ddb_regs.ddb_fpstate;
	/* Or an arbitrary trapframe */
	if (have_addr)
		fpstate = (struct fpstate64 *)addr;

	db_printf("fpstate %p: fsr = %llx gsr = %lx\nfpregs:\n",
		fpstate, (unsigned long long)fpstate->fs_fsr,
		(unsigned long)fpstate->fs_gsr);
	db_printf(" 0: %08x %08x %08x %08x %08x %08x %08x %08x\n",
		(unsigned int)fpstate->fs_regs[0],
		(unsigned int)fpstate->fs_regs[1],
		(unsigned int)fpstate->fs_regs[2],
		(unsigned int)fpstate->fs_regs[3],
		(unsigned int)fpstate->fs_regs[4],
		(unsigned int)fpstate->fs_regs[5],
		(unsigned int)fpstate->fs_regs[6],
		(unsigned int)fpstate->fs_regs[7]);
	db_printf(" 8: %08x %08x %08x %08x %08x %08x %08x %08x\n",
		(unsigned int)fpstate->fs_regs[8],
		(unsigned int)fpstate->fs_regs[9],
		(unsigned int)fpstate->fs_regs[10],
		(unsigned int)fpstate->fs_regs[11],
		(unsigned int)fpstate->fs_regs[12],
		(unsigned int)fpstate->fs_regs[13],
		(unsigned int)fpstate->fs_regs[14],
		(unsigned int)fpstate->fs_regs[15]);
	db_printf("16: %08x %08x %08x %08x %08x %08x %08x %08x\n",
		(unsigned int)fpstate->fs_regs[16],
		(unsigned int)fpstate->fs_regs[17],
		(unsigned int)fpstate->fs_regs[18],
		(unsigned int)fpstate->fs_regs[19],
		(unsigned int)fpstate->fs_regs[20],
		(unsigned int)fpstate->fs_regs[21],
		(unsigned int)fpstate->fs_regs[22],
		(unsigned int)fpstate->fs_regs[23]);
	db_printf("24: %08x %08x %08x %08x %08x %08x %08x %08x\n",
		(unsigned int)fpstate->fs_regs[24],
		(unsigned int)fpstate->fs_regs[25],
		(unsigned int)fpstate->fs_regs[26],
		(unsigned int)fpstate->fs_regs[27],
		(unsigned int)fpstate->fs_regs[28],
		(unsigned int)fpstate->fs_regs[29],
		(unsigned int)fpstate->fs_regs[30],
		(unsigned int)fpstate->fs_regs[31]);
	db_printf("32: %08x%08x %08x%08x %08x%08x %08x%08x\n",
		(unsigned int)fpstate->fs_regs[32],
		(unsigned int)fpstate->fs_regs[33],
		(unsigned int)fpstate->fs_regs[34],
		(unsigned int)fpstate->fs_regs[35],
		(unsigned int)fpstate->fs_regs[36],
		(unsigned int)fpstate->fs_regs[37],
		(unsigned int)fpstate->fs_regs[38],
		(unsigned int)fpstate->fs_regs[39]);
	db_printf("40: %08x%08x %08x%08x %08x%08x %08x%08x\n",
		(unsigned int)fpstate->fs_regs[40],
		(unsigned int)fpstate->fs_regs[41],
		(unsigned int)fpstate->fs_regs[42],
		(unsigned int)fpstate->fs_regs[43],
		(unsigned int)fpstate->fs_regs[44],
		(unsigned int)fpstate->fs_regs[45],
		(unsigned int)fpstate->fs_regs[46],
		(unsigned int)fpstate->fs_regs[47]);
	db_printf("48: %08x%08x %08x%08x %08x%08x %08x%08x\n",
		(unsigned int)fpstate->fs_regs[48],
		(unsigned int)fpstate->fs_regs[49],
		(unsigned int)fpstate->fs_regs[50],
		(unsigned int)fpstate->fs_regs[51],
		(unsigned int)fpstate->fs_regs[52],
		(unsigned int)fpstate->fs_regs[53],
		(unsigned int)fpstate->fs_regs[54],
		(unsigned int)fpstate->fs_regs[55]);
	db_printf("56: %08x%08x %08x%08x %08x%08x %08x%08x\n",
		(unsigned int)fpstate->fs_regs[56],
		(unsigned int)fpstate->fs_regs[57],
		(unsigned int)fpstate->fs_regs[58],
		(unsigned int)fpstate->fs_regs[59],
		(unsigned int)fpstate->fs_regs[60],
		(unsigned int)fpstate->fs_regs[61],
		(unsigned int)fpstate->fs_regs[62],
		(unsigned int)fpstate->fs_regs[63]);
}

void
db_dump_ts(db_expr_t addr, int have_addr, db_expr_t count, char *modif)
{
	struct trapstate	*ts;
	int			i, tl;

	/* Use our last trapframe? */
	ts = &ddb_regs.ddb_ts[0];
	tl = ddb_regs.ddb_tl;
	for (i = 0; i < tl; i++) {
		printf("%d tt=%lx tstate=%lx tpc=%p tnpc=%p\n",
		       i+1, (long)ts[i].tt, (u_long)ts[i].tstate,
		       (void *)(u_long)ts[i].tpc, (void *)(u_long)ts[i].tnpc);
	}

}


@


1.12
log
@Remove trailing whitespace

noted by jasper's emacs
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.11 2016/09/10 17:59:53 guenther Exp $	*/
d81 1
a81 1
			p = pfind(addr);
@


1.11
log
@Delete support for 32bit frame backtracing
Convert function definitions from K&R to Standard C
Delete superfluous casts and fix some whitespace

ok jasper@@ mpi@@ kettenis@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.10 2015/02/09 09:21:30 miod Exp $	*/
d55 2
a56 2
#define	KLOAD(x)	probeget((paddr_t)(u_long)&(x), ASI_PRIMARY, sizeof(x))	
#define ULOAD(x)	probeget((paddr_t)(u_long)&(x), ASI_AIUS, sizeof(x))	
d85 1
a85 1
			}	
d112 1
a112 1
	
d128 1
a128 1
		
d132 1
a132 1
		
d139 1
a139 1
		
d180 1
a180 1
void 
d185 1
a185 1
	db_printf("frame64 %p locals, ins:\n", f);		
d198 1
a198 1
			  (unsigned long long)f->fr_arg[0],	
d203 1
a203 1
			  (unsigned long long)f->fr_arg[4],	
d236 1
a236 1
		db_printf("\n");	 
d311 1
a311 1
	db_printf("y: %x\tpil: %d\toldpil: %d\tfault: %llx\tkstack: %llx\ttt: %x\nGlobals:\n", 
@


1.10
log
@Do not use USRSTACK when VM_MIN_KERNEL_ADDRESS is what you really mean.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.9 2007/08/15 20:10:08 kettenis Exp $	*/
d59 2
a60 6
db_stack_trace_print(addr, have_addr, count, modif, pr)
	db_expr_t       addr;
	int             have_addr;
	db_expr_t       count;
	char            *modif;
	int		(*pr)(const char *, ...);
d94 5
a104 1
		struct frame32  *f32;
d109 5
a113 11
		if (frame & 1) {
			f64 = (struct frame64 *)(frame + BIAS);
			pc = (db_addr_t)KLOAD(f64->fr_pc);
		
			frame = KLOAD(f64->fr_fp);
		} else {
			f32 = (struct frame32 *)(frame);
			pc = (db_addr_t)KLOAD(f32->fr_pc);
		
			frame = (long)KLOAD(f32->fr_fp);
		}
d134 5
d144 4
a147 11
		if (frame & 1) {
			f64 = (struct frame64 *)(frame + BIAS);
			for (i = 0; i < 5; i++)
				(*pr)("%lx, ", (long)KLOAD(f64->fr_arg[i]));
			(*pr)("%lx) at ", (long)KLOAD(f64->fr_arg[i]));
		} else {
			f32 = (struct frame32 *)(frame);
			for (i = 0; i < 5; i++)
				(*pr)("%x, ", (u_int)KLOAD(f32->fr_arg[i]));
			(*pr)("%x) at ", (u_int)KLOAD(f32->fr_arg[i]));
		}
d155 1
a155 5
db_dump_window(addr, have_addr, count, modif)
	db_expr_t addr;
	int have_addr;
	db_expr_t count;
	char *modif;
d165 9
a173 4
	for (i=0; i<addr && frame; i++) {
		if (frame & 1) 
			frame = (u_int64_t)((struct frame64 *)(u_long)(frame + BIAS))->fr_fp;
		else frame = (u_int64_t)((struct frame32 *)(u_long)frame)->fr_fp;
d181 1
a181 2
db_print_window(frame)
u_int64_t frame;
d183 1
a183 30
	if (frame & 1) {
		struct frame64* f = (struct frame64*)(u_long)(frame + BIAS);

		db_printf("frame64 %p locals, ins:\n", f);		
		if (INKERNEL(f)) {
			db_printf("%llx %llx %llx %llx ",
				  (unsigned long long)f->fr_local[0],
				  (unsigned long long)f->fr_local[1],
				  (unsigned long long)f->fr_local[2],
				  (unsigned long long)f->fr_local[3]);
			db_printf("%llx %llx %llx %llx\n",
				  (unsigned long long)f->fr_local[4],
				  (unsigned long long)f->fr_local[5],
				  (unsigned long long)f->fr_local[6],
				  (unsigned long long)f->fr_local[7]);
			db_printf("%llx %llx %llx %llx ",
				  (unsigned long long)f->fr_arg[0],	
				  (unsigned long long)f->fr_arg[1],
				  (unsigned long long)f->fr_arg[2],
				  (unsigned long long)f->fr_arg[3]);
			db_printf("%llx %llx %llx=sp %llx=pc:",
				  (unsigned long long)f->fr_arg[4],	
				  (unsigned long long)f->fr_arg[5],
				  (unsigned long long)f->fr_fp,
				  (unsigned long long)f->fr_pc);
			/* Sometimes this don't work.  Dunno why. */
			db_printsym(f->fr_pc, DB_STGY_PROC, db_printf);
			db_printf("\n");
		} else {
			struct frame64 fr;
d185 25
a209 18
			if (copyin(f, &fr, sizeof(fr))) return;
			f = &fr;
			db_printf("%llx %llx %llx %llx ",
				  (unsigned long long)f->fr_local[0], (unsigned long long)f->fr_local[1], (unsigned long long)f->fr_local[2], (unsigned long long)f->fr_local[3]);
			db_printf("%llx %llx %llx %llx\n",
				  (unsigned long long)f->fr_local[4], (unsigned long long)f->fr_local[5], (unsigned long long)f->fr_local[6], (unsigned long long)f->fr_local[7]);
			db_printf("%llx %llx %llx %llx ",
				  (unsigned long long)f->fr_arg[0],
				  (unsigned long long)f->fr_arg[1],
				  (unsigned long long)f->fr_arg[2],
				  (unsigned long long)f->fr_arg[3]);
			db_printf("%llx %llx %llx=sp %llx=pc",
				  (unsigned long long)f->fr_arg[4],
				  (unsigned long long)f->fr_arg[5],
				  (unsigned long long)f->fr_fp,
				  (unsigned long long)f->fr_pc);
			db_printf("\n");	 
		}
d211 1
a211 14
		struct frame32* f = (struct frame32*)(u_long)frame;

		db_printf("frame %p locals, ins:\n", f);
		if (INKERNEL(f)) {
			db_printf("%8x %8x %8x %8x %8x %8x %8x %8x\n",
				  f->fr_local[0], f->fr_local[1], f->fr_local[2], f->fr_local[3],
				  f->fr_local[4], f->fr_local[5], f->fr_local[6], f->fr_local[7]);
			db_printf("%8x %8x %8x %8x %8x %8x %8x=sp %8x=pc:",
				  f->fr_arg[0], f->fr_arg[1], f->fr_arg[2], f->fr_arg[3],
				  f->fr_arg[4], f->fr_arg[5], f->fr_fp, f->fr_pc);
			db_printsym(f->fr_pc, DB_STGY_PROC, db_printf);
			db_printf("\n");
		} else {
			struct frame32 fr;
d213 24
a236 13
			if (copyin(f, &fr, sizeof(fr))) return;
			f = &fr;
			db_printf("%8x %8x %8x %8x %8x %8x %8x %8x\n",
				  f->fr_local[0], f->fr_local[1], 
				  f->fr_local[2], f->fr_local[3],
				  f->fr_local[4], f->fr_local[5], 
				  f->fr_local[6], f->fr_local[7]);
			db_printf("%8x %8x %8x %8x %8x %8x %8x=sp %8x=pc\n",
				  f->fr_arg[0], f->fr_arg[1], 
				  f->fr_arg[2], f->fr_arg[3],
				  f->fr_arg[4], f->fr_arg[5], 
				  f->fr_fp, f->fr_pc);
		}
d241 1
a241 5
db_dump_stack(addr, have_addr, count, modif)
	db_expr_t addr;
	int have_addr;
	db_expr_t count;
	char *modif;
d262 1
a262 1
	for (i=0; i<count && frame; i++) {
d264 1
a264 2
			db_printf("WARNING: stack loop at %llx\n",
			    (unsigned long long) frame);
d268 4
a271 21
		if (frame & 1) {
			frame += BIAS;
			if (!INKERNEL(((struct frame64 *)(u_long)(frame)))
			    && kernel_only) break;
			db_printf("Window %x ", i);
			db_print_window(frame - BIAS);
			if (!INKERNEL(((struct frame64 *)(u_long)(frame))))
				copyin(((caddr_t)&((struct frame64 *)(u_long)frame)->fr_fp), &frame, sizeof(frame));
			else
				frame = ((struct frame64 *)(u_long)frame)->fr_fp;
		} else {
			u_int32_t tmp;
			if (!INKERNEL(((struct frame32 *)(u_long)frame))
			    && kernel_only) break;
			db_printf("Window %x ", i);
			db_print_window(frame);
			if (!INKERNEL(((struct frame32 *)(u_long)frame))) {
				copyin(&((struct frame32 *)(u_long)frame)->fr_fp, &tmp, sizeof(tmp));
				frame = (u_int64_t)tmp;
			} else
				frame = (u_int64_t)((struct frame32 *)(u_long)frame)->fr_fp;
d273 11
d290 1
a290 5
db_dump_trap(addr, have_addr, count, modif)
	db_expr_t addr;
	int have_addr;
	db_expr_t count;
	char *modif;
d359 4
a362 2
			  (int64_t)kstack->rw_local[0], (int64_t)kstack->rw_local[1],
			  (int64_t)kstack->rw_local[2], (int64_t)kstack->rw_local[3]);
d364 4
a367 2
			  (int64_t)kstack->rw_local[4], (int64_t)kstack->rw_local[5],
			  (int64_t)kstack->rw_local[6], (int64_t)kstack->rw_local[7]);
d373 1
a373 5
db_dump_fpstate(addr, have_addr, count, modif)
	db_expr_t addr;
	int have_addr;
	db_expr_t count;
	char *modif;
d461 1
a461 5
db_dump_ts(addr, have_addr, count, modif)
	db_expr_t addr;
	int have_addr;
	db_expr_t count;
	char *modif;
d469 1
a469 1
	for (i=0; i<tl; i++) {
@


1.9
log
@Kernel stacks can live beyond EINTSTACK now.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.8 2006/11/29 12:24:17 miod Exp $	*/
d50 1
a50 1
#define INKERNEL(va)	(((vaddr_t)(va)) >= USRSTACK) /* Not really true, y'know */
@


1.8
log
@Kernel stack can be swapped. This means that stuff that's on the stack
should never be referenced outside the context of the process to which
this stack belongs unless we do the PHOLD/PRELE dance. Loads of code
doesn't follow the rules here. Instead of trying to track down all
offenders and fix this hairy situation, it makes much more sense
to not swap kernel stacks.

From art@@, tested by many some time ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.7 2002/10/09 21:10:48 deraadt Exp $	*/
d124 1
a124 1
			if (frame < KERNBASE || frame >= EINTSTACK)
@


1.7
log
@pretty print
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.6 2002/05/18 09:49:17 art Exp $	*/
a89 4
			if ((p->p_flag & P_INMEM) == 0) {
				(*pr)("swapped out\n");
				return;
			}
@


1.6
log
@Rename the MD db_stack_trace_cmd to db_stack_trace_print. Add an argument
that specifies which printf funciton it should use. Implement
db_stack_trace_cmd in MI code.

Thanks to miod@@ for all the tests.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.5 2002/05/16 13:01:41 art Exp $	*/
d362 1
a362 1
	db_printf("y: %x\tpil: %d\toldpil: %d\tfault: %llx\tkstack: %llx\ttt: %x\tGlobals:\n", 
@


1.5
log
@Add a an argument to db_printsym that specifies the printf function
we'll use for printing the information.
miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.4 2002/03/14 03:16:01 millert Exp $	*/
d59 1
a59 1
db_stack_trace_cmd(addr, have_addr, count, modif)
d64 1
a69 3
	int		(*pr)(const char *, ...);

	pr = db_printf;
@


1.4
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.3 2002/03/14 01:26:45 millert Exp $	*/
d162 1
a162 1
		db_printsym(pc, DB_STGY_PROC);
d223 1
a223 1
			db_printsym(f->fr_pc, DB_STGY_PROC);
d257 1
a257 1
			db_printsym(f->fr_pc, DB_STGY_PROC);
@


1.3
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.2 2001/08/20 20:23:53 jason Exp $	*/
d529 1
a529 1
		       (void*)(u_long)ts[i].tpc, (void*)(u_long)ts[i].tnpc);
@


1.2
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d42 6
a47 6
void db_dump_fpstate __P((db_expr_t, int, db_expr_t, char *));
void db_dump_window __P((db_expr_t, int, db_expr_t, char *));
void db_dump_stack __P((db_expr_t, int, db_expr_t, char *));
void db_dump_trap __P((db_expr_t, int, db_expr_t, char *));
void db_dump_ts __P((db_expr_t, int, db_expr_t, char *));
void db_print_window __P((u_int64_t));
d69 1
a69 1
	int		(*pr) __P((const char *, ...));
@


1.2.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.2 2001/08/20 20:23:53 jason Exp $	*/
d42 6
a47 6
void db_dump_fpstate(db_expr_t, int, db_expr_t, char *);
void db_dump_window(db_expr_t, int, db_expr_t, char *);
void db_dump_stack(db_expr_t, int, db_expr_t, char *);
void db_dump_trap(db_expr_t, int, db_expr_t, char *);
void db_dump_ts(db_expr_t, int, db_expr_t, char *);
void db_print_window(u_int64_t);
d59 1
a59 1
db_stack_trace_print(addr, have_addr, count, modif, pr)
a63 1
	int		(*pr)(const char *, ...);
d69 3
d162 1
a162 1
		db_printsym(pc, DB_STGY_PROC, pr);
d223 1
a223 1
			db_printsym(f->fr_pc, DB_STGY_PROC, db_printf);
d257 1
a257 1
			db_printsym(f->fr_pc, DB_STGY_PROC, db_printf);
d529 1
a529 1
		       (void *)(u_long)ts[i].tpc, (void *)(u_long)ts[i].tnpc);
@


1.2.6.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.2.6.1 2002/06/11 03:38:43 art Exp $	*/
d362 1
a362 1
	db_printf("y: %x\tpil: %d\toldpil: %d\tfault: %llx\tkstack: %llx\ttt: %x\nGlobals:\n", 
@


1.2.4.1
log
@Sync the SMP branch to something just after 3.0
@
text
@@


1.2.4.2
log
@Merge in -current from about a week ago
@
text
@d42 6
a47 6
void db_dump_fpstate(db_expr_t, int, db_expr_t, char *);
void db_dump_window(db_expr_t, int, db_expr_t, char *);
void db_dump_stack(db_expr_t, int, db_expr_t, char *);
void db_dump_trap(db_expr_t, int, db_expr_t, char *);
void db_dump_ts(db_expr_t, int, db_expr_t, char *);
void db_print_window(u_int64_t);
d69 1
a69 1
	int		(*pr)(const char *, ...);
d529 1
a529 1
		       (void *)(u_long)ts[i].tpc, (void *)(u_long)ts[i].tnpc);
@


1.2.4.3
log
@Sync the SMP branch with 3.3
@
text
@d59 1
a59 1
db_stack_trace_print(addr, have_addr, count, modif, pr)
a63 1
	int		(*pr)(const char *, ...);
d69 3
d162 1
a162 1
		db_printsym(pc, DB_STGY_PROC, pr);
d223 1
a223 1
			db_printsym(f->fr_pc, DB_STGY_PROC, db_printf);
d257 1
a257 1
			db_printsym(f->fr_pc, DB_STGY_PROC, db_printf);
d364 1
a364 1
	db_printf("y: %x\tpil: %d\toldpil: %d\tfault: %llx\tkstack: %llx\ttt: %x\nGlobals:\n", 
@


1.1
log
@db_trace from NetBSD.
minimal mods to fit our ddb.
@
text
@d1 1
@

