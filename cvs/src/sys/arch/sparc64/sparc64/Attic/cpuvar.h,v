head	1.7;
access;
symbols
	OPENBSD_4_2:1.6.0.8
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.6
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.4
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.6.0.2
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.5.0.8
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.6
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.4
	OPENBSD_3_6_BASE:1.5
	SMP_SYNC_A:1.5
	SMP_SYNC_B:1.5
	OPENBSD_3_5:1.5.0.2
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.4.0.6
	OPENBSD_3_4_BASE:1.4
	UBC_SYNC_A:1.4
	OPENBSD_3_3:1.4.0.4
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.3.0.2
	OPENBSD_3_1_BASE:1.3
	UBC_SYNC_B:1.4
	UBC:1.2.0.6
	UBC_BASE:1.2
	SMP:1.2.0.4
	OPENBSD_3_0:1.2.0.2
	OPENBSD_3_0_BASE:1.2;
locks; strict;
comment	@ * @;


1.7
date	2007.09.09.10.17.33;	author kettenis;	state dead;
branches;
next	1.6;

1.6
date	2005.09.08.15.25.55;	author martin;	state Exp;
branches;
next	1.5;

1.5
date	2003.11.03.07.01.33;	author david;	state Exp;
branches;
next	1.4;

1.4
date	2002.06.15.17.23.31;	author art;	state Exp;
branches;
next	1.3;

1.3
date	2002.03.14.01.26.45;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2001.08.20.20.23.53;	author jason;	state Exp;
branches
	1.2.4.1
	1.2.6.1;
next	1.1;

1.1
date	2001.08.19.05.21.38;	author jason;	state Exp;
branches;
next	;

1.2.4.1
date	2001.10.31.03.07.58;	author nate;	state Exp;
branches;
next	1.2.4.2;

1.2.4.2
date	2002.03.28.11.23.52;	author niklas;	state Exp;
branches;
next	1.2.4.3;

1.2.4.3
date	2003.03.27.23.42.37;	author niklas;	state Exp;
branches;
next	1.2.4.4;

1.2.4.4
date	2004.02.19.10.50.00;	author niklas;	state Exp;
branches;
next	;

1.2.6.1
date	2002.06.11.03.38.43;	author art;	state Exp;
branches;
next	1.2.6.2;

1.2.6.2
date	2002.10.29.00.28.12;	author art;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Remove some more goo left over from sparc.
@
text
@/*	$OpenBSD: cpuvar.h,v 1.6 2005/09/08 15:25:55 martin Exp $	*/
/*	$NetBSD: cpuvar.h,v 1.2 1999/11/06 20:18:13 eeh Exp $ */

/*
 *  Copyright (c) 1996 The NetBSD Foundation, Inc.
 *  All rights reserved.
 *
 *  This code is derived from software contributed to The NetBSD Foundation
 *  by Paul Kranenburg.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *  1. Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *  3. All advertising materials mentioning features or use of this software
 *     must display the following acknowledgement:
 *         This product includes software developed by the NetBSD
 *         Foundation, Inc. and its contributors.
 *  4. Neither the name of The NetBSD Foundation nor the names of its
 *     contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 *  ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 *  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 *  PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 *  BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 *  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 *  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 *  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 *  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef _sparc64_cpuvar_h
#define _sparc64_cpuvar_h

#include <sys/device.h>

#include <sparc64/sparc64/cache.h>	/* for cacheinfo */

/*
 * The cpu_softc structure. This structure maintains information about one
 * currently installed CPU (there may be several of these if the machine
 * supports multiple CPUs). The information in this structure supersedes the
 * old "cpumod", "mmumod", and similar fields.
 */

struct cpu_softc {
	struct device	dv;		/* generic device info */

	int		node;		/* PROM node for this CPU */

	/* CPU information */
	int		id;		/* Module ID for MP systems */
	int		bus;		/* 1 if CPU is on MBus */

/* XXX - of these, we currently use only cpu_type */
	int		arch;		/* Architecture: CPU_SUN4x */

	int		hz;		/* Clock speed */

	/* Cache information */
	struct cacheinfo	cacheinfo;	/* see cache.h */

	/*
	 * The following pointers point to processes that are somehow
	 * associated with this CPU--running on it, using its FPU,
	 * etc.
	 *
	 * XXXMP: much more needs to go here
	 */
	struct	proc 	*fpproc;		/* FPU owner */
};

/*
 * CPU architectures
 */
#define CPUARCH_UNKNOWN		0
#define CPUARCH_SUN4		1
#define CPUARCH_SUN4C		2
#define CPUARCH_SUN4M		3
#define	CPUARCH_SUN4D		4
#define CPUARCH_SUN4U		5

/*
 * CPU classes
 */
#define CPUCLS_UNKNOWN		0

/*
 * CPU busses
 */

#define CPU_NONE		0	/* No particular bus */
#define CPU_UPA			2	/* UPA bus attached */

/*
 * Related function prototypes
 */
void getcpuinfo(struct cpu_softc *sc, int node);
void mmu_install_tables(struct cpu_softc *);
void pmap_alloc_cpu(struct cpu_softc *);

#define cpuinfo	(*(struct cpu_softc *)CPUINFO_VA)

struct cpu_softc	**cpu_info;

#endif	/* _sparc_cpuvar_h */
@


1.6
log
@make comments match the fact that we are on sun4u, plus minor cleanup

ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpuvar.h,v 1.5 2003/11/03 07:01:33 david Exp $	*/
@


1.5
log
@spelling fixes (in the comments)
@
text
@d1 1
a1 1
/*	$OpenBSD: cpuvar.h,v 1.4 2002/06/15 17:23:31 art Exp $	*/
d50 2
a51 3
 * supports multiple CPUs, as on some Sun4m architectures). The information
 * in this structure supersedes the old "cpumod", "mmumod", and similar
 * fields.
@


1.4
log
@Decruftification.

We will never have a.out kernels.
We will never have 32-bit kernels.
We will never have sun4c, sun4 and sun4m support in the sparc64 kernels.
We don't need support old netbsd libc.
The cpu will never be identified as some of the sun4c and sun4m types.
We don't need the gazillion of fields in cpuinfo that the sparc port uses.
Just generally remove dead code.

This is just a first step in making this meess readable.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpuvar.h,v 1.3 2002/03/14 01:26:45 millert Exp $	*/
d51 1
a51 1
 * in this structure supercedes the old "cpumod", "mmumod", and similar
@


1.3
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: cpuvar.h,v 1.2 2001/08/20 20:23:53 jason Exp $	*/
a47 29
 * CPU/MMU module information.
 * There is one of these for each "mainline" CPU module we support.
 * The information contained in the structure is used only during
 * auto-configuration of the CPUs; some fields are copied into the
 * per-cpu data structure (cpu_softc) for easy access during normal
 * operation.
 */
struct cpu_softc;
struct module_info {
	int  cpu_type;
	enum vactype vactype;
	void (*cpu_match)(struct cpu_softc *, struct module_info *, int);
	void (*getcacheinfo)(struct cpu_softc *sc, int node);
	void (*hotfix)(struct cpu_softc *);
	void (*mmu_enable)(void);
	void (*cache_enable)(void);
	int  ncontext;			/* max. # of contexts (we use) */

	void (*get_faultstatus)(void);
	void (*cache_flush)(caddr_t, u_int);
	void (*vcache_flush_page)(int);
	void (*vcache_flush_segment)(int, int);
	void (*vcache_flush_region)(int);
	void (*vcache_flush_context)(void);
	void (*pcache_flush_line)(int, int);
};


/*
a60 7
	char		*cpu_name;	/* CPU model */
	int		cpu_impl;	/* CPU implementation code */
	int		cpu_vers;	/* CPU version code */
	int		mmu_impl;	/* MMU implementation code */
	int		mmu_vers;	/* MMU version code */
	int		master;		/* 1 if this is bootup CPU */

a62 25
	int		mxcc;		/* 1 if a MBus-level MXCC is present */

	caddr_t		mailbox;	/* VA of CPU's mailbox */


	int		mmu_ncontext;	/* Number of contexts supported */
	int		mmu_nregion; 	/* Number of regions supported */
	int		mmu_nsegment;	/* [4/4c] Segments */
	int		mmu_npmeg;	/* [4/4c] Pmegs */
	int		sun4_mmu3l;	/* [4]: 3-level MMU present */
#if defined(SUN4_MMU3L)
#define HASSUN4_MMU3L	(cpuinfo.sun4_mmu3l)
#else
#define HASSUN4_MMU3L	(0)
#endif

	/* Context administration */
	int		*ctx_tbl;	/* [4m] SRMMU-edible context table */
	union ctxinfo	*ctxinfo;
	union ctxinfo	*ctx_freelist;  /* context free list */
	int		ctx_kick;	/* allocation rover when none free */
	int		ctx_kickdir;	/* ctx_kick roves both directions */

	/* MMU tables that map `cpuinfo'' on each CPU */
	int		*L1_ptps;	/* XXX */
a65 4
	int		class;		/* Class: SuperSPARC, microSPARC... */
	int		classlvl;	/* Iteration in class: 1, 2, etc. */
	int		classsublvl;	/* stepping in class (version) */
	int		cpu_type;	/* Type: see CPUTYP_xxx below */
a71 10
	/* FPU information */
	int		fpupresent;	/* true if FPU is present */
	int		fpuvers;	/* FPU revision */

	/* various flags to workaround anomalies in chips */
	int		flags;		/* see CPUFLG_xxx, below */

	/* Per processor counter register (sun4m only) */
	struct counter_4m	*counterreg_4m;

a79 35

	/*
	 * The following are function pointers to do interesting CPU-dependent
	 * things without having to do type-tests all the time
	 */

	/* bootup things: access to physical memory */
	u_int	(*read_physmem)(u_int addr, int space);
	void	(*write_physmem)(u_int addr, u_int data);
	void	(*cache_tablewalks)(void);
	void	(*mmu_enable)(void);
	void	(*hotfix)(struct cpu_softc *);

	/* locore defined: */
	void	(*get_faultstatus)(void);

	/* Cache handling functions */
	void	(*cache_enable)(void);
	void	(*cache_flush)(caddr_t, u_int);
	void	(*vcache_flush_page)(int);
	void	(*vcache_flush_segment)(int, int);
	void	(*vcache_flush_region)(int);
	void	(*vcache_flush_context)(void);
	void	(*pcache_flush_line)(int, int);

#ifdef SUN4M
	/* hardware-assisted block operation routines */
	void		(*hwbcopy)(const void *from, void *to, size_t len);
	void		(*hwbzero)(void *buf, size_t len);

	/* routine to clear mbus-sbus buffers */
	void		(*mbusflush)(void);
#endif

	/* XXX: Add more here! */
a96 14
#if defined(SUN4)
#define CPUCLS_SUN4		1
#endif

#if defined(SUN4C)
#define CPUCLS_SUN4C		5
#endif

#if defined(SUN4M)
#define CPUCLS_MICROSPARC	10	/* MicroSPARC-II */
#define CPUCLS_SUPERSPARC	11	/* Generic SuperSPARC */
#define CPUCLS_HYPERSPARC	12	/* Ross HyperSPARC RT620 */
#endif

a101 1
#define CPU_MBUS		1	/* SBUS attached */
a102 44

/*
 * CPU types. Each of these should uniquely identify one platform/type of
 * system, i.e. "MBus-based 75 MHz SuperSPARC-II with ECache" is
 * CPUTYP_SS2_MBUS_MXCC. The general form is
 * 	CPUTYP_proctype_bustype_cachetype_etc_etc
 *
 * XXX: This is far from complete/comprehensive
 * XXX: ADD SUN4, SUN4C TYPES
 */
#define CPUTYP_UNKNOWN		0

#define CPUTYP_4_100		1 	/* Sun4/100 */
#define CPUTYP_4_200		2	/* Sun4/200 */
#define CPUTYP_4_300		3	/* Sun4/300 */
#define CPUTYP_4_400		4	/* Sun4/400 */

#define CPUTYP_SLC		10	/* SPARCstation SLC */
#define CPUTYP_ELC		11	/* SPARCstation ELC */
#define CPUTYP_IPX		12	/* SPARCstation IPX */
#define CPUTYP_IPC		13	/* SPARCstation IPC */
#define CPUTYP_1		14	/* SPARCstation 1 */
#define CPUTYP_1P		15	/* SPARCstation 1+ */
#define CPUTYP_2		16	/* SPARCstation 2 */

/* We classify the Sun4m's by feature, not by model (XXX: do same for 4/4c) */
#define	CPUTYP_SS2_MBUS_MXCC	20 	/* SuperSPARC-II, Mbus, MXCC (SS20) */
#define CPUTYP_SS1_MBUS_MXCC	21	/* SuperSPARC-I, Mbus, MXCC (SS10) */
#define CPUTYP_SS2_MBUS_NOMXCC	22	/* SuperSPARC-II, on MBus w/o MXCC */
#define CPUTYP_SS1_MBUS_NOMXCC	23	/* SuperSPARC-I, on MBus w/o MXCC */
#define CPUTYP_MS2		24	/* MicroSPARC-2 */
#define CPUTYP_MS1		25 	/* MicroSPARC-1 */
#define CPUTYP_HS_MBUS		26	/* MBus-based HyperSPARC */
#define CPUTYP_CYPRESS		27	/* MBus-based Cypress */

/*
 * CPU flags
 */
#define CPUFLG_CACHEPAGETABLES	0x1	/* caching pagetables OK on Sun4m */
#define CPUFLG_CACHEIOMMUTABLES	0x2	/* caching IOMMU translations OK */
#define CPUFLG_CACHEDVMA	0x4	/* DVMA goes through cache */
#define CPUFLG_SUN4CACHEBUG	0x8	/* trap page can't be cached */
#define CPUFLG_CACHE_MANDATORY	0x10	/* if cache is on, don't use
					   uncached access */
@


1.2
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d59 5
a63 5
	void (*cpu_match)__P((struct cpu_softc *, struct module_info *, int));
	void (*getcacheinfo)__P((struct cpu_softc *sc, int node));
	void (*hotfix) __P((struct cpu_softc *));
	void (*mmu_enable)__P((void));
	void (*cache_enable)__P((void));
d66 7
a72 7
	void (*get_faultstatus)__P((void));
	void (*cache_flush)__P((caddr_t, u_int));
	void (*vcache_flush_page)__P((int));
	void (*vcache_flush_segment)__P((int, int));
	void (*vcache_flush_region)__P((int));
	void (*vcache_flush_context)__P((void));
	void (*pcache_flush_line)__P((int, int));
d162 5
a166 5
	u_int	(*read_physmem) __P((u_int addr, int space));
	void	(*write_physmem) __P((u_int addr, u_int data));
	void	(*cache_tablewalks) __P((void));
	void	(*mmu_enable) __P((void));
	void	(*hotfix) __P((struct cpu_softc *));
d169 1
a169 1
	void	(*get_faultstatus) __P((void));
d172 7
a178 7
	void	(*cache_enable) __P((void));
	void	(*cache_flush)__P((caddr_t, u_int));
	void	(*vcache_flush_page)__P((int));
	void	(*vcache_flush_segment)__P((int, int));
	void	(*vcache_flush_region)__P((int));
	void	(*vcache_flush_context)__P((void));
	void	(*pcache_flush_line)__P((int, int));
d182 2
a183 3
	void		(*hwbcopy)
				__P((const void *from, void *to, size_t len));
	void		(*hwbzero) __P((void *buf, size_t len));
d186 1
a186 1
	void		(*mbusflush) __P((void));
d276 3
a278 3
void getcpuinfo __P((struct cpu_softc *sc, int node));
void mmu_install_tables __P((struct cpu_softc *));
void pmap_alloc_cpu __P((struct cpu_softc *));
@


1.2.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cpuvar.h,v 1.2 2001/08/20 20:23:53 jason Exp $	*/
d59 5
a63 5
	void (*cpu_match)(struct cpu_softc *, struct module_info *, int);
	void (*getcacheinfo)(struct cpu_softc *sc, int node);
	void (*hotfix)(struct cpu_softc *);
	void (*mmu_enable)(void);
	void (*cache_enable)(void);
d66 7
a72 7
	void (*get_faultstatus)(void);
	void (*cache_flush)(caddr_t, u_int);
	void (*vcache_flush_page)(int);
	void (*vcache_flush_segment)(int, int);
	void (*vcache_flush_region)(int);
	void (*vcache_flush_context)(void);
	void (*pcache_flush_line)(int, int);
d162 5
a166 5
	u_int	(*read_physmem)(u_int addr, int space);
	void	(*write_physmem)(u_int addr, u_int data);
	void	(*cache_tablewalks)(void);
	void	(*mmu_enable)(void);
	void	(*hotfix)(struct cpu_softc *);
d169 1
a169 1
	void	(*get_faultstatus)(void);
d172 7
a178 7
	void	(*cache_enable)(void);
	void	(*cache_flush)(caddr_t, u_int);
	void	(*vcache_flush_page)(int);
	void	(*vcache_flush_segment)(int, int);
	void	(*vcache_flush_region)(int);
	void	(*vcache_flush_context)(void);
	void	(*pcache_flush_line)(int, int);
d182 3
a184 2
	void		(*hwbcopy)(const void *from, void *to, size_t len);
	void		(*hwbzero)(void *buf, size_t len);
d187 1
a187 1
	void		(*mbusflush)(void);
d277 3
a279 3
void getcpuinfo(struct cpu_softc *sc, int node);
void mmu_install_tables(struct cpu_softc *);
void pmap_alloc_cpu(struct cpu_softc *);
@


1.2.6.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cpuvar.h,v 1.2.6.1 2002/06/11 03:38:43 art Exp $	*/
d48 29
d90 7
d99 25
d127 4
d137 10
d155 35
d207 14
d226 1
d228 44
@


1.2.4.1
log
@Sync the SMP branch to something just after 3.0
@
text
@@


1.2.4.2
log
@Merge in -current from about a week ago
@
text
@d59 5
a63 5
	void (*cpu_match)(struct cpu_softc *, struct module_info *, int);
	void (*getcacheinfo)(struct cpu_softc *sc, int node);
	void (*hotfix)(struct cpu_softc *);
	void (*mmu_enable)(void);
	void (*cache_enable)(void);
d66 7
a72 7
	void (*get_faultstatus)(void);
	void (*cache_flush)(caddr_t, u_int);
	void (*vcache_flush_page)(int);
	void (*vcache_flush_segment)(int, int);
	void (*vcache_flush_region)(int);
	void (*vcache_flush_context)(void);
	void (*pcache_flush_line)(int, int);
d162 5
a166 5
	u_int	(*read_physmem)(u_int addr, int space);
	void	(*write_physmem)(u_int addr, u_int data);
	void	(*cache_tablewalks)(void);
	void	(*mmu_enable)(void);
	void	(*hotfix)(struct cpu_softc *);
d169 1
a169 1
	void	(*get_faultstatus)(void);
d172 7
a178 7
	void	(*cache_enable)(void);
	void	(*cache_flush)(caddr_t, u_int);
	void	(*vcache_flush_page)(int);
	void	(*vcache_flush_segment)(int, int);
	void	(*vcache_flush_region)(int);
	void	(*vcache_flush_context)(void);
	void	(*pcache_flush_line)(int, int);
d182 3
a184 2
	void		(*hwbcopy)(const void *from, void *to, size_t len);
	void		(*hwbzero)(void *buf, size_t len);
d187 1
a187 1
	void		(*mbusflush)(void);
d277 3
a279 3
void getcpuinfo(struct cpu_softc *sc, int node);
void mmu_install_tables(struct cpu_softc *);
void pmap_alloc_cpu(struct cpu_softc *);
@


1.2.4.3
log
@Sync the SMP branch with 3.3
@
text
@d48 29
d90 7
d99 25
d127 4
d137 10
d155 35
d207 14
d226 1
d228 44
@


1.2.4.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d51 1
a51 1
 * in this structure supersedes the old "cpumod", "mmumod", and similar
@


1.1
log
@Lot of stuff... Some from NetBSD, some from OpenBSD, minor modifications
@
text
@d1 1
@

