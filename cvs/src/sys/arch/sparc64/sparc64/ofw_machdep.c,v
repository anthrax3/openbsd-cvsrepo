head	1.33;
access;
symbols
	OPENBSD_6_2:1.33.0.8
	OPENBSD_6_2_BASE:1.33
	OPENBSD_6_1:1.33.0.6
	OPENBSD_6_1_BASE:1.33
	OPENBSD_6_0:1.33.0.2
	OPENBSD_6_0_BASE:1.33
	OPENBSD_5_9:1.32.0.4
	OPENBSD_5_9_BASE:1.32
	OPENBSD_5_8:1.32.0.6
	OPENBSD_5_8_BASE:1.32
	OPENBSD_5_7:1.32.0.2
	OPENBSD_5_7_BASE:1.32
	OPENBSD_5_6:1.31.0.26
	OPENBSD_5_6_BASE:1.31
	OPENBSD_5_5:1.31.0.24
	OPENBSD_5_5_BASE:1.31
	OPENBSD_5_4:1.31.0.20
	OPENBSD_5_4_BASE:1.31
	OPENBSD_5_3:1.31.0.18
	OPENBSD_5_3_BASE:1.31
	OPENBSD_5_2:1.31.0.16
	OPENBSD_5_2_BASE:1.31
	OPENBSD_5_1_BASE:1.31
	OPENBSD_5_1:1.31.0.14
	OPENBSD_5_0:1.31.0.12
	OPENBSD_5_0_BASE:1.31
	OPENBSD_4_9:1.31.0.10
	OPENBSD_4_9_BASE:1.31
	OPENBSD_4_8:1.31.0.8
	OPENBSD_4_8_BASE:1.31
	OPENBSD_4_7:1.31.0.4
	OPENBSD_4_7_BASE:1.31
	OPENBSD_4_6:1.31.0.6
	OPENBSD_4_6_BASE:1.31
	OPENBSD_4_5:1.31.0.2
	OPENBSD_4_5_BASE:1.31
	OPENBSD_4_4:1.28.0.2
	OPENBSD_4_4_BASE:1.28
	OPENBSD_4_3:1.23.0.2
	OPENBSD_4_3_BASE:1.23
	OPENBSD_4_2:1.19.0.2
	OPENBSD_4_2_BASE:1.19
	OPENBSD_4_1:1.16.0.2
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.15.0.2
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.14.0.4
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.14.0.2
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.11.0.4
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.2
	OPENBSD_3_6_BASE:1.11
	SMP_SYNC_A:1.10
	SMP_SYNC_B:1.10
	OPENBSD_3_5:1.9.0.2
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.8.0.2
	OPENBSD_3_4_BASE:1.8
	UBC_SYNC_A:1.8
	OPENBSD_3_3:1.7.0.2
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.6.0.4
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	UBC_SYNC_B:1.6
	UBC:1.3.0.6
	UBC_BASE:1.3
	SMP:1.3.0.4
	OPENBSD_3_0:1.3.0.2
	OPENBSD_3_0_BASE:1.3;
locks; strict;
comment	@ * @;


1.33
date	2016.03.07.13.21.51;	author naddy;	state Exp;
branches;
next	1.32;
commitid	EDvRPKRZUDEEb6oR;

1.32
date	2014.10.17.03.04.30;	author daniel;	state Exp;
branches;
next	1.31;
commitid	fw5iE7DsEpC0biIO;

1.31
date	2009.02.19.11.12.42;	author kettenis;	state Exp;
branches;
next	1.30;

1.30
date	2008.12.30.00.54.24;	author kettenis;	state Exp;
branches;
next	1.29;

1.29
date	2008.08.09.21.06.05;	author kettenis;	state Exp;
branches;
next	1.28;

1.28
date	2008.07.10.08.57.05;	author kettenis;	state Exp;
branches;
next	1.27;

1.27
date	2008.07.07.14.46.18;	author kettenis;	state Exp;
branches;
next	1.26;

1.26
date	2008.07.05.22.17.21;	author kettenis;	state Exp;
branches;
next	1.25;

1.25
date	2008.03.19.20.21.01;	author kettenis;	state Exp;
branches;
next	1.24;

1.24
date	2008.03.08.15.42.26;	author kettenis;	state Exp;
branches;
next	1.23;

1.23
date	2008.01.10.22.46.48;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2008.01.10.22.25.20;	author marco;	state Exp;
branches;
next	1.21;

1.21
date	2007.10.19.15.17.30;	author kettenis;	state Exp;
branches;
next	1.20;

1.20
date	2007.09.08.17.48.12;	author kettenis;	state Exp;
branches;
next	1.19;

1.19
date	2007.07.28.13.22.22;	author kettenis;	state Exp;
branches;
next	1.18;

1.18
date	2007.04.10.14.26.17;	author kettenis;	state Exp;
branches;
next	1.17;

1.17
date	2007.04.06.22.38.14;	author kettenis;	state Exp;
branches;
next	1.16;

1.16
date	2007.01.16.14.39.57;	author tsi;	state Exp;
branches;
next	1.15;

1.15
date	2006.08.31.21.28.35;	author kettenis;	state Exp;
branches;
next	1.14;

1.14
date	2005.07.01.01.12.04;	author brad;	state Exp;
branches;
next	1.13;

1.13
date	2005.06.29.23.48.10;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2005.04.21.00.26.47;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2004.06.15.05.44.45;	author brad;	state Exp;
branches;
next	1.10;

1.10
date	2004.05.17.04.34.46;	author brad;	state Exp;
branches;
next	1.9;

1.9
date	2004.01.07.20.44.56;	author pvalchev;	state Exp;
branches;
next	1.8;

1.8
date	2003.05.10.21.11.14;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2003.01.30.07.53.58;	author henric;	state Exp;
branches;
next	1.6;

1.6
date	2002.03.15.18.19.52;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.03.14.01.26.45;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2002.01.03.22.09.35;	author jason;	state Exp;
branches;
next	1.3;

1.3
date	2001.08.20.20.23.53;	author jason;	state Exp;
branches
	1.3.4.1
	1.3.6.1;
next	1.2;

1.2
date	2001.08.19.19.28.41;	author art;	state Exp;
branches;
next	1.1;

1.1
date	2001.08.19.05.21.38;	author jason;	state Exp;
branches;
next	;

1.3.4.1
date	2001.10.31.03.07.59;	author nate;	state Exp;
branches;
next	1.3.4.2;

1.3.4.2
date	2002.03.06.02.04.47;	author niklas;	state Exp;
branches;
next	1.3.4.3;

1.3.4.3
date	2002.03.28.11.23.52;	author niklas;	state Exp;
branches;
next	1.3.4.4;

1.3.4.4
date	2003.03.27.23.42.37;	author niklas;	state Exp;
branches;
next	1.3.4.5;

1.3.4.5
date	2003.05.13.19.41.09;	author ho;	state Exp;
branches;
next	1.3.4.6;

1.3.4.6
date	2004.02.19.10.50.01;	author niklas;	state Exp;
branches;
next	1.3.4.7;

1.3.4.7
date	2004.06.05.23.11.01;	author niklas;	state Exp;
branches;
next	;

1.3.6.1
date	2002.01.31.22.55.25;	author niklas;	state Exp;
branches;
next	1.3.6.2;

1.3.6.2
date	2002.06.11.03.38.44;	author art;	state Exp;
branches;
next	1.3.6.3;

1.3.6.3
date	2003.05.19.21.46.58;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.33
log
@Sync no-argument function declaration and definition by adding (void).
ok mpi@@
@
text
@/*	$OpenBSD: ofw_machdep.c,v 1.32 2014/10/17 03:04:30 daniel Exp $	*/
/*	$NetBSD: ofw_machdep.c,v 1.16 2001/07/20 00:07:14 eeh Exp $	*/

/*
 * Copyright (C) 1996 Wolfgang Solfrank.
 * Copyright (C) 1996 TooLs GmbH.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by TooLs GmbH.
 * 4. The name of TooLs GmbH may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY TOOLS GMBH ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL TOOLS GMBH BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
#include <sys/param.h>
#include <sys/buf.h>
#include <sys/conf.h>
#include <sys/device.h>
#include <sys/disk.h>
#include <sys/disklabel.h>
#include <sys/fcntl.h>
#include <sys/ioctl.h>
#include <sys/malloc.h>
#include <sys/stat.h>
#include <sys/systm.h>

#include <machine/openfirm.h>

#include <dev/ofw/ofw_pci.h>

#if defined(FFS) && defined(CD9660)
#include <ufs/ffs/fs.h>
#endif

/*
 * Note that stdarg.h and the ANSI style va_start macro is used for both
 * ANSI and traditional C compilers.
 */
#include <sys/stdarg.h>

#include <machine/sparc64.h>

int vsprintf(char *, const char *, va_list);

void dk_cleanup(void);

static u_int mmuh = -1, memh = -1;

static u_int get_mmu_handle(void);
static u_int get_memory_handle(void);

static u_int 
get_mmu_handle(void)
{
	u_int chosen;

	if ((chosen = OF_finddevice("/chosen")) == -1) {
		prom_printf("get_mmu_handle: cannot get /chosen\r\n");
		return -1;
	}
	if (OF_getprop(chosen, "mmu", &mmuh, sizeof(mmuh)) == -1) {
		prom_printf("get_mmu_handle: cannot get mmuh\r\n");
		return -1;
	}
	return mmuh;
}

static u_int 
get_memory_handle(void)
{
	u_int chosen;

	if ((chosen = OF_finddevice("/chosen")) == -1) {
		prom_printf("get_memory_handle: cannot get /chosen\r\n");
		return -1;
	}
	if (OF_getprop(chosen, "memory", &memh, sizeof(memh)) == -1) {
		prom_printf("get_memory_handle: cannot get memh\r\n");
		return -1;
	}
	return memh;
}


/* 
 * Point prom to our trap table.  This stops the prom from mapping us.
 */
int
prom_set_trap_table(tba, mmfsa)
	vaddr_t tba;
	paddr_t mmfsa;
{
	struct {
		cell_t name;
		cell_t nargs;
		cell_t nreturns;
		cell_t tba;
		cell_t mmfsa; 
	} args;

	args.name = ADR2CELL("SUNW,set-trap-table");
	if (CPU_ISSUN4V)
		args.nargs = 2;
	else
		args.nargs = 1;
	args.nreturns = 0;
	args.tba = ADR2CELL(tba);
	args.mmfsa = ADR2CELL(mmfsa);
	return openfirmware(&args);
}

/* 
 * Have the prom convert from virtual to physical addresses.
 *
 * Only works while the prom is actively mapping us.
 */
paddr_t
prom_vtop(vaddr)
	vaddr_t vaddr;
{
	struct {
		cell_t name;
		cell_t nargs;
		cell_t nreturns;
		cell_t method;
		cell_t ihandle;
		cell_t vaddr;
		cell_t status;
		cell_t retaddr;
		cell_t mode;
		cell_t phys_hi;
		cell_t phys_lo;
	} args;

	if (mmuh == -1 && ((mmuh = get_mmu_handle()) == -1)) {
		prom_printf("prom_vtop: cannot get mmuh\r\n");
		return 0;
	}
	args.name = ADR2CELL("call-method");
	args.nargs = 3;
	args.nreturns = 5;
	args.method = ADR2CELL("translate");
	args.ihandle = HDL2CELL(mmuh);
	args.vaddr = ADR2CELL(vaddr);
	if(openfirmware(&args) == -1)
		return -1;
#if 0
	prom_printf("Called \"translate\", mmuh=%x, vaddr=%x, "
		    "status=%x %x,\r\n "
		    "retaddr=%x %x, "
		    "mode=%x %x, "
		    "phys_hi=%x %x, "
		    "phys_lo=%x %x\r\n",
		    mmuh, vaddr,
		    (int)(args.status>>32), (int)args.status,
		    (int)(args.retaddr>>32), (int)args.retaddr, 
		    (int)(args.mode>>32), (int)args.mode,
		    (int)(args.phys_hi>>32), (int)args.phys_hi,
		    (int)(args.phys_lo>>32), (int)args.phys_lo);
#endif
	return (paddr_t)CELL2HDQ(args.phys_hi, args.phys_lo);
}

/* 
 * Grab some address space from the prom
 *
 * Only works while the prom is actively mapping us.
 */
vaddr_t
prom_claim_virt(vaddr, len)
	vaddr_t vaddr;
	int len;
{
	struct {
		cell_t name;
		cell_t nargs;
		cell_t nreturns;
		cell_t method;
		cell_t ihandle;
		cell_t align;
		cell_t len;
		cell_t vaddr;
		cell_t status;
		cell_t retaddr;
	} args;

	if (mmuh == -1 && ((mmuh = get_mmu_handle()) == -1)) {
		prom_printf("prom_claim_virt: cannot get mmuh\r\n");
		return 0;
	}
	args.name = ADR2CELL("call-method");
	args.nargs = 5;
	args.nreturns = 2;
	args.method = ADR2CELL("claim");
	args.ihandle = HDL2CELL(mmuh);
	args.align = 0;
	args.len = len;
	args.vaddr = ADR2CELL(vaddr);
	if (openfirmware(&args) == -1)
		return -1;
	return (paddr_t)args.retaddr;
}

/* 
 * Request some address space from the prom
 *
 * Only works while the prom is actively mapping us.
 */
vaddr_t
prom_alloc_virt(len, align)
	int len;
	int align;
{
	struct {
		cell_t name;
		cell_t nargs;
		cell_t nreturns;
		cell_t method;
		cell_t ihandle;
		cell_t align;
		cell_t len;
		cell_t status;
		cell_t retaddr;
	} args;

	if (mmuh == -1 && ((mmuh = get_mmu_handle()) == -1)) {
		prom_printf("prom_alloc_virt: cannot get mmuh\r\n");
		return -1LL;
	}
	args.name = ADR2CELL("call-method");
	args.nargs = 4;
	args.nreturns = 2;
	args.method = ADR2CELL("claim");
	args.ihandle = HDL2CELL(mmuh);
	args.align = align;
	args.len = len;
	if (openfirmware(&args) != 0)
		return -1;
	return (vaddr_t)args.retaddr;
}

/* 
 * Release some address space to the prom
 *
 * Only works while the prom is actively mapping us.
 */
int
prom_free_virt(vaddr, len)
	vaddr_t vaddr;
	int len;
{
	struct {
		cell_t name;
		cell_t nargs;
		cell_t nreturns;
		cell_t method;
		cell_t ihandle;
		cell_t len;
		cell_t vaddr;
	} args;

	if (mmuh == -1 && ((mmuh = get_mmu_handle()) == -1)) {
		prom_printf("prom_free_virt: cannot get mmuh\r\n");
		return -1;
	}
	args.name = ADR2CELL("call-method");
	args.nargs = 4;
	args.nreturns = 0;
	args.method = ADR2CELL("release");
	args.ihandle = HDL2CELL(mmuh);
	args.vaddr = ADR2CELL(vaddr);
	args.len = len;
	return openfirmware(&args);
}


/* 
 * Unmap some address space
 *
 * Only works while the prom is actively mapping us.
 */
int
prom_unmap_virt(vaddr, len)
	vaddr_t vaddr;
	int len;
{
	struct {
		cell_t name;
		cell_t nargs;
		cell_t nreturns;
		cell_t method;
		cell_t ihandle;
		cell_t len;
		cell_t vaddr;
	} args;

	if (mmuh == -1 && ((mmuh = get_mmu_handle()) == -1)) {
		prom_printf("prom_unmap_virt: cannot get mmuh\r\n");
		return -1;
	}
	args.name = ADR2CELL("call-method");
	args.nargs = 4;
	args.nreturns = 0;
	args.method = ADR2CELL("unmap");
	args.ihandle = HDL2CELL(mmuh);
	args.vaddr = ADR2CELL(vaddr);
	args.len = len;
	return openfirmware(&args);
}

/* 
 * Have prom map in some memory
 *
 * Only works while the prom is actively mapping us.
 */
int
prom_map_phys(paddr, size, vaddr, mode)
	paddr_t paddr;
	off_t size;
	vaddr_t vaddr;
	int mode;
{
	struct {
		cell_t name;
		cell_t nargs;
		cell_t nreturns;
		cell_t method;
		cell_t ihandle;
		cell_t mode;
		cell_t size;
		cell_t vaddr;
		cell_t phys_hi;
		cell_t phys_lo;
		cell_t status;
		cell_t retaddr;
	} args;

	if (mmuh == -1 && ((mmuh = get_mmu_handle()) == -1)) {
		prom_printf("prom_map_phys: cannot get mmuh\r\n");
		return 0;
	}
	args.name = ADR2CELL("call-method");
	args.nargs = 7;
	args.nreturns = 1;
	args.method = ADR2CELL("map");
	args.ihandle = HDL2CELL(mmuh);
	args.mode = mode;
	args.size = size;
	args.vaddr = ADR2CELL(vaddr);
	args.phys_hi = HDQ2CELL_HI(paddr);
	args.phys_lo = HDQ2CELL_LO(paddr);

	if (openfirmware(&args) == -1)
		return -1;
	if (args.status)
		return -1;
	return (int)args.retaddr;
}


/* 
 * Request some RAM from the prom
 *
 * Only works while the prom is actively mapping us.
 */
paddr_t
prom_alloc_phys(len, align)
	int len;
	int align;
{
	struct {
		cell_t name;
		cell_t nargs;
		cell_t nreturns;
		cell_t method;
		cell_t ihandle;
		cell_t align;
		cell_t len;
		cell_t status;
		cell_t phys_hi;
		cell_t phys_lo;
	} args;

	if (memh == -1 && ((memh = get_memory_handle()) == -1)) {
		prom_printf("prom_alloc_phys: cannot get memh\r\n");
		return -1;
	}
	args.name = ADR2CELL("call-method");
	args.nargs = 4;
	args.nreturns = 3;
	args.method = ADR2CELL("claim");
	args.ihandle = HDL2CELL(memh);
	args.align = align;
	args.len = len;
	if (openfirmware(&args) != 0)
		return -1;
	return (paddr_t)CELL2HDQ(args.phys_hi, args.phys_lo);
}

/* 
 * Request some specific RAM from the prom
 *
 * Only works while the prom is actively mapping us.
 */
paddr_t
prom_claim_phys(phys, len)
	paddr_t phys;
	int len;
{
	struct {
		cell_t name;
		cell_t nargs;
		cell_t nreturns;
		cell_t method;
		cell_t ihandle;
		cell_t align;
		cell_t len;
		cell_t phys_hi;
		cell_t phys_lo;
		cell_t status;
		cell_t rphys_hi;
		cell_t rphys_lo;
	} args;

	if (memh == -1 && ((memh = get_memory_handle()) == -1)) {
		prom_printf("prom_claim_phys: cannot get memh\r\n");
		return -1;
	}
	args.name = ADR2CELL("call-method");
	args.nargs = 6;
	args.nreturns = 3;
	args.method = ADR2CELL("claim");
	args.ihandle = HDL2CELL(memh);
	args.align = 0;
	args.len = len;
	args.phys_hi = HDQ2CELL_HI(phys);
	args.phys_lo = HDQ2CELL_LO(phys);
	if (openfirmware(&args) != 0)
		return -1;
	return (paddr_t)CELL2HDQ(args.rphys_hi, args.rphys_lo);
}

/* 
 * Free some RAM to prom
 *
 * Only works while the prom is actively mapping us.
 */
int
prom_free_phys(phys, len)
	paddr_t phys;
	int len;
{
	struct {
		cell_t name;
		cell_t nargs;
		cell_t nreturns;
		cell_t method;
		cell_t ihandle;
		cell_t len;
		cell_t phys_hi;
		cell_t phys_lo;
	} args;

	if (memh == -1 && ((memh = get_memory_handle()) == -1)) {
		prom_printf("prom_free_phys: cannot get memh\r\n");
		return -1;
	}
	args.name = ADR2CELL("call-method");
	args.nargs = 5;
	args.nreturns = 0;
	args.method = ADR2CELL("release");
	args.ihandle = HDL2CELL(memh);
	args.len = len;
	args.phys_hi = HDQ2CELL_HI(phys);
	args.phys_lo = HDQ2CELL_LO(phys);
	return openfirmware(&args);
}

/* 
 * Get the msgbuf from the prom.  Only works once.
 *
 * Only works while the prom is actively mapping us.
 */
paddr_t
prom_get_msgbuf(len, align)
	int len;
	int align;
{
	struct {
		cell_t name;
		cell_t nargs;
		cell_t nreturns;
		cell_t method;
		cell_t ihandle;
		cell_t align;
		cell_t len;
		cell_t id;
		cell_t status;
		cell_t phys_hi;
		cell_t phys_lo;
	} args;
	paddr_t addr;

	if (memh == -1 && ((memh = get_memory_handle()) == -1)) {
		prom_printf("prom_get_msgbuf: cannot get memh\r\n");
		return -1;
	}
	if (OF_test("test-method") == 0) {
		if (OF_test_method(OF_instance_to_package(memh), "SUNW,retain") == 0) {
			args.name = ADR2CELL("call-method");
			args.nargs = 5;
			args.nreturns = 3;
			args.method = ADR2CELL("SUNW,retain");
			args.id = ADR2CELL("msgbuf");
			args.ihandle = HDL2CELL(memh);
			args.len = len;
			args.align = align;
			args.status = -1;
			if (openfirmware(&args) == 0 && args.status == 0)
				return (paddr_t)CELL2HDQ(args.phys_hi, args.phys_lo);
			prom_printf("prom_get_msgbuf: SUNW,retain failed\r\n");
		} else prom_printf("prom_get_msgbuf: test-method failed\r\n");
	} else prom_printf("prom_get_msgbuf: test failed\r\n");
	/* Allocate random memory -- page zero avail?*/
	addr = prom_claim_phys(0x000, len);
	prom_printf("prom_get_msgbuf: allocated new buf at %08x\r\n", (int)addr); 
	if (addr == -1) {
		prom_printf("prom_get_msgbuf: cannot get allocate physmem\r\n");
		return -1;
	}
	prom_printf("prom_get_msgbuf: claiming new buf at %08x\r\n", (int)addr);
	{ int i; for (i=0; i<200000000; i++); }
	return addr; /* Kluge till we go 64-bit */
}

int
prom_itlb_load(int index, u_int64_t data, vaddr_t vaddr)
{
	static struct {
		cell_t name;
		cell_t nargs;
		cell_t nreturns;
		cell_t method;
		cell_t ihandle;
		cell_t vaddr;
		cell_t data;
		cell_t index;
		cell_t status;
	} args;

	if (mmuh == -1 && ((mmuh = get_mmu_handle()) == -1)) {
		prom_printf("prom_itlb_load: cannot get mmuh\r\n");
		return 0;
	}
	args.name = ADR2CELL("call-method");
	args.nargs = 5;
	args.nreturns = 1;
	args.method = ADR2CELL("SUNW,itlb-load");
	args.ihandle = HDL2CELL(mmuh);
	args.vaddr = ADR2CELL(vaddr);
	args.data = data;
	args.index = index;
	if(openfirmware(&args) == -1)
		return -1;
	if (args.status)
		return -1;
	return 0;
}

int
prom_dtlb_load(int index, u_int64_t data, vaddr_t vaddr)
{
	static struct {
		cell_t name;
		cell_t nargs;
		cell_t nreturns;
		cell_t method;
		cell_t ihandle;
		cell_t vaddr;
		cell_t data;
		cell_t index;
		cell_t status;
	} args;

	if (mmuh == -1 && ((mmuh = get_mmu_handle()) == -1)) {
		prom_printf("prom_itlb_load: cannot get mmuh\r\n");
		return 0;
	}
	args.name = ADR2CELL("call-method");
	args.nargs = 5;
	args.nreturns = 1;
	args.method = ADR2CELL("SUNW,dtlb-load");
	args.ihandle = HDL2CELL(mmuh);
	args.vaddr = ADR2CELL(vaddr);
	args.data = data;
	args.index = index;
	if(openfirmware(&args) == -1)
		return -1;
	if (args.status)
		return -1;
	return 0;
}

#ifdef MULTIPROCESSOR
/*
 * Start secondary cpu, arrange 'func' as the entry.
 */
void
prom_start_cpu(int cpu, void *func, long arg)
{
	static struct {
		cell_t  name;
		cell_t  nargs;
		cell_t  nreturns;
		cell_t  cpu;
		cell_t  func;
		cell_t  arg;
	} args;

	args.name = ADR2CELL("SUNW,start-cpu");
	args.nargs = 3;
	args.nreturns = 0;
	args.cpu = HDL2CELL(cpu);
	args.func = ADR2CELL(func);
	args.arg = arg;

	openfirmware(&args);
}

void
prom_start_cpu_by_cpuid(int cpu, void *func, long arg)
{
	static struct {
		cell_t  name;
		cell_t  nargs;
		cell_t  nreturns;
		cell_t  cpu;
		cell_t  func;
		cell_t  arg;
		cell_t	status;
	} args;

	args.name = ADR2CELL("SUNW,start-cpu-by-cpuid");
	args.nargs = 3;
	args.nreturns = 1;
	args.cpu = cpu;
	args.func = ADR2CELL(func);
	args.arg = arg;

	openfirmware(&args);
}
#endif

/* 
 * Low-level prom I/O routines.
 */

static u_int stdin = 0;
static u_int stdout = 0;

int 
OF_stdin(void) 
{
	u_int chosen;

	if (stdin != 0) 
		return stdin;
		
	chosen = OF_finddevice("/chosen");
	OF_getprop(chosen, "stdin", &stdin, sizeof(stdin));
	return stdin;
}

int
OF_stdout(void)
{
	u_int chosen;

	if (stdout != 0) 
		return stdout;
		
	chosen = OF_finddevice("/chosen");
	OF_getprop(chosen, "stdout", &stdout, sizeof(stdout));
	return stdout;
}


/*
 * print debug info to prom. 
 * This is not safe, but then what do you expect?
 */
void
prom_printf(const char *fmt, ...)
{
	int len;
	static char buf[256];
	va_list ap;

	va_start(ap, fmt);
	len = vsnprintf(buf, sizeof buf, fmt, ap);
	if (len == -1)
		len = 0;
	else if (len >= sizeof buf)
		len = sizeof buf - 1;
	va_end(ap);

	OF_write(OF_stdout(), buf, len);
}

const char *
prom_serengeti_set_console_input(const char *new)
{
	static struct {
		cell_t  name;
		cell_t  nargs;
		cell_t  nreturns;
		cell_t  new;
		cell_t  old;
	} args;

	args.name = ADR2CELL("SUNW,set-console-input");
	args.nargs = 1;
	args.nreturns = 1;
	args.new = ADR2CELL(new);

	if (openfirmware(&args) == -1)
		return NULL;

	return (const char *)args.old;
}

time_t
prom_opl_get_tod(void)
{
	static struct {
		cell_t  name;
		cell_t  nargs;
		cell_t  nreturns;
		cell_t  stick;
		cell_t  time;
	} args;

	args.name = ADR2CELL("FJSV,get-tod");
	args.nargs = 0;
	args.nreturns = 2;

	if (openfirmware(&args) == -1)
		return (time_t)-1;

	return (time_t)args.time;
}

uint64_t
prom_set_sun4v_api_version(uint64_t api_group, uint64_t major,
    uint64_t minor, uint64_t *supported_minor)
{
	static struct {
		cell_t  name;
		cell_t  nargs;
		cell_t  nreturns;
		cell_t  api_group;
		cell_t  major;
		cell_t  minor;
		cell_t	status;
		cell_t	supported_minor;
	} args;

	args.name = ADR2CELL("SUNW,set-sun4v-api-version");
	args.nargs = 3;
	args.nreturns = 2;
	args.api_group = api_group;
	args.major = major;
	args.minor = minor;
	args.status = -1;
	args.supported_minor = -1;

	openfirmware(&args);

	*supported_minor = args.supported_minor;
	return (uint64_t)args.status;
}

void
prom_sun4v_soft_state_supported(void)
{
	static struct {
		cell_t  name;
		cell_t  nargs;
		cell_t  nreturns;
	} args;

	args.name = ADR2CELL("SUNW,soft-state-supported");
	args.nargs = 0;
	args.nreturns = 0;

	openfirmware(&args);
}


#ifdef DEBUG
int ofmapintrdebug = 0;
#define	DPRINTF(x)	do { if (ofmapintrdebug) printf x; } while (0)
#else
#define DPRINTF(x)
#endif


/*
 * Recursively hunt for a property.
 */
int
OF_searchprop(int node, char *prop, void *buf, int buflen)
{
	int len;

	for( ; node; node = OF_parent(node)) {
		len = OF_getprop(node, prop, buf, buflen);
		if (len >= 0)
			return (len);
	}
	/* Error -- not found */
	return (-1);
}


/*
 * Compare a sequence of cells with a mask,
 *  return 1 if they match and 0 if they don't.
 */
static int compare_cells (int *cell1, int *cell2, int *mask, int ncells);
static int
compare_cells(int *cell1, int *cell2, int *mask, int ncells) 
{
	int i;

	for (i=0; i<ncells; i++) {
		DPRINTF(("src %x ^ dest %x -> %x & mask %x -> %x\n",
			cell1[i], cell2[i], (cell1[i] ^ cell2[i]),
			mask[i], ((cell1[i] ^ cell2[i]) & mask[i])));
		if (((cell1[i] ^ cell2[i]) & mask[i]) != 0)
			return (0);
	}
	return (1);
}

/*
 * Find top pci bus host controller for a node.
 */
static int
find_pci_host_node(int node)
{
	char dev_type[16];
	int pch = 0;
	int len;

	for (; node; node = OF_parent(node)) {
		len = OF_getprop(node, "device_type",
				 &dev_type, sizeof(dev_type));
		if (len <= 0)
			continue;
		if (strcmp(dev_type, "pci") == 0 ||
		    strcmp(dev_type, "pciex") == 0)
			pch = node;
	}
	return pch;
}

/*
 * Follow the OFW algorithm and return an interrupt specifier.
 *
 * Pass in the interrupt specifier you want mapped and the node
 * you want it mapped from.  validlen is the number of cells in
 * the interrupt specifier, and buflen is the number of cells in
 * the buffer.
 */
int
OF_mapintr(int node, int *interrupt, int validlen, int buflen)
{
	int i, len;
	int address_cells, size_cells, interrupt_cells, interrupt_map_len;
	int interrupt_map[256];
	int interrupt_map_mask[10];
	int reg[10];
	char dev_type[32];
	int phc_node;
	int rc = -1;

	/*
	 * Don't try to map interrupts for onboard devices, or if the
	 * interrupt is already fully specified.
	 */
	if (*interrupt & 0x20 || *interrupt & 0x7c0)
		return validlen;

	/*
	 * If there is no interrupt map in the bus node, we 
	 * need to convert the slot address to its parent
	 * bus format, and hunt up the parent bus to see if
	 * we need to remap.
	 *
	 * The specification for interrupt mapping is borken.
	 * You are supposed to query the interrupt parent in
	 * the interrupt-map specification to determine the
	 * number of address and interrupt cells, but we need
	 * to know how many address and interrupt cells to skip
	 * to find the phandle...
	 *
	 */
	if ((len = OF_getprop(node, "reg", &reg, sizeof(reg))) <= 0) {
		printf("OF_mapintr: no reg property?\n");
		return (-1);
	}

	phc_node = find_pci_host_node(node);
	while (node) {
#ifdef DEBUG
		char name[40];

		if (ofmapintrdebug) {
			OF_getprop(node, "name", &name, sizeof(name));
			printf("Node %s (%x), host %x\n", name,
			       node, phc_node);
		}
#endif

		if ((interrupt_map_len = OF_getprop(node,
			"interrupt-map", &interrupt_map,
			sizeof(interrupt_map))) <= 0) {

			/* Swizzle interrupt if this is a PCI bridge. */
			if (((len = OF_getprop(node, "device_type", &dev_type,
					      sizeof(dev_type))) > 0) &&
			    (strcmp(dev_type, "pci") == 0 ||
			     strcmp(dev_type, "pciex") == 0) &&
			    (node != phc_node)) {
				*interrupt = ((*interrupt +
				    OFW_PCI_PHYS_HI_DEVICE(reg[0]) - 1) & 3) + 1;
				DPRINTF(("OF_mapintr: interrupt %x, reg[0] %x\n",
					 *interrupt, reg[0]));
			}

			/* Get reg for next level compare. */
			reg[0] = 0;
			OF_getprop(node, "reg", &reg, sizeof(reg));

			node = OF_parent(node);
			continue;
		}
		/* Convert from bytes to cells. */
		interrupt_map_len = interrupt_map_len/sizeof(int);
		if ((len = (OF_searchprop(node, "#address-cells", &address_cells,
			sizeof(address_cells)))) <= 0) {
			/* How should I know. */
			address_cells = 2;
		}
		DPRINTF(("#address-cells = %d len %d", address_cells, len));
		if ((len = OF_searchprop(node, "#size-cells", &size_cells,
			sizeof(size_cells))) <= 0) {
			/* How should I know. */
			size_cells = 2;
		}
		DPRINTF(("#size-cells = %d len %d", size_cells, len));
		if ((len = OF_getprop(node, "#interrupt-cells", &interrupt_cells,
			sizeof(interrupt_cells))) <= 0) {
			/* How should I know. */
			interrupt_cells = 1;
		}
		DPRINTF(("#interrupt-cells = %d, len %d\n", interrupt_cells,
			len));
		if ((len = OF_getprop(node, "interrupt-map-mask", &interrupt_map_mask,
			sizeof(interrupt_map_mask))) <= 0) {
			/* Create a mask that masks nothing. */
			for (i = 0; i<(address_cells + interrupt_cells); i++)
				interrupt_map_mask[i] = -1;
		}
#ifdef DEBUG
		DPRINTF(("interrupt-map-mask len %d = ", len));
		for (i=0; i<(address_cells + interrupt_cells); i++)
			DPRINTF(("%x.", interrupt_map_mask[i]));
		DPRINTF(("reg = "));
		for (i=0; i<(address_cells); i++)
			DPRINTF(("%x.", reg[i]));
		DPRINTF(("interrupts = "));
		for (i=0; i<(interrupt_cells); i++)
			DPRINTF(("%x.", interrupt[i]));

#endif

		/* Finally we can attempt the compare. */
		i = 0;
		while (i < interrupt_map_len + address_cells + interrupt_cells) {
			int pintr_cells;
			int *imap = &interrupt_map[i];
			int *parent = &imap[address_cells + interrupt_cells];

#ifdef DEBUG
			DPRINTF(("\ninterrupt-map addr (a %d, i %d p %p) ", address_cells, interrupt_cells, parent));
			for (len=0; len<address_cells; len++)
				DPRINTF(("%x.", imap[len]));
			DPRINTF((" intr "));
			for (; len<(address_cells+interrupt_cells); len++)
				DPRINTF(("%x.", imap[len]));
			DPRINTF(("\nnode %x vs parent %x\n",
				imap[len], *parent));
#endif

			/* Find out how many cells we'll need to skip. */
			if ((len = OF_searchprop(*parent, "#interrupt-cells",
				&pintr_cells, sizeof(pintr_cells))) < 0) {
				pintr_cells = interrupt_cells;
			}
			DPRINTF(("pintr_cells = %d len %d\n", pintr_cells, len));

			if (compare_cells(imap, reg, 
				interrupt_map_mask, address_cells) &&
				compare_cells(&imap[address_cells], 
					interrupt,
					&interrupt_map_mask[address_cells], 
					interrupt_cells))
			{
				/* Bingo! */
				if (buflen < pintr_cells) {
					/* Error -- ran out of storage. */
					return (-1);
				}
				node = *parent;
				parent++;
#ifdef DEBUG
				DPRINTF(("Match! using "));
				for (len=0; len<pintr_cells; len++)
					DPRINTF(("%x.", parent[len]));
#endif
				for (i=0; i<pintr_cells; i++)
					interrupt[i] = parent[i];
				rc = validlen = pintr_cells;
				if (node == phc_node)
					return (rc);
				break;
			}
			/* Move on to the next interrupt_map entry. */
#ifdef DEBUG
			DPRINTF(("skip %d cells:",
				address_cells + interrupt_cells +
				pintr_cells + 1));
			for (len=0; len<(address_cells +
				interrupt_cells + pintr_cells + 1); len++)
				DPRINTF(("%x.", imap[len]));
#endif
			i += address_cells + interrupt_cells + pintr_cells + 1;
		}

		/* Get reg for the next level search. */
		if ((len = OF_getprop(node, "reg", &reg, sizeof(reg))) <= 0)
			DPRINTF(("OF_mapintr: no reg property?\n"));
		else
			DPRINTF(("reg len %d\n", len));

		node = OF_parent(node);
	}
	return (rc);
}
@


1.32
log
@Mark Cave-Ayland pointed out on tech@@ that the OF_test_method was called
with an ihandle instead of a phandle. And also the comparison was the
wrong way around.

This bug was causing an exception. Because -1 is returned to indicate
failure and because the comparison is the wrong way around, the bad logic
led to believing that SUNW,retain exists which is why this currently
works on some PROMs.

On E250/E450 machines, this didn't work so there was a hack to detect
these machines and work-around the problem. After this fix that hack is
now removed.

Tested on an E450 by sebastia@@ and confirmed that his dmesg is now
retained after a reboot. nick@@ promises to complain if his E250 is any
worse off.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.31 2009/02/19 11:12:42 kettenis Exp $	*/
d72 1
a72 1
get_mmu_handle()
d88 1
a88 1
get_memory_handle()
d681 1
a681 1
OF_stdin() 
d694 1
a694 1
OF_stdout()
@


1.31
log
@Make prom_sun4v_soft_state_supported() call the right client interface.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.30 2008/12/30 00:54:24 kettenis Exp $	*/
a521 12
	int rooth;
	int is_e250 = 1;

	/* E250s tend to have buggy PROMs that break on test-method */
	if ((rooth = OF_finddevice("/")) != -1) {
		char name[80];

		if ((OF_getprop(rooth, "name", &name, sizeof(name))) != -1) {
			if (strcmp(name, "SUNW,Ultra-250") && strcmp(name, "SUNW,Ultra-4")) 
				is_e250 = 0;
		} else prom_printf("prom_get_msgbuf: cannot get \"name\"\r\n");
	} else prom_printf("prom_get_msgbuf: cannot open root device \r\n");
d527 2
a528 4
	if (is_e250) {
		prom_printf("prom_get_msgbuf: Cannot recover msgbuf on E250/450\r\n");
	} else if (OF_test("test-method") == 0) {
		if (OF_test_method(memh, "SUNW,retain") != 0) {
@


1.30
log
@Add domain state related PROM calls.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.29 2008/08/09 21:06:05 kettenis Exp $	*/
d825 1
a825 1
	args.name = ADR2CELL("SUNW,set-sun4v-api-version");
@


1.29
log
@Add prom_set_sun4v_api_version().
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.28 2008/07/10 08:57:05 kettenis Exp $	*/
d815 17
@


1.28
log
@Add a function to get the time of day from the prom on the m4k.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.26 2008/07/05 22:17:21 kettenis Exp $	*/
d784 30
@


1.27
log
@Extend sbbc(4) to provide a console driver for the v1280.
@
text
@d765 21
@


1.26
log
@Specify the correct number of arguments in prom call that sets the trap table
(1 for sun4u, 2 for sun4v).
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.25 2008/03/19 20:21:01 kettenis Exp $	*/
d741 22
@


1.25
log
@Add prom_itlb_load() and prom_dtlb_load().
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.24 2008/03/08 15:42:26 kettenis Exp $	*/
d121 4
a124 1
	args.nargs = 2;
@


1.24
log
@SUNW,set-trap-table takes an extra argument on sun4v; sun4u doesn't seem to
mind.

tested by miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.23 2008/01/10 22:46:48 deraadt Exp $	*/
d564 68
@


1.23
log
@instead of showing { love }, fix the macro do use the do { ... } while (0) construct; ok kettenis marco
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.22 2008/01/10 22:25:20 marco Exp $	*/
d108 1
a108 1
prom_set_trap_table(tba)
d110 1
d117 1
d121 1
a121 1
	args.nargs = 1;
d124 1
@


1.22
log
@Fix {}

ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.21 2007/10/19 15:17:30 kettenis Exp $	*/
d671 1
a671 1
#define	DPRINTF(x)	if (ofmapintrdebug) printf x
d922 1
a922 1
		if ((len = OF_getprop(node, "reg", &reg, sizeof(reg))) <= 0) {
d924 1
a924 1
		} else {
d926 1
a926 1
		}
@


1.21
log
@Use HDL2CELL when passing an OpenFirmware handle in prom_start_cpu.  Makes
bsd.mp boot on an E250.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.20 2007/09/08 17:48:12 kettenis Exp $	*/
d922 1
a922 1
		if ((len = OF_getprop(node, "reg", &reg, sizeof(reg))) <= 0)
d924 1
a924 1
		else
d926 1
a926 1

d928 1
a928 1
	} 
@


1.20
log
@Add prom functions to start secondary CPUs.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.19 2007/07/28 13:22:22 kettenis Exp $	*/
d582 1
a582 1
	args.cpu = cpu;
@


1.19
log
@Don't try to map interrupts that are already fully specified.  Makes the
onboard IDE controller on the Ultrabook 170/200 work.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.18 2007/04/10 14:26:17 kettenis Exp $	*/
d562 50
@


1.18
log
@Prevent infinite loop mapping interrupts when "reg" property is missing.

ok mbalmer@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.17 2007/04/06 22:38:14 kettenis Exp $	*/
d707 5
a711 2
	/* Don't need to map OBP interrupt, it's already */
	if (*interrupt & 0x20)
@


1.17
log
@Add support for PCIe.  Don't map interrupts that are already mapped correctly.
Tested by deraadt@@, nick@@, sturm@@, naddy@@ and others.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.16 2007/01/16 14:39:57 tsi Exp $	*/
d869 1
a869 1
		if ((len = OF_getprop(node, "reg", &reg, sizeof(reg))) <= 0) {
d871 2
a872 3
			continue;
		}
		DPRINTF(("reg len %d\n", len));
@


1.16
log
@Remove unnecessary ampersands in ADR2CELL macro invocations;
Change OF_printf references to printf, given the former doesn't exist;
Clean up formatting, whitespace, unused code, etc.

ok miod@@, kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.15 2006/08/31 21:28:35 kettenis Exp $	*/
d680 2
a681 1
		if (!strcmp(dev_type, "pci"))
d731 1
a731 2

	for (; node; node = OF_parent(node)) {
d749 2
a750 1
			    !strcmp(dev_type, "pci") &&
d761 2
d805 3
a807 3
		/* finally we can attempt the compare */
		i=0;
		while ( i < interrupt_map_len + address_cells + interrupt_cells) {
d842 1
d852 2
d875 1
@


1.15
log
@Fix handling of 64-bit quantities in Open Firmware's client interface.
Spotted by tsi@@, and shamelessly stolen from his diff.  Fixes several
UltraSPARC-III machines wich have more than one memory bank filled.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.14 2005/07/01 01:12:04 brad Exp $	*/
d118 1
a118 1
	args.name = ADR2CELL(&"SUNW,set-trap-table");
d152 1
a152 1
	args.name = ADR2CELL(&"call-method");
d155 1
a155 1
	args.method = ADR2CELL(&"translate");
d161 11
a171 3
	prom_printf("Called \"translate\", mmuh=%x, vaddr=%x, status=%x %x,\r\n retaddr=%x %x, mode=%x %x, phys_hi=%x %x, phys_lo=%x %x\r\n",
		    mmuh, vaddr, (int)(args.status>>32), (int)args.status, (int)(args.retaddr>>32), (int)args.retaddr, 
		    (int)(args.mode>>32), (int)args.mode, (int)(args.phys_hi>>32), (int)args.phys_hi,
d204 1
a204 1
	args.name = ADR2CELL(&"call-method");
d207 1
a207 1
	args.method = ADR2CELL(&"claim");
d243 1
a243 1
	args.name = ADR2CELL(&"call-method");
d246 1
a246 1
	args.method = ADR2CELL(&"claim");
d279 1
a279 1
	args.name = ADR2CELL(&"call-method");
d282 1
a282 1
	args.method = ADR2CELL(&"release");
d314 1
a314 1
	args.name = ADR2CELL(&"call-method");
d317 1
a317 1
	args.method = ADR2CELL(&"unmap");
d355 1
a355 1
	args.name = ADR2CELL(&"call-method");
d358 1
a358 1
	args.method = ADR2CELL(&"map");
d363 1
a363 1
	args.phys_hi = HDQ2CELL_HI(paddr); 
d401 1
a401 1
	args.name = ADR2CELL(&"call-method");
d404 1
a404 1
	args.method = ADR2CELL(&"claim");
d442 1
a442 1
	args.name = ADR2CELL(&"call-method");
d445 1
a445 1
	args.method = ADR2CELL(&"claim");
d481 1
a481 1
	args.name = ADR2CELL(&"call-method");
d484 1
a484 1
	args.method = ADR2CELL(&"release");
d537 1
a537 1
			args.name = ADR2CELL(&"call-method");
d540 2
a541 2
			args.method = ADR2CELL(&"SUNW,retain");
			args.id = ADR2CELL(&"msgbuf");
@


1.14
log
@white space nit
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.13 2005/06/29 23:48:10 deraadt Exp $	*/
d166 1
a166 1
	return (paddr_t)((((paddr_t)args.phys_hi)<<32)|(u_int32_t)args.phys_lo); 
a218 1
	static int retaddr;
a241 1
	args.retaddr = ADR2CELL(&retaddr);
d244 1
a244 1
	return retaddr; /* Kluge till we go 64-bit */
d355 2
a356 2
	args.phys_hi = HDL2CELL(paddr>>32); 
	args.phys_lo = HDL2CELL(paddr);
d362 1
a362 1
	return args.retaddr;
d402 1
a402 1
	return (paddr_t)((((paddr_t)args.phys_hi)<<32)|(u_int32_t)args.phys_lo);
d441 2
a442 2
	args.phys_hi = HDL2CELL(phys>>32);
	args.phys_lo = HDL2CELL(phys);
d445 1
a445 1
	return (paddr_t)((((paddr_t)args.rphys_hi)<<32)|(u_int32_t)args.rphys_lo);
d479 2
a480 2
	args.phys_hi = HDL2CELL(phys>>32);
	args.phys_lo = HDL2CELL(phys);
d538 3
a540 4
			if (openfirmware(&args) == 0 && args.status == 0) {
				return (((paddr_t)args.phys_hi<<32)|
					(u_int32_t)args.phys_lo);
			} else prom_printf("prom_get_msgbuf: SUNW,retain failed\r\n");
@


1.13
log
@handle larger interrupt maps; from henric
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.12 2005/04/21 00:26:47 deraadt Exp $	*/
d834 1
a834 1
				parent ++;
@


1.12
log
@correct idion for snprintf failure handling; ok cloder
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.11 2004/06/15 05:44:45 brad Exp $	*/
d694 1
a694 1
	int interrupt_map[100];
d799 1
a799 1
		while ( i < interrupt_map_len ) {
d805 1
a805 1
			DPRINTF(("\ninterrupt-map addr "));
@


1.11
log
@fix some printf's

From: Brian Poole <raj at cerias dot purdue dot edu>

ok henric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.10 2004/05/17 04:34:46 brad Exp $	*/
d605 4
@


1.10
log
@OF_mapintr: swizzle interrupt for PCI bridges,
don't process OBP interrupts, return error if interrupt is not mapped.

allows the IDE CD-rom on a Netra T1 105 to work.

From NetBSD

Tested by me on a Netra T1 105 and Ultra 10, tested on a E450 and ok henric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.9 2004/01/07 20:44:56 pvalchev Exp $	*/
d93 1
a93 1
		prom_printf("get_mmu_handle: cannot get /chosen\r\n");
d270 1
a270 1
		prom_printf("prom_claim_virt: cannot get mmuh\r\n");
d305 1
a305 1
		prom_printf("prom_claim_virt: cannot get mmuh\r\n");
d433 1
a433 1
		prom_printf("prom_alloc_phys: cannot get memh\r\n");
@


1.9
log
@machine/stdarg.h -> sys/stdarg.h; ok espie
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.8 2003/05/10 21:11:14 deraadt Exp $	*/
d48 2
d562 2
a563 2
static u_int stdin;
static u_int stdout;
d657 21
d693 7
d720 2
d728 2
a729 1
			printf("Node %s\n", name);
d736 12
d749 1
d838 1
a838 1
				validlen = pintr_cells;
d861 1
a861 1
	return (validlen);
@


1.8
log
@string cleaning; ok beck dhartmei
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.7 2003/01/30 07:53:58 henric Exp $	*/
d56 1
a56 1
#include <machine/stdarg.h>
@


1.7
log
@
The E450 seems to have the same problem as the E250, so don't ask OF for
the msgbuf on this box either.

ok jason@@ (a very, very long time ago)
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.6 2002/03/15 18:19:52 millert Exp $	*/
d602 1
a602 1
	len = vsprintf(buf, fmt, ap);
@


1.6
log
@Kill #if __STDC__ used to do K&R vs. ANSI varargs/stdarg; just do things
the ANSI way.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.5 2002/03/14 01:26:45 millert Exp $	*/
d516 1
a516 1
			if (strcmp(name, "SUNW,Ultra-250")) 
d526 1
a526 1
		prom_printf("prom_get_msgbuf: Cannot recover msgbuf on E250\r\n");
@


1.5
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.4 2002/01/03 22:09:35 jason Exp $	*/
a594 1
#ifdef __STDC__
a595 5
#else
prom_printf(fmt, va_alist)
	char *fmt;
	va_dcl
#endif
@


1.4
log
@stdout and stdin are integers not pointers (use 0 not NULL)
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.3 2001/08/20 20:23:53 jason Exp $	*/
d60 1
a60 1
int vsprintf __P((char *, const char *, va_list));
d62 1
a62 1
void dk_cleanup __P((void));
d66 2
a67 2
static u_int get_mmu_handle __P((void));
static u_int get_memory_handle __P((void));
@


1.3
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d560 2
a561 2
static u_int stdin = NULL;
static u_int stdout = NULL;
d568 1
a568 1
	if (stdin != NULL) 
d581 1
a581 1
	if (stdout != NULL) 
@


1.3.6.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.4 2002/01/03 22:09:35 jason Exp $	*/
d560 2
a561 2
static u_int stdin;
static u_int stdout;
d568 1
a568 1
	if (stdin != 0) 
d581 1
a581 1
	if (stdout != 0) 
@


1.3.6.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.3.6.1 2002/01/31 22:55:25 niklas Exp $	*/
d60 1
a60 1
int vsprintf(char *, const char *, va_list);
d62 1
a62 1
void dk_cleanup(void);
d66 2
a67 2
static u_int get_mmu_handle(void);
static u_int get_memory_handle(void);
d595 1
d597 5
@


1.3.6.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d516 1
a516 1
			if (strcmp(name, "SUNW,Ultra-250") && strcmp(name, "SUNW,Ultra-4")) 
d526 1
a526 1
		prom_printf("prom_get_msgbuf: Cannot recover msgbuf on E250/450\r\n");
d602 1
a602 1
	len = vsnprintf(buf, sizeof buf, fmt, ap);
@


1.3.4.1
log
@Sync the SMP branch to something just after 3.0
@
text
@@


1.3.4.2
log
@Merge in trunk
@
text
@d560 2
a561 2
static u_int stdin;
static u_int stdout;
d568 1
a568 1
	if (stdin != 0) 
d581 1
a581 1
	if (stdout != 0) 
@


1.3.4.3
log
@Merge in -current from about a week ago
@
text
@d60 1
a60 1
int vsprintf(char *, const char *, va_list);
d62 1
a62 1
void dk_cleanup(void);
d66 2
a67 2
static u_int get_mmu_handle(void);
static u_int get_memory_handle(void);
d595 1
d597 5
@


1.3.4.4
log
@Sync the SMP branch with 3.3
@
text
@d516 1
a516 1
			if (strcmp(name, "SUNW,Ultra-250") && strcmp(name, "SUNW,Ultra-4")) 
d526 1
a526 1
		prom_printf("prom_get_msgbuf: Cannot recover msgbuf on E250/450\r\n");
@


1.3.4.5
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofw_machdep.c,v 1.3.4.4 2003/03/27 23:42:37 niklas Exp $	*/
d602 1
a602 1
	len = vsnprintf(buf, sizeof buf, fmt, ap);
@


1.3.4.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d56 1
a56 1
#include <sys/stdarg.h>
@


1.3.4.7
log
@Merge with the trunk
@
text
@a47 2
#include <dev/ofw/ofw_pci.h>

d560 2
a561 2
static u_int stdin = 0;
static u_int stdout = 0;
a654 21
 * Find top pci bus host controller for a node.
 */
static int
find_pci_host_node(int node)
{
	char dev_type[16];
	int pch = 0;
	int len;

	for (; node; node = OF_parent(node)) {
		len = OF_getprop(node, "device_type",
				 &dev_type, sizeof(dev_type));
		if (len <= 0)
			continue;
		if (!strcmp(dev_type, "pci"))
			pch = node;
	}
	return pch;
}

/*
a669 7
	char dev_type[32];
	int phc_node;
	int rc = -1;

	/* Don't need to map OBP interrupt, it's already */
	if (*interrupt & 0x20)
		return validlen;
a689 2
	phc_node = find_pci_host_node(node);

d696 1
a696 2
			printf("Node %s (%x), host %x\n", name,
			       node, phc_node);
a702 12

			/* Swizzle interrupt if this is a PCI bridge. */
			if (((len = OF_getprop(node, "device_type", &dev_type,
					      sizeof(dev_type))) > 0) &&
			    !strcmp(dev_type, "pci") &&
			    (node != phc_node)) {
				*interrupt = ((*interrupt +
				    OFW_PCI_PHYS_HI_DEVICE(reg[0]) - 1) & 3) + 1;
				DPRINTF(("OF_mapintr: interrupt %x, reg[0] %x\n",
					 *interrupt, reg[0]));
			}

a703 1
			reg[0] = 0;
d792 1
a792 1
				rc = validlen = pintr_cells;
d815 1
a815 1
	return (rc);
@


1.2
log
@remove some dead code.
@
text
@d1 1
@


1.1
log
@Lot of stuff... Some from NetBSD, some from OpenBSD, minor modifications
@
text
@a61 3
#if defined(FFS) && defined(CD9660)
static int dk_match_ffs __P((void));
#endif
@

