head	1.48;
access;
symbols
	OPENBSD_6_2:1.48.0.2
	OPENBSD_6_2_BASE:1.48
	OPENBSD_6_1:1.47.0.4
	OPENBSD_6_1_BASE:1.47
	OPENBSD_6_0:1.42.0.2
	OPENBSD_6_0_BASE:1.42
	OPENBSD_5_9:1.39.0.2
	OPENBSD_5_9_BASE:1.39
	OPENBSD_5_8:1.36.0.8
	OPENBSD_5_8_BASE:1.36
	OPENBSD_5_7:1.36.0.2
	OPENBSD_5_7_BASE:1.36
	OPENBSD_5_6:1.36.0.4
	OPENBSD_5_6_BASE:1.36
	OPENBSD_5_5:1.32.0.10
	OPENBSD_5_5_BASE:1.32
	OPENBSD_5_4:1.32.0.6
	OPENBSD_5_4_BASE:1.32
	OPENBSD_5_3:1.32.0.4
	OPENBSD_5_3_BASE:1.32
	OPENBSD_5_2:1.32.0.2
	OPENBSD_5_2_BASE:1.32
	OPENBSD_5_1_BASE:1.31
	OPENBSD_5_1:1.31.0.4
	OPENBSD_5_0:1.31.0.2
	OPENBSD_5_0_BASE:1.31
	OPENBSD_4_9:1.30.0.2
	OPENBSD_4_9_BASE:1.30
	OPENBSD_4_8:1.29.0.2
	OPENBSD_4_8_BASE:1.29
	OPENBSD_4_7:1.27.0.4
	OPENBSD_4_7_BASE:1.27
	OPENBSD_4_6:1.27.0.6
	OPENBSD_4_6_BASE:1.27
	OPENBSD_4_5:1.27.0.2
	OPENBSD_4_5_BASE:1.27
	OPENBSD_4_4:1.26.0.2
	OPENBSD_4_4_BASE:1.26
	OPENBSD_4_3:1.25.0.2
	OPENBSD_4_3_BASE:1.25
	OPENBSD_4_2:1.23.0.2
	OPENBSD_4_2_BASE:1.23
	OPENBSD_4_1:1.21.0.4
	OPENBSD_4_1_BASE:1.21
	OPENBSD_4_0:1.21.0.2
	OPENBSD_4_0_BASE:1.21
	OPENBSD_3_9:1.19.0.6
	OPENBSD_3_9_BASE:1.19
	OPENBSD_3_8:1.19.0.4
	OPENBSD_3_8_BASE:1.19
	OPENBSD_3_7:1.19.0.2
	OPENBSD_3_7_BASE:1.19
	OPENBSD_3_6:1.18.0.4
	OPENBSD_3_6_BASE:1.18
	SMP_SYNC_A:1.18
	SMP_SYNC_B:1.18
	OPENBSD_3_5:1.18.0.2
	OPENBSD_3_5_BASE:1.18
	OPENBSD_3_4:1.17.0.2
	OPENBSD_3_4_BASE:1.17
	UBC_SYNC_A:1.14
	OPENBSD_3_3:1.14.0.2
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.12.0.2
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	UBC_SYNC_B:1.12
	UBC:1.4.0.6
	UBC_BASE:1.4
	SMP:1.4.0.4
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4;
locks; strict;
comment	@ * @;


1.48
date	2017.04.30.16.45.45;	author mpi;	state Exp;
branches;
next	1.47;
commitid	2Gtqjzrin9LL2yHk;

1.47
date	2016.11.07.00.26.33;	author guenther;	state Exp;
branches;
next	1.46;
commitid	W7ztnDZwvjCaeQTS;

1.46
date	2016.10.18.00.43.57;	author guenther;	state Exp;
branches;
next	1.45;
commitid	ViMtDmKg8K8fZjQi;

1.45
date	2016.10.08.05.49.09;	author guenther;	state Exp;
branches;
next	1.44;
commitid	z63v1DilayzHcfkw;

1.44
date	2016.09.11.03.14.04;	author guenther;	state Exp;
branches;
next	1.43;
commitid	CTJERhMeok0roRjS;

1.43
date	2016.08.23.03.28.01;	author guenther;	state Exp;
branches;
next	1.42;
commitid	sVHD5kblxhZITIq0;

1.42
date	2016.03.14.23.08.05;	author krw;	state Exp;
branches;
next	1.41;
commitid	kCz5QgxnxRMKOzNf;

1.41
date	2016.03.07.13.21.51;	author naddy;	state Exp;
branches;
next	1.40;
commitid	EDvRPKRZUDEEb6oR;

1.40
date	2016.02.27.13.08.07;	author mpi;	state Exp;
branches;
next	1.39;
commitid	hnv9KfQtxhCytAnd;

1.39
date	2015.08.28.23.28.39;	author kettenis;	state Exp;
branches;
next	1.38;
commitid	IIvmUURykkPFbth0;

1.38
date	2015.08.28.22.17.14;	author kettenis;	state Exp;
branches;
next	1.37;
commitid	ikPFEnbOCyTBoWQD;

1.37
date	2015.08.26.13.59.24;	author kettenis;	state Exp;
branches;
next	1.36;
commitid	xm8anOz7TCNXA9ZJ;

1.36
date	2014.07.13.12.11.01;	author jasper;	state Exp;
branches;
next	1.35;
commitid	XHZxhpAa5R1Ymp1z;

1.35
date	2014.05.10.18.46.20;	author kettenis;	state Exp;
branches;
next	1.34;

1.34
date	2014.04.03.09.15.06;	author mpi;	state Exp;
branches;
next	1.33;

1.33
date	2014.03.29.18.09.30;	author guenther;	state Exp;
branches;
next	1.32;

1.32
date	2012.03.23.15.51.26;	author guenther;	state Exp;
branches;
next	1.31;

1.31
date	2011.07.03.18.34.14;	author oga;	state Exp;
branches;
next	1.30;

1.30
date	2010.11.27.19.57.23;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2010.07.06.02.26.32;	author guenther;	state Exp;
branches;
next	1.28;

1.28
date	2010.06.27.13.28.47;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2008.12.14.17.10.44;	author kettenis;	state Exp;
branches;
next	1.26;

1.26
date	2008.03.13.23.29.46;	author kettenis;	state Exp;
branches;
next	1.25;

1.25
date	2008.02.20.09.44.47;	author robert;	state Exp;
branches;
next	1.24;

1.24
date	2007.10.27.22.20.16;	author martin;	state Exp;
branches;
next	1.23;

1.23
date	2007.05.02.18.46.07;	author kettenis;	state Exp;
branches;
next	1.22;

1.22
date	2007.04.12.22.20.14;	author thib;	state Exp;
branches;
next	1.21;

1.21
date	2006.07.06.19.05.56;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2006.07.06.17.51.26;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2004.12.25.23.02.25;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2003.12.20.20.08.17;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2003.07.09.18.08.01;	author jason;	state Exp;
branches;
next	1.16;

1.16
date	2003.07.09.17.38.19;	author jason;	state Exp;
branches;
next	1.15;

1.15
date	2003.06.16.20.46.14;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2003.02.12.06.33.00;	author jason;	state Exp;
branches;
next	1.13;

1.13
date	2003.01.09.22.27.10;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2002.07.24.00.48.25;	author art;	state Exp;
branches;
next	1.11;

1.11
date	2002.06.15.17.23.31;	author art;	state Exp;
branches;
next	1.10;

1.10
date	2002.06.11.08.09.42;	author mdw;	state Exp;
branches;
next	1.9;

1.9
date	2002.06.10.20.09.24;	author mdw;	state Exp;
branches;
next	1.8;

1.8
date	2002.05.16.13.01.41;	author art;	state Exp;
branches;
next	1.7;

1.7
date	2002.03.14.04.16.55;	author jason;	state Exp;
branches;
next	1.6;

1.6
date	2002.03.14.03.16.01;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.03.14.01.26.45;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.08.22.05.08.11;	author jason;	state Exp;
branches
	1.4.4.1
	1.4.6.1;
next	1.3;

1.3
date	2001.08.20.20.23.53;	author jason;	state Exp;
branches;
next	1.2;

1.2
date	2001.08.19.16.09.22;	author art;	state Exp;
branches;
next	1.1;

1.1
date	2001.08.19.15.46.32;	author art;	state Exp;
branches;
next	;

1.4.4.1
date	2001.10.31.03.07.58;	author nate;	state Exp;
branches;
next	1.4.4.2;

1.4.4.2
date	2002.03.28.11.23.52;	author niklas;	state Exp;
branches;
next	1.4.4.3;

1.4.4.3
date	2003.03.27.23.42.37;	author niklas;	state Exp;
branches;
next	1.4.4.4;

1.4.4.4
date	2004.02.19.10.50.00;	author niklas;	state Exp;
branches;
next	;

1.4.6.1
date	2002.06.11.03.38.43;	author art;	state Exp;
branches;
next	1.4.6.2;

1.4.6.2
date	2002.10.29.00.28.12;	author art;	state Exp;
branches;
next	1.4.6.3;

1.4.6.3
date	2003.05.19.21.46.57;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.48
log
@Rename Debugger() into db_enter().

Using a name with the 'db_' prefix makes it invisible from the dynamic
profiler.

ok deraadt@@, kettenis@@, visa@@
@
text
@/*	$OpenBSD: db_interface.c,v 1.47 2016/11/07 00:26:33 guenther Exp $	*/
/*	$NetBSD: db_interface.c,v 1.61 2001/07/31 06:55:47 eeh Exp $ */

/*
 * Mach Operating System
 * Copyright (c) 1991,1990 Carnegie Mellon University
 * All Rights Reserved.
 *
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 *
 *	From: db_interface.c,v 2.4 1991/02/05 17:11:13 mrt (CMU)
 */

#include <sys/param.h>
#include <sys/proc.h>
#include <sys/user.h>
#include <sys/reboot.h>
#include <sys/systm.h>
#include <sys/malloc.h>

#include <dev/cons.h>

#include <machine/db_machdep.h>
#include <ddb/db_command.h>
#include <ddb/db_sym.h>
#include <ddb/db_variables.h>
#include <ddb/db_extern.h>
#include <ddb/db_access.h>
#include <ddb/db_output.h>
#include <ddb/db_interface.h>
#include <ddb/db_run.h>

#include <machine/instr.h>
#include <machine/cpu.h>
#include <machine/openfirm.h>
#include <machine/ctlreg.h>
#include <machine/pmap.h>

#ifdef notyet
#include "fb.h"
#include "esp_sbus.h"
#endif

#include "tda.h"

#ifdef MULTIPROCESSOR
struct mutex ddb_mp_mutex = MUTEX_INITIALIZER(IPL_HIGH);
volatile int ddb_state = DDB_STATE_NOT_RUNNING;
volatile cpuid_t ddb_active_cpu;
boolean_t	 db_switch_cpu;
struct cpu_info *db_switch_to_cpu;
#endif

db_regs_t	ddb_regs;	/* register state */

extern void OF_enter(void);

static long nil;

static int
db__char_value(struct db_variable *var, db_expr_t *expr, int mode)
{

	switch (mode) {
	case DB_VAR_SET:
		*var->valuep = *(char *)expr;
		break;
	case DB_VAR_GET:
		*expr = *(char *)var->valuep;
		break;
#ifdef DIAGNOSTIC
	default:
		printf("db__char_value: mode %d\n", mode);
		break;
#endif
	}

	return 0;
}

#ifdef notdef_yet
static int
db__short_value(struct db_variable *var, db_expr_t *expr, int mode)
{

	switch (mode) {
	case DB_VAR_SET:
		*var->valuep = *(short *)expr;
		break;
	case DB_VAR_GET:
		*expr = *(short *)var->valuep;
		break;
#ifdef DIAGNOSTIC
	default:
		printf("db__short_value: mode %d\n", mode);
		break;
#endif
	}

	return 0;
}
#endif

struct db_variable db_regs[] = {
	{ "tstate", (long *)&DDB_TF->tf_tstate, FCN_NULL, },
	{ "pc", (long *)&DDB_TF->tf_pc, FCN_NULL, },
	{ "npc", (long *)&DDB_TF->tf_npc, FCN_NULL, },
	{ "ipl", (long *)&DDB_TF->tf_oldpil, db__char_value, },
	{ "y", (long *)&DDB_TF->tf_y, db_var_rw_int, },
	{ "g0", (long *)&nil, FCN_NULL, },
	{ "g1", (long *)&DDB_TF->tf_global[1], FCN_NULL, },
	{ "g2", (long *)&DDB_TF->tf_global[2], FCN_NULL, },
	{ "g3", (long *)&DDB_TF->tf_global[3], FCN_NULL, },
	{ "g4", (long *)&DDB_TF->tf_global[4], FCN_NULL, },
	{ "g5", (long *)&DDB_TF->tf_global[5], FCN_NULL, },
	{ "g6", (long *)&DDB_TF->tf_global[6], FCN_NULL, },
	{ "g7", (long *)&DDB_TF->tf_global[7], FCN_NULL, },
	{ "o0", (long *)&DDB_TF->tf_out[0], FCN_NULL, },
	{ "o1", (long *)&DDB_TF->tf_out[1], FCN_NULL, },
	{ "o2", (long *)&DDB_TF->tf_out[2], FCN_NULL, },
	{ "o3", (long *)&DDB_TF->tf_out[3], FCN_NULL, },
	{ "o4", (long *)&DDB_TF->tf_out[4], FCN_NULL, },
	{ "o5", (long *)&DDB_TF->tf_out[5], FCN_NULL, },
	{ "o6", (long *)&DDB_TF->tf_out[6], FCN_NULL, },
	{ "o7", (long *)&DDB_TF->tf_out[7], FCN_NULL, },
	{ "l0", (long *)&DDB_TF->tf_local[0], FCN_NULL, },
	{ "l1", (long *)&DDB_TF->tf_local[1], FCN_NULL, },
	{ "l2", (long *)&DDB_TF->tf_local[2], FCN_NULL, },
	{ "l3", (long *)&DDB_TF->tf_local[3], FCN_NULL, },
	{ "l4", (long *)&DDB_TF->tf_local[4], FCN_NULL, },
	{ "l5", (long *)&DDB_TF->tf_local[5], FCN_NULL, },
	{ "l6", (long *)&DDB_TF->tf_local[6], FCN_NULL, },
	{ "l7", (long *)&DDB_TF->tf_local[7], FCN_NULL, },
	{ "i0", (long *)&DDB_FR->fr_arg[0], FCN_NULL, },
	{ "i1", (long *)&DDB_FR->fr_arg[1], FCN_NULL, },
	{ "i2", (long *)&DDB_FR->fr_arg[2], FCN_NULL, },
	{ "i3", (long *)&DDB_FR->fr_arg[3], FCN_NULL, },
	{ "i4", (long *)&DDB_FR->fr_arg[4], FCN_NULL, },
	{ "i5", (long *)&DDB_FR->fr_arg[5], FCN_NULL, },
	{ "i6", (long *)&DDB_FR->fr_arg[6], FCN_NULL, },
	{ "i7", (long *)&DDB_FR->fr_arg[7], FCN_NULL, },
	{ "f0", (long *)&DDB_FP->fs_regs[0], FCN_NULL, },
	{ "f2", (long *)&DDB_FP->fs_regs[2], FCN_NULL, },
	{ "f4", (long *)&DDB_FP->fs_regs[4], FCN_NULL, },
	{ "f6", (long *)&DDB_FP->fs_regs[6], FCN_NULL, },
	{ "f8", (long *)&DDB_FP->fs_regs[8], FCN_NULL, },
	{ "f10", (long *)&DDB_FP->fs_regs[10], FCN_NULL, },
	{ "f12", (long *)&DDB_FP->fs_regs[12], FCN_NULL, },
	{ "f14", (long *)&DDB_FP->fs_regs[14], FCN_NULL, },
	{ "f16", (long *)&DDB_FP->fs_regs[16], FCN_NULL, },
	{ "f18", (long *)&DDB_FP->fs_regs[18], FCN_NULL, },
	{ "f20", (long *)&DDB_FP->fs_regs[20], FCN_NULL, },
	{ "f22", (long *)&DDB_FP->fs_regs[22], FCN_NULL, },
	{ "f24", (long *)&DDB_FP->fs_regs[24], FCN_NULL, },
	{ "f26", (long *)&DDB_FP->fs_regs[26], FCN_NULL, },
	{ "f28", (long *)&DDB_FP->fs_regs[28], FCN_NULL, },
	{ "f30", (long *)&DDB_FP->fs_regs[30], FCN_NULL, },
	{ "f32", (long *)&DDB_FP->fs_regs[32], FCN_NULL, },
	{ "f34", (long *)&DDB_FP->fs_regs[34], FCN_NULL, },
	{ "f36", (long *)&DDB_FP->fs_regs[36], FCN_NULL, },
	{ "f38", (long *)&DDB_FP->fs_regs[38], FCN_NULL, },
	{ "f40", (long *)&DDB_FP->fs_regs[40], FCN_NULL, },
	{ "f42", (long *)&DDB_FP->fs_regs[42], FCN_NULL, },
	{ "f44", (long *)&DDB_FP->fs_regs[44], FCN_NULL, },
	{ "f46", (long *)&DDB_FP->fs_regs[46], FCN_NULL, },
	{ "f48", (long *)&DDB_FP->fs_regs[48], FCN_NULL, },
	{ "f50", (long *)&DDB_FP->fs_regs[50], FCN_NULL, },
	{ "f52", (long *)&DDB_FP->fs_regs[52], FCN_NULL, },
	{ "f54", (long *)&DDB_FP->fs_regs[54], FCN_NULL, },
	{ "f56", (long *)&DDB_FP->fs_regs[56], FCN_NULL, },
	{ "f58", (long *)&DDB_FP->fs_regs[58], FCN_NULL, },
	{ "f60", (long *)&DDB_FP->fs_regs[60], FCN_NULL, },
	{ "f62", (long *)&DDB_FP->fs_regs[62], FCN_NULL, },
	{ "fsr", (long *)&DDB_FP->fs_fsr, FCN_NULL, },
	{ "gsr", (long *)&DDB_FP->fs_gsr, FCN_NULL, },

};
struct db_variable *db_eregs = db_regs + nitems(db_regs);

extern label_t	*db_recover;

int	db_active = 0;

extern char *trap_type[];

void kdb_kbd_trap(struct trapframe64 *);
void db_prom_cmd(db_expr_t, int, db_expr_t, char *);
void db_proc_cmd(db_expr_t, int, db_expr_t, char *);
void db_ctx_cmd(db_expr_t, int, db_expr_t, char *);
void db_dump_window(db_expr_t, int, db_expr_t, char *);
void db_dump_stack(db_expr_t, int, db_expr_t, char *);
void db_dump_trap(db_expr_t, int, db_expr_t, char *);
void db_dump_fpstate(db_expr_t, int, db_expr_t, char *);
void db_dump_ts(db_expr_t, int, db_expr_t, char *);
void db_dump_pcb(db_expr_t, int, db_expr_t, char *);
void db_dump_pv(db_expr_t, int, db_expr_t, char *);
void db_setpcb(db_expr_t, int, db_expr_t, char *);
void db_dump_dtlb(db_expr_t, int, db_expr_t, char *);
void db_dump_itlb(db_expr_t, int, db_expr_t, char *);
void db_dump_dtsb(db_expr_t, int, db_expr_t, char *);
void db_pmap_kernel(db_expr_t, int, db_expr_t, char *);
void db_pload_cmd(db_expr_t, int, db_expr_t, char *);
void db_pmap_cmd(db_expr_t, int, db_expr_t, char *);
void db_lock(db_expr_t, int, db_expr_t, char *);
void db_dump_buf(db_expr_t, int, db_expr_t, char *);
void db_dump_espcmd(db_expr_t, int, db_expr_t, char *);
void db_watch(db_expr_t, int, db_expr_t, char *);
void db_xir(db_expr_t, int, db_expr_t, char *);

static void db_dump_pmap(struct pmap*);

#ifdef MULTIPROCESSOR
void db_cpuinfo_cmd(db_expr_t, int, db_expr_t, char *);
void db_startproc_cmd(db_expr_t, int, db_expr_t, char *);
void db_stopproc_cmd(db_expr_t, int, db_expr_t, char *);
void db_ddbproc_cmd(db_expr_t, int, db_expr_t, char *);
#endif

/*
 * Received keyboard interrupt sequence.
 */
void
kdb_kbd_trap(tf)
	struct trapframe64 *tf;
{
	if (db_active == 0 /* && (boothowto & RB_KDB) */) {
		printf("\n\nkernel: keyboard interrupt tf=%p\n", tf);
		db_ktrap(-1, tf);
	}
}

/*
 *  db_ktrap - field a TRACE or BPT trap
 */
int
db_ktrap(type, tf)
	int	type;
	register struct trapframe64 *tf;
{
	int s, tl;
	struct trapstate *ts = &ddb_regs.ddb_ts[0];
	extern int savetstate(struct trapstate *ts);
	extern void restoretstate(int tl, struct trapstate *ts);

#if NTDA > 0
	tda_full_blast();
#endif

	fb_unblank();

	switch (type) {
	case T_BREAKPOINT:	/* breakpoint */
	case -1:		/* keyboard interrupt */
		break;
	default:
		printf("kernel trap %x: %s\n", type, trap_type[type & 0x1ff]);
		if (db_recover != 0) {
			OF_enter();
			db_error("Faulted in DDB; continuing...\n");
			OF_enter();
			/*NOTREACHED*/
		}
		db_recover = (label_t *)1;
	}

#ifdef MULTIPROCESSOR
	mtx_enter(&ddb_mp_mutex);
	if (ddb_state == DDB_STATE_EXITING)
		ddb_state = DDB_STATE_NOT_RUNNING;
	mtx_leave(&ddb_mp_mutex);
	while (db_enter_ddb()) {
#endif

	/* Should switch to kdb`s own stack here. */
	write_all_windows();

	ddb_regs.ddb_tf = *tf;
	if (fpproc) {
		savefpstate(fpproc->p_md.md_fpstate);
		ddb_regs.ddb_fpstate = *fpproc->p_md.md_fpstate;
		loadfpstate(fpproc->p_md.md_fpstate);
	}

	s = splhigh();
	db_active++;
	cnpollc(TRUE);
	/* Need to do spl stuff till cnpollc works */
	tl = ddb_regs.ddb_tl = savetstate(ts);
	db_dump_ts(0, 0, 0, 0);
	db_trap(type, 0/*code*/);
	restoretstate(tl,ts);
	cnpollc(FALSE);
	db_active--;
	splx(s);

	if (fpproc) {
		*fpproc->p_md.md_fpstate = ddb_regs.ddb_fpstate;
		loadfpstate(fpproc->p_md.md_fpstate);
	}
#if 0
	/* We will not alter the machine's running state until we get everything else working */
	*(struct frame *)tf->tf_out[6] = ddb_regs.ddb_fr;
#endif
	*tf = ddb_regs.ddb_tf;

#ifdef MULTIPROCESSOR
		if (!db_switch_cpu)
			ddb_state = DDB_STATE_EXITING;
	}
#endif

	return (1);
}

#ifdef MULTIPROCESSOR

void ipi_db(void);

void
db_cpuinfo_cmd(db_expr_t addr, int have_addr, db_expr_t count, char *modif)
{
	struct cpu_info *ci;

	for (ci = cpus; ci != NULL; ci = ci->ci_next) {
		db_printf("%c%4d: ", (ci == curcpu()) ? '*' : ' ',
		    ci->ci_number);
		switch(ci->ci_ddb_paused) {
		case CI_DDB_RUNNING:
			db_printf("running\n");
			break;
		case CI_DDB_SHOULDSTOP:
			db_printf("stopping\n");
			break;
		case CI_DDB_STOPPED:
			db_printf("stopped\n");
			break;
		case CI_DDB_ENTERDDB:
			db_printf("entering ddb\n");
			break;
		case CI_DDB_INDDB:
			db_printf("ddb\n");
			break;
		default:
			db_printf("? (%d)\n",
			    ci->ci_ddb_paused);
			break;
		}
	}
}

void
db_startproc_cmd(db_expr_t addr, int have_addr, db_expr_t count, char *modif)
{
	struct cpu_info *ci;

	if (have_addr) {
		for (ci = cpus; ci != NULL; ci = ci->ci_next) {
			if (addr == ci->ci_number) {
				db_startcpu(ci);
				break;
			}
		}
		if (ci == NULL)
			db_printf("Invalid cpu %d\n", (int)addr);
	} else {
		for (ci = cpus; ci != NULL; ci = ci->ci_next) {
			if (ci != curcpu())
				db_startcpu(ci);
		}
	}
}

void
db_stopproc_cmd(db_expr_t addr, int have_addr, db_expr_t count, char *modif)
{
	struct cpu_info *ci;

	if (have_addr) {
		for (ci = cpus; ci != NULL; ci = ci->ci_next) {
			if (addr == ci->ci_number) {
				db_stopcpu(ci);
				break;
			}
		}
		if (ci == NULL)
			db_printf("Invalid cpu %d\n", (int)addr);
	} else {
		for (ci = cpus; ci != NULL; ci = ci->ci_next) {
			if (ci != curcpu())
				db_stopcpu(ci);
		}
	}
}

void
db_ddbproc_cmd(db_expr_t addr, int have_addr, db_expr_t count, char *modif)
{
	struct cpu_info *ci;

	if (have_addr) {
		for (ci = cpus; ci != NULL; ci = ci->ci_next) {
			if (addr == ci->ci_number && ci != curcpu()) {
				db_stopcpu(ci);
				db_switch_to_cpu = ci;
				db_switch_cpu = 1;
				db_cmd_loop_done = 1;
				break;
			}
		}
		if (ci == NULL)
			db_printf("Invalid cpu %d\n", (int)addr);
	} else {
		db_printf("CPU not specified\n");
	}
}

int
db_enter_ddb(void)
{
	struct cpu_info *ci;

	mtx_enter(&ddb_mp_mutex);

	/* If we are first in, grab ddb and stop all other CPUs */
	if (ddb_state == DDB_STATE_NOT_RUNNING) {
		ddb_active_cpu = cpu_number();
		ddb_state = DDB_STATE_RUNNING;
		curcpu()->ci_ddb_paused = CI_DDB_INDDB;
		mtx_leave(&ddb_mp_mutex);
		for (ci = cpus; ci != NULL; ci = ci->ci_next) {
			if (ci != curcpu() &&
			    ci->ci_ddb_paused != CI_DDB_STOPPED) {
				ci->ci_ddb_paused = CI_DDB_SHOULDSTOP;
				sparc64_send_ipi(ci->ci_itid, ipi_db, 0, 0);
			}
		}
		return (1);
	}

	/* Leaving ddb completely.  Start all other CPUs and return 0 */
	if (ddb_active_cpu == cpu_number() && ddb_state == DDB_STATE_EXITING) {
		for (ci = cpus; ci != NULL; ci = ci->ci_next)
			ci->ci_ddb_paused = CI_DDB_RUNNING;
		mtx_leave(&ddb_mp_mutex);
		return (0);
	}

	/* We're switching to another CPU.  db_ddbproc_cmd() has made sure
	 * it is waiting for ddb, we just have to set ddb_active_cpu. */
	if (ddb_active_cpu == cpu_number() && db_switch_cpu) {
		curcpu()->ci_ddb_paused = CI_DDB_SHOULDSTOP;
		db_switch_cpu = 0;
		ddb_active_cpu = db_switch_to_cpu->ci_number;
		db_switch_to_cpu->ci_ddb_paused = CI_DDB_ENTERDDB;
	}

	/* Wait until we should enter ddb or resume */
	while (ddb_active_cpu != cpu_number() &&
	    curcpu()->ci_ddb_paused != CI_DDB_RUNNING) {
		if (curcpu()->ci_ddb_paused == CI_DDB_SHOULDSTOP)
			curcpu()->ci_ddb_paused = CI_DDB_STOPPED;
		mtx_leave(&ddb_mp_mutex);

		/* Busy wait without locking, we'll confirm with lock later */
		while (ddb_active_cpu != cpu_number() &&
		    curcpu()->ci_ddb_paused != CI_DDB_RUNNING)
			CPU_BUSY_CYCLE();

		mtx_enter(&ddb_mp_mutex);
	}

	/* Either enter ddb or exit */
	if (ddb_active_cpu == cpu_number() && ddb_state == DDB_STATE_RUNNING) {
		curcpu()->ci_ddb_paused = CI_DDB_INDDB;
		mtx_leave(&ddb_mp_mutex);
		return (1);
	} else {
		mtx_leave(&ddb_mp_mutex);
		return (0);
	}
}

void
db_startcpu(struct cpu_info *ci)
{
	if (ci != curcpu()) {
		mtx_enter(&ddb_mp_mutex);
		ci->ci_ddb_paused = CI_DDB_RUNNING;
		mtx_leave(&ddb_mp_mutex);
	}
}

void
db_stopcpu(struct cpu_info *ci)
{
	mtx_enter(&ddb_mp_mutex);
	if (ci != curcpu() && ci->ci_ddb_paused != CI_DDB_STOPPED) {
		ci->ci_ddb_paused = CI_DDB_SHOULDSTOP;
		mtx_leave(&ddb_mp_mutex);
		sparc64_send_ipi(ci->ci_itid, ipi_db, 0, 0);
	} else {
		mtx_leave(&ddb_mp_mutex);
	}
}

#endif

/*
 * Read bytes from kernel address space for debugger.
 */
void
db_read_bytes(addr, size, data)
	vaddr_t	addr;
	register size_t	size;
	register char	*data;
{
	register char	*src;

	src = (char *)addr;
	while (size-- > 0) {
		if (src >= (char *)VM_MIN_KERNEL_ADDRESS)
			*data++ = probeget((paddr_t)(u_long)src++, ASI_P, 1);
		else
			copyin(src++, data++, sizeof(u_char));
	}
}


/*
 * Write bytes to kernel address space for debugger.
 */
void
db_write_bytes(addr, size, data)
	vaddr_t	addr;
	register size_t	size;
	register char	*data;
{
	register char	*dst;
	extern vaddr_t ktext;
	extern paddr_t ktextp;

	dst = (char *)addr;
	while (size-- > 0) {
		if ((dst >= (char *)VM_MIN_KERNEL_ADDRESS+0x800000))
			*dst = *data;
		else if ((dst >= (char *)VM_MIN_KERNEL_ADDRESS) &&
			 (dst < (char *)VM_MIN_KERNEL_ADDRESS+0x800000))
			/* Read Only mapping -- need to do a bypass access */
			stba((u_long)dst - ktext + ktextp, ASI_PHYS_CACHED, *data);
		else
			copyout(data, dst, sizeof(char));
		dst++, data++;
	}

}

void
db_enter(void)
{
	/* We use the breakpoint to trap into DDB */
	asm("ta 1; nop");
}

void
db_prom_cmd(addr, have_addr, count, modif)
	db_expr_t addr;
	int have_addr;
	db_expr_t count;
	char *modif;
{
	OF_enter();
}

#define CHEETAHP (((getver()>>32) & 0x1ff) >= 0x14)
unsigned long db_get_dtlb_data(int entry), db_get_dtlb_tag(int entry),
db_get_itlb_data(int entry), db_get_itlb_tag(int entry);
void db_print_itlb_entry(int entry, int i, int endc);
void db_print_dtlb_entry(int entry, int i, int endc);

extern __inline__ unsigned long db_get_dtlb_data(int entry)
{
	unsigned long r;
	__asm__ volatile("ldxa [%1] %2,%0"
		: "=r" (r)
		: "r" (entry <<3), "i" (ASI_DMMU_TLB_DATA));
	return r;
}
extern __inline__ unsigned long db_get_dtlb_tag(int entry)
{
	unsigned long r;
	__asm__ volatile("ldxa [%1] %2,%0"
		: "=r" (r)
		: "r" (entry <<3), "i" (ASI_DMMU_TLB_TAG));
	return r;
}
extern __inline__ unsigned long db_get_itlb_data(int entry)
{
	unsigned long r;
	__asm__ volatile("ldxa [%1] %2,%0"
		: "=r" (r)
		: "r" (entry <<3), "i" (ASI_IMMU_TLB_DATA));
	return r;
}
extern __inline__ unsigned long db_get_itlb_tag(int entry)
{
	unsigned long r;
	__asm__ volatile("ldxa [%1] %2,%0"
		: "=r" (r)
		: "r" (entry <<3), "i" (ASI_IMMU_TLB_TAG));
	return r;
}

void db_print_dtlb_entry(int entry, int i, int endc)
{
	unsigned long tag, data;
	tag = db_get_dtlb_tag(entry);
	data = db_get_dtlb_data(entry);
	db_printf("%2d:%16.16lx %16.16lx%c", i, tag, data, endc);
}

void db_print_itlb_entry(int entry, int i, int endc)
{
	unsigned long tag, data;
	tag = db_get_itlb_tag(entry);
	data = db_get_itlb_data(entry);
	db_printf("%2d:%16.16lx %16.16lx%c", i, tag, data, endc);
}

void
db_dump_dtlb(addr, have_addr, count, modif)
	db_expr_t addr;
	int have_addr;
	db_expr_t count;
	char *modif;
{
	/* extern void print_dtlb(void); -- locore.s; no longer used here */

	if (have_addr) {
		int i;
		int64_t* p = (int64_t*)addr;
		static int64_t buf[128];
		extern void dump_dtlb(int64_t *);

	if (CHEETAHP) {
		db_printf("DTLB %ld\n", addr);
		switch(addr)
		{
		case 0:
			for (i = 0; i < 16; ++i)
				db_print_dtlb_entry(i, i, (i&1)?'\n':' ');
			break;
		case 2:
			for (i = 0; i < 512; ++i)
				db_print_dtlb_entry(i+16384, i, (i&1)?'\n':' ');
			break;
		}
	} else {
		dump_dtlb(buf);
		p = buf;
		for (i=0; i<64;) {
			db_printf("%2d:%16.16llx %16.16llx ", i++, p[0], p[1]);
			p += 2;
			db_printf("%2d:%16.16llx %16.16llx\n", i++, p[0], p[1]);
			p += 2;
		}
	}
	} else {
printf ("Usage: mach dtlb 0,2\n");
	}
}

void
db_dump_itlb(addr, have_addr, count, modif)
	db_expr_t addr;
	int have_addr;
	db_expr_t count;
	char *modif;
{
	int i;
	if (!have_addr) {
		db_printf("Usage: mach itlb 0,1,2\n");
		return;
	}
	if (CHEETAHP) {
		db_printf("ITLB %ld\n", addr);
		switch(addr)
		{
		case 0:
			for (i = 0; i < 16; ++i)
				db_print_itlb_entry(i, i, (i&1)?'\n':' ');
			break;
		case 2:
			for (i = 0; i < 128; ++i)
				db_print_itlb_entry(i+16384, i, (i&1)?'\n':' ');
			break;
		}
	} else {
		for (i = 0; i < 63; ++i)
			db_print_itlb_entry(i, i, (i&1)?'\n':' ');
	}
}

void
db_pload_cmd(addr, have_addr, count, modif)
	db_expr_t addr;
	int have_addr;
	db_expr_t count;
	char *modif;
{
	static paddr_t oldaddr = -1;
	int asi = ASI_PHYS_CACHED;

	if (!have_addr) {
		addr = oldaddr;
	}
	if (addr == -1) {
		db_printf("no address\n");
		return;
	}
	addr &= ~0x7; /* align */
	{
		register char c, *cp = modif;
		while ((c = *cp++) != 0)
			if (c == 'u')
				asi = ASI_AIUS;
	}
	while (count--) {
		if (db_print_position() == 0) {
			/* Always print the address. */
			db_printf("%16.16lx:\t", addr);
		}
		oldaddr=addr;
		db_printf("%8.8lx\n", (long)ldxa(addr, asi));
		addr += 8;
		if (db_print_position() != 0)
			db_end_line(0);
	}
}

int64_t pseg_get(struct pmap *, vaddr_t);

void
db_dump_pmap(pm)
struct pmap* pm;
{
	/* print all valid pages in the kernel pmap */
	long i, j, k, n;
	paddr_t *pdir, *ptbl;
	/* Almost the same as pmap_collect() */

	n = 0;
	for (i=0; i<STSZ; i++) {
		if((pdir = (paddr_t *)(u_long)ldxa((vaddr_t)&pm->pm_segs[i], ASI_PHYS_CACHED))) {
			db_printf("pdir %ld at %lx:\n", i, (long)pdir);
			for (k=0; k<PDSZ; k++) {
				if ((ptbl = (paddr_t *)(u_long)ldxa((vaddr_t)&pdir[k], ASI_PHYS_CACHED))) {
					db_printf("\tptable %ld:%ld at %lx:\n", i, k, (long)ptbl);
					for (j=0; j<PTSZ; j++) {
						int64_t data0, data1;
						data0 = ldxa((vaddr_t)&ptbl[j], ASI_PHYS_CACHED);
						j++;
						data1 = ldxa((vaddr_t)&ptbl[j], ASI_PHYS_CACHED);
						if (data0 || data1) {
							db_printf("%llx: %llx\t",
								  (unsigned long long)(((u_int64_t)i<<STSHIFT)|(k<<PDSHIFT)|((j-1)<<PTSHIFT)),
								  (unsigned long long)(data0));
							db_printf("%llx: %llx\n",
								  (unsigned long long)(((u_int64_t)i<<STSHIFT)|(k<<PDSHIFT)|(j<<PTSHIFT)),
								  (unsigned long long)(data1));
						}
					}
				}
			}
		}
	}
}

void
db_pmap_kernel(addr, have_addr, count, modif)
	db_expr_t addr;
	int have_addr;
	db_expr_t count;
	char *modif;
{
	extern struct pmap kernel_pmap_;
	int i, j, full = 0;
	u_int64_t data;

	{
		register char c, *cp = modif;
		while ((c = *cp++) != 0)
			if (c == 'f')
				full = 1;
	}
	if (have_addr) {
		/* lookup an entry for this VA */

		if ((data = pseg_get(&kernel_pmap_, (vaddr_t)addr))) {
			db_printf("pmap_kernel(%p)->pm_segs[%lx][%lx][%lx]=>%llx\n",
				  (void *)addr, (u_long)va_to_seg(addr),
				  (u_long)va_to_dir(addr), (u_long)va_to_pte(addr),
				  (unsigned long long)data);
		} else {
			db_printf("No mapping for %p\n", (void *)addr);
		}
		return;
	}

	db_printf("pmap_kernel(%p) psegs %p phys %llx\n",
		  &kernel_pmap_, kernel_pmap_.pm_segs,
		  (unsigned long long)kernel_pmap_.pm_physaddr);
	if (full) {
		db_dump_pmap(&kernel_pmap_);
	} else {
		for (j=i=0; i<STSZ; i++) {
			long seg = (long)ldxa((vaddr_t)&kernel_pmap_.pm_segs[i], ASI_PHYS_CACHED);
			if (seg)
				db_printf("seg %d => %lx%c", i, seg, (j++%4)?'\t':'\n');
		}
	}
}


void
db_pmap_cmd(addr, have_addr, count, modif)
	db_expr_t addr;
	int have_addr;
	db_expr_t count;
	char *modif;
{
	struct pmap* pm=NULL;
	int i, j=0, full = 0;

	{
		register char c, *cp = modif;
		if (modif)
			while ((c = *cp++) != 0)
				if (c == 'f')
					full = 1;
	}
	if (curproc && curproc->p_vmspace)
		pm = curproc->p_vmspace->vm_map.pmap;
	if (have_addr) {
		pm = (struct pmap*)addr;
	}

	db_printf("pmap %p: ctx %x refs %d physaddr %llx psegs %p\n",
		pm, pm->pm_ctx, pm->pm_refs,
		(unsigned long long)pm->pm_physaddr, pm->pm_segs);

	if (full) {
		db_dump_pmap(pm);
	} else {
		for (i=0; i<STSZ; i++) {
			long seg = (long)ldxa((vaddr_t)&kernel_pmap_.pm_segs[i], ASI_PHYS_CACHED);
			if (seg)
				db_printf("seg %d => %lx%c", i, seg, (j++%4)?'\t':'\n');
		}
	}
}


void
db_lock(addr, have_addr, count, modif)
	db_expr_t addr;
	int have_addr;
	db_expr_t count;
	char *modif;
{
#if 0
	struct lock *l;

	if (!have_addr) {
		db_printf("What lock address?\n");
		return;
	}

	l = (struct lock *)addr;
	db_printf("flags=%x\n waitcount=%x sharecount=%x "
	    "exclusivecount=%x\n wmesg=%s recurselevel=%x\n",
	    l->lk_flags, l->lk_waitcount,
	    l->lk_sharecount, l->lk_exclusivecount, l->lk_wmesg,
	    l->lk_recurselevel);
#else
	db_printf("locks unsupported\n");
#endif
}

void
db_dump_dtsb(addr, have_addr, count, modif)
	db_expr_t addr;
	int have_addr;
	db_expr_t count;
	char *modif;
{
	extern pte_t *tsb_dmmu;
	extern int tsbsize;
#define TSBENTS (512<<tsbsize)
	int i;

	db_printf("TSB:\n");
	for (i=0; i<TSBENTS; i++) {
		db_printf("%4d:%4d:%08x %08x:%08x ", i,
			  (int)((tsb_dmmu[i].tag&TSB_TAG_G)?-1:TSB_TAG_CTX(tsb_dmmu[i].tag)),
			  (int)((i<<13)|TSB_TAG_VA(tsb_dmmu[i].tag)),
			  (int)(tsb_dmmu[i].data>>32), (int)tsb_dmmu[i].data);
		i++;
		db_printf("%4d:%4d:%08x %08x:%08x\n", i,
			  (int)((tsb_dmmu[i].tag&TSB_TAG_G)?-1:TSB_TAG_CTX(tsb_dmmu[i].tag)),
			  (int)((i<<13)|TSB_TAG_VA(tsb_dmmu[i].tag)),
			  (int)(tsb_dmmu[i].data>>32), (int)tsb_dmmu[i].data);
	}
}

void db_page_cmd(db_expr_t, int, db_expr_t, char *);
void
db_page_cmd(addr, have_addr, count, modif)
	db_expr_t addr;
	int have_addr;
	db_expr_t count;
	char *modif;
{

	if (!have_addr) {
		db_printf("Need paddr for page\n");
		return;
	}

	db_printf("pa %llx pg %p\n", (unsigned long long)addr,
	    PHYS_TO_VM_PAGE(addr));
}


void
db_proc_cmd(addr, have_addr, count, modif)
	db_expr_t addr;
	int have_addr;
	db_expr_t count;
	char *modif;
{
	struct proc *p;

	p = curproc;
	if (have_addr)
		p = (struct proc*) addr;
	if (p == NULL) {
		db_printf("no current process\n");
		return;
	}
	db_printf("process %p:", p);
	db_printf("pid:%d vmspace:%p pmap:%p ctx:%x wchan:%p pri:%d upri:%d\n",
	    p->p_p->ps_pid, p->p_vmspace, p->p_vmspace->vm_map.pmap,
	    p->p_vmspace->vm_map.pmap->pm_ctx,
	    p->p_wchan, p->p_priority, p->p_usrpri);
	db_printf("maxsaddr:%p ssiz:%dpg or %llxB\n",
	    p->p_vmspace->vm_maxsaddr, p->p_vmspace->vm_ssize,
	    (unsigned long long)ptoa(p->p_vmspace->vm_ssize));
	db_printf("profile timer: %lld sec %ld usec\n",
	    (long long)p->p_p->ps_timer[ITIMER_PROF].it_value.tv_sec,
	    p->p_p->ps_timer[ITIMER_PROF].it_value.tv_usec);
	db_printf("pcb: %p tf: %p fpstate: %p\n", &p->p_addr->u_pcb,
	    p->p_md.md_tf, p->p_md.md_fpstate);
	return;
}

void
db_ctx_cmd(addr, have_addr, count, modif)
	db_expr_t addr;
	int have_addr;
	db_expr_t count;
	char *modif;
{
	struct proc *p;

	/* XXX LOCKING XXX */
	LIST_FOREACH(p, &allproc, p_list) {
		if (p->p_stat) {
			db_printf("process %p:", p);
			db_printf("pid:%d pmap:%p ctx:%x tf:%p fpstate %p "
			    "lastcall:%s\n",
			    p->p_p->ps_pid, p->p_vmspace->vm_map.pmap,
			    p->p_vmspace->vm_map.pmap->pm_ctx,
			    p->p_md.md_tf, p->p_md.md_fpstate,
			    (p->p_addr->u_pcb.lastcall)?
			    p->p_addr->u_pcb.lastcall : "Null");
		}
	}
	return;
}

void
db_dump_pcb(addr, have_addr, count, modif)
	db_expr_t addr;
	int have_addr;
	db_expr_t count;
	char *modif;
{
	struct pcb *pcb;
	int i;

	pcb = curpcb;
	if (have_addr)
		pcb = (struct pcb*) addr;

	db_printf("pcb@@%p sp:%p pc:%p cwp:%d pil:%d nsaved:%x onfault:%p\nlastcall:%s\nfull windows:\n",
		  pcb, (void *)(long)pcb->pcb_sp, (void *)(long)pcb->pcb_pc, pcb->pcb_cwp,
		  pcb->pcb_pil, pcb->pcb_nsaved, (void *)pcb->pcb_onfault,
		  (pcb->lastcall)?pcb->lastcall:"Null");

	for (i=0; i<pcb->pcb_nsaved; i++) {
		db_printf("win %d: at %llx local, in\n", i,
			  (unsigned long long)pcb->pcb_rwsp[i]);
		db_printf("%16llx %16llx %16llx %16llx\n",
			  (unsigned long long)pcb->pcb_rw[i].rw_local[0],
			  (unsigned long long)pcb->pcb_rw[i].rw_local[1],
			  (unsigned long long)pcb->pcb_rw[i].rw_local[2],
			  (unsigned long long)pcb->pcb_rw[i].rw_local[3]);
		db_printf("%16llx %16llx %16llx %16llx\n",
			  (unsigned long long)pcb->pcb_rw[i].rw_local[4],
			  (unsigned long long)pcb->pcb_rw[i].rw_local[5],
			  (unsigned long long)pcb->pcb_rw[i].rw_local[6],
			  (unsigned long long)pcb->pcb_rw[i].rw_local[7]);
		db_printf("%16llx %16llx %16llx %16llx\n",
			  (unsigned long long)pcb->pcb_rw[i].rw_in[0],
			  (unsigned long long)pcb->pcb_rw[i].rw_in[1],
			  (unsigned long long)pcb->pcb_rw[i].rw_in[2],
			  (unsigned long long)pcb->pcb_rw[i].rw_in[3]);
		db_printf("%16llx %16llx %16llx %16llx\n",
			  (unsigned long long)pcb->pcb_rw[i].rw_in[4],
			  (unsigned long long)pcb->pcb_rw[i].rw_in[5],
			  (unsigned long long)pcb->pcb_rw[i].rw_in[6],
			  (unsigned long long)pcb->pcb_rw[i].rw_in[7]);
	}
}


void
db_setpcb(addr, have_addr, count, modif)
	db_expr_t addr;
	int have_addr;
	db_expr_t count;
	char *modif;
{
	struct proc *p;

	if (!have_addr) {
		db_printf("What TID do you want to map in?\n");
		return;
	}

	LIST_FOREACH(p, &allproc, p_list) {
		if (p->p_stat && p->p_tid == addr) {
			curproc = p;
			curpcb = (struct pcb*)p->p_addr;
			if (p->p_vmspace->vm_map.pmap->pm_ctx) {
				switchtoctx(p->p_vmspace->vm_map.pmap->pm_ctx);
				return;
			}
			db_printf("TID %ld has a null context.\n", addr);
			return;
		}
	}
	db_printf("TID %ld not found.\n", addr);
}


/*
 * Use physical or virtual watchpoint registers -- ugh
 */
void
db_watch(addr, have_addr, count, modif)
	db_expr_t addr;
	int have_addr;
	db_expr_t count;
	char *modif;
{
	int phys = 0;

#define WATCH_VR	(1L<<22)
#define WATCH_VW	(1L<<21)
#define WATCH_PR	(1L<<24)
#define WATCH_PW	(1L<<23)
#define WATCH_PM	(((u_int64_t)0xffffL)<<33)
#define WATCH_VM	(((u_int64_t)0xffffL)<<25)

	{
		register char c, *cp = modif;
		if (modif)
			while ((c = *cp++) != 0)
				if (c == 'p')
					phys = 1;
	}
	if (have_addr) {
		/* turn on the watchpoint */
		int64_t tmp = ldxa(0, ASI_MCCR);

		if (phys) {
			tmp &= ~(WATCH_PM|WATCH_PR|WATCH_PW);
			stxa(PHYSICAL_WATCHPOINT, ASI_DMMU, addr);
		} else {
			tmp &= ~(WATCH_VM|WATCH_VR|WATCH_VW);
			stxa(VIRTUAL_WATCHPOINT, ASI_DMMU, addr);
		}
		stxa(0, ASI_MCCR, tmp);
	} else {
		/* turn off the watchpoint */
		int64_t tmp = ldxa(0, ASI_MCCR);
		if (phys) tmp &= ~(WATCH_PM);
		else tmp &= ~(WATCH_VM);
		stxa(0, ASI_MCCR, tmp);
	}
}

/*
 * Provide a way to trigger an External Initiated Reset (XIR).  Some
 * systems can target individual processors, others can only target
 * all processors at once.
 */

struct xirhand {
	void (*xh_fun)(void *, int);
	void *xh_arg;
	SIMPLEQ_ENTRY(xirhand) xh_list;
};

SIMPLEQ_HEAD(, xirhand) db_xh = SIMPLEQ_HEAD_INITIALIZER(db_xh);

void
db_xir(db_expr_t addr, int have_addr, db_expr_t count, char *modif)
{
	struct xirhand *xh;

	if (!have_addr)
		addr = -1;

	SIMPLEQ_FOREACH(xh, &db_xh, xh_list) {
		xh->xh_fun(xh->xh_arg, addr);
	}
}

void
db_register_xir(void (*fun)(void *, int), void *arg)
{
	struct xirhand *xh;

	xh = malloc(sizeof(*xh), M_DEVBUF, M_NOWAIT);
	if (xh == NULL)
		panic("db_register_xir");
	xh->xh_fun = fun;
	xh->xh_arg = arg;
	SIMPLEQ_INSERT_TAIL(&db_xh, xh, xh_list);
}


#if NESP_SBUS
extern void db_esp(db_expr_t, int, db_expr_t, char *);
#endif

struct db_command db_machine_command_table[] = {
	{ "ctx",	db_ctx_cmd,	0,	0 },
	{ "dtlb",	db_dump_dtlb,	0,	0 },
	{ "dtsb",	db_dump_dtsb,	0,	0 },
#if NESP_SBUS
	{ "esp",	db_esp,		0,	0 },
#endif
	{ "fpstate",	db_dump_fpstate,0,	0 },
	{ "itlb",	db_dump_itlb,	0,	0 },
	{ "kmap",	db_pmap_kernel,	0,	0 },
	{ "lock",	db_lock,	0,	0 },
	{ "pcb",	db_dump_pcb,	0,	0 },
	{ "pctx",	db_setpcb,	0,	0 },
	{ "page",	db_page_cmd,	0,	0 },
	{ "phys",	db_pload_cmd,	0,	0 },
	{ "pmap",	db_pmap_cmd,	0,	0 },
	{ "proc",	db_proc_cmd,	0,	0 },
	{ "prom",	db_prom_cmd,	0,	0 },
	{ "pv",		db_dump_pv,	0,	0 },
	{ "stack",	db_dump_stack,	0,	0 },
	{ "tf",		db_dump_trap,	0,	0 },
	{ "ts",		db_dump_ts,	0,	0 },
	{ "watch",	db_watch,	0,	0 },
	{ "window",	db_dump_window,	0,	0 },
	{ "xir",	db_xir,		0,	0 },
#ifdef MULTIPROCESSOR
	{ "cpuinfo",	db_cpuinfo_cmd,		0,	0 },
	{ "startcpu",	db_startproc_cmd,	0,	0 },
	{ "stopcpu",	db_stopproc_cmd,	0,	0 },
	{ "ddbcpu",	db_ddbproc_cmd,		0,	0 },
#endif
	{ NULL, }
};

/*
 * support for SOFTWARE_SSTEP:
 * return the next pc if the given branch is taken.
 *
 * note: in the case of conditional branches with annul,
 * this actually returns the next pc in the "not taken" path,
 * but in that case next_instr_address() will return the
 * next pc in the "taken" path.  so even tho the breakpoints
 * are backwards, everything will still work, and the logic is
 * much simpler this way.
 */
db_addr_t
db_branch_taken(inst, pc, regs)
	int inst;
	db_addr_t pc;
	db_regs_t *regs;
{
    union instr insn;
    db_addr_t npc = ddb_regs.ddb_tf.tf_npc;

    insn.i_int = inst;

    /* the fancy union just gets in the way of this: */
    switch(inst & 0xffc00000) {
    case 0x30400000:	/* branch always, annul, with prediction */
	return pc + ((inst<<(32-19))>>((32-19)-2));
    case 0x30800000:	/* branch always, annul */
	return pc + ((inst<<(32-22))>>((32-22)-2));
    }

    /*
     * if this is not an annulled conditional branch, the next pc is "npc".
     */

    if (insn.i_any.i_op != IOP_OP2 || insn.i_branch.i_annul != 1)
	return npc;

    switch (insn.i_op2.i_op2) {
      case IOP2_Bicc:
      case IOP2_FBfcc:
      case IOP2_BPcc:
      case IOP2_FBPfcc:
      case IOP2_CBccc:
	/* branch on some condition-code */
	switch (insn.i_branch.i_cond)
	{
	  case Icc_A: /* always */
	    return pc + ((inst << 10) >> 8);

	  default: /* all other conditions */
	    return npc + 4;
	}

      case IOP2_BPr:
	/* branch on register, always conditional */
	return npc + 4;

      default:
	/* not a branch */
	panic("branch_taken() on non-branch");
    }
}

boolean_t
db_inst_branch(inst)
	int inst;
{
    union instr insn;

    insn.i_int = inst;

    /* the fancy union just gets in the way of this: */
    switch(inst & 0xffc00000) {
    case 0x30400000:	/* branch always, annul, with prediction */
	return TRUE;
    case 0x30800000:	/* branch always, annul */
	return TRUE;
    }

    if (insn.i_any.i_op != IOP_OP2)
	return FALSE;

    switch (insn.i_op2.i_op2) {
      case IOP2_BPcc:
      case IOP2_Bicc:
      case IOP2_BPr:
      case IOP2_FBPfcc:
      case IOP2_FBfcc:
      case IOP2_CBccc:
	return TRUE;

      default:
	return FALSE;
    }
}


boolean_t
db_inst_call(inst)
	int inst;
{
    union instr insn;

    insn.i_int = inst;

    switch (insn.i_any.i_op) {
      case IOP_CALL:
	return TRUE;

      case IOP_reg:
	return (insn.i_op3.i_op3 == IOP3_JMPL) && !db_inst_return(inst);

      default:
	return FALSE;
    }
}


boolean_t
db_inst_unconditional_flow_transfer(inst)
	int inst;
{
    union instr insn;

    insn.i_int = inst;

    if (db_inst_call(inst))
	return TRUE;

    if (insn.i_any.i_op != IOP_OP2)
	return FALSE;

    switch (insn.i_op2.i_op2)
    {
      case IOP2_BPcc:
      case IOP2_Bicc:
      case IOP2_FBPfcc:
      case IOP2_FBfcc:
      case IOP2_CBccc:
	return insn.i_branch.i_cond == Icc_A;

      default:
	return FALSE;
    }
}


boolean_t
db_inst_return(inst)
	int inst;
{
    return (inst == I_JMPLri(I_G0, I_O7, 8) ||		/* ret */
	    inst == I_JMPLri(I_G0, I_I7, 8));		/* retl */
}

boolean_t
db_inst_trap_return(inst)
	int inst;
{
    union instr insn;

    insn.i_int = inst;

    return (insn.i_any.i_op == IOP_reg &&
	    insn.i_op3.i_op3 == IOP3_RETT);
}

void
db_machine_init(void)
{
	db_machine_commands_install(db_machine_command_table);
}
@


1.47
log
@Split PID from TID, giving processes a PID unrelated to the TID of their
initial thread

ok jsing@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.46 2016/10/18 00:43:57 guenther Exp $	*/
d576 1
a576 1
Debugger(void)
@


1.46
log
@Delete remnants of "traptrace" support

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.45 2016/10/08 05:49:09 guenther Exp $	*/
d1065 1
a1065 1
		db_printf("What PID do you want to map in?\n");
d1070 1
a1070 1
		if (p->p_stat && p->p_pid == addr) {
d1077 1
a1077 1
			db_printf("PID %ld has a null context.\n", addr);
d1081 1
a1081 1
	db_printf("PID %ld not found.\n", addr);
@


1.45
log
@Various printf claim to report the PID, so actually report that and not the TID

Build testing assistance from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.44 2016/09/11 03:14:04 guenther Exp $	*/
a75 11
extern struct traptrace {
	unsigned short tl:3,	/* Trap level */
		ns:4,		/* PCB nsaved */
		tt:9;		/* Trap type */
	unsigned short pid;	/* PID */
	u_int tstate;		/* tstate */
	u_int tsp;		/* sp */
	u_int tpc;		/* pc */
	u_int tfault;		/* MMU tag access */
} trap_trace[], trap_trace_end[];

a222 1
void db_traptrace(db_expr_t, int, db_expr_t, char *);
a228 1
static void db_print_trace_entry(struct traptrace *, int);
a261 3
	extern int trap_trace_dis;

	trap_trace_dis++;
a322 1
	trap_trace_dis--;
a1083 72
static void
db_print_trace_entry(te, i)
	struct traptrace *te;
	int i;
{
	db_printf("%d:%d p:%d tt:%d:%llx:%llx %llx:%llx ", i,
		  (int)te->tl, (int)te->pid,
		  (int)te->tt, (unsigned long long)te->tstate,
		  (unsigned long long)te->tfault, (unsigned long long)te->tsp,
		  (unsigned long long)te->tpc);
	db_printsym((u_long)te->tpc, DB_STGY_PROC, db_printf);
	db_printf(": ");
	if ((te->tpc && !(te->tpc&0x3)) &&
	    curproc &&
	    (curproc->p_pid == te->pid)) {
		db_disasm((u_long)te->tpc, 0);
	} else db_printf("\n");
}

void
db_traptrace(addr, have_addr, count, modif)
	db_expr_t addr;
	int have_addr;
	db_expr_t count;
	char *modif;
{
	int i, start = 0, full = 0, reverse = 0;
	struct traptrace *end;

	start = 0;
	end = &trap_trace_end[0];

	{
		register char c, *cp = modif;
		if (modif)
			while ((c = *cp++) != 0) {
				if (c == 'f')
					full = 1;
				if (c == 'r')
					reverse = 1;
			}
	}

	if (have_addr) {
		start = addr / (sizeof (struct traptrace));
		if (&trap_trace[start] > &trap_trace_end[0]) {
			db_printf("Address out of range.\n");
			return;
		}
		if (!full) end =  &trap_trace[start+1];
	}

	db_printf("#:tl p:pid tt:tt:tstate:tfault sp:pc\n");
	if (reverse) {
		if (full && start)
			for (i=start; --i;) {
				db_print_trace_entry(&trap_trace[i], i);
			}
		i = (end - &trap_trace[0]);
		while(--i > start) {
			db_print_trace_entry(&trap_trace[i], i);
		}
	} else {
		for (i=start; &trap_trace[i] < end ; i++) {
			db_print_trace_entry(&trap_trace[i], i);
		}
		if (full && start)
			for (i=0; i < start ; i++) {
				db_print_trace_entry(&trap_trace[i], i);
			}
	}
}
a1198 1
	{ "traptrace",	db_traptrace,	0,	0 },
@


1.44
log
@Remove trailing whitespace

noted by jasper's emacs
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.43 2016/08/23 03:28:01 guenther Exp $	*/
d987 1
a987 1
	    p->p_pid, p->p_vmspace, p->p_vmspace->vm_map.pmap,
d1015 6
a1020 6
				"lastcall:%s\n",
				p->p_pid, p->p_vmspace->vm_map.pmap,
				p->p_vmspace->vm_map.pmap->pm_ctx,
				p->p_md.md_tf, p->p_md.md_fpstate,
				(p->p_addr->u_pcb.lastcall)?
				p->p_addr->u_pcb.lastcall : "Null");
@


1.43
log
@Convert %q to %ll in format strings

ok natano@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.42 2016/03/14 23:08:05 krw Exp $	*/
d330 1
a330 1
	if (fpproc) {	
d678 1
a678 1
	
d785 1
a785 1
	
d832 1
a832 1
		
d835 1
a835 1
				  (void *)addr, (u_long)va_to_seg(addr), 
d938 1
a938 1
		db_printf("%4d:%4d:%08x %08x:%08x ", i, 
d979 1
a979 1
	if (have_addr) 
d987 1
a987 1
	    p->p_pid, p->p_vmspace, p->p_vmspace->vm_map.pmap, 
d991 1
a991 1
	    p->p_vmspace->vm_maxsaddr, p->p_vmspace->vm_ssize, 
d996 1
a996 1
	db_printf("pcb: %p tf: %p fpstate: %p\n", &p->p_addr->u_pcb, 
d1037 1
a1037 1
	if (have_addr) 
d1044 1
a1044 1
	
d1046 1
a1046 1
		db_printf("win %d: at %llx local, in\n", i, 
d1085 1
a1085 1
    
d1106 3
a1108 3
	db_printf("%d:%d p:%d tt:%d:%llx:%llx %llx:%llx ", i, 
		  (int)te->tl, (int)te->pid, 
		  (int)te->tt, (unsigned long long)te->tstate, 
d1174 1
a1174 1
/* 
d1203 1
a1203 1
		
@


1.42
log
@Change a bunch of (<blah> *)0 to NULL.

ok beck@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.41 2016/03/07 13:21:51 naddy Exp $	*/
d834 1
a834 1
			db_printf("pmap_kernel(%p)->pm_segs[%lx][%lx][%lx]=>%qx\n",
@


1.41
log
@Sync no-argument function declaration and definition by adding (void).
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.40 2016/02/27 13:08:07 mpi Exp $	*/
d1298 1
a1298 1
	{ (char *)0, }
@


1.40
log
@Rename kdb_trap() into db_ktrap().

The goal is to include it in the list of functions that must not be
instrumented.  All ddb(8) functions should be in this list and have
their names start with 'db_'.

ok visa@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.39 2015/08/28 23:28:39 kettenis Exp $	*/
d593 1
a593 1
Debugger()
d1469 1
a1469 1
db_machine_init()
@


1.39
log
@Add support for switching CPUs in ddb on sparc64.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.38 2015/08/28 22:17:14 kettenis Exp $	*/
d259 1
a259 1
		kdb_trap(-1, tf);
d264 1
a264 1
 *  kdb_trap - field a TRACE or BPT trap
d267 1
a267 1
kdb_trap(type, tf)
@


1.38
log
@These days, we have two 4MB pages of read-only kernel memory.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.37 2015/08/26 13:59:24 kettenis Exp $	*/
d49 1
d64 8
d243 6
a286 3
		printf("kdb breakpoint at %llx\n",
		    (unsigned long long)tf->tf_pc);
		break;
a287 1
		printf("kdb tf=%p\n", tf);
d300 8
d341 6
d350 193
d1292 6
@


1.37
log
@Kill code that tries to handle 32-bit code that we're never going to use.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.36 2014/07/13 12:11:01 jasper Exp $	*/
d361 1
a361 1
		if ((dst >= (char *)VM_MIN_KERNEL_ADDRESS+0x400000))
d364 1
a364 1
			 (dst < (char *)VM_MIN_KERNEL_ADDRESS+0x400000))
@


1.36
log
@use nitems() instead of handrolling something identical

ok mpi@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.35 2014/05/10 18:46:20 kettenis Exp $	*/
a297 27
	/* We should do a proper copyin and xlate 64-bit stack frames, but... */
/*	if (tf->tf_tstate & TSTATE_PRIV) { */
	
#if 0
	/* make sure this is not causing ddb problems. */
	if (tf->tf_out[6] & 1) {
		if ((unsigned)(tf->tf_out[6] + BIAS) > (unsigned)KERNBASE)
			ddb_regs.ddb_fr = *(struct frame64 *)(tf->tf_out[6] + BIAS);
		else
			copyin((caddr_t)(tf->tf_out[6] + BIAS), &ddb_regs.ddb_fr, sizeof(struct frame64));
	} else {
		struct frame32 tfr;
		
		/* First get a local copy of the frame32 */
		if ((unsigned)(tf->tf_out[6]) > (unsigned)KERNBASE)
			tfr = *(struct frame32 *)tf->tf_out[6];
		else
			copyin((caddr_t)(tf->tf_out[6]), &tfr, sizeof(struct frame32));
		/* Now copy each field from the 32-bit value to the 64-bit value */
		for (i=0; i<8; i++)
			ddb_regs.ddb_fr.fr_local[i] = tfr.fr_local[i];
		for (i=0; i<6; i++)
			ddb_regs.ddb_fr.fr_arg[i] = tfr.fr_arg[i];
		ddb_regs.ddb_fr.fr_fp = (long)tfr.fr_fp;
		ddb_regs.ddb_fr.fr_pc = tfr.fr_pc;
	}
#endif
@


1.35
log
@We print time_t by casting to "long long" even in the kernel.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.34 2014/04/03 09:15:06 mpi Exp $	*/
d198 1
a198 1
struct db_variable *db_eregs = db_regs + sizeof(db_regs)/sizeof(db_regs[0]);
@


1.34
log
@Use <uvm/uvm_extern.h> if it's enough.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.33 2014/03/29 18:09:30 guenther Exp $	*/
d802 2
a803 2
	db_printf("profile timer: %ld sec %ld usec\n",
	    p->p_p->ps_timer[ITIMER_PROF].it_value.tv_sec,
@


1.33
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.32 2012/03/23 15:51:26 guenther Exp $	*/
a38 2
#include <uvm/uvm.h>

a1097 3
#ifdef UVMHIST
	{ "uvmdump",	db_uvmhistdump,	0,	0 },
#endif
@


1.32
log
@Make rusage totals, itimers, and profile settings per-process instead
of per-rthread.  Handling of per-thread tick and runtime counters
inspired by how FreeBSD does it.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.31 2011/07/03 18:34:14 oga Exp $	*/
d429 1
a429 1
	__asm__ __volatile__("ldxa [%1] %2,%0"
d437 1
a437 1
	__asm__ __volatile__("ldxa [%1] %2,%0"
d445 1
a445 1
	__asm__ __volatile__("ldxa [%1] %2,%0"
d453 1
a453 1
	__asm__ __volatile__("ldxa [%1] %2,%0"
@


1.31
log
@Rip out and burn support for UVM_HIST.

The vm hackers don't use it, don't maintain it and have to look at it all the
time. About time this 800 lines of code hit /dev/null.

``never liked it'' tedu@@. ariane@@ was very happy when i told her i wrote
this diff.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.30 2010/11/27 19:57:23 miod Exp $	*/
d805 2
a806 2
	    p->p_stats->p_timer[ITIMER_PROF].it_value.tv_sec,
	    p->p_stats->p_timer[ITIMER_PROF].it_value.tv_usec);
@


1.30
log
@Remove ddb single-step load and store counters. Most platforms do not
implement them, and they are of questionable usefulness.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.29 2010/07/06 02:26:32 guenther Exp $	*/
a1071 17

#ifdef UVMHIST
void db_uvmhistdump(db_expr_t, int, db_expr_t, char *);
extern void uvmhist_dump(struct uvm_history *);
extern struct uvm_history_head uvm_histories;

void
db_uvmhistdump(addr, have_addr, count, modif)
	db_expr_t addr;
	int have_addr;
	db_expr_t count;
	char *modif;
{

	uvmhist_dump(LIST_FIRST(&uvm_histories));
}
#endif
@


1.29
log
@Kill an unused variable
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.28 2010/06/27 13:28:47 miod Exp $	*/
a1290 81
}


int
db_inst_load(inst)
	int inst;
{
    union instr insn;

    insn.i_int = inst;

    if (insn.i_any.i_op != IOP_mem)
	return 0;

    switch (insn.i_op3.i_op3) {
      case IOP3_LD:
      case IOP3_LDUB:
      case IOP3_LDUH:
      case IOP3_LDD:
      case IOP3_LDSB:
      case IOP3_LDSH:
      case IOP3_LDSTUB:
      case IOP3_SWAP:
      case IOP3_LDA:
      case IOP3_LDUBA:
      case IOP3_LDUHA:
      case IOP3_LDDA:
      case IOP3_LDSBA:
      case IOP3_LDSHA:
      case IOP3_LDSTUBA:
      case IOP3_SWAPA:
      case IOP3_LDF:
      case IOP3_LDFSR:
      case IOP3_LDDF:
      case IOP3_LFC:
      case IOP3_LDCSR:
      case IOP3_LDDC:
	return 1;

      default:
	return 0;
    }
}

int
db_inst_store(inst)
	int inst;
{
    union instr insn;

    insn.i_int = inst;

    if (insn.i_any.i_op != IOP_mem)
	return 0;

    switch (insn.i_op3.i_op3) {
      case IOP3_ST:
      case IOP3_STB:
      case IOP3_STH:
      case IOP3_STD:
      case IOP3_LDSTUB:
      case IOP3_SWAP:
      case IOP3_STA:
      case IOP3_STBA:
      case IOP3_STHA:
      case IOP3_STDA:
      case IOP3_LDSTUBA:
      case IOP3_SWAPA:
      case IOP3_STF:
      case IOP3_STFSR:
      case IOP3_STQF:
      case IOP3_STDF:
      case IOP3_STC:
      case IOP3_STCSR:
      case IOP3_STQFA:
      case IOP3_STDC:
	return 1;

      default:
	return 0;
    }
@


1.28
log
@If you include <uvm/uvm.h>, you do not need to include any other <uvm/uvm_foo.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.27 2008/12/14 17:10:44 kettenis Exp $	*/
d890 1
a890 1
	struct proc *p, *pp;
a897 1
		pp = p->p_pptr;
@


1.27
log
@Implement a "machine xir" ddb command, making it possible to send an
External Initiated Reset (XIR) to processors.  A XIR is non-maskable and will
drop us at the PROM ok prompt.  This makes it possible to diagnose problems
where a CPU is spinning with interrupts disabled.

For now, this is only supported on machines with bbc(4).
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.26 2008/03/13 23:29:46 kettenis Exp $	*/
d39 1
a39 1
#include <uvm/uvm_extern.h>
a1072 2

#include <uvm/uvm.h>
@


1.26
log
@Make this catch up with some changed structs.  Fix indentation while I'm there.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.25 2008/02/20 09:44:47 robert Exp $	*/
d37 1
d231 1
d1033 40
d1125 1
@


1.25
log
@make tda(4) run the fans at maximum speed when we are about to drop
drop to ddb(4) in order to avoid overheating in case of a system crash.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.24 2007/10/27 22:20:16 martin Exp $	*/
d796 3
a798 3
		  p->p_pid, p->p_vmspace, p->p_vmspace->vm_map.pmap, 
		  p->p_vmspace->vm_map.pmap->pm_ctx,
		  p->p_wchan, p->p_priority, p->p_usrpri);
d800 2
a801 2
		  p->p_vmspace->vm_maxsaddr, p->p_vmspace->vm_ssize, 
		  (unsigned long long)ptoa(p->p_vmspace->vm_ssize));
d803 4
a806 4
		  p->p_stats->p_timer[ITIMER_PROF].it_value.tv_sec,
		  p->p_stats->p_timer[ITIMER_PROF].it_value.tv_usec);
	db_printf("pcb: %p fpstate: %p\n", &p->p_addr->u_pcb, 
		p->p_md.md_fpstate);
d856 1
a856 1
			  (unsigned long long)pcb->pcb_rw[i+1].rw_in[6]);
@


1.24
log
@get rid of btoc/ctob in favor of atop/ptoa
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.23 2007/05/02 18:46:07 kettenis Exp $	*/
d62 2
d263 4
@


1.23
log
@Move sparc64 to __HAVE_CPUINFO.

ok miod@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.22 2007/04/12 22:20:14 thib Exp $	*/
d795 1
a795 1
		  (unsigned long long)ctob(p->p_vmspace->vm_ssize));
@


1.22
log
@Remove the lk_interlock from struct lock; Also remove the LK_INTERLOCK
flag. This effectively makes the simplelock argument to lockmgr() fluff.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.21 2006/07/06 19:05:56 miod Exp $	*/
a835 1
	extern struct pcb *cpcb;
d839 1
a839 1
	pcb = cpcb;
a883 2
	extern struct pcb *cpcb;

d893 1
a893 1
			cpcb = (struct pcb*)p->p_addr;
@


1.21
log
@Make sure we alter ddb variables as ints, not longs; only matters on 64 bit
platforms.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.20 2006/07/06 17:51:26 miod Exp $	*/
d717 1
a717 1
	db_printf("interlock=%x flags=%x\n waitcount=%x sharecount=%x "
d719 1
a719 1
	    l->lk_interlock.lock_data, l->lk_flags, l->lk_waitcount,
@


1.20
log
@Make dummy $g0 in ddb the right size.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.19 2004/12/25 23:02:25 miod Exp $	*/
a122 21
static int
db__int_value(struct db_variable *var, db_expr_t *expr, int mode)
{

	switch (mode) {
	case DB_VAR_SET:
		*var->valuep = *(int *)expr;
		break;
	case DB_VAR_GET:
		*expr = *(int *)var->valuep;
		break;
#ifdef DIAGNOSTIC
	default:
		printf("db__int_value: mode %d\n", mode);
		break;
#endif
	}

	return 0;
}

d128 1
a128 1
	{ "y", (long *)&DDB_TF->tf_y, db__int_value, },
@


1.19
log
@Use list and queue macros where applicable to make the code easier to read;
no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.18 2003/12/20 20:08:17 miod Exp $	*/
d77 1
a77 1
static int nil;
@


1.18
log
@Pass -Wformat
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.17 2003/07/09 18:08:01 jason Exp $	*/
d835 1
a835 1
	for (p = allproc.lh_first; p != 0; p = p->p_list.le_next) {
d913 1
a913 1
	for (p = allproc.lh_first; p != 0; p = p->p_list.le_next) {
d1065 1
a1065 1
	uvmhist_dump(uvm_histories.lh_first);
@


1.17
log
@another instruction correction: STQDC -> STQFA
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.16 2003/07/09 17:38:19 jason Exp $	*/
d520 1
a520 1
			db_printf("%2d:%16.16lx %16.16lx ", i++, p[0], p[1]);
d522 1
a522 1
			db_printf("%2d:%16.16lx %16.16lx\n", i++, p[0], p[1]);
@


1.16
log
@corrections/filling of type 3 v9 instructions
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.15 2003/06/16 20:46:14 miod Exp $	*/
d1343 1
a1343 1
      case IOP3_STDCQ:
@


1.15
log
@Provide the same fbxxx() api as on sparc, in order to factorize more code
and eventually share some drivers.
This also brings us screen unblanking upon entering ddb, which can be really
useful at times...
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.14 2003/02/12 06:33:00 jason Exp $	*/
d1339 1
a1339 1
      case IOP3_STDFQ:
@


1.14
log
@Kill more commons in sparc64 code
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.13 2003/01/09 22:27:10 miod Exp $	*/
d282 1
a282 1
#if NFB > 0
d284 1
a284 1
#endif
@


1.13
log
@Remove fetch(9) and store(9) functions from the kernel, and replace the few
remaining instances of them with appropriate copy(9) usage.

ok art@@, tested on all arches unless my memory is non-ECC
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.12 2002/07/24 00:48:25 art Exp $	*/
d61 2
@


1.12
log
@Support for non-exec page mappings.
 - split the one TSB into two - one for dmmu, one for immu.
 - don't load pages without PG_EXEC into the immu TSB.
 - support for setting correct permissions on exec faults.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.11 2002/06/15 17:23:31 art Exp $	*/
d381 1
a381 1
			*data++ = fubyte(src++);
d408 1
a408 1
			subyte(dst, *data);
@


1.11
log
@Decruftification.

We will never have a.out kernels.
We will never have 32-bit kernels.
We will never have sun4c, sun4 and sun4m support in the sparc64 kernels.
We don't need support old netbsd libc.
The cpu will never be identified as some of the sun4c and sun4m types.
We don't need the gazillion of fields in cpuinfo that the sparc port uses.
Just generally remove dead code.

This is just a first step in making this meess readable.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.10 2002/06/11 08:09:42 mdw Exp $	*/
d753 1
a753 1
	extern pte_t *tsb;
d761 3
a763 3
			  (int)((tsb[i].tag&TSB_TAG_G)?-1:TSB_TAG_CTX(tsb[i].tag)),
			  (int)((i<<13)|TSB_TAG_VA(tsb[i].tag)),
			  (int)(tsb[i].data>>32), (int)tsb[i].data);
d766 3
a768 3
			  (int)((tsb[i].tag&TSB_TAG_G)?-1:TSB_TAG_CTX(tsb[i].tag)),
			  (int)((i<<13)|TSB_TAG_VA(tsb[i].tag)),
			  (int)(tsb[i].data>>32), (int)tsb[i].data);
@


1.10
log
@Recognize more v9 branches when stepping
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.9 2002/06/10 20:09:24 mdw Exp $	*/
a517 1
#ifdef __arch64__
a521 6
#else
			db_printf("%2d:%16.16qx %16.16qx ", i++, p[0], p[1]);
			p += 2;
			db_printf("%2d:%16.16qx %16.16qx\n", i++, p[0], p[1]);
			p += 2;
#endif
@


1.9
log
@Print ITLB/DTLB on usIII
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.8 2002/05/16 13:01:41 art Exp $	*/
d1131 8
d1179 8
@


1.8
log
@Add a an argument to db_printsym that specifies the printf function
we'll use for printing the information.
miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.7 2002/03/14 04:16:55 jason Exp $	*/
d237 1
d431 55
d493 1
a493 1
	extern void print_dtlb(void);
d500 15
a514 1
		
d530 31
d562 2
a563 3
#ifdef DEBUG
		print_dtlb();
#endif
d1086 1
@


1.7
log
@Properly conditionalize uvm history dump
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.6 2002/03/14 03:16:01 millert Exp $	*/
d844 1
a844 1
	db_printsym((u_long)te->tpc, DB_STGY_PROC);
@


1.6
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.5 2002/03/14 01:26:45 millert Exp $	*/
d957 1
d972 1
d1000 1
d1002 1
@


1.5
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.4 2001/08/22 05:08:11 jason Exp $	*/
d973 1
a973 1
extern void db_esp(db_expr_t, int, db_expr_t, char*);
@


1.4
log
@setup the 'machine' commands for ddb
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.3 2001/08/20 20:23:53 jason Exp $	*/
d62 1
a62 1
extern void OF_enter __P((void));
d224 22
a245 22
void kdb_kbd_trap __P((struct trapframe64 *));
void db_prom_cmd __P((db_expr_t, int, db_expr_t, char *));
void db_proc_cmd __P((db_expr_t, int, db_expr_t, char *));
void db_ctx_cmd __P((db_expr_t, int, db_expr_t, char *));
void db_dump_window __P((db_expr_t, int, db_expr_t, char *));
void db_dump_stack __P((db_expr_t, int, db_expr_t, char *));
void db_dump_trap __P((db_expr_t, int, db_expr_t, char *));
void db_dump_fpstate __P((db_expr_t, int, db_expr_t, char *));
void db_dump_ts __P((db_expr_t, int, db_expr_t, char *));
void db_dump_pcb __P((db_expr_t, int, db_expr_t, char *));
void db_dump_pv __P((db_expr_t, int, db_expr_t, char *));
void db_setpcb __P((db_expr_t, int, db_expr_t, char *));
void db_dump_dtlb __P((db_expr_t, int, db_expr_t, char *));
void db_dump_dtsb __P((db_expr_t, int, db_expr_t, char *));
void db_pmap_kernel __P((db_expr_t, int, db_expr_t, char *));
void db_pload_cmd __P((db_expr_t, int, db_expr_t, char *));
void db_pmap_cmd __P((db_expr_t, int, db_expr_t, char *));
void db_lock __P((db_expr_t, int, db_expr_t, char *));
void db_traptrace __P((db_expr_t, int, db_expr_t, char *));
void db_dump_buf __P((db_expr_t, int, db_expr_t, char *));
void db_dump_espcmd __P((db_expr_t, int, db_expr_t, char *));
void db_watch __P((db_expr_t, int, db_expr_t, char *));
d247 2
a248 2
static void db_dump_pmap __P((struct pmap*));
static void db_print_trace_entry __P((struct traptrace *, int));
d437 1
a437 1
	extern void print_dtlb __P((void));
d504 1
a504 1
int64_t pseg_get __P((struct pmap *, vaddr_t));
d679 1
a679 1
void db_page_cmd __P((db_expr_t, int, db_expr_t, char *));
d957 2
a958 2
void db_uvmhistdump __P((db_expr_t, int, db_expr_t, char *));
extern void uvmhist_dump __P((struct uvm_history *));
@


1.4.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.4 2001/08/22 05:08:11 jason Exp $	*/
d62 1
a62 1
extern void OF_enter(void);
d224 22
a245 22
void kdb_kbd_trap(struct trapframe64 *);
void db_prom_cmd(db_expr_t, int, db_expr_t, char *);
void db_proc_cmd(db_expr_t, int, db_expr_t, char *);
void db_ctx_cmd(db_expr_t, int, db_expr_t, char *);
void db_dump_window(db_expr_t, int, db_expr_t, char *);
void db_dump_stack(db_expr_t, int, db_expr_t, char *);
void db_dump_trap(db_expr_t, int, db_expr_t, char *);
void db_dump_fpstate(db_expr_t, int, db_expr_t, char *);
void db_dump_ts(db_expr_t, int, db_expr_t, char *);
void db_dump_pcb(db_expr_t, int, db_expr_t, char *);
void db_dump_pv(db_expr_t, int, db_expr_t, char *);
void db_setpcb(db_expr_t, int, db_expr_t, char *);
void db_dump_dtlb(db_expr_t, int, db_expr_t, char *);
void db_dump_dtsb(db_expr_t, int, db_expr_t, char *);
void db_pmap_kernel(db_expr_t, int, db_expr_t, char *);
void db_pload_cmd(db_expr_t, int, db_expr_t, char *);
void db_pmap_cmd(db_expr_t, int, db_expr_t, char *);
void db_lock(db_expr_t, int, db_expr_t, char *);
void db_traptrace(db_expr_t, int, db_expr_t, char *);
void db_dump_buf(db_expr_t, int, db_expr_t, char *);
void db_dump_espcmd(db_expr_t, int, db_expr_t, char *);
void db_watch(db_expr_t, int, db_expr_t, char *);
d247 2
a248 2
static void db_dump_pmap(struct pmap*);
static void db_print_trace_entry(struct traptrace *, int);
d437 1
a437 1
	extern void print_dtlb(void);
d504 1
a504 1
int64_t pseg_get(struct pmap *, vaddr_t);
d679 1
a679 1
void db_page_cmd(db_expr_t, int, db_expr_t, char *);
d844 1
a844 1
	db_printsym((u_long)te->tpc, DB_STGY_PROC, db_printf);
d957 2
a958 3
#ifdef UVMHIST
void db_uvmhistdump(db_expr_t, int, db_expr_t, char *);
extern void uvmhist_dump(struct uvm_history *);
a970 1
#endif
d973 1
a973 1
extern void db_esp(db_expr_t, int, db_expr_t, char *);
a997 1
#ifdef UVMHIST
a998 1
#endif
@


1.4.6.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.4.6.1 2002/06/11 03:38:43 art Exp $	*/
a236 1
void db_dump_itlb(db_expr_t, int, db_expr_t, char *);
a429 55
#define CHEETAHP (((getver()>>32) & 0x1ff) >= 0x14)
unsigned long db_get_dtlb_data(int entry), db_get_dtlb_tag(int entry),
db_get_itlb_data(int entry), db_get_itlb_tag(int entry);
void db_print_itlb_entry(int entry, int i, int endc);
void db_print_dtlb_entry(int entry, int i, int endc);

extern __inline__ unsigned long db_get_dtlb_data(int entry)
{
	unsigned long r;
	__asm__ __volatile__("ldxa [%1] %2,%0"
		: "=r" (r)
		: "r" (entry <<3), "i" (ASI_DMMU_TLB_DATA));
	return r;
}
extern __inline__ unsigned long db_get_dtlb_tag(int entry)
{
	unsigned long r;
	__asm__ __volatile__("ldxa [%1] %2,%0"
		: "=r" (r)
		: "r" (entry <<3), "i" (ASI_DMMU_TLB_TAG));
	return r;
}
extern __inline__ unsigned long db_get_itlb_data(int entry)
{
	unsigned long r;
	__asm__ __volatile__("ldxa [%1] %2,%0"
		: "=r" (r)
		: "r" (entry <<3), "i" (ASI_IMMU_TLB_DATA));
	return r;
}
extern __inline__ unsigned long db_get_itlb_tag(int entry)
{
	unsigned long r;
	__asm__ __volatile__("ldxa [%1] %2,%0"
		: "=r" (r)
		: "r" (entry <<3), "i" (ASI_IMMU_TLB_TAG));
	return r;
}

void db_print_dtlb_entry(int entry, int i, int endc)
{
	unsigned long tag, data;
	tag = db_get_dtlb_tag(entry);
	data = db_get_dtlb_data(entry);
	db_printf("%2d:%16.16lx %16.16lx%c", i, tag, data, endc);
}

void db_print_itlb_entry(int entry, int i, int endc)
{
	unsigned long tag, data;
	tag = db_get_itlb_tag(entry);
	data = db_get_itlb_data(entry);
	db_printf("%2d:%16.16lx %16.16lx%c", i, tag, data, endc);
}

d437 1
a437 1
	/* extern void print_dtlb(void); -- locore.s; no longer used here */
d444 1
a444 15
	
	if (CHEETAHP) {
		db_printf("DTLB %ld\n", addr);
		switch(addr)
		{
		case 0:
			for (i = 0; i < 16; ++i)
				db_print_dtlb_entry(i, i, (i&1)?'\n':' ');
			break;
		case 2:
			for (i = 0; i < 512; ++i)
				db_print_dtlb_entry(i+16384, i, (i&1)?'\n':' ');
			break;
		}
	} else {
d448 1
d453 6
a459 1
	}
d461 3
a463 32
printf ("Usage: mach dtlb 0,2\n");
	}
}

void
db_dump_itlb(addr, have_addr, count, modif)
	db_expr_t addr;
	int have_addr;
	db_expr_t count;
	char *modif;
{
	int i;
	if (!have_addr) {
		db_printf("Usage: mach itlb 0,1,2\n");
		return;
	}
	if (CHEETAHP) {
		db_printf("ITLB %ld\n", addr);
		switch(addr)
		{
		case 0:
			for (i = 0; i < 16; ++i)
				db_print_itlb_entry(i, i, (i&1)?'\n':' ');
			break;
		case 2:
			for (i = 0; i < 128; ++i)
				db_print_itlb_entry(i+16384, i, (i&1)?'\n':' ');
			break;
		}
	} else {
		for (i = 0; i < 63; ++i)
			db_print_itlb_entry(i, i, (i&1)?'\n':' ');
d660 1
a660 1
	extern pte_t *tsb_dmmu;
d668 3
a670 3
			  (int)((tsb_dmmu[i].tag&TSB_TAG_G)?-1:TSB_TAG_CTX(tsb_dmmu[i].tag)),
			  (int)((i<<13)|TSB_TAG_VA(tsb_dmmu[i].tag)),
			  (int)(tsb_dmmu[i].data>>32), (int)tsb_dmmu[i].data);
d673 3
a675 3
			  (int)((tsb_dmmu[i].tag&TSB_TAG_G)?-1:TSB_TAG_CTX(tsb_dmmu[i].tag)),
			  (int)((i<<13)|TSB_TAG_VA(tsb_dmmu[i].tag)),
			  (int)(tsb_dmmu[i].data>>32), (int)tsb_dmmu[i].data);
a985 1
	{ "itlb",	db_dump_itlb,	0,	0 },
a1029 8
    /* the fancy union just gets in the way of this: */
    switch(inst & 0xffc00000) {
    case 0x30400000:	/* branch always, annul, with prediction */
	return pc + ((inst<<(32-19))>>((32-19)-2));
    case 0x30800000:	/* branch always, annul */
	return pc + ((inst<<(32-22))>>((32-22)-2));
    }

a1069 8

    /* the fancy union just gets in the way of this: */
    switch(inst & 0xffc00000) {
    case 0x30400000:	/* branch always, annul, with prediction */
	return TRUE;
    case 0x30800000:	/* branch always, annul */
	return TRUE;
    }
@


1.4.6.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a61 2
db_regs_t	ddb_regs;	/* register state */

d381 1
a381 1
			copyin(src++, data++, sizeof(u_char));
d408 1
a408 1
			copyout(data, dst, sizeof(char));
@


1.4.4.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.4.4.2
log
@Merge in -current from about a week ago
@
text
@d62 1
a62 1
extern void OF_enter(void);
d224 22
a245 22
void kdb_kbd_trap(struct trapframe64 *);
void db_prom_cmd(db_expr_t, int, db_expr_t, char *);
void db_proc_cmd(db_expr_t, int, db_expr_t, char *);
void db_ctx_cmd(db_expr_t, int, db_expr_t, char *);
void db_dump_window(db_expr_t, int, db_expr_t, char *);
void db_dump_stack(db_expr_t, int, db_expr_t, char *);
void db_dump_trap(db_expr_t, int, db_expr_t, char *);
void db_dump_fpstate(db_expr_t, int, db_expr_t, char *);
void db_dump_ts(db_expr_t, int, db_expr_t, char *);
void db_dump_pcb(db_expr_t, int, db_expr_t, char *);
void db_dump_pv(db_expr_t, int, db_expr_t, char *);
void db_setpcb(db_expr_t, int, db_expr_t, char *);
void db_dump_dtlb(db_expr_t, int, db_expr_t, char *);
void db_dump_dtsb(db_expr_t, int, db_expr_t, char *);
void db_pmap_kernel(db_expr_t, int, db_expr_t, char *);
void db_pload_cmd(db_expr_t, int, db_expr_t, char *);
void db_pmap_cmd(db_expr_t, int, db_expr_t, char *);
void db_lock(db_expr_t, int, db_expr_t, char *);
void db_traptrace(db_expr_t, int, db_expr_t, char *);
void db_dump_buf(db_expr_t, int, db_expr_t, char *);
void db_dump_espcmd(db_expr_t, int, db_expr_t, char *);
void db_watch(db_expr_t, int, db_expr_t, char *);
d247 2
a248 2
static void db_dump_pmap(struct pmap*);
static void db_print_trace_entry(struct traptrace *, int);
d437 1
a437 1
	extern void print_dtlb(void);
d504 1
a504 1
int64_t pseg_get(struct pmap *, vaddr_t);
d679 1
a679 1
void db_page_cmd(db_expr_t, int, db_expr_t, char *);
d957 2
a958 3
#ifdef UVMHIST
void db_uvmhistdump(db_expr_t, int, db_expr_t, char *);
extern void uvmhist_dump(struct uvm_history *);
a970 1
#endif
d973 1
a973 1
extern void db_esp(db_expr_t, int, db_expr_t, char *);
a997 1
#ifdef UVMHIST
a998 1
#endif
@


1.4.4.3
log
@Sync the SMP branch with 3.3
@
text
@a61 2
db_regs_t	ddb_regs;	/* register state */

a236 1
void db_dump_itlb(db_expr_t, int, db_expr_t, char *);
d380 1
a380 1
			copyin(src++, data++, sizeof(u_char));
d407 1
a407 1
			copyout(data, dst, sizeof(char));
a429 55
#define CHEETAHP (((getver()>>32) & 0x1ff) >= 0x14)
unsigned long db_get_dtlb_data(int entry), db_get_dtlb_tag(int entry),
db_get_itlb_data(int entry), db_get_itlb_tag(int entry);
void db_print_itlb_entry(int entry, int i, int endc);
void db_print_dtlb_entry(int entry, int i, int endc);

extern __inline__ unsigned long db_get_dtlb_data(int entry)
{
	unsigned long r;
	__asm__ __volatile__("ldxa [%1] %2,%0"
		: "=r" (r)
		: "r" (entry <<3), "i" (ASI_DMMU_TLB_DATA));
	return r;
}
extern __inline__ unsigned long db_get_dtlb_tag(int entry)
{
	unsigned long r;
	__asm__ __volatile__("ldxa [%1] %2,%0"
		: "=r" (r)
		: "r" (entry <<3), "i" (ASI_DMMU_TLB_TAG));
	return r;
}
extern __inline__ unsigned long db_get_itlb_data(int entry)
{
	unsigned long r;
	__asm__ __volatile__("ldxa [%1] %2,%0"
		: "=r" (r)
		: "r" (entry <<3), "i" (ASI_IMMU_TLB_DATA));
	return r;
}
extern __inline__ unsigned long db_get_itlb_tag(int entry)
{
	unsigned long r;
	__asm__ __volatile__("ldxa [%1] %2,%0"
		: "=r" (r)
		: "r" (entry <<3), "i" (ASI_IMMU_TLB_TAG));
	return r;
}

void db_print_dtlb_entry(int entry, int i, int endc)
{
	unsigned long tag, data;
	tag = db_get_dtlb_tag(entry);
	data = db_get_dtlb_data(entry);
	db_printf("%2d:%16.16lx %16.16lx%c", i, tag, data, endc);
}

void db_print_itlb_entry(int entry, int i, int endc)
{
	unsigned long tag, data;
	tag = db_get_itlb_tag(entry);
	data = db_get_itlb_data(entry);
	db_printf("%2d:%16.16lx %16.16lx%c", i, tag, data, endc);
}

d437 1
a437 1
	/* extern void print_dtlb(void); -- locore.s; no longer used here */
d444 1
a444 15
	
	if (CHEETAHP) {
		db_printf("DTLB %ld\n", addr);
		switch(addr)
		{
		case 0:
			for (i = 0; i < 16; ++i)
				db_print_dtlb_entry(i, i, (i&1)?'\n':' ');
			break;
		case 2:
			for (i = 0; i < 512; ++i)
				db_print_dtlb_entry(i+16384, i, (i&1)?'\n':' ');
			break;
		}
	} else {
d448 1
d453 6
a459 1
	}
d461 3
a463 32
printf ("Usage: mach dtlb 0,2\n");
	}
}

void
db_dump_itlb(addr, have_addr, count, modif)
	db_expr_t addr;
	int have_addr;
	db_expr_t count;
	char *modif;
{
	int i;
	if (!have_addr) {
		db_printf("Usage: mach itlb 0,1,2\n");
		return;
	}
	if (CHEETAHP) {
		db_printf("ITLB %ld\n", addr);
		switch(addr)
		{
		case 0:
			for (i = 0; i < 16; ++i)
				db_print_itlb_entry(i, i, (i&1)?'\n':' ');
			break;
		case 2:
			for (i = 0; i < 128; ++i)
				db_print_itlb_entry(i+16384, i, (i&1)?'\n':' ');
			break;
		}
	} else {
		for (i = 0; i < 63; ++i)
			db_print_itlb_entry(i, i, (i&1)?'\n':' ');
d660 1
a660 1
	extern pte_t *tsb_dmmu;
d668 3
a670 3
			  (int)((tsb_dmmu[i].tag&TSB_TAG_G)?-1:TSB_TAG_CTX(tsb_dmmu[i].tag)),
			  (int)((i<<13)|TSB_TAG_VA(tsb_dmmu[i].tag)),
			  (int)(tsb_dmmu[i].data>>32), (int)tsb_dmmu[i].data);
d673 3
a675 3
			  (int)((tsb_dmmu[i].tag&TSB_TAG_G)?-1:TSB_TAG_CTX(tsb_dmmu[i].tag)),
			  (int)((i<<13)|TSB_TAG_VA(tsb_dmmu[i].tag)),
			  (int)(tsb_dmmu[i].data>>32), (int)tsb_dmmu[i].data);
d844 1
a844 1
	db_printsym((u_long)te->tpc, DB_STGY_PROC, db_printf);
a985 1
	{ "itlb",	db_dump_itlb,	0,	0 },
a1029 8
    /* the fancy union just gets in the way of this: */
    switch(inst & 0xffc00000) {
    case 0x30400000:	/* branch always, annul, with prediction */
	return pc + ((inst<<(32-19))>>((32-19)-2));
    case 0x30800000:	/* branch always, annul */
	return pc + ((inst<<(32-22))>>((32-22)-2));
    }

a1069 8

    /* the fancy union just gets in the way of this: */
    switch(inst & 0xffc00000) {
    case 0x30400000:	/* branch always, annul, with prediction */
	return TRUE;
    case 0x30800000:	/* branch always, annul */
	return TRUE;
    }
@


1.4.4.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d282 1
a282 1

d284 1
a284 1

d520 1
a520 1
			db_printf("%2d:%16.16llx %16.16llx ", i++, p[0], p[1]);
d522 1
a522 1
			db_printf("%2d:%16.16llx %16.16llx\n", i++, p[0], p[1]);
d1339 1
a1339 1
      case IOP3_STQF:
d1343 1
a1343 1
      case IOP3_STQFA:
@


1.3
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d976 1
a976 1
const struct db_command db_machine_command_table[] = {
d1234 6
@


1.2
log
@no doing shutdown
@
text
@d1 1
@


1.1
log
@db_interface from NetBSD.
hacked up a bit to match our ddb.
@
text
@a275 1
	extern int doing_shutdown;
a277 1
	doing_shutdown++;
a358 1
	doing_shutdown--;
@

