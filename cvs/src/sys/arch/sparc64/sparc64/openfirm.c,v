head	1.19;
access;
symbols
	OPENBSD_6_1:1.19.0.4
	OPENBSD_6_1_BASE:1.19
	OPENBSD_6_0:1.19.0.2
	OPENBSD_6_0_BASE:1.19
	OPENBSD_5_9:1.15.0.6
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.15.0.8
	OPENBSD_5_8_BASE:1.15
	OPENBSD_5_7:1.15.0.2
	OPENBSD_5_7_BASE:1.15
	OPENBSD_5_6:1.15.0.4
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.14.0.18
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.14.0.14
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.14.0.12
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.10
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.8
	OPENBSD_5_0:1.14.0.6
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.4
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.14.0.2
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.13.0.12
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.13.0.14
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.10
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.8
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.6
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.4
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.13.0.2
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.11.0.8
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.11.0.6
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.4
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.11.0.2
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.10.0.2
	OPENBSD_3_6_BASE:1.10
	SMP_SYNC_A:1.9
	SMP_SYNC_B:1.9
	OPENBSD_3_5:1.9.0.2
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.8.0.8
	OPENBSD_3_4_BASE:1.8
	UBC_SYNC_A:1.8
	OPENBSD_3_3:1.8.0.6
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.4
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	UBC_SYNC_B:1.8
	UBC:1.5.0.2
	UBC_BASE:1.5
	SMP:1.4.0.4
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4;
locks; strict;
comment	@ * @;


1.19
date	2016.05.19.09.15.28;	author kettenis;	state Exp;
branches;
next	1.18;
commitid	sPqcIVDGWL0OCQNG;

1.18
date	2016.03.19.11.34.22;	author mpi;	state Exp;
branches;
next	1.17;
commitid	15xZY6veDWwRM6Iq;

1.17
date	2016.03.07.13.21.51;	author naddy;	state Exp;
branches;
next	1.16;
commitid	EDvRPKRZUDEEb6oR;

1.16
date	2016.03.01.11.56.00;	author mpi;	state Exp;
branches;
next	1.15;
commitid	CZXiyhU8oBcz6IpF;

1.15
date	2014.03.29.18.09.30;	author guenther;	state Exp;
branches;
next	1.14;

1.14
date	2010.04.10.14.02.49;	author kettenis;	state Exp;
branches;
next	1.13;

1.13
date	2007.02.11.20.29.22;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2007.01.16.14.39.57;	author tsi;	state Exp;
branches;
next	1.11;

1.11
date	2005.03.13.17.33.12;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2004.08.08.20.11.32;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2004.01.07.20.44.56;	author pvalchev;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.15.18.19.52;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.03.14.03.16.01;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.03.14.01.26.45;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.12.05.01.59.55;	author jason;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2001.09.05.22.32.39;	author deraadt;	state Exp;
branches
	1.4.4.1;
next	1.3;

1.3
date	2001.08.24.00.03.23;	author art;	state Exp;
branches;
next	1.2;

1.2
date	2001.08.20.20.23.53;	author jason;	state Exp;
branches;
next	1.1;

1.1
date	2001.08.19.05.21.38;	author jason;	state Exp;
branches;
next	;

1.4.4.1
date	2001.10.31.03.07.59;	author nate;	state Exp;
branches;
next	1.4.4.2;

1.4.4.2
date	2002.03.06.02.04.47;	author niklas;	state Exp;
branches;
next	1.4.4.3;

1.4.4.3
date	2002.03.28.11.23.52;	author niklas;	state Exp;
branches;
next	1.4.4.4;

1.4.4.4
date	2004.02.19.10.50.01;	author niklas;	state Exp;
branches;
next	;

1.5.2.1
date	2002.06.11.03.38.44;	author art;	state Exp;
branches;
next	;


desc
@@


1.19
log
@Implement OF_is_compatible(9).
@
text
@/*	$OpenBSD: openfirm.c,v 1.18 2016/03/19 11:34:22 mpi Exp $	*/
/*	$NetBSD: openfirm.c,v 1.13 2001/06/21 00:08:02 eeh Exp $	*/

/*
 * Copyright (C) 1995, 1996 Wolfgang Solfrank.
 * Copyright (C) 1995, 1996 TooLs GmbH.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by TooLs GmbH.
 * 4. The name of TooLs GmbH may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY TOOLS GMBH ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL TOOLS GMBH BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/stdarg.h>
#include <machine/psl.h>

#include <machine/openfirm.h>

#define min(x,y)	((x<y)?(x):(y))

int
OF_peer(phandle)
	int phandle;
{
	struct {
		cell_t name;
		cell_t nargs;
		cell_t nreturns;
		cell_t phandle;
		cell_t sibling;
	} args;

	args.name = ADR2CELL("peer");
	args.nargs = 1;
	args.nreturns = 1;
	args.phandle = HDL2CELL(phandle);
	if (openfirmware(&args) == -1)
		return 0;
	return args.sibling;
}

int
OF_child(phandle)
	int phandle;
{
	struct {
		cell_t name;
		cell_t nargs;
		cell_t nreturns;
		cell_t phandle;
		cell_t child;
	} args;
	
	args.name = ADR2CELL("child");
	args.nargs = 1;
	args.nreturns = 1;
	args.phandle = HDL2CELL(phandle);
	if (openfirmware(&args) == -1)
		return 0;
	return args.child;
}

int
OF_parent(phandle)
	int phandle;
{
	struct {
		cell_t name;
		cell_t nargs;
		cell_t nreturns;
		cell_t phandle;
		cell_t parent;
	} args;
	
	args.name = ADR2CELL("parent");
	args.nargs = 1;
	args.nreturns = 1;
	args.phandle = HDL2CELL(phandle);
	if (openfirmware(&args) == -1)
		return 0;
	return args.parent;
}

int
OF_instance_to_package(ihandle)
	int ihandle;
{
	static struct {
		cell_t name;
		cell_t nargs;
		cell_t nreturns;
		cell_t ihandle;
		cell_t phandle;
	} args;
	
	args.name = ADR2CELL("instance-to-package");
	args.nargs = 1;
	args.nreturns = 1;
	args.ihandle = HDL2CELL(ihandle);
	if (openfirmware(&args) == -1)
		return -1;
	return args.phandle;
}

/* Should really return a `long' */
int
OF_getproplen(handle, prop)
	int handle;
	char *prop;
{
	struct {
		cell_t name;
		cell_t nargs;
		cell_t nreturns;
		cell_t phandle;
		cell_t prop;
		cell_t size;
	} args;
	
	args.name = ADR2CELL("getproplen");
	args.nargs = 2;
	args.nreturns = 1;
	args.phandle = HDL2CELL(handle);
	args.prop = ADR2CELL(prop);
	if (openfirmware(&args) == -1)
		return -1;
	return args.size;
}

int
OF_getprop(handle, prop, buf, buflen)
	int handle;
	char *prop;
	void *buf;
	int buflen;
{
	struct {
		cell_t name;
		cell_t nargs;
		cell_t nreturns;
		cell_t phandle;
		cell_t prop;
		cell_t buf;
		cell_t buflen;
		cell_t size;
	} args;
	
	if (buflen > NBPG)
		return -1;
	args.name = ADR2CELL("getprop");
	args.nargs = 4;
	args.nreturns = 1;
	args.phandle = HDL2CELL(handle);
	args.prop = ADR2CELL(prop);
	args.buf = ADR2CELL(buf);
	args.buflen = buflen;
	if (openfirmware(&args) == -1)
		return -1;
	return args.size;
}

int
OF_setprop(handle, prop, buf, buflen)
	int handle;
	char *prop;
	const void *buf;
	int buflen;
{
	struct {
		cell_t name;
		cell_t nargs;
		cell_t nreturns;
		cell_t phandle;
		cell_t prop;
		cell_t buf;
		cell_t buflen;
		cell_t size;
	} args;
	
	if (buflen > NBPG)
		return -1;
	args.name = ADR2CELL("setprop");
	args.nargs = 4;
	args.nreturns = 1;
	args.phandle = HDL2CELL(handle);
	args.prop = ADR2CELL(prop);
	args.buf = ADR2CELL(buf);
	args.buflen = buflen;
	if (openfirmware(&args) == -1)
		return -1;
	return args.size;
}

int
OF_nextprop(handle, prop, buf)
	int handle;
	char *prop;
	void *buf;
{
	struct {
		cell_t name;
		cell_t nargs;
		cell_t nreturns;
		cell_t phandle;
		cell_t prev;
		cell_t buf;
		cell_t next;
	} args;
	
	args.name = ADR2CELL("nextprop");
	args.nargs = 3;
	args.nreturns = 1;
	args.phandle = HDL2CELL(handle);
	args.prev = ADR2CELL(prop);
	args.buf = ADR2CELL(buf);
	if (openfirmware(&args) == -1)
		return -1;
	return args.next;
}

int
OF_finddevice(name)
char *name;
{
	struct {
		cell_t name;
		cell_t nargs;
		cell_t nreturns;
		cell_t device;
		cell_t phandle;
	} args;
	
	args.name = ADR2CELL("finddevice");
	args.nargs = 1;
	args.nreturns = 1;
	args.device = ADR2CELL(name);
	if (openfirmware(&args) == -1)
		return -1;
	return args.phandle;
}

int
OF_instance_to_path(ihandle, buf, buflen)
	int ihandle;
	char *buf;
	int buflen;
{
	struct {
		cell_t name;
		cell_t nargs;
		cell_t nreturns;
		cell_t ihandle;
		cell_t buf;
		cell_t buflen;
		cell_t length;
	} args;
	
	if (buflen > NBPG)
		return -1;
	args.name = ADR2CELL("instance-to-path");
	args.nargs = 3;
	args.nreturns = 1;
	args.ihandle = HDL2CELL(ihandle);
	args.buf = ADR2CELL(buf);
	args.buflen = buflen;
	if (openfirmware(&args) < 0)
		return -1;
	return args.length;
}

int
OF_package_to_path(phandle, buf, buflen)
	int phandle;
	char *buf;
	int buflen;
{
	struct {
		cell_t name;
		cell_t nargs;
		cell_t nreturns;
		cell_t phandle;
		cell_t buf;
		cell_t buflen;
		cell_t length;
	} args;
	
	if (buflen > NBPG)
		return -1;
	args.name = ADR2CELL("package-to-path");
	args.nargs = 3;
	args.nreturns = 1;
	args.phandle = HDL2CELL(phandle);
	args.buf = ADR2CELL(buf);
	args.buflen = buflen;
	if (openfirmware(&args) < 0)
		return -1;
	return args.length;
}

/*
 * The following two functions may need to be re-worked to be 64-bit clean.
 */
int
OF_call_method(char *method, int ihandle, int nargs, int nreturns, ...)
{
	va_list ap;
	struct {
		cell_t name;
		cell_t nargs;
		cell_t nreturns;
		cell_t method;
		cell_t ihandle;
		cell_t args_n_results[12];
	} args;
	long *ip, n;
	
	if (nargs > 6)
		return -1;
	args.name = ADR2CELL("call-method");
	args.nargs = nargs + 2;
	args.nreturns = nreturns + 1;
	args.method = ADR2CELL(method);
	args.ihandle = HDL2CELL(ihandle);
	va_start(ap, nreturns);
	for (ip = (long *)(args.args_n_results + (n = nargs)); --n >= 0;)
		*--ip = va_arg(ap, unsigned long);
	if (openfirmware(&args) == -1) {
		va_end(ap);
		return -1;
	}
	if (args.args_n_results[nargs]) {
		va_end(ap);
		return args.args_n_results[nargs];
	}
	for (ip = (long *)(args.args_n_results + nargs + (n = args.nreturns)); --n > 0;)
		*va_arg(ap, unsigned long *) = *--ip;
	va_end(ap);
	return 0;
}

int
OF_call_method_1(char *method, int ihandle, int nargs, ...)
{
	va_list ap;
	struct {
		cell_t name;
		cell_t nargs;
		cell_t nreturns;
		cell_t method;
		cell_t ihandle;
		cell_t args_n_results[16];
	} args;
	long *ip, n;
	
	if (nargs > 6)
		return -1;
	args.name = ADR2CELL("call-method");
	args.nargs = nargs + 2;
	args.nreturns = 1;
	args.method = ADR2CELL(method);
	args.ihandle = HDL2CELL(ihandle);
	va_start(ap, nargs);
	for (ip = (long *)(args.args_n_results + (n = nargs)); --n >= 0;)
		*--ip = va_arg(ap, unsigned long);
	va_end(ap);
	if (openfirmware(&args) == -1)
		return -1;
	if (args.args_n_results[nargs])
		return -1;
	return args.args_n_results[nargs + 1];
}

int
OF_open(dname)
	char *dname;
{
	struct {
		cell_t name;
		cell_t nargs;
		cell_t nreturns;
		cell_t dname;
		cell_t handle;
	} args;
	int l;
	
	if ((l = strlen(dname)) >= NBPG)
		return -1;
	args.name = ADR2CELL("open");	
	args.nargs = 1;
	args.nreturns = 1;
	args.dname = ADR2CELL(dname);
	if (openfirmware(&args) == -1)
		return -1;
	return args.handle;
}

void
OF_close(handle)
	int handle;
{
	struct {
		cell_t name;
		cell_t nargs;
		cell_t nreturns;
		cell_t handle;
	} args;
	
	args.name = ADR2CELL("close");
	args.nargs = 1;
	args.nreturns = 0;
	args.handle = HDL2CELL(handle);
	openfirmware(&args);
}

int
OF_test(service)
	char *service;
{
	struct {
		cell_t name;
		cell_t nargs;
		cell_t nreturns;
		cell_t service;
		cell_t status;
	} args;
	
	args.name = ADR2CELL("test");
	args.nargs = 1;
	args.nreturns = 1;
	args.service = ADR2CELL(service);
	if (openfirmware(&args) == -1)
		return -1;
	return args.status;
}

int
OF_test_method(service, method)
	int service;
	char *method;
{
	struct {
		cell_t name;
		cell_t nargs;
		cell_t nreturns;
		cell_t service;
		cell_t method;
		cell_t status;
	} args;
	
	args.name = ADR2CELL("test-method");
	args.nargs = 2;
	args.nreturns = 1;
	args.service = HDL2CELL(service);
	args.method = ADR2CELL(method);
	if (openfirmware(&args) == -1) 
		return -1;
	return args.status;
}
  
    
/* 
 * This assumes that character devices don't read in multiples of NBPG.
 */
int
OF_read(handle, addr, len)
	int handle;
	void *addr;
	int len;
{
	struct {
		cell_t name;
		cell_t nargs;
		cell_t nreturns;
		cell_t ihandle;
		cell_t addr;
		cell_t len;
		cell_t actual;
	} args;
	int l, act = 0;
	
	args.name = ADR2CELL("read");	
	args.nargs = 3;
	args.nreturns = 1;
	args.ihandle = HDL2CELL(handle);
	args.addr = ADR2CELL(addr);
	for (; len > 0; len -= l) {
		l = min(NBPG, len);
		args.len = l;
		if (openfirmware(&args) == -1)
			return -1;
		if (args.actual > 0) {
			act += args.actual;
		}
		if (args.actual < l) {
			if (act)
				return act;
			else
				return args.actual;
		}
	}
	return act;
}

void prom_printf(const char *fmt, ...);	/* XXX for below */

int
OF_write(handle, addr, len)
	int handle;
	void *addr;
	int len;
{
	struct {
		cell_t name;
		cell_t nargs;
		cell_t nreturns;
		cell_t ihandle;
		cell_t addr;
		cell_t len;
		cell_t actual;
	} args;
	int l, act = 0;

	if (len > 1024) {
		panic("OF_write(len=%d)", len);
	}
	args.name = ADR2CELL("write");
	args.nargs = 3;
	args.nreturns = 1;
	args.ihandle = HDL2CELL(handle);
	args.addr = ADR2CELL(addr);
	for (; len > 0; len -= l) {
		l = min(NBPG, len);
		args.len = l;
		if (openfirmware(&args) == -1)
			return -1;
		l = args.actual;
		act += l;
	}
	return act;
}


int
OF_seek(handle, pos)
	int handle;
	u_quad_t pos;
{
	struct {
		cell_t name;
		cell_t nargs;
		cell_t nreturns;
		cell_t handle;
		cell_t poshi;
		cell_t poslo;
		cell_t status;
	} args;
	
	args.name = ADR2CELL("seek");
	args.nargs = 3;
	args.nreturns = 1;
	args.handle = HDL2CELL(handle);
	args.poshi = HDQ2CELL_HI(pos);
	args.poslo = HDQ2CELL_LO(pos);
	if (openfirmware(&args) == -1)
		return -1;
	return args.status;
}

void
OF_boot(bootspec)
	char *bootspec;
{
	struct {
		cell_t name;
		cell_t nargs;
		cell_t nreturns;
		cell_t bootspec;
	} args;
	int l;
	
	if ((l = strlen(bootspec)) >= NBPG)
		panic("OF_boot");
	args.name = ADR2CELL("boot");	
	args.nargs = 1;
	args.nreturns = 0;
	args.bootspec = ADR2CELL(bootspec);
	openfirmware(&args);
	panic("OF_boot failed");
}

void
OF_enter(void)
{
	struct {
		cell_t name;
		cell_t nargs;
		cell_t nreturns;
	} args;
	
	args.name = ADR2CELL("enter");
	args.nargs = 0;
	args.nreturns = 0;
	openfirmware(&args);
}

void
OF_exit(void)
{
	struct {
		cell_t name;
		cell_t nargs;
		cell_t nreturns;
	} args;
	
	args.name = ADR2CELL("exit");
	args.nargs = 0;
	args.nreturns = 0;
	openfirmware(&args);
	panic("OF_exit failed");
}

void
OF_poweroff(void)
{
	struct {
		cell_t name;
		cell_t nargs;
		cell_t nreturns;
	} args;
	
	args.name = ADR2CELL("SUNW,power-off");
	args.nargs = 0;
	args.nreturns = 0;
	openfirmware(&args);
}

void
(*OF_set_callback(newfunc))(void *)
	void (*newfunc)(void *);
{
	struct {
		cell_t name;
		cell_t nargs;
		cell_t nreturns;
		cell_t newfunc;
		cell_t oldfunc;
	} args;
	
	args.name = ADR2CELL("set-callback");
	args.nargs = 1;
	args.nreturns = 1;
	args.newfunc = ADR2CELL(newfunc);
	if (openfirmware(&args) == -1)
		return (void *)(long)-1;
	return (void *)(long)args.oldfunc;
}

void 
OF_set_symbol_lookup(s2v, v2s)
	void (*s2v)(void *);
	void (*v2s)(void *);
{
	struct {
		cell_t name;
		cell_t nargs;
		cell_t nreturns;
		cell_t sym2val;
		cell_t val2sym;
	} args;
		
	args.name = ADR2CELL("set-symbol-lookup");
	args.nargs = 2;
	args.nreturns = 0;
	args.sym2val = ADR2CELL(s2v);
	args.val2sym = ADR2CELL(v2s);

	(void)openfirmware(&args);
}

int
OF_interpret(char *cmd, int nreturns, ...)
{
	va_list ap;
	struct {
		cell_t name;
		cell_t nargs;
		cell_t nreturns;
		cell_t slot[16];
	} args;
	cell_t status;
	int i = 0;

	args.name = ADR2CELL("interpret");
	args.nargs = 1;
	args.nreturns = ++nreturns;
	args.slot[i++] = ADR2CELL(cmd);
	va_start(ap, nreturns);
	while (i < 1)
		args.slot[i++] = va_arg(ap, cell_t);
	if (openfirmware(&args) == -1) {
		va_end(ap);
		return (-1);
	}
	status = args.slot[i++];
	while (i < 1 + nreturns)
		*va_arg(ap, cell_t *) = args.slot[i++];
	va_end(ap);
	return (status);
}

int
OF_milliseconds(void)
{
	struct {
		cell_t name;
		cell_t nargs;
		cell_t nreturns;
		cell_t nticks;
	} args;
	
	args.name = ADR2CELL("milliseconds");
	args.nargs = 0;
	args.nreturns = 1;
	if (openfirmware(&args) == -1)
		return -1;
	return (args.nticks);
}

#ifdef DDB
#include <machine/db_machdep.h>
#include <ddb/db_sym.h>
#include <ddb/db_extern.h>

int obp_symbol_debug = 0;

void OF_sym2val(cells)
	void *cells;
{
	struct args {
		cell_t service;
		cell_t nargs;
		cell_t nreturns;
		cell_t symbol;
		cell_t result;
		cell_t value;
	} *args = (struct args*)cells;
	char *symbol;
	db_expr_t value;

	/* Set data segment pointer */
	__asm volatile("clr %%g4" : :); 

	/* No args?  Nothing to do. */
	if (!args->nargs || 
	    !args->nreturns) return;

	/* Do we have a place for the value? */
	if (args->nreturns != 2) {
		args->nreturns = 1;
		args->result = -1;
		return;
	} 
	symbol = (char *)(u_long)args->symbol;
	if (obp_symbol_debug)
		prom_printf("looking up symbol %s\r\n", symbol);
	args->result = (db_value_of_name(symbol, &value) == TRUE) ? 0 : -1;
	if (obp_symbol_debug)
		prom_printf("%s is %lx\r\n", symbol, value);
	args->value = ADR2CELL(value);
}

void OF_val2sym(cells)
	void *cells;
{
	struct args {
		cell_t service;
		cell_t nargs;
		cell_t nreturns;
		cell_t value;
		cell_t offset;
		cell_t symbol;
	} *args = (struct args*)cells;
	db_sym_t symbol;
	db_expr_t value;
	db_expr_t offset;

	/* Set data segment pointer */
	__asm volatile("clr %%g4" : :);

	if (obp_symbol_debug)
		prom_printf("OF_val2sym: nargs %lx nreturns %lx\r\n",
			args->nargs, args->nreturns);
	/* No args?  Nothing to do. */
	if (!args->nargs || 
	    !args->nreturns) return;

	/* Do we have a place for the value? */
	if (args->nreturns != 2) {
		args->nreturns = 1;
		args->offset = -1;
		return;
	} 
	
	value = args->value;
	if (obp_symbol_debug)
		prom_printf("looking up value %ld\r\n", value);
	symbol = db_search_symbol(value, 0, &offset);
	if (symbol == NULL) {
		if (obp_symbol_debug)
			prom_printf("OF_val2sym: not found\r\n");
		args->nreturns = 1;
		args->offset = -1;
		return;		
	}
	args->offset = offset;
	args->symbol = ADR2CELL(symbol);
       
}
#endif

int
OF_is_compatible(int handle, const char *name)
{
	char compat[256];
	char *str;
	int len;

	len = OF_getprop(handle, "compatible", &compat, sizeof(compat));
	if (len <= 0)
		return 0;

	/* Guarantee that the buffer is null-terminated. */
	compat[sizeof(compat) - 1] = 0;

	str = compat;
	while (len > 0) {
		if (strcmp(str, name) == 0)
			return 1;
		len -= strlen(str) + 1;
		str += strlen(str) + 1;
	}

	return 0;
}
@


1.18
log
@Reduces the noise around the global ``ticks'' variable by renaming
all the local ones to ``nticks''.

ok stefan@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: openfirm.c,v 1.17 2016/03/07 13:21:51 naddy Exp $	*/
d842 25
@


1.17
log
@Sync no-argument function declaration and definition by adding (void).
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: openfirm.c,v 1.16 2016/03/01 11:56:00 mpi Exp $	*/
d740 1
a740 1
		cell_t ticks;
d748 1
a748 1
	return (args.ticks);
@


1.16
log
@DB_SYM_NULL -> NULL.
@
text
@d1 1
a1 1
/*	$OpenBSD: openfirm.c,v 1.15 2014/03/29 18:09:30 guenther Exp $	*/
d614 1
a614 1
OF_enter()
d629 1
a629 1
OF_exit()
d645 1
a645 1
OF_poweroff()
d734 1
a734 1
OF_milliseconds()
@


1.15
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: openfirm.c,v 1.14 2010/04/10 14:02:49 kettenis Exp $	*/
d830 1
a830 1
	if (symbol == DB_SYM_NULL) {
@


1.14
log
@Make this compile with gcc4.  Cleanup some debug code while I'm there.
@
text
@d1 1
a1 1
/*	$OpenBSD: openfirm.c,v 1.13 2007/02/11 20:29:22 miod Exp $	*/
d773 1
a773 1
	__asm __volatile("clr %%g4" : :); 
d810 1
a810 1
	__asm __volatile("clr %%g4" : :);
@


1.13
log
@Remove _KERNEL_OPT leftovers.
@
text
@d1 1
a1 1
/*	$OpenBSD: openfirm.c,v 1.12 2007/01/16 14:39:57 tsi Exp $	*/
d508 1
a508 1
	for (; len > 0; len -= l, (char *)addr += l) {
d544 4
a547 1
		
d553 1
a553 8
if (len>1024) { prom_printf("OF_write() > 1024\n");
#ifdef DDB
Debugger();
#else
panic("OF_write");
#endif
}
	for (; len > 0; len -= l, (char *)addr += l) {
@


1.12
log
@Remove unnecessary ampersands in ADR2CELL macro invocations;
Change OF_printf references to printf, given the former doesn't exist;
Clean up formatting, whitespace, unused code, etc.

ok miod@@, kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: openfirm.c,v 1.11 2005/03/13 17:33:12 deraadt Exp $	*/
a753 4

#if defined(_KERNEL_OPT)
#include "opt_ddb.h"
#endif
@


1.11
log
@va_args repair; andrushock@@korovino.net, ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: openfirm.c,v 1.10 2004/08/08 20:11:32 miod Exp $	*/
d55 1
a55 1
	args.name = ADR2CELL(&"peer");
d76 1
a76 1
	args.name = ADR2CELL(&"child");
d97 1
a97 1
	args.name = ADR2CELL(&"parent");
d118 1
a118 1
	args.name = ADR2CELL(&"instance-to-package");
d142 1
a142 1
	args.name = ADR2CELL(&"getproplen");
d172 1
a172 1
	args.name = ADR2CELL(&"getprop");
d204 1
a204 1
	args.name = ADR2CELL(&"setprop");
d232 1
a232 1
	args.name = ADR2CELL(&"nextprop");
d255 1
a255 1
	args.name = ADR2CELL(&"finddevice");
d282 1
a282 1
	args.name = ADR2CELL(&"instance-to-path");
d311 1
a311 1
	args.name = ADR2CELL(&"package-to-path");
d341 1
a341 1
	args.name = ADR2CELL(&"call-method");
d379 1
a379 1
	args.name = ADR2CELL(&"call-method");
d410 1
a410 1
	args.name = ADR2CELL(&"open");	
d430 1
a430 1
	args.name = ADR2CELL(&"close");
d449 1
a449 1
	args.name = ADR2CELL(&"test");
d472 1
a472 1
	args.name = ADR2CELL(&"test-method");
d503 1
a503 1
	args.name = ADR2CELL(&"read");	
d545 1
a545 1
	args.name = ADR2CELL(&"write");
d584 1
a584 1
	args.name = ADR2CELL(&"seek");
d588 2
a589 2
	args.poshi = HDL2CELL(pos >> 32);
	args.poslo = HDL2CELL(pos);
d609 1
a609 1
	args.name = ADR2CELL(&"boot");	
d626 1
a626 1
	args.name = ADR2CELL(&"enter");
d641 1
a641 1
	args.name = ADR2CELL(&"exit");
d657 1
a657 1
	args.name = ADR2CELL(&"SUNW,power-off");
d675 1
a675 1
	args.name = ADR2CELL(&"set-callback");
d697 1
a697 1
	args.name = ADR2CELL(&"set-symbol-lookup");
d719 1
a719 1
	args.name = ADR2CELL(&"interpret");
d747 1
a747 1
	args.name = ADR2CELL(&"milliseconds");
@


1.10
log
@Do not panic if OF_poweroff() returns, this is handled correctly by
the caller.
@
text
@d1 1
a1 1
/*	$OpenBSD: openfirm.c,v 1.9 2004/01/07 20:44:56 pvalchev Exp $	*/
d388 1
a388 2
	if (openfirmware(&args) == -1) {
		va_end(ap);
d390 1
a390 3
	}
	if (args.args_n_results[nargs]) {
		va_end(ap);
a391 1
	}
@


1.9
log
@machine/stdarg.h -> sys/stdarg.h; ok espie
@
text
@d1 1
a1 1
/*	$OpenBSD: openfirm.c,v 1.8 2002/03/15 18:19:52 millert Exp $	*/
a664 1
	panic("OF_poweroff failed");
@


1.8
log
@Kill #if __STDC__ used to do K&R vs. ANSI varargs/stdarg; just do things
the ANSI way.
@
text
@d1 1
a1 1
/*	$OpenBSD: openfirm.c,v 1.7 2002/03/14 03:16:01 millert Exp $	*/
d36 1
a37 1
#include <machine/stdarg.h>
@


1.7
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: openfirm.c,v 1.6 2002/03/14 01:26:45 millert Exp $	*/
a325 1
#ifdef	__STDC__
a326 8
#else
OF_call_method(method, ihandle, nargs, nreturns, va_alist)
	char *method;
	int ihandle;
	int nargs;
	int nreturns;
	va_dcl
#endif
a363 1
#ifdef	__STDC__
a364 7
#else
OF_call_method_1(method, ihandle, nargs, va_alist)
	char *method;
	int ihandle;
	int nargs;
	va_dcl
#endif
a711 1
#ifdef	__STDC__
a712 6
#else
OF_interpret(cmd, nreturns, va_alist)
	char *cmd;
	int nreturns;
	va_dcl
#endif
@


1.6
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: openfirm.c,v 1.5 2001/12/05 01:59:55 jason Exp $	*/
d356 1
a356 1
	for (ip = (long*)(args.args_n_results + (n = nargs)); --n >= 0;)
d366 1
a366 1
	for (ip = (long*)(args.args_n_results + nargs + (n = args.nreturns)); --n > 0;)
d402 1
a402 1
	for (ip = (long*)(args.args_n_results + (n = nargs)); --n >= 0;)
d460 1
a460 1
	char* service;
d482 1
a482 1
	char* method;
d702 2
a703 2
		return (void*)(long)-1;
	return (void*)(long)args.oldfunc;
@


1.5
log
@Make OF_interpret() work correctly; based on NetBSD fix, but maintaining
old OF_interpret(cmd, nreturns, ...) prototype (why/where/when would you
need nargs anyway?)
@
text
@d1 1
a1 1
/*	$OpenBSD: openfirm.c,v 1.4 2001/09/05 22:32:39 deraadt Exp $	*/
d547 1
a547 1
void prom_printf __P((const char *fmt, ...));	/* XXX for below */
@


1.5.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: openfirm.c,v 1.5 2001/12/05 01:59:55 jason Exp $	*/
d326 1
d328 8
d356 1
a356 1
	for (ip = (long *)(args.args_n_results + (n = nargs)); --n >= 0;)
d366 1
a366 1
	for (ip = (long *)(args.args_n_results + nargs + (n = args.nreturns)); --n > 0;)
d373 1
d375 7
d402 1
a402 1
	for (ip = (long *)(args.args_n_results + (n = nargs)); --n >= 0;)
d460 1
a460 1
	char *service;
d482 1
a482 1
	char *method;
d547 1
a547 1
void prom_printf(const char *fmt, ...);	/* XXX for below */
d702 2
a703 2
		return (void *)(long)-1;
	return (void *)(long)args.oldfunc;
d729 1
d731 6
@


1.4
log
@make sure that va_start() has matching va_end()
@
text
@d1 1
a1 1
/*	$OpenBSD: openfirm.c,v 1.3 2001/08/24 00:03:23 art Exp $	*/
d729 8
a736 1
OF_interpret(char *s, int nreturns, ...)
d738 1
d743 1
a743 2
		cell_t verbs;
		cell_t status;
d745 2
a747 3
	if (nreturns != 1)
		panic("XXX - OF_interpret: can't handle multiple returns");
	
d750 14
a763 5
	args.nreturns = 1;
	args.verbs = ADR2CELL(s);
	openfirmware(&args);

	return args.status;
@


1.4.4.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.4.4.2
log
@Merge in trunk
@
text
@d729 1
a729 8
#ifdef	__STDC__
OF_interpret(char *cmd, int nreturns, ...)
#else
OF_interpret(cmd, nreturns, va_alist)
	char *cmd;
	int nreturns;
	va_dcl
#endif
a730 1
	va_list ap;
d735 2
a736 1
		cell_t slot[16];
a737 2
	cell_t status;
	int i = 0;
d739 3
d744 5
a748 14
	args.nreturns = ++nreturns;
	args.slot[i++] = ADR2CELL(cmd);
	va_start(ap, nreturns);
	while (i < 1)
		args.slot[i++] = va_arg(ap, cell_t);
	if (openfirmware(&args) == -1) {
		va_end(ap);
		return (-1);
	}
	status = args.slot[i++];
	while (i < 1 + nreturns)
		*va_arg(ap, cell_t *) = args.slot[i++];
	va_end(ap);
	return (status);
@


1.4.4.3
log
@Merge in -current from about a week ago
@
text
@d326 1
d328 8
d356 1
a356 1
	for (ip = (long *)(args.args_n_results + (n = nargs)); --n >= 0;)
d366 1
a366 1
	for (ip = (long *)(args.args_n_results + nargs + (n = args.nreturns)); --n > 0;)
d373 1
d375 7
d402 1
a402 1
	for (ip = (long *)(args.args_n_results + (n = nargs)); --n >= 0;)
d460 1
a460 1
	char *service;
d482 1
a482 1
	char *method;
d547 1
a547 1
void prom_printf(const char *fmt, ...);	/* XXX for below */
d702 2
a703 2
		return (void *)(long)-1;
	return (void *)(long)args.oldfunc;
d729 1
d731 6
@


1.4.4.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@a35 1
#include <sys/stdarg.h>
d37 1
@


1.3
log
@One can get really creative at 2am.
@
text
@d1 1
a1 1
/*	$OpenBSD: openfirm.c,v 1.2 2001/08/20 20:23:53 jason Exp $	*/
d358 2
a359 1
	if (openfirmware(&args) == -1)
d361 3
a363 1
	if (args.args_n_results[nargs])
d365 1
d405 2
a406 1
	if (openfirmware(&args) == -1)
d408 3
a410 1
	if (args.args_n_results[nargs])
d412 1
@


1.2
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d732 1
a732 1
		panic("XXX - bork bork bork");
@


1.1
log
@Lot of stuff... Some from NetBSD, some from OpenBSD, minor modifications
@
text
@d1 1
@

