head	1.36;
access;
symbols
	OPENBSD_6_1_BASE:1.36
	OPENBSD_6_0:1.35.0.4
	OPENBSD_6_0_BASE:1.35
	OPENBSD_5_9:1.35.0.2
	OPENBSD_5_9_BASE:1.35
	OPENBSD_5_8:1.33.0.4
	OPENBSD_5_8_BASE:1.33
	OPENBSD_5_7:1.32.0.2
	OPENBSD_5_7_BASE:1.32
	OPENBSD_5_6:1.30.0.4
	OPENBSD_5_6_BASE:1.30
	OPENBSD_5_5:1.29.0.8
	OPENBSD_5_5_BASE:1.29
	OPENBSD_5_4:1.29.0.4
	OPENBSD_5_4_BASE:1.29
	OPENBSD_5_3:1.29.0.2
	OPENBSD_5_3_BASE:1.29
	OPENBSD_5_2:1.28.0.2
	OPENBSD_5_2_BASE:1.28
	OPENBSD_5_1_BASE:1.27
	OPENBSD_5_1:1.27.0.6
	OPENBSD_5_0:1.27.0.4
	OPENBSD_5_0_BASE:1.27
	OPENBSD_4_9:1.27.0.2
	OPENBSD_4_9_BASE:1.27
	OPENBSD_4_8:1.26.0.8
	OPENBSD_4_8_BASE:1.26
	OPENBSD_4_7:1.26.0.4
	OPENBSD_4_7_BASE:1.26
	OPENBSD_4_6:1.26.0.6
	OPENBSD_4_6_BASE:1.26
	OPENBSD_4_5:1.26.0.2
	OPENBSD_4_5_BASE:1.26
	OPENBSD_4_4:1.25.0.2
	OPENBSD_4_4_BASE:1.25
	OPENBSD_4_3:1.23.0.2
	OPENBSD_4_3_BASE:1.23
	OPENBSD_4_2:1.15.0.2
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.13.0.4
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.13.0.2
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.12.0.4
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.2
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.10.0.4
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.10.0.2
	OPENBSD_3_6_BASE:1.10
	SMP_SYNC_A:1.10
	SMP_SYNC_B:1.10
	OPENBSD_3_5:1.9.0.6
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.4
	OPENBSD_3_4_BASE:1.9
	UBC_SYNC_A:1.9
	OPENBSD_3_3:1.9.0.2
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	UBC_SYNC_B:1.8
	UBC:1.6.0.2
	UBC_BASE:1.6
	SMP:1.3.0.4
	OPENBSD_3_0:1.3.0.2
	OPENBSD_3_0_BASE:1.3;
locks; strict;
comment	@ * @;


1.36
date	2017.02.12.04.55.08;	author guenther;	state Exp;
branches;
next	1.35;
commitid	1rXx7AiXIWFC9gYa;

1.35
date	2015.11.06.06.33.26;	author guenther;	state Exp;
branches;
next	1.34;
commitid	wzHEHv1WzrJZbX9A;

1.34
date	2015.09.08.10.24.26;	author deraadt;	state Exp;
branches;
next	1.33;
commitid	vmJYOChRDa3hLxTe;

1.33
date	2015.05.05.02.13.47;	author guenther;	state Exp;
branches;
next	1.32;
commitid	dNPv28CJI5BxtRGW;

1.32
date	2014.11.16.12.30.59;	author deraadt;	state Exp;
branches;
next	1.31;
commitid	yv0ECmCdICvq576h;

1.31
date	2014.10.24.20.26.58;	author kettenis;	state Exp;
branches;
next	1.30;
commitid	uHRFGdi1cruubpXH;

1.30
date	2014.07.12.18.44.43;	author tedu;	state Exp;
branches;
next	1.29;
commitid	uKVPYMN2MLxdZxzH;

1.29
date	2013.01.16.19.04.43;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2012.06.21.00.56.59;	author guenther;	state Exp;
branches;
next	1.27;

1.27
date	2011.01.13.21.19.42;	author kettenis;	state Exp;
branches;
next	1.26;

1.26
date	2008.09.30.18.54.29;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2008.07.14.14.00.01;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2008.03.15.22.05.51;	author kettenis;	state Exp;
branches;
next	1.23;

1.23
date	2008.01.04.00.40.38;	author kettenis;	state Exp;
branches;
next	1.22;

1.22
date	2008.01.03.22.50.04;	author kettenis;	state Exp;
branches;
next	1.21;

1.21
date	2007.11.06.22.20.59;	author kettenis;	state Exp;
branches;
next	1.20;

1.20
date	2007.10.31.22.46.52;	author kettenis;	state Exp;
branches;
next	1.19;

1.19
date	2007.10.17.19.41.36;	author kettenis;	state Exp;
branches;
next	1.18;

1.18
date	2007.10.16.19.22.49;	author kettenis;	state Exp;
branches;
next	1.17;

1.17
date	2007.10.13.07.18.32;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2007.10.10.15.53.53;	author art;	state Exp;
branches;
next	1.15;

1.15
date	2007.06.20.17.29.36;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2007.05.27.20.59.26;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2006.05.29.20.01.32;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2005.08.08.19.48.37;	author kettenis;	state Exp;
branches;
next	1.11;

1.11
date	2005.03.29.19.34.07;	author kettenis;	state Exp;
branches;
next	1.10;

1.10
date	2004.05.23.06.46.09;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2003.02.24.07.55.08;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2002.06.15.17.23.31;	author art;	state Exp;
branches;
next	1.7;

1.7
date	2002.03.14.01.26.45;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.12.04.23.22.42;	author art;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2001.11.06.19.53.16;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2001.11.06.18.41.10;	author art;	state Exp;
branches;
next	1.3;

1.3
date	2001.09.19.20.50.58;	author mickey;	state Exp;
branches
	1.3.4.1;
next	1.2;

1.2
date	2001.08.20.20.23.53;	author jason;	state Exp;
branches;
next	1.1;

1.1
date	2001.08.19.05.21.38;	author jason;	state Exp;
branches;
next	;

1.3.4.1
date	2001.10.31.03.07.59;	author nate;	state Exp;
branches;
next	1.3.4.2;

1.3.4.2
date	2001.11.13.21.04.17;	author niklas;	state Exp;
branches;
next	1.3.4.3;

1.3.4.3
date	2002.03.06.02.04.47;	author niklas;	state Exp;
branches;
next	1.3.4.4;

1.3.4.4
date	2002.03.28.11.23.52;	author niklas;	state Exp;
branches;
next	1.3.4.5;

1.3.4.5
date	2003.03.27.23.42.37;	author niklas;	state Exp;
branches;
next	1.3.4.6;

1.3.4.6
date	2004.06.05.23.11.01;	author niklas;	state Exp;
branches;
next	;

1.6.2.1
date	2002.06.11.03.38.44;	author art;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2002.10.29.00.28.12;	author art;	state Exp;
branches;
next	1.6.2.3;

1.6.2.3
date	2003.05.19.21.46.58;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.36
log
@Split up fork1():
 - FORK_THREAD handling is a totally separate function, thread_fork(),
   that is only used by sys___tfork() and which loses the flags, func,
   arg, and newprocp parameters and gains tcb parameter to guarantee
   the new thread's TCB is set before the creating thread returns
 - fork1() loses its stack and tidptr parameters
Common bits factor out:
 - struct proc allocation and initialization moves to thread_new()
 - maxthread handling moves to fork_check_maxthread()
 - setting the new thread running moves to fork_thread_start()
The MD cpu_fork() function swaps its unused stacksize parameter for
a tcb parameter.

luna88k testing by aoyama@@, alpha testing by dlg@@
ok mpi@@
@
text
@/*	$OpenBSD: vm_machdep.c,v 1.35 2015/11/06 06:33:26 guenther Exp $	*/
/*	$NetBSD: vm_machdep.c,v 1.38 2001/06/30 00:02:20 eeh Exp $ */

/*
 * Copyright (c) 1996
 *	The President and Fellows of Harvard College. All rights reserved.
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
 *
 * All advertising materials mentioning features or use of this software
 * must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Lawrence Berkeley Laboratory.
 *	This product includes software developed by Harvard University.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Harvard University.
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)vm_machdep.c	8.2 (Berkeley) 9/23/93
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/user.h>
#include <sys/malloc.h>
#include <sys/buf.h>
#include <sys/exec.h>
#include <sys/vnode.h>
#include <sys/signalvar.h>

#include <uvm/uvm_extern.h>

#include <machine/cpu.h>
#include <machine/frame.h>
#include <machine/trap.h>
#include <machine/bus.h>

#include <sparc64/sparc64/cache.h>

/*
 * Map a user I/O request into kernel virtual address space.
 * Note: the pages are already locked by uvm_vslock(), so we
 * do not need to pass an access_type to pmap_enter().   
 */
void
vmapbuf(struct buf *bp, vsize_t len)
{
	struct pmap *upmap, *kpmap;
	vaddr_t uva;	/* User VA (map from) */
	vaddr_t kva;	/* Kernel VA (new to) */
	paddr_t pa; 	/* physical address */
	vsize_t off;

	if ((bp->b_flags & B_PHYS) == 0)
		panic("vmapbuf");

	/*
	 * XXX:  It might be better to round/trunc to a
	 * segment boundary to avoid VAC problems!
	 */
	bp->b_saveaddr = bp->b_data;
	uva = trunc_page((vaddr_t)bp->b_data);
	off = (vaddr_t)bp->b_data - uva;
	len = round_page(off + len);
	kva = uvm_km_valloc_prefer_wait(phys_map, len, uva);
	bp->b_data = (caddr_t)(kva + off);

	upmap = vm_map_pmap(&bp->b_proc->p_vmspace->vm_map);
	kpmap = vm_map_pmap(kernel_map);
	do {
		if (pmap_extract(upmap, uva, &pa) == FALSE)
			panic("vmapbuf: null page frame");
		/* Now map the page into kernel space. */
		pmap_enter(pmap_kernel(), kva,
		    pa /* | PMAP_NC */,
		    PROT_READ | PROT_WRITE,
		    PROT_READ | PROT_WRITE | PMAP_WIRED);

		uva += PAGE_SIZE;
		kva += PAGE_SIZE;
		len -= PAGE_SIZE;
	} while (len);
	pmap_update(pmap_kernel());
}

/*
 * Unmap a previously-mapped user I/O request.
 */
void
vunmapbuf(struct buf *bp, vsize_t len)
{
	vaddr_t kva;
	vsize_t off;

	if ((bp->b_flags & B_PHYS) == 0)
		panic("vunmapbuf");

	kva = trunc_page((vaddr_t)bp->b_data);
	off = (vaddr_t)bp->b_data - kva;
	len = round_page(off + len);

	pmap_remove(pmap_kernel(), kva, kva + len);
	pmap_update(pmap_kernel());
	uvm_km_free_wakeup(phys_map, kva, len);
	bp->b_data = bp->b_saveaddr;
	bp->b_saveaddr = NULL;
}


/*
 * The offset of the topmost frame in the kernel stack.
 */
#define	TOPFRAMEOFF (USPACE-sizeof(struct trapframe)-CC64FSZ)
#define	STACK_OFFSET	BIAS

#ifdef DEBUG
char cpu_forkname[] = "cpu_fork()";
#endif

/*
 * Finish a fork operation, with process p2 nearly set up.
 * Copy and update the pcb and trap frame, making the child ready to run.
 * 
 * Rig the child's kernel stack so that it will start out in
 * proc_trampoline() and call 'func' with 'arg' as an argument.
 * For normal processes this is child_return(), which causes the
 * child to go directly to user level with an apparent return value
 * of 0 from fork(), while the parent process returns normally.
 * For kernel threads this will be a function that never return.
 *
 * An alternate user-level stack or TCB can be requested by passing
 * a non-NULL value; these are poked into the PCB so they're in
 * effect at the initial return to userspace.
 */
void
cpu_fork(struct proc *p1, struct proc *p2, void *stack, void *tcb,
    void (*func)(void *), void *arg)
{
	struct pcb *opcb = &p1->p_addr->u_pcb;
	struct pcb *npcb = &p2->p_addr->u_pcb;
	struct trapframe *tf2;
	struct rwindow *rp;
	extern struct proc proc0;

	/*
	 * Save all user registers to p1's stack or, in the case of
	 * user registers and invalid stack pointers, to opcb.
	 * We then copy the whole pcb to p2; when switch() selects p2
	 * to run, it will run at the `proc_trampoline' stub, rather
	 * than returning at the copying code below.
	 *
	 * If process p1 has an FPU state, we must copy it.  If it is
	 * the FPU user, we must save the FPU state first.
	 */

#ifdef NOTDEF_DEBUG
	printf("cpu_fork()\n");
#endif
	if (p1 == curproc) {
		write_user_windows();

		/*
		 * We're in the kernel, so we don't really care about
		 * %ccr or %asi.  We do want to duplicate %pstate and %cwp.
		 */
		opcb->pcb_pstate = getpstate();
		opcb->pcb_cwp = getcwp();
	}
#ifdef DIAGNOSTIC
	else if (p1 != &proc0)
		panic("cpu_fork: curproc");
#endif
#ifdef DEBUG
	/* prevent us from having NULL lastcall */
	opcb->lastcall = cpu_forkname;
#else
	opcb->lastcall = NULL;
#endif
	bcopy((caddr_t)opcb, (caddr_t)npcb, sizeof(struct pcb));
	if (p1->p_md.md_fpstate) {
		fpusave_proc(p1, 1);
		p2->p_md.md_fpstate = malloc(sizeof(struct fpstate64),
		    M_SUBPROC, M_WAITOK);
		bcopy(p1->p_md.md_fpstate, p2->p_md.md_fpstate,
		    sizeof(struct fpstate64));
	} else
		p2->p_md.md_fpstate = NULL;

	/*
	 * Setup (kernel) stack frame that will by-pass the child
	 * out of the kernel. (The trap frame invariably resides at
	 * the tippity-top of the u. area.)
	 */
	tf2 = p2->p_md.md_tf = (struct trapframe *)
			((long)npcb + USPACE - sizeof(*tf2));

	/* Copy parent's trapframe */
	*tf2 = *(struct trapframe *)((long)opcb + USPACE - sizeof(*tf2));

	/*
	 * If specified, give the child a different stack, offset and
	 * with space reserved for the frame, and zero the frame pointer.
	 */
	if (stack != NULL) {
		tf2->tf_out[6] = (u_int64_t)(u_long)stack - (BIAS + CC64FSZ);
		tf2->tf_in[6] = 0;
	}
	if (tcb != NULL)
		tf2->tf_global[7] = (u_int64_t)tcb;

	/* Construct kernel frame to return to in cpu_switch() */
	rp = (struct rwindow *)((u_long)npcb + TOPFRAMEOFF);
	*rp = *(struct rwindow *)((u_long)opcb + TOPFRAMEOFF);
	rp->rw_local[0] = (long)func;		/* Function to call */
	rp->rw_local[1] = (long)arg;		/* and its argument */

	npcb->pcb_pc = (long)proc_trampoline - 8;
	npcb->pcb_sp = (long)rp - STACK_OFFSET;

	/* Need to create a %tstate if we're forking from proc0. */
	if (p1 == &proc0)
		tf2->tf_tstate =
		    ((u_int64_t)ASI_PRIMARY_NO_FAULT << TSTATE_ASI_SHIFT) |
		    ((PSTATE_USER) << TSTATE_PSTATE_SHIFT);
	else
		/* Clear condition codes and disable FPU. */
		tf2->tf_tstate &=
		    ~((PSTATE_PEF << TSTATE_PSTATE_SHIFT) | TSTATE_CCR);

#ifdef NOTDEF_DEBUG
	printf("cpu_fork: Copying over trapframe: otf=%p ntf=%p sp=%p opcb=%p npcb=%p\n", 
	       (struct trapframe *)((char *)opcb + USPACE - sizeof(*tf2)), tf2, rp, opcb, npcb);
	printf("cpu_fork: tstate=%lx pc=%lx npc=%lx rsp=%lx\n",
	       (long)tf2->tf_tstate, (long)tf2->tf_pc, (long)tf2->tf_npc,
	       (long)(tf2->tf_out[6]));
	Debugger();
#endif
}

/*
 * These are the "function" entry points in locore.s to handle IPI's.
 */
void	ipi_save_fpstate(void);
void	ipi_drop_fpstate(void);

void
fpusave_cpu(struct cpu_info *ci, int save)
{
	struct proc *p;

	KDASSERT(ci == curcpu());

	p = ci->ci_fpproc;
	if (p == NULL)
		return;

	if (save)
		savefpstate(p->p_md.md_fpstate);
	else
		clearfpstate();

	ci->ci_fpproc = NULL;
}

void
fpusave_proc(struct proc *p, int save)
{
	struct cpu_info *ci = curcpu();

#ifdef MULTIPROCESSOR
	if (p == ci->ci_fpproc) {
		u_int64_t s = intr_disable();
		fpusave_cpu(ci, save);
		intr_restore(s);
		return;
	}

	for (ci = cpus; ci != NULL; ci = ci->ci_next) {
		if (ci == curcpu())
			continue;
		if (ci->ci_fpproc != p)
			continue;
		sparc64_send_ipi(ci->ci_itid,
		    save ? ipi_save_fpstate : ipi_drop_fpstate, (vaddr_t)p, 0);
		while(ci->ci_fpproc == p)
			sparc_membar(Sync);
		break;
	}
#else
	if (p == ci->ci_fpproc)
		fpusave_cpu(ci, save);
#endif
}

/*
 * cpu_exit is called as the last action during exit.
 *
 * We clean up a little and then call sched_exit() with the old proc
 * as an argument.  sched_exit() schedules the old vmspace and stack
 * to be freed, then selects a new process to run.
 */
void
cpu_exit(struct proc *p)
{
	if (p->p_md.md_fpstate != NULL) {
		fpusave_proc(p, 0);
		free(p->p_md.md_fpstate, M_SUBPROC, sizeof(struct fpstate64));
	}

	pmap_deactivate(p);
	sched_exit(p);
}
@


1.35
log
@Move the logic for adjusting userspace registers in the child after fork
from cpu_fork() to child_return(), putting all the SYSCALL_G2RFLAG logic
in trap.c

sparc testing by sebastia@@ and miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.34 2015/09/08 10:24:26 deraadt Exp $	*/
d156 9
a164 12
 * proc_trampoline() and call child_return() with p2 as an
 * argument. This causes the newly-created child process to go
 * directly to user level with an apparent return value of 0 from
 * fork(), while the parent process returns normally.
 *
 * p1 is the process being forked; if p1 == &proc0, we are creating
 * a kernel thread, and the return path and argument are specified with
 * `func' and `arg'.
 *
 * If an alternate user-level stack is requested (with non-zero values
 * in both the stack and stacksize args), set up the user stack pointer
 * accordingly.
d167 2
a168 6
cpu_fork(p1, p2, stack, stacksize, func, arg)
	struct proc *p1, *p2;
	void *stack;
	size_t stacksize;
	void (*func)(void *);
	void *arg;
d236 1
a236 2
		tf2->tf_out[6] = (u_int64_t)(u_long)stack + stacksize
		    - (BIAS + CC64FSZ);
d239 2
@


1.34
log
@sizes for free(); ok semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.33 2015/05/05 02:13:47 guenther Exp $	*/
a246 21

	/* Duplicate efforts of syscall(), but slightly differently */
	if (tf2->tf_global[1] & SYSCALL_G2RFLAG) {
		/* jmp %g2 (or %g7, deprecated) on success */
		tf2->tf_npc = tf2->tf_global[2];
	} else {
		/*
		 * old system call convention: clear C on success
		 * note: proc_trampoline() sets a fresh psr when
		 * returning to user mode.
		 */
		/*tf2->tf_psr &= ~PSR_C;   -* success */
	}

	/* Set return values in child mode */
	tf2->tf_out[0] = 0;
	tf2->tf_out[1] = 1;

	/* Skip trap instruction. */
	tf2->tf_pc = tf2->tf_npc;
	tf2->tf_npc += 4;
@


1.33
log
@emul_native is only used for kernel threads which can't dump core, so
delete coredump_trad(), uvm_coredump(), cpu_coredump(), struct md_coredump,
and various #includes that are superfluous.

This leaves compat_linux processes without a coredump callback.  If that
ability is desired, someone should update it to use coredump_elf32() and
verify the results...

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.32 2014/11/16 12:30:59 deraadt Exp $	*/
d365 1
a365 1
		free(p->p_md.md_fpstate, M_SUBPROC, 0);
@


1.32
log
@Replace a plethora of historical protection options with just
PROT_NONE, PROT_READ, PROT_WRITE, and PROT_EXEC from mman.h.
PROT_MASK is introduced as the one true way of extracting those bits.
Remove UVM_ADV_* wrapper, using the standard names.
ok doug guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.31 2014/10/24 20:26:58 kettenis Exp $	*/
a55 1
#include <sys/core.h>
a370 47

/*
 * cpu_coredump is called to write a core dump header.
 * (should this be defined elsewhere?  machdep.c?)
 */
int
cpu_coredump(p, vp, cred, chdr)
	struct proc *p;
	struct vnode *vp;
	struct ucred *cred;
	struct core *chdr;
{
	int error;
	struct md_coredump md_core;
	struct coreseg cseg;

	CORE_SETMAGIC(*chdr, COREMAGIC, MID_MACHINE, 0);
	chdr->c_hdrsize = ALIGN(sizeof(*chdr));
	chdr->c_seghdrsize = ALIGN(sizeof(cseg));
	chdr->c_cpusize = sizeof(md_core);

	md_core.md_tf = *p->p_md.md_tf;
	md_core.md_wcookie = p->p_addr->u_pcb.pcb_wcookie;
	if (p->p_md.md_fpstate) {
		fpusave_proc(p, 1);
		md_core.md_fpstate = *p->p_md.md_fpstate;
	} else
		bzero((caddr_t)&md_core.md_fpstate, 
		      sizeof(md_core.md_fpstate));

	CORE_SETMAGIC(cseg, CORESEGMAGIC, MID_MACHINE, CORE_CPU);
	cseg.c_addr = 0;
	cseg.c_size = chdr->c_cpusize;
	error = vn_rdwr(UIO_WRITE, vp, (caddr_t)&cseg, chdr->c_seghdrsize,
	    (off_t)chdr->c_hdrsize, UIO_SYSSPACE, IO_UNIT, cred, NULL, p);
	if (error)
		return error;

	error = vn_rdwr(UIO_WRITE, vp, (caddr_t)&md_core, sizeof(md_core),
	    (off_t)(chdr->c_hdrsize + chdr->c_seghdrsize), UIO_SYSSPACE,
	    IO_UNIT, cred, NULL, p);
	if (!error)
		chdr->c_nseg++;

	return error;
}

@


1.31
log
@Bring phys_map to sparc64 and use it in vmapbuf(9) and vunmapbuf(9).
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.30 2014/07/12 18:44:43 tedu Exp $	*/
d107 3
a109 3
			pa /* | PMAP_NC */,
			VM_PROT_READ|VM_PROT_WRITE,
			VM_PROT_READ|VM_PROT_WRITE|PMAP_WIRED);
@


1.30
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.29 2013/01/16 19:04:43 miod Exp $	*/
d78 1
a78 3
vmapbuf(bp, len)
	struct buf *bp;
	vsize_t len;
d97 1
a97 1
	kva = uvm_km_valloc_prefer_wait(kernel_map, len, uva);
d122 1
a122 3
vunmapbuf(bp, len)
	struct buf *bp;
	vsize_t len;
d136 1
a136 1
	uvm_km_free_wakeup(kernel_map, kva, len);
@


1.29
log
@cpu_coredump() also needs to invoke vn_rdwr() without IO_NODELOCKED; only
affects a.out binaries' core dumps.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.28 2012/06/21 00:56:59 guenther Exp $	*/
d370 1
a370 1
		free(p->p_md.md_fpstate, M_SUBPROC);
@


1.28
log
@__tfork() needs to set the stack address of the new thread in the kernel,
so that it can't get a signal while still running on the parent thread's
stack.  Also, pass in sizeof(struct __tfork) to provide forward compat
when more members are added.  This is an ABI change, so switch syscall
numbers and bump lib majors this time.

ok deraadt@@ matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.27 2011/01/13 21:19:42 kettenis Exp $	*/
d410 1
a410 2
	    (off_t)chdr->c_hdrsize, UIO_SYSSPACE,
	    IO_NODELOCKED|IO_UNIT, cred, NULL, p);
d416 1
a416 1
	    IO_NODELOCKED|IO_UNIT, cred, NULL, p);
@


1.27
log
@Spin forever when waiting for completion of an FPU shootdown instead of
panicing if we spin for too long.  It is difficult to find an upper bound
for the spin count and there is some evidence the current limit is too low.
We made similar changes to amd64/i386 some time ago.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.26 2008/09/30 18:54:29 miod Exp $	*/
d244 2
a245 1
	 * If specified, give the child a different stack.
d247 5
a251 2
	if (stack != NULL)
		tf2->tf_out[6] = (u_int64_t)(u_long)stack + stacksize;
@


1.26
log
@Do not perform cache operations in vmapbuf(), pmap is supposed to do them
for us if needed.

ok art@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.25 2008/07/14 14:00:01 miod Exp $	*/
a337 2
		int spincount = 0;

d344 1
a344 5
		while(ci->ci_fpproc == p) {
			spincount++;
			if (spincount > 10000000) {
				panic("ipi_save_fpstate didn't");
			}
a345 1
		}
@


1.25
log
@Use uvm_km_valloc_prefer_wait() instead of uvm_km_valloc_wait() in vmapbuf().

ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.24 2008/03/15 22:05:51 kettenis Exp $	*/
a100 7

	/*
	 * We have to flush any write-back cache on the
	 * user-space mappings so our new mappings will
	 * have the correct contents.
	 */
	cache_flush(uva, len);
@


1.24
log
@Make GENERIC.MP work on the e10k.  The e10k is a bit funky since UPA only
supports 32 ports, and a machine with up to 64 CPUs obviously needs more.
So the machine has a special ASIC that does port translation, and because
of that we need to distinguish between port ID's and interrupt target ID's.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.23 2008/01/04 00:40:38 kettenis Exp $	*/
d99 1
a99 1
	kva = uvm_km_valloc_wait(kernel_map, len);
@


1.23
log
@Prevent sign-extension when setting ASI in %tstate.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.22 2008/01/03 22:50:04 kettenis Exp $	*/
d351 1
a351 1
		sparc64_send_ipi(ci->ci_upaid,
@


1.22
log
@Fix debug code.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.21 2007/11/06 22:20:59 kettenis Exp $	*/
d286 1
a286 1
	/* Need to create a %tstate if we're forking from proc0 */
d288 3
a290 2
		tf2->tf_tstate = (ASI_PRIMARY_NO_FAULT<<TSTATE_ASI_SHIFT) |
			((PSTATE_USER)<<TSTATE_PSTATE_SHIFT);
d292 1
a292 1
		/* clear condition codes and disable FPU */
d294 1
a294 1
		    ~((PSTATE_PEF<<TSTATE_PSTATE_SHIFT)|TSTATE_CCR);
@


1.21
log
@Close a race where we might save/drop the fpu state of the wrong process in
the ipi handlers.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.20 2007/10/31 22:46:52 kettenis Exp $	*/
d297 1
a297 1
	       (struct trapframe *)((int)opcb + USPACE - sizeof(*tf2)), tf2, rp, opcb, npcb);
@


1.20
log
@Overhaul fpu context save/restore code, making it more similar to what we do
on i386 and amd64.  Don't let IPIs in when saving fpu context by disabling
interrupts.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.19 2007/10/17 19:41:36 kettenis Exp $	*/
d351 1
a351 1
		    save ? ipi_save_fpstate : ipi_drop_fpstate, 0, 0);
@


1.19
log
@Sanitize debug printf.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.18 2007/10/16 19:22:49 kettenis Exp $	*/
d231 1
a231 1
		save_and_clear_fpstate(p1);
d312 1
a312 1
save_and_clear_fpstate(struct proc *p)
d314 7
a320 3
#ifdef MULTIPROCESSOR
	struct cpu_info *ci;
#endif
d322 1
a322 1
	if (p == fpproc) {
d324 16
a339 1
		fpproc = NULL;
d342 1
a342 1
#ifdef MULTIPROCESSOR
d350 2
a351 1
		sparc64_send_ipi(ci->ci_upaid, ipi_save_fpstate, 0, 0);
d361 3
d377 3
a379 30
	register struct fpstate64 *fs;
#ifdef MULTIPROCESSOR
	struct cpu_info *ci;
	int found = 0;
#endif

	if ((fs = p->p_md.md_fpstate) != NULL) {
		if (p == fpproc) {
			clearfpstate();
			fpproc = NULL;
#ifdef MULTIPROCESSOR
			found = 1;
#endif
		}
#ifdef MULTIPROCESSOR
		if (!found) {
			/* check if anyone else has this proc as fpproc */
			for (ci = cpus; ci != NULL; ci = ci->ci_next) {
				if (ci == curcpu())
					continue;
				if (ci->ci_fpproc != p)
					continue;
				sparc64_send_ipi(ci->ci_upaid,
				    ipi_drop_fpstate, 0, 0);
				break;
			}
		}
#endif

		free(fs, M_SUBPROC);
d409 1
a409 1
		save_and_clear_fpstate(p);
@


1.18
log
@Make lazy fpu context switching work for MULTIPROCESSOR kernels.  Tested by
many.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.17 2007/10/13 07:18:32 miod Exp $	*/
d298 2
a299 4
	printf("cpu_fork: tstate=%x:%x pc=%x:%x npc=%x:%x rsp=%x\n",
	       (long)(tf2->tf_tstate>>32), (long)tf2->tf_tstate, 
	       (long)(tf2->tf_pc>>32), (long)tf2->tf_pc,
	       (long)(tf2->tf_npc>>32), (long)tf2->tf_npc, 
@


1.17
log
@Fix cpu_exit() comments to be more closer to reality.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.16 2007/10/10 15:53:53 art Exp $	*/
d230 2
a231 5
       	if (p1->p_md.md_fpstate) {
		if (p1 == fpproc) {
			savefpstate(p1->p_md.md_fpstate);
			fpproc = NULL;
		}
d308 39
d357 4
d364 1
a364 1
			savefpstate(fs);
d366 16
d383 3
a385 1
		free((void *)fs, M_SUBPROC);
d415 1
a415 4
		if (p == fpproc) {
			savefpstate(p->p_md.md_fpstate);
			fpproc = NULL;
		}
@


1.16
log
@Make context switching much more MI:
 - Move the functionality of choosing a process from cpu_switch into
   a much simpler function: cpu_switchto. Instead of having the locore
   code walk the run queues, let the MI code choose the process we
   want to run and only implement the context switching itself in MD
   code.
 - Let MD context switching run without worrying about spls or locks.
 - Instead of having the idle loop implemented with special contexts
   in MD code, implement one idle proc for each cpu. make the idle
   loop MI with MD hooks.
 - Change the proc lists from the old style vax queues to TAILQs.
 - Change the sleep queue from vax queues to TAILQs. This makes
   wakeup() go from O(n^2) to O(n)

there will be some MD fallout, but it will be fixed shortly.
There's also a few cleanups to be done after this.

deraadt@@, kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.15 2007/06/20 17:29:36 miod Exp $	*/
d313 3
a315 4
 * We clean up a little and then call switchexit() with the old proc
 * as an argument.  switchexit() switches to the idle context, schedules
 * the old vmspace and stack to be freed, then selects a new process to
 * run.
@


1.15
log
@In vunmapbuf(), explicitely remove mappings before invoking uvm_km_free().
Even if the latter would end up removing the mappings by itself, it would
do so using pmap_remove() because phys_map is not intrsafe; but some
platforms use pmap_kenter_pa() in vmapbuf(). By removing the mappings
ourselves, we can ensure the remove function used matches the enter function
which has been used.
Discussed and theoretical ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.14 2007/05/27 20:59:26 miod Exp $	*/
d319 1
a319 2
cpu_exit(p)
	struct proc *p;
d330 3
a332 2
	switchexit(p);
	/* NOTREACHED */
@


1.14
log
@pagemove() is no longer used.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.13 2006/05/29 20:01:32 miod Exp $	*/
d145 2
a146 1
	/* This will call pmap_remove() for us. */
@


1.13
log
@Remove dead extern declarations.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.12 2005/08/08 19:48:37 kettenis Exp $	*/
a70 25

/*
 * Move pages from one kernel virtual address to another.
 */
void
pagemove(from, to, size)
	register caddr_t from, to;
	size_t size;
{
	paddr_t pa;

	if (size & PGOFSET || (long)from & PGOFSET || (long)to & PGOFSET)
		panic("pagemove 1");

	while (size > 0) {
		if (pmap_extract(pmap_kernel(), (vaddr_t)from, &pa) == FALSE)
			panic("pagemove 2");
		pmap_kremove((vaddr_t)from, PAGE_SIZE);
		pmap_kenter_pa((vaddr_t)to, pa, VM_PROT_READ|VM_PROT_WRITE);
		from += PAGE_SIZE;
		to += PAGE_SIZE;
		size -= PAGE_SIZE;
	}
	pmap_update(pmap_kernel());
}
@


1.12
log
@Skip (trap) instruction in cpu_fork() instead of proc_trampoline().
Fixes returning from fork(2) in the child with a pending signal.
tested by otto@@, krw@@, sturm@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.11 2005/03/29 19:34:07 kettenis Exp $	*/
a70 5

/* XXX These are in sbusvar.h, but including that would be problematical */
struct sbus_softc *sbus0;
void    sbus_enter(struct sbus_softc *, vaddr_t va, int64_t pa, int flags);
void    sbus_remove(struct sbus_softc *, vaddr_t va, int len);
@


1.11
log
@sparc64 StackGhost.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.10 2004/05/23 06:46:09 deraadt Exp $	*/
d304 4
@


1.10
log
@netbsd 1.54; do not count on new process having cleared condition codes;
hunted down by brian poole as relevant for the occassional cron failure
at startup...
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.9 2003/02/24 07:55:08 miod Exp $	*/
d381 1
@


1.9
log
@Oops, forgot to commit that part of the pmap_kenter changes; spotted by art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.8 2002/06/15 17:23:31 art Exp $	*/
d313 1
d318 4
a321 1

@


1.8
log
@Decruftification.

We will never have a.out kernels.
We will never have 32-bit kernels.
We will never have sun4c, sun4 and sun4m support in the sparc64 kernels.
We don't need support old netbsd libc.
The cpu will never be identified as some of the sun4c and sun4m types.
We don't need the gazillion of fields in cpuinfo that the sparc port uses.
Just generally remove dead code.

This is just a first step in making this meess readable.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.7 2002/03/14 01:26:45 millert Exp $	*/
d93 2
a94 5
		pmap_remove(pmap_kernel(),
		    (vaddr_t)from, (vaddr_t)from + PAGE_SIZE);
		pmap_enter(pmap_kernel(),
		    (vaddr_t)to, pa, VM_PROT_READ|VM_PROT_WRITE,
		    VM_PROT_READ|VM_PROT_WRITE|PMAP_WIRED);
@


1.7
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.6 2001/12/04 23:22:42 art Exp $	*/
a181 5

#if 0	/* XXX: The flush above is sufficient, right? */
	if (CACHEINFO.c_vactype != VAC_NONE)
		cpuinfo.cache_flush(bp->b_data, len);
#endif
a187 1
#ifdef __arch64__
a189 8
#else
#undef	trapframe
#define	trapframe	trapframe64
#undef	rwindow
#define	rwindow		rwindow32
#define	TOPFRAMEOFF (USPACE-sizeof(struct trapframe)-CC64FSZ)
#define	STACK_OFFSET	0
#endif
@


1.6
log
@Yet another sync to NetBSD uvm.
Today we add a pmap argument to pmap_update() and allocate map entries for
kernel_map from kmem_map instead of using the static entries. This should
get rid of MAX_KMAPENT panics. Also some uvm_loan problems are fixed.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.5 2001/11/06 19:53:16 miod Exp $	*/
d74 2
a75 2
void    sbus_enter __P((struct sbus_softc *, vaddr_t va, int64_t pa, int flags));
void    sbus_remove __P((struct sbus_softc *, vaddr_t va, int len));
@


1.6.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.6 2001/12/04 23:22:42 art Exp $	*/
d74 2
a75 2
void    sbus_enter(struct sbus_softc *, vaddr_t va, int64_t pa, int flags);
void    sbus_remove(struct sbus_softc *, vaddr_t va, int len);
@


1.6.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.6.2.1 2002/06/11 03:38:44 art Exp $	*/
d182 5
d193 1
d196 8
@


1.6.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d93 5
a97 2
		pmap_kremove((vaddr_t)from, PAGE_SIZE);
		pmap_kenter_pa((vaddr_t)to, pa, VM_PROT_READ|VM_PROT_WRITE);
@


1.5
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.4 2001/11/06 18:41:10 art Exp $	*/
d102 1
a102 1
	pmap_update();
d157 1
a157 1
	pmap_update();
@


1.4
log
@Let fork1, uvm_fork, and cpu_fork take a function/argument pair as argument,
instead of doing fork1, cpu_set_kpc. This lets us retire cpu_set_kpc and
avoid a multiprocessor race.

This commit breaks vax because it doesn't look like any other arch, someone
working on vax might want to look at this and try to adapt the code to be
more like the rest of the world.

Idea and uvm parts from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.3 2001/09/19 20:50:58 mickey Exp $	*/
a62 1
#include <vm/vm.h>
@


1.3
log
@merge vm/vm_kern.h into uvm/uvm_extern.h; art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.2 2001/08/20 20:23:53 jason Exp $	*/
d229 1
a229 1
cpu_fork(p1, p2, stack, stacksize)
d233 2
d326 2
a327 2
	rp->rw_local[0] = (long)child_return;	/* Function to call */
	rp->rw_local[1] = (long)p2;		/* and its argument */
a346 25
}

void
cpu_set_kpc(p, pc, arg)
	struct proc *p;
	void (*pc) __P((void *));
	void *arg;
{
	struct pcb *pcb;
	struct rwindow *rp;

	pcb = &p->p_addr->u_pcb;

	rp = (struct rwindow *)((u_long)pcb + TOPFRAMEOFF);
	rp->rw_local[0] = (long)pc;             /* Function to call */
	rp->rw_local[1] = (long)arg;            /* and its argument */

	/*
	 * Frob PCB:
	 *      - arrange to return to proc_trampoline() from cpu_switch()
	 *      - point it at the stack frame constructed above
	 *      - make it run in a clear set of register windows
	 */
	pcb->pcb_pc = (long)proc_trampoline - 8;
	pcb->pcb_sp = (long)rp - STACK_OFFSET;
@


1.3.4.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.3.4.2
log
@Merge in -current
@
text
@d63 1
d229 1
a229 1
cpu_fork(p1, p2, stack, stacksize, func, arg)
a232 2
	void (*func)(void *);
	void *arg;
d324 2
a325 2
	rp->rw_local[0] = (long)func;		/* Function to call */
	rp->rw_local[1] = (long)arg;		/* and its argument */
d345 25
@


1.3.4.3
log
@Merge in trunk
@
text
@d102 1
a102 1
	pmap_update(pmap_kernel());
d157 1
a157 1
	pmap_update(pmap_kernel());
@


1.3.4.4
log
@Merge in -current from about a week ago
@
text
@d74 2
a75 2
void    sbus_enter(struct sbus_softc *, vaddr_t va, int64_t pa, int flags);
void    sbus_remove(struct sbus_softc *, vaddr_t va, int len);
@


1.3.4.5
log
@Sync the SMP branch with 3.3
@
text
@d93 5
a97 2
		pmap_kremove((vaddr_t)from, PAGE_SIZE);
		pmap_kenter_pa((vaddr_t)to, pa, VM_PROT_READ|VM_PROT_WRITE);
d182 5
d193 1
d196 8
@


1.3.4.6
log
@Merge with the trunk
@
text
@a312 1

d317 1
a317 4
	else
		/* clear condition codes and disable FPU */
		tf2->tf_tstate &=
		    ~((PSTATE_PEF<<TSTATE_PSTATE_SHIFT)|TSTATE_CCR);
@


1.2
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a63 1
#include <vm/vm_kern.h>
@


1.1
log
@Lot of stuff... Some from NetBSD, some from OpenBSD, minor modifications
@
text
@d1 1
@

