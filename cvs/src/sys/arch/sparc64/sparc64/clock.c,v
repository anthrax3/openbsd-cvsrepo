head	1.58;
access;
symbols
	OPENBSD_6_1:1.58.0.4
	OPENBSD_6_1_BASE:1.58
	OPENBSD_6_0:1.58.0.2
	OPENBSD_6_0_BASE:1.58
	OPENBSD_5_9:1.57.0.2
	OPENBSD_5_9_BASE:1.57
	OPENBSD_5_8:1.57.0.4
	OPENBSD_5_8_BASE:1.57
	OPENBSD_5_7:1.56.0.2
	OPENBSD_5_7_BASE:1.56
	OPENBSD_5_6:1.54.0.4
	OPENBSD_5_6_BASE:1.54
	OPENBSD_5_5:1.51.0.4
	OPENBSD_5_5_BASE:1.51
	OPENBSD_5_4:1.49.0.2
	OPENBSD_5_4_BASE:1.49
	OPENBSD_5_3:1.48.0.12
	OPENBSD_5_3_BASE:1.48
	OPENBSD_5_2:1.48.0.10
	OPENBSD_5_2_BASE:1.48
	OPENBSD_5_1_BASE:1.48
	OPENBSD_5_1:1.48.0.8
	OPENBSD_5_0:1.48.0.6
	OPENBSD_5_0_BASE:1.48
	OPENBSD_4_9:1.48.0.4
	OPENBSD_4_9_BASE:1.48
	OPENBSD_4_8:1.48.0.2
	OPENBSD_4_8_BASE:1.48
	OPENBSD_4_7:1.47.0.4
	OPENBSD_4_7_BASE:1.47
	OPENBSD_4_6:1.47.0.6
	OPENBSD_4_6_BASE:1.47
	OPENBSD_4_5:1.47.0.2
	OPENBSD_4_5_BASE:1.47
	OPENBSD_4_4:1.44.0.2
	OPENBSD_4_4_BASE:1.44
	OPENBSD_4_3:1.38.0.2
	OPENBSD_4_3_BASE:1.38
	OPENBSD_4_2:1.33.0.2
	OPENBSD_4_2_BASE:1.33
	OPENBSD_4_1:1.26.0.4
	OPENBSD_4_1_BASE:1.26
	OPENBSD_4_0:1.26.0.2
	OPENBSD_4_0_BASE:1.26
	OPENBSD_3_9:1.23.0.4
	OPENBSD_3_9_BASE:1.23
	OPENBSD_3_8:1.23.0.2
	OPENBSD_3_8_BASE:1.23
	OPENBSD_3_7:1.22.0.2
	OPENBSD_3_7_BASE:1.22
	OPENBSD_3_6:1.20.0.2
	OPENBSD_3_6_BASE:1.20
	SMP_SYNC_A:1.19
	SMP_SYNC_B:1.19
	OPENBSD_3_5:1.18.0.4
	OPENBSD_3_5_BASE:1.18
	OPENBSD_3_4:1.18.0.2
	OPENBSD_3_4_BASE:1.18
	UBC_SYNC_A:1.17
	OPENBSD_3_3:1.17.0.2
	OPENBSD_3_3_BASE:1.17
	OPENBSD_3_2:1.13.0.2
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.12.0.2
	OPENBSD_3_1_BASE:1.12
	UBC_SYNC_B:1.14
	UBC:1.6.0.2
	UBC_BASE:1.6
	SMP:1.3.0.4
	OPENBSD_3_0:1.3.0.2
	OPENBSD_3_0_BASE:1.3;
locks; strict;
comment	@ * @;


1.58
date	2016.03.07.13.21.51;	author naddy;	state Exp;
branches;
next	1.57;
commitid	EDvRPKRZUDEEb6oR;

1.57
date	2015.06.13.07.16.37;	author jsg;	state Exp;
branches;
next	1.56;
commitid	h4MBZBV4zyNpGQH3;

1.56
date	2014.12.17.19.39.01;	author tedu;	state Exp;
branches;
next	1.55;
commitid	tfI16Mtx7wd6kmar;

1.55
date	2014.11.16.12.30.59;	author deraadt;	state Exp;
branches;
next	1.54;
commitid	yv0ECmCdICvq576h;

1.54
date	2014.07.12.18.44.43;	author tedu;	state Exp;
branches;
next	1.53;
commitid	uKVPYMN2MLxdZxzH;

1.53
date	2014.05.10.12.15.19;	author kettenis;	state Exp;
branches;
next	1.52;

1.52
date	2014.03.29.18.09.30;	author guenther;	state Exp;
branches;
next	1.51;

1.51
date	2014.02.08.11.04.50;	author kettenis;	state Exp;
branches;
next	1.50;

1.50
date	2014.01.30.00.51.13;	author dlg;	state Exp;
branches;
next	1.49;

1.49
date	2013.07.05.20.30.56;	author guenther;	state Exp;
branches;
next	1.48;

1.48
date	2010.07.07.15.37.22;	author kettenis;	state Exp;
branches;
next	1.47;

1.47
date	2008.08.10.14.13.05;	author kettenis;	state Exp;
branches;
next	1.46;

1.46
date	2008.08.07.21.25.47;	author kettenis;	state Exp;
branches;
next	1.45;

1.45
date	2008.08.07.18.46.04;	author kettenis;	state Exp;
branches;
next	1.44;

1.44
date	2008.07.15.22.49.01;	author kettenis;	state Exp;
branches;
next	1.43;

1.43
date	2008.06.11.04.44.19;	author kettenis;	state Exp;
branches;
next	1.42;

1.42
date	2008.05.22.21.39.04;	author kettenis;	state Exp;
branches;
next	1.41;

1.41
date	2008.04.17.19.52.27;	author kettenis;	state Exp;
branches;
next	1.40;

1.40
date	2008.04.15.22.39.26;	author kettenis;	state Exp;
branches;
next	1.39;

1.39
date	2008.03.29.20.07.36;	author kettenis;	state Exp;
branches;
next	1.38;

1.38
date	2007.11.14.20.43.12;	author kettenis;	state Exp;
branches;
next	1.37;

1.37
date	2007.11.11.19.47.34;	author kettenis;	state Exp;
branches;
next	1.36;

1.36
date	2007.10.21.21.00.38;	author kettenis;	state Exp;
branches;
next	1.35;

1.35
date	2007.10.19.15.29.22;	author kettenis;	state Exp;
branches;
next	1.34;

1.34
date	2007.10.17.21.23.28;	author kettenis;	state Exp;
branches;
next	1.33;

1.33
date	2007.05.06.14.52.36;	author kettenis;	state Exp;
branches;
next	1.32;

1.32
date	2007.04.09.19.59.06;	author kettenis;	state Exp;
branches;
next	1.31;

1.31
date	2007.04.07.19.24.58;	author kettenis;	state Exp;
branches;
next	1.30;

1.30
date	2007.04.01.12.22.24;	author kettenis;	state Exp;
branches;
next	1.29;

1.29
date	2007.03.19.14.04.04;	author art;	state Exp;
branches;
next	1.28;

1.28
date	2007.03.19.12.45.01;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2007.03.16.09.28.38;	author art;	state Exp;
branches;
next	1.26;

1.26
date	2006.07.01.20.05.11;	author kettenis;	state Exp;
branches;
next	1.25;

1.25
date	2006.06.21.22.28.56;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2006.06.20.20.31.32;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2005.04.26.18.54.39;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2004.09.28.19.21.58;	author jason;	state Exp;
branches;
next	1.21;

1.21
date	2004.09.23.17.25.03;	author jason;	state Exp;
branches;
next	1.20;

1.20
date	2004.06.28.01.47.41;	author aaron;	state Exp;
branches;
next	1.19;

1.19
date	2004.04.08.01.11.22;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2003.05.18.15.32.10;	author henric;	state Exp;
branches;
next	1.17;

1.17
date	2003.02.28.21.30.30;	author jason;	state Exp;
branches;
next	1.16;

1.16
date	2003.02.22.23.50.37;	author jason;	state Exp;
branches;
next	1.15;

1.15
date	2003.02.17.01.29.20;	author henric;	state Exp;
branches;
next	1.14;

1.14
date	2002.10.12.01.09.43;	author krw;	state Exp;
branches;
next	1.13;

1.13
date	2002.06.15.17.23.31;	author art;	state Exp;
branches;
next	1.12;

1.12
date	2002.04.04.17.01.12;	author jason;	state Exp;
branches;
next	1.11;

1.11
date	2002.04.03.17.22.40;	author jason;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.14.03.16.01;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.14.01.26.45;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.01.25.03.36.25;	author jason;	state Exp;
branches;
next	1.7;

1.7
date	2002.01.10.00.06.17;	author nordin;	state Exp;
branches;
next	1.6;

1.6
date	2001.12.07.19.09.00;	author jason;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2001.12.07.16.30.20;	author jason;	state Exp;
branches;
next	1.4;

1.4
date	2001.11.06.19.53.16;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2001.10.02.14.57.09;	author jason;	state Exp;
branches
	1.3.4.1;
next	1.2;

1.2
date	2001.08.20.20.23.53;	author jason;	state Exp;
branches;
next	1.1;

1.1
date	2001.08.19.05.21.38;	author jason;	state Exp;
branches;
next	;

1.3.4.1
date	2001.10.31.03.07.58;	author nate;	state Exp;
branches;
next	1.3.4.2;

1.3.4.2
date	2001.11.13.21.04.17;	author niklas;	state Exp;
branches;
next	1.3.4.3;

1.3.4.3
date	2002.03.06.02.04.47;	author niklas;	state Exp;
branches;
next	1.3.4.4;

1.3.4.4
date	2002.03.28.11.23.52;	author niklas;	state Exp;
branches;
next	1.3.4.5;

1.3.4.5
date	2003.03.27.23.42.37;	author niklas;	state Exp;
branches;
next	1.3.4.6;

1.3.4.6
date	2003.06.07.11.14.45;	author ho;	state Exp;
branches;
next	1.3.4.7;

1.3.4.7
date	2004.06.05.23.11.00;	author niklas;	state Exp;
branches;
next	;

1.6.2.1
date	2002.01.31.22.55.24;	author niklas;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2002.06.11.03.38.43;	author art;	state Exp;
branches;
next	1.6.2.3;

1.6.2.3
date	2002.10.29.00.28.11;	author art;	state Exp;
branches;
next	1.6.2.4;

1.6.2.4
date	2003.05.19.21.46.57;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.58
log
@Sync no-argument function declaration and definition by adding (void).
ok mpi@@
@
text
@/*	$OpenBSD: clock.c,v 1.57 2015/06/13 07:16:37 jsg Exp $	*/
/*	$NetBSD: clock.c,v 1.41 2001/07/24 19:29:25 eeh Exp $ */

/*
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 * Copyright (c) 1994 Gordon W. Ross
 * Copyright (c) 1993 Adam Glass
 * Copyright (c) 1996 Paul Kranenburg
 * Copyright (c) 1996
 * 	The President and Fellows of Harvard College. All rights reserved.
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
 *
 * All advertising materials mentioning features or use of this software
 * must display the following acknowledgement:
 *	This product includes software developed by Harvard University.
 *	This product includes software developed by the University of
 *	California, Lawrence Berkeley Laboratory.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 *	This product includes software developed by Paul Kranenburg.
 *	This product includes software developed by Harvard University.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)clock.c	8.1 (Berkeley) 6/11/93
 *
 */

/*
 * Clock driver.  This is the id prom and eeprom driver as well
 * and includes the timer register functions too.
 */

/* Define this for a 1/4s clock to ease debugging */
/* #define INTR_DEBUG */

#include <sys/param.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/proc.h>
#include <sys/resourcevar.h>
#include <sys/malloc.h>
#include <sys/systm.h>
#ifdef GPROF
#include <sys/gmon.h>
#endif
#include <sys/sched.h>
#include <sys/timetc.h>
#include <sys/atomic.h>

#include <machine/bus.h>
#include <machine/autoconf.h>
#include <machine/cpu.h>
#include <machine/idprom.h>

#include <dev/clock_subr.h>
#include <dev/ic/mk48txxreg.h>

#include <sparc64/sparc64/intreg.h>
#include <sparc64/sparc64/timerreg.h>
#include <sparc64/dev/iommureg.h>
#include <sparc64/dev/sbusreg.h>
#include <dev/sbus/sbusvar.h>
#include <sparc64/dev/ebusreg.h>
#include <sparc64/dev/ebusvar.h>
#include <sparc64/dev/fhcvar.h>

extern u_int64_t cpu_clockrate;

struct clock_wenable_info {
	bus_space_tag_t		cwi_bt;
	bus_space_handle_t	cwi_bh;
	bus_size_t		cwi_size;
};

struct cfdriver clock_cd = {
	NULL, "clock", DV_DULL
};

u_int tick_get_timecount(struct timecounter *);

struct timecounter tick_timecounter = {
	tick_get_timecount, NULL, ~0u, 0, "tick", 0, NULL
};

u_int sys_tick_get_timecount(struct timecounter *);

struct timecounter sys_tick_timecounter = {
	sys_tick_get_timecount, NULL, ~0u, 0, "sys_tick", 1000, NULL
};

/*
 * Statistics clock interval and variance, in usec.  Variance must be a
 * power of two.  Since this gives us an even number, not an odd number,
 * we discard one case and compensate.  That is, a variance of 1024 would
 * give us offsets in [0..1023].  Instead, we take offsets in [1..1023].
 * This is symmetric about the point 512, or statvar/2, and thus averages
 * to that value (assuming uniform random numbers).
 */
/* XXX fix comment to match value */
int statvar = 8192;
int statmin;			/* statclock interval - 1/2*variance */

static long tick_increment;

void	tick_start(void);
void	sys_tick_start(void);
void	stick_start(void);

int	tickintr(void *);
int	sys_tickintr(void *);
int	stickintr(void *);
int	schedintr(void *);

static struct intrhand level10 = { clockintr };
static struct intrhand level0 = { tickintr };
static struct intrhand level14 = { statintr };
static struct intrhand schedint = { schedintr };

/*
 * clock (eeprom) attaches at the sbus or the ebus (PCI)
 */
static int	clockmatch_sbus(struct device *, void *, void *);
static void	clockattach_sbus(struct device *, struct device *, void *);
static int	clockmatch_ebus(struct device *, void *, void *);
static void	clockattach_ebus(struct device *, struct device *, void *);
static int	clockmatch_fhc(struct device *, void *, void *);
static void	clockattach_fhc(struct device *, struct device *, void *);
static void	clockattach(int, bus_space_tag_t, bus_space_handle_t);

struct cfattach clock_sbus_ca = {
	sizeof(struct device), clockmatch_sbus, clockattach_sbus
};

struct cfattach clock_ebus_ca = {
	sizeof(struct device), clockmatch_ebus, clockattach_ebus
};

struct cfattach clock_fhc_ca = {
	sizeof(struct device), clockmatch_fhc, clockattach_fhc
};

/* Global TOD clock handle & idprom pointer */
todr_chip_handle_t todr_handle = NULL;
static struct idprom *idprom;

static int	timermatch(struct device *, void *, void *);
static void	timerattach(struct device *, struct device *, void *);

struct timerreg_4u	timerreg_4u;	/* XXX - need more cleanup */

struct cfattach timer_ca = {
	sizeof(struct device), timermatch, timerattach
};

struct cfdriver timer_cd = {
	NULL, "timer", DV_DULL
};

int clock_bus_wenable(struct todr_chip_handle *, int);
struct chiptime;
void myetheraddr(u_char *);
struct idprom *getidprom(void);
int chiptotime(int, int, int, int, int, int);
void timetochip(struct chiptime *);
void stopcounter(struct timer_4u *);

int timerblurb = 10; /* Guess a value; used before clock is attached */

/*
 * The OPENPROM calls the clock the "eeprom", so we have to have our
 * own special match function to call it the "clock".
 */
static int
clockmatch_sbus(parent, cf, aux)
	struct device *parent;
	void *cf;
	void *aux;
{
	struct sbus_attach_args *sa = aux;

	return (strcmp("eeprom", sa->sa_name) == 0);
}

static int
clockmatch_ebus(parent, cf, aux)
	struct device *parent;
	void *cf;
	void *aux;
{
	struct ebus_attach_args *ea = aux;

	return (strcmp("eeprom", ea->ea_name) == 0);
}

static int
clockmatch_fhc(parent, cf, aux)
	struct device *parent;
	void *cf;
	void *aux;
{
	struct fhc_attach_args *fa = aux;
        
	return (strcmp("eeprom", fa->fa_name) == 0);
}

/*
 * Attach a clock (really `eeprom') to the sbus or ebus.
 *
 * We ignore any existing virtual address as we need to map
 * this read-only and make it read-write only temporarily,
 * whenever we read or write the clock chip.  The clock also
 * contains the ID ``PROM'', and I have already had the pleasure
 * of reloading the cpu type, Ethernet address, etc, by hand from
 * the console FORTH interpreter.  I intend not to enjoy it again.
 *
 * the MK48T02 is 2K.  the MK48T08 is 8K, and the MK48T59 is
 * supposed to be identical to it.
 *
 * This is *UGLY*!  We probably have multiple mappings.  But I do
 * know that this all fits inside an 8K page, so I'll just map in
 * once.
 *
 * What we really need is some way to record the bus attach args
 * so we can call *_bus_map() later with BUS_SPACE_MAP_READONLY
 * or not to write enable/disable the device registers.  This is
 * a non-trivial operation.  
 */

/* ARGSUSED */
static void
clockattach_sbus(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct sbus_attach_args *sa = aux;
	bus_space_tag_t bt = sa->sa_bustag;
	int sz;
	static struct clock_wenable_info cwi;

	/* use sa->sa_regs[0].size? */
	sz = 8192;

	if (sbus_bus_map(bt,
			 sa->sa_slot,
			 (sa->sa_offset & ~NBPG),
			 sz,
			 BUS_SPACE_MAP_LINEAR | BUS_SPACE_MAP_READONLY,
			 0, &cwi.cwi_bh) != 0) {
		printf("%s: can't map register\n", self->dv_xname);
		return;
	}
	clockattach(sa->sa_node, bt, cwi.cwi_bh);

	/* Save info for the clock wenable call. */
	cwi.cwi_bt = bt;
	cwi.cwi_size = sz;
	todr_handle->bus_cookie = &cwi;
	todr_handle->todr_setwen = clock_bus_wenable;
}

/*
 * Write en/dis-able clock registers.  We coordinate so that several
 * writers can run simultaneously.
 * XXX There is still a race here.  The page change and the "writers"
 * change are not atomic.
 */
int
clock_bus_wenable(handle, onoff)
	struct todr_chip_handle *handle;
	int onoff;
{
	int s, err = 0;
	int prot; /* nonzero => change prot */
	volatile static int writers;
	struct clock_wenable_info *cwi = handle->bus_cookie;

	s = splhigh();
	if (onoff)
		prot = writers++ == 0 ? 1 : 0;
	else
		prot = --writers == 0 ? 1 : 0;
	splx(s);

	if (prot) {
		err = bus_space_protect(cwi->cwi_bt, cwi->cwi_bh, cwi->cwi_size,
		    onoff ? 0 : BUS_SPACE_MAP_READONLY);
		if (err)
			printf("clock_wenable_info: WARNING -- cannot %s "
			    "page protection\n", onoff ? "disable" : "enable");
	}
	return (err);
}

/* ARGSUSED */
static void
clockattach_ebus(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct ebus_attach_args *ea = aux;
	bus_space_tag_t bt;
	int sz;
	static struct clock_wenable_info cwi;

	/* hard code to 8K? */
	sz = ea->ea_regs[0].size;

	if (ea->ea_nvaddrs) {
		if (bus_space_map(ea->ea_memtag, ea->ea_vaddrs[0], 0,
		    BUS_SPACE_MAP_PROMADDRESS, &cwi.cwi_bh) != 0) {
			printf("%s: can't map register\n", self->dv_xname);
			return;
		}
		bt = ea->ea_memtag;
	} else if (ebus_bus_map(ea->ea_iotag, 0,
	    EBUS_PADDR_FROM_REG(&ea->ea_regs[0]), sz, 0, 0, &cwi.cwi_bh) == 0) {
		bt = ea->ea_iotag;
	} else if (ebus_bus_map(ea->ea_memtag, 0,
	    EBUS_PADDR_FROM_REG(&ea->ea_regs[0]), sz,
	    BUS_SPACE_MAP_LINEAR | BUS_SPACE_MAP_READONLY,
	    0, &cwi.cwi_bh) == 0) {
		bt = ea->ea_memtag;
	} else {
		printf("%s: can't map register\n", self->dv_xname);
		return;
	}

	clockattach(ea->ea_node, bt, cwi.cwi_bh);

	/* Save info for the clock wenable call. */
	cwi.cwi_bt = bt;
	cwi.cwi_size = sz;
	todr_handle->bus_cookie = &cwi;
	todr_handle->todr_setwen = (ea->ea_memtag == bt) ? 
	    clock_bus_wenable : NULL;
}

static void
clockattach_fhc(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct fhc_attach_args *fa = aux;
	bus_space_tag_t bt = fa->fa_bustag;
	int sz;
	static struct clock_wenable_info cwi;

	/* use sa->sa_regs[0].size? */
	sz = 8192;

	if (fhc_bus_map(bt, fa->fa_reg[0].fbr_slot,
	    (fa->fa_reg[0].fbr_offset & ~NBPG), fa->fa_reg[0].fbr_size,
	    BUS_SPACE_MAP_LINEAR | BUS_SPACE_MAP_READONLY, &cwi.cwi_bh) != 0) {
		printf("%s: can't map register\n", self->dv_xname);
		return;
	}

	clockattach(fa->fa_node, bt, cwi.cwi_bh);

	/* Save info for the clock wenable call. */
	cwi.cwi_bt = bt;
	cwi.cwi_size = sz;
	todr_handle->bus_cookie = &cwi;
	todr_handle->todr_setwen = clock_bus_wenable;
}

static void
clockattach(node, bt, bh)
	int node;
	bus_space_tag_t bt;
	bus_space_handle_t bh;
{
	char *model;
	struct idprom *idp;
	int h;

	model = getpropstring(node, "model");

#ifdef DIAGNOSTIC
	if (model == NULL)
		panic("clockattach: no model property");
#endif

	/* Our TOD clock year 0 is 1968 */
	if ((todr_handle = mk48txx_attach(bt, bh, model, 1968)) == NULL)
		panic("Can't attach %s tod clock", model);

#define IDPROM_OFFSET (8*1024 - 40)	/* XXX - get nvram sz from driver */
	if (idprom == NULL) {
		idp = getidprom();
		if (idp == NULL)
			idp = (struct idprom *)(bus_space_vaddr(bt, bh) +
			    IDPROM_OFFSET);
		idprom = idp;
	} else
		idp = idprom;
	h = idp->id_machine << 24;
	h |= idp->id_hostid[0] << 16;
	h |= idp->id_hostid[1] << 8;
	h |= idp->id_hostid[2];
	hostid = h;
	printf("\n");
}

struct idprom *
getidprom(void)
{
	struct idprom *idp = NULL;
	int node, n;

	node = findroot();
	if (getprop(node, "idprom", sizeof(*idp), &n, (void **)&idp) != 0)
		return (NULL);
	if (n != 1) {
		free(idp, M_DEVBUF, 0);
		return (NULL);
	}
	return (idp);
}

/*
 * The sun4u OPENPROMs call the timer the "counter-timer", except for
 * the lame UltraSPARC IIi PCI machines that don't have them.
 */
static int
timermatch(parent, cf, aux)
	struct device *parent;
	void *cf;
	void *aux;
{
#ifndef MULTIPROCESSOR
	struct mainbus_attach_args *ma = aux;

	if (!timerreg_4u.t_timer || !timerreg_4u.t_clrintr)
		return (strcmp("counter-timer", ma->ma_name) == 0);
	else
#endif
		return (0);
}

static void
timerattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct mainbus_attach_args *ma = aux;
	u_int *va = ma->ma_address;
	
	/*
	 * What we should have are 3 sets of registers that reside on
	 * different parts of SYSIO or PSYCHO.  We'll use the prom
	 * mappings cause we can't get rid of them and set up appropriate
	 * pointers on the timerreg_4u structure.
	 */
	timerreg_4u.t_timer = (struct timer_4u *)(u_long)va[0];
	timerreg_4u.t_clrintr = (int64_t *)(u_long)va[1];
	timerreg_4u.t_mapintr = (int64_t *)(u_long)va[2];

	/* Install the appropriate interrupt vector here */
	level10.ih_number = INTVEC(ma->ma_interrupts[0]);
	level10.ih_clr = (void *)&timerreg_4u.t_clrintr[0];
	level10.ih_map = (void *)&timerreg_4u.t_mapintr[0];
	strlcpy(level10.ih_name, "clock", sizeof(level10.ih_name));
	intr_establish(10, &level10);

	level14.ih_number = INTVEC(ma->ma_interrupts[1]);
	level14.ih_clr = (void *)&timerreg_4u.t_clrintr[1];
	level14.ih_map = (void *)&timerreg_4u.t_mapintr[1];
	strlcpy(level14.ih_name, "prof", sizeof(level14.ih_name));
	intr_establish(14, &level14);

	printf(" ivec 0x%llx, 0x%llx\n", INTVEC(level10.ih_number),
	    INTVEC(level14.ih_number));
}

void
stopcounter(creg)
	struct timer_4u *creg;
{
	/* Stop the clock */
	volatile int discard;
	discard = creg->t_limit;
	creg->t_limit = 0;
}

/*
 * XXX this belongs elsewhere
 */
void
myetheraddr(cp)
	u_char *cp;
{
	struct idprom *idp;

	if ((idp = idprom) == NULL) {
		int node, n;

		node = findroot();
		if (getprop(node, "idprom", sizeof *idp, &n, (void **)&idp) ||
		    n != 1) {
			printf("\nmyetheraddr: clock not setup yet, "
			       "and no idprom property in /\n");
			return;
		}
	}

	cp[0] = idp->id_ether[0];
	cp[1] = idp->id_ether[1];
	cp[2] = idp->id_ether[2];
	cp[3] = idp->id_ether[3];
	cp[4] = idp->id_ether[4];
	cp[5] = idp->id_ether[5];
	if (idprom == NULL)
		free(idp, M_DEVBUF, 0);
}

/*
 * Set up the real-time and statistics clocks.  Leave stathz 0 only if
 * no alternative timer is available.
 *
 * The frequencies of these clocks must be an even number of microseconds.
 */
void
cpu_initclocks(void)
{
	int statint, minint;
#ifdef DEBUG
	extern int intrdebug;
#endif
	u_int sys_tick_rate;
	int impl = 0;

#ifdef DEBUG
	/* Set a 1s clock */
	if (intrdebug) {
		hz = 1;
		tick = 1000000 / hz;
		printf("intrdebug set: 1Hz clock\n");
	}
#endif

	if (1000000 % hz) {
		printf("cannot get %d Hz clock; using 100 Hz\n", hz);
		hz = 100;
		tick = 1000000 / hz;
	}

	/* Make sure we have a sane cpu_clockrate -- we'll need it */
	if (!cpu_clockrate) 
		/* Default to 200MHz clock XXXXX */
		cpu_clockrate = 200000000;

	tick_timecounter.tc_frequency = cpu_clockrate;
	tc_init(&tick_timecounter);

	/*
	 * UltraSPARC IIe processors do have a STICK register, but it
	 * lives on the PCI host bridge and isn't accessable through
	 * ASR24.
	 */
	if (CPU_ISSUN4U || CPU_ISSUN4US)
		impl = (getver() & VER_IMPL) >> VER_IMPL_SHIFT;

	sys_tick_rate = getpropint(findroot(), "stick-frequency", 0);
	if (sys_tick_rate > 0 && impl != IMPL_HUMMINGBIRD) {
		sys_tick_timecounter.tc_frequency = sys_tick_rate;
		tc_init(&sys_tick_timecounter);
	}

	/*
	 * Now handle machines w/o counter-timers.
	 */

	if (!timerreg_4u.t_timer || !timerreg_4u.t_clrintr) {
		struct cpu_info *ci;

		/* We don't have a counter-timer -- use %tick */
		level0.ih_clr = 0;

		/* 
		 * Establish a level 10 interrupt handler 
		 *
		 * We will have a conflict with the softint handler,
		 * so we set the ih_number to 1.
		 */
		level0.ih_number = 1;
		strlcpy(level0.ih_name, "clock", sizeof(level0.ih_name));
		intr_establish(10, &level0);

		/* We only have one timer so we have no statclock */
		stathz = 0;	

		if (sys_tick_rate > 0) {
			tick_increment = sys_tick_rate / hz;
			if (impl == IMPL_HUMMINGBIRD) {
				level0.ih_fun = stickintr;
				cpu_start_clock = stick_start;
			} else {
				level0.ih_fun = sys_tickintr;
				cpu_start_clock = sys_tick_start;
			}
		} else {
			/* set the next interrupt time */
			tick_increment = cpu_clockrate / hz;
			level0.ih_fun = tickintr;
			cpu_start_clock = tick_start;
		}

		for (ci = cpus; ci != NULL; ci = ci->ci_next)
			memcpy(&ci->ci_tickintr, &level0, sizeof(level0));

		cpu_start_clock();

		return;
	}

	if (stathz == 0)
		stathz = hz;
	if (1000000 % stathz) {
		printf("cannot get %d Hz statclock; using 100 Hz\n", stathz);
		stathz = 100;
	}

	profhz = stathz;		/* always */

	statint = 1000000 / stathz;
	minint = statint / 2 + 100;
	while (statvar > minint)
		statvar >>= 1;

	/* 
	 * Establish scheduler softint.
	 */
	schedint.ih_pil = PIL_SCHED;
	schedint.ih_clr = NULL;
	schedint.ih_arg = 0;
	schedint.ih_pending = 0;
	schedhz = stathz/4;

	/* 
	 * Enable timers 
	 *
	 * Also need to map the interrupts cause we're not a child of the sbus.
	 * N.B. By default timer[0] is disabled and timer[1] is enabled.
	 */
	stxa((vaddr_t)&timerreg_4u.t_timer[0].t_limit, ASI_NUCLEUS,
	     tmr_ustolim(tick)|TMR_LIM_IEN|TMR_LIM_PERIODIC|TMR_LIM_RELOAD); 
	stxa((vaddr_t)&timerreg_4u.t_mapintr[0], ASI_NUCLEUS, 
	     timerreg_4u.t_mapintr[0]|INTMAP_V); 

#ifdef DEBUG
	if (intrdebug)
		/* Neglect to enable timer */
		stxa((vaddr_t)&timerreg_4u.t_timer[1].t_limit, ASI_NUCLEUS, 
		     tmr_ustolim(statint)|TMR_LIM_RELOAD); 
	else
#endif
		stxa((vaddr_t)&timerreg_4u.t_timer[1].t_limit, ASI_NUCLEUS, 
		     tmr_ustolim(statint)|TMR_LIM_IEN|TMR_LIM_RELOAD); 
	stxa((vaddr_t)&timerreg_4u.t_mapintr[1], ASI_NUCLEUS, 
	     timerreg_4u.t_mapintr[1]|INTMAP_V); 

	statmin = statint - (statvar >> 1);
	
}

/*
 * Dummy setstatclockrate(), since we know profhz==hz.
 */
/* ARGSUSED */
void
setstatclockrate(newhz)
	int newhz;
{
	/* nothing */
}

/*
 * Level 10 (clock) interrupts.  If we are using the FORTH PROM for
 * console input, we need to check for that here as well, and generate
 * a software interrupt to read it.
 */
#ifdef	DEBUG
static int clockcheck = 0;
#endif
int
clockintr(cap)
	void *cap;
{
#ifdef DEBUG
	static int64_t tick_base = 0;
	struct timeval ctime;
	int64_t t;

	t = tick() & TICK_TICKS;

	microtime(&ctime);
	if (!tick_base) {
		tick_base = (ctime.tv_sec * 1000000LL + ctime.tv_usec) 
			* 1000000LL / cpu_clockrate;
		tick_base -= t;
	} else if (clockcheck) {
		int64_t tk = t;
		int64_t clk = (ctime.tv_sec * 1000000LL + ctime.tv_usec);
		t -= tick_base;
		t = t * 1000000LL / cpu_clockrate;
		if (t - clk > hz) {
			printf("Clock lost an interrupt!\n");
			printf("Actual: %llx Expected: %llx tick %llx "
			    "tick_base %llx\n", (long long)t, (long long)clk,
			    (long long)tk, (long long)tick_base);
#ifdef DDB
			Debugger();
#endif
			tick_base = 0;
		}
	}	
#endif
	/* Let locore.s clear the interrupt for us. */
	hardclock((struct clockframe *)cap);

	return (1);
}

/*
 * Level 10 (clock) interrupts.  If we are using the FORTH PROM for
 * console input, we need to check for that here as well, and generate
 * a software interrupt to read it.
 *
 * %tick is really a level-14 interrupt.  We need to remap this in 
 * locore.s to a level 10.
 */
int
tickintr(cap)
	void *cap;
{
	struct cpu_info *ci = curcpu();
	u_int64_t s;

	/*
	 * No need to worry about overflow; %tick is architecturally
	 * defined not to do that for at least 10 years.
	 */
	while (ci->ci_tick < tick()) {
		ci->ci_tick += tick_increment;
		hardclock((struct clockframe *)cap);
		atomic_add_long((unsigned long *)&level0.ih_count.ec_count, 1);
	}

	/* Reset the interrupt. */
	s = intr_disable();
	tickcmpr_set(ci->ci_tick);
	intr_restore(s);

	return (1);
}

int
sys_tickintr(cap)
	void *cap;
{
	struct cpu_info *ci = curcpu();
	u_int64_t s;

	/*
	 * Do we need to worry about overflow here?
	 */
	while (ci->ci_tick < sys_tick()) {
		ci->ci_tick += tick_increment;
		hardclock((struct clockframe *)cap);
		atomic_add_long((unsigned long *)&level0.ih_count.ec_count, 1);
	}

	/* Reset the interrupt. */
	s = intr_disable();
	sys_tickcmpr_set(ci->ci_tick);
	intr_restore(s);

	return (1);
}

int
stickintr(cap)
	void *cap;
{
	struct cpu_info *ci = curcpu();
	u_int64_t s;

	/*
	 * Do we need to worry about overflow here?
	 */
	while (ci->ci_tick < stick()) {
		ci->ci_tick += tick_increment;
		hardclock((struct clockframe *)cap);
		atomic_add_long((unsigned long *)&level0.ih_count.ec_count, 1);
	}

	/* Reset the interrupt. */
	s = intr_disable();
	stickcmpr_set(ci->ci_tick);
	intr_restore(s);

	return (1);
}

/*
 * Level 14 (stat clock) interrupt handler.
 */
int
statintr(cap)
	void *cap;
{
	u_long newint, r, var;
	struct cpu_info *ci = curcpu();

#ifdef NOT_DEBUG
	printf("statclock: count %x:%x, limit %x:%x\n", 
	       timerreg_4u.t_timer[1].t_count, timerreg_4u.t_timer[1].t_limit);
#endif
#ifdef NOT_DEBUG
	prom_printf("!");
#endif
	statclock((struct clockframe *)cap);
#ifdef NOTDEF_DEBUG
	/* Don't re-schedule the IRQ */
	return 1;
#endif
	/*
	 * Compute new randomized interval.  The intervals are uniformly
	 * distributed on [statint - statvar / 2, statint + statvar / 2],
	 * and therefore have mean statint, giving a stathz frequency clock.
	 */
	var = statvar;
	do {
		r = random() & (var - 1);
	} while (r == 0);
	newint = statmin + r;

	if (schedhz)
		if ((++ci->ci_schedstate.spc_schedticks & 3) == 0)
			send_softint(-1, PIL_SCHED, &schedint);
	stxa((vaddr_t)&timerreg_4u.t_timer[1].t_limit, ASI_NUCLEUS, 
	     tmr_ustolim(newint)|TMR_LIM_IEN|TMR_LIM_RELOAD);

	return (1);
}

int
schedintr(arg)
	void *arg;
{
	if (curproc)
		schedclock(curproc);
	return (1);
}


/*
 * `sparc_clock_time_is_ok' is used in cpu_reboot() to determine
 * whether it is appropriate to call resettodr() to consolidate
 * pending time adjustments.
 */
int sparc_clock_time_is_ok;

/*
 * Set up the system's time, given a `reasonable' time value.
 */
void
inittodr(time_t base)
{
	int badbase = 0, waszero = base == 0;
	char *bad = NULL;
	struct timeval tv;
	struct timespec ts;

	tv.tv_sec = tv.tv_usec = 0;

	if (base < 5 * SECYR) {
		/*
		 * If base is 0, assume filesystem time is just unknown
		 * in stead of preposterous. Don't bark.
		 */
		if (base != 0)
			printf("WARNING: preposterous time in file system\n");
		/* not going to use it anyway, if the chip is readable */
		base = 21*SECYR + 186*SECDAY + SECDAY/2;
		badbase = 1;
	}

	if (todr_handle != NULL)
		todr_gettime(todr_handle, &tv);

	if (tv.tv_sec == 0) {
		/*
		 * Believe the time in the file system for lack of
		 * anything better, resetting the clock.
		 */
		bad = "WARNING: bad date in battery clock";
		tv.tv_sec = base;
		tv.tv_usec = 0;
		if (!badbase)
			resettodr();
	} else {
		time_t deltat = tv.tv_sec - base;

		sparc_clock_time_is_ok = 1;

		if (deltat < 0)
			deltat = -deltat;
		if (!(waszero || deltat < 2 * SECDAY)) {
#ifndef SMALL_KERNEL
			printf("WARNING: clock %s %lld days",
			    tv.tv_sec < base ? "lost" : "gained",
			    (long long)(deltat / SECDAY));
			bad = "";
#endif
		}
	}

	ts.tv_sec = tv.tv_sec;
	ts.tv_nsec = tv.tv_usec * 1000;
	tc_setclock(&ts);

	if (bad) {
		printf("%s", bad);
		printf(" -- CHECK AND RESET THE DATE!\n");
	}
}

/*
 * Reset the clock based on the current time.
 * Used when the current clock is preposterous, when the time is changed,
 * and when rebooting.  Do nothing if the time is not yet known, e.g.,
 * when crashing during autoconfig.
 */
void
resettodr(void)
{
	struct timeval tv;

	if (time_second == 1)
		return;

	microtime(&tv);

	sparc_clock_time_is_ok = 1;
	if (todr_handle == 0 || todr_settime(todr_handle, &tv) != 0)
		printf("Cannot set time in time-of-day clock\n");
}

void
tick_start(void)
{
	struct cpu_info *ci = curcpu();
	u_int64_t s;

	/*
	 * Try to make the tick interrupts as synchronously as possible on
	 * all CPUs to avoid inaccuracies for migrating processes.
	 */

	s = intr_disable();
	ci->ci_tick = roundup(tick(), tick_increment);
	tickcmpr_set(ci->ci_tick);
	intr_restore(s);
}

void
sys_tick_start(void)
{
	struct cpu_info *ci = curcpu();
	u_int64_t s;

	/*
	 * Try to make the tick interrupts as synchronously as possible on
	 * all CPUs to avoid inaccuracies for migrating processes.
	 */

	s = intr_disable();
	ci->ci_tick = roundup(sys_tick(), tick_increment);
	sys_tickcmpr_set(ci->ci_tick);
	intr_restore(s);
}

void
stick_start(void)
{
	struct cpu_info *ci = curcpu();
	u_int64_t s;

	/*
	 * Try to make the tick interrupts as synchronously as possible on
	 * all CPUs to avoid inaccuracies for migrating processes.
	 */

	s = intr_disable();
	ci->ci_tick = roundup(stick(), tick_increment);
	stickcmpr_set(ci->ci_tick);
	intr_restore(s);
}

u_int
tick_get_timecount(struct timecounter *tc)
{
	u_int64_t tick;

	__asm volatile("rd %%tick, %0" : "=r" (tick) :);

	return (tick & ~0u);
}

u_int
sys_tick_get_timecount(struct timecounter *tc)
{
	u_int64_t tick;

	__asm volatile("rd %%sys_tick, %0" : "=r" (tick) :);

	return (tick & ~0u);
}
@


1.57
log
@When investigating an uninitialised variable in the armv7 resettodr()
miod pointed out that time_second should be compared to 1 not 0 in the
md resettodr() functions as it is initialised to 1.

ok miod@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.56 2014/12/17 19:39:01 tedu Exp $	*/
d436 1
a436 1
getidprom()
d967 1
a967 1
resettodr()
@


1.56
log
@fix/reduce header dependencies. clock.c doesn't need any of this uvm.
ok deraadt kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.55 2014/11/16 12:30:59 deraadt Exp $	*/
d971 1
a971 1
	if (time_second == 0)
@


1.55
log
@Replace a plethora of historical protection options with just
PROT_NONE, PROT_READ, PROT_WRITE, and PROT_EXEC from mman.h.
PROT_MASK is introduced as the one true way of extracting those bits.
Remove UVM_ADV_* wrapper, using the standard names.
ok doug guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.54 2014/07/12 18:44:43 tedu Exp $	*/
d78 1
a78 2

#include <uvm/uvm_extern.h>
d309 1
a309 2
		prot = writers++ == 0 ?
		    PROT_READ | PROT_WRITE | PMAP_WIRED : 0;
d311 1
a311 2
		prot = --writers == 0 ?
		    PROT_READ | PMAP_WIRED : 0;
@


1.54
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.53 2014/05/10 12:15:19 kettenis Exp $	*/
d311 1
a311 1
		    VM_PROT_READ | VM_PROT_WRITE | PMAP_WIRED : 0;
d314 1
a314 1
		    VM_PROT_READ | PMAP_WIRED : 0;
@


1.53
log
@Format string fixes for printing interrupt vectors.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.52 2014/03/29 18:09:30 guenther Exp $	*/
d448 1
a448 1
		free(idp, M_DEVBUF);
d547 1
a547 1
		free(idp, M_DEVBUF);
@


1.52
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.51 2014/02/08 11:04:50 kettenis Exp $	*/
d505 1
a505 1
	printf(" ivec 0x%x, 0x%x\n", INTVEC(level10.ih_number),
@


1.51
log
@Initializing the time from an uninitialized variable isn't a very good idea.
While there, afnsify the inittodr() prototype.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.50 2014/01/30 00:51:13 dlg Exp $	*/
d1040 1
a1040 1
	__asm __volatile("rd %%tick, %0" : "=r" (tick) :);
d1050 1
a1050 1
	__asm __volatile("rd %%sys_tick, %0" : "=r" (tick) :);
@


1.50
log
@move sparc64 behind the MI atomic api.

this basically replaces sparc64_cas and sparc64_casx with atomic_cas_uint
and atomic_cas_ulong respectively. it then builds atomic_add and
atomic_sub out of those. this avoids the gcc atomic builtins that
the MI atomic_foo api uses by default, so we dont get the extra
membars that the builtins do but the atomic_foo api doesnt promise.

it also fixes up the code that used to use sparc64_{cas,casx} to
use the atomic_cas api instead.

use of the sparc64 membar() macros are left untouched for now.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.49 2013/07/05 20:30:56 guenther Exp $	*/
d902 1
a902 2
inittodr(base)
	time_t base;
d909 2
d923 4
a926 2
	if (todr_handle && (todr_gettime(todr_handle, &tv) != 0 ||
	    tv.tv_sec == 0)) {
@


1.49
log
@Avoid truncation when calculating clock gain/loss

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.48 2010/07/07 15:37:22 kettenis Exp $	*/
d780 1
a780 1
		atomic_add_ulong((unsigned long *)&level0.ih_count.ec_count, 1);
d804 1
a804 1
		atomic_add_ulong((unsigned long *)&level0.ih_count.ec_count, 1);
d828 1
a828 1
		atomic_add_ulong((unsigned long *)&level0.ih_count.ec_count, 1);
@


1.48
log
@Use atomic operations to increment clock interrupt counter.

ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.47 2008/08/10 14:13:05 kettenis Exp $	*/
d934 1
a934 1
		int deltat = tv.tv_sec - base;
d942 3
a944 2
			printf("WARNING: clock %s %ld days",
			    tv.tv_sec < base ? "lost" : "gained", deltat / SECDAY);
@


1.47
log
@Use the STICK logic on UltraSPARC-IIe to generate clock interrupts.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.46 2008/08/07 21:25:47 kettenis Exp $	*/
d780 1
a780 1
		level0.ih_count.ec_count++;
d804 1
a804 1
		level0.ih_count.ec_count++;
d828 1
a828 1
		level0.ih_count.ec_count++;
@


1.46
log
@Use %sys_tick to generate clock interrupts on systems that have it.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.45 2008/08/07 18:46:04 kettenis Exp $	*/
d135 9
a143 1
int schedintr(void *);
d626 1
a626 1
		if (sys_tick_rate > 0 && impl != IMPL_HUMMINGBIRD) {
d628 7
a634 2
			level0.ih_fun = sys_tickintr;
			cpu_start_clock = sys_tick_start;
d815 24
d1011 17
@


1.45
log
@Give each CPU its own `struct intrhand' for %tick interrupts.  Fixes a
problem where the clock would stop ticking on some CPUs because of lost
ticks.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.44 2008/07/15 22:49:01 kettenis Exp $	*/
d615 14
d632 1
a632 2
		/* We only have one timer so we have no statclock */
		stathz = 0;	
a633 10
		/* set the next interrupt time */
		tick_increment = cpu_clockrate / hz;
#ifdef DEBUG
		printf("Using %%tick -- intr in %ld cycles...",
		    tick_increment);
#endif
		tick_start();
#ifdef DEBUG
		printf("done.\n");
#endif
d778 24
d957 17
@


1.44
log
@Add a timecounter based on the $sys_tick register, and use it on machines
that have it.  Initial diff from art@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.43 2008/06/11 04:44:19 kettenis Exp $	*/
d600 2
d604 1
d614 4
@


1.43
log
@Use the prom address to map clock(4) at ebus(4) if available.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.42 2008/05/22 21:39:04 kettenis Exp $	*/
d116 6
d549 1
a549 1
cpu_initclocks()
d555 2
d580 15
a594 1
	
d932 10
@


1.42
log
@Restrict interrupt vectors to 11 bits.  Needed to make sun4us work.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.41 2008/04/17 19:52:27 kettenis Exp $	*/
d327 8
a334 1
	if (ebus_bus_map(ea->ea_iotag, 0,
@


1.41
log
@Really try to schedule clock ticks at fixed intervals.  Make sure hardclock()
gets called for every clock tick, even if we miss one.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.40 2008/04/15 22:39:26 kettenis Exp $	*/
d472 1
a472 1
	level10.ih_number = ma->ma_interrupts[0];
d478 1
a478 1
	level14.ih_number = ma->ma_interrupts[1];
@


1.40
log
@Add workaround for UltraSPARC-II errata, where writes to %tick_cmpr would
sometimes fail, which would result in the periodic clock interrupts on a CPU
stop.

Spotted in a NetBSD commit message, loosely based on code in OpenSolaris.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.39 2008/03/29 20:07:36 kettenis Exp $	*/
d718 2
a719 1
	u_int64_t base, s;
d721 9
a729 1
	hardclock((struct clockframe *)cap);
d731 1
a731 6
	/* 
	 * Reset the interrupt.  We need to disable interrupts to
	 * block out IPIs, otherwise a value that is in the past could
	 * be written to the TICK_CMPR register, causing hardclock to
	 * stop.
	 */
d733 1
a733 3
	base = sparc_rdpr(tick);
	tickcmpr_set((base + tick_increment) & TICK_TICKS);
	level0.ih_count.ec_count++;
d883 2
a884 1
	u_int64_t base, s;
d888 1
a888 2
	 * all CPUs to avoid inaccuracies for migrating processes.  Leave out
	 * one tick to make sure that it is not missed.
d892 2
a893 3
	base = sparc_rdpr(tick) & TICK_TICKS;
	base = roundup(base, tick_increment);
	sparc_wr(tick_cmpr, (base + tick_increment) & TICK_TICKS, 0);
@


1.39
log
@Don't double count clock and prof interrupts.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.38 2007/11/14 20:43:12 kettenis Exp $	*/
d730 1
a730 1
	sparc_wr(tick_cmpr, (base + tick_increment) & TICK_TICKS, 0);
@


1.38
log
@Remove eeprom.h.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.37 2007/11/11 19:47:34 kettenis Exp $	*/
a702 2
	level10.ih_count.ec_count++;

a774 2

	level14.ih_count.ec_count++;
@


1.37
log
@Replace next_tick() with simpler C code that I can actually understand.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.36 2007/10/21 21:00:38 kettenis Exp $	*/
a82 1
#include <machine/eeprom.h>
a879 12
}

/*
 * XXX: these may actually belong somewhere else, but since the
 * EEPROM is so closely tied to the clock on some models, perhaps
 * it needs to stay here...
 */
int
eeprom_uio(uio)
	struct uio *uio;
{
	return (ENODEV);
@


1.36
log
@Don't use next_tick() to start the clock ticking on secondary CPUs.  This
would fail from time to time on UltraSPARC-I and UltraSPARC-II CPUs.
Inspired by code in FreeBSD.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.35 2007/10/19 15:29:22 kettenis Exp $	*/
d592 1
a592 1
		next_tick(tick_increment);
d721 1
a721 1
	int s;
d725 9
a733 3
	s = splhigh();
	/* Reset the interrupt */
	next_tick(tick_increment);
d735 1
a735 1
	splx(s);
d909 1
a909 1
	sparc_wr(tick_cmpr, base + tick_increment, 0);
@


1.35
log
@Don't use "counter-timer" as clock interrupt source on MULTIPROCESSOR kernels
for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.34 2007/10/17 21:23:28 kettenis Exp $	*/
d129 1
a129 1
long tick_increment;
d887 18
@


1.34
log
@Spin up secondary CPUs on MULTIPROCESSOR kernels.  Works on UltraSPARC-III
CPUs.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.33 2007/05/06 14:52:36 kettenis Exp $	*/
d444 1
d450 1
@


1.33
log
@Whack "No counter-timer" message.  These days, most UltraSPARC cpu's don't
have one.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.32 2007/04/09 19:59:06 kettenis Exp $	*/
d129 1
a129 1
static long tick_increment;
@


1.32
log
@Seperate rtc(4) code out into its own file.  Add support for catching the
power button interrupts on ds1287 models.  The hardware will stil power off
automatically about 20 seconds after the power button is pressed, but we get
a decent chance at doing a clean shutdown before that.

"a good start" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.31 2007/04/07 19:24:58 kettenis Exp $	*/
a569 2
		printf("No counter-timer -- using %%tick at %ldMHz as "
		    "system clock.\n", (long)(cpu_clockrate/1000000));
@


1.31
log
@USECPERSEC is no longer used.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.30 2007/04/01 12:22:24 kettenis Exp $	*/
a88 1
#include <dev/ic/mc146818reg.h>
a100 5
struct rtc_info {
	bus_space_tag_t	rtc_bt;		/* bus tag & handle */
	bus_space_handle_t rtc_bh;	/* */
};

a145 2
static int	clockmatch_rtc(struct device *, void *, void *);
static void	clockattach_rtc(struct device *, struct device *, void *);
a159 8
struct cfattach rtc_ebus_ca = {
	sizeof(struct device), clockmatch_rtc, clockattach_rtc
};

struct cfdriver rtc_cd = {
	NULL, "rtc", DV_DULL
};

d161 1
a161 1
static todr_chip_handle_t todr_handle = NULL;
a186 9
u_int8_t rtc_read_reg(bus_space_tag_t, bus_space_handle_t, int);
void rtc_write_reg(bus_space_tag_t, bus_space_handle_t, int, u_int8_t);
int rtc_gettime(todr_chip_handle_t, struct timeval *);
int rtc_settime(todr_chip_handle_t, struct timeval *);
int rtc_getcal(todr_chip_handle_t, int *);
int rtc_setcal(todr_chip_handle_t, int);

int rtc_auto_century_adjust = 1;

a223 11
static int
clockmatch_rtc(parent, cf, aux)
	struct device *parent;
	void *cf;
	void *aux;
{
	struct ebus_attach_args *ea = aux;

	return (strcmp("rtc", ea->ea_name) == 0);
}

a434 100
 * `rtc' is a ds1287 on an ebus (actually an isa bus, but we use the
 * ebus driver for isa.)  So we can use ebus_wenable() but need to do
 * different attach work and use different todr routines.  It does not
 * incorporate an IDPROM.
 */

/*
 * XXX the stupid ds1287 is not mapped directly but uses an address
 * and a data reg so we cannot access the stuuupid thing w/o having
 * write access to the registers.
 *
 * XXXX We really need to mutex register access!
 */
#define	RTC_ADDR	0
#define	RTC_DATA	1
u_int8_t 
rtc_read_reg(bus_space_tag_t bt, bus_space_handle_t bh, int reg)
{
	bus_space_write_1(bt, bh, RTC_ADDR, reg);
	return (bus_space_read_1(bt, bh, RTC_DATA));
}
void 
rtc_write_reg(bus_space_tag_t bt, bus_space_handle_t bh, int reg, u_int8_t val)
{
	bus_space_write_1(bt, bh, RTC_ADDR, reg);
	bus_space_write_1(bt, bh, RTC_DATA, val);
}

/* ARGSUSED */
static void
clockattach_rtc(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct ebus_attach_args *ea = aux;
	bus_space_tag_t bt;
	todr_chip_handle_t handle;
	struct rtc_info *rtc;
	char *model;
	int sz;
	static struct clock_wenable_info cwi;

	/* hard code to 8K? */
	sz = ea->ea_regs[0].size;

	if (ebus_bus_map(ea->ea_iotag, 0,
	    EBUS_PADDR_FROM_REG(&ea->ea_regs[0]), sz, 0, 0, &cwi.cwi_bh) == 0) {
		bt = ea->ea_iotag;
	} else if (ebus_bus_map(ea->ea_memtag, 0,
	    EBUS_PADDR_FROM_REG(&ea->ea_regs[0]), sz,
	    BUS_SPACE_MAP_LINEAR | BUS_SPACE_MAP_READONLY,
	    0, &cwi.cwi_bh) == 0) {
		bt = ea->ea_memtag;
	} else {
		printf("%s: can't map register\n", self->dv_xname);
		return;
	}

	model = getpropstring(ea->ea_node, "model");
#ifdef DIAGNOSTIC
	if (model == NULL)
		panic("clockattach_rtc: no model property");
#endif
	printf(": %s\n", model);

	/* Setup our todr_handle */
	sz = ALIGN(sizeof(struct todr_chip_handle)) + sizeof(struct rtc_info);
	handle = malloc(sz, M_DEVBUF, M_NOWAIT);
	if (handle == NULL)
		panic("clockattach_rtc");
	rtc = (struct rtc_info*)((u_long)handle +
				 ALIGN(sizeof(struct todr_chip_handle)));
	handle->cookie = rtc;
	handle->todr_gettime = rtc_gettime;
	handle->todr_settime = rtc_settime;
	handle->todr_getcal = rtc_getcal;
	handle->todr_setcal = rtc_setcal;
	rtc->rtc_bt = bt;
	rtc->rtc_bh = cwi.cwi_bh;

	/* Save info for the clock wenable call. */
	cwi.cwi_bt = bt;
	cwi.cwi_size = sz;
	handle->bus_cookie = &cwi;
	handle->todr_setwen = (ea->ea_memtag == bt) ?
	    clock_bus_wenable : NULL;
	todr_handle = handle;

	/* 
	 * Turn interrupts off, just in case. (Although they shouldn't
	 * be wired to an interrupt controller on sparcs).
	 */
	todr_wenable(handle, 1);
	rtc_write_reg(bt, cwi.cwi_bh, 
		MC_REGB, MC_REGB_BINARY | MC_REGB_24HR);
	todr_wenable(handle, 0);

}

/*
a886 117
}


/*
 * RTC todr routines.
 */

/*
 * Get time-of-day and convert to a `struct timeval'
 * Return 0 on success; an error number otherwise.
 */
int
rtc_gettime(handle, tv)
	todr_chip_handle_t handle;
	struct timeval *tv;
{
	struct rtc_info *rtc = handle->cookie;
	bus_space_tag_t bt = rtc->rtc_bt;
	bus_space_handle_t bh = rtc->rtc_bh;
	struct clock_ymdhms dt;
	int year;
	u_int8_t csr;

	todr_wenable(handle, 1);

	/* Stop updates. */
	csr = rtc_read_reg(bt, bh, MC_REGB);
	csr |= MC_REGB_SET;
	rtc_write_reg(bt, bh, MC_REGB, csr);

	/* Read time */
	dt.dt_sec = rtc_read_reg(bt, bh, MC_SEC);
	dt.dt_min = rtc_read_reg(bt, bh, MC_MIN);
	dt.dt_hour = rtc_read_reg(bt, bh, MC_HOUR);
	dt.dt_day = rtc_read_reg(bt, bh, MC_DOM);
	dt.dt_wday = rtc_read_reg(bt, bh, MC_DOW);
	dt.dt_mon = rtc_read_reg(bt, bh, MC_MONTH);
	year = rtc_read_reg(bt, bh, MC_YEAR);

	if ((year += 1900) < POSIX_BASE_YEAR)
		year += 100;

	dt.dt_year = year;

	/* time wears on */
	csr = rtc_read_reg(bt, bh, MC_REGB);
	csr &= ~MC_REGB_SET;
	rtc_write_reg(bt, bh, MC_REGB, csr);
	todr_wenable(handle, 0);

	/* simple sanity checks */
	if (dt.dt_mon > 12 || dt.dt_day > 31 ||
	    dt.dt_hour >= 24 || dt.dt_min >= 60 || dt.dt_sec >= 60)
		return (1);

	tv->tv_sec = clock_ymdhms_to_secs(&dt);
	tv->tv_usec = 0;
	return (0);
}

/*
 * Set the time-of-day clock based on the value of the `struct timeval' arg.
 * Return 0 on success; an error number otherwise.
 */
int
rtc_settime(handle, tv)
	todr_chip_handle_t handle;
	struct timeval *tv;
{
	struct rtc_info *rtc = handle->cookie;
	bus_space_tag_t bt = rtc->rtc_bt;
	bus_space_handle_t bh = rtc->rtc_bh;
	struct clock_ymdhms dt;
	u_int8_t csr;
	int year;

	/* Note: we ignore `tv_usec' */
	clock_secs_to_ymdhms(tv->tv_sec, &dt);

	year = dt.dt_year % 100;

	todr_wenable(handle, 1);
	/* enable write */
	csr = rtc_read_reg(bt, bh, MC_REGB);
	csr |= MC_REGB_SET;
	rtc_write_reg(bt, bh, MC_REGB, csr);

	rtc_write_reg(bt, bh, MC_SEC, dt.dt_sec);
	rtc_write_reg(bt, bh, MC_MIN, dt.dt_min);
	rtc_write_reg(bt, bh, MC_HOUR, dt.dt_hour);
	rtc_write_reg(bt, bh, MC_DOW, dt.dt_wday);
	rtc_write_reg(bt, bh, MC_DOM, dt.dt_day);
	rtc_write_reg(bt, bh, MC_MONTH, dt.dt_mon);
	rtc_write_reg(bt, bh, MC_YEAR, year);

	/* load them up */
	csr = rtc_read_reg(bt, bh, MC_REGB);
	csr &= ~MC_REGB_SET;
	rtc_write_reg(bt, bh, MC_REGB, csr);
	todr_wenable(handle, 0);
	return (0);
}

int
rtc_getcal(handle, vp)
	todr_chip_handle_t handle;
	int *vp;
{
	return (EOPNOTSUPP);
}

int
rtc_setcal(handle, v)
	todr_chip_handle_t handle;
	int v;
{
	return (EOPNOTSUPP);
@


1.30
log
@Fix DEBUG built.

ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.29 2007/03/19 14:04:04 art Exp $	*/
a1140 2

#define	USECPERSEC	1000000
@


1.29
log
@Not only did I break RAMDISK, I also left a debugging printf.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.28 2007/03/19 12:45:01 deraadt Exp $	*/
d810 1
d815 1
d817 1
a817 1
		tick_base = (time_second * 1000000LL + time.tv_usec) 
d822 1
a822 1
		int64_t clk = (time.tv_sec * 1000000LL + time.tv_usec);
@


1.28
log
@please always test RAMDISK kernels
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.27 2007/03/16 09:28:38 art Exp $	*/
a978 2

printf("setting time to: %d\n", tv.tv_sec);
@


1.27
log
@Timecounters for sparc64. The cleanest and easiest timecounter
implementation this far. Uses the %tick register (as microtime was
using before).

kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.26 2006/07/01 20:05:11 kettenis Exp $	*/
d976 1
a977 1
#endif
@


1.26
log
@Cleanup dmesg printing.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.25 2006/06/21 22:28:56 miod Exp $	*/
d77 1
a99 1
static u_int64_t lasttick;
d117 6
a673 1
	static u_int64_t start_time;
d697 3
a701 14
	 * Calculate the starting %tick value.  We set that to the same
	 * as time, scaled for the CPU clockrate.  This gets nasty, but
	 * we can handle it.  time.tv_usec is in microseconds.  
	 * cpu_clockrate is in MHz.  
	 */
	start_time = time.tv_sec * cpu_clockrate;
	/* Now fine tune the usecs */
	start_time += cpu_clockrate / 1000000 * time.tv_usec;
	
	/* Initialize the %tick register */
	lasttick = start_time;
	__asm __volatile("wrpr %0, 0, %%tick" : : "r" (start_time));

	/*
d815 1
a815 1
		tick_base = (time.tv_sec * 1000000LL + time.tv_usec) 
a837 2
	lasttick = tick() & TICK_TICKS;

a859 2
	__asm __volatile("rd %%tick, %0" : "=r" (lasttick) :);
	lasttick &= TICK_TICKS;
d938 2
d953 2
a954 3
	if (todr_handle &&
	    (todr_gettime(todr_handle, (struct timeval *)&time) != 0 ||
	    time.tv_sec == 0)) {
d960 2
a961 1
		time.tv_sec = base;
d965 1
a965 1
		int deltat = time.tv_sec - base;
d971 1
a971 2
		if (waszero || deltat < 2 * SECDAY)
			return;
d973 4
a976 3
		printf("WARNING: clock %s %ld days",
		    time.tv_sec < base ? "lost" : "gained", deltat / SECDAY);
		bad = "";
d979 7
d1001 1
d1003 1
a1003 1
	if (time.tv_sec == 0)
d1006 2
d1009 1
a1009 2
	if (todr_handle == 0 ||
		todr_settime(todr_handle, (struct timeval *)&time) != 0)
d1144 2
a1145 3
void
microtime(tvp)
	struct timeval *tvp;
a1146 1
	int s;
a1148 1
	s = splhigh();
a1149 7
	tick &= TICK_TICKS;
	tick -= lasttick;
	tvp->tv_sec = time.tv_sec;
	tvp->tv_usec = time.tv_usec;
	splx(s);

	tick = (tick * USECPERSEC) / cpu_clockrate;
d1151 1
a1151 7
	tvp->tv_sec += tick / USECPERSEC;
	tvp->tv_usec += tick % USECPERSEC;

	while (tvp->tv_usec >= USECPERSEC) {
		tvp->tv_sec++;
		tvp->tv_usec -= USECPERSEC;
	}
@


1.25
log
@Only attach timer to the first counter-timer found.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.24 2006/06/20 20:31:32 miod Exp $	*/
d613 2
a614 5
	printf(" irq vectors %lx and %lx", 
	       (u_long)level10.ih_number, 
	       (u_long)level14.ih_number);

	printf("\n");
@


1.24
log
@Do not print hostid while booting, there's a sysctl for this.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.23 2005/04/26 18:54:39 miod Exp $	*/
d576 4
a579 1
	return (strcmp("counter-timer", ma->ma_name) == 0);
a714 1

@


1.23
log
@Remove unused hooks for periodic pcons polling.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.22 2004/09/28 19:21:58 jason Exp $	*/
d445 1
a445 2
	printf(": hostid %x\n", (u_int)hostid);

d449 2
a450 1
getidprom() {
@


1.22
log
@nuke unused variable
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.21 2004/09/23 17:25:03 jason Exp $	*/
a851 2
int poll_console = 0;

a866 2
	if (poll_console)
		setsoftint();
@


1.21
log
@clock@@fhc
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.20 2004/06/28 01:47:41 aaron Exp $	*/
a127 1
int timerok;
a614 1
	timerok = 1;
@


1.20
log
@Use new event counter API for interrupt counting on sparc64.  deraadt@@ tholo@@
drahn@@ millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.19 2004/04/08 01:11:22 deraadt Exp $	*/
d97 1
d145 2
d159 4
d234 11
d380 29
@


1.19
log
@on RAMDISK kernels, do not compare / time against the system time
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.18 2003/05/18 15:32:10 henric Exp $	*/
d555 1
d561 1
d679 1
d802 2
d832 1
d876 3
@


1.18
log
@The attach routine works better when it doesn't try to write to a
write-protected page.

ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.17 2003/02/28 21:30:30 jason Exp $	*/
d898 1
d913 2
a914 3
		(todr_gettime(todr_handle, (struct timeval *)&time) != 0 ||
		time.tv_sec == 0)) {
		printf("WARNING: bad date in battery clock");
d919 1
d932 1
d935 6
a941 1
	printf(" -- CHECK AND RESET THE DATE!\n");
@


1.17
log
@update lasttick in clockintr() so that time doesn't run away with us
(based on a larger diff from henric).
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.16 2003/02/22 23:50:37 jason Exp $	*/
a483 7
	/* 
	 * Turn interrupts off, just in case. (Although they shouldn't
	 * be wired to an interrupt controller on sparcs).
	 */
	rtc_write_reg(bt, cwi.cwi_bh, 
		MC_REGB, MC_REGB_BINARY | MC_REGB_24HR);

d506 10
@


1.16
log
@always use %tick based microtime (ie. remove conditional for counter-timer)
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.15 2003/02/17 01:29:20 henric Exp $	*/
d766 3
a768 1
	int64_t t = (u_int64_t)tick();
d793 3
@


1.15
log
@
Add support for the Sun Enterprise 450
Reduce the size of a GENERIC kernel by ~190k
Remove the nasty pointer/bus_space_handle_t casts
Adds debug bus_space code including the ability to trace
    bus operations (it actually works now).

The following rules are now followed (and verfified by the debug
code):

1.  A "bus_space_handle_t" may only be used with the
    "bus_space_tag_t" that created it.
2.  Only "bus_space_map()" may create "bus_space_handle_t"s.
3.  A "bus_space_handle_t" may not be modified after it has
    been created (other than being destroyed by "bus_space_unmap()").


Thanks to help from mcbride, marc, jason, drahn, to anyone that might
have slipped my mind at the moment.

ok jason@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.14 2002/10/12 01:09:43 krw Exp $	*/
d1083 2
a1084 11
	if (timerreg_4u.t_timer == NULL) {
		int s;
		u_int64_t tick;

		s = splhigh();
		__asm __volatile("rd %%tick, %0" : "=r" (tick) :);
		tick &= TICK_TICKS;
		tick -= lasttick;
		tvp->tv_sec = time.tv_sec;
		tvp->tv_usec = time.tv_usec;
		splx(s);
d1086 7
a1092 1
		tick = (tick * USECPERSEC) / cpu_clockrate;
d1094 1
a1094 12
		tvp->tv_sec += tick / USECPERSEC;
		tvp->tv_usec += tick % USECPERSEC;
	} else {
		struct timeval t1, t2;
		int64_t t_tick;

		do {
		
			t1 = time;
			t_tick = timerreg_4u.t_timer->t_count;
			t2 = time;
		} while (t1.tv_sec != t2.tv_sec || t1.tv_usec != t2.tv_usec);
d1096 2
a1097 3
		tvp->tv_sec = t1.tv_sec;
		tvp->tv_usec = t1.tv_usec + t_tick;
	}
@


1.14
log
@Remove more '\n's from panic() statements. Both trailing and leading.

Diff generated by Chris Kuethe.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.13 2002/06/15 17:23:31 art Exp $	*/
d106 6
d181 1
a181 2
int sbus_wenable(struct todr_chip_handle *, int);
int ebus_wenable(struct todr_chip_handle *, int);
a259 7
/* Somewhere to keep info that sbus_wenable() needs */
struct sbus_info {
	bus_space_tag_t		si_bt;
	bus_space_handle_t	si_bh;
	struct sbus_reg		si_reg;
};

d269 1
a269 1
	static struct sbus_info sbi;
d278 2
a279 3
			 BUS_SPACE_MAP_LINEAR|BUS_SPACE_MAP_READONLY,
			 0,
			 &sbi.si_bh) != 0) {
d283 1
a283 1
	clockattach(sa->sa_node, bt, sbi.si_bh);
d286 4
a289 4
	sbi.si_bt = bt;
	sbi.si_reg = sa->sa_reg[0];
	todr_handle->bus_cookie = &sbi;
	todr_handle->todr_setwen = sbus_wenable;
d295 2
d299 1
a299 1
sbus_wenable(handle, onoff)
d303 4
a306 3
	register int s, err = 0;
	register int prot;/* nonzero => change prot */
	static int writers;
d310 2
a311 1
		prot = writers++ == 0 ? BUS_SPACE_MAP_LINEAR : 0;
d313 2
a314 2
		prot = --writers == 0 ? 
			BUS_SPACE_MAP_LINEAR|BUS_SPACE_MAP_READONLY : 0;
d316 1
d318 5
a322 11
		struct sbus_info *sbi = (struct sbus_info *)handle->bus_cookie;
		bus_space_handle_t newaddr;

		err = sbus_bus_map(sbi->si_bt, sbi->si_reg.sbr_slot,
			(sbi->si_reg.sbr_offset & ~NBPG),
			8192, prot, (vaddr_t)sbi->si_bh, &newaddr);
		/* We can panic now or take a datafault later... */
		if (sbi->si_bh != newaddr)
			panic("sbus_wenable: address %p changed to %p",
			      (void *)(u_long)sbi->si_bh,
			      (void *)(u_long)newaddr);
a326 7

struct ebus_info {
	bus_space_tag_t		ei_bt;
	bus_space_handle_t	ei_bh;
	struct ebus_regs	ei_reg;
};

d334 1
a334 1
	bus_space_tag_t bt = ea->ea_bustag;
d336 1
a336 1
	static struct ebus_info ebi;
d341 9
a349 7
	if (ebus_bus_map(bt,
			 0,
			 EBUS_PADDR_FROM_REG(&ea->ea_regs[0]),
			 sz,
			 BUS_SPACE_MAP_LINEAR,
			 0,
			 &ebi.ei_bh) != 0) {
d353 2
a354 1
	clockattach(ea->ea_node, bt, ebi.ei_bh);
d357 5
a361 40
	ebi.ei_bt = bt;
	ebi.ei_reg = ea->ea_regs[0];
	todr_handle->bus_cookie = &ebi;
	todr_handle->todr_setwen = ebus_wenable;
}

/*
 * Write en/dis-able clock registers.  We coordinate so that several
 * writers can run simultaneously.
 */
int
ebus_wenable(handle, onoff)
	struct todr_chip_handle *handle;
	int onoff;
{
	register int s, err = 0;
	register int prot;/* nonzero => change prot */
	static int writers;

	s = splhigh();
	if (onoff)
		prot = writers++ == 0 ? BUS_SPACE_MAP_LINEAR : 0;
	else
		prot = --writers == 0 ? 
			BUS_SPACE_MAP_LINEAR|BUS_SPACE_MAP_READONLY : 0;
	splx(s);
	if (prot) {
		struct ebus_info *ebi = (struct ebus_info *)handle->bus_cookie;
		bus_space_handle_t newaddr;

		err = sbus_bus_map(ebi->ei_bt, 0,
			EBUS_PADDR_FROM_REG(&ebi->ei_reg), 8192, prot,
			(vaddr_t)ebi->ei_bh, &newaddr);
		/* We can panic now or take a datafault later... */
		if (ebi->ei_bh != newaddr)
			panic("ebus_wenable: address %p changed to %p",
			      (void *)(u_long)ebi->ei_bh,
			      (void *)(u_long)newaddr);
	}
	return (err);
a363 1

d389 2
a390 1
			idp = (struct idprom *)((u_long)bh + IDPROM_OFFSET);
d454 1
a454 1
	bus_space_tag_t bt = ea->ea_bustag;
d459 1
a459 1
	static struct ebus_info ebi;
d464 9
a472 7
	if (ebus_bus_map(bt,
			 0,
			 EBUS_PADDR_FROM_REG(&ea->ea_regs[0]),
			 sz,
			 BUS_SPACE_MAP_LINEAR,
			 0,
			 &ebi.ei_bh) != 0) {
d488 1
a488 1
	rtc_write_reg(bt, ebi.ei_bh, 
a502 1
	handle->todr_setwen = NULL;
d504 1
a504 1
	rtc->rtc_bh = ebi.ei_bh;
d507 5
a511 4
	ebi.ei_bt = bt;
	ebi.ei_reg = ea->ea_regs[0];
	handle->bus_cookie = &ebi;
	handle->todr_setwen = ebus_wenable;
a536 3
#if 0
	volatile int64_t *cnt = NULL, *lim = NULL;
#endif
d551 1
d553 1
d556 2
a558 1
	intr_establish(14, &level14);
d663 2
a664 2
		printf("No counter-timer -- using %%tick at %ldMHz as system clock.\n",
			(long)(cpu_clockrate/1000000));
d681 2
a682 1
		printf("Using %%tick -- intr in %ld cycles...", tick_increment);
d779 3
a781 2
			printf("Actual: %llx Expected: %llx tick %llx tick_base %llx\n",
			       (long long)t, (long long)clk, (long long)tk, (long long)tick_base);
d831 1
a831 1
	register u_long newint, r, var;
d923 1
a923 1
		printf("WARNING: clock %s %d days",
@


1.13
log
@Decruftification.

We will never have a.out kernels.
We will never have 32-bit kernels.
We will never have sun4c, sun4 and sun4m support in the sparc64 kernels.
We don't need support old netbsd libc.
The cpu will never be identified as some of the sun4c and sun4m types.
We don't need the gazillion of fields in cpuinfo that the sparc port uses.
Just generally remove dead code.

This is just a first step in making this meess readable.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.12 2002/04/04 17:01:12 jason Exp $	*/
d324 1
a324 1
			panic("sbus_wenable: address %p changed to %p\n",
d400 1
a400 1
			panic("ebus_wenable: address %p changed to %p\n",
@


1.12
log
@Fetch the "idprom" property from the root and if that fails get it
from the nvram.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.11 2002/04/03 17:22:40 jason Exp $	*/
a695 1
#ifdef __arch64__
a696 9
#else
	{
		int start_hi = (start_time>>32), start_lo = start_time;
		__asm __volatile("sllx %1,32,%0; or %0,%2,%0; wrpr %0, 0, %%tick" 
				 : "=&r" (start_hi) /* scratch register */
				 : "r" ((int)(start_hi)), "r" ((int)(start_lo)));
	}
#endif

@


1.11
log
@Replace the implementation of microtime with one written in C that doesn't go backwards on machines w/out counter-timer
Remove a bunch of uncessary code (#if 0, #undef, etc)
[still exhibits bad behavior on counter-timer machines, but it's the same
behavior as the assembler version]
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.10 2002/03/14 03:16:01 millert Exp $	*/
d179 1
d430 7
a436 2
	idp = (struct idprom *)((u_long)bh + IDPROM_OFFSET);

d444 15
a458 1
	idprom = idp;
@


1.10
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.9 2002/03/14 01:26:45 millert Exp $	*/
d98 1
a583 39
#if 0
	cnt = &(timerreg_4u.t_timer[0].t_count);
	lim = &(timerreg_4u.t_timer[0].t_limit);

	/*
	 * Calibrate delay() by tweaking the magic constant
	 * until a delay(100) actually reads (at least) 100 us 
	 * on the clock.  Since we're using the %tick register 
	 * which should be running at exactly the CPU clock rate, it
	 * has a period of somewhere between 7ns and 3ns.
	 */

#ifdef DEBUG
	printf("Delay calibrarion....\n");
#endif
	for (timerblurb = 1; timerblurb > 0; timerblurb++) {
		volatile int discard;
		register int t0, t1;

		/* Reset counter register by writing some large limit value */
		discard = *lim;
		*lim = tmr_ustolim(TMR_MASK-1);

		t0 = *cnt;
		delay(100);
		t1 = *cnt;

		if (t1 & TMR_LIMIT)
			panic("delay calibration");

		t0 = (t0 >> TMR_SHIFT) & TMR_MASK;
		t1 = (t1 >> TMR_SHIFT) & TMR_MASK;

		if (t1 >= t0 + 100)
			break;
	}

	printf(" delay constant %d\n", timerblurb);
#endif
d675 1
d844 2
d1106 42
@


1.9
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.8 2002/01/25 03:36:25 jason Exp $	*/
d573 1
a573 1
	level10.ih_clr = (void*)&timerreg_4u.t_clrintr[0];
d576 1
a576 1
	level14.ih_clr = (void*)&timerreg_4u.t_clrintr[1];
@


1.8
log
@Remove more NKBD/NMS references (jason == cpp tonight I guess)
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.7 2002/01/10 00:06:17 nordin Exp $	*/
d123 1
a123 1
int schedintr __P((void *));
d133 7
a139 7
static int	clockmatch_sbus __P((struct device *, void *, void *));
static void	clockattach_sbus __P((struct device *, struct device *, void *));
static int	clockmatch_ebus __P((struct device *, void *, void *));
static void	clockattach_ebus __P((struct device *, struct device *, void *));
static int	clockmatch_rtc __P((struct device *, void *, void *));
static void	clockattach_rtc __P((struct device *, struct device *, void *));
static void	clockattach __P((int, bus_space_tag_t, bus_space_handle_t));
d161 2
a162 2
static int	timermatch __P((struct device *, void *, void *));
static void	timerattach __P((struct device *, struct device *, void *));
d174 2
a175 2
int sbus_wenable __P((struct todr_chip_handle *, int));
int ebus_wenable __P((struct todr_chip_handle *, int));
d177 4
a180 4
void myetheraddr __P((u_char *));
int chiptotime __P((int, int, int, int, int, int));
void timetochip __P((struct chiptime *));
void stopcounter __P((struct timer_4u *));
@


1.7
log
@Check result from malloc(9) when using M_NOWAIT. jason@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.6 2001/12/07 19:09:00 jason Exp $	*/
a874 5

#if	NKBD	> 0
	extern int cnrom __P((void));
	extern int rom_console_input;
#endif
@


1.6
log
@Mimic some of the rtc handling (the m5819 on the x1 is a ds1287-alike) from i386, especially to do with year handling.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.5 2001/12/07 16:30:20 jason Exp $	*/
d514 2
@


1.6.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.8 2002/01/25 03:36:25 jason Exp $	*/
a513 2
	if (handle == NULL)
		panic("clockattach_rtc");
d873 5
@


1.6.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.6.2.1 2002/01/31 22:55:24 niklas Exp $	*/
a97 1
static u_int64_t lasttick;
d123 1
a123 1
int schedintr(void *);
d133 7
a139 7
static int	clockmatch_sbus(struct device *, void *, void *);
static void	clockattach_sbus(struct device *, struct device *, void *);
static int	clockmatch_ebus(struct device *, void *, void *);
static void	clockattach_ebus(struct device *, struct device *, void *);
static int	clockmatch_rtc(struct device *, void *, void *);
static void	clockattach_rtc(struct device *, struct device *, void *);
static void	clockattach(int, bus_space_tag_t, bus_space_handle_t);
d161 2
a162 2
static int	timermatch(struct device *, void *, void *);
static void	timerattach(struct device *, struct device *, void *);
d174 2
a175 2
int sbus_wenable(struct todr_chip_handle *, int);
int ebus_wenable(struct todr_chip_handle *, int);
d177 4
a180 5
void myetheraddr(u_char *);
struct idprom *getidprom(void);
int chiptotime(int, int, int, int, int, int);
void timetochip(struct chiptime *);
void stopcounter(struct timer_4u *);
d428 2
a429 7
	if (idprom == NULL) {
		idp = getidprom();
		if (idp == NULL)
			idp = (struct idprom *)((u_long)bh + IDPROM_OFFSET);
		idprom = idp;
	} else
		idp = idprom;
d437 1
a437 15
}

struct idprom *
getidprom() {
	struct idprom *idp = NULL;
	int node, n;

	node = findroot();
	if (getprop(node, "idprom", sizeof(*idp), &n, (void **)&idp) != 0)
		return (NULL);
	if (n != 1) {
		free(idp, M_DEVBUF);
		return (NULL);
	}
	return (idp);
d573 1
a573 1
	level10.ih_clr = (void *)&timerreg_4u.t_clrintr[0];
d576 1
a576 1
	level14.ih_clr = (void *)&timerreg_4u.t_clrintr[1];
d583 39
a712 1
	lasttick = start_time;
a880 2
	__asm __volatile("rd %%tick, %0" : "=r" (lasttick) :);
	lasttick &= TICK_TICKS;
a1140 42
#define	USECPERSEC	1000000

void
microtime(tvp)
	struct timeval *tvp;
{
	if (timerreg_4u.t_timer == NULL) {
		int s;
		u_int64_t tick;

		s = splhigh();
		__asm __volatile("rd %%tick, %0" : "=r" (tick) :);
		tick &= TICK_TICKS;
		tick -= lasttick;
		tvp->tv_sec = time.tv_sec;
		tvp->tv_usec = time.tv_usec;
		splx(s);

		tick = (tick * USECPERSEC) / cpu_clockrate;

		tvp->tv_sec += tick / USECPERSEC;
		tvp->tv_usec += tick % USECPERSEC;
	} else {
		struct timeval t1, t2;
		int64_t t_tick;

		do {
		
			t1 = time;
			t_tick = timerreg_4u.t_timer->t_count;
			t2 = time;
		} while (t1.tv_sec != t2.tv_sec || t1.tv_usec != t2.tv_usec);

		tvp->tv_sec = t1.tv_sec;
		tvp->tv_usec = t1.tv_usec + t_tick;
	}

	while (tvp->tv_usec >= USECPERSEC) {
		tvp->tv_sec++;
		tvp->tv_usec -= USECPERSEC;
	}
}
@


1.6.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.6.2.2 2002/06/11 03:38:43 art Exp $	*/
d324 1
a324 1
			panic("sbus_wenable: address %p changed to %p",
d400 1
a400 1
			panic("ebus_wenable: address %p changed to %p",
d696 1
d698 9
@


1.6.2.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a105 6
struct clock_wenable_info {
	bus_space_tag_t		cwi_bt;
	bus_space_handle_t	cwi_bh;
	bus_size_t		cwi_size;
};

d175 2
a176 1
int clock_bus_wenable(struct todr_chip_handle *, int);
d255 7
d271 1
a271 1
	static struct clock_wenable_info cwi;
d280 3
a282 2
			 BUS_SPACE_MAP_LINEAR | BUS_SPACE_MAP_READONLY,
			 0, &cwi.cwi_bh) != 0) {
d286 1
a286 1
	clockattach(sa->sa_node, bt, cwi.cwi_bh);
d289 4
a292 4
	cwi.cwi_bt = bt;
	cwi.cwi_size = sz;
	todr_handle->bus_cookie = &cwi;
	todr_handle->todr_setwen = clock_bus_wenable;
a297 2
 * XXX There is still a race here.  The page change and the "writers"
 * change are not atomic.
d300 1
a300 1
clock_bus_wenable(handle, onoff)
d304 3
a306 4
	int s, err = 0;
	int prot; /* nonzero => change prot */
	volatile static int writers;
	struct clock_wenable_info *cwi = handle->bus_cookie;
d310 1
a310 2
		prot = writers++ == 0 ?
		    VM_PROT_READ | VM_PROT_WRITE | PMAP_WIRED : 0;
d312 2
a313 2
		prot = --writers == 0 ?
		    VM_PROT_READ | PMAP_WIRED : 0;
d315 3
d319 8
a326 6
	if (prot) {
		err = bus_space_protect(cwi->cwi_bt, cwi->cwi_bh, cwi->cwi_size,
		    onoff ? 0 : BUS_SPACE_MAP_READONLY);
		if (err)
			printf("clock_wenable_info: WARNING -- cannot %s "
			    "page protection\n", onoff ? "disable" : "enable");
d331 7
d345 1
a345 1
	bus_space_tag_t bt;
d347 1
a347 1
	static struct clock_wenable_info cwi;
d352 7
a358 9
	if (ebus_bus_map(ea->ea_iotag, 0,
	    EBUS_PADDR_FROM_REG(&ea->ea_regs[0]), sz, 0, 0, &cwi.cwi_bh) == 0) {
		bt = ea->ea_iotag;
	} else if (ebus_bus_map(ea->ea_memtag, 0,
	    EBUS_PADDR_FROM_REG(&ea->ea_regs[0]), sz,
	    BUS_SPACE_MAP_LINEAR | BUS_SPACE_MAP_READONLY,
	    0, &cwi.cwi_bh) == 0) {
		bt = ea->ea_memtag;
	} else {
d362 1
d364 19
a382 1
	clockattach(ea->ea_node, bt, cwi.cwi_bh);
d384 21
a404 6
	/* Save info for the clock wenable call. */
	cwi.cwi_bt = bt;
	cwi.cwi_size = sz;
	todr_handle->bus_cookie = &cwi;
	todr_handle->todr_setwen = (ea->ea_memtag == bt) ? 
	    clock_bus_wenable : NULL;
d407 1
d433 1
a433 2
			idp = (struct idprom *)(bus_space_vaddr(bt, bh) +
			    IDPROM_OFFSET);
d497 1
a497 1
	bus_space_tag_t bt;
d502 1
a502 1
	static struct clock_wenable_info cwi;
d507 7
a513 9
	if (ebus_bus_map(ea->ea_iotag, 0,
	    EBUS_PADDR_FROM_REG(&ea->ea_regs[0]), sz, 0, 0, &cwi.cwi_bh) == 0) {
		bt = ea->ea_iotag;
	} else if (ebus_bus_map(ea->ea_memtag, 0,
	    EBUS_PADDR_FROM_REG(&ea->ea_regs[0]), sz,
	    BUS_SPACE_MAP_LINEAR | BUS_SPACE_MAP_READONLY,
	    0, &cwi.cwi_bh) == 0) {
		bt = ea->ea_memtag;
	} else {
d529 1
a529 1
	rtc_write_reg(bt, cwi.cwi_bh, 
d544 1
d546 1
a546 1
	rtc->rtc_bh = cwi.cwi_bh;
d549 4
a552 5
	cwi.cwi_bt = bt;
	cwi.cwi_size = sz;
	handle->bus_cookie = &cwi;
	handle->todr_setwen = (ea->ea_memtag == bt) ?
	    clock_bus_wenable : NULL;
d578 3
a594 1
	level10.ih_map = (void *)&timerreg_4u.t_mapintr[0];
a595 1

d598 1
a598 1
	level14.ih_map = (void *)&timerreg_4u.t_mapintr[1];
a599 1

d704 2
a705 2
		printf("No counter-timer -- using %%tick at %ldMHz as "
		    "system clock.\n", (long)(cpu_clockrate/1000000));
d722 1
a722 2
		printf("Using %%tick -- intr in %ld cycles...",
		    tick_increment);
d806 1
a806 3
	int64_t t;

	t = tick() & TICK_TICKS;
d819 2
a820 3
			printf("Actual: %llx Expected: %llx tick %llx "
			    "tick_base %llx\n", (long long)t, (long long)clk,
			    (long long)tk, (long long)tick_base);
a829 3

	lasttick = tick() & TICK_TICKS;

d870 1
a870 1
	u_long newint, r, var;
d962 1
a962 1
		printf("WARNING: clock %s %ld days",
d1122 13
a1134 2
	int s;
	u_int64_t tick;
d1136 5
a1140 7
	s = splhigh();
	__asm __volatile("rd %%tick, %0" : "=r" (tick) :);
	tick &= TICK_TICKS;
	tick -= lasttick;
	tvp->tv_sec = time.tv_sec;
	tvp->tv_usec = time.tv_usec;
	splx(s);
d1142 6
a1147 1
	tick = (tick * USECPERSEC) / cpu_clockrate;
d1149 3
a1151 2
	tvp->tv_sec += tick / USECPERSEC;
	tvp->tv_usec += tick % USECPERSEC;
@


1.5
log
@add rtc cfdriver
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.4 2001/11/06 19:53:16 miod Exp $	*/
a102 2
	u_int		rtc_year0;	/* What year is represented on the system
					   by the chip's year counter at 0 */
a523 2
	/* Our TOD clock year 0 is 1968 */
	rtc->rtc_year0 = 1968;	/* XXX Really? */
a1062 5
printf("rtc_gettime: read y %x/%d m %x/%d wd %d d %x/%d "
	"h %x/%d m %x/%d s %x/%d\n",
	year, year, dt.dt_mon, dt.dt_mon, dt.dt_wday,
	dt.dt_day, dt.dt_day, dt.dt_hour, dt.dt_hour,
	dt.dt_min, dt.dt_min, dt.dt_sec, dt.dt_sec);
d1064 1
a1064 2
	year += rtc->rtc_year0;
	if (year < POSIX_BASE_YEAR && rtc_auto_century_adjust != 0)
d1104 1
a1104 3
	year = dt.dt_year - rtc->rtc_year0;
	if (year > 99 && rtc_auto_century_adjust != 0)
		year -= 100;
@


1.4
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.3 2001/10/02 14:57:09 jason Exp $	*/
a142 1

d155 3
a157 1
extern struct cfdriver clock_cd;
@


1.3
log
@fix rtc_write_reg; netbsd.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.2 2001/08/20 20:23:53 jason Exp $	*/
a77 1
#include <vm/vm.h>
@


1.3.4.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.3.4.2
log
@Merge in -current
@
text
@d78 1
@


1.3.4.3
log
@Merge in trunk
@
text
@d103 2
d143 1
d156 1
a156 3
struct cfdriver rtc_cd = {
	NULL, "rtc", DV_DULL
};
a514 2
	if (handle == NULL)
		panic("clockattach_rtc");
d525 2
d877 5
d1066 5
d1072 2
a1073 1
	if ((year += 1900) < POSIX_BASE_YEAR)
d1113 3
a1115 1
	year = dt.dt_year % 100;
@


1.3.4.4
log
@Merge in -current from about a week ago
@
text
@d123 1
a123 1
int schedintr(void *);
d133 7
a139 7
static int	clockmatch_sbus(struct device *, void *, void *);
static void	clockattach_sbus(struct device *, struct device *, void *);
static int	clockmatch_ebus(struct device *, void *, void *);
static void	clockattach_ebus(struct device *, struct device *, void *);
static int	clockmatch_rtc(struct device *, void *, void *);
static void	clockattach_rtc(struct device *, struct device *, void *);
static void	clockattach(int, bus_space_tag_t, bus_space_handle_t);
d161 2
a162 2
static int	timermatch(struct device *, void *, void *);
static void	timerattach(struct device *, struct device *, void *);
d174 2
a175 2
int sbus_wenable(struct todr_chip_handle *, int);
int ebus_wenable(struct todr_chip_handle *, int);
d177 4
a180 4
void myetheraddr(u_char *);
int chiptotime(int, int, int, int, int, int);
void timetochip(struct chiptime *);
void stopcounter(struct timer_4u *);
d573 1
a573 1
	level10.ih_clr = (void *)&timerreg_4u.t_clrintr[0];
d576 1
a576 1
	level14.ih_clr = (void *)&timerreg_4u.t_clrintr[1];
@


1.3.4.5
log
@Sync the SMP branch with 3.3
@
text
@a97 1
static u_int64_t lasttick;
a104 6
struct clock_wenable_info {
	bus_space_tag_t		cwi_bt;
	bus_space_handle_t	cwi_bh;
	bus_size_t		cwi_size;
};

d174 2
a175 1
int clock_bus_wenable(struct todr_chip_handle *, int);
a177 1
struct idprom *getidprom(void);
d253 7
d269 1
a269 1
	static struct clock_wenable_info cwi;
d278 3
a280 2
			 BUS_SPACE_MAP_LINEAR | BUS_SPACE_MAP_READONLY,
			 0, &cwi.cwi_bh) != 0) {
d284 1
a284 1
	clockattach(sa->sa_node, bt, cwi.cwi_bh);
d287 4
a290 4
	cwi.cwi_bt = bt;
	cwi.cwi_size = sz;
	todr_handle->bus_cookie = &cwi;
	todr_handle->todr_setwen = clock_bus_wenable;
a295 2
 * XXX There is still a race here.  The page change and the "writers"
 * change are not atomic.
d298 1
a298 1
clock_bus_wenable(handle, onoff)
d302 3
a304 4
	int s, err = 0;
	int prot; /* nonzero => change prot */
	volatile static int writers;
	struct clock_wenable_info *cwi = handle->bus_cookie;
d308 1
a308 2
		prot = writers++ == 0 ?
		    VM_PROT_READ | VM_PROT_WRITE | PMAP_WIRED : 0;
d310 2
a311 2
		prot = --writers == 0 ?
		    VM_PROT_READ | PMAP_WIRED : 0;
d313 3
d317 8
a324 6
	if (prot) {
		err = bus_space_protect(cwi->cwi_bt, cwi->cwi_bh, cwi->cwi_size,
		    onoff ? 0 : BUS_SPACE_MAP_READONLY);
		if (err)
			printf("clock_wenable_info: WARNING -- cannot %s "
			    "page protection\n", onoff ? "disable" : "enable");
d329 7
d343 1
a343 1
	bus_space_tag_t bt;
d345 1
a345 1
	static struct clock_wenable_info cwi;
d350 7
a356 9
	if (ebus_bus_map(ea->ea_iotag, 0,
	    EBUS_PADDR_FROM_REG(&ea->ea_regs[0]), sz, 0, 0, &cwi.cwi_bh) == 0) {
		bt = ea->ea_iotag;
	} else if (ebus_bus_map(ea->ea_memtag, 0,
	    EBUS_PADDR_FROM_REG(&ea->ea_regs[0]), sz,
	    BUS_SPACE_MAP_LINEAR | BUS_SPACE_MAP_READONLY,
	    0, &cwi.cwi_bh) == 0) {
		bt = ea->ea_memtag;
	} else {
d360 21
d382 10
a391 1
	clockattach(ea->ea_node, bt, cwi.cwi_bh);
d393 10
a402 6
	/* Save info for the clock wenable call. */
	cwi.cwi_bt = bt;
	cwi.cwi_size = sz;
	todr_handle->bus_cookie = &cwi;
	todr_handle->todr_setwen = (ea->ea_memtag == bt) ? 
	    clock_bus_wenable : NULL;
d405 1
d428 2
a429 8
	if (idprom == NULL) {
		idp = getidprom();
		if (idp == NULL)
			idp = (struct idprom *)(bus_space_vaddr(bt, bh) +
			    IDPROM_OFFSET);
		idprom = idp;
	} else
		idp = idprom;
d437 1
a437 15
}

struct idprom *
getidprom() {
	struct idprom *idp = NULL;
	int node, n;

	node = findroot();
	if (getprop(node, "idprom", sizeof(*idp), &n, (void **)&idp) != 0)
		return (NULL);
	if (n != 1) {
		free(idp, M_DEVBUF);
		return (NULL);
	}
	return (idp);
d476 1
a476 1
	bus_space_tag_t bt;
d481 1
a481 1
	static struct clock_wenable_info cwi;
d486 7
a492 9
	if (ebus_bus_map(ea->ea_iotag, 0,
	    EBUS_PADDR_FROM_REG(&ea->ea_regs[0]), sz, 0, 0, &cwi.cwi_bh) == 0) {
		bt = ea->ea_iotag;
	} else if (ebus_bus_map(ea->ea_memtag, 0,
	    EBUS_PADDR_FROM_REG(&ea->ea_regs[0]), sz,
	    BUS_SPACE_MAP_LINEAR | BUS_SPACE_MAP_READONLY,
	    0, &cwi.cwi_bh) == 0) {
		bt = ea->ea_memtag;
	} else {
d508 1
a508 1
	rtc_write_reg(bt, cwi.cwi_bh, 
d523 1
d525 1
a525 1
	rtc->rtc_bh = cwi.cwi_bh;
d528 4
a531 5
	cwi.cwi_bt = bt;
	cwi.cwi_size = sz;
	handle->bus_cookie = &cwi;
	handle->todr_setwen = (ea->ea_memtag == bt) ?
	    clock_bus_wenable : NULL;
d557 3
a573 1
	level10.ih_map = (void *)&timerreg_4u.t_mapintr[0];
a574 1

d577 1
a577 1
	level14.ih_map = (void *)&timerreg_4u.t_mapintr[1];
a578 1

d583 39
d713 1
a713 1
	lasttick = start_time;
d715 9
d731 2
a732 2
		printf("No counter-timer -- using %%tick at %ldMHz as "
		    "system clock.\n", (long)(cpu_clockrate/1000000));
d749 1
a749 2
		printf("Using %%tick -- intr in %ld cycles...",
		    tick_increment);
d833 1
a833 3
	int64_t t;

	t = tick() & TICK_TICKS;
d846 2
a847 3
			printf("Actual: %llx Expected: %llx tick %llx "
			    "tick_base %llx\n", (long long)t, (long long)clk,
			    (long long)tk, (long long)tick_base);
a856 3

	lasttick = tick() & TICK_TICKS;

a880 2
	__asm __volatile("rd %%tick, %0" : "=r" (lasttick) :);
	lasttick &= TICK_TICKS;
d895 1
a895 1
	u_long newint, r, var;
d987 1
a987 1
		printf("WARNING: clock %s %ld days",
a1140 27
#define	USECPERSEC	1000000

void
microtime(tvp)
	struct timeval *tvp;
{
	int s;
	u_int64_t tick;

	s = splhigh();
	__asm __volatile("rd %%tick, %0" : "=r" (tick) :);
	tick &= TICK_TICKS;
	tick -= lasttick;
	tvp->tv_sec = time.tv_sec;
	tvp->tv_usec = time.tv_usec;
	splx(s);

	tick = (tick * USECPERSEC) / cpu_clockrate;

	tvp->tv_sec += tick / USECPERSEC;
	tvp->tv_usec += tick % USECPERSEC;

	while (tvp->tv_usec >= USECPERSEC) {
		tvp->tv_sec++;
		tvp->tv_usec -= USECPERSEC;
	}
}
@


1.3.4.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.3.4.5 2003/03/27 23:42:37 niklas Exp $	*/
d484 7
a512 10

	/* 
	 * Turn interrupts off, just in case. (Although they shouldn't
	 * be wired to an interrupt controller on sparcs).
	 */
	todr_wenable(handle, 1);
	rtc_write_reg(bt, cwi.cwi_bh, 
		MC_REGB, MC_REGB_BINARY | MC_REGB_24HR);
	todr_wenable(handle, 0);

@


1.3.4.7
log
@Merge with the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a897 1
	char *bad = NULL;
d912 3
a914 2
	    (todr_gettime(todr_handle, (struct timeval *)&time) != 0 ||
	    time.tv_sec == 0)) {
a918 1
		bad = "WARNING: bad date in battery clock";
a930 1
#ifndef SMALL_KERNEL
a932 6
		bad = "";
#endif
	}
	if (bad) {
		printf("%s", bad);
		printf(" -- CHECK AND RESET THE DATE!\n");
d934 1
@


1.2
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d465 2
a466 1
rtc_write_reg(bus_space_tag_t bt, bus_space_handle_t bh, int reg, u_int8_t val) {
d468 1
a468 1
	bus_space_write_1(bt, bh, RTC_DATA, reg);
@


1.1
log
@Lot of stuff... Some from NetBSD, some from OpenBSD, minor modifications
@
text
@d1 1
@

