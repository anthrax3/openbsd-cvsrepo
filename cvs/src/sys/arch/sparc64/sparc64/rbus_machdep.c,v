head	1.5;
access;
symbols
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.5.0.24
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.20
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.22
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.14
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.18
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.16
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.12
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.10
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.8
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.6
	OPENBSD_5_0:1.5.0.4
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.4.0.10
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.6
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.8
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.4
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.2
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.2.0.2
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_2:1.1.0.2
	OPENBSD_4_2_BASE:1.1;
locks; strict;
comment	@ * @;


1.5
date	2010.09.22.02.28.37;	author jsg;	state Exp;
branches;
next	1.4;

1.4
date	2008.07.19.10.02.09;	author kettenis;	state Exp;
branches;
next	1.3;

1.3
date	2008.07.18.22.05.29;	author kettenis;	state Exp;
branches;
next	1.2;

1.2
date	2007.11.25.00.38.49;	author kettenis;	state Exp;
branches;
next	1.1;

1.1
date	2007.08.04.16.46.03;	author kettenis;	state Exp;
branches;
next	;


desc
@@


1.5
log
@remove unused offset argument to rbus functions
ok krw@@ kettenis@@
@
text
@/*	$OpenBSD: rbus_machdep.c,v 1.4 2008/07/19 10:02:09 kettenis Exp $	*/

/*
 * Copyright (c) 2007 Mark Kettenis
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/device.h>
#include <sys/systm.h>

#include <machine/bus.h>

#include <dev/cardbus/rbus.h>
#include <dev/ofw/openfirm.h>
#include <dev/ofw/ofw_pci.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pccbbreg.h>

struct rbustag rbus_null;

/*
 * The PROM doesn't really understand PCMCIA/CardBus bridges, and
 * leaves them mostly alone.  However, on the UltraBook machines, it
 * treats the memory and IO window register as ordinary BARs and
 * assigns address space to them.  We re-use that address space for
 * rbus.  This is a bit of a hack, but it seems to work and saves us
 * from tracking down available address space globally.
 */

rbus_tag_t
rbus_pccbb_parent_mem(struct device *self, struct pci_attach_args *pa)
{
	struct ofw_pci_register addr[5];
	int naddr, len, i;
	int space, reg;
	int node = PCITAG_NODE(pa->pa_tag);
	char buf[32];

	/* Check for the UltraBook PCMCIA controller. */
	if (OF_getprop(node, "name", &buf, sizeof(buf)) > 0 &&
	    strcmp(buf, "pcma") == 0) {
		len = OF_getprop(PCITAG_NODE(pa->pa_tag), "assigned-addresses",
		    &addr, sizeof(addr));
		naddr = len / sizeof(struct ofw_pci_register);

		for (i = 0; i < naddr; i++) {
			space = addr[i].phys_hi & OFW_PCI_PHYS_HI_SPACEMASK;
			if (space != OFW_PCI_PHYS_HI_SPACE_MEM32)
				continue;
			reg = addr[i].phys_hi & OFW_PCI_PHYS_HI_REGISTERMASK;
			if (reg < PCI_CB_MEMBASE0 || reg > PCI_CB_IOLIMIT1)
				continue;

			return (rbus_new_root_delegate(pa->pa_memt,
			    addr[i].phys_lo, addr[i].size_lo));
		}
	}

	len = OF_getprop(OF_parent(node), "available", &addr, sizeof(addr));
	naddr = len / sizeof(struct ofw_pci_register);

	for (i = 0; i < naddr; i++) {
		space = addr[i].phys_hi & OFW_PCI_PHYS_HI_SPACEMASK;
		if (space != OFW_PCI_PHYS_HI_SPACE_MEM32)
			continue;
		if (addr[i].size_hi == 0 && addr[i].size_lo < 0x10000000)
			continue;

		return (rbus_new_root_delegate(pa->pa_memt,
		    addr[i].phys_lo, addr[i].size_lo));
	}

	return &rbus_null;
}

rbus_tag_t
rbus_pccbb_parent_io(struct device *self, struct pci_attach_args *pa)
{
	struct ofw_pci_register addr[5];
	int naddr, len, i;
	int space, reg;
	int node = PCITAG_NODE(pa->pa_tag);
	char buf[32];

	/* Check for the UltraBook PCMCIA controller. */
	if (OF_getprop(node, "name", &buf, sizeof(buf)) > 0 &&
	    strcmp(buf, "pcma") == 0) {
		len = OF_getprop(PCITAG_NODE(pa->pa_tag), "assigned-addresses",
		    &addr, sizeof(addr));
		naddr = len / sizeof(struct ofw_pci_register);

		for (i = 0; i < naddr; i++) {
			space = addr[i].phys_hi & OFW_PCI_PHYS_HI_SPACEMASK;
			if (space != OFW_PCI_PHYS_HI_SPACE_IO)
				continue;
			reg = addr[i].phys_hi & OFW_PCI_PHYS_HI_REGISTERMASK;
			if (reg < PCI_CB_MEMBASE0 || reg > PCI_CB_IOLIMIT1)
				continue;

			return (rbus_new_root_delegate(pa->pa_iot,
			    addr[i].phys_lo, addr[i].size_lo));
		}
	}

	len = OF_getprop(OF_parent(node), "available", &addr, sizeof(addr));
	naddr = len / sizeof(struct ofw_pci_register);

	for (i = 0; i < naddr; i++) {
		space = addr[i].phys_hi & OFW_PCI_PHYS_HI_SPACEMASK;
		if (space != OFW_PCI_PHYS_HI_SPACE_IO)
			continue;
		if (addr[i].size_hi == 0 && addr[i].size_lo < 0x00001000)
			continue;

		return (rbus_new_root_delegate(pa->pa_iot,
		    addr[i].phys_lo, addr[i].size_lo));
	}

	return &rbus_null;
}

void
pccbb_attach_hook(struct device *parent, struct device *self,
    struct pci_attach_args *pa)
{
	pci_chipset_tag_t pc = pa->pa_pc;
	int node = PCITAG_NODE(pa->pa_tag);
	int bus, busrange[2];
	pcireg_t bir;

	bir = pci_conf_read(pc, pa->pa_tag, PCI_BUSNUM);
	if (((bir >> 8) & 0xff) != 0)
		return;

	if (OF_getprop(OF_parent(node), "bus-range", &busrange,
	    sizeof(busrange)) != sizeof(busrange))
		return;

	bus = busrange[0] + 1;
	while (bus < 256 && pc->busnode[bus])
		bus++;
	if (bus == 256)
		return;
	pc->busnode[bus] = node;

	bir &= ~0x0000ff00;
	bir |= (bus << 8);
	pci_conf_write(pc, pa->pa_tag, PCI_BUSNUM, bir);
}
@


1.4
log
@Unbreak the tree.  Pointed out by James Hartley.
@
text
@d1 1
a1 1
/*	$OpenBSD: rbus_machdep.c,v 1.3 2008/07/18 22:05:29 kettenis Exp $	*/
d67 1
a67 1
			    addr[i].phys_lo, addr[i].size_lo, 0));
d82 1
a82 1
		    addr[i].phys_lo, addr[i].size_lo, 0));
d113 1
a113 1
			    addr[i].phys_lo, addr[i].size_lo, 0));
d128 1
a128 1
		    addr[i].phys_lo, addr[i].size_lo, 0));
@


1.3
log
@Determine the free address space by looking at the "available" property of
the PCI host bridge if we're not running on an UltraBook.  Fix allocation of
bus number such that it works on machines that have OpenBoot 4.x.
@
text
@d1 1
a1 1
/*	$OpenBSD: rbus_machdep.c,v 1.2 2007/11/25 00:38:49 kettenis Exp $	*/
d51 1
a51 1
	/* Check for the UltraBook PCMCIA controller. *//
d97 1
a97 1
	/* Check for the UltraBook PCMCIA controller. *//
@


1.2
log
@Give the CarBus side of CardBus-PCI bridges a bus number, since OpenFirmware
doesn't do it for us.
@
text
@d1 1
a1 1
/*	$OpenBSD: rbus_machdep.c,v 1.1 2007/08/04 16:46:03 kettenis Exp $	*/
d34 6
a39 5
 * The PROM doesn't really understand CardBus bridges.  So it treats
 * the memory and IO window register as ordinary BARs and assigns
 * address space to them.  We re-use that address space for rbus.
 * This is a bit of a hack, but it seems to work and saves us from
 * tracking down available address space globally.
d48 22
d71 1
a71 2
	len = OF_getprop(PCITAG_NODE(pa->pa_tag), "assigned-addresses",
	    &addr, sizeof(addr));
d78 1
a78 2
		reg = addr[i].phys_hi & OFW_PCI_PHYS_HI_REGISTERMASK;
		if (reg < PCI_CB_MEMBASE0 || reg > PCI_CB_IOLIMIT1)
d94 22
d117 1
a117 2
	len = OF_getprop(PCITAG_NODE(pa->pa_tag), "assigned-addresses",
	    &addr, sizeof(addr));
d124 1
a124 2
		reg = addr[i].phys_hi & OFW_PCI_PHYS_HI_REGISTERMASK;
		if (reg < PCI_CB_MEMBASE0 || reg > PCI_CB_IOLIMIT1)
d151 1
a151 1
	bus = busrange[1] + 1;
@


1.1
log
@rbus for sparc64

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d91 29
@

