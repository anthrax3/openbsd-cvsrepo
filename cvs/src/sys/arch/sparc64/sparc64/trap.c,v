head	1.97;
access;
symbols
	OPENBSD_6_0:1.88.0.2
	OPENBSD_6_0_BASE:1.88
	OPENBSD_5_9:1.87.0.2
	OPENBSD_5_9_BASE:1.87
	OPENBSD_5_8:1.86.0.4
	OPENBSD_5_8_BASE:1.86
	OPENBSD_5_7:1.85.0.2
	OPENBSD_5_7_BASE:1.85
	OPENBSD_5_6:1.84.0.4
	OPENBSD_5_6_BASE:1.84
	OPENBSD_5_5:1.78.0.6
	OPENBSD_5_5_BASE:1.78
	OPENBSD_5_4:1.78.0.2
	OPENBSD_5_4_BASE:1.78
	OPENBSD_5_3:1.77.0.2
	OPENBSD_5_3_BASE:1.77
	OPENBSD_5_2:1.75.0.2
	OPENBSD_5_2_BASE:1.75
	OPENBSD_5_1_BASE:1.74
	OPENBSD_5_1:1.74.0.2
	OPENBSD_5_0:1.73.0.2
	OPENBSD_5_0_BASE:1.73
	OPENBSD_4_9:1.66.0.2
	OPENBSD_4_9_BASE:1.66
	OPENBSD_4_8:1.65.0.2
	OPENBSD_4_8_BASE:1.65
	OPENBSD_4_7:1.64.0.4
	OPENBSD_4_7_BASE:1.64
	OPENBSD_4_6:1.64.0.6
	OPENBSD_4_6_BASE:1.64
	OPENBSD_4_5:1.64.0.2
	OPENBSD_4_5_BASE:1.64
	OPENBSD_4_4:1.63.0.2
	OPENBSD_4_4_BASE:1.63
	OPENBSD_4_3:1.60.0.2
	OPENBSD_4_3_BASE:1.60
	OPENBSD_4_2:1.51.0.2
	OPENBSD_4_2_BASE:1.51
	OPENBSD_4_1:1.46.0.2
	OPENBSD_4_1_BASE:1.46
	OPENBSD_4_0:1.43.0.2
	OPENBSD_4_0_BASE:1.43
	OPENBSD_3_9:1.40.0.2
	OPENBSD_3_9_BASE:1.40
	OPENBSD_3_8:1.35.0.2
	OPENBSD_3_8_BASE:1.35
	OPENBSD_3_7:1.33.0.2
	OPENBSD_3_7_BASE:1.33
	OPENBSD_3_6:1.32.0.2
	OPENBSD_3_6_BASE:1.32
	SMP_SYNC_A:1.31
	SMP_SYNC_B:1.31
	OPENBSD_3_5:1.31.0.2
	OPENBSD_3_5_BASE:1.31
	OPENBSD_3_4:1.30.0.2
	OPENBSD_3_4_BASE:1.30
	UBC_SYNC_A:1.24
	OPENBSD_3_3:1.24.0.2
	OPENBSD_3_3_BASE:1.24
	OPENBSD_3_2:1.22.0.2
	OPENBSD_3_2_BASE:1.22
	OPENBSD_3_1:1.18.0.2
	OPENBSD_3_1_BASE:1.18
	UBC_SYNC_B:1.23
	UBC:1.14.0.2
	UBC_BASE:1.14
	SMP:1.11.0.4
	OPENBSD_3_0:1.11.0.2
	OPENBSD_3_0_BASE:1.11;
locks; strict;
comment	@ * @;


1.97
date	2017.01.21.05.42.04;	author guenther;	state Exp;
branches;
next	1.96;
commitid	CHRb0fCqa8XxUAMH;

1.96
date	2016.12.20.13.47.38;	author jsg;	state Exp;
branches;
next	1.95;
commitid	lEoNDofM93YyLOXX;

1.95
date	2016.10.18.00.43.57;	author guenther;	state Exp;
branches;
next	1.94;
commitid	ViMtDmKg8K8fZjQi;

1.94
date	2016.10.08.05.49.09;	author guenther;	state Exp;
branches;
next	1.93;
commitid	z63v1DilayzHcfkw;

1.93
date	2016.09.12.15.04.15;	author tedu;	state Exp;
branches;
next	1.92;
commitid	vWAdKtETOGwz5jO8;

1.92
date	2016.09.11.03.14.04;	author guenther;	state Exp;
branches;
next	1.91;
commitid	CTJERhMeok0roRjS;

1.91
date	2016.09.10.19.33.38;	author guenther;	state Exp;
branches;
next	1.90;
commitid	UswMS3S919Tu8Ftw;

1.90
date	2016.09.10.18.31.15;	author guenther;	state Exp;
branches;
next	1.89;
commitid	qaYPymHgg6XnsBgW;

1.89
date	2016.09.10.18.02.15;	author guenther;	state Exp;
branches;
next	1.88;
commitid	31xHEcoKFly6mHlz;

1.88
date	2016.02.27.13.08.07;	author mpi;	state Exp;
branches;
next	1.87;
commitid	hnv9KfQtxhCytAnd;

1.87
date	2015.11.06.06.33.26;	author guenther;	state Exp;
branches;
next	1.86;
commitid	wzHEHv1WzrJZbX9A;

1.86
date	2015.06.05.16.07.24;	author kettenis;	state Exp;
branches;
next	1.85;
commitid	175jxV8DqPXO0EIN;

1.85
date	2014.11.16.12.30.59;	author deraadt;	state Exp;
branches;
next	1.84;
commitid	yv0ECmCdICvq576h;

1.84
date	2014.05.11.00.12.44;	author guenther;	state Exp;
branches;
next	1.83;

1.83
date	2014.05.10.12.29.58;	author kettenis;	state Exp;
branches;
next	1.82;

1.82
date	2014.05.10.05.33.00;	author guenther;	state Exp;
branches;
next	1.81;

1.81
date	2014.04.18.11.51.17;	author guenther;	state Exp;
branches;
next	1.80;

1.80
date	2014.03.30.21.54.49;	author guenther;	state Exp;
branches;
next	1.79;

1.79
date	2014.03.26.05.23.42;	author guenther;	state Exp;
branches;
next	1.78;

1.78
date	2013.04.02.13.24.57;	author kettenis;	state Exp;
branches;
next	1.77;

1.77
date	2012.12.31.06.46.14;	author guenther;	state Exp;
branches;
next	1.76;

1.76
date	2012.08.07.05.16.54;	author guenther;	state Exp;
branches;
next	1.75;

1.75
date	2012.04.11.14.38.55;	author mikeb;	state Exp;
branches;
next	1.74;

1.74
date	2011.11.16.20.50.19;	author deraadt;	state Exp;
branches;
next	1.73;

1.73
date	2011.07.11.15.40.47;	author guenther;	state Exp;
branches;
next	1.72;

1.72
date	2011.07.07.18.11.24;	author art;	state Exp;
branches;
next	1.71;

1.71
date	2011.07.06.22.26.44;	author kettenis;	state Exp;
branches;
next	1.70;

1.70
date	2011.07.06.21.41.37;	author art;	state Exp;
branches;
next	1.69;

1.69
date	2011.07.04.22.53.53;	author tedu;	state Exp;
branches;
next	1.68;

1.68
date	2011.06.06.13.19.29;	author kettenis;	state Exp;
branches;
next	1.67;

1.67
date	2011.04.03.14.56.28;	author guenther;	state Exp;
branches;
next	1.66;

1.66
date	2010.11.27.19.41.48;	author miod;	state Exp;
branches;
next	1.65;

1.65
date	2010.08.07.00.13.09;	author krw;	state Exp;
branches;
next	1.64;

1.64
date	2009.01.20.21.22.31;	author kettenis;	state Exp;
branches;
next	1.63;

1.63
date	2008.07.12.08.08.54;	author kettenis;	state Exp;
branches;
next	1.62;

1.62
date	2008.04.07.16.21.26;	author thib;	state Exp;
branches;
next	1.61;

1.61
date	2008.03.26.22.07.23;	author kettenis;	state Exp;
branches;
next	1.60;

1.60
date	2008.01.16.20.55.36;	author kettenis;	state Exp;
branches;
next	1.59;

1.59
date	2007.12.26.17.40.59;	author miod;	state Exp;
branches;
next	1.58;

1.58
date	2007.11.18.21.16.44;	author kettenis;	state Exp;
branches;
next	1.57;

1.57
date	2007.10.31.22.46.52;	author kettenis;	state Exp;
branches;
next	1.56;

1.56
date	2007.10.16.19.22.49;	author kettenis;	state Exp;
branches;
next	1.55;

1.55
date	2007.10.15.09.24.31;	author fgsch;	state Exp;
branches;
next	1.54;

1.54
date	2007.09.22.20.04.51;	author kettenis;	state Exp;
branches;
next	1.53;

1.53
date	2007.09.08.17.13.18;	author kettenis;	state Exp;
branches;
next	1.52;

1.52
date	2007.09.04.20.36.52;	author kettenis;	state Exp;
branches;
next	1.51;

1.51
date	2007.07.05.22.16.30;	author kettenis;	state Exp;
branches;
next	1.50;

1.50
date	2007.05.14.21.38.08;	author kettenis;	state Exp;
branches;
next	1.49;

1.49
date	2007.05.02.18.46.07;	author kettenis;	state Exp;
branches;
next	1.48;

1.48
date	2007.04.24.18.14.15;	author deraadt;	state Exp;
branches;
next	1.47;

1.47
date	2007.03.15.10.22.30;	author art;	state Exp;
branches;
next	1.46;

1.46
date	2007.02.27.22.46.32;	author deraadt;	state Exp;
branches;
next	1.45;

1.45
date	2006.12.24.20.30.35;	author miod;	state Exp;
branches;
next	1.44;

1.44
date	2006.12.24.20.29.19;	author miod;	state Exp;
branches;
next	1.43;

1.43
date	2006.07.01.16.24.17;	author miod;	state Exp;
branches;
next	1.42;

1.42
date	2006.06.26.22.18.06;	author miod;	state Exp;
branches;
next	1.41;

1.41
date	2006.05.15.21.56.54;	author kettenis;	state Exp;
branches;
next	1.40;

1.40
date	2006.02.05.19.53.34;	author kettenis;	state Exp;
branches;
next	1.39;

1.39
date	2006.01.30.21.26.19;	author miod;	state Exp;
branches;
next	1.38;

1.38
date	2005.12.30.21.14.16;	author millert;	state Exp;
branches;
next	1.37;

1.37
date	2005.12.25.00.22.47;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2005.09.15.21.09.30;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2005.04.21.04.39.35;	author mickey;	state Exp;
branches;
next	1.34;

1.34
date	2005.03.29.19.34.07;	author kettenis;	state Exp;
branches;
next	1.33;

1.33
date	2004.12.06.20.12.25;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2004.08.09.10.13.23;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2004.01.10.09.10.07;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2003.07.14.02.03.16;	author jason;	state Exp;
branches;
next	1.29;

1.29
date	2003.07.10.19.33.19;	author jason;	state Exp;
branches;
next	1.28;

1.28
date	2003.07.10.19.23.16;	author jason;	state Exp;
branches;
next	1.27;

1.27
date	2003.07.10.15.26.54;	author jason;	state Exp;
branches;
next	1.26;

1.26
date	2003.07.09.23.56.16;	author jason;	state Exp;
branches;
next	1.25;

1.25
date	2003.07.09.15.52.53;	author jason;	state Exp;
branches;
next	1.24;

1.24
date	2003.02.17.01.29.20;	author henric;	state Exp;
branches;
next	1.23;

1.23
date	2002.10.12.01.09.43;	author krw;	state Exp;
branches;
next	1.22;

1.22
date	2002.07.24.00.48.25;	author art;	state Exp;
branches;
next	1.21;

1.21
date	2002.06.23.03.03.15;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2002.06.15.17.23.31;	author art;	state Exp;
branches;
next	1.19;

1.19
date	2002.05.16.21.11.18;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2002.03.26.01.00.30;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2002.03.14.01.26.45;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2002.02.22.19.25.17;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2002.01.23.15.19.10;	author jason;	state Exp;
branches;
next	1.14;

1.14
date	2001.11.28.13.47.39;	author art;	state Exp;
branches
	1.14.2.1;
next	1.13;

1.13
date	2001.11.06.19.53.16;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2001.11.06.19.25.56;	author art;	state Exp;
branches;
next	1.11;

1.11
date	2001.09.28.14.43.13;	author art;	state Exp;
branches
	1.11.4.1;
next	1.10;

1.10
date	2001.09.28.13.02.46;	author art;	state Exp;
branches;
next	1.9;

1.9
date	2001.09.20.21.29.26;	author jason;	state Exp;
branches;
next	1.8;

1.8
date	2001.09.19.20.50.58;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	2001.08.31.06.37.19;	author art;	state Exp;
branches;
next	1.6;

1.6
date	2001.08.25.21.04.38;	author art;	state Exp;
branches;
next	1.5;

1.5
date	2001.08.25.12.27.30;	author art;	state Exp;
branches;
next	1.4;

1.4
date	2001.08.23.17.40.05;	author art;	state Exp;
branches;
next	1.3;

1.3
date	2001.08.20.20.23.53;	author jason;	state Exp;
branches;
next	1.2;

1.2
date	2001.08.19.17.41.59;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2001.08.19.05.21.38;	author jason;	state Exp;
branches;
next	;

1.11.4.1
date	2001.10.31.03.07.59;	author nate;	state Exp;
branches;
next	1.11.4.2;

1.11.4.2
date	2001.11.13.21.04.17;	author niklas;	state Exp;
branches;
next	1.11.4.3;

1.11.4.3
date	2001.12.05.00.39.13;	author niklas;	state Exp;
branches;
next	1.11.4.4;

1.11.4.4
date	2002.03.06.02.04.47;	author niklas;	state Exp;
branches;
next	1.11.4.5;

1.11.4.5
date	2002.03.28.11.23.52;	author niklas;	state Exp;
branches;
next	1.11.4.6;

1.11.4.6
date	2003.03.27.23.42.37;	author niklas;	state Exp;
branches;
next	1.11.4.7;

1.11.4.7
date	2004.02.19.10.50.01;	author niklas;	state Exp;
branches;
next	;

1.14.2.1
date	2002.01.31.22.55.25;	author niklas;	state Exp;
branches;
next	1.14.2.2;

1.14.2.2
date	2002.06.11.03.38.44;	author art;	state Exp;
branches;
next	1.14.2.3;

1.14.2.3
date	2002.10.29.00.28.12;	author art;	state Exp;
branches;
next	1.14.2.4;

1.14.2.4
date	2003.05.19.21.46.58;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.97
log
@p_comm is the process's command and isn't per thread, so move it from
struct proc to struct process.

ok deraadt@@ kettenis@@
@
text
@/*	$OpenBSD: trap.c,v 1.96 2016/12/20 13:47:38 jsg Exp $	*/
/*	$NetBSD: trap.c,v 1.73 2001/08/09 01:03:01 eeh Exp $ */

/*
 * Copyright (c) 1996
 *	The President and Fellows of Harvard College. All rights reserved.
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
 *
 * All advertising materials mentioning features or use of this software
 * must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Lawrence Berkeley Laboratory.
 *	This product includes software developed by Harvard University.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 *	This product includes software developed by Harvard University.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)trap.c	8.4 (Berkeley) 9/23/93
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/signalvar.h>
#include <sys/user.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/resource.h>
#include <sys/signal.h>
#include <sys/wait.h>
#include <sys/syscall.h>
#include <sys/syscall_mi.h>
#include <sys/syslog.h>

#include <uvm/uvm_extern.h>

#include <machine/cpu.h>
#include <machine/ctlreg.h>
#include <machine/trap.h>
#include <machine/instr.h>
#include <machine/pmap.h>

#ifdef DDB
#include <machine/db_machdep.h>
#else
#include <machine/frame.h>
#endif

#include <sparc64/fpu/fpu_extern.h>
#include <sparc64/sparc64/cache.h>

#ifndef offsetof
#define	offsetof(s, f) ((int)&((s *)0)->f)
#endif

/* trapstats */
int trapstats = 0;
int protfix = 0;
int udmiss = 0;	/* Number of normal/nucleus data/text miss/protection faults */
int udhit = 0;
int udprot = 0;
int utmiss = 0;
int kdmiss = 0;
int kdhit = 0;
int kdprot = 0;
int ktmiss = 0;
int iveccnt = 0; /* number if normal/nucleus interrupt/interrupt vector faults */
int uintrcnt = 0;
int kiveccnt = 0;
int kintrcnt = 0;
int intristk = 0; /* interrupts when already on intrstack */
int intrpoll = 0; /* interrupts not using vector lists */
int wfill = 0;
int kwfill = 0;
int wspill = 0;
int wspillskip = 0;
int rftucnt = 0;
int rftuld = 0;
int rftudone = 0;
int rftkcnt[5] = { 0, 0, 0, 0, 0 };

/*
 * Initial FPU state is all registers == all 1s, everything else == all 0s.
 * This makes every floating point register a signalling NaN, with sign bit
 * set, no matter how it is interpreted.  Appendix N of the Sparc V8 document
 * seems to imply that we should do this, and it does make sense.
 */
__asm(".align 64");
struct	fpstate64 initfpstate = {
	{ ~0, ~0, ~0, ~0, ~0, ~0, ~0, ~0, ~0, ~0, ~0, ~0, ~0, ~0, ~0, ~0,
	  ~0, ~0, ~0, ~0, ~0, ~0, ~0, ~0, ~0, ~0, ~0, ~0, ~0, ~0, ~0, ~0 }
};

/*
 * There are more than 100 trap types, but most are unused.
 *
 * Trap type 0 is taken over as an `Asynchronous System Trap'.
 * This is left-over Vax emulation crap that should be fixed.
 *
 * Traps not supported on the spitfire are marked with `*',
 * and additions are marked with `+'
 */
static const char T[] = "*trap";
const char *trap_type[] = {
	/* non-user vectors */
	"ast",			/* 0 */
	"power on reset",	/* 1 */
	"watchdog reset",	/* 2 */
	"externally initiated reset",/*3 */
	"software initiated reset",/* 4 */
	"RED state exception",	/* 5 */
	T, T,			/* 6..7 */
	"instruction access exception",	/* 8 */
	"*instruction MMU miss",/* 9 */
	"instruction access error",/* 0a */
	T, T, T, T, T,		/* 0b..0f */
	"illegal instruction",	/* 10 */
	"privileged opcode",	/* 11 */
	"*unimplemented LDD",	/* 12 */
	"*unimplemented STD",	/* 13 */
	T, T, T, T,		/* 14..17 */
	T, T, T, T, T, T, T, T, /* 18..1f */
	"fp disabled",		/* 20 */
	"fp exception ieee 754",/* 21 */
	"fp exception other",	/* 22 */
	"tag overflow",		/* 23 */
	"clean window",		/* 24 */
	T, T, T,		/* 25..27 -- trap continues */
	"division by zero",	/* 28 */
	"*internal processor error",/* 29 */
	T, T, T, T, T, T,	/* 2a..2f */
	"data access exception",/* 30 */
	"*data access MMU miss",/* 31 */
	"data access error",	/* 32 */
	"*data access protection",/* 33 */
	"mem address not aligned",	/* 34 */
	"LDDF mem address not aligned",/* 35 */
	"STDF mem address not aligned",/* 36 */
	"privileged action",	/* 37 */
	"LDQF mem address not aligned",/* 38 */
	"STQF mem address not aligned",/* 39 */
	T, T, T, T, T, T,	/* 3a..3f */
	"*async data error",	/* 40 */
	"level 1 int",		/* 41 */
	"level 2 int",		/* 42 */
	"level 3 int",		/* 43 */
	"level 4 int",		/* 44 */
	"level 5 int",		/* 45 */
	"level 6 int",		/* 46 */
	"level 7 int",		/* 47 */
	"level 8 int",		/* 48 */
	"level 9 int",		/* 49 */
	"level 10 int",		/* 4a */
	"level 11 int",		/* 4b */
	"level 12 int",		/* 4c */
	"level 13 int",		/* 4d */
	"level 14 int",		/* 4e */
	"level 15 int",		/* 4f */
	T, T, T, T, T, T, T, T, /* 50..57 */
	T, T, T, T, T, T, T, T, /* 58..5f */
	"+interrupt vector",	/* 60 */
	"+PA_watchpoint",	/* 61 */
	"+VA_watchpoint",	/* 62 */
	"+corrected ECC error",	/* 63 */
	"+fast instruction access MMU miss",/* 64 */
	T, T, T,		/* 65..67 -- trap continues */
	"+fast data access MMU miss",/* 68 */
	T, T, T,		/* 69..6b -- trap continues */
	"+fast data access protection",/* 6c */
	T, T, T,		/* 6d..6f -- trap continues */
	T, T, T, T, T, T, T, T, /* 70..77 */
	T, T, T, T, T, T, T, T, /* 78..7f */
	"spill 0 normal",	/* 80 */
	T, T, T,		/* 81..83 -- trap continues */
	"spill 1 normal",	/* 84 */
	T, T, T,		/* 85..87 -- trap continues */
	"spill 2 normal",	/* 88 */
	T, T, T,		/* 89..8b -- trap continues */
	"spill 3 normal",	/* 8c */
	T, T, T,		/* 8d..8f -- trap continues */
	"spill 4 normal",	/* 90 */
	T, T, T,		/* 91..93 -- trap continues */
	"spill 5 normal",	/* 94 */
	T, T, T,		/* 95..97 -- trap continues */
	"spill 6 normal",	/* 98 */
	T, T, T,		/* 99..9b -- trap continues */
	"spill 7 normal",	/* 9c */
	T, T, T,		/* 9c..9f -- trap continues */
	"spill 0 other",	/* a0 */
	T, T, T,		/* a1..a3 -- trap continues */
	"spill 1 other",	/* a4 */
	T, T, T,		/* a5..a7 -- trap continues */
	"spill 2 other",	/* a8 */
	T, T, T,		/* a9..ab -- trap continues */
	"spill 3 other",	/* ac */
	T, T, T,		/* ad..af -- trap continues */
	"spill 4 other",	/* b0 */
	T, T, T,		/* b1..b3 -- trap continues */
	"spill 5 other",	/* b4 */
	T, T, T,		/* b5..b7 -- trap continues */
	"spill 6 other",	/* b8 */
	T, T, T,		/* b9..bb -- trap continues */
	"spill 7 other",	/* bc */
	T, T, T,		/* bc..bf -- trap continues */
	"fill 0 normal",	/* c0 */
	T, T, T,		/* c1..c3 -- trap continues */
	"fill 1 normal",	/* c4 */
	T, T, T,		/* c5..c7 -- trap continues */
	"fill 2 normal",	/* c8 */
	T, T, T,		/* c9..cb -- trap continues */
	"fill 3 normal",	/* cc */
	T, T, T,		/* cd..cf -- trap continues */
	"fill 4 normal",	/* d0 */
	T, T, T,		/* d1..d3 -- trap continues */
	"fill 5 normal",	/* d4 */
	T, T, T,		/* d5..d7 -- trap continues */
	"fill 6 normal",	/* d8 */
	T, T, T,		/* d9..db -- trap continues */
	"fill 7 normal",	/* dc */
	T, T, T,		/* dc..df -- trap continues */
	"fill 0 other",		/* e0 */
	T, T, T,		/* e1..e3 -- trap continues */
	"fill 1 other",		/* e4 */
	T, T, T,		/* e5..e7 -- trap continues */
	"fill 2 other",		/* e8 */
	T, T, T,		/* e9..eb -- trap continues */
	"fill 3 other",		/* ec */
	T, T, T,		/* ed..ef -- trap continues */
	"fill 4 other",		/* f0 */
	T, T, T,		/* f1..f3 -- trap continues */
	"fill 5 other",		/* f4 */
	T, T, T,		/* f5..f7 -- trap continues */
	"fill 6 other",		/* f8 */
	T, T, T,		/* f9..fb -- trap continues */
	"fill 7 other",		/* fc */
	T, T, T,		/* fc..ff -- trap continues */

	/* user (software trap) vectors */
	"syscall",		/* 100 */
	"breakpoint",		/* 101 */
	"zero divide",		/* 102 */
	"flush windows",	/* 103 */
	"clean windows",	/* 104 */
	"range check",		/* 105 */
	"fix align",		/* 106 */
	"integer overflow",	/* 107 */
	"svr4 syscall",		/* 108 */
	"4.4 syscall",		/* 109 */
	"kgdb exec",		/* 10a */
	T, T, T, T, T,		/* 10b..10f */
	T, T, T, T, T, T, T, T,	/* 11a..117 */
	T, T, T, T, T, T, T, T,	/* 118..11f */
	"svr4 getcc",		/* 120 */
	"svr4 setcc",		/* 121 */
	"svr4 getpsr",		/* 122 */
	"svr4 setpsr",		/* 123 */
	"svr4 gethrtime",	/* 124 */
	"svr4 gethrvtime",	/* 125 */
	T,			/* 126 */
	"svr4 gethrestime",	/* 127 */
	T, T, T, T, T, T, T, T, /* 128..12f */
	T, T,			/* 130..131 */
	"get condition codes",	/* 132 */
	"set condition codes",	/* 133 */
	T, T, T, T,		/* 134..137 */
	T, T, T, T, T, T, T, T, /* 138..13f */
	T, T, T, T, T, T, T, T, /* 140..147 */
	T, T, T, T, T, T, T, T, /* 148..14f */
	T, T, T, T, T, T, T, T, /* 150..157 */
	T, T, T, T, T, T, T, T, /* 158..15f */
	T, T, T, T,		/* 160..163 */
	"SVID syscall64",	/* 164 */
	"SPARC Intl syscall64",	/* 165 */
	"OS vendor spec syscall",	/* 166 */
	"HW OEM syscall",	/* 167 */
	"ret from deferred trap",	/* 168 */
};

#define	N_TRAP_TYPES	(sizeof trap_type / sizeof *trap_type)

static inline void share_fpu(struct proc *, struct trapframe64 *);

void trap(struct trapframe64 *tf, unsigned type, vaddr_t pc, long tstate);
void data_access_fault(struct trapframe64 *tf, unsigned type, vaddr_t pc,
	vaddr_t va, vaddr_t sfva, u_long sfsr);
void data_access_error(struct trapframe64 *tf, unsigned type,
	vaddr_t afva, u_long afsr, vaddr_t sfva, u_long sfsr);
void text_access_fault(struct trapframe64 *tf, unsigned type,
	vaddr_t pc, u_long sfsr);
void text_access_error(struct trapframe64 *tf, unsigned type,
	vaddr_t pc, u_long sfsr, vaddr_t afva, u_long afsr);
void syscall(struct trapframe64 *, register_t code, register_t pc);

/*
 * If someone stole the FPU while we were away, do not enable it
 * on return.  This is not done in userret() above as it must follow
 * the ktrsysret() in syscall().  Actually, it is likely that the
 * ktrsysret should occur before the call to userret.
 *
 * Oh, and don't touch the FPU bit if we're returning to the kernel.
 */
static inline void
share_fpu(struct proc *p, struct trapframe64 *tf)
{
	if (!(tf->tf_tstate & TSTATE_PRIV) &&
	    (tf->tf_tstate & TSTATE_PEF) && fpproc != p)
		tf->tf_tstate &= ~TSTATE_PEF;
}

/*
 * Called from locore.s trap handling, for non-MMU-related traps.
 * (MMU-related traps go through mem_access_fault, below.)
 */
void
trap(struct trapframe64 *tf, unsigned type, vaddr_t pc, long tstate)
{
	struct proc *p;
	struct pcb *pcb;
	int pstate = (tstate>>TSTATE_PSTATE_SHIFT);
	u_int64_t s;
	int64_t n;
	union sigval sv;

	sv.sival_ptr = (void *)pc;

	/* This steps the PC over the trap. */
#define	ADVANCE (n = tf->tf_npc, tf->tf_pc = n, tf->tf_npc = n + 4)

	uvmexp.traps++;
	/*
	 * Generally, kernel traps cause a panic.  Any exceptions are
	 * handled early here.
	 */
	if (pstate & PSTATE_PRIV) {
#ifdef DDB
		if (type == T_BREAKPOINT) {
			write_all_windows();
			if (db_ktrap(type, tf)) {
				/* ADVANCE; */
				return;
			}
		}
		if (type == T_PA_WATCHPT || type == T_VA_WATCHPT) {
			if (db_ktrap(type, tf)) {
				/* DDB must turn off watchpoints or something */
				return;
			}
		}
#endif
		/*
		 * The kernel needs to use FPU registers for block
		 * load/store.  If we trap in priviliged code, save
		 * the FPU state if there is any and enable the FPU.
		 *
		 * We rely on the kernel code properly enabling the FPU
		 * in %fprs, otherwise we'll hang here trying to enable
		 * the FPU.
		 */
		if (type == T_FPDISABLED) {
			struct proc *newfpproc;

			if (CLKF_INTR((struct clockframe *)tf) || !curproc)
				newfpproc = &proc0;
			else {
				newfpproc = curproc;
				/* force other cpus to give up this fpstate */
				if (newfpproc->p_md.md_fpstate)
					fpusave_proc(newfpproc, 1);
			}
			if (fpproc != newfpproc) {
				s = intr_disable();
				if (fpproc != NULL) {
					/* someone else had it, maybe? */
					savefpstate(fpproc->p_md.md_fpstate);
					fpproc = NULL;
				}
				intr_restore(s);

				/* If we have an allocated fpstate, load it */
				if (newfpproc->p_md.md_fpstate != 0) {
					fpproc = newfpproc;
					loadfpstate(fpproc->p_md.md_fpstate);
				} else
					fpproc = NULL;
			}
			/* Enable the FPU */
			tf->tf_tstate |= (PSTATE_PEF<<TSTATE_PSTATE_SHIFT);
			return;
		}
		if (type != T_SPILL_N_NORM && type != T_FILL_N_NORM)
			goto dopanic;
	}
	if ((p = curproc) == NULL)
		p = &proc0;
	pcb = &p->p_addr->u_pcb;
	p->p_md.md_tf = tf;	/* for ptrace/signals */
	refreshcreds(p);

	switch (type) {

	default:
		if (type < 0x100) {
dopanic:
			panic("trap type 0x%x (%s): pc=%lx npc=%lx pstate=%b",
			    type, type < N_TRAP_TYPES ? trap_type[type] : T,
			    pc, (long)tf->tf_npc, pstate, PSTATE_BITS);
			/* NOTREACHED */
		}
		KERNEL_LOCK();
		trapsignal(p, SIGILL, type, ILL_ILLOPC, sv);
		KERNEL_UNLOCK();
		break;

	case T_AST:
		p->p_md.md_astpending = 0;
		uvmexp.softs++;
		mi_ast(p, curcpu()->ci_want_resched);
		break;

	case T_RWRET:
		/*
		 * XXX Flushing the user windows here should not be
		 * necessary, but not doing so here causes corruption
		 * of user windows on sun4v.  Flushing them shouldn't
		 * be much of a performance penalty since we're
		 * probably going to spill any remaining user windows
		 * anyhow.
		 */
		write_user_windows();
		if (rwindow_save(p) == -1) {
			KERNEL_LOCK();
			trapsignal(p, SIGILL, 0, ILL_BADSTK, sv);
			KERNEL_UNLOCK();
		}
		break;

	case T_ILLINST:
	{
		union instr ins;

		if (copyin((caddr_t)pc, &ins, sizeof(ins)) != 0) {
			/* XXX Can this happen? */
			KERNEL_LOCK();
			trapsignal(p, SIGILL, 0, ILL_ILLOPC, sv);
			KERNEL_UNLOCK();
			break;
		}
		if (ins.i_any.i_op == IOP_mem &&
		    (ins.i_op3.i_op3 == IOP3_LDQF ||
		     ins.i_op3.i_op3 == IOP3_STQF ||
		     ins.i_op3.i_op3 == IOP3_LDQFA ||
		     ins.i_op3.i_op3 == IOP3_STQFA)) {
			if (emul_qf(ins.i_int, p, sv, tf))
				ADVANCE;
			break;
		}
		if (ins.i_any.i_op == IOP_reg &&
		    ins.i_op3.i_op3 == IOP3_POPC &&
		    ins.i_op3.i_rs1 == 0) {
			if (emul_popc(ins.i_int, p, sv, tf))
				ADVANCE;
			break;
		}
		KERNEL_LOCK();
		trapsignal(p, SIGILL, 0, ILL_ILLOPC, sv);	/* XXX code? */
		KERNEL_UNLOCK();
		break;
	}

	case T_INST_EXCEPT:
	case T_TEXTFAULT:
	case T_PRIVINST:
	case T_PRIVACT:
		KERNEL_LOCK();
		trapsignal(p, SIGILL, 0, ILL_ILLOPC, sv);	/* XXX code? */
		KERNEL_UNLOCK();
		break;

	case T_FPDISABLED: {
		struct fpstate64 *fs = p->p_md.md_fpstate;

		if (fs == NULL) {
			KERNEL_LOCK();
			/* NOTE: fpstate must be 64-bit aligned */
			fs = malloc((sizeof *fs), M_SUBPROC, M_WAITOK);
			*fs = initfpstate;
			fs->fs_qsize = 0;
			p->p_md.md_fpstate = fs;
			KERNEL_UNLOCK();
		}

		/*
		 * We may have more FPEs stored up and/or ops queued.
		 * If they exist, handle them and get out.  Otherwise,
		 * resolve the FPU state, turn it on, and try again.
		 *
		 * Ultras should never have a FPU queue.
		 */
		if (fs->fs_qsize) {
			printf("trap: Warning fs_qsize is %d\n",fs->fs_qsize);
			fpu_cleanup(p, fs);
			break;
		}
		if (fpproc != p) {		/* we do not have it */
			/* but maybe another CPU has it? */
			fpusave_proc(p, 1);
			s = intr_disable();
			if (fpproc != NULL)	/* someone else had it */
				savefpstate(fpproc->p_md.md_fpstate);
			loadfpstate(fs);
			fpproc = p;		/* now we do have it */
			intr_restore(s);
			uvmexp.fpswtch++;
		}
		tf->tf_tstate |= (PSTATE_PEF<<TSTATE_PSTATE_SHIFT);
		sparc_wr(fprs, FPRS_FEF, 0);
		break;
	}

	case T_LDQF_ALIGN:
	case T_STQF_ALIGN:
	{
		union instr ins;

		if (copyin((caddr_t)pc, &ins, sizeof(ins)) != 0) {
			/* XXX Can this happen? */
			KERNEL_LOCK();
			trapsignal(p, SIGILL, 0, ILL_ILLOPC, sv);
			KERNEL_UNLOCK();
			break;
		}
		if (ins.i_any.i_op == IOP_mem &&
		    (ins.i_op3.i_op3 == IOP3_LDQF ||
		     ins.i_op3.i_op3 == IOP3_STQF ||
		     ins.i_op3.i_op3 == IOP3_LDQFA ||
		     ins.i_op3.i_op3 == IOP3_STQFA)) {
			if (emul_qf(ins.i_int, p, sv, tf))
				ADVANCE;
		} else {
			KERNEL_LOCK();
			trapsignal(p, SIGILL, 0, ILL_ILLOPC, sv);
			KERNEL_UNLOCK();
		}
		break;
	}

	case T_SPILL_N_NORM:
	case T_FILL_N_NORM:
		/*
		 * We got an alignment trap in the spill/fill handler.
		 *
		 * XXX We really should generate a bus error here, but
		 * we could be on the interrupt stack, and dumping
		 * core from the interrupt stack is not a good idea.
		 * It causes random crashes.
		 */
		KERNEL_LOCK();
		sigexit(p, SIGKILL);
		/* NOTREACHED */
		break;

	case T_ALIGN:
	case T_LDDF_ALIGN:
	case T_STDF_ALIGN:
#if 0
	{
		int64_t dsfsr, dsfar=0, isfsr;

		dsfsr = ldxa(SFSR, ASI_DMMU);
		if (dsfsr & SFSR_FV)
			dsfar = ldxa(SFAR, ASI_DMMU);
		isfsr = ldxa(SFSR, ASI_IMMU);
	}
#endif
		/*
		 * If we're busy doing copyin/copyout continue
		 */
		if (p->p_addr->u_pcb.pcb_onfault) {
			tf->tf_pc = (vaddr_t)p->p_addr->u_pcb.pcb_onfault;
			tf->tf_npc = tf->tf_pc + 4;
			break;
		}

		/* XXX sv.sival_ptr should be the fault address! */
		KERNEL_LOCK();
		trapsignal(p, SIGBUS, 0, BUS_ADRALN, sv);	/* XXX code? */
		KERNEL_UNLOCK();
		break;

	case T_FP_IEEE_754:
	case T_FP_OTHER:
		/*
		 * Clean up after a floating point exception.
		 * fpu_cleanup can (and usually does) modify the
		 * state we save here, so we must `give up' the FPU
		 * chip context.  (The software and hardware states
		 * will not match once fpu_cleanup does its job, so
		 * we must not save again later.)
		 */
		if (p != fpproc)
			panic("fpe without being the FP user");
		s = intr_disable();
		savefpstate(p->p_md.md_fpstate);
		fpproc = NULL;
		intr_restore(s);
		/* tf->tf_psr &= ~PSR_EF; */	/* share_fpu will do this */
		if (type == T_FP_OTHER && p->p_md.md_fpstate->fs_qsize == 0) {
			/*
			 * Push the faulting instruction on the queue;
			 * we might need to emulate it.
			 */
			copyin((caddr_t)pc, &p->p_md.md_fpstate->fs_queue[0].fq_instr, sizeof(int));
			p->p_md.md_fpstate->fs_queue[0].fq_addr = (int *)pc;
			p->p_md.md_fpstate->fs_qsize = 1;
		}
		ADVANCE;
		fpu_cleanup(p, p->p_md.md_fpstate);
		/* fpu_cleanup posts signals if needed */
		break;

	case T_TAGOF:
		KERNEL_LOCK();
		trapsignal(p, SIGEMT, 0, EMT_TAGOVF, sv);	/* XXX code? */
		KERNEL_UNLOCK();
		break;

	case T_BREAKPOINT:
		KERNEL_LOCK();
		trapsignal(p, SIGTRAP, 0, TRAP_BRKPT, sv);
		KERNEL_UNLOCK();
		break;

	case T_DIV0:
		ADVANCE;
		KERNEL_LOCK();
		trapsignal(p, SIGFPE, 0, FPE_INTDIV, sv);
		KERNEL_UNLOCK();
		break;

	case T_CLEANWIN:
		uprintf("T_CLEANWIN\n");	/* XXX Should not get this */
		ADVANCE;
		break;

	case T_FLUSHWIN:
		/* Software window flush for v8 software */
		write_all_windows();
		ADVANCE;
		break;

	case T_RANGECHECK:
		ADVANCE;
		KERNEL_LOCK();
		trapsignal(p, SIGILL, 0, ILL_ILLOPN, sv);	/* XXX code? */
		KERNEL_UNLOCK();
		break;

	case T_FIXALIGN:
		uprintf("T_FIXALIGN\n");
		ADVANCE;
		KERNEL_LOCK();
		trapsignal(p, SIGILL, 0, ILL_ILLOPN, sv);	/* XXX code? */
		KERNEL_UNLOCK();
		break;

	case T_INTOF:
		uprintf("T_INTOF\n");		/* XXX */
		ADVANCE;
		KERNEL_LOCK();
		trapsignal(p, SIGFPE, FPE_INTOVF_TRAP, FPE_INTOVF, sv);
		KERNEL_UNLOCK();
		break;
	}
	userret(p);
	share_fpu(p, tf);
#undef ADVANCE
}

/*
 * Save windows from PCB into user stack, and return 0.  This is used on
 * window overflow pseudo-traps (from locore.s, just before returning to
 * user mode) and when ptrace or sendsig needs a consistent state.
 * As a side effect, rwindow_save() always sets pcb_nsaved to 0.
 *
 * If the windows cannot be saved, pcb_nsaved is restored and we return -1.
 */
int
rwindow_save(struct proc *p)
{
	struct pcb *pcb = &p->p_addr->u_pcb;
	int i;

	for (i = 0; i < pcb->pcb_nsaved; i++) {
		pcb->pcb_rw[i].rw_in[7] ^= pcb->pcb_wcookie;
		if (copyout(&pcb->pcb_rw[i], (void *)(pcb->pcb_rwsp[i] + BIAS),
		    sizeof(struct rwindow64)))
			return (-1);
	}

	pcb->pcb_nsaved = 0;
	return (0);
}

/*
 * Kill user windows (before exec) by writing back to stack or pcb
 * and then erasing any pcb tracks.  Otherwise we might try to write
 * the registers into the new process after the exec.
 */
void
pmap_unuse_final(struct proc *p)
{

	write_user_windows();
	p->p_addr->u_pcb.pcb_nsaved = 0;
}

/*
 * This routine handles MMU generated faults.  About half
 * of them could be recoverable through uvm_fault.
 */
void
data_access_fault(struct trapframe64 *tf, unsigned type, vaddr_t pc,
    vaddr_t addr, vaddr_t sfva, u_long sfsr)
{
	u_int64_t tstate;
	struct proc *p;
	struct vmspace *vm;
	vaddr_t va;
	int rv;
	vm_prot_t access_type;
	vaddr_t onfault;
	union sigval sv;

	uvmexp.traps++;
	if ((p = curproc) == NULL)	/* safety check */
		p = &proc0;

	tstate = tf->tf_tstate;

	/* Find the faulting va to give to uvm_fault */
	va = trunc_page(addr);

	/*
	 * Now munch on protections.
	 *
	 * If it was a FAST_DATA_ACCESS_MMU_MISS we have no idea what the
	 * access was since the SFSR is not set.  But we should never get
	 * here from there.
	 */
	if (type == T_FDMMU_MISS || (sfsr & SFSR_FV) == 0) {
		/* Punt */
		access_type = PROT_READ;
	} else {
		access_type = (sfsr & SFSR_W) ? PROT_READ | PROT_WRITE
			: PROT_READ;
	}
	if (tstate & TSTATE_PRIV) {
		KERNEL_LOCK();
#ifdef DDB
		extern char Lfsprobe[];
		/*
		 * If this was an access that we shouldn't try to page in,
		 * resume at the fault handler without any action.
		 */
		if (p->p_addr->u_pcb.pcb_onfault == Lfsprobe)
			goto kfault;
#endif

		/*
		 * During autoconfiguration, faults are never OK unless
		 * pcb_onfault is set.  Once running normally we must allow
		 * exec() to cause copy-on-write faults to kernel addresses.
		 */
		if (cold)
			goto kfault;
		if (!(addr & TLB_TAG_ACCESS_CTX)) {
			/* CTXT == NUCLEUS */
			rv = uvm_fault(kernel_map, va, 0, access_type);
			if (rv == 0) {
				KERNEL_UNLOCK();
				return;
			}
			goto kfault;
		}
	} else {
		KERNEL_LOCK();
		p->p_md.md_tf = tf;
	}

	vm = p->p_vmspace;
	/* alas! must call the horrible vm code */
	onfault = (vaddr_t)p->p_addr->u_pcb.pcb_onfault;
	p->p_addr->u_pcb.pcb_onfault = NULL;
	rv = uvm_fault(&vm->vm_map, (vaddr_t)va, 0, access_type);
	p->p_addr->u_pcb.pcb_onfault = (void *)onfault;

	/*
	 * If this was a stack access we keep track of the maximum
	 * accessed stack size.  Also, if uvm_fault gets a protection
	 * failure it is due to accessing the stack region outside
	 * the current limit and we need to reflect that as an access
	 * error.
	 */
	if ((caddr_t)va >= vm->vm_maxsaddr) {
		if (rv == 0)
			uvm_grow(p, va);
		else if (rv == EACCES)
			rv = EFAULT;
	}
	if (rv != 0) {
		/*
		 * Pagein failed.  If doing copyin/out, return to onfault
		 * address.  Any other page fault in kernel, die; if user
		 * fault, deliver SIGSEGV.
		 */
		if (tstate & TSTATE_PRIV) {
kfault:
			onfault = (long)p->p_addr->u_pcb.pcb_onfault;
			if (!onfault) {
				(void) splhigh();
				panic("kernel data fault: pc=%lx addr=%lx",
				    pc, addr);
				/* NOTREACHED */
			}
			tf->tf_pc = onfault;
			tf->tf_npc = onfault + 4;
			KERNEL_UNLOCK();
			return;
		}

		if (type == T_FDMMU_MISS || (sfsr & SFSR_FV) == 0)
			sv.sival_ptr = (void *)va;
		else
			sv.sival_ptr = (void *)sfva;

		if (rv == ENOMEM) {
			printf("UVM: pid %d (%s), uid %d killed: out of swap\n",
			    p->p_p->ps_pid, p->p_p->ps_comm,
			    p->p_ucred ? (int)p->p_ucred->cr_uid : -1);
			trapsignal(p, SIGKILL, access_type, SEGV_MAPERR, sv);
		} else {
			trapsignal(p, SIGSEGV, access_type, SEGV_MAPERR, sv);
		}
	}

	if ((tstate & TSTATE_PRIV) == 0) {
		KERNEL_UNLOCK();
		userret(p);
		share_fpu(p, tf);
	} else {
		KERNEL_UNLOCK();
	}
}

/*
 * This routine handles deferred errors caused by the memory
 * or I/O bus subsystems.  Most of these are fatal, and even
 * if they are not, recovery is painful.  Also, the TPC and
 * TNPC values are probably not valid if we're not doing a
 * special PEEK/POKE code sequence.
 */
void
data_access_error(struct trapframe64 *tf, unsigned type, vaddr_t afva,
    u_long afsr, vaddr_t sfva, u_long sfsr)
{
	u_long pc;
	u_int64_t tstate;
	struct proc *p;
	vaddr_t onfault;
	union sigval sv;

	uvmexp.traps++;
	if ((p = curproc) == NULL)	/* safety check */
		p = &proc0;

	tstate = tf->tf_tstate;

	/*
	 * Catch PCI config space reads.
	 */
	if (curcpu()->ci_pci_probe) {
		curcpu()->ci_pci_fault = 1;
		goto out;
	}

	pc = tf->tf_pc;

	sv.sival_ptr = (void *)pc;

	onfault = (long)p->p_addr->u_pcb.pcb_onfault;
	printf("data error type %x sfsr=%lx sfva=%lx afsr=%lx afva=%lx tf=%p\n",
		type, sfsr, sfva, afsr, afva, tf);

	if (afsr == 0 && sfsr == 0) {
		printf("data_access_error: no fault\n");
		goto out;	/* No fault. Why were we called? */
	}

	if (tstate & TSTATE_PRIV) {

		if (!onfault) {
			(void) splhigh();
			panic("data fault: pc=%lx addr=%lx sfsr=%lb",
				(u_long)pc, (long)sfva, sfsr, SFSR_BITS);
			/* NOTREACHED */
		}

		/*
		 * If this was a priviliged error but not a probe, we
		 * cannot recover, so panic.
		 */
		if (afsr & ASFR_PRIV) {
			panic("Privileged Async Fault: AFAR %p AFSR %lx\n%lb",
				(void *)afva, afsr, afsr, AFSR_BITS);
			/* NOTREACHED */
		}
		tf->tf_pc = onfault;
		tf->tf_npc = onfault + 4;
		return;
	}

	KERNEL_LOCK();
	trapsignal(p, SIGSEGV, PROT_READ | PROT_WRITE, SEGV_MAPERR, sv);
	KERNEL_UNLOCK();
out:

	if ((tstate & TSTATE_PRIV) == 0) {
		userret(p);
		share_fpu(p, tf);
	}
}

/*
 * This routine handles MMU generated faults.  About half
 * of them could be recoverable through uvm_fault.
 */
void
text_access_fault(struct trapframe64 *tf, unsigned type, vaddr_t pc,
    u_long sfsr)
{
	u_int64_t tstate;
	struct proc *p;
	struct vmspace *vm;
	vaddr_t va;
	int rv;
	vm_prot_t access_type;
	union sigval sv;

	sv.sival_ptr = (void *)pc;

	uvmexp.traps++;
	if ((p = curproc) == NULL)	/* safety check */
		panic("text_access_fault: no curproc");

	tstate = tf->tf_tstate;

	va = trunc_page(pc);

	/* Now munch on protections... */

	access_type = PROT_EXEC;
	if (tstate & TSTATE_PRIV) {
		(void) splhigh();
		panic("kernel text_access_fault: pc=%lx va=%lx", pc, va);
		/* NOTREACHED */
	} else
		p->p_md.md_tf = tf;

	KERNEL_LOCK();

	vm = p->p_vmspace;
	/* alas! must call the horrible vm code */
	rv = uvm_fault(&vm->vm_map, va, 0, access_type);

	/*
	 * If this was a stack access we keep track of the maximum
	 * accessed stack size.  Also, if uvm_fault gets a protection
	 * failure it is due to accessing the stack region outside
	 * the current limit and we need to reflect that as an access
	 * error.
	 */
	if ((caddr_t)va >= vm->vm_maxsaddr) {
		if (rv == 0)
			uvm_grow(p, va);
		else if (rv == EACCES)
			rv = EFAULT;
	}
	if (rv != 0) {
		/*
		 * Pagein failed. Any other page fault in kernel, die; if user
		 * fault, deliver SIGSEGV.
		 */
		if (tstate & TSTATE_PRIV) {
			(void) splhigh();
			panic("kernel text fault: pc=%llx", (unsigned long long)pc);
			/* NOTREACHED */
		}
		trapsignal(p, SIGSEGV, access_type, SEGV_MAPERR, sv);
	}

	KERNEL_UNLOCK();

	if ((tstate & TSTATE_PRIV) == 0) {
		userret(p);
		share_fpu(p, tf);
	}
}


/*
 * This routine handles deferred errors caused by the memory
 * or I/O bus subsystems.  Most of these are fatal, and even
 * if they are not, recovery is painful.  Also, the TPC and
 * TNPC values are probably not valid if we're not doing a
 * special PEEK/POKE code sequence.
 */
void
text_access_error(struct trapframe64 *tf, unsigned type, vaddr_t pc,
    u_long sfsr, vaddr_t afva, u_long afsr)
{
	int64_t tstate;
	struct proc *p;
	struct vmspace *vm;
	vaddr_t va;
	int rv;
	vm_prot_t access_type;
	union sigval sv;

	sv.sival_ptr = (void *)pc;
	uvmexp.traps++;
	if ((p = curproc) == NULL)	/* safety check */
		p = &proc0;

	tstate = tf->tf_tstate;

	if ((afsr) != 0) {
		printf("text_access_error: memory error...\n");
		printf("text memory error type %d sfsr=%lx sfva=%lx afsr=%lx afva=%lx tf=%p\n",
		       type, sfsr, pc, afsr, afva, tf);

		if (tstate & TSTATE_PRIV)
			panic("text_access_error: kernel memory error");

		/* User fault -- Berr */
		KERNEL_LOCK();
		trapsignal(p, SIGBUS, 0, BUS_ADRALN, sv);
		KERNEL_UNLOCK();
	}

	if ((sfsr & SFSR_FV) == 0 || (sfsr & SFSR_FT) == 0)
		goto out;	/* No fault. Why were we called? */

	va = trunc_page(pc);

	/* Now munch on protections... */
	access_type = PROT_EXEC;
	if (tstate & TSTATE_PRIV) {
		(void) splhigh();
		panic("kernel text error: pc=%lx sfsr=%lb", pc,
		    sfsr, SFSR_BITS);
		/* NOTREACHED */
	} else
		p->p_md.md_tf = tf;

	KERNEL_LOCK();

	vm = p->p_vmspace;
	/* alas! must call the horrible vm code */
	rv = uvm_fault(&vm->vm_map, va, 0, access_type);

	/*
	 * If this was a stack access we keep track of the maximum
	 * accessed stack size.  Also, if uvm_fault gets a protection
	 * failure it is due to accessing the stack region outside
	 * the current limit and we need to reflect that as an access
	 * error.
	 */
	if ((caddr_t)va >= vm->vm_maxsaddr) {
		if (rv == 0)
			uvm_grow(p, va);
		else if (rv == EACCES)
			rv = EFAULT;
	}
	if (rv != 0) {
		/*
		 * Pagein failed.  If doing copyin/out, return to onfault
		 * address.  Any other page fault in kernel, die; if user
		 * fault, deliver SIGSEGV.
		 */
		if (tstate & TSTATE_PRIV) {
			(void) splhigh();
			panic("kernel text error: pc=%lx sfsr=%lb", pc,
			    sfsr, SFSR_BITS);
			/* NOTREACHED */
		}
		trapsignal(p, SIGSEGV, access_type, SEGV_MAPERR, sv);
	}

	KERNEL_UNLOCK();

out:
	if ((tstate & TSTATE_PRIV) == 0) {
		userret(p);
		share_fpu(p, tf);
	}
}

/*
 * System calls.  `pc' is just a copy of tf->tf_pc.
 *
 * Note that the things labelled `out' registers in the trapframe were the
 * `in' registers within the syscall trap code (because of the automatic
 * `save' effect of each trap).  They are, however, the %o registers of the
 * thing that made the system call, and are named that way here.
 */
void
syscall(struct trapframe64 *tf, register_t code, register_t pc)
{
	int i, nsys, nap;
	int64_t *ap;
	const struct sysent *callp;
	struct proc *p = curproc;
	int error, new;
	register_t args[8];
	register_t rval[2];

	if ((tf->tf_out[6] & 1) == 0)
		sigexit(p, SIGILL);

	uvmexp.syscalls++;
#ifdef DIAGNOSTIC
	if (tf->tf_tstate & TSTATE_PRIV)
		panic("syscall from kernel");
	if (curpcb != &p->p_addr->u_pcb)
		panic("syscall: cpcb/ppcb mismatch");
	if (tf != (struct trapframe64 *)((caddr_t)curpcb + USPACE) - 1)
		panic("syscall: trapframe");
#endif
	p->p_md.md_tf = tf;
	new = code & SYSCALL_G2RFLAG;
	code &= ~SYSCALL_G2RFLAG;

	callp = p->p_p->ps_emul->e_sysent;
	nsys = p->p_p->ps_emul->e_nsysent;

	/*
	 * The first six system call arguments are in the six %o registers.
	 * Any arguments beyond that are in the `argument extension' area
	 * of the user's stack frame (see <machine/frame.h>).
	 *
	 * Check for ``special'' codes that alter this, namely syscall and
	 * __syscall.  These both pass a syscall number in the first argument
	 * register, so the other arguments are just shifted down, possibly
	 * pushing one off the end into the extension area.  This happens
	 * with mmap() and mquery() used via __syscall().
	 */
	ap = &tf->tf_out[0];
	nap = 6;

	switch (code) {
	case SYS_syscall:
	case SYS___syscall:
		code = *ap++;
		nap--;
		break;
	}

	if (code < 0 || code >= nsys)
		callp += p->p_p->ps_emul->e_nosys;
	else {
		register_t *argp;

		callp += code;
		i = callp->sy_narg; /* Why divide? */
		if (i > nap) {	/* usually false */
			if (i > 8)
				panic("syscall nargs");
			/* Read the whole block in */
			if ((error = copyin((caddr_t)tf->tf_out[6]
			    + BIAS + offsetof(struct frame64, fr_argx),
			    &args[nap], (i - nap) * sizeof(register_t))))
				goto bad;
			i = nap;
		}
		/*
		 * It should be faster to do <= 6 longword copies than
		 * to call bcopy
		 */
		for (argp = args; i--;)
			*argp++ = *ap++;
	}

	rval[0] = 0;
	rval[1] = tf->tf_out[1];

	error = mi_syscall(p, code, callp, args, rval);

	switch (error) {
		vaddr_t dest;
	case 0:
		/* Note: fork() does not return here in the child */
		tf->tf_out[0] = rval[0];
		tf->tf_out[1] = rval[1];
		if (new) {
			/* jmp %g2 on success */
			dest = tf->tf_global[2];
			if (dest & 3) {
				error = EINVAL;
				goto bad;
			}
		} else {
			/* old system call convention: clear C on success */
			tf->tf_tstate &= ~(((int64_t)(ICC_C|XCC_C))<<TSTATE_CCR_SHIFT);	/* success */
			dest = tf->tf_npc;
		}
		tf->tf_pc = dest;
		tf->tf_npc = dest + 4;
		break;

	case ERESTART:
	case EJUSTRETURN:
		/* nothing to do */
		break;

	default:
	bad:
		tf->tf_out[0] = error;
		tf->tf_tstate |= (((int64_t)(ICC_C|XCC_C))<<TSTATE_CCR_SHIFT);	/* fail */
		dest = tf->tf_npc;
		tf->tf_pc = dest;
		tf->tf_npc = dest + 4;
		break;
	}

	mi_syscall_return(p, code, error, rval);
	share_fpu(p, tf);
}

/*
 * Process the tail end of a fork() for the child.
 */
void
child_return(void *arg)
{
	struct proc *p = arg;
	struct trapframe64 *tf = p->p_md.md_tf;
	vaddr_t dest;

	/* Duplicate efforts of syscall(), but slightly differently */
	if (tf->tf_global[1] & SYSCALL_G2RFLAG) {
		/* jmp %g2 on success */
		dest = tf->tf_global[2];
	} else {
		dest = tf->tf_npc;
		tf->tf_tstate &= ~(((int64_t)(ICC_C|XCC_C))<<TSTATE_CCR_SHIFT);
	}

	/* Skip trap instruction. */
	tf->tf_pc = dest;
	tf->tf_npc = dest + 4;

	/*
	 * Return values in the frame set by cpu_fork().
	 */
	tf->tf_out[0] = 0;
	tf->tf_out[1] = 0;

	KERNEL_UNLOCK();

	mi_child_return(p);
}
@


1.96
log
@fix use of uninitialised variables
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.95 2016/10/18 00:43:57 guenther Exp $	*/
d869 1
a869 1
			    p->p_p->ps_pid, p->p_comm,
@


1.95
log
@Delete remnants of "traptrace" support

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.94 2016/10/08 05:49:09 guenther Exp $	*/
d907 2
a917 1
	tstate = tf->tf_tstate;
d1153 1
a1153 1
	struct proc *p;
a1161 1
	p = curproc;
@


1.94
log
@Various printf claim to report the PID, so actually report that and not the TID

Build testing assistance from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.93 2016/09/12 15:04:15 tedu Exp $	*/
a433 1
			extern int trap_trace_dis;
a434 2
			trap_trace_dis = 1;

a850 2
				extern int trap_trace_dis;
				trap_trace_dis = 1; /* Disable traptrace for printf */
a931 3
			extern int trap_trace_dis;

			trap_trace_dis = 1; /* Disable traptrace for printf */
a992 2
		extern int trap_trace_dis;
		trap_trace_dis = 1; /* Disable traptrace for printf */
a1023 2
			extern int trap_trace_dis;
			trap_trace_dis = 1; /* Disable traptrace for printf */
a1066 3
		extern int trap_trace_dis;

		trap_trace_dis++; /* Disable traptrace for printf */
a1069 1
		trap_trace_dis--; /* Reenable traptrace for printf */
a1087 2
		extern int trap_trace_dis;
		trap_trace_dis = 1; /* Disable traptrace for printf */
a1120 2
			extern int trap_trace_dis;
			trap_trace_dis = 1; /* Disable traptrace for printf */
@


1.93
log
@spelling fix
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.92 2016/09/11 03:14:04 guenther Exp $	*/
d874 2
a875 2
			       p->p_pid, p->p_comm,
			       p->p_ucred ? (int)p->p_ucred->cr_uid : -1);
@


1.92
log
@Remove trailing whitespace

noted by jasper's emacs
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.91 2016/09/10 19:33:38 guenther Exp $	*/
d459 1
a459 1
		 * be much of a prefermance penalty since we're
@


1.91
log
@Convert function definitions from K&R to standard-style

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.90 2016/09/10 18:31:15 guenther Exp $	*/
d91 1
a91 1
int udhit = 0;	
d95 1
a95 1
int kdhit = 0;	
d315 1
a315 1
void data_access_fault(struct trapframe64 *tf, unsigned type, vaddr_t pc, 
d317 1
a317 1
void data_access_error(struct trapframe64 *tf, unsigned type, 
d319 1
a319 1
void text_access_fault(struct trapframe64 *tf, unsigned type, 
d321 1
a321 1
void text_access_error(struct trapframe64 *tf, unsigned type, 
d609 1
a609 1
		/* 
d617 1
a617 1
		
d777 1
a777 1
	/* 
d1240 1
a1240 1
		for (argp = args; i--;) 
@


1.90
log
@Simplify comments to reflect that we don't do 32bit compat processes

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.89 2016/09/10 18:02:15 guenther Exp $	*/
d312 1
a312 1
static __inline void share_fpu(struct proc *, struct trapframe64 *);
d333 2
a334 3
static __inline void share_fpu(p, tf)
	struct proc *p;
	struct trapframe64 *tf;
d346 1
a346 5
trap(tf, type, pc, tstate)
	struct trapframe64 *tf;
	unsigned type;
	vaddr_t pc;
	long tstate;
d744 1
a744 2
pmap_unuse_final(p)
	struct proc *p;
d756 2
a757 7
data_access_fault(tf, type, pc, addr, sfva, sfsr)
	struct trapframe64 *tf;
	unsigned type;
	vaddr_t pc;
	vaddr_t addr;
	vaddr_t sfva;
	u_long sfsr;
d899 2
a900 7
data_access_error(tf, type, afva, afsr, sfva, sfsr)
	struct trapframe64 *tf;
	unsigned type;
	vaddr_t sfva;
	u_long sfsr;
	vaddr_t afva;
	u_long afsr;
d976 2
a977 5
text_access_fault(tf, type, pc, sfsr)
	unsigned type;
	vaddr_t pc;
	struct trapframe64 *tf;
	u_long sfsr;
d1060 2
a1061 7
text_access_error(tf, type, pc, sfsr, afva, afsr)
	struct trapframe64 *tf;
	unsigned type;
	vaddr_t pc;
	u_long sfsr;
	vaddr_t afva;
	u_long afsr;
d1167 1
a1167 4
syscall(tf, code, pc)
	register_t code;
	struct trapframe64 *tf;
	register_t pc;
@


1.89
log
@If syscall() gets a 32bit trapframe, just kill the process; delete the
other code for 32bit processes, which collapses SYS_syscall and SYS___syscall
into the same behavior

ok kettenis@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.88 2016/02/27 13:08:07 mpi Exp $	*/
a1188 21
 *
 * 32-bit system calls on a 64-bit system are a problem.  Each system call
 * argument is stored in the smaller of the argument's true size or a
 * `register_t'.  Now on a 64-bit machine all normal types can be stored in a
 * `register_t'.  (The only exceptions would be 128-bit `quad's or 128-bit
 * extended precision floating point values, which we don't support.)  For
 * 32-bit syscalls, 64-bit integers like `off_t's, double precision floating
 * point values, and several other types cannot fit in a 32-bit `register_t'.
 * These will require reading in two `register_t' values for one argument.
 *
 * In order to calculate the true size of the arguments and therefore whether
 * any argument needs to be split into two slots, the system call args
 * structure needs to be built with the appropriately sized register_t.
 * Otherwise the emul needs to do some magic to split oversized arguments.
 *
 * We can handle most this stuff for normal syscalls by using either a 32-bit
 * or 64-bit array of `register_t' arguments.  Unfortunately ktrace always
 * expects arguments to be `register_t's, so it loses badly.  What's worse,
 * ktrace may need to do size translations to massage the argument array
 * appropriately according to the emulation that is doing the ktrace.
 *  
d1230 4
a1233 4
	 * __syscall.  The latter takes a quad syscall number, so that other
	 * arguments are at their natural alignments.  Adjust the number
	 * of ``easy'' arguments as appropriate; we will copy the hard
	 * ones later as needed.
@


1.88
log
@Rename kdb_trap() into db_ktrap().

The goal is to include it in the list of functions that must not be
instrumented.  All ddb(8) functions should be in this list and have
their names start with 'db_'.

ok visa@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.87 2015/11/06 06:33:26 guenther Exp $	*/
d1225 3
d1261 1
a1264 15
	case SYS___syscall:
		if (code < nsys && callp[code].sy_call !=
		    callp[p->p_p->ps_emul->e_nosys].sy_call)
			break; /* valid system call */
		if (tf->tf_out[6] & 1L) {
			/* longs *are* quadwords */
			code = ap[0];
			ap += 1;
			nap -= 1;			
		} else {
			code = ap[_QUAD_LOWWORD];
			ap += 2;
			nap -= 2;
		}
		break;
d1269 1
a1269 1
	else if (tf->tf_out[6] & 1L) {
d1278 1
a1278 1
			if ((error = copyin((caddr_t)(u_long)tf->tf_out[6]
a1289 3
	} else {
		error = EFAULT;
		goto bad;
@


1.87
log
@Move the logic for adjusting userspace registers in the child after fork
from cpu_fork() to child_return(), putting all the SYSCALL_G2RFLAG logic
in trap.c

sparc testing by sebastia@@ and miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.86 2015/06/05 16:07:24 kettenis Exp $	*/
d374 1
a374 1
			if (kdb_trap(type, tf)) {
d380 1
a380 1
			if (kdb_trap(type, tf)) {
@


1.86
log
@These days p->p_addr will never be NULL.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.85 2014/11/16 12:30:59 deraadt Exp $	*/
d1356 1
a1356 2
child_return(arg)
	void *arg;
d1358 1
a1358 1
	struct proc *p = (struct proc *)arg;
d1360 14
a1379 1
	tf->tf_tstate &= ~(((int64_t)(ICC_C|XCC_C))<<TSTATE_CCR_SHIFT);
a1384 1

@


1.85
log
@Replace a plethora of historical protection options with just
PROT_NONE, PROT_READ, PROT_WRITE, and PROT_EXEC from mman.h.
PROT_MASK is introduced as the one true way of extracting those bits.
Remove UVM_ADV_* wrapper, using the standard names.
ok doug guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.84 2014/05/11 00:12:44 guenther Exp $	*/
d617 1
a617 1
		if (p->p_addr && p->p_addr->u_pcb.pcb_onfault) {
d810 1
a810 1
		if (p->p_addr && p->p_addr->u_pcb.pcb_onfault == Lfsprobe)
d863 1
a863 2
			onfault = p->p_addr ?
			    (long)p->p_addr->u_pcb.pcb_onfault : 0;
d941 1
a941 1
	onfault = p->p_addr ? (long)p->p_addr->u_pcb.pcb_onfault : 0;
@


1.84
log
@Move the increment of uvmexp.softs back to the caller of mi_ast():
it needs to be done atomicly on some MP archs and we don't have
atomic_add_int() everywhere yet.  Also, mi_ast() was meant to be inline.

noted by miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.83 2014/05/10 12:29:58 kettenis Exp $	*/
d797 1
a797 1
		access_type = VM_PROT_READ;
d799 2
a800 2
		access_type = (sfsr & SFSR_W) ? VM_PROT_READ|VM_PROT_WRITE
			: VM_PROT_READ;
d978 1
a978 1
	trapsignal(p, SIGSEGV, VM_PROT_READ|VM_PROT_WRITE, SEGV_MAPERR, sv);
d1019 1
a1019 1
	access_type = VM_PROT_EXECUTE;
d1127 1
a1127 1
	access_type = VM_PROT_EXECUTE;
@


1.83
log
@A few more straightforward format string fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.82 2014/05/10 05:33:00 guenther Exp $	*/
d455 1
@


1.82
log
@Factor out the common ast bits into mi_ast()

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.81 2014/04/18 11:51:17 guenther Exp $	*/
d957 1
a957 1
			panic("data fault: pc=%lx addr=%lx sfsr=%b",
d967 1
a967 1
			panic("Privileged Async Fault: AFAR %p AFSR %lx\n%b",
d1131 2
a1132 1
		panic("kernel text error: pc=%lx sfsr=%b", pc, sfsr, SFSR_BITS);
d1166 1
a1166 1
			panic("kernel text error: pc=%lx sfsr=%b", pc,
@


1.81
log
@Have each thread keeps its own (counted!) reference to the process's ucreds
to avoid possible use-after-free references when swapping ids in threaded
processes.  "Do I have the right creds?" checks are always made with the
threads creds.

Inspired by FreeBSD and NetBSD
"right time" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.80 2014/03/30 21:54:49 guenther Exp $	*/
d455 1
a455 7
		if (p->p_flag & P_OWEUPC) {
			KERNEL_LOCK();
			ADDUPROF(p);
			KERNEL_UNLOCK();
		}
		if (curcpu()->ci_want_resched)
			preempt(NULL);
@


1.80
log
@Eliminates struct pcred by moving the real and saved ugids into
struct ucred; struct process then directly links to the ucred

Based on a discussion at c2k10 or so before noting that FreeBSD and
NetBSD did this too.

ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.79 2014/03/26 05:23:42 guenther Exp $	*/
d433 1
@


1.79
log
@Move p_emul and p_sigcode from proc to process.
Tweak the handling of ktrace EMUL when changing ktracing: only
generate one per process (not one per thread) and pass the correct
proc pointer down to the VFS layer.  Permit generating of NAMI and
CSW records inside ktrace(2) itself.

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.78 2013/04/02 13:24:57 kettenis Exp $	*/
d889 1
a889 1
			printf("UVM: pid %d (%s), uid %u killed: out of swap\n",
d891 1
a891 2
			       p->p_cred && p->p_ucred ?
			       p->p_ucred->cr_uid : -1);
@


1.78
log
@Get rid of SYSCALL_G7RFLAG.  iIt's been deprecated for a long time already,
and we've started using %g7 as a per-thread register now.  If you have any
binaries left that use this flag they'll probably crash and burn!
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.77 2012/12/31 06:46:14 guenther Exp $	*/
d1244 2
a1245 2
	callp = p->p_emul->e_sysent;
	nsys = p->p_emul->e_nsysent;
d1267 2
a1268 2
		if (code < nsys &&
		    callp[code].sy_call != callp[p->p_emul->e_nosys].sy_call)
d1284 1
a1284 1
		callp += p->p_emul->e_nosys;
@


1.77
log
@Remove emulation errno mapping code from platforms that no longer have
non-native emulations.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.76 2012/08/07 05:16:54 guenther Exp $	*/
d1241 2
a1242 2
	new = code & (SYSCALL_G7RFLAG | SYSCALL_G2RFLAG);
	code &= ~(SYSCALL_G7RFLAG | SYSCALL_G2RFLAG);
d1323 2
a1324 2
			/* jmp %g2 (or %g7, deprecated) on success */
			dest = tf->tf_global[new & SYSCALL_G2RFLAG ? 2 : 7];
@


1.76
log
@Move the common bits of syscall invocation and return handling into
an MI file, <sys/syscall_mi.h>, correcting inconsistencies and the
handling when copyin() of arguments fails.

Tested on i386, amd64, sparc64, and alpha (thanks naddy@@)
Any issues with other platforms will be fixed in tree.

header name from millert@@; ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.75 2012/04/11 14:38:55 mikeb Exp $	*/
a1344 2
		if (p->p_emul->e_errno)
			error = p->p_emul->e_errno[error];
@


1.75
log
@The first ktrace record for a newly spawned thread is a return
from a fork syscall done by the parent.  Use __tfork, not rfork
here to match the ktrace records for the parent (CALL __tfork,
RET __tfork).  ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.74 2011/11/16 20:50:19 deraadt Exp $	*/
d63 1
a64 6
#ifdef KTRACE
#include <sys/ktrace.h>
#endif

#include "systrace.h"
#include <dev/systrace.h>
d1226 1
a1226 1
	int error = 0, new, lock;
a1246 2
	lock = !(callp->sy_flags & SY_NOLOCK);

d1294 4
a1297 3
			error = copyin((caddr_t)(u_long)tf->tf_out[6] + BIAS +
				       offsetof(struct frame64, fr_argx),
				       (caddr_t)&args[nap], (i - nap) * sizeof(register_t));
d1300 4
a1303 1
		/* It should be faster to do <=6 longword copies than call bcopy */
a1305 10
		
#ifdef KTRACE
		if (KTRPOINT(p, KTR_SYSCALL)) {
			KERNEL_LOCK();
			ktrsyscall(p, code, callp->sy_argsize, args);
			KERNEL_UNLOCK();
		}
#endif
		if (error)
			goto bad;
a1310 5
#ifdef SYSCALL_DEBUG
	KERNEL_LOCK();
	scdebug_call(p, code, args);
	KERNEL_UNLOCK();
#endif
d1313 3
a1315 14
#if NSYSTRACE > 0
	if (ISSET(p->p_flag, P_SYSTRACE)) {
		KERNEL_LOCK();
		error = systrace_redirect(code, p, args, rval);
		KERNEL_UNLOCK();
	} else
#endif
	{
		if (lock)
			KERNEL_LOCK();
		error = (*callp->sy_call)(p, args, rval);
		if (lock)
			KERNEL_UNLOCK();
	}
d1355 1
a1355 13
#ifdef SYSCALL_DEBUG
	KERNEL_LOCK();
	scdebug_ret(p, code, error, rval);
	KERNEL_UNLOCK();
#endif
	userret(p);
#ifdef KTRACE
	if (KTRPOINT(p, KTR_SYSRET)) {
		KERNEL_LOCK();
		ktrsysret(p, code, error, rval[0]);
		KERNEL_UNLOCK();
	}
#endif
d1378 1
a1378 11
	userret(p);
#ifdef KTRACE
	if (KTRPOINT(p, KTR_SYSRET)) {
		KERNEL_LOCK();
		ktrsysret(p,
		    (p->p_flag & P_THREAD) ? SYS___tfork :
		    (p->p_p->ps_flags & PS_PPWAIT) ? SYS_vfork : SYS_fork,
		    0, 0);
		KERNEL_UNLOCK();
	}
#endif
@


1.74
log
@Make userret() MI.  On architectures which jammed stuff into it in the
past, pull that code out seperately.
ok guenther miod
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.73 2011/07/11 15:40:47 guenther Exp $	*/
d1424 1
a1424 1
		    (p->p_flag & P_THREAD) ? SYS_rfork :
@


1.73
log
@Revert art@@'s moving around of the KERNEL_LOCK()/KERNEL_UNLOCK() calls,
as it causes hangs in some ports, including libsigsegv's configure script

confirmed by krw@@, landry@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.71 2011/07/06 22:26:44 kettenis Exp $	*/
a316 1
static __inline void userret(struct proc *);
a328 16

/*
 * Define the code needed before returning to user mode, for
 * trap, mem_access_fault, and syscall.
 */
static __inline void
userret(struct proc *p)
{
	int sig;

	/* take pending signals */
	while ((sig = CURSIG(p)) != 0)
		postsig(sig);

	curcpu()->ci_schedstate.spc_curpriority = p->p_priority = p->p_usrpri;
}
@


1.72
log
@There is a bunch of places in the kernel entry points where we don't
hold the kernel lock, but still need call one function that needs it.

Instead of grabbing the lock all over the place, move the locks into
the affected functions: trapsignal, scdebug*, ktrsyscall, ktrsysret,
systrace_redirect and ADDUPROF. In the cases we already hold the biglock
we'll just recurse.

kettenis@@, beck@@ ok
@
text
@d469 1
d471 1
d477 1
d479 1
d496 1
d498 1
d508 1
d510 1
d529 1
d531 1
d539 1
d541 1
d592 1
d594 1
d605 1
d607 1
d650 1
d652 1
d687 1
d689 1
d693 1
d695 1
d700 1
d702 1
d718 1
d720 1
d726 1
d728 1
d734 1
d736 1
d1004 1
d1006 1
d1143 1
d1145 1
d1329 1
d1331 1
d1342 1
d1344 1
d1350 1
d1352 1
d1402 1
d1404 1
d1409 1
d1411 1
d1439 1
d1444 1
@


1.71
log
@Handle pci_conf_read() faults on reading non-existent registers that result
in master aborts.  Return 0xffffffff to emulate what happens on non-perfect
architectures in that case.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.70 2011/07/06 21:41:37 art Exp $	*/
a468 1
		KERNEL_LOCK();
a469 1
		KERNEL_UNLOCK();
a474 1
			KERNEL_LOCK();
a475 1
			KERNEL_UNLOCK();
a491 1
			KERNEL_LOCK();
a492 1
			KERNEL_UNLOCK();
a501 1
			KERNEL_LOCK();
a502 1
			KERNEL_UNLOCK();
a520 1
		KERNEL_LOCK();
a521 1
		KERNEL_UNLOCK();
a528 1
		KERNEL_LOCK();
a529 1
		KERNEL_UNLOCK();
a579 1
			KERNEL_LOCK();
a580 1
			KERNEL_UNLOCK();
a590 1
			KERNEL_LOCK();
a591 1
			KERNEL_UNLOCK();
a633 1
		KERNEL_LOCK();
a634 1
		KERNEL_UNLOCK();
a668 1
		KERNEL_LOCK();
a669 1
		KERNEL_UNLOCK();
a672 1
		KERNEL_LOCK();
a673 1
		KERNEL_UNLOCK();
a677 1
		KERNEL_LOCK();
a678 1
		KERNEL_UNLOCK();
a693 1
		KERNEL_LOCK();
a694 1
		KERNEL_UNLOCK();
a699 1
		KERNEL_LOCK();
a700 1
		KERNEL_UNLOCK();
a705 1
		KERNEL_LOCK();
a706 1
		KERNEL_UNLOCK();
a973 1
	KERNEL_LOCK();
a974 1
	KERNEL_UNLOCK();
a1110 1
		KERNEL_LOCK();
a1111 1
		KERNEL_UNLOCK();
a1294 1
			KERNEL_LOCK();
a1295 1
			KERNEL_UNLOCK();
a1305 1
	KERNEL_LOCK();
a1306 1
	KERNEL_UNLOCK();
a1311 1
		KERNEL_LOCK();
a1312 1
		KERNEL_UNLOCK();
a1361 1
	KERNEL_LOCK();
a1362 1
	KERNEL_UNLOCK();
a1366 1
		KERNEL_LOCK();
a1367 1
		KERNEL_UNLOCK();
a1394 1
		KERNEL_LOCK();
a1398 1
		KERNEL_UNLOCK();
@


1.70
log
@Clean up after P_BIGLOCK removal.
KERNEL_PROC_LOCK -> KERNEL_LOCK
KERNEL_PROC_UNLOCK -> KERNEL_UNLOCK

oga@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.69 2011/07/04 22:53:53 tedu Exp $	*/
d955 8
@


1.69
log
@remove compat_svr4 support.  ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.68 2011/06/06 13:19:29 kettenis Exp $	*/
d469 1
a469 1
		KERNEL_PROC_LOCK(p);
d471 1
a471 1
		KERNEL_PROC_UNLOCK(p);
d477 1
a477 1
			KERNEL_PROC_LOCK(p);
d479 1
a479 1
			KERNEL_PROC_UNLOCK(p);
d496 1
a496 1
			KERNEL_PROC_LOCK(p);
d498 1
a498 1
			KERNEL_PROC_UNLOCK(p);
d508 1
a508 1
			KERNEL_PROC_LOCK(p);
d510 1
a510 1
			KERNEL_PROC_UNLOCK(p);
d529 1
a529 1
		KERNEL_PROC_LOCK(p);
d531 1
a531 1
		KERNEL_PROC_UNLOCK(p);
d539 1
a539 1
		KERNEL_PROC_LOCK(p);
d541 1
a541 1
		KERNEL_PROC_UNLOCK(p);
d548 1
a548 1
			KERNEL_PROC_LOCK(p);
d554 1
a554 1
			KERNEL_PROC_UNLOCK(p);
d592 1
a592 1
			KERNEL_PROC_LOCK(p);
d594 1
a594 1
			KERNEL_PROC_UNLOCK(p);
d605 1
a605 1
			KERNEL_PROC_LOCK(p);
d607 1
a607 1
			KERNEL_PROC_UNLOCK(p);
d622 1
a622 1
		KERNEL_PROC_LOCK(p);
d650 1
a650 1
		KERNEL_PROC_LOCK(p);
d652 1
a652 1
		KERNEL_PROC_UNLOCK(p);
d687 1
a687 1
		KERNEL_PROC_LOCK(p);
d689 1
a689 1
		KERNEL_PROC_UNLOCK(p);
d693 1
a693 1
		KERNEL_PROC_LOCK(p);
d695 1
a695 1
		KERNEL_PROC_UNLOCK(p);
d700 1
a700 1
		KERNEL_PROC_LOCK(p);
d702 1
a702 1
		KERNEL_PROC_UNLOCK(p);
d718 1
a718 1
		KERNEL_PROC_LOCK(p);
d720 1
a720 1
		KERNEL_PROC_UNLOCK(p);
d726 1
a726 1
		KERNEL_PROC_LOCK(p);
d728 1
a728 1
		KERNEL_PROC_UNLOCK(p);
d734 1
a734 1
		KERNEL_PROC_LOCK(p);
d736 1
a736 1
		KERNEL_PROC_UNLOCK(p);
d857 1
a857 1
		KERNEL_PROC_LOCK(p);
d922 1
a922 1
		KERNEL_PROC_UNLOCK(p);
d996 1
a996 1
	KERNEL_PROC_LOCK(p);
d998 1
a998 1
	KERNEL_PROC_UNLOCK(p);
d1048 1
a1048 1
	KERNEL_PROC_LOCK(p);
d1082 1
a1082 1
	KERNEL_PROC_UNLOCK(p);
d1135 1
a1135 1
		KERNEL_PROC_LOCK(p);
d1137 1
a1137 1
		KERNEL_PROC_UNLOCK(p);
d1156 1
a1156 1
	KERNEL_PROC_LOCK(p);
d1192 1
a1192 1
	KERNEL_PROC_UNLOCK(p);
d1321 1
a1321 1
			KERNEL_PROC_LOCK(p);
d1323 1
a1323 1
			KERNEL_PROC_UNLOCK(p);
d1334 1
a1334 1
	KERNEL_PROC_LOCK(p);
d1336 1
a1336 1
	KERNEL_PROC_UNLOCK(p);
d1342 1
a1342 1
		KERNEL_PROC_LOCK(p);
d1344 1
a1344 1
		KERNEL_PROC_UNLOCK(p);
d1349 1
a1349 1
			KERNEL_PROC_LOCK(p);
d1352 1
a1352 1
			KERNEL_PROC_UNLOCK(p);
d1394 1
a1394 1
	KERNEL_PROC_LOCK(p);
d1396 1
a1396 1
	KERNEL_PROC_UNLOCK(p);
d1401 1
a1401 1
		KERNEL_PROC_LOCK(p);
d1403 1
a1403 1
		KERNEL_PROC_UNLOCK(p);
d1426 1
a1426 1
	KERNEL_PROC_UNLOCK(p);
d1431 1
a1431 1
		KERNEL_PROC_LOCK(p);
d1436 1
a1436 1
		KERNEL_PROC_UNLOCK(p);
@


1.68
log
@Set FEF bit in the %fprs register when handling an fp_disabled trap from
userland.  Prevents userland applications from trapping forever on the next
floating point instruction executed after clearing this flag.  Fixes issues
with threaded applications, sinc our pthreads library clears the FEF bit
under some circumstances.

ok miod@@, tested by ajacoutot@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.67 2011/04/03 14:56:28 guenther Exp $	*/
a83 6
#ifdef COMPAT_SVR4
#include <machine/svr4_machdep.h>
#endif
#ifdef COMPAT_SVR4_32
#include <machine/svr4_32_machdep.h>
#endif
a468 3
#if defined(COMPAT_SVR4) || defined(COMPAT_SVR4_32)
badtrap:
#endif
a472 19

#if defined(COMPAT_SVR4) || defined(COMPAT_SVR4_32)
	case T_SVR4_GETCC:
	case T_SVR4_SETCC:
	case T_SVR4_GETPSR:
	case T_SVR4_SETPSR:
	case T_SVR4_GETHRTIME:
	case T_SVR4_GETHRVTIME:
	case T_SVR4_GETHRESTIME:
#if defined(COMPAT_SVR4_32)
		if (svr4_32_trap(type, p))
			break;
#endif
#if defined(COMPAT_SVR4)
		if (svr4_trap(type, p))
			break;
#endif
		goto badtrap;
#endif
@


1.67
log
@Move PPWAIT flag from struct proc to process, so that rthreads in
a vforked child behave correctly.  Have the parent in a vfork()
wait on a (different) flag in *its* process instead of the child
to prevent a possible use-after-free.  When ktracing the child
return from a fork, call it rfork if an rthread was created.

ok blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.66 2010/11/27 19:41:48 miod Exp $	*/
d609 1
@


1.66
log
@Misaligned load/store recovery code in the kernel, enabled by T_FIXALIGN
userland traps on a per-process basis, were necessary for *some* SunOS
binaries on sparc, which had to compiled with explicit misaligned access code
generation (i.e. for vendors to release a working SunOS/sparc version of their
code until they could fix their bogus code).

There is no reason to keep this code on sparc64, and now that we don't provide
COMPAT_SUNOS anymore, there is no reason to keep this code on sparc.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.65 2010/08/07 00:13:09 krw Exp $	*/
d1460 3
a1462 1
		    (p->p_flag & P_PPWAIT) ? SYS_vfork : SYS_fork, 0, 0);
@


1.65
log
@No "\n" needed at the end of panic() strings.

Some stragglers from last diff.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.64 2009/01/20 21:22:31 kettenis Exp $	*/
a675 5
		if ((p->p_md.md_flags & MDP_FIXALIGN) != 0 && 
		    fixalign(p, tf) == 0) {
			ADVANCE;
			break;
		}
a750 1
#ifdef DEBUG_ALIGN
a751 3
#endif
		/* User wants us to fix alignment faults */
		p->p_md.md_flags |= MDP_FIXALIGN;
d753 3
@


1.64
log
@I can't figure out why flushing all user windows before writing out windows
saved in the pcb to the stack fixes the problems with user space register
window corruption I see on sun4v.  So I give up and commit the workaround.
It isn't too evil, since this isn't in the fast path and we're likely to
spill these windows anyway in the process of writing out the register windows.
Curiously enough, the OpenSolaris code seems to do pretty much the same.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.63 2008/07/12 08:08:54 kettenis Exp $	*/
d470 1
a470 1
			panic("trap type 0x%x (%s): pc=%lx npc=%lx pstate=%b\n",
d928 1
a928 1
				panic("kernel data fault: pc=%lx addr=%lx\n",
d1010 1
a1010 1
			panic("data fault: pc=%lx addr=%lx sfsr=%b\n",
d1076 1
a1076 1
		panic("kernel text_access_fault: pc=%lx va=%lx\n", pc, va);
d1109 1
a1109 1
			panic("kernel text fault: pc=%llx\n", (unsigned long long)pc);
d1184 1
a1184 1
		panic("kernel text error: pc=%lx sfsr=%b\n", pc, sfsr, SFSR_BITS);
d1218 1
a1218 1
			panic("kernel text error: pc=%lx sfsr=%b\n", pc,
@


1.63
log
@On Fujitsu's SPARC64 CPUs, the data_access_error trap is synchronous, and AFSR
will be 0.  Check SFSR too, before deciding there's no fault.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.61 2008/03/26 22:07:23 kettenis Exp $	*/
d514 9
@


1.62
log
@Don't grab the kernel biglock for syscalls marked SY_NOLOCK;
make the amd64 code a bit nicer and make the sparc64 match that.

tested by a few;
OK toby@@, dlg@@, kettenis@@ (for the sparc64 part).
@
text
@d989 1
a989 1
	if (afsr == 0) {
@


1.61
log
@Disable some code that reads some sun4u-specific registers for diagnostic
reasons, but isn't otherwise used.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.60 2008/01/16 20:55:36 kettenis Exp $	*/
d1264 1
a1264 1
	int error = 0, new;
d1285 2
d1357 1
a1358 1
#ifdef SYSCALL_DEBUG
d1360 1
d1365 2
a1366 1
	if (ISSET(p->p_flag, P_SYSTRACE))
d1368 2
a1369 1
	else
d1371 3
d1375 3
a1377 2
	KERNEL_PROC_UNLOCK(p);

@


1.60
log
@Simplify spilling register windows into the pcb by storing the stack pointer
seperately from the window and copying out data back to the stack by using the
T_RWRET softtrap and rwindow_save().
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.59 2007/12/26 17:40:59 miod Exp $	*/
d648 1
d656 2
a665 1
	}
@


1.59
log
@Use the TSTATE_xxx constants instead of (PSTATE_xxx << TSTATE_PSTATE_SHIFT)
for readability; ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.58 2007/11/18 21:16:44 kettenis Exp $	*/
d513 8
a772 3
 * 
 * XXXXXX This cannot work properly.  I need to re-examine this register
 * window thing entirely.  
d775 1
a775 2
rwindow_save(p)
	struct proc *p;
d778 1
a778 20
	struct rwindow64 *rw = &pcb->pcb_rw[0];
	u_int64_t rwdest;
	int i, j;

	i = pcb->pcb_nsaved;
	if (i == 0)
		return (0);
	 while (i > 0) {
		rwdest = rw[i--].rw_in[6];
		if (rwdest & 1) {
			struct rwindow64 rwstack = rw[i];

			rwdest += BIAS;
			rwstack.rw_in[7] ^= p->p_addr->u_pcb.pcb_wcookie;
			if (copyout((caddr_t)&rwstack, (caddr_t)(u_long)rwdest,
			    sizeof(rwstack))) {
				return (-1);
			}
		} else {
			struct rwindow32 rwstack;
d780 5
a784 11
			/* 32-bit window */
			for (j = 0; j < 8; j++) { 
				rwstack.rw_local[j] = (int)rw[i].rw_local[j];
				rwstack.rw_in[j] = (int)rw[i].rw_in[j];
			}
			/* Must truncate rwdest */
			if (copyout(&rwstack, (caddr_t)(u_long)(u_int)rwdest,
			    sizeof(rwstack))) {
				return (-1);
			}
		}
d786 1
a787 1

@


1.58
log
@Add missing locking around ktrsyscall() call.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.57 2007/10/31 22:46:52 kettenis Exp $	*/
d365 3
a367 3
	if (!(tf->tf_tstate & (PSTATE_PRIV<<TSTATE_PSTATE_SHIFT)) &&
	    (tf->tf_tstate & (PSTATE_PEF<<TSTATE_PSTATE_SHIFT)) && fpproc != p)
		tf->tf_tstate &= ~(PSTATE_PEF<<TSTATE_PSTATE_SHIFT);
d1190 1
a1190 1
	if (tstate & (PSTATE_PRIV<<TSTATE_PSTATE_SHIFT)) {
@


1.57
log
@Overhaul fpu context save/restore code, making it more similar to what we do
on i386 and amd64.  Don't let IPIs in when saving fpu context by disabling
interrupts.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.56 2007/10/16 19:22:49 kettenis Exp $	*/
d1361 5
a1365 3
		if (KTRPOINT(p, KTR_SYSCALL))
			ktrsyscall(p, code,
				   callp->sy_argsize, args);
@


1.56
log
@Make lazy fpu context switching work for MULTIPROCESSOR kernels.  Tested by
many.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.55 2007/10/15 09:24:31 fgsch Exp $	*/
d384 1
d432 1
a432 1
					save_and_clear_fpstate(newfpproc);
d435 1
d441 2
d582 2
a583 1
			save_and_clear_fpstate(p);
d588 1
d680 1
d683 1
@


1.55
log
@catch privileged actions as well; hint from miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.54 2007/09/22 20:04:51 kettenis Exp $	*/
d427 1
a427 1
			else
d429 4
a432 1

d577 2
@


1.54
log
@Add kernel locking.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.53 2007/09/08 17:13:18 kettenis Exp $	*/
d542 1
@


1.53
log
@Make the ast on sparc64 per-process instead of global.  Necessary to make
signal delivery more reliable once we go smp (although the code for that
is still missing).

"in principle, this looks good" art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.52 2007/09/04 20:36:52 kettenis Exp $	*/
d471 1
d473 1
d498 1
d500 1
d512 1
d514 1
d533 3
a535 1
		trapsignal(p, SIGILL, 0, ILL_ILLOPC, sv);	/* XXX code?? */
d542 3
a544 1
		trapsignal(p, SIGILL, 0, ILL_ILLOPC, sv);	/* XXX code?? */
d551 1
d557 1
d590 1
d592 1
d602 2
a603 1
		} else
d605 2
d620 1
d622 1
d651 3
a653 1
		trapsignal(p, SIGBUS, 0, BUS_ADRALN, sv);	/* XXX code?? */
d686 3
a688 1
		trapsignal(p, SIGEMT, 0, EMT_TAGOVF, sv);	/* XXX code?? */
d692 1
d694 1
d699 1
d701 1
d717 3
a719 1
		trapsignal(p, SIGILL, 0, ILL_ILLOPN, sv);	/* XXX code?? */
d734 1
d736 1
d857 2
a858 1
	if (tstate & (PSTATE_PRIV<<TSTATE_PSTATE_SHIFT)) {
d879 2
a880 1
			if (rv == 0)
d882 1
d885 2
a886 1
	} else
d888 1
d916 1
a916 1
		if (tstate & (PSTATE_PRIV<<TSTATE_PSTATE_SHIFT)) {
d930 1
d949 1
d951 1
d954 2
d999 1
a999 1
	if (tstate & (PSTATE_PRIV<<TSTATE_PSTATE_SHIFT)) {
d1025 1
d1027 1
d1029 1
d1068 1
a1068 1
	if (tstate & (PSTATE_PRIV<<TSTATE_PSTATE_SHIFT)) {
d1077 2
d1110 3
d1160 1
a1160 1
		if (tstate & (PSTATE_PRIV<<TSTATE_PSTATE_SHIFT))
d1164 1
d1166 1
d1185 2
d1220 3
d1357 2
d1370 1
d1412 1
d1414 1
d1418 2
a1419 1
	if (KTRPOINT(p, KTR_SYSRET))
d1421 2
d1444 2
d1448 2
a1449 1
	if (KTRPOINT(p, KTR_SYSRET))
d1452 2
@


1.52
log
@UltraSPARC CPUs always have an on-chip FPU.  There really is no need to have
the code to detect the various FPUs of earlier SPARC V7 and V8 CPUs.

ok deraadt@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.51 2007/07/05 22:16:30 kettenis Exp $	*/
d494 1
a494 1
		want_ast = 0;
@


1.51
log
@Report actual faulting address (if we can) instead of the mmu tag word for
SIGSEGV.

tested by jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.50 2007/05/14 21:38:08 kettenis Exp $	*/
a545 9
		}
		/*
		 * If we have not found an FPU, we have to emulate it.
		 *
		 * Since All UltraSPARC CPUs have an FPU how can this happen?
		 */
		if (!foundfpu) {
			trapsignal(p, SIGILL, 0, ILL_COPROC, sv);
			break;
@


1.50
log
@Move want_resched into struct cpu_info.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.49 2007/05/02 18:46:07 kettenis Exp $	*/
a811 2
	sv.sival_ptr = (void *)addr;

d905 6
@


1.49
log
@Move sparc64 to __HAVE_CPUINFO.

ok miod@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.48 2007/04/24 18:14:15 deraadt Exp $	*/
d498 1
a498 1
		if (want_resched)
@


1.48
log
@do not printf+panic, when a longer panic message is easier; kettenis ok
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.46 2007/02/27 22:46:32 deraadt Exp $	*/
a349 1
#ifdef notyet
a350 3
#else
	curpriority = p->p_priority = p->p_usrpri;
#endif
a1220 3
#ifdef DIAGNOSTIC
	extern struct pcb *cpcb;
#endif
d1227 1
a1227 1
	if (cpcb != &p->p_addr->u_pcb)
d1229 1
a1229 1
	if (tf != (struct trapframe64 *)((caddr_t)cpcb + USPACE) - 1)
@


1.47
log
@Since p_flag is often manipulated in interrupts and without biglock
it's a good idea to use atomic.h operations on it. This mechanic
change updates all bit operations on p_flag to atomic_{set,clear}bits_int.

Only exception is that P_OWEUPC is set by MI code before calling
need_proftick and it's automatically cleared by ADDUPC. There's
no reason for MD handling of that flag since everyone handles it the
same way.

kettenis@@ ok
@
text
@d467 3
a469 4
			printf("trap type 0x%x: pc=%lx", type, pc); 
			printf(" npc=%lx pstate=%b\n",
			    (long)tf->tf_npc, pstate, PSTATE_BITS);
			panic(type < N_TRAP_TYPES ? trap_type[type] : T);
d903 1
a903 1
				printf("data fault: pc=%lx addr=%lx\n",
a904 1
				panic("kernel fault");
d1037 1
a1037 2
		printf("text_access_fault: pc=%lx va=%lx\n", pc, va);
		panic("kernel fault");
d1068 1
a1068 2
			printf("text fault: pc=%llx\n", (unsigned long long)pc);
			panic("kernel fault");
d1138 1
a1138 2
		printf("text error: pc=%lx sfsr=%b\n", pc, sfsr, SFSR_BITS);
		panic("kernel fault");
d1170 1
a1170 1
			printf("text error: pc=%lx sfsr=%b\n", pc,
a1171 1
			panic("kernel fault");
@


1.46
log
@nicer panic; kettenis ok
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.45 2006/12/24 20:30:35 miod Exp $	*/
a500 1
			p->p_flag &= ~P_OWEUPC;
@


1.45
log
@Define PROC_PC. Then, since profiling information is being reported in
statclock(), do not bother doing this in userret() anymore. As a result,
userret() does not need its pc and ticks arguments, simplify.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.44 2006/12/24 20:29:19 miod Exp $	*/
d977 1
a977 1
			printf("data fault: pc=%lx addr=%lx sfsr=%b\n",
a978 1
			panic("kernel fault");
@


1.44
log
@Check for want_resched when processing AST and nowhere else. But then, when
doing so, do not check for signals - userret() will do this.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.43 2006/07/01 16:24:17 miod Exp $	*/
d323 1
a323 1
static __inline void userret(struct proc *, int,  u_quad_t);
d342 1
a342 4
userret(p, pc, oticks)
	struct proc *p;
	int pc;
	u_quad_t oticks;
a348 25
	p->p_priority = p->p_usrpri;
	if (want_ast) {
		want_ast = 0;
		if (p->p_flag & P_OWEUPC) {
			p->p_flag &= ~P_OWEUPC;
			ADDUPROF(p);
		}
	}
	if (want_resched) {
		/*
		 * We are being preempted.
		 */
		preempt(NULL);
		while ((sig = CURSIG(p)) != 0)
			postsig(sig);
	}

	/*
	 * If profiling, charge recent system time to the trapped pc.
	 */
	if (p->p_flag & P_PROFIL) {
		extern int psratio;

		addupc_task(p, pc, (int)(p->p_sticks - oticks) * psratio);
	}
d351 1
a351 1
	curcpu()->ci_schedstate.spc_curpriority = p->p_priority;
d353 1
a353 1
	curpriority = p->p_priority;
a388 1
	u_quad_t sticks;
a455 1
	sticks = p->p_sticks;
d723 1
a723 1
	userret(p, pc, sticks);
a815 1
	u_quad_t sticks;
a822 1
	sticks = p->p_sticks;
d925 1
a925 1
		userret(p, pc, sticks);
a949 1
	u_quad_t sticks;
a954 1
	sticks = p->p_sticks;
d1000 1
a1000 1
		userret(p, pc, sticks);
a1021 1
	u_quad_t sticks;
a1028 1
	sticks = p->p_sticks;
d1080 1
a1080 1
		userret(p, pc, sticks);
a1107 1
	u_quad_t sticks;
a1113 1
	sticks = p->p_sticks;
d1186 1
a1186 1
		userret(p, pc, sticks);
a1232 1
	u_quad_t sticks;
a1246 1
	sticks = p->p_sticks;
d1375 1
a1375 1
	userret(p, pc, sticks);
d1400 1
a1400 1
	userret(p, tf->tf_pc, 0);
@


1.43
log
@Make probeget() and related code in trap.c #ifdef DDB
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.42 2006/06/26 22:18:06 miod Exp $	*/
d529 8
a536 1
		break;	/* the work is all in userret() */
@


1.42
log
@Always skip the offending instruction for fpu faults, even if it is
theoretically recoverable, as there is no way we can rely on the signal
handler to do this properly; consistent with other platforms, and lets a
few autoconf tests in ports pass again.
spotted by sturm@@; reluctantly ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.41 2006/05/15 21:56:54 kettenis Exp $	*/
d869 2
a870 1
		extern char Lfsbail[];
d875 1
a875 1
		if (p->p_addr && p->p_addr->u_pcb.pcb_onfault == Lfsbail)
d877 1
@


1.41
log
@Fix SIGFPE handling.  The code doing an ADVANCE after calling trapsignal(),
which made is skip the first instruction of the signal trampoline in certain
cases.  That in turn truly hosed the stack.
ok miod@@, jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.40 2006/02/05 19:53:34 kettenis Exp $	*/
a695 1
			ADVANCE;
d697 1
a699 3
#if 0		/* ??? really never??? */
		ADVANCE;
#endif
@


1.40
log
@Commit uncommitted bit from 2006/01/03 change to locore.s:
Try to prevent red stating the machine on a misaligned user space stack by
SIGKILLing the process.
ok miod@@, henric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.39 2006/01/30 21:26:19 miod Exp $	*/
d688 5
a692 1
		if (p->p_md.md_fpstate->fs_qsize == 0) {
d694 1
a695 1
			fpu_cleanup(p, p->p_md.md_fpstate);
d697 2
a698 2
		} else
			fpu_cleanup(p, p->p_md.md_fpstate);
@


1.39
log
@When delivering SIGFOO, make sure the siginfo code is a FOO_xxx constant;
also deliver SIGILL/ILL_COPROC rather than SIGFPE/FPE_FLTINV for disabled
or missing floating point support.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.38 2005/12/30 21:14:16 millert Exp $	*/
d480 2
a481 1
		goto dopanic;
d630 13
@


1.38
log
@Remove unused COMPAT_NETBSD32 block and get rid of register{32,64}_t
which are now unused.  Tested and OK miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.37 2005/12/25 00:22:47 miod Exp $	*/
d581 1
a581 1
			trapsignal(p, SIGFPE, 0, FPE_FLTINV, sv);
@


1.37
log
@Ensure child_return() leaves registers the same way a successfull system
call would.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.36 2005/09/15 21:09:30 miod Exp $	*/
d1245 1
a1245 4
	union args {
		register32_t i[8];
		register64_t l[8];
	} args;
d1309 1
a1309 1
		register64_t *argp;
d1319 1
a1319 1
				       (caddr_t)&args.l[nap], (i - nap) * sizeof(register64_t));
d1323 1
a1323 1
		for (argp = &args.l[0]; i--;) 
d1329 1
a1329 1
				   callp->sy_argsize, (register_t*)args.l);
a1333 1
#if !defined(COMPAT_NETBSD32)
a1335 41
#else
		register32_t *argp;
		int j = 0;

		/* 32-bit stack */
		callp += code;

		i = (long)callp->sy_argsize / sizeof(register32_t);
		if (i > nap) {	/* usually false */
			register32_t temp[6];
			if (i > 8)
				panic("syscall nargs");
			/* Read the whole block in */
			error = copyin((caddr_t)(u_long)(tf->tf_out[6] +
						 offsetof(struct frame32, fr_argx)),
				       (caddr_t)&temp, (i - nap) * sizeof(register32_t));
			/* Copy each to the argument array */
			for (j = 0; nap + j < i; j++)
				args.i[nap+j] = temp[j];
			i = nap;
		}
		/* Need to convert from int64 to int32 or we lose */
		for (argp = &args.i[0]; i--;) 
				*argp++ = *ap++;
#ifdef KTRACE
		if (KTRPOINT(p, KTR_SYSCALL)) {
			register_t temp[8];
			
			/* Need to xlate 32-bit->64-bit */
			i = (long)callp->sy_argsize / 
				sizeof(register32_t);
			for (j=0; j<i; j++) 
				temp[j] = args.i[j];
			ktrsyscall(p, code,
				   i * sizeof(register_t), (register_t *)temp);
		}
#endif
		if (error) {
			goto bad;
		}
#endif	/* !COMPAT_NETBSD32 */
d1338 1
a1338 1
	scdebug_call(p, code, (register_t *)&args);
d1344 1
a1344 1
		error = systrace_redirect(code, p, &args, rval);
d1347 1
a1347 1
		error = (*callp->sy_call)(p, &args, rval);
@


1.36
log
@Change child_return() to record a proper ktrace record for vfork child
processes.

ok art@@ uwe@@ (some time ago)
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.35 2005/04/21 04:39:35 mickey Exp $	*/
d1452 1
d1457 5
a1461 1
	userret(p, p->p_md.md_tf->tf_pc, 0);
@


1.35
log
@count fpu lazy context switches; deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.34 2005/03/29 19:34:07 kettenis Exp $	*/
d1460 1
a1460 1
			  (p->p_flag & P_PPWAIT) ? SYS_vfork : SYS_fork, 0, 0);
@


1.34
log
@sparc64 StackGhost.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.33 2004/12/06 20:12:25 miod Exp $	*/
d602 1
@


1.33
log
@Use uvm_grow() to account for stack growth, rather than home-grown code
or nothing.
Inspired by a similar recent change in NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.32 2004/08/09 10:13:23 miod Exp $	*/
d761 2
d764 3
a766 2
			if (copyout((caddr_t)&rw[i], (caddr_t)(u_long)rwdest,
			    sizeof(*rw))) {
@


1.32
log
@Needs a non-empty pmap_unuse_final() as sparc.
Spotted by: art@@ No cookie for: deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.31 2004/01/10 09:10:07 deraadt Exp $	*/
d890 3
a892 5
		if (rv == 0) {
			segsz_t nss = btoc(USRSTACK - va);
			if (nss > vm->vm_ssize)
				vm->vm_ssize = nss;
		} else if (rv == EACCES)
d1067 3
a1069 5
		if (rv == 0) {
			segsz_t nss = btoc(USRSTACK - va);
			if (nss > vm->vm_ssize)
				vm->vm_ssize = nss;
		} else if (rv == EACCES)
d1172 3
a1174 5
		if (rv == 0) {
			segsz_t nss = btoc(USRSTACK - va);
			if (nss > vm->vm_ssize)
				vm->vm_ssize = nss;
		} else if (rv == EACCES)
@


1.31
log
@spelling; jjy2+@@pitt.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.30 2003/07/14 02:03:16 jason Exp $	*/
d792 1
a792 1
kill_user_windows(p)
@


1.30
log
@For completeness, handle ldqf/stqf alignment faults by calling the emulation
routine.  According to the spec, ldqf/stqf requires word alignment, but
can generate a ldqf/stqf alignment exception if the data isn't quad word
aligned.  Since the emulation routine only requires word alignment anyway,
this seems to be the right thing to do.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.29 2003/07/10 19:33:19 jason Exp $	*/
d306 1
a306 1
	"set condision codes",	/* 133 */
d316 1
a316 1
	"OS vedor spec syscall",/* 166 */
@


1.29
log
@unifdef -UNEW_FPSTATE in attempt to make it more clear
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.28 2003/07/10 19:23:16 jason Exp $	*/
a607 2
		trapsignal(p, SIGILL, 0, ILL_ILLOPC, sv);	/* XXX code?? */
		break;
d609 17
a625 1
		trapsignal(p, SIGILL, 0, ILL_ILLOPC, sv);	/* XXX code?? */
d627 1
@


1.28
log
@small bit of cleaning
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.27 2003/07/10 15:26:54 jason Exp $	*/
a51 2
#define NEW_FPSTATE

a455 10
#ifndef NEW_FPSTATE
			if (fpproc != NULL) {	/* someone else had it */
				savefpstate(fpproc->p_md.md_fpstate);
				fpproc = NULL;
				/* Enable the FPU */
/*				loadfpstate(initfpstate);*/
			}
			tf->tf_tstate |= (PSTATE_PEF<<TSTATE_PSTATE_SHIFT);
			return;
#else
d458 1
a458 2
			/* New scheme */
			if (CLKF_INTR((struct clockframe *)tf) || !curproc) {
d460 1
a460 1
			} else {
d462 1
a462 1
			}
d465 1
a465 1
				/* someone else had it, maybe? */
a478 1
#endif
@


1.27
log
@- working emulation for POPC instruction
- good start are fully decoding LDQF(A)/STQF(A)
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.26 2003/07/09 23:56:16 jason Exp $	*/
a457 1
extern void db_printf(const char * , ...);
a573 2
		trapsignal(p, SIGILL, 0, ILL_ILLOPC, sv);	/* XXX code?? */
		break;
a574 2
		trapsignal(p, SIGILL, 0, ILL_ILLOPC, sv);	/* XXX code?? */
		break;
d595 1
a595 2
#ifdef notyet
			fpu_emulate(p, tf, fs);
a596 4
#else
			trapsignal(p, SIGFPE, 0, FPE_FLTINV, sv);	/* XXX code?? */
			break;
#endif
d598 1
@


1.26
log
@part of infrastructure to deal with emulated stqf/ldqf:
T_ILLINST handler fetches instruction and decodes it.  If it's stqf, ldqf,
stqfa, or ldqfa call emulation instead of SIGILL directly.
Note: this still SIGILL's in the end, the emulation isn't done yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.25 2003/07/09 15:52:53 jason Exp $	*/
d559 8
a566 1
			if (emul_qf(ins.i_int, p, sv))
@


1.25
log
@add trap entries for LDQF/STQF alignment faults, but handle them as
SIGILL for now.  Also split out T_INST_EXCEPT and T_TEXTFAULT from
T_ILLINST pending handling of LDQF/STQF illegal instruction faults.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.24 2003/02/17 01:29:20 henric Exp $	*/
d546 17
d565 2
@


1.24
log
@
Add support for the Sun Enterprise 450
Reduce the size of a GENERIC kernel by ~190k
Remove the nasty pointer/bus_space_handle_t casts
Adds debug bus_space code including the ability to trace
    bus operations (it actually works now).

The following rules are now followed (and verfified by the debug
code):

1.  A "bus_space_handle_t" may only be used with the
    "bus_space_tag_t" that created it.
2.  Only "bus_space_map()" may create "bus_space_handle_t"s.
3.  A "bus_space_handle_t" may not be modified after it has
    been created (other than being destroyed by "bus_space_unmap()").


Thanks to help from mcbride, marc, jason, drahn, to anyone that might
have slipped my mind at the moment.

ok jason@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.23 2002/10/12 01:09:43 krw Exp $	*/
d546 2
d549 2
a553 1

d603 7
@


1.23
log
@Remove more '\n's from panic() statements. Both trailing and leading.

Diff generated by Chris Kuethe.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.22 2002/07/24 00:48:25 art Exp $	*/
a930 2
	sv.sival_ptr = (void *)pc;

d938 2
@


1.22
log
@Support for non-exec page mappings.
 - split the one TSB into two - one for dmmu, one for immu.
 - don't load pages without PG_EXEC into the immu TSB.
 - support for setting correct permissions on exec faults.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.21 2002/06/23 03:03:15 deraadt Exp $	*/
d1009 1
a1009 1
		panic("text_access_fault: no curproc\n");
@


1.21
log
@uid_t is unsigned
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.20 2002/06/15 17:23:31 art Exp $	*/
d1018 1
a1018 1
	access_type = /* VM_PROT_EXECUTE| */VM_PROT_READ;
d1125 1
a1125 1
	access_type = /* VM_PROT_EXECUTE| */ VM_PROT_READ;
@


1.20
log
@Decruftification.

We will never have a.out kernels.
We will never have 32-bit kernels.
We will never have sun4c, sun4 and sun4m support in the sparc64 kernels.
We don't need support old netbsd libc.
The cpu will never be identified as some of the sun4c and sun4m types.
We don't need the gazillion of fields in cpuinfo that the sparc port uses.
Just generally remove dead code.

This is just a first step in making this meess readable.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.19 2002/05/16 21:11:18 miod Exp $	*/
d893 1
a893 1
			printf("UVM: pid %d (%s), uid %d killed: out of swap\n",
@


1.19
log
@Add systrace support to all the remaining architectures.

Tested by various people on various platforms, I'm willing to fix any
breakage this causes.

ok niels@@ deraadt@@ and mickey@@ (after his comments were applied)
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.18 2002/03/26 01:00:30 miod Exp $	*/
d1311 1
a1311 1
#if defined(__arch64__) && !defined(COMPAT_NETBSD32)
a1339 1
#if defined(__arch64__)
a1348 4
#else
			ktrsyscall(p, code,
				   callp->sy_argsize, (register_t *)args.i);
#endif
d1354 1
a1354 1
#endif	/* __arch64__ && !COMPAT_NETBSD32 */
@


1.18
log
@Honor psratio for addupc_task(), as other arches do.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.17 2002/03/14 01:26:45 millert Exp $	*/
d70 3
d1366 6
a1371 1
	error = (*callp->sy_call)(p, &args, rval);
@


1.17
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.16 2002/02/22 19:25:17 deraadt Exp $	*/
d371 5
a375 2
	if (p->p_flag & P_PROFIL)
		addupc_task(p, pc, (int)(p->p_sticks - oticks));
@


1.16
log
@a few sigval_ptr cases were returning pc instead of fault address
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.15 2002/01/23 15:19:10 jason Exp $	*/
d322 2
a323 2
static __inline void userret __P((struct proc *, int,  u_quad_t));
static __inline void share_fpu __P((struct proc *, struct trapframe64 *));
d325 10
a334 10
void trap __P((struct trapframe64 *tf, unsigned type, vaddr_t pc, long tstate));
void data_access_fault __P((struct trapframe64 *tf, unsigned type, vaddr_t pc, 
	vaddr_t va, vaddr_t sfva, u_long sfsr));
void data_access_error __P((struct trapframe64 *tf, unsigned type, 
	vaddr_t afva, u_long afsr, vaddr_t sfva, u_long sfsr));
void text_access_fault __P((struct trapframe64 *tf, unsigned type, 
	vaddr_t pc, u_long sfsr));
void text_access_error __P((struct trapframe64 *tf, unsigned type, 
	vaddr_t pc, u_long sfsr, vaddr_t afva, u_long afsr));
void syscall __P((struct trapframe64 *, register_t code, register_t pc));
@


1.15
log
@Use sparc64 fpu_extern.h not sparc.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.14 2001/11/28 13:47:39 art Exp $	*/
d620 1
d789 1
a789 1
	sv.sival_ptr = (void *)pc;
a1054 1
		sv.sival_ptr = (void *)va;
a1163 1
		sv.sival_ptr = (void *)va;
@


1.14
log
@Sync in more uvm changes from NetBSD.
This time we're getting rid of KERN_* and VM_PAGER_* error codes and
use errnos instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.13 2001/11/06 19:53:16 miod Exp $	*/
d90 1
a90 1
#include <sparc/fpu/fpu_extern.h>
@


1.14.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.15 2002/01/23 15:19:10 jason Exp $	*/
d90 1
a90 1
#include <sparc64/fpu/fpu_extern.h>
@


1.14.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.14.2.1 2002/01/31 22:55:25 niklas Exp $	*/
a69 3
#include "systrace.h"
#include <dev/systrace.h>

d322 2
a323 2
static __inline void userret(struct proc *, int,  u_quad_t);
static __inline void share_fpu(struct proc *, struct trapframe64 *);
d325 10
a334 10
void trap(struct trapframe64 *tf, unsigned type, vaddr_t pc, long tstate);
void data_access_fault(struct trapframe64 *tf, unsigned type, vaddr_t pc, 
	vaddr_t va, vaddr_t sfva, u_long sfsr);
void data_access_error(struct trapframe64 *tf, unsigned type, 
	vaddr_t afva, u_long afsr, vaddr_t sfva, u_long sfsr);
void text_access_fault(struct trapframe64 *tf, unsigned type, 
	vaddr_t pc, u_long sfsr);
void text_access_error(struct trapframe64 *tf, unsigned type, 
	vaddr_t pc, u_long sfsr, vaddr_t afva, u_long afsr);
void syscall(struct trapframe64 *, register_t code, register_t pc);
d371 2
a372 5
	if (p->p_flag & P_PROFIL) {
		extern int psratio;

		addupc_task(p, pc, (int)(p->p_sticks - oticks) * psratio);
	}
a619 1
		/* XXX sv.sival_ptr should be the fault address! */
d788 1
a788 1
	sv.sival_ptr = (void *)addr;
d1054 1
d1164 1
d1361 1
a1361 6
#if NSYSTRACE > 0
	if (ISSET(p->p_flag, P_SYSTRACE))
		error = systrace_redirect(code, p, &args, rval);
	else
#endif
		error = (*callp->sy_call)(p, &args, rval);
@


1.14.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.14.2.2 2002/06/11 03:38:44 art Exp $	*/
d893 1
a893 1
			printf("UVM: pid %d (%s), uid %u killed: out of swap\n",
d1009 1
a1009 1
		panic("text_access_fault: no curproc");
d1018 1
a1018 1
	access_type = VM_PROT_EXECUTE;
d1125 1
a1125 1
	access_type = VM_PROT_EXECUTE;
d1311 1
a1311 1
#if !defined(COMPAT_NETBSD32)
d1340 1
d1350 4
d1359 1
a1359 1
#endif	/* !COMPAT_NETBSD32 */
@


1.14.2.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d931 2
a939 2

	sv.sival_ptr = (void *)pc;
@


1.13
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.12 2001/11/06 19:25:56 art Exp $	*/
d859 2
a860 2
		} else if (rv == KERN_PROTECTION_FAILURE)
			rv = KERN_INVALID_ADDRESS;
d885 1
a885 1
		if (rv == KERN_RESOURCE_SHORTAGE) {
d1038 2
a1039 2
		} else if (rv == KERN_PROTECTION_FAILURE)
			rv = KERN_INVALID_ADDRESS;
d1132 1
a1132 1
	rv = uvm_fault(&vm->vm_map, (vaddr_t)va, 0, access_type);
d1146 2
a1147 2
		} else if (rv == KERN_PROTECTION_FAILURE)
			rv = KERN_INVALID_ADDRESS;
@


1.12
log
@unbreak child_return.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.11 2001/09/28 14:43:13 art Exp $	*/
a69 1
#include <vm/vm.h>
@


1.11
log
@Almost half of this file was ifdef DEBUG. Everybody knows that debugging
code is just there for debugging so it doesn't need to be pretty or really
correct. In most cases it's just a bunch of printfs that only the author
understands for two hours after writing them.

Remove all that noise to make this file actually readable and as a bouns
fix a bug where any user could crash the kernel (not really crash, but
triggering ddb from userland is equivalent to crash in my world even if you
can just press 'c').
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.10 2001/09/28 13:02:46 art Exp $	*/
d1418 2
a1419 2
child_return(p)
	struct proc *p;
d1421 1
@


1.11.4.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.11.4.2
log
@Merge in -current
@
text
@d70 1
d1418 2
a1419 2
child_return(arg)
	void *arg;
a1420 1
	struct proc *p = (struct proc *)arg;
@


1.11.4.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.11.4.2 2001/11/13 21:04:17 niklas Exp $	*/
d859 2
a860 2
		} else if (rv == EACCES)
			rv = EFAULT;
d885 1
a885 1
		if (rv == ENOMEM) {
d1038 2
a1039 2
		} else if (rv == EACCES)
			rv = EFAULT;
d1132 1
a1132 1
	rv = uvm_fault(&vm->vm_map, va, 0, access_type);
d1146 2
a1147 2
		} else if (rv == EACCES)
			rv = EFAULT;
@


1.11.4.4
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d90 1
a90 1
#include <sparc64/fpu/fpu_extern.h>
a619 1
		/* XXX sv.sival_ptr should be the fault address! */
d788 1
a788 1
	sv.sival_ptr = (void *)addr;
d1054 1
d1164 1
@


1.11.4.5
log
@Merge in -current from about a week ago
@
text
@d322 2
a323 2
static __inline void userret(struct proc *, int,  u_quad_t);
static __inline void share_fpu(struct proc *, struct trapframe64 *);
d325 10
a334 10
void trap(struct trapframe64 *tf, unsigned type, vaddr_t pc, long tstate);
void data_access_fault(struct trapframe64 *tf, unsigned type, vaddr_t pc, 
	vaddr_t va, vaddr_t sfva, u_long sfsr);
void data_access_error(struct trapframe64 *tf, unsigned type, 
	vaddr_t afva, u_long afsr, vaddr_t sfva, u_long sfsr);
void text_access_fault(struct trapframe64 *tf, unsigned type, 
	vaddr_t pc, u_long sfsr);
void text_access_error(struct trapframe64 *tf, unsigned type, 
	vaddr_t pc, u_long sfsr, vaddr_t afva, u_long afsr);
void syscall(struct trapframe64 *, register_t code, register_t pc);
@


1.11.4.6
log
@Sync the SMP branch with 3.3
@
text
@a69 3
#include "systrace.h"
#include <dev/systrace.h>

d371 2
a372 5
	if (p->p_flag & P_PROFIL) {
		extern int psratio;

		addupc_task(p, pc, (int)(p->p_sticks - oticks) * psratio);
	}
d887 1
a887 1
			printf("UVM: pid %d (%s), uid %u killed: out of swap\n",
d925 2
a934 2
	sv.sival_ptr = (void *)pc;

d1003 1
a1003 1
		panic("text_access_fault: no curproc");
d1012 1
a1012 1
	access_type = VM_PROT_EXECUTE;
d1119 1
a1119 1
	access_type = VM_PROT_EXECUTE;
d1305 1
a1305 1
#if !defined(COMPAT_NETBSD32)
d1334 1
d1344 4
d1353 1
a1353 1
#endif	/* !COMPAT_NETBSD32 */
d1360 1
a1360 6
#if NSYSTRACE > 0
	if (ISSET(p->p_flag, P_SYSTRACE))
		error = systrace_redirect(code, p, &args, rval);
	else
#endif
		error = (*callp->sy_call)(p, &args, rval);
@


1.11.4.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d52 2
d308 1
a308 1
	"set condition codes",	/* 133 */
d318 1
a318 1
	"OS vendor spec syscall",	/* 166 */
d458 11
d471 2
a472 1
			if (CLKF_INTR((struct clockframe *)tf) || !curproc)
d474 1
a474 1
			else
d476 1
a476 1

d479 1
a479 1
					/* someone else had it, maybe? */
d493 1
d546 2
a547 24
	{
		union instr ins;

		if (copyin((caddr_t)pc, &ins, sizeof(ins)) != 0) {
			/* XXX Can this happen? */
			trapsignal(p, SIGILL, 0, ILL_ILLOPC, sv);
			break;
		}
		if (ins.i_any.i_op == IOP_mem &&
		    (ins.i_op3.i_op3 == IOP3_LDQF ||
		     ins.i_op3.i_op3 == IOP3_STQF ||
		     ins.i_op3.i_op3 == IOP3_LDQFA ||
		     ins.i_op3.i_op3 == IOP3_STQFA)) {
			if (emul_qf(ins.i_int, p, sv, tf))
				ADVANCE;
			break;
		}
		if (ins.i_any.i_op == IOP_reg &&
		    ins.i_op3.i_op3 == IOP3_POPC &&
		    ins.i_op3.i_rs1 == 0) {
			if (emul_popc(ins.i_int, p, sv, tf))
				ADVANCE;
			break;
		}
a549 1
	}
a550 2
	case T_INST_EXCEPT:
	case T_TEXTFAULT:
d571 5
a575 1
			trapsignal(p, SIGFPE, 0, FPE_FLTINV, sv);
d577 1
a578 1

a597 22
		break;
	}

	case T_LDQF_ALIGN:
	case T_STQF_ALIGN:
	{
		union instr ins;

		if (copyin((caddr_t)pc, &ins, sizeof(ins)) != 0) {
			/* XXX Can this happen? */
			trapsignal(p, SIGILL, 0, ILL_ILLOPC, sv);
			break;
		}
		if (ins.i_any.i_op == IOP_mem &&
		    (ins.i_op3.i_op3 == IOP3_LDQF ||
		     ins.i_op3.i_op3 == IOP3_STQF ||
		     ins.i_op3.i_op3 == IOP3_LDQFA ||
		     ins.i_op3.i_op3 == IOP3_STQFA)) {
			if (emul_qf(ins.i_int, p, sv, tf))
				ADVANCE;
		} else
			trapsignal(p, SIGILL, 0, ILL_ILLOPC, sv);
@


1.10
log
@Don't spam the console with userland alignemnt errors.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.9 2001/09/20 21:29:26 jason Exp $	*/
a97 9
#ifdef DEBUG
/* What trap level are we running? */
#define tl() ({ \
	int l; \
	__asm __volatile("rdpr %%tl, %0" : "=r" (l) :); \
	l; \
})
#endif

a123 32
#ifdef DEBUG
#define RW_64		0x1
#define RW_ERR		0x2
#define RW_FOLLOW	0x4
int	rwindow_debug = RW_ERR;
#define TDB_ADDFLT	0x1
#define TDB_TXTFLT	0x2
#define TDB_TRAP	0x4
#define TDB_SYSCALL	0x8
#define TDB_FOLLOW	0x10
#define TDB_FRAME	0x20
#define TDB_NSAVED	0x40
#define TDB_TL		0x80
#define TDB_STOPSIG	0x100
#define TDB_STOPCALL	0x200
#define TDB_STOPCPIO	0x400
#define TDB_SYSTOP	0x800
int	trapdebug = TDB_SYSCALL|TDB_STOPSIG|TDB_STOPCPIO|TDB_ADDFLT;
/* #define __inline */
#endif

#ifdef DDB
#if 1
#define DEBUGGER(t,f)	do { kdb_trap(t,f); } while (0)
#else
#define DEBUGGER(t,f)	Debugger()
#endif
#else
#define DEBUGGER(t,f)
#define Debugger()
#endif

a336 38
#ifdef DEBUG
void print_trapframe __P((struct trapframe64 *));
void
print_trapframe(tf)
	struct trapframe64 *tf;
{

	printf("Trapframe %p:\ttstate: %lx\tpc: %lx\tnpc: %lx\n",
	       tf, (u_long)tf->tf_tstate, (u_long)tf->tf_pc, (u_long)tf->tf_npc);
	printf("fault: %p\tkstack: %p\ty: %x\t", 
	       (void *)(u_long)tf->tf_fault, (void *)(u_long)tf->tf_kstack,
	       (int)tf->tf_y);
	printf("pil: %d\toldpil: %d\ttt: %x\tGlobals:\n", 
	       (int)tf->tf_pil, (int)tf->tf_oldpil, (int)tf->tf_tt);
	printf("%08x%08x %08x%08x %08x%08x %08x%08x\n",
	       (u_int)(tf->tf_global[0]>>32), (u_int)tf->tf_global[0],
	       (u_int)(tf->tf_global[1]>>32), (u_int)tf->tf_global[1],
	       (u_int)(tf->tf_global[2]>>32), (u_int)tf->tf_global[2],
	       (u_int)(tf->tf_global[3]>>32), (u_int)tf->tf_global[3]);
	printf("%08x%08x %08x%08x %08x%08x %08x%08x\nouts:\n",
	       (u_int)(tf->tf_global[4]>>32), (u_int)tf->tf_global[4],
	       (u_int)(tf->tf_global[5]>>32), (u_int)tf->tf_global[5],
	       (u_int)(tf->tf_global[6]>>32), (u_int)tf->tf_global[6],
	       (u_int)(tf->tf_global[7]>>32), (u_int)tf->tf_global[7]);
	printf("%08x%08x %08x%08x %08x%08x %08x%08x\n",
	       (u_int)(tf->tf_out[0]>>32), (u_int)tf->tf_out[0],
	       (u_int)(tf->tf_out[1]>>32), (u_int)tf->tf_out[1],
	       (u_int)(tf->tf_out[2]>>32), (u_int)tf->tf_out[2],
	       (u_int)(tf->tf_out[3]>>32), (u_int)tf->tf_out[3]);
	printf("%08x%08x %08x%08x %08x%08x %08x%08x\n",
	       (u_int)(tf->tf_out[4]>>32), (u_int)tf->tf_out[4],
	       (u_int)(tf->tf_out[5]>>32), (u_int)tf->tf_out[5],
	       (u_int)(tf->tf_out[6]>>32), (u_int)tf->tf_out[6],
	       (u_int)(tf->tf_out[7]>>32), (u_int)tf->tf_out[7]);

}
#endif

a421 40
#ifdef DEBUG
	if (tf->tf_pc == tf->tf_npc) {
		printf("trap: tpc %p == tnpc %p\n",
		    (void *)(u_long)tf->tf_pc, (void *)(u_long)tf->tf_npc);
		Debugger();
	}
#if 0
	{
		/* Check to make sure we're on the normal stack */
		int* sp;

		__asm("mov %%sp, %0" : "=r" (sp) :);
		if (sp < EINTSTACK) {
			printf("trap: We're on the interrupt stack!\ntype=0x%x tf=%p %s\n", 
			       type, tf, type < N_TRAP_TYPES ? trap_type[type] : 
			       ((type == T_AST) ? "ast" : 
				((type == T_RWRET) ? "rwret" : T)));
		}
	}
#endif
#endif


#ifdef DEBUG
	if ((trapdebug&TDB_NSAVED && cpcb->pcb_nsaved) || trapdebug&(TDB_FOLLOW|TDB_TRAP)) {
		printf("trap: type 0x%x: pc=%lx &tf=%p\n",
		       type, pc, tf);
		printf(" npc=%lx pstate=%b %s\n",
		       (long)tf->tf_npc, pstate, PSTATE_BITS,
		       type < N_TRAP_TYPES ? trap_type[type] : 
		       ((type == T_AST) ? "ast" : 
			((type == T_RWRET) ? "rwret" : T)));
	}
#if 0
	if (trapdebug & TDB_FRAME) {
		print_trapframe(tf);
	}
#endif
#endif

a422 16
#ifdef DEBUG
	if ((trapdebug&(TDB_FOLLOW|TDB_TRAP)) || ((trapdebug & TDB_TL) && tl())) {
		extern int trap_trace_dis;
		trap_trace_dis = 1;
		printf("trap: type 0x%x: lvl=%d pc=%lx &tf=%p",
		       type, (int)tl(), pc, tf);
		printf(" npc=%lx pstate=%b %s\n",
		       (long)tf->tf_npc, pstate, PSTATE_BITS,
		       type < N_TRAP_TYPES ? trap_type[type] : 
		       ((type == T_AST) ? "ast" : 
			((type == T_RWRET) ? "rwret" : T)));
#ifdef DDB
		kdb_trap(type, tf);
#endif
	}
#endif
a508 1
			DEBUGGER(type, tf);
a514 4
		/* the following message is gratuitous */
		/* ... but leave it in until we find anything */
		printf("%s[%d]: unimplemented software trap 0x%x\n",
		    p->p_comm, p->p_pid, type);
a542 7
		/* This is not an MMU issue!!!! */
		printf("trap: textfault at %lx!! sending SIGILL due to trap %d: %s\n", 
		       pc, type, type < N_TRAP_TYPES ? trap_type[type] : T);
#if defined(DDB) && defined(DEBUG)
		if (trapdebug & TDB_STOPSIG)
			Debugger();
#endif
a546 6
		printf("trap: privinst!! sending SIGILL due to trap %d: %s\n", 
		       type, type < N_TRAP_TYPES ? trap_type[type] : T);
#if defined(DDB) && defined(DEBUG)
		if (trapdebug & TDB_STOPSIG)
			Debugger();
#endif
a581 1

a613 8
		
#define fmt64(x)	(u_int)((x)>>32), (u_int)((x))
#ifdef DEBUG
		printf("Alignment error: dsfsr=%08x:%08x dsfar=%x:%x isfsr=%08x:%08x pc=%lx\n",
		       fmt64(dsfsr), fmt64(dsfar), fmt64(isfsr), pc);
#endif
		uprintf("Alignment error: pid=%d comm=%s dsfsr=%08x:%08x dsfar=%x:%x isfsr=%08x:%08x pc=%lx\n",
		       p->p_pid, p->p_comm, fmt64(dsfsr), fmt64(dsfar), fmt64(isfsr), pc);
a615 6
#if defined(DDB) && defined(DEBUG)
	if (trapdebug & TDB_STOPSIG) {
		write_all_windows();
		kdb_trap(type, tf);
	}
#endif
a676 1
		printf("T_RANGECHECK\n");	/* XXX */
a698 11
#ifdef DEBUG
	if (trapdebug&(TDB_FOLLOW|TDB_TRAP)) {
		printf("trap: done\n");
		/* if (type != T_BREAKPOINT) Debugger(); */
	}
#if 0
	if (trapdebug & TDB_FRAME) {
		print_trapframe(tf);
	}
#endif
#endif
a721 4
#ifdef DEBUG
	if (rwindow_debug&RW_FOLLOW)
		printf("rwindow_save(%p): nsaved %d\n", p, i);
#endif
a723 4
#ifdef DEBUG
	if (rwindow_debug&RW_FOLLOW)
		printf("%s[%d]: rwindow: pcb->stack:", p->p_comm, p->p_pid);
#endif
a725 4
#ifdef DEBUG
		if (rwindow_debug&RW_FOLLOW)
			printf("window %d at %lx\n", i, (long)rwdest);
#endif
a726 7
#ifdef DEBUG
			if (rwindow_debug&RW_64) {
				printf("rwindow_save: 64-bit tf to %p+BIAS or %p\n", 
				       (void *)(long)rwdest, (void *)(long)(rwdest+BIAS));
				Debugger();
			}
#endif
d729 1
a729 6
				    sizeof(*rw))) {
#ifdef DEBUG
			if (rwindow_debug&(RW_ERR|RW_64))
				printf("rwindow_save: 64-bit pcb copyout to %p failed\n", 
				       (void *)(long)rwdest);
#endif
a731 8
#ifdef DEBUG
			if (rwindow_debug&RW_64) {
				printf("Finished copyout(%p, %p, %lx)\n",
					(caddr_t)&rw[i], (caddr_t)(long)rwdest,
                                	sizeof(*rw));
				Debugger();
			}
#endif
d741 2
a742 6
			if (copyout(&rwstack, (caddr_t)(u_long)(u_int)rwdest, sizeof(rwstack))) {
#ifdef DEBUG
				if (rwindow_debug&RW_ERR)
					printf("rwindow_save: 32-bit pcb copyout to %p (%p) failed\n", 
					       (void *)(u_long)(u_int)rwdest, (void *)(u_long)rwdest);
#endif
d748 1
a748 6
#ifdef DEBUG
	if (rwindow_debug&RW_FOLLOW) {
		printf("\n");
		Debugger();
	}
#endif
a786 4
#ifdef DEBUG
	static int lastdouble;
	extern struct pcb* cpcb;
#endif
a789 32
#ifdef DEBUG
	if (tf->tf_pc == tf->tf_npc) {
		printf("data_access_fault: tpc %lx == tnpc %lx\n", 
		       (long)tf->tf_pc, (long)tf->tf_npc);
		Debugger();
	}
	write_user_windows();
	if ((cpcb->pcb_nsaved > 8) ||
	    (trapdebug&TDB_NSAVED && cpcb->pcb_nsaved) ||
	    (trapdebug&(TDB_ADDFLT|TDB_FOLLOW))) {
		printf("%ld: data_access_fault(%p, %x, %p, %p, %lx, %lx) "
			"nsaved=%d\n",
			(long)(curproc?curproc->p_pid:-1), tf, type,
			(void*)addr, (void*)pc,
			sfva, sfsr, (int)cpcb->pcb_nsaved);
		if ((trapdebug&TDB_NSAVED && cpcb->pcb_nsaved)) Debugger();
	}
	if (trapdebug & TDB_FRAME) {
		print_trapframe(tf);
	}
	if ((trapdebug & TDB_TL) && tl()) {
		printf("%ld: data_access_fault(%p, %x, %p, %p, %lx, %lx) "
			"nsaved=%d\n",
			(long)(curproc?curproc->p_pid:-1), tf, type,
			(void*)addr, (void*)pc,
			sfva, sfsr, (int)cpcb->pcb_nsaved);
		Debugger();
	}
	if (trapdebug&TDB_STOPCALL) { 
		Debugger();
	}
#endif
a795 14
#if 0
	/* 
	 * This can happen when we're in DDB w/curproc == NULL and try
	 * to access user space.
	 */
#ifdef DIAGNOSTIC
	if ((addr & PAGE_MASK) && 
	    (addr & PAGE_MASK) != p->p_vmspace->vm_map.pmap->pm_ctx) {
		printf("data_access_fault: va ctx %x != pm ctx %x\n",
		       (addr & PAGE_MASK), p->p_vmspace->vm_map.pmap->pm_ctx);
		Debugger();
	}
#endif
#endif
a800 16
#ifdef DEBUG
	if (lastdouble) {
		printf("stacked data fault @@ %lx (pc %lx);", addr, pc);
		lastdouble = 0;
		if (curproc == NULL)
			printf("NULL proc\n");
#if 0
		else
			printf("pid %d(%s); sigmask %x, sigcatch %x\n",
			       curproc->p_pid, curproc->p_comm,
				/* XXX */
			       curproc->p_sigctx.ps_sigmask.__bits[0], 
			       curproc->p_sigctx.ps_sigcatch.__bits[0]);
#endif
	}
#endif
d831 1
a831 1
		if (!(addr&TLB_TAG_ACCESS_CTX)) {
a833 9
#ifdef DEBUG
			if (trapdebug&(TDB_ADDFLT|TDB_FOLLOW))
				printf("data_access_fault: kernel "
					"uvm_fault(%p, %lx, %x, %x) "
					"sez %x -- %s\n",
					kernel_map, (vaddr_t)va, 0,
					access_type, rv,
					rv ? "failure" : "success");
#endif
a847 8
#ifdef DEBUG
	if (trapdebug&(TDB_ADDFLT|TDB_FOLLOW))
		printf("data_access_fault: %s uvm_fault(%p, %lx, %x, %x) "
			"sez %x -- %s\n",
			&vm->vm_map == kernel_map ? "kernel!!!" : "user",
			&vm->vm_map, (vaddr_t)va, 0, access_type, rv,
			rv ? "failure" : "success");
#endif
a878 1
				DEBUGGER(type, tf);
a881 6
#ifdef DEBUG
			if (trapdebug&(TDB_ADDFLT|TDB_FOLLOW|TDB_STOPCPIO)) {
				printf("data_access_fault: copyin/out of %p fault -- recover\n", (void *)addr);
				DEBUGGER(type, tf);
			}
#endif
a885 13
#ifdef DEBUG
		if (trapdebug&(TDB_ADDFLT|TDB_STOPSIG)) {
			extern int trap_trace_dis;
			trap_trace_dis = 1;
			printf("data_access_fault at addr %p: sending SIGSEGV\n", (void *)addr);
			printf("%ld: data_access_fault(%p, %x, %p, %p, %lx, %lx) "
				"nsaved=%d\n",
				(long)(curproc?curproc->p_pid:-1), tf, type,
				(void*)addr, (void*)pc,
				sfva, sfsr, (int)cpcb->pcb_nsaved);
			Debugger();
		}
#endif
a899 13
#ifdef DEBUG
	if (trapdebug&(TDB_ADDFLT|TDB_FOLLOW))
		printf("data_access_fault: done\n");
	if (trapdebug & TDB_FRAME) {
		print_trapframe(tf);
	}
	if (trapdebug&(TDB_ADDFLT|TDB_FOLLOW)) {
		extern void* return_from_trap __P((void));
		if ((void *)(u_long)tf->tf_pc == (void *)return_from_trap) {
			printf("Returning from stack datafault\n");
		}
	}
#endif
a922 3
#ifdef DEBUG
	static int lastdouble;
#endif
a926 29
#ifdef DEBUG
	if (tf->tf_pc == tf->tf_npc) {
		printf("data_access_error: tpc %lx == tnpc %lx\n", 
		       (long)tf->tf_pc, (long)tf->tf_npc);
		Debugger();
	}
	write_user_windows();
	if ((trapdebug&TDB_NSAVED && cpcb->pcb_nsaved) || 
	    trapdebug&(TDB_ADDFLT|TDB_FOLLOW)) {
		printf("%d data_access_error(%lx, %lx, %lx, %p)=%lx @@ %p %b\n",
		       curproc?curproc->p_pid:-1, 
		       (long)type, (long)sfva, (long)afva, tf, (long)tf->tf_tstate, 
		       (void *)(u_long)tf->tf_pc, sfsr, SFSR_BITS);
	}
	if (trapdebug & TDB_FRAME) {
		print_trapframe(tf);
	}
	if ((trapdebug & TDB_TL) && tl()) {
		printf("%d tl %ld data_access_error(%lx, %lx, %lx, %p)=%lx @@ %lx %b\n",
		       curproc?curproc->p_pid:-1, (long)tl(),
		       (long)type, (long)sfva, (long)afva, tf, (long)tf->tf_tstate, 
		       (long)tf->tf_pc, sfsr, SFSR_BITS);
		Debugger();
	}
	if (trapdebug&TDB_STOPCALL) { 
		Debugger();
	}
#endif

a943 17
#ifdef DEBUG
	if (lastdouble) {
		printf("stacked data error @@ %lx (pc %lx); sfsr %lx", sfva, pc, sfsr);
		lastdouble = 0;
		if (curproc == NULL)
			printf("NULL proc\n");
#if 0
		else
			printf("pid %d(%s); sigmask %x, sigcatch %x\n",
			       curproc->p_pid, curproc->p_comm,
				/* XXX */
			       curproc->p_sigctx.ps_sigmask.__bits[0], 
			       curproc->p_sigctx.ps_sigcatch.__bits[0]);
#endif
	}
#endif

a952 1
			DEBUGGER(type, tf);
a965 6
#ifdef DEBUG
		if (trapdebug&(TDB_ADDFLT|TDB_FOLLOW|TDB_STOPCPIO)) {
			printf("data_access_error: kern fault -- skipping instr\n");
			if (trapdebug&TDB_STOPCPIO) DEBUGGER(type, tf);
		}
#endif
d970 1
a970 9
#ifdef DEBUG
	if (trapdebug&(TDB_ADDFLT|TDB_STOPSIG)) {
		extern int trap_trace_dis;
		trap_trace_dis = 1;
		printf("data_access_error at %p: sending SIGSEGV\n",
			(void *)(u_long)afva);
		Debugger();
	}
#endif
a976 7
#ifdef DEBUG
	if (trapdebug&(TDB_ADDFLT|TDB_FOLLOW))
		printf("data_access_error: done\n");
	if (trapdebug & TDB_FRAME) {
		print_trapframe(tf);
	}
#endif
a1000 23
#ifdef DEBUG
	if (tf->tf_pc == tf->tf_npc) {
		printf("text_access_fault: tpc %p == tnpc %p\n", (void *)(u_long)tf->tf_pc, (void *)(u_long)tf->tf_npc);
		Debugger();
	}
	write_user_windows();
	if (((trapdebug&TDB_NSAVED) && cpcb->pcb_nsaved) || 
	    (trapdebug&(TDB_TXTFLT|TDB_FOLLOW)))
		printf("%d text_access_fault(%x, %lx, %p)\n",
		       curproc?curproc->p_pid:-1, type, pc, tf); 
	if (trapdebug & TDB_FRAME) {
		print_trapframe(tf);
	}
	if ((trapdebug & TDB_TL) && tl()) {
		printf("%d tl %d text_access_fault(%x, %lx, %p)\n",
		       curproc?curproc->p_pid:-1, tl(), type, pc, tf); 
		Debugger();
	}
	if (trapdebug&TDB_STOPCALL) { 
		Debugger();
	}
#endif

a1017 1
		DEBUGGER(type, tf);
a1026 5
#ifdef DEBUG
	if (trapdebug&(TDB_TXTFLT|TDB_FOLLOW))
		printf("text_access_fault: uvm_fault(%p, %lx, %x, FALSE) sez %x\n",
		       &vm->vm_map, va, 0, rv);
#endif
a1051 1
			DEBUGGER(type, tf);
a1054 8
#ifdef DEBUG
		if (trapdebug&(TDB_TXTFLT|TDB_STOPSIG)) {
			extern int trap_trace_dis;
			trap_trace_dis = 1;
			printf("text_access_fault at %p: sending SIGSEGV\n", (void *)(u_long)va);
			Debugger();
		}
#endif
a1061 9
#ifdef DEBUG
	if (trapdebug&(TDB_TXTFLT|TDB_FOLLOW)) {
		printf("text_access_fault: done\n");
		/* kdb_trap(T_BREAKPOINT, tf); */
	}
	if (trapdebug & TDB_FRAME) {
		print_trapframe(tf);
	}
#endif
d1089 1
a1089 3
#ifdef DEBUG
	static int lastdouble;
#endif
a1090 27
#ifdef DEBUG
	if (tf->tf_pc == tf->tf_npc) {
		printf("text_access_error: tpc %p == tnpc %p\n",
		    (void *)(u_long)tf->tf_pc, (void *)(u_long)tf->tf_npc);
		Debugger();
	}
	write_user_windows();
	if ((trapdebug&TDB_NSAVED && cpcb->pcb_nsaved) || trapdebug&(TDB_TXTFLT|TDB_FOLLOW)) {
		printf("%ld text_access_error(%lx, %lx, %lx, %p)=%lx @@ %lx %b\n",
		       (long)(curproc?curproc->p_pid:-1), 
		       (long)type, pc, (long)afva, tf, (long)tf->tf_tstate, 
		       (long)tf->tf_pc, sfsr, SFSR_BITS);
	}
	if (trapdebug & TDB_FRAME) {
		print_trapframe(tf);
	}
	if ((trapdebug & TDB_TL) && tl()) {
		printf("%ld tl %ld text_access_error(%lx, %lx, %lx, %p)=%lx @@ %lx %b\n",
		       (long)(curproc?curproc->p_pid:-1), (long)tl(),
		       (long)type, (long)pc, (long)afva, tf, 
		       (long)tf->tf_tstate, (long)tf->tf_pc, sfsr, SFSR_BITS);
		Debugger();
	}
	if (trapdebug&TDB_STOPCALL) { 
		Debugger();
	}
#endif
a1118 16
#ifdef DEBUG
	if (lastdouble) {
		printf("stacked text error @@ pc %lx; sfsr %lx", pc, sfsr);
		lastdouble = 0;
		if (curproc == NULL)
			printf("NULL proc\n");
#if 0
		else
			printf("pid %d(%s); sigmask %x, sigcatch %x\n",
			       curproc->p_pid, curproc->p_comm,
				/* XXX */
			       curproc->p_sigctx.ps_sigmask.__bits[0], 
			       curproc->p_sigctx.ps_sigcatch.__bits[0]);
#endif
	}
#endif
a1119 1

a1125 1
		DEBUGGER(type, tf);
a1161 1
			DEBUGGER(type, tf);
a1164 9
#ifdef DEBUG
		if (trapdebug&(TDB_TXTFLT|TDB_STOPSIG)) {
			extern int trap_trace_dis;
			trap_trace_dis = 1;
			printf("text_access_error at %p: sending SIGSEGV\n",
			    (void *)(u_long)va);
			Debugger();
		}
#endif
a1172 7
#ifdef DEBUG
	if (trapdebug&(TDB_TXTFLT|TDB_FOLLOW))
		printf("text_access_error: done\n");
	if (trapdebug & TDB_FRAME) {
		print_trapframe(tf);
	}
#endif
a1224 20
#ifdef DEBUG
	write_user_windows();
	if (tf->tf_pc == tf->tf_npc) {
		printf("syscall: tpc %p == tnpc %p\n", (void *)(u_long)tf->tf_pc,
		    (void *)(u_long)tf->tf_npc);
		Debugger();
	}
	if ((trapdebug&TDB_NSAVED && cpcb->pcb_nsaved) || trapdebug&(TDB_SYSCALL|TDB_FOLLOW))
		printf("%d syscall(%lx, %p, %lx)\n",
		       curproc?curproc->p_pid:-1, (u_long)code, tf, (u_long)pc); 
	if (trapdebug & TDB_FRAME) {
		print_trapframe(tf);
	}
	if ((trapdebug & TDB_TL) && tl()) {
		printf("%d tl %d syscall(%lx, %p, %lx)\n",
		       curproc?curproc->p_pid:-1, tl(), (u_long)code, tf, (u_long)pc); 
		Debugger();
	}
#endif

a1278 17
#ifdef DEBUG
/*	printf("code=%x, nsys=%x\n", code, nsys); */
	if (trapdebug&(TDB_SYSCALL|TDB_FOLLOW))
		printf("%d syscall(%d[%x]): tstate=%x:%x %s\n", 
		       curproc?curproc->p_pid:-1, (int)code, (u_int)code,
		       (int)(tf->tf_tstate>>32), (int)(tf->tf_tstate),
		       (p->p_emul->e_syscallnames) ?
		       ((code < 0 || code >= nsys) ? 
			"illegal syscall" : 
			p->p_emul->e_syscallnames[code]) :
		       "unknown syscall");
	if (p->p_emul->e_syscallnames)
		p->p_addr->u_pcb.lastcall = 
			((code < 0 || code >= nsys) ? 
			 "illegal syscall" : 
			 p->p_emul->e_syscallnames[code]);
#endif
d1283 1
a1283 7
#ifndef __arch64__
#ifdef DEBUG
		printf("syscall(): 64-bit stack on a 32-bit kernel????\n");
		Debugger();
#endif
#endif
		/* 64-bit stack -- not really supported on 32-bit kernels */
a1285 10
#ifdef DEBUG
		if (i != (long)callp->sy_argsize / sizeof(register64_t))
			printf("syscall %s: narg=%hd, argsize=%hd, call=%p, argsz/reg64=%ld\n",
			       (p->p_emul->e_syscallnames) ? ((code < 0 || code >= nsys) ? 
							      "illegal syscall" : 
							      p->p_emul->e_syscallnames[code])
			       : "unknown syscall", 
			       callp->sy_narg, callp->sy_argsize, callp->sy_call, 
			       (long)callp->sy_argsize / sizeof(register64_t));
#endif
a1286 5
#ifdef DEBUG
			if (trapdebug&(TDB_SYSCALL|TDB_FOLLOW) || i>8) {
				printf("Args64 %d>%d -- need to copyin\n", i , nap);
			}
#endif
d1304 2
a1305 12
		if (error) goto bad;
#ifdef DEBUG
		if (trapdebug&(TDB_SYSCALL|TDB_FOLLOW)) {
			for (i=0; i < callp->sy_narg; i++) 
				printf("arg[%d]=%lx ", i, (long)(args.l[i]));
			printf("\n");
		}
		if (trapdebug&(TDB_STOPCALL)) { 
			printf("stop precall\n");
			Debugger();
		}
#endif
d1307 4
a1316 7
#if defined(__arch64__) && !defined(COMPAT_NETBSD32)
		{
			printf("syscall(): 32-bit stack on a 64-bit kernel????\n");
			Debugger();
		}
#endif

a1319 4
#ifdef DEBUG
			if (trapdebug&(TDB_SYSCALL|TDB_FOLLOW) || i>8)
				printf("Args %d>%d -- need to copyin\n", i , nap);
#endif
a1328 9
#ifdef DEBUG
			if (trapdebug & (TDB_SYSCALL|TDB_FOLLOW))	{ 
				int k;
				printf("Copyin args of %d from %p:\n", j, 
				       (caddr_t)(u_long)(tf->tf_out[6] + offsetof(struct frame32, fr_argx)));
				for (k = 0; k < j; k++)
					printf("arg %d = %p at %d val %p\n", k, (void *)(u_long)temp[k], nap+k, (void *)(u_long)args.i[nap+k]);
			}
#endif
d1355 1
a1355 11
#ifdef DEBUG
		if (trapdebug&(TDB_SYSCALL|TDB_FOLLOW)) {
			for (i=0; i < (long)callp->sy_argsize / sizeof(register32_t); i++) 
				printf("arg[%d]=%x ", i, (int)(args.i[i]));
			printf("\n");
		}
		if (trapdebug&(TDB_STOPCALL)) { 
			printf("stop precall\n");
			Debugger();
		}
#endif
a1361 11
#ifdef DEBUG
	if (callp->sy_call == sys_nosys) {
		printf("trapdebug: emul %s UNIPL syscall %d:%s\n", 
		       p->p_emul->e_name, (int)code, 
		       p->p_emul->e_syscallnames ? (
			       (code < 0 || code >= nsys) ? 
			       "illegal syscall" : 
			       p->p_emul->e_syscallnames[code]) :
		       "unknown syscall");
	}
#endif
a1372 6
#ifdef DEBUG
			if (trapdebug&(TDB_SYSCALL|TDB_FOLLOW))
				printf("syscall: return tstate=%llx new success to %p retval %lx:%lx\n", 
				       (unsigned long long)tf->tf_tstate, (void *)(u_long)dest,
				       (u_long)rval[0], (u_long)rval[1]);
#endif
a1380 11
#ifdef DEBUG
			if (trapdebug&(TDB_SYSCALL|TDB_FOLLOW))
				printf("syscall: return tstate=%llx old success to %p retval %lx:%lx\n", 
				       (unsigned long long)tf->tf_tstate, (void *)(u_long)dest,
				       (u_long)rval[0], (u_long)rval[1]);
			if (trapdebug&(TDB_SYSCALL|TDB_FOLLOW))
				printf("old pc=%p npc=%p dest=%p\n",
				    (void *)(u_long)tf->tf_pc,
				    (void *)(u_long)tf->tf_npc,
				    (void *)(u_long)dest);
#endif
a1399 6
#ifdef DEBUG
		if (trapdebug&(TDB_SYSCALL|TDB_FOLLOW)) 
			printf("syscall: return tstate=%llx fail %d to %p\n", 
			       (unsigned long long)tf->tf_tstate, error,
			       (void *)(long)dest);
#endif
a1406 6
#ifdef NOTDEF_DEBUG
	if ( code == 202) {
		/* Trap on __sysctl */
		Debugger();
	}
#endif
a1411 10
#ifdef DEBUG
	if (trapdebug&(TDB_STOPCALL|TDB_SYSTOP)) { 
		Debugger();
	}
#endif
#ifdef DEBUG
	if (trapdebug & TDB_FRAME) {
		print_trapframe(tf);
	}
#endif
a1424 3
#ifdef NOTDEF_DEBUG
	printf("child_return: proc=%p\n", p);
#endif
@


1.9
log
@Our printf has %b, use it and don't bother with snprintf stuff.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.8 2001/09/19 20:50:58 mickey Exp $	*/
d770 1
d773 2
a774 1
		printf("Alignment error: pid=%d comm=%s dsfsr=%08x:%08x dsfar=%x:%x isfsr=%08x:%08x pc=%lx\n",
@


1.8
log
@merge vm/vm_kern.h into uvm/uvm_extern.h; art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.7 2001/08/31 06:37:19 art Exp $	*/
a525 2
		char sbuf[sizeof(PSTATE_BITS) + 64];

d528 2
a529 3
		snprintf(sbuf, sizeof(sbuf), "%b", pstate, PSTATE_BITS);
		printf(" npc=%lx pstate=%s %s\n",
		       (long)tf->tf_npc, sbuf, 
a543 2
		char sbuf[sizeof(PSTATE_BITS) + 64];

d548 2
a549 3
		snprintf(sbuf, sizeof(sbuf), "%b", pstate, PSTATE_BITS);
		printf(" npc=%lx pstate=%s %s\n",
		       (long)tf->tf_npc, sbuf, 
d641 5
a645 12
			{
				char sbuf[sizeof(PSTATE_BITS) + 64];

				printf("trap type 0x%x: pc=%lx",
				       type, pc); 
				snprintf(sbuf, sizeof(sbuf), "%b", pstate,
				    PSTATE_BITS);
				printf(" npc=%lx pstate=%s\n",
				       (long)tf->tf_npc, sbuf);
				DEBUGGER(type, tf);
				panic(type < N_TRAP_TYPES ? trap_type[type] : T);
			}
d1274 1
a1274 3
		char buf[768];
		snprintf(buf, sizeof(buf), "%b", sfsr, SFSR_BITS);
		printf("%d data_access_error(%lx, %lx, %lx, %p)=%lx @@ %p %s\n",
d1277 1
a1277 1
		       (void *)(u_long)tf->tf_pc, buf);
d1283 1
a1283 3
		char buf[768];
		snprintf(buf, sizeof(buf), "%b", sfsr, SFSR_BITS);
		printf("%d tl %ld data_access_error(%lx, %lx, %lx, %p)=%lx @@ %lx %s\n",
d1286 1
a1286 1
		       (long)tf->tf_pc, buf);
a1331 1
			char buf[768];
a1333 1
			snprintf(buf, sizeof(buf), "%b", sfsr, SFSR_BITS);
d1335 2
a1336 2
			printf("data fault: pc=%lx addr=%lx sfsr=%s\n",
				(u_long)pc, (long)sfva, buf);
d1347 2
a1348 4
			char buf[128];
			snprintf(buf, sizeof(buf), "%b", afsr, AFSR_BITS);
			panic("Privileged Async Fault: AFAR %p AFSR %lx\n%s",
				(void *)afva, afsr, buf);
a1544 2
	char buf[768];
	
d1554 1
a1554 2
		snprintf(buf, sizeof(buf), "%b", sfsr, SFSR_BITS);
		printf("%ld text_access_error(%lx, %lx, %lx, %p)=%lx @@ %lx %s\n",
d1557 1
a1557 1
		       (long)tf->tf_pc, buf); 
d1563 1
a1563 2
		snprintf(buf, sizeof(buf), "%b", sfsr, SFSR_BITS);
		printf("%ld tl %ld text_access_error(%lx, %lx, %lx, %p)=%lx @@ %lx %s\n",
d1566 1
a1566 1
		       (long)tf->tf_tstate, (long)tf->tf_pc, buf); 
a1622 1
		snprintf(buf, sizeof(buf), "%b", sfsr, SFSR_BITS);
d1624 1
a1624 1
		printf("text error: pc=%lx sfsr=%s\n", pc, buf);
a1658 1
			snprintf(buf, sizeof(buf), "%b", sfsr, SFSR_BITS);
d1660 2
a1661 1
			printf("text error: pc=%lx sfsr=%s\n", pc, buf);
@


1.7
log
@A text fault without curproc is always illegal.
cleanup in debug code.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.6 2001/08/25 21:04:38 art Exp $	*/
a70 1
#include <vm/vm_kern.h>
@


1.6
log
@Ooops. Disable accidentally comitted DEBUG.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.5 2001/08/25 12:27:30 art Exp $	*/
d1454 1
a1454 1
		p = &proc0;
a1925 4
#if 0 /*def DEBUG*/
#ifdef LKM
		if ((curproc->p_flag & P_32) == 0)
#endif
a1929 1
#endif
@


1.5
log
@Some fixes:
 - Make it build with DEBUG (by commenting out code).
 - Our uvm_fault still returns KERN_*, not errnos.
 - some cleanups.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.4 2001/08/23 17:40:05 art Exp $	*/
a51 1
#define DEBUG
@


1.4
log
@adapt to how our scheduler works.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.3 2001/08/20 20:23:53 jason Exp $	*/
d52 1
d152 1
a152 1
int	trapdebug = 0/*|TDB_SYSCALL|TDB_STOPSIG|TDB_STOPCPIO|TDB_ADDFLT|TDB_FOLLOW*/;
d1091 1
d1098 1
d1177 2
a1178 2
		} else if (rv == EACCES)
			rv = EFAULT;
d1223 1
a1223 1
		if (rv == ENOMEM) {
d1336 1
d1343 1
d1497 2
a1498 2
		} else if (rv == EACCES)
			rv = EFAULT;
d1634 1
d1641 1
d1675 2
a1676 2
		} else if (rv == EACCES)
			rv = EFAULT;
d1927 1
a1927 1
#ifdef DEBUG
@


1.3
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d455 1
d457 3
@


1.2
log
@siginfo support
@
text
@d1 1
@


1.1
log
@Lot of stuff... Some from NetBSD, some from OpenBSD, minor modifications
@
text
@d492 1
a492 1
	sv.sival_int = pc;
d1021 1
a1021 1
	sv.sival_int = pc;
d1270 1
a1270 1
	sv.sival_int = pc;
d1418 1
a1418 1
	sv.sival_int = pc;
d1512 1
a1512 1
		sv.sival_int = va;
d1560 1
a1560 1
	sv.sival_int = pc;
d1691 1
a1691 1
		sv.sival_int = va;
@

