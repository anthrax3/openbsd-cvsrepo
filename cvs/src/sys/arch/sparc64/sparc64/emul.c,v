head	1.23;
access;
symbols
	OPENBSD_6_1:1.23.0.10
	OPENBSD_6_1_BASE:1.23
	OPENBSD_6_0:1.23.0.8
	OPENBSD_6_0_BASE:1.23
	OPENBSD_5_9:1.23.0.4
	OPENBSD_5_9_BASE:1.23
	OPENBSD_5_8:1.23.0.6
	OPENBSD_5_8_BASE:1.23
	OPENBSD_5_7:1.23.0.2
	OPENBSD_5_7_BASE:1.23
	OPENBSD_5_6:1.22.0.16
	OPENBSD_5_6_BASE:1.22
	OPENBSD_5_5:1.22.0.14
	OPENBSD_5_5_BASE:1.22
	OPENBSD_5_4:1.22.0.10
	OPENBSD_5_4_BASE:1.22
	OPENBSD_5_3:1.22.0.8
	OPENBSD_5_3_BASE:1.22
	OPENBSD_5_2:1.22.0.6
	OPENBSD_5_2_BASE:1.22
	OPENBSD_5_1_BASE:1.22
	OPENBSD_5_1:1.22.0.4
	OPENBSD_5_0:1.22.0.2
	OPENBSD_5_0_BASE:1.22
	OPENBSD_4_9:1.19.0.2
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.18.0.2
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.17.0.2
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.15.0.8
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.4
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.2
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.14.0.2
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.12.0.16
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.14
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.12
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.12.0.10
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.8
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.6
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.12.0.4
	OPENBSD_3_6_BASE:1.12
	SMP_SYNC_A:1.12
	SMP_SYNC_B:1.12
	OPENBSD_3_5:1.12.0.2
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	UBC_SYNC_A:1.3
	OPENBSD_3_3:1.3.0.6
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.4
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.2
	OPENBSD_3_1_BASE:1.3
	UBC_SYNC_B:1.3
	UBC:1.2.0.6
	UBC_BASE:1.2
	SMP:1.2.0.4
	OPENBSD_3_0:1.2.0.2
	OPENBSD_3_0_BASE:1.2;
locks; strict;
comment	@ * @;


1.23
date	2014.11.16.12.30.59;	author deraadt;	state Exp;
branches;
next	1.22;
commitid	yv0ECmCdICvq576h;

1.22
date	2011.07.11.15.40.47;	author guenther;	state Exp;
branches;
next	1.21;

1.21
date	2011.07.07.18.11.24;	author art;	state Exp;
branches;
next	1.20;

1.20
date	2011.07.06.21.41.37;	author art;	state Exp;
branches;
next	1.19;

1.19
date	2010.11.27.19.41.48;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2010.04.11.13.12.16;	author kettenis;	state Exp;
branches;
next	1.17;

1.17
date	2010.01.01.23.19.20;	author kettenis;	state Exp;
branches;
next	1.16;

1.16
date	2010.01.01.13.13.08;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2008.06.26.05.42.13;	author ray;	state Exp;
branches;
next	1.14;

1.14
date	2007.10.31.22.46.52;	author kettenis;	state Exp;
branches;
next	1.13;

1.13
date	2007.09.09.10.17.33;	author kettenis;	state Exp;
branches;
next	1.12;

1.12
date	2003.11.03.07.01.33;	author david;	state Exp;
branches;
next	1.11;

1.11
date	2003.07.14.00.05.35;	author jason;	state Exp;
branches;
next	1.10;

1.10
date	2003.07.13.07.00.47;	author jason;	state Exp;
branches;
next	1.9;

1.9
date	2003.07.13.06.30.45;	author jason;	state Exp;
branches;
next	1.8;

1.8
date	2003.07.12.06.27.38;	author jason;	state Exp;
branches;
next	1.7;

1.7
date	2003.07.12.05.01.42;	author jason;	state Exp;
branches;
next	1.6;

1.6
date	2003.07.12.03.58.42;	author jason;	state Exp;
branches;
next	1.5;

1.5
date	2003.07.10.15.26.54;	author jason;	state Exp;
branches;
next	1.4;

1.4
date	2003.07.09.23.56.16;	author jason;	state Exp;
branches;
next	1.3;

1.3
date	2002.03.14.01.26.45;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2001.08.20.20.23.53;	author jason;	state Exp;
branches
	1.2.4.1
	1.2.6.1;
next	1.1;

1.1
date	2001.08.19.05.21.38;	author jason;	state Exp;
branches;
next	;

1.2.4.1
date	2001.10.31.03.07.58;	author nate;	state Exp;
branches;
next	1.2.4.2;

1.2.4.2
date	2002.03.28.11.23.52;	author niklas;	state Exp;
branches;
next	1.2.4.3;

1.2.4.3
date	2004.02.19.10.50.00;	author niklas;	state Exp;
branches;
next	;

1.2.6.1
date	2002.06.11.03.38.43;	author art;	state Exp;
branches;
next	;


desc
@@


1.23
log
@Replace a plethora of historical protection options with just
PROT_NONE, PROT_READ, PROT_WRITE, and PROT_EXEC from mman.h.
PROT_MASK is introduced as the one true way of extracting those bits.
Remove UVM_ADV_* wrapper, using the standard names.
ok doug guenther kettenis
@
text
@/*	$OpenBSD: emul.c,v 1.22 2011/07/11 15:40:47 guenther Exp $	*/
/*	$NetBSD: emul.c,v 1.8 2001/06/29 23:58:40 eeh Exp $	*/

/*-
 * Copyright (c) 1997, 2001 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Christos Zoulas.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/signalvar.h>
#include <sys/malloc.h>
#include <machine/reg.h>
#include <machine/instr.h>
#include <machine/cpu.h>
#include <machine/psl.h>
#include <uvm/uvm_extern.h>

#ifdef DEBUG_EMUL
# define DPRINTF(a) printf a
#else
# define DPRINTF(a)
#endif

#define GPR(tf, i)	((int32_t *)(u_long)&tf->tf_global)[i]
#define IPR(tf, i)	((int32_t *)(u_long)tf->tf_out[6])[i - 16]
#define FPR(p, i)	((int32_t) p->p_md.md_fpstate->fs_regs[i])
#define FPRSET(p, i, v)	p->p_md.md_fpstate->fs_regs[i] = (v)

static __inline int readgpreg(struct trapframe64 *, int, void *);
static __inline int readfpreg(struct proc *, int, void *);
static __inline int writegpreg(struct trapframe64 *, int, const void *);
static __inline int writefpreg(struct proc *, int, const void *);
static __inline int decodeaddr(struct trapframe64 *, union instr *, void *);
static int muldiv(struct trapframe64 *, union instr *, int32_t *, int32_t *,
    int32_t *);
void swap_quad(int64_t *);

#define	REGNAME(i)	"goli"[i >> 3], i & 7


static __inline int
readgpreg(tf, i, val)
	struct trapframe64 *tf;
	int i;
	void *val;
{
	int error = 0;
	if (i == 0)
		*(int32_t *) val = 0;
	else if (i < 16)
		*(int32_t *) val = GPR(tf, i);
	else
		error = copyin(&IPR(tf, i), val, sizeof(int32_t));

	return error;
}

		
static __inline int
writegpreg(tf, i, val)
	struct trapframe64 *tf;
	int i;
	const void *val;
{
	int error = 0;

	if (i == 0)
		return error;
	else if (i < 16)
		GPR(tf, i) = *(int32_t *) val;
	else
		/* XXX: Fix copyout prototype */
		error = copyout((caddr_t) val, &IPR(tf, i), sizeof(int32_t));

	return error;
}
	

static __inline int
readfpreg(p, i, val)
	struct proc *p;
	int i;
	void *val;
{
	*(int32_t *) val = FPR(p, i);
	return 0;
}

		
static __inline int
writefpreg(p, i, val)
	struct proc *p;
	int i;
	const void *val;
{
	FPRSET(p, i, *(const int32_t *) val);
	return 0;
}

static __inline int
decodeaddr(tf, code, val)
	struct trapframe64 *tf;
	union instr *code;
	void *val;
{
	if (code->i_simm13.i_i)
		*((int32_t *) val) = code->i_simm13.i_simm13;
	else {
		int error;

		if (code->i_asi.i_asi)
			return EINVAL;
		if ((error = readgpreg(tf, code->i_asi.i_rs2, val)) != 0)
			return error;
	}
	return 0;
}


static int
muldiv(tf, code, rd, rs1, rs2)
	struct trapframe64 *tf;
	union instr *code;
	int32_t *rd, *rs1, *rs2;
{
	/*
	 * We check for {S,U}{MUL,DIV}{,cc}
	 *
	 * [c = condition code, s = sign]
	 * Mul = 0c101s
	 * Div = 0c111s
	 */
	union {
		struct {
			unsigned unused:26;	/* padding */
			unsigned zero:1;	/* zero by opcode */
			unsigned cc:1;		/* one to send condition code */
			unsigned one1:1;	/* one by opcode */
			unsigned div:1;		/* one if divide */
			unsigned one2:1;	/* one by opcode */
			unsigned sgn:1;		/* sign bit */
		} bits;
		int num;
	} op;

	op.num = code->i_op3.i_op3;

#ifdef DEBUG_EMUL
	printf("muldiv 0x%x: %c%s%s %c%d, %c%d, ", code->i_int,
	    "us"[op.bits.sgn], op.bits.div ? "div" : "mul",
	    op.bits.cc ? "cc" : "", REGNAME(code->i_op3.i_rd),
	    REGNAME(code->i_op3.i_rs1));
	if (code->i_loadstore.i_i)
		printf("0x%x\n", *rs2);
	else
		printf("%c%d\n", REGNAME(code->i_asi.i_rs2));
#endif

	if (op.bits.div) {
		if (*rs2 == 0) {
			/*
			 * XXX: to be 100% correct here, on sunos we need to
			 *	ignore the error and return *rd = *rs1.
			 *	It should be easy to fix by passing struct
			 *	proc in here.
			 */
			DPRINTF(("muldiv: avoid zerodivide\n"));
			return EINVAL;
		}
		*rd = *rs1 / *rs2;
		DPRINTF(("muldiv: %d / %d = %d\n", *rs1, *rs2, *rd));
	}
	else {
		*rd = *rs1 * *rs2;
		DPRINTF(("muldiv: %d * %d = %d\n", *rs1, *rs2, *rd));
	}

	if (op.bits.cc) {
		/* Set condition codes */
		tf->tf_tstate &= ~(TSTATE_CCR);

		if (*rd == 0)
			tf->tf_tstate |= (u_int64_t)(ICC_Z|XCC_Z) << TSTATE_CCR_SHIFT;
		else {
			if (op.bits.sgn && *rd < 0)
				tf->tf_tstate |= (u_int64_t)(ICC_N|XCC_N) << TSTATE_CCR_SHIFT;
			if (op.bits.div) {
				if (*rd * *rs2 != *rs1)
					tf->tf_tstate |= (u_int64_t)(ICC_V|XCC_V) << TSTATE_CCR_SHIFT;
			}
			else {
				if (*rd / *rs2 != *rs1)
					tf->tf_tstate |= (u_int64_t)(ICC_V|XCC_V) << TSTATE_CCR_SHIFT;
			}
		}
	}

	return 0;
}

/*
 * Emulate unimplemented instructions on earlier sparc chips.
 */
int
emulinstr(pc, tf)
	vaddr_t pc;
	struct trapframe64 *tf;
{
	union instr code;
	int32_t rs1, rs2, rd;
	int error;

	/* fetch and check the instruction that caused the fault */
	error = copyin((caddr_t) pc, &code.i_int, sizeof(code.i_int));
	if (error != 0) {
		DPRINTF(("emulinstr: Bad instruction fetch\n"));
		return (SIGILL);
	}

	/* Only support format 2 */
	if (code.i_any.i_op != 2) {
		DPRINTF(("emulinstr: Not a format 2 instruction\n"));
		return (SIGILL);
	}

	write_user_windows();

	if ((error = readgpreg(tf, code.i_op3.i_rs1, &rs1)) != 0) {
		DPRINTF(("emulinstr: read rs1 %d\n", error));
		return (SIGILL);
	}

	if ((error = decodeaddr(tf, &code, &rs2)) != 0) {
		DPRINTF(("emulinstr: decode addr %d\n", error));
		return (SIGILL);
	}

	switch (code.i_op3.i_op3) {
	case IOP3_FLUSH:
/*		cpuinfo.cache_flush((caddr_t)(rs1 + rs2), 4); XXX */
		return (0);

	default:
		if ((code.i_op3.i_op3 & 0x2a) != 0xa) {
			DPRINTF(("emulinstr: Unsupported op3 0x%x\n",
			    code.i_op3.i_op3));
			return (SIGILL);
		}
		else if ((error = muldiv(tf, &code, &rd, &rs1, &rs2)) != 0)
			return (SIGFPE);
	}

	if ((error = writegpreg(tf, code.i_op3.i_rd, &rd)) != 0) {
		DPRINTF(("muldiv: write rd %d\n", error));
		return (SIGILL);
	}

	return (0);
}

#define	SIGN_EXT13(v)	(((int64_t)(v) << 51) >> 51)

void
swap_quad(int64_t *p)
{
	int64_t t;

	t = htole64(p[0]);
	p[0] = htole64(p[1]);
	p[1] = t;
}

/*
 * emulate STQF, STQFA, LDQF, and LDQFA
 */
int
emul_qf(int32_t insv, struct proc *p, union sigval sv, struct trapframe *tf)
{
	extern struct fpstate64 initfpstate;
	struct fpstate64 *fs = p->p_md.md_fpstate;
	int64_t addr, buf[2];
	union instr ins;
	int freg, isload, err;
	u_int8_t asi;

	ins.i_int = insv;
	freg = ins.i_op3.i_rd & ~1;
	freg |= (ins.i_op3.i_rd & 1) << 5;

	if (ins.i_op3.i_op3 == IOP3_LDQF || ins.i_op3.i_op3 == IOP3_LDQFA)
		isload = 1;
	else
		isload = 0;

	if (ins.i_op3.i_op3 == IOP3_STQF || ins.i_op3.i_op3 == IOP3_LDQF)
		asi = ASI_PRIMARY;
	else if (ins.i_loadstore.i_i)
		asi = (tf->tf_tstate & TSTATE_ASI) >> TSTATE_ASI_SHIFT;
	else
		asi = ins.i_asi.i_asi;

	addr = tf->tf_global[ins.i_asi.i_rs1];
	if (ins.i_loadstore.i_i)
		addr += SIGN_EXT13(ins.i_simm13.i_simm13);
	else
		addr += tf->tf_global[ins.i_asi.i_rs2];

	if (asi < ASI_PRIMARY) {
		/* privileged asi */
		KERNEL_LOCK();
		trapsignal(p, SIGILL, 0, ILL_PRVOPC, sv);
		KERNEL_UNLOCK();
		return (0);
	}
	if (asi > ASI_SECONDARY_NOFAULT_LITTLE ||
	    (asi > ASI_SECONDARY_NOFAULT && asi < ASI_PRIMARY_LITTLE)) {
		/* architecturally undefined user ASI's */
		goto segv;
	}

	if ((freg & 3) != 0) {
		/* only valid for %fN where N % 4 = 0 */
		KERNEL_LOCK();
		trapsignal(p, SIGILL, 0, ILL_ILLOPN, sv);
		KERNEL_UNLOCK();
		return (0);
	}

	if ((addr & 3) != 0) {
		/* request is not aligned */
		KERNEL_LOCK();
		trapsignal(p, SIGBUS, 0, BUS_ADRALN, sv);
		KERNEL_UNLOCK();
		return (0);
	}

	fs = p->p_md.md_fpstate;
	if (fs == NULL) {
		KERNEL_LOCK();
		/* don't currently have an fpu context, get one */
		fs = malloc(sizeof(*fs), M_SUBPROC, M_WAITOK);
		*fs = initfpstate;
		fs->fs_qsize = 0;
		p->p_md.md_fpstate = fs;
		KERNEL_UNLOCK();
	} else
		fpusave_proc(p, 1);

	/* Ok, try to do the actual operation (finally) */
	if (isload) {
		err = copyin((caddr_t)addr, buf, sizeof(buf));
		if (err != 0 && (asi & 2) == 0)
			goto segv;
		if (err == 0) {
			if (asi & 8)
				swap_quad(buf);
			bcopy(buf, &fs->fs_regs[freg], sizeof(buf));
		}
	} else {
		bcopy(&fs->fs_regs[freg], buf, sizeof(buf));
		if (asi & 8)
			swap_quad(buf);
		if (copyout(buf, (caddr_t)addr, sizeof(buf)) && (asi & 2) == 0)
			goto segv;
	}

	return (1);

segv:
	KERNEL_LOCK();
	trapsignal(p, SIGSEGV, isload ? PROT_READ : PROT_WRITE,
	    SEGV_MAPERR, sv);
	KERNEL_UNLOCK();
	return (0);
}

int
emul_popc(int32_t insv, struct proc *p, union sigval sv, struct trapframe *tf)
{
	u_int64_t val, ret = 0;
	union instr ins;

	ins.i_int = insv;
	if (ins.i_simm13.i_i == 0)
		val = tf->tf_global[ins.i_asi.i_rs2];
	else
		val = SIGN_EXT13(ins.i_simm13.i_simm13);

	for (; val != 0; val >>= 1)
		ret += val & 1;

	tf->tf_global[ins.i_asi.i_rd] = ret;
	return (1);
}
@


1.22
log
@Revert art@@'s moving around of the KERNEL_LOCK()/KERNEL_UNLOCK() calls,
as it causes hangs in some ports, including libsigsegv's configure script

confirmed by krw@@, landry@@
@
text
@d1 1
a1 1
/*	$OpenBSD: emul.c,v 1.20 2011/07/06 21:41:37 art Exp $	*/
d397 1
a397 1
	trapsignal(p, SIGSEGV, isload ? VM_PROT_READ : VM_PROT_WRITE,
@


1.21
log
@There is a bunch of places in the kernel entry points where we don't
hold the kernel lock, but still need call one function that needs it.

Instead of grabbing the lock all over the place, move the locks into
the affected functions: trapsignal, scdebug*, ktrsyscall, ktrsysret,
systrace_redirect and ADDUPROF. In the cases we already hold the biglock
we'll just recurse.

kettenis@@, beck@@ ok
@
text
@d336 1
d338 1
d349 1
d351 1
d357 1
d359 1
d396 1
d399 1
@


1.20
log
@Clean up after P_BIGLOCK removal.
KERNEL_PROC_LOCK -> KERNEL_LOCK
KERNEL_PROC_UNLOCK -> KERNEL_UNLOCK

oga@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: emul.c,v 1.19 2010/11/27 19:41:48 miod Exp $	*/
a335 1
		KERNEL_LOCK();
a336 1
		KERNEL_UNLOCK();
a346 1
		KERNEL_LOCK();
a347 1
		KERNEL_UNLOCK();
a352 1
		KERNEL_LOCK();
a353 1
		KERNEL_UNLOCK();
a389 1
	KERNEL_LOCK();
a391 1
	KERNEL_UNLOCK();
@


1.19
log
@Misaligned load/store recovery code in the kernel, enabled by T_FIXALIGN
userland traps on a per-process basis, were necessary for *some* SunOS
binaries on sparc, which had to compiled with explicit misaligned access code
generation (i.e. for vendors to release a working SunOS/sparc version of their
code until they could fix their bogus code).

There is no reason to keep this code on sparc64, and now that we don't provide
COMPAT_SUNOS anymore, there is no reason to keep this code on sparc.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: emul.c,v 1.18 2010/04/11 13:12:16 kettenis Exp $	*/
d336 1
a336 1
		KERNEL_PROC_LOCK(p);
d338 1
a338 1
		KERNEL_PROC_UNLOCK(p);
d349 1
a349 1
		KERNEL_PROC_LOCK(p);
d351 1
a351 1
		KERNEL_PROC_UNLOCK(p);
d357 1
a357 1
		KERNEL_PROC_LOCK(p);
d359 1
a359 1
		KERNEL_PROC_UNLOCK(p);
d365 1
a365 1
		KERNEL_PROC_LOCK(p);
d371 1
a371 1
		KERNEL_PROC_UNLOCK(p);
d396 1
a396 1
	KERNEL_PROC_LOCK(p);
d399 1
a399 1
	KERNEL_PROC_UNLOCK(p);
@


1.18
log
@Make gcc4 happy.  From NetBSD.  Probably reported to me before by jsg@@ or
robert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: emul.c,v 1.17 2010/01/01 23:19:20 kettenis Exp $	*/
a227 165
 * Code to handle alignment faults on the sparc. This is enabled by sending
 * a fixalign trap. Such code is generated by compiling with cc -misalign
 * on SunOS, but we don't have such a feature yet on our gcc.
 */

int
fixalign(p, tf)
	struct proc *p;
	struct trapframe64 *tf;
{
	static u_char sizedef[] = { 0x4, 0xff, 0x2, 0x8 };

	/*
	 * This is particular to load and store instructions
	 */
	union {
		struct {
			unsigned unused:26;	/* 26 padding */
			unsigned fl:1;		/* 1 bit float flag */
			unsigned op:1;		/* 1 bit opcode */
			unsigned sgn:1;		/* 1 bit sign */
			unsigned st:1;		/* 1 bit load/store */
			unsigned sz:2;		/* 2 bit size register */
		} bits;
		int num;
	} op;

	union {
		double	d;
		int32_t i[2];
		int16_t s[4];
		int8_t  c[8];
	} data;

	union instr code;
	size_t size;
	int64_t rs1, rs2;
	int error;

	/* fetch and check the instruction that caused the fault */
	error = copyin((caddr_t)(u_long)tf->tf_pc, &code.i_int, sizeof(code.i_int));
	if (error != 0) {
		DPRINTF(("fixalign: Bad instruction fetch\n"));
		return EINVAL;
	}

	/* Only support format 3 */
	if (code.i_any.i_op != 3) {
		DPRINTF(("fixalign: Not a load or store\n"));
		return EINVAL;
	}

	op.num = code.i_loadstore.i_op3;

	/* Check operand size */
	if ((size = sizedef[op.bits.sz]) == 0xff) {
		DPRINTF(("fixalign: Bad operand size\n"));
		return EINVAL;
	}

	write_user_windows();

	if ((error = readgpreg(tf, code.i_op3.i_rs1, &rs1)) != 0) {
		DPRINTF(("fixalign: read rs1 %d\n", error));
		return error;
	}

	if ((error = decodeaddr(tf, &code, &rs2)) != 0) {
		DPRINTF(("fixalign: decode addr %d\n", error));
		return error;
	}


	rs1 += rs2;

#ifdef DEBUG_EMUL
	printf("memalign 0x%x: %s%c%c %c%d, %c%d, ", code.i_int,
	    op.bits.st ? "st" : "ld", "us"[op.bits.sgn],
	    "w*hd"[op.bits.sz], op.bits.fl ? 'f' : REGNAME(code.i_op3.i_rd),
	    REGNAME(code.i_op3.i_rs1));
	if (code.i_loadstore.i_i)
		printf("0x%llx\n", (unsigned long long)rs2);
	else
		printf("%c%d\n", REGNAME(code.i_asi.i_rs2));
#endif
#ifdef DIAGNOSTIC
	if (op.bits.fl && p != fpproc)
		panic("fp align without being the FP owning process");
#endif

	if (op.bits.st) {
		if (op.bits.fl) {
			fpusave_proc(p, 1);

			error = readfpreg(p, code.i_op3.i_rd, &data.i[0]);
			if (error)
				return error;
			if (size == 8) {
				error = readfpreg(p, code.i_op3.i_rd + 1,
				    &data.i[1]);
				if (error)
					return error;
			}
		}
		else {
			error = readgpreg(tf, code.i_op3.i_rd, &data.i[0]);
			if (error)
				return error;
			if (size == 8) {
				error = readgpreg(tf, code.i_op3.i_rd + 1,
				    &data.i[1]);
				if (error)
					return error;
			}
		}

		if (size == 2)
			return copyout(&data.s[1], (caddr_t)(u_long)rs1, size);
		else
			return copyout(&data.d, (caddr_t)(u_long)rs1, size);
	}
	else { /* load */
		if (size == 2) {
			error = copyin((caddr_t)(u_long)rs1, &data.s[1], size);
			if (error)
				return error;

			/* Sign extend if necessary */
			if (op.bits.sgn && (data.s[1] & 0x8000) != 0)
				data.s[0] = ~0;
			else
				data.s[0] = 0;
		}
		else
			error = copyin((caddr_t)(u_long)rs1, &data.d, size);

		if (error)
			return error;

		if (op.bits.fl) {
			error = writefpreg(p, code.i_op3.i_rd, &data.i[0]);
			if (error)
				return error;
			if (size == 8) {
				error = writefpreg(p, code.i_op3.i_rd + 1,
				    &data.i[1]);
				if (error)
					return error;
			}
			loadfpstate(p->p_md.md_fpstate);
			fpproc = p;
		}
		else {
			error = writegpreg(tf, code.i_op3.i_rd, &data.i[0]);
			if (error)
				return error;
			if (size == 8)
				error = writegpreg(tf, code.i_op3.i_rd + 1,
				    &data.i[1]);
		}
	}
	return error;
}

/*
d355 2
a356 5
	if ((p->p_md.md_flags & MDP_FIXALIGN) == 0 && (addr & 3) != 0) {
		/*
		 * If process doesn't want us to fix alignment and the
		 * request isn't aligned, kill it.
		 */
@


1.17
log
@Miod must have gotten his fingers stuck between the keys on his keyboard and
accidentally swapped to lines of code.  Swap them back such that this
compiles again.
@
text
@d1 1
a1 1
/*	$OpenBSD: emul.c,v 1.16 2010/01/01 13:13:08 miod Exp $	*/
d53 1
d122 1
a122 1
	FPR(p, i) = *(const int32_t *) val;
@


1.16
log
@Make sure we grab the kernel lock before invoking trapsignal().
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: emul.c,v 1.15 2008/06/26 05:42:13 ray Exp $	*/
d565 1
a566 1
	    SEGV_MAPERR, sv);
@


1.15
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: emul.c,v 1.14 2007/10/31 22:46:52 kettenis Exp $	*/
d500 1
d502 1
d513 1
d515 1
d524 1
d526 1
d563 1
d565 1
@


1.14
log
@Overhaul fpu context save/restore code, making it more similar to what we do
on i386 and amd64.  Don't let IPIs in when saving fpu context by disabling
interrupts.
@
text
@d1 1
a1 1
/*	$OpenBSD: emul.c,v 1.13 2007/09/09 10:17:33 kettenis Exp $	*/
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.13
log
@Remove some more goo left over from sparc.
@
text
@d1 1
a1 1
/*	$OpenBSD: emul.c,v 1.12 2003/11/03 07:01:33 david Exp $	*/
d326 1
a326 4
			if (p == fpproc) {
				savefpstate(p->p_md.md_fpstate);
				fpproc = NULL;
			}
d533 1
d539 3
a541 8
	}
	if (fpproc != p) {
		/* make this process the current holder of the fpu */
		if (fpproc != NULL)
			savefpstate(fpproc->p_md.md_fpstate);
		fpproc = p;
	}
	tf->tf_tstate |= TSTATE_PEF;
a548 1
			savefpstate(fs);
a551 1
			loadfpstate(fs);
@


1.12
log
@spelling fixes (in the comments)
@
text
@d1 1
a1 1
/*	$OpenBSD: emul.c,v 1.11 2003/07/14 00:05:35 jason Exp $	*/
a48 1
#include <sparc64/sparc64/cpuvar.h>
@


1.11
log
@cleaning and undef DEBUG_EMUL
@
text
@d1 1
a1 1
/*	$OpenBSD: emul.c,v 1.10 2003/07/13 07:00:47 jason Exp $	*/
d510 1
a510 1
		/* priviledged asi */
@


1.10
log
@whoa, gcc wasn't at fault: i_loadstore was missing 5 bits, which was causing
the decode to be wrong.
@
text
@d1 1
a1 1
/*	$OpenBSD: emul.c,v 1.9 2003/07/13 06:30:45 jason Exp $	*/
a51 1
#define DEBUG_EMUL
d53 1
a53 1
# define DPRINTF(a) uprintf a
d182 1
a182 1
	uprintf("muldiv 0x%x: %c%s%s %c%d, %c%d, ", code->i_int,
d187 1
a187 1
		uprintf("0x%x\n", *rs2);
d189 1
a189 1
		uprintf("%c%d\n", REGNAME(code->i_asi.i_rs2));
d200 1
a200 1
			DPRINTF(("emulinstr: avoid zerodivide\n"));
d298 1
a298 1
		DPRINTF(("emulinstr: read rs1 %d\n", error));
d303 1
a303 1
		DPRINTF(("emulinstr: decode addr %d\n", error));
d311 1
a311 1
	uprintf("memalign 0x%x: %s%c%c %c%d, %c%d, ", code.i_int,
d316 1
a316 1
		uprintf("0x%llx\n", (unsigned long long)rs2);
d318 1
a318 1
		uprintf("%c%d\n", REGNAME(code.i_asi.i_rs2));
d418 1
a418 1
		return SIGILL;
d424 1
a424 1
		return SIGILL;
d431 1
a431 1
		return SIGILL;
d436 1
a436 1
		return SIGILL;
d442 1
a442 1
		return 0;
d448 1
a448 1
			return SIGILL;
d451 1
a451 1
			return SIGFPE;
d456 1
a456 1
		return SIGILL;
d459 1
a459 1
	return 0;
@


1.9
log
@my loathing for gcc runneth over: another case where a bitfield isn't
decoded properly with the instruction decode stuff.
@
text
@d1 1
a1 1
/*	$OpenBSD: emul.c,v 1.8 2003/07/12 06:27:38 jason Exp $	*/
d499 1
a499 1
	else if (ins.i_int & 0x2000)
d505 1
a505 1
	if (ins.i_int & 0x2000)
@


1.8
log
@grr.  gcc has bugs in its bitfields, work around it.
@
text
@d1 1
a1 1
/*	$OpenBSD: emul.c,v 1.7 2003/07/12 05:01:42 jason Exp $	*/
d505 1
a505 1
	if (ins.i_loadstore.i_i)
@


1.7
log
@%asi is in tf_tstate... nail the last variant of ldqfa/stqfa
@
text
@d1 1
a1 1
/*	$OpenBSD: emul.c,v 1.6 2003/07/12 03:58:42 jason Exp $	*/
d499 1
a499 1
	else if (ins.i_loadstore.i_i)
@


1.6
log
@almost full emulation of stq(a)/ldq(a):
- the only missing bit is the variant that uses %asi... explicit asi or
implicit asi appears to work
- also, a slightly improved popc loop based on a link from otto
@
text
@d1 1
a1 1
/*	$OpenBSD: emul.c,v 1.5 2003/07/10 15:26:54 jason Exp $	*/
d499 3
a501 8
	else if (ins.i_loadstore.i_i) {
		/*
		 * XXX asi = %asi, how do I get %asi the proc's %asi here?
		 * XXX kill it for now
		 */
		trapsignal(p, SIGILL, 0, ILL_PRVOPC, sv);
		return (0);
	} else
@


1.5
log
@- working emulation for POPC instruction
- good start are fully decoding LDQF(A)/STQF(A)
@
text
@d1 1
a1 1
/*	$OpenBSD: emul.c,v 1.4 2003/07/09 23:56:16 jason Exp $	*/
d44 1
d50 1
d70 1
d465 10
d481 3
d485 1
a485 1
	int freg, isload;
a486 1
	int64_t addr;
d500 4
a503 1
		/* XXX asi = %asi, how do I get %asi here? kill it for now */
d515 1
a515 1
	if ((asi & 0x80) == 0) {
d520 5
d532 50
a581 1
	trapsignal(p, SIGILL, 0, ILL_ILLOPC, sv);
d598 1
a598 2
		if (val & 1)
			ret++;
@


1.4
log
@part of infrastructure to deal with emulated stqf/ldqf:
T_ILLINST handler fetches instruction and decodes it.  If it's stqf, ldqf,
stqfa, or ldqfa call emulation instead of SIGILL directly.
Note: this still SIGILL's in the end, the emulation isn't done yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: emul.c,v 1.3 2002/03/14 01:26:45 millert Exp $	*/
d460 5
d466 1
a466 1
emul_qf(int32_t insv, struct proc *p, union sigval sv)
d469 3
d474 28
d503 2
a504 1
	if (ins.i_op3.i_rd & 0x20) {
d511 20
@


1.3
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: emul.c,v 1.2 2001/08/20 20:23:53 jason Exp $	*/
d43 1
d458 16
@


1.2
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d60 7
a66 7
static __inline int readgpreg __P((struct trapframe64 *, int, void *));
static __inline int readfpreg __P((struct proc *, int, void *));
static __inline int writegpreg __P((struct trapframe64 *, int, const void *));
static __inline int writefpreg __P((struct proc *, int, const void *));
static __inline int decodeaddr __P((struct trapframe64 *, union instr *, void *));
static int muldiv __P((struct trapframe64 *, union instr *, int32_t *, int32_t *,
    int32_t *));
@


1.2.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: emul.c,v 1.2 2001/08/20 20:23:53 jason Exp $	*/
d60 7
a66 7
static __inline int readgpreg(struct trapframe64 *, int, void *);
static __inline int readfpreg(struct proc *, int, void *);
static __inline int writegpreg(struct trapframe64 *, int, const void *);
static __inline int writefpreg(struct proc *, int, const void *);
static __inline int decodeaddr(struct trapframe64 *, union instr *, void *);
static int muldiv(struct trapframe64 *, union instr *, int32_t *, int32_t *,
    int32_t *);
@


1.2.4.1
log
@Sync the SMP branch to something just after 3.0
@
text
@@


1.2.4.2
log
@Merge in -current from about a week ago
@
text
@d60 7
a66 7
static __inline int readgpreg(struct trapframe64 *, int, void *);
static __inline int readfpreg(struct proc *, int, void *);
static __inline int writegpreg(struct trapframe64 *, int, const void *);
static __inline int writefpreg(struct proc *, int, const void *);
static __inline int decodeaddr(struct trapframe64 *, union instr *, void *);
static int muldiv(struct trapframe64 *, union instr *, int32_t *, int32_t *,
    int32_t *);
@


1.2.4.3
log
@Merge of current from two weeks agointo the SMP branch
@
text
@a42 2
#include <sys/signalvar.h>
#include <sys/malloc.h>
a47 1
#include <uvm/uvm_extern.h>
d49 1
d51 1
a51 1
# define DPRINTF(a) printf a
a66 1
void swap_quad(int64_t *);
d179 1
a179 1
	printf("muldiv 0x%x: %c%s%s %c%d, %c%d, ", code->i_int,
d184 1
a184 1
		printf("0x%x\n", *rs2);
d186 1
a186 1
		printf("%c%d\n", REGNAME(code->i_asi.i_rs2));
d197 1
a197 1
			DPRINTF(("muldiv: avoid zerodivide\n"));
d295 1
a295 1
		DPRINTF(("fixalign: read rs1 %d\n", error));
d300 1
a300 1
		DPRINTF(("fixalign: decode addr %d\n", error));
d308 1
a308 1
	printf("memalign 0x%x: %s%c%c %c%d, %c%d, ", code.i_int,
d313 1
a313 1
		printf("0x%llx\n", (unsigned long long)rs2);
d315 1
a315 1
		printf("%c%d\n", REGNAME(code.i_asi.i_rs2));
d415 1
a415 1
		return (SIGILL);
d421 1
a421 1
		return (SIGILL);
d428 1
a428 1
		return (SIGILL);
d433 1
a433 1
		return (SIGILL);
d439 1
a439 1
		return (0);
d445 1
a445 1
			return (SIGILL);
d448 1
a448 1
			return (SIGFPE);
d453 1
a453 1
		return (SIGILL);
d456 1
a456 137
	return (0);
}

#define	SIGN_EXT13(v)	(((int64_t)(v) << 51) >> 51)

void
swap_quad(int64_t *p)
{
	int64_t t;

	t = htole64(p[0]);
	p[0] = htole64(p[1]);
	p[1] = t;
}

/*
 * emulate STQF, STQFA, LDQF, and LDQFA
 */
int
emul_qf(int32_t insv, struct proc *p, union sigval sv, struct trapframe *tf)
{
	extern struct fpstate64 initfpstate;
	struct fpstate64 *fs = p->p_md.md_fpstate;
	int64_t addr, buf[2];
	union instr ins;
	int freg, isload, err;
	u_int8_t asi;

	ins.i_int = insv;
	freg = ins.i_op3.i_rd & ~1;
	freg |= (ins.i_op3.i_rd & 1) << 5;

	if (ins.i_op3.i_op3 == IOP3_LDQF || ins.i_op3.i_op3 == IOP3_LDQFA)
		isload = 1;
	else
		isload = 0;

	if (ins.i_op3.i_op3 == IOP3_STQF || ins.i_op3.i_op3 == IOP3_LDQF)
		asi = ASI_PRIMARY;
	else if (ins.i_loadstore.i_i)
		asi = (tf->tf_tstate & TSTATE_ASI) >> TSTATE_ASI_SHIFT;
	else
		asi = ins.i_asi.i_asi;

	addr = tf->tf_global[ins.i_asi.i_rs1];
	if (ins.i_loadstore.i_i)
		addr += SIGN_EXT13(ins.i_simm13.i_simm13);
	else
		addr += tf->tf_global[ins.i_asi.i_rs2];

	if (asi < ASI_PRIMARY) {
		/* privileged asi */
		trapsignal(p, SIGILL, 0, ILL_PRVOPC, sv);
		return (0);
	}
	if (asi > ASI_SECONDARY_NOFAULT_LITTLE ||
	    (asi > ASI_SECONDARY_NOFAULT && asi < ASI_PRIMARY_LITTLE)) {
		/* architecturally undefined user ASI's */
		goto segv;
	}

	if ((freg & 3) != 0) {
		/* only valid for %fN where N % 4 = 0 */
		trapsignal(p, SIGILL, 0, ILL_ILLOPN, sv);
		return (0);
	}

	if ((p->p_md.md_flags & MDP_FIXALIGN) == 0 && (addr & 3) != 0) {
		/*
		 * If process doesn't want us to fix alignment and the
		 * request isn't aligned, kill it.
		 */
		trapsignal(p, SIGBUS, 0, BUS_ADRALN, sv);
		return (0);
	}

	fs = p->p_md.md_fpstate;
	if (fs == NULL) {
		/* don't currently have an fpu context, get one */
		fs = malloc(sizeof(*fs), M_SUBPROC, M_WAITOK);
		*fs = initfpstate;
		fs->fs_qsize = 0;
		p->p_md.md_fpstate = fs;
	}
	if (fpproc != p) {
		/* make this process the current holder of the fpu */
		if (fpproc != NULL)
			savefpstate(fpproc->p_md.md_fpstate);
		fpproc = p;
	}
	tf->tf_tstate |= TSTATE_PEF;

	/* Ok, try to do the actual operation (finally) */
	if (isload) {
		err = copyin((caddr_t)addr, buf, sizeof(buf));
		if (err != 0 && (asi & 2) == 0)
			goto segv;
		if (err == 0) {
			savefpstate(fs);
			if (asi & 8)
				swap_quad(buf);
			bcopy(buf, &fs->fs_regs[freg], sizeof(buf));
			loadfpstate(fs);
		}
	} else {
		bcopy(&fs->fs_regs[freg], buf, sizeof(buf));
		if (asi & 8)
			swap_quad(buf);
		if (copyout(buf, (caddr_t)addr, sizeof(buf)) && (asi & 2) == 0)
			goto segv;
	}

	return (1);

segv:
	trapsignal(p, SIGSEGV, isload ? VM_PROT_READ : VM_PROT_WRITE,
	    SEGV_MAPERR, sv);
	return (0);
}

int
emul_popc(int32_t insv, struct proc *p, union sigval sv, struct trapframe *tf)
{
	u_int64_t val, ret = 0;
	union instr ins;

	ins.i_int = insv;
	if (ins.i_simm13.i_i == 0)
		val = tf->tf_global[ins.i_asi.i_rs2];
	else
		val = SIGN_EXT13(ins.i_simm13.i_simm13);

	for (; val != 0; val >>= 1)
		ret += val & 1;

	tf->tf_global[ins.i_asi.i_rd] = ret;
	return (1);
@


1.1
log
@Lot of stuff... Some from NetBSD, some from OpenBSD, minor modifications
@
text
@d1 1
@

