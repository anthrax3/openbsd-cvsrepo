head	1.184;
access;
symbols
	OPENBSD_6_1:1.183.0.4
	OPENBSD_6_1_BASE:1.183
	OPENBSD_6_0:1.178.0.2
	OPENBSD_6_0_BASE:1.178
	OPENBSD_5_9:1.174.0.2
	OPENBSD_5_9_BASE:1.174
	OPENBSD_5_8:1.172.0.6
	OPENBSD_5_8_BASE:1.172
	OPENBSD_5_7:1.172.0.2
	OPENBSD_5_7_BASE:1.172
	OPENBSD_5_6:1.167.0.4
	OPENBSD_5_6_BASE:1.167
	OPENBSD_5_5:1.149.0.4
	OPENBSD_5_5_BASE:1.149
	OPENBSD_5_4:1.147.0.2
	OPENBSD_5_4_BASE:1.147
	OPENBSD_5_3:1.146.0.2
	OPENBSD_5_3_BASE:1.146
	OPENBSD_5_2:1.138.0.2
	OPENBSD_5_2_BASE:1.138
	OPENBSD_5_1_BASE:1.136
	OPENBSD_5_1:1.136.0.4
	OPENBSD_5_0:1.136.0.2
	OPENBSD_5_0_BASE:1.136
	OPENBSD_4_9:1.127.0.2
	OPENBSD_4_9_BASE:1.127
	OPENBSD_4_8:1.124.0.2
	OPENBSD_4_8_BASE:1.124
	OPENBSD_4_7:1.122.0.2
	OPENBSD_4_7_BASE:1.122
	OPENBSD_4_6:1.118.0.4
	OPENBSD_4_6_BASE:1.118
	OPENBSD_4_5:1.115.0.2
	OPENBSD_4_5_BASE:1.115
	OPENBSD_4_4:1.112.0.2
	OPENBSD_4_4_BASE:1.112
	OPENBSD_4_3:1.105.0.2
	OPENBSD_4_3_BASE:1.105
	OPENBSD_4_2:1.93.0.2
	OPENBSD_4_2_BASE:1.93
	OPENBSD_4_1:1.86.0.2
	OPENBSD_4_1_BASE:1.86
	OPENBSD_4_0:1.83.0.2
	OPENBSD_4_0_BASE:1.83
	OPENBSD_3_9:1.80.0.2
	OPENBSD_3_9_BASE:1.80
	OPENBSD_3_8:1.76.0.2
	OPENBSD_3_8_BASE:1.76
	OPENBSD_3_7:1.74.0.2
	OPENBSD_3_7_BASE:1.74
	OPENBSD_3_6:1.70.0.2
	OPENBSD_3_6_BASE:1.70
	SMP_SYNC_A:1.67
	SMP_SYNC_B:1.67
	OPENBSD_3_5:1.67.0.2
	OPENBSD_3_5_BASE:1.67
	OPENBSD_3_4:1.65.0.2
	OPENBSD_3_4_BASE:1.65
	UBC_SYNC_A:1.59
	OPENBSD_3_3:1.59.0.2
	OPENBSD_3_3_BASE:1.59
	OPENBSD_3_2:1.47.0.2
	OPENBSD_3_2_BASE:1.47
	OPENBSD_3_1:1.41.0.2
	OPENBSD_3_1_BASE:1.41
	UBC_SYNC_B:1.51
	UBC:1.27.0.2
	UBC_BASE:1.27
	SMP:1.18.0.4
	OPENBSD_3_0:1.18.0.2
	OPENBSD_3_0_BASE:1.18;
locks; strict;
comment	@ * @;


1.184
date	2017.05.25.03.19.39;	author dlg;	state Exp;
branches;
next	1.183;
commitid	gx8rjMxrMcqYnydg;

1.183
date	2017.01.21.05.42.03;	author guenther;	state Exp;
branches;
next	1.182;
commitid	CHRb0fCqa8XxUAMH;

1.182
date	2017.01.13.09.18.11;	author fcambus;	state Exp;
branches;
next	1.181;
commitid	C556oRR1TXBPfD4D;

1.181
date	2016.10.09.11.25.40;	author tom;	state Exp;
branches;
next	1.180;
commitid	DfYvEDcFmu1LY9q1;

1.180
date	2016.10.08.05.49.09;	author guenther;	state Exp;
branches;
next	1.179;
commitid	z63v1DilayzHcfkw;

1.179
date	2016.09.18.14.28.25;	author deraadt;	state Exp;
branches;
next	1.178;
commitid	BJaYTqaJQ1246GGO;

1.178
date	2016.07.16.08.53.38;	author tom;	state Exp;
branches;
next	1.177;
commitid	k7UhQ5FCwMJC7iLG;

1.177
date	2016.05.21.01.12.35;	author deraadt;	state Exp;
branches;
next	1.176;
commitid	d2M5UZDUv3N3eZef;

1.176
date	2016.05.10.18.39.49;	author deraadt;	state Exp;
branches;
next	1.175;
commitid	qfOifNidEGDB2jL1;

1.175
date	2016.03.07.13.21.51;	author naddy;	state Exp;
branches;
next	1.174;
commitid	EDvRPKRZUDEEb6oR;

1.174
date	2015.10.21.07.59.18;	author mpi;	state Exp;
branches;
next	1.173;
commitid	XglPgGQ8qaiL0M4l;

1.173
date	2015.09.08.10.24.26;	author deraadt;	state Exp;
branches;
next	1.172;
commitid	vmJYOChRDa3hLxTe;

1.172
date	2014.12.10.15.29.53;	author mikeb;	state Exp;
branches;
next	1.171;
commitid	qHQiR2HLROzvZr7B;

1.171
date	2014.11.16.12.30.59;	author deraadt;	state Exp;
branches;
next	1.170;
commitid	yv0ECmCdICvq576h;

1.170
date	2014.10.25.16.58.59;	author kettenis;	state Exp;
branches;
next	1.169;
commitid	fh1IjCSQKOyp1bbm;

1.169
date	2014.10.24.20.26.58;	author kettenis;	state Exp;
branches;
next	1.168;
commitid	uHRFGdi1cruubpXH;

1.168
date	2014.09.18.18.55.23;	author kettenis;	state Exp;
branches;
next	1.167;
commitid	99PB3KmpuEsFyeCN;

1.167
date	2014.07.21.17.25.47;	author uebayasi;	state Exp;
branches;
next	1.166;
commitid	7QO4UJr3EKVAMc8t;

1.166
date	2014.07.13.22.53.39;	author uebayasi;	state Exp;
branches;
next	1.165;
commitid	wsdp3qtXGjMj98oD;

1.165
date	2014.07.13.22.13.07;	author uebayasi;	state Exp;
branches;
next	1.164;
commitid	qYPOd6Qi4aRBKldK;

1.164
date	2014.07.12.18.44.43;	author tedu;	state Exp;
branches;
next	1.163;
commitid	uKVPYMN2MLxdZxzH;

1.163
date	2014.07.11.22.28.06;	author uebayasi;	state Exp;
branches;
next	1.162;
commitid	fOXKrBuMmlMGQdd4;

1.162
date	2014.07.11.09.36.26;	author mpi;	state Exp;
branches;
next	1.161;
commitid	vsYjSRfS3Y783BvW;

1.161
date	2014.07.10.21.46.03;	author mpi;	state Exp;
branches;
next	1.160;
commitid	iYq3Z1ZWDKR3sS9G;

1.160
date	2014.07.10.20.15.27;	author uebayasi;	state Exp;
branches;
next	1.159;
commitid	YzvTa4t6mddz7Mh4;

1.159
date	2014.07.10.13.34.32;	author uebayasi;	state Exp;
branches;
next	1.158;
commitid	xpsLTYRIkonFtkr1;

1.158
date	2014.07.10.12.13.49;	author uebayasi;	state Exp;
branches;
next	1.157;
commitid	aofvn6ceiucgjg4N;

1.157
date	2014.05.31.15.49.28;	author mpi;	state Exp;
branches;
next	1.156;
commitid	eA4Y0YE1IUzj6hpW;

1.156
date	2014.05.30.13.46.17;	author mpi;	state Exp;
branches;
next	1.155;

1.155
date	2014.05.25.13.57.48;	author deraadt;	state Exp;
branches;
next	1.154;

1.154
date	2014.05.10.12.29.58;	author kettenis;	state Exp;
branches;
next	1.153;

1.153
date	2014.03.26.05.23.42;	author guenther;	state Exp;
branches;
next	1.152;

1.152
date	2014.03.22.06.05.45;	author guenther;	state Exp;
branches;
next	1.151;

1.151
date	2014.03.21.03.56.49;	author guenther;	state Exp;
branches;
next	1.150;

1.150
date	2014.03.13.03.52.56;	author dlg;	state Exp;
branches;
next	1.149;

1.149
date	2013.11.01.17.36.19;	author krw;	state Exp;
branches;
next	1.148;

1.148
date	2013.09.28.12.40.32;	author miod;	state Exp;
branches;
next	1.147;

1.147
date	2013.06.11.16.42.12;	author deraadt;	state Exp;
branches;
next	1.146;

1.146
date	2013.02.15.22.58.17;	author kettenis;	state Exp;
branches;
next	1.145;

1.145
date	2013.01.22.23.56.31;	author dlg;	state Exp;
branches;
next	1.144;

1.144
date	2012.12.22.17.26.46;	author kettenis;	state Exp;
branches;
next	1.143;

1.143
date	2012.12.02.07.03.31;	author guenther;	state Exp;
branches;
next	1.142;

1.142
date	2012.10.22.17.27.19;	author kettenis;	state Exp;
branches;
next	1.141;

1.141
date	2012.10.08.21.47.50;	author deraadt;	state Exp;
branches;
next	1.140;

1.140
date	2012.08.24.10.00.55;	author jsg;	state Exp;
branches;
next	1.139;

1.139
date	2012.08.22.13.33.33;	author okan;	state Exp;
branches;
next	1.138;

1.138
date	2012.05.09.18.34.21;	author okan;	state Exp;
branches;
next	1.137;

1.137
date	2012.03.23.15.51.26;	author guenther;	state Exp;
branches;
next	1.136;

1.136
date	2011.07.05.04.48.02;	author guenther;	state Exp;
branches;
next	1.135;

1.135
date	2011.06.26.22.40.00;	author deraadt;	state Exp;
branches;
next	1.134;

1.134
date	2011.06.24.19.47.49;	author naddy;	state Exp;
branches;
next	1.133;

1.133
date	2011.06.23.20.44.39;	author ariane;	state Exp;
branches;
next	1.132;

1.132
date	2011.06.05.19.41.08;	author deraadt;	state Exp;
branches;
next	1.131;

1.131
date	2011.04.18.21.44.56;	author guenther;	state Exp;
branches;
next	1.130;

1.130
date	2011.04.15.04.52.40;	author guenther;	state Exp;
branches;
next	1.129;

1.129
date	2011.04.07.15.30.16;	author miod;	state Exp;
branches;
next	1.128;

1.128
date	2011.03.05.17.48.59;	author deraadt;	state Exp;
branches;
next	1.127;

1.127
date	2010.12.26.15.41.00;	author miod;	state Exp;
branches;
next	1.126;

1.126
date	2010.11.27.19.41.48;	author miod;	state Exp;
branches;
next	1.125;

1.125
date	2010.11.20.20.33.24;	author miod;	state Exp;
branches;
next	1.124;

1.124
date	2010.06.27.03.03.48;	author thib;	state Exp;
branches;
next	1.123;

1.123
date	2010.03.29.19.21.58;	author oga;	state Exp;
branches;
next	1.122;

1.122
date	2009.12.08.21.23.18;	author kettenis;	state Exp;
branches;
next	1.121;

1.121
date	2009.08.11.19.17.17;	author miod;	state Exp;
branches;
next	1.120;

1.120
date	2009.08.11.18.46.32;	author miod;	state Exp;
branches;
next	1.119;

1.119
date	2009.08.09.10.40.18;	author blambert;	state Exp;
branches;
next	1.118;

1.118
date	2009.04.20.00.42.06;	author oga;	state Exp;
branches;
next	1.117;

1.117
date	2009.04.14.16.01.04;	author oga;	state Exp;
branches;
next	1.116;

1.116
date	2009.03.07.15.34.34;	author miod;	state Exp;
branches;
next	1.115;

1.115
date	2009.02.17.19.05.52;	author oga;	state Exp;
branches;
next	1.114;

1.114
date	2008.12.30.16.05.45;	author kettenis;	state Exp;
branches;
next	1.113;

1.113
date	2008.11.22.18.12.32;	author art;	state Exp;
branches;
next	1.112;

1.112
date	2008.06.27.17.22.15;	author miod;	state Exp;
branches;
next	1.111;

1.111
date	2008.06.26.05.42.13;	author ray;	state Exp;
branches;
next	1.110;

1.110
date	2008.06.09.07.07.15;	author djm;	state Exp;
branches;
next	1.109;

1.109
date	2008.04.20.10.35.57;	author kettenis;	state Exp;
branches;
next	1.108;

1.108
date	2008.04.18.06.42.21;	author djm;	state Exp;
branches;
next	1.107;

1.107
date	2008.04.09.16.58.10;	author deraadt;	state Exp;
branches;
next	1.106;

1.106
date	2008.03.22.21.10.29;	author kettenis;	state Exp;
branches;
next	1.105;

1.105
date	2008.01.04.00.40.38;	author kettenis;	state Exp;
branches;
next	1.104;

1.104
date	2007.12.22.15.14.58;	author kettenis;	state Exp;
branches;
next	1.103;

1.103
date	2007.12.16.12.43.54;	author kettenis;	state Exp;
branches;
next	1.102;

1.102
date	2007.11.16.20.51.29;	author kettenis;	state Exp;
branches;
next	1.101;

1.101
date	2007.10.31.22.46.52;	author kettenis;	state Exp;
branches;
next	1.100;

1.100
date	2007.10.20.16.54.52;	author miod;	state Exp;
branches;
next	1.99;

1.99
date	2007.10.16.20.33.27;	author kettenis;	state Exp;
branches;
next	1.98;

1.98
date	2007.10.08.17.48.06;	author krw;	state Exp;
branches;
next	1.97;

1.97
date	2007.10.02.00.59.12;	author krw;	state Exp;
branches;
next	1.96;

1.96
date	2007.09.08.17.13.18;	author kettenis;	state Exp;
branches;
next	1.95;

1.95
date	2007.09.03.01.09.09;	author krw;	state Exp;
branches;
next	1.94;

1.94
date	2007.08.25.19.05.56;	author kettenis;	state Exp;
branches;
next	1.93;

1.93
date	2007.08.04.16.44.15;	author kettenis;	state Exp;
branches;
next	1.92;

1.92
date	2007.07.22.21.33.04;	author kettenis;	state Exp;
branches;
next	1.91;

1.91
date	2007.06.06.17.15.13;	author deraadt;	state Exp;
branches;
next	1.90;

1.90
date	2007.05.29.20.36.48;	author deraadt;	state Exp;
branches;
next	1.89;

1.89
date	2007.05.26.20.26.51;	author pedro;	state Exp;
branches;
next	1.88;

1.88
date	2007.05.23.20.33.47;	author pvalchev;	state Exp;
branches;
next	1.87;

1.87
date	2007.03.31.22.16.48;	author deraadt;	state Exp;
branches;
next	1.86;

1.86
date	2006.12.30.16.25.41;	author kettenis;	state Exp;
branches;
next	1.85;

1.85
date	2006.11.19.16.49.22;	author miod;	state Exp;
branches;
next	1.84;

1.84
date	2006.09.22.19.16.07;	author miod;	state Exp;
branches;
next	1.83;

1.83
date	2006.06.21.21.53.32;	author jason;	state Exp;
branches;
next	1.82;

1.82
date	2006.06.07.19.13.08;	author miod;	state Exp;
branches;
next	1.81;

1.81
date	2006.03.15.21.03.39;	author deraadt;	state Exp;
branches;
next	1.80;

1.80
date	2006.01.02.18.19.41;	author miod;	state Exp;
branches;
next	1.79;

1.79
date	2005.11.24.22.30.08;	author miod;	state Exp;
branches;
next	1.78;

1.78
date	2005.11.11.16.50.21;	author miod;	state Exp;
branches;
next	1.77;

1.77
date	2005.10.24.19.07.40;	author martin;	state Exp;
branches;
next	1.76;

1.76
date	2005.07.09.22.51.13;	author robert;	state Exp;
branches;
next	1.75;

1.75
date	2005.03.29.19.34.07;	author kettenis;	state Exp;
branches;
next	1.74;

1.74
date	2004.11.02.21.20.59;	author miod;	state Exp;
branches;
next	1.73;

1.73
date	2004.10.01.18.18.49;	author jason;	state Exp;
branches;
next	1.72;

1.72
date	2004.09.28.02.06.36;	author jason;	state Exp;
branches;
next	1.71;

1.71
date	2004.09.27.21.12.40;	author jason;	state Exp;
branches;
next	1.70;

1.70
date	2004.08.02.21.40.46;	author brad;	state Exp;
branches;
next	1.69;

1.69
date	2004.06.28.01.47.41;	author aaron;	state Exp;
branches;
next	1.68;

1.68
date	2004.06.23.04.40.05;	author aaron;	state Exp;
branches;
next	1.67;

1.67
date	2004.03.10.23.02.54;	author tom;	state Exp;
branches;
next	1.66;

1.66
date	2004.02.19.18.46.18;	author miod;	state Exp;
branches;
next	1.65;

1.65
date	2003.06.24.21.54.39;	author henric;	state Exp;
branches;
next	1.64;

1.64
date	2003.06.16.20.46.14;	author miod;	state Exp;
branches;
next	1.63;

1.63
date	2003.06.06.11.17.48;	author henric;	state Exp;
branches;
next	1.62;

1.62
date	2003.06.02.23.27.56;	author millert;	state Exp;
branches;
next	1.61;

1.61
date	2003.06.02.18.14.16;	author jason;	state Exp;
branches;
next	1.60;

1.60
date	2003.06.01.17.43.50;	author art;	state Exp;
branches;
next	1.59;

1.59
date	2003.03.21.22.59.10;	author jason;	state Exp;
branches;
next	1.58;

1.58
date	2003.03.06.08.26.08;	author henric;	state Exp;
branches;
next	1.57;

1.57
date	2003.02.24.01.00.52;	author miod;	state Exp;
branches;
next	1.56;

1.56
date	2003.02.22.22.50.34;	author jason;	state Exp;
branches;
next	1.55;

1.55
date	2003.02.17.01.29.20;	author henric;	state Exp;
branches;
next	1.54;

1.54
date	2002.12.17.23.11.32;	author millert;	state Exp;
branches;
next	1.53;

1.53
date	2002.11.03.01.59.28;	author miod;	state Exp;
branches;
next	1.52;

1.52
date	2002.10.29.18.30.21;	author art;	state Exp;
branches;
next	1.51;

1.51
date	2002.10.12.01.09.43;	author krw;	state Exp;
branches;
next	1.50;

1.50
date	2002.10.07.18.35.57;	author mickey;	state Exp;
branches;
next	1.49;

1.49
date	2002.10.06.22.06.15;	author art;	state Exp;
branches;
next	1.48;

1.48
date	2002.10.06.20.18.54;	author art;	state Exp;
branches;
next	1.47;

1.47
date	2002.07.20.19.24.57;	author art;	state Exp;
branches;
next	1.46;

1.46
date	2002.07.10.20.30.15;	author jsyn;	state Exp;
branches;
next	1.45;

1.45
date	2002.07.03.21.19.05;	author miod;	state Exp;
branches;
next	1.44;

1.44
date	2002.06.15.17.23.31;	author art;	state Exp;
branches;
next	1.43;

1.43
date	2002.06.14.21.34.59;	author todd;	state Exp;
branches;
next	1.42;

1.42
date	2002.06.14.04.17.59;	author art;	state Exp;
branches;
next	1.41;

1.41
date	2002.03.27.15.12.22;	author jason;	state Exp;
branches;
next	1.40;

1.40
date	2002.03.23.13.28.34;	author espie;	state Exp;
branches;
next	1.39;

1.39
date	2002.03.14.03.16.01;	author millert;	state Exp;
branches;
next	1.38;

1.38
date	2002.03.14.01.26.45;	author millert;	state Exp;
branches;
next	1.37;

1.37
date	2002.02.21.20.30.15;	author art;	state Exp;
branches;
next	1.36;

1.36
date	2002.02.18.17.22.05;	author jason;	state Exp;
branches;
next	1.35;

1.35
date	2002.02.17.22.59.53;	author maja;	state Exp;
branches;
next	1.34;

1.34
date	2002.02.05.18.34.39;	author jason;	state Exp;
branches;
next	1.33;

1.33
date	2002.02.01.21.48.23;	author jason;	state Exp;
branches;
next	1.32;

1.32
date	2002.02.01.19.38.23;	author jason;	state Exp;
branches;
next	1.31;

1.31
date	2002.01.23.17.51.52;	author art;	state Exp;
branches;
next	1.30;

1.30
date	2002.01.23.17.35.56;	author art;	state Exp;
branches;
next	1.29;

1.29
date	2002.01.16.20.50.17;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2002.01.04.01.17.46;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2001.12.04.23.22.42;	author art;	state Exp;
branches
	1.27.2.1;
next	1.26;

1.26
date	2001.11.24.17.53.41;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2001.11.16.21.28.08;	author jason;	state Exp;
branches;
next	1.24;

1.24
date	2001.11.16.20.58.45;	author jason;	state Exp;
branches;
next	1.23;

1.23
date	2001.11.16.16.42.45;	author jason;	state Exp;
branches;
next	1.22;

1.22
date	2001.11.10.20.11.04;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2001.11.09.15.25.55;	author art;	state Exp;
branches;
next	1.20;

1.20
date	2001.11.07.01.18.00;	author art;	state Exp;
branches;
next	1.19;

1.19
date	2001.11.06.19.53.16;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2001.09.19.20.50.57;	author mickey;	state Exp;
branches
	1.18.4.1;
next	1.17;

1.17
date	2001.09.07.16.20.07;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2001.09.07.15.44.08;	author art;	state Exp;
branches;
next	1.15;

1.15
date	2001.08.31.06.29.40;	author art;	state Exp;
branches;
next	1.14;

1.14
date	2001.08.30.20.06.07;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2001.08.30.17.58.27;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2001.08.30.15.26.57;	author jason;	state Exp;
branches;
next	1.11;

1.11
date	2001.08.24.00.05.19;	author art;	state Exp;
branches;
next	1.10;

1.10
date	2001.08.23.14.01.03;	author art;	state Exp;
branches;
next	1.9;

1.9
date	2001.08.23.12.02.05;	author art;	state Exp;
branches;
next	1.8;

1.8
date	2001.08.20.20.23.53;	author jason;	state Exp;
branches;
next	1.7;

1.7
date	2001.08.20.19.43.20;	author jason;	state Exp;
branches;
next	1.6;

1.6
date	2001.08.19.18.23.53;	author art;	state Exp;
branches;
next	1.5;

1.5
date	2001.08.19.17.41.59;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2001.08.19.06.24.11;	author art;	state Exp;
branches;
next	1.3;

1.3
date	2001.08.19.06.17.51;	author art;	state Exp;
branches;
next	1.2;

1.2
date	2001.08.19.06.15.46;	author art;	state Exp;
branches;
next	1.1;

1.1
date	2001.08.19.05.21.38;	author jason;	state Exp;
branches;
next	;

1.18.4.1
date	2001.10.31.03.07.59;	author nate;	state Exp;
branches;
next	1.18.4.2;

1.18.4.2
date	2001.11.13.21.04.17;	author niklas;	state Exp;
branches;
next	1.18.4.3;

1.18.4.3
date	2001.12.05.00.39.13;	author niklas;	state Exp;
branches;
next	1.18.4.4;

1.18.4.4
date	2002.03.06.02.04.47;	author niklas;	state Exp;
branches;
next	1.18.4.5;

1.18.4.5
date	2002.03.28.11.23.52;	author niklas;	state Exp;
branches;
next	1.18.4.6;

1.18.4.6
date	2003.03.27.23.42.37;	author niklas;	state Exp;
branches;
next	1.18.4.7;

1.18.4.7
date	2003.06.07.11.14.46;	author ho;	state Exp;
branches;
next	1.18.4.8;

1.18.4.8
date	2004.02.19.10.50.01;	author niklas;	state Exp;
branches;
next	1.18.4.9;

1.18.4.9
date	2004.06.05.23.11.01;	author niklas;	state Exp;
branches;
next	;

1.27.2.1
date	2002.01.31.22.55.25;	author niklas;	state Exp;
branches;
next	1.27.2.2;

1.27.2.2
date	2002.06.11.03.38.43;	author art;	state Exp;
branches;
next	1.27.2.3;

1.27.2.3
date	2002.10.29.00.28.12;	author art;	state Exp;
branches;
next	1.27.2.4;

1.27.2.4
date	2003.05.19.21.46.58;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.184
log
@tweak sparc64 membars as a step toward making them usable in userland.

specifically, dont rely on magic in ctlreg to implement membars. moving
that to atomic.h would add a lot of pollution to the namespace, so
move to passing the membar options to a single __membar macro.

this tweaks everything that was using the ctlreg backend to either use
an appropriate membar_foo(), or to use __membar() in the MD code.

ok kettenis@@
@
text
@/*	$OpenBSD: machdep.c,v 1.183 2017/01/21 05:42:03 guenther Exp $	*/
/*	$NetBSD: machdep.c,v 1.108 2001/07/24 19:30:14 eeh Exp $ */

/*-
 * Copyright (c) 1996, 1997, 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,
 * NASA Ames Research Center.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
 *
 * All advertising materials mentioning features or use of this software
 * must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Lawrence Berkeley Laboratory.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)machdep.c	8.6 (Berkeley) 1/14/94
 */

#include <sys/param.h>
#include <sys/extent.h>
#include <sys/signal.h>
#include <sys/signalvar.h>
#include <sys/proc.h>
#include <sys/user.h>
#include <sys/buf.h>
#include <sys/device.h>
#include <sys/reboot.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/conf.h>
#include <sys/file.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/mount.h>
#include <sys/msgbuf.h>
#include <sys/syscallargs.h>
#include <sys/exec.h>

#include <net/if.h>
#include <uvm/uvm.h>

#include <sys/sysctl.h>
#include <sys/exec_elf.h>
#include <dev/rndvar.h>

#define _SPARC_BUS_DMA_PRIVATE
#include <machine/autoconf.h>
#include <machine/bus.h>
#include <machine/frame.h>
#include <machine/cpu.h>
#include <machine/pmap.h>
#include <machine/openfirm.h>
#include <machine/sparc64.h>

#include <sparc64/sparc64/cache.h>

#include "pckbc.h"
#include "pckbd.h"
#if (NPCKBC > 0) && (NPCKBD == 0)
#include <dev/ic/pckbcvar.h>
#endif

int     _bus_dmamap_create(bus_dma_tag_t, bus_dma_tag_t, bus_size_t, int,
	    bus_size_t, bus_size_t, int, bus_dmamap_t *);
void    _bus_dmamap_destroy(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t);
int     _bus_dmamap_load(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t, void *,
            bus_size_t, struct proc *, int);
int     _bus_dmamap_load_mbuf(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t,
            struct mbuf *, int);
int     _bus_dmamap_load_uio(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t,
            struct uio *, int);
int     _bus_dmamap_load_raw(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t,
            bus_dma_segment_t *, int, bus_size_t, int);
int	_bus_dmamap_load_buffer(bus_dma_tag_t, bus_dmamap_t, void *,
	    bus_size_t, struct proc *, int, bus_addr_t *, int *, int);

void    _bus_dmamap_unload(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t);
void    _bus_dmamap_sync(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t,
	    bus_addr_t, bus_size_t, int);

int     _bus_dmamem_alloc(bus_dma_tag_t, bus_dma_tag_t tag, bus_size_t size,
            bus_size_t alignment, bus_size_t boundary,
            bus_dma_segment_t *segs, int nsegs, int *rsegs, int flags);

void    _bus_dmamem_free(bus_dma_tag_t tag, bus_dma_tag_t,
	    bus_dma_segment_t *segs, int nsegs);
int     _bus_dmamem_map(bus_dma_tag_t tag, bus_dma_tag_t,
	    bus_dma_segment_t *segs, int nsegs, size_t size, caddr_t *kvap,
	    int flags);
void    _bus_dmamem_unmap(bus_dma_tag_t tag, bus_dma_tag_t, caddr_t kva,
            size_t size);
paddr_t _bus_dmamem_mmap(bus_dma_tag_t tag, bus_dma_tag_t,
	    bus_dma_segment_t *segs, int nsegs, off_t off, int prot, int flags);

int     _bus_dmamem_alloc_range(bus_dma_tag_t tag, bus_dma_tag_t,
	    bus_size_t size, bus_size_t alignment, bus_size_t boundary,
            bus_dma_segment_t *segs, int nsegs, int *rsegs, int flags,
            vaddr_t low, vaddr_t high);

/*
 * The "bus_space_debug" flags used by macros elsewhere.
 * A good set of flags to use when first debugging something is:
 * int bus_space_debug = BSDB_ACCESS | BSDB_ASSERT | BSDB_MAP;
 */
int bus_space_debug = 0;

struct vm_map *exec_map = NULL;
struct vm_map *phys_map = NULL;

struct uvm_constraint_range  dma_constraint = { 0x0, (paddr_t)-1 };
struct uvm_constraint_range *uvm_md_constraints[] = { NULL };

int	physmem;
extern	caddr_t msgbufaddr;

int sparc_led_blink = 1;

#ifdef APERTURE
int allowaperture = 0;
#endif

extern int ceccerrs;
extern int64_t cecclast;

/*
 * Maximum number of DMA segments we'll allow in dmamem_load()
 * routines.  Can be overridden in config files, etc.
 */
#ifndef MAX_DMA_SEGS
#define MAX_DMA_SEGS	20
#endif

/*
 * safepri is a safe priority for sleep to set for a spin-wait
 * during autoconfiguration or after a panic.
 */
int   safepri = 0;

void blink_led_timeout(void *);
void	dumpsys(void);
void	stackdump(void);

/*
 * Machine-dependent startup code
 */
void
cpu_startup(void)
{
#ifdef DEBUG
	extern int pmapdebug;
	int opmapdebug = pmapdebug;
#endif
	vaddr_t minaddr, maxaddr;
	extern struct user *proc0paddr;

#ifdef DEBUG
	pmapdebug = 0;
#endif

	proc0.p_addr = proc0paddr;

	/*
	 * Good {morning,afternoon,evening,night}.
	 */
	printf(version);
	/*identifycpu();*/
	printf("real mem = %lu (%luMB)\n", ptoa((psize_t)physmem),
	    ptoa((psize_t)physmem)/1024/1024);

	/*
	 * Allocate a submap for exec arguments.  This map effectively
	 * limits the number of processes exec'ing at any time.
	 */
	minaddr = vm_map_min(kernel_map);
	exec_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
	    16*NCARGS, VM_MAP_PAGEABLE, FALSE, NULL);

	/*
	 * Allocate a submap for physio
	 */
	minaddr = vm_map_min(kernel_map);
	phys_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
	    VM_PHYS_SIZE, 0, FALSE, NULL);

#ifdef DEBUG
	pmapdebug = opmapdebug;
#endif
	printf("avail mem = %lu (%luMB)\n", ptoa((psize_t)uvmexp.free),
	    ptoa((psize_t)uvmexp.free)/1024/1024);

	/*
	 * Set up buffers, so they can be used to read disk labels.
	 */
	bufinit();

#if 0
	pmap_redzone();
#endif
}

/*
 * Set up registers on exec.
 */

#define STACK_OFFSET	BIAS
#define CPOUTREG(l,v)	copyout(&(v), (l), sizeof(v))
#undef CCFSZ
#define CCFSZ	CC64FSZ

/* ARGSUSED */
void
setregs(p, pack, stack, retval)
	struct proc *p;
	struct exec_package *pack;
	vaddr_t stack;
	register_t *retval;
{
	struct trapframe64 *tf = p->p_md.md_tf;
	int64_t tstate;
	int pstate = PSTATE_USER;
	Elf_Ehdr *eh = pack->ep_hdr;

	/* 
	 * Setup the process StackGhost cookie which will be XORed into
	 * the return pointer as register windows are over/underflowed.
	 */
	arc4random_buf(&p->p_addr->u_pcb.pcb_wcookie,
	    sizeof(p->p_addr->u_pcb.pcb_wcookie));

	/* The cookie needs to guarantee invalid alignment after the XOR. */
	switch (p->p_addr->u_pcb.pcb_wcookie % 3) {
	case 0: /* Two lsb's already both set except if the cookie is 0. */
		p->p_addr->u_pcb.pcb_wcookie |= 0x3;
		break;
	case 1: /* Set the lsb. */
		p->p_addr->u_pcb.pcb_wcookie = 1 |
		    (p->p_addr->u_pcb.pcb_wcookie & ~0x3);
		break;
	case 2: /* Set the second most lsb. */
		p->p_addr->u_pcb.pcb_wcookie = 2 |
		    (p->p_addr->u_pcb.pcb_wcookie & ~0x3);
		break;
	}

	/*
	 * Set the registers to 0 except for:
	 *	%o6: stack pointer, built in exec())
	 *	%tstate: (retain icc and xcc and cwp bits)
	 *	%tpc,%tnpc: entry point of program
	 */
	/* Check what memory model is requested */
	switch ((eh->e_flags & EF_SPARCV9_MM)) {
	default:
		printf("Unknown memory model %d\n", 
		       (eh->e_flags & EF_SPARCV9_MM));
		/* FALLTHROUGH */
	case EF_SPARCV9_TSO:
		pstate = PSTATE_MM_TSO|PSTATE_IE;
		break;
	case EF_SPARCV9_PSO:
		pstate = PSTATE_MM_PSO|PSTATE_IE;
		break;
	case EF_SPARCV9_RMO:
		pstate = PSTATE_MM_RMO|PSTATE_IE;
		break;
	}

	tstate = ((u_int64_t)ASI_PRIMARY_NO_FAULT << TSTATE_ASI_SHIFT) |
	    (pstate << TSTATE_PSTATE_SHIFT) | (tf->tf_tstate & TSTATE_CWP);
	if (p->p_md.md_fpstate != NULL) {
		/*
		 * We hold an FPU state.  If we own *the* FPU chip state
		 * we must get rid of it, and the only way to do that is
		 * to save it.  In any case, get rid of our FPU state.
		 */
		fpusave_proc(p, 0);
		free(p->p_md.md_fpstate, M_SUBPROC, sizeof(struct fpstate64));
		p->p_md.md_fpstate = NULL;
	}
	bzero((caddr_t)tf, sizeof *tf);
	tf->tf_tstate = tstate;
	tf->tf_pc = pack->ep_entry & ~3;
	tf->tf_npc = tf->tf_pc + 4;
	tf->tf_global[2] = tf->tf_pc;
	stack -= sizeof(struct rwindow);
	tf->tf_out[6] = stack - STACK_OFFSET;
#ifdef NOTDEF_DEBUG
	printf("setregs: setting tf %p sp %p pc %p\n", (long)tf, 
	       (long)tf->tf_out[6], (long)tf->tf_pc);
#endif
	retval[1] = 0;
}

#ifdef DEBUG
int sigdebug = 0;
pid_t sigpid = 0;
#define SDB_FOLLOW	0x01
#define SDB_KSTACK	0x02
#define SDB_FPSTATE	0x04
#define SDB_DDB		0x08
#endif

struct sigframe {
	int	sf_signo;		/* signal number */
	int	sf_code;		/* signal code (unused) */
	siginfo_t *sf_sip;		/* points to siginfo_t */
	struct	sigcontext sf_sc;	/* actual sigcontext */
	siginfo_t sf_si;
};

/*
 * machine dependent system variables.
 */
int
cpu_sysctl(int *name, u_int namelen, void *oldp, size_t *oldlenp, void *newp,
    size_t newlen, struct proc *p)
{
	int oldval, ret;

	/* all sysctl names at this level are terminal */
	if (namelen != 1)
		return (ENOTDIR);	/* overloaded */

	switch (name[0]) {
	case CPU_LED_BLINK:
		oldval = sparc_led_blink;
		ret = sysctl_int(oldp, oldlenp, newp, newlen,
		    &sparc_led_blink);
		/*
		 * If we were false and are now true, start the timer.
		 */
		if (!oldval && sparc_led_blink > oldval)
			blink_led_timeout(NULL);
		return (ret);
	case CPU_ALLOWAPERTURE:
#ifdef APERTURE
		if (securelevel > 0)
			return (sysctl_int_lower(oldp, oldlenp, newp, newlen,
			    &allowaperture));
		else
			return (sysctl_int(oldp, oldlenp, newp, newlen,
			    &allowaperture));
#else
		return (sysctl_rdint(oldp, oldlenp, newp, 0));
#endif
	case CPU_CPUTYPE:
		return (sysctl_rdint(oldp, oldlenp, newp, cputyp));
	case CPU_CECCERRORS:
		return (sysctl_rdint(oldp, oldlenp, newp, ceccerrs));
	case CPU_CECCLAST:
		return (sysctl_rdquad(oldp, oldlenp, newp, cecclast));
	default:
		return (EOPNOTSUPP);
	}
	/* NOTREACHED */
}

/*
 * Send an interrupt to process.
 */
void
sendsig(sig_t catcher, int sig, int mask, u_long code, int type,
    union sigval val)
{
	struct proc *p = curproc;
	struct sigacts *psp = p->p_p->ps_sigacts;
	struct sigframe *fp;
	struct trapframe64 *tf;
	vaddr_t addr, oldsp, newsp;
	struct sigframe sf;

	tf = p->p_md.md_tf;
	oldsp = tf->tf_out[6] + STACK_OFFSET;

	/*
	 * Compute new user stack addresses, subtract off
	 * one signal frame, and align.
	 */
	if ((p->p_sigstk.ss_flags & SS_DISABLE) == 0 &&
	    !sigonstack(oldsp) && (psp->ps_sigonstack & sigmask(sig)))
		fp = (struct sigframe *)((caddr_t)p->p_sigstk.ss_sp +
		    p->p_sigstk.ss_size);
	else
		fp = (struct sigframe *)oldsp;
	/* Allocate an aligned sigframe */
	fp = (struct sigframe *)((long)(fp - 1) & ~0x0f);

	/*
	 * Now set up the signal frame.  We build it in kernel space
	 * and then copy it out.  We probably ought to just build it
	 * directly in user space....
	 */
	bzero(&sf, sizeof(sf));
	sf.sf_signo = sig;
	sf.sf_sip = NULL;

	/*
	 * Build the signal context to be used by sigreturn.
	 */
	sf.sf_sc.sc_mask = mask;
	/* Save register context. */
	sf.sf_sc.sc_sp = (long)tf->tf_out[6];
	sf.sf_sc.sc_pc = tf->tf_pc;
	sf.sf_sc.sc_npc = tf->tf_npc;
	sf.sf_sc.sc_tstate = tf->tf_tstate; /* XXX */
	sf.sf_sc.sc_g1 = tf->tf_global[1];
	sf.sf_sc.sc_o0 = tf->tf_out[0];

	if (psp->ps_siginfo & sigmask(sig)) {
		sf.sf_sip = &fp->sf_si;
		initsiginfo(&sf.sf_si, sig, code, type, val);
	}

	/*
	 * Put the stack in a consistent state before we whack away
	 * at it.  Note that write_user_windows may just dump the
	 * registers into the pcb; we need them in the process's memory.
	 * We also need to make sure that when we start the signal handler,
	 * its %i6 (%fp), which is loaded from the newly allocated stack area,
	 * joins seamlessly with the frame it was in when the signal occurred,
	 * so that the debugger and _longjmp code can back up through it.
	 */
	newsp = (vaddr_t)fp - sizeof(struct rwindow);
	write_user_windows();

	sf.sf_sc.sc_cookie = (long)&fp->sf_sc ^ p->p_p->ps_sigcookie;
	if (rwindow_save(p) || copyout((caddr_t)&sf, (caddr_t)fp, sizeof sf) || 
	    CPOUTREG(&(((struct rwindow *)newsp)->rw_in[6]), tf->tf_out[6])) {
		/*
		 * Process has trashed its stack; give it an illegal
		 * instruction to halt it in its tracks.
		 */
#ifdef DEBUG
		printf("sendsig: stack was trashed trying to send sig %d, "
		    "sending SIGILL\n", sig);
#endif
		sigexit(p, SIGILL);
		/* NOTREACHED */
	}

#ifdef DEBUG
	if (sigdebug & SDB_FOLLOW) {
		printf("sendsig: %s[%d] sig %d scp %p\n",
		    p->p_p->ps_comm, p->p_p->ps_pid, sig, &fp->sf_sc);
	}
#endif

	/*
	 * Arrange to continue execution at the code copied out in exec().
	 * It needs the function to call in %g1, and a new stack pointer.
	 */
	addr = p->p_p->ps_sigcode;
	tf->tf_global[1] = (vaddr_t)catcher;
	tf->tf_pc = addr;
	tf->tf_npc = addr + 4;
	tf->tf_out[6] = newsp - STACK_OFFSET;
}

/*
 * System call to cleanup state after a signal
 * has been taken.  Reset signal mask and
 * stack state from context left by sendsig (above),
 * and return to the given trap frame (if there is one).
 * Check carefully to make sure that the user has not
 * modified the state to gain improper privileges or to cause
 * a machine fault.
 */
/* ARGSUSED */
int
sys_sigreturn(struct proc *p, void *v, register_t *retval)
{
	struct sys_sigreturn_args /* {
		syscallarg(struct sigcontext *) sigcntxp;
	} */ *uap = v;
	struct sigcontext ksc, *scp = SCARG(uap, sigcntxp);
	struct trapframe64 *tf;
	int error = EINVAL;

	if (PROC_PC(p) != p->p_p->ps_sigcoderet) {
		sigexit(p, SIGILL);
		return (EPERM);
	}

	/* First ensure consistent stack state (see sendsig). */
	write_user_windows();

	if (rwindow_save(p)) {
#ifdef DEBUG
		printf("sigreturn: rwindow_save(%p) failed, sending SIGILL\n",
		    p);
#endif
		sigexit(p, SIGILL);
	}

	if ((vaddr_t)scp & 3)
		return (EINVAL);
	if ((error = copyin((caddr_t)scp, &ksc, sizeof ksc)))
		return (error);

	if (ksc.sc_cookie != ((long)scp ^ p->p_p->ps_sigcookie)) {
		sigexit(p, SIGILL);
		return (EFAULT);
	}

	/* Prevent reuse of the sigcontext cookie */
	ksc.sc_cookie = 0;
	(void)copyout(&ksc.sc_cookie, (caddr_t)scp +
	    offsetof(struct sigcontext, sc_cookie), sizeof (ksc.sc_cookie));

	scp = &ksc;

	tf = p->p_md.md_tf;
	/*
	 * Only the icc bits in the psr are used, so it need not be
	 * verified.  pc and npc must be multiples of 4.  This is all
	 * that is required; if it holds, just do it.
	 */
	if (((ksc.sc_pc | ksc.sc_npc) & 3) != 0 ||
	    (ksc.sc_pc == 0) || (ksc.sc_npc == 0)) {
#ifdef DEBUG
		printf("sigreturn: pc %p or npc %p invalid\n",
		   (void *)(unsigned long)ksc.sc_pc,
		   (void *)(unsigned long)ksc.sc_npc);
#endif
		return (EINVAL);
	}

	/* take only psr ICC field */
	tf->tf_tstate = (u_int64_t)(tf->tf_tstate & ~TSTATE_CCR) | (scp->sc_tstate & TSTATE_CCR);
	tf->tf_pc = (u_int64_t)scp->sc_pc;
	tf->tf_npc = (u_int64_t)scp->sc_npc;
	tf->tf_global[1] = (u_int64_t)scp->sc_g1;
	tf->tf_out[0] = (u_int64_t)scp->sc_o0;
	tf->tf_out[6] = (u_int64_t)scp->sc_sp;

	/* Restore signal mask. */
	p->p_sigmask = scp->sc_mask & ~sigcantmask;

	return (EJUSTRETURN);
}

/*
 * Notify the current process (p) that it has a signal pending,
 * process as soon as possible.
 */
void
signotify(struct proc *p)
{
	aston(p);
	cpu_unidle(p->p_cpu);
}

int	waittime = -1;
struct pcb dumppcb;

__dead void
boot(int howto)
{
	int i;
	static char str[128];

	if (cold) {
		if ((howto & RB_USERREQ) == 0)
			howto |= RB_HALT;
		goto haltsys;
	}

	fb_unblank();
	boothowto = howto;
	if ((howto & RB_NOSYNC) == 0 && waittime < 0) {
		extern int sparc_clock_time_is_ok;

		waittime = 0;
		vfs_shutdown();

		/*
		 * XXX
		 * Do this only if the TOD clock has already been read out
		 * successfully by inittodr() or set by an explicit call
		 * to resettodr() (e.g. from settimeofday()).
		 */
		if ((howto & RB_TIMEBAD) == 0 && sparc_clock_time_is_ok) {
			resettodr();
		} else {
			printf("WARNING: not updating battery clock\n");
		}
	}
	if_downall();

	uvm_shutdown();
	splhigh();
	cold = 1;

	if ((howto & RB_DUMP) != 0)
		dumpsys();

haltsys:
	config_suspend_all(DVACT_POWERDOWN);

	/* If powerdown was requested, do it. */
	if ((howto & RB_POWERDOWN) != 0) {
		/* Let the OBP do the work. */
		OF_poweroff();
		printf("WARNING: powerdown failed!\n");
		/*
		 * RB_POWERDOWN implies RB_HALT... fall into it...
		 */
	}

	if ((howto & RB_HALT) != 0) {
		printf("halted\n\n");
		OF_exit();
		panic("PROM exit failed");
	}

	printf("rebooting\n\n");
#if 0
	if (user_boot_string && *user_boot_string) {
		i = strlen(user_boot_string);
		if (i > sizeof(str))
			OF_boot(user_boot_string);	/* XXX */
		bcopy(user_boot_string, str, i);
	} else
#endif
	{
		i = 1;
		str[0] = '\0';
	}

	if ((howto & RB_SINGLE) != 0)
		str[i++] = 's';
	if ((howto & RB_KDB) != 0)
		str[i++] = 'd';
	if (i > 1) {
		if (str[0] == '\0')
			str[0] = '-';
		str[i] = 0;
	} else
		str[0] = 0;
	OF_boot(str);
	panic("cpu_reboot -- failed");
	for (;;)
		continue;
	/* NOTREACHED */
}

u_long	dumpmag = 0x8fca0101;	/* magic number for savecore */
int	dumpsize = 0;		/* also for savecore */
long	dumplo = 0;

void
dumpconf(void)
{
	int nblks, dumpblks;

	if (dumpdev == NODEV ||
	    (nblks = (bdevsw[major(dumpdev)].d_psize)(dumpdev)) == 0)
		return;
	if (nblks <= ctod(1))
		return;

	dumpblks = ctod(physmem) + pmap_dumpsize();
	if (dumpblks > (nblks - ctod(1)))
		/*
		 * dump size is too big for the partition.
		 * Note, we safeguard a click at the front for a
		 * possible disk label.
		 */
		return;

	/* Put the dump at the end of the partition */
	dumplo = nblks - dumpblks;

	/*
	 * savecore(8) expects dumpsize to be the number of pages
	 * of actual core dumped (i.e. excluding the MMU stuff).
	 */
	dumpsize = physmem;
}

#define	BYTES_PER_DUMP	(NBPG)	/* must be a multiple of pagesize */
static vaddr_t dumpspace;

caddr_t
reserve_dumppages(p)
	caddr_t p;
{

	dumpspace = (vaddr_t)p;
	return (p + BYTES_PER_DUMP);
}

/*
 * Write a crash dump.
 */
void
dumpsys(void)
{
	int psize;
	daddr_t blkno;
	int (*dump)(dev_t, daddr_t, caddr_t, size_t);
	int error = 0;
	struct mem_region *mp;
	extern struct mem_region *mem;

	/* copy registers to memory */
	snapshot(&dumppcb);
	stackdump();

	if (dumpdev == NODEV)
		return;

	/*
	 * For dumps during autoconfiguration,
	 * if dump device has already configured...
	 */
	if (dumpsize == 0)
		dumpconf();
	if (!dumpspace) {
		printf("\nno address space available, dump not possible\n");
		return;
	}
	if (dumplo <= 0) {
		printf("\ndump to dev %u,%u not possible\n", major(dumpdev),
		    minor(dumpdev));
		return;
	}
	printf("\ndumping to dev %u,%u offset %ld\n", major(dumpdev),
	    minor(dumpdev), dumplo);

	psize = (*bdevsw[major(dumpdev)].d_psize)(dumpdev);
	printf("dump ");
	if (psize == -1) {
		printf("area unavailable\n");
		return;
	}
	blkno = dumplo;
	dump = bdevsw[major(dumpdev)].d_dump;

	error = pmap_dumpmmu(dump, blkno);
	blkno += pmap_dumpsize();
printf("starting dump, blkno %lld\n", (long long)blkno);
	for (mp = mem; mp->size; mp++) {
		u_int64_t i = 0, n;
		paddr_t maddr = mp->start;

#if 0
		/* Remind me: why don't we dump page 0 ? */
		if (maddr == 0) {
			/* Skip first page at physical address 0 */
			maddr += NBPG;
			i += NBPG;
			blkno += btodb(NBPG);
		}
#endif
		for (; i < mp->size; i += n) {
			n = mp->size - i;
			if (n > BYTES_PER_DUMP)
				n = BYTES_PER_DUMP;

			/* print out how many MBs we have dumped */
			if (i && (i % (1024*1024)) == 0)
				printf("%lld ", i / (1024*1024));
			(void) pmap_enter(pmap_kernel(), dumpspace, maddr,
			    PROT_READ, PROT_READ | PMAP_WIRED);
			pmap_update(pmap_kernel());
			error = (*dump)(dumpdev, blkno,
					(caddr_t)dumpspace, (int)n);
			pmap_remove(pmap_kernel(), dumpspace, dumpspace + n);
			pmap_update(pmap_kernel());
			if (error)
				break;
			maddr += n;
			blkno += btodb(n);
		}
	}

	switch (error) {

	case ENXIO:
		printf("device bad\n");
		break;

	case EFAULT:
		printf("device not ready\n");
		break;

	case EINVAL:
		printf("area improper\n");
		break;

	case EIO:
		printf("i/o error\n");
		break;

	case 0:
		printf("succeeded\n");
		break;

	default:
		printf("error %d\n", error);
		break;
	}
}

void trapdump(struct trapframe64*);
/*
 * dump out a trapframe.
 */
void
trapdump(tf)
	struct trapframe64* tf;
{
	printf("TRAPFRAME: tstate=%llx pc=%llx npc=%llx y=%x\n",
	       (unsigned long long)tf->tf_tstate, (unsigned long long)tf->tf_pc,
	       (unsigned long long)tf->tf_npc, (unsigned)tf->tf_y);
	printf("%%g1-7: %llx %llx %llx %llx %llx %llx %llx\n",
	       (unsigned long long)tf->tf_global[1],
	       (unsigned long long)tf->tf_global[2],
	       (unsigned long long)tf->tf_global[3], 
	       (unsigned long long)tf->tf_global[4],
	       (unsigned long long)tf->tf_global[5],
	       (unsigned long long)tf->tf_global[6], 
	       (unsigned long long)tf->tf_global[7]);
	printf("%%o0-7: %llx %llx %llx %llx\n %llx %llx %llx %llx\n",
	       (unsigned long long)tf->tf_out[0],
	       (unsigned long long)tf->tf_out[1],
	       (unsigned long long)tf->tf_out[2],
	       (unsigned long long)tf->tf_out[3], 
	       (unsigned long long)tf->tf_out[4],
	       (unsigned long long)tf->tf_out[5],
	       (unsigned long long)tf->tf_out[6],
	       (unsigned long long)tf->tf_out[7]);
}
/*
 * get the fp and dump the stack as best we can.  don't leave the
 * current stack page
 */
void
stackdump(void)
{
	struct frame32 *fp = (struct frame32 *)getfp(), *sfp;
	struct frame64 *fp64;

	sfp = fp;
	printf("Frame pointer is at %p\n", fp);
	printf("Call traceback:\n");
	while (fp && ((u_long)fp >> PGSHIFT) == ((u_long)sfp >> PGSHIFT)) {
		if( ((long)fp) & 1 ) {
			fp64 = (struct frame64*)(((char *)fp)+BIAS);
			/* 64-bit frame */
			printf("%llx(%llx, %llx, %llx, %llx, %llx, %llx, %llx) "
			    "fp = %llx\n",
			       (unsigned long long)fp64->fr_pc,
			       (unsigned long long)fp64->fr_arg[0],
			       (unsigned long long)fp64->fr_arg[1],
			       (unsigned long long)fp64->fr_arg[2],
			       (unsigned long long)fp64->fr_arg[3],
			       (unsigned long long)fp64->fr_arg[4],
			       (unsigned long long)fp64->fr_arg[5],	
			       (unsigned long long)fp64->fr_arg[6],
			       (unsigned long long)fp64->fr_fp);
			fp = (struct frame32 *)(u_long)fp64->fr_fp;
		} else {
			/* 32-bit frame */
			printf("  pc = %x  args = (%x, %x, %x, %x, %x, %x) "
			    "fp = %x\n", fp->fr_pc, fp->fr_arg[0],
			    fp->fr_arg[1], fp->fr_arg[2], fp->fr_arg[3],
			    fp->fr_arg[4], fp->fr_arg[5], fp->fr_fp);
			fp = (struct frame32*)(u_long)(u_short)fp->fr_fp;
		}
	}
}


/*
 * Common function for DMA map creation.  May be called by bus-specific
 * DMA map creation functions.
 */
int
_bus_dmamap_create(t, t0, size, nsegments, maxsegsz, boundary, flags, dmamp)
	bus_dma_tag_t t, t0;
	bus_size_t size;
	int nsegments;
	bus_size_t maxsegsz;
	bus_size_t boundary;
	int flags;
	bus_dmamap_t *dmamp;
{
	struct sparc_bus_dmamap *map;
	void *mapstore;
	size_t mapsize;

	/*
	 * Allocate and initialize the DMA map.  The end of the map
	 * is a variable-sized array of segments, so we allocate enough
	 * room for them in one shot.
	 *
	 * Note we don't preserve the WAITOK or NOWAIT flags.  Preservation
	 * of ALLOCNOW notifies others that we've reserved these resources,
	 * and they are not to be freed.
	 *
	 * The bus_dmamap_t includes one bus_dma_segment_t, hence
	 * the (nsegments - 1).
	 */
	mapsize = sizeof(struct sparc_bus_dmamap) +
	    (sizeof(bus_dma_segment_t) * (nsegments - 1));
	if ((mapstore = malloc(mapsize, M_DEVBUF, (flags & BUS_DMA_NOWAIT) ?
	    (M_NOWAIT | M_ZERO) : (M_WAITOK | M_ZERO))) == NULL)
		return (ENOMEM);

	map = (struct sparc_bus_dmamap *)mapstore;
	map->_dm_size = size;
	map->_dm_segcnt = nsegments;
	map->_dm_maxsegsz = maxsegsz;
	map->_dm_boundary = boundary;
	map->_dm_flags = flags & ~(BUS_DMA_WAITOK | BUS_DMA_NOWAIT |
	    BUS_DMA_COHERENT | BUS_DMA_NOWRITE | BUS_DMA_NOCACHE);
	map->dm_mapsize = 0;		/* no valid mappings */
	map->dm_nsegs = 0;

	*dmamp = map;
	return (0);
}

/*
 * Common function for DMA map destruction.  May be called by bus-specific
 * DMA map destruction functions.
 */
void
_bus_dmamap_destroy(t, t0, map)
	bus_dma_tag_t t, t0;
	bus_dmamap_t map;

{
	/*
	 * Unload the map if it is still loaded.  This is required
	 * by the specification (well, the manpage).  Higher level
	 * drivers, if any, should do this too.  By the time the
	 * system gets here, the higher level "destroy" functions
	 * would probably already have clobbered the data needed
	 * to do a proper unload.
	 */
	if (map->dm_nsegs)
		bus_dmamap_unload(t0, map);

	free(map, M_DEVBUF, 0);
}

/*
 * Common function for loading a DMA map with a linear buffer.  May
 * be called by bus-specific DMA map load functions.
 *
 * Most SPARCs have IOMMUs in the bus controllers.  In those cases
 * they only need one segment and will use virtual addresses for DVMA.
 * Those bus controllers should intercept these vectors and should
 * *NEVER* call _bus_dmamap_load() which is used only by devices that
 * bypass DVMA.
 */
int
_bus_dmamap_load(t, t0, map, buf, buflen, p, flags)
	bus_dma_tag_t t, t0;
	bus_dmamap_t map;
	void *buf;
	bus_size_t buflen;
	struct proc *p;
	int flags;
{
	bus_addr_t lastaddr;
	int seg, error;

	/*
	 * Make sure that on error condition we return "no valid mappings".
	 */
	map->dm_mapsize = 0;
	map->dm_nsegs = 0;

	if (buflen > map->_dm_size)
		return (EINVAL);

	seg = 0;
	error = _bus_dmamap_load_buffer(t, map, buf, buflen, p, flags,
	    &lastaddr, &seg, 1);
	if (error == 0) {
		map->dm_mapsize = buflen;
		map->dm_nsegs = seg + 1;
	}
	return (error);
}

/*
 * Like _bus_dmamap_load(), but for mbufs.
 */
int
_bus_dmamap_load_mbuf(t, t0, map, m, flags)
	bus_dma_tag_t t, t0;
	bus_dmamap_t map;
	struct mbuf *m;
	int flags;
{
	bus_dma_segment_t segs[MAX_DMA_SEGS];
	int i;
	size_t len;

	/*
	 * Make sure that on error condition we return "no valid mappings".
	 */
 	map->dm_mapsize = 0;
 	map->dm_nsegs = 0;

	if (m->m_pkthdr.len > map->_dm_size)
		return (EINVAL);

	/* Record mbuf for *_unload */
	map->_dm_type = _DM_TYPE_MBUF;
	map->_dm_source = m;

	i = 0;
	len = 0;
	while (m) {
		vaddr_t vaddr = mtod(m, vaddr_t);
		long buflen = (long)m->m_len;

		len += buflen;
		while (buflen > 0 && i < MAX_DMA_SEGS) {
			paddr_t pa;
			long incr;

			incr = min(buflen, NBPG);

			if (pmap_extract(pmap_kernel(), vaddr, &pa) == FALSE) {
#ifdef DIAGNOSTIC
				printf("_bus_dmamap_load_mbuf: pmap_extract failed %lx\n",
					vaddr);
				map->_dm_type = 0;
				map->_dm_source = NULL;
#endif
				return EINVAL;
			}

			buflen -= incr;
			vaddr += incr;

			if (i > 0 && pa == (segs[i - 1].ds_addr +
			    segs[i - 1].ds_len) && ((segs[i - 1].ds_len + incr)
			    < map->_dm_maxsegsz)) {
				/* Hey, waddyaknow, they're contiguous */
				segs[i - 1].ds_len += incr;
				continue;
			}
			segs[i].ds_addr = pa;
			segs[i].ds_len = incr;
			segs[i]._ds_boundary = 0;
			segs[i]._ds_align = 0;
			segs[i]._ds_mlist = NULL;
			i++;
		}
		m = m->m_next;
		if (m && i >= MAX_DMA_SEGS) {
			/* Exceeded the size of our dmamap */
			map->_dm_type = 0;
			map->_dm_source = NULL;
			return (EFBIG);
		}
	}

	return (bus_dmamap_load_raw(t0, map, segs, i,
			    (bus_size_t)len, flags));
}

/*
 * Like _bus_dmamap_load(), but for uios.
 */
int
_bus_dmamap_load_uio(t, t0, map, uio, flags)
	bus_dma_tag_t t, t0;
	bus_dmamap_t map;
	struct uio *uio;
	int flags;
{
	/*
	 * XXXXXXX The problem with this routine is that it needs to 
	 * lock the user address space that is being loaded, but there
	 * is no real way for us to unlock it during the unload process.
	 * As a result, only UIO_SYSSPACE uio's are allowed for now.
	 */
	bus_dma_segment_t segs[MAX_DMA_SEGS];
	int i, j;
	size_t len;

	/*
	 * Make sure that on error condition we return "no valid mappings".
	 */
 	map->dm_mapsize = 0;
 	map->dm_nsegs = 0;

	if (uio->uio_resid > map->_dm_size)
		return (EINVAL);

	if (uio->uio_segflg != UIO_SYSSPACE)
		return (EOPNOTSUPP);

	/* Record for *_unload */
	map->_dm_type = _DM_TYPE_UIO;
	map->_dm_source = (void *)uio;

	i = j = 0;
	len = 0;
	while (j < uio->uio_iovcnt) {
		vaddr_t vaddr = (vaddr_t)uio->uio_iov[j].iov_base;
		long buflen = (long)uio->uio_iov[j].iov_len;

		len += buflen;
		while (buflen > 0 && i < MAX_DMA_SEGS) {
			paddr_t pa;
			long incr;

			incr = min(buflen, NBPG);
			(void) pmap_extract(pmap_kernel(), vaddr, &pa);
			buflen -= incr;
			vaddr += incr;

			if (i > 0 && pa == (segs[i - 1].ds_addr +
			    segs[i - 1].ds_len) && ((segs[i - 1].ds_len + incr)
			    < map->_dm_maxsegsz)) {
				/* Hey, waddyaknow, they're contiguous */
				segs[i - 1].ds_len += incr;
				continue;
			}
			segs[i].ds_addr = pa;
			segs[i].ds_len = incr;
			segs[i]._ds_boundary = 0;
			segs[i]._ds_align = 0;
			segs[i]._ds_mlist = NULL;
			i++;
		}
		j++;
		if ((uio->uio_iovcnt - j) && i >= MAX_DMA_SEGS) {
			/* Exceeded the size of our dmamap */
			map->_dm_type = 0;
			map->_dm_source = NULL;
			return (EFBIG);
		}
	}

	return (bus_dmamap_load_raw(t0, map, segs, i, (bus_size_t)len, flags));
}

/*
 * Like _bus_dmamap_load(), but for raw memory allocated with
 * bus_dmamem_alloc().
 */
int
_bus_dmamap_load_raw(t, t0, map, segs, nsegs, size, flags)
	bus_dma_tag_t t, t0;
	bus_dmamap_t map;
	bus_dma_segment_t *segs;
	int nsegs;
	bus_size_t size;
	int flags;
{

	panic("_bus_dmamap_load_raw: not implemented");
}

int
_bus_dmamap_load_buffer(bus_dma_tag_t t, bus_dmamap_t map, void *buf,
    bus_size_t buflen, struct proc *p, int flags, bus_addr_t *lastaddrp,
    int *segp, int first)
{
	bus_size_t sgsize;
	bus_addr_t curaddr, lastaddr, baddr, bmask;
	vaddr_t vaddr = (vaddr_t)buf;
	int seg;
	pmap_t pmap;

	if (p != NULL)
		pmap = p->p_vmspace->vm_map.pmap;
	else
		pmap = pmap_kernel();

	lastaddr = *lastaddrp;
	bmask  = ~(map->_dm_boundary - 1);

	for (seg = *segp; buflen > 0 ; ) {
		/*
		 * Get the physical address for this segment.
		 */
		pmap_extract(pmap, vaddr, (paddr_t *)&curaddr);

		/*
		 * Compute the segment size, and adjust counts.
		 */
		sgsize = PAGE_SIZE - ((u_long)vaddr & PGOFSET);
		if (buflen < sgsize)
			sgsize = buflen;

		/*
		 * Make sure we don't cross any boundaries.
		 */
		if (map->_dm_boundary > 0) {
			baddr = (curaddr + map->_dm_boundary) & bmask;
			if (sgsize > (baddr - curaddr))
				sgsize = (baddr - curaddr);
		}

		/*
		 * Insert chunk into a segment, coalescing with
		 * previous segment if possible.
		 */
		if (first) {
			map->dm_segs[seg].ds_addr = curaddr;
			map->dm_segs[seg].ds_len = sgsize;
			first = 0;
		} else {
			if (curaddr == lastaddr &&
			    (map->dm_segs[seg].ds_len + sgsize) <=
			     map->_dm_maxsegsz &&
			    (map->_dm_boundary == 0 ||
			     (map->dm_segs[seg].ds_addr & bmask) ==
			     (curaddr & bmask)))
				map->dm_segs[seg].ds_len += sgsize;
			else {
				if (++seg >= map->_dm_segcnt)
					break;
				map->dm_segs[seg].ds_addr = curaddr;
				map->dm_segs[seg].ds_len = sgsize;
			}
		}

		lastaddr = curaddr + sgsize;
		vaddr += sgsize;
		buflen -= sgsize;
	}

	*segp = seg;
	*lastaddrp = lastaddr;

	/*
	 * Did we fit?
	 */
	if (buflen != 0)
		return (EFBIG);		/* XXX better return value here? */
	return (0);
}

/*
 * Common function for unloading a DMA map.  May be called by
 * bus-specific DMA map unload functions.
 */
void
_bus_dmamap_unload(t, t0, map)
	bus_dma_tag_t t, t0;
	bus_dmamap_t map;
{
	/* Mark the mappings as invalid. */
	map->dm_mapsize = 0;
	map->dm_nsegs = 0;

}

/*
 * Common function for DMA map synchronization.  May be called
 * by bus-specific DMA map synchronization functions.
 */
void
_bus_dmamap_sync(t, t0, map, offset, len, ops)
	bus_dma_tag_t t, t0;
	bus_dmamap_t map;
	bus_addr_t offset;
	bus_size_t len;
	int ops;
{
	if (ops & (BUS_DMASYNC_PREWRITE | BUS_DMASYNC_POSTREAD))
		__membar("#MemIssue");
}

/*
 * Common function for DMA-safe memory allocation.  May be called
 * by bus-specific DMA memory allocation functions.
 */
int
_bus_dmamem_alloc(t, t0, size, alignment, boundary, segs, nsegs, rsegs, flags)
	bus_dma_tag_t t, t0;
	bus_size_t size, alignment, boundary;
	bus_dma_segment_t *segs;
	int nsegs;
	int *rsegs;
	int flags;
{
	struct pglist *mlist;
	int error, plaflag;

	/* Always round the size. */
	size = round_page(size);

	if ((mlist = malloc(sizeof(*mlist), M_DEVBUF,
	    (flags & BUS_DMA_NOWAIT) ? M_NOWAIT : M_WAITOK)) == NULL)
		return (ENOMEM);

	/*
	 * If the bus uses DVMA then ignore boundary and alignment.
	 */
	segs[0]._ds_boundary = boundary;
	segs[0]._ds_align = alignment;
	if (flags & BUS_DMA_DVMA) {
		boundary = 0;
		alignment = 0;
	}

	/*
	 * Allocate pages from the VM system.
	 */
	plaflag = flags & BUS_DMA_NOWAIT ? UVM_PLA_NOWAIT : UVM_PLA_WAITOK;
	if (flags & BUS_DMA_ZERO)
		plaflag |= UVM_PLA_ZERO;

	TAILQ_INIT(mlist);
	error = uvm_pglistalloc(size, (paddr_t)0, (paddr_t)-1,
	    alignment, boundary, mlist, nsegs, plaflag);
	if (error)
		return (error);

	/*
	 * Compute the location, size, and number of segments actually
	 * returned by the VM code.
	 */
	segs[0].ds_addr = 0UL; /* UPA does not map things */
	segs[0].ds_len = size;
	*rsegs = 1;

	/*
	 * Simply keep a pointer around to the linked list, so
	 * bus_dmamap_free() can return it.
	 *
	 * NOBODY SHOULD TOUCH THE pageq FIELDS WHILE THESE PAGES
	 * ARE IN OUR CUSTODY.
	 */
	segs[0]._ds_mlist = mlist;

	/* The bus driver should do the actual mapping */
	return (0);
}

/*
 * Common function for freeing DMA-safe memory.  May be called by
 * bus-specific DMA memory free functions.
 */
void
_bus_dmamem_free(t, t0, segs, nsegs)
	bus_dma_tag_t t, t0;
	bus_dma_segment_t *segs;
	int nsegs;
{

#ifdef DIAGNOSTIC
	if (nsegs != 1)
		panic("bus_dmamem_free: nsegs = %d", nsegs);
#endif

	/*
	 * Return the list of pages back to the VM system.
	 */
	uvm_pglistfree(segs[0]._ds_mlist);
	free(segs[0]._ds_mlist, M_DEVBUF, 0);
}

/*
 * Common function for mapping DMA-safe memory.  May be called by
 * bus-specific DMA memory map functions.
 */
int
_bus_dmamem_map(t, t0, segs, nsegs, size, kvap, flags)
	bus_dma_tag_t t, t0;
	bus_dma_segment_t *segs;
	int nsegs;
	size_t size;
	caddr_t *kvap;
	int flags;
{
	const struct kmem_dyn_mode *kd;
	struct vm_page *m;
	vaddr_t va, sva;
	size_t ssize;
	bus_addr_t addr, cbit;
	struct pglist *mlist;
	int error;

#ifdef DIAGNOSTIC
	if (nsegs != 1)
		panic("_bus_dmamem_map: nsegs = %d", nsegs);
#endif

	size = round_page(size);
	kd = flags & BUS_DMA_NOWAIT ? &kd_trylock : &kd_waitok;
	va = (vaddr_t)km_alloc(size, &kv_any, &kp_none, kd);
	if (va == 0)
		return (ENOMEM);

	*kvap = (caddr_t)va;

	cbit = 0;
	if (flags & BUS_DMA_NOCACHE)
		cbit |= PMAP_NC;

	sva = va;
	ssize = size;
	mlist = segs[0]._ds_mlist;
	TAILQ_FOREACH(m, mlist, pageq) {
#ifdef DIAGNOSTIC
		if (size == 0)
			panic("_bus_dmamem_map: size botch");
#endif
		addr = VM_PAGE_TO_PHYS(m);
		error = pmap_enter(pmap_kernel(), va, addr | cbit,
		    PROT_READ | PROT_WRITE,
		    PROT_READ | PROT_WRITE | PMAP_WIRED | PMAP_CANFAIL);
		if (error) {
			pmap_update(pmap_kernel());
			km_free((void *)sva, ssize, &kv_any, &kp_none);
			return (error);
		}
		va += PAGE_SIZE;
		size -= PAGE_SIZE;
	}
	pmap_update(pmap_kernel());

	return (0);
}

/*
 * Common function for unmapping DMA-safe memory.  May be called by
 * bus-specific DMA memory unmapping functions.
 */
void
_bus_dmamem_unmap(t, t0, kva, size)
	bus_dma_tag_t t, t0;
	caddr_t kva;
	size_t size;
{

#ifdef DIAGNOSTIC
	if ((u_long)kva & PAGE_MASK)
		panic("_bus_dmamem_unmap");
#endif

	km_free(kva, round_page(size), &kv_any, &kp_none);
}

/*
 * Common function for mmap(2)'ing DMA-safe memory.  May be called by
 * bus-specific DMA mmap(2)'ing functions.
 */
paddr_t
_bus_dmamem_mmap(t, t0, segs, nsegs, off, prot, flags)
	bus_dma_tag_t t, t0;
	bus_dma_segment_t *segs;
	int nsegs;
	off_t off;
	int prot, flags;
{
	int i;

	for (i = 0; i < nsegs; i++) {
#ifdef DIAGNOSTIC
		if (off & PGOFSET)
			panic("_bus_dmamem_mmap: offset unaligned");
		if (segs[i].ds_addr & PGOFSET)
			panic("_bus_dmamem_mmap: segment unaligned");
		if (segs[i].ds_len & PGOFSET)
			panic("_bus_dmamem_mmap: segment size not multiple"
					" of page size");
#endif
		if (off >= segs[i].ds_len) {
			off -= segs[i].ds_len;
			continue;
		}

		return (segs[i].ds_addr + off);
	}

	/* Page not found. */
	return (-1);
}

struct sparc_bus_dma_tag mainbus_dma_tag = {
	NULL,
	NULL,
	_bus_dmamap_create,
	_bus_dmamap_destroy,
	_bus_dmamap_load,
	_bus_dmamap_load_mbuf,
	_bus_dmamap_load_uio,
	_bus_dmamap_load_raw,
	_bus_dmamap_unload,
	_bus_dmamap_sync,

	_bus_dmamem_alloc,
	_bus_dmamem_free,
	_bus_dmamem_map,
	_bus_dmamem_unmap,
	_bus_dmamem_mmap
};


/*
 * Base bus space handlers.
 */
int sparc_bus_map(bus_space_tag_t, bus_space_tag_t, bus_addr_t, bus_size_t,
    int, bus_space_handle_t *);
int sparc_bus_protect(bus_space_tag_t, bus_space_tag_t, bus_space_handle_t,
    bus_size_t, int);
int sparc_bus_unmap(bus_space_tag_t, bus_space_tag_t, bus_space_handle_t,
    bus_size_t);
bus_addr_t sparc_bus_addr(bus_space_tag_t, bus_space_tag_t,
    bus_space_handle_t);
int sparc_bus_subregion(bus_space_tag_t, bus_space_tag_t,  bus_space_handle_t,
    bus_size_t, bus_size_t, bus_space_handle_t *);
paddr_t sparc_bus_mmap(bus_space_tag_t, bus_space_tag_t, bus_addr_t, off_t,
    int, int);
void *sparc_mainbus_intr_establish(bus_space_tag_t, bus_space_tag_t, int, int,
    int, int (*)(void *), void *, const char *);
int sparc_bus_alloc(bus_space_tag_t, bus_space_tag_t, bus_addr_t, bus_addr_t,
    bus_size_t, bus_size_t, bus_size_t, int, bus_addr_t *,
    bus_space_handle_t *);
void sparc_bus_free(bus_space_tag_t, bus_space_tag_t, bus_space_handle_t,
    bus_size_t);

int
sparc_bus_map(bus_space_tag_t t, bus_space_tag_t t0, bus_addr_t	addr,
    bus_size_t size, int flags, bus_space_handle_t *hp)
{
	vaddr_t va;
	u_int64_t pa;
	paddr_t	pm_flags = 0;
	vm_prot_t pm_prot = PROT_READ;

	if (flags & BUS_SPACE_MAP_PROMADDRESS) {
		hp->bh_ptr = addr;
		return (0);
	}

	if (size == 0) {
		char buf[80];
		bus_space_render_tag(t0, buf, sizeof buf);
		printf("\nsparc_bus_map: zero size on %s", buf);
		return (EINVAL);
	}

	if ( (LITTLE_ASI(t0->asi) && LITTLE_ASI(t0->sasi)) ||
	    (PHYS_ASI(t0->asi) != PHYS_ASI(t0->sasi)) ) {
		char buf[80];
		bus_space_render_tag(t0, buf, sizeof buf);
		printf("\nsparc_bus_map: mismatched ASIs on %s: asi=%x sasi=%x",
		    buf, t0->asi, t0->sasi);
	}

	if (PHYS_ASI(t0->asi)) {
#ifdef BUS_SPACE_DEBUG
		char buf[80];
		bus_space_render_tag(t0, buf, sizeof buf);
		BUS_SPACE_PRINTF(BSDB_MAP,
		    ("\nsparc_bus_map: physical tag %s asi %x sasi %x flags %x "
		    "paddr %016llx size %016llx",
		    buf,
		    (int)t0->asi, (int)t0->sasi, (int)flags,
		    (unsigned long long)addr, (unsigned long long)size));
#endif /* BUS_SPACE_DEBUG */
		if (flags & BUS_SPACE_MAP_LINEAR) {
			char buf[80];
			bus_space_render_tag(t0, buf, sizeof buf);
			printf("\nsparc_bus_map: linear mapping requested on physical bus %s", buf);
			return (EINVAL);
		}

		hp->bh_ptr = addr;
		return (0);
	}

	size = round_page(size);

	if (LITTLE_ASI(t0->sasi) && !LITTLE_ASI(t0->asi))
		pm_flags |= PMAP_LITTLE;

	if ((flags & BUS_SPACE_MAP_CACHEABLE) == 0)
		pm_flags |= PMAP_NC;

	va = (vaddr_t)km_alloc(size, &kv_any, &kp_none, &kd_nowait);
	if (va == 0)
		return (ENOMEM);

	/* note: preserve page offset */
	hp->bh_ptr = va | (addr & PGOFSET);

	pa = trunc_page(addr);
	if ((flags & BUS_SPACE_MAP_READONLY) == 0)
		pm_prot |= PROT_WRITE;

#ifdef BUS_SPACE_DEBUG
	{ /* scope */
		char buf[80];
		bus_space_render_tag(t0, buf, sizeof buf);
		BUS_SPACE_PRINTF(BSDB_MAP, ("\nsparc_bus_map: tag %s type %x "
		    "flags %x addr %016llx size %016llx virt %llx paddr "
		    "%016llx", buf, (int)t->default_type, (int) flags,
		    (unsigned long long)addr, (unsigned long long)size,
		    (unsigned long long)hp->bh_ptr, (unsigned long long)pa));
	}
#endif /* BUS_SPACE_DEBUG */

	do {
		BUS_SPACE_PRINTF(BSDB_MAPDETAIL, ("\nsparc_bus_map: phys %llx "
		    "virt %p hp->bh_ptr %llx", (unsigned long long)pa,
		    (char *)v, (unsigned long long)hp->bh_ptr));
		pmap_enter(pmap_kernel(), va, pa | pm_flags, pm_prot,
			pm_prot|PMAP_WIRED);
		va += PAGE_SIZE;
		pa += PAGE_SIZE;
	} while ((size -= PAGE_SIZE) > 0);
	pmap_update(pmap_kernel());
	return (0);
}

int
sparc_bus_subregion(bus_space_tag_t tag, bus_space_tag_t tag0,
    bus_space_handle_t handle, bus_size_t offset, bus_size_t size,
    bus_space_handle_t *nhandlep)
{
	*nhandlep = handle;
	nhandlep->bh_ptr += offset;
	return (0);
}

/* stolen from uvm_chgkprot() */
/*
 * Change protections on kernel pages from addr to addr+len
 * (presumably so debugger can plant a breakpoint).
 *
 * We force the protection change at the pmap level.  If we were
 * to use vm_map_protect a change to allow writing would be lazily-
 * applied meaning we would still take a protection fault, something
 * we really don't want to do.  It would also fragment the kernel
 * map unnecessarily.  We cannot use pmap_protect since it also won't
 * enforce a write-enable request.  Using pmap_enter is the only way
 * we can ensure the change takes place properly.
 */
int
sparc_bus_protect(bus_space_tag_t t, bus_space_tag_t t0, bus_space_handle_t h,
    bus_size_t size, int flags)
{
        vm_prot_t prot;
	paddr_t	pm_flags = 0;
        paddr_t pa;
        vaddr_t sva, eva;
	void* addr = bus_space_vaddr(t0, h);

	if (addr == 0) {
		printf("\nsparc_bus_protect: null address");
		return (EINVAL);
	}

	if (PHYS_ASI(t0->asi)) {
		printf("\nsparc_bus_protect: physical ASI");
		return (EINVAL);
	}

        prot = (flags & BUS_SPACE_MAP_READONLY) ?
	    PROT_READ : PROT_READ | PROT_WRITE;
	if ((flags & BUS_SPACE_MAP_CACHEABLE) == 0)
	    pm_flags |= PMAP_NC;

        eva = round_page((vaddr_t)addr + size);
        for (sva = trunc_page((vaddr_t)addr); sva < eva; sva += PAGE_SIZE) {
                /*
                 * Extract physical address for the page.
                 * We use a cheezy hack to differentiate physical
                 * page 0 from an invalid mapping, not that it
                 * really matters...
                 */
                if (pmap_extract(pmap_kernel(), sva, &pa) == FALSE)
                        panic("bus_space_protect(): invalid page");
                pmap_enter(pmap_kernel(), sva, pa | pm_flags, prot, prot | PMAP_WIRED);
        }
	pmap_update(pmap_kernel());

	return (0);
}

int
sparc_bus_unmap(bus_space_tag_t t, bus_space_tag_t t0, bus_space_handle_t bh,
    bus_size_t size)
{
	vaddr_t va = trunc_page((vaddr_t)bh.bh_ptr);
	vaddr_t endva = va + round_page(size);

	if (PHYS_ASI(t0->asi))
		return (0);

	pmap_remove(pmap_kernel(), va, endva);
	pmap_update(pmap_kernel());
	km_free((void *)va, endva - va, &kv_any, &kp_none);

	return (0);
}

paddr_t
sparc_bus_mmap(bus_space_tag_t t, bus_space_tag_t t0, bus_addr_t paddr,
    off_t off, int prot, int flags)
{
	if (PHYS_ASI(t0->asi)) {
		printf("\nsparc_bus_mmap: physical ASI");
		return (0);
	}

	/* Devices are un-cached... although the driver should do that */
	return ((paddr + off) | PMAP_NC);
}

bus_addr_t
sparc_bus_addr(bus_space_tag_t t, bus_space_tag_t t0, bus_space_handle_t h)
{
	paddr_t addr;

	if (PHYS_ASI(t0->asi))
		return h.bh_ptr;

	if (!pmap_extract(pmap_kernel(), h.bh_ptr, &addr))
		return (-1);
	return addr;
}

void *
bus_intr_allocate(bus_space_tag_t t, int (*handler)(void *), void *arg,
    int number, int pil,
    volatile u_int64_t *mapper, volatile u_int64_t *clearer,
    const char *what)
{
	struct intrhand *ih;

	ih = malloc(sizeof(*ih), M_DEVBUF, M_NOWAIT | M_ZERO);
	if (ih == NULL)
		return (NULL);

	ih->ih_fun = handler;
	ih->ih_arg = arg;
	ih->ih_number = number;
	ih->ih_pil = pil;
	ih->ih_map = mapper;
	ih->ih_clr = clearer;
	ih->ih_bus = t;
	strlcpy(ih->ih_name, what, sizeof(ih->ih_name));

	return (ih);
}

void
bus_intr_free(void *arg)
{
	free(arg, M_DEVBUF, 0);
}

void *
sparc_mainbus_intr_establish(bus_space_tag_t t, bus_space_tag_t t0, int number,
    int pil, int flags, int (*handler)(void *), void *arg, const char *what)
{
	struct intrhand *ih;

	ih = bus_intr_allocate(t0, handler, arg, number, pil, NULL, NULL, what);
	if (ih == NULL)
		return (NULL);

	intr_establish(ih->ih_pil, ih);

	return (ih);
}

int
sparc_bus_alloc(bus_space_tag_t t, bus_space_tag_t t0, bus_addr_t rs,
    bus_addr_t re, bus_size_t s, bus_size_t a, bus_size_t b, int f,
    bus_addr_t *ap, bus_space_handle_t *hp)
{
	return (ENOTTY);
}

void
sparc_bus_free(bus_space_tag_t t, bus_space_tag_t t0, bus_space_handle_t h,
    bus_size_t s)
{
	return;
}

static const struct sparc_bus_space_tag _mainbus_space_tag = {
	NULL,				/* cookie */
	NULL,				/* parent bus tag */
	UPA_BUS_SPACE,			/* type */
	ASI_PRIMARY,
	ASI_PRIMARY,
	"mainbus",
	sparc_bus_alloc,
	sparc_bus_free,
	sparc_bus_map,			/* bus_space_map */
	sparc_bus_protect,		/* bus_space_protect */
	sparc_bus_unmap,		/* bus_space_unmap */
	sparc_bus_subregion,		/* bus_space_subregion */
	sparc_bus_mmap,			/* bus_space_mmap */
	sparc_mainbus_intr_establish,	/* bus_intr_establish */
	sparc_bus_addr			/* bus_space_addr */
};
const bus_space_tag_t mainbus_space_tag = &_mainbus_space_tag;

struct cfdriver mainbus_cd = {
	NULL, "mainbus", DV_DULL
};

#define _BS_PRECALL(t,f)		\
        while (t->f == NULL)		\
                t = t->parent;
#define _BS_POSTCALL

#define _BS_CALL(t,f)			\
        (*(t)->f)

int
bus_space_alloc(bus_space_tag_t t, bus_addr_t rs, bus_addr_t re, bus_size_t s,
    bus_size_t a, bus_size_t b, int f, bus_addr_t *ap, bus_space_handle_t *hp)
{
        const bus_space_tag_t t0 = t;
        int ret;

        _BS_PRECALL(t, sparc_bus_alloc);
        ret = _BS_CALL(t, sparc_bus_alloc)(t, t0, rs, re, s, a, b, f, ap, hp);
        _BS_POSTCALL;
        return ret;
}

void
bus_space_free(bus_space_tag_t t, bus_space_handle_t h, bus_size_t s)
{
	const bus_space_tag_t t0 = t;

	_BS_PRECALL(t, sparc_bus_free);
	_BS_CALL(t, sparc_bus_free)(t, t0, h, s);
	_BS_POSTCALL;
}

int
bus_space_map(bus_space_tag_t t, bus_addr_t a, bus_size_t s, int f,
    bus_space_handle_t *hp)
{
	const bus_space_tag_t t0 = t;
	int ret;

	_BS_PRECALL(t, sparc_bus_map);
	ret = _BS_CALL(t, sparc_bus_map)(t, t0, a, s, f, hp);
	_BS_POSTCALL;
#ifdef BUS_SPACE_DEBUG
	if(s == 0) {
		char buf[128];
		bus_space_render_tag(t, buf, sizeof buf);
		printf("\n********** bus_space_map: requesting "
		    "zero-length mapping on bus %p:%s",
		    t, buf);
	}
	hp->bh_flags = 0;
	if (ret == 0) {
		hp->bh_size = s;
		hp->bh_tag = t0;
	} else {
		hp->bh_size = 0;
		hp->bh_tag = NULL;
	}
#endif /* BUS_SPACE_DEBUG */
	return (ret);
}

int
bus_space_protect(bus_space_tag_t t, bus_space_handle_t h, bus_size_t s, int f)
{
	const bus_space_tag_t t0 = t;
	int ret;

	_BS_PRECALL(t, sparc_bus_protect);
	ret = _BS_CALL(t, sparc_bus_protect)(t, t0, h, s, f);
	_BS_POSTCALL;

	return (ret);
}

int
bus_space_unmap(bus_space_tag_t t, bus_space_handle_t h, bus_size_t s)
{
	const bus_space_tag_t t0 = t;
	int ret;

	_BS_PRECALL(t, sparc_bus_unmap);
	BUS_SPACE_ASSERT(t0, h, 0, 1);
#ifdef BUS_SPACE_DEBUG
	if(h.bh_size != s) {
		char buf[128];
		bus_space_render_tag(t0, buf, sizeof buf);
		printf("\n********* bus_space_unmap: %p:%s, map/unmap "
		    "size mismatch (%llx != %llx)",
		    t, buf, h.bh_size, s);
	}
#endif /* BUS_SPACE_DEBUG */
	ret = _BS_CALL(t, sparc_bus_unmap)(t, t0, h, s);
	_BS_POSTCALL;
	return (ret);
}

int
bus_space_subregion(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o,
    bus_size_t s, bus_space_handle_t *hp)
{
	const bus_space_tag_t t0 = t;
	int ret;

	_BS_PRECALL(t, sparc_bus_subregion);
	BUS_SPACE_ASSERT(t0, h, o, 1);
#ifdef BUS_SPACE_DEBUG
	if(h.bh_size < o + s) {
		char buf[128];
		bus_space_render_tag(t0, buf, sizeof buf);
		printf("\n********** bus_space_subregion: "
		    "%p:%s, %llx < %llx + %llx", 
		    t0, buf, h.bh_size, o, s);
		hp->bh_size = 0;
		hp->bh_tag = NULL;
		return (EINVAL);
	}
#endif /* BUS_SPACE_DEBUG */
	ret = _BS_CALL(t, sparc_bus_subregion)(t, t0, h, o, s, hp);
	_BS_POSTCALL;
#ifdef BUS_SPACE_DEBUG
	if (ret == 0) {
		hp->bh_size = s;
		hp->bh_tag = t0;
	} else {
		hp->bh_size = 0;
		hp->bh_tag = NULL;
	}
#endif /* BUS_SPACE_DEBUG */
	return (ret);
}

paddr_t
bus_space_mmap(bus_space_tag_t t, bus_addr_t a, off_t o, int p, int f)
{
	const bus_space_tag_t t0 = t;
	paddr_t ret;

	_BS_PRECALL(t, sparc_bus_mmap);
	ret = _BS_CALL(t, sparc_bus_mmap)(t, t0, a, o, p, f);
	_BS_POSTCALL;
	return (ret);
}

void *
bus_intr_establish(bus_space_tag_t t, int p, int l, int f, int (*h)(void *),
    void *a, const char *w)
{
	const bus_space_tag_t t0 = t;
	void *ret;

	_BS_PRECALL(t, sparc_intr_establish);
	ret = _BS_CALL(t, sparc_intr_establish)(t, t0, p, l, f, h, a, w);
	_BS_POSTCALL;
	return (ret);
}

/* XXXX Things get complicated if we use unmapped register accesses. */
void *
bus_space_vaddr(bus_space_tag_t t, bus_space_handle_t h)
{
	BUS_SPACE_ASSERT(t, h, 0, 1);
        if(t->asi == ASI_PRIMARY || t->asi == ASI_PRIMARY_LITTLE) 
		return 	((void *)(vaddr_t)(h.bh_ptr));

#ifdef BUS_SPACE_DEBUG
	{ /* Scope */
		char buf[64];
		bus_space_render_tag(t, buf, sizeof buf);
		printf("\nbus_space_vaddr: no vaddr for %p:%s (asi=%x)",
			t, buf, t->asi);
	}
#endif

	return (NULL);
}

void
bus_space_render_tag(bus_space_tag_t t, char* buf, size_t len)
{
	if (t == NULL) {
		strlcat(buf, "<NULL>", len);
		return;
	}
	buf[0] = '\0';
	if (t->parent)
		bus_space_render_tag(t->parent, buf, len);

	strlcat(buf, "/", len);
	strlcat(buf, t->name, len);
}

#ifdef BUS_SPACE_DEBUG

void
bus_space_assert(bus_space_tag_t t, const bus_space_handle_t *h, bus_size_t o,
    int n)
{
        if (h->bh_tag != t) {
		char buf1[128];
		char buf2[128];
		bus_space_render_tag(t, buf1, sizeof buf1);
		bus_space_render_tag(h->bh_tag, buf2, sizeof buf2);
                printf("\n********** bus_space_assert: wrong tag (%p:%s, "
		    "expecting %p:%s) ", t, buf1, h->bh_tag, buf2);
	}

        if (o >= h->bh_size) {
		char buf[128];
		bus_space_render_tag(t, buf, sizeof buf);
                printf("\n********** bus_space_assert: bus %p:%s, offset "
		    "(%llx) out of mapping range (%llx) ", t, buf, o,
		    h->bh_size);
	}

	if (o & (n - 1)) {
		char buf[128];
		bus_space_render_tag(t, buf, sizeof buf);
                printf("\n********** bus_space_assert: bus %p:%s, offset "
		    "(%llx) incorrect alignment (%d) ", t, buf, o, n);
	}
}

#endif /* BUS_SPACE_DEBUG */

struct blink_led_softc {
	SLIST_HEAD(, blink_led) bls_head;
	int bls_on;
	struct timeout bls_to;
} blink_sc = { SLIST_HEAD_INITIALIZER(blink_sc.bls_head), 0 };

void
blink_led_register(struct blink_led *l)
{
	if (SLIST_EMPTY(&blink_sc.bls_head)) {
		timeout_set(&blink_sc.bls_to, blink_led_timeout, &blink_sc);
		blink_sc.bls_on = 0;
		if (sparc_led_blink)
			timeout_add(&blink_sc.bls_to, 1);
	}
	SLIST_INSERT_HEAD(&blink_sc.bls_head, l, bl_next);
}

void
blink_led_timeout(void *vsc)
{
	struct blink_led_softc *sc = &blink_sc;
	struct blink_led *l;
	int t;

	if (SLIST_EMPTY(&sc->bls_head))
		return;

	SLIST_FOREACH(l, &sc->bls_head, bl_next) {
		(*l->bl_func)(l->bl_arg, sc->bls_on);
	}
	sc->bls_on = !sc->bls_on;

	if (!sparc_led_blink)
		return;

	/*
	 * Blink rate is:
	 *      full cycle every second if completely idle (loadav = 0)
	 *      full cycle every 2 seconds if loadav = 1
	 *      full cycle every 3 seconds if loadav = 2
	 * etc.
	 */
	t = (((averunnable.ldavg[0] + FSCALE) * hz) >> (FSHIFT + 1));
	timeout_add(&sc->bls_to, t);
}
@


1.183
log
@p_comm is the process's command and isn't per thread, so move it from
struct proc to struct process.

ok deraadt@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.182 2017/01/13 09:18:11 fcambus Exp $	*/
d1330 1
a1330 1
		membar(MemIssue);
@


1.182
log
@Ansify cpu_sysctl() on alpha, arm, arm64, luna88k and sparc64.

OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.181 2016/10/09 11:25:40 tom Exp $	*/
d499 1
a499 1
		    p->p_comm, p->p_p->ps_pid, sig, &fp->sf_sc);
@


1.181
log
@Apply consistency to forever loops with continue and NOTREACHED

Same thought from kettenis@@, ok krw@@ phessler@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.180 2016/10/08 05:49:09 guenther Exp $	*/
d370 2
a371 8
cpu_sysctl(name, namelen, oldp, oldlenp, newp, newlen, p)
	int *name;
	u_int namelen;
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
	struct proc *p;
@


1.180
log
@Various printf claim to report the PID, so actually report that and not the TID

Build testing assistance from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.179 2016/09/18 14:28:25 deraadt Exp $	*/
d703 2
a704 1
	for (;;) ;
@


1.179
log
@option INSECURE is obsolete
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.178 2016/07/16 08:53:38 tom Exp $	*/
d505 1
a505 1
		       p->p_comm, p->p_pid, sig, &fp->sf_sc);
@


1.178
log
@Fix typo in comment in three machdep.c files:

s/names are this level/names at this level/

from aalm@@ - thanks
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.177 2016/05/21 01:12:35 deraadt Exp $	*/
a173 3
#ifdef INSECURE
int allowaperture = 1;
#else
a174 1
#endif
@


1.177
log
@hand-massage sendsig() and sys_sigreturn() to be much more similar
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.176 2016/05/10 18:39:49 deraadt Exp $	*/
d385 1
a385 1
	/* all sysctl names are this level are terminal */
@


1.176
log
@SROP mitigation.  sendsig() stores a (per-process ^ &sigcontext) cookie
inside the sigcontext.  sigreturn(2) checks syscall entry was from the
exact PC addr in the (per-process ASLR) sigtramp, verifies the cookie,
and clears it to prevent sigcontext reuse.
not yet tested on landisk, sparc, *88k, socppc.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.175 2016/03/07 13:21:51 naddy Exp $	*/
d427 2
a428 6
sendsig(catcher, sig, mask, code, type, val)
	sig_t catcher;
	int sig, mask;
	u_long code;
	int type;
	union sigval val;
d535 1
a535 4
sys_sigreturn(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d540 1
a540 1
	struct sigcontext *scp = SCARG(uap, sigcntxp), ksc;
a544 3
		printf("%s(%d): sigreturn not from tramp [pc 0x%llx 0x%lx]\n",
		    p->p_comm, p->p_pid, PROC_PC(p),
		     p->p_p->ps_sigcoderet);
a565 3
		printf("%s(%d): cookie %lx should have been %lx\n",
		    p->p_comm, p->p_pid, ksc.sc_cookie,
		    (long)scp ^ p->p_p->ps_sigcookie);
d573 1
a573 2
	    offsetof(struct sigcontext, sc_cookie),
	    sizeof (ksc.sc_cookie));
@


1.175
log
@Sync no-argument function declaration and definition by adding (void).
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.174 2015/10/21 07:59:18 mpi Exp $	*/
d495 1
a495 1
	/* XXX do not copyout siginfo if not needed */
d547 1
a547 1
	struct sigcontext sc, *scp;
d551 8
d569 4
a572 6
	scp = SCARG(uap, sigcntxp);
 	if ((vaddr_t)scp & 3 ||
	    (error = copyin((caddr_t)scp, &sc, sizeof sc)) != 0) {
#ifdef DEBUG
		printf("sigreturn: copyin failed: scp=%p\n", scp);
#endif
d574 7
d582 8
a589 1
	scp = &sc;
d597 2
a598 2
	if (((sc.sc_pc | sc.sc_npc) & 3) != 0 ||
	    (sc.sc_pc == 0) || (sc.sc_npc == 0)) {
d601 2
a602 2
		   (void *)(unsigned long)sc.sc_pc,
		   (void *)(unsigned long)sc.sc_npc);
@


1.174
log
@Do not call uvm_swap_finicrypt_all() a second time in dumpsys().

ok tedu@@, deraadt@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.173 2015/09/08 10:24:26 deraadt Exp $	*/
d206 1
a206 1
cpu_startup()
d755 1
a755 1
dumpsys()
d898 1
a898 1
stackdump()
@


1.173
log
@sizes for free(); ok semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.172 2014/12/10 15:29:53 mikeb Exp $	*/
a787 4

#ifdef UVM_SWAP_ENCRYPT
	uvm_swap_finicrypt_all();
#endif
@


1.172
log
@retire shutdown hooks; ok deraadt, krw
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.171 2014/11/16 12:30:59 deraadt Exp $	*/
d336 1
a336 1
		free(p->p_md.md_fpstate, M_SUBPROC, 0);
@


1.171
log
@Replace a plethora of historical protection options with just
PROT_NONE, PROT_READ, PROT_WRITE, and PROT_EXEC from mman.h.
PROT_MASK is introduced as the one true way of extracting those bits.
Remove UVM_ADV_* wrapper, using the standard names.
ok doug guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.170 2014/10/25 16:58:59 kettenis Exp $	*/
a656 1
	doshutdownhooks();
d688 1
a688 1
			
@


1.170
log
@uvm_km_valloc -> km_alloc
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.169 2014/10/24 20:26:58 kettenis Exp $	*/
d828 1
a828 1
					VM_PROT_READ, VM_PROT_READ|PMAP_WIRED);
d1479 2
a1480 2
		    VM_PROT_READ | VM_PROT_WRITE, VM_PROT_READ |
		    VM_PROT_WRITE | PMAP_WIRED | PMAP_CANFAIL);
d1599 1
a1599 1
	vm_prot_t pm_prot = VM_PROT_READ;
d1660 1
a1660 1
		pm_prot |= VM_PROT_WRITE;
d1731 1
a1731 1
	    VM_PROT_READ : VM_PROT_READ | VM_PROT_WRITE;
@


1.169
log
@Bring phys_map to sparc64 and use it in vmapbuf(9) and vunmapbuf(9).
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.168 2014/09/18 18:55:23 kettenis Exp $	*/
d1651 1
a1651 1
	va = uvm_km_valloc(kernel_map, size);
d1764 1
a1764 1
	uvm_km_free(kernel_map, va, endva - va);
@


1.168
log
@Use config_suspend_all(9).

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.167 2014/07/21 17:25:47 uebayasi Exp $	*/
d163 1
d236 7
@


1.167
log
@boot(9): Reduce annoying style diffs

- Always use either: ((x & RB_XXX) != 0) or ((x & RB_XXX) == 0) in boolean
  context (mostly if (x), or x ? y : z)
  - prom_halt() in alpha is confirmed to take int as boolean

Converted by coccinelle.  No functional change intended.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a611 1
	struct device *mainbus;
d650 1
a650 3
	mainbus = device_mainbus();
	if (mainbus != NULL)
		config_suspend(mainbus, DVACT_POWERDOWN);
@


1.166
log
@boot(9): Cosmetic changes to improve diff'ability.
@
text
@d646 1
a646 1
	if (howto & RB_DUMP)
d656 1
a656 1
	if ((howto & RB_POWERDOWN) == RB_POWERDOWN) {
d665 1
a665 1
	if (howto & RB_HALT) {
d685 1
a685 1
	if (howto & RB_SINGLE)
d687 1
a687 1
	if (howto & RB_KDB)
@


1.165
log
@Cosmetic changes to reduce diffs.
@
text
@d697 2
a698 1
	/*NOTREACHED*/
@


1.164
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.163 2014/07/11 22:28:06 uebayasi Exp $	*/
d643 1
a643 1
	splhigh();		/* Disable interrupts. */
a645 1
	/* If rebooting and a dump is requested, do it. */
@


1.163
log
@boot(9): Undo curproc-overriding hacks

Some (not all) boot(9) implementations have ancient hacks which overrides if
(curproc == NULL).  This was probably made in a hope to forcibly proceed
various clean-shutdown related code, including VFS shutdown.  Let's clarify
that clean-shutdown needs process context; it is impossible to cleanly shutdown
VFS from within e.g. a panic in SPL_HIGH.

OK kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d328 1
a328 1
		free(p->p_md.md_fpstate, M_SUBPROC);
d1005 1
a1005 1
	free(map, M_DEVBUF);
d1423 1
a1423 1
	free(segs[0]._ds_mlist, M_DEVBUF);
d1817 1
a1817 1
	free(arg, M_DEVBUF);
@


1.162
log
@Convert bus_dmamem_map(9) to km_alloc(9) in order to make it fail and
not sleep if the allocator cannot obtain a lock when BUS_DMA_NOWAIT is
specified.

idea and inputs from kettenis@@, ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.161 2014/07/10 21:46:03 mpi Exp $	*/
a622 1
		extern struct proc proc0;
a624 3
		/* make sure there's a process to charge for I/O in sync() */
		if (curproc == NULL)
			curproc = &proc0;
@


1.161
log
@Set cold to 1 before executing the DVACT_POWERDOWN handlers when halting or
rebooting a machine, like it is done in the hibernate case.

At least some USB host controller drivers rely on this to busy way instead
of sleeping.  Avoid a panic on macppc with an uhci(4) cardbus plugged in.

ok deraadt@@, uebayashi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.160 2014/07/10 20:15:27 uebayasi Exp $	*/
d1443 1
d1457 2
a1458 1
	va = uvm_km_valloc(kernel_map, size);
d1482 1
a1482 1
			uvm_km_free(kernel_map, sva, ssize);
d1509 1
a1509 2
	size = round_page(size);
	uvm_km_free(kernel_map, (vaddr_t)kva, size);
@


1.160
log
@boot(9): Remove comments about RB_*, "cold", and savectx()

Again remove slightly different comments to reduce diffs.  These will be
re-added once boot() become MI and its specification is clearly re-defined.

OK miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d647 2
a648 1
	(void) splhigh();		/* ??? */
@


1.159
log
@boot(): Remove comments about RB_TIMEBAD to reduce diffs

RB_TIMEBAD is documented well enough that the comment is not needed.  sparc64
does slightly different and its comment is left with XXX.

OK deraadt@@ miod@@
@
text
@a613 1
	/* If system is cold, just halt. */
a614 1
		/* (Unless the user explicitly asked for reboot.) */
@


1.158
log
@boot(): Unify declarations

OK deraadt@@
@
text
@d635 1
a635 2
		 * If we've been adjusting the clock, the todr
		 * will be out of synch; adjust it now.
@


1.157
log
@Revert previous diff setting cold to 1 on shutdown because it breaks machine
with softraid(4) disks.

softraid(4) is the last real consumer of the doshutdownhooks(9) API and it is
not trivial to convert its hook to a DVACT_POWERDOWN handler since the latter
does not allow to sleep.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.156 2014/05/30 13:46:17 mpi Exp $	*/
d607 2
a608 3
void
boot(howto)
	int howto;
@


1.156
log
@Set cold to 1 before executing the DVACT_POWERDOWN handlers when halting or
rebooting a machine, like it is done in the hibernate case.

At least some USB host controller drivers rely on this to busy way instead
of sleeping.  Avoid a panic on macppc with an uhci(4) cardbus plugged in.

ok deraadt@@, uebayashi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.155 2014/05/25 13:57:48 deraadt Exp $	*/
d651 1
a651 2
	splhigh();		/* Disable interrupts. */
	cold = 1;
@


1.155
log
@Turn on blinky things by default, very useful here
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.154 2014/05/10 12:29:58 kettenis Exp $	*/
d651 2
a652 1
	(void) splhigh();		/* ??? */
@


1.154
log
@A few more straightforward format string fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.153 2014/03/26 05:23:42 guenther Exp $	*/
d170 1
a170 1
int sparc_led_blink;
@


1.153
log
@Move p_emul and p_sigcode from proc to process.
Tweak the handling of ktrace EMUL when changing ktracing: only
generate one per process (not one per thread) and pass the correct
proc pointer down to the VFS layer.  Permit generating of NAMI and
CSW records inside ktrace(2) itself.

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.152 2014/03/22 06:05:45 guenther Exp $	*/
d828 1
a828 1
				printf("%d ", i / (1024*1024));
@


1.152
log
@Move p_sigacts from struct proc to struct process.

testing help mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.151 2014/03/21 03:56:49 guenther Exp $	*/
d513 1
a513 1
	addr = p->p_sigcode;
@


1.151
log
@Correct the (normally ignored) argument to SLIST_HEAD_INITIALIZER()
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.150 2014/03/13 03:52:56 dlg Exp $	*/
d427 1
a427 1
	struct sigacts *psp = p->p_sigacts;
@


1.150
log
@get rid of the assumption that the head of the alldevs list is the
"mainbus" device. this breaks when mpath is enabled because it
attaches before mainbus and therefore takes the head position.

have autoconf provide device_mainbus() which looks up mainbus_cd,
and use that instead.

discussed with deraadt who just wants mpath stuff to move forward
despite there being many ways to shine this particular turd.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.149 2013/11/01 17:36:19 krw Exp $	*/
d2107 1
a2107 1
} blink_sc = { SLIST_HEAD_INITIALIZER(bls_head), 0 };
@


1.149
log
@Sprinkle (long long) casts where %lld is being used to print daddr_t
variables. Some random whitespace/knf repairs encountered on the way.

ok miod@@ on inspection, feedback & more suggestions from millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.148 2013/09/28 12:40:32 miod Exp $	*/
d613 1
d659 3
a661 2
	if (!TAILQ_EMPTY(&alldevs))
		config_suspend(TAILQ_FIRST(&alldevs), DVACT_POWERDOWN);
@


1.148
log
@In boot(), do not iterate over alldevs if it's empty (i.e. halting from ddb
with ddb entered early with boot -d or from UKC).
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.147 2013/06/11 16:42:12 deraadt Exp $	*/
d805 1
a805 1
printf("starting dump, blkno %lld\n", blkno);
@


1.147
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.146 2013/02/15 22:58:17 kettenis Exp $	*/
d658 2
a659 1
	config_suspend(TAILQ_FIRST(&alldevs), DVACT_POWERDOWN);
@


1.146
log
@We deprecated returning to %g7 after a successful system call long ago.
These days we use it as a thread register and want to have it initialized to
zero for future thread local storage (TLS) support.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.145 2013/01/22 23:56:31 dlg Exp $	*/
d758 2
a759 2
	daddr64_t blkno;
	int (*dump)(dev_t, daddr64_t, caddr_t, size_t);
@


1.145
log
@pull the guts of bus_space_barrier into the inline function in the header.
there's only one implementation of it on sparc64, so we shouldnt need to
iterate up a chain of bus_space_tags to get to it.

because the only argument that is used inside the function is the flags,
this can generally be inlined to a single membar opcode. this leaves that
op as membar(Sync) for now while kettenis@@ thinks about what changing it
might mean.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.144 2012/12/22 17:26:46 kettenis Exp $	*/
d335 1
a335 1
	tf->tf_global[2] = tf->tf_global[7] = tf->tf_pc;
@


1.144
log
@We already zero out the trapframe, so there is no reason to set individual
members to zero.  Gets rid of a bogus comment as a bonus.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.143 2012/12/02 07:03:31 guenther Exp $	*/
a1583 2
void sparc_bus_barrier(bus_space_tag_t, bus_space_tag_t,  bus_space_handle_t,
    bus_size_t, bus_size_t, int);
a1837 13
void
sparc_bus_barrier(bus_space_tag_t t, bus_space_tag_t t0, bus_space_handle_t h,
    bus_size_t offset, bus_size_t size, int flags)
{
	/* 
	 * We have lots of alternatives depending on whether we're
	 * synchronizing loads with loads, loads with stores, stores
	 * with loads, or stores with stores.  The only ones that seem
	 * generic are #Sync and #MemIssue.  I'll use #Sync for safety.
	 */
	membar(Sync);
}

a1865 1
	sparc_bus_barrier,		/* bus_space_barrier */
@


1.143
log
@Determine whether we're currently on the alternative signal stack
dynamically, by comparing the stack pointer against the altstack
base and size, so that you get the correct answer if you longjmp
out of the signal handler, as tested by regress/sys/kern/stackjmp/.
Also, fix alt stack handling on vax, where it was completely broken.

Testing and corrections by miod@@, krw@@, tobiasu@@, pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.142 2012/10/22 17:27:19 kettenis Exp $	*/
a332 2
	/* %g4 needs to point to the start of the data segment */
	tf->tf_global[4] = 0; 
a337 1
	tf->tf_out[7] = 0;
@


1.142
log
@Stop passing around PS_STRINGS in %g1.  The ELF ABI reserves this register
for passing around a pointer to a cleanup function and we'd like to use it
for that purpose in the near future.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.141 2012/10/08 21:47:50 deraadt Exp $	*/
d433 1
a433 2
	vaddr_t addr; 
	struct rwindow *oldsp, *newsp;
a434 1
	int onstack;
d437 1
a437 1
	oldsp = (struct rwindow *)(u_long)(tf->tf_out[6] + STACK_OFFSET);
d443 2
a444 4
	onstack = p->p_sigstk.ss_flags & SS_ONSTACK;

	if ((p->p_sigstk.ss_flags & SS_DISABLE) == 0 && !onstack &&
	    (psp->ps_sigonstack & sigmask(sig))) {
d447 1
a447 2
		p->p_sigstk.ss_flags |= SS_ONSTACK;
	} else
d457 1
a463 1
	sf.sf_sc.sc_onstack = onstack;
d487 1
a487 1
	newsp = (struct rwindow *)((vaddr_t)fp - sizeof(struct rwindow));
d520 1
a520 1
	tf->tf_out[6] = (vaddr_t)newsp - STACK_OFFSET;
a588 6

	/* Restore signal stack. */
	if (sc.sc_onstack & SS_ONSTACK)
		p->p_sigstk.ss_flags |= SS_ONSTACK;
	else
		p->p_sigstk.ss_flags &= ~SS_ONSTACK;
@


1.141
log
@Revamp the sequences for suspend/hibernate -> resume so that the code
paths are reflexive.  It is now possible to fail part-way through a
suspend sequence, and recover along the resume code path.
Split DVACT_SUSPEND by adding a new DVACT_POWERDOWN method is used
after hibernate (and suspend too) to finish the job.  Some drivers
must be converted at the same time to use this instead of shutdown hooks
(the others will follow at a later time)
ok kettenis mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.140 2012/08/24 10:00:55 jsg Exp $	*/
a299 1
	 *	%g1: address of PS_STRINGS (used by crt0)
a332 1
	tf->tf_global[1] = (u_long)PS_STRINGS;
@


1.140
log
@don't read past the end of an array when dumping the stack.
same problem/fix as sparc.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.139 2012/08/22 13:33:33 okan Exp $	*/
a672 1
	/* Run any shutdown hooks. */
d674 1
@


1.139
log
@sigpid should be of type pid_t (only visable with DEBUG).

ok miod@@ (who found others to fix as well)
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.138 2012/05/09 18:34:21 okan Exp $	*/
d944 1
a944 1
			printf("  pc = %x  args = (%x, %x, %x, %x, %x, %x, %x) "
d947 1
a947 2
			    fp->fr_arg[4], fp->fr_arg[5], fp->fr_arg[6],
			    fp->fr_fp);
@


1.138
log
@merge sigdebug.h into machdep.c, to where all other architectures have
these (DEBUG) defines.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.137 2012/03/23 15:51:26 guenther Exp $	*/
d352 1
a352 1
int sigpid = 0;
@


1.137
log
@Make rusage totals, itimers, and profile settings per-process instead
of per-rthread.  Handling of per-thread tick and runtime counters
inspired by how FreeBSD does it.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.136 2011/07/05 04:48:02 guenther Exp $	*/
d351 1
a351 3
/* See sigdebug.h */
#include <sparc64/sparc64/sigdebug.h>
int sigdebug = 0x0;
d353 4
@


1.136
log
@Recommit the reverted sigacts change now that the NFS use-after-free
problem has been tracked down.  This fixes the sharing of the signal
handling state: shared bits go in sigacts, per-rthread bits goes in
struct proc.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.135 2011/06/26 22:40:00 deraadt Exp $	*/
d642 1
a642 1
		/* XXX protect against curproc->p_stats.foo refs in sync() */
@


1.135
log
@if_downall() cannot be done MI in sys_reboot() because vfs_shutdown()
might need network (ie. nfs).  Move the call to the MD boot() routines.
This cause for boot hangs diagnosed by kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.134 2011/06/24 19:47:49 naddy Exp $	*/
d445 1
a445 1
	onstack = psp->ps_sigstk.ss_flags & SS_ONSTACK;
d447 1
a447 1
	if ((psp->ps_flags & SAS_ALTSTACK) && !onstack &&
d449 3
a451 3
		fp = (struct sigframe *)((caddr_t)psp->ps_sigstk.ss_sp +
		    psp->ps_sigstk.ss_size);
		psp->ps_sigstk.ss_flags |= SS_ONSTACK;
d597 1
a597 1
		p->p_sigacts->ps_sigstk.ss_flags |= SS_ONSTACK;
d599 1
a599 1
		p->p_sigacts->ps_sigstk.ss_flags &= ~SS_ONSTACK;
@


1.134
log
@machdep.kbdreset enables a shutdown by Ctrl-Alt-Del on amd64 and
i386.  Stop abusing it on other archs for controling a shutdown by
pressing the soft power button:

* Add a MI sysctl hw.allowpowerdown; if set to 1 (the default) it
  allows a power button shutdown.
* Make acpi(4)/acpibtn(4) honor hw.allowpowerdown.
* Switch the various power button intercepts on landisk, sgi, sparc64
  and zaurus over to hw.allowpowerdown.
* Garbage collect the machdep.kbdreset sysctl on all archs other than
  amd64 and i386.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.133 2011/06/23 20:44:39 ariane Exp $	*/
d94 1
d661 1
@


1.133
log
@Fix the error path in bus_dmamem_map.
As discussed on icb: remove the comment,
remove pmap_remove (uvm_km_free does that for us).

ok oga@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.132 2011/06/05 19:41:08 deraadt Exp $	*/
a169 1
int kbd_reset;
a410 4
	case CPU_KBDRESET:
		if (securelevel > 0)
			return (sysctl_rdint(oldp, oldlenp, newp, kbd_reset));
		return (sysctl_int(oldp, oldlenp, newp, newlen, &kbd_reset));
@


1.132
log
@Move the bufcachepercent setting code to MI locations -- set it to 42%
for now; that is unlikely to hit some of the remaining starvation bugs.
Repair the bufpages calculation too; i386 was doing it ahead of time
(incorrectly) and then re-calculating it.
ok thib
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.131 2011/04/18 21:44:56 guenther Exp $	*/
a1496 4
			/*
			 * Clean up after ourselves.
			 * XXX uvm_wait on WAITOK
			 */
d1498 1
a1498 1
			uvm_km_free(kernel_map, va, ssize);
@


1.131
log
@Revert the sigacts diff: NFS can apparently retain pointers to processes
until they're zombies and then send them signals (for intr mounts).  Until
that is untangled, the sigacts change is unsafe.  sthen@@ was the victim
for this one
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.129 2011/04/07 15:30:16 miod Exp $	*/
a161 14

/*
 * Declare these as initialized data so we can patch them.
 */
#ifndef BUFCACHEPERCENT
#define BUFCACHEPERCENT 10
#endif

#ifdef	BUFPAGES
int	bufpages = BUFPAGES;
#else
int	bufpages = 0;
#endif
int	bufcachepercent = BUFCACHEPERCENT;
@


1.130
log
@Correct the sharing of the signal handling state: stuff that should
be shared (p_sigignore, p_sigcatch, P_NOCLDSTOP, P_NOCLDWAIT) moves
to struct sigacts, wihle stuff that should be per rthread (ps_oldmask,
SAS_OLDMASK, ps_sigstk) moves to struct proc.  Treat the coredumping
state bits (ps_sig, ps_code, ps_type, ps_sigval) as per-rthread
until our locking around coredumping is better.

Oh, and remove the old SunOS-compat ps_usertramp member.

"I like the sound of this" tedu@@
@
text
@d463 1
a463 1
	onstack = p->p_sigstk.ss_flags & SS_ONSTACK;
d465 1
a465 1
	if ((p->p_sigstk.ss_flags & SS_DISABLE) == 0 && !onstack &&
d467 3
a469 3
		fp = (struct sigframe *)((caddr_t)p->p_sigstk.ss_sp +
		    p->p_sigstk.ss_size);
		p->p_sigstk.ss_flags |= SS_ONSTACK;
d615 1
a615 1
		p->p_sigstk.ss_flags |= SS_ONSTACK;
d617 1
a617 1
		p->p_sigstk.ss_flags &= ~SS_ONSTACK;
@


1.129
log
@Do not use NULL in integer comparisons. No functional change.
ok matthew@@ tedu@@, also eyeballed by at least krw@@ oga@@ kettenis@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.128 2011/03/05 17:48:59 deraadt Exp $	*/
d463 1
a463 1
	onstack = psp->ps_sigstk.ss_flags & SS_ONSTACK;
d465 1
a465 1
	if ((psp->ps_flags & SAS_ALTSTACK) && !onstack &&
d467 3
a469 3
		fp = (struct sigframe *)((caddr_t)psp->ps_sigstk.ss_sp +
		    psp->ps_sigstk.ss_size);
		psp->ps_sigstk.ss_flags |= SS_ONSTACK;
d615 1
a615 1
		p->p_sigacts->ps_sigstk.ss_flags |= SS_ONSTACK;
d617 1
a617 1
		p->p_sigacts->ps_sigstk.ss_flags &= ~SS_ONSTACK;
@


1.128
log
@since the bus_space_barrier function does the same membar operation for
all cases, it should not waste time doing extra if/else if/else if/else
conditions.  i wonder how much this is going to speed up sparc64...
ok miod kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.127 2010/12/26 15:41:00 miod Exp $	*/
d356 1
a356 1
	tf->tf_out[7] = NULL;
d1811 1
a1811 1
		return (NULL);
@


1.127
log
@Kill pmap_phys_address(), and force every driver's mmap() routine to return
a physical address [more precisely, something suitable to pass to pmap_enter()'sphysical address argument].

This allows MI drivers to implement mmap() routines without having to know
about the pmap_phys_address() implementation and #ifdef obfuscation.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.126 2010/11/27 19:41:48 miod Exp $	*/
d1886 1
a1886 9
	if (flags == (BUS_SPACE_BARRIER_READ|BUS_SPACE_BARRIER_WRITE))
		membar(Sync);
	else if (flags == BUS_SPACE_BARRIER_READ)
		membar(Sync);
	else if (flags == BUS_SPACE_BARRIER_WRITE)
		membar(Sync);
	else
		printf("sparc_bus_barrier: unknown flags\n");
	return;
@


1.126
log
@Misaligned load/store recovery code in the kernel, enabled by T_FIXALIGN
userland traps on a per-process basis, were necessary for *some* SunOS
binaries on sparc, which had to compiled with explicit misaligned access code
generation (i.e. for vendors to release a working SunOS/sparc version of their
code until they could fix their bogus code).

There is no reason to keep this code on sparc64, and now that we don't provide
COMPAT_SUNOS anymore, there is no reason to keep this code on sparc.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.125 2010/11/20 20:33:24 miod Exp $	*/
d1576 1
a1576 1
		return (atop(segs[i].ds_addr + off));
@


1.125
log
@This is a first step towards getting rid of avail_start and avail_end in the
kernel, currently limited to low-hanging fruit: these variables were used
by bus_dma to specify the range in which to allocate memory, back when
uvm_pglistalloc() was stupid and would not walk the vm_physseg[].

Nowadays, except on some platforms for early initialization, these variables
are not used, or do not need to be global variables. Therefore:
- remove `extern' declarations of avail_start and avail_end (or close cousins,
  such as arm physical_start and physical_end) from files which no longer need
  to use them.
- make them local variables whenever possible.
- remove them when they are assigned to but no longer used.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.124 2010/06/27 03:03:48 thib Exp $	*/
a308 3

	/* Don't allow misaligned code by default */
	p->p_md.md_flags &= ~MDP_FIXALIGN;
@


1.124
log
@uvm constraints. Add two mandatory MD symbols, uvm_md_constraints
which contains the constraints for DMA/memory allocation for each
architecture, and dma_constraints which contains the range of addresses
that are dma accessable by the system.

This is based on ariane@@'s physcontig diff, with lots of bugfixes and
additions the following additions by my self:

Introduce a new function pool_set_constraints() which sets the address
range for which we allocate pages for the pool from, this is now used
for the mbuf/mbuf cluster pools to keep them dma accessible.

The !direct archs no longer stuff pages into the kernel object in
uvm_km_getpage_pla but rather do a pmap_extract() in uvm_km_putpages.

Tested heavily by my self on i386, amd64 and sparc64. Some tests on
alpha and SGI.

"commit it" beck, art, oga, deraadt
"i like the diff" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.122 2009/12/08 21:23:18 kettenis Exp $	*/
a161 1
extern vaddr_t avail_end;
a1374 1
extern paddr_t   vm_first_phys, vm_num_phys;
@


1.123
log
@PMAP_CANFAIL for bus_dmamem_map on all other architectures (and some
whitespace tweaks on i386 so that it matches).

ok kettenis@@
@
text
@d178 3
@


1.122
log
@Passing kva + size as the third argument to uvm_km_free() is a bad idea.  It
unmaps quite a bit more than intended, which causes weird things like
watchdog resets.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.121 2009/08/11 19:17:17 miod Exp $	*/
d1478 2
a1479 1
	vaddr_t va;
d1482 1
d1500 2
d1509 12
a1520 3
		pmap_enter(pmap_kernel(), va, addr | cbit,
		    VM_PROT_READ | VM_PROT_WRITE,
		    VM_PROT_READ | VM_PROT_WRITE | PMAP_WIRED);
@


1.121
log
@Do not bother initializing bufpages in the md code if the computation is
exactly the same the mi could will use if bufinit() is invoked with
bufpages == 0.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.120 2009/08/11 18:46:32 miod Exp $	*/
d1533 1
a1533 1
	uvm_km_free(kernel_map, (vaddr_t)kva, (vaddr_t)kva + size);
@


1.120
log
@With the SysV memory allocation changes, allocsys() doesn't do anything
anymore. Get rid of it completely.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.119 2009/08/09 10:40:18 blambert Exp $	*/
a238 7

	/*
	 * Determine how many buffers to allocate.
	 * We allocate bufcachepercent% of memory for buffer space.
	 */
	if (bufpages == 0)
		bufpages = physmem * bufcachepercent / 100;
@


1.119
log
@Rototill system V message queues.

No longer allocate a static amount of memory for messages in MD
boot path; message queues, message metadata, and message data now
all use dynamic memory, which means that runtime sysctls should now
be trivial to implement.

Since I'm going to be around all week to fix any breakage, this should
probably just go in now.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.118 2009/04/20 00:42:06 oga Exp $	*/
a209 1
caddr_t	allocsys(caddr_t);
a218 2
	caddr_t v;
	long sz;
a238 9
	/*
	 * Find out how much space we need, allocate it,
	 * and then give everything true virtual addresses.
	 */
	sz = (long)allocsys(NULL);
	if ((v = (caddr_t)uvm_km_alloc(kernel_map, round_page(sz))) == 0)
		panic("startup: no room for %lx bytes of tables", sz);
	if (allocsys(v) - v != sz)
		panic("startup: table size inconsistency");
a268 9
}

caddr_t
allocsys(caddr_t v)
{
#define valloc(name, type, num) \
	    v = (caddr_t)(((name) = (type *)v) + (num))

	return (v);
@


1.118
log
@Add a BUS_DMA_ZERO flag for bus_dmamem_alloc() to return zeroed memory.

Saves every damned driver calling bzero(), and continues the M_ZERO,
PR_ZERO symmetry.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.117 2009/04/14 16:01:04 oga Exp $	*/
a99 4
#ifdef SYSVMSG
#include <sys/msg.h>
#endif

a287 6
#ifdef SYSVMSG
	valloc(msgpool, char, msginfo.msgmax);
	valloc(msgmaps, struct msgmap, msginfo.msgseg);
	valloc(msghdrs, struct msg, msginfo.msgtql);
	valloc(msqids, struct msqid_ds, msginfo.msgmni);
#endif
@


1.117
log
@Convert the waitok field of uvm_pglistalloc to "flags", more will be added soon.

For the possibility of sleeping, the first two flags are UVM_PLA_WAITOK
and UVM_PLA_NOWAIT. It is an error not to show intention, so assert that
one of the two is provided. Switch over every caller in the tree to
using the appropriate flag.

ok art@@, ariane@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.116 2009/03/07 15:34:34 miod Exp $	*/
d1449 2
@


1.116
log
@When allocating memory in bus_dmamem_alloc() with uvm_pglistalloc(), do not
try to be smart for the address range, uvm_pglistalloc() is smart enough
nowadays.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.115 2009/02/17 19:05:52 oga Exp $	*/
d1426 1
a1426 1
	int error;
d1448 2
d1452 1
a1452 1
	    alignment, boundary, mlist, nsegs, (flags & BUS_DMA_NOWAIT) == 0);
@


1.115
log
@Remove an if 0ed out chunk for BUS_DMA_COHERENT in bus_dmamap_map.
sparc64 is dma coherent and won't be needing this.

ok kettenis@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.114 2008/12/30 16:05:45 kettenis Exp $	*/
a1424 1
	vaddr_t low, high;
a1429 2
	low = vm_first_phys;
	high = vm_first_phys + vm_num_phys - PAGE_SIZE;
d1449 1
a1449 1
	error = uvm_pglistalloc(size, low, high,
@


1.114
log
@Make _bus_dmamem_map(9) work.  This function wasn't actually used until now,
but soon will be.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.113 2008/11/22 18:12:32 art Exp $	*/
a1531 4
#if 0
	if (flags & BUS_DMA_COHERENT)
		cbit |= PMAP_NVC;
#endif
@


1.113
log
@The last parts of cpu_unidle. i386, amd64 and sparc64
In short, make cpu_unidle do what signotify used to do and
make signotify use cpu_unidle.
Also, include a cpu_unidle in need_resched, it won't change much right now
but will be needed in the future.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.112 2008/06/27 17:22:15 miod Exp $	*/
d1489 1
d1492 1
d1514 4
a1517 4
	vaddr_t va, sva;
	int r, cbit;
	size_t oversize;
	u_long align;
d1519 1
d1522 1
a1522 3

	cbit = PMAP_NC;
	align = PAGE_SIZE;
d1525 2
a1526 10

	/*
	 * Find a region of kernel virtual addresses that can accommodate
	 * our aligment requirements.
	 */
	oversize = size + align - PAGE_SIZE;
	r = uvm_map(kernel_map, &sva, oversize, NULL, UVM_UNKNOWN_OFFSET, 0,
	    UVM_MAPFLAG(UVM_PROT_NONE, UVM_PROT_NONE, UVM_INH_NONE,
	    UVM_ADV_NORMAL, 0));
	if (r != 0)
d1529 1
a1529 9
	/* Compute start of aligned region */
	va = sva;
	va += ((segs[0].ds_addr & (align - 1)) + align - va) & (align - 1);

	/* Return excess virtual addresses */
	if (va != sva)
		uvm_unmap(kernel_map, sva, va);
	if (va + size != sva + oversize)
		uvm_unmap(kernel_map, va + size, sva + oversize);
d1531 7
d1539 14
a1552 1
	*kvap = (caddr_t)va;
d1574 1
a1574 1
	uvm_unmap(kernel_map, (vaddr_t)kva, (vaddr_t)kva + size);
@


1.112
log
@Clear swap encryption keys before dumping a kernel image.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.111 2008/06/26 05:42:13 ray Exp $	*/
d672 1
a672 5
#ifdef MULTIPROCESSOR
	/* Send IPI if necessary. */
	if (p->p_cpu != curcpu() && p->p_cpu != NULL)
		smp_signotify(p);
#endif
@


1.111
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.110 2008/06/09 07:07:15 djm Exp $	*/
d862 4
@


1.110
log
@rename arc4random_bytes => arc4random_buf to match libc's nicer name;
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.109 2008/04/20 10:35:57 kettenis Exp $	*/
a19 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.109
log
@Remove the random() function from locore.s (which used sparcv7 instructions,
including mulscc to do multiplications) and switch to the generic random.c
code.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.108 2008/04/18 06:42:21 djm Exp $	*/
d335 1
a335 1
	arc4random_bytes(&p->p_addr->u_pcb.pcb_wcookie,
@


1.108
log
@use arc4random_uniform() for random number requests that are not a
power of two.

use arc4random_bytes() when requesting more than a word of PRNG
output.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.107 2008/04/09 16:58:10 deraadt Exp $	*/
a189 1
u_long	_randseed;
@


1.107
log
@Add new stub uvm_shutdown() and call it from the right place in MD boot()
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.107 2008/04/09 16:50:30 deraadt Exp $	*/
d336 2
a337 2
	p->p_addr->u_pcb.pcb_wcookie = ((u_int64_t)arc4random() << 32) |
	    arc4random();
@


1.106
log
@Reintroduce the cputyp variable, and use it to distinguish between sun4u and
sun4v.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.105 2008/01/04 00:40:38 kettenis Exp $	*/
d730 2
@


1.105
log
@Prevent sign-extension when setting ASI in %tstate.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.104 2007/12/22 15:14:58 kettenis Exp $	*/
d468 1
a468 1
		return (sysctl_rdint(oldp, oldlenp, newp, CPU_SUN4U));
@


1.104
log
@Replace _bus_dmamap_load() with an implementation based on
_bus_dmamap_load_buffer() like everybode else does.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.103 2007/12/16 12:43:54 kettenis Exp $	*/
d381 2
a382 3
	tstate = (ASI_PRIMARY_NO_FAULT<<TSTATE_ASI_SHIFT) |
		((pstate)<<TSTATE_PSTATE_SHIFT) | 
		(tf->tf_tstate & TSTATE_CWP);
@


1.103
log
@Correctly count number of segments in _bus_dmamap_load().  Initialize ds_addr
to 0UL instead of NULL while there.

Tested by & help from dlg@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.102 2007/11/16 20:51:29 kettenis Exp $	*/
d139 3
d1109 2
a1110 3
	bus_size_t sgsize;
	vaddr_t vaddr = (vaddr_t)buf;
	int i;
d1115 1
d1119 1
a1119 3
		return (EFBIG);

	sgsize = round_page(buflen + ((int)vaddr & PGOFSET));
d1121 6
a1126 25
	/*
	 * We always use just one segment.
	 */
	map->dm_mapsize = buflen;
	i = 0;
	map->dm_segs[i].ds_addr = 0UL;
	map->dm_segs[i].ds_len = 0;
	while (sgsize > 0) {
		paddr_t pa;

		(void) pmap_extract(pmap_kernel(), vaddr, &pa);
		sgsize -= NBPG;
		vaddr += NBPG;
		if (map->dm_segs[i].ds_len == 0)
			map->dm_segs[i].ds_addr = pa;
		if (pa == (map->dm_segs[i].ds_addr + map->dm_segs[i].ds_len)
		    && ((map->dm_segs[i].ds_len + NBPG) < map->_dm_maxsegsz)) {
			/* Hey, waddyaknow, they're contiguous */
			map->dm_segs[i].ds_len += NBPG;
			continue;
		}
		if (++i > map->_dm_segcnt)
			return (EFBIG);
		map->dm_segs[i].ds_addr = pa;
		map->dm_segs[i].ds_len = NBPG;
d1128 1
a1128 5
	/* Is this what the above comment calls "one segment"? */
	map->dm_nsegs = i + 1;

	/* Mapping is bus dependent */
	return (0);
d1304 81
@


1.102
log
@Fix typo in comment.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.101 2007/10/31 22:46:52 kettenis Exp $	*/
d1125 1
a1125 1
	map->dm_segs[i].ds_addr = NULL;
d1127 1
a1127 1
	while (sgsize > 0 && i < map->_dm_segcnt) {
d1141 3
a1143 1
		map->dm_segs[++i].ds_addr = pa;
d1147 1
a1147 1
	map->dm_nsegs = i;
d1409 1
a1409 1
	segs[0].ds_addr = NULL; /* UPA does not map things */
@


1.101
log
@Overhaul fpu context save/restore code, making it more similar to what we do
on i386 and amd64.  Don't let IPIs in when saving fpu context by disabling
interrupts.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.100 2007/10/20 16:54:52 miod Exp $	*/
d449 1
a449 1
		 * If we were false and are now true, call start the timer.
@


1.100
log
@Make sure to send an ipi to the processor a given proc runs on in signotify(),
in the MULTIPROCESOR case.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.99 2007/10/16 20:33:27 kettenis Exp $	*/
a324 1
	struct fpstate64 *fs;
d381 1
a381 1
	if ((fs = p->p_md.md_fpstate) != NULL) {
d387 2
a388 2
		save_and_clear_fpstate(p);
		free((void *)fs, M_SUBPROC);
@


1.99
log
@Make lazy fpu context switching work for MULTIPROCESSOR kernels.  Tested by
many.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.98 2007/10/08 17:48:06 krw Exp $	*/
d680 3
a682 1
	/* XXX Send IPI if necessary. */
@


1.98
log
@A few trailing bzero/memset -> M_ZERO occurrences, cast removal and
size(*p) usage.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.97 2007/10/02 00:59:12 krw Exp $	*/
d388 1
a388 4
		if (p == fpproc) {
			savefpstate(fs);
			fpproc = NULL;
		}
@


1.97
log
@Apply (with slight variants) this elimination of bzero() with M_ZERO:

-	if ((mapstore = malloc(mapsize, M_DEVBUF,
-	    (flags & BUS_DMA_NOWAIT) ? M_NOWAIT : M_WAITOK)) == NULL)
+	if ((mapstore = malloc(mapsize, M_DEVBUF, (flags & BUS_DMA_NOWAIT) ?
+	    (M_NOWAIT | M_ZERO) : (M_WAITOK | M_ZERO))) == NULL)
 		return (ENOMEM);

-	bzero(mapstore, mapsize);
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.96 2007/09/08 17:13:18 kettenis Exp $	*/
d1812 1
a1812 1
	ih = (struct intrhand *)malloc(sizeof(struct intrhand), M_DEVBUF, M_NOWAIT);
a1814 2

	memset(ih, 0, sizeof(struct intrhand));
@


1.96
log
@Make the ast on sparc64 per-process instead of global.  Necessary to make
signal delivery more reliable once we go smp (although the code for that
is still missing).

"in principle, this looks good" art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.95 2007/09/03 01:09:09 krw Exp $	*/
d1047 2
a1048 2
	if ((mapstore = malloc(mapsize, M_DEVBUF,
	    (flags & BUS_DMA_NOWAIT) ? M_NOWAIT : M_WAITOK)) == NULL)
a1050 1
	bzero(mapstore, mapsize);
@


1.95
log
@Typos from miod. 'functin' -> 'functin' in some comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.94 2007/08/25 19:05:56 kettenis Exp $	*/
d672 13
@


1.94
log
@Fix printing of more than 2G of memory.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.93 2007/08/04 16:44:15 kettenis Exp $	*/
d1509 1
a1509 1
 * Common functin for mmap(2)'ing DMA-safe memory.  May be called by
@


1.93
log
@Add sparc_bus_addr member to struct sparc_bus_space_tag.  This function maps
a bus_space_handle_t back to a bus_addr_t.  Needed for rbus.
Only implemented for mainbus(4) and psycho(4) for now; schizo(4) and pyro(4)
will follow soon.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.92 2007/07/22 21:33:04 kettenis Exp $	*/
d249 2
a250 2
	printf("real mem = %lu (%luMB)\n", ctob(physmem),
	    ctob(physmem)/1024/1024);
d279 2
a280 2
	printf("avail mem = %lu (%luMB)\n", ptoa(uvmexp.free),
	    ptoa(uvmexp.free)/1024/1024);
@


1.92
log
@Get rid of the fixe VA range for device mappings; use uvm_km_valloc() instead.
This allows mappings of more than 256MB, needed by some frame buffers.

"looks good", miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.91 2007/06/06 17:15:13 deraadt Exp $	*/
d1573 2
d1779 13
d1890 2
a1891 1
	sparc_mainbus_intr_establish	/* bus_intr_establish */
@


1.91
log
@now that all partition size/offsets are potentially 64-bit, change the
type of all variables to daddr64_t.  this includes the APIs for XXsize()
and XXdump(), all range checks inside bio drivers, internal variables
for disklabel handling, and even uvm's swap offsets.  re-read numerous
times by otto, miod, krw, thib to look for errors
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.90 2007/05/29 20:36:48 deraadt Exp $	*/
a1586 3
vaddr_t iobase = IODEV_BASE;
struct extent *io_space = NULL;

d1591 1
a1591 1
	vaddr_t v;
a1600 10
	if (iobase == NULL)
		iobase = IODEV_BASE;
	if (io_space == NULL)
		/*
		 * And set up IOSPACE extents.
		 */
		io_space = extent_create("IOSPACE",
		    (u_long)IODEV_BASE, (u_long)IODEV_END, M_DEVBUF, 0, 0,
		    EX_NOWAIT);

d1646 3
a1648 7
	{ /* scope */
		int err = extent_alloc(io_space, size, NBPG, 0, 0,
		    EX_NOWAIT | EX_BOUNDZERO, (u_long *)&v);
		if (err)
			panic("sparc_bus_map: cannot allocate io_space: %d",
			    err);
	}
d1651 1
a1651 1
	hp->bh_ptr = v | ((u_long)addr & PGOFSET);
d1653 1
a1653 1
	pa = addr & ~PAGE_MASK; /* = trunc_page(addr); Will drop high bits */
d1673 1
a1673 1
		pmap_enter(pmap_kernel(), v, pa | pm_flags, pm_prot,
d1675 1
a1675 1
		v += PAGE_SIZE;
a1752 1
	int error;
d1757 3
a1759 3
	error = extent_free(io_space, va, size, EX_NOWAIT);
	if (error)
		printf("\nsparc_bus_unmap: extent free says %d", error);
a1760 1
	pmap_remove(pmap_kernel(), va, endva);
@


1.90
log
@start of dumpconf() unification, which one day we can pray will be MI
(and part of setroot); ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.89 2007/05/26 20:26:51 pedro Exp $	*/
d825 2
a826 2
	daddr_t blkno;
	int (*dump)(dev_t, daddr_t, caddr_t, size_t);
d867 1
a867 1
printf("starting dump, blkno %d\n", blkno);
@


1.89
log
@Dynamic buffer cache. Initial diff from mickey@@, okay art@@ beck@@ toby@@
deraadt@@ dlg@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.88 2007/05/23 20:33:47 pvalchev Exp $	*/
d777 1
a777 1
dumpconf()
d781 4
a784 2
	if (dumpdev == NODEV || bdevsw[major(dumpdev)].d_psize == 0)
		/* No usable dump device */
a785 2

	nblks = (*bdevsw[major(dumpdev)].d_psize)(dumpdev);
@


1.88
log
@Print real/available memory in MB as well as bytes in dmesg, and unify
architectures to print it the same way.
ok henning, miod; i386 part from tom
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.87 2007/03/31 22:16:48 deraadt Exp $	*/
a174 6
#ifdef	NBUF
int	nbuf = NBUF;
#else
int	nbuf = 0;
#endif

d176 1
a176 1
#define BUFCACHEPERCENT 5
a228 1
	unsigned i;
a230 1
	int base, residual;
a235 1
	vsize_t size;
d261 6
a266 46
        /*
         * allocate virtual and physical memory for the buffers.
         */
        size = MAXBSIZE * nbuf;         /* # bytes for buffers */

        /* allocate VM for buffers... area is not managed by VM system */
        if (uvm_map(kernel_map, (vaddr_t *) &buffers, round_page(size),
                    NULL, UVM_UNKNOWN_OFFSET, 0,
                    UVM_MAPFLAG(UVM_PROT_NONE, UVM_PROT_NONE, UVM_INH_NONE,
                                UVM_ADV_NORMAL, 0)) != 0)
        	panic("cpu_startup: cannot allocate VM for buffers");

        minaddr = (vaddr_t) buffers;
        if ((bufpages / nbuf) >= btoc(MAXBSIZE)) {
        	bufpages = btoc(MAXBSIZE) * nbuf; /* do not overallocate RAM */
        }
        base = bufpages / nbuf;
        residual = bufpages % nbuf;

        /* now allocate RAM for buffers */
	for (i = 0 ; i < nbuf ; i++) {
		vaddr_t curbuf;
		vsize_t curbufsize;
		struct vm_page *pg;

		/*
		 * each buffer has MAXBSIZE bytes of VM space allocated.  of
		 * that MAXBSIZE space we allocate and map (base+1) pages
		 * for the first "residual" buffers, and then we allocate
		 * "base" pages for the rest.
		 */
		curbuf = (vaddr_t) buffers + (i * MAXBSIZE);
		curbufsize = NBPG * ((i < residual) ? (base+1) : base);

		while (curbufsize) {
			pg = uvm_pagealloc(NULL, 0, NULL, 0);
			if (pg == NULL)
				panic("cpu_startup: "
				    "not enough RAM for buffer cache");
			pmap_kenter_pa(curbuf,
			    VM_PAGE_TO_PHYS(pg), VM_PROT_READ|VM_PROT_WRITE);
			curbuf += PAGE_SIZE;
			curbufsize -= PAGE_SIZE;
		}
	}
	pmap_update(pmap_kernel());
a280 2
	printf("using %d buffers containing %ld bytes of memory\n", nbuf,
		(long)bufpages * PAGE_SIZE);
a302 24

        /*
	 * Determine how many buffers to allocate (enough to
	 * hold 5% of total physical memory, but at least 16).
	 * Allocate 1/2 as many swap buffer headers as file i/o buffers.
	 */
	 if (bufpages == 0)
	 	bufpages = physmem * bufcachepercent / 100;
	 if (nbuf == 0) {
	 	nbuf = bufpages;
		if (nbuf < 16)
			nbuf = 16;
	}
	/* Restrict to at most 30% filled kvm */
	if (nbuf * MAXBSIZE >
	    (KERNEND - KERNBASE) * 3 / 10)
		nbuf = (KERNEND - KERNBASE) /
		    MAXBSIZE * 3 / 10;

	/* More buffer pages than fits into the buffers is senseless.  */
	if (bufpages > nbuf * MAXBSIZE / PAGE_SIZE)
		bufpages = nbuf * MAXBSIZE / PAGE_SIZE;

	valloc(buf, struct buf, nbuf);
@


1.87
log
@do nbuf constraint based on KERNEND/KERNBASE to avoid integer overflow from new giant sparc64 kvm; ok kettenis, tested by pooleb
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.86 2006/12/30 16:25:41 kettenis Exp $	*/
d258 2
a259 1
	printf("total memory = %ld\n", (long)physmem * PAGE_SIZE);
d328 2
a329 1
	printf("avail memory = %ld\n", (long)uvmexp.free * PAGE_SIZE);
@


1.86
log
@Save pcb in dumppcb when dumping core.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.85 2006/11/19 16:49:22 miod Exp $	*/
d367 2
a368 2
	    (VM_MAX_KERNEL_ADDRESS - VM_MIN_KERNEL_ADDRESS) * 3 / 10)
		nbuf = (VM_MAX_KERNEL_ADDRESS - VM_MIN_KERNEL_ADDRESS) /
@


1.85
log
@In sigreturn, report the correct error if copyin() fails; spotted by
Alexey Dobriyan, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.84 2006/09/22 19:16:07 miod Exp $	*/
d748 1
d905 1
a905 1
	snapshot(cpcb);
@


1.84
log
@Dump memory above 4GB correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.83 2006/06/21 21:53:32 jason Exp $	*/
d703 1
a703 1
	    (error = copyin((caddr_t)scp, &sc, sizeof sc) != 0)) {
@


1.83
log
@add the machdep.kbdreset logic to sparc64 (stuff to use it is coming)
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.82 2006/06/07 19:13:08 miod Exp $	*/
d941 1
a941 1
		unsigned i = 0, n;
d956 1
a956 1
				 n = BYTES_PER_DUMP;
@


1.82
log
@Remove unused bus_space_probe().
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.81 2006/03/15 21:03:39 deraadt Exp $	*/
d197 1
d548 4
@


1.81
log
@use sysctl_int_lower() for the aperture variable.  This lets root close
the aperture without having to reboot, but does not allow re-opening;
ok matthieu
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.80 2006/01/02 18:19:41 miod Exp $	*/
a1860 21
}

/*
 * Establish a temporary bus mapping for device probing.  */
int
bus_space_probe(bus_space_tag_t tag, bus_addr_t paddr, bus_size_t size,
    size_t offset, int flags, int (*callback)(void *, void *), void *arg)
{
	bus_space_handle_t bh;
	paddr_t tmp;
	int result;

	if (bus_space_map(tag, paddr, size, flags, &bh) != 0)
		return (0);

	tmp = bh.bh_ptr;
	result = (probeget(tmp + offset, tag->asi, size) != -1);
	if (result && callback != NULL)
		result = (*callback)((char *)(u_long)tmp, arg);
	bus_space_unmap(tag, bh, size);
	return (result);
@


1.80
log
@Remove orphaned cpu_exec_aout_makecmds() since we don't _KERN_DO_AOUT.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.79 2005/11/24 22:30:08 miod Exp $	*/
d533 2
a534 2
			return (sysctl_rdint(oldp, oldlenp, newp,
			    allowaperture));
@


1.79
log
@Remove unnecessary cast in an atop() construct.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.78 2005/11/11 16:50:21 miod Exp $	*/
a1067 8

int
cpu_exec_aout_makecmds(p, epp)
	struct proc *p;
	struct exec_package *epp;
{
	return (ENOEXEC);
}
@


1.78
log
@Remove machdep.booted_kernel sysctl of questionable usefulness.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.77 2005/10/24 19:07:40 martin Exp $	*/
d1612 1
a1612 1
		return (atop((caddr_t)segs[i].ds_addr + off));
@


1.77
log
@Mach-macro free
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.76 2005/07/09 22:51:13 robert Exp $	*/
a513 3
	u_int chosen;
	char bootargs[256];
	char *cp = NULL;
a519 26
	case CPU_BOOTED_KERNEL:
		if (((chosen = OF_finddevice("/chosen")) != -1) &&
		    ((OF_getprop(chosen, "bootargs", bootargs, sizeof bootargs))
		      >= 0)) {
			/*
			 * bootargs is of the form: [kernelname] [args...]
			 * It can be the empty string if we booted from the
			 * default kernel name.
			 */
			for (cp = bootargs; 
			     *cp && *cp != ' ' && *cp != '\t' && *cp != '\n';
			     cp++);
			*cp = 0;
			/* Now we've separated the kernel name from the args */
			cp = bootargs;
			if (*cp == 0 || *cp == '-') 
				/*
				 * We can leave it NULL && let userland handle
				 * the failure or set it to the default name,
				 * `bsd' 
				 */
				cp = "bsd";
		}
		if (cp == NULL || cp[0] == '\0')
			return (ENOENT);
		return (sysctl_rdstring(oldp, oldlenp, newp, cp));
@


1.76
log
@Implement _bus_dmamem_mmap instead of just calling panic();
This is needed by bktr(4).

ok mickey@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.75 2005/03/29 19:34:07 kettenis Exp $	*/
d1641 1
a1641 1
		return (sparc64_btop((caddr_t)segs[i].ds_addr + off));
@


1.75
log
@sparc64 StackGhost.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.74 2004/11/02 21:20:59 miod Exp $	*/
d1624 1
d1626 20
a1645 1
	panic("_bus_dmamem_mmap: not implemented");
a1646 1

@


1.74
log
@Remove __HAVE_NWSCONS and related remnants of pre-wscons days; no functional
change.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.73 2004/10/01 18:18:49 jason Exp $	*/
d105 1
d401 22
@


1.73
log
@add a blink_led API (shaves ~1k from GENERIC) rather than have the same
logic in 3 files.  Devices register a function to be called to turn the
led on and off based on load average. (Note: rerun config and make depend)
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.72 2004/09/28 02:06:36 jason Exp $	*/
a225 15

#if (NPCKBC > 0) && (NPCKBD == 0)
/*
 * This is called by the pckbc driver if no pckbd is configured.
 * On the i386, it is used to glue in the old, deprecated console
 * code.  On the sparc64, it does nothing.
 */
int
pckbc_machdep_cnattach(kbctag, kbcslot)
	pckbc_tag_t kbctag;
	pckbc_slot_t kbcslot;
{
	return (ENXIO);
}
#endif
@


1.72
log
@driver for "clock-board" (mainly blinky lights, but also has information about the chassis)
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.71 2004/09/27 21:12:40 jason Exp $	*/
a80 4
#include "auxio.h"
#include "fhc.h"
#include "clkbrd.h"

a194 1
#if (NAUXIO > 0) || (NFHC > 0) || (NCLKBRD > 0)
a195 13
#endif

#if NAUXIO > 0
#include <sparc64/dev/auxiovar.h>
#endif

#if NFHC > 0
#include <sparc64/dev/fhcvar.h>
#endif

#if NCLKBRD > 0
#include <sparc64/dev/clkbrdvar.h>
#endif
d222 1
a504 1
#if NAUXIO > 0
a505 1
#endif
a541 1
#if (NAUXIO > 0) || (NFHC > 0) || (NCLKBRD > 0)
a544 1

d546 1
a546 2
		 * If we were false and are now true, call auxio_led_blink().
		 * auxio_led_blink() will catch the other case itself.
d548 2
a549 11
		if (!oldval && sparc_led_blink > oldval) {
#if NAUXIO > 0
			auxio_led_blink(NULL);
#endif
#if NFHC > 0
			fhc_led_blink(NULL);
#endif
#if NCLKBRD > 0
			clkbrd_led_blink(NULL);
#endif
		}
a550 3
#else
		return (EOPNOTSUPP);
#endif
d2223 47
@


1.71
log
@Important stuff: blinky lights for fhc
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.70 2004/08/02 21:40:46 brad Exp $	*/
d83 1
d199 1
a199 1
#if (NAUXIO > 0) || (NFHC > 0)
d211 4
d561 1
a561 1
#if NAUXIO > 0
d570 2
a571 1
		if (!oldval && sparc_led_blink > oldval)
d573 8
@


1.70
log
@_bus_dmamap_load_mbuf: check and process pmap_extract failure.

From NetBSD

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.69 2004/06/28 01:47:41 aaron Exp $	*/
d82 1
d198 4
d204 4
a207 1
int sparc_led_blink;
@


1.69
log
@Use new event counter API for interrupt counting on sparc64.  deraadt@@ tholo@@
drahn@@ millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.68 2004/06/23 04:40:05 aaron Exp $	*/
d1288 11
a1298 1
			(void) pmap_extract(pmap_kernel(), vaddr, &pa);
@


1.68
log
@Fix one-byte overflow in interrupt handling allocator.  henning@@, miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.67 2004/03/10 23:02:54 tom Exp $	*/
a1902 1
	size_t namelen = strlen(what) + 1;
d1904 1
a1904 2
	ih = (struct intrhand *)
		malloc(sizeof(struct intrhand) + namelen - 1, M_DEVBUF, M_NOWAIT);
d1908 1
a1908 1
	memset(ih, 0, sizeof(struct intrhand) + namelen - 1);
d1917 1
a1917 1
	strlcpy(ih->ih_name, what, namelen);
@


1.67
log
@Ensure that we obey a user's ddb> boot reboot command even if the system
is cold (during startup).

This adds RB_USERREQ to sys/reboot.h, uses it in the ddb commands, and
ensures that */*/machdep.c:boot() won't set RB_HALT when cold if this
flag is set.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.66 2004/02/19 18:46:18 miod Exp $	*/
d1910 1
a1910 1
	memset(ih, 0, sizeof(struct intrhand) + namelen);
@


1.66
log
@Kill <sys/clist.h> - nothing uses it since years.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.65 2003/06/24 21:54:39 henric Exp $	*/
d786 3
a788 1
		howto |= RB_HALT;
@


1.65
log
@Add a "where" argument to the sparc64 interrupt code.  This lets us
associate a name with each interrupt handler.  This is not visible
outside the kernel (yet).

ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.64 2003/06/16 20:46:14 miod Exp $	*/
a95 1
#include <sys/clist.h>
@


1.64
log
@Provide the same fbxxx() api as on sparc, in order to factorize more code
and eventually share some drivers.
This also brings us screen unblanking upon entering ddb, which can be really
useful at times...
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.63 2003/06/06 11:17:48 henric Exp $	*/
d1656 1
a1656 1
    int, int (*)(void *), void *);
a1894 1

d1896 4
a1899 2
sparc_mainbus_intr_establish(bus_space_tag_t t, bus_space_tag_t t0, int	pil,
    int level, int flags, int (*handler)(void *), void *arg)
d1902 1
d1905 1
a1905 1
		malloc(sizeof(struct intrhand), M_DEVBUF, M_NOWAIT);
d1909 2
d1913 28
a1940 1
	intr_establish(pil, ih);
d2148 1
a2148 1
    void *a)
d2154 1
a2154 1
	ret = _BS_CALL(t, sparc_intr_establish)(t, t0, p, l, f, h, a);
@


1.63
log
@There is no point in flushing the data cache all the time.  It just creates
a lot of useless ecache traffic.

testing by many
ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.62 2003/06/02 23:27:56 millert Exp $	*/
a790 1
#if NFB > 0
a791 1
#endif
@


1.62
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.61 2003/06/02 18:14:16 jason Exp $	*/
a1423 24
	int i;
	struct vm_page *m;
	struct pglist *mlist;
	paddr_t pa;

	for (i = 0; i < map->dm_nsegs; i++) {
		if ((mlist = map->dm_segs[i]._ds_mlist) == NULL) {
			/* 
			 * We were asked to load random VAs and lost the 
			 * PA info so just blow the entire cache away.
			 */
			blast_vcache();
			break;
		}
		for (m = TAILQ_FIRST(mlist); m != NULL;
		     m = TAILQ_NEXT(m,pageq)) {
			pa = VM_PAGE_TO_PHYS(m);
			/* 
			 * We should be flushing a subrange, but we
			 * don't know where the segments starts.
			 */
			dcache_flush_page(pa);
		}
	}
d1442 2
a1443 43
	int i;
	struct vm_page *m;
	struct pglist *mlist;

	/*
	 * We sync out our caches, but the bus must do the same.
	 *
	 * Actually a #Sync is expensive.  We should optimize.
	 */
	if ((ops & BUS_DMASYNC_PREREAD) || (ops & BUS_DMASYNC_PREWRITE)) {
		/* 
		 * Don't really need to do anything, but flush any pending
		 * writes anyway. 
		 */
		membar(Sync);
	}
	if (ops & BUS_DMASYNC_POSTREAD) {
		/* Invalidate the vcache */
		for (i=0; i<map->dm_nsegs; i++) {
			if ((mlist = map->dm_segs[i]._ds_mlist) == NULL)
				/* Should not really happen. */
				continue;
			for (m = TAILQ_FIRST(mlist);
			     m != NULL; m = TAILQ_NEXT(m,pageq)) {
				paddr_t start;
				psize_t size = NBPG;

				if (offset < NBPG) {
					start = VM_PAGE_TO_PHYS(m) + offset;
					size = NBPG;
					if (size > len)
						size = len;
					cache_flush_phys(start, size, 0);
					len -= size;
					continue;
				}
				offset -= size;
			}
		}
	}
	if (ops & BUS_DMASYNC_POSTWRITE) {
		/* Nothing to do.  Handled by the bus controller. */
	}
@


1.61
log
@add length checks on bus_dmamap_load_uio() on the total length vs. what the
map is expecting.  Also, sparc64 was missing the equivalent check in
_load_mbuf() and the "make sure no valid mappings are returned" goop.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.60 2003/06/01 17:43:50 art Exp $	*/
d62 1
a62 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.60
log
@initialize minaddr before calling uvm_km_suballoc.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.59 2003/03/21 22:59:10 jason Exp $	*/
d1268 9
d1343 9
@


1.59
log
@install a real handler for correctable ECC errors and make a count of
them available via sysctl (doc update in a bit); ok millert.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.58 2003/03/06 08:26:08 henric Exp $	*/
d342 3
a344 2
        exec_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
                                 16*NCARGS, VM_MAP_PAGEABLE, FALSE, NULL);
@


1.58
log
@The existing IOMMU code had a rounding problem that was most noticeable
on faster systems under heavy network load.  This replaces some of the
unreadable iommu functions with something a little less dense and a lot
less crash prone.

The bus_dma function pointer/cookie handling was broken.  Change them
to work like the stacked bus_space drivers (where "work" is the key
word).

Tested my many (thanks).

ok jason@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.57 2003/02/24 01:00:52 miod Exp $	*/
d215 3
d580 4
@


1.57
log
@Prefer pmap_kenter_pa() rather than pmap_enter() for the buffers.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.56 2003/02/22 22:50:34 jason Exp $	*/
d134 40
a173 2
/* This may be used by macros elsewhere. */
int bus_space_debug = BSDB_ACCESS | BSDB_ASSERT | BSDB_MAP;
d1074 2
a1075 1
			printf("%llx(%llx, %llx, %llx, %llx, %llx, %llx, %llx) fp = %llx\n",
d1088 5
a1092 4
			printf("  pc = %x  args = (%x, %x, %x, %x, %x, %x, %x) fp = %x\n",
			       fp->fr_pc, fp->fr_arg[0], fp->fr_arg[1], fp->fr_arg[2],
			       fp->fr_arg[3], fp->fr_arg[4], fp->fr_arg[5], fp->fr_arg[6],
			       fp->fr_fp);
d1112 2
a1113 2
_bus_dmamap_create(t, size, nsegments, maxsegsz, boundary, flags, dmamp)
	bus_dma_tag_t t;
d1149 2
a1150 2
	map->_dm_flags = flags & ~(BUS_DMA_WAITOK|BUS_DMA_NOWAIT|BUS_DMA_COHERENT|
				   BUS_DMA_NOWRITE|BUS_DMA_NOCACHE);
d1163 2
a1164 2
_bus_dmamap_destroy(t, map)
	bus_dma_tag_t t;
d1166 1
d1168 10
d1193 2
a1194 2
_bus_dmamap_load(t, map, buf, buflen, p, flags)
	bus_dma_tag_t t;
d1239 1
d1241 1
d1250 2
a1251 2
_bus_dmamap_load_mbuf(t, map, m, flags)
	bus_dma_tag_t t;
d1262 1
a1262 1
	map->_dm_source = (void *)m;
d1280 3
a1282 2
			if (i > 0 && pa == (segs[i-1].ds_addr + segs[i-1].ds_len)
			    && ((segs[i-1].ds_len + incr) < map->_dm_maxsegsz)) {
d1284 1
a1284 1
				segs[i-1].ds_len += incr;
d1303 1
a1303 1
	return (bus_dmamap_load_raw(t, map, segs, i,
d1311 2
a1312 2
_bus_dmamap_load_uio(t, map, uio, flags)
	bus_dma_tag_t t;
d1350 3
a1352 2
			if (i > 0 && pa == (segs[i-1].ds_addr + segs[i-1].ds_len)
			    && ((segs[i-1].ds_len + incr) < map->_dm_maxsegsz)) {
d1354 1
a1354 1
				segs[i-1].ds_len += incr;
d1373 1
a1373 1
	return (bus_dmamap_load_raw(t, map, segs, i, (bus_size_t)len, flags));
d1381 2
a1382 2
_bus_dmamap_load_raw(t, map, segs, nsegs, size, flags)
	bus_dma_tag_t t;
d1398 2
a1399 2
_bus_dmamap_unload(t, map)
	bus_dma_tag_t t;
d1407 1
a1407 1
	for (i=0; i<map->dm_nsegs; i++) {
d1437 2
a1438 2
_bus_dmamap_sync(t, map, offset, len, ops)
	bus_dma_tag_t t;
d1495 2
a1496 2
_bus_dmamem_alloc(t, size, alignment, boundary, segs, nsegs, rsegs, flags)
	bus_dma_tag_t t;
d1561 2
a1562 2
_bus_dmamem_free(t, segs, nsegs)
	bus_dma_tag_t t;
d1582 2
a1583 2
_bus_dmamem_map(t, segs, nsegs, size, kvap, flags)
	bus_dma_tag_t t;
a1590 1
	struct pglist *mlist;
a1625 1
	mlist = segs[0]._ds_mlist;
d1635 2
a1636 2
_bus_dmamem_unmap(t, kva, size)
	bus_dma_tag_t t;
d1655 2
a1656 2
_bus_dmamem_mmap(t, segs, nsegs, off, prot, flags)
	bus_dma_tag_t t;
d1736 1
a1736 1
	size = round_page(size);
d1773 2
@


1.56
log
@check for a NULL tag in bus_space_render_tag() so that other debug code doesn't crash.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.55 2003/02/17 01:29:20 henric Exp $	*/
d289 2
a290 3
			pmap_enter(kernel_map->pmap, curbuf,
			    VM_PAGE_TO_PHYS(pg), VM_PROT_READ|VM_PROT_WRITE,
			    VM_PROT_READ|VM_PROT_WRITE|PMAP_WIRED);
@


1.55
log
@
Add support for the Sun Enterprise 450
Reduce the size of a GENERIC kernel by ~190k
Remove the nasty pointer/bus_space_handle_t casts
Adds debug bus_space code including the ability to trace
    bus operations (it actually works now).

The following rules are now followed (and verfified by the debug
code):

1.  A "bus_space_handle_t" may only be used with the
    "bus_space_tag_t" that created it.
2.  Only "bus_space_map()" may create "bus_space_handle_t"s.
3.  A "bus_space_handle_t" may not be modified after it has
    been created (other than being destroyed by "bus_space_unmap()").


Thanks to help from mcbride, marc, jason, drahn, to anyone that might
have slipped my mind at the moment.

ok jason@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.54 2002/12/17 23:11:32 millert Exp $	*/
d2142 4
@


1.54
log
@Make SysV-style shared memory and semaphore limits sysctl'able.
Instead of allocating a static amount of memory for the data
structures via valloc() in allocsys(), allocate things dynamically
using pool(9) when possible and malloc(9) when not.  The various
members of struct seminfo and struct shminfo are in kern.seminfo
and kern.shminfo respectively (not all members of kern.seminfo are
changable).

The data structures used still leave something to be desired but
things are not made worse in that respect by this commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.53 2002/11/03 01:59:28 miod Exp $	*/
d134 2
a135 8
/* #include "fb.h" */

int bus_space_debug = 0; /* This may be used by macros elsewhere. */
#ifdef DEBUG
#define DPRINTF(l, s)   do { if (bus_space_debug & l) printf s; } while (0)
#else
#define DPRINTF(l, s)
#endif
a194 48
/* 
 * This is the table that tells us how to access different bus space types.
 */ 
#define BUS_BYPASS_ACCESS_ENABLED 0
#if BUS_BYPASS_ACCESS_ENABLED == 1
/*
 * Bypass access 
 */
int bus_type_asi[] = {
	ASI_PHYS_NON_CACHED,			/* UPA */
	ASI_PHYS_NON_CACHED,			/* SBUS */
	ASI_PHYS_NON_CACHED_LITTLE,		/* PCI configuration space */
	ASI_PHYS_NON_CACHED_LITTLE,		/* PCI memory space */
	ASI_PHYS_NON_CACHED_LITTLE,		/* PCI I/O space */
	0
};

int bus_stream_asi[] = {
	ASI_PHYS_NON_CACHED,			/* UPA */
	ASI_PHYS_NON_CACHED,			/* SBUS */
	ASI_PHYS_NON_CACHED,			/* PCI configuration space */
	ASI_PHYS_NON_CACHED,			/* PCI memory space */
	ASI_PHYS_NON_CACHED,			/* PCI I/O space */
	0
};
#else
/*
 * MMU access - we want to use the MMU for all this..
 */
int bus_type_asi[] = {
	ASI_PRIMARY,				/* UPA */
	ASI_PRIMARY,				/* SBUS */
	ASI_PHYS_NON_CACHED_LITTLE,		/* PCI configuration space */
	ASI_PRIMARY,				/* PCI memory space */
	ASI_PRIMARY,				/* PCI I/O space */
	0
};

int bus_stream_asi[] = {
	ASI_PRIMARY,				/* UPA */
	ASI_PRIMARY,				/* SBUS */
	ASI_PHYS_NON_CACHED,			/* PCI configuration space */
	ASI_PRIMARY_LITTLE,			/* PCI memory space */
	ASI_PRIMARY_LITTLE,			/* PCI I/O space */
	0
};
#endif

a239 1

d348 2
a349 2
	    (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) * 3 / 10)
		nbuf = (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) /
d491 2
a492 2
			 * It can be the empty string if we booted from the default
			 * kernel name.
d498 1
a498 1
			/* Now we've separated out the kernel name from the args */
d631 2
a632 1
		printf("sendsig: stack was trashed trying to send sig %d, sending SIGILL\n", sig);
d668 1
a668 1
	register struct proc *p;
d676 1
a676 1
	register struct trapframe64 *tf;
d684 2
a685 1
		printf("sigreturn: rwindow_save(%p) failed, sending SIGILL\n", p);
d884 1
a884 1
	register int psize;
d886 1
a886 1
	register int (*dump)(dev_t, daddr_t, caddr_t, size_t);
d888 1
a888 1
	register struct mem_region *mp;
d1404 1
a1404 1
		__asm("membar #Sync" : );
d1638 19
a1656 19
static int	sparc_bus_map( bus_space_tag_t, bus_type_t, bus_addr_t,
				    bus_size_t, int, vaddr_t,
				    bus_space_handle_t *);
static int	sparc_bus_unmap(bus_space_tag_t, bus_space_handle_t,
				     bus_size_t);
static int	sparc_bus_subregion(bus_space_tag_t, bus_space_handle_t,
					 bus_size_t, bus_size_t,
					 bus_space_handle_t *);
static paddr_t	sparc_bus_mmap(bus_space_tag_t, bus_addr_t, off_t, int, int);
static void	*sparc_mainbus_intr_establish(bus_space_tag_t, int, int,
						   int, int (*)(void *),
						   void *);
static void	sparc_bus_barrier(bus_space_tag_t, bus_space_handle_t,
					  bus_size_t, bus_size_t, int);
static int	sparc_bus_alloc(bus_space_tag_t, bus_addr_t, bus_addr_t,
					bus_size_t, bus_size_t, bus_size_t, int,
					bus_addr_t *, bus_space_handle_t *);
static void	sparc_bus_free(bus_space_tag_t, bus_space_handle_t,
				       bus_size_t);
d1662 2
a1663 7
sparc_bus_map(t, iospace, addr, size, flags, vaddr, hp)
	bus_space_tag_t t;
	bus_type_t	iospace;
	bus_addr_t	addr;
	bus_size_t	size;
	vaddr_t	vaddr;
	bus_space_handle_t *hp;
d1670 5
a1674 1
	t->type = iospace;
d1682 2
a1683 4
					 (u_long)IODEV_BASE, (u_long)IODEV_END,
					 M_DEVBUF, 0, 0, EX_NOWAIT);


d1686 3
a1688 1
		printf("sparc_bus_map: zero size\n");
d1691 29
a1719 22
	switch (iospace) {
	case PCI_CONFIG_BUS_SPACE:
		/* 
		 * PCI config space is special.
		 *
		 * It's really big and seldom used.  In order not to run
		 * out of IO mappings, config space will not be mapped in,
		 * rather it will be accessed through MMU bypass ASI accesses.
		 */
		if (flags & BUS_SPACE_MAP_LINEAR) return (-1);
		*hp = (bus_space_handle_t)addr;
		if (!vaddr) return (0);
		/* FALLTHROUGH */
	case PCI_IO_BUS_SPACE:
		pm_flags = PMAP_LITTLE;
		break;
	case PCI_MEMORY_BUS_SPACE:
		pm_flags = PMAP_LITTLE;
		break;
	default:
		pm_flags = 0;
		break;
d1722 5
a1726 1
	if (!(flags & BUS_SPACE_MAP_CACHEABLE)) pm_flags |= PMAP_NC;
d1728 6
a1733 8
	if (vaddr)
		v = trunc_page(vaddr);
	else {
		int err;
		if ((err = extent_alloc(io_space, size, NBPG,
					0, 0, EX_NOWAIT|EX_BOUNDZERO, 
					(u_long *)&v)))
			panic("sparc_bus_map: cannot allocate io_space: %d", err);
d1737 1
a1737 1
	*hp = (bus_space_handle_t)(v | ((u_long)addr & PGOFSET));
d1740 2
a1741 1
	if (!(flags&BUS_SPACE_MAP_READONLY)) pm_prot |= VM_PROT_WRITE;
d1743 11
a1753 5
	DPRINTF(BSDB_MAP, ("\nsparc_bus_map: type %x flags %x "
		"addr %016llx size %016llx virt %llx paddr %016llx\n",
		(int)iospace, (int) flags, (unsigned long long)addr,
		(unsigned long long)size, (unsigned long long)*hp,
		(unsigned long long)pa));
d1756 3
a1758 3
		DPRINTF(BSDB_MAP, ("sparc_bus_map: phys %llx virt %p hp %llx\n", 
			(unsigned long long)pa, (char *)v,
			(unsigned long long)*hp));
d1769 25
a1793 6
sparc_bus_subregion(tag, handle, offset, size, nhandlep)
	bus_space_tag_t		tag;
	bus_space_handle_t	handle;
	bus_size_t		offset;
	bus_size_t		size;
	bus_space_handle_t	*nhandlep;
d1795 35
a1829 1
	*nhandlep = handle + offset;
d1834 2
a1835 4
sparc_bus_unmap(t, bh, size)
	bus_space_tag_t t;
	bus_size_t	size;
	bus_space_handle_t bh;
d1837 1
a1837 1
	vaddr_t va = trunc_page((vaddr_t)bh);
d1839 1
d1841 6
a1846 2
	int error = extent_free(io_space, va, size, EX_NOWAIT);
	if (error) printf("sparc_bus_unmap: extent free says %d\n", error);
d1853 2
a1854 6
sparc_bus_mmap(t, paddr, off, prot, flags)
	bus_space_tag_t t;
	bus_addr_t paddr;
	off_t off;
	int prot;
	int flags;
d1856 5
d1862 1
a1862 1
	return ((paddr+off)|PMAP_NC);
d1868 2
a1869 9
bus_space_probe(tag, btype, paddr, size, offset, flags, callback, arg)
	bus_space_tag_t tag;
	bus_type_t	btype;
	bus_addr_t	paddr;
	bus_size_t	size;
	size_t		offset;
	int		flags;
	int		(*callback)(void *, void *);
	void		*arg;
d1875 1
a1875 1
	if (bus_space_map2(tag, btype, paddr, size, flags, NULL, &bh) != 0)
d1878 2
a1879 2
	tmp = (paddr_t)bh;
	result = (probeget(tmp + offset, bus_type_asi[tag->type], size) != -1);
d1888 2
a1889 7
sparc_mainbus_intr_establish(t, pil, level, flags, handler, arg)
	bus_space_tag_t t;
	int	pil;
	int	level;
	int	flags;
	int	(*handler)(void *);
	void	*arg;
d1905 2
a1906 6
sparc_bus_barrier (t, h, offset, size, flags)
	bus_space_tag_t	t;
	bus_space_handle_t h;
	bus_size_t	offset;
	bus_size_t	size;
	int		flags;
d1915 1
a1915 1
		__asm("membar #Sync" : );
d1917 1
a1917 1
		__asm("membar #Sync" : );
d1919 1
a1919 1
		__asm("membar #Sync" : );
d1926 3
a1928 10
sparc_bus_alloc(t, rs, re, s, a, b, f, ap, hp)
	bus_space_tag_t	t;
	bus_addr_t	rs;
	bus_addr_t	re;
	bus_size_t	s;
	bus_size_t	a;
	bus_size_t	b;
	int		f;
	bus_addr_t	*ap;
	bus_space_handle_t *hp;
d1934 2
a1935 4
sparc_bus_free(t, h, s)
	bus_space_tag_t	t;
	bus_space_handle_t	h;
	bus_size_t	s;
d1940 1
a1940 2

struct sparc_bus_space_tag mainbus_space_tag = {
d1944 3
d1950 1
d1957 1
d1962 220
@


1.53
log
@Missing word in buffers size line.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.52 2002/10/29 18:30:21 art Exp $	*/
a115 6
#ifdef SYSVSEM
#include <sys/sem.h>
#endif
#ifdef SYSVSHM
#include <sys/shm.h>
#endif
a381 11
#ifdef SYSVSHM
	shminfo.shmmax = shmmaxpgs;
	shminfo.shmall = shmmaxpgs;
	shminfo.shmseg = shmseg;
        valloc(shmsegs, struct shmid_ds, shminfo.shmmni);
#endif
#ifdef SYSVSEM
	valloc(sema, struct semid_ds, seminfo.semmni);
	valloc(sem, struct sem, seminfo.semmns);
	valloc(semu, int, (seminfo.semmnu * seminfo.semusz) / sizeof(int));
#endif
@


1.52
log
@Since memory deallocation can't fail, remove the error return from
uvm_unmap, uvm_deallocate and a few other functions.
Simplifies some code and reduces diff to the UBC branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.51 2002/10/12 01:09:43 krw Exp $	*/
d370 1
a370 1
	printf("using %d buffers containing %ld of memory\n", nbuf,
@


1.51
log
@Remove more '\n's from panic() statements. Both trailing and leading.

Diff generated by Chris Kuethe.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.50 2002/10/07 18:35:57 mickey Exp $	*/
d1637 1
a1637 1
		(void)uvm_unmap(kernel_map, sva, va);
d1639 1
a1639 1
		(void)uvm_unmap(kernel_map, va + size, sva + oversize);
@


1.50
log
@this removes the functionality of adding allocated
pages into the queue already containing allocated pages.
breaks i386:setup_buffers() because of this.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.49 2002/10/06 22:06:15 art Exp $	*/
d1795 1
a1795 1
			panic("sparc_bus_map: cannot allocate io_space: %d\n", err);
@


1.49
log
@No more need to initialize the result list before uvm_pglistalloc.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.48 2002/10/06 20:18:54 art Exp $	*/
d1545 1
@


1.48
log
@Declare nbuf just like all other architectures.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.47 2002/07/20 19:24:57 art Exp $	*/
a1544 1
	TAILQ_INIT(mlist);
@


1.47
log
@Instead of copying out the signal trampoline on top of the stack, create
an uvm aobj, copy out the signal trampoline into it and share that page
among all processes for the same emulation.

This also requires us to actually be able to tell signal code where the
trampoline is located, so introduce a new field in struct proc - p_sigcode
that is a pointer to sigcode. This allows us to remove all the ugly
calculations of the signal trampoline address done in every sendsig
function in the tree (that's why so many files are changed).

Tested by various people. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.46 2002/07/10 20:30:15 jsyn Exp $	*/
d151 9
@


1.46
log
@'sez' is not an english word; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.45 2002/07/03 21:19:05 miod Exp $	*/
a627 2
	extern char sigcode[], esigcode[];
#define	szsigcode	(esigcode - sigcode)
d711 1
a711 1
	addr = (vaddr_t)PS_STRINGS - szsigcode;
@


1.45
log
@Change all variables definitions (int foo) in sys/sys/*.h to variable
declarations (extern int foo), and compensate in the appropriate locations.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.44 2002/06/15 17:23:31 art Exp $	*/
d1838 1
a1838 1
	if (error) printf("sparc_bus_unmap: extent free sez %d\n", error);
@


1.44
log
@Decruftification.

We will never have a.out kernels.
We will never have 32-bit kernels.
We will never have sun4c, sun4 and sun4m support in the sparc64 kernels.
We don't need support old netbsd libc.
The cpu will never be identified as some of the sun4c and sun4m types.
We don't need the gazillion of fields in cpuinfo that the sparc port uses.
Just generally remove dead code.

This is just a first step in making this meess readable.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.43 2002/06/14 21:34:59 todd Exp $	*/
d156 5
@


1.43
log
@spelling; from Brian Poole <raj@@cerias.purdue.edu>
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.42 2002/06/14 04:17:59 art Exp $	*/
a110 7
#ifndef	ELFSIZE
#ifdef __arch64__
#define	ELFSIZE	64
#else
#define	ELFSIZE	32
#endif
#endif
a422 1
#ifdef __arch64__
a426 4
#else
#define STACK_OFFSET	0
#define CPOUTREG(l,v)	copyout(&(v), (l), sizeof(v))
#endif
a439 1
#ifdef __arch64__
a440 1
#endif
a451 1
#ifdef __arch64__
d468 1
a468 1
#endif
a513 4
#ifndef __arch64__
	struct	sigcontext *sf_scp;	/* SunOS user addr of sigcontext */
	int	sf_addr;		/* SunOS compat, always 0 for now */
#endif
a651 4
#ifndef __arch64__
	sf.sf_scp = 0;
	sf.sf_addr = 0;			/* XXX */
#endif
a661 1
#ifdef __arch64__
a662 3
#else
	sf.sf_sc.sc_psr = TSTATECCR_TO_PSR(tf->tf_tstate); /* XXX */
#endif
a773 1
#ifdef __arch64__
a774 3
#else
	tf->tf_tstate = (u_int64_t)(tf->tf_tstate & ~TSTATE_CCR) | PSRCC_TO_TSTATE(scp->sc_psr);
#endif
@


1.42
log
@support for getting the cpu type through sysctl, same as on sparc.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.41 2002/03/27 15:12:22 jason Exp $	*/
d1640 1
a1640 1
	 * Find a region of kernel virtual addresses that can accomodate
@


1.41
log
@Need APERTURE so we can read/write pci configuration with securelevel > 0
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.40 2002/03/23 13:28:34 espie Exp $	*/
d615 2
@


1.40
log
@Add variables for config(8) -e time tweak of systemV shared memory
parameters.

Ok millert@@, miod@@, maja@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.39 2002/03/14 03:16:01 millert Exp $	*/
d174 8
d603 11
@


1.39
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.38 2002/03/14 01:26:45 millert Exp $	*/
d374 3
@


1.38
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.37 2002/02/21 20:30:15 art Exp $	*/
d1100 1
a1100 1
			fp64 = (struct frame64*)(((char*)fp)+BIAS);
d1712 1
a1712 1
static void	*sparc_mainbus_intr_establish __P((bus_space_tag_t, int, int,
d1714 1
a1714 1
						   void *));
@


1.37
log
@There is no need to restrict number of bufs to 200.
It's just a pasto from sparc.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.36 2002/02/18 17:22:05 jason Exp $	*/
d188 3
a190 3
caddr_t	allocsys __P((caddr_t));
void	dumpsys __P((void));
void	stackdump __P((void));
d951 1
a951 1
	register int (*dump)	__P((dev_t, daddr_t, caddr_t, size_t));
d1056 1
a1056 1
void trapdump __P((struct trapframe64*));
d1703 1
a1703 1
static int	sparc_bus_map __P(( bus_space_tag_t, bus_type_t, bus_addr_t,
d1705 4
a1708 4
				    bus_space_handle_t *));
static int	sparc_bus_unmap __P((bus_space_tag_t, bus_space_handle_t,
				     bus_size_t));
static int	sparc_bus_subregion __P((bus_space_tag_t, bus_space_handle_t,
d1710 2
a1711 2
					 bus_space_handle_t *));
static paddr_t	sparc_bus_mmap __P((bus_space_tag_t, bus_addr_t, off_t, int, int));
d1713 1
a1713 1
						   int, int (*) __P((void *)),
d1715 3
a1717 3
static void	sparc_bus_barrier __P((bus_space_tag_t, bus_space_handle_t,
					  bus_size_t, bus_size_t, int));
static int	sparc_bus_alloc __P((bus_space_tag_t, bus_addr_t, bus_addr_t,
d1719 3
a1721 3
					bus_addr_t *, bus_space_handle_t *));
static void	sparc_bus_free __P((bus_space_tag_t, bus_space_handle_t,
				       bus_size_t));
d1868 1
a1868 1
	int		(*callback) __P((void *, void *));
d1893 1
a1893 1
	int	(*handler)__P((void *));
@


1.36
log
@provide pckbc_machdep_cnattach if necessary (like alpha, it does nothing)
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.35 2002/02/17 22:59:53 maja Exp $	*/
d400 1
a400 3
	if (nbuf > 200)
		nbuf = 200;     /* or we run out of PMEGS */
	/* Restrict to at most 70% filled kvm */
d402 1
a402 1
	    (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) * 7 / 10)
d404 1
a404 1
		    MAXBSIZE * 7 / 10;
@


1.35
log
@Patch from Daniel Lucq <daniel@@lucq.org>

The patch allows you to change the value of NMBCLUSTERS, BUFCACHEPERCENT
and NKMEMPAGES using the config command, instead of recompiling the kernel.

This is the kernel part of the patch. I have compiled it on i386, sparc64,
alpha and macppc. -moj ok art@@ maja@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.34 2002/02/05 18:34:39 jason Exp $	*/
d141 6
d238 15
@


1.34
log
@Implement vgafb_mmap() fully
From NetBSD: change bus_space_mmap() prototype to standard one
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.33 2002/02/01 21:48:23 jason Exp $	*/
d153 6
a366 3
#ifndef BUFCACHEPERCENT
#define BUFCACHEPERCENT 5
#endif
d373 1
a373 1
	 	bufpages = physmem * BUFCACHEPERCENT / 100;
@


1.33
log
@Clean up auxio a bit and add machdep.led_blink sysctl (like sparc),
portions from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.32 2002/02/01 19:38:23 jason Exp $	*/
d1689 1
a1689 2
static int	sparc_bus_mmap __P((bus_space_tag_t, bus_type_t,
				    bus_addr_t, int, bus_space_handle_t *));
d1693 7
a1699 3
static void     sparc_bus_barrier __P(( bus_space_tag_t, bus_space_handle_t,
					bus_size_t, bus_size_t, int));

d1824 2
a1825 2
int
sparc_bus_mmap(t, iospace, paddr, flags, hp)
d1827 4
a1830 4
	bus_type_t	iospace;
	bus_addr_t	paddr;
	int		flags;
	bus_space_handle_t *hp;
d1832 2
a1833 3

	*hp = (bus_space_handle_t)(paddr>>PGSHIFT);
	return (0);
d1887 2
a1888 1
void sparc_bus_barrier (t, h, offset, size, flags)
d1912 25
d1941 2
@


1.32
log
@Default kernel is bsd around these parts.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.31 2002/01/23 17:51:52 art Exp $	*/
d85 2
d157 5
d517 3
d555 16
@


1.31
log
@move mb_map allocation to mbinit()
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.30 2002/01/23 17:35:56 art Exp $	*/
d538 1
a538 1
				 * `netbsd' 
d540 1
a540 1
				cp = "netbsd";
@


1.30
log
@move definition of mb_map from zillions of machdep.c to uipc_mbuf.c
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.29 2002/01/16 20:50:17 miod Exp $	*/
a315 6

	/*
	 * Finally, allocate mbuf cluster submap.
	 */
        mb_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
	    VM_MBUF_SIZE, VM_MAP_INTRSAFE, FALSE, NULL);
@


1.29
log
@Don't include <sys/map.h> when you don't need what's in it.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.28 2002/01/04 01:17:46 miod Exp $	*/
a148 1
struct vm_map *mb_map = NULL;
@


1.28
log
@Standardize on EFBIG for bus_dma returning failure if caller is too griddy.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.27 2001/12/04 23:22:42 art Exp $	*/
a90 1
#include <sys/map.h>
@


1.27
log
@Yet another sync to NetBSD uvm.
Today we add a pmap argument to pmap_update() and allocate map entries for
kernel_map from kmem_map instead of using the static entries. This should
get rid of MAX_KMAPENT panics. Also some uvm_loan problems are fixed.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.26 2001/11/24 17:53:41 miod Exp $	*/
d1271 1
a1271 1
			return E2BIG;
d1340 1
a1340 1
			return (E2BIG);
@


1.27.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.31 2002/01/23 17:51:52 art Exp $	*/
d91 1
d150 1
d319 6
d1271 1
a1271 1
			return (EFBIG);
d1340 1
a1340 1
			return (EFBIG);
@


1.27.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.27.2.1 2002/01/31 22:55:25 niklas Exp $	*/
a84 2
#include "auxio.h"

a138 6
#include "pckbc.h"
#include "pckbd.h"
#if (NPCKBC > 0) && (NPCKBD == 0)
#include <dev/ic/pckbcvar.h>
#endif

a150 6
#ifndef BUFCACHEPERCENT
#define BUFCACHEPERCENT 5
#endif

int	bufcachepercent = BUFCACHEPERCENT;

a154 13
#if NAUXIO > 0
#include <sparc64/dev/auxiovar.h>
int sparc_led_blink;
#endif

#ifdef APERTURE
#ifdef INSECURE
int allowaperture = 1;
#else
int allowaperture = 0;
#endif
#endif

d169 3
a171 3
caddr_t	allocsys(caddr_t);
void	dumpsys(void);
void	stackdump(void);
a220 15
#if (NPCKBC > 0) && (NPCKBD == 0)
/*
 * This is called by the pckbc driver if no pckbd is configured.
 * On the i386, it is used to glue in the old, deprecated console
 * code.  On the sparc64, it does nothing.
 */
int
pckbc_machdep_cnattach(kbctag, kbcslot)
	pckbc_tag_t kbctag;
	pckbc_slot_t kbcslot;
{
	return (ENXIO);
}
#endif

a339 3
	shminfo.shmmax = shmmaxpgs;
	shminfo.shmall = shmmaxpgs;
	shminfo.shmseg = shmseg;
d354 3
d363 1
a363 1
	 	bufpages = physmem * bufcachepercent / 100;
d369 3
a371 1
	/* Restrict to at most 30% filled kvm */
d373 1
a373 1
	    (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) * 3 / 10)
d375 1
a375 1
		    MAXBSIZE * 3 / 10;
a509 3
#if NAUXIO > 0
	int oldval, ret;
#endif
d538 1
a538 1
				 * `bsd' 
d540 1
a540 1
				cp = "bsd";
a544 27
	case CPU_LED_BLINK:
#if NAUXIO > 0
		oldval = sparc_led_blink;
		ret = sysctl_int(oldp, oldlenp, newp, newlen,
		    &sparc_led_blink);

		/*
		 * If we were false and are now true, call auxio_led_blink().
		 * auxio_led_blink() will catch the other case itself.
		 */
		if (!oldval && sparc_led_blink > oldval)
			auxio_led_blink(NULL);
		return (ret);
#else
		return (EOPNOTSUPP);
#endif
	case CPU_ALLOWAPERTURE:
#ifdef APERTURE
		if (securelevel > 0)
			return (sysctl_rdint(oldp, oldlenp, newp,
			    allowaperture));
		else
			return (sysctl_int(oldp, oldlenp, newp, newlen,
			    &allowaperture));
#else
		return (sysctl_rdint(oldp, oldlenp, newp, 0));
#endif
d903 1
a903 1
	register int (*dump)(dev_t, daddr_t, caddr_t, size_t);
d1008 1
a1008 1
void trapdump(struct trapframe64*);
d1052 1
a1052 1
			fp64 = (struct frame64*)(((char *)fp)+BIAS);
d1655 1
a1655 1
static int	sparc_bus_map( bus_space_tag_t, bus_type_t, bus_addr_t,
d1657 4
a1660 4
				    bus_space_handle_t *);
static int	sparc_bus_unmap(bus_space_tag_t, bus_space_handle_t,
				     bus_size_t);
static int	sparc_bus_subregion(bus_space_tag_t, bus_space_handle_t,
d1662 9
a1670 12
					 bus_space_handle_t *);
static paddr_t	sparc_bus_mmap(bus_space_tag_t, bus_addr_t, off_t, int, int);
static void	*sparc_mainbus_intr_establish(bus_space_tag_t, int, int,
						   int, int (*)(void *),
						   void *);
static void	sparc_bus_barrier(bus_space_tag_t, bus_space_handle_t,
					  bus_size_t, bus_size_t, int);
static int	sparc_bus_alloc(bus_space_tag_t, bus_addr_t, bus_addr_t,
					bus_size_t, bus_size_t, bus_size_t, int,
					bus_addr_t *, bus_space_handle_t *);
static void	sparc_bus_free(bus_space_tag_t, bus_space_handle_t,
				       bus_size_t);
d1795 2
a1796 2
paddr_t
sparc_bus_mmap(t, paddr, off, prot, flags)
d1798 4
a1801 4
	bus_addr_t paddr;
	off_t off;
	int prot;
	int flags;
d1803 3
a1805 2
	/* Devices are un-cached... although the driver should do that */
	return ((paddr+off)|PMAP_NC);
d1818 1
a1818 1
	int		(*callback)(void *, void *);
d1843 1
a1843 1
	int	(*handler)(void *);
d1859 1
a1859 2
void
sparc_bus_barrier (t, h, offset, size, flags)
a1882 25
int
sparc_bus_alloc(t, rs, re, s, a, b, f, ap, hp)
	bus_space_tag_t	t;
	bus_addr_t	rs;
	bus_addr_t	re;
	bus_size_t	s;
	bus_size_t	a;
	bus_size_t	b;
	int		f;
	bus_addr_t	*ap;
	bus_space_handle_t *hp;
{
	return (ENOTTY);
}

void
sparc_bus_free(t, h, s)
	bus_space_tag_t	t;
	bus_space_handle_t	h;
	bus_size_t	s;
{
	return;
}


a1886 2
	sparc_bus_alloc,
	sparc_bus_free,
@


1.27.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.27.2.2 2002/06/11 03:38:43 art Exp $	*/
d111 7
a158 9
/*
 * Declare these as initialized data so we can patch them.
 */
#ifdef	NBUF
int	nbuf = NBUF;
#else
int	nbuf = 0;
#endif

a162 5
#ifdef	BUFPAGES
int	bufpages = BUFPAGES;
#else
int	bufpages = 0;
#endif
d430 1
d435 4
d452 1
d454 1
d466 1
d483 1
a483 1

d529 4
a614 2
	case CPU_CPUTYPE:
		return (sysctl_rdint(oldp, oldlenp, newp, CPU_SUN4U));
d640 2
d669 4
d683 1
d685 3
d733 1
a733 1
	addr = p->p_sigcode;
d799 1
d801 3
d1638 1
a1638 1
	 * Find a region of kernel virtual addresses that can accommodate
d1812 1
a1812 1
			panic("sparc_bus_map: cannot allocate io_space: %d", err);
d1862 1
a1862 1
	if (error) printf("sparc_bus_unmap: extent free says %d\n", error);
@


1.27.2.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d116 6
d140 8
a147 40
int     _bus_dmamap_create(bus_dma_tag_t, bus_dma_tag_t, bus_size_t, int,
	    bus_size_t, bus_size_t, int, bus_dmamap_t *);
void    _bus_dmamap_destroy(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t);
int     _bus_dmamap_load(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t, void *,
            bus_size_t, struct proc *, int);
int     _bus_dmamap_load_mbuf(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t,
            struct mbuf *, int);
int     _bus_dmamap_load_uio(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t,
            struct uio *, int);
int     _bus_dmamap_load_raw(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t,
            bus_dma_segment_t *, int, bus_size_t, int);
void    _bus_dmamap_unload(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t);
void    _bus_dmamap_sync(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t,
	    bus_addr_t, bus_size_t, int);

int     _bus_dmamem_alloc(bus_dma_tag_t, bus_dma_tag_t tag, bus_size_t size,
            bus_size_t alignment, bus_size_t boundary,
            bus_dma_segment_t *segs, int nsegs, int *rsegs, int flags);

void    _bus_dmamem_free(bus_dma_tag_t tag, bus_dma_tag_t,
	    bus_dma_segment_t *segs, int nsegs);
int     _bus_dmamem_map(bus_dma_tag_t tag, bus_dma_tag_t,
	    bus_dma_segment_t *segs, int nsegs, size_t size, caddr_t *kvap,
	    int flags);
void    _bus_dmamem_unmap(bus_dma_tag_t tag, bus_dma_tag_t, caddr_t kva,
            size_t size);
paddr_t _bus_dmamem_mmap(bus_dma_tag_t tag, bus_dma_tag_t,
	    bus_dma_segment_t *segs, int nsegs, off_t off, int prot, int flags);

int     _bus_dmamem_alloc_range(bus_dma_tag_t tag, bus_dma_tag_t,
	    bus_size_t size, bus_size_t alignment, bus_size_t boundary,
            bus_dma_segment_t *segs, int nsegs, int *rsegs, int flags,
            vaddr_t low, vaddr_t high);

/*
 * The "bus_space_debug" flags used by macros elsewhere.
 * A good set of flags to use when first debugging something is:
 * int bus_space_debug = BSDB_ACCESS | BSDB_ASSERT | BSDB_MAP;
 */
int bus_space_debug = 0;
a188 3
extern int ceccerrs;
extern int64_t cecclast;

d207 48
d300 1
d350 3
a352 2
			pmap_kenter_pa(curbuf,
			    VM_PAGE_TO_PHYS(pg), VM_PROT_READ|VM_PROT_WRITE);
d370 1
a370 1
	printf("using %d buffers containing %ld bytes of memory\n", nbuf,
d388 11
d420 2
a421 2
	    (VM_MAX_KERNEL_ADDRESS - VM_MIN_KERNEL_ADDRESS) * 3 / 10)
		nbuf = (VM_MAX_KERNEL_ADDRESS - VM_MIN_KERNEL_ADDRESS) /
d563 2
a564 2
			 * It can be the empty string if we booted from the
			 * default kernel name.
d570 1
a570 1
			/* Now we've separated the kernel name from the args */
a611 4
	case CPU_CECCERRORS:
		return (sysctl_rdint(oldp, oldlenp, newp, ceccerrs));
	case CPU_CECCLAST:
		return (sysctl_rdquad(oldp, oldlenp, newp, cecclast));
d703 1
a703 2
		printf("sendsig: stack was trashed trying to send sig %d, "
		    "sending SIGILL\n", sig);
d739 1
a739 1
	struct proc *p;
d747 1
a747 1
	struct trapframe64 *tf;
d755 1
a755 2
		printf("sigreturn: rwindow_save(%p) failed, sending SIGILL\n",
		    p);
d954 1
a954 1
	int psize;
d956 1
a956 1
	int (*dump)(dev_t, daddr_t, caddr_t, size_t);
d958 1
a958 1
	struct mem_region *mp;
d1107 1
a1107 2
			printf("%llx(%llx, %llx, %llx, %llx, %llx, %llx, %llx) "
			    "fp = %llx\n",
d1120 4
a1123 5
			printf("  pc = %x  args = (%x, %x, %x, %x, %x, %x, %x) "
			    "fp = %x\n", fp->fr_pc, fp->fr_arg[0],
			    fp->fr_arg[1], fp->fr_arg[2], fp->fr_arg[3],
			    fp->fr_arg[4], fp->fr_arg[5], fp->fr_arg[6],
			    fp->fr_fp);
d1143 2
a1144 2
_bus_dmamap_create(t, t0, size, nsegments, maxsegsz, boundary, flags, dmamp)
	bus_dma_tag_t t, t0;
d1180 2
a1181 2
	map->_dm_flags = flags & ~(BUS_DMA_WAITOK | BUS_DMA_NOWAIT |
	    BUS_DMA_COHERENT | BUS_DMA_NOWRITE | BUS_DMA_NOCACHE);
d1194 2
a1195 2
_bus_dmamap_destroy(t, t0, map)
	bus_dma_tag_t t, t0;
a1196 1

a1197 10
	/*
	 * Unload the map if it is still loaded.  This is required
	 * by the specification (well, the manpage).  Higher level
	 * drivers, if any, should do this too.  By the time the
	 * system gets here, the higher level "destroy" functions
	 * would probably already have clobbered the data needed
	 * to do a proper unload.
	 */
	if (map->dm_nsegs)
		bus_dmamap_unload(t0, map);
d1213 2
a1214 2
_bus_dmamap_load(t, t0, map, buf, buflen, p, flags)
	bus_dma_tag_t t, t0;
a1258 1
	/* Is this what the above comment calls "one segment"? */
a1259 1

d1268 2
a1269 2
_bus_dmamap_load_mbuf(t, t0, map, m, flags)
	bus_dma_tag_t t, t0;
d1280 1
a1280 1
	map->_dm_source = m;
d1298 2
a1299 3
			if (i > 0 && pa == (segs[i - 1].ds_addr +
			    segs[i - 1].ds_len) && ((segs[i - 1].ds_len + incr)
			    < map->_dm_maxsegsz)) {
d1301 1
a1301 1
				segs[i - 1].ds_len += incr;
d1320 1
a1320 1
	return (bus_dmamap_load_raw(t0, map, segs, i,
d1328 2
a1329 2
_bus_dmamap_load_uio(t, t0, map, uio, flags)
	bus_dma_tag_t t, t0;
d1367 2
a1368 3
			if (i > 0 && pa == (segs[i - 1].ds_addr +
			    segs[i - 1].ds_len) && ((segs[i - 1].ds_len + incr)
			    < map->_dm_maxsegsz)) {
d1370 1
a1370 1
				segs[i - 1].ds_len += incr;
d1389 1
a1389 1
	return (bus_dmamap_load_raw(t0, map, segs, i, (bus_size_t)len, flags));
d1397 2
a1398 2
_bus_dmamap_load_raw(t, t0, map, segs, nsegs, size, flags)
	bus_dma_tag_t t, t0;
d1414 2
a1415 2
_bus_dmamap_unload(t, t0, map)
	bus_dma_tag_t t, t0;
d1423 1
a1423 1
	for (i = 0; i < map->dm_nsegs; i++) {
d1453 2
a1454 2
_bus_dmamap_sync(t, t0, map, offset, len, ops)
	bus_dma_tag_t t, t0;
d1474 1
a1474 1
		membar(Sync);
d1511 2
a1512 2
_bus_dmamem_alloc(t, t0, size, alignment, boundary, segs, nsegs, rsegs, flags)
	bus_dma_tag_t t, t0;
d1577 2
a1578 2
_bus_dmamem_free(t, t0, segs, nsegs)
	bus_dma_tag_t t, t0;
d1598 2
a1599 2
_bus_dmamem_map(t, t0, segs, nsegs, size, kvap, flags)
	bus_dma_tag_t t, t0;
d1607 1
d1637 1
a1637 1
		uvm_unmap(kernel_map, sva, va);
d1639 1
a1639 1
		uvm_unmap(kernel_map, va + size, sva + oversize);
d1643 1
d1653 2
a1654 2
_bus_dmamem_unmap(t, t0, kva, size)
	bus_dma_tag_t t, t0;
d1673 2
a1674 2
_bus_dmamem_mmap(t, t0, segs, nsegs, off, prot, flags)
	bus_dma_tag_t t, t0;
d1708 19
a1726 19
int sparc_bus_map(bus_space_tag_t, bus_space_tag_t, bus_addr_t, bus_size_t,
    int, bus_space_handle_t *);
int sparc_bus_protect(bus_space_tag_t, bus_space_tag_t, bus_space_handle_t,
    bus_size_t, int);
int sparc_bus_unmap(bus_space_tag_t, bus_space_tag_t, bus_space_handle_t,
    bus_size_t);
int sparc_bus_subregion(bus_space_tag_t, bus_space_tag_t,  bus_space_handle_t,
    bus_size_t, bus_size_t, bus_space_handle_t *);
paddr_t sparc_bus_mmap(bus_space_tag_t, bus_space_tag_t, bus_addr_t, off_t,
    int, int);
void *sparc_mainbus_intr_establish(bus_space_tag_t, bus_space_tag_t, int, int,
    int, int (*)(void *), void *);
void sparc_bus_barrier(bus_space_tag_t, bus_space_tag_t,  bus_space_handle_t,
    bus_size_t, bus_size_t, int);
int sparc_bus_alloc(bus_space_tag_t, bus_space_tag_t, bus_addr_t, bus_addr_t,
    bus_size_t, bus_size_t, bus_size_t, int, bus_addr_t *,
    bus_space_handle_t *);
void sparc_bus_free(bus_space_tag_t, bus_space_tag_t, bus_space_handle_t,
    bus_size_t);
d1732 7
a1738 2
sparc_bus_map(bus_space_tag_t t, bus_space_tag_t t0, bus_addr_t	addr,
    bus_size_t size, int flags, bus_space_handle_t *hp)
d1745 1
a1745 5
	if (flags & BUS_SPACE_MAP_PROMADDRESS) {
		hp->bh_ptr = addr;
		return (0);
	}

d1753 3
a1755 2
		    (u_long)IODEV_BASE, (u_long)IODEV_END, M_DEVBUF, 0, 0,
		    EX_NOWAIT);
d1757 1
d1759 1
a1759 3
		char buf[80];
		bus_space_render_tag(t0, buf, sizeof buf);
		printf("\nsparc_bus_map: zero size on %s", buf);
d1762 22
a1783 29

	if ( (LITTLE_ASI(t0->asi) && LITTLE_ASI(t0->sasi)) ||
	    (PHYS_ASI(t0->asi) != PHYS_ASI(t0->sasi)) ) {
		char buf[80];
		bus_space_render_tag(t0, buf, sizeof buf);
		printf("\nsparc_bus_map: mismatched ASIs on %s: asi=%x sasi=%x",
		    buf, t0->asi, t0->sasi);
	}

	if (PHYS_ASI(t0->asi)) {
#ifdef BUS_SPACE_DEBUG
		char buf[80];
		bus_space_render_tag(t0, buf, sizeof buf);
		BUS_SPACE_PRINTF(BSDB_MAP,
		    ("\nsparc_bus_map: physical tag %s asi %x sasi %x flags %x "
		    "paddr %016llx size %016llx",
		    buf,
		    (int)t0->asi, (int)t0->sasi, (int)flags,
		    (unsigned long long)addr, (unsigned long long)size));
#endif /* BUS_SPACE_DEBUG */
		if (flags & BUS_SPACE_MAP_LINEAR) {
			char buf[80];
			bus_space_render_tag(t0, buf, sizeof buf);
			printf("\nsparc_bus_map: linear mapping requested on physical bus %s", buf);
			return (EINVAL);
		}

		hp->bh_ptr = addr;
		return (0);
d1786 1
a1786 4
	size = round_page(size);

	if (LITTLE_ASI(t0->sasi) && !LITTLE_ASI(t0->asi))
		pm_flags |= PMAP_LITTLE;
d1788 8
a1795 9
	if ((flags & BUS_SPACE_MAP_CACHEABLE) == 0)
		pm_flags |= PMAP_NC;

	{ /* scope */
		int err = extent_alloc(io_space, size, NBPG, 0, 0,
		    EX_NOWAIT | EX_BOUNDZERO, (u_long *)&v);
		if (err)
			panic("sparc_bus_map: cannot allocate io_space: %d",
			    err);
d1799 1
a1799 1
	hp->bh_ptr = v | ((u_long)addr & PGOFSET);
d1802 1
a1802 2
	if ((flags & BUS_SPACE_MAP_READONLY) == 0)
		pm_prot |= VM_PROT_WRITE;
d1804 5
a1808 11
#ifdef BUS_SPACE_DEBUG
	{ /* scope */
		char buf[80];
		bus_space_render_tag(t0, buf, sizeof buf);
		BUS_SPACE_PRINTF(BSDB_MAP, ("\nsparc_bus_map: tag %s type %x "
		    "flags %x addr %016llx size %016llx virt %llx paddr "
		    "%016llx", buf, (int)t->default_type, (int) flags,
		    (unsigned long long)addr, (unsigned long long)size,
		    (unsigned long long)hp->bh_ptr, (unsigned long long)pa));
	}
#endif /* BUS_SPACE_DEBUG */
d1811 3
a1813 3
		BUS_SPACE_PRINTF(BSDB_MAPDETAIL, ("\nsparc_bus_map: phys %llx "
		    "virt %p hp->bh_ptr %llx", (unsigned long long)pa,
		    (char *)v, (unsigned long long)hp->bh_ptr));
d1824 6
a1829 3
sparc_bus_subregion(bus_space_tag_t tag, bus_space_tag_t tag0,
    bus_space_handle_t handle, bus_size_t offset, bus_size_t size,
    bus_space_handle_t *nhandlep)
d1831 1
a1831 2
	*nhandlep = handle;
	nhandlep->bh_ptr += offset;
a1834 13
/* stolen from uvm_chgkprot() */
/*
 * Change protections on kernel pages from addr to addr+len
 * (presumably so debugger can plant a breakpoint).
 *
 * We force the protection change at the pmap level.  If we were
 * to use vm_map_protect a change to allow writing would be lazily-
 * applied meaning we would still take a protection fault, something
 * we really don't want to do.  It would also fragment the kernel
 * map unnecessarily.  We cannot use pmap_protect since it also won't
 * enforce a write-enable request.  Using pmap_enter is the only way
 * we can ensure the change takes place properly.
 */
d1836 4
a1839 44
sparc_bus_protect(bus_space_tag_t t, bus_space_tag_t t0, bus_space_handle_t h,
    bus_size_t size, int flags)
{
        vm_prot_t prot;
	paddr_t	pm_flags = 0;
        paddr_t pa;
        vaddr_t sva, eva;
	void* addr = bus_space_vaddr(t0, h);

	if (addr == 0) {
		printf("\nsparc_bus_protect: null address");
		return (EINVAL);
	}

	if (PHYS_ASI(t0->asi)) {
		printf("\nsparc_bus_protect: physical ASI");
		return (EINVAL);
	}

        prot = (flags & BUS_SPACE_MAP_READONLY) ?
	    VM_PROT_READ : VM_PROT_READ | VM_PROT_WRITE;
	if ((flags & BUS_SPACE_MAP_CACHEABLE) == 0)
	    pm_flags |= PMAP_NC;

        eva = round_page((vaddr_t)addr + size);
        for (sva = trunc_page((vaddr_t)addr); sva < eva; sva += PAGE_SIZE) {
                /*
                 * Extract physical address for the page.
                 * We use a cheezy hack to differentiate physical
                 * page 0 from an invalid mapping, not that it
                 * really matters...
                 */
                if (pmap_extract(pmap_kernel(), sva, &pa) == FALSE)
                        panic("bus_space_protect(): invalid page");
                pmap_enter(pmap_kernel(), sva, pa | pm_flags, prot, prot | PMAP_WIRED);
        }
	pmap_update(pmap_kernel());

	return (0);
}

int
sparc_bus_unmap(bus_space_tag_t t, bus_space_tag_t t0, bus_space_handle_t bh,
    bus_size_t size)
d1841 1
a1841 1
	vaddr_t va = trunc_page((vaddr_t)bh.bh_ptr);
a1842 1
	int error;
d1844 2
a1845 6
	if (PHYS_ASI(t0->asi))
		return (0);

	error = extent_free(io_space, va, size, EX_NOWAIT);
	if (error)
		printf("\nsparc_bus_unmap: extent free says %d", error);
d1852 6
a1857 2
sparc_bus_mmap(bus_space_tag_t t, bus_space_tag_t t0, bus_addr_t paddr,
    off_t off, int prot, int flags)
a1858 5
	if (PHYS_ASI(t0->asi)) {
		printf("\nsparc_bus_mmap: physical ASI");
		return (NULL);
	}

d1860 1
a1860 1
	return ((paddr + off) | PMAP_NC);
d1866 9
a1874 2
bus_space_probe(bus_space_tag_t tag, bus_addr_t paddr, bus_size_t size,
    size_t offset, int flags, int (*callback)(void *, void *), void *arg)
d1880 1
a1880 1
	if (bus_space_map(tag, paddr, size, flags, &bh) != 0)
d1883 2
a1884 2
	tmp = bh.bh_ptr;
	result = (probeget(tmp + offset, tag->asi, size) != -1);
d1893 7
a1899 2
sparc_mainbus_intr_establish(bus_space_tag_t t, bus_space_tag_t t0, int	pil,
    int level, int flags, int (*handler)(void *), void *arg)
d1915 6
a1920 2
sparc_bus_barrier(bus_space_tag_t t, bus_space_tag_t t0, bus_space_handle_t h,
    bus_size_t offset, bus_size_t size, int flags)
d1929 1
a1929 1
		membar(Sync);
d1931 1
a1931 1
		membar(Sync);
d1933 1
a1933 1
		membar(Sync);
d1940 10
a1949 3
sparc_bus_alloc(bus_space_tag_t t, bus_space_tag_t t0, bus_addr_t rs,
    bus_addr_t re, bus_size_t s, bus_size_t a, bus_size_t b, int f,
    bus_addr_t *ap, bus_space_handle_t *hp)
d1955 4
a1958 2
sparc_bus_free(bus_space_tag_t t, bus_space_tag_t t0, bus_space_handle_t h,
    bus_size_t s)
d1963 2
a1964 1
static const struct sparc_bus_space_tag _mainbus_space_tag = {
a1967 3
	ASI_PRIMARY,
	ASI_PRIMARY,
	"mainbus",
a1970 1
	sparc_bus_protect,		/* bus_space_protect */
a1976 1
const bus_space_tag_t mainbus_space_tag = &_mainbus_space_tag;
a1980 224

#define _BS_PRECALL(t,f)		\
        while (t->f == NULL)		\
                t = t->parent;
#define _BS_POSTCALL

#define _BS_CALL(t,f)			\
        (*(t)->f)

int
bus_space_alloc(bus_space_tag_t t, bus_addr_t rs, bus_addr_t re, bus_size_t s,
    bus_size_t a, bus_size_t b, int f, bus_addr_t *ap, bus_space_handle_t *hp)
{
        const bus_space_tag_t t0 = t;
        int ret;

        _BS_PRECALL(t, sparc_bus_alloc);
        ret = _BS_CALL(t, sparc_bus_alloc)(t, t0, rs, re, s, a, b, f, ap, hp);
        _BS_POSTCALL;
        return ret;
}

void
bus_space_free(bus_space_tag_t t, bus_space_handle_t h, bus_size_t s)
{
	const bus_space_tag_t t0 = t;

	_BS_PRECALL(t, sparc_bus_free);
	_BS_CALL(t, sparc_bus_free)(t, t0, h, s);
	_BS_POSTCALL;
}

int
bus_space_map(bus_space_tag_t t, bus_addr_t a, bus_size_t s, int f,
    bus_space_handle_t *hp)
{
	const bus_space_tag_t t0 = t;
	int ret;

	_BS_PRECALL(t, sparc_bus_map);
	ret = _BS_CALL(t, sparc_bus_map)(t, t0, a, s, f, hp);
	_BS_POSTCALL;
#ifdef BUS_SPACE_DEBUG
	if(s == 0) {
		char buf[128];
		bus_space_render_tag(t, buf, sizeof buf);
		printf("\n********** bus_space_map: requesting "
		    "zero-length mapping on bus %p:%s",
		    t, buf);
	}
	hp->bh_flags = 0;
	if (ret == 0) {
		hp->bh_size = s;
		hp->bh_tag = t0;
	} else {
		hp->bh_size = 0;
		hp->bh_tag = NULL;
	}
#endif /* BUS_SPACE_DEBUG */
	return (ret);
}

int
bus_space_protect(bus_space_tag_t t, bus_space_handle_t h, bus_size_t s, int f)
{
	const bus_space_tag_t t0 = t;
	int ret;

	_BS_PRECALL(t, sparc_bus_protect);
	ret = _BS_CALL(t, sparc_bus_protect)(t, t0, h, s, f);
	_BS_POSTCALL;

	return (ret);
}

int
bus_space_unmap(bus_space_tag_t t, bus_space_handle_t h, bus_size_t s)
{
	const bus_space_tag_t t0 = t;
	int ret;

	_BS_PRECALL(t, sparc_bus_unmap);
	BUS_SPACE_ASSERT(t0, h, 0, 1);
#ifdef BUS_SPACE_DEBUG
	if(h.bh_size != s) {
		char buf[128];
		bus_space_render_tag(t0, buf, sizeof buf);
		printf("\n********* bus_space_unmap: %p:%s, map/unmap "
		    "size mismatch (%llx != %llx)",
		    t, buf, h.bh_size, s);
	}
#endif /* BUS_SPACE_DEBUG */
	ret = _BS_CALL(t, sparc_bus_unmap)(t, t0, h, s);
	_BS_POSTCALL;
	return (ret);
}

int
bus_space_subregion(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o,
    bus_size_t s, bus_space_handle_t *hp)
{
	const bus_space_tag_t t0 = t;
	int ret;

	_BS_PRECALL(t, sparc_bus_subregion);
	BUS_SPACE_ASSERT(t0, h, o, 1);
#ifdef BUS_SPACE_DEBUG
	if(h.bh_size < o + s) {
		char buf[128];
		bus_space_render_tag(t0, buf, sizeof buf);
		printf("\n********** bus_space_subregion: "
		    "%p:%s, %llx < %llx + %llx", 
		    t0, buf, h.bh_size, o, s);
		hp->bh_size = 0;
		hp->bh_tag = NULL;
		return (EINVAL);
	}
#endif /* BUS_SPACE_DEBUG */
	ret = _BS_CALL(t, sparc_bus_subregion)(t, t0, h, o, s, hp);
	_BS_POSTCALL;
#ifdef BUS_SPACE_DEBUG
	if (ret == 0) {
		hp->bh_size = s;
		hp->bh_tag = t0;
	} else {
		hp->bh_size = 0;
		hp->bh_tag = NULL;
	}
#endif /* BUS_SPACE_DEBUG */
	return (ret);
}

paddr_t
bus_space_mmap(bus_space_tag_t t, bus_addr_t a, off_t o, int p, int f)
{
	const bus_space_tag_t t0 = t;
	paddr_t ret;

	_BS_PRECALL(t, sparc_bus_mmap);
	ret = _BS_CALL(t, sparc_bus_mmap)(t, t0, a, o, p, f);
	_BS_POSTCALL;
	return (ret);
}

void *
bus_intr_establish(bus_space_tag_t t, int p, int l, int f, int (*h)(void *),
    void *a)
{
	const bus_space_tag_t t0 = t;
	void *ret;

	_BS_PRECALL(t, sparc_intr_establish);
	ret = _BS_CALL(t, sparc_intr_establish)(t, t0, p, l, f, h, a);
	_BS_POSTCALL;
	return (ret);
}

/* XXXX Things get complicated if we use unmapped register accesses. */
void *
bus_space_vaddr(bus_space_tag_t t, bus_space_handle_t h)
{
	BUS_SPACE_ASSERT(t, h, 0, 1);
        if(t->asi == ASI_PRIMARY || t->asi == ASI_PRIMARY_LITTLE) 
		return 	((void *)(vaddr_t)(h.bh_ptr));

#ifdef BUS_SPACE_DEBUG
	{ /* Scope */
		char buf[64];
		bus_space_render_tag(t, buf, sizeof buf);
		printf("\nbus_space_vaddr: no vaddr for %p:%s (asi=%x)",
			t, buf, t->asi);
	}
#endif

	return (NULL);
}

void
bus_space_render_tag(bus_space_tag_t t, char* buf, size_t len)
{
	if (t == NULL) {
		strlcat(buf, "<NULL>", len);
		return;
	}
	buf[0] = '\0';
	if (t->parent)
		bus_space_render_tag(t->parent, buf, len);

	strlcat(buf, "/", len);
	strlcat(buf, t->name, len);
}

#ifdef BUS_SPACE_DEBUG

void
bus_space_assert(bus_space_tag_t t, const bus_space_handle_t *h, bus_size_t o,
    int n)
{
        if (h->bh_tag != t) {
		char buf1[128];
		char buf2[128];
		bus_space_render_tag(t, buf1, sizeof buf1);
		bus_space_render_tag(h->bh_tag, buf2, sizeof buf2);
                printf("\n********** bus_space_assert: wrong tag (%p:%s, "
		    "expecting %p:%s) ", t, buf1, h->bh_tag, buf2);
	}

        if (o >= h->bh_size) {
		char buf[128];
		bus_space_render_tag(t, buf, sizeof buf);
                printf("\n********** bus_space_assert: bus %p:%s, offset "
		    "(%llx) out of mapping range (%llx) ", t, buf, o,
		    h->bh_size);
	}

	if (o & (n - 1)) {
		char buf[128];
		bus_space_render_tag(t, buf, sizeof buf);
                printf("\n********** bus_space_assert: bus %p:%s, offset "
		    "(%llx) incorrect alignment (%d) ", t, buf, o, n);
	}
}

#endif /* BUS_SPACE_DEBUG */
@


1.26
log
@Harmonize boot() logic across arches:
- ensure RB_DUMP | RB_HALT will cause a dump
- or RB_HALT if (cold)
While there, honor RB_TIMEBAD on sparc64.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.25 2001/11/16 21:28:08 jason Exp $	*/
d310 1
a310 1
	pmap_update();
d976 1
a976 1
			pmap_update();
d980 1
a980 1
			pmap_update();
d1771 1
a1771 1
	pmap_update();
@


1.25
log
@add an implementation for _load_uio on UIO_SYSSPACE objects that looks strangely similiar to _load_mbuf.  Btw, /dev/crypto is working on sabre based systems with hifn7751 from soekris.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.24 2001/11/16 20:58:45 jason Exp $	*/
d796 1
a796 1
		if (sparc_clock_time_is_ok)
d798 3
@


1.24
log
@remove #if 1 and some other debugging stuff
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.23 2001/11/16 16:42:45 jason Exp $	*/
d1286 6
a1291 6
/* 
 * XXXXXXX The problem with this routine is that it needs to 
 * lock the user address space that is being loaded, but there
 * is no real way for us to unlock it during the unload process.
 */
#if 0
a1294 2
	struct proc *p = uio->uio_procp;
	struct pmap *pm;
d1296 6
a1301 15
	/*
	 * Check user read/write access to the data buffer.
	 */
	if (uio->uio_segflg == UIO_USERSPACE) {
		pm = p->p_vmspace->vm_map.pmap;
		for (i = 0; i < uio->uio_iovcnt; i++) {
			/* XXXCDC: map not locked, rethink */
			if (__predict_false(!uvm_useracc(uio->uio_iov[i].iov_base,
				     uio->uio_iov[i].iov_len,
/* XXX is UIO_WRITE correct? */
				     (uio->uio_rw == UIO_WRITE) ? B_WRITE : B_READ)))
				return (EFAULT);
		}
	} else
		pm = pmap_kernel();
d1303 1
a1303 1
	i = 0;
d1305 3
a1307 4
	for (j=0; j<uio->uio_iovcnt; j++) {
		struct iovec *iov = &uio->uio_iov[j];
		vaddr_t vaddr = (vaddr_t)iov->iov_base;
		bus_size_t buflen = iov->iov_len;
a1308 12
		/*
		 * Lock the part of the user address space involved
		 *    in the transfer.
		 */
		PHOLD(p);
		if (__predict_false(uvm_vslock(p, vaddr, buflen,
			    (uio->uio_rw == UIO_WRITE) ?
			    VM_PROT_READ | VM_PROT_WRITE : VM_PROT_READ)
			    != 0)) {
				goto after_vsunlock;
			}
		
d1315 1
a1315 1
			(void) pmap_extract(pm, vaddr, &pa);
a1317 3
			if (segs[i].ds_len == 0)
				segs[i].ds_addr = pa;

d1332 2
a1333 3
		uvm_vsunlock(p, bp->b_data, todo);
		PRELE(p);
 		if (buflen > 0 && i >= MAX_DMA_SEGS) 
d1335 4
a1338 1
			return E2BIG;
d1340 2
a1341 8
	map->_dm_type = DM_TYPE_UIO;
	map->_dm_source = (void *)uio;
	return (bus_dmamap_load_raw(t, map, segs, i, 
				    (bus_size_t)len, flags));
	return 0;
#else
	return (EOPNOTSUPP);
#endif
@


1.23
log
@_bus_dmamap_load_uio now returns an ERROR instead of claiming no error
(and doing nothing).  This allows for proper error propagation to
/dev/crypto which depends on bus_dmamap_load_uio() and failure
recovery... Better solution would be to -implement- _load_uio, but
that's another day.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.22 2001/11/10 20:11:04 deraadt Exp $	*/
d1183 1
a1183 10
	{ 
#ifdef DEBUG
		printf("_bus_dmamap_load(): error %lu > %lu -- map size exceeded!\n",
		    (unsigned long)buflen, (unsigned long)map->_dm_size);
#ifdef DDB
		Debugger();
#endif
#endif
		return (EINVAL);
	}		
a1225 1
#if 1
a1273 4
#else
	panic("_bus_dmamap_load_mbuf: not implemented");
	return 0;
#endif
@


1.22
log
@properly report >= 2GB of ram; bug found by matthieu
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.21 2001/11/09 15:25:55 art Exp $	*/
d1383 3
a1386 1
	return 0;
@


1.21
log
@nswbuf hasn't been used for ages. gc.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.20 2001/11/07 01:18:00 art Exp $	*/
d252 1
a252 1
	printf("total memory = %d\n", physmem * PAGE_SIZE);
@


1.20
log
@Add an alignment argument to uvm_map that specifies an alignment hint
for the virtual address.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.19 2001/11/06 19:53:16 miod Exp $	*/
a388 5
	if (nswbuf == 0) {
		nswbuf = (nbuf / 2) &~ 1;       /* force even */
		if (nswbuf > 256)
			nswbuf = 256;           /* sanity */
	}
@


1.19
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.18 2001/09/19 20:50:57 mickey Exp $	*/
d271 1
a271 1
                    NULL, UVM_UNKNOWN_OFFSET,
d1625 1
a1625 1
	r = uvm_map(kernel_map, &sva, oversize, NULL, UVM_UNKNOWN_OFFSET,
@


1.18
log
@merge vm/vm_kern.h into uvm/uvm_extern.h; art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.17 2001/09/07 16:20:07 deraadt Exp $	*/
a106 1
#include <vm/vm.h>
@


1.18.4.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.18.4.2
log
@Merge in -current
@
text
@d107 1
d253 1
a253 1
	printf("total memory = %ld\n", (long)physmem * PAGE_SIZE);
d272 1
a272 1
                    NULL, UVM_UNKNOWN_OFFSET, 0,
d390 5
d1626 1
a1626 1
	r = uvm_map(kernel_map, &sva, oversize, NULL, UVM_UNKNOWN_OFFSET, 0,
@


1.18.4.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.18.4.2 2001/11/13 21:04:17 niklas Exp $	*/
d796 1
a796 1
		if ((howto & RB_TIMEBAD) == 0 && sparc_clock_time_is_ok) {
a797 3
		} else {
			printf("WARNING: not updating battery clock\n");
		}
d1183 10
a1192 1
		return (EFBIG);
d1235 1
d1284 4
d1300 6
a1305 6
	/*
	 * XXXXXXX The problem with this routine is that it needs to 
	 * lock the user address space that is being loaded, but there
	 * is no real way for us to unlock it during the unload process.
	 * As a result, only UIO_SYSSPACE uio's are allowed for now.
	 */
d1309 2
d1312 15
a1326 2
	if (uio->uio_segflg != UIO_SYSSPACE)
		return (EOPNOTSUPP);
d1328 1
a1328 5
	/* Record for *_unload */
	map->_dm_type = _DM_TYPE_UIO;
	map->_dm_source = (void *)uio;

	i = j = 0;
d1330 4
a1333 3
	while (j < uio->uio_iovcnt) {
		vaddr_t vaddr = (vaddr_t)uio->uio_iov[j].iov_base;
		long buflen = (long)uio->uio_iov[j].iov_len;
d1335 12
d1353 1
a1353 1
			(void) pmap_extract(pmap_kernel(), vaddr, &pa);
d1356 3
d1373 3
a1375 2
		j++;
		if ((uio->uio_iovcnt - j) && i >= MAX_DMA_SEGS) {
d1377 1
a1377 4
			map->_dm_type = 0;
			map->_dm_source = NULL;
			return (E2BIG);
		}
d1379 6
a1384 2

	return (bus_dmamap_load_raw(t, map, segs, i, (bus_size_t)len, flags));
@


1.18.4.4
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a84 2
#include "auxio.h"

d91 1
a139 6
#include "pckbc.h"
#include "pckbd.h"
#if (NPCKBC > 0) && (NPCKBD == 0)
#include <dev/ic/pckbcvar.h>
#endif

d150 1
a152 6
#ifndef BUFCACHEPERCENT
#define BUFCACHEPERCENT 5
#endif

int	bufcachepercent = BUFCACHEPERCENT;

a156 5
#if NAUXIO > 0
#include <sparc64/dev/auxiovar.h>
int sparc_led_blink;
#endif

a222 15
#if (NPCKBC > 0) && (NPCKBD == 0)
/*
 * This is called by the pckbc driver if no pckbd is configured.
 * On the i386, it is used to glue in the old, deprecated console
 * code.  On the sparc64, it does nothing.
 */
int
pckbc_machdep_cnattach(kbctag, kbcslot)
	pckbc_tag_t kbctag;
	pckbc_slot_t kbcslot;
{
	return (ENXIO);
}
#endif

d310 1
a310 1
	pmap_update(pmap_kernel());
d319 6
d362 3
d371 1
a371 1
	 	bufpages = physmem * bufcachepercent / 100;
d377 3
a379 1
	/* Restrict to at most 30% filled kvm */
d381 1
a381 1
	    (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) * 3 / 10)
d383 1
a383 1
		    MAXBSIZE * 3 / 10;
a517 3
#if NAUXIO > 0
	int oldval, ret;
#endif
d546 1
a546 1
				 * `bsd' 
d548 1
a548 1
				cp = "bsd";
a552 16
	case CPU_LED_BLINK:
#if NAUXIO > 0
		oldval = sparc_led_blink;
		ret = sysctl_int(oldp, oldlenp, newp, newlen,
		    &sparc_led_blink);

		/*
		 * If we were false and are now true, call auxio_led_blink().
		 * auxio_led_blink() will catch the other case itself.
		 */
		if (!oldval && sparc_led_blink > oldval)
			auxio_led_blink(NULL);
		return (ret);
#else
		return (EOPNOTSUPP);
#endif
d976 1
a976 1
			pmap_update(pmap_kernel());
d980 1
a980 1
			pmap_update(pmap_kernel());
d1271 1
a1271 1
			return (EFBIG);
d1340 1
a1340 1
			return (EFBIG);
d1671 2
a1672 1
static paddr_t	sparc_bus_mmap __P((bus_space_tag_t, bus_addr_t, off_t, int, int));
d1676 3
a1678 7
static void	sparc_bus_barrier __P((bus_space_tag_t, bus_space_handle_t,
					  bus_size_t, bus_size_t, int));
static int	sparc_bus_alloc __P((bus_space_tag_t, bus_addr_t, bus_addr_t,
					bus_size_t, bus_size_t, bus_size_t, int,
					bus_addr_t *, bus_space_handle_t *));
static void	sparc_bus_free __P((bus_space_tag_t, bus_space_handle_t,
				       bus_size_t));
d1771 1
a1771 1
	pmap_update(pmap_kernel());
d1803 2
a1804 2
paddr_t
sparc_bus_mmap(t, paddr, off, prot, flags)
d1806 4
a1809 4
	bus_addr_t paddr;
	off_t off;
	int prot;
	int flags;
d1811 3
a1813 2
	/* Devices are un-cached... although the driver should do that */
	return ((paddr+off)|PMAP_NC);
d1867 1
a1867 2
void
sparc_bus_barrier (t, h, offset, size, flags)
a1890 25
int
sparc_bus_alloc(t, rs, re, s, a, b, f, ap, hp)
	bus_space_tag_t	t;
	bus_addr_t	rs;
	bus_addr_t	re;
	bus_size_t	s;
	bus_size_t	a;
	bus_size_t	b;
	int		f;
	bus_addr_t	*ap;
	bus_space_handle_t *hp;
{
	return (ENOTTY);
}

void
sparc_bus_free(t, h, s)
	bus_space_tag_t	t;
	bus_space_handle_t	h;
	bus_size_t	s;
{
	return;
}


a1894 2
	sparc_bus_alloc,
	sparc_bus_free,
@


1.18.4.5
log
@Merge in -current from about a week ago
@
text
@d188 3
a190 3
caddr_t	allocsys(caddr_t);
void	dumpsys(void);
void	stackdump(void);
d951 1
a951 1
	register int (*dump)(dev_t, daddr_t, caddr_t, size_t);
d1056 1
a1056 1
void trapdump(struct trapframe64*);
d1100 1
a1100 1
			fp64 = (struct frame64*)(((char *)fp)+BIAS);
d1703 1
a1703 1
static int	sparc_bus_map( bus_space_tag_t, bus_type_t, bus_addr_t,
d1705 4
a1708 4
				    bus_space_handle_t *);
static int	sparc_bus_unmap(bus_space_tag_t, bus_space_handle_t,
				     bus_size_t);
static int	sparc_bus_subregion(bus_space_tag_t, bus_space_handle_t,
d1710 8
a1717 8
					 bus_space_handle_t *);
static paddr_t	sparc_bus_mmap(bus_space_tag_t, bus_addr_t, off_t, int, int);
static void	*sparc_mainbus_intr_establish(bus_space_tag_t, int, int,
						   int, int (*)(void *),
						   void *);
static void	sparc_bus_barrier(bus_space_tag_t, bus_space_handle_t,
					  bus_size_t, bus_size_t, int);
static int	sparc_bus_alloc(bus_space_tag_t, bus_addr_t, bus_addr_t,
d1719 3
a1721 3
					bus_addr_t *, bus_space_handle_t *);
static void	sparc_bus_free(bus_space_tag_t, bus_space_handle_t,
				       bus_size_t);
d1868 1
a1868 1
	int		(*callback)(void *, void *);
d1893 1
a1893 1
	int	(*handler)(void *);
@


1.18.4.6
log
@Sync the SMP branch with 3.3
@
text
@d111 7
d123 6
d147 8
a154 40
int     _bus_dmamap_create(bus_dma_tag_t, bus_dma_tag_t, bus_size_t, int,
	    bus_size_t, bus_size_t, int, bus_dmamap_t *);
void    _bus_dmamap_destroy(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t);
int     _bus_dmamap_load(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t, void *,
            bus_size_t, struct proc *, int);
int     _bus_dmamap_load_mbuf(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t,
            struct mbuf *, int);
int     _bus_dmamap_load_uio(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t,
            struct uio *, int);
int     _bus_dmamap_load_raw(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t,
            bus_dma_segment_t *, int, bus_size_t, int);
void    _bus_dmamap_unload(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t);
void    _bus_dmamap_sync(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t,
	    bus_addr_t, bus_size_t, int);

int     _bus_dmamem_alloc(bus_dma_tag_t, bus_dma_tag_t tag, bus_size_t size,
            bus_size_t alignment, bus_size_t boundary,
            bus_dma_segment_t *segs, int nsegs, int *rsegs, int flags);

void    _bus_dmamem_free(bus_dma_tag_t tag, bus_dma_tag_t,
	    bus_dma_segment_t *segs, int nsegs);
int     _bus_dmamem_map(bus_dma_tag_t tag, bus_dma_tag_t,
	    bus_dma_segment_t *segs, int nsegs, size_t size, caddr_t *kvap,
	    int flags);
void    _bus_dmamem_unmap(bus_dma_tag_t tag, bus_dma_tag_t, caddr_t kva,
            size_t size);
paddr_t _bus_dmamem_mmap(bus_dma_tag_t tag, bus_dma_tag_t,
	    bus_dma_segment_t *segs, int nsegs, off_t off, int prot, int flags);

int     _bus_dmamem_alloc_range(bus_dma_tag_t tag, bus_dma_tag_t,
	    bus_size_t size, bus_size_t alignment, bus_size_t boundary,
            bus_dma_segment_t *segs, int nsegs, int *rsegs, int flags,
            vaddr_t low, vaddr_t high);

/*
 * The "bus_space_debug" flags used by macros elsewhere.
 * A good set of flags to use when first debugging something is:
 * int bus_space_debug = BSDB_ACCESS | BSDB_ASSERT | BSDB_MAP;
 */
int bus_space_debug = 0;
a158 9
/*
 * Declare these as initialized data so we can patch them.
 */
#ifdef	NBUF
int	nbuf = NBUF;
#else
int	nbuf = 0;
#endif

a162 5
#ifdef	BUFPAGES
int	bufpages = BUFPAGES;
#else
int	bufpages = 0;
#endif
a173 11
#ifdef APERTURE
#ifdef INSECURE
int allowaperture = 1;
#else
int allowaperture = 0;
#endif
#endif

extern int ceccerrs;
extern int64_t cecclast;

d192 48
d285 1
d335 3
a337 2
			pmap_kenter_pa(curbuf,
			    VM_PAGE_TO_PHYS(pg), VM_PROT_READ|VM_PROT_WRITE);
d355 1
a355 1
	printf("using %d buffers containing %ld bytes of memory\n", nbuf,
d373 8
d402 2
a403 2
	    (VM_MAX_KERNEL_ADDRESS - VM_MIN_KERNEL_ADDRESS) * 3 / 10)
		nbuf = (VM_MAX_KERNEL_ADDRESS - VM_MIN_KERNEL_ADDRESS) /
d419 1
d424 4
d441 1
d443 1
d455 1
d472 1
a472 1

d518 4
d557 2
a558 2
			 * It can be the empty string if we booted from the
			 * default kernel name.
d564 1
a564 1
			/* Now we've separated the kernel name from the args */
a592 17
	case CPU_ALLOWAPERTURE:
#ifdef APERTURE
		if (securelevel > 0)
			return (sysctl_rdint(oldp, oldlenp, newp,
			    allowaperture));
		else
			return (sysctl_int(oldp, oldlenp, newp, newlen,
			    &allowaperture));
#else
		return (sysctl_rdint(oldp, oldlenp, newp, 0));
#endif
	case CPU_CPUTYPE:
		return (sysctl_rdint(oldp, oldlenp, newp, CPU_SUN4U));
	case CPU_CECCERRORS:
		return (sysctl_rdint(oldp, oldlenp, newp, ceccerrs));
	case CPU_CECCLAST:
		return (sysctl_rdquad(oldp, oldlenp, newp, cecclast));
d618 2
d647 4
d661 1
d663 3
d694 1
a694 2
		printf("sendsig: stack was trashed trying to send sig %d, "
		    "sending SIGILL\n", sig);
d711 1
a711 1
	addr = p->p_sigcode;
d730 1
a730 1
	struct proc *p;
d738 1
a738 1
	struct trapframe64 *tf;
d746 1
a746 2
		printf("sigreturn: rwindow_save(%p) failed, sending SIGILL\n",
		    p);
d777 1
d779 3
d949 1
a949 1
	int psize;
d951 1
a951 1
	int (*dump)(dev_t, daddr_t, caddr_t, size_t);
d953 1
a953 1
	struct mem_region *mp;
d1102 1
a1102 2
			printf("%llx(%llx, %llx, %llx, %llx, %llx, %llx, %llx) "
			    "fp = %llx\n",
d1115 4
a1118 5
			printf("  pc = %x  args = (%x, %x, %x, %x, %x, %x, %x) "
			    "fp = %x\n", fp->fr_pc, fp->fr_arg[0],
			    fp->fr_arg[1], fp->fr_arg[2], fp->fr_arg[3],
			    fp->fr_arg[4], fp->fr_arg[5], fp->fr_arg[6],
			    fp->fr_fp);
d1138 2
a1139 2
_bus_dmamap_create(t, t0, size, nsegments, maxsegsz, boundary, flags, dmamp)
	bus_dma_tag_t t, t0;
d1175 2
a1176 2
	map->_dm_flags = flags & ~(BUS_DMA_WAITOK | BUS_DMA_NOWAIT |
	    BUS_DMA_COHERENT | BUS_DMA_NOWRITE | BUS_DMA_NOCACHE);
d1189 2
a1190 2
_bus_dmamap_destroy(t, t0, map)
	bus_dma_tag_t t, t0;
a1191 1

a1192 10
	/*
	 * Unload the map if it is still loaded.  This is required
	 * by the specification (well, the manpage).  Higher level
	 * drivers, if any, should do this too.  By the time the
	 * system gets here, the higher level "destroy" functions
	 * would probably already have clobbered the data needed
	 * to do a proper unload.
	 */
	if (map->dm_nsegs)
		bus_dmamap_unload(t0, map);
d1208 2
a1209 2
_bus_dmamap_load(t, t0, map, buf, buflen, p, flags)
	bus_dma_tag_t t, t0;
a1253 1
	/* Is this what the above comment calls "one segment"? */
a1254 1

d1263 2
a1264 2
_bus_dmamap_load_mbuf(t, t0, map, m, flags)
	bus_dma_tag_t t, t0;
d1275 1
a1275 1
	map->_dm_source = m;
d1293 2
a1294 3
			if (i > 0 && pa == (segs[i - 1].ds_addr +
			    segs[i - 1].ds_len) && ((segs[i - 1].ds_len + incr)
			    < map->_dm_maxsegsz)) {
d1296 1
a1296 1
				segs[i - 1].ds_len += incr;
d1315 1
a1315 1
	return (bus_dmamap_load_raw(t0, map, segs, i,
d1323 2
a1324 2
_bus_dmamap_load_uio(t, t0, map, uio, flags)
	bus_dma_tag_t t, t0;
d1362 2
a1363 3
			if (i > 0 && pa == (segs[i - 1].ds_addr +
			    segs[i - 1].ds_len) && ((segs[i - 1].ds_len + incr)
			    < map->_dm_maxsegsz)) {
d1365 1
a1365 1
				segs[i - 1].ds_len += incr;
d1384 1
a1384 1
	return (bus_dmamap_load_raw(t0, map, segs, i, (bus_size_t)len, flags));
d1392 2
a1393 2
_bus_dmamap_load_raw(t, t0, map, segs, nsegs, size, flags)
	bus_dma_tag_t t, t0;
d1409 2
a1410 2
_bus_dmamap_unload(t, t0, map)
	bus_dma_tag_t t, t0;
d1418 1
a1418 1
	for (i = 0; i < map->dm_nsegs; i++) {
d1448 2
a1449 2
_bus_dmamap_sync(t, t0, map, offset, len, ops)
	bus_dma_tag_t t, t0;
d1469 1
a1469 1
		membar(Sync);
d1506 2
a1507 2
_bus_dmamem_alloc(t, t0, size, alignment, boundary, segs, nsegs, rsegs, flags)
	bus_dma_tag_t t, t0;
d1572 2
a1573 2
_bus_dmamem_free(t, t0, segs, nsegs)
	bus_dma_tag_t t, t0;
d1593 2
a1594 2
_bus_dmamem_map(t, t0, segs, nsegs, size, kvap, flags)
	bus_dma_tag_t t, t0;
d1602 1
d1616 1
a1616 1
	 * Find a region of kernel virtual addresses that can accommodate
d1632 1
a1632 1
		uvm_unmap(kernel_map, sva, va);
d1634 1
a1634 1
		uvm_unmap(kernel_map, va + size, sva + oversize);
d1638 1
d1648 2
a1649 2
_bus_dmamem_unmap(t, t0, kva, size)
	bus_dma_tag_t t, t0;
d1668 2
a1669 2
_bus_dmamem_mmap(t, t0, segs, nsegs, off, prot, flags)
	bus_dma_tag_t t, t0;
d1703 19
a1721 19
int sparc_bus_map(bus_space_tag_t, bus_space_tag_t, bus_addr_t, bus_size_t,
    int, bus_space_handle_t *);
int sparc_bus_protect(bus_space_tag_t, bus_space_tag_t, bus_space_handle_t,
    bus_size_t, int);
int sparc_bus_unmap(bus_space_tag_t, bus_space_tag_t, bus_space_handle_t,
    bus_size_t);
int sparc_bus_subregion(bus_space_tag_t, bus_space_tag_t,  bus_space_handle_t,
    bus_size_t, bus_size_t, bus_space_handle_t *);
paddr_t sparc_bus_mmap(bus_space_tag_t, bus_space_tag_t, bus_addr_t, off_t,
    int, int);
void *sparc_mainbus_intr_establish(bus_space_tag_t, bus_space_tag_t, int, int,
    int, int (*)(void *), void *);
void sparc_bus_barrier(bus_space_tag_t, bus_space_tag_t,  bus_space_handle_t,
    bus_size_t, bus_size_t, int);
int sparc_bus_alloc(bus_space_tag_t, bus_space_tag_t, bus_addr_t, bus_addr_t,
    bus_size_t, bus_size_t, bus_size_t, int, bus_addr_t *,
    bus_space_handle_t *);
void sparc_bus_free(bus_space_tag_t, bus_space_tag_t, bus_space_handle_t,
    bus_size_t);
d1727 7
a1733 2
sparc_bus_map(bus_space_tag_t t, bus_space_tag_t t0, bus_addr_t	addr,
    bus_size_t size, int flags, bus_space_handle_t *hp)
d1740 1
a1740 5
	if (flags & BUS_SPACE_MAP_PROMADDRESS) {
		hp->bh_ptr = addr;
		return (0);
	}

d1748 2
a1749 2
		    (u_long)IODEV_BASE, (u_long)IODEV_END, M_DEVBUF, 0, 0,
		    EX_NOWAIT);
d1751 2
d1754 1
a1754 3
		char buf[80];
		bus_space_render_tag(t0, buf, sizeof buf);
		printf("\nsparc_bus_map: zero size on %s", buf);
d1757 22
a1778 29

	if ( (LITTLE_ASI(t0->asi) && LITTLE_ASI(t0->sasi)) ||
	    (PHYS_ASI(t0->asi) != PHYS_ASI(t0->sasi)) ) {
		char buf[80];
		bus_space_render_tag(t0, buf, sizeof buf);
		printf("\nsparc_bus_map: mismatched ASIs on %s: asi=%x sasi=%x",
		    buf, t0->asi, t0->sasi);
	}

	if (PHYS_ASI(t0->asi)) {
#ifdef BUS_SPACE_DEBUG
		char buf[80];
		bus_space_render_tag(t0, buf, sizeof buf);
		BUS_SPACE_PRINTF(BSDB_MAP,
		    ("\nsparc_bus_map: physical tag %s asi %x sasi %x flags %x "
		    "paddr %016llx size %016llx",
		    buf,
		    (int)t0->asi, (int)t0->sasi, (int)flags,
		    (unsigned long long)addr, (unsigned long long)size));
#endif /* BUS_SPACE_DEBUG */
		if (flags & BUS_SPACE_MAP_LINEAR) {
			char buf[80];
			bus_space_render_tag(t0, buf, sizeof buf);
			printf("\nsparc_bus_map: linear mapping requested on physical bus %s", buf);
			return (EINVAL);
		}

		hp->bh_ptr = addr;
		return (0);
d1781 1
a1781 1
	size = round_page(size);
d1783 8
a1790 12
	if (LITTLE_ASI(t0->sasi) && !LITTLE_ASI(t0->asi))
		pm_flags |= PMAP_LITTLE;

	if ((flags & BUS_SPACE_MAP_CACHEABLE) == 0)
		pm_flags |= PMAP_NC;

	{ /* scope */
		int err = extent_alloc(io_space, size, NBPG, 0, 0,
		    EX_NOWAIT | EX_BOUNDZERO, (u_long *)&v);
		if (err)
			panic("sparc_bus_map: cannot allocate io_space: %d",
			    err);
d1794 1
a1794 1
	hp->bh_ptr = v | ((u_long)addr & PGOFSET);
d1797 1
a1797 2
	if ((flags & BUS_SPACE_MAP_READONLY) == 0)
		pm_prot |= VM_PROT_WRITE;
d1799 5
a1803 11
#ifdef BUS_SPACE_DEBUG
	{ /* scope */
		char buf[80];
		bus_space_render_tag(t0, buf, sizeof buf);
		BUS_SPACE_PRINTF(BSDB_MAP, ("\nsparc_bus_map: tag %s type %x "
		    "flags %x addr %016llx size %016llx virt %llx paddr "
		    "%016llx", buf, (int)t->default_type, (int) flags,
		    (unsigned long long)addr, (unsigned long long)size,
		    (unsigned long long)hp->bh_ptr, (unsigned long long)pa));
	}
#endif /* BUS_SPACE_DEBUG */
d1806 3
a1808 3
		BUS_SPACE_PRINTF(BSDB_MAPDETAIL, ("\nsparc_bus_map: phys %llx "
		    "virt %p hp->bh_ptr %llx", (unsigned long long)pa,
		    (char *)v, (unsigned long long)hp->bh_ptr));
d1819 6
a1824 3
sparc_bus_subregion(bus_space_tag_t tag, bus_space_tag_t tag0,
    bus_space_handle_t handle, bus_size_t offset, bus_size_t size,
    bus_space_handle_t *nhandlep)
d1826 1
a1826 2
	*nhandlep = handle;
	nhandlep->bh_ptr += offset;
a1829 13
/* stolen from uvm_chgkprot() */
/*
 * Change protections on kernel pages from addr to addr+len
 * (presumably so debugger can plant a breakpoint).
 *
 * We force the protection change at the pmap level.  If we were
 * to use vm_map_protect a change to allow writing would be lazily-
 * applied meaning we would still take a protection fault, something
 * we really don't want to do.  It would also fragment the kernel
 * map unnecessarily.  We cannot use pmap_protect since it also won't
 * enforce a write-enable request.  Using pmap_enter is the only way
 * we can ensure the change takes place properly.
 */
d1831 4
a1834 44
sparc_bus_protect(bus_space_tag_t t, bus_space_tag_t t0, bus_space_handle_t h,
    bus_size_t size, int flags)
{
        vm_prot_t prot;
	paddr_t	pm_flags = 0;
        paddr_t pa;
        vaddr_t sva, eva;
	void* addr = bus_space_vaddr(t0, h);

	if (addr == 0) {
		printf("\nsparc_bus_protect: null address");
		return (EINVAL);
	}

	if (PHYS_ASI(t0->asi)) {
		printf("\nsparc_bus_protect: physical ASI");
		return (EINVAL);
	}

        prot = (flags & BUS_SPACE_MAP_READONLY) ?
	    VM_PROT_READ : VM_PROT_READ | VM_PROT_WRITE;
	if ((flags & BUS_SPACE_MAP_CACHEABLE) == 0)
	    pm_flags |= PMAP_NC;

        eva = round_page((vaddr_t)addr + size);
        for (sva = trunc_page((vaddr_t)addr); sva < eva; sva += PAGE_SIZE) {
                /*
                 * Extract physical address for the page.
                 * We use a cheezy hack to differentiate physical
                 * page 0 from an invalid mapping, not that it
                 * really matters...
                 */
                if (pmap_extract(pmap_kernel(), sva, &pa) == FALSE)
                        panic("bus_space_protect(): invalid page");
                pmap_enter(pmap_kernel(), sva, pa | pm_flags, prot, prot | PMAP_WIRED);
        }
	pmap_update(pmap_kernel());

	return (0);
}

int
sparc_bus_unmap(bus_space_tag_t t, bus_space_tag_t t0, bus_space_handle_t bh,
    bus_size_t size)
d1836 1
a1836 1
	vaddr_t va = trunc_page((vaddr_t)bh.bh_ptr);
a1837 4
	int error;

	if (PHYS_ASI(t0->asi))
		return (0);
d1839 2
a1840 3
	error = extent_free(io_space, va, size, EX_NOWAIT);
	if (error)
		printf("\nsparc_bus_unmap: extent free says %d", error);
d1847 6
a1852 2
sparc_bus_mmap(bus_space_tag_t t, bus_space_tag_t t0, bus_addr_t paddr,
    off_t off, int prot, int flags)
a1853 5
	if (PHYS_ASI(t0->asi)) {
		printf("\nsparc_bus_mmap: physical ASI");
		return (NULL);
	}

d1855 1
a1855 1
	return ((paddr + off) | PMAP_NC);
d1861 9
a1869 2
bus_space_probe(bus_space_tag_t tag, bus_addr_t paddr, bus_size_t size,
    size_t offset, int flags, int (*callback)(void *, void *), void *arg)
d1875 1
a1875 1
	if (bus_space_map(tag, paddr, size, flags, &bh) != 0)
d1878 2
a1879 2
	tmp = bh.bh_ptr;
	result = (probeget(tmp + offset, tag->asi, size) != -1);
d1888 7
a1894 2
sparc_mainbus_intr_establish(bus_space_tag_t t, bus_space_tag_t t0, int	pil,
    int level, int flags, int (*handler)(void *), void *arg)
d1910 6
a1915 2
sparc_bus_barrier(bus_space_tag_t t, bus_space_tag_t t0, bus_space_handle_t h,
    bus_size_t offset, bus_size_t size, int flags)
d1924 1
a1924 1
		membar(Sync);
d1926 1
a1926 1
		membar(Sync);
d1928 1
a1928 1
		membar(Sync);
d1935 10
a1944 3
sparc_bus_alloc(bus_space_tag_t t, bus_space_tag_t t0, bus_addr_t rs,
    bus_addr_t re, bus_size_t s, bus_size_t a, bus_size_t b, int f,
    bus_addr_t *ap, bus_space_handle_t *hp)
d1950 4
a1953 2
sparc_bus_free(bus_space_tag_t t, bus_space_tag_t t0, bus_space_handle_t h,
    bus_size_t s)
d1958 2
a1959 1
static const struct sparc_bus_space_tag _mainbus_space_tag = {
a1962 3
	ASI_PRIMARY,
	ASI_PRIMARY,
	"mainbus",
a1965 1
	sparc_bus_protect,		/* bus_space_protect */
a1971 1
const bus_space_tag_t mainbus_space_tag = &_mainbus_space_tag;
a1975 224

#define _BS_PRECALL(t,f)		\
        while (t->f == NULL)		\
                t = t->parent;
#define _BS_POSTCALL

#define _BS_CALL(t,f)			\
        (*(t)->f)

int
bus_space_alloc(bus_space_tag_t t, bus_addr_t rs, bus_addr_t re, bus_size_t s,
    bus_size_t a, bus_size_t b, int f, bus_addr_t *ap, bus_space_handle_t *hp)
{
        const bus_space_tag_t t0 = t;
        int ret;

        _BS_PRECALL(t, sparc_bus_alloc);
        ret = _BS_CALL(t, sparc_bus_alloc)(t, t0, rs, re, s, a, b, f, ap, hp);
        _BS_POSTCALL;
        return ret;
}

void
bus_space_free(bus_space_tag_t t, bus_space_handle_t h, bus_size_t s)
{
	const bus_space_tag_t t0 = t;

	_BS_PRECALL(t, sparc_bus_free);
	_BS_CALL(t, sparc_bus_free)(t, t0, h, s);
	_BS_POSTCALL;
}

int
bus_space_map(bus_space_tag_t t, bus_addr_t a, bus_size_t s, int f,
    bus_space_handle_t *hp)
{
	const bus_space_tag_t t0 = t;
	int ret;

	_BS_PRECALL(t, sparc_bus_map);
	ret = _BS_CALL(t, sparc_bus_map)(t, t0, a, s, f, hp);
	_BS_POSTCALL;
#ifdef BUS_SPACE_DEBUG
	if(s == 0) {
		char buf[128];
		bus_space_render_tag(t, buf, sizeof buf);
		printf("\n********** bus_space_map: requesting "
		    "zero-length mapping on bus %p:%s",
		    t, buf);
	}
	hp->bh_flags = 0;
	if (ret == 0) {
		hp->bh_size = s;
		hp->bh_tag = t0;
	} else {
		hp->bh_size = 0;
		hp->bh_tag = NULL;
	}
#endif /* BUS_SPACE_DEBUG */
	return (ret);
}

int
bus_space_protect(bus_space_tag_t t, bus_space_handle_t h, bus_size_t s, int f)
{
	const bus_space_tag_t t0 = t;
	int ret;

	_BS_PRECALL(t, sparc_bus_protect);
	ret = _BS_CALL(t, sparc_bus_protect)(t, t0, h, s, f);
	_BS_POSTCALL;

	return (ret);
}

int
bus_space_unmap(bus_space_tag_t t, bus_space_handle_t h, bus_size_t s)
{
	const bus_space_tag_t t0 = t;
	int ret;

	_BS_PRECALL(t, sparc_bus_unmap);
	BUS_SPACE_ASSERT(t0, h, 0, 1);
#ifdef BUS_SPACE_DEBUG
	if(h.bh_size != s) {
		char buf[128];
		bus_space_render_tag(t0, buf, sizeof buf);
		printf("\n********* bus_space_unmap: %p:%s, map/unmap "
		    "size mismatch (%llx != %llx)",
		    t, buf, h.bh_size, s);
	}
#endif /* BUS_SPACE_DEBUG */
	ret = _BS_CALL(t, sparc_bus_unmap)(t, t0, h, s);
	_BS_POSTCALL;
	return (ret);
}

int
bus_space_subregion(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o,
    bus_size_t s, bus_space_handle_t *hp)
{
	const bus_space_tag_t t0 = t;
	int ret;

	_BS_PRECALL(t, sparc_bus_subregion);
	BUS_SPACE_ASSERT(t0, h, o, 1);
#ifdef BUS_SPACE_DEBUG
	if(h.bh_size < o + s) {
		char buf[128];
		bus_space_render_tag(t0, buf, sizeof buf);
		printf("\n********** bus_space_subregion: "
		    "%p:%s, %llx < %llx + %llx", 
		    t0, buf, h.bh_size, o, s);
		hp->bh_size = 0;
		hp->bh_tag = NULL;
		return (EINVAL);
	}
#endif /* BUS_SPACE_DEBUG */
	ret = _BS_CALL(t, sparc_bus_subregion)(t, t0, h, o, s, hp);
	_BS_POSTCALL;
#ifdef BUS_SPACE_DEBUG
	if (ret == 0) {
		hp->bh_size = s;
		hp->bh_tag = t0;
	} else {
		hp->bh_size = 0;
		hp->bh_tag = NULL;
	}
#endif /* BUS_SPACE_DEBUG */
	return (ret);
}

paddr_t
bus_space_mmap(bus_space_tag_t t, bus_addr_t a, off_t o, int p, int f)
{
	const bus_space_tag_t t0 = t;
	paddr_t ret;

	_BS_PRECALL(t, sparc_bus_mmap);
	ret = _BS_CALL(t, sparc_bus_mmap)(t, t0, a, o, p, f);
	_BS_POSTCALL;
	return (ret);
}

void *
bus_intr_establish(bus_space_tag_t t, int p, int l, int f, int (*h)(void *),
    void *a)
{
	const bus_space_tag_t t0 = t;
	void *ret;

	_BS_PRECALL(t, sparc_intr_establish);
	ret = _BS_CALL(t, sparc_intr_establish)(t, t0, p, l, f, h, a);
	_BS_POSTCALL;
	return (ret);
}

/* XXXX Things get complicated if we use unmapped register accesses. */
void *
bus_space_vaddr(bus_space_tag_t t, bus_space_handle_t h)
{
	BUS_SPACE_ASSERT(t, h, 0, 1);
        if(t->asi == ASI_PRIMARY || t->asi == ASI_PRIMARY_LITTLE) 
		return 	((void *)(vaddr_t)(h.bh_ptr));

#ifdef BUS_SPACE_DEBUG
	{ /* Scope */
		char buf[64];
		bus_space_render_tag(t, buf, sizeof buf);
		printf("\nbus_space_vaddr: no vaddr for %p:%s (asi=%x)",
			t, buf, t->asi);
	}
#endif

	return (NULL);
}

void
bus_space_render_tag(bus_space_tag_t t, char* buf, size_t len)
{
	if (t == NULL) {
		strlcat(buf, "<NULL>", len);
		return;
	}
	buf[0] = '\0';
	if (t->parent)
		bus_space_render_tag(t->parent, buf, len);

	strlcat(buf, "/", len);
	strlcat(buf, t->name, len);
}

#ifdef BUS_SPACE_DEBUG

void
bus_space_assert(bus_space_tag_t t, const bus_space_handle_t *h, bus_size_t o,
    int n)
{
        if (h->bh_tag != t) {
		char buf1[128];
		char buf2[128];
		bus_space_render_tag(t, buf1, sizeof buf1);
		bus_space_render_tag(h->bh_tag, buf2, sizeof buf2);
                printf("\n********** bus_space_assert: wrong tag (%p:%s, "
		    "expecting %p:%s) ", t, buf1, h->bh_tag, buf2);
	}

        if (o >= h->bh_size) {
		char buf[128];
		bus_space_render_tag(t, buf, sizeof buf);
                printf("\n********** bus_space_assert: bus %p:%s, offset "
		    "(%llx) out of mapping range (%llx) ", t, buf, o,
		    h->bh_size);
	}

	if (o & (n - 1)) {
		char buf[128];
		bus_space_render_tag(t, buf, sizeof buf);
                printf("\n********** bus_space_assert: bus %p:%s, offset "
		    "(%llx) incorrect alignment (%d) ", t, buf, o, n);
	}
}

#endif /* BUS_SPACE_DEBUG */
@


1.18.4.7
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.18.4.6 2003/03/27 23:42:37 niklas Exp $	*/
d62 5
a66 1
 * 3. Neither the name of the University nor the names of its contributors
d342 2
a343 3
	minaddr = vm_map_min(kernel_map);
	exec_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
	    16*NCARGS, VM_MAP_PAGEABLE, FALSE, NULL);
a1266 9
	/*
	 * Make sure that on error condition we return "no valid mappings".
	 */
 	map->dm_mapsize = 0;
 	map->dm_nsegs = 0;

	if (m->m_pkthdr.len > map->_dm_size)
		return (EINVAL);

a1333 9
	/*
	 * Make sure that on error condition we return "no valid mappings".
	 */
 	map->dm_mapsize = 0;
 	map->dm_nsegs = 0;

	if (uio->uio_resid > map->_dm_size)
		return (EINVAL);

d1409 24
d1451 43
a1493 2
	if (ops & (BUS_DMASYNC_PREWRITE | BUS_DMASYNC_POSTREAD))
		membar(MemIssue);
@


1.18.4.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d791 1
d793 1
d1658 1
a1658 1
    int, int (*)(void *), void *, const char *);
d1897 1
d1899 2
a1900 4
bus_intr_allocate(bus_space_tag_t t, int (*handler)(void *), void *arg,
    int number, int pil,
    volatile u_int64_t *mapper, volatile u_int64_t *clearer,
    const char *what)
a1902 1
	size_t namelen = strlen(what) + 1;
d1905 1
a1905 1
		malloc(sizeof(struct intrhand) + namelen - 1, M_DEVBUF, M_NOWAIT);
a1908 2
	memset(ih, 0, sizeof(struct intrhand) + namelen);

d1911 1
a1911 28
	ih->ih_number = number;
	ih->ih_pil = pil;
	ih->ih_map = mapper;
	ih->ih_clr = clearer;
	ih->ih_bus = t;
	strlcpy(ih->ih_name, what, namelen);

	return (ih);
}

void
bus_intr_free(void *arg)
{
	free(arg, M_DEVBUF);
}

void *
sparc_mainbus_intr_establish(bus_space_tag_t t, bus_space_tag_t t0, int number,
    int pil, int flags, int (*handler)(void *), void *arg, const char *what)
{
	struct intrhand *ih;

	ih = bus_intr_allocate(t0, handler, arg, number, pil, NULL, NULL, what);
	if (ih == NULL)
		return (NULL);

	intr_establish(ih->ih_pil, ih);

d2119 1
a2119 1
    void *a, const char *w)
d2125 1
a2125 1
	ret = _BS_CALL(t, sparc_intr_establish)(t, t0, p, l, f, h, a, w);
@


1.18.4.9
log
@Merge with the trunk
@
text
@d96 1
d787 1
a787 3
		/* (Unless the user explicitly asked for reboot.) */
		if ((howto & RB_USERREQ) == 0)
			howto |= RB_HALT;
@


1.17
log
@do not accidentally clear other ss_flags bits
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.16 2001/09/07 15:44:08 art Exp $	*/
a107 1
#include <vm/vm_kern.h>
@


1.16
log
@Kill the majority of the DEBUG code that's cluttering the signal code.
All this ugliness makes it harder to debug the code.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.15 2001/08/31 06:29:40 art Exp $	*/
d601 1
a601 1
		psp->ps_sigstk.ss_flags = SS_ONSTACK;
@


1.15
log
@clean up sendsig a bit.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.14 2001/08/30 20:06:07 deraadt Exp $	*/
a606 11
#ifdef DEBUG
	sigpid = p->p_pid;
	if ((sigdebug & SDB_KSTACK) && p->p_pid == sigpid) {
		printf("sendsig: %s[%d] sig %d newusp %p scp %p oldsp %p\n",
		    p->p_comm, p->p_pid, sig, fp, &fp->sf_sc, oldsp);
#ifdef DDB
		if (sigdebug & SDB_DDB) Debugger();
#endif
	}
#endif

d652 1
a652 6
#ifdef DEBUG
	if ((sigdebug & SDB_KSTACK))
	    printf("sendsig: saving sf to %p, setting stack pointer %p to %p\n",
		   fp, &(((struct rwindow *)newsp)->rw_in[6]),
		   (void *)(unsigned long)tf->tf_out[6]);
#endif
a660 2
		if ((sigdebug & SDB_KSTACK) && p->p_pid == sigpid)
			printf("sendsig: window save or copyout error\n");
a661 3
#ifdef DDB
		if (sigdebug & SDB_DDB) Debugger();
#endif
a682 10

#ifdef DEBUG
	if ((sigdebug & SDB_KSTACK) && p->p_pid == sigpid) {
		printf("sendsig: about to return to catcher %p thru %p\n", 
		       catcher, (void *)(unsigned long)addr);
#ifdef DDB
		if (sigdebug & SDB_DDB) Debugger();
#endif
	}
#endif
d710 1
a710 3
if (p->p_addr->u_pcb.pcb_nsaved) 
printf("sigreturn: pid %d nsaved %d\n",
       p->p_pid, (p->p_addr->u_pcb.pcb_nsaved));
a713 3
#ifdef DDB
		Debugger();
#endif
a716 9
#ifdef DEBUG
	if (sigdebug & SDB_FOLLOW) {
		printf("sigreturn: %s[%d], sigcntxp %p\n",
		    p->p_comm, p->p_pid, SCARG(uap, sigcntxp));
#ifdef DDB
		if (sigdebug & SDB_DDB) Debugger();
#endif
	}
#endif
d718 2
a719 1
 	if ((vaddr_t)scp & 3 || (error = copyin((caddr_t)scp, &sc, sizeof sc) != 0))
a720 1
	{
a721 2
#ifdef DDB
		Debugger();
a724 3
#else
		return (error);
#endif
d733 2
a734 1
	if (((sc.sc_pc | sc.sc_npc) & 3) != 0 || (sc.sc_pc == 0) || (sc.sc_npc == 0))
a735 1
	{
a738 2
#ifdef DDB
		Debugger();
d742 1
a742 3
#else
		return (EINVAL);
#endif
a753 11
#ifdef DEBUG
	if (sigdebug & SDB_FOLLOW) {
		printf("sigreturn: return trapframe pc=%p sp=%p tstate=%llx\n",
		       (void *)(unsigned long)tf->tf_pc,
		       (void *)(unsigned long)tf->tf_out[6],
		       (unsigned long long)tf->tf_tstate);
#ifdef DDB
		if (sigdebug & SDB_DDB) Debugger();
#endif
	}
#endif
@


1.14
log
@properly handle onstack situation
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.13 2001/08/30 17:58:27 deraadt Exp $	*/
a488 3
#ifdef DDB
	Debugger();
#endif
a582 3
#ifdef NOT_DEBUG
	struct rwindow tmpwin;
#endif
d584 1
a584 1
	int oonstack;
d595 1
a595 1
	oonstack = psp->ps_sigstk.ss_flags & SS_ONSTACK;
d597 1
a597 1
	if ((psp->ps_flags & SAS_ALTSTACK) && !oonstack &&
d633 1
a633 1
	sf.sf_sc.sc_onstack = oonstack;
a634 9
#ifdef COMPAT_13
	/*
	 * XXX We always have to save an old style signal mask because
	 * XXX we might be delivering a signal to a process which will
	 * XXX escape from the signal in a non-standard way and invoke
	 * XXX sigreturn() directly.
	 */
	native_sigset_to_sigset13(mask, &sf.sf_sc.__sc_mask13);
#endif
a670 3
#ifdef NOT_DEBUG
	    copyin(oldsp, &tmpwin, sizeof(tmpwin)) || copyout(&tmpwin, newsp, sizeof(tmpwin)) ||
#endif
@


1.13
log
@correctly deal with layout of sigframe
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.12 2001/08/30 15:26:57 jason Exp $	*/
d590 1
a590 1
	int onstack, oonstack;
d603 2
a604 1
	if (onstack) {
@


1.12
log
@intialize g2 and g7 in trapframe setregs from tf pc so that pc isn't set to
zero when syscall of execve returns.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.11 2001/08/24 00:05:19 art Exp $	*/
d505 1
@


1.11
log
@Theo says that this is probably all that's needed for sigreturn.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.10 2001/08/23 14:01:03 art Exp $	*/
d482 1
@


1.10
log
@We can now move timeout_init into main().
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.9 2001/08/23 12:02:05 art Exp $	*/
a746 1
#if XXX
d842 1
a842 1
	(void) sigprocmask1(p, SIG_SETMASK, &sc.sc_mask, 0);
a843 1
#endif
d948 1
a948 1
	register int nblks, dumpblks;
@


1.9
log
@Remove even more old timeout tentacles.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.8 2001/08/20 20:23:53 jason Exp $	*/
a325 5

	/*
	 * Initialize timeouts
	 */
	timeout_init();
@


1.8
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a353 1
	valloc(timeouts, struct timeout, ntimeout);
@


1.7
log
@_randseed is a u_long
multiply physmem by page size when printing total memory
@
text
@d1 1
@


1.6
log
@SYSV stuff
@
text
@d155 1
a155 1
int	_randseed;
d253 1
a253 1
	printf("total memory = %d\n", physmem);
@


1.5
log
@siginfo support
@
text
@d120 10
@


1.4
log
@sigh. I need sleep.
@
text
@d499 1
a499 1
	int	sf_code;		/* code */
d505 1
a572 2
	panic("sendsig");
#if XXX
d574 1
d583 3
a585 1
	int onstack;
d594 7
a600 8
	onstack =
	    (p->p_sigctx.ps_sigstk.ss_flags & (SS_DISABLE | SS_ONSTACK)) == 0 &&
	    (SIGACTION(p, sig).sa_flags & SA_ONSTACK) != 0;

	if (onstack)
		fp = (struct sigframe *)((caddr_t)p->p_sigctx.ps_sigstk.ss_sp +
						p->p_sigctx.ps_sigstk.ss_size);
	else
d622 1
a622 1
	sf.sf_code = code;
d631 2
a632 2
	sf.sf_sc.sc_onstack = p->p_sigctx.ps_sigstk.ss_flags & SS_ONSTACK;
	sf.sf_sc.sc_mask = *mask;
d654 5
d676 1
d709 1
a709 1
	addr = (vaddr_t)p->p_sigctx.ps_sigcode;
a714 4
	/* Remember that we're now on the signal stack. */
	if (onstack)
		p->p_sigctx.ps_sigstk.ss_flags |= SS_ONSTACK;

a723 1
#endif
d833 1
a833 1
		p->p_sigctx.ps_sigstk.ss_flags |= SS_ONSTACK;
d835 1
a835 1
		p->p_sigctx.ps_sigstk.ss_flags &= ~SS_ONSTACK;
@


1.3
log
@Don't forget to initialize those timeouts.
(and don't forget to sleep)
@
text
@d243 1
a243 1
	printf("total memory = %s\n", physmem);
@


1.2
log
@Unsmoke drugs.
@
text
@d316 5
@


1.1
log
@Lot of stuff... Some from NetBSD, some from OpenBSD, minor modifications
@
text
@d319 3
a321 3
	printf("avail memory = %s\n", uvmexp.free);
	printf("using %d buffers containing %s of memory\n", nbuf,
		bufpages * PAGE_SIZE);
@

