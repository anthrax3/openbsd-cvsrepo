head	1.127;
access;
symbols
	OPENBSD_6_0:1.126.0.2
	OPENBSD_6_0_BASE:1.126
	OPENBSD_5_9:1.124.0.2
	OPENBSD_5_9_BASE:1.124
	OPENBSD_5_8:1.123.0.6
	OPENBSD_5_8_BASE:1.123
	OPENBSD_5_7:1.123.0.2
	OPENBSD_5_7_BASE:1.123
	OPENBSD_5_6:1.120.0.4
	OPENBSD_5_6_BASE:1.120
	OPENBSD_5_5:1.117.0.8
	OPENBSD_5_5_BASE:1.117
	OPENBSD_5_4:1.117.0.4
	OPENBSD_5_4_BASE:1.117
	OPENBSD_5_3:1.117.0.2
	OPENBSD_5_3_BASE:1.117
	OPENBSD_5_2:1.116.0.2
	OPENBSD_5_2_BASE:1.116
	OPENBSD_5_1_BASE:1.114
	OPENBSD_5_1:1.114.0.4
	OPENBSD_5_0:1.114.0.2
	OPENBSD_5_0_BASE:1.114
	OPENBSD_4_9:1.109.0.2
	OPENBSD_4_9_BASE:1.109
	OPENBSD_4_8:1.108.0.2
	OPENBSD_4_8_BASE:1.108
	OPENBSD_4_7:1.107.0.2
	OPENBSD_4_7_BASE:1.107
	OPENBSD_4_6:1.106.0.4
	OPENBSD_4_6_BASE:1.106
	OPENBSD_4_5:1.101.0.2
	OPENBSD_4_5_BASE:1.101
	OPENBSD_4_4:1.97.0.2
	OPENBSD_4_4_BASE:1.97
	OPENBSD_4_3:1.77.0.2
	OPENBSD_4_3_BASE:1.77
	OPENBSD_4_2:1.69.0.2
	OPENBSD_4_2_BASE:1.69
	OPENBSD_4_1:1.59.0.2
	OPENBSD_4_1_BASE:1.59
	OPENBSD_4_0:1.57.0.2
	OPENBSD_4_0_BASE:1.57
	OPENBSD_3_9:1.44.0.2
	OPENBSD_3_9_BASE:1.44
	OPENBSD_3_8:1.41.0.2
	OPENBSD_3_8_BASE:1.41
	OPENBSD_3_7:1.38.0.2
	OPENBSD_3_7_BASE:1.38
	OPENBSD_3_6:1.34.0.4
	OPENBSD_3_6_BASE:1.34
	SMP_SYNC_A:1.34
	SMP_SYNC_B:1.34
	OPENBSD_3_5:1.34.0.2
	OPENBSD_3_5_BASE:1.34
	OPENBSD_3_4:1.33.0.2
	OPENBSD_3_4_BASE:1.33
	UBC_SYNC_A:1.31
	OPENBSD_3_3:1.30.0.2
	OPENBSD_3_3_BASE:1.30
	OPENBSD_3_2:1.26.0.2
	OPENBSD_3_2_BASE:1.26
	OPENBSD_3_1:1.23.0.2
	OPENBSD_3_1_BASE:1.23
	UBC_SYNC_B:1.27
	UBC:1.17.0.2
	UBC_BASE:1.17
	SMP:1.13.0.4
	OPENBSD_3_0:1.13.0.2
	OPENBSD_3_0_BASE:1.13;
locks; strict;
comment	@ * @;


1.127
date	2016.10.18.00.43.57;	author guenther;	state Exp;
branches;
next	1.126;
commitid	ViMtDmKg8K8fZjQi;

1.126
date	2016.06.08.17.24.44;	author tedu;	state Exp;
branches;
next	1.125;
commitid	oK6mhkiIMNMJ6OsK;

1.125
date	2016.03.07.13.21.51;	author naddy;	state Exp;
branches;
next	1.124;
commitid	EDvRPKRZUDEEb6oR;

1.124
date	2015.09.19.21.07.04;	author semarie;	state Exp;
branches;
next	1.123;
commitid	9KMPSlP02LD1SpJP;

1.123
date	2014.11.30.22.26.14;	author kettenis;	state Exp;
branches;
next	1.122;
commitid	SuwbTdviYcmeB8QU;

1.122
date	2014.11.26.20.06.53;	author stsp;	state Exp;
branches;
next	1.121;
commitid	jELYBgAx2QwBsK5n;

1.121
date	2014.09.26.09.45.59;	author stsp;	state Exp;
branches;
next	1.120;
commitid	PtQw1CDVsXssuCkp;

1.120
date	2014.07.12.18.44.43;	author tedu;	state Exp;
branches;
next	1.119;
commitid	uKVPYMN2MLxdZxzH;

1.119
date	2014.05.10.12.29.58;	author kettenis;	state Exp;
branches;
next	1.118;

1.118
date	2014.03.29.18.09.30;	author guenther;	state Exp;
branches;
next	1.117;

1.117
date	2012.08.29.20.33.16;	author kettenis;	state Exp;
branches;
next	1.116;

1.116
date	2012.06.30.22.00.49;	author kettenis;	state Exp;
branches;
next	1.115;

1.115
date	2012.06.27.22.40.38;	author matthew;	state Exp;
branches;
next	1.114;

1.114
date	2011.07.17.22.46.47;	author matthew;	state Exp;
branches;
next	1.113;

1.113
date	2011.07.16.16.48.42;	author matthew;	state Exp;
branches;
next	1.112;

1.112
date	2011.07.05.20.34.45;	author matthew;	state Exp;
branches;
next	1.111;

1.111
date	2011.04.27.09.40.59;	author dlg;	state Exp;
branches;
next	1.110;

1.110
date	2011.04.07.15.30.16;	author miod;	state Exp;
branches;
next	1.109;

1.109
date	2010.11.18.21.13.19;	author miod;	state Exp;
branches;
next	1.108;

1.108
date	2010.08.07.00.13.09;	author krw;	state Exp;
branches;
next	1.107;

1.107
date	2010.01.02.01.20.38;	author kettenis;	state Exp;
branches;
next	1.106;

1.106
date	2009.05.31.21.23.28;	author kettenis;	state Exp;
branches;
next	1.105;

1.105
date	2009.04.19.17.53.39;	author deraadt;	state Exp;
branches;
next	1.104;

1.104
date	2009.04.12.14.53.15;	author kettenis;	state Exp;
branches;
next	1.103;

1.103
date	2009.04.04.21.07.48;	author kettenis;	state Exp;
branches;
next	1.102;

1.102
date	2009.04.04.11.12.46;	author kettenis;	state Exp;
branches;
next	1.101;

1.101
date	2009.02.19.11.12.42;	author kettenis;	state Exp;
branches;
next	1.100;

1.100
date	2009.02.15.15.03.58;	author kettenis;	state Exp;
branches;
next	1.99;

1.99
date	2009.01.16.23.21.32;	author kettenis;	state Exp;
branches;
next	1.98;

1.98
date	2009.01.03.22.09.29;	author kettenis;	state Exp;
branches;
next	1.97;

1.97
date	2008.07.21.04.35.54;	author todd;	state Exp;
branches;
next	1.96;

1.96
date	2008.07.06.08.53.38;	author kettenis;	state Exp;
branches;
next	1.95;

1.95
date	2008.07.06.07.25.04;	author kettenis;	state Exp;
branches;
next	1.94;

1.94
date	2008.07.05.23.08.08;	author kettenis;	state Exp;
branches;
next	1.93;

1.93
date	2008.07.04.18.48.45;	author kettenis;	state Exp;
branches;
next	1.92;

1.92
date	2008.07.04.17.20.27;	author kettenis;	state Exp;
branches;
next	1.91;

1.91
date	2008.06.10.16.49.01;	author kettenis;	state Exp;
branches;
next	1.90;

1.90
date	2008.06.10.00.02.09;	author kettenis;	state Exp;
branches;
next	1.89;

1.89
date	2008.05.24.20.02.19;	author kettenis;	state Exp;
branches;
next	1.88;

1.88
date	2008.05.21.19.23.15;	author kettenis;	state Exp;
branches;
next	1.87;

1.87
date	2008.04.14.21.04.56;	author kettenis;	state Exp;
branches;
next	1.86;

1.86
date	2008.04.12.14.59.30;	author kettenis;	state Exp;
branches;
next	1.85;

1.85
date	2008.03.31.22.14.01;	author kettenis;	state Exp;
branches;
next	1.84;

1.84
date	2008.03.30.12.30.01;	author kettenis;	state Exp;
branches;
next	1.83;

1.83
date	2008.03.22.21.10.28;	author kettenis;	state Exp;
branches;
next	1.82;

1.82
date	2008.03.17.23.10.21;	author kettenis;	state Exp;
branches;
next	1.81;

1.81
date	2008.03.14.17.04.48;	author kettenis;	state Exp;
branches;
next	1.80;

1.80
date	2008.03.13.23.03.02;	author kettenis;	state Exp;
branches;
next	1.79;

1.79
date	2008.03.08.22.53.02;	author kettenis;	state Exp;
branches;
next	1.78;

1.78
date	2008.03.08.16.30.36;	author kettenis;	state Exp;
branches;
next	1.77;

1.77
date	2008.03.01.15.56.09;	author kettenis;	state Exp;
branches;
next	1.76;

1.76
date	2008.03.01.14.42.42;	author kettenis;	state Exp;
branches;
next	1.75;

1.75
date	2007.11.16.23.27.28;	author kettenis;	state Exp;
branches;
next	1.74;

1.74
date	2007.10.31.22.21.43;	author kettenis;	state Exp;
branches;
next	1.73;

1.73
date	2007.10.25.18.48.00;	author deraadt;	state Exp;
branches;
next	1.72;

1.72
date	2007.10.25.05.19.55;	author deraadt;	state Exp;
branches;
next	1.71;

1.71
date	2007.10.17.21.23.28;	author kettenis;	state Exp;
branches;
next	1.70;

1.70
date	2007.10.14.18.31.29;	author kettenis;	state Exp;
branches;
next	1.69;

1.69
date	2007.08.07.21.20.54;	author kettenis;	state Exp;
branches;
next	1.68;

1.68
date	2007.07.29.20.22.07;	author kettenis;	state Exp;
branches;
next	1.67;

1.67
date	2007.06.01.19.25.10;	author deraadt;	state Exp;
branches;
next	1.66;

1.66
date	2007.05.13.09.16.05;	author kettenis;	state Exp;
branches;
next	1.65;

1.65
date	2007.05.04.19.30.55;	author deraadt;	state Exp;
branches;
next	1.64;

1.64
date	2007.05.04.03.44.44;	author deraadt;	state Exp;
branches;
next	1.63;

1.63
date	2007.04.30.18.37.00;	author deraadt;	state Exp;
branches;
next	1.62;

1.62
date	2007.04.30.18.05.21;	author deraadt;	state Exp;
branches;
next	1.61;

1.61
date	2007.04.07.14.15.10;	author kettenis;	state Exp;
branches;
next	1.60;

1.60
date	2007.03.15.20.50.35;	author kettenis;	state Exp;
branches;
next	1.59;

1.59
date	2007.02.12.19.53.36;	author gwk;	state Exp;
branches;
next	1.58;

1.58
date	2006.11.28.16.56.50;	author dlg;	state Exp;
branches;
next	1.57;

1.57
date	2006.08.10.01.11.13;	author gwk;	state Exp;
branches;
next	1.56;

1.56
date	2006.06.01.01.17.25;	author jason;	state Exp;
branches;
next	1.55;

1.55
date	2006.05.31.20.11.31;	author jason;	state Exp;
branches;
next	1.54;

1.54
date	2006.05.31.01.03.20;	author jason;	state Exp;
branches;
next	1.53;

1.53
date	2006.05.30.23.24.15;	author jason;	state Exp;
branches;
next	1.52;

1.52
date	2006.05.30.19.37.29;	author jason;	state Exp;
branches;
next	1.51;

1.51
date	2006.05.28.19.09.39;	author jason;	state Exp;
branches;
next	1.50;

1.50
date	2006.05.28.18.04.41;	author jason;	state Exp;
branches;
next	1.49;

1.49
date	2006.05.28.06.11.26;	author jason;	state Exp;
branches;
next	1.48;

1.48
date	2006.05.28.03.22.35;	author henning;	state Exp;
branches;
next	1.47;

1.47
date	2006.05.28.02.49.18;	author jason;	state Exp;
branches;
next	1.46;

1.46
date	2006.04.09.12.02.23;	author miod;	state Exp;
branches;
next	1.45;

1.45
date	2006.03.15.20.20.41;	author miod;	state Exp;
branches;
next	1.44;

1.44
date	2006.02.06.17.19.31;	author jmc;	state Exp;
branches;
next	1.43;

1.43
date	2005.12.27.18.31.11;	author miod;	state Exp;
branches;
next	1.42;

1.42
date	2005.10.06.19.53.40;	author brad;	state Exp;
branches;
next	1.41;

1.41
date	2005.05.14.19.27.38;	author brad;	state Exp;
branches;
next	1.40;

1.40
date	2005.05.01.18.15.49;	author miod;	state Exp;
branches;
next	1.39;

1.39
date	2005.04.21.00.15.43;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2005.03.15.18.46.39;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2004.12.25.23.02.25;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2004.10.23.08.21.27;	author mjc;	state Exp;
branches;
next	1.35;

1.35
date	2004.09.28.15.15.50;	author jason;	state Exp;
branches;
next	1.34;

1.34
date	2003.12.12.12.33.45;	author jmc;	state Exp;
branches;
next	1.33;

1.33
date	2003.07.31.17.23.24;	author jason;	state Exp;
branches;
next	1.32;

1.32
date	2003.06.02.23.27.56;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	2003.04.06.18.54.19;	author ho;	state Exp;
branches;
next	1.30;

1.30
date	2003.02.17.01.29.20;	author henric;	state Exp;
branches;
next	1.29;

1.29
date	2002.11.20.04.26.44;	author jason;	state Exp;
branches;
next	1.28;

1.28
date	2002.11.13.19.41.53;	author jason;	state Exp;
branches;
next	1.27;

1.27
date	2002.10.12.01.09.43;	author krw;	state Exp;
branches;
next	1.26;

1.26
date	2002.09.04.18.25.31;	author jason;	state Exp;
branches;
next	1.25;

1.25
date	2002.06.15.17.23.31;	author art;	state Exp;
branches;
next	1.24;

1.24
date	2002.06.07.19.31.08;	author jason;	state Exp;
branches;
next	1.23;

1.23
date	2002.04.10.04.17.50;	author jason;	state Exp;
branches;
next	1.22;

1.22
date	2002.03.22.16.29.46;	author jason;	state Exp;
branches;
next	1.21;

1.21
date	2002.03.14.03.16.01;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2002.03.14.01.26.45;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2002.01.25.23.54.40;	author jason;	state Exp;
branches;
next	1.18;

1.18
date	2002.01.16.20.50.17;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2001.12.07.05.11.14;	author jason;	state Exp;
branches
	1.17.2.1;
next	1.16;

1.16
date	2001.12.05.23.58.41;	author tdeval;	state Exp;
branches;
next	1.15;

1.15
date	2001.12.05.02.09.33;	author jason;	state Exp;
branches;
next	1.14;

1.14
date	2001.11.06.19.53.16;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2001.09.28.22.20.48;	author jason;	state Exp;
branches
	1.13.4.1;
next	1.12;

1.12
date	2001.09.26.20.21.04;	author jason;	state Exp;
branches;
next	1.11;

1.11
date	2001.09.20.00.01.34;	author jason;	state Exp;
branches;
next	1.10;

1.10
date	2001.09.19.21.44.35;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2001.09.19.21.32.20;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2001.09.18.17.25.24;	author jason;	state Exp;
branches;
next	1.7;

1.7
date	2001.08.31.15.12.05;	author jason;	state Exp;
branches;
next	1.6;

1.6
date	2001.08.25.12.29.56;	author art;	state Exp;
branches;
next	1.5;

1.5
date	2001.08.23.15.20.48;	author art;	state Exp;
branches;
next	1.4;

1.4
date	2001.08.22.05.08.11;	author jason;	state Exp;
branches;
next	1.3;

1.3
date	2001.08.20.19.40.43;	author jason;	state Exp;
branches;
next	1.2;

1.2
date	2001.08.19.15.31.06;	author art;	state Exp;
branches;
next	1.1;

1.1
date	2001.08.19.05.21.38;	author jason;	state Exp;
branches;
next	;

1.13.4.1
date	2001.10.31.03.07.58;	author nate;	state Exp;
branches;
next	1.13.4.2;

1.13.4.2
date	2001.11.13.21.04.17;	author niklas;	state Exp;
branches;
next	1.13.4.3;

1.13.4.3
date	2002.03.06.02.04.47;	author niklas;	state Exp;
branches;
next	1.13.4.4;

1.13.4.4
date	2002.03.28.11.23.52;	author niklas;	state Exp;
branches;
next	1.13.4.5;

1.13.4.5
date	2003.03.27.23.42.37;	author niklas;	state Exp;
branches;
next	1.13.4.6;

1.13.4.6
date	2003.05.13.19.41.09;	author ho;	state Exp;
branches;
next	1.13.4.7;

1.13.4.7
date	2003.06.07.11.14.45;	author ho;	state Exp;
branches;
next	1.13.4.8;

1.13.4.8
date	2004.02.19.10.50.00;	author niklas;	state Exp;
branches;
next	;

1.17.2.1
date	2002.01.31.22.55.24;	author niklas;	state Exp;
branches;
next	1.17.2.2;

1.17.2.2
date	2002.06.11.03.38.43;	author art;	state Exp;
branches;
next	1.17.2.3;

1.17.2.3
date	2002.10.29.00.28.11;	author art;	state Exp;
branches;
next	1.17.2.4;

1.17.2.4
date	2003.05.19.21.46.57;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.127
log
@Delete remnants of "traptrace" support

ok deraadt@@
@
text
@/*	$OpenBSD: autoconf.c,v 1.126 2016/06/08 17:24:44 tedu Exp $	*/
/*	$NetBSD: autoconf.c,v 1.51 2001/07/24 19:32:11 eeh Exp $ */

/*
 * Copyright (c) 1996
 *    The President and Fellows of Harvard College. All rights reserved.
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
 *
 * All advertising materials mentioning features or use of this software
 * must display the following acknowledgement:
 *	This product includes software developed by Harvard University.
 *	This product includes software developed by the University of
 *	California, Lawrence Berkeley Laboratory.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)autoconf.c	8.4 (Berkeley) 10/1/93
 */

#include "mpath.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/disklabel.h>
#include <sys/device.h>
#include <sys/disk.h>
#include <sys/conf.h>
#include <sys/reboot.h>
#include <sys/socket.h>
#include <sys/malloc.h>
#include <sys/queue.h>
#include <sys/msgbuf.h>

#include <net/if.h>

#include <dev/cons.h>
#include <dev/clock_subr.h>

#include <uvm/uvm_extern.h>

#include <machine/bus.h>
#include <machine/boot_flag.h>
#include <machine/autoconf.h>
#include <machine/hypervisor.h>
#include <machine/mdesc.h>
#include <machine/openfirm.h>
#include <machine/sparc64.h>
#include <machine/cpu.h>
#include <machine/pmap.h>
#include <machine/trap.h>
#include <sparc64/sparc64/cache.h>
#include <sparc64/sparc64/timerreg.h>
#include <sparc64/dev/vbusvar.h>
#include <sparc64/dev/cbusvar.h>

#include <stand/boot/bootarg.h>

#include <dev/ata/atavar.h>
#include <dev/pci/pcivar.h>
#include <dev/sbus/sbusvar.h>

#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>
#if NMPATH > 0
#include <scsi/mpathvar.h>
#endif

#ifdef DDB
#include <machine/db_machdep.h>
#include <ddb/db_sym.h>
#include <ddb/db_extern.h>
#endif

#include "softraid.h"
#if NSOFTRAID > 0
#include <sys/sensors.h>
#include <dev/softraidvar.h>

/* XXX */
#undef DPRINTF
#undef DNPRINTF
#endif

int printspl = 0;

/*
 * The following several variables are related to
 * the configuration process, and are used in initializing
 * the machine.
 */
int	stdinnode;	/* node ID of ROM's console input device */
int	fbnode;		/* node ID of ROM's console output device */
int	optionsnode;	/* node ID of ROM's options */

static	int rootnode;

/* for hw.product/vendor see sys/kern/kern_sysctl.c */
extern char *hw_prod, *hw_vendor;

static	char *str2hex(char *, long *);
static	int mbprint(void *, const char *);
void	sync_crash(void);
int	mainbus_match(struct device *, void *, void *);
static	void mainbus_attach(struct device *, struct device *, void *);
int	get_ncpus(void);

struct device *booted_device;
struct	bootpath bootpath[16];
int	nbootpath;
int	bootnode;
static	void bootpath_build(void);
static	void bootpath_print(struct bootpath *);
void bootpath_nodes(struct bootpath *, int);

struct openbsd_bootdata obd __attribute__((section(".openbsd.bootdata")));

int bus_class(struct device *);
int instance_match(struct device *, void *, struct bootpath *bp);
void nail_bootdev(struct device *, struct bootpath *);

/* Global interrupt mappings for all device types.  Match against the OBP
 * 'device_type' property. 
 */
struct intrmap intrmap[] = {
	{ "block",	PIL_FD },	/* Floppy disk */
	{ "serial",	PIL_SER },	/* zs */
	{ "scsi",	PIL_SCSI },
	{ "scsi-2",	PIL_SCSI },
	{ "network",	PIL_NET },
	{ "display",	PIL_VIDEO },
	{ "audio",	PIL_AUD },
	{ "ide",	PIL_SCSI },
/* The following devices don't have device types: */
	{ "SUNW,CS4231",	PIL_AUD },
	{ NULL,		0 }
};

#ifdef SUN4V
void	sun4v_soft_state_init(void);
void	sun4v_set_soft_state(int, const char *);

#define __align32 __attribute__((__aligned__(32)))
char sun4v_soft_state_booting[] __align32 = "OpenBSD booting";
char sun4v_soft_state_running[] __align32 = "OpenBSD running";
#endif

#ifdef DEBUG
#define ACDB_BOOTDEV	0x1
#define	ACDB_PROBE	0x2
int autoconf_debug = 0x0;
#define DPRINTF(l, s)   do { if (autoconf_debug & l) printf s; } while (0)
#else
#define DPRINTF(l, s)
#endif

/*
 * Convert hex ASCII string to a value.  Returns updated pointer.
 * Depends on ASCII order (this *is* machine-dependent code, you know).
 */
static char *
str2hex(char *str, long *vp)
{
	long v;
	int c;

	if (*str == 'w') {
		for (v = 1;; v++) {
			if (str[v] >= '0' && str[v] <= '9')
				continue;
			if (str[v] >= 'a' && str[v] <= 'f')
				continue;
			if (str[v] >= 'A' && str[v] <= 'F')
				continue;
			if (str[v] == '\0' || str[v] == ',')
				break;
			*vp = 0;
			return (str + v);
		}
		str++;
	}

	for (v = 0;; v = v * 16 + c, str++) {
		c = *(u_char *)str;
		if (c <= '9') {
			if ((c -= '0') < 0)
				break;
		} else if (c <= 'F') {
			if ((c -= 'A' - 10) < 10)
				break;
		} else if (c <= 'f') {
			if ((c -= 'a' - 10) < 10)
				break;
		} else
			break;
	}
	*vp = v;
	return (str);
}

/*
 * Hunt through the device tree for CPUs.  There should be no need to
 * go more than four levels deep; an UltraSPARC-IV on Seregeti shows
 * up as /ssm@@0,0/cmp@@0,0/cpu@@0 and a SPARC64-VI will show up as
 * /cmp@@0,0/core@@0/cpu@@0.
 */
int
get_ncpus(void)
{
	int node, child, stack[4], depth, ncpus;
	char buf[32];

	stack[0] = findroot();
	depth = 0;

	ncpus = 0;
	for (;;) {
		node = stack[depth];

		if (node == 0 || node == -1) {
			if (--depth < 0)
				goto done;
			
			stack[depth] = OF_peer(stack[depth]);
			continue;
		}

		if (OF_getprop(node, "device_type", buf, sizeof(buf)) > 0 &&
		    strcmp(buf, "cpu") == 0)
			ncpus++;

		child = OF_child(node);
		if (child != 0 && child != -1 && depth < 3)
			stack[++depth] = child;
		else
			stack[depth] = OF_peer(stack[depth]);
	}

done:
	ncpusfound = ncpus;
#ifdef MULTIPROCESSOR
	return (ncpus);
#else
	return (1);
#endif
}

/*
 * locore.s code calls bootstrap() just before calling main().
 *
 * What we try to do is as follows:
 *
 * 1) We will try to re-allocate the old message buffer.
 *
 * 2) We will then get the list of the total and available
 *	physical memory and available virtual memory from the
 *	prom.
 *
 * 3) We will pass the list to pmap_bootstrap to manage them.
 *
 * We will try to run out of the prom until we get to cpu_init().
 */
void
bootstrap(int nctx)
{
	extern int end;	/* End of kernel */
	struct trapvec *romtba;
#if defined(SUN4US) || defined(SUN4V)
	char buf[32];
#endif
	int impl = 0;
	int ncpus;

	/* Initialize the PROM console so printf will not panic. */
	(*cn_tab->cn_init)(cn_tab);

	/* 
	 * Initialize ddb first and register OBP callbacks.
	 * We can do this because ddb_init() does not allocate anything,
	 * just initializes some pointers to important things
	 * like the symtab.
	 *
	 * By doing this first and installing the OBP callbacks
	 * we get to do symbolic debugging of pmap_bootstrap().
	 */
#ifdef DDB
	db_machine_init();
	ddb_init();
	/* This can only be installed on an 64-bit system cause otherwise our stack is screwed */
	OF_set_symbol_lookup(OF_sym2val, OF_val2sym);
#endif

#if defined (SUN4US) || defined(SUN4V)
	if (OF_getprop(findroot(), "compatible", buf, sizeof(buf)) > 0) {
		if (strcmp(buf, "sun4us") == 0)
			cputyp = CPU_SUN4US;
		if (strcmp(buf, "sun4v") == 0)
			cputyp = CPU_SUN4V;
	}
#endif

	/* We cannot read %ver on sun4v systems. */
	if (CPU_ISSUN4U || CPU_ISSUN4US)
		impl = (getver() & VER_IMPL) >> VER_IMPL_SHIFT;

	if (impl >= IMPL_CHEETAH) {
		extern vaddr_t dlflush_start;
		vaddr_t *pva;
		u_int32_t insn;

		for (pva = &dlflush_start; *pva; pva++) {
			insn = *(u_int32_t *)(*pva);
			insn &= ~(ASI_DCACHE_TAG << 5);
			insn |= (ASI_DCACHE_INVALIDATE << 5);
			*(u_int32_t *)(*pva) = insn;
			flush((void *)(*pva));
		}

		cacheinfo.c_dcache_flush_page = us3_dcache_flush_page;
	}

	if ((impl >= IMPL_ZEUS && impl <= IMPL_JUPITER) || CPU_ISSUN4V) {
		extern vaddr_t dlflush_start;
		vaddr_t *pva;

		for (pva = &dlflush_start; *pva; pva++) {
			*(u_int32_t *)(*pva) = 0x01000000; /* nop */
			flush((void *)(*pva));
		}

		cacheinfo.c_dcache_flush_page = no_dcache_flush_page;
	}

#ifdef MULTIPROCESSOR
	if (impl >= IMPL_OLYMPUS_C && impl <= IMPL_JUPITER) {
		struct sun4u_patch {
			u_int32_t addr;
			u_int32_t insn;
		} *p;

		extern struct sun4u_patch sun4u_mtp_patch;
		extern struct sun4u_patch sun4u_mtp_patch_end;

		for (p = &sun4u_mtp_patch; p < &sun4u_mtp_patch_end; p++) {
			*(u_int32_t *)(vaddr_t)p->addr = p->insn;
			flush((void *)(vaddr_t)p->addr);
		}
	}
#endif

#ifdef SUN4V
	if (CPU_ISSUN4V) {
		u_int32_t insn;
		int32_t disp;

		disp = (vaddr_t)hv_mmu_demap_page - (vaddr_t)sp_tlb_flush_pte;
		insn = 0x10800000 | disp >> 2;	/* ba hv_mmu_demap_page */
		((u_int32_t *)sp_tlb_flush_pte)[0] = insn;
		insn = 0x94102003; 		/* mov MAP_ITLB|MAP_DTLB, %o2 */
		((u_int32_t *)sp_tlb_flush_pte)[1] = insn;

		disp =  (vaddr_t)hv_mmu_demap_ctx - (vaddr_t)sp_tlb_flush_ctx;
		insn = 0x10800000 | disp >> 2;	/* ba hv_mmu_demap_ctx */
		((u_int32_t *)sp_tlb_flush_ctx)[0] = insn;
		insn = 0x94102003; 		/* mov MAP_ITLB|MAP_DTLB, %o2 */
		((u_int32_t *)sp_tlb_flush_ctx)[1] = insn;

	{
		struct sun4v_patch {
			u_int32_t addr;
			u_int32_t insn;
		} *p;

		extern struct sun4v_patch sun4v_patch;
		extern struct sun4v_patch sun4v_patch_end;

		for (p = &sun4v_patch; p < &sun4v_patch_end; p++) {
			*(u_int32_t *)(vaddr_t)p->addr = p->insn;
			flush((void *)(vaddr_t)p->addr);
		}

#ifdef MULTIPROCESSOR
		extern struct sun4v_patch sun4v_mp_patch;
		extern struct sun4v_patch sun4v_mp_patch_end;

		for (p = &sun4v_mp_patch; p < &sun4v_mp_patch_end; p++) {
			*(u_int32_t *)(vaddr_t)p->addr = p->insn;
			flush((void *)(vaddr_t)p->addr);
		}
#endif
	}

	}
#endif

	/*
	 * Copy over the OBP breakpoint trap vector; OpenFirmware 5.x
	 * needs it to be able to return to the ok prompt.
	 */
	romtba = (struct trapvec *)sparc_rdpr(tba);
	bcopy(&romtba[T_MON_BREAKPOINT], &trapbase[T_MON_BREAKPOINT],
	    sizeof(struct trapvec));
	flush((void *)trapbase);

	ncpus = get_ncpus();
	pmap_bootstrap(KERNBASE, (u_long)&end, nctx, ncpus);

#ifdef SUN4V
	if (CPU_ISSUN4V) {
		sun4v_soft_state_init();
		sun4v_set_soft_state(SIS_TRANSITION, sun4v_soft_state_booting);
	}
#endif
}

void
bootpath_nodes(struct bootpath *bp, int nbp)
{
	int chosen;
	int i;
	char buf[128], *cp, c;

	chosen = OF_finddevice("/chosen");
	OF_getprop(chosen, "bootpath", buf, sizeof(buf));
	cp = buf;

	for (i = 0; i < nbp; i++, bp++) {
		if (*cp == '\0')
			return;
		while (*cp != '\0' && *cp == '/')
			cp++;
		while (*cp && *cp != '/')
			cp++;
		c = *cp;
		*cp = '\0';
		bootnode = bp->node = OF_finddevice(buf);
		*cp = c;
	}
}

/*
 * bootpath_build: build a bootpath. Used when booting a generic
 * kernel to find our root device.  Newer proms give us a bootpath,
 * for older proms we have to create one.  An element in a bootpath
 * has 4 fields: name (device name), val[0], val[1], and val[2]. Note that:
 * Interpretation of val[] is device-dependent. Some examples:
 *
 * if (val[0] == -1) {
 *	val[1] is a unit number    (happens most often with old proms)
 * } else {
 *	[sbus device] val[0] is a sbus slot, and val[1] is an sbus offset
 *	[scsi disk] val[0] is target, val[1] is lun, val[2] is partition
 *	[scsi tape] val[0] is target, val[1] is lun, val[2] is file #
 *	[pci device] val[0] is device, val[1] is function, val[2] might be partition
 * }
 *
 */

static void
bootpath_build(void)
{
	register char *cp, *pp;
	register struct bootpath *bp;
	register long chosen;
	char buf[128];

	bzero((void *)bootpath, sizeof(bootpath));
	bp = bootpath;

	/*
	 * Grab boot path from PROM
	 */
	chosen = OF_finddevice("/chosen");
	OF_getprop(chosen, "bootpath", buf, sizeof(buf));
	cp = buf;
	while (cp != NULL && *cp == '/') {
		/* Step over '/' */
		++cp;
		/* Extract name */
		pp = bp->name;
		while (*cp != '@@' && *cp != '/' && *cp != '\0')
			*pp++ = *cp++;
		*pp = '\0';
		if (*cp == '@@') {
			cp = str2hex(++cp, &bp->val[0]);
			if (*cp == ',')
				cp = str2hex(++cp, &bp->val[1]);
			if (*cp == ':') {
				/*
				 * We only store one character here, as we will
				 * only use this field to compute a partition
				 * index for block devices.  However, it might
				 * be an ethernet media specification, so be
				 * sure to skip all letters.
				 */
				bp->val[2] = *++cp - 'a';
				while (*cp != '\0' && *cp != '/')
					cp++;
			}
		} else {
			bp->val[0] = -1; /* no #'s: assume unit 0, no
					    sbus offset/address */
		}
		++bp;
		++nbootpath;
	}
	bp->name[0] = 0;
	
	bootpath_nodes(bootpath, nbootpath);
	
	/* Setup pointer to boot flags */
	OF_getprop(chosen, "bootargs", buf, sizeof(buf));
	cp = buf;

	/* Find start of boot flags */
	while (*cp) {
		while(*cp == ' ' || *cp == '\t') cp++;
		if (*cp == '-' || *cp == '\0')
			break;
		while(*cp != ' ' && *cp != '\t' && *cp != '\0') cp++;
		
	}
	if (*cp != '-')
		return;

	for (;*++cp;) {
		int fl;

		fl = 0;
		switch(*cp) {
		case 'a':
			fl |= RB_ASKNAME;
			break;
		case 'b':
			fl |= RB_HALT;
			break;
		case 'c':
			fl |= RB_CONFIG;
			break;
		case 'd':
			fl |= RB_KDB;
			break;
		case 's':
			fl |= RB_SINGLE;
			break;
		default:
			break;
		}
		if (!fl) {
			printf("unknown option `%c'\n", *cp);
			continue;
		}
		boothowto |= fl;

		/* specialties */
		if (*cp == 'd') {
#if defined(DDB)
			Debugger();
#else
			printf("kernel has no debugger\n");
#endif
		}
	}
}

/*
 * print out the bootpath
 * the %x isn't 0x%x because the Sun EPROMs do it this way, and
 * consistency with the EPROMs is probably better here.
 */

static void
bootpath_print(struct bootpath *bp)
{
	printf("bootpath: ");
	while (bp->name[0]) {
		if (bp->val[0] == -1)
			printf("/%s%lx", bp->name, bp->val[1]);
		else
			printf("/%s@@%lx,%lx", bp->name, bp->val[0], bp->val[1]);
		if (bp->val[2] != 0)
			printf(":%c", (int)bp->val[2] + 'a');
		bp++;
	}
	printf("\n");
}


/*
 * save or read a bootpath pointer from the boothpath store.
 *
 * XXX. required because of SCSI... we don't have control over the "sd"
 * device, so we can't set boot device there.   we patch in with
 * device_register(), and use this to recover the bootpath.
 */
struct bootpath *
bootpath_store(int storep, struct bootpath *bp)
{
	static struct bootpath *save;
	struct bootpath *retval;

	retval = save;
	if (storep)
		save = bp;

	return (retval);
}

/*
 * Determine mass storage and memory configuration for a machine.
 * We get the PROM's root device and make sure we understand it, then
 * attach it as `mainbus0'.  We also set up to handle the PROM `sync'
 * command.
 */
void
cpu_configure(void)
{
#ifdef SUN4V
	int pause = 0;

	if (CPU_ISSUN4V) {
		const char *prop;
		size_t len;
		int idx;

		mdesc_init();
		idx = mdesc_find_node("cpu");
		prop = mdesc_get_prop_data(idx, "hwcap-list", &len);
		if (prop) {
			while (len > 0) {
				if (strcmp(prop, "pause") == 0)
					pause = 1;
				len -= strlen(prop) + 1;
				prop += strlen(prop) + 1;
			}
		}
	}

	if (pause) {
		struct sun4v_patch {
			u_int32_t addr;
			u_int32_t insn;
		} *p;
		paddr_t pa;

		extern struct sun4v_patch sun4v_pause_patch;
		extern struct sun4v_patch sun4v_pause_patch_end;

		/*
		 * Use physical addresses to patch since kernel .text
		 * is already mapped read-only at this point.
		 */
		for (p = &sun4v_pause_patch; p < &sun4v_pause_patch_end; p++) {
			pmap_extract(pmap_kernel(), (vaddr_t)p->addr, &pa);
			stwa(pa, ASI_PHYS_NON_CACHED, p->insn);
			flush((void *)(vaddr_t)p->addr);
		}
	}
#endif

	if (obd.version == BOOTDATA_VERSION &&
	    obd.len == sizeof(struct openbsd_bootdata)) {
#if NSOFTRAID > 0
		memcpy(sr_bootuuid.sui_id, obd.sr_uuid,
		    sizeof(sr_bootuuid.sui_id));
		memcpy(sr_bootkey, obd.sr_maskkey, sizeof(sr_bootkey));
#endif
		explicit_bzero(obd.sr_maskkey, sizeof(obd.sr_maskkey));
	}

	/* build the bootpath */
	bootpath_build();

	if (boothowto & RB_CONFIG) {
#ifdef BOOT_CONFIG
		user_config();
#else
		printf("kernel does not support -c; continuing..\n");
#endif
	}

#if notyet
        /* FIXME FIXME FIXME  This is probably *WRONG!!!**/
        OF_set_callback(sync_crash);
#endif

	/* block clock interrupts and anything below */
	splclock();
	/* Enable device interrupts */
        setpstate(getpstate()|PSTATE_IE);

	if (config_rootfound("mainbus", NULL) == NULL)
		panic("mainbus not configured");

	/* Enable device interrupts */
        setpstate(getpstate()|PSTATE_IE);

	(void)spl0();
	cold = 0;

#ifdef SUN4V
	if (CPU_ISSUN4V)
		sun4v_set_soft_state(SIS_NORMAL, sun4v_soft_state_running);
#endif
}

#ifdef SUN4V

#define HSVC_GROUP_SOFT_STATE 0x003

int sun4v_soft_state_initialized = 0;

void
sun4v_soft_state_init(void)
{
	uint64_t minor;

	if (prom_set_sun4v_api_version(HSVC_GROUP_SOFT_STATE, 1, 0, &minor))
		return;

	prom_sun4v_soft_state_supported();
	sun4v_soft_state_initialized = 1;
}

void
sun4v_set_soft_state(int state, const char *desc)
{
	paddr_t pa;
	int err;

	if (!sun4v_soft_state_initialized)
		return;

	if (!pmap_extract(pmap_kernel(), (vaddr_t)desc, &pa))
		panic("sun4v_set_soft_state: pmap_extract failed");

	err = hv_soft_state_set(state, pa);
	if (err != H_EOK)
		printf("soft_state_set: %d\n", err);
}
#endif

void
diskconf(void)
{
	struct bootpath *bp;
	struct device *bootdv;

	bootpath_print(bootpath);

	bp = nbootpath == 0 ? NULL : &bootpath[nbootpath-1];
	bootdv = (bp == NULL) ? NULL : bp->dev;

#if NMPATH > 0
	if (bootdv != NULL)
		bootdv = mpath_bootdv(bootdv);
#endif

	setroot(bootdv, bp->val[2], RB_USERREQ | RB_HALT);
	dumpconf();
}

/*
 * Console `sync' command.  SunOS just does a `panic: zero' so I guess
 * no one really wants anything fancy...
 */
void
sync_crash(void)
{

	panic("PROM sync command");
}

char *
clockfreq(long freq)
{
	char *p;
	static char buf[10];

	freq /= 1000;
	snprintf(buf, sizeof buf, "%ld", freq / 1000);
	freq %= 1000;
	if (freq) {
		freq += 1000;	/* now in 1000..1999 */
		p = buf + strlen(buf);
		snprintf(p, buf + sizeof buf - p, "%ld", freq);
		*p = '.';	/* now buf = %d.%3d */
	}
	return (buf);
}

/* ARGSUSED */
static int
mbprint(void *aux, const char *name)
{
	struct mainbus_attach_args *ma = aux;

	if (name)
		printf("\"%s\" at %s", ma->ma_name, name);
	if (ma->ma_address)
		printf(" addr 0x%08lx", (u_long)ma->ma_address[0]);
	if (ma->ma_pri)
		printf(" ipl %d", ma->ma_pri);
	return (UNCONF);
}

int
findroot(void)
{
	int node;

	if ((node = rootnode) == 0 && (node = OF_peer(0)) == 0)
		panic("no PROM root device");
	rootnode = node;
	return (node);
}

/*
 * Given a `first child' node number, locate the node with the given name.
 * Return the node number, or 0 if not found.
 */
int
findnode(int first, const char *name)
{
	int node;
	char buf[32];

	for (node = first; node; node = OF_peer(node)) {
		if ((OF_getprop(node, "name", buf, sizeof(buf)) > 0) &&
			(strcmp(buf, name) == 0))
			return (node);
	}
	return (0);
}

int
mainbus_match(struct device *parent, void *cf, void *aux)
{
	return (1);
}

/*
 * Attach the mainbus.
 *
 * Our main job is to attach the CPU (the root node we got in cpu_configure())
 * and iterate down the list of `mainbus devices' (children of that node).
 * We also record the `node id' of the default frame buffer, if any.
 */
static void
mainbus_attach(struct device *parent, struct device *dev, void *aux)
{
extern struct sparc_bus_dma_tag mainbus_dma_tag;
extern bus_space_tag_t mainbus_space_tag;

	struct mainbus_attach_args ma;
	char buf[64];
	const char *const *ssp, *sp = NULL;
	int node0, node, rv, len;

	static const char *const openboot_special[] = {
		/* ignore these (end with NULL) */
		/*
		 * These are _root_ devices to ignore. Others must be handled
		 * elsewhere.
		 */
		"virtual-memory",
		"aliases",
		"memory",
		"openprom",
		"options",
		"packages",
		"chosen",
		NULL
	};

	/*
	 * Print the "banner-name" property in dmesg.  It provides a
	 * description of the machine that is generally more
	 * informative than the "name" property.  However, if the
	 * "banner-name" property is missing, fall back on the "name"
	 * propery.
	 */
	if (OF_getprop(findroot(), "banner-name", buf, sizeof(buf)) > 0 ||
	    OF_getprop(findroot(), "name", buf, sizeof(buf)) > 0)
		printf(": %s\n", buf);
	else
		printf("\n");

	/*
	 * Base the hw.product and hw.vendor strings on the "name"
	 * property.  They describe the hardware in a much more
	 * consistent way than the "banner-property".
	 */
	if ((len = OF_getprop(findroot(), "name", buf, sizeof(buf))) > 0) {
		hw_prod = malloc(len, M_DEVBUF, M_NOWAIT);
		if (hw_prod)
			strlcpy(hw_prod, buf, len);

		if (strncmp(buf, "SUNW,", 5) == 0)
			hw_vendor = "Sun";
		if (strncmp(buf, "FJSV,", 5) == 0)
			hw_vendor = "Fujitsu";
		if (strncmp(buf, "TAD,", 4) == 0)
			hw_vendor = "Tadpole";
		if (strncmp(buf, "NATE,", 5) == 0)
			hw_vendor = "Naturetech";

		/*
		 * The Momentum Leopard-V advertises itself as
		 * SUNW,UltraSPARC-IIi-Engine, but can be
		 * distinguished by looking at the "model" property.
		 */
		if (OF_getprop(findroot(), "model", buf, sizeof(buf)) > 0 &&
		    strncmp(buf, "MOMENTUM,", 9) == 0)
			hw_vendor = "Momentum";
	}

	/* Establish the first component of the boot path */
	bootpath_store(1, bootpath);

	/* We configure the CPUs first. */

	node = findroot();
	for (node0 = OF_child(node); node0; node0 = OF_peer(node0)) {
		if (OF_getprop(node0, "name", buf, sizeof(buf)) <= 0)
			continue;
	}

	for (node = OF_child(node); node; node = OF_peer(node)) {
		if (!checkstatus(node))
			continue;

		/* 
		 * UltraSPARC-IV cpus appear as two "cpu" nodes below
		 * a "cmp" node.
		 */
		if (OF_getprop(node, "name", buf, sizeof(buf)) <= 0)
			continue;
		if (strcmp(buf, "cmp") == 0) {
			bzero(&ma, sizeof(ma));
			ma.ma_node = node;
			ma.ma_name = buf;
			getprop(node, "reg", sizeof(*ma.ma_reg),
			    &ma.ma_nreg, (void **)&ma.ma_reg);
			config_found(dev, &ma, mbprint);
			continue;
		}

		if (OF_getprop(node, "device_type", buf, sizeof(buf)) <= 0)
			continue;
		if (strcmp(buf, "cpu") == 0) {
			bzero(&ma, sizeof(ma));
			ma.ma_node = node;
			OF_getprop(node, "name", buf, sizeof(buf));
			if (strcmp(buf, "cpu") == 0)
				OF_getprop(node, "compatible", buf, sizeof(buf));
			ma.ma_name = buf;
			getprop(node, "reg", sizeof(*ma.ma_reg),
			    &ma.ma_nreg, (void **)&ma.ma_reg);
			config_found(dev, &ma, mbprint);
			continue;
		}
	}

	node = findroot();	/* re-init root node */

	/* Find the "options" node */
	node0 = OF_child(node);
	optionsnode = findnode(node0, "options");
	if (optionsnode == 0)
		panic("no options in OPENPROM");

	for (node0 = OF_child(node); node0; node0 = OF_peer(node0)) {
		if (OF_getprop(node0, "name", buf, sizeof(buf)) <= 0)
			continue;
	}

	/*
	 * Configure the devices, in PROM order.  Skip
	 * PROM entries that are not for devices, or which must be
	 * done before we get here.
	 */
	for (node = OF_child(node); node; node = OF_peer(node)) {
		int portid;

		DPRINTF(ACDB_PROBE, ("Node: %x", node));
		if (OF_getprop(node, "device_type", buf, sizeof(buf)) > 0 &&
		    strcmp(buf, "cpu") == 0)
			continue;
		if (OF_getprop(node, "name", buf, sizeof(buf)) > 0 &&
		    strcmp(buf, "cmp") == 0)
			continue;
		DPRINTF(ACDB_PROBE, (" name %s\n", buf));
		for (ssp = openboot_special; (sp = *ssp) != NULL; ssp++)
			if (strcmp(buf, sp) == 0)
				break;
		if (sp != NULL)
			continue; /* an "early" device already configured */

		if (!checkstatus(node))
			continue;

		bzero(&ma, sizeof ma);
		ma.ma_bustag = mainbus_space_tag;
		ma.ma_dmatag = &mainbus_dma_tag;
		ma.ma_name = buf;
		ma.ma_node = node;
		if (OF_getprop(node, "upa-portid", &portid, sizeof(portid)) !=
		    sizeof(portid)) {
			if (OF_getprop(node, "portid", &portid,
			    sizeof(portid)) != sizeof(portid))
				portid = -1;
		}
		ma.ma_upaid = portid;

		if (getprop(node, "reg", sizeof(*ma.ma_reg), 
			     &ma.ma_nreg, (void **)&ma.ma_reg) != 0)
			continue;
#ifdef DEBUG
		if (autoconf_debug & ACDB_PROBE) {
			if (ma.ma_nreg)
				printf(" reg %08lx.%08lx\n",
					(long)ma.ma_reg->ur_paddr, 
					(long)ma.ma_reg->ur_len);
			else
				printf(" no reg\n");
		}
#endif
		rv = getprop(node, "interrupts", sizeof(*ma.ma_interrupts), 
			&ma.ma_ninterrupts, (void **)&ma.ma_interrupts);
		if (rv != 0 && rv != ENOENT) {
			free(ma.ma_reg, M_DEVBUF, 0);
			continue;
		}
#ifdef DEBUG
		if (autoconf_debug & ACDB_PROBE) {
			if (ma.ma_interrupts)
				printf(" interrupts %08x\n", 
					*ma.ma_interrupts);
			else
				printf(" no interrupts\n");
		}
#endif
		rv = getprop(node, "address", sizeof(*ma.ma_address), 
			&ma.ma_naddress, (void **)&ma.ma_address);
		if (rv != 0 && rv != ENOENT) {
			free(ma.ma_reg, M_DEVBUF, 0);
			free(ma.ma_interrupts, M_DEVBUF, 0);
			continue;
		}
#ifdef DEBUG
		if (autoconf_debug & ACDB_PROBE) {
			if (ma.ma_naddress)
				printf(" address %08x\n", 
					*ma.ma_address);
			else
				printf(" no address\n");
		}
#endif
		config_found(dev, &ma, mbprint);
		free(ma.ma_reg, M_DEVBUF, 0);
		free(ma.ma_interrupts, M_DEVBUF, 0);
		free(ma.ma_address, M_DEVBUF, 0);
	}

	extern int prom_cngetc(dev_t);

	/* Attach PROM console if no other console attached. */
	if (cn_tab->cn_getc == prom_cngetc) {
		bzero(&ma, sizeof ma);
		ma.ma_name = "pcons";
		config_found(dev, &ma, mbprint);
	}

	extern todr_chip_handle_t todr_handle;

	if (todr_handle == NULL) {
		bzero(&ma, sizeof ma);
		ma.ma_name = "prtc";
		config_found(dev, &ma, mbprint);
	}
}

struct cfattach mainbus_ca = {
	sizeof(struct device), mainbus_match, mainbus_attach
};

int
getprop(int node, char *name, size_t size, int *nitem, void **bufp)
{
	void	*buf;
	long	len;

	*nitem = 0;
	len = getproplen(node, name);
	if (len <= 0)
		return (ENOENT);

	if ((len % size) != 0)
		return (EINVAL);

	buf = *bufp;
	if (buf == NULL) {
		/* No storage provided, so we allocate some */
		buf = malloc(len + 1, M_DEVBUF, M_NOWAIT);
		if (buf == NULL)
			return (ENOMEM);
	}

	OF_getprop(node, name, buf, len);
	*bufp = buf;
	*nitem = len / size;
	return (0);
}


/*
 * Internal form of proplen().  Returns the property length.
 */
long
getproplen(int node, char *name)
{
	return (OF_getproplen(node, name));
}

/*
 * Return a string property.  There is a (small) limit on the length;
 * the string is fetched into a static buffer which is overwritten on
 * subsequent calls.
 */
char *
getpropstring(int node, char *name)
{
	static char stringbuf[32];

	return (getpropstringA(node, name, stringbuf));
}

/* Alternative getpropstring(), where caller provides the buffer */
char *
getpropstringA(int node, char *name, char *buffer)
{
	int blen;

	if (getprop(node, name, 1, &blen, (void **)&buffer) != 0)
		blen = 0;

	buffer[blen] = '\0';	/* usually unnecessary */
	return (buffer);
}

/*
 * Fetch an integer (or pointer) property.
 * The return value is the property, or the default if there was none.
 */
int
getpropint(int node, char *name, int deflt)
{
	int intbuf;

	if (OF_getprop(node, name, &intbuf, sizeof(intbuf)) != sizeof(intbuf))
		return (deflt);

	return (intbuf);
}

int
getpropspeed(int node, char *name)
{
	char buf[128];
	int i, speed = 0;

	if (OF_getprop(node, name, buf, sizeof(buf)) != -1) {
		for (i = 0; i < sizeof(buf); i++) {
			if (buf[i] < '0' || buf[i] > '9')
				break;
			speed *= 10;
			speed += buf[i] - '0';
		}
	}

	if (speed == 0)
		speed = 9600;

	return (speed);
}

/*
 * OPENPROM functions.  These are here mainly to hide the OPENPROM interface
 * from the rest of the kernel.
 */
int
firstchild(int node)
{

	return OF_child(node);
}

int
nextsibling(int node)
{

	return OF_peer(node);
}

int
checkstatus(int node)
{
	char buf[32];

	/* If there is no "status" property, assume everything is fine. */
	if (OF_getprop(node, "status", buf, sizeof(buf)) <= 0)
		return 1;

	/*
	 * If OpenBoot Diagnostics discovers a problem with a device
	 * it will mark it with "fail" or "fail-xxx", where "xxx" is
	 * additional human-readable information about the particular
	 * fault-condition.
	 */
	if (strcmp(buf, "disabled") == 0 || strncmp(buf, "fail", 4) == 0)
		return 0;

	return 1;
}

/* returns 1 if node has given property */
int
node_has_property(int node, const char *prop)
{
	return (OF_getproplen(node, (caddr_t)prop) != -1);
}

/*
 * Try to figure out where the PROM stores the cursor row & column
 * variables.  Returns nonzero on error.
 */
int
romgetcursoraddr(int **rowp, int **colp)
{
	cell_t row = 0, col = 0;

	OF_interpret("stdout @@ is my-self addr line# addr column# ",
	    2, &col, &row);

	/*
	 * We are running on a 64-bit machine, so these things point to
	 * 64-bit values.  To convert them to pointers to interfaces, add
	 * 4 to the address.
	 */
	if (row == 0 || col == 0)
		return (-1);
	*rowp = (int *)(row + 4);
	*colp = (int *)(col + 4);
	return (0);
}

void
callrom(void)
{

	__asm volatile("wrpr	%%g0, 0, %%tl" : );
	OF_enter();
}

/*
 * find a device matching "name" and unit number
 */
struct device *
getdevunit(char *name, int unit)
{
	struct device *dev = TAILQ_FIRST(&alldevs);
	char num[10], fullname[16];
	int lunit;

	/* compute length of name and decimal expansion of unit number */
	snprintf(num, sizeof num, "%d", unit);
	lunit = strlen(num);
	if (strlen(name) + lunit >= sizeof(fullname) - 1)
		panic("config_attach: device name too long");

	strlcpy(fullname, name, sizeof fullname);
	strlcat(fullname, num, sizeof fullname);

	while (strcmp(dev->dv_xname, fullname) != 0) {
		if ((dev = TAILQ_NEXT(dev, dv_list)) == NULL)
			return NULL;
	}
	return dev;
}

void
device_register(struct device *dev, void *aux)
{
	struct mainbus_attach_args *ma = aux;
	struct pci_attach_args *pa = aux;
	struct sbus_attach_args *sa = aux;
	struct vbus_attach_args *va = aux;
	struct cbus_attach_args *ca = aux;
	struct bootpath *bp = bootpath_store(0, NULL);
	struct device *busdev = dev->dv_parent;
	const char *devname = dev->dv_cfdata->cf_driver->cd_name;
	const char *busname;
	int node = -1;

	/*
	 * There is no point in continuing if we've exhausted all
	 * bootpath components.
	 */
	if (bp == NULL)
		return;

	DPRINTF(ACDB_BOOTDEV,
	    ("\n%s: device_register: devname %s(%s) component %s\n",
	    dev->dv_xname, devname, dev->dv_xname, bp->name));

	/*
	 * Ignore mainbus0 itself, it certainly is not a boot device.
	 */
	if (busdev == NULL)
		return;

	/*
	 * We don't know the type of 'aux'; it depends on the bus this
	 * device attaches to.  We are only interested in certain bus
	 * types; this is only used to find the boot device.
	 */
	busname = busdev->dv_cfdata->cf_driver->cd_name;
	if (strcmp(busname, "mainbus") == 0 ||
	    strcmp(busname, "ssm") == 0 || strcmp(busname, "upa") == 0)
		node = ma->ma_node;
	else if (strcmp(busname, "sbus") == 0 ||
	    strcmp(busname, "dma") == 0 || strcmp(busname, "ledma") == 0)
		node = sa->sa_node;
	else if (strcmp(busname, "vbus") == 0)
		node = va->va_node;
	else if (strcmp(busname, "cbus") == 0)
		node = ca->ca_node;
	else if (strcmp(busname, "pci") == 0)
		node = PCITAG_NODE(pa->pa_tag);

	if (node == bootnode) {
		if (strcmp(devname, "vdsk") == 0) {
			/*
			 * For virtual disks, don't nail the boot
			 * device just yet.  Instead, we add fake a
			 * SCSI target/lun, such that we match it the
			 * next time around.
			 */
			bp->dev = dev;
			(bp + 1)->val[0] = 0;
			(bp + 1)->val[1] = 0;
			nbootpath++;
			bootpath_store(1, bp + 1);
			return;
		}

		nail_bootdev(dev, bp);
		return;
	}

	if (node == bp->node) {
		bp->dev = dev;
		DPRINTF(ACDB_BOOTDEV, ("\t-- matched component %s to %s\n",
		    bp->name, dev->dv_xname));
		bootpath_store(1, bp + 1);
		return;
	}

	if (strcmp(devname, "scsibus") == 0) {
		/*
		 * Booting from anything but the first (physical) port
		 * isn't supported by OBP.
		 */
		if (strcmp(bp->name, "fp") == 0 && bp->val[0] == 0) {
			DPRINTF(ACDB_BOOTDEV, ("\t-- matched component %s to %s\n",
			    bp->name, dev->dv_xname));
			bootpath_store(1, bp + 1);
			return;
		}
	}

	if (strcmp(busname, "scsibus") == 0) {
		/*
		 * A SCSI disk or cd; retrieve target/lun information
		 * from parent and match with current bootpath component.
		 * Note that we also have look back past the `scsibus'
		 * device to determine whether this target is on the
		 * correct controller in our boot path.
		 */
		struct scsi_attach_args *sa = aux;
		struct scsi_link *sl = sa->sa_sc_link;
		struct scsibus_softc *sbsc =
		    (struct scsibus_softc *)dev->dv_parent;
		u_int target = bp->val[0];
		u_int lun = bp->val[1];

		if (bp->val[0] & 0xffffffff00000000 && bp->val[0] != -1) {
			/* Fibre channel? */
			if (bp->val[0] == sl->port_wwn && lun == sl->lun) {
				nail_bootdev(dev, bp);
			}
			return;
		}

		/* Check the controller that this scsibus is on. */
		if ((bp-1)->dev != sbsc->sc_dev.dv_parent)
			return;

		/*
		 * Bounds check: we know the target and lun widths.
		 */
		if (target >= sl->adapter_buswidth ||
		    lun >= sl->luns) {
			printf("SCSI disk bootpath component not accepted: "
			       "target %u; lun %u\n", target, lun);
			return;
		}

		if (target == sl->target && lun == sl->lun) {
			nail_bootdev(dev, bp);
			return;
		}
	}

	if (strcmp("wd", devname) == 0) {
		/* IDE disks. */
		struct ata_atapi_attach *aa = aux;
		u_int channel, drive;

		if (strcmp(bp->name, "ata") == 0 &&
		    bp->val[0] == aa->aa_channel) {
			channel = bp->val[0]; bp++;
			drive = bp->val[0];
		} else {
			channel = bp->val[0] / 2;
			drive = bp->val[0] % 2;
		}

		if (channel == aa->aa_channel &&
		    drive == aa->aa_drv_data->drive) {
			nail_bootdev(dev, bp);
			return;
		}
	}
}

void
nail_bootdev(struct device *dev, struct bootpath *bp)
{

	if (bp->dev != NULL)
		panic("device_register: already got a boot device: %s",
			bp->dev->dv_xname);

	/*
	 * Mark this bootpath component by linking it to the matched
	 * device. We pick up the device pointer in cpu_rootconf().
	 */
	booted_device = bp->dev = dev;
	DPRINTF(ACDB_BOOTDEV, ("\t-- found bootdevice: %s\n",dev->dv_xname));

	/*
	 * Then clear the current bootpath component, so we don't spuriously
	 * match similar instances on other busses, e.g. a disk on
	 * another SCSI bus with the same target.
	 */
	bootpath_store(1, NULL);
}

struct nam2blk nam2blk[] = {
	{ "sd",		 7 },
	{ "rd",		 5 },
	{ "wd",		12 },
	{ "cd",		18 },
	{ "vnd",	8 },
	{ NULL,		-1 }
};
@


1.126
log
@remove obsolete raid from namtoblk tables. from Artturi Alm
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.125 2016/03/07 13:21:51 naddy Exp $	*/
a588 5
		} else if (*cp == 't') {
			/* turn on traptrace w/o breaking into kdb */
			extern int trap_trace_dis;

			trap_trace_dis = 0;
@


1.125
log
@Sync no-argument function declaration and definition by adding (void).
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.124 2015/09/19 21:07:04 semarie Exp $	*/
a1507 1
	{ "raid",	25 },
@


1.124
log
@trivial "if(x) free(x)" replacement by "free(x)"

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.123 2014/11/30 22:26:14 kettenis Exp $	*/
d487 1
a487 1
bootpath_build()
d648 1
a648 1
cpu_configure()
d800 1
a800 1
sync_crash()
d840 1
a840 1
findroot()
d1291 1
a1291 1
callrom()
@


1.123
log
@SPARC T4 and later have a pause instruction to voluntarily pause a virtual
processor in order to give other strands a chance to run.  Use it in
__mp_lock_spin_hook() to avoid wasting CPU cycles if we're waiting for
the kernel or scheduler locks.  This is instruction is patched in, just like
we already do for the sleep instruction on SPARC64 VI processors.  We look
at the hwcap-list property of the cpu nodes in the machine description to
decide whether the pause instruction is available.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.122 2014/11/26 20:06:53 stsp Exp $	*/
d1080 1
a1080 2
			if (ma.ma_ninterrupts)
				free(ma.ma_interrupts, M_DEVBUF, 0);
d1094 2
a1095 4
		if (ma.ma_ninterrupts)
			free(ma.ma_interrupts, M_DEVBUF, 0);
		if (ma.ma_naddress)
			free(ma.ma_address, M_DEVBUF, 0);
@


1.122
log
@Add a new ELF segment .openbsd.bootdata to the sparc64 kernel.
This can be used to pass boot parameters to the kernel which can't be passed
safely via the Open Firmware interface, such as softraid volume IDs and keys.
The kernel already reads the arguments if available but ofwboot won't provide
them until further changes are committed there.

With support from deraadt, kettenis and matthew.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.121 2014/09/26 09:45:59 stsp Exp $	*/
d651 7
a657 1
	if (CPU_ISSUN4V)
d659 32
@


1.121
log
@ansify; ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.120 2014/07/12 18:44:43 tedu Exp $	*/
d70 1
d84 2
d102 10
d143 2
d654 10
@


1.120
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.119 2014/05/10 12:29:58 kettenis Exp $	*/
d276 1
a276 2
bootstrap(nctx)
	int nctx;
d590 1
a590 2
bootpath_print(bp)
	struct bootpath *bp;
d614 1
a614 3
bootpath_store(storep, bp)
	int storep;
	struct bootpath *bp;
d744 1
a744 2
clockfreq(freq)
	long freq;
d763 1
a763 3
mbprint(aux, name)
	void *aux;
	const char *name;
d779 1
a779 1
	register int node;
d792 1
a792 3
findnode(first, name)
	int first;
	register const char *name;
d806 1
a806 4
mainbus_match(parent, cf, aux)
	struct device *parent;
	void *cf;
	void *aux;
a807 1

d819 1
a819 3
mainbus_attach(parent, dev, aux)
	struct device *parent, *dev;
	void *aux;
d1061 1
a1061 6
getprop(node, name, size, nitem, bufp)
	int	node;
	char	*name;
	size_t	size;
	int	*nitem;
	void	**bufp;
d1093 1
a1093 3
getproplen(node, name)
	int node;
	char *name;
d1104 1
a1104 3
getpropstring(node, name)
	int node;
	char *name;
d1113 1
a1113 4
getpropstringA(node, name, buffer)
	int node;
	char *name;
	char *buffer;
d1129 1
a1129 4
getpropint(node, name, deflt)
	int node;
	char *name;
	int deflt;
d1140 1
a1140 3
getpropspeed(node, name)
	int node;
	char *name;
d1165 1
a1165 2
firstchild(node)
	int node;
d1172 1
a1172 2
nextsibling(node)
	int node;
d1199 1
d1201 1
a1201 3
node_has_property(node, prop)	/* returns 1 if node has given property */
	register int node;
	register const char *prop;
d1211 1
a1211 2
romgetcursoraddr(rowp, colp)
	int **rowp, **colp;
d1242 1
a1242 3
getdevunit(name, unit)
	char *name;
	int unit;
d1421 1
a1421 3
nail_bootdev(dev, bp)
	struct device *dev;
	struct bootpath *bp;
@


1.119
log
@A few more straightforward format string fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.118 2014/03/29 18:09:30 guenther Exp $	*/
d1016 1
a1016 1
			free(ma.ma_reg, M_DEVBUF);
d1031 1
a1031 1
			free(ma.ma_reg, M_DEVBUF);
d1033 1
a1033 1
				free(ma.ma_interrupts, M_DEVBUF);
d1046 1
a1046 1
		free(ma.ma_reg, M_DEVBUF);
d1048 1
a1048 1
			free(ma.ma_interrupts, M_DEVBUF);
d1050 1
a1050 1
			free(ma.ma_address, M_DEVBUF);
@


1.118
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.117 2012/08/29 20:33:16 kettenis Exp $	*/
d597 1
a597 1
			printf("/%s%x", bp->name, bp->val[1]);
d601 1
a601 1
			printf(":%c", bp->val[2] + 'a');
@


1.117
log
@The low-level guts to support MTP (Multi-Threaded Processing) on the
Fujitsu SPARC64-VI and SPARC64-VII CPUs.  Since the two threads on each core
share the TLBs of the core we cannot enter different mappings for the same
virtual address.  Instead we use a scratch register to store the per-cpu
pointer.  This is very similar to what we do on sun4v.

For now we still only attach the first thread of each SPARC64-VI/VII core
since we currently don't handle the VMT (Vertical Multi-Threading) of the
SPARC64-VI very well.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.116 2012/06/30 22:00:49 kettenis Exp $	*/
d1270 1
a1270 1
	__asm __volatile("wrpr	%%g0, 0, %%tl" : );
@


1.116
log
@Further research shows that fp@@x,y device path components with x > 0 are
used by Solaris for virtual ports (NPIV), and booting from thos is not
supported by OBP.  Simplify the code accordingly.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.115 2012/06/27 22:40:38 matthew Exp $	*/
d346 17
@


1.115
log
@Change sparc64 to match the "fp" boot device path's parameter based on
the prototype-scsi_link's SDEV_2NDBUS flag rather than against its
scsibus field.  First, the scsibus field hasn't even been initialized
when device_register() is called so it's always 0 anyway; second, the
path number is supposed to be locally scoped to a single device
whereas the scsibus field is a global scsibus(4) device number.

The existing code only happened to work because all of the dual-port
fibre-channel adapters we currently support attach as two devices with
one scsibus each rather than a single device with two scsibuses, so we
would never see anything but "fp@@0".

Initial investigation and diff by jmatthew after my SCSI cleanups at
c2k11 broke sparc64's ability to boot from isp(4); newer version from
me based on discussion with krw and kettenis.

tested and ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.114 2011/07/17 22:46:47 matthew Exp $	*/
d1364 5
a1368 5
		struct scsibus_attach_args *saa = aux;
		struct scsi_link *sl = saa->saa_sc_link;

		if (strcmp(bp->name, "fp") == 0 &&
		    bp->val[0] == ((sl->flags & SDEV_2NDBUS) ? 1 : 0)) {
@


1.114
log
@Backout a bunch of my SCSI commits from c2k11.  At least one of these
is causing problems when trying to boot sparc64 from an isp(4).

Verified to fix the sparc64/isp(4) regression by krw@@; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.113 2011/07/16 16:48:42 matthew Exp $	*/
d1368 1
a1368 1
		    bp->val[0] == sl->scsibus) {
@


1.113
log
@device_register() is called on the scsibus(4) devices before
scsibusattach() is called, so saa_sc_link->bus hasn't been initialized
to a valid pointer yet.

Easy fix: Use dev->dv_unit instead of poking into the attach args.

ok krw@@, jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.112 2011/07/05 20:34:45 matthew Exp $	*/
d1364 3
d1368 1
a1368 1
		    bp->val[0] == dev->dv_unit) {
@


1.112
log
@Replace last remaining users of link->scsibus with
link->bus->sc_dev.dv_unit.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.111 2011/04/27 09:40:59 dlg Exp $	*/
a1363 3
		struct scsibus_attach_args *saa = aux;
		struct scsi_link *sl = saa->saa_sc_link;

d1365 1
a1365 1
		    bp->val[0] == sl->bus->sc_dev.dv_unit) {
@


1.111
log
@support rooting off multipath disks.

if you boot from a disk that ends up behind mpath(4) on sparc64,
it wont be able to resolve it to the actual disk device since a
path driver (eg sym(4)) sits where ofw tells us a disk is.

this diff allows the bootpath code to match on path drivers, and
then asks mpath to swap the path for the disk device.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.110 2011/04/07 15:30:16 miod Exp $	*/
d1368 1
a1368 1
		    bp->val[0] == sl->scsibus) {
@


1.110
log
@Do not use NULL in integer comparisons. No functional change.
ok matthew@@ tedu@@, also eyeballed by at least krw@@ oga@@ kettenis@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.109 2010/11/18 21:13:19 miod Exp $	*/
d47 2
d89 3
d710 5
d1376 1
a1376 1
	if (strcmp(devname, "sd") == 0 || strcmp(devname, "cd") == 0) {
@


1.109
log
@Do not #include <sys/dkstat.h> if you don't need anything from it.
ok krw@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.108 2010/08/07 00:13:09 krw Exp $	*/
d1222 1
a1222 1
	cell_t row = NULL, col = NULL;
d1232 1
a1232 1
	if (row == NULL || col == NULL)
@


1.108
log
@No "\n" needed at the end of panic() strings.

Some stragglers from last diff.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.107 2010/01/02 01:20:38 kettenis Exp $	*/
a52 1
#include <sys/dkstat.h>
@


1.107
log
@We need an additional level of indirection through 'struct scsibus_attach_args'
to find the 'struct scsi_link' associated with a scsibus(4).  Interpreting
'struct scsibus_attach_args' as a 'struct scsi_link' happened to mostly work
since it had a zero stored in the right place.  However, after dlg@@'s changes
to 'struct scsi_link' that no longer turned out to be true.

Makes my blade1k find its root disk again.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.106 2009/05/31 21:23:28 kettenis Exp $	*/
d687 1
a687 1
		panic("sun4v_set_soft_state: pmap_extract failed\n");
@


1.106
log
@Add Naturetech as a possible hardware vendor.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.105 2009/04/19 17:53:39 deraadt Exp $	*/
d1355 2
a1356 1
		struct scsi_link *sl = aux;
@


1.105
log
@Count number of cpus found (potentially not attached) and store that
in sysctl hw.ncpufound; ok miod kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.104 2009/04/12 14:53:15 kettenis Exp $	*/
d863 2
@


1.104
log
@Move code handling Machine Descriptions out of the cbus(4) driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.103 2009/04/04 21:07:48 kettenis Exp $	*/
a217 1
#ifdef MULTIPROCESSOR
d230 1
a230 1
				return (ncpus);
d247 4
a250 1
	return (0);
@


1.103
log
@Bump the size of the array that we use to store bootpath components.  Makes the
t5120 and similar systems boot from our install CD-ROM.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.102 2009/04/04 11:12:46 kettenis Exp $	*/
d71 1
d616 5
@


1.102
log
@Cleanup debug printf.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.101 2009/02/19 11:12:42 kettenis Exp $	*/
d118 1
a118 1
struct	bootpath bootpath[8];
@


1.101
log
@Make prom_sun4v_soft_state_supported() call the right client interface.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.100 2009/02/15 15:03:58 kettenis Exp $	*/
a663 2

	prom_printf("minor %lld\r\n", minor);
@


1.100
log
@Sun's usage of the "banner-name" property is just too inconsistent to give
us a chance to parse it and generate strings for hw.product and hw.vendor.
Use the "name" property instead.  This should give us a better chance of
booting on UltraSPARC T2+ systems.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.99 2009/01/16 23:21:32 kettenis Exp $	*/
d146 8
d396 7
d644 42
d687 1
@


1.99
log
@Make it possible to boot from vdsk(4).
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.98 2009/01/03 22:09:29 kettenis Exp $	*/
a105 1
char platform_type[64];
d750 1
a750 1
	char buf[32], *p;
d770 24
a793 11
	if ((len = OF_getprop(findroot(), "banner-name", platform_type,
	    sizeof(platform_type))) <= 0)
		OF_getprop(findroot(), "name", platform_type,
		    sizeof(platform_type));
	printf(": %s\n", platform_type);

	hw_vendor = malloc(sizeof(platform_type), M_DEVBUF, M_NOWAIT);
	if (len > 0 && hw_vendor != NULL) {
		strlcpy(hw_vendor, platform_type, sizeof(platform_type));
		if ((strncmp(hw_vendor, "SUNW,", 5)) == 0) {
			p = hw_prod = hw_vendor + 5;
d795 13
a807 9
		} else if ((strncmp(hw_vendor, "Sun (TM) ", 9)) == 0) {
			p = hw_prod = hw_vendor + 9;
			hw_vendor = "Sun";
		} else if ((p = memchr(hw_vendor, ' ', len)) != NULL) {
			*p = '\0';
			hw_prod = ++p;
		}
		if ((p = memchr(hw_prod, '(', len - (p - hw_prod))) != NULL)
			*p = '\0';
@


1.98
log
@Make is possible to boot from devices on cbus(4) (when they're there and
actually work).
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.97 2008/07/21 04:35:54 todd Exp $	*/
d1245 15
@


1.97
log
@nam2blk[] needs a "vnd" entry for some things (like softraid)
ok marco@@ no objection miod@@ need this for regress djm@@ no objection krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.96 2008/07/06 08:53:38 kettenis Exp $	*/
d78 2
d1200 2
d1237 4
@


1.96
log
@Enable ssm(4) and remove hacks that worked around the fact that we didn't
have it.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.95 2008/07/06 07:25:04 kettenis Exp $	*/
d1357 1
@


1.95
log
@Add missing include such that RAMDISK kernels compile again.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.94 2008/07/05 23:08:08 kettenis Exp $	*/
a800 4
		if (strcmp(buf, "ssm") == 0) {
			node = node0;
			break;
		}
a849 4
		if (strcmp(buf, "ssm") == 0) {
			node = node0;
			break;
		}
a1210 6
	/*
	 * XXX Skip 'ssm' until we have a real driver for it.
	 */
	if (strcmp(bp->name, "ssm") == 0)
		bp = bootpath_store(1, bp + 1);

d1227 2
a1228 1
	if (strcmp(busname, "mainbus") == 0 || strcmp(busname, "upa") == 0)
@


1.94
log
@Copy OBP breakpoint vector from the PROM trap table into our own trap table.
This makes the kernel properly enter the prom upon halt on the v1280.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.93 2008/07/04 18:48:45 kettenis Exp $	*/
d75 1
@


1.93
log
@Add a little hack to recognize the boot device on the v1280.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.92 2008/07/04 17:20:27 kettenis Exp $	*/
d263 1
d374 9
@


1.92
log
@Add support for ssm nodes as found on the v1280 and bigger machines.  For now,
we pretend that ssm is mainbus.  Perhaps I'l turn it into a real bus driver
later.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.91 2008/06/10 16:49:01 kettenis Exp $	*/
d1207 6
@


1.91
log
@Make get_npcus() walk the device tree to figure out the number of CPUs
instead of treating "cmp" nodes specially.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.90 2008/06/10 00:02:09 kettenis Exp $	*/
d787 8
d840 9
d854 1
a854 1
	for (node = node0; node; node = OF_peer(node)) {
@


1.90
log
@Add cmp(4), a dummy driver to make attaching CMT cpus easier.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.89 2008/05/24 20:02:19 kettenis Exp $	*/
d198 6
d208 1
a208 1
	int node0, node,ncpus;
d211 2
a212 1
	node = findroot();
d215 8
a222 8
	for (node = OF_child(node), node0 = 0; node; node = OF_peer(node)) {
		/* 
		 * UltraSPARC-IV cpus appear as two "cpu" nodes below
		 * a "cmp" node.  Go down one level, but remember
		 * where we came from, such that we can go up again
		 * after we've handled both "cpu" nodes.
		 */
		if (OF_getprop(node, "name", buf, sizeof(buf)) <= 0)
a223 3
		if (strcmp(buf, "cmp") == 0) {
			node0 = node;
			node = OF_child(node0);
d226 2
a227 3
		if (OF_getprop(node, "device_type", buf, sizeof(buf)) <= 0)
			continue;
		if (strcmp(buf, "cpu") == 0)
d230 5
a234 4
		if (node0 && OF_peer(node) == 0) {
			node = node0;
			node0 = 0;
		}
d237 1
a237 1
	return (ncpus);
@


1.89
log
@Treat SPARC64-VI and SPARC64-VII similar to SPARC64-V, and move the
UltraSPARC-III fixup code into bootstrap() too.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.88 2008/05/21 19:23:15 kettenis Exp $	*/
d736 1
a736 1
	int node0, node, rv, len, ncpus;
d784 1
a784 2
	ncpus = 0;
	for (node = OF_child(node), node0 = 0; node; node = OF_peer(node)) {
d790 1
a790 3
		 * a "cmp" node.  Go down one level, but remember
		 * where we came from, such that we can go up again
		 * after we've handled both "cpu" nodes.
d795 7
a801 2
			node0 = node;
			node = OF_child(node0);
a807 2
			ma.ma_bustag = mainbus_space_tag;
			ma.ma_dmatag = &mainbus_dma_tag;
d816 1
a816 6
			ncpus++;
		}

		if (node0 && OF_peer(node) == 0) {
			node = node0;
			node0 = 0;
a819 3
	if (ncpus == 0)
		panic("None of the CPUs found");

d840 3
a842 1
		OF_getprop(node, "name", buf, sizeof(buf));
@


1.88
log
@First step towards supporting sun4us machines with Fujitsu's SPARC64-V CPU.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.87 2008/04/14 21:04:56 kettenis Exp $	*/
d262 1
d290 1
a290 1
}
d293 21
a313 2
#if defined (SUN4US) || defined(SUN4V)
	if (CPU_ISSUN4US || CPU_ISSUN4V) {
a323 1
#endif
@


1.87
log
@Introduce macros to switch to normal and alternate globals and switch to
use the .section based mechanism to patch them up for sun4v.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.86 2008/04/12 14:59:30 kettenis Exp $	*/
d259 1
a259 1
#ifdef SUN4V
d283 7
a289 4
#ifdef SUN4V
	if (OF_getprop(findroot(), "compatible", buf, sizeof(buf)) > 0 &&
	    strcmp(buf, "sun4v") == 0)
		cputyp = CPU_SUN4V;
d292 2
a293 2
#ifdef SUN4V
	if (CPU_ISSUN4V) {
a295 2
		u_int32_t insn;
		int32_t disp;
d302 9
a347 1
		cacheinfo.c_dcache_flush_page = no_dcache_flush_page;
@


1.86
log
@Introduce macros to get and set the MMU context ID in asm code and switch to
use the .section based mechanism to patch them up for sun4v.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.85 2008/03/31 22:14:01 kettenis Exp $	*/
a291 1
		extern vaddr_t gl0_start, gl1_start;
a297 10
			flush((void *)(*pva));
		}

		for (pva = &gl0_start; *pva; pva++) {
			*(u_int32_t *)(*pva) = 0xa1902000; /* wr %g0, 0, %gl */
			flush((void *)(*pva));
		}

		for (pva = &gl1_start; *pva; pva++) {
			*(u_int32_t *)(*pva) = 0xa1902001; /* wr %g0, 1, %gl */
@


1.85
log
@Make MULTIPROCESSOR kernels work on sun4v.  Won't gracefully halt, powerdown
or reboot yet, but that will (hopefully) be fixed in the near future.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.84 2008/03/30 12:30:01 kettenis Exp $	*/
d291 1
a291 1
		extern vaddr_t dlflush_start, ctxid_start;
a301 8
		for (pva = &ctxid_start; *pva; pva++) {
			insn = *(u_int32_t *)(*pva);
			insn &= ~(ASI_DMMU << 5);
			insn |= (ASI_MMU_CONTEXTID << 5);
			*(u_int32_t *)(*pva) = insn;
			flush((void *)(*pva));
		}

a323 1
#ifdef MULTIPROCESSOR
d328 9
a336 1
		};
d338 1
a340 1
		struct sun4v_patch *p;
d346 1
a347 1
#endif
@


1.84
log
@More sun4v support.  GENERIC and RAMDISK kernels will now boot on both
sun4u and sun4v.  GENERIC.MP won't work yet though.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.83 2008/03/22 21:10:28 kettenis Exp $	*/
d331 18
@


1.83
log
@Reintroduce the cputyp variable, and use it to distinguish between sun4u and
sun4v.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.82 2008/03/17 23:10:21 kettenis Exp $	*/
d70 1
d75 1
d287 47
@


1.82
log
@Remove KGDB code.  It was never converted to 64-bit, and just makes locore.s
even more unreadable.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.81 2008/03/14 17:04:48 kettenis Exp $	*/
d257 3
d279 6
@


1.81
log
@Don't even try to attach pcons(4) if we have a real console.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.80 2008/03/13 23:03:02 kettenis Exp $	*/
a99 4
#ifdef KGDB
extern	int kgdb_debug_panic;
#endif

d259 3
a270 6
#ifdef KGDB
/* Moved zs_kgdb_init() to dev/zs.c:consinit(). */
	zs_kgdb_init();		/* XXX */
#endif
	/* Initialize the PROM console so printf will not panic */
	(*cn_tab->cn_init)(cn_tab);
d423 1
a423 4
#if defined(KGDB)
			kgdb_debug_panic = 1;
			kgdb_connect(1);
#elif defined(DDB)
@


1.80
log
@Attach prtc(4) if no (hardware) real-time clock was found.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.79 2008/03/08 22:53:02 kettenis Exp $	*/
d842 9
a850 4
	/* Try to attach PROM console */
	bzero(&ma, sizeof ma);
	ma.ma_name = "pcons";
	config_found(dev, &ma, mbprint);
@


1.79
log
@Check "status" property for CPUs too.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.78 2008/03/08 16:30:36 kettenis Exp $	*/
d64 1
d846 8
@


1.78
log
@Introduce a function to check the "status" property of an OFW node, and use it
to avoid attaching disabled or failed devices.

This should make it possible to manually deconfigure devices on mid-range and
high-end servers like the V880 using the "asr-disable" PROM command, and make
OpenBSD avoid using hardware that has been detected as faulty by the POST or
OpenBoot Diagnostics.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.77 2008/03/01 15:56:09 kettenis Exp $	*/
d703 3
@


1.77
log
@Add getpropspeed(); a function which decodes a property describing a serial
port configuration and returns the configured speed.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.76 2008/03/01 14:42:42 kettenis Exp $	*/
d770 3
d985 20
a1004 1
/* The following are used primarily in consinit() */
@


1.76
log
@Provide "reg" property when attaching cpu(4).
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.75 2007/11/16 23:27:28 kettenis Exp $	*/
a932 2
	

d937 23
@


1.75
log
@Pass name of CPU nodes instead of "cpu" such that we see it for unconfigured
CPUs on UP kernels.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.74 2007/10/31 22:21:43 kettenis Exp $	*/
d239 1
d727 2
@


1.74
log
@Remove some XXX code that has been #ifdef'ed out for ages.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.73 2007/10/25 18:48:00 deraadt Exp $	*/
d722 5
a726 2
			ma.ma_name = "cpu";
			config_found(dev, (void *)&ma, mbprint);
d756 2
a757 2
		if ((OF_getprop(node, "device_type", buf, sizeof(buf)) > 0) &&
			strcmp(buf, "cpu") == 0)
d825 1
a825 1
		(void) config_found(dev, (void *)&ma, mbprint);
d835 1
a835 1
	(void) config_found(dev, (void *)&ma, mbprint);
@


1.73
log
@allocate 1 byte extra in getprop(), for the NUL that some callers like
to place.  This is a nightmare, and we must move away from these stupid
wrapper APIs.  ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.72 2007/10/25 05:19:55 deraadt Exp $	*/
a499 4
#if 0
	extern struct user *proc0paddr;	/* XXX see below */
#endif

a525 9

#if 0
	/*
	 * XXX Re-zero proc0's user area, to nullify the effect of the
	 * XXX stack running into it during auto-configuration.
	 * XXX - should fix stack usage.
	 */
	bzero(proc0paddr, sizeof(struct user));
#endif
@


1.72
log
@another case of product encoding is "Sun (TM) modelname", on the E250
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.71 2007/10/17 21:23:28 kettenis Exp $	*/
d874 1
a874 1
		buf = malloc(len, M_DEVBUF, M_NOWAIT);
@


1.71
log
@Spin up secondary CPUs on MULTIPROCESSOR kernels.  Works on UltraSPARC-III
CPUs.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.70 2007/10/14 18:31:29 kettenis Exp $	*/
d694 3
@


1.70
log
@Don't bail out after finding the first cpu.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.69 2007/08/07 21:20:54 kettenis Exp $	*/
d114 1
d199 40
d259 1
d283 2
a284 1
	pmap_bootstrap(KERNBASE, (u_long)&end, nctx);
d665 1
a665 1
	int node0, node, rv, len;
d703 2
a704 6
	/*
	 * Locate and configure the ``early'' devices.  These must be
	 * configured before we can do the rest.  For instance, the
	 * EEPROM contains the Ethernet address for the LANCE chip.
	 * If the device cannot be located or configured, panic.
	 */
d706 1
a706 3
/*
 * The rest of this routine is for OBP machines exclusively.
 */
d710 2
a711 6
	/* Establish the first component of the boot path */
	bootpath_store(1, bootpath);

	/* the first early device to be configured is the cpu */

	{
d714 3
a716 2
		 * a "cmp" node.  Lookup the first "cmp" node, such
		 * that we find the "cpu" node in the code below.
d718 6
d725 10
a734 5
		for (node = OF_child(node); node; node = OF_peer(node)) {
			if (OF_getprop(node, "name", buf, sizeof(buf)) <= 0)
				continue;
			if (strcmp(buf, "cmp") == 0)
				break;
d737 3
a739 20
		if (node == 0)
			node = findroot();
	}

	{
		int found = 0;

		for (node = OF_child(node); node; node = OF_peer(node)) {
			if (OF_getprop(node, "device_type", 
				buf, sizeof(buf)) <= 0)
				continue;
			if (strcmp(buf, "cpu") == 0) {
				bzero(&ma, sizeof(ma));
				ma.ma_bustag = mainbus_space_tag;
				ma.ma_dmatag = &mainbus_dma_tag;
				ma.ma_node = node;
				ma.ma_name = "cpu";
				config_found(dev, (void *)&ma, mbprint);
				found++;
			}
a740 3

		if (!found)
			panic("None of the CPUs found");
d743 2
@


1.69
log
@Add "dma" and "ledma" as busses that potentially have the root device on them.
Makes the Ultra-1 find its root disk again.

tested by nick@@ and fgsch@@, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.68 2007/07/29 20:22:07 kettenis Exp $	*/
d697 1
a697 1
		/* XXX - what to do on multiprocessor machines? */
d710 1
a710 1
				break;
d713 2
a714 1
		if (node == 0)
@


1.68
log
@Add support for bootpaths like /pci@@1f,4000/ide@@3,0/ata@@0,0/cmdk@@0,0
in addition to paths like /pci@@1f,0/ide@@d,0/disk@@0,0 for machines rooting
off wd(4).  This makes the Ultrabook 170/200 find its root disk.

tested by krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.67 2007/06/01 19:25:10 deraadt Exp $	*/
d1045 3
a1049 2
	else if (strcmp(busname, "sbus") == 0)
		node = sa->sa_node;
@


1.67
log
@some architectures called setroot() from cpu_configure(), *way* before some
subsystems were enabled.  others used a *md_diskconf -> diskconf() method to
make sure init_main could "do late setroot".  Change all architectures to
have diskconf(), use it directly & late.  tested by todd and myself on most
architectures, ok miod too
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.67 2007/06/01 19:20:47 deraadt Exp $	*/
d1121 1
d1123 11
a1133 2
		if ((bp->val[0] / 2) == aa->aa_channel &&
		    (bp->val[0] % 2) == aa->aa_drv_data->drive) {
@


1.66
log
@Put names we get from the prom between double quotes when we print them.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.65 2007/05/04 19:30:55 deraadt Exp $	*/
a113 1
void	diskconf(void);
a497 2

	md_diskconf = diskconf;
@


1.65
log
@make findblkmajor() and findblkname() MI; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.64 2007/05/04 03:44:44 deraadt Exp $	*/
d558 1
a558 1
		printf("%s at %s", ma->ma_name, name);
@


1.64
log
@setroot() was a ugly mix of MI and MD code, with different bugs on different
machines.  Instead -- build one solid clean MI version, and thenchange all
the architectures to use it.  ok various people, tested on almost all cases.
(it is a 10094 line diff..)
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.63 2007/04/30 18:37:00 deraadt Exp $	*/
d1158 1
a1158 4
struct nam2blk {
	char	*name;
	int	maj;
} nam2blk[] = {
d1164 1
a1165 23

int
findblkmajor(struct device *dv)
{
	char *name = dv->dv_xname;
	int i;

	for (i = 0; i < sizeof(nam2blk)/sizeof(nam2blk[0]); i++)
		if (!strncmp(name, nam2blk[i].name, strlen(nam2blk[i].name)))
			return (nam2blk[i].maj);
	return (-1);
}

char *
findblkname(int maj)
{
	int i;

	for (i = 0; i < sizeof(nam2blk)/sizeof(nam2blk[0]); i++)
		if (nam2blk[i].maj == maj)
			return (nam2blk[i].name);
	return (NULL);
}
@


1.63
log
@check for exit string earlier
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.62 2007/04/30 18:05:21 deraadt Exp $	*/
a87 1

a113 2
static	int getstr(char *, int);
void	setroot(void);
a114 3
static	struct device *getdisk(char *, int, int, dev_t *);
int	findblkmajor(struct device *);
char	*findblkname(int);
a144 3
#ifdef RAMDISK_HOOKS
static struct device fakerdrootdev = { DV_DISK, {}, NULL, 0, "rd0", NULL };
#endif
a338 1
	bootpath_print(bootpath);
d507 2
a508 3
	setroot();
	dumpconf();
}
d510 1
a510 14
void
setroot()
{
	struct swdevt *swp;
	struct device *dv;
	int len, majdev, unit, part;
	dev_t nrootdev, nswapdev = NODEV;
	char buf[128];
	dev_t temp;
	struct device *bootdv;
	struct bootpath *bp;
#if defined(NFSCLIENT)
	extern char *nfsbootdevname;
#endif
a512 3
#ifdef RAMDISK_HOOKS
	bootdv = &fakerdrootdev;
#else
a513 1
#endif
d515 2
a516 346
	/*
	 * (raid) device auto-configuration could have returned
	 * the root device's id in rootdev.  Check this case.
	 */
	if (rootdev != NODEV) {
		majdev = major(rootdev);
		unit = DISKUNIT(rootdev);
		part = DISKPART(rootdev);

		len = snprintf(buf, sizeof buf, "%s%d", findblkname(majdev),
		    unit);
		if (len == -1 || len >= sizeof(buf))
			panic("setroot: device name too long");

		bootdv = getdisk(buf, len, part, &rootdev);
	}

	/*
	 * If `swap generic' and we couldn't determine boot device,
	 * ask the user.
	 */
	if (mountroot == NULL && bootdv == NULL)
		boothowto |= RB_ASKNAME;

	if (boothowto & RB_ASKNAME) {
		for (;;) {
			printf("root device");
			if (bootdv != NULL)
				printf(" (default %s%c)",
					bootdv->dv_xname,
					bootdv->dv_class == DV_DISK
						? bp->val[2]+'a' : ' ');
			printf(": ");
			len = getstr(buf, sizeof(buf));
			if (len == 0 && bootdv != NULL) {
				strlcpy(buf, bootdv->dv_xname, sizeof buf);
				len = strlen(buf);
			}
			if (len == 4 && strncmp(buf, "exit", 4) == 0)
				boot(RB_USERREQ | RB_HALT);
			if (len > 0 && buf[len - 1] == '*') {
				buf[--len] = '\0';
				dv = getdisk(buf, len, 1, &nrootdev);
				if (dv != NULL) {
					bootdv = dv;
					nswapdev = nrootdev;
					goto gotswap;
				}
			}
			dv = getdisk(buf, len, bp?bp->val[2]:0, &nrootdev);
			if (dv != NULL) {
				bootdv = dv;
				break;
			}
		}

		/*
		 * because swap must be on same device as root, for
		 * network devices this is easy.
		 */
		if (bootdv->dv_class == DV_IFNET) {
			goto gotswap;
		}
		for (;;) {
			printf("swap device ");
			if (bootdv != NULL)
				printf("(default %s%c)",
					bootdv->dv_xname,
					bootdv->dv_class == DV_DISK?'b':' ');
			printf(": ");
			len = getstr(buf, sizeof(buf));
			if (len == 4 && strncmp(buf, "exit", 4) == 0)
				boot(RB_USERREQ | RB_HALT);
			if (len == 0 && bootdv != NULL) {
				switch (bootdv->dv_class) {
				case DV_IFNET:
					nswapdev = NODEV;
					break;
				case DV_DISK:
					nswapdev = MAKEDISKDEV(major(nrootdev),
					    DISKUNIT(nrootdev), 1);
					break;
				case DV_TAPE:
				case DV_TTY:
				case DV_DULL:
				case DV_CPU:
					break;
				}
				break;
			}
			dv = getdisk(buf, len, 1, &nswapdev);
			if (dv) {
				if (dv->dv_class == DV_IFNET)
					nswapdev = NODEV;
				break;
			}
		}
gotswap:
		rootdev = nrootdev;
		dumpdev = nswapdev;
		swdevt[0].sw_dev = nswapdev;
		swdevt[1].sw_dev = NODEV;

	} else if (mountroot == NULL) {

		/*
		 * `swap generic': Use the device the ROM told us to use.
		 */
		majdev = findblkmajor(bootdv);
		if (majdev >= 0) {
			/*
			 * Root and swap are on a disk.
			 * val[2] of the boot device is the partition number.
			 * Assume swap is on partition b.
			 */
			part = bp->val[2];
			unit = bootdv->dv_unit;
			rootdev = MAKEDISKDEV(majdev, unit, part);
			nswapdev = dumpdev = MAKEDISKDEV(major(rootdev),
			    DISKUNIT(rootdev), 1);
		} else {
			/*
			 * Root and swap are on a net.
			 */
			nswapdev = dumpdev = NODEV;
		}
		swdevt[0].sw_dev = nswapdev;
		/* swdevt[1].sw_dev = NODEV; */

	} else {

		/*
		 * `root DEV swap DEV': honour rootdev/swdevt.
		 * rootdev/swdevt/mountroot already properly set.
		 */
		if (bootdv->dv_class == DV_DISK)
			printf("root on %s%c\n", bootdv->dv_xname,
			    part + 'a');
		majdev = major(rootdev);
		unit = DISKUNIT(rootdev);
		part = DISKPART(rootdev);
		return;
	}

	switch (bootdv->dv_class) {
#if defined(NFSCLIENT)
	case DV_IFNET:
		mountroot = nfs_mountroot;
		nfsbootdevname = bootdv->dv_xname;
		return;
#endif
	case DV_DISK:
		mountroot = dk_mountroot;
		majdev = major(rootdev);
		unit = DISKUNIT(rootdev);
		part = DISKPART(rootdev);
		printf("root on %s%c\n", bootdv->dv_xname,
		    part + 'a');
		break;
	default:
		printf("can't figure root, hope your kernel is right\n");
		return;
	}

	/*
	 * Make the swap partition on the root drive the primary swap.
	 */
	temp = NODEV;
	for (swp = swdevt; swp->sw_dev != NODEV; swp++) {
		if (majdev == major(swp->sw_dev) &&
		    unit == DISKUNIT(swp->sw_dev)) {
			temp = swdevt[0].sw_dev;
			swdevt[0].sw_dev = swp->sw_dev;
			swp->sw_dev = temp;
			break;
		}
	}
	if (swp->sw_dev != NODEV) {
		/*
		 * If dumpdev was the same as the old primary swap device,
		 * move it to the new primary swap device.
		 */
		if (temp == dumpdev)
			dumpdev = swdevt[0].sw_dev;
	}
}

struct nam2blk {
	char *name;
	int maj;
} nam2blk[] = {
	{ "sd",		 7 },
	{ "rd",		 5 },
	{ "wd",		12 },
	{ "cd",		18 },
	{ "raid",	25 },
};

int
findblkmajor(dv)
	struct device *dv;
{
	char *name = dv->dv_xname;
	int i;

	for (i = 0; i < sizeof(nam2blk)/sizeof(nam2blk[0]); ++i)
		if (strncmp(name, nam2blk[i].name, strlen(nam2blk[i].name)) == 0)
			return (nam2blk[i].maj);
	return (-1);
}

char *
findblkname(maj)
	int maj;
{
	int i;

	for (i = 0; i < sizeof(nam2blk)/sizeof(nam2blk[0]); ++i)
		if (nam2blk[i].maj == maj)
			return (nam2blk[i].name);
	return (NULL);
}

static struct device *
getdisk(str, len, defpart, devp)
	char *str;
	int len, defpart;
	dev_t *devp;
{
	struct device *dv;

	if ((dv = parsedisk(str, len, defpart, devp)) == NULL) {
		printf("use one of: exit");
#ifdef RAMDISK_HOOKS
		printf(" %s[a-p]", fakerdrootdev.dv_xname);
#endif
		TAILQ_FOREACH(dv, &alldevs, dv_list) {
			if (dv->dv_class == DV_DISK)
				printf(" %s[a-p]", dv->dv_xname);
#ifdef NFSCLIENT
			if (dv->dv_class == DV_IFNET)
				printf(" %s", dv->dv_xname);
#endif
		}
		printf("\n");
	}
	return (dv);
}

struct device *
parsedisk(str, len, defpart, devp)
	char *str;
	int len, defpart;
	dev_t *devp;
{
	struct device *dv;
	char *cp, c;
	int majdev, unit, part;

	if (len == 0)
		return (NULL);
	cp = str + len - 1;
	c = *cp;
	if (c >= 'a' && (c - 'a') < MAXPARTITIONS) {
		part = c - 'a';
		*cp = '\0';
	} else
		part = defpart;

#ifdef RAMDISK_HOOKS
	if (strcmp(str, fakerdrootdev.dv_xname) == 0) {
		dv = &fakerdrootdev;
		goto gotdisk;
	}
#endif

	TAILQ_FOREACH(dv, &alldevs, dv_list) {
		if (dv->dv_class == DV_DISK &&
		    strcmp(str, dv->dv_xname) == 0) {
#ifdef RAMDISK_HOOKS
gotdisk:
#endif
			majdev = findblkmajor(dv);
			unit = dv->dv_unit;
			if (majdev < 0)
				panic("parsedisk");
			*devp = MAKEDISKDEV(majdev, unit, part);
			break;
		}
#ifdef NFSCLIENT
		if (dv->dv_class == DV_IFNET &&
		    strcmp(str, dv->dv_xname) == 0) {
			*devp = NODEV;
			break;
		}
#endif
	}

	*cp = c;
	return (dv);
}

static int
getstr(cp, size)
	char *cp;
	int size;
{
	char *lp;
	int c;
	int len;

	lp = cp;
	len = 0;
	for (;;) {
		c = cngetc();
		switch (c) {
		case '\n':
		case '\r':
			printf("\n");
			*lp++ = '\0';
			return (len);
		case '\b':
		case '\177':
		case '#':
			if (len) {
				--len;
				--lp;
				printf("\b \b");
			}
			continue;
		case '@@':
		case 'u'&037:
			len = 0;
			lp = cp;
			printf("\n");
			continue;
		default:
			if (len + 1 >= size || c < ' ') {
				printf("\007");
				continue;
			}
			printf("%c", c);
			++len;
			*lp++ = c;
		}
	}
d1156 34
@


1.62
log
@use boot(RB_USERREQ | RB_HALT) to get back to the prom instead of
special openfirmware calls; discussed with miod
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.61 2007/04/07 14:15:10 kettenis Exp $	*/
d581 2
a591 2
			if (len == 4 && strncmp(buf, "exit", 4) == 0)
				boot(RB_USERREQ | RB_HALT);
d614 2
a632 2
			if (len == 4 && strncmp(buf, "exit", 4) == 0)
				boot(RB_USERREQ | RB_HALT);
@


1.61
log
@Replace code that tries to find the boot device by pretending to walk the
device tree and matching locators in the bootpath string components with
code that tries to match the PROM node of the devices to bootpath components.
This way we don't need a list of possible boot devices that needs to be
tweaked whenever we try to support new Sun hardware (or when dlg plugs a
new fancy storage controller in a sparc64 machine).

Tested by many.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.60 2007/03/15 20:50:35 kettenis Exp $	*/
d590 2
a591 4
			if (len == 4 && strncmp(buf, "exit", 4) == 0) {
				doshutdownhooks();
				OF_exit();
			}
d632 1
a632 1
				OF_exit();
@


1.60
log
@Make sure we find the OpenFirmware node for UltraSPARC-IV cpus.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.59 2007/02/12 19:53:36 gwk Exp $	*/
d125 1
d128 1
a128 1
void bootpath_compat(struct bootpath *, int);
a129 1
char *bus_compatible(struct bootpath *, struct device *);
d255 1
a255 3
bootpath_compat(bp, nbp)
	struct bootpath *bp;
	int nbp;
d257 1
a257 1
	long node, chosen;
d274 1
a274 4
		node = OF_finddevice(buf);
		bp->compatible[0] = '\0';
		OF_getprop(node, "compatible", bp->compatible,
		    sizeof(bp->compatible));
d347 1
a347 1
	bootpath_compat(bootpath, nbootpath);
d1385 2
a1386 85
#define BUSCLASS_NONE		0
#define BUSCLASS_MAINBUS	1
#define BUSCLASS_IOMMU		2
#define BUSCLASS_OBIO		3
#define BUSCLASS_SBUS		4
#define BUSCLASS_VME		5
#define BUSCLASS_PCI		6
#define BUSCLASS_XDC		7
#define BUSCLASS_XYC		8
#define BUSCLASS_FDC		9
#define BUSCLASS_SCHIZO		10

static struct {
	char	*name;
	int	class;
} bus_class_tab[] = {
	{ "mainbus",	BUSCLASS_MAINBUS },
	{ "upa",	BUSCLASS_MAINBUS },
	{ "psycho",	BUSCLASS_MAINBUS },
	{ "schizo",	BUSCLASS_SCHIZO },
	{ "obio",	BUSCLASS_OBIO },
	{ "iommu",	BUSCLASS_IOMMU },
	{ "sbus",	BUSCLASS_SBUS },
	{ "xbox",	BUSCLASS_SBUS },
	{ "esp",	BUSCLASS_SBUS },
	{ "isp",	BUSCLASS_SBUS },
	{ "dma",	BUSCLASS_SBUS },
	{ "espdma",	BUSCLASS_SBUS },
	{ "ledma",	BUSCLASS_SBUS },
	{ "simba",	BUSCLASS_PCI },
	{ "ppb",	BUSCLASS_PCI },
	{ "isp",	BUSCLASS_PCI },
	{ "pciide",	BUSCLASS_PCI },
	{ "siop",	BUSCLASS_PCI },
	{ "pci",	BUSCLASS_PCI },
	{ "mpi",	BUSCLASS_PCI },
	{ "fdc",	BUSCLASS_FDC },
	{ "fp",		BUSCLASS_NONE},
};

/*
 * A list of PROM device names that differ from our OpenBSD
 * device names.
 */
static const struct dev_compat_tab {
	char	*bpname;
	int	class;
	char	*cfname;
} dev_compat_tab[] = {
	{ "espdma",	BUSCLASS_NONE,		"dma" },
	{ "QLGC,isp",	BUSCLASS_NONE,		"isp" },
	{ "SUNW,qlc",	BUSCLASS_NONE,		"isp" },
	{ "PTI,isp",	BUSCLASS_NONE,		"isp" },
	{ "ptisp",	BUSCLASS_NONE,		"isp" },
	{ "SUNW,isptwo", BUSCLASS_NONE,		"isp" },
	{ "SUNW,fdtwo",	BUSCLASS_NONE,		"fdc" },
	{ "pci108e,8001", BUSCLASS_SCHIZO,	"schizo" },
	{ "pci",	BUSCLASS_MAINBUS,	"psycho" },
	{ "pci",	BUSCLASS_PCI,		"ppb" },
	{ "ide",	BUSCLASS_PCI,		"pciide" },
	{ "disk",	BUSCLASS_NONE,		"wd" },
	{ "cmdk",	BUSCLASS_NONE,		"wd" },
	{ "pci108e,1101.1", BUSCLASS_NONE,	"gem" },
	{ "dc",		BUSCLASS_NONE,		"dc" },
	/* ``network'' might be either gem or hme */
	{ "network",	BUSCLASS_NONE,		"gem" },
	{ "network",	BUSCLASS_NONE,		"hme" },
	{ "ethernet",	BUSCLASS_NONE,		"dc" },
	{ "SUNW,fas",	BUSCLASS_NONE,		"esp" },
	{ "SUNW,hme",	BUSCLASS_NONE,		"hme" },
	{ "glm",	BUSCLASS_PCI,		"siop" },
	{ "scsi",	BUSCLASS_PCI,		"siop" },
	{ "SUNW,glm",	BUSCLASS_PCI,		"siop" },
	{ "sd",		BUSCLASS_NONE,		"sd" },
	{ "ide-disk",	BUSCLASS_NONE,		"wd" },
	{ "LSILogic,sas", BUSCLASS_NONE,	"mpi" },
	{ "fp",		BUSCLASS_NONE,		"scsibus" },
	{ "ssd",	BUSCLASS_NONE,		"sd" },
	{ NULL }
};

char *
bus_compatible(bp, dev)
	struct bootpath *bp;
	struct device *dev;
d1388 8
a1395 3
	const struct dev_compat_tab *lore, *sub;
	int class = bus_class(dev);
	const char *dvname = dev->dv_cfdata->cf_driver->cd_name;
d1398 2
a1399 5
	 * First try matching the ``compatible'' property.
	 * However, since more than one device can share the same
	 * ``compatible'' property, we have to take this into account
	 * and favor the entry matching our current device name, if
	 * there is one.
d1401 2
a1402 14
	for (lore = dev_compat_tab; lore->bpname != NULL; lore++) {
		if (strcmp(bp->compatible, lore->bpname) != 0)
			continue;
		if (lore->class != BUSCLASS_NONE &&
		    lore->class != class)
			continue;
		for (sub = lore + 1; sub->bpname != NULL; sub++) {
			if (strcmp(lore->bpname, sub->bpname) != 0)
				break;
			if (strcmp(sub->cfname, dvname) == 0)
				return (sub->cfname);
		}
		return (lore->cfname);
	}
d1404 3
a1406 45
	/*
	 * If it has not been found, match on the ``name'' property;
	 * there can only be one instance in the table.
	 */
	for (lore = dev_compat_tab; lore->bpname != NULL; lore++) {
		if (strcmp(bp->name, lore->bpname) == 0 &&
		    (lore->class == BUSCLASS_NONE ||
		     lore->class == class))
			return (lore->cfname);
	}

	return (bp->name);
}

int
bus_class(dev)
	struct device *dev;
{
	char *name;
	int i, class;

	class = BUSCLASS_NONE;
	if (dev == NULL)
		return (class);

	name = dev->dv_cfdata->cf_driver->cd_name;
	for (i = sizeof(bus_class_tab)/sizeof(bus_class_tab[0]); i-- > 0;) {
		if (strcmp(name, bus_class_tab[i].name) == 0) {
			class = bus_class_tab[i].class;
			break;
		}
	}

	return (class);
}

int
instance_match(dev, aux, bp)
	struct device *dev;
	void *aux;
	struct bootpath *bp;
{
	struct mainbus_attach_args *ma;
	struct sbus_attach_args *sa;
	struct pci_attach_args *pa;
d1409 1
a1409 10
	 * Several devices are represented on bootpaths in one of
	 * two formats, e.g.:
	 *	(1) ../sbus@@.../esp@@<offset>,<slot>/sd@@..  (PROM v3 style)
	 *	(2) /sbus0/esp0/sd@@..                      (PROM v2 style)
	 *
	 * hence we fall back on a `unit number' check if the bus-specific
	 * instance parameter check does not produce a match.
	 *
	 * For PCI devices, we get:
	 *	../pci@@../xxx@@<dev>,<fn>/...
d1411 2
d1415 3
a1417 1
	 * Rank parent bus so we know which locators to check.
d1419 7
a1425 65
	switch (bus_class(dev->dv_parent)) {
	case BUSCLASS_MAINBUS:
		ma = aux;
		DPRINTF(ACDB_BOOTDEV,
		    ("instance_match: mainbus device, want %#x have %#x\n",
		    ma->ma_upaid, bp->val[0]));
		if (bp->val[0] != ma->ma_upaid)
			break;
		if (bus_class(dev) != BUSCLASS_SCHIZO)
			return (1);
		if (ma->ma_nreg < 1) {
			DPRINTF(ACDB_BOOTDEV,
			    ("instance match: schizo not enough regs %d\n",
			    ma->ma_nreg));
			break;
		}
		DPRINTF(ACDB_BOOTDEV,
		    ("instance_match: schizo device, want %llx have %llx\n",
		    (unsigned long long)ma->ma_reg[0].ur_paddr & 0x00700000,
		    (unsigned long long)bp->val[1]));
		if ((ma->ma_reg[0].ur_paddr & 0x00700000) == bp->val[1])
			return (1);
		break;
	case BUSCLASS_SBUS:
		sa = aux;
		DPRINTF(ACDB_BOOTDEV, ("instance_match: sbus device, "
		    "want slot %#x offset %#x have slot %#x offset %#x\n",
		     bp->val[0], bp->val[1], sa->sa_slot, sa->sa_offset));
		if (bp->val[0] == sa->sa_slot && bp->val[1] == sa->sa_offset)
			return (1);
		break;
	case BUSCLASS_PCI:
		pa = aux;
		DPRINTF(ACDB_BOOTDEV, ("instance_match: pci device, "
		    "want dev %#x fn %#x have dev %#x fn %#x\n",
		     bp->val[0], bp->val[1], pa->pa_device, pa->pa_function));
		if (bp->val[0] == pa->pa_device &&
		    bp->val[1] == pa->pa_function)
			return (1);
		break;
	case BUSCLASS_SCHIZO:
		ma = aux;
		if (ma->ma_nreg < 1) {
			DPRINTF(ACDB_BOOTDEV, ("schizo: not enough regs %d\n",
			    ma->ma_nreg));
			break;
		}
		DPRINTF(ACDB_BOOTDEV,
		    ("instance_match: mainbus device, want %#x/%llx have %#x/%llx\n",
		    ma->ma_upaid,
		    (unsigned long long)ma->ma_reg[0].ur_paddr & 0x00700000,
		    bp->val[0], (unsigned long long)bp->val[1]));
		if (bp->val[0] == ma->ma_upaid &&
		    bp->val[1] == (ma->ma_reg[0].ur_paddr & 0x00700000))
			return (1);
		break;
	default:
		break;
	}

	if (bp->val[0] == -1 && bp->val[1] == dev->dv_unit)
		return (1);

	return (0);
}
d1427 2
a1428 13
void
device_register(dev, aux)
	struct device *dev;
	void *aux;
{
	struct bootpath *bp = bootpath_store(0, NULL);
	char *dvname, *bpname;

	/*
	 * If device name does not match current bootpath component
	 * then there's nothing interesting to consider.
	 */
	if (bp == NULL)
d1430 1
d1432 5
a1436 13
	/*
	 * Translate PROM name in case our drivers are named differently
	 */
	bpname = bus_compatible(bp, dev);
	dvname = dev->dv_cfdata->cf_driver->cd_name;

	DPRINTF(ACDB_BOOTDEV,
	    ("\n%s: device_register: dvname %s(%s) bpname %s(%s)\n",
	    dev->dv_xname, dvname, dev->dv_xname, bpname, bp->name));

	/* First, match by name */
	if (strcmp(dvname, bpname) != 0 &&
	    (strcmp(dvname, "schizo") != 0 || strcmp(bpname, "pci") != 0))
d1438 1
d1440 1
a1440 36
	if (bus_class(dev) != BUSCLASS_NONE) {
		/*
		 * A bus or controller device of sorts. Check instance
		 * parameters and advance boot path on match.
		 */
		if (instance_match(dev, aux, bp) != 0) {
			bp->dev = dev;
			bootpath_store(1, bp + 1);
			DPRINTF(ACDB_BOOTDEV, ("\t-- found bus controller %s\n",
			    dev->dv_xname));
			if (strcmp(bp->name, "ide") == 0 &&
			    strcmp((bp + 1)->name, "ata") == 0 &&
			    strcmp((bp + 2)->name, "cmdk") == 0) {
				if ((bp + 2)->val[1] == 0 &&
				    (bp + 1)->val[1] == 0) {
					(bp + 1)->dev = dev;
					bootpath_store(1, bp + 2);
					(bp + 2)->val[0] +=
					    2 * ((bp + 1)->val[0]);
					(bp + 2)->val[1] = 0;
				}
			}
			return;
		}
	} else if (strcmp(dvname, "le") == 0 ||
		   strcmp(dvname, "hme") == 0) {
		/*
		 * ethernet devices.
		 */
		if (instance_match(dev, aux, bp) != 0) {
			nail_bootdev(dev, bp);
			DPRINTF(ACDB_BOOTDEV, ("\t-- found ethernet controller %s\n",
			    dev->dv_xname));
			return;
		}
	} else if (strcmp(bp->name, "fp") == 0) {
d1443 4
a1446 3
		if (bp->val[0] == sl->scsibus) {
			DPRINTF(ACDB_BOOTDEV, ("\t-- found fp scsibus %s\n",
			    dev->dv_xname));
d1450 3
a1452 1
	} else if (strcmp(dvname, "sd") == 0 || strcmp(dvname, "cd") == 0) {
d1468 2
a1469 3
			/* fibre channel? */
			if (sl->port_wwn != 0 && sl->port_wwn == bp->val[0] &&
			    sl->lun == sl->lun) {
a1470 3
				DPRINTF(ACDB_BOOTDEV,
				    ("\t-- found fc/ssd disk %s\n",
				    dev->dv_xname));
d1475 1
a1475 1
		/* Check the controller that this scsibus is on */
d1489 1
a1489 1
		if (sl->target == target && sl->lun == lun) {
a1490 2
			DPRINTF(ACDB_BOOTDEV, ("\t-- found [cs]d disk %s\n",
			    dev->dv_xname));
d1493 3
a1495 1
	} else if (strcmp("wd", dvname) == 0) {
a1501 12
			DPRINTF(ACDB_BOOTDEV, ("\t-- found wd disk %s\n",
			    dev->dv_xname));
			return;
		}
	} else {
		/*
		 * Generic match procedure.
		 */
		if (instance_match(dev, aux, bp) != 0) {
			nail_bootdev(dev, bp);
			DPRINTF(ACDB_BOOTDEV, ("\t-- found generic device %s\n",
			    dev->dv_xname));
d1522 1
@


1.59
log
@Fix the hw.vendor/product sysctls on sparc64, handle the cases where
banner-name begins with "SUNW," and make a copy of the platform_type buffer
before chopping it up, so other/future users of platform_type dont get a
rude shock.

deraadt asked for this a 100 million years ago before 4.0.
tested by pyr, brad, and kettenis.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.58 2006/11/28 16:56:50 dlg Exp $	*/
d1059 19
@


1.58
log
@rename scsibus_attach_args to scsi_attach_args. this can help avoid
confusing when trying to attach scsibus to a hba, since it is really meant
for attaching scsi devices to scsibus.

ok deraadt@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.57 2006/08/10 01:11:13 gwk Exp $	*/
d1027 8
a1034 3
	if (len > 0) {
		hw_vendor = platform_type;
		if ((p = memchr(hw_vendor, ' ', len)) != NULL) {
a1036 2
			if ((p = memchr(p, '(', len - (p - hw_vendor))) != NULL)
				*p = '\0'; 
d1038 2
d1061 1
a1061 1
		
@


1.57
log
@Hookup hw.vendor and hw.product sysctls on sparc64.
ok dlg@@, "looks good" miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.56 2006/06/01 01:17:25 jason Exp $	*/
d1688 1
a1688 1
		struct scsibus_attach_args *sa = aux;
@


1.56
log
@oops, remove debugging cruft
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.55 2006/05/31 20:11:31 jason Exp $	*/
d107 3
d1002 1
a1002 1
	char buf[32];
d1004 1
a1004 1
	int node0, node, rv;
d1022 2
a1023 2
	if (OF_getprop(findroot(), "banner-name", platform_type,
	    sizeof(platform_type)) <= 0)
d1027 9
a1035 1

@


1.55
log
@extend the bootpath values to 64bits, and deal with fallout
extend str2hex to handle long's, and teach it that strings starting with 'w',
consisting of hex digits are really just hex digits
match fp to scsibus (fiber port)
match fiber channel portwwn/lun to it's bootpath variables
result: with a small change to isp(mailed to mjacob) we can correctly
autoconf with a boot path of:
/pci@@8,600000/SUNW,qlc@@4/fp@@0,0/disk@@w21000004cf948498,0:a/bsd
ie. schizo/   isp/       scsisbus/disk with port WWN of 21...98, lun 0, partition a
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.54 2006/05/31 01:03:20 jason Exp $	*/
a171 1
		printf("dubbya...%s\n", str);
@


1.54
log
@match SUNW,qlc->isp (one step away from root on isp/fibre channel on US3)
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.53 2006/05/30 23:24:15 jason Exp $	*/
d107 1
a107 1
static	char *str2hex(char *, int *);
d166 1
a166 3
str2hex(str, vp)
	register char *str;
	register int *vp;
d168 19
a186 1
	register int v, c;
d431 1
a431 1
			printf("/%s@@%x,%x", bp->name, bp->val[0], bp->val[1]);
d1393 1
d1432 2
d1661 9
d1681 1
a1681 1
			(struct scsibus_softc *)dev->dv_parent;
d1684 12
@


1.53
log
@how about we -correctly- match the schizo.  When I get home, I'm going
to make this code cleaner, but I'm bloody tired of typing the root
device name
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.52 2006/05/30 19:37:29 jason Exp $	*/
d1390 1
@


1.52
log
@rework the schizo attach to match the upaid and paddr regs
(/pci@@8,600000/, 8 == upaid, 600000 == paddr of registers)
Also, match the mpi (LSILogic,sas)
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.51 2006/05/28 19:09:39 jason Exp $	*/
d1516 15
a1530 1
		if (bp->val[0] == ma->ma_upaid)
@


1.51
log
@Can't call directly back into the prom if we "exit" at the root
device prompt.  We need to call shutdownhooks which will set the sab
back into the mode the prom likes (I hate this chip)
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.50 2006/05/28 18:04:41 jason Exp $	*/
d1350 1
d1359 1
a1359 1
	{ "schizo",	BUSCLASS_MAINBUS },
d1375 1
d1394 1
a1395 1
	{ "pci",	BUSCLASS_MAINBUS,	"schizo" },
d1413 1
d1536 16
d1589 1
a1589 1
	    (strcmp(dvname, "schizo") != 0 || strcmp(bpname, "psycho") != 0))
@


1.50
log
@- if the "upa-portid" property doesn't exist, try "portid" (schizo)
- hack enough of autoconf to get psycho and schizo working with device_register
(autoconf appears to work now for schizo machines).
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.49 2006/05/28 06:11:26 jason Exp $	*/
d577 2
a578 1
			if (len == 4 && strncmp(buf, "exit", 4) == 0)
d580 1
@


1.49
log
@formatting
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.48 2006/05/28 03:22:35 henning Exp $	*/
d1082 5
a1086 2
			sizeof(portid)) 
			portid = -1;
d1356 1
d1391 1
d1567 2
a1568 1
	if (strcmp(dvname, bpname) != 0)
@


1.48
log
@intrducing device type DV_SENSOR turned out to be a bad idea as it
affects way more than just hotplug messages. remove DV_SENSOR and use
DV_DULL for the moment. proper solution coming.
discussed with deraadt mk jason
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.47 2006/05/28 02:49:18 jason Exp $	*/
d556 1
a556 1
			printf("root device ");
d558 1
a558 1
				printf("(default %s%c)",
@


1.47
log
@more hotplug fallout: add DV_SENSOR to the device type switch
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.46 2006/04/09 12:02:23 miod Exp $	*/
a613 1
				case DV_SENSOR:
@


1.46
log
@Rewrite bus_compatible() to allow one alias to expand to several drivers,
and in this case pick the one which matches the driver we are currently
attaching, if any; allows systems netbooted via gem interfaces to recognize
their boot device, and solves PR #5058.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.45 2006/03/15 20:20:41 miod Exp $	*/
d614 1
@


1.45
log
@Nuke dk_establish(), no longer used.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.44 2006/02/06 17:19:31 jmc Exp $	*/
d1372 1
a1372 1
 * A list of PROM device names that differ from our NetBSD
d1375 1
a1375 1
static struct {
d1393 2
d1404 1
d1412 3
a1414 1
	int i, class = bus_class(dev);
d1416 31
a1446 11
	for (i = sizeof(dev_compat_tab)/sizeof(dev_compat_tab[0]); i-- > 0;) {
		if (strcmp(bp->compatible, dev_compat_tab[i].bpname) == 0 &&
		    (dev_compat_tab[i].class == BUSCLASS_NONE ||
		     dev_compat_tab[i].class == class))
			return (dev_compat_tab[i].cfname);
	}
	for (i = sizeof(dev_compat_tab)/sizeof(dev_compat_tab[0]); i-- > 0;) {
		if (strcmp(bp->name, dev_compat_tab[i].bpname) == 0 &&
		    (dev_compat_tab[i].class == BUSCLASS_NONE ||
		     dev_compat_tab[i].class == class))
			return (dev_compat_tab[i].cfname);
@


1.44
log
@typos from alexey dobriyan;
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.43 2005/12/27 18:31:11 miod Exp $	*/
d429 1
a429 1
 * dk_establish(), and use this to recover the bootpath.
@


1.43
log
@Remove unused sw_nblks field of struct swdevt. Then, remove swapconf()
which duplicates work done by uvm_swap_init().
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.42 2005/10/06 19:53:40 brad Exp $	*/
d327 1
a327 1
					    sbus offset/adddress */
@


1.42
log
@match isp as a PCI device called "SUNW,isptwo".

From mrg NetBSD

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.41 2005/05/14 19:27:38 brad Exp $	*/
a113 1
void	swapconf(void);
a504 1
	swapconf();
a505 17
}

void
swapconf()
{
	struct swdevt *swp;
	int nblks;

	for (swp = swdevt; swp->sw_dev != NODEV; swp++)
		if (bdevsw[major(swp->sw_dev)].d_psize) {
			nblks =
			  (*bdevsw[major(swp->sw_dev)].d_psize)(swp->sw_dev);
			if (nblks != -1 &&
			    (swp->sw_nblks == 0 || swp->sw_nblks > nblks))
				swp->sw_nblks = nblks;
			swp->sw_nblks = ctod(dtoc(swp->sw_nblks));
		}
@


1.41
log
@Match a device_type of scsi-2 as SCSI (as found in a Netra 1405).

From NetBSD

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.40 2005/05/01 18:15:49 miod Exp $	*/
d1383 1
d1403 1
@


1.40
log
@When parsing the bootpath, correctly handle ":foo" modifiers if they are
more than one-letter wrong; fixes boot device determination with
  /.../ledma:tpe/le...
strings (PR #4192)
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.39 2005/04/21 00:15:43 deraadt Exp $	*/
d139 1
@


1.39
log
@correct idiom for snprintf failure handling; ok beck
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.38 2005/03/15 18:46:39 miod Exp $	*/
d313 12
a324 3
			if (*cp == ':')
				/* XXX - we handle just one char */
				bp->val[2] = *++cp - 'a', ++cp;
@


1.38
log
@Nuke matchbyname(), which isn't used anymore.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.37 2004/12/25 23:02:25 miod Exp $	*/
d549 2
a550 2
			unit);
		if (len >= sizeof(buf))
@


1.37
log
@Use list and queue macros where applicable to make the code easier to read;
no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.36 2004/10/23 08:21:27 mjc Exp $	*/
a159 14

/*
 * Most configuration on the SPARC is done by matching OPENPROM Forth
 * device names with our internal names.
 */
int
matchbyname(parent, cf, aux)
	struct device *parent;
	struct cfdata *cf;
	void *aux;
{
	printf("%s: WARNING: matchbyname\n", cf->cf_driver->cd_name);
	return (0);
}
@


1.36
log
@configure() -> cpu_configure()
ok grange@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.35 2004/09/28 15:15:50 jason Exp $	*/
d789 1
a789 2
		for (dv = alldevs.tqh_first; dv != NULL;
		    dv = dv->dv_list.tqe_next) {        
d829 1
a829 1
	for (dv = alldevs.tqh_first; dv != NULL; dv = dv->dv_list.tqe_next) {
d1338 1
a1338 1
	struct device *dev = alldevs.tqh_first;
d1352 1
a1352 1
		if ((dev = dev->dv_list.tqe_next) == NULL)
@


1.35
log
@allow booting from isp devices
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.34 2003/12/12 12:33:45 jmc Exp $	*/
d993 1
a993 1
 * Our main job is to attach the CPU (the root node we got in configure())
@


1.34
log
@initialze -> initializes; from Eric Borsboom;
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.33 2003/07/31 17:23:24 jason Exp $	*/
d1382 1
@


1.33
log
@remove autoconf_nzs; from netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.32 2003/06/02 23:27:56 millert Exp $	*/
d228 1
a228 1
	 * just initialze some pointers to important things
@


1.32
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.31 2003/04/06 18:54:19 ho Exp $	*/
a988 2

int autoconf_nzs = 0;	/* must be global so obio.c can see it */
@


1.31
log
@strcat/strcpy/sprintf cleanup. krw@@, anil@@ ok. art@@ tested sparc64.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.30 2003/02/17 01:29:20 henric Exp $	*/
d28 1
a28 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.30
log
@
Add support for the Sun Enterprise 450
Reduce the size of a GENERIC kernel by ~190k
Remove the nasty pointer/bus_space_handle_t casts
Adds debug bus_space code including the ability to trace
    bus operations (it actually works now).

The following rules are now followed (and verfified by the debug
code):

1.  A "bus_space_handle_t" may only be used with the
    "bus_space_tag_t" that created it.
2.  Only "bus_space_map()" may create "bus_space_handle_t"s.
3.  A "bus_space_handle_t" may not be modified after it has
    been created (other than being destroyed by "bus_space_unmap()").


Thanks to help from mcbride, marc, jason, drahn, to anyone that might
have slipped my mind at the moment.

ok jason@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.29 2002/11/20 04:26:44 jason Exp $	*/
d566 2
a567 1
		len = sprintf(buf, "%s%d", findblkname(majdev), unit);
d592 1
a592 1
				strcpy(buf, bootdv->dv_xname);
d925 1
a925 1
	sprintf(buf, "%ld", freq / 1000);
d930 1
a930 1
		sprintf(p, "%ld", freq);
d1350 1
a1350 1
	sprintf(num, "%d", unit);
d1355 2
a1356 2
	strcpy(fullname, name);
	strcat(fullname, num);
@


1.29
log
@You know why I love Sun?  Consistency... deal with another weirdo root
device selection situation (IDE disk controllers on the AX).
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.28 2002/11/13 19:41:53 jason Exp $	*/
d1008 1
a1008 1
extern struct sparc_bus_space_tag mainbus_space_tag;
d1064 1
a1064 1
				ma.ma_bustag = &mainbus_space_tag;
d1106 1
a1106 1
		ma.ma_bustag = &mainbus_space_tag;
@


1.28
log
@print 'banner-name' instead of 'name' for mainbus (when available)
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.27 2002/10/12 01:09:43 krw Exp $	*/
d1579 2
a1580 2
				if (((bp + 2)->val[0] == (bp + 1)->val[0]) &&
				    ((bp + 1)->val[1] == 0)) {
d1583 3
@


1.27
log
@Remove more '\n's from panic() statements. Both trailing and leading.

Diff generated by Chris Kuethe.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.26 2002/09/04 18:25:31 jason Exp $	*/
d109 1
a109 1
char platform_type[32];
d1031 4
a1034 1
	OF_getprop(findroot(), "name", platform_type, sizeof(platform_type));
@


1.26
log
@Correctly decode the IDE channel/drive number when matching devices
(booting from master or slave on either channel should work now).
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.25 2002/06/15 17:23:31 art Exp $	*/
d1070 1
a1070 1
			panic("None of the CPUs found\n");
@


1.25
log
@Decruftification.

We will never have a.out kernels.
We will never have 32-bit kernels.
We will never have sun4c, sun4 and sun4m support in the sparc64 kernels.
We don't need support old netbsd libc.
The cpu will never be identified as some of the sun4c and sun4m types.
We don't need the gazillion of fields in cpuinfo that the sparc port uses.
Just generally remove dead code.

This is just a first step in making this meess readable.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.24 2002/06/07 19:31:08 jason Exp $	*/
d1634 2
a1635 1
		if (aa->aa_channel == bp->val[0]) {
@


1.24
log
@add a way to exit from the 'root device' prompt if we haven't found ANY possibilities.  Power cycling this machine is SLOW!
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.23 2002/04/10 04:17:50 jason Exp $	*/
a112 2
static	void crazymap(char *, int *);
int	st_crazymap(int);
a227 5
#ifndef	__arch64__
	/* Assembly glue for the PROM */
	extern void OF_sym2val32(void *);
	extern void OF_val2sym32(void *);
#endif
a246 1
#ifdef __arch64__
a248 5
#else
#if 1
	OF_set_symbol_lookup(OF_sym2val32, OF_val2sym32);
#endif
#endif
a453 50

/*
 * Set up the sd target mappings for non SUN4 PROMs.
 * Find out about the real SCSI target, given the PROM's idea of the
 * target of the (boot) device (i.e., the value in bp->v0val[0]).
 */
static void
crazymap(prop, map)
	char *prop;
	int *map;
{
	int i;

	/*
	 * Set up the identity mapping for old sun4 monitors
	 * and v[2-] OpenPROMs. Note: dkestablish() does the
	 * SCSI-target juggling for sun4 monitors.
	 */
	for (i = 0; i < 8; ++i)
		map[i] = i;
}

int
sd_crazymap(n)
	int	n;
{
	static int prom_sd_crazymap[8]; /* static: compute only once! */
	static int init = 0;

	if (init == 0) {
		crazymap("sd-targets", prom_sd_crazymap);
		init = 1;
	}
	return prom_sd_crazymap[n];
}

int
st_crazymap(n)
	int	n;
{
	static int prom_st_crazymap[8]; /* static: compute only once! */
	static int init = 0;

	if (init == 0) {
		crazymap("st-targets", prom_st_crazymap);
		init = 1;
	}
	return prom_st_crazymap[n];
}

@


1.23
log
@Be sure to print 'root on' line for RAMDISK kernels
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.22 2002/03/22 16:29:46 jason Exp $	*/
d666 2
d707 2
d851 1
a851 1
		printf("use one of:");
@


1.22
log
@dc is compatible with dc, go figure
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.21 2002/03/14 03:16:01 millert Exp $	*/
d750 3
@


1.21
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.20 2002/03/14 01:26:45 millert Exp $	*/
d1471 1
@


1.20
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.19 2002/01/25 23:54:40 jason Exp $	*/
d323 1
a323 1
	bzero((void*)bootpath, sizeof(bootpath));
d1169 1
a1169 1
			     &ma.ma_nreg, (void**)&ma.ma_reg) != 0)
d1182 1
a1182 1
			&ma.ma_ninterrupts, (void**)&ma.ma_interrupts);
d1197 1
a1197 1
			&ma.ma_naddress, (void**)&ma.ma_address);
@


1.19
log
@properly identify gem as a boot device
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.18 2002/01/16 20:50:17 miod Exp $	*/
d111 14
a124 14
static	char *str2hex __P((char *, int *));
static	int mbprint __P((void *, const char *));
static	void crazymap __P((char *, int *));
int	st_crazymap __P((int));
void	sync_crash __P((void));
int	mainbus_match __P((struct device *, void *, void *));
static	void mainbus_attach __P((struct device *, struct device *, void *));
static	int getstr __P((char *, int));
void	setroot __P((void));
void	swapconf __P((void));
void	diskconf __P((void));
static	struct device *getdisk __P((char *, int, int, dev_t *));
int	findblkmajor __P((struct device *));
char	*findblkname __P((int));
d129 8
a136 8
static	void bootpath_build __P((void));
static	void bootpath_print __P((struct bootpath *));
void bootpath_compat __P((struct bootpath *, int));

char *bus_compatible __P((struct bootpath *, struct device *));
int bus_class __P((struct device *));
int instance_match __P((struct device *, void *, struct bootpath *bp));
void nail_bootdev __P((struct device *, struct bootpath *));
d232 2
a233 2
	extern void OF_sym2val32 __P((void *));
	extern void OF_val2sym32 __P((void *));
@


1.18
log
@Don't include <sys/map.h> when you don't need what's in it.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.17 2001/12/07 05:11:14 jason Exp $	*/
d1470 1
@


1.17
log
@ethernet -> dc (Netra X1 finds its root dev correctly now)
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.16 2001/12/05 23:58:41 tdeval Exp $	*/
a52 1
#include <sys/map.h>
@


1.17.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.19 2002/01/25 23:54:40 jason Exp $	*/
d53 1
a1470 1
	{ "pci108e,1101.1", BUSCLASS_NONE,	"gem" },
@


1.17.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.17.2.1 2002/01/31 22:55:24 niklas Exp $	*/
d111 14
a124 14
static	char *str2hex(char *, int *);
static	int mbprint(void *, const char *);
static	void crazymap(char *, int *);
int	st_crazymap(int);
void	sync_crash(void);
int	mainbus_match(struct device *, void *, void *);
static	void mainbus_attach(struct device *, struct device *, void *);
static	int getstr(char *, int);
void	setroot(void);
void	swapconf(void);
void	diskconf(void);
static	struct device *getdisk(char *, int, int, dev_t *);
int	findblkmajor(struct device *);
char	*findblkname(int);
d129 8
a136 8
static	void bootpath_build(void);
static	void bootpath_print(struct bootpath *);
void bootpath_compat(struct bootpath *, int);

char *bus_compatible(struct bootpath *, struct device *);
int bus_class(struct device *);
int instance_match(struct device *, void *, struct bootpath *bp);
void nail_bootdev(struct device *, struct bootpath *);
d232 2
a233 2
	extern void OF_sym2val32(void *);
	extern void OF_val2sym32(void *);
d323 1
a323 1
	bzero((void *)bootpath, sizeof(bootpath));
a665 2
			if (len == 4 && strncmp(buf, "exit", 4) == 0)
				OF_exit();
a704 2
			if (len == 4 && strncmp(buf, "exit", 4) == 0)
				OF_exit();
a749 3
		if (bootdv->dv_class == DV_DISK)
			printf("root on %s%c\n", bootdv->dv_xname,
			    part + 'a');
d844 1
a844 1
		printf("use one of: exit");
d1169 1
a1169 1
			     &ma.ma_nreg, (void **)&ma.ma_reg) != 0)
d1182 1
a1182 1
			&ma.ma_ninterrupts, (void **)&ma.ma_interrupts);
d1197 1
a1197 1
			&ma.ma_naddress, (void **)&ma.ma_address);
a1470 1
	{ "dc",		BUSCLASS_NONE,		"dc" },
@


1.17.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.17.2.2 2002/06/11 03:38:43 art Exp $	*/
d113 2
d230 5
d254 1
d257 5
d469 50
d1133 1
a1133 1
			panic("None of the CPUs found");
d1697 1
a1697 2
		if ((bp->val[0] / 2) == aa->aa_channel &&
		    (bp->val[0] % 2) == aa->aa_drv_data->drive) {
@


1.17.2.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d109 1
a109 1
char platform_type[64];
d566 1
a566 2
		len = snprintf(buf, sizeof buf, "%s%d", findblkname(majdev),
			unit);
d591 1
a591 1
				strlcpy(buf, bootdv->dv_xname, sizeof buf);
d924 1
a924 1
	snprintf(buf, sizeof buf, "%ld", freq / 1000);
d929 1
a929 1
		snprintf(p, buf + sizeof buf - p, "%ld", freq);
d1008 1
a1008 1
extern bus_space_tag_t mainbus_space_tag;
d1031 1
a1031 4
	if (OF_getprop(findroot(), "banner-name", platform_type,
	    sizeof(platform_type)) <= 0)
		OF_getprop(findroot(), "name", platform_type,
		    sizeof(platform_type));
d1061 1
a1061 1
				ma.ma_bustag = mainbus_space_tag;
d1103 1
a1103 1
		ma.ma_bustag = mainbus_space_tag;
d1346 1
a1346 1
	snprintf(num, sizeof num, "%d", unit);
d1351 2
a1352 2
	strlcpy(fullname, name, sizeof fullname);
	strlcat(fullname, num, sizeof fullname);
d1576 2
a1577 2
				if ((bp + 2)->val[1] == 0 &&
				    (bp + 1)->val[1] == 0) {
a1579 3
					(bp + 2)->val[0] +=
					    2 * ((bp + 1)->val[0]);
					(bp + 2)->val[1] = 0;
@


1.16
log
@Enable rootdev auto-configuration by device drivers during boot.
Add support for "raid" devices (prepare future raidframe changes).

OK deraadt@@, Reviewed by drahn@@, jason@@, mickey@@ and miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.15 2001/12/05 02:09:33 jason Exp $	*/
d1472 1
@


1.15
log
@nuke rominterpret and update romgetcursoraddr() to work on sparc64; based on NetBSD work.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.14 2001/11/06 19:53:16 miod Exp $	*/
d124 2
a125 1
static int findblkmajor __P((struct device *));
d622 16
d804 2
a805 2
	{ "sd",         7 },
	{ "rd",         5 },
d807 2
a808 1
	{ "cd",         18 },
d811 1
a811 1
static int
d819 1
a819 1
		if (strncmp(name, nam2blk[i].name, strlen(nam2blk[0].name)) == 0)      
d822 12
@


1.14
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.13 2001/09/28 22:20:48 jason Exp $	*/
a1326 13
#ifdef RASTERCONSOLE
/* Pass a string to the FORTH PROM to be interpreted */
void
rominterpret(s)
	register char *s;
{

	if (promvec->pv_romvec_vers < 2)
		promvec->pv_fortheval.v0_eval(strlen(s), s);
	else
		promvec->pv_fortheval.v2_eval(s);
}

d1333 1
a1333 1
	register int **rowp, **colp;
d1335 4
a1338 1
	char buf[100];
d1341 3
a1343 3
	 * line# and column# are global in older proms (rom vector < 2)
	 * and in some newer proms.  They are local in version 2.9.  The
	 * correct cutoff point is unknown, as yet; we use 2.9 here.
d1345 5
a1349 11
	if (promvec->pv_romvec_vers < 2 || promvec->pv_printrev < 0x00020009)
		sprintf(buf,
		    "' line# >body >user %lx ! ' column# >body >user %lx !",
		    (u_long)rowp, (u_long)colp);
	else
		sprintf(buf,
		    "stdout @@ is my-self addr line# %lx ! addr column# %lx !",
		    (u_long)rowp, (u_long)colp);
	*rowp = *colp = NULL;
	rominterpret(buf);
	return (*rowp == NULL || *colp == NULL);
a1350 1
#endif
@


1.13
log
@Hack to work around bootpaths like:
bootpath: /pci@@1f,4000/ide@@3,0/ata@@0,0/cmdk@@0,0
The val[0] of ata appears to be the channel number, and cmdk is disk
(cmdk@@channel,disk)
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.12 2001/09/26 20:21:04 jason Exp $	*/
a69 1
#include <vm/vm.h>
@


1.13.4.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.13.4.2
log
@Merge in -current
@
text
@d70 1
@


1.13.4.3
log
@Merge in trunk
@
text
@d53 1
d124 1
a124 2
int	findblkmajor __P((struct device *));
char	*findblkname __P((int));
a620 16
	 * (raid) device auto-configuration could have returned
	 * the root device's id in rootdev.  Check this case.
	 */
	if (rootdev != NODEV) {
		majdev = major(rootdev);
		unit = DISKUNIT(rootdev);
		part = DISKPART(rootdev);

		len = sprintf(buf, "%s%d", findblkname(majdev), unit);
		if (len >= sizeof(buf))
			panic("setroot: device name too long");

		bootdv = getdisk(buf, len, part, &rootdev);
	}

	/*
d787 2
a788 2
	{ "sd",		 7 },
	{ "rd",		 5 },
d790 1
a790 2
	{ "cd",		18 },
	{ "raid",	25 },
d793 1
a793 1
int
d801 1
a801 1
		if (strncmp(name, nam2blk[i].name, strlen(nam2blk[i].name)) == 0)
a805 12
char *
findblkname(maj)
	int maj;
{
	int i;

	for (i = 0; i < sizeof(nam2blk)/sizeof(nam2blk[0]); ++i)
		if (nam2blk[i].maj == maj)
			return (nam2blk[i].name);
	return (NULL);
}

d1327 13
d1346 1
a1346 1
	int **rowp, **colp;
d1348 1
a1348 4
	cell_t row = NULL, col = NULL;

	OF_interpret("stdout @@ is my-self addr line# addr column# ",
	    2, &col, &row);
d1351 3
a1353 3
	 * We are running on a 64-bit machine, so these things point to
	 * 64-bit values.  To convert them to pointers to interfaces, add
	 * 4 to the address.
d1355 11
a1365 5
	if (row == NULL || col == NULL)
		return (-1);
	*rowp = (int *)(row + 4);
	*colp = (int *)(col + 4);
	return (0);
d1367 1
a1457 1
	{ "pci108e,1101.1", BUSCLASS_NONE,	"gem" },
a1458 1
	{ "ethernet",	BUSCLASS_NONE,		"dc" },
@


1.13.4.4
log
@Merge in -current from about a week ago
@
text
@d111 14
a124 14
static	char *str2hex(char *, int *);
static	int mbprint(void *, const char *);
static	void crazymap(char *, int *);
int	st_crazymap(int);
void	sync_crash(void);
int	mainbus_match(struct device *, void *, void *);
static	void mainbus_attach(struct device *, struct device *, void *);
static	int getstr(char *, int);
void	setroot(void);
void	swapconf(void);
void	diskconf(void);
static	struct device *getdisk(char *, int, int, dev_t *);
int	findblkmajor(struct device *);
char	*findblkname(int);
d129 8
a136 8
static	void bootpath_build(void);
static	void bootpath_print(struct bootpath *);
void bootpath_compat(struct bootpath *, int);

char *bus_compatible(struct bootpath *, struct device *);
int bus_class(struct device *);
int instance_match(struct device *, void *, struct bootpath *bp);
void nail_bootdev(struct device *, struct bootpath *);
d232 2
a233 2
	extern void OF_sym2val32(void *);
	extern void OF_val2sym32(void *);
d323 1
a323 1
	bzero((void *)bootpath, sizeof(bootpath));
d1169 1
a1169 1
			     &ma.ma_nreg, (void **)&ma.ma_reg) != 0)
d1182 1
a1182 1
			&ma.ma_ninterrupts, (void **)&ma.ma_interrupts);
d1197 1
a1197 1
			&ma.ma_naddress, (void **)&ma.ma_address);
@


1.13.4.5
log
@Sync the SMP branch with 3.3
@
text
@d109 1
a109 1
char platform_type[64];
d113 2
d230 5
d254 1
d257 5
d469 50
a665 2
			if (len == 4 && strncmp(buf, "exit", 4) == 0)
				OF_exit();
a704 2
			if (len == 4 && strncmp(buf, "exit", 4) == 0)
				OF_exit();
a749 3
		if (bootdv->dv_class == DV_DISK)
			printf("root on %s%c\n", bootdv->dv_xname,
			    part + 'a');
d844 1
a844 1
		printf("use one of: exit");
d1064 1
a1064 1
extern bus_space_tag_t mainbus_space_tag;
d1087 1
a1087 4
	if (OF_getprop(findroot(), "banner-name", platform_type,
	    sizeof(platform_type)) <= 0)
		OF_getprop(findroot(), "name", platform_type,
		    sizeof(platform_type));
d1117 1
a1117 1
				ma.ma_bustag = mainbus_space_tag;
d1126 1
a1126 1
			panic("None of the CPUs found");
d1159 1
a1159 1
		ma.ma_bustag = mainbus_space_tag;
a1470 1
	{ "dc",		BUSCLASS_NONE,		"dc" },
d1631 2
a1632 2
				if ((bp + 2)->val[1] == 0 &&
				    (bp + 1)->val[1] == 0) {
a1634 3
					(bp + 2)->val[0] +=
					    2 * ((bp + 1)->val[0]);
					(bp + 2)->val[1] = 0;
d1689 1
a1689 2
		if ((bp->val[0] / 2) == aa->aa_channel &&
		    (bp->val[0] % 2) == aa->aa_drv_data->drive) {
@


1.13.4.6
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.13.4.5 2003/03/27 23:42:37 niklas Exp $	*/
d566 1
a566 2
		len = snprintf(buf, sizeof buf, "%s%d", findblkname(majdev),
			unit);
d591 1
a591 1
				strlcpy(buf, bootdv->dv_xname, sizeof buf);
d924 1
a924 1
	snprintf(buf, sizeof buf, "%ld", freq / 1000);
d929 1
a929 1
		snprintf(p, buf + sizeof buf - p, "%ld", freq);
d1349 1
a1349 1
	snprintf(num, sizeof num, "%d", unit);
d1354 2
a1355 2
	strlcpy(fullname, name, sizeof fullname);
	strlcat(fullname, num, sizeof fullname);
@


1.13.4.7
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.13.4.6 2003/05/13 19:41:09 ho Exp $	*/
d28 5
a32 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.13.4.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d228 1
a228 1
	 * just initializes some pointers to important things
d989 2
@


1.12
log
@grab the "compatible" prom property and use that for searching the device
tree as well as the "name".  This allows us to differentiate 'sd' and 'wd'
pretty easily (and makes it less ambiguous).
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.11 2001/09/20 00:01:34 jason Exp $	*/
d1458 1
d1615 9
@


1.11
log
@remove mountroot_hooks and add all of the stuff necessary for RAMDISK_HOOKS
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.10 2001/09/19 21:44:35 deraadt Exp $	*/
d132 1
d134 1
a134 1
char *bus_compatible __P((char *, struct device *));
d268 30
d357 1
d1457 2
a1458 2
	{ "disk",	BUSCLASS_NONE,		"wd" },  /* XXX */
	{ "network",	BUSCLASS_NONE,		"hme" }, /* XXX */
d1462 1
d1464 2
d1469 2
a1470 2
bus_compatible(bpname, dev)
	char *bpname;
d1476 7
a1482 1
		if (strcmp(bpname, dev_compat_tab[i].bpname) == 0 &&
d1488 1
a1488 1
	return (bpname);
d1593 1
a1593 1
	bpname = bus_compatible(bp->name, dev);
@


1.10
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.9 2001/09/19 21:32:20 miod Exp $	*/
d154 3
a156 11
/*
 * The mountroot_hook is provided as a mechanism for devices to perform
 * a special function if they're the root device, such as the floppy
 * drive ejecting the current disk and prompting for a filesystem floppy.
 */
struct mountroot_hook {
	LIST_ENTRY(mountroot_hook) mr_link;
	struct	device *mr_device;
	void	(*mr_func) __P((struct device *));
};
LIST_HEAD(, mountroot_hook) mrh_list;
a499 3
	/* Initialize the mountroot_hook list. */
	LIST_INIT(&mrh_list);

a575 1
	struct mountroot_hook *mrhp;
d583 3
d587 1
d706 1
a706 1
		goto gotroot;
a749 14

gotroot:
	/*
	 * Find mountroot hook and execute.
	 */
	for (mrhp = mrh_list.lh_first; mrhp != NULL;
	     mrhp = mrhp->mr_link.le_next)
		if (mrhp->mr_device == bootdv) {
			if (findblkmajor(mrhp->mr_device) == major(rootdev)) 
				(*mrhp->mr_func)(bootdv);
			else
				(*mrhp->mr_func)(NULL);
			break;
		}
d785 3
d822 7
d832 3
@


1.9
log
@Now is a good time to commit this cosmetic maxpartition-related change...
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.8 2001/09/18 17:25:24 jason Exp $	*/
d792 1
a792 2
		if (strncmp(name, nam2blk[i].name, strlen(nam2blk[0].name)) == 0
)      
@


1.8
log
@make sure mountroot_hook list is initialized
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.7 2001/08/31 15:12:05 jason Exp $	*/
d811 1
a811 1
				printf(" %s[a-h]", dv->dv_xname);
@


1.7
log
@implement autoconf mechanism using device_register(); from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.6 2001/08/25 12:29:56 art Exp $	*/
d507 3
@


1.6
log
@Our diskconf needs process context. Do just like i386, move
setroot, swapconf and dumpconf into a hook that main runs after scheduling
has been enabled.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.5 2001/08/23 15:20:48 art Exp $	*/
d85 3
d127 1
d133 5
a1159 1
		ma.ma_bp = bootpath;
d1379 294
@


1.5
log
@Allow wd to be root and some cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.4 2001/08/22 05:08:11 jason Exp $	*/
d120 1
d537 7
d546 1
a546 1
	cold = 0;
d552 2
a553 2
	register struct swdevt *swp;
	register int nblks;
a563 1
	dumpconf();
d665 1
a665 1
		/* swdevt[1].sw_dev = NODEV; */
a759 1

@


1.4
log
@setup the 'machine' commands for ddb
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.3 2001/08/20 19:40:43 jason Exp $	*/
d562 3
a564 3
	register struct swdevt *swp;
	register struct device *dv;
	register int len, majdev, unit, part;
d762 1
d771 1
a771 1
	register int i;
d786 1
a786 1
	register struct device *dv;
d810 2
a811 2
	register struct device *dv;
	register char *cp, c;
d849 2
a850 2
	register char *cp;
	register int size;
d852 3
a854 3
	register char *lp;
	register int c;
	register int len;
@


1.3
log
@more stuff to do with OpenBSD/sparc style bootpath determination
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d250 1
@


1.2
log
@Our ddb_init doesn't take argument (it should, but that's another story).
@
text
@d1 1
d117 5
d144 12
d500 8
d534 4
a539 1
#if XXX
d541 1
a541 1
cpu_rootconf()
d543 26
d570 3
a572 2
	struct device *bootdv;
	int bootpartition;
d575 188
a762 2
	bootdv = bp == NULL ? NULL : bp->dev;
	bootpartition = bootdv == NULL ? 0 : bp->val[2];
d764 36
a799 1
	setroot(bootdv, bootpartition);
d801 37
d839 51
d1143 1
a1363 315


/*
 * Device registration used to determine the boot device.
 * 
 * Copied from the sparc port.
 */
#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>

#define BUSCLASS_NONE		0
#define BUSCLASS_MAINBUS	1
#define BUSCLASS_IOMMU		2
#define BUSCLASS_OBIO		3
#define BUSCLASS_SBUS		4
#define BUSCLASS_VME		5
#define BUSCLASS_PCI		6
#define BUSCLASS_XDC		7
#define BUSCLASS_XYC		8
#define BUSCLASS_FDC		9

#if XXX
static int bus_class __P((struct device *));
static char *bus_compatible __P((char *, struct device *));
static int instance_match __P((struct device *, void *, struct bootpath *));
static void nail_bootdev __P((struct device *, struct bootpath *));

static struct {
	char	*name;
	int	class;
} bus_class_tab[] = {
	{ "mainbus",	BUSCLASS_MAINBUS },
	{ "upa",	BUSCLASS_MAINBUS },
	{ "psycho",	BUSCLASS_MAINBUS },
	{ "obio",	BUSCLASS_OBIO },
	{ "iommu",	BUSCLASS_IOMMU },
	{ "sbus",	BUSCLASS_SBUS },
	{ "xbox",	BUSCLASS_SBUS },
	{ "esp",	BUSCLASS_SBUS },
	{ "dma",	BUSCLASS_SBUS },
	{ "espdma",	BUSCLASS_SBUS },
	{ "ledma",	BUSCLASS_SBUS },
	{ "simba",	BUSCLASS_PCI },
	{ "ppb",	BUSCLASS_PCI },
	{ "pciide",	BUSCLASS_PCI },
	{ "siop",	BUSCLASS_PCI },
	{ "pci",	BUSCLASS_PCI },
	{ "fdc",	BUSCLASS_FDC },
};

/*
 * A list of PROM device names that differ from our NetBSD
 * device names.
 */
static struct {
	char	*bpname;
	int	class;
	char	*cfname;
} dev_compat_tab[] = {
	{ "espdma",	BUSCLASS_NONE,		"dma" },
	{ "QLGC,isp",	BUSCLASS_NONE,		"isp" },
	{ "PTI,isp",	BUSCLASS_NONE,		"isp" },
	{ "ptisp",	BUSCLASS_NONE,		"isp" },
	{ "SUNW,fdtwo",	BUSCLASS_NONE,		"fdc" },
	{ "pci",	BUSCLASS_MAINBUS,	"psycho" },
	{ "pci",	BUSCLASS_PCI,		"ppb" },
	{ "ide",	BUSCLASS_PCI,		"pciide" },
	{ "disk",	BUSCLASS_NONE,		"wd" },  /* XXX */
	{ "network",	BUSCLASS_NONE,		"hme" }, /* XXX */
	{ "SUNW,fas",	BUSCLASS_NONE,		"esp" },
	{ "SUNW,hme",	BUSCLASS_NONE,		"hme" },
	{ "glm",	BUSCLASS_PCI,		"siop" },
	{ "SUNW,glm",	BUSCLASS_PCI,		"siop" },
};

static char *
bus_compatible(bpname, dev)
	char *bpname;
	struct device *dev;
{
	int i, class = bus_class(dev);

	for (i = sizeof(dev_compat_tab)/sizeof(dev_compat_tab[0]); i-- > 0;) {
		if (strcmp(bpname, dev_compat_tab[i].bpname) == 0 &&
		    (dev_compat_tab[i].class == BUSCLASS_NONE ||
		     dev_compat_tab[i].class == class))
			return (dev_compat_tab[i].cfname);
	}

	return (bpname);
}

static int
bus_class(dev)
	struct device *dev;
{
	char *name;
	int i, class;

	class = BUSCLASS_NONE;
	if (dev == NULL)
		return (class);

	name = dev->dv_cfdata->cf_driver->cd_name;
	for (i = sizeof(bus_class_tab)/sizeof(bus_class_tab[0]); i-- > 0;) {
		if (strcmp(name, bus_class_tab[i].name) == 0) {
			class = bus_class_tab[i].class;
			break;
		}
	}

	return (class);
}

int
instance_match(dev, aux, bp)
	struct device *dev;
	void *aux;
	struct bootpath *bp;
{
	struct mainbus_attach_args *ma;
	struct sbus_attach_args *sa;
	struct pci_attach_args *pa;

	/*
	 * Several devices are represented on bootpaths in one of
	 * two formats, e.g.:
	 *	(1) ../sbus@@.../esp@@<offset>,<slot>/sd@@..  (PROM v3 style)
	 *	(2) /sbus0/esp0/sd@@..                      (PROM v2 style)
	 *
	 * hence we fall back on a `unit number' check if the bus-specific
	 * instance parameter check does not produce a match.
	 *
	 * For PCI devices, we get:
	 *	../pci@@../xxx@@<dev>,<fn>/...
	 */

	/*
	 * Rank parent bus so we know which locators to check.
	 */
	switch (bus_class(dev->dv_parent)) {
	case BUSCLASS_MAINBUS:
		ma = aux;
		DPRINTF(ACDB_BOOTDEV,
		    ("instance_match: mainbus device, want %#x have %#x\n",
		    ma->ma_upaid, bp->val[0]));
		if (bp->val[0] == ma->ma_upaid)
			return (1);
		break;
	case BUSCLASS_SBUS:
		sa = aux;
		DPRINTF(ACDB_BOOTDEV, ("instance_match: sbus device, "
		    "want slot %#x offset %#x have slot %#x offset %#x\n",
		     bp->val[0], bp->val[1], sa->sa_slot, sa->sa_offset));
		if (bp->val[0] == sa->sa_slot && bp->val[1] == sa->sa_offset)
			return (1);
		break;
	case BUSCLASS_PCI:
		pa = aux;
		DPRINTF(ACDB_BOOTDEV, ("instance_match: pci device, "
		    "want dev %#x fn %#x have dev %#x fn %#x\n",
		     bp->val[0], bp->val[1], pa->pa_device, pa->pa_function));
		if (bp->val[0] == pa->pa_device &&
		    bp->val[1] == pa->pa_function)
			return (1);
		break;
	default:
		break;
	}

	if (bp->val[0] == -1 && bp->val[1] == dev->dv_unit)
		return (1);

	return (0);
}
#endif

struct device *booted_device;

#if XXX
void
nail_bootdev(dev, bp)
	struct device *dev;
	struct bootpath *bp;
{

	if (bp->dev != NULL)
		panic("device_register: already got a boot device: %s",
			bp->dev->dv_xname);

	/*
	 * Mark this bootpath component by linking it to the matched
	 * device. We pick up the device pointer in cpu_rootconf().
	 */
	booted_device = bp->dev = dev;

	/*
	 * Then clear the current bootpath component, so we don't spuriously
	 * match similar instances on other busses, e.g. a disk on
	 * another SCSI bus with the same target.
	 */
	bootpath_store(1, NULL);
}

void
device_register(dev, aux)
	struct device *dev;
	void *aux;
{
	struct bootpath *bp = bootpath_store(0, NULL);
	char *dvname, *bpname;

	/*
	 * If device name does not match current bootpath component
	 * then there's nothing interesting to consider.
	 */
	if (bp == NULL)
		return;

	/*
	 * Translate PROM name in case our drivers are named differently
	 */
	bpname = bus_compatible(bp->name, dev);
	dvname = dev->dv_cfdata->cf_driver->cd_name;

	DPRINTF(ACDB_BOOTDEV,
	    ("\n%s: device_register: dvname %s(%s) bpname %s(%s)\n",
	    dev->dv_xname, dvname, dev->dv_xname, bpname, bp->name));

	/* First, match by name */
	if (strcmp(dvname, bpname) != 0)
		return;

	if (bus_class(dev) != BUSCLASS_NONE) {
		/*
		 * A bus or controller device of sorts. Check instance
		 * parameters and advance boot path on match.
		 */
		if (instance_match(dev, aux, bp) != 0) {
			bp->dev = dev;
			bootpath_store(1, bp + 1);
			DPRINTF(ACDB_BOOTDEV, ("\t-- found bus controller %s\n",
			    dev->dv_xname));
			return;
		}
	} else if (strcmp(dvname, "le") == 0 ||
		   strcmp(dvname, "hme") == 0) {
		/*
		 * ethernet devices.
		 */
		if (instance_match(dev, aux, bp) != 0) {
			nail_bootdev(dev, bp);
			DPRINTF(ACDB_BOOTDEV, ("\t-- found ethernet controller %s\n",
			    dev->dv_xname));
			return;
		}
	} else if (strcmp(dvname, "sd") == 0 || strcmp(dvname, "cd") == 0) {
		/*
		 * A SCSI disk or cd; retrieve target/lun information
		 * from parent and match with current bootpath component.
		 * Note that we also have look back past the `scsibus'
		 * device to determine whether this target is on the
		 * correct controller in our boot path.
		 */
		struct scsipibus_attach_args *sa = aux;
		struct scsipi_periph *periph = sa->sa_periph;
		struct scsibus_softc *sbsc =
			(struct scsibus_softc *)dev->dv_parent;
		u_int target = bp->val[0];
		u_int lun = bp->val[1];

		/* Check the controller that this scsibus is on */
		if ((bp-1)->dev != sbsc->sc_dev.dv_parent)
			return;

		/*
		 * Bounds check: we know the target and lun widths.
		 */
		if (target >= periph->periph_channel->chan_ntargets ||
		    lun >= periph->periph_channel->chan_nluns) {
			printf("SCSI disk bootpath component not accepted: "
			       "target %u; lun %u\n", target, lun);
			return;
		}

		if (periph->periph_target == target &&
		    periph->periph_lun == lun) {
			nail_bootdev(dev, bp);
			DPRINTF(ACDB_BOOTDEV, ("\t-- found [cs]d disk %s\n",
			    dev->dv_xname));
			return;
		}
	} else if (strcmp("wd", dvname) == 0) {
		/* IDE disks. */
		struct ata_atapi_attach *aa = aux;

		if (aa->aa_channel == bp->val[0]) {
			nail_bootdev(dev, bp);
			DPRINTF(ACDB_BOOTDEV, ("\t-- found wd disk %s\n",
			    dev->dv_xname));
			return;
		}
	} else {
		/*
		 * Generic match procedure.
		 */
		if (instance_match(dev, aux, bp) != 0) {
			nail_bootdev(dev, bp);
			DPRINTF(ACDB_BOOTDEV, ("\t-- found generic device %s\n",
			    dev->dv_xname));
			return;
		}
	}
}
#endif
@


1.1
log
@Lot of stuff... Some from NetBSD, some from OpenBSD, minor modifications
@
text
@a209 3
#if defined(DDB) && defined(DB_ELF_SYMBOLS)
	extern void *ssym, *esym;
#endif
a231 3
#ifdef DB_ELF_SYMBOLS
	ddb_init((int)((caddr_t)esym - (caddr_t)ssym), ssym, esym); 
#else
a232 1
#endif
@

