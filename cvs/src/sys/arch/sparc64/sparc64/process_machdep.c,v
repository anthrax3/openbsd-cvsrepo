head	1.12;
access;
symbols
	OPENBSD_6_1:1.12.0.32
	OPENBSD_6_1_BASE:1.12
	OPENBSD_6_0:1.12.0.30
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.12.0.26
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.12.0.28
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.20
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.12.0.24
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.12.0.22
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.12.0.18
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.12.0.16
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.14
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.12
	OPENBSD_5_0:1.12.0.10
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.8
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.12.0.6
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.2
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.12.0.4
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.11.0.6
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.4
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.2
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.10.0.8
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.6
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.4
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.10.0.2
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.7.0.2
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.6.0.8
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.6.0.6
	OPENBSD_3_6_BASE:1.6
	SMP_SYNC_A:1.6
	SMP_SYNC_B:1.6
	OPENBSD_3_5:1.6.0.4
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.2
	OPENBSD_3_4_BASE:1.6
	UBC_SYNC_A:1.5
	OPENBSD_3_3:1.5.0.4
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4
	UBC_SYNC_B:1.5
	UBC:1.2.0.6
	UBC_BASE:1.2
	SMP:1.2.0.4
	OPENBSD_3_0:1.2.0.2
	OPENBSD_3_0_BASE:1.2;
locks; strict;
comment	@ * @;


1.12
date	2009.03.05.19.52.23;	author kettenis;	state Exp;
branches;
next	1.11;

1.11
date	2007.10.31.22.46.52;	author kettenis;	state Exp;
branches;
next	1.10;

1.10
date	2005.12.31.23.50.39;	author kettenis;	state Exp;
branches;
next	1.9;

1.9
date	2005.12.17.16.08.35;	author kettenis;	state Exp;
branches;
next	1.8;

1.8
date	2005.12.16.21.37.05;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2005.03.29.19.34.07;	author kettenis;	state Exp;
branches;
next	1.6;

1.6
date	2003.06.02.23.27.56;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.06.15.17.23.31;	author art;	state Exp;
branches;
next	1.4;

1.4
date	2002.03.17.18.38.43;	author art;	state Exp;
branches;
next	1.3;

1.3
date	2002.03.14.00.42.24;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2001.08.20.20.23.53;	author jason;	state Exp;
branches
	1.2.4.1
	1.2.6.1;
next	1.1;

1.1
date	2001.08.19.05.21.38;	author jason;	state Exp;
branches;
next	;

1.2.4.1
date	2001.10.31.03.07.59;	author nate;	state Exp;
branches;
next	1.2.4.2;

1.2.4.2
date	2002.03.28.11.23.52;	author niklas;	state Exp;
branches;
next	1.2.4.3;

1.2.4.3
date	2003.03.27.23.42.37;	author niklas;	state Exp;
branches;
next	1.2.4.4;

1.2.4.4
date	2003.06.07.11.14.46;	author ho;	state Exp;
branches;
next	;

1.2.6.1
date	2002.06.11.03.38.44;	author art;	state Exp;
branches;
next	1.2.6.2;

1.2.6.2
date	2002.10.29.00.28.12;	author art;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Make ELF platforms generate ELF core dumps.  Somewhat based on code from
NetBSD.

ok kurt@@, drahn@@, miod@@
@
text
@/*	$OpenBSD: process_machdep.c,v 1.11 2007/10/31 22:46:52 kettenis Exp $	*/
/*	$NetBSD: process_machdep.c,v 1.10 2000/09/26 22:05:50 eeh Exp $ */

/*
 * Copyright (c) 1993 The Regents of the University of California.
 * Copyright (c) 1993 Jan-Simon Pendry
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Jan-Simon Pendry.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * from: Id: procfs_i386.c,v 4.1 1993/12/17 10:47:45 jsp Rel
 */

/*
 * This file may seem a bit stylized, but that so that it's easier to port.
 * Functions to be implemented here are:
 *
 * process_read_regs(proc, regs)
 *	Get the current user-visible register set from the process
 *	and copy it into the regs structure (<machine/reg.h>).
 *	The process is stopped at the time read_regs is called.
 *
 * process_write_regs(proc, regs)
 *	Update the current register set from the passed in regs
 *	structure.  Take care to avoid clobbering special CPU
 *	registers or privileged bits in the PSL.
 *	The process is stopped at the time write_regs is called.
 *
 * process_sstep(proc)
 *	Arrange for the process to trap after executing a single instruction.
 *
 * process_set_pc(proc)
 *	Set the process's program counter.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/time.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/proc.h>
#include <sys/user.h>
#include <sys/vnode.h>
#include <machine/psl.h>
#include <machine/reg.h>
#include <machine/frame.h>
#include <sys/ptrace.h>

#ifndef P_32
#define P_32 0
#endif
/* Unfortunately we need to convert v9 trapframe to v8 regs */
int
process_read_regs(p, regs)
	struct proc *p;
	struct reg *regs;
{
	struct trapframe64* tf = p->p_md.md_tf;
	struct reg32* regp = (struct reg32*)regs;
	int i;

	if (!(curproc->p_flag & P_32)) {
		/* 64-bit mode -- copy out regs */
		regs->r_tstate = tf->tf_tstate;
		regs->r_pc = tf->tf_pc;
		regs->r_npc = tf->tf_npc;
		regs->r_y = tf->tf_y;
		for (i = 0; i < 8; i++) {
			regs->r_global[i] = tf->tf_global[i];
			regs->r_out[i] = tf->tf_out[i];
			regs->r_local[i] = tf->tf_local[i];
			regs->r_in[i] = tf->tf_in[i];
		}
		return (0);
	}

	/* 32-bit mode -- copy out & convert 32-bit regs */
	regp->r_psr = TSTATECCR_TO_PSR(tf->tf_tstate);
	regp->r_pc = tf->tf_pc;
	regp->r_npc = tf->tf_npc;
	regp->r_y = tf->tf_y;
	for (i = 0; i < 8; i++) {
		regp->r_global[i] = tf->tf_global[i];
		regp->r_out[i] = tf->tf_out[i];
	}
	/* We should also write out the ins and locals.  See signal stuff */
	return (0);
}

int
process_read_fpregs(p, regs)
	struct proc	*p;
	struct fpreg	*regs;
{
	extern struct fpstate64	initfpstate;
	struct fpstate64 *statep = &initfpstate;
	struct fpreg32 *regp = (struct fpreg32 *)regs;
	int i;

	/* NOTE: struct fpreg == struct fpstate */
	if (p->p_md.md_fpstate) {
		fpusave_proc(p, 1);
		statep = p->p_md.md_fpstate;
	}

	if (!(curproc->p_flag & P_32)) {
		/* 64-bit mode -- copy in fregs */
		bcopy(statep, regs, sizeof(struct fpreg64));
		return 0;
	}
	/* 32-bit mode -- copy out & convert 32-bit fregs */
	for (i = 0; i < 32; i++)
		regp->fr_regs[i] = statep->fs_regs[i];

	return 0;
}

#ifdef PTRACE

int
process_write_regs(p, regs)
	struct proc *p;
	struct reg *regs;
{
	struct trapframe64* tf = p->p_md.md_tf;
	struct reg32* regp = (struct reg32*)regs;
	int i;

	if (!(curproc->p_flag & P_32)) {
		/* 64-bit mode -- copy in regs */
		tf->tf_pc = regs->r_pc;
		tf->tf_npc = regs->r_npc;
		tf->tf_y = regs->r_y;
		for (i = 0; i < 8; i++) {
			tf->tf_global[i] = regs->r_global[i];
			tf->tf_out[i] = regs->r_out[i];
		}
		/* We should also read in the ins and locals.  See signal stuff */
		tf->tf_tstate = (tf->tf_tstate & ~TSTATE_CCR) | 
			(regs->r_tstate & TSTATE_CCR);
		return (0);
	}

	/* 32-bit mode -- copy in & convert 32-bit regs */
	tf->tf_pc = regp->r_pc;
	tf->tf_npc = regp->r_npc;
	tf->tf_y = regp->r_y;
	for (i = 0; i < 8; i++) {
		tf->tf_global[i] = regp->r_global[i];
		tf->tf_out[i] = regp->r_out[i];
	}
	/* We should also read in the ins and locals.  See signal stuff */
	tf->tf_tstate = (int64_t)(tf->tf_tstate & ~TSTATE_CCR) | 
		PSRCC_TO_TSTATE(regp->r_psr);
	return (0);
}

#ifdef PT_STEP
int
process_sstep(p, sstep)
	struct proc *p;
	int sstep;
{
	if (sstep)
		return EINVAL;
	return (0);
}
#endif

int
process_set_pc(p, addr)
	struct proc *p;
	caddr_t addr;
{
	p->p_md.md_tf->tf_pc = (vaddr_t)addr;
	p->p_md.md_tf->tf_npc = (vaddr_t)addr + 4;
	return (0);
}

int
process_write_fpregs(p, regs)
	struct proc	*p;
	struct fpreg	*regs;
{
	struct fpreg32 *regp = (struct fpreg32 *)regs;
	int i;

	if (p->p_md.md_fpstate == NULL) {
		p->p_md.md_fpstate = malloc(sizeof(struct fpstate64),
		    M_SUBPROC, M_WAITOK);
	} else
		fpusave_proc(p, 1);

	if (!(curproc->p_flag & P_32)) {
		/* 64-bit mode -- copy in fregs */
		bcopy(regs, p->p_md.md_fpstate, sizeof(struct fpreg64));
		p->p_md.md_fpstate->fs_qsize = 0;
		return 0;
	}
	/* 32-bit mode -- copy in & convert 32-bit fregs */
	for (i = 0; i < 32; i++)
		p->p_md.md_fpstate->fs_regs[i] = regp->fr_regs[i];
	p->p_md.md_fpstate->fs_fsr = regp->fr_fsr;
	p->p_md.md_fpstate->fs_qsize = 0;

	return 0;
}

#endif	/* PTRACE */

register_t
process_get_wcookie(struct proc *p)
{
	return p->p_addr->u_pcb.pcb_wcookie;
}
@


1.11
log
@Overhaul fpu context save/restore code, making it more similar to what we do
on i386 and amd64.  Don't let IPIs in when saving fpu context by disabling
interrupts.
@
text
@d1 1
a1 1
/*	$OpenBSD: process_machdep.c,v 1.10 2005/12/31 23:50:39 kettenis Exp $	*/
d234 2
a240 2

#endif	/* PTRACE */
@


1.10
log
@Make PT_SETFPREGS work even if the process didn't use the fpu yet.
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: process_machdep.c,v 1.9 2005/12/17 16:08:35 kettenis Exp $	*/
d127 1
a127 2
		if (p == fpproc)
			savefpstate(p->p_md.md_fpstate);
d216 2
a217 7
	}

	if (p == fpproc) {
		/* Release the fpu. */
		savefpstate(p->p_md.md_fpstate);
		fpproc = NULL;
	}
@


1.9
log
@Fix PT_{GET|SET}FPREGS.  Make sure we flush the fpu before reading/modifying
the state in the pcb.  Make sure we don't thrash the initial fpu state for
(currently unsupported) 32-bit processes.
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: process_machdep.c,v 1.8 2005/12/16 21:37:05 miod Exp $	*/
d65 1
a210 1
	struct fpstate64 *statep;
d214 4
a217 4
	if (p->p_md.md_fpstate == NULL)
		return EINVAL;
	else
		statep = p->p_md.md_fpstate;
d227 2
a228 2
		bcopy(regs, statep, sizeof(struct fpreg64));
		statep->fs_qsize = 0;
d233 3
a235 3
		statep->fs_regs[i] = regp->fr_regs[i];
	statep->fs_fsr = regp->fr_fsr;
	statep->fs_qsize = 0;
@


1.8
log
@Compile out process_sstep() as we don't define PT_STEP, thus nothing uses
these functions. ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: process_machdep.c,v 1.7 2005/03/29 19:34:07 kettenis Exp $	*/
d120 2
a121 2
	struct fpstate64	*statep = &initfpstate;
	struct fpreg32		*regp = (struct fpreg32 *)regs;
d124 7
a132 3
		/* NOTE: struct fpreg == struct fpstate */
		if (p->p_md.md_fpstate)
			statep = p->p_md.md_fpstate;
d137 1
a137 3
	if (p->p_md.md_fpstate)
		statep = p->p_md.md_fpstate;
	for (i=0; i<32; i++)
d210 8
d219 5
a223 4
	extern struct fpstate64	initfpstate;
	struct fpstate64	*statep = &initfpstate;
	struct fpreg32		*regp = (struct fpreg32 *)regs;
	int i;
d227 1
a227 6
		if (p->p_md.md_fpstate == NULL)
			return EINVAL;

		/* NOTE: struct fpreg == struct fpstate */
		bcopy(regs, p->p_md.md_fpstate, sizeof(struct fpreg64));
		statep = p->p_md.md_fpstate;
d232 1
a232 3
	if (p->p_md.md_fpstate)
		statep = p->p_md.md_fpstate;
	for (i=0; i<32; i++)
@


1.7
log
@sparc64 StackGhost.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: process_machdep.c,v 1.6 2003/06/02 23:27:56 millert Exp $	*/
d181 1
d191 1
@


1.6
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: process_machdep.c,v 1.5 2002/06/15 17:23:31 art Exp $	*/
d232 6
@


1.5
log
@Decruftification.

We will never have a.out kernels.
We will never have 32-bit kernels.
We will never have sun4c, sun4 and sun4m support in the sparc64 kernels.
We don't need support old netbsd libc.
The cpu will never be identified as some of the sun4c and sun4m types.
We don't need the gazillion of fields in cpuinfo that the sparc port uses.
Just generally remove dead code.

This is just a first step in making this meess readable.
@
text
@d1 1
a1 1
/*	$OpenBSD: process_machdep.c,v 1.4 2002/03/17 18:38:43 art Exp $	*/
d20 1
a20 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.4
log
@In PT_{GET,SET}REGS there is no reason to not get/set %l* and %i*.
This change will break debuggers, so if you have any, rebuild.
@
text
@d1 1
a1 1
/*	$OpenBSD: process_machdep.c,v 1.3 2002/03/14 00:42:24 miod Exp $	*/
a89 1
#ifdef __arch64__
d104 1
a104 1
#endif
a155 1
#ifdef __arch64__
d170 1
a170 1
#endif
@


1.3
log
@Turn the ptrace(2) syscall into a kernel compile option, option PTRACE in
your kernel configuration file.
By default, GENERIC will enable this.

When PTRACE is not enabled, several ptrace-like features of the procfs
filesystem will be disabled as well (namely, the ability to read and write
any process' registers, as well as attching, single stepping and detaching
to/from processes).

This should help paranoid people build better sandboxens, and us to build
smaller ramdisks.
@
text
@d1 1
a1 1
/*	$OpenBSD: process_machdep.c,v 1.2 2001/08/20 20:23:53 jason Exp $	*/
d100 2
@


1.2
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d118 29
a205 27
process_read_fpregs(p, regs)
struct proc	*p;
struct fpreg	*regs;
{
	extern struct fpstate64	initfpstate;
	struct fpstate64	*statep = &initfpstate;
	struct fpreg32		*regp = (struct fpreg32 *)regs;
	int i;

	if (!(curproc->p_flag & P_32)) {
		/* 64-bit mode -- copy in fregs */
		/* NOTE: struct fpreg == struct fpstate */
		if (p->p_md.md_fpstate)
			statep = p->p_md.md_fpstate;
		bcopy(statep, regs, sizeof(struct fpreg64));
		return 0;
	}
	/* 32-bit mode -- copy out & convert 32-bit fregs */
	if (p->p_md.md_fpstate)
		statep = p->p_md.md_fpstate;
	for (i=0; i<32; i++)
		regp->fr_regs[i] = statep->fs_regs[i];

	return 0;
}

int
d207 2
a208 2
struct proc	*p;
struct fpreg	*regs;
d237 2
@


1.2.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: process_machdep.c,v 1.2 2001/08/20 20:23:53 jason Exp $	*/
a99 2
			regs->r_local[i] = tf->tf_local[i];
			regs->r_in[i] = tf->tf_in[i];
a117 29
process_read_fpregs(p, regs)
	struct proc	*p;
	struct fpreg	*regs;
{
	extern struct fpstate64	initfpstate;
	struct fpstate64	*statep = &initfpstate;
	struct fpreg32		*regp = (struct fpreg32 *)regs;
	int i;

	if (!(curproc->p_flag & P_32)) {
		/* 64-bit mode -- copy in fregs */
		/* NOTE: struct fpreg == struct fpstate */
		if (p->p_md.md_fpstate)
			statep = p->p_md.md_fpstate;
		bcopy(statep, regs, sizeof(struct fpreg64));
		return 0;
	}
	/* 32-bit mode -- copy out & convert 32-bit fregs */
	if (p->p_md.md_fpstate)
		statep = p->p_md.md_fpstate;
	for (i=0; i<32; i++)
		regp->fr_regs[i] = statep->fs_regs[i];

	return 0;
}

#ifdef PTRACE

int
d177 27
d205 2
a206 2
	struct proc	*p;
	struct fpreg	*regs;
a234 2

#endif	/* PTRACE */
@


1.2.6.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: process_machdep.c,v 1.2.6.1 2002/06/11 03:38:44 art Exp $	*/
d90 1
d105 1
a105 1

d157 1
d172 1
a172 1

@


1.2.4.1
log
@Sync the SMP branch to something just after 3.0
@
text
@@


1.2.4.2
log
@Merge in -current from about a week ago
@
text
@a99 2
			regs->r_local[i] = tf->tf_local[i];
			regs->r_in[i] = tf->tf_in[i];
a117 29
process_read_fpregs(p, regs)
	struct proc	*p;
	struct fpreg	*regs;
{
	extern struct fpstate64	initfpstate;
	struct fpstate64	*statep = &initfpstate;
	struct fpreg32		*regp = (struct fpreg32 *)regs;
	int i;

	if (!(curproc->p_flag & P_32)) {
		/* 64-bit mode -- copy in fregs */
		/* NOTE: struct fpreg == struct fpstate */
		if (p->p_md.md_fpstate)
			statep = p->p_md.md_fpstate;
		bcopy(statep, regs, sizeof(struct fpreg64));
		return 0;
	}
	/* 32-bit mode -- copy out & convert 32-bit fregs */
	if (p->p_md.md_fpstate)
		statep = p->p_md.md_fpstate;
	for (i=0; i<32; i++)
		regp->fr_regs[i] = statep->fs_regs[i];

	return 0;
}

#ifdef PTRACE

int
d177 27
d205 2
a206 2
	struct proc	*p;
	struct fpreg	*regs;
a234 2

#endif	/* PTRACE */
@


1.2.4.3
log
@Sync the SMP branch with 3.3
@
text
@d90 1
d105 1
a105 1

d157 1
d172 1
a172 1

@


1.2.4.4
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: process_machdep.c,v 1.2.4.3 2003/03/27 23:42:37 niklas Exp $	*/
d20 5
a24 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.1
log
@Lot of stuff... Some from NetBSD, some from OpenBSD, minor modifications
@
text
@d1 1
@

