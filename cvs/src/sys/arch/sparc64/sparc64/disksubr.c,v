head	1.72;
access;
symbols
	OPENBSD_6_2_BASE:1.72
	OPENBSD_6_1:1.72.0.4
	OPENBSD_6_1_BASE:1.72
	OPENBSD_6_0:1.71.0.4
	OPENBSD_6_0_BASE:1.71
	OPENBSD_5_9:1.71.0.2
	OPENBSD_5_9_BASE:1.71
	OPENBSD_5_8:1.69.0.6
	OPENBSD_5_8_BASE:1.69
	OPENBSD_5_7:1.69.0.2
	OPENBSD_5_7_BASE:1.69
	OPENBSD_5_6:1.68.0.6
	OPENBSD_5_6_BASE:1.68
	OPENBSD_5_5:1.68.0.4
	OPENBSD_5_5_BASE:1.68
	OPENBSD_5_4:1.67.0.2
	OPENBSD_5_4_BASE:1.67
	OPENBSD_5_3:1.66.0.8
	OPENBSD_5_3_BASE:1.66
	OPENBSD_5_2:1.66.0.6
	OPENBSD_5_2_BASE:1.66
	OPENBSD_5_1_BASE:1.66
	OPENBSD_5_1:1.66.0.4
	OPENBSD_5_0:1.66.0.2
	OPENBSD_5_0_BASE:1.66
	OPENBSD_4_9:1.63.0.2
	OPENBSD_4_9_BASE:1.63
	OPENBSD_4_8:1.62.0.2
	OPENBSD_4_8_BASE:1.62
	OPENBSD_4_7:1.58.0.2
	OPENBSD_4_7_BASE:1.58
	OPENBSD_4_6:1.56.0.4
	OPENBSD_4_6_BASE:1.56
	OPENBSD_4_5:1.53.0.2
	OPENBSD_4_5_BASE:1.53
	OPENBSD_4_4:1.52.0.2
	OPENBSD_4_4_BASE:1.52
	OPENBSD_4_3:1.48.0.2
	OPENBSD_4_3_BASE:1.48
	OPENBSD_4_2:1.46.0.2
	OPENBSD_4_2_BASE:1.46
	OPENBSD_4_1:1.20.0.2
	OPENBSD_4_1_BASE:1.20
	OPENBSD_4_0:1.19.0.2
	OPENBSD_4_0_BASE:1.19
	OPENBSD_3_9:1.15.0.2
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.13.0.2
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.12.0.6
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.12.0.4
	OPENBSD_3_6_BASE:1.12
	SMP_SYNC_A:1.12
	SMP_SYNC_B:1.12
	OPENBSD_3_5:1.12.0.2
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	UBC_SYNC_A:1.9
	OPENBSD_3_3:1.9.0.4
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.2
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	UBC_SYNC_B:1.9
	UBC:1.6.0.6
	UBC_BASE:1.6
	SMP:1.6.0.4
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6;
locks; strict;
comment	@ * @;


1.72
date	2017.02.28.10.49.37;	author natano;	state Exp;
branches;
next	1.71;
commitid	9645cvu5lMcc7gZM;

1.71
date	2015.09.28.15.30.33;	author krw;	state Exp;
branches;
next	1.70;
commitid	4HAoihbq9J4IUXef;

1.70
date	2015.09.27.22.34.27;	author krw;	state Exp;
branches;
next	1.69;
commitid	6I9GceOSjHo9mTgF;

1.69
date	2015.01.16.20.17.06;	author miod;	state Exp;
branches;
next	1.68;
commitid	qvf9KkZ1B5C1I4hl;

1.68
date	2013.10.20.10.11.17;	author krw;	state Exp;
branches;
next	1.67;

1.67
date	2013.06.11.16.42.12;	author deraadt;	state Exp;
branches;
next	1.66;

1.66
date	2011.04.16.03.21.15;	author krw;	state Exp;
branches;
next	1.65;

1.65
date	2011.04.15.14.57.29;	author krw;	state Exp;
branches;
next	1.64;

1.64
date	2011.04.06.13.46.51;	author miod;	state Exp;
branches;
next	1.63;

1.63
date	2010.09.08.14.37.32;	author jsing;	state Exp;
branches;
next	1.62;

1.62
date	2010.05.24.16.41.32;	author jsing;	state Exp;
branches;
next	1.61;

1.61
date	2010.04.25.06.15.17;	author deraadt;	state Exp;
branches;
next	1.60;

1.60
date	2010.04.24.20.12.23;	author miod;	state Exp;
branches;
next	1.59;

1.59
date	2010.04.23.15.25.21;	author jsing;	state Exp;
branches;
next	1.58;

1.58
date	2010.02.26.23.11.57;	author deraadt;	state Exp;
branches;
next	1.57;

1.57
date	2009.08.13.15.23.11;	author deraadt;	state Exp;
branches;
next	1.56;

1.56
date	2009.06.04.21.13.02;	author deraadt;	state Exp;
branches;
next	1.55;

1.55
date	2009.05.13.01.31.58;	author krw;	state Exp;
branches;
next	1.54;

1.54
date	2009.04.07.03.11.59;	author krw;	state Exp;
branches;
next	1.53;

1.53
date	2009.01.22.01.06.28;	author krw;	state Exp;
branches;
next	1.52;

1.52
date	2008.06.29.20.05.22;	author krw;	state Exp;
branches;
next	1.51;

1.51
date	2008.06.12.06.58.37;	author deraadt;	state Exp;
branches;
next	1.50;

1.50
date	2008.06.11.12.35.44;	author deraadt;	state Exp;
branches;
next	1.49;

1.49
date	2008.06.10.20.50.23;	author beck;	state Exp;
branches;
next	1.48;

1.48
date	2007.10.02.03.26.59;	author krw;	state Exp;
branches;
next	1.47;

1.47
date	2007.09.19.23.47.50;	author tsi;	state Exp;
branches;
next	1.46;

1.46
date	2007.06.20.18.15.46;	author deraadt;	state Exp;
branches;
next	1.45;

1.45
date	2007.06.18.05.28.54;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2007.06.18.02.14.17;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2007.06.17.00.27.29;	author deraadt;	state Exp;
branches;
next	1.42;

1.42
date	2007.06.14.03.41.22;	author deraadt;	state Exp;
branches;
next	1.41;

1.41
date	2007.06.14.03.37.23;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2007.06.14.03.35.30;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2007.06.14.03.29.34;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2007.06.12.20.57.43;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2007.06.09.23.06.46;	author krw;	state Exp;
branches;
next	1.36;

1.36
date	2007.06.09.04.08.39;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2007.06.09.02.03.47;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2007.06.08.04.59.07;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2007.06.07.03.41.52;	author krw;	state Exp;
branches;
next	1.32;

1.32
date	2007.06.07.00.28.17;	author krw;	state Exp;
branches;
next	1.31;

1.31
date	2007.06.06.22.14.32;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2007.06.06.16.42.06;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2007.06.05.02.38.37;	author krw;	state Exp;
branches;
next	1.28;

1.28
date	2007.06.05.00.38.19;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2007.06.02.02.35.27;	author krw;	state Exp;
branches;
next	1.26;

1.26
date	2007.05.31.19.57.44;	author krw;	state Exp;
branches;
next	1.25;

1.25
date	2007.05.31.02.57.53;	author krw;	state Exp;
branches;
next	1.24;

1.24
date	2007.05.31.00.30.10;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2007.05.29.06.56.30;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2007.05.29.06.28.15;	author otto;	state Exp;
branches;
next	1.21;

1.21
date	2007.05.29.05.08.20;	author krw;	state Exp;
branches;
next	1.20;

1.20
date	2006.10.04.03.23.01;	author krw;	state Exp;
branches;
next	1.19;

1.19
date	2006.08.17.10.34.14;	author krw;	state Exp;
branches;
next	1.18;

1.18
date	2006.08.11.21.32.40;	author krw;	state Exp;
branches;
next	1.17;

1.17
date	2006.03.15.20.20.41;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2006.03.04.19.33.21;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2005.12.22.02.51.25;	author krw;	state Exp;
branches;
next	1.14;

1.14
date	2005.09.21.21.08.35;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2005.03.30.07.52.32;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2004.03.17.14.16.04;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2003.07.16.18.06.35;	author tedu;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.04.21.47.59;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2002.06.15.17.23.31;	author art;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.14.01.26.45;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.19.02.50.59;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2001.10.15.04.03.45;	author jason;	state Exp;
branches
	1.6.4.1
	1.6.6.1;
next	1.5;

1.5
date	2001.10.12.20.32.11;	author jason;	state Exp;
branches;
next	1.4;

1.4
date	2001.09.18.21.04.33;	author jason;	state Exp;
branches;
next	1.3;

1.3
date	2001.08.20.20.23.53;	author jason;	state Exp;
branches;
next	1.2;

1.2
date	2001.08.19.18.41.34;	author art;	state Exp;
branches;
next	1.1;

1.1
date	2001.08.18.22.54.47;	author jason;	state Exp;
branches;
next	;

1.6.4.1
date	2001.10.31.03.07.58;	author nate;	state Exp;
branches;
next	1.6.4.2;

1.6.4.2
date	2002.03.06.02.04.47;	author niklas;	state Exp;
branches;
next	1.6.4.3;

1.6.4.3
date	2002.03.28.11.23.52;	author niklas;	state Exp;
branches;
next	1.6.4.4;

1.6.4.4
date	2003.03.27.23.42.37;	author niklas;	state Exp;
branches;
next	1.6.4.5;

1.6.4.5
date	2003.06.07.11.14.45;	author ho;	state Exp;
branches;
next	1.6.4.6;

1.6.4.6
date	2004.02.19.10.50.00;	author niklas;	state Exp;
branches;
next	1.6.4.7;

1.6.4.7
date	2004.06.05.23.11.00;	author niklas;	state Exp;
branches;
next	;

1.6.6.1
date	2002.06.11.03.38.43;	author art;	state Exp;
branches;
next	1.6.6.2;

1.6.6.2
date	2002.10.29.00.28.12;	author art;	state Exp;
branches;
next	;


desc
@@


1.72
log
@Switch geteblks()'s size argument from int to size_t. It's called with
unsigned variables as argument in most places anyway. Decrease the
chance of signedness/range mismatch issues.

ok stefan
@
text
@/*	$OpenBSD: disksubr.c,v 1.71 2015/09/28 15:30:33 krw Exp $	*/
/*	$NetBSD: disksubr.c,v 1.13 2000/12/17 22:39:18 pk Exp $ */

/*
 * Copyright (c) 1994, 1995 Gordon W. Ross
 * Copyright (c) 1994 Theo de Raadt
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/disklabel.h>
#include <sys/disk.h>

#include <dev/sun/disklabel.h>

#include "cd.h"

static	int disklabel_sun_to_bsd(struct sun_disklabel *, struct disklabel *);
static	int disklabel_bsd_to_sun(struct disklabel *, struct sun_disklabel *);
static __inline u_int sun_extended_sum(struct sun_disklabel *, void *);

#if NCD > 0
extern void cdstrategy(struct buf *);
#endif

/*
 * Attempt to read a disk label from a device
 * using the indicated strategy routine.
 * The label must be partly set up before this:
 * secpercyl, secsize and anything required for a block i/o read
 * operation in the driver's strategy/start routines
 * must be filled in before calling us.
 */
int
readdisklabel(dev_t dev, void (*strat)(struct buf *),
    struct disklabel *lp, int spoofonly)
{
	struct sun_disklabel *slp;
	struct buf *bp = NULL;
	int error;

	if ((error = initdisklabel(lp)))
		goto done;
	lp->d_flags |= D_VENDOR;

	/*
	 * On sparc64 we check for a CD label first, because our
	 * CD install media contains both sparc & sparc64 labels.
	 * We want the sparc64 machine to find the "CD label", not
	 * the SunOS label, for loading its kernel.
	 */
#if NCD > 0
	if (strat == cdstrategy) {
#if defined(CD9660)
		if (iso_disklabelspoof(dev, strat, lp) == 0)
			goto done;
#endif
#if defined(UDF)
		if (udf_disklabelspoof(dev, strat, lp) == 0)
			goto done;
#endif
	}
#endif /* NCD > 0 */

	/* get buffer and initialize it */
	bp = geteblk(lp->d_secsize);
	bp->b_dev = dev;

	if (spoofonly)
		goto doslabel;

	error = readdisksector(bp, strat, lp, DL_BLKTOSEC(lp, LABELSECTOR));
	if (error)
		goto done;

	slp = (struct sun_disklabel *)bp->b_data;
	if (slp->sl_magic == SUN_DKMAGIC) {
		error = disklabel_sun_to_bsd(slp, lp);
		goto done;
	}

	error = checkdisklabel(bp->b_data + LABELOFFSET, lp, 0, DL_GETDSIZE(lp));
	if (error == 0)
		goto done;

doslabel:
	error = readdoslabel(bp, strat, lp, NULL, spoofonly);
	if (error == 0)
		goto done;

	/* A CD9660/UDF label may be on a non-CD drive, so recheck */
#if defined(CD9660)
	error = iso_disklabelspoof(dev, strat, lp);
	if (error == 0)
		goto done;
#endif
#if defined(UDF)
	error = udf_disklabelspoof(dev, strat, lp);
	if (error == 0)
		goto done;
#endif

done:
	if (bp) {
		bp->b_flags |= B_INVAL;
		brelse(bp);
	}
	disk_change = 1;
	return (error);
}

/*
 * Write disk label back to device after modification.
 */
int
writedisklabel(dev_t dev, void (*strat)(struct buf *), struct disklabel *lp)
{
	struct buf *bp = NULL;
	int error;

	/* get buffer and initialize it */
	bp = geteblk(lp->d_secsize);
	bp->b_dev = dev;

	error = disklabel_bsd_to_sun(lp, (struct sun_disklabel *)bp->b_data);
	if (error)
		goto done;

	/* Write out the updated label. */
	bp->b_blkno = LABELSECTOR;
	bp->b_bcount = lp->d_secsize;
	CLR(bp->b_flags, B_READ | B_WRITE | B_DONE);
	SET(bp->b_flags, B_BUSY | B_WRITE | B_RAW);
	(*strat)(bp);
	error = biowait(bp);

done:
	if (bp) {
		bp->b_flags |= B_INVAL;
		brelse(bp);
	}
	disk_change = 1;
	return (error);
}

/************************************************************************
 *
 * The rest of this was taken from arch/sparc/scsi/sun_disklabel.c
 * and then substantially rewritten by Gordon W. Ross
 *
 ************************************************************************/

/* What partition types to assume for Sun disklabels: */
static u_char
sun_fstypes[16] = {
	FS_BSDFFS,	/* a */
	FS_SWAP,	/* b */
	FS_UNUSED,	/* c - whole disk */
	FS_BSDFFS,	/* d */
	FS_BSDFFS,	/* e */
	FS_BSDFFS,	/* f */
	FS_BSDFFS,	/* g */
	FS_BSDFFS,	/* h */
	FS_BSDFFS,	/* i */
	FS_BSDFFS,	/* j */
	FS_BSDFFS,	/* k */
	FS_BSDFFS,	/* l */
	FS_BSDFFS,	/* m */
	FS_BSDFFS,	/* n */
	FS_BSDFFS,	/* o */
	FS_BSDFFS	/* p */
};

/*
 * Given a struct sun_disklabel, assume it has an extended partition
 * table and compute the correct value for sl_xpsum.
 */
static __inline u_int
sun_extended_sum(struct sun_disklabel *sl, void *end)
{
	u_int sum, *xp, *ep;

	xp = (u_int *)&sl->sl_xpmag;
	ep = (u_int *)end;

	sum = 0;
	for (; xp < ep; xp++)
		sum += *xp;
	return (sum);
}

/*
 * Given a SunOS disk label, set lp to a BSD disk label.
 * The BSD label is cleared out before this is called.
 */
static int
disklabel_sun_to_bsd(struct sun_disklabel *sl, struct disklabel *lp)
{
	struct sun_preamble *preamble = (struct sun_preamble *)sl;
	struct sun_partinfo *ppp;
	struct sun_dkpart *spp;
	struct partition *npp;
	u_short cksum = 0, *sp1, *sp2;
	int i, secpercyl;

	/* Verify the XOR check. */
	sp1 = (u_short *)sl;
	sp2 = (u_short *)(sl + 1);
	while (sp1 < sp2)
		cksum ^= *sp1++;
	if (cksum != 0)
		return (EINVAL);	/* SunOS disk label, bad checksum */

	/* Format conversion. */
	lp->d_magic = DISKMAGIC;
	lp->d_magic2 = DISKMAGIC;
	lp->d_flags = D_VENDOR;
	memcpy(lp->d_packname, sl->sl_text, sizeof(lp->d_packname));

	lp->d_secsize = DEV_BSIZE;
	lp->d_nsectors = sl->sl_nsectors;
	lp->d_ntracks = sl->sl_ntracks;
	lp->d_ncylinders = sl->sl_ncylinders;

	secpercyl = sl->sl_nsectors * sl->sl_ntracks;
	lp->d_secpercyl = secpercyl;
	/* If unset or initialized as full disk, permit refinement */
	if (DL_GETDSIZE(lp) == 0 || DL_GETDSIZE(lp) == MAXDISKSIZE)
		DL_SETDSIZE(lp, (u_int64_t)secpercyl * sl->sl_ncylinders);
	lp->d_version = 1;

	memcpy(&lp->d_uid, &sl->sl_uid, sizeof(lp->d_uid));

	lp->d_acylinders = sl->sl_acylinders;

	lp->d_npartitions = MAXPARTITIONS;
	/* These are as defined in <ufs/ffs/fs.h> */
	lp->d_bbsize = 8192;	/* XXX */
	lp->d_sbsize = 8192;	/* XXX */

	for (i = 0; i < 8; i++) {
		spp = &sl->sl_part[i];
		npp = &lp->d_partitions[i];
		DL_SETPOFFSET(npp, spp->sdkp_cyloffset * secpercyl);
		DL_SETPSIZE(npp, spp->sdkp_nsectors);
		if (DL_GETPSIZE(npp) == 0) {
			npp->p_fstype = FS_UNUSED;
		} else {
			npp->p_fstype = sun_fstypes[i];
			if (npp->p_fstype == FS_BSDFFS) {
				/*
				 * The sun label does not store the FFS fields,
				 * so just set them with default values here.
				 */
				npp->p_fragblock =
				    DISKLABELV1_FFS_FRAGBLOCK(2048, 8);
				npp->p_cpg = 16;
			}
		}
	}

	/* Clear "extended" partition info, tentatively */
	for (i = 0; i < SUNXPART; i++) {
		npp = &lp->d_partitions[i+8];
		DL_SETPOFFSET(npp, 0);
		DL_SETPSIZE(npp, 0);
		npp->p_fstype = FS_UNUSED;
	}

	/* Check to see if there's an "extended" partition table
	 * SL_XPMAG partitions had checksums up to just before the
	 * (new) sl_types variable, while SL_XPMAGTYP partitions have
	 * checksums up to the just before the (new) sl_xxx1 variable.
	 * Also, disklabels created prior to the addition of sl_uid will
	 * have a checksum to just before the sl_uid variable.
	 */
	if ((sl->sl_xpmag == SL_XPMAG &&
	    sun_extended_sum(sl, &sl->sl_types) == sl->sl_xpsum) ||
	    (sl->sl_xpmag == SL_XPMAGTYP &&
	    sun_extended_sum(sl, &sl->sl_uid) == sl->sl_xpsum) ||
	    (sl->sl_xpmag == SL_XPMAGTYP &&
	    sun_extended_sum(sl, &sl->sl_xxx1) == sl->sl_xpsum)) {
		/*
		 * There is.  Copy over the "extended" partitions.
		 * This code parallels the loop for partitions a-h.
		 */
		for (i = 0; i < SUNXPART; i++) {
			spp = &sl->sl_xpart[i];
			npp = &lp->d_partitions[i+8];
			DL_SETPOFFSET(npp, spp->sdkp_cyloffset * secpercyl);
			DL_SETPSIZE(npp, spp->sdkp_nsectors);
			if (DL_GETPSIZE(npp) == 0) {
				npp->p_fstype = FS_UNUSED;
				continue;
			}
			npp->p_fstype = sun_fstypes[i+8];
			if (npp->p_fstype == FS_BSDFFS) {
				npp->p_fragblock =
				    DISKLABELV1_FFS_FRAGBLOCK(2048, 8);
				npp->p_cpg = 16;
			}
		}
		if (sl->sl_xpmag == SL_XPMAGTYP) {
			for (i = 0; i < MAXPARTITIONS; i++) {
				npp = &lp->d_partitions[i];
				npp->p_fstype = sl->sl_types[i];
				npp->p_fragblock = sl->sl_fragblock[i];
				npp->p_cpg = sl->sl_cpg[i];
			}
		}
	} else if (preamble->sl_nparts <= 8) {
		/*
		 * A more traditional Sun label.  Recognise certain filesystem
		 * types from it, if they are available.
		 */
		i = preamble->sl_nparts;
		if (i == 0)
			i = 8;

		npp = &lp->d_partitions[i-1];
		ppp = &preamble->sl_part[i-1];
		for (; i > 0; i--, npp--, ppp--) {
			if (npp->p_size == 0)
				continue;
			if ((ppp->spi_tag == 0) && (ppp->spi_flag == 0))
				continue;

			switch (ppp->spi_tag) {
			case SPTAG_SUNOS_ROOT:
			case SPTAG_SUNOS_USR:
			case SPTAG_SUNOS_VAR:
			case SPTAG_SUNOS_HOME:
				npp->p_fstype = FS_BSDFFS;
				npp->p_fragblock =
				    DISKLABELV1_FFS_FRAGBLOCK(2048, 8);
				npp->p_cpg = 16;
				break;
			case SPTAG_LINUX_EXT2:
				npp->p_fstype = FS_EXT2FS;
				break;
			default:
				/* FS_SWAP for _SUNOS_SWAP and _LINUX_SWAP? */
				npp->p_fstype = FS_UNUSED;
				break;
			}
		}
	}

	lp->d_checksum = 0;
	lp->d_checksum = dkcksum(lp);
	return (checkdisklabel(lp, lp, 0, DL_GETDSIZE(lp)));
}

/*
 * Given a BSD disk label, update the Sun disklabel
 * pointed to by cp with the new info.  Note that the
 * Sun disklabel may have other info we need to keep.
 */
static int
disklabel_bsd_to_sun(struct disklabel *lp, struct sun_disklabel *sl)
{
	struct partition *npp;
	struct sun_dkpart *spp;
	int i, secpercyl;
	u_short cksum, *sp1, *sp2;

	/* Enforce preconditions */
	if (lp->d_secsize != DEV_BSIZE || lp->d_nsectors == 0 ||
	    lp->d_ntracks == 0)
		return (EINVAL);

	/* Format conversion. */
	bzero(sl, sizeof(*sl));
	memcpy(sl->sl_text, lp->d_packname, sizeof(lp->d_packname));
	sl->sl_pcylinders = lp->d_ncylinders + lp->d_acylinders; /* XXX */
	sl->sl_ncylinders = lp->d_ncylinders;
	sl->sl_acylinders = lp->d_acylinders;
	sl->sl_ntracks = lp->d_ntracks;
	sl->sl_nsectors = lp->d_nsectors;

	memcpy(&sl->sl_uid, &lp->d_uid, sizeof(lp->d_uid));

	secpercyl = sl->sl_nsectors * sl->sl_ntracks;
	for (i = 0; i < 8; i++) {
		spp = &sl->sl_part[i];
		npp = &lp->d_partitions[i];
		spp->sdkp_cyloffset = 0;
		spp->sdkp_nsectors = 0;
		if (DL_GETPSIZE(npp)) {
			if (DL_GETPOFFSET(npp) % secpercyl)
				return (EINVAL);
			spp->sdkp_cyloffset = DL_GETPOFFSET(npp) / secpercyl;
			spp->sdkp_nsectors = DL_GETPSIZE(npp);
		}
	}
	sl->sl_magic = SUN_DKMAGIC;

	for (i = 0; i < SUNXPART; i++) {
		spp = &sl->sl_xpart[i];
		npp = &lp->d_partitions[i+8];
		spp->sdkp_cyloffset = 0;
		spp->sdkp_nsectors = 0;
		if (DL_GETPSIZE(npp)) {
			if (DL_GETPOFFSET(npp) % secpercyl)
				return (EINVAL);
			spp->sdkp_cyloffset = DL_GETPOFFSET(npp) / secpercyl;
			spp->sdkp_nsectors = DL_GETPSIZE(npp);
		}
	}
	for (i = 0; i < MAXPARTITIONS; i++) {
		npp = &lp->d_partitions[i];
		sl->sl_types[i] = npp->p_fstype;
		sl->sl_fragblock[i] = npp->p_fragblock;
		sl->sl_cpg[i] = npp->p_cpg;
	}
	sl->sl_xpmag = SL_XPMAGTYP;
	sl->sl_xpsum = sun_extended_sum(sl, &sl->sl_xxx1);

	/* Correct the XOR check. */
	sp1 = (u_short *)sl;
	sp2 = (u_short *)(sl + 1);
	sl->sl_cksum = cksum = 0;
	while (sp1 < sp2)
		cksum ^= *sp1++;
	sl->sl_cksum = cksum;

	return (0);
}
@


1.71
log
@Oops. sparc64/disksubr.c was overlooked when all the other disksubr.c's
got 'disk_change = 1;' to keep the DUID cache up to date in Feb.
2011. Bad krw@@.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.70 2015/09/27 22:34:27 krw Exp $	*/
d90 1
a90 1
	bp = geteblk((int)lp->d_secsize);
d146 1
a146 1
	bp = geteblk((int)lp->d_secsize);
@


1.70
log
@Use readdisksector() instead of manual buf initialization. sparc64
compiles and boots, so the identical sparc code must too!

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.69 2015/01/16 20:17:06 miod Exp $	*/
d132 1
d166 1
@


1.69
log
@disklabel_sun_to_bsd() will nicely set the disk size if it is zero, but it is
usually invoked after initdisklabel() which proactively changes a zero disk
size to MAXDISKSIZE, causing this test to fail.

Allow for MAXDISKSIZE too in that test. This makes spoofed disklabels of SMD
disks have a proper `c' slice size.

luna88k disklabel_om_to_bsd() is modified accordingly, to keep diffability,
even though luna88k can't - to the best of my knowledge - sport SMD disk
controllers.

ok deraadt@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.68 2013/10/20 10:11:17 krw Exp $	*/
d96 2
a97 7
	bp->b_blkno = LABELSECTOR;
	bp->b_bcount = lp->d_secsize;
	CLR(bp->b_flags, B_READ | B_WRITE | B_DONE);
	SET(bp->b_flags, B_BUSY | B_READ | B_RAW);
	(*strat)(bp);
	if (biowait(bp)) {
		error = bp->b_error;
a98 1
	}
@


1.68
log
@(daddr_t) -> (u_int64_t) when multiplying ncylinders * secpercyl to
get disk size, since DL_SETDSIZE() takes disk sector values, not
512-byte block values.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.67 2013/06/11 16:42:12 deraadt Exp $	*/
d255 2
a256 1
	if (DL_GETDSIZE(lp) == 0)
@


1.67
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.66 2011/04/16 03:21:15 krw Exp $	*/
d256 1
a256 1
		DL_SETDSIZE(lp, (daddr_t)secpercyl * sl->sl_ncylinders);
@


1.66
log
@Use 'CLR(<buf>->b_flags, B_READ | B_WRITE | B_DONE)' regardless of
what the previous IO was. Less chance of copy and paste errors.
Suggested by miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.65 2011/04/15 14:57:29 krw Exp $	*/
d256 1
a256 1
		DL_SETDSIZE(lp, (daddr64_t)secpercyl * sl->sl_ncylinders);
@


1.65
log
@In days of yore one could arbitrarily whack buffer flags. Those days
are past. Use CLR() and SET() to modify necessary flags while leaving
the flags used by the buffer cache in peace.

Should make bufcache code much less confused about the state of the
bufs used in reading/writing disklabels. Other such flag abuses no
doubt await a visit.

Errors in original diff found by miod@@.

ok beck@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.64 2011/04/06 13:46:51 miod Exp $	*/
d98 1
a98 1
	CLR(bp->b_flags, B_WRITE | B_DONE);
d161 1
a161 1
	CLR(bp->b_flags, B_READ | B_DONE);
@


1.64
log
@The various read*label() have stopped returning error strings for quite
some time, and return errnos instead. Fix or remove out-of-date comments
mentioning the error strings, and make their callers check the return value
against zero, not NULL.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.63 2010/09/08 14:37:32 jsing Exp $	*/
d98 2
a99 1
	bp->b_flags = B_BUSY | B_READ | B_RAW;
d161 2
a162 1
	bp->b_flags = B_BUSY | B_WRITE | B_RAW;
@


1.63
log
@Nuke bogus comment.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.60 2010/04/24 20:12:23 miod Exp $	*/
a56 4
 *
 * Return buffer for use in signalling errors if requested.
 *
 * Returns null on success and an error string on failure.
a382 1
 * Returns zero or error code.
@


1.62
log
@Correctly recognise extended partitions created prior to the addition of
sl_uid. Fix tested by okan@@.

ok deraadt@@
@
text
@a223 2
 * Returns NULL on success, else an error string.
 *
@


1.61
log
@introducing a 64-bit type to the disklabel structure leads some architectures
to pad-align the size of the structure; it grows, the disklabel ioctl's are
break ABI.  Change the uid to a character array.  this also simplifies some
other stuff
ok jsing
@
text
@d305 2
d310 2
@


1.60
log
@grammar in comments
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.59 2010/04/23 15:25:21 jsing Exp $	*/
d263 1
a263 1
	lp->d_label_uid = sl->sl_label_uid;
d409 1
a409 1
	sl->sl_label_uid = lp->d_label_uid;
@


1.59
log
@Recycle unused disklabel fields in order to create a disklabel unique
identifier, allowing the disk to be identified without relying on the
device name.

ok deraadt@@ krw@@ beck@@ marco@@ todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.57 2009/08/13 15:23:11 deraadt Exp $	*/
d78 1
a78 1
	 * the SunOS label, for loading it's kernel.
@


1.58
log
@when we build a vendor label for writing, clear the memory supplied by the
buffer cache first, so that all sorts of gibble doesn't end up on the disk.
ok kettenis (for the sparc/sparc64 ones, at least)
@
text
@d263 2
a264 1
	lp->d_sparespercyl = sl->sl_sparespercyl;
a265 2
	lp->d_rpm = sl->sl_rpm;
	lp->d_interleave = sl->sl_interleave;
a402 1
	sl->sl_rpm = lp->d_rpm;
a403 2
	sl->sl_sparespercyl = lp->d_sparespercyl;
	sl->sl_interleave = lp->d_interleave;
d408 2
@


1.57
log
@Replace the error strings that were being passed around with much simpler
errnos.  Note that the error strings are being ignored, since we long ago
decided to not spam the console, and there is no other nice way to use the
errors (without changing the ioctls to pass it back)
The errno is now useful, since we can pass b_error from failing IO up, and
the drive can decide how to use that
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.56 2009/06/04 21:13:02 deraadt Exp $	*/
d402 1
@


1.56
log
@Recycle four ancient fields in the disklabel structure, replacing them with
bounds information, ie. the zone of the disk that OpenBSD can use.  Have each
pre-disklabel parser (MBR, DPME, or per-arch MD disklabel parsers) figure out
this area and pass it up to userland.  Then, delete all the same disk parsing
code from disklabel(8) since the kernel passes it up.  Lots and lots of - signs
in the disklabel(8) code.
Tested on as many platforms as possible, the fallout will be repaired as time
goes on.  To test, use disklabel -d <drive> and validate that the bounds do not
overlap any boot blocks.  This same information is used by disklabel -A...
OK for the concept from krw, miod, and drahn
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.55 2009/05/13 01:31:58 krw Exp $	*/
d42 1
a42 1
static	char *disklabel_sun_to_bsd(struct sun_disklabel *, struct disklabel *);
d62 1
a62 1
char *
d68 1
a68 1
	char *msg;
d70 1
a70 1
	if ((msg = initdisklabel(lp)))
d105 1
a105 1
		msg = "disk label read error";
d111 1
a111 1
		msg = disklabel_sun_to_bsd(slp, lp);
d115 2
a116 2
	msg = checkdisklabel(bp->b_data + LABELOFFSET, lp, 0, DL_GETDSIZE(lp));
	if (msg == NULL)
d120 2
a121 2
	msg = readdoslabel(bp, strat, lp, NULL, spoofonly);
	if (msg == NULL)
d126 2
a127 2
	if (iso_disklabelspoof(dev, strat, lp) == 0) {
		msg = NULL;
a128 1
	}
d131 2
a132 2
	if (udf_disklabelspoof(dev, strat, lp) == 0) {
		msg = NULL;
a133 1
	}
d141 1
a141 1
	return (msg);
d228 1
a228 1
static char *
d244 1
a244 1
		return ("SunOS disk label, bad checksum");
@


1.55
log
@Set D_VENDOR when spoofing a label on archs that use D_VENDOR when
reading the native disklabel. This ensures cylinder alignment.

Fix disklabel to do cylinder alignment arithmetic correctly in -A
mode. Worked by accident before, since the code was protected by
D_VENDOR, which wasn't being set.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.54 2009/04/07 03:11:59 krw Exp $	*/
d115 1
a115 1
	msg = checkdisklabel(bp->b_data + LABELOFFSET, lp);
d381 1
a381 1
	return (checkdisklabel(lp, lp));
@


1.54
log
@Eliminate useless loop over partitions and ignore zero length
partitions in bsd_to_sun(), even if their offsets are nonsense.
Theo says if sparc64 compiles so will sparc. Fixes some useless
disklabel warning messages.

ok miod@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.53 2009/01/22 01:06:28 krw Exp $	*/
d72 1
@


1.53
log
@Call checkdisklabel() for labels built from native info. This will
ensure 'c' always has the correct size as the rest of the kernel
assumes. Thus prevent dd'ing causing a SCSI out-of-bounds error.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.52 2008/06/29 20:05:22 krw Exp $	*/
d417 8
a424 5

		if (DL_GETPOFFSET(npp) % secpercyl)
			return (EINVAL);
		spp->sdkp_cyloffset = DL_GETPOFFSET(npp) / secpercyl;
		spp->sdkp_nsectors = DL_GETPSIZE(npp);
a428 5
		if (DL_GETPOFFSET(&lp->d_partitions[i+8]) ||
		    DL_GETPSIZE(&lp->d_partitions[i+8]))
			break;
	}
	for (i = 0; i < SUNXPART; i++) {
d431 8
a438 5
		if (DL_GETPOFFSET(npp) % secpercyl)
			return (EINVAL);
		sl->sl_xpart[i].sdkp_cyloffset =
		    DL_GETPOFFSET(npp) / secpercyl;
		sl->sl_xpart[i].sdkp_nsectors = DL_GETPSIZE(npp);
@


1.52
log
@Use DEV_BSIZE (defined as 512) instead of 512 when initializing the
disklabel's d_secsize.

ok millert@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.51 2008/06/12 06:58:37 deraadt Exp $	*/
d380 1
a380 1
	return (NULL);
@


1.51
log
@Bring biomem diff back into the tree after the nfs_bio.c fix went in.
ok thib beck art
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.49 2008/06/10 20:50:23 beck Exp $	*/
d253 1
a253 1
	lp->d_secsize = 512;
d398 2
a399 1
	if (lp->d_secsize != 512 || lp->d_nsectors == 0 || lp->d_ntracks == 0)
@


1.50
log
@back out biomem diff since it is not right yet.  Doing very large
file copies to nfsv2 causes the system to eventually peg the console.
On the console ^T indicates that the load is increasing rapidly, ddb
indicates many calls to getbuf, there is some very slow nfs traffic
making none (or extremely slow) progress.  Eventually some machines
seize up entirely.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.48 2007/10/02 03:26:59 krw Exp $	*/
d101 1
a101 1
	bp->b_flags = B_BUSY | B_READ;
d165 1
a165 1
	bp->b_flags = B_BUSY | B_WRITE;
@


1.49
log
@Fix buffer cache pending read statistics by ensuring we can identify
biowait() reads that do *not* come from the buffer cache - we use the
B_RAW flag to identify these at art's suggestion - since it makes sense
and the flag was not being used. this just flags all these buffers with
B_RAW - biodone already ignores returned buffers marked B_RAW.
ok art@@
@
text
@d101 1
a101 1
	bp->b_flags = B_BUSY | B_READ | B_RAW;
d165 1
a165 1
	bp->b_flags = B_BUSY | B_WRITE | B_RAW;
@


1.48
log
@Fiddle Sun traditional disklabel recognition to eliminate union and
associated field access defines. This reverts most changes to
dev/sun/disklabel.h without eliminating new functionality. Fix
comments to line up and fit on 80 column line, making both tsi@@ and I
feel better.

Simplify logic in disksubr.c. No semantic change.

Tested & ok tsi@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.47 2007/09/19 23:47:50 tsi Exp $	*/
d101 1
a101 1
	bp->b_flags = B_BUSY | B_READ;
d165 1
a165 1
	bp->b_flags = B_BUSY | B_WRITE;
@


1.47
log
@On sparc & sparc64, change `mount -a` to recognise Linux ext2 partitions
by interpreting more fields out of a standard Sun disk label.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.46tsi Exp $	*/
d232 3
d236 1
a236 2
	struct sun_dkpart *spp;
	struct sun_partinfo *ppp;
a237 1
	u_short cksum = 0, *sp1, *sp2;
d340 1
a340 1
	} else if (sl->sl_nparts <= 8) {
d345 7
a351 17
		if ((i = sl->sl_nparts) == 0) {
			for (i = 8;  i-- > 0; ) {
				npp = &lp->d_partitions[i];
				if (npp->p_size == 0)
					continue;

				ppp = &sl->sl_ipart[i];
				if ((ppp->spi_tag == 0) && (ppp->spi_flag == 0))
					continue;

				i = 8;
				break;
			}
		}

		while (i-- > 0) {
			npp = &lp->d_partitions[i];
d354 2
a356 1
			ppp = &sl->sl_ipart[i];
a357 9
			case SPTAG_EMPTY:
			case SPTAG_BOOT:
			case SPTAG_WHOLE_DISK:
				npp->p_fstype = FS_UNUSED;
				break;
			case SPTAG_SUNOS_SWAP:
			case SPTAG_LINUX_SWAP:
				npp->p_fstype = FS_UNUSED;	/* FS_SWAP? */
				break;
d371 1
@


1.46
log
@b_cylinder does not need to be set on the callpath down into drivers.
cpu_disklabel can go away, since nothing anymore needs to use it; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.45 2007/06/18 05:28:54 deraadt Exp $	*/
d234 1
d331 1
a331 1
		if (sl->sl_xpmag == SL_XPMAGTYP)
d338 54
@


1.45
log
@using same words in similar code sequences is good
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.44 2007/06/18 02:14:17 deraadt Exp $	*/
d64 1
a64 1
    struct disklabel *lp, struct cpu_disklabel *osdep, int spoofonly)
a99 1
	bp->b_cylinder = 0;
d119 1
a119 1
	msg = readdoslabel(bp, strat, lp, osdep, NULL, NULL, spoofonly);
d149 1
a149 2
writedisklabel(dev_t dev, void (*strat)(struct buf *),
    struct disklabel *lp, struct cpu_disklabel *osdep)
a163 1
	bp->b_cylinder = 0;
@


1.44
log
@msg is already gauranteed to be NULL
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.43 2007/06/17 00:27:29 deraadt Exp $	*/
d92 1
a92 1
	/* obtain buffer and initialize it */
d156 1
a156 1
	/* obtain buffer and initialize it */
@


1.43
log
@significantly simplified disklabel infrastructure.  MBR handling becomes MI
to support hotplug media on most architectures.  disklabel setup and
verification done using new helper functions.  Disklabels must *always*
have a correct checksum now.  Same code paths are used to learn on-disk
location disklabels, to avoid new errors sneaking in.  Tested on almost all
cases, testing help from todd, kettenis, krw, otto, dlg, robert, gwk, drahn
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.42 2007/06/14 03:41:22 deraadt Exp $	*/
d82 1
a82 2
		if (iso_disklabelspoof(dev, strat, lp) == 0) {
			msg = NULL;
a83 1
		}
d86 1
a86 2
		if (udf_disklabelspoof(dev, strat, lp) == 0) {
			msg = NULL;
a87 1
		}
@


1.42
log
@some spaces in the way
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.41 2007/06/14 03:37:23 deraadt Exp $	*/
a34 2
#include <sys/ioccom.h>
#include <sys/device.h>
a37 2
#include <machine/cpu.h>
#include <machine/autoconf.h>
a39 2
#include <dev/sbus/sbusvar.h>

d42 2
a43 2
static	char *disklabel_sun_to_bsd(char *, struct disklabel *);
static	int disklabel_bsd_to_sun(struct disklabel *, char *);
d64 1
a64 1
    struct disklabel *lp, struct cpu_disklabel *clp, int spoofonly)
d66 1
d68 1
a68 4
	struct disklabel *dlp;
	struct sun_disklabel *slp;
	char *msg = NULL;
	int error, i;
d70 1
a70 23
	/* minimal requirements for archetypal disk label */
	if (lp->d_secsize < DEV_BSIZE)
		lp->d_secsize = DEV_BSIZE;
	if (DL_GETDSIZE(lp) == 0)
		DL_SETDSIZE(lp, MAXDISKSIZE);
	if (lp->d_secpercyl == 0) {
		msg = "invalid geometry";
		goto done;
	}
	lp->d_npartitions = RAW_PART+1;
	for (i = 0; i < RAW_PART; i++) {
		DL_SETPSIZE(&lp->d_partitions[i], 0);
		DL_SETPOFFSET(&lp->d_partitions[i], 0);
	}
	if (DL_GETPSIZE(&lp->d_partitions[RAW_PART]) == 0)
		DL_SETPSIZE(&lp->d_partitions[RAW_PART], DL_GETDSIZE(lp));
	DL_SETPOFFSET(&lp->d_partitions[RAW_PART], 0);
	lp->d_version = 1;
	lp->d_bbsize = 8192;
	lp->d_sbsize = 64*1024;		/* XXX ? */

	/* don't read the on-disk label if we are in spoofed-only mode */
	if (spoofonly)
d73 6
d96 1
a96 1
	/* obtain buffer to probe drive with */
d98 4
a102 2
	/* next, dig out disk label */
	bp->b_dev = dev;
d108 1
a108 8

	/* if successful, locate disk label within block and validate */
	error = biowait(bp);
	if (error == 0) {
		/* Save the whole block in case it has info we need. */
		bcopy(bp->b_data, clp->cd_block, sizeof(clp->cd_block));
	}
	if (error) {
d113 1
a113 1
	slp = (struct sun_disklabel *)clp->cd_block;
d115 1
a115 1
		msg = disklabel_sun_to_bsd(clp->cd_block, lp);
d119 7
a125 10
	/* Check for a native disk label (PROM can not boot it). */
	dlp = (struct disklabel *)(clp->cd_block + LABELOFFSET);
	if (dlp->d_magic == DISKMAGIC) {
		if (dkcksum(dlp)) {
			msg = "disk label corrupted";
			goto done;
		}
		DL_SETDSIZE(dlp, DL_GETDSIZE(lp));
		*lp = *dlp;	/* struct assignment */
		msg = NULL;
a126 1
	}
d128 1
a140 2
	bzero(clp->cd_block, sizeof(clp->cd_block));
	msg = "no disk label";
a146 1
	disklabeltokernlabel(lp);
a151 1
 * Current label is already in clp->cd_block[]
d155 1
a155 1
    struct disklabel *lp, struct cpu_disklabel *clp)
d160 5
a164 1
	error = disklabel_bsd_to_sun(lp, clp->cd_block);
a167 4
	/* Get a buffer and copy the new label into it. */
	bp = geteblk((int)lp->d_secsize);
	bcopy(clp->cd_block, bp->b_data, sizeof(clp->cd_block));

a168 1
	bp->b_dev = dev;
d237 1
a237 1
disklabel_sun_to_bsd(char *cp, struct disklabel *lp)
a238 1
	struct sun_disklabel *sl;
d242 1
a242 3
	u_short cksum, *sp1, *sp2;

	sl = (struct sun_disklabel *)cp;
a246 1
	cksum = 0;
d255 1
d267 1
a267 1
	lp->d_version = 1;	/* 48 bit addressing */
d358 1
a358 1
disklabel_bsd_to_sun(struct disklabel *lp, char *cp)
a359 1
	struct sun_disklabel *sl;
a367 2

	sl = (struct sun_disklabel *)cp;
@


1.41
log
@excessive blank lines making the versions different
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.40 2007/06/14 03:35:30 deraadt Exp $	*/
d299 2
a300 2
	lp->d_nsectors   = sl->sl_nsectors;
	lp->d_ntracks    = sl->sl_ntracks;
d304 1
a304 1
	lp->d_secpercyl  = secpercyl;
d310 3
a312 3
	lp->d_acylinders   = sl->sl_acylinders;
	lp->d_rpm          = sl->sl_rpm;
	lp->d_interleave   = sl->sl_interleave;
d415 1
a415 1
	sl->sl_pcylinders   = lp->d_ncylinders + lp->d_acylinders; /* XXX */
d417 5
a421 5
	sl->sl_interleave   = lp->d_interleave;
	sl->sl_ncylinders   = lp->d_ncylinders;
	sl->sl_acylinders   = lp->d_acylinders;
	sl->sl_ntracks      = lp->d_ntracks;
	sl->sl_nsectors     = lp->d_nsectors;
@


1.40
log
@set the prototype disklabel to version 1
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.39 2007/06/14 03:29:34 deraadt Exp $	*/
a183 1

@


1.39
log
@do not depend on previous loop variable, use a constant instead
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.38 2007/06/12 20:57:43 deraadt Exp $	*/
d95 1
@


1.38
log
@all disksubr.c did their b_flags manipulation differently (and wrong).
correct and unify; ok thib miod
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.37 2007/06/09 23:06:46 krw Exp $	*/
d92 3
a94 3
	if (DL_GETPSIZE(&lp->d_partitions[i]) == 0)
		DL_SETPSIZE(&lp->d_partitions[i], DL_GETDSIZE(lp));
	DL_SETPOFFSET(&lp->d_partitions[i], 0);
@


1.37
log
@The differences in the last non-homogeneous bounds_check_with_label()
routines (alpha, vax) prove to be not worth keeping. Move
bounds_check_with_label() into the MI world. Eliminate unreliable and
almost certainly useless checks for overwriting a disklabel.

After discussion with deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.36 2007/06/09 04:08:39 deraadt Exp $	*/
d177 1
a177 1
		bp->b_flags = B_INVAL | B_AGE | B_READ;
d193 1
a193 1
	struct buf *bp;
d198 1
a198 9
		return (error);

#if 0	/* XXX - Allow writing native disk labels? */
	{
		struct disklabel *dlp;
		dlp = (struct disklabel *)(clp->cd_block + LABELOFFSET);
		*dlp = *lp;	/* struct assignment */
	}
#endif
d209 1
a209 1
	bp->b_flags = B_WRITE;
a211 1
	brelse(bp);
d213 5
@


1.36
log
@by hand i carefully found that all the differences in setdisklabel()
implimentations were simply either missing code, or spacing and such.
setdisklabel() can become MI now.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.35 2007/06/09 02:03:47 deraadt Exp $	*/
a222 56
}

/*
 * Determine the size of the transfer, and make sure it is
 * within the boundaries of the partition. Adjust transfer
 * if needed, and signal errors or early completion.
 */
int
bounds_check_with_label(struct buf *bp, struct disklabel *lp,
    struct cpu_disklabel *osdep, int wlabel)
{
#define blockpersec(count, lp) ((count) * (((lp)->d_secsize) / DEV_BSIZE))
	struct partition *p = lp->d_partitions + DISKPART(bp->b_dev);
	int labelsector = blockpersec(DL_GETPOFFSET(&lp->d_partitions[RAW_PART]), lp) +
	    LABELSECTOR;
	int sz = howmany(bp->b_bcount, DEV_BSIZE);

	/* avoid division by zero */
	if (lp->d_secpercyl == 0) {
		bp->b_error = EINVAL;
		goto bad;
	}

	/* beyond partition? */
	if (bp->b_blkno + sz > blockpersec(DL_GETPSIZE(p), lp)) {
		sz = blockpersec(DL_GETPSIZE(p), lp) - bp->b_blkno;
		if (sz == 0) {
			/* If exactly at end of disk, return EOF. */
			bp->b_resid = bp->b_bcount;
			return (-1);
		}
		if (sz < 0) {
			/* If past end of disk, return EINVAL. */
			bp->b_error = EINVAL;
			goto bad;
		}
		/* Otherwise, truncate request. */
		bp->b_bcount = sz << DEV_BSHIFT;
	}

	/* Overwriting disk label? */
	if (bp->b_blkno + blockpersec(DL_GETPOFFSET(p), lp) <= labelsector &&
	    bp->b_blkno + blockpersec(DL_GETPOFFSET(p), lp) + sz > labelsector &&
	    (bp->b_flags & B_READ) == 0 && !wlabel) {
		bp->b_error = EROFS;
		goto bad;
	}

	/* calculate cylinder for disksort to order transfers with */
	bp->b_cylinder = (bp->b_blkno + blockpersec(DL_GETPOFFSET(p), lp)) /
	    lp->d_secpercyl;
	return (1);

bad:
	bp->b_flags |= B_ERROR;
	return (-1);
@


1.35
log
@annoying spacing glitch which makes the diffs bigger
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.34 2007/06/08 04:59:07 deraadt Exp $	*/
a183 41
/*
 * Check new disk label for sensibility
 * before setting it.
 */
int
setdisklabel(struct disklabel *olp, struct disklabel *nlp,
    u_int openmask, struct cpu_disklabel *clp)
{
	int i;
	struct partition *opp, *npp;

	/* sanity clause */
	if (nlp->d_secpercyl == 0 || nlp->d_secsize == 0 ||
	    (nlp->d_secsize % DEV_BSIZE) != 0)
		return (EINVAL);

	/* special case to allow disklabel to be invalidated */
	if (nlp->d_magic == 0xffffffff) {
		*olp = *nlp;
		return (0);
	}

	if (nlp->d_magic != DISKMAGIC || nlp->d_magic2 != DISKMAGIC ||
	    dkcksum(nlp) != 0)
		return (EINVAL);

	while ((i = ffs(openmask)) != 0) {
		i--;
		openmask &= ~(1 << i);
		if (nlp->d_npartitions <= i)
			return (EBUSY);
		opp = &olp->d_partitions[i];
		npp = &nlp->d_partitions[i];
		if (DL_GETPOFFSET(npp) != DL_GETPOFFSET(opp) ||
		    DL_GETPSIZE(npp) < DL_GETPSIZE(opp))
			return (EBUSY);
	}

	*olp = *nlp;
	return (0);
}
@


1.34
log
@- always set the partition disk size to full disk info (from driver)
- always store our new fatty 16-partitions-with-full-cpg-info style
  sun disklabels on the disk.
- correct an error in matching old-style 16-partition matching code;
  the checksum spanned a different region
tested by me, groked by krw, which is a lot more than the rest of
the post-hackathon exhausted slackers
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.33 2007/06/07 03:41:52 krw Exp $	*/
d198 1
a198 1
		return(EINVAL);
d392 1
a392 1
		return("SunOS disk label, bad checksum");
@


1.33
log
@Comment 'fixes'. All bounds_check_with_label now identical except for
vax and alpha.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.32 2007/06/07 00:28:17 krw Exp $	*/
d50 1
a50 1
static __inline u_int sun_extended_sum(struct sun_disklabel *);
d154 1
d355 1
a355 1
sun_extended_sum(struct sun_disklabel *sl)
d360 1
a360 1
	ep = (u_int *)&sl->sl_xxx1[0];
d449 9
a457 3
	/* Check to see if there's an "extended" partition table */
	if ((sl->sl_xpmag == SL_XPMAG || sl->sl_xpmag == SL_XPMAGTYP) &&
	    sun_extended_sum(sl) == sl->sl_xpsum) {	/* ...yes! */
a535 7
	/*
	 * The reason we store the extended table stuff only conditionally
	 * is so that a label that doesn't need it will have NULs there, like
	 * a "traditional" Sun label.  Since Suns seem to ignore everything
	 * between sl_text and sl_rpm, this probably doesn't matter, but it
	 * certainly doesn't hurt anything and it's easy to do.
	 */
d541 14
a554 26
	/* We do need to load the extended table? */
	if (i < SUNXPART) {
		sl->sl_xpmag = SL_XPMAGTYP;
		for (i = 0; i < SUNXPART; i++) {
			spp = &sl->sl_xpart[i];
			npp = &lp->d_partitions[i+8];
			if (DL_GETPOFFSET(npp) % secpercyl)
				return (EINVAL);
			sl->sl_xpart[i].sdkp_cyloffset =
			    DL_GETPOFFSET(npp) / secpercyl;
			sl->sl_xpart[i].sdkp_nsectors = DL_GETPSIZE(npp);
		}
		for (i = 0; i < MAXPARTITIONS; i++) {
			npp = &lp->d_partitions[i];
			sl->sl_types[i] = npp->p_fstype;
			sl->sl_fragblock[i] = npp->p_fragblock;
			sl->sl_cpg[i] = npp->p_cpg;
		}
		sl->sl_xpsum = sun_extended_sum(sl);
	} else {
		sl->sl_xpmag = 0;
		for (i = 0; i < SUNXPART; i++) {
			sl->sl_xpart[i].sdkp_cyloffset = 0;
			sl->sl_xpart[i].sdkp_nsectors = 0;
		}
		sl->sl_xpsum = 0;
d556 2
@


1.32
log
@More bounds_check_with_label homogenization. Fix a couple of typos while
there.

'so go to it!' deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.31 2007/06/06 22:14:32 deraadt Exp $	*/
d303 1
a303 4
	/* overwriting disk label ? */
	/* XXX should also protect bootstrap in first 8K */
	/* XXX this assumes everything <=LABELSECTOR is label! */
	/*     But since LABELSECTOR is 0, that's ok for now. */
@


1.31
log
@clamp the disklabel d_secperunit to what the disk actually says it has,
not to what some bogus disklabel from the past may say (some of which
may have been caused by older openbsd disklabel programs).  resolves
issues seen by myself and Markus Lude on sparc/sparc64 machines
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.30 2007/06/06 16:42:06 deraadt Exp $	*/
d276 2
d292 1
a292 1
			return (0);
d307 3
a309 2
	if ((bp->b_blkno + blockpersec(DL_GETPOFFSET(p), lp) <= LABELSECTOR) &&
	    ((bp->b_flags & B_READ) == 0) && (wlabel == 0)) {
d318 1
@


1.30
log
@a fair sprinking of knf, code movement, and sometimes character-by-character
accuracy so that the variious disksubr.c's can be compared easier.
setdisklabel() starts taking an int for openmask.
ok krw, and read by quite a few other people
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.29 2007/06/05 02:38:37 krw Exp $	*/
d404 2
a405 1
	DL_SETDSIZE(lp, (daddr64_t)secpercyl * sl->sl_ncylinders);
@


1.29
log
@bounds_check_with_label() checks for i/o outside of the partition and
for overwriting the disklabel. Reorder some checks so all copies of
bounds_check_with_label do the checks in the same order. Order picked
by using the currently most popular one. Should be no functional
change.

"If it's boring, commit it" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.28 2007/06/05 00:38:19 deraadt Exp $	*/
d40 2
a41 3
#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>

d44 1
a44 2
#include <machine/autoconf.h>
#include <machine/cpu.h>
a45 1
#include <dev/sbus/sbusvar.h>
a51 2
extern struct device *bootdv;

d69 2
a70 6
readdisklabel(dev, strat, lp, clp, spoofonly)
	dev_t dev;
	void (*strat)(struct buf *);
	struct disklabel *lp;
	struct cpu_disklabel *clp;
	int spoofonly;
d127 1
a127 1
	bp->b_flags |= B_BUSY | B_READ;
d141 1
a141 1
	slp = (struct sun_disklabel *) clp->cd_block;
d148 1
a148 1
	dlp = (struct disklabel *) (clp->cd_block + LABELOFFSET);
d160 1
a160 1
	if (iso_disklabelspoof(dev, strat, lp) == NULL) {
d188 2
a189 4
setdisklabel(olp, nlp, openmask, clp)
	struct disklabel *olp, *nlp;
	u_long openmask;
	struct cpu_disklabel *clp;
d209 1
a209 1
	while ((i = ffs((long)openmask)) != 0) {
d230 2
a231 5
writedisklabel(dev, strat, lp, clp)
	dev_t dev;
	void (*strat)(struct buf *);
	struct disklabel *lp;
	struct cpu_disklabel *clp;
d237 2
d257 1
a257 1
	bp->b_flags |= B_WRITE;
d345 1
a345 1
	FS_BSDFFS,	/* p */
d353 1
a353 2
sun_extended_sum(sl)
	struct sun_disklabel *sl;
d355 1
a355 3
	u_int lsum;
	u_int *xp;
	u_int *ep;
d360 1
a360 1
	lsum = 0;
d362 2
a363 2
		lsum += *xp;
	return(lsum);
d373 1
a373 3
disklabel_sun_to_bsd(cp, lp)
	char *cp;
	struct disklabel *lp;
d490 1
a490 3
disklabel_bsd_to_sun(lp, cp)
	struct disklabel *lp;
	char *cp;
@


1.28
log
@use six new macros to access & store the 48-bit disklabel fields related
to size.  tested on almost all machines, double checked by miod and krw
next comes the type handling surrounding these values
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.27 2007/06/02 02:35:27 krw Exp $	*/
a295 10
	/* overwriting disk label ? */
	/* XXX should also protect bootstrap in first 8K */
	/* XXX this assumes everything <=LABELSECTOR is label! */
	/*     But since LABELSECTOR is 0, that's ok for now. */
	if ((bp->b_blkno + blockpersec(DL_GETPOFFSET(p), lp) <= LABELSECTOR) &&
	    ((bp->b_flags & B_READ) == 0) && (wlabel == 0)) {
		bp->b_error = EROFS;
		goto bad;
	}

d311 10
@


1.27
log
@Rename cvtdisklabelv1 -> disklabeltokernlabel. It does more than just
convert version 0 to version 1 disklabels.

Suggested by deraadt@@.

ok deraadt@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.26 2007/05/31 19:57:44 krw Exp $	*/
d90 2
a91 2
	if (lp->d_secperunit == 0)
		lp->d_secperunit = 0x1fffffff;
d98 2
a99 2
		lp->d_partitions[i].p_size = 0;
		lp->d_partitions[i].p_offset = 0;
d101 3
a103 3
	if (lp->d_partitions[i].p_size == 0)
		lp->d_partitions[i].p_size = lp->d_secperunit;
	lp->d_partitions[i].p_offset = 0;
d227 2
a228 1
		if (npp->p_offset != opp->p_offset || npp->p_size < opp->p_size)
d300 1
a300 1
	if ((bp->b_blkno + blockpersec(p->p_offset, lp) <= LABELSECTOR) &&
d307 2
a308 2
	if (bp->b_blkno + sz > blockpersec(p->p_size, lp)) {
		sz = blockpersec(p->p_size, lp) - bp->b_blkno;
d324 1
a324 1
	bp->b_cylinder = (bp->b_blkno + blockpersec(p->p_offset, lp)) /
d421 1
a421 1
	lp->d_secperunit = secpercyl * sl->sl_ncylinders;
d437 3
a439 3
		npp->p_offset = spp->sdkp_cyloffset * secpercyl;
		npp->p_size = spp->sdkp_nsectors;
		if (npp->p_size == 0) {
d458 2
a459 2
		npp->p_offset = 0;
		npp->p_size = 0;
d473 3
a475 3
			npp->p_offset = spp->sdkp_cyloffset * secpercyl;
			npp->p_size = spp->sdkp_nsectors;
			if (npp->p_size == 0) {
d539 1
a539 1
		if (npp->p_offset % secpercyl)
d541 2
a542 2
		spp->sdkp_cyloffset = npp->p_offset / secpercyl;
		spp->sdkp_nsectors = npp->p_size;
d554 2
a555 2
		if (lp->d_partitions[i+8].p_offset ||
		    lp->d_partitions[i+8].p_size)
d564 1
a564 1
			if (npp->p_offset % secpercyl)
d567 2
a568 2
			    npp->p_offset / secpercyl;
			sl->sl_xpart[i].sdkp_nsectors = npp->p_size;
@


1.26
log
@KNF, whitespace and comment rectification to make all
bounds_check_with_label() routines as identical as possible without
changing any code. Code nits and adjustments to come.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.25 2007/05/31 02:57:53 krw Exp $	*/
d188 1
a188 1
	cvtdisklabelv1(lp);
@


1.25
log
@Be consistant and use b_cylinder when saving the cylinder number for
disksort, not b_resid. b_cylinder is defined to be 'b_resid' so no
functional change.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.24 2007/05/31 00:30:10 deraadt Exp $	*/
d282 2
a283 5
bounds_check_with_label(bp, lp, osdep, wlabel)
	struct buf *bp;
	struct disklabel *lp;
	struct cpu_disklabel *osdep;
	int wlabel;
d309 1
a309 1
			/* If exactly at end of disk, return an EOF */
d318 1
a318 1
		/* Or truncate if part of it fits */
@


1.24
log
@extend the sun disklabel format to contain filesystem types.  also,
store the information fsck needs.  this allows us to create raid
partitions, nicely, of course.
ok miod todd krw
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.23 2007/05/29 06:56:30 deraadt Exp $	*/
d326 1
a326 1
	bp->b_resid = (bp->b_blkno + blockpersec(p->p_offset, lp)) /
@


1.23
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.22 2007/05/29 06:28:15 otto Exp $	*/
d424 1
d466 1
a466 1
	if (sl->sl_xpmag == SL_XPMAG &&
d488 7
d562 1
a562 1
		sl->sl_xpmag = SL_XPMAG;
d571 6
@


1.22
log
@Updated disklabel format to support larger disks and partitions. We
free room in struct partition by packing fragment size and
fragments/block more tighlty and use the resulting space to make
offset and size 48 bits.  For the disk part we use spare fields in
struct disklabel.  Kernel converts in-mem copy of the on-disk
label if needed, disklabel(8) writes new version.
We are careful to only change fields not used by bootloaders.
Conception of basic scheme by deraadt.
ok deraadt@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.21 2007/05/29 05:08:20 krw Exp $	*/
d483 1
a483 1
				    DISKLABELV1_FFS_FRAGBLOCK(2048, 8)
@


1.21
log
@Refactor readdisklabel() to ensure there is a single point of return, in
preparation for translating all disk labels visible to the kernel to
the soon to arrive V1 format.

ok otto@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.20 2006/10/04 03:23:01 krw Exp $	*/
d188 1
d449 2
a450 2
				npp->p_fsize = 2048;
				npp->p_frag = 8;
d482 2
a483 2
				npp->p_fsize = 2048;
				npp->p_frag = 8;
@


1.20
log
@More tidying up after bad144. Remove references in comments and
don't include dkbad.h when nothing in it is used. Missed
arm/include/disklabel.h first time around.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.19 2006/08/17 10:34:14 krw Exp $	*/
d81 1
a81 1
	struct buf *bp;
d84 1
d92 4
a95 2
	if (lp->d_secpercyl == 0)
		return ("invalid geometry");
d109 1
a109 1
		return (NULL);
d114 4
a117 2
		if (iso_disklabelspoof(dev, strat, lp) == 0)
			return (NULL);
d120 4
a123 2
		if (udf_disklabelspoof(dev, strat, lp) == 0)
			return (NULL);
d145 4
a148 4
	bp->b_flags = B_INVAL | B_AGE | B_READ;
	brelse(bp);
	if (error)
		return ("disk label read error");
d151 4
a154 2
	if (slp->sl_magic == SUN_DKMAGIC)
		return (disklabel_sun_to_bsd(clp->cd_block, lp));
d159 4
a162 2
		if (dkcksum(dlp))
			return ("disk label corrupted");
d164 2
a165 1
		return (NULL);
d169 4
a172 2
	if (iso_disklabelspoof(dev, strat, lp) == NULL)
		return (NULL);
d175 4
a178 2
	if (udf_disklabelspoof(dev, strat, lp) == 0)
		return (NULL);
d181 8
a188 1
	return ("no disk label");
@


1.19
log
@Check d_secpercyl in all readdisklable() functions, and have all of
them return 'invalid geometry' when d_secpercyl == 0. While there move
the check to a consistant location (after the check of d_secperunit)
and use a consistant idiom (i.e. some readdisklabel()'s have no 'done'
label).

prodded by thib@@ after a bad macppc experience. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.18 2006/08/11 21:32:40 krw Exp $	*/
a38 1
#include <sys/dkbad.h>
@


1.18
log
@Use d_secperunit rather than 0x1fffffff as the default value for
RAW_PART's p_size. Since d_secperunit is initialized to 0x1fffffff if
not specified there should be no need to use the magic number again.
And if d_secperunit was specified then that value should be used
instead of the magic number.

This was already being done for hp300, luna88k, mac68k, mvme68k,
mvme88k.

Should be a no-op.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.17 2006/03/15 20:20:41 miod Exp $	*/
d92 2
@


1.17
log
@Nuke dk_establish(), no longer used.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.16 2006/03/04 19:33:21 miod Exp $	*/
d98 1
a98 1
		lp->d_partitions[i].p_size = 0x1fffffff;
@


1.16
log
@Typos grab bag of the month, eyeballed by jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.15 2005/12/22 02:51:25 krw Exp $	*/
a56 6

void
dk_establish(struct disk *dk, struct device *dev)
{
	/* fix later */
}
@


1.15
log
@Set correct partition offset to 0 when initializing RAW_PART.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.14 2005/09/21 21:08:35 miod Exp $	*/
d93 1
a93 1
	/* minimal requirements for archtypal disk label */
@


1.14
log
@isbad() is only used on SMD disks on sparc; remove it on other platforms.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.13 2005/03/30 07:52:32 deraadt Exp $	*/
d105 1
a105 1
	lp->d_partitions[0].p_offset = 0;
@


1.13
log
@first approximation:  spoof UDF filesystem disklabels when we see them.
it is likely a slight bug or two will sneak in with this, so everyone
please keep an eye out on your disklabels
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.12 2004/03/17 14:16:04 miod Exp $	*/
a563 25
}

/*
 * Search the bad sector table looking for the specified sector.
 * Return index if found.
 * Return -1 if not found.
 */
int
isbad(bt, cyl, trk, sec)
	struct dkbad *bt;
	int cyl, trk, sec;
{
	int i;
	long blk, bblk;

	blk = ((long)cyl << 16) + (trk << 8) + sec;
	for (i = 0; i < 126; i++) {
		bblk = ((long)bt->bt_bad[i].bt_cyl << 16) +
			bt->bt_bad[i].bt_trksec;
		if (blk == bblk)
			return (i);
		if (blk < bblk || bblk < 0)
			break;
	}
	return (-1);
@


1.12
log
@Make sure disklabels use at least DEV_BSIZE as their sector size.
This allows the kernel to survive reading the disklabel off a 256-bytes/sector
scsi device...

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.11 2003/07/16 18:06:35 tedu Exp $	*/
d113 9
a121 4
#if defined(CD9660) && (NCD > 0)
	if ((strat == cdstrategy) &&
	    (iso_disklabelspoof(dev, strat, lp) == NULL))
		return (NULL);
d123 2
d163 4
@


1.11
log
@sun disklabels need updating too.  frag size -> 2048.
pointed out by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.10 2003/06/04 21:47:59 deraadt Exp $	*/
d94 2
@


1.10
log
@mop up some more 3/4 license issues
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.9 2002/06/15 17:23:31 art Exp $	*/
d417 1
a417 1
				npp->p_fsize = 1024;
d450 1
a450 1
				npp->p_fsize = 1024;
@


1.9
log
@Decruftification.

We will never have a.out kernels.
We will never have 32-bit kernels.
We will never have sun4c, sun4 and sun4m support in the sparc64 kernels.
We don't need support old netbsd libc.
The cpu will never be identified as some of the sun4c and sun4m types.
We don't need the gazillion of fields in cpuinfo that the sparc port uses.
Just generally remove dead code.

This is just a first step in making this meess readable.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.8 2002/03/14 01:26:45 millert Exp $	*/
d17 1
a17 4
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Theo de Raadt.
 * 4. The name of the author may not be used to endorse or promote products
@


1.8
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.7 2002/02/19 02:50:59 deraadt Exp $	*/
a50 3
#if defined(SUN4)
#include <machine/oldmon.h>
#endif
@


1.7
log
@stategy is not an english word
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.6 2001/10/15 04:03:45 jason Exp $	*/
d58 3
a60 3
static	char *disklabel_sun_to_bsd __P((char *, struct disklabel *));
static	int disklabel_bsd_to_sun __P((struct disklabel *, char *));
static __inline u_int sun_extended_sum __P((struct sun_disklabel *));
d71 1
a71 1
extern void cdstrategy __P((struct buf *));
d89 1
a89 1
	void (*strat) __P((struct buf *));
d216 1
a216 1
	void (*strat) __P((struct buf *));
@


1.6
log
@Make the test for iso9660 filesystems preferred if the device is a CD,
and use old behavior otherwise (check for sun label, then native label,
then iso label).
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.5 2001/10/12 20:32:11 jason Exp $	*/
d76 1
a76 1
 * using the indicated stategy routine.
@


1.6.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.6 2001/10/15 04:03:45 jason Exp $	*/
d58 3
a60 3
static	char *disklabel_sun_to_bsd(char *, struct disklabel *);
static	int disklabel_bsd_to_sun(struct disklabel *, char *);
static __inline u_int sun_extended_sum(struct sun_disklabel *);
d71 1
a71 1
extern void cdstrategy(struct buf *);
d76 1
a76 1
 * using the indicated strategy routine.
d89 1
a89 1
	void (*strat)(struct buf *);
d216 1
a216 1
	void (*strat)(struct buf *);
@


1.6.6.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.6.6.1 2002/06/11 03:38:43 art Exp $	*/
d51 3
@


1.6.4.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.6.4.2
log
@Merge in trunk
@
text
@d76 1
a76 1
 * using the indicated strategy routine.
@


1.6.4.3
log
@Merge in -current from about a week ago
@
text
@d58 3
a60 3
static	char *disklabel_sun_to_bsd(char *, struct disklabel *);
static	int disklabel_bsd_to_sun(struct disklabel *, char *);
static __inline u_int sun_extended_sum(struct sun_disklabel *);
d71 1
a71 1
extern void cdstrategy(struct buf *);
d89 1
a89 1
	void (*strat)(struct buf *);
d216 1
a216 1
	void (*strat)(struct buf *);
@


1.6.4.4
log
@Sync the SMP branch with 3.3
@
text
@d51 3
@


1.6.4.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.6.4.4 2003/03/27 23:42:37 niklas Exp $	*/
d17 4
a20 1
 * 3. The name of the author may not be used to endorse or promote products
@


1.6.4.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d417 1
a417 1
				npp->p_fsize = 2048;
d450 1
a450 1
				npp->p_fsize = 2048;
@


1.6.4.7
log
@Merge with the trunk
@
text
@a93 2
	if (lp->d_secsize < DEV_BSIZE)
		lp->d_secsize = DEV_BSIZE;
@


1.5
log
@Move the iso_disklabelspoof() call higher so that if one is present we
prefer it to the sun/native label.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.4 2001/09/18 21:04:33 jason Exp $	*/
d56 1
d70 4
d117 3
a119 2
#if defined(CD9660)
	if (iso_disklabelspoof(dev, strat, lp) == 0)
d158 4
@


1.4
log
@bring sparc64 OUT of the stone age... MAXPARTITIONS 16
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.3 2001/08/20 20:23:53 jason Exp $	*/
d112 5
a151 4
#if defined(CD9660)
	if (iso_disklabelspoof(dev, strat, lp) == 0)
		return (NULL);
#endif
@


1.3
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d59 1
d92 1
a92 1
	int error;
d97 4
a100 5
	if (lp->d_npartitions == 0) {
		lp->d_npartitions = RAW_PART + 1;
		if (lp->d_partitions[RAW_PART].p_size == 0)
			lp->d_partitions[RAW_PART].p_size = 0x1fffffff;
		lp->d_partitions[RAW_PART].p_offset = 0;
d102 5
d108 1
d120 1
a120 1
	bp->b_flags |= B_READ;
d129 1
d134 5
a138 1
	/* Check for a NetBSD disk label. */
d142 2
a143 2
			return ("NetBSD disk label corrupted");
		*lp = *dlp;
d147 4
a150 6
	/* Check for a Sun disk label (for PROM compatibility). */
	slp = (struct sun_disklabel *) clp->cd_block;
	if (slp->sl_magic == SUN_DKMAGIC)
		return (disklabel_sun_to_bsd(clp->cd_block, lp));


a210 2
	struct disklabel *dlp;
	struct sun_disklabel *slp;
d212 1
a212 5
	/*
	 * Embed native label in a piece of wasteland.
	 */
	if (sizeof(struct disklabel) > sizeof slp->sl_bsdlabel)
		return EFBIG;
d214 7
a220 9
	slp = (struct sun_disklabel *)clp->cd_block;
	bzero(slp->sl_bsdlabel, sizeof(slp->sl_bsdlabel));
	dlp = (struct disklabel *)slp->sl_bsdlabel;
	*dlp = *lp;

	/* Build a SunOS compatible label around the native label */
	error = disklabel_bsd_to_sun(lp, clp->cd_block);
	if (error)
		return (error);
d251 1
d253 1
a253 2
	int maxsz = p->p_size;
	int sz = (bp->b_bcount + DEV_BSIZE - 1) >> DEV_BSHIFT;
d255 12
a266 7
	/*
	 * overwriting disk label ?
	 * The label is always in sector LABELSECTOR.
	 * XXX should also protect bootstrap in first 8K
	 */
	if (bp->b_blkno + p->p_offset <= LABELSECTOR &&
	    (bp->b_flags & B_READ) == 0 && wlabel == 0) {
d272 4
a275 3
	if (bp->b_blkno < 0 || bp->b_blkno + sz > maxsz) {
		/* if exactly at end of disk, return an EOF */
		if (bp->b_blkno == maxsz) {
d277 1
a277 1
			return(0);
d279 2
a280 3
		/* or truncate if part of it fits */
		sz = maxsz - bp->b_blkno;
		if (sz <= 0) {
d284 1
d289 3
a291 2
	bp->b_resid = (bp->b_blkno + p->p_offset) / lp->d_secpercyl;
	return(1);
d294 1
a294 1
	return(-1);
d306 1
a306 1
sun_fstypes[8] = {
d309 1
a309 1
	FS_OTHER,	/* c - whole disk */
d315 8
d326 21
d393 1
a393 1
	lp->d_npartitions = 8;
d419 33
d474 2
a475 1
	if (lp->d_secsize != 512)
d480 1
a480 3
	/*
	 * Format conversion.
	 */
a495 6
		/*
		 * SunOS partitions must start on a cylinder boundary.
		 * Note this restriction is forced upon NetBSD/sparc
		 * labels too, since we want to keep both labels
		 * synchronised.
		 */
d503 35
a537 1
	/* Compute the XOR check. */
@


1.2
log
@dk_establish
@
text
@d1 1
@


1.1
log
@compiles
@
text
@d61 6
@

