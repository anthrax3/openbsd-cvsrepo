head	1.2;
access;
symbols
	OPENBSD_6_2:1.2.0.52
	OPENBSD_6_2_BASE:1.2
	OPENBSD_6_1:1.2.0.50
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.2.0.46
	OPENBSD_6_0_BASE:1.2
	OPENBSD_5_9:1.2.0.42
	OPENBSD_5_9_BASE:1.2
	OPENBSD_5_8:1.2.0.44
	OPENBSD_5_8_BASE:1.2
	OPENBSD_5_7:1.2.0.36
	OPENBSD_5_7_BASE:1.2
	OPENBSD_5_6:1.2.0.40
	OPENBSD_5_6_BASE:1.2
	OPENBSD_5_5:1.2.0.38
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.2.0.34
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.32
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.30
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.28
	OPENBSD_5_0:1.2.0.26
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.24
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.22
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.2.0.18
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.20
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.16
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.2.0.14
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3:1.2.0.12
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_2:1.2.0.10
	OPENBSD_4_2_BASE:1.2
	OPENBSD_4_1:1.2.0.8
	OPENBSD_4_1_BASE:1.2
	OPENBSD_4_0:1.2.0.6
	OPENBSD_4_0_BASE:1.2
	OPENBSD_3_9:1.2.0.4
	OPENBSD_3_9_BASE:1.2
	OPENBSD_3_8:1.2.0.2
	OPENBSD_3_8_BASE:1.2
	OPENBSD_3_7:1.1.0.20
	OPENBSD_3_7_BASE:1.1
	OPENBSD_3_6:1.1.0.18
	OPENBSD_3_6_BASE:1.1
	SMP_SYNC_A:1.1
	SMP_SYNC_B:1.1
	OPENBSD_3_5:1.1.0.16
	OPENBSD_3_5_BASE:1.1
	OPENBSD_3_4:1.1.0.14
	OPENBSD_3_4_BASE:1.1
	UBC_SYNC_A:1.1
	OPENBSD_3_3:1.1.0.12
	OPENBSD_3_3_BASE:1.1
	OPENBSD_3_2:1.1.0.10
	OPENBSD_3_2_BASE:1.1
	OPENBSD_3_1:1.1.0.8
	OPENBSD_3_1_BASE:1.1
	UBC_SYNC_B:1.1
	UBC:1.1.0.6
	UBC_BASE:1.1
	SMP:1.1.0.4
	OPENBSD_3_0:1.1.0.2
	OPENBSD_3_0_BASE:1.1;
locks; strict;
comment	@# @;


1.2
date	2005.05.01.05.42.43;	author brad;	state Exp;
branches;
next	1.1;

1.1
date	2001.08.19.05.21.38;	author jason;	state Exp;
branches
	1.1.4.1;
next	;

1.1.4.1
date	2001.10.31.03.07.59;	author nate;	state Exp;
branches;
next	;


desc
@@


1.2
log
@RCS id
@
text
@/*	$OpenBSD$	*/
/*	$NetBSD: in_cksum.S,v 1.2 2001/08/10 20:53:11 eeh Exp $ */

/*
 * Copyright (c) 2001 Eduardo Horvath
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Eduardo Horvath.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include "assym.h"
#include <machine/asm.h>

/*
 * int in_cksum(struct mbuf *m, int len)
 * int in_cksum_internal(struct mbuf *m, int len, int offset, int sum)
 *
 * The only fields of the mbuf we really care about
 * is m_next and m_len and m_data.
 *
 *
 * Register usage:
 *
 *	%o0 -	mbuf
 *	%o1 -	len
 *	%o2 -	mlen
 *	%o3 -	sum
 *	%o4 -	temp
 *	%o5 -	mdata
 *	%g1 -	swapped
 *	%g4 -	temp
 *	%g5 -	temp
 */

#define	IALIGN	.align	32
	
ENTRY(in_cksum)
	clr	%o3		! sum = 0;
	clr	%o2
_ENTRY(_C_LABEL(in_cksum_internal))
	brz	%o0, Lfinish	! for (; m && len > 0; m->m_next) {
	 clr	%g1		! swapped = 0;
	brlez	%o1, Lfinish
	 mov	%o2, %o4	! Stash this elsewhere for a bit

	lduw	[%o0 + M_LEN], %o2	! Code duplicated at Lloop
	srlx	%o3, 32, %g4	! REDUCE bigtime
	sethi	%hi(0xffff), %g5
	ldx	[%o0 + M_DATA], %o5
	srl	%o3, 0, %o3
	or	%g5, %lo(0xffff), %g5
	
	sub	%o2, %o4, %o2	! Correct for initial offset
	ba,pt	%icc, 0f
	 add	%o5, %o4, %o5
	
	IALIGN
Lloop:			
	lduw	[%o0 + M_LEN], %o2
	srlx	%o3, 32, %g4	! REDUCE bigtime
	sethi	%hi(0xffff), %g5
	ldx	[%o0 + M_DATA], %o5
	srl	%o3, 0, %o3
	or	%g5, %lo(0xffff), %g5
0:	
	add	%o3, %g4, %o3
	brz	%o2, Lnext	! if (m->m_len == 0) continue;
	
	 cmp	%o1, %o2	! if (len < mlen)
	movl	%icc, %o1, %o2	!	mlen = len;

	btst	3, %o5		! if (!(*w & 3)) {
	bz	Lint_aligned
	 sub	%o1, %o2, %o1	! len -= mlen

	srlx	%o3, 16, %o4	! REDUCE {sum = (sum & 0xffff) + (sum >> 16);}
	and	%o3, %g5, %o3
	
	add	%o3, %o4, %o3
	btst	1, %o5		! if (!(*w & 3) &&
	bz	Lshort_aligned
	 nop
	
	deccc	%o2
	bl,a,pn	%icc, Lnext	! mlen >= 1) {
	 inc	%o2
	ldub	[%o5], %o4	! ADDBYTE {ROL; sum += *w; byte_swapped ^= 1;}
	sllx	%o3, 8, %o3	! ROL { sum = sum << 8; }
	inc	%o5		! }
	add	%o3, %o4, %o3
	xor	%g1, 1, %g1	! Flip byte_swapped
	
Lshort_aligned:
	btst	2, %o5		! if (!(*w & 3) &&
	bz	Lint_aligned
	 nop
	
	deccc	2, %o2		! mlen >= 1) {
	bl,a,pn	%icc, Lfinish_byte
	 inc	2, %o2
	lduh	[%o5], %o4	! ADDSHORT {sum += *(u_short *)w;}
	inc	2, %o5		! }
	add	%o3, %o4, %o3	! }
Lint_aligned:
	deccc	0xc, %o2	! while (mlen >= 12) {
	ble,pn	%icc, Ltoofar
	 clr	%g5
	ba,pt	%icc, 0f
	 clr	%g4
	IALIGN
0:	
	lduw	[%o5 + 0x00], %o4
	add	%o3, %g4, %o3
	deccc	0xc, %o2
	lduw	[%o5 + 0x04], %g4
	add	%o3, %g5, %o3
	lduw	[%o5 + 0x08], %g5
	inc	0xc, %o5	! ADVANCE(12) }
	bg,pt	%icc, 0b	
	 add	%o3, %o4, %o3
	add	%o3, %g4, %o3
	add	%o3, %g5, %o3
Ltoofar:
	inc	0xc, %o2
	
Ldo_int:
	deccc	4, %o2
	bl,pn	%icc, Lfinish_short
	 nop
0:	
	lduw	[%o5], %o4
	inc	4, %o5
	deccc	4, %o2
	bge,pt	%icc, 0b
	 add	%o3, %o4, %o3

Lfinish_short:	
	btst	2, %o2
	bz	Lfinish_byte
	 nop
	lduh	[%o5], %o4
	inc	2, %o5
	add	%o3, %o4, %o3

Lfinish_byte:	
	btst	1, %o2
	bz	Lnext
	 nop
	ldub	[%o5], %o4
	sllx	%o3, 8, %o3	! ROL { sum = sum << 8; }
	inc	%o5
	xor	%g1, 1, %g1	! Flip byte_swapped
	add	%o3, %o4, %o3
	
Lnext:
	ldx	[%o0 + M_NEXT], %o0
Lfinish:
	srlx	%o3, 32, %o4	! Reduce to 32-bits
	srl	%o3, 0, %o3
	brz,pt	%o0, 1f		! In general there is only one mbuf
	 add	%o3, %o4, %o3
	brgz,pt	%o1, Lloop	! But usually all need to be fully checksummed
	 nop
1:	
	sethi	%hi(0x0000ffff), %o5	! data ptr not needed any more
	
	srlx	%o3, 16, %o4
	or	%o5, %lo(0x0000ffff), %o5
	
	and	%o3, %o5, %o3
	
	add	%o3, %o4, %o3
	brz,pt	%g1, 0f		! if (byte_swapped) {
	 nop

	sllx	%o3, 8, %o3	! ROL

	srlx	%o3, 16, %o4	! REDUCE
	and	%o3, %o5, %o3
	
	add	%o3, %o4, %o3
0:	
	subcc	%o3, %o5, %o4	! if (sum > 0xffff)
	movg	%icc, %o4, %o3	! sum -= 0xffff;

	clr	%g4		! In case we are using EMBEDANY (ick)
	retl
	 xor	%o3, %o5, %o0	! return (0xffff ^ sum);
@


1.1
log
@Lot of stuff... Some from NetBSD, some from OpenBSD, minor modifications
@
text
@d1 1
@


1.1.4.1
log
@Sync the SMP branch to something just after 3.0
@
text
@@

