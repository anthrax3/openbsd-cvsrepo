head	1.66;
access;
symbols
	OPENBSD_6_1:1.65.0.6
	OPENBSD_6_1_BASE:1.65
	OPENBSD_6_0:1.65.0.2
	OPENBSD_6_0_BASE:1.65
	OPENBSD_5_9:1.63.0.4
	OPENBSD_5_9_BASE:1.63
	OPENBSD_5_8:1.63.0.6
	OPENBSD_5_8_BASE:1.63
	OPENBSD_5_7:1.63.0.2
	OPENBSD_5_7_BASE:1.63
	OPENBSD_5_6:1.62.0.4
	OPENBSD_5_6_BASE:1.62
	OPENBSD_5_5:1.61.0.4
	OPENBSD_5_5_BASE:1.61
	OPENBSD_5_4:1.60.0.2
	OPENBSD_5_4_BASE:1.60
	OPENBSD_5_3:1.59.0.2
	OPENBSD_5_3_BASE:1.59
	OPENBSD_5_2:1.56.0.8
	OPENBSD_5_2_BASE:1.56
	OPENBSD_5_1_BASE:1.56
	OPENBSD_5_1:1.56.0.6
	OPENBSD_5_0:1.56.0.4
	OPENBSD_5_0_BASE:1.56
	OPENBSD_4_9:1.56.0.2
	OPENBSD_4_9_BASE:1.56
	OPENBSD_4_8:1.55.0.2
	OPENBSD_4_8_BASE:1.55
	OPENBSD_4_7:1.54.0.2
	OPENBSD_4_7_BASE:1.54
	OPENBSD_4_6:1.52.0.4
	OPENBSD_4_6_BASE:1.52
	OPENBSD_4_5:1.51.0.2
	OPENBSD_4_5_BASE:1.51
	OPENBSD_4_4:1.45.0.2
	OPENBSD_4_4_BASE:1.45
	OPENBSD_4_3:1.33.0.2
	OPENBSD_4_3_BASE:1.33
	OPENBSD_4_2:1.20.0.2
	OPENBSD_4_2_BASE:1.20
	OPENBSD_4_1:1.18.0.2
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.14.0.6
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.14.0.4
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.14.0.2
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.13.0.8
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.13.0.6
	OPENBSD_3_6_BASE:1.13
	SMP_SYNC_A:1.13
	SMP_SYNC_B:1.13
	OPENBSD_3_5:1.13.0.4
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.13.0.2
	OPENBSD_3_4_BASE:1.13
	UBC_SYNC_A:1.13
	OPENBSD_3_3:1.11.0.2
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.9.0.2
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	UBC_SYNC_B:1.9
	UBC:1.5.0.2
	UBC_BASE:1.5
	SMP:1.3.0.4
	OPENBSD_3_0:1.3.0.2
	OPENBSD_3_0_BASE:1.3;
locks; strict;
comment	@ * @;


1.66
date	2017.05.25.03.19.39;	author dlg;	state Exp;
branches;
next	1.65;
commitid	gx8rjMxrMcqYnydg;

1.65
date	2016.05.03.08.30.15;	author kettenis;	state Exp;
branches;
next	1.64;
commitid	MZpYt2QjcBZtOFba;

1.64
date	2016.04.29.16.49.53;	author mpi;	state Exp;
branches;
next	1.63;
commitid	kLGRoBzBa5Gai7Fe;

1.63
date	2014.11.16.12.30.59;	author deraadt;	state Exp;
branches;
next	1.62;
commitid	yv0ECmCdICvq576h;

1.62
date	2014.03.29.18.09.30;	author guenther;	state Exp;
branches;
next	1.61;

1.61
date	2014.01.19.12.45.36;	author deraadt;	state Exp;
branches;
next	1.60;

1.60
date	2013.06.03.16.55.22;	author guenther;	state Exp;
branches;
next	1.59;

1.59
date	2012.12.04.21.00.21;	author kettenis;	state Exp;
branches;
next	1.58;

1.58
date	2012.11.07.16.31.03;	author kettenis;	state Exp;
branches;
next	1.57;

1.57
date	2012.09.08.20.58.50;	author kettenis;	state Exp;
branches;
next	1.56;

1.56
date	2011.01.13.22.55.33;	author matthieu;	state Exp;
branches;
next	1.55;

1.55
date	2010.04.20.23.27.00;	author deraadt;	state Exp;
branches;
next	1.54;

1.54
date	2010.02.12.01.35.14;	author tedu;	state Exp;
branches;
next	1.53;

1.53
date	2009.10.26.20.17.25;	author deraadt;	state Exp;
branches;
next	1.52;

1.52
date	2009.04.13.08.31.36;	author kettenis;	state Exp;
branches;
next	1.51;

1.51
date	2008.11.22.18.12.32;	author art;	state Exp;
branches;
next	1.50;

1.50
date	2008.10.15.23.23.50;	author deraadt;	state Exp;
branches;
next	1.49;

1.49
date	2008.08.17.15.55.55;	author kettenis;	state Exp;
branches;
next	1.48;

1.48
date	2008.08.11.19.53.33;	author kettenis;	state Exp;
branches;
next	1.47;

1.47
date	2008.08.11.18.20.37;	author kettenis;	state Exp;
branches;
next	1.46;

1.46
date	2008.08.07.21.25.47;	author kettenis;	state Exp;
branches;
next	1.45;

1.45
date	2008.07.21.13.30.05;	author art;	state Exp;
branches;
next	1.44;

1.44
date	2008.07.12.14.26.07;	author kettenis;	state Exp;
branches;
next	1.43;

1.43
date	2008.07.12.07.37.25;	author kettenis;	state Exp;
branches;
next	1.42;

1.42
date	2008.07.11.14.23.53;	author kettenis;	state Exp;
branches;
next	1.41;

1.41
date	2008.07.11.05.20.19;	author kettenis;	state Exp;
branches;
next	1.40;

1.40
date	2008.06.08.02.21.34;	author kettenis;	state Exp;
branches;
next	1.39;

1.39
date	2008.05.24.20.02.20;	author kettenis;	state Exp;
branches;
next	1.38;

1.38
date	2008.05.21.19.23.15;	author kettenis;	state Exp;
branches;
next	1.37;

1.37
date	2008.03.24.11.49.25;	author kettenis;	state Exp;
branches;
next	1.36;

1.36
date	2008.03.23.23.46.21;	author kettenis;	state Exp;
branches;
next	1.35;

1.35
date	2008.03.16.22.22.15;	author kettenis;	state Exp;
branches;
next	1.34;

1.34
date	2008.03.15.22.05.51;	author kettenis;	state Exp;
branches;
next	1.33;

1.33
date	2007.12.21.12.15.36;	author kettenis;	state Exp;
branches;
next	1.32;

1.32
date	2007.11.28.19.07.48;	author kettenis;	state Exp;
branches;
next	1.31;

1.31
date	2007.11.16.23.27.28;	author kettenis;	state Exp;
branches;
next	1.30;

1.30
date	2007.11.10.00.22.29;	author kettenis;	state Exp;
branches;
next	1.29;

1.29
date	2007.11.09.16.13.52;	author kettenis;	state Exp;
branches;
next	1.28;

1.28
date	2007.10.28.12.34.05;	author kettenis;	state Exp;
branches;
next	1.27;

1.27
date	2007.10.21.21.00.38;	author kettenis;	state Exp;
branches;
next	1.26;

1.26
date	2007.10.19.14.36.01;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2007.10.18.20.44.47;	author kettenis;	state Exp;
branches;
next	1.24;

1.24
date	2007.10.17.21.23.28;	author kettenis;	state Exp;
branches;
next	1.23;

1.23
date	2007.09.09.12.57.40;	author kettenis;	state Exp;
branches;
next	1.22;

1.22
date	2007.09.08.17.13.17;	author kettenis;	state Exp;
branches;
next	1.21;

1.21
date	2007.09.04.20.36.52;	author kettenis;	state Exp;
branches;
next	1.20;

1.20
date	2007.05.02.18.46.07;	author kettenis;	state Exp;
branches;
next	1.19;

1.19
date	2007.03.15.21.24.23;	author kettenis;	state Exp;
branches;
next	1.18;

1.18
date	2007.01.07.18.13.41;	author kettenis;	state Exp;
branches;
next	1.17;

1.17
date	2007.01.07.16.54.46;	author kettenis;	state Exp;
branches;
next	1.16;

1.16
date	2006.12.29.00.14.28;	author kettenis;	state Exp;
branches;
next	1.15;

1.15
date	2006.12.23.12.28.11;	author kettenis;	state Exp;
branches;
next	1.14;

1.14
date	2005.08.06.14.26.52;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2003.05.11.22.09.31;	author jason;	state Exp;
branches;
next	1.12;

1.12
date	2003.05.07.22.33.25;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2003.02.12.06.33.00;	author jason;	state Exp;
branches;
next	1.10;

1.10
date	2003.02.10.10.47.58;	author jason;	state Exp;
branches;
next	1.9;

1.9
date	2002.06.15.17.23.31;	author art;	state Exp;
branches;
next	1.8;

1.8
date	2002.06.11.10.57.51;	author art;	state Exp;
branches;
next	1.7;

1.7
date	2002.03.14.01.26.45;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.01.04.22.07.44;	author jason;	state Exp;
branches;
next	1.5;

1.5
date	2001.12.04.23.22.42;	author art;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2001.11.06.19.53.16;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2001.09.19.20.50.57;	author mickey;	state Exp;
branches
	1.3.4.1;
next	1.2;

1.2
date	2001.08.20.20.23.53;	author jason;	state Exp;
branches;
next	1.1;

1.1
date	2001.08.19.05.21.38;	author jason;	state Exp;
branches;
next	;

1.3.4.1
date	2001.10.31.03.07.58;	author nate;	state Exp;
branches;
next	1.3.4.2;

1.3.4.2
date	2001.11.13.21.04.17;	author niklas;	state Exp;
branches;
next	1.3.4.3;

1.3.4.3
date	2002.03.06.02.04.47;	author niklas;	state Exp;
branches;
next	1.3.4.4;

1.3.4.4
date	2002.03.28.11.23.52;	author niklas;	state Exp;
branches;
next	1.3.4.5;

1.3.4.5
date	2003.03.27.23.42.37;	author niklas;	state Exp;
branches;
next	1.3.4.6;

1.3.4.6
date	2003.05.13.19.41.09;	author ho;	state Exp;
branches;
next	;

1.5.2.1
date	2002.01.31.22.55.24;	author niklas;	state Exp;
branches;
next	1.5.2.2;

1.5.2.2
date	2002.06.11.03.38.43;	author art;	state Exp;
branches;
next	1.5.2.3;

1.5.2.3
date	2002.10.29.00.28.12;	author art;	state Exp;
branches;
next	1.5.2.4;

1.5.2.4
date	2003.05.19.21.46.57;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.66
log
@tweak sparc64 membars as a step toward making them usable in userland.

specifically, dont rely on magic in ctlreg to implement membars. moving
that to atomic.h would add a lot of pollution to the namespace, so
move to passing the membar options to a single __membar macro.

this tweaks everything that was using the ctlreg backend to either use
an appropriate membar_foo(), or to use __membar() in the MD code.

ok kettenis@@
@
text
@/*	$OpenBSD: cpu.c,v 1.65 2016/05/03 08:30:15 kettenis Exp $	*/
/*	$NetBSD: cpu.c,v 1.13 2001/05/26 21:27:15 chs Exp $ */

/*
 * Copyright (c) 1996
 *	The President and Fellows of Harvard College. All rights reserved.
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
 *
 * All advertising materials mentioning features or use of this software
 * must display the following acknowledgement:
 *	This product includes software developed by Harvard University.
 *	This product includes software developed by the University of
 *	California, Lawrence Berkeley Laboratory.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Aaron Brown and
 *	Harvard University.
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)cpu.c	8.5 (Berkeley) 11/23/93
 *
 */

#include <sys/param.h>
#include <sys/device.h>
#include <sys/proc.h>
#include <sys/sysctl.h>
#include <sys/systm.h>
#include <dev/rndvar.h>

#include <uvm/uvm_extern.h>

#include <machine/autoconf.h>
#include <machine/cpu.h>
#include <machine/reg.h>
#include <machine/trap.h>
#include <machine/hypervisor.h>
#include <machine/openfirm.h>
#include <machine/pmap.h>
#include <machine/sparc64.h>

#include <sparc64/sparc64/cache.h>

#include <sparc64/dev/starfire.h>

/* This is declared here so that you must include a CPU for the cache code. */
struct cacheinfo cacheinfo = {
	us_dcache_flush_page
};

void (*cpu_start_clock)(void);

/* Linked list of all CPUs in system. */
struct cpu_info *cpus = NULL;

struct cpu_info *alloc_cpuinfo(struct mainbus_attach_args *);

/* The following are used externally (sysctl_hw). */
char	machine[] = MACHINE;		/* from <machine/param.h> */
char	cpu_model[100];

/* The CPU configuration driver. */
int cpu_match(struct device *, void *, void *);
void cpu_attach(struct device *, struct device *, void *);

struct cfattach cpu_ca = {
	sizeof(struct device), cpu_match, cpu_attach
};

void cpu_init(struct cpu_info *ci);
void cpu_hatch(void);

int sparc64_cpuspeed(int *);

int hummingbird_div(uint64_t);
uint64_t hummingbird_estar_mode(int);
void hummingbird_enable_self_refresh(void);
void hummingbird_disable_self_refresh(void);
void hummingbird_set_refresh_count(int, int);
void hummingbird_setperf(int);
void hummingbird_init(struct cpu_info *ci);

#define	IU_IMPL(v)	((((u_int64_t)(v))&VER_IMPL) >> VER_IMPL_SHIFT)
#define	IU_VERS(v)	((((u_int64_t)(v))&VER_MASK) >> VER_MASK_SHIFT)

struct cpu_info *
alloc_cpuinfo(struct mainbus_attach_args *ma)
{
	paddr_t pa0, pa;
	vaddr_t va, va0;
	vsize_t sz = 8 * PAGE_SIZE;
	int portid;
	struct cpu_info *cpi, *ci;
	extern paddr_t cpu0paddr;

	portid = getpropint(ma->ma_node, "upa-portid", -1);
	if (portid == -1)
		portid = getpropint(ma->ma_node, "portid", -1);
	if (portid == -1)
		portid = getpropint(ma->ma_node, "cpuid", -1);
	if (portid == -1 && ma->ma_nreg > 0)
		portid = (ma->ma_reg[0].ur_paddr >> 32) & 0x0fffffff;
	if (portid == -1)
		panic("alloc_cpuinfo: portid");

	for (cpi = cpus; cpi != NULL; cpi = cpi->ci_next)
		if (cpi->ci_upaid == portid)
			return cpi;

	va = uvm_km_valloc_align(kernel_map, sz, 8 * PAGE_SIZE, 0);
	if (va == 0)
		panic("alloc_cpuinfo: no virtual space");
	va0 = va;

	pa0 = cpu0paddr;
	cpu0paddr += sz;

	for (pa = pa0; pa < cpu0paddr; pa += PAGE_SIZE, va += PAGE_SIZE)
		pmap_kenter_pa(va, pa, PROT_READ | PROT_WRITE);

	pmap_update(pmap_kernel());

	cpi = (struct cpu_info *)(va0 + CPUINFO_VA - INTSTACK);

	memset((void *)va0, 0, sz);

	/*
	 * Initialize cpuinfo structure.
	 *
	 * Arrange pcb, idle stack and interrupt stack in the same
	 * way as is done for the boot CPU in pmap.c.
	 */
	cpi->ci_next = NULL;
	cpi->ci_curproc = NULL;
	cpi->ci_number = ncpus++;
	cpi->ci_upaid = portid;
	cpi->ci_fpproc = NULL;
#ifdef MULTIPROCESSOR
	cpi->ci_spinup = cpu_hatch;				/* XXX */
#else
	cpi->ci_spinup = NULL;
#endif

	cpi->ci_initstack = cpi;
	cpi->ci_paddr = pa0;
#ifdef SUN4V
	cpi->ci_mmfsa = pa0;
#endif
	cpi->ci_self = cpi;
	cpi->ci_node = ma->ma_node;

	sched_init_cpu(cpi);

	/*
	 * Finally, add itself to the list of active cpus.
	 */
	for (ci = cpus; ci->ci_next != NULL; ci = ci->ci_next)
		;
	ci->ci_next = cpi;
	return (cpi);
}

int
cpu_match(parent, vcf, aux)
	struct device *parent;
	void *vcf;
	void *aux;
{
	struct mainbus_attach_args *ma = aux;
#ifndef MULTIPROCESSOR
	int portid;
#endif
	char buf[32];

	if (OF_getprop(ma->ma_node, "device_type", buf, sizeof(buf)) <= 0 ||
	    strcmp(buf, "cpu") != 0)
		return (0);

#ifndef MULTIPROCESSOR
	/*
	 * On singleprocessor kernels, only match the CPU we're
	 * running on.
	 */
	portid = getpropint(ma->ma_node, "upa-portid", -1);
	if (portid == -1)
		portid = getpropint(ma->ma_node, "portid", -1);
	if (portid == -1)
		portid = getpropint(ma->ma_node, "cpuid", -1);
	if (portid == -1 && ma->ma_nreg > 0)
		portid = (ma->ma_reg[0].ur_paddr >> 32) & 0xff;
	if (portid == -1)
		return (0);

	if (portid != cpus->ci_upaid)
		return (0);
#endif

	return (1);
}

/*
 * Attach the CPU.
 * Discover interesting goop about the virtual address cache
 * (slightly funny place to do it, but this is where it is to be found).
 */
void
cpu_attach(parent, dev, aux)
	struct device *parent;
	struct device *dev;
	void *aux;
{
	int node;
	u_int clk;
	int impl, vers;
	struct mainbus_attach_args *ma = aux;
	struct cpu_info *ci;
	const char *sep;
	register int i, l;
	u_int64_t ver = 0;
	extern u_int64_t cpu_clockrate[];

	if (CPU_ISSUN4U || CPU_ISSUN4US)
		ver = getver();
	impl = IU_IMPL(ver);
	vers = IU_VERS(ver);

	/* tell them what we have */
	if (strcmp(parent->dv_cfdata->cf_driver->cd_name, "core") == 0)
		node = OF_parent(ma->ma_node);
	else
		node = ma->ma_node;

	/*
	 * Allocate cpu_info structure if needed.
	 */
	ci = alloc_cpuinfo(ma);
	ci->ci_node = ma->ma_node;

	clk = getpropint(node, "clock-frequency", 0);
	if (clk == 0) {
		/*
		 * Try to find it in the OpenPROM root...
		 */
		clk = getpropint(findroot(), "clock-frequency", 0);
	}
	if (clk) {
		cpu_clockrate[0] = clk; /* Tell OS what frequency we run on */
		cpu_clockrate[1] = clk/1000000;
	}
	snprintf(cpu_model, sizeof cpu_model, "%s (rev %d.%d) @@ %s MHz",
	    ma->ma_name, vers >> 4, vers & 0xf, clockfreq(clk));
	printf(": %s\n", cpu_model);

	cpu_cpuspeed = sparc64_cpuspeed;

	if (ci->ci_upaid == cpu_myid())
		cpu_init(ci);

	cacheinfo.c_physical = 1; /* Dunno... */
	cacheinfo.c_split = 1;
	l = getpropint(node, "icache-line-size", 0);
	if (l == 0)
		l = getpropint(node, "l1-icache-line-size", 0);
	cacheinfo.ic_linesize = l;
	for (i = 0; (1 << i) < l && l; i++)
		/* void */;
	if ((1 << i) != l && l)
		panic("bad icache line size %d", l);
	cacheinfo.ic_l2linesize = i;
	cacheinfo.ic_totalsize = getpropint(node, "icache-size", 0);
	if (cacheinfo.ic_totalsize == 0)
		cacheinfo.ic_totalsize = getpropint(node, "l1-icache-size", 0);
	if (cacheinfo.ic_totalsize == 0)
		cacheinfo.ic_totalsize = l *
		    getpropint(node, "icache-nlines", 64) *
		    getpropint(node, "icache-associativity", 1);

	l = getpropint(node, "dcache-line-size", 0);
	if (l == 0)
		l = getpropint(node, "l1-dcache-line-size", 0);
	cacheinfo.dc_linesize = l;
	for (i = 0; (1 << i) < l && l; i++)
		/* void */;
	if ((1 << i) != l && l)
		panic("bad dcache line size %d", l);
	cacheinfo.dc_l2linesize = i;
	cacheinfo.dc_totalsize = getpropint(node, "dcache-size", 0);
	if (cacheinfo.dc_totalsize == 0)
		cacheinfo.dc_totalsize = getpropint(node, "l1-dcache-size", 0);
	if (cacheinfo.dc_totalsize == 0)
		cacheinfo.dc_totalsize = l *
		    getpropint(node, "dcache-nlines", 128) *
		    getpropint(node, "dcache-associativity", 1);
	
	l = getpropint(node, "ecache-line-size", 0);
	if (l == 0)
		l = getpropint(node, "l2-cache-line-size", 0);
	cacheinfo.ec_linesize = l;
	for (i = 0; (1 << i) < l && l; i++)
		/* void */;
	if ((1 << i) != l && l)
		panic("bad ecache line size %d", l);
	cacheinfo.ec_l2linesize = i;
	cacheinfo.ec_totalsize = getpropint(node, "ecache-size", 0);
	if (cacheinfo.ec_totalsize == 0)
		cacheinfo.ec_totalsize = getpropint(node, "l2-cache-size", 0);
	if (cacheinfo.ec_totalsize == 0)
		cacheinfo.ec_totalsize = l *
		    getpropint(node, "ecache-nlines", 32768) *
		    getpropint(node, "ecache-associativity", 1);
	
	/*
	 * XXX - The following will have to do until
	 * we have per-cpu cache handling.
	 */
	cacheinfo.c_l2linesize =
		min(cacheinfo.ic_l2linesize,
		    cacheinfo.dc_l2linesize);
	cacheinfo.c_linesize =
		min(cacheinfo.ic_linesize,
		    cacheinfo.dc_linesize);
	cacheinfo.c_totalsize =
		cacheinfo.ic_totalsize +
		cacheinfo.dc_totalsize;

	if (cacheinfo.c_totalsize == 0)
		return;
	
	sep = " ";
	printf("%s: physical", dev->dv_xname);
	if (cacheinfo.ic_totalsize > 0) {
		printf("%s%ldK instruction (%ld b/l)", sep,
		       (long)cacheinfo.ic_totalsize/1024,
		       (long)cacheinfo.ic_linesize);
		sep = ", ";
	}
	if (cacheinfo.dc_totalsize > 0) {
		printf("%s%ldK data (%ld b/l)", sep,
		       (long)cacheinfo.dc_totalsize/1024,
		       (long)cacheinfo.dc_linesize);
		sep = ", ";
	}
	if (cacheinfo.ec_totalsize > 0) {
		printf("%s%ldK external (%ld b/l)", sep,
		       (long)cacheinfo.ec_totalsize/1024,
		       (long)cacheinfo.ec_linesize);
	}

#ifndef SMALL_KERNEL
	if (impl == IMPL_HUMMINGBIRD)
		hummingbird_init(ci);
#endif

	printf("\n");
	cache_enable();
}

int
cpu_myid(void)
{
	char buf[32];
	int impl;

#ifdef SUN4V
	if (CPU_ISSUN4V) {
		uint64_t myid;

		hv_cpu_myid(&myid);
		return myid;
	}
#endif

	if (OF_getprop(findroot(), "name", buf, sizeof(buf)) > 0 &&
	    strcmp(buf, "SUNW,Ultra-Enterprise-10000") == 0)
		return lduwa(0x1fff40000d0UL, ASI_PHYS_NON_CACHED);

	impl = (getver() & VER_IMPL) >> VER_IMPL_SHIFT;
	switch (impl) {
	case IMPL_OLYMPUS_C:
	case IMPL_JUPITER:
		return CPU_JUPITERID;
	case IMPL_CHEETAH:
	case IMPL_CHEETAH_PLUS:
	case IMPL_JAGUAR:
	case IMPL_PANTHER:
		return CPU_FIREPLANEID;
	default:
		return CPU_UPAID;
	}
}

void
cpu_init(struct cpu_info *ci)
{
#ifdef SUN4V
	paddr_t pa = ci->ci_paddr;
	int err;
#endif

	if (CPU_ISSUN4U || CPU_ISSUN4US) {
		tick_enable();
		return;
	}

#ifdef SUN4V
#define MONDO_QUEUE_SIZE	32
#define QUEUE_ENTRY_SIZE	64

	pa += CPUINFO_VA - INTSTACK;
	pa += PAGE_SIZE;

	ci->ci_cpumq = pa;
	err = hv_cpu_qconf(CPU_MONDO_QUEUE, ci->ci_cpumq, MONDO_QUEUE_SIZE);
	if (err != H_EOK)
		panic("Unable to set cpu mondo queue: %d", err);
	pa += MONDO_QUEUE_SIZE * QUEUE_ENTRY_SIZE;

	ci->ci_devmq = pa;
	err = hv_cpu_qconf(DEVICE_MONDO_QUEUE, ci->ci_devmq, MONDO_QUEUE_SIZE);
	if (err != H_EOK)
		panic("Unable to set device mondo queue: %d", err);
	pa += MONDO_QUEUE_SIZE * QUEUE_ENTRY_SIZE;

	ci->ci_mondo = pa;
	pa += 64;

	ci->ci_cpuset = pa;
	pa += 64;
#endif
}

struct cfdriver cpu_cd = {
	NULL, "cpu", DV_DULL
};

int
sparc64_cpuspeed(int *freq)
{
	extern u_int64_t cpu_clockrate[];

	*freq = cpu_clockrate[1];
	return (0);
}

#ifndef SMALL_KERNEL

/*
 * Hummingbird (UltraSPARC-IIe) has a clock control unit that enables
 * Energy Star mode.  This only works in combination with unbuffered
 * DIMMs so it is not supported on all machines with UltraSPARC-IIe
 * CPUs.
 */

/* Memory_Control_0 (MC0) register. */
#define HB_MC0			0x1fe0000f010ULL
#define  HB_MC0_SELF_REFRESH		0x00010000
#define  HB_MC0_REFRESH_COUNT_MASK	0x00007f00
#define  HB_MC0_REFRESH_COUNT_SHIFT	8
#define  HB_MC0_REFRESH_COUNT(reg) \
  (((reg) & HB_MC0_REFRESH_COUNT_MASK) >> HB_MC0_REFRESH_COUNT_SHIFT)
#define  HB_MC0_REFRESH_CLOCKS_PER_COUNT	64ULL
#define  HB_MC0_REFRESH_INTERVAL	7800ULL

/* Energy Star register. */
#define HB_ESTAR		0x1fe0000f080ULL
#define  HB_ESTAR_MODE_MASK		0x00000007
#define  HB_ESTAR_MODE_DIV_1		0x00000000
#define  HB_ESTAR_MODE_DIV_2		0x00000001
#define  HB_ESTAR_MODE_DIV_4		0x00000003
#define  HB_ESTAR_MODE_DIV_6		0x00000002
#define  HB_ESTAR_MODE_DIV_8		0x00000004
#define  HB_ESTAR_NUM_MODES		5

int hummingbird_divisors[HB_ESTAR_NUM_MODES];

int
hummingbird_div(uint64_t estar_mode)
{
	switch(estar_mode) {
	case HB_ESTAR_MODE_DIV_1:
		return 1;
	case HB_ESTAR_MODE_DIV_2:
		return 2;
	case HB_ESTAR_MODE_DIV_4:
		return 4;
	case HB_ESTAR_MODE_DIV_6:
		return 6;
	case HB_ESTAR_MODE_DIV_8:
		return 8;
	default:
		panic("bad E-Star mode");
	}
}

uint64_t
hummingbird_estar_mode(int div)
{
	switch(div) {
	case 1:
		return HB_ESTAR_MODE_DIV_1;
	case 2:
		return HB_ESTAR_MODE_DIV_2;
	case 4:
		return HB_ESTAR_MODE_DIV_4;
	case 6:
		return HB_ESTAR_MODE_DIV_6;
	case 8:
		return HB_ESTAR_MODE_DIV_8;
	default:
		panic("bad clock divisor");
	}
}

void
hummingbird_enable_self_refresh(void)
{
	uint64_t reg;

	reg = ldxa(HB_MC0, ASI_PHYS_NON_CACHED);
	reg |= HB_MC0_SELF_REFRESH;
	stxa(HB_MC0, ASI_PHYS_NON_CACHED, reg);
	reg = ldxa(HB_MC0, ASI_PHYS_NON_CACHED);
}

void
hummingbird_disable_self_refresh(void)
{
	uint64_t reg;

	reg = ldxa(HB_MC0, ASI_PHYS_NON_CACHED);
	reg &= ~HB_MC0_SELF_REFRESH;
	stxa(HB_MC0, ASI_PHYS_NON_CACHED, reg);
	reg = ldxa(HB_MC0, ASI_PHYS_NON_CACHED);
}

void
hummingbird_set_refresh_count(int div, int new_div)
{
	extern u_int64_t cpu_clockrate[];
	uint64_t count, new_count;
	uint64_t delta;
	uint64_t reg;

	reg = ldxa(HB_MC0, ASI_PHYS_NON_CACHED);
	count = HB_MC0_REFRESH_COUNT(reg);
	new_count = (HB_MC0_REFRESH_INTERVAL * cpu_clockrate[0]) /
		(HB_MC0_REFRESH_CLOCKS_PER_COUNT * new_div * 1000000000);
	reg &= ~HB_MC0_REFRESH_COUNT_MASK;
	reg |= (new_count << HB_MC0_REFRESH_COUNT_SHIFT);
	stxa(HB_MC0, ASI_PHYS_NON_CACHED, reg);
	reg = ldxa(HB_MC0, ASI_PHYS_NON_CACHED);

	if (new_div > div && (reg & HB_MC0_SELF_REFRESH) == 0) {
		delta = HB_MC0_REFRESH_CLOCKS_PER_COUNT * 
		    ((count + new_count) * 1000000UL * div) / cpu_clockrate[0];
		delay(delta + 1);
	}
}

void
hummingbird_setperf(int level)
{
	extern u_int64_t cpu_clockrate[];
	uint64_t estar_mode, new_estar_mode;
	uint64_t reg, s;
	int div, new_div, i;

	new_estar_mode = HB_ESTAR_MODE_DIV_1;
	for (i = 0; i < HB_ESTAR_NUM_MODES && hummingbird_divisors[i]; i++) {
		if (level <= 100 / hummingbird_divisors[i])
			new_estar_mode =
			    hummingbird_estar_mode(hummingbird_divisors[i]);
	}

	reg = ldxa(HB_ESTAR, ASI_PHYS_NON_CACHED);
	estar_mode = reg & HB_ESTAR_MODE_MASK;
	if (estar_mode == new_estar_mode)
		return;

	reg &= ~HB_ESTAR_MODE_MASK;
	div = hummingbird_div(estar_mode);
	new_div = hummingbird_div(new_estar_mode);

	s = intr_disable();
	if (estar_mode == HB_ESTAR_MODE_DIV_1 &&
	    new_estar_mode == HB_ESTAR_MODE_DIV_2) {
		hummingbird_set_refresh_count(1, 2);
		stxa(HB_ESTAR, ASI_PHYS_NON_CACHED, reg | HB_ESTAR_MODE_DIV_2);
		delay(1);
		hummingbird_enable_self_refresh();
	} else if (estar_mode == HB_ESTAR_MODE_DIV_2 &&
	    new_estar_mode == HB_ESTAR_MODE_DIV_1) {
		hummingbird_disable_self_refresh();
		stxa(HB_ESTAR, ASI_PHYS_NON_CACHED, reg | HB_ESTAR_MODE_DIV_1);
		delay(1);
		hummingbird_set_refresh_count(2, 1);
	} else if (estar_mode == HB_ESTAR_MODE_DIV_1) {
		/* 
		 * Transition to 1/2 speed first, then to
		 * lower speed.
		 */
		hummingbird_set_refresh_count(1, 2);
		stxa(HB_ESTAR, ASI_PHYS_NON_CACHED, reg | HB_ESTAR_MODE_DIV_2);
		delay(1);
		hummingbird_enable_self_refresh();

		hummingbird_set_refresh_count(2, new_div);
		stxa(HB_ESTAR, ASI_PHYS_NON_CACHED, reg | new_estar_mode);
		delay(1);
	} else if (new_estar_mode == HB_ESTAR_MODE_DIV_1) {
		/* 
		 * Transition to 1/2 speed first, then to
		 * full speed.
		 */
		stxa(HB_ESTAR, ASI_PHYS_NON_CACHED, reg | HB_ESTAR_MODE_DIV_2);
		delay(1);
		hummingbird_set_refresh_count(div, 2);

		hummingbird_disable_self_refresh();
		stxa(HB_ESTAR, ASI_PHYS_NON_CACHED, reg | HB_ESTAR_MODE_DIV_1);
		delay(1);
		hummingbird_set_refresh_count(2, 1);
	} else if (div < new_div) {
		hummingbird_set_refresh_count(div, new_div);
		stxa(HB_ESTAR, ASI_PHYS_NON_CACHED, reg | new_estar_mode);
		delay(1);
	} else if (div > new_div) {
		stxa(HB_ESTAR, ASI_PHYS_NON_CACHED, reg | new_estar_mode);
		delay(1);
		hummingbird_set_refresh_count(div, new_div);
	}
	cpu_clockrate[1] = cpu_clockrate[0] / (new_div * 1000000);
	intr_restore(s);
}

void
hummingbird_init(struct cpu_info *ci)
{
	/*
	 * The "clock-divisors" property seems to indicate which
	 * frequency scalings are supported on a particular model.
	 */
	if (OF_getprop(ci->ci_node, "clock-divisors",
	    &hummingbird_divisors, sizeof(hummingbird_divisors)) <= 0)
		return;

	cpu_setperf = hummingbird_setperf;
}
#endif

#ifdef MULTIPROCESSOR
void cpu_mp_startup(void);

void
cpu_boot_secondary_processors(void)
{
	struct cpu_info *ci;
	int cpuid, i;
	char buf[32];

	if (OF_getprop(findroot(), "name", buf, sizeof(buf)) > 0 &&
	    strcmp(buf, "SUNW,Ultra-Enterprise-10000") == 0) {
		for (ci = cpus; ci != NULL; ci = ci->ci_next)
			ci->ci_itid = STARFIRE_UPAID2HWMID(ci->ci_upaid);
	} else {
		for (ci = cpus; ci != NULL; ci = ci->ci_next)
			ci->ci_itid = ci->ci_upaid;
	}

	for (ci = cpus; ci != NULL; ci = ci->ci_next) {
		if (ci->ci_upaid == cpu_myid())
			continue;
		ci->ci_randseed = (arc4random() & 0x7fffffff) + 1;

		if (CPU_ISSUN4V)
			cpuid = ci->ci_upaid;
		else
			cpuid = getpropint(ci->ci_node, "cpuid", -1);

		if (OF_test("SUNW,start-cpu-by-cpuid") == 0) {
			prom_start_cpu_by_cpuid(cpuid,
			    (void *)cpu_mp_startup, ci->ci_paddr);
		} else {
			prom_start_cpu(ci->ci_node,
			    (void *)cpu_mp_startup, ci->ci_paddr);
		}

		for (i = 0; i < 2000; i++) {
			membar_sync();
			if (ci->ci_flags & CPUF_RUNNING)
				break;
			delay(10000);
		}
	}
}

void
cpu_hatch(void)
{
	struct cpu_info *ci = curcpu();
	int s;

	cpu_init(ci);

	ci->ci_flags |= CPUF_RUNNING;
	membar_sync();

	s = splhigh();
	nanouptime(&ci->ci_schedstate.spc_runtime);
	splx(s);

	cpu_start_clock();

	SCHED_LOCK(s);
	cpu_switchto(NULL, sched_chooseproc());
}
#endif

void
need_resched(struct cpu_info *ci)
{
	ci->ci_want_resched = 1;

	/* There's a risk we'll be called before the idle threads start */
	if (ci->ci_curproc) {
		aston(ci->ci_curproc);
		if (ci != curcpu())
			cpu_unidle(ci);
	}
}

/*
 * Idle loop.
 *
 * We disable and reenable the interrupts in every cycle of the idle loop.
 * Since hv_cpu_yield doesn't actually reenable interrupts, it just wakes
 * up if an interrupt would have happened, but it's our responsibility to
 * unblock interrupts.
 */

void
cpu_idle_enter(void)
{
	if (CPU_ISSUN4V) {
		sparc_wrpr(pstate, sparc_rdpr(pstate) & ~PSTATE_IE, 0);
	}
}

void
cpu_idle_cycle(void)
{
#ifdef SUN4V
	if (CPU_ISSUN4V) {
		hv_cpu_yield();
		sparc_wrpr(pstate, sparc_rdpr(pstate) | PSTATE_IE, 0);
		sparc_wrpr(pstate, sparc_rdpr(pstate) & ~PSTATE_IE, 0);
	}
#endif

	/*
	 * On processors with multiple threads we simply force a
	 * thread switch.  Using the sleep instruction seems to work
	 * just as well as using the suspend instruction and makes the
	 * code a little bit less complicated.
	 */
	__asm volatile(
		"999:	nop					\n"
		"	.section .sun4u_mtp_patch, \"ax\"	\n"
		"	.word	999b				\n"
		"	.word	0x81b01060	! sleep		\n"
		"	.previous				\n"
		: : : "memory");
}

void
cpu_idle_leave(void)
{
	if (CPU_ISSUN4V) {
		sparc_wrpr(pstate, sparc_rdpr(pstate) | PSTATE_IE, 0);
	}
}
@


1.65
log
@Revert previous commit.  Calling sched_init_cpu() from
cpu_boot_secondary_processors() break suspend/resume.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.64 2016/04/29 16:49:53 mpi Exp $	*/
d720 1
a720 1
			sparc_membar(Sync);
d737 1
a737 1
	sparc_membar(Sync);
@


1.64
log
@Call sched_init_cpu() just before booting secondary CPUs.

This prevent the scheduler from scheduling tasks to CPUs not beeing able
to execute them during the boot process.

ok visa@@, kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.63 2014/11/16 12:30:59 deraadt Exp $	*/
d183 2
a703 2

		sched_init_cpu(ci);
@


1.63
log
@Replace a plethora of historical protection options with just
PROT_NONE, PROT_READ, PROT_WRITE, and PROT_EXEC from mman.h.
PROT_MASK is introduced as the one true way of extracting those bits.
Remove UVM_ADV_* wrapper, using the standard names.
ok doug guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.62 2014/03/29 18:09:30 guenther Exp $	*/
a182 2
	sched_init_cpu(cpi);

d702 2
@


1.62
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.61 2014/01/19 12:45:36 deraadt Exp $	*/
d150 1
a150 1
		pmap_kenter_pa(va, pa, VM_PROT_READ | VM_PROT_WRITE);
@


1.61
log
@Initialize ci_randseed better using arc4random() + a trick.  Remove the
libkern srandom() API since it is not suitable for this use.
ok kettenis miod
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.60 2013/06/03 16:55:22 guenther Exp $	*/
d797 1
a797 1
	__asm __volatile(
@


1.60
log
@Convert some internal APIs to use timespecs instead of timevals

ok matthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.59 2012/12/04 21:00:21 kettenis Exp $	*/
d60 1
d704 1
a704 1
		ci->ci_randseed = random();
@


1.59
log
@Attach the 2nd core of SPARC64-VI and SPARC64-VII CPUs.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.58 2012/11/07 16:31:03 kettenis Exp $	*/
d739 1
a739 1
	microuptime(&ci->ci_schedstate.spc_runtime);
@


1.58
log
@Enable %tick access for userland on sun4u systems (sun4v systems already have
this enabled).

ok pirofti@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.57 2012/09/08 20:58:50 kettenis Exp $	*/
a224 6
		return (0);
#else
	/* XXX Only attach the first thread of a core for now. */
	if (OF_getprop(OF_parent(ma->ma_node), "device_type",
	    buf, sizeof(buf)) >= 0 && strcmp(buf, "core") == 0 &&
	    (getpropint(ma->ma_node, "cpuid", -1) % 2) == 1)
@


1.57
log
@On SPARC64 VI/VII CPUs, use the lseep instruction in the idle loop to force a
thread switch in the hope the other thread can do some useful work.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.56 2011/01/13 22:55:33 matthieu Exp $	*/
d434 1
d436 2
a437 1
	if (CPU_ISSUN4U || CPU_ISSUN4US)
d439 1
d441 1
@


1.56
log
@Fix link edition without 'option SUN4V'. ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.55 2010/04/20 23:27:00 deraadt Exp $	*/
d791 14
d808 1
a808 1
cpu_idle_leave()
@


1.55
log
@cleanup more confusion regarding user.h before proc.h, or missing proc.h
ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.54 2010/02/12 01:35:14 tedu Exp $	*/
d784 1
d790 1
@


1.54
log
@introduce a uvm_km_valloc_try function that won't get a lower level lock
for use by the uvm pseg code.  this is the path of least resistance until
we sort out how many of these functions we really need.  problem found by mikeb
ok kettenis oga
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.53 2009/10/26 20:17:25 deraadt Exp $	*/
d57 1
@


1.53
log
@Do not do strncmp comparisons on dv_xname because longer device names which
look similar could arrive in the future.  Instead, compare directly against
dv_cfdata->cf_driver->cd_name
Issue originally spotted by miod
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.52 2009/04/13 08:31:36 kettenis Exp $	*/
d139 1
a139 1
	va = uvm_km_valloc_align(kernel_map, sz, 8 * PAGE_SIZE);
@


1.52
log
@Explicitly test whether the SUNW,start-cpu-by-cpuid interface is available
instead of assuming it is.  Makes sure we actually spin up the secondary
CPUs on Serengeti machines with certain firmware revisions.

Tested by Christophe Latt.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.51 2008/11/22 18:12:32 art Exp $	*/
d263 1
a263 1
	if (strncmp(parent->dv_xname, "core", 4) == 0)
@


1.51
log
@The last parts of cpu_unidle. i386, amd64 and sparc64
In short, make cpu_unidle do what signotify used to do and
make signotify use cpu_unidle.
Also, include a cpu_unidle in need_resched, it won't change much right now
but will be needed in the future.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.50 2008/10/15 23:23:50 deraadt Exp $	*/
d711 2
a712 2
		if (cpuid == -1) {
			prom_start_cpu(ci->ci_node,
d715 1
a715 1
			prom_start_cpu_by_cpuid(cpuid,
@


1.50
log
@make random(9) return per-cpu values (by saving the seed in the cpuinfo),
which are uniform for the profclock on each cpu in a SMP system (but using
a different seed for each cpu).  on all cpus, avoid seeding with a value out
of the [0, 2^31-1] range (since that is not stable)
ok kettenis drahn
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.49 2008/08/17 15:55:55 kettenis Exp $	*/
d754 3
a756 1
	if (ci->ci_curproc != NULL)
d758 3
@


1.49
log
@Scale down cpu_clockrate[1] when we scale down the cpu clock frequency such
that delay(9) continues to do the right thing.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.48 2008/08/11 19:53:33 kettenis Exp $	*/
d704 1
@


1.48
log
@Add hw.cupspeed cupport for all CPU types.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.47 2008/08/11 18:20:37 kettenis Exp $	*/
a109 1
int hummingbird_cpuspeed(int *);
d594 1
d663 1
a666 13
int
hummingbird_cpuspeed(int *freq)
{
	extern u_int64_t cpu_clockrate[];
	uint64_t reg;
	int div;

	reg = ldxa(HB_ESTAR, ASI_PHYS_NON_CACHED);
	div = hummingbird_div(reg & HB_ESTAR_MODE_MASK);
	*freq = cpu_clockrate[1] / div;
	return (0);
}

a678 1
	cpu_cpuspeed = hummingbird_cpuspeed;	
@


1.47
log
@Add hw.setperf support for UltraSPARC-IIe support.

tested by miod@@, matthieu@@, naddy@@, jsg@@, djm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.46 2008/08/07 21:25:47 kettenis Exp $	*/
d102 2
d290 2
d467 9
@


1.46
log
@Use %sys_tick to generate clock interrupts on systems that have it.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.45 2008/07/21 13:30:05 art Exp $	*/
d56 2
a58 1
#include <sys/device.h>
d102 9
d271 1
d380 6
d463 218
@


1.45
log
@Implement the cpu_yield hypervisor call. Use it in the idle loop for
SUN4V to let it suspend strands (why does everyone invent own words for
hyperthreads?). This gives a huge performance boost when most of the
cpus are idle.

kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.44 2008/07/12 14:26:07 kettenis Exp $	*/
d79 2
d507 1
a507 1
	tick_start();
@


1.44
log
@Add a temporary hack to attach only the first thread of every core for
MULTIPROCESSOR kernels.  We map 'struct cpuinfo' at the same virtual
address on every processor, but since threads on the same core share
an MMU this doesn't quite work.  With the hack we are at least able to
use the other core (and any additional processors).
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.43 2008/07/12 07:37:25 kettenis Exp $	*/
d518 35
@


1.43
log
@Add macros to get the appropriate interrupt target ID for non-UPA CPUs and
use them in cpu_myid().
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.42 2008/07/11 14:23:53 kettenis Exp $	*/
d211 6
@


1.42
log
@Fujitsu SPARC64-VI CPU's have two cores that have two threads each.  Provide
a core(4) device, representing these cores and attach cpu(4) devices to it
for each thread.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.40 2008/06/08 02:21:34 kettenis Exp $	*/
d369 1
d383 12
a394 1
	else
d396 1
@


1.41
log
@Handle CPUs with a clock speed >= 2 GHz correctly.
@
text
@d244 4
a247 1
	node = ma->ma_node;
@


1.40
log
@Make UltraSPARC-IV work.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.39 2008/05/24 20:02:20 kettenis Exp $	*/
d229 1
a229 1
	long clk;
@


1.39
log
@Treat SPARC64-VI and SPARC64-VII similar to SPARC64-V, and move the
UltraSPARC-III fixup code into bootstrap() too.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.38 2008/05/21 19:23:15 kettenis Exp $	*/
d112 1
a112 1
	portid = getpropint(ma->ma_node, "portid", -1);
d114 3
a116 1
		portid = getpropint(ma->ma_node, "upa-portid", -1);
@


1.38
log
@First step towards supporting sun4us machines with Fujitsu's SPARC64-V CPU.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.37 2008/03/24 11:49:25 kettenis Exp $	*/
a357 19

	if (impl >= IMPL_CHEETAH) {
		extern vaddr_t ktext, dlflush_start;
		extern paddr_t ktextp;
		vaddr_t *pva;
		paddr_t pa;
		u_int32_t inst;

		for (pva = &dlflush_start; *pva; pva++) {
			inst = *(u_int32_t *)(*pva);
			inst &= ~(ASI_DCACHE_TAG << 5);
			inst |= (ASI_DCACHE_INVALIDATE << 5);
			pa = (paddr_t) (ktextp - ktext + *pva);
			stwa(pa, ASI_PHYS_CACHED, inst);
			flush((void *)KERNBASE);
		}

		cacheinfo.c_dcache_flush_page = us3_dcache_flush_page;
	}
@


1.37
log
@Use correct cpuid on sun4v.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.36 2008/03/23 23:46:21 kettenis Exp $	*/
d236 1
a236 1
	if (CPU_ISSUN4U)
d407 1
a407 1
	if (CPU_ISSUN4U)
@


1.36
log
@Add code to initialize CPUs on sun4v.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.35 2008/03/16 22:22:15 kettenis Exp $	*/
d463 6
a468 2
		cpuid = getpropint(ci->ci_node, "cpuid", -1);
		if (CPU_ISSUN4U && cpuid == -1) {
@


1.35
log
@Include <sparc64/dev/starfire.h> instead of having our own definitions.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.34 2008/03/15 22:05:51 kettenis Exp $	*/
d65 1
d82 1
a82 1
struct cpu_info *alloc_cpuinfo(int);
a87 2
void cpu_hatch(void);

d89 2
a90 2
static void cpu_attach(struct device *, struct device *, void *);
int  cpu_match(struct device *, void *, void *);
d96 2
a97 1
extern struct cfdriver cpu_cd;
d103 1
a103 1
alloc_cpuinfo(int node)
d112 1
a112 1
	portid = getpropint(node, "portid", -1);
d114 3
a116 1
		portid = getpropint(node, "upa-portid", -1);
d158 1
a158 1
	cpi->ci_initstack = (void *)EINTSTACK;
d160 3
d164 1
a164 1
	cpi->ci_node = node;
d203 2
d220 1
a220 1
static void
d233 1
a233 1
	u_int64_t ver;
d236 2
a237 1
	ver = getver();
d247 1
a247 1
	ci = alloc_cpuinfo(node);
d264 3
d384 9
d400 36
d464 1
a464 1
		if (cpuid == -1) {
d484 1
d487 3
a489 1
	curcpu()->ci_flags |= CPUF_RUNNING;
d493 1
a493 1
	microuptime(&curcpu()->ci_schedstate.spc_runtime);
@


1.34
log
@Make GENERIC.MP work on the e10k.  The e10k is a bit funky since UPA only
supports 32 ports, and a machine with up to 64 CPUs obviously needs more.
So the machine has a special ASIC that does port translation, and because
of that we need to distinguish between port ID's and interrupt target ID's.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.33 2007/12/21 12:15:36 kettenis Exp $	*/
d71 2
a385 3

#define STARFIRE_UPAID2HWMID(upaid) \
    (((upaid & 0x3c) << 1) | ((upaid & 0x40) >> 4) | (upaid & 0x3))
@


1.33
log
@Don't use getpropstring to get the CPU model name; it's evil.  Instead, rely on
the name passed in struct mainbus_attach_args.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.32 2007/11/28 19:07:48 kettenis Exp $	*/
d366 12
d385 3
d393 10
d405 1
a405 1
		if (ci->ci_upaid == CPU_UPAID)
@


1.32
log
@Give UltraSPARC-IV CPUs a chance again to attach on GENERIC.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.31 2007/11/16 23:27:28 kettenis Exp $	*/
a219 1
	char *cpuname;
a249 3
	cpuname = getpropstring(node, "name");
	if (strcmp(cpuname, "cpu") == 0)
		cpuname = getpropstring(node, "compatible");
d251 1
a251 1
	    cpuname, vers >> 4, vers & 0xf, clockfreq(clk));
@


1.31
log
@Pass name of CPU nodes instead of "cpu" such that we see it for unconfigured
CPUs on UP kernels.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.30 2007/11/10 00:22:29 kettenis Exp $	*/
d191 1
a191 1
	portid = getpropint(ma->ma_node, "portid", -1);
d193 3
a195 1
		portid = getpropint(ma->ma_node, "upa-portid", -1);
@


1.30
log
@For single-processor kernels, only match the CPU we're running on.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.29 2007/11/09 16:13:52 kettenis Exp $	*/
d65 1
a176 1
	struct cfdata *cf = (struct cfdata *)vcf;
d180 1
d182 2
a183 1
	if (strcmp(cf->cf_driver->cd_name, ma->ma_name) != 0)
@


1.29
log
@Use the interrupt stack as the initial stack for spinning up secondary CPUs.
Inspired by a change in NetBSD pointed out by miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.28 2007/10/28 12:34:05 kettenis Exp $	*/
d177 21
d199 1
a199 1
	return (strcmp(cf->cf_driver->cd_name, ma->ma_name) == 0);
@


1.28
log
@UltraSPARC CPUs don't have a floating-point queue, so cpu_reset_fpustate() is
redundant since there is no queue to flush.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.27 2007/10/21 21:00:38 kettenis Exp $	*/
d103 1
a103 1
	vaddr_t va, va0, kstack;
a135 4
	kstack = uvm_km_alloc (kernel_map, USPACE);
	if (kstack == 0)
		panic("alloc_cpuinfo: unable to allocate pcb");

d153 1
a153 1
	cpi->ci_initstack = (void *)(kstack + USPACE);
a156 1
	cpi->ci_cpcb = (struct pcb *)kstack;
@


1.27
log
@Don't use next_tick() to start the clock ticking on secondary CPUs.  This
would fail from time to time on UltraSPARC-I and UltraSPARC-II CPUs.
Inspired by code in FreeBSD.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.26 2007/10/19 14:36:01 deraadt Exp $	*/
a83 1
void cpu_reset_fpustate(void);
a185 21
void
cpu_reset_fpustate(void)
{
	struct fpstate64 *fpstate;
	struct fpstate64 fps[2];

	/* This needs to be 64-bit aligned */
	fpstate = ALIGNFPSTATE(&fps[1]);
	/*
	 * Get the FSR and clear any exceptions.  If we do not unload
	 * the queue here and it is left over from a previous crash, we
	 * will panic in the first loadfpstate(), due to a sequence error,
	 * so we need to dump the whole state anyway.
	 *
	 * If there is no FPU, trap.c will advance over all the stores,
	 * so we initialize fs_fsr here.
	 */
	fpstate->fs_fsr = 7 << FSR_VER_SHIFT;	/* 7 is reserved for "none" */
	savefpstate(fpstate);
}

a219 8
	/*
	 * Only do this on the boot cpu.  Other cpu's call
	 * cpu_reset_fpustate() from cpu_hatch() before they
	 * call into the idle loop.
	 */
	if (ci->ci_number == 0)
		cpu_reset_fpustate();

a389 1
	cpu_reset_fpustate();
@


1.26
log
@remove old-school "cpu%d running" messages from default code paths
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.25 2007/10/18 20:44:47 kettenis Exp $	*/
d428 1
a428 2
	extern long tick_increment;
	next_tick(tick_increment);
@


1.25
log
@Don't try to send IPIs to CPUs that aren't running (yet).
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.24 2007/10/17 21:23:28 kettenis Exp $	*/
a418 2

	printf("cpu%d running\n", cpu_number());
@


1.24
log
@Spin up secondary CPUs on MULTIPROCESSOR kernels.  Works on UltraSPARC-III
CPUs.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.23 2007/09/09 12:57:40 kettenis Exp $	*/
a385 1
volatile int cpu_mp_started;
d408 1
a408 1
			if (cpu_mp_started == 1)
a411 3

		cpu_mp_started = 0;
		sparc_membar(Sync);
d423 1
a423 1
	cpu_mp_started = 1;
@


1.23
log
@Make fpproc per-cpu.  This turns fpproc into a macro, so adjust fpu/fpu.c
to avoid collisions.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.22 2007/09/08 17:13:17 kettenis Exp $	*/
d66 1
d78 2
d84 3
d100 75
d187 21
d224 2
a225 3
	struct fpstate64 *fpstate;
	struct fpstate64 fps[2];
	char *sep;
a229 13
	/* This needs to be 64-bit aligned */
	fpstate = ALIGNFPSTATE(&fps[1]);
	/*
	 * Get the FSR and clear any exceptions.  If we do not unload
	 * the queue here and it is left over from a previous crash, we
	 * will panic in the first loadfpstate(), due to a sequence error,
	 * so we need to dump the whole state anyway.
	 *
	 * If there is no FPU, trap.c will advance over all the stores,
	 * so we initialize fs_fsr here.
	 */
	fpstate->fs_fsr = 7 << FSR_VER_SHIFT;	/* 7 is reserved for "none" */
	savefpstate(fpstate);
d237 13
d383 58
@


1.22
log
@Make the ast on sparc64 per-process instead of global.  Necessary to make
signal delivery more reliable once we go smp (although the code for that
is still missing).

"in principle, this looks good" art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.21 2007/09/04 20:36:52 kettenis Exp $	*/
a79 2

struct	proc *fpproc;
@


1.21
log
@UltraSPARC CPUs always have an on-chip FPU.  There really is no need to have
the code to detect the various FPUs of earlier SPARC V7 and V8 CPUs.

ok deraadt@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.20 2007/05/02 18:46:07 kettenis Exp $	*/
a81 2
int	want_ast;
extern	int want_resched;
d284 8
@


1.20
log
@Move sparc64 to __HAVE_CPUINFO.

ok miod@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.19 2007/03/15 21:24:23 kettenis Exp $	*/
a81 1
int	foundfpu;
a94 2
static char *fsrtoname(int, int, int, char *, size_t);

d123 1
a123 1
	int impl, vers, fver;
a124 1
	char *fpuname;
a128 1
	char fpbuf[40];
a145 1
	fver = (fpstate->fs_fsr >> FSR_VER_SHIFT) & (FSR_VER >> FSR_VER_SHIFT);
a148 5
	if (fver != 7) {
		foundfpu = 1;
		fpuname = fsrtoname(impl, vers, fver, fpbuf, sizeof fpbuf);
	} else
		fpuname = "no";
d167 2
a168 3
	snprintf(cpu_model, sizeof cpu_model,
		"%s (rev %d.%d) @@ %s MHz, %s FPU", cpuname,
		vers >> 4, vers & 0xf, clockfreq(clk), fpuname);
a280 82
}

/*
 * The following tables convert <IU impl, IU version, FPU version> triples
 * into names for the CPU and FPU chip.  In most cases we do not need to
 * inspect the FPU version to name the IU chip, but there is one exception
 * (for Tsunami), and this makes the tables the same.
 *
 * The table contents (and much of the structure here) are from Guy Harris.
 *
 */
struct info {
	u_char	valid;
	u_char	iu_impl;
	u_char	iu_vers;
	u_char	fpu_vers;
	char	*name;
};

#define	ANY	0xff	/* match any FPU version (or, later, IU version) */


/* NB: table order matters here; specific numbers must appear before ANY. */
static struct info fpu_types[] = {
	/*
	 * Vendor 0, IU Fujitsu0.
	 */
	{ 1, 0x0, ANY, 0, "MB86910 or WTL1164/5" },
	{ 1, 0x0, ANY, 1, "MB86911 or WTL1164/5" },
	{ 1, 0x0, ANY, 2, "L64802 or ACT8847" },
	{ 1, 0x0, ANY, 3, "WTL3170/2" },
	{ 1, 0x0, 4,   4, "on-chip" },		/* Swift */
	{ 1, 0x0, ANY, 4, "L64804" },

	/*
	 * Vendor 1, IU ROSS0/1 or Pinnacle.
	 */
	{ 1, 0x1, 0xf, 0, "on-chip" },		/* Pinnacle */
	{ 1, 0x1, ANY, 0, "L64812 or ACT8847" },
	{ 1, 0x1, ANY, 1, "L64814" },
	{ 1, 0x1, ANY, 2, "TMS390C602A" },
	{ 1, 0x1, ANY, 3, "RT602 or WTL3171" },

	/*
	 * Vendor 2, IU BIT0.
	 */
	{ 1, 0x2, ANY, 0, "B5010 or B5110/20 or B5210" },

	/*
	 * Vendor 4, Texas Instruments.
	 */
	{ 1, 0x4, ANY, 0, "on-chip" },		/* Viking */
	{ 1, 0x4, ANY, 4, "on-chip" },		/* Tsunami */

	/*
	 * Vendor 5, IU Matsushita0.
	 */
	{ 1, 0x5, ANY, 0, "on-chip" },

	/*
	 * Vendor 9, Weitek.
	 */
	{ 1, 0x9, ANY, 3, "on-chip" },

	{ 0 }
};

static char *
fsrtoname(impl, vers, fver, buf, buflen)
	register int impl, vers, fver;
	char *buf;
	size_t buflen;
{
	register struct info *p;

	for (p = fpu_types; p->valid; p++)
		if (p->iu_impl == impl &&
		    (p->iu_vers == vers || p->iu_vers == ANY) &&
		    (p->fpu_vers == fver))
			return (p->name);
	snprintf(buf, buflen, "version %x", fver);
	return (buf);
@


1.19
log
@UltraSPARC-IV cpus appear a bit different in OpenFirmware than older cpus.
Make sure we fetch the right properties such that we don't crash later in the
pci bus walking code when we divide by a zero cache line size.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.18 2007/01/07 18:13:41 kettenis Exp $	*/
a72 3

/* Our exported CPU info; we have only one for now. */  
struct cpu_info cpu_info_store;
@


1.18
log
@The associativity of the cache is already taken into account for
[ide]cache-size, so don't multiply it with [ide]cache-associativity.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.17 2007/01/07 16:54:46 kettenis Exp $	*/
d130 1
d178 3
d182 1
a182 1
		"%s (rev %d.%d) @@ %s MHz, %s FPU", getpropstring(node, "name"),
d188 4
a191 1
	cacheinfo.ic_linesize = l = getpropint(node, "icache-line-size", 0);
d199 2
d205 4
a208 2
	cacheinfo.dc_linesize = l =
		getpropint(node, "dcache-line-size",0);
d216 2
d222 4
a225 2
	cacheinfo.ec_linesize = l =
		getpropint(node, "ecache-line-size", 0);
d232 2
@


1.17
log
@Print out mask set revision.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.16 2006/12/29 00:14:28 kettenis Exp $	*/
d190 1
a190 3
	cacheinfo.ic_totalsize =
	    getpropint(node, "icache-size", 0) *
	    getpropint(node, "icache-associativity", 1);
d203 1
a203 3
	cacheinfo.dc_totalsize =
	    getpropint(node, "dcache-size", 0) *
	    getpropint(node, "dcache-associativity", 1);
d216 1
a216 3
	cacheinfo.ec_totalsize =
		getpropint(node, "ecache-size", 0) *
		getpropint(node, "ecache-associativity", 1);
@


1.16
log
@Give the UltraSPARC-III its own version of dcache_flush_page().  Fixes problems
with svnd(4).  Now you can do a full mkr on a v210 (and a blade1k if you're
lucky).
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.15 2006/12/23 12:28:11 kettenis Exp $	*/
d177 3
a179 3
	snprintf(cpu_model, sizeof cpu_model, "%s @@ %s MHz, %s FPU",
		getpropstring(node, "name"),
		clockfreq(clk), fpuname);
@


1.15
log
@On UltraSPARC-III, patch some crucial D-cache flush instructions, and
enable the cache.

ok jason@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.14 2005/08/06 14:26:52 miod Exp $	*/
d70 3
a72 1
struct cacheinfo cacheinfo;
d282 2
@


1.14
log
@We do not need a char machine_arch[] constant.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.13 2003/05/11 22:09:31 jason Exp $	*/
d264 17
@


1.13
log
@nuke another common: want_resched
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.12 2003/05/07 22:33:25 deraadt Exp $	*/
a79 1
char	machine_arch[] = MACHINE_ARCH;	/* from <machine/param.h> */
@


1.12
log
@string cleaning
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.11 2003/02/12 06:33:00 jason Exp $	*/
d85 2
a86 1
int	want_ast, want_resched;
@


1.11
log
@Kill more commons in sparc64 code
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.10 2003/02/10 10:47:58 jason Exp $	*/
d97 1
a97 1
static char *fsrtoname(int, int, int, char *);
d157 1
a157 1
		fpuname = fsrtoname(impl, vers, fver, fpbuf);
d175 1
a175 1
	sprintf(cpu_model, "%s @@ %s MHz, %s FPU",
d332 1
a332 1
fsrtoname(impl, vers, fver, buf)
d335 1
d344 1
a344 1
	sprintf(buf, "version %x", fver);
@


1.10
log
@fix sparc64 specific commons
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.9 2002/06/15 17:23:31 art Exp $	*/
d85 1
@


1.9
log
@Decruftification.

We will never have a.out kernels.
We will never have 32-bit kernels.
We will never have sun4c, sun4 and sun4m support in the sparc64 kernels.
We don't need support old netbsd libc.
The cpu will never be identified as some of the sun4c and sun4m types.
We don't need the gazillion of fields in cpuinfo that the sparc port uses.
Just generally remove dead code.

This is just a first step in making this meess readable.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.8 2002/06/11 10:57:51 art Exp $	*/
d82 3
@


1.8
log
@nuke unused stuff
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.7 2002/03/14 01:26:45 millert Exp $	*/
a92 3
#if defined(SUN4C) || defined(SUN4M)
static char *psrtoname(int, int, int, char *);
#endif
a97 25
#ifdef notdef
/*
 * IU implementations are parceled out to vendors (with some slight
 * glitches).  Printing these is cute but takes too much space.
 */
static char *iu_vendor[16] = {
	"Fujitsu",	/* and also LSI Logic */
	"ROSS",		/* ROSS (ex-Cypress) */
	"BIT",
	"LSIL",		/* LSI Logic finally got their own */
	"TI",		/* Texas Instruments */
	"Matsushita",
	"Philips",
	"Harvest",	/* Harvest VLSI Design Center */
	"SPEC",		/* Systems and Processes Engineering Corporation */
	"Weitek",
	"vendor#10",
	"vendor#11",
	"vendor#12",
	"vendor#13",
	"vendor#14",
	"vendor#15"
};
#endif

a280 34
#if defined(SUN4C) || defined(SUN4M)
static struct info iu_types[] = {
	{ 1, 0x0, 0x4, 4,   "MB86904" },
	{ 1, 0x0, 0x0, ANY, "MB86900/1A or L64801" },
	{ 1, 0x1, 0x0, ANY, "RT601 or L64811 v1" },
	{ 1, 0x1, 0x1, ANY, "RT601 or L64811 v2" },
	{ 1, 0x1, 0x3, ANY, "RT611" },
	{ 1, 0x1, 0xf, ANY, "RT620" },
	{ 1, 0x2, 0x0, ANY, "B5010" },
	{ 1, 0x4, 0x0,   0, "TMS390Z50 v0 or TMS390Z55" },
	{ 1, 0x4, 0x1,   0, "TMS390Z50 v1" },
	{ 1, 0x4, 0x1,   4, "TMS390S10" },
	{ 1, 0x5, 0x0, ANY, "MN10501" },
	{ 1, 0x9, 0x0, ANY, "W8601/8701 or MB86903" },
	{ 0 }
};

static char *
psrtoname(impl, vers, fver, buf)
	register int impl, vers, fver;
	char *buf;
{
	register struct info *p;

	for (p = iu_types; p->valid; p++)
		if (p->iu_impl == impl && p->iu_vers == vers &&
		    (p->fpu_vers == fver || p->fpu_vers == ANY))
			return (p->name);

	/* Not found. */
	sprintf(buf, "IU impl 0x%x vers 0x%x", impl, vers);
	return (buf);
}
#endif /* SUN4C || SUN4M */
@


1.7
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.6 2002/01/04 22:07:44 jason Exp $	*/
a124 83

/*
 * Overhead involved in firing up a new CPU:
 * 
 *	Allocate a cpuinfo/interrupt stack
 *	Map that into the kernel
 *	Initialize the cpuinfo
 *	Return the TLB entry for the cpuinfo.
 */
u_int64_t
cpu_init(pa, cpu_num)
	paddr_t pa;
	int cpu_num;
{
	struct cpu_info *ci;
	u_int64_t pagesize;
	u_int64_t pte;
	struct vm_page *m;
	psize_t size;
	vaddr_t va;
	struct pglist mlist;
	int error;

	size = NBPG; /* XXXX 8K, 64K, 512K, or 4MB */
	TAILQ_INIT(&mlist);
	if ((error = uvm_pglistalloc((psize_t)size, (paddr_t)0, (paddr_t)-1,
		(paddr_t)size, (paddr_t)0, &mlist, 1, 0)) != 0)
		panic("cpu_start: no memory, error %d", error);

	va = uvm_km_valloc(kernel_map, size);
	if (va == 0)
		panic("cpu_start: no memory");

	m = TAILQ_FIRST(&mlist);
	pa = VM_PAGE_TO_PHYS(m);
	pte = TSB_DATA(0 /* global */,
		pagesize,
		pa,
		1 /* priv */,
		1 /* Write */,
		1 /* Cacheable */,
		1 /* ALIAS -- Disable D$ */,
		1 /* valid */,
		0 /* IE */);

	/* Map the pages */
	for (; m != NULL; m = TAILQ_NEXT(m,pageq)) {
		pa = VM_PAGE_TO_PHYS(m);
		pmap_zero_page(pa);
		pmap_enter(pmap_kernel(), va, pa | PMAP_NVC,
			VM_PROT_READ|VM_PROT_WRITE,
			VM_PROT_READ|VM_PROT_WRITE|PMAP_WIRED);
		va += NBPG;
	}
	pmap_update(pmap_kernel());

	if (!cpus) cpus = (struct cpu_info *)va;
	else {
		for (ci = cpus; ci->ci_next; ci=ci->ci_next);
		ci->ci_next = (struct cpu_info *)va;
	}

	switch (size) {
#define K	*1024
	case 8 K:
		pagesize = TLB_8K;
		break;
	case 64 K:
		pagesize = TLB_64K;
		break;
	case 512 K:
		pagesize = TLB_512K;
		break;
	case 4 K K:
		pagesize = TLB_4M;
		break;
	default:
		panic("cpu_start: stack size %x not a machine page size\n",
			(unsigned)size);
	}
	return (pte|TLB_L);
}

@


1.6
log
@Use [eid]cache-size to determine cache sizes and fall back to (?cache-nlines * ?cache-linesize) if it fails (from NetBSD).
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.5 2001/12/04 23:22:42 art Exp $	*/
d84 2
a85 2
static void cpu_attach __P((struct device *, struct device *, void *));
int  cpu_match __P((struct device *, void *, void *));
d94 1
a94 1
static char *psrtoname __P((int, int, int, char *));
d96 1
a96 1
static char *fsrtoname __P((int, int, int, char *));
@


1.5
log
@Yet another sync to NetBSD uvm.
Today we add a pmap argument to pmap_update() and allocate map entries for
kernel_map from kmem_map instead of using the static entries. This should
get rid of MAX_KMAPENT panics. Also some uvm_loan problems are fixed.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.4 2001/11/06 19:53:16 miod Exp $	*/
d295 8
a302 4
	cacheinfo.ic_totalsize = l *
		getpropint(node, "icache-nlines", 64) *
		getpropint(node, "icache-associativity", 1);
	
d310 7
a316 3
	cacheinfo.dc_totalsize = l *
		getpropint(node, "dcache-nlines", 128) *
		getpropint(node, "dcache-associativity", 1);
d325 2
a326 2
	cacheinfo.ec_totalsize = l *
		getpropint(node, "ecache-nlines", 32768) *
d328 4
d369 1
a369 1
	printf(" \n");
@


1.5.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.6 2002/01/04 22:07:44 jason Exp $	*/
d295 4
a298 8
	cacheinfo.ic_totalsize =
	    getpropint(node, "icache-size", 0) *
	    getpropint(node, "icache-associativity", 1);
	if (cacheinfo.ic_totalsize == 0)
		cacheinfo.ic_totalsize = l *
		    getpropint(node, "icache-nlines", 64) *
		    getpropint(node, "icache-associativity", 1);

d306 3
a308 7
	cacheinfo.dc_totalsize =
	    getpropint(node, "dcache-size", 0) *
	    getpropint(node, "dcache-associativity", 1);
	if (cacheinfo.dc_totalsize == 0)
		cacheinfo.dc_totalsize = l *
		    getpropint(node, "dcache-nlines", 128) *
		    getpropint(node, "dcache-associativity", 1);
d317 2
a318 2
	cacheinfo.ec_totalsize =
		getpropint(node, "ecache-size", 0) *
a319 4
	if (cacheinfo.ec_totalsize == 0)
		cacheinfo.ec_totalsize = l *
		    getpropint(node, "ecache-nlines", 32768) *
		    getpropint(node, "ecache-associativity", 1);
d357 1
a357 1
	printf("\n");
@


1.5.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.5.2.1 2002/01/31 22:55:24 niklas Exp $	*/
d84 2
a85 2
static void cpu_attach(struct device *, struct device *, void *);
int  cpu_match(struct device *, void *, void *);
d94 1
a94 1
static char *psrtoname(int, int, int, char *);
d96 1
a96 1
static char *fsrtoname(int, int, int, char *);
@


1.5.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.5.2.2 2002/06/11 03:38:43 art Exp $	*/
d93 3
d101 108
d392 34
@


1.5.2.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a82 5
struct	proc *fpproc;
int	foundfpu;
int	want_ast;
extern	int want_resched;

d93 1
a93 1
static char *fsrtoname(int, int, int, char *, size_t);
d153 1
a153 1
		fpuname = fsrtoname(impl, vers, fver, fpbuf, sizeof fpbuf);
d171 1
a171 1
	snprintf(cpu_model, sizeof cpu_model, "%s @@ %s MHz, %s FPU",
d328 1
a328 1
fsrtoname(impl, vers, fver, buf, buflen)
a330 1
	size_t buflen;
d339 1
a339 1
	snprintf(buf, buflen, "version %x", fver);
@


1.4
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.3 2001/09/19 20:50:57 mickey Exp $	*/
d179 1
a179 1
	pmap_update();
@


1.3
log
@merge vm/vm_kern.h into uvm/uvm_extern.h; art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.2 2001/08/20 20:23:53 jason Exp $	*/
a58 1
#include <vm/vm.h>
@


1.3.4.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.3.4.2
log
@Merge in -current
@
text
@d59 1
@


1.3.4.3
log
@Merge in trunk
@
text
@d179 1
a179 1
	pmap_update(pmap_kernel());
d295 4
a298 8
	cacheinfo.ic_totalsize =
	    getpropint(node, "icache-size", 0) *
	    getpropint(node, "icache-associativity", 1);
	if (cacheinfo.ic_totalsize == 0)
		cacheinfo.ic_totalsize = l *
		    getpropint(node, "icache-nlines", 64) *
		    getpropint(node, "icache-associativity", 1);

d306 3
a308 7
	cacheinfo.dc_totalsize =
	    getpropint(node, "dcache-size", 0) *
	    getpropint(node, "dcache-associativity", 1);
	if (cacheinfo.dc_totalsize == 0)
		cacheinfo.dc_totalsize = l *
		    getpropint(node, "dcache-nlines", 128) *
		    getpropint(node, "dcache-associativity", 1);
d317 2
a318 2
	cacheinfo.ec_totalsize =
		getpropint(node, "ecache-size", 0) *
a319 4
	if (cacheinfo.ec_totalsize == 0)
		cacheinfo.ec_totalsize = l *
		    getpropint(node, "ecache-nlines", 32768) *
		    getpropint(node, "ecache-associativity", 1);
d357 1
a357 1
	printf("\n");
@


1.3.4.4
log
@Merge in -current from about a week ago
@
text
@d84 2
a85 2
static void cpu_attach(struct device *, struct device *, void *);
int  cpu_match(struct device *, void *, void *);
d94 1
a94 1
static char *psrtoname(int, int, int, char *);
d96 1
a96 1
static char *fsrtoname(int, int, int, char *);
@


1.3.4.5
log
@Sync the SMP branch with 3.3
@
text
@a82 4
struct	proc *fpproc;
int	foundfpu;
int	want_ast, want_resched;

d93 3
d101 108
d392 34
@


1.3.4.6
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.3.4.5 2003/03/27 23:42:37 niklas Exp $	*/
d85 1
a85 2
int	want_ast;
extern	int want_resched;
d97 1
a97 1
static char *fsrtoname(int, int, int, char *, size_t);
d157 1
a157 1
		fpuname = fsrtoname(impl, vers, fver, fpbuf, sizeof fpbuf);
d175 1
a175 1
	snprintf(cpu_model, sizeof cpu_model, "%s @@ %s MHz, %s FPU",
d332 1
a332 1
fsrtoname(impl, vers, fver, buf, buflen)
a334 1
	size_t buflen;
d343 1
a343 1
	snprintf(buf, buflen, "version %x", fver);
@


1.2
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a59 1
#include <vm/vm_kern.h>
@


1.1
log
@Lot of stuff... Some from NetBSD, some from OpenBSD, minor modifications
@
text
@d1 1
@

