head	1.20;
access;
symbols
	OPENBSD_6_2:1.20.0.2
	OPENBSD_6_2_BASE:1.20
	OPENBSD_6_1:1.20.0.4
	OPENBSD_6_1_BASE:1.20
	OPENBSD_6_0:1.18.0.12
	OPENBSD_6_0_BASE:1.18
	OPENBSD_5_9:1.18.0.8
	OPENBSD_5_9_BASE:1.18
	OPENBSD_5_8:1.18.0.10
	OPENBSD_5_8_BASE:1.18
	OPENBSD_5_7:1.18.0.2
	OPENBSD_5_7_BASE:1.18
	OPENBSD_5_6:1.18.0.6
	OPENBSD_5_6_BASE:1.18
	OPENBSD_5_5:1.18.0.4
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.17.0.10
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.17.0.8
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.6
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.4
	OPENBSD_5_0:1.17.0.2
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.14.0.6
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.14.0.4
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.2
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.13.0.10
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.6
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.4
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.2
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.12.0.6
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.4
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.2
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.10.0.12
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.10
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.8
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.10.0.6
	OPENBSD_3_6_BASE:1.10
	SMP_SYNC_A:1.10
	SMP_SYNC_B:1.10
	OPENBSD_3_5:1.10.0.4
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	UBC_SYNC_A:1.8
	OPENBSD_3_3:1.8.0.4
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	UBC_SYNC_B:1.8
	UBC:1.4.0.6
	UBC_BASE:1.4
	SMP:1.4.0.4
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4;
locks; strict;
comment	@ * @;


1.20
date	2017.01.21.05.42.03;	author guenther;	state Exp;
branches;
next	1.19;
commitid	CHRb0fCqa8XxUAMH;

1.19
date	2016.10.08.05.49.09;	author guenther;	state Exp;
branches;
next	1.18;
commitid	z63v1DilayzHcfkw;

1.18
date	2013.11.26.20.33.15;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2011.07.11.15.40.47;	author guenther;	state Exp;
branches;
next	1.16;

1.16
date	2011.07.07.18.11.24;	author art;	state Exp;
branches;
next	1.15;

1.15
date	2011.07.06.21.41.37;	author art;	state Exp;
branches;
next	1.14;

1.14
date	2010.01.01.13.13.07;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2007.09.09.12.57.40;	author kettenis;	state Exp;
branches;
next	1.12;

1.12
date	2006.06.21.19.24.38;	author jason;	state Exp;
branches;
next	1.11;

1.11
date	2006.05.14.21.58.05;	author kettenis;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.02.23.27.55;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.02.20.03.37;	author jason;	state Exp;
branches;
next	1.8;

1.8
date	2002.08.12.16.40.51;	author jason;	state Exp;
branches;
next	1.7;

1.7
date	2002.08.03.15.22.06;	author jason;	state Exp;
branches;
next	1.6;

1.6
date	2002.07.10.20.30.14;	author jsyn;	state Exp;
branches;
next	1.5;

1.5
date	2002.03.14.01.26.45;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.09.15.23.42.36;	author jason;	state Exp;
branches
	1.4.4.1
	1.4.6.1;
next	1.3;

1.3
date	2001.09.10.16.03.02;	author jason;	state Exp;
branches;
next	1.2;

1.2
date	2001.09.08.22.52.51;	author jason;	state Exp;
branches;
next	1.1;

1.1
date	2001.09.08.22.33.51;	author jason;	state Exp;
branches;
next	;

1.4.4.1
date	2001.10.31.03.07.58;	author nate;	state Exp;
branches;
next	1.4.4.2;

1.4.4.2
date	2002.03.28.11.23.52;	author niklas;	state Exp;
branches;
next	1.4.4.3;

1.4.4.3
date	2003.03.27.23.42.36;	author niklas;	state Exp;
branches;
next	1.4.4.4;

1.4.4.4
date	2003.06.07.11.14.45;	author ho;	state Exp;
branches;
next	;

1.4.6.1
date	2002.06.11.03.38.43;	author art;	state Exp;
branches;
next	1.4.6.2;

1.4.6.2
date	2002.10.29.00.28.11;	author art;	state Exp;
branches;
next	;


desc
@@


1.20
log
@p_comm is the process's command and isn't per thread, so move it from
struct proc to struct process.

ok deraadt@@ kettenis@@
@
text
@/*	$OpenBSD: fpu.c,v 1.19 2016/10/08 05:49:09 guenther Exp $	*/
/*	$NetBSD: fpu.c,v 1.11 2000/12/06 01:47:50 mrg Exp $ */

/*
 * Copyright (c) 2001 Jason L. Wright (jason@@thought.net)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
 *
 * All advertising materials mentioning features or use of this software
 * must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Lawrence Berkeley Laboratory.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)fpu.c	8.1 (Berkeley) 6/11/93
 */

#include <sys/param.h>
#include <sys/proc.h>
#include <sys/signal.h>
#include <sys/systm.h>
#include <sys/syslog.h>
#include <sys/signalvar.h>

#include <machine/instr.h>
#include <machine/reg.h>

#include <sparc64/fpu/fpu_emu.h>
#include <sparc64/fpu/fpu_extern.h>

int fpu_regoffset(int, int);
int fpu_insn_fmov(struct fpstate64 *, struct fpemu *, union instr);
int fpu_insn_fabs(struct fpstate64 *, struct fpemu *, union instr);
int fpu_insn_fneg(struct fpstate64 *, struct fpemu *, union instr);
int fpu_insn_itof(struct fpemu *, union instr, int, int *,
    int *, u_int *);
int fpu_insn_ftoi(struct fpemu *, union instr, int *, int, u_int *);
int fpu_insn_ftof(struct fpemu *, union instr, int *, int *, u_int *);
int fpu_insn_fsqrt(struct fpemu *, union instr, int *, int *, u_int *);
int fpu_insn_fcmp(struct fpstate64 *, struct fpemu *, union instr, int);
int fpu_insn_fmul(struct fpemu *, union instr, int *, int *, u_int *);
int fpu_insn_fmulx(struct fpemu *, union instr, int *, int *, u_int *);
int fpu_insn_fdiv(struct fpemu *, union instr, int *, int *, u_int *);
int fpu_insn_fadd(struct fpemu *, union instr, int *, int *, u_int *);
int fpu_insn_fsub(struct fpemu *, union instr, int *, int *, u_int *);
int fpu_insn_fmovcc(struct proc *, struct fpstate64 *, union instr);
int fpu_insn_fmovr(struct proc *, struct fpstate64 *, union instr);
void fpu_fcopy(u_int *, u_int *, int);

#ifdef DEBUG
int fpe_debug = 0;

/*
 * Dump a `fpn' structure.
 */
void
fpu_dumpfpn(struct fpn *fp)
{
	static char *class[] = { "SNAN", "QNAN", "ZERO", "NUM", "INF" };

	printf("%s %c.%x %x %x %xE%d", class[fp->fp_class + 2],
	    fp->fp_sign ? '-' : ' ', fp->fp_mant[0], fp->fp_mant[1],
	    fp->fp_mant[2], fp->fp_mant[3], fp->fp_exp);
}
void
fpu_dumpstate(struct fpstate64 *fs)
{
	int i;

	for (i = 0; i < 64; i++)
		printf("%%f%02d: %08x%s",
		    i, fs->fs_regs[i], ((i & 3) == 3) ? "\n" : "   ");
}
#endif

/*
 * fpu_execute returns the following error numbers (0 = no error):
 */
#define	FPE		1	/* take a floating point exception */
#define	NOTFPU		2	/* not an FPU instruction */

/*
 * Translate current exceptions into `first' exception.  The
 * bits go the wrong way for ffs() (0x10 is most important, etc).
 * There are only 5, so do it the obvious way.
 */
#define	X1(x) x
#define	X2(x) x,x
#define	X4(x) x,x,x,x
#define	X8(x) X4(x),X4(x)
#define	X16(x) X8(x),X8(x)

static char cx_to_trapx[] = {
	X1(FSR_NX),
	X2(FSR_DZ),
	X4(FSR_UF),
	X8(FSR_OF),
	X16(FSR_NV)
};
static u_char fpu_codes[] = {
	X1(FPE_FLTINEX_TRAP),
	X2(FPE_FLTDIV_TRAP),
	X4(FPE_FLTUND_TRAP),
	X8(FPE_FLTOVF_TRAP),
	X16(FPE_FLTOPERR_TRAP)
};

static int fpu_types[] = {
	X1(FPE_FLTRES),
	X2(FPE_FLTDIV),
	X4(FPE_FLTUND),
	X8(FPE_FLTOVF),
	X16(FPE_FLTINV)
};

void
fpu_fcopy(src, dst, type)
	u_int *src, *dst;
	int type;
{
	*dst++ = *src++;
	if (type == FTYPE_SNG || type == FTYPE_INT)
		return;
	*dst++ = *src++;
	if (type != FTYPE_EXT)
		return;
	*dst++ = *src++;
	*dst = *src;
}

/*
 * The FPU gave us an exception.  Clean up the mess.  Note that the
 * fp queue can only have FPops in it, never load/store FP registers
 * nor FBfcc instructions.  Experiments with `crashme' prove that
 * unknown FPops do enter the queue, however.
 */
void
fpu_cleanup(p, fs)
	register struct proc *p;
	register struct fpstate64 *fs;
{
	register int i, fsr = fs->fs_fsr, error;
	union instr instr;
	union sigval sv;
	struct fpemu fe;

	sv.sival_int = p->p_md.md_tf->tf_pc;  /* XXX only approximate */

	switch ((fsr >> FSR_FTT_SHIFT) & FSR_FTT_MASK) {

	case FSR_TT_NONE:
#if 0
		/* XXX I'm not sure how we get here, but ignoring the trap */
		/* XXX seems to work in my limited tests		   */
		/* XXX More research to be done =)			   */
		panic("fpu_cleanup 1"); /* ??? */
#else
		printf("fpu_cleanup 1\n");
#endif
		break;

	case FSR_TT_IEEE:
		if ((i = fsr & FSR_CX) == 0)
			panic("fpu ieee trap, but no exception");
		KERNEL_LOCK();
		trapsignal(p, SIGFPE, fpu_codes[i - 1], fpu_types[i - 1], sv);
		KERNEL_UNLOCK();
		break;		/* XXX should return, but queue remains */

	case FSR_TT_UNFIN:
		if (fs->fs_qsize == 0) {
			printf("fpu_cleanup: unfinished fpop");
			/* The book says reexecute or emulate. */
			return;
		}
		break;
	case FSR_TT_UNIMP:
		if (fs->fs_qsize == 0)
			panic("fpu_cleanup: unimplemented fpop");
		break;

	case FSR_TT_SEQ:
		panic("fpu sequence error");
		/* NOTREACHED */

	case FSR_TT_HWERR:
		log(LOG_ERR, "fpu hardware error (%s[%d])\n",
		    p->p_p->ps_comm, p->p_p->ps_pid);
		uprintf("%s[%d]: fpu hardware error\n",
		    p->p_p->ps_comm, p->p_p->ps_pid);
		KERNEL_LOCK();
		trapsignal(p, SIGFPE, -1, FPE_FLTINV, sv);	/* ??? */
		KERNEL_UNLOCK();
		goto out;

	default:
		printf("fsr=0x%x\n", fsr);
		panic("fpu error");
	}

	/* emulate the instructions left in the queue */
	fe.fe_fpstate = fs;
	for (i = 0; i < fs->fs_qsize; i++) {
		instr.i_int = fs->fs_queue[i].fq_instr;
		if (instr.i_any.i_op != IOP_reg ||
		    (instr.i_op3.i_op3 != IOP3_FPop1 &&
		     instr.i_op3.i_op3 != IOP3_FPop2))
			panic("bogus fpu queue");
		error = fpu_execute(p, &fe, instr);
		switch (error) {

		case 0:
			continue;

		case FPE:
			KERNEL_LOCK();
			trapsignal(p, SIGFPE,
			    fpu_codes[(fs->fs_fsr & FSR_CX) - 1],
			    fpu_types[(fs->fs_fsr & FSR_CX) - 1], sv);
			KERNEL_UNLOCK();
			break;

		case NOTFPU:
			KERNEL_LOCK();
			trapsignal(p, SIGILL, 0, ILL_COPROC, sv);
			KERNEL_UNLOCK();
			break;

		default:
			panic("fpu_cleanup 3");
			/* NOTREACHED */
		}
		/* XXX should stop here, but queue remains */
	}
out:
	fs->fs_qsize = 0;
}

/*
 * Compute offset given a register and type.  For 32 bit sparc, bits 1 and 0
 * must be zero for ext types, and bit 0 must be 0 for double and long types.
 * For 64bit sparc, bit 1 must be zero for quad types, and bit 0 becomes bit
 * 5 in the register offset for long, double, and quad types.
 */
int
fpu_regoffset(rx, type)
	int rx, type;
{
	if (type == FTYPE_LNG || type == FTYPE_DBL || type == FTYPE_EXT) {
		rx |= (rx & 1) << 5;
		rx &= 0x3e;
		if ((type == FTYPE_EXT) && (rx & 2))
			return (-1);
	}
	return (rx);
}

/*
 * Execute an FPU instruction (one that runs entirely in the FPU; not
 * FBfcc or STF, for instance).  On return, fe->fe_fs->fs_fsr will be
 * modified to reflect the setting the hardware would have left.
 */
int
fpu_execute(p, fe, instr)
	struct proc *p;
	struct fpemu *fe;
	union instr instr;
{
	struct fpstate *fs;
	int opf, rdtype, rd, err, mask, cx, fsr;
	u_int space[4];

	DPRINTF(FPE_INSN, ("op3: %x, opf %x\n", instr.i_opf.i_op3,
	    instr.i_opf.i_opf));
	DPRINTF(FPE_STATE, ("BEFORE:\n"));
	DUMPSTATE(FPE_STATE, fe->fe_fpstate);
	opf = instr.i_opf.i_opf;
	fs = fe->fe_fpstate;
	fe->fe_fsr = fs->fs_fsr & ~FSR_CX;
	fe->fe_cx = 0;

	if ((instr.i_int & 0xc0000000) != 0x80000000)
		return (NOTFPU);

	if (instr.i_opf.i_op3 == IOP3_FPop2) {
		switch (opf) {
		case FCMPS: case FCMPD: case FCMPQ:
			return (fpu_insn_fcmp(fs, fe, instr, 0));

		case FCMPES: case FCMPED: case FCMPEQ:
			return (fpu_insn_fcmp(fs, fe, instr, 1));

		case FMVFC0S: case FMVFC0D: case FMVFC0Q:
		case FMVFC1S: case FMVFC1D: case FMVFC1Q:
		case FMVFC2S: case FMVFC2D: case FMVFC2Q:
		case FMVFC3S: case FMVFC3D: case FMVFC3Q:
		case FMVICS: case FMVICD: case FMVICQ:
		case FMVXCS: case FMVXCD: case FMVXCQ:
			return (fpu_insn_fmovcc(p, fs, instr));

		case FMOVZS: case FMOVZD: case FMOVZQ:
		case FMOVLEZS: case FMOVLEZD: case FMOVLEZQ:
		case FMOVLZS: case FMOVLZD: case FMOVLZQ:
		case FMOVNZS: case FMOVNZD: case FMOVNZQ:
		case FMOVGZS: case FMOVGZD: case FMOVGZQ:
		case FMOVGEZS: case FMOVGEZD: case FMOVGEZQ:
			return (fpu_insn_fmovr(p, fs, instr));
		}
		return (NOTFPU);
	}

	if (instr.i_opf.i_op3 != IOP3_FPop1)
		return (NOTFPU);

	switch (instr.i_opf.i_opf) {
	case FSTOX: case FDTOX: case FQTOX:
		rdtype = FTYPE_LNG;
		if ((err = fpu_insn_ftoi(fe, instr, &rd, rdtype, space)) != 0)
			return (err);
		break;

	case FSTOI: case FDTOI: case FQTOI:
		rdtype = FTYPE_INT;
		if ((err = fpu_insn_ftoi(fe, instr, &rd, rdtype, space)) != 0)
			return (err);
		break;

	case FITOS: case FITOD: case FITOQ:
		if ((err = fpu_insn_itof(fe, instr, FTYPE_INT, &rd,
		    &rdtype, space)) != 0)
			return (err);
		break;

	case FXTOS: case FXTOD: case FXTOQ:
		if ((err = fpu_insn_itof(fe, instr, FTYPE_LNG, &rd,
		    &rdtype, space)) != 0)
			return (err);
		break;

	case FSTOD: case FSTOQ:
	case FDTOS: case FDTOQ:
	case FQTOS: case FQTOD:
		if ((err = fpu_insn_ftof(fe, instr, &rd, &rdtype, space)) != 0)
			return (err);
		break;

	case FMOVS: case FMOVD: case FMOVQ:
		return (fpu_insn_fmov(fs, fe, instr));

	case FNEGS: case FNEGD: case FNEGQ:
		return (fpu_insn_fneg(fs, fe, instr));

	case FABSS: case FABSD: case FABSQ:
		return (fpu_insn_fabs(fs, fe, instr));

	case FSQRTS: case FSQRTD: case FSQRTQ:
		if ((err = fpu_insn_fsqrt(fe, instr, &rd, &rdtype, space)) != 0)
			return (err);
		break;

	case FMULS: case FMULD: case FMULQ:
		if ((err = fpu_insn_fmul(fe, instr, &rd, &rdtype, space)) != 0)
			return (err);
		break;

	case FDIVS: case FDIVD: case FDIVQ:
		if ((err = fpu_insn_fdiv(fe, instr, &rd, &rdtype, space)) != 0)
			return (err);
		break;

	case FSMULD: case FDMULQ:
		if ((err = fpu_insn_fmulx(fe, instr, &rd, &rdtype, space)) != 0)
			return (err);
		break;

	case FADDS: case FADDD: case FADDQ:
		if ((err = fpu_insn_fadd(fe, instr, &rd, &rdtype, space)) != 0)
			return (err);
		break;

	case FSUBS: case FSUBD: case FSUBQ:
		if ((err = fpu_insn_fsub(fe, instr, &rd, &rdtype, space)) != 0)
			return (err);
		break;
	default:
		return (NOTFPU);
	}

	cx = fe->fe_cx;
	fsr = fe->fe_fsr;
	if (cx != 0) {
		mask = (fsr >> FSR_TEM_SHIFT) & FSR_TEM_MASK;
		if (cx & mask) {
			/* not accrued??? */
			fs->fs_fsr = (fsr & ~FSR_FTT) |
			    (FSR_TT_IEEE << FSR_FTT_SHIFT) |
			    (cx_to_trapx[(cx & mask) - 1] << FSR_CX_SHIFT);
			return (FPE);
		}
		fsr |= (cx << FSR_CX_SHIFT) | (cx << FSR_AX_SHIFT);
	}
	fs->fs_fsr = fsr;
	fpu_fcopy(space, fs->fs_regs + rd, rdtype);
	DPRINTF(FPE_STATE, ("AFTER:\n"));
	DUMPSTATE(FPE_STATE, fs);
	return (0);
}

/*
 * Handler for FMOV[SDQ] emulation.
 */
int
fpu_insn_fmov(fs, fe, instr)
	struct fpstate64 *fs;
	struct fpemu *fe;
	union instr instr;
{
	int opf = instr.i_opf.i_opf, rs, rd, rtype;

	rtype = opf & 3;
	if (rtype == 0)
		return (NOTFPU);
	if ((rs = fpu_regoffset(instr.i_opf.i_rs2, rtype)) < 0)
		return (NOTFPU);
	if ((rd = fpu_regoffset(instr.i_opf.i_rd, rtype)) < 0)
		return (NOTFPU);
	fpu_fcopy(fs->fs_regs + rs, fs->fs_regs + rd, rtype);
	fs->fs_fsr = fe->fe_fsr;
	return (0);
}

/*
 * Handler for FABS[SDQ] emulation.
 */
int
fpu_insn_fabs(fs, fe, instr)
	struct fpstate64 *fs;
	struct fpemu *fe;
	union instr instr;
{
	int opf = instr.i_opf.i_opf, rs, rd, rtype;

	rtype = opf & 3;
	if (rtype == 0)
		return (NOTFPU);
	if ((rs = fpu_regoffset(instr.i_opf.i_rs2, rtype)) < 0)
		return (NOTFPU);
	if ((rd = fpu_regoffset(instr.i_opf.i_rd, rtype)) < 0)
		return (NOTFPU);
	fpu_fcopy(fs->fs_regs + rs, fs->fs_regs + rd, rtype);
	fs->fs_regs[rd] = fs->fs_regs[rd] & ~(1U << 31);
	fs->fs_fsr = fe->fe_fsr;
	return (0);
}

/*
 * Handler for FNEG[SDQ] emulation.
 */
int
fpu_insn_fneg(fs, fe, instr)
	struct fpstate64 *fs;
	struct fpemu *fe;
	union instr instr;
{
	int opf = instr.i_opf.i_opf, rs, rd, rtype;

	rtype = opf & 3;
	if (rtype == 0)
		return (NOTFPU);
	if ((rs = fpu_regoffset(instr.i_opf.i_rs2, rtype)) < 0)
		return (NOTFPU);
	if ((rd = fpu_regoffset(instr.i_opf.i_rd, rtype)) < 0)
		return (NOTFPU);
	fpu_fcopy(fs->fs_regs + rs, fs->fs_regs + rd, rtype);
	fs->fs_regs[rd] = fs->fs_regs[rd] ^ (1U << 31);
	fs->fs_fsr = fe->fe_fsr;
	return (0);
}

/*
 * Handler for F[XI]TO[SDQ] emulation.
 */
int
fpu_insn_itof(fe, instr, rstype, rdp, rdtypep, space)
	struct fpemu *fe;
	union instr instr;
	u_int *space;
	int rstype, *rdp, *rdtypep;
{
	int opf = instr.i_opf.i_opf, rs, rd, rdtype;

	if ((rs = fpu_regoffset(instr.i_opf.i_rs2, rstype)) < 0)
		return (NOTFPU);

	rdtype = (opf >> 2) & 3;
	if (rdtype == 0)
		return (NOTFPU);
	if ((rd = fpu_regoffset(instr.i_opf.i_rd, rdtype)) < 0)
		return (NOTFPU);

	DPRINTF(FPE_INSN, ("itof %%f%d(%d, %d) -> %%f%d(%d, %d)\n",
	    rs, rstype, instr.i_opf.i_rs2, rd, rdtype, instr.i_opf.i_rd));
	fpu_explode(fe, &fe->fe_f1, rstype, rs);
	fpu_implode(fe, &fe->fe_f1, rdtype, space);
	*rdp = rd;
	*rdtypep = rdtype;
	return (0);
}

/*
 * Handler for F[SDQ]TO[XI] emulation.
 */
int
fpu_insn_ftoi(fe, instr, rdp, rdtype, space)
	struct fpemu *fe;
	union instr instr;
	u_int *space;
	int *rdp, rdtype;
{
	int opf = instr.i_opf.i_opf, rd, rstype, rs;

	rstype = opf & 3;
	if (rstype == 0)
		return (NOTFPU);
	if ((rs = fpu_regoffset(instr.i_opf.i_rs2, rstype)) < 0)
		return (NOTFPU);
	if ((rd = fpu_regoffset(instr.i_opf.i_rd, rdtype)) < 0)
		return (NOTFPU);

	fpu_explode(fe, &fe->fe_f1, rstype, rs);
	fpu_implode(fe, &fe->fe_f1, rdtype, space);
	*rdp = rd;
	return (0);
}

/*
 * Handler for F[SDQ]TO[SDQ] emulation.
 */
int
fpu_insn_ftof(fe, instr, rdp, rdtypep, space)
	struct fpemu *fe;
	union instr instr;
	u_int *space;
	int *rdp, *rdtypep;
{
	int opf = instr.i_opf.i_opf, rd, rs, rdtype, rstype;

	rstype = opf & 3;
	rdtype = (opf >> 2) & 3;

	if ((rstype == rdtype) || (rstype == 0) || (rdtype == 0))
		return (NOTFPU);

	if ((rs = fpu_regoffset(instr.i_opf.i_rs2, rstype)) < 0)
		return (NOTFPU);
	if ((rd = fpu_regoffset(instr.i_opf.i_rd, rdtype)) < 0)
		return (NOTFPU);

	DPRINTF(FPE_INSN, ("ftof %%f%d(%d, %d) -> %%f%d(%d, %d)\n",
	    rs, rstype, instr.i_opf.i_rs2, rd, rdtype, instr.i_opf.i_rd));

	fpu_explode(fe, &fe->fe_f1, rstype, rs);
	fpu_implode(fe, &fe->fe_f1, rdtype, space);
	*rdp = rd;
	*rdtypep = rdtype;
	return (0);
}

/*
 * Handler for FQSRT[SDQ] emulation.
 */
int
fpu_insn_fsqrt(fe, instr, rdp, rdtypep, space)
	struct fpemu *fe;
	union instr instr;
	u_int *space;
	int *rdp, *rdtypep;
{
	int opf = instr.i_opf.i_opf, rd, rs, rtype;
	struct fpn *fp;

	rtype = opf & 3;
	if (rtype == 0)
		return (NOTFPU);
	if ((rs = fpu_regoffset(instr.i_opf.i_rs2, rtype)) < 0)
		return (NOTFPU);
	if ((rd = fpu_regoffset(instr.i_opf.i_rd, rtype)) < 0)
		return (NOTFPU);

	fpu_explode(fe, &fe->fe_f1, rtype, rs);
	fp = fpu_sqrt(fe);
	fpu_implode(fe, fp, rtype, space);
	*rdp = rd;
	*rdtypep = rtype;
	return (0);
}

/*
 * Handler for FCMP{E}[SDQ] emulation.
 */
int
fpu_insn_fcmp(fs, fe, instr, cmpe)
	struct fpstate64 *fs;
	struct fpemu *fe;
	union instr instr;
	int cmpe;
{
	int opf = instr.i_opf.i_opf, rs1, rs2, rtype, cx, fsr;

	rtype = opf & 3;
	if (rtype == 0)
		return (NOTFPU);
	if ((rs1 = fpu_regoffset(instr.i_opf.i_rs1, rtype)) < 0)
		return (NOTFPU);
	if ((rs2 = fpu_regoffset(instr.i_opf.i_rs2, rtype)) < 0)
		return (NOTFPU);

	fpu_explode(fe, &fe->fe_f1, rtype, rs1);
	fpu_explode(fe, &fe->fe_f2, rtype, rs2);
	fpu_compare(fe, cmpe);

	/*
	 * The only possible exception here is NV; catch it early
	 * and get out, as there is no result register.
	 */
	cx = fe->fe_cx;
	fsr = fe->fe_fsr | (cx << FSR_CX_SHIFT);
	if (cx != 0) {
		if (fsr & (FSR_NV << FSR_TEM_SHIFT)) {
			fs->fs_fsr = (fsr & ~FSR_FTT) |
			    (FSR_TT_IEEE << FSR_FTT_SHIFT);
			return (FPE);
		}
		fsr |= FSR_NV << FSR_AX_SHIFT;
	}
	fs->fs_fsr = fsr;
	return (0);
}

/*
 * Handler for FMUL[SDQ] emulation.
 */
int
fpu_insn_fmul(fe, instr, rdp, rdtypep, space)
	struct fpemu *fe;
	union instr instr;
	int *rdp, *rdtypep;
	u_int *space;
{
	struct fpn *fp;
	int opf = instr.i_opf.i_opf, rd, rtype, rs1, rs2;

	rtype = opf & 3;
	if (rtype == 0)
		return (NOTFPU);
	if ((rs1 = fpu_regoffset(instr.i_opf.i_rs1, rtype)) < 0)
		return (NOTFPU);
	if ((rs2 = fpu_regoffset(instr.i_opf.i_rs2, rtype)) < 0)
		return (NOTFPU);
	if ((rd = fpu_regoffset(instr.i_opf.i_rd, rtype)) < 0)
		return (NOTFPU);

	fpu_explode(fe, &fe->fe_f1, rtype, rs1);
	fpu_explode(fe, &fe->fe_f2, rtype, rs2);
	fp = fpu_mul(fe);
	fpu_implode(fe, fp, rtype, space);
	*rdp = rd;
	*rdtypep = rtype;
	return (0);
}

/*
 * Handler for FSMULD, FDMULQ emulation.
 */
int
fpu_insn_fmulx(fe, instr, rdp, rdtypep, space)
	struct fpemu *fe;
	union instr instr;
	int *rdp, *rdtypep;
	u_int *space;
{
	struct fpn *fp;
	int opf = instr.i_opf.i_opf, rd, rdtype, rstype, rs1, rs2;

	rstype = opf & 3;
	rdtype = (opf >> 2) & 3;
	if ((rstype != rdtype + 1) || (rstype == 0) || (rdtype == 0))
		return (NOTFPU);
	if ((rs1 = fpu_regoffset(instr.i_opf.i_rs1, rstype)) < 0)
		return (NOTFPU);
	if ((rs2 = fpu_regoffset(instr.i_opf.i_rs2, rstype)) < 0)
		return (NOTFPU);
	if ((rd = fpu_regoffset(instr.i_opf.i_rd, rdtype)) < 0)
		return (NOTFPU);

	fpu_explode(fe, &fe->fe_f1, rstype, rs1);
	fpu_explode(fe, &fe->fe_f2, rstype, rs2);
	fp = fpu_mul(fe);
	fpu_implode(fe, fp, rdtype, space);
	*rdp = rd;
	*rdtypep = rdtype;
	return (0);
}

/*
 * Handler for FDIV[SDQ] emulation.
 */
int
fpu_insn_fdiv(fe, instr, rdp, rdtypep, space)
	struct fpemu *fe;
	union instr instr;
	int *rdp, *rdtypep;
	u_int *space;
{
	struct fpn *fp;
	int opf = instr.i_opf.i_opf, rd, rtype, rs1, rs2;

	rtype = opf & 3;
	if (rtype == 0)
		return (NOTFPU);
	if ((rs1 = fpu_regoffset(instr.i_opf.i_rs1, rtype)) < 0)
		return (NOTFPU);
	if ((rs2 = fpu_regoffset(instr.i_opf.i_rs2, rtype)) < 0)
		return (NOTFPU);
	if ((rd = fpu_regoffset(instr.i_opf.i_rd, rtype)) < 0)
		return (NOTFPU);

	fpu_explode(fe, &fe->fe_f1, rtype, rs1);
	fpu_explode(fe, &fe->fe_f2, rtype, rs2);
	fp = fpu_div(fe);
	fpu_implode(fe, fp, rtype, space);
	*rdp = rd;
	*rdtypep = rtype;
	return (0);
}

/*
 * Handler for FADD[SDQ] emulation.
 */
int
fpu_insn_fadd(fe, instr, rdp, rdtypep, space)
	struct fpemu *fe;
	union instr instr;
	int *rdp, *rdtypep;
	u_int *space;
{
	struct fpn *fp;
	int opf = instr.i_opf.i_opf, rd, rtype, rs1, rs2;

	rtype = opf & 3;
	if (rtype == 0)
		return (NOTFPU);
	if ((rs1 = fpu_regoffset(instr.i_opf.i_rs1, rtype)) < 0)
		return (NOTFPU);
	if ((rs2 = fpu_regoffset(instr.i_opf.i_rs2, rtype)) < 0)
		return (NOTFPU);
	if ((rd = fpu_regoffset(instr.i_opf.i_rd, rtype)) < 0)
		return (NOTFPU);

	fpu_explode(fe, &fe->fe_f1, rtype, rs1);
	fpu_explode(fe, &fe->fe_f2, rtype, rs2);
	fp = fpu_add(fe);
	fpu_implode(fe, fp, rtype, space);
	*rdp = rd;
	*rdtypep = rtype;
	return (0);
}

/*
 * Handler for FSUB[SDQ] emulation.
 */
int
fpu_insn_fsub(fe, instr, rdp, rdtypep, space)
	struct fpemu *fe;
	union instr instr;
	int *rdp, *rdtypep;
	u_int *space;
{
	struct fpn *fp;
	int opf = instr.i_opf.i_opf, rd, rtype, rs1, rs2;

	rtype = opf & 3;
	if (rtype == 0)
		return (NOTFPU);
	if ((rs1 = fpu_regoffset(instr.i_opf.i_rs1, rtype)) < 0)
		return (NOTFPU);
	if ((rs2 = fpu_regoffset(instr.i_opf.i_rs2, rtype)) < 0)
		return (NOTFPU);
	if ((rd = fpu_regoffset(instr.i_opf.i_rd, rtype)) < 0)
		return (NOTFPU);

	fpu_explode(fe, &fe->fe_f1, rtype, rs1);
	fpu_explode(fe, &fe->fe_f2, rtype, rs2);
	fp = fpu_sub(fe);
	fpu_implode(fe, fp, rtype, space);
	*rdp = rd;
	*rdtypep = rtype;
	return (0);
}

/*
 * Handler for FMOV[SDQ][cond] emulation.
 */
int
fpu_insn_fmovcc(p, fs, instr)
	struct proc *p;
	struct fpstate64 *fs;
	union instr instr;
{
	int rtype, rd, rs, cond;

	rtype = instr.i_fmovcc.i_opf_low & 3;
	if ((rtype == 0) || (instr.i_int & 0x00040000))
		return (NOTFPU);

	if ((rd = fpu_regoffset(instr.i_fmovcc.i_rd, rtype)) < 0)
		return (NOTFPU);
	if ((rs = fpu_regoffset(instr.i_fmovcc.i_rs2, rtype)) < 0)
		return (NOTFPU);

	switch (instr.i_fmovcc.i_opf_cc) {
	case 0:
		cond = (fs->fs_fsr >> FSR_FCC_SHIFT) & FSR_FCC_MASK;
		break;
	case 1:
		cond = (fs->fs_fsr >> FSR_FCC1_SHIFT) & FSR_FCC_MASK;
		break;
	case 2:
		cond = (fs->fs_fsr >> FSR_FCC2_SHIFT) & FSR_FCC_MASK;
		break;
	case 3:
		cond = (fs->fs_fsr >> FSR_FCC3_SHIFT) & FSR_FCC_MASK;
		break;
	case 4:
		cond = (p->p_md.md_tf->tf_tstate >> TSTATE_CCR_SHIFT) &
		    PSR_ICC;
		break;
	case 6:
		cond = (p->p_md.md_tf->tf_tstate >>
		    (TSTATE_CCR_SHIFT + XCC_SHIFT)) & PSR_ICC;
		break;
	default:
		return (NOTFPU);
	}

	if (instr.i_fmovcc.i_cond != cond)
		return (0);

	fpu_fcopy(fs->fs_regs + rs, fs->fs_regs + rd, rtype);
	return (0);
}

/*
 * Handler for FMOVR[icond][SDQ] emulation.
 */
int
fpu_insn_fmovr(p, fs, instr)
	struct proc *p;
	struct fpstate64 *fs;
	union instr instr;
{
	int rtype, rd, rs2, rs1;

	rtype = instr.i_fmovcc.i_opf_low & 3;
	if ((rtype == 0) || (instr.i_int & 0x00002000))
		return (NOTFPU);

	if ((rd = fpu_regoffset(instr.i_fmovr.i_rd, rtype)) < 0)
		return (NOTFPU);
	if ((rs2 = fpu_regoffset(instr.i_fmovr.i_rs2, rtype)) < 0)
		return (NOTFPU);
	rs1 = instr.i_fmovr.i_rs1;

	switch (instr.i_fmovr.i_rcond) {
	case 1:	/* Z */
		if (rs1 != 0 &&
		    (int64_t)p->p_md.md_tf->tf_global[rs1] != 0)
			return (0);
		break;
	case 2: /* LEZ */
		if (rs1 != 0 &&
		    (int64_t)p->p_md.md_tf->tf_global[rs1] > 0)
			return (0);
		break;
	case 3: /* LZ */
		if (rs1 == 0 ||
		    (int64_t)p->p_md.md_tf->tf_global[rs1] >= 0)
			return (0);
		break;
	case 5:	/* NZ */
		if (rs1 == 0 ||
		    (int64_t)p->p_md.md_tf->tf_global[rs1] == 0)
			return (0);
		break;
	case 6: /* NGZ */
		if (rs1 == 0 ||
		    (int64_t)p->p_md.md_tf->tf_global[rs1] <= 0)
			return (0);
		break;
	case 7: /* NGEZ */
		if (rs1 != 0 &&
		    (int64_t)p->p_md.md_tf->tf_global[rs1] < 0)
			return (0);
		break;
	default:
		return (NOTFPU);
	}

	fpu_fcopy(fs->fs_regs + rs2, fs->fs_regs + rd, rtype);
	return (0);
}
@


1.19
log
@Various printf claim to report the PID, so actually report that and not the TID

Build testing assistance from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fpu.c,v 1.18 2013/11/26 20:33:15 deraadt Exp $	*/
d240 1
a240 1
		    p->p_comm, p->p_p->ps_pid);
d242 1
a242 1
		    p->p_comm, p->p_p->ps_pid);
@


1.18
log
@1 << 31 cleanup.  Eitan Adler pointed out that there has been a
resurrection of the bad idiom in the tree.
sufficient review by miod, kettenis, tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: fpu.c,v 1.17 2011/07/11 15:40:47 guenther Exp $	*/
d240 3
a242 2
		    p->p_comm, p->p_pid);
		uprintf("%s[%d]: fpu hardware error\n", p->p_comm, p->p_pid);
@


1.17
log
@Revert art@@'s moving around of the KERNEL_LOCK()/KERNEL_UNLOCK() calls,
as it causes hangs in some ports, including libsigsegv's configure script

confirmed by krw@@, landry@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fpu.c,v 1.15 2011/07/06 21:41:37 art Exp $	*/
d502 1
a502 1
	fs->fs_regs[rd] = fs->fs_regs[rd] & ~(1 << 31);
d526 1
a526 1
	fs->fs_regs[rd] = fs->fs_regs[rd] ^ (1 << 31);
@


1.16
log
@There is a bunch of places in the kernel entry points where we don't
hold the kernel lock, but still need call one function that needs it.

Instead of grabbing the lock all over the place, move the locks into
the affected functions: trapsignal, scdebug*, ktrsyscall, ktrsysret,
systrace_redirect and ADDUPROF. In the cases we already hold the biglock
we'll just recurse.

kettenis@@, beck@@ ok
@
text
@d217 1
d219 1
d242 1
d244 1
d267 1
d271 1
d275 1
d277 1
@


1.15
log
@Clean up after P_BIGLOCK removal.
KERNEL_PROC_LOCK -> KERNEL_LOCK
KERNEL_PROC_UNLOCK -> KERNEL_UNLOCK

oga@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: fpu.c,v 1.14 2010/01/01 13:13:07 miod Exp $	*/
a216 1
		KERNEL_LOCK();
a217 1
		KERNEL_UNLOCK();
a239 1
		KERNEL_LOCK();
a240 1
		KERNEL_UNLOCK();
a262 1
			KERNEL_LOCK();
a265 1
			KERNEL_UNLOCK();
a268 1
			KERNEL_LOCK();
a269 1
			KERNEL_UNLOCK();
@


1.14
log
@Make sure we grab the kernel lock before invoking trapsignal().
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fpu.c,v 1.13 2007/09/09 12:57:40 kettenis Exp $	*/
d217 1
a217 1
		KERNEL_PROC_LOCK(p);
d219 1
a219 1
		KERNEL_PROC_UNLOCK(p);
d242 1
a242 1
		KERNEL_PROC_LOCK(p);
d244 1
a244 1
		KERNEL_PROC_UNLOCK(p);
d267 1
a267 1
			KERNEL_PROC_LOCK(p);
d271 1
a271 1
			KERNEL_PROC_UNLOCK(p);
d275 1
a275 1
			KERNEL_PROC_LOCK(p);
d277 1
a277 1
			KERNEL_PROC_UNLOCK(p);
@


1.13
log
@Make fpproc per-cpu.  This turns fpproc into a macro, so adjust fpu/fpu.c
to avoid collisions.
@
text
@d1 1
a1 1
/*	$OpenBSD: fpu.c,v 1.12 2006/06/21 19:24:38 jason Exp $	*/
d217 1
d219 1
d242 1
d244 1
d267 1
d271 1
d275 1
d277 1
@


1.12
log
@There was hope, at one time, of sharing fpu/ with sparc.  That's still
possible, but not with #ifdef SUN4U all over the place.  The define should
be _v9 or __sparc64__ since it will equally well apply to all v9 machines.
We'll burn that bridge before we cross it.
@
text
@d1 1
a1 1
/*	$OpenBSD: fpu.c,v 1.11 2006/05/14 21:58:05 kettenis Exp $	*/
d307 2
a308 2
fpu_execute(fpproc, fe, instr)
	struct proc *fpproc;
d342 1
a342 1
			return (fpu_insn_fmovcc(fpproc, fs, instr));
d350 1
a350 1
			return (fpu_insn_fmovr(fpproc, fs, instr));
d848 2
a849 2
fpu_insn_fmovcc(fpproc, fs, instr)
	struct proc *fpproc;
d878 1
a878 1
		cond = (fpproc->p_md.md_tf->tf_tstate >> TSTATE_CCR_SHIFT) &
d882 1
a882 1
		cond = (fpproc->p_md.md_tf->tf_tstate >>
d900 2
a901 2
fpu_insn_fmovr(fpproc, fs, instr)
	struct proc *fpproc;
d920 1
a920 1
		    (int64_t)fpproc->p_md.md_tf->tf_global[rs1] != 0)
d925 1
a925 1
		    (int64_t)fpproc->p_md.md_tf->tf_global[rs1] > 0)
d930 1
a930 1
		    (int64_t)fpproc->p_md.md_tf->tf_global[rs1] >= 0)
d935 1
a935 1
		    (int64_t)fpproc->p_md.md_tf->tf_global[rs1] == 0)
d940 1
a940 1
		    (int64_t)fpproc->p_md.md_tf->tf_global[rs1] <= 0)
d945 1
a945 1
		    (int64_t)fpproc->p_md.md_tf->tf_global[rs1] < 0)
@


1.11
log
@Make the array of fpu exception types/codes big enough.
Fix a typo too, such that we actually read beyond element 0 in all cases.
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fpu.c,v 1.10 2003/06/02 23:27:55 millert Exp $	*/
a191 3
#ifndef SUN4U
	register struct fpstate *fs;
#else /* SUN4U */
a192 1
#endif /* SUN4U */
a220 1
#ifdef SUN4U
a226 1
#endif /* SUN4U */
@


1.10
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: fpu.c,v 1.9 2003/06/02 20:03:37 jason Exp $	*/
d161 5
a165 5
	FPE_FLTRES,
	FPE_FLTDIV,
	FPE_FLTUND,
	FPE_FLTOVF,
	FPE_FLTINV,
d221 1
a221 1
		trapsignal(p, SIGFPE, fpu_codes[i - 1], fpu_types[i - i], sv);
@


1.9
log
@one more... nuke clause 3 & 4
@
text
@d1 1
a1 1
/*	$OpenBSD: fpu.c,v 1.8 2002/08/12 16:40:51 jason Exp $	*/
d51 1
a51 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.8
log
@Remove a large chunk of `#ifdef notyet' code
@
text
@d1 1
a1 1
/*	$OpenBSD: fpu.c,v 1.7 2002/08/03 15:22:06 jason Exp $	*/
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Jason L. Wright
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.7
log
@Don't depend on curproc, pass the proc * down to the functions that need it (fmovr/fmovcc).
@
text
@d1 1
a1 1
/*	$OpenBSD: fpu.c,v 1.6 2002/07/10 20:30:14 jsyn Exp $	*/
a295 52

#ifdef notyet
/*
 * If we have no FPU at all (are there any machines like this out
 * there!?) we have to emulate each instruction, and we need a pointer
 * to the trapframe so that we can step over them and do FBfcc's.
 * We know the `queue' is empty, though; we just want to emulate
 * the instruction at tf->tf_pc.
 */
fpu_emulate(p, tf, fs)
	struct proc *p;
	register struct trapframe *tf;
#ifndef SUN4U
	register struct fpstate *fs;
#else /* SUN4U */
	register struct fpstate64 *fs;
#endif /* SUN4U */
{

	do {
		fetch instr from pc
		decode
		if (integer instr) {
			/*
			 * We do this here, rather than earlier, to avoid
			 * losing even more badly than usual.
			 */
			if (p->p_addr->u_pcb.pcb_uw) {
				write_user_windows();
				if (rwindow_save(p))
					sigexit(p, SIGILL);
			}
			if (loadstore) {
				do_it;
				pc = npc, npc += 4
			} else if (fbfcc) {
				do_annul_stuff;
			} else
				return;
		} else if (fpu instr) {
			fe.fe_fsr = fs->fs_fsr &= ~FSR_CX;
			error = fpu_execute(p, &fe, fs, instr);
			switch (error) {
				etc;
			}
		} else
			return;
		if (want to reschedule)
			return;
	} while (error == 0);
}
#endif
@


1.6
log
@'sez' is not an english word; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fpu.c,v 1.5 2002/03/14 01:26:45 millert Exp $	*/
d107 2
a108 2
int fpu_insn_fmovcc(struct fpstate64 *, union instr);
int fpu_insn_fmovr(struct fpstate64 *, union instr);
d271 1
a271 1
		error = fpu_execute(&fe, instr);
d337 1
a337 1
			error = fpu_execute(&fe, fs, instr);
d374 2
a375 1
fpu_execute(fe, instr)
d409 1
a409 1
			return (fpu_insn_fmovcc(fs, instr));
d417 1
a417 1
			return (fpu_insn_fmovr(fs, instr));
d912 1
a912 1
 * Handler for FMOV[SDQ][cond] emulation. XXX Assumes we are curproc.
d915 2
a916 1
fpu_insn_fmovcc(fs, instr)
d945 1
a945 1
		cond = (curproc->p_md.md_tf->tf_tstate >> TSTATE_CCR_SHIFT) &
d949 1
a949 1
		cond = (curproc->p_md.md_tf->tf_tstate >>
d964 1
a964 1
 * Handler for FMOVR[icond][SDQ] emulation.  XXX Assumes we are curproc.
d967 2
a968 1
fpu_insn_fmovr(fs, instr)
d987 1
a987 1
		    (int64_t)curproc->p_md.md_tf->tf_global[rs1] != 0)
d992 1
a992 1
		    (int64_t)curproc->p_md.md_tf->tf_global[rs1] > 0)
d997 1
a997 1
		    (int64_t)curproc->p_md.md_tf->tf_global[rs1] >= 0)
d1002 1
a1002 1
		    (int64_t)curproc->p_md.md_tf->tf_global[rs1] == 0)
d1007 1
a1007 1
		    (int64_t)curproc->p_md.md_tf->tf_global[rs1] <= 0)
d1012 1
a1012 1
		    (int64_t)curproc->p_md.md_tf->tf_global[rs1] < 0)
@


1.5
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: fpu.c,v 1.4 2001/09/15 23:42:36 jason Exp $	*/
d237 1
a237 1
			/* The book sez reexecute or emulate. */
@


1.4
log
@Mostly rewritten decode of fpu emulation:
o handles decode of all 64 32 bit registers (based on type)
o easier to read (at least imo).
o needs some optimization (clarity was the first goal here)
@
text
@d1 1
a1 1
/*	$OpenBSD: fpu.c,v 1.2 2001/09/08 22:52:51 jason Exp $	*/
d92 18
a109 18
int fpu_regoffset __P((int, int));
int fpu_insn_fmov __P((struct fpstate64 *, struct fpemu *, union instr));
int fpu_insn_fabs __P((struct fpstate64 *, struct fpemu *, union instr));
int fpu_insn_fneg __P((struct fpstate64 *, struct fpemu *, union instr));
int fpu_insn_itof __P((struct fpemu *, union instr, int, int *,
    int *, u_int *));
int fpu_insn_ftoi __P((struct fpemu *, union instr, int *, int, u_int *));
int fpu_insn_ftof __P((struct fpemu *, union instr, int *, int *, u_int *));
int fpu_insn_fsqrt __P((struct fpemu *, union instr, int *, int *, u_int *));
int fpu_insn_fcmp __P((struct fpstate64 *, struct fpemu *, union instr, int));
int fpu_insn_fmul __P((struct fpemu *, union instr, int *, int *, u_int *));
int fpu_insn_fmulx __P((struct fpemu *, union instr, int *, int *, u_int *));
int fpu_insn_fdiv __P((struct fpemu *, union instr, int *, int *, u_int *));
int fpu_insn_fadd __P((struct fpemu *, union instr, int *, int *, u_int *));
int fpu_insn_fsub __P((struct fpemu *, union instr, int *, int *, u_int *));
int fpu_insn_fmovcc __P((struct fpstate64 *, union instr));
int fpu_insn_fmovr __P((struct fpstate64 *, union instr));
void fpu_fcopy __P((u_int *, u_int *, int));
@


1.4.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: fpu.c,v 1.4 2001/09/15 23:42:36 jason Exp $	*/
d92 18
a109 18
int fpu_regoffset(int, int);
int fpu_insn_fmov(struct fpstate64 *, struct fpemu *, union instr);
int fpu_insn_fabs(struct fpstate64 *, struct fpemu *, union instr);
int fpu_insn_fneg(struct fpstate64 *, struct fpemu *, union instr);
int fpu_insn_itof(struct fpemu *, union instr, int, int *,
    int *, u_int *);
int fpu_insn_ftoi(struct fpemu *, union instr, int *, int, u_int *);
int fpu_insn_ftof(struct fpemu *, union instr, int *, int *, u_int *);
int fpu_insn_fsqrt(struct fpemu *, union instr, int *, int *, u_int *);
int fpu_insn_fcmp(struct fpstate64 *, struct fpemu *, union instr, int);
int fpu_insn_fmul(struct fpemu *, union instr, int *, int *, u_int *);
int fpu_insn_fmulx(struct fpemu *, union instr, int *, int *, u_int *);
int fpu_insn_fdiv(struct fpemu *, union instr, int *, int *, u_int *);
int fpu_insn_fadd(struct fpemu *, union instr, int *, int *, u_int *);
int fpu_insn_fsub(struct fpemu *, union instr, int *, int *, u_int *);
int fpu_insn_fmovcc(struct fpstate64 *, union instr);
int fpu_insn_fmovr(struct fpstate64 *, union instr);
void fpu_fcopy(u_int *, u_int *, int);
@


1.4.6.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: fpu.c,v 1.4.6.1 2002/06/11 03:38:43 art Exp $	*/
d107 2
a108 2
int fpu_insn_fmovcc(struct proc *, struct fpstate64 *, union instr);
int fpu_insn_fmovr(struct proc *, struct fpstate64 *, union instr);
d237 1
a237 1
			/* The book says reexecute or emulate. */
d271 1
a271 1
		error = fpu_execute(p, &fe, instr);
d297 52
d374 1
a374 2
fpu_execute(fpproc, fe, instr)
	struct proc *fpproc;
d408 1
a408 1
			return (fpu_insn_fmovcc(fpproc, fs, instr));
d416 1
a416 1
			return (fpu_insn_fmovr(fpproc, fs, instr));
d911 1
a911 1
 * Handler for FMOV[SDQ][cond] emulation.
d914 1
a914 2
fpu_insn_fmovcc(fpproc, fs, instr)
	struct proc *fpproc;
d943 1
a943 1
		cond = (fpproc->p_md.md_tf->tf_tstate >> TSTATE_CCR_SHIFT) &
d947 1
a947 1
		cond = (fpproc->p_md.md_tf->tf_tstate >>
d962 1
a962 1
 * Handler for FMOVR[icond][SDQ] emulation.
d965 1
a965 2
fpu_insn_fmovr(fpproc, fs, instr)
	struct proc *fpproc;
d984 1
a984 1
		    (int64_t)fpproc->p_md.md_tf->tf_global[rs1] != 0)
d989 1
a989 1
		    (int64_t)fpproc->p_md.md_tf->tf_global[rs1] > 0)
d994 1
a994 1
		    (int64_t)fpproc->p_md.md_tf->tf_global[rs1] >= 0)
d999 1
a999 1
		    (int64_t)fpproc->p_md.md_tf->tf_global[rs1] == 0)
d1004 1
a1004 1
		    (int64_t)fpproc->p_md.md_tf->tf_global[rs1] <= 0)
d1009 1
a1009 1
		    (int64_t)fpproc->p_md.md_tf->tf_global[rs1] < 0)
@


1.4.4.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.4.4.2
log
@Merge in -current from about a week ago
@
text
@d92 18
a109 18
int fpu_regoffset(int, int);
int fpu_insn_fmov(struct fpstate64 *, struct fpemu *, union instr);
int fpu_insn_fabs(struct fpstate64 *, struct fpemu *, union instr);
int fpu_insn_fneg(struct fpstate64 *, struct fpemu *, union instr);
int fpu_insn_itof(struct fpemu *, union instr, int, int *,
    int *, u_int *);
int fpu_insn_ftoi(struct fpemu *, union instr, int *, int, u_int *);
int fpu_insn_ftof(struct fpemu *, union instr, int *, int *, u_int *);
int fpu_insn_fsqrt(struct fpemu *, union instr, int *, int *, u_int *);
int fpu_insn_fcmp(struct fpstate64 *, struct fpemu *, union instr, int);
int fpu_insn_fmul(struct fpemu *, union instr, int *, int *, u_int *);
int fpu_insn_fmulx(struct fpemu *, union instr, int *, int *, u_int *);
int fpu_insn_fdiv(struct fpemu *, union instr, int *, int *, u_int *);
int fpu_insn_fadd(struct fpemu *, union instr, int *, int *, u_int *);
int fpu_insn_fsub(struct fpemu *, union instr, int *, int *, u_int *);
int fpu_insn_fmovcc(struct fpstate64 *, union instr);
int fpu_insn_fmovr(struct fpstate64 *, union instr);
void fpu_fcopy(u_int *, u_int *, int);
@


1.4.4.3
log
@Sync the SMP branch with 3.3
@
text
@d107 2
a108 2
int fpu_insn_fmovcc(struct proc *, struct fpstate64 *, union instr);
int fpu_insn_fmovr(struct proc *, struct fpstate64 *, union instr);
d237 1
a237 1
			/* The book says reexecute or emulate. */
d271 1
a271 1
		error = fpu_execute(p, &fe, instr);
d297 52
d374 1
a374 2
fpu_execute(fpproc, fe, instr)
	struct proc *fpproc;
d408 1
a408 1
			return (fpu_insn_fmovcc(fpproc, fs, instr));
d416 1
a416 1
			return (fpu_insn_fmovr(fpproc, fs, instr));
d911 1
a911 1
 * Handler for FMOV[SDQ][cond] emulation.
d914 1
a914 2
fpu_insn_fmovcc(fpproc, fs, instr)
	struct proc *fpproc;
d943 1
a943 1
		cond = (fpproc->p_md.md_tf->tf_tstate >> TSTATE_CCR_SHIFT) &
d947 1
a947 1
		cond = (fpproc->p_md.md_tf->tf_tstate >>
d962 1
a962 1
 * Handler for FMOVR[icond][SDQ] emulation.
d965 1
a965 2
fpu_insn_fmovr(fpproc, fs, instr)
	struct proc *fpproc;
d984 1
a984 1
		    (int64_t)fpproc->p_md.md_tf->tf_global[rs1] != 0)
d989 1
a989 1
		    (int64_t)fpproc->p_md.md_tf->tf_global[rs1] > 0)
d994 1
a994 1
		    (int64_t)fpproc->p_md.md_tf->tf_global[rs1] >= 0)
d999 1
a999 1
		    (int64_t)fpproc->p_md.md_tf->tf_global[rs1] == 0)
d1004 1
a1004 1
		    (int64_t)fpproc->p_md.md_tf->tf_global[rs1] <= 0)
d1009 1
a1009 1
		    (int64_t)fpproc->p_md.md_tf->tf_global[rs1] < 0)
@


1.4.4.4
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: fpu.c,v 1.4.4.3 2003/03/27 23:42:36 niklas Exp $	*/
d16 5
d56 5
a60 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.3
log
@Add more debugging stuff (including fpstate dumping)
Also, and more importantly, applying the same mask to rs2 and rd is bad ju-ju for the F?TO? instructions.
@
text
@d5 31
d92 19
d112 1
a112 1
int fpe_debug = 0xf;
a125 1

d127 1
a127 1
fpu_dumpstate(struct fpstate64 *fp)
d131 3
a133 5
	for (i = 0; i < 64; i++) {
		printf("%%f%02d: %08x  ", i, fp->fs_regs[i]);
		if ((i & 3) == 3)
			printf("\n");
	}
d177 15
d350 19
a371 3
 *
 * Note that we do not catch all illegal opcodes, so you can, for instance,
 * multiply two integers this way.
d375 1
a375 1
	register struct fpemu *fe;
d378 2
a379 8
	register struct fpn *fp;
#ifndef SUN4U
	register int opf, rs1, rs2, rd, type, mask, fsr, cx;
	register struct fpstate *fs;
#else /* SUN4U */
	register int opf, rs1, rs2, rd, type, mask, fsr, cx, i, cond;
	register struct fpstate64 *fs;
#endif /* SUN4U */
d382 4
a385 5
	/*
	 * `Decode' and execute instruction.  Start with no exceptions.
	 * The type of any i_opf opcode is in the bottom two bits, so we
	 * squish them out here.
	 */
a386 9
	type = opf & 3;
	mask = "\0\0\1\3"[type];
	rs1 = instr.i_opf.i_rs1 & ~mask;
	rs2 = instr.i_opf.i_rs2 & ~mask;
	rd = instr.i_opf.i_rd & ~mask;
#ifdef notdef
	if ((rs1 | rs2 | rd) & mask)
		return (BADREG);
#endif
a387 2
	DPRINTF(FPE_REG, ("BEFORE:\n"));
	DUMPSTATE(FPE_REG, fs);
d390 27
a416 98
#ifdef SUN4U
	/*
	 * Check to see if we're dealing with a fancy cmove and handle
	 * it first.
	 */
	if (instr.i_op3.i_op3 == IOP3_FPop2 && (opf&0xff0) != (FCMP&0xff0)) {
		switch (opf >>= 2) {
		case FMVFC0 >> 2:
			DPRINTF(FPE_INSN, ("fpu_execute: FMVFC0\n"));
			cond = (fs->fs_fsr>>FSR_FCC_SHIFT)&FSR_FCC_MASK;
			if (instr.i_fmovcc.i_cond != cond) return(0); /* success */
			rs1 = fs->fs_regs[rs2];
			goto mov;
		case FMVFC1 >> 2:
			DPRINTF(FPE_INSN, ("fpu_execute: FMVFC1\n"));
			cond = (fs->fs_fsr>>FSR_FCC1_SHIFT)&FSR_FCC_MASK;
			if (instr.i_fmovcc.i_cond != cond) return(0); /* success */
			rs1 = fs->fs_regs[rs2];
			goto mov;
		case FMVFC2 >> 2:
			DPRINTF(FPE_INSN, ("fpu_execute: FMVFC2\n"));
			cond = (fs->fs_fsr>>FSR_FCC2_SHIFT)&FSR_FCC_MASK;
			if (instr.i_fmovcc.i_cond != cond) return(0); /* success */
			rs1 = fs->fs_regs[rs2];
			goto mov;
		case FMVFC3 >> 2:
			DPRINTF(FPE_INSN, ("fpu_execute: FMVFC3\n"));
			cond = (fs->fs_fsr>>FSR_FCC3_SHIFT)&FSR_FCC_MASK;
			if (instr.i_fmovcc.i_cond != cond) return(0); /* success */
			rs1 = fs->fs_regs[rs2];
			goto mov;
		case FMVIC >> 2:
			/* Presume we're curproc */
			DPRINTF(FPE_INSN, ("fpu_execute: FMVIC\n"));
			cond = (curproc->p_md.md_tf->tf_tstate>>TSTATE_CCR_SHIFT)&PSR_ICC;
			if (instr.i_fmovcc.i_cond != cond) return(0); /* success */
			rs1 = fs->fs_regs[rs2];
			goto mov;			
		case FMVXC >> 2:
			/* Presume we're curproc */
			DPRINTF(FPE_INSN, ("fpu_execute: FMVXC\n"));
			cond = (curproc->p_md.md_tf->tf_tstate>>(TSTATE_CCR_SHIFT+XCC_SHIFT))&PSR_ICC;
			if (instr.i_fmovcc.i_cond != cond) return(0); /* success */
			rs1 = fs->fs_regs[rs2];
			goto mov;			
		case FMVRZ >> 2:
			/* Presume we're curproc */
			DPRINTF(FPE_INSN, ("fpu_execute: FMVRZ\n"));
			rs1 = instr.i_fmovr.i_rs1;
			if (rs1 != 0 && (int64_t)curproc->p_md.md_tf->tf_global[rs1] != 0)
				return (0); /* success */
			rs1 = fs->fs_regs[rs2];
			goto mov;			
		case FMVRLEZ >> 2:
			/* Presume we're curproc */
			DPRINTF(FPE_INSN, ("fpu_execute: FMVRLEZ\n"));
			rs1 = instr.i_fmovr.i_rs1;
			if (rs1 != 0 && (int64_t)curproc->p_md.md_tf->tf_global[rs1] > 0)
				return (0); /* success */
			rs1 = fs->fs_regs[rs2];
			goto mov;			
		case FMVRLZ >> 2:
			/* Presume we're curproc */
			DPRINTF(FPE_INSN, ("fpu_execute: FMVRLZ\n"));
			rs1 = instr.i_fmovr.i_rs1;
			if (rs1 == 0 || (int64_t)curproc->p_md.md_tf->tf_global[rs1] >= 0)
				return (0); /* success */
			rs1 = fs->fs_regs[rs2];
			goto mov;			
		case FMVRNZ >> 2:
			/* Presume we're curproc */
			DPRINTF(FPE_INSN, ("fpu_execute: FMVRNZ\n"));
			rs1 = instr.i_fmovr.i_rs1;
			if (rs1 == 0 || (int64_t)curproc->p_md.md_tf->tf_global[rs1] == 0)
				return (0); /* success */
			rs1 = fs->fs_regs[rs2];
			goto mov;			
		case FMVRGZ >> 2:
			/* Presume we're curproc */
			DPRINTF(FPE_INSN, ("fpu_execute: FMVRGZ\n"));
			rs1 = instr.i_fmovr.i_rs1;
			if (rs1 == 0 || (int64_t)curproc->p_md.md_tf->tf_global[rs1] <= 0)
				return (0); /* success */
			rs1 = fs->fs_regs[rs2];
			goto mov;			
		case FMVRGEZ >> 2:
			/* Presume we're curproc */
			DPRINTF(FPE_INSN, ("fpu_execute: FMVRGEZ\n"));
			rs1 = instr.i_fmovr.i_rs1;
			if (rs1 != 0 && (int64_t)curproc->p_md.md_tf->tf_global[rs1] < 0)
				return (0); /* success */
			rs1 = fs->fs_regs[rs2];
			goto mov;		
		default:
			DPRINTF(FPE_INSN, 
				("fpu_execute: unknown v9 FP inst %x opf %x\n", 
					instr.i_int, opf));
			return (NOTFPU);
d418 1
a419 3
#endif /* SUN4U */
	DPRINTF(FPE_INSN, ("opf: %x\n", opf));
	switch (opf >>= 2) {
d421 48
a468 30
	default:
		DPRINTF(FPE_INSN, 
			("fpu_execute: unknown basic FP inst %x opf %x\n",
				instr.i_int, opf));
		return (NOTFPU);

	case FMOV >> 2:		/* these should all be pretty obvious */
		DPRINTF(FPE_INSN, ("fpu_execute: FMOV\n"));
		rs1 = fs->fs_regs[rs2];
		goto mov;

	case FNEG >> 2:
		DPRINTF(FPE_INSN, ("fpu_execute: FNEG\n"));
		rs1 = fs->fs_regs[rs2] ^ (1 << 31);
		goto mov;

	case FABS >> 2:
		DPRINTF(FPE_INSN, ("fpu_execute: FABS\n"));
		rs1 = fs->fs_regs[rs2] & ~(1 << 31);
	mov:
#ifndef SUN4U
		fs->fs_regs[rd] = rs1;
#else /* SUN4U */
		i = 1<<type;
		fs->fs_regs[rd++] = rs1;
		while (--i) 
			fs->fs_regs[rd++] = fs->fs_regs[++rs2];
#endif /* SUN4U */
		fs->fs_fsr = fe->fe_fsr;
		return (0);	/* success */
d470 4
a473 64
	case FSQRT >> 2:
		DPRINTF(FPE_INSN, ("fpu_execute: FSQRT\n"));
		fpu_explode(fe, &fe->fe_f1, type, rs2);
		fp = fpu_sqrt(fe);
		break;

	case FADD >> 2:
		DPRINTF(FPE_INSN, ("fpu_execute: FADD (%d %d -> %d)\n",
		    instr.i_opf.i_rs1, instr.i_opf.i_rs2, instr.i_opf.i_rd));
		fpu_explode(fe, &fe->fe_f1, type, rs1);
		fpu_explode(fe, &fe->fe_f2, type, rs2);
		fp = fpu_add(fe);
		break;

	case FSUB >> 2:
		DPRINTF(FPE_INSN, ("fpu_execute: FSUB\n"));
		fpu_explode(fe, &fe->fe_f1, type, rs1);
		fpu_explode(fe, &fe->fe_f2, type, rs2);
		fp = fpu_sub(fe);
		break;

	case FMUL >> 2:
		DPRINTF(FPE_INSN, ("fpu_execute: FMUL\n"));
		fpu_explode(fe, &fe->fe_f1, type, rs1);
		fpu_explode(fe, &fe->fe_f2, type, rs2);
		fp = fpu_mul(fe);
		break;

	case FDIV >> 2:
		DPRINTF(FPE_INSN, ("fpu_execute: FDIV\n"));
		fpu_explode(fe, &fe->fe_f1, type, rs1);
		fpu_explode(fe, &fe->fe_f2, type, rs2);
		fp = fpu_div(fe);
		break;

	case FCMP >> 2:
		DPRINTF(FPE_INSN, ("fpu_execute: FCMP\n"));
		fpu_explode(fe, &fe->fe_f1, type, rs1);
		fpu_explode(fe, &fe->fe_f2, type, rs2);
		fpu_compare(fe, 0);
		goto cmpdone;

	case FCMPE >> 2:
		DPRINTF(FPE_INSN, ("fpu_execute: FCMPE\n"));
		fpu_explode(fe, &fe->fe_f1, type, rs1);
		fpu_explode(fe, &fe->fe_f2, type, rs2);
		fpu_compare(fe, 1);
	cmpdone:
		/*
		 * The only possible exception here is NV; catch it
		 * early and get out, as there is no result register.
		 */
		cx = fe->fe_cx;
		fsr = fe->fe_fsr | (cx << FSR_CX_SHIFT);
		if (cx != 0) {
			if (fsr & (FSR_NV << FSR_TEM_SHIFT)) {
				fs->fs_fsr = (fsr & ~FSR_FTT) |
				    (FSR_TT_IEEE << FSR_FTT_SHIFT);
				return (FPE);
			}
			fsr |= FSR_NV << FSR_AX_SHIFT;
		}
		fs->fs_fsr = fsr;
		return (0);
d475 3
a477 9
	case FSMULD >> 2:
	case FDMULX >> 2:
		DPRINTF(FPE_INSN, ("fpu_execute: FSMULx\n"));
		if (type == FTYPE_EXT)
			return (NOTFPU);
		fpu_explode(fe, &fe->fe_f1, type, rs1);
		fpu_explode(fe, &fe->fe_f2, type, rs2);
		type++;	/* single to double, or double to quad */
		fp = fpu_mul(fe);
d480 3
a482 9
#ifdef SUN4U
	case FXTOS >> 2:
	case FXTOD >> 2:
	case FXTOQ >> 2:
		DPRINTF(FPE_INSN, ("fpu_execute: FXTOx (%d -> %d)\n",
		    instr.i_opf.i_rs2, instr.i_opf.i_rd));
		type = FTYPE_LNG;
		fpu_explode(fe, fp = &fe->fe_f1, type, rs2);
		type = opf & 3;	/* sneaky; depends on instruction encoding */
d485 3
a487 5
	case FTOX >> 2:
		DPRINTF(FPE_INSN, ("fpu_execute: FTOX\n"));
		rd = instr.i_opf.i_rd & (~1);
		fpu_explode(fe, fp = &fe->fe_f1, type, rs2);
		type = FTYPE_LNG;
a488 1
#endif /* SUN4U */
d490 3
a492 17
	case FTOS >> 2:
	case FTOI >> 2:
		rd = instr.i_opf.i_rd;
		goto fto;
	case FTOD >> 2:
		rd = instr.i_opf.i_rd & (~1);
		goto fto;

	case FTOQ >> 2:
		rd = instr.i_opf.i_rd & (~3);
		goto fto;

fto:
		DPRINTF(FPE_INSN, ("fpu_execute: FTOx (%d -> %d)\n",
		    instr.i_opf.i_rs2, instr.i_opf.i_rd));
		fpu_explode(fe, fp = &fe->fe_f1, type, rs2);
		type = opf & 3;	/* sneaky; depends on instruction encoding */
d494 2
a497 7
	/*
	 * ALU operation is complete.  Collapse the result and then check
	 * for exceptions.  If we got any, and they are enabled, do not
	 * alter the destination register, just stop with an exception.
	 * Otherwise set new current exceptions and accrue.
	 */
	fpu_implode(fe, fp, type, space);
d512 230
a741 6
	fs->fs_regs[rd] = space[0];
	if (type >= FTYPE_DBL || type == FTYPE_LNG) {
		fs->fs_regs[rd + 1] = space[1];
		if (type > FTYPE_DBL) {
			fs->fs_regs[rd + 2] = space[2];
			fs->fs_regs[rd + 3] = space[3];
d743 209
d953 65
a1017 4
	DPRINTF(FPE_REG, ("AFTER (rd %d, type %d, space %x/%x/%x/%x):\n", rd, type,
	    space[0], space[1], space[2], space[3]));
	DUMPSTATE(FPE_REG, fs);
	return (0);	/* success */
@


1.2
log
@From NetBSD: debugging stuff to dump fpn's
@
text
@d1 1
a1 1
/*	$OpenBSD: fpu.c,v 1.1 2001/09/08 22:33:51 jason Exp $	*/
d62 1
a62 1
int fpe_debug = 0;
d76 12
d326 2
d431 1
d472 2
a473 1
		DPRINTF(FPE_INSN, ("fpu_execute: FADD\n"));
d545 2
a546 1
		DPRINTF(FPE_INSN, ("fpu_execute: FXTOx\n"));
d553 2
a554 1
		DPRINTF(FPE_INSN, ("fpu_execute: FTOx\n"));
d561 3
d565 3
d569 6
a574 2
	case FTOI >> 2:
		DPRINTF(FPE_INSN, ("fpu_execute: FTOx\n"));
d609 3
@


1.1
log
@Import netbsd's fpu handling (modified to be separate from sparc); this is
for paranoia's sake (don't want to break sparc32 while hacking on it).
Real work by art.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d60 17
@

