head	1.33;
access;
symbols
	OPENBSD_6_2_BASE:1.33
	OPENBSD_6_1:1.31.0.18
	OPENBSD_6_1_BASE:1.31
	OPENBSD_6_0:1.31.0.14
	OPENBSD_6_0_BASE:1.31
	OPENBSD_5_9:1.31.0.10
	OPENBSD_5_9_BASE:1.31
	OPENBSD_5_8:1.31.0.12
	OPENBSD_5_8_BASE:1.31
	OPENBSD_5_7:1.31.0.4
	OPENBSD_5_7_BASE:1.31
	OPENBSD_5_6:1.31.0.8
	OPENBSD_5_6_BASE:1.31
	OPENBSD_5_5:1.31.0.6
	OPENBSD_5_5_BASE:1.31
	OPENBSD_5_4:1.31.0.2
	OPENBSD_5_4_BASE:1.31
	OPENBSD_5_3:1.30.0.12
	OPENBSD_5_3_BASE:1.30
	OPENBSD_5_2:1.30.0.10
	OPENBSD_5_2_BASE:1.30
	OPENBSD_5_1_BASE:1.30
	OPENBSD_5_1:1.30.0.8
	OPENBSD_5_0:1.30.0.6
	OPENBSD_5_0_BASE:1.30
	OPENBSD_4_9:1.30.0.4
	OPENBSD_4_9_BASE:1.30
	OPENBSD_4_8:1.30.0.2
	OPENBSD_4_8_BASE:1.30
	OPENBSD_4_7:1.27.0.2
	OPENBSD_4_7_BASE:1.27
	OPENBSD_4_6:1.25.0.8
	OPENBSD_4_6_BASE:1.25
	OPENBSD_4_5:1.25.0.4
	OPENBSD_4_5_BASE:1.25
	OPENBSD_4_4:1.25.0.2
	OPENBSD_4_4_BASE:1.25
	OPENBSD_4_3:1.24.0.2
	OPENBSD_4_3_BASE:1.24
	OPENBSD_4_2:1.19.0.6
	OPENBSD_4_2_BASE:1.19
	OPENBSD_4_1:1.19.0.4
	OPENBSD_4_1_BASE:1.19
	OPENBSD_4_0:1.19.0.2
	OPENBSD_4_0_BASE:1.19
	OPENBSD_3_9:1.17.0.8
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.17.0.6
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.17.0.2
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.17.0.4
	OPENBSD_3_6_BASE:1.17
	SMP_SYNC_A:1.16
	SMP_SYNC_B:1.16
	OPENBSD_3_5:1.16.0.2
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.14.0.2
	OPENBSD_3_4_BASE:1.14
	UBC_SYNC_A:1.11
	OPENBSD_3_3:1.10.0.2
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.9.0.2
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	UBC_SYNC_B:1.9
	UBC:1.1.0.4
	UBC_BASE:1.1
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.33
date	2017.09.08.05.36.52;	author deraadt;	state Exp;
branches;
next	1.32;
commitid	uRv5pa9QDlZaYgwD;

1.32
date	2017.04.30.16.45.45;	author mpi;	state Exp;
branches;
next	1.31;
commitid	2Gtqjzrin9LL2yHk;

1.31
date	2013.05.30.16.15.01;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2010.07.02.17.27.01;	author nicm;	state Exp;
branches;
next	1.29;

1.29
date	2010.06.28.14.13.31;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2010.04.12.12.57.52;	author tedu;	state Exp;
branches;
next	1.27;

1.27
date	2009.11.09.17.53.39;	author nicm;	state Exp;
branches;
next	1.26;

1.26
date	2009.10.31.06.40.16;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2008.05.24.00.11.31;	author kettenis;	state Exp;
branches;
next	1.24;

1.24
date	2008.03.01.16.03.04;	author kettenis;	state Exp;
branches;
next	1.23;

1.23
date	2008.01.15.19.42.15;	author kettenis;	state Exp;
branches;
next	1.22;

1.22
date	2008.01.08.05.08.32;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2007.11.14.20.43.12;	author kettenis;	state Exp;
branches;
next	1.20;

1.20
date	2007.11.13.13.50.10;	author kettenis;	state Exp;
branches;
next	1.19;

1.19
date	2006.05.28.22.41.44;	author jason;	state Exp;
branches;
next	1.18;

1.18
date	2006.05.28.17.10.52;	author jason;	state Exp;
branches;
next	1.17;

1.17
date	2004.07.17.21.27.30;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2003.12.16.15.08.50;	author jason;	state Exp;
branches;
next	1.15;

1.15
date	2003.10.03.16.44.50;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2003.08.15.20.32.15;	author tedu;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.24.21.54.39;	author henric;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.02.20.02.49;	author jason;	state Exp;
branches;
next	1.11;

1.11
date	2003.05.13.23.55.54;	author henric;	state Exp;
branches;
next	1.10;

1.10
date	2003.02.17.01.29.20;	author henric;	state Exp;
branches;
next	1.9;

1.9
date	2002.09.23.18.43.18;	author jason;	state Exp;
branches;
next	1.8;

1.8
date	2002.07.18.02.22.19;	author jason;	state Exp;
branches;
next	1.7;

1.7
date	2002.04.08.17.49.42;	author jason;	state Exp;
branches;
next	1.6;

1.6
date	2002.03.14.01.26.44;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.01.18.21.15.56;	author jason;	state Exp;
branches;
next	1.4;

1.4
date	2002.01.17.21.23.24;	author jason;	state Exp;
branches;
next	1.3;

1.3
date	2002.01.17.19.30.07;	author jason;	state Exp;
branches;
next	1.2;

1.2
date	2002.01.17.05.39.16;	author jason;	state Exp;
branches;
next	1.1;

1.1
date	2001.10.28.02.19.16;	author jason;	state Exp;
branches
	1.1.2.1
	1.1.4.1;
next	;

1.1.2.1
date	2001.11.13.21.04.17;	author niklas;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2002.03.06.02.04.46;	author niklas;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2002.03.28.11.23.51;	author niklas;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2003.03.27.23.42.35;	author niklas;	state Exp;
branches;
next	1.1.2.5;

1.1.2.5
date	2003.05.16.00.29.40;	author niklas;	state Exp;
branches;
next	1.1.2.6;

1.1.2.6
date	2003.06.07.11.14.44;	author ho;	state Exp;
branches;
next	1.1.2.7;

1.1.2.7
date	2004.02.19.10.50.00;	author niklas;	state Exp;
branches;
next	;

1.1.4.1
date	2002.01.31.22.55.24;	author niklas;	state Exp;
branches;
next	1.1.4.2;

1.1.4.2
date	2002.06.11.03.38.43;	author art;	state Exp;
branches;
next	1.1.4.3;

1.1.4.3
date	2002.10.29.00.28.11;	author art;	state Exp;
branches;
next	1.1.4.4;

1.1.4.4
date	2003.05.19.21.46.57;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.33
log
@If you use sys/param.h, you don't need sys/types.h
@
text
@/*	$OpenBSD: sab.c,v 1.32 2017/04/30 16:45:45 mpi Exp $	*/

/*
 * Copyright (c) 2001 Jason L. Wright (jason@@thought.net)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * Effort sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F30602-01-2-0537.
 *
 */

/*
 * SAB82532 Dual UART driver
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/conf.h>
#include <sys/file.h>
#include <sys/ioctl.h>
#include <sys/kernel.h>
#include <sys/proc.h>
#include <sys/tty.h>
#include <sys/time.h>
#include <sys/syslog.h>

#include <machine/autoconf.h>
#include <machine/openfirm.h>
#include <machine/conf.h>
#include <machine/cpu.h>
#include <machine/psl.h>

#include <dev/cons.h>
#include <ddb/db_output.h>

#include <sparc64/dev/ebusreg.h>
#include <sparc64/dev/ebusvar.h>
#include <sparc64/dev/cons.h>
#include <sparc64/dev/sab82532reg.h>

#define	SAB_CARD(x)	((minor(x) >> 6) & 3)
#define	SAB_PORT(x)	(minor(x) & 7)
#define	SAB_DIALOUT(x)	(minor(x) & 0x10)
#define	SABTTY_RBUF_SIZE	1024	/* must be divisible by 2 */

struct sab_softc {
	struct device		sc_dv;
	struct intrhand *	sc_ih;
	bus_space_tag_t		sc_bt;
	bus_space_handle_t	sc_bh;
	struct sabtty_softc *	sc_child[SAB_NCHAN];
	u_int			sc_nchild;
	void *			sc_softintr;
	int			sc_node;
};

struct sabtty_attach_args {
	u_int sbt_portno;
};

struct sabtty_softc {
	struct device		sc_dv;
	struct sab_softc *	sc_parent;
	bus_space_tag_t		sc_bt;
	bus_space_handle_t	sc_bh;
	struct tty *		sc_tty;
	u_int			sc_portno;
	u_int8_t		sc_pvr_dtr, sc_pvr_dsr;
	u_int8_t		sc_imr0, sc_imr1;
	int			sc_openflags;
	u_char *		sc_txp;
	int			sc_txc;
	int			sc_flags;
#define SABTTYF_STOP		0x01
#define	SABTTYF_DONE		0x02
#define	SABTTYF_RINGOVERFLOW	0x04
#define	SABTTYF_CDCHG		0x08
#define	SABTTYF_CONS_IN		0x10
#define	SABTTYF_CONS_OUT	0x20
#define	SABTTYF_TXDRAIN		0x40
#define	SABTTYF_DONTDDB		0x80
	int			sc_speed;
	u_int8_t		sc_rbuf[SABTTY_RBUF_SIZE];
	u_int8_t		*sc_rend, *sc_rput, *sc_rget;
	u_int8_t		sc_polling, sc_pollrfc;
};

struct sabtty_softc *sabtty_cons_input;
struct sabtty_softc *sabtty_cons_output;

#define	SAB_READ(sc,r)		\
    bus_space_read_1((sc)->sc_bt, (sc)->sc_bh, (r))
#define	SAB_WRITE(sc,r,v)	\
    bus_space_write_1((sc)->sc_bt, (sc)->sc_bh, (r), (v))
#define	SAB_WRITE_BLOCK(sc,r,p,c)	\
    bus_space_write_region_1((sc)->sc_bt, (sc)->sc_bh, (r), (p), (c))

int sab_match(struct device *, void *, void *);
void sab_attach(struct device *, struct device *, void *);

int sab_print(void *, const char *);
int sab_intr(void *);
void sab_softintr(void *);
void sab_cnputc(dev_t, int);
int sab_cngetc(dev_t);
void sab_cnpollc(dev_t, int);

int sabtty_match(struct device *, void *, void *);
void sabtty_attach(struct device *, struct device *, void *);
int sabtty_activate(struct device *, int);

void sabtty_start(struct tty *);
int sabtty_param(struct tty *, struct termios *);
int sabtty_intr(struct sabtty_softc *, int *);
void sabtty_softintr(struct sabtty_softc *);
int sabtty_mdmctrl(struct sabtty_softc *, int, int);
int sabtty_cec_wait(struct sabtty_softc *);
int sabtty_tec_wait(struct sabtty_softc *);
void sabtty_reset(struct sabtty_softc *);
void sabtty_flush(struct sabtty_softc *);
int sabtty_speed(int);
void sabtty_console_flags(struct sabtty_softc *);
void sabtty_console_speed(struct sabtty_softc *);
void sabtty_cnpollc(struct sabtty_softc *, int);
void sabtty_shutdown(struct sabtty_softc *);
int sabttyparam(struct sabtty_softc *, struct tty *, struct termios *);

int sabttyopen(dev_t, int, int, struct proc *);
int sabttyclose(dev_t, int, int, struct proc *);
int sabttyread(dev_t, struct uio *, int);
int sabttywrite(dev_t, struct uio *, int);
int sabttyioctl(dev_t, u_long, caddr_t, int, struct proc *);
int sabttystop(struct tty *, int);
struct tty *sabttytty(dev_t);
void sabtty_cnputc(struct sabtty_softc *, int);
int sabtty_cngetc(struct sabtty_softc *);
void sabtty_abort(struct sabtty_softc *);

struct cfattach sab_ca = {
	sizeof(struct sab_softc), sab_match, sab_attach
};

struct cfdriver sab_cd = {
	NULL, "sab", DV_DULL
};

struct cfattach sabtty_ca = {
	sizeof(struct sabtty_softc), sabtty_match, sabtty_attach,
	NULL, sabtty_activate
};

struct cfdriver sabtty_cd = {
	NULL, "sabtty", DV_TTY
};

struct sabtty_rate {
	int baud;
	int n, m;
};

struct sabtty_rate sabtty_baudtable[] = {
	{      50,	35,     10 },
	{      75,	47,	9 },
	{     110,	32,	9 },
	{     134,	53,	8 },
	{     150,	47,	8 },
	{     200,	35,	8 },
	{     300,	47,	7 },
	{     600,	47,	6 },
	{    1200,	47,	5 },
	{    1800,	31,	5 },
	{    2400,	47,	4 },
	{    4800,	47,	3 },
	{    9600,	47,	2 },
	{   19200,	47,	1 },
	{   38400,	23,	1 },
	{   57600,	15,	1 },
	{  115200,	 7,	1 },
	{  230400,	 3,	1 },
	{  460800,	 1,	1 },
	{   76800,	11,	1 },
	{  153600,	 5,	1 },
	{  307200,	 3,	1 },
	{  614400,	 3,	0 },
	{  921600,	 0,	1 },
};

int
sab_match(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	struct ebus_attach_args *ea = aux;
	char *compat;

	if (strcmp(ea->ea_name, "se") == 0 ||
	    strcmp(ea->ea_name, "FJSV,se") == 0)
		return (1);
	compat = getpropstring(ea->ea_node, "compatible");
	if (compat != NULL && !strcmp(compat, "sab82532"))
		return (1);
	return (0);
}

void
sab_attach(parent, self, aux)
	struct device *parent;
	struct device *self;
	void *aux;
{
	struct sab_softc *sc = (struct sab_softc *)self;
	struct ebus_attach_args *ea = aux;
	u_int8_t r;
	u_int i;

	sc->sc_bt = ea->ea_memtag;
	sc->sc_node = ea->ea_node;

	/* Use prom mapping, if available. */
	if (ea->ea_nvaddrs) {
		if (bus_space_map(sc->sc_bt, ea->ea_vaddrs[0],
		    0, BUS_SPACE_MAP_PROMADDRESS, &sc->sc_bh) != 0) {
			printf(": can't map register space\n");
			return;
		}
	} else if (ebus_bus_map(sc->sc_bt, 0,
	    EBUS_PADDR_FROM_REG(&ea->ea_regs[0]), ea->ea_regs[0].size, 0, 0,
	    &sc->sc_bh) != 0) {
		printf(": can't map register space\n");
		return;
	}

	BUS_SPACE_SET_FLAGS(sc->sc_bt, sc->sc_bh, BSHDB_NO_ACCESS);

	sc->sc_ih = bus_intr_establish(sc->sc_bt, ea->ea_intrs[0],
	    IPL_TTY, 0, sab_intr, sc, self->dv_xname);
	if (sc->sc_ih == NULL) {
		printf(": can't map interrupt\n");
		return;
	}

	sc->sc_softintr = softintr_establish(IPL_TTY, sab_softintr, sc);
	if (sc->sc_softintr == NULL) {
		printf(": can't get soft intr\n");
		return;
	}

	printf(": rev ");
	r = SAB_READ(sc, SAB_VSTR) & SAB_VSTR_VMASK;
	switch (r) {
	case SAB_VSTR_V_1:
		printf("1");
		break;
	case SAB_VSTR_V_2:
		printf("2");
		break;
	case SAB_VSTR_V_32:
		printf("3.2");
		break;
	default:
		printf("unknown(0x%x)", r);
		break;
	}
	printf("\n");

	/* Let current output drain */
	DELAY(100000);

	/* Set all pins, except DTR pins to be inputs */
	SAB_WRITE(sc, SAB_PCR, ~(SAB_PVR_DTR_A | SAB_PVR_DTR_B));
	/* Disable port interrupts */
	SAB_WRITE(sc, SAB_PIM, 0xff);
	SAB_WRITE(sc, SAB_PVR, SAB_PVR_DTR_A | SAB_PVR_DTR_B | SAB_PVR_MAGIC);
	SAB_WRITE(sc, SAB_IPC, SAB_IPC_ICPL);

	for (i = 0; i < SAB_NCHAN; i++) {
		struct sabtty_attach_args sta;

		sta.sbt_portno = i;
		sc->sc_child[i] = (struct sabtty_softc *)config_found_sm(self,
		    &sta, sab_print, sabtty_match);
		if (sc->sc_child[i] != NULL)
			sc->sc_nchild++;
	}
}

int
sabtty_activate(struct device *self, int act)
{
	struct sabtty_softc *sc = (struct sabtty_softc *)self;
	int ret = 0;

	switch (act) {
	case DVACT_POWERDOWN:
		if (sc->sc_flags & SABTTYF_CONS_IN)
			sabtty_shutdown(sc);
		break;
	}

	return (ret);
}

int
sab_print(args, name)
	void *args;
	const char *name;
{
	struct sabtty_attach_args *sa = args;

	if (name)
		printf("sabtty at %s", name);
	printf(" port %d", sa->sbt_portno);
	return (UNCONF);
}

int
sab_intr(vsc)
	void *vsc;
{
	struct sab_softc *sc = vsc;
	int r = 0, needsoft = 0;
	u_int8_t gis;

	gis = SAB_READ(sc, SAB_GIS);

	/* channel A */
	if ((gis & (SAB_GIS_ISA1 | SAB_GIS_ISA0)) && sc->sc_child[0] &&
	    sc->sc_child[0]->sc_tty)
		r |= sabtty_intr(sc->sc_child[0], &needsoft);

	/* channel B */
	if ((gis & (SAB_GIS_ISB1 | SAB_GIS_ISB0)) && sc->sc_child[1] &&
	    sc->sc_child[1]->sc_tty)
		r |= sabtty_intr(sc->sc_child[1], &needsoft);

	if (needsoft)
		softintr_schedule(sc->sc_softintr);

	return (r);
}

void
sab_softintr(vsc)
	void *vsc;
{
	struct sab_softc *sc = vsc;

	if (sc->sc_child[0] && sc->sc_child[0]->sc_tty)
		sabtty_softintr(sc->sc_child[0]);
	if (sc->sc_child[1] && sc->sc_child[1]->sc_tty)
		sabtty_softintr(sc->sc_child[1]);
}

int
sabtty_match(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	struct sabtty_attach_args *sa = aux;

	if (sa->sbt_portno < SAB_NCHAN)
		return (1);
	return (0);
}

void
sabtty_attach(parent, self, aux)
	struct device *parent;
	struct device *self;
	void *aux;
{
	struct sabtty_softc *sc = (struct sabtty_softc *)self;
	struct sabtty_attach_args *sa = aux;
	int r;

	sc->sc_tty = ttymalloc(0);
	sc->sc_tty->t_oproc = sabtty_start;
	sc->sc_tty->t_param = sabtty_param;

	sc->sc_parent = (struct sab_softc *)parent;
	sc->sc_bt = sc->sc_parent->sc_bt;
	sc->sc_portno = sa->sbt_portno;
	sc->sc_rend = sc->sc_rbuf + SABTTY_RBUF_SIZE;

	switch (sa->sbt_portno) {
	case 0:	/* port A */
		sc->sc_pvr_dtr = SAB_PVR_DTR_A;
		sc->sc_pvr_dsr = SAB_PVR_DSR_A;
		r = bus_space_subregion(sc->sc_bt, sc->sc_parent->sc_bh,
		    SAB_CHAN_A, SAB_CHANLEN, &sc->sc_bh);
		break;
	case 1:	/* port B */
		sc->sc_pvr_dtr = SAB_PVR_DTR_B;
		sc->sc_pvr_dsr = SAB_PVR_DSR_B;
		r = bus_space_subregion(sc->sc_bt, sc->sc_parent->sc_bh,
		    SAB_CHAN_B, SAB_CHANLEN, &sc->sc_bh);
		break;
	default:
		printf(": invalid channel: %u\n", sa->sbt_portno);
		return;
	}
	if (r != 0) {
		printf(": failed to allocate register subregion\n");
		return;
	}

	sabtty_console_flags(sc);
	sabtty_console_speed(sc);

	if (sc->sc_flags & (SABTTYF_CONS_IN | SABTTYF_CONS_OUT)) {
		struct termios t;
		char *acc;

		switch (sc->sc_flags & (SABTTYF_CONS_IN | SABTTYF_CONS_OUT)) {
		case SABTTYF_CONS_IN:
			acc = " input";
			break;
		case SABTTYF_CONS_OUT:
			acc = " output";
			break;
		case SABTTYF_CONS_IN|SABTTYF_CONS_OUT:
		default:
			acc = "";
			break;
		}

		if (sc->sc_flags & SABTTYF_CONS_OUT) {
			/* Let current output drain */
			DELAY(100000);
		}

		t.c_ispeed = 0;
		t.c_ospeed = sc->sc_speed;
		t.c_cflag = CREAD | CS8 | HUPCL;
		sc->sc_tty->t_ospeed = 0;
		sabttyparam(sc, sc->sc_tty, &t);

		if (sc->sc_flags & SABTTYF_CONS_IN) {
			sabtty_cons_input = sc;
			cn_tab->cn_pollc = sab_cnpollc;
			cn_tab->cn_getc = sab_cngetc;
			cn_tab->cn_dev = makedev(77/*XXX*/, self->dv_unit);
		}

		if (sc->sc_flags & SABTTYF_CONS_OUT) {
			sabtty_cons_output = sc;
			cn_tab->cn_putc = sab_cnputc;
			cn_tab->cn_dev = makedev(77/*XXX*/, self->dv_unit);
		}
		printf(": console%s", acc);
	} else {
		/* Not a console... */
		sabtty_reset(sc);
	}

	printf("\n");
}

int
sabtty_intr(sc, needsoftp)
	struct sabtty_softc *sc;
	int *needsoftp;
{
	u_int8_t isr0, isr1;
	int i, len = 0, needsoft = 0, r = 0, clearfifo = 0;

	isr0 = SAB_READ(sc, SAB_ISR0);
	isr1 = SAB_READ(sc, SAB_ISR1);

	if (isr0 || isr1)
		r = 1;

	if (isr0 & SAB_ISR0_RPF) {
		len = 32;
		clearfifo = 1;
	}
	if (isr0 & SAB_ISR0_TCD) {
		len = (32 - 1) & SAB_READ(sc, SAB_RBCL);
		clearfifo = 1;
	}
	if (isr0 & SAB_ISR0_TIME) {
		sabtty_cec_wait(sc);
		SAB_WRITE(sc, SAB_CMDR, SAB_CMDR_RFRD);
	}
	if (isr0 & SAB_ISR0_RFO) {
		sc->sc_flags |= SABTTYF_RINGOVERFLOW;
		clearfifo = 1;
	}
	if (len != 0) {
		u_int8_t *ptr;

		ptr = sc->sc_rput;
		for (i = 0; i < len; i++) {
			*ptr++ = SAB_READ(sc, SAB_RFIFO);
			if (ptr == sc->sc_rend)
				ptr = sc->sc_rbuf;
			if (ptr == sc->sc_rget) {
				if (ptr == sc->sc_rbuf)
					ptr = sc->sc_rend;
				ptr--;
				sc->sc_flags |= SABTTYF_RINGOVERFLOW;
			}
		}
		sc->sc_rput = ptr;
		needsoft = 1;
	}

	if (clearfifo) {
		sabtty_cec_wait(sc);
		SAB_WRITE(sc, SAB_CMDR, SAB_CMDR_RMC);
	}

	if (isr0 & SAB_ISR0_CDSC) {
		sc->sc_flags |= SABTTYF_CDCHG;
		needsoft = 1;
	}

	if (isr1 & SAB_ISR1_BRKT)
		sabtty_abort(sc);

	if (isr1 & (SAB_ISR1_XPR | SAB_ISR1_ALLS)) {
		if ((SAB_READ(sc, SAB_STAR) & SAB_STAR_XFW) &&
		    (sc->sc_flags & SABTTYF_STOP) == 0) {
			if (sc->sc_txc < 32)
				len = sc->sc_txc;
			else
				len = 32;

			if (len > 0) {
				SAB_WRITE_BLOCK(sc, SAB_XFIFO, sc->sc_txp, len);
				sc->sc_txp += len; 
				sc->sc_txc -= len;

				sabtty_cec_wait(sc);
				SAB_WRITE(sc, SAB_CMDR, SAB_CMDR_XF);

				/*
				 * Prevent the false end of xmit from
				 * confusing things below.
				 */
				isr1 &= ~SAB_ISR1_ALLS;
			}
		}

		if ((sc->sc_txc == 0) || (sc->sc_flags & SABTTYF_STOP)) {
			if ((sc->sc_imr1 & SAB_IMR1_XPR) == 0) {
				sc->sc_imr1 |= SAB_IMR1_XPR;
				sc->sc_imr1 &= ~SAB_IMR1_ALLS;
				SAB_WRITE(sc, SAB_IMR1, sc->sc_imr1);
			}
		}
	}

	if ((isr1 & SAB_ISR1_ALLS) && ((sc->sc_txc == 0) ||
	    (sc->sc_flags & SABTTYF_STOP))) {
		if (sc->sc_flags & SABTTYF_TXDRAIN)
			wakeup(sc);
		sc->sc_flags &= ~SABTTYF_STOP;
		sc->sc_flags |= SABTTYF_DONE;
		sc->sc_imr1 |= SAB_IMR1_ALLS;
		SAB_WRITE(sc, SAB_IMR1, sc->sc_imr1);
		needsoft = 1;
	}

	if (needsoft)
		*needsoftp = needsoft;
	return (r);
}

void
sabtty_softintr(sc)
	struct sabtty_softc *sc;
{
	struct tty *tp = sc->sc_tty;
	int s, flags;
	u_int8_t r;

	if (tp == NULL)
		return;

	if ((tp->t_state & TS_ISOPEN) == 0)
		return;

	while (sc->sc_rget != sc->sc_rput) {
		int data;
		u_int8_t stat;

		data = sc->sc_rget[0];
		stat = sc->sc_rget[1];
		sc->sc_rget += 2;
		if (stat & SAB_RSTAT_PE)
			data |= TTY_PE;
		if (stat & SAB_RSTAT_FE)
			data |= TTY_FE;
		if (sc->sc_rget == sc->sc_rend)
			sc->sc_rget = sc->sc_rbuf;

		(*linesw[tp->t_line].l_rint)(data, tp);
	}

	s = splhigh();
	flags = sc->sc_flags;
	sc->sc_flags &= ~(SABTTYF_DONE|SABTTYF_CDCHG|SABTTYF_RINGOVERFLOW);
	splx(s);

	if (flags & SABTTYF_CDCHG) {
		s = spltty();
		r = SAB_READ(sc, SAB_VSTR) & SAB_VSTR_CD;
		splx(s);

		(*linesw[tp->t_line].l_modem)(tp, r);
	}

	if (flags & SABTTYF_RINGOVERFLOW)
		log(LOG_WARNING, "%s: ring overflow\n", sc->sc_dv.dv_xname);

	if (flags & SABTTYF_DONE) {
		ndflush(&tp->t_outq, sc->sc_txp - tp->t_outq.c_cf);
		tp->t_state &= ~TS_BUSY;
		(*linesw[tp->t_line].l_start)(tp);
	}
}

int
sabttyopen(dev, flags, mode, p)
	dev_t dev;
	int flags, mode;
	struct proc *p;
{
	struct sab_softc *bc;
	struct sabtty_softc *sc;
	struct tty *tp;
	int card = SAB_CARD(dev), port = SAB_PORT(dev), s, s1;

	if (card >= sab_cd.cd_ndevs)
		return (ENXIO);
	bc = sab_cd.cd_devs[card];
	if (bc == NULL)
		return (ENXIO);

	if (port >= bc->sc_nchild)
		return (ENXIO);
	sc = bc->sc_child[port];
	if (sc == NULL)
		return (ENXIO);

	tp = sc->sc_tty;
	tp->t_dev = dev;

	if ((tp->t_state & TS_ISOPEN) == 0) {
		tp->t_state |= TS_WOPEN;

		ttychars(tp);
		tp->t_iflag = TTYDEF_IFLAG;
		tp->t_oflag = TTYDEF_OFLAG;
		tp->t_cflag = TTYDEF_CFLAG;
		if (sc->sc_openflags & TIOCFLAG_CLOCAL)
			tp->t_cflag |= CLOCAL;
		if (sc->sc_openflags & TIOCFLAG_CRTSCTS)
			tp->t_cflag |= CRTSCTS;
		if (sc->sc_openflags & TIOCFLAG_MDMBUF)
			tp->t_cflag |= MDMBUF;
		tp->t_lflag = TTYDEF_LFLAG;
		if (sc->sc_flags & (SABTTYF_CONS_IN | SABTTYF_CONS_OUT))
			tp->t_ispeed = tp->t_ospeed = sc->sc_speed;
		else
			tp->t_ispeed = tp->t_ospeed = TTYDEF_SPEED;

		sc->sc_rput = sc->sc_rget = sc->sc_rbuf;

		s = spltty();

		ttsetwater(tp);

		s1 = splhigh();
		sabtty_reset(sc);
		sabtty_param(tp, &tp->t_termios);
		sc->sc_imr0 = SAB_IMR0_PERR | SAB_IMR0_FERR | SAB_IMR0_PLLA;
		SAB_WRITE(sc, SAB_IMR0, sc->sc_imr0);
		sc->sc_imr1 = SAB_IMR1_BRK | SAB_IMR1_ALLS | SAB_IMR1_XDU |
		    SAB_IMR1_TIN | SAB_IMR1_CSC | SAB_IMR1_XMR | SAB_IMR1_XPR;
		SAB_WRITE(sc, SAB_IMR1, sc->sc_imr1);
		SAB_WRITE(sc, SAB_CCR0, SAB_READ(sc, SAB_CCR0) | SAB_CCR0_PU);
		sabtty_cec_wait(sc);
		SAB_WRITE(sc, SAB_CMDR, SAB_CMDR_XRES);
		sabtty_cec_wait(sc);
		SAB_WRITE(sc, SAB_CMDR, SAB_CMDR_RRES);
		sabtty_cec_wait(sc);
		splx(s1);

		sabtty_flush(sc);

		if ((sc->sc_openflags & TIOCFLAG_SOFTCAR) ||
		    (SAB_READ(sc, SAB_VSTR) & SAB_VSTR_CD))
			tp->t_state |= TS_CARR_ON;
		else
			tp->t_state &= ~TS_CARR_ON;
	} else if ((tp->t_state & TS_XCLUDE) &&
	    (!suser(p, 0))) {
		return (EBUSY);
	} else {
		s = spltty();
	}

	if ((flags & O_NONBLOCK) == 0) {
		while ((tp->t_cflag & CLOCAL) == 0 &&
		    (tp->t_state & TS_CARR_ON) == 0) {
			int error;

			tp->t_state |= TS_WOPEN;
			error = ttysleep(tp, &tp->t_rawq, TTIPRI | PCATCH,
			    "sabttycd", 0);
			if (error != 0) {
				splx(s);
				tp->t_state &= ~TS_WOPEN;
				return (error);
			}
		}
	}

	splx(s);

	s = (*linesw[tp->t_line].l_open)(dev, tp, p);
	if (s != 0) {
		if (tp->t_state & TS_ISOPEN)
			return (s);

		if (tp->t_cflag & HUPCL) {
			sabtty_mdmctrl(sc, 0, DMSET);
			(void)tsleep(sc, TTIPRI, ttclos, hz);
		}

		if ((sc->sc_flags & (SABTTYF_CONS_IN | SABTTYF_CONS_OUT)) == 0) {
			/* Flush and power down if we're not the console */
			sabtty_flush(sc);
			sabtty_reset(sc);
		}
	}
	return (s);
}

int
sabttyclose(dev, flags, mode, p)
	dev_t dev;
	int flags, mode;
	struct proc *p;
{
	struct sab_softc *bc = sab_cd.cd_devs[SAB_CARD(dev)];
	struct sabtty_softc *sc = bc->sc_child[SAB_PORT(dev)];
	struct tty *tp = sc->sc_tty;
	int s;

	(*linesw[tp->t_line].l_close)(tp, flags, p);

	s = spltty();

	if ((tp->t_state & TS_ISOPEN) == 0) {
		/* Wait for output drain */
		sc->sc_imr1 &= ~SAB_IMR1_ALLS;
		SAB_WRITE(sc, SAB_IMR1, sc->sc_imr1);
		sc->sc_flags |= SABTTYF_TXDRAIN;
		(void)tsleep(sc, TTIPRI, ttclos, 5 * hz);
		sc->sc_imr1 |= SAB_IMR1_ALLS;
		SAB_WRITE(sc, SAB_IMR1, sc->sc_imr1);
		sc->sc_flags &= ~SABTTYF_TXDRAIN;

		if (tp->t_cflag & HUPCL) {
			sabtty_mdmctrl(sc, 0, DMSET);
			(void)tsleep(bc, TTIPRI, ttclos, hz);
		}

		if ((sc->sc_flags & (SABTTYF_CONS_IN | SABTTYF_CONS_OUT)) == 0) {
			/* Flush and power down if we're not the console */
			sabtty_flush(sc);
			sabtty_reset(sc);
		}
	}

	ttyclose(tp);
	splx(s);

	return (0);
}

int
sabttyread(dev, uio, flags)
	dev_t dev;
	struct uio *uio;
	int flags;
{
	struct sab_softc *bc = sab_cd.cd_devs[SAB_CARD(dev)];
	struct sabtty_softc *sc = bc->sc_child[SAB_PORT(dev)];
	struct tty *tp = sc->sc_tty;

	return ((*linesw[tp->t_line].l_read)(tp, uio, flags));
}

int
sabttywrite(dev, uio, flags)
	dev_t dev;
	struct uio *uio;
	int flags;
{
	struct sab_softc *bc = sab_cd.cd_devs[SAB_CARD(dev)];
	struct sabtty_softc *sc = bc->sc_child[SAB_PORT(dev)];
	struct tty *tp = sc->sc_tty;

	return ((*linesw[tp->t_line].l_write)(tp, uio, flags));
}

int
sabttyioctl(dev, cmd, data, flags, p)
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flags;
	struct proc *p;
{
	struct sab_softc *bc = sab_cd.cd_devs[SAB_CARD(dev)];
	struct sabtty_softc *sc = bc->sc_child[SAB_PORT(dev)];
	struct tty *tp = sc->sc_tty;
	int error;

	error = (*linesw[tp->t_line].l_ioctl)(tp, cmd, data, flags, p);
	if (error >= 0)
		return (error);

	error = ttioctl(tp, cmd, data, flags, p);
	if (error >= 0)
		return (error);

	error = 0;

	switch (cmd) {
	case TIOCSBRK:
		SAB_WRITE(sc, SAB_DAFO,
		    SAB_READ(sc, SAB_DAFO) | SAB_DAFO_XBRK);
		break;
	case TIOCCBRK:
		SAB_WRITE(sc, SAB_DAFO,
		    SAB_READ(sc, SAB_DAFO) & ~SAB_DAFO_XBRK);
		break;
	case TIOCSDTR:
		sabtty_mdmctrl(sc, TIOCM_DTR, DMBIS);
		break;
	case TIOCCDTR:
		sabtty_mdmctrl(sc, TIOCM_DTR, DMBIC);
		break;
	case TIOCMBIS:
		sabtty_mdmctrl(sc, *((int *)data), DMBIS);
		break;
	case TIOCMBIC:
		sabtty_mdmctrl(sc, *((int *)data), DMBIC);
		break;
	case TIOCMGET:
		*((int *)data) = sabtty_mdmctrl(sc, 0, DMGET);
		break;
	case TIOCMSET:
		sabtty_mdmctrl(sc, *((int *)data), DMSET);
		break;
	case TIOCGFLAGS:
		*((int *)data) = sc->sc_openflags;
		break;
	case TIOCSFLAGS:
		if (suser(p, 0))
			error = EPERM;
		else
			sc->sc_openflags = *((int *)data) &
			    (TIOCFLAG_SOFTCAR | TIOCFLAG_CLOCAL |
			     TIOCFLAG_CRTSCTS | TIOCFLAG_MDMBUF);
		break;
	default:
		error = ENOTTY;
	}

	return (error);
}

struct tty *
sabttytty(dev)
	dev_t dev;
{
	struct sab_softc *bc = sab_cd.cd_devs[SAB_CARD(dev)];
	struct sabtty_softc *sc = bc->sc_child[SAB_PORT(dev)];

	return (sc->sc_tty);
}

int
sabttystop(tp, flags)
	struct tty *tp;
	int flags;
{
	struct sab_softc *bc = sab_cd.cd_devs[SAB_CARD(tp->t_dev)];
	struct sabtty_softc *sc = bc->sc_child[SAB_PORT(tp->t_dev)];
	int s;

	s = spltty();
	if (tp->t_state & TS_BUSY) {
		if ((tp->t_state & TS_TTSTOP) == 0)
			tp->t_state |= TS_FLUSH;
		sc->sc_flags |= SABTTYF_STOP;
		sc->sc_imr1 &= ~SAB_IMR1_ALLS;
		SAB_WRITE(sc, SAB_IMR1, sc->sc_imr1);
	}
	splx(s);
	return (0);
}

int
sabtty_mdmctrl(sc, bits, how)
	struct sabtty_softc *sc;
	int bits, how;
{
	u_int8_t r;
	int s;

	s = spltty();
	switch (how) {
	case DMGET:
		bits = 0;
		if (SAB_READ(sc, SAB_STAR) & SAB_STAR_CTS)
			bits |= TIOCM_CTS;
		if ((SAB_READ(sc, SAB_VSTR) & SAB_VSTR_CD) == 0)
			bits |= TIOCM_CD;

		r = SAB_READ(sc, SAB_PVR);
		if ((r & sc->sc_pvr_dtr) == 0)
			bits |= TIOCM_DTR;
		if ((r & sc->sc_pvr_dsr) == 0)
			bits |= TIOCM_DSR;

		r = SAB_READ(sc, SAB_MODE);
		if ((r & (SAB_MODE_RTS|SAB_MODE_FRTS)) == SAB_MODE_RTS)
			bits |= TIOCM_RTS;
		break;
	case DMSET:
		r = SAB_READ(sc, SAB_MODE);
		if (bits & TIOCM_RTS) {
			r &= ~SAB_MODE_FRTS;
			r |= SAB_MODE_RTS;
		} else
			r |= SAB_MODE_FRTS | SAB_MODE_RTS;
		SAB_WRITE(sc, SAB_MODE, r);

		r = SAB_READ(sc, SAB_PVR);
		if (bits & TIOCM_DTR)
			r &= ~sc->sc_pvr_dtr;
		else
			r |= sc->sc_pvr_dtr;
		SAB_WRITE(sc, SAB_PVR, r);
		break;
	case DMBIS:
		if (bits & TIOCM_RTS) {
			r = SAB_READ(sc, SAB_MODE);
			r &= ~SAB_MODE_FRTS;
			r |= SAB_MODE_RTS;
			SAB_WRITE(sc, SAB_MODE, r);
		}
		if (bits & TIOCM_DTR) {
			r = SAB_READ(sc, SAB_PVR);
			r &= ~sc->sc_pvr_dtr;
			SAB_WRITE(sc, SAB_PVR, r);
		}
		break;
	case DMBIC:
		if (bits & TIOCM_RTS) {
			r = SAB_READ(sc, SAB_MODE);
			r |= SAB_MODE_FRTS | SAB_MODE_RTS;
			SAB_WRITE(sc, SAB_MODE, r);
		}
		if (bits & TIOCM_DTR) {
			r = SAB_READ(sc, SAB_PVR);
			r |= sc->sc_pvr_dtr;
			SAB_WRITE(sc, SAB_PVR, r);
		}
		break;
	}
	splx(s);
	return (bits);
}

int
sabttyparam(sc, tp, t)
	struct sabtty_softc *sc;
	struct tty *tp;
	struct termios *t;
{
	int s, ospeed;
	tcflag_t cflag;
	u_int8_t dafo, r;

	ospeed = sabtty_speed(t->c_ospeed);
	if (ospeed < 0 || (t->c_ispeed && t->c_ispeed != t->c_ospeed))
		return (EINVAL);

	s = spltty();

	/* hang up line if ospeed is zero, otherwise raise dtr */
	sabtty_mdmctrl(sc, TIOCM_DTR,
	    (t->c_ospeed == 0) ? DMBIC : DMBIS);

	dafo = SAB_READ(sc, SAB_DAFO);

	cflag = t->c_cflag;

	if (sc->sc_flags & (SABTTYF_CONS_IN | SABTTYF_CONS_OUT)) {
		cflag |= CLOCAL;
		cflag &= ~HUPCL;
	}

	if (cflag & CSTOPB)
		dafo |= SAB_DAFO_STOP;
	else
		dafo &= ~SAB_DAFO_STOP;

	dafo &= ~SAB_DAFO_CHL_CSIZE;
	switch (cflag & CSIZE) {
	case CS5:
		dafo |= SAB_DAFO_CHL_CS5;
		break;
	case CS6:
		dafo |= SAB_DAFO_CHL_CS6;
		break;
	case CS7:
		dafo |= SAB_DAFO_CHL_CS7;
		break;
	default:
		dafo |= SAB_DAFO_CHL_CS8;
		break;
	}

	dafo &= ~SAB_DAFO_PARMASK;
	if (cflag & PARENB) {
		if (cflag & PARODD)
			dafo |= SAB_DAFO_PAR_ODD;
		else
			dafo |= SAB_DAFO_PAR_EVEN;
	} else
		dafo |= SAB_DAFO_PAR_NONE;

	if (ospeed != 0) {
		SAB_WRITE(sc, SAB_BGR, ospeed & 0xff);
		r = SAB_READ(sc, SAB_CCR2);
		r &= ~(SAB_CCR2_BR9 | SAB_CCR2_BR8);
		r |= (ospeed >> 2) & (SAB_CCR2_BR9 | SAB_CCR2_BR8);
		SAB_WRITE(sc, SAB_CCR2, r);
	}

	r = SAB_READ(sc, SAB_MODE);
	r |= SAB_MODE_RAC;
	if (cflag & CRTSCTS) {
		r &= ~(SAB_MODE_RTS | SAB_MODE_FCTS);
		r |= SAB_MODE_FRTS;
		sc->sc_imr1 &= ~SAB_IMR1_CSC;
	} else {
		r |= SAB_MODE_RTS | SAB_MODE_FCTS;
		r &= ~SAB_MODE_FRTS;
		sc->sc_imr1 |= SAB_IMR1_CSC;
	}
	SAB_WRITE(sc, SAB_MODE, r);
	SAB_WRITE(sc, SAB_IMR1, sc->sc_imr1);

	tp->t_cflag = cflag;

	splx(s);
	return (0);
}

int
sabtty_param(tp, t)
	struct tty *tp;
	struct termios *t;
{
	struct sab_softc *bc = sab_cd.cd_devs[SAB_CARD(tp->t_dev)];
	struct sabtty_softc *sc = bc->sc_child[SAB_PORT(tp->t_dev)];

	return (sabttyparam(sc, tp, t));
}

void
sabtty_start(tp)
	struct tty *tp;
{
	struct sab_softc *bc = sab_cd.cd_devs[SAB_CARD(tp->t_dev)];
	struct sabtty_softc *sc = bc->sc_child[SAB_PORT(tp->t_dev)];
	int s;

	s = spltty();
	if ((tp->t_state & (TS_TTSTOP | TS_TIMEOUT | TS_BUSY)) == 0) {
		ttwakeupwr(tp);
		if (tp->t_outq.c_cc) {
			sc->sc_txc = ndqb(&tp->t_outq, 0);
			sc->sc_txp = tp->t_outq.c_cf;
			tp->t_state |= TS_BUSY;
			sc->sc_imr1 &= ~(SAB_ISR1_XPR | SAB_ISR1_ALLS);
			SAB_WRITE(sc, SAB_IMR1, sc->sc_imr1);
		}
	}
	splx(s);
}

int
sabtty_cec_wait(struct sabtty_softc *sc)
{
	int i = 50000;

	for (;;) {
		if ((SAB_READ(sc, SAB_STAR) & SAB_STAR_CEC) == 0)
			return (0);
		if (--i == 0)
			return (1);
		DELAY(1);
	}
}

int
sabtty_tec_wait(struct sabtty_softc *sc)
{
	int i = 200000;

	for (;;) {
		if ((SAB_READ(sc, SAB_STAR) & SAB_STAR_TEC) == 0)
			return (0);
		if (--i == 0)
			return (1);
		DELAY(1);
	}
}

void
sabtty_reset(sc)
	struct sabtty_softc *sc;
{
	/* power down */
	SAB_WRITE(sc, SAB_CCR0, 0);

	/* set basic configuration */
	SAB_WRITE(sc, SAB_CCR0,
	    SAB_CCR0_MCE | SAB_CCR0_SC_NRZ | SAB_CCR0_SM_ASYNC);
	SAB_WRITE(sc, SAB_CCR1, SAB_CCR1_ODS | SAB_CCR1_BCR | SAB_CCR1_CM_7);
	SAB_WRITE(sc, SAB_CCR2, SAB_CCR2_BDF | SAB_CCR2_SSEL | SAB_CCR2_TOE);
	SAB_WRITE(sc, SAB_CCR3, 0);
	SAB_WRITE(sc, SAB_CCR4, SAB_CCR4_MCK4 | SAB_CCR4_EBRG);
	SAB_WRITE(sc, SAB_MODE, SAB_MODE_RTS | SAB_MODE_FCTS | SAB_MODE_RAC);
	SAB_WRITE(sc, SAB_RFC,
	    SAB_RFC_DPS | SAB_RFC_RFDF | SAB_RFC_RFTH_32CHAR);

	/* clear interrupts */
	sc->sc_imr0 = sc->sc_imr1 = 0xff;
	SAB_WRITE(sc, SAB_IMR0, sc->sc_imr0);
	SAB_WRITE(sc, SAB_IMR1, sc->sc_imr1);
	SAB_READ(sc, SAB_ISR0);
	SAB_READ(sc, SAB_ISR1);
}

void
sabtty_flush(sc)
	struct sabtty_softc *sc;
{
	/* clear rx fifo */
	sabtty_cec_wait(sc);
	SAB_WRITE(sc, SAB_CMDR, SAB_CMDR_RRES);

	/* clear tx fifo */
	sabtty_cec_wait(sc);
	SAB_WRITE(sc, SAB_CMDR, SAB_CMDR_XRES);
}

int
sabtty_speed(rate)
	int rate;
{
	int i, len, r;

	if (rate == 0)
		return (0);
	len = sizeof(sabtty_baudtable)/sizeof(sabtty_baudtable[0]);
	for (i = 0; i < len; i++) {
		if (rate == sabtty_baudtable[i].baud) {
			r = sabtty_baudtable[i].n |
			    (sabtty_baudtable[i].m << 6);
			return (r);
		}
	}
	return (-1);
}

void
sabtty_cnputc(sc, c)
	struct sabtty_softc *sc;
	int c;
{
	sabtty_tec_wait(sc);
	SAB_WRITE(sc, SAB_TIC, c);
	sabtty_tec_wait(sc);
}

int
sabtty_cngetc(sc)
	struct sabtty_softc *sc;
{
	u_int8_t r, len, ipc;

	ipc = SAB_READ(sc, SAB_IPC);
	SAB_WRITE(sc, SAB_IPC, ipc | SAB_IPC_VIS);

again:
	do {
		r = SAB_READ(sc, SAB_STAR);
	} while ((r & SAB_STAR_RFNE) == 0);

	/*
	 * Ok, at least one byte in RFIFO, ask for permission to access RFIFO
	 * (I hate this chip... hate hate hate).
	 */
	sabtty_cec_wait(sc);
	SAB_WRITE(sc, SAB_CMDR, SAB_CMDR_RFRD);

	/* Wait for RFIFO to come ready */
	do {
		r = SAB_READ(sc, SAB_ISR0);
	} while ((r & SAB_ISR0_TCD) == 0);

	len = SAB_READ(sc, SAB_RBCL) & (32 - 1);
	if (len == 0)
		goto again;	/* Shouldn't happen... */

	r = SAB_READ(sc, SAB_RFIFO);

	/*
	 * Blow away everything left in the FIFO...
	 */
	sabtty_cec_wait(sc);
	SAB_WRITE(sc, SAB_CMDR, SAB_CMDR_RMC);
	SAB_WRITE(sc, SAB_IPC, ipc);
	return (r);
}

void
sabtty_cnpollc(sc, on)
	struct sabtty_softc *sc;
	int on;
{
	u_int8_t r;

	if (on) {
		if (sc->sc_polling)
			return;
		SAB_WRITE(sc, SAB_IPC, SAB_READ(sc, SAB_IPC) | SAB_IPC_VIS);
		r = sc->sc_pollrfc = SAB_READ(sc, SAB_RFC);
		r &= ~(SAB_RFC_RFDF);
		SAB_WRITE(sc, SAB_RFC, r);
		sabtty_cec_wait(sc);
		SAB_WRITE(sc, SAB_CMDR, SAB_CMDR_RRES);
		sc->sc_polling = 1;
	} else {
		if (!sc->sc_polling)
			return;
		SAB_WRITE(sc, SAB_IPC, SAB_READ(sc, SAB_IPC) & ~SAB_IPC_VIS);
		SAB_WRITE(sc, SAB_RFC, sc->sc_pollrfc);
		sabtty_cec_wait(sc);
		SAB_WRITE(sc, SAB_CMDR, SAB_CMDR_RRES);
		sc->sc_polling = 0;
	}
}

void
sab_cnputc(dev, c)
	dev_t dev;
	int c;
{
	struct sabtty_softc *sc = sabtty_cons_output;

	if (sc == NULL)
		return;
	sabtty_cnputc(sc, c);
}

void
sab_cnpollc(dev, on)
	dev_t dev;
	int on;
{
	struct sabtty_softc *sc = sabtty_cons_input;

	sabtty_cnpollc(sc, on);
}

int
sab_cngetc(dev)
	dev_t dev;
{
	struct sabtty_softc *sc = sabtty_cons_input;

	if (sc == NULL)
		return (-1);
	return (sabtty_cngetc(sc));
}

void
sabtty_console_flags(sc)
	struct sabtty_softc *sc;
{
	int node, channel, options, cookie;
	char buf[255];

	node = sc->sc_parent->sc_node;
	channel = sc->sc_portno;

	options = OF_finddevice("/options");

	/* Default to channel 0 if there are no explicit prom args */
	cookie = 0;

	if (node == OF_instance_to_package(OF_stdin())) {
		if (OF_getprop(options, "input-device", buf,
		    sizeof(buf)) != -1) {
			if (strncmp("ttyb", buf, strlen("ttyb")) == 0)
				cookie = 1;
		}

		if (channel == cookie)
			sc->sc_flags |= SABTTYF_CONS_IN;
	}

	/* Default to same channel if there are no explicit prom args */

	if (node == OF_instance_to_package(OF_stdout())) {
		if (OF_getprop(options, "output-device", buf,
		    sizeof(buf)) != -1) {
			if (strncmp("ttyb", buf, strlen("ttyb")) == 0)
				cookie = 1;
		}

		if (channel == cookie)
			sc->sc_flags |= SABTTYF_CONS_OUT;
	}
}

void
sabtty_console_speed(sc)
	struct sabtty_softc *sc;
{
	char *name;
	int node, channel, options;

	node = sc->sc_parent->sc_node;
	channel = sc->sc_portno;

	if (getpropint(node, "ssp-console", -1) == channel) {
		sc->sc_speed = getpropspeed(node, "ssp-console-modes");
		return;
	}
	if (getpropint(node, "ssp-control", -1) == channel) {
		sc->sc_speed = getpropspeed(node, "ssp-control-modes");
		return;
	}

	options = OF_finddevice("/options");
	name = sc->sc_portno ? "ttyb-mode" : "ttya-mode";
	sc->sc_speed = getpropspeed(options, name);
}

void
sabtty_abort(sc)
	struct sabtty_softc *sc;
{

	if (sc->sc_flags & SABTTYF_CONS_IN) {
#ifdef DDB
		extern int db_active, db_console;

		if (db_console == 0)
			return;
		if (db_active == 0)
			db_enter();
		else
			callrom();
#else
		callrom();
#endif
	}
}

void
sabtty_shutdown(struct sabtty_softc *sc)
{
	/* Have to put the chip back into single char mode */
	sc->sc_flags |= SABTTYF_DONTDDB;
	SAB_WRITE(sc, SAB_RFC, SAB_READ(sc, SAB_RFC) & ~SAB_RFC_RFDF);
	sabtty_cec_wait(sc);
	SAB_WRITE(sc, SAB_CMDR, SAB_CMDR_RRES);
	sabtty_cec_wait(sc);
	SAB_WRITE(sc, SAB_IPC, SAB_READ(sc, SAB_IPC) | SAB_IPC_VIS);
}
@


1.32
log
@Rename Debugger() into db_enter().

Using a name with the 'db_' prefix makes it invisible from the dynamic
profiler.

ok deraadt@@, kettenis@@, visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sab.c,v 1.31 2013/05/30 16:15:01 deraadt Exp $	*/
a37 1
#include <sys/types.h>
@


1.31
log
@Enforce ca_activate tree-walks over the entire heirarchy for all events,
cleaning up some shutdown-hook related code on the way.
(A few drivers related to sparc are still skipped at kettenis' request)
ok kettenis mlarkin, tested by many others too
@
text
@d1 1
a1 1
/*	$OpenBSD: sab.c,v 1.30 2010/07/02 17:27:01 nicm Exp $	*/
d1401 1
a1401 1
			Debugger();
@


1.30
log
@Move common code for waking up writers on a tty into a function.

ok deraadt matthew millert
@
text
@d1 1
a1 1
/*	$OpenBSD: sab.c,v 1.29 2010/06/28 14:13:31 deraadt Exp $	*/
d124 1
d134 2
d149 1
a149 1
void sabtty_shutdown(void *);
d172 2
a173 1
	sizeof(struct sabtty_softc), sabtty_match, sabtty_attach
d312 16
a466 1
			shutdownhook_establish(sabtty_shutdown, sc);
d1411 1
a1411 2
sabtty_shutdown(vsc)
	void *vsc;
a1412 2
	struct sabtty_softc *sc = vsc;

@


1.29
log
@Allow tty drivers to request larger buffers at attach time using a
max-baud-rate hint.  Adjust TTYHOG (the nearly full logic) to this new
situation.  The larger buffers are required by the very high speed
KDDI devices in Japan (CF com, or USB ucom) so those are the only two
drivers which currently ask for a larger buffer size.
ok yasuoka miod
@
text
@d1 1
a1 1
/*	$OpenBSD: sab.c,v 1.28 2010/04/12 12:57:52 tedu Exp $	*/
d1096 1
a1096 7
		if (tp->t_outq.c_cc <= tp->t_lowat) {
			if (tp->t_state & TS_ASLEEP) {
				tp->t_state &= ~TS_ASLEEP;
				wakeup(&tp->t_outq);
			}
			selwakeup(&tp->t_wsel);
		}
@


1.28
log
@Some of the line disciplines want to check for suser.  Better to pass them
a process instead of using curproc.  ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: sab.c,v 1.27 2009/11/09 17:53:39 nicm Exp $	*/
d380 1
a380 1
	sc->sc_tty = ttymalloc();
@


1.27
log
@Every selwakeup() should have a matching KNOTE() (even if kqueue isn't
supported it doesn't do any harm), so put the KNOTE() in selwakeup() itself and
remove it from any occurences where both are used, except one for kqueue itself
and one in sys_pipe.c (where the selwakeup is under a PIPE_SEL flag).

Based on a diff from tedu.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: sab.c,v 1.26 2009/10/31 06:40:16 deraadt Exp $	*/
d728 1
a728 1
	s = (*linesw[tp->t_line].l_open)(dev, tp);
d758 1
a758 1
	(*linesw[tp->t_line].l_close)(tp, flags);
@


1.26
log
@Add missing KNOTE() calls after selwakeup(), until we decide if the KNOTE()
calls can go directly into selwakeup() safely
long discussion with nicm, murmers of consent from tedu and miod, noone
else seems to care of kqueue is busted as long as it makes their sockets
move data fast... pretty sad.
@
text
@d1 1
a1 1
/*	$OpenBSD: sab.c,v 1.25 2008/05/24 00:11:31 kettenis Exp $	*/
a1101 1
			KNOTE(&tp->t_wsel.si_note, 0);
@


1.25
log
@Match serial devices on PRIMEPOWER 650.
@
text
@d1 1
a1 1
/*	$OpenBSD: sab.c,v 1.24 2008/03/01 16:03:04 kettenis Exp $	*/
d1102 1
@


1.24
log
@Use getpropspeed() to get console speed.  Add code to handle "ssp-console" and
"ssp-control" as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: sab.c,v 1.23 2008/01/15 19:42:15 kettenis Exp $	*/
d216 2
a217 1
	if (strcmp(ea->ea_name, "se") == 0)
@


1.23
log
@Make sabtty(4) adopt the speed configured in OpenFirmware when it is the
console.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sab.c,v 1.22 2008/01/08 05:08:32 deraadt Exp $	*/
d1355 2
a1356 2
	int options, i;
	char buf[255];
d1358 2
a1359 1
	options = OF_finddevice("/options");
d1361 7
a1367 8
	if (OF_getprop(options, sc->sc_portno ? "ttyb-mode" : "ttya-mode",
	    buf, sizeof(buf)) != -1) {
		for (i = 0; i < sizeof(buf); i++) {
			if (buf[i] < '0' || buf[i] > '9')
				break;
			sc->sc_speed *= 10;
			sc->sc_speed += buf[i] - '0';
		}
d1370 3
a1372 2
	if (sc->sc_speed == 0)
		sc->sc_speed = TTYDEF_SPEED;
@


1.22
log
@Be uniform with console message from other devices
@
text
@d1 1
a1 1
/*	$OpenBSD: sab.c,v 1.21 2007/11/14 20:43:12 kettenis Exp $	*/
d106 1
d144 1
d411 1
d436 1
a436 1
		t.c_ospeed = 9600;
d668 4
a671 1
		tp->t_ispeed = tp->t_ospeed = TTYDEF_SPEED;
d1315 1
a1315 2
	int node, channel, cookie;
	u_int options;
d1349 23
@


1.21
log
@Remove eeprom.h.
@
text
@d1 1
a1 1
/*	$OpenBSD: sab.c,v 1.20 2007/11/13 13:50:10 kettenis Exp $	*/
d416 1
a416 1
			acc = "input";
d419 1
a419 1
			acc = "output";
d423 1
a423 1
			acc = "i/o";
d451 1
a451 1
		printf(": console %s", acc);
@


1.20
log
@Remove bsd_openprom.h.
@
text
@d1 1
a1 1
/*	$OpenBSD: sab.c,v 1.19 2006/05/28 22:41:44 jason Exp $	*/
a54 1
#include <machine/eeprom.h>
@


1.19
log
@make sure the IMR values are visible when we drop back into the prom
@
text
@d1 1
a1 1
/*	$OpenBSD: sab.c,v 1.18 2006/05/28 17:10:52 jason Exp $	*/
a52 1
#include <machine/bsd_openprom.h>
@


1.18
log
@make the ISR bits visible so we can poll them in cngetc (w/out cnpollc).
I still hate this chip.
@
text
@d1 1
a1 1
/*	$OpenBSD: sab.c,v 1.17 2004/07/17 21:27:30 miod Exp $	*/
d1381 1
@


1.17
log
@Wait for output to be drained when sabtty is the console output port;
produces nicer (correct) kernel output upon bootup.
Reported in NetBSD PR #26226; tested by dlg@@ and I.
@
text
@d1 1
a1 1
/*	$OpenBSD: sab.c,v 1.16 2003/12/16 15:08:50 jason Exp $	*/
d1110 1
a1110 2
sabtty_cec_wait(sc)
	struct sabtty_softc *sc;
d1124 1
a1124 2
sabtty_tec_wait(sc)
	struct sabtty_softc *sc;
d1209 4
a1212 1
	u_int8_t r, len;
d1242 1
@


1.16
log
@Don't need linear mappings here either
@
text
@d1 1
a1 1
/*	$OpenBSD: sab.c,v 1.15 2003/10/03 16:44:50 miod Exp $	*/
d429 6
a434 1
		t.c_ispeed= 0;
@


1.15
log
@Merge tty_attach() in ttymalloc() and tty_detach() in ttyfree(). The need for
separate tty registering is gone now that sparc has switched to wscons, and
this makes the code less error-prone.

Also, remove tests for ttymalloc() failure, since it uses M_WAITOK.

ok millert@@ deraadt@@, tested by various people as well besides me...
@
text
@d1 1
a1 1
/*	$OpenBSD: sab.c,v 1.14 2003/08/15 20:32:15 tedu Exp $	*/
d246 2
a247 2
	    EBUS_PADDR_FROM_REG(&ea->ea_regs[0]), ea->ea_regs[0].size,
	    BUS_SPACE_MAP_LINEAR, 0, &sc->sc_bh) != 0) {
@


1.14
log
@change arguments to suser.  suser now takes the process, and a flags
argument.  old cred only calls user suser_ucred.  this will allow future
work to more flexibly implement the idea of a root process.  looks like
something i saw in freebsd, but a little different.
use of suser_ucred vs suser in file system code should be looked at again,
for the moment semantics remain unchanged.
review and input from art@@  testing and further review miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sab.c,v 1.13 2003/06/24 21:54:39 henric Exp $	*/
a379 5
	if (sc->sc_tty == NULL) {
		printf(": failed to allocate tty\n");
		return;
	}
	tty_attach(sc->sc_tty);
@


1.13
log
@Add a "where" argument to the sparc64 interrupt code.  This lets us
associate a name with each interrupt handler.  This is not visible
outside the kernel (yet).

ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sab.c,v 1.12 2003/06/02 20:02:49 jason Exp $	*/
d699 1
a699 1
	    (!suser(p->p_ucred, &p->p_acflag))) {
d865 1
a865 1
		if (suser(p->p_ucred, &p->p_acflag))
@


1.12
log
@nuke terms 3 & 4
@
text
@d1 1
a1 1
/*	$OpenBSD: sab.c,v 1.11 2003/05/13 23:55:54 henric Exp $	*/
d255 1
a255 1
	    IPL_TTY, 0, sab_intr, sc);
@


1.11
log
@The sab driver sometimes gets out of sync with the hardware.  This can
cause the serial console to hang.

ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sab.c,v 1.10 2003/02/17 01:29:20 henric Exp $	*/
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Jason L. Wright
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.10
log
@
Add support for the Sun Enterprise 450
Reduce the size of a GENERIC kernel by ~190k
Remove the nasty pointer/bus_space_handle_t casts
Adds debug bus_space code including the ability to trace
    bus operations (it actually works now).

The following rules are now followed (and verfified by the debug
code):

1.  A "bus_space_handle_t" may only be used with the
    "bus_space_tag_t" that created it.
2.  Only "bus_space_map()" may create "bus_space_handle_t"s.
3.  A "bus_space_handle_t" may not be modified after it has
    been created (other than being destroyed by "bus_space_unmap()").


Thanks to help from mcbride, marc, jason, drahn, to anyone that might
have slipped my mind at the moment.

ok jason@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sab.c,v 1.9 2002/09/23 18:43:18 jason Exp $	*/
d125 2
d144 2
a145 2
void sabtty_cec_wait(struct sabtty_softc *);
void sabtty_tec_wait(struct sabtty_softc *);
d290 3
a438 3
		/* Let current output drain */
		DELAY(100000);

d529 3
a531 13
	if (isr1 & SAB_ISR1_ALLS) {
		if (sc->sc_flags & SABTTYF_TXDRAIN)
			wakeup(sc);
		sc->sc_flags &= ~SABTTYF_STOP;
		sc->sc_flags |= SABTTYF_DONE;
		sc->sc_imr1 |= SAB_IMR1_ALLS;
		SAB_WRITE(sc, SAB_IMR1, sc->sc_imr1);
		needsoft = 1;
	}

	if (isr1 & SAB_ISR1_XPR) {
		r = 1;
		if ((sc->sc_flags & SABTTYF_STOP) == 0) {
d536 6
a541 6
			for (i = 0; i < len; i++) {
				SAB_WRITE(sc, SAB_XFIFO + i, *sc->sc_txp);
				sc->sc_txp++;
				sc->sc_txc--;
			}
			if (i != 0) {
d544 6
d554 5
a558 3
			sc->sc_imr1 |= SAB_IMR1_XPR;
			sc->sc_imr1 &= ~SAB_IMR1_ALLS;
			SAB_WRITE(sc, SAB_IMR1, sc->sc_imr1);
d562 11
d1107 1
a1107 1
			sc->sc_imr1 &= ~SAB_IMR1_XPR;
d1114 1
a1114 1
void
d1122 1
a1122 1
			return;
d1124 1
a1124 1
			break;
d1129 1
a1129 1
void
d1137 1
a1137 1
			return;
d1139 1
a1139 1
			break;
@


1.9
log
@Fix console determination; based on discussion in port-sparc64@@netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: sab.c,v 1.8 2002/07/18 02:22:19 jason Exp $	*/
d238 1
a238 1
	sc->sc_bt = ea->ea_bustag;
d242 7
a248 3
	if (ea->ea_nvaddrs)
		sc->sc_bh = (bus_space_handle_t)ea->ea_vaddrs[0];
	else if (ebus_bus_map(sc->sc_bt, 0,
d255 3
a257 1
	sc->sc_ih = bus_intr_establish(ea->ea_bustag, ea->ea_intrs[0],
@


1.8
log
@Match compatible sab82532
@
text
@d1 1
a1 1
/*	$OpenBSD: sab.c,v 1.7 2002/04/08 17:49:42 jason Exp $	*/
d1298 1
a1298 1
	u_int chosen;
d1304 1
a1304 1
	chosen = OF_finddevice("/chosen");
d1310 1
a1310 1
		if (OF_getprop(chosen, "input-device", buf,
d1312 1
a1312 1
			if (strcmp("ttyb", buf) == 0)
d1323 1
a1323 1
		if (OF_getprop(chosen, "output-device", buf,
d1325 1
a1325 1
			if (strcmp("ttyb", buf) == 0)
@


1.7
log
@Credit DARPA/USAF appropriately.
@
text
@d1 1
a1 1
/*	$OpenBSD: sab.c,v 1.6 2002/03/14 01:26:44 millert Exp $	*/
d217 1
d220 3
@


1.6
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: sab.c,v 1.5 2002/01/18 21:15:56 jason Exp $	*/
d32 5
@


1.5
log
@o Remove some debugging prints (most of them wouldn't work anyway)
o Add support for draining the XFIFO on last close
o Debounce the break sequence by looking for the terminate side of the break instead of the detection side.
o wrap the parameter setup in splhigh (lest we get caught with the chip powered down)
@
text
@d1 1
a1 1
/*	$OpenBSD: sab.c,v 1.4 2002/01/17 21:23:24 jason Exp $	*/
d121 36
a156 36
int sab_match __P((struct device *, void *, void *));
void sab_attach __P((struct device *, struct device *, void *));
int sab_print __P((void *, const char *));
int sab_intr __P((void *));
void sab_softintr __P((void *));
void sab_cnputc __P((dev_t, int));
int sab_cngetc __P((dev_t));
void sab_cnpollc __P((dev_t, int));

int sabtty_match __P((struct device *, void *, void *));
void sabtty_attach __P((struct device *, struct device *, void *));
void sabtty_start __P((struct tty *));
int sabtty_param __P((struct tty *, struct termios *));
int sabtty_intr __P((struct sabtty_softc *, int *));
void sabtty_softintr __P((struct sabtty_softc *));
int sabtty_mdmctrl __P((struct sabtty_softc *, int, int));
void sabtty_cec_wait __P((struct sabtty_softc *));
void sabtty_tec_wait __P((struct sabtty_softc *));
void sabtty_reset __P((struct sabtty_softc *));
void sabtty_flush __P((struct sabtty_softc *));
int sabtty_speed __P((int));
void sabtty_console_flags __P((struct sabtty_softc *));
void sabtty_cnpollc __P((struct sabtty_softc *, int));
void sabtty_shutdown __P((void *));
int sabttyparam __P((struct sabtty_softc *, struct tty *, struct termios *));

int sabttyopen __P((dev_t, int, int, struct proc *));
int sabttyclose __P((dev_t, int, int, struct proc *));
int sabttyread __P((dev_t, struct uio *, int));
int sabttywrite __P((dev_t, struct uio *, int));
int sabttyioctl __P((dev_t, u_long, caddr_t, int, struct proc *));
int sabttystop __P((struct tty *, int));
struct tty *sabttytty __P((dev_t));
void sabtty_cnputc __P((struct sabtty_softc *, int));
int sabtty_cngetc __P((struct sabtty_softc *));
void sabtty_abort __P((struct sabtty_softc *));
@


1.4
log
@Better handling of transitions between our mode and what the prom wants.
@
text
@d1 1
a1 1
/*	$OpenBSD: sab.c,v 1.3 2002/01/17 19:30:07 jason Exp $	*/
d106 2
d145 1
d403 1
d422 6
d509 1
a509 1
	if (isr1 & SAB_ISR1_BRK)
d512 10
a524 1
			len = 32;
d527 2
d542 1
a543 3
			sc->sc_flags &= ~SABTTYF_STOP;
			sc->sc_flags |= SABTTYF_DONE;
			needsoft = 1;
d615 1
a615 1
	int card = SAB_CARD(dev), port = SAB_PORT(dev), s;
d652 3
a656 2
		ttsetwater(tp);

d659 1
a659 2

		sc->sc_imr1 = SAB_IMR1_BRKT | SAB_IMR1_ALLS | SAB_IMR1_XDU |
d663 7
d702 17
a718 1
	return ((*linesw[tp->t_line].l_open)(dev, tp));
d733 1
d736 20
a755 4
	if ((tp->t_cflag & HUPCL) || ((tp->t_state & TS_ISOPEN) == 0)) {
		sabtty_mdmctrl(sc, 0, DMSET);
		sabtty_flush(sc);
		sabtty_reset(sc);
d757 2
d760 1
a760 1
	ttyclose(tp);
d882 2
d963 2
a964 1
sabtty_param(tp, t)
a967 2
	struct sab_softc *bc = sab_cd.cd_devs[SAB_CARD(tp->t_dev)];
	struct sabtty_softc *sc = bc->sc_child[SAB_PORT(tp->t_dev)];
d985 1
d1049 11
a1100 2
	if (i == 0)
		printf("%s: cec timeout\n", sc->sc_dv.dv_xname);
a1115 2
	if (i == 0)
		printf("%s: tec timeout\n", sc->sc_dv.dv_xname);
d1183 1
d1233 1
a1238 1
		SAB_WRITE(sc, SAB_IPC, SAB_READ(sc, SAB_IPC) | SAB_IPC_VIS);
d1243 1
a1246 1
		SAB_WRITE(sc, SAB_IPC, SAB_READ(sc, SAB_IPC) & ~SAB_IPC_VIS);
d1258 1
a1258 2
	if (sc == NULL) {
		printf("sab_cnputc: invalid device\n");
a1259 1
	}
d1279 1
a1279 2
	if (sc == NULL) {
		printf("sab_cngetc: invalid device\n");
a1280 1
	}
d1353 1
@


1.3
log
@add polled input handling and remove dead code
Also add support for Break->DDB handling on console
[Works in ddb including going back and forth to the PROM, but locks up
after printing the 'swap on ...' line]
@
text
@d1 1
a1 1
/*	$OpenBSD: sab.c,v 1.2 2002/01/17 05:39:16 jason Exp $	*/
d142 1
a142 1
void sabtty_ddb __P((struct sabtty_softc *));
d275 1
a275 1
	SAB_WRITE(sc, SAB_IPC, SAB_IPC_ICPL | SAB_IPC_VIS);
d423 1
d907 1
d922 7
a928 1
	if (t->c_cflag & CSTOPB)
d934 1
a934 1
	switch (t->c_cflag & CSIZE) {
d950 2
a951 2
	if (t->c_cflag & PARENB) {
		if (tp->t_cflag & PARODD)
d968 1
a968 1
	if (t->c_cflag & CRTSCTS) {
d980 2
d1167 1
d1175 1
a1257 1
#ifdef DDB
d1259 1
a1259 1
sabtty_ddb(sc)
a1261 10
	extern int db_active, db_console;

	if (db_console == 0)
		return;
	if (db_active == 0)
		Debugger();
	else
		callrom();	/* Debugger is probably hosed */
}
#endif
a1262 4
void
sabtty_abort(sc)
	struct sabtty_softc *sc;
{
d1264 2
a1265 1
		u_int8_t oldrfc, r;
d1267 6
a1272 9
		/* Set FIFO for single character mode */
		r = oldrfc = SAB_READ(sc, SAB_RFC);
		r &= ~(SAB_RFC_RFDF);
		SAB_WRITE(sc, SAB_RFC, r);
		sabtty_cec_wait(sc);
		SAB_WRITE(sc, SAB_CMDR, SAB_CMDR_RRES);

#ifdef DDB
		sabtty_ddb(sc);
d1276 8
d1285 5
a1289 5
		/* Reset FIFO to character + status mode */
		SAB_WRITE(sc, SAB_RFC, oldrfc);
		sabtty_cec_wait(sc);
		SAB_WRITE(sc, SAB_CMDR, SAB_CMDR_RRES);
	}
@


1.2
log
@Add console handling (output works, input needs more work)
[Very close to being able to enable 'se' in GENERIC...]
@
text
@d1 1
a1 1
/*	$OpenBSD: sab.c,v 1.1 2001/10/28 02:19:16 jason Exp $	*/
d108 1
a123 1
struct sabtty_softc *sab_findsabtty __P((dev_t));
d141 2
d153 1
d275 1
a275 1
	SAB_WRITE(sc, SAB_IPC, SAB_IPC_ICPL);
d498 3
d1109 31
a1139 1
	return (-1);
d1142 4
a1145 3
struct sabtty_softc *
sab_findsabtty(dev)
	dev_t dev;
d1147 1
a1147 2
	struct sab_softc *bc;
	int card = SAB_CARD(dev), port = SAB_PORT(dev);
d1149 17
a1165 5
	if (card >= sab_cd.cd_ndevs || (bc = sab_cd.cd_devs[card]) == NULL)
		return (NULL);
	if (port >= bc->sc_nchild)
		return (NULL);
	return (bc->sc_child[port]);
d1187 3
a1236 1
			printf("Found output device: %s\n", buf);
d1243 43
@


1.1
log
@SAB82532 driver (missing console stuff, but working as a generic tty
device).  Based on datasheet from Infineon (another datasheet with
non-trivial errors) and info from the linux driver for same chip.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d80 1
d104 2
d110 3
d123 4
d140 1
d149 2
d224 1
d394 39
a432 1
	sabtty_reset(sc);
d1088 106
@


1.1.2.1
log
@Merge in -current
@
text
@@


1.1.2.2
log
@Merge in trunk
@
text
@a79 1
	int			sc_node;
a102 4
#define	SABTTYF_CONS_IN		0x10
#define	SABTTYF_CONS_OUT	0x20
#define	SABTTYF_TXDRAIN		0x40
#define	SABTTYF_DONTDDB		0x80
a104 1
	u_int8_t		sc_polling, sc_pollrfc;
a106 3
struct sabtty_softc *sabtty_cons_input;
struct sabtty_softc *sabtty_cons_output;

a116 3
void sab_cnputc __P((dev_t, int));
int sab_cngetc __P((dev_t));
void sab_cnpollc __P((dev_t, int));
a129 4
void sabtty_console_flags __P((struct sabtty_softc *));
void sabtty_cnpollc __P((struct sabtty_softc *, int));
void sabtty_shutdown __P((void *));
int sabttyparam __P((struct sabtty_softc *, struct tty *, struct termios *));
a137 3
void sabtty_cnputc __P((struct sabtty_softc *, int));
int sabtty_cngetc __P((struct sabtty_softc *));
void sabtty_abort __P((struct sabtty_softc *));
a210 1
	sc->sc_node = ea->ea_node;
d380 1
a380 47
	sabtty_console_flags(sc);

	if (sc->sc_flags & (SABTTYF_CONS_IN | SABTTYF_CONS_OUT)) {
		struct termios t;
		char *acc;

		switch (sc->sc_flags & (SABTTYF_CONS_IN | SABTTYF_CONS_OUT)) {
		case SABTTYF_CONS_IN:
			acc = "input";
			break;
		case SABTTYF_CONS_OUT:
			acc = "output";
			break;
		case SABTTYF_CONS_IN|SABTTYF_CONS_OUT:
		default:
			acc = "i/o";
			break;
		}

		/* Let current output drain */
		DELAY(100000);

		t.c_ispeed= 0;
		t.c_ospeed = 9600;
		t.c_cflag = CREAD | CS8 | HUPCL;
		sc->sc_tty->t_ospeed = 0;
		sabttyparam(sc, sc->sc_tty, &t);

		if (sc->sc_flags & SABTTYF_CONS_IN) {
			sabtty_cons_input = sc;
			cn_tab->cn_pollc = sab_cnpollc;
			cn_tab->cn_getc = sab_cngetc;
			cn_tab->cn_dev = makedev(77/*XXX*/, self->dv_unit);
			shutdownhook_establish(sabtty_shutdown, sc);
		}

		if (sc->sc_flags & SABTTYF_CONS_OUT) {
			sabtty_cons_output = sc;
			cn_tab->cn_putc = sab_cnputc;
			cn_tab->cn_dev = makedev(77/*XXX*/, self->dv_unit);
		}
		printf(": console %s", acc);
	} else {
		/* Not a console... */
		sabtty_reset(sc);
	}

a442 13
	if (isr1 & SAB_ISR1_BRKT)
		sabtty_abort(sc);

	if (isr1 & SAB_ISR1_ALLS) {
		if (sc->sc_flags & SABTTYF_TXDRAIN)
			wakeup(sc);
		sc->sc_flags &= ~SABTTYF_STOP;
		sc->sc_flags |= SABTTYF_DONE;
		sc->sc_imr1 |= SAB_IMR1_ALLS;
		SAB_WRITE(sc, SAB_IMR1, sc->sc_imr1);
		needsoft = 1;
	}

d446 1
a448 2
			else
				len = 32;
a461 1
			sc->sc_imr1 &= ~SAB_IMR1_ALLS;
d463 3
d537 1
a537 1
	int card = SAB_CARD(dev), port = SAB_PORT(dev), s, s1;
d574 2
a577 3
		s1 = splhigh();
		sabtty_reset(sc);
		sabtty_param(tp, &tp->t_termios);
d580 2
a581 1
		sc->sc_imr1 = SAB_IMR1_BRK | SAB_IMR1_ALLS | SAB_IMR1_XDU |
a584 7
		sabtty_cec_wait(sc);
		SAB_WRITE(sc, SAB_CMDR, SAB_CMDR_XRES);
		sabtty_cec_wait(sc);
		SAB_WRITE(sc, SAB_CMDR, SAB_CMDR_RRES);
		sabtty_cec_wait(sc);
		splx(s1);

d617 1
a617 17
	s = (*linesw[tp->t_line].l_open)(dev, tp);
	if (s != 0) {
		if (tp->t_state & TS_ISOPEN)
			return (s);

		if (tp->t_cflag & HUPCL) {
			sabtty_mdmctrl(sc, 0, DMSET);
			(void)tsleep(sc, TTIPRI, ttclos, hz);
		}

		if ((sc->sc_flags & (SABTTYF_CONS_IN | SABTTYF_CONS_OUT)) == 0) {
			/* Flush and power down if we're not the console */
			sabtty_flush(sc);
			sabtty_reset(sc);
		}
	}
	return (s);
a631 1

d634 4
a637 20
	if ((tp->t_state & TS_ISOPEN) == 0) {
		/* Wait for output drain */
		sc->sc_imr1 &= ~SAB_IMR1_ALLS;
		SAB_WRITE(sc, SAB_IMR1, sc->sc_imr1);
		sc->sc_flags |= SABTTYF_TXDRAIN;
		(void)tsleep(sc, TTIPRI, ttclos, 5 * hz);
		sc->sc_imr1 |= SAB_IMR1_ALLS;
		SAB_WRITE(sc, SAB_IMR1, sc->sc_imr1);
		sc->sc_flags &= ~SABTTYF_TXDRAIN;

		if (tp->t_cflag & HUPCL) {
			sabtty_mdmctrl(sc, 0, DMSET);
			(void)tsleep(bc, TTIPRI, ttclos, hz);
		}

		if ((sc->sc_flags & (SABTTYF_CONS_IN | SABTTYF_CONS_OUT)) == 0) {
			/* Flush and power down if we're not the console */
			sabtty_flush(sc);
			sabtty_reset(sc);
		}
d639 1
a639 1

a640 2
	splx(s);

a761 2
		sc->sc_imr1 &= ~SAB_IMR1_ALLS;
		SAB_WRITE(sc, SAB_IMR1, sc->sc_imr1);
d841 1
a841 2
sabttyparam(sc, tp, t)
	struct sabtty_softc *sc;
d845 2
a847 1
	tcflag_t cflag;
d862 1
a862 8
	cflag = t->c_cflag;

	if (sc->sc_flags & (SABTTYF_CONS_IN | SABTTYF_CONS_OUT)) {
		cflag |= CLOCAL;
		cflag &= ~HUPCL;
	}

	if (cflag & CSTOPB)
d868 1
a868 1
	switch (cflag & CSIZE) {
d884 2
a885 2
	if (cflag & PARENB) {
		if (cflag & PARODD)
d902 1
a902 1
	if (cflag & CRTSCTS) {
a913 2
	tp->t_cflag = cflag;

a917 11
int
sabtty_param(tp, t)
	struct tty *tp;
	struct termios *t;
{
	struct sab_softc *bc = sab_cd.cd_devs[SAB_CARD(tp->t_dev)];
	struct sabtty_softc *sc = bc->sc_child[SAB_PORT(tp->t_dev)];

	return (sabttyparam(sc, tp, t));
}

d959 2
d976 2
a1035 184
}

void
sabtty_cnputc(sc, c)
	struct sabtty_softc *sc;
	int c;
{
	sabtty_tec_wait(sc);
	SAB_WRITE(sc, SAB_TIC, c);
	sabtty_tec_wait(sc);
}

int
sabtty_cngetc(sc)
	struct sabtty_softc *sc;
{
	u_int8_t r, len;

again:
	do {
		r = SAB_READ(sc, SAB_STAR);
	} while ((r & SAB_STAR_RFNE) == 0);

	/*
	 * Ok, at least one byte in RFIFO, ask for permission to access RFIFO
	 * (I hate this chip... hate hate hate).
	 */
	sabtty_cec_wait(sc);
	SAB_WRITE(sc, SAB_CMDR, SAB_CMDR_RFRD);

	/* Wait for RFIFO to come ready */
	do {
		r = SAB_READ(sc, SAB_ISR0);
	} while ((r & SAB_ISR0_TCD) == 0);

	len = SAB_READ(sc, SAB_RBCL) & (32 - 1);
	if (len == 0)
		goto again;	/* Shouldn't happen... */

	r = SAB_READ(sc, SAB_RFIFO);

	/*
	 * Blow away everything left in the FIFO...
	 */
	sabtty_cec_wait(sc);
	SAB_WRITE(sc, SAB_CMDR, SAB_CMDR_RMC);
	return (r);
}

void
sabtty_cnpollc(sc, on)
	struct sabtty_softc *sc;
	int on;
{
	u_int8_t r;

	if (on) {
		if (sc->sc_polling)
			return;
		SAB_WRITE(sc, SAB_IPC, SAB_READ(sc, SAB_IPC) | SAB_IPC_VIS);
		r = sc->sc_pollrfc = SAB_READ(sc, SAB_RFC);
		r &= ~(SAB_RFC_RFDF);
		SAB_WRITE(sc, SAB_RFC, r);
		sabtty_cec_wait(sc);
		SAB_WRITE(sc, SAB_CMDR, SAB_CMDR_RRES);
		sc->sc_polling = 1;
	} else {
		if (!sc->sc_polling)
			return;
		SAB_WRITE(sc, SAB_IPC, SAB_READ(sc, SAB_IPC) & ~SAB_IPC_VIS);
		SAB_WRITE(sc, SAB_RFC, sc->sc_pollrfc);
		sabtty_cec_wait(sc);
		SAB_WRITE(sc, SAB_CMDR, SAB_CMDR_RRES);
		sc->sc_polling = 0;
	}
}

void
sab_cnputc(dev, c)
	dev_t dev;
	int c;
{
	struct sabtty_softc *sc = sabtty_cons_output;

	if (sc == NULL)
		return;
	sabtty_cnputc(sc, c);
}

void
sab_cnpollc(dev, on)
	dev_t dev;
	int on;
{
	struct sabtty_softc *sc = sabtty_cons_input;

	sabtty_cnpollc(sc, on);
}

int
sab_cngetc(dev)
	dev_t dev;
{
	struct sabtty_softc *sc = sabtty_cons_input;

	if (sc == NULL)
		return (-1);
	return (sabtty_cngetc(sc));
}

void
sabtty_console_flags(sc)
	struct sabtty_softc *sc;
{
	int node, channel, cookie;
	u_int chosen;
	char buf[255];

	node = sc->sc_parent->sc_node;
	channel = sc->sc_portno;

	chosen = OF_finddevice("/chosen");

	/* Default to channel 0 if there are no explicit prom args */
	cookie = 0;

	if (node == OF_instance_to_package(OF_stdin())) {
		if (OF_getprop(chosen, "input-device", buf,
		    sizeof(buf)) != -1) {
			if (strcmp("ttyb", buf) == 0)
				cookie = 1;
		}

		if (channel == cookie)
			sc->sc_flags |= SABTTYF_CONS_IN;
	}

	/* Default to same channel if there are no explicit prom args */

	if (node == OF_instance_to_package(OF_stdout())) {
		if (OF_getprop(chosen, "output-device", buf,
		    sizeof(buf)) != -1) {
			if (strcmp("ttyb", buf) == 0)
				cookie = 1;
		}

		if (channel == cookie)
			sc->sc_flags |= SABTTYF_CONS_OUT;
	}
}

void
sabtty_abort(sc)
	struct sabtty_softc *sc;
{

	if (sc->sc_flags & SABTTYF_CONS_IN) {
#ifdef DDB
		extern int db_active, db_console;

		if (db_console == 0)
			return;
		if (db_active == 0)
			Debugger();
		else
			callrom();
#else
		callrom();
#endif
	}
}

void
sabtty_shutdown(vsc)
	void *vsc;
{
	struct sabtty_softc *sc = vsc;

	/* Have to put the chip back into single char mode */
	sc->sc_flags |= SABTTYF_DONTDDB;
	SAB_WRITE(sc, SAB_RFC, SAB_READ(sc, SAB_RFC) & ~SAB_RFC_RFDF);
	sabtty_cec_wait(sc);
	SAB_WRITE(sc, SAB_CMDR, SAB_CMDR_RRES);
	sabtty_cec_wait(sc);
@


1.1.2.3
log
@Merge in -current from about a week ago
@
text
@d121 8
a128 8
int sab_match(struct device *, void *, void *);
void sab_attach(struct device *, struct device *, void *);
int sab_print(void *, const char *);
int sab_intr(void *);
void sab_softintr(void *);
void sab_cnputc(dev_t, int);
int sab_cngetc(dev_t);
void sab_cnpollc(dev_t, int);
d130 16
a145 16
int sabtty_match(struct device *, void *, void *);
void sabtty_attach(struct device *, struct device *, void *);
void sabtty_start(struct tty *);
int sabtty_param(struct tty *, struct termios *);
int sabtty_intr(struct sabtty_softc *, int *);
void sabtty_softintr(struct sabtty_softc *);
int sabtty_mdmctrl(struct sabtty_softc *, int, int);
void sabtty_cec_wait(struct sabtty_softc *);
void sabtty_tec_wait(struct sabtty_softc *);
void sabtty_reset(struct sabtty_softc *);
void sabtty_flush(struct sabtty_softc *);
int sabtty_speed(int);
void sabtty_console_flags(struct sabtty_softc *);
void sabtty_cnpollc(struct sabtty_softc *, int);
void sabtty_shutdown(void *);
int sabttyparam(struct sabtty_softc *, struct tty *, struct termios *);
d147 10
a156 10
int sabttyopen(dev_t, int, int, struct proc *);
int sabttyclose(dev_t, int, int, struct proc *);
int sabttyread(dev_t, struct uio *, int);
int sabttywrite(dev_t, struct uio *, int);
int sabttyioctl(dev_t, u_long, caddr_t, int, struct proc *);
int sabttystop(struct tty *, int);
struct tty *sabttytty(dev_t);
void sabtty_cnputc(struct sabtty_softc *, int);
int sabtty_cngetc(struct sabtty_softc *);
void sabtty_abort(struct sabtty_softc *);
@


1.1.2.4
log
@Sync the SMP branch with 3.3
@
text
@a31 5
 *
 * Effort sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F30602-01-2-0537.
 *
a211 1
	char *compat;
a214 3
	compat = getpropstring(ea->ea_node, "compatible");
	if (compat != NULL && !strcmp(compat, "sab82532"))
		return (1);
d229 1
a229 1
	sc->sc_bt = ea->ea_memtag;
d233 3
a235 7
	if (ea->ea_nvaddrs) {
		if (bus_space_map(sc->sc_bt, ea->ea_vaddrs[0],
		    0, BUS_SPACE_MAP_PROMADDRESS, &sc->sc_bh) != 0) {
			printf(": can't map register space\n");
			return;
		}
	} else if (ebus_bus_map(sc->sc_bt, 0,
d242 1
a242 3
	BUS_SPACE_SET_FLAGS(sc->sc_bt, sc->sc_bh, BSHDB_NO_ACCESS);

	sc->sc_ih = bus_intr_establish(sc->sc_bt, ea->ea_intrs[0],
d1289 1
a1289 1
	u_int options;
d1295 1
a1295 1
	options = OF_finddevice("/options");
d1301 1
a1301 1
		if (OF_getprop(options, "input-device", buf,
d1303 1
a1303 1
			if (strncmp("ttyb", buf, strlen("ttyb")) == 0)
d1314 1
a1314 1
		if (OF_getprop(options, "output-device", buf,
d1316 1
a1316 1
			if (strncmp("ttyb", buf, strlen("ttyb")) == 0)
@


1.1.2.5
log
@merge the trunk so we will get the genfs and locking fixes
@
text
@a124 2
#define	SAB_WRITE_BLOCK(sc,r,p,c)	\
    bus_space_write_region_1((sc)->sc_bt, (sc)->sc_bh, (r), (p), (c))
d142 2
a143 2
int sabtty_cec_wait(struct sabtty_softc *);
int sabtty_tec_wait(struct sabtty_softc *);
a287 3
	/* Let current output drain */
	DELAY(100000);

d434 3
d527 13
a539 3
	if (isr1 & (SAB_ISR1_XPR | SAB_ISR1_ALLS)) {
		if ((SAB_READ(sc, SAB_STAR) & SAB_STAR_XFW) &&
		    (sc->sc_flags & SABTTYF_STOP) == 0) {
d544 6
a549 6

			if (len > 0) {
				SAB_WRITE_BLOCK(sc, SAB_XFIFO, sc->sc_txp, len);
				sc->sc_txp += len; 
				sc->sc_txc -= len;

a551 6

				/*
				 * Prevent the false end of xmit from
				 * confusing things below.
				 */
				isr1 &= ~SAB_ISR1_ALLS;
d556 3
a558 5
			if ((sc->sc_imr1 & SAB_IMR1_XPR) == 0) {
				sc->sc_imr1 |= SAB_IMR1_XPR;
				sc->sc_imr1 &= ~SAB_IMR1_ALLS;
				SAB_WRITE(sc, SAB_IMR1, sc->sc_imr1);
			}
a561 11
	if ((isr1 & SAB_ISR1_ALLS) && ((sc->sc_txc == 0) ||
	    (sc->sc_flags & SABTTYF_STOP))) {
		if (sc->sc_flags & SABTTYF_TXDRAIN)
			wakeup(sc);
		sc->sc_flags &= ~SABTTYF_STOP;
		sc->sc_flags |= SABTTYF_DONE;
		sc->sc_imr1 |= SAB_IMR1_ALLS;
		SAB_WRITE(sc, SAB_IMR1, sc->sc_imr1);
		needsoft = 1;
	}

d1096 1
a1096 1
			sc->sc_imr1 &= ~(SAB_ISR1_XPR | SAB_ISR1_ALLS);
d1103 1
a1103 1
int
d1111 1
a1111 1
			return (0);
d1113 1
a1113 1
			return (1);
d1118 1
a1118 1
int
d1126 1
a1126 1
			return (0);
d1128 1
a1128 1
			return (1);
@


1.1.2.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: sab.c,v 1.1.2.5 2003/05/16 00:29:40 niklas Exp $	*/
d15 5
@


1.1.2.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d246 2
a247 2
	    EBUS_PADDR_FROM_REG(&ea->ea_regs[0]), ea->ea_regs[0].size, 0, 0,
	    &sc->sc_bh) != 0) {
d255 1
a255 1
	    IPL_TTY, 0, sab_intr, sc, self->dv_xname);
d380 5
d699 1
a699 1
	    (!suser(p, 0))) {
d865 1
a865 1
		if (suser(p, 0))
@


1.1.4.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: sab.c,v 1.5 2002/01/18 21:15:56 jason Exp $	*/
a79 1
	int			sc_node;
a102 4
#define	SABTTYF_CONS_IN		0x10
#define	SABTTYF_CONS_OUT	0x20
#define	SABTTYF_TXDRAIN		0x40
#define	SABTTYF_DONTDDB		0x80
a104 1
	u_int8_t		sc_polling, sc_pollrfc;
a106 3
struct sabtty_softc *sabtty_cons_input;
struct sabtty_softc *sabtty_cons_output;

a116 3
void sab_cnputc __P((dev_t, int));
int sab_cngetc __P((dev_t));
void sab_cnpollc __P((dev_t, int));
a129 4
void sabtty_console_flags __P((struct sabtty_softc *));
void sabtty_cnpollc __P((struct sabtty_softc *, int));
void sabtty_shutdown __P((void *));
int sabttyparam __P((struct sabtty_softc *, struct tty *, struct termios *));
a137 3
void sabtty_cnputc __P((struct sabtty_softc *, int));
int sabtty_cngetc __P((struct sabtty_softc *));
void sabtty_abort __P((struct sabtty_softc *));
a210 1
	sc->sc_node = ea->ea_node;
d380 1
a380 47
	sabtty_console_flags(sc);

	if (sc->sc_flags & (SABTTYF_CONS_IN | SABTTYF_CONS_OUT)) {
		struct termios t;
		char *acc;

		switch (sc->sc_flags & (SABTTYF_CONS_IN | SABTTYF_CONS_OUT)) {
		case SABTTYF_CONS_IN:
			acc = "input";
			break;
		case SABTTYF_CONS_OUT:
			acc = "output";
			break;
		case SABTTYF_CONS_IN|SABTTYF_CONS_OUT:
		default:
			acc = "i/o";
			break;
		}

		/* Let current output drain */
		DELAY(100000);

		t.c_ispeed= 0;
		t.c_ospeed = 9600;
		t.c_cflag = CREAD | CS8 | HUPCL;
		sc->sc_tty->t_ospeed = 0;
		sabttyparam(sc, sc->sc_tty, &t);

		if (sc->sc_flags & SABTTYF_CONS_IN) {
			sabtty_cons_input = sc;
			cn_tab->cn_pollc = sab_cnpollc;
			cn_tab->cn_getc = sab_cngetc;
			cn_tab->cn_dev = makedev(77/*XXX*/, self->dv_unit);
			shutdownhook_establish(sabtty_shutdown, sc);
		}

		if (sc->sc_flags & SABTTYF_CONS_OUT) {
			sabtty_cons_output = sc;
			cn_tab->cn_putc = sab_cnputc;
			cn_tab->cn_dev = makedev(77/*XXX*/, self->dv_unit);
		}
		printf(": console %s", acc);
	} else {
		/* Not a console... */
		sabtty_reset(sc);
	}

a442 13
	if (isr1 & SAB_ISR1_BRKT)
		sabtty_abort(sc);

	if (isr1 & SAB_ISR1_ALLS) {
		if (sc->sc_flags & SABTTYF_TXDRAIN)
			wakeup(sc);
		sc->sc_flags &= ~SABTTYF_STOP;
		sc->sc_flags |= SABTTYF_DONE;
		sc->sc_imr1 |= SAB_IMR1_ALLS;
		SAB_WRITE(sc, SAB_IMR1, sc->sc_imr1);
		needsoft = 1;
	}

d446 1
a448 2
			else
				len = 32;
a461 1
			sc->sc_imr1 &= ~SAB_IMR1_ALLS;
d463 3
d537 1
a537 1
	int card = SAB_CARD(dev), port = SAB_PORT(dev), s, s1;
d574 2
a577 3
		s1 = splhigh();
		sabtty_reset(sc);
		sabtty_param(tp, &tp->t_termios);
d580 2
a581 1
		sc->sc_imr1 = SAB_IMR1_BRK | SAB_IMR1_ALLS | SAB_IMR1_XDU |
a584 7
		sabtty_cec_wait(sc);
		SAB_WRITE(sc, SAB_CMDR, SAB_CMDR_XRES);
		sabtty_cec_wait(sc);
		SAB_WRITE(sc, SAB_CMDR, SAB_CMDR_RRES);
		sabtty_cec_wait(sc);
		splx(s1);

d617 1
a617 17
	s = (*linesw[tp->t_line].l_open)(dev, tp);
	if (s != 0) {
		if (tp->t_state & TS_ISOPEN)
			return (s);

		if (tp->t_cflag & HUPCL) {
			sabtty_mdmctrl(sc, 0, DMSET);
			(void)tsleep(sc, TTIPRI, ttclos, hz);
		}

		if ((sc->sc_flags & (SABTTYF_CONS_IN | SABTTYF_CONS_OUT)) == 0) {
			/* Flush and power down if we're not the console */
			sabtty_flush(sc);
			sabtty_reset(sc);
		}
	}
	return (s);
a631 1

d634 4
a637 20
	if ((tp->t_state & TS_ISOPEN) == 0) {
		/* Wait for output drain */
		sc->sc_imr1 &= ~SAB_IMR1_ALLS;
		SAB_WRITE(sc, SAB_IMR1, sc->sc_imr1);
		sc->sc_flags |= SABTTYF_TXDRAIN;
		(void)tsleep(sc, TTIPRI, ttclos, 5 * hz);
		sc->sc_imr1 |= SAB_IMR1_ALLS;
		SAB_WRITE(sc, SAB_IMR1, sc->sc_imr1);
		sc->sc_flags &= ~SABTTYF_TXDRAIN;

		if (tp->t_cflag & HUPCL) {
			sabtty_mdmctrl(sc, 0, DMSET);
			(void)tsleep(bc, TTIPRI, ttclos, hz);
		}

		if ((sc->sc_flags & (SABTTYF_CONS_IN | SABTTYF_CONS_OUT)) == 0) {
			/* Flush and power down if we're not the console */
			sabtty_flush(sc);
			sabtty_reset(sc);
		}
d639 1
a639 1

a640 2
	splx(s);

a761 2
		sc->sc_imr1 &= ~SAB_IMR1_ALLS;
		SAB_WRITE(sc, SAB_IMR1, sc->sc_imr1);
d841 1
a841 2
sabttyparam(sc, tp, t)
	struct sabtty_softc *sc;
d845 2
a847 1
	tcflag_t cflag;
d862 1
a862 8
	cflag = t->c_cflag;

	if (sc->sc_flags & (SABTTYF_CONS_IN | SABTTYF_CONS_OUT)) {
		cflag |= CLOCAL;
		cflag &= ~HUPCL;
	}

	if (cflag & CSTOPB)
d868 1
a868 1
	switch (cflag & CSIZE) {
d884 2
a885 2
	if (cflag & PARENB) {
		if (cflag & PARODD)
d902 1
a902 1
	if (cflag & CRTSCTS) {
a913 2
	tp->t_cflag = cflag;

a917 11
int
sabtty_param(tp, t)
	struct tty *tp;
	struct termios *t;
{
	struct sab_softc *bc = sab_cd.cd_devs[SAB_CARD(tp->t_dev)];
	struct sabtty_softc *sc = bc->sc_child[SAB_PORT(tp->t_dev)];

	return (sabttyparam(sc, tp, t));
}

d959 2
d976 2
a1035 184
}

void
sabtty_cnputc(sc, c)
	struct sabtty_softc *sc;
	int c;
{
	sabtty_tec_wait(sc);
	SAB_WRITE(sc, SAB_TIC, c);
	sabtty_tec_wait(sc);
}

int
sabtty_cngetc(sc)
	struct sabtty_softc *sc;
{
	u_int8_t r, len;

again:
	do {
		r = SAB_READ(sc, SAB_STAR);
	} while ((r & SAB_STAR_RFNE) == 0);

	/*
	 * Ok, at least one byte in RFIFO, ask for permission to access RFIFO
	 * (I hate this chip... hate hate hate).
	 */
	sabtty_cec_wait(sc);
	SAB_WRITE(sc, SAB_CMDR, SAB_CMDR_RFRD);

	/* Wait for RFIFO to come ready */
	do {
		r = SAB_READ(sc, SAB_ISR0);
	} while ((r & SAB_ISR0_TCD) == 0);

	len = SAB_READ(sc, SAB_RBCL) & (32 - 1);
	if (len == 0)
		goto again;	/* Shouldn't happen... */

	r = SAB_READ(sc, SAB_RFIFO);

	/*
	 * Blow away everything left in the FIFO...
	 */
	sabtty_cec_wait(sc);
	SAB_WRITE(sc, SAB_CMDR, SAB_CMDR_RMC);
	return (r);
}

void
sabtty_cnpollc(sc, on)
	struct sabtty_softc *sc;
	int on;
{
	u_int8_t r;

	if (on) {
		if (sc->sc_polling)
			return;
		SAB_WRITE(sc, SAB_IPC, SAB_READ(sc, SAB_IPC) | SAB_IPC_VIS);
		r = sc->sc_pollrfc = SAB_READ(sc, SAB_RFC);
		r &= ~(SAB_RFC_RFDF);
		SAB_WRITE(sc, SAB_RFC, r);
		sabtty_cec_wait(sc);
		SAB_WRITE(sc, SAB_CMDR, SAB_CMDR_RRES);
		sc->sc_polling = 1;
	} else {
		if (!sc->sc_polling)
			return;
		SAB_WRITE(sc, SAB_IPC, SAB_READ(sc, SAB_IPC) & ~SAB_IPC_VIS);
		SAB_WRITE(sc, SAB_RFC, sc->sc_pollrfc);
		sabtty_cec_wait(sc);
		SAB_WRITE(sc, SAB_CMDR, SAB_CMDR_RRES);
		sc->sc_polling = 0;
	}
}

void
sab_cnputc(dev, c)
	dev_t dev;
	int c;
{
	struct sabtty_softc *sc = sabtty_cons_output;

	if (sc == NULL)
		return;
	sabtty_cnputc(sc, c);
}

void
sab_cnpollc(dev, on)
	dev_t dev;
	int on;
{
	struct sabtty_softc *sc = sabtty_cons_input;

	sabtty_cnpollc(sc, on);
}

int
sab_cngetc(dev)
	dev_t dev;
{
	struct sabtty_softc *sc = sabtty_cons_input;

	if (sc == NULL)
		return (-1);
	return (sabtty_cngetc(sc));
}

void
sabtty_console_flags(sc)
	struct sabtty_softc *sc;
{
	int node, channel, cookie;
	u_int chosen;
	char buf[255];

	node = sc->sc_parent->sc_node;
	channel = sc->sc_portno;

	chosen = OF_finddevice("/chosen");

	/* Default to channel 0 if there are no explicit prom args */
	cookie = 0;

	if (node == OF_instance_to_package(OF_stdin())) {
		if (OF_getprop(chosen, "input-device", buf,
		    sizeof(buf)) != -1) {
			if (strcmp("ttyb", buf) == 0)
				cookie = 1;
		}

		if (channel == cookie)
			sc->sc_flags |= SABTTYF_CONS_IN;
	}

	/* Default to same channel if there are no explicit prom args */

	if (node == OF_instance_to_package(OF_stdout())) {
		if (OF_getprop(chosen, "output-device", buf,
		    sizeof(buf)) != -1) {
			if (strcmp("ttyb", buf) == 0)
				cookie = 1;
		}

		if (channel == cookie)
			sc->sc_flags |= SABTTYF_CONS_OUT;
	}
}

void
sabtty_abort(sc)
	struct sabtty_softc *sc;
{

	if (sc->sc_flags & SABTTYF_CONS_IN) {
#ifdef DDB
		extern int db_active, db_console;

		if (db_console == 0)
			return;
		if (db_active == 0)
			Debugger();
		else
			callrom();
#else
		callrom();
#endif
	}
}

void
sabtty_shutdown(vsc)
	void *vsc;
{
	struct sabtty_softc *sc = vsc;

	/* Have to put the chip back into single char mode */
	sc->sc_flags |= SABTTYF_DONTDDB;
	SAB_WRITE(sc, SAB_RFC, SAB_READ(sc, SAB_RFC) & ~SAB_RFC_RFDF);
	sabtty_cec_wait(sc);
	SAB_WRITE(sc, SAB_CMDR, SAB_CMDR_RRES);
	sabtty_cec_wait(sc);
@


1.1.4.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: sab.c,v 1.1.4.1 2002/01/31 22:55:24 niklas Exp $	*/
a31 5
 *
 * Effort sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F30602-01-2-0537.
 *
d121 36
a156 36
int sab_match(struct device *, void *, void *);
void sab_attach(struct device *, struct device *, void *);
int sab_print(void *, const char *);
int sab_intr(void *);
void sab_softintr(void *);
void sab_cnputc(dev_t, int);
int sab_cngetc(dev_t);
void sab_cnpollc(dev_t, int);

int sabtty_match(struct device *, void *, void *);
void sabtty_attach(struct device *, struct device *, void *);
void sabtty_start(struct tty *);
int sabtty_param(struct tty *, struct termios *);
int sabtty_intr(struct sabtty_softc *, int *);
void sabtty_softintr(struct sabtty_softc *);
int sabtty_mdmctrl(struct sabtty_softc *, int, int);
void sabtty_cec_wait(struct sabtty_softc *);
void sabtty_tec_wait(struct sabtty_softc *);
void sabtty_reset(struct sabtty_softc *);
void sabtty_flush(struct sabtty_softc *);
int sabtty_speed(int);
void sabtty_console_flags(struct sabtty_softc *);
void sabtty_cnpollc(struct sabtty_softc *, int);
void sabtty_shutdown(void *);
int sabttyparam(struct sabtty_softc *, struct tty *, struct termios *);

int sabttyopen(dev_t, int, int, struct proc *);
int sabttyclose(dev_t, int, int, struct proc *);
int sabttyread(dev_t, struct uio *, int);
int sabttywrite(dev_t, struct uio *, int);
int sabttyioctl(dev_t, u_long, caddr_t, int, struct proc *);
int sabttystop(struct tty *, int);
struct tty *sabttytty(dev_t);
void sabtty_cnputc(struct sabtty_softc *, int);
int sabtty_cngetc(struct sabtty_softc *);
void sabtty_abort(struct sabtty_softc *);
@


1.1.4.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: sab.c,v 1.1.4.2 2002/06/11 03:38:43 art Exp $	*/
a216 1
	char *compat;
a219 3
	compat = getpropstring(ea->ea_node, "compatible");
	if (compat != NULL && !strcmp(compat, "sab82532"))
		return (1);
d1294 1
a1294 1
	u_int options;
d1300 1
a1300 1
	options = OF_finddevice("/options");
d1306 1
a1306 1
		if (OF_getprop(options, "input-device", buf,
d1308 1
a1308 1
			if (strncmp("ttyb", buf, strlen("ttyb")) == 0)
d1319 1
a1319 1
		if (OF_getprop(options, "output-device", buf,
d1321 1
a1321 1
			if (strncmp("ttyb", buf, strlen("ttyb")) == 0)
@


1.1.4.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a124 2
#define	SAB_WRITE_BLOCK(sc,r,p,c)	\
    bus_space_write_region_1((sc)->sc_bt, (sc)->sc_bh, (r), (p), (c))
d142 2
a143 2
int sabtty_cec_wait(struct sabtty_softc *);
int sabtty_tec_wait(struct sabtty_softc *);
d238 1
a238 1
	sc->sc_bt = ea->ea_memtag;
d242 3
a244 7
	if (ea->ea_nvaddrs) {
		if (bus_space_map(sc->sc_bt, ea->ea_vaddrs[0],
		    0, BUS_SPACE_MAP_PROMADDRESS, &sc->sc_bh) != 0) {
			printf(": can't map register space\n");
			return;
		}
	} else if (ebus_bus_map(sc->sc_bt, 0,
d251 1
a251 3
	BUS_SPACE_SET_FLAGS(sc->sc_bt, sc->sc_bh, BSHDB_NO_ACCESS);

	sc->sc_ih = bus_intr_establish(sc->sc_bt, ea->ea_intrs[0],
a281 3
	/* Let current output drain */
	DELAY(100000);

d428 3
d521 13
a533 3
	if (isr1 & (SAB_ISR1_XPR | SAB_ISR1_ALLS)) {
		if ((SAB_READ(sc, SAB_STAR) & SAB_STAR_XFW) &&
		    (sc->sc_flags & SABTTYF_STOP) == 0) {
d538 6
a543 6

			if (len > 0) {
				SAB_WRITE_BLOCK(sc, SAB_XFIFO, sc->sc_txp, len);
				sc->sc_txp += len; 
				sc->sc_txc -= len;

a545 6

				/*
				 * Prevent the false end of xmit from
				 * confusing things below.
				 */
				isr1 &= ~SAB_ISR1_ALLS;
d550 3
a552 5
			if ((sc->sc_imr1 & SAB_IMR1_XPR) == 0) {
				sc->sc_imr1 |= SAB_IMR1_XPR;
				sc->sc_imr1 &= ~SAB_IMR1_ALLS;
				SAB_WRITE(sc, SAB_IMR1, sc->sc_imr1);
			}
a555 11
	if ((isr1 & SAB_ISR1_ALLS) && ((sc->sc_txc == 0) ||
	    (sc->sc_flags & SABTTYF_STOP))) {
		if (sc->sc_flags & SABTTYF_TXDRAIN)
			wakeup(sc);
		sc->sc_flags &= ~SABTTYF_STOP;
		sc->sc_flags |= SABTTYF_DONE;
		sc->sc_imr1 |= SAB_IMR1_ALLS;
		SAB_WRITE(sc, SAB_IMR1, sc->sc_imr1);
		needsoft = 1;
	}

d1090 1
a1090 1
			sc->sc_imr1 &= ~(SAB_ISR1_XPR | SAB_ISR1_ALLS);
d1097 1
a1097 1
int
d1105 1
a1105 1
			return (0);
d1107 1
a1107 1
			return (1);
d1112 1
a1112 1
int
d1120 1
a1120 1
			return (0);
d1122 1
a1122 1
			return (1);
@
