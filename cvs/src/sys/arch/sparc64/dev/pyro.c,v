head	1.31;
access;
symbols
	OPENBSD_6_1:1.30.0.4
	OPENBSD_6_1_BASE:1.30
	OPENBSD_6_0:1.28.0.8
	OPENBSD_6_0_BASE:1.28
	OPENBSD_5_9:1.28.0.4
	OPENBSD_5_9_BASE:1.28
	OPENBSD_5_8:1.28.0.6
	OPENBSD_5_8_BASE:1.28
	OPENBSD_5_7:1.28.0.2
	OPENBSD_5_7_BASE:1.28
	OPENBSD_5_6:1.27.0.4
	OPENBSD_5_6_BASE:1.27
	OPENBSD_5_5:1.26.0.4
	OPENBSD_5_5_BASE:1.26
	OPENBSD_5_4:1.25.0.2
	OPENBSD_5_4_BASE:1.25
	OPENBSD_5_3:1.24.0.2
	OPENBSD_5_3_BASE:1.24
	OPENBSD_5_2:1.23.0.6
	OPENBSD_5_2_BASE:1.23
	OPENBSD_5_1_BASE:1.23
	OPENBSD_5_1:1.23.0.4
	OPENBSD_5_0:1.23.0.2
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.20.0.2
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.18.0.6
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.18.0.2
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.18.0.4
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.16.0.2
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.14.0.2
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.11.0.2
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.7.0.2
	OPENBSD_4_2_BASE:1.7;
locks; strict;
comment	@ * @;


1.31
date	2017.05.25.03.19.39;	author dlg;	state Exp;
branches;
next	1.30;
commitid	gx8rjMxrMcqYnydg;

1.30
date	2016.12.20.13.40.50;	author jsg;	state Exp;
branches;
next	1.29;
commitid	i01X1vVvVdPgOOHT;

1.29
date	2016.08.23.03.28.01;	author guenther;	state Exp;
branches;
next	1.28;
commitid	sVHD5kblxhZITIq0;

1.28
date	2014.12.09.06.58.29;	author doug;	state Exp;
branches;
next	1.27;
commitid	yWAxzpQP2PPpYlfT;

1.27
date	2014.07.12.18.44.43;	author tedu;	state Exp;
branches;
next	1.26;
commitid	uKVPYMN2MLxdZxzH;

1.26
date	2014.01.21.10.59.30;	author dlg;	state Exp;
branches;
next	1.25;

1.25
date	2013.05.13.19.27.16;	author kettenis;	state Exp;
branches;
next	1.24;

1.24
date	2012.08.20.15.23.25;	author kettenis;	state Exp;
branches;
next	1.23;

1.23
date	2011.07.06.22.26.44;	author kettenis;	state Exp;
branches;
next	1.22;

1.22
date	2011.07.06.05.48.57;	author kettenis;	state Exp;
branches;
next	1.21;

1.21
date	2011.06.26.20.32.36;	author kettenis;	state Exp;
branches;
next	1.20;

1.20
date	2010.12.05.15.15.14;	author kettenis;	state Exp;
branches;
next	1.19;

1.19
date	2010.12.04.17.06.32;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2009.03.29.22.52.11;	author kettenis;	state Exp;
branches;
next	1.17;

1.17
date	2009.03.29.21.53.52;	author sthen;	state Exp;
branches;
next	1.16;

1.16
date	2009.01.02.20.01.45;	author kettenis;	state Exp;
branches;
next	1.15;

1.15
date	2008.12.21.19.40.41;	author kettenis;	state Exp;
branches;
next	1.14;

1.14
date	2008.07.12.13.08.04;	author kettenis;	state Exp;
branches;
next	1.13;

1.13
date	2008.07.12.12.21.04;	author kettenis;	state Exp;
branches;
next	1.12;

1.12
date	2008.05.24.14.54.03;	author kettenis;	state Exp;
branches;
next	1.11;

1.11
date	2008.01.19.11.13.43;	author kettenis;	state Exp;
branches;
next	1.10;

1.10
date	2007.10.10.11.31.49;	author krw;	state Exp;
branches;
next	1.9;

1.9
date	2007.10.08.18.30.13;	author krw;	state Exp;
branches;
next	1.8;

1.8
date	2007.09.18.00.46.41;	author krw;	state Exp;
branches;
next	1.7;

1.7
date	2007.04.03.19.59.01;	author kettenis;	state Exp;
branches;
next	1.6;

1.6
date	2007.04.01.21.41.09;	author kettenis;	state Exp;
branches;
next	1.5;

1.5
date	2007.04.01.12.50.18;	author kettenis;	state Exp;
branches;
next	1.4;

1.4
date	2007.04.01.12.48.07;	author kettenis;	state Exp;
branches;
next	1.3;

1.3
date	2007.03.31.22.14.52;	author kettenis;	state Exp;
branches;
next	1.2;

1.2
date	2007.03.31.19.05.31;	author kettenis;	state Exp;
branches;
next	1.1;

1.1
date	2007.03.30.22.24.56;	author kettenis;	state Exp;
branches;
next	;


desc
@@


1.31
log
@tweak sparc64 membars as a step toward making them usable in userland.

specifically, dont rely on magic in ctlreg to implement membars. moving
that to atomic.h would add a lot of pollution to the namespace, so
move to passing the membar options to a single __membar macro.

this tweaks everything that was using the ctlreg backend to either use
an appropriate membar_foo(), or to use __membar() in the MD code.

ok kettenis@@
@
text
@/*	$OpenBSD: pyro.c,v 1.30 2016/12/20 13:40:50 jsg Exp $	*/

/*
 * Copyright (c) 2002 Jason L. Wright (jason@@thought.net)
 * Copyright (c) 2003 Henric Jungheim
 * Copyright (c) 2007 Mark Kettenis
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/device.h>
#include <sys/errno.h>
#include <sys/malloc.h>
#include <sys/systm.h>

#define _SPARC_BUS_DMA_PRIVATE
#include <machine/bus.h>
#include <machine/autoconf.h>
#include <machine/openfirm.h>

#ifdef DDB
#include <machine/db_machdep.h>
#endif

#include <dev/pci/pcivar.h>
#include <dev/pci/pcireg.h>

#include <sparc64/dev/iommureg.h>
#include <sparc64/dev/iommuvar.h>
#include <sparc64/dev/msivar.h>
#include <sparc64/dev/pyrovar.h>

#ifdef DEBUG
#define PDB_PROM        0x01
#define PDB_BUSMAP      0x02
#define PDB_INTR        0x04
#define PDB_CONF        0x08
int pyro_debug = ~0;
#define DPRINTF(l, s)   do { if (pyro_debug & l) printf s; } while (0)
#else
#define DPRINTF(l, s)
#endif

#define FIRE_EQ_BASE_ADDR		0x10000
#define FIRE_EQ_CNTRL_SET		0x11000
#define  FIRE_EQ_CTRL_SET_EN		0x0000100000000000UL
#define FIRE_EQ_CNTRL_CLEAR		0x11200
#define FIRE_EQ_STATE			0x11400
#define FIRE_EQ_TAIL			0x11600
#define FIRE_EQ_HEAD			0x11800
#define FIRE_MSI_MAP			0x20000
#define  FIRE_MSI_MAP_V			0x8000000000000000UL
#define  FIRE_MSI_MAP_EQWR_N		0x4000000000000000UL
#define  FIRE_MSI_MAP_EQNUM		0x000000000000003fUL
#define FIRE_MSI_CLEAR			0x28000
#define  FIRE_MSI_CLEAR_EQWR_N		0x4000000000000000UL
#define FIRE_INTRMONDO_DATA0		0x2c000
#define FIRE_INTRMONDO_DATA1		0x2c008
#define FIRE_MSI32_ADDR			0x34000
#define FIRE_MSI64_ADDR			0x34008

#define FIRE_RESET_GEN			0x7010

#define FIRE_RESET_GEN_XIR		0x0000000000000002UL

#define FIRE_INTRMAP_INT_CNTRL_NUM_MASK	0x000003c0
#define FIRE_INTRMAP_INT_CNTRL_NUM0	0x00000040
#define FIRE_INTRMAP_INT_CNTRL_NUM1	0x00000080
#define FIRE_INTRMAP_INT_CNTRL_NUM2	0x00000100
#define FIRE_INTRMAP_INT_CNTRL_NUM3	0x00000200
#define FIRE_INTRMAP_T_JPID_SHIFT	26
#define FIRE_INTRMAP_T_JPID_MASK	0x7c000000

#define OBERON_INTRMAP_T_DESTID_SHIFT	21
#define OBERON_INTRMAP_T_DESTID_MASK	0x7fe00000

extern struct sparc_pci_chipset _sparc_pci_chipset;

int pyro_match(struct device *, void *, void *);
void pyro_attach(struct device *, struct device *, void *);
void pyro_init(struct pyro_softc *, int);
void pyro_init_iommu(struct pyro_softc *, struct pyro_pbm *);
void pyro_init_msi(struct pyro_softc *, struct pyro_pbm *);
int pyro_print(void *, const char *);

pci_chipset_tag_t pyro_alloc_chipset(struct pyro_pbm *, int,
    pci_chipset_tag_t);
bus_space_tag_t pyro_alloc_mem_tag(struct pyro_pbm *);
bus_space_tag_t pyro_alloc_io_tag(struct pyro_pbm *);
bus_space_tag_t pyro_alloc_config_tag(struct pyro_pbm *);
bus_space_tag_t pyro_alloc_bus_tag(struct pyro_pbm *, const char *,
    int, int, int);
bus_dma_tag_t pyro_alloc_dma_tag(struct pyro_pbm *);

int pyro_conf_size(pci_chipset_tag_t, pcitag_t);
pcireg_t pyro_conf_read(pci_chipset_tag_t, pcitag_t, int);
void pyro_conf_write(pci_chipset_tag_t, pcitag_t, int, pcireg_t);

int pyro_intr_map(struct pci_attach_args *, pci_intr_handle_t *);
int pyro_bus_map(bus_space_tag_t, bus_space_tag_t, bus_addr_t,
    bus_size_t, int, bus_space_handle_t *);
paddr_t pyro_bus_mmap(bus_space_tag_t, bus_space_tag_t, bus_addr_t, off_t,
    int, int);
void *pyro_intr_establish(bus_space_tag_t, bus_space_tag_t, int, int, int,
    int (*)(void *), void *, const char *);
void pyro_msi_ack(struct intrhand *);

int pyro_msi_eq_intr(void *);

int pyro_dmamap_create(bus_dma_tag_t, bus_dma_tag_t, bus_size_t, int,
    bus_size_t, bus_size_t, int, bus_dmamap_t *);

#ifdef DDB
void pyro_xir(void *, int);
#endif

int
pyro_match(struct device *parent, void *match, void *aux)
{
	struct mainbus_attach_args *ma = aux;
	char *str;

	if (strcmp(ma->ma_name, "pci") != 0)
		return (0);

	str = getpropstring(ma->ma_node, "compatible");
	if (strcmp(str, "pciex108e,80f0") == 0 ||
	    strcmp(str, "pciex108e,80f8") == 0)
		return (1);

	return (0);
}

void
pyro_attach(struct device *parent, struct device *self, void *aux)
{
	struct pyro_softc *sc = (struct pyro_softc *)self;
	struct mainbus_attach_args *ma = aux;
	char *str;
	int busa;

	sc->sc_node = ma->ma_node;
	sc->sc_dmat = ma->ma_dmatag;
	sc->sc_bust = ma->ma_bustag;
	sc->sc_csr = ma->ma_reg[0].ur_paddr;
	sc->sc_xbc = ma->ma_reg[1].ur_paddr;
	sc->sc_ign = INTIGN(ma->ma_upaid << INTMAP_IGN_SHIFT);

	if ((ma->ma_reg[0].ur_paddr & 0x00700000) == 0x00600000)
		busa = 1;
	else
		busa = 0;

	if (bus_space_map(sc->sc_bust, sc->sc_csr,
	    ma->ma_reg[0].ur_len, 0, &sc->sc_csrh)) {
		printf(": failed to map csr registers\n");
		return;
	}

	if (bus_space_map(sc->sc_bust, sc->sc_xbc,
	    ma->ma_reg[1].ur_len, 0, &sc->sc_xbch)) {
		printf(": failed to map xbc registers\n");
		return;
	}

	str = getpropstring(ma->ma_node, "compatible");
	if (strcmp(str, "pciex108e,80f8") == 0)
		sc->sc_oberon = 1;

	pyro_init(sc, busa);
}

void
pyro_init(struct pyro_softc *sc, int busa)
{
	struct pyro_pbm *pbm;
	struct pcibus_attach_args pba;
	int *busranges = NULL, nranges;

	pbm = malloc(sizeof(*pbm), M_DEVBUF, M_NOWAIT | M_ZERO);
	if (pbm == NULL)
		panic("pyro: can't alloc pyro pbm");

	pbm->pp_sc = sc;
	pbm->pp_bus_a = busa;

	if (getprop(sc->sc_node, "ranges", sizeof(struct pyro_range),
	    &pbm->pp_nrange, (void **)&pbm->pp_range))
		panic("pyro: can't get ranges");

	if (getprop(sc->sc_node, "bus-range", sizeof(int), &nranges,
	    (void **)&busranges))
		panic("pyro: can't get bus-range");

	printf(": \"%s\", rev %d, ign %x, bus %c %d to %d\n",
	    sc->sc_oberon ? "Oberon" : "Fire",
	    getpropint(sc->sc_node, "module-revision#", 0), sc->sc_ign,
	    busa ? 'A' : 'B', busranges[0], busranges[1]);

	printf("%s: ", sc->sc_dv.dv_xname);
	pyro_init_iommu(sc, pbm);

	pbm->pp_memt = pyro_alloc_mem_tag(pbm);
	pbm->pp_iot = pyro_alloc_io_tag(pbm);
	pbm->pp_cfgt = pyro_alloc_config_tag(pbm);
	pbm->pp_dmat = pyro_alloc_dma_tag(pbm);

	pyro_init_msi(sc, pbm);

	if (bus_space_map(pbm->pp_cfgt, 0, 0x10000000, 0, &pbm->pp_cfgh))
		panic("pyro: can't map config space");

	pbm->pp_pc = pyro_alloc_chipset(pbm, sc->sc_node, &_sparc_pci_chipset);

	pbm->pp_pc->bustag = pbm->pp_cfgt;
	pbm->pp_pc->bushandle = pbm->pp_cfgh;

	bzero(&pba, sizeof(pba));
	pba.pba_busname = "pci";
	pba.pba_domain = pci_ndomains++;
	pba.pba_bus = busranges[0];
	pba.pba_pc = pbm->pp_pc;
	pba.pba_flags = pbm->pp_flags;
	pba.pba_dmat = pbm->pp_dmat;
	pba.pba_memt = pbm->pp_memt;
	pba.pba_iot = pbm->pp_iot;
	pba.pba_pc->conf_size = pyro_conf_size;
	pba.pba_pc->conf_read = pyro_conf_read;
	pba.pba_pc->conf_write = pyro_conf_write;
	pba.pba_pc->intr_map = pyro_intr_map;

	free(busranges, M_DEVBUF, 0);

#ifdef DDB
	db_register_xir(pyro_xir, sc);
#endif

	config_found(&sc->sc_dv, &pba, pyro_print);
}

void
pyro_init_iommu(struct pyro_softc *sc, struct pyro_pbm *pbm)
{
	struct iommu_state *is = &pbm->pp_is;
	int tsbsize = 7;
	u_int32_t iobase = -1;
	char *name;

	is->is_bustag = sc->sc_bust;

	if (bus_space_subregion(is->is_bustag, sc->sc_csrh,
	    0x40000, 0x100, &is->is_iommu)) {
		panic("pyro: unable to create iommu handle");
	}

	is->is_sb[0] = &pbm->pp_sb;
	is->is_sb[0]->sb_bustag = is->is_bustag;

	name = (char *)malloc(32, M_DEVBUF, M_NOWAIT);
	if (name == NULL)
		panic("couldn't malloc iommu name");
	snprintf(name, 32, "%s dvma", sc->sc_dv.dv_xname);

	/* On Oberon, we need to flush the cache. */
	if (sc->sc_oberon)
		is->is_flags |= IOMMU_FLUSH_CACHE;

	iommu_init(name, is, tsbsize, iobase);
}

void
pyro_init_msi(struct pyro_softc *sc, struct pyro_pbm *pbm)
{
	u_int32_t msi_addr_range[3];
	u_int32_t msi_eq_devino[3] = { 0, 36, 24 };
	int ihandle;
	int msis, msi_eq_size;

	if (OF_getprop(sc->sc_node, "msi-address-ranges",
	    msi_addr_range, sizeof(msi_addr_range)) <= 0)
		return;
	pbm->pp_msiaddr = msi_addr_range[1];
	pbm->pp_msiaddr |= ((bus_addr_t)msi_addr_range[0]) << 32;

	msis = getpropint(sc->sc_node, "#msi", 256);
	pbm->pp_msi = mallocarray(msis, sizeof(*pbm->pp_msi), M_DEVBUF,
	    M_NOWAIT | M_ZERO);
	if (pbm->pp_msi == NULL)
		return;

	msi_eq_size = getpropint(sc->sc_node, "msi-eq-size", 256);
	pbm->pp_meq = msi_eq_alloc(pbm->pp_dmat, msi_eq_size);
	if (pbm->pp_meq == NULL)
		goto free_table;

	bzero(pbm->pp_meq->meq_va,
	    pbm->pp_meq->meq_nentries * sizeof(struct pyro_msi_msg));

	bus_space_write_8(sc->sc_bust, sc->sc_csrh, FIRE_EQ_BASE_ADDR,
	    pbm->pp_meq->meq_map->dm_segs[0].ds_addr);

	bus_space_write_8(sc->sc_bust, sc->sc_csrh,
	    FIRE_INTRMONDO_DATA0, sc->sc_ign);
	bus_space_write_8(sc->sc_bust, sc->sc_csrh,
	    FIRE_INTRMONDO_DATA1, 0);

	bus_space_write_8(sc->sc_bust, sc->sc_csrh, FIRE_MSI32_ADDR,
	    pbm->pp_msiaddr);

	bus_space_write_8(sc->sc_bust, sc->sc_csrh, FIRE_EQ_HEAD, 0);
	bus_space_write_8(sc->sc_bust, sc->sc_csrh, FIRE_EQ_TAIL, 0);

	OF_getprop(sc->sc_node, "msi-eq-to-devino",
	    msi_eq_devino, sizeof(msi_eq_devino));

	ihandle = msi_eq_devino[2] | sc->sc_ign;
	if (pyro_intr_establish(pbm->pp_memt, sc->sc_bust, ihandle,
	    IPL_HIGH, 0, pyro_msi_eq_intr, pbm, sc->sc_dv.dv_xname) == NULL)
		goto free_table;

	/* Enable EQ. */
	bus_space_write_8(sc->sc_bust, sc->sc_csrh, FIRE_EQ_CNTRL_SET,
	    FIRE_EQ_CTRL_SET_EN);

	pbm->pp_flags |= PCI_FLAGS_MSI_ENABLED;
	return;

free_table:
	free(pbm->pp_msi, M_DEVBUF, 0);
}

int
pyro_print(void *aux, const char *p)
{
	if (p == NULL)
		return (UNCONF);
	return (QUIET);
}

int
pyro_conf_size(pci_chipset_tag_t pc, pcitag_t tag)
{
	return PCIE_CONFIG_SPACE_SIZE;
}

pcireg_t
pyro_conf_read(pci_chipset_tag_t pc, pcitag_t tag, int reg)
{
	struct cpu_info *ci = curcpu();
	pcireg_t val;
	int s;

	s = splhigh();
	__membar("#Sync");
	ci->ci_pci_probe = 1;
	val = bus_space_read_4(pc->bustag, pc->bushandle,
	    (PCITAG_OFFSET(tag) << 4) + reg);
	__membar("#Sync");
	if (ci->ci_pci_fault)
		val = 0xffffffff;
	ci->ci_pci_probe = ci->ci_pci_fault = 0;
	splx(s);

	return (val);
}

void
pyro_conf_write(pci_chipset_tag_t pc, pcitag_t tag, int reg, pcireg_t data)
{
        bus_space_write_4(pc->bustag, pc->bushandle,
	    (PCITAG_OFFSET(tag) << 4) + reg, data);
}

/*
 * Bus-specific interrupt mapping
 */
int
pyro_intr_map(struct pci_attach_args *pa, pci_intr_handle_t *ihp)
{
	struct pyro_pbm *pp = pa->pa_pc->cookie;
	struct pyro_softc *sc = pp->pp_sc;
	u_int dev;

	if (*ihp != (pci_intr_handle_t)-1) {
		*ihp |= sc->sc_ign;
		return (0);
	}

	/*
	 * We didn't find a PROM mapping for this interrupt.  Try to
	 * construct one ourselves based on the swizzled interrupt pin
	 * and the interrupt mapping for PCI slots documented in the
	 * UltraSPARC-IIi User's Manual.
	 */

	if (pa->pa_intrpin == 0)
		return (-1);

	/*
	 * This deserves some documentation.  Should anyone
	 * have anything official looking, please speak up.
	 */
	dev = pa->pa_device - 1;

	*ihp = (pa->pa_intrpin - 1) & INTMAP_PCIINT;
	*ihp |= (dev << 2) & INTMAP_PCISLOT;
	*ihp |= sc->sc_ign;

	return (0);
}

bus_space_tag_t
pyro_alloc_mem_tag(struct pyro_pbm *pp)
{
	return (pyro_alloc_bus_tag(pp, "mem",
	    0x02,       /* 32-bit mem space (where's the #define???) */
	    ASI_PRIMARY, ASI_PRIMARY_LITTLE));
}

bus_space_tag_t
pyro_alloc_io_tag(struct pyro_pbm *pp)
{
	return (pyro_alloc_bus_tag(pp, "io",
	    0x01,       /* IO space (where's the #define???) */
	    ASI_PHYS_NON_CACHED_LITTLE, ASI_PHYS_NON_CACHED));
}

bus_space_tag_t
pyro_alloc_config_tag(struct pyro_pbm *pp)
{
	return (pyro_alloc_bus_tag(pp, "cfg",
	    0x00,       /* Config space (where's the #define???) */
	    ASI_PHYS_NON_CACHED_LITTLE, ASI_PHYS_NON_CACHED));
}

bus_space_tag_t
pyro_alloc_bus_tag(struct pyro_pbm *pbm, const char *name, int ss,
    int asi, int sasi)
{
	struct pyro_softc *sc = pbm->pp_sc;
	struct sparc_bus_space_tag *bt;

	bt = malloc(sizeof(*bt), M_DEVBUF, M_NOWAIT | M_ZERO);
	if (bt == NULL)
		panic("pyro: could not allocate bus tag");

	snprintf(bt->name, sizeof(bt->name), "%s-pbm_%s(%d/%2.2x)",
	    sc->sc_dv.dv_xname, name, ss, asi);

	bt->cookie = pbm;
	bt->parent = sc->sc_bust;
	bt->default_type = ss;
	bt->asi = asi;
	bt->sasi = sasi;
	bt->sparc_bus_map = pyro_bus_map;
	bt->sparc_bus_mmap = pyro_bus_mmap;
	bt->sparc_intr_establish = pyro_intr_establish;
	return (bt);
}

bus_dma_tag_t
pyro_alloc_dma_tag(struct pyro_pbm *pbm)
{
	struct pyro_softc *sc = pbm->pp_sc;
	bus_dma_tag_t dt, pdt = sc->sc_dmat;

	dt = malloc(sizeof(*dt), M_DEVBUF, M_NOWAIT | M_ZERO);
	if (dt == NULL)
		panic("pyro: could not alloc dma tag");

	dt->_cookie = pbm;
	dt->_parent = pdt;
	dt->_dmamap_create	= pyro_dmamap_create;
	dt->_dmamap_destroy	= iommu_dvmamap_destroy;
	dt->_dmamap_load	= iommu_dvmamap_load;
	dt->_dmamap_load_raw	= iommu_dvmamap_load_raw;
	dt->_dmamap_unload	= iommu_dvmamap_unload;
	dt->_dmamap_sync	= iommu_dvmamap_sync;
	dt->_dmamem_alloc	= iommu_dvmamem_alloc;
	dt->_dmamem_free	= iommu_dvmamem_free;
	return (dt);
}

pci_chipset_tag_t
pyro_alloc_chipset(struct pyro_pbm *pbm, int node, pci_chipset_tag_t pc)
{
	pci_chipset_tag_t npc;

	npc = malloc(sizeof *npc, M_DEVBUF, M_NOWAIT);
	if (npc == NULL)
		panic("pyro: could not allocate pci_chipset_tag_t");
	memcpy(npc, pc, sizeof *pc);
	npc->cookie = pbm;
	npc->rootnode = node;
	return (npc);
}

int
pyro_dmamap_create(bus_dma_tag_t t, bus_dma_tag_t t0, bus_size_t size,
    int nsegments, bus_size_t maxsegsz, bus_size_t boundary, int flags,
    bus_dmamap_t *dmamp)
{
	struct pyro_pbm *pp = t->_cookie;

	return (iommu_dvmamap_create(t, t0, &pp->pp_sb, size, nsegments,
	    maxsegsz, boundary, flags, dmamp));
}

int
pyro_bus_map(bus_space_tag_t t, bus_space_tag_t t0, bus_addr_t offset,
    bus_size_t size, int flags, bus_space_handle_t *hp)
{
	struct pyro_pbm *pbm = t->cookie;
	int i, ss;

	DPRINTF(PDB_BUSMAP, ("pyro_bus_map: type %d off %llx sz %llx flags %d",
	    t->default_type,
	    (unsigned long long)offset,
	    (unsigned long long)size,
	    flags));

	ss = t->default_type;
	DPRINTF(PDB_BUSMAP, (" cspace %d", ss));

	if (t->parent == 0 || t->parent->sparc_bus_map == 0) {
		printf("\npyro_bus_map: invalid parent");
		return (EINVAL);
	}

	if (flags & BUS_SPACE_MAP_PROMADDRESS) {
		return ((*t->parent->sparc_bus_map)
		    (t, t0, offset, size, flags, hp));
	}

	for (i = 0; i < pbm->pp_nrange; i++) {
		bus_addr_t paddr;

		if (((pbm->pp_range[i].cspace >> 24) & 0x03) != ss)
			continue;

		paddr = pbm->pp_range[i].phys_lo + offset;
		paddr |= ((bus_addr_t)pbm->pp_range[i].phys_hi) << 32;
		return ((*t->parent->sparc_bus_map)
		    (t, t0, paddr, size, flags, hp));
	}

	return (EINVAL);
}

paddr_t
pyro_bus_mmap(bus_space_tag_t t, bus_space_tag_t t0, bus_addr_t paddr,
    off_t off, int prot, int flags)
{
	bus_addr_t offset = paddr;
	struct pyro_pbm *pbm = t->cookie;
	int i, ss;

	ss = t->default_type;

	DPRINTF(PDB_BUSMAP, ("pyro_bus_mmap: prot %d flags %d pa %llx\n",
	    prot, flags, (unsigned long long)paddr));

	if (t->parent == 0 || t->parent->sparc_bus_mmap == 0) {
		printf("\npyro_bus_mmap: invalid parent");
		return (-1);
	}

	for (i = 0; i < pbm->pp_nrange; i++) {
		bus_addr_t paddr;

		if (((pbm->pp_range[i].cspace >> 24) & 0x03) != ss)
			continue;

		paddr = pbm->pp_range[i].phys_lo + offset;
		paddr |= ((bus_addr_t)pbm->pp_range[i].phys_hi) << 32;
		return ((*t->parent->sparc_bus_mmap)
		    (t, t0, paddr, off, prot, flags));
	}

	return (-1);
}

void *
pyro_intr_establish(bus_space_tag_t t, bus_space_tag_t t0, int ihandle,
    int level, int flags, int (*handler)(void *), void *arg, const char *what)
{
	struct pyro_pbm *pbm = t->cookie;
	struct pyro_softc *sc = pbm->pp_sc;
	struct intrhand *ih = NULL;
	volatile u_int64_t *intrmapptr = NULL, *intrclrptr = NULL;
	int ino;

	if (ihandle & PCI_INTR_MSI) {
		pci_chipset_tag_t pc = pbm->pp_pc;
		pcitag_t tag = ihandle & ~PCI_INTR_MSI;
		int msinum = pbm->pp_msinum++;
		u_int64_t reg;

		ih = bus_intr_allocate(t0, handler, arg, ihandle, level,
		     NULL, NULL, what);
		if (ih == NULL)
			return (NULL);

		evcount_attach(&ih->ih_count, ih->ih_name, NULL);

		ih->ih_ack = pyro_msi_ack;

		pbm->pp_msi[msinum] = ih;
		ih->ih_number = msinum;

		if (flags & BUS_INTR_ESTABLISH_MPSAFE)
			ih->ih_mpsafe = 1;

		pci_msi_enable(pc, tag, pbm->pp_msiaddr, msinum);

		/* Map MSI to the right EQ and mark it as valid. */
		reg = bus_space_read_8(sc->sc_bust, sc->sc_csrh,
		    FIRE_MSI_MAP + msinum * 8);
		reg &= ~FIRE_MSI_MAP_EQNUM;
		bus_space_write_8(sc->sc_bust, sc->sc_csrh,
		    FIRE_MSI_MAP + msinum * 8, reg);

		bus_space_write_8(sc->sc_bust, sc->sc_csrh,
		    FIRE_MSI_CLEAR + msinum * 8, FIRE_MSI_CLEAR_EQWR_N);

		reg = bus_space_read_8(sc->sc_bust, sc->sc_csrh,
		    FIRE_MSI_MAP + msinum * 8);
		reg |= FIRE_MSI_MAP_V;
		bus_space_write_8(sc->sc_bust, sc->sc_csrh,
		    FIRE_MSI_MAP + msinum * 8, reg);

		return (ih);
	}

	ino = INTINO(ihandle);

	if (level == IPL_NONE)
		level = INTLEV(ihandle);
	if (level == IPL_NONE) {
		printf(": no IPL, setting IPL 2.\n");
		level = 2;
	}

	if ((flags & BUS_INTR_ESTABLISH_SOFTINTR) == 0) {
		u_int64_t *imap, *iclr;

		imap = bus_space_vaddr(sc->sc_bust, sc->sc_csrh) + 0x1000;
		iclr = bus_space_vaddr(sc->sc_bust, sc->sc_csrh) + 0x1400;
		intrmapptr = &imap[ino];
		intrclrptr = &iclr[ino];
		ino |= INTVEC(ihandle);
	}

	ih = bus_intr_allocate(t0, handler, arg, ino, level, intrmapptr,
	    intrclrptr, what);
	if (ih == NULL)
		return (NULL);

	if (flags & BUS_INTR_ESTABLISH_MPSAFE)
		ih->ih_mpsafe = 1;

	intr_establish(ih->ih_pil, ih);

	if (intrmapptr != NULL) {
		u_int64_t intrmap;

		intrmap = *intrmapptr;
		intrmap &= ~FIRE_INTRMAP_INT_CNTRL_NUM_MASK;
		intrmap |= FIRE_INTRMAP_INT_CNTRL_NUM0;
		if (sc->sc_oberon) {
			intrmap &= ~OBERON_INTRMAP_T_DESTID_MASK;
			intrmap |= CPU_JUPITERID <<
			    OBERON_INTRMAP_T_DESTID_SHIFT;
		} else {
			intrmap &= ~FIRE_INTRMAP_T_JPID_MASK;
			intrmap |= CPU_UPAID << FIRE_INTRMAP_T_JPID_SHIFT;
		}
		intrmap |= INTMAP_V;
		*intrmapptr = intrmap;
		intrmap = *intrmapptr;
		ih->ih_number |= intrmap & INTMAP_INR;
	}

	return (ih);
}

void
pyro_msi_ack(struct intrhand *ih)
{
}

int
pyro_msi_eq_intr(void *arg)
{
	struct pyro_pbm *pbm = arg;
	struct pyro_softc *sc = pbm->pp_sc;
	struct msi_eq *meq = pbm->pp_meq;
	struct pyro_msi_msg *msg;
	uint64_t head, tail;
	struct intrhand *ih;
	int msinum;

	head = bus_space_read_8(sc->sc_bust, sc->sc_csrh, FIRE_EQ_HEAD);
	tail = bus_space_read_8(sc->sc_bust, sc->sc_csrh, FIRE_EQ_TAIL);

	if (head == tail)
		return (0);

	while (head != tail) {
		msg = (struct pyro_msi_msg *)meq->meq_va;

		if (msg[head].mm_type == 0)
			break;
		msg[head].mm_type = 0;

		msinum = msg[head].mm_data;
		ih = pbm->pp_msi[msinum];
		bus_space_write_8(sc->sc_bust, sc->sc_csrh,
		    FIRE_MSI_CLEAR + msinum * 8, FIRE_MSI_CLEAR_EQWR_N);

		send_softint(-1, ih->ih_pil, ih);

		head += 1;
		head &= (meq->meq_nentries - 1);
	}

	bus_space_write_8(sc->sc_bust, sc->sc_csrh, FIRE_EQ_HEAD, head);

	return (1);
}

#ifdef DDB
void
pyro_xir(void *arg, int cpu)
{
	struct pyro_softc *sc = arg;

	bus_space_write_8(sc->sc_bust, sc->sc_xbch, FIRE_RESET_GEN,
	    FIRE_RESET_GEN_XIR);
}
#endif

const struct cfattach pyro_ca = {
	sizeof(struct pyro_softc), pyro_match, pyro_attach
};

struct cfdriver pyro_cd = {
	NULL, "pyro", DV_DULL
};
@


1.30
log
@no need to test if an array is non-NULL
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pyro.c,v 1.29 2016/08/23 03:28:01 guenther Exp $	*/
d375 1
a375 1
	membar(Sync);
d379 1
a379 1
	membar(Sync);
@


1.29
log
@Convert %q to %ll in format strings

ok natano@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pyro.c,v 1.28 2014/12/09 06:58:29 doug Exp $	*/
d625 1
a625 4
		if (ih->ih_name)
			evcount_attach(&ih->ih_count, ih->ih_name, NULL);
		else
			evcount_attach(&ih->ih_count, "unknown", NULL);
@


1.28
log
@Replace some malloc(n*size,...) calls with mallocarray().

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pyro.c,v 1.27 2014/07/12 18:44:43 tedu Exp $	*/
d537 1
a537 1
	DPRINTF(PDB_BUSMAP, ("pyro_bus_map: type %d off %qx sz %qx flags %d",
d581 1
a581 1
	DPRINTF(PDB_BUSMAP, ("pyro_bus_mmap: prot %d flags %d pa %qx\n",
@


1.27
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: pyro.c,v 1.26 2014/01/21 10:59:30 dlg Exp $	*/
d307 2
a308 2
	pbm->pp_msi = malloc(msis * sizeof(*pbm->pp_msi),
	    M_DEVBUF, M_NOWAIT | M_ZERO);
@


1.26
log
@enable MPSAFE interrupts on pyro. it seems to work ok.

kettenis@@ told me where to put these lines
@
text
@d1 1
a1 1
/*	$OpenBSD: pyro.c,v 1.25 2013/05/13 19:27:16 kettenis Exp $	*/
d253 1
a253 1
	free(busranges, M_DEVBUF);
d350 1
a350 1
	free(pbm->pp_msi, M_DEVBUF);
@


1.25
log
@Get rid of some silly underscores.
@
text
@d1 1
a1 1
/*	$OpenBSD: pyro.c,v 1.24 2012/08/20 15:23:25 kettenis Exp $	*/
d635 3
d682 3
@


1.24
log
@MISs work on Oberon as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: pyro.c,v 1.23 2011/07/06 22:26:44 kettenis Exp $	*/
d112 1
a112 1
bus_space_tag_t _pyro_alloc_bus_tag(struct pyro_pbm *, const char *,
d121 1
a121 1
int _pyro_bus_map(bus_space_tag_t, bus_space_tag_t, bus_addr_t,
d123 1
a123 1
paddr_t _pyro_bus_mmap(bus_space_tag_t, bus_space_tag_t, bus_addr_t, off_t,
d125 1
a125 1
void *_pyro_intr_establish(bus_space_tag_t, bus_space_tag_t, int, int, int,
d338 1
a338 1
	if (_pyro_intr_establish(pbm->pp_memt, sc->sc_bust, ihandle,
d436 1
a436 1
	return (_pyro_alloc_bus_tag(pp, "mem",
d444 1
a444 1
	return (_pyro_alloc_bus_tag(pp, "io",
d452 1
a452 1
	return (_pyro_alloc_bus_tag(pp, "cfg",
d458 1
a458 1
_pyro_alloc_bus_tag(struct pyro_pbm *pbm, const char *name, int ss,
d476 3
a478 3
	bt->sparc_bus_map = _pyro_bus_map;
	bt->sparc_bus_mmap = _pyro_bus_mmap;
	bt->sparc_intr_establish = _pyro_intr_establish;
d531 1
a531 1
_pyro_bus_map(bus_space_tag_t t, bus_space_tag_t t0, bus_addr_t offset,
d537 1
a537 1
	DPRINTF(PDB_BUSMAP, ("_pyro_bus_map: type %d off %qx sz %qx flags %d",
d547 1
a547 1
		printf("\n_pyro_bus_map: invalid parent");
d572 1
a572 1
_pyro_bus_mmap(bus_space_tag_t t, bus_space_tag_t t0, bus_addr_t paddr,
d581 1
a581 1
	DPRINTF(PDB_BUSMAP, ("_pyro_bus_mmap: prot %d flags %d pa %qx\n",
d585 1
a585 1
		printf("\n_pyro_bus_mmap: invalid parent");
d605 1
a605 1
_pyro_intr_establish(bus_space_tag_t t, bus_space_tag_t t0, int ihandle,
@


1.23
log
@Handle pci_conf_read() faults on reading non-existent registers that result
in master aborts.  Return 0xffffffff to emulate what happens on non-perfect
architectures in that case.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pyro.c,v 1.22 2011/07/06 05:48:57 kettenis Exp $	*/
a298 4

	/* Don't do MSI on Oberon for now. */
	if (sc->sc_oberon)
		return;
@


1.22
log
@Add MSI support to pyro(4).  Tested on a v215 with the on-board mpi(4).
@
text
@d1 1
a1 1
/*	$OpenBSD: pyro.c,v 1.22 2011/07/06 05:39:00 kettenis Exp $	*/
d374 16
a389 2
	return (bus_space_read_4(pc->bustag, pc->bushandle,
	    (PCITAG_OFFSET(tag) << 4) + reg));
@


1.21
log
@Fix some inconsistencies in how we build 64-bit addresses from OF properties.
@
text
@d1 1
a1 1
/*	$OpenBSD: pyro.c,v 1.20 2010/12/05 15:15:14 kettenis Exp $	*/
d40 1
d51 1
d65 18
d85 1
a85 1
#define FIRE_RESET_GEN_XIR		0x0000000000000002L
d104 1
d127 3
d229 2
a243 1
#if 0
a244 1
#endif
d292 65
d604 42
d693 45
@


1.20
log
@PCIe based sparc64 machines have always supported access to the extended PCIe
configuration space.  So on pyro(4) and vpci(4) return the size appropriate
for the extended PCIe configuration space.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pyro.c,v 1.19 2010/12/04 17:06:32 miod Exp $	*/
d497 1
a497 1
		paddr |= ((bus_addr_t)pbm->pp_range[i].phys_hi<<32);
@


1.19
log
@Introduce a new pci routine, pci_conf_size(), which returns the size of a
given pcitag_t configuration address space. Currently, all pci controllers
will return the usual 0x100 bytes of PCI configuration space, but this will
eventually change on PCIe-capable controlers.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pyro.c,v 1.18 2009/03/29 22:52:11 kettenis Exp $	*/
d279 1
a279 1
	return PCI_CONFIG_SPACE_SIZE;
@


1.18
log
@bzero pci attach args

ok deraadt@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pyro.c,v 1.17 2009/03/29 21:53:52 sthen Exp $	*/
d95 1
d224 1
d274 6
@


1.17
log
@make various strings ("can't map mem space" and similar) more consistent
between instances, saving space in the kernel. feedback from many (some
incorporated, some left for future work).

ok deraadt, kettenis, "why not" miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: pyro.c,v 1.16 2009/01/02 20:01:45 kettenis Exp $	*/
d212 1
a215 1
	pba.pba_bridgetag = NULL;
@


1.16
log
@Make IOMMU code use the generic _bus_dmamem_map() and _bus_dmamem_unmap().
@
text
@d1 1
a1 1
/*	$OpenBSD: pyro.c,v 1.15 2008/12/21 19:40:41 kettenis Exp $	*/
d205 1
a205 1
		panic("pyro: could not map config space");
@


1.15
log
@Make the "machine xir" ddb command work on machines with pyro(4).

tested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pyro.c,v 1.14 2008/07/12 13:08:04 kettenis Exp $	*/
a394 2
	dt->_dmamem_map		= iommu_dvmamem_map;
	dt->_dmamem_unmap	= iommu_dvmamem_unmap;
@


1.14
log
@Perform IOMMU cache flushes on Oberon.
@
text
@d1 1
a1 1
/*	$OpenBSD: pyro.c,v 1.13 2008/07/12 12:21:04 kettenis Exp $	*/
d41 4
d63 4
d109 4
d229 4
d557 11
@


1.13
log
@Use the proper interrupt target ID on Oberon.
@
text
@d1 1
a1 1
/*	$OpenBSD: pyro.c,v 1.11 2008/01/19 11:13:43 kettenis Exp $	*/
d242 4
@


1.12
log
@iLet's see if this also works for Oberon (the PCIe bridge found on the SPARC Enterprise M4000/M5000/M8000/M9000).
@
text
@d59 11
d519 10
a528 1
		intrmap |= (1LL << 6);
@


1.11
log
@Make host bridges provide their own implementation of pci_conf_read() and
pci_conf_write() and give pyro(4) an implementation suitable for PCIe.  For
psycho(4) and schizo(4), go back to the origional implementation.  This gets
rid of the 'tagshift' member of pci_chipset_tag_t, and clears the way for
sun4v.
@
text
@d1 1
a1 1
/*	$OpenBSD: pyro.c,v 1.10 2007/10/10 11:31:49 krw Exp $	*/
d100 2
a101 1
	if (strcmp(str, "pciex108e,80f0") == 0)
d112 1
d138 4
@


1.10
log
@malloc+bzero -> malloc+M_ZERO. Use 'malloc(sizeof(*p) ...' idiom.

This completes my bzero/memset(,0,) -> M_ZERO sweep of the tree.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pyro.c,v 1.9 2007/10/08 18:30:13 krw Exp $	*/
d76 3
d194 2
d237 14
a373 1
	npc->tagshift = 4;	/* PCIe has a larger config space */
@


1.9
log
@A few trailing bzero/memset -> M_ZERO occurrences, cast removal and
size(*p) usage. This should be the last of the simple malloc()
changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: pyro.c,v 1.8 2007/09/18 00:46:41 krw Exp $	*/
d325 1
a325 2
	dt = (bus_dma_tag_t)malloc(sizeof(struct sparc_bus_dma_tag),
	    M_DEVBUF, M_NOWAIT);
a328 1
	bzero(dt, sizeof(*dt));
@


1.8
log
@Only the most obvious bzero() -> M_ZERO changes. No cast changes, no
MALLOC/FREE, etc. Just adding M_ZERO to malloc() and deleting an
immediately adjacent bzero().
@
text
@d1 1
a1 1
/*	$OpenBSD: pyro.c,v 1.7 2007/04/03 19:59:01 kettenis Exp $	*/
d144 1
a144 1
	pbm = (struct pyro_pbm *)malloc(sizeof(*pbm), M_DEVBUF, M_NOWAIT);
a146 1
	bzero(pbm, sizeof(*pbm));
@


1.7
log
@Add iommu glue.
@
text
@d1 1
a1 1
/*	$OpenBSD: pyro.c,v 1.6 2007/04/01 21:41:09 kettenis Exp $	*/
d302 1
a302 1
	bt = malloc(sizeof(*bt), M_DEVBUF, M_NOWAIT);
a305 1
	bzero(bt, sizeof *bt);
@


1.6
log
@Add code to establish interrupts.
@
text
@d1 1
a1 1
/*	$OpenBSD: pyro.c,v 1.5 2007/04/01 12:50:18 kettenis Exp $	*/
d64 1
d165 3
d199 26
d368 4
a371 1
	return (ENOMEM);
@


1.5
log
@Shift pci tags for PCIe.
@
text
@d1 1
a1 1
/*	$OpenBSD: pyro.c,v 1.4 2007/04/01 12:48:07 kettenis Exp $	*/
d112 2
d121 12
d419 44
a462 1
	return (NULL);
@


1.4
log
@Provide (non functional) dma tag.
@
text
@d1 1
a1 1
/*	$OpenBSD: pyro.c,v 1.3 2007/03/31 22:14:52 kettenis Exp $	*/
d315 1
@


1.3
log
@Map PCIe config space.
@
text
@d1 1
a1 1
/*	$OpenBSD: pyro.c,v 1.2 2007/03/31 19:05:31 kettenis Exp $	*/
d73 1
d83 3
a152 1
#if 0
a153 1
#endif
d277 27
d316 8
@


1.2
log
@Fix DEBUG.
@
text
@d1 1
a1 1
/*	$OpenBSD: pyro.c,v 1.1 2007/03/30 22:24:56 kettenis Exp $	*/
d152 3
@


1.1
log
@First stab at a driver for the Host/PCIe bridge found on the Sun Fire
v215/v245/v445 systems.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d293 1
a293 1
	DPRINTF(SDB_BUSMAP, ("_pyro_bus_map: type %d off %qx sz %qx flags %d",
@

