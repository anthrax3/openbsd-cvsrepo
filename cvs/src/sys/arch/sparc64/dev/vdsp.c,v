head	1.42;
access;
symbols
	OPENBSD_6_2:1.42.0.8
	OPENBSD_6_2_BASE:1.42
	OPENBSD_6_1:1.42.0.6
	OPENBSD_6_1_BASE:1.42
	OPENBSD_6_0:1.42.0.2
	OPENBSD_6_0_BASE:1.42
	OPENBSD_5_9:1.41.0.2
	OPENBSD_5_9_BASE:1.41
	OPENBSD_5_8:1.39.0.6
	OPENBSD_5_8_BASE:1.39
	OPENBSD_5_7:1.39.0.2
	OPENBSD_5_7_BASE:1.39
	OPENBSD_5_6:1.27.0.4
	OPENBSD_5_6_BASE:1.27
	OPENBSD_5_5:1.24.0.4
	OPENBSD_5_5_BASE:1.24
	OPENBSD_5_4:1.19.0.2
	OPENBSD_5_4_BASE:1.19
	OPENBSD_5_3:1.18.0.2
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.10.0.8
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.6
	OPENBSD_5_0:1.10.0.4
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.2
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.2.0.2
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.1.0.2
	OPENBSD_4_7_BASE:1.1;
locks; strict;
comment	@ * @;


1.42
date	2016.03.19.12.04.15;	author natano;	state Exp;
branches;
next	1.41;
commitid	gAjwyca5TfuoJAhn;

1.41
date	2015.12.29.04.46.28;	author mmcc;	state Exp;
branches;
next	1.40;
commitid	QKSTqnEw1KIrhSLM;

1.40
date	2015.09.15.21.04.10;	author kettenis;	state Exp;
branches;
next	1.39;
commitid	i2NLeYVyMNJxqjSJ;

1.39
date	2015.02.11.12.09.18;	author miod;	state Exp;
branches;
next	1.38;
commitid	lQICcl8ltXh6vHZf;

1.38
date	2015.02.11.01.40.42;	author dlg;	state Exp;
branches;
next	1.37;
commitid	GYTDnP2pcCHBWbLm;

1.37
date	2015.01.27.03.17.35;	author dlg;	state Exp;
branches;
next	1.36;
commitid	MyKPm9Q3dQu92BiX;

1.36
date	2015.01.25.21.42.13;	author kettenis;	state Exp;
branches;
next	1.35;
commitid	ZoO3iubG0jt8mq0g;

1.35
date	2015.01.23.12.41.23;	author dlg;	state Exp;
branches;
next	1.34;
commitid	y4GSgm8ZhDqVs5Fx;

1.34
date	2014.12.17.19.39.01;	author tedu;	state Exp;
branches;
next	1.33;
commitid	tfI16Mtx7wd6kmar;

1.33
date	2014.12.09.06.58.29;	author doug;	state Exp;
branches;
next	1.32;
commitid	yWAxzpQP2PPpYlfT;

1.32
date	2014.09.29.19.34.23;	author kettenis;	state Exp;
branches;
next	1.31;
commitid	G3k6cv1A2IbnIbUW;

1.31
date	2014.09.29.17.48.51;	author kettenis;	state Exp;
branches;
next	1.30;
commitid	IoC86PsxZecifmsg;

1.30
date	2014.09.29.10.27.43;	author kettenis;	state Exp;
branches;
next	1.29;
commitid	h5ww9LxkJicOcxvn;

1.29
date	2014.09.28.19.14.36;	author kettenis;	state Exp;
branches;
next	1.28;
commitid	Hoee3gfEvLOJ7Uyq;

1.28
date	2014.09.22.08.26.16;	author kettenis;	state Exp;
branches;
next	1.27;
commitid	t15OoIafkWkko0Rz;

1.27
date	2014.07.12.18.44.43;	author tedu;	state Exp;
branches;
next	1.26;
commitid	uKVPYMN2MLxdZxzH;

1.26
date	2014.05.10.11.49.31;	author kettenis;	state Exp;
branches;
next	1.25;

1.25
date	2014.04.03.09.15.06;	author mpi;	state Exp;
branches;
next	1.24;

1.24
date	2014.01.24.09.58.03;	author kettenis;	state Exp;
branches;
next	1.23;

1.23
date	2014.01.23.23.53.33;	author kettenis;	state Exp;
branches;
next	1.22;

1.22
date	2014.01.23.04.09.44;	author kettenis;	state Exp;
branches;
next	1.21;

1.21
date	2014.01.23.01.37.18;	author kettenis;	state Exp;
branches;
next	1.20;

1.20
date	2014.01.23.00.19.09;	author kettenis;	state Exp;
branches;
next	1.19;

1.19
date	2013.07.12.18.51.03;	author kettenis;	state Exp;
branches;
next	1.18;

1.18
date	2012.12.08.20.38.10;	author kettenis;	state Exp;
branches;
next	1.17;

1.17
date	2012.12.08.12.35.04;	author kettenis;	state Exp;
branches;
next	1.16;

1.16
date	2012.12.03.19.57.04;	author kettenis;	state Exp;
branches;
next	1.15;

1.15
date	2012.12.02.19.34.35;	author kettenis;	state Exp;
branches;
next	1.14;

1.14
date	2012.12.01.11.59.05;	author kettenis;	state Exp;
branches;
next	1.13;

1.13
date	2012.10.26.20.57.08;	author kettenis;	state Exp;
branches;
next	1.12;

1.12
date	2012.10.21.19.30.56;	author kettenis;	state Exp;
branches;
next	1.11;

1.11
date	2012.10.21.18.56.00;	author kettenis;	state Exp;
branches;
next	1.10;

1.10
date	2011.01.07.00.46.48;	author kettenis;	state Exp;
branches;
next	1.9;

1.9
date	2011.01.07.00.43.11;	author kettenis;	state Exp;
branches;
next	1.8;

1.8
date	2011.01.06.23.26.48;	author kettenis;	state Exp;
branches;
next	1.7;

1.7
date	2011.01.06.18.40.09;	author kettenis;	state Exp;
branches;
next	1.6;

1.6
date	2011.01.02.22.28.29;	author kettenis;	state Exp;
branches;
next	1.5;

1.5
date	2011.01.02.12.11.22;	author kettenis;	state Exp;
branches;
next	1.4;

1.4
date	2011.01.02.00.49.05;	author kettenis;	state Exp;
branches;
next	1.3;

1.3
date	2011.01.02.00.35.23;	author kettenis;	state Exp;
branches;
next	1.2;

1.2
date	2010.04.20.23.26.59;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2009.12.31.11.58.41;	author kettenis;	state Exp;
branches;
next	;


desc
@@


1.42
log
@Remove the unused flags argument from VOP_UNLOCK().

torture tested on amd64, i386 and macppc
ok beck mpi stefan
"the change looks right" deraadt
@
text
@/*	$OpenBSD: vdsp.c,v 1.41 2015/12/29 04:46:28 mmcc Exp $	*/
/*
 * Copyright (c) 2009, 2011, 2014 Mark Kettenis
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/conf.h>
#include <sys/proc.h>
#include <sys/buf.h>
#include <sys/device.h>
#include <sys/disklabel.h>
#include <sys/fcntl.h>
#include <sys/lock.h>
#include <sys/malloc.h>
#include <sys/mutex.h>
#include <sys/namei.h>
#include <sys/systm.h>
#include <sys/task.h>
#include <sys/vnode.h>
#include <sys/dkio.h>
#include <sys/specdev.h>

#include <machine/autoconf.h>
#include <machine/conf.h>
#include <machine/hypervisor.h>
#include <machine/mdesc.h>

#include <uvm/uvm_extern.h>

#include <scsi/scsi_all.h>
#include <scsi/scsi_disk.h>
#include <scsi/scsiconf.h>

#include <isofs/cd9660/iso.h>

#include <dev/sun/disklabel.h>

#include <sparc64/dev/cbusvar.h>
#include <sparc64/dev/ldcvar.h>
#include <sparc64/dev/viovar.h>

#ifdef VDSP_DEBUG
#define DPRINTF(x)	printf x
#else
#define DPRINTF(x)
#endif

#define VDSK_TX_ENTRIES			64
#define VDSK_RX_ENTRIES			64

#define VDSK_MAX_DESCRIPTORS		1024
#define VDSK_MAX_DESCRIPTOR_SIZE	512

struct vd_attr_info {
	struct vio_msg_tag	tag;
	uint8_t			xfer_mode;
	uint8_t			vd_type;
	uint8_t			vd_mtype;
	uint8_t			_reserved1;
	uint32_t		vdisk_block_size;
	uint64_t		operations;
	uint64_t		vdisk_size;
	uint64_t		max_xfer_sz;
	uint64_t		_reserved2[2];
};

#define VD_DISK_TYPE_SLICE	0x01
#define VD_DISK_TYPE_DISK	0x02

#define VD_MEDIA_TYPE_FIXED	0x01
#define VD_MEDIA_TYPE_CD	0x02
#define VD_MEDIA_TYPE_DVD	0x03

/* vDisk version 1.0. */
#define VD_OP_BREAD		0x01
#define VD_OP_BWRITE		0x02
#define VD_OP_FLUSH		0x03
#define VD_OP_GET_WCE		0x04
#define VD_OP_SET_WCE		0x05
#define VD_OP_GET_VTOC		0x06
#define VD_OP_SET_VTOC		0x07
#define VD_OP_GET_DISKGEOM	0x08
#define VD_OP_SET_DISKGEOM	0x09
#define VD_OP_GET_DEVID		0x0b
#define VD_OP_GET_EFI		0x0c
#define VD_OP_SET_EFI		0x0d

/* vDisk version 1.1 */
#define VD_OP_SCSICMD		0x0a
#define VD_OP_RESET		0x0e
#define VD_OP_GET_ACCESS	0x0f
#define VD_OP_SET_ACCESS	0x10
#define VD_OP_GET_CAPACITY	0x11

/* Sun standard fields. */
struct sun_vtoc_preamble {
	char	sl_text[128];
	u_int	sl_version;	/* label version */
	char	sl_volume[8];	/* short volume name */
	u_short	sl_nparts;	/* partition count */

	struct sun_partinfo sl_part[8];

	u_int	sl_bootinfo[3];
	u_int	sl_sanity;
};

struct vd_vtoc_part {
	uint16_t	id_tag;
	uint16_t	perm;
	uint32_t	reserved;
	uint64_t	start;
	uint64_t	nblocks;
	
};
struct vd_vtoc {
	uint8_t		volume_name[8];
	uint16_t	sector_size;
	uint16_t	num_partitions;
	uint32_t	reserved;
	uint8_t		ascii_label[128];
	struct vd_vtoc_part partition[8];
};

struct vd_diskgeom {
	uint16_t	ncyl;
	uint16_t	acyl;
	uint16_t	bcyl;
	uint16_t	nhead;
	uint16_t	nsect;
	uint16_t	intrlv;
	uint16_t	apc;
	uint16_t	rpm;
	uint16_t	pcyl;
	uint16_t	write_reinstruct;
	uint16_t	read_reinstruct;
};

struct vd_desc {
	struct vio_dring_hdr	hdr;
	uint64_t		req_id;
	uint8_t			operation;
	uint8_t			slice;
	uint16_t		_reserved1;
	uint32_t		status;
	uint64_t		offset;
	uint64_t		size;
	uint32_t		ncookies;
	uint32_t		_reserved2;
	struct ldc_cookie	cookie[1];
};

#define VD_SLICE_NONE		0xff

struct vdsk_desc_msg {
	struct vio_msg_tag	tag;
	uint64_t		seq_no;
	uint64_t		desc_handle;
	uint64_t		req_id;
	uint8_t			operation;
	uint8_t			slice;
	uint16_t		_reserved1;
	uint32_t		status;
	uint64_t		offset;
	uint64_t		size;
	uint32_t		ncookies;
	uint32_t		_reserved2;
	struct ldc_cookie	cookie[1];
};

/*
 * We support vDisk 1.1.
 */
#define VDSK_MAJOR	1
#define VDSK_MINOR	1

/*
 * But we only support a subset of the defined commands.
 */
#define VD_OP_MASK \
    ((1 << VD_OP_BREAD) | (1 << VD_OP_BWRITE) | (1 << VD_OP_FLUSH) | \
     (1 << VD_OP_GET_WCE) | (1 << VD_OP_SET_WCE) | \
     (1 << VD_OP_GET_VTOC) | (1 << VD_OP_SET_VTOC) | \
     (1 << VD_OP_GET_DISKGEOM))

struct vdsp_softc {
	struct device	sc_dv;
	int		sc_idx;
	bus_space_tag_t	sc_bustag;
	bus_dma_tag_t	sc_dmatag;

	uint64_t	sc_tx_ino;
	uint64_t	sc_rx_ino;
	void		*sc_tx_ih;
	void		*sc_rx_ih;

	struct ldc_conn	sc_lc;

	uint16_t	sc_vio_state;
#define VIO_SND_VER_INFO	0x0001
#define VIO_ACK_VER_INFO	0x0002
#define VIO_RCV_VER_INFO	0x0004
#define VIO_SND_ATTR_INFO	0x0008
#define VIO_ACK_ATTR_INFO	0x0010
#define VIO_RCV_ATTR_INFO	0x0020
#define VIO_SND_DRING_REG	0x0040
#define VIO_ACK_DRING_REG	0x0080
#define VIO_RCV_DRING_REG	0x0100
#define VIO_SND_RDX		0x0200
#define VIO_ACK_RDX		0x0400
#define VIO_RCV_RDX		0x0800

	uint16_t	sc_major;
	uint16_t	sc_minor;

	uint8_t		sc_xfer_mode;

	uint32_t	sc_local_sid;
	uint64_t	sc_seq_no;

	uint64_t	sc_dring_ident;
	uint32_t	sc_num_descriptors;
	uint32_t	sc_descriptor_size;
	struct ldc_cookie sc_dring_cookie;

	struct task	sc_open_task;
	struct task	sc_alloc_task;
	struct task	sc_close_task;

	struct mutex	sc_desc_mtx;
	struct vdsk_desc_msg *sc_desc_msg[VDSK_RX_ENTRIES];
	int		sc_desc_head;
	int		sc_desc_tail;

	struct task	sc_read_task;

	caddr_t		sc_vd;
	struct task	sc_vd_task;
	struct vd_desc	**sc_vd_ring;
	u_int		sc_vd_prod;
	u_int		sc_vd_cons;

	uint32_t	sc_vdisk_block_size;
	uint64_t	sc_vdisk_size;

	struct vnode	*sc_vp;

	struct sun_disklabel *sc_label;
	uint16_t	sc_ncyl;
	uint16_t	sc_acyl;
	uint16_t	sc_nhead;
	uint16_t	sc_nsect;
};

int	vdsp_match(struct device *, void *, void *);
void	vdsp_attach(struct device *, struct device *, void *);

struct cfattach vdsp_ca = {
	sizeof(struct vdsp_softc), vdsp_match, vdsp_attach
};

struct cfdriver vdsp_cd = {
	NULL, "vdsp", DV_DULL
};

int	vdsp_tx_intr(void *);
int	vdsp_rx_intr(void *);

void	vdsp_rx_data(struct ldc_conn *, struct ldc_pkt *);
void	vdsp_rx_vio_ctrl(struct vdsp_softc *, struct vio_msg *);
void	vdsp_rx_vio_ver_info(struct vdsp_softc *, struct vio_msg_tag *);
void	vdsp_rx_vio_attr_info(struct vdsp_softc *, struct vio_msg_tag *);
void	vdsp_rx_vio_dring_reg(struct vdsp_softc *, struct vio_msg_tag *);
void	vdsp_rx_vio_rdx(struct vdsp_softc *sc, struct vio_msg_tag *);
void	vdsp_rx_vio_data(struct vdsp_softc *sc, struct vio_msg *);
void	vdsp_rx_vio_dring_data(struct vdsp_softc *sc,
	    struct vio_msg_tag *);
void	vdsp_rx_vio_desc_data(struct vdsp_softc *sc, struct vio_msg_tag *);

void	vdsp_ldc_reset(struct ldc_conn *);
void	vdsp_ldc_start(struct ldc_conn *);

void	vdsp_sendmsg(struct vdsp_softc *, void *, size_t, int dowait);

void	vdsp_open(void *);
void	vdsp_close(void *);
void	vdsp_alloc(void *);
void	vdsp_readlabel(struct vdsp_softc *);
int	vdsp_writelabel(struct vdsp_softc *);
int	vdsp_is_iso(struct vdsp_softc *);
void	vdsp_read(void *);
void	vdsp_read_desc(struct vdsp_softc *, struct vdsk_desc_msg *);
void	vdsp_vd_task(void *);
void	vdsp_read_dring(void *, void *);
void	vdsp_write_dring(void *, void *);
void	vdsp_flush_dring(void *, void *);
void	vdsp_get_vtoc(void *, void *);
void	vdsp_set_vtoc(void *, void *);
void	vdsp_get_diskgeom(void *, void *);
void	vdsp_unimp(void *, void *);

void	vdsp_ack_desc(struct vdsp_softc *, struct vd_desc *);

int
vdsp_match(struct device *parent, void *match, void *aux)
{
	struct cbus_attach_args *ca = aux;

	if (strcmp(ca->ca_name, "vds-port") == 0)
		return (1);

	return (0);
}

void
vdsp_attach(struct device *parent, struct device *self, void *aux)
{
	struct vdsp_softc *sc = (struct vdsp_softc *)self;
	struct cbus_attach_args *ca = aux;
	struct ldc_conn *lc;

	sc->sc_idx = ca->ca_idx;
	sc->sc_bustag = ca->ca_bustag;
	sc->sc_dmatag = ca->ca_dmatag;
	sc->sc_tx_ino = ca->ca_tx_ino;
	sc->sc_rx_ino = ca->ca_rx_ino;

	printf(": ivec 0x%llx, 0x%llx", sc->sc_tx_ino, sc->sc_rx_ino);

	mtx_init(&sc->sc_desc_mtx, IPL_BIO);

	/*
	 * Un-configure queues before registering interrupt handlers,
	 * such that we dont get any stale LDC packets or events.
	 */
	hv_ldc_tx_qconf(ca->ca_id, 0, 0);
	hv_ldc_rx_qconf(ca->ca_id, 0, 0);

	sc->sc_tx_ih = bus_intr_establish(ca->ca_bustag, sc->sc_tx_ino,
	    IPL_BIO, BUS_INTR_ESTABLISH_MPSAFE, vdsp_tx_intr, sc,
	    sc->sc_dv.dv_xname);
	sc->sc_rx_ih = bus_intr_establish(ca->ca_bustag, sc->sc_rx_ino,
	    IPL_BIO, BUS_INTR_ESTABLISH_MPSAFE, vdsp_rx_intr, sc,
	    sc->sc_dv.dv_xname);
	if (sc->sc_tx_ih == NULL || sc->sc_rx_ih == NULL) {
		printf(", can't establish interrupt\n");
		return;
	}

	lc = &sc->sc_lc;
	lc->lc_id = ca->ca_id;
	lc->lc_sc = sc;
	lc->lc_reset = vdsp_ldc_reset;
	lc->lc_start = vdsp_ldc_start;
	lc->lc_rx_data = vdsp_rx_data;

	lc->lc_txq = ldc_queue_alloc(sc->sc_dmatag, VDSK_TX_ENTRIES);
	if (lc->lc_txq == NULL) {
		printf(", can't allocate tx queue\n");
		return;
	}

	lc->lc_rxq = ldc_queue_alloc(sc->sc_dmatag, VDSK_RX_ENTRIES);
	if (lc->lc_rxq == NULL) {
		printf(", can't allocate rx queue\n");
		goto free_txqueue;
	}

	task_set(&sc->sc_open_task, vdsp_open, sc);
	task_set(&sc->sc_alloc_task, vdsp_alloc, sc);
	task_set(&sc->sc_close_task, vdsp_close, sc);
	task_set(&sc->sc_read_task, vdsp_read, sc);

	printf("\n");

	return;

#if 0
free_rxqueue:
	ldc_queue_free(sc->sc_dmatag, lc->lc_rxq);
#endif
free_txqueue:
	ldc_queue_free(sc->sc_dmatag, lc->lc_txq);
}

int
vdsp_tx_intr(void *arg)
{
	struct vdsp_softc *sc = arg;
	struct ldc_conn *lc = &sc->sc_lc;
	uint64_t tx_head, tx_tail, tx_state;
	int err;

	err = hv_ldc_tx_get_state(lc->lc_id, &tx_head, &tx_tail, &tx_state);
	if (err != H_EOK) {
		printf("hv_ldc_rx_get_state %d\n", err);
		return (0);
	}

	if (tx_state != lc->lc_tx_state) {
		switch (tx_state) {
		case LDC_CHANNEL_DOWN:
			DPRINTF(("Tx link down\n"));
			break;
		case LDC_CHANNEL_UP:
			DPRINTF(("Tx link up\n"));
			break;
		case LDC_CHANNEL_RESET:
			DPRINTF(("Tx link reset\n"));
			break;
		}
		lc->lc_tx_state = tx_state;
	}

	wakeup(lc->lc_txq);
	return (1);
}

int
vdsp_rx_intr(void *arg)
{
	struct vdsp_softc *sc = arg;
	struct ldc_conn *lc = &sc->sc_lc;
	uint64_t rx_head, rx_tail, rx_state;
	struct ldc_pkt *lp;
	int err;

	err = hv_ldc_rx_get_state(lc->lc_id, &rx_head, &rx_tail, &rx_state);
	if (err == H_EINVAL)
		return (0);
	if (err != H_EOK) {
		printf("hv_ldc_rx_get_state %d\n", err);
		return (0);
	}

	if (rx_state != lc->lc_rx_state) {
		switch (rx_state) {
		case LDC_CHANNEL_DOWN:
			DPRINTF(("Rx link down\n"));
			lc->lc_tx_seqid = 0;
			lc->lc_state = 0;
			lc->lc_reset(lc);
			break;
		case LDC_CHANNEL_UP:
			DPRINTF(("Rx link up\n"));
			break;
		case LDC_CHANNEL_RESET:
			DPRINTF(("Rx link reset\n"));
			lc->lc_tx_seqid = 0;
			lc->lc_state = 0;
			lc->lc_reset(lc);
			break;
		}
		lc->lc_rx_state = rx_state;
		return (1);
	}

	if (lc->lc_rx_state == LDC_CHANNEL_DOWN)
		return (1);

	lp = (struct ldc_pkt *)(lc->lc_rxq->lq_va + rx_head);
	switch (lp->type) {
	case LDC_CTRL:
		ldc_rx_ctrl(lc, lp);
		break;

	case LDC_DATA:
		ldc_rx_data(lc, lp);
		break;

	default:
		DPRINTF(("0x%02x/0x%02x/0x%02x\n", lp->type, lp->stype,
		    lp->ctrl));
		ldc_reset(lc);
		break;
	}

	rx_head += sizeof(*lp);
	rx_head &= ((lc->lc_rxq->lq_nentries * sizeof(*lp)) - 1);
	err = hv_ldc_rx_set_qhead(lc->lc_id, rx_head);
	if (err != H_EOK)
		printf("%s: hv_ldc_rx_set_qhead %d\n", __func__, err);

	return (1);
}

void
vdsp_rx_data(struct ldc_conn *lc, struct ldc_pkt *lp)
{
	struct vio_msg *vm = (struct vio_msg *)lp;

	switch (vm->type) {
	case VIO_TYPE_CTRL:
		if ((lp->env & LDC_FRAG_START) == 0 &&
		    (lp->env & LDC_FRAG_STOP) == 0)
			return;
		vdsp_rx_vio_ctrl(lc->lc_sc, vm);
		break;

	case VIO_TYPE_DATA:
		if((lp->env & LDC_FRAG_START) == 0)
			return;
		vdsp_rx_vio_data(lc->lc_sc, vm);
		break;

	default:
		DPRINTF(("Unhandled packet type 0x%02x\n", vm->type));
		ldc_reset(lc);
		break;
	}
}

void
vdsp_rx_vio_ctrl(struct vdsp_softc *sc, struct vio_msg *vm)
{
	struct vio_msg_tag *tag = (struct vio_msg_tag *)&vm->type;

	switch (tag->stype_env) {
	case VIO_VER_INFO:
		vdsp_rx_vio_ver_info(sc, tag);
		break;
	case VIO_ATTR_INFO:
		vdsp_rx_vio_attr_info(sc, tag);
		break;
	case VIO_DRING_REG:
		vdsp_rx_vio_dring_reg(sc, tag);
		break;
	case VIO_RDX:
		vdsp_rx_vio_rdx(sc, tag);
		break;
	default:
		DPRINTF(("CTRL/0x%02x/0x%04x\n", tag->stype, tag->stype_env));
		break;
	}
}

void
vdsp_rx_vio_ver_info(struct vdsp_softc *sc, struct vio_msg_tag *tag)
{
	struct vio_ver_info *vi = (struct vio_ver_info *)tag;

	switch (vi->tag.stype) {
	case VIO_SUBTYPE_INFO:
		DPRINTF(("CTRL/INFO/VER_INFO\n"));

		/* Make sure we're talking to a virtual disk. */
		if (vi->dev_class != VDEV_DISK) {
			/* Huh, we're not talking to a disk device? */
			printf("%s: peer is not a disk device\n",
			    sc->sc_dv.dv_xname);
			vi->tag.stype = VIO_SUBTYPE_NACK;
			vi->major = 0;
			vdsp_sendmsg(sc, vi, sizeof(*vi), 0);
			return;
		}

		if (vi->major != VDSK_MAJOR) {
			vi->tag.stype = VIO_SUBTYPE_NACK;
			vi->major = VDSK_MAJOR;
			vi->minor = VDSK_MINOR;
			vdsp_sendmsg(sc, vi, sizeof(*vi), 0);
			return;
		}

		sc->sc_major = vi->major;
		sc->sc_minor = vi->minor;
		sc->sc_local_sid = vi->tag.sid;

		vi->tag.stype = VIO_SUBTYPE_ACK;
		if (vi->minor > VDSK_MINOR)
			vi->minor = VDSK_MINOR;
		vi->dev_class = VDEV_DISK_SERVER;
		vdsp_sendmsg(sc, vi, sizeof(*vi), 0);
		sc->sc_vio_state |= VIO_RCV_VER_INFO;
		break;

	case VIO_SUBTYPE_ACK:
		DPRINTF(("CTRL/ACK/VER_INFO\n"));
		break;

	default:
		DPRINTF(("CTRL/0x%02x/VER_INFO\n", vi->tag.stype));
		break;
	}
}

void
vdsp_rx_vio_attr_info(struct vdsp_softc *sc, struct vio_msg_tag *tag)
{
	struct vd_attr_info *ai = (struct vd_attr_info *)tag;

	switch (ai->tag.stype) {
	case VIO_SUBTYPE_INFO:
		DPRINTF(("CTRL/INFO/ATTR_INFO\n"));

		if (ai->xfer_mode != VIO_DESC_MODE &&
		    ai->xfer_mode != VIO_DRING_MODE) {
			printf("%s: peer uses unsupported xfer mode 0x%02x\n",
			    sc->sc_dv.dv_xname, ai->xfer_mode);
			ai->tag.stype = VIO_SUBTYPE_NACK;
			vdsp_sendmsg(sc, ai, sizeof(*ai), 0);
			return;
		}
		sc->sc_xfer_mode = ai->xfer_mode;
		sc->sc_vio_state |= VIO_RCV_ATTR_INFO;

		task_add(systq, &sc->sc_open_task);
		break;

	case VIO_SUBTYPE_ACK:
		DPRINTF(("CTRL/ACK/ATTR_INFO\n"));
		break;

	default:
		DPRINTF(("CTRL/0x%02x/ATTR_INFO\n", ai->tag.stype));
		break;
	}
}

void
vdsp_rx_vio_dring_reg(struct vdsp_softc *sc, struct vio_msg_tag *tag)
{
	struct vio_dring_reg *dr = (struct vio_dring_reg *)tag;

	switch (dr->tag.stype) {
	case VIO_SUBTYPE_INFO:
		DPRINTF(("CTRL/INFO/DRING_REG\n"));

		if (dr->num_descriptors > VDSK_MAX_DESCRIPTORS ||
		    dr->descriptor_size > VDSK_MAX_DESCRIPTOR_SIZE ||
		    dr->ncookies > 1) {
			dr->tag.stype = VIO_SUBTYPE_NACK;
			vdsp_sendmsg(sc, dr, sizeof(*dr), 0);
			return;
		}
		sc->sc_num_descriptors = dr->num_descriptors;
		sc->sc_descriptor_size = dr->descriptor_size;
		sc->sc_dring_cookie = dr->cookie[0];
		sc->sc_vio_state |= VIO_RCV_DRING_REG;

		task_add(systq, &sc->sc_alloc_task);
		break;

	case VIO_SUBTYPE_ACK:
		DPRINTF(("CTRL/ACK/DRING_REG\n"));
		break;

	default:
		DPRINTF(("CTRL/0x%02x/DRING_REG\n", dr->tag.stype));
		break;
	}
}

void
vdsp_rx_vio_rdx(struct vdsp_softc *sc, struct vio_msg_tag *tag)
{
	switch(tag->stype) {
	case VIO_SUBTYPE_INFO:
		DPRINTF(("CTRL/INFO/RDX\n"));

		tag->stype = VIO_SUBTYPE_ACK;
		tag->sid = sc->sc_local_sid;
		vdsp_sendmsg(sc, tag, sizeof(*tag), 0);
		sc->sc_vio_state |= VIO_RCV_RDX;
		break;

	case VIO_SUBTYPE_ACK:
		DPRINTF(("CTRL/ACK/RDX\n"));
		break;

	default:
		DPRINTF(("CTRL/0x%02x/RDX (VIO)\n", tag->stype));
		break;
	}
}

void
vdsp_rx_vio_data(struct vdsp_softc *sc, struct vio_msg *vm)
{
	struct vio_msg_tag *tag = (struct vio_msg_tag *)&vm->type;

	if (!ISSET(sc->sc_vio_state, VIO_RCV_RDX)) {
		DPRINTF(("Spurious DATA/0x%02x/0x%04x\n", tag->stype,
		    tag->stype_env));
		return;
	}

	switch(tag->stype_env) {
	case VIO_DESC_DATA:
		vdsp_rx_vio_desc_data(sc, tag);
		break;

	case VIO_DRING_DATA:
		vdsp_rx_vio_dring_data(sc, tag);
		break;

	default:
		DPRINTF(("DATA/0x%02x/0x%04x\n", tag->stype, tag->stype_env));
		break;
	}
}

void
vdsp_rx_vio_dring_data(struct vdsp_softc *sc, struct vio_msg_tag *tag)
{
	struct vio_dring_msg *dm = (struct vio_dring_msg *)tag;
	struct vd_desc *vd;
	vaddr_t va;
	paddr_t pa;
	uint64_t size, off;
	psize_t nbytes;
	int err;

	switch(tag->stype) {
	case VIO_SUBTYPE_INFO:
		DPRINTF(("DATA/INFO/DRING_DATA\n"));

		if (dm->dring_ident != sc->sc_dring_ident ||
		    dm->start_idx >= sc->sc_num_descriptors) {
			dm->tag.stype = VIO_SUBTYPE_NACK;
			vdsp_sendmsg(sc, dm, sizeof(*dm), 0);
			return;
		}

		off = dm->start_idx * sc->sc_descriptor_size;
		vd = (struct vd_desc *)(sc->sc_vd + off);
		va = (vaddr_t)vd;
		size = sc->sc_descriptor_size;
		while (size > 0) {
			pmap_extract(pmap_kernel(), va, &pa);
			nbytes = MIN(size, PAGE_SIZE - (off & PAGE_MASK));
			err = hv_ldc_copy(sc->sc_lc.lc_id, LDC_COPY_IN,
			    sc->sc_dring_cookie.addr + off, pa,
			    nbytes, &nbytes);
			if (err != H_EOK) {
				printf("%s: hv_ldc_copy %d\n", __func__, err);
				return;
			}
			va += nbytes;
			size -= nbytes;
			off += nbytes;
		}

		sc->sc_vd_ring[sc->sc_vd_prod % sc->sc_num_descriptors] = vd;
		membar_producer();
		sc->sc_vd_prod++;
		task_add(systq, &sc->sc_vd_task);

		break;

	case VIO_SUBTYPE_ACK:
		DPRINTF(("DATA/ACK/DRING_DATA\n"));
		break;

	case VIO_SUBTYPE_NACK:
		DPRINTF(("DATA/NACK/DRING_DATA\n"));
		break;

	default:
		DPRINTF(("DATA/0x%02x/DRING_DATA\n", tag->stype));
		break;
	}
}

void
vdsp_vd_task(void *xsc)
{
	struct vdsp_softc *sc = xsc;
	struct vd_desc *vd;

	while (sc->sc_vd_cons != sc->sc_vd_prod) {
		membar_consumer();
		vd = sc->sc_vd_ring[sc->sc_vd_cons++ % sc->sc_num_descriptors];
	
		DPRINTF(("%s: operation %x\n", sc->sc_dv.dv_xname,
		    vd->operation));
		switch (vd->operation) {
		case VD_OP_BREAD:
			vdsp_read_dring(sc, vd);
			break;
		case VD_OP_BWRITE:
			vdsp_write_dring(sc, vd);
			break;
		case VD_OP_FLUSH:
			vdsp_flush_dring(sc, vd);
			break;
		case VD_OP_GET_VTOC:
			vdsp_get_vtoc(sc, vd);
			break;
		case VD_OP_SET_VTOC:
			vdsp_set_vtoc(sc, vd);
			break;
		case VD_OP_GET_DISKGEOM:
			vdsp_get_diskgeom(sc, vd);
			break;
		case VD_OP_GET_WCE:
		case VD_OP_SET_WCE:
		case VD_OP_GET_DEVID:
			/*
			 * Solaris issues VD_OP_GET_DEVID despite the
			 * fact that we don't advertise it.  It seems
			 * to be able to handle failure just fine, so
			 * we silently ignore it.
			 */
			vdsp_unimp(sc, vd);
			break;
		default:
			printf("%s: unsupported operation 0x%02x\n",
			    sc->sc_dv.dv_xname, vd->operation);
			vdsp_unimp(sc, vd);
			break;
		}
	}
}

void
vdsp_rx_vio_desc_data(struct vdsp_softc *sc, struct vio_msg_tag *tag)
{
	struct vdsk_desc_msg *dm = (struct vdsk_desc_msg *)tag;

	switch(tag->stype) {
	case VIO_SUBTYPE_INFO:
		DPRINTF(("DATA/INFO/DESC_DATA\n"));

		switch (dm->operation) {
		case VD_OP_BREAD:
			mtx_enter(&sc->sc_desc_mtx);
			sc->sc_desc_msg[sc->sc_desc_head++] = dm;
			sc->sc_desc_head &= (VDSK_RX_ENTRIES - 1);
			KASSERT(sc->sc_desc_head != sc->sc_desc_tail);
			mtx_leave(&sc->sc_desc_mtx);
			task_add(systq, &sc->sc_read_task);
			break;
		default:
			printf("%s: unsupported operation 0x%02x\n",
			    sc->sc_dv.dv_xname, dm->operation);
			break;
		}
		break;

	case VIO_SUBTYPE_ACK:
		DPRINTF(("DATA/ACK/DESC_DATA\n"));
		break;

	case VIO_SUBTYPE_NACK:
		DPRINTF(("DATA/NACK/DESC_DATA\n"));
		break;

	default:
		DPRINTF(("DATA/0x%02x/DESC_DATA\n", tag->stype));
		break;
	}
}

void
vdsp_ldc_reset(struct ldc_conn *lc)
{
	struct vdsp_softc *sc = lc->lc_sc;

	sc->sc_vio_state = 0;
	task_add(systq, &sc->sc_close_task);
}

void
vdsp_ldc_start(struct ldc_conn *lc)
{
	/* The vDisk client is supposed to initiate the handshake. */
}

void
vdsp_sendmsg(struct vdsp_softc *sc, void *msg, size_t len, int dowait)
{
	struct ldc_conn *lc = &sc->sc_lc;
	int err;

	do {
		err = ldc_send_unreliable(lc, msg, len);
		if (dowait && err == EWOULDBLOCK) {
			/*
			 * Seems like the hypervisor doesn't actually
			 * generate interrupts for transmit queues, so
			 * we specify a timeout such that we don't
			 * block forever.
			 */
			err = tsleep(lc->lc_txq, PWAIT, "vdsp", 1);
		}
	} while (dowait && err == EWOULDBLOCK);
}

void
vdsp_open(void *arg1)
{
	struct vdsp_softc *sc = arg1;
	struct proc *p = curproc;
	struct vd_attr_info ai;

	if (sc->sc_vp == NULL) {
		struct nameidata nd;
		struct vattr va;
		struct partinfo pi;
		const char *name;
		dev_t dev;
		int error;

		name = mdesc_get_prop_str(sc->sc_idx, "vds-block-device");
		if (name == NULL)
			return;

		NDINIT(&nd, LOOKUP, FOLLOW, UIO_SYSSPACE, name, p);
		error = vn_open(&nd, FREAD | FWRITE, 0);
		if (error) {
			printf("VOP_OPEN: %s, %d\n", name, error);
			return;
		}

		if (nd.ni_vp->v_type == VBLK) {
			dev = nd.ni_vp->v_rdev;
			error = (*bdevsw[major(dev)].d_ioctl)(dev,
			    DIOCGPART, (caddr_t)&pi, FREAD, curproc);
			if (error)
				printf("DIOCGPART: %s, %d\n", name, error);
			sc->sc_vdisk_block_size = pi.disklab->d_secsize;
			sc->sc_vdisk_size = DL_GETPSIZE(pi.part);
		} else {
			error = VOP_GETATTR(nd.ni_vp, &va, p->p_ucred, p);
			if (error)
				printf("VOP_GETATTR: %s, %d\n", name, error);
			sc->sc_vdisk_block_size = DEV_BSIZE;
			sc->sc_vdisk_size = va.va_size / DEV_BSIZE;
		}

		VOP_UNLOCK(nd.ni_vp, p);
		sc->sc_vp = nd.ni_vp;

		vdsp_readlabel(sc);
	}

	bzero(&ai, sizeof(ai));
	ai.tag.type = VIO_TYPE_CTRL;
	ai.tag.stype = VIO_SUBTYPE_ACK;
	ai.tag.stype_env = VIO_ATTR_INFO;
	ai.tag.sid = sc->sc_local_sid;
	ai.xfer_mode = sc->sc_xfer_mode;
	ai.vd_type = VD_DISK_TYPE_DISK;
	if (sc->sc_major > 1 || sc->sc_minor >= 1) {
		if (vdsp_is_iso(sc))
			ai.vd_mtype = VD_MEDIA_TYPE_CD;
		else
			ai.vd_mtype = VD_MEDIA_TYPE_FIXED;
	}
	ai.vdisk_block_size = sc->sc_vdisk_block_size;
	ai.operations = VD_OP_MASK;
	ai.vdisk_size = sc->sc_vdisk_size;
	ai.max_xfer_sz = MAXPHYS / sc->sc_vdisk_block_size;
	vdsp_sendmsg(sc, &ai, sizeof(ai), 1);
}

void
vdsp_close(void *arg1)
{
	struct vdsp_softc *sc = arg1;
	struct proc *p = curproc;

	sc->sc_seq_no = 0;

	free(sc->sc_vd, M_DEVBUF, 0);
	sc->sc_vd = NULL;
	free(sc->sc_vd_ring, M_DEVBUF,
	     sc->sc_num_descriptors * sizeof(*sc->sc_vd_ring));
	sc->sc_vd_ring = NULL;
	free(sc->sc_label, M_DEVBUF, 0);
	sc->sc_label = NULL;
	if (sc->sc_vp) {
		vn_close(sc->sc_vp, FREAD | FWRITE, p->p_ucred, p);
		sc->sc_vp = NULL;
	}
}

void
vdsp_readlabel(struct vdsp_softc *sc)
{
	struct proc *p = curproc;
	struct iovec iov;
	struct uio uio;
	int err;

	if (sc->sc_vp == NULL)
		return;

	sc->sc_label = malloc(sizeof(*sc->sc_label), M_DEVBUF, M_WAITOK);

	iov.iov_base = sc->sc_label;
	iov.iov_len = sizeof(*sc->sc_label);
	uio.uio_iov = &iov;
	uio.uio_iovcnt = 1;
	uio.uio_offset = 0;
	uio.uio_resid = sizeof(*sc->sc_label);
	uio.uio_segflg = UIO_SYSSPACE;
	uio.uio_rw = UIO_READ;
	uio.uio_procp = p;

	vn_lock(sc->sc_vp, LK_EXCLUSIVE | LK_RETRY, p);
	err = VOP_READ(sc->sc_vp, &uio, 0, p->p_ucred);
	VOP_UNLOCK(sc->sc_vp, p);
	if (err) {
		free(sc->sc_label, M_DEVBUF, 0);
		sc->sc_label = NULL;
	}
}

int
vdsp_writelabel(struct vdsp_softc *sc)
{
	struct proc *p = curproc;
	struct iovec iov;
	struct uio uio;
	int err;

	if (sc->sc_vp == NULL || sc->sc_label == NULL)
		return (EINVAL);

	iov.iov_base = sc->sc_label;
	iov.iov_len = sizeof(*sc->sc_label);
	uio.uio_iov = &iov;
	uio.uio_iovcnt = 1;
	uio.uio_offset = 0;
	uio.uio_resid = sizeof(*sc->sc_label);
	uio.uio_segflg = UIO_SYSSPACE;
	uio.uio_rw = UIO_WRITE;
	uio.uio_procp = p;

	vn_lock(sc->sc_vp, LK_EXCLUSIVE | LK_RETRY, p);
	err = VOP_WRITE(sc->sc_vp, &uio, 0, p->p_ucred);
	VOP_UNLOCK(sc->sc_vp, p);

	return (err);
}

int
vdsp_is_iso(struct vdsp_softc *sc)
{
	struct proc *p = curproc;
	struct iovec iov;
	struct uio uio;
	struct iso_volume_descriptor *vdp;
	int err;

	if (sc->sc_vp == NULL)
		return (0);

	vdp = malloc(sizeof(*vdp), M_DEVBUF, M_WAITOK);

	iov.iov_base = vdp;
	iov.iov_len = sizeof(*vdp);
	uio.uio_iov = &iov;
	uio.uio_iovcnt = 1;
	uio.uio_offset = 16 * ISO_DEFAULT_BLOCK_SIZE;
	uio.uio_resid = sizeof(*vdp);
	uio.uio_segflg = UIO_SYSSPACE;
	uio.uio_rw = UIO_READ;
	uio.uio_procp = p;

	vn_lock(sc->sc_vp, LK_EXCLUSIVE | LK_RETRY, p);
	err = VOP_READ(sc->sc_vp, &uio, 0, p->p_ucred);
	VOP_UNLOCK(sc->sc_vp, p);

	if (err == 0 && memcmp(vdp->id, ISO_STANDARD_ID, sizeof(vdp->id)))
		err = ENOENT;

	free(vdp, M_DEVBUF, 0);
	return (err == 0);
}

void
vdsp_alloc(void *arg1)
{
	struct vdsp_softc *sc = arg1;
	struct vio_dring_reg dr;

	KASSERT(sc->sc_num_descriptors <= VDSK_MAX_DESCRIPTORS);
	KASSERT(sc->sc_descriptor_size <= VDSK_MAX_DESCRIPTOR_SIZE);
	sc->sc_vd = mallocarray(sc->sc_num_descriptors,
	    sc->sc_descriptor_size, M_DEVBUF, M_WAITOK);
	sc->sc_vd_ring = mallocarray(sc->sc_num_descriptors,
	    sizeof(*sc->sc_vd_ring), M_DEVBUF, M_WAITOK);
	task_set(&sc->sc_vd_task, vdsp_vd_task, sc);

	bzero(&dr, sizeof(dr));
	dr.tag.type = VIO_TYPE_CTRL;
	dr.tag.stype = VIO_SUBTYPE_ACK;
	dr.tag.stype_env = VIO_DRING_REG;
	dr.tag.sid = sc->sc_local_sid;
	dr.dring_ident = ++sc->sc_dring_ident;
	vdsp_sendmsg(sc, &dr, sizeof(dr), 1);
}

void
vdsp_read(void *arg1)
{
	struct vdsp_softc *sc = arg1;

	mtx_enter(&sc->sc_desc_mtx);
	while (sc->sc_desc_tail != sc->sc_desc_head) {
		mtx_leave(&sc->sc_desc_mtx);
		vdsp_read_desc(sc, sc->sc_desc_msg[sc->sc_desc_tail]);
		mtx_enter(&sc->sc_desc_mtx);
		sc->sc_desc_tail++;
		sc->sc_desc_tail &= (VDSK_RX_ENTRIES - 1);
	}
	mtx_leave(&sc->sc_desc_mtx);
}

void
vdsp_read_desc(struct vdsp_softc *sc, struct vdsk_desc_msg *dm)
{
	struct ldc_conn *lc = &sc->sc_lc;
	struct proc *p = curproc;
	struct iovec iov;
	struct uio uio;
	caddr_t buf;
	vaddr_t va;
	paddr_t pa;
	uint64_t size, off;
	psize_t nbytes;
	int err, i;

	if (sc->sc_vp == NULL)
		return;

	buf = malloc(dm->size, M_DEVBUF, M_WAITOK);

	iov.iov_base = buf;
	iov.iov_len = dm->size;
	uio.uio_iov = &iov;
	uio.uio_iovcnt = 1;
	uio.uio_offset = dm->offset * DEV_BSIZE;
	uio.uio_resid = dm->size;
	uio.uio_segflg = UIO_SYSSPACE;
	uio.uio_rw = UIO_READ;
	uio.uio_procp = p;

	vn_lock(sc->sc_vp, LK_EXCLUSIVE | LK_RETRY, p);
	dm->status = VOP_READ(sc->sc_vp, &uio, 0, p->p_ucred);
	VOP_UNLOCK(sc->sc_vp, p);

	KERNEL_UNLOCK();
	if (dm->status == 0) {
		i = 0;
		va = (vaddr_t)buf;
		size = dm->size;
		off = 0;
		while (size > 0 && i < dm->ncookies) {
			pmap_extract(pmap_kernel(), va, &pa);
			nbytes = MIN(size, dm->cookie[i].size - off);
			nbytes = MIN(nbytes, PAGE_SIZE - (off & PAGE_MASK));
			err = hv_ldc_copy(lc->lc_id, LDC_COPY_OUT,
			    dm->cookie[i].addr + off, pa, nbytes, &nbytes);
			if (err != H_EOK) {
				printf("%s: hv_ldc_copy: %d\n", __func__, err);
				dm->status = EIO;
				KERNEL_LOCK();
				goto fail;
			}
			va += nbytes;
			size -= nbytes;
			off += nbytes;
			if (off >= dm->cookie[i].size) {
				off = 0;
				i++;
			}
		}
	}
	KERNEL_LOCK();

fail:
	free(buf, M_DEVBUF, 0);

	/* ACK the descriptor. */
	dm->tag.stype = VIO_SUBTYPE_ACK;
	dm->tag.sid = sc->sc_local_sid;
	vdsp_sendmsg(sc, dm, sizeof(*dm) +
	    (dm->ncookies - 1) * sizeof(struct ldc_cookie), 1);
}

void
vdsp_read_dring(void *arg1, void *arg2)
{
	struct vdsp_softc *sc = arg1;
	struct ldc_conn *lc = &sc->sc_lc;
	struct vd_desc *vd = arg2;
	struct proc *p = curproc;
	struct iovec iov;
	struct uio uio;
	caddr_t buf;
	vaddr_t va;
	paddr_t pa;
	uint64_t size, off;
	psize_t nbytes;
	int err, i;

	if (sc->sc_vp == NULL)
		return;

	buf = malloc(vd->size, M_DEVBUF, M_WAITOK);

	iov.iov_base = buf;
	iov.iov_len = vd->size;
	uio.uio_iov = &iov;
	uio.uio_iovcnt = 1;
	uio.uio_offset = vd->offset * DEV_BSIZE;
	uio.uio_resid = vd->size;
	uio.uio_segflg = UIO_SYSSPACE;
	uio.uio_rw = UIO_READ;
	uio.uio_procp = p;

	vn_lock(sc->sc_vp, LK_EXCLUSIVE | LK_RETRY, p);
	vd->status = VOP_READ(sc->sc_vp, &uio, 0, p->p_ucred);
	VOP_UNLOCK(sc->sc_vp, p);

	KERNEL_UNLOCK();
	if (vd->status == 0) {
		i = 0;
		va = (vaddr_t)buf;
		size = vd->size;
		off = 0;
		while (size > 0 && i < vd->ncookies) {
			pmap_extract(pmap_kernel(), va, &pa);
			nbytes = MIN(size, vd->cookie[i].size - off);
			nbytes = MIN(nbytes, PAGE_SIZE - (off & PAGE_MASK));
			err = hv_ldc_copy(lc->lc_id, LDC_COPY_OUT,
			    vd->cookie[i].addr + off, pa, nbytes, &nbytes);
			if (err != H_EOK) {
				printf("%s: hv_ldc_copy: %d\n", __func__, err);
				vd->status = EIO;
				KERNEL_LOCK();
				goto fail;
			}
			va += nbytes;
			size -= nbytes;
			off += nbytes;
			if (off >= vd->cookie[i].size) {
				off = 0;
				i++;
			}
		}
	}
	KERNEL_LOCK();

fail:
	free(buf, M_DEVBUF, 0);

	/* ACK the descriptor. */
	vd->hdr.dstate = VIO_DESC_DONE;
	vdsp_ack_desc(sc, vd);
}

void
vdsp_write_dring(void *arg1, void *arg2)
{
	struct vdsp_softc *sc = arg1;
	struct ldc_conn *lc = &sc->sc_lc;
	struct vd_desc *vd = arg2;
	struct proc *p = curproc;
	struct iovec iov;
	struct uio uio;
	caddr_t buf;
	vaddr_t va;
	paddr_t pa;
	uint64_t size, off;
	psize_t nbytes;
	int err, i;

	if (sc->sc_vp == NULL)
		return;

	buf = malloc(vd->size, M_DEVBUF, M_WAITOK);

	KERNEL_UNLOCK();
	i = 0;
	va = (vaddr_t)buf;
	size = vd->size;
	off = 0;
	while (size > 0 && i < vd->ncookies) {
		pmap_extract(pmap_kernel(), va, &pa);
		nbytes = MIN(size, vd->cookie[i].size - off);
		nbytes = MIN(nbytes, PAGE_SIZE - (off & PAGE_MASK));
		err = hv_ldc_copy(lc->lc_id, LDC_COPY_IN,
		    vd->cookie[i].addr + off, pa, nbytes, &nbytes);
		if (err != H_EOK) {
			printf("%s: hv_ldc_copy: %d\n", __func__, err);
			vd->status = EIO;
			KERNEL_LOCK();
			goto fail;
		}
		va += nbytes;
		size -= nbytes;
		off += nbytes;
		if (off >= vd->cookie[i].size) {
			off = 0;
			i++;
		}
	}
	KERNEL_LOCK();

	iov.iov_base = buf;
	iov.iov_len = vd->size;
	uio.uio_iov = &iov;
	uio.uio_iovcnt = 1;
	uio.uio_offset = vd->offset * DEV_BSIZE;
	uio.uio_resid = vd->size;
	uio.uio_segflg = UIO_SYSSPACE;
	uio.uio_rw = UIO_WRITE;
	uio.uio_procp = p;

	vn_lock(sc->sc_vp, LK_EXCLUSIVE | LK_RETRY, p);
	vd->status = VOP_WRITE(sc->sc_vp, &uio, 0, p->p_ucred);
	VOP_UNLOCK(sc->sc_vp, p);

fail:
	free(buf, M_DEVBUF, 0);

	/* ACK the descriptor. */
	vd->hdr.dstate = VIO_DESC_DONE;
	vdsp_ack_desc(sc, vd);
}

void
vdsp_flush_dring(void *arg1, void *arg2)
{
	struct vdsp_softc *sc = arg1;
	struct vd_desc *vd = arg2;

	if (sc->sc_vp == NULL)
		return;

	/* ACK the descriptor. */
	vd->status = 0;
	vd->hdr.dstate = VIO_DESC_DONE;
	vdsp_ack_desc(sc, vd);
}

void
vdsp_get_vtoc(void *arg1, void *arg2)
{
	struct vdsp_softc *sc = arg1;
	struct ldc_conn *lc = &sc->sc_lc;
	struct vd_desc *vd = arg2;
	struct sun_vtoc_preamble *sl;
	struct vd_vtoc *vt;
	vaddr_t va;
	paddr_t pa;
	uint64_t size, off;
	psize_t nbytes;
	int err, i;

	vt = malloc(PAGE_SIZE, M_DEVBUF, M_WAITOK | M_ZERO);

	if (sc->sc_label == NULL)
		vdsp_readlabel(sc);

	if (sc->sc_label && sc->sc_label->sl_magic == SUN_DKMAGIC) {
		sl = (struct sun_vtoc_preamble *)sc->sc_label;

		memcpy(vt->ascii_label, sl->sl_text, sizeof(sl->sl_text));
		memcpy(vt->volume_name, sl->sl_volume, sizeof(sl->sl_volume));
		vt->sector_size = DEV_BSIZE;
		vt->num_partitions = sl->sl_nparts;
		for (i = 0; i < vt->num_partitions; i++) {
			vt->partition[i].id_tag = sl->sl_part[i].spi_tag;
			vt->partition[i].perm = sl->sl_part[i].spi_flag;
			vt->partition[i].start =
			    sc->sc_label->sl_part[i].sdkp_cyloffset *
				sc->sc_label->sl_ntracks *
				sc->sc_label->sl_nsectors;
			vt->partition[i].nblocks =
			    sc->sc_label->sl_part[i].sdkp_nsectors;
		}
	} else {
		uint64_t disk_size;
		int unit;

		/* Human-readable disk size. */
		disk_size = sc->sc_vdisk_size * sc->sc_vdisk_block_size;
		disk_size >>= 10;
		unit = 'K';
		if (disk_size > (2 << 10)) {
			disk_size >>= 10;
			unit = 'M';
		}
		if (disk_size > (2 << 10)) {
			disk_size >>= 10;
			unit = 'G';
		}

		snprintf(vt->ascii_label, sizeof(vt->ascii_label),
		    "OpenBSD-DiskImage-%lld%cB cyl %d alt %d hd %d sec %d",
		    disk_size, unit, sc->sc_ncyl, sc->sc_acyl,
		    sc->sc_nhead, sc->sc_nsect);
		vt->sector_size = sc->sc_vdisk_block_size;
		vt->num_partitions = 8;
		vt->partition[2].id_tag = SPTAG_WHOLE_DISK;
		vt->partition[2].nblocks =
		    sc->sc_ncyl * sc->sc_nhead * sc->sc_nsect;
	}

	i = 0;
	va = (vaddr_t)vt;
	size = roundup(sizeof(*vt), 64);
	off = 0;
	while (size > 0 && i < vd->ncookies) {
		pmap_extract(pmap_kernel(), va, &pa);
		nbytes = MIN(size, vd->cookie[i].size - off);
		nbytes = MIN(nbytes, PAGE_SIZE - (off & PAGE_MASK));
		err = hv_ldc_copy(lc->lc_id, LDC_COPY_OUT,
		    vd->cookie[i].addr + off, pa, nbytes, &nbytes);
		if (err != H_EOK) {
			printf("%s: hv_ldc_copy: %d\n", __func__, err);
			vd->status = EIO;
			goto fail;
		}
		va += nbytes;
		size -= nbytes;
		off += nbytes;
		if (off >= vd->cookie[i].size) {
			off = 0;
			i++;
		}
	}

	vd->status = 0;

fail:
	free(vt, M_DEVBUF, 0);

	/* ACK the descriptor. */
	vd->hdr.dstate = VIO_DESC_DONE;
	vdsp_ack_desc(sc, vd);
}

void
vdsp_set_vtoc(void *arg1, void *arg2)
{
	struct vdsp_softc *sc = arg1;
	struct ldc_conn *lc = &sc->sc_lc;
	struct vd_desc *vd = arg2;
	struct sun_vtoc_preamble *sl;
	struct vd_vtoc *vt;
	u_short cksum = 0, *sp1, *sp2;
	vaddr_t va;
	paddr_t pa;
	uint64_t size, off;
	psize_t nbytes;
	int err, i;

	vt = malloc(PAGE_SIZE, M_DEVBUF, M_WAITOK | M_ZERO);

	i = 0;
	va = (vaddr_t)vt;
	size = sizeof(*vt);
	off = 0;
	while (size > 0 && i < vd->ncookies) {
		pmap_extract(pmap_kernel(), va, &pa);
		nbytes = MIN(size, vd->cookie[i].size - off);
		nbytes = MIN(nbytes, PAGE_SIZE - (off & PAGE_MASK));
		err = hv_ldc_copy(lc->lc_id, LDC_COPY_IN,
		    vd->cookie[i].addr + off, pa, nbytes, &nbytes);
		if (err != H_EOK) {
			printf("%s: hv_ldc_copy: %d\n", __func__, err);
			vd->status = EIO;
			goto fail;
		}
		va += nbytes;
		size -= nbytes;
		off += nbytes;
		if (off >= vd->cookie[i].size) {
			off = 0;
			i++;
		}
	}

	if (vt->num_partitions > nitems(sc->sc_label->sl_part)) {
		vd->status = EINVAL;
		goto fail;
	}

	if (sc->sc_label == NULL || sc->sc_label->sl_magic != SUN_DKMAGIC) {
		sc->sc_label = malloc(sizeof(*sc->sc_label),
		    M_DEVBUF, M_WAITOK | M_ZERO);

		sc->sc_label->sl_ntracks = sc->sc_nhead;
		sc->sc_label->sl_nsectors = sc->sc_nsect;
		sc->sc_label->sl_ncylinders = sc->sc_ncyl;
		sc->sc_label->sl_acylinders = sc->sc_acyl;
		sc->sc_label->sl_pcylinders = sc->sc_ncyl + sc->sc_acyl;
		sc->sc_label->sl_rpm = 3600;

		sc->sc_label->sl_magic = SUN_DKMAGIC;
	}

	sl = (struct sun_vtoc_preamble *)sc->sc_label;
	memcpy(sl->sl_text, vt->ascii_label, sizeof(sl->sl_text));
	sl->sl_version = 0x01;
	memcpy(sl->sl_volume, vt->volume_name, sizeof(sl->sl_volume));
	sl->sl_nparts = vt->num_partitions;
	for (i = 0; i < vt->num_partitions; i++) {
		sl->sl_part[i].spi_tag = vt->partition[i].id_tag;
		sl->sl_part[i].spi_flag = vt->partition[i].perm;
		sc->sc_label->sl_part[i].sdkp_cyloffset =
		    vt->partition[i].start / (sc->sc_nhead * sc->sc_nsect);
		sc->sc_label->sl_part[i].sdkp_nsectors =
		    vt->partition[i].nblocks;
	}
	sl->sl_sanity = 0x600ddeee;

	/* Compute the checksum. */
	sp1 = (u_short *)sc->sc_label;
	sp2 = (u_short *)(sc->sc_label + 1);
	while (sp1 < sp2)
		cksum ^= *sp1++;
	sc->sc_label->sl_cksum = cksum;

	vd->status = vdsp_writelabel(sc);

fail:
	free(vt, M_DEVBUF, 0);

	/* ACK the descriptor. */
	vd->hdr.dstate = VIO_DESC_DONE;
	vdsp_ack_desc(sc, vd);
}

void
vdsp_get_diskgeom(void *arg1, void *arg2)
{
	struct vdsp_softc *sc = arg1;
	struct ldc_conn *lc = &sc->sc_lc;
	struct vd_desc *vd = arg2;
	struct vd_diskgeom *vg;
	vaddr_t va;
	paddr_t pa;
	uint64_t size, off;
	psize_t nbytes;
	int err, i;

	vg = malloc(PAGE_SIZE, M_DEVBUF, M_WAITOK | M_ZERO);

	if (sc->sc_label == NULL)
		vdsp_readlabel(sc);

	if (sc->sc_label && sc->sc_label->sl_magic == SUN_DKMAGIC) {
		vg->ncyl = sc->sc_label->sl_ncylinders;
		vg->acyl = sc->sc_label->sl_acylinders;
		vg->nhead = sc->sc_label->sl_ntracks;
		vg->nsect = sc->sc_label->sl_nsectors;
		vg->intrlv = sc->sc_label->sl_interleave;
		vg->apc = sc->sc_label->sl_sparespercyl;
		vg->rpm = sc->sc_label->sl_rpm;
		vg->pcyl = sc->sc_label->sl_pcylinders;
	} else {
		uint64_t disk_size, block_size;

		disk_size = sc->sc_vdisk_size * sc->sc_vdisk_block_size;
		block_size = sc->sc_vdisk_block_size;

		if (disk_size >= 8L * 1024 * 1024 * 1024) {
			vg->nhead = 96;
			vg->nsect = 768;
		} else if (disk_size >= 2 *1024 * 1024) {
			vg->nhead = 1;
			vg->nsect = 600;
		} else {
			vg->nhead = 1;
			vg->nsect = 200;
		}

		vg->pcyl = disk_size / (block_size * vg->nhead * vg->nsect);
		if (vg->pcyl == 0)
			vg->pcyl = 1;
		if (vg->pcyl > 2)
			vg->acyl = 2;
		vg->ncyl = vg->pcyl - vg->acyl;

		vg->rpm = 3600;
	}

	sc->sc_ncyl = vg->ncyl;
	sc->sc_acyl = vg->acyl;
	sc->sc_nhead = vg->nhead;
	sc->sc_nsect = vg->nsect;

	i = 0;
	va = (vaddr_t)vg;
	size = roundup(sizeof(*vg), 64);
	off = 0;
	while (size > 0 && i < vd->ncookies) {
		pmap_extract(pmap_kernel(), va, &pa);
		nbytes = MIN(size, vd->cookie[i].size - off);
		nbytes = MIN(nbytes, PAGE_SIZE - (off & PAGE_MASK));
		err = hv_ldc_copy(lc->lc_id, LDC_COPY_OUT,
		    vd->cookie[i].addr + off, pa, nbytes, &nbytes);
		if (err != H_EOK) {
			printf("%s: hv_ldc_copy: %d\n", __func__, err);
			vd->status = EIO;
			goto fail;
		}
		va += nbytes;
		size -= nbytes;
		off += nbytes;
		if (off >= vd->cookie[i].size) {
			off = 0;
			i++;
		}
	}

	vd->status = 0;

fail:
	free(vg, M_DEVBUF, 0);

	/* ACK the descriptor. */
	vd->hdr.dstate = VIO_DESC_DONE;
	vdsp_ack_desc(sc, vd);
}

void
vdsp_unimp(void *arg1, void *arg2)
{
	struct vdsp_softc *sc = arg1;
	struct vd_desc *vd = arg2;

	/* ACK the descriptor. */
	vd->status = ENOTSUP;
	vd->hdr.dstate = VIO_DESC_DONE;
	vdsp_ack_desc(sc, vd);
}

void
vdsp_ack_desc(struct vdsp_softc *sc, struct vd_desc *vd)
{
	struct vio_dring_msg dm;
	vaddr_t va;
	paddr_t pa;
	uint64_t size, off;
	psize_t nbytes;
	int err;

	va = (vaddr_t)vd;
	off = (caddr_t)vd - sc->sc_vd;
	size = sc->sc_descriptor_size;
	while (size > 0) {
		pmap_extract(pmap_kernel(), va, &pa);
		nbytes = MIN(size, PAGE_SIZE - (off & PAGE_MASK));
		err = hv_ldc_copy(sc->sc_lc.lc_id, LDC_COPY_OUT,
		    sc->sc_dring_cookie.addr + off, pa, nbytes, &nbytes);
		if (err != H_EOK) {
			printf("%s: hv_ldc_copy %d\n", __func__, err);
			return;
		}
		va += nbytes;
		size -= nbytes;
		off += nbytes;
	}

	/* ACK the descriptor. */
	bzero(&dm, sizeof(dm));
	dm.tag.type = VIO_TYPE_DATA;
	dm.tag.stype = VIO_SUBTYPE_ACK;
	dm.tag.stype_env = VIO_DRING_DATA;
	dm.tag.sid = sc->sc_local_sid;
	dm.seq_no = ++sc->sc_seq_no;
	dm.dring_ident = sc->sc_dring_ident;
	off = (caddr_t)vd - sc->sc_vd;
	dm.start_idx = off / sc->sc_descriptor_size;
	dm.end_idx = off / sc->sc_descriptor_size;
	vdsp_sendmsg(sc, &dm, sizeof(dm), 1);
}

int
vdspopen(dev_t dev, int flag, int mode, struct proc *p)
{
	struct vdsp_softc *sc;
	struct ldc_conn *lc;
	int unit = minor(dev);
	int err;

	if (unit >= vdsp_cd.cd_ndevs)
		return (ENXIO);
	sc = vdsp_cd.cd_devs[unit];
	if (sc == NULL)
		return (ENXIO);

	lc = &sc->sc_lc;

	err = hv_ldc_tx_qconf(lc->lc_id,
	    lc->lc_txq->lq_map->dm_segs[0].ds_addr, lc->lc_txq->lq_nentries);
	if (err != H_EOK)
		printf("%s: hv_ldc_tx_qconf %d\n", __func__, err);

	err = hv_ldc_rx_qconf(lc->lc_id,
	    lc->lc_rxq->lq_map->dm_segs[0].ds_addr, lc->lc_rxq->lq_nentries);
	if (err != H_EOK)
		printf("%s: hv_ldc_rx_qconf %d\n", __func__, err);

	cbus_intr_setenabled(sc->sc_bustag, sc->sc_tx_ino, INTR_ENABLED);
	cbus_intr_setenabled(sc->sc_bustag, sc->sc_rx_ino, INTR_ENABLED);

	return (0);
}

int
vdspclose(dev_t dev, int flag, int mode, struct proc *p)
{
	struct vdsp_softc *sc;
	int unit = minor(dev);

	if (unit >= vdsp_cd.cd_ndevs)
		return (ENXIO);
	sc = vdsp_cd.cd_devs[unit];
	if (sc == NULL)
		return (ENXIO);

	cbus_intr_setenabled(sc->sc_bustag, sc->sc_tx_ino, INTR_DISABLED);
	cbus_intr_setenabled(sc->sc_bustag, sc->sc_rx_ino, INTR_DISABLED);

	hv_ldc_tx_qconf(sc->sc_lc.lc_id, 0, 0);
	hv_ldc_rx_qconf(sc->sc_lc.lc_id, 0, 0);

	task_add(systq, &sc->sc_close_task);
	return (0);
}

int
vdspioctl(dev_t dev, u_long cmd, caddr_t data, int flag, struct proc *p)
{
	struct vdsp_softc *sc;
	int unit = minor(dev);

	if (unit >= vdsp_cd.cd_ndevs)
		return (ENXIO);
	sc = vdsp_cd.cd_devs[unit];
	if (sc == NULL)
		return (ENXIO);

	return (ENOTTY);
}
@


1.41
log
@Remove NULL-checks before free().

ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vdsp.c,v 1.40 2015/09/15 21:04:10 kettenis Exp $	*/
d944 1
a944 1
		VOP_UNLOCK(nd.ni_vp, 0, p);
d1016 1
a1016 1
	VOP_UNLOCK(sc->sc_vp, 0, p);
d1046 1
a1046 1
	VOP_UNLOCK(sc->sc_vp, 0, p);
d1077 1
a1077 1
	VOP_UNLOCK(sc->sc_vp, 0, p);
d1156 1
a1156 1
	VOP_UNLOCK(sc->sc_vp, 0, p);
d1230 1
a1230 1
	VOP_UNLOCK(sc->sc_vp, 0, p);
d1329 1
a1329 1
	VOP_UNLOCK(sc->sc_vp, 0, p);
@


1.40
log
@Fix overlapping memcpy found by Maxime Villard's Brainy Code Scanner.
@
text
@d1 1
a1 1
/*	$OpenBSD: vdsp.c,v 1.39 2015/02/11 12:09:18 miod Exp $	*/
d978 7
a984 13
	if (sc->sc_vd) {
		free(sc->sc_vd, M_DEVBUF, 0);
		sc->sc_vd = NULL;
	}
	if (sc->sc_vd_ring != NULL) {
		free(sc->sc_vd_ring, M_DEVBUF,
		    sc->sc_num_descriptors * sizeof(*sc->sc_vd_ring));
		sc->sc_vd_ring = NULL;
	}
	if (sc->sc_label) {
		free(sc->sc_label, M_DEVBUF, 0);
		sc->sc_label = NULL;
	}
@


1.39
log
@dlg@@ said he had fixed sparc64, but I'm afraid this requires <sys/lock.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: vdsp.c,v 1.38 2015/02/11 01:40:42 dlg Exp $	*/
d1521 1
a1521 1
	memcpy(sl->sl_volume, sl->sl_volume, sizeof(sl->sl_volume));
@


1.38
log
@this doesnt need anything sys/lock.h provides
@
text
@d1 1
a1 1
/*	$OpenBSD: vdsp.c,v 1.37 2015/01/27 03:17:35 dlg Exp $	*/
d25 1
@


1.37
log
@remove the second void * argument on tasks.

when workqs were introduced, we provided a second argument so you
could pass a thing and some context to work on it in. there were
very few things that took advantage of the second argument, so when
i introduced pools i suggested removing it. since tasks were meant
to replace workqs, it was requested that we keep the second argument
to make porting from workqs to tasks easier.

now that workqs are gone, i had a look at the use of the second
argument again and found only one good use of it (vdsp(4) on sparc64
if you're interested) and a tiny handful of questionable uses. the
vast majority of tasks only used a single argument. i have since
modified all tasks that used two args to only use one, so now we
can remove the second argument.

so this is a mechanical change. all tasks only passed NULL as their
second argument, so we can just remove it.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vdsp.c,v 1.36 2015/01/25 21:42:13 kettenis Exp $	*/
a26 1
#include <sys/lock.h>
@


1.36
log
@Rework cbus(4) interrupt support a bit.  Instead of merging devhandle and
devino into a pseudo-sysino, directly use the devino as the ihandle.  The
devhandle is stored in the cbus softc, and accessed through the bus space
tag.  This allows us to have more than 256 interrupts on a single cbus, and
avoids relying on the lower bits of the devhandle being zero.
@
text
@d1 1
a1 1
/*	$OpenBSD: vdsp.c,v 1.35 2015/01/23 12:41:23 dlg Exp $	*/
d297 3
a299 3
void	vdsp_open(void *, void *);
void	vdsp_close(void *, void *);
void	vdsp_alloc(void *, void *);
d303 1
a303 1
void	vdsp_read(void *, void *);
d305 1
a305 1
void	vdsp_vd_task(void *, void *);
d381 4
a384 4
	task_set(&sc->sc_open_task, vdsp_open, sc, NULL);
	task_set(&sc->sc_alloc_task, vdsp_alloc, sc, NULL);
	task_set(&sc->sc_close_task, vdsp_close, sc, NULL);
	task_set(&sc->sc_read_task, vdsp_read, sc, NULL);
d778 1
a778 1
vdsp_vd_task(void *xsc, void *null)
d903 1
a903 1
vdsp_open(void *arg1, void *null)
d971 1
a971 1
vdsp_close(void *arg1, void *null)
d1093 1
a1093 1
vdsp_alloc(void *arg1, void *null)
d1104 1
a1104 1
	task_set(&sc->sc_vd_task, vdsp_vd_task, sc, NULL);
d1116 1
a1116 1
vdsp_read(void *arg1, void *null)
@


1.35
log
@move from deferring vd requests with a task per message to a ring
of pointers to vd requests, and a single task to notify the taskq
that there's work on the ring.

the ring is modelled on what you usually get with network cards,
which is an array with a producer and consumer index. the interrupt
handler fills an entry in the ring at the producers index and
increments it. the task reads entries at the consumer index and
increments it until it reaches the same value as the producer.

tested and slightly tweaked by kettenis@@
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vdsp.c,v 1.34 2014/12/17 19:39:01 tedu Exp $	*/
d204 2
a205 2
	uint64_t	sc_tx_sysino;
	uint64_t	sc_rx_sysino;
d337 2
d340 1
a340 6
	if (cbus_intr_map(ca->ca_node, ca->ca_tx_ino, &sc->sc_tx_sysino) ||
	    cbus_intr_map(ca->ca_node, ca->ca_rx_ino, &sc->sc_rx_sysino)) {
		printf(": can't map interrupt\n");
		return;
	}
	printf(": ivec 0x%llx, 0x%llx", sc->sc_tx_sysino, sc->sc_rx_sysino);
d351 1
a351 1
	sc->sc_tx_ih = bus_intr_establish(ca->ca_bustag, sc->sc_tx_sysino,
d354 1
a354 1
	sc->sc_rx_ih = bus_intr_establish(ca->ca_bustag, sc->sc_rx_sysino,
d1722 2
a1723 2
	cbus_intr_setenabled(sc->sc_tx_sysino, INTR_ENABLED);
	cbus_intr_setenabled(sc->sc_rx_sysino, INTR_ENABLED);
d1740 2
a1741 2
	cbus_intr_setenabled(sc->sc_tx_sysino, INTR_DISABLED);
	cbus_intr_setenabled(sc->sc_rx_sysino, INTR_DISABLED);
@


1.34
log
@fix/reduce header dependencies. clock.c doesn't need any of this uvm.
ok deraadt kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: vdsp.c,v 1.33 2014/12/09 06:58:29 doug Exp $	*/
d250 4
a253 1
	struct task	*sc_vd_task;
d305 1
a722 1
	struct task *task;
a757 1
		task = &sc->sc_vd_task[dm->start_idx];
d759 32
a790 2
		DPRINTF(("%s: start_idx %d, end_idx %d, operation %x\n",
		    sc->sc_dv.dv_xname, dm->start_idx, dm->end_idx,
d794 1
a794 1
			task_set(task, vdsp_read_dring, sc, vd);
d797 1
a797 1
			task_set(task, vdsp_write_dring, sc, vd);
d800 1
a800 1
			task_set(task, vdsp_flush_dring, sc, vd);
d803 1
a803 1
			task_set(task, vdsp_get_vtoc, sc, vd);
d806 1
a806 1
			task_set(task, vdsp_set_vtoc, sc, vd);
d809 1
a809 1
			task_set(task, vdsp_get_diskgeom, sc, vd);
d820 1
a820 1
			task_set(task, vdsp_unimp, sc, vd);
d825 1
a825 1
			task_set(task, vdsp_unimp, sc, vd);
a827 14
		task_add(systq, task);
		break;

	case VIO_SUBTYPE_ACK:
		DPRINTF(("DATA/ACK/DRING_DATA\n"));
		break;

	case VIO_SUBTYPE_NACK:
		DPRINTF(("DATA/NACK/DRING_DATA\n"));
		break;

	default:
		DPRINTF(("DATA/0x%02x/DRING_DATA\n", tag->stype));
		break;
d906 1
a906 1
vdsp_open(void *arg1, void *arg2)
d974 1
a974 1
vdsp_close(void *arg1, void *arg2)
d985 4
a988 3
	if (sc->sc_vd_task) {
		free(sc->sc_vd_task, M_DEVBUF, 0);
		sc->sc_vd_task = NULL;
d1096 1
a1096 1
vdsp_alloc(void *arg1, void *arg2)
d1103 5
a1107 4
	sc->sc_vd = mallocarray(sc->sc_num_descriptors, sc->sc_descriptor_size,
	    M_DEVBUF, M_WAITOK);
	sc->sc_vd_task = mallocarray(sc->sc_num_descriptors,
	    sizeof(struct task), M_DEVBUF, M_WAITOK);
d1119 1
a1119 1
vdsp_read(void *arg1, void *arg2)
@


1.33
log
@Replace some malloc(n*size,...) calls with mallocarray().

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vdsp.c,v 1.32 2014/09/29 19:34:23 kettenis Exp $	*/
d27 1
@


1.32
log
@The interrupt handler should now be mpsafe.
@
text
@d1 1
a1 1
/*	$OpenBSD: vdsp.c,v 1.31 2014/09/29 17:48:51 kettenis Exp $	*/
d1083 1
a1083 3
	sc->sc_vd = malloc(sc->sc_num_descriptors * sc->sc_descriptor_size,
	    M_DEVBUF, M_WAITOK);
	sc->sc_vd_task = malloc(sc->sc_num_descriptors * sizeof(struct task),
d1085 2
@


1.31
log
@Add locking for our private descriptor message queue.
@
text
@d1 1
a1 1
/*	$OpenBSD: vdsp.c,v 1.30 2014/09/29 10:27:43 kettenis Exp $	*/
d350 2
a351 1
	    IPL_BIO, 0, vdsp_tx_intr, sc, sc->sc_dv.dv_xname);
d353 2
a354 1
	    IPL_BIO, 0, vdsp_rx_intr, sc, sc->sc_dv.dv_xname);
@


1.30
log
@Add support for using block devices in addition to files.

Tested by jasper@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: vdsp.c,v 1.29 2014/09/28 19:14:36 kettenis Exp $	*/
d26 1
d241 1
d340 2
d821 1
d825 1
a853 2
	sc->sc_desc_head = sc->sc_desc_tail = 0;

a854 1

d1100 1
d1102 4
a1105 1
		vdsp_read_desc(sc, sc->sc_desc_msg[sc->sc_desc_tail++]);
d1108 1
@


1.29
log
@Properly serialize closing our vnode.  Fixes the occasional panic during
reboot or when restaring ldomd(8).
@
text
@d1 1
a1 1
/*	$OpenBSD: vdsp.c,v 1.28 2014/09/22 08:26:16 kettenis Exp $	*/
d30 2
d891 1
d893 1
d907 15
a921 5
		error = VOP_GETATTR(nd.ni_vp, &va, p->p_ucred, p);
		if (error)
			printf("VOP_GETATTR: %s, %d\n", name, error);
		sc->sc_vdisk_block_size = DEV_BSIZE;
		sc->sc_vdisk_size = va.va_size / DEV_BSIZE;
@


1.28
log
@Drop the kernel lock when copying data to/from the other domain during
read/write operations.
@
text
@d1 1
a1 1
/*	$OpenBSD: vdsp.c,v 1.27 2014/07/12 18:44:43 tedu Exp $	*/
a848 13
	sc->sc_seq_no = 0;
	if (sc->sc_vd) {
		free(sc->sc_vd, M_DEVBUF, 0);
		sc->sc_vd = NULL;
	}
	if (sc->sc_vd_task) {
		free(sc->sc_vd_task, M_DEVBUF, 0);
		sc->sc_vd_task = NULL;
	}
	if (sc->sc_label) {
		free(sc->sc_label, M_DEVBUF, 0);
		sc->sc_label = NULL;
	}
d941 14
d1704 1
a1704 5
	if (sc->sc_vp) {
		vn_close(sc->sc_vp, FREAD | FWRITE, p->p_ucred, p);
		sc->sc_vp = NULL;
	}

@


1.27
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: vdsp.c,v 1.26 2014/05/10 11:49:31 kettenis Exp $	*/
d1121 1
d1136 1
d1148 1
d1195 1
d1210 1
d1222 1
d1253 1
d1267 1
d1278 1
@


1.26
log
@Some straightforward format string fixes.  Also, print both the tx and rx
interrupt vector numbers instead of printing rx; pointed out by florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vdsp.c,v 1.25 2014/04/03 09:15:06 mpi Exp $	*/
d851 1
a851 1
		free(sc->sc_vd, M_DEVBUF);
d855 1
a855 1
		free(sc->sc_vd_task, M_DEVBUF);
d859 1
a859 1
		free(sc->sc_label, M_DEVBUF);
d987 1
a987 1
		free(sc->sc_label, M_DEVBUF);
d1051 1
a1051 1
	free(vdp, M_DEVBUF);
d1148 1
a1148 1
	free(buf, M_DEVBUF);
d1219 1
a1219 1
	free(buf, M_DEVBUF);
d1286 1
a1286 1
	free(buf, M_DEVBUF);
d1399 1
a1399 1
	free(vt, M_DEVBUF);
d1491 1
a1491 1
	free(vt, M_DEVBUF);
d1584 1
a1584 1
	free(vg, M_DEVBUF);
@


1.25
log
@Use <uvm/uvm_extern.h> if it's enough.
@
text
@d1 1
a1 1
/*	$OpenBSD: vdsp.c,v 1.24 2014/01/24 09:58:03 kettenis Exp $	*/
d334 1
a334 1
	printf(": ivec 0x%lx, 0x%lx", sc->sc_tx_sysino, sc->sc_tx_sysino);
d1668 1
a1668 1
		printf("%s: hv_ldc_rx_qconf %d\n", err, __func__);
@


1.24
log
@If hv_ldc_copy() fails copying data set report status as EIO and acknowledge
the descriptor.  This seems to be what Solaris does in such a case.
@
text
@d1 1
a1 1
/*	$OpenBSD: vdsp.c,v 1.23 2014/01/23 23:53:33 kettenis Exp $	*/
d36 1
a36 1
#include <uvm/uvm.h>
@


1.23
log
@Eleminate the last workq usage here.
@
text
@d1 1
a1 1
/*	$OpenBSD: vdsp.c,v 1.22 2014/01/23 04:09:44 kettenis Exp $	*/
d1134 2
a1135 2
				free(buf, M_DEVBUF);
				return;
d1147 1
d1205 2
a1206 2
				free(buf, M_DEVBUF);
				return;
d1218 1
d1259 2
a1260 2
			free(buf, M_DEVBUF);
			return;
d1285 1
d1384 2
a1385 2
			free(vt, M_DEVBUF);
			return;
d1396 3
a1401 1
	vd->status = 0;
d1435 2
a1436 2
			free(vt, M_DEVBUF);
			return;
d1569 2
a1570 2
			free(vg, M_DEVBUF);
			return;
d1581 3
a1586 1
	vd->status = 0;
@


1.22
log
@Switch to task queues, except for one little corner case that I need to think
a bit further about.
@
text
@d1 1
a1 1
/*	$OpenBSD: vdsp.c,v 1.21 2014/01/23 01:37:18 kettenis Exp $	*/
d3 1
a3 1
 * Copyright (c) 2009, 2011 Mark Kettenis
a29 1
#include <sys/workq.h>
d238 6
a246 4
	int		sc_tx_cnt;
	int		sc_tx_prod;
	int		sc_tx_cons;

d296 1
d374 1
d815 4
a818 1
			workq_add_task(NULL, 0, vdsp_read, sc, dm);
d846 2
d1081 10
a1091 1
	struct vdsk_desc_msg *dm = arg2;
@


1.21
log
@Don't blindly continue if and hv_ldc_copy() call fails.  For now, simply
clean up and return without ACKing any descriptors.  That means the client
probably hangs.  Some thought is needed on what the correct way to handle
these conditions is.  Made me spot a small memory leak, which is fixed asi
a bonus.
@
text
@d1 1
a1 1
/*	$OpenBSD: vdsp.c,v 1.20 2014/01/23 00:19:09 kettenis Exp $	*/
d28 1
d235 4
d240 1
d369 4
d606 1
a606 1
		workq_add_task(NULL, 0, vdsp_open, sc, NULL);
d640 1
a640 1
		workq_add_task(NULL, 0, vdsp_alloc, sc, NULL);
d707 1
d743 1
d750 1
a750 1
			workq_add_task(NULL, 0, vdsp_read_dring, sc, vd);
d753 1
a753 1
			workq_add_task(NULL, 0, vdsp_write_dring, sc, vd);
d756 1
a756 1
			workq_add_task(NULL, 0, vdsp_flush_dring, sc, vd);
d759 1
a759 1
			workq_add_task(NULL, 0, vdsp_get_vtoc, sc, vd);
d762 1
a762 1
			workq_add_task(NULL, 0, vdsp_set_vtoc, sc, vd);
d765 1
a765 1
			workq_add_task(NULL, 0, vdsp_get_diskgeom, sc, vd);
d776 1
a776 1
			workq_add_task(NULL, 0, vdsp_unimp, sc, vd);
d781 1
a781 1
			workq_add_task(NULL, 0, vdsp_unimp, sc, vd);
d784 1
d846 4
d855 1
a855 1
	workq_add_task(NULL, 0, vdsp_close, sc, NULL);
d1056 2
@


1.20
log
@Use MIN() instead of min() as we're dealing with 64-bit types.
@
text
@d1 1
a1 1
/*	$OpenBSD: vdsp.c,v 1.19 2013/07/12 18:51:03 kettenis Exp $	*/
d1096 1
a1096 1
			if (err != H_EOK)
d1098 3
d1166 1
a1166 1
			if (err != H_EOK)
d1168 3
d1219 1
a1219 1
		if (err != H_EOK)
d1221 3
d1343 1
a1343 1
		if (err != H_EOK)
d1345 3
d1392 1
a1392 1
		if (err != H_EOK)
d1394 3
d1526 1
a1526 1
		if (err != H_EOK)
d1528 3
d1539 2
@


1.19
log
@Actually assign return value to the variable that's used to check it.

Pointed out by Maxime Villard.
@
text
@d1 1
a1 1
/*	$OpenBSD: vdsp.c,v 1.18 2012/12/08 20:38:10 kettenis Exp $	*/
d720 1
a720 1
			nbytes = min(size, PAGE_SIZE - (off & PAGE_MASK));
d1092 2
a1093 2
			nbytes = min(size, dm->cookie[i].size - off);
			nbytes = min(nbytes, PAGE_SIZE - (off & PAGE_MASK));
d1159 2
a1160 2
			nbytes = min(size, vd->cookie[i].size - off);
			nbytes = min(nbytes, PAGE_SIZE - (off & PAGE_MASK));
d1209 2
a1210 2
		nbytes = min(size, vd->cookie[i].size - off);
		nbytes = min(nbytes, PAGE_SIZE - (off & PAGE_MASK));
d1330 2
a1331 2
		nbytes = min(size, vd->cookie[i].size - off);
		nbytes = min(nbytes, PAGE_SIZE - (off & PAGE_MASK));
d1376 2
a1377 2
		nbytes = min(size, vd->cookie[i].size - off);
		nbytes = min(nbytes, PAGE_SIZE - (off & PAGE_MASK));
d1507 2
a1508 2
		nbytes = min(size, vd->cookie[i].size - off);
		nbytes = min(nbytes, PAGE_SIZE - (off & PAGE_MASK));
d1555 1
a1555 1
		nbytes = min(size, PAGE_SIZE - (off & PAGE_MASK));
@


1.18
log
@Make ldomd(8) to control the availability of virtual disks to guest domains.
This is done by opening the corresponding /dev/vdspN device file.  The virtual
disk will remain available until that device is closed, which happens
automatically when ldomd(8) exits.
@
text
@d1 1
a1 1
/*	$OpenBSD: vdsp.c,v 1.17 2012/12/08 12:35:04 kettenis Exp $	*/
d383 1
a383 1
	hv_ldc_tx_get_state(lc->lc_id, &tx_head, &tx_tail, &tx_state);
@


1.17
log
@Descriptor rings can be larger than a single page, so add the offset instead
of or-ing it in.
@
text
@d1 1
a1 1
/*	$OpenBSD: vdsp.c,v 1.16 2012/12/03 19:57:04 kettenis Exp $	*/
d19 1
d32 1
a281 1
void	vdsp_mountroot(void *);
a364 1
	mountroothook_establish(vdsp_mountroot, sc);
a867 21
vdsp_mountroot(void *arg)
{
	struct vdsp_softc *sc = arg;
	struct ldc_conn *lc = &sc->sc_lc;
	int err;

	err = hv_ldc_tx_qconf(lc->lc_id,
	    lc->lc_txq->lq_map->dm_segs[0].ds_addr, lc->lc_txq->lq_nentries);
	if (err != H_EOK)
		printf("%s: hv_ldc_tx_qconf %d\n", __func__, err);

	err = hv_ldc_rx_qconf(lc->lc_id,
	    lc->lc_rxq->lq_map->dm_segs[0].ds_addr, lc->lc_rxq->lq_nentries);
	if (err != H_EOK)
		printf("%s: hv_ldc_rx_qconf %d\n", err, __func__);

	cbus_intr_setenabled(sc->sc_tx_sysino, INTR_ENABLED);
	cbus_intr_setenabled(sc->sc_rx_sysino, INTR_ENABLED);
}

void
d1579 73
@


1.16
log
@Close disk images if the client disconnects.  This makes it possible to
replace a disk image and have it visible to the guest when it reboots
instead of having to reboot the primary domain.
@
text
@d1 1
a1 1
/*	$OpenBSD: vdsp.c,v 1.15 2012/12/02 19:34:35 kettenis Exp $	*/
d722 1
a722 1
			    sc->sc_dring_cookie.addr | off, pa,
d724 4
a731 4
		if (err != H_EOK) {
			printf("%s: hv_ldc_copy %d\n", __func__, err);
			return;
		}
d1578 5
a1582 1
		    sc->sc_dring_cookie.addr | off, pa, nbytes, &nbytes);
a1585 4
	}
	if (err != H_EOK) {
		printf("%s: hv_ldc_copy %d\n", __func__, err);
		return;
@


1.15
log
@Add "support" for VD_OP_GET_WCE and VD_OP_SET_WCE.  These operations don't
really make sense for virtual disks backed by disk images, so we return
ENOTSUP just like Solaris does.  But advertising support for these operations
works around a bug in the Linux kernel.
@
text
@d1 1
a1 1
/*	$OpenBSD: vdsp.c,v 1.14 2012/12/01 11:59:05 kettenis Exp $	*/
d282 1
d837 2
d906 1
a906 1
		error = vn_open(&nd, FREAD, 0);
d942 12
@


1.14
log
@Silently ignore VD_OP_GET_DEVID as Solaris uses it even though we don't
advertise it.
@
text
@d1 1
a1 1
/*	$OpenBSD: vdsp.c,v 1.13 2012/10/26 20:57:08 kettenis Exp $	*/
d188 1
d754 2
@


1.13
log
@Turns out that for devices that attach to cbus(4), it is better to disable
interrupts up-front and explicitly enabling them later than the other way
around.
@
text
@d1 1
a1 1
/*	$OpenBSD: vdsp.c,v 1.12 2012/10/21 19:30:56 kettenis Exp $	*/
d752 9
@


1.12
log
@Fix thinko in previous.
@
text
@d1 1
a1 1
/*	$OpenBSD: vdsp.c,v 1.11 2012/10/21 18:56:00 kettenis Exp $	*/
a339 8

	/*
	 * Disable interrupts while we have no queues allocated.
	 * Otherwise we may end up with an interrupt storm as soon as
	 * our peer places a packet in their transmit queue.
	 */
	cbus_intr_setenabled(sc->sc_tx_sysino, INTR_DISABLED);
	cbus_intr_setenabled(sc->sc_rx_sysino, INTR_DISABLED);
@


1.11
log
@Make sure that there is enough room in the transmit queue to send a VIO
message.  Sleep if necessary.
@
text
@d1 1
a1 1
/*	$OpenBSD: vdsp.c,v 1.10 2011/01/07 00:46:48 kettenis Exp $	*/
d848 1
a848 1
		if (dowait) {
@


1.10
log
@Detect wether a disk image is an ISO image and set the media type to
VD_MEDIA_TYPE_CD to vDisk 1.1 clients.  Makes installing from a Solaris 11
Express bootable install CD work.
@
text
@d1 1
a1 1
/*	$OpenBSD: vdsp.c,v 1.9 2011/01/07 00:43:11 kettenis Exp $	*/
d277 1
a277 1
void	vdsp_sendmsg(struct vdsp_softc *, void *, size_t);
d387 1
d390 5
d410 1
d548 1
a548 1
			vdsp_sendmsg(sc, vi, sizeof(*vi));
d556 1
a556 1
			vdsp_sendmsg(sc, vi, sizeof(*vi));
d568 1
a568 1
		vdsp_sendmsg(sc, vi, sizeof(*vi));
d596 1
a596 1
			vdsp_sendmsg(sc, ai, sizeof(*ai));
d628 1
a628 1
			vdsp_sendmsg(sc, dr, sizeof(*dr));
d658 1
a658 1
		vdsp_sendmsg(sc, tag, sizeof(*tag));
d716 1
a716 1
			vdsp_sendmsg(sc, dm, sizeof(*dm));
d841 1
a841 1
vdsp_sendmsg(struct vdsp_softc *sc, void *msg, size_t len)
a843 3
	struct ldc_pkt *lp;
	uint64_t tx_head, tx_tail, tx_state;
	uint8_t *p = msg;
d846 12
a857 25
	err = hv_ldc_tx_get_state(lc->lc_id, &tx_head, &tx_tail, &tx_state);
	if (err != H_EOK)
		return;

	while (len > 0) {
		lp = (struct ldc_pkt *)(lc->lc_txq->lq_va + tx_tail);
		bzero(lp, sizeof(struct ldc_pkt));
		lp->type = LDC_DATA;
		lp->stype = LDC_INFO;
		lp->env = min(len, LDC_PKT_PAYLOAD);
		if (p == msg)
			lp->env |= LDC_FRAG_START;
		if (len <= LDC_PKT_PAYLOAD)
			lp->env |= LDC_FRAG_STOP;
		lp->seqid = lc->lc_tx_seqid++;
		bcopy(p, &lp->major, min(len, LDC_PKT_PAYLOAD));

		tx_tail += sizeof(*lp);
		tx_tail &= ((lc->lc_txq->lq_nentries * sizeof(*lp)) - 1);
		err = hv_ldc_tx_set_qtail(lc->lc_id, tx_tail);
		if (err != H_EOK)
			printf("%s: hv_ldc_tx_set_qtail: %d\n", __func__, err);
		p += min(len, LDC_PKT_PAYLOAD);
		len -= min(len, LDC_PKT_PAYLOAD);
	}
d934 1
a934 1
	vdsp_sendmsg(sc, &ai, sizeof(ai));
d1049 1
a1049 1
	vdsp_sendmsg(sc, &dr, sizeof(dr));
d1116 1
a1116 1
	    (dm->ncookies - 1) * sizeof(struct ldc_cookie));
d1580 1
a1580 1
	vdsp_sendmsg(sc, &dm, sizeof(dm));
@


1.9
log
@Fix malloc(9) call with swapped type and flags arguments.
@
text
@d1 1
a1 1
/*	$OpenBSD: vdsp.c,v 1.8 2011/01/06 23:26:48 kettenis Exp $	*/
d40 2
d284 1
d933 6
a938 2
	if (sc->sc_major > 1 || sc->sc_minor >= 1)
		ai.vd_mtype = VD_MEDIA_TYPE_FIXED;
d1004 35
@


1.8
log
@Add support for the vDisk 1.1 protocol.  Improve Solaris vtoc/disklabel
support and implement VD_OP_SET_VTOC.  This makes Solaris actualy run on top
of an OpenBSD control domain.  Installing from CD needs some further tweaking
but a network install will probably work.  OpenBSD clients are still happy.
@
text
@d1 1
a1 1
/*	$OpenBSD: vdsp.c,v 1.7 2011/01/06 18:40:09 kettenis Exp $	*/
d1008 1
a1008 1
	    M_WAITOK, M_DEVBUF);
@


1.7
log
@Solaris insists on getting the right sequence numbers in DRING_DATA messages
and it seems we were off by one.
@
text
@d1 1
a1 1
/*	$OpenBSD: vdsp.c,v 1.6 2011/01/02 22:28:29 kettenis Exp $	*/
d3 1
a3 1
 * Copyright (c) 2009 Mark Kettenis
d99 13
d176 1
a176 1
 * For now, we only support vDisk 1.0.
d179 1
a179 1
#define VDSK_MINOR	0
d182 1
a182 1
 * And we only support a subset of the defined commands.
d186 2
a187 1
     (1 << VD_OP_GET_DISKGEOM) | (1 << VD_OP_GET_VTOC))
d241 4
d281 1
d287 1
d550 2
d555 2
a556 1
		vi->minor = VDSK_MINOR;
d745 3
d930 2
d971 28
d1235 1
a1235 1
	struct sun_preamble *sl;
d1243 1
a1243 1
	vd->status = EINVAL;
d1249 1
a1249 2
		sl = (struct sun_preamble *)sc->sc_label;
		vt = malloc(PAGE_SIZE, M_DEVBUF, M_WAITOK | M_ZERO);
d1251 1
a1251 1
		memcpy(vt->ascii_label, sl->sl_text, sizeof(vt->ascii_label));
d1265 27
d1293 18
a1310 19
		i = 0;
		va = (vaddr_t)vt;
		size = roundup(sizeof(*vt), 64);
		off = 0;
		while (size > 0 && i < vd->ncookies) {
			pmap_extract(pmap_kernel(), va, &pa);
			nbytes = min(size, vd->cookie[i].size - off);
			nbytes = min(nbytes, PAGE_SIZE - (off & PAGE_MASK));
			err = hv_ldc_copy(lc->lc_id, LDC_COPY_OUT,
			    vd->cookie[i].addr + off, pa, nbytes, &nbytes);
			if (err != H_EOK)
				printf("%s: hv_ldc_copy: %d\n", __func__, err);
			va += nbytes;
			size -= nbytes;
			off += nbytes;
			if (off >= vd->cookie[i].size) {
				off = 0;
				i++;
			}
d1312 1
d1314 44
a1357 2
		vd->status = 0;
		free(vt, M_DEVBUF);
d1360 46
d1464 5
@


1.6
log
@More changes to pacify the Solaris virtual disk client.  Implement
VD_OP_GET_VTOC and VD_OP_GET_DISKGEOM.  Factor out the code to ACK descriptors
and fix a bug copying in/out a descriptor that crosses a page boundary.
@
text
@d1 1
a1 1
/*	$OpenBSD: vdsp.c,v 1.5 2011/01/02 12:11:22 kettenis Exp $	*/
d1367 1
a1367 1
	dm.seq_no = sc->sc_seq_no++;
@


1.5
log
@Move away from using fixed-sized descriptors and fill in some missing bits
in the messages that ACK descriptors.  Makes OpenSolaris virtual disk clients
much happier and able to boot from a bootable automatic installer cdrom.
@
text
@d1 1
a1 1
/*	$OpenBSD: vdsp.c,v 1.4 2011/01/02 00:49:05 kettenis Exp $	*/
d22 1
d40 2
d99 31
d169 1
a169 1
 * And we only support Block Read, Block Write and Flush commands.
d172 2
a173 1
    ((1 << VD_OP_BREAD) | (1 << VD_OP_BWRITE) | (1 << VD_OP_FLUSH))
d225 2
d262 1
d267 5
a271 1
void	vdsp_fail_dring(struct vdsp_softc *, struct vd_desc *);
d670 3
a672 1
	paddr_t pa, offset;
d687 14
a700 8
		sc->sc_seq_no = dm->seq_no;

		offset = dm->start_idx * sc->sc_descriptor_size;
		vd = (struct vd_desc *)(sc->sc_vd + offset);
		pmap_extract(pmap_kernel(), (vaddr_t)vd, &pa);
		err = hv_ldc_copy(sc->sc_lc.lc_id, LDC_COPY_IN,
		    sc->sc_dring_cookie.addr | offset, pa,
		    sc->sc_descriptor_size, &nbytes);
d702 1
a702 1
			printf("hv_ldc_copy %d\n", err);
d706 3
d719 6
d728 1
a728 1
			vdsp_fail_dring(sc, vd);
d787 1
d792 4
a795 1

d850 1
a850 1
		printf("hv_ldc_tx_qconf %d\n", err);
d855 1
a855 1
		printf("hv_ldc_rx_qconf %d\n", err);
d893 2
d912 32
d1010 1
a1010 1
				printf("hv_ldc_copy: %d\n", err);
a1035 1
	struct vio_dring_msg dm;
d1041 1
a1041 1
	paddr_t pa, offset;
d1077 1
a1077 1
				printf("hv_ldc_copy: %d\n", err);
d1090 1
d1092 1
a1092 21
	pmap_extract(pmap_kernel(), (vaddr_t)vd, &pa);
	offset = (caddr_t)vd - sc->sc_vd;
	err = hv_ldc_copy(sc->sc_lc.lc_id, LDC_COPY_OUT,
	    sc->sc_dring_cookie.addr | offset, pa,
	    sc->sc_descriptor_size, &nbytes);
	if (err != H_EOK) {
		printf("hv_ldc_copy %d\n", err);
		return;
	}

	/* ACK the descriptor. */
	bzero(&dm, sizeof(dm));
	dm.tag.type = VIO_TYPE_DATA;
	dm.tag.stype = VIO_SUBTYPE_ACK;
	dm.tag.stype_env = VIO_DRING_DATA;
	dm.tag.sid = sc->sc_local_sid;
	dm.seq_no = sc->sc_seq_no;
	dm.dring_ident = sc->sc_dring_ident;
	dm.start_idx = offset / sc->sc_descriptor_size;
	dm.end_idx = offset / sc->sc_descriptor_size;
	vdsp_sendmsg(sc, &dm, sizeof(dm));
a1100 1
	struct vio_dring_msg dm;
d1106 1
a1106 1
	paddr_t pa, offset;
d1127 1
a1127 1
			printf("hv_ldc_copy: %d\n", err);
d1153 1
d1155 10
a1164 7
	pmap_extract(pmap_kernel(), (vaddr_t)vd, &pa);
	offset = (caddr_t)vd - sc->sc_vd;
	err = hv_ldc_copy(sc->sc_lc.lc_id, LDC_COPY_OUT,
	    sc->sc_dring_cookie.addr | offset, pa,
	    sc->sc_descriptor_size, &nbytes);
	if (err != H_EOK) {
		printf("hv_ldc_copy %d\n", err);
d1166 68
d1237 2
a1238 10
	bzero(&dm, sizeof(dm));
	dm.tag.type = VIO_TYPE_DATA;
	dm.tag.stype = VIO_SUBTYPE_ACK;
	dm.tag.stype_env = VIO_DRING_DATA;
	dm.tag.sid = sc->sc_local_sid;
	dm.seq_no = sc->sc_seq_no;
	dm.dring_ident = sc->sc_dring_ident;
	dm.start_idx = offset / sc->sc_descriptor_size;
	dm.end_idx = offset / sc->sc_descriptor_size;
	vdsp_sendmsg(sc, &dm, sizeof(dm));
d1242 1
a1242 1
vdsp_flush_dring(void *arg1, void *arg2)
d1245 1
d1247 4
a1250 2
	struct vio_dring_msg dm;
	paddr_t pa, offset;
d1252 42
a1293 1
	int err;
d1295 20
a1314 2
	if (sc->sc_vp == NULL)
		return;
d1316 1
d1319 8
a1326 9
	pmap_extract(pmap_kernel(), (vaddr_t)vd, &pa);
	offset = (caddr_t)vd - sc->sc_vd;
	err = hv_ldc_copy(sc->sc_lc.lc_id, LDC_COPY_OUT,
	    sc->sc_dring_cookie.addr | offset, pa,
	    sc->sc_descriptor_size, &nbytes);
	if (err != H_EOK) {
		printf("hv_ldc_copy %d\n", err);
		return;
	}
d1329 3
a1331 10
	bzero(&dm, sizeof(dm));
	dm.tag.type = VIO_TYPE_DATA;
	dm.tag.stype = VIO_SUBTYPE_ACK;
	dm.tag.stype_env = VIO_DRING_DATA;
	dm.tag.sid = sc->sc_local_sid;
	dm.seq_no = sc->sc_seq_no;
	dm.dring_ident = sc->sc_dring_ident;
	dm.start_idx = offset / sc->sc_descriptor_size;
	dm.end_idx = offset / sc->sc_descriptor_size;
	vdsp_sendmsg(sc, &dm, sizeof(dm));
d1335 1
a1335 1
vdsp_fail_dring(struct vdsp_softc *sc, struct vd_desc *vd)
d1338 3
a1340 1
	paddr_t pa, offset;
d1344 12
a1355 7
	vd->status = ENOTSUP;
	vd->hdr.dstate = VIO_DESC_DONE;
	pmap_extract(pmap_kernel(), (vaddr_t)vd, &pa);
	offset = (caddr_t)vd - sc->sc_vd;
	err = hv_ldc_copy(sc->sc_lc.lc_id, LDC_COPY_OUT,
	    sc->sc_dring_cookie.addr | offset, pa,
	    sc->sc_descriptor_size, &nbytes);
d1357 1
a1357 1
		printf("hv_ldc_copy %d\n", err);
d1367 1
a1367 1
	dm.seq_no = sc->sc_seq_no;
d1369 3
a1371 2
	dm.start_idx = offset / sc->sc_descriptor_size;
	dm.end_idx = offset / sc->sc_descriptor_size;
@


1.4
log
@Use the session ID passed to use by the virtual disk client, and pass back
a bit more information to the client during the attribute negotiation phase.
Gets us past the attribute negotiation phase against an OpenSolaris virtual
disk client.
@
text
@d1 1
a1 1
/*	$OpenBSD: vdsp.c,v 1.3 2011/01/02 00:35:23 kettenis Exp $	*/
d49 2
a50 2
#define VDSK_TX_ENTRIES		64
#define VDSK_RX_ENTRIES		64
d52 2
a53 1
#define VDSK_MAX_DESCRIPTORS	1024
d107 1
a107 1
	struct ldc_cookie	cookie[MAXPHYS / PAGE_SIZE];
d180 1
a180 1
	struct vd_desc	*sc_vd;
d229 1
d550 1
a550 1
		    dr->descriptor_size > sizeof(struct vd_desc) ||
d643 4
a646 1
		vd = &sc->sc_vd[dm->start_idx];
a647 1
		offset = dm->start_idx * sc->sc_descriptor_size;
d669 1
d852 3
a854 2
	KASSERT(sc->sc_num_descriptors <= 1024);
	sc->sc_vd = malloc(sc->sc_num_descriptors * sizeof(struct vd_desc),
d996 1
a996 1
	offset = (vd - sc->sc_vd) * sc->sc_descriptor_size;
d1011 1
d1013 2
d1079 1
a1079 1
	offset = (vd - sc->sc_vd) * sc->sc_descriptor_size;
d1094 1
d1096 2
d1117 34
a1150 1
	offset = (vd - sc->sc_vd) * sc->sc_descriptor_size;
d1165 1
d1167 2
@


1.3
log
@Declare ourselves to be a virtual disk server during the version negotiation
phase.  Gets us past the version negotiation against an OpenSolaris virtual
disk client.
@
text
@d1 1
a1 1
/*	$OpenBSD: vdsp.c,v 1.2 2010/04/20 23:26:59 deraadt Exp $	*/
d133 6
d486 2
a488 1
		vi->tag.sid = sc->sc_local_sid;
d833 1
d835 1
d837 1
@


1.2
log
@cleanup more confusion regarding user.h before proc.h, or missing proc.h
ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: vdsp.c,v 1.1 2009/12/31 11:58:41 kettenis Exp $	*/
d483 1
@


1.1
log
@Add vds(4) and vdsp(4), implementing the vDisk server side protocol.  This
makes it possible to run an OpenBSD guest domain on top of a virtiual disk
backed by a disk image on a filesystem on OpenBSD control or service domain.

Probably doesn't support running Solaris or Linux yet.  Haven't tried those
yet because booting their installers in a guest domain is way too painful!
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d19 1
@

