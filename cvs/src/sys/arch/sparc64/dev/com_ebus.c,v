head	1.21;
access;
symbols
	OPENBSD_6_1:1.21.0.22
	OPENBSD_6_1_BASE:1.21
	OPENBSD_6_0:1.21.0.20
	OPENBSD_6_0_BASE:1.21
	OPENBSD_5_9:1.21.0.16
	OPENBSD_5_9_BASE:1.21
	OPENBSD_5_8:1.21.0.18
	OPENBSD_5_8_BASE:1.21
	OPENBSD_5_7:1.21.0.10
	OPENBSD_5_7_BASE:1.21
	OPENBSD_5_6:1.21.0.14
	OPENBSD_5_6_BASE:1.21
	OPENBSD_5_5:1.21.0.12
	OPENBSD_5_5_BASE:1.21
	OPENBSD_5_4:1.21.0.8
	OPENBSD_5_4_BASE:1.21
	OPENBSD_5_3:1.21.0.6
	OPENBSD_5_3_BASE:1.21
	OPENBSD_5_2:1.21.0.4
	OPENBSD_5_2_BASE:1.21
	OPENBSD_5_1_BASE:1.21
	OPENBSD_5_1:1.21.0.2
	OPENBSD_5_0:1.20.0.12
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.20.0.10
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.20.0.8
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.20.0.4
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.20.0.6
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.20.0.2
	OPENBSD_4_5_BASE:1.20
	OPENBSD_4_4:1.18.0.2
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.16.0.2
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.12.0.2
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.11.0.8
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.6
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.11.0.4
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.2
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.10.0.2
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.9.0.8
	OPENBSD_3_6_BASE:1.9
	SMP_SYNC_A:1.9
	SMP_SYNC_B:1.9
	OPENBSD_3_5:1.9.0.4
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	UBC_SYNC_A:1.8
	OPENBSD_3_3:1.8.0.2
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.7.0.2
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	UBC_SYNC_B:1.7
	UBC:1.1.0.6
	UBC_BASE:1.1
	SMP:1.1.0.4
	OPENBSD_3_0:1.1.0.2
	OPENBSD_3_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.21
date	2011.09.28.11.02.37;	author dlg;	state Exp;
branches;
next	1.20;

1.20
date	2009.01.12.22.17.36;	author kettenis;	state Exp;
branches;
next	1.19;

1.19
date	2009.01.05.22.13.17;	author kettenis;	state Exp;
branches;
next	1.18;

1.18
date	2008.07.10.12.33.40;	author kettenis;	state Exp;
branches;
next	1.17;

1.17
date	2008.05.24.15.29.33;	author kettenis;	state Exp;
branches;
next	1.16;

1.16
date	2008.03.01.15.59.04;	author kettenis;	state Exp;
branches;
next	1.15;

1.15
date	2008.02.10.16.31.30;	author kettenis;	state Exp;
branches;
next	1.14;

1.14
date	2008.01.08.00.29.36;	author dlg;	state Exp;
branches;
next	1.13;

1.13
date	2007.11.15.20.39.45;	author kettenis;	state Exp;
branches;
next	1.12;

1.12
date	2007.04.03.23.17.42;	author kettenis;	state Exp;
branches;
next	1.11;

1.11
date	2005.06.06.01.08.47;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2004.09.23.18.55.45;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.24.21.54.39;	author henric;	state Exp;
branches;
next	1.8;

1.8
date	2003.02.17.01.29.20;	author henric;	state Exp;
branches;
next	1.7;

1.7
date	2002.06.04.19.26.49;	author jason;	state Exp;
branches;
next	1.6;

1.6
date	2002.03.14.01.26.44;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.01.25.03.58.39;	author jason;	state Exp;
branches;
next	1.4;

1.4
date	2002.01.24.03.38.56;	author jason;	state Exp;
branches;
next	1.3;

1.3
date	2002.01.23.20.16.05;	author jason;	state Exp;
branches;
next	1.2;

1.2
date	2002.01.17.05.17.10;	author jason;	state Exp;
branches;
next	1.1;

1.1
date	2001.09.29.03.13.49;	author art;	state Exp;
branches
	1.1.4.1
	1.1.6.1;
next	;

1.1.4.1
date	2001.10.31.03.07.57;	author nate;	state Exp;
branches;
next	1.1.4.2;

1.1.4.2
date	2002.03.06.02.04.46;	author niklas;	state Exp;
branches;
next	1.1.4.3;

1.1.4.3
date	2002.03.28.10.57.11;	author niklas;	state Exp;
branches;
next	1.1.4.4;

1.1.4.4
date	2003.03.27.23.42.35;	author niklas;	state Exp;
branches;
next	1.1.4.5;

1.1.4.5
date	2004.02.19.10.49.59;	author niklas;	state Exp;
branches;
next	;

1.1.6.1
date	2002.01.31.22.55.23;	author niklas;	state Exp;
branches;
next	1.1.6.2;

1.1.6.2
date	2002.06.11.03.38.42;	author art;	state Exp;
branches;
next	1.1.6.3;

1.1.6.3
date	2003.05.19.21.46.57;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.21
log
@disable the fifo on m series systems by telling the driver its a 16550
which stops the MI com code from probing it as a 16550a.

hopefully this will prevent the awesome faults on the mainboard from
locking the system up.

ok kettenis@@
@
text
@/*	$OpenBSD: com_ebus.c,v 1.20 2009/01/12 22:17:36 kettenis Exp $	*/
/*	$NetBSD: com_ebus.c,v 1.6 2001/07/24 19:27:10 eeh Exp $	*/

/*
 * Copyright (c) 1999, 2000 Matthew R. Green
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * NS Super I/O PC87332VLJ "com" to ebus attachment
 */

#include <sys/types.h>
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/tty.h>
#include <sys/conf.h>

#include <machine/bus.h>
#include <machine/autoconf.h>
#include <machine/openfirm.h>

#include <sparc64/dev/ebusreg.h>
#include <sparc64/dev/ebusvar.h>

#include <dev/cons.h>
#include <dev/ic/comvar.h>

cdev_decl(com); /* XXX this belongs elsewhere */

int	com_ebus_match(struct device *, void *, void *);
void	com_ebus_attach(struct device *, struct device *, void *);
int	com_ebus_speed(struct ebus_attach_args *);

struct cfattach com_ebus_ca = {
	sizeof(struct com_softc), com_ebus_match, com_ebus_attach
};

static char *com_names[] = {
	"su",
	"su_pnp",
	"rsc-console",
	"lom-console",
	NULL
};

int
com_ebus_match(struct device *parent, void *match, void *aux)
{
	struct ebus_attach_args *ea = aux;
	int i;

	for (i=0; com_names[i]; i++)
		if (strcmp(ea->ea_name, com_names[i]) == 0)
			return (1);

	if (strcmp(ea->ea_name, "serial") == 0) {
		char compat[80];

		/* Could be anything. */
		if ((i = OF_getproplen(ea->ea_node, "compatible")) &&
			OF_getprop(ea->ea_node, "compatible", compat,
				sizeof(compat)) == i) {
			if (strcmp(compat, "su16552") == 0 ||
			    strcmp(compat, "su16550") == 0 ||
			    strcmp(compat, "FJSV,su") == 0 ||
			    strcmp(compat, "su") == 0) {
				return (1);
			}
		}
	}
	return (0);
}

/* XXXART - was 1846200 */
#define BAUD_BASE       (1843200)

void
com_ebus_attach(struct device *parent, struct device *self, void *aux)
{
	struct com_softc *sc = (void *)self;
	struct ebus_attach_args *ea = aux;
	int i, com_is_input, com_is_output;
	int node, port;
	char buf[32];

	sc->sc_iobase = EBUS_PADDR_FROM_REG(&ea->ea_regs[0]);
	/*
	 * Addresses that should be supplied by the prom:
	 *	- normal com registers
	 *	- ns873xx configuration registers
	 *	- DMA space
	 * The `com' driver does not use DMA accesses, so we can
	 * ignore that for now.  We should enable the com port in
	 * the ns873xx registers here. XXX
	 *
	 * Use the prom address if there.
	 */
	if (ea->ea_nvaddrs) {
		if (bus_space_map(ea->ea_memtag, ea->ea_vaddrs[0], 0,
		    BUS_SPACE_MAP_PROMADDRESS, &sc->sc_ioh) != 0) {
			printf(": can't map register space\n");
			return;
		}
		sc->sc_iot = ea->ea_memtag;
	} else if (ebus_bus_map(ea->ea_memtag, 0,
	    EBUS_PADDR_FROM_REG(&ea->ea_regs[0]),
	    ea->ea_regs[0].size, 0, 0, &sc->sc_ioh) == 0) {
		sc->sc_iot = ea->ea_memtag;
	} else if (ebus_bus_map(ea->ea_iotag, 0,
	    EBUS_PADDR_FROM_REG(&ea->ea_regs[0]),
	    ea->ea_regs[0].size, 0, 0, &sc->sc_ioh) == 0) {
		sc->sc_iot = ea->ea_iotag;
	} else {
		printf(": can't map register space\n");
               	return;
	}
	sc->sc_hwflags = 0;
	sc->sc_swflags = 0;
	sc->sc_frequency = BAUD_BASE;

	for (i = 0; i < ea->ea_nintrs; i++)
		bus_intr_establish(sc->sc_iot, ea->ea_intrs[i],
		    IPL_TTY, 0, comintr, sc, self->dv_xname);

	/*
	 * Figure out if we're the console.
	 *
	 * The Fujitsu SPARC Enterprise M4000/M5000/M8000/M9000 has a
	 * serial port on each I/O board and a pseudo console that is
	 * redirected to one of these serial ports.  The board number
	 * of the serial port in question is encoded in the "tty-port#"
	 * property of the pseudo console, so we figure out what our
	 * board number is by walking up the device tree, and check
	 * for a match.
	 */

	node = OF_instance_to_package(OF_stdin());
	com_is_input = (ea->ea_node == node);
	if (OF_getprop(node, "name", buf, sizeof(buf)) > 0 &&
	    strcmp(buf, "pseudo-console") == 0) {
		port = getpropint(node, "tty-port#", -1);
		node = OF_parent(OF_parent(ea->ea_node));
		com_is_input = (getpropint(node, "board#", -2) == port);
	}

	node = OF_instance_to_package(OF_stdout());
	com_is_output = (ea->ea_node == node);
	if (OF_getprop(node, "name", buf, sizeof(buf)) > 0 &&
	    strcmp(buf, "pseudo-console") == 0) {
		port = getpropint(node, "tty-port#", -1);
		node = OF_parent(OF_parent(ea->ea_node));
		com_is_output = (getpropint(node, "board#", -2) == port);
	}

	if (com_is_input || com_is_output) {
		struct consdev *cn_orig;
		int speed;

		speed = com_ebus_speed(ea);

		comconsioh = sc->sc_ioh;
		cn_orig = cn_tab;
		/* Attach com as the console. */
		if (comcnattach(sc->sc_iot, sc->sc_iobase, speed,
		    sc->sc_frequency,
		    ((TTYDEF_CFLAG & ~(CSIZE | PARENB))|CREAD | CS8 | HUPCL))) {
			printf("Error: comcnattach failed\n");
		}
		cn_tab = cn_orig;
		if (com_is_input) {
			cn_tab->cn_dev = /*XXX*/makedev(36, sc->sc_dev.dv_unit);
			cn_tab->cn_probe = comcnprobe;
			cn_tab->cn_init = comcninit;
			cn_tab->cn_getc = comcngetc;
			cn_tab->cn_pollc = comcnpollc;
		}
		if (com_is_output)
			cn_tab->cn_putc = comcnputc;
	}

	/*
	 * Apparently shoving too much data down the TX FIFO on the
	 * Fujitsu SPARC Enterprise M4000/M5000 causes a hardware
	 * fault.  Avoid this issue by setting the FIFO depth to 1.
	 * This will effectively disable the TX FIFO, but will still
	 * enable the RX FIFO, which is what we really care about.
	 */
	if (OF_getprop(ea->ea_node, "compatible", buf, sizeof(buf)) > 0 &&
	    strcmp(buf, "FJSV,su") == 0)
		sc->sc_uarttype = COM_UART_16550;

        if (OF_getproplen(ea->ea_node, "keyboard") == 0)
		printf(": keyboard");
	else if (OF_getproplen(ea->ea_node, "mouse") == 0)
		printf(": mouse");

	/* Now attach the driver */
	com_attach_subr(sc);
}

int
com_ebus_speed(struct ebus_attach_args *ea)
{
	char buf[128];
	char *name = NULL;
	int aliases, options;

	if (strcmp(ea->ea_name, "rsc-console") == 0)
		return 115200;

	aliases = OF_finddevice("/aliases");
	if (OF_getprop(aliases, "ttya", buf, sizeof(buf)) != -1 &&
	    OF_finddevice(buf) == ea->ea_node)
		name = "ttya-mode";
	if (OF_getprop(aliases, "ttyb", buf, sizeof(buf)) != -1 &&
	    OF_finddevice(buf) == ea->ea_node)
		name = "ttyb-mode";

	if (name == NULL)
		return TTYDEF_SPEED;

	options = OF_finddevice("/options");
	return (getpropspeed(options, name));
}
@


1.20
log
@Look up the "compatible" property of the right node to detect serial
interfaces on the m4k/m5k/m8k/m9k.
@
text
@d1 1
a1 1
/*	$OpenBSD: com_ebus.c,v 1.19 2009/01/05 22:13:17 kettenis Exp $	*/
d215 1
a215 1
		sc->sc_fifolen = 1;
@


1.19
log
@Restrict FIFO depth to 1 byte on m4k/m5k/m8k/m9k.  Hopefully this prevents
hardware faults from happening.
@
text
@d1 1
a1 1
/*	$OpenBSD: com_ebus.c,v 1.18 2008/07/10 12:33:40 kettenis Exp $	*/
d213 1
a213 1
	if (OF_getprop(node, "compatible", buf, sizeof(buf)) > 0 &&
@


1.18
log
@Detect whether com(4) is the console on the m4k.
@
text
@d1 1
a1 1
/*	$OpenBSD: com_ebus.c,v 1.16 2008/03/01 15:59:04 kettenis Exp $	*/
d205 11
@


1.17
log
@Attach to "FJSV,su", which is the name used for serial ports on the SPARC
Enterprise M4000/M5000/M8000/M9000.
@
text
@d108 2
d150 29
a178 3
	/* Figure out if we're the console. */
	com_is_input = (ea->ea_node == OF_instance_to_package(OF_stdin()));
	com_is_output = (ea->ea_node == OF_instance_to_package(OF_stdout()));
@


1.16
log
@Make sabtty(4) adopt the speed configured in OpenFirmware when it is the
console.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: com_ebus.c,v 1.15 2008/02/10 16:31:30 kettenis Exp $	*/
d90 1
@


1.15
log
@Attach to "lom-console".  Hopefuly this will give us a proper console on
the Netra T4/Netra 20 when the console is directed to the LOM.
@
text
@d1 1
a1 1
/*	$OpenBSD: com_ebus.c,v 1.14 2008/01/08 00:29:36 dlg Exp $	*/
d57 1
d72 1
a72 4
com_ebus_match(parent, match, aux)
	struct device *parent;
	void *match;
	void *aux;
d102 1
a102 3
com_ebus_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d153 1
a153 1
		int speed = 9600;
d155 1
a155 2
		if (strcmp(ea->ea_name, "rsc-console") == 0)
			speed = 115200;
d184 25
@


1.14
log
@the rsc-console on the v880 operates at 115200, not the 9600 we think we
have to force all console devices to. this change passes the right speed
to the com code, and continues to use it when the device is opened as the
console device.

figured out by kettenis@@
ok kettenis@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: com_ebus.c,v 1.12 2007/04/03 23:17:42 kettenis Exp $	*/
d66 1
@


1.13
log
@Attach to "rsc-console".  Hopefuly this will give us a proper console on
the Sun Fire 280R/V480/V880 when the console is directed to the RSC card.
@
text
@d156 4
d164 1
a164 1
		if (comcnattach(sc->sc_iot, sc->sc_iobase, 9600,
@


1.12
log
@Match su16552.
@
text
@d1 1
a1 1
/*	$OpenBSD: com_ebus.c,v 1.11 2005/06/06 01:08:47 miod Exp $	*/
d65 1
@


1.11
log
@Homogeneize dmesg output.
@
text
@d1 1
a1 1
/*	$OpenBSD: com_ebus.c,v 1.10 2004/09/23 18:55:45 miod Exp $	*/
d88 3
a90 2
			if (strcmp(compat, "su16550") == 0 || 
				strcmp(compat, "su") == 0) {
@


1.10
log
@Correctly test for prom memory mapping failure. Fortunately no system we
know of provides prom memory mappings for com(4)...
@
text
@d1 1
a1 1
/*	$OpenBSD: com_ebus.c,v 1.9 2003/06/24 21:54:39 henric Exp $	*/
d176 1
a176 1
		printf(", keyboard");
d178 1
a178 1
		printf(", mouse");
@


1.9
log
@Add a "where" argument to the sparc64 interrupt code.  This lets us
associate a name with each interrupt handler.  This is not visible
outside the kernel (yet).

ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: com_ebus.c,v 1.8 2003/02/17 01:29:20 henric Exp $	*/
d123 1
a123 1
		    BUS_SPACE_MAP_PROMADDRESS, &sc->sc_ioh) == 0) {
@


1.8
log
@
Add support for the Sun Enterprise 450
Reduce the size of a GENERIC kernel by ~190k
Remove the nasty pointer/bus_space_handle_t casts
Adds debug bus_space code including the ability to trace
    bus operations (it actually works now).

The following rules are now followed (and verfified by the debug
code):

1.  A "bus_space_handle_t" may only be used with the
    "bus_space_tag_t" that created it.
2.  Only "bus_space_map()" may create "bus_space_handle_t"s.
3.  A "bus_space_handle_t" may not be modified after it has
    been created (other than being destroyed by "bus_space_unmap()").


Thanks to help from mcbride, marc, jason, drahn, to anyone that might
have slipped my mind at the moment.

ok jason@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: com_ebus.c,v 1.7 2002/06/04 19:26:49 jason Exp $	*/
d146 1
a146 1
		    IPL_TTY, 0, comintr, sc);
@


1.7
log
@identify keyboard/mouse ports
@
text
@d1 1
a1 1
/*	$OpenBSD: com_ebus.c,v 1.6 2002/03/14 01:26:44 millert Exp $	*/
a108 1
	sc->sc_iot = ea->ea_bustag;
d111 1
a111 1
	 * Addresses that shoud be supplied by the prom:
d121 16
a136 7
	if (ea->ea_nvaddrs)
		sc->sc_ioh = (bus_space_handle_t)ea->ea_vaddrs[0];
	else if (ebus_bus_map(sc->sc_iot, 0,
			      EBUS_PADDR_FROM_REG(&ea->ea_regs[0]),
			      ea->ea_regs[0].size,
			      BUS_SPACE_MAP_LINEAR,
			      0, &sc->sc_ioh) != 0) {
d138 1
a138 1
                return;
d145 1
a145 1
		bus_intr_establish(ea->ea_bustag, ea->ea_intrs[i],
@


1.6
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: com_ebus.c,v 1.5 2002/01/25 03:58:39 jason Exp $	*/
d166 6
a174 1

@


1.5
log
@Remove kbd_ms_ttyvar.h... Unneeded file from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: com_ebus.c,v 1.4 2002/01/24 03:38:56 jason Exp $	*/
d55 2
a56 2
int	com_ebus_match __P((struct device *, void *, void *));
void	com_ebus_attach __P((struct device *, struct device *, void *));
@


1.4
log
@Don't need ms.h (or SUNKBD/SUNMS)
@
text
@d1 1
a1 1
/*	$OpenBSD: com_ebus.c,v 1.3 2002/01/23 20:16:05 jason Exp $	*/
a51 1
#include <dev/sun/kbd_ms_ttyvar.h>
@


1.3
log
@handle split input/output devices (from NetBSD)
@
text
@d1 1
a1 1
/*	$OpenBSD: com_ebus.c,v 1.2 2002/01/17 05:17:10 jason Exp $	*/
a52 2

#include "ms.h"
@


1.2
log
@I'm a tree breaker... sorry... don't include "kbd.h"
@
text
@d1 1
a1 1
/*	$OpenBSD: com_ebus.c,v 1.1 2001/09/29 03:13:49 art Exp $	*/
a59 1
int	com_ebus_isconsole __P((int node));
a99 14
int
com_ebus_isconsole(node)
	int node;
{
	if (node == OF_instance_to_package(OF_stdin())) {
		return (1);
	}

	if (node == OF_instance_to_package(OF_stdout())) { 
		return (1);
	}
	return (0);
}

d110 1
a110 1
	int i;
d143 7
a149 1
	if (com_ebus_isconsole(ea->ea_node)) {
d151 1
d158 10
@


1.1
log
@Glue for com at ebus. From NetBSD, hacked to fit our com.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a53 1
#include "kbd.h"
@


1.1.6.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: com_ebus.c,v 1.5 2002/01/25 03:58:39 jason Exp $	*/
d52 4
d61 1
d102 14
d126 1
a126 1
	int i, com_is_input, com_is_output;
d159 1
a159 7
	/* Figure out if we're the console. */
	com_is_input = (ea->ea_node == OF_instance_to_package(OF_stdin()));
	com_is_output = (ea->ea_node == OF_instance_to_package(OF_stdout()));

	if (com_is_input || com_is_output) {
		struct consdev *cn_orig;

a160 1
		cn_orig = cn_tab;
a166 10
		cn_tab = cn_orig;
		if (com_is_input) {
			cn_tab->cn_dev = /*XXX*/makedev(36, sc->sc_dev.dv_unit);
			cn_tab->cn_probe = comcnprobe;
			cn_tab->cn_init = comcninit;
			cn_tab->cn_getc = comcngetc;
			cn_tab->cn_pollc = comcnpollc;
		}
		if (com_is_output)
			cn_tab->cn_putc = comcnputc;
@


1.1.6.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: com_ebus.c,v 1.1.6.1 2002/01/31 22:55:23 niklas Exp $	*/
d55 2
a56 2
int	com_ebus_match(struct device *, void *, void *);
void	com_ebus_attach(struct device *, struct device *, void *);
a165 6

        if (OF_getproplen(ea->ea_node, "keyboard") == 0)
		printf(", keyboard");
	else if (OF_getproplen(ea->ea_node, "mouse") == 0)
		printf(", mouse");

d169 1
@


1.1.6.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d109 1
d112 1
a112 1
	 * Addresses that should be supplied by the prom:
d122 7
a128 16
	if (ea->ea_nvaddrs) {
		if (bus_space_map(ea->ea_memtag, ea->ea_vaddrs[0], 0,
		    BUS_SPACE_MAP_PROMADDRESS, &sc->sc_ioh) == 0) {
			printf(": can't map register space\n");
			return;
		}
		sc->sc_iot = ea->ea_memtag;
	} else if (ebus_bus_map(ea->ea_memtag, 0,
	    EBUS_PADDR_FROM_REG(&ea->ea_regs[0]),
	    ea->ea_regs[0].size, 0, 0, &sc->sc_ioh) == 0) {
		sc->sc_iot = ea->ea_memtag;
	} else if (ebus_bus_map(ea->ea_iotag, 0,
	    EBUS_PADDR_FROM_REG(&ea->ea_regs[0]),
	    ea->ea_regs[0].size, 0, 0, &sc->sc_ioh) == 0) {
		sc->sc_iot = ea->ea_iotag;
	} else {
d130 1
a130 1
               	return;
d137 1
a137 1
		bus_intr_establish(sc->sc_iot, ea->ea_intrs[i],
@


1.1.4.1
log
@Sync the SMP branch to something just after 3.0
@
text
@@


1.1.4.2
log
@Merge in trunk
@
text
@d52 4
d61 1
d102 14
d126 1
a126 1
	int i, com_is_input, com_is_output;
d159 1
a159 7
	/* Figure out if we're the console. */
	com_is_input = (ea->ea_node == OF_instance_to_package(OF_stdin()));
	com_is_output = (ea->ea_node == OF_instance_to_package(OF_stdout()));

	if (com_is_input || com_is_output) {
		struct consdev *cn_orig;

a160 1
		cn_orig = cn_tab;
a166 10
		cn_tab = cn_orig;
		if (com_is_input) {
			cn_tab->cn_dev = /*XXX*/makedev(36, sc->sc_dev.dv_unit);
			cn_tab->cn_probe = comcnprobe;
			cn_tab->cn_init = comcninit;
			cn_tab->cn_getc = comcngetc;
			cn_tab->cn_pollc = comcnpollc;
		}
		if (com_is_output)
			cn_tab->cn_putc = comcnputc;
@


1.1.4.3
log
@Merge in -current from about a week ago
@
text
@d55 2
a56 2
int	com_ebus_match(struct device *, void *, void *);
void	com_ebus_attach(struct device *, struct device *, void *);
@


1.1.4.4
log
@Sync the SMP branch with 3.3
@
text
@d109 1
d112 1
a112 1
	 * Addresses that should be supplied by the prom:
d122 7
a128 16
	if (ea->ea_nvaddrs) {
		if (bus_space_map(ea->ea_memtag, ea->ea_vaddrs[0], 0,
		    BUS_SPACE_MAP_PROMADDRESS, &sc->sc_ioh) == 0) {
			printf(": can't map register space\n");
			return;
		}
		sc->sc_iot = ea->ea_memtag;
	} else if (ebus_bus_map(ea->ea_memtag, 0,
	    EBUS_PADDR_FROM_REG(&ea->ea_regs[0]),
	    ea->ea_regs[0].size, 0, 0, &sc->sc_ioh) == 0) {
		sc->sc_iot = ea->ea_memtag;
	} else if (ebus_bus_map(ea->ea_iotag, 0,
	    EBUS_PADDR_FROM_REG(&ea->ea_regs[0]),
	    ea->ea_regs[0].size, 0, 0, &sc->sc_ioh) == 0) {
		sc->sc_iot = ea->ea_iotag;
	} else {
d130 1
a130 1
               	return;
d137 1
a137 1
		bus_intr_establish(sc->sc_iot, ea->ea_intrs[i],
a165 6

        if (OF_getproplen(ea->ea_node, "keyboard") == 0)
		printf(", keyboard");
	else if (OF_getproplen(ea->ea_node, "mouse") == 0)
		printf(", mouse");

d169 1
@


1.1.4.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d146 1
a146 1
		    IPL_TTY, 0, comintr, sc, self->dv_xname);
@


