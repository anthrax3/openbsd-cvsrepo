head	1.68;
access;
symbols
	OPENBSD_6_2:1.68.0.2
	OPENBSD_6_2_BASE:1.68
	OPENBSD_6_1:1.67.0.4
	OPENBSD_6_1_BASE:1.67
	OPENBSD_6_0:1.66.0.10
	OPENBSD_6_0_BASE:1.66
	OPENBSD_5_9:1.66.0.6
	OPENBSD_5_9_BASE:1.66
	OPENBSD_5_8:1.66.0.8
	OPENBSD_5_8_BASE:1.66
	OPENBSD_5_7:1.66.0.2
	OPENBSD_5_7_BASE:1.66
	OPENBSD_5_6:1.66.0.4
	OPENBSD_5_6_BASE:1.66
	OPENBSD_5_5:1.64.0.6
	OPENBSD_5_5_BASE:1.64
	OPENBSD_5_4:1.64.0.2
	OPENBSD_5_4_BASE:1.64
	OPENBSD_5_3:1.63.0.8
	OPENBSD_5_3_BASE:1.63
	OPENBSD_5_2:1.63.0.6
	OPENBSD_5_2_BASE:1.63
	OPENBSD_5_1_BASE:1.63
	OPENBSD_5_1:1.63.0.4
	OPENBSD_5_0:1.63.0.2
	OPENBSD_5_0_BASE:1.63
	OPENBSD_4_9:1.61.0.2
	OPENBSD_4_9_BASE:1.61
	OPENBSD_4_8:1.60.0.6
	OPENBSD_4_8_BASE:1.60
	OPENBSD_4_7:1.60.0.2
	OPENBSD_4_7_BASE:1.60
	OPENBSD_4_6:1.60.0.4
	OPENBSD_4_6_BASE:1.60
	OPENBSD_4_5:1.58.0.2
	OPENBSD_4_5_BASE:1.58
	OPENBSD_4_4:1.54.0.2
	OPENBSD_4_4_BASE:1.54
	OPENBSD_4_3:1.53.0.2
	OPENBSD_4_3_BASE:1.53
	OPENBSD_4_2:1.47.0.4
	OPENBSD_4_2_BASE:1.47
	OPENBSD_4_1:1.47.0.2
	OPENBSD_4_1_BASE:1.47
	OPENBSD_4_0:1.35.0.2
	OPENBSD_4_0_BASE:1.35
	OPENBSD_3_9:1.16.0.12
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.16.0.10
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.16.0.6
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.16.0.8
	OPENBSD_3_6_BASE:1.16
	SMP_SYNC_A:1.16
	SMP_SYNC_B:1.16
	OPENBSD_3_5:1.16.0.4
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.16.0.2
	OPENBSD_3_4_BASE:1.16
	UBC_SYNC_A:1.13
	SMP:1.11.0.4
	OPENBSD_3_3:1.11.0.2
	OPENBSD_3_3_BASE:1.11
	UBC_SYNC_B:1.7
	OPENBSD_3_2:1.7.0.2
	OPENBSD_3_2_BASE:1.7
	UBC:1.2.0.2;
locks; strict;
comment	@ * @;


1.68
date	2017.05.25.03.19.39;	author dlg;	state Exp;
branches;
next	1.67;
commitid	gx8rjMxrMcqYnydg;

1.67
date	2016.08.23.03.28.01;	author guenther;	state Exp;
branches;
next	1.66;
commitid	sVHD5kblxhZITIq0;

1.66
date	2014.07.12.18.44.43;	author tedu;	state Exp;
branches;
next	1.65;
commitid	uKVPYMN2MLxdZxzH;

1.65
date	2014.05.10.12.18.38;	author kettenis;	state Exp;
branches;
next	1.64;

1.64
date	2013.05.13.17.46.42;	author kettenis;	state Exp;
branches;
next	1.63;

1.63
date	2011.07.06.23.42.38;	author kettenis;	state Exp;
branches;
next	1.62;

1.62
date	2011.06.26.20.32.36;	author kettenis;	state Exp;
branches;
next	1.61;

1.61
date	2010.12.04.17.06.32;	author miod;	state Exp;
branches;
next	1.60;

1.60
date	2009.03.29.22.52.11;	author kettenis;	state Exp;
branches;
next	1.59;

1.59
date	2009.03.29.21.53.52;	author sthen;	state Exp;
branches;
next	1.58;

1.58
date	2009.01.02.20.01.45;	author kettenis;	state Exp;
branches;
next	1.57;

1.57
date	2008.12.19.21.03.58;	author kettenis;	state Exp;
branches;
next	1.56;

1.56
date	2008.12.16.22.27.34;	author kettenis;	state Exp;
branches;
next	1.55;

1.55
date	2008.08.18.20.29.37;	author brad;	state Exp;
branches;
next	1.54;

1.54
date	2008.07.07.23.22.27;	author kettenis;	state Exp;
branches;
next	1.53;

1.53
date	2008.01.19.11.13.43;	author kettenis;	state Exp;
branches;
next	1.52;

1.52
date	2007.11.13.15.51.59;	author kettenis;	state Exp;
branches;
next	1.51;

1.51
date	2007.10.10.11.31.49;	author krw;	state Exp;
branches;
next	1.50;

1.50
date	2007.10.08.18.30.13;	author krw;	state Exp;
branches;
next	1.49;

1.49
date	2007.09.18.00.46.41;	author krw;	state Exp;
branches;
next	1.48;

1.48
date	2007.08.25.19.25.31;	author kettenis;	state Exp;
branches;
next	1.47;

1.47
date	2007.02.23.22.15.36;	author kettenis;	state Exp;
branches;
next	1.46;

1.46
date	2007.02.23.21.52.01;	author kettenis;	state Exp;
branches;
next	1.45;

1.45
date	2007.01.26.16.53.29;	author tsi;	state Exp;
branches;
next	1.44;

1.44
date	2007.01.20.16.26.53;	author kettenis;	state Exp;
branches;
next	1.43;

1.43
date	2007.01.16.11.10.53;	author kettenis;	state Exp;
branches;
next	1.42;

1.42
date	2007.01.14.16.57.21;	author kettenis;	state Exp;
branches;
next	1.41;

1.41
date	2007.01.14.16.21.22;	author kettenis;	state Exp;
branches;
next	1.40;

1.40
date	2007.01.13.21.04.03;	author kettenis;	state Exp;
branches;
next	1.39;

1.39
date	2007.01.12.21.32.38;	author kettenis;	state Exp;
branches;
next	1.38;

1.38
date	2006.12.24.01.25.01;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2006.12.14.17.36.12;	author kettenis;	state Exp;
branches;
next	1.36;

1.36
date	2006.12.12.19.18.52;	author kettenis;	state Exp;
branches;
next	1.35;

1.35
date	2006.08.27.18.55.57;	author kettenis;	state Exp;
branches;
next	1.34;

1.34
date	2006.07.01.18.19.09;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2006.07.01.16.41.26;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2006.06.30.05.02.11;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2006.06.28.20.09.15;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2006.06.28.20.07.51;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2006.06.28.20.06.32;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2006.06.27.21.22.14;	author kettenis;	state Exp;
branches;
next	1.27;

1.27
date	2006.06.23.16.09.45;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2006.06.02.04.48.34;	author jason;	state Exp;
branches;
next	1.25;

1.25
date	2006.06.01.21.16.29;	author jason;	state Exp;
branches;
next	1.24;

1.24
date	2006.06.01.20.58.19;	author jason;	state Exp;
branches;
next	1.23;

1.23
date	2006.06.01.19.12.45;	author jason;	state Exp;
branches;
next	1.22;

1.22
date	2006.06.01.07.54.10;	author jason;	state Exp;
branches;
next	1.21;

1.21
date	2006.05.28.22.14.16;	author jason;	state Exp;
branches;
next	1.20;

1.20
date	2006.05.28.22.09.57;	author jason;	state Exp;
branches;
next	1.19;

1.19
date	2006.05.28.06.28.08;	author jason;	state Exp;
branches;
next	1.18;

1.18
date	2006.03.19.02.43.38;	author brad;	state Exp;
branches;
next	1.17;

1.17
date	2006.03.13.20.10.49;	author brad;	state Exp;
branches;
next	1.16;

1.16
date	2003.06.24.21.54.39;	author henric;	state Exp;
branches;
next	1.15;

1.15
date	2003.06.11.03.16.12;	author henric;	state Exp;
branches;
next	1.14;

1.14
date	2003.06.03.01.41.42;	author jason;	state Exp;
branches;
next	1.13;

1.13
date	2003.05.11.19.20.36;	author jason;	state Exp;
branches;
next	1.12;

1.12
date	2003.05.11.04.44.22;	author jason;	state Exp;
branches;
next	1.11;

1.11
date	2003.03.06.08.26.08;	author henric;	state Exp;
branches
	1.11.4.1;
next	1.10;

1.10
date	2003.02.22.19.54.43;	author jason;	state Exp;
branches;
next	1.9;

1.9
date	2003.02.17.01.29.20;	author henric;	state Exp;
branches;
next	1.8;

1.8
date	2003.01.13.16.04.38;	author jason;	state Exp;
branches;
next	1.7;

1.7
date	2002.08.01.18.26.35;	author jason;	state Exp;
branches;
next	1.6;

1.6
date	2002.07.24.19.12.00;	author jason;	state Exp;
branches;
next	1.5;

1.5
date	2002.07.24.19.10.54;	author jason;	state Exp;
branches;
next	1.4;

1.4
date	2002.07.18.16.45.08;	author jason;	state Exp;
branches;
next	1.3;

1.3
date	2002.06.12.01.14.42;	author jason;	state Exp;
branches;
next	1.2;

1.2
date	2002.06.08.23.31.30;	author jason;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2002.06.08.21.56.02;	author jason;	state Exp;
branches;
next	;

1.2.2.1
date	2002.06.11.03.38.43;	author art;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2002.10.29.00.28.11;	author art;	state Exp;
branches;
next	1.2.2.3;

1.2.2.3
date	2003.05.19.21.46.57;	author tedu;	state Exp;
branches;
next	;

1.11.4.1
date	2003.05.13.19.41.09;	author ho;	state Exp;
branches;
next	1.11.4.2;

1.11.4.2
date	2003.06.07.11.14.45;	author ho;	state Exp;
branches;
next	1.11.4.3;

1.11.4.3
date	2004.02.19.10.50.00;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.68
log
@tweak sparc64 membars as a step toward making them usable in userland.

specifically, dont rely on magic in ctlreg to implement membars. moving
that to atomic.h would add a lot of pollution to the namespace, so
move to passing the membar options to a single __membar macro.

this tweaks everything that was using the ctlreg backend to either use
an appropriate membar_foo(), or to use __membar() in the MD code.

ok kettenis@@
@
text
@/*	$OpenBSD: schizo.c,v 1.67 2016/08/23 03:28:01 guenther Exp $	*/

/*
 * Copyright (c) 2002 Jason L. Wright (jason@@thought.net)
 * Copyright (c) 2003 Henric Jungheim
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/device.h>
#include <sys/errno.h>
#include <sys/extent.h>
#include <sys/malloc.h>
#include <sys/systm.h>
#include <sys/time.h>
#include <sys/reboot.h>

#define _SPARC_BUS_DMA_PRIVATE
#include <machine/bus.h>
#include <machine/autoconf.h>
#include <machine/psl.h>

#ifdef DDB
#include <machine/db_machdep.h>
#endif

#include <dev/pci/pcivar.h>
#include <dev/pci/pcireg.h>

#include <sparc64/dev/iommureg.h>
#include <sparc64/dev/iommuvar.h>
#include <sparc64/dev/schizoreg.h>
#include <sparc64/dev/schizovar.h>
#include <sparc64/sparc64/cache.h>

#ifdef DEBUG
#define SDB_PROM        0x01
#define SDB_BUSMAP      0x02
#define SDB_INTR        0x04
#define SDB_CONF        0x08
int schizo_debug = ~0;
#define DPRINTF(l, s)   do { if (schizo_debug & l) printf s; } while (0)
#else
#define DPRINTF(l, s)
#endif

extern struct sparc_pci_chipset _sparc_pci_chipset;

int schizo_match(struct device *, void *, void *);
void schizo_attach(struct device *, struct device *, void *);
void schizo_init(struct schizo_softc *, int);
void schizo_init_iommu(struct schizo_softc *, struct schizo_pbm *);
int schizo_print(void *, const char *);

void schizo_set_intr(struct schizo_softc *, struct schizo_pbm *, int,
    int (*handler)(void *), void *, int, char *);
int schizo_ue(void *);
int schizo_ce(void *);
int schizo_safari_error(void *);
int schizo_pci_error(void *);

pci_chipset_tag_t schizo_alloc_chipset(struct schizo_pbm *, int,
    pci_chipset_tag_t);
bus_space_tag_t schizo_alloc_mem_tag(struct schizo_pbm *);
bus_space_tag_t schizo_alloc_io_tag(struct schizo_pbm *);
bus_space_tag_t schizo_alloc_config_tag(struct schizo_pbm *);
bus_space_tag_t schizo_alloc_bus_tag(struct schizo_pbm *, const char *,
    int, int, int);
bus_dma_tag_t schizo_alloc_dma_tag(struct schizo_pbm *);

int schizo_conf_size(pci_chipset_tag_t, pcitag_t);
pcireg_t schizo_conf_read(pci_chipset_tag_t, pcitag_t, int);
void schizo_conf_write(pci_chipset_tag_t, pcitag_t, int, pcireg_t);

int schizo_intr_map(struct pci_attach_args *, pci_intr_handle_t *);
int schizo_bus_map(bus_space_tag_t, bus_space_tag_t, bus_addr_t,
    bus_size_t, int, bus_space_handle_t *);
paddr_t schizo_bus_mmap(bus_space_tag_t, bus_space_tag_t, bus_addr_t, off_t,
    int, int);
bus_addr_t schizo_bus_addr(bus_space_tag_t, bus_space_tag_t,
    bus_space_handle_t);
void *schizo_intr_establish(bus_space_tag_t, bus_space_tag_t, int, int, int,
    int (*)(void *), void *, const char *);

int schizo_dmamap_create(bus_dma_tag_t, bus_dma_tag_t, bus_size_t, int,
    bus_size_t, bus_size_t, int, bus_dmamap_t *);

#ifdef DDB
void schizo_xir(void *, int);
#endif

int
schizo_match(struct device *parent, void *match, void *aux)
{
	struct mainbus_attach_args *ma = aux;
	char *str;

	if (strcmp(ma->ma_name, "pci") != 0)
		return (0);

	str = getpropstring(ma->ma_node, "model");
	if (strcmp(str, "schizo") == 0)
		return (1);

	str = getpropstring(ma->ma_node, "compatible");
	if (strcmp(str, "pci108e,8001") == 0)
		return (1);
	if (strcmp(str, "pci108e,8002") == 0)		/* XMITS */
		return (1);
	if (strcmp(str, "pci108e,a801") == 0)		/* Tomatillo */
		return (1);

	return (0);
}

void
schizo_attach(struct device *parent, struct device *self, void *aux)
{
	struct schizo_softc *sc = (struct schizo_softc *)self;
	struct mainbus_attach_args *ma = aux;
	int busa;
	char *str;

	str = getpropstring(ma->ma_node, "compatible");
	if (strcmp(str, "pci108e,a801") == 0)
		sc->sc_tomatillo = 1;

	sc->sc_node = ma->ma_node;
	sc->sc_dmat = ma->ma_dmatag;
	sc->sc_bust = ma->ma_bustag;
	sc->sc_ctrl = ma->ma_reg[1].ur_paddr - 0x10000UL;
	sc->sc_ign = INTIGN(ma->ma_upaid << INTMAP_IGN_SHIFT);

	if ((ma->ma_reg[0].ur_paddr & 0x00700000) == 0x00600000)
		busa = 1;
	else
		busa = 0;

	if (bus_space_map(sc->sc_bust, sc->sc_ctrl,
	    sizeof(struct schizo_regs), 0, &sc->sc_ctrlh)) {
		printf(": failed to map registers\n");
		return;
	}

	/* enable schizo ecc error interrupts */
	schizo_write(sc, SCZ_ECCCTRL, schizo_read(sc, SCZ_ECCCTRL) |
	    SCZ_ECCCTRL_EE_INTEN | SCZ_ECCCTRL_UE_INTEN |
	    SCZ_ECCCTRL_CE_INTEN);

	schizo_init(sc, busa);
}

void
schizo_init(struct schizo_softc *sc, int busa)
{
	struct schizo_pbm *pbm;
	struct pcibus_attach_args pba;
	int *busranges = NULL, nranges;
	u_int64_t match, reg;

	pbm = malloc(sizeof(*pbm), M_DEVBUF, M_NOWAIT | M_ZERO);
	if (pbm == NULL)
		panic("schizo: can't alloc schizo pbm");

	pbm->sp_sc = sc;
	pbm->sp_bus_a = busa;
	pbm->sp_regt = sc->sc_bust;

	if (getprop(sc->sc_node, "ranges", sizeof(struct schizo_range),
	    &pbm->sp_nrange, (void **)&pbm->sp_range))
		panic("schizo: can't get ranges");

	if (getprop(sc->sc_node, "bus-range", sizeof(int), &nranges,
	    (void **)&busranges))
		panic("schizo: can't get bus-range");

	printf(": \"%s\", version %d, ign %x, bus %c %d to %d\n",
	    sc->sc_tomatillo ? "Tomatillo" : "Schizo",
	    getpropint(sc->sc_node, "version#", 0), sc->sc_ign,
	    busa ? 'A' : 'B', busranges[0], busranges[1]);

	if (bus_space_subregion(pbm->sp_regt, sc->sc_ctrlh,
	    busa ? offsetof(struct schizo_regs, pbm_a) :
	    offsetof(struct schizo_regs, pbm_b),
	    sizeof(struct schizo_pbm_regs),
	    &pbm->sp_regh)) {
		panic("schizo: unable to create PBM handle");
	}

	printf("%s: ", sc->sc_dv.dv_xname);
	schizo_init_iommu(sc, pbm);

	match = schizo_read(sc, busa ? SCZ_PCIA_IO_MATCH : SCZ_PCIB_IO_MATCH);
	pbm->sp_confpaddr = match & ~0x8000000000000000UL;

	pbm->sp_memt = schizo_alloc_mem_tag(pbm);
	pbm->sp_iot = schizo_alloc_io_tag(pbm);
	pbm->sp_cfgt = schizo_alloc_config_tag(pbm);
	pbm->sp_dmat = schizo_alloc_dma_tag(pbm);

	if (bus_space_map(pbm->sp_cfgt, 0, 0x1000000, 0, &pbm->sp_cfgh))
		panic("schizo: can't map config space");

	pbm->sp_pc = schizo_alloc_chipset(pbm, sc->sc_node,
	    &_sparc_pci_chipset);

	pbm->sp_pc->bustag = pbm->sp_cfgt;
	pbm->sp_pc->bushandle = pbm->sp_cfgh;

	bzero(&pba, sizeof(pba));
	pba.pba_busname = "pci";
	pba.pba_domain = pci_ndomains++;
	pba.pba_bus = busranges[0];
	pba.pba_pc = pbm->sp_pc;
#if 0
	pba.pba_flags = pbm->sp_flags;
#endif
	pba.pba_dmat = pbm->sp_dmat;
	pba.pba_memt = pbm->sp_memt;
	pba.pba_iot = pbm->sp_iot;
	pba.pba_pc->conf_size = schizo_conf_size;
	pba.pba_pc->conf_read = schizo_conf_read;
	pba.pba_pc->conf_write = schizo_conf_write;
	pba.pba_pc->intr_map = schizo_intr_map;

	free(busranges, M_DEVBUF, 0);

	schizo_pbm_write(pbm, SCZ_PCI_INTR_RETRY, 5);

	/* clear out the bus errors */
	schizo_pbm_write(pbm, SCZ_PCI_CTRL, schizo_pbm_read(pbm, SCZ_PCI_CTRL));
	schizo_pbm_write(pbm, SCZ_PCI_AFSR, schizo_pbm_read(pbm, SCZ_PCI_AFSR));
	schizo_cfg_write(pbm, PCI_COMMAND_STATUS_REG,
	    schizo_cfg_read(pbm, PCI_COMMAND_STATUS_REG));

	reg = schizo_pbm_read(pbm, SCZ_PCI_CTRL);
	/* enable/disable error interrupts and arbiter */
	reg |= SCZ_PCICTRL_EEN | SCZ_PCICTRL_MMU_INT | SCZ_PCICTRL_ARB;
	reg &= ~SCZ_PCICTRL_SBH_INT;
	schizo_pbm_write(pbm, SCZ_PCI_CTRL, reg);

	reg = schizo_pbm_read(pbm, SCZ_PCI_DIAG);
	reg &= ~(SCZ_PCIDIAG_D_RTRYARB | SCZ_PCIDIAG_D_RETRY |
	    SCZ_PCIDIAG_D_INTSYNC);
	schizo_pbm_write(pbm, SCZ_PCI_DIAG, reg);

	if (busa)
		schizo_set_intr(sc, pbm, PIL_HIGH, schizo_pci_error,
		   pbm, SCZ_PCIERR_A_INO, "pci_a");
	else
		schizo_set_intr(sc, pbm, PIL_HIGH, schizo_pci_error,
		   pbm, SCZ_PCIERR_B_INO, "pci_b");

	/* double mapped */
	schizo_set_intr(sc, pbm, PIL_HIGH, schizo_ue, sc, SCZ_UE_INO,
	    "ue");
	schizo_set_intr(sc, pbm, PIL_HIGH, schizo_ce, sc, SCZ_CE_INO,
	    "ce");
	schizo_set_intr(sc, pbm, PIL_HIGH, schizo_safari_error, sc,
	    SCZ_SERR_INO, "safari");

#ifdef DDB
	/* 
	 * Only a master Tomatillo (the one with JPID[0:2] = 6)
	 * can/should generate XIR.
	 */
	if (sc->sc_tomatillo &&
	    ((schizo_read(sc, SCZ_CONTROL_STATUS) >> 20) & 0x7) == 6)
		db_register_xir(schizo_xir, sc);
#endif

	config_found(&sc->sc_dv, &pba, schizo_print);
}

int
schizo_ue(void *vsc)
{
	struct schizo_softc *sc = vsc;

	panic("%s: uncorrectable error", sc->sc_dv.dv_xname);
	return (1);
}

int
schizo_ce(void *vsc)
{
	struct schizo_softc *sc = vsc;

	panic("%s: correctable error", sc->sc_dv.dv_xname);
	return (1);
}

int
schizo_pci_error(void *vpbm)
{
	struct schizo_pbm *sp = vpbm;
	struct schizo_softc *sc = sp->sp_sc;
	u_int64_t afsr, afar, ctrl;
	u_int32_t csr;

	afsr = schizo_pbm_read(sp, SCZ_PCI_AFSR);
	afar = schizo_pbm_read(sp, SCZ_PCI_AFAR);
	ctrl = schizo_pbm_read(sp, SCZ_PCI_CTRL);
	csr = schizo_cfg_read(sp, PCI_COMMAND_STATUS_REG);

	printf("%s: pci bus %c error\n", sc->sc_dv.dv_xname,
	    sp->sp_bus_a ? 'A' : 'B');

	printf("PCIAFSR=%llb\n", afsr, SCZ_PCIAFSR_BITS);
	printf("PCIAFAR=%llx\n", afar);
	printf("PCICTRL=%llb\n", ctrl, SCZ_PCICTRL_BITS);
	printf("PCICSR=%b\n", csr, PCI_COMMAND_STATUS_BITS);

	if (ctrl & SCZ_PCICTRL_MMU_ERR) {
		u_int64_t ctrl, tfar;

		ctrl = schizo_pbm_read(sp, SCZ_PCI_IOMMU_CTRL);
		printf("IOMMUCTRL=%llx\n", ctrl);

		if ((ctrl & TOM_IOMMU_ERR) == 0)
			goto clear_error;

		if (sc->sc_tomatillo) {
			tfar = schizo_pbm_read(sp, TOM_PCI_IOMMU_TFAR);
			printf("IOMMUTFAR=%llx\n", tfar);
		}

		/* These are non-fatal if target abort was signalled. */
		if ((ctrl & TOM_IOMMU_ERR_MASK) == TOM_IOMMU_INV_ERR ||
		    ctrl & TOM_IOMMU_ILLTSBTBW_ERR ||
		    ctrl & TOM_IOMMU_BADVA_ERR) {
			if (csr & PCI_STATUS_TARGET_TARGET_ABORT) {
				schizo_pbm_write(sp, SCZ_PCI_IOMMU_CTRL, ctrl);
				goto clear_error;
			}
		}
	}

	panic("%s: fatal", sc->sc_dv.dv_xname);

 clear_error:
	schizo_cfg_write(sp, PCI_COMMAND_STATUS_REG, csr);
	schizo_pbm_write(sp, SCZ_PCI_CTRL, ctrl);
	schizo_pbm_write(sp, SCZ_PCI_AFSR, afsr);
	return (1);
}

int
schizo_safari_error(void *vsc)
{
	struct schizo_softc *sc = vsc;

	printf("%s: safari error\n", sc->sc_dv.dv_xname);

	printf("ERRLOG=%llx\n", schizo_read(sc, SCZ_SAFARI_ERRLOG));
	printf("UE_AFSR=%llx\n", schizo_read(sc, SCZ_UE_AFSR));
	printf("UE_AFAR=%llx\n", schizo_read(sc, SCZ_UE_AFAR));
	printf("CE_AFSR=%llx\n", schizo_read(sc, SCZ_CE_AFSR));
	printf("CE_AFAR=%llx\n", schizo_read(sc, SCZ_CE_AFAR));

	panic("%s: fatal", sc->sc_dv.dv_xname);
	return (1);
}

void
schizo_init_iommu(struct schizo_softc *sc, struct schizo_pbm *pbm)
{
	struct iommu_state *is = &pbm->sp_is;
	int *vdma = NULL, nitem, tsbsize = 7;
	u_int32_t iobase = -1;
	vaddr_t va;
	char *name;

	va = (vaddr_t)pbm->sp_flush[0x40];

	is->is_bustag = pbm->sp_regt;

	if (bus_space_subregion(is->is_bustag, pbm->sp_regh,
	    offsetof(struct schizo_pbm_regs, iommu),
	    sizeof(struct iommureg), &is->is_iommu)) {
		panic("schizo: unable to create iommu handle");
	} 

	is->is_sb[0] = &pbm->sp_sb;
	is->is_sb[0]->sb_bustag = is->is_bustag;
	is->is_sb[0]->sb_flush = (void *)(va & ~0x3f);

	if (bus_space_subregion(is->is_bustag, pbm->sp_regh,
	    offsetof(struct schizo_pbm_regs, strbuf),
	    sizeof(struct iommu_strbuf), &is->is_sb[0]->sb_sb)) {
		panic("schizo: unable to create streaming buffer handle");
		is->is_sb[0]->sb_flush = NULL;
	} 

#if 1
	/* XXX disable the streaming buffers for now */
	bus_space_write_8(is->is_bustag, is->is_sb[0]->sb_sb,
	    STRBUFREG(strbuf_ctl),
	    bus_space_read_8(is->is_bustag, is->is_sb[0]->sb_sb,
		STRBUFREG(strbuf_ctl)) & ~STRBUF_EN);
	is->is_sb[0]->sb_flush = NULL;
#endif

	name = (char *)malloc(32, M_DEVBUF, M_NOWAIT);
	if (name == NULL)
		panic("couldn't malloc iommu name");
	snprintf(name, 32, "%s dvma", sc->sc_dv.dv_xname);

	/*
	 * Separate the men from the boys.  If the `virtual-dma'
	 * property exists, use it.
	 */
	if (!getprop(sc->sc_node, "virtual-dma", sizeof(vdma), &nitem, 
	    (void **)&vdma)) {
		/* Damn.  Gotta use these values. */
		iobase = vdma[0];
#define	TSBCASE(x)	case 1 << ((x) + 23): tsbsize = (x); break
		switch (vdma[1]) { 
			TSBCASE(1); TSBCASE(2); TSBCASE(3);
			TSBCASE(4); TSBCASE(5); TSBCASE(6);
		default: 
			printf("bogus tsb size %x, using 7\n", vdma[1]);
			TSBCASE(7);
		}
#undef TSBCASE
		DPRINTF(SDB_BUSMAP, ("schizo_iommu_init: iobase=0x%x\n", iobase));
		free(vdma, M_DEVBUF, 0);
	} else {
		DPRINTF(SDB_BUSMAP, ("schizo_iommu_init: getprop failed, "
		    "using iobase=0x%x, tsbsize=%d\n", iobase, tsbsize));
	}

	iommu_init(name, is, tsbsize, iobase);
}

int
schizo_print(void *aux, const char *p)
{
	if (p == NULL)
		return (UNCONF);
	return (QUIET);
}

int
schizo_conf_size(pci_chipset_tag_t pc, pcitag_t tag)
{
	return PCI_CONFIG_SPACE_SIZE;
}

pcireg_t
schizo_conf_read(pci_chipset_tag_t pc, pcitag_t tag, int reg)
{
	struct cpu_info *ci = curcpu();
	pcireg_t val;
	int s;

	s = splhigh();
	__membar("#Sync");
	ci->ci_pci_probe = 1;
	val = bus_space_read_4(pc->bustag, pc->bushandle,
	    PCITAG_OFFSET(tag) + reg);
	__membar("#Sync");
	if (ci->ci_pci_fault)
		val = 0xffffffff;
	ci->ci_pci_probe = ci->ci_pci_fault = 0;
	splx(s);

	return (val);
}

void
schizo_conf_write(pci_chipset_tag_t pc, pcitag_t tag, int reg, pcireg_t data)
{
        bus_space_write_4(pc->bustag, pc->bushandle,
	    PCITAG_OFFSET(tag) + reg, data);
}

/*
 * Bus-specific interrupt mapping
 */
int
schizo_intr_map(struct pci_attach_args *pa, pci_intr_handle_t *ihp)
{
	struct schizo_pbm *sp = pa->pa_pc->cookie;
	struct schizo_softc *sc = sp->sp_sc;
	u_int dev;

	if (*ihp != (pci_intr_handle_t)-1) {
		*ihp |= sc->sc_ign;
		return (0);
	}

	/*
	 * We didn't find a PROM mapping for this interrupt.  Try to
	 * construct one ourselves based on the swizzled interrupt pin
	 * and the interrupt mapping for PCI slots documented in the
	 * UltraSPARC-IIi User's Manual.
	 */

	if (pa->pa_intrpin == 0)
		return (-1);

	/*
	 * This deserves some documentation.  Should anyone
	 * have anything official looking, please speak up.
	 */
	dev = pa->pa_device - 1;

	*ihp = (pa->pa_intrpin - 1) & INTMAP_PCIINT;
	*ihp |= (dev << 2) & INTMAP_PCISLOT;
	*ihp |= sc->sc_ign;

	return (0);
}

void
schizo_set_intr(struct schizo_softc *sc, struct schizo_pbm *pbm, int ipl,
    int (*handler)(void *), void *arg, int ino, char *what)
{
	struct intrhand *ih;
	volatile u_int64_t *map, *clr;
	struct schizo_pbm_regs *pbmreg;
	char *name;
	int nlen;

	pbmreg = bus_space_vaddr(pbm->sp_regt, pbm->sp_regh);
	map = &pbmreg->imap[ino];
	clr = &pbmreg->iclr[ino];
	ino |= sc->sc_ign;

	nlen = strlen(sc->sc_dv.dv_xname) + 1 + strlen(what) + 1;
	name = malloc(nlen, M_DEVBUF, M_WAITOK);
	snprintf(name, nlen, "%s:%s", sc->sc_dv.dv_xname, what);

	ih = bus_intr_allocate(pbm->sp_regt, handler, arg, ino, ipl,
	    map, clr, name);
	if (ih == NULL) {
		printf("set_intr failed...\n");
		free(name, M_DEVBUF, 0);
		return;
	}

	intr_establish(ih->ih_pil, ih);
}

bus_space_tag_t
schizo_alloc_mem_tag(struct schizo_pbm *sp)
{
	return (schizo_alloc_bus_tag(sp, "mem",
	    0x02,       /* 32-bit mem space (where's the #define???) */
	    ASI_PRIMARY, ASI_PRIMARY_LITTLE));
}

bus_space_tag_t
schizo_alloc_io_tag(struct schizo_pbm *sp)
{
	return (schizo_alloc_bus_tag(sp, "io",
	    0x01,       /* IO space (where's the #define???) */
	    ASI_PHYS_NON_CACHED_LITTLE, ASI_PHYS_NON_CACHED));
}

bus_space_tag_t
schizo_alloc_config_tag(struct schizo_pbm *sp)
{
	return (schizo_alloc_bus_tag(sp, "cfg",
	    0x00,       /* Config space (where's the #define???) */
	    ASI_PHYS_NON_CACHED_LITTLE, ASI_PHYS_NON_CACHED));
}

bus_space_tag_t
schizo_alloc_bus_tag(struct schizo_pbm *pbm, const char *name, int ss,
    int asi, int sasi)
{
	struct schizo_softc *sc = pbm->sp_sc;
	struct sparc_bus_space_tag *bt;

	bt = malloc(sizeof(*bt), M_DEVBUF, M_NOWAIT | M_ZERO);
	if (bt == NULL)
		panic("schizo: could not allocate bus tag");

	snprintf(bt->name, sizeof(bt->name), "%s-pbm_%s(%d/%2.2x)",
	    sc->sc_dv.dv_xname, name, ss, asi);

	bt->cookie = pbm;
	bt->parent = sc->sc_bust;
	bt->default_type = ss;
	bt->asi = asi;
	bt->sasi = sasi;
	bt->sparc_bus_map = schizo_bus_map;
	bt->sparc_bus_mmap = schizo_bus_mmap;
	bt->sparc_bus_addr = schizo_bus_addr;
	bt->sparc_intr_establish = schizo_intr_establish;
	return (bt);
}

bus_dma_tag_t
schizo_alloc_dma_tag(struct schizo_pbm *pbm)
{
	struct schizo_softc *sc = pbm->sp_sc;
	bus_dma_tag_t dt, pdt = sc->sc_dmat;

	dt = malloc(sizeof(*dt), M_DEVBUF, M_NOWAIT | M_ZERO);
	if (dt == NULL)
		panic("schizo: could not alloc dma tag");

	dt->_cookie = pbm;
	dt->_parent = pdt;
	dt->_dmamap_create	= schizo_dmamap_create;
	dt->_dmamap_destroy	= iommu_dvmamap_destroy;
	dt->_dmamap_load	= iommu_dvmamap_load;
	dt->_dmamap_load_raw	= iommu_dvmamap_load_raw;
	dt->_dmamap_unload	= iommu_dvmamap_unload;
	dt->_dmamap_sync	= iommu_dvmamap_sync;
	dt->_dmamem_alloc	= iommu_dvmamem_alloc;
	dt->_dmamem_free	= iommu_dvmamem_free;
	return (dt);
}

pci_chipset_tag_t
schizo_alloc_chipset(struct schizo_pbm *pbm, int node, pci_chipset_tag_t pc)
{
	pci_chipset_tag_t npc;

	npc = malloc(sizeof *npc, M_DEVBUF, M_NOWAIT);
	if (npc == NULL)
		panic("schizo: could not allocate pci_chipset_tag_t");
	memcpy(npc, pc, sizeof *pc);
	npc->cookie = pbm;
	npc->rootnode = node;
	return (npc);
}

int
schizo_dmamap_create(bus_dma_tag_t t, bus_dma_tag_t t0, bus_size_t size,
    int nsegments, bus_size_t maxsegsz, bus_size_t boundary, int flags,
    bus_dmamap_t *dmamp)
{
	struct schizo_pbm *sp = t->_cookie;

	return (iommu_dvmamap_create(t, t0, &sp->sp_sb, size, nsegments,
	    maxsegsz, boundary, flags, dmamp));
}

int
schizo_bus_map(bus_space_tag_t t, bus_space_tag_t t0, bus_addr_t offset,
    bus_size_t size, int flags, bus_space_handle_t *hp)
{
	struct schizo_pbm *pbm = t->cookie;
	int i, ss;

	DPRINTF(SDB_BUSMAP,("schizo_bus_map: type %d off %llx sz %llx flags %d",
	    t->default_type,
	    (unsigned long long)offset,
	    (unsigned long long)size,
	    flags));

	ss = t->default_type;
	DPRINTF(SDB_BUSMAP, (" cspace %d", ss));

	if (t->parent == 0 || t->parent->sparc_bus_map == 0) {
		printf("\nschizo_bus_map: invalid parent");
		return (EINVAL);
	}

	if (flags & BUS_SPACE_MAP_PROMADDRESS) {
		return ((*t->parent->sparc_bus_map)
		    (t, t0, offset, size, flags, hp));
	}

	for (i = 0; i < pbm->sp_nrange; i++) {
		bus_addr_t paddr;

		if (((pbm->sp_range[i].cspace >> 24) & 0x03) != ss)
			continue;

		paddr = pbm->sp_range[i].phys_lo + offset;
		paddr |= ((bus_addr_t)pbm->sp_range[i].phys_hi) << 32;
		return ((*t->parent->sparc_bus_map)
		    (t, t0, paddr, size, flags, hp));
	}

	return (EINVAL);
}

paddr_t
schizo_bus_mmap(bus_space_tag_t t, bus_space_tag_t t0, bus_addr_t paddr,
    off_t off, int prot, int flags)
{
	bus_addr_t offset = paddr;
	struct schizo_pbm *pbm = t->cookie;
	int i, ss;

	ss = t->default_type;

	DPRINTF(SDB_BUSMAP, ("schizo_bus_mmap: prot %d flags %d pa %llx\n",
	    prot, flags, (unsigned long long)paddr));

	if (t->parent == 0 || t->parent->sparc_bus_mmap == 0) {
		printf("\nschizo_bus_mmap: invalid parent");
		return (-1);
	}

	for (i = 0; i < pbm->sp_nrange; i++) {
		bus_addr_t paddr;

		if (((pbm->sp_range[i].cspace >> 24) & 0x03) != ss)
			continue;

		paddr = pbm->sp_range[i].phys_lo + offset;
		paddr |= ((bus_addr_t)pbm->sp_range[i].phys_hi) << 32;
		return ((*t->parent->sparc_bus_mmap)
		    (t, t0, paddr, off, prot, flags));
	}

	return (-1);
}

bus_addr_t
schizo_bus_addr(bus_space_tag_t t, bus_space_tag_t t0, bus_space_handle_t h)
{
	struct schizo_pbm *pbm = t->cookie;
	bus_addr_t addr;
	int i, ss;

	ss = t->default_type;

	if (t->parent == 0 || t->parent->sparc_bus_addr == 0) {
		printf("\nschizo_bus_addr: invalid parent");
		return (-1);
	}

	t = t->parent;

	addr = ((*t->sparc_bus_addr)(t, t0, h));
	if (addr == -1)
		return (-1);

	for (i = 0; i < pbm->sp_nrange; i++) {
		if (((pbm->sp_range[i].cspace >> 24) & 0x03) != ss)
			continue;

		return (BUS_ADDR_PADDR(addr) - pbm->sp_range[i].phys_lo);
	}

	return (-1);
}

void *
schizo_intr_establish(bus_space_tag_t t, bus_space_tag_t t0, int ihandle,
    int level, int flags, int (*handler)(void *), void *arg, const char *what)
{
	struct schizo_pbm *pbm = t->cookie;
	struct intrhand *ih = NULL;
	volatile u_int64_t *intrmapptr = NULL, *intrclrptr = NULL;
	int ino;
	long vec = INTVEC(ihandle);

	vec = INTVEC(ihandle);
	ino = INTINO(vec);

	if (level == IPL_NONE)
		level = INTLEV(vec);
	if (level == IPL_NONE) {
		printf(": no IPL, setting IPL 2.\n");
		level = 2;
	}

	if ((flags & BUS_INTR_ESTABLISH_SOFTINTR) == 0) {
		struct schizo_pbm_regs *pbmreg;

		pbmreg = bus_space_vaddr(pbm->sp_regt, pbm->sp_regh);
		intrmapptr = &pbmreg->imap[ino];
		intrclrptr = &pbmreg->iclr[ino];
		if (INTIGN(vec) == 0)
			ino |= (*intrmapptr) & INTMAP_IGN;
		else
			ino |= vec & INTMAP_IGN;
	}

	ih = bus_intr_allocate(t0, handler, arg, ino, level, intrmapptr,
	    intrclrptr, what);
	if (ih == NULL)
		return (NULL);

	if (flags & BUS_INTR_ESTABLISH_MPSAFE)
		ih->ih_mpsafe = 1;

	intr_establish(ih->ih_pil, ih);

	if (intrmapptr != NULL) {
		u_int64_t intrmap;

		intrmap = *intrmapptr;
		intrmap |= INTMAP_V;
		*intrmapptr = intrmap;
		intrmap = *intrmapptr;
		ih->ih_number |= intrmap & INTMAP_INR;
	}

	return (ih);
}

#ifdef DDB
void
schizo_xir(void *arg, int cpu)
{
	struct schizo_softc *sc = arg;

	schizo_write(sc, TOM_RESET_GEN, TOM_RESET_GEN_XIR);
}
#endif

const struct cfattach schizo_ca = {
	sizeof(struct schizo_softc), schizo_match, schizo_attach
};

struct cfdriver schizo_cd = {
	NULL, "schizo", DV_DULL
};
@


1.67
log
@Convert %q to %ll in format strings

ok natano@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: schizo.c,v 1.66 2014/07/12 18:44:43 tedu Exp $	*/
d479 1
a479 1
	membar(Sync);
d483 1
a483 1
	membar(Sync);
@


1.66
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: schizo.c,v 1.65 2014/05/10 12:18:38 kettenis Exp $	*/
d672 1
a672 1
	DPRINTF(SDB_BUSMAP, ("schizo_bus_map: type %d off %qx sz %qx flags %d",
d716 1
a716 1
	DPRINTF(SDB_BUSMAP, ("schizo_bus_mmap: prot %d flags %d pa %qx\n",
@


1.65
log
@Schizo registers are all 64-bit, so use u_int64_t to store them and print them
using %llx/%llb.
@
text
@d1 1
a1 1
/*	$OpenBSD: schizo.c,v 1.64 2013/05/13 17:46:42 kettenis Exp $	*/
d247 1
a247 1
	free(busranges, M_DEVBUF);
d448 1
a448 1
		free(vdma, M_DEVBUF);
d560 1
a560 1
		free(name, M_DEVBUF);
@


1.64
log
@Implement support for running interrupt handlers without taking the kernel
lock, by adding a new BUS_INTR_ESTABLISH_MPSAFE flag for use with the
(sparc64-specific) bus_intr_establish(9) interface.  Add support for this
flag to schizo(4); other bus drivers will ignore it for now.  While there,
remove the BUS_INTR_ESTABLISH_FASTTRAP flag which serves no purpose.
@
text
@d1 1
a1 1
/*	$OpenBSD: schizo.c,v 1.63 2011/07/06 23:42:38 kettenis Exp $	*/
d330 3
a332 3
	printf("PCIAFSR=%lb\n", afsr, SCZ_PCIAFSR_BITS);
	printf("PCIAFAR=%lx\n", afar);
	printf("PCICTRL=%lb\n", ctrl, SCZ_PCICTRL_BITS);
d336 1
a336 1
		u_int32_t ctrl, tfar;
d339 1
a339 1
		printf("IOMMUCTRL=%lx\n", ctrl);
d346 1
a346 1
			printf("IOMMUTFAR=%lx\n", tfar);
d376 5
a380 5
	printf("ERRLOG=%lx\n", schizo_read(sc, SCZ_SAFARI_ERRLOG));
	printf("UE_AFSR=%lx\n", schizo_read(sc, SCZ_UE_AFSR));
	printf("UE_AFAR=%lx\n", schizo_read(sc, SCZ_UE_AFAR));
	printf("CE_AFSR=%lx\n", schizo_read(sc, SCZ_CE_AFSR));
	printf("CE_AFAR=%lx\n", schizo_read(sc, SCZ_CE_AFAR));
@


1.63
log
@Handle pci_conf_read() faults on reading non-existent registers that result
in master aborts.  Return 0xffffffff to emulate what happens on non-perfect
architectures in that case.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: schizo.c,v 1.62 2011/06/26 20:32:36 kettenis Exp $	*/
d805 3
@


1.62
log
@Fix some inconsistencies in how we build 64-bit addresses from OF properties.
@
text
@d1 1
a1 1
/*	$OpenBSD: schizo.c,v 1.61 2010/12/04 17:06:32 miod Exp $	*/
d474 16
a489 2
	return (bus_space_read_4(pc->bustag, pc->bushandle,
	    PCITAG_OFFSET(tag) + reg));
@


1.61
log
@Introduce a new pci routine, pci_conf_size(), which returns the size of a
given pcitag_t configuration address space. Currently, all pci controllers
will return the usual 0x100 bytes of PCI configuration space, but this will
eventually change on PCIe-capable controlers.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: schizo.c,v 1.60 2009/03/29 22:52:11 kettenis Exp $	*/
d717 1
a717 1
		paddr |= ((bus_addr_t)pbm->sp_range[i].phys_hi<<32);
@


1.60
log
@bzero pci attach args

ok deraadt@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: schizo.c,v 1.59 2009/03/29 21:53:52 sthen Exp $	*/
d92 1
d242 1
d463 6
@


1.59
log
@make various strings ("can't map mem space" and similar) more consistent
between instances, saving space in the kernel. feedback from many (some
incorporated, some left for future work).

ok deraadt, kettenis, "why not" miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: schizo.c,v 1.58 2009/01/02 20:01:45 kettenis Exp $	*/
d230 1
a233 1
	pba.pba_bridgetag = NULL;
@


1.58
log
@Make IOMMU code use the generic _bus_dmamem_map() and _bus_dmamem_unmap().
@
text
@d1 1
a1 1
/*	$OpenBSD: schizo.c,v 1.57 2008/12/19 21:03:58 kettenis Exp $	*/
d222 1
a222 1
		panic("schizo: could not map config space");
@


1.57
log
@Add missing #ifdef DDB around prototyupe.
@
text
@d1 1
a1 1
/*	$OpenBSD: schizo.c,v 1.56 2008/12/16 22:27:34 kettenis Exp $	*/
a614 2
	dt->_dmamem_map		= iommu_dvmamem_map;
	dt->_dmamem_unmap	= iommu_dvmamem_unmap;
@


1.56
log
@Make the "machine xir" ddb command work on machines with Tomatillo
schizo(4) variants.
@
text
@d1 1
a1 1
/*	$OpenBSD: schizo.c,v 1.55 2008/08/18 20:29:37 brad Exp $	*/
d108 1
d110 1
@


1.55
log
@Add sparc_bus_addr function for schizo to allow CardBus to work.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: schizo.c,v 1.54 2008/07/07 23:22:27 kettenis Exp $	*/
d44 4
d108 2
d279 10
d798 10
@


1.54
log
@Match on XMITS (which is a PCI-X Schizo variant found on Sun Fire
E2900/E4900/E6900/E20K/E25K systems).  There's a fairly good chance it'll
just work.
@
text
@d1 1
a1 1
/*	$OpenBSD: schizo.c,v 1.53 2008/01/19 11:13:43 kettenis Exp $	*/
d96 2
d572 1
d696 30
@


1.53
log
@Make host bridges provide their own implementation of pci_conf_read() and
pci_conf_write() and give pyro(4) an implementation suitable for PCIe.  For
psycho(4) and schizo(4), go back to the origional implementation.  This gets
rid of the 'tagshift' member of pci_chipset_tag_t, and clears the way for
sun4v.
@
text
@d1 1
a1 1
/*	$OpenBSD: schizo.c,v 1.52 2007/11/13 15:51:59 kettenis Exp $	*/
d117 2
@


1.52
log
@Fix printf format string.
@
text
@d1 1
a1 1
/*	$OpenBSD: schizo.c,v 1.51 2007/10/10 11:31:49 krw Exp $	*/
d88 3
d229 2
d439 14
@


1.51
log
@malloc+bzero -> malloc+M_ZERO. Use 'malloc(sizeof(*p) ...' idiom.

This completes my bzero/memset(,0,) -> M_ZERO sweep of the tree.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: schizo.c,v 1.50 2007/10/08 18:30:13 krw Exp $	*/
d304 1
a304 1
	printf("PCICSR=%lb\n", csr, PCI_COMMAND_STATUS_BITS);
@


1.50
log
@A few trailing bzero/memset -> M_ZERO occurrences, cast removal and
size(*p) usage. This should be the last of the simple malloc()
changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: schizo.c,v 1.49 2007/09/18 00:46:41 krw Exp $	*/
d559 1
a559 2
	dt = (bus_dma_tag_t)malloc(sizeof(struct sparc_bus_dma_tag),
	    M_DEVBUF, M_NOWAIT);
a562 1
	bzero(dt, sizeof(*dt));
@


1.49
log
@Only the most obvious bzero() -> M_ZERO changes. No cast changes, no
MALLOC/FREE, etc. Just adding M_ZERO to malloc() and deleting an
immediately adjacent bzero().
@
text
@d1 1
a1 1
/*	$OpenBSD: schizo.c,v 1.48 2007/08/25 19:25:31 kettenis Exp $	*/
d166 1
a166 1
	pbm = (struct schizo_pbm *)malloc(sizeof(*pbm), M_DEVBUF, M_NOWAIT);
a168 1
	bzero(pbm, sizeof(*pbm));
@


1.48
log
@Print a bit more information in the safari interrupt handler.  Get rid of
function names starting with an underscore while I'm there.
@
text
@d1 1
a1 1
/*	$OpenBSD: schizo.c,v 1.47 2007/02/23 22:15:36 kettenis Exp $	*/
d536 1
a536 1
	bt = malloc(sizeof(*bt), M_DEVBUF, M_NOWAIT);
a539 1
	bzero(bt, sizeof *bt);
@


1.47
log
@Print safari error log register if we get a safari interrupt.
@
text
@d1 1
a1 1
/*	$OpenBSD: schizo.c,v 1.46 2007/02/23 21:52:01 kettenis Exp $	*/
d84 1
a84 1
bus_space_tag_t _schizo_alloc_bus_tag(struct schizo_pbm *, const char *,
a87 1
paddr_t schizo_bus_mmap(bus_space_tag_t, bus_addr_t, off_t, int, int);
d89 1
a89 1
int _schizo_bus_map(bus_space_tag_t, bus_space_tag_t, bus_addr_t,
d91 3
a93 1
void *_schizo_intr_establish(bus_space_tag_t, bus_space_tag_t, int, int, int,
a94 1
paddr_t _schizo_bus_mmap(bus_space_tag_t, bus_space_tag_t, bus_addr_t, off_t, int, int);
d349 4
d508 1
a508 1
	return (_schizo_alloc_bus_tag(sp, "mem",
d516 1
a516 1
	return (_schizo_alloc_bus_tag(sp, "io",
d524 1
a524 1
	return (_schizo_alloc_bus_tag(sp, "cfg",
d530 1
a530 1
_schizo_alloc_bus_tag(struct schizo_pbm *pbm, const char *name, int ss,
d549 3
a551 3
	bt->sparc_bus_map = _schizo_bus_map;
	bt->sparc_bus_mmap = _schizo_bus_mmap;
	bt->sparc_intr_establish = _schizo_intr_establish;
d589 1
a589 1
		panic("could not allocate pci_chipset_tag_t");
d591 1
a591 1
	npc->cookie = pbm; 
d608 1
a608 1
_schizo_bus_map(bus_space_tag_t t, bus_space_tag_t t0, bus_addr_t offset,
d614 1
a614 1
	DPRINTF(SDB_BUSMAP, ("_schizo_bus_map: type %d off %qx sz %qx flags %d",
d624 1
a624 1
		printf("\n_schizo_bus_map: invalid parent");
d649 1
a649 1
_schizo_bus_mmap(bus_space_tag_t t, bus_space_tag_t t0, bus_addr_t paddr,
d658 1
a658 1
	DPRINTF(SDB_BUSMAP, ("_schizo_bus_mmap: prot %d flags %d pa %qx\n",
d662 1
a662 1
		printf("\n_schizo_bus_mmap: invalid parent");
d682 1
a682 1
_schizo_intr_establish(bus_space_tag_t t, bus_space_tag_t t0, int ihandle,
@


1.46
log
@Establish pci error interrupt after we're done fiddling with schizo's registers
instead of when we're halfway through.
@
text
@d1 1
a1 1
/*	$OpenBSD: schizo.c,v 1.45 2007/01/26 16:53:29 tsi Exp $	*/
d346 5
a350 1
	panic("%s: safari error", sc->sc_dv.dv_xname);
@


1.45
log
@Deal with zero wraparound in DVMA range checks;
Fix default DVMA range for Schizo's with no "virtual-dma" property;
Add TSB size indicator to Schizo & Psycho debugging messages.

ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: schizo.c,v 1.44 2007/01/20 16:26:53 kettenis Exp $	*/
a238 7
	if (busa)
		schizo_set_intr(sc, pbm, PIL_HIGH, schizo_pci_error,
		   pbm, SCZ_PCIERR_A_INO, "pci_a");
	else
		schizo_set_intr(sc, pbm, PIL_HIGH, schizo_pci_error,
		   pbm, SCZ_PCIERR_B_INO, "pci_b");

d249 7
@


1.44
log
@Do not panic on non-fatal iommu errors.
@
text
@d1 1
a1 1
/*	$OpenBSD: schizo.c,v 1.43 2007/01/16 11:10:53 kettenis Exp $	*/
d354 1
a354 1
	int *vdma = NULL, nitem, tsbsize = 128 * 1024;
d415 1
a415 1
		    "iobase=0x%x\n", iobase));
@


1.43
log
@Really print iommu TFAR (instead of CTRL again).
@
text
@d1 1
a1 1
/*	$OpenBSD: schizo.c,v 1.42 2007/01/14 16:57:21 kettenis Exp $	*/
d291 1
a291 1
	u_int64_t afsr, afar, ctrl, tfar;
d308 2
d313 3
d320 10
d334 4
@


1.42
log
@Clear error bits in PCI command/status register before establishing PCI error
handler.
@
text
@d1 1
a1 1
/*	$OpenBSD: schizo.c,v 1.41 2007/01/14 16:21:22 kettenis Exp $	*/
d313 1
a313 1
			printf("IOMMUTFAR=%lx\n", ctrl);
@


1.41
log
@Provide a bit more diagnostic information in the PCI error handler.
@
text
@d1 1
a1 1
/*	$OpenBSD: schizo.c,v 1.40 2007/01/13 21:04:03 kettenis Exp $	*/
d236 2
@


1.40
log
@Print Schizo/Tomatillo version number.
@
text
@d1 1
a1 1
/*	$OpenBSD: schizo.c,v 1.39 2007/01/12 21:32:38 kettenis Exp $	*/
d289 2
a290 1
	u_int64_t afsr, afar, ctrl;
d295 1
d300 1
a300 1
	printf("PCIAFSR=%lb\n", afsr, SCZ_PCIAFSR_BITS, afsr);
d303 11
@


1.39
log
@According to the OpenSolaris sources, the DTO bits are really MMU bit.
Add the real DTO bits for Tomatillo.
@
text
@d1 1
a1 1
/*	$OpenBSD: schizo.c,v 1.38 2006/12/24 01:25:01 deraadt Exp $	*/
d183 3
a185 2
	printf(": \"%s\", ign %x, bus %c %d to %d\n",
	    sc->sc_tomatillo ? "Tomatillo" : "Schizo", sc->sc_ign,
@


1.38
log
@change schizo/psycho interrupts to be xname:what instead of ugly names
seen previously; discussed with kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: schizo.c,v 1.37 2006/12/14 17:36:12 kettenis Exp $	*/
d245 1
a245 1
	reg |= SCZ_PCICTRL_EEN | SCZ_PCICTRL_DTO_INT | SCZ_PCICTRL_ARB;
@


1.37
log
@Make pci subsystem aware of domains.  Each host bridge gets assigned a unique
domain number such that we can distinguish between busses with the same bus
number that are behind different host bridges.  Domains can be accessed by
using different device nodes.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: schizo.c,v 1.36 2006/12/12 19:18:52 kettenis Exp $	*/
d255 4
a258 2
	schizo_set_intr(sc, pbm, PIL_HIGH, schizo_ue, sc, SCZ_UE_INO, "ue");
	schizo_set_intr(sc, pbm, PIL_HIGH, schizo_ce, sc, SCZ_CE_INO, "ce");
d439 2
d447 4
d452 1
a452 1
	    map, clr, what);
d455 1
@


1.36
log
@Use appropriate macros to decode IGN.
@
text
@d1 1
a1 1
/*	$OpenBSD: schizo.c,v 1.35 2006/08/27 18:55:57 kettenis Exp $	*/
d216 1
@


1.35
log
@Use the correct IGN for the B side of schizo.  Makes interrupts actually work
in the PCI slot of the v210.

ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: schizo.c,v 1.34 2006/07/01 18:19:09 deraadt Exp $	*/
d137 1
a137 1
	sc->sc_ign = ma->ma_upaid << 6;
@


1.34
log
@one more dmesg tweak
@
text
@d1 1
a1 1
/*	$OpenBSD: schizo.c,v 1.33 2006/07/01 16:41:26 deraadt Exp $	*/
d137 1
d183 2
a184 2
	printf(": \"%s\", bus %c %d to %d\n",
	    sc->sc_tomatillo ? "Tomatillo" : "Schizo",
a399 4
	u_int64_t agentid;

	agentid = schizo_read(sc, SCZ_CONTROL_STATUS);
	agentid = ((agentid >> 20) & 31) << 6;
d402 1
a402 1
		*ihp |= agentid;
d424 1
a424 1
	*ihp |= agentid;
d440 1
a440 1
	ino |= (*map) & INTMAP_IGN;
d654 4
a657 1
		ino |= (*intrmapptr) & INTMAP_IGN;
@


1.33
log
@clean dmesg output for iommu more; tested miod dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: schizo.c,v 1.32 2006/06/30 05:02:11 deraadt Exp $	*/
a195 1
	printf("\n");
@


1.32
log
@Some machines lack the virtual-dma property.  In that case, go back
to the 128KB assumption, until we find out another way to determine
the space.  Damn.
@
text
@d1 1
a1 1
/*	$OpenBSD: schizo.c,v 1.31 2006/06/28 20:09:15 deraadt Exp $	*/
a380 1
	iommu_reset(is);
@


1.31
log
@cleanup dmesg logging for iommu goo, make it follow the standard form
@
text
@d1 1
a1 1
/*	$OpenBSD: schizo.c,v 1.28 2006/06/27 21:22:14 kettenis Exp $	*/
d316 1
a316 1
	int *vdma = NULL, nitem, tsbsize;
@


1.30
log
@look at "virtual-dma" property to decide where the iommu address space
is, instead of having iommu_init() decide
@
text
@d1 1
a1 1
/*	$OpenBSD: schizo.c,v 1.29 2006/06/28 20:06:32 deraadt Exp $	*/
d194 1
d196 1
d576 1
a576 1
		printf("\n_psycho_bus_map: invalid parent");
@


1.29
log
@keep track of what is a schizo and what is tomatillo
@
text
@d1 1
a1 1
/*	$OpenBSD: schizo.c,v 1.28 2006/06/27 21:22:14 kettenis Exp $	*/
d314 2
d354 25
a378 1
	iommu_init(name, is, 128 * 1024, -1);
@


1.28
log
@Fix interrupt mapping.  This now seems to work on all machines, even with
pci cards that have a pci-pci bridge and lack fcode.

tested by many, ok jason@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: schizo.c,v 1.27 2006/06/23 16:09:45 deraadt Exp $	*/
d127 5
d182 3
a184 2
	printf(": bus %c %d to %d\n", busa ? 'A' : 'B',
	    busranges[0], busranges[1]);
@


1.27
log
@match tomatillo varient (not yet fully working)
@
text
@d1 1
a1 1
/*	$OpenBSD: schizo.c,v 1.26 2006/06/02 04:48:34 jason Exp $	*/
a366 1
	u_int ino;
a368 2
	ino = *ihp;

d372 1
a372 1
	if (ino & ~INTMAP_PCIINT) {
d378 10
d393 3
a395 17
	if (ino == 0 || ino > 4) {
		u_int32_t intreg;

		intreg = pci_conf_read(pa->pa_pc, pa->pa_tag,
		     PCI_INTERRUPT_REG);

		ino = PCI_INTERRUPT_PIN(intreg) - 1;
	} else
		ino -= 1;

	ino &= INTMAP_PCIINT;
	ino |= agentid;
	ino |= (dev << 2) & INTMAP_PCISLOT;

	printf("******** mapping interrupt %x -> %x\n", *ihp, ino);

	*ihp = ino;
@


1.26
log
@- clear the PCI_AFSR during init
- set up the interrupts more correctly
- print errors nicer
@
text
@d1 1
a1 1
/*	$OpenBSD: schizo.c,v 1.25 2006/06/01 21:16:29 jason Exp $	*/
d114 2
@


1.25
log
@latch the AFSR/AFAR -before- reading the PCI control/status register
@
text
@d1 1
a1 1
/*	$OpenBSD: schizo.c,v 1.24 2006/06/01 20:58:19 jason Exp $	*/
d223 1
d233 3
a235 5
	/* enable/disable error interrupts */
	reg |= SCZ_PCICTRL_EEN | SCZ_PCICTRL_SBH_INT;
	reg &= ~SCZ_PCICTRL_DTO_INT;
	/* enable bus arbiter for all pci slots */
	reg |= SCZ_PCICTRL_ARB;
d275 5
d284 3
a286 7
	printf("PCIAFSR=%lb\n",
	    schizo_pbm_read(sp, SCZ_PCI_AFSR), SCZ_PCIAFSR_BITS);

	printf("PCIAFAR=%lx\n", schizo_pbm_read(sp, SCZ_PCI_AFAR));

	printf("PCICTRL=%lb\n",
	    schizo_pbm_read(sp, SCZ_PCI_CTRL), SCZ_PCICTRL_BITS);
@


1.24
log
@do a better job of setting up the PBM.  Doesn't fix the PIO faults we're
seeing, I"m not convinced they're fixable any more.
@
text
@d1 1
a1 1
/*	$OpenBSD: schizo.c,v 1.23 2006/06/01 19:12:45 jason Exp $	*/
a279 3
	printf("PCICTRL=%lb\n",
	    schizo_pbm_read(sp, SCZ_PCI_CTRL), SCZ_PCICTRL_BITS);

d284 3
@


1.23
log
@- stop using magic constants for the onboard error INOs (one was wrong anyway)
- setup pci error interrupts and do an interpretive dance with the registers
@
text
@d1 1
a1 1
/*	$OpenBSD: schizo.c,v 1.22 2006/06/01 07:54:10 jason Exp $	*/
d156 1
a156 1
	u_int64_t match;
d219 5
d231 12
a242 2
	schizo_pbm_write(pbm, SCZ_PCI_CTRL, schizo_pbm_read(pbm, SCZ_PCI_CTRL) |
	    SCZ_PCICTRL_EEN | SCZ_PCICTRL_SBH_INT | SCZ_PCICTRL_DTO_INT);
@


1.22
log
@enable error interrupts and install handlers for same (the handlers don't do much yet)
@
text
@d1 1
a1 1
/*	$OpenBSD: schizo.c,v 1.21 2006/05/28 22:14:16 jason Exp $	*/
d221 1
a221 1
		   pbm, 0x32, "pci_a");
d224 1
a224 1
		   pbm, 0x32, "pci_ib");
d226 6
a231 2
	schizo_set_intr(sc, pbm, PIL_HIGH, schizo_ue, sc, 0x30, "ue");
	schizo_set_intr(sc, pbm, PIL_HIGH, schizo_ce, sc, 0x31, "ce");
d233 1
a233 1
	    0x34, "safari");
d262 13
a274 1
	panic("%s: pci error", sc->sc_dv.dv_xname);
@


1.21
log
@oops, nuke debugging stuff
@
text
@d1 1
a1 1
/*	$OpenBSD: schizo.c,v 1.20 2006/05/28 22:09:57 jason Exp $	*/
d72 7
d129 1
a129 1
	sc->sc_ctrl = ma->ma_reg[1].ur_paddr - 0x10000;
d142 5
d165 2
a177 1
	pbm->sp_regt = sc->sc_bust;
d180 1
a180 1
		offsetof(struct schizo_regs, pbm_b),
d188 1
a188 2
	match = bus_space_read_8(sc->sc_bust, sc->sc_ctrlh,
	    (busa ? SCZ_PCIA_IO_MATCH : SCZ_PCIB_IO_MATCH));
d219 12
d234 37
d339 1
a339 2
	agentid = bus_space_read_8(sc->sc_bust, sc->sc_ctrlh,
	    SCZ_CONTROL_STATUS);
d372 23
@


1.20
log
@- Implement schizo_intr_map (mainly to | in the agentid).
- get correct IGN for intr_establish
all of this is from kettenis and henric, I'm just cleaning it up and committing
the easy bits
@
text
@d1 1
a1 1
/*	$OpenBSD: schizo.c,v 1.19 2006/05/28 06:28:08 jason Exp $	*/
a279 1
	printf("AGENT(%llx)", agentid);
a280 1
	printf("agent(%llx)", agentid);
@


1.19
log
@don't hardcode the iova... it uses the same scheme as the sbus machines
(cd0 at scsibus0 at siop0 now attaches on the blade2k)
@
text
@d1 1
a1 1
/*	$OpenBSD: schizo.c,v 1.18 2006/03/19 02:43:38 brad Exp $	*/
d82 1
d203 1
d264 52
d412 1
a412 1
        struct schizo_pbm *sp = t->_cookie;
d414 1
a414 1
        return (iommu_dvmamap_create(t, t0, &sp->sp_sb, size, nsegments,
d437 1
a437 1
        }
d442 1
a442 1
        }
d472 1
a472 1
        if (t->parent == 0 || t->parent->sparc_bus_mmap == 0) {
d475 1
a475 1
        }
d518 1
@


1.18
log
@rev 1.86

make the "generic" PCI bus enumeration code the standard case which
gets used if nothing else is defined in MD headers,
introduce a "PCI_MACHDEP_ENUMERATE_BUS" CPP definition which can
be used by MD headers (just 1 port atm) to plug in special code

rev 1.62

* Implement a machine-dependent pci_enumerate_bus() for sparc64 which
  uses OFW device nodes to enumerate the bus.  When a PCI bus that is
  behind a bridge is attached, pci_attach_hook() allocates a new PCI
  chipset tag for the new bus and sets it's "curnode" to the OFW node
  of the bridge.  This is used as a starting point when enumerating
  that bus.  Root busses get the OFW node of the host bridge (psycho).

rev 1.59

Split the code that enumerates the PCI bus and that actually probes
for a device into two functions:

* pci_probe_device() actually probes/attaches the device specified
  by the provide pcitag_t.

* pci_enumerate_bus() enumerates the bus, and calls pci_probe_device()
  for each device on the bus.  A pci_enumerate_bus_generic() is provided
  which implements the old method of doing this: If something found at
  dev0/func0, determine number of functions and probe each one.

From NetBSD

ok kettenis@@

Tested on a good number of amd64/i386/macppc/sparc64 systems
@
text
@d1 1
a1 1
/*	$OpenBSD: schizo.c,v 1.17 2006/03/13 20:10:49 brad Exp $	*/
d250 1
a250 1
	iommu_init(name, is, 128 * 1024, 0xc0000000);
@


1.17
log
@* Add "pcitag_t *pba_bridgetag" to pci_attach_args.  This is set to
  NULL for root PCI busses.  For busses behind a bridge, it points to
  a persistent copy of the bridge's pcitag_t.  This can be very useful
  for machine-dependent PCI bus enumeration code.

From NetBSD

ok grange@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: schizo.c,v 1.16 2003/06/24 21:54:39 henric Exp $	*/
a349 1
	npc->curnode = node;
@


1.16
log
@Add a "where" argument to the sparc64 interrupt code.  This lets us
associate a name with each interrupt handler.  This is not visible
outside the kernel (yet).

ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: schizo.c,v 1.15 2003/06/11 03:16:12 henric Exp $	*/
d194 1
@


1.15
log
@Much of the sbus, psycho, and schizo bus_dma code is the same, so let's
call the real implementation functions directly instead of duplicating
lots of code that only calls the real stuff anyway.

tested by miod@@ henning@@
ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: schizo.c,v 1.14 2003/06/03 01:41:42 jason Exp $	*/
d85 1
a85 1
    int (*)(void *), void *);
d440 1
a440 1
    int level, int flags, int (*handler)(void *), void *arg)
a447 5
	ih = (struct intrhand *)malloc(sizeof(struct intrhand), M_DEVBUF,
	    M_NOWAIT);
	if (ih == NULL)
		return (NULL);

d466 4
a469 5
	ih->ih_map = intrmapptr;
	ih->ih_clr = intrclrptr;
	ih->ih_fun = handler;
	ih->ih_pil = level;
	ih->ih_number = ino;
@


1.14
log
@nuke clause 3 & 4 (with henric's permission)
@
text
@d1 1
a1 1
/*	$OpenBSD: schizo.c,v 1.13 2003/05/11 19:20:36 jason Exp $	*/
a89 14
void schizo_dmamap_destroy(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t);
int schizo_dmamap_load(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t, void *,
    bus_size_t, struct proc *, int);
void schizo_dmamap_unload(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t);
int schizo_dmamap_load_raw(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t,
    bus_dma_segment_t *, int, bus_size_t, int);
void schizo_dmamap_sync(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t, bus_addr_t,
    bus_size_t, int);
int schizo_dmamem_alloc(bus_dma_tag_t, bus_dma_tag_t, bus_size_t, bus_size_t,
    bus_size_t, bus_dma_segment_t *, int, int *, int);
void schizo_dmamem_free(bus_dma_tag_t, bus_dma_tag_t, bus_dma_segment_t *, int);
int schizo_dmamem_map(bus_dma_tag_t, bus_dma_tag_t, bus_dma_segment_t *, int,
    size_t, caddr_t *, int);
void schizo_dmamem_unmap(bus_dma_tag_t, bus_dma_tag_t, caddr_t, size_t);
d232 1
a232 1
		is->is_sb[0]->sb_flush = 0;
d241 1
d325 10
a334 10
	dt->_dmamap_create = schizo_dmamap_create;
	dt->_dmamap_destroy = schizo_dmamap_destroy;
	dt->_dmamap_load = schizo_dmamap_load;
	dt->_dmamap_load_raw = schizo_dmamap_load_raw;
	dt->_dmamap_unload = schizo_dmamap_unload;
	dt->_dmamap_sync = schizo_dmamap_sync;
	dt->_dmamem_alloc = schizo_dmamem_alloc;
	dt->_dmamem_free = schizo_dmamem_free;
	dt->_dmamem_map = schizo_dmamem_map;
	dt->_dmamem_unmap = schizo_dmamem_unmap;
d360 2
a361 100
        return (iommu_dvmamap_create(t0, &sp->sp_is, &sp->sp_sb, size,
            nsegments, maxsegsz, boundary, flags, dmamp));
}

void
schizo_dmamap_destroy(bus_dma_tag_t t, bus_dma_tag_t t0, bus_dmamap_t map)
{
	iommu_dvmamap_destroy(t0, map);
}

int
schizo_dmamap_load(bus_dma_tag_t t, bus_dma_tag_t t0, bus_dmamap_t map,
    void *buf, bus_size_t buflen, struct proc *p, int flags)
{
	struct schizo_pbm *pbm = t->_cookie;

	return (iommu_dvmamap_load(t0, &pbm->sp_is, map, buf, buflen, p,
	    flags));
}

void
schizo_dmamap_unload(bus_dma_tag_t t, bus_dma_tag_t t0, bus_dmamap_t map)
{
	struct schizo_pbm *pbm = t->_cookie;

        iommu_dvmamap_unload(t0, &pbm->sp_is, map);
}

int
schizo_dmamap_load_raw(bus_dma_tag_t t, bus_dma_tag_t t0, bus_dmamap_t map,
    bus_dma_segment_t *segs, int nsegs, bus_size_t size, int flags)
{
	struct schizo_pbm *pbm = t->_cookie;

	return (iommu_dvmamap_load_raw(t0, &pbm->sp_is, map, segs, nsegs,
	    flags, size));
}

void
schizo_dmamap_sync(bus_dma_tag_t t, bus_dma_tag_t t0, bus_dmamap_t map,
    bus_addr_t offset, bus_size_t len, int ops)
{
	struct schizo_pbm *pbm = t->_cookie;

	if (t->_parent == NULL)
		panic("schizo_dmamap_sync: no parent");

	for (t = t->_parent; t->_dmamap_sync == NULL; t = t->_parent)
		if (t == NULL)
			panic("schizo_dmamap_sync: can't find implementation");


	if (ops & (BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE)) {
		/* Flush the CPU then the IOMMU */
		(*t->_dmamap_sync)(t, t0, map, offset, len, ops);
		iommu_dvmamap_sync(t0, &pbm->sp_is, map, offset, len, ops);
	}
	if (ops & (BUS_DMASYNC_POSTREAD|BUS_DMASYNC_POSTWRITE)) {
		/* Flush the IOMMU then the CPU */
		iommu_dvmamap_sync(t0, &pbm->sp_is, map, offset, len, ops);
		(*t->_dmamap_sync)(t, t0, map, offset, len, ops);
	}
}

int
schizo_dmamem_alloc(bus_dma_tag_t t, bus_dma_tag_t t0, bus_size_t size,
    bus_size_t alignment, bus_size_t boundary, bus_dma_segment_t *segs,
    int nsegs, int *rsegs, int flags)
{
	struct schizo_pbm *pbm = t->_cookie;

	return (iommu_dvmamem_alloc(t0, &pbm->sp_is, size, alignment, boundary,
	    segs, nsegs, rsegs, flags));
}

void
schizo_dmamem_free(bus_dma_tag_t t, bus_dma_tag_t t0, bus_dma_segment_t *segs,
    int nsegs)
{
	struct schizo_pbm *pbm = t->_cookie;

	iommu_dvmamem_free(t0, &pbm->sp_is, segs, nsegs);
}

int
schizo_dmamem_map(bus_dma_tag_t t, bus_dma_tag_t t0, bus_dma_segment_t *segs,
    int nsegs, size_t size, caddr_t *kvap, int flags)
{
	struct schizo_pbm *pbm = t->_cookie;

	return (iommu_dvmamem_map(t0, &pbm->sp_is, segs, nsegs, size,
	    kvap, flags));
}

void
schizo_dmamem_unmap(bus_dma_tag_t t, bus_dma_tag_t t0, caddr_t kva, size_t size)
{
	struct schizo_pbm *pbm = t->_cookie;

	iommu_dvmamem_unmap(t0, &pbm->sp_is, kva, size);
@


1.13
log
@nuke debugging stuff
@
text
@d1 1
a1 1
/*	$OpenBSD: schizo.c,v 1.12 2003/05/11 04:44:22 jason Exp $	*/
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Jason L. Wright
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.12
log
@get the offset of the config space correct, now to figure out why the rtc is unhappy.
@
text
@d1 1
a1 1
/*	$OpenBSD: schizo.c,v 1.11 2003/03/06 08:26:08 henric Exp $	*/
a195 1
	printf("config paddr: %llx\n", pbm->sp_confpaddr);
@


1.11
log
@The existing IOMMU code had a rounding problem that was most noticeable
on faster systems under heavy network load.  This replaces some of the
unreadable iommu functions with something a little less dense and a lot
less crash prone.

The bus_dma function pointer/cookie handling was broken.  Change them
to work like the stacked bus_space drivers (where "work" is the key
word).

Tested my many (thanks).

ok jason@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: schizo.c,v 1.10 2003/02/22 19:54:43 jason Exp $	*/
d196 1
d203 1
a203 2
	if (bus_space_map(pbm->sp_cfgt, pbm->sp_confpaddr, 0x1000000,
	    0, &pbm->sp_cfgh))
@


1.11.4.1
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: schizo.c,v 1.11 2003/03/06 08:26:08 henric Exp $	*/
d202 2
a203 1
	if (bus_space_map(pbm->sp_cfgt, 0, 0x1000000, 0, &pbm->sp_cfgh))
@


1.11.4.2
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: schizo.c,v 1.11.4.1 2003/05/13 19:41:09 ho Exp $	*/
d16 5
@


1.11.4.3
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d85 1
a85 1
    int (*)(void *), void *, const char *);
d90 14
d246 1
a246 1
		is->is_sb[0]->sb_flush = NULL;
a254 1
	is->is_sb[0]->sb_flush = NULL;
d338 10
a347 10
	dt->_dmamap_create	= schizo_dmamap_create;
	dt->_dmamap_destroy	= iommu_dvmamap_destroy;
	dt->_dmamap_load	= iommu_dvmamap_load;
	dt->_dmamap_load_raw	= iommu_dvmamap_load_raw;
	dt->_dmamap_unload	= iommu_dvmamap_unload;
	dt->_dmamap_sync	= iommu_dvmamap_sync;
	dt->_dmamem_alloc	= iommu_dvmamem_alloc;
	dt->_dmamem_free	= iommu_dvmamem_free;
	dt->_dmamem_map		= iommu_dvmamem_map;
	dt->_dmamem_unmap	= iommu_dvmamem_unmap;
d373 100
a472 2
        return (iommu_dvmamap_create(t, t0, &sp->sp_sb, size, nsegments,
	    maxsegsz, boundary, flags, dmamp));
d551 1
a551 1
    int level, int flags, int (*handler)(void *), void *arg, const char *what)
d559 5
d582 5
a586 4
	ih = bus_intr_allocate(t0, handler, arg, ino, level, intrmapptr,
	    intrclrptr, what);
	if (ih == NULL)
		return (NULL);
@


1.10
log
@rearrange allocations and such so that this actually attaches (still panics
when attaching the pcibus... Still working on it =)
@
text
@d1 1
a1 1
/*	$OpenBSD: schizo.c,v 1.9 2003/02/17 01:29:20 henric Exp $	*/
d93 4
a96 1
int schizo_dmamap_load(bus_dma_tag_t, bus_dmamap_t, void *,
d98 2
a99 2
void schizo_dmamap_unload(bus_dma_tag_t, bus_dmamap_t);
int schizo_dmamap_load_raw(bus_dma_tag_t, bus_dmamap_t,
d101 1
a101 1
void schizo_dmamap_sync(bus_dma_tag_t, bus_dmamap_t, bus_addr_t,
d103 6
a108 6
int schizo_dmamem_alloc(bus_dma_tag_t, bus_size_t, bus_size_t, bus_size_t,
    bus_dma_segment_t *, int, int *, int);
void schizo_dmamem_free(bus_dma_tag_t, bus_dma_segment_t *, int);
int schizo_dmamem_map(bus_dma_tag_t, bus_dma_segment_t *, int, size_t,
    caddr_t *, int);
void schizo_dmamem_unmap(bus_dma_tag_t, caddr_t, size_t);
d344 2
a345 3
#define PCOPY(x)        dt->x = pdt->x
	PCOPY(_dmamap_create);
	PCOPY(_dmamap_destroy);
a346 2
	PCOPY(_dmamap_load_mbuf);
	PCOPY(_dmamap_load_uio);
a353 2
	PCOPY(_dmamem_mmap);
#undef  PCOPY
d373 19
a391 2
schizo_dmamap_load(bus_dma_tag_t t, bus_dmamap_t map, void *buf,
    bus_size_t buflen, struct proc *p, int flags)
d395 2
a396 1
	return (iommu_dvmamap_load(t, &pbm->sp_is, map, buf, buflen, p, flags));
d400 1
a400 1
schizo_dmamap_unload(bus_dma_tag_t t, bus_dmamap_t map)
d404 1
a404 1
        iommu_dvmamap_unload(t, &pbm->sp_is, map);
d408 1
a408 1
schizo_dmamap_load_raw(bus_dma_tag_t t, bus_dmamap_t map,
d413 1
a413 1
	return (iommu_dvmamap_load_raw(t, &pbm->sp_is, map, segs, nsegs,
d418 2
a419 2
schizo_dmamap_sync(bus_dma_tag_t t, bus_dmamap_t map, bus_addr_t offset,
    bus_size_t len, int ops)
d423 8
d433 2
a434 2
		bus_dmamap_sync(t->_parent, map, offset, len, ops);
		iommu_dvmamap_sync(t, &pbm->sp_is, map, offset, len, ops);
d438 2
a439 2
		iommu_dvmamap_sync(t, &pbm->sp_is, map, offset, len, ops);
		bus_dmamap_sync(t->_parent, map, offset, len, ops);
d444 3
a446 3
schizo_dmamem_alloc(bus_dma_tag_t t, bus_size_t size, bus_size_t alignment,
    bus_size_t boundary, bus_dma_segment_t *segs, int nsegs, int *rsegs,
    int flags)
d450 1
a450 1
	return (iommu_dvmamem_alloc(t, &pbm->sp_is, size, alignment, boundary,
d455 2
a456 1
schizo_dmamem_free(bus_dma_tag_t t, bus_dma_segment_t *segs, int nsegs)
d460 1
a460 1
	iommu_dvmamem_free(t, &pbm->sp_is, segs, nsegs);
d464 2
a465 2
schizo_dmamem_map(bus_dma_tag_t t, bus_dma_segment_t *segs, int nsegs,
    size_t size, caddr_t *kvap, int flags)
d469 1
a469 1
	return (iommu_dvmamem_map(t, &pbm->sp_is, segs, nsegs, size,
d474 1
a474 1
schizo_dmamem_unmap(bus_dma_tag_t t, caddr_t kva, size_t size)
d478 1
a478 1
	iommu_dvmamem_unmap(t, &pbm->sp_is, kva, size);
@


1.9
log
@
Add support for the Sun Enterprise 450
Reduce the size of a GENERIC kernel by ~190k
Remove the nasty pointer/bus_space_handle_t casts
Adds debug bus_space code including the ability to trace
    bus operations (it actually works now).

The following rules are now followed (and verfified by the debug
code):

1.  A "bus_space_handle_t" may only be used with the
    "bus_space_tag_t" that created it.
2.  Only "bus_space_map()" may create "bus_space_handle_t"s.
3.  A "bus_space_handle_t" may not be modified after it has
    been created (other than being destroyed by "bus_space_unmap()").


Thanks to help from mcbride, marc, jason, drahn, to anyone that might
have slipped my mind at the moment.

ok jason@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: schizo.c,v 1.8 2003/01/13 16:04:38 jason Exp $	*/
a178 6
	schizo_init_iommu(sc, pbm);

	match = bus_space_read_8(sc->sc_bust, sc->sc_ctrlh,
	    (busa ? SCZ_PCIA_IO_MATCH : SCZ_PCIB_IO_MATCH));
	pbm->sp_confpaddr = match & ~0x8000000000000000UL;

d188 6
d228 1
d231 2
d234 1
a234 1
	
d241 1
d243 2
d249 1
d266 1
@


1.8
log
@Don't use a global variable to determine which pci_conf* function to call,
store function pointers in the pci_chipset_tag_t (ie. fix an ugly hack
I did during the hackathon last year).
@
text
@d1 1
a1 1
/*	$OpenBSD: schizo.c,v 1.7 2002/08/01 18:26:35 jason Exp $	*/
d5 1
d58 11
d79 5
a83 1
bus_space_tag_t schizo_alloc_bus_tag(struct schizo_pbm *, int);
a85 2
pcireg_t schizo_pci_conf_read(pci_chipset_tag_t pc, pcitag_t, int);
void schizo_pci_conf_write(pci_chipset_tag_t, pcitag_t, int, pcireg_t);
d87 3
a89 3
int _schizo_bus_map(bus_space_tag_t, bus_type_t, bus_addr_t,
    bus_size_t, int, vaddr_t, bus_space_handle_t *);
void *_schizo_intr_establish(bus_space_tag_t, int, int, int,
d91 1
a91 1
paddr_t _schizo_bus_mmap(bus_space_tag_t, bus_addr_t, off_t, int, int);
a105 1
int schizo_get_childspace(int);
d108 1
a108 3
schizo_match(parent, match, aux)
	struct device *parent;
	void *match, *aux;
d128 1
a128 3
schizo_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d144 1
a144 1
	if (bus_space_map(sc->sc_bust, ma->ma_reg[1].ur_paddr - 0x10000,
a148 2
	sc->sc_regs = (struct schizo_regs *)bus_space_vaddr(sc->sc_bust,
	    sc->sc_ctrlh);
d154 1
a154 3
schizo_init(sc, busa)
	struct schizo_softc *sc;
	int busa;
d185 12
a196 3
	pbm->sp_memt = schizo_alloc_bus_tag(pbm, PCI_MEMORY_BUS_SPACE);
	pbm->sp_iot = schizo_alloc_bus_tag(pbm, PCI_IO_BUS_SPACE);
	pbm->sp_cfgt = schizo_alloc_bus_tag(pbm, PCI_CONFIG_BUS_SPACE);
d199 2
a200 2
	if (bus_space_map2(sc->sc_bust, PCI_CONFIG_BUS_SPACE,
	    pbm->sp_confpaddr, 0x1000000, 0, 0, &pbm->sp_cfgh))
d206 2
a207 2
	pbm->sp_pc->conf_read = schizo_pci_conf_read;
	pbm->sp_pc->conf_write = schizo_pci_conf_write;
d225 1
a225 3
schizo_init_iommu(sc, pbm)
	struct schizo_softc *sc;
	struct schizo_pbm *pbm;
d230 14
a243 8
	is->is_bustag = pbm->sp_sc->sc_bust;
	if (pbm->sp_bus_a) {
		is->is_iommu = &pbm->sp_sc->sc_regs->pbm_a.iommu;
		is->is_sb[0] = &pbm->sp_sc->sc_regs->pbm_a.strbuf;
	} else {
		is->is_iommu = &pbm->sp_sc->sc_regs->pbm_b.iommu;
		is->is_sb[0] = &pbm->sp_sc->sc_regs->pbm_b.strbuf;
	}
d247 4
a250 2
	is->is_sb[0]->strbuf_ctl &= ~STRBUF_EN;
	is->is_sb[0] = NULL;
a251 1
	is->is_sb[1] = NULL;
d262 1
a262 3
schizo_print(aux, p)
	void *aux;
	const char *p;
d270 26
a295 3
schizo_alloc_bus_tag(pbm, type)
	struct schizo_pbm *pbm;
	int type;
d298 1
a298 1
	bus_space_tag_t bt;
d300 1
a300 2
	bt = (bus_space_tag_t)
		malloc(sizeof(struct sparc_bus_space_tag), M_DEVBUF, M_NOWAIT);
d305 3
d310 3
a312 1
	bt->type = type;
d320 1
a320 2
schizo_alloc_dma_tag(pbm)
	struct schizo_pbm *pbm;
d352 1
a352 4
schizo_alloc_chipset(pbm, node, pc)
	struct schizo_pbm *pbm;
	int node;
	pci_chipset_tag_t pc;
d367 2
a368 7
schizo_dmamap_load(t, map, buf, buflen, p, flags)
	bus_dma_tag_t t;
	bus_dmamap_t map;
	void *buf;
	bus_size_t buflen;
	struct proc *p;
	int flags;
d370 1
a370 1
	struct schizo_pbm *pbm = (struct schizo_pbm *)t->_cookie;
d376 1
a376 3
schizo_dmamap_unload(t, map)
	bus_dma_tag_t t;
	bus_dmamap_t map;
d378 1
a378 1
	struct schizo_pbm *pbm = (struct schizo_pbm *)t->_cookie;
d384 2
a385 6
schizo_dmamap_load_raw(t, map, segs, nsegs, size, flags)
	bus_dma_tag_t t;
	bus_dmamap_t map;
	bus_dma_segment_t *segs;
	int nsegs, flags;
	bus_size_t size;
d387 1
a387 1
	struct schizo_pbm *pbm = (struct schizo_pbm *)t->_cookie;
d394 2
a395 6
schizo_dmamap_sync(t, map, offset, len, ops)
	bus_dma_tag_t t;
	bus_dmamap_t map;
	bus_addr_t offset;
	bus_size_t len;
	int ops;
d397 1
a397 1
	struct schizo_pbm *pbm = (struct schizo_pbm *)t->_cookie;
d412 3
a414 9
schizo_dmamem_alloc(t, size, alignment, boundary, segs, nsegs, rsegs, flags)
	bus_dma_tag_t t;
	bus_size_t size;
	bus_size_t alignment;
	bus_size_t boundary;
	bus_dma_segment_t *segs;
	int nsegs;
	int *rsegs;
	int flags;
d416 1
a416 1
	struct schizo_pbm *pbm = (struct schizo_pbm *)t->_cookie;
d423 1
a423 4
schizo_dmamem_free(t, segs, nsegs)
	bus_dma_tag_t t;
	bus_dma_segment_t *segs;
	int nsegs;
d425 1
a425 1
	struct schizo_pbm *pbm = (struct schizo_pbm *)t->_cookie;
d431 2
a432 7
schizo_dmamem_map(t, segs, nsegs, size, kvap, flags)
	bus_dma_tag_t t;
	bus_dma_segment_t *segs;
	int nsegs;
	size_t size;
	caddr_t *kvap;
	int flags;
d434 1
a434 1
	struct schizo_pbm *pbm = (struct schizo_pbm *)t->_cookie;
d441 1
a441 4
schizo_dmamem_unmap(t, kva, size)
	bus_dma_tag_t t;
	caddr_t kva;
	size_t size;
d443 1
a443 1
	struct schizo_pbm *pbm = (struct schizo_pbm *)t->_cookie;
d449 2
a450 25
schizo_get_childspace(type)
	int type;
{
	if (type == PCI_CONFIG_BUS_SPACE)
		return (0x0);
	if (type == PCI_IO_BUS_SPACE)
		return (0x1);
	if (type == PCI_MEMORY_BUS_SPACE)
		return (0x2);
#if 0
	if (type == PCI_MEMORY64_BUS_SPACE)
		return (0x3);
#endif
	panic("schizo: unknown type %d", type);
}

int
_schizo_bus_map(t, btype, offset, size, flags, vaddr, hp)
	bus_space_tag_t t;
	bus_type_t btype;
	bus_addr_t offset;
	bus_size_t size;
	int flags;
	vaddr_t vaddr;
	bus_space_handle_t *hp;
a452 1
	struct schizo_softc *sc = pbm->sp_sc;
d455 18
a472 4
	ss = schizo_get_childspace(t->type);

	if (btype == 0)
		btype = t->type;
d482 2
a483 2
		return (bus_space_map2(sc->sc_bust, btype, paddr,
		    size, flags, vaddr, hp));
d490 2
a491 6
_schizo_bus_mmap(t, paddr, off, prot, flags)
	bus_space_tag_t t;
	bus_addr_t paddr;
	off_t off;
	int prot;
	int flags;
a494 1
	struct schizo_softc *sc = pbm->sp_sc;
d497 9
a505 1
	ss = schizo_get_childspace(t->type);
d515 2
a516 2
		return (bus_space_mmap(sc->sc_bustag, paddr, off,
		    prot, flags));
a521 31
pcireg_t
schizo_pci_conf_read(pc, tag, reg)
	pci_chipset_tag_t pc;
	pcitag_t tag;
	int reg;
{
	struct schizo_pbm *pbm = pc->cookie;

	if (PCITAG_NODE(tag) == -1)
		return (~0);

	return (bus_space_read_4(pbm->sp_cfgt, pbm->sp_cfgh,
	    PCITAG_OFFSET(tag) + reg));
}

void
schizo_pci_conf_write(pc, tag, reg, data)
	pci_chipset_tag_t pc;
	pcitag_t tag;
	int reg;
	pcireg_t data;
{
	struct schizo_pbm *pbm = pc->cookie;

	if (PCITAG_NODE(tag) == -1)
		return;

	bus_space_write_4(pbm->sp_cfgt, pbm->sp_cfgh,
	    PCITAG_OFFSET(tag) + reg, data);
}

d523 2
a524 7
_schizo_intr_establish(t, ihandle, level, flags, handler, arg)
	bus_space_tag_t t;
	int ihandle;
	int level;
	int flags;
	int (*handler)(void *);
	void *arg;
a526 1
	struct schizo_softc *sc = pbm->sp_sc;	
d550 1
a550 2
		pbmreg = pbm->sp_bus_a ? &sc->sc_regs->pbm_a :
		    &sc->sc_regs->pbm_b;
@


1.7
log
@add support for mapping interrupts.
@
text
@d1 1
a1 1
/*	$OpenBSD: schizo.c,v 1.6 2002/07/24 19:12:00 jason Exp $	*/
a173 2
	pci_conf_setfunc(schizo_pci_conf_read, schizo_pci_conf_write);

d191 3
@


1.6
log
@nuke debugging cruft
@
text
@d1 1
a1 1
/*	$OpenBSD: schizo.c,v 1.5 2002/07/24 19:10:54 jason Exp $	*/
d560 50
a609 1
	return (NULL);
@


1.5
log
@add support for schizo streaming buffers (per PBM), but leave the buffers disabled for now
@
text
@d1 1
a1 1
/*	$OpenBSD: schizo.c,v 1.4 2002/07/18 16:45:08 jason Exp $	*/
a231 1
	printf("buffers %p & %p\n", is->is_sb[0], is->is_sb[1]);
@


1.4
log
@- Add support for both of the schizo iommu's(There is an iommu per pbm)
- const the cfattach
- clean
- deal with the fact that the register property doesn't reflect the true
length of the register set (grr!)
- move away from home grown read/write_8 and use bus_space where possible
@
text
@d1 1
a1 1
/*	$OpenBSD: schizo.c,v 1.3 2002/06/12 01:14:42 jason Exp $	*/
d218 1
a218 2
	is->is_sb[0] = is->is_sb[1] = NULL;
	if (pbm->sp_bus_a)
d220 2
a221 1
	else
d223 10
@


1.3
log
@add mmap implementation and skeleton interrupt mapping
@
text
@d1 1
a1 1
/*	$OpenBSD: schizo.c,v 1.2 2002/06/08 23:31:30 jason Exp $	*/
d62 1
a64 10
u_int64_t schizo_read(bus_addr_t);

struct cfattach schizo_ca = {
	sizeof(struct schizo_softc), schizo_match, schizo_attach
};

struct cfdriver schizo_cd = {
	NULL, "schizo", DV_DULL
};

d92 1
d135 8
d176 4
a179 2
	match = schizo_read(sc->sc_ctrl + 
	   (busa ? SCZ_PCIA_IO_MATCH : SCZ_PCIB_IO_MATCH));
a181 2
	printf("config space %llx\n", pbm->sp_confpaddr);

d209 23
a325 1
	struct schizo_softc *sc = pbm->sp_sc;
d327 1
a327 1
	return (iommu_dvmamap_load(t, sc->sc_is, map, buf, buflen, p, flags));
a335 1
        struct schizo_softc *sc = pbm->sp_sc;
d337 1
a337 1
        iommu_dvmamap_unload(t, sc->sc_is, map);
a348 1
	struct schizo_softc *sc = pbm->sp_sc;
d350 1
a350 1
	return (iommu_dvmamap_load_raw(t, sc->sc_is, map, segs, nsegs,
a362 1
	struct schizo_softc *sc = pbm->sp_sc;
d367 1
a367 1
		iommu_dvmamap_sync(t, sc->sc_is, map, offset, len, ops);
d371 1
a371 1
		iommu_dvmamap_sync(t, sc->sc_is, map, offset, len, ops);
a387 1
	struct schizo_softc *sc = pbm->sp_sc;
d389 1
a389 1
	return (iommu_dvmamem_alloc(t, sc->sc_is, size, alignment, boundary,
a399 1
	struct schizo_softc *sc = pbm->sp_sc;
d401 1
a401 1
	iommu_dvmamem_free(t, sc->sc_is, segs, nsegs);
a413 1
	struct schizo_softc *sc = pbm->sp_sc;
d415 1
a415 1
	return (iommu_dvmamem_map(t, sc->sc_is, segs, nsegs, size,
a425 1
	struct schizo_softc *sc = pbm->sp_sc;
d427 1
a427 1
	iommu_dvmamem_unmap(t, sc->sc_is, kva, size);
d430 2
a431 3
int schizo_get_childspace(int);

int schizo_get_childspace(type)
a517 1
	pcireg_t val = ~0;
d520 1
a520 1
		return (val);
d522 2
a523 5
	val = bus_space_read_4(pbm->sp_cfgt, pbm->sp_cfgh,
	    PCITAG_OFFSET(tag) + reg);
	
	printf("read: tag %llx reg %x -> %x\n", tag, reg, val);
	return (val);
a541 13
u_int64_t
schizo_read(adr)
	bus_addr_t adr;
{
	u_int64_t r;

	__asm__ __volatile__("ldxa [%1] %2, %0"
	    : "=r" (r)
	    : "r" (adr), "i" (ASI_PHYS_NON_CACHED)
	    : "memory");
	return (r);
}

d553 8
@


1.2
log
@Move stuff around like a crazy man... (split into var/reg)
@
text
@d1 1
a1 1
/*	$OpenBSD: schizo.c,v 1.1 2002/06/08 21:56:02 jason Exp $	*/
d84 1
a84 1
void *schizo_intr_establish(bus_space_tag_t, int, int, int,
d86 1
d237 2
a238 4
#if XXX
	bt->sparc_bus_mmap = schizo_bus_mmap;
	bt->sparc_intr_establish = schizo_intr_establish;
#endif
d467 30
d543 12
@


1.2.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.2.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: schizo.c,v 1.2.2.1 2002/06/11 03:38:43 art Exp $	*/
a61 1
void schizo_init_iommu(struct schizo_softc *, struct schizo_pbm *);
d64 10
d84 1
a84 1
void *_schizo_intr_establish(bus_space_tag_t, int, int, int,
a85 1
paddr_t _schizo_bus_mmap(bus_space_tag_t, bus_addr_t, off_t, int, int);
a99 1
int schizo_get_childspace(int);
a141 8
	if (bus_space_map(sc->sc_bust, ma->ma_reg[1].ur_paddr - 0x10000,
	    sizeof(struct schizo_regs), 0, &sc->sc_ctrlh)) {
		printf(": failed to map registers\n");
		return;
	}
	sc->sc_regs = (struct schizo_regs *)bus_space_vaddr(sc->sc_bust,
	    sc->sc_ctrlh);

d175 3
a177 1
	schizo_init_iommu(sc, pbm);
d179 1
a179 3
	match = bus_space_read_8(sc->sc_bust, sc->sc_ctrlh,
	    (busa ? SCZ_PCIA_IO_MATCH : SCZ_PCIB_IO_MATCH));
	pbm->sp_confpaddr = match & ~0x8000000000000000UL;
a207 32
void
schizo_init_iommu(sc, pbm)
	struct schizo_softc *sc;
	struct schizo_pbm *pbm;
{
	struct iommu_state *is = &pbm->sp_is;
	char *name;

	is->is_bustag = pbm->sp_sc->sc_bust;
	if (pbm->sp_bus_a) {
		is->is_iommu = &pbm->sp_sc->sc_regs->pbm_a.iommu;
		is->is_sb[0] = &pbm->sp_sc->sc_regs->pbm_a.strbuf;
	} else {
		is->is_iommu = &pbm->sp_sc->sc_regs->pbm_b.iommu;
		is->is_sb[0] = &pbm->sp_sc->sc_regs->pbm_b.strbuf;
	}

#if 1
	/* XXX disable the streaming buffers for now */
	is->is_sb[0]->strbuf_ctl &= ~STRBUF_EN;
	is->is_sb[0] = NULL;
#endif
	is->is_sb[1] = NULL;

	name = (char *)malloc(32, M_DEVBUF, M_NOWAIT);
	if (name == NULL)
		panic("couldn't malloc iommu name");
	snprintf(name, 32, "%s dvma", sc->sc_dv.dv_xname);

	iommu_init(name, is, 128 * 1024, 0xc0000000);
}

d236 4
a239 2
	bt->sparc_bus_mmap = _schizo_bus_mmap;
	bt->sparc_intr_establish = _schizo_intr_establish;
d304 1
d306 1
a306 1
	return (iommu_dvmamap_load(t, &pbm->sp_is, map, buf, buflen, p, flags));
d315 1
d317 1
a317 1
        iommu_dvmamap_unload(t, &pbm->sp_is, map);
d329 1
d331 1
a331 1
	return (iommu_dvmamap_load_raw(t, &pbm->sp_is, map, segs, nsegs,
d344 1
d349 1
a349 1
		iommu_dvmamap_sync(t, &pbm->sp_is, map, offset, len, ops);
d353 1
a353 1
		iommu_dvmamap_sync(t, &pbm->sp_is, map, offset, len, ops);
d370 1
d372 1
a372 1
	return (iommu_dvmamem_alloc(t, &pbm->sp_is, size, alignment, boundary,
d383 1
d385 1
a385 1
	iommu_dvmamem_free(t, &pbm->sp_is, segs, nsegs);
d398 1
d400 1
a400 1
	return (iommu_dvmamem_map(t, &pbm->sp_is, segs, nsegs, size,
d411 1
d413 1
a413 1
	iommu_dvmamem_unmap(t, &pbm->sp_is, kva, size);
d416 3
a418 2
int
schizo_get_childspace(type)
a467 30
paddr_t
_schizo_bus_mmap(t, paddr, off, prot, flags)
	bus_space_tag_t t;
	bus_addr_t paddr;
	off_t off;
	int prot;
	int flags;
{
	bus_addr_t offset = paddr;
	struct schizo_pbm *pbm = t->cookie;
	struct schizo_softc *sc = pbm->sp_sc;
	int i, ss;

	ss = schizo_get_childspace(t->type);

	for (i = 0; i < pbm->sp_nrange; i++) {
		bus_addr_t paddr;

		if (((pbm->sp_range[i].cspace >> 24) & 0x03) != ss)
			continue;

		paddr = pbm->sp_range[i].phys_lo + offset;
		paddr |= ((bus_addr_t)pbm->sp_range[i].phys_hi<<32);
		return (bus_space_mmap(sc->sc_bustag, paddr, off,
		    prot, flags));
	}

	return (-1);
}

d475 1
d478 1
a478 1
		return (~0);
d480 5
a484 2
	return (bus_space_read_4(pbm->sp_cfgt, pbm->sp_cfgh,
	    PCITAG_OFFSET(tag) + reg));
d503 11
a513 59
void *
_schizo_intr_establish(t, ihandle, level, flags, handler, arg)
	bus_space_tag_t t;
	int ihandle;
	int level;
	int flags;
	int (*handler)(void *);
	void *arg;
{
	struct schizo_pbm *pbm = t->cookie;
	struct schizo_softc *sc = pbm->sp_sc;	
	struct intrhand *ih = NULL;
	volatile u_int64_t *intrmapptr = NULL, *intrclrptr = NULL;
	int ino;
	long vec = INTVEC(ihandle);

	ih = (struct intrhand *)malloc(sizeof(struct intrhand), M_DEVBUF,
	    M_NOWAIT);
	if (ih == NULL)
		return (NULL);

	vec = INTVEC(ihandle);
	ino = INTINO(vec);

	if (level == IPL_NONE)
		level = INTLEV(vec);
	if (level == IPL_NONE) {
		printf(": no IPL, setting IPL 2.\n");
		level = 2;
	}

	if ((flags & BUS_INTR_ESTABLISH_SOFTINTR) == 0) {
		struct schizo_pbm_regs *pbmreg;

		pbmreg = pbm->sp_bus_a ? &sc->sc_regs->pbm_a :
		    &sc->sc_regs->pbm_b;
		intrmapptr = &pbmreg->imap[ino];
		intrclrptr = &pbmreg->iclr[ino];
	}

	ih->ih_map = intrmapptr;
	ih->ih_clr = intrclrptr;
	ih->ih_fun = handler;
	ih->ih_pil = level;
	ih->ih_number = ino;

	intr_establish(ih->ih_pil, ih);

	if (intrmapptr != NULL) {
		u_int64_t intrmap;

		intrmap = *intrmapptr;
		intrmap |= INTMAP_V;
		*intrmapptr = intrmap;
		intrmap = *intrmapptr;
		ih->ih_number |= intrmap & INTMAP_INR;
	}

	return (ih);
a514 8

const struct cfattach schizo_ca = {
	sizeof(struct schizo_softc), schizo_match, schizo_attach
};

struct cfdriver schizo_cd = {
	NULL, "schizo", DV_DULL
};
@


1.2.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a4 1
 * Copyright (c) 2003 Henric Jungheim
a56 11
#ifdef DEBUG
#define SDB_PROM        0x01
#define SDB_BUSMAP      0x02
#define SDB_INTR        0x04
#define SDB_CONF        0x08
int schizo_debug = ~0;
#define DPRINTF(l, s)   do { if (schizo_debug & l) printf s; } while (0)
#else
#define DPRINTF(l, s)
#endif

d67 1
a67 5
bus_space_tag_t schizo_alloc_mem_tag(struct schizo_pbm *);
bus_space_tag_t schizo_alloc_io_tag(struct schizo_pbm *);
bus_space_tag_t schizo_alloc_config_tag(struct schizo_pbm *);
bus_space_tag_t _schizo_alloc_bus_tag(struct schizo_pbm *, const char *,
    int, int, int);
d70 2
d73 3
a75 3
int _schizo_bus_map(bus_space_tag_t, bus_space_tag_t, bus_addr_t,
    bus_size_t, int, bus_space_handle_t *);
void *_schizo_intr_establish(bus_space_tag_t, bus_space_tag_t, int, int, int,
d77 1
a77 1
paddr_t _schizo_bus_mmap(bus_space_tag_t, bus_space_tag_t, bus_addr_t, off_t, int, int);
d79 1
a79 4
int schizo_dmamap_create(bus_dma_tag_t, bus_dma_tag_t, bus_size_t, int,
    bus_size_t, bus_size_t, int, bus_dmamap_t *);
void schizo_dmamap_destroy(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t);
int schizo_dmamap_load(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t, void *,
d81 2
a82 2
void schizo_dmamap_unload(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t);
int schizo_dmamap_load_raw(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t,
d84 1
a84 1
void schizo_dmamap_sync(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t, bus_addr_t,
d86 7
a92 6
int schizo_dmamem_alloc(bus_dma_tag_t, bus_dma_tag_t, bus_size_t, bus_size_t,
    bus_size_t, bus_dma_segment_t *, int, int *, int);
void schizo_dmamem_free(bus_dma_tag_t, bus_dma_tag_t, bus_dma_segment_t *, int);
int schizo_dmamem_map(bus_dma_tag_t, bus_dma_tag_t, bus_dma_segment_t *, int,
    size_t, caddr_t *, int);
void schizo_dmamem_unmap(bus_dma_tag_t, bus_dma_tag_t, caddr_t, size_t);
d95 3
a97 1
schizo_match(struct device *parent, void *match, void *aux)
d117 3
a119 1
schizo_attach(struct device *parent, struct device *self, void *aux)
d135 1
a135 1
	if (bus_space_map(sc->sc_bust, sc->sc_ctrl,
d140 2
d147 3
a149 1
schizo_init(struct schizo_softc *sc, int busa)
d174 1
a174 8
	pbm->sp_regt = sc->sc_bust;
	if (bus_space_subregion(pbm->sp_regt, sc->sc_ctrlh,
	    busa ? offsetof(struct schizo_regs, pbm_a) :
		offsetof(struct schizo_regs, pbm_b),
	    sizeof(struct schizo_pbm_regs),
	    &pbm->sp_regh)) {
		panic("schizo: unable to create PBM handle");
	}
d182 3
a184 3
	pbm->sp_memt = schizo_alloc_mem_tag(pbm);
	pbm->sp_iot = schizo_alloc_io_tag(pbm);
	pbm->sp_cfgt = schizo_alloc_config_tag(pbm);
d187 2
a188 1
	if (bus_space_map(pbm->sp_cfgt, 0, 0x1000000, 0, &pbm->sp_cfgh))
a193 3
	pbm->sp_pc->bustag = pbm->sp_cfgt;
	pbm->sp_pc->bushandle = pbm->sp_cfgh;

d210 3
a212 1
schizo_init_iommu(struct schizo_softc *sc, struct schizo_pbm *pbm)
a214 1
	vaddr_t va;
d217 8
a224 20
	va = (vaddr_t)pbm->sp_flush[0x40];

	is->is_bustag = pbm->sp_regt;

	if (bus_space_subregion(is->is_bustag, pbm->sp_regh,
	    offsetof(struct schizo_pbm_regs, iommu),
	    sizeof(struct iommureg), &is->is_iommu)) {
		panic("schizo: unable to create iommu handle");
	} 

	is->is_sb[0] = &pbm->sp_sb;
	is->is_sb[0]->sb_bustag = is->is_bustag;
	is->is_sb[0]->sb_flush = (void *)(va & ~0x3f);

	if (bus_space_subregion(is->is_bustag, pbm->sp_regh,
	    offsetof(struct schizo_pbm_regs, strbuf),
	    sizeof(struct iommu_strbuf), &is->is_sb[0]->sb_sb)) {
		panic("schizo: unable to create streaming buffer handle");
		is->is_sb[0]->sb_flush = 0;
	} 
d228 2
a229 4
	bus_space_write_8(is->is_bustag, is->is_sb[0]->sb_sb,
	    STRBUFREG(strbuf_ctl),
	    bus_space_read_8(is->is_bustag, is->is_sb[0]->sb_sb,
		STRBUFREG(strbuf_ctl)) & ~STRBUF_EN);
d231 1
a238 1
	iommu_reset(is);
d242 3
a244 1
schizo_print(void *aux, const char *p)
d252 3
a254 26
schizo_alloc_mem_tag(struct schizo_pbm *sp)
{
	return (_schizo_alloc_bus_tag(sp, "mem",
	    0x02,       /* 32-bit mem space (where's the #define???) */
	    ASI_PRIMARY, ASI_PRIMARY_LITTLE));
}

bus_space_tag_t
schizo_alloc_io_tag(struct schizo_pbm *sp)
{
	return (_schizo_alloc_bus_tag(sp, "io",
	    0x01,       /* IO space (where's the #define???) */
	    ASI_PHYS_NON_CACHED_LITTLE, ASI_PHYS_NON_CACHED));
}

bus_space_tag_t
schizo_alloc_config_tag(struct schizo_pbm *sp)
{
	return (_schizo_alloc_bus_tag(sp, "cfg",
	    0x00,       /* Config space (where's the #define???) */
	    ASI_PHYS_NON_CACHED_LITTLE, ASI_PHYS_NON_CACHED));
}

bus_space_tag_t
_schizo_alloc_bus_tag(struct schizo_pbm *pbm, const char *name, int ss,
    int asi, int sasi)
d257 1
a257 1
	struct sparc_bus_space_tag *bt;
d259 2
a260 1
	bt = malloc(sizeof(*bt), M_DEVBUF, M_NOWAIT);
a264 3
	snprintf(bt->name, sizeof(bt->name), "%s-pbm_%s(%d/%2.2x)",
	    sc->sc_dv.dv_xname, name, ss, asi);

d267 1
a267 3
	bt->default_type = ss;
	bt->asi = asi;
	bt->sasi = sasi;
d275 2
a276 1
schizo_alloc_dma_tag(struct schizo_pbm *pbm)
d289 3
a291 2
	dt->_dmamap_create = schizo_dmamap_create;
	dt->_dmamap_destroy = schizo_dmamap_destroy;
d293 2
d302 2
d308 4
a311 1
schizo_alloc_chipset(struct schizo_pbm *pbm, int node, pci_chipset_tag_t pc)
d326 7
a332 19
schizo_dmamap_create(bus_dma_tag_t t, bus_dma_tag_t t0, bus_size_t size,
    int nsegments, bus_size_t maxsegsz, bus_size_t boundary, int flags,
    bus_dmamap_t *dmamp)
{
        struct schizo_pbm *sp = t->_cookie;

        return (iommu_dvmamap_create(t0, &sp->sp_is, &sp->sp_sb, size,
            nsegments, maxsegsz, boundary, flags, dmamp));
}

void
schizo_dmamap_destroy(bus_dma_tag_t t, bus_dma_tag_t t0, bus_dmamap_t map)
{
	iommu_dvmamap_destroy(t0, map);
}

int
schizo_dmamap_load(bus_dma_tag_t t, bus_dma_tag_t t0, bus_dmamap_t map,
    void *buf, bus_size_t buflen, struct proc *p, int flags)
d334 1
a334 1
	struct schizo_pbm *pbm = t->_cookie;
d336 1
a336 2
	return (iommu_dvmamap_load(t0, &pbm->sp_is, map, buf, buflen, p,
	    flags));
d340 3
a342 1
schizo_dmamap_unload(bus_dma_tag_t t, bus_dma_tag_t t0, bus_dmamap_t map)
d344 1
a344 1
	struct schizo_pbm *pbm = t->_cookie;
d346 1
a346 1
        iommu_dvmamap_unload(t0, &pbm->sp_is, map);
d350 6
a355 2
schizo_dmamap_load_raw(bus_dma_tag_t t, bus_dma_tag_t t0, bus_dmamap_t map,
    bus_dma_segment_t *segs, int nsegs, bus_size_t size, int flags)
d357 1
a357 1
	struct schizo_pbm *pbm = t->_cookie;
d359 1
a359 1
	return (iommu_dvmamap_load_raw(t0, &pbm->sp_is, map, segs, nsegs,
d364 6
a369 2
schizo_dmamap_sync(bus_dma_tag_t t, bus_dma_tag_t t0, bus_dmamap_t map,
    bus_addr_t offset, bus_size_t len, int ops)
d371 1
a371 9
	struct schizo_pbm *pbm = t->_cookie;

	if (t->_parent == NULL)
		panic("schizo_dmamap_sync: no parent");

	for (t = t->_parent; t->_dmamap_sync == NULL; t = t->_parent)
		if (t == NULL)
			panic("schizo_dmamap_sync: can't find implementation");

d375 2
a376 2
		(*t->_dmamap_sync)(t, t0, map, offset, len, ops);
		iommu_dvmamap_sync(t0, &pbm->sp_is, map, offset, len, ops);
d380 2
a381 2
		iommu_dvmamap_sync(t0, &pbm->sp_is, map, offset, len, ops);
		(*t->_dmamap_sync)(t, t0, map, offset, len, ops);
d386 9
a394 3
schizo_dmamem_alloc(bus_dma_tag_t t, bus_dma_tag_t t0, bus_size_t size,
    bus_size_t alignment, bus_size_t boundary, bus_dma_segment_t *segs,
    int nsegs, int *rsegs, int flags)
d396 1
a396 1
	struct schizo_pbm *pbm = t->_cookie;
d398 1
a398 1
	return (iommu_dvmamem_alloc(t0, &pbm->sp_is, size, alignment, boundary,
d403 4
a406 2
schizo_dmamem_free(bus_dma_tag_t t, bus_dma_tag_t t0, bus_dma_segment_t *segs,
    int nsegs)
d408 1
a408 1
	struct schizo_pbm *pbm = t->_cookie;
d410 1
a410 1
	iommu_dvmamem_free(t0, &pbm->sp_is, segs, nsegs);
d414 7
a420 2
schizo_dmamem_map(bus_dma_tag_t t, bus_dma_tag_t t0, bus_dma_segment_t *segs,
    int nsegs, size_t size, caddr_t *kvap, int flags)
d422 1
a422 1
	struct schizo_pbm *pbm = t->_cookie;
d424 1
a424 1
	return (iommu_dvmamem_map(t0, &pbm->sp_is, segs, nsegs, size,
d429 4
a432 1
schizo_dmamem_unmap(bus_dma_tag_t t, bus_dma_tag_t t0, caddr_t kva, size_t size)
d434 1
a434 1
	struct schizo_pbm *pbm = t->_cookie;
d436 1
a436 1
	iommu_dvmamem_unmap(t0, &pbm->sp_is, kva, size);
d440 25
a464 2
_schizo_bus_map(bus_space_tag_t t, bus_space_tag_t t0, bus_addr_t offset,
    bus_size_t size, int flags, bus_space_handle_t *hp)
d467 1
d470 4
a473 18
	DPRINTF(SDB_BUSMAP, ("_schizo_bus_map: type %d off %qx sz %qx flags %d",
	    t->default_type,
	    (unsigned long long)offset,
	    (unsigned long long)size,
	    flags));

	ss = t->default_type;
	DPRINTF(SDB_BUSMAP, (" cspace %d", ss));

	if (t->parent == 0 || t->parent->sparc_bus_map == 0) {
		printf("\n_psycho_bus_map: invalid parent");
		return (EINVAL);
        }

	if (flags & BUS_SPACE_MAP_PROMADDRESS) {
		return ((*t->parent->sparc_bus_map)
		    (t, t0, offset, size, flags, hp));
        }
d483 2
a484 2
		return ((*t->parent->sparc_bus_map)
		    (t, t0, paddr, size, flags, hp));
d491 6
a496 2
_schizo_bus_mmap(bus_space_tag_t t, bus_space_tag_t t0, bus_addr_t paddr,
    off_t off, int prot, int flags)
d500 1
d503 1
a503 9
	ss = t->default_type;

	DPRINTF(SDB_BUSMAP, ("_schizo_bus_mmap: prot %d flags %d pa %qx\n",
	    prot, flags, (unsigned long long)paddr));

        if (t->parent == 0 || t->parent->sparc_bus_mmap == 0) {
		printf("\n_schizo_bus_mmap: invalid parent");
		return (-1);
        }
d513 2
a514 2
		return ((*t->parent->sparc_bus_mmap)
		    (t, t0, paddr, off, prot, flags));
d520 31
d552 7
a558 2
_schizo_intr_establish(bus_space_tag_t t, bus_space_tag_t t0, int ihandle,
    int level, int flags, int (*handler)(void *), void *arg)
d561 1
d585 2
a586 1
		pbmreg = bus_space_vaddr(pbm->sp_regt, pbm->sp_regh);
@


1.1
log
@Initial (not quite fully working) driver for the schizo on the blade1000
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d53 2
a54 2
#include <sparc64/dev/psychoreg.h>
#include <sparc64/dev/psychovar.h>
a56 39
#define	SCZ_PCIA_MEM_MATCH		0x00040
#define	SCZ_PCIA_MEM_MASK		0x00048
#define	SCZ_PCIA_IO_MATCH		0x00050
#define	SCZ_PCIA_IO_MASK		0x00058
#define	SCZ_PCIB_MEM_MATCH		0x00060
#define	SCZ_PCIB_MEM_MASK		0x00068
#define	SCZ_PCIB_IO_MATCH		0x00070
#define	SCZ_PCIB_IO_MASK		0x00078

struct schizo_range {
	u_int32_t	cspace;
	u_int32_t	child_hi;
	u_int32_t	child_lo;
	u_int32_t	phys_hi;
	u_int32_t	phys_lo;
	u_int32_t	size_hi;
	u_int32_t	size_lo;
};

struct schizo_pbm {
	struct schizo_softc *sp_sc;

	struct schizo_range *sp_range;
	pci_chipset_tag_t sp_pc;
	int sp_nreg;
	int sp_nrange;
	int sp_nintmap;

	bus_space_tag_t		sp_memt;
	bus_space_tag_t		sp_iot;
	bus_space_tag_t		sp_cfgt;
	bus_space_handle_t	sp_cfgh;
	bus_dma_tag_t		sp_dmat;
	int			sp_bus;
	int			sp_flags;
	int			sp_bus_a;
	bus_addr_t		sp_confpaddr;
};

a64 10

struct schizo_softc {
	struct device sc_dv;
	int sc_node;
	bus_dma_tag_t sc_dmat;
	bus_space_tag_t sc_bust;
	bus_space_tag_t sc_bustag;
	struct iommu_state *sc_is;
	bus_addr_t sc_ctrl;
};
@

