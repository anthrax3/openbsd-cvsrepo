head	1.44;
access;
symbols
	OPENBSD_6_1:1.44.0.14
	OPENBSD_6_1_BASE:1.44
	OPENBSD_6_0:1.44.0.10
	OPENBSD_6_0_BASE:1.44
	OPENBSD_5_9:1.44.0.6
	OPENBSD_5_9_BASE:1.44
	OPENBSD_5_8:1.44.0.8
	OPENBSD_5_8_BASE:1.44
	OPENBSD_5_7:1.44.0.2
	OPENBSD_5_7_BASE:1.44
	OPENBSD_5_6:1.44.0.4
	OPENBSD_5_6_BASE:1.44
	OPENBSD_5_5:1.43.0.6
	OPENBSD_5_5_BASE:1.43
	OPENBSD_5_4:1.43.0.2
	OPENBSD_5_4_BASE:1.43
	OPENBSD_5_3:1.42.0.8
	OPENBSD_5_3_BASE:1.42
	OPENBSD_5_2:1.42.0.6
	OPENBSD_5_2_BASE:1.42
	OPENBSD_5_1_BASE:1.42
	OPENBSD_5_1:1.42.0.4
	OPENBSD_5_0:1.42.0.2
	OPENBSD_5_0_BASE:1.42
	OPENBSD_4_9:1.40.0.2
	OPENBSD_4_9_BASE:1.40
	OPENBSD_4_8:1.39.0.4
	OPENBSD_4_8_BASE:1.39
	OPENBSD_4_7:1.39.0.2
	OPENBSD_4_7_BASE:1.39
	OPENBSD_4_6:1.37.0.4
	OPENBSD_4_6_BASE:1.37
	OPENBSD_4_5:1.36.0.4
	OPENBSD_4_5_BASE:1.36
	OPENBSD_4_4:1.36.0.2
	OPENBSD_4_4_BASE:1.36
	OPENBSD_4_3:1.34.0.2
	OPENBSD_4_3_BASE:1.34
	OPENBSD_4_2:1.30.0.2
	OPENBSD_4_2_BASE:1.30
	OPENBSD_4_1:1.26.0.4
	OPENBSD_4_1_BASE:1.26
	OPENBSD_4_0:1.26.0.2
	OPENBSD_4_0_BASE:1.26
	OPENBSD_3_9:1.21.0.2
	OPENBSD_3_9_BASE:1.21
	OPENBSD_3_8:1.19.0.2
	OPENBSD_3_8_BASE:1.19
	OPENBSD_3_7:1.15.0.2
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.14.0.8
	OPENBSD_3_6_BASE:1.14
	SMP_SYNC_A:1.14
	SMP_SYNC_B:1.14
	OPENBSD_3_5:1.14.0.4
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.14.0.2
	OPENBSD_3_4_BASE:1.14
	UBC_SYNC_A:1.13
	OPENBSD_3_3:1.11.0.2
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.9.0.2
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	UBC_SYNC_B:1.9
	UBC:1.6.0.6
	UBC_BASE:1.6
	SMP:1.6.0.4
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6;
locks; strict;
comment	@ * @;


1.44
date	2014.05.10.12.15.19;	author kettenis;	state Exp;
branches;
next	1.43;

1.43
date	2013.05.17.18.26.37;	author kettenis;	state Exp;
branches;
next	1.42;

1.42
date	2011.07.06.05.08.50;	author kettenis;	state Exp;
branches;
next	1.41;

1.41
date	2011.06.26.18.20.36;	author kettenis;	state Exp;
branches;
next	1.40;

1.40
date	2010.12.04.17.06.32;	author miod;	state Exp;
branches;
next	1.39;

1.39
date	2009.08.22.02.54.51;	author mk;	state Exp;
branches;
next	1.38;

1.38
date	2009.07.20.23.40.43;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2009.05.03.21.23.04;	author kettenis;	state Exp;
branches;
next	1.36;

1.36
date	2008.03.24.21.24.30;	author kettenis;	state Exp;
branches;
next	1.35;

1.35
date	2008.03.08.16.34.32;	author kettenis;	state Exp;
branches;
next	1.34;

1.34
date	2008.01.19.11.13.43;	author kettenis;	state Exp;
branches;
next	1.33;

1.33
date	2008.01.03.21.30.07;	author kettenis;	state Exp;
branches;
next	1.32;

1.32
date	2007.11.25.00.38.49;	author kettenis;	state Exp;
branches;
next	1.31;

1.31
date	2007.10.25.20.00.06;	author kettenis;	state Exp;
branches;
next	1.30;

1.30
date	2007.08.04.16.39.15;	author kettenis;	state Exp;
branches;
next	1.29;

1.29
date	2007.05.28.16.14.27;	author kettenis;	state Exp;
branches;
next	1.28;

1.28
date	2007.04.02.18.10.14;	author kettenis;	state Exp;
branches;
next	1.27;

1.27
date	2007.04.01.12.26.15;	author kettenis;	state Exp;
branches;
next	1.26;

1.26
date	2006.07.10.21.38.01;	author kettenis;	state Exp;
branches;
next	1.25;

1.25
date	2006.06.27.21.22.14;	author kettenis;	state Exp;
branches;
next	1.24;

1.24
date	2006.06.02.08.26.01;	author jason;	state Exp;
branches;
next	1.23;

1.23
date	2006.03.24.03.08.00;	author brad;	state Exp;
branches;
next	1.22;

1.22
date	2006.03.19.02.43.38;	author brad;	state Exp;
branches;
next	1.21;

1.21
date	2006.01.06.20.30.09;	author kettenis;	state Exp;
branches;
next	1.20;

1.20
date	2005.09.04.20.40.53;	author brad;	state Exp;
branches;
next	1.19;

1.19
date	2005.07.30.20.50.35;	author brad;	state Exp;
branches;
next	1.18;

1.18
date	2005.07.27.09.39.21;	author art;	state Exp;
branches;
next	1.17;

1.17
date	2005.07.07.16.40.05;	author brad;	state Exp;
branches;
next	1.16;

1.16
date	2005.06.30.04.02.52;	author marco;	state Exp;
branches;
next	1.15;

1.15
date	2004.12.02.02.41.02;	author brad;	state Exp;
branches;
next	1.14;

1.14
date	2003.06.24.21.54.39;	author henric;	state Exp;
branches;
next	1.13;

1.13
date	2003.05.16.06.59.12;	author henric;	state Exp;
branches;
next	1.12;

1.12
date	2003.05.10.21.11.14;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2003.02.17.01.29.20;	author henric;	state Exp;
branches;
next	1.10;

1.10
date	2003.01.13.16.04.38;	author jason;	state Exp;
branches;
next	1.9;

1.9
date	2002.06.08.18.06.02;	author jason;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.26.18.13.11;	author jason;	state Exp;
branches;
next	1.7;

1.7
date	2002.03.14.01.26.44;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.10.12.14.57.04;	author jason;	state Exp;
branches
	1.6.4.1
	1.6.6.1;
next	1.5;

1.5
date	2001.08.29.02.47.58;	author jason;	state Exp;
branches;
next	1.4;

1.4
date	2001.08.25.10.13.29;	author art;	state Exp;
branches;
next	1.3;

1.3
date	2001.08.23.15.26.52;	author jason;	state Exp;
branches;
next	1.2;

1.2
date	2001.08.22.20.08.55;	author art;	state Exp;
branches;
next	1.1;

1.1
date	2001.08.22.14.10.12;	author art;	state Exp;
branches;
next	;

1.6.4.1
date	2001.10.31.03.07.58;	author nate;	state Exp;
branches;
next	1.6.4.2;

1.6.4.2
date	2002.03.28.11.23.51;	author niklas;	state Exp;
branches;
next	1.6.4.3;

1.6.4.3
date	2003.03.27.23.42.35;	author niklas;	state Exp;
branches;
next	1.6.4.4;

1.6.4.4
date	2003.05.13.19.41.09;	author ho;	state Exp;
branches;
next	1.6.4.5;

1.6.4.5
date	2003.06.07.11.14.44;	author ho;	state Exp;
branches;
next	1.6.4.6;

1.6.4.6
date	2004.02.19.10.49.59;	author niklas;	state Exp;
branches;
next	;

1.6.6.1
date	2002.06.11.03.38.43;	author art;	state Exp;
branches;
next	1.6.6.2;

1.6.6.2
date	2003.05.19.21.46.57;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.44
log
@Format string fixes for printing interrupt vectors.
@
text
@/*	$OpenBSD: pci_machdep.c,v 1.43 2013/05/17 18:26:37 kettenis Exp $	*/
/*	$NetBSD: pci_machdep.c,v 1.22 2001/07/20 00:07:13 eeh Exp $	*/

/*
 * Copyright (c) 1999, 2000 Matthew R. Green
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * functions expected by the MI PCI code.
 */

#ifdef DEBUG
#define SPDB_CONF	0x01
#define SPDB_INTR	0x04
#define SPDB_INTMAP	0x08
#define SPDB_PROBE	0x20
int sparc_pci_debug = 0x0;
#define DPRINTF(l, s)	do { if (sparc_pci_debug & l) printf s; } while (0)
#else
#define DPRINTF(l, s)	do { } while (0)
#endif

#include <sys/types.h>
#include <sys/param.h>
#include <sys/time.h>
#include <sys/systm.h>
#include <sys/errno.h>
#include <sys/device.h>
#include <sys/malloc.h>

#define _SPARC_BUS_DMA_PRIVATE
#include <machine/bus.h>
#include <machine/autoconf.h>
#include <machine/openfirm.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcireg.h>

#include <dev/ofw/ofw_pci.h>

#include <sparc64/dev/iommureg.h>
#include <sparc64/dev/iommuvar.h>
#include <sparc64/dev/psychoreg.h>
#include <sparc64/dev/psychovar.h>
#include <sparc64/sparc64/cache.h>

/* this is a base to be copied */
struct sparc_pci_chipset _sparc_pci_chipset = {
	NULL,
};

static int pci_bus_frequency(int node);

/*
 * functions provided to the MI code.
 */

void
pci_attach_hook(parent, self, pba)
	struct device *parent;
	struct device *self;
	struct pcibus_attach_args *pba;
{
	/* Don't do anything */
}

int
pci_bus_maxdevs(pc, busno)
	pci_chipset_tag_t pc;
	int busno;
{

	return 32;
}

pcitag_t
pci_make_tag(pc, b, d, f)
	pci_chipset_tag_t pc;
	int b;
	int d;
	int f;
{
	struct ofw_pci_register reg;
	pcitag_t tag;
	int busrange[2];
	int node, len;
#ifdef DEBUG
	char name[80];
	bzero(name, sizeof(name));
#endif

	if (pc->busnode[b])
		return PCITAG_CREATE(0, b, d, f);

	/* 
	 * Hunt for the node that corresponds to this device 
	 *
	 * We could cache this info in an array in the parent
	 * device... except then we have problems with devices
	 * attached below pci-pci bridges, and we would need to
	 * add special code to the pci-pci bridge to cache this
	 * info.
	 */

	tag = PCITAG_CREATE(-1, b, d, f);
	node = pc->rootnode;

	/*
	 * Traverse all peers until we find the node or we find
	 * the right bridge. 
	 */
	for (node = ((node)); node; node = OF_peer(node)) {

#ifdef DEBUG
		if (sparc_pci_debug & SPDB_PROBE) {
			OF_getprop(node, "name", &name, sizeof(name));
			printf("checking node %x %s\n", node, name);
		}
#endif

		/*
		 * Check for PCI-PCI bridges.  If the device we want is
		 * in the bus-range for that bridge, work our way down.
		 */
		while ((OF_getprop(node, "bus-range", (void *)&busrange,
			sizeof(busrange)) == sizeof(busrange)) &&
			(b >= busrange[0] && b <= busrange[1])) {
			/* Go down 1 level */
			node = OF_child(node);
#ifdef DEBUG
			if (sparc_pci_debug & SPDB_PROBE) {
				OF_getprop(node, "name", &name, sizeof(name));
				printf("going down to node %x %s\n",
					node, name);
			}
#endif
		}

		/* 
		 * We only really need the first `reg' property. 
		 *
		 * For simplicity, we'll query the `reg' when we
		 * need it.  Otherwise we could malloc() it, but
		 * that gets more complicated.
		 */
		len = OF_getproplen(node, "reg");
		if (len < sizeof(reg))
			continue;
		if (OF_getprop(node, "reg", (void *)&reg, sizeof(reg)) != len)
			panic("pci_probe_bus: OF_getprop len botch");

		if (b != OFW_PCI_PHYS_HI_BUS(reg.phys_hi))
			continue;
		if (d != OFW_PCI_PHYS_HI_DEVICE(reg.phys_hi))
			continue;
		if (f != OFW_PCI_PHYS_HI_FUNCTION(reg.phys_hi))
			continue;

		/* Got a match */
		tag = PCITAG_CREATE(node, b, d, f);

		return (tag);
	}
	/* No device found -- return a dead tag */
	return (tag);
}

void
pci_decompose_tag(pc, tag, bp, dp, fp)
	pci_chipset_tag_t pc;
	pcitag_t tag;
	int *bp, *dp, *fp;
{

	if (bp != NULL)
		*bp = PCITAG_BUS(tag);
	if (dp != NULL)
		*dp = PCITAG_DEV(tag);
	if (fp != NULL)
		*fp = PCITAG_FUN(tag);
}

static int 
pci_bus_frequency(int node)
{
	int len, bus_frequency;

	len = OF_getproplen(node, "clock-frequency");
	if (len < sizeof(bus_frequency)) {
		DPRINTF(SPDB_PROBE,
		    ("pci_bus_frequency: clock-frequency len %d too small\n",
		     len));
		return 33;
	}
	if (OF_getprop(node, "clock-frequency", &bus_frequency,
		       sizeof(bus_frequency)) != len) {
		DPRINTF(SPDB_PROBE,
		    ("pci_bus_frequency: could not read clock-frequency\n"));
		return 33;
	}
	return bus_frequency / 1000000;
}

int
sparc64_pci_enumerate_bus(struct pci_softc *sc,
    int (*match)(struct pci_attach_args *), struct pci_attach_args *pap)
{
	struct ofw_pci_register reg;
	pci_chipset_tag_t pc = sc->sc_pc;
	pcitag_t tag;
	pcireg_t class, csr, bhlc, ic;
	int node, b, d, f, ret;
	int bus_frequency, lt, cl, cacheline;
	char name[30];

	if (sc->sc_bridgetag)
		node = PCITAG_NODE(*sc->sc_bridgetag);
	else
		node = pc->rootnode;

	bus_frequency = pci_bus_frequency(node);

	/*
	 * Make sure the cache line size is at least as big as the
	 * ecache line and the streaming cache (64 byte).
	 */
	cacheline = max(cacheinfo.ec_linesize, 64);

	for (node = OF_child(node); node != 0 && node != -1;
	     node = OF_peer(node)) {
		if (!checkstatus(node))
			continue;

		name[0] = name[29] = 0;
		OF_getprop(node, "name", name, sizeof(name));

		if (OF_getprop(node, "class-code", &class, sizeof(class)) != 
		    sizeof(class))
			continue;
		if (OF_getprop(node, "reg", &reg, sizeof(reg)) < sizeof(reg))
			panic("pci_enumerate_bus: \"%s\" regs too small", name);

		b = OFW_PCI_PHYS_HI_BUS(reg.phys_hi);
		d = OFW_PCI_PHYS_HI_DEVICE(reg.phys_hi);
		f = OFW_PCI_PHYS_HI_FUNCTION(reg.phys_hi);

		if (sc->sc_bus != b) {
			printf("%s: WARNING: incorrect bus # for \"%s\" "
			"(%d/%d/%d)\n", sc->sc_dev.dv_xname, name, b, d, f);
			continue;
		}

		tag = PCITAG_CREATE(node, b, d, f);

		/*
		 * Turn on parity and fast-back-to-back for the device.
		 */
		csr = pci_conf_read(pc, tag, PCI_COMMAND_STATUS_REG);
		if (csr & PCI_STATUS_BACKTOBACK_SUPPORT)
			csr |= PCI_COMMAND_BACKTOBACK_ENABLE;
		csr |= PCI_COMMAND_PARITY_ENABLE;
		pci_conf_write(pc, tag, PCI_COMMAND_STATUS_REG, csr);

		/*
		 * Initialize the latency timer register for busmaster
		 * devices to work properly.
		 *   latency-timer = min-grant * bus-freq / 4  (from FreeBSD)
		 * Also initialize the cache line size register.
		 * Solaris anytime sets this register to the value 0x10.
		 */
		bhlc = pci_conf_read(pc, tag, PCI_BHLC_REG);
		ic = pci_conf_read(pc, tag, PCI_INTERRUPT_REG);

		lt = min(PCI_MIN_GNT(ic) * bus_frequency / 4, 255);
		if (lt == 0 || lt < PCI_LATTIMER(bhlc))
			lt = PCI_LATTIMER(bhlc);

		cl = PCI_CACHELINE(bhlc);
		if (cl == 0)
			cl = cacheline;

		bhlc &= ~((PCI_LATTIMER_MASK << PCI_LATTIMER_SHIFT) |
			  (PCI_CACHELINE_MASK << PCI_CACHELINE_SHIFT));
		bhlc |= (lt << PCI_LATTIMER_SHIFT) |
			(cl << PCI_CACHELINE_SHIFT);
		pci_conf_write(pc, tag, PCI_BHLC_REG, bhlc);

		ret = pci_probe_device(sc, tag, match, pap);
		if (match != NULL && ret != 0)
			return (ret);
	}

	return (0);
}

int
pci_conf_size(pci_chipset_tag_t pc, pcitag_t tag)
{
	int val = 0;

        if (PCITAG_NODE(tag) != -1)
		val = pc->conf_size(pc, tag);

        return (val);
}

pcireg_t
pci_conf_read(pci_chipset_tag_t pc, pcitag_t tag, int reg)
{
        pcireg_t val = (pcireg_t)~0;

        if (PCITAG_NODE(tag) != -1)
		val = pc->conf_read(pc, tag, reg);

        return (val);
}

void
pci_conf_write(pci_chipset_tag_t pc, pcitag_t tag, int reg, pcireg_t data)
{
        if (PCITAG_NODE(tag) != -1)
		pc->conf_write(pc, tag, reg, data);
}

/*
 * interrupt mapping foo.
 * XXX: how does this deal with multiple interrupts for a device?
 */
int
pci_intr_map(pa, ihp)
	struct pci_attach_args *pa;
	pci_intr_handle_t *ihp;
{
	pcitag_t tag = pa->pa_tag;
	int interrupts[4], ninterrupts;
	int len, node = PCITAG_NODE(tag);
	char devtype[30];

	len = OF_getproplen(node, "interrupts");
	if (len < 0 || len < sizeof(interrupts[0])) {
		DPRINTF(SPDB_INTMAP,
			("pci_intr_map: interrupts len %d too small\n", len));
		return (ENODEV);
	}
	if (OF_getprop(node, "interrupts", interrupts,
	    sizeof(interrupts)) != len) {
		DPRINTF(SPDB_INTMAP,
			("pci_intr_map: could not read interrupts\n"));
		return (ENODEV);
	}

	/*
	 * If we have multiple interrupts for a device, choose the one
	 * that corresponds to the PCI function.  This makes the
	 * second PC Card slot on the UltraBook get the right interrupt.
	 */
	ninterrupts = len / sizeof(interrupts[0]);
	if (PCITAG_FUN(pa->pa_tag) < ninterrupts)
		interrupts[0] = interrupts[PCITAG_FUN(pa->pa_tag)];

	if (OF_mapintr(node, &interrupts[0], sizeof(interrupts[0]), 
	    sizeof(interrupts)) < 0) {
		interrupts[0] = -1;
	}
	/* Try to find an IPL for this type of device. */
	if (OF_getprop(node, "device_type", &devtype, sizeof(devtype)) > 0) {
		for (len = 0;  intrmap[len].in_class; len++)
			if (strcmp(intrmap[len].in_class, devtype) == 0) {
				interrupts[0] |= INTLEVENCODE(intrmap[len].in_lev);
				break;
			}
	}

	/* XXXX -- we use the ino.  What if there is a valid IGN? */
	*ihp = interrupts[0];

	if (pa->pa_pc->intr_map)
		return ((*pa->pa_pc->intr_map)(pa, ihp));
	else
		return (0);
}

int
pci_intr_map_msi(struct pci_attach_args *pa, pci_intr_handle_t *ihp)
{
	pci_chipset_tag_t pc = pa->pa_pc;
	pcitag_t tag = pa->pa_tag;

	if ((pa->pa_flags & PCI_FLAGS_MSI_ENABLED) == 0 ||
	    pci_get_capability(pc, tag, PCI_CAP_MSI, NULL, NULL) == 0)
		return (-1);

	*ihp = PCITAG_OFFSET(pa->pa_tag) | PCI_INTR_MSI;
	return (0);
}

int
pci_intr_line(pci_chipset_tag_t pc, pci_intr_handle_t ih)
{
	return (ih);
}

const char *
pci_intr_string(pc, ih)
	pci_chipset_tag_t pc;
	pci_intr_handle_t ih;
{
	static char str[16];

	DPRINTF(SPDB_INTR, ("pci_intr_string: ih %u", ih));
	if (ih & PCI_INTR_MSI)
		snprintf(str, sizeof str, "msi");
	else
		snprintf(str, sizeof str, "ivec 0x%llx", INTVEC(ih));
	DPRINTF(SPDB_INTR, ("; returning %s\n", str));

	return (str);
}

void *
pci_intr_establish(pc, ih, level, func, arg, what)
	pci_chipset_tag_t pc;
	pci_intr_handle_t ih;
	int level;
	int (*func)(void *);
	void *arg;
	const char *what;
{
	void *cookie;
	int flags = 0;

	if (level & IPL_MPSAFE) {
		flags |= BUS_INTR_ESTABLISH_MPSAFE;
		level &= ~IPL_MPSAFE;
	}

	DPRINTF(SPDB_INTR, ("pci_intr_establish: ih %lu; level %d",
	    (u_long)ih, level));
	cookie = bus_intr_establish(pc->bustag, ih, level, flags,
	    func, arg, what);

	DPRINTF(SPDB_INTR, ("; returning handle %p\n", cookie));
	return (cookie);
}

void
pci_intr_disestablish(pc, cookie)
	pci_chipset_tag_t pc;
	void *cookie;
{

	DPRINTF(SPDB_INTR, ("pci_intr_disestablish: cookie %p\n", cookie));

	/* XXX */
	printf("can't disestablish PCI interrupts yet\n");
}

void
pci_msi_enable(pci_chipset_tag_t pc, pcitag_t tag, bus_addr_t addr, int vec)
{
	pcireg_t reg;
	int off;

	if (pci_get_capability(pc, tag, PCI_CAP_MSI, &off, &reg) == 0)
		panic("%s: no msi capability", __func__);

	if (reg & PCI_MSI_MC_C64) {
		pci_conf_write(pc, tag, off + PCI_MSI_MA, addr);
		pci_conf_write(pc, tag, off + PCI_MSI_MAU32, 0);
		pci_conf_write(pc, tag, off + PCI_MSI_MD64, vec);
	} else {
		pci_conf_write(pc, tag, off + PCI_MSI_MA, addr);
		pci_conf_write(pc, tag, off + PCI_MSI_MD32, vec);
	}
	pci_conf_write(pc, tag, off, reg | PCI_MSI_MC_MSIE);
}
@


1.43
log
@Implement IPL_MPSAFE for pci bus interrupt handlers.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.42 2011/07/06 05:08:50 kettenis Exp $	*/
d437 1
a437 1
		snprintf(str, sizeof str, "ivec 0x%x", INTVEC(ih));
@


1.42
log
@Move pci_msi_enable() out of the vpci(4) driver into the MD pci(4) code.
Soon to be used by pyro(4) as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.41 2011/06/26 18:20:36 kettenis Exp $	*/
d453 6
d462 2
a463 1
	cookie = bus_intr_establish(pc->bustag, ih, level, 0, func, arg, what);
@


1.41
log
@Implement pci_intr_map_msi().
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.40 2010/12/04 17:06:32 miod Exp $	*/
d472 20
@


1.40
log
@Introduce a new pci routine, pci_conf_size(), which returns the size of a
given pcitag_t configuration address space. Currently, all pci controllers
will return the usual 0x100 bytes of PCI configuration space, but this will
eventually change on PCIe-capable controlers.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.39 2009/08/22 02:54:51 mk Exp $	*/
d407 14
d434 4
a437 1
	snprintf(str, sizeof str, "ivec 0x%x", INTVEC(ih));
@


1.39
log
@Constify the what/name parameter of pci_intr_establish().

Tested by myself, sthen, oga, kettenis, and jasper.
Input from sthen and jasper.

ok kettenis

(Manpage follows shortly.)
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.38 2009/07/20 23:40:43 miod Exp $	*/
d317 11
@


1.38
log
@Pass a pci_chipset_tag_t to pci_intr_line(), to eventually allow the
logic to be chipset dependent; no functional change yet.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.37 2009/05/03 21:23:04 kettenis Exp $	*/
d422 1
a422 1
	char *what;
@


1.37
log
@On the UltraBook the PROM privides two interrupts for its ccb(4)'s.  Handle
this case by choosing the interrupt that corresponds to the PCI function.
Makes the second PCMCIA slot work.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.36 2008/03/24 21:24:30 kettenis Exp $	*/
d396 1
a396 1
pci_intr_line(pci_intr_handle_t ih)
@


1.36
log
@Remove KASSERT that's causing grieve on sun4v, and I've never seen triggered.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.35 2008/03/08 16:34:32 kettenis Exp $	*/
d347 1
a347 1
	int interrupts;
d352 1
a352 1
	if (len < 0 || len < sizeof(interrupts)) {
d357 2
a358 2
	if (OF_getprop(node, "interrupts", (void *)&interrupts, 
		sizeof(interrupts)) != len) {
d364 12
a375 3
	if (OF_mapintr(node, &interrupts, sizeof(interrupts), 
		sizeof(interrupts)) < 0) {
		interrupts = -1;
d381 1
a381 1
				interrupts |= INTLEVENCODE(intrmap[len].in_lev);
d387 1
a387 1
	*ihp = interrupts;
@


1.35
log
@Check "status" property.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.34 2008/01/19 11:13:43 kettenis Exp $	*/
a250 3
	KASSERT((cacheline/64)*64 == cacheline &&
	    (cacheline/cacheinfo.ec_linesize)*cacheinfo.ec_linesize == cacheline &&
	    (cacheline/4)*4 == cacheline);
@


1.34
log
@Make host bridges provide their own implementation of pci_conf_read() and
pci_conf_write() and give pyro(4) an implementation suitable for PCIe.  For
psycho(4) and schizo(4), go back to the origional implementation.  This gets
rid of the 'tagshift' member of pci_chipset_tag_t, and clears the way for
sun4v.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.33 2008/01/03 21:30:07 kettenis Exp $	*/
d257 3
@


1.33
log
@Don't depend on evil (struct psycho_pbm *) cast.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.32 2007/11/25 00:38:49 kettenis Exp $	*/
a318 1
/* assume we are mapped little-endian/side-effect */
d324 2
a325 9
        DPRINTF(SPDB_CONF, ("pci_conf_read: tag %lx reg %x ",
                (long)PCITAG_OFFSET(tag), reg));
        if (PCITAG_NODE(tag) != -1) {
                val = bus_space_read_4(pc->bustag, pc->bushandle,
                        (PCITAG_OFFSET(tag) << pc->tagshift) + reg);
        } else
		DPRINTF(SPDB_CONF, ("pci_conf_read: bogus pcitag %x\n",
	            (int)PCITAG_OFFSET(tag)));
        DPRINTF(SPDB_CONF, (" returning %08x\n", (u_int)val));
d333 2
a334 11
        DPRINTF(SPDB_CONF, ("pci_conf_write: tag %lx; reg %x; data %x; ",
                (long)PCITAG_OFFSET(tag), reg, (int)data));

        /* If we don't know it, just punt. */
        if (PCITAG_NODE(tag) == -1) {
                DPRINTF(SPDB_CONF, ("pci_config_write: bad addr"));
                return;
        }

        bus_space_write_4(pc->bustag, pc->bushandle,
                (PCITAG_OFFSET(tag) << pc->tagshift) + reg, data);
@


1.32
log
@Give the CarBus side of CardBus-PCI bridges a bus number, since OpenFirmware
doesn't do it for us.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.31 2007/10/25 20:00:06 kettenis Exp $	*/
a432 1
	struct psycho_pbm *pp = (struct psycho_pbm *)pc->cookie;
d436 1
a436 1
	cookie = bus_intr_establish(pp->pp_memt, ih, level, 0, func, arg, what);
@


1.31
log
@Remove some coded that has been #ifdef'ed out for quite a while now.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.30 2007/08/04 16:39:15 kettenis Exp $	*/
d114 3
@


1.30
log
@Add missing pci_intr_line() implementation.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.29 2007/05/28 16:14:27 kettenis Exp $	*/
d127 1
d129 1
a129 27
	 * First make sure we're on the right bus.  If our parent
	 * has a bus-range property and we're not in the range,
	 * then we're obviously on the wrong bus.  So go up one
	 * level.
	 */
#ifdef DEBUG
	if (sparc_pci_debug & SPDB_PROBE) {
		OF_getprop(node, "name", &name, sizeof(name));
		printf("curnode %x %s\n", node, name);
	}
#endif
#if 0
	while ((OF_getprop(OF_parent(node), "bus-range", (void *)&busrange,
		sizeof(busrange)) == sizeof(busrange)) &&
		(b < busrange[0] || b > busrange[1])) {
		/* Out of range, go up one */
		node = OF_parent(node);
#ifdef DEBUG
		if (sparc_pci_debug & SPDB_PROBE) {
			OF_getprop(node, "name", &name, sizeof(name));
			printf("going up to node %x %s\n", node, name);
		}
#endif
	}
#endif	
	/*
	 * Now traverse all peers until we find the node or we find
a130 3
	 *
	 * XXX We go up one and down one to make sure nobody's missed.
	 * but this should not be necessary.
a140 1
#if 1
d158 1
a158 1
#endif
@


1.29
log
@Fix comparison between signed and unsigned integer.  Makes the random
panics during autoconf disappear on the v215.

ok dlg@@, otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.28 2007/04/02 18:10:14 kettenis Exp $	*/
d427 6
@


1.28
log
@Remove bogus code.  Turning on parity for pci busses may be a good idea, but
this is not the way to do it.  And given the way Sun host bridges crap out
upon access to pci config space for nonexistent devices, this code is
rightout harmful for machines where device 0 isn't present on some busses.

Tested by many; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.27 2007/04/01 12:26:15 kettenis Exp $	*/
d395 1
a395 1
	if (len < sizeof(interrupts)) {
@


1.27
log
@Shift tags when converting them into an address offset.  Necessary to support
access to PCIe config space, which is larger than normal PCI config space.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.26 2006/07/10 21:38:01 kettenis Exp $	*/
a279 15

	/* Turn on parity for the bus. */
	tag = PCITAG_CREATE(node, sc->sc_bus, 0, 0);
	csr = pci_conf_read(pc, tag, PCI_COMMAND_STATUS_REG);
	csr |= PCI_COMMAND_PARITY_ENABLE;
	pci_conf_write(pc, tag, PCI_COMMAND_STATUS_REG, csr);

	/*
	 * Initialize the latency timer register.
	 * The value 0x40 is from Solaris.
	 */
	bhlc = pci_conf_read(pc, tag, PCI_BHLC_REG);
	bhlc &= ~(PCI_LATTIMER_MASK << PCI_LATTIMER_SHIFT);
	bhlc |= 0x40 << PCI_LATTIMER_SHIFT;
	pci_conf_write(pc, tag, PCI_BHLC_REG, bhlc);
@


1.26
log
@Do not blindly enable pci io/mem space.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.25 2006/06/27 21:22:14 kettenis Exp $	*/
d370 1
a370 1
                        PCITAG_OFFSET(tag) + reg);
d392 1
a392 1
                PCITAG_OFFSET(tag) + reg, data);
@


1.25
log
@Fix interrupt mapping.  This now seems to work on all machines, even with
pci cards that have a pci-pci bridge and lack fcode.

tested by many, ok jason@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.24 2006/06/02 08:26:01 jason Exp $	*/
a76 15
static pcitag_t
ofpci_make_tag(pci_chipset_tag_t pc, int node, int b, int d, int f)
{
	pcitag_t tag;

	tag = PCITAG_CREATE(node, b, d, f);

	/* Enable all the different spaces for this device */
	pci_conf_write(pc, tag, PCI_COMMAND_STATUS_REG,
		PCI_COMMAND_MEM_ENABLE|PCI_COMMAND_MASTER_ENABLE|
		PCI_COMMAND_IO_ENABLE);

	return (tag);
}

d209 1
a209 1
		tag = ofpci_make_tag(pc, node, b, d, f);
d282 1
a282 1
	tag = ofpci_make_tag(pc, node, sc->sc_bus, 0, 0);
d317 1
a317 1
		tag = ofpci_make_tag(pc, node, b, d, f);
@


1.24
log
@turn the non-DEBUG case of DPRINTF into a do {} while (0) so it works
more or less as expected (and removes the need to a stupid #ifdef)
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.23 2006/03/24 03:08:00 brad Exp $	*/
d439 1
a439 1
		printf("OF_mapintr failed\n");
d467 1
a467 1
	snprintf(str, sizeof str, "ivec %x", ih);
@


1.23
log
@- Set the PCI latency timer for bus master devices.

- Turn on parity checking for the PCI bus.

From NetBSD

Tested on U5/U10/U30/Netra X1/T1 105/Leopard-V
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.22 2006/03/19 02:43:38 brad Exp $	*/
d44 1
a44 1
#define DPRINTF(l, s)
d386 3
a388 5
        }
#ifdef DEBUG
        else DPRINTF(SPDB_CONF, ("pci_conf_read: bogus pcitag %x\n",
            (int)PCITAG_OFFSET(tag)));
#endif
@


1.22
log
@rev 1.86

make the "generic" PCI bus enumeration code the standard case which
gets used if nothing else is defined in MD headers,
introduce a "PCI_MACHDEP_ENUMERATE_BUS" CPP definition which can
be used by MD headers (just 1 port atm) to plug in special code

rev 1.62

* Implement a machine-dependent pci_enumerate_bus() for sparc64 which
  uses OFW device nodes to enumerate the bus.  When a PCI bus that is
  behind a bridge is attached, pci_attach_hook() allocates a new PCI
  chipset tag for the new bus and sets it's "curnode" to the OFW node
  of the bridge.  This is used as a starting point when enumerating
  that bus.  Root busses get the OFW node of the host bridge (psycho).

rev 1.59

Split the code that enumerates the PCI bus and that actually probes
for a device into two functions:

* pci_probe_device() actually probes/attaches the device specified
  by the provide pcitag_t.

* pci_enumerate_bus() enumerates the bus, and calls pci_probe_device()
  for each device on the bus.  A pci_enumerate_bus_generic() is provided
  which implements the old method of doing this: If something found at
  dev0/func0, determine number of functions and probe each one.

From NetBSD

ok kettenis@@

Tested on a good number of amd64/i386/macppc/sparc64 systems
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.21 2006/01/06 20:30:09 kettenis Exp $	*/
a58 1

d68 1
d75 2
d247 21
d275 1
a275 1
	pcireg_t class;
d277 1
d285 26
d333 34
@


1.21
log
@Don't add the same function twice when ordering the functions of a PCI device.
Prevents alipm(4) attaching twice on Blade-100.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.20 2005/09/04 20:40:53 brad Exp $	*/
a39 1
#define SPDB_INTFIX	0x10
d75 15
a111 118
#ifdef __PCI_BUS_DEVORDER
int
pci_bus_devorder(pc, busno, devs)
	pci_chipset_tag_t pc;
	int busno;
	char *devs;
{
	struct ofw_pci_register reg;
	int node, len, device, i = 0;
	u_int32_t done = 0;
#ifdef DEBUG
	char name[80];
#endif

	node = pc->curnode;
#ifdef DEBUG
	if (sparc_pci_debug & SPDB_PROBE) {
		OF_getprop(node, "name", &name, sizeof(name));
		printf("pci_bus_devorder: curnode %x %s\n", node, name);
	}
#endif
	/*
	 * Initially, curnode is the root of the pci tree.  As we
	 * attach bridges, curnode should be set to that of the bridge.
	 */
	for (node = OF_child(node); node; node = OF_peer(node)) {
		len = OF_getproplen(node, "reg");
		if (len < sizeof(reg))
			continue;
		if (OF_getprop(node, "reg", (void *)&reg, sizeof(reg)) != len)
			panic("pci_probe_bus: OF_getprop len botch");

		device = OFW_PCI_PHYS_HI_DEVICE(reg.phys_hi);

		if (done & (1 << device))
			continue;

		devs[i++] = device;
		done |= 1 << device;
#ifdef DEBUG
	if (sparc_pci_debug & SPDB_PROBE) {
		OF_getprop(node, "name", &name, sizeof(name));
		printf("pci_bus_devorder: adding %x %s\n", node, name);
	}
#endif
		if (i == 32)
			break;
	}
	if (i < 32)
		devs[i] = -1;

	return i;
}
#endif

#ifdef __PCI_DEV_FUNCORDER
int
pci_dev_funcorder(pc, busno, device, funcs)
	pci_chipset_tag_t pc;
	int busno;
	int device;
	char *funcs;
{
	struct ofw_pci_register reg;
	int node, len, function, i = 0;
	u_int8_t done = 0;
#ifdef DEBUG
	char name[80];
#endif

	node = pc->curnode;
#ifdef DEBUG
	if (sparc_pci_debug & SPDB_PROBE) {
		OF_getprop(node, "name", &name, sizeof(name));
		printf("pci_bus_funcorder: curnode %x %s\n", node, name);
	}
#endif
	/*
	 * Functions are siblings.  Presumably we're only called when the
	 * first instance of this device is detected, so we should be able to
	 * get to all the other functions with OF_peer().  But there seems
	 * some issues with this scheme, so we always go to the first node on
	 * this bus segment for a scan.  
	 */
	for (node = OF_child(OF_parent(node)); node; node = OF_peer(node)) {
		len = OF_getproplen(node, "reg");
		if (len < sizeof(reg))
			continue;
		if (OF_getprop(node, "reg", (void *)&reg, sizeof(reg)) != len)
			panic("pci_probe_bus: OF_getprop len botch");

		if (device != OFW_PCI_PHYS_HI_DEVICE(reg.phys_hi))
			continue;

		
		function = OFW_PCI_PHYS_HI_FUNCTION(reg.phys_hi);

		if (done & (1 << function))
			continue;

		funcs[i++] = function;
		done |= 1 << function;
#ifdef DEBUG
	if (sparc_pci_debug & SPDB_PROBE) {
		OF_getprop(node, "name", &name, sizeof(name));
		printf("pci_bus_funcorder: adding %x %s\n", node, name);
	}
#endif
		if (i == 8)
			break;
	}
	if (i < 8)
		funcs[i] = -1;

	return i;
}
#endif

d222 1
a222 1
		tag = PCITAG_CREATE(node, b, d, f);
a223 13
		/*
		 * Record the node.  This has two effects:
		 *
		 * 1) We don't have to search as far.
		 * 2) pci_bus_devorder will scan the right bus.
		 */
		pc->curnode = node;

		/* Enable all the different spaces for this device */
		pci_conf_write(pc, tag, PCI_COMMAND_STATUS_REG,
			PCI_COMMAND_MEM_ENABLE|PCI_COMMAND_MASTER_ENABLE|
			PCI_COMMAND_IO_ENABLE);
		DPRINTF(SPDB_PROBE, ("found node %x %s\n", node, name));
d243 46
@


1.20
log
@remove unused NetBSD pci_intr_evcnt() function.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.19 2005/07/30 20:50:35 brad Exp $	*/
d162 2
a163 1
	int node, len, i = 0;
d192 8
a199 1
		funcs[i++] = OFW_PCI_PHYS_HI_FUNCTION(reg.phys_hi);
@


1.19
log
@Don't do nothing -> Don't do anything
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.18 2005/07/27 09:39:21 art Exp $	*/
a451 10
}

const struct evcnt *
pci_intr_evcnt(pc, ih)
	pci_chipset_tag_t pc;
	pci_intr_handle_t ih;
{

	/* XXX for now, no evcnt parent reported */
	return NULL;
@


1.18
log
@Back out 1.16. There are cases where we can recover from OF_mapintr
failure.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.17 2005/07/07 16:40:05 brad Exp $	*/
d86 1
a86 1
	/* Don't do nothing */
@


1.17
log
@change panic into printf for pci_intr_disestablish()
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.16 2005/06/30 04:02:52 marco Exp $	*/
a420 1
		return (ENODEV);
@


1.16
log
@found this when working on something else...

ok fgsch@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.15 2004/12/02 02:41:02 brad Exp $	*/
d494 1
a494 1
	panic("can't disestablish PCI interrupts yet");
@


1.15
log
@Add pci_decompose_tag() for sparc64.

From NetBSD

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.14 2003/06/24 21:54:39 henric Exp $	*/
d421 1
@


1.14
log
@Add a "where" argument to the sparc64 interrupt code.  This lets us
associate a name with each interrupt handler.  This is not visible
outside the kernel (yet).

ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.13 2003/05/16 06:59:12 henric Exp $	*/
d337 15
@


1.13
log
@The sparc64 proms do not map all interrupt vectors.  Instead of
trying to use the interrupt pin (or is it that the PCI
function?) as the interrupt vector, this computes the vector
from the PCI bus, slot, and pin.  This will only change mappings
on psycho-based machines (*not* sabre, i.e., IIi/e) and only for
those vectors reported as nonsense INRs (INO 0-3).

This should fix the mapping of non-bridge expansion cards on U60
and E450, and other psycho boxen.  U30 seems to do its own
thing.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.12 2003/05/10 21:11:14 deraadt Exp $	*/
d463 1
a463 1
	cookie = bus_intr_establish(pp->pp_memt, ih, level, 0, func, arg);
@


1.12
log
@string cleaning; ok beck dhartmei
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.11 2003/02/17 01:29:20 henric Exp $	*/
d418 5
a422 1
	return (0);
d461 2
a462 1
	DPRINTF(SPDB_INTR, ("pci_intr_establish: ih %lu; level %d", (u_long)ih, level));
@


1.11
log
@
Add support for the Sun Enterprise 450
Reduce the size of a GENERIC kernel by ~190k
Remove the nasty pointer/bus_space_handle_t casts
Adds debug bus_space code including the ability to trace
    bus operations (it actually works now).

The following rules are now followed (and verfified by the debug
code):

1.  A "bus_space_handle_t" may only be used with the
    "bus_space_tag_t" that created it.
2.  Only "bus_space_map()" may create "bus_space_handle_t"s.
3.  A "bus_space_handle_t" may not be modified after it has
    been created (other than being destroyed by "bus_space_unmap()").


Thanks to help from mcbride, marc, jason, drahn, to anyone that might
have slipped my mind at the moment.

ok jason@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.10 2003/01/13 16:04:38 jason Exp $	*/
d429 1
a429 1
	sprintf(str, "ivec %x", ih);
@


1.10
log
@Don't use a global variable to determine which pci_conf* function to call,
store function pointers in the pci_chipset_tag_t (ie. fix an ugly hack
I did during the hackathon last year).
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.9 2002/06/08 18:06:02 jason Exp $	*/
d341 1
a341 4
pci_conf_read(pc, tag, reg)
	pci_chipset_tag_t pc;
	pcitag_t tag;
	int reg;
d343 15
a357 1
	return (pc->conf_read(pc, tag, reg));
d361 1
a361 5
pci_conf_write(pc, tag, reg, data)
	pci_chipset_tag_t pc;
	pcitag_t tag;
	int reg;
	pcireg_t data;
d363 11
a373 1
	return (pc->conf_write(pc, tag, reg, data));
a374 1

@


1.9
log
@make pci_conf_{read|write} indirect functions so we can overload them
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.8 2002/03/26 18:13:11 jason Exp $	*/
a338 12
pcireg_t (*sparc64_pci_conf_read)(pci_chipset_tag_t, pcitag_t, int);
void (*sparc64_pci_conf_write)(pci_chipset_tag_t, pcitag_t, int, pcireg_t);

void
pci_conf_setfunc(rd, wr)
	pcireg_t (*rd)(pci_chipset_tag_t, pcitag_t, int);
	void (*wr)(pci_chipset_tag_t, pcitag_t, int, pcireg_t);
{
	sparc64_pci_conf_read = rd;
	sparc64_pci_conf_write = wr;
}

d346 1
a346 3
	if (sparc64_pci_conf_read == NULL)
		panic("no pci_conf_read");
	return ((*sparc64_pci_conf_read)(pc, tag, reg));
d356 1
a356 3
	if (sparc64_pci_conf_write == NULL)
		panic("no pci_conf_read");
	return ((*sparc64_pci_conf_write)(pc, tag, reg, data));
@


1.8
log
@Permit compiling with DEBUG; Joey Coleman <joeycoleman@@acm.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.7 2002/03/14 01:26:44 millert Exp $	*/
d339 12
d358 3
a360 23
	struct psycho_pbm *pp = pc->cookie;
	struct psycho_softc *sc = pp->pp_sc;
	pcireg_t val = (pcireg_t)~0;

	DPRINTF(SPDB_CONF, ("pci_conf_read: tag %lx reg %x ", 
		(long)tag, reg));
	if (PCITAG_NODE(tag) != -1) {
		DPRINTF(SPDB_CONF, ("asi=%x addr=%qx (offset=%x) ...",
			bus_type_asi[sc->sc_configtag->type],
			(long long)(sc->sc_configaddr + 
				PCITAG_OFFSET(tag) + reg),
			(int)PCITAG_OFFSET(tag) + reg));

		val = bus_space_read_4(sc->sc_configtag, sc->sc_configaddr,
			PCITAG_OFFSET(tag) + reg);
	}
#ifdef DEBUG
	else DPRINTF(SPDB_CONF, ("pci_conf_read: bogus pcitag %x\n",
	    (int)PCITAG_OFFSET(tag)));
#endif
	DPRINTF(SPDB_CONF, (" returning %08x\n", (u_int)val));

	return (val);
d370 4
a373 2
	struct psycho_pbm *pp = pc->cookie;
	struct psycho_softc *sc = pp->pp_sc;
a374 16
	DPRINTF(SPDB_CONF, ("pci_conf_write: tag %lx; reg %x; data %x; ", 
		(long)PCITAG_OFFSET(tag), reg, (int)data));
	DPRINTF(SPDB_CONF, ("asi = %x; readaddr = %qx (offset = %x)\n",
		bus_type_asi[sc->sc_configtag->type],
		(long long)(sc->sc_configaddr + PCITAG_OFFSET(tag) + reg), 
		(int)PCITAG_OFFSET(tag) + reg));

	/* If we don't know it, just punt. */
	if (PCITAG_NODE(tag) == -1) {
		DPRINTF(SPDB_CONF, ("pci_config_write: bad addr"));
		return;
	}

	bus_space_write_4(sc->sc_configtag, sc->sc_configaddr, 
		PCITAG_OFFSET(tag) + reg, data);
}
@


1.7
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.6 2001/10/12 14:57:04 jason Exp $	*/
d364 1
a364 1
	    (int)PCITAG_OFFSET(tag));
@


1.6
log
@From NetBSD: convert printf's to debug only and remove a panic
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.5 2001/08/29 02:47:58 jason Exp $	*/
d472 1
a472 1
	int (*func) __P((void *));
@


1.6.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.6 2001/10/12 14:57:04 jason Exp $	*/
a338 12
pcireg_t (*sparc64_pci_conf_read)(pci_chipset_tag_t, pcitag_t, int);
void (*sparc64_pci_conf_write)(pci_chipset_tag_t, pcitag_t, int, pcireg_t);

void
pci_conf_setfunc(rd, wr)
	pcireg_t (*rd)(pci_chipset_tag_t, pcitag_t, int);
	void (*wr)(pci_chipset_tag_t, pcitag_t, int, pcireg_t);
{
	sparc64_pci_conf_read = rd;
	sparc64_pci_conf_write = wr;
}

d346 23
a368 3
	if (sparc64_pci_conf_read == NULL)
		panic("no pci_conf_read");
	return ((*sparc64_pci_conf_read)(pc, tag, reg));
d378 18
a395 3
	if (sparc64_pci_conf_write == NULL)
		panic("no pci_conf_read");
	return ((*sparc64_pci_conf_write)(pc, tag, reg, data));
a397 1

d472 1
a472 1
	int (*func)(void *);
@


1.6.6.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d339 12
d353 4
a356 1
pci_conf_read(pci_chipset_tag_t pc, pcitag_t tag, int reg)
d358 3
a360 15
        pcireg_t val = (pcireg_t)~0;

        DPRINTF(SPDB_CONF, ("pci_conf_read: tag %lx reg %x ",
                (long)PCITAG_OFFSET(tag), reg));
        if (PCITAG_NODE(tag) != -1) {
                val = bus_space_read_4(pc->bustag, pc->bushandle,
                        PCITAG_OFFSET(tag) + reg);
        }
#ifdef DEBUG
        else DPRINTF(SPDB_CONF, ("pci_conf_read: bogus pcitag %x\n",
            (int)PCITAG_OFFSET(tag)));
#endif
        DPRINTF(SPDB_CONF, (" returning %08x\n", (u_int)val));

        return (val);
d364 5
a368 1
pci_conf_write(pci_chipset_tag_t pc, pcitag_t tag, int reg, pcireg_t data)
d370 4
a373 8
        DPRINTF(SPDB_CONF, ("pci_conf_write: tag %lx; reg %x; data %x; ",
                (long)PCITAG_OFFSET(tag), reg, (int)data));

        /* If we don't know it, just punt. */
        if (PCITAG_NODE(tag) == -1) {
                DPRINTF(SPDB_CONF, ("pci_config_write: bad addr"));
                return;
        }
a374 3
        bus_space_write_4(pc->bustag, pc->bushandle,
                PCITAG_OFFSET(tag) + reg, data);
}
d418 1
a418 5

	if (pa->pa_pc->intr_map)
		return ((*pa->pa_pc->intr_map)(pa, ihp));
	else
		return (0);
d429 1
a429 1
	snprintf(str, sizeof str, "ivec %x", ih);
d457 1
a457 2
	DPRINTF(SPDB_INTR, ("pci_intr_establish: ih %lu; level %d",
	    (u_long)ih, level));
@


1.6.4.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.6.4.2
log
@Merge in -current from about a week ago
@
text
@d472 1
a472 1
	int (*func)(void *);
@


1.6.4.3
log
@Sync the SMP branch with 3.3
@
text
@d341 4
a344 1
pci_conf_read(pci_chipset_tag_t pc, pcitag_t tag, int reg)
d346 3
a348 1
        pcireg_t val = (pcireg_t)~0;
d350 12
a361 6
        DPRINTF(SPDB_CONF, ("pci_conf_read: tag %lx reg %x ",
                (long)PCITAG_OFFSET(tag), reg));
        if (PCITAG_NODE(tag) != -1) {
                val = bus_space_read_4(pc->bustag, pc->bushandle,
                        PCITAG_OFFSET(tag) + reg);
        }
d363 2
a364 2
        else DPRINTF(SPDB_CONF, ("pci_conf_read: bogus pcitag %x\n",
            (int)PCITAG_OFFSET(tag)));
d366 1
a366 1
        DPRINTF(SPDB_CONF, (" returning %08x\n", (u_int)val));
d368 1
a368 1
        return (val);
d372 5
a376 1
pci_conf_write(pci_chipset_tag_t pc, pcitag_t tag, int reg, pcireg_t data)
d378 9
a386 2
        DPRINTF(SPDB_CONF, ("pci_conf_write: tag %lx; reg %x; data %x; ",
                (long)PCITAG_OFFSET(tag), reg, (int)data));
d388 5
a392 5
        /* If we don't know it, just punt. */
        if (PCITAG_NODE(tag) == -1) {
                DPRINTF(SPDB_CONF, ("pci_config_write: bad addr"));
                return;
        }
d394 2
a395 2
        bus_space_write_4(pc->bustag, pc->bushandle,
                PCITAG_OFFSET(tag) + reg, data);
@


1.6.4.4
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.6.4.3 2003/03/27 23:42:35 niklas Exp $	*/
d429 1
a429 1
	snprintf(str, sizeof str, "ivec %x", ih);
@


1.6.4.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.6.4.4 2003/05/13 19:41:09 ho Exp $	*/
d418 1
a418 5

	if (pa->pa_pc->intr_map)
		return ((*pa->pa_pc->intr_map)(pa, ihp));
	else
		return (0);
d457 1
a457 2
	DPRINTF(SPDB_INTR, ("pci_intr_establish: ih %lu; level %d",
	    (u_long)ih, level));
@


1.6.4.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d463 1
a463 1
	cookie = bus_intr_establish(pp->pp_memt, ih, level, 0, func, arg, what);
@


1.5
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d363 2
a364 2
	else printf("pci_conf_read: bogus pcitag %x\n",
		(int)PCITAG_OFFSET(tag));
d388 6
a393 3
	if (PCITAG_NODE(tag) == -1)
		panic("pci_conf_write: bad addr");
		
@


1.4
log
@Change pci_intr_map to take pci_attach_args as an argument.
All callers actually took all arguments to pci_intr_map from pci_attach_args
structs, so this simplifies code.
This also allows more complicated interrupt assignment schemes like the one
on sparc64.

This makes sparc64 pci interrupts work.

Inspired by the same change in NetBSD.
@
text
@d1 1
@


1.3
log
@Check for OF_mapintr() failure appears to be backwards; diff mailed to NetBSD.
@
text
@d399 2
a400 4
pci_intr_map(pc, tag, pin, line, ihp)
	pci_chipset_tag_t pc;
	pcitag_t tag;
	int pin, line;
d403 1
@


1.2
log
@Fix interrupt establishing.
@
text
@d423 1
a423 1
		sizeof(interrupts)) > 0) {
@


1.1
log
@pci_machep from NetBSD
@
text
@d399 4
a402 2
pci_intr_map(pa, ihp)
	struct pci_attach_args *pa;
a404 1
	pcitag_t tag = pa->pa_tag;
d465 1
a465 1
pci_intr_establish(pc, ih, level, func, arg)
d471 1
@

