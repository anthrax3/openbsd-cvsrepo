head	1.51;
access;
symbols
	OPENBSD_6_1:1.50.0.8
	OPENBSD_6_1_BASE:1.50
	OPENBSD_6_0:1.50.0.4
	OPENBSD_6_0_BASE:1.50
	OPENBSD_5_9:1.50.0.2
	OPENBSD_5_9_BASE:1.50
	OPENBSD_5_8:1.49.0.6
	OPENBSD_5_8_BASE:1.49
	OPENBSD_5_7:1.49.0.2
	OPENBSD_5_7_BASE:1.49
	OPENBSD_5_6:1.48.0.4
	OPENBSD_5_6_BASE:1.48
	OPENBSD_5_5:1.46.0.4
	OPENBSD_5_5_BASE:1.46
	OPENBSD_5_4:1.45.0.16
	OPENBSD_5_4_BASE:1.45
	OPENBSD_5_3:1.45.0.14
	OPENBSD_5_3_BASE:1.45
	OPENBSD_5_2:1.45.0.12
	OPENBSD_5_2_BASE:1.45
	OPENBSD_5_1_BASE:1.45
	OPENBSD_5_1:1.45.0.10
	OPENBSD_5_0:1.45.0.8
	OPENBSD_5_0_BASE:1.45
	OPENBSD_4_9:1.45.0.6
	OPENBSD_4_9_BASE:1.45
	OPENBSD_4_8:1.45.0.4
	OPENBSD_4_8_BASE:1.45
	OPENBSD_4_7:1.45.0.2
	OPENBSD_4_7_BASE:1.45
	OPENBSD_4_6:1.40.0.6
	OPENBSD_4_6_BASE:1.40
	OPENBSD_4_5:1.40.0.2
	OPENBSD_4_5_BASE:1.40
	OPENBSD_4_4:1.39.0.8
	OPENBSD_4_4_BASE:1.39
	OPENBSD_4_3:1.39.0.6
	OPENBSD_4_3_BASE:1.39
	OPENBSD_4_2:1.39.0.4
	OPENBSD_4_2_BASE:1.39
	OPENBSD_4_1:1.39.0.2
	OPENBSD_4_1_BASE:1.39
	OPENBSD_4_0:1.36.0.2
	OPENBSD_4_0_BASE:1.36
	OPENBSD_3_9:1.34.0.4
	OPENBSD_3_9_BASE:1.34
	OPENBSD_3_8:1.34.0.2
	OPENBSD_3_8_BASE:1.34
	OPENBSD_3_7:1.33.0.2
	OPENBSD_3_7_BASE:1.33
	OPENBSD_3_6:1.29.0.8
	OPENBSD_3_6_BASE:1.29
	SMP_SYNC_A:1.29
	SMP_SYNC_B:1.29
	OPENBSD_3_5:1.29.0.4
	OPENBSD_3_5_BASE:1.29
	OPENBSD_3_4:1.29.0.2
	OPENBSD_3_4_BASE:1.29
	UBC_SYNC_A:1.24
	SMP:1.23.0.2
	OPENBSD_3_3:1.22.0.4
	OPENBSD_3_3_BASE:1.22
	UBC_SYNC_B:1.22
	OPENBSD_3_2:1.22.0.2
	OPENBSD_3_2_BASE:1.22
	UBC:1.11.0.2;
locks; strict;
comment	@ * @;


1.51
date	2017.09.08.05.36.52;	author deraadt;	state Exp;
branches;
next	1.50;
commitid	uRv5pa9QDlZaYgwD;

1.50
date	2015.12.11.16.07.01;	author mpi;	state Exp;
branches;
next	1.49;
commitid	fbhqfhfdKxBcsetK;

1.49
date	2015.01.26.20.25.38;	author miod;	state Exp;
branches;
next	1.48;
commitid	QoBTQyxLjPIHPpcg;

1.48
date	2014.07.12.18.44.43;	author tedu;	state Exp;
branches;
next	1.47;
commitid	uKVPYMN2MLxdZxzH;

1.47
date	2014.03.29.18.09.30;	author guenther;	state Exp;
branches;
next	1.46;

1.46
date	2013.10.20.20.07.27;	author miod;	state Exp;
branches;
next	1.45;

1.45
date	2009.12.16.11.06.17;	author jasper;	state Exp;
branches;
next	1.44;

1.44
date	2009.12.02.20.11.17;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2009.11.30.23.32.57;	author kettenis;	state Exp;
branches;
next	1.42;

1.42
date	2009.09.05.14.09.35;	author miod;	state Exp;
branches;
next	1.41;

1.41
date	2009.07.16.21.03.09;	author kettenis;	state Exp;
branches;
next	1.40;

1.40
date	2008.12.27.17.23.01;	author miod;	state Exp;
branches;
next	1.39;

1.39
date	2007.03.06.23.10.26;	author kettenis;	state Exp;
branches;
next	1.38;

1.38
date	2006.12.17.22.18.16;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2006.12.02.11.21.37;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2006.06.30.21.38.19;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2006.05.15.21.38.36;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2005.04.05.21.49.33;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2005.03.15.18.40.15;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2005.03.07.16.44.52;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2005.01.05.23.04.25;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2004.11.29.22.07.40;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2003.06.24.19.41.33;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2003.06.23.16.49.44;	author jason;	state Exp;
branches;
next	1.27;

1.27
date	2003.06.20.19.54.37;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2003.06.17.17.35.40;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2003.06.02.20.02.49;	author jason;	state Exp;
branches;
next	1.24;

1.24
date	2003.05.12.19.37.33;	author jason;	state Exp;
branches;
next	1.23;

1.23
date	2003.03.27.18.17.58;	author jason;	state Exp;
branches
	1.23.2.1;
next	1.22;

1.22
date	2002.09.10.03.18.59;	author jason;	state Exp;
branches;
next	1.21;

1.21
date	2002.08.19.20.16.04;	author jason;	state Exp;
branches;
next	1.20;

1.20
date	2002.07.30.19.48.15;	author jason;	state Exp;
branches;
next	1.19;

1.19
date	2002.07.29.06.21.45;	author jason;	state Exp;
branches;
next	1.18;

1.18
date	2002.07.29.05.53.12;	author jason;	state Exp;
branches;
next	1.17;

1.17
date	2002.07.28.06.25.14;	author fgsch;	state Exp;
branches;
next	1.16;

1.16
date	2002.07.26.18.23.34;	author jason;	state Exp;
branches;
next	1.15;

1.15
date	2002.07.26.18.00.08;	author jason;	state Exp;
branches;
next	1.14;

1.14
date	2002.07.26.16.57.16;	author jason;	state Exp;
branches;
next	1.13;

1.13
date	2002.07.25.19.04.43;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2002.06.11.06.53.03;	author fgsch;	state Exp;
branches;
next	1.11;

1.11
date	2002.06.03.16.32.04;	author fgsch;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	2002.05.22.22.02.08;	author fgsch;	state Exp;
branches;
next	1.9;

1.9
date	2002.05.22.21.30.47;	author jason;	state Exp;
branches;
next	1.8;

1.8
date	2002.05.22.14.44.20;	author jason;	state Exp;
branches;
next	1.7;

1.7
date	2002.05.22.03.15.29;	author jason;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.22.01.45.12;	author jason;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.21.18.49.00;	author jason;	state Exp;
branches;
next	1.4;

1.4
date	2002.05.21.18.31.31;	author jason;	state Exp;
branches;
next	1.3;

1.3
date	2002.05.21.15.46.07;	author jason;	state Exp;
branches;
next	1.2;

1.2
date	2002.05.21.14.53.47;	author jason;	state Exp;
branches;
next	1.1;

1.1
date	2002.05.21.04.31.03;	author jason;	state Exp;
branches;
next	;

1.11.2.1
date	2002.06.11.03.38.42;	author art;	state Exp;
branches;
next	1.11.2.2;

1.11.2.2
date	2002.10.29.00.28.11;	author art;	state Exp;
branches;
next	1.11.2.3;

1.11.2.3
date	2003.05.19.21.46.57;	author tedu;	state Exp;
branches;
next	;

1.23.2.1
date	2003.04.19.19.17.49;	author niklas;	state Exp;
branches;
next	1.23.2.2;

1.23.2.2
date	2003.05.13.19.41.09;	author ho;	state Exp;
branches;
next	1.23.2.3;

1.23.2.3
date	2003.05.16.00.29.40;	author niklas;	state Exp;
branches;
next	1.23.2.4;

1.23.2.4
date	2003.06.07.11.14.44;	author ho;	state Exp;
branches;
next	1.23.2.5;

1.23.2.5
date	2004.02.19.10.49.59;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.51
log
@If you use sys/param.h, you don't need sys/types.h
@
text
@/*	$OpenBSD: creator.c,v 1.50 2015/12/11 16:07:01 mpi Exp $	*/

/*
 * Copyright (c) 2002 Jason L. Wright (jason@@thought.net)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/conf.h>
#include <sys/malloc.h>

#include <machine/bus.h>
#include <machine/autoconf.h>
#include <machine/openfirm.h>

#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsdisplayvar.h>
#include <dev/rasops/rasops.h>
#include <machine/fbvar.h>

#include <sparc64/dev/creatorreg.h>
#include <sparc64/dev/creatorvar.h>

int	creator_match(struct device *, void *, void *);
void	creator_attach(struct device *, struct device *, void *);
int	creator_ioctl(void *, u_long, caddr_t, int, struct proc *);
paddr_t creator_mmap(void *, off_t, int);

void	creator_ras_fifo_wait(struct creator_softc *, int);
void	creator_ras_wait(struct creator_softc *);
void	creator_ras_init(struct creator_softc *);
int	creator_ras_copyrows(void *, int, int, int);
int	creator_ras_erasecols(void *, int, int, int, long int);
int	creator_ras_eraserows(void *, int, int, long int);
void	creator_ras_fill(struct creator_softc *);
void	creator_ras_setfg(struct creator_softc *, int32_t);

int	creator_setcursor(struct creator_softc *, struct wsdisplay_cursor *);
int	creator_updatecursor(struct creator_softc *, u_int);
void	creator_curs_enable(struct creator_softc *, u_int);

#ifndef SMALL_KERNEL
void	creator_load_firmware(struct device *);
#endif /* SMALL_KERNEL */
void	creator_load_sram(struct creator_softc *, u_int32_t *, u_int32_t);

struct wsdisplay_accessops creator_accessops = {
	.ioctl = creator_ioctl,
	.mmap = creator_mmap
};

struct cfdriver creator_cd = {
	NULL, "creator", DV_DULL
};

struct cfattach creator_ca = {
	sizeof(struct creator_softc), creator_match, creator_attach
};

int
creator_match(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	struct mainbus_attach_args *ma = aux;

	if (strcmp(ma->ma_name, "SUNW,ffb") == 0 ||
	    strcmp(ma->ma_name, "SUNW,afb") == 0)
		return (1);
	return (0);
}

void
creator_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct creator_softc *sc = (struct creator_softc *)self;
	struct mainbus_attach_args *ma = aux;
	extern int fbnode;
	int i, nregs;
	char *model;
	int btype;

	sc->sc_bt = ma->ma_bustag;

	nregs = min(ma->ma_nreg, FFB_NREGS);

	if (nregs <= FFB_REG_DFB24) {
		printf(": no dfb24 regs found\n");
		return;
	}

	if (bus_space_map(sc->sc_bt, ma->ma_reg[FFB_REG_DFB24].ur_paddr,
	    ma->ma_reg[FFB_REG_DFB24].ur_len, BUS_SPACE_MAP_LINEAR,
	    &sc->sc_pixel_h)) {
		printf(": failed to map dfb24\n");
		return;
	}

	if (bus_space_map(sc->sc_bt, ma->ma_reg[FFB_REG_FBC].ur_paddr,
	    ma->ma_reg[FFB_REG_FBC].ur_len, 0, &sc->sc_fbc_h)) {
		printf(": failed to map fbc\n");
		goto unmap_dfb24;
	}

	if (bus_space_map(sc->sc_bt, ma->ma_reg[FFB_REG_DAC].ur_paddr,
	    ma->ma_reg[FFB_REG_DAC].ur_len, 0, &sc->sc_dac_h)) {
		printf(": failed to map dac\n");
		goto unmap_fbc;
	}

	for (i = 0; i < nregs; i++) {
		sc->sc_addrs[i] = ma->ma_reg[i].ur_paddr;
		sc->sc_sizes[i] = ma->ma_reg[i].ur_len;
	}
	sc->sc_nreg = nregs;

	sc->sc_console = (fbnode == ma->ma_node);
	sc->sc_node = ma->ma_node;

	if (strcmp(ma->ma_name, "SUNW,afb") == 0)
		sc->sc_type = FFB_AFB;

	/*
	 * Prom reports only the length of the fcode header, we need
	 * the whole thing.
	 */
	sc->sc_sizes[0] = 0x00400000;

	if (sc->sc_type == FFB_CREATOR) {
		btype = getpropint(sc->sc_node, "board_type", 0);
		if ((btype & 7) == 3)
			printf(": Creator3D");
		else
			printf(": Creator");
	} else
		printf(": Elite3D");

	model = getpropstring(sc->sc_node, "model");
	if (model == NULL || strlen(model) == 0)
		model = "unknown";

	DAC_WRITE(sc, FFB_DAC_TYPE, DAC_TYPE_GETREV);
	sc->sc_dacrev = DAC_READ(sc, FFB_DAC_VALUE) >> 28;

	printf(", model %s, dac %u", model, sc->sc_dacrev);

	if (sc->sc_type == FFB_AFB)
		sc->sc_dacrev = 10;

	fb_setsize(&sc->sc_sunfb, 32, 1152, 900, sc->sc_node, 0);
	/* linesize has a fixed value, compensate */
	sc->sc_sunfb.sf_linebytes = 8192;
	sc->sc_sunfb.sf_fbsize = sc->sc_sunfb.sf_height * 8192;

	printf(", %dx%d\n", sc->sc_sunfb.sf_width, sc->sc_sunfb.sf_height);

	sc->sc_sunfb.sf_ro.ri_bits = (void *)bus_space_vaddr(sc->sc_bt,
	    sc->sc_pixel_h);
	sc->sc_sunfb.sf_ro.ri_hw = sc;
	fbwscons_init(&sc->sc_sunfb, 0, sc->sc_console);

	if ((sc->sc_sunfb.sf_dev.dv_cfdata->cf_flags & CREATOR_CFFLAG_NOACCEL)
	    == 0) {
		sc->sc_sunfb.sf_ro.ri_ops.eraserows = creator_ras_eraserows;
		sc->sc_sunfb.sf_ro.ri_ops.erasecols = creator_ras_erasecols;
		sc->sc_sunfb.sf_ro.ri_ops.copyrows = creator_ras_copyrows;
		creator_ras_init(sc);

#ifndef SMALL_KERNEL
		/*
		 * Elite3D cards need a firmware for accelerated X to
		 * work.  Console framebuffer acceleration will work
		 * without it though, so doing this late should be
		 * fine.
		 */
		if (sc->sc_type == FFB_AFB)
			config_mountroot(self, creator_load_firmware);
#endif /* SMALL_KERNEL */
	}

	if (sc->sc_console)
		fbwscons_console_init(&sc->sc_sunfb, -1);

	fbwscons_attach(&sc->sc_sunfb, &creator_accessops, sc->sc_console);
	return;

unmap_fbc:
	bus_space_unmap(sc->sc_bt, sc->sc_fbc_h,
	    ma->ma_reg[FFB_REG_FBC].ur_len);
unmap_dfb24:
	bus_space_unmap(sc->sc_bt, sc->sc_pixel_h,
	    ma->ma_reg[FFB_REG_DFB24].ur_len);
}

int
creator_ioctl(v, cmd, data, flags, p)
	void *v;
	u_long cmd;
	caddr_t data;
	int flags;
	struct proc *p;
{
	struct creator_softc *sc = v;
	struct wsdisplay_cursor *curs;
	struct wsdisplay_fbinfo *wdf;
	struct wsdisplay_curpos *pos;
	u_char r[2], g[2], b[2];
	int error;

	switch (cmd) {
	case WSDISPLAYIO_GTYPE:
		*(u_int *)data = WSDISPLAY_TYPE_SUNFFB;
		break;
	case WSDISPLAYIO_SMODE:
		sc->sc_mode = *(u_int *)data;
		if (sc->sc_mode == WSDISPLAYIO_MODE_EMUL) {
			struct rasops_info *ri = &sc->sc_sunfb.sf_ro;
			long attr;

			if ((sc->sc_sunfb.sf_dev.dv_cfdata->cf_flags &
			    CREATOR_CFFLAG_NOACCEL) == 0)
				creator_ras_init(sc);

			/* Clear screen. */
			ri->ri_ops.alloc_attr(ri,
			    WSCOL_BLACK, WSCOL_WHITE, WSATTR_WSCOLORS, &attr);
			ri->ri_ops.eraserows(ri, 0, ri->ri_rows, attr);
		} 
		break;
	case WSDISPLAYIO_GINFO:
		wdf = (void *)data;
		wdf->height = sc->sc_sunfb.sf_height;
		wdf->width  = sc->sc_sunfb.sf_width;
		wdf->depth  = 32;
		wdf->cmsize = 0;
		break;
	case WSDISPLAYIO_GETSUPPORTEDDEPTH:
		*(u_int *)data = WSDISPLAYIO_DEPTH_24_32;
		break;
	case WSDISPLAYIO_LINEBYTES:
		*(u_int *)data = sc->sc_sunfb.sf_linebytes;
		break;
	case WSDISPLAYIO_GCURSOR:
		curs = (struct wsdisplay_cursor *)data;
		if (curs->which & WSDISPLAY_CURSOR_DOCUR)
			curs->enable = sc->sc_curs_enabled;
		if (curs->which & WSDISPLAY_CURSOR_DOPOS) {
			curs->pos.x = sc->sc_curs_pos.x;
			curs->pos.y = sc->sc_curs_pos.y;
		}
		if (curs->which & WSDISPLAY_CURSOR_DOHOT) {
			curs->hot.x = sc->sc_curs_hot.x;
			curs->hot.y = sc->sc_curs_hot.y;
		}
		if (curs->which & WSDISPLAY_CURSOR_DOCMAP) {
			curs->cmap.index = 0;
			curs->cmap.count = 2;
			r[0] = sc->sc_curs_fg >> 0;
			g[0] = sc->sc_curs_fg >> 8;
			b[0] = sc->sc_curs_fg >> 16;
			r[1] = sc->sc_curs_bg >> 0;
			g[1] = sc->sc_curs_bg >> 8;
			b[1] = sc->sc_curs_bg >> 16;
			error = copyout(r, curs->cmap.red, sizeof(r));
			if (error)
				return (error);
			error = copyout(g, curs->cmap.green, sizeof(g));
			if (error)
				return (error);
			error = copyout(b, curs->cmap.blue, sizeof(b));
			if (error)
				return (error);
		}
		if (curs->which & WSDISPLAY_CURSOR_DOSHAPE) {
			size_t l;

			curs->size.x = sc->sc_curs_size.x;
			curs->size.y = sc->sc_curs_size.y;
			l = (sc->sc_curs_size.x * sc->sc_curs_size.y) / NBBY;
			error = copyout(sc->sc_curs_image, curs->image, l);
			if (error)
				return (error);
			error = copyout(sc->sc_curs_mask, curs->mask, l);
			if (error)
				return (error);
		}
		break;
	case WSDISPLAYIO_SCURPOS:
		pos = (struct wsdisplay_curpos *)data;
		sc->sc_curs_pos.x = pos->x;
		sc->sc_curs_pos.y = pos->y;
		creator_updatecursor(sc, WSDISPLAY_CURSOR_DOPOS);
		break;
	case WSDISPLAYIO_GCURPOS:
		pos = (struct wsdisplay_curpos *)data;
		pos->x = sc->sc_curs_pos.x;
		pos->y = sc->sc_curs_pos.y;
		break;
	case WSDISPLAYIO_SCURSOR:
		curs = (struct wsdisplay_cursor *)data;
		return (creator_setcursor(sc, curs));
	case WSDISPLAYIO_GCURMAX:
		pos = (struct wsdisplay_curpos *)data;
		pos->x = CREATOR_CURS_MAX;
		pos->y = CREATOR_CURS_MAX;
		break;
	case WSDISPLAYIO_SVIDEO:
	case WSDISPLAYIO_GVIDEO:
		break;

	case WSDISPLAYIO_GETCMAP:
	case WSDISPLAYIO_PUTCMAP:
	default:
		return -1; /* not supported yet */
        }

	return (0);
}

int
creator_setcursor(struct creator_softc *sc, struct wsdisplay_cursor *curs)
{
	u_int8_t r[2], g[2], b[2], image[128], mask[128];
	int error;
	size_t imcount;

	/*
	 * Do stuff that can generate errors first, then we'll blast it
	 * all at once.
	 */
	if (curs->which & WSDISPLAY_CURSOR_DOCMAP) {
		if (curs->cmap.count < 2)
			return (EINVAL);
		error = copyin(curs->cmap.red, r, sizeof(r));
		if (error)
			return (error);
		error = copyin(curs->cmap.green, g, sizeof(g));
		if (error)
			return (error);
		error = copyin(curs->cmap.blue, b, sizeof(b));
		if (error)
			return (error);
	}

	if (curs->which & WSDISPLAY_CURSOR_DOSHAPE) {
		if (curs->size.x > CREATOR_CURS_MAX ||
		    curs->size.y > CREATOR_CURS_MAX)
			return (EINVAL);
		imcount = (curs->size.x * curs->size.y) / NBBY;
		error = copyin(curs->image, image, imcount);
		if (error)
			return (error);
		error = copyin(curs->mask, mask, imcount);
		if (error)
			return (error);
	}

	/*
	 * Ok, everything is in kernel space and sane, update state.
	 */

	if (curs->which & WSDISPLAY_CURSOR_DOCUR)
		sc->sc_curs_enabled = curs->enable;
	if (curs->which & WSDISPLAY_CURSOR_DOPOS) {
		sc->sc_curs_pos.x = curs->pos.x;
		sc->sc_curs_pos.y = curs->pos.y;
	}
	if (curs->which & WSDISPLAY_CURSOR_DOHOT) {
		sc->sc_curs_hot.x = curs->hot.x;
		sc->sc_curs_hot.y = curs->hot.y;
	}
	if (curs->which & WSDISPLAY_CURSOR_DOCMAP) {
		sc->sc_curs_fg = ((r[0] << 0) | (g[0] << 8) | (b[0] << 16));
		sc->sc_curs_bg = ((r[1] << 0) | (g[1] << 8) | (b[1] << 16));
	}
	if (curs->which & WSDISPLAY_CURSOR_DOSHAPE) {
		sc->sc_curs_size.x = curs->size.x;
		sc->sc_curs_size.y = curs->size.y;
		bcopy(image, sc->sc_curs_image, imcount);
		bcopy(mask, sc->sc_curs_mask, imcount);
	}

	creator_updatecursor(sc, curs->which);

	return (0);
}

void
creator_curs_enable(struct creator_softc *sc, u_int ena)
{
	u_int32_t v;

	DAC_WRITE(sc, FFB_DAC_TYPE2, DAC_TYPE2_CURSENAB);
	if (sc->sc_dacrev <= 2)
		v = ena ? 3 : 0;
	else
		v = ena ? 0 : 3;
	DAC_WRITE(sc, FFB_DAC_VALUE2, v);
}

int
creator_updatecursor(struct creator_softc *sc, u_int which)
{
	creator_curs_enable(sc, 0);

	if (which & WSDISPLAY_CURSOR_DOCMAP) {
		DAC_WRITE(sc, FFB_DAC_TYPE2, DAC_TYPE2_CURSCMAP);
		DAC_WRITE(sc, FFB_DAC_VALUE2, sc->sc_curs_fg);
		DAC_WRITE(sc, FFB_DAC_VALUE2, sc->sc_curs_bg);
	}

	if (which & (WSDISPLAY_CURSOR_DOPOS | WSDISPLAY_CURSOR_DOHOT)) {
		u_int32_t x, y;

		x = sc->sc_curs_pos.x + CREATOR_CURS_MAX - sc->sc_curs_hot.x;
		y = sc->sc_curs_pos.y + CREATOR_CURS_MAX - sc->sc_curs_hot.y;
		DAC_WRITE(sc, FFB_DAC_TYPE2, DAC_TYPE2_CURSPOS);
		DAC_WRITE(sc, FFB_DAC_VALUE2,
		    ((x & 0xffff) << 16) | (y & 0xffff));
	}

	if (which & WSDISPLAY_CURSOR_DOCUR)
		creator_curs_enable(sc, sc->sc_curs_enabled);

	return (0);
}

const struct creator_mappings {
	bus_addr_t uoff;
	bus_addr_t poff;
	bus_size_t ulen;
} creator_map[] = {
	{ FFB_VOFF_SFB8R, FFB_POFF_SFB8R, FFB_VLEN_SFB8R },
	{ FFB_VOFF_SFB8G, FFB_POFF_SFB8G, FFB_VLEN_SFB8G },
	{ FFB_VOFF_SFB8B, FFB_POFF_SFB8B, FFB_VLEN_SFB8B },
	{ FFB_VOFF_SFB8X, FFB_POFF_SFB8X, FFB_VLEN_SFB8X },
	{ FFB_VOFF_SFB32, FFB_POFF_SFB32, FFB_VLEN_SFB32 },
	{ FFB_VOFF_SFB64, FFB_POFF_SFB64, FFB_VLEN_SFB64 },
	{ FFB_VOFF_FBC_REGS, FFB_POFF_FBC_REGS, FFB_VLEN_FBC_REGS },
	{ FFB_VOFF_BM_FBC_REGS, FFB_POFF_BM_FBC_REGS, FFB_VLEN_BM_FBC_REGS },
	{ FFB_VOFF_DFB8R, FFB_POFF_DFB8R, FFB_VLEN_DFB8R },
	{ FFB_VOFF_DFB8G, FFB_POFF_DFB8G, FFB_VLEN_DFB8G },
	{ FFB_VOFF_DFB8B, FFB_POFF_DFB8B, FFB_VLEN_DFB8B },
	{ FFB_VOFF_DFB8X, FFB_POFF_DFB8X, FFB_VLEN_DFB8X },
	{ FFB_VOFF_DFB24, FFB_POFF_DFB24, FFB_VLEN_DFB24 },
	{ FFB_VOFF_DFB32, FFB_POFF_DFB32, FFB_VLEN_DFB32 },
	{ FFB_VOFF_DFB422A, FFB_POFF_DFB422A, FFB_VLEN_DFB422A },
	{ FFB_VOFF_DFB422AD, FFB_POFF_DFB422AD, FFB_VLEN_DFB422AD },
	{ FFB_VOFF_DFB24B, FFB_POFF_DFB24B, FFB_VLEN_DFB24B },
	{ FFB_VOFF_DFB422B, FFB_POFF_DFB422B, FFB_VLEN_DFB422B },
	{ FFB_VOFF_DFB422BD, FFB_POFF_DFB422BD, FFB_VLEN_DFB422BD },
	{ FFB_VOFF_SFB16Z, FFB_POFF_SFB16Z, FFB_VLEN_SFB16Z },
	{ FFB_VOFF_SFB8Z, FFB_POFF_SFB8Z, FFB_VLEN_SFB8Z },
	{ FFB_VOFF_SFB422, FFB_POFF_SFB422, FFB_VLEN_SFB422 },
	{ FFB_VOFF_SFB422D, FFB_POFF_SFB422D, FFB_VLEN_SFB422D },
	{ FFB_VOFF_FBC_KREGS, FFB_POFF_FBC_KREGS, FFB_VLEN_FBC_KREGS },
	{ FFB_VOFF_DAC, FFB_POFF_DAC, FFB_VLEN_DAC },
	{ FFB_VOFF_PROM, FFB_POFF_PROM, FFB_VLEN_PROM },
	{ FFB_VOFF_EXP, FFB_POFF_EXP, FFB_VLEN_EXP },
};
#define	CREATOR_NMAPPINGS       nitems(creator_map)

paddr_t
creator_mmap(vsc, off, prot)
	void *vsc;
	off_t off;
	int prot;
{
	paddr_t x;
	struct creator_softc *sc = vsc;
	int i;

	switch (sc->sc_mode) {
	case WSDISPLAYIO_MODE_MAPPED:
		/* Turn virtual offset into physical offset */
		for (i = 0; i < CREATOR_NMAPPINGS; i++) {
			if (off >= creator_map[i].uoff &&
			    off < (creator_map[i].uoff + creator_map[i].ulen))
				break;
		}
		if (i == CREATOR_NMAPPINGS)
			break;

		off -= creator_map[i].uoff;
		off += creator_map[i].poff;
		off += sc->sc_addrs[0];

		/* Map based on physical offset */
		for (i = 0; i < sc->sc_nreg; i++) {
			/* Before this set? */
			if (off < sc->sc_addrs[i])
				continue;
			/* After this set? */
			if (off >= (sc->sc_addrs[i] + sc->sc_sizes[i]))
				continue;

			x = bus_space_mmap(sc->sc_bt, 0, off, prot,
			    BUS_SPACE_MAP_LINEAR);
			return (x);
		}
		break;
	case WSDISPLAYIO_MODE_DUMBFB:
		if (sc->sc_nreg <= FFB_REG_DFB24)
			break;
		if (off >= 0 && off < sc->sc_sizes[FFB_REG_DFB24])
			return (bus_space_mmap(sc->sc_bt,
			    sc->sc_addrs[FFB_REG_DFB24], off, prot,
			    BUS_SPACE_MAP_LINEAR));
		break;
	}

	return (-1);
}

void
creator_ras_fifo_wait(sc, n)
	struct creator_softc *sc;
	int n;
{
	int32_t cache = sc->sc_fifo_cache;

	if (cache < n) {
		do {
			cache = FBC_READ(sc, FFB_FBC_UCSR);
			cache = (cache & FBC_UCSR_FIFO_MASK) - 8;
		} while (cache < n);
	}
	sc->sc_fifo_cache = cache - n;
}

void
creator_ras_wait(sc)
	struct creator_softc *sc;
{
	u_int32_t ucsr, r;

	while (1) {
		ucsr = FBC_READ(sc, FFB_FBC_UCSR);
		if ((ucsr & (FBC_UCSR_FB_BUSY|FBC_UCSR_RP_BUSY)) == 0)
			break;
		r = ucsr & (FBC_UCSR_READ_ERR | FBC_UCSR_FIFO_OVFL);
		if (r != 0)
			FBC_WRITE(sc, FFB_FBC_UCSR, r);
	}
}

void
creator_ras_init(sc)
	struct creator_softc *sc;
{
	creator_ras_fifo_wait(sc, 7);
	FBC_WRITE(sc, FFB_FBC_PPC,
	    FBC_PPC_VCE_DIS | FBC_PPC_TBE_OPAQUE |
	    FBC_PPC_APE_DIS | FBC_PPC_CS_CONST);
	FBC_WRITE(sc, FFB_FBC_FBC,
	    FFB_FBC_WB_A | FFB_FBC_RB_A | FFB_FBC_SB_BOTH |
	    FFB_FBC_XE_OFF | FFB_FBC_RGBE_MASK);
	FBC_WRITE(sc, FFB_FBC_ROP, FBC_ROP_NEW);
	FBC_WRITE(sc, FFB_FBC_DRAWOP, FBC_DRAWOP_RECTANGLE);
	FBC_WRITE(sc, FFB_FBC_PMASK, 0xffffffff);
	FBC_WRITE(sc, FFB_FBC_FONTINC, 0x10000);
	sc->sc_fg_cache = 0;
	FBC_WRITE(sc, FFB_FBC_FG, sc->sc_fg_cache);
	creator_ras_wait(sc);
}

int
creator_ras_eraserows(cookie, row, n, attr)
	void *cookie;
	int row, n;
	long int attr;
{
	struct rasops_info *ri = cookie;
	struct creator_softc *sc = ri->ri_hw;
	int bg, fg;

	if (row < 0) {
		n += row;
		row = 0;
	}
	if (row + n > ri->ri_rows)
		n = ri->ri_rows - row;
	if (n <= 0)
		return 0;

	ri->ri_ops.unpack_attr(cookie, attr, &fg, &bg, NULL);
	creator_ras_fill(sc);
	creator_ras_setfg(sc, ri->ri_devcmap[bg]);
	creator_ras_fifo_wait(sc, 4);
	if ((n == ri->ri_rows) && (ri->ri_flg & RI_FULLCLEAR)) {
		FBC_WRITE(sc, FFB_FBC_BY, 0);
		FBC_WRITE(sc, FFB_FBC_BX, 0);
		FBC_WRITE(sc, FFB_FBC_BH, ri->ri_height);
		FBC_WRITE(sc, FFB_FBC_BW, ri->ri_width);
	} else {
		row *= ri->ri_font->fontheight;
		FBC_WRITE(sc, FFB_FBC_BY, ri->ri_yorigin + row);
		FBC_WRITE(sc, FFB_FBC_BX, ri->ri_xorigin);
		FBC_WRITE(sc, FFB_FBC_BH, n * ri->ri_font->fontheight);
		FBC_WRITE(sc, FFB_FBC_BW, ri->ri_emuwidth);
	}
	creator_ras_wait(sc);

	return 0;
}

int
creator_ras_erasecols(cookie, row, col, n, attr)
	void *cookie;
	int row, col, n;
	long int attr;
{
	struct rasops_info *ri = cookie;
	struct creator_softc *sc = ri->ri_hw;
	int fg, bg;

	if ((row < 0) || (row >= ri->ri_rows))
		return 0;
	if (col < 0) {
		n += col;
		col = 0;
	}
	if (col + n > ri->ri_cols)
		n = ri->ri_cols - col;
	if (n <= 0)
		return 0;
	n *= ri->ri_font->fontwidth;
	col *= ri->ri_font->fontwidth;
	row *= ri->ri_font->fontheight;

	ri->ri_ops.unpack_attr(cookie, attr, &fg, &bg, NULL);
	creator_ras_fill(sc);
	creator_ras_setfg(sc, ri->ri_devcmap[bg]);
	creator_ras_fifo_wait(sc, 4);
	FBC_WRITE(sc, FFB_FBC_BY, ri->ri_yorigin + row);
	FBC_WRITE(sc, FFB_FBC_BX, ri->ri_xorigin + col);
	FBC_WRITE(sc, FFB_FBC_BH, ri->ri_font->fontheight);
	FBC_WRITE(sc, FFB_FBC_BW, n - 1);
	creator_ras_wait(sc);

	return 0;
}

void
creator_ras_fill(sc)
	struct creator_softc *sc;
{
	creator_ras_fifo_wait(sc, 2);
	FBC_WRITE(sc, FFB_FBC_ROP, FBC_ROP_NEW);
	FBC_WRITE(sc, FFB_FBC_DRAWOP, FBC_DRAWOP_RECTANGLE);
	creator_ras_wait(sc);
}

int
creator_ras_copyrows(cookie, src, dst, n)
	void *cookie;
	int src, dst, n;
{
	struct rasops_info *ri = cookie;
	struct creator_softc *sc = ri->ri_hw;

	if (dst == src)
		return 0;
	if (src < 0) {
		n += src;
		src = 0;
	}
	if ((src + n) > ri->ri_rows)
		n = ri->ri_rows - src;
	if (dst < 0) {
		n += dst;
		dst = 0;
	}
	if ((dst + n) > ri->ri_rows)
		n = ri->ri_rows - dst;
	if (n <= 0)
		return 0;
	n *= ri->ri_font->fontheight;
	src *= ri->ri_font->fontheight;
	dst *= ri->ri_font->fontheight;

	creator_ras_fifo_wait(sc, 8);
	FBC_WRITE(sc, FFB_FBC_ROP, FBC_ROP_OLD | (FBC_ROP_OLD << 8));
	FBC_WRITE(sc, FFB_FBC_DRAWOP, FBC_DRAWOP_VSCROLL);
	FBC_WRITE(sc, FFB_FBC_BY, ri->ri_yorigin + src);
	FBC_WRITE(sc, FFB_FBC_BX, ri->ri_xorigin);
	FBC_WRITE(sc, FFB_FBC_DY, ri->ri_yorigin + dst);
	FBC_WRITE(sc, FFB_FBC_DX, ri->ri_xorigin);
	FBC_WRITE(sc, FFB_FBC_BH, n);
	FBC_WRITE(sc, FFB_FBC_BW, ri->ri_emuwidth);
	creator_ras_wait(sc);

	return 0;
}

void
creator_ras_setfg(sc, fg)
	struct creator_softc *sc;
	int32_t fg;
{
	creator_ras_fifo_wait(sc, 1);
	if (fg == sc->sc_fg_cache)
		return;
	sc->sc_fg_cache = fg;
	FBC_WRITE(sc, FFB_FBC_FG, fg);
	creator_ras_wait(sc);
}

#ifndef SMALL_KERNEL
struct creator_firmware {
	char		fw_ident[8];
	u_int32_t	fw_size;
	u_int32_t	fw_reserved[2];
	u_int32_t	fw_ucode[0];
};

#define CREATOR_FIRMWARE_REV	0x101

void
creator_load_firmware(struct device *self)
{
	struct creator_softc *sc = (struct creator_softc *)self;
	struct creator_firmware *fw;
	u_int32_t ascr;
	size_t buflen;
	u_char *buf;
	int error;

	error = loadfirmware("afb", &buf, &buflen);
	if (error) {
		printf("%s: error %d, could not read firmware %s\n",
		       sc->sc_sunfb.sf_dev.dv_xname, error, "afb");
		return;
	}

	fw = (struct creator_firmware *)buf;
	if (sizeof(*fw) > buflen ||
	    fw->fw_size * sizeof(u_int32_t) > (buflen - sizeof(*fw))) {
		printf("%s: corrupt firmware\n", sc->sc_sunfb.sf_dev.dv_xname);
		free(buf, M_DEVBUF, 0);
		return;
	}

	printf("%s: firmware rev %d.%d.%d\n", sc->sc_sunfb.sf_dev.dv_xname,
	       (fw->fw_ucode[CREATOR_FIRMWARE_REV] >> 16) & 0xff,
	       (fw->fw_ucode[CREATOR_FIRMWARE_REV] >> 8) & 0xff,
	       fw->fw_ucode[CREATOR_FIRMWARE_REV] & 0xff);

	ascr = FBC_READ(sc, FFB_FBC_ASCR);

	/* Stop all floats. */
	FBC_WRITE(sc, FFB_FBC_FEM, ascr & 0x3f);
	FBC_WRITE(sc, FFB_FBC_ASCR, FBC_ASCR_STOP);

	creator_ras_wait(sc);

	/* Load firmware into all secondary floats. */
	if (ascr & 0x3e) {
		FBC_WRITE(sc, FFB_FBC_FEM, ascr & 0x3e);
		creator_load_sram(sc, fw->fw_ucode, fw->fw_size);
	}

	/* Load firmware into primary float. */
	FBC_WRITE(sc, FFB_FBC_FEM, ascr & 0x01);
	creator_load_sram(sc, fw->fw_ucode, fw->fw_size);

	/* Restart all floats. */
	FBC_WRITE(sc, FFB_FBC_FEM, ascr & 0x3f);
	FBC_WRITE(sc, FFB_FBC_ASCR, FBC_ASCR_RESTART);

	creator_ras_wait(sc);

	free(buf, M_DEVBUF, 0);
}
#endif /* SMALL_KERNEL */

void
creator_load_sram(struct creator_softc *sc, u_int32_t *ucode, u_int32_t size)
{
	uint64_t pstate, fprs;
	caddr_t sram;

	sram = bus_space_vaddr(sc->sc_bt, sc->sc_fbc_h) + FFB_FBC_SRAM36;

	/*
	 * Apparently, loading the firmware into SRAM needs to be done
	 * using block copies.  And block copies use the
	 * floating-point registers.  Generally, using the FPU in the
	 * kernel is verboten.  But since we load the firmware before
	 * userland processes are started, thrashing the
	 * floating-point registers is fine.  We do need to enable the
	 * FPU before we access them though, otherwise we'll trap.
	 */
	pstate = sparc_rdpr(pstate);
	sparc_wrpr(pstate, pstate | PSTATE_PEF, 0);
	fprs = sparc_rd(fprs);
	sparc_wr(fprs, FPRS_FEF, 0);

	FBC_WRITE(sc, FFB_FBC_SRAMAR, 0);

	while (size > 0) {
		creator_ras_fifo_wait(sc, 16);

		__asm__ volatile("ld	[%0 + 0x00], %%f1\n\t"
				     "ld	[%0 + 0x04], %%f0\n\t"
				     "ld	[%0 + 0x08], %%f3\n\t"
				     "ld	[%0 + 0x0c], %%f2\n\t"
				     "ld	[%0 + 0x10], %%f5\n\t"
				     "ld	[%0 + 0x14], %%f4\n\t"
				     "ld	[%0 + 0x18], %%f7\n\t"
				     "ld	[%0 + 0x1c], %%f6\n\t"
				     "ld	[%0 + 0x20], %%f9\n\t"
				     "ld	[%0 + 0x24], %%f8\n\t"
				     "ld	[%0 + 0x28], %%f11\n\t"
				     "ld	[%0 + 0x2c], %%f10\n\t"
				     "ld	[%0 + 0x30], %%f13\n\t"
				     "ld	[%0 + 0x34], %%f12\n\t"
				     "ld	[%0 + 0x38], %%f15\n\t"
				     "ld	[%0 + 0x3c], %%f14\n\t"
				     "membar	#Sync\n\t"
				     "stda	%%f0, [%1] 240\n\t"
				     "membar	#Sync"
				     : : "r" (ucode), "r" (sram));

		ucode += 16;
		size -= 16;
	}

	sparc_wr(fprs, fprs, 0);
	sparc_wrpr(pstate, pstate, 0);

	creator_ras_wait(sc);
}
@


1.50
log
@Replace mountroothook_establish(9) by config_mountroot(9) a narrower API
similar to config_defer(9).

ok mikeb@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: creator.c,v 1.49 2015/01/26 20:25:38 miod Exp $	*/
a28 1
#include <sys/types.h>
@


1.49
log
@Print frame buffer resolution at attach time.
@
text
@d1 1
a1 1
/*	$OpenBSD: creator.c,v 1.48 2014/07/12 18:44:43 tedu Exp $	*/
d68 1
a68 1
void	creator_load_firmware(void *);
d203 2
a204 2
		if (sc->sc_type == FFB_AFB) 
			mountroothook_establish(creator_load_firmware, sc);
d747 1
a747 1
creator_load_firmware(void *vsc)
d749 1
a749 1
	struct creator_softc *sc = vsc;
@


1.48
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: creator.c,v 1.47 2014/03/29 18:09:30 guenther Exp $	*/
d172 1
a172 1
	printf(", model %s, dac %u\n", model, sc->sc_dacrev);
d181 2
@


1.47
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: creator.c,v 1.46 2013/10/20 20:07:27 miod Exp $	*/
d765 1
a765 1
		free(buf, M_DEVBUF);
d798 1
a798 1
	free(buf, M_DEVBUF);
@


1.46
log
@Use C99 named initializers for struct wsdisplay_accessops fields.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: creator.c,v 1.45 2009/12/16 11:06:17 jasper Exp $	*/
d829 1
a829 1
		__asm__ __volatile__("ld	[%0 + 0x00], %%f1\n\t"
@


1.45
log
@- use nitems() inside a descriptive macro name

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: creator.c,v 1.44 2009/12/02 20:11:17 deraadt Exp $	*/
d73 2
a74 9
	creator_ioctl,
	creator_mmap,
	NULL,	/* alloc_screen */
	NULL,	/* free_screen */
	NULL,	/* show_screen */
	NULL,	/* load_font */
	NULL,	/* scrollback */
	NULL,	/* getchar */
	NULL,	/* burner */
@


1.44
log
@no firmware on ramdisks; ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: creator.c,v 1.43 2009/11/30 23:32:57 kettenis Exp $	*/
d493 1
a493 1
#define	CREATOR_NMAPPINGS	(sizeof(creator_map)/sizeof(creator_map[0]))
@


1.43
log
@Load firmware that is needed for accelerated X on Elite3D boards.
The firmware is loaded from /etc/firmware/afb, which will be provided soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: creator.c,v 1.42 2009/09/05 14:09:35 miod Exp $	*/
d67 1
d69 1
d201 1
d210 1
d741 1
d807 1
@


1.42
log
@Change the wsdisplay_emulops return types from void to int; emulops will now
return zero on success and nonzero on failure.
This commit only performs mechanical changes for the existing emulops to
always return zero.
@
text
@d1 1
a1 1
/*	$OpenBSD: creator.c,v 1.41 2009/07/16 21:03:09 kettenis Exp $	*/
d35 1
a35 1
#include <sys/timeout.h>
d53 1
d62 1
d67 3
d198 9
d734 124
@


1.41
log
@Clean up after X.

help & ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: creator.c,v 1.40 2008/12/27 17:23:01 miod Exp $	*/
d56 3
a58 3
void	creator_ras_copyrows(void *, int, int, int);
void	creator_ras_erasecols(void *, int, int, int, long int);
void	creator_ras_eraserows(void *, int, int, long int);
d581 1
a581 1
void
d598 1
a598 1
		return;
d617 2
d621 1
a621 1
void
d632 1
a632 1
		return;
d640 1
a640 1
		return;
d654 2
d668 1
a668 1
void
d677 1
a677 1
		return;
d691 1
a691 1
		return;
d706 2
@


1.40
log
@Sync the sparc64 fb* api with the recent changes done on sparc.
@
text
@d1 1
a1 1
/*	$OpenBSD: creator.c,v 1.39 2007/03/06 23:10:26 kettenis Exp $	*/
d230 13
@


1.39
log
@Implement WSDISPLAYIO_GETSUPPORTEDDEPTH; makes X actually work if you follow
the instructions in /usr/X11R6/README.
@
text
@d1 1
a1 1
/*	$OpenBSD: creator.c,v 1.38 2006/12/17 22:18:16 miod Exp $	*/
a51 5
int	creator_alloc_screen(void *, const struct wsscreen_descr *, void **,
	    int *, int *, long *);
void	creator_free_screen(void *, void *);
int	creator_show_screen(void *, void *, int, void (*cb)(void *, int, int),
	    void *);
d68 4
a71 4
	creator_alloc_screen,
	creator_free_screen,
	creator_show_screen,
	NULL,	/* load font */
d185 1
a185 1
	fbwscons_init(&sc->sc_sunfb, sc->sc_console ? 0 : RI_CLEAR);
d195 1
a195 1
	if (sc->sc_console) {
a196 1
	}
a425 43
	return (0);
}

int
creator_alloc_screen(v, type, cookiep, curxp, curyp, attrp)
	void *v;
	const struct wsscreen_descr *type;
	void **cookiep;
	int *curxp, *curyp;
	long *attrp;
{
	struct creator_softc *sc = v;

	if (sc->sc_nscreens > 0)
		return (ENOMEM);

	*cookiep = &sc->sc_sunfb.sf_ro;
	*curyp = 0;
	*curxp = 0;
	sc->sc_sunfb.sf_ro.ri_ops.alloc_attr(&sc->sc_sunfb.sf_ro,
	    WSCOL_BLACK, WSCOL_WHITE, WSATTR_WSCOLORS, attrp);
	sc->sc_nscreens++;
	return (0);
}

void
creator_free_screen(v, cookie)
	void *v;
	void *cookie;
{
	struct creator_softc *sc = v;

	sc->sc_nscreens--;
}

int
creator_show_screen(v, cookie, waitok, cb, cbarg)
	void *v;
	void *cookie;
	int waitok;
	void (*cb)(void *, int, int);
	void *cbarg;
{
@


1.38
log
@Remove unnecessary <dev/wscons/wscons_raster.h> inclusion.
@
text
@d1 1
a1 1
/*	$OpenBSD: creator.c,v 1.37 2006/12/02 11:21:37 miod Exp $	*/
d243 3
@


1.37
log
@Use the unpack_attr emulops instead of doing an inline rasops_unpack_attr.
@
text
@d1 1
a1 1
/*	$OpenBSD: creator.c,v 1.36 2006/06/30 21:38:19 miod Exp $	*/
a42 1
#include <dev/wscons/wscons_raster.h>
@


1.36
log
@For 32bit sun frame buffers, tweak ri_devcmap to get the BoW palette instead
of needing different WSCOL_{BLACK,WHITE} values than 8bit frame buffers.

This allows us to not special case the alloc_attr() invocations depending
on the color depth, and to make WSCOL_{BLACK,WHITE} constants again in the
wsemul_sun land.
@
text
@d1 1
a1 1
/*	$OpenBSD: creator.c,v 1.35 2006/05/15 21:38:36 miod Exp $	*/
d623 1
d634 1
d636 1
a636 1
	creator_ras_setfg(sc, ri->ri_devcmap[(attr >> 16) & 0xf]);
d661 1
d677 1
d679 1
a679 1
	creator_ras_setfg(sc, ri->ri_devcmap[(attr >> 16) & 0xf]);
@


1.35
log
@Merge creator attachment code again, it turns out the upa/mainbus attachment
code split is not necessary after all; ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: creator.c,v 1.34 2005/04/05 21:49:33 miod Exp $	*/
d450 1
a450 1
	    0, 0, 0, attrp);
@


1.34
log
@Off-by-ones in register comparisons.
@
text
@d1 1
a1 1
/*	$OpenBSD: creator.c,v 1.33 2005/03/15 18:40:15 miod Exp $	*/
d50 2
d87 17
d105 3
a107 1
creator_attach(struct creator_softc *sc)
d109 4
d116 39
a154 1
	printf(":");
d165 1
a165 1
			printf(" Creator3D");
d167 1
a167 1
			printf(" Creator");
d169 1
a169 1
		printf(" Elite3D");
d206 8
@


1.33
log
@Take care of updating the PROMs view of the cursor position in the common fb
code, rather than doing this in only a subset of the fb drivers.
@
text
@d1 1
a1 1
/*	$OpenBSD: creator.c,v 1.32 2005/03/07 16:44:52 miod Exp $	*/
d480 1
a480 1
		if (sc->sc_nreg < FFB_REG_DFB24)
@


1.32
log
@Do not bother passing the blanking routine to fbwscons_console_init(),
as fbwscons_attach() can find it on its own.
@
text
@d1 1
a1 1
/*	$OpenBSD: creator.c,v 1.31 2005/01/05 23:04:25 miod Exp $	*/
a62 1
void	creator_ras_updatecursor(struct rasops_info *);
a138 1
		sc->sc_sunfb.sf_ro.ri_updatecursor = creator_ras_updatecursor;
a673 12
}

void
creator_ras_updatecursor(ri)
	struct rasops_info *ri;
{
	struct creator_softc *sc = ri->ri_hw;

	if (sc->sc_sunfb.sf_crowp != NULL)
		*sc->sc_sunfb.sf_crowp = ri->ri_crow;
	if (sc->sc_sunfb.sf_ccolp != NULL)
		*sc->sc_sunfb.sf_ccolp = ri->ri_ccol;
@


1.31
log
@Let wsdisplay drivers return zero for WSDISPLAYIO_[GS]VIDEO ioctls - most
of the work is done in the upper layer, but they get to see the ioctl,
so don't always return an error.
@
text
@d1 1
a1 1
/*	$OpenBSD: creator.c,v 1.30 2004/11/29 22:07:40 miod Exp $	*/
d141 1
a141 2
		fbwscons_console_init(&sc->sc_sunfb, -1,
		    NULL);
@


1.30
log
@Move the struct wsscreen_descr from a per-driver global to a per-instance
field of the sunfb structure. This allows multiple instances of the same driver,
but with different resolutions (such as a couple of vigra or a TGX cgsix and
a TGX+ cgsix) to use distinct wsscreen_descr structures featuring different
resolution information.

Doing this allows more wsscreen_descr fiddling inside the sparc* fb api,
and results in some code shrinkage (about 4KB on sparc GENERIC).
@
text
@d1 1
a1 1
/*	$OpenBSD: creator.c,v 1.29 2003/06/24 19:41:33 miod Exp $	*/
d246 2
@


1.29
log
@Revert the addition of the blanking code - it will corrupt displays after long
blanking periods...
@
text
@d1 1
a1 1
/*	$OpenBSD: creator.c,v 1.28 2003/06/23 16:49:44 jason Exp $	*/
a49 14
struct wsscreen_descr creator_stdscreen = {
	"std",
};

const struct wsscreen_descr *creator_scrlist[] = {
	&creator_stdscreen,
	/* XXX other formats? */
};

struct wsscreen_list creator_screenlist = {
	sizeof(creator_scrlist) / sizeof(struct wsscreen_descr *),
	    creator_scrlist
};

a88 1
	struct wsemuldisplaydev_attach_args waa;
a138 5
	creator_stdscreen.capabilities = sc->sc_sunfb.sf_ro.ri_caps;
	creator_stdscreen.nrows = sc->sc_sunfb.sf_ro.ri_rows;
	creator_stdscreen.ncols = sc->sc_sunfb.sf_ro.ri_cols;
	creator_stdscreen.textops = &sc->sc_sunfb.sf_ro.ri_ops;

d141 1
a141 1
		fbwscons_console_init(&sc->sc_sunfb, &creator_stdscreen, -1,
d145 1
a145 5
	waa.console = sc->sc_console;
	waa.scrdata = &creator_screenlist;
	waa.accessops = &creator_accessops;
	waa.accesscookie = sc;
	config_found(&sc->sc_sunfb.sf_dev, &waa, wsemuldisplaydevprint);
@


1.28
log
@Remove some debugging cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: creator.c,v 1.27 2003/06/20 19:54:37 miod Exp $	*/
a69 1
void	creator_burner(void *, u_int, u_int);
d93 1
a93 1
	creator_burner
d162 1
a162 1
		    creator_burner);
a427 23
}

void
creator_burner(void *v, u_int on, u_int flags)
{
	struct creator_softc *sc = v;
	u_int32_t tgen;

	DAC_WRITE(sc, FFB_DAC_TYPE, DAC_TYPE_BLANK);
	tgen = DAC_READ(sc, FFB_DAC_VALUE);
	if (on) {
		tgen |= DAC_BLANK_VIDEO_ENABLE;
		tgen &= ~(DAC_BLANK_HSYNC_DISABLE | DAC_BLANK_VSYNC_DISABLE);
	} else {
		tgen &= ~DAC_BLANK_VIDEO_ENABLE;
#if 0 /* yields very strange results sometimes when unblanking... */
		if (flags & WSDISPLAY_BURN_VBLANK)
			tgen |= DAC_BLANK_HSYNC_DISABLE |
			    DAC_BLANK_VSYNC_DISABLE;
#endif
	}
	DAC_WRITE(sc, FFB_DAC_TYPE, DAC_TYPE_BLANK);
	DAC_WRITE(sc, FFB_DAC_VALUE, tgen);
@


1.27
log
@Screen blanker routine for Creator, adapted from the X11 sunffb driver code.
Tested by jason@@ and I.
@
text
@d1 1
a1 1
/*	$OpenBSD: creator.c,v 1.26 2003/06/17 17:35:40 miod Exp $	*/
d507 1
a507 2
		if (i == CREATOR_NMAPPINGS) {
			printf("didn't find %llx\n", off);
a508 1
		}
@


1.26
log
@Extend the sunfb structure to take care of the PROM cursor position
pointers, and adapt creator to the fb api.
ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: creator.c,v 1.25 2003/06/02 20:02:49 jason Exp $	*/
d70 1
d94 1
a94 1
	NULL,	/* burner */
d163 1
a163 1
		    NULL);
d429 23
@


1.25
log
@nuke terms 3 & 4
@
text
@d1 1
a1 1
/*	$OpenBSD: creator.c,v 1.24 2003/05/12 19:37:33 jason Exp $	*/
d45 1
a51 5
	0, 0,	/* will be filled in -- XXX shouldn't, it's global. */
	0,
	0, 0,
	WSSCREEN_UNDERLINE | WSSCREEN_HILIT |
	WSSCREEN_REVERSE | WSSCREEN_WSCOLORS
a70 1
static int a2int(char *, int);
a79 1
void	creator_ras_updatecursor(struct rasops_info *);
d136 6
a141 9
	sc->sc_depth = 24;
	sc->sc_linebytes = 8192;
	sc->sc_height = getpropint(sc->sc_node, "height", 0);
	sc->sc_width = getpropint(sc->sc_node, "width", 0);

	sc->sc_rasops.ri_depth = 32;
	sc->sc_rasops.ri_stride = sc->sc_linebytes;
	sc->sc_rasops.ri_flg = RI_CENTER;
	sc->sc_rasops.ri_bits = (void *)bus_space_vaddr(sc->sc_bt,
d143 2
d146 5
a150 13
	sc->sc_rasops.ri_width = sc->sc_width;
	sc->sc_rasops.ri_height = sc->sc_height;
	sc->sc_rasops.ri_hw = sc;

	rasops_init(&sc->sc_rasops,
	    a2int(getpropstring(optionsnode, "screen-#rows"), 34),
	    a2int(getpropstring(optionsnode, "screen-#columns"), 80));

	if ((sc->sc_dv.dv_cfdata->cf_flags & CREATOR_CFFLAG_NOACCEL) == 0) {
		sc->sc_rasops.ri_hw = sc;
		sc->sc_rasops.ri_ops.eraserows = creator_ras_eraserows;
		sc->sc_rasops.ri_ops.erasecols = creator_ras_erasecols;
		sc->sc_rasops.ri_ops.copyrows = creator_ras_copyrows;
d154 4
a157 3
	creator_stdscreen.nrows = sc->sc_rasops.ri_rows;
	creator_stdscreen.ncols = sc->sc_rasops.ri_cols;
	creator_stdscreen.textops = &sc->sc_rasops.ri_ops;
d160 3
a162 21
		long defattr;

		if (romgetcursoraddr(&sc->sc_crowp, &sc->sc_ccolp))
			sc->sc_ccolp = sc->sc_crowp = NULL;
		if (sc->sc_ccolp != NULL)
			sc->sc_rasops.ri_ccol = *sc->sc_ccolp;
		if (sc->sc_crowp != NULL)
			sc->sc_rasops.ri_crow = *sc->sc_crowp;

		/* fix color choice */
		wscol_white = 0;
		wscol_black = 255;
		wskernel_bg = 0;
		wskernel_fg = 255;

		sc->sc_rasops.ri_ops.alloc_attr(&sc->sc_rasops,
		    0, 0, 0, &defattr);
		sc->sc_rasops.ri_updatecursor = creator_ras_updatecursor;

		wsdisplay_cnattach(&creator_stdscreen, &sc->sc_rasops,
		    sc->sc_rasops.ri_ccol, sc->sc_rasops.ri_crow, defattr);
d169 1
a169 1
	config_found(&sc->sc_dv, &waa, wsemuldisplaydevprint);
d196 2
a197 2
		wdf->height = sc->sc_height;
		wdf->width  = sc->sc_width;
d199 1
a199 1
		wdf->cmsize = 256; /* XXX */
d202 1
a202 1
		*(u_int *)data = sc->sc_linebytes;
d400 1
a400 1
	*cookiep = &sc->sc_rasops;
d403 2
a404 1
	sc->sc_rasops.ri_ops.alloc_attr(&sc->sc_rasops, 0, 0, 0, attrp);
a518 12
static int
a2int(char *cp, int deflt)
{
	int i = 0;

	if (*cp == '\0')
		return (deflt);
	while (*cp != '\0')
		i = i * 10 + *cp++ - '0';
	return (i);
}

d709 4
a712 4
	if (sc->sc_crowp != NULL)
		*sc->sc_crowp = ri->ri_crow;
	if (sc->sc_ccolp != NULL)
		*sc->sc_ccolp = ri->ri_ccol;
@


1.24
log
@use new display types
@
text
@d1 1
a1 1
/*	$OpenBSD: creator.c,v 1.23 2003/03/27 18:17:58 jason Exp $	*/
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Jason L. Wright
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.23
log
@- Add support for the *CURS* ioctls (requires mapping the DAC registers
and tweaking appropriately)
- add support for VADDR->PADDR mappings expected by the X server
- fix attachment error handling (it depended on bus_space_vaddr() working
for non-linear mappings).
@
text
@d1 1
a1 1
/*	$OpenBSD: creator.c,v 1.22 2002/09/10 03:18:59 jason Exp $	*/
d226 1
a226 1
		*(u_int *)data = WSDISPLAY_TYPE_SUN24;
@


1.23.2.1
log
@A sweep to fix remaining files not in sync with the SMP_SYNC_B point.
@
text
@d91 3
d120 6
d139 7
a145 1
	printf(", model %s\n", model);
d218 1
d220 3
d241 66
a306 1

a307 2
		break;/* XXX */

a308 9
		break;/* XXX */

	case WSDISPLAYIO_SVIDEO:
	case WSDISPLAYIO_GVIDEO:
	case WSDISPLAYIO_GCURPOS:
	case WSDISPLAYIO_SCURPOS:
	case WSDISPLAYIO_GCURMAX:
	case WSDISPLAYIO_GCURSOR:
	case WSDISPLAYIO_SCURSOR:
d317 108
d466 35
d507 1
d513 16
d537 3
a539 2
			return (bus_space_mmap(sc->sc_bt, sc->sc_addrs[i],
			    off - sc->sc_addrs[i], prot, BUS_SPACE_MAP_LINEAR));
@


1.23.2.2
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: creator.c,v 1.23.2.1 2003/04/19 19:17:49 niklas Exp $	*/
a90 3
int	creator_setcursor(struct creator_softc *, struct wsdisplay_cursor *);
int	creator_updatecursor(struct creator_softc *, u_int);
void	creator_curs_enable(struct creator_softc *, u_int);
a116 6
	/*
	 * Prom reports only the length of the fcode header, we need
	 * the whole thing.
	 */
	sc->sc_sizes[0] = 0x00400000;

d130 1
a130 7
	DAC_WRITE(sc, FFB_DAC_TYPE, DAC_TYPE_GETREV);
	sc->sc_dacrev = DAC_READ(sc, FFB_DAC_VALUE) >> 28;

	printf(", model %s, dac %u\n", model, sc->sc_dacrev);

	if (sc->sc_type == FFB_AFB)
		sc->sc_dacrev = 10;
a202 1
	struct wsdisplay_cursor *curs;
a203 3
	struct wsdisplay_curpos *pos;
	u_char r[2], g[2], b[2];
	int error;
d222 12
a234 55
		curs = (struct wsdisplay_cursor *)data;
		if (curs->which & WSDISPLAY_CURSOR_DOCUR)
			curs->enable = sc->sc_curs_enabled;
		if (curs->which & WSDISPLAY_CURSOR_DOPOS) {
			curs->pos.x = sc->sc_curs_pos.x;
			curs->pos.y = sc->sc_curs_pos.y;
		}
		if (curs->which & WSDISPLAY_CURSOR_DOHOT) {
			curs->hot.x = sc->sc_curs_hot.x;
			curs->hot.y = sc->sc_curs_hot.y;
		}
		if (curs->which & WSDISPLAY_CURSOR_DOCMAP) {
			curs->cmap.index = 0;
			curs->cmap.count = 2;
			r[0] = sc->sc_curs_fg >> 0;
			g[0] = sc->sc_curs_fg >> 8;
			b[0] = sc->sc_curs_fg >> 16;
			r[1] = sc->sc_curs_bg >> 0;
			g[1] = sc->sc_curs_bg >> 8;
			b[1] = sc->sc_curs_bg >> 16;
			error = copyout(r, curs->cmap.red, sizeof(r));
			if (error)
				return (error);
			error = copyout(g, curs->cmap.green, sizeof(g));
			if (error)
				return (error);
			error = copyout(b, curs->cmap.blue, sizeof(b));
			if (error)
				return (error);
		}
		if (curs->which & WSDISPLAY_CURSOR_DOSHAPE) {
			size_t l;

			curs->size.x = sc->sc_curs_size.x;
			curs->size.y = sc->sc_curs_size.y;
			l = (sc->sc_curs_size.x * sc->sc_curs_size.y) / NBBY;
			error = copyout(sc->sc_curs_image, curs->image, l);
			if (error)
				return (error);
			error = copyout(sc->sc_curs_mask, curs->mask, l);
			if (error)
				return (error);
		}
		break;
	case WSDISPLAYIO_SCURPOS:
		pos = (struct wsdisplay_curpos *)data;
		sc->sc_curs_pos.x = pos->x;
		sc->sc_curs_pos.y = pos->y;
		creator_updatecursor(sc, WSDISPLAY_CURSOR_DOPOS);
		break;
	case WSDISPLAYIO_GCURPOS:
		pos = (struct wsdisplay_curpos *)data;
		pos->x = sc->sc_curs_pos.x;
		pos->y = sc->sc_curs_pos.y;
		break;
a235 11
		curs = (struct wsdisplay_cursor *)data;
		return (creator_setcursor(sc, curs));
	case WSDISPLAYIO_GCURMAX:
		pos = (struct wsdisplay_curpos *)data;
		pos->x = CREATOR_CURS_MAX;
		pos->y = CREATOR_CURS_MAX;
		break;
	case WSDISPLAYIO_SVIDEO:
	case WSDISPLAYIO_GVIDEO:
	case WSDISPLAYIO_GETCMAP:
	case WSDISPLAYIO_PUTCMAP:
a243 108
creator_setcursor(struct creator_softc *sc, struct wsdisplay_cursor *curs)
{
	u_int8_t r[2], g[2], b[2], image[128], mask[128];
	int error;
	size_t imcount;

	/*
	 * Do stuff that can generate errors first, then we'll blast it
	 * all at once.
	 */
	if (curs->which & WSDISPLAY_CURSOR_DOCMAP) {
		if (curs->cmap.count < 2)
			return (EINVAL);
		error = copyin(curs->cmap.red, r, sizeof(r));
		if (error)
			return (error);
		error = copyin(curs->cmap.green, g, sizeof(g));
		if (error)
			return (error);
		error = copyin(curs->cmap.blue, b, sizeof(b));
		if (error)
			return (error);
	}

	if (curs->which & WSDISPLAY_CURSOR_DOSHAPE) {
		if (curs->size.x > CREATOR_CURS_MAX ||
		    curs->size.y > CREATOR_CURS_MAX)
			return (EINVAL);
		imcount = (curs->size.x * curs->size.y) / NBBY;
		error = copyin(curs->image, image, imcount);
		if (error)
			return (error);
		error = copyin(curs->mask, mask, imcount);
		if (error)
			return (error);
	}

	/*
	 * Ok, everything is in kernel space and sane, update state.
	 */

	if (curs->which & WSDISPLAY_CURSOR_DOCUR)
		sc->sc_curs_enabled = curs->enable;
	if (curs->which & WSDISPLAY_CURSOR_DOPOS) {
		sc->sc_curs_pos.x = curs->pos.x;
		sc->sc_curs_pos.y = curs->pos.y;
	}
	if (curs->which & WSDISPLAY_CURSOR_DOHOT) {
		sc->sc_curs_hot.x = curs->hot.x;
		sc->sc_curs_hot.y = curs->hot.y;
	}
	if (curs->which & WSDISPLAY_CURSOR_DOCMAP) {
		sc->sc_curs_fg = ((r[0] << 0) | (g[0] << 8) | (b[0] << 16));
		sc->sc_curs_bg = ((r[1] << 0) | (g[1] << 8) | (b[1] << 16));
	}
	if (curs->which & WSDISPLAY_CURSOR_DOSHAPE) {
		sc->sc_curs_size.x = curs->size.x;
		sc->sc_curs_size.y = curs->size.y;
		bcopy(image, sc->sc_curs_image, imcount);
		bcopy(mask, sc->sc_curs_mask, imcount);
	}

	creator_updatecursor(sc, curs->which);

	return (0);
}

void
creator_curs_enable(struct creator_softc *sc, u_int ena)
{
	u_int32_t v;

	DAC_WRITE(sc, FFB_DAC_TYPE2, DAC_TYPE2_CURSENAB);
	if (sc->sc_dacrev <= 2)
		v = ena ? 3 : 0;
	else
		v = ena ? 0 : 3;
	DAC_WRITE(sc, FFB_DAC_VALUE2, v);
}

int
creator_updatecursor(struct creator_softc *sc, u_int which)
{
	creator_curs_enable(sc, 0);

	if (which & WSDISPLAY_CURSOR_DOCMAP) {
		DAC_WRITE(sc, FFB_DAC_TYPE2, DAC_TYPE2_CURSCMAP);
		DAC_WRITE(sc, FFB_DAC_VALUE2, sc->sc_curs_fg);
		DAC_WRITE(sc, FFB_DAC_VALUE2, sc->sc_curs_bg);
	}

	if (which & (WSDISPLAY_CURSOR_DOPOS | WSDISPLAY_CURSOR_DOHOT)) {
		u_int32_t x, y;

		x = sc->sc_curs_pos.x + CREATOR_CURS_MAX - sc->sc_curs_hot.x;
		y = sc->sc_curs_pos.y + CREATOR_CURS_MAX - sc->sc_curs_hot.y;
		DAC_WRITE(sc, FFB_DAC_TYPE2, DAC_TYPE2_CURSPOS);
		DAC_WRITE(sc, FFB_DAC_VALUE2,
		    ((x & 0xffff) << 16) | (y & 0xffff));
	}

	if (which & WSDISPLAY_CURSOR_DOCUR)
		creator_curs_enable(sc, sc->sc_curs_enabled);

	return (0);
}

int
a284 35
const struct creator_mappings {
	bus_addr_t uoff;
	bus_addr_t poff;
	bus_size_t ulen;
} creator_map[] = {
	{ FFB_VOFF_SFB8R, FFB_POFF_SFB8R, FFB_VLEN_SFB8R },
	{ FFB_VOFF_SFB8G, FFB_POFF_SFB8G, FFB_VLEN_SFB8G },
	{ FFB_VOFF_SFB8B, FFB_POFF_SFB8B, FFB_VLEN_SFB8B },
	{ FFB_VOFF_SFB8X, FFB_POFF_SFB8X, FFB_VLEN_SFB8X },
	{ FFB_VOFF_SFB32, FFB_POFF_SFB32, FFB_VLEN_SFB32 },
	{ FFB_VOFF_SFB64, FFB_POFF_SFB64, FFB_VLEN_SFB64 },
	{ FFB_VOFF_FBC_REGS, FFB_POFF_FBC_REGS, FFB_VLEN_FBC_REGS },
	{ FFB_VOFF_BM_FBC_REGS, FFB_POFF_BM_FBC_REGS, FFB_VLEN_BM_FBC_REGS },
	{ FFB_VOFF_DFB8R, FFB_POFF_DFB8R, FFB_VLEN_DFB8R },
	{ FFB_VOFF_DFB8G, FFB_POFF_DFB8G, FFB_VLEN_DFB8G },
	{ FFB_VOFF_DFB8B, FFB_POFF_DFB8B, FFB_VLEN_DFB8B },
	{ FFB_VOFF_DFB8X, FFB_POFF_DFB8X, FFB_VLEN_DFB8X },
	{ FFB_VOFF_DFB24, FFB_POFF_DFB24, FFB_VLEN_DFB24 },
	{ FFB_VOFF_DFB32, FFB_POFF_DFB32, FFB_VLEN_DFB32 },
	{ FFB_VOFF_DFB422A, FFB_POFF_DFB422A, FFB_VLEN_DFB422A },
	{ FFB_VOFF_DFB422AD, FFB_POFF_DFB422AD, FFB_VLEN_DFB422AD },
	{ FFB_VOFF_DFB24B, FFB_POFF_DFB24B, FFB_VLEN_DFB24B },
	{ FFB_VOFF_DFB422B, FFB_POFF_DFB422B, FFB_VLEN_DFB422B },
	{ FFB_VOFF_DFB422BD, FFB_POFF_DFB422BD, FFB_VLEN_DFB422BD },
	{ FFB_VOFF_SFB16Z, FFB_POFF_SFB16Z, FFB_VLEN_SFB16Z },
	{ FFB_VOFF_SFB8Z, FFB_POFF_SFB8Z, FFB_VLEN_SFB8Z },
	{ FFB_VOFF_SFB422, FFB_POFF_SFB422, FFB_VLEN_SFB422 },
	{ FFB_VOFF_SFB422D, FFB_POFF_SFB422D, FFB_VLEN_SFB422D },
	{ FFB_VOFF_FBC_KREGS, FFB_POFF_FBC_KREGS, FFB_VLEN_FBC_KREGS },
	{ FFB_VOFF_DAC, FFB_POFF_DAC, FFB_VLEN_DAC },
	{ FFB_VOFF_PROM, FFB_POFF_PROM, FFB_VLEN_PROM },
	{ FFB_VOFF_EXP, FFB_POFF_EXP, FFB_VLEN_EXP },
};
#define	CREATOR_NMAPPINGS	(sizeof(creator_map)/sizeof(creator_map[0]))

a290 1
	paddr_t x;
a295 16
		/* Turn virtual offset into physical offset */
		for (i = 0; i < CREATOR_NMAPPINGS; i++) {
			if (off >= creator_map[i].uoff &&
			    off < (creator_map[i].uoff + creator_map[i].ulen))
				break;
		}
		if (i == CREATOR_NMAPPINGS) {
			printf("didn't find %llx\n", off);
			break;
		}

		off -= creator_map[i].uoff;
		off += creator_map[i].poff;
		off += sc->sc_addrs[0];

		/* Map based on physical offset */
d304 2
a305 3
			x = bus_space_mmap(sc->sc_bt, 0, off, prot,
			    BUS_SPACE_MAP_LINEAR);
			return (x);
@


1.23.2.3
log
@merge the trunk so we will get the genfs and locking fixes
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d226 1
a226 1
		*(u_int *)data = WSDISPLAY_TYPE_SUNFFB;
@


1.23.2.4
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: creator.c,v 1.23.2.3 2003/05/16 00:29:40 niklas Exp $	*/
d15 5
@


1.23.2.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a44 1
#include <machine/fbvar.h>
d51 5
d75 1
d85 1
d142 9
a150 6
	fb_setsize(&sc->sc_sunfb, 32, 1152, 900, sc->sc_node, 0);
	/* linesize has a fixed value, compensate */
	sc->sc_sunfb.sf_linebytes = 8192;
	sc->sc_sunfb.sf_fbsize = sc->sc_sunfb.sf_height * 8192;

	sc->sc_sunfb.sf_ro.ri_bits = (void *)bus_space_vaddr(sc->sc_bt,
a151 2
	sc->sc_sunfb.sf_ro.ri_hw = sc;
	fbwscons_init(&sc->sc_sunfb, sc->sc_console ? 0 : RI_CLEAR);
d153 13
a165 5
	if ((sc->sc_sunfb.sf_dev.dv_cfdata->cf_flags & CREATOR_CFFLAG_NOACCEL)
	    == 0) {
		sc->sc_sunfb.sf_ro.ri_ops.eraserows = creator_ras_eraserows;
		sc->sc_sunfb.sf_ro.ri_ops.erasecols = creator_ras_erasecols;
		sc->sc_sunfb.sf_ro.ri_ops.copyrows = creator_ras_copyrows;
d169 3
a171 4
	creator_stdscreen.capabilities = sc->sc_sunfb.sf_ro.ri_caps;
	creator_stdscreen.nrows = sc->sc_sunfb.sf_ro.ri_rows;
	creator_stdscreen.ncols = sc->sc_sunfb.sf_ro.ri_cols;
	creator_stdscreen.textops = &sc->sc_sunfb.sf_ro.ri_ops;
d174 21
a194 3
		sc->sc_sunfb.sf_ro.ri_updatecursor = creator_ras_updatecursor;
		fbwscons_console_init(&sc->sc_sunfb, &creator_stdscreen, -1,
		    NULL);
d201 1
a201 1
	config_found(&sc->sc_sunfb.sf_dev, &waa, wsemuldisplaydevprint);
d228 2
a229 2
		wdf->height = sc->sc_sunfb.sf_height;
		wdf->width  = sc->sc_sunfb.sf_width;
d231 1
a231 1
		wdf->cmsize = 0;
d234 1
a234 1
		*(u_int *)data = sc->sc_sunfb.sf_linebytes;
d432 1
a432 1
	*cookiep = &sc->sc_sunfb.sf_ro;
d435 1
a435 2
	sc->sc_sunfb.sf_ro.ri_ops.alloc_attr(&sc->sc_sunfb.sf_ro,
	    0, 0, 0, attrp);
d514 2
a515 1
		if (i == CREATOR_NMAPPINGS)
d517 1
d550 12
d752 4
a755 4
	if (sc->sc_sunfb.sf_crowp != NULL)
		*sc->sc_sunfb.sf_crowp = ri->ri_crow;
	if (sc->sc_sunfb.sf_ccolp != NULL)
		*sc->sc_sunfb.sf_ccolp = ri->ri_ccol;
@


1.22
log
@Register more wsscreen properties to take advantage of wsemul_sun changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: creator.c,v 1.21 2002/08/19 20:16:04 jason Exp $	*/
d91 3
d120 6
d139 7
a145 1
	printf(", model %s\n", model);
d218 1
d220 3
d241 66
a306 1

a307 2
		break;/* XXX */

a308 9
		break;/* XXX */

	case WSDISPLAYIO_SVIDEO:
	case WSDISPLAYIO_GVIDEO:
	case WSDISPLAYIO_GCURPOS:
	case WSDISPLAYIO_SCURPOS:
	case WSDISPLAYIO_GCURMAX:
	case WSDISPLAYIO_GCURSOR:
	case WSDISPLAYIO_SCURSOR:
d317 108
d466 35
d507 1
d513 16
d537 3
a539 2
			return (bus_space_mmap(sc->sc_bt, sc->sc_addrs[i],
			    off - sc->sc_addrs[i], prot, BUS_SPACE_MAP_LINEAR));
@


1.21
log
@Take advantage of rasops.updatecursor to keep the prom cursor up to date
@
text
@d1 1
a1 1
/*	$OpenBSD: creator.c,v 1.20 2002/07/30 19:48:15 jason Exp $	*/
d59 1
@


1.20
log
@allow cf_flags to determine whether console acceleration should be used (defaults to yes)
@
text
@d1 1
a1 1
/*	$OpenBSD: creator.c,v 1.19 2002/07/29 06:21:45 jason Exp $	*/
d86 1
a86 1
void	creator_ras_do_cursor(struct rasops_info *);
d89 1
a162 1
		int *ccolp, *crowp;
d165 6
a170 6
		if (romgetcursoraddr(&crowp, &ccolp))
			ccolp = crowp = NULL;
		if (ccolp != NULL)
			sc->sc_rasops.ri_ccol = *ccolp;
		if (crowp != NULL)
			sc->sc_rasops.ri_crow = *crowp;
d180 2
d514 12
@


1.19
log
@use ROP_OLD for VSCROLL, with this, vertical scroll (copyrows) works (and it's -fast-)
@
text
@d1 1
a1 1
/*	$OpenBSD: creator.c,v 1.18 2002/07/29 05:53:12 jason Exp $	*/
d148 8
a155 5
	sc->sc_rasops.ri_hw = sc;
	sc->sc_rasops.ri_ops.eraserows = creator_ras_eraserows;
	sc->sc_rasops.ri_ops.erasecols = creator_ras_erasecols;
	sc->sc_rasops.ri_ops.copyrows = creator_ras_copyrows;
	creator_ras_init(sc);
@


1.18
log
@- cache the last value written to FBC_FG and avoid unnecessary fifo writes
- add a copyrows implementation based on the VSCROLL drawing operation.  It
draws a correctly sized rectangle, but I have no idea where the source data
came from... so it's currently disabled =)
@
text
@d1 1
a1 1
/*	$OpenBSD: creator.c,v 1.17 2002/07/28 06:25:14 fgsch Exp $	*/
a150 1
#if 0
a151 1
#endif
d452 2
a453 1
	creator_ras_fifo_wait(sc, 1);
d486 2
a487 1
	creator_ras_fifo_wait(sc, 7);
@


1.17
log
@more registers; jason@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: creator.c,v 1.16 2002/07/26 18:23:34 jason Exp $	*/
a83 1
void	creator_ras_copycols(void *, int, int, int, int);
d88 1
d151 3
d365 14
d400 2
a401 2
	creator_ras_fifo_wait(sc, 5);
	FBC_WRITE(sc, FFB_FBC_FG, ri->ri_devcmap[(attr >> 16) & 0xf]);
d441 2
a442 2
	creator_ras_fifo_wait(sc, 5);
	FBC_WRITE(sc, FFB_FBC_FG, ri->ri_devcmap[(attr >> 16) & 0xf]);
d454 1
a454 8
	creator_ras_fifo_wait(sc, 6);
	FBC_WRITE(sc, FFB_FBC_PPC,
	    FBC_PPC_VCE_DIS | FBC_PPC_TBE_OPAQUE |
	    FBC_PPC_APE_DIS | FBC_PPC_CS_CONST);
	FBC_WRITE(sc, FFB_FBC_FBC,
	    FFB_FBC_WB_A | FFB_FBC_RB_A | FFB_FBC_SB_BOTH |
	    FFB_FBC_XE_OFF | FFB_FBC_RGBE_MASK);
	FBC_WRITE(sc, FFB_FBC_ROP, FBC_ROP_NEW);
d456 52
a507 2
	FBC_WRITE(sc, FFB_FBC_PMASK, 0xffffffff);
	FBC_WRITE(sc, FFB_FBC_FONTINC, 0x10000);
@


1.16
log
@fifo needs 6 entries before we feed it rectangle command
@
text
@d1 1
a1 1
/*	$OpenBSD: creator.c,v 1.15 2002/07/26 18:00:08 jason Exp $	*/
d441 3
a443 1
	FBC_WRITE(sc, FFB_FBC_FBC, 0x2000707f);
@


1.15
log
@- add hardware support for eraserows and erasecols
- also fix some register names and add yet more of them
[one thing this chip isn't lacking is registers...]
@
text
@d1 1
a1 1
/*	$OpenBSD: creator.c,v 1.14 2002/07/26 16:57:16 jason Exp $	*/
d437 1
a437 1
	creator_ras_fifo_wait(sc, 5);
@


1.14
log
@- remove duplicate defns
- start at some utility functions for the FBC handling
@
text
@d1 1
a1 1
/*	$OpenBSD: creator.c,v 1.13 2002/07/25 19:04:43 miod Exp $	*/
d82 7
d148 4
d352 1
a352 1
		r = ucsr & (FFB_UCSR_READ_ERR | FFB_UCSR_FIFO_OVFL);
d356 91
@


1.13
log
@Adapt the framebuffer code to the WSDISPLAY_TYPE constant changes, and
add the necessary magic for wsemul_sun color handling.

Initially based on a patch from jason@@, then some tinkering by me.
@
text
@d1 1
a1 1
/*	$OpenBSD: creator.c,v 1.12 2002/06/11 06:53:03 fgsch Exp $	*/
d51 1
d80 2
d313 32
@


1.12
log
@split creator driver into bus specific and common code.
requested and ok by jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: creator.c,v 1.11 2002/06/03 16:32:04 fgsch Exp $	*/
a99 1
	long defattr;
a141 1
	sc->sc_rasops.ri_ops.alloc_attr(&sc->sc_rasops, 0, 0, 0, &defattr);
d145 1
d154 8
d186 1
a186 1
		*(u_int *)data = WSDISPLAY_TYPE_SUNFFB;
@


1.11
log
@- use the 24 bits dumb frame buffer reg. instead of the 32 one, but return
  32 bpp to wsfb.
- print the model; the board type is not useful.

this enables video output in the U1/E and probably some other creator models.
tested by jason@@ and Daniel Zieber <dlz@@astro.caltech.edu>; jason@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: creator.c,v 1.10 2002/05/22 22:02:08 fgsch Exp $	*/
d51 1
a51 28
/* Number of register sets */
#define	FFB_NREGS		24

/* Register set numbers */
#define	FFB_REG_PROM		0
#define	FFB_REG_DAC		1
#define	FFB_REG_FBC		2
#define	FFB_REG_DFB8R		3
#define	FFB_REG_DFB8G		4
#define	FFB_REG_DFB8B		5
#define	FFB_REG_DFB8X		6
#define	FFB_REG_DFB24		7
#define	FFB_REG_DFB32		8
#define	FFB_REG_SFB8R		9
#define	FFB_REG_SFB8G		10
#define	FFB_REG_SFB8B		11
#define	FFB_REG_SFB8X		12
#define	FFB_REG_SFB32		13
#define	FFB_REG_SFB64		14
#define	FFB_REG_DFB422A		15
#define	FFB_REG_DFB422AD	16
#define	FFB_REG_DFB24B		17
#define	FFB_REG_DFB422B		18
#define	FFB_REG_DFB422BD	19
#define	FFB_REG_SFB8Z		20
#define	FFB_REG_SFB16Z		21
#define	FFB_REG_SFB422		22
#define	FFB_REG_SFB422D		23
d86 1
a86 1
	NULL,	/* load_font */
a91 19
struct creator_softc {
	struct device sc_dv;
	bus_space_tag_t sc_bt;
	bus_space_handle_t sc_pixel_h;
	bus_addr_t sc_addrs[FFB_NREGS];
	bus_size_t sc_sizes[FFB_NREGS];
	int sc_height, sc_width, sc_linebytes, sc_depth;
	int sc_nscreens, sc_nreg;
	u_int sc_mode;
	struct rasops_info sc_rasops;
};

int	creator_match(struct device *, void *, void *);
void	creator_attach(struct device *, struct device *, void *);

struct cfattach creator_ca = {
	sizeof(struct creator_softc), creator_match, creator_attach
};

a95 13
int
creator_match(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	struct mainbus_attach_args *ma = aux;

	if (strcmp(ma->ma_name, "SUNW,ffb") == 0 ||
	    strcmp(ma->ma_name, "SUNW,afb") == 0)
		return (1);
	return (0);
}

d97 1
a97 3
creator_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
a98 2
	struct creator_softc *sc = (struct creator_softc *)self;
	struct mainbus_attach_args *ma = aux;
a100 2
	extern int fbnode;
	int i, btype, console, nregs;
d102 1
a102 4

	sc->sc_bt = ma->ma_bustag;

	nregs = min(ma->ma_nreg, FFB_NREGS);
d106 2
a107 3
	if (strcmp(ma->ma_name, "SUNW,afb") != 0) {
		btype = getpropint(ma->ma_node, "board_type", 0);

d115 1
a115 1
	model = getpropstring(ma->ma_node, "model");
a120 19
	if (nregs < FFB_REG_DFB24) {
		printf(": no dfb24 regs found\n");
		goto fail;
	}

	if (bus_space_map2(sc->sc_bt, 0, ma->ma_reg[FFB_REG_DFB24].ur_paddr,
	    ma->ma_reg[FFB_REG_DFB24].ur_len, 0, NULL, &sc->sc_pixel_h)) {
		printf("%s: failed to map dfb24\n", sc->sc_dv.dv_xname);
		goto fail;
	}

	for (i = 0; i < nregs; i++) {
		sc->sc_addrs[i] = ma->ma_reg[i].ur_paddr;
		sc->sc_sizes[i] = ma->ma_reg[i].ur_len;
	}
	sc->sc_nreg = nregs;

	console = (fbnode == ma->ma_node);

d123 2
a124 2
	sc->sc_height = getpropint(ma->ma_node, "height", 0);
	sc->sc_width = getpropint(ma->ma_node, "width", 0);
d145 1
a145 1
	if (console) {
d159 1
a159 1
	waa.console = console;
d163 1
a163 8
	config_found(self, &waa, wsemuldisplaydevprint);

	return;

fail:
	if (sc->sc_pixel_h != 0)
		bus_space_unmap(sc->sc_bt, sc->sc_pixel_h,
		    ma->ma_reg[FFB_REG_DFB24].ur_len);
@


1.11.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.11.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: creator.c,v 1.11.2.1 2002/06/11 03:38:42 art Exp $	*/
d51 28
a78 2
#include <sparc64/dev/creatorreg.h>
#include <sparc64/dev/creatorvar.h>
a84 1
	WSSCREEN_UNDERLINE | WSSCREEN_HILIT |
a105 10
void	creator_ras_fifo_wait(struct creator_softc *, int);
void	creator_ras_wait(struct creator_softc *);
void	creator_ras_init(struct creator_softc *);
void	creator_ras_copyrows(void *, int, int, int);
void	creator_ras_erasecols(void *, int, int, int, long int);
void	creator_ras_eraserows(void *, int, int, long int);
void	creator_ras_updatecursor(struct rasops_info *);
void	creator_ras_fill(struct creator_softc *);
void	creator_ras_setfg(struct creator_softc *, int32_t);
void	creator_ras_updatecursor(struct rasops_info *);
d113 1
a113 1
	NULL,	/* load font */
d119 19
d142 13
d156 3
a158 1
creator_attach(struct creator_softc *sc)
d160 2
d163 3
d167 4
a170 1
	int btype;
d174 3
a176 2
	if (sc->sc_type == FFB_CREATOR) {
		btype = getpropint(sc->sc_node, "board_type", 0);
d184 1
a184 1
	model = getpropstring(sc->sc_node, "model");
d190 19
d211 2
a212 2
	sc->sc_height = getpropint(sc->sc_node, "height", 0);
	sc->sc_width = getpropint(sc->sc_node, "width", 0);
a227 8
	if ((sc->sc_dv.dv_cfdata->cf_flags & CREATOR_CFFLAG_NOACCEL) == 0) {
		sc->sc_rasops.ri_hw = sc;
		sc->sc_rasops.ri_ops.eraserows = creator_ras_eraserows;
		sc->sc_rasops.ri_ops.erasecols = creator_ras_erasecols;
		sc->sc_rasops.ri_ops.copyrows = creator_ras_copyrows;
		creator_ras_init(sc);
	}

d231 1
d233 2
a234 2
	if (sc->sc_console) {
		long defattr;
d236 6
a241 16
		if (romgetcursoraddr(&sc->sc_crowp, &sc->sc_ccolp))
			sc->sc_ccolp = sc->sc_crowp = NULL;
		if (sc->sc_ccolp != NULL)
			sc->sc_rasops.ri_ccol = *sc->sc_ccolp;
		if (sc->sc_crowp != NULL)
			sc->sc_rasops.ri_crow = *sc->sc_crowp;

		/* fix color choice */
		wscol_white = 0;
		wscol_black = 255;
		wskernel_bg = 0;
		wskernel_fg = 255;

		sc->sc_rasops.ri_ops.alloc_attr(&sc->sc_rasops,
		    0, 0, 0, &defattr);
		sc->sc_rasops.ri_updatecursor = creator_ras_updatecursor;
d247 1
a247 1
	waa.console = sc->sc_console;
d251 8
a258 1
	config_found(&sc->sc_dv, &waa, wsemuldisplaydevprint);
d274 1
a274 1
		*(u_int *)data = WSDISPLAY_TYPE_SUN24;
a397 196
}

void
creator_ras_fifo_wait(sc, n)
	struct creator_softc *sc;
	int n;
{
	int32_t cache = sc->sc_fifo_cache;

	if (cache < n) {
		do {
			cache = FBC_READ(sc, FFB_FBC_UCSR);
			cache = (cache & FBC_UCSR_FIFO_MASK) - 8;
		} while (cache < n);
	}
	sc->sc_fifo_cache = cache - n;
}

void
creator_ras_wait(sc)
	struct creator_softc *sc;
{
	u_int32_t ucsr, r;

	while (1) {
		ucsr = FBC_READ(sc, FFB_FBC_UCSR);
		if ((ucsr & (FBC_UCSR_FB_BUSY|FBC_UCSR_RP_BUSY)) == 0)
			break;
		r = ucsr & (FBC_UCSR_READ_ERR | FBC_UCSR_FIFO_OVFL);
		if (r != 0)
			FBC_WRITE(sc, FFB_FBC_UCSR, r);
	}
}

void
creator_ras_init(sc)
	struct creator_softc *sc;
{
	creator_ras_fifo_wait(sc, 7);
	FBC_WRITE(sc, FFB_FBC_PPC,
	    FBC_PPC_VCE_DIS | FBC_PPC_TBE_OPAQUE |
	    FBC_PPC_APE_DIS | FBC_PPC_CS_CONST);
	FBC_WRITE(sc, FFB_FBC_FBC,
	    FFB_FBC_WB_A | FFB_FBC_RB_A | FFB_FBC_SB_BOTH |
	    FFB_FBC_XE_OFF | FFB_FBC_RGBE_MASK);
	FBC_WRITE(sc, FFB_FBC_ROP, FBC_ROP_NEW);
	FBC_WRITE(sc, FFB_FBC_DRAWOP, FBC_DRAWOP_RECTANGLE);
	FBC_WRITE(sc, FFB_FBC_PMASK, 0xffffffff);
	FBC_WRITE(sc, FFB_FBC_FONTINC, 0x10000);
	sc->sc_fg_cache = 0;
	FBC_WRITE(sc, FFB_FBC_FG, sc->sc_fg_cache);
	creator_ras_wait(sc);
}

void
creator_ras_eraserows(cookie, row, n, attr)
	void *cookie;
	int row, n;
	long int attr;
{
	struct rasops_info *ri = cookie;
	struct creator_softc *sc = ri->ri_hw;

	if (row < 0) {
		n += row;
		row = 0;
	}
	if (row + n > ri->ri_rows)
		n = ri->ri_rows - row;
	if (n <= 0)
		return;

	creator_ras_fill(sc);
	creator_ras_setfg(sc, ri->ri_devcmap[(attr >> 16) & 0xf]);
	creator_ras_fifo_wait(sc, 4);
	if ((n == ri->ri_rows) && (ri->ri_flg & RI_FULLCLEAR)) {
		FBC_WRITE(sc, FFB_FBC_BY, 0);
		FBC_WRITE(sc, FFB_FBC_BX, 0);
		FBC_WRITE(sc, FFB_FBC_BH, ri->ri_height);
		FBC_WRITE(sc, FFB_FBC_BW, ri->ri_width);
	} else {
		row *= ri->ri_font->fontheight;
		FBC_WRITE(sc, FFB_FBC_BY, ri->ri_yorigin + row);
		FBC_WRITE(sc, FFB_FBC_BX, ri->ri_xorigin);
		FBC_WRITE(sc, FFB_FBC_BH, n * ri->ri_font->fontheight);
		FBC_WRITE(sc, FFB_FBC_BW, ri->ri_emuwidth);
	}
	creator_ras_wait(sc);
}

void
creator_ras_erasecols(cookie, row, col, n, attr)
	void *cookie;
	int row, col, n;
	long int attr;
{
	struct rasops_info *ri = cookie;
	struct creator_softc *sc = ri->ri_hw;

	if ((row < 0) || (row >= ri->ri_rows))
		return;
	if (col < 0) {
		n += col;
		col = 0;
	}
	if (col + n > ri->ri_cols)
		n = ri->ri_cols - col;
	if (n <= 0)
		return;
	n *= ri->ri_font->fontwidth;
	col *= ri->ri_font->fontwidth;
	row *= ri->ri_font->fontheight;

	creator_ras_fill(sc);
	creator_ras_setfg(sc, ri->ri_devcmap[(attr >> 16) & 0xf]);
	creator_ras_fifo_wait(sc, 4);
	FBC_WRITE(sc, FFB_FBC_BY, ri->ri_yorigin + row);
	FBC_WRITE(sc, FFB_FBC_BX, ri->ri_xorigin + col);
	FBC_WRITE(sc, FFB_FBC_BH, ri->ri_font->fontheight);
	FBC_WRITE(sc, FFB_FBC_BW, n - 1);
	creator_ras_wait(sc);
}

void
creator_ras_fill(sc)
	struct creator_softc *sc;
{
	creator_ras_fifo_wait(sc, 2);
	FBC_WRITE(sc, FFB_FBC_ROP, FBC_ROP_NEW);
	FBC_WRITE(sc, FFB_FBC_DRAWOP, FBC_DRAWOP_RECTANGLE);
	creator_ras_wait(sc);
}

void
creator_ras_copyrows(cookie, src, dst, n)
	void *cookie;
	int src, dst, n;
{
	struct rasops_info *ri = cookie;
	struct creator_softc *sc = ri->ri_hw;

	if (dst == src)
		return;
	if (src < 0) {
		n += src;
		src = 0;
	}
	if ((src + n) > ri->ri_rows)
		n = ri->ri_rows - src;
	if (dst < 0) {
		n += dst;
		dst = 0;
	}
	if ((dst + n) > ri->ri_rows)
		n = ri->ri_rows - dst;
	if (n <= 0)
		return;
	n *= ri->ri_font->fontheight;
	src *= ri->ri_font->fontheight;
	dst *= ri->ri_font->fontheight;

	creator_ras_fifo_wait(sc, 8);
	FBC_WRITE(sc, FFB_FBC_ROP, FBC_ROP_OLD | (FBC_ROP_OLD << 8));
	FBC_WRITE(sc, FFB_FBC_DRAWOP, FBC_DRAWOP_VSCROLL);
	FBC_WRITE(sc, FFB_FBC_BY, ri->ri_yorigin + src);
	FBC_WRITE(sc, FFB_FBC_BX, ri->ri_xorigin);
	FBC_WRITE(sc, FFB_FBC_DY, ri->ri_yorigin + dst);
	FBC_WRITE(sc, FFB_FBC_DX, ri->ri_xorigin);
	FBC_WRITE(sc, FFB_FBC_BH, n);
	FBC_WRITE(sc, FFB_FBC_BW, ri->ri_emuwidth);
	creator_ras_wait(sc);
}

void
creator_ras_setfg(sc, fg)
	struct creator_softc *sc;
	int32_t fg;
{
	creator_ras_fifo_wait(sc, 1);
	if (fg == sc->sc_fg_cache)
		return;
	sc->sc_fg_cache = fg;
	FBC_WRITE(sc, FFB_FBC_FG, fg);
	creator_ras_wait(sc);
}

void
creator_ras_updatecursor(ri)
	struct rasops_info *ri;
{
	struct creator_softc *sc = ri->ri_hw;

	if (sc->sc_crowp != NULL)
		*sc->sc_crowp = ri->ri_crow;
	if (sc->sc_ccolp != NULL)
		*sc->sc_ccolp = ri->ri_ccol;
@


1.11.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a90 3
int	creator_setcursor(struct creator_softc *, struct wsdisplay_cursor *);
int	creator_updatecursor(struct creator_softc *, u_int);
void	creator_curs_enable(struct creator_softc *, u_int);
a116 6
	/*
	 * Prom reports only the length of the fcode header, we need
	 * the whole thing.
	 */
	sc->sc_sizes[0] = 0x00400000;

d130 1
a130 7
	DAC_WRITE(sc, FFB_DAC_TYPE, DAC_TYPE_GETREV);
	sc->sc_dacrev = DAC_READ(sc, FFB_DAC_VALUE) >> 28;

	printf(", model %s, dac %u\n", model, sc->sc_dacrev);

	if (sc->sc_type == FFB_AFB)
		sc->sc_dacrev = 10;
a202 1
	struct wsdisplay_cursor *curs;
a203 3
	struct wsdisplay_curpos *pos;
	u_char r[2], g[2], b[2];
	int error;
d207 1
a207 1
		*(u_int *)data = WSDISPLAY_TYPE_SUNFFB;
d222 12
a234 55
		curs = (struct wsdisplay_cursor *)data;
		if (curs->which & WSDISPLAY_CURSOR_DOCUR)
			curs->enable = sc->sc_curs_enabled;
		if (curs->which & WSDISPLAY_CURSOR_DOPOS) {
			curs->pos.x = sc->sc_curs_pos.x;
			curs->pos.y = sc->sc_curs_pos.y;
		}
		if (curs->which & WSDISPLAY_CURSOR_DOHOT) {
			curs->hot.x = sc->sc_curs_hot.x;
			curs->hot.y = sc->sc_curs_hot.y;
		}
		if (curs->which & WSDISPLAY_CURSOR_DOCMAP) {
			curs->cmap.index = 0;
			curs->cmap.count = 2;
			r[0] = sc->sc_curs_fg >> 0;
			g[0] = sc->sc_curs_fg >> 8;
			b[0] = sc->sc_curs_fg >> 16;
			r[1] = sc->sc_curs_bg >> 0;
			g[1] = sc->sc_curs_bg >> 8;
			b[1] = sc->sc_curs_bg >> 16;
			error = copyout(r, curs->cmap.red, sizeof(r));
			if (error)
				return (error);
			error = copyout(g, curs->cmap.green, sizeof(g));
			if (error)
				return (error);
			error = copyout(b, curs->cmap.blue, sizeof(b));
			if (error)
				return (error);
		}
		if (curs->which & WSDISPLAY_CURSOR_DOSHAPE) {
			size_t l;

			curs->size.x = sc->sc_curs_size.x;
			curs->size.y = sc->sc_curs_size.y;
			l = (sc->sc_curs_size.x * sc->sc_curs_size.y) / NBBY;
			error = copyout(sc->sc_curs_image, curs->image, l);
			if (error)
				return (error);
			error = copyout(sc->sc_curs_mask, curs->mask, l);
			if (error)
				return (error);
		}
		break;
	case WSDISPLAYIO_SCURPOS:
		pos = (struct wsdisplay_curpos *)data;
		sc->sc_curs_pos.x = pos->x;
		sc->sc_curs_pos.y = pos->y;
		creator_updatecursor(sc, WSDISPLAY_CURSOR_DOPOS);
		break;
	case WSDISPLAYIO_GCURPOS:
		pos = (struct wsdisplay_curpos *)data;
		pos->x = sc->sc_curs_pos.x;
		pos->y = sc->sc_curs_pos.y;
		break;
a235 11
		curs = (struct wsdisplay_cursor *)data;
		return (creator_setcursor(sc, curs));
	case WSDISPLAYIO_GCURMAX:
		pos = (struct wsdisplay_curpos *)data;
		pos->x = CREATOR_CURS_MAX;
		pos->y = CREATOR_CURS_MAX;
		break;
	case WSDISPLAYIO_SVIDEO:
	case WSDISPLAYIO_GVIDEO:
	case WSDISPLAYIO_GETCMAP:
	case WSDISPLAYIO_PUTCMAP:
a243 108
creator_setcursor(struct creator_softc *sc, struct wsdisplay_cursor *curs)
{
	u_int8_t r[2], g[2], b[2], image[128], mask[128];
	int error;
	size_t imcount;

	/*
	 * Do stuff that can generate errors first, then we'll blast it
	 * all at once.
	 */
	if (curs->which & WSDISPLAY_CURSOR_DOCMAP) {
		if (curs->cmap.count < 2)
			return (EINVAL);
		error = copyin(curs->cmap.red, r, sizeof(r));
		if (error)
			return (error);
		error = copyin(curs->cmap.green, g, sizeof(g));
		if (error)
			return (error);
		error = copyin(curs->cmap.blue, b, sizeof(b));
		if (error)
			return (error);
	}

	if (curs->which & WSDISPLAY_CURSOR_DOSHAPE) {
		if (curs->size.x > CREATOR_CURS_MAX ||
		    curs->size.y > CREATOR_CURS_MAX)
			return (EINVAL);
		imcount = (curs->size.x * curs->size.y) / NBBY;
		error = copyin(curs->image, image, imcount);
		if (error)
			return (error);
		error = copyin(curs->mask, mask, imcount);
		if (error)
			return (error);
	}

	/*
	 * Ok, everything is in kernel space and sane, update state.
	 */

	if (curs->which & WSDISPLAY_CURSOR_DOCUR)
		sc->sc_curs_enabled = curs->enable;
	if (curs->which & WSDISPLAY_CURSOR_DOPOS) {
		sc->sc_curs_pos.x = curs->pos.x;
		sc->sc_curs_pos.y = curs->pos.y;
	}
	if (curs->which & WSDISPLAY_CURSOR_DOHOT) {
		sc->sc_curs_hot.x = curs->hot.x;
		sc->sc_curs_hot.y = curs->hot.y;
	}
	if (curs->which & WSDISPLAY_CURSOR_DOCMAP) {
		sc->sc_curs_fg = ((r[0] << 0) | (g[0] << 8) | (b[0] << 16));
		sc->sc_curs_bg = ((r[1] << 0) | (g[1] << 8) | (b[1] << 16));
	}
	if (curs->which & WSDISPLAY_CURSOR_DOSHAPE) {
		sc->sc_curs_size.x = curs->size.x;
		sc->sc_curs_size.y = curs->size.y;
		bcopy(image, sc->sc_curs_image, imcount);
		bcopy(mask, sc->sc_curs_mask, imcount);
	}

	creator_updatecursor(sc, curs->which);

	return (0);
}

void
creator_curs_enable(struct creator_softc *sc, u_int ena)
{
	u_int32_t v;

	DAC_WRITE(sc, FFB_DAC_TYPE2, DAC_TYPE2_CURSENAB);
	if (sc->sc_dacrev <= 2)
		v = ena ? 3 : 0;
	else
		v = ena ? 0 : 3;
	DAC_WRITE(sc, FFB_DAC_VALUE2, v);
}

int
creator_updatecursor(struct creator_softc *sc, u_int which)
{
	creator_curs_enable(sc, 0);

	if (which & WSDISPLAY_CURSOR_DOCMAP) {
		DAC_WRITE(sc, FFB_DAC_TYPE2, DAC_TYPE2_CURSCMAP);
		DAC_WRITE(sc, FFB_DAC_VALUE2, sc->sc_curs_fg);
		DAC_WRITE(sc, FFB_DAC_VALUE2, sc->sc_curs_bg);
	}

	if (which & (WSDISPLAY_CURSOR_DOPOS | WSDISPLAY_CURSOR_DOHOT)) {
		u_int32_t x, y;

		x = sc->sc_curs_pos.x + CREATOR_CURS_MAX - sc->sc_curs_hot.x;
		y = sc->sc_curs_pos.y + CREATOR_CURS_MAX - sc->sc_curs_hot.y;
		DAC_WRITE(sc, FFB_DAC_TYPE2, DAC_TYPE2_CURSPOS);
		DAC_WRITE(sc, FFB_DAC_VALUE2,
		    ((x & 0xffff) << 16) | (y & 0xffff));
	}

	if (which & WSDISPLAY_CURSOR_DOCUR)
		creator_curs_enable(sc, sc->sc_curs_enabled);

	return (0);
}

int
a284 35
const struct creator_mappings {
	bus_addr_t uoff;
	bus_addr_t poff;
	bus_size_t ulen;
} creator_map[] = {
	{ FFB_VOFF_SFB8R, FFB_POFF_SFB8R, FFB_VLEN_SFB8R },
	{ FFB_VOFF_SFB8G, FFB_POFF_SFB8G, FFB_VLEN_SFB8G },
	{ FFB_VOFF_SFB8B, FFB_POFF_SFB8B, FFB_VLEN_SFB8B },
	{ FFB_VOFF_SFB8X, FFB_POFF_SFB8X, FFB_VLEN_SFB8X },
	{ FFB_VOFF_SFB32, FFB_POFF_SFB32, FFB_VLEN_SFB32 },
	{ FFB_VOFF_SFB64, FFB_POFF_SFB64, FFB_VLEN_SFB64 },
	{ FFB_VOFF_FBC_REGS, FFB_POFF_FBC_REGS, FFB_VLEN_FBC_REGS },
	{ FFB_VOFF_BM_FBC_REGS, FFB_POFF_BM_FBC_REGS, FFB_VLEN_BM_FBC_REGS },
	{ FFB_VOFF_DFB8R, FFB_POFF_DFB8R, FFB_VLEN_DFB8R },
	{ FFB_VOFF_DFB8G, FFB_POFF_DFB8G, FFB_VLEN_DFB8G },
	{ FFB_VOFF_DFB8B, FFB_POFF_DFB8B, FFB_VLEN_DFB8B },
	{ FFB_VOFF_DFB8X, FFB_POFF_DFB8X, FFB_VLEN_DFB8X },
	{ FFB_VOFF_DFB24, FFB_POFF_DFB24, FFB_VLEN_DFB24 },
	{ FFB_VOFF_DFB32, FFB_POFF_DFB32, FFB_VLEN_DFB32 },
	{ FFB_VOFF_DFB422A, FFB_POFF_DFB422A, FFB_VLEN_DFB422A },
	{ FFB_VOFF_DFB422AD, FFB_POFF_DFB422AD, FFB_VLEN_DFB422AD },
	{ FFB_VOFF_DFB24B, FFB_POFF_DFB24B, FFB_VLEN_DFB24B },
	{ FFB_VOFF_DFB422B, FFB_POFF_DFB422B, FFB_VLEN_DFB422B },
	{ FFB_VOFF_DFB422BD, FFB_POFF_DFB422BD, FFB_VLEN_DFB422BD },
	{ FFB_VOFF_SFB16Z, FFB_POFF_SFB16Z, FFB_VLEN_SFB16Z },
	{ FFB_VOFF_SFB8Z, FFB_POFF_SFB8Z, FFB_VLEN_SFB8Z },
	{ FFB_VOFF_SFB422, FFB_POFF_SFB422, FFB_VLEN_SFB422 },
	{ FFB_VOFF_SFB422D, FFB_POFF_SFB422D, FFB_VLEN_SFB422D },
	{ FFB_VOFF_FBC_KREGS, FFB_POFF_FBC_KREGS, FFB_VLEN_FBC_KREGS },
	{ FFB_VOFF_DAC, FFB_POFF_DAC, FFB_VLEN_DAC },
	{ FFB_VOFF_PROM, FFB_POFF_PROM, FFB_VLEN_PROM },
	{ FFB_VOFF_EXP, FFB_POFF_EXP, FFB_VLEN_EXP },
};
#define	CREATOR_NMAPPINGS	(sizeof(creator_map)/sizeof(creator_map[0]))

a290 1
	paddr_t x;
a295 16
		/* Turn virtual offset into physical offset */
		for (i = 0; i < CREATOR_NMAPPINGS; i++) {
			if (off >= creator_map[i].uoff &&
			    off < (creator_map[i].uoff + creator_map[i].ulen))
				break;
		}
		if (i == CREATOR_NMAPPINGS) {
			printf("didn't find %llx\n", off);
			break;
		}

		off -= creator_map[i].uoff;
		off += creator_map[i].poff;
		off += sc->sc_addrs[0];

		/* Map based on physical offset */
d304 2
a305 3
			x = bus_space_mmap(sc->sc_bt, 0, off, prot,
			    BUS_SPACE_MAP_LINEAR);
			return (x);
@


1.10
log
@Match on "SUNW,afb" as well, a guess to make Elite3D cards work and print
the board type for now as well; jason@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: creator.c,v 1.9 2002/05/22 21:30:47 jason Exp $	*/
d166 1
d174 2
a175 1
	btype = getpropint(ma->ma_node, "board_type", 0);
a176 1
	if (strcmp(ma->ma_name, "SUNW,afb") != 0) {
d184 5
a188 1
	printf(", type %d\n", btype);
d190 2
a191 2
	if (nregs < FFB_REG_DFB32) {
		printf(": no dfb32 regs found\n");
d195 3
a197 3
	if (bus_space_map2(sc->sc_bt, 0, ma->ma_reg[FFB_REG_DFB32].ur_paddr,
	    ma->ma_reg[FFB_REG_DFB32].ur_len, 0, NULL, &sc->sc_pixel_h)) {
		printf("%s: failed to map dfb32\n", sc->sc_dv.dv_xname);
d209 1
a209 1
	sc->sc_depth = 32;
d214 1
a214 1
	sc->sc_rasops.ri_depth = sc->sc_depth;
d258 1
a258 1
		    ma->ma_reg[FFB_REG_DFB32].ur_len);
d283 2
a284 2
		wdf->depth  = sc->sc_depth;
		wdf->cmsize = 256;/*XXX*/
@


1.9
log
@- Allow matching of devices with fewer than 24 register sets
- set display type to be SUNFFB
@
text
@d1 1
a1 1
/*	$OpenBSD: creator.c,v 1.8 2002/05/22 14:44:20 jason Exp $	*/
d94 2
a95 1
	sizeof(creator_scrlist) / sizeof(struct wsscreen_descr *), creator_scrlist
d98 6
a103 6
int creator_ioctl(void *, u_long, caddr_t, int, struct proc *);
int creator_alloc_screen(void *, const struct wsscreen_descr *, void **,
    int *, int *, long *);
void creator_free_screen(void *, void *);
int creator_show_screen(void *, void *, int, void (*cb)(void *, int, int),
    void *);
d149 2
a150 1
	if (strcmp(ma->ma_name, "SUNW,ffb") == 0)
a173 4
	if ((btype & 7) == 3)
		printf(" Creator3D");
	else
		printf(" Creator");
d175 9
a183 1
	printf("\n");
@


1.8
log
@Copy only the register paddrs/lens that we have room for
@
text
@d1 1
a1 1
/*	$OpenBSD: creator.c,v 1.6 2002/05/22 01:45:12 jason Exp $	*/
d163 1
a163 1
	int i, btype, console;
d166 2
a167 4
	if (ma->ma_nreg < FFB_NREGS) {
		printf(": expected %d regs, got %d\n", FFB_NREGS, ma->ma_nreg);
		goto fail;
	}
d179 5
d190 1
a190 1
	for (i = 0; i < FFB_NREGS; i++) {
d194 1
a194 1
	sc->sc_nreg = ma->ma_nreg;
d263 1
a263 1
		*(u_int *)data = WSDISPLAY_TYPE_UNKNOWN;
@


1.7
log
@Only map in DFB32 during attach, other stuff will be mapped by _mmap as
necessary.
@
text
@d187 1
a187 1
	for (i = 0; i < ma->ma_nreg; i++) {
@


1.6
log
@return mappings from DFB24 for DUMBFB mode mmap requests (this makes unaccelerated X on the creator work)
@
text
@d1 1
a1 1
/*	$OpenBSD: creator.c,v 1.5 2002/05/21 18:49:00 jason Exp $	*/
d121 1
a121 1
	bus_space_handle_t sc_regs[FFB_NREGS];
d181 6
a187 6
		if (bus_space_map2(sc->sc_bt, 0,
		    ma->ma_reg[i].ur_paddr, ma->ma_reg[i].ur_len,
		    0, NULL, &sc->sc_regs[i])) {
			printf(": failed to map register set %d\n", i);
			goto fail;
		}
a189 1
		sc->sc_nreg = i + 1;
d191 1
d204 2
a205 1
	    sc->sc_regs[FFB_REG_DFB32]);
d242 3
a244 4
	for (i = 0; i < sc->sc_nreg; i++)
		if (sc->sc_regs[i] != 0)
			bus_space_unmap(sc->sc_bt, sc->sc_regs[i],
			    ma->ma_reg[i].ur_len);
@


1.5
log
@Remove some debugging code and generally clean things up.
@
text
@d1 1
a1 1
/*	$OpenBSD: creator.c,v 1.4 2002/05/21 18:31:31 jason Exp $	*/
d126 1
d262 3
d347 9
a355 7
	for (i = 0; i < sc->sc_nreg; i++) {
		/* Before this set? */
		if (off < sc->sc_addrs[i])
			continue;
		/* After this set? */
		if (off >= (sc->sc_addrs[i] + sc->sc_sizes[i]))
			continue;
d357 12
a368 2
		return (bus_space_mmap(sc->sc_bt, sc->sc_addrs[i],
		    off - sc->sc_addrs[i], prot, BUS_SPACE_MAP_LINEAR));
@


1.4
log
@Get the initial cursor position correct so we don't start back at 0,0 when
wsdisplay attaches.
@
text
@d1 1
a1 1
/*	$OpenBSD: creator.c,v 1.3 2002/05/21 15:46:07 jason Exp $	*/
d90 1
a90 1
	/* XXX other formaces? */
d125 1
a125 1
	int sc_nscreens, sc_nregs;
d189 1
a189 4
		printf(" reg %d: addr %llx len %llx\n", i,
		    (unsigned long long)sc->sc_addrs[i],
		    (unsigned long long)sc->sc_sizes[i]);
		sc->sc_nregs = i + 1;
d199 2
a200 2
	sc->sc_rasops.ri_depth = 32;
	sc->sc_rasops.ri_stride = 8192;
d240 1
a240 1
	for (i = 0; i < ma->ma_nreg; i++)
d266 1
a266 1
		wdf->cmsize = 256;
d343 1
a343 1
	for (i = 0; i < sc->sc_nregs; i++) {
@


1.3
log
@Remove last vestiges of rcons and now it appears to work.
@
text
@d1 1
a1 1
/*	$OpenBSD: creator.c,v 1.2 2002/05/21 14:53:47 jason Exp $	*/
d221 9
d231 1
a231 1
		    0, 0, defattr);
@


1.2
log
@Use rasops alloc_attr in alloc_screen so it doesn't crash when a screen is
added.
@
text
@d1 1
a1 1
/*	$OpenBSD: creator.c,v 1.1 2002/05/21 04:31:03 jason Exp $	*/
a79 11
struct wsdisplay_emulops creator_emulops = {
	rcons_cursor,
	rcons_mapchar,
	rcons_putchar,
	rcons_copycols,
	rcons_erasecols,
	rcons_copyrows,
	rcons_eraserows,
	rcons_alloc_attr
};

a125 1
	struct rcons sc_rcons;
d202 2
a203 2
	sc->sc_rasops.ri_depth = 8;
	sc->sc_rasops.ri_stride = 1024;
d206 1
a206 1
	    sc->sc_regs[FFB_REG_DFB8R]);
d220 6
a225 5
#if 0
/*XXX*/	waa.console = console;
#else
/*XXX*/	waa.console = 0;
#endif
@


1.1
log
@Skeleton driver for the Creator/Creator3D framebuffer (doesn't do much
except provide an entry point for mmap'n from userland so I can figure out
how it works).  Many thanks to Matt Potter <matt@@vertrauen.org> for providing
a card.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d310 4
a313 4
	*cookiep = &sc->sc_rcons;
	*curyp = *sc->sc_rcons.rc_crowp;
	*curxp = *sc->sc_rcons.rc_ccolp;
	rcons_alloc_attr(&sc->sc_rcons, 0, 0, 0, attrp);
@

