head	1.27;
access;
symbols
	OPENBSD_6_2_BASE:1.27
	OPENBSD_6_1:1.27.0.8
	OPENBSD_6_1_BASE:1.27
	OPENBSD_6_0:1.27.0.4
	OPENBSD_6_0_BASE:1.27
	OPENBSD_5_9:1.27.0.2
	OPENBSD_5_9_BASE:1.27
	OPENBSD_5_8:1.26.0.12
	OPENBSD_5_8_BASE:1.26
	OPENBSD_5_7:1.26.0.4
	OPENBSD_5_7_BASE:1.26
	OPENBSD_5_6:1.26.0.8
	OPENBSD_5_6_BASE:1.26
	OPENBSD_5_5:1.26.0.6
	OPENBSD_5_5_BASE:1.26
	OPENBSD_5_4:1.26.0.2
	OPENBSD_5_4_BASE:1.26
	OPENBSD_5_3:1.24.0.8
	OPENBSD_5_3_BASE:1.24
	OPENBSD_5_2:1.24.0.6
	OPENBSD_5_2_BASE:1.24
	OPENBSD_5_1_BASE:1.24
	OPENBSD_5_1:1.24.0.4
	OPENBSD_5_0:1.24.0.2
	OPENBSD_5_0_BASE:1.24
	OPENBSD_4_9:1.23.0.10
	OPENBSD_4_9_BASE:1.23
	OPENBSD_4_8:1.23.0.8
	OPENBSD_4_8_BASE:1.23
	OPENBSD_4_7:1.23.0.4
	OPENBSD_4_7_BASE:1.23
	OPENBSD_4_6:1.23.0.6
	OPENBSD_4_6_BASE:1.23
	OPENBSD_4_5:1.23.0.2
	OPENBSD_4_5_BASE:1.23
	OPENBSD_4_4:1.19.0.6
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.19.0.4
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.19.0.2
	OPENBSD_4_2_BASE:1.19
	OPENBSD_4_1:1.18.0.6
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.18.0.4
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.18.0.2
	OPENBSD_3_9_BASE:1.18
	OPENBSD_3_8:1.17.0.2
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.16.0.2
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.15.0.8
	OPENBSD_3_6_BASE:1.15
	SMP_SYNC_A:1.15
	SMP_SYNC_B:1.15
	OPENBSD_3_5:1.15.0.4
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.15.0.2
	OPENBSD_3_4_BASE:1.15
	UBC_SYNC_A:1.14
	OPENBSD_3_3:1.14.0.2
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.12.0.2
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	SMP:1.9.0.2
	UBC:1.7.0.2
	UBC_SYNC_B:1.12;
locks; strict;
comment	@ * @;


1.27
date	2015.10.28.05.11.55;	author jsg;	state Exp;
branches;
next	1.26;
commitid	B4LPDyoEsWMzuD6q;

1.26
date	2013.05.10.16.00.08;	author mikeb;	state Exp;
branches;
next	1.25;

1.25
date	2013.04.21.14.44.16;	author sebastia;	state Exp;
branches;
next	1.24;

1.24
date	2011.03.18.21.01.17;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2009.01.12.21.11.58;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2009.01.11.16.12.15;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2009.01.11.15.53.58;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2008.10.15.19.12.19;	author blambert;	state Exp;
branches;
next	1.19;

1.19
date	2007.05.25.21.27.15;	author krw;	state Exp;
branches;
next	1.18;

1.18
date	2005.11.11.16.44.51;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2005.05.14.15.25.20;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2005.03.06.23.23.10;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2003.06.02.23.27.55;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2003.03.09.01.43.46;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2002.11.29.01.00.49;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2002.05.29.20.43.43;	author maja;	state Exp;
branches;
next	1.11;

1.11
date	2002.03.21.03.09.33;	author jason;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.14.01.26.44;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.05.20.10.51;	author jason;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2002.02.12.04.37.47;	author jason;	state Exp;
branches;
next	1.7;

1.7
date	2002.01.31.16.39.17;	author jason;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2002.01.25.03.24.53;	author jason;	state Exp;
branches;
next	1.5;

1.5
date	2002.01.16.21.32.59;	author jason;	state Exp;
branches;
next	1.4;

1.4
date	2002.01.16.18.04.42;	author jason;	state Exp;
branches;
next	1.3;

1.3
date	2002.01.16.16.25.49;	author jason;	state Exp;
branches;
next	1.2;

1.2
date	2002.01.16.15.35.26;	author jason;	state Exp;
branches;
next	1.1;

1.1
date	2002.01.15.22.00.12;	author jason;	state Exp;
branches;
next	;

1.7.2.1
date	2002.01.31.22.55.24;	author niklas;	state Exp;
branches;
next	1.7.2.2;

1.7.2.2
date	2002.06.11.03.38.43;	author art;	state Exp;
branches;
next	1.7.2.3;

1.7.2.3
date	2003.05.19.21.46.57;	author tedu;	state Exp;
branches;
next	;

1.9.2.1
date	2002.03.28.11.23.52;	author niklas;	state Exp;
branches;
next	1.9.2.2;

1.9.2.2
date	2003.03.27.23.42.36;	author niklas;	state Exp;
branches;
next	1.9.2.3;

1.9.2.3
date	2003.06.07.11.14.45;	author ho;	state Exp;
branches;
next	;


desc
@@


1.27
log
@missing splx in error path
same change made in the sparc equivalent a while ago
@
text
@/*	$OpenBSD: z8530kbd.c,v 1.26 2013/05/10 16:00:08 mikeb Exp $	*/
/*	$NetBSD: z8530tty.c,v 1.77 2001/05/30 15:24:24 lukem Exp $	*/

/*-
 * Copyright (c) 1993, 1994, 1995, 1996, 1997, 1998, 1999
 *	Charles M. Hannum.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Charles M. Hannum.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 1994 Gordon W. Ross
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
 *
 * All advertising materials mentioning features or use of this software
 * must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Lawrence Berkeley Laboratory.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)zs.c	8.1 (Berkeley) 7/19/93
 */

/*
 * Zilog Z8530 Dual UART driver (tty interface)
 *
 * This is the "slave" driver that will be attached to
 * the "zsc" driver for plain "tty" async. serial lines.
 *
 * Credits, history:
 *
 * The original version of this code was the sparc/dev/zs.c driver
 * as distributed with the Berkeley 4.4 Lite release.  Since then,
 * Gordon Ross reorganized the code into the current parent/child
 * driver scheme, separating the Sun keyboard and mouse support
 * into independent child drivers.
 *
 * RTS/CTS flow-control support was a collaboration of:
 *	Gordon Ross <gwr@@netbsd.org>,
 *	Bill Studenmund <wrstuden@@loki.stanford.edu>
 *	Ian Dall <Ian.Dall@@dsto.defence.gov.au>
 *
 * The driver was massively overhauled in November 1997 by Charles Hannum,
 * fixing *many* bugs, and substantially improving performance.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/device.h>
#include <sys/conf.h>
#include <sys/file.h>
#include <sys/ioctl.h>
#include <sys/malloc.h>
#include <sys/tty.h>
#include <sys/time.h>
#include <sys/kernel.h>
#include <sys/syslog.h>

#include <machine/autoconf.h>

#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wskbdvar.h>

#include <dev/sun/sunkbdreg.h>
#include <dev/sun/sunkbdvar.h>

#include <dev/ic/z8530reg.h>
#include <machine/z8530var.h>

#include <dev/cons.h>

/*
 * How many input characters we can buffer.
 * The port-specific var.h may override this.
 * Note: must be a power of two!
 */
#ifndef	ZSKBD_RING_SIZE
#define	ZSKBD_RING_SIZE	2048
#endif

struct cfdriver zskbd_cd = {
	NULL, "zskbd", DV_TTY
};

/*
 * Make this an option variable one can patch.
 * But be warned:  this must be a power of 2!
 */
u_int zskbd_rbuf_size = ZSKBD_RING_SIZE;

/* Stop input when 3/4 of the ring is full; restart when only 1/4 is full. */
u_int zskbd_rbuf_hiwat = (ZSKBD_RING_SIZE * 1) / 4;
u_int zskbd_rbuf_lowat = (ZSKBD_RING_SIZE * 3) / 4;

struct zskbd_softc {
	struct sunkbd_softc	sc_base;

	struct	zs_chanstate *zst_cs;

	struct timeout zst_diag_ch;

	u_int zst_overflows,
	      zst_floods,
	      zst_errors;

	int zst_hwflags,	/* see z8530var.h */
	    zst_swflags;	/* TIOCFLAG_SOFTCAR, ... <ttycom.h> */

	u_int zst_r_hiwat,
	      zst_r_lowat;
	u_char *volatile zst_rbget,
	       *volatile zst_rbput;
	volatile u_int zst_rbavail;
	u_char *zst_rbuf,
	       *zst_ebuf;

	/*
	 * The transmit byte count and address are used for pseudo-DMA
	 * output in the hardware interrupt code.  PDMA can be suspended
	 * to get pending changes done; heldtbc is used for this.  It can
	 * also be stopped for ^S; this sets TS_TTSTOP in tp->t_state.
	 */
	u_char *zst_tba;		/* transmit buffer address */
	u_int zst_tbc,			/* transmit byte count */
	      zst_heldtbc;		/* held tbc while xmission stopped */

	u_char zst_tbuf[ZSKBD_RING_SIZE];
	u_char *zst_tbeg, *zst_tend, *zst_tbp;

	/* Flags to communicate with zskbd_softint() */
	volatile u_char zst_rx_flags,	/* receiver blocked */
#define	RX_TTY_BLOCKED		0x01
#define	RX_TTY_OVERFLOWED	0x02
#define	RX_IBUF_BLOCKED		0x04
#define	RX_IBUF_OVERFLOWED	0x08
#define	RX_ANY_BLOCK		0x0f
			zst_tx_busy,	/* working on an output chunk */
			zst_tx_done,	/* done with one output chunk */
			zst_tx_stopped,	/* H/W level stop (lost CTS) */
			zst_st_check,	/* got a status interrupt */
			zst_rx_ready;

	/* PPS signal on DCD, with or without inkernel clock disciplining */
	u_char  zst_ppsmask;			/* pps signal mask */
	u_char  zst_ppsassert;			/* pps leading edge */
	u_char  zst_ppsclear;			/* pps trailing edge */
};

/* Definition of the driver for autoconfig. */
static int	zskbd_match(struct device *, void *, void *);
static void	zskbd_attach(struct device *, struct device *, void *);

struct cfattach zskbd_ca = {
	sizeof(struct zskbd_softc), zskbd_match, zskbd_attach
};

struct zsops zsops_kbd;

static void zs_modem(struct zskbd_softc *, int);
static void zs_hwiflow(struct zskbd_softc *);
static void zs_maskintr(struct zskbd_softc *);

/* Low-level routines. */
static void zskbd_rxint(struct zs_chanstate *);
static void zskbd_stint(struct zs_chanstate *, int);
static void zskbd_txint(struct zs_chanstate *);
static void zskbd_softint(struct zs_chanstate *);
static void zskbd_diag(void *);

int zskbd_init(struct zskbd_softc *);
void zskbd_putc(struct zskbd_softc *, u_int8_t);
void zskbd_raw(struct zskbd_softc *, u_int8_t);

/* wskbd glue */
void zskbd_cngetc(void *, u_int *, int *);
void zskbd_cnpollc(void *, int);

void zsstart_tx(struct zskbd_softc *);
int zsenqueue_tx(void *, u_int8_t *, u_int);

struct wskbd_consops zskbd_consops = {
	zskbd_cngetc,
	zskbd_cnpollc
};

#define	ZSKBDUNIT(x)	(minor(x) & 0x7ffff)

/*
 * zskbd_match: how is this zs channel configured?
 */
int 
zskbd_match(parent, vcf, aux)
	struct device *parent;
	void *vcf;
	void   *aux;
{
	struct cfdata *cf = vcf;
	struct zsc_attach_args *args = aux;
	int ret;

	/* If we're not looking for a keyboard, just exit */
	if (strcmp(args->type, "keyboard") != 0)
		return (0);

	ret = 10;

	/* Exact match is better than wildcard. */
	if (cf->cf_loc[ZSCCF_CHANNEL] == args->channel)
		ret += 2;

	/* This driver accepts wildcard. */
	if (cf->cf_loc[ZSCCF_CHANNEL] == ZSCCF_CHANNEL_DEFAULT)
		ret += 1;

	return (ret);
}

void 
zskbd_attach(parent, self, aux)
	struct device *parent, *self;
	void   *aux;

{
	struct zsc_softc *zsc = (void *)parent;
	struct zskbd_softc *zst = (void *)self;
	struct sunkbd_softc *ss = (void *)self;
	struct cfdata *cf = self->dv_cfdata;
	struct zsc_attach_args *args = aux;
	struct wskbddev_attach_args a;
	struct zs_chanstate *cs;
	int channel, s, tty_unit, console = 0;
	dev_t dev;

	ss->sc_sendcmd = zsenqueue_tx;
	timeout_set(&ss->sc_bellto, sunkbd_bellstop, zst);

	timeout_set(&zst->zst_diag_ch, zskbd_diag, zst);

	zst->zst_tbp = zst->zst_tba = zst->zst_tbeg = zst->zst_tbuf;
	zst->zst_tend = zst->zst_tbeg + ZSKBD_RING_SIZE;

	tty_unit = ss->sc_dev.dv_unit;
	channel = args->channel;
	cs = zsc->zsc_cs[channel];
	cs->cs_private = zst;
	cs->cs_ops = &zsops_kbd;

	zst->zst_cs = cs;
	zst->zst_swflags = cf->cf_flags;	/* softcar, etc. */
	zst->zst_hwflags = args->hwflags;
	dev = makedev(zs_major, tty_unit);

	if (zst->zst_swflags)
		printf(" flags 0x%x", zst->zst_swflags);

	/*
	 * Check whether we serve as a console device.
	 * XXX - split console input/output channels aren't
	 *	 supported yet on /dev/console
	 */
	if ((zst->zst_hwflags & ZS_HWFLAG_CONSOLE_INPUT) != 0) {
		if ((args->hwflags & ZS_HWFLAG_USE_CONSDEV) != 0) {
			args->consdev->cn_dev = dev;
			cn_tab->cn_pollc = wskbd_cnpollc;
			cn_tab->cn_getc = wskbd_cngetc;
		}
		cn_tab->cn_dev = dev;
		console = 1;
	}

	zst->zst_rbuf = malloc(zskbd_rbuf_size << 1, M_DEVBUF, M_WAITOK);
	zst->zst_ebuf = zst->zst_rbuf + (zskbd_rbuf_size << 1);
	/* Disable the high water mark. */
	zst->zst_r_hiwat = 0;
	zst->zst_r_lowat = 0;
	zst->zst_rbget = zst->zst_rbput = zst->zst_rbuf;
	zst->zst_rbavail = zskbd_rbuf_size;

	/* if there are no enable/disable functions, assume the device
	   is always enabled */
	if (!cs->enable)
		cs->enabled = 1;

	/*
	 * Hardware init
	 */
	if (ISSET(zst->zst_hwflags, ZS_HWFLAG_CONSOLE)) {
		/* Call zsparam similar to open. */

		/* Wait a while for previous console output to complete */
		DELAY(10000);
	} else if (!ISSET(zst->zst_hwflags, ZS_HWFLAG_NORESET)) {
		/* Not the console; may need reset. */
		int reset;

		reset = (channel == 0) ? ZSWR9_A_RESET : ZSWR9_B_RESET;
		s = splzs();
		zs_write_reg(cs, 9, reset);
		splx(s);
	}

	/*
	 * Probe for a keyboard.
	 * If one is found, turn on receiver and status interrupts.
	 * We defer the actual write of the register to zsparam(),
	 * but we must make sure status interrupts are turned on by
	 * the time zsparam() reads the initial rr0 state.
	 */
	if (zskbd_init(zst)) {
		SET(cs->cs_preg[1], ZSWR1_RIE | ZSWR1_SIE);
		zs_write_reg(cs, 1, cs->cs_creg[1]);

		/* Make sure DTR is on now. */
		s = splzs();
		zs_modem(zst, 1);
		splx(s);
	} else {
		/* Will raise DTR in open. */
		s = splzs();
		zs_modem(zst, 0);
		splx(s);

		return;
	}

	ss->sc_click =
	    strcmp(getpropstring(optionsnode, "keyboard-click?"), "true") == 0;
	sunkbd_setclick(ss, ss->sc_click);

	a.console = console;
	if (ISTYPE5(ss->sc_layout)) {
		a.keymap = &sunkbd5_keymapdata;
#ifndef	SUNKBD5_LAYOUT
		if (ss->sc_layout < MAXSUNLAYOUT &&
		    sunkbd_layouts[ss->sc_layout] != -1)
			sunkbd5_keymapdata.layout =
			    sunkbd_layouts[ss->sc_layout];
#endif
	} else {
		a.keymap = &sunkbd_keymapdata;
#ifndef	SUNKBD_LAYOUT
		if (ss->sc_layout < MAXSUNLAYOUT &&
		    sunkbd_layouts[ss->sc_layout] != -1)
			sunkbd_keymapdata.layout =
			    sunkbd_layouts[ss->sc_layout];
#endif
	}
	a.accessops = &sunkbd_accessops;
	a.accesscookie = zst;

	if (console)
		wskbd_cnattach(&zskbd_consops, zst, a.keymap);

	sunkbd_attach(ss, &a);
}

int
zskbd_init(zst)
	struct zskbd_softc *zst;
{
	struct sunkbd_softc *ss = (void *)zst;
	struct zs_chanstate *cs = zst->zst_cs;
	int s, tries;
	u_int8_t v3, v4, v5, rr0;

	/* setup for 1200n81 */
	if (zs_set_speed(cs, 1200)) {			/* set 1200bps */
		printf(": failed to set baudrate\n");
		return 0;
	}
	if (zs_set_modes(cs, CS8 | CLOCAL)) {
		printf(": failed to set modes\n");
		return 0;
	}

	s = splzs();

	zs_maskintr(zst);

	v3 = cs->cs_preg[3];				/* set 8 bit chars */
	v5 = cs->cs_preg[5];
	CLR(v3, ZSWR3_RXSIZE);
	CLR(v5, ZSWR5_TXSIZE);
	SET(v3, ZSWR3_RX_8);
	SET(v5, ZSWR5_TX_8);
	cs->cs_preg[3] = v3;
	cs->cs_preg[5] = v5;

	v4 = cs->cs_preg[4];				/* no parity 1 stop */
	CLR(v4, ZSWR4_SBMASK | ZSWR4_PARMASK);
	SET(v4, ZSWR4_ONESB | ZSWR4_EVENP);
	cs->cs_preg[4] = v4;

	if (!cs->cs_heldchange) {
		if (zst->zst_tx_busy) {
			zst->zst_heldtbc = zst->zst_tbc;
			zst->zst_tbc = 0;
			cs->cs_heldchange = 1;
		} else
			zs_loadchannelregs(cs);
	}

	/*
	 * Hardware flow control is disabled, turn off the buffer water
	 * marks and unblock any soft flow control state.  Otherwise, enable
	 * the water marks.
	 */
	zst->zst_r_hiwat = 0;
	zst->zst_r_lowat = 0;
	if (ISSET(zst->zst_rx_flags, RX_TTY_OVERFLOWED)) {
		CLR(zst->zst_rx_flags, RX_TTY_OVERFLOWED);
		zst->zst_rx_ready = 1;
		cs->cs_softreq = 1;
	}
	if (ISSET(zst->zst_rx_flags, RX_TTY_BLOCKED|RX_IBUF_BLOCKED)) {
		CLR(zst->zst_rx_flags, RX_TTY_BLOCKED|RX_IBUF_BLOCKED);
		zs_hwiflow(zst);
	}

	/*
	 * Force a recheck of the hardware carrier and flow control status,
	 * since we may have changed which bits we're looking at.
	 */
	zskbd_stint(cs, 1);

	splx(s);

	/*
	 * Hardware flow control is disabled, unblock any hard flow control
	 * state.
	 */
	if (zst->zst_tx_stopped) {
		zst->zst_tx_stopped = 0;
		zsstart_tx(zst);
	}

	zskbd_softint(cs);

	/* Ok, start the reset sequence... */

	s = splhigh();

	for (tries = 5; tries != 0; tries--) {
		int ltries;

		ss->sc_leds = 0;
		ss->sc_layout = -1;

		/* Send reset request */
		zskbd_putc(zst, SKBD_CMD_RESET);

		ltries = 1000;
		while (--ltries > 0) {
			rr0 = *cs->cs_reg_csr;
			if (rr0 & ZSRR0_RX_READY) {
				sunkbd_raw(ss, *cs->cs_reg_data);
				if (ss->sc_kbdstate == SKBD_STATE_RESET)
					break;
			}
			DELAY(1000);
		}
		if (ltries == 0)
			continue;

		/* Wait for reset to finish. */
		ltries = 1000;
		while (--ltries > 0) {
			rr0 = *cs->cs_reg_csr;
			if (rr0 & ZSRR0_RX_READY) {
				sunkbd_raw(ss, *cs->cs_reg_data);
				if (ss->sc_kbdstate == SKBD_STATE_GETKEY)
					break;
			}
			DELAY(1000);
		}
		if (ltries == 0)
			continue;

		/* Some Sun<=>PS/2 converters need some delay here */
		DELAY(5000);

		/* Send layout request */
		zskbd_putc(zst, SKBD_CMD_LAYOUT);

		ltries = 1000;
		while (--ltries > 0) {
			rr0 = *cs->cs_reg_csr;
			if (rr0 & ZSRR0_RX_READY) {
				sunkbd_raw(ss, *cs->cs_reg_data);
				if (ss->sc_layout != -1)
					break;
			}
			DELAY(1000);
		}
		if (ltries == 0)
			continue;
		break;
	}
	if (tries == 0)
		printf(": no keyboard\n");
	else
		printf(": layout %d\n", ss->sc_layout);
	splx(s);

	return tries;
}

void
zskbd_putc(zst, c)
	struct zskbd_softc *zst;
	u_int8_t c;
{
	u_int8_t rr0;
	int s;

	s = splhigh();
	do {
		rr0 = *zst->zst_cs->cs_reg_csr;
	} while ((rr0 & ZSRR0_TX_READY) == 0);
	*zst->zst_cs->cs_reg_data = c;
	delay(2);
	splx(s);
}

int
zsenqueue_tx(v, str, len)
	void *v;
	u_int8_t *str;
	u_int len;
{
	struct zskbd_softc *zst = v;
	int s;
	u_int i;

	s = splzs();
	if (zst->zst_tbc + len > ZSKBD_RING_SIZE) {
		splx(s);
		return (-1);
	}
	zst->zst_tbc += len;
	for (i = 0; i < len; i++) {
		*zst->zst_tbp = str[i];
		if (++zst->zst_tbp == zst->zst_tend)
			zst->zst_tbp = zst->zst_tbeg;
	}
	splx(s);
	zsstart_tx(zst);
	return (0);
}

void
zsstart_tx(zst)
	struct zskbd_softc *zst;
{
	struct zs_chanstate *cs = zst->zst_cs;
	int s, s1;

	s = spltty();

	if (zst->zst_tx_stopped)
		goto out;
	if (zst->zst_tbc == 0)
		goto out;

	s1 = splzs();

	zst->zst_tx_busy = 1;

	if (!ISSET(cs->cs_preg[1], ZSWR1_TIE)) {
		SET(cs->cs_preg[1], ZSWR1_TIE);
		cs->cs_creg[1] = cs->cs_preg[1];
		zs_write_reg(cs, 1, cs->cs_creg[1]);
	}

	zs_write_data(cs, *zst->zst_tba);

	zst->zst_tbc--;
	if (++zst->zst_tba == zst->zst_tend)
		zst->zst_tba = zst->zst_tbeg;

	splx(s1);

out:
	splx(s);
}

/*
 * Compute interrupt enable bits and set in the pending bits. Called both
 * in zsparam() and when PPS (pulse per second timing) state changes.
 * Must be called at splzs().
 */
static void
zs_maskintr(zst)
	struct zskbd_softc *zst;
{
	struct zs_chanstate *cs = zst->zst_cs;
	int tmp15;

	cs->cs_rr0_mask = cs->cs_rr0_cts | cs->cs_rr0_dcd;
	if (zst->zst_ppsmask != 0)
		cs->cs_rr0_mask |= cs->cs_rr0_pps;
	tmp15 = cs->cs_preg[15];
	if (ISSET(cs->cs_rr0_mask, ZSRR0_DCD))
		SET(tmp15, ZSWR15_DCD_IE);
	else
		CLR(tmp15, ZSWR15_DCD_IE);
	if (ISSET(cs->cs_rr0_mask, ZSRR0_CTS))
		SET(tmp15, ZSWR15_CTS_IE);
	else
		CLR(tmp15, ZSWR15_CTS_IE);
	cs->cs_preg[15] = tmp15;
}


/*
 * Raise or lower modem control (DTR/RTS) signals.  If a character is
 * in transmission, the change is deferred.
 */
static void
zs_modem(zst, onoff)
	struct zskbd_softc *zst;
	int onoff;
{
	struct zs_chanstate *cs = zst->zst_cs;

	if (cs->cs_wr5_dtr == 0)
		return;

	if (onoff)
		SET(cs->cs_preg[5], cs->cs_wr5_dtr);
	else
		CLR(cs->cs_preg[5], cs->cs_wr5_dtr);

	if (!cs->cs_heldchange) {
		if (zst->zst_tx_busy) {
			zst->zst_heldtbc = zst->zst_tbc;
			zst->zst_tbc = 0;
			cs->cs_heldchange = 1;
		} else
			zs_loadchannelregs(cs);
	}
}

/*
 * Internal version of zshwiflow
 * called at splzs
 */
static void
zs_hwiflow(zst)
	struct zskbd_softc *zst;
{
	struct zs_chanstate *cs = zst->zst_cs;

	if (cs->cs_wr5_rts == 0)
		return;

	if (ISSET(zst->zst_rx_flags, RX_ANY_BLOCK)) {
		CLR(cs->cs_preg[5], cs->cs_wr5_rts);
		CLR(cs->cs_creg[5], cs->cs_wr5_rts);
	} else {
		SET(cs->cs_preg[5], cs->cs_wr5_rts);
		SET(cs->cs_creg[5], cs->cs_wr5_rts);
	}
	zs_write_reg(cs, 5, cs->cs_creg[5]);
}


/****************************************************************
 * Interface to the lower layer (zscc)
 ****************************************************************/

#define	integrate
integrate void zskbd_rxsoft(struct zskbd_softc *);
integrate void zskbd_txsoft(struct zskbd_softc *);
integrate void zskbd_stsoft(struct zskbd_softc *);
/*
 * receiver ready interrupt.
 * called at splzs
 */
static void
zskbd_rxint(cs)
	struct zs_chanstate *cs;
{
	struct zskbd_softc *zst = cs->cs_private;
	u_char *put, *end;
	u_int cc;
	u_char rr0, rr1, c;

	end = zst->zst_ebuf;
	put = zst->zst_rbput;
	cc = zst->zst_rbavail;

	while (cc > 0) {
		/*
		 * First read the status, because reading the received char
		 * destroys the status of this char.
		 */
		rr1 = zs_read_reg(cs, 1);
		c = zs_read_data(cs);

		if (ISSET(rr1, ZSRR1_FE | ZSRR1_DO | ZSRR1_PE)) {
			/* Clear the receive error. */
			zs_write_csr(cs, ZSWR0_RESET_ERRORS);
		}

		put[0] = c;
		put[1] = rr1;
		put += 2;
		if (put >= end)
			put = zst->zst_rbuf;
		cc--;

		rr0 = zs_read_csr(cs);
		if (!ISSET(rr0, ZSRR0_RX_READY))
			break;
	}

	/*
	 * Current string of incoming characters ended because
	 * no more data was available or we ran out of space.
	 * Schedule a receive event if any data was received.
	 * If we're out of space, turn off receive interrupts.
	 */
	zst->zst_rbput = put;
	zst->zst_rbavail = cc;
	if (!ISSET(zst->zst_rx_flags, RX_TTY_OVERFLOWED)) {
		zst->zst_rx_ready = 1;
		cs->cs_softreq = 1;
	}

	/*
	 * See if we are in danger of overflowing a buffer. If
	 * so, use hardware flow control to ease the pressure.
	 */
	if (!ISSET(zst->zst_rx_flags, RX_IBUF_BLOCKED) &&
	    cc < zst->zst_r_hiwat) {
		SET(zst->zst_rx_flags, RX_IBUF_BLOCKED);
		zs_hwiflow(zst);
	}

	/*
	 * If we're out of space, disable receive interrupts
	 * until the queue has drained a bit.
	 */
	if (!cc) {
		SET(zst->zst_rx_flags, RX_IBUF_OVERFLOWED);
		CLR(cs->cs_preg[1], ZSWR1_RIE);
		cs->cs_creg[1] = cs->cs_preg[1];
		zs_write_reg(cs, 1, cs->cs_creg[1]);
	}
}

/*
 * transmitter ready interrupt.  (splzs)
 */
static void
zskbd_txint(cs)
	struct zs_chanstate *cs;
{
	struct zskbd_softc *zst = cs->cs_private;

	/*
	 * If we've delayed a parameter change, do it now, and restart
	 * output.
	 */
	if (cs->cs_heldchange) {
		zs_loadchannelregs(cs);
		cs->cs_heldchange = 0;
		zst->zst_tbc = zst->zst_heldtbc;
		zst->zst_heldtbc = 0;
	}

	/* Output the next character in the buffer, if any. */
	if (zst->zst_tbc > 0) {
		zs_write_data(cs, *zst->zst_tba);
		zst->zst_tbc--;
		if (++zst->zst_tba == zst->zst_tend)
			zst->zst_tba = zst->zst_tbeg;
	} else {
		/* Disable transmit completion interrupts if necessary. */
		if (ISSET(cs->cs_preg[1], ZSWR1_TIE)) {
			CLR(cs->cs_preg[1], ZSWR1_TIE);
			cs->cs_creg[1] = cs->cs_preg[1];
			zs_write_reg(cs, 1, cs->cs_creg[1]);
		}
		if (zst->zst_tx_busy) {
			zst->zst_tx_busy = 0;
			zst->zst_tx_done = 1;
			cs->cs_softreq = 1;
		}
	}
}

/*
 * status change interrupt.  (splzs)
 */
static void
zskbd_stint(cs, force)
	struct zs_chanstate *cs;
	int force;
{
	struct zskbd_softc *zst = cs->cs_private;
	u_char rr0, delta;

	rr0 = zs_read_csr(cs);
	zs_write_csr(cs, ZSWR0_RESET_STATUS);

	/*
	 * Check here for console break, so that we can abort
	 * even when interrupts are locking up the machine.
	 */
	if (!force)
		delta = rr0 ^ cs->cs_rr0;
	else
		delta = cs->cs_rr0_mask;
	cs->cs_rr0 = rr0;

	if (ISSET(delta, cs->cs_rr0_mask)) {
		SET(cs->cs_rr0_delta, delta);

		/*
		 * Stop output immediately if we lose the output
		 * flow control signal or carrier detect.
		 */
		if (ISSET(~rr0, cs->cs_rr0_mask)) {
			zst->zst_tbc = 0;
			zst->zst_heldtbc = 0;
		}

		zst->zst_st_check = 1;
		cs->cs_softreq = 1;
	}
}

void
zskbd_diag(arg)
	void *arg;
{
	struct zskbd_softc *zst = arg;
	struct sunkbd_softc *ss = arg;
	int overflows, floods;
	int s;

	s = splzs();
	overflows = zst->zst_overflows;
	zst->zst_overflows = 0;
	floods = zst->zst_floods;
	zst->zst_floods = 0;
	zst->zst_errors = 0;
	splx(s);

	log(LOG_WARNING, "%s: %d silo overflow%s, %d ibuf flood%s\n",
	    ss->sc_dev.dv_xname,
	    overflows, overflows == 1 ? "" : "s",
	    floods, floods == 1 ? "" : "s");
}

integrate void
zskbd_rxsoft(zst)
	struct zskbd_softc *zst;
{
	struct sunkbd_softc *ss = (void *)zst;
	struct zs_chanstate *cs = zst->zst_cs;
	u_char *get, *end;
	u_int cc, scc;
	u_char rr1;
	int code;
	int s;
	u_int8_t cbuf[SUNKBD_MAX_INPUT_SIZE], *c;

	end = zst->zst_ebuf;
	get = zst->zst_rbget;
	scc = cc = zskbd_rbuf_size - zst->zst_rbavail;

	if (cc == zskbd_rbuf_size) {
		zst->zst_floods++;
		if (zst->zst_errors++ == 0)
			timeout_add_sec(&zst->zst_diag_ch, 60);
	}

	c = cbuf;
	while (cc) {
		code = get[0];
		rr1 = get[1];
		if (ISSET(rr1, ZSRR1_DO | ZSRR1_FE | ZSRR1_PE)) {
			if (ISSET(rr1, ZSRR1_DO)) {
				zst->zst_overflows++;
				if (zst->zst_errors++ == 0)
					timeout_add_sec(&zst->zst_diag_ch, 60);
			}
			if (ISSET(rr1, ZSRR1_FE))
				SET(code, TTY_FE);
			if (ISSET(rr1, ZSRR1_PE))
				SET(code, TTY_PE);
		}

		*c++ = code;
		if (c - cbuf == sizeof cbuf) {
			sunkbd_input(ss, cbuf, c - cbuf);
			c = cbuf;
		}

		get += 2;
		if (get >= end)
			get = zst->zst_rbuf;
		cc--;
	}
	if (c != cbuf)
		sunkbd_input(ss, cbuf, c - cbuf);

	if (cc != scc) {
		zst->zst_rbget = get;
		s = splzs();
		cc = zst->zst_rbavail += scc - cc;
		/* Buffers should be ok again, release possible block. */
		if (cc >= zst->zst_r_lowat) {
			if (ISSET(zst->zst_rx_flags, RX_IBUF_OVERFLOWED)) {
				CLR(zst->zst_rx_flags, RX_IBUF_OVERFLOWED);
				SET(cs->cs_preg[1], ZSWR1_RIE);
				cs->cs_creg[1] = cs->cs_preg[1];
				zs_write_reg(cs, 1, cs->cs_creg[1]);
			}
			if (ISSET(zst->zst_rx_flags, RX_IBUF_BLOCKED)) {
				CLR(zst->zst_rx_flags, RX_IBUF_BLOCKED);
				zs_hwiflow(zst);
			}
		}
		splx(s);
	}
}

integrate void
zskbd_txsoft(zst)
	struct zskbd_softc *zst;
{
}

integrate void
zskbd_stsoft(zst)
	struct zskbd_softc *zst;
{
	struct zs_chanstate *cs = zst->zst_cs;
	u_char rr0, delta;
	int s;

	s = splzs();
	rr0 = cs->cs_rr0;
	delta = cs->cs_rr0_delta;
	cs->cs_rr0_delta = 0;
	splx(s);

	if (ISSET(delta, cs->cs_rr0_cts)) {
		/* Block or unblock output according to flow control. */
		if (ISSET(rr0, cs->cs_rr0_cts))
			zst->zst_tx_stopped = 0;
		else
			zst->zst_tx_stopped = 1;
	}
}

/*
 * Software interrupt.  Called at zssoft
 *
 * The main job to be done here is to empty the input ring
 * by passing its contents up to the tty layer.  The ring is
 * always emptied during this operation, therefore the ring
 * must not be larger than the space after "high water" in
 * the tty layer, or the tty layer might drop our input.
 *
 * Note: an "input blockage" condition is assumed to exist if
 * EITHER the TS_TBLOCK flag or zst_rx_blocked flag is set.
 */
static void
zskbd_softint(cs)
	struct zs_chanstate *cs;
{
	struct zskbd_softc *zst = cs->cs_private;
	int s;

	s = spltty();

	if (zst->zst_rx_ready) {
		zst->zst_rx_ready = 0;
		zskbd_rxsoft(zst);
	}

	if (zst->zst_st_check) {
		zst->zst_st_check = 0;
		zskbd_stsoft(zst);
	}

	if (zst->zst_tx_done) {
		zst->zst_tx_done = 0;
		zskbd_txsoft(zst);
	}

	splx(s);
}

struct zsops zsops_kbd = {
	zskbd_rxint,	/* receive char available */
	zskbd_stint,	/* external/status */
	zskbd_txint,	/* xmit buffer empty */
	zskbd_softint,	/* process software interrupt */
};

void
zskbd_cnpollc(v, on)
	void *v;
	int on;
{
	extern int swallow_zsintrs;

	if (on)
		swallow_zsintrs++;
	else
		swallow_zsintrs--;
}

void
zskbd_cngetc(v, type, data)
	void *v;
	u_int *type;
	int *data;
{
	struct zskbd_softc *zst = v;
	int s;
	u_int8_t c, rr0;

	s = splhigh();
	do {
		rr0 = *zst->zst_cs->cs_reg_csr;
	} while ((rr0 & ZSRR0_RX_READY) == 0);

	c = *zst->zst_cs->cs_reg_data;
	splx(s);

	sunkbd_decode(c, type, data);
}
@


1.26
log
@ditch unused zskbd_device_lookup; verified by sebastia@@
@
text
@d1 1
a1 1
/*	$OpenBSD: z8530kbd.c,v 1.25 2013/04/21 14:44:16 sebastia Exp $	*/
d588 2
a589 1
	if (zst->zst_tbc + len > ZSKBD_RING_SIZE)
d591 1
@


1.25
log
@Unify the zs tty driver.

Most of the hard work by mpi@@, who provided the initial diff.
Fixes for sparc from myself. Tested on sgi and sparc myself.
Compiles and detects zstty on my powerbook, compile tested on
sparc64 by me. Real testing with zs device on sparc64 by miod@@
who also gave a lot of help and feedback.

ok miod@@, mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: z8530kbd.c,v 1.24 2011/03/18 21:01:17 miod Exp $	*/
a214 2
struct zskbd_softc *zskbd_device_lookup(struct cfdriver *, int);

a238 8

struct zskbd_softc *
zskbd_device_lookup(cf, unit)
	struct cfdriver *cf;
	int unit;
{ 
	return (struct zskbd_softc *)device_lookup(cf, unit);
}
@


1.24
log
@Add some delay between a successful keyboard reset sequence and a keyboard
layout inquiry, as some PS/2 converters (at least the Starview SV 125) need
it to behave correctly.
Found the hard way and researched by Mike Malopolski, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: z8530kbd.c,v 1.23 2009/01/12 21:11:58 miod Exp $	*/
d119 1
a119 1
#include <sparc64/dev/z8530reg.h>
@


1.23
log
@Oops, sunkbd_decode() still needs to be public for *cngetc() to work;
spotted the hard way by kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: z8530kbd.c,v 1.22 2009/01/11 16:12:15 miod Exp $	*/
d541 2
@


1.22
log
@Define a limit to the input which can be fed to sunkbd_input() at once,
will be necessary for rawkbd mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: z8530kbd.c,v 1.21 2009/01/11 15:53:58 miod Exp $	*/
d1096 1
a1096 11
	switch (c) {
	case SKBD_RSP_IDLE:
		*type = WSCONS_EVENT_ALL_KEYS_UP;
		*data = 0;
		break;
	default:
		*type = (c & 0x80) ?
		    WSCONS_EVENT_KEY_UP : WSCONS_EVENT_KEY_DOWN;
		*data = c & 0x7f;
		break;
	}
@


1.21
log
@Factor a bit more sunkbd common parts; paves the way for upcoming
WSDISPLAY_COMPAT_RAWKBD support.
@
text
@d1 1
a1 1
/*	$OpenBSD: z8530kbd.c,v 1.20 2008/10/15 19:12:19 blambert Exp $	*/
d927 1
a927 1
	u_int8_t cbuf[64], *c;
@


1.20
log
@Second pass of simple timeout_add -> timeout_add_sec conversions
This should take care of the simpler ones (i.e., timeout values of
integer multiples of hz).

ok krw@@, art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: z8530kbd.c,v 1.19 2007/05/25 21:27:15 krw Exp $	*/
d416 1
a416 1
	ss->sc_wskbddev = config_found(self, &a, wskbddevprint);
d923 1
a923 1
	u_int cc, scc, type;
d925 1
a925 1
	int code, value;
d927 1
d939 1
d955 5
a959 2
		sunkbd_decode(code, &type, &value);
		wskbd_input(ss->sc_wskbddev, type, value);
d966 2
@


1.19
log
@"interupt" -> "interrupt" in various comments. Mostly from Diego Casati.
@
text
@d1 1
a1 1
/*	$OpenBSD: z8530kbd.c,v 1.18 2005/11/11 16:44:51 miod Exp $	*/
d935 1
a935 1
			timeout_add(&zst->zst_diag_ch, 60 * hz);
d945 1
a945 1
					timeout_add(&zst->zst_diag_ch, 60 * hz);
@


1.18
log
@Enable or disable keyclick on attach, based upon the PROM keyboard-click?
property.
Tested with type 3 and type 4 keyboards.
@
text
@d1 1
a1 1
/*	$OpenBSD: z8530kbd.c,v 1.17 2005/05/14 15:25:20 miod Exp $	*/
d646 1
a646 1
 * Compute interupt enable bits and set in the pending bits. Called both
@


1.17
log
@Factorize most of the high-level logic for Sun serial keyboards in
sys/dev/sun/sunkbd.c, and move the layout tables to sys/dev/sun/sunkbdmap.c.

No functional changes, small sparc64 kernel shrinkage.
@
text
@d1 1
a1 1
/*	$OpenBSD: z8530kbd.c,v 1.16 2005/03/06 23:23:10 miod Exp $	*/
d111 2
d387 4
@


1.16
log
@Shorten dmesg if no keyboard is plugged.
@
text
@d1 1
a1 1
/*	$OpenBSD: z8530kbd.c,v 1.15 2003/06/02 23:27:55 millert Exp $	*/
a112 2
#include <dev/wscons/wsksymdef.h>
#include <dev/wscons/wsksymvar.h>
d146 2
a147 1
	struct	device zst_dev;		/* required first: base device */
d150 1
a150 1
	struct timeout zst_diag_ch, zst_bellto;
a196 6

	struct device *zst_wskbddev;
	int zst_leds;				/* LED status */
	u_int8_t zst_kbdstate;			/* keyboard state */
	int zst_layout;				/* current layout */
	int zst_bellactive, zst_belltimeout;
d210 1
a210 1
static void  zs_hwiflow(struct zskbd_softc *);
a226 4
int zskbd_enable(void *, int);
void zskbd_set_leds(void *, int);
int zskbd_get_leds(struct zskbd_softc *);
int zskbd_ioctl(void *, u_long, caddr_t, int, struct proc *);
d231 1
a231 9
int zsenqueue_tx(struct zskbd_softc *, u_char *, int);
void zskbd_bell(struct zskbd_softc *, u_int, u_int, u_int);
void zskbd_bellstop(void *);

struct wskbd_accessops zskbd_accessops = {
	zskbd_enable,
	zskbd_set_leds,
	zskbd_ioctl
};
d284 3
a286 2
	struct zsc_softc *zsc = (void *) parent;
	struct zskbd_softc *zst = (void *) self;
d294 3
a297 1
	timeout_set(&zst->zst_bellto, zskbd_bellstop, zst);
d302 1
a302 1
	tty_unit = zst->zst_dev.dv_unit;
d387 1
a387 1
	if (ISTYPE5(zst->zst_layout)) {
d390 2
a391 2
		if (zst->zst_layout < MAXSUNLAYOUT &&
		    sunkbd_layouts[zst->zst_layout] != -1)
d393 1
a393 1
			    sunkbd_layouts[zst->zst_layout];
d398 2
a399 2
		if (zst->zst_layout < MAXSUNLAYOUT &&
		    sunkbd_layouts[zst->zst_layout] != -1)
d401 1
a401 1
			    sunkbd_layouts[zst->zst_layout];
d404 1
a404 1
	a.accessops = &zskbd_accessops;
d410 1
a410 1
	zst->zst_wskbddev = config_found(self, &a, wskbddevprint);
d417 1
d502 2
a503 2
		zst->zst_leds = 0;
		zst->zst_layout = -1;
d512 2
a513 2
				zskbd_raw(zst, *cs->cs_reg_data);
				if (zst->zst_kbdstate == SKBD_STATE_RESET)
d526 2
a527 2
				zskbd_raw(zst, *cs->cs_reg_data);
				if (zst->zst_kbdstate == SKBD_STATE_GETKEY)
d543 2
a544 2
				zskbd_raw(zst, *cs->cs_reg_data);
				if (zst->zst_layout != -1)
d556 1
a556 1
		printf(": layout %d\n", zst->zst_layout);
a562 42
zskbd_raw(zst, c)
	struct zskbd_softc *zst;
	u_int8_t c;
{
	int claimed = 0;

	if (zst->zst_kbdstate == SKBD_STATE_LAYOUT) {
		zst->zst_kbdstate = SKBD_STATE_GETKEY;
		zst->zst_layout = c;
		return;
	}

	switch (c) {
	case SKBD_RSP_RESET:
		zst->zst_kbdstate = SKBD_STATE_RESET;
		claimed = 1;
		break;
	case SKBD_RSP_LAYOUT:
		zst->zst_kbdstate = SKBD_STATE_LAYOUT;
		claimed = 1;
		break;
	case SKBD_RSP_IDLE:
		zst->zst_kbdstate = SKBD_STATE_GETKEY;
		claimed = 1;
	}

	if (claimed)
		return;

	switch (zst->zst_kbdstate) {
	case SKBD_STATE_RESET:
		zst->zst_kbdstate = SKBD_STATE_GETKEY;
		if (c != SKBD_RSP_RESET_OK)
			printf("%s: reset1 invalid code 0x%02x\n",
			    zst->zst_dev.dv_xname, c);
		break;
	case SKBD_STATE_GETKEY:
		break;
	}
}

void
d580 4
a583 4
zsenqueue_tx(zst, str, len)
	struct zskbd_softc *zst;
	u_char *str;
	int len;
d585 3
a587 1
	int s, i;
d892 1
d905 1
a905 1
	    zst->zst_dev.dv_xname,
d914 1
d947 2
a948 12
		switch (code) {
		case SKBD_RSP_IDLE:
			type = WSCONS_EVENT_ALL_KEYS_UP;
			value = 0;
			break;
		default:
			type = (code & 0x80) ?
			    WSCONS_EVENT_KEY_UP : WSCONS_EVENT_KEY_DOWN;
			value = code & 0x7f;
			break;
		}
		wskbd_input(zst->zst_wskbddev, type, value);
a1050 121

int
zskbd_enable(v, on)
	void *v;
	int on;
{
	return (0);
}

void
zskbd_set_leds(v, wled)
	void *v;
	int wled;
{
	struct zskbd_softc *zst = v;
	u_int8_t sled = 0;
	u_int8_t cmd[2];

	zst->zst_leds = wled;

	if (wled & WSKBD_LED_CAPS)
		sled |= SKBD_LED_CAPSLOCK;
	if (wled & WSKBD_LED_NUM)
		sled |= SKBD_LED_NUMLOCK;
	if (wled & WSKBD_LED_SCROLL)
		sled |= SKBD_LED_SCROLLLOCK;
	if (wled & WSKBD_LED_COMPOSE)
		sled |= SKBD_LED_COMPOSE;

	cmd[0] = SKBD_CMD_SETLED;
	cmd[1] = sled;
	zsenqueue_tx(zst, cmd, sizeof(cmd));
}

int
zskbd_get_leds(zst)
	struct zskbd_softc *zst;
{
	return (zst->zst_leds);
}

int
zskbd_ioctl(v, cmd, data, flag, p)
	void *v;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
{
	struct zskbd_softc *zst = v;
	int *d_int = (int *)data;
	struct wskbd_bell_data *d_bell = (struct wskbd_bell_data *)data;

	switch (cmd) {
	case WSKBDIO_GTYPE:
		if (ISTYPE5(zst->zst_layout)) {
			*d_int = WSKBD_TYPE_SUN5;
		} else {
			*d_int = WSKBD_TYPE_SUN;
		}
		return (0);
	case WSKBDIO_SETLEDS:
		zskbd_set_leds(zst, *d_int);
		return (0);
	case WSKBDIO_GETLEDS:
		*d_int = zskbd_get_leds(zst);
		return (0);
	case WSKBDIO_COMPLEXBELL:
		zskbd_bell(zst, d_bell->period,
		    d_bell->pitch, d_bell->volume);
		return (0);
	}
	return (-1);
}

void
zskbd_bell(zst, period, pitch, volume)
	struct zskbd_softc *zst;
	u_int period, pitch, volume;
{
	int ticks, s;
	u_int8_t c = SKBD_CMD_BELLON;

	ticks = (period * hz)/1000;
	if (ticks <= 0)
		ticks = 1;

	s = splzs();
	if (zst->zst_bellactive) {
		if (zst->zst_belltimeout == 0)
			timeout_del(&zst->zst_bellto);
	}
	if (pitch == 0 || period == 0) {
		zskbd_bellstop(zst);
		splx(s);
		return;
	}
	if (!zst->zst_bellactive) {
		zst->zst_bellactive = 1;
		zst->zst_belltimeout = 1;
		zsenqueue_tx(zst, &c, 1);
		timeout_add(&zst->zst_bellto, ticks);
	}
	splx(s);
}

void
zskbd_bellstop(v)
	void *v;
{
	struct zskbd_softc *zst = v;
	int s;
	u_int8_t c;

	s = splzs();
	zst->zst_belltimeout = 0;
	c = SKBD_CMD_BELLOFF;
	zsenqueue_tx(zst, &c, 1);
	zst->zst_bellactive = 0;
	splx(s);
}
@


1.15
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: z8530kbd.c,v 1.14 2003/03/09 01:43:46 miod Exp $	*/
a398 1
		printf("%s: no keyboard\n", self->dv_xname);
d569 1
a569 1
		printf(": reset timeout\n");
@


1.14
log
@When a sparc machine is running with serial console, the zskbd probe would
try to use short cuts, and would not correctly initialize its channel if a
keyboard is connected to it, which might have been done on purpose.
It would then become impossible to run X11 on this machine afterwards.

Fix this by being more cautious during the probe, at the extent of a couple
of seconds if no keyboard is present.

Tested by various, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: z8530kbd.c,v 1.13 2002/11/29 01:00:49 miod Exp $	*/
d56 1
a56 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.13
log
@Upon detection of an international Sun keyboard with a recognized layout,
attach it with the appropriate keymap table, rather than the default KB_US
table.

If this is not the expected behaviour, users can still revert to US layout
via "kbd us" or "wsconsctl -w keyboard.encoding=us".

As the installation media uses the prom console, which will honor the
international keyboard layout, this will definitely help users with
international keyboards and fancy characters in their passwords...

Note that there is still some Sun keyboard tables missing at the moment.
@
text
@d1 1
a1 1
/*	$OpenBSD: z8530kbd.c,v 1.12 2002/05/29 20:43:43 maja Exp $	*/
d233 1
a233 1
void zskbd_init(struct zskbd_softc *);
a371 17

		/*
		 * Turn on receiver and status interrupts.
		 * We defer the actual write of the register to zsparam(),
		 * but we must make sure status interrupts are turned on by
		 * the time zsparam() reads the initial rr0 state.
		 */
		zskbd_init(zst);
		SET(cs->cs_preg[1], ZSWR1_RIE | ZSWR1_SIE);
		zs_write_reg(cs, 1, cs->cs_creg[1]);

		s = splzs();

		/* Make sure DTR is on now. */
		zs_modem(zst, 1);

		splx(s);
a376 1

d378 3
d382 10
a391 1
		zs_write_reg(cs, 9, reset);
d393 5
d399 1
d401 1
d403 3
a405 4
		splx(s);
		printf("\n");
	} else
		printf("\n");
d434 1
a434 1
void
d445 1
a445 1
		return;
d449 1
a449 1
		return;
d578 2
@


1.12
log
@Add a new wskbd type for Sun type 5 keyboards (WSKBD_TYPE_SUN5).
This is needed since eg Swedish type 4 and 5 keyboard has keycodes
with different keycodes. eg AltGr and Compose are switched in type 5
compared with type 4.

This change will need a new Xserver to allow sun type 5 keyboards.
-moj  ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: z8530kbd.c,v 1.11 2002/03/21 03:09:33 jason Exp $	*/
d410 6
d418 6
@


1.11
log
@pretty dmesg
@
text
@d1 1
a1 1
/*	$OpenBSD: z8530kbd.c,v 1.10 2002/03/14 01:26:44 millert Exp $	*/
d408 5
a412 1
	a.keymap = &sunkbd_keymapdata;
d417 1
a417 1
		wskbd_cnattach(&zskbd_consops, zst, &sunkbd_keymapdata);
d1160 5
a1164 1
		*d_int = WSKBD_TYPE_SUN;
@


1.10
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: z8530kbd.c,v 1.9 2002/03/05 20:10:51 jason Exp $	*/
d403 3
a405 3
	}

	printf("\n");
@


1.9
log
@Insert missing newline for autoconf prettiness.
@
text
@d1 1
a1 1
/*	$OpenBSD: z8530kbd.c,v 1.8 2002/02/12 04:37:47 jason Exp $	*/
d220 3
a222 3
static void zs_modem __P((struct zskbd_softc *, int));
static void  zs_hwiflow __P((struct zskbd_softc *));
static void zs_maskintr __P((struct zskbd_softc *));
d224 1
a224 1
struct zskbd_softc *zskbd_device_lookup __P((struct cfdriver *, int));
d227 9
a235 9
static void zskbd_rxint   __P((struct zs_chanstate *));
static void zskbd_stint   __P((struct zs_chanstate *, int));
static void zskbd_txint   __P((struct zs_chanstate *));
static void zskbd_softint __P((struct zs_chanstate *));
static void zskbd_diag __P((void *));

void zskbd_init __P((struct zskbd_softc *));
void zskbd_putc __P((struct zskbd_softc *, u_int8_t));
void zskbd_raw __P((struct zskbd_softc *, u_int8_t));
d238 11
a248 11
int zskbd_enable __P((void *, int));
void zskbd_set_leds __P((void *, int));
int zskbd_get_leds __P((struct zskbd_softc *));
int zskbd_ioctl __P((void *, u_long, caddr_t, int, struct proc *));
void zskbd_cngetc __P((void *, u_int *, int *));
void zskbd_cnpollc __P((void *, int));

void zsstart_tx __P((struct zskbd_softc *));
int zsenqueue_tx __P((struct zskbd_softc *, u_char *, int));
void zskbd_bell __P((struct zskbd_softc *, u_int, u_int, u_int));
void zskbd_bellstop __P((void *));
d767 3
a769 3
integrate void zskbd_rxsoft __P((struct zskbd_softc *));
integrate void zskbd_txsoft __P((struct zskbd_softc *));
integrate void zskbd_stsoft __P((struct zskbd_softc *));
@


1.9.2.1
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d220 3
a222 3
static void zs_modem(struct zskbd_softc *, int);
static void  zs_hwiflow(struct zskbd_softc *);
static void zs_maskintr(struct zskbd_softc *);
d224 1
a224 1
struct zskbd_softc *zskbd_device_lookup(struct cfdriver *, int);
d227 9
a235 9
static void zskbd_rxint(struct zs_chanstate *);
static void zskbd_stint(struct zs_chanstate *, int);
static void zskbd_txint(struct zs_chanstate *);
static void zskbd_softint(struct zs_chanstate *);
static void zskbd_diag(void *);

void zskbd_init(struct zskbd_softc *);
void zskbd_putc(struct zskbd_softc *, u_int8_t);
void zskbd_raw(struct zskbd_softc *, u_int8_t);
d238 11
a248 11
int zskbd_enable(void *, int);
void zskbd_set_leds(void *, int);
int zskbd_get_leds(struct zskbd_softc *);
int zskbd_ioctl(void *, u_long, caddr_t, int, struct proc *);
void zskbd_cngetc(void *, u_int *, int *);
void zskbd_cnpollc(void *, int);

void zsstart_tx(struct zskbd_softc *);
int zsenqueue_tx(struct zskbd_softc *, u_char *, int);
void zskbd_bell(struct zskbd_softc *, u_int, u_int, u_int);
void zskbd_bellstop(void *);
d403 3
a405 3
		printf("\n");
	} else
		printf("\n");
d767 3
a769 3
integrate void zskbd_rxsoft(struct zskbd_softc *);
integrate void zskbd_txsoft(struct zskbd_softc *);
integrate void zskbd_stsoft(struct zskbd_softc *);
@


1.9.2.2
log
@Sync the SMP branch with 3.3
@
text
@d233 1
a233 1
int zskbd_init(struct zskbd_softc *);
d372 17
d394 1
d396 1
a397 2
		splx(s);
	}
a398 16
	/*
	 * Probe for a keyboard.
	 * If one is found, turn on receiver and status interrupts.
	 * We defer the actual write of the register to zsparam(),
	 * but we must make sure status interrupts are turned on by
	 * the time zsparam() reads the initial rr0 state.
	 */
	if (zskbd_init(zst)) {
		SET(cs->cs_preg[1], ZSWR1_RIE | ZSWR1_SIE);
		zs_write_reg(cs, 1, cs->cs_creg[1]);

		/* Make sure DTR is on now. */
		s = splzs();
		zs_modem(zst, 1);
		splx(s);
	} else {
a399 1
		s = splzs();
d401 1
d403 3
a405 4

		printf("%s: no keyboard\n", self->dv_xname);
		return;
	}
d408 1
a408 17
	if (ISTYPE5(zst->zst_layout)) {
		a.keymap = &sunkbd5_keymapdata;
#ifndef	SUNKBD5_LAYOUT
		if (zst->zst_layout < MAXSUNLAYOUT &&
		    sunkbd_layouts[zst->zst_layout] != -1)
			sunkbd5_keymapdata.layout =
			    sunkbd_layouts[zst->zst_layout];
#endif
	} else {
		a.keymap = &sunkbd_keymapdata;
#ifndef	SUNKBD_LAYOUT
		if (zst->zst_layout < MAXSUNLAYOUT &&
		    sunkbd_layouts[zst->zst_layout] != -1)
			sunkbd_keymapdata.layout =
			    sunkbd_layouts[zst->zst_layout];
#endif
	}
d413 1
a413 1
		wskbd_cnattach(&zskbd_consops, zst, a.keymap);
d418 1
a418 1
int
d429 1
a429 1
		return 0;
d433 1
a433 1
		return 0;
a561 2

	return tries;
d1156 1
a1156 5
		if (ISTYPE5(zst->zst_layout)) {
			*d_int = WSKBD_TYPE_SUN5;
		} else {
			*d_int = WSKBD_TYPE_SUN;
		}
@


1.9.2.3
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: z8530kbd.c,v 1.9.2.2 2003/03/27 23:42:36 niklas Exp $	*/
d56 5
a60 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.8
log
@Much to my annoyance, teach zskbd how to bark.
@
text
@d1 1
a1 1
/*	$OpenBSD: z8530kbd.c,v 1.7 2002/01/31 16:39:17 jason Exp $	*/
d404 2
@


1.7
log
@Fallout from moving SET/CLR/etc
@
text
@d1 1
a1 1
/*	$OpenBSD: z8530kbd.c,v 1.6 2002/01/25 03:24:53 jason Exp $	*/
d155 1
a155 1
	struct timeout zst_diag_ch;
d207 1
d240 1
a240 1
int zskbd_get_leds __P((void *));
d247 2
d317 1
d1134 2
a1135 2
zskbd_get_leds(v)
	void *v;
a1136 2
	struct zskbd_softc *zst = v;

d1148 4
d1154 1
a1154 1
		*(int *)data = WSKBD_TYPE_SUN;
d1157 1
a1157 1
		zskbd_set_leds(v, *(int *)data);
d1160 5
a1164 1
		*(int *)data = zskbd_get_leds(v);
d1168 47
@


1.7.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: z8530kbd.c,v 1.7 2002/01/31 16:39:17 jason Exp $	*/
@


1.7.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: z8530kbd.c,v 1.7.2.1 2002/01/31 22:55:24 niklas Exp $	*/
d155 1
a155 1
	struct timeout zst_diag_ch, zst_bellto;
a206 1
	int zst_bellactive, zst_belltimeout;
d219 3
a221 3
static void zs_modem(struct zskbd_softc *, int);
static void  zs_hwiflow(struct zskbd_softc *);
static void zs_maskintr(struct zskbd_softc *);
d223 1
a223 1
struct zskbd_softc *zskbd_device_lookup(struct cfdriver *, int);
d226 9
a234 9
static void zskbd_rxint(struct zs_chanstate *);
static void zskbd_stint(struct zs_chanstate *, int);
static void zskbd_txint(struct zs_chanstate *);
static void zskbd_softint(struct zs_chanstate *);
static void zskbd_diag(void *);

void zskbd_init(struct zskbd_softc *);
void zskbd_putc(struct zskbd_softc *, u_int8_t);
void zskbd_raw(struct zskbd_softc *, u_int8_t);
d237 9
a245 11
int zskbd_enable(void *, int);
void zskbd_set_leds(void *, int);
int zskbd_get_leds(struct zskbd_softc *);
int zskbd_ioctl(void *, u_long, caddr_t, int, struct proc *);
void zskbd_cngetc(void *, u_int *, int *);
void zskbd_cnpollc(void *, int);

void zsstart_tx(struct zskbd_softc *);
int zsenqueue_tx(struct zskbd_softc *, u_char *, int);
void zskbd_bell(struct zskbd_softc *, u_int, u_int, u_int);
void zskbd_bellstop(void *);
a313 1
	timeout_set(&zst->zst_bellto, zskbd_bellstop, zst);
d399 1
a399 3
		printf("\n");
	} else
		printf("\n");
d402 1
a402 5
	if (ISTYPE5(zst->zst_layout)) {
		a.keymap = &sunkbd5_keymapdata;
	} else {
		a.keymap = &sunkbd_keymapdata;
	}
d407 1
a407 1
		wskbd_cnattach(&zskbd_consops, zst, a.keymap);
d761 3
a763 3
integrate void zskbd_rxsoft(struct zskbd_softc *);
integrate void zskbd_txsoft(struct zskbd_softc *);
integrate void zskbd_stsoft(struct zskbd_softc *);
d1130 2
a1131 2
zskbd_get_leds(zst)
	struct zskbd_softc *zst;
d1133 2
a1145 4
	struct zskbd_softc *zst = v;
	int *d_int = (int *)data;
	struct wskbd_bell_data *d_bell = (struct wskbd_bell_data *)data;

d1148 1
a1148 5
		if (ISTYPE5(zst->zst_layout)) {
			*d_int = WSKBD_TYPE_SUN5;
		} else {
			*d_int = WSKBD_TYPE_SUN;
		}
d1151 1
a1151 1
		zskbd_set_leds(zst, *d_int);
d1154 1
a1154 5
		*d_int = zskbd_get_leds(zst);
		return (0);
	case WSKBDIO_COMPLEXBELL:
		zskbd_bell(zst, d_bell->period,
		    d_bell->pitch, d_bell->volume);
a1157 47
}

void
zskbd_bell(zst, period, pitch, volume)
	struct zskbd_softc *zst;
	u_int period, pitch, volume;
{
	int ticks, s;
	u_int8_t c = SKBD_CMD_BELLON;

	ticks = (period * hz)/1000;
	if (ticks <= 0)
		ticks = 1;

	s = splzs();
	if (zst->zst_bellactive) {
		if (zst->zst_belltimeout == 0)
			timeout_del(&zst->zst_bellto);
	}
	if (pitch == 0 || period == 0) {
		zskbd_bellstop(zst);
		splx(s);
		return;
	}
	if (!zst->zst_bellactive) {
		zst->zst_bellactive = 1;
		zst->zst_belltimeout = 1;
		zsenqueue_tx(zst, &c, 1);
		timeout_add(&zst->zst_bellto, ticks);
	}
	splx(s);
}

void
zskbd_bellstop(v)
	void *v;
{
	struct zskbd_softc *zst = v;
	int s;
	u_int8_t c;

	s = splzs();
	zst->zst_belltimeout = 0;
	c = SKBD_CMD_BELLOFF;
	zsenqueue_tx(zst, &c, 1);
	zst->zst_bellactive = 0;
	splx(s);
@


1.7.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d233 1
a233 1
int zskbd_init(struct zskbd_softc *);
d372 17
d394 1
d396 1
a397 13
		splx(s);
	}

	/*
	 * Probe for a keyboard.
	 * If one is found, turn on receiver and status interrupts.
	 * We defer the actual write of the register to zsparam(),
	 * but we must make sure status interrupts are turned on by
	 * the time zsparam() reads the initial rr0 state.
	 */
	if (zskbd_init(zst)) {
		SET(cs->cs_preg[1], ZSWR1_RIE | ZSWR1_SIE);
		zs_write_reg(cs, 1, cs->cs_creg[1]);
a398 5
		/* Make sure DTR is on now. */
		s = splzs();
		zs_modem(zst, 1);
		splx(s);
	} else {
a399 1
		s = splzs();
d401 1
d403 3
a405 4

		printf("%s: no keyboard\n", self->dv_xname);
		return;
	}
a409 6
#ifndef	SUNKBD5_LAYOUT
		if (zst->zst_layout < MAXSUNLAYOUT &&
		    sunkbd_layouts[zst->zst_layout] != -1)
			sunkbd5_keymapdata.layout =
			    sunkbd_layouts[zst->zst_layout];
#endif
a411 6
#ifndef	SUNKBD_LAYOUT
		if (zst->zst_layout < MAXSUNLAYOUT &&
		    sunkbd_layouts[zst->zst_layout] != -1)
			sunkbd_keymapdata.layout =
			    sunkbd_layouts[zst->zst_layout];
#endif
d422 1
a422 1
int
d433 1
a433 1
		return 0;
d437 1
a437 1
		return 0;
a565 2

	return tries;
@


1.6
log
@move the scancode -> wskbd event map into a seperate file... more still
to move, though.
@
text
@d1 1
a1 1
/*	$OpenBSD: z8530kbd.c,v 1.5 2002/01/16 21:32:59 jason Exp $	*/
a207 5

/* Macros to clear/set/test flags. */
#define SET(t, f)	(t) |= (f)
#define CLR(t, f)	(t) &= ~(f)
#define ISSET(t, f)	((t) & (f))
@


1.5
log
@More removal of tty stuff
add support for updating LED status
add ScrollLock keysym
[Committed from the console of a u1 with wsdisplay at cgsix and wskbd at zskbd =]
@
text
@d1 1
a1 1
/*	$OpenBSD: z8530kbd.c,v 1.4 2002/01/16 18:04:42 jason Exp $	*/
d120 3
a262 126
#define	KC(n)	KS_KEYCODE(n)
const keysym_t zskbd_keydesc_us[] = {
    KC(0x01), KS_Cmd,
    KC(0x02), KS_Cmd_BrightnessDown,
    KC(0x04), KS_Cmd_BrightnessUp,
    KC(0x05),				KS_f1,
    KC(0x06),				KS_f2,
    KC(0x07),				KS_f10,
    KC(0x08),				KS_f3,
    KC(0x09),				KS_f11,
    KC(0x0a),				KS_f4,
    KC(0x0b),				KS_f12,
    KC(0x0c),				KS_f5,
    KC(0x0d),				KS_Alt_R,
    KC(0x0e),				KS_f6,
    KC(0x10),				KS_f7,
    KC(0x11),				KS_f8,
    KC(0x12),				KS_f9,
    KC(0x13),				KS_Alt_L,
    KC(0x14),				KS_Up,
    KC(0x15),				KS_Pause,
    KC(0x16),				KS_Print_Screen,
    KC(0x18),				KS_Left,
    KC(0x19),				KS_Hold_Screen,
    KC(0x1b),				KS_Down,
    KC(0x1c),				KS_Right,
    KC(0x1d),				KS_Escape,
    KC(0x1e),				KS_1,		KS_exclam,
    KC(0x1f),				KS_2,		KS_at,
    KC(0x20),				KS_3,		KS_numbersign,
    KC(0x21),				KS_4,		KS_dollar,
    KC(0x22),				KS_5,		KS_percent,
    KC(0x23),				KS_6,		KS_asciicircum,
    KC(0x24),				KS_7,		KS_ampersand,
    KC(0x25),				KS_8,		KS_asterisk,
    KC(0x26),				KS_9,		KS_parenleft,
    KC(0x27),				KS_0,		KS_parenright,
    KC(0x28),				KS_minus,	KS_underscore,
    KC(0x29),				KS_equal,	KS_plus,
    KC(0x2a),				KS_grave,	KS_asciitilde,
    KC(0x2b),				KS_BackSpace,
    KC(0x2c),				KS_Insert,
    KC(0x2d),				KS_KP_Equal,
    KC(0x2e),				KS_KP_Divide,
    KC(0x2f),				KS_KP_Multiply,
    KC(0x32),				KS_KP_Delete,
    KC(0x34),				KS_Home,
    KC(0x35),				KS_Tab,
    KC(0x36),				KS_q,
    KC(0x37),				KS_w,
    KC(0x38),				KS_e,
    KC(0x39),				KS_r,
    KC(0x3a),				KS_t,
    KC(0x3b),				KS_y,
    KC(0x3c),				KS_u,
    KC(0x3d),				KS_i,
    KC(0x3e),				KS_o,
    KC(0x3f),				KS_p,
    KC(0x40),				KS_bracketleft,	KS_braceleft,
    KC(0x41),				KS_bracketright,KS_braceright,
    KC(0x42),				KS_Delete,
    KC(0x43),				KS_Multi_key,
    KC(0x44),				KS_KP_Home,	KS_KP_7,
    KC(0x45),				KS_KP_Up,	KS_KP_8,
    KC(0x46),				KS_KP_Prior,	KS_KP_9,
    KC(0x47),				KS_KP_Subtract,
    KC(0x4a),				KS_End,
    KC(0x4c),				KS_Control_L,
    KC(0x4d), KS_Cmd_Debugger,		KS_a,
    KC(0x4e),				KS_s,
    KC(0x4f),				KS_d,
    KC(0x50),				KS_f,
    KC(0x51),				KS_g,
    KC(0x52),				KS_h,
    KC(0x53),				KS_j,
    KC(0x54),				KS_k,
    KC(0x55),				KS_l,
    KC(0x56),				KS_semicolon,	KS_colon,
    KC(0x57),				KS_apostrophe,	KS_quotedbl,
    KC(0x58),				KS_backslash,	KS_bar,
    KC(0x59),				KS_Return,
    KC(0x5a),				KS_KP_Enter,
    KC(0x5b),				KS_KP_Left,	KS_KP_4,
    KC(0x5c),				KS_KP_Begin,	KS_KP_5,
    KC(0x5d),				KS_KP_Right,	KS_KP_6,
    KC(0x5e),				KS_KP_Insert,	KS_KP_0,
    KC(0x5f),				KS_Find,
    KC(0x60),				KS_Prior,
    KC(0x62),				KS_Num_Lock,
    KC(0x63),				KS_Shift_L,
    KC(0x64),				KS_z,
    KC(0x65),				KS_x,
    KC(0x66),				KS_c,
    KC(0x67),				KS_v,
    KC(0x68),				KS_b,
    KC(0x69),				KS_n,
    KC(0x6a),				KS_m,
    KC(0x6b),				KS_comma,	KS_less,
    KC(0x6c),				KS_period,	KS_greater,
    KC(0x6d),				KS_slash,	KS_question,
    KC(0x6e),				KS_Shift_R,
    KC(0x6f),				KS_Linefeed,
    KC(0x70),				KS_KP_End,	KS_KP_1,
    KC(0x71),				KS_KP_Down,	KS_KP_2,
    KC(0x72),				KS_KP_Next,	KS_KP_3,
    KC(0x76),				KS_Help,
    KC(0x77),				KS_Caps_Lock,
    KC(0x78),				KS_Meta_L,
    KC(0x79),				KS_space,
    KC(0x7a),				KS_Meta_R,
    KC(0x7b),				KS_Next,
    KC(0x7d),				KS_KP_Add,
};

#define KBD_MAP(name, base, map) \
    { name, base, sizeof(map)/sizeof(keysym_t), map }

const struct wscons_keydesc zskbd_keydesctab[] = {
	KBD_MAP(KB_US, 0, zskbd_keydesc_us),
	{0, 0, 0, 0},
};

struct wskbd_mapdata zskbd_keymapdata = {
	zskbd_keydesctab, KB_US
};

d407 1
a407 1
	a.keymap = &zskbd_keymapdata;
d412 1
a412 1
		wskbd_cnattach(&zskbd_consops, zst, &zskbd_keymapdata);
a415 24

/* keyboard commands (host->kbd) */
#define	SKBD_CMD_RESET		0x01
#define	SKBD_CMD_BELLON		0x02
#define	SKBD_CMD_BELLOFF	0x03
#define	SKBD_CMD_CLICKON	0x0a
#define	SKBD_CMD_CLICKOFF	0x0b
#define	SKBD_CMD_SETLED		0x0e
#define	SKBD_CMD_LAYOUT		0x0f

/* keyboard responses (kbd->host) */
#define	SKBD_RSP_RESET_OK	0x04	/* normal reset status */
#define	SKBD_RSP_IDLE		0x7f	/* no keys down */
#define	SKBD_RSP_LAYOUT		0xfe	/* layout follows */
#define	SKBD_RSP_RESET		0xff	/* reset status follows */

#define	SKBD_LED_NUMLOCK	0x01
#define	SKBD_LED_COMPOSE	0x02
#define	SKBD_LED_SCROLLLOCK	0x04
#define	SKBD_LED_CAPSLOCK	0x08

#define	SKBD_STATE_RESET	0
#define	SKBD_STATE_LAYOUT	1
#define	SKBD_STATE_GETKEY	2
@


1.4
log
@Enable the traditional Stop-A handling
Prepare for being able to set the LED's
Clean some of the tty cruft (more of this to come)
@
text
@d1 1
a1 1
/*	$OpenBSD: z8530kbd.c,v 1.3 2002/01/16 16:25:49 jason Exp $	*/
a149 1
	struct  tty *zst_tty;
d179 3
a220 2
static void	zsstart __P((struct tty *));
static int	zsparam __P((struct tty *, struct termios *));
a221 1
static int    zshwiflow __P((struct tty *, int));
d246 3
d263 2
a264 2
    KC(0x02),				KS_Cmd_BrightnessDown,
    KC(0x04),				KS_Cmd_BrightnessUp,
d283 1
a437 1
	struct tty *tp;
d443 3
a474 8
	tp = ttymalloc();
	tp->t_dev = dev;
	tp->t_oproc = zsstart;
	tp->t_param = zsparam;
	tp->t_hwiflow = zshwiflow;
	tty_attach(tp);

	zst->zst_tty = tp;
d640 1
a640 1
		zsstart(zst->zst_tty);
d769 25
a793 6
/*
 * Start or restart transmission.
 */
static void
zsstart(tp)
	struct tty *tp;
a794 1
	struct zskbd_softc *zst = zskbd_device_lookup(&zskbd_cd, ZSKBDUNIT(tp->t_dev));
d796 1
a796 1
	int s;
d799 2
a800 1
	if (ISSET(tp->t_state, TS_BUSY | TS_TIMEOUT | TS_TTSTOP))
d802 1
a802 1
	if (zst->zst_tx_stopped)
d805 1
a805 23
	if (tp->t_outq.c_cc <= tp->t_lowat) {
		if (ISSET(tp->t_state, TS_ASLEEP)) {
			CLR(tp->t_state, TS_ASLEEP);
			wakeup((caddr_t)&tp->t_outq);
		}
		selwakeup(&tp->t_wsel);
		if (tp->t_outq.c_cc == 0)
			goto out;
	}

	/* Grab the first contiguous region of buffer space. */
	{
		u_char *tba;
		int tbc;

		tba = tp->t_outq.c_cf;
		tbc = ndqb(&tp->t_outq, 0);
	
		(void) splzs();

		zst->zst_tba = tba;
		zst->zst_tbc = tbc;
	}
a806 1
	SET(tp->t_state, TS_BUSY);
a808 1
	/* Enable transmit completion interrupts if necessary. */
d815 1
a815 35
	/* Output the first character of the contiguous buffer. */
	{
		zs_write_data(cs, *zst->zst_tba);
		zst->zst_tbc--;
		zst->zst_tba++;
	}
out:
	splx(s);
	return;
}

/*
 * Set ZS tty parameters from termios.
 * XXX - Should just copy the whole termios after
 * making sure all the changes could be done.
 */
static int
zsparam(tp, t)
	struct tty *tp;
	struct termios *t;
{
	struct zskbd_softc *zst = zskbd_device_lookup(&zskbd_cd, ZSKBDUNIT(tp->t_dev));
	struct zs_chanstate *cs = zst->zst_cs;
	int ospeed, cflag;
	u_char tmp3, tmp4, tmp5;
	int s, error;

	ospeed = t->c_ospeed;
	cflag = t->c_cflag;

	/* Check requested parameters. */
	if (ospeed < 0)
		return (EINVAL);
	if (t->c_ispeed && t->c_ispeed != ospeed)
		return (EINVAL);
d817 3
a819 9
	/*
	 * For the console, always force CLOCAL and !HUPCL, so that the port
	 * is always active.
	 */
	if (ISSET(zst->zst_swflags, TIOCFLAG_SOFTCAR) ||
	    ISSET(zst->zst_hwflags, ZS_HWFLAG_CONSOLE)) {
		SET(cflag, CLOCAL);
		CLR(cflag, HUPCL);
	}
d821 1
a821 125
	/*
	 * Only whack the UART when params change.
	 * Some callers need to clear tp->t_ospeed
	 * to make sure initialization gets done.
	 */
	if (tp->t_ospeed == ospeed &&
	    tp->t_cflag == cflag)
		return (0);

	/*
	 * Call MD functions to deal with changed
	 * clock modes or H/W flow control modes.
	 * The BRG divisor is set now. (reg 12,13)
	 */
	error = zs_set_speed(cs, ospeed);
	if (error)
		return (error);
	error = zs_set_modes(cs, cflag);
	if (error)
		return (error);

	/*
	 * Block interrupts so that state will not
	 * be altered until we are done setting it up.
	 *
	 * Initial values in cs_preg are set before
	 * our attach routine is called.  The master
	 * interrupt enable is handled by zsc.c
	 *
	 */
	s = splzs();

	/*
	 * Recalculate which status ints to enable.
	 */
	zs_maskintr(zst);

	/* Recompute character size bits. */
	tmp3 = cs->cs_preg[3];
	tmp5 = cs->cs_preg[5];
	CLR(tmp3, ZSWR3_RXSIZE);
	CLR(tmp5, ZSWR5_TXSIZE);
	switch (ISSET(cflag, CSIZE)) {
	case CS5:
		SET(tmp3, ZSWR3_RX_5);
		SET(tmp5, ZSWR5_TX_5);
		break;
	case CS6:
		SET(tmp3, ZSWR3_RX_6);
		SET(tmp5, ZSWR5_TX_6);
		break;
	case CS7:
		SET(tmp3, ZSWR3_RX_7);
		SET(tmp5, ZSWR5_TX_7);
		break;
	case CS8:
		SET(tmp3, ZSWR3_RX_8);
		SET(tmp5, ZSWR5_TX_8);
		break;
	}
	cs->cs_preg[3] = tmp3;
	cs->cs_preg[5] = tmp5;

	/*
	 * Recompute the stop bits and parity bits.  Note that
	 * zs_set_speed() may have set clock selection bits etc.
	 * in wr4, so those must preserved.
	 */
	tmp4 = cs->cs_preg[4];
	CLR(tmp4, ZSWR4_SBMASK | ZSWR4_PARMASK);
	if (ISSET(cflag, CSTOPB))
		SET(tmp4, ZSWR4_TWOSB);
	else
		SET(tmp4, ZSWR4_ONESB);
	if (!ISSET(cflag, PARODD))
		SET(tmp4, ZSWR4_EVENP);
	if (ISSET(cflag, PARENB))
		SET(tmp4, ZSWR4_PARENB);
	cs->cs_preg[4] = tmp4;

	/* And copy to tty. */
	tp->t_ispeed = 0;
	tp->t_ospeed = ospeed;
	tp->t_cflag = cflag;

	/*
	 * If nothing is being transmitted, set up new current values,
	 * else mark them as pending.
	 */
	if (!cs->cs_heldchange) {
		if (zst->zst_tx_busy) {
			zst->zst_heldtbc = zst->zst_tbc;
			zst->zst_tbc = 0;
			cs->cs_heldchange = 1;
		} else
			zs_loadchannelregs(cs);
	}

	/*
	 * If hardware flow control is disabled, turn off the buffer water
	 * marks and unblock any soft flow control state.  Otherwise, enable
	 * the water marks.
	 */
	if (!ISSET(cflag, CHWFLOW)) {
		zst->zst_r_hiwat = 0;
		zst->zst_r_lowat = 0;
		if (ISSET(zst->zst_rx_flags, RX_TTY_OVERFLOWED)) {
			CLR(zst->zst_rx_flags, RX_TTY_OVERFLOWED);
			zst->zst_rx_ready = 1;
			cs->cs_softreq = 1;
		}
		if (ISSET(zst->zst_rx_flags, RX_TTY_BLOCKED|RX_IBUF_BLOCKED)) {
			CLR(zst->zst_rx_flags, RX_TTY_BLOCKED|RX_IBUF_BLOCKED);
			zs_hwiflow(zst);
		}
	} else {
		zst->zst_r_hiwat = zskbd_rbuf_hiwat;
		zst->zst_r_lowat = zskbd_rbuf_lowat;
	}

	/*
	 * Force a recheck of the hardware carrier and flow control status,
	 * since we may have changed which bits we're looking at.
	 */
	zskbd_stint(cs, 1);
d823 1
a824 15

	/*
	 * If hardware flow control is disabled, unblock any hard flow control
	 * state.
	 */
	if (!ISSET(cflag, CHWFLOW)) {
		if (zst->zst_tx_stopped) {
			zst->zst_tx_stopped = 0;
			zsstart(tp);
		}
	}

	zskbd_softint(cs);

	return (0);
a884 39
 * Try to block or unblock input using hardware flow-control.
 * This is called by kern/tty.c if MDMBUF|CRTSCTS is set, and
 * if this function returns non-zero, the TS_TBLOCK flag will
 * be set or cleared according to the "block" arg passed.
 */
int
zshwiflow(tp, block)
	struct tty *tp;
	int block;
{
	struct zskbd_softc *zst = zskbd_device_lookup(&zskbd_cd, ZSKBDUNIT(tp->t_dev));
	struct zs_chanstate *cs = zst->zst_cs;
	int s;

	if (cs->cs_wr5_rts == 0)
		return (0);

	s = splzs();
	if (block) {
		if (!ISSET(zst->zst_rx_flags, RX_TTY_BLOCKED)) {
			SET(zst->zst_rx_flags, RX_TTY_BLOCKED);
			zs_hwiflow(zst);
		}
	} else {
		if (ISSET(zst->zst_rx_flags, RX_TTY_OVERFLOWED)) {
			CLR(zst->zst_rx_flags, RX_TTY_OVERFLOWED);
			zst->zst_rx_ready = 1;
			cs->cs_softreq = 1;
		}
		if (ISSET(zst->zst_rx_flags, RX_TTY_BLOCKED)) {
			CLR(zst->zst_rx_flags, RX_TTY_BLOCKED);
			zs_hwiflow(zst);
		}
	}
	splx(s);
	return (1);
}

/*
d914 1
a914 1
integrate void zskbd_txsoft __P((struct zskbd_softc *, struct tty *));
d1017 2
a1018 1
		zst->zst_tba++;
d1174 1
a1174 1
zskbd_txsoft(zst, tp)
a1175 1
	struct tty *tp;
a1176 7

	CLR(tp->t_state, TS_BUSY);
	if (ISSET(tp->t_state, TS_FLUSH))
		CLR(tp->t_state, TS_FLUSH);
	else
		ndflush(&tp->t_outq, (int)(zst->zst_tba - tp->t_outq.c_cf));
	(*linesw[tp->t_line].l_start)(tp);
a1218 1
	struct tty *tp = zst->zst_tty;
d1235 1
a1235 1
		zskbd_txsoft(zst, tp);
d1263 1
d1275 4
@


1.3
log
@Send input to wskbd_input() instead of line discipline and make sure RIE is set.
@
text
@d1 1
a1 1
/*	$OpenBSD: z8530kbd.c,v 1.2 2002/01/16 15:35:26 jason Exp $	*/
d260 1
d283 1
a283 1
    KC(0x1d), KS_Cmd_Debugger,		KS_Escape,
d324 2
a325 2
    KC(0x4c),	 KS_Cmd1,		KS_Control_L,
    KC(0x4d),				KS_a,
d558 5
d1138 1
a1138 1
integrate void zskbd_rxsoft __P((struct zskbd_softc *, struct tty *));
d1140 1
a1140 1
integrate void zskbd_stsoft __P((struct zskbd_softc *, struct tty *));
d1322 1
a1322 1
zskbd_rxsoft(zst, tp)
a1323 1
	struct tty *tp;
d1412 1
a1412 1
zskbd_stsoft(zst, tp)
a1413 1
	struct tty *tp;
a1424 7
	if (ISSET(delta, cs->cs_rr0_dcd)) {
		/*
		 * Inform the tty layer that carrier detect changed.
		 */
		(void) (*linesw[tp->t_line].l_modem)(tp, ISSET(rr0, ZSRR0_DCD));
	}

d1427 1
a1427 1
		if (ISSET(rr0, cs->cs_rr0_cts)) {
d1429 1
a1429 2
			(*linesw[tp->t_line].l_start)(tp);
		} else {
a1430 1
		}
d1458 1
a1458 1
		zskbd_rxsoft(zst, tp);
d1463 1
a1463 1
		zskbd_stsoft(zst, tp);
d1490 1
a1490 1
zskbd_set_leds(v, on)
d1492 1
a1492 1
	int on;
d1495 3
d1499 8
a1506 1
	zst->zst_leds = on;
@


1.2
log
@Initialize the rest of the wskbd_mapdata structure.
Clean up and remove alot of debugging crap
Fix the initialization state machine.
[State: works as console keyboard in polled mode... interrupt mode to go...]
@
text
@d1 1
a1 1
/*	$OpenBSD: z8530kbd.c,v 1.1 2002/01/15 22:00:12 jason Exp $	*/
d505 1
d507 1
a507 1
		zskbd_init(zst);
a1320 1
	int (*rint) __P((int c, struct tty *tp)) = linesw[tp->t_line].l_rint;
d1322 1
a1322 1
	u_int cc, scc;
d1324 1
a1324 1
	int code;
a1336 7
	/* If not yet open, drop the entire buffer content here */
	if (!ISSET(tp->t_state, TS_ISOPEN)) {
		get += cc << 1;
		if (get >= end)
			get -= zskbd_rbuf_size << 1;
		cc = 0;
	}
d1351 10
a1360 26
		if ((*rint)(code, tp) == -1) {
			/*
			 * The line discipline's buffer is out of space.
			 */
			if (!ISSET(zst->zst_rx_flags, RX_TTY_BLOCKED)) {
				/*
				 * We're either not using flow control, or the
				 * line discipline didn't tell us to block for
				 * some reason.  Either way, we have no way to
				 * know when there's more space available, so
				 * just drop the rest of the data.
				 */
				get += cc << 1;
				if (get >= end)
					get -= zskbd_rbuf_size << 1;
				cc = 0;
			} else {
				/*
				 * Don't schedule any more receive processing
				 * until the line discipline tells us there's
				 * space available (through comhwiflow()).
				 * Leave the rest of the data in the input
				 * buffer.
				 */
				SET(zst->zst_rx_flags, RX_TTY_OVERFLOWED);
			}
d1363 2
@


1.1
log
@Frontend driver for keyboards attached to zs's (instead of zstty's).
Doesn't really work yet, but it's not terribly far off.
This is a work in progress..
@
text
@d1 1
a1 1
/*	$OpenBSD: z8530tty.c,v 1.1 2001/08/21 21:42:30 jason Exp $	*/
d379 1
a379 1
	zskbd_keydesctab
a468 2
	printf("\n");

a494 1
		struct termios t;
a498 7
		/* Setup the "new" parameters in t. */
		t.c_ispeed = 0;
		t.c_ospeed = 1200;
		t.c_cflag = CS8 | CLOCAL;

		s = splzs();

d506 1
a506 6

		splx(s);

		/* Make sure zsparam will see changes. */
		tp->t_ospeed = 0;
		(void) zsparam(tp, &t);
a529 2
	zskbd_init(zst);

a643 2
	zst->zst_leds = 0;
	zst->zst_layout = -1;
d648 4
d657 5
a661 2
			if (rr0 & ZSRR0_RX_READY)
				break;
a665 3
		zskbd_raw(zst, *cs->cs_reg_data);
		if (zst->zst_kbdstate != SKBD_STATE_RESET)
			continue;
d667 1
d671 5
a675 2
			if (rr0 & ZSRR0_RX_READY)
				break;
a679 3
		zskbd_raw(zst, *cs->cs_reg_data);
		if (zst->zst_kbdstate != SKBD_STATE_GETKEY)
			continue;
d681 2
d688 5
a692 2
			if (rr0 & ZSRR0_RX_READY)
				break;
d697 1
a697 15
		zskbd_raw(zst, *cs->cs_reg_data);
		if (zst->zst_kbdstate != SKBD_STATE_LAYOUT)
			continue;
		ltries = 1000;
		while (--ltries > 0) {
			rr0 = *cs->cs_reg_csr;
			if (rr0 & ZSRR0_RX_READY)
				break;
			DELAY(1000);
		}
		if (ltries == 0)
			continue;
		zskbd_raw(zst, *cs->cs_reg_data);
		if (zst->zst_kbdstate == SKBD_STATE_GETKEY)
			break;
d700 1
a700 1
		printf(":reset timeout\n");
d702 1
a702 1
		printf("reset ok, layout %d\n", zst->zst_layout);
d713 6
a718 1
	printf("raw(state %d, code %x)\n", zst->zst_kbdstate, c);
d733 1
a733 2
	if (claimed) {
		printf("out state: %d\n", zst->zst_kbdstate);
a734 1
	}
a742 5
	case SKBD_STATE_LAYOUT:
		zst->zst_kbdstate = SKBD_STATE_GETKEY;
		printf("layout: %02x\n", c);
		zst->zst_layout = c;
		break;
a743 1
		printf("KEY(%02x)\n", c);
a745 1
	printf("out state: %d\n", zst->zst_kbdstate);
a1511 3
	struct zskbd_softc *zst = v;

	printf("zskbd_enable: %s\n", zst->zst_dev.dv_xname);
a1521 1
	printf("zskbd_set_leds: %s\n", zst->zst_dev.dv_xname);
a1530 1
	printf("zskbd_get_leds: %s\n", zst->zst_dev.dv_xname);
a1541 4
	struct zskbd_softc *zst = v;

	printf("zskbd_ioctl: %s\n", zst->zst_dev.dv_xname);

d1544 1
a1544 3
#if 0		/* XXX need to allocate a type... */
		*(int *)data = WSKBD_TYPE_XXX;
#endif
a1560 1
	struct zskbd_softc *zst = v;
a1562 2
	printf("%s: cnpollc...", zst->zst_dev.dv_xname);

a1578 2
	printf("%s: cngetc...", zst->zst_dev.dv_xname);

d1587 11
a1597 4
	printf("%02x\n", c);

	*type = (c & 0x80) ? WSCONS_EVENT_KEY_UP : WSCONS_EVENT_KEY_DOWN;
	*data = c & 0x7f;
@

