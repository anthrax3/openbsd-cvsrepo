head	1.14;
access;
symbols
	OPENBSD_6_1:1.14.0.14
	OPENBSD_6_1_BASE:1.14
	OPENBSD_6_0:1.14.0.10
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.14.0.6
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.14.0.8
	OPENBSD_5_8_BASE:1.14
	OPENBSD_5_7:1.14.0.2
	OPENBSD_5_7_BASE:1.14
	OPENBSD_5_6:1.14.0.4
	OPENBSD_5_6_BASE:1.14
	OPENBSD_5_5:1.13.0.6
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.13.0.2
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.12.0.2
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.11.0.8
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.6
	OPENBSD_5_0:1.11.0.4
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.2
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.10.0.2
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.7.0.2
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.5.0.6
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.2
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2;
locks; strict;
comment	@ * @;


1.14
date	2014.05.10.11.49.31;	author kettenis;	state Exp;
branches;
next	1.13;

1.13
date	2013.07.16.19.46.56;	author kettenis;	state Exp;
branches;
next	1.12;

1.12
date	2012.10.20.12.00.33;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2011.01.04.20.48.56;	author kettenis;	state Exp;
branches;
next	1.10;

1.10
date	2010.07.02.17.27.01;	author nicm;	state Exp;
branches;
next	1.9;

1.9
date	2010.06.28.14.13.31;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2010.04.12.12.57.52;	author tedu;	state Exp;
branches;
next	1.7;

1.7
date	2009.11.09.17.53.39;	author nicm;	state Exp;
branches;
next	1.6;

1.6
date	2009.10.31.06.40.16;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2008.11.24.16.19.33;	author kettenis;	state Exp;
branches;
next	1.4;

1.4
date	2008.10.12.09.18.24;	author kettenis;	state Exp;
branches;
next	1.3;

1.3
date	2008.09.23.22.44.19;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2008.07.07.14.38.42;	author kettenis;	state Exp;
branches;
next	1.1;

1.1
date	2008.03.08.19.38.33;	author kettenis;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Some straightforward format string fixes.  Also, print both the tx and rx
interrupt vector numbers instead of printing rx; pointed out by florian@@
@
text
@/*	$OpenBSD: vcons.c,v 1.13 2013/07/16 19:46:56 kettenis Exp $	*/
/*
 * Copyright (c) 2008 Mark Kettenis
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/conf.h>
#include <sys/device.h>
#include <sys/proc.h>
#include <sys/systm.h>
#include <sys/tty.h>

#ifdef DDB
#include <ddb/db_var.h>
#endif

#include <machine/autoconf.h>
#include <machine/conf.h>
#include <machine/hypervisor.h>
#include <machine/openfirm.h>

#include <dev/cons.h>
#include <sparc64/dev/vbusvar.h>

struct vcons_softc {
	struct device	sc_dv;
	void		*sc_ih;
	struct tty	*sc_tty;
	void		*sc_si;
};

int	vcons_match(struct device *, void *, void *);
void	vcons_attach(struct device *, struct device *, void *);

struct cfattach vcons_ca = {
	sizeof(struct vcons_softc), vcons_match, vcons_attach
};

struct cfdriver vcons_cd = {
	NULL, "vcons", DV_DULL
};

int	vcons_intr(void *);

int	vcons_cnlookc(dev_t, int *);
int	vcons_cngetc(dev_t);
void	vcons_cnputc(dev_t, int);

void	vconsstart(struct tty *);
int	vconsparam(struct tty *, struct termios *);
void	vcons_softintr(void *);

int
vcons_match(struct device *parent, void *match, void *aux)
{
	struct vbus_attach_args *va = aux;

	if (strcmp(va->va_name, "console") == 0)
		return (1);

	return (0);
}

void
vcons_attach(struct device *parent, struct device *self, void *aux)
{
	struct vcons_softc *sc = (struct vcons_softc *)self;
	struct vbus_attach_args *va = aux;
	uint64_t sysino;
	int vcons_is_input, vcons_is_output;
	int node, maj;

	sc->sc_si = softintr_establish(IPL_TTY, vcons_softintr, sc);
	if (sc->sc_si == NULL)
		panic(": can't establish soft interrupt");

	if (vbus_intr_map(va->va_node, va->va_intr[0], &sysino))
		printf(": can't map interrupt\n");
	printf(": ivec 0x%llx", sysino);

	sc->sc_ih = bus_intr_establish(va->va_bustag, sysino, IPL_TTY,
	    BUS_INTR_ESTABLISH_MPSAFE, vcons_intr, sc, sc->sc_dv.dv_xname);
	if (sc->sc_ih == NULL) {
		printf(", can't establish interrupt\n");
		return;
	}

	node = OF_instance_to_package(OF_stdin());
	vcons_is_input = (va->va_node == node);
	node = OF_instance_to_package(OF_stdout());
	vcons_is_output = (va->va_node == node);

	if (vcons_is_input || vcons_is_output) {
		if (vcons_is_input) {
			cn_tab->cn_pollc = nullcnpollc;
			cn_tab->cn_getc = vcons_cngetc;

			/* Locate the major number. */
			for (maj = 0; maj < nchrdev; maj++)
				if (cdevsw[maj].d_open == vconsopen)
					break;
			cn_tab->cn_dev = makedev(maj, self->dv_unit);
		}
		if (vcons_is_output) 
			cn_tab->cn_putc = vcons_cnputc;

		printf(", console");
	}

	printf("\n");
}

int
vcons_intr(void *arg)
{
	struct vcons_softc *sc = arg;

	if (sc->sc_tty)
		softintr_schedule(sc->sc_si);
	return (1);
}

int
vcons_cnlookc(dev_t dev, int *cp)
{
	int64_t ch;

	if (hv_cons_getchar(&ch) == H_EOK) {
#ifdef DDB
		if (ch == -1 && db_console)
			Debugger();
#endif
		*cp = ch;
		return (1);
	}

	return (0);
}

int
vcons_cngetc(dev_t dev)
{
	int c;

	while(!vcons_cnlookc(dev, &c))
		;

	return (c);
}

void
vcons_cnputc(dev_t dev, int c)
{
	while (hv_cons_putchar(c) == H_EWOULDBLOCK);
}

int
vconsopen(dev_t dev, int flag, int mode, struct proc *p)
{
	struct vcons_softc *sc;
	struct tty *tp;
	int unit = minor(dev);

	if (unit >= vcons_cd.cd_ndevs)
		return (ENXIO);
	sc = vcons_cd.cd_devs[unit];
	if (sc == NULL)
		return (ENXIO);

	if (sc->sc_tty)
		tp = sc->sc_tty;
	else
		tp = sc->sc_tty = ttymalloc(0);

	tp->t_oproc = vconsstart;
	tp->t_param = vconsparam;
	tp->t_dev = dev;
	if ((tp->t_state & TS_ISOPEN) == 0) {
		ttychars(tp);
		tp->t_iflag = TTYDEF_IFLAG;
		tp->t_oflag = TTYDEF_OFLAG;
		tp->t_cflag = TTYDEF_CFLAG;
		tp->t_lflag = TTYDEF_LFLAG;
		tp->t_ispeed = tp->t_ospeed = TTYDEF_SPEED;
		ttsetwater(tp);
	} else if ((tp->t_state & TS_XCLUDE) && suser(p, 0))
		return (EBUSY);
	tp->t_state |= TS_CARR_ON;

	return ((*linesw[tp->t_line].l_open)(dev, tp, p));
}

int
vconsclose(dev_t dev, int flag, int mode, struct proc *p)
{
	struct vcons_softc *sc;
	struct tty *tp;
	int unit = minor(dev);

	if (unit >= vcons_cd.cd_ndevs)
		return (ENXIO);
	sc = vcons_cd.cd_devs[unit];
	if (sc == NULL)
		return (ENXIO);

	tp = sc->sc_tty;
	(*linesw[tp->t_line].l_close)(tp, flag, p);
	ttyclose(tp);
	return (0);
}

int
vconsread(dev_t dev, struct uio *uio, int flag)
{
	struct vcons_softc *sc;
	struct tty *tp;
	int unit = minor(dev);

	if (unit >= vcons_cd.cd_ndevs)
		return (ENXIO);
	sc = vcons_cd.cd_devs[unit];
	if (sc == NULL)
		return (ENXIO);

	tp = sc->sc_tty;
	return ((*linesw[tp->t_line].l_read)(tp, uio, flag));
}

int
vconswrite(dev_t dev, struct uio *uio, int flag)
{
	struct vcons_softc *sc;
	struct tty *tp;
	int unit = minor(dev);

	if (unit >= vcons_cd.cd_ndevs)
		return (ENXIO);
	sc = vcons_cd.cd_devs[unit];
	if (sc == NULL)
		return (ENXIO);

	tp = sc->sc_tty;
	return ((*linesw[tp->t_line].l_write)(tp, uio, flag));
}

int
vconsioctl(dev_t dev, u_long cmd, caddr_t data, int flag, struct proc *p)
{
	struct vcons_softc *sc;
	struct tty *tp;
	int unit = minor(dev);
	int error;

	if (unit >= vcons_cd.cd_ndevs)
		return (ENXIO);
	sc = vcons_cd.cd_devs[unit];
	if (sc == NULL)
		return (ENXIO);

	tp = sc->sc_tty;
	error = (*linesw[tp->t_line].l_ioctl)(tp, cmd, data, flag, p);
	if (error >= 0)
		return error;
	error = ttioctl(tp, cmd, data, flag, p);
	if (error >= 0)
		return (error);

	return (ENOTTY);
}

void
vconsstart(struct tty *tp)
{
	int s;

	s = spltty();
	if (tp->t_state & (TS_TTSTOP | TS_BUSY)) {
		splx(s);
		return;
	}
	ttwakeupwr(tp);
	tp->t_state |= TS_BUSY;
	while (tp->t_outq.c_cc != 0)
		vcons_cnputc(tp->t_dev, getc(&tp->t_outq));
	tp->t_state &= ~TS_BUSY;
	splx(s);
}

int
vconsstop(struct tty *tp, int flag)
{
	int s;

	s = spltty();
	if (tp->t_state & TS_BUSY)
		if ((tp->t_state & TS_TTSTOP) == 0)
			tp->t_state |= TS_FLUSH;
	splx(s);
	return (0);
}

struct tty *
vconstty(dev_t dev)
{
	struct vcons_softc *sc;
	int unit = minor(dev);

	if (unit >= vcons_cd.cd_ndevs)
		return (NULL);
	sc = vcons_cd.cd_devs[unit];
	if (sc == NULL)
		return (NULL);

	return sc->sc_tty;
}

int
vconsparam(struct tty *tp, struct termios *t)
{
	tp->t_ispeed = t->c_ispeed;
	tp->t_ospeed = t->c_ospeed;
	tp->t_cflag = t->c_cflag;
	return (0);
}

void
vcons_softintr(void *arg)
{
	struct vcons_softc *sc = arg;
	struct tty *tp = sc->sc_tty;
	int c;

	while (vcons_cnlookc(tp->t_dev, &c)) {
		if (tp->t_state & TS_ISOPEN)
			(*linesw[tp->t_line].l_rint)(c, tp);
	}
}
@


1.13
log
@The interrupt handler for vcons(4) is defenitely safe to run without holding
the kernel lock, so use BUS_INTR_ESTABLISH_MPSAFE.
@
text
@d1 1
a1 1
/*	$OpenBSD: vcons.c,v 1.12 2012/10/20 12:00:33 miod Exp $	*/
d91 1
a91 1
	printf(": ivec 0x%lx", sysino);
@


1.12
log
@off-by-one in device number check; found the hard way and reported by J Sisson.
@
text
@d1 1
a1 1
/*	$OpenBSD: vcons.c,v 1.11 2011/01/04 20:48:56 kettenis Exp $	*/
d93 2
a94 2
	sc->sc_ih = bus_intr_establish(va->va_bustag, sysino, IPL_TTY, 0,
	    vcons_intr, sc, sc->sc_dv.dv_xname);
@


1.11
log
@It is actually possible to run CoolThreads servers with a graphics console,
so don't assume vcons(4) always is the console.
@
text
@d1 1
a1 1
/*	$OpenBSD: vcons.c,v 1.10 2010/07/02 17:27:01 nicm Exp $	*/
d176 1
a176 1
	if (unit > vcons_cd.cd_ndevs)
d212 1
a212 1
	if (unit > vcons_cd.cd_ndevs)
d231 1
a231 1
	if (unit > vcons_cd.cd_ndevs)
d248 1
a248 1
	if (unit > vcons_cd.cd_ndevs)
d266 1
a266 1
	if (unit > vcons_cd.cd_ndevs)
d320 1
a320 1
	if (unit > vcons_cd.cd_ndevs)
@


1.10
log
@Move common code for waking up writers on a tty into a function.

ok deraadt matthew millert
@
text
@d1 1
a1 1
/*	$OpenBSD: vcons.c,v 1.9 2010/06/28 14:13:31 deraadt Exp $	*/
d82 2
a83 1
	int maj;
d91 1
a91 1
	printf(": ivec 0x%lx\n", sysino);
d93 2
a94 1
	sc->sc_ih = bus_intr_establish(va->va_bustag, sysino, IPL_TTY, 0, vcons_intr, sc, sc->sc_dv.dv_xname);
d96 1
a96 1
		printf("%s: can't establish interrupt\n", sc->sc_dv.dv_xname);
d100 23
a122 9
	cn_tab->cn_pollc = nullcnpollc;
	cn_tab->cn_getc = vcons_cngetc;
	cn_tab->cn_putc = vcons_cnputc;

	/* Locate the major number. */
	for (maj = 0; maj < nchrdev; maj++)
		if (cdevsw[maj].d_open == vconsopen)
			break;
	cn_tab->cn_dev = makedev(maj, self->dv_unit);
@


1.9
log
@Allow tty drivers to request larger buffers at attach time using a
max-baud-rate hint.  Adjust TTYHOG (the nearly full logic) to this new
situation.  The larger buffers are required by the very high speed
KDDI devices in Japan (CF com, or USB ucom) so those are the only two
drivers which currently ask for a larger buffer size.
ok yasuoka miod
@
text
@d1 1
a1 1
/*	$OpenBSD: vcons.c,v 1.8 2010/04/12 12:57:52 tedu Exp $	*/
d277 1
a277 7
	if (tp->t_outq.c_cc <= tp->t_lowat) {
		if (tp->t_state & TS_ASLEEP) {
			tp->t_state &= ~TS_ASLEEP;
			wakeup((caddr_t)&tp->t_outq);
		}
		selwakeup(&tp->t_wsel);
	}
@


1.8
log
@Some of the line disciplines want to check for suser.  Better to pass them
a process instead of using curproc.  ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: vcons.c,v 1.7 2009/11/09 17:53:39 nicm Exp $	*/
d169 1
a169 1
		tp = sc->sc_tty = ttymalloc();
@


1.7
log
@Every selwakeup() should have a matching KNOTE() (even if kqueue isn't
supported it doesn't do any harm), so put the KNOTE() in selwakeup() itself and
remove it from any occurences where both are used, except one for kqueue itself
and one in sys_pipe.c (where the selwakeup is under a PIPE_SEL flag).

Based on a diff from tedu.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: vcons.c,v 1.6 2009/10/31 06:40:16 deraadt Exp $	*/
d186 1
a186 1
	return ((*linesw[tp->t_line].l_open)(dev, tp));
d203 1
a203 1
	(*linesw[tp->t_line].l_close)(tp, flag);
@


1.6
log
@Add missing KNOTE() calls after selwakeup(), until we decide if the KNOTE()
calls can go directly into selwakeup() safely
long discussion with nicm, murmers of consent from tedu and miod, noone
else seems to care of kqueue is busted as long as it makes their sockets
move data fast... pretty sad.
@
text
@d1 1
a1 1
/*	$OpenBSD: vcons.c,v 1.5 2008/11/24 16:19:33 kettenis Exp $	*/
a282 1
		KNOTE(&tp->t_wsel.si_note, 0);
@


1.5
log
@Only schedule a soft interrupt if the device has been opened (and sc_tty
has been initialized).
@
text
@d1 1
a1 1
/*	$OpenBSD: vcons.c,v 1.4 2008/10/12 09:18:24 kettenis Exp $	*/
d283 1
@


1.4
log
@Make vcons(4) interrupt driven.
@
text
@d1 1
a1 1
/*	$OpenBSD: vcons.c,v 1.3 2008/09/23 22:44:19 miod Exp $	*/
d114 2
a115 1
	softintr_schedule(sc->sc_si);
@


1.3
log
@One more uninitialized local. Yawn.
@
text
@d1 1
a1 1
/*	$OpenBSD: vcons.c,v 1.2 2008/07/07 14:38:42 kettenis Exp $	*/
a22 1
#include <sys/timeout.h>
d38 2
a39 1
	struct device	sc_dev;
d41 1
a41 1
	struct timeout	sc_to;
d55 2
d63 1
a63 1
void	vconstimeout(void *);
d80 2
d84 13
a96 3
	printf("\n");

	timeout_set(&sc->sc_to, vconstimeout, sc);
d110 9
a157 1
	int error, setuptimeout = 0;
a180 2

		setuptimeout = 1;
d185 1
a185 5
	error = (*linesw[tp->t_line].l_open)(dev, tp);
	if (error == 0 && setuptimeout)
		vconstimeout(sc);

	return (error);
a201 1
	timeout_del(&sc->sc_to);
d328 1
a328 1
vconstimeout(void *v)
d330 1
a330 1
	struct vcons_softc *sc = v;
a337 1
	timeout_add(&sc->sc_to, 1);
@


1.2
log
@Fix typo in comment.
@
text
@d1 1
a1 1
/*	$OpenBSD: vcons.c,v 1.1 2008/03/08 19:38:33 kettenis Exp $	*/
d135 1
a135 1
	int error, setuptimeout;
@


1.1
log
@Driver for console on sun4v.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d88 1
a88 1
	/* Locate the mahor number. */
@

