head	1.47;
access;
symbols
	OPENBSD_6_1_BASE:1.47
	OPENBSD_6_0:1.46.0.8
	OPENBSD_6_0_BASE:1.46
	OPENBSD_5_9:1.46.0.4
	OPENBSD_5_9_BASE:1.46
	OPENBSD_5_8:1.46.0.6
	OPENBSD_5_8_BASE:1.46
	OPENBSD_5_7:1.46.0.2
	OPENBSD_5_7_BASE:1.46
	OPENBSD_5_6:1.39.0.4
	OPENBSD_5_6_BASE:1.39
	OPENBSD_5_5:1.36.0.4
	OPENBSD_5_5_BASE:1.36
	OPENBSD_5_4:1.33.0.2
	OPENBSD_5_4_BASE:1.33
	OPENBSD_5_3:1.32.0.2
	OPENBSD_5_3_BASE:1.32
	OPENBSD_5_2:1.29.0.6
	OPENBSD_5_2_BASE:1.29
	OPENBSD_5_1_BASE:1.29
	OPENBSD_5_1:1.29.0.4
	OPENBSD_5_0:1.29.0.2
	OPENBSD_5_0_BASE:1.29
	OPENBSD_4_9:1.27.0.2
	OPENBSD_4_9_BASE:1.27
	OPENBSD_4_8:1.24.0.2
	OPENBSD_4_8_BASE:1.24
	OPENBSD_4_7:1.17.0.2
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.12.0.4
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.10.0.2
	OPENBSD_4_5_BASE:1.10;
locks; strict;
comment	@ * @;


1.47
date	2016.10.13.18.16.42;	author tom;	state Exp;
branches;
next	1.46;
commitid	SqaLeQ0YjEjdttMK;

1.46
date	2015.01.25.21.42.13;	author kettenis;	state Exp;
branches;
next	1.45;
commitid	ZoO3iubG0jt8mq0g;

1.45
date	2014.09.21.14.52.37;	author kettenis;	state Exp;
branches;
next	1.44;
commitid	eh7onasQrOf5Yb8v;

1.44
date	2014.09.21.14.15.01;	author kettenis;	state Exp;
branches;
next	1.43;
commitid	dxLOzenvVZWqHHhw;

1.43
date	2014.09.16.20.23.42;	author kettenis;	state Exp;
branches;
next	1.42;
commitid	tC2bKKKk2wBWPbJW;

1.42
date	2014.09.16.15.59.35;	author kettenis;	state Exp;
branches;
next	1.41;
commitid	WgD9sNzncfXkgUSP;

1.41
date	2014.09.15.20.34.15;	author kettenis;	state Exp;
branches;
next	1.40;
commitid	mvbATfDpXpzcIPNZ;

1.40
date	2014.09.15.08.16.21;	author kettenis;	state Exp;
branches;
next	1.39;
commitid	6WK0lWMMGMygVGrL;

1.39
date	2014.07.12.18.44.43;	author tedu;	state Exp;
branches;
next	1.38;
commitid	uKVPYMN2MLxdZxzH;

1.38
date	2014.05.10.11.49.31;	author kettenis;	state Exp;
branches;
next	1.37;

1.37
date	2014.04.03.09.15.06;	author mpi;	state Exp;
branches;
next	1.36;

1.36
date	2014.01.22.23.57.59;	author kettenis;	state Exp;
branches;
next	1.35;

1.35
date	2014.01.22.22.24.12;	author kettenis;	state Exp;
branches;
next	1.34;

1.34
date	2014.01.22.21.35.58;	author dlg;	state Exp;
branches;
next	1.33;

1.33
date	2013.05.12.19.33.01;	author krw;	state Exp;
branches;
next	1.32;

1.32
date	2012.11.21.23.02.37;	author kettenis;	state Exp;
branches;
next	1.31;

1.31
date	2012.11.21.21.20.13;	author kettenis;	state Exp;
branches;
next	1.30;

1.30
date	2012.10.26.20.57.08;	author kettenis;	state Exp;
branches;
next	1.29;

1.29
date	2011.07.17.22.46.47;	author matthew;	state Exp;
branches;
next	1.28;

1.28
date	2011.07.08.22.09.27;	author matthew;	state Exp;
branches;
next	1.27;

1.27
date	2011.01.01.20.49.53;	author kettenis;	state Exp;
branches;
next	1.26;

1.26
date	2011.01.01.20.32.18;	author kettenis;	state Exp;
branches;
next	1.25;

1.25
date	2010.10.12.00.53.32;	author krw;	state Exp;
branches;
next	1.24;

1.24
date	2010.06.28.18.31.01;	author krw;	state Exp;
branches;
next	1.23;

1.23
date	2010.06.15.04.11.34;	author dlg;	state Exp;
branches;
next	1.22;

1.22
date	2010.05.22.19.55.42;	author kettenis;	state Exp;
branches;
next	1.21;

1.21
date	2010.05.20.16.31.03;	author thib;	state Exp;
branches;
next	1.20;

1.20
date	2010.05.20.00.55.17;	author krw;	state Exp;
branches;
next	1.19;

1.19
date	2010.03.24.06.55.28;	author dlg;	state Exp;
branches;
next	1.18;

1.18
date	2010.03.23.01.57.19;	author krw;	state Exp;
branches;
next	1.17;

1.17
date	2010.01.09.23.15.06;	author krw;	state Exp;
branches;
next	1.16;

1.16
date	2009.12.12.13.24.58;	author kettenis;	state Exp;
branches;
next	1.15;

1.15
date	2009.12.09.22.39.52;	author kettenis;	state Exp;
branches;
next	1.14;

1.14
date	2009.12.09.18.41.14;	author kettenis;	state Exp;
branches;
next	1.13;

1.13
date	2009.12.08.20.37.58;	author kettenis;	state Exp;
branches;
next	1.12;

1.12
date	2009.05.12.20.20.35;	author kettenis;	state Exp;
branches;
next	1.11;

1.11
date	2009.05.10.12.59.12;	author kettenis;	state Exp;
branches;
next	1.10;

1.10
date	2009.02.20.17.55.28;	author kettenis;	state Exp;
branches;
next	1.9;

1.9
date	2009.02.16.21.19.06;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2009.01.17.22.18.14;	author kettenis;	state Exp;
branches;
next	1.7;

1.7
date	2009.01.17.20.36.42;	author kettenis;	state Exp;
branches;
next	1.6;

1.6
date	2009.01.17.17.11.10;	author kettenis;	state Exp;
branches;
next	1.5;

1.5
date	2009.01.16.23.57.45;	author kettenis;	state Exp;
branches;
next	1.4;

1.4
date	2009.01.16.17.50.55;	author kettenis;	state Exp;
branches;
next	1.3;

1.3
date	2009.01.16.16.59.58;	author kettenis;	state Exp;
branches;
next	1.2;

1.2
date	2009.01.12.23.05.07;	author kettenis;	state Exp;
branches;
next	1.1;

1.1
date	2009.01.12.20.11.13;	author kettenis;	state Exp;
branches;
next	;


desc
@@


1.47
log
@Fix memory leaks on error paths spotted by coypu (at) SDF (dot) ORG - thanks

ok deraadt@@
@
text
@/*	$OpenBSD: vdsk.c,v 1.46 2015/01/25 21:42:13 kettenis Exp $	*/
/*
 * Copyright (c) 2009, 2011 Mark Kettenis
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/buf.h>
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/systm.h>

#include <machine/autoconf.h>
#include <machine/hypervisor.h>

#include <uvm/uvm_extern.h>

#include <scsi/scsi_all.h>
#include <scsi/cd.h>
#include <scsi/scsi_disk.h>
#include <scsi/scsiconf.h>

#include <sparc64/dev/cbusvar.h>
#include <sparc64/dev/ldcvar.h>
#include <sparc64/dev/viovar.h>

#ifdef VDSK_DEBUG
#define DPRINTF(x)	printf x
#else
#define DPRINTF(x)
#endif

#define VDSK_TX_ENTRIES		32
#define VDSK_RX_ENTRIES		32

struct vd_attr_info {
	struct vio_msg_tag	tag;
	uint8_t			xfer_mode;
	uint8_t			vd_type;
	uint8_t			vd_mtype;
	uint8_t			_reserved1;
	uint32_t		vdisk_block_size;
	uint64_t		operations;
	uint64_t		vdisk_size;
	uint64_t		max_xfer_sz;
	uint64_t		_reserved2[2];
};

#define VD_DISK_TYPE_SLICE	0x01
#define VD_DISK_TYPE_DISK	0x02

#define VD_MEDIA_TYPE_FIXED	0x01
#define VD_MEDIA_TYPE_CD	0x02
#define VD_MEDIA_TYPE_DVD	0x03

/* vDisk version 1.0. */
#define VD_OP_BREAD		0x01
#define VD_OP_BWRITE		0x02
#define VD_OP_FLUSH		0x03
#define VD_OP_GET_WCE		0x04
#define VD_OP_SET_WCE		0x05
#define VD_OP_GET_VTOC		0x06
#define VD_OP_SET_VTOC		0x07
#define VD_OP_GET_DISKGEOM	0x08
#define VD_OP_SET_DISKGEOM	0x09
#define VD_OP_GET_DEVID		0x0b
#define VD_OP_GET_EFI		0x0c
#define VD_OP_SET_EFI		0x0d

/* vDisk version 1.1 */
#define VD_OP_SCSICMD		0x0a
#define VD_OP_RESET		0x0e
#define VD_OP_GET_ACCESS	0x0f
#define VD_OP_SET_ACCESS	0x10
#define VD_OP_GET_CAPACITY	0x11

struct vd_desc {
	struct vio_dring_hdr	hdr;
	uint64_t		req_id;
	uint8_t			operation;
	uint8_t			slice;
	uint16_t		_reserved1;
	uint32_t		status;
	uint64_t		offset;
	uint64_t		size;
	uint32_t		ncookies;
	uint32_t		_reserved2;
	struct ldc_cookie	cookie[MAXPHYS / PAGE_SIZE];
};

#define VD_SLICE_NONE		0xff

struct vdsk_dring {
	bus_dmamap_t		vd_map;
	bus_dma_segment_t	vd_seg;
	struct vd_desc		*vd_desc;
	int			vd_nentries;
};

struct vdsk_dring *vdsk_dring_alloc(bus_dma_tag_t, int);
void	vdsk_dring_free(bus_dma_tag_t, struct vdsk_dring *);

/*
 * We support vDisk 1.0 and 1.1.
 */
#define VDSK_MAJOR	1
#define VDSK_MINOR	1

struct vdsk_soft_desc {
	int		vsd_map_idx[MAXPHYS / PAGE_SIZE];
	struct scsi_xfer *vsd_xs;
	int		vsd_ncookies;
};

struct vdsk_softc {
	struct device	sc_dv;
	bus_space_tag_t	sc_bustag;
	bus_dma_tag_t	sc_dmatag;

	void		*sc_tx_ih;
	void		*sc_rx_ih;

	struct ldc_conn	sc_lc;

	uint16_t	sc_vio_state;
#define VIO_SND_VER_INFO	0x0001
#define VIO_ACK_VER_INFO	0x0002
#define VIO_SND_ATTR_INFO	0x0004
#define VIO_ACK_ATTR_INFO	0x0008
#define VIO_SND_DRING_REG	0x0010
#define VIO_ACK_DRING_REG	0x0020
#define VIO_SND_RDX		0x0040
#define VIO_ACK_RDX		0x0080
#define VIO_ESTABLISHED		0x00ff

	uint16_t	sc_major;
	uint16_t	sc_minor;

	uint32_t	sc_local_sid;
	uint64_t	sc_dring_ident;
	uint64_t	sc_seq_no;

	int		sc_tx_cnt;
	int		sc_tx_prod;
	int		sc_tx_cons;

	struct ldc_map	*sc_lm;
	struct vdsk_dring *sc_vd;
	struct vdsk_soft_desc *sc_vsd;

	struct scsi_iopool sc_iopool;
	struct scsi_adapter sc_switch;
	struct scsi_link sc_link;

	uint32_t	sc_vdisk_block_size;
	uint64_t	sc_vdisk_size;
	uint8_t		sc_vd_mtype;
};

int	vdsk_match(struct device *, void *, void *);
void	vdsk_attach(struct device *, struct device *, void *);

struct cfattach vdsk_ca = {
	sizeof(struct vdsk_softc), vdsk_match, vdsk_attach
};

struct cfdriver vdsk_cd = {
	NULL, "vdsk", DV_DULL
};

int	vdsk_tx_intr(void *);
int	vdsk_rx_intr(void *);

void	vdsk_rx_data(struct ldc_conn *, struct ldc_pkt *);
void	vdsk_rx_vio_ctrl(struct vdsk_softc *, struct vio_msg *);
void	vdsk_rx_vio_ver_info(struct vdsk_softc *, struct vio_msg_tag *);
void	vdsk_rx_vio_attr_info(struct vdsk_softc *, struct vio_msg_tag *);
void	vdsk_rx_vio_dring_reg(struct vdsk_softc *, struct vio_msg_tag *);
void	vdsk_rx_vio_rdx(struct vdsk_softc *sc, struct vio_msg_tag *);
void	vdsk_rx_vio_data(struct vdsk_softc *sc, struct vio_msg *);
void	vdsk_rx_vio_dring_data(struct vdsk_softc *sc, struct vio_msg_tag *);

void	vdsk_ldc_reset(struct ldc_conn *);
void	vdsk_ldc_start(struct ldc_conn *);

void	vdsk_sendmsg(struct vdsk_softc *, void *, size_t);
void	vdsk_send_ver_info(struct vdsk_softc *, uint16_t, uint16_t);
void	vdsk_send_attr_info(struct vdsk_softc *);
void	vdsk_send_dring_reg(struct vdsk_softc *);
void	vdsk_send_rdx(struct vdsk_softc *);

void	*vdsk_io_get(void *);
void	vdsk_io_put(void *, void *);

void	vdsk_scsi_cmd(struct scsi_xfer *);
int	vdsk_submit_cmd(struct scsi_xfer *);
void	vdsk_complete_cmd(struct scsi_xfer *, int);
int	vdsk_dev_probe(struct scsi_link *);
void	vdsk_dev_free(struct scsi_link *);

void	vdsk_scsi_inq(struct scsi_xfer *);
void	vdsk_scsi_inquiry(struct scsi_xfer *);
void	vdsk_scsi_capacity(struct scsi_xfer *);
void	vdsk_scsi_capacity16(struct scsi_xfer *);
void	vdsk_scsi_done(struct scsi_xfer *, int);

int
vdsk_match(struct device *parent, void *match, void *aux)
{
	struct cbus_attach_args *ca = aux;

	if (strcmp(ca->ca_name, "disk") == 0)
		return (1);

	return (0);
}

void
vdsk_attach(struct device *parent, struct device *self, void *aux)
{
	struct vdsk_softc *sc = (struct vdsk_softc *)self;
	struct cbus_attach_args *ca = aux;
	struct scsibus_attach_args saa;
	struct ldc_conn *lc;
	int err, s;
	int timeout;

	sc->sc_bustag = ca->ca_bustag;
	sc->sc_dmatag = ca->ca_dmatag;

	printf(": ivec 0x%llx, 0x%llx", ca->ca_tx_ino, ca->ca_rx_ino);

	/*
	 * Un-configure queues before registering interrupt handlers,
	 * such that we dont get any stale LDC packets or events.
	 */
	hv_ldc_tx_qconf(ca->ca_id, 0, 0);
	hv_ldc_rx_qconf(ca->ca_id, 0, 0);

	sc->sc_tx_ih = bus_intr_establish(ca->ca_bustag, ca->ca_tx_ino,
	    IPL_BIO, 0, vdsk_tx_intr, sc, sc->sc_dv.dv_xname);
	sc->sc_rx_ih = bus_intr_establish(ca->ca_bustag, ca->ca_rx_ino,
	    IPL_BIO, 0, vdsk_rx_intr, sc, sc->sc_dv.dv_xname);
	if (sc->sc_tx_ih == NULL || sc->sc_rx_ih == NULL) {
		printf(", can't establish interrupt\n");
		return;
	}

	lc = &sc->sc_lc;
	lc->lc_id = ca->ca_id;
	lc->lc_sc = sc;
	lc->lc_reset = vdsk_ldc_reset;
	lc->lc_start = vdsk_ldc_start;
	lc->lc_rx_data = vdsk_rx_data;

	lc->lc_txq = ldc_queue_alloc(sc->sc_dmatag, VDSK_TX_ENTRIES);
	if (lc->lc_txq == NULL) {
		printf(", can't allocate tx queue\n");
		return;
	}

	lc->lc_rxq = ldc_queue_alloc(sc->sc_dmatag, VDSK_RX_ENTRIES);
	if (lc->lc_rxq == NULL) {
		printf(", can't allocate rx queue\n");
		goto free_txqueue;
	}

	sc->sc_lm = ldc_map_alloc(sc->sc_dmatag, 2048);
	if (sc->sc_lm == NULL) {
		printf(", can't allocate LDC mapping table\n");
		goto free_rxqueue;
	}

	err = hv_ldc_set_map_table(lc->lc_id,
	    sc->sc_lm->lm_map->dm_segs[0].ds_addr, sc->sc_lm->lm_nentries);
	if (err != H_EOK) {
		printf("hv_ldc_set_map_table %d\n", err);
		goto free_map;
	}

	sc->sc_vd = vdsk_dring_alloc(sc->sc_dmatag, 32);
	if (sc->sc_vd == NULL) {
		printf(", can't allocate dring\n");
		goto free_map;
	}
	sc->sc_vsd = malloc(32 * sizeof(*sc->sc_vsd), M_DEVBUF, M_NOWAIT);
	if (sc->sc_vsd == NULL) {
		printf(", can't allocate software ring\n");
		goto free_dring;
	}

	sc->sc_lm->lm_slot[0].entry = sc->sc_vd->vd_map->dm_segs[0].ds_addr;
	sc->sc_lm->lm_slot[0].entry &= LDC_MTE_RA_MASK;
	sc->sc_lm->lm_slot[0].entry |= LDC_MTE_CPR | LDC_MTE_CPW;
	sc->sc_lm->lm_slot[0].entry |= LDC_MTE_R | LDC_MTE_W;
	sc->sc_lm->lm_next = 1;
	sc->sc_lm->lm_count = 1;

	err = hv_ldc_tx_qconf(lc->lc_id,
	    lc->lc_txq->lq_map->dm_segs[0].ds_addr, lc->lc_txq->lq_nentries);
	if (err != H_EOK)
		printf("hv_ldc_tx_qconf %d\n", err);

	err = hv_ldc_rx_qconf(lc->lc_id,
	    lc->lc_rxq->lq_map->dm_segs[0].ds_addr, lc->lc_rxq->lq_nentries);
	if (err != H_EOK)
		printf("hv_ldc_rx_qconf %d\n", err);

	cbus_intr_setenabled(sc->sc_bustag, ca->ca_tx_ino, INTR_ENABLED);
	cbus_intr_setenabled(sc->sc_bustag, ca->ca_rx_ino, INTR_ENABLED);

	ldc_send_vers(lc);

	printf("\n");

	/*
	 * Interrupts aren't enabled during autoconf, so poll for VIO
	 * peer-to-peer hanshake completion.
	 */
	s = splbio();
	timeout = 1000;
	do {
		if (vdsk_rx_intr(sc) && sc->sc_vio_state == VIO_ESTABLISHED)
			break;

		delay(1000);
	} while(--timeout > 0);
	splx(s);

	if (sc->sc_vio_state != VIO_ESTABLISHED)
		return;

	scsi_iopool_init(&sc->sc_iopool, sc, vdsk_io_get, vdsk_io_put);

	sc->sc_switch.scsi_cmd = vdsk_scsi_cmd;
	sc->sc_switch.scsi_minphys = scsi_minphys;
	sc->sc_switch.dev_probe = vdsk_dev_probe;
	sc->sc_switch.dev_free = vdsk_dev_free;

	sc->sc_link.adapter = &sc->sc_switch;
	sc->sc_link.adapter_softc = self;
	sc->sc_link.adapter_buswidth = 2;
	sc->sc_link.luns = 1; /* XXX slices should be presented as luns? */
	sc->sc_link.adapter_target = 2;
	sc->sc_link.openings = sc->sc_vd->vd_nentries - 1;
	sc->sc_link.pool = &sc->sc_iopool;

	bzero(&saa, sizeof(saa));
	saa.saa_sc_link = &sc->sc_link;
	config_found(self, &saa, scsiprint);

	return;

free_dring:
	vdsk_dring_free(sc->sc_dmatag, sc->sc_vd);
free_map:
	hv_ldc_set_map_table(lc->lc_id, 0, 0);
	ldc_map_free(sc->sc_dmatag, sc->sc_lm);
free_rxqueue:
	ldc_queue_free(sc->sc_dmatag, lc->lc_rxq);
free_txqueue:
	ldc_queue_free(sc->sc_dmatag, lc->lc_txq);
}

int
vdsk_tx_intr(void *arg)
{
	struct vdsk_softc *sc = arg;
	struct ldc_conn *lc = &sc->sc_lc;
	uint64_t tx_head, tx_tail, tx_state;

	hv_ldc_tx_get_state(lc->lc_id, &tx_head, &tx_tail, &tx_state);
	if (tx_state != lc->lc_tx_state) {
		switch (tx_state) {
		case LDC_CHANNEL_DOWN:
			DPRINTF(("Tx link down\n"));
			break;
		case LDC_CHANNEL_UP:
			DPRINTF(("Tx link up\n"));
			break;
		case LDC_CHANNEL_RESET:
			DPRINTF(("Tx link reset\n"));
			break;
		}
		lc->lc_tx_state = tx_state;
	}

	return (1);
}

int
vdsk_rx_intr(void *arg)
{
	struct vdsk_softc *sc = arg;
	struct ldc_conn *lc = &sc->sc_lc;
	uint64_t rx_head, rx_tail, rx_state;
	struct ldc_pkt *lp;
	int err;

	err = hv_ldc_rx_get_state(lc->lc_id, &rx_head, &rx_tail, &rx_state);
	if (err == H_EINVAL)
		return (0);
	if (err != H_EOK) {
		printf("hv_ldc_rx_get_state %d\n", err);
		return (0);
	}

	if (rx_state != lc->lc_rx_state) {
		sc->sc_vio_state = 0;
		lc->lc_tx_seqid = 0;
		lc->lc_state = 0;
		switch (rx_state) {
		case LDC_CHANNEL_DOWN:
			DPRINTF(("Rx link down\n"));
			break;
		case LDC_CHANNEL_UP:
			DPRINTF(("Rx link up\n"));
			ldc_send_vers(lc);
			break;
		case LDC_CHANNEL_RESET:
			DPRINTF(("Rx link reset\n"));
			break;
		}
		lc->lc_rx_state = rx_state;
		hv_ldc_rx_set_qhead(lc->lc_id, rx_tail);
		return (1);
	}

	if (rx_head == rx_tail)
		return (0);

	lp = (struct ldc_pkt *)(lc->lc_rxq->lq_va + rx_head);
	switch (lp->type) {
	case LDC_CTRL:
		ldc_rx_ctrl(lc, lp);
		break;

	case LDC_DATA:
		ldc_rx_data(lc, lp);
		break;

	default:
		DPRINTF(("%0x02/%0x02/%0x02\n", lp->type, lp->stype,
		    lp->ctrl));
		ldc_reset(lc);
		break;
	}

	if (lc->lc_state == 0)
		return (1);

	rx_head += sizeof(*lp);
	rx_head &= ((lc->lc_rxq->lq_nentries * sizeof(*lp)) - 1);
	err = hv_ldc_rx_set_qhead(lc->lc_id, rx_head);
	if (err != H_EOK)
		printf("%s: hv_ldc_rx_set_qhead %d\n", __func__, err);

	return (1);
}

void
vdsk_rx_data(struct ldc_conn *lc, struct ldc_pkt *lp)
{
	struct vio_msg *vm = (struct vio_msg *)lp;

	switch (vm->type) {
	case VIO_TYPE_CTRL:
		if ((lp->env & LDC_FRAG_START) == 0 &&
		    (lp->env & LDC_FRAG_STOP) == 0)
			return;
		vdsk_rx_vio_ctrl(lc->lc_sc, vm);
		break;

	case VIO_TYPE_DATA:
		if((lp->env & LDC_FRAG_START) == 0)
			return;
		vdsk_rx_vio_data(lc->lc_sc, vm);
		break;

	default:
		DPRINTF(("Unhandled packet type 0x%02x\n", vm->type));
		ldc_reset(lc);
		break;
	}
}

void
vdsk_rx_vio_ctrl(struct vdsk_softc *sc, struct vio_msg *vm)
{
	struct vio_msg_tag *tag = (struct vio_msg_tag *)&vm->type;

	switch (tag->stype_env) {
	case VIO_VER_INFO:
		vdsk_rx_vio_ver_info(sc, tag);
		break;
	case VIO_ATTR_INFO:
		vdsk_rx_vio_attr_info(sc, tag);
		break;
	case VIO_DRING_REG:
		vdsk_rx_vio_dring_reg(sc, tag);
		break;
	case VIO_RDX:
		vdsk_rx_vio_rdx(sc, tag);
		break;
	default:
		DPRINTF(("CTRL/0x%02x/0x%04x\n", tag->stype, tag->stype_env));
		break;
	}
}

void
vdsk_rx_vio_ver_info(struct vdsk_softc *sc, struct vio_msg_tag *tag)
{
	struct vio_ver_info *vi = (struct vio_ver_info *)tag;

	switch (vi->tag.stype) {
	case VIO_SUBTYPE_INFO:
		DPRINTF(("CTRL/INFO/VER_INFO\n"));
		break;

	case VIO_SUBTYPE_ACK:
		DPRINTF(("CTRL/ACK/VER_INFO\n"));
		if (!ISSET(sc->sc_vio_state, VIO_SND_VER_INFO)) {
			ldc_reset(&sc->sc_lc);
			break;
		}
		sc->sc_major = vi->major;
		sc->sc_minor = vi->minor;
		sc->sc_vio_state |= VIO_ACK_VER_INFO;
		break;

	default:
		DPRINTF(("CTRL/0x%02x/VER_INFO\n", vi->tag.stype));
		break;
	}

	if (ISSET(sc->sc_vio_state, VIO_ACK_VER_INFO))
		vdsk_send_attr_info(sc);
}

void
vdsk_rx_vio_attr_info(struct vdsk_softc *sc, struct vio_msg_tag *tag)
{
	struct vd_attr_info *ai = (struct vd_attr_info *)tag;

	switch (ai->tag.stype) {
	case VIO_SUBTYPE_INFO:
		DPRINTF(("CTRL/INFO/ATTR_INFO\n"));
		break;

	case VIO_SUBTYPE_ACK:
		DPRINTF(("CTRL/ACK/ATTR_INFO\n"));
		if (!ISSET(sc->sc_vio_state, VIO_SND_ATTR_INFO)) {
			ldc_reset(&sc->sc_lc);
			break;
		}

		sc->sc_vdisk_block_size = ai->vdisk_block_size;
		sc->sc_vdisk_size = ai->vdisk_size;
		if (sc->sc_major > 1 || sc->sc_minor >= 1)
			sc->sc_vd_mtype = ai->vd_mtype;
		else
			sc->sc_vd_mtype = VD_MEDIA_TYPE_FIXED;

		sc->sc_vio_state |= VIO_ACK_ATTR_INFO;
		break;

	default:
		DPRINTF(("CTRL/0x%02x/ATTR_INFO\n", ai->tag.stype));
		break;
	}

	if (ISSET(sc->sc_vio_state, VIO_ACK_ATTR_INFO))
		vdsk_send_dring_reg(sc);

}

void
vdsk_rx_vio_dring_reg(struct vdsk_softc *sc, struct vio_msg_tag *tag)
{
	struct vio_dring_reg *dr = (struct vio_dring_reg *)tag;

	switch (dr->tag.stype) {
	case VIO_SUBTYPE_INFO:
		DPRINTF(("CTRL/INFO/DRING_REG\n"));
		break;

	case VIO_SUBTYPE_ACK:
		DPRINTF(("CTRL/ACK/DRING_REG\n"));
		if (!ISSET(sc->sc_vio_state, VIO_SND_DRING_REG)) {
			ldc_reset(&sc->sc_lc);
			break;
		}

		sc->sc_dring_ident = dr->dring_ident;
		sc->sc_seq_no = 1;

		sc->sc_vio_state |= VIO_ACK_DRING_REG;
		break;

	default:
		DPRINTF(("CTRL/0x%02x/DRING_REG\n", dr->tag.stype));
		break;
	}

	if (ISSET(sc->sc_vio_state, VIO_ACK_DRING_REG))
		vdsk_send_rdx(sc);
}

void
vdsk_rx_vio_rdx(struct vdsk_softc *sc, struct vio_msg_tag *tag)
{
	switch(tag->stype) {
	case VIO_SUBTYPE_INFO:
		DPRINTF(("CTRL/INFO/RDX\n"));
		break;

	case VIO_SUBTYPE_ACK:
	{
		int prod;

		DPRINTF(("CTRL/ACK/RDX\n"));
		if (!ISSET(sc->sc_vio_state, VIO_SND_RDX)) {
			ldc_reset(&sc->sc_lc);
			break;
		}
		sc->sc_vio_state |= VIO_ACK_RDX;

		/*
		 * If this ACK is the result of a reconnect, we may
		 * have pending I/O that we need to resubmit.  We need
		 * to rebuild the ring descriptors though since the
		 * vDisk server on the other side may have touched
		 * them already.  So we just clean up the ring and the
		 * LDC map and resubmit the SCSI commands based on our
		 * soft descriptors.
		 */
		prod = sc->sc_tx_prod;
		sc->sc_tx_prod = sc->sc_tx_cons;
		sc->sc_tx_cnt = 0;
		sc->sc_lm->lm_next = 1;
		sc->sc_lm->lm_count = 1;
		while (sc->sc_tx_prod != prod)
			vdsk_submit_cmd(sc->sc_vsd[sc->sc_tx_prod].vsd_xs);

		scsi_iopool_run(&sc->sc_iopool);
		break;
	}

	default:
		DPRINTF(("CTRL/0x%02x/RDX (VIO)\n", tag->stype));
		break;
	}
}

void
vdsk_rx_vio_data(struct vdsk_softc *sc, struct vio_msg *vm)
{
	struct vio_msg_tag *tag = (struct vio_msg_tag *)&vm->type;

	if (sc->sc_vio_state != VIO_ESTABLISHED) {
		DPRINTF(("Spurious DATA/0x%02x/0x%04x\n", tag->stype,
		    tag->stype_env));
		return;
	}

	switch(tag->stype_env) {
	case VIO_DRING_DATA:
		vdsk_rx_vio_dring_data(sc, tag);
		break;

	default:
		DPRINTF(("DATA/0x%02x/0x%04x\n", tag->stype, tag->stype_env));
		break;
	}
}

void
vdsk_rx_vio_dring_data(struct vdsk_softc *sc, struct vio_msg_tag *tag)
{
	switch(tag->stype) {
	case VIO_SUBTYPE_INFO:
		DPRINTF(("DATA/INFO/DRING_DATA\n"));
		break;

	case VIO_SUBTYPE_ACK:
	{
		struct scsi_xfer *xs;
		int cons;

		cons = sc->sc_tx_cons;
		while (sc->sc_vd->vd_desc[cons].hdr.dstate == VIO_DESC_DONE) {
			xs = sc->sc_vsd[cons].vsd_xs;
			if (ISSET(xs->flags, SCSI_POLL) == 0)
				vdsk_complete_cmd(xs, cons);
			cons++;
			cons &= (sc->sc_vd->vd_nentries - 1);
		}
		sc->sc_tx_cons = cons;
		break;
	}

	case VIO_SUBTYPE_NACK:
		DPRINTF(("DATA/NACK/DRING_DATA\n"));
		break;

	default:
		DPRINTF(("DATA/0x%02x/DRING_DATA\n", tag->stype));
		break;
	}
}

void
vdsk_ldc_reset(struct ldc_conn *lc)
{
	struct vdsk_softc *sc = lc->lc_sc;

	sc->sc_vio_state = 0;
}

void
vdsk_ldc_start(struct ldc_conn *lc)
{
	struct vdsk_softc *sc = lc->lc_sc;

	vdsk_send_ver_info(sc, VDSK_MAJOR, VDSK_MINOR);
}

void
vdsk_sendmsg(struct vdsk_softc *sc, void *msg, size_t len)
{
	struct ldc_conn *lc = &sc->sc_lc;
	int err;

	err = ldc_send_unreliable(lc, msg, len);
	if (err)
		printf("%s: ldc_send_unreliable: %d\n", __func__, err);
}

void
vdsk_send_ver_info(struct vdsk_softc *sc, uint16_t major, uint16_t minor)
{
	struct vio_ver_info vi;

	/* Allocate new session ID. */
	sc->sc_local_sid = tick();

	bzero(&vi, sizeof(vi));
	vi.tag.type = VIO_TYPE_CTRL;
	vi.tag.stype = VIO_SUBTYPE_INFO;
	vi.tag.stype_env = VIO_VER_INFO;
	vi.tag.sid = sc->sc_local_sid;
	vi.major = major;
	vi.minor = minor;
	vi.dev_class = VDEV_DISK;
	vdsk_sendmsg(sc, &vi, sizeof(vi));

	sc->sc_vio_state |= VIO_SND_VER_INFO;
}

void
vdsk_send_attr_info(struct vdsk_softc *sc)
{
	struct vd_attr_info ai;

	bzero(&ai, sizeof(ai));
	ai.tag.type = VIO_TYPE_CTRL;
	ai.tag.stype = VIO_SUBTYPE_INFO;
	ai.tag.stype_env = VIO_ATTR_INFO;
	ai.tag.sid = sc->sc_local_sid;
	ai.xfer_mode = VIO_DRING_MODE;
	ai.vdisk_block_size = DEV_BSIZE;
	ai.max_xfer_sz = MAXPHYS / DEV_BSIZE;
	vdsk_sendmsg(sc, &ai, sizeof(ai));

	sc->sc_vio_state |= VIO_SND_ATTR_INFO;
}

void
vdsk_send_dring_reg(struct vdsk_softc *sc)
{
	struct vio_dring_reg dr;

	bzero(&dr, sizeof(dr));
	dr.tag.type = VIO_TYPE_CTRL;
	dr.tag.stype = VIO_SUBTYPE_INFO;
	dr.tag.stype_env = VIO_DRING_REG;
	dr.tag.sid = sc->sc_local_sid;
	dr.dring_ident = 0;
	dr.num_descriptors = sc->sc_vd->vd_nentries;
	dr.descriptor_size = sizeof(struct vd_desc);
	dr.options = VIO_TX_RING | VIO_RX_RING;
	dr.ncookies = 1;
	dr.cookie[0].addr = 0;
	dr.cookie[0].size = PAGE_SIZE;
	vdsk_sendmsg(sc, &dr, sizeof(dr));

	sc->sc_vio_state |= VIO_SND_DRING_REG;
};

void
vdsk_send_rdx(struct vdsk_softc *sc)
{
	struct vio_rdx rdx;

	bzero(&rdx, sizeof(rdx));
	rdx.tag.type = VIO_TYPE_CTRL;
	rdx.tag.stype = VIO_SUBTYPE_INFO;
	rdx.tag.stype_env = VIO_RDX;
	rdx.tag.sid = sc->sc_local_sid;
	vdsk_sendmsg(sc, &rdx, sizeof(rdx));

	sc->sc_vio_state |= VIO_SND_RDX;
}

struct vdsk_dring *
vdsk_dring_alloc(bus_dma_tag_t t, int nentries)
{
	struct vdsk_dring *vd;
	bus_size_t size;
	caddr_t va;
	int nsegs;
	int i;

	vd = malloc(sizeof(struct vdsk_dring), M_DEVBUF, M_NOWAIT);
	if (vd == NULL)
		return NULL;

	size = roundup(nentries * sizeof(struct vd_desc), PAGE_SIZE);

	if (bus_dmamap_create(t, size, 1, size, 0,
	    BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW, &vd->vd_map) != 0)
		goto error;

	if (bus_dmamem_alloc(t, size, PAGE_SIZE, 0, &vd->vd_seg, 1,
	    &nsegs, BUS_DMA_NOWAIT) != 0)
		goto destroy;

	if (bus_dmamem_map(t, &vd->vd_seg, 1, size, &va,
	    BUS_DMA_NOWAIT) != 0)
		goto free;

	if (bus_dmamap_load(t, vd->vd_map, va, size, NULL,
	    BUS_DMA_NOWAIT) != 0)
		goto unmap;

	vd->vd_desc = (struct vd_desc *)va;
	vd->vd_nentries = nentries;
	bzero(vd->vd_desc, nentries * sizeof(struct vd_desc));
	for (i = 0; i < vd->vd_nentries; i++)
		vd->vd_desc[i].hdr.dstate = VIO_DESC_FREE;
	return (vd);

unmap:
	bus_dmamem_unmap(t, va, size);
free:
	bus_dmamem_free(t, &vd->vd_seg, 1);
destroy:
	bus_dmamap_destroy(t, vd->vd_map);
error:
	free(vd, M_DEVBUF, sizeof(struct vdsk_dring));

	return (NULL);
}

void
vdsk_dring_free(bus_dma_tag_t t, struct vdsk_dring *vd)
{
	bus_size_t size;

	size = vd->vd_nentries * sizeof(struct vd_desc);
	size = roundup(size, PAGE_SIZE);

	bus_dmamap_unload(t, vd->vd_map);
	bus_dmamem_unmap(t, (caddr_t)vd->vd_desc, size);
	bus_dmamem_free(t, &vd->vd_seg, 1);
	bus_dmamap_destroy(t, vd->vd_map);
	free(vd, M_DEVBUF, 0);
}

void *
vdsk_io_get(void *xsc)
{
	struct vdsk_softc *sc = xsc;
	void *rv = sc; /* just has to be !NULL */
	int s;

	s = splbio();
	if (sc->sc_vio_state != VIO_ESTABLISHED ||
	    sc->sc_tx_cnt >= sc->sc_vd->vd_nentries)
		rv = NULL;
	else
		sc->sc_tx_cnt++;
	splx(s);

	return (rv);
}

void
vdsk_io_put(void *xsc, void *io)
{
	struct vdsk_softc *sc = xsc;
	int s;

#ifdef DIAGNOSTIC
	if (sc != io)
		panic("vsdk_io_put: unexpected io");
#endif

	s = splbio();
	sc->sc_tx_cnt--;
	splx(s);
}

void
vdsk_scsi_cmd(struct scsi_xfer *xs)
{
	struct vdsk_softc *sc = xs->sc_link->adapter_softc;
	int timeout, s;
	int desc;

	switch (xs->cmd->opcode) {
	case READ_BIG:
	case READ_COMMAND:
	case READ_12:
	case READ_16:
	case WRITE_BIG:
	case WRITE_COMMAND:
	case WRITE_12:
	case WRITE_16:
	case SYNCHRONIZE_CACHE:
		break;

	case INQUIRY:
		vdsk_scsi_inq(xs);
		return;
	case READ_CAPACITY:
		vdsk_scsi_capacity(xs);
		return;
	case READ_CAPACITY_16:
		vdsk_scsi_capacity16(xs);
		return;

	case TEST_UNIT_READY:
	case START_STOP:
	case PREVENT_ALLOW:
		vdsk_scsi_done(xs, XS_NOERROR);
		return;

	default:
		printf("%s cmd 0x%02x\n", __func__, xs->cmd->opcode);
	case MODE_SENSE:
	case MODE_SENSE_BIG:
	case REPORT_LUNS:
	case READ_TOC:
		vdsk_scsi_done(xs, XS_DRIVER_STUFFUP);
		return;
	}

	s = splbio();
	desc = vdsk_submit_cmd(xs);

	if (!ISSET(xs->flags, SCSI_POLL)) {
		splx(s);
		return;
	}

	timeout = 1000;
	do {
		if (sc->sc_vd->vd_desc[desc].hdr.dstate == VIO_DESC_DONE)
			break;

		delay(1000);
	} while(--timeout > 0);
	if (sc->sc_vd->vd_desc[desc].hdr.dstate == VIO_DESC_DONE) {
		vdsk_complete_cmd(xs, desc);
	} else {
		ldc_reset(&sc->sc_lc);
		vdsk_scsi_done(xs, XS_TIMEOUT);
	}
	splx(s);
}

int
vdsk_submit_cmd(struct scsi_xfer *xs)
{
	struct vdsk_softc *sc = xs->sc_link->adapter_softc;
	struct ldc_map *map = sc->sc_lm;
	struct vio_dring_msg dm;
	struct scsi_rw *rw;
	struct scsi_rw_big *rwb;
	struct scsi_rw_12 *rw12;
	struct scsi_rw_16 *rw16;
	u_int64_t lba;
	u_int32_t sector_count;
	uint8_t operation;
	vaddr_t va;
	paddr_t pa;
	psize_t nbytes;
	int len, ncookies;
	int desc;

	switch (xs->cmd->opcode) {
	case READ_BIG:
	case READ_COMMAND:
	case READ_12:
	case READ_16:
		operation = VD_OP_BREAD;
		break;

	case WRITE_BIG:
	case WRITE_COMMAND:
	case WRITE_12:
	case WRITE_16:
		operation = VD_OP_BWRITE;
		break;

	case SYNCHRONIZE_CACHE:
		operation = VD_OP_FLUSH;
		break;
	}

	/*
	 * READ/WRITE/SYNCHRONIZE commands. SYNCHRONIZE CACHE has same
	 * layout as 10-byte READ/WRITE commands.
	 */
	if (xs->cmdlen == 6) {
		rw = (struct scsi_rw *)xs->cmd;
		lba = _3btol(rw->addr) & (SRW_TOPADDR << 16 | 0xffff);
		sector_count = rw->length ? rw->length : 0x100;
	} else if (xs->cmdlen == 10) {
		rwb = (struct scsi_rw_big *)xs->cmd;
		lba = _4btol(rwb->addr);
		sector_count = _2btol(rwb->length);
	} else if (xs->cmdlen == 12) {
		rw12 = (struct scsi_rw_12 *)xs->cmd;
		lba = _4btol(rw12->addr);
		sector_count = _4btol(rw12->length);
	} else if (xs->cmdlen == 16) {
		rw16 = (struct scsi_rw_16 *)xs->cmd;
		lba = _8btol(rw16->addr);
		sector_count = _4btol(rw16->length);
	}

	desc = sc->sc_tx_prod;

	ncookies = 0;
	len = xs->datalen;
	va = (vaddr_t)xs->data;
	while (len > 0) {
		KASSERT(ncookies < MAXPHYS / PAGE_SIZE);
		pmap_extract(pmap_kernel(), va, &pa);
		while (map->lm_slot[map->lm_next].entry != 0) {
			map->lm_next++;
			map->lm_next &= (map->lm_nentries - 1);
		}
		map->lm_slot[map->lm_next].entry = (pa & LDC_MTE_RA_MASK);
		map->lm_slot[map->lm_next].entry |= LDC_MTE_CPR | LDC_MTE_CPW;
		map->lm_slot[map->lm_next].entry |= LDC_MTE_IOR | LDC_MTE_IOW;
		map->lm_slot[map->lm_next].entry |= LDC_MTE_R | LDC_MTE_W;
		map->lm_count++;

		nbytes = MIN(len, PAGE_SIZE - (pa & PAGE_MASK));

		sc->sc_vd->vd_desc[desc].cookie[ncookies].addr =
		    map->lm_next << PAGE_SHIFT | (pa & PAGE_MASK);
		sc->sc_vd->vd_desc[desc].cookie[ncookies].size = nbytes;

		sc->sc_vsd[desc].vsd_map_idx[ncookies] = map->lm_next;
		va += nbytes;
		len -= nbytes;
		ncookies++;
	}

	if (ISSET(xs->flags, SCSI_POLL) == 0)
		sc->sc_vd->vd_desc[desc].hdr.ack = 1;
	else
		sc->sc_vd->vd_desc[desc].hdr.ack = 0;
	sc->sc_vd->vd_desc[desc].operation = operation;
	sc->sc_vd->vd_desc[desc].slice = VD_SLICE_NONE;
	sc->sc_vd->vd_desc[desc].status = 0xffffffff;
	sc->sc_vd->vd_desc[desc].offset = lba;
	sc->sc_vd->vd_desc[desc].size = xs->datalen;
	sc->sc_vd->vd_desc[desc].ncookies = ncookies;
	membar(Sync);
	sc->sc_vd->vd_desc[desc].hdr.dstate = VIO_DESC_READY;

	sc->sc_vsd[desc].vsd_xs = xs;
	sc->sc_vsd[desc].vsd_ncookies = ncookies;

	sc->sc_tx_prod++;
	sc->sc_tx_prod &= (sc->sc_vd->vd_nentries - 1);

	bzero(&dm, sizeof(dm));
	dm.tag.type = VIO_TYPE_DATA;
	dm.tag.stype = VIO_SUBTYPE_INFO;
	dm.tag.stype_env = VIO_DRING_DATA;
	dm.tag.sid = sc->sc_local_sid;
	dm.seq_no = sc->sc_seq_no++;
	dm.dring_ident = sc->sc_dring_ident;
	dm.start_idx = dm.end_idx = desc;
	vdsk_sendmsg(sc, &dm, sizeof(dm));

	return desc;
}

void
vdsk_complete_cmd(struct scsi_xfer *xs, int desc)
{
	struct vdsk_softc *sc = xs->sc_link->adapter_softc;
	struct ldc_map *map = sc->sc_lm;
	int cookie, idx;
	int error;

	cookie = 0;
	while (cookie < sc->sc_vsd[desc].vsd_ncookies) {
		idx = sc->sc_vsd[desc].vsd_map_idx[cookie++];
		map->lm_slot[idx].entry = 0;
		map->lm_count--;
	}

	error = XS_NOERROR;
	if (sc->sc_vd->vd_desc[desc].status != 0)
		error = XS_DRIVER_STUFFUP;
	xs->resid = xs->datalen -
		sc->sc_vd->vd_desc[desc].size;
	vdsk_scsi_done(xs, error);

	sc->sc_vd->vd_desc[desc].hdr.dstate = VIO_DESC_FREE;
}

void
vdsk_scsi_inq(struct scsi_xfer *xs)
{
	struct scsi_inquiry *inq = (struct scsi_inquiry *)xs->cmd;

	if (ISSET(inq->flags, SI_EVPD))
		vdsk_scsi_done(xs, XS_DRIVER_STUFFUP);
	else
		vdsk_scsi_inquiry(xs);
}

void
vdsk_scsi_inquiry(struct scsi_xfer *xs)
{
	struct vdsk_softc *sc = xs->sc_link->adapter_softc;
	struct scsi_inquiry_data inq;
	char buf[5];

	bzero(&inq, sizeof(inq));

	switch (sc->sc_vd_mtype) {
	case VD_MEDIA_TYPE_CD:
	case VD_MEDIA_TYPE_DVD:
		inq.device = T_CDROM;
		break;

	case VD_MEDIA_TYPE_FIXED:
	default:
		inq.device = T_DIRECT;
		break;
	}

	inq.version = 0x05; /* SPC-3 */
	inq.response_format = 2;
	inq.additional_length = 32;
	inq.flags |= SID_CmdQue;
	bcopy("SUN     ", inq.vendor, sizeof(inq.vendor));
	bcopy("Virtual Disk    ", inq.product, sizeof(inq.product));
	snprintf(buf, sizeof(buf), "%u.%u ", sc->sc_major, sc->sc_minor);
	bcopy(buf, inq.revision, sizeof(inq.revision));

	bcopy(&inq, xs->data, MIN(sizeof(inq), xs->datalen));

	vdsk_scsi_done(xs, XS_NOERROR);
}

void
vdsk_scsi_capacity(struct scsi_xfer *xs)
{
	struct vdsk_softc *sc = xs->sc_link->adapter_softc;
	struct scsi_read_cap_data rcd;
	uint64_t capacity;

	bzero(&rcd, sizeof(rcd));

	capacity = sc->sc_vdisk_size - 1;
	if (capacity > 0xffffffff)
		capacity = 0xffffffff;

	_lto4b(capacity, rcd.addr);
	_lto4b(sc->sc_vdisk_block_size, rcd.length);

	bcopy(&rcd, xs->data, MIN(sizeof(rcd), xs->datalen));

	vdsk_scsi_done(xs, XS_NOERROR);
}

void
vdsk_scsi_capacity16(struct scsi_xfer *xs)
{
	struct vdsk_softc *sc = xs->sc_link->adapter_softc;
	struct scsi_read_cap_data_16 rcd;

	bzero(&rcd, sizeof(rcd));

	_lto8b(sc->sc_vdisk_size - 1, rcd.addr);
	_lto4b(sc->sc_vdisk_block_size, rcd.length);

	bcopy(&rcd, xs->data, MIN(sizeof(rcd), xs->datalen));

	vdsk_scsi_done(xs, XS_NOERROR);
}

void
vdsk_scsi_done(struct scsi_xfer *xs, int error)
{
	xs->error = error;

	scsi_done(xs);
}

int
vdsk_dev_probe(struct scsi_link *link)
{
	KASSERT(link->lun == 0);

	if (link->target == 0)
		return (0);

	return (ENODEV);
}

void
vdsk_dev_free(struct scsi_link *link)
{
	printf("%s\n", __func__);
}
@


1.46
log
@Rework cbus(4) interrupt support a bit.  Instead of merging devhandle and
devino into a pseudo-sysino, directly use the devino as the ihandle.  The
devhandle is stored in the cbus softc, and accessed through the bus space
tag.  This allows us to have more than 256 interrupts on a single cbus, and
avoids relying on the lower bits of the devhandle being zero.
@
text
@d1 1
a1 1
/*	$OpenBSD: vdsk.c,v 1.45 2014/09/21 14:52:37 kettenis Exp $	*/
d844 1
a844 1
		return (NULL);
d871 2
@


1.45
log
@Don't request an ACK from the server if we're polling.
@
text
@d1 1
a1 1
/*	$OpenBSD: vdsk.c,v 1.44 2014/09/21 14:15:01 kettenis Exp $	*/
a235 1
	uint64_t sysino[2];
d242 1
a242 6
	if (cbus_intr_map(ca->ca_node, ca->ca_tx_ino, &sysino[0]) ||
	    cbus_intr_map(ca->ca_node, ca->ca_rx_ino, &sysino[1])) {
		printf(": can't map interrupt\n");
		return;
	}
	printf(": ivec 0x%llx, 0x%llx", sysino[0], sysino[1]);
d251 4
a254 4
	sc->sc_tx_ih = bus_intr_establish(ca->ca_bustag, sysino[0], IPL_BIO,
	    0, vdsk_tx_intr, sc, sc->sc_dv.dv_xname);
	sc->sc_rx_ih = bus_intr_establish(ca->ca_bustag, sysino[1], IPL_BIO,
	    0, vdsk_rx_intr, sc, sc->sc_dv.dv_xname);
d320 2
a321 2
	cbus_intr_setenabled(sysino[0], INTR_ENABLED);
	cbus_intr_setenabled(sysino[1], INTR_ENABLED);
@


1.44
log
@Decouple polled commands from the interrupt handler.
@
text
@d1 1
a1 1
/*	$OpenBSD: vdsk.c,v 1.43 2014/09/16 20:23:42 kettenis Exp $	*/
d1090 4
a1093 1
	sc->sc_vd->vd_desc[desc].hdr.ack = 1;
@


1.43
log
@Check the right descriptor field when polling for completion.
@
text
@d1 1
a1 1
/*	$OpenBSD: vdsk.c,v 1.42 2014/09/16 15:59:35 kettenis Exp $	*/
d208 1
d706 1
a706 3
		struct ldc_map *map = sc->sc_lm;
		int cons, error;
		int cookie, idx;
d711 3
a713 16

			cookie = 0;
			while (cookie < sc->sc_vsd[cons].vsd_ncookies) {
				idx = sc->sc_vsd[cons].vsd_map_idx[cookie++];
				map->lm_slot[idx].entry = 0;
				map->lm_count--;
			}

			error = XS_NOERROR;
			if (sc->sc_vd->vd_desc[cons].status != 0)
				error = XS_DRIVER_STUFFUP;
			xs->resid = xs->datalen -
			    sc->sc_vd->vd_desc[cons].size;
			vdsk_scsi_done(xs, error);

			sc->sc_vd->vd_desc[cons++].hdr.dstate = VIO_DESC_FREE;
d985 1
a985 2
		if (vdsk_rx_intr(sc) &&
		    sc->sc_vd->vd_desc[desc].hdr.dstate == VIO_DESC_FREE)
d990 6
d1117 25
@


1.42
log
@Split out command submission code into its own function.
@
text
@d1 1
a1 1
/*	$OpenBSD: vdsk.c,v 1.41 2014/09/15 20:34:15 kettenis Exp $	*/
d1000 1
a1000 1
		    sc->sc_vd->vd_desc[desc].status == VIO_DESC_FREE)
@


1.41
log
@Fix logic error; we're out of IOs if we're not connected to the virtual disk
server *or* if we've filled all the entries on the ring.
@
text
@d1 1
a1 1
/*	$OpenBSD: vdsk.c,v 1.40 2014/09/15 08:16:21 kettenis Exp $	*/
d203 1
a203 1
void *	vdsk_io_get(void *);
d207 1
d660 1
a660 1
			vdsk_scsi_cmd(sc->sc_vsd[sc->sc_tx_prod].vsd_xs);
d947 3
a949 7
	struct scsi_rw *rw;
	struct scsi_rw_big *rwb;
	struct scsi_rw_12 *rw12;
	struct scsi_rw_16 *rw16;
	u_int64_t lba;
	u_int32_t sector_count;
	uint8_t operation;
a955 2
		operation = VD_OP_BREAD;
		break;
a959 3
		operation = VD_OP_BWRITE;
		break;

a960 1
		operation = VD_OP_FLUSH;
d989 58
a1068 12
{
	struct vdsk_softc *sc = xs->sc_link->adapter_softc;
	struct ldc_map *map = sc->sc_lm;
	struct vio_dring_msg dm;
	vaddr_t va;
	paddr_t pa;
	psize_t nbytes;
	int len, ncookies;
	int desc, s;
	int timeout;

	s = splbio();
d1125 1
a1125 15
	if (!ISSET(xs->flags, SCSI_POLL)) {
		splx(s);
		return;
	}

	timeout = 1000;
	do {
		if (vdsk_rx_intr(sc) &&
		    sc->sc_vd->vd_desc[desc].status == VIO_DESC_FREE)
			break;

		delay(1000);
	} while(--timeout > 0);
	splx(s);
}
@


1.40
log
@Call ldc_send_unreliable() insteaf of duplicating the code to send an ldc
packet.  Rename vio_sendmsg() to vnet_sendmsg().
@
text
@d1 1
a1 1
/*	$OpenBSD: vdsk.c,v 1.39 2014/07/12 18:44:43 tedu Exp $	*/
d917 1
a917 1
	if (sc->sc_vio_state != VIO_ESTABLISHED &&
@


1.39
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: vdsk.c,v 1.38 2014/05/10 11:49:31 kettenis Exp $	*/
a762 2
	struct ldc_pkt *lp;
	uint64_t tx_head, tx_tail, tx_state;
d765 3
a767 18
	err = hv_ldc_tx_get_state(lc->lc_id, &tx_head, &tx_tail, &tx_state);
	if (err != H_EOK)
		return;

	lp = (struct ldc_pkt *)(lc->lc_txq->lq_va + tx_tail);
	bzero(lp, sizeof(struct ldc_pkt));
	lp->type = LDC_DATA;
	lp->stype = LDC_INFO;
	KASSERT((len & ~LDC_LEN_MASK) == 0);
	lp->env = len | LDC_FRAG_STOP | LDC_FRAG_START;
	lp->seqid = lc->lc_tx_seqid++;
	bcopy(msg, &lp->major, len);

	tx_tail += sizeof(*lp);
	tx_tail &= ((lc->lc_txq->lq_nentries * sizeof(*lp)) - 1);
	err = hv_ldc_tx_set_qtail(lc->lc_id, tx_tail);
	if (err != H_EOK)
		printf("%s: hv_ldc_tx_set_qtail: %d\n", __func__, err);
@


1.38
log
@Some straightforward format string fixes.  Also, print both the tx and rx
interrupt vector numbers instead of printing rx; pointed out by florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vdsk.c,v 1.37 2014/04/03 09:15:06 mpi Exp $	*/
d923 1
a923 1
	free(vd, M_DEVBUF);
@


1.37
log
@Use <uvm/uvm_extern.h> if it's enough.
@
text
@d1 1
a1 1
/*	$OpenBSD: vdsk.c,v 1.36 2014/01/22 23:57:59 kettenis Exp $	*/
d246 1
a246 1
	printf(": ivec 0x%lx, 0x%lx", sysino[0], sysino[1]);
@


1.36
log
@Do not assume the data buffers handed down to us from the SCSI midlayer are
page aligned.
@
text
@d1 1
a1 1
/*	$OpenBSD: vdsk.c,v 1.35 2014/01/22 22:24:12 kettenis Exp $	*/
d27 1
a27 1
#include <uvm/uvm.h>
@


1.35
log
@Only kick the iopool if we've just established a new connection to the server.
@
text
@d1 1
a1 1
/*	$OpenBSD: vdsk.c,v 1.34 2014/01/22 21:35:58 dlg Exp $	*/
d123 1
a706 1
		int len;
d713 1
a713 2
			len = xs->datalen;
			while (len > 0) {
a716 1
				len -= PAGE_SIZE;
d1043 1
d1055 1
d1067 2
d1071 1
a1071 2
		sc->sc_vd->vd_desc[desc].cookie[ncookies].size =
		    min(len, PAGE_SIZE);
d1074 2
a1075 2
		va += PAGE_SIZE;
		len -= PAGE_SIZE;
d1090 1
@


1.34
log
@this gets rid of NO_CCB in vdsk. it considers space on the tx ring
as the resource the iopool is managing, but gated by the availability
of the service domain. it takes advantage of the newly available
scsi_iopool_run() interface to restart io when the domain providing
a disk comes back.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vdsk.c,v 1.33 2013/05/12 19:33:01 krw Exp $	*/
d659 2
a667 3

	if (sc->sc_vio_state == VIO_ESTABLISHED)
		scsi_iopool_run(&sc->sc_iopool);
@


1.33
log
@Handle big (a.k.a. >2TB) disks by adding logic to handle the 12 and 16
byte scsi read/write commands.

Issue pointed out by John Morrissey via bugs@@. Problem reproduced and
fix tested by sf@@ on vioblk.

ok sf@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vdsk.c,v 1.32 2012/11/21 23:02:37 kettenis Exp $	*/
d161 1
d202 3
d347 2
d360 1
d666 3
a730 1
			sc->sc_tx_cnt--;
d929 34
a1050 8
	if (sc->sc_vio_state != VIO_ESTABLISHED ||
	    sc->sc_tx_cnt >= sc->sc_vd->vd_nentries) {
		xs->error = XS_NO_CCB;
		scsi_done(xs);
		splx(s);
		return;
	}

a1092 1
	sc->sc_tx_cnt++;
@


1.32
log
@Atempting to eject a CD-ROM makes the SCSI midlayer generate a READ_TOC
command.  Silently fail that command instead of spamming the console.
@
text
@d1 1
a1 1
/*	$OpenBSD: vdsk.c,v 1.31 2012/11/21 21:20:13 kettenis Exp $	*/
d925 2
d934 2
d940 2
d975 4
d983 1
a983 1
	} else {
d987 8
@


1.31
log
@Try to negotiate version 1.1 of the vDisk protocol such that we can get
the vdisk media type and fake a CD-ROM drive.
@
text
@d1 1
a1 1
/*	$OpenBSD: vdsk.c,v 1.30 2012/10/26 20:57:08 kettenis Exp $	*/
d30 1
d964 1
@


1.30
log
@Turns out that for devices that attach to cbus(4), it is better to disable
interrupts up-front and explicitly enabling them later than the other way
around.
@
text
@d1 1
a1 1
/*	$OpenBSD: vdsk.c,v 1.29 2011/07/17 22:46:47 matthew Exp $	*/
d114 1
a114 1
 * For now, we only support vDisk 1.0.
d117 1
a117 1
#define VDSK_MINOR	0
d165 1
d566 4
d1087 12
a1098 1
	inq.device = T_DIRECT;
@


1.29
log
@Backout a bunch of my SCSI commits from c2k11.  At least one of these
is causing problems when trying to boot sparc64 from an isp(4).

Verified to fix the sparc64/isp(4) regression by krw@@; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vdsk.c,v 1.28 2011/07/08 22:09:27 matthew Exp $	*/
d316 3
@


1.28
log
@First batch of converting SCSI HBAs from setting saa_targets and
saa_luns instead of adapter_buswidth and luns in the prototype link.

ok dlg@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vdsk.c,v 1.27 2011/01/01 20:49:53 kettenis Exp $	*/
d345 2
a351 2
	saa.saa_targets = 2;
	saa.saa_luns = 1; /* XXX slices should be presented as luns? */
@


1.27
log
@Corretctly return 0xffffffff for the returned LBA if the disk is too large
for the READ CAPACITY command.
@
text
@d1 1
a1 1
/*	$OpenBSD: vdsk.c,v 1.26 2011/01/01 20:32:18 kettenis Exp $	*/
a344 2
	sc->sc_link.adapter_buswidth = 2;
	sc->sc_link.luns = 1; /* XXX slices should be presented as luns? */
d350 2
@


1.26
log
@Implement READ CAPACITY (16).
@
text
@d1 1
a1 1
/*	$OpenBSD: vdsk.c,v 1.25 2010/10/12 00:53:32 krw Exp $	*/
d1103 1
a1103 1
	capacity = sc->sc_vdisk_size;
d1107 1
a1107 1
	_lto4b(capacity - 1, rcd.addr);
@


1.25
log
@Force openings to 1 for devices that can't do tagged i/o, i.e. more
than 1 i/o active at once.  This reduces the chances that concurrent
i/o's for such devices will confuse the device or the adapter code.
It also eliminates a reason for adapter code to maintain its own
queues.

Tweak all drivers that fake INQUIRY results to set the SID_CmdQue
flag, thus continuing to claim to be able to do tagged i/o.

Positive feedback from matthew@@ and marco@@ for an earlier version.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vdsk.c,v 1.24 2010/06/28 18:31:01 krw Exp $	*/
d3 1
a3 1
 * Copyright (c) 2009 Mark Kettenis
d206 1
d940 3
d1108 16
@


1.24
log
@Remove all adapter-specific 'struct scsi_device's. They are never used. First
step in elminating 'struct scsi_device' entirely.

Spotted and initial diff from matthew@@.

ok matthew@@ dlg@@ deraadt@@ marco@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vdsk.c,v 1.23 2010/06/15 04:11:34 dlg Exp $	*/
d1079 1
@


1.23
log
@dont pass the dev_t from the scsi device drivers into the midlayer for
ioctl requests, and dont pass the proc pointers around for any ioctl
requests in scsi land at all. neither were used, so trim the fat.

ok krw@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vdsk.c,v 1.22 2010/05/22 19:55:42 kettenis Exp $	*/
a177 4
struct scsi_device vdsk_device = {
	NULL, NULL, NULL, NULL
};

a341 1
	sc->sc_link.device = &vdsk_device;
@


1.22
log
@Blank lines at the start of a function are so .Nx.
@
text
@d1 1
a1 1
/*	$OpenBSD: vdsk.c,v 1.21 2010/05/20 16:31:03 thib Exp $	*/
a205 1
int	vdsk_ioctl(struct scsi_link *, u_long, caddr_t, int, struct proc *);
a344 1
	sc->sc_switch.ioctl = vdsk_ioctl;
a1137 8
}

int
vdsk_ioctl(struct scsi_link *link, u_long cmd, caddr_t addr, int flags,
    struct proc *p)
{
	printf("%s\n", __func__);
	return (ENOTTY);
@


1.21
log
@remove unused variable. fallout from previous.
ok phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vdsk.c,v 1.20 2010/05/20 00:55:17 krw Exp $	*/
a1119 1

@


1.20
log
@New scsi code seems to be stable. Pluck previously identified
low-hanging splbio/splx pairs that are no longer needed and see if
this reveals any hidden scsi flaws.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vdsk.c,v 1.19 2010/03/24 06:55:28 dlg Exp $	*/
a1119 1
	int s;
@


1.19
log
@vdsk_scsi_cmd doesnt need to return now, so fix some of its scsi command
emulation to not return values either.

i think this is right, but cant test just yet.

found by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vdsk.c,v 1.18 2010/03/23 01:57:19 krw Exp $	*/
a1123 1
	s = splbio();
a1124 1
	splx(s);
@


1.18
log
@Change the scsi_cmd function member of scsi_adapter from int to
void. Use XS_NO_CCB error in the scsi command (xs) to report the
NO_CCB condition. Eliminates all SUCCESSFULLY_QUEUED and COMPLETE
confusion and untangles the midlayer from the adapter a bit more.

Eyes and some fixes by miod@@

There may be some compile issues on little used (i.e. I don't have
any) drivers but the change is mechanical and thus easy to remedy.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vdsk.c,v 1.17 2010/01/09 23:15:06 krw Exp $	*/
d208 4
a211 4
int	vdsk_scsi_inq(struct scsi_xfer *);
int	vdsk_scsi_inquiry(struct scsi_xfer *);
int	vdsk_scsi_capacity(struct scsi_xfer *);
int	vdsk_scsi_done(struct scsi_xfer *, int);
d941 2
a942 1
		return (vdsk_scsi_inq(xs));
d944 2
a945 1
		return (vdsk_scsi_capacity(xs));
d950 2
a951 1
		return (vdsk_scsi_done(xs, XS_NOERROR));
d958 2
a959 1
		return (vdsk_scsi_done(xs, XS_DRIVER_STUFFUP));
d1062 1
a1062 1
int
d1068 3
a1070 3
		return (vdsk_scsi_done(xs, XS_DRIVER_STUFFUP));

	return (vdsk_scsi_inquiry(xs));
d1073 1
a1073 1
int
d1093 1
a1093 1
	return (vdsk_scsi_done(xs, XS_NOERROR));
d1096 1
a1096 1
int
d1114 1
a1114 1
	return (vdsk_scsi_done(xs, XS_NOERROR));
d1117 1
a1117 1
int
a1126 1
	return (COMPLETE);
@


1.17
log
@Zap all setting of ITSDONE in drivers that don't look at it. Nobody
else cares so it's just noise. Drivers that actually look at ITSDONE
are unchanged.

ok marco@@ (for his files) dlg@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vdsk.c,v 1.16 2009/12/12 13:24:58 kettenis Exp $	*/
d203 1
a203 1
int	vdsk_scsi_cmd(struct scsi_xfer *);
d917 1
a917 1
int
d981 2
d984 1
a984 1
		return (NO_CCB);
d1043 1
a1043 1
		return (SUCCESSFULLY_QUEUED);
a1054 2

	return (COMPLETE);
@


1.16
log
@Add missing splbio() protection when sending commands to the vDisk server.
@
text
@d1 1
a1 1
/*	$OpenBSD: vdsk.c,v 1.15 2009/12/09 22:39:52 kettenis Exp $	*/
a1118 1
	xs->flags |= ITSDONE;
@


1.15
log
@Resubmit any pending SCSI commands when we sucessfully (re)connect to
a vDisk server.  This makes OpenBSD running in a guest domain survive
a reboot of a control domain or service domain.
@
text
@d1 1
a1 1
/*	$OpenBSD: vdsk.c,v 1.14 2009/12/09 18:41:14 kettenis Exp $	*/
d978 1
d980 2
a981 1
	    sc->sc_tx_cnt >= sc->sc_vd->vd_nentries)
d983 1
d1039 2
a1040 1
	if (!ISSET(xs->flags, SCSI_POLL))
d1042 1
a1043 1
	s = splbio();
@


1.14
log
@Don't try to shove I/O down the LDC if we're disconnected from the virtual
disk server.
@
text
@d1 1
a1 1
/*	$OpenBSD: vdsk.c,v 1.13 2009/12/08 20:37:58 kettenis Exp $	*/
a416 1
		sc->sc_tx_cnt = sc->sc_tx_prod = sc->sc_tx_cons = 0;
d623 3
d632 17
d650 1
a738 1
	sc->sc_tx_cnt = sc->sc_tx_prod = sc->sc_tx_cons = 0;
a1146 1

@


1.13
log
@Base the revision string in the INQUIRY info on the version of the VIO protocol
used by the virtual disk server.
@
text
@d1 1
a1 1
/*	$OpenBSD: vdsk.c,v 1.12 2009/05/12 20:20:35 kettenis Exp $	*/
d959 2
a960 1
	if (sc->sc_tx_cnt >= sc->sc_vd->vd_nentries)
@


1.12
log
@Make reserved member of protocol struct start with underscore.
@
text
@d1 1
a1 1
/*	$OpenBSD: vdsk.c,v 1.11 2009/05/10 12:59:12 kettenis Exp $	*/
d145 3
d536 2
d1048 1
d1050 1
d1060 2
a1061 1
	bcopy("1.0 ", inq.revision, sizeof(inq.revision));
@


1.11
log
@Remove a dead variable and some unneeded returns.
@
text
@d1 1
a1 1
/*	$OpenBSD: vdsk.c,v 1.10 2009/02/20 17:55:28 kettenis Exp $	*/
d56 1
a56 1
	uint64_t		reserved2[2];
@


1.10
log
@Tweak debug printf.
@
text
@d1 1
a1 1
/*	$OpenBSD: vdsk.c,v 1.9 2009/02/16 21:19:06 miod Exp $	*/
a367 1
	return;
a402 1
	uint64_t *msg;
a437 1
	msg = (uint64_t *)(lc->lc_rxq->lq_va + rx_head);
@


1.9
log
@Extend the scsi_adapter minphys() callback to take a struct scsi_link *
as additional argument. This will allow intermediate layers between
scsi devices such as sd and scsi host adapters to take appropriate
action if necessary.
@
text
@d1 1
a1 1
/*	$OpenBSD: vdsk.c,v 1.8 2009/01/17 22:18:14 kettenis Exp $	*/
d754 1
a754 1
		printf("hv_ldc_tx_set_qtail: %d\n", err);
@


1.8
log
@Clean things up a bit, and be a bit more fussy about the proper sequence in
which we should receive messages from our peer.
@
text
@d1 1
a1 1
/*	$OpenBSD: vdsk.c,v 1.7 2009/01/17 20:36:42 kettenis Exp $	*/
d340 1
a340 1
	sc->sc_switch.scsi_minphys = minphys;
@


1.7
log
@Return NO_CCB if we run out of descriptors.

Suggested by krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vdsk.c,v 1.6 2009/01/17 17:11:10 kettenis Exp $	*/
d134 10
a143 2
	uint8_t		sc_vio_state;
#define VIO_ESTABLISHED	8
d191 2
a192 2
void	vdsk_reset(struct ldc_conn *);
void	vdsk_start(struct ldc_conn *);
d261 2
a262 2
	lc->lc_reset = vdsk_reset;
	lc->lc_start = vdsk_start;
a440 10
#if 0
{
	int i;

	printf("%s: rx intr, head %lx, tail %lx\n", sc->sc_dv.dv_xname,
	    rx_head, rx_tail);
	for (i = 0; i < 8; i++)
		printf("word %d: 0x%016lx\n", i, msg[i]);
}
#endif
d532 5
a536 1
		vdsk_send_attr_info(sc);
d543 3
d560 5
d567 2
a568 1
		vdsk_send_dring_reg(sc);
d575 4
d593 4
d601 1
a601 1
		vdsk_send_rdx(sc);
d608 3
d623 5
a627 3

		/* Link is up! */
		sc->sc_vio_state = VIO_ESTABLISHED;
d713 1
a713 1
vdsk_reset(struct ldc_conn *lc)
d722 1
a722 1
vdsk_start(struct ldc_conn *lc)
d774 2
d792 2
d814 2
d829 2
a970 3
		/* Don't take slot 0; it's used by our descriptor ring. */
		if (map->lm_next == 0)
			map->lm_next++;
@


1.6
log
@Implement SYNCHRONIZE CACHE and make SCSI_POLL work while we're there.
@
text
@d1 1
a1 1
/*	$OpenBSD: vdsk.c,v 1.5 2009/01/16 23:57:45 kettenis Exp $	*/
d925 2
a926 1
	KASSERT(sc->sc_tx_cnt < sc->sc_vd->vd_nentries);
@


1.5
log
@Set the number of openings to the number of ring descriptors minus one.  For
some reason, setting it to the number of descriptors causes ring overruns.
@
text
@d1 1
a1 1
/*	$OpenBSD: vdsk.c,v 1.4 2009/01/16 17:50:55 kettenis Exp $	*/
d883 4
d922 2
a923 1
	int desc;
d970 2
a971 2
	desc++;
	desc &= (sc->sc_vd->vd_nentries - 1);
d981 1
a981 2
	dm.start_idx = sc->sc_tx_prod;
	dm.end_idx = sc->sc_tx_prod;
d984 15
a998 1
	sc->sc_tx_prod = desc;
a999 2

	return (SUCCESSFULLY_QUEUED);
@


1.4
log
@Make transfers bigger than PAGE_SIZE work.
@
text
@d1 1
a1 1
/*	$OpenBSD: vdsk.c,v 1.3 2009/01/16 16:59:58 kettenis Exp $	*/
d343 1
a343 1
	sc->sc_link.openings = 32;
a636 2
	struct vio_dring_msg *dm = (struct vio_dring_msg *)tag;

a679 10
	{
		uint64_t *msg = (uint64_t *)tag;
		int i, idx;
		for (i = 0; i < 7; i++)
			printf("word %d: %llx\n", i + 1, msg[i]);
		idx = dm->start_idx;
		printf("state 0x%02x\n", sc->sc_vd->vd_desc[idx].hdr.dstate);
		printf("status 0x%04x\n", sc->sc_vd->vd_desc[idx].status);
		printf("size 0x%04x\n", sc->sc_vd->vd_desc[idx].size);
	}
d919 2
@


1.3
log
@Remove bogus KASSERT.
@
text
@d1 1
a1 1
/*	$OpenBSD: vdsk.c,v 1.2 2009/01/12 23:05:07 kettenis Exp $	*/
d637 2
d682 10
a691 3
		printf("state 0x%02x\n", sc->sc_vd->vd_desc[0].hdr.dstate);
		printf("status 0x%04x\n", sc->sc_vd->vd_desc[0].status);
		printf("size 0x%04x\n", sc->sc_vd->vd_desc[0].size);
d960 1
d969 1
a969 1
	sc->sc_vd->vd_desc[desc].ncookies = 1;
@


1.2
log
@A storage driver should be DV_DULL, not DV_IFNET.  Pointed out by dlg@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: vdsk.c,v 1.1 2009/01/12 20:11:13 kettenis Exp $	*/
a1054 1
	KASSERT(link->scsibus == 0);
@


1.1
log
@Initial stab at a driver for virtual disks found on sun4v logical domains.
Still needs some work, but reading from and writing to a disk image works.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d164 1
a164 1
	NULL, "vdsk", DV_IFNET
@

