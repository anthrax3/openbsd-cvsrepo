head	1.28;
access;
symbols
	OPENBSD_6_2:1.28.0.4
	OPENBSD_6_2_BASE:1.28
	OPENBSD_6_1:1.28.0.6
	OPENBSD_6_1_BASE:1.28
	OPENBSD_6_0:1.28.0.2
	OPENBSD_6_0_BASE:1.28
	OPENBSD_5_9:1.25.0.8
	OPENBSD_5_9_BASE:1.25
	OPENBSD_5_8:1.25.0.10
	OPENBSD_5_8_BASE:1.25
	OPENBSD_5_7:1.25.0.2
	OPENBSD_5_7_BASE:1.25
	OPENBSD_5_6:1.25.0.6
	OPENBSD_5_6_BASE:1.25
	OPENBSD_5_5:1.25.0.4
	OPENBSD_5_5_BASE:1.25
	OPENBSD_5_4:1.23.0.10
	OPENBSD_5_4_BASE:1.23
	OPENBSD_5_3:1.23.0.8
	OPENBSD_5_3_BASE:1.23
	OPENBSD_5_2:1.23.0.6
	OPENBSD_5_2_BASE:1.23
	OPENBSD_5_1_BASE:1.23
	OPENBSD_5_1:1.23.0.4
	OPENBSD_5_0:1.23.0.2
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.22.0.8
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.22.0.6
	OPENBSD_4_8_BASE:1.22
	OPENBSD_4_7:1.22.0.2
	OPENBSD_4_7_BASE:1.22
	OPENBSD_4_6:1.22.0.4
	OPENBSD_4_6_BASE:1.22
	OPENBSD_4_5:1.21.0.2
	OPENBSD_4_5_BASE:1.21
	OPENBSD_4_4:1.17.0.4
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.17.0.2
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.16.0.4
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.16.0.2
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.13.0.2
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.8.0.6
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.4
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.2
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.5.0.6
	OPENBSD_3_6_BASE:1.5
	SMP_SYNC_A:1.5
	SMP_SYNC_B:1.5
	OPENBSD_3_5:1.5.0.2
	OPENBSD_3_5_BASE:1.5
	SMP:1.4.0.2
	OPENBSD_3_4:1.3.0.2
	OPENBSD_3_4_BASE:1.3;
locks; strict;
comment	@ * @;


1.28
date	2016.03.29.22.06.50;	author kettenis;	state Exp;
branches;
next	1.27;
commitid	U0onRdUViHh8mR03;

1.27
date	2016.03.15.20.50.22;	author krw;	state Exp;
branches;
next	1.26;
commitid	JZR2bOwahEjnBJaG;

1.26
date	2016.03.07.13.21.51;	author naddy;	state Exp;
branches;
next	1.25;
commitid	EDvRPKRZUDEEb6oR;

1.25
date	2013.10.21.10.36.19;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2013.08.15.18.29.56;	author kettenis;	state Exp;
branches;
next	1.23;

1.23
date	2011.04.07.15.30.16;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2009.06.03.20.17.48;	author kettenis;	state Exp;
branches;
next	1.21;

1.21
date	2009.01.19.20.21.33;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2009.01.12.17.14.48;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2009.01.11.15.27.32;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2008.12.27.17.23.01;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2007.11.10.15.17.16;	author jsing;	state Exp;
branches;
next	1.16;

1.16
date	2006.12.03.16.41.58;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2006.12.02.11.25.09;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2006.11.29.12.13.54;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2006.07.01.16.15.59;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2006.06.30.21.38.19;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2006.06.29.17.54.32;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2006.03.12.22.53.02;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2006.03.12.22.17.50;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2005.03.15.18.40.15;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2005.03.07.16.44.52;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2004.11.29.22.07.40;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2004.02.29.21.24.37;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2003.10.05.18.34.43;	author miod;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2003.06.28.14.26.17;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2003.06.17.17.35.40;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2003.06.16.20.46.10;	author miod;	state Exp;
branches;
next	;

1.4.2.1
date	2004.06.05.23.10.59;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.28
log
@Some sparc64 pci frame buffers incorrectly have the `depth' property
spelled `depth ' with a trailing space.

From miod@@
@
text
@/*	$OpenBSD: fb.c,v 1.27 2016/03/15 20:50:22 krw Exp $	*/
/*	$NetBSD: fb.c,v 1.23 1997/07/07 23:30:22 pk Exp $ */

/*
 * Copyright (c) 2002, 2004, 2008  Miodrag Vallat.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
 *
 * All advertising materials mentioning features or use of this software
 * must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Lawrence Berkeley Laboratory.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)fb.c	8.1 (Berkeley) 6/11/93
 */

/*
 * Common wsdisplay framebuffer drivers helpers.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/proc.h>
#include <sys/conf.h>

#include <machine/autoconf.h>
#include <machine/conf.h>
#include <machine/openfirm.h>

#include <dev/wscons/wsdisplayvar.h>
#include <dev/rasops/rasops.h>
#include <machine/fbvar.h>

#include "wsdisplay.h"

/*
 * Sun specific color indexes.
 * Black is not really 7, but rather ~0; to fit within the 8 ANSI color
 * palette we are using on console, we pick (~0) & 0x07 instead.
 * This essentially swaps WSCOL_BLACK and WSCOL_WHITE.
 */
#define	WSCOL_SUN_WHITE		0
#define	WSCOL_SUN_BLACK		7

/*
 * emergency unblank code
 * XXX should be somewhat moved to wscons MI code
 */

void (*fb_burner)(void *, u_int, u_int);
void *fb_cookie;

void
fb_unblank(void)
{
	if (fb_burner != NULL)
		(*fb_burner)(fb_cookie, 1, 0);
}

#if NWSDISPLAY > 0

static int a2int(char *, int);
int	fb_get_console_metrics(int *, int *, int *, int *);
void	fb_initwsd(struct sunfb *);
void	fb_updatecursor(struct rasops_info *);

int	fb_alloc_screen(void *, const struct wsscreen_descr *, void **,
	    int *, int *, long *);
void	fb_free_screen(void *, void *);
int	fb_show_screen(void *, void *, int, void (*)(void *, int, int),
	    void *);
int	fb_load_font(void *, void *, struct wsdisplay_font *);
int	fb_list_font(void *, struct wsdisplay_font *);

void
fb_setsize(struct sunfb *sf, int def_depth, int def_width, int def_height,
    int node, int unused)
{
	int def_linebytes;

	/*
	 * Some PCI devices lack the `depth' property, but have a `depth '
	 * property (with a trailing space) instead.
	 */
	sf->sf_depth = getpropint(node, "depth",
	    getpropint(node, "depth ", def_depth));
	sf->sf_width = getpropint(node, "width", def_width);
	sf->sf_height = getpropint(node, "height", def_height);

	def_linebytes =
	    roundup(sf->sf_width, sf->sf_depth) * sf->sf_depth / 8;
	sf->sf_linebytes = getpropint(node, "linebytes", def_linebytes);

	/*
	 * XXX If we are configuring a board in a wider depth level
	 * than the mode it is currently operating in, the PROM will
	 * return a linebytes property tied to the current depth value,
	 * which is NOT what we are relying upon!
	 */
	if (sf->sf_linebytes < (sf->sf_width * sf->sf_depth) / 8)
		sf->sf_linebytes = def_linebytes;

	sf->sf_fbsize = sf->sf_height * sf->sf_linebytes;
}

static int
a2int(char *cp, int deflt)
{
	int i = 0;

	if (*cp == '\0')
		return (deflt);
	while (*cp != '\0')
		i = i * 10 + *cp++ - '0';
	return (i);
}

/* setup the embedded wsscreen_descr structure from rasops settings */
void
fb_initwsd(struct sunfb *sf)
{
	strlcpy(sf->sf_wsd.name, "std", sizeof(sf->sf_wsd.name));
	sf->sf_wsd.capabilities = sf->sf_ro.ri_caps;
	sf->sf_wsd.nrows = sf->sf_ro.ri_rows;
	sf->sf_wsd.ncols = sf->sf_ro.ri_cols;
	sf->sf_wsd.textops = &sf->sf_ro.ri_ops;
}

void
fb_updatecursor(struct rasops_info *ri)
{
	struct sunfb *sf = (struct sunfb *)ri->ri_hw;

	if (sf->sf_crowp != NULL)
		*sf->sf_crowp = ri->ri_crow;
	if (sf->sf_ccolp != NULL)
		*sf->sf_ccolp = ri->ri_ccol;
}

void
fbwscons_init(struct sunfb *sf, int flags, int isconsole)
{
	struct rasops_info *ri = &sf->sf_ro;
	int cols, rows, fw, fh, wt, wl;

	/* ri_hw and ri_bits must have already been setup by caller */
	ri->ri_flg = RI_FULLCLEAR | flags;
	ri->ri_depth = sf->sf_depth;
	ri->ri_stride = sf->sf_linebytes;
	ri->ri_width = sf->sf_width;
	ri->ri_height = sf->sf_height;

	rows = a2int(getpropstring(optionsnode, "screen-#rows"), 34);
	cols = a2int(getpropstring(optionsnode, "screen-#columns"), 80);

	/*
	 * If the framebuffer width is under 960 pixels, rasops will
	 * switch from the 12x22 font to the more adequate 8x16 font
	 * here.
	 * If we are the console device, we need to adjust two things:
	 * - the display row should be overrided from the current PROM
	 *   metrics, since it will not match the PROM reality anymore.
	 * - the screen needs to be cleared.
	 *
	 * However, to accommodate laptops with specific small fonts,
	 * it is necessary to compare the resolution with the actual
	 * font metrics.
	 */

	if (isconsole) {
		if (fb_get_console_metrics(&fw, &fh, &wt, &wl) != 0) {
			/*
			 * Assume a 12x22 prom font and a centered
			 * 80x34 console window.
			 */
			fw = 12; fh = 22;
			wt = wl = 0;
		} else {
			/*
			 * Make sure window-top and window-left
			 * values are consistent with the font metrics.
			 */
			if (wt <= 0 || wt > sf->sf_height - rows * fh ||
			    wl <= 0 || wl > sf->sf_width - cols * fw)
				wt = wl = 0;
		}
		if (wt == 0 /* || wl == 0 */) {
			ri->ri_flg |= RI_CENTER;

			/*
			 * Since the console window might not be
			 * centered (e.g. on a 1280x1024 vigra
			 * VS-12 frame buffer), have rasops
			 * clear the margins even if the screen is
			 * not cleared.
			 */
			ri->ri_flg |= RI_CLEARMARGINS;
		}

		if (ri->ri_wsfcookie != 0) {
			/* driver handles font issues. do nothing. */
		} else {
			/*
			 * If the PROM uses a different font than the
			 * one we are expecting it to use, or if the
			 * display is shorter than 960 pixels wide,
			 * we'll force a screen clear.
			 */
			if (fw != 12 || sf->sf_width < 12 * 80)
				ri->ri_flg |= RI_CLEAR | RI_CENTER;
		}
	} else {
		ri->ri_flg |= RI_CLEAR | RI_CENTER;
	}

	/* ifb(4) doesn't set ri_bits at the moment */
	if (ri->ri_bits == NULL)
		ri->ri_flg &= ~(RI_CLEAR | RI_CLEARMARGINS);

	rasops_init(ri, rows, cols);

	/*
	 * If this is the console display and there is no font change,
	 * adjust our terminal window to the position of the PROM
	 * window - in case it is not exactly centered.
	 */
	if ((ri->ri_flg & RI_CENTER) == 0) {
		/* code above made sure wt and wl are initialized */
		ri->ri_bits += wt * ri->ri_stride;
		if (ri->ri_depth >= 8)	/* for 15bpp to compute ok */
			ri->ri_bits += wl * ri->ri_pelbytes;
		else
			ri->ri_bits += (wl * ri->ri_depth) >> 3;

		ri->ri_xorigin = wl;
		ri->ri_yorigin = wt;
	}

	if (sf->sf_depth == 8) {
		/*
		 * If we are running with an indexed palette, compensate
		 * the swap of black and white through ri_devcmap.
		 */
		ri->ri_devcmap[WSCOL_SUN_BLACK] = 0;
		ri->ri_devcmap[WSCOL_SUN_WHITE] = 0xffffffff;
	} else if (sf->sf_depth > 8) {
		/*
		 * If we are running on a direct color frame buffer,
		 * make the ``normal'' white the same as the highlighted
		 * white.
		 */
		ri->ri_devcmap[WSCOL_WHITE] = ri->ri_devcmap[WSCOL_WHITE + 8];
	}
}

void
fbwscons_console_init(struct sunfb *sf, int row)
{
	struct rasops_info *ri = &sf->sf_ro;
	void *cookie;
	long defattr;

	if (romgetcursoraddr(&sf->sf_crowp, &sf->sf_ccolp))
		sf->sf_ccolp = sf->sf_crowp = NULL;
	if (sf->sf_ccolp != NULL)
		ri->ri_ccol = *sf->sf_ccolp;

	if (ri->ri_flg & RI_CLEAR) {
		/*
		 * If we have cleared the screen, this is because either
		 * we are not the console display, or the font has been
		 * changed.
		 * In this case, choose not to keep pointers to the PROM
		 * cursor position, as the values are likely to be inaccurate
		 * upon shutdown...
		 */
		sf->sf_crowp = sf->sf_ccolp = NULL;
		row = 0;
	}

	if (row < 0) /* no override */ {
		if (sf->sf_crowp != NULL)
			ri->ri_crow = *sf->sf_crowp;
		else
			/* assume last row */
			ri->ri_crow = ri->ri_rows - 1;
	} else {
		ri->ri_crow = row;
	}

	/*
	 * Scale back rows and columns if the font would not otherwise
	 * fit on this display. Without this we would panic later.
	 */
	if (ri->ri_crow >= ri->ri_rows)
		ri->ri_crow = ri->ri_rows - 1;
	if (ri->ri_ccol >= ri->ri_cols)
		ri->ri_ccol = ri->ri_cols - 1;

	/*
	 * Take care of updating the PROM cursor position as well if we can.
	 */
	if (ri->ri_updatecursor != NULL &&
	    (sf->sf_ccolp != NULL || sf->sf_crowp != NULL))
		ri->ri_updatecursor = fb_updatecursor;

	if (ri->ri_flg & RI_VCONS)
		cookie = ri->ri_active;
	else
		cookie = ri;

	if (ISSET(ri->ri_caps, WSSCREEN_WSCOLORS))
		ri->ri_ops.alloc_attr(cookie,
		    WSCOL_BLACK, WSCOL_WHITE, WSATTR_WSCOLORS, &defattr);
	else
		ri->ri_ops.alloc_attr(cookie, 0, 0, 0, &defattr);

	fb_initwsd(sf);
	wsdisplay_cnattach(&sf->sf_wsd, cookie,
	    ri->ri_ccol, ri->ri_crow, defattr);
}

void
fbwscons_setcolormap(struct sunfb *sf,
    void (*setcolor)(void *, u_int, u_int8_t, u_int8_t, u_int8_t))
{
	int i;
	const u_char *color;

	if (sf->sf_depth <= 8 && setcolor != NULL) {
		for (i = 0; i < 16; i++) {
			color = &rasops_cmap[i * 3];
			setcolor(sf, i, color[0], color[1], color[2]);
		}
		for (i = 240; i < 256; i++) {
			color = &rasops_cmap[i * 3];
			setcolor(sf, i, color[0], color[1], color[2]);
		}
		/*
		 * Compensate for BoW default hardware palette: existing
		 * output (which we do not want to affect) is black on
		 * white with color index 0 being white and 0xff being
		 * black.
		 */
		setcolor(sf, WSCOL_SUN_WHITE, 0xff, 0xff, 0xff);
		setcolor(sf, 0xff ^ WSCOL_SUN_WHITE, 0, 0, 0);
		setcolor(sf, WSCOL_SUN_BLACK, 0, 0, 0);
		setcolor(sf, 0xff ^ (WSCOL_SUN_BLACK), 0xff, 0xff, 0xff);
	}
}

void
fbwscons_attach(struct sunfb *sf, struct wsdisplay_accessops *op, int isconsole)
{
	struct wsemuldisplaydev_attach_args waa;

	if (isconsole == 0) {
		/* done in wsdisplay_cnattach() earlier if console */
		fb_initwsd(sf);
	} else {
		/* remember screen burner routine */
		fb_burner = op->burn_screen;
		fb_cookie = sf;
	}

	/* plug common wsdisplay_accessops if necessary */
	if (op->alloc_screen == NULL) {
		op->alloc_screen = fb_alloc_screen;
		op->free_screen = fb_free_screen;
		op->show_screen = fb_show_screen;
	}
	if (op->load_font == NULL) {
		op->load_font = fb_load_font;
		op->list_font = fb_list_font;
	}

	sf->sf_scrlist[0] = &sf->sf_wsd;
	sf->sf_wsl.nscreens = 1;
	sf->sf_wsl.screens = (const struct wsscreen_descr **)sf->sf_scrlist;

	waa.console = isconsole;
	waa.scrdata = &sf->sf_wsl;
	waa.accessops = op;
	waa.accesscookie = sf;
	waa.defaultscreens = 0;
	config_found(&sf->sf_dev, &waa, wsemuldisplaydevprint);
}

/*
 * Common wsdisplay_accessops routines.
 */
int
fb_alloc_screen(void *v, const struct wsscreen_descr *type,
    void **cookiep, int *curxp, int *curyp, long *attrp)
{
	struct sunfb *sf = v;
	struct rasops_info *ri = &sf->sf_ro;
	void *cookie;

	if (sf->sf_nscreens > 0)
		return (ENOMEM);

	if (ri->ri_flg & RI_VCONS)
		cookie = ri->ri_active;
	else
		cookie = ri;

	*cookiep = cookie;
	*curyp = 0;
	*curxp = 0;
	if (ISSET(ri->ri_caps, WSSCREEN_WSCOLORS))
		ri->ri_ops.alloc_attr(cookie,
		    WSCOL_BLACK, WSCOL_WHITE, WSATTR_WSCOLORS, attrp);
	else
		ri->ri_ops.alloc_attr(cookie, 0, 0, 0, attrp);
	sf->sf_nscreens++;
	return (0);
}

void
fb_free_screen(void *v, void *cookie)
{
	struct sunfb *sf = v;

	sf->sf_nscreens--;
}

int
fb_show_screen(void *v, void *cookie, int waitok, void (*cb)(void *, int, int),
    void *cbarg)
{
	return (0);
}

int
fb_load_font(void *v, void *emulcookie, struct wsdisplay_font *font)
{
	struct sunfb *sf = v;
	struct rasops_info *ri = &sf->sf_ro;

	return rasops_load_font(ri, emulcookie, font);
}

int
fb_list_font(void *v, struct wsdisplay_font *font)
{
	struct sunfb *sf = v;
	struct rasops_info *ri = &sf->sf_ro;

	return rasops_list_font(ri, font);
}

int
fb_get_console_metrics(int *fontwidth, int *fontheight, int *wtop, int *wleft)
{
	cell_t romheight, romwidth, windowtop, windowleft;

	/*
	 * Get the PROM font metrics and address
	 */
	OF_interpret("stdout @@ is my-self "
	    "addr char-height addr char-width "
	    "addr window-top addr window-left",
	    4, &windowleft, &windowtop, &romwidth, &romheight);

	if (romheight == 0 || romwidth == 0 ||
	    windowtop == 0 || windowleft == 0)
		return (1);

	*fontwidth = (int)*(uint64_t *)romwidth;
	*fontheight = (int)*(uint64_t *)romheight;
	*wtop = (int)*(uint64_t *)windowtop;
	*wleft = (int)*(uint64_t *)windowleft;

	return (0);
}

#endif	/* NWSDISPLAY */
@


1.27
log
@'accomodate' -> 'accommodate' in comments.

Started by diff from Mical Mazurek.
@
text
@d1 1
a1 1
/*	$OpenBSD: fb.c,v 1.26 2016/03/07 13:21:51 naddy Exp $	*/
d134 6
a139 1
	sf->sf_depth = getpropint(node, "depth", def_depth);
@


1.26
log
@Sync no-argument function declaration and definition by adding (void).
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fb.c,v 1.25 2013/10/21 10:36:19 miod Exp $	*/
d213 1
a213 1
	 * However, to accomodate laptops with specific small fonts,
@


1.25
log
@Add load_font and list_font accessops to all rasops-based wsdisplay drivers.
Trivial except for tga(4) and gpx(4/vax) which need a bit more care setting
up a new font.
@
text
@d1 1
a1 1
/*	$OpenBSD: fb.c,v 1.24 2013/08/15 18:29:56 kettenis Exp $	*/
d107 1
a107 1
fb_unblank()
@


1.24
log
@Add RI_VCONS support.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fb.c,v 1.23 2011/04/07 15:30:16 miod Exp $	*/
d125 2
d420 4
d481 18
@


1.23
log
@Do not use NULL in integer comparisons. No functional change.
ok matthew@@ tedu@@, also eyeballed by at least krw@@ oga@@ kettenis@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fb.c,v 1.22 2009/06/03 20:17:48 kettenis Exp $	*/
d306 1
d353 5
d359 1
a359 1
		ri->ri_ops.alloc_attr(ri,
d362 1
a362 1
		ri->ri_ops.alloc_attr(ri, 0, 0, 0, &defattr);
d365 2
a366 1
	wsdisplay_cnattach(&sf->sf_wsd, ri, ri->ri_ccol, ri->ri_crow, defattr);
d440 1
d445 6
a450 1
	*cookiep = ri;
d454 1
a454 1
		ri->ri_ops.alloc_attr(ri,
d457 1
a457 1
		ri->ri_ops.alloc_attr(ri, 0, 0, 0, attrp);
@


1.22
log
@Fix check for window-top and window-left values.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fb.c,v 1.21 2009/01/19 20:21:33 miod Exp $	*/
d477 2
a478 2
	if (romheight == NULL || romwidth == NULL ||
	    windowtop == NULL || windowleft == NULL)
@


1.21
log
@Clear RI_CLEARMARGINS in the ri_bits == NULL ifb(4) kluge, the new window
position code may set it.
@
text
@d1 1
a1 1
/*	$OpenBSD: fb.c,v 1.20 2009/01/12 17:14:48 miod Exp $	*/
d229 2
a230 2
			if (wt <= 0 || wt > sf->sf_width - cols * fw ||
			    wl <= 0 || wl > sf->sf_height - rows * fh)
@


1.20
log
@Be more strict when checking window-left and window-top values.
@
text
@d1 1
a1 1
/*	$OpenBSD: fb.c,v 1.19 2009/01/11 15:27:32 miod Exp $	*/
d264 1
a264 1
		ri->ri_flg &= ~RI_CLEAR;
@


1.19
log
@Some frame buffer fcode do not fill window-top and window-left put
nevertheless provide them; cope with zero values.
@
text
@d1 1
a1 1
/*	$OpenBSD: fb.c,v 1.18 2008/12/27 17:23:01 miod Exp $	*/
d223 9
a231 1
			wt = 0; wl = 0;
d233 1
a233 1
		if (wt == 0 || wl == 0) {
@


1.18
log
@Sync the sparc64 fb* api with the recent changes done on sparc.
@
text
@d1 1
a1 1
/*	$OpenBSD: fb.c,v 1.17 2007/11/10 15:17:16 jsing Exp $	*/
d223 3
@


1.17
log
@weel -> well
@
text
@d1 1
a1 1
/*	$OpenBSD: fb.c,v 1.16 2006/12/03 16:41:58 miod Exp $	*/
d5 1
a5 1
 * Copyright (c) 2002, 2004  Miodrag Vallat.
d81 1
d116 9
a124 2
static void fb_initwsd(struct sunfb *);
static void fb_updatecursor(struct rasops_info *);
d139 1
d146 1
a146 1
	if (sf->sf_linebytes < (sf->sf_width * sf->sf_depth) / 8) {
a147 1
	}
d165 1
a165 1
static void
d175 1
a175 1
static void
d187 1
a187 1
fbwscons_init(struct sunfb *sf, int flags)
d190 1
a190 1
	int cols, rows;
d193 1
a193 1
	ri->ri_flg = RI_CENTER | RI_FULLCLEAR | flags;
d202 53
d257 17
d302 14
a315 1
	if (row < 0) {
a321 8
		/*
		 * If we force the display row, this is because the screen
		 * has been cleared or the font has been changed.
		 * In this case, choose not to keep pointers to the PROM
		 * cursor position, as the values are likely to be inaccurate
		 * upon shutdown...
		 */
		sf->sf_crowp = sf->sf_ccolp = NULL;
d394 7
d411 65
@


1.16
log
@Do the ri_devcmap reprogramming dance in fbwscons_init(), so that it applies
to non-console frame buffers as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: fb.c,v 1.15 2006/12/02 11:25:09 miod Exp $	*/
d252 1
a252 1
	 * Take care of updating the PROM cursor position as weel if we can.
@


1.15
log
@Fix ri_devcmap[] to allow WSCOL_BLACK and WSCOL_WHITE to not have to be
different for sparc{,64} systems.
@
text
@d1 1
a1 1
/*	$OpenBSD: fb.c,v 1.14 2006/11/29 12:13:54 miod Exp $	*/
d195 16
a256 16

	if (sf->sf_depth == 8) {
		/*
		 * If we are running with an indexed palette, compensate
		 * the swap of black and white through ri_devcmap.
		 */
		ri->ri_devcmap[WSCOL_SUN_BLACK] = 0;
		ri->ri_devcmap[WSCOL_SUN_WHITE] = 0xffffffff;
	} else if (sf->sf_depth > 8) {
		/*
		 * If we are running on a direct color frame buffer,
		 * make the ``normal'' white the same as the highlighted
		 * white.
		 */
		ri->ri_devcmap[WSCOL_WHITE] = ri->ri_devcmap[WSCOL_WHITE + 8];
	}
@


1.14
log
@Add a new member to struct wsemuldisplaydev_attach_args, for a frame buffer
driver to be able to tell how many wscons screens to attach to it,
instead of WSDISPLAY_DEFAULTSCREENS which is a global setting.
@
text
@d1 1
a1 1
/*	$OpenBSD: fb.c,v 1.13 2006/07/01 16:15:59 miod Exp $	*/
d89 9
a116 1
int	fb_alloc_cattr(void *, int, int, int, long *);
a194 2
	if (ri->ri_caps & WSSCREEN_WSCOLORS)
		ri->ri_ops.alloc_attr = fb_alloc_cattr;
a200 1
	int32_t tmp;
d242 14
a255 8
	/*
	 * Select appropriate color settings to mimic a
	 * black on white Sun console.
	 */
	if (sf->sf_depth > 8) {
		tmp = ri->ri_devcmap[WSCOL_WHITE];
		ri->ri_devcmap[WSCOL_WHITE] = ri->ri_devcmap[WSCOL_BLACK];
		ri->ri_devcmap[WSCOL_BLACK] = tmp;
d273 1
a273 1
	u_char *color;
d277 1
a277 1
			color = (u_char *)&rasops_cmap[i * 3];
d281 1
a281 1
			color = (u_char *)&rasops_cmap[i * 3];
d284 10
a293 5
		/* compensate for BoW palette */
		setcolor(sf, WSCOL_BLACK, 0, 0, 0);
		setcolor(sf, 0xff ^ WSCOL_BLACK, 255, 255, 255);
		setcolor(sf, WSCOL_WHITE, 255, 255, 255);
		setcolor(sf, 0xff ^ WSCOL_WHITE, 0, 0, 0);
a320 42
}

/*
 * A variant of rasops_alloc_cattr() which handles the WSCOL_BLACK and
 * WSCOL_WHITE specific values wrt highlighting.
 */
int
fb_alloc_cattr(void *cookie, int fg, int bg, int flg, long *attrp)
{
	int swap;

	if ((flg & WSATTR_BLINK) != 0)
		return (EINVAL);

	if ((flg & WSATTR_WSCOLORS) == 0) {
		fg = WSCOL_WHITE;
		bg = WSCOL_BLACK;
	}

	if ((flg & WSATTR_REVERSE) != 0) {
		swap = fg;
		fg = bg;
		bg = swap;
	}

	if ((flg & WSATTR_HILIT) != 0) {
		if (fg == WSCOL_BLACK)
			fg = 8; /* ``regular'' dark gray */
		else if (fg != WSCOL_WHITE) /* white is always highlighted */
			fg += 8;
	}

	flg = ((flg & WSATTR_UNDERLINE) ? 1 : 0);

	/* we're lucky we do not need a different isgray table... */
	if (rasops_isgray[fg])
		flg |= 2;
	if (rasops_isgray[bg])
		flg |= 4;

	*attrp = (bg << 16) | (fg << 24) | flg;
	return (0);
@


1.13
log
@Provide our own alloc_attr() routine for sun frame buffer, since the computation
of highlighted color indexes is slightly different due to different black and
white color code (and the fact that the default white is the highlighted white).
@
text
@d1 1
a1 1
/*	$OpenBSD: fb.c,v 1.12 2006/06/30 21:38:19 miod Exp $	*/
d303 1
@


1.12
log
@For 32bit sun frame buffers, tweak ri_devcmap to get the BoW palette instead
of needing different WSCOL_{BLACK,WHITE} values than 8bit frame buffers.

This allows us to not special case the alloc_attr() invocations depending
on the color depth, and to make WSCOL_{BLACK,WHITE} constants again in the
wsemul_sun land.
@
text
@d1 1
a1 1
/*	$OpenBSD: fb.c,v 1.11 2006/06/29 17:54:32 miod Exp $	*/
d108 1
d173 1
d177 5
a181 5
	sf->sf_ro.ri_flg = RI_CENTER | RI_FULLCLEAR | flags;
	sf->sf_ro.ri_depth = sf->sf_depth;
	sf->sf_ro.ri_stride = sf->sf_linebytes;
	sf->sf_ro.ri_width = sf->sf_width;
	sf->sf_ro.ri_height = sf->sf_height;
d186 3
a188 1
	rasops_init(&sf->sf_ro, rows, cols);
d304 42
@


1.11
log
@No need to keep specific variables for the kernel messages colors on sun
emulation, we can reuse the existing WSCOL_xxx codes, and WSCOL_BLACK and
WSCOL_WHITE will point to variables anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: fb.c,v 1.10 2006/03/12 22:53:02 miod Exp $	*/
d190 2
d197 1
a197 1
		sf->sf_ro.ri_ccol = *sf->sf_ccolp;
d201 1
a201 1
			sf->sf_ro.ri_crow = *sf->sf_crowp;
d204 1
a204 1
			sf->sf_ro.ri_crow = sf->sf_ro.ri_rows - 1;
d214 1
a214 1
		sf->sf_ro.ri_crow = row;
d221 4
a224 4
	if (sf->sf_ro.ri_crow >= sf->sf_ro.ri_rows)
		sf->sf_ro.ri_crow = sf->sf_ro.ri_rows - 1;
	if (sf->sf_ro.ri_ccol >= sf->sf_ro.ri_cols)
		sf->sf_ro.ri_ccol = sf->sf_ro.ri_cols - 1;
d229 1
a229 1
	if (sf->sf_ro.ri_updatecursor != NULL &&
d231 1
a231 1
		sf->sf_ro.ri_updatecursor = fb_updatecursor;
d238 3
a240 2
		wscol_white = 0;
		wscol_black = 255;
d243 2
a244 3
	if (ISSET(sf->sf_ro.ri_caps, WSSCREEN_WSCOLORS) &&
	    sf->sf_depth == 8) {
		sf->sf_ro.ri_ops.alloc_attr(&sf->sf_ro,
d246 2
a247 3
	} else {
		sf->sf_ro.ri_ops.alloc_attr(&sf->sf_ro, 0, 0, 0, &defattr);
	}
d250 1
a250 2
	wsdisplay_cnattach(&sf->sf_wsd, &sf->sf_ro,
	    sf->sf_ro.ri_ccol, sf->sf_ro.ri_crow, defattr);
@


1.10
log
@Previous fix was half-done, move the wsscreen_list array into the softc
as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: fb.c,v 1.8 2005/03/15 18:40:15 miod Exp $	*/
a237 2
		wskernel_bg = 0;
		wskernel_fg = 255;
@


1.9
log
@When attaching a wsdisplay, the wsscreen_list structure can not be on the
stack; found the hard way by Stefano <stefano@@merlinobbs.net>.
@
text
@a282 1
	struct wsscreen_descr *scrlist[1];
d293 1
a293 1
	scrlist[0] = &sf->sf_wsd;
d295 1
a295 1
	sf->sf_wsl.screens = (const struct wsscreen_descr **)scrlist;
@


1.8
log
@Take care of updating the PROMs view of the cursor position in the common fb
code, rather than doing this in only a subset of the fb drivers.
@
text
@d1 1
a1 1
/*	$OpenBSD: fb.c,v 1.7 2005/03/07 16:44:52 miod Exp $	*/
a283 1
	struct wsscreen_list screenlist;
d295 2
a296 2
	screenlist.nscreens = 1;
	screenlist.screens = (const struct wsscreen_descr **)scrlist;
d299 1
a299 1
	waa.scrdata = &screenlist;
@


1.7
log
@Do not bother passing the blanking routine to fbwscons_console_init(),
as fbwscons_attach() can find it on its own.
@
text
@d1 1
a1 1
/*	$OpenBSD: fb.c,v 1.6 2004/11/29 22:07:40 miod Exp $	*/
a82 1
#include <dev/wscons/wscons_raster.h>
a87 3
static int a2int(char *, int);
static void fb_initwsd(struct sunfb *);

d105 4
d158 11
d223 7
@


1.6
log
@Move the struct wsscreen_descr from a per-driver global to a per-instance
field of the sunfb structure. This allows multiple instances of the same driver,
but with different resolutions (such as a couple of vigra or a TGX cgsix and
a TGX+ cgsix) to use distinct wsscreen_descr structures featuring different
resolution information.

Doing this allows more wsscreen_descr fiddling inside the sparc* fb api,
and results in some code shrinkage (about 4KB on sparc GENERIC).
@
text
@d1 1
a1 1
/*	$OpenBSD: fb.c,v 1.5 2004/02/29 21:24:37 miod Exp $	*/
d177 1
a177 2
fbwscons_console_init(struct sunfb *sf, int row,
    void (*burner)(void *, u_int, u_int))
a234 4

	/* remember screen burner routine */
	fb_burner = burner;
	fb_cookie = sf;
d271 4
@


1.5
log
@More colormap games for 8-bit framebuffers to enjoy the inverted cursor too.
@
text
@d1 1
a1 1
/*	$OpenBSD: fb.c,v 1.4 2003/10/05 18:34:43 miod Exp $	*/
d5 1
a5 1
 * Copyright (c) 2002 Miodrag Vallat
d89 3
d135 1
a135 3
int a2int(char *, int);

int
d147 11
d177 1
a177 1
fbwscons_console_init(struct sunfb *sf, struct wsscreen_descr *wsc, int row,
d209 4
a212 4
	if (sf->sf_ro.ri_crow >= wsc->nrows)
		sf->sf_ro.ri_crow = wsc->nrows - 1;
	if (sf->sf_ro.ri_ccol >= wsc->ncols)
		sf->sf_ro.ri_ccol = wsc->ncols - 1;
d225 1
a225 1
	if (ISSET(wsc->capabilities, WSSCREEN_WSCOLORS) &&
d233 2
a234 1
	wsdisplay_cnattach(wsc, &sf->sf_ro,
d264 23
@


1.4
log
@If attaching a wsdisplay console causes a font switch, do not update the PROM
view of the cursor position, so that it comes back to a correct location when
the system is shut down.
@
text
@d1 1
a1 1
/*	$OpenBSD: fb.c,v 1.3 2003/06/28 14:26:17 miod Exp $	*/
d241 4
d247 1
a247 1
		setcolor(sf, 255, 0, 0, 0);	/* cursor */
d249 1
@


1.4.2.1
log
@Merge with the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a240 4
		for (i = 240; i < 256; i++) {
			color = (u_char *)&rasops_cmap[i * 3];
			setcolor(sf, i, color[0], color[1], color[2]);
		}
d243 1
a243 1
		setcolor(sf, 0xff ^ WSCOL_BLACK, 255, 255, 255);
a244 1
		setcolor(sf, 0xff ^ WSCOL_WHITE, 0, 0, 0);
@


1.3
log
@Add RI_FULLCLEAR to the rasops flags. Accelerated drivers (cgsix, creator,
pnozz) benefit from this, and this does not hurt the other drivers.
@
text
@d1 1
a1 1
/*	$OpenBSD: fb.c,v 1.2 2003/06/17 17:35:40 miod Exp $	*/
d182 8
a190 2
		if (sf->sf_crowp != NULL)
			*sf->sf_crowp = row;
@


1.2
log
@Extend the sunfb structure to take care of the PROM cursor position
pointers, and adapt creator to the fb api.
ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fb.c,v 1.1 2003/06/16 20:46:10 miod Exp $	*/
d152 1
a152 1
	sf->sf_ro.ri_flg = RI_CENTER | flags;
@


1.1
log
@Provide the same fbxxx() api as on sparc, in order to factorize more code
and eventually share some drivers.
This also brings us screen unblanking upon entering ddb, which can be really
useful at times...
@
text
@d1 1
a1 1
/*	$OpenBSD: fb.c,v 1.24 2003/06/02 23:27:54 millert Exp $	*/
a168 1
	int *ccolp, *crowp;
d170 4
a173 4
	if (romgetcursoraddr(&crowp, &ccolp))
		ccolp = crowp = NULL;
	if (ccolp != NULL)
		sf->sf_ro.ri_ccol = *ccolp;
d176 2
a177 2
		if (crowp != NULL)
			sf->sf_ro.ri_crow = *crowp;
d181 1
a181 1
	} else
d183 3
@

