head	1.6;
access;
symbols
	OPENBSD_6_2_BASE:1.6
	OPENBSD_6_1:1.6.0.40
	OPENBSD_6_1_BASE:1.6
	OPENBSD_6_0:1.6.0.36
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.6.0.32
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.6.0.34
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.26
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.6.0.30
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.28
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.24
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.22
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.20
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.18
	OPENBSD_5_0:1.6.0.16
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.14
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.12
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.8
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.10
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.6
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.4
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.2
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.5.0.12
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.10
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.8
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.6
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.4
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.2
	OPENBSD_3_7_BASE:1.5;
locks; strict;
comment	@ * @;


1.6
date	2008.01.20.16.41.17;	author kettenis;	state Exp;
branches;
next	1.5;

1.5
date	2004.10.01.18.18.49;	author jason;	state Exp;
branches;
next	1.4;

1.4
date	2004.09.29.17.43.33;	author jason;	state Exp;
branches;
next	1.3;

1.3
date	2004.09.28.16.37.02;	author jason;	state Exp;
branches;
next	1.2;

1.2
date	2004.09.28.14.34.58;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2004.09.28.02.06.36;	author jason;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Add temperature sensor.
@
text
@/*	$OpenBSD: clkbrd.c,v 1.5 2004/10/01 18:18:49 jason Exp $	*/

/*
 * Copyright (c) 2004 Jason L. Wright (jason@@thought.net)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/conf.h>
#include <sys/device.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/sensors.h>
#include <sys/systm.h>
#include <sys/timeout.h>

#include <machine/bus.h>
#include <machine/autoconf.h>
#include <machine/openfirm.h>

#include <sparc64/dev/fhcvar.h>
#include <sparc64/dev/clkbrdreg.h>
#include <sparc64/dev/clkbrdvar.h>

int clkbrd_match(struct device *, void *, void *);
void clkbrd_attach(struct device *, struct device *, void *);
void clkbrd_led_blink(void *, int);
void clkbrd_refresh(void *);

struct cfattach clkbrd_ca = {
	sizeof(struct clkbrd_softc), clkbrd_match, clkbrd_attach
};

struct cfdriver clkbrd_cd = {
	NULL, "clkbrd", DV_DULL
};

int
clkbrd_match(struct device *parent, void *match, void *aux)
{
	struct fhc_attach_args *fa = aux;

	if (strcmp(fa->fa_name, "clock-board") == 0)
		return (1);
	return (0);
}

void
clkbrd_attach(struct device *parent, struct device *self, void *aux)
{
	struct clkbrd_softc *sc = (struct clkbrd_softc *)self;
	struct fhc_attach_args *fa = aux;
	int slots;
	u_int8_t r;

	sc->sc_bt = fa->fa_bustag;

	if (fa->fa_nreg < 2) {
		printf(": no registers\n");
		return;
	}

	if (fhc_bus_map(sc->sc_bt, fa->fa_reg[1].fbr_slot,
	    fa->fa_reg[1].fbr_offset, fa->fa_reg[1].fbr_size, 0,
	    &sc->sc_creg)) {
		printf(": can't map ctrl regs\n");
		return;
	}

	if (fa->fa_nreg > 2) {
		if (fhc_bus_map(sc->sc_bt, fa->fa_reg[2].fbr_slot,
		    fa->fa_reg[2].fbr_offset, fa->fa_reg[2].fbr_size, 0,
		    &sc->sc_vreg)) {
			printf(": can't map vreg\n");
			return;
		}
		sc->sc_has_vreg = 1;
	}

	slots = 4;
	r = bus_space_read_1(sc->sc_bt, sc->sc_creg, CLK_STS1);
	switch (r & 0xc0) {
	case 0x40:
		slots = 16;
		break;
	case 0xc0:
		slots = 8;
		break;
	case 0x80:
		if (sc->sc_has_vreg) {
			r = bus_space_read_1(sc->sc_bt, sc->sc_vreg, 0);
			if (r != 0 && (r & 0x80) == 0)
					slots = 5;
		}
	}

	sc->sc_blink.bl_func = clkbrd_led_blink;
	sc->sc_blink.bl_arg = sc;
	blink_led_register(&sc->sc_blink);

	/* Initialize sensor data. */
	strlcpy(sc->sc_sensordev.xname, sc->sc_dv.dv_xname,
	    sizeof(sc->sc_sensordev.xname));
	sc->sc_sensor.type = SENSOR_TEMP;

	sensor_attach(&sc->sc_sensordev, &sc->sc_sensor);

	if (sensor_task_register(sc, clkbrd_refresh, 5) == NULL) {
		printf(": unable to register update task\n");
		return;
	}

	sensordev_install(&sc->sc_sensordev);

	printf(": %d slots\n", slots);
}

void
clkbrd_led_blink(void *vsc, int on)
{
	struct clkbrd_softc *sc = vsc;
	int s;
	u_int8_t r;

	s = splhigh();
	r = bus_space_read_1(sc->sc_bt, sc->sc_creg, CLK_CTRL);
	if (on)
		r |= CLK_CTRL_RLED;
	else
		r &= ~CLK_CTRL_RLED;
	bus_space_write_1(sc->sc_bt, sc->sc_creg, CLK_CTRL, r);
	bus_space_read_1(sc->sc_bt, sc->sc_creg, CLK_CTRL);
	splx(s);
}

/*
 * Calibration table for temperature sensor.
 */
int8_t clkbrd_temp[] = {
	 0,  0,  0,  0,  0,  0,  0,  0,
	 0,  0,  0,  0,  1,  2,  4,  5,
	 7,  8, 10, 11, 12, 13, 14, 15,
	17, 18, 19, 20, 21, 22, 23, 24,
	24, 25, 26, 27, 28, 29, 29, 30,
	31, 32, 32, 33, 34, 35, 35, 36,
	37, 38, 38, 39, 40, 40, 41, 42,
	42, 43, 44, 44, 45, 46, 46, 47,
	48, 48, 49, 50, 50, 51, 52, 52,
	53, 54, 54, 55, 56, 57, 57, 58,
	59, 59, 60, 60, 61, 62, 63, 63,
	64, 65, 65, 66, 67, 68, 68, 69,
	70, 70, 71, 72, 73, 74, 74, 75,
	76, 77, 78, 78, 79, 80, 81, 82
};

const int8_t clkbrd_temp_warn = 60;
const int8_t clkbrd_temp_crit = 68;

void
clkbrd_refresh(void *arg)
{
	struct clkbrd_softc *sc = arg;
	u_int8_t val;
	int8_t temp;

	val = bus_space_read_1(sc->sc_bt, sc->sc_creg, CLK_TEMP);
	if (val == 0xff) {
		sc->sc_sensor.flags |= SENSOR_FINVALID;
		return;
	}

	if (val < sizeof(clkbrd_temp))
		temp = clkbrd_temp[val];
	else
		temp = clkbrd_temp[sizeof(clkbrd_temp) - 1];

	sc->sc_sensor.value = val * 1000000 + 273150000;
	sc->sc_sensor.flags &= ~SENSOR_FINVALID;
	sc->sc_sensor.status = SENSOR_S_OK;
	if (temp >= clkbrd_temp_warn)
		sc->sc_sensor.status = SENSOR_S_WARN;
	if (temp >= clkbrd_temp_crit)
		sc->sc_sensor.status = SENSOR_S_CRIT;
}
@


1.5
log
@add a blink_led API (shaves ~1k from GENERIC) rather than have the same
logic in 3 files.  Devices register a function to be called to turn the
led on and off based on load average. (Note: rerun config and make depend)
@
text
@d1 1
a1 1
/*	$OpenBSD: clkbrd.c,v 1.4 2004/09/29 17:43:33 jason Exp $	*/
a28 1
#include <sys/types.h>
d30 5
a35 3
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/conf.h>
a36 1
#include <sys/malloc.h>
d49 1
d60 1
a60 3
clkbrd_match(parent, match, aux)
	struct device *parent;
	void *match, *aux;
d70 1
a70 3
clkbrd_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
a117 2
	printf(": %d slots\n", slots);

d121 16
d155 50
@


1.4
log
@map correct register set for the blinky lights and the slot description
@
text
@d1 1
a1 1
/*	$OpenBSD: clkbrd.c,v 1.3 2004/09/28 16:37:02 jason Exp $	*/
a45 2
extern	int sparc_led_blink;

d48 1
a81 2
	timeout_set(&sc->sc_to, clkbrd_led_blink, sc);

d123 3
a125 2
	if (sparc_led_blink)
		clkbrd_led_blink(sc);
d129 1
a129 1
clkbrd_led_blink(void *vsc)
d132 1
a132 1
	int i, s;
a134 9
	if (sc == NULL) {
		for (i = 0; i < clkbrd_cd.cd_ndevs; i++) {
			sc = clkbrd_cd.cd_devs[i];
			if (sc != NULL)
				clkbrd_led_blink(sc);
		}
		return;
	}

d137 4
a140 1
	r ^= CLK_CTRL_RLED;
a143 13

	if (!sparc_led_blink)
		return;

	/*
	 * Blink rate is:
	 *      full cycle every second if completely idle (loadav = 0)
	 *      full cycle every 2 seconds if loadav = 1
	 *      full cycle every 3 seconds if loadav = 2
	 * etc.
	 */
	s = (((averunnable.ldavg[0] + FSCALE) * hz) >> (FSHIFT + 1));
	timeout_add(&sc->sc_to, s);
@


1.3
log
@debugging stuff nuke I will
@
text
@d1 1
a1 1
/*	$OpenBSD: clkbrd.c,v 1.2 2004/09/28 14:34:58 miod Exp $	*/
d85 1
a85 1
	if (fa->fa_nreg < 1) {
d90 2
a91 2
	if (fhc_bus_map(sc->sc_bt, fa->fa_reg[0].fbr_slot,
	    fa->fa_reg[0].fbr_offset, fa->fa_reg[0].fbr_size, 0,
d107 1
d119 1
a119 4
			if (r != 0) {
				if (r & 0x80)
					slots = 4;
				else
a120 2
				break;
			}
a121 2
	default:
		slots = 4;
@


1.2
log
@Like Yoda Jason trying to speak is.
@
text
@d1 1
a1 1
/*	$OpenBSD: clkbrd.c,v 1.1 2004/09/28 02:06:36 jason Exp $	*/
d78 1
a78 1
	int i, slots;
a130 6

	for (i = 0; i < fa->fa_nreg; i++) {
		printf(" r[%d] slot %x offset %x size %x\n",
		    i, fa->fa_reg[i].fbr_slot, fa->fa_reg[i].fbr_offset,
		    fa->fa_reg[i].fbr_size);
	}
@


1.1
log
@driver for "clock-board" (mainly blinky lights, but also has information about the chassis)
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d130 1
a130 1
	printf(": slots %d\n", slots);
@

