head	1.21;
access;
symbols
	OPENBSD_6_2_BASE:1.21
	OPENBSD_6_1:1.20.0.8
	OPENBSD_6_1_BASE:1.20
	OPENBSD_6_0:1.20.0.4
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.20.0.2
	OPENBSD_5_9_BASE:1.20
	OPENBSD_5_8:1.19.0.8
	OPENBSD_5_8_BASE:1.19
	OPENBSD_5_7:1.19.0.2
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.19.0.4
	OPENBSD_5_6_BASE:1.19
	OPENBSD_5_5:1.18.0.14
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.18.0.10
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.18.0.8
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.18.0.6
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.4
	OPENBSD_5_0:1.18.0.2
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.17.0.2
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.16.0.10
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.16.0.6
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.16.0.8
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.16.0.4
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.16.0.2
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.15.0.2
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.13.0.2
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.12.0.10
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.8
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.12.0.6
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.4
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.2
	OPENBSD_3_7_BASE:1.12;
locks; strict;
comment	@ * @;


1.21
date	2017.09.08.05.36.52;	author deraadt;	state Exp;
branches;
next	1.20;
commitid	uRv5pa9QDlZaYgwD;

1.20
date	2015.09.19.21.07.04;	author semarie;	state Exp;
branches;
next	1.19;
commitid	9KMPSlP02LD1SpJP;

1.19
date	2014.07.12.18.44.43;	author tedu;	state Exp;
branches;
next	1.18;
commitid	uKVPYMN2MLxdZxzH;

1.18
date	2011.04.07.15.30.16;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2010.11.11.17.58.23;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2008.03.09.13.27.47;	author kettenis;	state Exp;
branches;
next	1.15;

1.15
date	2008.01.17.22.53.18;	author kettenis;	state Exp;
branches;
next	1.14;

1.14
date	2007.09.17.01.33.33;	author krw;	state Exp;
branches;
next	1.13;

1.13
date	2007.05.01.19.44.56;	author kettenis;	state Exp;
branches;
next	1.12;

1.12
date	2004.10.01.18.18.49;	author jason;	state Exp;
branches;
next	1.11;

1.11
date	2004.09.28.18.37.43;	author jason;	state Exp;
branches;
next	1.10;

1.10
date	2004.09.28.02.01.49;	author jason;	state Exp;
branches;
next	1.9;

1.9
date	2004.09.27.21.12.40;	author jason;	state Exp;
branches;
next	1.8;

1.8
date	2004.09.27.19.23.07;	author jason;	state Exp;
branches;
next	1.7;

1.7
date	2004.09.27.18.32.35;	author jason;	state Exp;
branches;
next	1.6;

1.6
date	2004.09.27.18.15.32;	author jason;	state Exp;
branches;
next	1.5;

1.5
date	2004.09.27.17.28.03;	author jason;	state Exp;
branches;
next	1.4;

1.4
date	2004.09.24.21.29.36;	author jason;	state Exp;
branches;
next	1.3;

1.3
date	2004.09.24.20.50.49;	author jason;	state Exp;
branches;
next	1.2;

1.2
date	2004.09.23.16.26.59;	author jason;	state Exp;
branches;
next	1.1;

1.1
date	2004.09.22.21.44.45;	author jason;	state Exp;
branches;
next	;


desc
@@


1.21
log
@If you use sys/param.h, you don't need sys/types.h
@
text
@/*	$OpenBSD: fhc.c,v 1.20 2015/09/19 21:07:04 semarie Exp $	*/

/*
 * Copyright (c) 2004 Jason L. Wright (jason@@thought.net)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/conf.h>
#include <sys/timeout.h>
#include <sys/malloc.h>

#include <machine/bus.h>
#include <machine/autoconf.h>
#include <machine/openfirm.h>

#include <sparc64/dev/fhcreg.h>
#include <sparc64/dev/fhcvar.h>
#include <sparc64/dev/iommureg.h>

struct cfdriver fhc_cd = {
	NULL, "fhc", DV_DULL
};

int	fhc_print(void *, const char *);

bus_space_tag_t fhc_alloc_bus_tag(struct fhc_softc *);
int _fhc_bus_map(bus_space_tag_t, bus_space_tag_t, bus_addr_t, bus_size_t,
    int, bus_space_handle_t *);
void *fhc_intr_establish(bus_space_tag_t, bus_space_tag_t, int, int, int,
    int (*)(void *), void *, const char *);
bus_space_handle_t *fhc_find_intr_handle(struct fhc_softc *, int);
void fhc_led_blink(void *, int);

void
fhc_attach(struct fhc_softc *sc)
{
	int node0, node;
	u_int32_t ctrl;

	printf(" board %d: %s\n", sc->sc_board,
	    getpropstring(sc->sc_node, "board-model"));

	sc->sc_cbt = fhc_alloc_bus_tag(sc);

	sc->sc_ign = sc->sc_board << 1;
	bus_space_write_4(sc->sc_bt, sc->sc_ireg, FHC_I_IGN, sc->sc_ign);
	sc->sc_ign = bus_space_read_4(sc->sc_bt, sc->sc_ireg, FHC_I_IGN);

	ctrl = bus_space_read_4(sc->sc_bt, sc->sc_preg, FHC_P_CTRL);
	if (!sc->sc_is_central)
		ctrl |= FHC_P_CTRL_IXIST;
	ctrl &= ~(FHC_P_CTRL_AOFF | FHC_P_CTRL_BOFF | FHC_P_CTRL_SLINE);
	bus_space_write_4(sc->sc_bt, sc->sc_preg, FHC_P_CTRL, ctrl);
	bus_space_read_4(sc->sc_bt, sc->sc_preg, FHC_P_CTRL);

	/* clear interrupts */
	bus_space_write_4(sc->sc_bt, sc->sc_freg, FHC_F_ICLR, 0);
	bus_space_read_4(sc->sc_bt, sc->sc_freg, FHC_F_ICLR);
	bus_space_write_4(sc->sc_bt, sc->sc_sreg, FHC_S_ICLR, 0);
	bus_space_read_4(sc->sc_bt, sc->sc_sreg, FHC_S_ICLR);
	bus_space_write_4(sc->sc_bt, sc->sc_ureg, FHC_U_ICLR, 0);
	bus_space_read_4(sc->sc_bt, sc->sc_ureg, FHC_U_ICLR);
	bus_space_write_4(sc->sc_bt, sc->sc_treg, FHC_T_ICLR, 0);
	bus_space_read_4(sc->sc_bt, sc->sc_treg, FHC_T_ICLR);

	getprop(sc->sc_node, "ranges", sizeof(struct fhc_range),
	    &sc->sc_nrange, (void **)&sc->sc_range);

	node0 = firstchild(sc->sc_node);
	for (node = node0; node; node = nextsibling(node)) {
		struct fhc_attach_args fa;

		if (!checkstatus(node))
			continue;

		bzero(&fa, sizeof(fa));

		fa.fa_node = node;
		fa.fa_bustag = sc->sc_cbt;

		if (fhc_get_string(fa.fa_node, "name", &fa.fa_name)) {
			printf("can't fetch name for node 0x%x\n", node);
			continue;
		}
		getprop(node, "reg", sizeof(struct fhc_reg),
		    &fa.fa_nreg, (void **)&fa.fa_reg);
		getprop(node, "interrupts", sizeof(int),
		    &fa.fa_nintr, (void **)&fa.fa_intr);
		getprop(node, "address", sizeof(*fa.fa_promvaddrs),
		    &fa.fa_npromvaddrs, (void **)&fa.fa_promvaddrs);

		(void)config_found(&sc->sc_dv, (void *)&fa, fhc_print);

		free(fa.fa_name, M_DEVBUF, 0);
		free(fa.fa_reg, M_DEVBUF, 0);
		free(fa.fa_intr, M_DEVBUF, 0);
		free(fa.fa_promvaddrs, M_DEVBUF, 0);
	}

	sc->sc_blink.bl_func = fhc_led_blink;
	sc->sc_blink.bl_arg = sc;
	blink_led_register(&sc->sc_blink);
}

int
fhc_print(void *args, const char *busname)
{
	struct fhc_attach_args *fa = args;
	char *class;

	if (busname != NULL) {
		printf("\"%s\" at %s", fa->fa_name, busname);
		class = getpropstring(fa->fa_node, "device_type");
		if (*class != '\0')
			printf(" class %s", class);
	}
	return (UNCONF);
}

int
fhc_get_string(int node, char *name, char **buf)
{
	int len;

	len = getproplen(node, name);
	if (len < 0)
		return (len);
	*buf = (char *)malloc(len + 1, M_DEVBUF, M_NOWAIT);
	if (*buf == NULL)
		return (-1);

	if (len != 0)
		getpropstringA(node, name, *buf);
	(*buf)[len] = '\0';
	return (0);
}

bus_space_tag_t
fhc_alloc_bus_tag(struct fhc_softc *sc)
{
	struct sparc_bus_space_tag *bt;

	bt = malloc(sizeof(*bt), M_DEVBUF, M_NOWAIT | M_ZERO);
	if (bt == NULL)
		panic("fhc: couldn't alloc bus tag");

	strlcpy(bt->name, sc->sc_dv.dv_xname, sizeof(bt->name));
	bt->cookie = sc;
	bt->parent = sc->sc_bt;
	bt->asi = bt->parent->asi;
	bt->sasi = bt->parent->sasi;
	bt->sparc_bus_map = _fhc_bus_map;
	/* XXX bt->sparc_bus_mmap = fhc_bus_mmap; */
	bt->sparc_intr_establish = fhc_intr_establish;
	return (bt);
}

int
_fhc_bus_map(bus_space_tag_t t, bus_space_tag_t t0, bus_addr_t addr,
    bus_size_t size, int flags, bus_space_handle_t *hp)
{
	struct fhc_softc *sc = t->cookie;
	int64_t slot = BUS_ADDR_IOSPACE(addr);
	int64_t offset = BUS_ADDR_PADDR(addr);
	int i;

	if (t->parent == NULL || t->parent->sparc_bus_map == NULL) {
		printf("\n_fhc_bus_map: invalid parent");
		return (EINVAL);
	}

	if (flags & BUS_SPACE_MAP_PROMADDRESS)
		return ((*t->parent->sparc_bus_map)(t, t0, addr,
		    size, flags, hp));

	for (i = 0; i < sc->sc_nrange; i++) {
		bus_addr_t paddr;

		if (sc->sc_range[i].cspace != slot)
			continue;

		paddr = offset - sc->sc_range[i].coffset;
		paddr += sc->sc_range[i].poffset;
		paddr |= ((bus_addr_t)sc->sc_range[i].pspace << 32); 

		return ((*t->parent->sparc_bus_map)(t->parent, t0, paddr,
		    size, flags, hp));
	}

	return (EINVAL);
}

bus_space_handle_t *
fhc_find_intr_handle(struct fhc_softc *sc, int ino)
{
	switch (FHC_INO(ino)) {
	case FHC_F_INO:
		return &sc->sc_freg;
	case FHC_S_INO:
		return &sc->sc_sreg;
	case FHC_U_INO:
		return &sc->sc_ureg;
	case FHC_T_INO:
		return &sc->sc_treg;
	default:
		break;
	}

	return (NULL);
}

void *
fhc_intr_establish(bus_space_tag_t t, bus_space_tag_t t0, int ihandle,
    int level, int flags, int (*handler)(void *), void *arg, const char *what)
{
	struct fhc_softc *sc = t->cookie;
	volatile u_int64_t *intrmapptr = NULL, *intrclrptr = NULL;
	struct intrhand *ih;
	long vec;

	if (level == IPL_NONE)
		level = INTLEV(ihandle);
	if (level == IPL_NONE) {
		printf(": no IPL, setting IPL 2.\n");
		level = 2;
	}

	if ((flags & BUS_INTR_ESTABLISH_SOFTINTR) == 0) {
		bus_space_handle_t *hp;
		struct fhc_intr_reg *intrregs;

		hp = fhc_find_intr_handle(sc, ihandle);
		if (hp == NULL) {
			printf(": can't find intr handle\n");
			return (NULL);
		}

		intrregs = bus_space_vaddr(sc->sc_bt, *hp);
		intrmapptr = &intrregs->imap;
		intrclrptr = &intrregs->iclr;
		vec = ((sc->sc_ign << INTMAP_IGN_SHIFT) & INTMAP_IGN) |
		    INTINO(ihandle);
	} else
		vec = INTVEC(ihandle);

	ih = bus_intr_allocate(t0, handler, arg, vec, level, intrmapptr,
	    intrclrptr, what);
	if (ih == NULL)
		return (NULL);

	intr_establish(ih->ih_pil, ih);

	if (intrmapptr != NULL) {
		u_int64_t r;

		r = *intrmapptr;
		r |= INTMAP_V;
		*intrmapptr = r;
		r = *intrmapptr;
		ih->ih_number |= r & INTMAP_INR;
	}

	return (ih);
}

void
fhc_led_blink(void *vsc, int on)
{
	struct fhc_softc *sc = vsc;
	int s;
	u_int32_t r;

	s = splhigh();
	r = bus_space_read_4(sc->sc_bt, sc->sc_preg, FHC_P_CTRL);
	if (on)
		r |= FHC_P_CTRL_RLED;
	else
		r &= ~FHC_P_CTRL_RLED;
	r &= ~(FHC_P_CTRL_AOFF | FHC_P_CTRL_BOFF | FHC_P_CTRL_SLINE);
	bus_space_write_4(sc->sc_bt, sc->sc_preg, FHC_P_CTRL, r);
	bus_space_read_4(sc->sc_bt, sc->sc_preg, FHC_P_CTRL);
	splx(s);
}
@


1.20
log
@trivial "if(x) free(x)" replacement by "free(x)"

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fhc.c,v 1.19 2014/07/12 18:44:43 tedu Exp $	*/
a28 1
#include <sys/types.h>
@


1.19
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: fhc.c,v 1.18 2011/04/07 15:30:16 miod Exp $	*/
d120 4
a123 8
		if (fa.fa_name != NULL)
			free(fa.fa_name, M_DEVBUF, 0);
		if (fa.fa_reg != NULL)
			free(fa.fa_reg, M_DEVBUF, 0);
		if (fa.fa_intr != NULL)
			free(fa.fa_intr, M_DEVBUF, 0);
		if (fa.fa_promvaddrs != NULL)
			free(fa.fa_promvaddrs, M_DEVBUF, 0);
@


1.18
log
@Do not use NULL in integer comparisons. No functional change.
ok matthew@@ tedu@@, also eyeballed by at least krw@@ oga@@ kettenis@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fhc.c,v 1.17 2010/11/11 17:58:23 miod Exp $	*/
d121 1
a121 1
			free(fa.fa_name, M_DEVBUF);
d123 1
a123 1
			free(fa.fa_reg, M_DEVBUF);
d125 1
a125 1
			free(fa.fa_intr, M_DEVBUF);
d127 1
a127 1
			free(fa.fa_promvaddrs, M_DEVBUF);
@


1.17
log
@Replace snprintf(foo, sizeof foo, "%s", ...) with strlcpy. ok deraadt@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fhc.c,v 1.16 2008/03/09 13:27:47 kettenis Exp $	*/
d124 1
a124 1
		if (fa.fa_nintr != NULL)
@


1.16
log
@Check "status" property.
@
text
@d1 1
a1 1
/*	$OpenBSD: fhc.c,v 1.15 2008/01/17 22:53:18 kettenis Exp $	*/
d177 1
a177 1
	snprintf(bt->name, sizeof(bt->name), "%s", sc->sc_dv.dv_xname);
@


1.15
log
@Print names we get from the prom within double quotes.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fhc.c,v 1.14 2007/09/17 01:33:33 krw Exp $	*/
d98 3
@


1.14
log
@Only the most obvious bzero() -> M_ZERO changes. No cast changes, no
MALLOC/FREE, etc. Just adding M_ZERO to malloc() and deleting an
immediately adjacent bzero().
@
text
@d1 1
a1 1
/*	$OpenBSD: fhc.c,v 1.13 2007/05/01 19:44:56 kettenis Exp $	*/
d139 1
a139 1
		printf("%s at %s", fa->fa_name, busname);
@


1.13
log
@Don't rely on the PROM to have configured the interrupts.  Make Simics boot
a but further and doesn't hurt a real E4500.

tested by miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fhc.c,v 1.12 2004/10/01 18:18:49 jason Exp $	*/
d170 1
a170 1
	bt = malloc(sizeof(*bt), M_DEVBUF, M_NOWAIT);
a173 1
	bzero(bt, sizeof(*bt));
@


1.12
log
@add a blink_led API (shaves ~1k from GENERIC) rather than have the same
logic in 3 files.  Devices register a function to be called to turn the
led on and off based on load average. (Note: rerun config and make depend)
@
text
@d1 1
a1 1
/*	$OpenBSD: fhc.c,v 1.11 2004/09/28 18:37:43 jason Exp $	*/
a57 2
bus_space_handle_t *fhc_try_intr_handle(struct fhc_softc *,
    bus_space_handle_t *, bus_size_t, int);
d222 1
a222 2
fhc_try_intr_handle(struct fhc_softc *sc, bus_space_handle_t *hp,
    bus_size_t off, int val)
d224 12
a235 12
	u_int64_t r;

	r = bus_space_read_8(sc->sc_bt, *hp, off);
	if (INTINO(r) == INTINO(val))
		return (hp);
	return (NULL);
}

bus_space_handle_t *
fhc_find_intr_handle(struct fhc_softc *sc, int val)
{
	bus_space_handle_t *hp;
a236 12
	hp = fhc_try_intr_handle(sc, &sc->sc_freg, FHC_F_IMAP, val);
	if (hp != NULL)
		return (hp);
	hp = fhc_try_intr_handle(sc, &sc->sc_sreg, FHC_S_IMAP, val);
	if (hp != NULL)
		return (hp);
	hp = fhc_try_intr_handle(sc, &sc->sc_ureg, FHC_U_IMAP, val);
	if (hp != NULL)
		return (hp);
	hp = fhc_try_intr_handle(sc, &sc->sc_treg, FHC_T_IMAP, val);
	if (hp != NULL)
		return (hp);
@


1.11
log
@use prom mappings when availavk
@
text
@d1 1
a1 1
/*	$OpenBSD: fhc.c,v 1.10 2004/09/28 02:01:49 jason Exp $	*/
a51 2
extern	int sparc_led_blink;

d60 1
a70 2
	timeout_set(&sc->sc_to, fhc_led_blink, sc);

d129 3
a131 2
	if (sparc_led_blink)
		fhc_led_blink(sc);
d310 1
a310 1
fhc_led_blink(void *vsc)
d313 1
a313 1
	int i, s;
a315 9
	if (sc == NULL) {
		for (i = 0; i < fhc_cd.cd_ndevs; i++) {
			sc = fhc_cd.cd_devs[i];
			if (sc != NULL)
				fhc_led_blink(sc);
		}
		return;
	}

d318 4
a321 1
	r ^= FHC_P_CTRL_RLED;
a325 13

	if (!sparc_led_blink)
		return;

	/*
	 * Blink rate is:
	 *      full cycle every second if completely idle (loadav = 0)
	 *      full cycle every 2 seconds if loadav = 1
	 *      full cycle every 3 seconds if loadav = 2
	 * etc.
	 */
	s = (((averunnable.ldavg[0] + FSCALE) * hz) >> (FSHIFT + 1));
	timeout_add(&sc->sc_to, s);
@


1.10
log
@missing \n
@
text
@d1 1
a1 1
/*	$OpenBSD: fhc.c,v 1.9 2004/09/27 21:12:40 jason Exp $	*/
d117 2
d128 2
@


1.9
log
@Important stuff: blinky lights for fhc
@
text
@d1 1
a1 1
/*	$OpenBSD: fhc.c,v 1.8 2004/09/27 19:23:07 jason Exp $	*/
d69 1
a69 1
	printf(" board %d: %s", sc->sc_board,
@


1.8
log
@setup ign based on board number
@
text
@d1 1
a1 1
/*	$OpenBSD: fhc.c,v 1.7 2004/09/27 18:32:35 jason Exp $	*/
d52 2
d72 2
d127 3
d305 38
@


1.7
log
@compute the board number of each fhc
@
text
@d1 1
a1 1
/*	$OpenBSD: fhc.c,v 1.6 2004/09/27 18:15:32 jason Exp $	*/
d67 1
a67 1
	printf(" board %d: %s\n", sc->sc_board,
d72 4
d275 2
a276 1
		vec = INTVEC(*intrmapptr);
@


1.6
log
@setup control register correctly and clear interrupts before attaching children
@
text
@d1 1
a1 1
/*	$OpenBSD: fhc.c,v 1.5 2004/09/27 17:28:03 jason Exp $	*/
d67 2
a68 1
	printf(": %s\n", getpropstring(sc->sc_node, "board-model"));
@


1.5
log
@check malloc return correctly; from Patrick Latifi
@
text
@d1 1
a1 1
/*	$OpenBSD: fhc.c,v 1.4 2004/09/24 21:29:36 jason Exp $	*/
d65 1
d70 17
@


1.4
log
@Whoops, need to include the IGN... zs@@fhc now sorta works (kinda...)
@
text
@d1 1
a1 1
/*	$OpenBSD: fhc.c,v 1.3 2004/09/24 20:50:49 jason Exp $	*/
d126 1
a126 1
	if (buf == NULL)
@


1.3
log
@setup interrupt handling for fhc attached devices
@
text
@d1 1
a1 1
/*	$OpenBSD: fhc.c,v 1.2 2004/09/23 16:26:59 jason Exp $	*/
d230 1
d252 3
a254 1
	}
d256 2
a257 2
	ih = bus_intr_allocate(t0, handler, arg, INTINO(ihandle), level,
	    intrmapptr, intrclrptr, what);
@


1.2
log
@- fix the bus_map functions (get the parent node right)
- remove a bunch of debugging goop
@
text
@d1 1
a1 1
/*	$OpenBSD: fhc.c,v 1.1 2004/09/22 21:44:45 jason Exp $	*/
d42 1
d44 1
d55 5
d88 2
d97 2
d152 1
a152 1
	/* XXX bt->sparc_intr_establish = upa_intr_establish; */
d189 82
@


1.1
log
@firehose controller driver (not quite working) for the e4500 (and others)
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a65 8
#if 0
	for (node = 0; node < sc->sc_nrange; node++)
	        printf("%d: cs %08x co %08x ps %08x po %08x sz %08x\n",
	            node, sc->sc_range[node].cspace,
		    sc->sc_range[node].coffset, sc->sc_range[node].pspace,
		    sc->sc_range[node].poffset, sc->sc_range[node].size);
#endif

a81 9
#if 0
		printf("%s registers:\n", fa.fa_name);
		for (i = 0; i < fa.fa_nreg; i++) {
			printf(" %d slot 0x%x offset 0x%x size 0x%x\n", i,
			    fa.fa_reg[i].fbr_slot,
			    fa.fa_reg[i].fbr_offset,
			    fa.fa_reg[i].fbr_size);
		}

a82 1
#endif
d173 1
a173 2
		printf("[fhc %llx]", (unsigned long long)paddr);
		return ((*t->parent->sparc_bus_map)(t, t0, paddr,
@

