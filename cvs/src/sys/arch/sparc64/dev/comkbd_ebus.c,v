head	1.21;
access;
symbols
	OPENBSD_6_0:1.21.0.22
	OPENBSD_6_0_BASE:1.21
	OPENBSD_5_9:1.21.0.18
	OPENBSD_5_9_BASE:1.21
	OPENBSD_5_8:1.21.0.20
	OPENBSD_5_8_BASE:1.21
	OPENBSD_5_7:1.21.0.12
	OPENBSD_5_7_BASE:1.21
	OPENBSD_5_6:1.21.0.16
	OPENBSD_5_6_BASE:1.21
	OPENBSD_5_5:1.21.0.14
	OPENBSD_5_5_BASE:1.21
	OPENBSD_5_4:1.21.0.10
	OPENBSD_5_4_BASE:1.21
	OPENBSD_5_3:1.21.0.8
	OPENBSD_5_3_BASE:1.21
	OPENBSD_5_2:1.21.0.6
	OPENBSD_5_2_BASE:1.21
	OPENBSD_5_1_BASE:1.21
	OPENBSD_5_1:1.21.0.4
	OPENBSD_5_0:1.21.0.2
	OPENBSD_5_0_BASE:1.21
	OPENBSD_4_9:1.20.0.10
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.20.0.8
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.20.0.4
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.20.0.6
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.20.0.2
	OPENBSD_4_5_BASE:1.20
	OPENBSD_4_4:1.18.0.12
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.18.0.10
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.18.0.8
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.18.0.6
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.18.0.4
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.18.0.2
	OPENBSD_3_9_BASE:1.18
	OPENBSD_3_8:1.17.0.2
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.15.0.2
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.14.0.8
	OPENBSD_3_6_BASE:1.14
	SMP_SYNC_A:1.14
	SMP_SYNC_B:1.14
	OPENBSD_3_5:1.14.0.4
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.14.0.2
	OPENBSD_3_4_BASE:1.14
	UBC_SYNC_A:1.11
	OPENBSD_3_3:1.11.0.2
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.7.0.2
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	SMP:1.4.0.2
	UBC:1.2.0.2
	UBC_SYNC_B:1.7;
locks; strict;
comment	@ * @;


1.21
date	2011.03.18.21.01.17;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2009.01.11.16.12.15;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2009.01.11.15.53.58;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2005.11.11.16.44.51;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2005.05.14.15.25.20;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2005.04.05.14.11.16;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2005.03.06.23.23.10;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2003.06.24.21.54.39;	author henric;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.02.20.02.49;	author jason;	state Exp;
branches;
next	1.12;

1.12
date	2003.05.26.07.32.36;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2003.02.17.01.29.20;	author henric;	state Exp;
branches;
next	1.10;

1.10
date	2002.12.22.16.13.30;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2002.12.10.01.22.34;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2002.11.29.01.00.49;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2002.05.29.20.43.43;	author maja;	state Exp;
branches;
next	1.6;

1.6
date	2002.04.08.17.49.42;	author jason;	state Exp;
branches;
next	1.5;

1.5
date	2002.03.14.01.26.44;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2002.02.12.16.53.06;	author jason;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2002.02.01.15.52.06;	author jason;	state Exp;
branches;
next	1.2;

1.2
date	2002.01.25.03.24.53;	author jason;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2002.01.24.15.54.37;	author jason;	state Exp;
branches;
next	;

1.2.2.1
date	2002.01.31.22.55.23;	author niklas;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2002.06.11.03.38.42;	author art;	state Exp;
branches;
next	1.2.2.3;

1.2.2.3
date	2003.05.19.21.46.57;	author tedu;	state Exp;
branches;
next	;

1.4.2.1
date	2002.03.28.10.57.11;	author niklas;	state Exp;
branches;
next	1.4.2.2;

1.4.2.2
date	2003.03.27.23.42.35;	author niklas;	state Exp;
branches;
next	1.4.2.3;

1.4.2.3
date	2003.06.07.11.14.44;	author ho;	state Exp;
branches;
next	1.4.2.4;

1.4.2.4
date	2004.02.19.10.49.59;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.21
log
@Add some delay between a successful keyboard reset sequence and a keyboard
layout inquiry, as some PS/2 converters (at least the Starview SV 125) need
it to behave correctly.
Found the hard way and researched by Mike Malopolski, thanks!
@
text
@/*	$OpenBSD: comkbd_ebus.c,v 1.20 2009/01/11 16:12:15 miod Exp $	*/

/*
 * Copyright (c) 2002 Jason L. Wright (jason@@thought.net)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * Effort sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F30602-01-2-0537.
 *
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/device.h>
#include <sys/conf.h>
#include <sys/file.h>
#include <sys/ioctl.h>
#include <sys/malloc.h>
#include <sys/tty.h>
#include <sys/time.h>
#include <sys/kernel.h>
#include <sys/syslog.h>

#include <machine/bus.h>
#include <machine/autoconf.h>
#include <machine/openfirm.h>

#include <sparc64/dev/ebusreg.h>
#include <sparc64/dev/ebusvar.h>

#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wskbdvar.h>

#include <dev/sun/sunkbdreg.h>
#include <dev/sun/sunkbdvar.h>

#include <dev/ic/comreg.h>
#include <dev/ic/comvar.h>
#include <dev/ic/ns16550reg.h>

#include <dev/cons.h>

#define	COMK_RX_RING	64
#define	COMK_TX_RING	64

struct comkbd_softc {
	struct sunkbd_softc	sc_base;

	bus_space_tag_t sc_iot;		/* bus tag */
	bus_space_handle_t sc_ioh;	/* bus handle */
	void *sc_ih, *sc_si;		/* interrupt vectors */

	u_int sc_rxcnt;
	u_int8_t sc_rxbuf[COMK_RX_RING];
	u_int8_t *sc_rxbeg, *sc_rxend, *sc_rxget, *sc_rxput;

	u_int sc_txcnt;
	u_int8_t sc_txbuf[COMK_TX_RING];
	u_int8_t *sc_txbeg, *sc_txend, *sc_txget, *sc_txput;

	u_int8_t sc_ier;
};

#define	COM_WRITE(sc,r,v) \
    bus_space_write_1((sc)->sc_iot, (sc)->sc_ioh, (r), (v))
#define	COM_READ(sc,r) \
    bus_space_read_1((sc)->sc_iot, (sc)->sc_ioh, (r))

int comkbd_match(struct device *, void *, void *);
void comkbd_attach(struct device *, struct device *, void *);
int comkbd_iskbd(int);

/* wskbd glue */
void comkbd_cnpollc(void *, int);
void comkbd_cngetc(void *, u_int *, int *);

/* internals */
int comkbd_enqueue(void *, u_int8_t *, u_int);
int comkbd_init(struct comkbd_softc *);
void comkbd_putc(struct comkbd_softc *, u_int8_t);
int comkbd_intr(void *);
void comkbd_soft(void *);

struct cfattach comkbd_ca = {
	sizeof(struct comkbd_softc), comkbd_match, comkbd_attach
};

struct cfdriver comkbd_cd = {
	NULL, "comkbd", DV_DULL
};

const char *comkbd_names[] = {
	"su",
	"su_pnp",
	NULL
};

struct wskbd_consops comkbd_consops = {
	comkbd_cngetc,
	comkbd_cnpollc
};

int
comkbd_iskbd(node)
	int node;
{
	if (OF_getproplen(node, "keyboard") == 0)
		return (10);
	return (0);
}

int
comkbd_match(parent, match, aux)
	struct device *parent;
	void *match;
	void *aux;
{
	struct ebus_attach_args *ea = aux;
	int i;

	for (i = 0; comkbd_names[i]; i++)
		if (strcmp(ea->ea_name, comkbd_names[i]) == 0)
			return (comkbd_iskbd(ea->ea_node));

	if (strcmp(ea->ea_name, "serial") == 0) {
		char compat[80];

		if ((i = OF_getproplen(ea->ea_node, "compatible")) &&
		    OF_getprop(ea->ea_node, "compatible", compat,
			sizeof(compat)) == i) {
			if (strcmp(compat, "su16550") == 0 ||
			    strcmp(compat, "su") == 0)
				return (comkbd_iskbd(ea->ea_node));
		}
	}
	return (0);
}

void
comkbd_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct comkbd_softc *sc = (void *)self;
	struct sunkbd_softc *ss = (void *)sc;
	struct ebus_attach_args *ea = aux;
	struct wskbddev_attach_args a;
	int console;

	ss->sc_sendcmd = comkbd_enqueue;
	timeout_set(&ss->sc_bellto, sunkbd_bellstop, sc);

	sc->sc_iot = ea->ea_memtag;

	sc->sc_rxget = sc->sc_rxput = sc->sc_rxbeg = sc->sc_rxbuf;
	sc->sc_rxend = sc->sc_rxbuf + COMK_RX_RING;
	sc->sc_rxcnt = 0;

	sc->sc_txget = sc->sc_txput = sc->sc_txbeg = sc->sc_txbuf;
	sc->sc_txend = sc->sc_txbuf + COMK_TX_RING;
	sc->sc_txcnt = 0;

	console = (ea->ea_node == OF_instance_to_package(OF_stdin()));

	sc->sc_si = softintr_establish(IPL_TTY, comkbd_soft, sc);
	if (sc->sc_si == NULL) {
		printf(": can't get soft intr\n");
		return;
	}

	/* Use prom address if available, otherwise map it. */
	if (ea->ea_nvaddrs && bus_space_map(ea->ea_memtag, ea->ea_vaddrs[0], 0,
	    BUS_SPACE_MAP_PROMADDRESS, &sc->sc_ioh) == 0) {
		sc->sc_iot = ea->ea_memtag;
	} else if (ebus_bus_map(ea->ea_memtag, 0,
	    EBUS_PADDR_FROM_REG(&ea->ea_regs[0]),
	    ea->ea_regs[0].size, 0, 0, &sc->sc_ioh) == 0) {
		sc->sc_iot = ea->ea_memtag;
	} else if (ebus_bus_map(ea->ea_iotag, 0,
	    EBUS_PADDR_FROM_REG(&ea->ea_regs[0]),
	    ea->ea_regs[0].size, 0, 0, &sc->sc_ioh) == 0) {
		sc->sc_iot = ea->ea_iotag;
	} else {
		printf(": can't map register space\n");
                return;
	}

	sc->sc_ih = bus_intr_establish(sc->sc_iot,
	    ea->ea_intrs[0], IPL_TTY, 0, comkbd_intr, sc, self->dv_xname);
	if (sc->sc_ih == NULL) {
		printf(": can't get hard intr\n");
		return;
	}

	if (comkbd_init(sc) == 0) {
		return;
	}

	ss->sc_click =
	    strcmp(getpropstring(optionsnode, "keyboard-click?"), "true") == 0;
	sunkbd_setclick(ss, ss->sc_click);

	a.console = console;
	if (ISTYPE5(ss->sc_layout)) {
		a.keymap = &sunkbd5_keymapdata;
#ifndef SUNKBD5_LAYOUT
		if (ss->sc_layout < MAXSUNLAYOUT &&
		    sunkbd_layouts[ss->sc_layout] != -1)
			sunkbd5_keymapdata.layout =
			    sunkbd_layouts[ss->sc_layout];
#endif
	} else {
		a.keymap = &sunkbd_keymapdata;
#ifndef SUNKBD_LAYOUT
		if (ss->sc_layout < MAXSUNLAYOUT &&
		    sunkbd_layouts[ss->sc_layout] != -1)
			sunkbd_keymapdata.layout =
			    sunkbd_layouts[ss->sc_layout];
#endif
	}
	a.accessops = &sunkbd_accessops;
	a.accesscookie = sc;

	if (console) {
		cn_tab->cn_dev = makedev(77, ss->sc_dev.dv_unit); /* XXX */
		cn_tab->cn_pollc = wskbd_cnpollc;
		cn_tab->cn_getc = wskbd_cngetc;
		wskbd_cnattach(&comkbd_consops, sc, a.keymap);
		sc->sc_ier = IER_ETXRDY | IER_ERXRDY;
		COM_WRITE(sc, com_ier, sc->sc_ier);
		COM_READ(sc, com_iir);
		COM_WRITE(sc, com_mcr, MCR_IENABLE | MCR_DTR | MCR_RTS);
	}

	sunkbd_attach(ss, &a);
}

void
comkbd_cnpollc(vsc, on)
	void *vsc;
	int on;
{
}

void
comkbd_cngetc(v, type, data)
	void *v;
	u_int *type;
	int *data;
{
	struct comkbd_softc *sc = v;
	int s;
	u_int8_t c;

	s = splhigh();
	while (1) {
		if (COM_READ(sc, com_lsr) & LSR_RXRDY)
			break;
	}
	c = COM_READ(sc, com_data);
	COM_READ(sc, com_iir);
	splx(s);

	sunkbd_decode(c, type, data);
}

void
comkbd_putc(sc, c)
	struct comkbd_softc *sc;
	u_int8_t c;
{
	int s, timo;

	s = splhigh();

	timo = 150000;
	while (--timo) {
		if (COM_READ(sc, com_lsr) & LSR_TXRDY)
			break;
	}

	COM_WRITE(sc, com_data, c);
	bus_space_barrier(sc->sc_iot, sc->sc_ioh, 0, COM_NPORTS,
	    BUS_SPACE_BARRIER_READ | BUS_SPACE_BARRIER_WRITE);

	timo = 150000;
	while (--timo) {
		if (COM_READ(sc, com_lsr) & LSR_TXRDY)
			break;
	}

	splx(s);
}

int
comkbd_enqueue(v, buf, buflen)
	void *v;
	u_int8_t *buf;
	u_int buflen;
{
	struct comkbd_softc *sc = v;
	int s;
	u_int i;

	s = spltty();

	/* See if there is room... */
	if ((sc->sc_txcnt + buflen) > COMK_TX_RING) {
		splx(s);
		return (-1);
	}

	for (i = 0; i < buflen; i++) {
		*sc->sc_txget = *buf;
		buf++;
		sc->sc_txcnt++;
		sc->sc_txget++;
		if (sc->sc_txget == sc->sc_txend)
			sc->sc_txget = sc->sc_txbeg;
	}

	comkbd_soft(sc);

	splx(s);
	return (0);
}

void
comkbd_soft(vsc)
	void *vsc;
{
	struct comkbd_softc *sc = vsc;
	struct sunkbd_softc *ss = (void *)sc;
	u_int8_t cbuf[SUNKBD_MAX_INPUT_SIZE], *cptr;
	u_int8_t c;

	cptr = cbuf;
	while (sc->sc_rxcnt) {
		*cptr++ = *sc->sc_rxget;
		if (++sc->sc_rxget == sc->sc_rxend)
			sc->sc_rxget = sc->sc_rxbeg;
		sc->sc_rxcnt--;
		if (cptr - cbuf == sizeof cbuf) {
			sunkbd_input(ss, cbuf, cptr - cbuf);
			cptr = cbuf;
		}
	}
	if (cptr != cbuf)
		sunkbd_input(ss, cbuf, cptr - cbuf);

	if (sc->sc_txcnt) {
		c = sc->sc_ier | IER_ETXRDY;
		if (c != sc->sc_ier) {
			COM_WRITE(sc, com_ier, c);
			sc->sc_ier = c;
		}
		if (COM_READ(sc, com_lsr) & LSR_TXRDY) {
			sc->sc_txcnt--;
			COM_WRITE(sc, com_data, *sc->sc_txput);
			if (++sc->sc_txput == sc->sc_txend)
				sc->sc_txput = sc->sc_txbeg;
		}
	}
}

int
comkbd_intr(vsc)
	void *vsc;
{
	struct comkbd_softc *sc = vsc;
	u_int8_t iir, lsr, data;
	int needsoft = 0;

	/* Nothing to do */
	iir = COM_READ(sc, com_iir);
	if (iir & IIR_NOPEND)
		return (0);

	for (;;) {
		lsr = COM_READ(sc, com_lsr);
		if (lsr & LSR_RXRDY) {
			needsoft = 1;

			do {
				data = COM_READ(sc, com_data);
				if (sc->sc_rxcnt != COMK_RX_RING) {
					*sc->sc_rxput = data;
					if (++sc->sc_rxput == sc->sc_rxend)
						sc->sc_rxput = sc->sc_rxbeg;
					sc->sc_rxcnt++;
				}
				lsr = COM_READ(sc, com_lsr);
			} while (lsr & LSR_RXRDY);
		}

		if (lsr & LSR_TXRDY) {
			if (sc->sc_txcnt == 0) {
				/* Nothing further to send */
				sc->sc_ier &= ~IER_ETXRDY;
				COM_WRITE(sc, com_ier, sc->sc_ier);
			} else
				needsoft = 1;
		}

		iir = COM_READ(sc, com_iir);
		if (iir & IIR_NOPEND)
			break;
	}

	if (needsoft)
		softintr_schedule(sc->sc_si);

	return (1);
}

int
comkbd_init(sc)
	struct comkbd_softc *sc;
{
	struct sunkbd_softc *ss = (void *)sc;
	u_int8_t stat, c;
	int tries;

	for (tries = 5; tries != 0; tries--) {
		int ltries;

		ss->sc_leds = 0;
		ss->sc_layout = -1;

		/* Send reset request */
		comkbd_putc(sc, SKBD_CMD_RESET);

		ltries = 1000;
		while (--ltries > 0) {
			stat = COM_READ(sc,com_lsr);
			if (stat & LSR_RXRDY) {
				c = COM_READ(sc, com_data);
				
				sunkbd_raw(ss, c);
				if (ss->sc_kbdstate == SKBD_STATE_RESET)
					break;
			}
			DELAY(1000);
		}
		if (ltries == 0)
			continue;

		/* Wait for reset to finish. */
		ltries = 1000;
		while (--ltries > 0) {
			stat = COM_READ(sc, com_lsr);
			if (stat & LSR_RXRDY) {
				c = COM_READ(sc, com_data);
				sunkbd_raw(ss, c);
				if (ss->sc_kbdstate == SKBD_STATE_GETKEY)
					break;
			}
			DELAY(1000);
		}
		if (ltries == 0)
			continue;

		/* Some Sun<=>PS/2 converters need some delay here */
		DELAY(5000);

		/* Send layout request */
		comkbd_putc(sc, SKBD_CMD_LAYOUT);

		ltries = 1000;
		while (--ltries > 0) {
			stat = COM_READ(sc, com_lsr);
			if (stat & LSR_RXRDY) {
				c = COM_READ(sc, com_data);
				sunkbd_raw(ss, c);
				if (ss->sc_layout != -1)
					break;
			}
			DELAY(1000);
		}
		if (ltries != 0)
			break;
	}
	if (tries == 0)
		printf(": no keyboard\n");
	else
		printf(": layout %d\n", ss->sc_layout);

	return tries;
}
@


1.20
log
@Define a limit to the input which can be fed to sunkbd_input() at once,
will be necessary for rawkbd mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: comkbd_ebus.c,v 1.19 2009/01/11 15:53:58 miod Exp $	*/
d486 2
@


1.19
log
@Factor a bit more sunkbd common parts; paves the way for upcoming
WSDISPLAY_COMPAT_RAWKBD support.
@
text
@d1 1
a1 1
/*	$OpenBSD: comkbd_ebus.c,v 1.18 2005/11/11 16:44:51 miod Exp $	*/
d357 1
a357 1
	u_int8_t cbuf[COMK_RX_RING], *cptr = cbuf;
d360 1
d366 6
a372 1
	}
@


1.18
log
@Enable or disable keyclick on attach, based upon the PROM keyboard-click?
property.
Tested with type 3 and type 4 keyboards.
@
text
@d1 1
a1 1
/*	$OpenBSD: comkbd_ebus.c,v 1.17 2005/05/14 15:25:20 miod Exp $	*/
d258 1
a258 1
	ss->sc_wskbddev = config_found(self, &a, wskbddevprint);
d357 1
a357 2
	u_int type;
	int value;
d361 1
a361 1
		c = *sc->sc_rxget;
d365 1
a365 2
		sunkbd_decode(c, &type, &value);
		wskbd_input(ss->sc_wskbddev, type, value);
@


1.17
log
@Factorize most of the high-level logic for Sun serial keyboards in
sys/dev/sun/sunkbd.c, and move the layout tables to sys/dev/sun/sunkbdmap.c.

No functional changes, small sparc64 kernel shrinkage.
@
text
@d1 1
a1 1
/*	$OpenBSD: comkbd_ebus.c,v 1.16 2005/04/05 14:11:16 miod Exp $	*/
d221 4
@


1.16
log
@No extra newline if keyboard plugged but not console.
@
text
@d1 1
a1 1
/*	$OpenBSD: comkbd_ebus.c,v 1.15 2005/03/06 23:23:10 miod Exp $	*/
a55 2
#include <dev/wscons/wsksymdef.h>
#include <dev/wscons/wsksymvar.h>
d70 2
a71 1
	struct device sc_dv;		/* us, as a device */
a84 7

	struct device *sc_wskbddev;	/* child wskbd */
	int sc_leds;
	u_int8_t sc_kbdstate;
	int sc_layout;
	int sc_bellactive, sc_belltimeout;
	struct timeout sc_bellto;
a98 4
int comkbd_enable(void *, int);
void comkbd_setleds(void *, int);
int comkbd_getleds(struct comkbd_softc *);
int comkbd_ioctl(void *, u_long, caddr_t, int, struct proc *);
d101 1
a101 2
void comkbd_enqueue(struct comkbd_softc *, u_int8_t *, u_int);
void comkbd_raw(struct comkbd_softc *, u_int8_t);
a105 2
void comkbd_bellstop(void *);
void comkbd_bell(struct comkbd_softc *, u_int, u_int, u_int);
d115 1
a115 1
char *comkbd_names[] = {
a120 6
struct wskbd_accessops comkbd_accessops = {
	comkbd_enable,
	comkbd_setleds,
	comkbd_ioctl
};

d168 1
d173 2
a174 1
	timeout_set(&sc->sc_bellto, comkbd_bellstop, sc);
d223 1
a223 1
	if (ISTYPE5(sc->sc_layout)) {
d226 2
a227 2
		if (sc->sc_layout < MAXSUNLAYOUT &&
		    sunkbd_layouts[sc->sc_layout] != -1)
d229 1
a229 1
			    sunkbd_layouts[sc->sc_layout];
d234 2
a235 2
		if (sc->sc_layout < MAXSUNLAYOUT &&
		    sunkbd_layouts[sc->sc_layout] != -1)
d237 1
a237 1
			    sunkbd_layouts[sc->sc_layout];
d240 1
a240 1
	a.accessops = &comkbd_accessops;
d244 1
a244 1
		cn_tab->cn_dev = makedev(77, sc->sc_dv.dv_unit); /* XXX */
d247 1
a247 7
		if (ISTYPE5(sc->sc_layout)) {
			wskbd_cnattach(&comkbd_consops, sc,
			    &sunkbd5_keymapdata);
		} else {
			wskbd_cnattach(&comkbd_consops, sc,
			    &sunkbd_keymapdata);
		}
d254 1
a254 1
	sc->sc_wskbddev = config_found(self, &a, wskbddevprint);
d283 1
a283 85
	switch (c) {
	case SKBD_RSP_IDLE:
		*type = WSCONS_EVENT_ALL_KEYS_UP;
		*data = 0;
		break;
	default:
		*type = (c & 0x80) ?
		    WSCONS_EVENT_KEY_UP : WSCONS_EVENT_KEY_DOWN;
		*data = c & 0x7f;
		break;
	}
}

int
comkbd_ioctl(v, cmd, data, flag, p)
	void *v;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
{
	struct comkbd_softc *sc = v;
	int *d_int = (int *)data;
	struct wskbd_bell_data *d_bell = (struct wskbd_bell_data *)data;

	switch (cmd) {
	case WSKBDIO_GTYPE:
		if (ISTYPE5(sc->sc_layout)) {
			*d_int = WSKBD_TYPE_SUN5;
		} else {
			*d_int = WSKBD_TYPE_SUN;
		}
		return (0);
	case WSKBDIO_SETLEDS:
		comkbd_setleds(v, *d_int);
		return (0);
	case WSKBDIO_GETLEDS:
		*d_int = comkbd_getleds(sc);
		return (0);
	case WSKBDIO_COMPLEXBELL:
		comkbd_bell(sc, d_bell->period,
		    d_bell->pitch, d_bell->volume);
		return (0);
	}
	return (-1);
}

int
comkbd_enable(vsc, on)
	void *vsc;
	int on;
{
	return (0);
}

int
comkbd_getleds(sc)
	struct comkbd_softc *sc;
{
	return (sc->sc_leds);
}

void
comkbd_setleds(v, wled)
	void *v;
	int wled;
{
	struct comkbd_softc *sc = v;
	u_int8_t sled = 0;
	u_int8_t cmd[2];

	sc->sc_leds = wled;

	if (wled & WSKBD_LED_CAPS)
		sled |= SKBD_LED_CAPSLOCK;
	if (wled & WSKBD_LED_NUM)
		sled |= SKBD_LED_NUMLOCK;
	if (wled & WSKBD_LED_SCROLL)
		sled |= SKBD_LED_SCROLLLOCK;
	if (wled & WSKBD_LED_COMPOSE)
		sled |= SKBD_LED_COMPOSE;

	cmd[0] = SKBD_CMD_SETLED;
	cmd[1] = sled;
	comkbd_enqueue(sc, cmd, sizeof(cmd));
d314 3
a316 3
void
comkbd_enqueue(sc, buf, buflen)
	struct comkbd_softc *sc;
d320 1
d327 4
a330 2
	if ((sc->sc_txcnt + buflen) > COMK_TX_RING)
		return;
d344 1
d352 1
d362 2
a363 12
		switch (c) {
		case SKBD_RSP_IDLE:
			type = WSCONS_EVENT_ALL_KEYS_UP;
			value = 0;
			break;
		default:
			type = (c & 0x80) ?
			    WSCONS_EVENT_KEY_UP : WSCONS_EVENT_KEY_DOWN;
			value = c & 0x7f;
			break;
		}
		wskbd_input(sc->sc_wskbddev, type, value);
d435 1
d442 2
a443 2
		sc->sc_leds = 0;
		sc->sc_layout = -1;
d454 2
a455 2
				comkbd_raw(sc, c);
				if (sc->sc_kbdstate == SKBD_STATE_RESET)
d469 2
a470 2
				comkbd_raw(sc, c);
				if (sc->sc_kbdstate == SKBD_STATE_GETKEY)
d487 2
a488 2
				comkbd_raw(sc, c);
				if (sc->sc_layout != -1)
d499 1
a499 1
		printf(": layout %d\n", sc->sc_layout);
a501 89
}

void
comkbd_raw(sc, c)
	struct comkbd_softc *sc;
	u_int8_t c;
{
	int claimed = 0;

	if (sc->sc_kbdstate == SKBD_STATE_LAYOUT) {
		sc->sc_kbdstate = SKBD_STATE_GETKEY;
		sc->sc_layout = c;
		return;
	}

	switch (c) {
	case SKBD_RSP_RESET:
		sc->sc_kbdstate = SKBD_STATE_RESET;
		claimed = 1;
		break;
	case SKBD_RSP_LAYOUT:
		sc->sc_kbdstate = SKBD_STATE_LAYOUT;
		claimed = 1;
		break;
	case SKBD_RSP_IDLE:
		sc->sc_kbdstate = SKBD_STATE_GETKEY;
		claimed = 1;
	}

	if (claimed)
		return;

	switch (sc->sc_kbdstate) {
	case SKBD_STATE_RESET:
		sc->sc_kbdstate = SKBD_STATE_GETKEY;
		if (c != SKBD_RSP_RESET_OK)
			printf("%s: reset1 invalid code 0x%02x\n",
			    sc->sc_dv.dv_xname, c);
		break;
	case SKBD_STATE_GETKEY:
		break;
	}
}

void
comkbd_bell(sc, period, pitch, volume)
	struct comkbd_softc *sc;
	u_int period, pitch, volume;
{
	int ticks, s;
	u_int8_t c = SKBD_CMD_BELLON;

	ticks = (period * hz)/1000;
	if (ticks <= 0)
		ticks = 1;

	s = spltty();
	if (sc->sc_bellactive) {
		if (sc->sc_belltimeout == 0)
			timeout_del(&sc->sc_bellto);
	}
	if (pitch == 0 || period == 0) {
		comkbd_bellstop(sc);
		splx(s);
		return;
	}
	if (!sc->sc_bellactive) {
		sc->sc_bellactive = 1;
		sc->sc_belltimeout = 1;
		comkbd_enqueue(sc, &c, 1);
		timeout_add(&sc->sc_bellto, ticks);
	}
	splx(s);
}

void
comkbd_bellstop(v)
	void *v;
{
	struct comkbd_softc *sc = v;
	int s;
	u_int8_t c;

	s = spltty();
	sc->sc_belltimeout = 0;
	c = SKBD_CMD_BELLOFF;
	comkbd_enqueue(sc, &c, 1);
	sc->sc_bellactive = 0;
	splx(s);
@


1.15
log
@Shorten dmesg if no keyboard is plugged.
@
text
@d1 1
a1 1
/*	$OpenBSD: comkbd_ebus.c,v 1.14 2003/06/24 21:54:39 henric Exp $	*/
d277 1
a277 2
	} else
		printf("\n");
@


1.14
log
@Add a "where" argument to the sparc64 interrupt code.  This lets us
associate a name with each interrupt handler.  This is not visible
outside the kernel (yet).

ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: comkbd_ebus.c,v 1.13 2003/06/02 20:02:49 jason Exp $	*/
d237 1
a237 2
	if (!comkbd_init(sc)) {
		printf("%s: no keyboard\n", self->dv_xname);
d611 1
a611 1
		printf(": reset timeout\n");
@


1.13
log
@nuke terms 3 & 4
@
text
@d1 1
a1 1
/*	$OpenBSD: comkbd_ebus.c,v 1.12 2003/05/26 07:32:36 miod Exp $	*/
d231 1
a231 1
	    ea->ea_intrs[0], IPL_TTY, 0, comkbd_intr, sc);
@


1.12
log
@Make sure to do the keyboard layout selection dance before wskbd_cnattach()
is invoked.
@
text
@d1 1
a1 1
/*	$OpenBSD: comkbd_ebus.c,v 1.11 2003/02/17 01:29:20 henric Exp $	*/
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Jason L. Wright
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.11
log
@
Add support for the Sun Enterprise 450
Reduce the size of a GENERIC kernel by ~190k
Remove the nasty pointer/bus_space_handle_t casts
Adds debug bus_space code including the ability to trace
    bus operations (it actually works now).

The following rules are now followed (and verfified by the debug
code):

1.  A "bus_space_handle_t" may only be used with the
    "bus_space_tag_t" that created it.
2.  Only "bus_space_map()" may create "bus_space_handle_t"s.
3.  A "bus_space_handle_t" may not be modified after it has
    been created (other than being destroyed by "bus_space_unmap()").


Thanks to help from mcbride, marc, jason, drahn, to anyone that might
have slipped my mind at the moment.

ok jason@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: comkbd_ebus.c,v 1.10 2002/12/22 16:13:30 miod Exp $	*/
d120 1
a120 1
void comkbd_init(struct comkbd_softc *);
d242 4
a245 18
	if (console) {
		comkbd_init(sc);
		cn_tab->cn_dev = makedev(77, sc->sc_dv.dv_unit); /* XXX */
		cn_tab->cn_pollc = wskbd_cnpollc;
		cn_tab->cn_getc = wskbd_cngetc;
		if (ISTYPE5(sc->sc_layout)) {
			wskbd_cnattach(&comkbd_consops, sc,
			    &sunkbd5_keymapdata);
		} else {
			wskbd_cnattach(&comkbd_consops, sc,
			    &sunkbd_keymapdata);
		}
		sc->sc_ier = IER_ETXRDY | IER_ERXRDY;
		COM_WRITE(sc, com_ier, sc->sc_ier);
		COM_READ(sc, com_iir);
		COM_WRITE(sc, com_mcr, MCR_IENABLE | MCR_DTR | MCR_RTS);
	} else
		printf("\n");
d267 19
d552 1
a552 1
void
d620 2
@


1.10
log
@Do not attempt to select keyboard layout until it has been determined from
the keyboard (oops).  This also fixes a bad interaction with wskbd_cnattach
that would hose the underlying sabtty device.
@
text
@d1 1
a1 1
/*	$OpenBSD: comkbd_ebus.c,v 1.7 2002/05/29 20:43:43 maja Exp $	*/
d200 1
a200 1
	sc->sc_iot = ea->ea_bustag;
d218 18
a235 1
	sc->sc_ih = bus_intr_establish(ea->ea_bustag,
a241 12
	/* Use prom address if available, otherwise map it. */
	if (ea->ea_nvaddrs)
		sc->sc_ioh = (bus_space_handle_t)ea->ea_vaddrs[0];
	else if (ebus_bus_map(sc->sc_iot, 0,
			      EBUS_PADDR_FROM_REG(&ea->ea_regs[0]),
			      ea->ea_regs[0].size,
			      BUS_SPACE_MAP_LINEAR,
			      0, &sc->sc_ioh) != 0) {
		printf(": can't map register space\n");
                return;
	}

d248 2
a249 1
			wskbd_cnattach(&comkbd_consops, sc, &sunkbd5_keymapdata);
d251 2
a252 1
			wskbd_cnattach(&comkbd_consops, sc, &sunkbd_keymapdata);
@


1.9
log
@Fix spurious \n in dmesg output
@
text
@d1 1
a1 1
/*	$OpenBSD: comkbd_ebus.c,v 1.8 2002/11/29 01:00:49 miod Exp $	*/
d237 18
d257 1
a257 1
#ifndef	SUNKBD5_LAYOUT
d265 1
a265 1
#ifndef	SUNKBD_LAYOUT
a273 18

	if (console) {
		comkbd_init(sc);
		cn_tab->cn_dev = makedev(77, sc->sc_dv.dv_unit); /* XXX */
		cn_tab->cn_pollc = wskbd_cnpollc;
		cn_tab->cn_getc = wskbd_cngetc;
		if (ISTYPE5(sc->sc_layout)) {
			wskbd_cnattach(&comkbd_consops, sc, &sunkbd5_keymapdata);
		} else {
			wskbd_cnattach(&comkbd_consops, sc, &sunkbd_keymapdata);
		}
		sc->sc_ier = IER_ETXRDY | IER_ERXRDY;
		COM_WRITE(sc, com_ier, sc->sc_ier);
		COM_READ(sc, com_iir);
		COM_WRITE(sc, com_mcr, MCR_IENABLE | MCR_DTR | MCR_RTS);
	} else
		printf("\n");

@


1.8
log
@Upon detection of an international Sun keyboard with a recognized layout,
attach it with the appropriate keymap table, rather than the default KB_US
table.

If this is not the expected behaviour, users can still revert to US layout
via "kbd us" or "wsconsctl -w keyboard.encoding=us".

As the installation media uses the prom console, which will honor the
international keyboard layout, this will definitely help users with
international keyboards and fancy characters in their passwords...

Note that there is still some Sun keyboard tables missing at the moment.
@
text
@d1 1
a1 1
/*	$OpenBSD: comkbd_ebus.c,v 1.7 2002/05/29 20:43:43 maja Exp $	*/
d235 1
a235 2
	} else
		printf("\n");
d271 2
a272 1
	}
@


1.7
log
@Add a new wskbd type for Sun type 5 keyboards (WSKBD_TYPE_SUN5).
This is needed since eg Swedish type 4 and 5 keyboard has keycodes
with different keycodes. eg AltGr and Compose are switched in type 5
compared with type 4.

This change will need a new Xserver to allow sun type 5 keyboards.
-moj  ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: comkbd_ebus.c,v 1.6 2002/04/08 17:49:42 jason Exp $	*/
d235 19
d255 2
d272 1
a272 3
	} else
		printf("\n");

a273 8
	a.console = console;
	if (ISTYPE5(sc->sc_layout)) {
		a.keymap = &sunkbd5_keymapdata;
	} else {
		a.keymap = &sunkbd_keymapdata;
	}
	a.accessops = &comkbd_accessops;
	a.accesscookie = sc;
@


1.6
log
@Credit DARPA/USAF appropriately.
@
text
@d1 1
a1 1
/*	$OpenBSD: comkbd_ebus.c,v 1.5 2002/03/14 01:26:44 millert Exp $	*/
d242 5
a246 1
		wskbd_cnattach(&comkbd_consops, sc, &sunkbd_keymapdata);
d256 5
a260 1
	a.keymap = &sunkbd_keymapdata;
d319 5
a323 1
		*d_int = WSKBD_TYPE_SUN;
@


1.5
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: comkbd_ebus.c,v 1.4 2002/02/12 16:53:06 jason Exp $	*/
d32 5
@


1.4
log
@beep!
@
text
@d1 1
a1 1
/*	$OpenBSD: comkbd_ebus.c,v 1.3 2002/02/01 15:52:06 jason Exp $	*/
d100 3
a102 3
int comkbd_match __P((struct device *, void *, void *));
void comkbd_attach __P((struct device *, struct device *, void *));
int comkbd_iskbd __P((int));
d105 6
a110 6
void comkbd_cnpollc __P((void *, int));
void comkbd_cngetc __P((void *, u_int *, int *));
int comkbd_enable __P((void *, int));
void comkbd_setleds __P((void *, int));
int comkbd_getleds __P((struct comkbd_softc *));
int comkbd_ioctl __P((void *, u_long, caddr_t, int, struct proc *));
d113 8
a120 8
void comkbd_enqueue __P((struct comkbd_softc *, u_int8_t *, u_int));
void comkbd_raw __P((struct comkbd_softc *, u_int8_t));
void comkbd_init __P((struct comkbd_softc *));
void comkbd_putc __P((struct comkbd_softc *, u_int8_t));
int comkbd_intr __P((void *));
void comkbd_soft __P((void *));
void comkbd_bellstop __P((void *));
void comkbd_bell __P((struct comkbd_softc *, u_int, u_int, u_int));
@


1.4.2.1
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d100 3
a102 3
int comkbd_match(struct device *, void *, void *);
void comkbd_attach(struct device *, struct device *, void *);
int comkbd_iskbd(int);
d105 6
a110 6
void comkbd_cnpollc(void *, int);
void comkbd_cngetc(void *, u_int *, int *);
int comkbd_enable(void *, int);
void comkbd_setleds(void *, int);
int comkbd_getleds(struct comkbd_softc *);
int comkbd_ioctl(void *, u_long, caddr_t, int, struct proc *);
d113 8
a120 8
void comkbd_enqueue(struct comkbd_softc *, u_int8_t *, u_int);
void comkbd_raw(struct comkbd_softc *, u_int8_t);
void comkbd_init(struct comkbd_softc *);
void comkbd_putc(struct comkbd_softc *, u_int8_t);
int comkbd_intr(void *);
void comkbd_soft(void *);
void comkbd_bellstop(void *);
void comkbd_bell(struct comkbd_softc *, u_int, u_int, u_int);
@


1.4.2.2
log
@Sync the SMP branch with 3.3
@
text
@a31 5
 *
 * Effort sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F30602-01-2-0537.
 *
d195 1
a195 1
	sc->sc_iot = ea->ea_memtag;
d213 1
a213 18
	/* Use prom address if available, otherwise map it. */
	if (ea->ea_nvaddrs && bus_space_map(ea->ea_memtag, ea->ea_vaddrs[0], 0,
	    BUS_SPACE_MAP_PROMADDRESS, &sc->sc_ioh) == 0) {
		sc->sc_iot = ea->ea_memtag;
	} else if (ebus_bus_map(ea->ea_memtag, 0,
	    EBUS_PADDR_FROM_REG(&ea->ea_regs[0]),
	    ea->ea_regs[0].size, 0, 0, &sc->sc_ioh) == 0) {
		sc->sc_iot = ea->ea_memtag;
	} else if (ebus_bus_map(ea->ea_iotag, 0,
	    EBUS_PADDR_FROM_REG(&ea->ea_regs[0]),
	    ea->ea_regs[0].size, 0, 0, &sc->sc_ioh) == 0) {
		sc->sc_iot = ea->ea_iotag;
	} else {
		printf(": can't map register space\n");
                return;
	}

	sc->sc_ih = bus_intr_establish(sc->sc_iot,
d220 12
d237 1
a237 7
		if (ISTYPE5(sc->sc_layout)) {
			wskbd_cnattach(&comkbd_consops, sc,
			    &sunkbd5_keymapdata);
		} else {
			wskbd_cnattach(&comkbd_consops, sc,
			    &sunkbd_keymapdata);
		}
d245 1
d247 1
a247 17
	if (ISTYPE5(sc->sc_layout)) {
		a.keymap = &sunkbd5_keymapdata;
#ifndef SUNKBD5_LAYOUT
		if (sc->sc_layout < MAXSUNLAYOUT &&
		    sunkbd_layouts[sc->sc_layout] != -1)
			sunkbd5_keymapdata.layout =
			    sunkbd_layouts[sc->sc_layout];
#endif
	} else {
		a.keymap = &sunkbd_keymapdata;
#ifndef SUNKBD_LAYOUT
		if (sc->sc_layout < MAXSUNLAYOUT &&
		    sunkbd_layouts[sc->sc_layout] != -1)
			sunkbd_keymapdata.layout =
			    sunkbd_layouts[sc->sc_layout];
#endif
	}
d306 1
a306 5
		if (ISTYPE5(sc->sc_layout)) {
			*d_int = WSKBD_TYPE_SUN5;
		} else {
			*d_int = WSKBD_TYPE_SUN;
		}
@


1.4.2.3
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: comkbd_ebus.c,v 1.4.2.2 2003/03/27 23:42:35 niklas Exp $	*/
d15 5
d120 1
a120 1
int comkbd_init(struct comkbd_softc *);
d242 18
a259 4
	if (!comkbd_init(sc)) {
		printf("%s: no keyboard\n", self->dv_xname);
		return;
	}
a280 19

	if (console) {
		cn_tab->cn_dev = makedev(77, sc->sc_dv.dv_unit); /* XXX */
		cn_tab->cn_pollc = wskbd_cnpollc;
		cn_tab->cn_getc = wskbd_cngetc;
		if (ISTYPE5(sc->sc_layout)) {
			wskbd_cnattach(&comkbd_consops, sc,
			    &sunkbd5_keymapdata);
		} else {
			wskbd_cnattach(&comkbd_consops, sc,
			    &sunkbd_keymapdata);
		}
		sc->sc_ier = IER_ETXRDY | IER_ERXRDY;
		COM_WRITE(sc, com_ier, sc->sc_ier);
		COM_READ(sc, com_iir);
		COM_WRITE(sc, com_mcr, MCR_IENABLE | MCR_DTR | MCR_RTS);
	} else
		printf("\n");

d547 1
a547 1
int
a614 2

	return tries;
@


1.4.2.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d231 1
a231 1
	    ea->ea_intrs[0], IPL_TTY, 0, comkbd_intr, sc, self->dv_xname);
@


1.3
log
@missing \n
@
text
@d1 1
a1 1
/*	$OpenBSD: comkbd_ebus.c,v 1.2 2002/01/25 03:24:53 jason Exp $	*/
d91 2
d109 1
a109 1
int comkbd_getleds __P((void *));
d119 2
d193 2
a231 2
	printf("\n");

d242 3
a244 1
	}
d300 4
d306 1
a306 1
		*(int *)data = WSKBD_TYPE_SUN;
d309 1
a309 1
		comkbd_setleds(v, *(int *)data);
d312 5
a316 1
		*(int *)data = comkbd_getleds(v);
d331 2
a332 2
comkbd_getleds(v)
	void *v;
a333 2
	struct comkbd_softc *sc = v;

d622 47
@


1.2
log
@move the scancode -> wskbd event map into a seperate file... more still
to move, though.
@
text
@d1 1
a1 1
/*	$OpenBSD: comkbd_ebus.c,v 1.1 2002/01/24 15:54:37 jason Exp $	*/
d225 2
@


1.2.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: comkbd_ebus.c,v 1.2 2002/01/25 03:24:53 jason Exp $	*/
@


1.2.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: comkbd_ebus.c,v 1.2.2.1 2002/01/31 22:55:23 niklas Exp $	*/
a31 5
 *
 * Effort sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F30602-01-2-0537.
 *
a90 2
	int sc_bellactive, sc_belltimeout;
	struct timeout sc_bellto;
d98 3
a100 3
int comkbd_match(struct device *, void *, void *);
void comkbd_attach(struct device *, struct device *, void *);
int comkbd_iskbd(int);
d103 6
a108 6
void comkbd_cnpollc(void *, int);
void comkbd_cngetc(void *, u_int *, int *);
int comkbd_enable(void *, int);
void comkbd_setleds(void *, int);
int comkbd_getleds(struct comkbd_softc *);
int comkbd_ioctl(void *, u_long, caddr_t, int, struct proc *);
d111 6
a116 8
void comkbd_enqueue(struct comkbd_softc *, u_int8_t *, u_int);
void comkbd_raw(struct comkbd_softc *, u_int8_t);
void comkbd_init(struct comkbd_softc *);
void comkbd_putc(struct comkbd_softc *, u_int8_t);
int comkbd_intr(void *);
void comkbd_soft(void *);
void comkbd_bellstop(void *);
void comkbd_bell(struct comkbd_softc *, u_int, u_int, u_int);
a188 2
	timeout_set(&sc->sc_bellto, comkbd_bellstop, sc);

d231 1
a231 5
		if (ISTYPE5(sc->sc_layout)) {
			wskbd_cnattach(&comkbd_consops, sc, &sunkbd5_keymapdata);
		} else {
			wskbd_cnattach(&comkbd_consops, sc, &sunkbd_keymapdata);
		}
d236 1
a236 3
	} else
		printf("\n");

d239 1
a239 5
	if (ISTYPE5(sc->sc_layout)) {
		a.keymap = &sunkbd5_keymapdata;
	} else {
		a.keymap = &sunkbd_keymapdata;
	}
a291 4
	struct comkbd_softc *sc = v;
	int *d_int = (int *)data;
	struct wskbd_bell_data *d_bell = (struct wskbd_bell_data *)data;

d294 1
a294 5
		if (ISTYPE5(sc->sc_layout)) {
			*d_int = WSKBD_TYPE_SUN5;
		} else {
			*d_int = WSKBD_TYPE_SUN;
		}
d297 1
a297 1
		comkbd_setleds(v, *d_int);
d300 1
a300 5
		*d_int = comkbd_getleds(sc);
		return (0);
	case WSKBDIO_COMPLEXBELL:
		comkbd_bell(sc, d_bell->period,
		    d_bell->pitch, d_bell->volume);
d315 2
a316 2
comkbd_getleds(sc)
	struct comkbd_softc *sc;
d318 2
a607 47
}

void
comkbd_bell(sc, period, pitch, volume)
	struct comkbd_softc *sc;
	u_int period, pitch, volume;
{
	int ticks, s;
	u_int8_t c = SKBD_CMD_BELLON;

	ticks = (period * hz)/1000;
	if (ticks <= 0)
		ticks = 1;

	s = spltty();
	if (sc->sc_bellactive) {
		if (sc->sc_belltimeout == 0)
			timeout_del(&sc->sc_bellto);
	}
	if (pitch == 0 || period == 0) {
		comkbd_bellstop(sc);
		splx(s);
		return;
	}
	if (!sc->sc_bellactive) {
		sc->sc_bellactive = 1;
		sc->sc_belltimeout = 1;
		comkbd_enqueue(sc, &c, 1);
		timeout_add(&sc->sc_bellto, ticks);
	}
	splx(s);
}

void
comkbd_bellstop(v)
	void *v;
{
	struct comkbd_softc *sc = v;
	int s;
	u_int8_t c;

	s = spltty();
	sc->sc_belltimeout = 0;
	c = SKBD_CMD_BELLOFF;
	comkbd_enqueue(sc, &c, 1);
	sc->sc_bellactive = 0;
	splx(s);
@


1.2.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d200 1
a200 1
	sc->sc_iot = ea->ea_memtag;
d218 1
a218 18
	/* Use prom address if available, otherwise map it. */
	if (ea->ea_nvaddrs && bus_space_map(ea->ea_memtag, ea->ea_vaddrs[0], 0,
	    BUS_SPACE_MAP_PROMADDRESS, &sc->sc_ioh) == 0) {
		sc->sc_iot = ea->ea_memtag;
	} else if (ebus_bus_map(ea->ea_memtag, 0,
	    EBUS_PADDR_FROM_REG(&ea->ea_regs[0]),
	    ea->ea_regs[0].size, 0, 0, &sc->sc_ioh) == 0) {
		sc->sc_iot = ea->ea_memtag;
	} else if (ebus_bus_map(ea->ea_iotag, 0,
	    EBUS_PADDR_FROM_REG(&ea->ea_regs[0]),
	    ea->ea_regs[0].size, 0, 0, &sc->sc_ioh) == 0) {
		sc->sc_iot = ea->ea_iotag;
	} else {
		printf(": can't map register space\n");
                return;
	}

	sc->sc_ih = bus_intr_establish(sc->sc_iot,
d225 12
d243 1
a243 2
			wskbd_cnattach(&comkbd_consops, sc,
			    &sunkbd5_keymapdata);
d245 1
a245 2
			wskbd_cnattach(&comkbd_consops, sc,
			    &sunkbd_keymapdata);
d254 1
a257 6
#ifndef SUNKBD5_LAYOUT
		if (sc->sc_layout < MAXSUNLAYOUT &&
		    sunkbd_layouts[sc->sc_layout] != -1)
			sunkbd5_keymapdata.layout =
			    sunkbd_layouts[sc->sc_layout];
#endif
a259 6
#ifndef SUNKBD_LAYOUT
		if (sc->sc_layout < MAXSUNLAYOUT &&
		    sunkbd_layouts[sc->sc_layout] != -1)
			sunkbd_keymapdata.layout =
			    sunkbd_layouts[sc->sc_layout];
#endif
@


1.1
log
@Add a driver for keyboards on com (ns16550 clones) as found on the AXi, etc.
Also, add the necessary config goop
Finally, enable com* at ebus?, comkbd* at ebus?, and vgafb* at pci?
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d59 3
a67 150
/* keyboard commands (host->kbd) */
#define	SKBD_CMD_RESET		0x01
#define	SKBD_CMD_BELLON		0x02
#define	SKBD_CMD_BELLOFF	0x03
#define	SKBD_CMD_CLICKON	0x0a
#define	SKBD_CMD_CLICKOFF	0x0b
#define	SKBD_CMD_SETLED		0x0e
#define	SKBD_CMD_LAYOUT		0x0f

/* keyboard responses (kbd->host) */
#define	SKBD_RSP_RESET_OK	0x04	/* normal reset status */
#define	SKBD_RSP_IDLE		0x7f	/* no keys down */
#define	SKBD_RSP_LAYOUT		0xfe	/* layout follows */
#define	SKBD_RSP_RESET		0xff	/* reset status follows */

#define	SKBD_LED_NUMLOCK	0x01
#define	SKBD_LED_COMPOSE	0x02
#define	SKBD_LED_SCROLLLOCK	0x04
#define	SKBD_LED_CAPSLOCK	0x08

#define	SKBD_STATE_RESET	0
#define	SKBD_STATE_LAYOUT	1
#define	SKBD_STATE_GETKEY	2

#define	KC(n)	KS_KEYCODE(n)
const keysym_t comkbd_keydesc_us[] = {
    KC(0x01), KS_Cmd,
    KC(0x02), KS_Cmd_BrightnessDown,
    KC(0x04), KS_Cmd_BrightnessUp,
    KC(0x05),				KS_f1,
    KC(0x06),				KS_f2,
    KC(0x07),				KS_f10,
    KC(0x08),				KS_f3,
    KC(0x09),				KS_f11,
    KC(0x0a),				KS_f4,
    KC(0x0b),				KS_f12,
    KC(0x0c),				KS_f5,
    KC(0x0d),				KS_Alt_R,
    KC(0x0e),				KS_f6,
    KC(0x10),				KS_f7,
    KC(0x11),				KS_f8,
    KC(0x12),				KS_f9,
    KC(0x13),				KS_Alt_L,
    KC(0x14),				KS_Up,
    KC(0x15),				KS_Pause,
    KC(0x16),				KS_Print_Screen,
    KC(0x18),				KS_Left,
    KC(0x19),				KS_Hold_Screen,
    KC(0x1b),				KS_Down,
    KC(0x1c),				KS_Right,
    KC(0x1d),				KS_Escape,
    KC(0x1e),				KS_1,		KS_exclam,
    KC(0x1f),				KS_2,		KS_at,
    KC(0x20),				KS_3,		KS_numbersign,
    KC(0x21),				KS_4,		KS_dollar,
    KC(0x22),				KS_5,		KS_percent,
    KC(0x23),				KS_6,		KS_asciicircum,
    KC(0x24),				KS_7,		KS_ampersand,
    KC(0x25),				KS_8,		KS_asterisk,
    KC(0x26),				KS_9,		KS_parenleft,
    KC(0x27),				KS_0,		KS_parenright,
    KC(0x28),				KS_minus,	KS_underscore,
    KC(0x29),				KS_equal,	KS_plus,
    KC(0x2a),				KS_grave,	KS_asciitilde,
    KC(0x2b),				KS_BackSpace,
    KC(0x2c),				KS_Insert,
    KC(0x2d),				KS_KP_Equal,
    KC(0x2e),				KS_KP_Divide,
    KC(0x2f),				KS_KP_Multiply,
    KC(0x32),				KS_KP_Delete,
    KC(0x34),				KS_Home,
    KC(0x35),				KS_Tab,
    KC(0x36),				KS_q,
    KC(0x37),				KS_w,
    KC(0x38),				KS_e,
    KC(0x39),				KS_r,
    KC(0x3a),				KS_t,
    KC(0x3b),				KS_y,
    KC(0x3c),				KS_u,
    KC(0x3d),				KS_i,
    KC(0x3e),				KS_o,
    KC(0x3f),				KS_p,
    KC(0x40),				KS_bracketleft,	KS_braceleft,
    KC(0x41),				KS_bracketright,KS_braceright,
    KC(0x42),				KS_Delete,
    KC(0x43),				KS_Multi_key,
    KC(0x44),				KS_KP_Home,	KS_KP_7,
    KC(0x45),				KS_KP_Up,	KS_KP_8,
    KC(0x46),				KS_KP_Prior,	KS_KP_9,
    KC(0x47),				KS_KP_Subtract,
    KC(0x4a),				KS_End,
    KC(0x4c),				KS_Control_L,
    KC(0x4d), KS_Cmd_Debugger,		KS_a,
    KC(0x4e),				KS_s,
    KC(0x4f),				KS_d,
    KC(0x50),				KS_f,
    KC(0x51),				KS_g,
    KC(0x52),				KS_h,
    KC(0x53),				KS_j,
    KC(0x54),				KS_k,
    KC(0x55),				KS_l,
    KC(0x56),				KS_semicolon,	KS_colon,
    KC(0x57),				KS_apostrophe,	KS_quotedbl,
    KC(0x58),				KS_backslash,	KS_bar,
    KC(0x59),				KS_Return,
    KC(0x5a),				KS_KP_Enter,
    KC(0x5b),				KS_KP_Left,	KS_KP_4,
    KC(0x5c),				KS_KP_Begin,	KS_KP_5,
    KC(0x5d),				KS_KP_Right,	KS_KP_6,
    KC(0x5e),				KS_KP_Insert,	KS_KP_0,
    KC(0x5f),				KS_Find,
    KC(0x60),				KS_Prior,
    KC(0x62),				KS_Num_Lock,
    KC(0x63),				KS_Shift_L,
    KC(0x64),				KS_z,
    KC(0x65),				KS_x,
    KC(0x66),				KS_c,
    KC(0x67),				KS_v,
    KC(0x68),				KS_b,
    KC(0x69),				KS_n,
    KC(0x6a),				KS_m,
    KC(0x6b),				KS_comma,	KS_less,
    KC(0x6c),				KS_period,	KS_greater,
    KC(0x6d),				KS_slash,	KS_question,
    KC(0x6e),				KS_Shift_R,
    KC(0x6f),				KS_Linefeed,
    KC(0x70),				KS_KP_End,	KS_KP_1,
    KC(0x71),				KS_KP_Down,	KS_KP_2,
    KC(0x72),				KS_KP_Next,	KS_KP_3,
    KC(0x76),				KS_Help,
    KC(0x77),				KS_Caps_Lock,
    KC(0x78),				KS_Meta_L,
    KC(0x79),				KS_space,
    KC(0x7a),				KS_Meta_R,
    KC(0x7b),				KS_Next,
    KC(0x7d),				KS_KP_Add,
};

#define KBD_MAP(name, base, map) \
    { name, base, sizeof(map)/sizeof(keysym_t), map }

const struct wscons_keydesc comkbd_keydesctab[] = {
	KBD_MAP(KB_US, 0, comkbd_keydesc_us),
	{0, 0, 0, 0},
};

struct wskbd_mapdata comkbd_keymapdata = {
	comkbd_keydesctab, KB_US
};

d231 1
a231 1
		wskbd_cnattach(&comkbd_consops, sc, &comkbd_keymapdata);
d239 1
a239 1
	a.keymap = &comkbd_keymapdata;
@

