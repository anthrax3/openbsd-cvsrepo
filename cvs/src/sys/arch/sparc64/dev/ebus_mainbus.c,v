head	1.10;
access;
symbols
	OPENBSD_6_2_BASE:1.10
	OPENBSD_6_1:1.10.0.4
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.9.0.4
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.2
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.8.0.14
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.6
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.10
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.8
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.4
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.2
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.7.0.8
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.6
	OPENBSD_5_0:1.7.0.4
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.2
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.6.0.10
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.6
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.8
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.4
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.2
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.4.0.2
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.3.0.2
	OPENBSD_4_2_BASE:1.3;
locks; strict;
comment	@ * @;


1.10
date	2016.08.23.03.28.01;	author guenther;	state Exp;
branches;
next	1.9;
commitid	sVHD5kblxhZITIq0;

1.9
date	2015.09.27.11.29.20;	author kettenis;	state Exp;
branches;
next	1.8;
commitid	Um3BvP4zKyWaKQpf;

1.8
date	2012.08.17.20.41.27;	author kettenis;	state Exp;
branches;
next	1.7;

1.7
date	2010.11.11.17.58.23;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2008.04.03.19.41.20;	author kettenis;	state Exp;
branches;
next	1.5;

1.5
date	2008.04.03.18.08.04;	author kettenis;	state Exp;
branches;
next	1.4;

1.4
date	2007.09.17.01.33.33;	author krw;	state Exp;
branches;
next	1.3;

1.3
date	2007.04.07.20.15.54;	author kettenis;	state Exp;
branches;
next	1.2;

1.2
date	2007.04.05.19.14.00;	author kettenis;	state Exp;
branches;
next	1.1;

1.1
date	2007.04.04.18.38.54;	author kettenis;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Convert %q to %ll in format strings

ok natano@@ krw@@
@
text
@/*	$OpenBSD: ebus_mainbus.c,v 1.9 2015/09/27 11:29:20 kettenis Exp $	*/

/*
 * Copyright (c) 2007 Mark Kettenis
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#ifdef DEBUG
#define	EDB_PROM	0x01
#define EDB_CHILD	0x02
#define	EDB_INTRMAP	0x04
#define EDB_BUSMAP	0x08
#define EDB_BUSDMA	0x10
#define EDB_INTR	0x20
extern int ebus_debug;
#define DPRINTF(l, s)   do { if (ebus_debug & l) printf s; } while (0)
#else
#define DPRINTF(l, s)
#endif

#include <sys/param.h>
#include <sys/conf.h>
#include <sys/device.h>
#include <sys/errno.h>
#include <sys/extent.h>
#include <sys/malloc.h>
#include <sys/systm.h>
#include <sys/time.h>

#define _SPARC_BUS_DMA_PRIVATE
#include <machine/bus.h>
#include <machine/autoconf.h>
#include <machine/hypervisor.h>
#include <machine/openfirm.h>

#include <dev/pci/pcivar.h>

#include <sparc64/dev/iommureg.h>
#include <sparc64/dev/ebusreg.h>
#include <sparc64/dev/ebusvar.h>
#include <sparc64/dev/pyrovar.h>

extern struct cfdriver pyro_cd;

int	ebus_mainbus_match(struct device *, void *, void *);
void	ebus_mainbus_attach(struct device *, struct device *, void *);

struct cfattach ebus_mainbus_ca = {
	sizeof(struct ebus_softc), ebus_mainbus_match, ebus_mainbus_attach
};


int ebus_mainbus_bus_map(bus_space_tag_t, bus_space_tag_t,
    bus_addr_t, bus_size_t, int, bus_space_handle_t *);
void *ebus_mainbus_intr_establish(bus_space_tag_t, bus_space_tag_t,
    int, int, int, int (*)(void *), void *, const char *);
bus_space_tag_t ebus_alloc_bus_tag(struct ebus_softc *, bus_space_tag_t);
void ebus_mainbus_intr_ack(struct intrhand *);

int
ebus_mainbus_match(struct device *parent, void *match, void *aux)
{
	struct mainbus_attach_args *ma = aux;

	if (strcmp(ma->ma_name, "ebus") == 0)
		return (1);
	return (0);
}

void
ebus_mainbus_attach(struct device *parent, struct device *self, void *aux)
{
	struct ebus_softc *sc = (struct ebus_softc *)self;
	struct mainbus_attach_args *ma = aux;
	struct ebus_attach_args eba;
	struct ebus_interrupt_map_mask *immp;
	int node, nmapmask, error;
	struct pyro_softc *psc;
	int i, j;

	printf("\n");

	sc->sc_memtag = ebus_alloc_bus_tag(sc, ma->ma_bustag);
	sc->sc_iotag = ebus_alloc_bus_tag(sc, ma->ma_bustag);
	sc->sc_dmatag = ebus_alloc_dma_tag(sc, ma->ma_dmatag);

	sc->sc_node = node = ma->ma_node;

	/*
	 * fill in our softc with information from the prom
	 */
	sc->sc_intmap = NULL;
	sc->sc_range = NULL;
	error = getprop(node, "interrupt-map",
			sizeof(struct ebus_interrupt_map),
			&sc->sc_nintmap, (void **)&sc->sc_intmap);
	switch (error) {
	case 0:
		immp = &sc->sc_intmapmask;
		error = getprop(node, "interrupt-map-mask",
			    sizeof(struct ebus_interrupt_map_mask), &nmapmask,
			    (void **)&immp);
		if (error)
			panic("could not get ebus interrupt-map-mask");
		if (nmapmask != 1)
			panic("ebus interrupt-map-mask is broken");
		break;
	case ENOENT:
		break;
	default:
		panic("ebus interrupt-map: error %d", error);
		break;
	}

	/*
	 * Ebus interrupts may be connected to any of the PCI Express
	 * leafs.  Here we add the appropriate IGN to the interrupt
	 * mappings such that we can use it to distingish between
	 * intterupts connected to PCIE-A and PCIE-B.
	 */
	for (i = 0; i < sc->sc_nintmap; i++) {
		for (j = 0; j < pyro_cd.cd_ndevs; j++) {
			psc = pyro_cd.cd_devs[j];
			if (psc && psc->sc_node == sc->sc_intmap[i].cnode) {
				sc->sc_intmap[i].cintr |= psc->sc_ign;
				break;
			}
		}
	}

	error = getprop(node, "ranges", sizeof(struct ebus_mainbus_ranges),
	    &sc->sc_nrange, (void **)&sc->sc_range);
	if (error)
		panic("ebus ranges: error %d", error);

	/*
	 * now attach all our children
	 */
	DPRINTF(EDB_CHILD, ("ebus node %08x, searching children...\n", node));
	for (node = firstchild(node); node; node = nextsibling(node)) {
		if (ebus_setup_attach_args(sc, node, &eba) != 0) {
			DPRINTF(EDB_CHILD,
			    ("ebus_mainbus_attach: %s: incomplete\n",
			    getpropstring(node, "name")));
			continue;
		} else {
			DPRINTF(EDB_CHILD, ("- found child `%s', attaching\n",
			    eba.ea_name));
			(void)config_found(self, &eba, ebus_print);
		}
		ebus_destroy_attach_args(&eba);
	}
}

bus_space_tag_t
ebus_alloc_bus_tag(struct ebus_softc *sc, bus_space_tag_t parent)
{
	struct sparc_bus_space_tag *bt;

	bt = malloc(sizeof(*bt), M_DEVBUF, M_NOWAIT | M_ZERO);
	if (bt == NULL)
		panic("could not allocate ebus bus tag");

	strlcpy(bt->name, sc->sc_dev.dv_xname, sizeof(bt->name));
	bt->cookie = sc;
	bt->parent = parent;
	bt->asi = parent->asi;
	bt->sasi = parent->sasi;
	bt->sparc_bus_map = ebus_mainbus_bus_map;
	bt->sparc_intr_establish = ebus_mainbus_intr_establish;

	return (bt);
}

int
ebus_mainbus_bus_map(bus_space_tag_t t, bus_space_tag_t t0, bus_addr_t offset,
    bus_size_t size, int flags, bus_space_handle_t *hp)
{
	struct ebus_softc *sc = t->cookie;
	struct ebus_mainbus_ranges *range;
	bus_addr_t hi, lo;
	int i;

	DPRINTF(EDB_BUSMAP,
	    ("\n_ebus_mainbus_bus_map: off %016llx sz %x flags %d",
	    (unsigned long long)offset, (int)size, (int)flags));

	if (t->parent == 0 || t->parent->sparc_bus_map == 0) {
		printf("\n_ebus_mainbus_bus_map: invalid parent");
		return (EINVAL);
	}

	t = t->parent;

	if (flags & BUS_SPACE_MAP_PROMADDRESS) {
		return ((*t->sparc_bus_map)
		    (t, t0, offset, size, flags, hp));
	}

	hi = offset >> 32UL;
	lo = offset & 0xffffffff;
	range = (struct ebus_mainbus_ranges *)sc->sc_range;

	DPRINTF(EDB_BUSMAP, (" (hi %08x lo %08x)", (u_int)hi, (u_int)lo));
	for (i = 0; i < sc->sc_nrange; i++) {
		bus_addr_t addr;

		if (hi != range[i].child_hi)
			continue;
		if (lo < range[i].child_lo ||
		    (lo + size) > (range[i].child_lo + range[i].size))
			continue;

		addr = ((bus_addr_t)range[i].phys_hi << 32UL) |
				    range[i].phys_lo;
		addr += lo;
		DPRINTF(EDB_BUSMAP,
		    ("\n_ebus_mainbus_bus_map: paddr offset %llx addr %llx\n", 
		    (unsigned long long)offset, (unsigned long long)addr));
                return ((*t->sparc_bus_map)(t, t0, addr, size, flags, hp));
	}
	DPRINTF(EDB_BUSMAP, (": FAILED\n"));
	return (EINVAL);
}

void *
ebus_mainbus_intr_establish(bus_space_tag_t t, bus_space_tag_t t0, int ihandle,
    int level, int flags, int (*handler)(void *), void *arg, const char *what)
{
	struct ebus_softc *sc = t->cookie;
	struct intrhand *ih = NULL;
	volatile u_int64_t *intrmapptr = NULL, *intrclrptr = NULL;
	int ino;

#ifdef SUN4V
	if (CPU_ISSUN4V) {
		struct upa_reg reg;
		u_int64_t devhandle, devino = INTINO(ihandle);
		u_int64_t sysino;
		int node = -1;
		int i, err;

		for (i = 0; i < sc->sc_nintmap; i++) {
			if (sc->sc_intmap[i].cintr == ihandle) {
				node = sc->sc_intmap[i].cnode;
				break;
			}
		}
		if (node == -1)
			return (NULL);

		if (OF_getprop(node, "reg", &reg, sizeof(reg)) != sizeof(reg))
			return (NULL);
		devhandle = (reg.ur_paddr >> 32) & 0x0fffffff;

		err = hv_intr_devino_to_sysino(devhandle, devino, &sysino);
		if (err != H_EOK)
			return (NULL);

		KASSERT(sysino == INTVEC(sysino));
		ih = bus_intr_allocate(t0, handler, arg, sysino, level,
		    NULL, NULL, what);
		if (ih == NULL)
			return (NULL);

		intr_establish(ih->ih_pil, ih);
		ih->ih_ack = ebus_mainbus_intr_ack;

		err = hv_intr_settarget(sysino, ih->ih_cpu->ci_upaid);
		if (err != H_EOK)
			return (NULL);

		/* Clear pending interrupts. */
		err = hv_intr_setstate(sysino, INTR_IDLE);
		if (err != H_EOK)
			return (NULL);

		err = hv_intr_setenabled(sysino, INTR_ENABLED);
		if (err != H_EOK)
			return (NULL);

		return (ih);
	}
#endif

	ino = INTINO(ihandle);

	if ((flags & BUS_INTR_ESTABLISH_SOFTINTR) == 0) {
		struct pyro_softc *psc = NULL;
		u_int64_t *imap, *iclr;
		int i;

		for (i = 0; i < pyro_cd.cd_ndevs; i++) {
			psc = pyro_cd.cd_devs[i];
			if (psc && psc->sc_ign == INTIGN(ihandle)) {
				break;
			}
		}
		if (psc == NULL)
			return (NULL);

		imap = bus_space_vaddr(psc->sc_bust, psc->sc_csrh) + 0x1000;
		iclr = bus_space_vaddr(psc->sc_bust, psc->sc_csrh) + 0x1400;
		intrmapptr = &imap[ino];
		intrclrptr = &iclr[ino];
		ino |= INTVEC(ihandle);
	}

	ih = bus_intr_allocate(t0, handler, arg, ino, level, intrmapptr,
	    intrclrptr, what);
	if (ih == NULL)
		return (NULL);

	intr_establish(ih->ih_pil, ih);

	if (intrmapptr != NULL) {
		u_int64_t intrmap;

		intrmap = *intrmapptr;
		intrmap |= (1LL << 6);
		intrmap |= INTMAP_V;
		*intrmapptr = intrmap;
		intrmap = *intrmapptr;
		ih->ih_number |= intrmap & INTMAP_INR;
	}

	return (ih);
}

#ifdef SUN4V

void
ebus_mainbus_intr_ack(struct intrhand *ih)
{
	hv_intr_setstate(ih->ih_number, INTR_IDLE);
}

#endif
@


1.9
log
@Store the target CPU in "struct intrhand" and use it in intr_barrier().
Also use it wherever we configure the hardware to direct interrupts to the
right CPU.
@
text
@d1 1
a1 1
/*	$OpenBSD: ebus_mainbus.c,v 1.8 2012/08/17 20:41:27 kettenis Exp $	*/
d229 1
a229 1
		    ("\n_ebus_mainbus_bus_map: paddr offset %qx addr %qx\n", 
@


1.8
log
@Turns out interrupts for Ebus devices are wired to the *other* PCI Expres leaf
on the v445 (compared to the v215/v245).  Generalize the code to allow for
arbitrary wirings.  Makes the serial console on the v445 work.
@
text
@d1 1
a1 1
/*	$OpenBSD: ebus_mainbus.c,v 1.7 2010/11/11 17:58:23 miod Exp $	*/
d280 1
a280 1
		err = hv_intr_settarget(sysino, cpus->ci_upaid);
@


1.7
log
@Replace snprintf(foo, sizeof foo, "%s", ...) with strlcpy. ok deraadt@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ebus_mainbus.c,v 1.6 2008/04/03 19:41:20 kettenis Exp $	*/
d90 1
a90 23
	int i;

	sc->sc_node = node = ma->ma_node;
	sc->sc_ign = INTIGN((ma->ma_upaid) << INTMAP_IGN_SHIFT);

	if (CPU_ISSUN4U) {
		printf(": ign %x", sc->sc_ign);

		for (i = 0; i < pyro_cd.cd_ndevs; i++) {
			psc = pyro_cd.cd_devs[i];
			if (psc && psc->sc_ign == sc->sc_ign) {
				sc->sc_bust = psc->sc_bust;
				sc->sc_csr = psc->sc_csr;
				sc->sc_csrh = psc->sc_csrh;
				break;
			}
		}

		if (sc->sc_csr == 0) {
			printf(": can't find matching host bridge leaf\n");
			return;
		}
	}
d98 2
d126 16
a296 1
	ihandle |= sc->sc_ign;
d300 1
d302 10
d313 2
a314 3
		/* XXX */
		imap = bus_space_vaddr(sc->sc_bust, sc->sc_csrh) + 0x1000;
		iclr = bus_space_vaddr(sc->sc_bust, sc->sc_csrh) + 0x1400;
@


1.6
log
@Make ebus(4) work on sun4v.
@
text
@d1 1
a1 1
/*	$OpenBSD: ebus_mainbus.c,v 1.5 2008/04/03 18:08:04 kettenis Exp $	*/
d179 1
a179 1
	snprintf(bt->name, sizeof(bt->name), "%s", sc->sc_dev.dv_xname);
@


1.5
log
@Some cosmetic changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: ebus_mainbus.c,v 1.4 2007/09/17 01:33:33 krw Exp $	*/
d44 1
d69 1
a69 1

d95 2
a96 1
	printf(": ign %x", sc->sc_ign);
d98 8
a105 7
	for (i = 0; i < pyro_cd.cd_ndevs; i++) {
		psc = pyro_cd.cd_devs[i];
		if (psc && psc->sc_ign == sc->sc_ign) {
			sc->sc_bust = psc->sc_bust;
			sc->sc_csr = psc->sc_csr;
			sc->sc_csrh = psc->sc_csrh;
			break;
a106 1
	}
d108 4
a111 3
	if (sc->sc_csr == 0) {
		printf(": can't find matching host bridge leaf\n");
		return;
d250 51
d335 10
@


1.4
log
@Only the most obvious bzero() -> M_ZERO changes. No cast changes, no
MALLOC/FREE, etc. Just adding M_ZERO to malloc() and deleting an
immediately adjacent bzero().
@
text
@d1 1
a1 1
/*	$OpenBSD: ebus_mainbus.c,v 1.3 2007/04/07 20:15:54 kettenis Exp $	*/
d63 1
a63 1
int _ebus_mainbus_bus_map(bus_space_tag_t, bus_space_tag_t,
d65 1
a65 1
void *_ebus_mainbus_intr_establish(bus_space_tag_t, bus_space_tag_t,
d181 2
a182 2
	bt->sparc_bus_map = _ebus_mainbus_bus_map;
	bt->sparc_intr_establish = _ebus_mainbus_intr_establish;
d188 1
a188 1
_ebus_mainbus_bus_map(bus_space_tag_t t, bus_space_tag_t t0, bus_addr_t offset,
d239 1
a239 1
_ebus_mainbus_intr_establish(bus_space_tag_t t, bus_space_tag_t t0, int ihandle,
@


1.3
log
@Remove unused variable.
@
text
@d1 1
a1 1
/*	$OpenBSD: ebus_mainbus.c,v 1.2 2007/04/05 19:14:00 kettenis Exp $	*/
d172 1
a172 1
	bt = malloc(sizeof(*bt), M_DEVBUF, M_NOWAIT);
a175 1
	bzero(bt, sizeof *bt);
@


1.2
log
@Fix interrupts.
@
text
@d1 1
a1 1
/*	$OpenBSD: ebus_mainbus.c,v 1.1 2007/04/04 18:38:54 kettenis Exp $	*/
a59 4
};

struct cfdriver ebus_mainbus_cd = {
	NULL, "ebus", DV_DULL
@


1.1
log
@Add support for ebus at mainbus, as found on machines with pyro(4) like the
v215.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d46 2
d51 3
a53 1
#include <sparc64/sparc64/cache.h>
d92 17
d110 4
a113 1
	sc->sc_ign = INTIGN((ma->ma_upaid & 0x1e) << INTMAP_IGN_SHIFT);
d115 1
a115 1
	printf(": ign %x\n", sc->sc_ign);
a119 10

	sc->sc_node = node = ma->ma_node;

	/* XXX double mapping? */
	sc->sc_bust = ma->ma_bustag;
	sc->sc_csr = ma->ma_reg[0].ur_paddr + 0x600000 - 0x464000;
	if (bus_space_map(sc->sc_bust, sc->sc_csr, 0x2000, 0, &sc->sc_csrh)) {
		printf(": failed to map csr registers\n");
		return;
	}
@

