head	1.22;
access;
symbols
	OPENBSD_6_2:1.22.0.4
	OPENBSD_6_2_BASE:1.22
	OPENBSD_6_1:1.21.0.6
	OPENBSD_6_1_BASE:1.21
	OPENBSD_6_0:1.21.0.2
	OPENBSD_6_0_BASE:1.21
	OPENBSD_5_9:1.20.0.8
	OPENBSD_5_9_BASE:1.20
	OPENBSD_5_8:1.20.0.10
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.20.0.2
	OPENBSD_5_7_BASE:1.20
	OPENBSD_5_6:1.20.0.6
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.20.0.4
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.18.0.14
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.18.0.12
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.18.0.10
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.8
	OPENBSD_5_0:1.18.0.6
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.18.0.4
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.18.0.2
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.16.0.2
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.13.0.10
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.6
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.4
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.2
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.11.0.2
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.10.0.2
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.9.0.6
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.4
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.2
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.8.0.4
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8
	SMP_SYNC_A:1.7
	SMP_SYNC_B:1.7
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.6.0.2
	OPENBSD_3_4_BASE:1.6
	UBC_SYNC_A:1.5
	OPENBSD_3_3:1.5.0.6
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.4
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	UBC_SYNC_B:1.5
	UBC:1.3.0.2
	UBC_BASE:1.3
	SMP:1.2.0.4
	OPENBSD_3_0:1.2.0.2
	OPENBSD_3_0_BASE:1.2;
locks; strict;
comment	@ * @;


1.22
date	2017.04.30.16.45.45;	author mpi;	state Exp;
branches;
next	1.21;
commitid	2Gtqjzrin9LL2yHk;

1.21
date	2016.03.07.13.21.51;	author naddy;	state Exp;
branches;
next	1.20;
commitid	EDvRPKRZUDEEb6oR;

1.20
date	2013.10.20.20.07.27;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2013.10.18.17.38.33;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2010.06.28.14.13.31;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2010.04.12.12.57.52;	author tedu;	state Exp;
branches;
next	1.16;

1.16
date	2009.11.09.17.53.39;	author nicm;	state Exp;
branches;
next	1.15;

1.15
date	2009.10.31.06.40.16;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2009.09.05.14.09.35;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2007.11.14.20.43.12;	author kettenis;	state Exp;
branches;
next	1.12;

1.12
date	2007.11.13.13.50.10;	author kettenis;	state Exp;
branches;
next	1.11;

1.11
date	2007.06.29.04.32.39;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2007.03.07.06.23.04;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2005.04.26.18.54.36;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2004.09.13.20.31.25;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2003.10.03.16.44.50;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2003.08.15.20.32.15;	author tedu;	state Exp;
branches;
next	1.5;

1.5
date	2002.03.14.03.16.00;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2002.03.14.01.26.44;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.12.08.17.11.55;	author miod;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2001.09.04.13.22.13;	author art;	state Exp;
branches
	1.2.4.1;
next	1.1;

1.1
date	2001.08.19.05.21.37;	author jason;	state Exp;
branches;
next	;

1.2.4.1
date	2001.10.31.03.07.58;	author nate;	state Exp;
branches;
next	1.2.4.2;

1.2.4.2
date	2002.03.06.02.04.46;	author niklas;	state Exp;
branches;
next	1.2.4.3;

1.2.4.3
date	2002.03.28.11.23.51;	author niklas;	state Exp;
branches;
next	1.2.4.4;

1.2.4.4
date	2004.02.19.10.49.59;	author niklas;	state Exp;
branches;
next	;

1.3.2.1
date	2002.06.11.03.38.43;	author art;	state Exp;
branches;
next	;


desc
@@


1.22
log
@Rename Debugger() into db_enter().

Using a name with the 'db_' prefix makes it invisible from the dynamic
profiler.

ok deraadt@@, kettenis@@, visa@@
@
text
@/*	$OpenBSD: pcons.c,v 1.21 2016/03/07 13:21:51 naddy Exp $	*/
/*	$NetBSD: pcons.c,v 1.7 2001/05/02 10:32:20 scw Exp $	*/

/*-
 * Copyright (c) 2000 Eduardo E. Horvath
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Default console driver.  Uses the PROM or whatever
 * driver(s) are appropriate.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/conf.h>
#include <sys/device.h>
#include <sys/file.h>
#include <sys/ioctl.h>
#include <sys/kernel.h>
#include <sys/proc.h>
#include <sys/tty.h>
#include <sys/time.h>
#include <sys/syslog.h>

#include <machine/autoconf.h>
#include <machine/openfirm.h>
#include <machine/conf.h>
#include <machine/cpu.h>
#include <machine/psl.h>

#include <dev/cons.h>

#include "wsdisplay.h"

#if NWSDISPLAY > 0
#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsdisplayvar.h>
#endif

struct pconssoftc {
	struct device of_dev;

#if NWSDISPLAY > 0
	int	sc_wsdisplay;
	u_int	sc_nscreens;
#endif

	struct tty *of_tty;
	struct timeout sc_poll_to;
	int of_flags;
};
/* flags: */
#define	OFPOLL		1

#define	OFBURSTLEN	128	/* max number of bytes to write in one chunk */

/* XXXXXXXX - this is in MI code in NetBSD */
/*
 * Stuff to handle debugger magic key sequences.
 */
#define CNS_LEN                 128
#define CNS_MAGIC_VAL(x)        ((x)&0x1ff)
#define CNS_MAGIC_NEXT(x)       (((x)>>9)&0x7f)
#define CNS_TERM                0x7f    /* End of sequence */

typedef struct cnm_state {
	int	cnm_state;
	u_short	*cnm_magic;
} cnm_state_t;
#ifdef DDB
#include <ddb/db_var.h>
#define cn_trap()	do { if (db_console) db_enter(); } while (0)
#else
#define cn_trap()
#endif
#define cn_isconsole(d)	((d) == cn_tab->cn_dev)
void cn_init_magic(cnm_state_t *cnm);
void cn_destroy_magic(cnm_state_t *cnm);
int cn_set_magic(char *magic);
int cn_get_magic(char *magic, int len);
/* This should be called for each byte read */
#ifndef cn_check_magic
#define cn_check_magic(d, k, s)                                         \
        do {                                                            \
		if (cn_isconsole(d)) {                                  \
			int v = (s).cnm_magic[(s).cnm_state];           \
			if ((k) == CNS_MAGIC_VAL(v)) {                  \
				(s).cnm_state = CNS_MAGIC_NEXT(v);      \
				if ((s).cnm_state == CNS_TERM) {        \
					cn_trap();                      \
                                        (s).cnm_state = 0;              \
				}                                       \
			} else {                                        \
				(s).cnm_state = 0;                      \
			}                                               \
		}                                                       \
	} while (/* CONSTCOND */ 0)
#endif

/* Encode out-of-band events this way when passing to cn_check_magic() */
#define CNC_BREAK               0x100

/* XXXXXXXXXX - end of this part of cnmagic, more at the end of this file. */

#include <sparc64/dev/cons.h>

int pconsmatch(struct device *, void *, void *);
void pconsattach(struct device *, struct device *, void *);

struct cfattach pcons_ca = {
	sizeof(struct pconssoftc), pconsmatch, pconsattach
};

struct cfdriver pcons_cd = {
	NULL, "pcons", DV_TTY
};

extern struct cfdriver pcons_cd;
static struct cnm_state pcons_cnm_state;

static int pconsprobe(void);
static void pcons_wsdisplay_init(struct pconssoftc *);
extern struct consdev *cn_tab;

cons_decl(prom_);

int
pconsmatch(parent, match, aux)
	struct device *parent;
	void *match;
	void *aux;
{
	struct mainbus_attach_args *ma = aux;

	/* Only attach if no other console has attached. */
	return (strcmp("pcons", ma->ma_name) == 0 &&
	    cn_tab->cn_getc == prom_cngetc);
}

void pcons_poll(void *);

void
pconsattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct pconssoftc *sc = (struct pconssoftc *) self;
#if NWSDISPLAY > 0
	char buffer[128];
	extern struct consdev wsdisplay_cons;
	extern int wsdisplay_getc_dummy(dev_t);
#endif

	printf("\n");
	if (!pconsprobe())
		return;

#if NWSDISPLAY > 0
	/*
	 * Attach a dumb wsdisplay device if a wscons input driver has
	 * registered as the console, or is about to do so (usb keyboards).
	 */
	if (wsdisplay_cons.cn_getc != wsdisplay_getc_dummy)
		sc->sc_wsdisplay = 1;
	else {
		if (OF_getprop(OF_instance_to_package(stdin), "compatible",
		    buffer, sizeof(buffer)) != -1 &&
		   strncmp("usb", buffer, 3) == 0)
		sc->sc_wsdisplay = 1;
	}

	if (sc->sc_wsdisplay != 0) {
		pcons_wsdisplay_init(sc);
		return;
	}
#endif
	cn_init_magic(&pcons_cnm_state);
	cn_set_magic("+++++");
	timeout_set(&sc->sc_poll_to, pcons_poll, sc);
}

void pconsstart(struct tty *);
int pconsparam(struct tty *, struct termios *);

int
pconsopen(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
{
	struct pconssoftc *sc;
	int unit = minor(dev);
	struct tty *tp;
	
	if (unit >= pcons_cd.cd_ndevs)
		return ENXIO;
	sc = pcons_cd.cd_devs[unit];
	if (!sc)
		return ENXIO;
#if NWSDISPLAY > 0
	if (sc->sc_wsdisplay != 0)
		return ENXIO;
#endif
	if (!(tp = sc->of_tty)) {
		sc->of_tty = tp = ttymalloc(0);
	}
	tp->t_oproc = pconsstart;
	tp->t_param = pconsparam;
	tp->t_dev = dev;
	cn_tab->cn_dev = dev;
	if (!(tp->t_state & TS_ISOPEN)) {
		ttychars(tp);
		tp->t_iflag = TTYDEF_IFLAG;
		tp->t_oflag = TTYDEF_OFLAG;
		tp->t_cflag = TTYDEF_CFLAG;
		tp->t_lflag = TTYDEF_LFLAG;
		tp->t_ispeed = tp->t_ospeed = TTYDEF_SPEED;
		pconsparam(tp, &tp->t_termios);
		ttsetwater(tp);
	} else if ((tp->t_state & TS_XCLUDE) && suser(p, 0))
		return EBUSY;
	tp->t_state |= TS_CARR_ON;
	
	if (!(sc->of_flags & OFPOLL)) {
		sc->of_flags |= OFPOLL;
		timeout_add(&sc->sc_poll_to, 1);
	}

	return (*linesw[tp->t_line].l_open)(dev, tp, p);
}

int
pconsclose(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
{
	struct pconssoftc *sc = pcons_cd.cd_devs[minor(dev)];
	struct tty *tp = sc->of_tty;

	timeout_del(&sc->sc_poll_to);
	sc->of_flags &= ~OFPOLL;
	(*linesw[tp->t_line].l_close)(tp, flag, p);
	ttyclose(tp);
	return 0;
}

int
pconsread(dev, uio, flag)
	dev_t dev;
	struct uio *uio;
	int flag;
{
	struct pconssoftc *sc = pcons_cd.cd_devs[minor(dev)];
	struct tty *tp = sc->of_tty;

	return (*linesw[tp->t_line].l_read)(tp, uio, flag);
}

int
pconswrite(dev, uio, flag)
	dev_t dev;
	struct uio *uio;
	int flag;
{
	struct pconssoftc *sc = pcons_cd.cd_devs[minor(dev)];
	struct tty *tp = sc->of_tty;

	return (*linesw[tp->t_line].l_write)(tp, uio, flag);
}

int
pconsioctl(dev, cmd, data, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
{
	struct pconssoftc *sc = pcons_cd.cd_devs[minor(dev)];
	struct tty *tp = sc->of_tty;
	int error;

	if ((error = (*linesw[tp->t_line].l_ioctl)(tp, cmd, data, flag, p)) >= 0)
		return error;
	if ((error = ttioctl(tp, cmd, data, flag, p)) >= 0)
		return error;
	return ENOTTY;
}

struct tty *
pconstty(dev)
	dev_t dev;
{
	struct pconssoftc *sc = pcons_cd.cd_devs[minor(dev)];

	return sc->of_tty;
}

int
pconsstop(tp, flag)
	struct tty *tp;
	int flag;
{
	return 0;
}

void
pconsstart(tp)
	struct tty *tp;
{
	struct clist *cl;
	int s, len;
	u_char buf[OFBURSTLEN];
	
	s = spltty();
	if (tp->t_state & (TS_TIMEOUT | TS_BUSY | TS_TTSTOP)) {
		splx(s);
		return;
	}
	tp->t_state |= TS_BUSY;
	splx(s);
	cl = &tp->t_outq;
	len = q_to_b(cl, buf, OFBURSTLEN);
	OF_write(stdout, buf, len);
	s = spltty();
	tp->t_state &= ~TS_BUSY;
	if (cl->c_cc) {
		tp->t_state |= TS_TIMEOUT;
		timeout_add(&tp->t_rstrt_to, 1);
	}
	if (cl->c_cc <= tp->t_lowat) {
		if (tp->t_state & TS_ASLEEP) {
			tp->t_state &= ~TS_ASLEEP;
			wakeup(cl);
		}
		selwakeup(&tp->t_wsel);
	}
	splx(s);
}

int
pconsparam(tp, t)
	struct tty *tp;
	struct termios *t;
{
	tp->t_ispeed = t->c_ispeed;
	tp->t_ospeed = t->c_ospeed;
	tp->t_cflag = t->c_cflag;
	return 0;
}

void
pcons_poll(aux)
	void *aux;
{
	struct pconssoftc *sc = aux;
	struct tty *tp = sc->of_tty;
	char ch;
	
	while (OF_read(stdin, &ch, 1) > 0) {
		cn_check_magic(tp->t_dev, ch, pcons_cnm_state);
		if (tp && (tp->t_state & TS_ISOPEN)) {
			if (ch == '\b')
				ch = '\177';
			(*linesw[tp->t_line].l_rint)(ch, tp);
		}
	}
	timeout_add(&sc->sc_poll_to, 1);
}

int
pconsprobe(void)
{
	if (!stdin) stdin = OF_stdin();
	if (!stdout) stdout = OF_stdout();

	return (stdin && stdout);
}

void
pcons_cnpollc(dev, on)
	dev_t dev;
	int on;
{
	struct pconssoftc *sc = NULL;

	if (pcons_cd.cd_devs) 
		sc = pcons_cd.cd_devs[minor(dev)];

	if (sc == NULL)
		return;

	if (on) {
		if (sc->of_flags & OFPOLL)
			timeout_del(&sc->sc_poll_to);
		sc->of_flags &= ~OFPOLL;
	} else {
                /* Resuming kernel. */
		if (!(sc->of_flags & OFPOLL)) {
			sc->of_flags |= OFPOLL;
			timeout_add(&sc->sc_poll_to, 1);
		}
	}
}

/* XXXXXXXX --- more cnmagic stuff. */
#define ENCODE_STATE(c, n) (short)(((c)&0x1ff)|(((n)&0x7f)<<9))

static unsigned short cn_magic[CNS_LEN];

/*
 * Initialize a cnm_state_t.
 */
void
cn_init_magic(cnm_state_t *cnm)
{
	cnm->cnm_state = 0;
	cnm->cnm_magic = cn_magic;
}

/*
 * Destroy a cnm_state_t.
 */
void
cn_destroy_magic(cnm_state_t *cnm)
{
	cnm->cnm_state = 0;
	cnm->cnm_magic = NULL;
}

/*
 * Translate a magic string to a state
 * machine table.
 */
int
cn_set_magic(char *magic)
{
	unsigned int i, c, n;
	unsigned short m[CNS_LEN];

	for (i=0; i<CNS_LEN; i++) {
		c = (*magic++)&0xff;
		n = *magic ? i+1 : CNS_TERM;
		switch (c) {
		case 0:
			/* End of string */
			if (i == 0) {
				/* empty string? */
				cn_magic[0] = 0;
#ifdef DEBUG
				printf("cn_set_magic(): empty!\n");
#endif
				return (0);
			}
			do {
				cn_magic[i] = m[i];
			} while (i--);
			return(0);
		case 0x27:
			/* Escape sequence */
			c = (*magic++)&0xff;
			n = *magic ? i+1 : CNS_TERM;
			switch (c) {
			case 0x27:
				break;
			case 0x01:
				/* BREAK */
				c = CNC_BREAK;
				break;
			case 0x02:
				/* NUL */
				c = 0;
				break;
			}
			/* FALLTHROUGH */
		default:
			/* Transition to the next state. */
#ifdef DEBUG
			if (!cold)
				printf("mag %d %x:%x\n", i, c, n);
#endif
			m[i] = ENCODE_STATE(c, n);
			break;
		}
	} 
	return (EINVAL);
}

/*
 * Translate a state machine table back to
 * a magic string.
 */
int 
cn_get_magic(char *magic, int maglen) {
	unsigned int i, c;
	
	for (i=0; i<CNS_LEN; i++) {
		c = cn_magic[i];
		/* Translate a character */
		switch (CNS_MAGIC_VAL(c)) {
		case CNC_BREAK:
			*magic++ = 0x27;
			*magic++ = 0x01;
			break;
		case 0:
			*magic++ = 0x27;
			*magic++ = 0x02;
			break;
		case 0x27:
			*magic++ = 0x27;
			*magic++ = 0x27;
			break;
		default:
			*magic++ = (c&0x0ff);
			break;
		}
		/* Now go to the next state */
		i = CNS_MAGIC_NEXT(c);
		if (i == CNS_TERM || i == 0) {
			/* Either termination state or empty machine */
			*magic++ = 0;
			return (0);
		}
	}
	return (EINVAL);
}

#if NWSDISPLAY > 0

int	pcons_alloc_screen(void *, const struct wsscreen_descr *, void **,
	    int *, int *, long *);
void	pcons_cursor(void *, int, int, int);
void	pcons_free_screen(void *, void *);
int	pcons_ioctl(void *, u_long, caddr_t, int, struct proc *);
int	pcons_mapchar(void *, int, unsigned int *);
paddr_t	pcons_mmap(void *, off_t, int);
int	pcons_putchar(void *, int, int, u_int, long);
int	pcons_show_screen(void *, void *, int, void (*)(void *, int, int),
	    void *);

struct wsdisplay_emulops pcons_emulops = {
	NULL,
	pcons_mapchar,
	pcons_putchar
};

struct wsscreen_descr pcons_stdscreen = {
	"dumb", 80, 34, &pcons_emulops, 12, 22, 0
};

const struct wsscreen_descr *pcons_scrlist[] = {
	&pcons_stdscreen
};

struct wsscreen_list pcons_screenlist = {
	1, pcons_scrlist
};

struct wsdisplay_accessops pcons_accessops = {
	.ioctl = pcons_ioctl,
	.mmap = pcons_mmap,
	.alloc_screen = pcons_alloc_screen,
	.free_screen = pcons_free_screen,
	.show_screen = pcons_show_screen
};

int
pcons_alloc_screen(void *v, const struct wsscreen_descr *typ, void **cookiep,
    int *curxp, int *curyp, long *attrp)
{
	struct pconssoftc *sc = v;
	int *rowp, *colp;
	int row, col;

	if (sc->sc_nscreens > 0)
		return (ENOMEM);

	row = col = 0;
	if (romgetcursoraddr(&rowp, &colp) == 0) {
		if (rowp != NULL)
			row = *rowp;
		if (colp != NULL)
			col = *colp;
	}

	*cookiep = v;
	*attrp = 0;
	*curxp = col;
	*curyp = row;

	sc->sc_nscreens++;
	return (0);
}

void
pcons_free_screen(void *v, void *cookie)
{
	struct pconssoftc *sc = v;

	sc->sc_nscreens--;
}

int
pcons_ioctl(void *v, u_long cmd, caddr_t data, int flags, struct proc *p)
{
	switch (cmd) {
	case WSDISPLAYIO_GTYPE:
		*(u_int *)data = WSDISPLAY_TYPE_UNKNOWN;
		break;
	default:
		return (-1);
	}

	return (0);
}

paddr_t
pcons_mmap(void *v, off_t off, int prot)
{
	return ((paddr_t)-1);
}

int
pcons_show_screen(void *v, void *cookie, int waitok,
    void (*cb)(void *, int, int), void *arg)
{
	return (0);
}

int
pcons_mapchar(void *v, int uc, unsigned int *idx)
{
	if ((uc & 0xff) == uc) {
		*idx = uc;
		return (1);
	} else {
		*idx = '?';
		return (0);
	}
}

int
pcons_putchar(void *v, int row, int col, u_int uc, long attr)
{
	u_char buf[1];
	int s;

	buf[0] = (u_char)uc;
	s = splhigh();
	OF_write(stdout, &buf, 1);
	splx(s);

	return 0;
}

void
pcons_wsdisplay_init(struct pconssoftc *sc)
{
	struct wsemuldisplaydev_attach_args waa;
	int *rowp, *colp;
	int options, row, col;

	row = col = 0;
	if (romgetcursoraddr(&rowp, &colp) == 0) {
		if (rowp != NULL)
			row = *rowp;
		if (colp != NULL)
			col = *colp;
	}

	options = OF_finddevice("/options");
	pcons_stdscreen.nrows = getpropint(options, "screen-#rows", 34);
	pcons_stdscreen.ncols = getpropint(options, "screen-#columns", 80);

	/*
	 * We claim console here, because we can only get there if stdin
	 * is a keyboard. However, the PROM could have been configured with
	 * stdin being a keyboard and stdout being a serial sink.
	 * But since this combination is not supported under OpenBSD at the
	 * moment, it is reasonably safe to attach a dumb display as console
	 * here.
	 */
	wsdisplay_cnattach(&pcons_stdscreen, sc, col, row, 0);

	waa.console = 1;
	waa.scrdata = &pcons_screenlist;
	waa.accessops = &pcons_accessops;
	waa.accesscookie = sc;
	waa.defaultscreens = 1;

	config_found((struct device *)sc, &waa, wsemuldisplaydevprint);
}
#endif
@


1.21
log
@Sync no-argument function declaration and definition by adding (void).
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pcons.c,v 1.20 2013/10/20 20:07:27 miod Exp $	*/
d96 1
a96 1
#define cn_trap()	do { if (db_console) Debugger(); } while (0)
@


1.20
log
@Use C99 named initializers for struct wsdisplay_accessops fields.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcons.c,v 1.19 2013/10/18 17:38:33 miod Exp $	*/
d397 1
a397 1
pconsprobe()
@


1.19
log
@Make sure that, when a particular mapchar() can't find a proper glyph for the
requested character in the font it is using, it suggests a question mark
character, instead of a space, so that the existence of the non-representable
character becomes visible.

Note that this is consistent with pcdisplay which suggests a diamond for
missing glyphs.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcons.c,v 1.18 2010/06/28 14:13:31 deraadt Exp $	*/
d585 5
a589 5
	pcons_ioctl,
	pcons_mmap,
	pcons_alloc_screen,
	pcons_free_screen,
	pcons_show_screen
@


1.18
log
@Allow tty drivers to request larger buffers at attach time using a
max-baud-rate hint.  Adjust TTYHOG (the nearly full logic) to this new
situation.  The larger buffers are required by the very high speed
KDDI devices in Japan (CF com, or USB ucom) so those are the only two
drivers which currently ask for a larger buffer size.
ok yasuoka miod
@
text
@d1 1
a1 1
/*	$OpenBSD: pcons.c,v 1.17 2010/04/12 12:57:52 tedu Exp $	*/
d662 1
a662 1
		*idx = ' ';
@


1.17
log
@Some of the line disciplines want to check for suser.  Better to pass them
a process instead of using curproc.  ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: pcons.c,v 1.16 2009/11/09 17:53:39 nicm Exp $	*/
d229 1
a229 1
		sc->of_tty = tp = ttymalloc();
@


1.16
log
@Every selwakeup() should have a matching KNOTE() (even if kqueue isn't
supported it doesn't do any harm), so put the KNOTE() in selwakeup() itself and
remove it from any occurences where both are used, except one for kqueue itself
and one in sys_pipe.c (where the selwakeup is under a PIPE_SEL flag).

Based on a diff from tedu.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: pcons.c,v 1.15 2009/10/31 06:40:16 deraadt Exp $	*/
d253 1
a253 1
	return (*linesw[tp->t_line].l_open)(dev, tp);
d267 1
a267 1
	(*linesw[tp->t_line].l_close)(tp, flag);
@


1.15
log
@Add missing KNOTE() calls after selwakeup(), until we decide if the KNOTE()
calls can go directly into selwakeup() safely
long discussion with nicm, murmers of consent from tedu and miod, noone
else seems to care of kqueue is busted as long as it makes their sockets
move data fast... pretty sad.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcons.c,v 1.14 2009/09/05 14:09:35 miod Exp $	*/
a361 1
		KNOTE(&tp->t_wsel.si_note, 0);
@


1.14
log
@Change the wsdisplay_emulops return types from void to int; emulops will now
return zero on success and nonzero on failure.
This commit only performs mechanical changes for the existing emulops to
always return zero.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcons.c,v 1.13 2007/11/14 20:43:12 kettenis Exp $	*/
d362 1
@


1.13
log
@Remove eeprom.h.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcons.c,v 1.12 2007/11/13 13:50:10 kettenis Exp $	*/
d562 1
a562 1
void	pcons_putchar(void *, int, int, u_int, long);
d667 1
a667 1
void
d677 2
@


1.12
log
@Remove bsd_openprom.h.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcons.c,v 1.11 2007/06/29 04:32:39 deraadt Exp $	*/
a52 1
#include <machine/eeprom.h>
@


1.11
log
@sick of extra static messing up tracebacks; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: pcons.c,v 1.10 2007/03/07 06:23:04 miod Exp $	*/
a50 1
#include <machine/bsd_openprom.h>
@


1.10
log
@For unsupported (yet) Expert3D style frame buffers, attach pcons and attach
a really dumb wsdisplay to pcons, so that wskbd/wsmouse input drivers can be
used for input, and prom for output.

This is a band-aid for the release, so that people with such frame buffers
do not need to unplug them or switch to serial console to install OpenBSD.

Probably not the best way to do this, but this one has a minimal footprint
and no tentacles in wscons.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pcons.c,v 1.9 2005/04/26 18:54:36 miod Exp $	*/
d133 2
a134 2
static int pconsmatch(struct device *, void *, void *);
static void pconsattach(struct device *, struct device *, void *);
d153 1
a153 1
static int
d166 1
a166 1
static void pcons_poll(void *);
d168 1
a168 1
static void
d208 2
a209 2
static void pconsstart(struct tty *);
static int pconsparam(struct tty *, struct termios *);
d334 1
a334 1
static void
d368 1
a368 1
static int
d379 1
a379 1
static void
@


1.9
log
@Remove unused hooks for periodic pcons polling.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcons.c,v 1.8 2004/09/13 20:31:25 deraadt Exp $	*/
d59 24
d148 1
d151 2
a159 1
	extern int prom_cngetc(dev_t);
a163 1

d174 5
d184 19
d226 4
d555 164
@


1.8
log
@for pcons tty and kernel console (ie. boot -a) input, replace prom ^H
with ^? as that is what we have standardized on for all delete keys.
this got missed, meaning boot -a and RAMDISK console tty were gross.
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: pcons.c,v 1.7 2003/10/03 16:44:50 miod Exp $	*/
d133 1
a133 1
	extern int  prom_cngetc(dev_t);
d136 2
a137 2
	return ((strcmp("pcons", ma->ma_name) == 0) &&
		(cn_tab->cn_getc == prom_cngetc));
d193 1
a193 1
	} else if ((tp->t_state&TS_XCLUDE) && suser(p, 0))
d364 3
a367 1
		if (!sc) return;
d373 1
a373 1
		if (sc && !(sc->of_flags & OFPOLL)) {
a377 6
}

void pcons_dopoll(void);
void
pcons_dopoll() {
		pcons_poll((void *)pcons_cd.cd_devs[0]);
@


1.7
log
@Merge tty_attach() in ttymalloc() and tty_detach() in ttyfree(). The need for
separate tty registering is gone now that sparc has switched to wscons, and
this makes the code less error-prone.

Also, remove tests for ttymalloc() failure, since it uses M_WAITOK.

ok millert@@ deraadt@@, tested by various people as well besides me...
@
text
@d1 1
a1 1
/*	$OpenBSD: pcons.c,v 1.6 2003/08/15 20:32:15 tedu Exp $	*/
d336 3
a338 1
		if (tp && (tp->t_state & TS_ISOPEN))
d340 1
@


1.6
log
@change arguments to suser.  suser now takes the process, and a flags
argument.  old cred only calls user suser_ucred.  this will allow future
work to more flexibly implement the idea of a root process.  looks like
something i saw in freebsd, but a little different.
use of suser_ucred vs suser in file system code should be looked at again,
for the moment semantics remain unchanged.
review and input from art@@  testing and further review miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pcons.c,v 1.5 2002/03/14 03:16:00 millert Exp $	*/
a178 1
		tty_attach(tp);
@


1.5
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: pcons.c,v 1.4 2002/03/14 01:26:44 millert Exp $	*/
d194 1
a194 1
	} else if ((tp->t_state&TS_XCLUDE) && suser(p->p_ucred, &p->p_acflag))
@


1.4
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: pcons.c,v 1.3 2001/12/08 17:11:55 miod Exp $	*/
d379 1
a379 1
		pcons_poll((void*)pcons_cd.cd_devs[0]);
@


1.3
log
@db_console is declared in <ddb/db_var.h>. Fix a typo while there, too.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcons.c,v 1.2 2001/09/04 13:22:13 art Exp $	*/
d79 4
a82 4
void cn_init_magic __P((cnm_state_t *cnm));
void cn_destroy_magic __P((cnm_state_t *cnm));
int cn_set_magic __P((char *magic));
int cn_get_magic __P((char *magic, int len));
d109 2
a110 2
static int pconsmatch __P((struct device *, void *, void *));
static void pconsattach __P((struct device *, struct device *, void *));
d123 1
a123 1
static int pconsprobe __P((void));
d133 1
a133 1
	extern int  prom_cngetc __P((dev_t));
d141 1
a141 1
static void pcons_poll __P((void *));
d159 2
a160 2
static void pconsstart __P((struct tty *));
static int pconsparam __P((struct tty *, struct termios *));
d376 1
a376 1
void pcons_dopoll __P((void));
@


1.3.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pcons.c,v 1.3 2001/12/08 17:11:55 miod Exp $	*/
d79 4
a82 4
void cn_init_magic(cnm_state_t *cnm);
void cn_destroy_magic(cnm_state_t *cnm);
int cn_set_magic(char *magic);
int cn_get_magic(char *magic, int len);
d109 2
a110 2
static int pconsmatch(struct device *, void *, void *);
static void pconsattach(struct device *, struct device *, void *);
d123 1
a123 1
static int pconsprobe(void);
d133 1
a133 1
	extern int  prom_cngetc(dev_t);
d141 1
a141 1
static void pcons_poll(void *);
d159 2
a160 2
static void pconsstart(struct tty *);
static int pconsparam(struct tty *, struct termios *);
d376 1
a376 1
void pcons_dopoll(void);
d379 1
a379 1
		pcons_poll((void *)pcons_cd.cd_devs[0]);
@


1.2
log
@Don't forget tty_attach. Should fix the timeout related panics.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcons.c,v 1.1 2001/08/19 05:21:37 jason Exp $	*/
a71 1
extern int db_console;
d73 1
d466 1
a466 1
 * Translatea state machine table back to
@


1.2.4.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.2.4.2
log
@Merge in trunk
@
text
@d72 1
a73 1
#include <ddb/db_var.h>
d466 1
a466 1
 * Translate a state machine table back to
@


1.2.4.3
log
@Merge in -current from about a week ago
@
text
@d79 4
a82 4
void cn_init_magic(cnm_state_t *cnm);
void cn_destroy_magic(cnm_state_t *cnm);
int cn_set_magic(char *magic);
int cn_get_magic(char *magic, int len);
d109 2
a110 2
static int pconsmatch(struct device *, void *, void *);
static void pconsattach(struct device *, struct device *, void *);
d123 1
a123 1
static int pconsprobe(void);
d133 1
a133 1
	extern int  prom_cngetc(dev_t);
d141 1
a141 1
static void pcons_poll(void *);
d159 2
a160 2
static void pconsstart(struct tty *);
static int pconsparam(struct tty *, struct termios *);
d376 1
a376 1
void pcons_dopoll(void);
d379 1
a379 1
		pcons_poll((void *)pcons_cd.cd_devs[0]);
@


1.2.4.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d179 1
d194 1
a194 1
	} else if ((tp->t_state&TS_XCLUDE) && suser(p, 0))
@


1.1
log
@Lot of stuff... Some from NetBSD, some from OpenBSD, minor modifications
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d177 1
a177 1
	if (!(tp = sc->of_tty))
d179 2
@

