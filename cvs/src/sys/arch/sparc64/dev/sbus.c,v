head	1.44;
access;
symbols
	OPENBSD_6_1:1.44.0.6
	OPENBSD_6_1_BASE:1.44
	OPENBSD_6_0:1.44.0.4
	OPENBSD_6_0_BASE:1.44
	OPENBSD_5_9:1.44.0.2
	OPENBSD_5_9_BASE:1.44
	OPENBSD_5_8:1.43.0.6
	OPENBSD_5_8_BASE:1.43
	OPENBSD_5_7:1.43.0.2
	OPENBSD_5_7_BASE:1.43
	OPENBSD_5_6:1.42.0.4
	OPENBSD_5_6_BASE:1.42
	OPENBSD_5_5:1.39.0.16
	OPENBSD_5_5_BASE:1.39
	OPENBSD_5_4:1.39.0.12
	OPENBSD_5_4_BASE:1.39
	OPENBSD_5_3:1.39.0.10
	OPENBSD_5_3_BASE:1.39
	OPENBSD_5_2:1.39.0.8
	OPENBSD_5_2_BASE:1.39
	OPENBSD_5_1_BASE:1.39
	OPENBSD_5_1:1.39.0.6
	OPENBSD_5_0:1.39.0.4
	OPENBSD_5_0_BASE:1.39
	OPENBSD_4_9:1.39.0.2
	OPENBSD_4_9_BASE:1.39
	OPENBSD_4_8:1.37.0.8
	OPENBSD_4_8_BASE:1.37
	OPENBSD_4_7:1.37.0.4
	OPENBSD_4_7_BASE:1.37
	OPENBSD_4_6:1.37.0.6
	OPENBSD_4_6_BASE:1.37
	OPENBSD_4_5:1.37.0.2
	OPENBSD_4_5_BASE:1.37
	OPENBSD_4_4:1.35.0.2
	OPENBSD_4_4_BASE:1.35
	OPENBSD_4_3:1.32.0.2
	OPENBSD_4_3_BASE:1.32
	OPENBSD_4_2:1.27.0.2
	OPENBSD_4_2_BASE:1.27
	OPENBSD_4_1:1.26.0.4
	OPENBSD_4_1_BASE:1.26
	OPENBSD_4_0:1.26.0.2
	OPENBSD_4_0_BASE:1.26
	OPENBSD_3_9:1.23.0.2
	OPENBSD_3_9_BASE:1.23
	OPENBSD_3_8:1.22.0.4
	OPENBSD_3_8_BASE:1.22
	OPENBSD_3_7:1.22.0.2
	OPENBSD_3_7_BASE:1.22
	OPENBSD_3_6:1.20.0.8
	OPENBSD_3_6_BASE:1.20
	SMP_SYNC_A:1.20
	SMP_SYNC_B:1.20
	OPENBSD_3_5:1.20.0.4
	OPENBSD_3_5_BASE:1.20
	OPENBSD_3_4:1.20.0.2
	OPENBSD_3_4_BASE:1.20
	UBC_SYNC_A:1.16
	OPENBSD_3_3:1.16.0.2
	OPENBSD_3_3_BASE:1.16
	OPENBSD_3_2:1.14.0.4
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.14.0.2
	OPENBSD_3_1_BASE:1.14
	UBC_SYNC_B:1.14
	UBC:1.7.0.6
	UBC_BASE:1.7
	SMP:1.7.0.4
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7;
locks; strict;
comment	@ * @;


1.44
date	2015.09.19.21.07.04;	author semarie;	state Exp;
branches;
next	1.43;
commitid	9KMPSlP02LD1SpJP;

1.43
date	2014.12.09.06.58.29;	author doug;	state Exp;
branches;
next	1.42;
commitid	yWAxzpQP2PPpYlfT;

1.42
date	2014.07.12.20.18.09;	author uebayasi;	state Exp;
branches;
next	1.41;
commitid	nhoQgK9Q8d952hTz;

1.41
date	2014.07.12.18.44.43;	author tedu;	state Exp;
branches;
next	1.40;
commitid	uKVPYMN2MLxdZxzH;

1.40
date	2014.07.12.14.12.44;	author uebayasi;	state Exp;
branches;
next	1.39;
commitid	CwxiCWSX4kdxVfoo;

1.39
date	2010.12.26.15.37.20;	author kettenis;	state Exp;
branches;
next	1.38;

1.38
date	2010.11.11.17.58.23;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2009.01.14.20.35.42;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2009.01.02.20.01.45;	author kettenis;	state Exp;
branches;
next	1.35;

1.35
date	2008.06.26.05.42.13;	author ray;	state Exp;
branches;
next	1.34;

1.34
date	2008.03.16.22.19.57;	author kettenis;	state Exp;
branches;
next	1.33;

1.33
date	2008.03.09.13.28.20;	author kettenis;	state Exp;
branches;
next	1.32;

1.32
date	2008.01.17.22.53.18;	author kettenis;	state Exp;
branches;
next	1.31;

1.31
date	2008.01.03.21.37.25;	author kettenis;	state Exp;
branches;
next	1.30;

1.30
date	2007.12.07.00.34.20;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2007.10.08.17.48.06;	author krw;	state Exp;
branches;
next	1.28;

1.28
date	2007.09.17.01.33.33;	author krw;	state Exp;
branches;
next	1.27;

1.27
date	2007.05.29.09.54.13;	author sobrado;	state Exp;
branches;
next	1.26;

1.26
date	2006.06.28.20.09.15;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2006.06.27.20.20.48;	author jason;	state Exp;
branches;
next	1.24;

1.24
date	2006.06.02.20.00.56;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2005.09.08.15.25.54;	author martin;	state Exp;
branches;
next	1.22;

1.22
date	2005.03.05.01.44.52;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2005.01.27.21.17.50;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2003.06.24.21.54.39;	author henric;	state Exp;
branches;
next	1.19;

1.19
date	2003.06.18.17.33.35;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2003.06.11.03.16.12;	author henric;	state Exp;
branches;
next	1.17;

1.17
date	2003.06.02.23.27.55;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2003.03.06.08.26.08;	author henric;	state Exp;
branches;
next	1.15;

1.15
date	2003.02.17.01.29.20;	author henric;	state Exp;
branches;
next	1.14;

1.14
date	2002.03.14.20.26.20;	author jason;	state Exp;
branches;
next	1.13;

1.13
date	2002.03.14.03.16.00;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2002.03.14.01.26.44;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2002.03.12.19.46.25;	author jason;	state Exp;
branches;
next	1.10;

1.10
date	2002.02.05.18.34.39;	author jason;	state Exp;
branches;
next	1.9;

1.9
date	2002.01.10.00.06.17;	author nordin;	state Exp;
branches;
next	1.8;

1.8
date	2002.01.04.05.19.25;	author jason;	state Exp;
branches;
next	1.7;

1.7
date	2001.10.15.03.36.16;	author jason;	state Exp;
branches
	1.7.4.1
	1.7.6.1;
next	1.6;

1.6
date	2001.08.31.15.12.05;	author jason;	state Exp;
branches;
next	1.5;

1.5
date	2001.08.22.12.09.12;	author art;	state Exp;
branches;
next	1.4;

1.4
date	2001.08.20.19.40.43;	author jason;	state Exp;
branches;
next	1.3;

1.3
date	2001.08.19.05.32.03;	author art;	state Exp;
branches;
next	1.2;

1.2
date	2001.08.18.21.30.00;	author jason;	state Exp;
branches;
next	1.1;

1.1
date	2001.08.18.20.56.41;	author jason;	state Exp;
branches;
next	;

1.7.4.1
date	2001.10.31.03.07.58;	author nate;	state Exp;
branches;
next	1.7.4.2;

1.7.4.2
date	2002.03.06.02.04.46;	author niklas;	state Exp;
branches;
next	1.7.4.3;

1.7.4.3
date	2002.03.28.11.23.51;	author niklas;	state Exp;
branches;
next	1.7.4.4;

1.7.4.4
date	2003.03.27.23.42.36;	author niklas;	state Exp;
branches;
next	1.7.4.5;

1.7.4.5
date	2003.06.07.11.14.44;	author ho;	state Exp;
branches;
next	1.7.4.6;

1.7.4.6
date	2004.02.19.10.50.00;	author niklas;	state Exp;
branches;
next	;

1.7.6.1
date	2002.01.31.22.55.24;	author niklas;	state Exp;
branches;
next	1.7.6.2;

1.7.6.2
date	2002.06.11.03.38.43;	author art;	state Exp;
branches;
next	1.7.6.3;

1.7.6.3
date	2003.05.19.21.46.57;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.44
log
@trivial "if(x) free(x)" replacement by "free(x)"

ok miod@@
@
text
@/*	$OpenBSD: sbus.c,v 1.43 2014/12/09 06:58:29 doug Exp $	*/
/*	$NetBSD: sbus.c,v 1.46 2001/10/07 20:30:41 eeh Exp $ */

/*-
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Paul Kranenburg.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
 *
 * All advertising materials mentioning features or use of this software
 * must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Lawrence Berkeley Laboratory.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)sbus.c	8.1 (Berkeley) 6/11/93
 */

/*
 * Copyright (c) 1999 Eduardo Horvath
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR  ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR  BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */


/*
 * SBus stuff.
 */

#include <sys/param.h>
#include <sys/proc.h>
#include <sys/signalvar.h>
#include <sys/extent.h>
#include <sys/malloc.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/reboot.h>

#include <machine/bus.h>
#include <sparc64/sparc64/cache.h>
#include <sparc64/dev/iommureg.h>
#include <sparc64/dev/iommuvar.h>
#include <sparc64/dev/sbusreg.h>
#include <sparc64/dev/starfire.h>
#include <dev/sbus/sbusvar.h>
#include <dev/sbus/xboxvar.h>

#include <uvm/uvm_extern.h>

#include <machine/autoconf.h>
#include <machine/cpu.h>
#include <machine/openfirm.h>
#include <machine/sparc64.h>

#ifdef DEBUG
#define SDB_DVMA	0x1
#define SDB_INTR	0x2
#define SDB_CHILD	0x4
int sbus_debug = 0;
#define DPRINTF(l, s)   do { if (sbus_debug & l) printf s; } while (0)
#else
#define DPRINTF(l, s)
#endif

bus_space_tag_t sbus_alloc_bustag(struct sbus_softc *, int);
bus_dma_tag_t sbus_alloc_dma_tag(struct sbus_softc *, bus_dma_tag_t);
int sbus_get_intr(struct sbus_softc *, int,
    struct sbus_intr **, int *, int);
int sbus_overtemp(void *);
int _sbus_bus_map(bus_space_tag_t, bus_space_tag_t,
    bus_addr_t,		/*offset*/
    bus_size_t,		/*size*/
    int,		/*flags*/
    bus_space_handle_t *);
void *sbus_intr_establish(bus_space_tag_t, bus_space_tag_t,
    int,		/*SBus interrupt level*/
    int,		/*`device class' priority*/
    int,		/*flags*/
    int (*)(void *),	/*handler*/
    void *,		/*handler arg*/
    const char *);	/*what*/
void	sbus_attach_common(struct sbus_softc *, int, int);

/* autoconfiguration driver */
void	sbus_mb_attach(struct device *, struct device *, void *);
void	sbus_xbox_attach(struct device *, struct device *, void *);
int	sbus_mb_match(struct device *, void *, void *);
int	sbus_xbox_match(struct device *, void *, void *);

struct cfattach sbus_mb_ca = {
	sizeof(struct sbus_softc), sbus_mb_match, sbus_mb_attach
};

struct cfattach sbus_xbox_ca = {
	sizeof(struct sbus_softc), sbus_xbox_match, sbus_xbox_attach
};

struct cfdriver sbus_cd = {
	NULL, "sbus", DV_DULL
};

/*
 * DVMA routines
 */
int sbus_dmamap_create(bus_dma_tag_t, bus_dma_tag_t, bus_size_t, int,
    bus_size_t, bus_size_t, int, bus_dmamap_t *);

/*
 * Child devices receive the SBus interrupt level in their attach
 * arguments. We translate these to CPU IPLs using the following
 * tables. Note: obio bus interrupt levels are identical to the
 * processor IPL.
 *
 * The second set of tables is used when the SBus interrupt level
 * cannot be had from the PROM as an `interrupt' property. We then
 * fall back on the `intr' property which contains the CPU IPL.
 */

/* Translate SBus interrupt level to processor IPL */
static int intr_sbus2ipl_4u[] = {
	0, 2, 3, 5, 7, 9, 11, 13
};

/*
 * This value is or'ed into the attach args' interrupt level cookie
 * if the interrupt level comes from an `intr' property, i.e. it is
 * not an SBus interrupt level.
 */
#define SBUS_INTR_COMPAT	0x80000000


/*
 * Print the location of some sbus-attached device (called just
 * before attaching that device).  If `sbus' is not NULL, the
 * device was found but not configured; print the sbus as well.
 * Return UNCONF (config_find ignores this if the device was configured).
 */
int
sbus_print(void *args, const char *busname)
{
	struct sbus_attach_args *sa = args;
	char *class;
	int i;

	if (busname != NULL) {
		printf("\"%s\" at %s", sa->sa_name, busname);
		class = getpropstring(sa->sa_node, "device_type");
		if (*class != '\0')
			printf(" class %s", class);
	}
	printf(" slot %ld offset 0x%lx", (long)sa->sa_slot, 
	       (u_long)sa->sa_offset);
	for (i = 0; i < sa->sa_nintr; i++) {
		struct sbus_intr *sbi = &sa->sa_intr[i];

		printf(" vector %lx ipl %ld", 
		       (u_long)sbi->sbi_vec, 
		       (long)INTLEV(sbi->sbi_pri));
	}
	return (UNCONF);
}

int
sbus_mb_match(struct device *parent, void *vcf, void *aux)
{
	struct cfdata *cf = vcf;
	struct mainbus_attach_args *ma = aux;

	return (strcmp(cf->cf_driver->cd_name, ma->ma_name) == 0);
}

int
sbus_xbox_match(struct device *parent, void *vcf, void *aux)
{
	struct xbox_softc *xsc = (struct xbox_softc *)parent;

	/* Prevent multiple attachments */
	if (xsc->sc_attached == 0) {
		xsc->sc_attached = 1;
		return (1);
	}

	return (0);
}

void
sbus_xbox_attach(struct device *parent, struct device *self, void *aux)
{
	struct sbus_softc *sc = (struct sbus_softc *)self;
	struct xbox_softc *xsc = (struct xbox_softc *)parent;
	struct sbus_softc *sbus = (struct sbus_softc *)parent->dv_parent;
	struct xbox_attach_args *xa = aux;
	int node = xa->xa_node;

	sc->sc_master = sbus->sc_master;

	sc->sc_bustag = xa->xa_bustag;
	sc->sc_dmatag = sbus_alloc_dma_tag(sc, xa->xa_dmatag);

	/*
	 * Parent has already done the address translation computations.
	 */
	sc->sc_nrange = xsc->sc_nrange;
	sc->sc_range = xsc->sc_range;

	/*
	 * Record clock frequency for synchronous SCSI.
	 * IS THIS THE CORRECT DEFAULT??
	 */
	sc->sc_clockfreq = getpropint(node, "clock-frequency", 25*1000*1000);
	printf(": %s MHz\n", clockfreq(sc->sc_clockfreq));

	sbus_attach_common(sc, node, 1);
}

void
sbus_mb_attach(struct device *parent, struct device *self, void *aux)
{
	struct sbus_softc *sc = (struct sbus_softc *)self;
	struct mainbus_attach_args *ma = aux;
	int node = ma->ma_node;
	struct intrhand *ih;
	int ipl, error;
	struct sysioreg *sysio;
	char buf[32];
	char *name;

	sc->sc_master = sc;

	sc->sc_bustag = ma->ma_bustag;

	/* Find interrupt group no */
	sc->sc_ign = ma->ma_interrupts[0] & INTMAP_IGN;

	/*
	 * Collect address translations from the OBP.
	 */
	error = getprop(node, "ranges", sizeof(struct sbus_range),
			 &sc->sc_nrange, (void **)&sc->sc_range);
	if (error)
		panic("%s: error getting ranges property", sc->sc_dev.dv_xname);

	/*
	 * Record clock frequency for synchronous SCSI.
	 * IS THIS THE CORRECT DEFAULT??
	 */
	sc->sc_clockfreq = getpropint(node, "clock-frequency", 25*1000*1000);
	printf(": clock = %s MHz\n", clockfreq(sc->sc_clockfreq));

	bus_space_map(sc->sc_bustag,
	    ma->ma_address[0], sizeof(struct sysioreg),
	    BUS_SPACE_MAP_PROMADDRESS, &sc->sc_bh);
	sysio = bus_space_vaddr(sc->sc_bustag, sc->sc_bh);

	/* initialize the IOMMU */

	/* punch in our copies */
	sc->sc_is.is_bustag = sc->sc_bustag;
	bus_space_subregion(sc->sc_bustag, sc->sc_bh,
	    offsetof(struct sysioreg, sys_iommu),
	    sizeof(struct iommureg), &sc->sc_is.is_iommu);

	/* initialize our strbuf_ctl */
	sc->sc_is.is_sb[0] = &sc->sc_sb;
	if (bus_space_subregion(sc->sc_bustag, sc->sc_bh,
	    offsetof(struct sysioreg, sys_strbuf),
	    sizeof(struct iommu_strbuf), &sc->sc_sb.sb_sb) == 0) {
		/* point sb_flush to our flush buffer */
		sc->sc_sb.sb_flush = &sc->sc_flush;
		sc->sc_sb.sb_bustag = sc->sc_bustag;
	} else
		sc->sc_sb.sb_flush = NULL;

	/* give us a nice name.. */
	name = (char *)malloc(32, M_DEVBUF, M_NOWAIT);
	if (name == 0)
		panic("couldn't malloc iommu name");
	snprintf(name, 32, "%s dvma", sc->sc_dev.dv_xname);

	printf("%s: ", sc->sc_dev.dv_xname);
	iommu_init(name, &sc->sc_is, 0, -1);

	/* Initialize Starfire PC interrupt translation. */
	if (OF_getprop(findroot(), "name", buf, sizeof(buf)) > 0 &&
	    strcmp(buf, "SUNW,Ultra-Enterprise-10000") == 0)
		starfire_pc_ittrans_init(ma->ma_upaid);

	/* Enable the over temp intr */
	ih = malloc(sizeof(*ih), M_DEVBUF, M_NOWAIT | M_ZERO);
	if (ih == NULL)
		panic("couldn't malloc intrhand");
	ih->ih_map = &sysio->therm_int_map;
	ih->ih_clr = NULL; /* &sysio->therm_clr_int; */
	ih->ih_fun = sbus_overtemp;
	ipl = 1;
	ih->ih_pil = (1 << ipl);
	ih->ih_number = INTVEC(*(ih->ih_map));
	strlcpy(ih->ih_name, sc->sc_dev.dv_xname, sizeof(ih->ih_name));
	intr_establish(ipl, ih);
	*(ih->ih_map) |= INTMAP_V;
	
	/*
	 * Note: the stupid SBus IOMMU ignores the high bits of an address, so a
	 * NULL DMA pointer will be translated by the first page of the IOTSB.
	 * To avoid bugs we'll alloc and ignore the first entry in the IOTSB.
	 */
	{
		u_long dummy;

		if (extent_alloc_subregion(sc->sc_is.is_dvmamap,
		    sc->sc_is.is_dvmabase, sc->sc_is.is_dvmabase + NBPG, NBPG,
		    NBPG, 0, 0, EX_NOWAIT | EX_BOUNDZERO,
		    (u_long *)&dummy) != 0)
			panic("sbus iommu: can't toss first dvma page");
	}

	sc->sc_dmatag = sbus_alloc_dma_tag(sc, ma->ma_dmatag);

	sbus_attach_common(sc, node, 0);
}

/*
 * Attach an SBus (main part).
 */
void
sbus_attach_common(struct sbus_softc *sc, int node, int indirect)
{
	bus_space_tag_t sbt;
	struct sbus_attach_args sa;
	int node0;

	/* Setup interrupt translation tables */
	sc->sc_intr2ipl = intr_sbus2ipl_4u;

	sbt = sbus_alloc_bustag(sc, indirect);

	/*
	 * Get the SBus burst transfer size if burst transfers are supported
	 */
	sc->sc_burst = getpropint(node, "burst-sizes", 0);

	/*
	 * Loop through ROM children, fixing any relative addresses
	 * and then configuring each device.
	 * `specials' is an array of device names that are treated
	 * specially:
	 */
	node0 = firstchild(node);
	for (node = node0; node; node = nextsibling(node)) {
		if (!checkstatus(node))
			continue;

		if (sbus_setup_attach_args(sc, sbt, sc->sc_dmatag,
					   node, &sa) != 0) {
			DPRINTF(SDB_CHILD,
			    ("sbus_attach: %s: incomplete\n",
			    getpropstring(node, "name")));
			continue;
		}
		(void) config_found(&sc->sc_dev, (void *)&sa, sbus_print);
		sbus_destroy_attach_args(&sa);
	}
}

int
sbus_setup_attach_args(struct sbus_softc *sc, bus_space_tag_t bustag,
    bus_dma_tag_t dmatag, int node, struct sbus_attach_args *sa)
{
	int	error;
	int	n;

	bzero(sa, sizeof(struct sbus_attach_args));
	error = getprop(node, "name", 1, &n, (void **)&sa->sa_name);
	if (error != 0)
		return (error);
	sa->sa_name[n] = '\0';

	sa->sa_bustag = bustag;
	sa->sa_dmatag = dmatag;
	sa->sa_node = node;
	sa->sa_frequency = sc->sc_clockfreq;

	error = getprop(node, "reg", sizeof(struct sbus_reg),
			 &sa->sa_nreg, (void **)&sa->sa_reg);
	if (error != 0) {
		char buf[32];
		if (error != ENOENT ||
		    !node_has_property(node, "device_type") ||
		    strcmp(getpropstringA(node, "device_type", buf),
			   "hierarchical") != 0)
			return (error);
	}
	for (n = 0; n < sa->sa_nreg; n++) {
		/* Convert to relative addressing, if necessary */
		u_int32_t base = sa->sa_reg[n].sbr_offset;
		if (SBUS_ABS(base)) {
			sa->sa_reg[n].sbr_slot = SBUS_ABS_TO_SLOT(base);
			sa->sa_reg[n].sbr_offset = SBUS_ABS_TO_OFFSET(base);
		}
	}

	if ((error = sbus_get_intr(sc, node, &sa->sa_intr, &sa->sa_nintr,
	    sa->sa_slot)) != 0)
		return (error);

	error = getprop(node, "address", sizeof(u_int32_t),
			 &sa->sa_npromvaddrs, (void **)&sa->sa_promvaddrs);
	if (error != 0 && error != ENOENT)
		return (error);

	return (0);
}

void
sbus_destroy_attach_args(struct sbus_attach_args *sa)
{
	free(sa->sa_name, M_DEVBUF, 0);
	free(sa->sa_reg, M_DEVBUF, 0);
	free(sa->sa_intr, M_DEVBUF, 0);
	free((void *)sa->sa_promvaddrs, M_DEVBUF, 0);

	bzero(sa, sizeof(struct sbus_attach_args)); /*DEBUG*/
}


int
_sbus_bus_map(bus_space_tag_t t, bus_space_tag_t t0, bus_addr_t addr,
    bus_size_t size, int flags, bus_space_handle_t *hp)
{
	struct sbus_softc *sc = t->cookie;
	int64_t slot = BUS_ADDR_IOSPACE(addr);
	int64_t offset = BUS_ADDR_PADDR(addr);
	int i;

	if (t->parent == NULL || t->parent->sparc_bus_map == NULL) {
		printf("\n_psycho_bus_map: invalid parent");
		return (EINVAL);
	}

	if (flags & BUS_SPACE_MAP_PROMADDRESS) {
		return ((*t->parent->sparc_bus_map)(t, t0, addr,
					size, flags, hp));
	}

	for (i = 0; i < sc->sc_nrange; i++) {
		bus_addr_t paddr;

		if (sc->sc_range[i].cspace != slot)
			continue;

		/* We've found the connection to the parent bus */
		paddr = sc->sc_range[i].poffset + offset;
		paddr |= ((bus_addr_t)sc->sc_range[i].pspace << 32);
		DPRINTF(SDB_DVMA, ("_sbus_bus_map: mapping paddr "
			"slot %lx offset %lx poffset %lx paddr %lx\n",
		    (long)slot, (long)offset, (long)sc->sc_range[i].poffset,
		    (long)paddr));
		return ((*t->parent->sparc_bus_map)(t, t0, paddr,
					size, flags, hp));
	}

	return (EINVAL);
}

bus_addr_t
sbus_bus_addr(bus_space_tag_t t, u_int btype, u_int offset)
{
	bus_addr_t baddr = ~(bus_addr_t)0;
	int slot = btype;
	struct sbus_softc *sc = t->cookie;
	int i;

	for (i = 0; i < sc->sc_nrange; i++) {
		if (sc->sc_range[i].cspace != slot)
			continue;

		baddr = sc->sc_range[i].poffset + offset;
		baddr |= (bus_addr_t)sc->sc_range[i].pspace << 32;
	}

	return (baddr);
}

/*
 * Handle an overtemp situation.
 *
 * SPARCs have temperature sensors which generate interrupts
 * if the machine's temperature exceeds a certain threshold.
 * This handles the interrupt and powers off the machine.
 * The same needs to be done to PCI controller drivers.
 */
int
sbus_overtemp(void *arg)
{
	/* Should try a clean shutdown first */
	printf("DANGER: OVER TEMPERATURE detected\nShutting down...\n");
	delay(20);
	prsignal(initprocess, SIGUSR2);
	return (1);
}

/*
 * Get interrupt attributes for an SBus device.
 */
int
sbus_get_intr(struct sbus_softc *sc, int node, struct sbus_intr **ipp, int *np,
    int slot)
{
	int *ipl;
	int n, i;
	char buf[32];

	/*
	 * The `interrupts' property contains the SBus interrupt level.
	 */
	ipl = NULL;
	if (getprop(node, "interrupts", sizeof(int), np, (void **)&ipl) == 0) {
		struct sbus_intr *ip;
		int pri;

		/* Default to interrupt level 2 -- otherwise unused */
		pri = INTLEVENCODE(2);

		/* Change format to an `struct sbus_intr' array */
		ip = mallocarray(*np, sizeof(struct sbus_intr), M_DEVBUF,
		    M_NOWAIT);
		if (ip == NULL)
			return (ENOMEM);

		/*
		 * Now things get ugly.  We need to take this value which is
		 * the interrupt vector number and encode the IPL into it
		 * somehow. Luckily, the interrupt vector has lots of free
		 * space and we can easily stuff the IPL in there for a while.
		 */
		getpropstringA(node, "device_type", buf);
		if (!buf[0])
			getpropstringA(node, "name", buf);

		for (i = 0; intrmap[i].in_class; i++) 
			if (strcmp(intrmap[i].in_class, buf) == 0) {
				pri = INTLEVENCODE(intrmap[i].in_lev);
				break;
			}

		/*
		 * SBus card devices need the slot number encoded into
		 * the vector as this is generally not done.
		 */
		if ((ipl[0] & INTMAP_OBIO) == 0)
			pri |= slot << 3;

		for (n = 0; n < *np; n++) {
			/* 
			 * We encode vector and priority into sbi_pri so we 
			 * can pass them as a unit.  This will go away if 
			 * sbus_establish ever takes an sbus_intr instead 
			 * of an integer level.
			 * Stuff the real vector in sbi_vec.
			 */

			ip[n].sbi_pri = pri | ipl[n];
			ip[n].sbi_vec = ipl[n];
		}
		free(ipl, M_DEVBUF, 0);
		*ipp = ip;
	}
	
	return (0);
}


/*
 * Install an interrupt handler for an SBus device.
 */
void *
sbus_intr_establish(bus_space_tag_t t, bus_space_tag_t t0, int pri, int level,
    int flags, int (*handler)(void *), void *arg, const char *what)
{
	struct sbus_softc *sc = t->cookie;
	struct sysioreg *sysio;
	struct intrhand *ih;
	volatile u_int64_t *map = NULL;
	volatile u_int64_t *clr = NULL;
	int ipl;
	long vec = pri; 

	/* Pick the master SBus as all do not have IOMMU registers */
	sc = sc->sc_master;

	sysio = bus_space_vaddr(sc->sc_bustag, sc->sc_bh);

	if ((flags & BUS_INTR_ESTABLISH_SOFTINTR) != 0)
		ipl = 1 << vec;
	else if ((vec & SBUS_INTR_COMPAT) != 0)
		ipl = 1 << (vec & ~SBUS_INTR_COMPAT);
	else {
		/* Decode and remove IPL */
		ipl = level;
		if (ipl == IPL_NONE)
			ipl = 1 << INTLEV(vec);
		if (ipl == IPL_NONE) {
			printf("ERROR: no IPL, setting IPL 2.\n");
			ipl = 2;
		}
		vec = INTVEC(vec);
		DPRINTF(SDB_INTR,
		    ("\nsbus: intr[%ld]%lx: %lx\nHunting for IRQ...\n",
		    (long)ipl, (long)vec, (u_long)intrlev[vec]));
		if ((vec & INTMAP_OBIO) == 0) {
			/* We're in an SBus slot */
			/* Register the map and clear intr registers */
			bus_space_handle_t maph;
			int slot = INTSLOT(pri);

			map = &(&sysio->sbus_slot0_int)[slot];
			clr = &sysio->sbus0_clr_int[vec];
#ifdef DEBUG
			if (sbus_debug & SDB_INTR) {
				int64_t intrmap = *map;
				
				printf("SBus %lx IRQ as %llx in slot %d\n", 
				       (long)vec, (long long)intrmap, slot);
				printf("\tmap addr %p clr addr %p\n",
				    map, clr);
			}
#endif
			/* Enable the interrupt */
			vec |= INTMAP_V;
			/* Insert IGN */
			vec |= sc->sc_ign;
			/*
			 * This would be cleaner if the underlying interrupt
			 * infrastructure took a bus tag/handle pair.  Even
			 * if not, the following could be done with a write
			 * to the appropriate offset from sc->sc_bustag and
			 * sc->sc_bh.
			 */
			bus_space_map(sc->sc_bustag, (bus_addr_t)map, 8,
			    BUS_SPACE_MAP_PROMADDRESS, &maph);
			bus_space_write_8(sc->sc_bustag, maph, 0, vec);
		} else {
			bus_space_handle_t maph;
			volatile int64_t *intrptr = &sysio->scsi_int_map;
			int64_t intrmap = 0;
			int i;

			/* Insert IGN */
			vec |= sc->sc_ign;
			for (i = 0; &intrptr[i] <=
			    (int64_t *)&sysio->reserved_int_map &&
			    INTVEC(intrmap = intrptr[i]) != INTVEC(vec); i++)
				;
			if (INTVEC(intrmap) == INTVEC(vec)) {
				DPRINTF(SDB_INTR,
				    ("OBIO %lx IRQ as %lx in slot %d\n", 
				    vec, (long)intrmap, i));
				/* Register the map and clear intr registers */
				map = &intrptr[i];
				intrptr = (int64_t *)&sysio->scsi_clr_int;
				clr = &intrptr[i];
				/* Enable the interrupt */
				intrmap |= INTMAP_V;
				/*
				 * This would be cleaner if the underlying
				 * interrupt infrastructure took a bus tag/
				 * handle pair.  Even if not, the following
				 * could be done with a write to the
				 * appropriate offset from sc->sc_bustag and
				 * sc->sc_bh.
				 */
				bus_space_map(sc->sc_bustag,
				    (bus_addr_t)map, 8,
				    BUS_SPACE_MAP_PROMADDRESS, &maph);
				bus_space_write_8(sc->sc_bustag, maph, 0,
				    (u_long)intrmap);
			} else
				panic("IRQ not found!");
		}
	}
#ifdef DEBUG
	if (sbus_debug & SDB_INTR) { long i; for (i = 0; i < 400000000; i++); }
#endif

	ih = bus_intr_allocate(t0, handler, arg, vec, ipl, map, clr, what);
	if (ih == NULL)
		return (ih);

	intr_establish(ih->ih_pil, ih);

	return (ih);
}

bus_space_tag_t
sbus_alloc_bustag(struct sbus_softc *sc, int indirect)
{
	struct sparc_bus_space_tag *sbt;

	sbt = malloc(sizeof(*sbt), M_DEVBUF, M_NOWAIT | M_ZERO);
	if (sbt == NULL)
		return (NULL);

	strlcpy(sbt->name, sc->sc_dev.dv_xname, sizeof(sbt->name));
	sbt->cookie = sc;
	if (indirect)
		sbt->parent = sc->sc_bustag->parent;
	else
		sbt->parent = sc->sc_bustag;
	sbt->default_type = SBUS_BUS_SPACE;
	sbt->asi = ASI_PRIMARY;
	sbt->sasi = ASI_PRIMARY;
	sbt->sparc_bus_map = _sbus_bus_map;
	sbt->sparc_bus_mmap = sc->sc_bustag->sparc_bus_mmap;
	sbt->sparc_intr_establish = sbus_intr_establish;
	return (sbt);
}


bus_dma_tag_t
sbus_alloc_dma_tag(struct sbus_softc *sc, bus_dma_tag_t psdt)
{
	bus_dma_tag_t sdt;

	sdt = (bus_dma_tag_t)malloc(sizeof(struct sparc_bus_dma_tag),
	    M_DEVBUF, M_NOWAIT | M_ZERO);
	if (sdt == NULL)
		/* Panic? */
		return (psdt);

	sdt->_cookie = sc;
	sdt->_parent = psdt;
	sdt->_dmamap_create	= sbus_dmamap_create;
	sdt->_dmamap_destroy	= iommu_dvmamap_destroy;
	sdt->_dmamap_load	= iommu_dvmamap_load;
	sdt->_dmamap_load_raw	= iommu_dvmamap_load_raw;
	sdt->_dmamap_unload	= iommu_dvmamap_unload;
	sdt->_dmamap_sync	= iommu_dvmamap_sync;
	sdt->_dmamem_alloc	= iommu_dvmamem_alloc;
	sdt->_dmamem_free	= iommu_dvmamem_free;
	return (sdt);
}

int
sbus_dmamap_create(bus_dma_tag_t t, bus_dma_tag_t t0, bus_size_t size,
    int nsegments, bus_size_t maxsegsz, bus_size_t boundary, int flags,
    bus_dmamap_t *dmamp)
{
	struct sbus_softc *sc = t->_cookie;

	/* Disallow DMA on secondary SBuses for now */
	if (sc != sc->sc_master)
		return (EINVAL);

        return (iommu_dvmamap_create(t, t0, &sc->sc_sb, size, nsegments,
	    maxsegsz, boundary, flags, dmamp));
}
@


1.43
log
@Replace some malloc(n*size,...) calls with mallocarray().

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sbus.c,v 1.42 2014/07/12 20:18:09 uebayasi Exp $	*/
d488 4
a491 11
	if (sa->sa_name != NULL)
		free(sa->sa_name, M_DEVBUF, 0);

	if (sa->sa_nreg != 0)
		free(sa->sa_reg, M_DEVBUF, 0);

	if (sa->sa_intr)
		free(sa->sa_intr, M_DEVBUF, 0);

	if (sa->sa_promvaddrs)
		free((void *)sa->sa_promvaddrs, M_DEVBUF, 0);
@


1.42
log
@reboot(9): Shutdown system by signaling init(8) from kernel where appropriate

Some ports watch temperature in MD and try to shutdown system, when overheated,
by calling directly (re)boot(9).  Change this to signal init(8) from kernel,
as acpi(4) and acpitz(4) do, which has been more tested.  This also helps to
clarify design that ``clean shutdown must be always started by init(8)''.

Note that SIGUSR2 causes init(8) to call reboot(2) with RB_POWERDOWN, as
acpi(4) etc. already does.  It is reasonable, pointed out by kettenis@@,
considering system is overheated and immediate reboot may be dangerous.

OK deraadt@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d603 2
a604 1
		ip = malloc(*np * sizeof(struct sbus_intr), M_DEVBUF, M_NOWAIT);
@


1.41
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: sbus.c,v 1.40 2014/07/12 14:12:44 uebayasi Exp $	*/
d102 2
d576 1
a576 2
	reboot(RB_POWERDOWN | RB_HALT);
	/*NOTREACHED*/
@


1.40
log
@boot(9), reboot(9): Migrate MD callers of boot(9) to reboot(9)

I have found that some ports call boot(9) from machine-dependent code to
reboot system.  These should be changed to either:

- Sending signal to init(8) to trigger it to shutdown system cleanly, like
  acpi(4) does, in cases where found problems don't prevent system from working
  immediately, or

- Just doing panic(9) if the situation is severely broken.

For now, just rewrite boot() to reboot().  Actual fixes follow.

Discussed with & OK from kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d487 1
a487 1
		free(sa->sa_name, M_DEVBUF);
d490 1
a490 1
		free(sa->sa_reg, M_DEVBUF);
d493 1
a493 1
		free(sa->sa_intr, M_DEVBUF);
d496 1
a496 1
		free((void *)sa->sa_promvaddrs, M_DEVBUF);
d641 1
a641 1
		free(ipl, M_DEVBUF);
@


1.39
log
@Clean up how we print the sbus(4) clock speed.  Purely cosmetic.

ok miod@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sbus.c,v 1.38 2010/11/11 17:58:23 miod Exp $	*/
d574 1
a574 1
	boot(RB_POWERDOWN|RB_HALT);
@


1.38
log
@Replace snprintf(foo, sizeof foo, "%s", ...) with strlcpy. ok deraadt@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sbus.c,v 1.37 2009/01/14 20:35:42 miod Exp $	*/
d280 1
a280 1
	printf(": clock = %s MHz\n", clockfreq(sc->sc_clockfreq));
@


1.37
log
@Be sure to allocate memory with M_ZERO in sbus_alloc_dma_tag(), or strange
things happen. ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sbus.c,v 1.36 2009/01/02 20:01:45 kettenis Exp $	*/
d779 1
a779 2
	snprintf(sbt->name, sizeof(sbt->name), "%s",
		sc->sc_dev.dv_xname);
@


1.36
log
@Make IOMMU code use the generic _bus_dmamem_map() and _bus_dmamem_unmap().
@
text
@d1 1
a1 1
/*	$OpenBSD: sbus.c,v 1.35 2008/06/26 05:42:13 ray Exp $	*/
d801 2
a802 2
	sdt = (bus_dma_tag_t)
		malloc(sizeof(struct sparc_bus_dma_tag), M_DEVBUF, M_NOWAIT);
@


1.35
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sbus.c,v 1.34 2008/03/16 22:19:57 kettenis Exp $	*/
a816 2
	sdt->_dmamem_map	= iommu_dvmamem_map;
	sdt->_dmamem_unmap	= iommu_dvmamem_unmap;
@


1.34
log
@Set up interrupt translation for e10k.
@
text
@d1 1
a1 1
/*	$OpenBSD: sbus.c,v 1.33 2008/03/09 13:28:20 kettenis Exp $	*/
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.33
log
@Check "status" property.
@
text
@d1 1
a1 1
/*	$OpenBSD: sbus.c,v 1.32 2008/01/17 22:53:18 kettenis Exp $	*/
d120 1
d128 1
d301 1
d358 5
@


1.32
log
@Print names we get from the prom within double quotes.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sbus.c,v 1.31 2008/01/03 21:37:25 kettenis Exp $	*/
d418 3
@


1.31
log
@Remove redundant extenr declaration.
@
text
@d1 1
a1 1
/*	$OpenBSD: sbus.c,v 1.30 2007/12/07 00:34:20 deraadt Exp $	*/
d220 1
a220 1
		printf("%s at %s", sa->sa_name, busname);
@


1.30
log
@unify a function name compared to other busses
@
text
@d1 1
a1 1
/*	$OpenBSD: sbus.c,v 1.29 2007/10/08 17:48:06 krw Exp $	*/
a174 2

extern struct cfdriver sbus_cd;
@


1.29
log
@A few trailing bzero/memset -> M_ZERO occurrences, cast removal and
size(*p) usage.
@
text
@d1 1
a1 1
/*	$OpenBSD: sbus.c,v 1.28 2007/09/17 01:33:33 krw Exp $	*/
d140 1
a140 1
bus_dma_tag_t sbus_alloc_dmatag(struct sbus_softc *, bus_dma_tag_t);
d274 1
a274 1
	sc->sc_dmatag = sbus_alloc_dmatag(sc, xa->xa_dmatag);
d387 1
a387 1
	sc->sc_dmatag = sbus_alloc_dmatag(sc, ma->ma_dmatag);
d795 1
a795 1
sbus_alloc_dmatag(struct sbus_softc *sc, bus_dma_tag_t psdt)
@


1.28
log
@Only the most obvious bzero() -> M_ZERO changes. No cast changes, no
MALLOC/FREE, etc. Just adding M_ZERO to malloc() and deleting an
immediately adjacent bzero().
@
text
@d1 1
a1 1
/*	$OpenBSD: sbus.c,v 1.27 2007/05/29 09:54:13 sobrado Exp $	*/
d359 1
a359 2
	ih = (struct intrhand *)
		malloc(sizeof(struct intrhand), M_DEVBUF, M_NOWAIT);
a361 1
	memset(ih, 0, sizeof(struct intrhand));
@


1.27
log
@use the right capitalization for `SBus'

ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sbus.c,v 1.26 2006/06/28 20:09:15 deraadt Exp $	*/
d775 1
a775 1
	sbt = malloc(sizeof(*sbt), M_DEVBUF, M_NOWAIT);
a778 1
	bzero(sbt, sizeof *sbt);
@


1.26
log
@cleanup dmesg logging for iommu goo, make it follow the standard form
@
text
@d1 1
a1 1
/*	$OpenBSD: sbus.c,v 1.25 2006/06/27 20:20:48 jason Exp $	*/
d105 1
a105 1
 * Sbus stuff.
d150 1
a150 1
    int,		/*Sbus interrupt level*/
d185 1
a185 1
 * Child devices receive the Sbus interrupt level in their attach
d190 1
a190 1
 * The second set of tables is used when the Sbus interrupt level
d195 1
a195 1
/* Translate Sbus interrupt level to processor IPL */
d203 1
a203 1
 * not an Sbus interrupt level.
d375 1
a375 1
	 * Note: the stupid SBUS IOMMU ignores the high bits of an address, so a
d395 1
a395 1
 * Attach an Sbus (main part).
d580 1
a580 1
 * Get interrupt attributes for an Sbus device.
d591 1
a591 1
	 * The `interrupts' property contains the Sbus interrupt level.
d623 1
a623 1
		 * Sbus card devices need the slot number encoded into
d650 1
a650 1
 * Install an interrupt handler for an Sbus device.
d687 1
a687 1
			/* We're in an SBUS slot */
d698 1
a698 1
				printf("SBUS %lx IRQ as %llx in slot %d\n", 
@


1.25
log
@don't bother printing "{se}bus: %s incomplete" for devices missing a reg
property.  They're not interesting.
@
text
@d1 1
a1 1
/*	$OpenBSD: sbus.c,v 1.24 2006/06/02 20:00:56 miod Exp $	*/
d355 1
@


1.24
log
@sbus_establish() and the associated linked list in the sbus softc is now only
used to store a per-device reset callback, for use in sbusreset(). Except
sbusreset() has never, ever, been used since Torek's sbus code went in.
Time to recycle those wasted bits.
@
text
@d1 1
a1 1
/*	$OpenBSD: sbus.c,v 1.23 2005/09/08 15:25:54 martin Exp $	*/
d132 1
a420 2
		char *name = getpropstring(node, "name");

d423 3
a425 1
			printf("sbus_attach: %s: incomplete\n", name);
@


1.23
log
@make comments match the fact that we are on sun4u, plus minor cleanup

ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sbus.c,v 1.22 2005/03/05 01:44:52 miod Exp $	*/
a137 2
void sbusreset(int);

a555 56
}


/*
 * Each attached device calls sbus_establish after it initializes
 * its sbusdev portion.
 */
void
sbus_establish(struct sbusdev *sd, struct device *dev)
{
	struct sbus_softc *sc;
	struct device *curdev;

	/*
	 * We have to look for the sbus by name, since it is not necessarily
	 * our immediate parent.
	 * We don't just use the device structure of the above-attached
	 * sbus, since we support multiple sbus's.
	 */
	for (curdev = dev->dv_parent; ; curdev = curdev->dv_parent) {
		if (!curdev || !curdev->dv_xname)
			panic("sbus_establish: can't find sbus parent for %s",
			      sd->sd_dev->dv_xname
					? sd->sd_dev->dv_xname
					: "<unknown>" );

		if (strncmp(curdev->dv_xname, "sbus", 4) == 0)
			break;
	}
	sc = (struct sbus_softc *) curdev;

	sd->sd_dev = dev;
	sd->sd_bchain = sc->sc_sbdev;
	sc->sc_sbdev = sd;
}

/*
 * Reset the given sbus.
 */
void
sbusreset(int sbus)
{
	struct sbusdev *sd;
	struct sbus_softc *sc = sbus_cd.cd_devs[sbus];
	struct device *dev;

	printf("reset %s:", sc->sc_dev.dv_xname);
	for (sd = sc->sc_sbdev; sd != NULL; sd = sd->sd_bchain) {
		if (sd->sd_reset) {
			dev = sd->sd_dev;
			(*sd->sd_reset)(dev);
			printf(" %s", dev->dv_xname);
		}
	}
	/* Reload iommu regs */
	iommu_reset(&sc->sc_is);
@


1.22
log
@Preliminary xbox support: attaches, memory mapping and interrupts work, but
DMA transfers are not implemented yet, and are disabled (which causes drivers
to SBus cards on the xbox to fail to attach).

In practice, this allows frame buffers to work, maybe more devices; DMA
support will be worked on in the near future.
@
text
@d1 1
a1 1
/*	$OpenBSD: sbus.c,v 1.21 2005/01/27 21:17:50 miod Exp $	*/
d573 1
a573 1
	 * our immediate parent (i.e. sun4m /iommu/sbus/espdma/esp)
@


1.21
log
@Fill all fields of intrhand structures not created by bus_intr_allocate().
@
text
@d1 1
a1 1
/*	$OpenBSD: sbus.c,v 1.20 2003/06/24 21:54:39 henric Exp $	*/
d121 1
d140 3
a142 3
static bus_space_tag_t sbus_alloc_bustag(struct sbus_softc *);
static bus_dma_tag_t sbus_alloc_dmatag(struct sbus_softc *);
static int sbus_get_intr(struct sbus_softc *, int,
d144 2
a145 2
static int sbus_overtemp(void *);
static int _sbus_bus_map(bus_space_tag_t, bus_space_tag_t,
d150 1
a150 1
static void *sbus_intr_establish(bus_space_tag_t, bus_space_tag_t,
d157 1
a157 1

d160 4
a163 2
int	sbus_match(struct device *, void *, void *);
void	sbus_attach(struct device *, struct device *, void *);
d165 3
d169 2
a170 2
struct cfattach sbus_ca = {
	sizeof(struct sbus_softc), sbus_match, sbus_attach
d241 1
a241 1
sbus_match(struct device *parent, void *vcf, void *aux)
d249 14
a262 3
/*
 * Attach an Sbus.
 */
d264 1
a264 1
sbus_attach(struct device *parent, struct device *self, void *aux)
d267 4
a270 9
	struct mainbus_attach_args *ma = aux;
	struct intrhand *ih;
	struct sysioreg *sysio;
	int ipl;
	char *name;
	int node = ma->ma_node;
	int node0, error;
	bus_space_tag_t sbt;
	struct sbus_attach_args sa;
d272 1
a272 4
	sc->sc_bustag = ma->ma_bustag;
	sc->sc_dmatag = ma->ma_dmatag;
	/* Find interrupt group no */
	sc->sc_ign = ma->ma_interrupts[0] & INTMAP_IGN;
d274 2
a275 4
	bus_space_map(sc->sc_bustag,
	    ma->ma_address[0], sizeof(struct sysioreg),
	    BUS_SPACE_MAP_PROMADDRESS, &sc->sc_bh);
	sysio = bus_space_vaddr(sc->sc_bustag, sc->sc_bh);
d277 5
a281 2
	/* Setup interrupt translation tables */
	sc->sc_intr2ipl = intr_sbus2ipl_4u;
d290 2
a291 2
	sbt = sbus_alloc_bustag(sc);
	sc->sc_dmatag = sbus_alloc_dmatag(sc);
d293 17
a309 4
	/*
	 * Get the SBus burst transfer size if burst transfers are supported
	 */
	sc->sc_burst = getpropint(node, "burst-sizes", 0);
d319 12
d389 25
d575 1
a575 1
	 * sbus, since we might (in the future) support multiple sbus's.
d720 3
d826 2
a827 2
static bus_space_tag_t
sbus_alloc_bustag(struct sbus_softc *sc)
d839 4
a842 1
	sbt->parent = sc->sc_bustag;
d853 2
a854 2
static bus_dma_tag_t
sbus_alloc_dmatag(struct sbus_softc *sc)
d856 1
a856 1
	bus_dma_tag_t sdt, psdt = sc->sc_dmatag;
a875 1
	sc->sc_dmatag = sdt;
d886 4
a892 1

@


1.20
log
@Add a "where" argument to the sparc64 interrupt code.  This lets us
associate a name with each interrupt handler.  This is not visible
outside the kernel (yet).

ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sbus.c,v 1.19 2003/06/18 17:33:35 miod Exp $	*/
d328 1
d335 1
@


1.19
log
@When reporting unknown sbus hardware, also report the hardware class (audio,
block device...) if it advertizes one.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sbus.c,v 1.18 2003/06/11 03:16:12 henric Exp $	*/
d154 2
a155 1
    void *);		/*handler arg*/
d648 1
a648 1
    int flags, int (*handler)(void *), void *arg)
d653 2
a659 5
	ih = (struct intrhand *)
		malloc(sizeof(struct intrhand), M_DEVBUF, M_NOWAIT);
	if (ih == NULL)
		return (NULL);

d683 2
a684 2
			ih->ih_map = &(&sysio->sbus_slot0_int)[slot];
			ih->ih_clr = &sysio->sbus0_clr_int[vec];
d687 1
a687 1
				int64_t intrmap = *ih->ih_map;
d692 1
a692 1
				    ih->ih_map, ih->ih_clr);
d706 1
a706 1
			bus_space_map(sc->sc_bustag, (bus_addr_t)ih->ih_map, 8,
d726 1
a726 1
				ih->ih_map = &intrptr[i];
d728 1
a728 1
				ih->ih_clr = &intrptr[i];
d740 1
a740 1
				    (bus_addr_t)ih->ih_map, 8,
d752 4
a755 4
	ih->ih_fun = handler;
	ih->ih_arg = arg;
	ih->ih_number = vec;
	ih->ih_pil = ipl;
d757 1
@


1.18
log
@Much of the sbus, psycho, and schizo bus_dma code is the same, so let's
call the real implementation functions directly instead of duplicating
lots of code that only calls the real stuff anyway.

tested by miod@@ henning@@
ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sbus.c,v 1.17 2003/06/02 23:27:55 millert Exp $	*/
d212 1
d215 1
a215 1
	if (busname)
d217 4
@


1.17
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: sbus.c,v 1.16 2003/03/06 08:26:08 henric Exp $	*/
a176 17
void sbus_dmamap_destroy(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t);
int sbus_dmamap_load(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t, void *,
    bus_size_t, struct proc *, int);
void sbus_dmamap_unload(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t);
int sbus_dmamap_load_raw(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t,
    bus_dma_segment_t *, int, bus_size_t, int);
void sbus_dmamap_sync(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t, bus_addr_t,
    bus_size_t, int);
int sbus_dmamem_alloc(bus_dma_tag_t, bus_dma_tag_t tag, bus_size_t size,
    bus_size_t alignment, bus_size_t boundary, bus_dma_segment_t *segs,
    int nsegs, int *rsegs, int flags);
void sbus_dmamem_free(bus_dma_tag_t, bus_dma_tag_t tag,
    bus_dma_segment_t *segs, int nsegs);
int sbus_dmamem_map(bus_dma_tag_t, bus_dma_tag_t tag, bus_dma_segment_t *segs,
    int nsegs, size_t size, caddr_t *kvap, int flags);
void sbus_dmamem_unmap(bus_dma_tag_t, bus_dma_tag_t tag, caddr_t kva,
    size_t size);
d307 1
a307 1
		sc->sc_is.is_sb[0] = NULL;
d794 10
a803 10
	sdt->_dmamap_create = sbus_dmamap_create;
	sdt->_dmamap_destroy = sbus_dmamap_destroy;
	sdt->_dmamap_load = sbus_dmamap_load;
	sdt->_dmamap_load_raw = sbus_dmamap_load_raw;
	sdt->_dmamap_unload = sbus_dmamap_unload;
	sdt->_dmamap_sync = sbus_dmamap_sync;
	sdt->_dmamem_alloc = sbus_dmamem_alloc;
	sdt->_dmamem_free = sbus_dmamem_free;
	sdt->_dmamem_map = sbus_dmamem_map;
	sdt->_dmamem_unmap = sbus_dmamem_unmap;
d815 2
a816 2
        return (iommu_dvmamap_create(t0, &sc->sc_is, &sc->sc_sb, size,
            nsegments, maxsegsz, boundary, flags, dmamp));
a818 96
void
sbus_dmamap_destroy(bus_dma_tag_t t, bus_dma_tag_t t0, bus_dmamap_t map)
{
	iommu_dvmamap_destroy(t0, map);
}

int
sbus_dmamap_load(bus_dma_tag_t t, bus_dma_tag_t t0, bus_dmamap_t map,
    void *buf, bus_size_t buflen, struct proc *p, int flags)
{
	struct sbus_softc *sc = t->_cookie;

	return (iommu_dvmamap_load(t0, &sc->sc_is, map, buf, buflen,
	    p, flags));
}

int
sbus_dmamap_load_raw(bus_dma_tag_t t, bus_dma_tag_t t0, bus_dmamap_t map,
    bus_dma_segment_t *segs, int nsegs, bus_size_t size, int flags)
{
	struct sbus_softc *sc = t->_cookie;

	return (iommu_dvmamap_load_raw(t0, &sc->sc_is, map, segs,
	    nsegs, flags, size));
}

void
sbus_dmamap_unload(bus_dma_tag_t t, bus_dma_tag_t t0, bus_dmamap_t map)
{
	struct sbus_softc *sc = t->_cookie;

	iommu_dvmamap_unload(t0, &sc->sc_is, map);
}

void
sbus_dmamap_sync(bus_dma_tag_t t, bus_dma_tag_t t0, bus_dmamap_t map,
    bus_addr_t offset, bus_size_t len, int ops)
{
	struct sbus_softc *sc = t->_cookie;

	if (t->_parent == NULL)
		panic("sbus_dmamap_sync: no parent");

	for (t = t->_parent; t->_dmamap_sync == NULL; t = t->_parent)
		if (t == NULL)
			panic("sbus_dmamap_sync: can't find implementation");

	if (ops & (BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE)) {
		/* Flush the CPU then the IOMMU */
		(*t->_dmamap_sync)(t, t0, map, offset, len, ops);
		iommu_dvmamap_sync(t0, &sc->sc_is, map, offset, len, ops);
	}
	if (ops & (BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE)) {
		/* Flush the IOMMU then the CPU */
		iommu_dvmamap_sync(t0, &sc->sc_is, map, offset, len, ops);
		(*t->_dmamap_sync)(t, t0, map, offset, len, ops);
	}
}

int
sbus_dmamem_alloc(bus_dma_tag_t t, bus_dma_tag_t t0, bus_size_t size,
    bus_size_t alignment, bus_size_t boundary, bus_dma_segment_t *segs,
    int nsegs, int *rsegs, int flags)
{
	struct sbus_softc *sc = t->_cookie;

	return (iommu_dvmamem_alloc(t0, &sc->sc_is, size, alignment, boundary,
	    segs, nsegs, rsegs, flags));
}

void
sbus_dmamem_free(bus_dma_tag_t t, bus_dma_tag_t t0, bus_dma_segment_t *segs,
    int nsegs)
{
	struct sbus_softc *sc = t->_cookie;

	iommu_dvmamem_free(t0, &sc->sc_is, segs, nsegs);
}

int
sbus_dmamem_map(bus_dma_tag_t t, bus_dma_tag_t t0, bus_dma_segment_t *segs,
    int nsegs, size_t size, caddr_t *kvap, int flags)
{
	struct sbus_softc *sc = t->_cookie;

	return (iommu_dvmamem_map(t0, &sc->sc_is, segs, nsegs, size,
	    kvap, flags));
}

void
sbus_dmamem_unmap(bus_dma_tag_t t, bus_dma_tag_t t0, caddr_t kva, size_t size)
{
	struct sbus_softc *sc = t->_cookie;

	iommu_dvmamem_unmap(t0, &sc->sc_is, kva, size);
}
@


1.16
log
@The existing IOMMU code had a rounding problem that was most noticeable
on faster systems under heavy network load.  This replaces some of the
unreadable iommu functions with something a little less dense and a lot
less crash prone.

The bus_dma function pointer/cookie handling was broken.  Change them
to work like the stacked bus_space drivers (where "work" is the key
word).

Tested my many (thanks).

ok jason@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sbus.c,v 1.15 2003/02/17 01:29:20 henric Exp $	*/
d61 1
a61 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.15
log
@
Add support for the Sun Enterprise 450
Reduce the size of a GENERIC kernel by ~190k
Remove the nasty pointer/bus_space_handle_t casts
Adds debug bus_space code including the ability to trace
    bus operations (it actually works now).

The following rules are now followed (and verfified by the debug
code):

1.  A "bus_space_handle_t" may only be used with the
    "bus_space_tag_t" that created it.
2.  Only "bus_space_map()" may create "bus_space_handle_t"s.
3.  A "bus_space_handle_t" may not be modified after it has
    been created (other than being destroyed by "bus_space_unmap()").


Thanks to help from mcbride, marc, jason, drahn, to anyone that might
have slipped my mind at the moment.

ok jason@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sbus.c,v 1.14 2002/03/14 20:26:20 jason Exp $	*/
d179 19
a197 13
int sbus_dmamap_load(bus_dma_tag_t, bus_dmamap_t, void *, bus_size_t,
    struct proc *, int);
void sbus_dmamap_unload(bus_dma_tag_t, bus_dmamap_t);
int sbus_dmamap_load_raw(bus_dma_tag_t, bus_dmamap_t, bus_dma_segment_t *,
    int, bus_size_t, int);
void sbus_dmamap_sync(bus_dma_tag_t, bus_dmamap_t, bus_addr_t, bus_size_t, int);
int sbus_dmamem_alloc(bus_dma_tag_t tag, bus_size_t size, bus_size_t alignment,
    bus_size_t boundary, bus_dma_segment_t *segs, int nsegs, int *rsegs,
    int flags);
void sbus_dmamem_free(bus_dma_tag_t tag, bus_dma_segment_t *segs, int nsegs);
int sbus_dmamem_map(bus_dma_tag_t tag, bus_dma_segment_t *segs, int nsegs,
    size_t size, caddr_t *kvap, int flags);
void sbus_dmamem_unmap(bus_dma_tag_t tag, caddr_t kva, size_t size);
d815 2
a816 3
#define PCOPY(x)	sdt->x = psdt->x
	PCOPY(_dmamap_create);
	PCOPY(_dmamap_destroy);
a817 2
	PCOPY(_dmamap_load_mbuf);
	PCOPY(_dmamap_load_uio);
a824 2
	PCOPY(_dmamem_mmap);
#undef	PCOPY
d830 3
a832 2
sbus_dmamap_load(bus_dma_tag_t tag, bus_dmamap_t map, void *buf,
    bus_size_t buflen, struct proc *p, int flags)
d834 1
a834 1
	struct sbus_softc *sc = tag->_cookie;
d836 17
a852 1
	return (iommu_dvmamap_load(tag, &sc->sc_is, map, buf, buflen,
d857 1
a857 1
sbus_dmamap_load_raw(bus_dma_tag_t tag, bus_dmamap_t map,
d860 1
a860 1
	struct sbus_softc *sc = tag->_cookie;
d862 1
a862 1
	return (iommu_dvmamap_load_raw(tag, &sc->sc_is, map, segs,
d867 1
a867 1
sbus_dmamap_unload(bus_dma_tag_t tag, bus_dmamap_t map)
d869 1
a869 1
	struct sbus_softc *sc = tag->_cookie;
d871 1
a871 1
	iommu_dvmamap_unload(tag, &sc->sc_is, map);
d875 2
a876 2
sbus_dmamap_sync(bus_dma_tag_t tag, bus_dmamap_t map, bus_addr_t offset,
    bus_size_t len, int ops)
d878 8
a885 1
	struct sbus_softc *sc = tag->_cookie;
d889 2
a890 2
		bus_dmamap_sync(tag->_parent, map, offset, len, ops);
		iommu_dvmamap_sync(tag, &sc->sc_is, map, offset, len, ops);
d894 2
a895 2
		iommu_dvmamap_sync(tag, &sc->sc_is, map, offset, len, ops);
		bus_dmamap_sync(tag->_parent, map, offset, len, ops);
d900 3
a902 3
sbus_dmamem_alloc(bus_dma_tag_t tag, bus_size_t size, bus_size_t alignment,
    bus_size_t boundary, bus_dma_segment_t *segs, int nsegs, int *rsegs,
    int flags)
d904 1
a904 1
	struct sbus_softc *sc = tag->_cookie;
d906 1
a906 1
	return (iommu_dvmamem_alloc(tag, &sc->sc_is, size, alignment, boundary,
d911 2
a912 1
sbus_dmamem_free(bus_dma_tag_t tag, bus_dma_segment_t *segs, int nsegs)
d914 1
a914 1
	struct sbus_softc *sc = (struct sbus_softc *)tag->_cookie;
d916 1
a916 1
	iommu_dvmamem_free(tag, &sc->sc_is, segs, nsegs);
d920 2
a921 2
sbus_dmamem_map(bus_dma_tag_t tag, bus_dma_segment_t *segs, int nsegs,
    size_t size, caddr_t *kvap, int flags)
d923 1
a923 1
	struct sbus_softc *sc = tag->_cookie;
d925 1
a925 1
	return (iommu_dvmamem_map(tag, &sc->sc_is, segs, nsegs, size,
d930 1
a930 1
sbus_dmamem_unmap(bus_dma_tag_t tag, caddr_t kva, size_t size)
d932 1
a932 1
	struct sbus_softc *sc = (struct sbus_softc *)tag->_cookie;
d934 1
a934 1
	iommu_dvmamem_unmap(tag, &sc->sc_is, kva, size);
@


1.14
log
@Make the sbus ipl handling more like psycho.  Some devices (Aurora 210sj, eg)
use Sbus level 5 for interrupts which means spltty() is not blocked correctly
because the sbus interrupt handling uses the implied spl of the interrupt
instead of the level passed to it.
@
text
@d1 1
a1 1
/*	$OpenBSD: sbus.c,v 1.13 2002/03/14 03:16:00 millert Exp $	*/
d146 1
a146 3
			      struct sbus_intr **, int *, int);
int sbus_bus_mmap(bus_space_tag_t, bus_type_t, bus_addr_t,
			      int, bus_space_handle_t *);
d148 11
a158 15
static int _sbus_bus_map(
		bus_space_tag_t,
		bus_type_t,
		bus_addr_t,		/*offset*/
		bus_size_t,		/*size*/
		int,			/*flags*/
		vaddr_t,		/*preferred virtual address */
		bus_space_handle_t *);
static void *sbus_intr_establish(
		bus_space_tag_t,
		int,			/*Sbus interrupt level*/
		int,			/*`device class' priority*/
		int,			/*flags*/
		int (*)(void *),	/*handler*/
		void *);		/*handler arg*/
d179 2
a180 2
int sbus_dmamap_load(bus_dma_tag_t, bus_dmamap_t, void *,
			  bus_size_t, struct proc *, int);
d182 10
a191 14
int sbus_dmamap_load_raw(bus_dma_tag_t, bus_dmamap_t,
		    bus_dma_segment_t *, int, bus_size_t, int);
void sbus_dmamap_sync(bus_dma_tag_t, bus_dmamap_t, bus_addr_t,
			   bus_size_t, int);
int sbus_dmamem_alloc(bus_dma_tag_t tag, bus_size_t size,
			   bus_size_t alignment, bus_size_t boundary,
			   bus_dma_segment_t *segs, int nsegs, int *rsegs,
			   int flags);
void sbus_dmamem_free(bus_dma_tag_t tag, bus_dma_segment_t *segs,
			   int nsegs);
int sbus_dmamem_map(bus_dma_tag_t tag, bus_dma_segment_t *segs,
			 int nsegs, size_t size, caddr_t *kvap, int flags);
void sbus_dmamem_unmap(bus_dma_tag_t tag, caddr_t kva,
			    size_t size);
d224 1
a224 3
sbus_print(args, busname)
	void *args;
	const char *busname;
d244 1
a244 4
sbus_match(parent, vcf, aux)
	struct device *parent;
	void *vcf;
	void *aux;
d256 1
a256 4
sbus_attach(parent, self, aux)
	struct device *parent;
	struct device *self;
	void *aux;
d261 1
a264 1

d271 7
a277 2
	sc->sc_sysio = (struct sysioreg*)(u_long)ma->ma_address[0];	/* Use prom mapping for sysio. */
	sc->sc_ign = ma->ma_interrupts[0] & INTMAP_IGN;		/* Find interrupt group no */
d305 1
a305 1
	/* initailise the IOMMU */
d309 14
a322 3
	sc->sc_is.is_iommu = &sc->sc_sysio->sys_iommu;
	sc->sc_is.is_sb[0] = &sc->sc_sysio->sys_strbuf;
	sc->sc_is.is_sb[1] = NULL;
d337 2
a338 2
	ih->ih_map = &sc->sc_sysio->therm_int_map;
	ih->ih_clr = NULL; /* &sc->sc_sysio->therm_clr_int; */
d341 1
a341 1
	ih->ih_pil = (1<<ipl);
d355 2
a356 2
		    sc->sc_is.is_dvmabase, sc->sc_is.is_dvmabase + NBPG,
		    NBPG, NBPG, 0, 0, EX_NOWAIT|EX_BOUNDZERO,
d382 2
a383 6
sbus_setup_attach_args(sc, bustag, dmatag, node, sa)
	struct sbus_softc	*sc;
	bus_space_tag_t		bustag;
	bus_dma_tag_t		dmatag;
	int			node;
	struct sbus_attach_args	*sa;
a384 2
	/*struct	sbus_reg sbusreg;*/
	/*int	base;*/
d386 1
a386 1
	int n;
d431 1
a431 2
sbus_destroy_attach_args(sa)
	struct sbus_attach_args	*sa;
d450 2
a451 8
_sbus_bus_map(t, btype, offset, size, flags, vaddr, hp)
	bus_space_tag_t t;
	bus_type_t btype;
	bus_addr_t offset;
	bus_size_t size;
	int	flags;
	vaddr_t vaddr;
	bus_space_handle_t *hp;
d454 2
a455 1
	int64_t slot = btype;
d458 10
d476 3
a478 3
		paddr |= ((bus_addr_t)sc->sc_range[i].pspace<<32);
		DPRINTF(SDB_DVMA,
("\n_sbus_bus_map: mapping paddr slot %lx offset %lx poffset %lx paddr %lx\n",
d481 2
a482 2
		return (bus_space_map2(sc->sc_bustag, 0, paddr,
					size, flags, vaddr, hp));
a487 28
int
sbus_bus_mmap(t, btype, paddr, flags, hp)
	bus_space_tag_t t;
	bus_type_t btype;
	bus_addr_t paddr;
	int flags;
	bus_space_handle_t *hp;
{
	bus_addr_t offset = paddr;
	int slot = btype;
	struct sbus_softc *sc = t->cookie;
	int i;

	for (i = 0; i < sc->sc_nrange; i++) {
		bus_addr_t paddr;

		if (sc->sc_range[i].cspace != slot)
			continue;

		paddr = sc->sc_range[i].poffset + offset;
		paddr |= ((bus_addr_t)sc->sc_range[i].pspace<<32);
		*hp = bus_space_mmap(sc->sc_bustag, paddr, 0,
		    VM_PROT_READ|VM_PROT_WRITE, flags);
	}

	return (*hp == -1 ? -1 : 0);
}

d489 1
a489 4
sbus_bus_addr(t, btype, offset)
	bus_space_tag_t t;
	u_int btype;
	u_int offset;
d491 1
a491 1
	bus_addr_t baddr;
d501 1
a501 1
		baddr |= ((bus_addr_t)sc->sc_range[i].pspace<<32);
d513 1
a513 3
sbus_establish(sd, dev)
	register struct sbusdev *sd;
	register struct device *dev;
d515 2
a516 2
	register struct sbus_softc *sc;
	register struct device *curdev;
d545 1
a545 2
sbusreset(sbus)
	int sbus;
d547 1
a547 1
	register struct sbusdev *sd;
d572 1
a572 2
sbus_overtemp(arg)
	void *arg;
d586 2
a587 6
sbus_get_intr(sc, node, ipp, np, slot)
	struct sbus_softc *sc;
	int node;
	struct sbus_intr **ipp;
	int *np;
	int slot;
d641 1
a641 1
			ip[n].sbi_pri = pri|ipl[n];
d656 2
a657 7
sbus_intr_establish(t, pri, level, flags, handler, arg)
	bus_space_tag_t t;
	int pri;
	int level;
	int flags;
	int (*handler)(void *);
	void *arg;
d660 1
d665 2
d692 1
a692 1

d695 2
a696 2
			ih->ih_map = &(&sc->sc_sysio->sbus_slot0_int)[slot];
			ih->ih_clr = &sc->sc_sysio->sbus0_clr_int[vec];
d711 10
a720 2
			bus_space_write_8(sc->sc_bustag,
			    (bus_space_handle_t)(u_long)ih->ih_map, 0, vec);
d722 2
a723 1
			int64_t *intrptr = &sc->sc_sysio->scsi_int_map;
d730 1
a730 1
			    (int64_t *)&sc->sc_sysio->reserved_int_map &&
d739 1
a739 1
				intrptr = (int64_t *)&sc->sc_sysio->scsi_clr_int;
d743 12
a754 2
				bus_space_write_8(sc->sc_bustag,
				    (bus_space_handle_t)(u_long)ih->ih_map, 0,
d773 1
a773 2
sbus_alloc_bustag(sc)
	struct sbus_softc *sc;
d775 1
a775 1
	bus_space_tag_t sbt;
d777 1
a777 2
	sbt = (bus_space_tag_t)
		malloc(sizeof(struct sparc_bus_space_tag), M_DEVBUF, M_NOWAIT);
d782 2
d786 3
a788 1
	sbt->type = SBUS_BUS_SPACE;
d797 1
a797 2
sbus_alloc_dmatag(sc)
	struct sbus_softc *sc;
d829 2
a830 7
sbus_dmamap_load(tag, map, buf, buflen, p, flags)
	bus_dma_tag_t tag;
	bus_dmamap_t map;
	void *buf;
	bus_size_t buflen;
	struct proc *p;
	int flags;
d832 1
a832 1
	struct sbus_softc *sc = (struct sbus_softc *)tag->_cookie;
d834 2
a835 1
	return (iommu_dvmamap_load(tag, &sc->sc_is, map, buf, buflen, p, flags));
d839 2
a840 7
sbus_dmamap_load_raw(tag, map, segs, nsegs, size, flags)
	bus_dma_tag_t tag;
	bus_dmamap_t map;
	bus_dma_segment_t *segs;
	int nsegs;
	bus_size_t size;
	int flags;
d842 1
a842 1
	struct sbus_softc *sc = (struct sbus_softc *)tag->_cookie;
d844 2
a845 1
	return (iommu_dvmamap_load_raw(tag, &sc->sc_is, map, segs, nsegs, flags, size));
d849 1
a849 3
sbus_dmamap_unload(tag, map)
	bus_dma_tag_t tag;
	bus_dmamap_t map;
d851 1
a851 1
	struct sbus_softc *sc = (struct sbus_softc *)tag->_cookie;
d857 2
a858 6
sbus_dmamap_sync(tag, map, offset, len, ops)
	bus_dma_tag_t tag;
	bus_dmamap_t map;
	bus_addr_t offset;
	bus_size_t len;
	int ops;
d860 1
a860 1
	struct sbus_softc *sc = (struct sbus_softc *)tag->_cookie;
d862 1
a862 1
	if (ops & (BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE)) {
d867 1
a867 1
	if (ops & (BUS_DMASYNC_POSTREAD|BUS_DMASYNC_POSTWRITE)) {
d875 3
a877 9
sbus_dmamem_alloc(tag, size, alignment, boundary, segs, nsegs, rsegs, flags)
	bus_dma_tag_t tag;
	bus_size_t size;
	bus_size_t alignment;
	bus_size_t boundary;
	bus_dma_segment_t *segs;
	int nsegs;
	int *rsegs;
	int flags;
d879 1
a879 1
	struct sbus_softc *sc = (struct sbus_softc *)tag->_cookie;
d886 1
a886 4
sbus_dmamem_free(tag, segs, nsegs)
	bus_dma_tag_t tag;
	bus_dma_segment_t *segs;
	int nsegs;
d894 2
a895 7
sbus_dmamem_map(tag, segs, nsegs, size, kvap, flags)
	bus_dma_tag_t tag;
	bus_dma_segment_t *segs;
	int nsegs;
	size_t size;
	caddr_t *kvap;
	int flags;
d897 1
a897 1
	struct sbus_softc *sc = (struct sbus_softc *)tag->_cookie;
d899 2
a900 1
	return (iommu_dvmamem_map(tag, &sc->sc_is, segs, nsegs, size, kvap, flags));
d904 1
a904 4
sbus_dmamem_unmap(tag, kva, size)
	bus_dma_tag_t tag;
	caddr_t kva;
	size_t size;
@


1.13
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: sbus.c,v 1.12 2002/03/14 01:26:44 millert Exp $	*/
d718 1
a718 1
		ipl = vec;
d720 1
a720 1
		ipl = vec & ~SBUS_INTR_COMPAT;
d723 7
a729 1
		ipl = INTLEV(vec);
d793 2
a794 2
	ih->ih_pil = (1<<ipl);
	intr_establish(ipl, ih);
@


1.12
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: sbus.c,v 1.11 2002/03/12 19:46:25 jason Exp $	*/
d158 1
a158 1
static void *sbus_intr_establish __P((
d164 1
a164 1
		void *));		/*handler arg*/
@


1.11
log
@sparc64's aren't likely to be CPU_ISSUN4C
@
text
@d1 1
a1 1
/*	$OpenBSD: sbus.c,v 1.10 2002/02/05 18:34:39 jason Exp $	*/
d141 1
a141 1
void sbusreset __P((int));
d143 8
a150 8
static bus_space_tag_t sbus_alloc_bustag __P((struct sbus_softc *));
static bus_dma_tag_t sbus_alloc_dmatag __P((struct sbus_softc *));
static int sbus_get_intr __P((struct sbus_softc *, int,
			      struct sbus_intr **, int *, int));
int sbus_bus_mmap __P((bus_space_tag_t, bus_type_t, bus_addr_t,
			      int, bus_space_handle_t *));
static int sbus_overtemp __P((void *));
static int _sbus_bus_map __P((
d157 1
a157 1
		bus_space_handle_t *));
d163 1
a163 1
		int (*) __P((void *)),	/*handler*/
d168 2
a169 2
int	sbus_match __P((struct device *, void *, void *));
void	sbus_attach __P((struct device *, struct device *, void *));
d185 8
a192 8
int sbus_dmamap_load __P((bus_dma_tag_t, bus_dmamap_t, void *,
			  bus_size_t, struct proc *, int));
void sbus_dmamap_unload __P((bus_dma_tag_t, bus_dmamap_t));
int sbus_dmamap_load_raw __P((bus_dma_tag_t, bus_dmamap_t,
		    bus_dma_segment_t *, int, bus_size_t, int));
void sbus_dmamap_sync __P((bus_dma_tag_t, bus_dmamap_t, bus_addr_t,
			   bus_size_t, int));
int sbus_dmamem_alloc __P((bus_dma_tag_t tag, bus_size_t size,
d195 7
a201 7
			   int flags));
void sbus_dmamem_free __P((bus_dma_tag_t tag, bus_dma_segment_t *segs,
			   int nsegs));
int sbus_dmamem_map __P((bus_dma_tag_t tag, bus_dma_segment_t *segs,
			 int nsegs, size_t size, caddr_t *kvap, int flags));
void sbus_dmamem_unmap __P((bus_dma_tag_t tag, caddr_t kva,
			    size_t size));
d704 1
a704 1
	int (*handler) __P((void *));
@


1.10
log
@Implement vgafb_mmap() fully
From NetBSD: change bus_space_mmap() prototype to standard one
@
text
@d1 1
a1 1
/*	$OpenBSD: sbus.c,v 1.9 2002/01/10 00:06:17 nordin Exp $	*/
d215 1
a215 4
static int intr_sbus2ipl_4c[] = {
	0, 1, 2, 3, 5, 7, 8, 9
};
static int intr_sbus2ipl_4m[] = {
d293 1
a293 3
	sc->sc_intr2ipl = CPU_ISSUN4C
				? intr_sbus2ipl_4c
				: intr_sbus2ipl_4m;
@


1.9
log
@Check result from malloc(9) when using M_NOWAIT. jason@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: sbus.c,v 1.8 2002/01/04 05:19:25 jason Exp $	*/
d126 2
d518 2
a519 1
		return (bus_space_mmap(sc->sc_bustag, 0, paddr, flags, hp));
d522 1
a522 1
		return (-1);
@


1.8
log
@expose sbus_bus_addr() so cgsix actually compiles (oops)
@
text
@d1 1
a1 1
/*	$OpenBSD: sbus.c,v 1.7 2001/10/15 03:36:16 jason Exp $	*/
d340 2
@


1.7
log
@Pull in several changes from NetBSD:
- Clear the dmamap inside splhigh() protection.
- Manage both streaming caches on psycho/psycho+.
And fix a botch I created when merging iommu changes last time.
@
text
@d1 1
a1 1
/*	$OpenBSD: sbus.c,v 1.6 2001/08/31 15:12:05 jason Exp $	*/
a146 1
bus_addr_t sbus_bus_addr __P((bus_space_tag_t, u_int, u_int));
@


1.7.6.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: sbus.c,v 1.9 2002/01/10 00:06:17 nordin Exp $	*/
d147 1
a340 2
	if (ih == NULL)
		panic("couldn't malloc intrhand");
@


1.7.6.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: sbus.c,v 1.7.6.1 2002/01/31 22:55:24 niklas Exp $	*/
a125 2
#include <uvm/uvm_extern.h>

d139 1
a139 1
void sbusreset(int);
d141 8
a148 8
static bus_space_tag_t sbus_alloc_bustag(struct sbus_softc *);
static bus_dma_tag_t sbus_alloc_dmatag(struct sbus_softc *);
static int sbus_get_intr(struct sbus_softc *, int,
			      struct sbus_intr **, int *, int);
int sbus_bus_mmap(bus_space_tag_t, bus_type_t, bus_addr_t,
			      int, bus_space_handle_t *);
static int sbus_overtemp(void *);
static int _sbus_bus_map(
d155 2
a156 2
		bus_space_handle_t *);
static void *sbus_intr_establish(
d161 2
a162 2
		int (*)(void *),	/*handler*/
		void *);		/*handler arg*/
d166 2
a167 2
int	sbus_match(struct device *, void *, void *);
void	sbus_attach(struct device *, struct device *, void *);
d183 8
a190 8
int sbus_dmamap_load(bus_dma_tag_t, bus_dmamap_t, void *,
			  bus_size_t, struct proc *, int);
void sbus_dmamap_unload(bus_dma_tag_t, bus_dmamap_t);
int sbus_dmamap_load_raw(bus_dma_tag_t, bus_dmamap_t,
		    bus_dma_segment_t *, int, bus_size_t, int);
void sbus_dmamap_sync(bus_dma_tag_t, bus_dmamap_t, bus_addr_t,
			   bus_size_t, int);
int sbus_dmamem_alloc(bus_dma_tag_t tag, bus_size_t size,
d193 7
a199 7
			   int flags);
void sbus_dmamem_free(bus_dma_tag_t tag, bus_dma_segment_t *segs,
			   int nsegs);
int sbus_dmamem_map(bus_dma_tag_t tag, bus_dma_segment_t *segs,
			 int nsegs, size_t size, caddr_t *kvap, int flags);
void sbus_dmamem_unmap(bus_dma_tag_t tag, caddr_t kva,
			    size_t size);
d213 4
a216 1
static int intr_sbus2ipl_4u[] = {
d294 3
a296 1
	sc->sc_intr2ipl = intr_sbus2ipl_4u;
d516 1
a516 2
		*hp = bus_space_mmap(sc->sc_bustag, paddr, 0,
		    VM_PROT_READ|VM_PROT_WRITE, flags);
d519 1
a519 1
	return (*hp == -1 ? -1 : 0);
d706 1
a706 1
	int (*handler)(void *);
d720 1
a720 1
		ipl = 1 << vec;
d722 1
a722 1
		ipl = 1 << (vec & ~SBUS_INTR_COMPAT);
d725 1
a725 7
		ipl = level;
		if (ipl == IPL_NONE)
			ipl = 1 << INTLEV(vec);
		if (ipl == IPL_NONE) {
			printf("ERROR: no IPL, setting IPL 2.\n");
			ipl = 2;
		}
d789 2
a790 2
	ih->ih_pil = ipl;
	intr_establish(ih->ih_pil, ih);
@


1.7.6.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d146 3
a148 1
    struct sbus_intr **, int *, int);
d150 15
a164 11
static int _sbus_bus_map(bus_space_tag_t, bus_space_tag_t,
    bus_addr_t,		/*offset*/
    bus_size_t,		/*size*/
    int,		/*flags*/
    bus_space_handle_t *);
static void *sbus_intr_establish(bus_space_tag_t, bus_space_tag_t,
    int,		/*Sbus interrupt level*/
    int,		/*`device class' priority*/
    int,		/*flags*/
    int (*)(void *),	/*handler*/
    void *);		/*handler arg*/
d185 17
a201 19
int sbus_dmamap_create(bus_dma_tag_t, bus_dma_tag_t, bus_size_t, int,
    bus_size_t, bus_size_t, int, bus_dmamap_t *);
void sbus_dmamap_destroy(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t);
int sbus_dmamap_load(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t, void *,
    bus_size_t, struct proc *, int);
void sbus_dmamap_unload(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t);
int sbus_dmamap_load_raw(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t,
    bus_dma_segment_t *, int, bus_size_t, int);
void sbus_dmamap_sync(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t, bus_addr_t,
    bus_size_t, int);
int sbus_dmamem_alloc(bus_dma_tag_t, bus_dma_tag_t tag, bus_size_t size,
    bus_size_t alignment, bus_size_t boundary, bus_dma_segment_t *segs,
    int nsegs, int *rsegs, int flags);
void sbus_dmamem_free(bus_dma_tag_t, bus_dma_tag_t tag,
    bus_dma_segment_t *segs, int nsegs);
int sbus_dmamem_map(bus_dma_tag_t, bus_dma_tag_t tag, bus_dma_segment_t *segs,
    int nsegs, size_t size, caddr_t *kvap, int flags);
void sbus_dmamem_unmap(bus_dma_tag_t, bus_dma_tag_t tag, caddr_t kva,
    size_t size);
d234 3
a236 1
sbus_print(void *args, const char *busname)
d256 4
a259 1
sbus_match(struct device *parent, void *vcf, void *aux)
d271 4
a274 1
sbus_attach(struct device *parent, struct device *self, void *aux)
a278 1
	struct sysioreg *sysio;
d282 1
d289 2
a290 7
	/* Find interrupt group no */
	sc->sc_ign = ma->ma_interrupts[0] & INTMAP_IGN;

	bus_space_map(sc->sc_bustag,
	    ma->ma_address[0], sizeof(struct sysioreg),
	    BUS_SPACE_MAP_PROMADDRESS, &sc->sc_bh);
	sysio = bus_space_vaddr(sc->sc_bustag, sc->sc_bh);
d318 1
a318 1
	/* initialize the IOMMU */
d322 3
a324 14
	bus_space_subregion(sc->sc_bustag, sc->sc_bh,
	    offsetof(struct sysioreg, sys_iommu),
	    sizeof(struct iommureg), &sc->sc_is.is_iommu);

	/* initialize our strbuf_ctl */
	sc->sc_is.is_sb[0] = &sc->sc_sb;
	if (bus_space_subregion(sc->sc_bustag, sc->sc_bh,
	    offsetof(struct sysioreg, sys_strbuf),
	    sizeof(struct iommu_strbuf), &sc->sc_sb.sb_sb) == 0) {
		/* point sb_flush to our flush buffer */
		sc->sc_sb.sb_flush = &sc->sc_flush;
		sc->sc_sb.sb_bustag = sc->sc_bustag;
	} else
		sc->sc_is.is_sb[0] = NULL;
d339 2
a340 2
	ih->ih_map = &sysio->therm_int_map;
	ih->ih_clr = NULL; /* &sysio->therm_clr_int; */
d343 1
a343 1
	ih->ih_pil = (1 << ipl);
d357 2
a358 2
		    sc->sc_is.is_dvmabase, sc->sc_is.is_dvmabase + NBPG, NBPG,
		    NBPG, 0, 0, EX_NOWAIT | EX_BOUNDZERO,
d384 6
a389 2
sbus_setup_attach_args(struct sbus_softc *sc, bus_space_tag_t bustag,
    bus_dma_tag_t dmatag, int node, struct sbus_attach_args *sa)
d391 2
d394 1
a394 1
	int	n;
d439 2
a440 1
sbus_destroy_attach_args(struct sbus_attach_args *sa)
d459 8
a466 2
_sbus_bus_map(bus_space_tag_t t, bus_space_tag_t t0, bus_addr_t addr,
    bus_size_t size, int flags, bus_space_handle_t *hp)
d469 1
a469 2
	int64_t slot = BUS_ADDR_IOSPACE(addr);
	int64_t offset = BUS_ADDR_PADDR(addr);
a471 10
	if (t->parent == NULL || t->parent->sparc_bus_map == NULL) {
		printf("\n_psycho_bus_map: invalid parent");
		return (EINVAL);
	}

	if (flags & BUS_SPACE_MAP_PROMADDRESS) {
		return ((*t->parent->sparc_bus_map)(t, t0, addr,
					size, flags, hp));
	}

d480 3
a482 3
		paddr |= ((bus_addr_t)sc->sc_range[i].pspace << 32);
		DPRINTF(SDB_DVMA, ("_sbus_bus_map: mapping paddr "
			"slot %lx offset %lx poffset %lx paddr %lx\n",
d485 2
a486 2
		return ((*t->parent->sparc_bus_map)(t, t0, paddr,
					size, flags, hp));
d492 28
d521 4
a524 1
sbus_bus_addr(bus_space_tag_t t, u_int btype, u_int offset)
d526 1
a526 1
	bus_addr_t baddr = ~(bus_addr_t)0;
d536 1
a536 1
		baddr |= (bus_addr_t)sc->sc_range[i].pspace << 32;
d548 3
a550 1
sbus_establish(struct sbusdev *sd, struct device *dev)
d552 2
a553 2
	struct sbus_softc *sc;
	struct device *curdev;
d582 2
a583 1
sbusreset(int sbus)
d585 1
a585 1
	struct sbusdev *sd;
d610 2
a611 1
sbus_overtemp(void *arg)
d625 6
a630 2
sbus_get_intr(struct sbus_softc *sc, int node, struct sbus_intr **ipp, int *np,
    int slot)
d684 1
a684 1
			ip[n].sbi_pri = pri | ipl[n];
d699 7
a705 2
sbus_intr_establish(bus_space_tag_t t, bus_space_tag_t t0, int pri, int level,
    int flags, int (*handler)(void *), void *arg)
a707 1
	struct sysioreg *sysio;
a711 2
	sysio = bus_space_vaddr(sc->sc_bustag, sc->sc_bh);

d737 1
a737 1
			bus_space_handle_t maph;
d740 2
a741 2
			ih->ih_map = &(&sysio->sbus_slot0_int)[slot];
			ih->ih_clr = &sysio->sbus0_clr_int[vec];
d756 2
a757 10
			/*
			 * This would be cleaner if the underlying interrupt
			 * infrastructure took a bus tag/handle pair.  Even
			 * if not, the following could be done with a write
			 * to the appropriate offset from sc->sc_bustag and
			 * sc->sc_bh.
			 */
			bus_space_map(sc->sc_bustag, (bus_addr_t)ih->ih_map, 8,
			    BUS_SPACE_MAP_PROMADDRESS, &maph);
			bus_space_write_8(sc->sc_bustag, maph, 0, vec);
d759 1
a759 2
			bus_space_handle_t maph;
			volatile int64_t *intrptr = &sysio->scsi_int_map;
d766 1
a766 1
			    (int64_t *)&sysio->reserved_int_map &&
d775 1
a775 1
				intrptr = (int64_t *)&sysio->scsi_clr_int;
d779 2
a780 12
				/*
				 * This would be cleaner if the underlying
				 * interrupt infrastructure took a bus tag/
				 * handle pair.  Even if not, the following
				 * could be done with a write to the
				 * appropriate offset from sc->sc_bustag and
				 * sc->sc_bh.
				 */
				bus_space_map(sc->sc_bustag,
				    (bus_addr_t)ih->ih_map, 8,
				    BUS_SPACE_MAP_PROMADDRESS, &maph);
				bus_space_write_8(sc->sc_bustag, maph, 0,
d799 2
a800 1
sbus_alloc_bustag(struct sbus_softc *sc)
d802 1
a802 1
	struct sparc_bus_space_tag *sbt;
d804 2
a805 1
	sbt = malloc(sizeof(*sbt), M_DEVBUF, M_NOWAIT);
a809 2
	snprintf(sbt->name, sizeof(sbt->name), "%s",
		sc->sc_dev.dv_xname);
d812 1
a812 3
	sbt->default_type = SBUS_BUS_SPACE;
	sbt->asi = ASI_PRIMARY;
	sbt->sasi = ASI_PRIMARY;
d821 2
a822 1
sbus_alloc_dmatag(struct sbus_softc *sc)
d834 3
a836 2
	sdt->_dmamap_create = sbus_dmamap_create;
	sdt->_dmamap_destroy = sbus_dmamap_destroy;
d838 2
d847 2
d854 7
a860 3
sbus_dmamap_create(bus_dma_tag_t t, bus_dma_tag_t t0, bus_size_t size,
    int nsegments, bus_size_t maxsegsz, bus_size_t boundary, int flags,
    bus_dmamap_t *dmamp)
d862 1
a862 1
	struct sbus_softc *sc = t->_cookie;
d864 1
a864 18
        return (iommu_dvmamap_create(t0, &sc->sc_is, &sc->sc_sb, size,
            nsegments, maxsegsz, boundary, flags, dmamp));
}

void
sbus_dmamap_destroy(bus_dma_tag_t t, bus_dma_tag_t t0, bus_dmamap_t map)
{
	iommu_dvmamap_destroy(t0, map);
}

int
sbus_dmamap_load(bus_dma_tag_t t, bus_dma_tag_t t0, bus_dmamap_t map,
    void *buf, bus_size_t buflen, struct proc *p, int flags)
{
	struct sbus_softc *sc = t->_cookie;

	return (iommu_dvmamap_load(t0, &sc->sc_is, map, buf, buflen,
	    p, flags));
d868 7
a874 2
sbus_dmamap_load_raw(bus_dma_tag_t t, bus_dma_tag_t t0, bus_dmamap_t map,
    bus_dma_segment_t *segs, int nsegs, bus_size_t size, int flags)
d876 1
a876 1
	struct sbus_softc *sc = t->_cookie;
d878 1
a878 2
	return (iommu_dvmamap_load_raw(t0, &sc->sc_is, map, segs,
	    nsegs, flags, size));
d882 3
a884 1
sbus_dmamap_unload(bus_dma_tag_t t, bus_dma_tag_t t0, bus_dmamap_t map)
d886 1
a886 1
	struct sbus_softc *sc = t->_cookie;
d888 1
a888 1
	iommu_dvmamap_unload(t0, &sc->sc_is, map);
d892 6
a897 2
sbus_dmamap_sync(bus_dma_tag_t t, bus_dma_tag_t t0, bus_dmamap_t map,
    bus_addr_t offset, bus_size_t len, int ops)
d899 1
a899 8
	struct sbus_softc *sc = t->_cookie;

	if (t->_parent == NULL)
		panic("sbus_dmamap_sync: no parent");

	for (t = t->_parent; t->_dmamap_sync == NULL; t = t->_parent)
		if (t == NULL)
			panic("sbus_dmamap_sync: can't find implementation");
d901 1
a901 1
	if (ops & (BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE)) {
d903 2
a904 2
		(*t->_dmamap_sync)(t, t0, map, offset, len, ops);
		iommu_dvmamap_sync(t0, &sc->sc_is, map, offset, len, ops);
d906 1
a906 1
	if (ops & (BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE)) {
d908 2
a909 2
		iommu_dvmamap_sync(t0, &sc->sc_is, map, offset, len, ops);
		(*t->_dmamap_sync)(t, t0, map, offset, len, ops);
d914 9
a922 3
sbus_dmamem_alloc(bus_dma_tag_t t, bus_dma_tag_t t0, bus_size_t size,
    bus_size_t alignment, bus_size_t boundary, bus_dma_segment_t *segs,
    int nsegs, int *rsegs, int flags)
d924 1
a924 1
	struct sbus_softc *sc = t->_cookie;
d926 1
a926 1
	return (iommu_dvmamem_alloc(t0, &sc->sc_is, size, alignment, boundary,
d931 4
a934 2
sbus_dmamem_free(bus_dma_tag_t t, bus_dma_tag_t t0, bus_dma_segment_t *segs,
    int nsegs)
d936 1
a936 1
	struct sbus_softc *sc = t->_cookie;
d938 1
a938 1
	iommu_dvmamem_free(t0, &sc->sc_is, segs, nsegs);
d942 7
a948 2
sbus_dmamem_map(bus_dma_tag_t t, bus_dma_tag_t t0, bus_dma_segment_t *segs,
    int nsegs, size_t size, caddr_t *kvap, int flags)
d950 1
a950 1
	struct sbus_softc *sc = t->_cookie;
d952 1
a952 2
	return (iommu_dvmamem_map(t0, &sc->sc_is, segs, nsegs, size,
	    kvap, flags));
d956 4
a959 1
sbus_dmamem_unmap(bus_dma_tag_t t, bus_dma_tag_t t0, caddr_t kva, size_t size)
d961 1
a961 1
	struct sbus_softc *sc = t->_cookie;
d963 1
a963 1
	iommu_dvmamem_unmap(t0, &sc->sc_is, kva, size);
@


1.7.4.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.7.4.2
log
@Merge in trunk
@
text
@a125 2
#include <uvm/uvm_extern.h>

d147 1
a340 2
	if (ih == NULL)
		panic("couldn't malloc intrhand");
d515 1
a515 2
		*hp = bus_space_mmap(sc->sc_bustag, paddr, 0,
		    VM_PROT_READ|VM_PROT_WRITE, flags);
d518 1
a518 1
	return (*hp == -1 ? -1 : 0);
@


1.7.4.3
log
@Merge in -current from about a week ago
@
text
@d141 1
a141 1
void sbusreset(int);
d143 8
a150 8
static bus_space_tag_t sbus_alloc_bustag(struct sbus_softc *);
static bus_dma_tag_t sbus_alloc_dmatag(struct sbus_softc *);
static int sbus_get_intr(struct sbus_softc *, int,
			      struct sbus_intr **, int *, int);
int sbus_bus_mmap(bus_space_tag_t, bus_type_t, bus_addr_t,
			      int, bus_space_handle_t *);
static int sbus_overtemp(void *);
static int _sbus_bus_map(
d157 2
a158 2
		bus_space_handle_t *);
static void *sbus_intr_establish(
d163 2
a164 2
		int (*)(void *),	/*handler*/
		void *);		/*handler arg*/
d168 2
a169 2
int	sbus_match(struct device *, void *, void *);
void	sbus_attach(struct device *, struct device *, void *);
d185 8
a192 8
int sbus_dmamap_load(bus_dma_tag_t, bus_dmamap_t, void *,
			  bus_size_t, struct proc *, int);
void sbus_dmamap_unload(bus_dma_tag_t, bus_dmamap_t);
int sbus_dmamap_load_raw(bus_dma_tag_t, bus_dmamap_t,
		    bus_dma_segment_t *, int, bus_size_t, int);
void sbus_dmamap_sync(bus_dma_tag_t, bus_dmamap_t, bus_addr_t,
			   bus_size_t, int);
int sbus_dmamem_alloc(bus_dma_tag_t tag, bus_size_t size,
d195 7
a201 7
			   int flags);
void sbus_dmamem_free(bus_dma_tag_t tag, bus_dma_segment_t *segs,
			   int nsegs);
int sbus_dmamem_map(bus_dma_tag_t tag, bus_dma_segment_t *segs,
			 int nsegs, size_t size, caddr_t *kvap, int flags);
void sbus_dmamem_unmap(bus_dma_tag_t tag, caddr_t kva,
			    size_t size);
d215 4
a218 1
static int intr_sbus2ipl_4u[] = {
d296 3
a298 1
	sc->sc_intr2ipl = intr_sbus2ipl_4u;
d709 1
a709 1
	int (*handler)(void *);
d723 1
a723 1
		ipl = 1 << vec;
d725 1
a725 1
		ipl = 1 << (vec & ~SBUS_INTR_COMPAT);
d728 1
a728 7
		ipl = level;
		if (ipl == IPL_NONE)
			ipl = 1 << INTLEV(vec);
		if (ipl == IPL_NONE) {
			printf("ERROR: no IPL, setting IPL 2.\n");
			ipl = 2;
		}
d792 2
a793 2
	ih->ih_pil = ipl;
	intr_establish(ih->ih_pil, ih);
@


1.7.4.4
log
@Sync the SMP branch with 3.3
@
text
@d146 3
a148 1
    struct sbus_intr **, int *, int);
d150 15
a164 11
static int _sbus_bus_map(bus_space_tag_t, bus_space_tag_t,
    bus_addr_t,		/*offset*/
    bus_size_t,		/*size*/
    int,		/*flags*/
    bus_space_handle_t *);
static void *sbus_intr_establish(bus_space_tag_t, bus_space_tag_t,
    int,		/*Sbus interrupt level*/
    int,		/*`device class' priority*/
    int,		/*flags*/
    int (*)(void *),	/*handler*/
    void *);		/*handler arg*/
d185 17
a201 19
int sbus_dmamap_create(bus_dma_tag_t, bus_dma_tag_t, bus_size_t, int,
    bus_size_t, bus_size_t, int, bus_dmamap_t *);
void sbus_dmamap_destroy(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t);
int sbus_dmamap_load(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t, void *,
    bus_size_t, struct proc *, int);
void sbus_dmamap_unload(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t);
int sbus_dmamap_load_raw(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t,
    bus_dma_segment_t *, int, bus_size_t, int);
void sbus_dmamap_sync(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t, bus_addr_t,
    bus_size_t, int);
int sbus_dmamem_alloc(bus_dma_tag_t, bus_dma_tag_t tag, bus_size_t size,
    bus_size_t alignment, bus_size_t boundary, bus_dma_segment_t *segs,
    int nsegs, int *rsegs, int flags);
void sbus_dmamem_free(bus_dma_tag_t, bus_dma_tag_t tag,
    bus_dma_segment_t *segs, int nsegs);
int sbus_dmamem_map(bus_dma_tag_t, bus_dma_tag_t tag, bus_dma_segment_t *segs,
    int nsegs, size_t size, caddr_t *kvap, int flags);
void sbus_dmamem_unmap(bus_dma_tag_t, bus_dma_tag_t tag, caddr_t kva,
    size_t size);
d234 3
a236 1
sbus_print(void *args, const char *busname)
d256 4
a259 1
sbus_match(struct device *parent, void *vcf, void *aux)
d271 4
a274 1
sbus_attach(struct device *parent, struct device *self, void *aux)
a278 1
	struct sysioreg *sysio;
d282 1
d289 2
a290 7
	/* Find interrupt group no */
	sc->sc_ign = ma->ma_interrupts[0] & INTMAP_IGN;

	bus_space_map(sc->sc_bustag,
	    ma->ma_address[0], sizeof(struct sysioreg),
	    BUS_SPACE_MAP_PROMADDRESS, &sc->sc_bh);
	sysio = bus_space_vaddr(sc->sc_bustag, sc->sc_bh);
d318 1
a318 1
	/* initialize the IOMMU */
d322 3
a324 14
	bus_space_subregion(sc->sc_bustag, sc->sc_bh,
	    offsetof(struct sysioreg, sys_iommu),
	    sizeof(struct iommureg), &sc->sc_is.is_iommu);

	/* initialize our strbuf_ctl */
	sc->sc_is.is_sb[0] = &sc->sc_sb;
	if (bus_space_subregion(sc->sc_bustag, sc->sc_bh,
	    offsetof(struct sysioreg, sys_strbuf),
	    sizeof(struct iommu_strbuf), &sc->sc_sb.sb_sb) == 0) {
		/* point sb_flush to our flush buffer */
		sc->sc_sb.sb_flush = &sc->sc_flush;
		sc->sc_sb.sb_bustag = sc->sc_bustag;
	} else
		sc->sc_is.is_sb[0] = NULL;
d339 2
a340 2
	ih->ih_map = &sysio->therm_int_map;
	ih->ih_clr = NULL; /* &sysio->therm_clr_int; */
d343 1
a343 1
	ih->ih_pil = (1 << ipl);
d357 2
a358 2
		    sc->sc_is.is_dvmabase, sc->sc_is.is_dvmabase + NBPG, NBPG,
		    NBPG, 0, 0, EX_NOWAIT | EX_BOUNDZERO,
d384 6
a389 2
sbus_setup_attach_args(struct sbus_softc *sc, bus_space_tag_t bustag,
    bus_dma_tag_t dmatag, int node, struct sbus_attach_args *sa)
d391 2
d394 1
a394 1
	int	n;
d439 2
a440 1
sbus_destroy_attach_args(struct sbus_attach_args *sa)
d459 8
a466 2
_sbus_bus_map(bus_space_tag_t t, bus_space_tag_t t0, bus_addr_t addr,
    bus_size_t size, int flags, bus_space_handle_t *hp)
d469 1
a469 2
	int64_t slot = BUS_ADDR_IOSPACE(addr);
	int64_t offset = BUS_ADDR_PADDR(addr);
a471 10
	if (t->parent == NULL || t->parent->sparc_bus_map == NULL) {
		printf("\n_psycho_bus_map: invalid parent");
		return (EINVAL);
	}

	if (flags & BUS_SPACE_MAP_PROMADDRESS) {
		return ((*t->parent->sparc_bus_map)(t, t0, addr,
					size, flags, hp));
	}

d480 3
a482 3
		paddr |= ((bus_addr_t)sc->sc_range[i].pspace << 32);
		DPRINTF(SDB_DVMA, ("_sbus_bus_map: mapping paddr "
			"slot %lx offset %lx poffset %lx paddr %lx\n",
d485 2
a486 2
		return ((*t->parent->sparc_bus_map)(t, t0, paddr,
					size, flags, hp));
d492 28
d521 4
a524 1
sbus_bus_addr(bus_space_tag_t t, u_int btype, u_int offset)
d526 1
a526 1
	bus_addr_t baddr = ~(bus_addr_t)0;
d536 1
a536 1
		baddr |= (bus_addr_t)sc->sc_range[i].pspace << 32;
d548 3
a550 1
sbus_establish(struct sbusdev *sd, struct device *dev)
d552 2
a553 2
	struct sbus_softc *sc;
	struct device *curdev;
d582 2
a583 1
sbusreset(int sbus)
d585 1
a585 1
	struct sbusdev *sd;
d610 2
a611 1
sbus_overtemp(void *arg)
d625 6
a630 2
sbus_get_intr(struct sbus_softc *sc, int node, struct sbus_intr **ipp, int *np,
    int slot)
d684 1
a684 1
			ip[n].sbi_pri = pri | ipl[n];
d699 7
a705 2
sbus_intr_establish(bus_space_tag_t t, bus_space_tag_t t0, int pri, int level,
    int flags, int (*handler)(void *), void *arg)
a707 1
	struct sysioreg *sysio;
a711 2
	sysio = bus_space_vaddr(sc->sc_bustag, sc->sc_bh);

d737 1
a737 1
			bus_space_handle_t maph;
d740 2
a741 2
			ih->ih_map = &(&sysio->sbus_slot0_int)[slot];
			ih->ih_clr = &sysio->sbus0_clr_int[vec];
d756 2
a757 10
			/*
			 * This would be cleaner if the underlying interrupt
			 * infrastructure took a bus tag/handle pair.  Even
			 * if not, the following could be done with a write
			 * to the appropriate offset from sc->sc_bustag and
			 * sc->sc_bh.
			 */
			bus_space_map(sc->sc_bustag, (bus_addr_t)ih->ih_map, 8,
			    BUS_SPACE_MAP_PROMADDRESS, &maph);
			bus_space_write_8(sc->sc_bustag, maph, 0, vec);
d759 1
a759 2
			bus_space_handle_t maph;
			volatile int64_t *intrptr = &sysio->scsi_int_map;
d766 1
a766 1
			    (int64_t *)&sysio->reserved_int_map &&
d775 1
a775 1
				intrptr = (int64_t *)&sysio->scsi_clr_int;
d779 2
a780 12
				/*
				 * This would be cleaner if the underlying
				 * interrupt infrastructure took a bus tag/
				 * handle pair.  Even if not, the following
				 * could be done with a write to the
				 * appropriate offset from sc->sc_bustag and
				 * sc->sc_bh.
				 */
				bus_space_map(sc->sc_bustag,
				    (bus_addr_t)ih->ih_map, 8,
				    BUS_SPACE_MAP_PROMADDRESS, &maph);
				bus_space_write_8(sc->sc_bustag, maph, 0,
d799 2
a800 1
sbus_alloc_bustag(struct sbus_softc *sc)
d802 1
a802 1
	struct sparc_bus_space_tag *sbt;
d804 2
a805 1
	sbt = malloc(sizeof(*sbt), M_DEVBUF, M_NOWAIT);
a809 2
	snprintf(sbt->name, sizeof(sbt->name), "%s",
		sc->sc_dev.dv_xname);
d812 1
a812 3
	sbt->default_type = SBUS_BUS_SPACE;
	sbt->asi = ASI_PRIMARY;
	sbt->sasi = ASI_PRIMARY;
d821 2
a822 1
sbus_alloc_dmatag(struct sbus_softc *sc)
d834 3
a836 2
	sdt->_dmamap_create = sbus_dmamap_create;
	sdt->_dmamap_destroy = sbus_dmamap_destroy;
d838 2
d847 2
d854 7
a860 3
sbus_dmamap_create(bus_dma_tag_t t, bus_dma_tag_t t0, bus_size_t size,
    int nsegments, bus_size_t maxsegsz, bus_size_t boundary, int flags,
    bus_dmamap_t *dmamp)
d862 1
a862 1
	struct sbus_softc *sc = t->_cookie;
d864 1
a864 18
        return (iommu_dvmamap_create(t0, &sc->sc_is, &sc->sc_sb, size,
            nsegments, maxsegsz, boundary, flags, dmamp));
}

void
sbus_dmamap_destroy(bus_dma_tag_t t, bus_dma_tag_t t0, bus_dmamap_t map)
{
	iommu_dvmamap_destroy(t0, map);
}

int
sbus_dmamap_load(bus_dma_tag_t t, bus_dma_tag_t t0, bus_dmamap_t map,
    void *buf, bus_size_t buflen, struct proc *p, int flags)
{
	struct sbus_softc *sc = t->_cookie;

	return (iommu_dvmamap_load(t0, &sc->sc_is, map, buf, buflen,
	    p, flags));
d868 7
a874 2
sbus_dmamap_load_raw(bus_dma_tag_t t, bus_dma_tag_t t0, bus_dmamap_t map,
    bus_dma_segment_t *segs, int nsegs, bus_size_t size, int flags)
d876 1
a876 1
	struct sbus_softc *sc = t->_cookie;
d878 1
a878 2
	return (iommu_dvmamap_load_raw(t0, &sc->sc_is, map, segs,
	    nsegs, flags, size));
d882 3
a884 1
sbus_dmamap_unload(bus_dma_tag_t t, bus_dma_tag_t t0, bus_dmamap_t map)
d886 1
a886 1
	struct sbus_softc *sc = t->_cookie;
d888 1
a888 1
	iommu_dvmamap_unload(t0, &sc->sc_is, map);
d892 6
a897 2
sbus_dmamap_sync(bus_dma_tag_t t, bus_dma_tag_t t0, bus_dmamap_t map,
    bus_addr_t offset, bus_size_t len, int ops)
d899 1
a899 8
	struct sbus_softc *sc = t->_cookie;

	if (t->_parent == NULL)
		panic("sbus_dmamap_sync: no parent");

	for (t = t->_parent; t->_dmamap_sync == NULL; t = t->_parent)
		if (t == NULL)
			panic("sbus_dmamap_sync: can't find implementation");
d901 1
a901 1
	if (ops & (BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE)) {
d903 2
a904 2
		(*t->_dmamap_sync)(t, t0, map, offset, len, ops);
		iommu_dvmamap_sync(t0, &sc->sc_is, map, offset, len, ops);
d906 1
a906 1
	if (ops & (BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE)) {
d908 2
a909 2
		iommu_dvmamap_sync(t0, &sc->sc_is, map, offset, len, ops);
		(*t->_dmamap_sync)(t, t0, map, offset, len, ops);
d914 9
a922 3
sbus_dmamem_alloc(bus_dma_tag_t t, bus_dma_tag_t t0, bus_size_t size,
    bus_size_t alignment, bus_size_t boundary, bus_dma_segment_t *segs,
    int nsegs, int *rsegs, int flags)
d924 1
a924 1
	struct sbus_softc *sc = t->_cookie;
d926 1
a926 1
	return (iommu_dvmamem_alloc(t0, &sc->sc_is, size, alignment, boundary,
d931 4
a934 2
sbus_dmamem_free(bus_dma_tag_t t, bus_dma_tag_t t0, bus_dma_segment_t *segs,
    int nsegs)
d936 1
a936 1
	struct sbus_softc *sc = t->_cookie;
d938 1
a938 1
	iommu_dvmamem_free(t0, &sc->sc_is, segs, nsegs);
d942 7
a948 2
sbus_dmamem_map(bus_dma_tag_t t, bus_dma_tag_t t0, bus_dma_segment_t *segs,
    int nsegs, size_t size, caddr_t *kvap, int flags)
d950 1
a950 1
	struct sbus_softc *sc = t->_cookie;
d952 1
a952 2
	return (iommu_dvmamem_map(t0, &sc->sc_is, segs, nsegs, size,
	    kvap, flags));
d956 4
a959 1
sbus_dmamem_unmap(bus_dma_tag_t t, bus_dma_tag_t t0, caddr_t kva, size_t size)
d961 1
a961 1
	struct sbus_softc *sc = t->_cookie;
d963 1
a963 1
	iommu_dvmamem_unmap(t0, &sc->sc_is, kva, size);
@


1.7.4.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: sbus.c,v 1.7.4.4 2003/03/27 23:42:36 niklas Exp $	*/
d61 5
a65 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.7.4.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d154 1
a154 2
    void *,		/*handler arg*/
    const char *);	/*what*/
d177 17
a228 1
	char *class;
d231 1
a231 1
	if (busname != NULL) {
a232 4
		class = getpropstring(sa->sa_node, "device_type");
		if (*class != '\0')
			printf(" class %s", class);
	}
d324 1
a324 1
		sc->sc_sb.sb_flush = NULL;
d659 1
a659 1
    int flags, int (*handler)(void *), void *arg, const char *what)
a663 2
	volatile u_int64_t *map = NULL;
	volatile u_int64_t *clr = NULL;
d669 5
d697 2
a698 2
			map = &(&sysio->sbus_slot0_int)[slot];
			clr = &sysio->sbus0_clr_int[vec];
d701 1
a701 1
				int64_t intrmap = *map;
d706 1
a706 1
				    map, clr);
d720 1
a720 1
			bus_space_map(sc->sc_bustag, (bus_addr_t)map, 8,
d740 1
a740 1
				map = &intrptr[i];
d742 1
a742 1
				clr = &intrptr[i];
d754 1
a754 1
				    (bus_addr_t)map, 8,
d766 4
a769 4
	ih = bus_intr_allocate(t0, handler, arg, vec, ipl, map, clr, what);
	if (ih == NULL)
		return (ih);

a770 1

d811 10
a820 10
	sdt->_dmamap_create	= sbus_dmamap_create;
	sdt->_dmamap_destroy	= iommu_dvmamap_destroy;
	sdt->_dmamap_load	= iommu_dvmamap_load;
	sdt->_dmamap_load_raw	= iommu_dvmamap_load_raw;
	sdt->_dmamap_unload	= iommu_dvmamap_unload;
	sdt->_dmamap_sync	= iommu_dvmamap_sync;
	sdt->_dmamem_alloc	= iommu_dvmamem_alloc;
	sdt->_dmamem_free	= iommu_dvmamem_free;
	sdt->_dmamem_map	= iommu_dvmamem_map;
	sdt->_dmamem_unmap	= iommu_dvmamem_unmap;
d832 36
a867 2
        return (iommu_dvmamap_create(t, t0, &sc->sc_sb, size, nsegments,
	    maxsegsz, boundary, flags, dmamp));
d870 62
@


1.6
log
@implement autoconf mechanism using device_register(); from NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD: sbus.c,v 1.5 2001/08/22 12:09:12 art Exp $	*/
/*	$NetBSD: sbus.c,v 1.43 2001/07/20 00:07:13 eeh Exp $ */
d145 1
a145 1
static int sbus_bus_mmap __P((bus_space_tag_t, bus_type_t, bus_addr_t,
d147 1
d285 1
a285 1
	int error;
d327 2
a328 1
	sc->sc_is.is_sb = &sc->sc_sysio->sys_strbuf;
d371 2
a372 1
	for (node = firstchild(node); node; node = nextsibling(node)) {
d515 1
a515 2
		return (bus_space_mmap(sc->sc_bustag, 0, paddr,
				       flags, hp));
d518 23
a540 1
	return (-1);
d809 1
a809 1
	sbt->sparc_bus_mmap = sbus_bus_mmap;
@


1.5
log
@Too much cut 'n paste. sbus is not an ifnet.
@
text
@d1 1
a1 1
/*	$OpenBSD: sbus.c,v 1.4 2001/08/20 19:40:43 jason Exp $	*/
a376 6

		if (ma->ma_bp != NULL && strcmp(ma->ma_bp->name, "sbus") == 0)
			sa.sa_bp = ma->ma_bp + 1;
		else
			sa.sa_bp = NULL;

@


1.4
log
@more stuff to do with OpenBSD/sparc style bootpath determination
@
text
@d1 1
a1 1
/*	$OpenBSD: sbus.c,v 1.3 2001/08/19 05:32:03 art Exp $	*/
d175 1
a175 1
	NULL, "sbus", DV_IFNET
@


1.3
log
@sbus_cd.
@
text
@d1 1
a1 1
/*	$OpenBSD: sbus.c,v 1.2 2001/08/18 21:30:00 jason Exp $	*/
d284 1
a284 1
	int node0, error;
d369 1
a369 2
	node0 = firstchild(node);
	for (node = node0; node; node = nextsibling(node)) {
d377 6
@


1.2
log
@RCSids
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d172 4
@


1.1
log
@enough to get sbus.o from NetBSD
@
text
@d1 1
@

