head	1.27;
access;
symbols
	OPENBSD_6_1_BASE:1.27
	OPENBSD_6_0:1.27.0.8
	OPENBSD_6_0_BASE:1.27
	OPENBSD_5_9:1.27.0.4
	OPENBSD_5_9_BASE:1.27
	OPENBSD_5_8:1.27.0.6
	OPENBSD_5_8_BASE:1.27
	OPENBSD_5_7:1.27.0.2
	OPENBSD_5_7_BASE:1.27
	OPENBSD_5_6:1.26.0.6
	OPENBSD_5_6_BASE:1.26
	OPENBSD_5_5:1.26.0.4
	OPENBSD_5_5_BASE:1.26
	OPENBSD_5_4:1.24.0.2
	OPENBSD_5_4_BASE:1.24
	OPENBSD_5_3:1.23.0.14
	OPENBSD_5_3_BASE:1.23
	OPENBSD_5_2:1.23.0.12
	OPENBSD_5_2_BASE:1.23
	OPENBSD_5_1_BASE:1.23
	OPENBSD_5_1:1.23.0.10
	OPENBSD_5_0:1.23.0.8
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.23.0.6
	OPENBSD_4_9_BASE:1.23
	OPENBSD_4_8:1.23.0.4
	OPENBSD_4_8_BASE:1.23
	OPENBSD_4_7:1.23.0.2
	OPENBSD_4_7_BASE:1.23
	OPENBSD_4_6:1.22.0.8
	OPENBSD_4_6_BASE:1.22
	OPENBSD_4_5:1.22.0.4
	OPENBSD_4_5_BASE:1.22
	OPENBSD_4_4:1.22.0.2
	OPENBSD_4_4_BASE:1.22
	OPENBSD_4_3:1.21.0.2
	OPENBSD_4_3_BASE:1.21
	OPENBSD_4_2:1.18.0.8
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.18.0.6
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.18.0.4
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.18.0.2
	OPENBSD_3_9_BASE:1.18
	OPENBSD_3_8:1.17.0.4
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.17.0.2
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.13.0.8
	OPENBSD_3_6_BASE:1.13
	SMP_SYNC_A:1.13
	SMP_SYNC_B:1.13
	OPENBSD_3_5:1.13.0.4
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.13.0.2
	OPENBSD_3_4_BASE:1.13
	UBC_SYNC_A:1.12
	OPENBSD_3_3:1.12.0.2
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.10.0.2
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	UBC_SYNC_B:1.11
	UBC:1.3.0.6
	UBC_BASE:1.3
	SMP:1.3.0.4
	OPENBSD_3_0:1.3.0.2
	OPENBSD_3_0_BASE:1.3;
locks; strict;
comment	@ * @;


1.27
date	2015.02.05.12.04.58;	author miod;	state Exp;
branches;
next	1.26;
commitid	nfEz66YvzGXJsIIq;

1.26
date	2013.11.01.21.22.31;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2013.10.21.12.14.53;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2013.04.21.14.44.16;	author sebastia;	state Exp;
branches;
next	1.23;

1.23
date	2009.09.10.21.30.00;	author kettenis;	state Exp;
branches;
next	1.22;

1.22
date	2008.06.26.05.42.13;	author ray;	state Exp;
branches;
next	1.21;

1.21
date	2007.11.14.20.43.12;	author kettenis;	state Exp;
branches;
next	1.20;

1.20
date	2007.11.13.13.50.10;	author kettenis;	state Exp;
branches;
next	1.19;

1.19
date	2007.10.22.14.46.46;	author jsing;	state Exp;
branches;
next	1.18;

1.18
date	2006.01.09.20.57.00;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2004.09.29.19.17.43;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2004.09.28.18.37.43;	author jason;	state Exp;
branches;
next	1.15;

1.15
date	2004.09.24.20.53.12;	author jason;	state Exp;
branches;
next	1.14;

1.14
date	2004.09.23.18.00.58;	author jason;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.24.21.54.39;	author henric;	state Exp;
branches;
next	1.12;

1.12
date	2003.02.17.01.29.20;	author henric;	state Exp;
branches;
next	1.11;

1.11
date	2002.10.12.01.09.43;	author krw;	state Exp;
branches;
next	1.10;

1.10
date	2002.09.23.18.43.18;	author jason;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.14.01.26.45;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.01.25.03.58.39;	author jason;	state Exp;
branches;
next	1.7;

1.7
date	2002.01.25.03.36.25;	author jason;	state Exp;
branches;
next	1.6;

1.6
date	2002.01.24.03.38.56;	author jason;	state Exp;
branches;
next	1.5;

1.5
date	2002.01.17.05.17.10;	author jason;	state Exp;
branches;
next	1.4;

1.4
date	2002.01.15.22.00.12;	author jason;	state Exp;
branches;
next	1.3;

1.3
date	2001.08.21.21.42.30;	author jason;	state Exp;
branches
	1.3.4.1
	1.3.6.1;
next	1.2;

1.2
date	2001.08.20.20.23.52;	author jason;	state Exp;
branches;
next	1.1;

1.1
date	2001.08.19.05.21.37;	author jason;	state Exp;
branches;
next	;

1.3.4.1
date	2001.10.31.03.07.58;	author nate;	state Exp;
branches;
next	1.3.4.2;

1.3.4.2
date	2002.03.06.02.04.47;	author niklas;	state Exp;
branches;
next	1.3.4.3;

1.3.4.3
date	2002.03.28.11.23.52;	author niklas;	state Exp;
branches;
next	1.3.4.4;

1.3.4.4
date	2003.03.27.23.42.36;	author niklas;	state Exp;
branches;
next	1.3.4.5;

1.3.4.5
date	2004.02.19.10.50.00;	author niklas;	state Exp;
branches;
next	;

1.3.6.1
date	2002.01.31.22.55.24;	author niklas;	state Exp;
branches;
next	1.3.6.2;

1.3.6.2
date	2002.06.11.03.38.43;	author art;	state Exp;
branches;
next	1.3.6.3;

1.3.6.3
date	2002.10.29.00.28.11;	author art;	state Exp;
branches;
next	1.3.6.4;

1.3.6.4
date	2003.05.19.21.46.57;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.27
log
@Do what the comments suggest and check for port-[ab]-ignore-cd properties,
and if so, force soft carrier mode.
@
text
@/*	$OpenBSD: zs.c,v 1.26 2013/11/01 21:22:31 miod Exp $	*/
/*	$NetBSD: zs.c,v 1.29 2001/05/30 15:24:24 lukem Exp $	*/

/*-
 * Copyright (c) 1996 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Gordon W. Ross.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Zilog Z8530 Dual UART driver (machine-dependent part)
 *
 * Runs two serial lines per chip using slave drivers.
 * Plain tty/async lines use the zstty slave.
 * Sun keyboard/mouse uses the zskbd/zsms slaves.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/conf.h>
#include <sys/device.h>
#include <sys/file.h>
#include <sys/ioctl.h>
#include <sys/kernel.h>
#include <sys/proc.h>
#include <sys/tty.h>
#include <sys/time.h>
#include <sys/syslog.h>

#include <machine/autoconf.h>
#include <machine/openfirm.h>
#include <machine/conf.h>
#include <machine/cpu.h>
#include <machine/psl.h>
#include <machine/z8530var.h>

#include <dev/cons.h>
#include <dev/ic/z8530reg.h>
#include <sparc64/dev/fhcvar.h>
#include <ddb/db_output.h>

#include <sparc64/dev/cons.h>

struct cfdriver zs_cd = {
	NULL, "zs", DV_TTY
};

/*
 * Some warts needed by z8530tty.c -
 * The default parity REALLY needs to be the same as the PROM uses,
 * or you can not see messages done with printf during boot-up...
 */
int zs_def_cflag = (CREAD | CS8 | HUPCL);
int zs_major = 12;

/*
 * The Sun provides a 4.9152 MHz clock to the ZS chips.
 */
#define PCLK	(9600 * 512)	/* PCLK pin input clock rate */

#define	ZS_DELAY()

/* The layout of this is hardware-dependent (padding, order). */
struct zschan {
	volatile u_char	zc_csr;		/* ctrl,status, and indirect access */
	u_char		zc_xxx0;
	volatile u_char	zc_data;	/* data */
	u_char		zc_xxx1;
};
struct zsdevice {
	/* Yes, they are backwards. */
	struct	zschan zs_chan_b;
	struct	zschan zs_chan_a;
};

/* ZS channel used as the console device (if any) */
void *zs_conschan_get, *zs_conschan_put;

static u_char zs_init_reg[16] = {
	0,	/* 0: CMD (reset, etc.) */
	0,	/* 1: No interrupts yet. */
	0,	/* 2: IVECT */
	ZSWR3_RX_8 | ZSWR3_RX_ENABLE,
	ZSWR4_CLK_X16 | ZSWR4_ONESB,
	ZSWR5_TX_8 | ZSWR5_TX_ENABLE,
	0,	/* 6: TXSYNC/SYNCLO */
	0,	/* 7: RXSYNC/SYNCHI */
	0,	/* 8: alias for data port */
	ZSWR9_MASTER_IE | ZSWR9_NO_VECTOR,
	0,	/*10: Misc. TX/RX control bits */
	ZSWR11_TXCLK_BAUD | ZSWR11_RXCLK_BAUD,
	((PCLK/32)/9600)-2,	/*12: BAUDLO (default=9600) */
	0,			/*13: BAUDHI (default=9600) */
	ZSWR14_BAUD_ENA | ZSWR14_BAUD_FROM_PCLK,
	ZSWR15_BREAK_IE,
};

/* Console ops */
static int  zscngetc(dev_t);
static void zscnputc(dev_t, int);
static void zscnpollc(dev_t, int);

struct consdev zs_consdev = {
	NULL,
	NULL,
	zscngetc,
	zscnputc,
	zscnpollc,
	NULL,
};


/****************************************************************
 * Autoconfig
 ****************************************************************/

/* Definition of the driver for autoconfig. */
static int  zs_match_sbus(struct device *, void *, void *);
static void zs_attach_sbus(struct device *, struct device *, void *);

static int  zs_match_fhc(struct device *, void *, void *);
static void zs_attach_fhc(struct device *, struct device *, void *);

static void zs_attach(struct zsc_softc *, struct zsdevice *, int);
static int  zs_print(void *, const char *name);

struct cfattach zs_sbus_ca = {
	sizeof(struct zsc_softc), zs_match_sbus, zs_attach_sbus
};

struct cfattach zs_fhc_ca = {
	sizeof(struct zsc_softc), zs_match_fhc, zs_attach_fhc
};

extern int stdinnode;
extern int fbnode;

/* Interrupt handlers. */
static int zshard(void *);
static void zssoft(void *);

static int zs_get_speed(struct zs_chanstate *);

/* Console device support */
static int zs_console_flags(int, int, int);

/*
 * Is the zs chip present?
 */
static int
zs_match_sbus(parent, vcf, aux)
	struct device *parent;
	void *vcf;
	void *aux;
{
	struct cfdata *cf = vcf;
	struct sbus_attach_args *sa = aux;

	if (strcmp(cf->cf_driver->cd_name, sa->sa_name) != 0)
		return (0);

	return (1);
}

static int
zs_match_fhc(parent, vcf, aux)
	struct device *parent;
	void *vcf;
	void *aux;
{
	struct cfdata *cf = vcf;
	struct fhc_attach_args *fa = aux;

	if (strcmp(cf->cf_driver->cd_name, fa->fa_name) != 0)
		return (0);
	return (1);
}

static void
zs_attach_sbus(parent, self, aux)
	struct device *parent;
	struct device *self;
	void *aux;
{
	struct zsc_softc *zsc = (void *) self;
	struct sbus_attach_args *sa = aux;
	struct zsdevice *zsaddr;
	bus_space_handle_t kvaddr;

	if (sa->sa_nintr == 0) {
		printf(" no interrupt lines\n");
		return;
	}

	/* Only map registers once. */
	if (sa->sa_npromvaddrs) {
		/*
		 * We're converting from a 32-bit pointer to a 64-bit
		 * pointer.  Since the 32-bit entity is negative, but
		 * the kernel is still mapped into the lower 4GB
		 * range, this needs to be zero-extended.
		 *
		 * XXXXX If we map the kernel and devices into the
		 * high 4GB range, this needs to be changed to
		 * sign-extend the address.
		 */
		zsaddr = (struct zsdevice *)
		    (unsigned long int)sa->sa_promvaddrs[0];
	} else {
		if (sbus_bus_map(sa->sa_bustag, sa->sa_slot, sa->sa_offset,
		    sa->sa_size, BUS_SPACE_MAP_LINEAR, 0, &kvaddr) != 0) {
			printf("%s @@ sbus: cannot map registers\n",
			       self->dv_xname);
			return;
		}
		zsaddr = (struct zsdevice *)
		    bus_space_vaddr(sa->sa_bustag, kvaddr);
	}

	zsc->zsc_bustag = sa->sa_bustag;
	zsc->zsc_dmatag = sa->sa_dmatag;
	zsc->zsc_promunit = getpropint(sa->sa_node, "slave", -2);
	zsc->zsc_node = sa->sa_node;

	zs_attach(zsc, zsaddr, sa->sa_pri);
}

static void
zs_attach_fhc(parent, self, aux)
	struct device *parent;
	struct device *self;
	void *aux;
{
	struct zsc_softc *zsc = (void *) self;
	struct fhc_attach_args *fa = aux;
	struct zsdevice *zsaddr;
	bus_space_handle_t kvaddr;

	if (fa->fa_nreg < 1 && fa->fa_npromvaddrs < 1) {
		printf(": no registers\n");
		return;
	}

	if (fa->fa_nintr < 1) {
		printf(": no interrupts\n");
		return;
	}

	if (fa->fa_npromvaddrs) {
		/*
		 * We're converting from a 32-bit pointer to a 64-bit
		 * pointer.  Since the 32-bit entity is negative, but
		 * the kernel is still mapped into the lower 4GB
		 * range, this needs to be zero-extended.
		 *
		 * XXXXX If we map the kernel and devices into the
		 * high 4GB range, this needs to be changed to
		 * sign-extend the address.
		 */
		zsaddr = (struct zsdevice *)
		    (unsigned long int)fa->fa_promvaddrs[0];
	} else {
		if (fhc_bus_map(fa->fa_bustag, fa->fa_reg[0].fbr_slot,
		    fa->fa_reg[0].fbr_offset, fa->fa_reg[0].fbr_size,
		    BUS_SPACE_MAP_LINEAR, &kvaddr) != 0) {
			printf("%s @@ fhc: cannot map registers\n",
			    self->dv_xname);
			return;
		}
		zsaddr = (struct zsdevice *)
		    bus_space_vaddr(fa->fa_bustag, kvaddr);
	}

	zsc->zsc_bustag = fa->fa_bustag;
	zsc->zsc_dmatag = NULL;
	zsc->zsc_promunit = getpropint(fa->fa_node, "slave", -2);
	zsc->zsc_node = fa->fa_node;

	zs_attach(zsc, zsaddr, fa->fa_intr[0]);
}

/*
 * Attach a found zs.
 *
 * USE ROM PROPERTY keyboard FOR KEYBOARD/MOUSE?
 */
static void
zs_attach(zsc, zsd, pri)
	struct zsc_softc *zsc;
	struct zsdevice *zsd;
	int pri;
{
	struct zsc_attach_args zsc_args;
	struct zs_chanstate *cs;
	int s, channel, softpri = PIL_TTY;

	if (zsd == NULL) {
		printf("configuration incomplete\n");
		return;
	}

	printf(" softpri %d\n", softpri);

	/*
	 * Initialize software state for each channel.
	 */
	for (channel = 0; channel < 2; channel++) {
		struct zschan *zc;
		struct device *child;

		zsc_args.type = "serial";
		if (getproplen(zsc->zsc_node, "keyboard") == 0) {
			if (channel == 0)
				zsc_args.type = "keyboard";
			if (channel == 1)
				zsc_args.type = "mouse";
		}

		zsc_args.channel = channel;
		cs = &zsc->zsc_cs_store[channel];
		zsc->zsc_cs[channel] = cs;

		cs->cs_channel = channel;
		cs->cs_private = NULL;
		cs->cs_ops = &zsops_null;
		cs->cs_brg_clk = PCLK / 16;

		zc = (channel == 0) ? &zsd->zs_chan_a : &zsd->zs_chan_b;

		zsc_args.consdev = NULL;
		zsc_args.hwflags = zs_console_flags(zsc->zsc_promunit,
						    zsc->zsc_node,
						    channel);

		if (zsc_args.hwflags & ZS_HWFLAG_CONSOLE) {
			zsc_args.hwflags |= ZS_HWFLAG_USE_CONSDEV;
			zsc_args.consdev = &zs_consdev;
		}

		if (getproplen(zsc->zsc_node, channel == 0 ?
		    "port-a-ignore-cd" : "port-b-ignore-cd") == 0) {
			zsc_args.hwflags |= ZS_HWFLAG_NO_DCD;
		}

		if ((zsc_args.hwflags & ZS_HWFLAG_CONSOLE_INPUT) != 0) {
			zs_conschan_get = zc;
		}
		if ((zsc_args.hwflags & ZS_HWFLAG_CONSOLE_OUTPUT) != 0) {
			zs_conschan_put = zc;
		}
		/* Childs need to set cn_dev, etc */

		cs->cs_reg_csr  = &zc->zc_csr;
		cs->cs_reg_data = &zc->zc_data;

		bcopy(zs_init_reg, cs->cs_creg, 16);
		bcopy(zs_init_reg, cs->cs_preg, 16);

		/* XXX: Consult PROM properties for this?! */
		cs->cs_defspeed = zs_get_speed(cs);
		cs->cs_defcflag = zs_def_cflag;

		/* Make these correspond to cs_defcflag (-crtscts) */
		cs->cs_rr0_dcd = ZSRR0_DCD;
		cs->cs_rr0_cts = 0;
		cs->cs_wr5_dtr = ZSWR5_DTR | ZSWR5_RTS;
		cs->cs_wr5_rts = 0;

		/*
		 * Clear the master interrupt enable.
		 * The INTENA is common to both channels,
		 * so just do it on the A channel.
		 */
		if (channel == 0) {
			zs_write_reg(cs, 9, 0);
		}

		/*
		 * Look for a child driver for this channel.
		 * The child attach will setup the hardware.
		 */
		if (!(child = 
		      config_found(&zsc->zsc_dev, (void *)&zsc_args, zs_print))) {
			/* No sub-driver.  Just reset it. */
			u_char reset = (channel == 0) ?
				ZSWR9_A_RESET : ZSWR9_B_RESET;
			s = splzs();
			zs_write_reg(cs,  9, reset);
			splx(s);
		} 
	}

	/*
	 * Now safe to install interrupt handlers.
	 */
	if (bus_intr_establish(zsc->zsc_bustag, pri, IPL_SERIAL, 0, zshard,
	    zsc, zsc->zsc_dev.dv_xname) == NULL)
		panic("zsattach: could not establish interrupt");
	if (!(zsc->zsc_softintr = softintr_establish(softpri, zssoft, zsc)))
		panic("zsattach: could not establish soft interrupt");

	/*
	 * Set the master interrupt enable and interrupt vector.
	 * (common to both channels, do it on A)
	 */
	cs = zsc->zsc_cs[0];
	s = splhigh();
	/* interrupt vector */
	zs_write_reg(cs, 2, zs_init_reg[2]);
	/* master interrupt control (enable) */
	zs_write_reg(cs, 9, zs_init_reg[9]);
	splx(s);

}

static int
zs_print(aux, name)
	void *aux;
	const char *name;
{
	struct zsc_attach_args *args = aux;

	if (name != NULL)
		printf("%s: ", name);

	if (args->channel != -1)
		printf(" channel %d", args->channel);

	return (UNCONF);
}

static int
zshard(arg)
	void *arg;
{
	struct zsc_softc *zsc = (struct zsc_softc *)arg;
	int rval = 0;

	while (zsc_intr_hard(zsc))
		rval = 1;
	if ((zsc->zsc_cs[0] && zsc->zsc_cs[0]->cs_softreq) ||
	    (zsc->zsc_cs[1] && zsc->zsc_cs[1]->cs_softreq))
		softintr_schedule(zsc->zsc_softintr);
	return (rval);
}

/*
 * We need this only for TTY_DEBUG purposes.
 */
static void
zssoft(arg)
	void *arg;
{
	struct zsc_softc *zsc = (struct zsc_softc *)arg;
	int s;

	/* Make sure we call the tty layer at spltty. */
	s = spltty();
	(void)zsc_intr_soft(zsc);
#ifdef TTY_DEBUG
	{
		struct zstty_softc *zst0 = zsc->zsc_cs[0]->cs_private;
		struct zstty_softc *zst1 = zsc->zsc_cs[1]->cs_private;
		if (zst0->zst_overflows || zst1->zst_overflows ) {
			struct trapframe *frame = (struct trapframe *)arg;
			
			printf("zs silo overflow from %p\n",
			       (long)frame->tf_pc);
		}
	}
#endif
	splx(s);
}


/*
 * Compute the current baud rate given a ZS channel.
 */
static int
zs_get_speed(cs)
	struct zs_chanstate *cs;
{
	int tconst;

	tconst = zs_read_reg(cs, 12);
	tconst |= zs_read_reg(cs, 13) << 8;
	return (TCONST_TO_BPS(cs->cs_brg_clk, tconst));
}

/*
 * MD functions for setting the baud rate and control modes.
 */
int
zs_set_speed(cs, bps)
	struct zs_chanstate *cs;
	int bps;	/* bits per second */
{
	int tconst, real_bps;

	if (bps == 0)
		return (0);

#ifdef	DIAGNOSTIC
	if (cs->cs_brg_clk == 0)
		panic("zs_set_speed");
#endif

	tconst = BPS_TO_TCONST(cs->cs_brg_clk, bps);
	if (tconst < 0)
		return (EINVAL);

	/* Convert back to make sure we can do it. */
	real_bps = TCONST_TO_BPS(cs->cs_brg_clk, tconst);

	/* XXX - Allow some tolerance here? */
	if (real_bps != bps)
		return (EINVAL);

	cs->cs_preg[12] = tconst;
	cs->cs_preg[13] = tconst >> 8;

	/* Caller will stuff the pending registers. */
	return (0);
}

int
zs_set_modes(cs, cflag)
	struct zs_chanstate *cs;
	int cflag;
{
	int s;

	/*
	 * Output hardware flow control on the chip is horrendous:
	 * if carrier detect drops, the receiver is disabled, and if
	 * CTS drops, the transmitter is stopped IN MID CHARACTER!
	 * Therefore, NEVER set the HFC bit, and instead use the
	 * status interrupt to detect CTS changes.
	 */
	s = splzs();
	cs->cs_rr0_pps = 0;
	if ((cflag & (CLOCAL | MDMBUF)) != 0) {
		cs->cs_rr0_dcd = 0;
		if ((cflag & MDMBUF) == 0)
			cs->cs_rr0_pps = ZSRR0_DCD;
	} else
		cs->cs_rr0_dcd = ZSRR0_DCD;
	if ((cflag & CRTSCTS) != 0) {
		cs->cs_wr5_dtr = ZSWR5_DTR;
		cs->cs_wr5_rts = ZSWR5_RTS;
		cs->cs_rr0_cts = ZSRR0_CTS;
#if 0 /* JLW */
	} else if ((cflag & CDTRCTS) != 0) {
		cs->cs_wr5_dtr = 0;
		cs->cs_wr5_rts = ZSWR5_DTR;
		cs->cs_rr0_cts = ZSRR0_CTS;
#endif
	} else if ((cflag & MDMBUF) != 0) {
		cs->cs_wr5_dtr = 0;
		cs->cs_wr5_rts = ZSWR5_DTR;
		cs->cs_rr0_cts = ZSRR0_DCD;
	} else {
		cs->cs_wr5_dtr = ZSWR5_DTR | ZSWR5_RTS;
		cs->cs_wr5_rts = 0;
		cs->cs_rr0_cts = 0;
	}
	splx(s);

	/* Caller will stuff the pending registers. */
	return (0);
}


/*
 * Read or write the chip with suitable delays.
 */

u_char
zs_read_reg(cs, reg)
	struct zs_chanstate *cs;
	u_char reg;
{
	u_char val;

	*cs->cs_reg_csr = reg;
	ZS_DELAY();
	val = *cs->cs_reg_csr;
	ZS_DELAY();
	return (val);
}

void
zs_write_reg(cs, reg, val)
	struct zs_chanstate *cs;
	u_char reg, val;
{
	*cs->cs_reg_csr = reg;
	ZS_DELAY();
	*cs->cs_reg_csr = val;
	ZS_DELAY();
}

u_char
zs_read_csr(cs)
	struct zs_chanstate *cs;
{
	u_char val;

	val = *cs->cs_reg_csr;
	ZS_DELAY();
	return (val);
}

void
zs_write_csr(cs, val)
	struct zs_chanstate *cs;
	u_char val;
{
	*cs->cs_reg_csr = val;
	ZS_DELAY();
}

u_char
zs_read_data(cs)
	struct zs_chanstate *cs;
{
	u_char val;

	val = *cs->cs_reg_data;
	ZS_DELAY();
	return (val);
}

void
zs_write_data(cs, val)
	struct zs_chanstate *cs;
	u_char val;
{
	*cs->cs_reg_data = val;
	ZS_DELAY();
}

/****************************************************************
 * Console support functions (Sun specific!)
 * Note: this code is allowed to know about the layout of
 * the chip registers, and uses that to keep things simple.
 * XXX - I think I like the mvme167 code better. -gwr
 ****************************************************************/

extern void Debugger(void);

/*
 * Handle user request to enter kernel debugger.
 */
void
zs_abort(cs)
	struct zs_chanstate *cs;
{
	volatile struct zschan *zc = zs_conschan_get;
	int rr0;

	/* Wait for end of break to avoid PROM abort. */
	/* XXX - Limit the wait? */
	do {
		rr0 = zc->zc_csr;
		ZS_DELAY();
	} while (rr0 & ZSRR0_BREAK);

#if defined(KGDB)
	zskgdb(cs);
#elif defined(DDB)
	{
		extern int db_active;
		
		if (!db_active)
			Debugger();
		else
			/* Debugger is probably hozed */
			callrom();
	}
#else
	printf("stopping on keyboard abort\n");
	callrom();
#endif
}


/*
 * Polled input char.
 */
int
zs_getc(arg)
	void *arg;
{
	volatile struct zschan *zc = arg;
	int s, c, rr0;

	s = splhigh();
	/* Wait for a character to arrive. */
	do {
		rr0 = zc->zc_csr;
		ZS_DELAY();
	} while ((rr0 & ZSRR0_RX_READY) == 0);

	c = zc->zc_data;
	ZS_DELAY();
	splx(s);

	return (c);
}

/*
 * Polled output char.
 */
void
zs_putc(arg, c)
	void *arg;
	int c;
{
	volatile struct zschan *zc = arg;
	int s, rr0;

	s = splhigh();

	/* Wait for transmitter to become ready. */
	do {
		rr0 = zc->zc_csr;
		ZS_DELAY();
	} while ((rr0 & ZSRR0_TX_READY) == 0);

	/*
	 * Send the next character.
	 * Now you'd think that this could be followed by a ZS_DELAY()
	 * just like all the other chip accesses, but it turns out that
	 * the `transmit-ready' interrupt isn't de-asserted until
	 * some period of time after the register write completes
	 * (more than a couple instructions).  So to avoid stray
	 * interrupts we put in the 2us delay regardless of cpu model.
	 */
	zc->zc_data = c;
	delay(2);

	splx(s);
}

/*****************************************************************/




/*
 * Polled console input putchar.
 */
static int
zscngetc(dev)
	dev_t dev;
{
	return (zs_getc(zs_conschan_get));
}

/*
 * Polled console output putchar.
 */
static void
zscnputc(dev, c)
	dev_t dev;
	int c;
{
	zs_putc(zs_conschan_put, c);
}

int swallow_zsintrs;

static void
zscnpollc(dev, on)
	dev_t dev;
	int on;
{
	/* 
	 * Need to tell zs driver to acknowledge all interrupts or we get
	 * annoying spurious interrupt messages.  This is because mucking
	 * with spl() levels during polling does not prevent interrupts from
	 * being generated.
	 */

	if (on)
		swallow_zsintrs++;
	else
		swallow_zsintrs--;
}

int
zs_console_flags(promunit, node, channel)
	int promunit;
	int node;
	int channel;
{
	int cookie, flags = 0;
	u_int options;
	char buf[255];

	/*
	 * We'll just to the OBP grovelling down here since that's
	 * the only type of firmware we support.
	 */
	options = OF_finddevice("/options");

	/* Default to channel 0 if there are no explicit prom args */
	cookie = 0;

	if (node == OF_instance_to_package(OF_stdin())) {
		if (OF_getprop(options, "input-device",
		    buf, sizeof(buf)) != -1) {
			if (strncmp("ttyb", buf, strlen("ttyb")) == 0)
				cookie = 1;
		}

		if (channel == cookie)
			flags |= ZS_HWFLAG_CONSOLE_INPUT;
	}

	if (node == OF_instance_to_package(OF_stdout())) { 
		if (OF_getprop(options, "output-device",
		    buf, sizeof(buf)) != -1) {
			if (strncmp("ttyb", buf, strlen("ttyb")) == 0)
				cookie = 1;
		}
		
		if (channel == cookie)
			flags |= ZS_HWFLAG_CONSOLE_OUTPUT;
	}

	return (flags);
}
@


1.26
log
@Drop zsaddr[NZS] and the need for zs to be needs-count. zsaddr[] is no longer
necessary now that each zs device registers its own interrupt handler, and
zshard() does not need to walk all zs chips, which has been the case for years.
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.25 2013/10/21 12:14:53 miod Exp $	*/
d107 1
a107 1
	ZSWR4_CLK_X16 | ZSWR4_ONESB | ZSWR4_EVENP,
d308 1
a308 2
 * USE ROM PROPERTIES port-a-ignore-cd AND port-b-ignore-cd FOR
 * SOFT CARRIER, AND keyboard PROPERTY FOR KEYBOARD/MOUSE?
d361 5
@


1.25
log
@Fix lies in comments, and apply some KNF and unused or duplicate prototype
removals.
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.24 2013/04/21 14:44:16 sebastia Exp $	*/
a66 2
#include "zs.h" 	/* NZS */

a70 6
/* Make life easier for the initialized arrays here. */
#if NZS < 3
#undef  NZS
#define NZS 3
#endif

a101 3
/* Saved PROM mappings */
static struct zsdevice *zsaddr[NZS];

d210 2
a211 1
	int zs_unit = zsc->zsc_dev.dv_unit;
d218 20
a237 31
	/* Use the mapping setup by the Sun PROM. */
	if (zsaddr[zs_unit] == NULL) {
		/* Only map registers once. */
		if (sa->sa_npromvaddrs) {
			/*
			 * We're converting from a 32-bit pointer to a 64-bit
			 * pointer.  Since the 32-bit entity is negative, but
			 * the kernel is still mapped into the lower 4GB
			 * range, this needs to be zero-extended.
			 *
			 * XXXXX If we map the kernel and devices into the
			 * high 4GB range, this needs to be changed to
			 * sign-extend the address.
			 */
			zsaddr[zs_unit] = 
				(struct zsdevice *)
				(unsigned long int)sa->sa_promvaddrs[0];
		} else {
			bus_space_handle_t kvaddr;

			if (sbus_bus_map(sa->sa_bustag, sa->sa_slot,
					 sa->sa_offset,
					 sa->sa_size,
					 BUS_SPACE_MAP_LINEAR,
					 0, &kvaddr) != 0) {
				printf("%s @@ sbus: cannot map registers\n",
				       self->dv_xname);
				return;
			}
			zsaddr[zs_unit] = (struct zsdevice *)
				bus_space_vaddr(sa->sa_bustag, kvaddr);
d239 2
d242 1
d247 2
a248 1
	zs_attach(zsc, zsaddr[zs_unit], sa->sa_pri);
d259 1
a259 1
	int zs_unit = zsc->zsc_dev.dv_unit;
d272 20
a291 24
	if (zsaddr[zs_unit] == NULL) {
		if (fa->fa_npromvaddrs) {
			/*
			 * We're converting from a 32-bit pointer to a 64-bit
			 * pointer.  Since the 32-bit entity is negative, but
			 * the kernel is still mapped into the lower 4GB
			 * range, this needs to be zero-extended.
			 *
			 * XXXXX If we map the kernel and devices into the
			 * high 4GB range, this needs to be changed to
			 * sign-extend the address.
			 */
			zsaddr[zs_unit] = (struct zsdevice *)
			    (unsigned long int)fa->fa_promvaddrs[0];
		} else {
			if (fhc_bus_map(fa->fa_bustag, fa->fa_reg[0].fbr_slot,
			    fa->fa_reg[0].fbr_offset, fa->fa_reg[0].fbr_size,
			    BUS_SPACE_MAP_LINEAR, &kvaddr) != 0) {
				printf("%s @@ fhc: cannot map registers\n",
				    self->dv_xname);
				return;
			}
			zsaddr[zs_unit] = (struct zsdevice *)
			    bus_space_vaddr(fa->fa_bustag, kvaddr);
d293 2
d302 1
a302 1
	zs_attach(zsc, zsaddr[zs_unit], fa->fa_intr[0]);
d413 1
a413 3
	 * Now safe to install interrupt handlers.  Note the arguments
	 * to the interrupt handlers aren't used.  Note, we only do this
	 * once since both SCCs interrupt at the same level and vector.
d456 1
a456 1
	int rr3, rval;
d458 4
a461 8
	rval = 0;
	while ((rr3 = zsc_intr_hard(zsc))) {
		/* Count up the interrupts. */
		rval |= rr3;
	}
	if (((zsc->zsc_cs[0] && zsc->zsc_cs[0]->cs_softreq) ||
	     (zsc->zsc_cs[1] && zsc->zsc_cs[1]->cs_softreq)) &&
	    zsc->zsc_softintr) {
a462 1
	}
@


1.24
log
@Unify the zs tty driver.

Most of the hard work by mpi@@, who provided the initial diff.
Fixes for sparc from myself. Tested on sgi and sparc myself.
Compiles and detects zstty on my powerbook, compile tested on
sparc64 by me. Real testing with zs device on sparc64 by miod@@
who also gave a lot of help and feedback.

ok miod@@, mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.23 2009/09/10 21:30:00 kettenis Exp $	*/
d37 2
a38 2
 * Plain tty/async lines use the zs_async slave.
 * Sun keyboard/mouse uses the zs_kbd/zs_ms slaves.
a172 1
int zscheckintr(void *);
a180 4
/* Power management hooks */
int  zs_enable(struct zs_chanstate *);
void zs_disable(struct zs_chanstate *);

a491 19
int
zscheckintr(arg)
	void *arg;
{
	struct zsc_softc *zsc;
	int unit, rval;

	rval = 0;
	for (unit = 0; unit < zs_cd.cd_ndevs; unit++) {

		zsc = zs_cd.cd_devs[unit];
		if (zsc == NULL)
			continue;
		rval = (zshard((void *)zsc) || rval);
	}
	return (rval);
}


d574 1
a574 1
	int cflag;	/* bits per second */
d659 2
a660 1
void  zs_write_csr(cs, val)
d668 2
a669 1
u_char zs_read_data(cs)
d679 2
a680 1
void  zs_write_data(cs, val)
d831 4
a834 2
	if (on) swallow_zsintrs++;
	else swallow_zsintrs--;
a879 1

@


1.23
log
@Remove zssoftpending; it isn't of any use anymore.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.22 2008/06/26 05:42:13 ray Exp $	*/
d61 1
a61 1
#include <sparc64/dev/z8530reg.h>
@


1.22
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.21 2007/11/14 20:43:12 kettenis Exp $	*/
a476 3
/* Deprecate this? */
static volatile int zssoftpending;

a491 1
		zssoftpending = PIL_TTY;
a527 1
	zssoftpending = 0;
@


1.21
log
@Remove eeprom.h.
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.20 2007/11/13 13:50:10 kettenis Exp $	*/
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.20
log
@Remove bsd_openprom.h.
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.19 2007/10/22 14:46:46 jsing Exp $	*/
a63 1
#include <machine/eeprom.h>
@


1.19
log
@stoped -> stopped

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.18 2006/01/09 20:57:00 miod Exp $	*/
a61 1
#include <machine/bsd_openprom.h>
@


1.18
log
@Remove completely obsolete comment from the pre-wscons sparc days in
zs_getc().
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.17 2004/09/29 19:17:43 miod Exp $	*/
d619 1
a619 1
	 * CTS drops, the transmitter is stoped IN MID CHARACTER!
@


1.17
log
@Ratibibugle now useless evcnt structures.
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.16 2004/09/28 18:37:43 jason Exp $	*/
a788 4
	/*
	 * This is used by the kd driver to read scan codes,
	 * so don't translate '\r' ==> '\n' here...
	 */
@


1.16
log
@use prom mappings when availavk
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.15 2004/09/24 20:53:12 jason Exp $	*/
a455 3
	evcnt_attach(&zsc->zsc_dev, "intr", &zsc->zsc_intrcnt);


a499 1
		zsc->zsc_intrcnt.ev_count++;
@


1.15
log
@fix up attachment of zs@@fhc
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.14 2004/09/23 18:00:58 jason Exp $	*/
d293 1
a293 1
	if (fa->fa_nreg < 1) {
d303 25
a327 5
	if (fhc_bus_map(fa->fa_bustag, fa->fa_reg[0].fbr_slot,
	    fa->fa_reg[0].fbr_offset, fa->fa_reg[0].fbr_size,
	    BUS_SPACE_MAP_LINEAR, &kvaddr) != 0) {
		printf("%s @@ fhc: cannot map registers\n", self->dv_xname);
		return;
a328 2
	zsaddr[zs_unit] =
	    (struct zsdevice *) bus_space_vaddr(fa->fa_bustag, kvaddr);
@


1.14
log
@prepare the way for multi-bus attachment of zs (specifically zs@@fhc).
Remove the zs@@mainbus stuff from files.sparc64 (nothing uses it)
don't forget to rerun config...
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.13 2003/06/24 21:54:39 henric Exp $	*/
d291 1
d293 9
a301 1
	bus_space_handle_t kvaddr;
d316 2
a317 4
	printf("\n");
#if 0
	zs_attach(zsc, zsaddr[zs_unit], sa->sa_pri);
#endif
@


1.13
log
@Add a "where" argument to the sparc64 interrupt code.  This lets us
associate a name with each interrupt handler.  This is not visible
outside the kernel (yet).

ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.12 2003/02/17 01:29:20 henric Exp $	*/
d71 1
d161 5
a165 2
static int  zs_match_mainbus(struct device *, void *, void *);
static void zs_attach_mainbus(struct device *, struct device *, void *);
d170 2
a171 3
/* Do we really need this ? */
struct cfattach zs_ca = {
	sizeof(struct zsc_softc), zs_match_mainbus, zs_attach_mainbus
d174 2
a175 2
struct cfattach zs_mainbus_ca = {
	sizeof(struct zsc_softc), zs_match_mainbus, zs_attach_mainbus
a177 1
extern struct cfdriver zs_cd;
d199 1
a199 1
zs_match_mainbus(parent, vcf, aux)
d213 14
d228 1
a228 1
zs_attach_mainbus(parent, self, aux)
d280 31
@


1.12
log
@
Add support for the Sun Enterprise 450
Reduce the size of a GENERIC kernel by ~190k
Remove the nasty pointer/bus_space_handle_t casts
Adds debug bus_space code including the ability to trace
    bus operations (it actually works now).

The following rules are now followed (and verfified by the debug
code):

1.  A "bus_space_handle_t" may only be used with the
    "bus_space_tag_t" that created it.
2.  Only "bus_space_map()" may create "bus_space_handle_t"s.
3.  A "bus_space_handle_t" may not be modified after it has
    been created (other than being destroyed by "bus_space_unmap()").


Thanks to help from mcbride, marc, jason, drahn, to anyone that might
have slipped my mind at the moment.

ok jason@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.11 2002/10/12 01:09:43 krw Exp $	*/
d378 3
a380 1
	bus_intr_establish(zsc->zsc_bustag, pri, IPL_SERIAL, 0, zshard, zsc);
@


1.11
log
@Remove more '\n's from panic() statements. Both trailing and leading.

Diff generated by Chris Kuethe.
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.10 2002/09/23 18:43:18 jason Exp $	*/
d256 1
a256 1
				(unsigned long int)kvaddr;
@


1.10
log
@Fix console determination; based on discussion in port-sparc64@@netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.9 2002/03/14 01:26:45 millert Exp $	*/
d380 1
a380 1
		panic("zsattach: could not establish soft interrupt\n");
@


1.9
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.8 2002/01/25 03:58:39 jason Exp $	*/
d811 1
a811 1
	u_int chosen;
d818 1
a818 1
	chosen = OF_finddevice("/chosen");
d822 1
d824 3
a826 3
		if (OF_getprop(chosen, "input-device", buf, sizeof(buf)) != -1) {

			if (!strcmp("ttyb", buf))
d835 3
a837 3
		if (OF_getprop(chosen, "output-device", buf, sizeof(buf)) != -1) {

			if (!strcmp("ttyb", buf))
@


1.8
log
@Remove kbd_ms_ttyvar.h... Unneeded file from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.7 2002/01/25 03:36:25 jason Exp $	*/
d141 3
a143 3
static int  zscngetc __P((dev_t));
static void zscnputc __P((dev_t, int));
static void zscnpollc __P((dev_t, int));
d160 2
a161 2
static int  zs_match_mainbus __P((struct device *, void *, void *));
static void zs_attach_mainbus __P((struct device *, struct device *, void *));
d163 2
a164 2
static void zs_attach __P((struct zsc_softc *, struct zsdevice *, int));
static int  zs_print __P((void *, const char *name));
d180 3
a182 3
int zscheckintr __P((void *));
static int zshard __P((void *));
static void zssoft __P((void *));
d184 1
a184 1
static int zs_get_speed __P((struct zs_chanstate *));
d187 1
a187 1
static int zs_console_flags __P((int, int, int));
d190 2
a191 2
int  zs_enable __P((struct zs_chanstate *));
void zs_disable __P((struct zs_chanstate *));
d660 1
a660 1
extern void Debugger __P((void));
@


1.7
log
@Remove more NKBD/NMS references (jason == cpp tonight I guess)
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.6 2002/01/24 03:38:56 jason Exp $	*/
a70 1
#include <dev/sun/kbd_ms_ttyvar.h>
@


1.6
log
@Don't need ms.h (or SUNKBD/SUNMS)
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.5 2002/01/17 05:17:10 jason Exp $	*/
a295 3
#if (NKBD > 0) || (NMS > 0)
		extern struct cfdriver zstty_cd; /* in ioconf.c */
#endif
a371 37
#if (NKBD > 0) || (NMS > 0)
		/* 
		 * If this was a zstty it has a keyboard
		 * property on it we need to attach the
		 * sunkbd and sunms line disciplines.
		 */
		if (child 
		    && (child->dv_cfdata->cf_driver == &zstty_cd) 
		    && (getproplen(zsc->zsc_node, "keyboard") == 0)) {
			struct kbd_ms_tty_attach_args kma;
			struct zstty_softc {	
				/* The following are the only fields we need here */
				struct	device zst_dev;
				struct  tty *zst_tty;
				struct	zs_chanstate *zst_cs;
			} *zst = (struct zstty_softc *)child;
			struct tty *tp;

			kma.kmta_tp = tp = zst->zst_tty;
			kma.kmta_dev = tp->t_dev;
			kma.kmta_consdev = zsc_args.consdev;

			/* Attach 'em if we got 'em. */
#if (NKBD > 0)
			if (channel == 0) {
				kma.kmta_name = "keyboard";
				config_found(child, (void *)&kma, NULL);
			}
#endif
#if (NMS > 0)
			if (channel == 1) {
				kma.kmta_name = "mouse";
				config_found(child, (void *)&kma, NULL);
			}
#endif
		}
#endif
@


1.5
log
@I'm a tree breaker... sorry... don't include "kbd.h"
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.4 2002/01/15 22:00:12 jason Exp $	*/
a75 1
#include "ms.h"		/* NMS */
@


1.4
log
@Frontend driver for keyboards attached to zs's (instead of zstty's).
Doesn't really work yet, but it's not terribly far off.
This is a work in progress..
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.3 2001/08/21 21:42:30 jason Exp $	*/
a75 1
#include "kbd.h"	/* NKBD */
@


1.3
log
@zs and all it's associated stuff (all from NetBSD).. Works on my ultra1,
but still needs tweaks (wedging this into OpenBSD is worse than square
peg in round hole).
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.2 2001/08/20 20:23:52 jason Exp $	*/
d302 8
d398 1
a398 1
			
@


1.3.6.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.8 2002/01/25 03:58:39 jason Exp $	*/
d71 1
d76 2
d298 3
a300 8

		zsc_args.type = "serial";
		if (getproplen(zsc->zsc_node, "keyboard") == 0) {
			if (channel == 0)
				zsc_args.type = "keyboard";
			if (channel == 1)
				zsc_args.type = "mouse";
		}
d369 37
@


1.3.6.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.3.6.1 2002/01/31 22:55:24 niklas Exp $	*/
d141 3
a143 3
static int  zscngetc(dev_t);
static void zscnputc(dev_t, int);
static void zscnpollc(dev_t, int);
d160 2
a161 2
static int  zs_match_mainbus(struct device *, void *, void *);
static void zs_attach_mainbus(struct device *, struct device *, void *);
d163 2
a164 2
static void zs_attach(struct zsc_softc *, struct zsdevice *, int);
static int  zs_print(void *, const char *name);
d180 3
a182 3
int zscheckintr(void *);
static int zshard(void *);
static void zssoft(void *);
d184 1
a184 1
static int zs_get_speed(struct zs_chanstate *);
d187 1
a187 1
static int zs_console_flags(int, int, int);
d190 2
a191 2
int  zs_enable(struct zs_chanstate *);
void zs_disable(struct zs_chanstate *);
d660 1
a660 1
extern void Debugger(void);
@


1.3.6.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.3.6.2 2002/06/11 03:38:43 art Exp $	*/
d380 1
a380 1
		panic("zsattach: could not establish soft interrupt");
d811 1
a811 1
	u_int options;
d818 1
a818 1
	options = OF_finddevice("/options");
d822 2
d825 1
a825 4
	if (node == OF_instance_to_package(OF_stdin())) {
		if (OF_getprop(options, "input-device",
		    buf, sizeof(buf)) != -1) {
			if (strncmp("ttyb", buf, strlen("ttyb")) == 0)
d834 3
a836 3
		if (OF_getprop(options, "output-device",
		    buf, sizeof(buf)) != -1) {
			if (strncmp("ttyb", buf, strlen("ttyb")) == 0)
@


1.3.6.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d256 1
a256 1
				bus_space_vaddr(sa->sa_bustag, kvaddr);
@


1.3.4.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.3.4.2
log
@Merge in trunk
@
text
@d71 1
d76 2
d298 3
a300 8

		zsc_args.type = "serial";
		if (getproplen(zsc->zsc_node, "keyboard") == 0) {
			if (channel == 0)
				zsc_args.type = "keyboard";
			if (channel == 1)
				zsc_args.type = "mouse";
		}
d369 37
@


1.3.4.3
log
@Merge in -current from about a week ago
@
text
@d141 3
a143 3
static int  zscngetc(dev_t);
static void zscnputc(dev_t, int);
static void zscnpollc(dev_t, int);
d160 2
a161 2
static int  zs_match_mainbus(struct device *, void *, void *);
static void zs_attach_mainbus(struct device *, struct device *, void *);
d163 2
a164 2
static void zs_attach(struct zsc_softc *, struct zsdevice *, int);
static int  zs_print(void *, const char *name);
d180 3
a182 3
int zscheckintr(void *);
static int zshard(void *);
static void zssoft(void *);
d184 1
a184 1
static int zs_get_speed(struct zs_chanstate *);
d187 1
a187 1
static int zs_console_flags(int, int, int);
d190 2
a191 2
int  zs_enable(struct zs_chanstate *);
void zs_disable(struct zs_chanstate *);
d660 1
a660 1
extern void Debugger(void);
@


1.3.4.4
log
@Sync the SMP branch with 3.3
@
text
@d256 1
a256 1
				bus_space_vaddr(sa->sa_bustag, kvaddr);
d380 1
a380 1
		panic("zsattach: could not establish soft interrupt");
d811 1
a811 1
	u_int options;
d818 1
a818 1
	options = OF_finddevice("/options");
d822 2
d825 1
a825 4
	if (node == OF_instance_to_package(OF_stdin())) {
		if (OF_getprop(options, "input-device",
		    buf, sizeof(buf)) != -1) {
			if (strncmp("ttyb", buf, strlen("ttyb")) == 0)
d834 3
a836 3
		if (OF_getprop(options, "output-device",
		    buf, sizeof(buf)) != -1) {
			if (strncmp("ttyb", buf, strlen("ttyb")) == 0)
@


1.3.4.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d378 1
a378 3
	if (bus_intr_establish(zsc->zsc_bustag, pri, IPL_SERIAL, 0, zshard,
	    zsc, zsc->zsc_dev.dv_xname) == NULL)
		panic("zsattach: could not establish interrupt");
@


1.2
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d70 1
a70 1
#include <dev/ic/z8530reg.h>
d80 4
d163 1
a163 1
static int  zs_match_mainbus __P((struct device *, struct cfdata *, void *));
d200 1
a200 1
zs_match_mainbus(parent, cf, aux)
d202 1
a202 1
	struct cfdata *cf;
d205 1
d245 1
a245 1
				(uintptr_t)sa->sa_promvaddrs[0];
d259 1
a259 1
				(uintptr_t)kvaddr;
d298 1
d300 1
d417 1
a417 2
	evcnt_attach_dynamic(&zsc->zsc_intrcnt, EVCNT_TYPE_INTR, NULL,
	    zsc->zsc_dev.dv_xname, "intr");
d600 1
d605 1
@


1.1
log
@Lot of stuff... Some from NetBSD, some from OpenBSD, minor modifications
@
text
@d1 1
@

