head	1.64;
access;
symbols
	OPENBSD_6_1:1.64.0.14
	OPENBSD_6_1_BASE:1.64
	OPENBSD_6_0:1.64.0.10
	OPENBSD_6_0_BASE:1.64
	OPENBSD_5_9:1.64.0.6
	OPENBSD_5_9_BASE:1.64
	OPENBSD_5_8:1.64.0.8
	OPENBSD_5_8_BASE:1.64
	OPENBSD_5_7:1.64.0.2
	OPENBSD_5_7_BASE:1.64
	OPENBSD_5_6:1.64.0.4
	OPENBSD_5_6_BASE:1.64
	OPENBSD_5_5:1.60.0.4
	OPENBSD_5_5_BASE:1.60
	OPENBSD_5_4:1.59.0.6
	OPENBSD_5_4_BASE:1.59
	OPENBSD_5_3:1.59.0.4
	OPENBSD_5_3_BASE:1.59
	OPENBSD_5_2:1.59.0.2
	OPENBSD_5_2_BASE:1.59
	OPENBSD_5_1_BASE:1.58
	OPENBSD_5_1:1.58.0.12
	OPENBSD_5_0:1.58.0.10
	OPENBSD_5_0_BASE:1.58
	OPENBSD_4_9:1.58.0.8
	OPENBSD_4_9_BASE:1.58
	OPENBSD_4_8:1.58.0.6
	OPENBSD_4_8_BASE:1.58
	OPENBSD_4_7:1.58.0.2
	OPENBSD_4_7_BASE:1.58
	OPENBSD_4_6:1.58.0.4
	OPENBSD_4_6_BASE:1.58
	OPENBSD_4_5:1.56.0.2
	OPENBSD_4_5_BASE:1.56
	OPENBSD_4_4:1.52.0.2
	OPENBSD_4_4_BASE:1.52
	OPENBSD_4_3:1.50.0.6
	OPENBSD_4_3_BASE:1.50
	OPENBSD_4_2:1.50.0.4
	OPENBSD_4_2_BASE:1.50
	OPENBSD_4_1:1.50.0.2
	OPENBSD_4_1_BASE:1.50
	OPENBSD_4_0:1.47.0.2
	OPENBSD_4_0_BASE:1.47
	OPENBSD_3_9:1.42.0.4
	OPENBSD_3_9_BASE:1.42
	OPENBSD_3_8:1.42.0.2
	OPENBSD_3_8_BASE:1.42
	OPENBSD_3_7:1.41.0.2
	OPENBSD_3_7_BASE:1.41
	OPENBSD_3_6:1.35.0.4
	OPENBSD_3_6_BASE:1.35
	SMP_SYNC_A:1.34
	SMP_SYNC_B:1.34
	OPENBSD_3_5:1.34.0.4
	OPENBSD_3_5_BASE:1.34
	OPENBSD_3_4:1.34.0.2
	OPENBSD_3_4_BASE:1.34
	UBC_SYNC_A:1.31
	OPENBSD_3_3:1.31.0.2
	OPENBSD_3_3_BASE:1.31
	OPENBSD_3_2:1.28.0.2
	OPENBSD_3_2_BASE:1.28
	OPENBSD_3_1:1.16.0.2
	OPENBSD_3_1_BASE:1.16
	SMP:1.5.0.2
	UBC_SYNC_B:1.28
	UBC:1.2.0.2
	UBC_BASE:1.2;
locks; strict;
comment	@ * @;


1.64
date	2014.07.28.15.00.27;	author jsg;	state Exp;
branches;
next	1.63;
commitid	UC1Kg7uZbOmNOW0L;

1.63
date	2014.07.22.04.53.59;	author deraadt;	state Exp;
branches;
next	1.62;
commitid	AI2mHFSZ0ZrtNJCF;

1.62
date	2014.07.22.04.44.09;	author deraadt;	state Exp;
branches;
next	1.61;
commitid	z5wYcc2dIGrVIwOy;

1.61
date	2014.07.22.04.42.51;	author jsg;	state Exp;
branches;
next	1.60;
commitid	EtAKn2rlAqe8IYXn;

1.60
date	2013.10.20.20.07.27;	author miod;	state Exp;
branches;
next	1.59;

1.59
date	2012.07.08.16.36.23;	author kettenis;	state Exp;
branches;
next	1.58;

1.58
date	2009.06.02.18.51.03;	author kettenis;	state Exp;
branches;
next	1.57;

1.57
date	2009.03.01.10.48.54;	author kettenis;	state Exp;
branches;
next	1.56;

1.56
date	2008.12.29.22.07.35;	author miod;	state Exp;
branches;
next	1.55;

1.55
date	2008.12.27.17.23.01;	author miod;	state Exp;
branches;
next	1.54;

1.54
date	2008.10.01.21.06.42;	author kettenis;	state Exp;
branches;
next	1.53;

1.53
date	2008.08.11.20.56.55;	author kettenis;	state Exp;
branches;
next	1.52;

1.52
date	2008.03.23.12.10.53;	author miod;	state Exp;
branches;
next	1.51;

1.51
date	2008.03.21.17.14.12;	author miod;	state Exp;
branches;
next	1.50;

1.50
date	2007.03.06.19.13.13;	author miod;	state Exp;
branches;
next	1.49;

1.49
date	2007.01.13.21.03.23;	author miod;	state Exp;
branches;
next	1.48;

1.48
date	2006.12.17.22.18.16;	author miod;	state Exp;
branches;
next	1.47;

1.47
date	2006.08.29.01.27.59;	author deraadt;	state Exp;
branches;
next	1.46;

1.46
date	2006.08.11.18.57.08;	author miod;	state Exp;
branches;
next	1.45;

1.45
date	2006.05.30.19.53.31;	author miod;	state Exp;
branches;
next	1.44;

1.44
date	2006.04.16.22.28.02;	author miod;	state Exp;
branches;
next	1.43;

1.43
date	2006.04.09.12.22.56;	author matthieu;	state Exp;
branches;
next	1.42;

1.42
date	2005.07.17.17.13.38;	author miod;	state Exp;
branches;
next	1.41;

1.41
date	2005.03.15.20.19.24;	author miod;	state Exp;
branches;
next	1.40;

1.40
date	2005.03.15.18.40.15;	author miod;	state Exp;
branches;
next	1.39;

1.39
date	2005.03.07.16.44.52;	author miod;	state Exp;
branches;
next	1.38;

1.38
date	2005.01.05.23.04.25;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2004.12.02.02.41.02;	author brad;	state Exp;
branches;
next	1.36;

1.36
date	2004.11.30.13.23.19;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2004.08.10.21.57.51;	author millert;	state Exp;
branches;
next	1.34;

1.34
date	2003.06.16.21.46.23;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2003.06.16.20.47.04;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2003.06.02.20.02.49;	author jason;	state Exp;
branches;
next	1.31;

1.31
date	2002.12.25.01.23.04;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2002.12.10.02.12.33;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2002.11.09.22.51.48;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2002.09.15.14.29.29;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2002.09.10.03.18.59;	author jason;	state Exp;
branches;
next	1.26;

1.26
date	2002.08.19.20.16.04;	author jason;	state Exp;
branches;
next	1.25;

1.25
date	2002.08.02.16.13.07;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2002.07.30.17.55.56;	author jason;	state Exp;
branches;
next	1.23;

1.23
date	2002.07.25.19.19.55;	author jason;	state Exp;
branches;
next	1.22;

1.22
date	2002.07.24.15.36.38;	author jason;	state Exp;
branches;
next	1.21;

1.21
date	2002.06.11.22.56.37;	author jason;	state Exp;
branches;
next	1.20;

1.20
date	2002.06.11.22.53.09;	author jason;	state Exp;
branches;
next	1.19;

1.19
date	2002.06.11.15.33.27;	author matthieu;	state Exp;
branches;
next	1.18;

1.18
date	2002.06.04.21.50.07;	author jason;	state Exp;
branches;
next	1.17;

1.17
date	2002.04.15.17.43.30;	author jason;	state Exp;
branches;
next	1.16;

1.16
date	2002.04.08.17.49.42;	author jason;	state Exp;
branches;
next	1.15;

1.15
date	2002.04.01.19.50.53;	author jason;	state Exp;
branches;
next	1.14;

1.14
date	2002.03.31.17.34.15;	author jason;	state Exp;
branches;
next	1.13;

1.13
date	2002.03.30.00.08.14;	author jason;	state Exp;
branches;
next	1.12;

1.12
date	2002.03.28.04.28.38;	author jason;	state Exp;
branches;
next	1.11;

1.11
date	2002.03.27.05.00.12;	author jason;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.27.01.15.12;	author jason;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.27.01.00.48;	author jason;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.26.01.28.18;	author jason;	state Exp;
branches;
next	1.7;

1.7
date	2002.03.14.03.16.00;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.03.14.01.26.44;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.02.08.16.46.26;	author jason;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2002.02.05.18.34.39;	author jason;	state Exp;
branches;
next	1.3;

1.3
date	2002.01.03.16.26.27;	author jason;	state Exp;
branches;
next	1.2;

1.2
date	2001.12.14.19.17.02;	author jason;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2001.12.14.14.59.04;	author jason;	state Exp;
branches;
next	;

1.2.2.1
date	2002.01.31.22.55.24;	author niklas;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2002.06.11.03.38.43;	author art;	state Exp;
branches;
next	1.2.2.3;

1.2.2.3
date	2002.10.29.00.28.11;	author art;	state Exp;
branches;
next	1.2.2.4;

1.2.2.4
date	2003.05.19.21.46.57;	author tedu;	state Exp;
branches;
next	;

1.5.2.1
date	2002.03.28.11.23.52;	author niklas;	state Exp;
branches;
next	1.5.2.2;

1.5.2.2
date	2003.03.27.23.42.36;	author niklas;	state Exp;
branches;
next	1.5.2.3;

1.5.2.3
date	2003.06.07.11.14.45;	author ho;	state Exp;
branches;
next	1.5.2.4;

1.5.2.4
date	2004.02.19.10.50.00;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.64
log
@Limit the "aperture needed" printf to ramdisks via RAMDISK_HOOKS.
Originally with SMALL_KERNEL until sebastia@@ pointed out that not
all ramdisks are built with SMALL_KERNEL.
ok deraadt@@ kettenis@@
@
text
@/*	$OpenBSD: vgafb.c,v 1.63 2014/07/22 04:53:59 deraadt Exp $	*/

/*
 * Copyright (c) 2001 Jason L. Wright (jason@@thought.net)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * Effort sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F30602-01-2-0537.
 *
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/errno.h>
#include <sys/ioctl.h>
#include <sys/malloc.h>
#include <sys/pciio.h>

#include <uvm/uvm_extern.h>

#include <machine/autoconf.h>
#include <machine/bus.h>
#include <machine/intr.h>
#include <machine/openfirm.h>

#include <dev/pci/pcidevs.h>
#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/vga_pcivar.h>

#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsdisplayvar.h>
#include <dev/rasops/rasops.h>

#include <machine/fbvar.h>

struct vgafb_softc {
	struct sunfb sc_sunfb;
	int sc_nscreens;
	int sc_node, sc_ofhandle;
	bus_space_tag_t sc_mem_t;
	bus_space_tag_t sc_io_t;
	pcitag_t sc_pcitag;
	bus_space_handle_t sc_mem_h;
	bus_addr_t sc_io_addr, sc_mem_addr, sc_mmio_addr;
	bus_size_t sc_io_size, sc_mem_size, sc_mmio_size;
	int sc_console;
	u_int sc_mode;
	u_int8_t sc_cmap_red[256];
	u_int8_t sc_cmap_green[256];
	u_int8_t sc_cmap_blue[256];
};

int vgafb_mapregs(struct vgafb_softc *, struct pci_attach_args *);
int vgafb_rommap(struct vgafb_softc *, struct pci_attach_args *);
int vgafb_ioctl(void *, u_long, caddr_t, int, struct proc *);
paddr_t vgafb_mmap(void *, off_t, int);
int vgafb_is_console(int);
int vgafb_getcmap(struct vgafb_softc *, struct wsdisplay_cmap *);
int vgafb_putcmap(struct vgafb_softc *, struct wsdisplay_cmap *);
void vgafb_setcolor(void *, u_int, u_int8_t, u_int8_t, u_int8_t);

struct wsdisplay_accessops vgafb_accessops = {
	.ioctl = vgafb_ioctl,
	.mmap = vgafb_mmap
};

int	vgafbmatch(struct device *, void *, void *);
void	vgafbattach(struct device *, struct device *, void *);

struct cfattach vgafb_ca = {
	sizeof (struct vgafb_softc), vgafbmatch, vgafbattach
};

struct cfdriver vgafb_cd = {
	NULL, "vgafb", DV_DULL
};

#ifdef APERTURE
extern int allowaperture;
#endif

int
vgafbmatch(parent, vcf, aux)
	struct device *parent;
	void *vcf, *aux;
{
	struct pci_attach_args *pa = aux;
	int node;

	/*
	 * Do not match on Expert3D devices, which are driven by ifb(4).
	 */
	if (ifb_ident(aux) != 0)
		return (0);

	/*
	 * XXX Non-console devices do not get configured by the PROM,
	 * XXX so do not attach them yet.
	 */
	node = PCITAG_NODE(pa->pa_tag);
	if (!vgafb_is_console(node))
		return (0);

	if (PCI_CLASS(pa->pa_class) == PCI_CLASS_PREHISTORIC &&
	    PCI_SUBCLASS(pa->pa_class) == PCI_SUBCLASS_PREHISTORIC_VGA)
		return (1);

	if (PCI_CLASS(pa->pa_class) == PCI_CLASS_DISPLAY &&
	    PCI_SUBCLASS(pa->pa_class) == PCI_SUBCLASS_DISPLAY_VGA)
		return (1);

	if (PCI_CLASS(pa->pa_class) == PCI_CLASS_DISPLAY &&
	    PCI_SUBCLASS(pa->pa_class) == PCI_SUBCLASS_DISPLAY_MISC)
		return (1);

	return (0);
}

void    
vgafbattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct vgafb_softc *sc = (struct vgafb_softc *)self;
	struct pci_attach_args *pa = aux;

	sc->sc_mem_t = pa->pa_memt;
	sc->sc_io_t = pa->pa_iot;
	sc->sc_node = PCITAG_NODE(pa->pa_tag);
	sc->sc_pcitag = pa->pa_tag;

	printf("\n");

	if (vgafb_mapregs(sc, pa))
		return;

	sc->sc_console = vgafb_is_console(sc->sc_node);

	fb_setsize(&sc->sc_sunfb, 8, 1152, 900, sc->sc_node, 0);
	if (sc->sc_sunfb.sf_depth == 24) {
		sc->sc_sunfb.sf_depth = 32;
		sc->sc_sunfb.sf_linebytes =
		    (sc->sc_sunfb.sf_depth / 8) * sc->sc_sunfb.sf_width;
		sc->sc_sunfb.sf_fbsize =
		    sc->sc_sunfb.sf_height * sc->sc_sunfb.sf_linebytes;
	}

	sc->sc_sunfb.sf_ro.ri_bits = (void *)bus_space_vaddr(sc->sc_mem_t,
	    sc->sc_mem_h);
	sc->sc_sunfb.sf_ro.ri_hw = sc;

	fbwscons_init(&sc->sc_sunfb,
	    RI_BSWAP | (sc->sc_console ? 0 : RI_FORCEMONO), sc->sc_console);

	if (sc->sc_console) {
		sc->sc_ofhandle = OF_stdout();
		fbwscons_setcolormap(&sc->sc_sunfb, vgafb_setcolor);
		fbwscons_console_init(&sc->sc_sunfb, -1);
	} else {
		/* sc->sc_ofhandle = PCITAG_NODE(sc->sc_pcitag); */
	}

#ifdef RAMDISK_HOOKS
	if (vga_aperture_needed(pa))
		printf("%s: aperture needed\n", sc->sc_sunfb.sf_dev.dv_xname);
#endif

	fbwscons_attach(&sc->sc_sunfb, &vgafb_accessops, sc->sc_console);
}

int
vgafb_ioctl(v, cmd, data, flags, p)
	void *v;
	u_long cmd;
	caddr_t data;
	int flags;
	struct proc *p;
{
	struct vgafb_softc *sc = v;
	struct wsdisplay_fbinfo *wdf;
	struct pcisel *sel;

	switch (cmd) {
	case WSDISPLAYIO_GTYPE:
		*(u_int *)data = WSDISPLAY_TYPE_UNKNOWN;
		break;
	case WSDISPLAYIO_SMODE:
		sc->sc_mode = *(u_int *)data;
		if (sc->sc_mode == WSDISPLAYIO_MODE_EMUL) {
			if (sc->sc_console)	/* XXX needs sc_ofhandle */
				fbwscons_setcolormap(&sc->sc_sunfb,
				    vgafb_setcolor);
		}
		break;
	case WSDISPLAYIO_GINFO:
		wdf = (void *)data;
		wdf->height = sc->sc_sunfb.sf_height;
		wdf->width  = sc->sc_sunfb.sf_width;
		wdf->depth  = sc->sc_sunfb.sf_depth;
		wdf->cmsize = 256;
		break;
	case WSDISPLAYIO_GETSUPPORTEDDEPTH:
		if (sc->sc_sunfb.sf_depth == 32)
			*(u_int *)data = WSDISPLAYIO_DEPTH_24_32;
		else
			return (-1);
		break;
	case WSDISPLAYIO_LINEBYTES:
		*(u_int *)data = sc->sc_sunfb.sf_linebytes;
		break;
		
	case WSDISPLAYIO_GETCMAP:
		if (sc->sc_console == 0)
			return (EINVAL);
		return vgafb_getcmap(sc, (struct wsdisplay_cmap *)data);
	case WSDISPLAYIO_PUTCMAP:
		if (sc->sc_console == 0)
			return (EINVAL);
		return vgafb_putcmap(sc, (struct wsdisplay_cmap *)data);

	case WSDISPLAYIO_GPCIID:
		sel = (struct pcisel *)data;
		sel->pc_bus = PCITAG_BUS(sc->sc_pcitag);
		sel->pc_dev = PCITAG_DEV(sc->sc_pcitag);
		sel->pc_func = PCITAG_FUN(sc->sc_pcitag);
		break;

	case WSDISPLAYIO_SVIDEO:
	case WSDISPLAYIO_GVIDEO:
		break;

	case WSDISPLAYIO_GCURPOS:
	case WSDISPLAYIO_SCURPOS:
	case WSDISPLAYIO_GCURMAX:
	case WSDISPLAYIO_GCURSOR:
	case WSDISPLAYIO_SCURSOR:
	default:
		return -1; /* not supported yet */
        }

	return (0);
}

int
vgafb_getcmap(sc, cm)
	struct vgafb_softc *sc;
	struct wsdisplay_cmap *cm;
{
	u_int index = cm->index;
	u_int count = cm->count;
	int error;

	if (index >= 256 || count > 256 - index)
		return (EINVAL);

	error = copyout(&sc->sc_cmap_red[index], cm->red, count);
	if (error)
		return (error);
	error = copyout(&sc->sc_cmap_green[index], cm->green, count);
	if (error)
		return (error);
	error = copyout(&sc->sc_cmap_blue[index], cm->blue, count);
	if (error)
		return (error);
	return (0);
}

int
vgafb_putcmap(sc, cm)
	struct vgafb_softc *sc;
	struct wsdisplay_cmap *cm;
{
	u_int index = cm->index;
	u_int count = cm->count;
	u_int i;
	int error;
	u_char *r, *g, *b;

	if (index >= 256 || count > 256 - index)
		return (EINVAL);

	if ((error = copyin(cm->red, &sc->sc_cmap_red[index], count)) != 0)
		return (error);
	if ((error = copyin(cm->green, &sc->sc_cmap_green[index], count)) != 0)
		return (error);
	if ((error = copyin(cm->blue, &sc->sc_cmap_blue[index], count)) != 0)
		return (error);

	r = &sc->sc_cmap_red[index];
	g = &sc->sc_cmap_green[index];
	b = &sc->sc_cmap_blue[index];

	for (i = 0; i < count; i++) {
		OF_call_method("color!", sc->sc_ofhandle, 4, 0, *r, *g, *b,
		    index);
		r++, g++, b++, index++;
	}
	return (0);
}

void
vgafb_setcolor(v, index, r, g, b)
	void *v;
	u_int index;
	u_int8_t r, g, b;
{
	struct vgafb_softc *sc = v;

	sc->sc_cmap_red[index] = r;
	sc->sc_cmap_green[index] = g;
	sc->sc_cmap_blue[index] = b;
	OF_call_method("color!", sc->sc_ofhandle, 4, 0, r, g, b, index);
}

paddr_t
vgafb_mmap(v, off, prot)
	void *v;
	off_t off;
	int prot;
{
	struct vgafb_softc *sc = v;

	if (off & PGOFSET)
		return (-1);

	switch (sc->sc_mode) {
	case WSDISPLAYIO_MODE_MAPPED:
#ifdef APERTURE
		if (allowaperture == 0)
			return (-1);
#endif

		if (sc->sc_mmio_size == 0)
			return (-1);

		if (off >= sc->sc_mem_addr &&
		    off < (sc->sc_mem_addr + sc->sc_mem_size))
			return (bus_space_mmap(sc->sc_mem_t,
			    sc->sc_mem_addr, off - sc->sc_mem_addr,
			    prot, BUS_SPACE_MAP_LINEAR));

		if (off >= sc->sc_mmio_addr &&
		    off < (sc->sc_mmio_addr + sc->sc_mmio_size))
			return (bus_space_mmap(sc->sc_mem_t,
			    sc->sc_mmio_addr, off - sc->sc_mmio_addr,
			    prot, BUS_SPACE_MAP_LINEAR));
		break;

	case WSDISPLAYIO_MODE_DUMBFB:
		if (off >= 0 && off < sc->sc_mem_size)
			return (bus_space_mmap(sc->sc_mem_t, sc->sc_mem_addr,
			    off, prot, BUS_SPACE_MAP_LINEAR));
		break;
	}

	return (-1);
}

int
vgafb_is_console(node)
	int node;
{
	extern int fbnode;

	return (fbnode == node);
}

int
vgafb_mapregs(sc, pa)
	struct vgafb_softc *sc;
	struct pci_attach_args *pa;
{
	bus_addr_t ba;
	bus_size_t bs;
	int hasio = 0, hasmem = 0, hasmmio = 0; 
	u_int32_t i, cf;
	int rv;

	for (i = PCI_MAPREG_START; i <= PCI_MAPREG_PPB_END; i += 4) {
		cf = pci_conf_read(pa->pa_pc, pa->pa_tag, i);
		if (PCI_MAPREG_TYPE(cf) == PCI_MAPREG_TYPE_IO) {
			if (hasio)
				continue;
			rv = pci_io_find(pa->pa_pc, pa->pa_tag, i,
			    &sc->sc_io_addr, &sc->sc_io_size);
			if (rv != 0) {
				if (rv != ENOENT)
					printf("%s: failed to find io at 0x%x\n",
					    sc->sc_sunfb.sf_dev.dv_xname, i);
				continue;
			}
			hasio = 1;
		} else {
			/* Memory mapping... frame memory or mmio? */
			rv = pci_mem_find(pa->pa_pc, pa->pa_tag, i,
			    &ba, &bs, NULL);
			if (rv != 0) {
				if (rv != ENOENT)
					printf("%s: failed to find mem at 0x%x\n",
					    sc->sc_sunfb.sf_dev.dv_xname, i);
				continue;
			}

			if (bs == 0 /* || ba == 0 */) {
				/* ignore this entry */
			} else if (hasmem == 0) {
				/*
				 * first memory slot found goes into memory,
				 * this is for the case of no mmio
				 */
				sc->sc_mem_addr = ba;
				sc->sc_mem_size = bs;
				hasmem = 1;
			} else {
				/*
				 * Oh, we have a second `memory'
				 * region, is this region the vga memory
				 * or mmio, we guess that memory is
				 * the larger of the two.
				 */
				if (sc->sc_mem_size >= bs) {
					/* this is the mmio */
					sc->sc_mmio_addr = ba;
					sc->sc_mmio_size = bs;
					hasmmio = 1;
				} else {
					/* this is the memory */
					sc->sc_mmio_addr = sc->sc_mem_addr;
					sc->sc_mmio_size = sc->sc_mem_size;
					sc->sc_mem_addr = ba;
					sc->sc_mem_size = bs;
				}
			}
		}
	}

	if (hasmem != 0) {
		if (bus_space_map(pa->pa_memt, sc->sc_mem_addr, sc->sc_mem_size,
		    0, &sc->sc_mem_h)) {
			printf("%s: can't map mem space\n",
			    sc->sc_sunfb.sf_dev.dv_xname);
			return (1);
		}
	}

	/* failure to initialize io ports should not prevent attachment */
	if (hasmem == 0) {
		printf("%s: could not find memory space\n",
		    sc->sc_sunfb.sf_dev.dv_xname);
		return (1);
	}

#ifdef DIAGNOSTIC
	if (hasmmio == 0) {
		printf("%s: WARNING: no mmio space configured\n",
		    sc->sc_sunfb.sf_dev.dv_xname);
	}
#endif

	return (0);
}
@


1.63
log
@oops, duplicate
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.62 2014/07/22 04:44:09 deraadt Exp $	*/
d187 1
d190 1
@


1.62
log
@need dev/pci/vga_pcivar.h
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.61 2014/07/22 04:42:51 jsg Exp $	*/
a56 2

#include <dev/pci/vga_pcivar.h>
@


1.61
log
@The aperture needed test should be in vgafb as well as vga@@pci.
Problem noticed/fix tested by sebastia@@ on macppc.
sparc64 problems in earlier diff pointed out by deraadt@@
'looks good' kettenis@@ 'commit' deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.60 2013/10/20 20:07:27 miod Exp $	*/
d57 2
@


1.60
log
@Use C99 named initializers for struct wsdisplay_accessops fields.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.59 2012/07/08 16:36:23 kettenis Exp $	*/
d52 1
d186 3
@


1.59
log
@Don't need to worry about the ATI driver here anymore.
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.58 2009/06/02 18:51:03 kettenis Exp $	*/
d86 2
a87 10
	vgafb_ioctl,
	vgafb_mmap,
	NULL,	/* alloc_screen */
	NULL,	/* free_screen */
	NULL,	/* show_screen */
	NULL,	/* load_font */
	NULL,	/* scrollback */
	NULL,	/* getchar */
	NULL,	/* burner */
	NULL	/* pollc */
@


1.58
log
@When about to run X11 in 32 bpp mode, advertize correctly that we are
really using 24 bpp pixels on 32 bit boundaries.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.57 2009/03/01 10:48:54 kettenis Exp $	*/
a449 4
					/* ATI driver maps 0x80000 mmio, grr */
					if (bs < 0x80000) {
						bs = 0x80000;
					}
a457 4
					/* ATI driver maps 0x80000 mmio, grr */
					if (sc->sc_mmio_size < 0x80000) {
						sc->sc_mmio_size = 0x80000;
					}
@


1.57
log
@Don't let an mmio area replace the frame buffer if they are the same size.
Seen on a Tech Source Raptor.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.56 2008/12/29 22:07:35 miod Exp $	*/
d227 6
@


1.56
log
@Move ifb identification to its own routine. We can not simply have the ifb
probe win over vgafb, since one may configure a kernel with vgafb but without
ifb (especially slackers who forget to rerun config).
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.55 2008/12/27 17:23:01 miod Exp $	*/
d441 1
a441 1
				if (sc->sc_mem_size > bs) {
@


1.55
log
@Sync the sparc64 fb* api with the recent changes done on sparc.
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.54 2008/10/01 21:06:42 kettenis Exp $	*/
a112 7
static const struct pci_matchid ifb_devices[] = {
    { PCI_VENDOR_INTERGRAPH, PCI_PRODUCT_INTERGRAPH_EXPERT3D },
    { PCI_VENDOR_3DLABS,     PCI_PRODUCT_3DLABS_WILDCAT_6210 },
    { PCI_VENDOR_3DLABS,     PCI_PRODUCT_3DLABS_WILDCAT_5110 },/* Sun XVR-500 */
    { PCI_VENDOR_3DLABS,     PCI_PRODUCT_3DLABS_WILDCAT_7210 }
};

a119 1
	char *name;
d122 1
a122 2
	 * Do not match on Expert3D devices, which need a different
	 * driver.
d124 1
a124 8
	if (pci_matchbyid(pa, ifb_devices,
	    sizeof(ifb_devices) / sizeof(ifb_devices[0])) != 0)
		return (0);

	node = PCITAG_NODE(pa->pa_tag);
	name = getpropstring(node, "name");
	if (strcmp(name, "SUNW,Expert3D") == 0 ||
	    strcmp(name, "SUNW,Expert3D-Lite") == 0)
d131 1
@


1.54
log
@Revert last commit.  It didn't really help and we fixed X11 instead.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.53 2008/08/11 20:56:55 kettenis Exp $	*/
a78 5
int vgafb_alloc_screen(void *, const struct wsscreen_descr *, void **,
    int *, int *, long *);
void vgafb_free_screen(void *, void *);
int vgafb_show_screen(void *, void *, int,
    void (*cb)(void *, int, int), void *);
d88 8
a95 4
	vgafb_alloc_screen,
	vgafb_free_screen,
	vgafb_show_screen,
	0 /* load_font */
d199 1
a199 1
	    RI_BSWAP | (sc->sc_console ? 0 : RI_FORCEMONO | RI_CLEAR));
a347 43
}

int
vgafb_alloc_screen(v, type, cookiep, curxp, curyp, attrp)
	void *v;
	const struct wsscreen_descr *type;
	void **cookiep;
	int *curxp, *curyp;
	long *attrp;
{
	struct vgafb_softc *sc = v;

	if (sc->sc_nscreens > 0)
		return (ENOMEM);

	*cookiep = &sc->sc_sunfb.sf_ro;
	*curyp = 0;
	*curxp = 0;
	sc->sc_sunfb.sf_ro.ri_ops.alloc_attr(&sc->sc_sunfb.sf_ro,
	    WSCOL_BLACK, WSCOL_WHITE, WSATTR_WSCOLORS, attrp);
	sc->sc_nscreens++;
	return (0);
}

void
vgafb_free_screen(v, cookie)
	void *v;
	void *cookie;
{
	struct vgafb_softc *sc = v;

	sc->sc_nscreens--;
}

int
vgafb_show_screen(v, cookie, waitok, cb, cbarg)
	void *v;
	void *cookie;
	int waitok;
	void (*cb)(void *, int, int);
	void *cbarg;
{
	return (0);
@


1.53
log
@Allow mapping mmio regions that are not page aligned.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.52 2008/03/23 12:10:53 miod Exp $	*/
d421 1
a421 9
		/* 
		 * ATI Mach64 boards have an mmio region that's
		 * typically smaller than a page and therefore may end
		 * up being not aligned to a page boundary.  Alow the
		 * whole page to be mapped and hope the firmware
		 * didn't put any resources on the same page that
		 * belong to a different device.
		 */
		if (off >= trunc_page(sc->sc_mmio_addr) &&
d424 1
a424 2
			    trunc_page(sc->sc_mmio_addr),
			    off - trunc_page(sc->sc_mmio_addr),
@


1.52
log
@Use new defines from pcidevs to match Expert3D.
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.51 2008/03/21 17:14:12 miod Exp $	*/
d421 9
a429 1
		if (off >= sc->sc_mmio_addr &&
d432 2
a433 1
			    sc->sc_mmio_addr, off - sc->sc_mmio_addr,
@


1.51
log
@Do not attach vgafb if not the console device, since the PROM will not have
initialized the device in this case.
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.50 2007/03/06 19:13:13 miod Exp $	*/
d115 4
a118 6
	{ PCI_VENDOR_INTERGRAPH, 0x108 },	/* XXX */
	{ PCI_VENDOR_INTERGRAPH, 0x140 },	/* XXX */
	{ PCI_VENDOR_INTERGRAPH, PCI_PRODUCT_INTERGRAPH_EXPERT3D },
	{ PCI_VENDOR_3DLABS,	 0x7a1 },	/* Wildcat III 6210 */
	{ PCI_VENDOR_3DLABS,	 0x7a2 },	/* Sun XVR-500 */
	{ PCI_VENDOR_3DLABS,	 0x7a3 },	/* Wildcat IV 7210 */
@


1.50
log
@Three more Expert3D-like frame buffers we shouldn't attach to yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.49 2007/01/13 21:03:23 miod Exp $	*/
d146 6
@


1.49
log
@Do not match on Expert3D and Expert3D-Lite cards, these will require a
different driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.48 2006/12/17 22:18:16 miod Exp $	*/
d118 3
@


1.48
log
@Remove unnecessary <dev/wscons/wscons_raster.h> inclusion.
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.47 2006/08/29 01:27:59 deraadt Exp $	*/
a34 1
#include <sys/buf.h>
d36 1
a36 1
#include <sys/kernel.h>
a37 1
#include <sys/device.h>
d44 1
a46 1
#include <machine/autoconf.h>
d49 2
d52 1
d56 1
a68 2
	pci_chipset_tag_t sc_pci_chip;
	int sc_has_rom;
a73 1
	int *sc_crowp, *sc_ccolp;
d114 6
d126 17
d149 1
a149 7
	    PCI_SUBCLASS(pa->pa_class) == PCI_SUBCLASS_DISPLAY_VGA) {
		extern char cpu_model[];

		/* XXX Cannot yet deal with VGA devices on Blade 1000 and family */
		if (strncmp(cpu_model, "SUNW,UltraSPARC-III",
		    strlen("SUNW,UltraSPARC-III")) == 0)
			return (0);
a150 1
	}
@


1.47
log
@XXX when we find vgapci devices on a USIII machine, fail to match
(for now, until the bugs are found.  USIII machines remain serial-only
for now); ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.46 2006/08/11 18:57:08 miod Exp $	*/
a53 1
#include <dev/wscons/wscons_raster.h>
@


1.46
log
@For non-console vgafb, force rasops to initialize it as a monochrome resource,
since we can't program the colormap anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.45 2006/05/30 19:53:31 miod Exp $	*/
d128 7
a134 1
	    PCI_SUBCLASS(pa->pa_class) == PCI_SUBCLASS_DISPLAY_VGA)
d136 1
@


1.45
log
@Sync region detection algorithm with macppc, helps some recent cards, such
as 3DLabs Permedia and Intergraph Expert3D.

Also, if no mmio region is found, attach anyway, this only prevents accelerated
X11 from starting.
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.44 2006/04/16 22:28:02 miod Exp $	*/
d172 1
a172 1
	    RI_BSWAP | (sc->sc_console ? 0 : RI_CLEAR));
d179 1
a179 1
		/* sc->sc_ofhandle = XXX */
@


1.44
log
@Remove code from an old (broken) diff of mine, which crept in in last commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.43 2006/04/09 12:22:56 matthieu Exp $	*/
d383 4
d430 1
a430 1
	for (i = PCI_MAPREG_START; i < PCI_MAPREG_END; i += 4) {
d455 7
a461 15
			if (bs <= 0x10000) {	/* mmio */
				if (hasmmio)
					continue;
				sc->sc_mmio_addr = ba;
				sc->sc_mmio_size = bs;
				hasmmio = 1;
			} else {
				if (hasmem)
					continue;
				if (bus_space_map(pa->pa_memt, ba, bs,
				    0, &sc->sc_mem_h)) {
					printf("%s: can't map mem space\n",
					    sc->sc_sunfb.sf_dev.dv_xname);
					continue;
				}
d465 27
d496 19
a514 2
	if (hasmmio == 0 || hasmem == 0 || hasio == 0) {
		printf("%s: failed to find all ports\n",
a515 1
		goto fail;
d517 1
a519 5

fail:
	if (hasmem)
		bus_space_unmap(pa->pa_memt, sc->sc_mem_h, sc->sc_mem_size);
	return (1);
@


1.43
log
@On macppc and sparc64, if allowaperture=0 only allow mmap()-ing of
the framebuffer memory in WSDISPLAYIO_MODE_DUMBFB mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.42 2005/07/17 17:13:38 miod Exp $	*/
a111 2
int defective_fb_node;

d153 3
a157 11
	if (vgafb_mapregs(sc, pa)) {
		/*
		 * If we are the console device, but can't attach,
		 * we'll let the next video device hijack the console
		 * even if it is not, from the PROMs point of view.
		 */
		if (sc->sc_console)
			defective_fb_node = sc->sc_node;
		return;
	}

d412 1
a412 1
	return (fbnode == node || defective_fb_node != 0);
@


1.42
log
@Make sure we don't reprogram the colormap upon leaving mapped mode,
if we are not the console display; prevents a stupid panic.
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.41 2005/03/15 20:19:24 miod Exp $	*/
d112 6
d155 10
a164 1
	if (vgafb_mapregs(sc, pa))
d166 1
a166 2

	sc->sc_console = vgafb_is_console(sc->sc_node);
d389 4
d422 1
a422 1
	return (fbnode == node);
@


1.41
log
@Only warn if pci_{io,mem}_find fails if the returned value is not ENOENT - empty
ranges are skipped and considered harmless.
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.40 2005/03/15 18:40:15 miod Exp $	*/
d199 5
a203 2
		if (sc->sc_mode == WSDISPLAYIO_MODE_EMUL)
			fbwscons_setcolormap(&sc->sc_sunfb, vgafb_setcolor);
@


1.40
log
@Take care of updating the PROMs view of the cursor position in the common fb
code, rather than doing this in only a subset of the fb drivers.
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.39 2005/03/07 16:44:52 miod Exp $	*/
d147 2
a151 2
	printf("\n");

d413 1
d420 6
a425 3
			if (pci_io_find(pa->pa_pc, pa->pa_tag, i,
			    &sc->sc_io_addr, &sc->sc_io_size)) {
				printf(": failed to find io at 0x%x\n", i);
d431 6
a436 3
			if (pci_mem_find(pa->pa_pc, pa->pa_tag, i,
			    &ba, &bs, NULL)) {
				printf(": failed to find mem at 0x%x\n", i);
d451 2
a452 1
					printf(": can't map mem space\n");
d463 2
a464 1
		printf(": failed to find all ports\n");
@


1.39
log
@Do not bother passing the blanking routine to fbwscons_console_init(),
as fbwscons_attach() can find it on its own.
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.38 2005/01/05 23:04:25 miod Exp $	*/
a90 1
void vgafb_updatecursor(struct rasops_info *ri);
a172 1
		sc->sc_sunfb.sf_ro.ri_updatecursor = vgafb_updatecursor;
a464 12
}

void
vgafb_updatecursor(ri)
	struct rasops_info *ri;
{
	struct vgafb_softc *sc = ri->ri_hw;

	if (sc->sc_crowp != NULL)
		*sc->sc_crowp = ri->ri_crow;
	if (sc->sc_ccolp != NULL)
		*sc->sc_ccolp = ri->ri_ccol;
@


1.38
log
@Let wsdisplay drivers return zero for WSDISPLAYIO_[GS]VIDEO ioctls - most
of the work is done in the upper layer, but they get to see the ioctl,
so don't always return an error.
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.37 2004/12/02 02:41:02 brad Exp $	*/
d175 1
a175 1
		fbwscons_console_init(&sc->sc_sunfb, -1, NULL);
@


1.37
log
@Add pci_decompose_tag() for sparc64.

From NetBSD

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.36 2004/11/30 13:23:19 miod Exp $	*/
d233 2
@


1.36
log
@Move the struct wsscreen_descr from a per-driver global to a per-instance
field of the sunfb structure. This allows multiple instances of the same driver,
but with different resolutions (such as a couple of vigra or a TGX cgsix and
a TGX+ cgsix) to use distinct wsscreen_descr structures featuring different
resolution information.

Doing this allows more wsscreen_descr fiddling inside the sparc* fb api,
and results in some code shrinkage (about 4KB on sparc GENERIC).

[file excluded in previous commit by mistake. spotted by claudio@@]
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.35 2004/08/10 21:57:51 millert Exp $	*/
d228 1
a228 1
		sel->pc_func = PCITAG_FUNC(sc->sc_pcitag);
@


1.35
log
@Print the newline after vgafb_mapregs(), not before since vgafb_mapregs()
may print diagostic messgaes on error.  OK henning@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.34 2003/06/16 21:46:23 miod Exp $	*/
a77 13
struct wsscreen_descr vgafb_stdscreen = {
	"std",
};

const struct wsscreen_descr *vgafb_scrlist[] = {
	&vgafb_stdscreen,
	/* XXX other formats? */
};

struct wsscreen_list vgafb_screenlist = {
	sizeof(vgafb_scrlist) / sizeof(struct wsscreen_descr *), vgafb_scrlist
};

a141 1
	struct wsemuldisplaydev_attach_args waa;
a170 5
	vgafb_stdscreen.capabilities = sc->sc_sunfb.sf_ro.ri_caps;
	vgafb_stdscreen.nrows = sc->sc_sunfb.sf_ro.ri_rows;
	vgafb_stdscreen.ncols = sc->sc_sunfb.sf_ro.ri_cols;
	vgafb_stdscreen.textops = &sc->sc_sunfb.sf_ro.ri_ops;

d175 1
a175 2
		fbwscons_console_init(&sc->sc_sunfb, &vgafb_stdscreen, -1,
		    NULL);
d180 1
a180 5
	waa.console = sc->sc_console;
	waa.scrdata = &vgafb_screenlist;
	waa.accessops = &vgafb_accessops;
	waa.accesscookie = sc;
	config_found(self, &waa, wsemuldisplaydevprint);
@


1.34
log
@Nuke a few more data and code superseded by the fb api.
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.33 2003/06/16 20:47:04 miod Exp $	*/
a161 2
	printf("\n");

d164 2
@


1.33
log
@Adapt to the fbxxx() API.

tested by matthieu@@, krw@@ and I on various hardware.
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.32 2003/06/02 20:02:49 jason Exp $	*/
a79 5
	0, 0,	/* will be filled in -- XXX shouldn't, it's global. */
	NULL,
	0, 0,
	WSSCREEN_UNDERLINE | WSSCREEN_HILIT |
	WSSCREEN_REVERSE | WSSCREEN_WSCOLORS
a155 1
	long defattr;
a188 2
	sc->sc_sunfb.sf_ro.ri_ops.alloc_attr(&sc->sc_sunfb.sf_ro,
	    WSCOL_BLACK, WSCOL_WHITE, WSATTR_WSCOLORS, &defattr);
@


1.32
log
@nuke terms 3 & 4
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.31 2002/12/25 01:23:04 miod Exp $	*/
d56 1
d59 1
a59 1
	struct device sc_dev;
a60 1
	int sc_width, sc_height, sc_depth, sc_linebytes;
a74 1
	struct rasops_info sc_rasops;
d108 1
a108 3
void vgafb_setcolor(struct vgafb_softc *, unsigned int,
    u_int8_t, u_int8_t, u_int8_t);
void vgafb_restore_default_colors(struct vgafb_softc *);
a109 1
static int a2int(char *, int);
d168 1
a168 17
	sc->sc_depth = getpropint(sc->sc_node, "depth", -1);
	if (sc->sc_depth == -1)
		sc->sc_depth = 8;

	sc->sc_linebytes = getpropint(sc->sc_node, "linebytes", -1);
	if (sc->sc_linebytes == -1)
		sc->sc_linebytes = 1152;

	sc->sc_height = getpropint(sc->sc_node, "height", -1);
	if (sc->sc_height == -1)
		sc->sc_height = 900;

	sc->sc_width = getpropint(sc->sc_node, "width", -1);
	if (sc->sc_width == -1)
		sc->sc_width = 1152;

	sc->sc_console = vgafb_is_console(sc->sc_node);
d173 9
a181 9
	if (sc->sc_depth == 24) {
		/* Depth is 24, but rasops really wants bpp */
		sc->sc_rasops.ri_depth = 32;
		/* PROM gets linebytes wrong, ignore it. */
		sc->sc_rasops.ri_stride =
		    (sc->sc_rasops.ri_depth / 8) * sc->sc_width;
	} else {
		sc->sc_rasops.ri_depth = sc->sc_depth;
		sc->sc_rasops.ri_stride = sc->sc_linebytes;
d184 1
a184 2
	sc->sc_rasops.ri_flg = RI_CENTER | RI_BSWAP;
	sc->sc_rasops.ri_bits = (void *)bus_space_vaddr(sc->sc_mem_t,
d186 10
a195 12
	sc->sc_rasops.ri_width = sc->sc_width;
	sc->sc_rasops.ri_height = sc->sc_height;
	sc->sc_rasops.ri_hw = sc;

	rasops_init(&sc->sc_rasops,
	    a2int(getpropstring(optionsnode, "screen-#rows"), 34),
	    a2int(getpropstring(optionsnode, "screen-#columns"), 80));

	vgafb_stdscreen.nrows = sc->sc_rasops.ri_rows;
	vgafb_stdscreen.ncols = sc->sc_rasops.ri_cols;
	vgafb_stdscreen.textops = &sc->sc_rasops.ri_ops;
	sc->sc_rasops.ri_ops.alloc_attr(&sc->sc_rasops,
a197 2
	printf("\n");

d200 6
a205 21

		if (sc->sc_depth == 8) {
			vgafb_restore_default_colors(sc);
		} else {
			/* fix color choice */
			wscol_white = 0;
			wscol_black = 255;
			wskernel_bg = 0;
			wskernel_fg = 255;
		}

		if (romgetcursoraddr(&sc->sc_crowp, &sc->sc_ccolp))
			sc->sc_ccolp = sc->sc_crowp = NULL;
		if (sc->sc_ccolp != NULL)
			sc->sc_rasops.ri_ccol = *sc->sc_ccolp;
		if (sc->sc_crowp != NULL)
			sc->sc_rasops.ri_crow = *sc->sc_crowp;
		sc->sc_rasops.ri_updatecursor = vgafb_updatecursor;

		wsdisplay_cnattach(&vgafb_stdscreen, &sc->sc_rasops,
		    sc->sc_rasops.ri_ccol, sc->sc_rasops.ri_crow, defattr);
a212 2

	return;
d233 2
a234 4
		if (sc->sc_mode == WSDISPLAYIO_MODE_EMUL &&
		    sc->sc_depth == 8) {
			vgafb_restore_default_colors(sc);
		}
d238 3
a240 3
		wdf->height = sc->sc_height;
		wdf->width  = sc->sc_width;
		wdf->depth  = sc->sc_rasops.ri_depth;
d244 1
a244 1
		*(u_int *)data = sc->sc_rasops.ri_stride;
d335 3
a337 3
vgafb_setcolor(sc, index, r, g, b)
	struct vgafb_softc *sc;
	unsigned int index;
d340 2
a347 17
void
vgafb_restore_default_colors(struct vgafb_softc *sc)
{
	int i;

	for (i = 0; i < 256; i++) {
		const u_char *color;

		color = &rasops_cmap[i * 3];
		vgafb_setcolor(sc, i, color[0], color[1], color[2]);
	}
	/* compensate for BoW palette */
	vgafb_setcolor(sc, WSCOL_BLACK, 0, 0, 0);
	vgafb_setcolor(sc, 255, 0, 0, 0);	/* cursor */
	vgafb_setcolor(sc, WSCOL_WHITE, 255, 255, 255);
}

d361 1
a361 1
	*cookiep = &sc->sc_rasops;
d364 1
a364 1
	sc->sc_rasops.ri_ops.alloc_attr(&sc->sc_rasops,
a424 12
}

static int
a2int(char *cp, int deflt)
{
	int i = 0;

	if (*cp == '\0')
		return (deflt);
	while (*cp != '\0')
		i = i * 10 + *cp++ - '0';
	return (i);
@


1.31
log
@Initialize color palette from rasops settings (from sparc) rather than
from incorrect values, and restore it after X11 use (from macppc).
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.30 2002/12/10 02:12:33 miod Exp $	*/
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Jason L. Wright
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.30
log
@Register as the "std" wscons device, not "sun". This is consistent with other
frame buffers, and produces less confusing dmesg output.
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.29 2002/11/09 22:51:48 miod Exp $	*/
d116 1
d232 1
a232 9
			vgafb_setcolor(sc, WSCOL_BLACK, 0, 0, 0);
			vgafb_setcolor(sc, 255, 0, 0, 0);
			vgafb_setcolor(sc, WSCOL_RED, 255, 0, 0);
			vgafb_setcolor(sc, WSCOL_GREEN, 0, 255, 0);
			vgafb_setcolor(sc, WSCOL_BROWN, 154, 85, 46);
			vgafb_setcolor(sc, WSCOL_BLUE, 0, 0, 255);
			vgafb_setcolor(sc, WSCOL_MAGENTA, 255, 255, 0);
			vgafb_setcolor(sc, WSCOL_CYAN, 0, 255, 255);
			vgafb_setcolor(sc, WSCOL_WHITE, 255, 255, 255);
d280 4
d393 17
@


1.29
log
@Instead of relying on uvm_useracc(), get a false sense of security, and
do not check copyin() result, take care and properly handle copyin() failure.

This was not harmful, but a bit more correctness never harms.
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.28 2002/09/15 14:29:29 miod Exp $	*/
d85 1
a85 1
	"sun",
@


1.28
log
@Fix color choices to match wsemul_sun requirements.
Tested by and ok matthieu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.27 2002/09/10 03:18:59 jason Exp $	*/
d360 2
a361 1
	int i;
d366 7
a372 7
	if (!uvm_useracc(cm->red, cm->count, B_READ) ||
	    !uvm_useracc(cm->green, cm->count, B_READ) ||
	    !uvm_useracc(cm->blue, cm->count, B_READ))
		return (EFAULT);
	copyin(cm->red, &sc->sc_cmap_red[index], count);
	copyin(cm->green, &sc->sc_cmap_green[index], count);
	copyin(cm->blue, &sc->sc_cmap_blue[index], count);
d379 2
a380 1
		OF_call_method("color!", sc->sc_ofhandle, 4, 0, *r, *g, *b, index);
@


1.27
log
@Register more wsscreen properties to take advantage of wsemul_sun changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.26 2002/08/19 20:16:04 jason Exp $	*/
d223 1
a223 1
	    WSCOL_WHITE, WSCOL_BLACK, WSATTR_WSCOLORS, &defattr);
d232 1
a232 1
			vgafb_setcolor(sc, 255, 255, 255, 255);
d240 6
d413 1
a413 1
	    WSCOL_WHITE, WSCOL_BLACK, WSATTR_WSCOLORS, attrp);
@


1.26
log
@Take advantage of rasops.updatecursor to keep the prom cursor up to date
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.25 2002/08/02 16:13:07 millert Exp $	*/
d89 1
@


1.25
log
@Do correct bounds checking in get/set/put cmap routines.  A few of
these check were already OK but have been modified for consistency.
Problem found by Silvio Cesare.
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.24 2002/07/30 17:55:56 jason Exp $	*/
d81 1
d115 1
a115 1

a226 2
		int *ccolp, *crowp;

d241 8
a248 6
		if (romgetcursoraddr(&crowp, &ccolp))
			ccolp = crowp = NULL;
		if (ccolp != NULL)
			sc->sc_rasops.ri_ccol = *ccolp;
		if (crowp != NULL)
			sc->sc_rasops.ri_crow = *crowp;
d550 12
@


1.24
log
@simplify vgafb_mmap()
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.23 2002/07/25 19:19:55 jason Exp $	*/
d330 3
d350 2
a351 2
	int index = cm->index;
	int count = cm->count;
d355 1
a355 2
	if (cm->index >= 256 || cm->count > 256 ||
	    (cm->index + cm->count) > 256)
@


1.23
log
@There's no need to override the default mapping to big endian now that rasops8 handles byte swapping itself.
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.22 2002/07/24 15:36:38 jason Exp $	*/
d453 1
a453 2

		return (-1);
d459 1
a459 4
		return (-1);

	default:
		return (-1);
@


1.22
log
@- don't need mmio or io registers mapped for console use
- can't map expansion rom this way, remove it until we find a safe way
- use less magic constants
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.21 2002/06/11 22:56:37 jason Exp $	*/
d206 1
a206 1
	sc->sc_rasops.ri_flg = RI_CENTER;
d528 2
a529 2
				if (bus_space_map2(pa->pa_memt, SBUS_BUS_SPACE,
				    ba, bs, 0, NULL, &sc->sc_mem_h)) {
@


1.21
log
@Fix (include sys/pciio.h)
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.20 2002/06/11 22:53:09 jason Exp $	*/
d70 3
a72 3
	bus_space_handle_t sc_mem_h, sc_io_h, sc_mmio_h;
	bus_addr_t sc_io_addr, sc_mem_addr, sc_mmio_addr, sc_rom_addr;
	bus_size_t sc_io_size, sc_mem_size, sc_mmio_size, sc_rom_size;
a73 1
	u_int8_t *sc_rom_ptr;
a435 2
	paddr_t pa;
	vaddr_t va;
a453 9
		if (sc->sc_rom_ptr != NULL &&
		    off >= sc->sc_rom_addr &&
		    off < sc->sc_rom_addr + sc->sc_rom_size) {
			off -= sc->sc_rom_addr;
			va = ((vaddr_t)sc->sc_rom_ptr) + off;
			if (pmap_extract(pmap_kernel(), va, &pa) == FALSE)
				return (-1);
			return (pa);
		}
a489 81
#define	PCI_ROMBAR_REG		0x30
#define	PCI_ROMBAR_ADDR(mr)						\
	    ((mr) & PCI_ROMBAR_ADDR_MASK)
#define	PCI_ROMBAR_SIZE(mr)						\
	    (PCI_ROMBAR_ADDR(mr) & -PCI_ROMBAR_ADDR(mr))
#define	PCI_ROMBAR_ADDR_ENABLE	0x00000001
#define	PCI_ROMBAR_ADDR_MASK	0xfffff800

/* offsets into the rom space */
#define	PCI_ROM_OFF_MAGIC0	0x0
#define	PCI_ROM_OFF_MAGIC1	0x1

/* rom header magic numbers */
#define	PCI_ROM_MAGIC0		0x55
#define	PCI_ROM_MAGIC1		0xaa

int
vgafb_rommap(sc, pa)
	struct vgafb_softc *sc;
	struct pci_attach_args *pa;
{
	bus_space_handle_t bh;
	u_int32_t origaddr, address, mask, size, i;
	u_int8_t *romptr, *p;
	int s;

	s = splhigh();
	origaddr = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_ROMBAR_REG);
	pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_ROMBAR_REG,
	    PCI_ROMBAR_ADDR_MASK);
	mask = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_ROMBAR_REG);
	pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_ROMBAR_REG, origaddr);
	address = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_ROMBAR_REG);
	splx(s);

	/* No ROM supported? */
	if (mask == 0)
		return (0);

	address &= PCI_ROMBAR_ADDR_MASK;

	/* Turn on the address decoder please... */
	pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_ROMBAR_REG,
	    address | PCI_ROMBAR_ADDR_ENABLE);

	size = PCI_ROMBAR_SIZE(mask);

	if (bus_space_map(pa->pa_memt, address, size, 0, &bh)) {
		pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_ROMBAR_REG, origaddr);
		return (0);
	}

	if ((bus_space_read_1(pa->pa_memt, bh, PCI_ROM_OFF_MAGIC0) !=
	    PCI_ROM_MAGIC0) ||
	    (bus_space_read_1(pa->pa_memt, bh, PCI_ROM_OFF_MAGIC1) !=
	    PCI_ROM_MAGIC1)) {
		/* ROM is supported but not present */
		bus_space_unmap(pa->pa_memt, bh, size);
		pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_ROMBAR_REG, origaddr);
		return (0);
	}

	romptr = (u_int8_t *)malloc(size, M_DEVBUF, M_NOWAIT);
	if (romptr == NULL) {
		bus_space_unmap(pa->pa_memt, bh, size);
		pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_ROMBAR_REG, origaddr);
		return (0);
	}

	for (p = romptr, i = 0; i < size; i++)
		*p++ = bus_space_read_1(pa->pa_memt, bh, i);

	sc->sc_rom_ptr = romptr;
	sc->sc_rom_addr = address;
	sc->sc_rom_size = size;

	bus_space_unmap(pa->pa_memt, bh, size);
	pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_ROMBAR_REG, origaddr);
	return (0);
}

d500 1
a500 3
	vgafb_rommap(sc, pa);

	for (i = 0x10; i <= 0x18; i += 4) {
a509 5
			if (bus_space_map(pa->pa_iot, sc->sc_io_addr,
			    sc->sc_io_size, 0, &sc->sc_io_h)) {
				printf(": can't map io space\n");
				continue;
			}
a521 5
				if (bus_space_map(pa->pa_memt, ba, bs, 0,
				    &sc->sc_mmio_h)) {
					printf(": can't map mmio space\n");
					continue;
				}
a547 4
	if (hasio)
		bus_space_unmap(pa->pa_iot, sc->sc_io_h, sc->sc_io_size);
	if (hasmmio)
		bus_space_unmap(pa->pa_memt, sc->sc_mmio_h, sc->sc_mmio_size);
@


1.20
log
@s/pcitag/sc_pcitag so it compiles (sorry matthieu)
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.19 2002/06/11 15:33:27 matthieu Exp $	*/
d47 1
@


1.19
log
@add a new ioctl to wscons (currently implemented  only on sparc64)
`that returns the bus:dev:func PCI id of the device.
ok jason@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.18 2002/06/04 21:50:07 jason Exp $	*/
d68 1
a68 1
	pcitag_t pcitag;
@


1.18
log
@Convert vgafb from rcons to rasops
If depth is 24, select rasops32 (and make sure the stride is right)
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.17 2002/04/15 17:43:30 jason Exp $	*/
d68 1
d172 1
d271 1
d290 1
a290 1

d299 7
@


1.17
log
@Since XFree doesn't try to remap things behind our backs anymore, simplify
the driver a bit (mainly don't reprobe the pci address for every call to
vgafb_mmap()).
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.16 2002/04/08 17:49:42 jason Exp $	*/
d59 1
a59 1
#include <dev/rcons/raster.h>
a62 1
	struct sbusdev sc_sd;
a73 2
	struct rcons sc_rcons;
	struct raster sc_raster;
d79 1
a79 11
};

struct wsdisplay_emulops vgafb_emulops = {
	rcons_cursor,
	rcons_mapchar,
	rcons_putchar,
	rcons_copycols,
	rcons_erasecols,
	rcons_copyrows,
	rcons_eraserows,
	rcons_alloc_attr
d193 9
a201 12
	sc->sc_rcons.rc_sp = &sc->sc_raster;
	sc->sc_raster.width = sc->sc_width;
	sc->sc_raster.height = sc->sc_height;
	sc->sc_raster.depth = sc->sc_depth;
	sc->sc_raster.linelongs = sc->sc_linebytes / 4;
	sc->sc_raster.pixels = (void *)bus_space_vaddr(sc->sc_mem_t, sc->sc_mem_h);

	if (sc->sc_console == 0 ||
	    romgetcursoraddr(&sc->sc_rcons.rc_crowp, &sc->sc_rcons.rc_ccolp)) {
		sc->sc_rcons.rc_crow = sc->sc_rcons.rc_ccol = -1;
		sc->sc_rcons.rc_crowp = &sc->sc_rcons.rc_crow;
		sc->sc_rcons.rc_ccolp = &sc->sc_rcons.rc_ccol;
d204 16
a219 12
	sc->sc_rcons.rc_maxcol =
	    a2int(getpropstring(optionsnode, "screen-#columns"), 80);
	sc->sc_rcons.rc_maxrow =
	    a2int(getpropstring(optionsnode, "screen-#rows"), 34);

	rcons_init(&sc->sc_rcons,
	    sc->sc_rcons.rc_maxrow, sc->sc_rcons.rc_maxcol);

	vgafb_stdscreen.nrows = sc->sc_rcons.rc_maxrow;
	vgafb_stdscreen.ncols = sc->sc_rcons.rc_maxcol;
	vgafb_stdscreen.textops = &vgafb_emulops;
	rcons_alloc_attr(&sc->sc_rcons, 0, 0, 0, &defattr);
d224 2
d227 21
a247 11
		vgafb_setcolor(sc, WSCOL_BLACK, 0, 0, 0);
		vgafb_setcolor(sc, 255, 255, 255, 255);
		vgafb_setcolor(sc, WSCOL_RED, 255, 0, 0);
		vgafb_setcolor(sc, WSCOL_GREEN, 0, 255, 0);
		vgafb_setcolor(sc, WSCOL_BROWN, 154, 85, 46);
		vgafb_setcolor(sc, WSCOL_BLUE, 0, 0, 255);
		vgafb_setcolor(sc, WSCOL_MAGENTA, 255, 255, 0);
		vgafb_setcolor(sc, WSCOL_CYAN, 0, 255, 255);
		vgafb_setcolor(sc, WSCOL_WHITE, 255, 255, 255);
		wsdisplay_cnattach(&vgafb_stdscreen, &sc->sc_rcons,
		    *sc->sc_rcons.rc_ccolp, *sc->sc_rcons.rc_crowp, defattr);
d281 1
a281 1
		wdf->depth  = sc->sc_depth;
d285 1
a285 1
		*(u_int *)data = sc->sc_linebytes;
d389 5
a393 4
	*cookiep = &sc->sc_rcons;
	*curyp = *sc->sc_rcons.rc_crowp;
	*curxp = *sc->sc_rcons.rc_ccolp;
	rcons_alloc_attr(&sc->sc_rcons, 0, 0, 0, attrp);
d623 1
a623 2
	    			    ba, bs, 0, NULL,
				    &sc->sc_mem_h)) {
@


1.16
log
@Credit DARPA/USAF appropriately.
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.15 2002/04/01 19:50:53 jason Exp $	*/
a72 2
	pcitag_t sc_pci_tag;
	int sc_io_cf, sc_mmio_cf, sc_mem_cf;
d181 2
a182 2
	sc->sc_pci_chip = pa->pa_pc;
	sc->sc_pci_tag = pa->pa_tag;
a424 2
	bus_addr_t ba;
	bus_size_t bs;
d433 4
a436 4
		if ((pci_mem_find(sc->sc_pci_chip, sc->sc_pci_tag,
		    sc->sc_mem_cf, &ba, &bs, NULL) == 0) &&
		    (off >= ba) && (off < (ba + bs)))
			return (bus_space_mmap(sc->sc_mem_t, ba, off - ba,
d439 4
a442 4
		if ((pci_mem_find(sc->sc_pci_chip, sc->sc_pci_tag,
		    sc->sc_mmio_cf, &ba, &bs, NULL) == 0) &&
		    (off >= ba) && (off < (ba + bs)))
			return (bus_space_mmap(sc->sc_mem_t, ba, off - ba,
a597 1
			sc->sc_io_cf = i;
d600 1
a600 1
			/* Memory mapping... framebuffer or mmio? */
a616 1
				sc->sc_mmio_cf = i;
a628 1
				sc->sc_mem_cf = i;
a637 3

	sc->sc_mem_t = pa->pa_memt;
	sc->sc_io_t = pa->pa_iot;
@


1.15
log
@Remove all traces of VGAFB_ALLOW_NATIVE.
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.14 2002/03/31 17:34:15 jason Exp $	*/
d32 5
@


1.14
log
@add a new mode to wsdisplay, WSDISPLAYIO_MODE_DUMBFB.  This mode is
functionally equivalent what used to be WSDISPLAYIO_MODE_MAPPED, which now
means a "native" mapping.
vgafb_mmap() returns pci relative mappings in WSDISPLAYIO_MODE_MAPPED and
linear framebuffer mappings in WSDISPLAYIO_MODE_DUMBFB
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.13 2002/03/30 00:08:14 jason Exp $	*/
a54 2

#undef VGAFB_ALLOW_NATIVE
@


1.13
log
@Don't honor native accesses unless VGAFB_ALLOW_NATIVE is defined (this is
a temporary workaround that will be backed out when more work is done
elsewhere)
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.12 2002/03/28 04:28:38 jason Exp $	*/
d77 1
d273 3
a423 1
#ifdef VGAFB_ALLOW_NATIVE
d426 2
a427 1
#endif
d432 24
a455 8
#ifdef VGAFB_ALLOW_NATIVE
	/* See if this is a native mapping of pixel memory */
	if ((pci_mem_find(sc->sc_pci_chip, sc->sc_pci_tag, sc->sc_mem_cf,
	    &ba, &bs, NULL) == 0) &&
	    (off >= ba) && (off < (ba + bs))) {
		return (bus_space_mmap(sc->sc_mem_t, ba, off - ba, prot,
		    BUS_SPACE_MAP_LINEAR));
	}
d457 5
a461 8
	/* See if this is a native mapping of memory mapped i/o */
	if ((pci_mem_find(sc->sc_pci_chip, sc->sc_pci_tag, sc->sc_mmio_cf,
	    &ba, &bs, NULL) == 0) &&
	    (off >= ba) && (off < (ba + bs))) {
		return (bus_space_mmap(sc->sc_mem_t, ba, off - ba, prot,
		    BUS_SPACE_MAP_LINEAR));
	}
#endif
d463 2
a464 16
	/* Lastly, this might be a request for a "dumb" framebuffer map */
	if (off >= 0 && off < sc->sc_mem_size) {
		return (bus_space_mmap(sc->sc_mem_t, sc->sc_mem_addr, off, prot,
		    BUS_SPACE_MAP_LINEAR));
	}

#ifdef VGAFB_ALLOW_NATIVE
	/* Don't allow mapping of the shadow rom right now... needs work */
	if (sc->sc_rom_ptr != NULL &&
	    off >= sc->sc_rom_addr &&
	    off < sc->sc_rom_addr + sc->sc_rom_size) {
		off -= sc->sc_rom_addr;
		va = ((vaddr_t)sc->sc_rom_ptr) + off;
		if (pmap_extract(pmap_kernel(), va, &pa) == FALSE)
			return (-1);
		return (pa);
a465 1
#endif
@


1.12
log
@- recheck the PCI BAR's during mmap: XFree86 doesn't like the prom mappings
so rather than deal with it, it remaps things.
- turn off access to the rom... this may need rethinking
(both accelerated X and dumb framebuffer X work because the offsets will not
overlap).
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.11 2002/03/27 05:00:12 jason Exp $	*/
d56 2
d420 1
d423 1
d428 1
d444 1
d452 1
a452 1
#if 0
@


1.11
log
@Avoid using bus_space_map2() on the rom (was too lazy to deal with endian =),
instead use bus_space_map() and bus_space_read_1() to gaurantee correct
endian; speed isn't an issue here (well, as long as some joker doesn't ship
a 16MB vga rom...)
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.10 2002/03/27 01:15:12 jason Exp $	*/
d67 3
d177 2
d418 2
a419 2
	paddr_t pa;
	vaddr_t va;
d424 17
d446 2
d457 1
d591 1
d611 1
d624 1
@


1.10
log
@Make a shadow copy of the bios rom (if available) and make it available via mmap
Also, don't hardcode the length of the pixel memory in vgafb_mmap(), use the size provided by pci_mem_find.
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.9 2002/03/27 01:00:48 jason Exp $	*/
d67 1
a67 1
	u_int32_t *sc_rom_ptr;
d480 2
a481 1
	u_int32_t origaddr, address, mask, size, *romptr, *p, i;
d505 1
a505 2
	if (bus_space_map2(pa->pa_memt, SBUS_BUS_SPACE, address, size, 0,
	    NULL, &bh)) {
d520 1
a520 1
	romptr = (u_int32_t *)malloc(size, M_DEVBUF, M_NOWAIT);
d527 2
a528 2
	for (p = romptr, i = 0; i < size; i += 4, p++)
		*p = bus_space_read_4(pa->pa_memt, bh, i);
@


1.9
log
@bus_space_mmap wants the paddr not the handle
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.8 2002/03/26 01:28:18 jason Exp $	*/
d65 4
a68 2
	bus_addr_t sc_io_addr, sc_mem_addr, sc_mmio_addr;
	bus_size_t sc_io_size, sc_mem_size, sc_mmio_size;
d106 1
d413 2
d419 1
a419 1
	if (off >= 0 && off < 0x800000) {
d424 10
d458 81
d548 2
@


1.8
log
@Map all of the io/mem spaces provided
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.7 2002/03/14 03:16:00 millert Exp $	*/
d415 1
a415 1
		return (bus_space_mmap(sc->sc_mem_t, sc->sc_mem_h, off, prot,
@


1.7
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.6 2002/03/14 01:26:44 millert Exp $	*/
d62 5
a66 3
	bus_space_tag_t sc_bt;
	bus_space_handle_t sc_bh;
	bus_addr_t sc_paddr;
d103 1
a168 1
	bus_size_t memsize;
d191 2
a192 11
	if (pci_mem_find(pa->pa_pc, pa->pa_tag, 0x10,
	    &sc->sc_paddr, &memsize, NULL)) {
		printf(": can't find mem space\n");
		goto fail;
	}
	if (bus_space_map2(pa->pa_memt, SBUS_BUS_SPACE,
	    sc->sc_paddr, memsize, 0, NULL, &sc->sc_bh)) {
		printf(": can't map mem space\n");
		goto fail;
	}
	sc->sc_bt = pa->pa_memt;
d199 1
a199 1
	sc->sc_raster.pixels = (void *)sc->sc_bh;
a244 1
fail:
d415 1
a415 1
		return (bus_space_mmap(sc->sc_bt, sc->sc_paddr, off, prot,
d441 81
@


1.6
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.5 2002/02/08 16:46:26 jason Exp $	*/
d105 2
a106 2
int vgafb_show_screen __P((void *, void *, int,
    void (*cb)(void *, int, int), void *));
@


1.5
log
@vagfb_setcolor() needs to enter entries into the software copy of the
palette so that it can be restored correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.4 2002/02/05 18:34:39 jason Exp $	*/
d101 4
a104 4
int vgafb_ioctl __P((void *, u_long, caddr_t, int, struct proc *));
int vgafb_alloc_screen __P((void *, const struct wsscreen_descr *, void **,
    int *, int *, long *));
void vgafb_free_screen __P((void *, void *));
d106 7
a112 7
    void (*cb) __P((void *, int, int)), void *));
paddr_t vgafb_mmap __P((void *, off_t, int));
int vgafb_is_console __P((int));
int vgafb_getcmap __P((struct vgafb_softc *, struct wsdisplay_cmap *));
int vgafb_putcmap __P((struct vgafb_softc *, struct wsdisplay_cmap *));
void vgafb_setcolor __P((struct vgafb_softc *, unsigned int,
    u_int8_t, u_int8_t, u_int8_t));
d114 1
a114 1
static int a2int __P((char *, int));
d125 2
a126 2
int	vgafbmatch	__P((struct device *, void *, void *));
void	vgafbattach	__P((struct device *, struct device *, void *));
d405 1
a405 1
	void (*cb) __P((void *, int, int));
@


1.5.2.1
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d101 12
a112 12
int vgafb_ioctl(void *, u_long, caddr_t, int, struct proc *);
int vgafb_alloc_screen(void *, const struct wsscreen_descr *, void **,
    int *, int *, long *);
void vgafb_free_screen(void *, void *);
int vgafb_show_screen(void *, void *, int,
    void (*cb)(void *, int, int), void *);
paddr_t vgafb_mmap(void *, off_t, int);
int vgafb_is_console(int);
int vgafb_getcmap(struct vgafb_softc *, struct wsdisplay_cmap *);
int vgafb_putcmap(struct vgafb_softc *, struct wsdisplay_cmap *);
void vgafb_setcolor(struct vgafb_softc *, unsigned int,
    u_int8_t, u_int8_t, u_int8_t);
d114 1
a114 1
static int a2int(char *, int);
d125 2
a126 2
int	vgafbmatch(struct device *, void *, void *);
void	vgafbattach(struct device *, struct device *, void *);
d405 1
a405 1
	void (*cb)(void *, int, int);
@


1.5.2.2
log
@Sync the SMP branch with 3.3
@
text
@a31 5
 *
 * Effort sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F30602-01-2-0537.
 *
a41 1
#include <sys/pciio.h>
d54 1
a54 1
#include <dev/rasops/rasops.h>
d58 1
d62 5
a66 8
	bus_space_tag_t sc_mem_t;
	bus_space_tag_t sc_io_t;
	pcitag_t sc_pcitag;
	bus_space_handle_t sc_mem_h;
	bus_addr_t sc_io_addr, sc_mem_addr, sc_mmio_addr;
	bus_size_t sc_io_size, sc_mem_size, sc_mmio_size;
	pci_chipset_tag_t sc_pci_chip;
	int sc_has_rom;
a67 1
	u_int sc_mode;
d71 11
a81 2
	struct rasops_info sc_rasops;
	int *sc_crowp, *sc_ccolp;
d85 1
a85 1
	"std",
a88 1
	WSSCREEN_UNDERLINE | WSSCREEN_HILIT |
a100 2
int vgafb_mapregs(struct vgafb_softc *, struct pci_attach_args *);
int vgafb_rommap(struct vgafb_softc *, struct pci_attach_args *);
d113 1
a113 2
void vgafb_restore_default_colors(struct vgafb_softc *);
void vgafb_updatecursor(struct rasops_info *ri);
d166 1
a168 2
	sc->sc_mem_t = pa->pa_memt;
	sc->sc_io_t = pa->pa_iot;
a169 1
	sc->sc_pcitag = pa->pa_tag;
d189 11
a199 2
	if (vgafb_mapregs(sc, pa))
		return;
d201 12
a212 9
	if (sc->sc_depth == 24) {
		/* Depth is 24, but rasops really wants bpp */
		sc->sc_rasops.ri_depth = 32;
		/* PROM gets linebytes wrong, ignore it. */
		sc->sc_rasops.ri_stride =
		    (sc->sc_rasops.ri_depth / 8) * sc->sc_width;
	} else {
		sc->sc_rasops.ri_depth = sc->sc_depth;
		sc->sc_rasops.ri_stride = sc->sc_linebytes;
d215 12
a226 16
	sc->sc_rasops.ri_flg = RI_CENTER | RI_BSWAP;
	sc->sc_rasops.ri_bits = (void *)bus_space_vaddr(sc->sc_mem_t,
	    sc->sc_mem_h);
	sc->sc_rasops.ri_width = sc->sc_width;
	sc->sc_rasops.ri_height = sc->sc_height;
	sc->sc_rasops.ri_hw = sc;

	rasops_init(&sc->sc_rasops,
	    a2int(getpropstring(optionsnode, "screen-#rows"), 34),
	    a2int(getpropstring(optionsnode, "screen-#columns"), 80));

	vgafb_stdscreen.nrows = sc->sc_rasops.ri_rows;
	vgafb_stdscreen.ncols = sc->sc_rasops.ri_cols;
	vgafb_stdscreen.textops = &sc->sc_rasops.ri_ops;
	sc->sc_rasops.ri_ops.alloc_attr(&sc->sc_rasops,
	    WSCOL_BLACK, WSCOL_WHITE, WSATTR_WSCOLORS, &defattr);
d232 11
a242 21

		if (sc->sc_depth == 8) {
			vgafb_restore_default_colors(sc);
		} else {
			/* fix color choice */
			wscol_white = 0;
			wscol_black = 255;
			wskernel_bg = 0;
			wskernel_fg = 255;
		}

		if (romgetcursoraddr(&sc->sc_crowp, &sc->sc_ccolp))
			sc->sc_ccolp = sc->sc_crowp = NULL;
		if (sc->sc_ccolp != NULL)
			sc->sc_rasops.ri_ccol = *sc->sc_ccolp;
		if (sc->sc_crowp != NULL)
			sc->sc_rasops.ri_crow = *sc->sc_crowp;
		sc->sc_rasops.ri_updatecursor = vgafb_updatecursor;

		wsdisplay_cnattach(&vgafb_stdscreen, &sc->sc_rasops,
		    sc->sc_rasops.ri_ccol, sc->sc_rasops.ri_crow, defattr);
d252 1
a264 1
	struct pcisel *sel;
a269 7
	case WSDISPLAYIO_SMODE:
		sc->sc_mode = *(u_int *)data;
		if (sc->sc_mode == WSDISPLAYIO_MODE_EMUL &&
		    sc->sc_depth == 8) {
			vgafb_restore_default_colors(sc);
		}
		break;
d274 1
a274 1
		wdf->depth  = sc->sc_rasops.ri_depth;
d278 1
a278 1
		*(u_int *)data = sc->sc_rasops.ri_stride;
d280 1
a280 1
		
a289 7
	case WSDISPLAYIO_GPCIID:
		sel = (struct pcisel *)data;
		sel->pc_bus = PCITAG_BUS(sc->sc_pcitag);
		sel->pc_dev = PCITAG_DEV(sc->sc_pcitag);
		sel->pc_func = PCITAG_FUNC(sc->sc_pcitag);
		break;

a312 3
	if (index >= 256 || count > 256 - index)
		return (EINVAL);

d330 3
a332 4
	u_int index = cm->index;
	u_int count = cm->count;
	u_int i;
	int error;
d335 2
a336 1
	if (index >= 256 || count > 256 - index)
d338 7
a344 7

	if ((error = copyin(cm->red, &sc->sc_cmap_red[index], count)) != 0)
		return (error);
	if ((error = copyin(cm->green, &sc->sc_cmap_green[index], count)) != 0)
		return (error);
	if ((error = copyin(cm->blue, &sc->sc_cmap_blue[index], count)) != 0)
		return (error);
d351 1
a351 2
		OF_call_method("color!", sc->sc_ofhandle, 4, 0, *r, *g, *b,
		    index);
a368 17
void
vgafb_restore_default_colors(struct vgafb_softc *sc)
{
	int i;

	for (i = 0; i < 256; i++) {
		const u_char *color;

		color = &rasops_cmap[i * 3];
		vgafb_setcolor(sc, i, color[0], color[1], color[2]);
	}
	/* compensate for BoW palette */
	vgafb_setcolor(sc, WSCOL_BLACK, 0, 0, 0);
	vgafb_setcolor(sc, 255, 0, 0, 0);	/* cursor */
	vgafb_setcolor(sc, WSCOL_WHITE, 255, 255, 255);
}

d382 4
a385 5
	*cookiep = &sc->sc_rasops;
	*curyp = 0;
	*curxp = 0;
	sc->sc_rasops.ri_ops.alloc_attr(&sc->sc_rasops,
	    WSCOL_BLACK, WSCOL_WHITE, WSATTR_WSCOLORS, attrp);
d422 3
a424 20
	switch (sc->sc_mode) {
	case WSDISPLAYIO_MODE_MAPPED:
		if (off >= sc->sc_mem_addr &&
		    off < (sc->sc_mem_addr + sc->sc_mem_size))
			return (bus_space_mmap(sc->sc_mem_t,
			    sc->sc_mem_addr, off - sc->sc_mem_addr,
			    prot, BUS_SPACE_MAP_LINEAR));

		if (off >= sc->sc_mmio_addr &&
		    off < (sc->sc_mmio_addr + sc->sc_mmio_size))
			return (bus_space_mmap(sc->sc_mem_t,
			    sc->sc_mmio_addr, off - sc->sc_mmio_addr,
			    prot, BUS_SPACE_MAP_LINEAR));
		break;

	case WSDISPLAYIO_MODE_DUMBFB:
		if (off >= 0 && off < sc->sc_mem_size)
			return (bus_space_mmap(sc->sc_mem_t, sc->sc_mem_addr,
			    off, prot, BUS_SPACE_MAP_LINEAR));
		break;
a448 75
}

int
vgafb_mapregs(sc, pa)
	struct vgafb_softc *sc;
	struct pci_attach_args *pa;
{
	bus_addr_t ba;
	bus_size_t bs;
	int hasio = 0, hasmem = 0, hasmmio = 0; 
	u_int32_t i, cf;

	for (i = PCI_MAPREG_START; i < PCI_MAPREG_END; i += 4) {
		cf = pci_conf_read(pa->pa_pc, pa->pa_tag, i);
		if (PCI_MAPREG_TYPE(cf) == PCI_MAPREG_TYPE_IO) {
			if (hasio)
				continue;
			if (pci_io_find(pa->pa_pc, pa->pa_tag, i,
			    &sc->sc_io_addr, &sc->sc_io_size)) {
				printf(": failed to find io at 0x%x\n", i);
				continue;
			}
			hasio = 1;
		} else {
			/* Memory mapping... frame memory or mmio? */
			if (pci_mem_find(pa->pa_pc, pa->pa_tag, i,
			    &ba, &bs, NULL)) {
				printf(": failed to find mem at 0x%x\n", i);
				continue;
			}

			if (bs <= 0x10000) {	/* mmio */
				if (hasmmio)
					continue;
				sc->sc_mmio_addr = ba;
				sc->sc_mmio_size = bs;
				hasmmio = 1;
			} else {
				if (hasmem)
					continue;
				if (bus_space_map(pa->pa_memt, ba, bs,
				    0, &sc->sc_mem_h)) {
					printf(": can't map mem space\n");
					continue;
				}
				sc->sc_mem_addr = ba;
				sc->sc_mem_size = bs;
				hasmem = 1;
			}
		}
	}

	if (hasmmio == 0 || hasmem == 0 || hasio == 0) {
		printf(": failed to find all ports\n");
		goto fail;
	}

	return (0);

fail:
	if (hasmem)
		bus_space_unmap(pa->pa_memt, sc->sc_mem_h, sc->sc_mem_size);
	return (1);
}

void
vgafb_updatecursor(ri)
	struct rasops_info *ri;
{
	struct vgafb_softc *sc = ri->ri_hw;

	if (sc->sc_crowp != NULL)
		*sc->sc_crowp = ri->ri_crow;
	if (sc->sc_ccolp != NULL)
		*sc->sc_ccolp = ri->ri_ccol;
@


1.5.2.3
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.5.2.2 2003/03/27 23:42:36 niklas Exp $	*/
d15 5
@


1.5.2.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a55 1
#include <machine/fbvar.h>
d58 1
a58 1
	struct sunfb sc_sunfb;
d60 1
d75 1
d81 5
d109 3
a111 1
void vgafb_setcolor(void *, u_int, u_int8_t, u_int8_t, u_int8_t);
d113 1
d165 1
d172 17
a188 1
	printf("\n");
d193 9
a201 9
	sc->sc_console = vgafb_is_console(sc->sc_node);

	fb_setsize(&sc->sc_sunfb, 8, 1152, 900, sc->sc_node, 0);
	if (sc->sc_sunfb.sf_depth == 24) {
		sc->sc_sunfb.sf_depth = 32;
		sc->sc_sunfb.sf_linebytes =
		    (sc->sc_sunfb.sf_depth / 8) * sc->sc_sunfb.sf_width;
		sc->sc_sunfb.sf_fbsize =
		    sc->sc_sunfb.sf_height * sc->sc_sunfb.sf_linebytes;
d204 2
a205 1
	sc->sc_sunfb.sf_ro.ri_bits = (void *)bus_space_vaddr(sc->sc_mem_t,
d207 13
a219 1
	sc->sc_sunfb.sf_ro.ri_hw = sc;
d221 1
a221 7
	fbwscons_init(&sc->sc_sunfb,
	    RI_BSWAP | (sc->sc_console ? 0 : RI_CLEAR));

	vgafb_stdscreen.capabilities = sc->sc_sunfb.sf_ro.ri_caps;
	vgafb_stdscreen.nrows = sc->sc_sunfb.sf_ro.ri_rows;
	vgafb_stdscreen.ncols = sc->sc_sunfb.sf_ro.ri_cols;
	vgafb_stdscreen.textops = &sc->sc_sunfb.sf_ro.ri_ops;
d225 21
a245 6
		fbwscons_setcolormap(&sc->sc_sunfb, vgafb_setcolor);
		sc->sc_sunfb.sf_ro.ri_updatecursor = vgafb_updatecursor;
		fbwscons_console_init(&sc->sc_sunfb, &vgafb_stdscreen, -1,
		    NULL);
	} else {
		/* sc->sc_ofhandle = XXX */
d253 2
d275 4
a278 2
		if (sc->sc_mode == WSDISPLAYIO_MODE_EMUL)
			fbwscons_setcolormap(&sc->sc_sunfb, vgafb_setcolor);
d282 3
a284 3
		wdf->height = sc->sc_sunfb.sf_height;
		wdf->width  = sc->sc_sunfb.sf_width;
		wdf->depth  = sc->sc_sunfb.sf_depth;
d288 1
a288 1
		*(u_int *)data = sc->sc_sunfb.sf_linebytes;
d379 3
a381 3
vgafb_setcolor(v, index, r, g, b)
	void *v;
	u_int index;
a383 2
	struct vgafb_softc *sc = v;

d390 17
d420 1
a420 1
	*cookiep = &sc->sc_sunfb.sf_ro;
d423 1
a423 1
	sc->sc_sunfb.sf_ro.ri_ops.alloc_attr(&sc->sc_sunfb.sf_ro,
d484 12
@


1.4
log
@Implement vgafb_mmap() fully
From NetBSD: change bus_space_mmap() prototype to standard one
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.3 2002/01/03 16:26:27 jason Exp $	*/
d351 1
a351 1
		vgafb_setcolor(sc, index, *r, *g, *b);
d363 3
@


1.3
log
@
add get/set colormap functions (mostly stolen from macppc)
add WSSCREEN_WSCOLORS attribute (doesn't seem to matter much, tho)
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.2 2001/12/14 19:17:02 jason Exp $	*/
d64 1
a167 1
	bus_addr_t membase;
d190 1
a190 1
	    &membase, &memsize, NULL)) {
d195 1
a195 1
	    membase, memsize, 0, NULL, &sc->sc_bh)) {
d409 1
a409 1
vgafb_mmap(v, offset, prot)
d411 1
a411 1
	off_t offset;
a413 1
#if 0
a414 1
#endif
d416 1
a416 1
	if (offset & PGOFSET)
d418 6
@


1.2
log
@less confusing variable names
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.1 2001/12/14 14:59:04 jason Exp $	*/
d35 1
d43 2
d60 2
a61 1
	int sc_width, sc_height, sc_depth, sc_linebytes, sc_node;
d66 4
d84 1
a84 1
	"std",
d86 1
a86 1
	0,
d88 1
a88 1
	WSSCREEN_REVERSE
d108 4
a166 1
	int console;
d187 1
a187 1
	console = vgafb_is_console(sc->sc_node);
d208 1
a208 1
	if (console == 0 ||
d230 11
a240 1
	if (console)
d243 1
d245 1
a245 1
	waa.console = console;
a280 1
#if 0
d282 3
a284 1
		return vgafb_getcmap(vc, (struct wsdisplay_cmap *)data);
d286 3
a288 2
		return vgafb_putcmap(vc, (struct wsdisplay_cmap *)data);
#endif
d302 62
@


1.2.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.3 2002/01/03 16:26:27 jason Exp $	*/
a34 1
#include <sys/buf.h>
a41 2
#include <uvm/uvm_extern.h>

d57 1
a57 2
	int sc_width, sc_height, sc_depth, sc_linebytes;
	int sc_node, sc_ofhandle;
a61 4
	int sc_console;
	u_int8_t sc_cmap_red[256];
	u_int8_t sc_cmap_green[256];
	u_int8_t sc_cmap_blue[256];
d76 1
a76 1
	"sun",
d78 1
a78 1
	NULL,
d80 1
a80 1
	WSSCREEN_REVERSE | WSSCREEN_WSCOLORS
a99 4
int vgafb_getcmap __P((struct vgafb_softc *, struct wsdisplay_cmap *));
int vgafb_putcmap __P((struct vgafb_softc *, struct wsdisplay_cmap *));
void vgafb_setcolor __P((struct vgafb_softc *, unsigned int,
    u_int8_t, u_int8_t, u_int8_t));
d155 1
d176 1
a176 1
	sc->sc_console = vgafb_is_console(sc->sc_node);
d197 1
a197 1
	if (sc->sc_console == 0 ||
d219 1
a219 11
	if (sc->sc_console) {
		sc->sc_ofhandle = OF_stdout();
		vgafb_setcolor(sc, WSCOL_BLACK, 0, 0, 0);
		vgafb_setcolor(sc, 255, 255, 255, 255);
		vgafb_setcolor(sc, WSCOL_RED, 255, 0, 0);
		vgafb_setcolor(sc, WSCOL_GREEN, 0, 255, 0);
		vgafb_setcolor(sc, WSCOL_BROWN, 154, 85, 46);
		vgafb_setcolor(sc, WSCOL_BLUE, 0, 0, 255);
		vgafb_setcolor(sc, WSCOL_MAGENTA, 255, 255, 0);
		vgafb_setcolor(sc, WSCOL_CYAN, 0, 255, 255);
		vgafb_setcolor(sc, WSCOL_WHITE, 255, 255, 255);
a221 1
	}
d223 1
a223 1
	waa.console = sc->sc_console;
d259 1
d261 1
a261 3
		if (sc->sc_console == 0)
			return (EINVAL);
		return vgafb_getcmap(sc, (struct wsdisplay_cmap *)data);
d263 2
a264 3
		if (sc->sc_console == 0)
			return (EINVAL);
		return vgafb_putcmap(sc, (struct wsdisplay_cmap *)data);
a277 62
}

int
vgafb_getcmap(sc, cm)
	struct vgafb_softc *sc;
	struct wsdisplay_cmap *cm;
{
	u_int index = cm->index;
	u_int count = cm->count;
	int error;

	error = copyout(&sc->sc_cmap_red[index], cm->red, count);
	if (error)
		return (error);
	error = copyout(&sc->sc_cmap_green[index], cm->green, count);
	if (error)
		return (error);
	error = copyout(&sc->sc_cmap_blue[index], cm->blue, count);
	if (error)
		return (error);
	return (0);
}

int
vgafb_putcmap(sc, cm)
	struct vgafb_softc *sc;
	struct wsdisplay_cmap *cm;
{
	int index = cm->index;
	int count = cm->count;
	int i;
	u_char *r, *g, *b;

	if (cm->index >= 256 || cm->count > 256 ||
	    (cm->index + cm->count) > 256)
		return (EINVAL);
	if (!uvm_useracc(cm->red, cm->count, B_READ) ||
	    !uvm_useracc(cm->green, cm->count, B_READ) ||
	    !uvm_useracc(cm->blue, cm->count, B_READ))
		return (EFAULT);
	copyin(cm->red, &sc->sc_cmap_red[index], count);
	copyin(cm->green, &sc->sc_cmap_green[index], count);
	copyin(cm->blue, &sc->sc_cmap_blue[index], count);

	r = &sc->sc_cmap_red[index];
	g = &sc->sc_cmap_green[index];
	b = &sc->sc_cmap_blue[index];

	for (i = 0; i < count; i++) {
		vgafb_setcolor(sc, index, *r, *g, *b);
		r++, g++, b++, index++;
	}
	return (0);
}

void
vgafb_setcolor(sc, index, r, g, b)
	struct vgafb_softc *sc;
	unsigned int index;
	u_int8_t r, g, b;
{
	OF_call_method("color!", sc->sc_ofhandle, 4, 0, r, g, b, index);
@


1.2.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.2.2.1 2002/01/31 22:55:24 niklas Exp $	*/
a31 5
 *
 * Effort sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F30602-01-2-0537.
 *
d54 1
a54 1
#include <dev/rasops/rasops.h>
d58 1
d62 4
a65 8
	bus_space_tag_t sc_mem_t;
	bus_space_tag_t sc_io_t;
	bus_space_handle_t sc_mem_h, sc_io_h, sc_mmio_h;
	bus_addr_t sc_io_addr, sc_mem_addr, sc_mmio_addr, sc_rom_addr;
	bus_size_t sc_io_size, sc_mem_size, sc_mmio_size, sc_rom_size;
	pci_chipset_tag_t sc_pci_chip;
	u_int8_t *sc_rom_ptr;
	int sc_has_rom;
a66 1
	u_int sc_mode;
d70 11
a80 1
	struct rasops_info sc_rasops;
d100 12
a111 14
int vgafb_mapregs(struct vgafb_softc *, struct pci_attach_args *);
int vgafb_rommap(struct vgafb_softc *, struct pci_attach_args *);
int vgafb_ioctl(void *, u_long, caddr_t, int, struct proc *);
int vgafb_alloc_screen(void *, const struct wsscreen_descr *, void **,
    int *, int *, long *);
void vgafb_free_screen(void *, void *);
int vgafb_show_screen(void *, void *, int,
    void (*cb)(void *, int, int), void *);
paddr_t vgafb_mmap(void *, off_t, int);
int vgafb_is_console(int);
int vgafb_getcmap(struct vgafb_softc *, struct wsdisplay_cmap *);
int vgafb_putcmap(struct vgafb_softc *, struct wsdisplay_cmap *);
void vgafb_setcolor(struct vgafb_softc *, unsigned int,
    u_int8_t, u_int8_t, u_int8_t);
d113 1
a113 1
static int a2int(char *, int);
d124 2
a125 2
int	vgafbmatch(struct device *, void *, void *);
void	vgafbattach(struct device *, struct device *, void *);
d165 1
d167 1
a168 2
	sc->sc_mem_t = pa->pa_memt;
	sc->sc_io_t = pa->pa_iot;
d189 11
a199 2
	if (vgafb_mapregs(sc, pa))
		return;
d201 12
a212 9
	if (sc->sc_depth == 24) {
		/* Depth is 24, but rasops really wants bpp */
		sc->sc_rasops.ri_depth = 32;
		/* PROM gets linebytes wrong, ignore it. */
		sc->sc_rasops.ri_stride =
		    (sc->sc_rasops.ri_depth / 8) * sc->sc_width;
	} else {
		sc->sc_rasops.ri_depth = sc->sc_depth;
		sc->sc_rasops.ri_stride = sc->sc_linebytes;
d215 12
a226 16
	sc->sc_rasops.ri_flg = RI_CENTER;
	sc->sc_rasops.ri_bits = (void *)bus_space_vaddr(sc->sc_mem_t,
	    sc->sc_mem_h);
	sc->sc_rasops.ri_width = sc->sc_width;
	sc->sc_rasops.ri_height = sc->sc_height;
	sc->sc_rasops.ri_hw = sc;

	rasops_init(&sc->sc_rasops,
	    a2int(getpropstring(optionsnode, "screen-#rows"), 34),
	    a2int(getpropstring(optionsnode, "screen-#columns"), 80));

	vgafb_stdscreen.nrows = sc->sc_rasops.ri_rows;
	vgafb_stdscreen.ncols = sc->sc_rasops.ri_cols;
	vgafb_stdscreen.textops = &sc->sc_rasops.ri_ops;
	sc->sc_rasops.ri_ops.alloc_attr(&sc->sc_rasops,
	    WSCOL_WHITE, WSCOL_BLACK, WSATTR_WSCOLORS, &defattr);
a230 2
		int *ccolp, *crowp;

d232 11
a242 21

		if (sc->sc_depth == 8) {
			vgafb_setcolor(sc, WSCOL_BLACK, 0, 0, 0);
			vgafb_setcolor(sc, 255, 255, 255, 255);
			vgafb_setcolor(sc, WSCOL_RED, 255, 0, 0);
			vgafb_setcolor(sc, WSCOL_GREEN, 0, 255, 0);
			vgafb_setcolor(sc, WSCOL_BROWN, 154, 85, 46);
			vgafb_setcolor(sc, WSCOL_BLUE, 0, 0, 255);
			vgafb_setcolor(sc, WSCOL_MAGENTA, 255, 255, 0);
			vgafb_setcolor(sc, WSCOL_CYAN, 0, 255, 255);
			vgafb_setcolor(sc, WSCOL_WHITE, 255, 255, 255);
		}

		if (romgetcursoraddr(&crowp, &ccolp))
			ccolp = crowp = NULL;
		if (ccolp != NULL)
			sc->sc_rasops.ri_ccol = *ccolp;
		if (crowp != NULL)
			sc->sc_rasops.ri_crow = *crowp;
		wsdisplay_cnattach(&vgafb_stdscreen, &sc->sc_rasops,
		    sc->sc_rasops.ri_ccol, sc->sc_rasops.ri_crow, defattr);
d252 1
a269 3
	case WSDISPLAYIO_SMODE:
		sc->sc_mode = *(u_int *)data;
		break;
d274 1
a274 1
		wdf->depth  = sc->sc_rasops.ri_depth;
d278 1
a278 1
		*(u_int *)data = sc->sc_rasops.ri_stride;
d351 1
a351 1
		OF_call_method("color!", sc->sc_ofhandle, 4, 0, *r, *g, *b, index);
a362 3
	sc->sc_cmap_red[index] = r;
	sc->sc_cmap_green[index] = g;
	sc->sc_cmap_blue[index] = b;
d379 4
a382 5
	*cookiep = &sc->sc_rasops;
	*curyp = 0;
	*curxp = 0;
	sc->sc_rasops.ri_ops.alloc_attr(&sc->sc_rasops,
	    WSCOL_WHITE, WSCOL_BLACK, WSATTR_WSCOLORS, attrp);
d402 1
a402 1
	void (*cb)(void *, int, int);
d409 1
a409 1
vgafb_mmap(v, off, prot)
d411 1
a411 1
	off_t off;
d414 1
d416 1
a416 2
	paddr_t pa;
	vaddr_t va;
d418 1
a418 1
	if (off & PGOFSET)
a419 36

	switch (sc->sc_mode) {
	case WSDISPLAYIO_MODE_MAPPED:
		if (off >= sc->sc_mem_addr &&
		    off < (sc->sc_mem_addr + sc->sc_mem_size))
			return (bus_space_mmap(sc->sc_mem_t,
			    sc->sc_mem_addr, off - sc->sc_mem_addr,
			    prot, BUS_SPACE_MAP_LINEAR));

		if (off >= sc->sc_mmio_addr &&
		    off < (sc->sc_mmio_addr + sc->sc_mmio_size))
			return (bus_space_mmap(sc->sc_mem_t,
			    sc->sc_mmio_addr, off - sc->sc_mmio_addr,
			    prot, BUS_SPACE_MAP_LINEAR));

		if (sc->sc_rom_ptr != NULL &&
		    off >= sc->sc_rom_addr &&
		    off < sc->sc_rom_addr + sc->sc_rom_size) {
			off -= sc->sc_rom_addr;
			va = ((vaddr_t)sc->sc_rom_ptr) + off;
			if (pmap_extract(pmap_kernel(), va, &pa) == FALSE)
				return (-1);
			return (pa);
		}
		return (-1);

	case WSDISPLAYIO_MODE_DUMBFB:
		if (off >= 0 && off < sc->sc_mem_size)
			return (bus_space_mmap(sc->sc_mem_t, sc->sc_mem_addr,
			    off, prot, BUS_SPACE_MAP_LINEAR));
		return (-1);

	default:
		return (-1);
	}

a441 160
}

#define	PCI_ROMBAR_REG		0x30
#define	PCI_ROMBAR_ADDR(mr)						\
	    ((mr) & PCI_ROMBAR_ADDR_MASK)
#define	PCI_ROMBAR_SIZE(mr)						\
	    (PCI_ROMBAR_ADDR(mr) & -PCI_ROMBAR_ADDR(mr))
#define	PCI_ROMBAR_ADDR_ENABLE	0x00000001
#define	PCI_ROMBAR_ADDR_MASK	0xfffff800

/* offsets into the rom space */
#define	PCI_ROM_OFF_MAGIC0	0x0
#define	PCI_ROM_OFF_MAGIC1	0x1

/* rom header magic numbers */
#define	PCI_ROM_MAGIC0		0x55
#define	PCI_ROM_MAGIC1		0xaa

int
vgafb_rommap(sc, pa)
	struct vgafb_softc *sc;
	struct pci_attach_args *pa;
{
	bus_space_handle_t bh;
	u_int32_t origaddr, address, mask, size, i;
	u_int8_t *romptr, *p;
	int s;

	s = splhigh();
	origaddr = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_ROMBAR_REG);
	pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_ROMBAR_REG,
	    PCI_ROMBAR_ADDR_MASK);
	mask = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_ROMBAR_REG);
	pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_ROMBAR_REG, origaddr);
	address = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_ROMBAR_REG);
	splx(s);

	/* No ROM supported? */
	if (mask == 0)
		return (0);

	address &= PCI_ROMBAR_ADDR_MASK;

	/* Turn on the address decoder please... */
	pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_ROMBAR_REG,
	    address | PCI_ROMBAR_ADDR_ENABLE);

	size = PCI_ROMBAR_SIZE(mask);

	if (bus_space_map(pa->pa_memt, address, size, 0, &bh)) {
		pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_ROMBAR_REG, origaddr);
		return (0);
	}

	if ((bus_space_read_1(pa->pa_memt, bh, PCI_ROM_OFF_MAGIC0) !=
	    PCI_ROM_MAGIC0) ||
	    (bus_space_read_1(pa->pa_memt, bh, PCI_ROM_OFF_MAGIC1) !=
	    PCI_ROM_MAGIC1)) {
		/* ROM is supported but not present */
		bus_space_unmap(pa->pa_memt, bh, size);
		pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_ROMBAR_REG, origaddr);
		return (0);
	}

	romptr = (u_int8_t *)malloc(size, M_DEVBUF, M_NOWAIT);
	if (romptr == NULL) {
		bus_space_unmap(pa->pa_memt, bh, size);
		pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_ROMBAR_REG, origaddr);
		return (0);
	}

	for (p = romptr, i = 0; i < size; i++)
		*p++ = bus_space_read_1(pa->pa_memt, bh, i);

	sc->sc_rom_ptr = romptr;
	sc->sc_rom_addr = address;
	sc->sc_rom_size = size;

	bus_space_unmap(pa->pa_memt, bh, size);
	pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_ROMBAR_REG, origaddr);
	return (0);
}

int
vgafb_mapregs(sc, pa)
	struct vgafb_softc *sc;
	struct pci_attach_args *pa;
{
	bus_addr_t ba;
	bus_size_t bs;
	int hasio = 0, hasmem = 0, hasmmio = 0; 
	u_int32_t i, cf;

	vgafb_rommap(sc, pa);

	for (i = 0x10; i <= 0x18; i += 4) {
		cf = pci_conf_read(pa->pa_pc, pa->pa_tag, i);
		if (PCI_MAPREG_TYPE(cf) == PCI_MAPREG_TYPE_IO) {
			if (hasio)
				continue;
			if (pci_io_find(pa->pa_pc, pa->pa_tag, i,
			    &sc->sc_io_addr, &sc->sc_io_size)) {
				printf(": failed to find io at 0x%x\n", i);
				continue;
			}
			if (bus_space_map(pa->pa_iot, sc->sc_io_addr,
			    sc->sc_io_size, 0, &sc->sc_io_h)) {
				printf(": can't map io space\n");
				continue;
			}
			hasio = 1;
		} else {
			/* Memory mapping... frame memory or mmio? */
			if (pci_mem_find(pa->pa_pc, pa->pa_tag, i,
			    &ba, &bs, NULL)) {
				printf(": failed to find mem at 0x%x\n", i);
				continue;
			}

			if (bs <= 0x10000) {	/* mmio */
				if (hasmmio)
					continue;
				if (bus_space_map(pa->pa_memt, ba, bs, 0,
				    &sc->sc_mmio_h)) {
					printf(": can't map mmio space\n");
					continue;
				}
				sc->sc_mmio_addr = ba;
				sc->sc_mmio_size = bs;
				hasmmio = 1;
			} else {
				if (hasmem)
					continue;
				if (bus_space_map2(pa->pa_memt, SBUS_BUS_SPACE,
				    ba, bs, 0, NULL, &sc->sc_mem_h)) {
					printf(": can't map mem space\n");
					continue;
				}
				sc->sc_mem_addr = ba;
				sc->sc_mem_size = bs;
				hasmem = 1;
			}
		}
	}

	if (hasmmio == 0 || hasmem == 0 || hasio == 0) {
		printf(": failed to find all ports\n");
		goto fail;
	}

	return (0);

fail:
	if (hasio)
		bus_space_unmap(pa->pa_iot, sc->sc_io_h, sc->sc_io_size);
	if (hasmmio)
		bus_space_unmap(pa->pa_memt, sc->sc_mmio_h, sc->sc_mmio_size);
	if (hasmem)
		bus_space_unmap(pa->pa_memt, sc->sc_mem_h, sc->sc_mem_size);
	return (1);
@


1.2.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.2.2.2 2002/06/11 03:38:43 art Exp $	*/
a46 1
#include <sys/pciio.h>
d68 3
a70 4
	pcitag_t sc_pcitag;
	bus_space_handle_t sc_mem_h;
	bus_addr_t sc_io_addr, sc_mem_addr, sc_mmio_addr;
	bus_size_t sc_io_size, sc_mem_size, sc_mmio_size;
d72 1
a79 1
	int *sc_crowp, *sc_ccolp;
a86 1
	WSSCREEN_UNDERLINE | WSSCREEN_HILIT |
d113 1
a113 1
void vgafb_updatecursor(struct rasops_info *ri);
a170 1
	sc->sc_pcitag = pa->pa_tag;
d204 1
a204 1
	sc->sc_rasops.ri_flg = RI_CENTER | RI_BSWAP;
d219 1
a219 1
	    WSCOL_BLACK, WSCOL_WHITE, WSATTR_WSCOLORS, &defattr);
d224 2
d230 1
a230 1
			vgafb_setcolor(sc, 255, 0, 0, 0);
a237 6
		} else {
			/* fix color choice */
			wscol_white = 0;
			wscol_black = 255;
			wskernel_bg = 0;
			wskernel_fg = 255;
d240 6
a245 8
		if (romgetcursoraddr(&sc->sc_crowp, &sc->sc_ccolp))
			sc->sc_ccolp = sc->sc_crowp = NULL;
		if (sc->sc_ccolp != NULL)
			sc->sc_rasops.ri_ccol = *sc->sc_ccolp;
		if (sc->sc_crowp != NULL)
			sc->sc_rasops.ri_crow = *sc->sc_crowp;
		sc->sc_rasops.ri_updatecursor = vgafb_updatecursor;

a268 1
	struct pcisel *sel;
d287 1
a287 1
		
a296 7
	case WSDISPLAYIO_GPCIID:
		sel = (struct pcisel *)data;
		sel->pc_bus = PCITAG_BUS(sc->sc_pcitag);
		sel->pc_dev = PCITAG_DEV(sc->sc_pcitag);
		sel->pc_func = PCITAG_FUNC(sc->sc_pcitag);
		break;

a319 3
	if (index >= 256 || count > 256 - index)
		return (EINVAL);

d337 2
a338 2
	u_int index = cm->index;
	u_int count = cm->count;
d342 2
a343 1
	if (index >= 256 || count > 256 - index)
d393 1
a393 1
	    WSCOL_BLACK, WSCOL_WHITE, WSATTR_WSCOLORS, attrp);
d426 2
d445 11
a455 1
		break;
d461 4
a464 1
		break;
d491 81
d582 3
a584 1
	for (i = PCI_MAPREG_START; i < PCI_MAPREG_END; i += 4) {
d594 5
d611 5
d622 2
a623 2
				if (bus_space_map(pa->pa_memt, ba, bs,
				    0, &sc->sc_mem_h)) {
d642 4
a648 12
}

void
vgafb_updatecursor(ri)
	struct rasops_info *ri;
{
	struct vgafb_softc *sc = ri->ri_hw;

	if (sc->sc_crowp != NULL)
		*sc->sc_crowp = ri->ri_crow;
	if (sc->sc_ccolp != NULL)
		*sc->sc_ccolp = ri->ri_ccol;
@


1.2.2.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d85 1
a85 1
	"std",
a115 1
void vgafb_restore_default_colors(struct vgafb_softc *);
d231 9
a239 1
			vgafb_restore_default_colors(sc);
a286 4
		if (sc->sc_mode == WSDISPLAYIO_MODE_EMUL &&
		    sc->sc_depth == 8) {
			vgafb_restore_default_colors(sc);
		}
d360 1
a360 2
	u_int i;
	int error;
d365 7
a371 7

	if ((error = copyin(cm->red, &sc->sc_cmap_red[index], count)) != 0)
		return (error);
	if ((error = copyin(cm->green, &sc->sc_cmap_green[index], count)) != 0)
		return (error);
	if ((error = copyin(cm->blue, &sc->sc_cmap_blue[index], count)) != 0)
		return (error);
d378 1
a378 2
		OF_call_method("color!", sc->sc_ofhandle, 4, 0, *r, *g, *b,
		    index);
a393 17
}

void
vgafb_restore_default_colors(struct vgafb_softc *sc)
{
	int i;

	for (i = 0; i < 256; i++) {
		const u_char *color;

		color = &rasops_cmap[i * 3];
		vgafb_setcolor(sc, i, color[0], color[1], color[2]);
	}
	/* compensate for BoW palette */
	vgafb_setcolor(sc, WSCOL_BLACK, 0, 0, 0);
	vgafb_setcolor(sc, 255, 0, 0, 0);	/* cursor */
	vgafb_setcolor(sc, WSCOL_WHITE, 255, 255, 255);
@


1.1
log
@Driver for vga framebuffers on sparc64 based on cgsix (which is based on
cgsix from sparc and vgafb from macppc).
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d153 1
a153 1
	bus_size_t iosize;
d156 1
a156 1
	bus_addr_t base;
d178 2
a179 1
	if (pci_mem_find(pa->pa_pc, pa->pa_tag, 0x10, &base, &iosize, NULL)) {
d183 2
a184 2
	if (bus_space_map2(pa->pa_memt, SBUS_BUS_SPACE, base, iosize, 0, NULL,
	    &sc->sc_bh)) {
@

