head	1.17;
access;
symbols
	OPENBSD_6_1:1.17.0.6
	OPENBSD_6_1_BASE:1.17
	OPENBSD_6_0:1.17.0.2
	OPENBSD_6_0_BASE:1.17
	OPENBSD_5_9:1.16.0.8
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.16.0.10
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.16.0.2
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.16.0.6
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.16.0.4
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.15.0.18
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.15.0.16
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.14
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.12
	OPENBSD_5_0:1.15.0.10
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.15.0.8
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.15.0.6
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.15.0.2
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.15.0.4
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.14.0.2
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.13.0.2
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.11.0.2
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.10.0.2
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.9.0.16
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.14
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.12
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.10
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.6
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.8
	OPENBSD_3_6_BASE:1.9
	SMP_SYNC_A:1.9
	SMP_SYNC_B:1.9
	OPENBSD_3_5:1.9.0.4
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	UBC_SYNC_A:1.8
	OPENBSD_3_3:1.8.0.2
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.6.0.4
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	UBC_SYNC_B:1.6
	UBC:1.4.0.6
	UBC_BASE:1.4
	SMP:1.4.0.4
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4;
locks; strict;
comment	@ * @;


1.17
date	2016.05.04.18.26.12;	author kettenis;	state Exp;
branches;
next	1.16;
commitid	M6mvq0S4zf7jMQ41;

1.16
date	2014.01.22.10.52.35;	author kettenis;	state Exp;
branches;
next	1.15;

1.15
date	2009.05.04.16.48.37;	author oga;	state Exp;
branches;
next	1.14;

1.14
date	2009.01.02.20.01.45;	author kettenis;	state Exp;
branches;
next	1.13;

1.13
date	2008.07.12.13.08.04;	author kettenis;	state Exp;
branches;
next	1.12;

1.12
date	2008.03.09.19.27.56;	author kettenis;	state Exp;
branches;
next	1.11;

1.11
date	2007.12.05.21.15.46;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2007.05.29.09.53.59;	author sobrado;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.11.03.16.12;	author henric;	state Exp;
branches;
next	1.8;

1.8
date	2003.03.06.08.26.08;	author henric;	state Exp;
branches;
next	1.7;

1.7
date	2003.02.17.01.29.20;	author henric;	state Exp;
branches;
next	1.6;

1.6
date	2002.03.14.01.26.44;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.02.22.16.11.59;	author jason;	state Exp;
branches;
next	1.4;

1.4
date	2001.10.15.03.36.16;	author jason;	state Exp;
branches
	1.4.4.1
	1.4.6.1;
next	1.3;

1.3
date	2001.09.26.19.31.57;	author jason;	state Exp;
branches;
next	1.2;

1.2
date	2001.08.18.21.30.00;	author jason;	state Exp;
branches;
next	1.1;

1.1
date	2001.08.18.20.56.41;	author jason;	state Exp;
branches;
next	;

1.4.4.1
date	2001.10.31.03.07.58;	author nate;	state Exp;
branches;
next	1.4.4.2;

1.4.4.2
date	2002.03.06.02.04.46;	author niklas;	state Exp;
branches;
next	1.4.4.3;

1.4.4.3
date	2002.03.28.10.57.11;	author niklas;	state Exp;
branches;
next	1.4.4.4;

1.4.4.4
date	2003.03.27.23.42.35;	author niklas;	state Exp;
branches;
next	1.4.4.5;

1.4.4.5
date	2004.02.19.10.49.59;	author niklas;	state Exp;
branches;
next	;

1.4.6.1
date	2002.06.11.03.38.43;	author art;	state Exp;
branches;
next	1.4.6.2;

1.4.6.2
date	2003.05.19.21.46.57;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.17
log
@Some hardware (such as the onboard dc(4) of the Netra X1) has a broken DMA
engine that might attempt to read beyond the end of the buffer that was
programmed.  The IOMMU catches this "DMA overrun" and throws an unrecoverable
error at us, at which point we have no choice but to panic.  To avoid this
implement a BUS_DMA_OVERRUN flag that maps an additional scratch page at the
end of the vdma address range.  DMA requests will spill over into this page,
which just returns zeroes.

Thanks to matthieu@@ for giving me access to a machine with the problem.

ok deraadt@@, beck@@
@
text
@/*	$OpenBSD: iommuvar.h,v 1.16 2014/01/22 10:52:35 kettenis Exp $	*/
/*	$NetBSD: iommuvar.h,v 1.9 2001/10/07 20:30:41 eeh Exp $	*/

/*
 * Copyright (c) 2003 Henric Jungheim
 * Copyright (c) 1999 Matthew R. Green
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#ifndef _SPARC64_DEV_IOMMUVAR_H_
#define _SPARC64_DEV_IOMMUVAR_H_

#ifndef _SYS_TREE_H_
#include <sys/tree.h>
#endif

#include <sys/extent.h>
#include <sys/mutex.h>

/*
 * per-Streaming Buffer state
 */
struct strbuf_ctl {
	bus_space_tag_t		sb_bustag;	/* streaming buffer registers */
	bus_space_handle_t	sb_sb;		/* Handle for our regs */
	struct iommu_state	*sb_iommu;	/* Associated IOMMU */
	/*
	 * Since implementing the per-map IOMMU state, these per-STC
	 * flush areas are not used other than as a boolean flag to indicate
	 * the presence of a working and enabled STC.  For inconsistency's
	 * sake, the "sb" pointers of iommu_state are sometimes used for the
	 * same purpose.  This should be consolidated.  DEFINATELY, since
	 * mutex operations must happen at this level.
	 */
	struct mutex		sb_mtx;		/* one flush at a time */

	paddr_t			sb_flushpa;	/* to flush streaming buffers */
	volatile int64_t	*sb_flush;
};

/*
 * per-map STC flush area
 */
struct strbuf_flush {
	char	sbf_area[0x80];		/* Holds 64-byte long/aligned buffer */
	void	*sbf_flush;		/* Kernel virtual address of buffer */
	paddr_t	sbf_flushpa;		/* Physical address of buffer area */
};

/* 
 * per-map DVMA page table
 */
struct iommu_page_entry {
	SPLAY_ENTRY(iommu_page_entry) ipe_node;
	paddr_t		ipe_pa;
	bus_addr_t	ipe_va;
};
struct iommu_page_map {
	SPLAY_HEAD(iommu_page_tree, iommu_page_entry) ipm_tree;
	int ipm_maxpage;	/* Size of allocated page map */
	int ipm_pagecnt;	/* Number of entries in use */
	struct iommu_page_entry	ipm_map[1];
};

/*
 * per-map IOMMU state
 *
 * This is what bus_dvmamap_t'c _dm_cookie should be pointing to.
 */
struct iommu_map_state {
	struct strbuf_flush ims_flush;	/* flush should be first (alignment) */
	struct strbuf_ctl *ims_sb;	/* Link to parent */
	struct iommu_state *ims_iommu;
	int ims_flags;
	struct extent_region ims_er;
	struct iommu_page_map ims_map;	/* map must be last (array at end) */
};
#define IOMMU_MAP_STREAM	1

/*
 * per-IOMMU state
 */
struct iommu_state {
	paddr_t			is_ptsb;	/* TSB physical address */
	int64_t			*is_tsb;	/* TSB virtual address */
	int			is_tsbsize;	/* 0 = 8K, ... */
	u_int			is_dvmabase;
	u_int			is_dvmaend;
	int64_t			is_cr;		/* Control register value */
	struct mutex		is_mtx;
	struct extent		*is_dvmamap;	/* DVMA map for this instance */
	int			is_flags;
#define IOMMU_FLUSH_CACHE	0x00000001

	struct strbuf_ctl	*is_sb[2];	/* Streaming buffers if any */

	paddr_t			is_scratch;	/* Scratch page */

	/* copies of our parents state, to allow us to be self contained */
	bus_space_tag_t		is_bustag;	/* our bus tag */
	bus_space_handle_t	is_iommu;	/* IOMMU registers */
	uint64_t		is_devhandle;
};

/* interfaces for PCI/SBus code */
void	iommu_init(char *, struct iommu_state *, int, u_int32_t);
void	iommu_reset(struct iommu_state *);
paddr_t iommu_extract(struct iommu_state *, bus_addr_t);
int64_t iommu_lookup_tte(struct iommu_state *, bus_addr_t);
int64_t iommu_fetch_tte(struct iommu_state *, paddr_t);
/* bus_dma_tag_t implementation functions */
int	iommu_dvmamap_create(bus_dma_tag_t, bus_dma_tag_t, struct strbuf_ctl *,
	    bus_size_t, int, bus_size_t, bus_size_t, int, bus_dmamap_t *);
void	iommu_dvmamap_destroy(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t);
int	iommu_dvmamap_load(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t, void *,
	    bus_size_t, struct proc *, int);
void	iommu_dvmamap_unload(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t);
int	iommu_dvmamap_load_raw(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t,
	    bus_dma_segment_t *, int, bus_size_t, int);
void	iommu_dvmamap_sync(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t,
	    bus_addr_t, bus_size_t, int);
int	iommu_dvmamem_alloc(bus_dma_tag_t, bus_dma_tag_t, bus_size_t,
	    bus_size_t, bus_size_t, bus_dma_segment_t *, int, int *, int);
void	iommu_dvmamem_free(bus_dma_tag_t, bus_dma_tag_t, bus_dma_segment_t *,
	    int);

#define IOMMUREG_READ(is, reg)				\
	bus_space_read_8((is)->is_bustag,		\
		(is)->is_iommu,				\
		IOMMUREG(reg))	

#define IOMMUREG_WRITE(is, reg, v)			\
	bus_space_write_8((is)->is_bustag,		\
		(is)->is_iommu,				\
		IOMMUREG(reg),				\
		(v))

#endif /* _SPARC64_DEV_IOMMUVAR_H_ */

@


1.16
log
@Use extent_alloc_subregion_with_descr(9).  This should make bus_dmamap_load(9)
and bus_dmamap_unload(9) "mpsafe".
@
text
@d1 1
a1 1
/*	$OpenBSD: iommuvar.h,v 1.15 2009/05/04 16:48:37 oga Exp $	*/
d119 2
@


1.15
log
@type pedantry.

the type we bind to an iommu or a GART is paddr_t, by definition, on the
other hand, the type we get out of it is not a vaddr_t, it's bus_addr_t.

fix up sparc64 iommu, amd64 iommu and the sg_dma backedn that uses it to
realise this.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iommuvar.h,v 1.14 2009/01/02 20:01:45 kettenis Exp $	*/
d40 1
d98 1
@


1.14
log
@Make IOMMU code use the generic _bus_dmamem_map() and _bus_dmamem_unmap().
@
text
@d1 1
a1 1
/*	$OpenBSD: iommuvar.h,v 1.13 2008/07/12 13:08:04 kettenis Exp $	*/
d77 2
a78 2
	paddr_t	ipe_pa;
	vaddr_t	ipe_va;
d127 2
a128 2
paddr_t iommu_extract(struct iommu_state *, vaddr_t);
int64_t iommu_lookup_tte(struct iommu_state *, vaddr_t);
@


1.13
log
@Perform IOMMU cache flushes on Oberon.
@
text
@d1 1
a1 1
/*	$OpenBSD: iommuvar.h,v 1.11 2007/12/05 21:15:46 deraadt Exp $	*/
a144 3
int	iommu_dvmamem_map(bus_dma_tag_t, bus_dma_tag_t, bus_dma_segment_t *,
	    int, size_t, caddr_t *, int);
void	iommu_dvmamem_unmap(bus_dma_tag_t, bus_dma_tag_t, caddr_t, size_t);
@


1.12
log
@Add some members needed by the sunv IOMMU code.
@
text
@d113 2
@


1.11
log
@use mutexes to protect the iommu's extent map and the streaming buffer,
so that busdma is most likely MP_SAFE now.  (while there, fix an extent
map race... the ranges were selected outside splhigh)
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: iommuvar.h,v 1.10 2007/05/29 09:53:59 sobrado Exp $	*/
d95 1
d119 1
@


1.10
log
@use the right capitalization for `SBus'

ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iommuvar.h,v 1.9 2003/06/11 03:16:12 henric Exp $	*/
d40 2
d54 2
a55 1
	 * same purpose.  This should be consolidated.
d57 2
d110 1
@


1.9
log
@Much of the sbus, psycho, and schizo bus_dma code is the same, so let's
call the real implementation functions directly instead of duplicating
lots of code that only calls the real stuff anyway.

tested by miod@@ henning@@
ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iommuvar.h,v 1.8 2003/03/06 08:26:08 henric Exp $	*/
d114 1
a114 1
/* interfaces for PCI/SBUS code */
@


1.8
log
@The existing IOMMU code had a rounding problem that was most noticeable
on faster systems under heavy network load.  This replaces some of the
unreadable iommu functions with something a little less dense and a lot
less crash prone.

The bus_dma function pointer/cookie handling was broken.  Change them
to work like the stacked bus_space drivers (where "work" is the key
word).

Tested my many (thanks).

ok jason@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iommuvar.h,v 1.7 2003/02/17 01:29:20 henric Exp $	*/
d120 10
a129 11
int	iommu_dvmamap_create(bus_dma_tag_t, struct iommu_state *,
	    struct strbuf_ctl *, bus_size_t, int, bus_size_t, bus_size_t,
	    int, bus_dmamap_t *);
void	iommu_dvmamap_destroy(bus_dma_tag_t, bus_dmamap_t);
int	iommu_dvmamap_load(bus_dma_tag_t, struct iommu_state *,
	    bus_dmamap_t, void *, bus_size_t, struct proc *, int);
void	iommu_dvmamap_unload(bus_dma_tag_t, struct iommu_state *,
	    bus_dmamap_t);
int	iommu_dvmamap_load_raw(bus_dma_tag_t, struct iommu_state *,
	    bus_dmamap_t, bus_dma_segment_t *, int, int, bus_size_t);
void	iommu_dvmamap_sync(bus_dma_tag_t, struct iommu_state *, bus_dmamap_t,
d131 7
a137 9
int	iommu_dvmamem_alloc(bus_dma_tag_t, struct iommu_state *,
	    bus_size_t, bus_size_t, bus_size_t, bus_dma_segment_t *,
	    int, int *, int);
void	iommu_dvmamem_free(bus_dma_tag_t, struct iommu_state *,
	    bus_dma_segment_t *, int);
int	iommu_dvmamem_map(bus_dma_tag_t, struct iommu_state *,
	    bus_dma_segment_t *, int, size_t, caddr_t *, int);
void	iommu_dvmamem_unmap(bus_dma_tag_t, struct iommu_state *,
	    caddr_t, size_t);
@


1.7
log
@
Add support for the Sun Enterprise 450
Reduce the size of a GENERIC kernel by ~190k
Remove the nasty pointer/bus_space_handle_t casts
Adds debug bus_space code including the ability to trace
    bus operations (it actually works now).

The following rules are now followed (and verfified by the debug
code):

1.  A "bus_space_handle_t" may only be used with the
    "bus_space_tag_t" that created it.
2.  Only "bus_space_map()" may create "bus_space_handle_t"s.
3.  A "bus_space_handle_t" may not be modified after it has
    been created (other than being destroyed by "bus_space_unmap()").


Thanks to help from mcbride, marc, jason, drahn, to anyone that might
have slipped my mind at the moment.

ok jason@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iommuvar.h,v 1.6 2002/03/14 01:26:44 millert Exp $	*/
d5 1
d36 4
a42 1

d46 8
d59 37
d104 1
a104 1
	int64_t			is_cr;		/* IOMMU control register value */
a116 2
void    iommu_enter(struct iommu_state *, vaddr_t, int64_t, int);
void    iommu_remove(struct iommu_state *, vaddr_t, size_t);
d118 6
a123 1

d130 2
a131 2
void	iommu_dvmamap_sync(bus_dma_tag_t, struct iommu_state *,
	    bus_dmamap_t, bus_addr_t, bus_size_t, int);
@


1.6
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: iommuvar.h,v 1.5 2002/02/22 16:11:59 jason Exp $	*/
d36 11
d55 1
a55 1
	int64_t			is_cr;		/* IOMMU control regiter value */
d58 1
a58 3
	paddr_t			is_flushpa;	/* used to flush the SBUS */
	/* Needs to be volatile or egcs optimizes away loads */
	volatile int64_t	is_flush[2];
d62 1
a62 2
	struct iommureg		*is_iommu;	/* IOMMU registers */
	struct iommu_strbuf	*is_sb[2];	/* streaming buffer(s) */
d90 11
d102 1
@


1.5
log
@From NetBSD:
- Fix pr sparc64/15633: datafault at tlp_start causes panic
- Also clean up some additional 32-bit kernel printf issues.
- Handle the case where a DMA operation wraps from the end of a page to the
beginning of the same page properly by double-mapping that page.
- Move a brace so this will compile w/o DEBUG.
- Overhaul iommu_dvmamap_load_raw().
From Me:
- Verify the streaming cache exists before waiting on it to clear during flush.
- Force sync of flush status (hardware sets it to 1 when its done)
- Force sync flush of registers (bus_space_barrier)
- Flush ALL segments on BUS_DMA_POSTREAD operations (not just the first!)
@
text
@d1 1
a1 1
/*	$OpenBSD: iommuvar.h,v 1.4 2001/10/15 03:36:16 jason Exp $	*/
d58 15
a72 15
void	iommu_init __P((char *, struct iommu_state *, int, u_int32_t));
void	iommu_reset __P((struct iommu_state *));
void    iommu_enter __P((struct iommu_state *, vaddr_t, int64_t, int));
void    iommu_remove __P((struct iommu_state *, vaddr_t, size_t));
paddr_t iommu_extract __P((struct iommu_state *, vaddr_t));

int	iommu_dvmamap_load __P((bus_dma_tag_t, struct iommu_state *,
	    bus_dmamap_t, void *, bus_size_t, struct proc *, int));
void	iommu_dvmamap_unload __P((bus_dma_tag_t, struct iommu_state *,
	    bus_dmamap_t));
int	iommu_dvmamap_load_raw __P((bus_dma_tag_t, struct iommu_state *,
	    bus_dmamap_t, bus_dma_segment_t *, int, int, bus_size_t));
void	iommu_dvmamap_sync __P((bus_dma_tag_t, struct iommu_state *,
	    bus_dmamap_t, bus_addr_t, bus_size_t, int));
int	iommu_dvmamem_alloc __P((bus_dma_tag_t, struct iommu_state *,
d74 7
a80 7
	    int, int *, int));
void	iommu_dvmamem_free __P((bus_dma_tag_t, struct iommu_state *,
	    bus_dma_segment_t *, int));
int	iommu_dvmamem_map __P((bus_dma_tag_t, struct iommu_state *,
	    bus_dma_segment_t *, int, size_t, caddr_t *, int));
void	iommu_dvmamem_unmap __P((bus_dma_tag_t, struct iommu_state *,
	    caddr_t, size_t));
@


1.4
log
@Pull in several changes from NetBSD:
- Clear the dmamap inside splhigh() protection.
- Manage both streaming caches on psycho/psycho+.
And fix a botch I created when merging iommu changes last time.
@
text
@d1 1
a1 1
/*	$OpenBSD: iommuvar.h,v 1.3 2001/09/26 19:31:57 jason Exp $	*/
d43 1
@


1.4.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: iommuvar.h,v 1.4 2001/10/15 03:36:16 jason Exp $	*/
a42 1
	u_int			is_dvmaend;
d57 15
a71 15
void	iommu_init(char *, struct iommu_state *, int, u_int32_t);
void	iommu_reset(struct iommu_state *);
void    iommu_enter(struct iommu_state *, vaddr_t, int64_t, int);
void    iommu_remove(struct iommu_state *, vaddr_t, size_t);
paddr_t iommu_extract(struct iommu_state *, vaddr_t);

int	iommu_dvmamap_load(bus_dma_tag_t, struct iommu_state *,
	    bus_dmamap_t, void *, bus_size_t, struct proc *, int);
void	iommu_dvmamap_unload(bus_dma_tag_t, struct iommu_state *,
	    bus_dmamap_t);
int	iommu_dvmamap_load_raw(bus_dma_tag_t, struct iommu_state *,
	    bus_dmamap_t, bus_dma_segment_t *, int, int, bus_size_t);
void	iommu_dvmamap_sync(bus_dma_tag_t, struct iommu_state *,
	    bus_dmamap_t, bus_addr_t, bus_size_t, int);
int	iommu_dvmamem_alloc(bus_dma_tag_t, struct iommu_state *,
d73 7
a79 7
	    int, int *, int);
void	iommu_dvmamem_free(bus_dma_tag_t, struct iommu_state *,
	    bus_dma_segment_t *, int);
int	iommu_dvmamem_map(bus_dma_tag_t, struct iommu_state *,
	    bus_dma_segment_t *, int, size_t, caddr_t *, int);
void	iommu_dvmamem_unmap(bus_dma_tag_t, struct iommu_state *,
	    caddr_t, size_t);
@


1.4.6.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a4 1
 * Copyright (c) 2003 Henric Jungheim
a34 59
#ifndef _SYS_TREE_H_
#include <sys/tree.h>
#endif

/*
 * per-Streaming Buffer state
 */
struct strbuf_ctl {
	bus_space_tag_t		sb_bustag;	/* streaming buffer registers */
	bus_space_handle_t	sb_sb;		/* Handle for our regs */
	struct iommu_state	*sb_iommu;	/* Associated IOMMU */
	/*
	 * Since implementing the per-map IOMMU state, these per-STC
	 * flush areas are not used other than as a boolean flag to indicate
	 * the presence of a working and enabled STC.  For inconsistency's
	 * sake, the "sb" pointers of iommu_state are sometimes used for the
	 * same purpose.  This should be consolidated.
	 */
	paddr_t			sb_flushpa;	/* to flush streaming buffers */
	volatile int64_t	*sb_flush;
};

/*
 * per-map STC flush area
 */
struct strbuf_flush {
	char	sbf_area[0x80];		/* Holds 64-byte long/aligned buffer */
	void	*sbf_flush;		/* Kernel virtual address of buffer */
	paddr_t	sbf_flushpa;		/* Physical address of buffer area */
};

/* 
 * per-map DVMA page table
 */
struct iommu_page_entry {
	SPLAY_ENTRY(iommu_page_entry) ipe_node;
	paddr_t	ipe_pa;
	vaddr_t	ipe_va;
};
struct iommu_page_map {
	SPLAY_HEAD(iommu_page_tree, iommu_page_entry) ipm_tree;
	int ipm_maxpage;	/* Size of allocated page map */
	int ipm_pagecnt;	/* Number of entries in use */
	struct iommu_page_entry	ipm_map[1];
};

/*
 * per-map IOMMU state
 *
 * This is what bus_dvmamap_t'c _dm_cookie should be pointing to.
 */
struct iommu_map_state {
	struct strbuf_flush ims_flush;	/* flush should be first (alignment) */
	struct strbuf_ctl *ims_sb;	/* Link to parent */
	int ims_flags;
	struct iommu_page_map ims_map;	/* map must be last (array at end) */
};
#define IOMMU_MAP_STREAM	1

d44 1
a44 1
	int64_t			is_cr;		/* Control register value */
d47 3
a49 1
	struct strbuf_ctl	*is_sb[2];	/* Streaming buffers if any */
d53 2
a54 1
	bus_space_handle_t	is_iommu;	/* IOMMU registers */
d60 2
d63 1
a63 6
int64_t iommu_lookup_tte(struct iommu_state *, vaddr_t);
int64_t iommu_fetch_tte(struct iommu_state *, paddr_t);
int	iommu_dvmamap_create(bus_dma_tag_t, struct iommu_state *,
	    struct strbuf_ctl *, bus_size_t, int, bus_size_t, bus_size_t,
	    int, bus_dmamap_t *);
void	iommu_dvmamap_destroy(bus_dma_tag_t, bus_dmamap_t);
d70 2
a71 2
void	iommu_dvmamap_sync(bus_dma_tag_t, struct iommu_state *, bus_dmamap_t,
	    bus_addr_t, bus_size_t, int);
a81 11
#define IOMMUREG_READ(is, reg)				\
	bus_space_read_8((is)->is_bustag,		\
		(is)->is_iommu,				\
		IOMMUREG(reg))	

#define IOMMUREG_WRITE(is, reg, v)			\
	bus_space_write_8((is)->is_bustag,		\
		(is)->is_iommu,				\
		IOMMUREG(reg),				\
		(v))

a82 1

@


1.4.4.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.4.4.2
log
@Merge in trunk
@
text
@a42 1
	u_int			is_dvmaend;
@


1.4.4.3
log
@Merge in -current from about a week ago
@
text
@d58 5
a62 5
void	iommu_init(char *, struct iommu_state *, int, u_int32_t);
void	iommu_reset(struct iommu_state *);
void    iommu_enter(struct iommu_state *, vaddr_t, int64_t, int);
void    iommu_remove(struct iommu_state *, vaddr_t, size_t);
paddr_t iommu_extract(struct iommu_state *, vaddr_t);
d64 9
a72 9
int	iommu_dvmamap_load(bus_dma_tag_t, struct iommu_state *,
	    bus_dmamap_t, void *, bus_size_t, struct proc *, int);
void	iommu_dvmamap_unload(bus_dma_tag_t, struct iommu_state *,
	    bus_dmamap_t);
int	iommu_dvmamap_load_raw(bus_dma_tag_t, struct iommu_state *,
	    bus_dmamap_t, bus_dma_segment_t *, int, int, bus_size_t);
void	iommu_dvmamap_sync(bus_dma_tag_t, struct iommu_state *,
	    bus_dmamap_t, bus_addr_t, bus_size_t, int);
int	iommu_dvmamem_alloc(bus_dma_tag_t, struct iommu_state *,
d74 7
a80 7
	    int, int *, int);
void	iommu_dvmamem_free(bus_dma_tag_t, struct iommu_state *,
	    bus_dma_segment_t *, int);
int	iommu_dvmamem_map(bus_dma_tag_t, struct iommu_state *,
	    bus_dma_segment_t *, int, size_t, caddr_t *, int);
void	iommu_dvmamem_unmap(bus_dma_tag_t, struct iommu_state *,
	    caddr_t, size_t);
@


1.4.4.4
log
@Sync the SMP branch with 3.3
@
text
@a4 1
 * Copyright (c) 2003 Henric Jungheim
a34 59
#ifndef _SYS_TREE_H_
#include <sys/tree.h>
#endif

/*
 * per-Streaming Buffer state
 */
struct strbuf_ctl {
	bus_space_tag_t		sb_bustag;	/* streaming buffer registers */
	bus_space_handle_t	sb_sb;		/* Handle for our regs */
	struct iommu_state	*sb_iommu;	/* Associated IOMMU */
	/*
	 * Since implementing the per-map IOMMU state, these per-STC
	 * flush areas are not used other than as a boolean flag to indicate
	 * the presence of a working and enabled STC.  For inconsistency's
	 * sake, the "sb" pointers of iommu_state are sometimes used for the
	 * same purpose.  This should be consolidated.
	 */
	paddr_t			sb_flushpa;	/* to flush streaming buffers */
	volatile int64_t	*sb_flush;
};

/*
 * per-map STC flush area
 */
struct strbuf_flush {
	char	sbf_area[0x80];		/* Holds 64-byte long/aligned buffer */
	void	*sbf_flush;		/* Kernel virtual address of buffer */
	paddr_t	sbf_flushpa;		/* Physical address of buffer area */
};

/* 
 * per-map DVMA page table
 */
struct iommu_page_entry {
	SPLAY_ENTRY(iommu_page_entry) ipe_node;
	paddr_t	ipe_pa;
	vaddr_t	ipe_va;
};
struct iommu_page_map {
	SPLAY_HEAD(iommu_page_tree, iommu_page_entry) ipm_tree;
	int ipm_maxpage;	/* Size of allocated page map */
	int ipm_pagecnt;	/* Number of entries in use */
	struct iommu_page_entry	ipm_map[1];
};

/*
 * per-map IOMMU state
 *
 * This is what bus_dvmamap_t'c _dm_cookie should be pointing to.
 */
struct iommu_map_state {
	struct strbuf_flush ims_flush;	/* flush should be first (alignment) */
	struct strbuf_ctl *ims_sb;	/* Link to parent */
	int ims_flags;
	struct iommu_page_map ims_map;	/* map must be last (array at end) */
};
#define IOMMU_MAP_STREAM	1

d44 1
a44 1
	int64_t			is_cr;		/* Control register value */
d47 3
a49 1
	struct strbuf_ctl	*is_sb[2];	/* Streaming buffers if any */
d53 2
a54 1
	bus_space_handle_t	is_iommu;	/* IOMMU registers */
d60 2
d63 1
a63 6
int64_t iommu_lookup_tte(struct iommu_state *, vaddr_t);
int64_t iommu_fetch_tte(struct iommu_state *, paddr_t);
int	iommu_dvmamap_create(bus_dma_tag_t, struct iommu_state *,
	    struct strbuf_ctl *, bus_size_t, int, bus_size_t, bus_size_t,
	    int, bus_dmamap_t *);
void	iommu_dvmamap_destroy(bus_dma_tag_t, bus_dmamap_t);
d70 2
a71 2
void	iommu_dvmamap_sync(bus_dma_tag_t, struct iommu_state *, bus_dmamap_t,
	    bus_addr_t, bus_size_t, int);
a81 11
#define IOMMUREG_READ(is, reg)				\
	bus_space_read_8((is)->is_bustag,		\
		(is)->is_iommu,				\
		IOMMUREG(reg))	

#define IOMMUREG_WRITE(is, reg, v)			\
	bus_space_write_8((is)->is_bustag,		\
		(is)->is_iommu,				\
		IOMMUREG(reg),				\
		(v))

a82 1

@


1.4.4.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d120 11
a130 10
/* bus_dma_tag_t implementation functions */
int	iommu_dvmamap_create(bus_dma_tag_t, bus_dma_tag_t, struct strbuf_ctl *,
	    bus_size_t, int, bus_size_t, bus_size_t, int, bus_dmamap_t *);
void	iommu_dvmamap_destroy(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t);
int	iommu_dvmamap_load(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t, void *,
	    bus_size_t, struct proc *, int);
void	iommu_dvmamap_unload(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t);
int	iommu_dvmamap_load_raw(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t,
	    bus_dma_segment_t *, int, bus_size_t, int);
void	iommu_dvmamap_sync(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t,
d132 9
a140 7
int	iommu_dvmamem_alloc(bus_dma_tag_t, bus_dma_tag_t, bus_size_t,
	    bus_size_t, bus_size_t, bus_dma_segment_t *, int, int *, int);
void	iommu_dvmamem_free(bus_dma_tag_t, bus_dma_tag_t, bus_dma_segment_t *,
	    int);
int	iommu_dvmamem_map(bus_dma_tag_t, bus_dma_tag_t, bus_dma_segment_t *,
	    int, size_t, caddr_t *, int);
void	iommu_dvmamem_unmap(bus_dma_tag_t, bus_dma_tag_t, caddr_t, size_t);
@


1.3
log
@Merge with NetBSD:
better handling of boundary conditions
add iommu_extract debugging function
@
text
@d1 2
a2 2
/*	$OpenBSD: iommuvar.h,v 1.2 2001/08/18 21:30:00 jason Exp $	*/
/*	$NetBSD: iommuvar.h,v 1.7 2001/07/20 00:07:13 eeh Exp $	*/
d48 1
a48 1
	volatile int64_t	is_flush;
d53 1
a53 1
	struct iommu_strbuf	*is_sb;		/* streaming buffer */
d61 1
a79 1
paddr_t	iommu_extract __P((struct iommu_state *, vaddr_t));
@


1.2
log
@RCSids
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d79 1
@


1.1
log
@enough to get sbus.o from NetBSD
@
text
@d1 1
@

