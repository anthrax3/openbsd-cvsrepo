head	1.24;
access;
symbols
	OPENBSD_6_1:1.24.0.2
	OPENBSD_6_1_BASE:1.24
	OPENBSD_6_0:1.23.0.10
	OPENBSD_6_0_BASE:1.23
	OPENBSD_5_9:1.23.0.6
	OPENBSD_5_9_BASE:1.23
	OPENBSD_5_8:1.23.0.8
	OPENBSD_5_8_BASE:1.23
	OPENBSD_5_7:1.23.0.2
	OPENBSD_5_7_BASE:1.23
	OPENBSD_5_6:1.23.0.4
	OPENBSD_5_6_BASE:1.23
	OPENBSD_5_5:1.22.0.26
	OPENBSD_5_5_BASE:1.22
	OPENBSD_5_4:1.22.0.22
	OPENBSD_5_4_BASE:1.22
	OPENBSD_5_3:1.22.0.20
	OPENBSD_5_3_BASE:1.22
	OPENBSD_5_2:1.22.0.18
	OPENBSD_5_2_BASE:1.22
	OPENBSD_5_1_BASE:1.22
	OPENBSD_5_1:1.22.0.16
	OPENBSD_5_0:1.22.0.14
	OPENBSD_5_0_BASE:1.22
	OPENBSD_4_9:1.22.0.12
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.22.0.10
	OPENBSD_4_8_BASE:1.22
	OPENBSD_4_7:1.22.0.6
	OPENBSD_4_7_BASE:1.22
	OPENBSD_4_6:1.22.0.8
	OPENBSD_4_6_BASE:1.22
	OPENBSD_4_5:1.22.0.4
	OPENBSD_4_5_BASE:1.22
	OPENBSD_4_4:1.22.0.2
	OPENBSD_4_4_BASE:1.22
	OPENBSD_4_3:1.20.0.2
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.17.0.2
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.15.0.2
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.14.0.2
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.13.0.2
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.12.0.10
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.6
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.12.0.8
	OPENBSD_3_6_BASE:1.12
	SMP_SYNC_A:1.12
	SMP_SYNC_B:1.12
	OPENBSD_3_5:1.12.0.4
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.12.0.2
	OPENBSD_3_4_BASE:1.12
	UBC_SYNC_A:1.11
	OPENBSD_3_3:1.11.0.2
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.9.0.4
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	UBC_SYNC_B:1.9
	UBC:1.6.0.2
	UBC_BASE:1.6
	SMP:1.5.0.4
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5;
locks; strict;
comment	@ * @;


1.24
date	2016.08.23.03.28.01;	author guenther;	state Exp;
branches;
next	1.23;
commitid	sVHD5kblxhZITIq0;

1.23
date	2014.07.12.18.44.43;	author tedu;	state Exp;
branches;
next	1.22;
commitid	uKVPYMN2MLxdZxzH;

1.22
date	2008.06.11.05.15.43;	author kettenis;	state Exp;
branches;
next	1.21;

1.21
date	2008.03.08.16.33.41;	author kettenis;	state Exp;
branches;
next	1.20;

1.20
date	2008.02.17.22.01.27;	author kettenis;	state Exp;
branches;
next	1.19;

1.19
date	2007.10.01.16.11.19;	author krw;	state Exp;
branches;
next	1.18;

1.18
date	2007.09.18.00.46.41;	author krw;	state Exp;
branches;
next	1.17;

1.17
date	2007.04.10.17.47.55;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2007.04.04.18.38.54;	author kettenis;	state Exp;
branches;
next	1.15;

1.15
date	2007.01.09.22.37.18;	author kettenis;	state Exp;
branches;
next	1.14;

1.14
date	2006.06.27.20.20.48;	author jason;	state Exp;
branches;
next	1.13;

1.13
date	2006.02.25.17.48.39;	author kettenis;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.12.05.57.43;	author henric;	state Exp;
branches;
next	1.11;

1.11
date	2003.03.06.08.26.08;	author henric;	state Exp;
branches;
next	1.10;

1.10
date	2003.02.17.01.29.20;	author henric;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.14.03.16.00;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.14.01.26.44;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.05.18.34.39;	author jason;	state Exp;
branches;
next	1.6;

1.6
date	2001.12.14.14.53.48;	author jason;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2001.10.07.15.27.12;	author jason;	state Exp;
branches
	1.5.4.1;
next	1.4;

1.4
date	2001.10.01.16.55.57;	author jason;	state Exp;
branches;
next	1.3;

1.3
date	2001.09.15.07.00.12;	author jason;	state Exp;
branches;
next	1.2;

1.2
date	2001.08.29.02.47.58;	author jason;	state Exp;
branches;
next	1.1;

1.1
date	2001.08.22.12.10.34;	author art;	state Exp;
branches;
next	;

1.5.4.1
date	2001.10.31.03.07.57;	author nate;	state Exp;
branches;
next	1.5.4.2;

1.5.4.2
date	2002.03.06.02.04.46;	author niklas;	state Exp;
branches;
next	1.5.4.3;

1.5.4.3
date	2002.03.28.10.57.11;	author niklas;	state Exp;
branches;
next	1.5.4.4;

1.5.4.4
date	2003.03.27.23.42.35;	author niklas;	state Exp;
branches;
next	1.5.4.5;

1.5.4.5
date	2004.02.19.10.49.59;	author niklas;	state Exp;
branches;
next	;

1.6.2.1
date	2002.06.11.03.38.42;	author art;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2003.05.19.21.46.57;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.24
log
@Convert %q to %ll in format strings

ok natano@@ krw@@
@
text
@/*	$OpenBSD: ebus.c,v 1.23 2014/07/12 18:44:43 tedu Exp $	*/
/*	$NetBSD: ebus.c,v 1.24 2001/07/25 03:49:54 eeh Exp $	*/

/*
 * Copyright (c) 1999, 2000 Matthew R. Green
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * UltraSPARC 5 and beyond ebus support.
 *
 * note that this driver is not complete:
 *	- ebus2 dma code is completely unwritten
 *	- interrupt establish is written and appears to work
 *	- bus map code is written and appears to work
 */

#ifdef DEBUG
#define	EDB_PROM	0x01
#define EDB_CHILD	0x02
#define	EDB_INTRMAP	0x04
#define EDB_BUSMAP	0x08
#define EDB_BUSDMA	0x10
#define EDB_INTR	0x20
int ebus_debug = 0x0;
#define DPRINTF(l, s)   do { if (ebus_debug & l) printf s; } while (0)
#else
#define DPRINTF(l, s)
#endif

#include <sys/param.h>
#include <sys/conf.h>
#include <sys/device.h>
#include <sys/errno.h>
#include <sys/extent.h>
#include <sys/malloc.h>
#include <sys/systm.h>
#include <sys/time.h>

#define _SPARC_BUS_DMA_PRIVATE
#include <machine/bus.h>
#include <machine/autoconf.h>
#include <machine/openfirm.h>

#include <dev/pci/pcivar.h>
#include <dev/pci/pcireg.h>
#include <dev/pci/pcidevs.h>

#include <sparc64/dev/iommureg.h>
#include <sparc64/dev/iommuvar.h>
#include <sparc64/dev/psychoreg.h>
#include <sparc64/dev/psychovar.h>
#include <sparc64/dev/ebusreg.h>
#include <sparc64/dev/ebusvar.h>
#include <sparc64/sparc64/cache.h>

int	ebus_match(struct device *, void *, void *);
void	ebus_attach(struct device *, struct device *, void *);

struct cfattach ebus_ca = {
	sizeof(struct ebus_softc), ebus_match, ebus_attach
};

struct cfdriver ebus_cd = {
	NULL, "ebus", DV_DULL
};


void	ebus_find_ino(struct ebus_softc *, struct ebus_attach_args *);
int	ebus_find_node(struct pci_attach_args *);

/*
 * here are our bus space and bus dma routines.
 */
static paddr_t ebus_bus_mmap(bus_space_tag_t, bus_space_tag_t, bus_addr_t,
    off_t, int, int);
static int _ebus_bus_map(bus_space_tag_t, bus_space_tag_t, bus_addr_t,
    bus_size_t, int, bus_space_handle_t *);
bus_space_tag_t ebus_alloc_mem_tag(struct ebus_softc *, bus_space_tag_t);
bus_space_tag_t ebus_alloc_io_tag(struct ebus_softc *, bus_space_tag_t);
bus_space_tag_t _ebus_alloc_bus_tag(struct ebus_softc *sc, const char *,
    bus_space_tag_t, int);


int
ebus_match(struct device *parent, void *match, void *aux)
{
	struct pci_attach_args *pa = aux;
	char name[10];
	int node;

	/* Only attach if there's a PROM node. */
	node = PCITAG_NODE(pa->pa_tag);
	if (node == -1) return (0);

	/* Match a real ebus */
	OF_getprop(node, "name", &name, sizeof(name));
	if (PCI_CLASS(pa->pa_class) == PCI_CLASS_BRIDGE &&
	    PCI_VENDOR(pa->pa_id) == PCI_VENDOR_SUN &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_SUN_EBUS &&
		strcmp(name, "ebus") == 0)
		return (1);

	/* Or a real RIO ebus */
	if (PCI_CLASS(pa->pa_class) == PCI_CLASS_BRIDGE &&
	    PCI_VENDOR(pa->pa_id) == PCI_VENDOR_SUN &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_SUN_RIO_EBUS &&
		strcmp(name, "ebus") == 0)
		return (1);

	/* Or a fake ebus */
	if (PCI_CLASS(pa->pa_class) == PCI_CLASS_BRIDGE &&
	    PCI_VENDOR(pa->pa_id) == PCI_VENDOR_ALTERA &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ALTERA_EBUS &&
		strcmp(name, "ebus") == 0)
		return (1);

	/* Or a PCI-ISA bridge XXX I hope this is on-board. */
	if (PCI_CLASS(pa->pa_class) == PCI_CLASS_BRIDGE &&
	    PCI_SUBCLASS(pa->pa_class) == PCI_SUBCLASS_BRIDGE_ISA) {
		return (1);
	}

	return (0);
}

/*
 * attach an ebus and all its children.  this code is modeled
 * after the sbus code which does similar things.
 */
void
ebus_attach(struct device *parent, struct device *self, void *aux)
{
	struct ebus_softc *sc = (struct ebus_softc *)self;
	struct pci_attach_args *pa = aux;
	struct ebus_attach_args eba;
	struct ebus_interrupt_map_mask *immp;
	int node, nmapmask, error;

	printf("\n");

	sc->sc_memtag = ebus_alloc_mem_tag(sc, pa->pa_memt);
	sc->sc_iotag = ebus_alloc_io_tag(sc, pa->pa_iot);
	sc->sc_dmatag = ebus_alloc_dma_tag(sc, pa->pa_dmat);

	node = PCITAG_NODE(pa->pa_tag);
	if (node == -1)
		panic("could not find ebus node");

	sc->sc_node = node;

	/*
	 * fill in our softc with information from the prom
	 */
	sc->sc_intmap = NULL;
	sc->sc_range = NULL;
	error = getprop(node, "interrupt-map",
			sizeof(struct ebus_interrupt_map),
			&sc->sc_nintmap, (void **)&sc->sc_intmap);
	switch (error) {
	case 0:
		immp = &sc->sc_intmapmask;
		error = getprop(node, "interrupt-map-mask",
			    sizeof(struct ebus_interrupt_map_mask), &nmapmask,
			    (void **)&immp);
		if (error)
			panic("could not get ebus interrupt-map-mask");
		if (nmapmask != 1)
			panic("ebus interrupt-map-mask is broken");
		break;
	case ENOENT:
		break;
	default:
		panic("ebus interrupt-map: error %d", error);
		break;
	}

	error = getprop(node, "ranges", sizeof(struct ebus_ranges),
	    &sc->sc_nrange, &sc->sc_range);
	if (error)
		panic("ebus ranges: error %d", error);

	/*
	 * now attach all our children
	 */
	DPRINTF(EDB_CHILD, ("ebus node %08x, searching children...\n", node));
	for (node = firstchild(node); node; node = nextsibling(node)) {
		if (!checkstatus(node))
			continue;

		if (ebus_setup_attach_args(sc, node, &eba) != 0) {
			DPRINTF(EDB_CHILD,
			    ("ebus_attach: %s: incomplete\n",
			    getpropstring(node, "name")));
			continue;
		} else {
			DPRINTF(EDB_CHILD, ("- found child `%s', attaching\n",
			    eba.ea_name));
			(void)config_found(self, &eba, ebus_print);
		}
		ebus_destroy_attach_args(&eba);
	}
}

int
ebus_setup_attach_args(struct ebus_softc *sc, int node,
    struct ebus_attach_args *ea)
{
	int	n, rv;

	bzero(ea, sizeof(struct ebus_attach_args));
	rv = getprop(node, "name", 1, &n, (void **)&ea->ea_name);
	if (rv != 0)
		return (rv);
	ea->ea_name[n] = '\0';

	ea->ea_node = node;
	ea->ea_memtag = sc->sc_memtag;
	ea->ea_iotag = sc->sc_iotag;
	ea->ea_dmatag = sc->sc_dmatag;

	rv = getprop(node, "reg", sizeof(struct ebus_regs), &ea->ea_nregs,
	    (void **)&ea->ea_regs);
	if (rv)
		return (rv);

	rv = getprop(node, "address", sizeof(u_int32_t), &ea->ea_nvaddrs,
	    (void **)&ea->ea_vaddrs);
	if (rv != ENOENT) {
		if (rv)
			return (rv);

		if (ea->ea_nregs != ea->ea_nvaddrs)
			printf("ebus loses: device %s: %d regs and %d addrs\n",
			    ea->ea_name, ea->ea_nregs, ea->ea_nvaddrs);
	} else
		ea->ea_nvaddrs = 0;

	if (getprop(node, "interrupts", sizeof(u_int32_t), &ea->ea_nintrs,
	    (void **)&ea->ea_intrs))
		ea->ea_nintrs = 0;
	else
		ebus_find_ino(sc, ea);

	return (0);
}

void
ebus_destroy_attach_args(struct ebus_attach_args *ea)
{
	if (ea->ea_name)
		free((void *)ea->ea_name, M_DEVBUF, 0);
	if (ea->ea_regs)
		free((void *)ea->ea_regs, M_DEVBUF, 0);
	if (ea->ea_intrs)
		free((void *)ea->ea_intrs, M_DEVBUF, 0);
	if (ea->ea_vaddrs)
		free((void *)ea->ea_vaddrs, M_DEVBUF, 0);
}

int
ebus_print(void *aux, const char *p)
{
	struct ebus_attach_args *ea = aux;
	int i;

	if (p)
		printf("\"%s\" at %s", ea->ea_name, p);
	for (i = 0; i < ea->ea_nregs; i++)
		printf("%s %x-%x", i == 0 ? " addr" : ",",
		    ea->ea_regs[i].lo,
		    ea->ea_regs[i].lo + ea->ea_regs[i].size - 1);
	for (i = 0; i < ea->ea_nintrs; i++)
		printf(" ivec 0x%x", ea->ea_intrs[i]);
	return (UNCONF);
}


/*
 * find the INO values for each interrupt and fill them in.
 *
 * for each "reg" property of this device, mask its hi and lo
 * values with the "interrupt-map-mask"'s hi/lo values, and also
 * mask the interrupt number with the interrupt mask.  search the
 * "interrupt-map" list for matching values of hi, lo and interrupt
 * to give the INO for this interrupt.
 */
void
ebus_find_ino(struct ebus_softc *sc, struct ebus_attach_args *ea)
{
	u_int32_t hi, lo, intr;
	int i, j, k;

	if (sc->sc_nintmap == 0) {
		for (i = 0; i < ea->ea_nintrs; i++) {
			OF_mapintr(ea->ea_node, &ea->ea_intrs[i],
				sizeof(ea->ea_intrs[0]),
				sizeof(ea->ea_intrs[0]));
		}
		return;
	}

	DPRINTF(EDB_INTRMAP,
	    ("ebus_find_ino: searching %d interrupts", ea->ea_nintrs));

	for (j = 0; j < ea->ea_nintrs; j++) {

		intr = ea->ea_intrs[j] & sc->sc_intmapmask.intr;

		DPRINTF(EDB_INTRMAP,
		    ("; intr %x masked to %x", ea->ea_intrs[j], intr));
		for (i = 0; i < ea->ea_nregs; i++) {
			hi = ea->ea_regs[i].hi & sc->sc_intmapmask.hi;
			lo = ea->ea_regs[i].lo & sc->sc_intmapmask.lo;

			DPRINTF(EDB_INTRMAP,
			    ("; reg hi.lo %08x.%08x masked to %08x.%08x",
			    ea->ea_regs[i].hi, ea->ea_regs[i].lo, hi, lo));
			for (k = 0; k < sc->sc_nintmap; k++) {
				DPRINTF(EDB_INTRMAP,
				    ("; checking hi.lo %08x.%08x intr %x",
				    sc->sc_intmap[k].hi, sc->sc_intmap[k].lo,
				    sc->sc_intmap[k].intr));
				if (hi == sc->sc_intmap[k].hi &&
				    lo == sc->sc_intmap[k].lo &&
				    intr == sc->sc_intmap[k].intr) {
					ea->ea_intrs[j] =
					    sc->sc_intmap[k].cintr;
					DPRINTF(EDB_INTRMAP,
					    ("; FOUND IT! changing to %d\n",
					    sc->sc_intmap[k].cintr));
					goto next_intr;
				}
			}
		}
next_intr:;
	}
}

bus_space_tag_t
ebus_alloc_mem_tag(struct ebus_softc *sc, bus_space_tag_t parent)
{
        return (_ebus_alloc_bus_tag(sc, "mem", parent,
            0x02));	/* 32-bit mem space (where's the #define???) */
}

bus_space_tag_t
ebus_alloc_io_tag(struct ebus_softc *sc, bus_space_tag_t parent)
{
        return (_ebus_alloc_bus_tag(sc, "io", parent,
            0x01));	/* IO space (where's the #define???) */
}

/*
 * bus space and bus dma below here
 */
bus_space_tag_t
_ebus_alloc_bus_tag(struct ebus_softc *sc, const char *name,
    bus_space_tag_t parent, int ss)
{
	struct sparc_bus_space_tag *bt;

	bt = malloc(sizeof(*bt), M_DEVBUF, M_NOWAIT | M_ZERO);
	if (bt == NULL)
		panic("could not allocate ebus bus tag");

	snprintf(bt->name, sizeof(bt->name), "%s_%s",
		sc->sc_dev.dv_xname, name);
	bt->cookie = sc;
	bt->parent = parent;
	bt->default_type = ss;
	bt->asi = parent->asi;
	bt->sasi = parent->sasi;
	bt->sparc_bus_map = _ebus_bus_map;
	bt->sparc_bus_mmap = ebus_bus_mmap;

	return (bt);
}

bus_dma_tag_t
ebus_alloc_dma_tag(struct ebus_softc *sc, bus_dma_tag_t pdt)
{
	bus_dma_tag_t dt;

	dt = malloc(sizeof(*dt), M_DEVBUF, M_NOWAIT | M_ZERO);
	if (dt == NULL)
		panic("could not allocate ebus dma tag");

	dt->_cookie = sc;
	dt->_parent = pdt;
	sc->sc_dmatag = dt;
	return (dt);
}

/*
 * bus space support.  <sparc64/dev/psychoreg.h> has a discussion
 * about PCI physical addresses, which also applies to ebus.
 */
static int
_ebus_bus_map(bus_space_tag_t t, bus_space_tag_t t0, bus_addr_t offset,
    bus_size_t size, int flags, bus_space_handle_t *hp)
{
	struct ebus_softc *sc = t->cookie;
	struct ebus_ranges *range = sc->sc_range;
	bus_addr_t hi, lo;
	int i;

	DPRINTF(EDB_BUSMAP,
	    ("\n_ebus_bus_map: type %d off %016llx sz %x flags %d",
	    (int)t->default_type, (unsigned long long)offset, (int)size,
	    (int)flags));

	if (t->parent == 0 || t->parent->sparc_bus_map == 0) {
		printf("\n_ebus_bus_map: invalid parent");
		return (EINVAL);
	}

	t = t->parent;

	if (flags & BUS_SPACE_MAP_PROMADDRESS) {
		return ((*t->sparc_bus_map)
		    (t, t0, offset, size, flags, hp));
	}

	hi = offset >> 32UL;
	lo = offset & 0xffffffff;

	DPRINTF(EDB_BUSMAP, (" (hi %08x lo %08x)", (u_int)hi, (u_int)lo));
	for (i = 0; i < sc->sc_nrange; i++) {
		bus_addr_t pciaddr;

		if (hi != range[i].child_hi)
			continue;
		if (lo < range[i].child_lo ||
		    (lo + size) > (range[i].child_lo + range[i].size))
			continue;

		if(((range[i].phys_hi >> 24) & 3) != t->default_type)
			continue;

		pciaddr = ((bus_addr_t)range[i].phys_mid << 32UL) |
				       range[i].phys_lo;
		pciaddr += lo;
		DPRINTF(EDB_BUSMAP,
		    ("\n_ebus_bus_map: mapping space %x paddr offset %llx "
		    "pciaddr %llx\n", (int)t->default_type,
		    (unsigned long long)offset, (unsigned long long)pciaddr));
                return ((*t->sparc_bus_map)(t, t0, pciaddr, size, flags, hp));
	}
	DPRINTF(EDB_BUSMAP, (": FAILED\n"));
	return (EINVAL);
}

static paddr_t
ebus_bus_mmap(bus_space_tag_t t, bus_space_tag_t t0, bus_addr_t paddr,
    off_t off, int prot, int flags)
{
	bus_addr_t offset = paddr;
	struct ebus_softc *sc = t->cookie;
	struct ebus_ranges *range = sc->sc_range;
	int i;

	if (t->parent == 0 || t->parent->sparc_bus_mmap == 0) {
		printf("\nebus_bus_mmap: invalid parent");
		return (-1);
        }

	t = t->parent;

	for (i = 0; i < sc->sc_nrange; i++) {
		bus_addr_t paddr = ((bus_addr_t)range[i].child_hi << 32) |
					        range[i].child_lo;

		if (offset != paddr)
			continue;

		DPRINTF(EDB_BUSMAP, ("\n_ebus_bus_mmap: mapping paddr %llx\n",
		    (unsigned long long)paddr));
		return ((*t->sparc_bus_mmap)(t, t0, paddr, off, prot, flags));
	}

	return (-1);
}
@


1.23
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: ebus.c,v 1.22 2008/06/11 05:15:43 kettenis Exp $	*/
d468 2
a469 2
		    ("\n_ebus_bus_map: mapping space %x paddr offset %qx "
		    "pciaddr %qx\n", (int)t->default_type,
d500 1
a500 1
		DPRINTF(EDB_BUSMAP, ("\n_ebus_bus_mmap: mapping paddr %qx\n",
@


1.22
log
@Match the Altera EBus found on the Tadpole SPARCLE.
@
text
@d1 1
a1 1
/*	$OpenBSD: ebus.c,v 1.21 2008/03/08 16:33:41 kettenis Exp $	*/
d275 1
a275 1
		free((void *)ea->ea_name, M_DEVBUF);
d277 1
a277 1
		free((void *)ea->ea_regs, M_DEVBUF);
d279 1
a279 1
		free((void *)ea->ea_intrs, M_DEVBUF);
d281 1
a281 1
		free((void *)ea->ea_vaddrs, M_DEVBUF);
@


1.21
log
@Check "status" property.  Since the PROM marks the floppy controller device
as "disabled" if no floppy drive is connected, this will get rid of the
"unconfigured" message for the floppy controller on machines that don't have
a floppy drive.
@
text
@d1 1
a1 1
/*	$OpenBSD: ebus.c,v 1.20 2008/02/17 22:01:27 kettenis Exp $	*/
d131 7
@


1.20
log
@We're not printing interrupt priority levels (ot whatever ipl stands for) but
interrupt vectors, so change it to ivec and print them in hex.
@
text
@d1 1
a1 1
/*	$OpenBSD: ebus.c,v 1.19 2007/10/01 16:11:19 krw Exp $	*/
d204 3
@


1.19
log
@More easy bzero() -> M_ZERO. Use 'p = malloc(sizeof(*p) ...' where
obvious.
@
text
@d1 1
a1 1
/*	$OpenBSD: ebus.c,v 1.18 2007/09/18 00:46:41 krw Exp $	*/
d287 1
a287 1
		printf(" ipl %d", ea->ea_intrs[i]);
@


1.18
log
@Only the most obvious bzero() -> M_ZERO changes. No cast changes, no
MALLOC/FREE, etc. Just adding M_ZERO to malloc() and deleting an
immediately adjacent bzero().
@
text
@d1 1
a1 1
/*	$OpenBSD: ebus.c,v 1.17 2007/04/10 17:47:55 miod Exp $	*/
d398 1
a398 2
	dt = (bus_dma_tag_t)
		malloc(sizeof(struct sparc_bus_dma_tag), M_DEVBUF, M_NOWAIT);
a401 1
	bzero(dt, sizeof *dt);
@


1.17
log
@``it's'' -> ``its'' when the grammar gods require this change.
@
text
@d1 1
a1 1
/*	$OpenBSD: ebus.c,v 1.16 2007/04/04 18:38:54 kettenis Exp $	*/
d376 1
a376 1
	bt = malloc(sizeof(*bt), M_DEVBUF, M_NOWAIT);
a379 1
	bzero(bt, sizeof *bt);
@


1.16
log
@Add support for ebus at mainbus, as found on machines with pyro(4) like the
v215.
@
text
@d1 1
a1 1
/*	$OpenBSD: ebus.c,v 1.15 2007/01/09 22:37:18 kettenis Exp $	*/
d144 1
a144 1
 * attach an ebus and all it's children.  this code is modeled
d295 1
a295 1
 * for each "reg" property of this device, mask it's hi and lo
@


1.15
log
@Adjust for USIII to RIO EBus renaming.
@
text
@d1 1
a1 1
/*	$OpenBSD: ebus.c,v 1.14 2006/06/27 20:20:48 jason Exp $	*/
a91 4
int	ebus_setup_attach_args(struct ebus_softc *, int,
	    struct ebus_attach_args *);
void	ebus_destroy_attach_args(struct ebus_attach_args *);
int	ebus_print(void *, const char *);
d195 1
a195 1
	    &sc->sc_nrange, (void **)&sc->sc_range);
d420 1
d448 1
a448 1
		if (hi != sc->sc_range[i].child_hi)
d450 2
a451 3
		if (lo < sc->sc_range[i].child_lo ||
		    (lo + size) >
		      (sc->sc_range[i].child_lo + sc->sc_range[i].size))
d454 1
a454 1
		if(((sc->sc_range[i].phys_hi >> 24) & 3) != t->default_type)
d457 2
a458 2
		pciaddr = ((bus_addr_t)sc->sc_range[i].phys_mid << 32UL) |
				       sc->sc_range[i].phys_lo;
a463 1
		/* pass it onto the psycho */
d476 1
d487 2
a488 3
		bus_addr_t paddr =
		    ((bus_addr_t)sc->sc_range[i].child_hi << 32) |
		    sc->sc_range[i].child_lo;
a499 1

@


1.14
log
@don't bother printing "{se}bus: %s incomplete" for devices missing a reg
property.  They're not interesting.
@
text
@d1 1
a1 1
/*	$OpenBSD: ebus.c,v 1.13 2006/02/25 17:48:39 kettenis Exp $	*/
d131 1
a131 1
	/* Or a real ebus III */
d134 1
a134 1
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_SUN_EBUSIII &&
@


1.13
log
@Put quotation marks around names of unconfigured devices.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ebus.c,v 1.12 2003/06/12 05:57:43 henric Exp $	*/
a207 2
		char *name = getpropstring(node, "name");

d209 3
a211 1
			printf("ebus_attach: %s: incomplete\n", name);
@


1.12
log
@There is no sense in calling one function when you really want
another.  The bus_space code is perfectly capable of finding
the parent handler itself.

"heck" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ebus.c,v 1.11 2003/03/06 08:26:08 henric Exp $	*/
d285 1
a285 1
		printf("%s at %s", ea->ea_name, p);
@


1.11
log
@The existing IOMMU code had a rounding problem that was most noticeable
on faster systems under heavy network load.  This replaces some of the
unreadable iommu functions with something a little less dense and a lot
less crash prone.

The bus_dma function pointer/cookie handling was broken.  Change them
to work like the stacked bus_space drivers (where "work" is the key
word).

Tested my many (thanks).

ok jason@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ebus.c,v 1.10 2003/02/17 01:29:20 henric Exp $	*/
a105 2
static void *ebus_intr_establish(bus_space_tag_t, bus_space_tag_t, int, int,
    int, int (*)(void *), void *);
d394 1
a394 1
	bt->sparc_intr_establish = ebus_intr_establish;
a503 18
}

/*
 * install an interrupt handler for a PCI device
 */
void *
ebus_intr_establish(bus_space_tag_t t, bus_space_tag_t t0, int pri, int level,
    int flags, int (*handler)(void *), void *arg)
{
	if (t->parent == 0 || t->parent->sparc_bus_mmap == 0) {
		printf("\nebus_bus_mmap: invalid parent");
		return (NULL);
        }

	t = t->parent;

	return ((*t->sparc_intr_establish)(t, t0, pri, level, flags,
	    handler, arg));
@


1.10
log
@
Add support for the Sun Enterprise 450
Reduce the size of a GENERIC kernel by ~190k
Remove the nasty pointer/bus_space_handle_t casts
Adds debug bus_space code including the ability to trace
    bus operations (it actually works now).

The following rules are now followed (and verfified by the debug
code):

1.  A "bus_space_handle_t" may only be used with the
    "bus_space_tag_t" that created it.
2.  Only "bus_space_map()" may create "bus_space_handle_t"s.
3.  A "bus_space_handle_t" may not be modified after it has
    been created (other than being destroyed by "bus_space_unmap()").


Thanks to help from mcbride, marc, jason, drahn, to anyone that might
have slipped my mind at the moment.

ok jason@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ebus.c,v 1.9 2002/03/14 03:16:00 millert Exp $	*/
a107 11
static int ebus_dmamap_load(bus_dma_tag_t, bus_dmamap_t, void *, bus_size_t,
    struct proc *, int);
static void ebus_dmamap_unload(bus_dma_tag_t, bus_dmamap_t);
static void ebus_dmamap_sync(bus_dma_tag_t, bus_dmamap_t, bus_addr_t,
    bus_size_t, int);
int ebus_dmamem_alloc(bus_dma_tag_t, bus_size_t, bus_size_t, bus_size_t,
    bus_dma_segment_t *, int, int *, int);
void ebus_dmamem_free(bus_dma_tag_t, bus_dma_segment_t *, int);
int ebus_dmamem_map(bus_dma_tag_t, bus_dma_segment_t *, int, size_t,
    caddr_t *, int);
void ebus_dmamem_unmap(bus_dma_tag_t, caddr_t, size_t);
a412 15
#define PCOPY(x)	dt->x = pdt->x
	PCOPY(_dmamap_create);
	PCOPY(_dmamap_destroy);
	dt->_dmamap_load = ebus_dmamap_load;
	PCOPY(_dmamap_load_mbuf);
	PCOPY(_dmamap_load_uio);
	PCOPY(_dmamap_load_raw);
	dt->_dmamap_unload = ebus_dmamap_unload;
	dt->_dmamap_sync = ebus_dmamap_sync;
	dt->_dmamem_alloc = ebus_dmamem_alloc;
	dt->_dmamem_free = ebus_dmamem_free;
	dt->_dmamem_map = ebus_dmamem_map;
	dt->_dmamem_unmap = ebus_dmamem_unmap;
	PCOPY(_dmamem_mmap);
#undef	PCOPY
a525 50
/*
 * bus dma support
 */
int
ebus_dmamap_load(bus_dma_tag_t t, bus_dmamap_t map, void *buf,
    bus_size_t buflen, struct proc *p, int flags)
{
	return (bus_dmamap_load(t->_parent, map, buf, buflen, p, flags));
}

void
ebus_dmamap_unload(bus_dma_tag_t t, bus_dmamap_t map)
{
	bus_dmamap_unload(t->_parent, map);
}

void
ebus_dmamap_sync(bus_dma_tag_t t, bus_dmamap_t map, bus_addr_t offset,
    bus_size_t len, int ops)
{
	bus_dmamap_sync(t->_parent, map, offset, len, ops);
}

int
ebus_dmamem_alloc(bus_dma_tag_t t, bus_size_t size, bus_size_t alignment,
    bus_size_t boundary, bus_dma_segment_t *segs, int nsegs, int *rsegs,
    int flags)
{
	return (bus_dmamem_alloc(t->_parent, size, alignment, boundary, segs,
	    nsegs, rsegs, flags));
}

void
ebus_dmamem_free(bus_dma_tag_t t, bus_dma_segment_t *segs, int nsegs)
{
	bus_dmamem_free(t->_parent, segs, nsegs);
}

int
ebus_dmamem_map(bus_dma_tag_t t, bus_dma_segment_t *segs, int nsegs,
    size_t size, caddr_t *kvap, int flags)
{
	return (bus_dmamem_map(t->_parent, segs, nsegs, size, kvap, flags));
}

void
ebus_dmamem_unmap(bus_dma_tag_t t, caddr_t kva, size_t size)
{
	return (bus_dmamem_unmap(t->_parent, kva, size));
}
@


1.9
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: ebus.c,v 1.8 2002/03/14 01:26:44 millert Exp $	*/
d102 8
a109 9
static paddr_t ebus_bus_mmap(bus_space_tag_t, bus_addr_t, off_t, int, int);
static int _ebus_bus_map(bus_space_tag_t, bus_type_t, bus_addr_t,
				bus_size_t, int, vaddr_t,
				bus_space_handle_t *);
static void *ebus_intr_establish(bus_space_tag_t, int, int, int,
				int (*)(void *), void *);

static int ebus_dmamap_load(bus_dma_tag_t, bus_dmamap_t, void *,
			  bus_size_t, struct proc *, int);
d112 1
a112 1
				  bus_size_t, int);
d114 1
a114 1
			   bus_dma_segment_t *, int, int *, int);
d117 1
a117 1
			 caddr_t *, int);
d119 5
d126 1
a126 4
ebus_match(parent, match, aux)
	struct device *parent;
	void *match;
	void *aux;
d165 1
a165 3
ebus_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d175 2
a176 3
	sc->sc_memtag = pa->pa_memt;
	sc->sc_iotag = pa->pa_iot;
	sc->sc_childbustag = ebus_alloc_bus_tag(sc, PCI_MEMORY_BUS_SPACE);
d236 2
a237 4
ebus_setup_attach_args(sc, node, ea)
	struct ebus_softc	*sc;
	int			node;
	struct ebus_attach_args	*ea;
d248 2
a249 1
	ea->ea_bustag = sc->sc_childbustag;
d279 1
a279 2
ebus_destroy_attach_args(ea)
	struct ebus_attach_args	*ea;
a280 1

d292 1
a292 3
ebus_print(aux, p)
	void *aux;
	const char *p;
d319 1
a319 3
ebus_find_ino(sc, ea)
	struct ebus_softc *sc;
	struct ebus_attach_args *ea;
d370 13
d388 2
a389 3
ebus_alloc_bus_tag(sc, type)
	struct ebus_softc *sc;
	int type;
d391 1
a391 1
	bus_space_tag_t bt;
d393 1
a393 2
	bt = (bus_space_tag_t)
		malloc(sizeof(struct sparc_bus_space_tag), M_DEVBUF, M_NOWAIT);
d398 2
d401 4
a404 2
	bt->parent = sc->sc_memtag;
	bt->type = type;
d412 1
a412 3
ebus_alloc_dma_tag(sc, pdt)
	struct ebus_softc *sc;
	bus_dma_tag_t pdt;
d448 2
a449 8
_ebus_bus_map(t, btype, offset, size, flags, vaddr, hp)
	bus_space_tag_t t;
	bus_type_t btype;
	bus_addr_t offset;
	bus_size_t size;
	int	flags;
	vaddr_t vaddr;
	bus_space_handle_t *hp;
d453 1
a453 1
	int i, ss;
d456 15
a470 3
	    ("\n_ebus_bus_map: type %d off %016llx sz %x flags %d va %p",
	    (int)t->type, (unsigned long long)offset, (int)size, (int)flags,
	    (void *)vaddr));
d474 1
d486 3
a488 16
		/* Isolate address space and find the right tag */
		ss = (sc->sc_range[i].phys_hi>>24)&3;
		switch (ss) {
		case 1:	/* I/O space */
			t = sc->sc_iotag;
			break;
		case 2:	/* Memory space */
			t = sc->sc_memtag;
			break;
		case 0:	/* Config space */
		case 3:	/* 64-bit Memory space */
		default: /* WTF? */
			/* We don't handle these */
			panic("_ebus_bus_map: illegal space %x", ss);
			break;
		}
d493 3
a495 2
		    ("\n_ebus_bus_map: mapping space %x paddr offset %qx pciaddr %qx\n",
		    ss, (unsigned long long)offset, (unsigned long long)pciaddr));
d497 1
a497 1
		return (bus_space_map2(t, 0, pciaddr, size, flags, vaddr, hp));
d504 2
a505 6
ebus_bus_mmap(t, paddr, off, prot, flags)
	bus_space_tag_t t;
	bus_addr_t paddr;
	off_t off;
	int prot;
	int flags;
d511 7
d519 2
a520 1
		bus_addr_t paddr = ((bus_addr_t)sc->sc_range[i].child_hi << 32) |
d528 1
a528 1
		return (bus_space_mmap(sc->sc_memtag, paddr, off, prot, flags));
d538 2
a539 7
ebus_intr_establish(t, pri, level, flags, handler, arg)
	bus_space_tag_t t;
	int pri;
	int level;
	int flags;
	int (*handler)(void *);
	void *arg;
d541 8
a548 1
	return (bus_intr_establish(t->parent, pri, level, flags,
d556 2
a557 7
ebus_dmamap_load(t, map, buf, buflen, p, flags)
	bus_dma_tag_t t;
	bus_dmamap_t map;
	void *buf;
	bus_size_t buflen;
	struct proc *p;
	int flags;
d563 1
a563 3
ebus_dmamap_unload(t, map)
	bus_dma_tag_t t;
	bus_dmamap_t map;
d569 2
a570 6
ebus_dmamap_sync(t, map, offset, len, ops)
	bus_dma_tag_t t;
	bus_dmamap_t map;
	bus_addr_t offset;
	bus_size_t len;
	int ops;
d576 3
a578 9
ebus_dmamem_alloc(t, size, alignment, boundary, segs, nsegs, rsegs, flags)
	bus_dma_tag_t t;
	bus_size_t size;
	bus_size_t alignment;
	bus_size_t boundary;
	bus_dma_segment_t *segs;
	int nsegs;
	int *rsegs;
	int flags;
d585 1
a585 4
ebus_dmamem_free(t, segs, nsegs)
	bus_dma_tag_t t;
	bus_dma_segment_t *segs;
	int nsegs;
d591 2
a592 7
ebus_dmamem_map(t, segs, nsegs, size, kvap, flags)
	bus_dma_tag_t t;
	bus_dma_segment_t *segs;
	int nsegs;
	size_t size;
	caddr_t *kvap;
	int flags;
d598 1
a598 4
ebus_dmamem_unmap(t, kva, size)
	bus_dma_tag_t t;
	caddr_t kva;
	size_t size;
@


1.8
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: ebus.c,v 1.7 2002/02/05 18:34:39 jason Exp $	*/
d106 2
a107 2
static void *ebus_intr_establish __P((bus_space_tag_t, int, int, int,
				int (*)(void *), void *));
@


1.7
log
@Implement vgafb_mmap() fully
From NetBSD: change bus_space_mmap() prototype to standard one
@
text
@d1 1
a1 1
/*	$OpenBSD: ebus.c,v 1.6 2001/12/14 14:53:48 jason Exp $	*/
d80 2
a81 2
int	ebus_match __P((struct device *, void *, void *));
void	ebus_attach __P((struct device *, struct device *, void *));
d92 6
a97 6
int	ebus_setup_attach_args __P((struct ebus_softc *, int,
	    struct ebus_attach_args *));
void	ebus_destroy_attach_args __P((struct ebus_attach_args *));
int	ebus_print __P((void *, const char *));
void	ebus_find_ino __P((struct ebus_softc *, struct ebus_attach_args *));
int	ebus_find_node __P((struct pci_attach_args *));
d102 2
a103 2
static paddr_t ebus_bus_mmap __P((bus_space_tag_t, bus_addr_t, off_t, int, int));
static int _ebus_bus_map __P((bus_space_tag_t, bus_type_t, bus_addr_t,
d105 1
a105 1
				bus_space_handle_t *));
d107 1
a107 1
				int (*) __P((void *)), void *));
d109 11
a119 11
static int ebus_dmamap_load __P((bus_dma_tag_t, bus_dmamap_t, void *,
			  bus_size_t, struct proc *, int));
static void ebus_dmamap_unload __P((bus_dma_tag_t, bus_dmamap_t));
static void ebus_dmamap_sync __P((bus_dma_tag_t, bus_dmamap_t, bus_addr_t,
				  bus_size_t, int));
int ebus_dmamem_alloc __P((bus_dma_tag_t, bus_size_t, bus_size_t, bus_size_t,
			   bus_dma_segment_t *, int, int *, int));
void ebus_dmamem_free __P((bus_dma_tag_t, bus_dma_segment_t *, int));
int ebus_dmamem_map __P((bus_dma_tag_t, bus_dma_segment_t *, int, size_t,
			 caddr_t *, int));
void ebus_dmamem_unmap __P((bus_dma_tag_t, caddr_t, size_t));
d540 1
a540 1
	int (*handler) __P((void *));
@


1.6
log
@pass zero as type for bus_space_map2 (the current argument isn't used by
the upper layer anyway).
@
text
@d1 1
a1 1
/*	$OpenBSD: ebus.c,v 1.5 2001/10/07 15:27:12 jason Exp $	*/
d102 1
a102 2
static int ebus_bus_mmap __P((bus_space_tag_t, bus_type_t, bus_addr_t,
				int, bus_space_handle_t *));
d504 2
a505 2
static int
ebus_bus_mmap(t, btype, paddr, flags, hp)
a506 1
	bus_type_t btype;
d508 2
a510 1
	bus_space_handle_t *hp;
d525 1
a525 2
		return (bus_space_mmap(sc->sc_memtag, 0, paddr,
				       flags, hp));
@


1.6.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ebus.c,v 1.6 2001/12/14 14:53:48 jason Exp $	*/
d80 2
a81 2
int	ebus_match(struct device *, void *, void *);
void	ebus_attach(struct device *, struct device *, void *);
d92 6
a97 6
int	ebus_setup_attach_args(struct ebus_softc *, int,
	    struct ebus_attach_args *);
void	ebus_destroy_attach_args(struct ebus_attach_args *);
int	ebus_print(void *, const char *);
void	ebus_find_ino(struct ebus_softc *, struct ebus_attach_args *);
int	ebus_find_node(struct pci_attach_args *);
d102 3
a104 2
static paddr_t ebus_bus_mmap(bus_space_tag_t, bus_addr_t, off_t, int, int);
static int _ebus_bus_map(bus_space_tag_t, bus_type_t, bus_addr_t,
d106 15
a120 15
				bus_space_handle_t *);
static void *ebus_intr_establish(bus_space_tag_t, int, int, int,
				int (*)(void *), void *);

static int ebus_dmamap_load(bus_dma_tag_t, bus_dmamap_t, void *,
			  bus_size_t, struct proc *, int);
static void ebus_dmamap_unload(bus_dma_tag_t, bus_dmamap_t);
static void ebus_dmamap_sync(bus_dma_tag_t, bus_dmamap_t, bus_addr_t,
				  bus_size_t, int);
int ebus_dmamem_alloc(bus_dma_tag_t, bus_size_t, bus_size_t, bus_size_t,
			   bus_dma_segment_t *, int, int *, int);
void ebus_dmamem_free(bus_dma_tag_t, bus_dma_segment_t *, int);
int ebus_dmamem_map(bus_dma_tag_t, bus_dma_segment_t *, int, size_t,
			 caddr_t *, int);
void ebus_dmamem_unmap(bus_dma_tag_t, caddr_t, size_t);
d505 2
a506 2
static paddr_t
ebus_bus_mmap(t, paddr, off, prot, flags)
d508 1
a509 2
	off_t off;
	int prot;
d511 1
d526 2
a527 1
		return (bus_space_mmap(sc->sc_memtag, paddr, off, prot, flags));
d542 1
a542 1
	int (*handler)(void *);
@


1.6.2.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d102 18
a119 11
static paddr_t ebus_bus_mmap(bus_space_tag_t, bus_space_tag_t, bus_addr_t,
    off_t, int, int);
static int _ebus_bus_map(bus_space_tag_t, bus_space_tag_t, bus_addr_t,
    bus_size_t, int, bus_space_handle_t *);
static void *ebus_intr_establish(bus_space_tag_t, bus_space_tag_t, int, int,
    int, int (*)(void *), void *);
bus_space_tag_t ebus_alloc_mem_tag(struct ebus_softc *, bus_space_tag_t);
bus_space_tag_t ebus_alloc_io_tag(struct ebus_softc *, bus_space_tag_t);
bus_space_tag_t _ebus_alloc_bus_tag(struct ebus_softc *sc, const char *,
    bus_space_tag_t, int);

d122 4
a125 1
ebus_match(struct device *parent, void *match, void *aux)
d164 3
a166 1
ebus_attach(struct device *parent, struct device *self, void *aux)
d176 3
a178 2
	sc->sc_memtag = ebus_alloc_mem_tag(sc, pa->pa_memt);
	sc->sc_iotag = ebus_alloc_io_tag(sc, pa->pa_iot);
d238 4
a241 2
ebus_setup_attach_args(struct ebus_softc *sc, int node,
    struct ebus_attach_args *ea)
d252 1
a252 2
	ea->ea_memtag = sc->sc_memtag;
	ea->ea_iotag = sc->sc_iotag;
d282 2
a283 1
ebus_destroy_attach_args(struct ebus_attach_args *ea)
d285 1
d297 3
a299 1
ebus_print(void *aux, const char *p)
d326 3
a328 1
ebus_find_ino(struct ebus_softc *sc, struct ebus_attach_args *ea)
a378 13
bus_space_tag_t
ebus_alloc_mem_tag(struct ebus_softc *sc, bus_space_tag_t parent)
{
        return (_ebus_alloc_bus_tag(sc, "mem", parent,
            0x02));	/* 32-bit mem space (where's the #define???) */
}

bus_space_tag_t
ebus_alloc_io_tag(struct ebus_softc *sc, bus_space_tag_t parent)
{
        return (_ebus_alloc_bus_tag(sc, "io", parent,
            0x01));	/* IO space (where's the #define???) */
}
d384 3
a386 2
_ebus_alloc_bus_tag(struct ebus_softc *sc, const char *name,
    bus_space_tag_t parent, int ss)
d388 1
a388 1
	struct sparc_bus_space_tag *bt;
d390 2
a391 1
	bt = malloc(sizeof(*bt), M_DEVBUF, M_NOWAIT);
a395 2
	snprintf(bt->name, sizeof(bt->name), "%s_%s",
		sc->sc_dev.dv_xname, name);
d397 2
a398 4
	bt->parent = parent;
	bt->default_type = ss;
	bt->asi = parent->asi;
	bt->sasi = parent->sasi;
d406 3
a408 1
ebus_alloc_dma_tag(struct ebus_softc *sc, bus_dma_tag_t pdt)
d420 15
d444 8
a451 2
_ebus_bus_map(bus_space_tag_t t, bus_space_tag_t t0, bus_addr_t offset,
    bus_size_t size, int flags, bus_space_handle_t *hp)
d455 1
a455 1
	int i;
d458 3
a460 15
	    ("\n_ebus_bus_map: type %d off %016llx sz %x flags %d",
	    (int)t->default_type, (unsigned long long)offset, (int)size,
	    (int)flags));

	if (t->parent == 0 || t->parent->sparc_bus_map == 0) {
		printf("\n_ebus_bus_map: invalid parent");
		return (EINVAL);
	}

	t = t->parent;

	if (flags & BUS_SPACE_MAP_PROMADDRESS) {
		return ((*t->sparc_bus_map)
		    (t, t0, offset, size, flags, hp));
	}
a463 1

d475 16
a490 3
		if(((sc->sc_range[i].phys_hi >> 24) & 3) != t->default_type)
			continue;

d495 2
a496 3
		    ("\n_ebus_bus_map: mapping space %x paddr offset %qx "
		    "pciaddr %qx\n", (int)t->default_type,
		    (unsigned long long)offset, (unsigned long long)pciaddr));
d498 1
a498 1
                return ((*t->sparc_bus_map)(t, t0, pciaddr, size, flags, hp));
d505 6
a510 2
ebus_bus_mmap(bus_space_tag_t t, bus_space_tag_t t0, bus_addr_t paddr,
    off_t off, int prot, int flags)
a515 7
	if (t->parent == 0 || t->parent->sparc_bus_mmap == 0) {
		printf("\nebus_bus_mmap: invalid parent");
		return (-1);
        }

	t = t->parent;

d517 1
a517 2
		bus_addr_t paddr =
		    ((bus_addr_t)sc->sc_range[i].child_hi << 32) |
d525 1
a525 1
		return ((*t->sparc_bus_mmap)(t, t0, paddr, off, prot, flags));
d535 7
a541 2
ebus_intr_establish(bus_space_tag_t t, bus_space_tag_t t0, int pri, int level,
    int flags, int (*handler)(void *), void *arg)
d543 3
a545 4
	if (t->parent == 0 || t->parent->sparc_bus_mmap == 0) {
		printf("\nebus_bus_mmap: invalid parent");
		return (NULL);
        }
d547 57
a603 1
	t = t->parent;
d605 10
a614 2
	return ((*t->sparc_intr_establish)(t, t0, pri, level, flags,
	    handler, arg));
d617 8
@


1.5
log
@remove all assumptions that parent is psycho.  Also, don't try to use
iommu operations directly: that's what bus_dma(9) heirarchy is for.
(audioce now works on u5, though it won't play on the onboard speaker,
or mine is busted... plays fine in headphones/lineout).
@
text
@d1 1
a1 1
/*	$OpenBSD: ebus.c,v 1.4 2001/10/01 16:55:57 jason Exp $	*/
d499 1
a499 2
		return (bus_space_map2(t, sc->sc_range[i].phys_hi, 
			pciaddr, size, flags, vaddr, hp));
@


1.5.4.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.5.4.2
log
@Merge in trunk
@
text
@d102 2
a103 1
static paddr_t ebus_bus_mmap __P((bus_space_tag_t, bus_addr_t, off_t, int, int));
d499 2
a500 1
		return (bus_space_map2(t, 0, pciaddr, size, flags, vaddr, hp));
d506 2
a507 2
static paddr_t
ebus_bus_mmap(t, paddr, off, prot, flags)
d509 1
a510 2
	off_t off;
	int prot;
d512 1
d527 2
a528 1
		return (bus_space_mmap(sc->sc_memtag, paddr, off, prot, flags));
@


1.5.4.3
log
@Merge in -current from about a week ago
@
text
@d80 2
a81 2
int	ebus_match(struct device *, void *, void *);
void	ebus_attach(struct device *, struct device *, void *);
d92 6
a97 6
int	ebus_setup_attach_args(struct ebus_softc *, int,
	    struct ebus_attach_args *);
void	ebus_destroy_attach_args(struct ebus_attach_args *);
int	ebus_print(void *, const char *);
void	ebus_find_ino(struct ebus_softc *, struct ebus_attach_args *);
int	ebus_find_node(struct pci_attach_args *);
d102 2
a103 2
static paddr_t ebus_bus_mmap(bus_space_tag_t, bus_addr_t, off_t, int, int);
static int _ebus_bus_map(bus_space_tag_t, bus_type_t, bus_addr_t,
d105 15
a119 15
				bus_space_handle_t *);
static void *ebus_intr_establish(bus_space_tag_t, int, int, int,
				int (*)(void *), void *);

static int ebus_dmamap_load(bus_dma_tag_t, bus_dmamap_t, void *,
			  bus_size_t, struct proc *, int);
static void ebus_dmamap_unload(bus_dma_tag_t, bus_dmamap_t);
static void ebus_dmamap_sync(bus_dma_tag_t, bus_dmamap_t, bus_addr_t,
				  bus_size_t, int);
int ebus_dmamem_alloc(bus_dma_tag_t, bus_size_t, bus_size_t, bus_size_t,
			   bus_dma_segment_t *, int, int *, int);
void ebus_dmamem_free(bus_dma_tag_t, bus_dma_segment_t *, int);
int ebus_dmamem_map(bus_dma_tag_t, bus_dma_segment_t *, int, size_t,
			 caddr_t *, int);
void ebus_dmamem_unmap(bus_dma_tag_t, caddr_t, size_t);
d540 1
a540 1
	int (*handler)(void *);
@


1.5.4.4
log
@Sync the SMP branch with 3.3
@
text
@d102 18
a119 11
static paddr_t ebus_bus_mmap(bus_space_tag_t, bus_space_tag_t, bus_addr_t,
    off_t, int, int);
static int _ebus_bus_map(bus_space_tag_t, bus_space_tag_t, bus_addr_t,
    bus_size_t, int, bus_space_handle_t *);
static void *ebus_intr_establish(bus_space_tag_t, bus_space_tag_t, int, int,
    int, int (*)(void *), void *);
bus_space_tag_t ebus_alloc_mem_tag(struct ebus_softc *, bus_space_tag_t);
bus_space_tag_t ebus_alloc_io_tag(struct ebus_softc *, bus_space_tag_t);
bus_space_tag_t _ebus_alloc_bus_tag(struct ebus_softc *sc, const char *,
    bus_space_tag_t, int);

d122 4
a125 1
ebus_match(struct device *parent, void *match, void *aux)
d164 3
a166 1
ebus_attach(struct device *parent, struct device *self, void *aux)
d176 3
a178 2
	sc->sc_memtag = ebus_alloc_mem_tag(sc, pa->pa_memt);
	sc->sc_iotag = ebus_alloc_io_tag(sc, pa->pa_iot);
d238 4
a241 2
ebus_setup_attach_args(struct ebus_softc *sc, int node,
    struct ebus_attach_args *ea)
d252 1
a252 2
	ea->ea_memtag = sc->sc_memtag;
	ea->ea_iotag = sc->sc_iotag;
d282 2
a283 1
ebus_destroy_attach_args(struct ebus_attach_args *ea)
d285 1
d297 3
a299 1
ebus_print(void *aux, const char *p)
d326 3
a328 1
ebus_find_ino(struct ebus_softc *sc, struct ebus_attach_args *ea)
a378 13
bus_space_tag_t
ebus_alloc_mem_tag(struct ebus_softc *sc, bus_space_tag_t parent)
{
        return (_ebus_alloc_bus_tag(sc, "mem", parent,
            0x02));	/* 32-bit mem space (where's the #define???) */
}

bus_space_tag_t
ebus_alloc_io_tag(struct ebus_softc *sc, bus_space_tag_t parent)
{
        return (_ebus_alloc_bus_tag(sc, "io", parent,
            0x01));	/* IO space (where's the #define???) */
}
d384 3
a386 2
_ebus_alloc_bus_tag(struct ebus_softc *sc, const char *name,
    bus_space_tag_t parent, int ss)
d388 1
a388 1
	struct sparc_bus_space_tag *bt;
d390 2
a391 1
	bt = malloc(sizeof(*bt), M_DEVBUF, M_NOWAIT);
a395 2
	snprintf(bt->name, sizeof(bt->name), "%s_%s",
		sc->sc_dev.dv_xname, name);
d397 2
a398 4
	bt->parent = parent;
	bt->default_type = ss;
	bt->asi = parent->asi;
	bt->sasi = parent->sasi;
d406 3
a408 1
ebus_alloc_dma_tag(struct ebus_softc *sc, bus_dma_tag_t pdt)
d420 15
d444 8
a451 2
_ebus_bus_map(bus_space_tag_t t, bus_space_tag_t t0, bus_addr_t offset,
    bus_size_t size, int flags, bus_space_handle_t *hp)
d455 1
a455 1
	int i;
d458 3
a460 15
	    ("\n_ebus_bus_map: type %d off %016llx sz %x flags %d",
	    (int)t->default_type, (unsigned long long)offset, (int)size,
	    (int)flags));

	if (t->parent == 0 || t->parent->sparc_bus_map == 0) {
		printf("\n_ebus_bus_map: invalid parent");
		return (EINVAL);
	}

	t = t->parent;

	if (flags & BUS_SPACE_MAP_PROMADDRESS) {
		return ((*t->sparc_bus_map)
		    (t, t0, offset, size, flags, hp));
	}
a463 1

d475 16
a490 3
		if(((sc->sc_range[i].phys_hi >> 24) & 3) != t->default_type)
			continue;

d495 2
a496 3
		    ("\n_ebus_bus_map: mapping space %x paddr offset %qx "
		    "pciaddr %qx\n", (int)t->default_type,
		    (unsigned long long)offset, (unsigned long long)pciaddr));
d498 1
a498 1
                return ((*t->sparc_bus_map)(t, t0, pciaddr, size, flags, hp));
d505 6
a510 2
ebus_bus_mmap(bus_space_tag_t t, bus_space_tag_t t0, bus_addr_t paddr,
    off_t off, int prot, int flags)
a515 7
	if (t->parent == 0 || t->parent->sparc_bus_mmap == 0) {
		printf("\nebus_bus_mmap: invalid parent");
		return (-1);
        }

	t = t->parent;

d517 1
a517 2
		bus_addr_t paddr =
		    ((bus_addr_t)sc->sc_range[i].child_hi << 32) |
d525 1
a525 1
		return ((*t->sparc_bus_mmap)(t, t0, paddr, off, prot, flags));
d535 7
a541 2
ebus_intr_establish(bus_space_tag_t t, bus_space_tag_t t0, int pri, int level,
    int flags, int (*handler)(void *), void *arg)
d543 3
a545 4
	if (t->parent == 0 || t->parent->sparc_bus_mmap == 0) {
		printf("\nebus_bus_mmap: invalid parent");
		return (NULL);
        }
d547 57
a603 1
	t = t->parent;
d605 10
a614 2
	return ((*t->sparc_intr_establish)(t, t0, pri, level, flags,
	    handler, arg));
d617 8
@


1.5.4.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d106 2
d396 1
a396 1

d506 18
@


1.4
log
@don't print redundant information
the parent of ebus is pci (not psycho), so fetch grantparent for iommu_state
@
text
@d1 1
a1 1
/*	$OpenBSD: ebus.c,v 1.3 2001/09/15 07:00:12 jason Exp $	*/
a176 5
	/*
	 * The "parent" of an ebus is the pci layer, in this case we
	 * really want the grandparent.
	 */
	sc->sc_parent = (struct psycho_softc *)parent->dv_parent;
d546 2
a547 1
	return (bus_intr_establish(t->parent, pri, level, flags, handler, arg));
d562 1
a562 4
	struct ebus_softc *sc = t->_cookie;

	return (iommu_dvmamap_load(t, sc->sc_parent->sc_is, map, buf, buflen,
	    p, flags));
d570 1
a570 3
	struct ebus_softc *sc = t->_cookie;

	iommu_dvmamap_unload(t, sc->sc_parent->sc_is, map);
a580 3
	struct ebus_softc *sc = t->_cookie;

	iommu_dvmamap_sync(t, sc->sc_parent->sc_is, map, offset, len, ops);
d595 2
a596 4
	struct ebus_softc *sc = t->_cookie;

	return (iommu_dvmamem_alloc(t, sc->sc_parent->sc_is, size, alignment,
	    boundary, segs, nsegs, rsegs, flags));
d605 1
a605 3
	struct ebus_softc *sc = t->_cookie;

	iommu_dvmamem_free(t, sc->sc_parent->sc_is, segs, nsegs);
d617 1
a617 4
	struct ebus_softc *sc = t->_cookie;

	return (iommu_dvmamem_map(t, sc->sc_parent->sc_is, segs, nsegs,
	    size, kvap, flags));
d626 1
a626 3
	struct ebus_softc *sc = t->_cookie;

	iommu_dvmamem_unmap(t, sc->sc_parent->sc_is, kva, size);
@


1.3
log
@match ebusIII (from netbsd)
@
text
@d1 1
a1 1
/*	$OpenBSD: ebus.c,v 1.2 2001/08/29 02:47:58 jason Exp $	*/
a173 1
	char devinfo[256];
d177 5
a181 5
	pci_devinfo(pa->pa_id, pa->pa_class, 0, devinfo);
	printf("%s: %s, revision 0x%02x\n", self->dv_xname, devinfo,
	    PCI_REVISION(pa->pa_class));

	sc->sc_parent = (struct psycho_softc *)parent;
a410 1
/* XXX? */
d441 1
@


1.2
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d141 7
@


1.1
log
@glue for ebus found on ultra 5 and later. From NetBSD.
@
text
@d1 1
@

