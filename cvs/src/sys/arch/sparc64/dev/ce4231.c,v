head	1.35;
access;
symbols
	OPENBSD_6_2:1.35.0.6
	OPENBSD_6_2_BASE:1.35
	OPENBSD_6_1:1.35.0.4
	OPENBSD_6_1_BASE:1.35
	OPENBSD_6_0:1.33.0.6
	OPENBSD_6_0_BASE:1.33
	OPENBSD_5_9:1.33.0.2
	OPENBSD_5_9_BASE:1.33
	OPENBSD_5_8:1.33.0.4
	OPENBSD_5_8_BASE:1.33
	OPENBSD_5_7:1.31.0.2
	OPENBSD_5_7_BASE:1.31
	OPENBSD_5_6:1.31.0.4
	OPENBSD_5_6_BASE:1.31
	OPENBSD_5_5:1.30.0.6
	OPENBSD_5_5_BASE:1.30
	OPENBSD_5_4:1.30.0.2
	OPENBSD_5_4_BASE:1.30
	OPENBSD_5_3:1.28.0.12
	OPENBSD_5_3_BASE:1.28
	OPENBSD_5_2:1.28.0.10
	OPENBSD_5_2_BASE:1.28
	OPENBSD_5_1_BASE:1.28
	OPENBSD_5_1:1.28.0.8
	OPENBSD_5_0:1.28.0.6
	OPENBSD_5_0_BASE:1.28
	OPENBSD_4_9:1.28.0.4
	OPENBSD_4_9_BASE:1.28
	OPENBSD_4_8:1.28.0.2
	OPENBSD_4_8_BASE:1.28
	OPENBSD_4_7:1.25.0.2
	OPENBSD_4_7_BASE:1.25
	OPENBSD_4_6:1.22.0.8
	OPENBSD_4_6_BASE:1.22
	OPENBSD_4_5:1.22.0.4
	OPENBSD_4_5_BASE:1.22
	OPENBSD_4_4:1.22.0.2
	OPENBSD_4_4_BASE:1.22
	OPENBSD_4_3:1.21.0.10
	OPENBSD_4_3_BASE:1.21
	OPENBSD_4_2:1.21.0.8
	OPENBSD_4_2_BASE:1.21
	OPENBSD_4_1:1.21.0.6
	OPENBSD_4_1_BASE:1.21
	OPENBSD_4_0:1.21.0.4
	OPENBSD_4_0_BASE:1.21
	OPENBSD_3_9:1.21.0.2
	OPENBSD_3_9_BASE:1.21
	OPENBSD_3_8:1.20.0.2
	OPENBSD_3_8_BASE:1.20
	OPENBSD_3_7:1.17.0.2
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.15.0.8
	OPENBSD_3_6_BASE:1.15
	SMP_SYNC_A:1.15
	SMP_SYNC_B:1.15
	OPENBSD_3_5:1.15.0.4
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.15.0.2
	OPENBSD_3_4_BASE:1.15
	UBC_SYNC_A:1.13
	OPENBSD_3_3:1.12.0.2
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.11.0.2
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	UBC_SYNC_B:1.11
	UBC:1.2.0.6
	UBC_BASE:1.2
	SMP:1.2.0.4
	OPENBSD_3_0:1.2.0.2
	OPENBSD_3_0_BASE:1.2;
locks; strict;
comment	@ * @;


1.35
date	2016.09.19.06.46.43;	author ratchov;	state Exp;
branches;
next	1.34;
commitid	qGgYgJTgEFuAoGj4;

1.34
date	2016.09.14.06.12.19;	author ratchov;	state Exp;
branches;
next	1.33;
commitid	pi1a9KN0itEngOc4;

1.33
date	2015.05.11.06.52.35;	author ratchov;	state Exp;
branches;
next	1.32;
commitid	d72M2ifvvYynw0IH;

1.32
date	2015.05.11.06.46.21;	author ratchov;	state Exp;
branches;
next	1.31;
commitid	RaOGL5SyOGOZylwx;

1.31
date	2014.07.12.18.44.43;	author tedu;	state Exp;
branches;
next	1.30;
commitid	uKVPYMN2MLxdZxzH;

1.30
date	2013.05.16.06.31.50;	author kettenis;	state Exp;
branches;
next	1.29;

1.29
date	2013.05.15.08.29.23;	author ratchov;	state Exp;
branches;
next	1.28;

1.28
date	2010.07.26.23.17.19;	author jakemsr;	state Exp;
branches;
next	1.27;

1.27
date	2010.07.26.20.06.12;	author jakemsr;	state Exp;
branches;
next	1.26;

1.26
date	2010.07.15.03.43.11;	author jakemsr;	state Exp;
branches;
next	1.25;

1.25
date	2010.02.22.00.43.30;	author jakemsr;	state Exp;
branches;
next	1.24;

1.24
date	2009.12.15.10.43.53;	author edd;	state Exp;
branches;
next	1.23;

1.23
date	2009.12.01.23.17.11;	author edd;	state Exp;
branches;
next	1.22;

1.22
date	2008.04.21.00.32.42;	author jakemsr;	state Exp;
branches;
next	1.21;

1.21
date	2005.09.08.15.25.54;	author martin;	state Exp;
branches;
next	1.20;

1.20
date	2005.07.09.22.23.15;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2005.04.16.21.57.23;	author mickey;	state Exp;
branches;
next	1.18;

1.18
date	2005.04.15.13.05.14;	author mickey;	state Exp;
branches;
next	1.17;

1.17
date	2004.11.09.14.30.34;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2004.09.29.19.17.43;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2003.06.24.21.54.39;	author henric;	state Exp;
branches;
next	1.14;

1.14
date	2003.06.02.20.02.49;	author jason;	state Exp;
branches;
next	1.13;

1.13
date	2003.05.11.19.41.12;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2003.02.17.01.29.19;	author henric;	state Exp;
branches;
next	1.11;

1.11
date	2002.09.10.17.27.27;	author jason;	state Exp;
branches;
next	1.10;

1.10
date	2002.08.16.19.02.17;	author jason;	state Exp;
branches;
next	1.9;

1.9
date	2002.07.18.02.14.26;	author jason;	state Exp;
branches;
next	1.8;

1.8
date	2002.04.08.17.49.41;	author jason;	state Exp;
branches;
next	1.7;

1.7
date	2002.03.14.03.16.00;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.03.14.01.26.44;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.01.24.03.06.54;	author jason;	state Exp;
branches;
next	1.4;

1.4
date	2002.01.20.23.21.54;	author ericj;	state Exp;
branches;
next	1.3;

1.3
date	2002.01.11.17.26.34;	author jason;	state Exp;
branches;
next	1.2;

1.2
date	2001.10.02.00.26.24;	author jason;	state Exp;
branches
	1.2.4.1
	1.2.6.1;
next	1.1;

1.1
date	2001.10.01.18.10.32;	author jason;	state Exp;
branches;
next	;

1.2.4.1
date	2001.10.31.03.07.57;	author nate;	state Exp;
branches;
next	1.2.4.2;

1.2.4.2
date	2002.03.06.02.04.46;	author niklas;	state Exp;
branches;
next	1.2.4.3;

1.2.4.3
date	2002.03.28.10.57.11;	author niklas;	state Exp;
branches;
next	1.2.4.4;

1.2.4.4
date	2003.03.27.23.42.35;	author niklas;	state Exp;
branches;
next	1.2.4.5;

1.2.4.5
date	2003.05.13.19.41.09;	author ho;	state Exp;
branches;
next	1.2.4.6;

1.2.4.6
date	2003.06.07.11.14.44;	author ho;	state Exp;
branches;
next	1.2.4.7;

1.2.4.7
date	2004.02.19.10.49.59;	author niklas;	state Exp;
branches;
next	;

1.2.6.1
date	2002.01.31.22.55.23;	author niklas;	state Exp;
branches;
next	1.2.6.2;

1.2.6.2
date	2002.06.11.03.38.42;	author art;	state Exp;
branches;
next	1.2.6.3;

1.2.6.3
date	2002.10.29.00.28.11;	author art;	state Exp;
branches;
next	1.2.6.4;

1.2.6.4
date	2003.05.19.21.46.57;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.35
log
@Remove unused getdev() audio driver functions.
@
text
@/*	$OpenBSD: ce4231.c,v 1.34 2016/09/14 06:12:19 ratchov Exp $	*/

/*
 * Copyright (c) 1999 Jason L. Wright (jason@@thought.net)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Driver for CS4231 based audio found in some sun4u systems (cs4231)
 * based on ideas from the S/Linux project and the NetBSD project.
 *
 * Effort sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F30602-01-2-0537.
 *
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/errno.h>
#include <sys/ioctl.h>
#include <sys/device.h>
#include <sys/proc.h>
#include <sys/malloc.h>

#include <machine/cpu.h>
#include <machine/bus.h>
#include <machine/intr.h>
#include <machine/autoconf.h>

#include <sys/audioio.h>
#include <dev/audio_if.h>

#include <sparc64/dev/ebusreg.h>
#include <sparc64/dev/ebusvar.h>
#include <sparc64/dev/ce4231var.h>

/* AD1418 provides basic registers, CS4231 extends with more */
#include <dev/ic/ad1848reg.h>
#include <dev/ic/cs4231reg.h>

/* Mixer classes and mixer knobs */
#define CSAUDIO_INPUT_CLASS	0
#define CSAUDIO_OUTPUT_CLASS	1
#define CSAUDIO_RECORD_CLASS	2
#define CSAUDIO_DAC_LVL		3
#define CSAUDIO_DAC_MUTE	4
#define CSAUDIO_OUTPUTS		5
#define CSAUDIO_CD_LVL		6
#define CSAUDIO_CD_MUTE		7
#define CSAUDIO_LINE_IN_LVL	8
#define CSAUDIO_LINE_IN_MUTE	9
#define CSAUDIO_MONITOR_LVL	10
#define CSAUDIO_MONITOR_MUTE	11
#define CSAUDIO_REC_LVL		12
#define CSAUDIO_RECORD_SOURCE	13
#define CSAUDIO_MIC_PREAMP	14

/* Recording sources */
#define REC_PORT_LINE	0
#define REC_PORT_CD	1
#define REC_PORT_MIC	2
#define REC_PORT_MIX	3

/* Output ports. */
#define OUT_PORT_LINE	0x1
#define OUT_PORT_HP	0x2
#define OUT_PORT_SPKR	0x4

/* Bits on the ADC reg that determine recording source */
#define CS_REC_SRC_BITS 0xc0

#ifdef AUDIO_DEBUG
#define	DPRINTF(x)	printf x
#else
#define	DPRINTF(x)
#endif

#define	CS_TIMEOUT	90000

/* Read/write CS4231 direct registers */
#define CS_WRITE(sc,r,v)	\
    bus_space_write_1((sc)->sc_bustag, (sc)->sc_cshandle, (r) << 2, (v))
#define	CS_READ(sc,r)		\
    bus_space_read_1((sc)->sc_bustag, (sc)->sc_cshandle, (r) << 2)

/* Read/write EBDMA playback registers */
#define	P_WRITE(sc,r,v)		\
    bus_space_write_4((sc)->sc_bustag, (sc)->sc_pdmahandle, (r), (v))
#define	P_READ(sc,r)		\
    bus_space_read_4((sc)->sc_bustag, (sc)->sc_pdmahandle, (r))

/* Read/write EBDMA capture registers */
#define	C_WRITE(sc,r,v)		\
    bus_space_write_4((sc)->sc_bustag, (sc)->sc_cdmahandle, (r), (v))
#define	C_READ(sc,r)		\
    bus_space_read_4((sc)->sc_bustag, (sc)->sc_cdmahandle, (r))

int	ce4231_match(struct device *, void *, void *);
void	ce4231_attach(struct device *, struct device *, void *);
int	ce4231_cintr(void *);
int	ce4231_pintr(void *);

int	ce4231_set_speed(struct ce4231_softc *, u_long *);

void	ce4231_set_outputs(struct ce4231_softc *, int);
int	ce4231_get_outputs(struct ce4231_softc *);

void		ce4231_write(struct ce4231_softc *, u_int8_t, u_int8_t);
u_int8_t	ce4231_read(struct ce4231_softc *, u_int8_t);

/* Audio interface */
int	ce4231_open(void *, int);
void	ce4231_close(void *);
int	ce4231_set_params(void *, int, int, struct audio_params *,
    struct audio_params *);
int	ce4231_round_blocksize(void *, int);
int	ce4231_commit_settings(void *);
int	ce4231_halt_output(void *);
int	ce4231_halt_input(void *);
int	ce4231_set_port(void *, mixer_ctrl_t *);
int	ce4231_get_port(void *, mixer_ctrl_t *);
int	ce4231_query_devinfo(void *addr, mixer_devinfo_t *);
void *	ce4231_alloc(void *, int, size_t, int, int);
void	ce4231_free(void *, void *, int);
int	ce4231_get_props(void *);
int	ce4231_trigger_output(void *, void *, void *, int,
    void (*intr)(void *), void *arg, struct audio_params *);
int	ce4231_trigger_input(void *, void *, void *, int,
    void (*intr)(void *), void *arg, struct audio_params *);

struct audio_hw_if ce4231_sa_hw_if = {
	ce4231_open,
	ce4231_close,
	ce4231_set_params,
	ce4231_round_blocksize,
	ce4231_commit_settings,
	0,
	0,
	0,
	0,
	ce4231_halt_output,
	ce4231_halt_input,
	0,
	0,
	ce4231_set_port,
	ce4231_get_port,
	ce4231_query_devinfo,
	ce4231_alloc,
	ce4231_free,
	0,
	ce4231_get_props,
	ce4231_trigger_output,
	ce4231_trigger_input
};

struct cfattach audioce_ca = {
	sizeof (struct ce4231_softc), ce4231_match, ce4231_attach
};

struct cfdriver audioce_cd = {
	NULL, "audioce", DV_DULL
};

int
ce4231_match(parent, vcf, aux)
	struct device *parent;
	void *vcf, *aux;
{
	struct ebus_attach_args *ea = aux;

	if (!strcmp("SUNW,CS4231", ea->ea_name) ||
	    !strcmp("audio", ea->ea_name))
		return (1);
	return (0);
}

void    
ce4231_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct ebus_attach_args *ea = aux;
	struct ce4231_softc *sc = (struct ce4231_softc *)self;
	mixer_ctrl_t cp;
	int node;

	node = ea->ea_node;

	sc->sc_last_format = 0xffffffff;

	/* Pass on the bus tags */
	sc->sc_bustag = ea->ea_memtag;
	sc->sc_dmatag = ea->ea_dmatag;

	/* Make sure things are sane. */
	if (ea->ea_nintrs != 2) {
		printf(": expected 2 interrupts, got %d\n", ea->ea_nintrs);
		return;
	}
	if (ea->ea_nregs != 4) {
		printf(": expected 4 register set, got %d\n",
		    ea->ea_nregs);
		return;
	}

	sc->sc_cih = bus_intr_establish(sc->sc_bustag, ea->ea_intrs[0],
	    IPL_AUDIO, BUS_INTR_ESTABLISH_MPSAFE, ce4231_cintr,
	    sc, self->dv_xname);
	if (sc->sc_cih == NULL) {
		printf(": couldn't establish capture interrupt\n");
		return;
	}
	sc->sc_pih = bus_intr_establish(sc->sc_bustag, ea->ea_intrs[1],
	    IPL_AUDIO, BUS_INTR_ESTABLISH_MPSAFE, ce4231_pintr,
	    sc, self->dv_xname);
	if (sc->sc_pih == NULL) {
		printf(": couldn't establish play interrupt1\n");
		return;
	}

	/* XXX what if prom has already mapped?! */

	if (ebus_bus_map(sc->sc_bustag, 0,
	    EBUS_PADDR_FROM_REG(&ea->ea_regs[0]), ea->ea_regs[0].size,
	    BUS_SPACE_MAP_LINEAR, 0, &sc->sc_cshandle) != 0) {
		printf(": couldn't map cs4231 registers\n");
		return;
	}

	if (ebus_bus_map(sc->sc_bustag, 0,
	    EBUS_PADDR_FROM_REG(&ea->ea_regs[1]), ea->ea_regs[1].size,
	    BUS_SPACE_MAP_LINEAR, 0, &sc->sc_pdmahandle) != 0) {
		printf(": couldn't map dma1 registers\n");
		return;
	}

	if (ebus_bus_map(sc->sc_bustag, 0,
	    EBUS_PADDR_FROM_REG(&ea->ea_regs[2]), ea->ea_regs[2].size,
	    BUS_SPACE_MAP_LINEAR, 0, &sc->sc_cdmahandle) != 0) {
		printf(": couldn't map dma2 registers\n");
		return;
	}

	if (ebus_bus_map(sc->sc_bustag, 0,
	    EBUS_PADDR_FROM_REG(&ea->ea_regs[3]), ea->ea_regs[3].size,
	    BUS_SPACE_MAP_LINEAR, 0, &sc->sc_auxhandle) != 0) {
		printf(": couldn't map aux registers\n");
		return;
	}

	printf(": nvaddrs %d\n", ea->ea_nvaddrs);

	audio_attach_mi(&ce4231_sa_hw_if, sc, &sc->sc_dev);

	/* Enable mode 2. */
	ce4231_write(sc, SP_MISC_INFO, ce4231_read(sc, SP_MISC_INFO) | MODE2);

	/* Attenuate DAC, CD and line-in.  -22.5 dB for all. */
	cp.dev = CSAUDIO_DAC_LVL;
	cp.type = AUDIO_MIXER_VALUE;
	cp.un.value.num_channels = 2;
	cp.un.value.level[AUDIO_MIXER_LEVEL_LEFT] = 195;
	cp.un.value.level[AUDIO_MIXER_LEVEL_RIGHT] = 195;
	ce4231_set_port(sc, &cp);

	cp.dev = CSAUDIO_CD_LVL;
	cp.un.value.level[AUDIO_MIXER_LEVEL_LEFT] = 135;
	cp.un.value.level[AUDIO_MIXER_LEVEL_RIGHT] = 135;
	ce4231_set_port(sc, &cp);

	cp.dev = CSAUDIO_LINE_IN_LVL;
	ce4231_set_port(sc, &cp);

	/* Unmute DAC, CD and line-in */
	cp.dev = CSAUDIO_DAC_MUTE;
	cp.type = AUDIO_MIXER_ENUM;
	cp.un.ord = 0;
	ce4231_set_port(sc, &cp);

	cp.dev = CSAUDIO_CD_MUTE;
	ce4231_set_port(sc, &cp);

	cp.dev = CSAUDIO_LINE_IN_MUTE;
	ce4231_set_port(sc, &cp);

	/* XXX get real burst... */
	sc->sc_burst = EBDCSR_BURST_8;
}

/*
 * Write to one of the indexed registers of cs4231.
 */
void
ce4231_write(sc, r, v)
	struct ce4231_softc *sc;
	u_int8_t r, v;
{
	CS_WRITE(sc, AD1848_IADDR, r);
	CS_WRITE(sc, AD1848_IDATA, v);
}

/*
 * Read from one of the indexed registers of cs4231.
 */
u_int8_t
ce4231_read(sc, r)
	struct ce4231_softc *sc;
	u_int8_t r;
{
	CS_WRITE(sc, AD1848_IADDR, r);
	return (CS_READ(sc, AD1848_IDATA));
}

int
ce4231_set_speed(sc, argp)
	struct ce4231_softc *sc;
	u_long *argp;

{
	/*
	 * The available speeds are in the following table. Keep the speeds in
	 * the increasing order.
	 */
	typedef struct {
		int speed;
		u_char bits;
	} speed_struct;
	u_long arg = *argp;

	static speed_struct speed_table[] = {
		{5510,	(0 << 1) | CLOCK_XTAL2},
		{5510,	(0 << 1) | CLOCK_XTAL2},
		{6620,	(7 << 1) | CLOCK_XTAL2},
		{8000,	(0 << 1) | CLOCK_XTAL1},
		{9600,	(7 << 1) | CLOCK_XTAL1},
		{11025,	(1 << 1) | CLOCK_XTAL2},
		{16000,	(1 << 1) | CLOCK_XTAL1},
		{18900,	(2 << 1) | CLOCK_XTAL2},
		{22050,	(3 << 1) | CLOCK_XTAL2},
		{27420,	(2 << 1) | CLOCK_XTAL1},
		{32000,	(3 << 1) | CLOCK_XTAL1},
		{33075,	(6 << 1) | CLOCK_XTAL2},
		{33075,	(4 << 1) | CLOCK_XTAL2},
		{44100,	(5 << 1) | CLOCK_XTAL2},
		{48000,	(6 << 1) | CLOCK_XTAL1},
	};

	int i, n, selected = -1;

	n = sizeof(speed_table) / sizeof(speed_struct);

	if (arg < speed_table[0].speed)
		selected = 0;
	if (arg > speed_table[n - 1].speed)
		selected = n - 1;

	for (i = 1; selected == -1 && i < n; i++) {
		if (speed_table[i].speed == arg)
			selected = i;
		else if (speed_table[i].speed > arg) {
			int diff1, diff2;

			diff1 = arg - speed_table[i - 1].speed;
			diff2 = speed_table[i].speed - arg;
			if (diff1 < diff2)
				selected = i - 1;
			else
				selected = i;
		}
	}

	if (selected == -1)
		selected = 3;

	sc->sc_speed_bits = speed_table[selected].bits;
	sc->sc_need_commit = 1;
	*argp = speed_table[selected].speed;

	return (0);
}

/*
 * Audio interface functions
 */
int
ce4231_open(addr, flags)
	void *addr;
	int flags;
{
	struct ce4231_softc *sc = addr;
	int tries;

	DPRINTF(("ce4231_open\n"));

	if (sc->sc_open)
		return (EBUSY);

	sc->sc_open = 1;
	sc->sc_rintr = 0;
	sc->sc_rarg = 0;
	sc->sc_pintr = 0;
	sc->sc_parg = 0;

	P_WRITE(sc, EBDMA_DCSR, EBDCSR_RESET);
	C_WRITE(sc, EBDMA_DCSR, EBDCSR_RESET);
	P_WRITE(sc, EBDMA_DCSR, sc->sc_burst);
	C_WRITE(sc, EBDMA_DCSR, sc->sc_burst);

	DELAY(20);

	for (tries = CS_TIMEOUT;
	     tries && CS_READ(sc, AD1848_IADDR) == SP_IN_INIT; tries--)
		DELAY(10);
	if (tries == 0)
		printf("%s: timeout waiting for reset\n", sc->sc_dev.dv_xname);

	ce4231_write(sc, SP_PIN_CONTROL,
	    ce4231_read(sc, SP_PIN_CONTROL) | INTERRUPT_ENABLE);

	return (0);
}

void
ce4231_close(addr)
	void *addr;
{
	struct ce4231_softc *sc = addr;

	ce4231_halt_input(sc);
	ce4231_halt_output(sc);
	ce4231_write(sc, SP_PIN_CONTROL,
	    ce4231_read(sc, SP_PIN_CONTROL) & (~INTERRUPT_ENABLE));
	sc->sc_open = 0;
}

int
ce4231_set_params(addr, setmode, usemode, p, r)
	void *addr;
	int setmode, usemode;
	struct audio_params *p, *r;
{
	struct ce4231_softc *sc = (struct ce4231_softc *)addr;
	int err, bits, enc = p->encoding;

	if (p->precision > 16)
		p->precision = 16;
	switch (enc) {
	case AUDIO_ENCODING_ULAW:
		p->precision = 8;
		bits = FMT_ULAW >> 5;
		break;
	case AUDIO_ENCODING_ALAW:
		p->precision = 8;
		bits = FMT_ALAW >> 5;
		break;
	case AUDIO_ENCODING_SLINEAR_LE:
		p->precision = 16;
		bits = FMT_TWOS_COMP >> 5;
		break;
	case AUDIO_ENCODING_SLINEAR_BE:
		p->precision = 16;
		bits = FMT_TWOS_COMP_BE >> 5;
		break;
	case AUDIO_ENCODING_ULINEAR_LE:
	case AUDIO_ENCODING_ULINEAR_BE:
		p->precision = 8;
		break;
	default:
		return (EINVAL);
	}

	if (p->channels > 2)
		p->channels = 2;

	err = ce4231_set_speed(sc, &p->sample_rate);
	if (err)
		return (err);

	p->bps = AUDIO_BPS(p->precision);
	r->bps = AUDIO_BPS(r->precision);
	p->msb = r->msb = 1;

	sc->sc_format_bits = bits;
	sc->sc_channels = p->channels;
	sc->sc_precision = p->precision;
	sc->sc_need_commit = 1;
	return (0);
}

int
ce4231_round_blocksize(addr, blk)
	void *addr;
	int blk;
{
	return ((blk + 3) & (-4));
}

int
ce4231_commit_settings(addr)
	void *addr;
{
	struct ce4231_softc *sc = (struct ce4231_softc *)addr;
	int tries;
	u_int8_t r, fs;

	if (sc->sc_need_commit == 0)
		return (0);

	fs = sc->sc_speed_bits | (sc->sc_format_bits << 5);
	if (sc->sc_channels == 2)
		fs |= FMT_STEREO;

	if (sc->sc_last_format == fs) {
		sc->sc_need_commit = 0;
		return (0);
	}

	/* XXX: this code is called before DMA (this intrs) is stopped */
	mtx_enter(&audio_lock);

	r = ce4231_read(sc, SP_INTERFACE_CONFIG) | AUTO_CAL_ENABLE;
	CS_WRITE(sc, AD1848_IADDR, MODE_CHANGE_ENABLE);
	CS_WRITE(sc, AD1848_IADDR, MODE_CHANGE_ENABLE | SP_INTERFACE_CONFIG);
	CS_WRITE(sc, AD1848_IDATA, r);

	CS_WRITE(sc, AD1848_IADDR, MODE_CHANGE_ENABLE | SP_CLOCK_DATA_FORMAT);
	CS_WRITE(sc, AD1848_IDATA, fs);
	CS_READ(sc, AD1848_IDATA);
	CS_READ(sc, AD1848_IDATA);
	tries = CS_TIMEOUT;
	for (tries = CS_TIMEOUT;
	     tries && CS_READ(sc, AD1848_IADDR) == SP_IN_INIT; tries--)
		DELAY(10);
	if (tries == 0)
		printf("%s: timeout committing fspb\n", sc->sc_dev.dv_xname);

	CS_WRITE(sc, AD1848_IADDR, MODE_CHANGE_ENABLE | CS_REC_FORMAT);
	CS_WRITE(sc, AD1848_IDATA, fs);
	CS_READ(sc, AD1848_IDATA);
	CS_READ(sc, AD1848_IDATA);
	for (tries = CS_TIMEOUT;
	     tries && CS_READ(sc, AD1848_IADDR) == SP_IN_INIT; tries--)
		DELAY(10);
	if (tries == 0)
		printf("%s: timeout committing cdf\n", sc->sc_dev.dv_xname);

	CS_WRITE(sc, AD1848_IADDR, 0);
	for (tries = CS_TIMEOUT;
	     tries && CS_READ(sc, AD1848_IADDR) == SP_IN_INIT; tries--)
		DELAY(10);
	if (tries == 0)
		printf("%s: timeout waiting for !mce\n", sc->sc_dev.dv_xname);

	CS_WRITE(sc, AD1848_IADDR, SP_TEST_AND_INIT);
	for (tries = CS_TIMEOUT;
	     tries && CS_READ(sc, AD1848_IDATA) & AUTO_CAL_IN_PROG; tries--)
		DELAY(10);
	if (tries == 0)
		printf("%s: timeout waiting for autocalibration\n",
		    sc->sc_dev.dv_xname);

	mtx_leave(&audio_lock);

	sc->sc_need_commit = 0;
	return (0);
}

int
ce4231_halt_output(addr)
	void *addr;
{
	struct ce4231_softc *sc = (struct ce4231_softc *)addr;

	P_WRITE(sc, EBDMA_DCSR,
	    P_READ(sc, EBDMA_DCSR) & ~EBDCSR_DMAEN);
	ce4231_write(sc, SP_INTERFACE_CONFIG,
	    ce4231_read(sc, SP_INTERFACE_CONFIG) & (~PLAYBACK_ENABLE));
	return (0);
}

int
ce4231_halt_input(addr)
	void *addr;
{
	struct ce4231_softc *sc = (struct ce4231_softc *)addr;

	C_WRITE(sc, EBDMA_DCSR,
	    C_READ(sc, EBDMA_DCSR) & ~EBDCSR_DMAEN);
	ce4231_write(sc, SP_INTERFACE_CONFIG,
	    ce4231_read(sc, SP_INTERFACE_CONFIG) & (~CAPTURE_ENABLE));
	return (0);
}

void
ce4231_set_outputs(struct ce4231_softc *sc, int mask)
{
	u_int8_t val;

	val = ce4231_read(sc, CS_MONO_IO_CONTROL) & ~MONO_OUTPUT_MUTE;
	if (!(mask & OUT_PORT_SPKR))
		val |= MONO_OUTPUT_MUTE;
	ce4231_write(sc, CS_MONO_IO_CONTROL, val);

	val = ce4231_read(sc, SP_PIN_CONTROL) & ~(XCTL0_ENABLE | XCTL1_ENABLE);
	if (!(mask & OUT_PORT_LINE))
		val |= XCTL0_ENABLE;
	if (!(mask & OUT_PORT_HP))
		val |= XCTL1_ENABLE;
	ce4231_write(sc, SP_PIN_CONTROL, val);
}

int
ce4231_get_outputs(struct ce4231_softc *sc)
{
	int mask = 0;
	u_int8_t val;

	if (!(ce4231_read(sc, CS_MONO_IO_CONTROL) & MONO_OUTPUT_MUTE))
		mask |= OUT_PORT_SPKR;

	val = ce4231_read(sc, SP_PIN_CONTROL);
	if (!(val & XCTL0_ENABLE))
		mask |= OUT_PORT_LINE;
	if (!(val & XCTL1_ENABLE))
		mask |= OUT_PORT_HP;

	return (mask);
}

int
ce4231_set_port(void *addr, mixer_ctrl_t *cp)
{
	struct ce4231_softc *sc = (struct ce4231_softc *)addr;
	u_int8_t l, r;

	DPRINTF(("ce4231_set_port: dev=%d type=%d\n", cp->dev, cp->type));

	switch (cp->dev) {

	case CSAUDIO_DAC_LVL:
		if (cp->type != AUDIO_MIXER_VALUE)
			return (EINVAL);
		l = ce4231_read(sc, SP_LEFT_OUTPUT_CONTROL) &
		    OUTPUT_ATTEN_MASK;
		r = ce4231_read(sc, SP_RIGHT_OUTPUT_CONTROL) &
		    OUTPUT_ATTEN_MASK;
		l |= (AUDIO_MAX_GAIN -
		    cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT]) >> 2;
		r |= (AUDIO_MAX_GAIN -
		    cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT]) >> 2;
		ce4231_write(sc, SP_LEFT_OUTPUT_CONTROL, l);
		ce4231_write(sc, SP_RIGHT_OUTPUT_CONTROL, r);
		break;
	case CSAUDIO_DAC_MUTE:
		if (cp->type != AUDIO_MIXER_ENUM)
			return (EINVAL);
		l = ce4231_read(sc, SP_LEFT_OUTPUT_CONTROL) & ~OUTPUT_MUTE;
		r = ce4231_read(sc, SP_RIGHT_OUTPUT_CONTROL) & ~OUTPUT_MUTE;
		if (cp->un.ord) {
			l |= OUTPUT_MUTE;
			r |= OUTPUT_MUTE;
		}
		ce4231_write(sc, SP_LEFT_OUTPUT_CONTROL, l);
		ce4231_write(sc, SP_RIGHT_OUTPUT_CONTROL, r);
		break;

	case CSAUDIO_OUTPUTS:
		if (cp->type != AUDIO_MIXER_SET)
			return (EINVAL);
		ce4231_set_outputs(sc, cp->un.mask);
		break;

	case CSAUDIO_CD_LVL:
		if (cp->type != AUDIO_MIXER_VALUE)
			return (EINVAL);
		l = ce4231_read(sc, SP_LEFT_AUX1_CONTROL) &
		    AUX_INPUT_ATTEN_MASK;
		r = ce4231_read(sc, SP_RIGHT_AUX1_CONTROL) &
		    AUX_INPUT_ATTEN_MASK;
		l |= (AUDIO_MAX_GAIN -
		    cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT]) >> 3;
		r |= (AUDIO_MAX_GAIN -
		    cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT]) >> 3;
		ce4231_write(sc, SP_LEFT_AUX1_CONTROL, l);
		ce4231_write(sc, SP_RIGHT_AUX1_CONTROL, r);
		break;
	case CSAUDIO_CD_MUTE:
		if (cp->type != AUDIO_MIXER_ENUM)
			return (EINVAL);
		l = ce4231_read(sc, SP_LEFT_AUX1_CONTROL) & ~AUX_INPUT_MUTE;
		r = ce4231_read(sc, SP_RIGHT_AUX1_CONTROL) & ~AUX_INPUT_MUTE;
		if (cp->un.ord) {
			l |= AUX_INPUT_MUTE;
			r |= AUX_INPUT_MUTE;
		}
		ce4231_write(sc, SP_LEFT_AUX1_CONTROL, l);
		ce4231_write(sc, SP_RIGHT_AUX1_CONTROL, r);
		break;

	case CSAUDIO_LINE_IN_LVL:
		if (cp->type != AUDIO_MIXER_VALUE)
			return (EINVAL);
		l = ce4231_read(sc, CS_LEFT_LINE_CONTROL) &
		    LINE_INPUT_ATTEN_MASK;
		r = ce4231_read(sc, CS_RIGHT_LINE_CONTROL) &
		    LINE_INPUT_ATTEN_MASK;
		l |= (AUDIO_MAX_GAIN -
		    cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT]) >> 3;
		r |= (AUDIO_MAX_GAIN -
		    cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT]) >> 3;
		ce4231_write(sc, CS_LEFT_LINE_CONTROL, l);
		ce4231_write(sc, CS_RIGHT_LINE_CONTROL, r);
		break;
	case CSAUDIO_LINE_IN_MUTE:
		l = ce4231_read(sc, CS_LEFT_LINE_CONTROL) & ~LINE_INPUT_MUTE;
		r = ce4231_read(sc, CS_RIGHT_LINE_CONTROL) & ~LINE_INPUT_MUTE;
		if (cp->un.ord) {
			l |= LINE_INPUT_MUTE;
			r |= LINE_INPUT_MUTE;
		}
		ce4231_write(sc, CS_LEFT_LINE_CONTROL, l);
		ce4231_write(sc, CS_RIGHT_LINE_CONTROL, r);
		break;

	case CSAUDIO_MONITOR_LVL:
		if (cp->type != AUDIO_MIXER_VALUE)
			return (EINVAL);
		if (cp->un.value.num_channels != 1)
			return (EINVAL);
		l = ce4231_read(sc, SP_DIGITAL_MIX) & ~MIX_ATTEN_MASK;
		l |= (AUDIO_MAX_GAIN -
		    cp->un.value.level[AUDIO_MIXER_LEVEL_MONO]) &
		    MIX_ATTEN_MASK;
		ce4231_write(sc, SP_DIGITAL_MIX, l);
		break;
	case CSAUDIO_MONITOR_MUTE:
		if (cp->type != AUDIO_MIXER_ENUM)
			return (EINVAL);
		l = ce4231_read(sc, SP_DIGITAL_MIX) & ~DIGITAL_MIX1_ENABLE;
		if (!cp->un.ord)
			l |= DIGITAL_MIX1_ENABLE;
		ce4231_write(sc, SP_DIGITAL_MIX, l);
		break;

	case CSAUDIO_REC_LVL:
		if (cp->type != AUDIO_MIXER_VALUE)
			return (EINVAL);
		l = ce4231_read(sc, SP_LEFT_INPUT_CONTROL) & INPUT_GAIN_MASK;
		r = ce4231_read(sc, SP_RIGHT_INPUT_CONTROL) & INPUT_GAIN_MASK;
		l = cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT] >> 4;
		r = cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT] >> 4;
		ce4231_write(sc, SP_LEFT_INPUT_CONTROL, l);
		ce4231_write(sc, SP_RIGHT_INPUT_CONTROL, r);
		break;
	case CSAUDIO_RECORD_SOURCE:
		if (cp->type != AUDIO_MIXER_ENUM)
			return (EINVAL);
		l = ce4231_read(sc, SP_LEFT_INPUT_CONTROL) & INPUT_SOURCE_MASK;
		r = ce4231_read(sc, SP_RIGHT_INPUT_CONTROL) & INPUT_SOURCE_MASK;
		l |= cp->un.ord << 6;
		r |= cp->un.ord << 6;
		ce4231_write(sc, SP_LEFT_INPUT_CONTROL, l);
		ce4231_write(sc, SP_RIGHT_INPUT_CONTROL, r);
		break;

	case CSAUDIO_MIC_PREAMP:
		if (cp->type != AUDIO_MIXER_ENUM)
			return (EINVAL);
		l = ce4231_read(sc, SP_LEFT_INPUT_CONTROL) &
		    ~INPUT_MIC_GAIN_ENABLE;
		r = ce4231_read(sc, SP_RIGHT_INPUT_CONTROL) &
		    ~INPUT_MIC_GAIN_ENABLE;
		if (cp->un.ord) {
			l |= INPUT_MIC_GAIN_ENABLE;
			r |= INPUT_MIC_GAIN_ENABLE;
		}
		ce4231_write(sc, SP_LEFT_INPUT_CONTROL, l);
		ce4231_write(sc, SP_RIGHT_INPUT_CONTROL, r);
		break;

	default:
		return (EINVAL);
	}

	return (0);
}

int
ce4231_get_port(void *addr, mixer_ctrl_t *cp)
{
	struct ce4231_softc *sc = (struct ce4231_softc *)addr;

	DPRINTF(("ce4231_get_port: port=%d type=%d\n", cp->dev, cp->type));

	switch (cp->dev) {

	case CSAUDIO_DAC_LVL:
		if (cp->type != AUDIO_MIXER_VALUE)
			return (EINVAL);
		cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT] =
		    AUDIO_MAX_GAIN - ((ce4231_read(sc, SP_LEFT_OUTPUT_CONTROL) &
		    OUTPUT_ATTEN_BITS) << 2);
		cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT] =
		    AUDIO_MAX_GAIN - ((ce4231_read(sc, SP_RIGHT_OUTPUT_CONTROL) &
		    OUTPUT_ATTEN_BITS) << 2);
		break;
	case CSAUDIO_DAC_MUTE:
		if (cp->type != AUDIO_MIXER_ENUM)
			return (EINVAL);
		cp->un.ord = (ce4231_read(sc, SP_LEFT_OUTPUT_CONTROL) &
		    OUTPUT_MUTE) ? 1 : 0;
		break;

	case CSAUDIO_OUTPUTS:
		if (cp->type != AUDIO_MIXER_SET)
			return (EINVAL);
		cp->un.mask = ce4231_get_outputs(sc);
		break;

	case CSAUDIO_CD_LVL:
		if (cp->type != AUDIO_MIXER_VALUE)
			return (EINVAL);
		cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT] =
		    AUDIO_MAX_GAIN - ((ce4231_read(sc, SP_LEFT_AUX1_CONTROL) &
		    AUX_INPUT_ATTEN_BITS) << 3);
		cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT] =
		    AUDIO_MAX_GAIN - ((ce4231_read(sc, SP_RIGHT_AUX1_CONTROL) &
		    AUX_INPUT_ATTEN_BITS) << 3);
		break;
	case CSAUDIO_CD_MUTE:
		if (cp->type != AUDIO_MIXER_ENUM)
			return (EINVAL);
		cp->un.ord = (ce4231_read(sc, SP_LEFT_AUX1_CONTROL) &
		    AUX_INPUT_MUTE) ? 1 : 0;
		break;

	case CSAUDIO_LINE_IN_LVL:
		if (cp->type != AUDIO_MIXER_VALUE)
			return (EINVAL);
		cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT] =
		    AUDIO_MAX_GAIN - ((ce4231_read(sc, CS_LEFT_LINE_CONTROL) &
		    LINE_INPUT_ATTEN_BITS) << 3);
		cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT] =
		    AUDIO_MAX_GAIN - ((ce4231_read(sc, CS_RIGHT_LINE_CONTROL) &
		    LINE_INPUT_ATTEN_BITS) << 3);
		break;
	case CSAUDIO_LINE_IN_MUTE:
		if (cp->type != AUDIO_MIXER_ENUM)
			return (EINVAL);
		cp->un.ord = (ce4231_read(sc, CS_LEFT_LINE_CONTROL) &
		    LINE_INPUT_MUTE) ? 1 : 0;
		break;

	case CSAUDIO_MONITOR_LVL:
		if (cp->type != AUDIO_MIXER_VALUE)
			return (EINVAL);
		if (cp->un.value.num_channels != 1)
			return (EINVAL);
		cp->un.value.level[AUDIO_MIXER_LEVEL_MONO] =
		    AUDIO_MAX_GAIN - (ce4231_read(sc, SP_DIGITAL_MIX) &
		    MIX_ATTEN_MASK);
		break;
	case CSAUDIO_MONITOR_MUTE:
		if (cp->type != AUDIO_MIXER_ENUM)
			return (EINVAL);
		cp->un.ord = (ce4231_read(sc, SP_DIGITAL_MIX) &
		    DIGITAL_MIX1_ENABLE) ? 0 : 1;
		break;

	case CSAUDIO_REC_LVL:
		if (cp->type != AUDIO_MIXER_VALUE)
			return (EINVAL);
		cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT] =
		    (ce4231_read(sc, SP_LEFT_INPUT_CONTROL) &
		    ~INPUT_GAIN_MASK) << 4;
		cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT] =
		    (ce4231_read(sc, SP_RIGHT_INPUT_CONTROL) &
		    ~INPUT_GAIN_MASK) << 4;
		break;
	case CSAUDIO_RECORD_SOURCE:
		if (cp->type != AUDIO_MIXER_ENUM)
			return (EINVAL);
		cp->un.ord = (ce4231_read(sc, SP_LEFT_INPUT_CONTROL) &
		    CS_REC_SRC_BITS) >> 6;
		break;

	case CSAUDIO_MIC_PREAMP:
		if (cp->type != AUDIO_MIXER_ENUM)
			return (EINVAL);
		cp->un.ord = (ce4231_read(sc, SP_LEFT_INPUT_CONTROL) &
		    INPUT_MIC_GAIN_ENABLE) ? 1 : 0;
		break;

	default:
		return (EINVAL);
	}
	return (0);
}

int
ce4231_query_devinfo(void *addr, mixer_devinfo_t *dip)
{
	size_t nsize = MAX_AUDIO_DEV_LEN;
	int err = 0;

	switch (dip->index) {
	case CSAUDIO_INPUT_CLASS:
		dip->type = AUDIO_MIXER_CLASS;
		dip->mixer_class = CSAUDIO_INPUT_CLASS;
		dip->prev = dip->next = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioCinputs, nsize);
		break;
	case CSAUDIO_OUTPUT_CLASS:
		dip->type = AUDIO_MIXER_CLASS;
		dip->mixer_class = CSAUDIO_OUTPUT_CLASS;
		dip->prev = dip->next = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioCoutputs, nsize);
		break;
	case CSAUDIO_RECORD_CLASS:
		dip->type = AUDIO_MIXER_CLASS;
		dip->mixer_class = CSAUDIO_RECORD_CLASS;
		dip->prev = dip->next = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioCrecord, nsize);
		break;

	case CSAUDIO_DAC_LVL:
		dip->type = AUDIO_MIXER_VALUE;
		dip->mixer_class = CSAUDIO_OUTPUT_CLASS;
		dip->prev = AUDIO_MIXER_LAST;
		dip->next = CSAUDIO_DAC_MUTE;
		strlcpy(dip->label.name, AudioNdac, nsize);
		dip->un.v.num_channels = 2;
		dip->un.v.delta = 4;
		strlcpy(dip->un.v.units.name, AudioNvolume, nsize);
		break;
	case CSAUDIO_DAC_MUTE:
		dip->type = AUDIO_MIXER_ENUM;
		dip->mixer_class = CSAUDIO_OUTPUT_CLASS;
		dip->prev = CSAUDIO_DAC_LVL;
		dip->next = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioNmute, nsize);
		goto onoff;

	case CSAUDIO_OUTPUTS:
		dip->type = AUDIO_MIXER_SET;
		dip->mixer_class = CSAUDIO_OUTPUT_CLASS;
		dip->prev = dip->next = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioNoutput, nsize);
		dip->un.s.num_mem = 3;
		strlcpy(dip->un.s.member[0].label.name, AudioNline, nsize);
		dip->un.s.member[0].mask = OUT_PORT_LINE;
		strlcpy(dip->un.s.member[1].label.name, AudioNheadphone, nsize);
		dip->un.s.member[1].mask = OUT_PORT_HP;
		strlcpy(dip->un.s.member[2].label.name, AudioNspeaker, nsize);
		dip->un.s.member[2].mask = OUT_PORT_SPKR;
		break;

	case CSAUDIO_CD_LVL:
		dip->type = AUDIO_MIXER_VALUE;
		dip->mixer_class = CSAUDIO_INPUT_CLASS;
		dip->prev = AUDIO_MIXER_LAST;
		dip->next = CSAUDIO_CD_MUTE;
		strlcpy(dip->label.name, AudioNcd, nsize);
		dip->un.v.num_channels = 2;
		dip->un.v.delta = 8;
		strlcpy(dip->un.v.units.name, AudioNvolume, nsize);
		break;
	case CSAUDIO_CD_MUTE:
		dip->type = AUDIO_MIXER_ENUM;
		dip->mixer_class = CSAUDIO_INPUT_CLASS;
		dip->prev = CSAUDIO_CD_LVL;
		dip->next = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioNmute, nsize);
		goto onoff;

	case CSAUDIO_LINE_IN_LVL:
		dip->type = AUDIO_MIXER_VALUE;
		dip->mixer_class = CSAUDIO_INPUT_CLASS;
		dip->prev = AUDIO_MIXER_LAST;
		dip->next = CSAUDIO_LINE_IN_MUTE;
		strlcpy(dip->label.name, AudioNline, nsize);
		dip->un.v.num_channels = 2;
		dip->un.v.delta = 8;
		strlcpy(dip->un.v.units.name, AudioNvolume, nsize);
		break;
	case CSAUDIO_LINE_IN_MUTE:
		dip->type = AUDIO_MIXER_ENUM;
		dip->mixer_class = CSAUDIO_INPUT_CLASS;
		dip->prev = CSAUDIO_LINE_IN_LVL;
		dip->next = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioNmute, nsize);
		goto onoff;

	case CSAUDIO_MONITOR_LVL:
		dip->type = AUDIO_MIXER_VALUE;
		dip->mixer_class = CSAUDIO_OUTPUT_CLASS;
		dip->prev = AUDIO_MIXER_LAST;
		dip->next = CSAUDIO_MONITOR_MUTE;
		strlcpy(dip->label.name, AudioNmonitor, nsize);
		dip->un.v.num_channels = 1;
		dip->un.v.delta = 4;
		strlcpy(dip->un.v.units.name, AudioNvolume, nsize);
		break;
	case CSAUDIO_MONITOR_MUTE:
		dip->type = AUDIO_MIXER_ENUM;
		dip->mixer_class = CSAUDIO_OUTPUT_CLASS;
		dip->prev = CSAUDIO_MONITOR_LVL;
		dip->next = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioNmute, nsize);
		goto onoff;

	case CSAUDIO_REC_LVL:
		dip->type = AUDIO_MIXER_VALUE;
		dip->mixer_class = CSAUDIO_RECORD_CLASS;
		dip->prev = dip->next = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioNvolume, nsize);
		dip->un.v.num_channels = 2;
		dip->un.v.delta = 16;
		strlcpy(dip->un.v.units.name, AudioNvolume, nsize);
		break;
	case CSAUDIO_RECORD_SOURCE:
		dip->type = AUDIO_MIXER_ENUM;
		dip->mixer_class = CSAUDIO_RECORD_CLASS;
		dip->prev = dip->next = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioNsource, nsize);
		dip->un.e.num_mem = 4;
		strlcpy(dip->un.e.member[0].label.name, AudioNline, nsize);
		dip->un.e.member[0].ord = REC_PORT_LINE;
		strlcpy(dip->un.e.member[1].label.name, AudioNcd, nsize);
		dip->un.e.member[1].ord = REC_PORT_CD;
		strlcpy(dip->un.e.member[2].label.name, AudioNmicrophone, nsize);
		dip->un.e.member[2].ord = REC_PORT_MIC;
		strlcpy(dip->un.e.member[3].label.name, AudioNmixerout, nsize);
		dip->un.e.member[3].ord = REC_PORT_MIX;
		break;

	case CSAUDIO_MIC_PREAMP:
		dip->type = AUDIO_MIXER_ENUM;
		dip->mixer_class = CSAUDIO_RECORD_CLASS;
		dip->prev = dip->next = AUDIO_MIXER_LAST;
		snprintf(dip->label.name, nsize, "%s_%s", AudioNmicrophone,
		   AudioNpreamp);
		goto onoff;

onoff:
		dip->un.e.num_mem = 2;
		strlcpy(dip->un.e.member[0].label.name, AudioNon, nsize);
		dip->un.e.member[0].ord = 1;
		strlcpy(dip->un.e.member[1].label.name, AudioNoff, nsize);
		dip->un.e.member[1].ord = 0;
		break;

	default:
		err = ENXIO;
	}

	return (err);
}

int
ce4231_get_props(addr)
	void *addr;
{
	return (AUDIO_PROP_FULLDUPLEX);
}

/*
 * Hardware interrupt handler
 */
/*
 * Don't bother with the AD1848_STATUS register.  It's interrupt bit gets
 * set for both recording and playback interrupts.  But we have separate
 * handlers for playback and recording, and if we clear the status in
 * one handler while there is an interrupt pending for the other direction
 * as well, we'll never notice the interrupt for the other direction.
 *
 * Instead rely solely on CS_IRQ_STATUS, which has separate bits for
 * playback and recording interrupts.  Also note that resetting
 * AD1848_STATUS clears the interrupt bits in CS_IRQ_STATUS.
 */

int
ce4231_pintr(v)
	void *v;
{
	struct ce4231_softc *sc = (struct ce4231_softc *)v;
	u_int32_t csr;
	u_int8_t reg;
	struct cs_dma *p;
	struct cs_chdma *chdma = &sc->sc_pchdma;
	int r = 0;

	mtx_enter(&audio_lock);
	csr = P_READ(sc, EBDMA_DCSR);

	reg = ce4231_read(sc, CS_IRQ_STATUS);
	if (reg & CS_IRQ_PI) {
		ce4231_write(sc, SP_LOWER_BASE_COUNT, 0xff);
		ce4231_write(sc, SP_UPPER_BASE_COUNT, 0xff);
		ce4231_write(sc, CS_IRQ_STATUS, reg & ~CS_IRQ_PI);
	}

	P_WRITE(sc, EBDMA_DCSR, csr);

	if (csr & EBDCSR_INT)
		r = 1;

	if ((csr & EBDCSR_TC) || ((csr & EBDCSR_A_LOADED) == 0)) {
		u_long nextaddr, togo;

		p = chdma->cur_dma;
		togo = chdma->segsz - chdma->count;
		if (togo == 0) {
			nextaddr = (u_int32_t)p->dmamap->dm_segs[0].ds_addr;
			chdma->count = togo = chdma->blksz;
		} else {
			nextaddr = chdma->lastaddr;
			if (togo > chdma->blksz)
				togo = chdma->blksz;
			chdma->count += togo;
		}

		P_WRITE(sc, EBDMA_DCNT, togo);
		P_WRITE(sc, EBDMA_DADDR, nextaddr);
		chdma->lastaddr = nextaddr + togo;

		if (sc->sc_pintr != NULL)
			(*sc->sc_pintr)(sc->sc_parg);
		r = 1;
	}
	mtx_leave(&audio_lock);
	return (r);
}

int
ce4231_cintr(v)
	void *v;
{
	struct ce4231_softc *sc = (struct ce4231_softc *)v;
	u_int32_t csr;
	u_int8_t reg;
	struct cs_dma *p;
	struct cs_chdma *chdma = &sc->sc_rchdma;
	int r = 0;

	mtx_enter(&audio_lock);
	csr = C_READ(sc, EBDMA_DCSR);

	reg = ce4231_read(sc, CS_IRQ_STATUS);
	if (reg & CS_IRQ_CI) {
		ce4231_write(sc, CS_LOWER_REC_CNT, 0xff);
		ce4231_write(sc, CS_UPPER_REC_CNT, 0xff);
		ce4231_write(sc, CS_IRQ_STATUS, reg & ~CS_IRQ_CI);
	}

	C_WRITE(sc, EBDMA_DCSR, csr);

	if (csr & EBDCSR_INT)
		r = 1;

	if ((csr & EBDCSR_TC) || ((csr & EBDCSR_A_LOADED) == 0)) {
		u_long nextaddr, togo;

		p = chdma->cur_dma;
		togo = chdma->segsz - chdma->count;
		if (togo == 0) {
			nextaddr = (u_int32_t)p->dmamap->dm_segs[0].ds_addr;
			chdma->count = togo = chdma->blksz;
		} else {
			nextaddr = chdma->lastaddr;
			if (togo > chdma->blksz)
				togo = chdma->blksz;
			chdma->count += togo;
		}

		C_WRITE(sc, EBDMA_DCNT, togo);
		C_WRITE(sc, EBDMA_DADDR, nextaddr);
		chdma->lastaddr = nextaddr + togo;

		if (sc->sc_rintr != NULL)
			(*sc->sc_rintr)(sc->sc_rarg);
		r = 1;
	}
	mtx_leave(&audio_lock);
	return (r);
}

void *
ce4231_alloc(addr, direction, size, pool, flags)
	void *addr;
	int direction;
	size_t size;
	int pool;
	int flags;
{
	struct ce4231_softc *sc = (struct ce4231_softc *)addr;
	bus_dma_tag_t dmat = sc->sc_dmatag;
	struct cs_dma *p;

	p = (struct cs_dma *)malloc(sizeof(struct cs_dma), pool, flags);
	if (p == NULL)
		return (NULL);

	if (bus_dmamap_create(dmat, size, 1, size, 0,
	    BUS_DMA_NOWAIT, &p->dmamap) != 0)
		goto fail;

	p->size = size;

	if (bus_dmamem_alloc(dmat, size, 64*1024, 0, p->segs,
	    sizeof(p->segs)/sizeof(p->segs[0]), &p->nsegs,
	    BUS_DMA_NOWAIT) != 0)
		goto fail1;

	if (bus_dmamem_map(dmat, p->segs, p->nsegs, p->size,
	    &p->addr, BUS_DMA_NOWAIT | BUS_DMA_COHERENT) != 0)
		goto fail2;

	if (bus_dmamap_load(dmat, p->dmamap, p->addr, size, NULL,
	    BUS_DMA_NOWAIT) != 0)
		goto fail3;

	p->next = sc->sc_dmas;
	sc->sc_dmas = p;
	return (p->addr);

fail3:
	bus_dmamem_unmap(dmat, p->addr, p->size);
fail2:
	bus_dmamem_free(dmat, p->segs, p->nsegs);
fail1:
	bus_dmamap_destroy(dmat, p->dmamap);
fail:
	free(p, pool, 0);
	return (NULL);
}

void
ce4231_free(addr, ptr, pool)
	void *addr;
	void *ptr;
	int pool;
{
	struct ce4231_softc *sc = addr;
	bus_dma_tag_t dmat = sc->sc_dmatag;
	struct cs_dma *p, **pp;

	for (pp = &sc->sc_dmas; (p = *pp) != NULL; pp = &(*pp)->next) {
		if (p->addr != ptr)
			continue;
		bus_dmamap_unload(dmat, p->dmamap);
		bus_dmamem_unmap(dmat, p->addr, p->size);
		bus_dmamem_free(dmat, p->segs, p->nsegs);
		bus_dmamap_destroy(dmat, p->dmamap);
		*pp = p->next;
		free(p, pool, 0);
		return;
	}
	printf("%s: attempt to free rogue pointer\n", sc->sc_dev.dv_xname);
}

int
ce4231_trigger_output(addr, start, end, blksize, intr, arg, param)
	void *addr, *start, *end;
	int blksize;
	void (*intr)(void *);
	void *arg;
	struct audio_params *param;
{
	struct ce4231_softc *sc = addr;
	struct cs_dma *p;
	struct cs_chdma *chdma = &sc->sc_pchdma;
	u_int32_t csr;
	vaddr_t n;

	sc->sc_pintr = intr;
	sc->sc_parg = arg;

	for (p = sc->sc_dmas; p->addr != start; p = p->next)
		/*EMPTY*/;
	if (p == NULL) {
		printf("%s: trigger_output: bad addr: %p\n",
		    sc->sc_dev.dv_xname, start);
		return (EINVAL);
	}

	n = (char *)end - (char *)start;

	/*
	 * Do only `blksize' at a time, so audio_pint() is kept
	 * synchronous with us...
	 */
	chdma->cur_dma = p;
	chdma->blksz = blksize;
	chdma->segsz = n;

	if (n > chdma->blksz)
		n = chdma->blksz;

	chdma->count = n;

	csr = P_READ(sc, EBDMA_DCSR);
	if (csr & EBDCSR_DMAEN) {
		P_WRITE(sc, EBDMA_DCNT, (u_long)n);
		P_WRITE(sc, EBDMA_DADDR,
		    (u_long)p->dmamap->dm_segs[0].ds_addr);
	} else {
		P_WRITE(sc, EBDMA_DCSR, EBDCSR_RESET);
		P_WRITE(sc, EBDMA_DCSR, sc->sc_burst);

		P_WRITE(sc, EBDMA_DCNT, (u_long)n);
		P_WRITE(sc, EBDMA_DADDR,
		    (u_long)p->dmamap->dm_segs[0].ds_addr);

		P_WRITE(sc, EBDMA_DCSR, sc->sc_burst | EBDCSR_DMAEN |
		    EBDCSR_INTEN | EBDCSR_CNTEN | EBDCSR_NEXTEN);

		ce4231_write(sc, SP_LOWER_BASE_COUNT, 0xff);
		ce4231_write(sc, SP_UPPER_BASE_COUNT, 0xff);
		ce4231_write(sc, SP_INTERFACE_CONFIG,
		    ce4231_read(sc, SP_INTERFACE_CONFIG) | PLAYBACK_ENABLE);
	}
	chdma->lastaddr = p->dmamap->dm_segs[0].ds_addr + n;

	return (0);
}

int
ce4231_trigger_input(addr, start, end, blksize, intr, arg, param)
	void *addr, *start, *end;
	int blksize;
	void (*intr)(void *);
	void *arg;
	struct audio_params *param;
{
	struct ce4231_softc *sc = addr;
	struct cs_dma *p;
	struct cs_chdma *chdma = &sc->sc_rchdma;
	u_int32_t csr;
	vaddr_t n;

	sc->sc_rintr = intr;
	sc->sc_rarg = arg;

	for (p = sc->sc_dmas; p->addr != start; p = p->next)
		/*EMPTY*/;
	if (p == NULL) {
		printf("%s: trigger_input: bad addr: %p\n",
		    sc->sc_dev.dv_xname, start);
		return (EINVAL);
	}

	n = (char *)end - (char *)start;

	/*
	 * Do only `blksize' at a time, so audio_rint() is kept
	 * synchronous with us...
	 */
	chdma->cur_dma = p;
	chdma->blksz = blksize;
	chdma->segsz = n;

	if (n > chdma->blksz)
		n = chdma->blksz;

	chdma->count = n;

	csr = C_READ(sc, EBDMA_DCSR);
	if (csr & EBDCSR_DMAEN) {
		C_WRITE(sc, EBDMA_DCNT, (u_long)n);
		C_WRITE(sc, EBDMA_DADDR,
		    (u_long)p->dmamap->dm_segs[0].ds_addr);
	} else {
		C_WRITE(sc, EBDMA_DCSR, EBDCSR_RESET);
		C_WRITE(sc, EBDMA_DCSR, sc->sc_burst);

		C_WRITE(sc, EBDMA_DCNT, (u_long)n);
		C_WRITE(sc, EBDMA_DADDR,
		    (u_long)p->dmamap->dm_segs[0].ds_addr);

		C_WRITE(sc, EBDMA_DCSR, sc->sc_burst | EBDCSR_WRITE |
		    EBDCSR_DMAEN | EBDCSR_INTEN | EBDCSR_CNTEN | EBDCSR_NEXTEN);

		ce4231_write(sc, CS_LOWER_REC_CNT, 0xff);
		ce4231_write(sc, CS_UPPER_REC_CNT, 0xff);
		ce4231_write(sc, SP_INTERFACE_CONFIG,
		    ce4231_read(sc, SP_INTERFACE_CONFIG) | CAPTURE_ENABLE);
	}
	chdma->lastaddr = p->dmamap->dm_segs[0].ds_addr + n;

	return (0);
}
@


1.34
log
@Remove drain(), query_encoding(), mappage() and get_default_params()
methods from all audio drivers and from the audio_if structure as they
are never called.
@
text
@d1 1
a1 1
/*	$OpenBSD: ce4231.c,v 1.32 2015/05/11 06:46:21 ratchov Exp $	*/
a141 1
int	ce4231_getdev(void *, struct audio_device *);
a165 1
	ce4231_getdev,
a185 6
struct audio_device ce4231_device = {
	"SUNW,CS4231",
	"b",
	"onboard1",
};

a612 9
	return (0);
}

int
ce4231_getdev(addr, retp)
	void *addr;
	struct audio_device *retp;
{
	*retp = ce4231_device;
@


1.33
log
@Remove support for ADPCM encoding which isn't used nowadays and
not available to programs anyway.
@
text
@a135 1
int	ce4231_query_encoding(void *, struct audio_encoding *);
a156 2
	0,
	ce4231_query_encoding,
a174 1
	0,
d177 1
a177 2
	ce4231_trigger_input,
	0
a463 46
}

int
ce4231_query_encoding(addr, fp)
	void *addr;
	struct audio_encoding *fp;
{
	int err = 0;

	switch (fp->index) {
	case 0:
		strlcpy(fp->name, AudioEmulaw, sizeof(fp->name));
		fp->encoding = AUDIO_ENCODING_ULAW;
		fp->precision = 8;
		fp->flags = 0;
		break;
	case 1:
		strlcpy(fp->name, AudioEalaw, sizeof(fp->name));
		fp->encoding = AUDIO_ENCODING_ALAW;
		fp->precision = 8;
		fp->flags = 0;
		break;
	case 2:
		strlcpy(fp->name, AudioEslinear_le, sizeof(fp->name));
		fp->encoding = AUDIO_ENCODING_SLINEAR_LE;
		fp->precision = 16;
		fp->flags = 0;
		break;
	case 3:
		strlcpy(fp->name, AudioEulinear, sizeof(fp->name));
		fp->encoding = AUDIO_ENCODING_ULINEAR;
		fp->precision = 8;
		fp->flags = 0;
		break;
	case 4:
		strlcpy(fp->name, AudioEslinear_be, sizeof(fp->name));
		fp->encoding = AUDIO_ENCODING_SLINEAR_BE;
		fp->precision = 16;
		fp->flags = 0;
		break;
	default:
		err = EINVAL;
	}
	fp->bps = AUDIO_BPS(fp->precision);
	fp->msb = 1;
	return (err);
@


1.32
log
@Remove all audio format conversion code from the kernel (btw holding
the kernel_lock), as we already do better conversions in
user-mode. Yet, no need for every single driver to fiddle with the
conversion code as they are done transparently by common MI code. With
help from armani and miod, support from mpi

ok armani@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ce4231.c,v 1.31 2014/07/12 18:44:43 tedu Exp $	*/
a508 6
	case 5:
		strlcpy(fp->name, AudioEadpcm, sizeof(fp->name));
		fp->encoding = AUDIO_ENCODING_ADPCM;
		fp->precision = 8;
		fp->flags = 0;
		break;
a547 4
		break;
	case AUDIO_ENCODING_ADPCM:
		p->precision = 8;
		bits = FMT_ADPCM >> 5;
@


1.31
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: ce4231.c,v 1.30 2013/05/16 06:31:50 kettenis Exp $	*/
a53 1
#include <dev/auconv.h>
a509 18
		strlcpy(fp->name, AudioEslinear, sizeof(fp->name));
		fp->encoding = AUDIO_ENCODING_SLINEAR;
		fp->precision = 8;
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 6:
		strlcpy(fp->name, AudioEulinear_le, sizeof(fp->name));
		fp->encoding = AUDIO_ENCODING_ULINEAR_LE;
		fp->precision = 16;
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 7:
		strlcpy(fp->name, AudioEulinear_be, sizeof(fp->name));
		fp->encoding = AUDIO_ENCODING_ULINEAR_BE;
		fp->precision = 16;
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 8:
a530 2
	void (*pswcode)(void *, u_char *, int cnt) = NULL;
	void (*rswcode)(void *, u_char *, int cnt) = NULL;
d536 1
a536 2
		if (p->precision != 8)
			p->precision = 8;
d540 1
a540 2
		if (p->precision != 8)
			p->precision = 8;
d544 2
a545 10
		if (p->precision == 8) {
			bits = FMT_PCM8 >> 5;
			pswcode = rswcode = change_sign8;
		} else
			bits = FMT_TWOS_COMP >> 5;
		break;
	case AUDIO_ENCODING_ULINEAR:
		if (p->precision != 8)
			p->precision = 8;
		bits = FMT_PCM8 >> 5;
d548 2
a549 11
		if (p->precision == 8) {
			bits = FMT_PCM8 >> 5;
			pswcode = rswcode = change_sign8;
		} else
			bits = FMT_TWOS_COMP_BE >> 5;
		break;
	case AUDIO_ENCODING_SLINEAR:
		if (p->precision != 8)
			p->precision = 8;
		bits = FMT_PCM8 >> 5;
		pswcode = rswcode = change_sign8;
a551 7
		if (p->precision == 8)
			bits = FMT_PCM8 >> 5;
		else {
			bits = FMT_TWOS_COMP >> 5;
			pswcode = rswcode = change_sign16_le;
		}
		break;
d553 1
a553 6
		if (p->precision == 8)
			bits = FMT_PCM8 >> 5;
		else {
			bits = FMT_TWOS_COMP_BE >> 5;
			pswcode = rswcode = change_sign16_be;
		}
d556 1
a556 2
		if (p->precision != 8)
			p->precision = 8;
a569 2
	p->sw_code = pswcode;
	r->sw_code = rswcode;
@


1.30
log
@Run audio interrupts without grabbing the kernel lock.  While IPL_SERIAL is
higher than IPL_AUDIO on sparc64, and interrupt handlers running at IPL_SERIAL
still grab the kernel lock, this isn't a problem as machines with audioce(4)
are guaranteed not to have zs(4) (the only driver that uses IPL_SERIAL).
@
text
@d1 1
a1 1
/*	$OpenBSD: ce4231.c,v 1.29 2013/05/15 08:29:23 ratchov Exp $	*/
d1389 1
a1389 1
	free(p, pool);
d1411 1
a1411 1
		free(p, pool);
@


1.29
log
@Introduce a global interrupt-aware mutex protecting data
structures (including sound-card registers) from concurent
access by syscall and interrupt code-paths. Since critical
sections remain the same, calls to splraise/spllower can be
safely replaced by calls to mtx_enter/mtx_leave with two
exceptions: (1) mutexes are not reentrant (the inner splraise
is thus removed), and (2) we're not allowed to sleep with a
mutex (either msleep is used or the mutex is released before
sleeping).

ok and help from kettenis, a lot of work from armani
@
text
@d1 1
a1 1
/*	$OpenBSD: ce4231.c,v 1.28 2010/07/26 23:17:19 jakemsr Exp $	*/
d243 2
a244 1
	    IPL_AUDIO, 0, ce4231_cintr, sc, self->dv_xname);
d250 2
a251 1
	    IPL_AUDIO, 0, ce4231_pintr, sc, self->dv_xname);
@


1.28
log
@recording/full-duplex support
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: ce4231.c,v 1.27 2010/07/26 20:06:12 jakemsr Exp $	*/
d647 1
a647 1
	int s, tries;
d662 2
a663 1
	s = splaudio();
d706 1
a706 1
	splx(s);
d1246 1
d1284 1
a1284 1

d1299 1
d1337 1
a1337 1

@


1.27
log
@simplify the mixer(4) code and interface.  document the interface.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: ce4231.c,v 1.26 2010/07/15 03:43:11 jakemsr Exp $	*/
a102 2
#define	CS_AFS_PI	0x10

a432 1
	sc->sc_locked = 0;
a720 1
	sc->sc_locked = 0;
a733 1
	sc->sc_locked = 0;
d1222 11
a1232 6
int
ce4231_cintr(v)
	void *v;
{
	return (0);
}
d1240 1
a1240 1
	u_int8_t reg, status;
d1242 1
d1246 6
a1251 8
	status = CS_READ(sc, AD1848_STATUS);
	if (status & (INTERRUPT_STATUS | SAMPLE_ERROR)) {
		reg = ce4231_read(sc, CS_IRQ_STATUS);
		if (reg & CS_AFS_PI) {
			ce4231_write(sc, SP_LOWER_BASE_COUNT, 0xff);
			ce4231_write(sc, SP_UPPER_BASE_COUNT, 0xff);
		}
		CS_WRITE(sc, AD1848_STATUS, 0);
d1262 2
a1263 2
		p = sc->sc_nowplaying;
		togo = sc->sc_playsegsz - sc->sc_playcnt;
d1266 1
a1266 1
			sc->sc_playcnt = togo = sc->sc_blksz;
d1268 4
a1271 4
			nextaddr = sc->sc_lastaddr;
			if (togo > sc->sc_blksz)
				togo = sc->sc_blksz;
			sc->sc_playcnt += togo;
d1276 1
a1276 1
		sc->sc_lastaddr = nextaddr + togo;
d1286 52
d1422 1
a1425 7
	if (sc->sc_locked != 0) {
		printf("%s: trigger_output: already running\n",
		    sc->sc_dev.dv_xname);
		return (EINVAL);
	}

	sc->sc_locked = 1;
d1443 3
a1445 3
	sc->sc_blksz = blksize;
	sc->sc_nowplaying = p;
	sc->sc_playsegsz = n;
d1447 2
a1448 2
	if (n > sc->sc_blksz)
		n = sc->sc_blksz;
d1450 1
a1450 1
	sc->sc_playcnt = n;
d1473 1
a1473 1
	sc->sc_lastaddr = p->dmamap->dm_segs[0].ds_addr + n;
d1486 56
a1541 1
	return (ENXIO);
@


1.26
log
@add two new members to structs audio_encoding and audio_prinfo.
for both structs, the new members are 'bps' and 'msb', which
describe the number of bytes per sample and data alignment in the
sample, respectively.  drivers must properly set these fields in
the 'query_encoding', 'set_parameters' and 'get_default_params'
hardware interface methods.

discussed with ratchov, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ce4231.c,v 1.25 2010/02/22 00:43:30 jakemsr Exp $	*/
d65 15
a79 36
#define	CSAUDIO_DAC_LVL		0
#define	CSAUDIO_LINE_IN_LVL	1
#define	CSAUDIO_MIC_LVL		2
#define	CSAUDIO_CD_LVL		3
#define	CSAUDIO_MONITOR_LVL	4
#define	CSAUDIO_LINE_IN_MUTE	5
#define	CSAUDIO_DAC_MUTE	6
#define	CSAUDIO_CD_MUTE		7
#define	CSAUDIO_MIC_MUTE	8
#define	CSAUDIO_MONITOR_MUTE	9
#define	CSAUDIO_REC_LVL		10
#define	CSAUDIO_RECORD_SOURCE	11
#define	CSAUDIO_INPUT_CLASS	12
#define	CSAUDIO_OUTPUT_CLASS	13
#define	CSAUDIO_RECORD_CLASS	14
/* The dac can output to these destinations, which *do* have mute
 * controls, but share levels with the main DAC
 */
#define CSAUDIO_DAC_MONO_MUTE	15
#define CSAUDIO_DAC_LINE_MUTE	16
#define CSAUDIO_DAC_HDPH_MUTE	17

/* Physical volume/attenuation registers, array indexes for
 * sc->sc_volume/sc->sc_mute
 *
 * Based upon my Sun blade 1000:
 * AUX2 is usually CD in
 * MONO is usually a mic
 */
#define	CSPORT_AUX2		0
#define	CSPORT_AUX1		1
#define	CSPORT_DAC		2
#define	CSPORT_LINEIN		3
#define	CSPORT_MONO		4
#define	CSPORT_MONITOR		5
#define CSPORT_ADC		6
d82 9
a90 4
#define LINE_IN_PORT	0
#define AUX1_IN_PORT	1
#define MIC_IN_PORT	2
#define DAC_IN_PORT	3
a102 2
#define	CS_PC_LINEMUTE	XCTL1_ENABLE
#define	CS_PC_HDPHMUTE	XCTL1_ENABLE
a103 2
#define MONO_INPUT_MUTE 0x80
#define MIX_MUTE	0x00
d129 3
a131 2
void	ce4231_setup_output(struct ce4231_softc *sc);
void	ce4231_setup_input(struct ce4231_softc *sc);
d222 1
d291 30
a320 7
	/* Default to all dacouts unmuted, reasonable volume */
	sc->sc_monoout_enable = 1;
	sc->sc_lineout_enable = 1;
	sc->sc_hdphout_enable = 1;
	sc->sc_mute[CSPORT_DAC] = 1; /* dac itself not muted */
	sc->sc_volume[CSPORT_DAC].left = 192;
	sc->sc_volume[CSPORT_DAC].right = 192;
a453 7
	/* Turn on cs4231 mode */
	ce4231_write(sc, SP_MISC_INFO,
	    ce4231_read(sc, SP_MISC_INFO) | MODE2);

	ce4231_setup_output(sc);
	ce4231_setup_input(sc);

a459 157
/* Set volume/attenuation values and mute settings for outputs */
void
ce4231_setup_output(sc)
	struct ce4231_softc *sc;
{
	u_int8_t pc, mi, rm = 0, lm = 0;


	/* DAC-output attenuation */
	DPRINTF(("ce4231_setup_output: DAC out = %d, %d\n",
	    sc->sc_volume[CSPORT_DAC].left,
	    sc->sc_volume[CSPORT_DAC].right));
	lm = (255 - sc->sc_volume[CSPORT_DAC].left) >> 2;
	rm = (255 - sc->sc_volume[CSPORT_DAC].right) >> 2;

	/* DAC out mute setting */
	if (!sc->sc_mute[CSPORT_DAC]) {
		DPRINTF(("ce4231_setup_output: DAC out muted\n"));
		lm = lm | OUTPUT_MUTE;
		rm = rm | OUTPUT_MUTE;
	}

	/* Commit DAC-out settings */
	ce4231_write(sc, SP_LEFT_OUTPUT_CONTROL, lm);
	ce4231_write(sc, SP_RIGHT_OUTPUT_CONTROL, rm);

	/* Mono DAC-out mute settings */
	mi = ce4231_read(sc, CS_MONO_IO_CONTROL) & ~MONO_OUTPUT_MUTE;
	if (!sc->sc_monoout_enable) {
		DPRINTF(("ce4231_setup_output: DAC mono output is disabled\n"));
		mi = mi | MONO_OUTPUT_MUTE;
	}

	/* Merge in mono input settings, as in same 8 bits */
	mi = mi | (ce4231_read(sc, CS_MONO_IO_CONTROL) & MONO_INPUT_MUTE);

	/* Commit mono dacout settings */
	ce4231_write(sc, CS_MONO_IO_CONTROL, mi);

	/* Line and headphone dacout mutes */
	pc = (ce4231_read(sc, SP_PIN_CONTROL) &
	    ~CS_PC_HDPHMUTE) & ~CS_PC_LINEMUTE;
	if (!sc->sc_lineout_enable) {
		DPRINTF(("ce4231_setup_output: DAC line output is disabled\n"));
		pc = pc | CS_PC_LINEMUTE;
	}
	if (!sc->sc_hdphout_enable) {
		DPRINTF(("ce4231_setup_output: DAC hdph output is disabled\n"));
		pc = pc | CS_PC_HDPHMUTE;
	}

	/* Commit line/headphone DAC-out settings */
	ce4231_write(sc, SP_PIN_CONTROL, pc);
}

/* Set volume/attenuation values and mute settings for outputs */
void
ce4231_setup_input(sc)
	struct ce4231_softc *sc;
{

	u_int8_t line_l, line_r, mono, aux2_l, aux2_r, monitor,
	    adc_l, adc_r;

	/* Line-in gain */
	DPRINTF(("ce4231_setup_input: line in gain = %d,%d\n",
	    sc->sc_volume[CSPORT_LINEIN].left,
	    sc->sc_volume[CSPORT_LINEIN].right));
	line_l = sc->sc_volume[CSPORT_LINEIN].left >> 3;
	line_r = sc->sc_volume[CSPORT_LINEIN].right >> 3;
	DPRINTF(("ce4231_setup_input: line-in gain (on card) = %d,%d\n",
	    line_l, line_r));

	/* Line-in mute */
	if (!sc->sc_mute[CSPORT_LINEIN]) {
		DPRINTF(("ce4231_setup_input: line-in mute is enabled\n"));
		line_l = line_l | CS_PC_LINEMUTE;
		line_r = line_r| CS_PC_LINEMUTE;
	}

	/* Commit line-in settings to card */
	ce4231_write(sc, CS_LEFT_LINE_CONTROL, line_l);
	ce4231_write(sc, CS_RIGHT_LINE_CONTROL, line_r);

	/* Mono-in attenuation */
	DPRINTF(("ce4231_setup_input: mono-in gain = %d\n",
	    sc->sc_volume[CSPORT_MONO].left));
	mono = (255 - sc->sc_volume[CSPORT_MONO].left) >> 4;
	DPRINTF(("ce4231_setup_input: mono-in attenuation (on card) = %d\n",
	    mono));

	/* Mono-in mute */
	if (!sc->sc_mute[CSPORT_MONO]) {
		DPRINTF(("ce4231_setup_input: mono-in mute is enabled\n"));
		mono = mono | MONO_INPUT_MUTE;
	}

	/* Merge in mono dacout setting, as in the same 8 bits */
	mono = mono | (ce4231_read(sc, CS_MONO_IO_CONTROL) & MONO_OUTPUT_MUTE);

	/* Commit mono-in settings */
	ce4231_write(sc, CS_MONO_IO_CONTROL, mono);

	/* CD/aux2 gain */
	DPRINTF(("ce4231_setup_input: cd/aux2 gain = %d,%d\n",
	    sc->sc_volume[CSPORT_AUX2].left,
	    sc->sc_volume[CSPORT_AUX2].right));
	aux2_l = sc->sc_volume[CSPORT_AUX2].left >> 3;
	aux2_r = sc->sc_volume[CSPORT_AUX2].right >> 3;
	DPRINTF(("ce4231_setup_input: cd/aux2 gain (on card) = %d,%d\n",
	    aux2_l, aux2_r));

	/* CD/aux2-input mute */
	if (!sc->sc_mute[CSPORT_AUX2]) {
		DPRINTF(("ce4231_setup_input: cd/aux2-in mute is enabled\n"));
		aux2_l = aux2_l | AUX_INPUT_MUTE;
		aux2_r = aux2_r | AUX_INPUT_MUTE;
	}

	/* Commit cd/aux2 settings */
	ce4231_write(sc, SP_LEFT_AUX2_CONTROL, aux2_l);
	ce4231_write(sc, SP_RIGHT_AUX2_CONTROL, aux2_r);

	/* Monitor attenuation */
	DPRINTF(("ce4231_setup_input: monitor gain = %d\n",
	    sc->sc_volume[CSPORT_MONITOR].left));
	monitor = (0xff - sc->sc_volume[CSPORT_MONITOR].left) & MIX_ATTEN_MASK;
	DPRINTF(("ce4231_setup_input: monitor attenuation (on card) = %d\n",
	    monitor >> 2));

	/* Monitor mute */
	if (!sc->sc_mute[CSPORT_MONITOR]) {
		monitor |= DIGITAL_MIX1_ENABLE;
	}

	/* Commit monitor settings */
	ce4231_write(sc, SP_DIGITAL_MIX, monitor);

	/* ADC-in gain */
	DPRINTF(("ce4231_setup_input: adc gain = %d,%d\n",
	    sc->sc_volume[CSPORT_ADC].left,
	    sc->sc_volume[CSPORT_ADC].right));
	adc_l = sc->sc_volume[CSPORT_ADC].left >> 4;
	adc_r = sc->sc_volume[CSPORT_ADC].right >> 4;
	DPRINTF(("ce4231_setup_input: adc gain (on card)  = %d,%d\n",
	    adc_l, adc_r));

	/* Record source is one of *_INPUT_PORT */
	adc_l = adc_l | (sc->sc_rec_src << 6);
	adc_r = adc_r | (sc->sc_rec_src << 6);

	ce4231_write(sc, SP_LEFT_INPUT_CONTROL, adc_l);
	ce4231_write(sc, SP_RIGHT_INPUT_CONTROL, adc_r);

	return;
}

d751 18
d770 19
a788 3
ce4231_set_port(addr, cp)
	void *addr;
	mixer_ctrl_t *cp;
d791 1
a791 1
	int error = EINVAL;
d793 1
a793 1
	DPRINTF(("ce4231_set_port: port=%d type=%d\n", cp->dev, cp->type));
d795 1
a795 4
	/* XXX a lot of duplicated code here, sometime in the future
	 * make a function like:
	 * set_soft_volume(struct ce4231_softc *sc, mixer_ctrl_t *cp);
	 */
a796 1
	switch (cp->dev) {
d799 11
a809 15
			break;
		if (cp->un.value.num_channels == 1) {
			sc->sc_volume[CSPORT_DAC].left =
				cp->un.value.level[AUDIO_MIXER_LEVEL_MONO];
			sc->sc_volume[CSPORT_DAC].right =
				cp->un.value.level[AUDIO_MIXER_LEVEL_MONO];
		} else if (cp->un.value.num_channels == 2) {
			sc->sc_volume[CSPORT_DAC].left =
				cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT];
			sc->sc_volume[CSPORT_DAC].right =
				cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT];
		} else
			break;
		ce4231_setup_output(sc);
		error = 0;
d811 11
a821 17
	case CSAUDIO_LINE_IN_LVL:
		if (cp->type != AUDIO_MIXER_VALUE)
			break;
		if (cp->un.value.num_channels == 1) {
			sc->sc_volume[CSPORT_LINEIN].left =
			    cp->un.value.level[AUDIO_MIXER_LEVEL_MONO];
			sc->sc_volume[CSPORT_LINEIN].right =
			    cp->un.value.level[AUDIO_MIXER_LEVEL_MONO];
		} else if (cp->un.value.num_channels == 2) {
			sc->sc_volume[CSPORT_LINEIN].left =
			    cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT];
			sc->sc_volume[CSPORT_LINEIN].right =
			    cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT];
		} else
			break;
		ce4231_setup_input(sc);
		error = 0;
d823 5
a827 17
	case CSAUDIO_MIC_LVL:
		if (cp->type != AUDIO_MIXER_VALUE)
			break;
		if (cp->un.value.num_channels == 1) {
			sc->sc_volume[CSPORT_MONO].left =
			    cp->un.value.level[AUDIO_MIXER_LEVEL_MONO];
			sc->sc_volume[CSPORT_MONO].right =
			    cp->un.value.level[AUDIO_MIXER_LEVEL_MONO];
		} else if (cp->un.value.num_channels == 2) {
			sc->sc_volume[CSPORT_MONO].left =
			    cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT];
			sc->sc_volume[CSPORT_MONO].right =
			    cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT];
		} else
			break;
		ce4231_setup_input(sc);
		error = 0;
d829 1
d832 23
a854 15
			break;
		if (cp->un.value.num_channels == 1) {
			sc->sc_volume[CSPORT_AUX2].left =
			    cp->un.value.level[AUDIO_MIXER_LEVEL_MONO];
			sc->sc_volume[CSPORT_AUX2].right =
			    cp->un.value.level[AUDIO_MIXER_LEVEL_MONO];
		} else if (cp->un.value.num_channels == 2) {
			sc->sc_volume[CSPORT_AUX2].left =
			    cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT];
			sc->sc_volume[CSPORT_AUX2].right =
			    cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT];
		} else
			break;
		ce4231_setup_input(sc);
		error = 0;
a855 8
	case CSAUDIO_MONITOR_LVL:
		if (cp->type != AUDIO_MIXER_VALUE ||
		    cp->un.value.num_channels != 1)
		    	break;
		sc->sc_volume[CSPORT_MONITOR].left =
		    cp->un.value.level[AUDIO_MIXER_LEVEL_MONO];
		ce4231_setup_input(sc);
		error = 0;
d857 13
d872 8
a879 5
		if (cp->type != AUDIO_MIXER_ENUM)
			break;
		sc->sc_mute[CSPORT_LINEIN] = cp->un.ord ? 1 : 0;
		ce4231_setup_input(sc);
		error = 0;
d881 11
a891 20
	case CSAUDIO_DAC_MUTE:
		if (cp->type != AUDIO_MIXER_ENUM)
			break;
		sc->sc_mute[CSPORT_DAC] = cp->un.ord ? 1 : 0;
		ce4231_setup_output(sc);
		error = 0;
		break;
	case CSAUDIO_CD_MUTE:
		if (cp->type != AUDIO_MIXER_ENUM)
			break;
		sc->sc_mute[CSPORT_AUX2] = cp->un.ord ? 1 : 0;
		ce4231_setup_input(sc);
		error = 0;
		break;
	case CSAUDIO_MIC_MUTE:
		if (cp->type != AUDIO_MIXER_ENUM)
			break;
		sc->sc_mute[CSPORT_MONO] = cp->un.ord ? 1 : 0;
		ce4231_setup_input(sc);
		error = 0;
d895 5
a899 4
			break;
		sc->sc_mute[CSPORT_MONITOR] = cp->un.ord ? 1 : 0;
		ce4231_setup_input(sc);
		error = 0;
d901 10
a910 6
	case CSAUDIO_DAC_MONO_MUTE:
		if (cp->type != AUDIO_MIXER_ENUM)
			break;
		sc->sc_monoout_enable = cp->un.ord ? 1 : 0;
		ce4231_setup_output(sc);
		error = 0;
d912 1
a912 1
	case CSAUDIO_DAC_LINE_MUTE:
d914 7
a920 4
			break;
		sc->sc_lineout_enable = cp->un.ord ? 1 : 0;
		ce4231_setup_output(sc);
		error = 0;
d922 2
a923 1
	case CSAUDIO_DAC_HDPH_MUTE:
d925 11
a935 4
			break;
		sc->sc_hdphout_enable = cp->un.ord ? 1 : 0;
		ce4231_setup_output(sc);
		error = 0;
a936 17
	case CSAUDIO_REC_LVL:
		if (cp->type != AUDIO_MIXER_VALUE)
			break;
		if (cp->un.value.num_channels == 1) {
			sc->sc_volume[CSPORT_ADC].left =
			    cp->un.value.level[AUDIO_MIXER_LEVEL_MONO];
			sc->sc_volume[CSPORT_ADC].right =
			    cp->un.value.level[AUDIO_MIXER_LEVEL_MONO];
		} else if (cp->un.value.num_channels == 2) {
			sc->sc_volume[CSPORT_ADC].left =
			    cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT];
			sc->sc_volume[CSPORT_ADC].right =
			    cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT];
		} else
			break;
		ce4231_setup_input(sc);
		error = 0;
d938 2
a939 9
		break;

	case CSAUDIO_RECORD_SOURCE:
		if (cp->type != AUDIO_MIXER_ENUM)
			break;
		sc->sc_rec_src = cp->un.ord;
		ce4231_setup_input(sc);
		error = 0;
		break;
d942 1
a942 1
	return (error);
d946 1
a946 3
ce4231_get_port(addr, cp)
	void *addr;
	mixer_ctrl_t *cp;
d949 2
a950 1
	int error = EINVAL;
d953 1
d956 7
a962 15
			break;
		if (cp->un.value.num_channels == 1)
			cp->un.value.level[AUDIO_MIXER_LEVEL_MONO] =
			    255 - ((ce4231_read(sc, SP_LEFT_OUTPUT_CONTROL) &
			    OUTPUT_ATTEN_BITS) << 2);
		else if (cp->un.value.num_channels == 2) {
			cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT] =
			    255 - ((ce4231_read(sc, SP_LEFT_OUTPUT_CONTROL) &
			    OUTPUT_ATTEN_BITS) << 2);
			cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT] =
			    255 - ((ce4231_read(sc, SP_RIGHT_OUTPUT_CONTROL) &
			    OUTPUT_ATTEN_BITS) << 2);
		} else
			break;
		error = 0;
d964 5
a968 17
	case CSAUDIO_LINE_IN_LVL:
		if (cp->type != AUDIO_MIXER_VALUE)
			break;
		if (cp->un.value.num_channels == 1)
			cp->un.value.level[AUDIO_MIXER_LEVEL_MONO] =
			    (ce4231_read(sc, CS_LEFT_LINE_CONTROL) &
			    LINE_INPUT_ATTEN_BITS) << 3;
		else if (cp->un.value.num_channels == 2) {
			cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT] =
			    (ce4231_read(sc, CS_LEFT_LINE_CONTROL) &
			    LINE_INPUT_ATTEN_BITS) << 3;
			cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT] =
			    (ce4231_read(sc, CS_RIGHT_LINE_CONTROL) &
			    LINE_INPUT_ATTEN_BITS) << 3;
		} else
			break;
		error = 0;
d970 5
a974 10
	case CSAUDIO_MIC_LVL:
		if (cp->type != AUDIO_MIXER_VALUE)
			break;
		if (cp->un.value.num_channels == 1) {
			cp->un.value.level[AUDIO_MIXER_LEVEL_MONO] =
			    (255 - (ce4231_read(sc, CS_MONO_IO_CONTROL) &
			    MONO_INPUT_ATTEN_BITS)) << 4;
		} else
			break;
		error = 0;
d976 1
d979 13
a991 15
			break;
		if (cp->un.value.num_channels == 1)
			cp->un.value.level[AUDIO_MIXER_LEVEL_MONO] =
			    (ce4231_read(sc, SP_LEFT_AUX2_CONTROL) &
			    LINE_INPUT_ATTEN_BITS) << 3;
		else if (cp->un.value.num_channels == 2) {
			cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT] =
			    (ce4231_read(sc, SP_LEFT_AUX2_CONTROL) &
			    LINE_INPUT_ATTEN_BITS) << 3;
			cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT] =
			    (ce4231_read(sc, SP_RIGHT_AUX2_CONTROL) &
			    LINE_INPUT_ATTEN_BITS) << 3;
		} else
			break;
		error = 0;
d993 2
a994 1
	case CSAUDIO_MONITOR_LVL:
d996 7
a1002 7
			break;
		if (cp->un.value.num_channels != 1)
			break;
		cp->un.value.level[AUDIO_MIXER_LEVEL_MONO] =
		    (0xff & MIX_ATTEN_MASK) -
		    (ce4231_read(sc, SP_DIGITAL_MIX) & MIX_ATTEN_MASK);
		error = 0;
d1006 3
a1008 4
			break;
		cp->un.ord = ce4231_read(sc, CS_LEFT_LINE_CONTROL) &
		    CS_PC_LINEMUTE ? 0 : 1;
		error = 0;
d1010 9
a1018 20
	case CSAUDIO_DAC_MUTE:
		if (cp->type != AUDIO_MIXER_ENUM)
			break;
		cp->un.ord = ce4231_read(sc, SP_LEFT_OUTPUT_CONTROL) &
		    OUTPUT_MUTE ? 0 : 1;
		error = 0;
		break;
	case CSAUDIO_CD_MUTE:
		if (cp->type != AUDIO_MIXER_ENUM)
			break;
		cp->un.ord = ce4231_read(sc, SP_LEFT_AUX2_CONTROL) &
		    AUX_INPUT_MUTE ? 0 : 1;
		error = 0;
		break;
	case CSAUDIO_MIC_MUTE:
		if (cp->type != AUDIO_MIXER_ENUM)
			break;
		cp->un.ord = ce4231_read(sc, CS_MONO_IO_CONTROL) &
		    MONO_INPUT_MUTE ? 0 : 1;
		error = 0;
d1022 3
a1024 25
			break;
		cp->un.ord = ce4231_read(sc, SP_DIGITAL_MIX) &
		    DIGITAL_MIX1_ENABLE ? 0 : 1;
		error = 0;
		break;
	case CSAUDIO_DAC_MONO_MUTE:
		if (cp->type != AUDIO_MIXER_ENUM)
			break;
		cp->un.ord = ce4231_read(sc, CS_MONO_IO_CONTROL) &
		    MONO_OUTPUT_MUTE ? 0 : 1;
		error = 0;
		break;
	case CSAUDIO_DAC_LINE_MUTE:
		if (cp->type != AUDIO_MIXER_ENUM)
			break;
		cp->un.ord = ce4231_read(sc, SP_PIN_CONTROL) & CS_PC_LINEMUTE
		    ? 0 : 1;
		error = 0;
		break;
	case CSAUDIO_DAC_HDPH_MUTE:
		if (cp->type != AUDIO_MIXER_ENUM)
			break;
		cp->un.ord = ce4231_read(sc, SP_PIN_CONTROL) & CS_PC_HDPHMUTE
		    ? 0 : 1;
		error = 0;
d1026 1
d1029 7
a1035 12
			break;
		if (cp->un.value.num_channels == 1) {
			cp->un.value.level[AUDIO_MIXER_LEVEL_MONO] =
			    ce4231_read(sc, SP_LEFT_INPUT_CONTROL) << 4;
		} else if (cp->un.value.num_channels == 2) {
			cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT] =
			    ce4231_read(sc, SP_LEFT_INPUT_CONTROL) << 4;
			cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT] =
			    ce4231_read(sc, SP_RIGHT_INPUT_CONTROL) << 4;
		} else
			break;
		error = 0;
d1039 4
a1042 1
			break;
d1044 6
a1049 3
		/* AUX in disabled for now until we know what it does */
		if (cp->un.ord == AUX1_IN_PORT)
			break;
d1051 2
a1052 4
		cp->un.ord = ce4231_read(sc, SP_LEFT_INPUT_CONTROL &
		    CS_REC_SRC_BITS) >> 6;
		error = 0;
		break;
d1054 1
a1054 1
	return (error);
d1058 1
a1058 3
ce4231_query_devinfo(addr, dip)
	void *addr;
	mixer_devinfo_t *dip;
d1060 1
d1064 2
a1065 2
	case CSAUDIO_MIC_LVL:		/* Mono/microphone mixer */
		dip->type = AUDIO_MIXER_VALUE;
d1067 14
a1080 7
		dip->prev = AUDIO_MIXER_LAST;
		dip->next = CSAUDIO_MIC_MUTE;
		strlcpy(dip->label.name, AudioNmicrophone,
		    sizeof(dip->label.name));
		dip->un.v.num_channels = 1;
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof(dip->un.v.units.name));
d1082 2
a1083 1
	case CSAUDIO_DAC_LVL:		/* DAC out */
d1088 1
a1088 1
		strlcpy(dip->label.name, AudioNdac, sizeof(dip->label.name));
d1090 23
a1112 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof(dip->un.v.units.name));
d1114 2
a1115 1
	case CSAUDIO_LINE_IN_LVL:	/* Line */
d1119 2
a1120 2
		dip->next = CSAUDIO_LINE_IN_MUTE;
		strlcpy(dip->label.name, AudioNline, sizeof(dip->label.name));
d1122 2
a1123 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof(dip->un.v.units.name));
d1125 9
a1133 1
	case CSAUDIO_CD_LVL:		/* CD */
d1137 2
a1138 2
		dip->next = CSAUDIO_CD_MUTE;
		strlcpy(dip->label.name, AudioNcd, sizeof(dip->label.name));
d1140 2
a1141 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof(dip->un.v.units.name));
d1148 4
a1151 20
		goto mute;
	case CSAUDIO_DAC_MUTE:
		dip->type = AUDIO_MIXER_ENUM;
		dip->mixer_class = CSAUDIO_OUTPUT_CLASS;
		dip->prev = CSAUDIO_DAC_LVL;
		dip->next = CSAUDIO_DAC_MONO_MUTE;
		goto mute;
	case CSAUDIO_CD_MUTE:
		dip->type = AUDIO_MIXER_ENUM;
		dip->mixer_class = CSAUDIO_INPUT_CLASS;
		dip->prev = CSAUDIO_CD_LVL;
		dip->next = AUDIO_MIXER_LAST;
		goto mute;
	case CSAUDIO_MIC_MUTE:
		dip->type = AUDIO_MIXER_ENUM;
		dip->mixer_class = CSAUDIO_INPUT_CLASS;
		dip->prev = CSAUDIO_MIC_LVL;
		dip->next = AUDIO_MIXER_LAST;
		goto mute;
	case CSAUDIO_MONITOR_LVL:	/* Monitor level */
d1156 1
a1156 2
		strlcpy(dip->label.name, AudioNmonitor,
		    sizeof(dip->label.name));
d1158 2
a1159 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof(dip->un.v.units.name));
d1166 3
a1168 36
		goto mute;
	case CSAUDIO_DAC_MONO_MUTE: /* The DAC has a mono out, usually spkr */
		dip->type = AUDIO_MIXER_ENUM;
		dip->mixer_class = CSAUDIO_OUTPUT_CLASS;
		dip->prev = CSAUDIO_DAC_MUTE;
		dip->next = CSAUDIO_DAC_LINE_MUTE;
		/* Custom name, as we already have a mute in this class */
		strlcpy(dip->label.name, "monomute", sizeof(dip->label.name));
		goto mute1;
	case CSAUDIO_DAC_LINE_MUTE:
		dip->type = AUDIO_MIXER_ENUM;
		dip->mixer_class = CSAUDIO_OUTPUT_CLASS;
		dip->prev = CSAUDIO_DAC_MONO_MUTE;
		dip->next = CSAUDIO_DAC_HDPH_MUTE;
		/* Custom name */
		strlcpy(dip->label.name, "linemute", sizeof(dip->label.name));
		goto mute1;
	case CSAUDIO_DAC_HDPH_MUTE:
		dip->type = AUDIO_MIXER_ENUM;
		dip->mixer_class = CSAUDIO_OUTPUT_CLASS;
		dip->prev = CSAUDIO_DAC_LINE_MUTE;
		dip->next = CSAUDIO_MONITOR_LVL;
		/* Custom name */
		strlcpy(dip->label.name, "hdphmute", sizeof(dip->label.name));
		goto mute1;
	mute:
		strlcpy(dip->label.name, AudioNmute, sizeof(dip->label.name));
	mute1:
		dip->un.e.num_mem = 2;
		strlcpy(dip->un.e.member[0].label.name, AudioNon,
		    sizeof(dip->un.e.member[0].label.name));
		dip->un.e.member[0].ord = 0;
		strlcpy(dip->un.e.member[1].label.name, AudioNoff,
		    sizeof(dip->un.e.member[1].label.name));
		dip->un.e.member[1].ord = 1;
		break;
d1172 2
a1173 4
		dip->prev = AUDIO_MIXER_LAST;
		dip->next = CSAUDIO_RECORD_SOURCE;
		strlcpy(dip->label.name, AudioNrecord,
		    sizeof(dip->label.name));
d1175 2
a1176 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof(dip->un.v.units.name));
d1181 2
a1182 4
		dip->prev = CSAUDIO_REC_LVL;
		dip->next = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioNsource,
		    sizeof(dip->label.name));
d1184 9
d1194 7
a1200 3
		strlcpy(dip->un.e.member[0].label.name, AudioNline,
		    sizeof(dip->un.e.member[0].label.name));
		dip->un.e.member[0].ord = LINE_IN_PORT;
d1202 7
a1208 3
		strlcpy(dip->un.e.member[1].label.name, "aux",
		    sizeof(dip->un.e.member[1].label.name));
		dip->un.e.member[1].ord = AUX1_IN_PORT;
a1209 33
		strlcpy(dip->un.e.member[2].label.name, AudioNmicrophone,
		    sizeof(dip->un.e.member[2].label.name));
		dip->un.e.member[2].ord = MIC_IN_PORT;

		strlcpy(dip->un.e.member[3].label.name, AudioNdac,
		    sizeof(dip->un.e.member[3].label.name));
		dip->un.e.member[3].ord = DAC_IN_PORT;

		break;
	case CSAUDIO_INPUT_CLASS:	/* Input class descriptor */
		dip->type = AUDIO_MIXER_CLASS;
		dip->mixer_class = CSAUDIO_INPUT_CLASS;
		dip->prev = AUDIO_MIXER_LAST;
		dip->next = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioCinputs,
		    sizeof(dip->label.name));
		break;
	case CSAUDIO_OUTPUT_CLASS:	/* Output class descriptor */
		dip->type = AUDIO_MIXER_CLASS;
		dip->mixer_class = CSAUDIO_OUTPUT_CLASS;
		dip->prev = AUDIO_MIXER_LAST;
		dip->next = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioCoutputs,
		    sizeof(dip->label.name));
		break;
	case CSAUDIO_RECORD_CLASS:	/* Record class descriptor */
		dip->type = AUDIO_MIXER_CLASS;
		dip->mixer_class = CSAUDIO_RECORD_CLASS;
		dip->prev = AUDIO_MIXER_LAST;
		dip->next = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioCrecord,
		    sizeof(dip->label.name));
		break;
@


1.25
log
@- fix a few debug messages: disabled vs enabled mixup, missing \n
- remove some '//' commented code
ok ratchov, kettenis, edd
@
text
@d1 1
a1 1
/*	$OpenBSD: ce4231.c,v 1.24 2009/12/15 10:43:53 edd Exp $	*/
d697 2
d785 3
@


1.24
log
@fix some buffer sizes.
put () around all sizeof uses.

OK ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ce4231.c,v 1.23 2009/12/01 23:17:11 edd Exp $	*/
d491 1
a491 1
		DPRINTF(("ce4231_setup_output: DAC mono output is enabled"));
d505 1
a505 1
		DPRINTF(("ce4231_setup_output: DAC line output is enabled"));
d509 1
a509 1
		DPRINTF(("ce4231_setup_output: DAC hdph output is enabled"));
a1191 1
		//cp->un.ord = sc->sc_mute[CSPORT_AUX2] ? 1 : 0;
a1198 1
		//cp->un.ord = sc->sc_mute[CSPORT_MONO] ? 1 : 0;
a1205 1
		//cp->un.ord = sc->sc_mute[CSPORT_MONITOR] ? 1 : 0;
a1212 1
		//cp->un.ord = sc->sc_monoout_enable ? 1 : 0;
a1219 1
		//cp->un.ord = sc->sc_lineout_enable ? 1 : 0;
a1226 1
		//cp->un.ord = sc->sc_hdphout_enable ? 1 : 0;
@


1.23
log
@Fix the mixer interface for the CE4231 sound card found in Sun machines. Still a
lot of room for improvement in the driver, but atleast it works now.

OK kettenis@@, ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ce4231.c,v 1.22 2008/04/21 00:32:42 jakemsr Exp $	*/
d641 1
a641 1
		strlcpy(fp->name, AudioEmulaw, sizeof fp->name);
d647 1
a647 1
		strlcpy(fp->name, AudioEalaw, sizeof fp->name);
d653 1
a653 1
		strlcpy(fp->name, AudioEslinear_le, sizeof fp->name);
d659 1
a659 1
		strlcpy(fp->name, AudioEulinear, sizeof fp->name);
d665 1
a665 1
		strlcpy(fp->name, AudioEslinear_be, sizeof fp->name);
d671 1
a671 1
		strlcpy(fp->name, AudioEslinear, sizeof fp->name);
d677 1
a677 1
		strlcpy(fp->name, AudioEulinear_le, sizeof fp->name);
d683 1
a683 1
		strlcpy(fp->name, AudioEulinear_be, sizeof fp->name);
d689 1
a689 1
		strlcpy(fp->name, AudioEadpcm, sizeof fp->name);
d1282 1
a1282 1
		    sizeof dip->label.name);
d1285 1
a1285 1
		    sizeof dip->un.v.units.name);
d1292 1
a1292 1
		strlcpy(dip->label.name, AudioNdac, sizeof dip->label.name);
d1295 1
a1295 1
		    sizeof dip->un.v.units.name);
d1302 1
a1302 1
		strlcpy(dip->label.name, AudioNline, sizeof dip->label.name);
d1305 1
a1305 1
		    sizeof dip->un.v.units.name);
d1312 1
a1312 1
		strlcpy(dip->label.name, AudioNcd, sizeof dip->label.name);
d1315 1
a1315 1
		    sizeof dip->un.v.units.name);
d1346 2
a1347 1
		strlcpy(dip->label.name, AudioNmonitor, sizeof dip->label.name);
d1350 1
a1350 1
		    sizeof dip->un.v.units.name);
d1364 1
a1364 1
		strlcpy(dip->label.name, "monomute", sizeof "monomute");
d1372 1
a1372 1
		strlcpy(dip->label.name, "linemute", sizeof "linemute");
d1380 1
a1380 1
		strlcpy(dip->label.name, "hdphmute", sizeof "hdphmute");
d1383 1
a1383 1
		strlcpy(dip->label.name, AudioNmute, sizeof dip->label.name);
d1387 1
a1387 1
		    sizeof dip->un.e.member[0].label.name);
d1390 1
a1390 1
		    sizeof dip->un.e.member[1].label.name);
d1398 2
a1399 1
		strlcpy(dip->label.name, AudioNrecord, sizeof dip->label.name);
d1402 1
a1402 1
		    sizeof dip->un.v.units.name);
d1409 2
a1410 1
		strlcpy(dip->label.name, AudioNsource, sizeof dip->label.name);
d1414 1
a1414 1
		    sizeof dip->un.e.member[0].label.name);
d1418 1
a1418 1
		    sizeof dip->un.e.member[1].label.name);
d1422 1
a1422 1
		    sizeof dip->un.e.member[2].label.name);
d1426 1
a1426 1
		    sizeof dip->un.e.member[3].label.name);
d1435 2
a1436 1
		strlcpy(dip->label.name, AudioCinputs, sizeof dip->label.name);
d1443 2
a1444 1
		strlcpy(dip->label.name, AudioCoutputs, sizeof dip->label.name);
d1451 2
a1452 1
		strlcpy(dip->label.name, AudioCrecord, sizeof dip->label.name);
@


1.22
log
@
allow low level audio drivers to specify a default sample format,
instead of 8-bit mono mulaw @@ 8kHz.

this is just the infrastructure; no drivers are specifying a default
yet.

ok ratchov@@, deanna@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ce4231.c,v 1.21 2005/09/08 15:25:54 martin Exp $	*/
d60 1
d64 1
d70 16
a85 14
#define	CSAUDIO_OUTPUT_LVL	5
#define	CSAUDIO_LINE_IN_MUTE	6
#define	CSAUDIO_DAC_MUTE	7
#define	CSAUDIO_CD_MUTE		8
#define	CSAUDIO_MIC_MUTE	9
#define	CSAUDIO_MONITOR_MUTE	10
#define	CSAUDIO_OUTPUT_MUTE	11
#define	CSAUDIO_REC_LVL		12
#define	CSAUDIO_RECORD_SOURCE	13
#define	CSAUDIO_OUTPUT		14
#define	CSAUDIO_INPUT_CLASS	15
#define	CSAUDIO_OUTPUT_CLASS	16
#define	CSAUDIO_RECORD_CLASS	17
#define	CSAUDIO_MONITOR_CLASS	18
d87 7
d100 6
a105 7
#define	CSPORT_SPEAKER		6
#define	CSPORT_LINEOUT		7
#define	CSPORT_HEADPHONE	8

#define MIC_IN_PORT	0
#define LINE_IN_PORT	1
#define AUX1_IN_PORT	2
d108 3
d119 1
a119 1
#define	CS_PC_LINEMUTE	XCTL0_ENABLE
d122 2
d150 1
d309 7
a315 6
	/* Default to speaker, unmuted, reasonable volume */
	sc->sc_out_port = CSPORT_SPEAKER;
	sc->sc_mute[CSPORT_SPEAKER] = 1;
	sc->sc_mute[CSPORT_MONITOR] = 1;
	sc->sc_volume[CSPORT_SPEAKER].left = 192;
	sc->sc_volume[CSPORT_SPEAKER].right = 192;
d424 2
d428 1
d454 1
d462 1
d467 55
a521 1
	u_int8_t pc, mi, rm, lm;
d523 2
a524 1
	pc = ce4231_read(sc, SP_PIN_CONTROL) | CS_PC_HDPHMUTE | CS_PC_LINEMUTE;
d526 15
a540 1
	mi = ce4231_read(sc, CS_MONO_IO_CONTROL) | MONO_OUTPUT_MUTE;
d542 19
a560 4
	lm = ce4231_read(sc, SP_LEFT_OUTPUT_CONTROL);
	lm &= ~OUTPUT_ATTEN_BITS;
	lm |= ((~(sc->sc_volume[CSPORT_SPEAKER].left >> 2)) &
	    OUTPUT_ATTEN_BITS) | OUTPUT_MUTE;
d562 2
a563 4
	rm = ce4231_read(sc, SP_RIGHT_OUTPUT_CONTROL);
	rm &= ~OUTPUT_ATTEN_BITS;
	rm |= ((~(sc->sc_volume[CSPORT_SPEAKER].right >> 2)) &
	    OUTPUT_ATTEN_BITS) | OUTPUT_MUTE;
d565 14
a578 3
	if (sc->sc_mute[CSPORT_MONITOR]) {
		lm &= ~OUTPUT_MUTE;
		rm &= ~OUTPUT_MUTE;
d581 14
a594 13
	switch (sc->sc_out_port) {
	case CSPORT_HEADPHONE:
		if (sc->sc_mute[CSPORT_SPEAKER])
			pc &= ~CS_PC_HDPHMUTE;
		break;
	case CSPORT_SPEAKER:
		if (sc->sc_mute[CSPORT_SPEAKER])
			mi &= ~MONO_OUTPUT_MUTE;
		break;
	case CSPORT_LINEOUT:
		if (sc->sc_mute[CSPORT_SPEAKER])
			pc &= ~CS_PC_LINEMUTE;
		break;
d597 20
a616 4
	ce4231_write(sc, SP_LEFT_OUTPUT_CONTROL, lm);
	ce4231_write(sc, SP_RIGHT_OUTPUT_CONTROL, rm);
	ce4231_write(sc, SP_PIN_CONTROL, pc);
	ce4231_write(sc, CS_MONO_IO_CONTROL, mi);
d711 2
d716 1
a716 1
			return (EINVAL);
d721 1
a721 1
			return (EINVAL);
d728 1
a728 1
		} else if (p->precision == 16)
a729 2
		else
			return (EINVAL);
d733 1
a733 1
			return (EINVAL);
d740 1
a740 1
		} else if (p->precision == 16)
a741 2
		else
			return (EINVAL);
d745 1
a745 1
			return (EINVAL);
d752 1
a752 1
		else if (p->precision == 16) {
d755 1
a755 2
		} else
			return (EINVAL);
d760 1
a760 1
		else if (p->precision == 16) {
d763 1
a763 2
		} else
			return (EINVAL);
d767 1
a767 1
			return (EINVAL);
d774 2
a775 2
	if (p->channels != 1 && p->channels != 2)
		return (EINVAL);
d915 5
d924 10
a933 11
		if (cp->un.value.num_channels == 1)
			ce4231_write(sc, SP_LEFT_AUX1_CONTROL,
			    cp->un.value.level[AUDIO_MIXER_LEVEL_MONO] &
			    LINE_INPUT_ATTEN_BITS);
		else if (cp->un.value.num_channels == 2) {
			ce4231_write(sc, SP_LEFT_AUX1_CONTROL,
			    cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT] &
			    LINE_INPUT_ATTEN_BITS);
			ce4231_write(sc, SP_RIGHT_AUX1_CONTROL,
			    cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT] &
			    LINE_INPUT_ATTEN_BITS);
d936 1
d942 10
a951 11
		if (cp->un.value.num_channels == 1)
			ce4231_write(sc, CS_LEFT_LINE_CONTROL,
			    cp->un.value.level[AUDIO_MIXER_LEVEL_MONO] &
			    AUX_INPUT_ATTEN_BITS);
		else if (cp->un.value.num_channels == 2) {
			ce4231_write(sc, CS_LEFT_LINE_CONTROL,
			    cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT] &
			    AUX_INPUT_ATTEN_BITS);
			ce4231_write(sc, CS_RIGHT_LINE_CONTROL,
			    cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT] &
			    AUX_INPUT_ATTEN_BITS);
d954 1
d961 9
a969 5
#if 0
			ce4231_write(sc, CS_MONO_IO_CONTROL,
			    cp->un.value.level[AUDIO_MIXER_LEVEL_MONO] &
			    MONO_INPUT_ATTEN_BITS);
#endif
d972 1
d979 4
a982 3
			ce4231_write(sc, SP_LEFT_AUX2_CONTROL,
			    cp->un.value.level[AUDIO_MIXER_LEVEL_MONO] &
			    LINE_INPUT_ATTEN_BITS);
d984 4
a987 6
			ce4231_write(sc, SP_LEFT_AUX2_CONTROL,
			    cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT] &
			    LINE_INPUT_ATTEN_BITS);
			ce4231_write(sc, SP_RIGHT_AUX2_CONTROL,
			    cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT] &
			    LINE_INPUT_ATTEN_BITS);
d990 1
d994 6
a999 7
		if (cp->type != AUDIO_MIXER_VALUE)
			break;
		if (cp->un.value.num_channels == 1)
			ce4231_write(sc, SP_DIGITAL_MIX,
			    cp->un.value.level[AUDIO_MIXER_LEVEL_MONO] << 2);
		else
			break;
a1000 18
		break;
	case CSAUDIO_OUTPUT_LVL:
		if (cp->type != AUDIO_MIXER_VALUE)
			break;
		if (cp->un.value.num_channels == 1) {
			sc->sc_volume[CSPORT_SPEAKER].left =
			    cp->un.value.level[AUDIO_MIXER_LEVEL_MONO];
			sc->sc_volume[CSPORT_SPEAKER].right =
			    cp->un.value.level[AUDIO_MIXER_LEVEL_MONO];
		}
		else if (cp->un.value.num_channels == 2) {
			sc->sc_volume[CSPORT_SPEAKER].left =
			    cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT];
			sc->sc_volume[CSPORT_SPEAKER].right =
			    cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT];
		}
		else
			break;
a1001 13
		ce4231_setup_output(sc);
		error = 0;
		break;
	case CSAUDIO_OUTPUT:
		if (cp->type != AUDIO_MIXER_ENUM)
			break;
		if (cp->un.ord != CSPORT_LINEOUT &&
		    cp->un.ord != CSPORT_SPEAKER &&
		    cp->un.ord != CSPORT_HEADPHONE)
			return (EINVAL);
		sc->sc_out_port = cp->un.ord;
		ce4231_setup_output(sc);
		error = 0;
d1007 1
d1013 2
a1014 1
		sc->sc_mute[CSPORT_AUX1] = cp->un.ord ? 1 : 0;
d1021 1
d1028 1
d1035 1
d1038 1
a1038 1
	case CSAUDIO_OUTPUT_MUTE:
d1041 15
a1055 1
		sc->sc_mute[CSPORT_SPEAKER] = cp->un.ord ? 1 : 0;
d1062 15
d1078 1
d1082 3
a1098 2
	DPRINTF(("ce4231_get_port: port=%d type=%d\n", cp->dev, cp->type));

d1104 3
a1106 3
			cp->un.value.level[AUDIO_MIXER_LEVEL_MONO]=
			    ce4231_read(sc, SP_LEFT_AUX1_CONTROL) &
			    LINE_INPUT_ATTEN_BITS;
d1109 2
a1110 2
			    ce4231_read(sc, SP_LEFT_AUX1_CONTROL) &
			    LINE_INPUT_ATTEN_BITS;
d1112 2
a1113 2
			    ce4231_read(sc, SP_RIGHT_AUX1_CONTROL) &
			    LINE_INPUT_ATTEN_BITS;
d1123 2
a1124 1
			    ce4231_read(sc, CS_LEFT_LINE_CONTROL) & AUX_INPUT_ATTEN_BITS;
d1127 2
a1128 1
			    ce4231_read(sc, CS_LEFT_LINE_CONTROL) & AUX_INPUT_ATTEN_BITS;
d1130 2
a1131 1
			    ce4231_read(sc, CS_RIGHT_LINE_CONTROL) & AUX_INPUT_ATTEN_BITS;
a1139 1
#if 0
d1141 2
a1142 3
			    ce4231_read(sc, CS_MONO_IO_CONTROL) &
			    MONO_INPUT_ATTEN_BITS;
#endif
d1152 2
a1153 2
			    ce4231_read(sc, SP_LEFT_AUX2_CONTROL) &
			    LINE_INPUT_ATTEN_BITS;
d1156 2
a1157 2
			    ce4231_read(sc, SP_LEFT_AUX2_CONTROL) &
			    LINE_INPUT_ATTEN_BITS;
d1159 3
a1161 4
			    ce4231_read(sc, SP_RIGHT_AUX2_CONTROL) &
			    LINE_INPUT_ATTEN_BITS;
		}
		else
d1171 2
a1172 17
		    ce4231_read(sc, SP_DIGITAL_MIX) >> 2;
		error = 0;
		break;
	case CSAUDIO_OUTPUT_LVL:
		if (cp->type != AUDIO_MIXER_VALUE)
			break;
		if (cp->un.value.num_channels == 1)
			cp->un.value.level[AUDIO_MIXER_LEVEL_MONO] =
			    sc->sc_volume[CSPORT_SPEAKER].left;
		else if (cp->un.value.num_channels == 2) {
			cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT] =
			    sc->sc_volume[CSPORT_SPEAKER].left;
			cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT] =
			    sc->sc_volume[CSPORT_SPEAKER].right;
		}
		else
			break;
d1178 2
a1179 1
		cp->un.ord = sc->sc_mute[CSPORT_LINEIN] ? 1 : 0;
d1185 2
a1186 1
		cp->un.ord = sc->sc_mute[CSPORT_AUX1] ? 1 : 0;
d1192 3
a1194 1
		cp->un.ord = sc->sc_mute[CSPORT_AUX2] ? 1 : 0;
d1200 3
a1202 1
		cp->un.ord = sc->sc_mute[CSPORT_MONO] ? 1 : 0;
d1208 3
a1210 1
		cp->un.ord = sc->sc_mute[CSPORT_MONITOR] ? 1 : 0;
d1213 1
a1213 1
	case CSAUDIO_OUTPUT_MUTE:
d1216 19
a1234 1
		cp->un.ord = sc->sc_mute[CSPORT_SPEAKER] ? 1 : 0;
d1242 1
a1242 1
			    AUDIO_MIN_GAIN;
d1245 1
a1245 1
			    AUDIO_MIN_GAIN;
d1247 1
a1247 1
			    AUDIO_MIN_GAIN;
d1255 3
a1257 5
		cp->un.ord = MIC_IN_PORT;
		error = 0;
		break;
	case CSAUDIO_OUTPUT:
		if (cp->type != AUDIO_MIXER_ENUM)
d1259 3
a1261 1
		cp->un.ord = sc->sc_out_port;
d1276 1
a1276 1
	case CSAUDIO_MIC_LVL:		/* mono/microphone mixer */
d1281 2
a1282 1
		strlcpy(dip->label.name, AudioNmicrophone, sizeof dip->label.name);
d1287 1
a1287 1
	case CSAUDIO_DAC_LVL:		/* dacout */
d1289 1
a1289 1
		dip->mixer_class = CSAUDIO_INPUT_CLASS;
d1297 1
a1297 1
	case CSAUDIO_LINE_IN_LVL:	/* line */
d1307 1
a1307 1
	case CSAUDIO_CD_LVL:		/* cd */
a1316 20
	case CSAUDIO_MONITOR_LVL:	/* monitor level */
		dip->type = AUDIO_MIXER_VALUE;
		dip->mixer_class = CSAUDIO_MONITOR_CLASS;
		dip->prev = AUDIO_MIXER_LAST;
		dip->next = CSAUDIO_MONITOR_MUTE;
		strlcpy(dip->label.name, AudioNmonitor, sizeof dip->label.name);
		dip->un.v.num_channels = 1;
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
		break;
	case CSAUDIO_OUTPUT_LVL:
		dip->type = AUDIO_MIXER_VALUE;
		dip->mixer_class = CSAUDIO_OUTPUT_CLASS;
		dip->prev = AUDIO_MIXER_LAST;
		dip->next = CSAUDIO_OUTPUT_MUTE;
		strlcpy(dip->label.name, AudioNoutput, sizeof dip->label.name);
		dip->un.v.num_channels = 2;
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
		break;
d1325 1
a1325 1
		dip->mixer_class = CSAUDIO_INPUT_CLASS;
d1327 1
a1327 1
		dip->next = AUDIO_MIXER_LAST;
d1341 10
d1357 17
a1373 1
	case CSAUDIO_OUTPUT_MUTE:
d1376 5
a1380 4
		dip->prev = CSAUDIO_OUTPUT_LVL;
		dip->next = AUDIO_MIXER_LAST;
		goto mute;

d1383 1
d1392 1
a1392 1
	case CSAUDIO_REC_LVL:		/* record level */
d1408 3
a1410 2
		dip->un.e.num_mem = 3;
		strlcpy(dip->un.e.member[0].label.name, AudioNcd,
d1412 3
a1414 2
		dip->un.e.member[0].ord = DAC_IN_PORT;
		strlcpy(dip->un.e.member[1].label.name, AudioNmicrophone,
d1416 3
a1418 2
		dip->un.e.member[1].ord = MIC_IN_PORT;
		strlcpy(dip->un.e.member[2].label.name, AudioNdac,
d1420 3
a1422 2
		dip->un.e.member[2].ord = AUX1_IN_PORT;
		strlcpy(dip->un.e.member[3].label.name, AudioNline,
d1424 2
a1425 17
		dip->un.e.member[3].ord = LINE_IN_PORT;
		break;
	case CSAUDIO_OUTPUT:
		dip->type = AUDIO_MIXER_ENUM;
		dip->mixer_class = CSAUDIO_MONITOR_CLASS;
		dip->prev = dip->next = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioNoutput, sizeof dip->label.name);
		dip->un.e.num_mem = 3;
		strlcpy(dip->un.e.member[0].label.name, AudioNspeaker,
		    sizeof dip->un.e.member[0].label.name);
		dip->un.e.member[0].ord = CSPORT_SPEAKER;
		strlcpy(dip->un.e.member[1].label.name, AudioNline,
		    sizeof dip->un.e.member[1].label.name);
		dip->un.e.member[1].ord = CSPORT_LINEOUT;
		strlcpy(dip->un.e.member[2].label.name, AudioNheadphone,
		    sizeof dip->un.e.member[2].label.name);
		dip->un.e.member[2].ord = CSPORT_HEADPHONE;
d1427 1
a1427 1
	case CSAUDIO_INPUT_CLASS:	/* input class descriptor */
d1434 1
a1434 1
	case CSAUDIO_OUTPUT_CLASS:	/* output class descriptor */
d1441 1
a1441 8
	case CSAUDIO_MONITOR_CLASS:	/* monitor class descriptor */
		dip->type = AUDIO_MIXER_CLASS;
		dip->mixer_class = CSAUDIO_MONITOR_CLASS;
		dip->prev = AUDIO_MIXER_LAST;
		dip->next = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioCmonitor, sizeof dip->label.name);
		break;
	case CSAUDIO_RECORD_CLASS:	/* record class descriptor */
@


1.21
log
@make comments match the fact that we are on sun4u, plus minor cleanup

ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ce4231.c,v 1.20 2005/07/09 22:23:15 miod Exp $	*/
d187 2
a188 1
	ce4231_trigger_input
@


1.20
log
@Do not #include "foo.h" and keep the whole file between #if NFOO >0 ... #endif,
config(8) will not bring us into play unless NFOO > 0 anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: ce4231.c,v 1.19 2005/04/16 21:57:23 mickey Exp $	*/
d30 1
a30 1
 * Driver for CS4231 based audio found in some sun4m systems (cs4231)
@


1.19
log
@do not provide round_buffer if not needed unless explained why in comments
@
text
@d1 1
a1 1
/*	$OpenBSD: ce4231.c,v 1.18 2005/04/15 13:05:14 mickey Exp $	*/
a38 3
#include "audio.h"
#if NAUDIO > 0

a1535 2

#endif /* NAUDIO > 0 */
@


1.18
log
@make sure aligment does not return zero block size
@
text
@d1 1
a1 1
/*	$OpenBSD: ce4231.c,v 1.17 2004/11/09 14:30:34 miod Exp $	*/
a157 1
size_t	ce4231_round_buffersize(void *, int, size_t);
d186 1
a186 1
	ce4231_round_buffersize,
a1310 9
}

size_t
ce4231_round_buffersize(addr, direction, size)
	void *addr;
	int direction;
	size_t size;
{
	return (size);
@


1.17
log
@Always free memory on failure in c{e,s}4231_alloc(); from Patrick Lafiti.
@
text
@d1 1
a1 1
/*	$OpenBSD: ce4231.c,v 1.16 2004/09/29 19:17:43 miod Exp $	*/
d671 1
a671 1
	return (blk & (-4));
@


1.16
log
@Ratibibugle now useless evcnt structures.
@
text
@d1 1
a1 1
/*	$OpenBSD: ce4231.c,v 1.15 2003/06/24 21:54:39 henric Exp $	*/
d1407 1
a1407 1
		goto fail;
d1439 1
@


1.15
log
@Add a "where" argument to the sparc64 interrupt code.  This lets us
associate a name with each interrupt handler.  This is not visible
outside the kernel (yet).

ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ce4231.c,v 1.14 2003/06/02 20:02:49 jason Exp $	*/
a292 2

	evcnt_attach(&sc->sc_dev, "intr", &sc->sc_intrcnt);
@


1.14
log
@nuke terms 3 & 4
@
text
@d1 1
a1 1
/*	$OpenBSD: ce4231.c,v 1.13 2003/05/11 19:41:12 deraadt Exp $	*/
d250 1
a250 1
	    IPL_AUDIO, 0, ce4231_cintr, sc);
d256 1
a256 1
	    IPL_AUDIO, 0, ce4231_pintr, sc);
@


1.13
log
@string cleaning; krw ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ce4231.c,v 1.12 2003/02/17 01:29:19 henric Exp $	*/
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Jason L. Wright
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.12
log
@
Add support for the Sun Enterprise 450
Reduce the size of a GENERIC kernel by ~190k
Remove the nasty pointer/bus_space_handle_t casts
Adds debug bus_space code including the ability to trace
    bus operations (it actually works now).

The following rules are now followed (and verfified by the debug
code):

1.  A "bus_space_handle_t" may only be used with the
    "bus_space_tag_t" that created it.
2.  Only "bus_space_map()" may create "bus_space_handle_t"s.
3.  A "bus_space_handle_t" may not be modified after it has
    been created (other than being destroyed by "bus_space_unmap()").


Thanks to help from mcbride, marc, jason, drahn, to anyone that might
have slipped my mind at the moment.

ok jason@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ce4231.c,v 1.11 2002/09/10 17:27:27 jason Exp $	*/
d519 1
a519 1
		strcpy(fp->name, AudioEmulaw);
d525 1
a525 1
		strcpy(fp->name, AudioEalaw);
d531 1
a531 1
		strcpy(fp->name, AudioEslinear_le);
d537 1
a537 1
		strcpy(fp->name, AudioEulinear);
d543 1
a543 1
		strcpy(fp->name, AudioEslinear_be);
d549 1
a549 1
		strcpy(fp->name, AudioEslinear);
d555 1
a555 1
		strcpy(fp->name, AudioEulinear_le);
d561 1
a561 1
		strcpy(fp->name, AudioEulinear_be);
d567 1
a567 1
		strcpy(fp->name, AudioEadpcm);
d1138 1
a1138 1
		strcpy(dip->label.name, AudioNmicrophone);
d1140 2
a1141 1
		strcpy(dip->un.v.units.name, AudioNvolume);
d1148 1
a1148 1
		strcpy(dip->label.name, AudioNdac);
d1150 2
a1151 1
		strcpy(dip->un.v.units.name, AudioNvolume);
d1158 1
a1158 1
		strcpy(dip->label.name, AudioNline);
d1160 2
a1161 1
		strcpy(dip->un.v.units.name, AudioNvolume);
d1168 1
a1168 1
		strcpy(dip->label.name, AudioNcd);
d1170 2
a1171 1
		strcpy(dip->un.v.units.name, AudioNvolume);
d1178 1
a1178 1
		strcpy(dip->label.name, AudioNmonitor);
d1180 2
a1181 1
		strcpy(dip->un.v.units.name, AudioNvolume);
d1188 1
a1188 1
		strcpy(dip->label.name, AudioNoutput);
d1190 2
a1191 1
		strcpy(dip->un.v.units.name, AudioNvolume);
d1231 1
a1231 1
		strcpy(dip->label.name, AudioNmute);
d1233 2
a1234 1
		strcpy(dip->un.e.member[0].label.name, AudioNon);
d1236 2
a1237 1
		strcpy(dip->un.e.member[1].label.name, AudioNoff);
d1245 1
a1245 1
		strcpy(dip->label.name, AudioNrecord);
d1247 2
a1248 1
		strcpy(dip->un.v.units.name, AudioNvolume);
d1255 1
a1255 1
		strcpy(dip->label.name, AudioNsource);
d1257 2
a1258 1
		strcpy(dip->un.e.member[0].label.name, AudioNcd);
d1260 2
a1261 1
		strcpy(dip->un.e.member[1].label.name, AudioNmicrophone);
d1263 2
a1264 1
		strcpy(dip->un.e.member[2].label.name, AudioNdac);
d1266 2
a1267 1
		strcpy(dip->un.e.member[3].label.name, AudioNline);
d1274 1
a1274 1
		strcpy(dip->label.name, AudioNoutput);
d1276 2
a1277 1
		strcpy(dip->un.e.member[0].label.name, AudioNspeaker);
d1279 2
a1280 1
		strcpy(dip->un.e.member[1].label.name, AudioNline);
d1282 2
a1283 1
		strcpy(dip->un.e.member[2].label.name, AudioNheadphone);
d1291 1
a1291 1
		strcpy(dip->label.name, AudioCinputs);
d1298 1
a1298 1
		strcpy(dip->label.name, AudioCoutputs);
d1305 1
a1305 1
		strcpy(dip->label.name, AudioCmonitor);
d1312 1
a1312 1
		strcpy(dip->label.name, AudioCrecord);
@


1.11
log
@Remove some debugging code, KNF, and fix encoding selection.
@
text
@d1 1
a1 1
/*	$OpenBSD: ce4231.c,v 1.10 2002/08/16 19:02:17 jason Exp $	*/
d240 1
a240 1
	sc->sc_bustag = ea->ea_bustag;
d254 1
a254 1
	sc->sc_cih = bus_intr_establish(ea->ea_bustag, ea->ea_intrs[0],
d260 1
a260 1
	sc->sc_pih = bus_intr_establish(ea->ea_bustag, ea->ea_intrs[1],
d269 1
a269 1
	if (ebus_bus_map(ea->ea_bustag, 0,
d276 1
a276 1
	if (ebus_bus_map(ea->ea_bustag, 0,
d283 1
a283 1
	if (ebus_bus_map(ea->ea_bustag, 0,
d290 1
a290 1
	if (ebus_bus_map(ea->ea_bustag, 0,
d1483 1
a1483 1
		printf("%s: trigger_output: bad addr: %x\n",
@


1.10
log
@remove debugging code
@
text
@d1 1
a1 1
/*	$OpenBSD: ce4231.c,v 1.9 2002/07/18 02:14:26 jason Exp $	*/
d396 1
a396 2
	if (selected == -1) {
		printf("%s: can't find speed\n", sc->sc_dev.dv_xname);
a397 1
	}
d585 3
a587 26
	int err, bits, enc;
	void (*pswcode)(void *, u_char *, int cnt);
	void (*rswcode)(void *, u_char *, int cnt);

	enc = p->encoding;
	pswcode = rswcode = 0;
	switch (enc) {
	case AUDIO_ENCODING_SLINEAR_LE:
		if (p->precision == 8) {
			enc = AUDIO_ENCODING_ULINEAR_LE;
			pswcode = rswcode = change_sign8;
		}
		break;
	case AUDIO_ENCODING_ULINEAR_LE:
		if (p->precision == 16) {
			enc = AUDIO_ENCODING_SLINEAR_LE;
			pswcode = rswcode = change_sign16;
		}
		break;
	case AUDIO_ENCODING_ULINEAR_BE:
		if (p->precision == 16) {
			enc = AUDIO_ENCODING_SLINEAR_BE;
			pswcode = rswcode = change_sign16;
		}
		break;
	}
d591 2
d596 2
a599 3
	case AUDIO_ENCODING_ADPCM:
		bits = FMT_ADPCM >> 5;
		break;
d601 4
a604 1
		if (p->precision == 16)
d609 5
d615 4
a618 1
		if (p->precision == 16)
d623 6
d632 17
a648 1
		else
d650 1
d897 2
d1110 2
a1111 1
		if (cp->type != AUDIO_MIXER_ENUM) break;
d1116 2
a1117 1
		if (cp->type != AUDIO_MIXER_ENUM) break;
@


1.9
log
@another prom name, 'audio'
@
text
@d1 1
a1 1
/*	$OpenBSD: ce4231.c,v 1.8 2002/04/08 17:49:41 jason Exp $	*/
a1106 2
	default:
		printf("Invalid kind!\n");
@


1.8
log
@Credit DARPA/USAF appropriately.
@
text
@d1 1
a1 1
/*	$OpenBSD: ce4231.c,v 1.7 2002/03/14 03:16:00 millert Exp $	*/
d220 4
a223 1
	return (strcmp("SUNW,CS4231", ea->ea_name) == 0);
@


1.7
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: ce4231.c,v 1.6 2002/03/14 01:26:44 millert Exp $	*/
d37 5
@


1.6
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: ce4231.c,v 1.5 2002/01/24 03:06:54 jason Exp $	*/
d160 4
a163 4
int	ce4231_trigger_output __P((void *, void *, void *, int,
    void (*intr)(void *), void *arg, struct audio_params *));
int	ce4231_trigger_input __P((void *, void *, void *, int,
    void (*intr)(void *), void *arg, struct audio_params *));
@


1.5
log
@Save the interrupt cookies and fix the printfs for failure.
@
text
@d1 1
a1 1
/*	$OpenBSD: ce4231.c,v 1.4 2002/01/20 23:21:54 ericj Exp $	*/
d131 4
a134 4
int	ce4231_match	__P((struct device *, void *, void *));
void	ce4231_attach	__P((struct device *, struct device *, void *));
int	ce4231_cintr	__P((void *));
int	ce4231_pintr	__P((void *));
d136 2
a137 2
int	ce4231_set_speed	__P((struct ce4231_softc *, u_long *));
void	ce4231_setup_output	__P((struct ce4231_softc *sc));
d139 2
a140 2
void		ce4231_write	__P((struct ce4231_softc *, u_int8_t, u_int8_t));
u_int8_t	ce4231_read	__P((struct ce4231_softc *, u_int8_t));
d143 17
a159 17
int	ce4231_open		__P((void *, int));
void	ce4231_close		__P((void *));
int	ce4231_query_encoding	__P((void *, struct audio_encoding *));
int	ce4231_set_params	__P((void *, int, int, struct audio_params *,
    struct audio_params *));
int	ce4231_round_blocksize	__P((void *, int));
int	ce4231_commit_settings	__P((void *));
int	ce4231_halt_output	__P((void *));
int	ce4231_halt_input	__P((void *));
int	ce4231_getdev		__P((void *, struct audio_device *));
int	ce4231_set_port		__P((void *, mixer_ctrl_t *));
int	ce4231_get_port		__P((void *, mixer_ctrl_t *));
int	ce4231_query_devinfo	__P((void *addr, mixer_devinfo_t *));
void *	ce4231_alloc		__P((void *, int, size_t, int, int));
void	ce4231_free		__P((void *, void *, int));
size_t	ce4231_round_buffersize	__P((void *, int, size_t));
int	ce4231_get_props	__P((void *));
d161 1
a161 1
    void (*intr)__P((void *)), void *arg, struct audio_params *));
d163 1
a163 1
    void (*intr)__P((void *)), void *arg, struct audio_params *));
d580 2
a581 2
	void (*pswcode) __P((void *, u_char *, int cnt));
	void (*rswcode) __P((void *, u_char *, int cnt));
d1441 1
a1441 1
	void (*intr) __P((void *));
d1513 1
a1513 1
	void (*intr) __P((void *));
@


1.4
log
@
move a few more arch specific drivers to use new allocm and round_buffersize.
@
text
@d1 1
a1 1
/*	$OpenBSD: ce4231.c,v 1.3 2002/01/11 17:26:34 jason Exp $	*/
d246 4
a249 3
	if (bus_intr_establish(ea->ea_bustag, ea->ea_intrs[0], IPL_AUDIO, 0,
	    ce4231_cintr, sc) == NULL) {
		printf(": couldn't establish interrupt1\n");
d252 4
a255 3
	if (bus_intr_establish(ea->ea_bustag, ea->ea_intrs[1], IPL_AUDIO, 0,
	    ce4231_pintr, sc) == NULL) {
		printf(": couldn't establish interrupt1\n");
@


1.3
log
@enable/disable IEN in cs4231 pin control register
@
text
@d1 1
a1 1
/*	$OpenBSD: ce4231.c,v 1.2 2001/10/02 00:26:24 jason Exp $	*/
d156 1
a156 1
void *	ce4231_alloc		__P((void *, u_long, int, int));
d158 1
a158 1
u_long	ce4231_round_buffersize	__P((void *, u_long));
d1283 2
a1284 2
u_long
ce4231_round_buffersize(addr, size)
d1286 2
a1287 1
	u_long size;
d1363 1
a1363 1
ce4231_alloc(addr, size, pool, flags)
d1365 2
a1366 1
	u_long size;
@


1.2
log
@fix dma problems... now blaring Berlin's The Metro around the house from U30.
(like cs4231, this driver only supports playback... capture will have to
wait until post 3.0).
@
text
@d1 1
a1 1
/*	$OpenBSD: ce4231.c,v 1.1 2001/10/01 18:10:32 jason Exp $	*/
d436 4
d497 2
@


1.2.6.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: ce4231.c,v 1.5 2002/01/24 03:06:54 jason Exp $	*/
d156 1
a156 1
void *	ce4231_alloc		__P((void *, int, size_t, int, int));
d158 1
a158 1
size_t	ce4231_round_buffersize	__P((void *, int, size_t));
d246 3
a248 4
	sc->sc_cih = bus_intr_establish(ea->ea_bustag, ea->ea_intrs[0],
	    IPL_AUDIO, 0, ce4231_cintr, sc);
	if (sc->sc_cih == NULL) {
		printf(": couldn't establish capture interrupt\n");
d251 3
a253 4
	sc->sc_pih = bus_intr_establish(ea->ea_bustag, ea->ea_intrs[1],
	    IPL_AUDIO, 0, ce4231_pintr, sc);
	if (sc->sc_pih == NULL) {
		printf(": couldn't establish play interrupt1\n");
a435 4

	ce4231_write(sc, SP_PIN_CONTROL,
	    ce4231_read(sc, SP_PIN_CONTROL) | INTERRUPT_ENABLE);

a492 2
	ce4231_write(sc, SP_PIN_CONTROL,
	    ce4231_read(sc, SP_PIN_CONTROL) & (~INTERRUPT_ENABLE));
d1277 2
a1278 2
size_t
ce4231_round_buffersize(addr, direction, size)
d1280 1
a1280 2
	int direction;
	size_t size;
d1356 1
a1356 1
ce4231_alloc(addr, direction, size, pool, flags)
d1358 1
a1358 2
	int direction;
	size_t size;
@


1.2.6.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ce4231.c,v 1.2.6.1 2002/01/31 22:55:23 niklas Exp $	*/
a36 5
 *
 * Effort sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F30602-01-2-0537.
 *
d131 4
a134 4
int	ce4231_match(struct device *, void *, void *);
void	ce4231_attach(struct device *, struct device *, void *);
int	ce4231_cintr(void *);
int	ce4231_pintr(void *);
d136 2
a137 2
int	ce4231_set_speed(struct ce4231_softc *, u_long *);
void	ce4231_setup_output(struct ce4231_softc *sc);
d139 2
a140 2
void		ce4231_write(struct ce4231_softc *, u_int8_t, u_int8_t);
u_int8_t	ce4231_read(struct ce4231_softc *, u_int8_t);
d143 21
a163 21
int	ce4231_open(void *, int);
void	ce4231_close(void *);
int	ce4231_query_encoding(void *, struct audio_encoding *);
int	ce4231_set_params(void *, int, int, struct audio_params *,
    struct audio_params *);
int	ce4231_round_blocksize(void *, int);
int	ce4231_commit_settings(void *);
int	ce4231_halt_output(void *);
int	ce4231_halt_input(void *);
int	ce4231_getdev(void *, struct audio_device *);
int	ce4231_set_port(void *, mixer_ctrl_t *);
int	ce4231_get_port(void *, mixer_ctrl_t *);
int	ce4231_query_devinfo(void *addr, mixer_devinfo_t *);
void *	ce4231_alloc(void *, int, size_t, int, int);
void	ce4231_free(void *, void *, int);
size_t	ce4231_round_buffersize(void *, int, size_t);
int	ce4231_get_props(void *);
int	ce4231_trigger_output(void *, void *, void *, int,
    void (*intr)(void *), void *arg, struct audio_params *);
int	ce4231_trigger_input(void *, void *, void *, int,
    void (*intr)(void *), void *arg, struct audio_params *);
d580 2
a581 2
	void (*pswcode)(void *, u_char *, int cnt);
	void (*rswcode)(void *, u_char *, int cnt);
d1441 1
a1441 1
	void (*intr)(void *);
d1513 1
a1513 1
	void (*intr)(void *);
@


1.2.6.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ce4231.c,v 1.2.6.2 2002/06/11 03:38:42 art Exp $	*/
d220 1
a220 4
	if (!strcmp("SUNW,CS4231", ea->ea_name) ||
	    !strcmp("audio", ea->ea_name))
		return (1);
	return (0);
d393 2
a394 1
	if (selected == -1)
d396 1
d584 26
a609 3
	int err, bits, enc = p->encoding;
	void (*pswcode)(void *, u_char *, int cnt) = NULL;
	void (*rswcode)(void *, u_char *, int cnt) = NULL;
a612 2
		if (p->precision != 8)
			return (EINVAL);
a615 2
		if (p->precision != 8)
			return (EINVAL);
d618 3
d622 1
a622 4
		if (p->precision == 8) {
			bits = FMT_PCM8 >> 5;
			pswcode = rswcode = change_sign8;
		} else if (p->precision == 16)
a626 5
	case AUDIO_ENCODING_ULINEAR:
		if (p->precision != 8)
			return (EINVAL);
		bits = FMT_PCM8 >> 5;
		break;
d628 1
a628 4
		if (p->precision == 8) {
			bits = FMT_PCM8 >> 5;
			pswcode = rswcode = change_sign8;
		} else if (p->precision == 16)
a632 6
	case AUDIO_ENCODING_SLINEAR:
		if (p->precision != 8)
			return (EINVAL);
		bits = FMT_PCM8 >> 5;
		pswcode = rswcode = change_sign8;
		break;
d636 1
a636 13
		else if (p->precision == 16) {
			bits = FMT_TWOS_COMP >> 5;
			pswcode = rswcode = change_sign16_le;
		} else
			return (EINVAL);
		break;
	case AUDIO_ENCODING_ULINEAR_BE:
		if (p->precision == 8)
			bits = FMT_PCM8 >> 5;
		else if (p->precision == 16) {
			bits = FMT_TWOS_COMP_BE >> 5;
			pswcode = rswcode = change_sign16_be;
		} else
a638 5
	case AUDIO_ENCODING_ADPCM:
		if (p->precision != 8)
			return (EINVAL);
		bits = FMT_ADPCM >> 5;
		break;
a883 2
		if (cp->type != AUDIO_MIXER_ENUM)
			break;
d1095 1
a1095 2
		if (cp->type != AUDIO_MIXER_ENUM)
			break;
d1100 1
a1100 2
		if (cp->type != AUDIO_MIXER_ENUM)
			break;
d1104 2
@


1.2.6.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d240 1
a240 1
	sc->sc_bustag = ea->ea_memtag;
d254 1
a254 1
	sc->sc_cih = bus_intr_establish(sc->sc_bustag, ea->ea_intrs[0],
d260 1
a260 1
	sc->sc_pih = bus_intr_establish(sc->sc_bustag, ea->ea_intrs[1],
d269 1
a269 1
	if (ebus_bus_map(sc->sc_bustag, 0,
d276 1
a276 1
	if (ebus_bus_map(sc->sc_bustag, 0,
d283 1
a283 1
	if (ebus_bus_map(sc->sc_bustag, 0,
d290 1
a290 1
	if (ebus_bus_map(sc->sc_bustag, 0,
d519 1
a519 1
		strlcpy(fp->name, AudioEmulaw, sizeof fp->name);
d525 1
a525 1
		strlcpy(fp->name, AudioEalaw, sizeof fp->name);
d531 1
a531 1
		strlcpy(fp->name, AudioEslinear_le, sizeof fp->name);
d537 1
a537 1
		strlcpy(fp->name, AudioEulinear, sizeof fp->name);
d543 1
a543 1
		strlcpy(fp->name, AudioEslinear_be, sizeof fp->name);
d549 1
a549 1
		strlcpy(fp->name, AudioEslinear, sizeof fp->name);
d555 1
a555 1
		strlcpy(fp->name, AudioEulinear_le, sizeof fp->name);
d561 1
a561 1
		strlcpy(fp->name, AudioEulinear_be, sizeof fp->name);
d567 1
a567 1
		strlcpy(fp->name, AudioEadpcm, sizeof fp->name);
d1138 1
a1138 1
		strlcpy(dip->label.name, AudioNmicrophone, sizeof dip->label.name);
d1140 1
a1140 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d1147 1
a1147 1
		strlcpy(dip->label.name, AudioNdac, sizeof dip->label.name);
d1149 1
a1149 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d1156 1
a1156 1
		strlcpy(dip->label.name, AudioNline, sizeof dip->label.name);
d1158 1
a1158 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d1165 1
a1165 1
		strlcpy(dip->label.name, AudioNcd, sizeof dip->label.name);
d1167 1
a1167 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d1174 1
a1174 1
		strlcpy(dip->label.name, AudioNmonitor, sizeof dip->label.name);
d1176 1
a1176 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d1183 1
a1183 1
		strlcpy(dip->label.name, AudioNoutput, sizeof dip->label.name);
d1185 1
a1185 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d1225 1
a1225 1
		strlcpy(dip->label.name, AudioNmute, sizeof dip->label.name);
d1227 1
a1227 2
		strlcpy(dip->un.e.member[0].label.name, AudioNon,
		    sizeof dip->un.e.member[0].label.name);
d1229 1
a1229 2
		strlcpy(dip->un.e.member[1].label.name, AudioNoff,
		    sizeof dip->un.e.member[1].label.name);
d1237 1
a1237 1
		strlcpy(dip->label.name, AudioNrecord, sizeof dip->label.name);
d1239 1
a1239 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d1246 1
a1246 1
		strlcpy(dip->label.name, AudioNsource, sizeof dip->label.name);
d1248 1
a1248 2
		strlcpy(dip->un.e.member[0].label.name, AudioNcd,
		    sizeof dip->un.e.member[0].label.name);
d1250 1
a1250 2
		strlcpy(dip->un.e.member[1].label.name, AudioNmicrophone,
		    sizeof dip->un.e.member[1].label.name);
d1252 1
a1252 2
		strlcpy(dip->un.e.member[2].label.name, AudioNdac,
		    sizeof dip->un.e.member[2].label.name);
d1254 1
a1254 2
		strlcpy(dip->un.e.member[3].label.name, AudioNline,
		    sizeof dip->un.e.member[3].label.name);
d1261 1
a1261 1
		strlcpy(dip->label.name, AudioNoutput, sizeof dip->label.name);
d1263 1
a1263 2
		strlcpy(dip->un.e.member[0].label.name, AudioNspeaker,
		    sizeof dip->un.e.member[0].label.name);
d1265 1
a1265 2
		strlcpy(dip->un.e.member[1].label.name, AudioNline,
		    sizeof dip->un.e.member[1].label.name);
d1267 1
a1267 2
		strlcpy(dip->un.e.member[2].label.name, AudioNheadphone,
		    sizeof dip->un.e.member[2].label.name);
d1275 1
a1275 1
		strlcpy(dip->label.name, AudioCinputs, sizeof dip->label.name);
d1282 1
a1282 1
		strlcpy(dip->label.name, AudioCoutputs, sizeof dip->label.name);
d1289 1
a1289 1
		strlcpy(dip->label.name, AudioCmonitor, sizeof dip->label.name);
d1296 1
a1296 1
		strlcpy(dip->label.name, AudioCrecord, sizeof dip->label.name);
d1483 1
a1483 1
		printf("%s: trigger_output: bad addr: %p\n",
@


1.2.4.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.2.4.2
log
@Merge in trunk
@
text
@d156 1
a156 1
void *	ce4231_alloc		__P((void *, int, size_t, int, int));
d158 1
a158 1
size_t	ce4231_round_buffersize	__P((void *, int, size_t));
d246 3
a248 4
	sc->sc_cih = bus_intr_establish(ea->ea_bustag, ea->ea_intrs[0],
	    IPL_AUDIO, 0, ce4231_cintr, sc);
	if (sc->sc_cih == NULL) {
		printf(": couldn't establish capture interrupt\n");
d251 3
a253 4
	sc->sc_pih = bus_intr_establish(ea->ea_bustag, ea->ea_intrs[1],
	    IPL_AUDIO, 0, ce4231_pintr, sc);
	if (sc->sc_pih == NULL) {
		printf(": couldn't establish play interrupt1\n");
a435 4

	ce4231_write(sc, SP_PIN_CONTROL,
	    ce4231_read(sc, SP_PIN_CONTROL) | INTERRUPT_ENABLE);

a492 2
	ce4231_write(sc, SP_PIN_CONTROL,
	    ce4231_read(sc, SP_PIN_CONTROL) & (~INTERRUPT_ENABLE));
d1277 2
a1278 2
size_t
ce4231_round_buffersize(addr, direction, size)
d1280 1
a1280 2
	int direction;
	size_t size;
d1356 1
a1356 1
ce4231_alloc(addr, direction, size, pool, flags)
d1358 1
a1358 2
	int direction;
	size_t size;
@


1.2.4.3
log
@Merge in -current from about a week ago
@
text
@d131 4
a134 4
int	ce4231_match(struct device *, void *, void *);
void	ce4231_attach(struct device *, struct device *, void *);
int	ce4231_cintr(void *);
int	ce4231_pintr(void *);
d136 2
a137 2
int	ce4231_set_speed(struct ce4231_softc *, u_long *);
void	ce4231_setup_output(struct ce4231_softc *sc);
d139 2
a140 2
void		ce4231_write(struct ce4231_softc *, u_int8_t, u_int8_t);
u_int8_t	ce4231_read(struct ce4231_softc *, u_int8_t);
d143 21
a163 21
int	ce4231_open(void *, int);
void	ce4231_close(void *);
int	ce4231_query_encoding(void *, struct audio_encoding *);
int	ce4231_set_params(void *, int, int, struct audio_params *,
    struct audio_params *);
int	ce4231_round_blocksize(void *, int);
int	ce4231_commit_settings(void *);
int	ce4231_halt_output(void *);
int	ce4231_halt_input(void *);
int	ce4231_getdev(void *, struct audio_device *);
int	ce4231_set_port(void *, mixer_ctrl_t *);
int	ce4231_get_port(void *, mixer_ctrl_t *);
int	ce4231_query_devinfo(void *addr, mixer_devinfo_t *);
void *	ce4231_alloc(void *, int, size_t, int, int);
void	ce4231_free(void *, void *, int);
size_t	ce4231_round_buffersize(void *, int, size_t);
int	ce4231_get_props(void *);
int	ce4231_trigger_output(void *, void *, void *, int,
    void (*intr)(void *), void *arg, struct audio_params *);
int	ce4231_trigger_input(void *, void *, void *, int,
    void (*intr)(void *), void *arg, struct audio_params *);
d580 2
a581 2
	void (*pswcode)(void *, u_char *, int cnt);
	void (*rswcode)(void *, u_char *, int cnt);
d1441 1
a1441 1
	void (*intr)(void *);
d1513 1
a1513 1
	void (*intr)(void *);
@


1.2.4.4
log
@Sync the SMP branch with 3.3
@
text
@a36 5
 *
 * Effort sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F30602-01-2-0537.
 *
d215 1
a215 4
	if (!strcmp("SUNW,CS4231", ea->ea_name) ||
	    !strcmp("audio", ea->ea_name))
		return (1);
	return (0);
d232 1
a232 1
	sc->sc_bustag = ea->ea_memtag;
d246 1
a246 1
	sc->sc_cih = bus_intr_establish(sc->sc_bustag, ea->ea_intrs[0],
d252 1
a252 1
	sc->sc_pih = bus_intr_establish(sc->sc_bustag, ea->ea_intrs[1],
d261 1
a261 1
	if (ebus_bus_map(sc->sc_bustag, 0,
d268 1
a268 1
	if (ebus_bus_map(sc->sc_bustag, 0,
d275 1
a275 1
	if (ebus_bus_map(sc->sc_bustag, 0,
d282 1
a282 1
	if (ebus_bus_map(sc->sc_bustag, 0,
d388 2
a389 1
	if (selected == -1)
d391 1
d579 26
a604 3
	int err, bits, enc = p->encoding;
	void (*pswcode)(void *, u_char *, int cnt) = NULL;
	void (*rswcode)(void *, u_char *, int cnt) = NULL;
a607 2
		if (p->precision != 8)
			return (EINVAL);
a610 2
		if (p->precision != 8)
			return (EINVAL);
d613 3
d617 1
a617 4
		if (p->precision == 8) {
			bits = FMT_PCM8 >> 5;
			pswcode = rswcode = change_sign8;
		} else if (p->precision == 16)
a621 5
	case AUDIO_ENCODING_ULINEAR:
		if (p->precision != 8)
			return (EINVAL);
		bits = FMT_PCM8 >> 5;
		break;
d623 1
a623 4
		if (p->precision == 8) {
			bits = FMT_PCM8 >> 5;
			pswcode = rswcode = change_sign8;
		} else if (p->precision == 16)
a627 6
	case AUDIO_ENCODING_SLINEAR:
		if (p->precision != 8)
			return (EINVAL);
		bits = FMT_PCM8 >> 5;
		pswcode = rswcode = change_sign8;
		break;
d631 1
a631 13
		else if (p->precision == 16) {
			bits = FMT_TWOS_COMP >> 5;
			pswcode = rswcode = change_sign16_le;
		} else
			return (EINVAL);
		break;
	case AUDIO_ENCODING_ULINEAR_BE:
		if (p->precision == 8)
			bits = FMT_PCM8 >> 5;
		else if (p->precision == 16) {
			bits = FMT_TWOS_COMP_BE >> 5;
			pswcode = rswcode = change_sign16_be;
		} else
a633 5
	case AUDIO_ENCODING_ADPCM:
		if (p->precision != 8)
			return (EINVAL);
		bits = FMT_ADPCM >> 5;
		break;
a878 2
		if (cp->type != AUDIO_MIXER_ENUM)
			break;
d1090 1
a1090 2
		if (cp->type != AUDIO_MIXER_ENUM)
			break;
d1095 1
a1095 2
		if (cp->type != AUDIO_MIXER_ENUM)
			break;
d1099 2
d1463 1
a1463 1
		printf("%s: trigger_output: bad addr: %p\n",
@


1.2.4.5
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: ce4231.c,v 1.2.4.4 2003/03/27 23:42:35 niklas Exp $	*/
d519 1
a519 1
		strlcpy(fp->name, AudioEmulaw, sizeof fp->name);
d525 1
a525 1
		strlcpy(fp->name, AudioEalaw, sizeof fp->name);
d531 1
a531 1
		strlcpy(fp->name, AudioEslinear_le, sizeof fp->name);
d537 1
a537 1
		strlcpy(fp->name, AudioEulinear, sizeof fp->name);
d543 1
a543 1
		strlcpy(fp->name, AudioEslinear_be, sizeof fp->name);
d549 1
a549 1
		strlcpy(fp->name, AudioEslinear, sizeof fp->name);
d555 1
a555 1
		strlcpy(fp->name, AudioEulinear_le, sizeof fp->name);
d561 1
a561 1
		strlcpy(fp->name, AudioEulinear_be, sizeof fp->name);
d567 1
a567 1
		strlcpy(fp->name, AudioEadpcm, sizeof fp->name);
d1138 1
a1138 1
		strlcpy(dip->label.name, AudioNmicrophone, sizeof dip->label.name);
d1140 1
a1140 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d1147 1
a1147 1
		strlcpy(dip->label.name, AudioNdac, sizeof dip->label.name);
d1149 1
a1149 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d1156 1
a1156 1
		strlcpy(dip->label.name, AudioNline, sizeof dip->label.name);
d1158 1
a1158 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d1165 1
a1165 1
		strlcpy(dip->label.name, AudioNcd, sizeof dip->label.name);
d1167 1
a1167 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d1174 1
a1174 1
		strlcpy(dip->label.name, AudioNmonitor, sizeof dip->label.name);
d1176 1
a1176 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d1183 1
a1183 1
		strlcpy(dip->label.name, AudioNoutput, sizeof dip->label.name);
d1185 1
a1185 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d1225 1
a1225 1
		strlcpy(dip->label.name, AudioNmute, sizeof dip->label.name);
d1227 1
a1227 2
		strlcpy(dip->un.e.member[0].label.name, AudioNon,
		    sizeof dip->un.e.member[0].label.name);
d1229 1
a1229 2
		strlcpy(dip->un.e.member[1].label.name, AudioNoff,
		    sizeof dip->un.e.member[1].label.name);
d1237 1
a1237 1
		strlcpy(dip->label.name, AudioNrecord, sizeof dip->label.name);
d1239 1
a1239 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d1246 1
a1246 1
		strlcpy(dip->label.name, AudioNsource, sizeof dip->label.name);
d1248 1
a1248 2
		strlcpy(dip->un.e.member[0].label.name, AudioNcd,
		    sizeof dip->un.e.member[0].label.name);
d1250 1
a1250 2
		strlcpy(dip->un.e.member[1].label.name, AudioNmicrophone,
		    sizeof dip->un.e.member[1].label.name);
d1252 1
a1252 2
		strlcpy(dip->un.e.member[2].label.name, AudioNdac,
		    sizeof dip->un.e.member[2].label.name);
d1254 1
a1254 2
		strlcpy(dip->un.e.member[3].label.name, AudioNline,
		    sizeof dip->un.e.member[3].label.name);
d1261 1
a1261 1
		strlcpy(dip->label.name, AudioNoutput, sizeof dip->label.name);
d1263 1
a1263 2
		strlcpy(dip->un.e.member[0].label.name, AudioNspeaker,
		    sizeof dip->un.e.member[0].label.name);
d1265 1
a1265 2
		strlcpy(dip->un.e.member[1].label.name, AudioNline,
		    sizeof dip->un.e.member[1].label.name);
d1267 1
a1267 2
		strlcpy(dip->un.e.member[2].label.name, AudioNheadphone,
		    sizeof dip->un.e.member[2].label.name);
d1275 1
a1275 1
		strlcpy(dip->label.name, AudioCinputs, sizeof dip->label.name);
d1282 1
a1282 1
		strlcpy(dip->label.name, AudioCoutputs, sizeof dip->label.name);
d1289 1
a1289 1
		strlcpy(dip->label.name, AudioCmonitor, sizeof dip->label.name);
d1296 1
a1296 1
		strlcpy(dip->label.name, AudioCrecord, sizeof dip->label.name);
@


1.2.4.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ce4231.c,v 1.2.4.5 2003/05/13 19:41:09 ho Exp $	*/
d15 5
@


1.2.4.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d250 1
a250 1
	    IPL_AUDIO, 0, ce4231_cintr, sc, self->dv_xname);
d256 1
a256 1
	    IPL_AUDIO, 0, ce4231_pintr, sc, self->dv_xname);
@


1.1
log
@driver for cs4231 at ebus: doesn't quite sound right yet (VERY choppy and
noisy... probably dma issue).  This isn't the final destination for these
files either (alot of sharing can be done with sbus version, I think).
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4231.c,v 1.7 2001/10/01 04:10:49 jason Exp $	*/
d1337 1
a1337 1
			nextaddr = P_READ(sc, EBDMA_DADDR) + sc->sc_blksz;
d1345 1
d1494 1
@

