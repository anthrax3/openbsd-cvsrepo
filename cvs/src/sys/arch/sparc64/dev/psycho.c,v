head	1.74;
access;
symbols
	OPENBSD_6_1:1.74.0.2
	OPENBSD_6_1_BASE:1.74
	OPENBSD_6_0:1.73.0.10
	OPENBSD_6_0_BASE:1.73
	OPENBSD_5_9:1.73.0.6
	OPENBSD_5_9_BASE:1.73
	OPENBSD_5_8:1.73.0.8
	OPENBSD_5_8_BASE:1.73
	OPENBSD_5_7:1.73.0.2
	OPENBSD_5_7_BASE:1.73
	OPENBSD_5_6:1.73.0.4
	OPENBSD_5_6_BASE:1.73
	OPENBSD_5_5:1.70.0.4
	OPENBSD_5_5_BASE:1.70
	OPENBSD_5_4:1.69.0.10
	OPENBSD_5_4_BASE:1.69
	OPENBSD_5_3:1.69.0.8
	OPENBSD_5_3_BASE:1.69
	OPENBSD_5_2:1.69.0.6
	OPENBSD_5_2_BASE:1.69
	OPENBSD_5_1_BASE:1.69
	OPENBSD_5_1:1.69.0.4
	OPENBSD_5_0:1.69.0.2
	OPENBSD_5_0_BASE:1.69
	OPENBSD_4_9:1.67.0.2
	OPENBSD_4_9_BASE:1.67
	OPENBSD_4_8:1.66.0.6
	OPENBSD_4_8_BASE:1.66
	OPENBSD_4_7:1.66.0.2
	OPENBSD_4_7_BASE:1.66
	OPENBSD_4_6:1.66.0.4
	OPENBSD_4_6_BASE:1.66
	OPENBSD_4_5:1.64.0.2
	OPENBSD_4_5_BASE:1.64
	OPENBSD_4_4:1.62.0.2
	OPENBSD_4_4_BASE:1.62
	OPENBSD_4_3:1.55.0.2
	OPENBSD_4_3_BASE:1.55
	OPENBSD_4_2:1.52.0.2
	OPENBSD_4_2_BASE:1.52
	OPENBSD_4_1:1.50.0.2
	OPENBSD_4_1_BASE:1.50
	OPENBSD_4_0:1.47.0.2
	OPENBSD_4_0_BASE:1.47
	OPENBSD_3_9:1.41.0.4
	OPENBSD_3_9_BASE:1.41
	OPENBSD_3_8:1.41.0.2
	OPENBSD_3_8_BASE:1.41
	OPENBSD_3_7:1.40.0.2
	OPENBSD_3_7_BASE:1.40
	OPENBSD_3_6:1.38.0.6
	OPENBSD_3_6_BASE:1.38
	SMP_SYNC_A:1.38
	SMP_SYNC_B:1.38
	OPENBSD_3_5:1.38.0.2
	OPENBSD_3_5_BASE:1.38
	OPENBSD_3_4:1.37.0.2
	OPENBSD_3_4_BASE:1.37
	UBC_SYNC_A:1.32
	OPENBSD_3_3:1.30.0.2
	OPENBSD_3_3_BASE:1.30
	OPENBSD_3_2:1.22.0.2
	OPENBSD_3_2_BASE:1.22
	OPENBSD_3_1:1.18.0.2
	OPENBSD_3_1_BASE:1.18
	UBC_SYNC_B:1.23
	UBC:1.9.0.2
	UBC_BASE:1.9
	SMP:1.8.0.4
	OPENBSD_3_0:1.8.0.2
	OPENBSD_3_0_BASE:1.8;
locks; strict;
comment	@ * @;


1.74
date	2016.08.23.03.28.01;	author guenther;	state Exp;
branches;
next	1.73;
commitid	sVHD5kblxhZITIq0;

1.73
date	2014.07.12.22.37.03;	author uebayasi;	state Exp;
branches;
next	1.72;
commitid	5h3kYJioMDqUXM3V;

1.72
date	2014.07.12.18.44.43;	author tedu;	state Exp;
branches;
next	1.71;
commitid	uKVPYMN2MLxdZxzH;

1.71
date	2014.07.12.14.12.44;	author uebayasi;	state Exp;
branches;
next	1.70;
commitid	CwxiCWSX4kdxVfoo;

1.70
date	2014.01.24.09.36.23;	author kettenis;	state Exp;
branches;
next	1.69;

1.69
date	2011.07.06.23.43.14;	author kettenis;	state Exp;
branches;
next	1.68;

1.68
date	2011.06.26.20.32.36;	author kettenis;	state Exp;
branches;
next	1.67;

1.67
date	2010.12.04.17.06.32;	author miod;	state Exp;
branches;
next	1.66;

1.66
date	2009.03.29.22.52.11;	author kettenis;	state Exp;
branches;
next	1.65;

1.65
date	2009.03.29.21.53.52;	author sthen;	state Exp;
branches;
next	1.64;

1.64
date	2009.01.02.20.01.45;	author kettenis;	state Exp;
branches;
next	1.63;

1.63
date	2008.11.25.16.31.19;	author kettenis;	state Exp;
branches;
next	1.62;

1.62
date	2008.07.23.12.18.40;	author kettenis;	state Exp;
branches;
next	1.61;

1.61
date	2008.07.20.10.37.43;	author kettenis;	state Exp;
branches;
next	1.60;

1.60
date	2008.07.12.10.07.25;	author kettenis;	state Exp;
branches;
next	1.59;

1.59
date	2008.06.02.19.39.08;	author kettenis;	state Exp;
branches;
next	1.58;

1.58
date	2008.05.24.23.31.37;	author kettenis;	state Exp;
branches;
next	1.57;

1.57
date	2008.05.24.20.57.46;	author kettenis;	state Exp;
branches;
next	1.56;

1.56
date	2008.03.16.22.19.57;	author kettenis;	state Exp;
branches;
next	1.55;

1.55
date	2008.01.19.11.13.43;	author kettenis;	state Exp;
branches;
next	1.54;

1.54
date	2007.10.08.18.30.13;	author krw;	state Exp;
branches;
next	1.53;

1.53
date	2007.09.08.10.50.04;	author martin;	state Exp;
branches;
next	1.52;

1.52
date	2007.08.04.16.44.15;	author kettenis;	state Exp;
branches;
next	1.51;

1.51
date	2007.04.10.17.47.55;	author miod;	state Exp;
branches;
next	1.50;

1.50
date	2007.01.26.16.53.28;	author tsi;	state Exp;
branches;
next	1.49;

1.49
date	2006.12.24.01.25.01;	author deraadt;	state Exp;
branches;
next	1.48;

1.48
date	2006.12.14.17.36.12;	author kettenis;	state Exp;
branches;
next	1.47;

1.47
date	2006.07.01.16.41.26;	author deraadt;	state Exp;
branches;
next	1.46;

1.46
date	2006.07.01.13.57.50;	author kettenis;	state Exp;
branches;
next	1.45;

1.45
date	2006.06.28.20.09.15;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2006.06.27.21.22.14;	author kettenis;	state Exp;
branches;
next	1.43;

1.43
date	2006.03.19.02.43.38;	author brad;	state Exp;
branches;
next	1.42;

1.42
date	2006.03.13.20.10.49;	author brad;	state Exp;
branches;
next	1.41;

1.41
date	2005.06.06.20.31.12;	author jason;	state Exp;
branches;
next	1.40;

1.40
date	2005.01.27.21.17.50;	author miod;	state Exp;
branches;
next	1.39;

1.39
date	2004.12.18.03.05.24;	author brad;	state Exp;
branches;
next	1.38;

1.38
date	2003.12.20.20.08.17;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2003.06.24.21.54.39;	author henric;	state Exp;
branches;
next	1.36;

1.36
date	2003.06.11.03.16.12;	author henric;	state Exp;
branches;
next	1.35;

1.35
date	2003.06.04.23.26.12;	author henric;	state Exp;
branches;
next	1.34;

1.34
date	2003.06.02.12.22.32;	author henric;	state Exp;
branches;
next	1.33;

1.33
date	2003.05.30.00.15.36;	author henric;	state Exp;
branches;
next	1.32;

1.32
date	2003.05.16.17.18.14;	author jason;	state Exp;
branches;
next	1.31;

1.31
date	2003.05.16.06.59.12;	author henric;	state Exp;
branches;
next	1.30;

1.30
date	2003.03.25.22.10.19;	author jason;	state Exp;
branches;
next	1.29;

1.29
date	2003.03.06.08.26.08;	author henric;	state Exp;
branches;
next	1.28;

1.28
date	2003.03.05.00.20.13;	author henric;	state Exp;
branches;
next	1.27;

1.27
date	2003.02.17.01.29.20;	author henric;	state Exp;
branches;
next	1.26;

1.26
date	2003.02.11.19.20.26;	author mickey;	state Exp;
branches;
next	1.25;

1.25
date	2003.01.13.16.04.38;	author jason;	state Exp;
branches;
next	1.24;

1.24
date	2002.12.02.17.08.51;	author jason;	state Exp;
branches;
next	1.23;

1.23
date	2002.10.12.01.09.43;	author krw;	state Exp;
branches;
next	1.22;

1.22
date	2002.09.17.13.25.52;	author art;	state Exp;
branches;
next	1.21;

1.21
date	2002.07.18.05.46.29;	author jason;	state Exp;
branches;
next	1.20;

1.20
date	2002.06.08.18.06.02;	author jason;	state Exp;
branches;
next	1.19;

1.19
date	2002.06.07.08.40.33;	author jason;	state Exp;
branches;
next	1.18;

1.18
date	2002.04.04.23.16.22;	author jason;	state Exp;
branches;
next	1.17;

1.17
date	2002.04.04.17.03.00;	author jason;	state Exp;
branches;
next	1.16;

1.16
date	2002.03.14.03.16.00;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2002.03.14.01.26.44;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2002.02.05.18.34.39;	author jason;	state Exp;
branches;
next	1.13;

1.13
date	2002.01.31.18.27.26;	author jason;	state Exp;
branches;
next	1.12;

1.12
date	2002.01.30.23.58.02;	author jason;	state Exp;
branches;
next	1.11;

1.11
date	2002.01.29.20.33.19;	author jason;	state Exp;
branches;
next	1.10;

1.10
date	2002.01.10.00.06.17;	author nordin;	state Exp;
branches;
next	1.9;

1.9
date	2001.12.14.14.55.57;	author jason;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2001.10.15.03.36.16;	author jason;	state Exp;
branches
	1.8.4.1;
next	1.7;

1.7
date	2001.09.27.20.45.34;	author jason;	state Exp;
branches;
next	1.6;

1.6
date	2001.09.26.22.16.55;	author jason;	state Exp;
branches;
next	1.5;

1.5
date	2001.09.26.19.34.54;	author jason;	state Exp;
branches;
next	1.4;

1.4
date	2001.09.04.15.06.15;	author jason;	state Exp;
branches;
next	1.3;

1.3
date	2001.09.01.17.12.19;	author jason;	state Exp;
branches;
next	1.2;

1.2
date	2001.08.29.04.59.57;	author jason;	state Exp;
branches;
next	1.1;

1.1
date	2001.08.22.12.05.10;	author art;	state Exp;
branches;
next	;

1.8.4.1
date	2001.10.31.03.07.58;	author nate;	state Exp;
branches;
next	1.8.4.2;

1.8.4.2
date	2002.03.06.02.04.46;	author niklas;	state Exp;
branches;
next	1.8.4.3;

1.8.4.3
date	2002.03.28.11.23.51;	author niklas;	state Exp;
branches;
next	1.8.4.4;

1.8.4.4
date	2003.03.27.23.42.35;	author niklas;	state Exp;
branches;
next	1.8.4.5;

1.8.4.5
date	2003.06.07.11.14.44;	author ho;	state Exp;
branches;
next	1.8.4.6;

1.8.4.6
date	2004.02.19.10.49.59;	author niklas;	state Exp;
branches;
next	;

1.9.2.1
date	2002.01.31.22.55.23;	author niklas;	state Exp;
branches;
next	1.9.2.2;

1.9.2.2
date	2002.06.11.03.38.43;	author art;	state Exp;
branches;
next	1.9.2.3;

1.9.2.3
date	2002.10.29.00.28.11;	author art;	state Exp;
branches;
next	1.9.2.4;

1.9.2.4
date	2003.05.19.21.46.57;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.74
log
@Convert %q to %ll in format strings

ok natano@@ krw@@
@
text
@/*	$OpenBSD: psycho.c,v 1.73 2014/07/12 22:37:03 uebayasi Exp $	*/
/*	$NetBSD: psycho.c,v 1.39 2001/10/07 20:30:41 eeh Exp $	*/

/*
 * Copyright (c) 1999, 2000 Matthew R. Green
 * Copyright (c) 2003 Henric Jungheim
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Support for `psycho' and `psycho+' UPA to PCI bridge and 
 * UltraSPARC IIi and IIe `sabre' PCI controllers.
 */

#include <sys/param.h>
#include <sys/device.h>
#include <sys/errno.h>
#include <sys/extent.h>
#include <sys/malloc.h>
#include <sys/systm.h>
#include <sys/time.h>
#include <sys/timetc.h>

#include <uvm/uvm_extern.h>

#define _SPARC_BUS_DMA_PRIVATE
#include <machine/bus.h>
#include <machine/autoconf.h>
#include <machine/openfirm.h>
#include <machine/psl.h>

#include <dev/pci/pcivar.h>
#include <dev/pci/pcireg.h>

#include <sparc64/dev/iommureg.h>
#include <sparc64/dev/iommuvar.h>
#include <sparc64/dev/psychoreg.h>
#include <sparc64/dev/psychovar.h>
#include <sparc64/dev/starfire.h>
#include <sparc64/sparc64/cache.h>

#ifdef DEBUG
#define PDB_PROM	0x01
#define PDB_BUSMAP	0x02
#define PDB_INTR	0x04
#define PDB_CONF	0x08
int psycho_debug = ~0;
#define DPRINTF(l, s)   do { if (psycho_debug & l) printf s; } while (0)
#else
#define DPRINTF(l, s)
#endif

pci_chipset_tag_t psycho_alloc_chipset(struct psycho_pbm *, int,
    pci_chipset_tag_t);
void psycho_get_bus_range(int, int *);
void psycho_get_ranges(int, struct psycho_ranges **, int *);
void psycho_set_intr(struct psycho_softc *, int, void *, 
    u_int64_t *, u_int64_t *, const char *);
bus_space_tag_t psycho_alloc_bus_tag(struct psycho_pbm *,
    const char *, int, int, int);

/* Interrupt handlers */
int psycho_ue(void *);
int psycho_ce(void *);
int psycho_bus_a(void *);
int psycho_bus_b(void *);
int psycho_bus_error(struct psycho_softc *, int);
int psycho_powerfail(void *);
int psycho_wakeup(void *);

/* IOMMU support */
void psycho_iommu_init(struct psycho_softc *, int);

/*
 * bus space and bus dma support for UltraSPARC `psycho'.  note that most
 * of the bus dma support is provided by the iommu dvma controller.
 */
int psycho_bus_map(bus_space_tag_t, bus_space_tag_t, bus_addr_t,
    bus_size_t, int, bus_space_handle_t *);
paddr_t psycho_bus_mmap(bus_space_tag_t, bus_space_tag_t, bus_addr_t, off_t,
    int, int);
bus_addr_t psycho_bus_addr(bus_space_tag_t, bus_space_tag_t,
    bus_space_handle_t);
void *psycho_intr_establish(bus_space_tag_t, bus_space_tag_t, int, int, int,
    int (*)(void *), void *, const char *);

int psycho_dmamap_create(bus_dma_tag_t, bus_dma_tag_t, bus_size_t, int,
    bus_size_t, bus_size_t, int, bus_dmamap_t *);
void psycho_sabre_dvmamap_sync(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t,
    bus_size_t, bus_size_t, int);
void psycho_map_psycho(struct psycho_softc *, int, bus_addr_t, bus_size_t,
    bus_addr_t, bus_size_t);
int psycho_intr_map(struct pci_attach_args *, pci_intr_handle_t *);
void psycho_identify_pbm(struct psycho_softc *sc, struct psycho_pbm *pp,
    struct pcibus_attach_args *pa);

int psycho_conf_size(pci_chipset_tag_t, pcitag_t);
pcireg_t psycho_conf_read(pci_chipset_tag_t, pcitag_t, int);
void psycho_conf_write(pci_chipset_tag_t, pcitag_t, int, pcireg_t);

/* base pci_chipset */
extern struct sparc_pci_chipset _sparc_pci_chipset;

u_int stick_get_timecount(struct timecounter *);

struct timecounter stick_timecounter = {
	stick_get_timecount, NULL, ~0u, 0, "stick", 1000, NULL
};

/*
 * autoconfiguration
 */
int	psycho_match(struct device *, void *, void *);
void	psycho_attach(struct device *, struct device *, void *);
int	psycho_print(void *aux, const char *p);


struct cfattach psycho_ca = {
        sizeof(struct psycho_softc), psycho_match, psycho_attach
};

struct cfdriver psycho_cd = {
	NULL, "psycho", DV_DULL
};

/*
 * "sabre" is the UltraSPARC IIi onboard UPA to PCI bridge.  It manages a
 * single PCI bus and does not have a streaming buffer.  It often has an APB
 * (advanced PCI bridge) connected to it, which was designed specifically for
 * the IIi.  The APB let's the IIi handle two independednt PCI buses, and
 * appears as two "simba"'s underneath the sabre.
 *
 * "psycho" and "psycho+" is a dual UPA to PCI bridge.  It sits on the UPA bus
 * and manages two PCI buses.  "psycho" has two 64-bit 33MHz buses, while
 * "psycho+" controls both a 64-bit 33MHz and a 64-bit 66MHz PCI bus.  You
 * will usually find a "psycho+" since I don't think the original "psycho"
 * ever shipped, and if it did it would be in the U30.  
 *
 * Each "psycho" PCI bus appears as a separate OFW node, but since they are
 * both part of the same IC, they only have a single register space.  As such,
 * they need to be configured together, even though the autoconfiguration will
 * attach them separately.
 *
 * On UltraIIi machines, "sabre" itself usually takes pci0, with "simba" often
 * as pci1 and pci2, although they have been implemented with other PCI bus
 * numbers on some machines.
 *
 * On UltraII machines, there can be any number of "psycho+" ICs, each
 * providing two PCI buses.  
 *
 *
 * XXXX The psycho/sabre node has an `interrupts' attribute.  They contain
 * the values of the following interrupts in this order:
 *
 * PCI Bus Error	(30)
 * DMA UE		(2e)
 * DMA CE		(2f)
 * Power Fail		(25)
 *
 * We really should attach handlers for each.
 *
 */
#define	ROM_PCI_NAME		"pci"

struct psycho_type {
	char *p_name;
	int p_type;
} psycho_types[] = {
	{ "SUNW,psycho",        PSYCHO_MODE_PSYCHO      },
	{ "pci108e,8000",       PSYCHO_MODE_PSYCHO      },
	{ "SUNW,sabre",         PSYCHO_MODE_SABRE       },
	{ "pci108e,a000",       PSYCHO_MODE_SABRE       },
	{ "pci108e,a001",       PSYCHO_MODE_SABRE       },
	{ "pci10cf,138f",	PSYCHO_MODE_CMU_CH	},
	{ "pci10cf,1390",	PSYCHO_MODE_CMU_CH	},
	{ NULL, 0 }
};

int
psycho_match(struct device *parent, void *match, void *aux)
{
	struct mainbus_attach_args *ma = aux;
	struct psycho_type *ptype;
	char *str;

	/* match on a name of "pci" and a sabre or a psycho */
	if (strcmp(ma->ma_name, ROM_PCI_NAME) != 0)
		return (0);

	for (ptype = psycho_types; ptype->p_name != NULL; ptype++) {
		str = getpropstring(ma->ma_node, "model");
		if (strcmp(str, ptype->p_name) == 0)
			return (1);
		str = getpropstring(ma->ma_node, "compatible");
		if (strcmp(str, ptype->p_name) == 0)
			return (1);
	}
	return (0);
}

/*
 * SUNW,psycho initialization ...
 *	- find the per-psycho registers
 *	- figure out the IGN.
 *	- find our partner psycho
 *	- configure ourselves
 *	- bus range, bus, 
 *	- get interrupt-map and interrupt-map-mask
 *	- setup the chipsets.
 *	- if we're the first of the pair, initialise the IOMMU, otherwise
 *	  just copy its tags and addresses.
 */
void
psycho_attach(struct device *parent, struct device *self, void *aux)
{
	struct psycho_softc *sc = (struct psycho_softc *)self;
	struct psycho_softc *osc = NULL;
	struct psycho_pbm *pp;
	struct pcibus_attach_args pba;
	struct mainbus_attach_args *ma = aux;
	u_int64_t csr;
	int psycho_br[2], n;
	struct psycho_type *ptype;
	char buf[32];
	u_int stick_rate;

	sc->sc_node = ma->ma_node;
	sc->sc_bustag = ma->ma_bustag;
	sc->sc_dmatag = ma->ma_dmatag;

	/*
	 * call the model-specific initialization routine.
	 */

	for (ptype = psycho_types; ptype->p_name != NULL; ptype++) {
		char *str;

		str = getpropstring(ma->ma_node, "model");
		if (strcmp(str, ptype->p_name) == 0)
			break;
		str = getpropstring(ma->ma_node, "compatible");
		if (strcmp(str, ptype->p_name) == 0)
			break;
	}
	if (ptype->p_name == NULL)
		panic("psycho_attach: unknown model?");
	sc->sc_mode = ptype->p_type;

	/*
	 * The psycho gets three register banks:
	 * (0) per-PBM configuration and status registers
	 * (1) per-PBM PCI configuration space, containing only the
	 *     PBM 256-byte PCI header
	 * (2) the shared psycho configuration registers (struct psychoreg)
	 *
	 * XXX use the prom address for the psycho registers?  we do so far.
	 */

	/* Register layouts are different.  stuupid. */
	if (sc->sc_mode == PSYCHO_MODE_PSYCHO ||
	    sc->sc_mode == PSYCHO_MODE_CMU_CH) {
		sc->sc_basepaddr = (paddr_t)ma->ma_reg[2].ur_paddr;

		if (ma->ma_naddress > 2) {
			psycho_map_psycho(sc, 0,
			    ma->ma_address[2], sizeof(struct psychoreg),
			    ma->ma_address[0], sizeof(struct pci_ctl));
		} else if (ma->ma_nreg > 2) {
			psycho_map_psycho(sc, 1,
			    ma->ma_reg[2].ur_paddr, ma->ma_reg[2].ur_len,
			    ma->ma_reg[0].ur_paddr, ma->ma_reg[0].ur_len);
		} else
			panic("psycho_attach: %d not enough registers",
			    ma->ma_nreg);
	} else {
		sc->sc_basepaddr = (paddr_t)ma->ma_reg[0].ur_paddr;

		if (ma->ma_naddress) {
			psycho_map_psycho(sc, 0,
			    ma->ma_address[0], sizeof(struct psychoreg),
			    ma->ma_address[0] +
				offsetof(struct psychoreg, psy_pcictl[0]),
			    sizeof(struct pci_ctl));
		} else if (ma->ma_nreg) {
			psycho_map_psycho(sc, 1,
			    ma->ma_reg[0].ur_paddr, ma->ma_reg[0].ur_len,
			    ma->ma_reg[0].ur_paddr +
				offsetof(struct psychoreg, psy_pcictl[0]),
			    sizeof(struct pci_ctl));
		} else
			panic("psycho_attach: %d not enough registers",
			    ma->ma_nreg);
	}

	csr = psycho_psychoreg_read(sc, psy_csr);
	sc->sc_ign = INTMAP_IGN; /* APB IGN is always 0x1f << 6 = 0x7c */
	if (sc->sc_mode == PSYCHO_MODE_PSYCHO ||
	    sc->sc_mode == PSYCHO_MODE_CMU_CH)
		sc->sc_ign = PSYCHO_GCSR_IGN(csr) << 6;

	printf(": %s, impl %d, version %d, ign %x\n", ptype->p_name,
	    PSYCHO_GCSR_IMPL(csr), PSYCHO_GCSR_VERS(csr), sc->sc_ign);

	/*
	 * Match other psycho's that are already configured against
	 * the base physical address. This will be the same for a
	 * pair of devices that share register space.
	 */
	for (n = 0; n < psycho_cd.cd_ndevs; n++) {
		struct psycho_softc *asc =
		    (struct psycho_softc *)psycho_cd.cd_devs[n];

		if (asc == NULL || asc == sc)
			/* This entry is not there or it is me */
			continue;

		if (asc->sc_basepaddr != sc->sc_basepaddr)
			/* This is an unrelated psycho */
			continue;

		/* Found partner */
		osc = asc;
		break;
	}

	/* Oh, dear.  OK, lets get started */

	/*
	 * Setup the PCI control register
	 */
	csr = psycho_pcictl_read(sc, pci_csr);
	csr |= PCICTL_MRLM | PCICTL_ARB_PARK | PCICTL_ERRINTEN |
	    PCICTL_4ENABLE;
	csr &= ~(PCICTL_SERR | PCICTL_CPU_PRIO | PCICTL_ARB_PRIO |
	    PCICTL_RTRYWAIT);
	psycho_pcictl_write(sc, pci_csr, csr);

	/*
	 * Allocate our psycho_pbm
	 */
	pp = sc->sc_psycho_this = malloc(sizeof *pp, M_DEVBUF,
		M_NOWAIT | M_ZERO);
	if (pp == NULL)
		panic("could not allocate psycho pbm");

	pp->pp_sc = sc;

	/* grab the psycho ranges */
	psycho_get_ranges(sc->sc_node, &pp->pp_range, &pp->pp_nrange);

	/* get the bus-range for the psycho */
	psycho_get_bus_range(sc->sc_node, psycho_br);

	bzero(&pba, sizeof(pba));
	pba.pba_domain = pci_ndomains++;
	pba.pba_bus = psycho_br[0];

	printf("%s: bus range %u-%u, PCI bus %d\n", sc->sc_dev.dv_xname,
	    psycho_br[0], psycho_br[1], psycho_br[0]);

	pp->pp_pcictl = sc->sc_pcictl;

	/* allocate our tags */
	pp->pp_memt = psycho_alloc_mem_tag(pp);
	pp->pp_iot = psycho_alloc_io_tag(pp);
	if (sc->sc_mode == PSYCHO_MODE_CMU_CH)
		pp->pp_dmat = ma->ma_dmatag;
	else
		pp->pp_dmat = psycho_alloc_dma_tag(pp);
	pp->pp_flags = (pp->pp_memt ? PCI_FLAGS_MEM_ENABLED : 0) |
	                (pp->pp_iot ? PCI_FLAGS_IO_ENABLED  : 0);

	/* allocate a chipset for this */
	pp->pp_pc = psycho_alloc_chipset(pp, sc->sc_node, &_sparc_pci_chipset);

	/* setup the rest of the psycho pbm */
	pba.pba_pc = pp->pp_pc;

	/*
	 * And finally, if we're a sabre or the first of a pair of psycho's to
	 * arrive here, start up the IOMMU and get a config space tag.
	 */

	if (osc == NULL) {
		uint64_t timeo;

		/* Initialize Starfire PC interrupt translation. */
		if (OF_getprop(findroot(), "name", buf, sizeof(buf)) > 0 &&
		    strcmp(buf, "SUNW,Ultra-Enterprise-10000") == 0)
			starfire_pc_ittrans_init(ma->ma_upaid);

		/*
		 * Establish handlers for interesting interrupts....
		 *
		 * XXX We need to remember these and remove this to support
		 * hotplug on the UPA/FHC bus.
		 *
		 * XXX Not all controllers have these, but installing them
		 * is better than trying to sort through this mess.
		 */
		psycho_set_intr(sc, 15, psycho_ue,
		    psycho_psychoreg_vaddr(sc, ue_int_map),
		    psycho_psychoreg_vaddr(sc, ue_clr_int), "ue");
		if (sc->sc_mode == PSYCHO_MODE_PSYCHO ||
		    sc->sc_mode == PSYCHO_MODE_SABRE) {
			psycho_set_intr(sc, 1, psycho_ce,
			    psycho_psychoreg_vaddr(sc, ce_int_map),
			    psycho_psychoreg_vaddr(sc, ce_clr_int), "ce");
			psycho_set_intr(sc, 15, psycho_bus_a,
			    psycho_psychoreg_vaddr(sc, pciaerr_int_map),
			    psycho_psychoreg_vaddr(sc, pciaerr_clr_int),
			    "bus_a");
		}
#if 0
		psycho_set_intr(sc, 15, psycho_powerfail,
		    psycho_psychoreg_vaddr(sc, power_int_map),
		    psycho_psychoreg_vaddr(sc, power_clr_int), "powerfail");
#endif
		if (sc->sc_mode == PSYCHO_MODE_PSYCHO ||
		    sc->sc_mode == PSYCHO_MODE_CMU_CH) {
			psycho_set_intr(sc, 15, psycho_bus_b,
			    psycho_psychoreg_vaddr(sc, pciberr_int_map),
			    psycho_psychoreg_vaddr(sc, pciberr_clr_int),
			    "bus_b");
		}
		if (sc->sc_mode == PSYCHO_MODE_PSYCHO) {
			psycho_set_intr(sc, 1, psycho_wakeup,
			    psycho_psychoreg_vaddr(sc, pwrmgt_int_map),
			    psycho_psychoreg_vaddr(sc, pwrmgt_clr_int),
			    "wakeup");
		}

		/*
		 * Apparently a number of machines with psycho and psycho+
		 * controllers have interrupt latency issues.  We'll try
		 * setting the interrupt retry timeout to 0xff which gives us
		 * a retry of 3-6 usec (which is what sysio is set to) for the
		 * moment, which seems to help alleviate this problem.
		 */
		timeo = psycho_psychoreg_read(sc, intr_retry_timer);
		if (timeo > 0xfff) {
#ifdef DEBUG
			printf("decreasing interrupt retry timeout "
			    "from %lx to 0xff\n", (long)timeo);
#endif
			psycho_psychoreg_write(sc, intr_retry_timer, 0xff);
		}

		/*
		 * Setup IOMMU and PCI configuration if we're the first
		 * of a pair of psycho's to arrive here.
		 *
		 * We should calculate a TSB size based on the amount of RAM,
		 * number of bus controllers, and number and type of child
		 * devices.
		 *
		 * For the moment, 32KB should be more than enough.
		 */
		sc->sc_is = malloc(sizeof(struct iommu_state),
			M_DEVBUF, M_NOWAIT | M_ZERO);
		if (sc->sc_is == NULL)
			panic("psycho_attach: malloc iommu_state");

		if (getproplen(sc->sc_node, "no-streaming-cache") < 0) {
			struct strbuf_ctl *sb = &pp->pp_sb;
			vaddr_t va = (vaddr_t)&pp->pp_flush[0x40];

			/*
			 * Initialize the strbuf_ctl.
			 *
			 * The flush sync buffer must be 64-byte aligned.
			 */

			sb->sb_flush = (void *)(va & ~0x3f);

			sb->sb_bustag = sc->sc_bustag;
			if (bus_space_subregion(sc->sc_bustag, sc->sc_pcictl,
			    offsetof(struct pci_ctl, pci_strbuf),
			    sizeof(struct iommu_strbuf),
			    &sb->sb_sb)) {
				printf("STC0 subregion failed\n");
				sb->sb_flush = 0;
			}
		}

		/* Point out iommu at the strbuf_ctl. */
		sc->sc_is->is_sb[0] = &pp->pp_sb;

		/* CMU-CH doesn't have an IOMMU. */
		if (sc->sc_mode != PSYCHO_MODE_CMU_CH) {
			printf("%s: ", sc->sc_dev.dv_xname);
			psycho_iommu_init(sc, 2);
		}

		sc->sc_configtag = psycho_alloc_config_tag(sc->sc_psycho_this);
		if (bus_space_map(sc->sc_configtag,
		    sc->sc_basepaddr, 0x01000000, 0, &sc->sc_configaddr))
			panic("can't map psycho PCI configuration space");
	} else {
		/* Just copy IOMMU state, config tag and address */
		sc->sc_is = osc->sc_is;
		sc->sc_configtag = osc->sc_configtag;
		sc->sc_configaddr = osc->sc_configaddr;

		if (getproplen(sc->sc_node, "no-streaming-cache") < 0) {
			struct strbuf_ctl *sb = &pp->pp_sb;
			vaddr_t va = (vaddr_t)&pp->pp_flush[0x40];

			/*
			 * Initialize the strbuf_ctl.
			 *
			 * The flush sync buffer must be 64-byte aligned.
			 */

			sb->sb_flush = (void *)(va & ~0x3f);

			sb->sb_bustag = sc->sc_bustag;
			if (bus_space_subregion(sc->sc_bustag, sc->sc_pcictl,
			    offsetof(struct pci_ctl, pci_strbuf),
			    sizeof(struct iommu_strbuf),
			    &sb->sb_sb)) {
				printf("STC1 subregion failed\n");
				sb->sb_flush = 0;
			}

			/* Point out iommu at the strbuf_ctl. */
			sc->sc_is->is_sb[1] = sb;
		}

		/* Point out iommu at the strbuf_ctl. */
		sc->sc_is->is_sb[1] = &pp->pp_sb;

		printf("%s: ", sc->sc_dev.dv_xname);
		printf("dvma map %x-%x", sc->sc_is->is_dvmabase,
		    sc->sc_is->is_dvmaend);
#ifdef DEBUG
		printf(", iotdb %llx-%llx",
		    (unsigned long long)sc->sc_is->is_ptsb,
		    (unsigned long long)(sc->sc_is->is_ptsb +
		    (PAGE_SIZE << sc->sc_is->is_tsbsize)));
#endif
		iommu_reset(sc->sc_is);
		printf("\n");
	}

	/*
	 * The UltraSPARC IIe has new STICK logic that provides a
	 * timebase counter that doesn't scale with processor
	 * frequency.  Use it to provide a timecounter.
	 */
	stick_rate = getpropint(findroot(), "stick-frequency", 0);
	if (stick_rate > 0 && sc->sc_mode == PSYCHO_MODE_SABRE) {
		stick_timecounter.tc_frequency = stick_rate;
		stick_timecounter.tc_priv = sc;
		tc_init(&stick_timecounter);
	}

	/*
	 * attach the pci.. note we pass PCI A tags, etc., for the sabre here.
	 */
	pba.pba_busname = "pci";
#if 0
	pba.pba_flags = sc->sc_psycho_this->pp_flags;
#endif
	pba.pba_dmat = sc->sc_psycho_this->pp_dmat;
	pba.pba_iot = sc->sc_psycho_this->pp_iot;
	pba.pba_memt = sc->sc_psycho_this->pp_memt;
	pba.pba_pc->bustag = sc->sc_configtag;
	pba.pba_pc->bushandle = sc->sc_configaddr;
	pba.pba_pc->conf_size = psycho_conf_size;
	pba.pba_pc->conf_read = psycho_conf_read;
	pba.pba_pc->conf_write = psycho_conf_write;
	pba.pba_pc->intr_map = psycho_intr_map;

	if (sc->sc_mode == PSYCHO_MODE_PSYCHO ||
	    sc->sc_mode == PSYCHO_MODE_CMU_CH)
		psycho_identify_pbm(sc, pp, &pba);
	else
		pp->pp_id = PSYCHO_PBM_UNKNOWN;

	config_found(self, &pba, psycho_print);
}

void
psycho_identify_pbm(struct psycho_softc *sc, struct psycho_pbm *pp,
    struct pcibus_attach_args *pa)
{
	vaddr_t pci_va = (vaddr_t)bus_space_vaddr(sc->sc_bustag, sc->sc_pcictl);
	paddr_t pci_pa;

	if (pmap_extract(pmap_kernel(), pci_va, &pci_pa) == 0)
	    pp->pp_id = PSYCHO_PBM_UNKNOWN;
	else switch(pci_pa & 0xffff) {
		case 0x2000:
			pp->pp_id = PSYCHO_PBM_A;
			break;
		case 0x4000:
			pp->pp_id = PSYCHO_PBM_B;
			break;
		default:
			pp->pp_id = PSYCHO_PBM_UNKNOWN;
			break;
	}
}

void
psycho_map_psycho(struct psycho_softc* sc, int do_map, bus_addr_t reg_addr,
    bus_size_t reg_size, bus_addr_t pci_addr, bus_size_t pci_size)
{
	if (do_map) {
		if (bus_space_map(sc->sc_bustag,
		    reg_addr, reg_size, 0, &sc->sc_regsh))
			panic("psycho_attach: cannot map regs");

		if (pci_addr >= reg_addr &&
		    pci_addr + pci_size <= reg_addr + reg_size) {
			if (bus_space_subregion(sc->sc_bustag, sc->sc_regsh,
			    pci_addr - reg_addr, pci_size, &sc->sc_pcictl))
				panic("psycho_map_psycho: map ctl");
		}
		else if (bus_space_map(sc->sc_bustag, pci_addr, pci_size,
		    0, &sc->sc_pcictl))
			panic("psycho_map_psycho: cannot map pci");
	} else {
		if (bus_space_map(sc->sc_bustag, reg_addr, reg_size,
		    BUS_SPACE_MAP_PROMADDRESS, &sc->sc_regsh))
			panic("psycho_map_psycho: cannot map ctl");
		if (bus_space_map(sc->sc_bustag, pci_addr, pci_size,
		    BUS_SPACE_MAP_PROMADDRESS, &sc->sc_pcictl))
			panic("psycho_map_psycho: cannot map pci");
	}
}

int
psycho_print(void *aux, const char *p)
{
	if (p == NULL)
		return (UNCONF);
	return (QUIET);
}

void
psycho_set_intr(struct psycho_softc *sc, int ipl, void *handler,
    u_int64_t *mapper, u_int64_t *clearer, const char *suffix)
{
	struct intrhand *ih;

	ih = malloc(sizeof(*ih), M_DEVBUF, M_NOWAIT | M_ZERO);
	if (ih == NULL)
		panic("couldn't malloc intrhand");
	ih->ih_arg = sc;
	ih->ih_map = mapper;
	ih->ih_clr = clearer;
	ih->ih_fun = handler;
	ih->ih_pil = (1 << ipl);
	ih->ih_number = INTVEC(*(ih->ih_map));
	snprintf(ih->ih_name, sizeof(ih->ih_name),
	    "%s:%s", sc->sc_dev.dv_xname, suffix);

	DPRINTF(PDB_INTR, (
	    "\ninstalling handler %p arg %p for %s with number %x pil %u",
	    ih->ih_fun, ih->ih_arg, sc->sc_dev.dv_xname, ih->ih_number,
	    ih->ih_pil));

	intr_establish(ipl, ih);
}

/*
 * PCI bus support
 */

/*
 * allocate a PCI chipset tag and set its cookie.
 */
pci_chipset_tag_t
psycho_alloc_chipset(struct psycho_pbm *pp, int node, pci_chipset_tag_t pc)
{
	pci_chipset_tag_t npc;
	
	npc = malloc(sizeof *npc, M_DEVBUF, M_NOWAIT);
	if (npc == NULL)
		panic("could not allocate pci_chipset_tag_t");
	memcpy(npc, pc, sizeof *pc);
	npc->cookie = pp;
	npc->rootnode = node;

	return (npc);
}

/*
 * grovel the OBP for various psycho properties
 */
void
psycho_get_bus_range(node, brp)
	int node;
	int *brp;
{
	int n, error;

	error = getprop(node, "bus-range", sizeof(*brp), &n, (void **)&brp);
	if (error)
		panic("could not get psycho bus-range, error %d", error);
	if (n != 2)
		panic("broken psycho bus-range");
	DPRINTF(PDB_PROM,
	    ("psycho debug: got `bus-range' for node %08x: %u - %u\n",
	    node, brp[0], brp[1]));
}

void
psycho_get_ranges(int node, struct psycho_ranges **rp, int *np)
{

	if (getprop(node, "ranges", sizeof(**rp), np, (void **)rp))
		panic("could not get psycho ranges");
	DPRINTF(PDB_PROM,
	    ("psycho debug: got `ranges' for node %08x: %d entries\n",
	    node, *np));
}

/*
 * Interrupt handlers.
 */

int
psycho_ue(void *arg)
{
	struct psycho_softc *sc = arg;
	unsigned long long afsr = psycho_psychoreg_read(sc, psy_ue_afsr);
	unsigned long long afar = psycho_psychoreg_read(sc, psy_ue_afar);

	/*
	 * It's uncorrectable.  Dump the regs and panic.
	 */
	panic("%s: uncorrectable DMA error AFAR %llx (pa=%lx tte=%llx/%llx) "
	    "AFSR %llx", sc->sc_dev.dv_xname, afar,
	    iommu_extract(sc->sc_is, (vaddr_t)afar),
	    iommu_lookup_tte(sc->sc_is, (vaddr_t)afar),
	    iommu_fetch_tte(sc->sc_is, (paddr_t)afar),
	    afsr);
	return (1);
}

int 
psycho_ce(void *arg)
{
	struct psycho_softc *sc = arg;
	u_int64_t afar, afsr;

	/*
	 * It's correctable.  Dump the regs and continue.
	 */

	afar = psycho_psychoreg_read(sc, psy_ce_afar);
	afsr = psycho_psychoreg_read(sc, psy_ce_afsr);

	printf("%s: correctable DMA error AFAR %llx AFSR %llx\n",
	    sc->sc_dev.dv_xname, afar, afsr);

	/* Clear error. */
	psycho_psychoreg_write(sc, psy_ce_afsr,
	    afsr & (PSY_CEAFSR_PDRD | PSY_CEAFSR_PDWR |
	    PSY_CEAFSR_SDRD | PSY_CEAFSR_SDWR));
			       
	return (1);
}

int
psycho_bus_error(struct psycho_softc *sc, int bus)
{
	u_int64_t afsr, afar, bits;

	afar = psycho_psychoreg_read(sc, psy_pcictl[bus].pci_afar);
	afsr = psycho_psychoreg_read(sc, psy_pcictl[bus].pci_afsr);

	bits = afsr & (PSY_PCIAFSR_PMA | PSY_PCIAFSR_PTA | PSY_PCIAFSR_PTRY |
	    PSY_PCIAFSR_PPERR | PSY_PCIAFSR_SMA | PSY_PCIAFSR_STA |
	    PSY_PCIAFSR_STRY | PSY_PCIAFSR_SPERR);

	if (bits == 0)
		return (0);

	/*
	 * It's uncorrectable.  Dump the regs and panic.
	 */
	printf("%s: PCI bus %c error AFAR %llx (pa=%llx) AFSR %llx\n",
	    sc->sc_dev.dv_xname, 'A' + bus, (long long)afar,
	    (long long)iommu_extract(sc->sc_is, (vaddr_t)afar),
	    (long long)afsr);

	psycho_psychoreg_write(sc, psy_pcictl[bus].pci_afsr, bits);
	return (1);
}

int 
psycho_bus_a(void *arg)
{
	struct psycho_softc *sc = arg;

	return (psycho_bus_error(sc, 0));
}

int 
psycho_bus_b(void *arg)
{
	struct psycho_softc *sc = arg;

	return (psycho_bus_error(sc, 1));
}

int 
psycho_powerfail(void *arg)
{
	/*
	 * We lost power.  Try to shut down NOW.
	 */
	panic("Power Failure Detected");
	/* NOTREACHED */
	return (1);
}

int
psycho_wakeup(void *arg)
{
	struct psycho_softc *sc = arg;

	/*
	 * Gee, we don't really have a framework to deal with this
	 * properly.
	 */
	printf("%s: power management wakeup\n",	sc->sc_dev.dv_xname);
	return (1);
}

/*
 * initialise the IOMMU..
 */
void
psycho_iommu_init(struct psycho_softc *sc, int tsbsize)
{
	struct iommu_state *is = sc->sc_is;
	int *vdma = NULL, nitem;
	u_int32_t iobase = -1;
	char *name;

	/* punch in our copies */
	is->is_bustag = sc->sc_bustag;
	bus_space_subregion(sc->sc_bustag, sc->sc_regsh,
	    offsetof(struct psychoreg, psy_iommu), sizeof(struct iommureg),
	    &is->is_iommu);

	/*
	 * Separate the men from the boys.  If it has a `virtual-dma'
	 * property, use it.
	 */
	if (!getprop(sc->sc_node, "virtual-dma", sizeof(vdma), &nitem, 
	    (void **)&vdma)) {
		/* Damn.  Gotta use these values. */
		iobase = vdma[0];
#define	TSBCASE(x)	case 1 << ((x) + 23): tsbsize = (x); break
		switch (vdma[1]) { 
			TSBCASE(1); TSBCASE(2); TSBCASE(3);
			TSBCASE(4); TSBCASE(5); TSBCASE(6);
		default: 
			printf("bogus tsb size %x, using 7\n", vdma[1]);
			TSBCASE(7);
		}
#undef TSBCASE
		DPRINTF(PDB_CONF, ("psycho_iommu_init: iobase=0x%x\n", iobase));
		free(vdma, M_DEVBUF, 0);
	} else {
		DPRINTF(PDB_CONF, ("psycho_iommu_init: getprop failed, "
		    "iobase=0x%x, tsbsize=%d\n", iobase, tsbsize));
	}

	/* give us a nice name.. */
	name = (char *)malloc(32, M_DEVBUF, M_NOWAIT);
	if (name == NULL)
		panic("couldn't malloc iommu name");
	snprintf(name, 32, "%s dvma", sc->sc_dev.dv_xname);

	iommu_init(name, is, tsbsize, iobase);
}

/*
 * below here is bus space and bus dma support
 */

bus_space_tag_t
psycho_alloc_mem_tag(struct psycho_pbm *pp)
{
	return (psycho_alloc_bus_tag(pp, "mem",
	    0x02,	/* 32-bit mem space (where's the #define???) */
	    ASI_PRIMARY, ASI_PRIMARY_LITTLE));
}

bus_space_tag_t
psycho_alloc_io_tag(struct psycho_pbm *pp)
{
	return (psycho_alloc_bus_tag(pp, "io",
	    0x01,	/* IO space (where's the #define???) */
	    ASI_PHYS_NON_CACHED_LITTLE, ASI_PHYS_NON_CACHED));
}

bus_space_tag_t
psycho_alloc_config_tag(struct psycho_pbm *pp)
{
	return (psycho_alloc_bus_tag(pp, "cfg",
	    0x00,	/* Config space (where's the #define???) */
	    ASI_PHYS_NON_CACHED_LITTLE, ASI_PHYS_NON_CACHED));
}

bus_space_tag_t
psycho_alloc_bus_tag(struct psycho_pbm *pp,
    const char *name, int ss, int asi, int sasi)
{
	struct psycho_softc *sc = pp->pp_sc;
	struct sparc_bus_space_tag *bt;

	bt = malloc(sizeof(*bt), M_DEVBUF, M_NOWAIT | M_ZERO);
	if (bt == NULL)
		panic("could not allocate psycho bus tag");

	snprintf(bt->name, sizeof(bt->name), "%s-pbm_%s(%d-%2.2x)",
	    sc->sc_dev.dv_xname, name, ss, asi); 

	bt->cookie = pp;
	bt->parent = sc->sc_bustag;
	bt->default_type = ss;
	bt->asi = asi;
	bt->sasi = sasi;
	bt->sparc_bus_map = psycho_bus_map;
	bt->sparc_bus_mmap = psycho_bus_mmap;
	bt->sparc_bus_addr = psycho_bus_addr;
	bt->sparc_intr_establish = psycho_intr_establish;

	return (bt);
}

bus_dma_tag_t
psycho_alloc_dma_tag(struct psycho_pbm *pp)
{
	struct psycho_softc *sc = pp->pp_sc;
	bus_dma_tag_t dt, pdt = sc->sc_dmatag;

	dt = (bus_dma_tag_t)malloc(sizeof(struct sparc_bus_dma_tag),
	    M_DEVBUF, M_NOWAIT | M_ZERO);
	if (dt == NULL)
		panic("could not allocate psycho dma tag");

	dt->_cookie = pp;
	dt->_parent = pdt;
	dt->_dmamap_create	= psycho_dmamap_create;
	dt->_dmamap_destroy	= iommu_dvmamap_destroy;
	dt->_dmamap_load	= iommu_dvmamap_load;
	dt->_dmamap_load_raw	= iommu_dvmamap_load_raw;
	dt->_dmamap_unload	= iommu_dvmamap_unload;
	if (sc->sc_mode == PSYCHO_MODE_PSYCHO)
		dt->_dmamap_sync = iommu_dvmamap_sync;
	else
		dt->_dmamap_sync = psycho_sabre_dvmamap_sync;
	dt->_dmamem_alloc	= iommu_dvmamem_alloc;
	dt->_dmamem_free	= iommu_dvmamem_free;

	return (dt);
}

/*
 * bus space support.  <sparc64/dev/psychoreg.h> has a discussion about
 * PCI physical addresses.
 */

int
psycho_bus_map(bus_space_tag_t t, bus_space_tag_t t0, bus_addr_t offset,
    bus_size_t size, int flags, bus_space_handle_t *hp)
{
	struct psycho_pbm *pp = t->cookie;
	int i, ss;

	DPRINTF(PDB_BUSMAP, ("\npsycho_bus_map: type %d off %llx sz %llx "
	    "flags %d", t->default_type, (unsigned long long)offset,
	    (unsigned long long)size, flags));

	ss = t->default_type;
	DPRINTF(PDB_BUSMAP, (" cspace %d", ss));

	if (t->parent == 0 || t->parent->sparc_bus_map == 0) {
		printf("\npsycho_bus_map: invalid parent");
		return (EINVAL);
	}

	t = t->parent;

	if (flags & BUS_SPACE_MAP_PROMADDRESS) {
		return ((*t->sparc_bus_map)
		    (t, t0, offset, size, flags, hp));
	}

	for (i = 0; i < pp->pp_nrange; i++) {
		bus_addr_t paddr;

		if (((pp->pp_range[i].cspace >> 24) & 0x03) != ss)
			continue;

		paddr = pp->pp_range[i].phys_lo + offset;
		paddr |= ((bus_addr_t)pp->pp_range[i].phys_hi) << 32;
		DPRINTF(PDB_BUSMAP,
		    ("\n_psycho_bus_map: mapping paddr space %lx offset %lx "
			"paddr %llx",
		    (long)ss, (long)offset,
		    (unsigned long long)paddr));
		return ((*t->sparc_bus_map)(t, t0, paddr, size, flags, hp));
	}
	DPRINTF(PDB_BUSMAP, (" FAILED\n"));
	return (EINVAL);
}

paddr_t
psycho_bus_mmap(bus_space_tag_t t, bus_space_tag_t t0, bus_addr_t paddr,
    off_t off, int prot, int flags)
{
	bus_addr_t offset = paddr;
	struct psycho_pbm *pp = t->cookie;
	int i, ss;

	ss = t->default_type;

	DPRINTF(PDB_BUSMAP, ("\n_psycho_bus_mmap: prot %d flags %d pa %llx",
	    prot, flags, (unsigned long long)paddr));

	if (t->parent == 0 || t->parent->sparc_bus_mmap == 0) {
		printf("\npsycho_bus_mmap: invalid parent");
		return (-1);
	}

	t = t->parent;

	for (i = 0; i < pp->pp_nrange; i++) {
		bus_addr_t paddr;

		if (((pp->pp_range[i].cspace >> 24) & 0x03) != ss)
			continue;

		paddr = pp->pp_range[i].phys_lo + offset;
		paddr |= ((bus_addr_t)pp->pp_range[i].phys_hi) << 32;
		DPRINTF(PDB_BUSMAP, ("\npsycho_bus_mmap: mapping paddr "
		    "space %lx offset %lx paddr %llx",
		    (long)ss, (long)offset,
		    (unsigned long long)paddr));
		return ((*t->sparc_bus_mmap)(t, t0, paddr, off, prot, flags));
	}

	return (-1);
}

bus_addr_t
psycho_bus_addr(bus_space_tag_t t, bus_space_tag_t t0, bus_space_handle_t h)
{
	struct psycho_pbm *pp = t->cookie;
	bus_addr_t addr;
	int i, ss;

	ss = t->default_type;

	if (t->parent == 0 || t->parent->sparc_bus_addr == 0) {
		printf("\npsycho_bus_addr: invalid parent");
		return (-1);
	}

	t = t->parent;

	addr = ((*t->sparc_bus_addr)(t, t0, h));
	if (addr == -1)
		return (-1);

	for (i = 0; i < pp->pp_nrange; i++) {
		if (((pp->pp_range[i].cspace >> 24) & 0x03) != ss)
			continue;

		return (BUS_ADDR_PADDR(addr) - pp->pp_range[i].phys_lo);
	}

	return (-1);
}

int
psycho_conf_size(pci_chipset_tag_t pc, pcitag_t tag)
{
	return PCI_CONFIG_SPACE_SIZE;
}

pcireg_t
psycho_conf_read(pci_chipset_tag_t pc, pcitag_t tag, int reg)
{
	struct cpu_info *ci = curcpu();
	pcireg_t val;
	int s;

	s = splhigh();
	membar(Sync);
	ci->ci_pci_probe = 1;
	val = bus_space_read_4(pc->bustag, pc->bushandle,
	    PCITAG_OFFSET(tag) + reg);
	membar(Sync);
	if (ci->ci_pci_fault)
		val = 0xffffffff;
	ci->ci_pci_probe = ci->ci_pci_fault = 0;
	splx(s);

	return (val);
}

void
psycho_conf_write(pci_chipset_tag_t pc, pcitag_t tag, int reg, pcireg_t data)
{
        bus_space_write_4(pc->bustag, pc->bushandle,
	    PCITAG_OFFSET(tag) + reg, data);
}

/*
 * Bus-specific interrupt mapping
 */ 
int
psycho_intr_map(struct pci_attach_args *pa, pci_intr_handle_t *ihp)
{
	struct psycho_pbm *pp = pa->pa_pc->cookie;
	struct psycho_softc *sc = pp->pp_sc;
	u_int dev;

	if (*ihp != (pci_intr_handle_t)-1) {
		*ihp |= sc->sc_ign;
		return (0);
	}

	/*
	 * We didn't find a PROM mapping for this interrupt.  Try to
	 * construct one ourselves based on the swizzled interrupt pin
	 * and the interrupt mapping for PCI slots documented in the
	 * UltraSPARC-IIi User's Manual.
	 */

	if (pa->pa_intrpin == 0)
		return (-1);

	/*
	 * This deserves some documentation.  Should anyone
	 * have anything official looking, please speak up.
	 */
	if (sc->sc_mode == PSYCHO_MODE_PSYCHO &&
	    pp->pp_id == PSYCHO_PBM_B)
		dev = PCITAG_DEV(pa->pa_intrtag) - 2;
	else
		dev = PCITAG_DEV(pa->pa_intrtag) - 1;

	*ihp = (pa->pa_intrpin - 1) & INTMAP_PCIINT;
	*ihp |= ((pp->pp_id == PSYCHO_PBM_B) ? INTMAP_PCIBUS : 0);
	*ihp |= (dev << 2) & INTMAP_PCISLOT;
	*ihp |= sc->sc_ign;

	return (0);
}

/*
 * install an interrupt handler for a PCI device
 */
void *
psycho_intr_establish(bus_space_tag_t t, bus_space_tag_t t0, int ihandle,
    int level, int flags, int (*handler)(void *), void *arg, const char *what)
{
	struct psycho_pbm *pp = t->cookie;
	struct psycho_softc *sc = pp->pp_sc;
	struct intrhand *ih;
	volatile u_int64_t *intrmapptr = NULL, *intrclrptr = NULL;
	int64_t intrmap = 0;
	int ino;
	long vec = INTVEC(ihandle); 

	/*
	 * Hunt through all the interrupt mapping regs to look for our
	 * interrupt vector.
	 *
	 * XXX We only compare INOs rather than IGNs since the firmware may
	 * not provide the IGN and the IGN is constant for all device on that
	 * PCI controller.  This could cause problems for the FFB/external
	 * interrupt which has a full vector that can be set arbitrarily.  
	 */

	DPRINTF(PDB_INTR,
	    ("\npsycho_intr_establish: ihandle %x vec %lx", ihandle, vec));
	ino = INTINO(vec);
	DPRINTF(PDB_INTR, (" ino %x", ino));

	/* If the device didn't ask for an IPL, use the one encoded. */
	if (level == IPL_NONE)
		level = INTLEV(vec);
	/* If it still has no level, print a warning and assign IPL 2 */
	if (level == IPL_NONE) {
		printf("ERROR: no IPL, setting IPL 2.\n");
		level = 2;
	}

	if (flags & BUS_INTR_ESTABLISH_SOFTINTR)
		goto found;

	DPRINTF(PDB_INTR,
	    ("\npsycho: intr %lx: %p\nHunting for IRQ...\n",
	    (long)ino, intrlev[ino]));

	/* 
	 * First look for PCI interrupts, otherwise the PCI A slot 0
	 * INTA# interrupt might match an unused non-PCI (obio)
	 * interrupt.
	 */

	for (intrmapptr = psycho_psychoreg_vaddr(sc, pcia_slot0_int),
	    intrclrptr = psycho_psychoreg_vaddr(sc, pcia0_clr_int[0]);
	    intrmapptr <= (volatile u_int64_t *)
		psycho_psychoreg_vaddr(sc, pcib_slot3_int);
	    intrmapptr++, intrclrptr += 4) {
		/* Skip PCI-A Slot 2 and PCI-A Slot 3 on psycho's */
		if (sc->sc_mode == PSYCHO_MODE_PSYCHO &&
		    (intrmapptr ==
			psycho_psychoreg_vaddr(sc, pcia_slot2_int) ||
		    intrmapptr ==
			psycho_psychoreg_vaddr(sc, pcia_slot3_int)))
			continue;

		if (((*intrmapptr ^ vec) & 0x3c) == 0) {
			intrclrptr += vec & 0x3;
			goto found;
		}
	}

	/* Now hunt through obio.  */
	for (intrmapptr = psycho_psychoreg_vaddr(sc, scsi_int_map),
	    intrclrptr = psycho_psychoreg_vaddr(sc, scsi_clr_int);
	    intrmapptr < (volatile u_int64_t *)
		psycho_psychoreg_vaddr(sc, ffb0_int_map);
	    intrmapptr++, intrclrptr++) {
		if (INTINO(*intrmapptr) == ino)
			goto found;
	}

	printf("Cannot find interrupt vector %lx\n", vec);
	return (NULL);

found:
	ih = bus_intr_allocate(t0, handler, arg, ino | sc->sc_ign, level,
	    intrmapptr, intrclrptr, what);
	if (ih == NULL) {
		printf("Cannot allocate interrupt vector %lx\n", vec);
		return (NULL);
	}

	DPRINTF(PDB_INTR, (
	    "\ninstalling handler %p arg %p with number %x pil %u",
	    ih->ih_fun, ih->ih_arg, ih->ih_number, ih->ih_pil));

	if (flags & BUS_INTR_ESTABLISH_MPSAFE)
		ih->ih_mpsafe = 1;

	intr_establish(ih->ih_pil, ih);

	/*
	 * Enable the interrupt now we have the handler installed.
	 * Read the current value as we can't change it besides the
	 * valid bit so so make sure only this bit is changed.
	 *
	 * XXXX --- we really should use bus_space for this.
	 */
	if (intrmapptr) {
		intrmap = *intrmapptr;
		DPRINTF(PDB_INTR, ("; read intrmap = %016llx",
			(unsigned long long)intrmap));

		/* Enable the interrupt */
		intrmap |= INTMAP_V;
		DPRINTF(PDB_INTR, ("; addr of intrmapptr = %p", intrmapptr));
		DPRINTF(PDB_INTR, ("; writing intrmap = %016llx",
			(unsigned long long)intrmap));
		*intrmapptr = intrmap;
		DPRINTF(PDB_INTR, ("; reread intrmap = %016llx",
			(unsigned long long)(intrmap = *intrmapptr)));
	}
	return (ih);
}

/*
 * hooks into the iommu dvma calls.
 */
int
psycho_dmamap_create(bus_dma_tag_t t, bus_dma_tag_t t0, bus_size_t size,
    int nsegments, bus_size_t maxsegsz, bus_size_t boundary, int flags,
    bus_dmamap_t *dmamp)
{
	struct psycho_pbm *pp = t->_cookie;

	return (iommu_dvmamap_create(t, t0, &pp->pp_sb, size, nsegments,
	    maxsegsz, boundary, flags, dmamp));
}

void
psycho_sabre_dvmamap_sync(bus_dma_tag_t t, bus_dma_tag_t t0, bus_dmamap_t map,
    bus_size_t offset, bus_size_t len, int ops)
{
	struct psycho_pbm *pp = t->_cookie;
	struct psycho_softc *sc = pp->pp_sc;

	if (ops & BUS_DMASYNC_POSTREAD)
		psycho_psychoreg_read(sc, pci_dma_write_sync);

	if (ops & (BUS_DMASYNC_POSTREAD | BUS_DMASYNC_PREWRITE))
		membar(MemIssue);
}

u_int
stick_get_timecount(struct timecounter *tc)
{
	struct psycho_softc *sc = tc->tc_priv;

	return psycho_psychoreg_read(sc, stick_reg_low);
}
@


1.73
log
@reboot(9), panic(9): Call panic(9) for unrecoverable MD H/W errors (NMIs)

Some architectures have ability to detect hardware sanity and notify system
(NMI, firmware callback, etc.).  Handle these hardware severe errors, same
as software errors, with panic(9).

According to miod@@, SGI IP27 NMI is triggered by pushing some "hidden" button,
which "usual" users/admins don't know.  Pushing such a button is "RB_USERREQ"
(human-triggered) in that the button is pushed by a human, but not "RB_USERREQ"
in that no user intervention in system (== no command input) is done.  miod@@
agreed that changing these from RB_USERREQ to !RB_USERREQ (== panic(9)) is
not a big problem.

OK miod@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d1003 1
a1003 1
	DPRINTF(PDB_BUSMAP, ("\npsycho_bus_map: type %d off %qx sz %qx "
d1032 1
a1032 1
			"paddr %qx",
d1051 1
a1051 1
	DPRINTF(PDB_BUSMAP, ("\n_psycho_bus_mmap: prot %d flags %d pa %qx",
d1070 1
a1070 1
		    "space %lx offset %lx paddr %qx",
d1296 1
a1296 1
		DPRINTF(PDB_INTR, ("; read intrmap = %016qx",
d1302 1
a1302 1
		DPRINTF(PDB_INTR, ("; writing intrmap = %016qx",
d1305 1
a1305 1
		DPRINTF(PDB_INTR, ("; reread intrmap = %016qx",
@


1.72
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: psycho.c,v 1.71 2014/07/12 14:12:44 uebayasi Exp $	*/
a45 1
#include <sys/reboot.h>
d840 2
a841 2
	printf("Power Failure Detected: Shutting down NOW.\n");
	reboot(RB_POWERDOWN | RB_HALT);
@


1.71
log
@boot(9), reboot(9): Migrate MD callers of boot(9) to reboot(9)

I have found that some ports call boot(9) from machine-dependent code to
reboot system.  These should be changed to either:

- Sending signal to init(8) to trigger it to shutdown system cleanly, like
  acpi(4) does, in cases where found problems don't prevent system from working
  immediately, or

- Just doing panic(9) if the situation is severely broken.

For now, just rewrite boot() to reboot().  Actual fixes follow.

Discussed with & OK from kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d894 1
a894 1
		free(vdma, M_DEVBUF);
@


1.70
log
@Add support for BUS_INTR_ESTABLISH_MPSAFE.
@
text
@d1 1
a1 1
/*	$OpenBSD: psycho.c,v 1.69 2011/07/06 23:43:14 kettenis Exp $	*/
d842 1
a842 1
	boot(RB_POWERDOWN|RB_HALT);
@


1.69
log
@Handle pci_conf_read() faults on reading non-existent registers that result
in master aborts.  Return 0xffffffff to emulate what happens on non-perfect
architectures in that case.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: psycho.c,v 1.68 2011/06/26 20:32:36 kettenis Exp $	*/
d1282 3
@


1.68
log
@Fix some inconsistencies in how we build 64-bit addresses from OF properties.
@
text
@d1 1
a1 1
/*	$OpenBSD: psycho.c,v 1.67 2010/12/04 17:06:32 miod Exp $	*/
d1119 16
a1134 2
	return (bus_space_read_4(pc->bustag, pc->bushandle,
	    PCITAG_OFFSET(tag) + reg));
@


1.67
log
@Introduce a new pci routine, pci_conf_size(), which returns the size of a
given pcitag_t configuration address space. Currently, all pci controllers
will return the usual 0x100 bytes of PCI configuration space, but this will
eventually change on PCIe-capable controlers.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: psycho.c,v 1.66 2009/03/29 22:52:11 kettenis Exp $	*/
d1030 1
a1030 1
		paddr |= ((bus_addr_t)pp->pp_range[i].phys_hi << 32);
d1069 1
a1069 1
		paddr |= ((bus_addr_t)pp->pp_range[i].phys_hi << 32);
@


1.66
log
@bzero pci attach args

ok deraadt@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: psycho.c,v 1.65 2009/03/29 21:53:52 sthen Exp $	*/
d121 1
d594 1
d1110 5
@


1.65
log
@make various strings ("can't map mem space" and similar) more consistent
between instances, saving space in the kernel. feedback from many (some
incorporated, some left for future work).

ok deraadt, kettenis, "why not" miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: psycho.c,v 1.64 2009/01/02 20:01:45 kettenis Exp $	*/
d377 1
a379 1
	pba.pba_bridgetag = NULL;
@


1.64
log
@Make IOMMU code use the generic _bus_dmamem_map() and _bus_dmamem_unmap().
@
text
@d1 1
a1 1
/*	$OpenBSD: psycho.c,v 1.63 2008/11/25 16:31:19 kettenis Exp $	*/
d521 1
a521 1
			panic("could not map psycho PCI configuration space");
@


1.63
log
@Fix dmesg ugliness caused by not printing iotdb stuff.
@
text
@d1 1
a1 1
/*	$OpenBSD: psycho.c,v 1.62 2008/07/23 12:18:40 kettenis Exp $	*/
a985 2
	dt->_dmamem_map		= iommu_dvmamem_map;
	dt->_dmamem_unmap	= iommu_dvmamem_unmap;
@


1.62
log
@Clear correctable errors after handling them.  From Bjorn Andersson.
@
text
@d1 1
a1 1
/*	$OpenBSD: psycho.c,v 1.61 2008/07/20 10:37:43 kettenis Exp $	*/
d557 1
a557 1
		printf("dvma map %x-%x, ", sc->sc_is->is_dvmabase,
d559 2
a560 1
		printf("iotdb %llx-%llx",
d564 1
@


1.61
log
@Provide a timecounter based on the UltraSPARC IIe STICK logic.
@
text
@d1 1
a1 1
/*	$OpenBSD: psycho.c,v 1.60 2008/07/12 10:07:25 kettenis Exp $	*/
d768 1
d774 3
d778 7
a784 3
	    sc->sc_dev.dv_xname, 
	    (long long)psycho_psychoreg_read(sc, psy_ce_afar),
	    (long long)psycho_psychoreg_read(sc, psy_ce_afsr));
@


1.60
log
@Don't install interrupt handlers for non-exitsing interrupts on CMU-CH.
@
text
@d1 1
a1 1
/*	$OpenBSD: psycho.c,v 1.59 2008/06/02 19:39:08 kettenis Exp $	*/
d45 1
d127 6
d248 1
d568 12
d1306 8
@


1.59
log
@No need to enable the interrupt in psycho_set_intr(); intr_establish() already
does that for us.
@
text
@d1 1
a1 1
/*	$OpenBSD: psycho.c,v 1.58 2008/05/24 23:31:37 kettenis Exp $	*/
d419 10
a428 6
		psycho_set_intr(sc, 1, psycho_ce,
		    psycho_psychoreg_vaddr(sc, ce_int_map),
		    psycho_psychoreg_vaddr(sc, ce_clr_int), "ce");
		psycho_set_intr(sc, 15, psycho_bus_a,
		    psycho_psychoreg_vaddr(sc, pciaerr_int_map),
		    psycho_psychoreg_vaddr(sc, pciaerr_clr_int), "bus_a");
d440 2
@


1.58
log
@Found some documentation that suggests that CMU-CH doesn't have an IOMMU and
streaming cache, so don't try to initialize it.
@
text
@d1 1
a1 1
/*	$OpenBSD: psycho.c,v 1.57 2008/05/24 20:57:46 kettenis Exp $	*/
a659 1
	*(ih->ih_map) |= INTMAP_V;
@


1.57
log
@Add Psycho variants found on the SPARC Enterprise M4000/M5000/M8000/M9000.
@
text
@d1 1
a1 1
/*	$OpenBSD: psycho.c,v 1.56 2008/03/16 22:19:57 kettenis Exp $	*/
d190 2
a191 2
	{ "pci10cf,138f",	PSYCHO_MODE_PSYCHO	},
	{ "pci10cf,1390",	PSYCHO_MODE_PSYCHO	},
d275 2
a276 1
	if (sc->sc_mode == PSYCHO_MODE_PSYCHO) {
d312 2
a313 1
	if (sc->sc_mode == PSYCHO_MODE_PSYCHO)
d381 4
a384 1
	pp->pp_dmat = psycho_alloc_dma_tag(pp);
d430 2
a431 1
		if (sc->sc_mode == PSYCHO_MODE_PSYCHO) {
d498 5
a502 2
		printf("%s: ", sc->sc_dev.dv_xname);
		psycho_iommu_init(sc, 2);
d569 2
a570 1
	if (sc->sc_mode == PSYCHO_MODE_PSYCHO)
@


1.56
log
@Set up interrupt translation for e10k.
@
text
@d1 1
a1 1
/*	$OpenBSD: psycho.c,v 1.55 2008/01/19 11:13:43 kettenis Exp $	*/
d190 2
@


1.55
log
@Make host bridges provide their own implementation of pci_conf_read() and
pci_conf_write() and give pyro(4) an implementation suitable for PCIe.  For
psycho(4) and schizo(4), go back to the origional implementation.  This gets
rid of the 'tagshift' member of pci_chipset_tag_t, and clears the way for
sun4v.
@
text
@d1 1
a1 1
/*	$OpenBSD: psycho.c,v 1.54 2007/10/08 18:30:13 krw Exp $	*/
d52 1
d62 1
d238 1
d394 5
@


1.54
log
@A few trailing bzero/memset -> M_ZERO occurrences, cast removal and
size(*p) usage. This should be the last of the simple malloc()
changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: psycho.c,v 1.53 2007/09/08 10:50:04 martin Exp $	*/
d118 3
d546 2
d1055 15
a1261 1

@


1.53
log
@use M_ZERO.

input from kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: psycho.c,v 1.52 2007/08/04 16:44:15 kettenis Exp $	*/
d617 1
a617 2
	ih = (struct intrhand *)malloc(sizeof(struct intrhand),
	    M_DEVBUF, M_NOWAIT);
a619 1
	memset(ih, 0, sizeof(struct intrhand));
@


1.52
log
@Add sparc_bus_addr member to struct sparc_bus_space_tag.  This function maps
a bus_space_handle_t back to a bus_addr_t.  Needed for rbus.
Only implemented for mainbus(4) and psycho(4) for now; schizo(4) and pyro(4)
will follow soon.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: psycho.c,v 1.51 2007/04/10 17:47:55 miod Exp $	*/
d346 2
a347 1
	pp = sc->sc_psycho_this = malloc(sizeof *pp, M_DEVBUF, M_NOWAIT);
a350 2
	memset(pp, 0, sizeof *pp);

d450 1
a450 1
			M_DEVBUF, M_NOWAIT);
a453 2
		memset(sc->sc_is, 0, sizeof *sc->sc_is);

d884 1
a884 1
	bt = malloc(sizeof(*bt), M_DEVBUF, M_NOWAIT);
a887 2
	bzero(bt, sizeof *bt);
	
d911 1
a911 1
	    M_DEVBUF, M_NOWAIT);
a914 1
	bzero(dt, sizeof *dt);
@


1.51
log
@``it's'' -> ``its'' when the grammar gods require this change.
@
text
@d1 1
a1 1
/*	$OpenBSD: psycho.c,v 1.50 2007/01/26 16:53:28 tsi Exp $	*/
d80 1
a80 1
bus_space_tag_t _psycho_alloc_bus_tag(struct psycho_pbm *,
d99 2
d103 2
a104 2
int _psycho_bus_map(bus_space_tag_t, bus_space_tag_t, bus_addr_t,
    bus_size_t, int, bus_space_handle_t *);
d859 1
a859 1
	return (_psycho_alloc_bus_tag(pp, "mem",
d867 1
a867 1
	return (_psycho_alloc_bus_tag(pp, "io",
d875 1
a875 1
	return (_psycho_alloc_bus_tag(pp, "cfg",
d881 1
a881 1
_psycho_alloc_bus_tag(struct psycho_pbm *pp,
d901 1
a901 1
	bt->sparc_bus_map = _psycho_bus_map;
d903 1
d946 1
a946 1
_psycho_bus_map(bus_space_tag_t t, bus_space_tag_t t0, bus_addr_t offset,
d952 1
a952 1
	DPRINTF(PDB_BUSMAP, ("\n_psycho_bus_map: type %d off %qx sz %qx "
d960 1
a960 1
		printf("\n_psycho_bus_map: invalid parent");
d1004 1
a1004 1
		printf("\n_psycho_bus_mmap: invalid parent");
d1018 1
a1018 1
		DPRINTF(PDB_BUSMAP, ("\n_psycho_bus_mmap: mapping paddr "
d1023 30
@


1.50
log
@Deal with zero wraparound in DVMA range checks;
Fix default DVMA range for Schizo's with no "virtual-dma" property;
Add TSB size indicator to Schizo & Psycho debugging messages.

ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: psycho.c,v 1.49 2006/12/24 01:25:01 deraadt Exp $	*/
d218 1
a218 1
 *	  just copy it's tags and addresses.
d646 1
a646 1
 * allocate a PCI chipset tag and set it's cookie.
@


1.49
log
@change schizo/psycho interrupts to be xname:what instead of ugly names
seen previously; discussed with kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: psycho.c,v 1.48 2006/12/14 17:36:12 kettenis Exp $	*/
d838 1
a838 1
		    "iobase=0x%x\n", iobase));
@


1.48
log
@Make pci subsystem aware of domains.  Each host bridge gets assigned a unique
domain number such that we can distinguish between busses with the same bus
number that are behind different host bridges.  Domains can be accessed by
using different device nodes.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: psycho.c,v 1.47 2006/07/01 16:41:26 deraadt Exp $	*/
d630 1
a630 1
	    "%s_%s", sc->sc_dev.dv_xname, suffix);
@


1.47
log
@clean dmesg output for iommu more; tested miod dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: psycho.c,v 1.46 2006/07/01 13:57:50 kettenis Exp $	*/
d358 1
@


1.46
log
@Make sure we don't accidentally match one of the unused PCI error interrupts
instead the interrupt for PCI slot 0.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: psycho.c,v 1.45 2006/06/28 20:09:15 deraadt Exp $	*/
d361 1
a361 1
	printf("%s: bus range %u-%u, PCI bus %d", sc->sc_dev.dv_xname,
d479 1
a479 1
		printf(", ");
a480 1
		printf("\n");
d520 1
a520 1
		printf(", ");
d527 1
a528 1
		iommu_reset(sc->sc_is);
@


1.45
log
@cleanup dmesg logging for iommu goo, make it follow the standard form
@
text
@d1 1
a1 1
/*	$OpenBSD: psycho.c,v 1.44 2006/06/27 21:22:14 kettenis Exp $	*/
a1092 1

d1114 5
a1118 9
	/* Hunt thru obio first */
	for (intrmapptr = psycho_psychoreg_vaddr(sc, scsi_int_map),
	    intrclrptr = psycho_psychoreg_vaddr(sc, scsi_clr_int);
	    intrmapptr < (volatile u_int64_t *)
		psycho_psychoreg_vaddr(sc, ffb0_int_map);
	    intrmapptr++, intrclrptr++) {
		if (INTINO(*intrmapptr) == ino)
			goto found;
	}
a1119 1
	/* Now do PCI interrupts */
d1138 11
@


1.44
log
@Fix interrupt mapping.  This now seems to work on all machines, even with
pci cards that have a pci-pci bridge and lack fcode.

tested by many, ok jason@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: psycho.c,v 1.43 2006/03/19 02:43:38 brad Exp $	*/
a231 2
	printf("\n");

d304 1
a304 1
	printf("%s: impl %d, version %d: ign %x ", ptype->p_name,
d361 2
a362 2
	printf("bus range %u to %u", psycho_br[0], psycho_br[1]);
	printf("; PCI bus %d", psycho_br[0]);
a378 2
	printf("\n");

d479 1
d481 1
d521 8
a805 1
	char *name;
d807 1
d809 1
a809 2
	int *vdma = NULL;
	int nitem;
d818 2
a819 6
	 * Separate the men from the boys.  Get the `virtual-dma'
	 * property for sabre and use that to make sure the damn
	 * iommu works.
	 *
	 * We could query the `#virtual-dma-size-cells' and
	 * `#virtual-dma-addr-cells' and DTRT, but I'm lazy.
d822 1
a822 1
		(void **)&vdma)) {
d836 1
a836 2
	}
	else {
@


1.43
log
@rev 1.86

make the "generic" PCI bus enumeration code the standard case which
gets used if nothing else is defined in MD headers,
introduce a "PCI_MACHDEP_ENUMERATE_BUS" CPP definition which can
be used by MD headers (just 1 port atm) to plug in special code

rev 1.62

* Implement a machine-dependent pci_enumerate_bus() for sparc64 which
  uses OFW device nodes to enumerate the bus.  When a PCI bus that is
  behind a bridge is attached, pci_attach_hook() allocates a new PCI
  chipset tag for the new bus and sets it's "curnode" to the OFW node
  of the bridge.  This is used as a starting point when enumerating
  that bus.  Root busses get the OFW node of the host bridge (psycho).

rev 1.59

Split the code that enumerates the PCI bus and that actually probes
for a device into two functions:

* pci_probe_device() actually probes/attaches the device specified
  by the provide pcitag_t.

* pci_enumerate_bus() enumerates the bus, and calls pci_probe_device()
  for each device on the bus.  A pci_enumerate_bus_generic() is provided
  which implements the old method of doing this: If something found at
  dev0/func0, determine number of functions and probe each one.

From NetBSD

ok kettenis@@

Tested on a good number of amd64/i386/macppc/sparc64 systems
@
text
@d1 1
a1 1
/*	$OpenBSD: psycho.c,v 1.42 2006/03/13 20:10:49 brad Exp $	*/
a1033 1
	u_int ino;
d1035 14
a1048 1
	ino = *ihp;
d1050 14
a1063 20
	if ((ino & ~INTMAP_PCIINT) == 0) {
		/*
		 * This deserves some documentation.  Should anyone
		 * have anything official looking, please speak up.
		 */
		if (sc->sc_mode == PSYCHO_MODE_PSYCHO &&
		    pp->pp_id == PSYCHO_PBM_B)
			dev = pa->pa_device - 2;
		else
			dev = pa->pa_device - 1;

		if (ino == 0 || ino > 4) {
			u_int32_t intreg;

			intreg = pci_conf_read(pa->pa_pc, pa->pa_tag,
			     PCI_INTERRUPT_REG);
			
			ino = PCI_INTERRUPT_PIN(intreg) - 1;
		} else
			ino -= 1;
a1064 9
		ino &= INTMAP_PCIINT;
				
		ino |= sc->sc_ign;
		ino |= ((pp->pp_id == PSYCHO_PBM_B) ? INTMAP_PCIBUS : 0);
		ino |= (dev << 2) & INTMAP_PCISLOT;
			
		*ihp = ino;
	}
  
@


1.42
log
@* Add "pcitag_t *pba_bridgetag" to pci_attach_args.  This is set to
  NULL for root PCI busses.  For busses behind a bridge, it points to
  a persistent copy of the bridge's pcitag_t.  This can be very useful
  for machine-dependent PCI bus enumeration code.

From NetBSD

ok grange@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: psycho.c,v 1.41 2005/06/06 20:31:12 jason Exp $	*/
a652 1
	npc->curnode = node;
@


1.41
log
@-no need to hang onto virtual-dma parameter from prom, free it
-formatting nits
@
text
@d1 1
a1 1
/*	$OpenBSD: psycho.c,v 1.40 2005/01/27 21:17:50 miod Exp $	*/
d361 1
@


1.40
log
@Fill all fields of intrhand structures not created by bus_intr_allocate().
@
text
@d1 1
a1 1
/*	$OpenBSD: psycho.c,v 1.39 2004/12/18 03:05:24 brad Exp $	*/
d834 1
d892 1
a892 1
	    	sc->sc_dev.dv_xname, name, ss, asi); 
d912 2
a913 2
	dt = (bus_dma_tag_t)
		malloc(sizeof(struct sparc_bus_dma_tag), M_DEVBUF, M_NOWAIT);
@


1.39
log
@Print error codes in panic message.

From NetBSD

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: psycho.c,v 1.38 2003/12/20 20:08:17 miod Exp $	*/
d79 1
a79 1
    u_int64_t *, u_int64_t *);
d401 1
a401 1
		    psycho_psychoreg_vaddr(sc, ue_clr_int));
d404 1
a404 1
		    psycho_psychoreg_vaddr(sc, ce_clr_int));
d407 1
a407 1
		    psycho_psychoreg_vaddr(sc, pciaerr_clr_int));
d411 1
a411 1
		    psycho_psychoreg_vaddr(sc, power_clr_int));
d416 2
a417 1
			    psycho_psychoreg_vaddr(sc, pciberr_clr_int));
d420 2
a421 1
			    psycho_psychoreg_vaddr(sc, pwrmgt_clr_int));
d607 1
a607 1
    u_int64_t *mapper, u_int64_t *clearer)
d615 1
d622 2
@


1.38
log
@Pass -Wformat
@
text
@d1 1
a1 1
/*	$OpenBSD: psycho.c,v 1.37 2003/06/24 21:54:39 henric Exp $	*/
d660 1
a660 1
	int n;
d662 3
a664 2
	if (getprop(node, "bus-range", sizeof(*brp), &n, (void **)&brp))
		panic("could not get psycho bus-range");
@


1.37
log
@Add a "where" argument to the sparc64 interrupt code.  This lets us
associate a name with each interrupt handler.  This is not visible
outside the kernel (yet).

ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: psycho.c,v 1.36 2003/06/11 03:16:12 henric Exp $	*/
d696 1
a696 1
	panic("%s: uncorrectable DMA error AFAR %llx (pa=%llx tte=%llx/%llx) "
@


1.36
log
@Much of the sbus, psycho, and schizo bus_dma code is the same, so let's
call the real implementation functions directly instead of duplicating
lots of code that only calls the real stuff anyway.

tested by miod@@ henning@@
ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: psycho.c,v 1.35 2003/06/04 23:26:12 henric Exp $	*/
d104 1
a104 1
    int (*)(void *), void *);
d1069 1
a1069 1
    int level, int flags, int (*handler)(void *), void *arg)
a1078 5
	ih = (struct intrhand *)
		malloc(sizeof(struct intrhand), M_DEVBUF, M_NOWAIT);
	if (ih == NULL)
		return (NULL);

d1104 2
a1105 1
	if ((flags & BUS_INTR_ESTABLISH_SOFTINTR) == 0) {
d1107 3
a1109 35
		DPRINTF(PDB_INTR,
		    ("\npsycho: intr %lx: %p\nHunting for IRQ...\n",
		    (long)ino, intrlev[ino]));

		/* Hunt thru obio first */
		for (intrmapptr = psycho_psychoreg_vaddr(sc, scsi_int_map),
		    intrclrptr = psycho_psychoreg_vaddr(sc, scsi_clr_int);
		    intrmapptr < (volatile u_int64_t *)
			psycho_psychoreg_vaddr(sc, ffb0_int_map);
		    intrmapptr++, intrclrptr++) {
			if (INTINO(*intrmapptr) == ino)
				goto found;
		}

		/* Now do PCI interrupts */
		for (intrmapptr = psycho_psychoreg_vaddr(sc, pcia_slot0_int),
		    intrclrptr = psycho_psychoreg_vaddr(sc, pcia0_clr_int[0]);
		    intrmapptr <= (volatile u_int64_t *)
			psycho_psychoreg_vaddr(sc, pcib_slot3_int);
		    intrmapptr++, intrclrptr += 4) {
			/* Skip PCI-A Slot 2 and PCI-A Slot 3 on psycho's */
			if (sc->sc_mode == PSYCHO_MODE_PSYCHO &&
			    (intrmapptr ==
				psycho_psychoreg_vaddr(sc, pcia_slot2_int) ||
			    intrmapptr ==
				psycho_psychoreg_vaddr(sc, pcia_slot3_int)))
				continue;

			if (((*intrmapptr ^ vec) & 0x3c) == 0) {
				intrclrptr += vec & 0x3;
				goto found;
			}
		}
		printf("Cannot find interrupt vector %lx\n", vec);
		return (NULL);
d1111 8
a1118 4
	found:
		/* Register the map and clear intr registers */
		ih->ih_map = intrmapptr;
		ih->ih_clr = intrclrptr;
a1119 3
#ifdef NOT_DEBUG
	if (psycho_debug & PDB_INTR) {
		long i;
d1121 12
a1132 1
		for (i = 0; i < 500000000; i++)
d1134 5
d1140 2
a1141 1
#endif
d1143 7
a1149 4
	ih->ih_fun = handler;
	ih->ih_arg = arg;
	ih->ih_pil = level;
	ih->ih_number = ino | sc->sc_ign;
@


1.35
log
@The IIi/e chips have a DMA sync register that we have been ignoring.  This
could lead to nasty races between PIO and DMA.

tested by krw@@
ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: psycho.c,v 1.34 2003/06/02 12:22:32 henric Exp $	*/
d106 2
a107 10
int psycho_dmamap_create(bus_dma_tag_t, bus_dma_tag_t, bus_size_t, int, bus_size_t,
    bus_size_t, int, bus_dmamap_t *);
void psycho_dvmamap_destroy(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t);
int psycho_dmamap_load(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t, void *,
    bus_size_t, struct proc *, int);
void psycho_dmamap_unload(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t);
int psycho_dmamap_load_raw(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t,
    bus_dma_segment_t *, int, bus_size_t, int);
void psycho_dmamap_sync(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t, bus_addr_t,
    bus_size_t, int);
a109 6
int psycho_dmamem_alloc(bus_dma_tag_t, bus_dma_tag_t, bus_size_t, bus_size_t, bus_size_t,
    bus_dma_segment_t *, int, int *, int);
void psycho_dmamem_free(bus_dma_tag_t, bus_dma_tag_t, bus_dma_segment_t *, int);
int psycho_dmamem_map(bus_dma_tag_t, bus_dma_tag_t, bus_dma_segment_t *, int, size_t,
    caddr_t *, int);
void psycho_dmamem_unmap(bus_dma_tag_t, bus_dma_tag_t, caddr_t, size_t);
d209 1
a209 1
 * SUNW,psycho initialisation ..
d475 1
d477 2
a478 3
			/* Point out iommu at the strbuf_ctl. */
			sc->sc_is->is_sb[0] = sb;
		}
d517 3
d913 5
a917 5
	dt->_dmamap_create = psycho_dmamap_create;
	dt->_dmamap_destroy = psycho_dvmamap_destroy;
	dt->_dmamap_load = psycho_dmamap_load;
	dt->_dmamap_load_raw = psycho_dmamap_load_raw;
	dt->_dmamap_unload = psycho_dmamap_unload;
d919 1
a919 1
		dt->_dmamap_sync = psycho_dmamap_sync;
d922 5
a926 4
	dt->_dmamem_alloc = psycho_dmamem_alloc;
	dt->_dmamem_free = psycho_dmamem_free;
	dt->_dmamem_map = psycho_dmamem_map;
	dt->_dmamem_unmap = psycho_dmamem_unmap;
a1204 40
	struct psycho_softc *sc = pp->pp_sc;

	return (iommu_dvmamap_create(t0, sc->sc_is, &pp->pp_sb, size,
	    nsegments, maxsegsz, boundary, flags, dmamp));
}

void
psycho_dvmamap_destroy(bus_dma_tag_t t, bus_dma_tag_t t0, bus_dmamap_t map)
{
	iommu_dvmamap_destroy(t0, map); 
}

int
psycho_dmamap_load(bus_dma_tag_t t, bus_dma_tag_t t0, bus_dmamap_t map,
    void *buf, bus_size_t buflen, struct proc *p, int flags)
{
	struct psycho_pbm *pp = t->_cookie;
	struct psycho_softc *sc = pp->pp_sc;

	if (pp->pp_sb.sb_flush == NULL)
		flags &= ~BUS_DMA_STREAMING;

	return (iommu_dvmamap_load(t0, sc->sc_is, map, buf, buflen, p, flags));
}

void
psycho_dmamap_unload(bus_dma_tag_t t, bus_dma_tag_t t0, bus_dmamap_t map)
{
	struct psycho_pbm *pp = t->_cookie;
	struct psycho_softc *sc = pp->pp_sc;

	iommu_dvmamap_unload(t0, sc->sc_is, map);
}

int
psycho_dmamap_load_raw(bus_dma_tag_t t, bus_dma_tag_t t0, bus_dmamap_t map,
    bus_dma_segment_t *segs, int nsegs, bus_size_t size, int flags)
{
	struct psycho_pbm *pp = t->_cookie;
	struct psycho_softc *sc = pp->pp_sc;
d1206 2
a1207 32
	if (pp->pp_sb.sb_flush == NULL)
		flags &= ~BUS_DMA_STREAMING;

	return (iommu_dvmamap_load_raw(t0, sc->sc_is, map, segs, nsegs, flags,
	    size));
}

void
psycho_dmamap_sync(bus_dma_tag_t t, bus_dma_tag_t t0, bus_dmamap_t map, bus_addr_t offset,
    bus_size_t len, int ops)
{
	struct psycho_pbm *pp = t->_cookie;
	struct psycho_softc *sc = pp->pp_sc;

	if (t->_parent == NULL)
		panic("psycho_dmamap_sync: no parent");
	
	for (t = t->_parent; t->_dmamap_sync == NULL; t = t->_parent)
		if (t == NULL)
			panic("psycho_dmamap_sync: can't find implementation");

	if (ops & (BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE)) {
		/* Flush the CPU then the IOMMU */
		(*t->_dmamap_sync)(t, t0, map, offset, len,
		    ops);
		iommu_dvmamap_sync(t0, sc->sc_is, map, offset, len, ops);
	}
	if (ops & (BUS_DMASYNC_POSTREAD|BUS_DMASYNC_POSTWRITE)) {
		/* Flush the IOMMU then the CPU */
		iommu_dvmamap_sync(t0, sc->sc_is, map, offset, len, ops);
		(*t->_dmamap_sync)(t, t0, map, offset, len, ops);
	}
a1221 41
}

int
psycho_dmamem_alloc(bus_dma_tag_t t, bus_dma_tag_t t0, bus_size_t size, bus_size_t alignment,
    bus_size_t boundary, bus_dma_segment_t *segs, int nsegs, int *rsegs,
    int flags)
{
	struct psycho_pbm *pp = t->_cookie;
	struct psycho_softc *sc = pp->pp_sc;

	return (iommu_dvmamem_alloc(t0, sc->sc_is, size, alignment, boundary,
	    segs, nsegs, rsegs, flags));
}

void
psycho_dmamem_free(bus_dma_tag_t t, bus_dma_tag_t t0, bus_dma_segment_t *segs, int nsegs)
{
	struct psycho_pbm *pp = t->_cookie;
	struct psycho_softc *sc = pp->pp_sc;

	iommu_dvmamem_free(t0, sc->sc_is, segs, nsegs);
}

int
psycho_dmamem_map(bus_dma_tag_t t, bus_dma_tag_t t0, bus_dma_segment_t *segs, int nsegs,
    size_t size, caddr_t *kvap, int flags)
{
	struct psycho_pbm *pp = t->_cookie;
	struct psycho_softc *sc = pp->pp_sc;

	return (iommu_dvmamem_map
	    (t0, sc->sc_is, segs, nsegs, size, kvap, flags));
}

void
psycho_dmamem_unmap(bus_dma_tag_t t, bus_dma_tag_t t0, caddr_t kva, size_t size)
{
	struct psycho_pbm *pp = t->_cookie;
	struct psycho_softc *sc = pp->pp_sc;

	iommu_dvmamem_unmap(t0, sc->sc_is, kva, size);
@


1.34
log
@Do not map psycho-only interrupts on sabres.  Reading from undefined
registers and mapping strange INRs is not a good idea.

ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: psycho.c,v 1.33 2003/05/30 00:15:36 henric Exp $	*/
d116 2
d929 4
a932 1
	dt->_dmamap_sync = psycho_dmamap_sync;
d1288 14
@


1.33
log
@Fix interrupt mapping for psycho's PBM B.  This should make interrupts
happy for all psycho based boxes.

tested by beck@@
ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: psycho.c,v 1.32 2003/05/16 17:18:14 jason Exp $	*/
a419 3
		psycho_set_intr(sc, 15, psycho_bus_b,
		    psycho_psychoreg_vaddr(sc, pciberr_int_map),
		    psycho_psychoreg_vaddr(sc, pciberr_clr_int));
d425 8
a432 3
		psycho_set_intr(sc, 1, psycho_wakeup,
		    psycho_psychoreg_vaddr(sc, pwrmgt_int_map),
		    psycho_psychoreg_vaddr(sc, pwrmgt_clr_int));
@


1.32
log
@move the interrupt idle stuff to the generic intr_establish function
@
text
@d1 1
a1 1
/*	$OpenBSD: psycho.c,v 1.31 2003/05/16 06:59:12 henric Exp $	*/
d1029 1
d1035 10
d1059 1
a1059 1
		ino |= ((pa->pa_device - 1) << 2) & INTMAP_PCISLOT;
@


1.31
log
@The sparc64 proms do not map all interrupt vectors.  Instead of
trying to use the interrupt pin (or is it that the PCI
function?) as the interrupt vector, this computes the vector
from the PCI bus, slot, and pin.  This will only change mappings
on psycho-based machines (*not* sabre, i.e., IIi/e) and only for
those vectors reported as nonsense INRs (INO 0-3).

This should fix the mapping of non-bridge expansion cards on U60
and E450, and other psycho boxen.  U30 seems to do its own
thing.
@
text
@d1 1
a1 1
/*	$OpenBSD: psycho.c,v 1.30 2003/03/25 22:10:19 jason Exp $	*/
a1183 4
	}
	if (intrclrptr) {
		/* set state to IDLE */
		*intrclrptr = 0;
@


1.30
log
@Clear interrupts (set to IDLE) as they are established.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: psycho.c,v 1.29 2003/03/06 08:26:08 henric Exp $	*/
d47 2
d124 3
d314 1
a314 1
	sc->sc_ign = 0x7c0; /* APB IGN is always 0x7c */
d542 6
d553 22
d1019 35
@


1.29
log
@The existing IOMMU code had a rounding problem that was most noticeable
on faster systems under heavy network load.  This replaces some of the
unreadable iommu functions with something a little less dense and a lot
less crash prone.

The bus_dma function pointer/cookie handling was broken.  Change them
to work like the stacked bus_space drivers (where "work" is the key
word).

Tested my many (thanks).

ok jason@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: psycho.c,v 1.28 2003/03/05 00:20:13 henric Exp $	*/
d1116 4
@


1.28
log
@Some typos prevented STCs from being detected and the size of the
PCI configuration space is actually one "0" larger.  Noticed on an
E450 with all 10 PCI slots populated.

ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: psycho.c,v 1.27 2003/02/17 01:29:20 henric Exp $	*/
d104 4
a107 1
int psycho_dmamap_load(bus_dma_tag_t, bus_dmamap_t, void *,
d109 2
a110 2
void psycho_dmamap_unload(bus_dma_tag_t, bus_dmamap_t);
int psycho_dmamap_load_raw(bus_dma_tag_t, bus_dmamap_t,
d112 1
a112 1
void psycho_dmamap_sync(bus_dma_tag_t, bus_dmamap_t, bus_addr_t,
d114 1
a114 1
int psycho_dmamem_alloc(bus_dma_tag_t, bus_size_t, bus_size_t, bus_size_t,
d116 2
a117 2
void psycho_dmamem_free(bus_dma_tag_t, bus_dma_segment_t *, int);
int psycho_dmamem_map(bus_dma_tag_t, bus_dma_segment_t *, int, size_t,
d119 1
a119 1
void psycho_dmamem_unmap(bus_dma_tag_t, caddr_t, size_t);
d477 1
d514 1
d521 1
d670 6
a675 3
	panic("%s: uncorrectable DMA error AFAR %llx (pa=%llx) AFSR %llx",
	    sc->sc_dev.dv_xname, afar,
	    (long long)iommu_extract(sc->sc_is, (vaddr_t)afar), afsr);
d887 2
a888 3
#define PCOPY(x)	dt->x = pdt->x
	PCOPY(_dmamap_create);
	PCOPY(_dmamap_destroy);
a889 2
	PCOPY(_dmamap_load_mbuf);
	PCOPY(_dmamap_load_uio);
a896 2
	PCOPY(_dmamem_mmap);
#undef	PCOPY
d1124 20
a1143 2
psycho_dmamap_load(bus_dma_tag_t t, bus_dmamap_t map, void *buf,
    bus_size_t buflen, struct proc *p, int flags)
d1148 4
a1151 1
	return (iommu_dvmamap_load(t, sc->sc_is, map, buf, buflen, p, flags));
d1155 1
a1155 1
psycho_dmamap_unload(bus_dma_tag_t t, bus_dmamap_t map)
d1160 1
a1160 1
	iommu_dvmamap_unload(t, sc->sc_is, map);
d1164 1
a1164 1
psycho_dmamap_load_raw(bus_dma_tag_t t, bus_dmamap_t map,
d1170 4
a1173 1
	return (iommu_dvmamap_load_raw(t, sc->sc_is, map, segs, nsegs, flags,
d1178 1
a1178 1
psycho_dmamap_sync(bus_dma_tag_t t, bus_dmamap_t map, bus_addr_t offset,
d1184 7
d1193 3
a1195 2
		bus_dmamap_sync(t->_parent, map, offset, len, ops);
		iommu_dvmamap_sync(t, sc->sc_is, map, offset, len, ops);
d1199 2
a1200 2
		iommu_dvmamap_sync(t, sc->sc_is, map, offset, len, ops);
		bus_dmamap_sync(t->_parent, map, offset, len, ops);
d1205 1
a1205 1
psycho_dmamem_alloc(bus_dma_tag_t t, bus_size_t size, bus_size_t alignment,
d1212 1
a1212 1
	return (iommu_dvmamem_alloc(t, sc->sc_is, size, alignment, boundary,
d1217 1
a1217 1
psycho_dmamem_free(bus_dma_tag_t t, bus_dma_segment_t *segs, int nsegs)
d1222 1
a1222 1
	iommu_dvmamem_free(t, sc->sc_is, segs, nsegs);
d1226 1
a1226 1
psycho_dmamem_map(bus_dma_tag_t t, bus_dma_segment_t *segs, int nsegs,
d1233 1
a1233 1
	    (t, sc->sc_is, segs, nsegs, size, kvap, flags));
d1237 1
a1237 1
psycho_dmamem_unmap(bus_dma_tag_t t, caddr_t kva, size_t size)
d1242 1
a1242 1
	iommu_dvmamem_unmap(t, sc->sc_is, kva, size);
@


1.27
log
@
Add support for the Sun Enterprise 450
Reduce the size of a GENERIC kernel by ~190k
Remove the nasty pointer/bus_space_handle_t casts
Adds debug bus_space code including the ability to trace
    bus operations (it actually works now).

The following rules are now followed (and verfified by the debug
code):

1.  A "bus_space_handle_t" may only be used with the
    "bus_space_tag_t" that created it.
2.  Only "bus_space_map()" may create "bus_space_handle_t"s.
3.  A "bus_space_handle_t" may not be modified after it has
    been created (other than being destroyed by "bus_space_unmap()").


Thanks to help from mcbride, marc, jason, drahn, to anyone that might
have slipped my mind at the moment.

ok jason@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: psycho.c,v 1.26 2003/02/11 19:20:26 mickey Exp $	*/
d457 1
a457 1
		if (getproplen(sc->sc_node, "no-streaming-cache") >= 0) {
d459 1
a459 1
			vaddr_t va = (vaddr_t)pp->pp_flush[0x40];
d485 1
a485 1
		    sc->sc_basepaddr, 0x0100000, 0, &sc->sc_configaddr))
d493 1
a493 1
		if (getproplen(sc->sc_node, "no-streaming-cache") >= 0) {
d495 1
a495 1
			vaddr_t va = (vaddr_t)pp->pp_flush[0x40];
@


1.26
log
@be consistant on Hz vs hz
@
text
@d1 1
a1 1
/*	$OpenBSD: psycho.c,v 1.25 2003/01/13 16:04:38 jason Exp $	*/
d6 1
d66 1
a66 1
int psycho_debug = 0;
d78 2
d97 5
a101 6
pcireg_t psycho_pci_conf_read(pci_chipset_tag_t pc, pcitag_t, int);
void psycho_pci_conf_write(pci_chipset_tag_t, pcitag_t, int, pcireg_t);
paddr_t psycho_bus_mmap(bus_space_tag_t, bus_addr_t, off_t, int, int);
int _psycho_bus_map(bus_space_tag_t, bus_type_t, bus_addr_t,
    bus_size_t, int, vaddr_t, bus_space_handle_t *);
void *psycho_intr_establish(bus_space_tag_t, int, int, int,
d117 2
a128 1
int	psycho_get_childspace(int);
d191 1
a191 4
psycho_match(parent, match, aux)
	struct device	*parent;
	void		*match;
	void		*aux;
d225 1
a225 3
psycho_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
a231 1
	bus_space_handle_t bh;
a233 1
	struct pci_ctl *pci_ctl;
d243 1
a243 1
	 * call the model-specific initialisation routine.
d275 3
a277 4
			sc->sc_regs = (struct psychoreg *)
			    (u_long)ma->ma_address[2];
			pci_ctl = (struct pci_ctl *)
			    (u_long)ma->ma_address[0];
d279 1
a279 4
			bus_space_handle_t handle;

			/* We need to map this in ourselves. */
			if (bus_space_map2(sc->sc_bustag, 0,
d281 1
a281 10
			    0, NULL, &handle))
				panic("psycho_attach: cannot map regs");
			sc->sc_regs = (struct psychoreg *)(u_long)handle;

			if (bus_space_map2(sc->sc_bustag, 0,
			    ma->ma_reg[0].ur_paddr, ma->ma_reg[0].ur_len,
			    0, NULL, &handle))
				panic("psycho_attach: cannot map ctl");
/* XXX -- this is lost but never unmapped */
			pci_ctl = (struct pci_ctl *)(u_long)handle;
d289 5
a293 3
			sc->sc_regs = (struct psychoreg *)
			    (u_long)ma->ma_address[0];
			pci_ctl = (struct pci_ctl *)&sc->sc_regs->psy_pcictl[0];
d295 1
a295 4
			bus_space_handle_t handle;

			/* We need to map this in ourselves. */
			if (bus_space_map2(sc->sc_bustag, 0,
d297 3
a299 4
			    0, NULL, &handle))
				panic("psycho_attach: cannot map regs");
			sc->sc_regs = (struct psychoreg *)(u_long)handle;
			pci_ctl = (struct pci_ctl *)&sc->sc_regs->psy_pcictl[0];
d305 1
a305 1
	csr = sc->sc_regs->psy_csr;
a334 1

d340 1
a340 2
	csr = bus_space_read_8(sc->sc_bustag,
	    (bus_space_handle_t)(u_long)&pci_ctl->pci_csr, 0);
d345 1
a345 3
	bus_space_write_8(sc->sc_bustag,
	    (bus_space_handle_t)(u_long)&pci_ctl->pci_csr, 0, csr);

d369 1
a369 1
	pp->pp_pcictl = &sc->sc_regs->psy_pcictl[0];
d376 1
a376 1
	    (pp->pp_iot ? PCI_FLAGS_IO_ENABLED : 0);
a383 3
	pba.pba_pc->conf_read = psycho_pci_conf_read;
	pba.pba_pc->conf_write = psycho_pci_conf_write;

d390 1
d392 2
d404 2
a405 2
		    &sc->sc_regs->ue_int_map,
		    &sc->sc_regs->ue_clr_int);
d407 2
a408 2
		    &sc->sc_regs->ce_int_map,
		    &sc->sc_regs->ce_clr_int);
d410 2
a411 2
		    &sc->sc_regs->pciaerr_int_map,
		    &sc->sc_regs->pciaerr_clr_int);
d413 2
a414 2
		    &sc->sc_regs->pciberr_int_map,
		    &sc->sc_regs->pciberr_clr_int);
d417 2
a418 2
		    &sc->sc_regs->power_int_map, 
		    &sc->sc_regs->power_clr_int);
d421 18
a438 2
		    &sc->sc_regs->pwrmgt_int_map, 
		    &sc->sc_regs->pwrmgt_clr_int);
d444 3
a446 3
		 * We should calculate a TSB size based on amount of RAM
		 * and number of bus controllers and number an type of
		 * child devices.
d455 1
d457 23
a479 4
		sc->sc_is->is_sb[0] = NULL;
		sc->sc_is->is_sb[1] = NULL;
		if (getproplen(sc->sc_node, "no-streaming-cache") >= 0)
			sc->sc_is->is_sb[0] = &pci_ctl->pci_strbuf;
d484 2
a485 3
		if (bus_space_map2(sc->sc_bustag,
		    PCI_CONFIG_BUS_SPACE, sc->sc_basepaddr + 0x01000000,
		    0x0100000, 0, 0, &bh))
a486 1
		sc->sc_configaddr = (off_t)bh;
d493 23
a515 2
		if (getproplen(sc->sc_node, "no-streaming-cache") >= 0)
			sc->sc_is->is_sb[1] = &pci_ctl->pci_strbuf;
a519 6
	 * XXX Linux magic, helps U30
	 * "PROM sets the IRQ retry value too low, increase it."
	 */
	sc->sc_regs->intr_retry_timer = 0xff;

	/*
d529 2
d535 28
d564 1
a564 3
psycho_print(aux, p)
	void *aux;
	const char *p;
a565 1

d572 2
a573 6
psycho_set_intr(sc, ipl, handler, mapper, clearer)
	struct psycho_softc *sc;
	int ipl;
	void *handler;
	u_int64_t *mapper;
	u_int64_t *clearer;
d585 1
a585 1
	ih->ih_pil = (1<<ipl);
d589 3
a591 2
	    "; installing handler %p arg %p with number %x pil %u\n",
	    ih->ih_fun, ih->ih_arg, ih->ih_number, ih->ih_pil));
d605 1
a605 4
psycho_alloc_chipset(pp, node, pc)
	struct psycho_pbm *pp;
	int node;
	pci_chipset_tag_t pc;
d634 3
a636 1
	DPRINTF(PDB_PROM, ("psycho debug: got `bus-range' for node %08x: %u - %u\n", node, brp[0], brp[1]));
d640 1
a640 4
psycho_get_ranges(node, rp, np)
	int node;
	struct psycho_ranges **rp;
	int *np;
d645 3
a647 1
	DPRINTF(PDB_PROM, ("psycho debug: got `ranges' for node %08x: %d entries\n", node, *np));
d655 1
a655 2
psycho_ue(arg)
	void *arg;
d657 3
a659 4
	struct psycho_softc *sc = (struct psycho_softc *)arg;
	struct psychoreg *regs = sc->sc_regs;
	unsigned long long afsr = regs->psy_ue_afsr;
	unsigned long long afar = regs->psy_ue_afar;
d671 1
a671 2
psycho_ce(arg)
	void *arg;
d673 1
a673 2
	struct psycho_softc *sc = (struct psycho_softc *)arg;
	struct psychoreg *regs = sc->sc_regs;
d681 2
a682 1
	    (long long)regs->psy_ce_afar, (long long)regs->psy_ce_afsr);
d687 1
a687 3
psycho_bus_error(sc, bus)
	struct psycho_softc *sc;
	int bus;
a688 1
	struct psychoreg *regs = sc->sc_regs;
d691 2
a692 2
	afar = regs->psy_pcictl[bus].pci_afar;
	afsr = regs->psy_pcictl[bus].pci_afsr;
d709 1
a709 1
	regs->psy_pcictl[bus].pci_afsr = bits;
d714 1
a714 2
psycho_bus_a(arg)
	void *arg;
d716 1
a716 1
	struct psycho_softc *sc = (struct psycho_softc *)arg;
d722 1
a722 2
psycho_bus_b(arg)
	void *arg;
d724 1
a724 1
	struct psycho_softc *sc = (struct psycho_softc *)arg;
d730 1
a730 2
psycho_powerfail(arg)
	void *arg;
a731 1

d741 1
a741 2
psycho_wakeup(arg)
	void *arg;
d743 1
a743 1
	struct psycho_softc *sc = (struct psycho_softc *)arg;
d757 1
a757 3
psycho_iommu_init(sc, tsbsize)
	struct psycho_softc *sc;
	int tsbsize;
d767 3
a769 1
	is->is_iommu = &sc->sc_regs->psy_iommu;
d783 1
a783 1
#define	TSBCASE(x)	case 1<<((x)+23): tsbsize = (x); break
d792 5
d811 25
d837 2
a838 3
psycho_alloc_bus_tag(pp, type)
	struct psycho_pbm *pp;
	int type;
d841 1
a841 1
	bus_space_tag_t bt;
d843 1
a843 2
	bt = (bus_space_tag_t)
		malloc(sizeof(struct sparc_bus_space_tag), M_DEVBUF, M_NOWAIT);
d848 4
d854 3
a856 1
	bt->type = type;
d860 1
d865 1
a865 2
psycho_alloc_dma_tag(pp)
	struct psycho_pbm *pp;
d902 2
a903 37
psycho_get_childspace(type)
	int type;
{
	int ss;

	switch (type) {
	case PCI_CONFIG_BUS_SPACE:
		ss = 0x00;
		break;
	case PCI_IO_BUS_SPACE:
		ss = 0x01;
		break;
	case PCI_MEMORY_BUS_SPACE:
		ss = 0x02;
		break;
#if 0
	/* we don't do 64 bit memory space */
	case PCI_MEMORY64_BUS_SPACE:
		ss = 0x03;
		break;
#endif
	default:
		panic("psycho_get_childspace: unknown bus type");
	}

	return (ss);
}

int
_psycho_bus_map(t, btype, offset, size, flags, vaddr, hp)
	bus_space_tag_t t;
	bus_type_t btype;
	bus_addr_t offset;
	bus_size_t size;
	int	flags;
	vaddr_t vaddr;
	bus_space_handle_t *hp;
a905 1
	struct psycho_softc *sc = pp->pp_sc;
d908 3
a910 2
	DPRINTF(PDB_BUSMAP, ("_psycho_bus_map: type %d off %qx sz %qx flags %d va %p", t->type, (unsigned long long)offset, (unsigned long long)size, flags,
	    (void *)vaddr));
d912 1
a912 1
	ss = psycho_get_childspace(t->type);
d915 11
a925 2
	if (btype == 0)
		btype = t->type;
d934 4
a937 2
		paddr |= ((bus_addr_t)pp->pp_range[i].phys_hi<<32);
		DPRINTF(PDB_BUSMAP, ("\n_psycho_bus_map: mapping paddr space %lx offset %lx paddr %qx\n",
d940 1
a940 2
		return (bus_space_map2(sc->sc_bustag, btype, paddr,
		    size, flags, vaddr, hp));
d947 2
a948 6
psycho_bus_mmap(t, paddr, off, prot, flags)
	bus_space_tag_t t;
	bus_addr_t paddr;
	off_t off;
	int prot;
	int flags;
a951 1
	struct psycho_softc *sc = pp->pp_sc;
d954 1
a954 1
	ss = psycho_get_childspace(t->type);
d956 1
a956 1
	DPRINTF(PDB_BUSMAP, ("_psycho_bus_mmap: prot %d flags %d pa %qx\n",
d959 7
d973 1
a973 1
		paddr |= ((bus_addr_t)pp->pp_range[i].phys_hi<<32);
d975 1
a975 1
		    "space %lx offset %lx paddr %qx\n",
d978 1
a978 1
		return (bus_space_mmap(sc->sc_bustag, paddr, off, prot, flags));
d988 2
a989 7
psycho_intr_establish(t, ihandle, level, flags, handler, arg)
	bus_space_tag_t t;
	int ihandle;
	int level;
	int flags;
	int (*handler)(void *);
	void *arg;
d1015 2
a1016 1
	DPRINTF(PDB_INTR, ("\npsycho_intr_establish: ihandle %x vec %lx", ihandle, vec));
d1021 2
a1022 1
	if (level == IPL_NONE) level = INTLEV(vec);
d1031 2
a1032 1
		DPRINTF(PDB_INTR, ("\npsycho: intr %lx: %p\nHunting for IRQ...\n",
d1036 4
a1039 3
		for (intrmapptr = &sc->sc_regs->scsi_int_map,
		    intrclrptr = &sc->sc_regs->scsi_clr_int;
		    intrmapptr < &sc->sc_regs->ffb0_int_map;
d1046 4
a1049 3
		for (intrmapptr = &sc->sc_regs->pcia_slot0_int,
		    intrclrptr = &sc->sc_regs->pcia0_clr_int[0];
		    intrmapptr <= &sc->sc_regs->pcib_slot3_int;
d1053 4
a1056 2
			    (intrmapptr == &sc->sc_regs->pcia_slot2_int ||
			     intrmapptr == &sc->sc_regs->pcia_slot3_int))
d1087 1
a1087 1
	    "; installing handler %p arg %p with number %x pil %u\n",
d1110 1
a1110 1
		DPRINTF(PDB_INTR, ("; reread intrmap = %016qx\n",
d1120 2
a1121 7
psycho_dmamap_load(t, map, buf, buflen, p, flags)
	bus_dma_tag_t t;
	bus_dmamap_t map;
	void *buf;
	bus_size_t buflen;
	struct proc *p;
	int flags;
d1123 1
a1123 1
	struct psycho_pbm *pp = (struct psycho_pbm *)t->_cookie;
d1130 1
a1130 3
psycho_dmamap_unload(t, map)
	bus_dma_tag_t t;
	bus_dmamap_t map;
d1132 1
a1132 1
	struct psycho_pbm *pp = (struct psycho_pbm *)t->_cookie;
d1139 2
a1140 7
psycho_dmamap_load_raw(t, map, segs, nsegs, size, flags)
	bus_dma_tag_t t;
	bus_dmamap_t map;
	bus_dma_segment_t *segs;
	int nsegs;
	bus_size_t size;
	int flags;
d1142 1
a1142 1
	struct psycho_pbm *pp = (struct psycho_pbm *)t->_cookie;
d1145 2
a1146 1
	return (iommu_dvmamap_load_raw(t, sc->sc_is, map, segs, nsegs, flags, size));
d1150 2
a1151 6
psycho_dmamap_sync(t, map, offset, len, ops)
	bus_dma_tag_t t;
	bus_dmamap_t map;
	bus_addr_t offset;
	bus_size_t len;
	int ops;
d1153 1
a1153 1
	struct psycho_pbm *pp = (struct psycho_pbm *)t->_cookie;
a1165 1

d1169 3
a1171 9
psycho_dmamem_alloc(t, size, alignment, boundary, segs, nsegs, rsegs, flags)
	bus_dma_tag_t t;
	bus_size_t size;
	bus_size_t alignment;
	bus_size_t boundary;
	bus_dma_segment_t *segs;
	int nsegs;
	int *rsegs;
	int flags;
d1173 1
a1173 1
	struct psycho_pbm *pp = (struct psycho_pbm *)t->_cookie;
d1181 1
a1181 4
psycho_dmamem_free(t, segs, nsegs)
	bus_dma_tag_t t;
	bus_dma_segment_t *segs;
	int nsegs;
d1183 1
a1183 1
	struct psycho_pbm *pp = (struct psycho_pbm *)t->_cookie;
d1190 2
a1191 7
psycho_dmamem_map(t, segs, nsegs, size, kvap, flags)
	bus_dma_tag_t t;
	bus_dma_segment_t *segs;
	int nsegs;
	size_t size;
	caddr_t *kvap;
	int flags;
d1193 1
a1193 1
	struct psycho_pbm *pp = (struct psycho_pbm *)t->_cookie;
d1196 2
a1197 1
	return (iommu_dvmamem_map(t, sc->sc_is, segs, nsegs, size, kvap, flags));
d1201 1
a1201 4
psycho_dmamem_unmap(t, kva, size)
	bus_dma_tag_t t;
	caddr_t kva;
	size_t size;
d1203 1
a1203 1
	struct psycho_pbm *pp = (struct psycho_pbm *)t->_cookie;
a1208 57
pcireg_t
psycho_pci_conf_read(pc, tag, reg)
	pci_chipset_tag_t pc;
	pcitag_t tag;
	int reg;
{
	struct psycho_pbm *pp = pc->cookie;
	struct psycho_softc *sc = pp->pp_sc;
	pcireg_t val = (pcireg_t)~0;

	DPRINTF(PDB_CONF, ("pci_conf_read: tag %lx reg %x ", 
		(long)tag, reg));
	if (PCITAG_NODE(tag) != -1) {
		DPRINTF(PDB_CONF, ("asi=%x addr=%qx (offset=%x) ...",
			bus_type_asi[sc->sc_configtag->type],
			(long long)(sc->sc_configaddr + 
				PCITAG_OFFSET(tag) + reg),
			(int)PCITAG_OFFSET(tag) + reg));

		val = bus_space_read_4(sc->sc_configtag, sc->sc_configaddr,
			PCITAG_OFFSET(tag) + reg);
	}
#ifdef DEBUG
	else DPRINTF(PDB_CONF, ("pci_conf_read: bogus pcitag %x\n",
	    (int)PCITAG_OFFSET(tag)));
#endif
	DPRINTF(PDB_CONF, (" returning %08x\n", (u_int)val));

	return (val);
}

void
psycho_pci_conf_write(pc, tag, reg, data)
	pci_chipset_tag_t pc;
	pcitag_t tag;
	int reg;
	pcireg_t data;
{
	struct psycho_pbm *pp = pc->cookie;
	struct psycho_softc *sc = pp->pp_sc;

	DPRINTF(PDB_CONF, ("pci_conf_write: tag %lx; reg %x; data %x; ", 
		(long)PCITAG_OFFSET(tag), reg, (int)data));
	DPRINTF(PDB_CONF, ("asi = %x; readaddr = %qx (offset = %x)\n",
		bus_type_asi[sc->sc_configtag->type],
		(long long)(sc->sc_configaddr + PCITAG_OFFSET(tag) + reg), 
		(int)PCITAG_OFFSET(tag) + reg));

	/* If we don't know it, just punt. */
	if (PCITAG_NODE(tag) == -1) {
		DPRINTF(PDB_CONF, ("pci_config_write: bad addr"));
		return;
	}

	bus_space_write_4(sc->sc_configtag, sc->sc_configaddr, 
		PCITAG_OFFSET(tag) + reg, data);
}
@


1.25
log
@Don't use a global variable to determine which pci_conf* function to call,
store function pointers in the pci_chipset_tag_t (ie. fix an ugly hack
I did during the hackathon last year).
@
text
@d1 1
a1 1
/*	$OpenBSD: psycho.c,v 1.24 2002/12/02 17:08:51 jason Exp $	*/
d145 1
a145 1
 * "psycho+" controls both a 64-bit 33Mhz and a 64-bit 66Mhz PCI bus.  You
@


1.24
log
@Skip the ffb0, ffb1, pcia/slot2 (for psycho), and pcia/slot3 (for psycho)
interrupt map matches; from FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: psycho.c,v 1.23 2002/10/12 01:09:43 krw Exp $	*/
a391 2
	pci_conf_setfunc(psycho_pci_conf_read, psycho_pci_conf_write);

d406 3
@


1.23
log
@Remove more '\n's from panic() statements. Both trailing and leading.

Diff generated by Chris Kuethe.
@
text
@d1 1
a1 1
/*	$OpenBSD: psycho.c,v 1.22 2002/09/17 13:25:52 art Exp $	*/
d990 3
a992 3
			 intrclrptr = &sc->sc_regs->scsi_clr_int;
		     intrmapptr <= &sc->sc_regs->ffb1_int_map;
		     intrmapptr++, intrclrptr++) {
d999 9
a1007 3
			 intrclrptr = &sc->sc_regs->pcia0_clr_int[0];
		     intrmapptr <= &sc->sc_regs->pcib_slot3_int;
		     intrmapptr++, intrclrptr += 4) {
@


1.22
log
@I sense too much cut 'n paste.
Allow this to build with DEBUG.
@
text
@d1 1
a1 1
/*	$OpenBSD: psycho.c,v 1.21 2002/07/18 05:46:29 jason Exp $	*/
d617 1
a617 1
	panic("%s: uncorrectable DMA error AFAR %llx (pa=%llx) AFSR %llx\n",
@


1.21
log
@s/0/NULL in pointer comparison
@
text
@d1 1
a1 1
/*	$OpenBSD: psycho.c,v 1.20 2002/06/08 18:06:02 jason Exp $	*/
a59 1
#undef DEBUG
d64 2
a65 1
int psycho_debug = 0x0;
d1194 1
a1194 1
	DPRINTF(SPDB_CONF, ("pci_conf_read: tag %lx reg %x ", 
d1197 1
a1197 1
		DPRINTF(SPDB_CONF, ("asi=%x addr=%qx (offset=%x) ...",
d1207 1
a1207 1
	else DPRINTF(SPDB_CONF, ("pci_conf_read: bogus pcitag %x\n",
d1210 1
a1210 1
	DPRINTF(SPDB_CONF, (" returning %08x\n", (u_int)val));
d1225 1
a1225 1
	DPRINTF(SPDB_CONF, ("pci_conf_write: tag %lx; reg %x; data %x; ", 
d1227 1
a1227 1
	DPRINTF(SPDB_CONF, ("asi = %x; readaddr = %qx (offset = %x)\n",
d1234 1
a1234 1
		DPRINTF(SPDB_CONF, ("pci_config_write: bad addr"));
@


1.20
log
@make pci_conf_{read|write} indirect functions so we can overload them
@
text
@d1 1
a1 1
/*	$OpenBSD: psycho.c,v 1.19 2002/06/07 08:40:33 jason Exp $	*/
d758 1
a758 1
	if (name == 0)
@


1.19
log
@remove static
@
text
@d1 1
a1 1
/*	$OpenBSD: psycho.c,v 1.18 2002/04/04 23:16:22 jason Exp $	*/
d94 2
d392 2
d407 1
a407 1
	pba.pba_pc = psycho_alloc_chipset(pp, sc->sc_node, pp->pp_pc);
d1182 58
@


1.18
log
@Some PCI machines do not implement the uperf registers.  Those that do
provide an 'sc at ebus'.  Use that instead of a direct attachment of
uperf to psycho.
@
text
@d1 1
a1 1
/*	$OpenBSD: psycho.c,v 1.17 2002/04/04 17:03:00 jason Exp $	*/
d71 1
a71 1
static pci_chipset_tag_t psycho_alloc_chipset(struct psycho_pbm *, int,
@


1.17
log
@s/0/NULL for pointers
@
text
@d1 1
a1 1
/*	$OpenBSD: psycho.c,v 1.16 2002/03/14 03:16:00 millert Exp $	*/
a36 2
#include "uperf_psycho.h"

a411 11
#if NUPERF_PSYCHO > 0
		if (sc->sc_mode == PSYCHO_MODE_PSYCHO) {
			struct uperf_psycho_attach_args upaa;

			upaa.upaa_name = "uperf";
			upaa.upaa_regs = &sc->sc_regs->psy_pm;

			(void)config_found(self, &upaa, psycho_print);
		}
#endif

@


1.16
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: psycho.c,v 1.15 2002/03/14 01:26:44 millert Exp $	*/
d471 2
a472 2
		sc->sc_is->is_sb[0] = 0;
		sc->sc_is->is_sb[1] = 0;
@


1.15
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: psycho.c,v 1.14 2002/02/05 18:34:39 jason Exp $	*/
d99 2
a100 2
void *psycho_intr_establish __P((bus_space_tag_t, int, int, int,
    int (*)(void *), void *));
@


1.14
log
@Implement vgafb_mmap() fully
From NetBSD: change bus_space_mmap() prototype to standard one
@
text
@d1 1
a1 1
/*	$OpenBSD: psycho.c,v 1.13 2002/01/31 18:27:26 jason Exp $	*/
d73 6
a78 6
static pci_chipset_tag_t psycho_alloc_chipset __P((struct psycho_pbm *, int,
    pci_chipset_tag_t));
void psycho_get_bus_range __P((int, int *));
void psycho_get_ranges __P((int, struct psycho_ranges **, int *));
void psycho_set_intr __P((struct psycho_softc *, int, void *, 
    u_int64_t *, u_int64_t *));
d81 7
a87 7
int psycho_ue __P((void *));
int psycho_ce __P((void *));
int psycho_bus_a __P((void *));
int psycho_bus_b __P((void *));
int psycho_bus_error __P((struct psycho_softc *, int));
int psycho_powerfail __P((void *));
int psycho_wakeup __P((void *));
d90 1
a90 1
void psycho_iommu_init __P((struct psycho_softc *, int));
d96 3
a98 3
paddr_t psycho_bus_mmap __P((bus_space_tag_t, bus_addr_t, off_t, int, int));
int _psycho_bus_map __P((bus_space_tag_t, bus_type_t, bus_addr_t,
    bus_size_t, int, vaddr_t, bus_space_handle_t *));
d100 1
a100 1
    int (*) __P((void *)), void *));
d102 13
a114 13
int psycho_dmamap_load __P((bus_dma_tag_t, bus_dmamap_t, void *,
    bus_size_t, struct proc *, int));
void psycho_dmamap_unload __P((bus_dma_tag_t, bus_dmamap_t));
int psycho_dmamap_load_raw __P((bus_dma_tag_t, bus_dmamap_t,
    bus_dma_segment_t *, int, bus_size_t, int));
void psycho_dmamap_sync __P((bus_dma_tag_t, bus_dmamap_t, bus_addr_t,
    bus_size_t, int));
int psycho_dmamem_alloc __P((bus_dma_tag_t, bus_size_t, bus_size_t, bus_size_t,
    bus_dma_segment_t *, int, int *, int));
void psycho_dmamem_free __P((bus_dma_tag_t, bus_dma_segment_t *, int));
int psycho_dmamem_map __P((bus_dma_tag_t, bus_dma_segment_t *, int, size_t,
    caddr_t *, int));
void psycho_dmamem_unmap __P((bus_dma_tag_t, caddr_t, size_t));
d122 4
a125 4
int	psycho_match __P((struct device *, void *, void *));
void	psycho_attach __P((struct device *, struct device *, void *));
int	psycho_print __P((void *aux, const char *p));
int	psycho_get_childspace __P((int));
d953 1
a953 1
	int (*handler) __P((void *));
@


1.13
log
@Don't need uperf_psychovar.h to define one structure, put it in psychovar.h
@
text
@d1 1
a1 1
/*	$OpenBSD: psycho.c,v 1.12 2002/01/30 23:58:02 jason Exp $	*/
d96 1
a96 2
int psycho_bus_mmap __P((bus_space_tag_t, bus_type_t, bus_addr_t,
    int, bus_space_handle_t *));
d908 2
a909 2
int
psycho_bus_mmap(t, btype, paddr, flags, hp)
a910 1
	bus_type_t btype;
d912 2
a914 1
	bus_space_handle_t *hp;
d923 2
a924 1
	DPRINTF(PDB_BUSMAP, ("_psycho_bus_mmap: type %d flags %d pa %qx\n", btype, flags, (unsigned long long)paddr));
d934 2
a935 1
		DPRINTF(PDB_BUSMAP, ("\n_psycho_bus_mmap: mapping paddr space %lx offset %lx paddr %qx\n",
d938 1
a938 1
		return (bus_space_mmap(sc->sc_bustag, 0, paddr, flags, hp));
@


1.12
log
@Driver for getting at performance counters.  These manifest them
selves as "sc at sbus" and a couple of registers on psycho (sabre
doesn't appear to have these registers).
@
text
@d1 1
a1 1
/*	$OpenBSD: psycho.c,v 1.11 2002/01/29 20:33:19 jason Exp $	*/
a59 3
#if NUPERF_PSYCHO > 0
#include <sparc64/dev/uperf_psychovar.h>
#endif
@


1.11
log
@Don't install a handler for powerfail... this causes weird problems with
the Netra X1 (interactions with lom)
@
text
@d1 1
a1 1
/*	$OpenBSD: psycho.c,v 1.10 2002/01/10 00:06:17 nordin Exp $	*/
d37 2
d60 3
d418 10
@


1.10
log
@Check result from malloc(9) when using M_NOWAIT. jason@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: psycho.c,v 1.9 2001/12/14 14:55:57 jason Exp $	*/
d435 1
d439 1
@


1.9
log
@Use default mapping type (little endian) if the type is 0, otherwise use
the passed in type.  This allows PCI devices to create big endian mappings
which is necessary for vgafb.
@
text
@d1 1
a1 1
/*	$OpenBSD: psycho.c,v 1.8 2001/10/15 03:36:16 jason Exp $	*/
d525 2
@


1.9.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: psycho.c,v 1.13 2002/01/31 18:27:26 jason Exp $	*/
a36 2
#include "uperf_psycho.h"

a412 10
#if NUPERF_PSYCHO > 0
		if (sc->sc_mode == PSYCHO_MODE_PSYCHO) {
			struct uperf_psycho_attach_args upaa;

			upaa.upaa_name = "uperf";
			upaa.upaa_regs = &sc->sc_regs->psy_pm;

			(void)config_found(self, &upaa, psycho_print);
		}
#endif
a434 1
#if 0
a437 1
#endif
a524 2
	if (ih == NULL)
		panic("couldn't malloc intrhand");
@


1.9.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: psycho.c,v 1.9.2.1 2002/01/31 22:55:23 niklas Exp $	*/
d37 2
d73 6
a78 6
pci_chipset_tag_t psycho_alloc_chipset(struct psycho_pbm *, int,
    pci_chipset_tag_t);
void psycho_get_bus_range(int, int *);
void psycho_get_ranges(int, struct psycho_ranges **, int *);
void psycho_set_intr(struct psycho_softc *, int, void *, 
    u_int64_t *, u_int64_t *);
d81 7
a87 7
int psycho_ue(void *);
int psycho_ce(void *);
int psycho_bus_a(void *);
int psycho_bus_b(void *);
int psycho_bus_error(struct psycho_softc *, int);
int psycho_powerfail(void *);
int psycho_wakeup(void *);
d90 1
a90 1
void psycho_iommu_init(struct psycho_softc *, int);
d96 20
a115 21
pcireg_t psycho_pci_conf_read(pci_chipset_tag_t pc, pcitag_t, int);
void psycho_pci_conf_write(pci_chipset_tag_t, pcitag_t, int, pcireg_t);
paddr_t psycho_bus_mmap(bus_space_tag_t, bus_addr_t, off_t, int, int);
int _psycho_bus_map(bus_space_tag_t, bus_type_t, bus_addr_t,
    bus_size_t, int, vaddr_t, bus_space_handle_t *);
void *psycho_intr_establish(bus_space_tag_t, int, int, int,
    int (*)(void *), void *);

int psycho_dmamap_load(bus_dma_tag_t, bus_dmamap_t, void *,
    bus_size_t, struct proc *, int);
void psycho_dmamap_unload(bus_dma_tag_t, bus_dmamap_t);
int psycho_dmamap_load_raw(bus_dma_tag_t, bus_dmamap_t,
    bus_dma_segment_t *, int, bus_size_t, int);
void psycho_dmamap_sync(bus_dma_tag_t, bus_dmamap_t, bus_addr_t,
    bus_size_t, int);
int psycho_dmamem_alloc(bus_dma_tag_t, bus_size_t, bus_size_t, bus_size_t,
    bus_dma_segment_t *, int, int *, int);
void psycho_dmamem_free(bus_dma_tag_t, bus_dma_segment_t *, int);
int psycho_dmamem_map(bus_dma_tag_t, bus_dma_segment_t *, int, size_t,
    caddr_t *, int);
void psycho_dmamem_unmap(bus_dma_tag_t, caddr_t, size_t);
d123 4
a126 4
int	psycho_match(struct device *, void *, void *);
void	psycho_attach(struct device *, struct device *, void *);
int	psycho_print(void *aux, const char *p);
int	psycho_get_childspace(int);
a392 2
	pci_conf_setfunc(psycho_pci_conf_read, psycho_pci_conf_write);

d406 1
a406 1
	pba.pba_pc = pp->pp_pc;
d415 11
d472 2
a473 2
		sc->sc_is->is_sb[0] = NULL;
		sc->sc_is->is_sb[1] = NULL;
d909 2
a910 2
paddr_t
psycho_bus_mmap(t, paddr, off, prot, flags)
d912 1
a913 2
	off_t off;
	int prot;
d915 1
d924 1
a924 2
	DPRINTF(PDB_BUSMAP, ("_psycho_bus_mmap: prot %d flags %d pa %qx\n",
	    prot, flags, (unsigned long long)paddr));
d934 1
a934 2
		DPRINTF(PDB_BUSMAP, ("\n_psycho_bus_mmap: mapping paddr "
		    "space %lx offset %lx paddr %qx\n",
d937 1
a937 1
		return (bus_space_mmap(sc->sc_bustag, paddr, off, prot, flags));
d952 1
a952 1
	int (*handler)(void *);
a1189 58
}

pcireg_t
psycho_pci_conf_read(pc, tag, reg)
	pci_chipset_tag_t pc;
	pcitag_t tag;
	int reg;
{
	struct psycho_pbm *pp = pc->cookie;
	struct psycho_softc *sc = pp->pp_sc;
	pcireg_t val = (pcireg_t)~0;

	DPRINTF(SPDB_CONF, ("pci_conf_read: tag %lx reg %x ", 
		(long)tag, reg));
	if (PCITAG_NODE(tag) != -1) {
		DPRINTF(SPDB_CONF, ("asi=%x addr=%qx (offset=%x) ...",
			bus_type_asi[sc->sc_configtag->type],
			(long long)(sc->sc_configaddr + 
				PCITAG_OFFSET(tag) + reg),
			(int)PCITAG_OFFSET(tag) + reg));

		val = bus_space_read_4(sc->sc_configtag, sc->sc_configaddr,
			PCITAG_OFFSET(tag) + reg);
	}
#ifdef DEBUG
	else DPRINTF(SPDB_CONF, ("pci_conf_read: bogus pcitag %x\n",
	    (int)PCITAG_OFFSET(tag)));
#endif
	DPRINTF(SPDB_CONF, (" returning %08x\n", (u_int)val));

	return (val);
}

void
psycho_pci_conf_write(pc, tag, reg, data)
	pci_chipset_tag_t pc;
	pcitag_t tag;
	int reg;
	pcireg_t data;
{
	struct psycho_pbm *pp = pc->cookie;
	struct psycho_softc *sc = pp->pp_sc;

	DPRINTF(SPDB_CONF, ("pci_conf_write: tag %lx; reg %x; data %x; ", 
		(long)PCITAG_OFFSET(tag), reg, (int)data));
	DPRINTF(SPDB_CONF, ("asi = %x; readaddr = %qx (offset = %x)\n",
		bus_type_asi[sc->sc_configtag->type],
		(long long)(sc->sc_configaddr + PCITAG_OFFSET(tag) + reg), 
		(int)PCITAG_OFFSET(tag) + reg));

	/* If we don't know it, just punt. */
	if (PCITAG_NODE(tag) == -1) {
		DPRINTF(SPDB_CONF, ("pci_config_write: bad addr"));
		return;
	}

	bus_space_write_4(sc->sc_configtag, sc->sc_configaddr, 
		PCITAG_OFFSET(tag) + reg, data);
@


1.9.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: psycho.c,v 1.9.2.2 2002/06/11 03:38:43 art Exp $	*/
d60 1
d65 1
a65 2
#define PDB_CONF	0x08
int psycho_debug = 0;
d617 1
a617 1
	panic("%s: uncorrectable DMA error AFAR %llx (pa=%llx) AFSR %llx",
d758 1
a758 1
	if (name == NULL)
d1194 1
a1194 1
	DPRINTF(PDB_CONF, ("pci_conf_read: tag %lx reg %x ", 
d1197 1
a1197 1
		DPRINTF(PDB_CONF, ("asi=%x addr=%qx (offset=%x) ...",
d1207 1
a1207 1
	else DPRINTF(PDB_CONF, ("pci_conf_read: bogus pcitag %x\n",
d1210 1
a1210 1
	DPRINTF(PDB_CONF, (" returning %08x\n", (u_int)val));
d1225 1
a1225 1
	DPRINTF(PDB_CONF, ("pci_conf_write: tag %lx; reg %x; data %x; ", 
d1227 1
a1227 1
	DPRINTF(PDB_CONF, ("asi = %x; readaddr = %qx (offset = %x)\n",
d1234 1
a1234 1
		DPRINTF(PDB_CONF, ("pci_config_write: bad addr"));
@


1.9.2.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a5 1
 * Copyright (c) 2003 Henric Jungheim
a45 2
#include <uvm/uvm_extern.h>

d65 1
a65 1
int psycho_debug = ~0;
a76 2
bus_space_tag_t _psycho_alloc_bus_tag(struct psycho_pbm *,
    const char *, int, int, int);
d94 6
a99 5
paddr_t psycho_bus_mmap(bus_space_tag_t, bus_space_tag_t, bus_addr_t, off_t,
    int, int);
int _psycho_bus_map(bus_space_tag_t, bus_space_tag_t, bus_addr_t,
    bus_size_t, int, bus_space_handle_t *);
void *psycho_intr_establish(bus_space_tag_t, bus_space_tag_t, int, int, int,
d102 1
a102 4
int psycho_dmamap_create(bus_dma_tag_t, bus_dma_tag_t, bus_size_t, int, bus_size_t,
    bus_size_t, int, bus_dmamap_t *);
void psycho_dvmamap_destroy(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t);
int psycho_dmamap_load(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t, void *,
d104 2
a105 2
void psycho_dmamap_unload(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t);
int psycho_dmamap_load_raw(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t,
d107 1
a107 1
void psycho_dmamap_sync(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t, bus_addr_t,
d109 1
a109 1
int psycho_dmamem_alloc(bus_dma_tag_t, bus_dma_tag_t, bus_size_t, bus_size_t, bus_size_t,
d111 2
a112 2
void psycho_dmamem_free(bus_dma_tag_t, bus_dma_tag_t, bus_dma_segment_t *, int);
int psycho_dmamem_map(bus_dma_tag_t, bus_dma_tag_t, bus_dma_segment_t *, int, size_t,
d114 1
a114 6
void psycho_dmamem_unmap(bus_dma_tag_t, bus_dma_tag_t, caddr_t, size_t);
void psycho_map_psycho(struct psycho_softc *, int, bus_addr_t, bus_size_t,
    bus_addr_t, bus_size_t);
int psycho_intr_map(struct pci_attach_args *, pci_intr_handle_t *);
void psycho_identify_pbm(struct psycho_softc *sc, struct psycho_pbm *pp,
    struct pcibus_attach_args *pa);
d125 1
d145 1
a145 1
 * "psycho+" controls both a 64-bit 33MHz and a 64-bit 66MHz PCI bus.  You
d188 4
a191 1
psycho_match(struct device *parent, void *match, void *aux)
d225 3
a227 1
psycho_attach(struct device *parent, struct device *self, void *aux)
d234 1
d237 1
d247 1
a247 1
	 * call the model-specific initialization routine.
d279 4
a282 3
			psycho_map_psycho(sc, 0,
			    ma->ma_address[2], sizeof(struct psychoreg),
			    ma->ma_address[0], sizeof(struct pci_ctl));
d284 4
a287 1
			psycho_map_psycho(sc, 1,
d289 10
a298 1
			    ma->ma_reg[0].ur_paddr, ma->ma_reg[0].ur_len);
d306 3
a308 5
			psycho_map_psycho(sc, 0,
			    ma->ma_address[0], sizeof(struct psychoreg),
			    ma->ma_address[0] +
				offsetof(struct psychoreg, psy_pcictl[0]),
			    sizeof(struct pci_ctl));
d310 4
a313 1
			psycho_map_psycho(sc, 1,
d315 4
a318 3
			    ma->ma_reg[0].ur_paddr +
				offsetof(struct psychoreg, psy_pcictl[0]),
			    sizeof(struct pci_ctl));
d324 2
a325 2
	csr = psycho_psychoreg_read(sc, psy_csr);
	sc->sc_ign = INTMAP_IGN; /* APB IGN is always 0x1f << 6 = 0x7c */
d354 1
d360 2
a361 1
	csr = psycho_pcictl_read(sc, pci_csr);
d366 3
a368 1
	psycho_pcictl_write(sc, pci_csr, csr);
d392 3
a394 1
	pp->pp_pcictl = sc->sc_pcictl;
d401 1
a401 1
	                (pp->pp_iot ? PCI_FLAGS_IO_ENABLED  : 0);
a414 1

a415 2
		uint64_t timeo;

d426 2
a427 2
		    psycho_psychoreg_vaddr(sc, ue_int_map),
		    psycho_psychoreg_vaddr(sc, ue_clr_int));
d429 2
a430 2
		    psycho_psychoreg_vaddr(sc, ce_int_map),
		    psycho_psychoreg_vaddr(sc, ce_clr_int));
d432 2
a433 2
		    psycho_psychoreg_vaddr(sc, pciaerr_int_map),
		    psycho_psychoreg_vaddr(sc, pciaerr_clr_int));
d435 2
a436 2
		    psycho_psychoreg_vaddr(sc, pciberr_int_map),
		    psycho_psychoreg_vaddr(sc, pciberr_clr_int));
d439 2
a440 2
		    psycho_psychoreg_vaddr(sc, power_int_map),
		    psycho_psychoreg_vaddr(sc, power_clr_int));
d443 2
a444 18
		    psycho_psychoreg_vaddr(sc, pwrmgt_int_map),
		    psycho_psychoreg_vaddr(sc, pwrmgt_clr_int));

		/*
		 * Apparently a number of machines with psycho and psycho+
		 * controllers have interrupt latency issues.  We'll try
		 * setting the interrupt retry timeout to 0xff which gives us
		 * a retry of 3-6 usec (which is what sysio is set to) for the
		 * moment, which seems to help alleviate this problem.
		 */
		timeo = psycho_psychoreg_read(sc, intr_retry_timer);
		if (timeo > 0xfff) {
#ifdef DEBUG
			printf("decreasing interrupt retry timeout "
			    "from %lx to 0xff\n", (long)timeo);
#endif
			psycho_psychoreg_write(sc, intr_retry_timer, 0xff);
		}
d450 3
a452 3
		 * We should calculate a TSB size based on the amount of RAM,
		 * number of bus controllers, and number and type of child
		 * devices.
a460 22
		memset(sc->sc_is, 0, sizeof *sc->sc_is);

		if (getproplen(sc->sc_node, "no-streaming-cache") < 0) {
			struct strbuf_ctl *sb = &pp->pp_sb;
			vaddr_t va = (vaddr_t)&pp->pp_flush[0x40];

			/*
			 * Initialize the strbuf_ctl.
			 *
			 * The flush sync buffer must be 64-byte aligned.
			 */

			sb->sb_flush = (void *)(va & ~0x3f);

			sb->sb_bustag = sc->sc_bustag;
			if (bus_space_subregion(sc->sc_bustag, sc->sc_pcictl,
			    offsetof(struct pci_ctl, pci_strbuf),
			    sizeof(struct iommu_strbuf),
			    &sb->sb_sb)) {
				printf("STC0 subregion failed\n");
				sb->sb_flush = 0;
			}
d462 4
a465 3
			/* Point out iommu at the strbuf_ctl. */
			sc->sc_is->is_sb[0] = sb;
		}
d470 3
a472 2
		if (bus_space_map(sc->sc_configtag,
		    sc->sc_basepaddr, 0x01000000, 0, &sc->sc_configaddr))
d474 1
d481 2
a482 25
		if (getproplen(sc->sc_node, "no-streaming-cache") < 0) {
			struct strbuf_ctl *sb = &pp->pp_sb;
			vaddr_t va = (vaddr_t)&pp->pp_flush[0x40];

			/*
			 * Initialize the strbuf_ctl.
			 *
			 * The flush sync buffer must be 64-byte aligned.
			 */

			sb->sb_flush = (void *)(va & ~0x3f);

			sb->sb_bustag = sc->sc_bustag;
			if (bus_space_subregion(sc->sc_bustag, sc->sc_pcictl,
			    offsetof(struct pci_ctl, pci_strbuf),
			    sizeof(struct iommu_strbuf),
			    &sb->sb_sb)) {
				printf("STC1 subregion failed\n");
				sb->sb_flush = 0;
			}

			/* Point out iommu at the strbuf_ctl. */
			sc->sc_is->is_sb[1] = sb;
		}

d487 6
a501 8
	pba.pba_pc->bustag = sc->sc_configtag;
	pba.pba_pc->bushandle = sc->sc_configaddr;
	pba.pba_pc->intr_map = psycho_intr_map;

	if (sc->sc_mode == PSYCHO_MODE_PSYCHO)
		psycho_identify_pbm(sc, pp, &pba);
	else
		pp->pp_id = PSYCHO_PBM_UNKNOWN;
d506 4
a509 3
void
psycho_identify_pbm(struct psycho_softc *sc, struct psycho_pbm *pp,
    struct pcibus_attach_args *pa)
a510 2
	vaddr_t pci_va = (vaddr_t)bus_space_vaddr(sc->sc_bustag, sc->sc_pcictl);
	paddr_t pci_pa;
a511 46
	if (pmap_extract(pmap_kernel(), pci_va, &pci_pa) == 0)
	    pp->pp_id = PSYCHO_PBM_UNKNOWN;
	else switch(pci_pa & 0xffff) {
		case 0x2000:
			pp->pp_id = PSYCHO_PBM_A;
			break;
		case 0x4000:
			pp->pp_id = PSYCHO_PBM_B;
			break;
		default:
			pp->pp_id = PSYCHO_PBM_UNKNOWN;
			break;
	}
}

void
psycho_map_psycho(struct psycho_softc* sc, int do_map, bus_addr_t reg_addr,
    bus_size_t reg_size, bus_addr_t pci_addr, bus_size_t pci_size)
{
	if (do_map) {
		if (bus_space_map(sc->sc_bustag,
		    reg_addr, reg_size, 0, &sc->sc_regsh))
			panic("psycho_attach: cannot map regs");

		if (pci_addr >= reg_addr &&
		    pci_addr + pci_size <= reg_addr + reg_size) {
			if (bus_space_subregion(sc->sc_bustag, sc->sc_regsh,
			    pci_addr - reg_addr, pci_size, &sc->sc_pcictl))
				panic("psycho_map_psycho: map ctl");
		}
		else if (bus_space_map(sc->sc_bustag, pci_addr, pci_size,
		    0, &sc->sc_pcictl))
			panic("psycho_map_psycho: cannot map pci");
	} else {
		if (bus_space_map(sc->sc_bustag, reg_addr, reg_size,
		    BUS_SPACE_MAP_PROMADDRESS, &sc->sc_regsh))
			panic("psycho_map_psycho: cannot map ctl");
		if (bus_space_map(sc->sc_bustag, pci_addr, pci_size,
		    BUS_SPACE_MAP_PROMADDRESS, &sc->sc_pcictl))
			panic("psycho_map_psycho: cannot map pci");
	}
}

int
psycho_print(void *aux, const char *p)
{
d518 6
a523 2
psycho_set_intr(struct psycho_softc *sc, int ipl, void *handler,
    u_int64_t *mapper, u_int64_t *clearer)
d535 1
a535 1
	ih->ih_pil = (1 << ipl);
d539 2
a540 3
	    "\ninstalling handler %p arg %p for %s with number %x pil %u",
	    ih->ih_fun, ih->ih_arg, sc->sc_dev.dv_xname, ih->ih_number,
	    ih->ih_pil));
d554 4
a557 1
psycho_alloc_chipset(struct psycho_pbm *pp, int node, pci_chipset_tag_t pc)
d586 1
a586 3
	DPRINTF(PDB_PROM,
	    ("psycho debug: got `bus-range' for node %08x: %u - %u\n",
	    node, brp[0], brp[1]));
d590 4
a593 1
psycho_get_ranges(int node, struct psycho_ranges **rp, int *np)
d598 1
a598 3
	DPRINTF(PDB_PROM,
	    ("psycho debug: got `ranges' for node %08x: %d entries\n",
	    node, *np));
d606 2
a607 1
psycho_ue(void *arg)
d609 4
a612 3
	struct psycho_softc *sc = arg;
	unsigned long long afsr = psycho_psychoreg_read(sc, psy_ue_afsr);
	unsigned long long afar = psycho_psychoreg_read(sc, psy_ue_afar);
d617 3
a619 6
	panic("%s: uncorrectable DMA error AFAR %llx (pa=%llx tte=%llx/%llx) "
	    "AFSR %llx", sc->sc_dev.dv_xname, afar,
	    iommu_extract(sc->sc_is, (vaddr_t)afar),
	    iommu_lookup_tte(sc->sc_is, (vaddr_t)afar),
	    iommu_fetch_tte(sc->sc_is, (paddr_t)afar),
	    afsr);
d624 2
a625 1
psycho_ce(void *arg)
d627 2
a628 1
	struct psycho_softc *sc = arg;
d636 1
a636 2
	    (long long)psycho_psychoreg_read(sc, psy_ce_afar),
	    (long long)psycho_psychoreg_read(sc, psy_ce_afsr));
d641 3
a643 1
psycho_bus_error(struct psycho_softc *sc, int bus)
d645 1
d648 2
a649 2
	afar = psycho_psychoreg_read(sc, psy_pcictl[bus].pci_afar);
	afsr = psycho_psychoreg_read(sc, psy_pcictl[bus].pci_afsr);
d666 1
a666 1
	psycho_psychoreg_write(sc, psy_pcictl[bus].pci_afsr, bits);
d671 2
a672 1
psycho_bus_a(void *arg)
d674 1
a674 1
	struct psycho_softc *sc = arg;
d680 2
a681 1
psycho_bus_b(void *arg)
d683 1
a683 1
	struct psycho_softc *sc = arg;
d689 2
a690 1
psycho_powerfail(void *arg)
d692 1
d702 2
a703 1
psycho_wakeup(void *arg)
d705 1
a705 1
	struct psycho_softc *sc = arg;
d719 3
a721 1
psycho_iommu_init(struct psycho_softc *sc, int tsbsize)
d731 1
a731 3
	bus_space_subregion(sc->sc_bustag, sc->sc_regsh,
	    offsetof(struct psychoreg, psy_iommu), sizeof(struct iommureg),
	    &is->is_iommu);
d745 1
a745 1
#define	TSBCASE(x)	case 1 << ((x) + 23): tsbsize = (x); break
a753 5
		DPRINTF(PDB_CONF, ("psycho_iommu_init: iobase=0x%x\n", iobase));
	}
	else {
		DPRINTF(PDB_CONF, ("psycho_iommu_init: getprop failed, "
		    "iobase=0x%x\n", iobase));
a767 1

d769 3
a771 26
psycho_alloc_mem_tag(struct psycho_pbm *pp)
{
	return (_psycho_alloc_bus_tag(pp, "mem",
	    0x02,	/* 32-bit mem space (where's the #define???) */
	    ASI_PRIMARY, ASI_PRIMARY_LITTLE));
}

bus_space_tag_t
psycho_alloc_io_tag(struct psycho_pbm *pp)
{
	return (_psycho_alloc_bus_tag(pp, "io",
	    0x01,	/* IO space (where's the #define???) */
	    ASI_PHYS_NON_CACHED_LITTLE, ASI_PHYS_NON_CACHED));
}

bus_space_tag_t
psycho_alloc_config_tag(struct psycho_pbm *pp)
{
	return (_psycho_alloc_bus_tag(pp, "cfg",
	    0x00,	/* Config space (where's the #define???) */
	    ASI_PHYS_NON_CACHED_LITTLE, ASI_PHYS_NON_CACHED));
}

bus_space_tag_t
_psycho_alloc_bus_tag(struct psycho_pbm *pp,
    const char *name, int ss, int asi, int sasi)
d774 1
a774 1
	struct sparc_bus_space_tag *bt;
d776 2
a777 1
	bt = malloc(sizeof(*bt), M_DEVBUF, M_NOWAIT);
a781 4
	
	snprintf(bt->name, sizeof(bt->name), "%s-pbm_%s(%d-%2.2x)",
	    	sc->sc_dev.dv_xname, name, ss, asi); 

d784 1
a784 3
	bt->default_type = ss;
	bt->asi = asi;
	bt->sasi = sasi;
a787 1

d792 2
a793 1
psycho_alloc_dma_tag(struct psycho_pbm *pp)
d806 3
a808 2
	dt->_dmamap_create = psycho_dmamap_create;
	dt->_dmamap_destroy = psycho_dvmamap_destroy;
d810 2
d819 2
d830 37
a866 2
_psycho_bus_map(bus_space_tag_t t, bus_space_tag_t t0, bus_addr_t offset,
    bus_size_t size, int flags, bus_space_handle_t *hp)
d869 1
d872 2
a873 3
	DPRINTF(PDB_BUSMAP, ("\n_psycho_bus_map: type %d off %qx sz %qx "
	    "flags %d", t->default_type, (unsigned long long)offset,
	    (unsigned long long)size, flags));
d875 1
a875 1
	ss = t->default_type;
d878 2
a879 11
	if (t->parent == 0 || t->parent->sparc_bus_map == 0) {
		printf("\n_psycho_bus_map: invalid parent");
		return (EINVAL);
	}

	t = t->parent;

	if (flags & BUS_SPACE_MAP_PROMADDRESS) {
		return ((*t->sparc_bus_map)
		    (t, t0, offset, size, flags, hp));
	}
d888 2
a889 4
		paddr |= ((bus_addr_t)pp->pp_range[i].phys_hi << 32);
		DPRINTF(PDB_BUSMAP,
		    ("\n_psycho_bus_map: mapping paddr space %lx offset %lx "
			"paddr %qx",
d892 2
a893 1
		return ((*t->sparc_bus_map)(t, t0, paddr, size, flags, hp));
d900 6
a905 2
psycho_bus_mmap(bus_space_tag_t t, bus_space_tag_t t0, bus_addr_t paddr,
    off_t off, int prot, int flags)
d909 1
d912 1
a912 1
	ss = t->default_type;
d914 1
a914 1
	DPRINTF(PDB_BUSMAP, ("\n_psycho_bus_mmap: prot %d flags %d pa %qx",
a916 7
	if (t->parent == 0 || t->parent->sparc_bus_mmap == 0) {
		printf("\n_psycho_bus_mmap: invalid parent");
		return (-1);
	}

	t = t->parent;

d924 1
a924 1
		paddr |= ((bus_addr_t)pp->pp_range[i].phys_hi << 32);
d926 1
a926 1
		    "space %lx offset %lx paddr %qx",
d929 1
a929 1
		return ((*t->sparc_bus_mmap)(t, t0, paddr, off, prot, flags));
a935 35
 * Bus-specific interrupt mapping
 */ 
int
psycho_intr_map(struct pci_attach_args *pa, pci_intr_handle_t *ihp)
{
	struct psycho_pbm *pp = pa->pa_pc->cookie;
	struct psycho_softc *sc = pp->pp_sc;
	u_int ino;

	ino = *ihp;

	if ((ino & ~INTMAP_PCIINT) == 0) {
		if (ino == 0 || ino > 4) {
			u_int32_t intreg;

			intreg = pci_conf_read(pa->pa_pc, pa->pa_tag,
			     PCI_INTERRUPT_REG);
			
			ino = PCI_INTERRUPT_PIN(intreg) - 1;
		} else
			ino -= 1;

		ino &= INTMAP_PCIINT;
				
		ino |= sc->sc_ign;
		ino |= ((pp->pp_id == PSYCHO_PBM_B) ? INTMAP_PCIBUS : 0);
		ino |= ((pa->pa_device - 1) << 2) & INTMAP_PCISLOT;
			
		*ihp = ino;
	}
  
	return (0);
}

/*
d939 7
a945 2
psycho_intr_establish(bus_space_tag_t t, bus_space_tag_t t0, int ihandle,
    int level, int flags, int (*handler)(void *), void *arg)
d971 1
a971 2
	DPRINTF(PDB_INTR,
	    ("\npsycho_intr_establish: ihandle %x vec %lx", ihandle, vec));
d976 1
a976 2
	if (level == IPL_NONE)
		level = INTLEV(vec);
d985 1
a985 2
		DPRINTF(PDB_INTR,
		    ("\npsycho: intr %lx: %p\nHunting for IRQ...\n",
d989 4
a992 5
		for (intrmapptr = psycho_psychoreg_vaddr(sc, scsi_int_map),
		    intrclrptr = psycho_psychoreg_vaddr(sc, scsi_clr_int);
		    intrmapptr < (volatile u_int64_t *)
			psycho_psychoreg_vaddr(sc, ffb0_int_map);
		    intrmapptr++, intrclrptr++) {
d998 4
a1001 13
		for (intrmapptr = psycho_psychoreg_vaddr(sc, pcia_slot0_int),
		    intrclrptr = psycho_psychoreg_vaddr(sc, pcia0_clr_int[0]);
		    intrmapptr <= (volatile u_int64_t *)
			psycho_psychoreg_vaddr(sc, pcib_slot3_int);
		    intrmapptr++, intrclrptr += 4) {
			/* Skip PCI-A Slot 2 and PCI-A Slot 3 on psycho's */
			if (sc->sc_mode == PSYCHO_MODE_PSYCHO &&
			    (intrmapptr ==
				psycho_psychoreg_vaddr(sc, pcia_slot2_int) ||
			    intrmapptr ==
				psycho_psychoreg_vaddr(sc, pcia_slot3_int)))
				continue;

d1030 1
a1030 1
	    "\ninstalling handler %p arg %p with number %x pil %u",
d1053 1
a1053 1
		DPRINTF(PDB_INTR, ("; reread intrmap = %016qx",
d1063 7
a1069 3
psycho_dmamap_create(bus_dma_tag_t t, bus_dma_tag_t t0, bus_size_t size,
    int nsegments, bus_size_t maxsegsz, bus_size_t boundary, int flags,
    bus_dmamap_t *dmamp)
d1071 1
a1071 1
	struct psycho_pbm *pp = t->_cookie;
d1074 1
a1074 2
	return (iommu_dvmamap_create(t0, sc->sc_is, &pp->pp_sb, size,
	    nsegments, maxsegsz, boundary, flags, dmamp));
d1078 3
a1080 1
psycho_dvmamap_destroy(bus_dma_tag_t t, bus_dma_tag_t t0, bus_dmamap_t map)
d1082 4
a1085 1
	iommu_dvmamap_destroy(t0, map); 
d1089 7
a1095 2
psycho_dmamap_load(bus_dma_tag_t t, bus_dma_tag_t t0, bus_dmamap_t map,
    void *buf, bus_size_t buflen, struct proc *p, int flags)
d1097 1
a1097 1
	struct psycho_pbm *pp = t->_cookie;
d1100 1
a1100 4
	if (pp->pp_sb.sb_flush == NULL)
		flags &= ~BUS_DMA_STREAMING;

	return (iommu_dvmamap_load(t0, sc->sc_is, map, buf, buflen, p, flags));
d1104 6
a1109 1
psycho_dmamap_unload(bus_dma_tag_t t, bus_dma_tag_t t0, bus_dmamap_t map)
d1111 1
a1111 1
	struct psycho_pbm *pp = t->_cookie;
d1114 11
a1124 1
	iommu_dvmamap_unload(t0, sc->sc_is, map);
d1128 9
a1136 2
psycho_dmamap_load_raw(bus_dma_tag_t t, bus_dma_tag_t t0, bus_dmamap_t map,
    bus_dma_segment_t *segs, int nsegs, bus_size_t size, int flags)
d1138 1
a1138 1
	struct psycho_pbm *pp = t->_cookie;
d1141 2
a1142 5
	if (pp->pp_sb.sb_flush == NULL)
		flags &= ~BUS_DMA_STREAMING;

	return (iommu_dvmamap_load_raw(t0, sc->sc_is, map, segs, nsegs, flags,
	    size));
d1146 4
a1149 2
psycho_dmamap_sync(bus_dma_tag_t t, bus_dma_tag_t t0, bus_dmamap_t map, bus_addr_t offset,
    bus_size_t len, int ops)
d1151 1
a1151 1
	struct psycho_pbm *pp = t->_cookie;
d1154 1
a1154 18
	if (t->_parent == NULL)
		panic("psycho_dmamap_sync: no parent");
	
	for (t = t->_parent; t->_dmamap_sync == NULL; t = t->_parent)
		if (t == NULL)
			panic("psycho_dmamap_sync: can't find implementation");

	if (ops & (BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE)) {
		/* Flush the CPU then the IOMMU */
		(*t->_dmamap_sync)(t, t0, map, offset, len,
		    ops);
		iommu_dvmamap_sync(t0, sc->sc_is, map, offset, len, ops);
	}
	if (ops & (BUS_DMASYNC_POSTREAD|BUS_DMASYNC_POSTWRITE)) {
		/* Flush the IOMMU then the CPU */
		iommu_dvmamap_sync(t0, sc->sc_is, map, offset, len, ops);
		(*t->_dmamap_sync)(t, t0, map, offset, len, ops);
	}
d1158 7
a1164 3
psycho_dmamem_alloc(bus_dma_tag_t t, bus_dma_tag_t t0, bus_size_t size, bus_size_t alignment,
    bus_size_t boundary, bus_dma_segment_t *segs, int nsegs, int *rsegs,
    int flags)
d1166 1
a1166 1
	struct psycho_pbm *pp = t->_cookie;
d1169 1
a1169 2
	return (iommu_dvmamem_alloc(t0, sc->sc_is, size, alignment, boundary,
	    segs, nsegs, rsegs, flags));
d1173 4
a1176 1
psycho_dmamem_free(bus_dma_tag_t t, bus_dma_tag_t t0, bus_dma_segment_t *segs, int nsegs)
d1178 1
a1178 1
	struct psycho_pbm *pp = t->_cookie;
d1181 1
a1181 1
	iommu_dvmamem_free(t0, sc->sc_is, segs, nsegs);
d1184 5
a1188 3
int
psycho_dmamem_map(bus_dma_tag_t t, bus_dma_tag_t t0, bus_dma_segment_t *segs, int nsegs,
    size_t size, caddr_t *kvap, int flags)
d1190 1
a1190 1
	struct psycho_pbm *pp = t->_cookie;
d1192 1
d1194 19
a1212 2
	return (iommu_dvmamem_map
	    (t0, sc->sc_is, segs, nsegs, size, kvap, flags));
d1216 5
a1220 1
psycho_dmamem_unmap(bus_dma_tag_t t, bus_dma_tag_t t0, caddr_t kva, size_t size)
d1222 1
a1222 1
	struct psycho_pbm *pp = t->_cookie;
d1225 15
a1239 1
	iommu_dvmamem_unmap(t0, sc->sc_is, kva, size);
a1240 1

@


1.8
log
@Pull in several changes from NetBSD:
- Clear the dmamap inside splhigh() protection.
- Manage both streaming caches on psycho/psycho+.
And fix a botch I created when merging iommu changes last time.
@
text
@d1 1
a1 1
/*	$OpenBSD: psycho.c,v 1.7 2001/09/27 20:45:34 jason Exp $	*/
d872 3
d886 1
a886 1
		return (bus_space_map2(sc->sc_bustag, t->type, paddr,
@


1.8.4.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.8.4.2
log
@Merge in trunk
@
text
@a36 2
#include "uperf_psycho.h"

d94 2
a95 1
paddr_t psycho_bus_mmap __P((bus_space_tag_t, bus_addr_t, off_t, int, int));
a412 10
#if NUPERF_PSYCHO > 0
		if (sc->sc_mode == PSYCHO_MODE_PSYCHO) {
			struct uperf_psycho_attach_args upaa;

			upaa.upaa_name = "uperf";
			upaa.upaa_regs = &sc->sc_regs->psy_pm;

			(void)config_found(self, &upaa, psycho_print);
		}
#endif
a434 1
#if 0
a437 1
#endif
a524 2
	if (ih == NULL)
		panic("couldn't malloc intrhand");
a871 3
	if (btype == 0)
		btype = t->type;

d883 1
a883 1
		return (bus_space_map2(sc->sc_bustag, btype, paddr,
d890 2
a891 2
paddr_t
psycho_bus_mmap(t, paddr, off, prot, flags)
d893 1
a894 2
	off_t off;
	int prot;
d896 1
d905 1
a905 2
	DPRINTF(PDB_BUSMAP, ("_psycho_bus_mmap: prot %d flags %d pa %qx\n",
	    prot, flags, (unsigned long long)paddr));
d915 1
a915 2
		DPRINTF(PDB_BUSMAP, ("\n_psycho_bus_mmap: mapping paddr "
		    "space %lx offset %lx paddr %qx\n",
d918 1
a918 1
		return (bus_space_mmap(sc->sc_bustag, paddr, off, prot, flags));
@


1.8.4.3
log
@Merge in -current from about a week ago
@
text
@d73 6
a78 6
static pci_chipset_tag_t psycho_alloc_chipset(struct psycho_pbm *, int,
    pci_chipset_tag_t);
void psycho_get_bus_range(int, int *);
void psycho_get_ranges(int, struct psycho_ranges **, int *);
void psycho_set_intr(struct psycho_softc *, int, void *, 
    u_int64_t *, u_int64_t *);
d81 7
a87 7
int psycho_ue(void *);
int psycho_ce(void *);
int psycho_bus_a(void *);
int psycho_bus_b(void *);
int psycho_bus_error(struct psycho_softc *, int);
int psycho_powerfail(void *);
int psycho_wakeup(void *);
d90 1
a90 1
void psycho_iommu_init(struct psycho_softc *, int);
d96 19
a114 19
paddr_t psycho_bus_mmap(bus_space_tag_t, bus_addr_t, off_t, int, int);
int _psycho_bus_map(bus_space_tag_t, bus_type_t, bus_addr_t,
    bus_size_t, int, vaddr_t, bus_space_handle_t *);
void *psycho_intr_establish(bus_space_tag_t, int, int, int,
    int (*)(void *), void *);

int psycho_dmamap_load(bus_dma_tag_t, bus_dmamap_t, void *,
    bus_size_t, struct proc *, int);
void psycho_dmamap_unload(bus_dma_tag_t, bus_dmamap_t);
int psycho_dmamap_load_raw(bus_dma_tag_t, bus_dmamap_t,
    bus_dma_segment_t *, int, bus_size_t, int);
void psycho_dmamap_sync(bus_dma_tag_t, bus_dmamap_t, bus_addr_t,
    bus_size_t, int);
int psycho_dmamem_alloc(bus_dma_tag_t, bus_size_t, bus_size_t, bus_size_t,
    bus_dma_segment_t *, int, int *, int);
void psycho_dmamem_free(bus_dma_tag_t, bus_dma_segment_t *, int);
int psycho_dmamem_map(bus_dma_tag_t, bus_dma_segment_t *, int, size_t,
    caddr_t *, int);
void psycho_dmamem_unmap(bus_dma_tag_t, caddr_t, size_t);
d122 4
a125 4
int	psycho_match(struct device *, void *, void *);
void	psycho_attach(struct device *, struct device *, void *);
int	psycho_print(void *aux, const char *p);
int	psycho_get_childspace(int);
d953 1
a953 1
	int (*handler)(void *);
@


1.8.4.4
log
@Sync the SMP branch with 3.3
@
text
@a5 1
 * Copyright (c) 2003 Henric Jungheim
d37 2
d62 1
d67 1
a67 2
#define PDB_CONF	0x08
int psycho_debug = ~0;
d73 1
a73 1
pci_chipset_tag_t psycho_alloc_chipset(struct psycho_pbm *, int,
a78 2
bus_space_tag_t _psycho_alloc_bus_tag(struct psycho_pbm *,
    const char *, int, int, int);
d96 4
a99 5
paddr_t psycho_bus_mmap(bus_space_tag_t, bus_space_tag_t, bus_addr_t, off_t,
    int, int);
int _psycho_bus_map(bus_space_tag_t, bus_space_tag_t, bus_addr_t,
    bus_size_t, int, bus_space_handle_t *);
void *psycho_intr_establish(bus_space_tag_t, bus_space_tag_t, int, int, int,
d102 1
a102 4
int psycho_dmamap_create(bus_dma_tag_t, bus_dma_tag_t, bus_size_t, int, bus_size_t,
    bus_size_t, int, bus_dmamap_t *);
void psycho_dvmamap_destroy(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t);
int psycho_dmamap_load(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t, void *,
d104 2
a105 2
void psycho_dmamap_unload(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t);
int psycho_dmamap_load_raw(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t,
d107 1
a107 1
void psycho_dmamap_sync(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t, bus_addr_t,
d109 1
a109 1
int psycho_dmamem_alloc(bus_dma_tag_t, bus_dma_tag_t, bus_size_t, bus_size_t, bus_size_t,
d111 2
a112 2
void psycho_dmamem_free(bus_dma_tag_t, bus_dma_tag_t, bus_dma_segment_t *, int);
int psycho_dmamem_map(bus_dma_tag_t, bus_dma_tag_t, bus_dma_segment_t *, int, size_t,
d114 1
a114 3
void psycho_dmamem_unmap(bus_dma_tag_t, bus_dma_tag_t, caddr_t, size_t);
void psycho_map_psycho(struct psycho_softc *, int, bus_addr_t, bus_size_t,
    bus_addr_t, bus_size_t);
d125 1
d145 1
a145 1
 * "psycho+" controls both a 64-bit 33MHz and a 64-bit 66MHz PCI bus.  You
d188 4
a191 1
psycho_match(struct device *parent, void *match, void *aux)
d225 3
a227 1
psycho_attach(struct device *parent, struct device *self, void *aux)
d234 1
d237 1
d247 1
a247 1
	 * call the model-specific initialization routine.
d279 4
a282 3
			psycho_map_psycho(sc, 0,
			    ma->ma_address[2], sizeof(struct psychoreg),
			    ma->ma_address[0], sizeof(struct pci_ctl));
d284 4
a287 1
			psycho_map_psycho(sc, 1,
d289 10
a298 1
			    ma->ma_reg[0].ur_paddr, ma->ma_reg[0].ur_len);
d306 3
a308 5
			psycho_map_psycho(sc, 0,
			    ma->ma_address[0], sizeof(struct psychoreg),
			    ma->ma_address[0] +
				offsetof(struct psychoreg, psy_pcictl[0]),
			    sizeof(struct pci_ctl));
d310 4
a313 1
			psycho_map_psycho(sc, 1,
d315 4
a318 3
			    ma->ma_reg[0].ur_paddr +
				offsetof(struct psychoreg, psy_pcictl[0]),
			    sizeof(struct pci_ctl));
d324 1
a324 1
	csr = psycho_psychoreg_read(sc, psy_csr);
d354 1
d360 2
a361 1
	csr = psycho_pcictl_read(sc, pci_csr);
d366 3
a368 1
	psycho_pcictl_write(sc, pci_csr, csr);
d392 1
a392 1
	pp->pp_pcictl = sc->sc_pcictl;
d399 1
a399 1
	                (pp->pp_iot ? PCI_FLAGS_IO_ENABLED  : 0);
d405 1
a405 1
	pba.pba_pc = pp->pp_pc;
d413 7
d421 3
a423 2
	if (osc == NULL) {
		uint64_t timeo;
d435 2
a436 2
		    psycho_psychoreg_vaddr(sc, ue_int_map),
		    psycho_psychoreg_vaddr(sc, ue_clr_int));
d438 2
a439 2
		    psycho_psychoreg_vaddr(sc, ce_int_map),
		    psycho_psychoreg_vaddr(sc, ce_clr_int));
d441 2
a442 2
		    psycho_psychoreg_vaddr(sc, pciaerr_int_map),
		    psycho_psychoreg_vaddr(sc, pciaerr_clr_int));
d444 2
a445 2
		    psycho_psychoreg_vaddr(sc, pciberr_int_map),
		    psycho_psychoreg_vaddr(sc, pciberr_clr_int));
d448 2
a449 2
		    psycho_psychoreg_vaddr(sc, power_int_map),
		    psycho_psychoreg_vaddr(sc, power_clr_int));
d452 2
a453 18
		    psycho_psychoreg_vaddr(sc, pwrmgt_int_map),
		    psycho_psychoreg_vaddr(sc, pwrmgt_clr_int));

		/*
		 * Apparently a number of machines with psycho and psycho+
		 * controllers have interrupt latency issues.  We'll try
		 * setting the interrupt retry timeout to 0xff which gives us
		 * a retry of 3-6 usec (which is what sysio is set to) for the
		 * moment, which seems to help alleviate this problem.
		 */
		timeo = psycho_psychoreg_read(sc, intr_retry_timer);
		if (timeo > 0xfff) {
#ifdef DEBUG
			printf("decreasing interrupt retry timeout "
			    "from %lx to 0xff\n", (long)timeo);
#endif
			psycho_psychoreg_write(sc, intr_retry_timer, 0xff);
		}
d459 3
a461 3
		 * We should calculate a TSB size based on the amount of RAM,
		 * number of bus controllers, and number and type of child
		 * devices.
a469 22
		memset(sc->sc_is, 0, sizeof *sc->sc_is);

		if (getproplen(sc->sc_node, "no-streaming-cache") < 0) {
			struct strbuf_ctl *sb = &pp->pp_sb;
			vaddr_t va = (vaddr_t)&pp->pp_flush[0x40];

			/*
			 * Initialize the strbuf_ctl.
			 *
			 * The flush sync buffer must be 64-byte aligned.
			 */

			sb->sb_flush = (void *)(va & ~0x3f);

			sb->sb_bustag = sc->sc_bustag;
			if (bus_space_subregion(sc->sc_bustag, sc->sc_pcictl,
			    offsetof(struct pci_ctl, pci_strbuf),
			    sizeof(struct iommu_strbuf),
			    &sb->sb_sb)) {
				printf("STC0 subregion failed\n");
				sb->sb_flush = 0;
			}
d471 4
a474 3
			/* Point out iommu at the strbuf_ctl. */
			sc->sc_is->is_sb[0] = sb;
		}
d479 3
a481 2
		if (bus_space_map(sc->sc_configtag,
		    sc->sc_basepaddr, 0x01000000, 0, &sc->sc_configaddr))
d483 1
d490 2
a491 25
		if (getproplen(sc->sc_node, "no-streaming-cache") < 0) {
			struct strbuf_ctl *sb = &pp->pp_sb;
			vaddr_t va = (vaddr_t)&pp->pp_flush[0x40];

			/*
			 * Initialize the strbuf_ctl.
			 *
			 * The flush sync buffer must be 64-byte aligned.
			 */

			sb->sb_flush = (void *)(va & ~0x3f);

			sb->sb_bustag = sc->sc_bustag;
			if (bus_space_subregion(sc->sc_bustag, sc->sc_pcictl,
			    offsetof(struct pci_ctl, pci_strbuf),
			    sizeof(struct iommu_strbuf),
			    &sb->sb_sb)) {
				printf("STC1 subregion failed\n");
				sb->sb_flush = 0;
			}

			/* Point out iommu at the strbuf_ctl. */
			sc->sc_is->is_sb[1] = sb;
		}

d496 6
a510 2
	pba.pba_pc->bustag = sc->sc_configtag;
	pba.pba_pc->bushandle = sc->sc_configaddr;
d515 4
a518 3
void
psycho_map_psycho(struct psycho_softc* sc, int do_map, bus_addr_t reg_addr,
    bus_size_t reg_size, bus_addr_t pci_addr, bus_size_t pci_size)
a519 23
	if (do_map) {
		if (bus_space_map(sc->sc_bustag,
		    reg_addr, reg_size, 0, &sc->sc_regsh))
			panic("psycho_attach: cannot map regs");

		if (pci_addr >= reg_addr &&
		    pci_addr + pci_size <= reg_addr + reg_size) {
			if (bus_space_subregion(sc->sc_bustag, sc->sc_regsh,
			    pci_addr - reg_addr, pci_size, &sc->sc_pcictl))
				panic("psycho_map_psycho: map ctl");
		}
		else if (bus_space_map(sc->sc_bustag, pci_addr, pci_size,
		    0, &sc->sc_pcictl))
			panic("psycho_map_psycho: cannot map pci");
	} else {
		if (bus_space_map(sc->sc_bustag, reg_addr, reg_size,
		    BUS_SPACE_MAP_PROMADDRESS, &sc->sc_regsh))
			panic("psycho_map_psycho: cannot map ctl");
		if (bus_space_map(sc->sc_bustag, pci_addr, pci_size,
		    BUS_SPACE_MAP_PROMADDRESS, &sc->sc_pcictl))
			panic("psycho_map_psycho: cannot map pci");
	}
}
a520 3
int
psycho_print(void *aux, const char *p)
{
d527 6
a532 2
psycho_set_intr(struct psycho_softc *sc, int ipl, void *handler,
    u_int64_t *mapper, u_int64_t *clearer)
d544 1
a544 1
	ih->ih_pil = (1 << ipl);
d548 2
a549 3
	    "\ninstalling handler %p arg %p for %s with number %x pil %u",
	    ih->ih_fun, ih->ih_arg, sc->sc_dev.dv_xname, ih->ih_number,
	    ih->ih_pil));
d563 4
a566 1
psycho_alloc_chipset(struct psycho_pbm *pp, int node, pci_chipset_tag_t pc)
d595 1
a595 3
	DPRINTF(PDB_PROM,
	    ("psycho debug: got `bus-range' for node %08x: %u - %u\n",
	    node, brp[0], brp[1]));
d599 4
a602 1
psycho_get_ranges(int node, struct psycho_ranges **rp, int *np)
d607 1
a607 3
	DPRINTF(PDB_PROM,
	    ("psycho debug: got `ranges' for node %08x: %d entries\n",
	    node, *np));
d615 2
a616 1
psycho_ue(void *arg)
d618 4
a621 3
	struct psycho_softc *sc = arg;
	unsigned long long afsr = psycho_psychoreg_read(sc, psy_ue_afsr);
	unsigned long long afar = psycho_psychoreg_read(sc, psy_ue_afar);
d626 3
a628 6
	panic("%s: uncorrectable DMA error AFAR %llx (pa=%llx tte=%llx/%llx) "
	    "AFSR %llx", sc->sc_dev.dv_xname, afar,
	    iommu_extract(sc->sc_is, (vaddr_t)afar),
	    iommu_lookup_tte(sc->sc_is, (vaddr_t)afar),
	    iommu_fetch_tte(sc->sc_is, (paddr_t)afar),
	    afsr);
d633 2
a634 1
psycho_ce(void *arg)
d636 2
a637 1
	struct psycho_softc *sc = arg;
d645 1
a645 2
	    (long long)psycho_psychoreg_read(sc, psy_ce_afar),
	    (long long)psycho_psychoreg_read(sc, psy_ce_afsr));
d650 3
a652 1
psycho_bus_error(struct psycho_softc *sc, int bus)
d654 1
d657 2
a658 2
	afar = psycho_psychoreg_read(sc, psy_pcictl[bus].pci_afar);
	afsr = psycho_psychoreg_read(sc, psy_pcictl[bus].pci_afsr);
d675 1
a675 1
	psycho_psychoreg_write(sc, psy_pcictl[bus].pci_afsr, bits);
d680 2
a681 1
psycho_bus_a(void *arg)
d683 1
a683 1
	struct psycho_softc *sc = arg;
d689 2
a690 1
psycho_bus_b(void *arg)
d692 1
a692 1
	struct psycho_softc *sc = arg;
d698 2
a699 1
psycho_powerfail(void *arg)
d701 1
d711 2
a712 1
psycho_wakeup(void *arg)
d714 1
a714 1
	struct psycho_softc *sc = arg;
d728 3
a730 1
psycho_iommu_init(struct psycho_softc *sc, int tsbsize)
d740 1
a740 3
	bus_space_subregion(sc->sc_bustag, sc->sc_regsh,
	    offsetof(struct psychoreg, psy_iommu), sizeof(struct iommureg),
	    &is->is_iommu);
d754 1
a754 1
#define	TSBCASE(x)	case 1 << ((x) + 23): tsbsize = (x); break
a762 5
		DPRINTF(PDB_CONF, ("psycho_iommu_init: iobase=0x%x\n", iobase));
	}
	else {
		DPRINTF(PDB_CONF, ("psycho_iommu_init: getprop failed, "
		    "iobase=0x%x\n", iobase));
d767 1
a767 1
	if (name == NULL)
a776 1

d778 3
a780 26
psycho_alloc_mem_tag(struct psycho_pbm *pp)
{
	return (_psycho_alloc_bus_tag(pp, "mem",
	    0x02,	/* 32-bit mem space (where's the #define???) */
	    ASI_PRIMARY, ASI_PRIMARY_LITTLE));
}

bus_space_tag_t
psycho_alloc_io_tag(struct psycho_pbm *pp)
{
	return (_psycho_alloc_bus_tag(pp, "io",
	    0x01,	/* IO space (where's the #define???) */
	    ASI_PHYS_NON_CACHED_LITTLE, ASI_PHYS_NON_CACHED));
}

bus_space_tag_t
psycho_alloc_config_tag(struct psycho_pbm *pp)
{
	return (_psycho_alloc_bus_tag(pp, "cfg",
	    0x00,	/* Config space (where's the #define???) */
	    ASI_PHYS_NON_CACHED_LITTLE, ASI_PHYS_NON_CACHED));
}

bus_space_tag_t
_psycho_alloc_bus_tag(struct psycho_pbm *pp,
    const char *name, int ss, int asi, int sasi)
d783 1
a783 1
	struct sparc_bus_space_tag *bt;
d785 2
a786 1
	bt = malloc(sizeof(*bt), M_DEVBUF, M_NOWAIT);
a790 4
	
	snprintf(bt->name, sizeof(bt->name), "%s-pbm_%s(%d-%2.2x)",
	    	sc->sc_dev.dv_xname, name, ss, asi); 

d793 1
a793 3
	bt->default_type = ss;
	bt->asi = asi;
	bt->sasi = sasi;
a796 1

d801 2
a802 1
psycho_alloc_dma_tag(struct psycho_pbm *pp)
d815 3
a817 2
	dt->_dmamap_create = psycho_dmamap_create;
	dt->_dmamap_destroy = psycho_dvmamap_destroy;
d819 2
d828 2
d839 37
a875 2
_psycho_bus_map(bus_space_tag_t t, bus_space_tag_t t0, bus_addr_t offset,
    bus_size_t size, int flags, bus_space_handle_t *hp)
d878 1
d881 2
a882 3
	DPRINTF(PDB_BUSMAP, ("\n_psycho_bus_map: type %d off %qx sz %qx "
	    "flags %d", t->default_type, (unsigned long long)offset,
	    (unsigned long long)size, flags));
d884 1
a884 1
	ss = t->default_type;
d887 2
a888 11
	if (t->parent == 0 || t->parent->sparc_bus_map == 0) {
		printf("\n_psycho_bus_map: invalid parent");
		return (EINVAL);
	}

	t = t->parent;

	if (flags & BUS_SPACE_MAP_PROMADDRESS) {
		return ((*t->sparc_bus_map)
		    (t, t0, offset, size, flags, hp));
	}
d897 2
a898 4
		paddr |= ((bus_addr_t)pp->pp_range[i].phys_hi << 32);
		DPRINTF(PDB_BUSMAP,
		    ("\n_psycho_bus_map: mapping paddr space %lx offset %lx "
			"paddr %qx",
d901 2
a902 1
		return ((*t->sparc_bus_map)(t, t0, paddr, size, flags, hp));
d909 6
a914 2
psycho_bus_mmap(bus_space_tag_t t, bus_space_tag_t t0, bus_addr_t paddr,
    off_t off, int prot, int flags)
d918 1
d921 1
a921 1
	ss = t->default_type;
d923 1
a923 1
	DPRINTF(PDB_BUSMAP, ("\n_psycho_bus_mmap: prot %d flags %d pa %qx",
a925 7
	if (t->parent == 0 || t->parent->sparc_bus_mmap == 0) {
		printf("\n_psycho_bus_mmap: invalid parent");
		return (-1);
	}

	t = t->parent;

d933 1
a933 1
		paddr |= ((bus_addr_t)pp->pp_range[i].phys_hi << 32);
d935 1
a935 1
		    "space %lx offset %lx paddr %qx",
d938 1
a938 1
		return ((*t->sparc_bus_mmap)(t, t0, paddr, off, prot, flags));
d948 7
a954 2
psycho_intr_establish(bus_space_tag_t t, bus_space_tag_t t0, int ihandle,
    int level, int flags, int (*handler)(void *), void *arg)
d980 1
a980 2
	DPRINTF(PDB_INTR,
	    ("\npsycho_intr_establish: ihandle %x vec %lx", ihandle, vec));
d985 1
a985 2
	if (level == IPL_NONE)
		level = INTLEV(vec);
d994 1
a994 2
		DPRINTF(PDB_INTR,
		    ("\npsycho: intr %lx: %p\nHunting for IRQ...\n",
d998 4
a1001 5
		for (intrmapptr = psycho_psychoreg_vaddr(sc, scsi_int_map),
		    intrclrptr = psycho_psychoreg_vaddr(sc, scsi_clr_int);
		    intrmapptr < (volatile u_int64_t *)
			psycho_psychoreg_vaddr(sc, ffb0_int_map);
		    intrmapptr++, intrclrptr++) {
d1007 4
a1010 13
		for (intrmapptr = psycho_psychoreg_vaddr(sc, pcia_slot0_int),
		    intrclrptr = psycho_psychoreg_vaddr(sc, pcia0_clr_int[0]);
		    intrmapptr <= (volatile u_int64_t *)
			psycho_psychoreg_vaddr(sc, pcib_slot3_int);
		    intrmapptr++, intrclrptr += 4) {
			/* Skip PCI-A Slot 2 and PCI-A Slot 3 on psycho's */
			if (sc->sc_mode == PSYCHO_MODE_PSYCHO &&
			    (intrmapptr ==
				psycho_psychoreg_vaddr(sc, pcia_slot2_int) ||
			    intrmapptr ==
				psycho_psychoreg_vaddr(sc, pcia_slot3_int)))
				continue;

d1039 1
a1039 1
	    "\ninstalling handler %p arg %p with number %x pil %u",
d1062 1
a1062 1
		DPRINTF(PDB_INTR, ("; reread intrmap = %016qx",
a1064 4
	if (intrclrptr) {
		/* set state to IDLE */
		*intrclrptr = 0;
	}
d1072 7
a1078 3
psycho_dmamap_create(bus_dma_tag_t t, bus_dma_tag_t t0, bus_size_t size,
    int nsegments, bus_size_t maxsegsz, bus_size_t boundary, int flags,
    bus_dmamap_t *dmamp)
d1080 1
a1080 1
	struct psycho_pbm *pp = t->_cookie;
d1083 1
a1083 2
	return (iommu_dvmamap_create(t0, sc->sc_is, &pp->pp_sb, size,
	    nsegments, maxsegsz, boundary, flags, dmamp));
d1087 3
a1089 8
psycho_dvmamap_destroy(bus_dma_tag_t t, bus_dma_tag_t t0, bus_dmamap_t map)
{
	iommu_dvmamap_destroy(t0, map); 
}

int
psycho_dmamap_load(bus_dma_tag_t t, bus_dma_tag_t t0, bus_dmamap_t map,
    void *buf, bus_size_t buflen, struct proc *p, int flags)
d1091 1
a1091 1
	struct psycho_pbm *pp = t->_cookie;
d1094 1
a1094 13
	if (pp->pp_sb.sb_flush == NULL)
		flags &= ~BUS_DMA_STREAMING;

	return (iommu_dvmamap_load(t0, sc->sc_is, map, buf, buflen, p, flags));
}

void
psycho_dmamap_unload(bus_dma_tag_t t, bus_dma_tag_t t0, bus_dmamap_t map)
{
	struct psycho_pbm *pp = t->_cookie;
	struct psycho_softc *sc = pp->pp_sc;

	iommu_dvmamap_unload(t0, sc->sc_is, map);
d1098 7
a1104 2
psycho_dmamap_load_raw(bus_dma_tag_t t, bus_dma_tag_t t0, bus_dmamap_t map,
    bus_dma_segment_t *segs, int nsegs, bus_size_t size, int flags)
d1106 1
a1106 1
	struct psycho_pbm *pp = t->_cookie;
d1109 1
a1109 5
	if (pp->pp_sb.sb_flush == NULL)
		flags &= ~BUS_DMA_STREAMING;

	return (iommu_dvmamap_load_raw(t0, sc->sc_is, map, segs, nsegs, flags,
	    size));
d1113 6
a1118 2
psycho_dmamap_sync(bus_dma_tag_t t, bus_dma_tag_t t0, bus_dmamap_t map, bus_addr_t offset,
    bus_size_t len, int ops)
d1120 1
a1120 1
	struct psycho_pbm *pp = t->_cookie;
a1122 7
	if (t->_parent == NULL)
		panic("psycho_dmamap_sync: no parent");
	
	for (t = t->_parent; t->_dmamap_sync == NULL; t = t->_parent)
		if (t == NULL)
			panic("psycho_dmamap_sync: can't find implementation");

d1125 2
a1126 3
		(*t->_dmamap_sync)(t, t0, map, offset, len,
		    ops);
		iommu_dvmamap_sync(t0, sc->sc_is, map, offset, len, ops);
d1130 2
a1131 2
		iommu_dvmamap_sync(t0, sc->sc_is, map, offset, len, ops);
		(*t->_dmamap_sync)(t, t0, map, offset, len, ops);
d1133 1
d1137 9
a1145 3
psycho_dmamem_alloc(bus_dma_tag_t t, bus_dma_tag_t t0, bus_size_t size, bus_size_t alignment,
    bus_size_t boundary, bus_dma_segment_t *segs, int nsegs, int *rsegs,
    int flags)
d1147 1
a1147 1
	struct psycho_pbm *pp = t->_cookie;
d1150 1
a1150 1
	return (iommu_dvmamem_alloc(t0, sc->sc_is, size, alignment, boundary,
d1155 4
a1158 1
psycho_dmamem_free(bus_dma_tag_t t, bus_dma_tag_t t0, bus_dma_segment_t *segs, int nsegs)
d1160 1
a1160 1
	struct psycho_pbm *pp = t->_cookie;
d1163 1
a1163 1
	iommu_dvmamem_free(t0, sc->sc_is, segs, nsegs);
d1167 7
a1173 2
psycho_dmamem_map(bus_dma_tag_t t, bus_dma_tag_t t0, bus_dma_segment_t *segs, int nsegs,
    size_t size, caddr_t *kvap, int flags)
d1175 1
a1175 1
	struct psycho_pbm *pp = t->_cookie;
d1178 1
a1178 2
	return (iommu_dvmamem_map
	    (t0, sc->sc_is, segs, nsegs, size, kvap, flags));
d1182 4
a1185 1
psycho_dmamem_unmap(bus_dma_tag_t t, bus_dma_tag_t t0, caddr_t kva, size_t size)
d1187 1
a1187 1
	struct psycho_pbm *pp = t->_cookie;
d1190 1
a1190 1
	iommu_dvmamem_unmap(t0, sc->sc_is, kva, size);
a1191 1

@


1.8.4.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: psycho.c,v 1.8.4.4 2003/03/27 23:42:35 niklas Exp $	*/
a46 2
#include <uvm/uvm_extern.h>

a113 2
void psycho_sabre_dvmamap_sync(bus_dma_tag_t, bus_dma_tag_t, bus_dmamap_t,
    bus_size_t, bus_size_t, int);
a121 3
int psycho_intr_map(struct pci_attach_args *, pci_intr_handle_t *);
void psycho_identify_pbm(struct psycho_softc *sc, struct psycho_pbm *pp,
    struct pcibus_attach_args *pa);
d309 1
a309 1
	sc->sc_ign = INTMAP_IGN; /* APB IGN is always 0x1f << 6 = 0x7c */
d415 3
d423 3
a425 8
		if (sc->sc_mode == PSYCHO_MODE_PSYCHO) {
			psycho_set_intr(sc, 15, psycho_bus_b,
			    psycho_psychoreg_vaddr(sc, pciberr_int_map),
			    psycho_psychoreg_vaddr(sc, pciberr_clr_int));
			psycho_set_intr(sc, 1, psycho_wakeup,
			    psycho_psychoreg_vaddr(sc, pwrmgt_int_map),
			    psycho_psychoreg_vaddr(sc, pwrmgt_clr_int));
		}
a536 6
	pba.pba_pc->intr_map = psycho_intr_map;

	if (sc->sc_mode == PSYCHO_MODE_PSYCHO)
		psycho_identify_pbm(sc, pp, &pba);
	else
		pp->pp_id = PSYCHO_PBM_UNKNOWN;
a541 22
psycho_identify_pbm(struct psycho_softc *sc, struct psycho_pbm *pp,
    struct pcibus_attach_args *pa)
{
	vaddr_t pci_va = (vaddr_t)bus_space_vaddr(sc->sc_bustag, sc->sc_pcictl);
	paddr_t pci_pa;

	if (pmap_extract(pmap_kernel(), pci_va, &pci_pa) == 0)
	    pp->pp_id = PSYCHO_PBM_UNKNOWN;
	else switch(pci_pa & 0xffff) {
		case 0x2000:
			pp->pp_id = PSYCHO_PBM_A;
			break;
		case 0x4000:
			pp->pp_id = PSYCHO_PBM_B;
			break;
		default:
			pp->pp_id = PSYCHO_PBM_UNKNOWN;
			break;
	}
}

void
d892 1
a892 4
	if (sc->sc_mode == PSYCHO_MODE_PSYCHO)
		dt->_dmamap_sync = psycho_dmamap_sync;
	else
		dt->_dmamap_sync = psycho_sabre_dvmamap_sync;
a988 46
 * Bus-specific interrupt mapping
 */ 
int
psycho_intr_map(struct pci_attach_args *pa, pci_intr_handle_t *ihp)
{
	struct psycho_pbm *pp = pa->pa_pc->cookie;
	struct psycho_softc *sc = pp->pp_sc;
	u_int dev;
	u_int ino;

	ino = *ihp;

	if ((ino & ~INTMAP_PCIINT) == 0) {
		/*
		 * This deserves some documentation.  Should anyone
		 * have anything official looking, please speak up.
		 */
		if (sc->sc_mode == PSYCHO_MODE_PSYCHO &&
		    pp->pp_id == PSYCHO_PBM_B)
			dev = pa->pa_device - 2;
		else
			dev = pa->pa_device - 1;

		if (ino == 0 || ino > 4) {
			u_int32_t intreg;

			intreg = pci_conf_read(pa->pa_pc, pa->pa_tag,
			     PCI_INTERRUPT_REG);
			
			ino = PCI_INTERRUPT_PIN(intreg) - 1;
		} else
			ino -= 1;

		ino &= INTMAP_PCIINT;
				
		ino |= sc->sc_ign;
		ino |= ((pp->pp_id == PSYCHO_PBM_B) ? INTMAP_PCIBUS : 0);
		ino |= (dev << 2) & INTMAP_PCISLOT;
			
		*ihp = ino;
	}
  
	return (0);
}

/*
d1117 4
a1205 14
}

void
psycho_sabre_dvmamap_sync(bus_dma_tag_t t, bus_dma_tag_t t0, bus_dmamap_t map,
    bus_size_t offset, bus_size_t len, int ops)
{
	struct psycho_pbm *pp = t->_cookie;
	struct psycho_softc *sc = pp->pp_sc;

	if (ops & BUS_DMASYNC_POSTREAD)
		psycho_psychoreg_read(sc, pci_dma_write_sync);

	if (ops & (BUS_DMASYNC_POSTREAD | BUS_DMASYNC_PREWRITE))
		membar(MemIssue);
@


1.8.4.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d104 1
a104 1
    int (*)(void *), void *, const char *);
d106 10
a115 2
int psycho_dmamap_create(bus_dma_tag_t, bus_dma_tag_t, bus_size_t, int,
    bus_size_t, bus_size_t, int, bus_dmamap_t *);
d118 6
d223 1
a223 1
 * SUNW,psycho initialization ...
d489 3
a493 3
		/* Point out iommu at the strbuf_ctl. */
		sc->sc_is->is_sb[0] = &pp->pp_sb;

a530 3
		/* Point out iommu at the strbuf_ctl. */
		sc->sc_is->is_sb[1] = &pp->pp_sb;

d707 1
a707 1
	panic("%s: uncorrectable DMA error AFAR %llx (pa=%lx tte=%llx/%llx) "
d924 5
a928 5
	dt->_dmamap_create	= psycho_dmamap_create;
	dt->_dmamap_destroy	= iommu_dvmamap_destroy;
	dt->_dmamap_load	= iommu_dvmamap_load;
	dt->_dmamap_load_raw	= iommu_dvmamap_load_raw;
	dt->_dmamap_unload	= iommu_dvmamap_unload;
d930 1
a930 1
		dt->_dmamap_sync = iommu_dvmamap_sync;
d933 4
a936 5
	dt->_dmamem_alloc	= iommu_dvmamem_alloc;
	dt->_dmamem_free	= iommu_dvmamem_free;
	dt->_dmamem_map		= iommu_dvmamem_map;
	dt->_dmamem_unmap	= iommu_dvmamem_unmap;

d1079 1
a1079 1
    int level, int flags, int (*handler)(void *), void *arg, const char *what)
d1089 5
d1119 1
a1119 2
	if (flags & BUS_INTR_ESTABLISH_SOFTINTR)
		goto found;
d1121 13
a1133 3
	DPRINTF(PDB_INTR,
	    ("\npsycho: intr %lx: %p\nHunting for IRQ...\n",
	    (long)ino, intrlev[ino]));
d1135 21
a1155 23
	/* Hunt thru obio first */
	for (intrmapptr = psycho_psychoreg_vaddr(sc, scsi_int_map),
	    intrclrptr = psycho_psychoreg_vaddr(sc, scsi_clr_int);
	    intrmapptr < (volatile u_int64_t *)
		psycho_psychoreg_vaddr(sc, ffb0_int_map);
	    intrmapptr++, intrclrptr++) {
		if (INTINO(*intrmapptr) == ino)
			goto found;
	}

	/* Now do PCI interrupts */
	for (intrmapptr = psycho_psychoreg_vaddr(sc, pcia_slot0_int),
	    intrclrptr = psycho_psychoreg_vaddr(sc, pcia0_clr_int[0]);
	    intrmapptr <= (volatile u_int64_t *)
		psycho_psychoreg_vaddr(sc, pcib_slot3_int);
	    intrmapptr++, intrclrptr += 4) {
		/* Skip PCI-A Slot 2 and PCI-A Slot 3 on psycho's */
		if (sc->sc_mode == PSYCHO_MODE_PSYCHO &&
		    (intrmapptr ==
			psycho_psychoreg_vaddr(sc, pcia_slot2_int) ||
		    intrmapptr ==
			psycho_psychoreg_vaddr(sc, pcia_slot3_int)))
			continue;
d1157 4
a1160 4
		if (((*intrmapptr ^ vec) & 0x3c) == 0) {
			intrclrptr += vec & 0x3;
			goto found;
		}
d1162 3
a1164 2
	printf("Cannot find interrupt vector %lx\n", vec);
	return (NULL);
d1166 2
a1167 6
found:
	ih = bus_intr_allocate(t0, handler, arg, ino | sc->sc_ign, level,
	    intrmapptr, intrclrptr, what);
	if (ih == NULL) {
		printf("Cannot allocate interrupt vector %lx\n", vec);
		return (NULL);
d1169 6
d1215 18
d1234 54
a1287 2
	return (iommu_dvmamap_create(t, t0, &pp->pp_sb, size, nsegments,
	    maxsegsz, boundary, flags, dmamp));
d1302 41
@


1.7
log
@psycho_bus_[a|b] are essentially the same function; use a helper to avoid typos
attempt to extract the faulting address from the iommu in the newly defined
psycho_bus_error() function
@
text
@d1 2
a2 2
/*	$OpenBSD: psycho.c,v 1.6 2001/09/26 22:16:55 jason Exp $	*/
/*	$NetBSD: psycho.c,v 1.34 2001/07/20 00:07:13 eeh Exp $	*/
a113 1
int psycho_get_childspace __P((int));
d124 2
d132 1
a132 13
        NULL, "psycho", DV_DULL
};

struct psycho_type {
	char *p_name;
	int p_type;
} psycho_types[] = {
	{ "SUNW,sabre",		PSYCHO_MODE_SABRE	},
	{ "pci180e,a000",	PSYCHO_MODE_SABRE	},
	{ "pci108e,a001",	PSYCHO_MODE_SABRE	},
	{ "SUNW,psycho",	PSYCHO_MODE_PSYCHO	},
	{ "pci108e,8000",	PSYCHO_MODE_PSYCHO	},
	{ NULL, 0 }
d173 12
a184 3
#define ROM_SABRE_MODEL		"SUNW,sabre"
#define ROM_SIMBA_MODEL		"SUNW,simba"
#define ROM_PSYCHO_MODEL	"SUNW,psycho"
a207 1

d361 4
a364 8
	csr |= PCICTL_MRLM |
	       PCICTL_ARB_PARK |
	       PCICTL_ERRINTEN |
	       PCICTL_4ENABLE;
	csr &= ~(PCICTL_SERR |
		 PCICTL_CPU_PRIO |
		 PCICTL_ARB_PRIO |
		 PCICTL_RTRYWAIT);
d452 11
d476 4
d718 1
a718 1
	struct iommu_state *is;
a722 6
	is = malloc(sizeof(struct iommu_state), M_DEVBUF, M_NOWAIT);
	if (is == NULL)
		panic("psycho_iommu_init: malloc is");

	sc->sc_is = is;

a725 5

	if (getproplen(sc->sc_node, "no-streaming-cache") < 0)
		is->is_sb = 0;
	else
		is->is_sb = &sc->sc_regs->psy_iommu_strbuf;
@


1.6
log
@be more specific in psycho_ue case (partially based on NetBSD)
@
text
@d1 1
a1 1
/*	$OpenBSD: psycho.c,v 1.5 2001/09/26 19:34:54 jason Exp $	*/
d83 1
d626 4
a629 3
int 
psycho_bus_a(arg)
	void *arg;
a630 1
	struct psycho_softc *sc = (struct psycho_softc *)arg;
d634 2
a635 2
	afar = regs->psy_pcictl[0].pci_afar;
	afsr = regs->psy_pcictl[0].pci_afsr;
d647 4
a650 2
	printf("%s: PCI bus A error AFAR %llx AFSR %llx\n",
	    sc->sc_dev.dv_xname, afar, afsr);
d652 1
a652 1
	regs->psy_pcictl[1].pci_afsr = bits;
d657 1
a657 1
psycho_bus_b(arg)
a660 2
	struct psychoreg *regs = sc->sc_regs;
	u_int64_t afsr, afar, bits;
d662 2
a663 2
	afar = regs->psy_pcictl[1].pci_afar;
	afsr = regs->psy_pcictl[1].pci_afsr;
d665 5
a669 3
	bits = afsr & (PSY_PCIAFSR_PMA | PSY_PCIAFSR_PTA | PSY_PCIAFSR_PTRY |
	    PSY_PCIAFSR_PPERR | PSY_PCIAFSR_SMA | PSY_PCIAFSR_STA |
	    PSY_PCIAFSR_STRY | PSY_PCIAFSR_SPERR);
d671 1
a671 11
	if (bits == 0)
		return (0);

	/*
	 * It's uncorrectable.  Dump the regs and panic.
	 */
	printf("%s: PCI bus B error AFAR %llx AFSR %llx\n",
	    sc->sc_dev.dv_xname, afar, afsr);

	regs->psy_pcictl[1].pci_afsr = bits;
	return (1);
@


1.5
log
@A little bit of voodoo borrowed from the linux driver: set the
intr_retry_timer a little higher.
@
text
@d1 1
a1 1
/*	$OpenBSD: psycho.c,v 1.4 2001/09/04 15:06:15 jason Exp $	*/
d596 2
d602 3
a604 4

	panic("%s: uncorrectable DMA error AFAR %llx AFSR %llx\n",
	    sc->sc_dev.dv_xname, 
	    (long long)regs->psy_ue_afar, (long long)regs->psy_ue_afsr);
@


1.4
log
@clean up error handling for psycho_bus_[a|b]
move DEBUG defines to after includes to avoid pollution
add more debugging information if DEBUG is defined.
@
text
@d1 1
a1 1
/*	$OpenBSD: psycho.c,v 1.3 2001/09/01 17:12:19 jason Exp $	*/
d472 6
@


1.3
log
@remove statics & KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: psycho.c,v 1.2 2001/08/29 04:59:57 jason Exp $	*/
a36 10
#ifdef DEBUG
#define PDB_PROM	0x01
#define PDB_BUSMAP	0x02
#define PDB_INTR	0x04
int psycho_debug = 0x0;
#define DPRINTF(l, s)   do { if (psycho_debug & l) printf s; } while (0)
#else
#define DPRINTF(l, s)
#endif

d60 11
d516 5
d624 11
d639 2
d642 1
a642 3
	panic("%s: PCI bus A error AFAR %llx AFSR %llx\n",
	    sc->sc_dev.dv_xname, 
	    (long long)regs->psy_ue_afar, (long long)regs->psy_ue_afsr);
d652 11
d667 2
d670 1
a670 3
	panic("%s: PCI bus B error AFAR %llx AFSR %llx\n",
	    sc->sc_dev.dv_xname, 
	    (long long)regs->psy_ue_afar, (long long)regs->psy_ue_afsr);
d1022 2
a1023 2
	    "; installing handler %p arg %p with ino %u pil %u\n",
	    handler, arg, (u_int)ino, (u_int)ih->ih_pil));
@


1.2
log
@- modify probe routine to check the 'compatible' property for matching and
lengthen the list of supported devices (this allows us to match the psycho
on the SUNW,Ultra-1-Engine).
- pretty some debugging code
- rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d71 5
a75 5
						   pci_chipset_tag_t));
static void psycho_get_bus_range __P((int, int *));
static void psycho_get_ranges __P((int, struct psycho_ranges **, int *));
static void psycho_set_intr __P((struct psycho_softc *, int, void *, 
	u_int64_t *, u_int64_t *));
d78 6
a83 7
static int psycho_ue __P((void *));
static int psycho_ce __P((void *));
static int psycho_bus_a __P((void *));
static int psycho_bus_b __P((void *));
static int psycho_powerfail __P((void *));
static int psycho_wakeup __P((void *));

d86 1
a86 1
static void psycho_iommu_init __P((struct psycho_softc *, int));
d92 14
a105 15
static int psycho_bus_mmap __P((bus_space_tag_t, bus_type_t, bus_addr_t,
				int, bus_space_handle_t *));
static int _psycho_bus_map __P((bus_space_tag_t, bus_type_t, bus_addr_t,
				bus_size_t, int, vaddr_t,
				bus_space_handle_t *));
static void *psycho_intr_establish __P((bus_space_tag_t, int, int, int,
				int (*) __P((void *)), void *));

static int psycho_dmamap_load __P((bus_dma_tag_t, bus_dmamap_t, void *,
				   bus_size_t, struct proc *, int));
static void psycho_dmamap_unload __P((bus_dma_tag_t, bus_dmamap_t));
static int psycho_dmamap_load_raw __P((bus_dma_tag_t, bus_dmamap_t,
		    bus_dma_segment_t *, int, bus_size_t, int));
static void psycho_dmamap_sync __P((bus_dma_tag_t, bus_dmamap_t, bus_addr_t,
				    bus_size_t, int));
d107 1
a107 1
			     bus_dma_segment_t *, int, int *, int));
d110 1
a110 1
			   caddr_t *, int));
d112 1
d120 3
a122 3
static	int	psycho_match __P((struct device *, void *, void *));
static	void	psycho_attach __P((struct device *, struct device *, void *));
static	int	psycho_print __P((void *aux, const char *p));
d186 1
a186 1
static	int
d224 1
a224 1
static	void
d280 1
a280 1
				(u_long)ma->ma_address[2];
d282 1
a282 1
				(u_long)ma->ma_address[0];
d288 2
a289 2
				ma->ma_reg[2].ur_paddr,
				ma->ma_reg[2].ur_len, 0, NULL, &handle))
d294 2
a295 2
				ma->ma_reg[0].ur_paddr,
				ma->ma_reg[0].ur_len, 0, NULL, &handle))
a298 1

d301 1
a301 1
				ma->ma_nreg);
d307 1
a307 1
				(u_long)ma->ma_address[0];
d314 2
a315 2
				ma->ma_reg[0].ur_paddr,
				ma->ma_reg[0].ur_len, 0, NULL, &handle))
d321 1
a321 1
				ma->ma_nreg);
a337 1

d339 1
a339 1
			(struct psycho_softc *)psycho_cd.cd_devs[n];
d361 1
a361 1
			(bus_space_handle_t)(u_long)&pci_ctl->pci_csr, 0);
d371 1
a371 1
			(bus_space_handle_t)(u_long)&pci_ctl->pci_csr, 0, csr);
d403 1
a403 1
		       (pp->pp_iot ? PCI_FLAGS_IO_ENABLED : 0);
d429 2
a430 2
			&sc->sc_regs->ue_int_map, 
			&sc->sc_regs->ue_clr_int);
d432 2
a433 2
			&sc->sc_regs->ce_int_map, 
			&sc->sc_regs->ce_clr_int);
d435 2
a436 2
			&sc->sc_regs->pciaerr_int_map, 
			&sc->sc_regs->pciaerr_clr_int);
d438 2
a439 2
			&sc->sc_regs->pciberr_int_map, 
			&sc->sc_regs->pciberr_clr_int);
d441 2
a442 2
			&sc->sc_regs->power_int_map, 
			&sc->sc_regs->power_clr_int);
d444 2
a445 2
			&sc->sc_regs->pwrmgt_int_map, 
			&sc->sc_regs->pwrmgt_clr_int);
d461 2
a462 6
				  PCI_CONFIG_BUS_SPACE,
				  sc->sc_basepaddr + 0x01000000,
				  0x0100000,
				  0,
				  0,
				  &bh))
d486 1
a486 1
static	int
d497 1
a497 1
static void
d508 1
a508 1
		M_DEVBUF, M_NOWAIT);
d526 1
a526 1
static pci_chipset_tag_t
d548 1
a548 1
static void
d562 1
a562 1
static void
d578 1
a578 1
static int
d590 2
a591 2
		sc->sc_dev.dv_xname, 
		(long long)regs->psy_ue_afar, (long long)regs->psy_ue_afsr);
d594 2
a595 1
static int 
d607 2
a608 2
		sc->sc_dev.dv_xname, 
		(long long)regs->psy_ce_afar, (long long)regs->psy_ce_afsr);
d611 2
a612 1
static int 
d624 2
a625 2
		sc->sc_dev.dv_xname, 
		(long long)regs->psy_ue_afar, (long long)regs->psy_ue_afsr);
d628 2
a629 1
static int 
d641 2
a642 2
		sc->sc_dev.dv_xname, 
		(long long)regs->psy_ue_afar, (long long)regs->psy_ue_afsr);
d645 2
a646 1
static int 
d658 3
a660 2
static 
int psycho_wakeup(arg)
a672 2


d798 2
a799 4
static int get_childspace __P((int));

static int
get_childspace(type)
d821 1
a821 1
		panic("get_childspace: unknown bus type");
d827 1
a827 1
static int
d844 1
a844 1
	ss = get_childspace(t->type);
d856 2
a857 2
			       (long)ss, (long)offset,
			       (unsigned long long)paddr));
d859 1
a859 1
					size, flags, vaddr, hp));
d865 1
a865 1
static int
d878 1
a878 1
	ss = get_childspace(t->type);
d891 3
a893 4
			       (long)ss, (long)offset,
			       (unsigned long long)paddr));
		return (bus_space_mmap(sc->sc_bustag, 0, paddr,
				       flags, hp));
a898 1

d954 1
a954 1
			     intrclrptr = &sc->sc_regs->scsi_clr_int;
d963 1
a963 1
			     intrclrptr = &sc->sc_regs->pcia0_clr_int[0];
@


1.1
log
@psycho -> the pci host bridge on Ultra 5s.
From NetBSD.
@
text
@d1 1
d133 12
d194 2
a195 1
	char *model = getpropstring(ma->ma_node, "model");
d198 11
a208 4
	if (strcmp(ma->ma_name, ROM_PCI_NAME) == 0 &&
	    (strcmp(model, ROM_SABRE_MODEL) == 0 ||
	     strcmp(model, ROM_PSYCHO_MODEL) == 0))
		return (1);
d239 1
a239 1
	char *model = getpropstring(ma->ma_node, "model");
d251 13
a263 6
	if (strcmp(model, ROM_SABRE_MODEL) == 0)
		sc->sc_mode = PSYCHO_MODE_SABRE;
	else if (strcmp(model, ROM_PSYCHO_MODEL) == 0)
		sc->sc_mode = PSYCHO_MODE_PSYCHO;
	else
		panic("psycho_attach: unknown model %s?", model);
d331 3
a333 3
	printf("%s: impl %d, version %d: ign %x ",
		model, PSYCHO_GCSR_IMPL(csr), PSYCHO_GCSR_VERS(csr),
		sc->sc_ign);
d1022 1
a1022 1
		DPRINTF(PDB_INTR, ("; writing intrmap = %016qx\n",
d1025 1
a1025 1
		DPRINTF(PDB_INTR, ("; reread intrmap = %016qx",
@

