head	1.3;
access;
symbols
	OPENBSD_6_1:1.3.0.10
	OPENBSD_6_1_BASE:1.3
	OPENBSD_6_0:1.3.0.6
	OPENBSD_6_0_BASE:1.3
	OPENBSD_5_9:1.3.0.2
	OPENBSD_5_9_BASE:1.3
	OPENBSD_5_8:1.3.0.4
	OPENBSD_5_8_BASE:1.3
	OPENBSD_5_7:1.2.0.24
	OPENBSD_5_7_BASE:1.2
	OPENBSD_5_6:1.2.0.28
	OPENBSD_5_6_BASE:1.2
	OPENBSD_5_5:1.2.0.26
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.2.0.22
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.20
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.18
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.16
	OPENBSD_5_0:1.2.0.14
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.12
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.10
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.2.0.6
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.8
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.4
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2;
locks; strict;
comment	@ * @;


1.3
date	2015.05.07.00.00.52;	author jsg;	state Exp;
branches;
next	1.2;
commitid	CWzExR2MeAiy4L19;

1.2
date	2008.04.22.01.44.19;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2008.04.21.04.50.23;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.3
log
@add missing braces
ok miod@@
@
text
@/*	$OpenBSD: mgiic.c,v 1.2 2008/04/22 01:44:19 deraadt Exp $	*/
/*
 * Copyright (c) 2008 Theo de Raadt <deraadt@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/device.h>
#include <sys/errno.h>
#include <sys/malloc.h>
#include <sys/systm.h>
#include <sys/rwlock.h>

#include <uvm/uvm_extern.h>

#include <machine/bus.h>
#include <machine/autoconf.h>
#include <machine/openfirm.h>

#include <dev/i2c/i2cvar.h>
#include <sparc64/dev/ofwi2cvar.h>

#define MGSLAVEADDR		0x00
#define MGSLAVEXADDR		0x08
#define MGDATA			0x10
#define MGCONTROL			0x18
#define  MGCONTROL_IEN			0x80
#define  MGCONTROL_ENAB			0x40
#define  MGCONTROL_STA			0x20
#define  MGCONTROL_STP			0x10
#define  MGCONTROL_IFLG			0x08
#define  MGCONTROL_AAK			0x04
#define MGSTATUS		0x20
#define  MGSTATUS_BUSERR		0x00
#define  MGSTATUS_STARTSENT		0x08
#define	 MGSTATUS_REPEATSTART		0x10
#define  MGSTATUS_ADDR_W_ACKR		0x18
#define  MGSTATUS_ADDR_W_NOACKR		0x20
#define  MGSTATUS_MDATA_ACKR		0x28
#define  MGSTATUS_MDATA_NOACKR		0x30
#define  MGSTATUS_ARBLOST		0x38
#define  MGSTATUS_ADDR_R_ACKR		0x40
#define  MGSTATUS_ADDR_R_NOACKR		0x48
#define  MGSTATUS_MDATA_ACKT		0x50
#define  MGSTATUS_MDATA_NOACKT		0x58
#define  MGSTATUS_SADDR_W_ACKT		0x60
#define  MGSTATUS_ARBLOST_SLW_ACKT	0x68
#define  MGSTATUS_GC_TACK		0x70
#define  MGSTATUS_ARBLOST_GC_ACKT	0x78
#define  MGSTATUS_IDLE			0xf8
#define MGCLOCKCONTROL		0x28
#define MGSOFTRESET		0x30

struct mgiic_softc {
	struct device sc_dev;

	bus_space_tag_t		sc_bt;
	bus_space_handle_t	sc_regh;


	int			sc_poll;

	struct i2c_controller	sc_i2c;
	struct rwlock		sc_lock;
};

int			mgiic_match(struct device *, void *, void *);
void			mgiic_attach(struct device *, struct device *, void *);

struct cfdriver mgiic_cd = {
        NULL, "mgiic", DV_DULL
};

struct cfattach mgiic_ca = {
        sizeof(struct mgiic_softc), mgiic_match, mgiic_attach
};

int			mgiic_i2c_acquire_bus(void *, int);
void			mgiic_i2c_release_bus(void *, int);
int			mgiic_i2c_exec(void *, i2c_op_t, i2c_addr_t, const void *,
			    size_t, void *, size_t, int);

int			mgiic_xmit(struct mgiic_softc *, u_int8_t, const u_int8_t *,
			    size_t);
int			mgiic_recv(struct mgiic_softc *, u_int8_t, u_int8_t *, size_t);
volatile u_int8_t	mgiic_read(struct mgiic_softc *, bus_size_t);
volatile void		mgiic_write(struct mgiic_softc *, bus_size_t, u_int8_t);
volatile void		mgiic_control(struct mgiic_softc *, u_int8_t, u_int8_t);
int			mgiic_poll(struct mgiic_softc *);

int
mgiic_match(struct device *parent, void *match, void *aux)
{
	struct mainbus_attach_args *ma = aux;
	char compat[32];

	if (strcmp(ma->ma_name, "i2c") != 0)
		return (0);
	if (OF_getprop(ma->ma_node, "compatible", compat, sizeof(compat)) == -1)
		return (0);
	if (strcmp(compat, "fire-i2c") == 0)
		return (1);
	return (0);
}

void
mgiic_attach(struct device *parent, struct device *self, void *aux)
{
	struct mgiic_softc *sc = (struct mgiic_softc *)self;
	struct mainbus_attach_args *ma = aux;
	struct i2cbus_attach_args iba;

	sc->sc_bt = ma->ma_bustag;

	if (bus_space_map(sc->sc_bt, ma->ma_reg[0].ur_paddr,
	    ma->ma_reg[0].ur_len, 0, &sc->sc_regh)) {
		printf(": failed to map preg\n");
		return;
	}

	rw_init(&sc->sc_lock, "iiclk");
	sc->sc_i2c.ic_cookie = sc;
	sc->sc_i2c.ic_acquire_bus = mgiic_i2c_acquire_bus;
	sc->sc_i2c.ic_release_bus = mgiic_i2c_release_bus;
	sc->sc_i2c.ic_exec = mgiic_i2c_exec;

	printf("\n");

	bzero(&iba, sizeof(iba));
	iba.iba_name = "iic";
	iba.iba_tag = &sc->sc_i2c;
	iba.iba_bus_scan = ofwiic_scan;
	iba.iba_bus_scan_arg = &ma->ma_node;
	config_found(&sc->sc_dev, &iba, iicbus_print);
}

int
mgiic_i2c_acquire_bus(void *arg, int flags)
{
	struct mgiic_softc     *sc = arg;

	if (cold || sc->sc_poll || (flags & I2C_F_POLL))
		return (0);

	return (rw_enter(&sc->sc_lock, RW_WRITE | RW_INTR));
}

void
mgiic_i2c_release_bus(void *arg, int flags)
{
	struct mgiic_softc     *sc = arg;

	if (cold || sc->sc_poll || (flags & I2C_F_POLL))
		return;

	rw_exit(&sc->sc_lock);
}

int
mgiic_i2c_exec(void *arg, i2c_op_t op, i2c_addr_t addr,
    const void *cmdbuf, size_t cmdlen, void *buf, size_t len, int flags)
{
	struct mgiic_softc	*sc = arg;
	int			ret = 0;

	if (addr & ~0x7f)
		return (1);

	if (cold || sc->sc_poll)
		flags |= I2C_F_POLL;

	if (cmdlen > 0) {
		ret = mgiic_xmit(sc, addr & 0x7f, cmdbuf, cmdlen);
		if (ret != 0)
			goto done;
	}

	if (len > 0) {
		if (I2C_OP_WRITE_P(op))
			ret = mgiic_xmit(sc, addr & 0x7f, buf, len);
		else
			ret = mgiic_recv(sc, addr & 0x7f, buf, len);
	}
done:
	printf("e%d\n", ret);
	return (ret);
}

int
mgiic_xmit(struct mgiic_softc *sc, u_int8_t addr, const u_int8_t *buf,
    size_t len)
{
	int err = 1, i = 0;

top:
	printf("xmit s%02x STA ", mgiic_read(sc, MGSTATUS));
	mgiic_control(sc, MGCONTROL_STA, MGCONTROL_IFLG);

	if (mgiic_poll(sc))
		goto bail;
	printf("s%02x ", mgiic_read(sc, MGSTATUS));
	if (mgiic_read(sc, MGSTATUS) != MGSTATUS_STARTSENT)
		goto bail;

	mgiic_write(sc, MGDATA, addr << 1);
	printf("a%02x ", addr << 1);
	mgiic_control(sc, 0, MGCONTROL_IFLG);

	while (i < len) {
		if (mgiic_poll(sc))
			 goto bail;
		printf("s%02x ", mgiic_read(sc, MGSTATUS));
		switch (mgiic_read(sc, MGSTATUS)) {
		case MGSTATUS_ADDR_W_ACKR:
		case MGSTATUS_MDATA_ACKR:
			mgiic_write(sc, MGDATA, buf[i]);
			printf("w%02x ", buf[i]);
			i++;
			mgiic_control(sc, 0, MGCONTROL_IFLG);
			break;
		case MGSTATUS_ADDR_W_NOACKR:
		case MGSTATUS_MDATA_NOACKR:
			mgiic_write(sc, MGDATA, buf[i]);
			printf("w%02x ", buf[i]);
			mgiic_control(sc, 0, MGCONTROL_IFLG);
			break;
		case MGSTATUS_BUSERR:
			mgiic_control(sc, MGCONTROL_STP, MGCONTROL_IFLG);
			i = 0;
			if (mgiic_poll(sc))
				goto bail;
			goto top;
		case MGSTATUS_IDLE:
		default:
			err = 1;
			goto bail;
		}
	}
	printf("OK ");
	err = 0;
bail:
	if (err)
		printf("BAIL STP s%02x\n", mgiic_read(sc, MGSTATUS));
	mgiic_control(sc, MGCONTROL_STP, MGCONTROL_IFLG);
	while (mgiic_read(sc, MGSTATUS) != MGSTATUS_IDLE)
		;
	printf("s%02x\n", mgiic_read(sc, MGSTATUS));
	return (err);
}

int
mgiic_recv(struct mgiic_softc *sc, u_int8_t addr, u_int8_t *buf, size_t len)
{
	int err = 1, i = 0;

	printf("recv s%02x ", mgiic_read(sc, MGSTATUS));
	mgiic_control(sc, MGCONTROL_STA, MGCONTROL_IFLG);
	if (mgiic_poll(sc))
		goto bail;

	printf("s%02x ", mgiic_read(sc, MGSTATUS));
	if (mgiic_read(sc, MGSTATUS) != MGSTATUS_STARTSENT)
		goto bail;

re_address:
	mgiic_write(sc, MGDATA, (addr << 1) | 0x01);
	printf("a%02x ", (addr << 1) | 0x01);
	mgiic_control(sc, 0, MGCONTROL_IFLG);

	while (i < len) {
		if (mgiic_poll(sc))
			goto bail;
		printf("s%02x ", mgiic_read(sc, MGSTATUS));
		switch (mgiic_read(sc, MGSTATUS)) {
		case MGSTATUS_ADDR_R_ACKR:
			if (len - i > 1)
				mgiic_control(sc, MGCONTROL_AAK, MGCONTROL_IFLG);
			else
				mgiic_control(sc, 0, MGCONTROL_IFLG);
			break;
		case MGSTATUS_ADDR_R_NOACKR:
			mgiic_control(sc, MGCONTROL_STA, MGCONTROL_IFLG);
			break;
		case MGSTATUS_REPEATSTART:
			goto re_address;
		case MGSTATUS_MDATA_ACKT:
			buf[i] = mgiic_read(sc, MGDATA);
			printf("r%02x ", buf[i]);
			i++;
			if (len - i > 1)
				mgiic_control(sc, MGCONTROL_AAK, MGCONTROL_IFLG);
			else
				mgiic_control(sc, 0, MGCONTROL_IFLG|MGCONTROL_AAK);
			break;
		case MGSTATUS_MDATA_NOACKT:
			buf[i] = mgiic_read(sc, MGDATA);
			printf("r%02x ", buf[i]);
			i++;
			if (len == i) {
				printf("DONE ");
				err = 0;
				goto bail;
			}
			printf("SHORT ");
			goto bail;
			break;
		default:
			printf("BAD");
			goto bail;
		}
	}
	printf("OK ");
	err = 0;
bail:
	if (err)
		printf("BAIL STP s%02x\n", mgiic_read(sc, MGSTATUS));
	mgiic_control(sc, MGCONTROL_STP, MGCONTROL_IFLG | MGCONTROL_AAK);
	while (mgiic_read(sc, MGSTATUS) != MGSTATUS_IDLE)
		;
	printf("s%02x\n", mgiic_read(sc, MGSTATUS));
	return (err);
}

volatile u_int8_t
mgiic_read(struct mgiic_softc *sc, bus_size_t r)
{
	bus_space_barrier(sc->sc_bt, sc->sc_regh, r, 8,
	    BUS_SPACE_BARRIER_READ);
	return (bus_space_read_8(sc->sc_bt, sc->sc_regh, r)) & 0xff;
}

volatile void
mgiic_write(struct mgiic_softc *sc, bus_size_t r, u_int8_t v)
{
	u_int64_t val = v;

	bus_space_write_8(sc->sc_bt, sc->sc_regh, r, val);
	bus_space_barrier(sc->sc_bt, sc->sc_regh, r, 8,
	    BUS_SPACE_BARRIER_WRITE);
}

volatile void
mgiic_control(struct mgiic_softc *sc, u_int8_t on, u_int8_t off)
{
	u_int8_t val;

	val = (mgiic_read(sc, MGCONTROL) | on) & ~off;
	mgiic_write(sc, MGCONTROL, val);
}

int
mgiic_poll(struct mgiic_softc *sc)
{
	int		i;

	for (i = 0; i < 1000; i++) {
		if (mgiic_read(sc, MGCONTROL) & MGCONTROL_IFLG)
			return (0);
		delay(100);
	}
	return (1);
}
@


1.2
log
@Works better, but still needs debug on to work..
@
text
@d1 1
a1 1
/*	$OpenBSD: mgiic.c,v 1.1 2008/04/21 04:50:23 deraadt Exp $	*/
d183 1
a183 1
	if (cmdlen > 0)
d187 1
@


1.1
log
@Work in progress at supporting the Mentor Graphics i2c core found in
the Fire pcie hostbridge.  Fairly horrid device to deal with.
@
text
@d1 1
a1 1
/*	$OpenBSD: mgiic.c,v 1.2 2008/04/08 22:05:19 kettenis Exp $	*/
d3 1
a3 1
 * Copyright (c) 2008 Mark Kettenis <kettenis@@openbsd.org>
a26 1
#define _SPARC_BUS_DMA_PRIVATE
d34 30
a63 30
#define MGIIC_SLAVEADDR		0x00
#define MGIIC_SLAVEXADDR	0x08
#define MGIIC_DATA		0x10
#define MGIIC_CONTROL		0x18
#define  MGIIC_CONTROL_IEN		0x80
#define  MGIIC_CONTROL_ENAB		0x40
#define  MGIIC_CONTROL_STA		0x20
#define  MGIIC_CONTROL_STP		0x10
#define  MGIIC_CONTROL_IFLG		0x08
#define  MGIIC_CONTROL_AAK		0x04
#define MGIIC_STATUS		0x20
#define  MGIIC_STATUS_BUSERR		0x00
#define  MGIIC_STATUS_STARTSENT		0x08
#define	 MGIIC_STATUS_REPEATSTART	0x10
#define  MGIIC_STATUS_ADDR_W_ACKR	0x18
#define  MGIIC_STATUS_ADDR_W_NOACKR	0x20
#define  MGIIC_STATUS_MDATA_ACKR	0x28
#define  MGIIC_STATUS_MDATA_NOACKR	0x30
#define  MGIIC_STATUS_ARBLOST		0x38
#define  MGIIC_STATUS_ADDR_R_ACKR	0x40	
#define  MGIIC_STATUS_ADDR_R_NOACKR	0x48
#define  MGIIC_STATUS_MDATA_ACKT	0x50
#define  MGIIC_STATUS_MDATA_NOACKT	0x58
#define  MGIIC_STATUS_SADDR_W_ACKT	0x60
#define  MGIIC_STATUS_ARBLOST_SLW_ACKT	0x68
#define  MGIIC_STATUS_GC_TACK		0x70
#define  MGIIC_STATUS_ARBLOST_GC_ACKT	0x78
#define  MGIIC_STATUS_IDLE		0xf8
#define MGIIC_CLOCKCONTROL	0x28
#define MGIIC_SOFTRESET		0x30
d94 2
a95 1
int			mgiic_xmit(struct mgiic_softc *, u_int8_t, const u_int8_t *, size_t);
a109 1

a111 1

a113 1

a122 1
	int i;
a131 5
	printf(": ");
	for (i = 0; i < 7; i++)
		printf("%04x ", mgiic_read(sc, i * 8));
	printf("\n");

d138 2
d175 1
a175 1
	int			ret = 0, i = 0;
d184 3
a186 2
		if (mgiic_xmit(sc, addr & 0x7f, cmdbuf, cmdlen) != 0)
			return (1);
d194 1
a195 3
	for (i = 0; i < 7; i++)
		printf("%04x ", mgiic_read(sc, i * 8));
	printf("\n");
d203 1
a203 2
	int err = 1;
	int i;
d205 3
a207 1
	mgiic_control(sc, MGIIC_CONTROL_STA, 0);
d211 2
a212 1
	if (mgiic_read(sc, MGIIC_STATUS) != 0x08)
d215 5
a219 4
	mgiic_write(sc, MGIIC_DATA, addr << 1);
	mgiic_control(sc, 0, MGIIC_CONTROL_IFLG);
		
	for (i = 0; i < len; i++) {
d221 13
a233 7
			goto bail;
		switch (mgiic_read(sc, MGIIC_STATUS)) {
		case 0x18:
		case 0x20:
		case 0x28:
		case 0x30:
			mgiic_write(sc, MGIIC_DATA, buf[i]);
d235 1
a235 1
			mgiic_control(sc, 0, MGIIC_CONTROL_IFLG);
d237 7
d245 1
d249 1
d252 4
a255 2
	mgiic_control(sc, MGIIC_CONTROL_STP, MGIIC_CONTROL_IFLG);
	while (mgiic_read(sc, MGIIC_STATUS) != 0xf8)
d257 1
d264 1
a264 4
	int err = 1;
	int i;

	mgiic_control(sc, MGIIC_CONTROL_STA, 0);
d266 2
d270 3
a272 1
	if (mgiic_read(sc, MGIIC_STATUS) != 0x08)
d275 4
a278 2
	mgiic_write(sc, MGIIC_DATA, (addr << 1) | 0x01);
	mgiic_control(sc, 0, MGIIC_CONTROL_IFLG);
d280 1
a280 1
	for (i = 0; i < len; ) {
d283 10
a292 6
		switch (mgiic_read(sc, MGIIC_STATUS)) {
		case 0x40:
			mgiic_control(sc, 0, MGIIC_CONTROL_IFLG);
			break;			
		case 0x48:
			mgiic_control(sc, MGIIC_CONTROL_STA, MGIIC_CONTROL_IFLG);
d294 4
a297 3
		case 0x50:
		case 0x58:
			buf[i] = mgiic_read(sc, MGIIC_DATA);
d300 16
a315 1
			mgiic_control(sc, MGIIC_CONTROL_AAK, MGIIC_CONTROL_IFLG);
d318 1
d322 1
d325 4
a328 2
	mgiic_control(sc, MGIIC_CONTROL_STP, MGIIC_CONTROL_IFLG);
	while (mgiic_read(sc, MGIIC_STATUS) != 0xf8)
d330 1
d357 2
a358 3
	val = (mgiic_read(sc, MGIIC_CONTROL) | on) & ~off;
	printf("s%02xc%02x ", mgiic_read(sc, MGIIC_STATUS), val);
	return mgiic_write(sc, MGIIC_CONTROL, val);
d367 1
a367 2
		if (mgiic_read(sc, MGIIC_CONTROL) & MGIIC_CONTROL_IFLG) {
			printf("s%02x ", mgiic_read(sc, MGIIC_STATUS));
a368 1
		}
@

