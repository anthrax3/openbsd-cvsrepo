head	1.8;
access;
symbols
	OPENBSD_6_2_BASE:1.8
	OPENBSD_6_1:1.8.0.4
	OPENBSD_6_1_BASE:1.8;
locks; strict;
comment	@ * @;


1.8
date	2017.03.26.18.27.55;	author drahn;	state Exp;
branches;
next	1.7;
commitid	hJYaUiOIvF89WqMI;

1.7
date	2017.02.18.00.47.18;	author patrick;	state Exp;
branches;
next	1.6;
commitid	tunNIyNIErqpq7Ei;

1.6
date	2017.02.18.00.34.14;	author patrick;	state Exp;
branches;
next	1.5;
commitid	h3LyZDg1Pg2bn8Pw;

1.5
date	2017.02.18.00.19.33;	author patrick;	state Exp;
branches;
next	1.4;
commitid	g3mgqggZPS5femzX;

1.4
date	2017.02.07.21.51.03;	author patrick;	state Exp;
branches;
next	1.3;
commitid	xMeMkQ1gPu0fmwji;

1.3
date	2017.01.23.10.15.53;	author kettenis;	state Exp;
branches;
next	1.2;
commitid	kDWNuU5kVWCWI1Kb;

1.2
date	2017.01.05.21.25.52;	author patrick;	state Exp;
branches;
next	1.1;
commitid	TEZT3PQFqpQA3SfA;

1.1
date	2016.12.17.23.38.33;	author patrick;	state Exp;
branches;
next	;
commitid	uicSPzuCfsvjSNQ4;


desc
@@


1.8
log
@Switch arm64 generic timer to use virtual timer instead of physical
timer. virtual timer will always be present where physical timer may
be disabled by hypervisor. Other OSes use virtual timer. ok patrick@@
@
text
@/* $OpenBSD: agtimer.c,v 1.7 2017/02/18 00:47:18 patrick Exp $ */
/*
 * Copyright (c) 2011 Dale Rahn <drahn@@openbsd.org>
 * Copyright (c) 2013 Patrick Wildt <patrick@@blueri.se>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/queue.h>
#include <sys/malloc.h>
#include <sys/device.h>
#include <sys/kernel.h>
#include <sys/timetc.h>
#include <sys/evcount.h>

#include <machine/intr.h>
#include <machine/bus.h>
#include <machine/fdt.h>

#include <dev/ofw/fdt.h>
#include <dev/ofw/openfirm.h>

/* registers */
#define GTIMER_CNTV_CTL_ENABLE		(1 << 0)
#define GTIMER_CNTV_CTL_IMASK		(1 << 1)
#define GTIMER_CNTV_CTL_ISTATUS		(1 << 2)

#define TIMER_FREQUENCY		24 * 1000 * 1000 /* ARM core clock */
int32_t agtimer_frequency = TIMER_FREQUENCY;

u_int agtimer_get_timecount(struct timecounter *);

static struct timecounter agtimer_timecounter = {
	agtimer_get_timecount, NULL, 0x7fffffff, 0, "agtimer", 0, NULL
};

#define MAX_ARM_CPUS	8

struct agtimer_pcpu_softc {
	uint64_t 		pc_nexttickevent;
	uint64_t 		pc_nextstatevent;
	u_int32_t		pc_ticks_err_sum;
};

struct agtimer_softc {
	struct device		sc_dev;
	int			sc_node;

	struct agtimer_pcpu_softc sc_pstat[MAX_ARM_CPUS];

	u_int32_t		sc_ticks_err_cnt;
	u_int32_t		sc_ticks_per_second;
	u_int32_t		sc_ticks_per_intr;
	u_int32_t		sc_statvar;
	u_int32_t		sc_statmin;

#ifdef AMPTIMER_DEBUG
	struct evcount		sc_clk_count;
	struct evcount		sc_stat_count;
#endif
};

int		agtimer_match(struct device *, void *, void *);
void		agtimer_attach(struct device *, struct device *, void *);
uint64_t	agtimer_readcnt64(void);
int		agtimer_intr(void *);
void		agtimer_cpu_initclocks(void);
void		agtimer_delay(u_int);
void		agtimer_setstatclockrate(int stathz);
void		agtimer_set_clockrate(int32_t new_frequency);
void		agtimer_startclock(void);

struct cfattach agtimer_ca = {
	sizeof (struct agtimer_softc), agtimer_match, agtimer_attach
};

struct cfdriver agtimer_cd = {
	NULL, "agtimer", DV_DULL
};

uint64_t
agtimer_readcnt64(void)
{
	uint64_t val;

	__asm volatile("isb" : : : "memory");
	__asm volatile("MRS %x0, CNTVCT_EL0" : "=r" (val));

	return (val);
}

static inline uint64_t
agtimer_get_freq(void)
{
	uint64_t val;

	__asm volatile("MRS %x0, CNTFRQ_EL0" : "=r" (val));

	return (val);
}

static inline int
agtimer_get_ctrl(void)
{
	uint32_t val;

	__asm volatile("MRS %x0, CNTV_CTL_EL0" : "=r" (val));

	return (val);
}

static inline int
agtimer_set_ctrl(uint32_t val)
{
	__asm volatile("MSR CNTV_CTL_EL0, %x0" : : "r" (val));
	__asm volatile("isb" : : : "memory");

	return (0);
}

static inline int
agtimer_set_tval(uint32_t val)
{
	__asm volatile("MSR CNTV_TVAL_EL0, %x0" : : "r" (val));
	__asm volatile("isb" : : : "memory");

	return (0);
}

int
agtimer_match(struct device *parent, void *cfdata, void *aux)
{
	struct fdt_attach_args *faa = (struct fdt_attach_args *)aux;

	return (OF_is_compatible(faa->fa_node, "arm,armv7-timer") ||
	    OF_is_compatible(faa->fa_node, "arm,armv8-timer"));
}

void
agtimer_attach(struct device *parent, struct device *self, void *aux)
{
	struct agtimer_softc *sc = (struct agtimer_softc *)self;
	struct fdt_attach_args *faa = aux;

	sc->sc_node = faa->fa_node;

	if (agtimer_get_freq() != 0)
		agtimer_frequency = agtimer_get_freq();
	agtimer_frequency =
	    OF_getpropint(sc->sc_node, "clock-frequency", agtimer_frequency);
	sc->sc_ticks_per_second = agtimer_frequency;

	printf(": tick rate %d KHz\n", sc->sc_ticks_per_second /1000);

	/* XXX: disable user access */

#ifdef AMPTIMER_DEBUG
	evcount_attach(&sc->sc_clk_count, "clock", NULL);
	evcount_attach(&sc->sc_stat_count, "stat", NULL);
#endif

	/*
	 * private timer and interrupts not enabled until
	 * timer configures
	 */

	arm_clock_register(agtimer_cpu_initclocks, agtimer_delay,
	    agtimer_setstatclockrate, agtimer_startclock);

	agtimer_timecounter.tc_frequency = sc->sc_ticks_per_second;
	agtimer_timecounter.tc_priv = sc;

	tc_init(&agtimer_timecounter);
}

u_int
agtimer_get_timecount(struct timecounter *tc)
{
	return agtimer_readcnt64();
}

int
agtimer_intr(void *frame)
{
	struct agtimer_softc	*sc = agtimer_cd.cd_devs[0];
	struct agtimer_pcpu_softc *pc = &sc->sc_pstat[CPU_INFO_UNIT(curcpu())];
	uint64_t		 now;
	uint64_t		 nextevent;
	uint32_t		 r;
#if defined(USE_GTIMER_CMP)
	int			 skip = 1;
#else
	int64_t			 delay;
#endif
	int			 rc = 0;

	/*
	 * DSR - I know that the tick timer is 64 bits, but the following
	 * code deals with rollover, so there is no point in dealing
	 * with the 64 bit math, just let the 32 bit rollover
	 * do the right thing
	 */

	now = agtimer_readcnt64();

	while (pc->pc_nexttickevent <= now) {
		pc->pc_nexttickevent += sc->sc_ticks_per_intr;
		pc->pc_ticks_err_sum += sc->sc_ticks_err_cnt;

		/* looping a few times is faster than divide */
		while (pc->pc_ticks_err_sum > hz) {
			pc->pc_nexttickevent += 1;
			pc->pc_ticks_err_sum -= hz;
		}

#ifdef AMPTIMER_DEBUG
		sc->sc_clk_count.ec_count++;
#endif
		rc = 1;
		hardclock(frame);
	}
	while (pc->pc_nextstatevent <= now) {
		do {
			r = random() & (sc->sc_statvar -1);
		} while (r == 0); /* random == 0 not allowed */
		pc->pc_nextstatevent += sc->sc_statmin + r;

		/* XXX - correct nextstatevent? */
#ifdef AMPTIMER_DEBUG
		sc->sc_stat_count.ec_count++;
#endif
		rc = 1;
		statclock(frame);
	}

	if (pc->pc_nexttickevent < pc->pc_nextstatevent)
		nextevent = pc->pc_nexttickevent;
	else
		nextevent = pc->pc_nextstatevent;

	delay = nextevent - now;
	if (delay < 0)
		delay = 1;

	agtimer_set_tval(delay);

	return (rc);
}

void
agtimer_set_clockrate(int32_t new_frequency)
{
	struct agtimer_softc	*sc = agtimer_cd.cd_devs[0];

	agtimer_frequency = new_frequency;

	if (sc == NULL)
		return;

	sc->sc_ticks_per_second = agtimer_frequency;
	agtimer_timecounter.tc_frequency = sc->sc_ticks_per_second;
	printf("agtimer0: adjusting clock: new tick rate %d KHz\n",
	    sc->sc_ticks_per_second /1000);
}

void
agtimer_cpu_initclocks()
{
	struct agtimer_softc	*sc = agtimer_cd.cd_devs[0];
	struct agtimer_pcpu_softc *pc = &sc->sc_pstat[CPU_INFO_UNIT(curcpu())];
	uint32_t		 reg;
	uint64_t		 next;

	stathz = hz;
	profhz = hz * 10;

	if (sc->sc_ticks_per_second != agtimer_frequency) {
		agtimer_set_clockrate(agtimer_frequency);
	}

	agtimer_setstatclockrate(stathz);

	sc->sc_ticks_per_intr = sc->sc_ticks_per_second / hz;
	sc->sc_ticks_err_cnt = sc->sc_ticks_per_second % hz;
	pc->pc_ticks_err_sum = 0;

	/* configure virtual timer interupt */
	arm_intr_establish_fdt_idx(sc->sc_node, 2, IPL_CLOCK,
	    agtimer_intr, NULL, "tick");

	next = agtimer_readcnt64() + sc->sc_ticks_per_intr;
	pc->pc_nexttickevent = pc->pc_nextstatevent = next;

	reg = agtimer_get_ctrl();
	reg &= ~GTIMER_CNTV_CTL_IMASK;
	reg |= GTIMER_CNTV_CTL_ENABLE;
	agtimer_set_tval(sc->sc_ticks_per_second);
	agtimer_set_ctrl(reg);
}

void
agtimer_delay(u_int usecs)
{
	uint64_t		clock, oclock, delta, delaycnt;
	uint64_t		csec, usec;
	volatile int		j;

	if (usecs > (0x80000000 / agtimer_frequency)) {
		csec = usecs / 10000;
		usec = usecs % 10000;

		delaycnt = (agtimer_frequency / 100) * csec +
		    (agtimer_frequency / 100) * usec / 10000;
	} else {
		delaycnt = agtimer_frequency * usecs / 1000000;
	}
	if (delaycnt <= 1)
		for (j = 100; j > 0; j--)
			;

	oclock = agtimer_readcnt64();
	while (1) {
		for (j = 100; j > 0; j--)
			;
		clock = agtimer_readcnt64();
		delta = clock - oclock;
		if (delta > delaycnt)
			break;
	}
}

void
agtimer_setstatclockrate(int newhz)
{
	struct agtimer_softc	*sc = agtimer_cd.cd_devs[0];
	int			 minint, statint;
	int			 s;

	s = splclock();

	statint = sc->sc_ticks_per_second / newhz;
	/* calculate largest 2^n which is smaller that just over half statint */
	sc->sc_statvar = 0x40000000; /* really big power of two */
	minint = statint / 2 + 100;
	while (sc->sc_statvar > minint)
		sc->sc_statvar >>= 1;

	sc->sc_statmin = statint - (sc->sc_statvar >> 1);

	splx(s);

	/*
	 * XXX this allows the next stat timer to occur then it switches
	 * to the new frequency. Rather than switching instantly.
	 */
}

void
agtimer_startclock(void)
{
	struct agtimer_softc	*sc = agtimer_cd.cd_devs[0];
	struct agtimer_pcpu_softc *pc = &sc->sc_pstat[CPU_INFO_UNIT(curcpu())];
	uint64_t nextevent;
	uint32_t reg;

	nextevent = agtimer_readcnt64() + sc->sc_ticks_per_intr;
	pc->pc_nexttickevent = pc->pc_nextstatevent = nextevent;

	reg = agtimer_get_ctrl();
	reg &= ~GTIMER_CNTV_CTL_IMASK;
	reg |= GTIMER_CNTV_CTL_ENABLE;
	agtimer_set_tval(sc->sc_ticks_per_second);
	agtimer_set_ctrl(reg);
}

void
agtimer_init(void)
{
	uint64_t cntfrq = 0;

	/* XXX: Check for Generic Timer support. */
	cntfrq = agtimer_get_freq();

	if (cntfrq != 0) {
		agtimer_frequency = cntfrq;
		arm_clock_register(NULL, agtimer_delay, NULL, NULL);
	}
}
@


1.7
log
@Make sure that the timer control registers are written before any
further code is executed.  Additionally, make sure the counter is
read only after all previous code has executed.
@
text
@d1 1
a1 1
/* $OpenBSD: agtimer.c,v 1.6 2017/02/18 00:34:14 patrick Exp $ */
d36 3
a38 3
#define GTIMER_CNTP_CTL_ENABLE		(1 << 0)
#define GTIMER_CNTP_CTL_IMASK		(1 << 1)
#define GTIMER_CNTP_CTL_ISTATUS		(1 << 2)
d99 1
a99 1
	__asm volatile("MRS %x0, CNTPCT_EL0" : "=r" (val));
d119 1
a119 1
	__asm volatile("MRS %x0, CNTP_CTL_EL0" : "=r" (val));
d127 1
a127 1
	__asm volatile("MSR CNTP_CTL_EL0, %x0" : : "r" (val));
d136 1
a136 1
	__asm volatile("MSR CNTP_TVAL_EL0, %x0" : : "r" (val));
d299 2
a300 4
	/* Setup secure and non-secure timer IRQs. */
	arm_intr_establish_fdt_idx(sc->sc_node, 0, IPL_CLOCK,
	    agtimer_intr, NULL, "tick");
	arm_intr_establish_fdt_idx(sc->sc_node, 1, IPL_CLOCK,
d307 2
a308 2
	reg &= ~GTIMER_CNTP_CTL_IMASK;
	reg |= GTIMER_CNTP_CTL_ENABLE;
d382 2
a383 2
	reg &= ~GTIMER_CNTP_CTL_IMASK;
	reg |= GTIMER_CNTP_CTL_ENABLE;
@


1.6
log
@Bump variables related to arithmetic operations to 64-bit.  Especially
the bump of usec and csec is of concern since a timer frequency of around
187MHz overflows in a 32-bit only calculation, as seen on the AMD Seattle
SoC.  Since we are running a 64-bit architecture, doing 64-bit arithmetic
operations doesn't hurt us as much as on the 32-bit ARMv7 port.
@
text
@d1 1
a1 1
/* $OpenBSD: agtimer.c,v 1.5 2017/02/18 00:19:33 patrick Exp $ */
d98 1
d128 1
a128 3

	//cpu_drain_writebuf();
	//isb();
d137 1
a137 3

	//cpu_drain_writebuf();
	//isb();
@


1.5
log
@Initialize the generic timer early so that its delay function can be
used early, similar to the armv7 implementation.
@
text
@d1 1
a1 1
/* $OpenBSD: agtimer.c,v 1.4 2017/02/07 21:51:03 patrick Exp $ */
d321 2
a322 1
	u_int32_t		clock, oclock, delta, delaycnt;
a323 1
	int			csec, usec;
@


1.4
log
@The default frequency we chose for the generic timer does not always ring
true.  Instead, unless overwritten by the device tree, we should ask the
generic timer for its frequency.  This fixes time on my AMD Seattle and
should improve time management on QEMU as well.
@
text
@d1 1
a1 1
/* $OpenBSD: agtimer.c,v 1.3 2017/01/23 10:15:53 kettenis Exp $ */
d396 1
a396 1
	uint32_t cntfrq = 0;
d399 1
a399 1
	__asm volatile("MRS %x0, CNTFRQ_EL0" : "=r" (cntfrq));
@


1.3
log
@Also attach to "arm,armv7-timer".

ok patrick@@
@
text
@d1 1
a1 1
/* $OpenBSD: agtimer.c,v 1.2 2017/01/05 21:25:52 patrick Exp $ */
d103 10
d162 2
@


1.2
log
@Pass value as input instead of output register, otherwise we write
garbage into the control register.  While there remove positional
argument leftover from the 32-bit version.
@
text
@d1 1
a1 1
/* $OpenBSD: agtimer.c,v 1.1 2016/12/17 23:38:33 patrick Exp $ */
d140 2
a141 1
	return OF_is_compatible(faa->fa_node, "arm,armv8-timer");
@


1.1
log
@Import of OpenBSD/arm64

This commit contains all the kernel files related to the OpenBSD/arm64
port.  It is based on the PowerPC pmap, loongson, arm/armv7 code and
FreeBSD aarch64 code.  Hard work done by Dale Rahn.
@
text
@d1 1
a1 1
/* $OpenBSD: agtimer.c,v 1.8 2016/09/24 13:03:47 kettenis Exp $ */
d116 1
a116 1
	__asm volatile("MSR CNTP_CTL_EL0, %x0" : "=r" (val));
d127 1
a127 1
	__asm volatile("MSR CNTP_TVAL_EL0, %x0" : : [val] "r" (val));
@

