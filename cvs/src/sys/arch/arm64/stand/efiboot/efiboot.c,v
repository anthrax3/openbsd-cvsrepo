head	1.13;
access;
symbols
	OPENBSD_6_1:1.6.0.4
	OPENBSD_6_1_BASE:1.6;
locks; strict;
comment	@ * @;


1.13
date	2017.08.23.18.03.54;	author kettenis;	state Exp;
branches;
next	1.12;
commitid	2wIKEa5dHVLhjcux;

1.12
date	2017.08.22.17.18.21;	author kettenis;	state Exp;
branches;
next	1.11;
commitid	HfdTatJzKCIeKlaU;

1.11
date	2017.08.07.19.34.53;	author kettenis;	state Exp;
branches;
next	1.10;
commitid	9gJdvyH7ZN4Nyv48;

1.10
date	2017.07.31.14.06.29;	author kettenis;	state Exp;
branches;
next	1.9;
commitid	QqR3CEbSXXwoQ8F7;

1.9
date	2017.07.29.19.51.50;	author kettenis;	state Exp;
branches;
next	1.8;
commitid	WpXyuOCnHHogGX4n;

1.8
date	2017.07.24.12.12.09;	author patrick;	state Exp;
branches;
next	1.7;
commitid	58yX8QpUh6nXcm7x;

1.7
date	2017.05.07.11.07.48;	author kettenis;	state Exp;
branches;
next	1.6;
commitid	YMeGkMIyZpsclaDF;

1.6
date	2017.03.11.09.09.14;	author jsg;	state Exp;
branches;
next	1.5;
commitid	LVN2NjaWttDAvafA;

1.5
date	2017.02.08.09.13.25;	author patrick;	state Exp;
branches;
next	1.4;
commitid	tK2JT9fQy7lXXcy3;

1.4
date	2017.02.04.22.43.46;	author patrick;	state Exp;
branches;
next	1.3;
commitid	jgEnVIZdRyE0kG4G;

1.3
date	2017.02.03.08.48.40;	author patrick;	state Exp;
branches;
next	1.2;
commitid	Ji6tTDtVIndbCxtu;

1.2
date	2017.01.22.04.18.52;	author kettenis;	state Exp;
branches;
next	1.1;
commitid	bcjBZper2FyiK4m4;

1.1
date	2016.12.17.23.38.33;	author patrick;	state Exp;
branches;
next	;
commitid	uicSPzuCfsvjSNQ4;


desc
@@


1.13
log
@If the firmware provides a framebuffer through the Graphics Output Protocol,
create a "simple-framebuffer" node such that the kernel can attach the
simplefb(4) driver.  Only do this if such a "simple-framebuffer" node
doesn't exist already.

ok patrick@@, jsg@@
@
text
@/*	$OpenBSD: efiboot.c,v 1.12 2017/08/22 17:18:21 kettenis Exp $	*/

/*
 * Copyright (c) 2015 YASUOKA Masahiko <yasuoka@@yasuoka.net>
 * Copyright (c) 2016 Mark Kettenis
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/queue.h>
#include <dev/cons.h>
#include <sys/disklabel.h>

#include <efi.h>
#include <efiapi.h>
#include <efiprot.h>
#include <eficonsctl.h>

#include <lib/libkern/libkern.h>
#include <stand/boot/cmd.h>

#include "disk.h"
#include "eficall.h"
#include "fdt.h"
#include "libsa.h"

EFI_SYSTEM_TABLE	*ST;
EFI_BOOT_SERVICES	*BS;
EFI_RUNTIME_SERVICES	*RS;
EFI_HANDLE		 IH, efi_bootdp;

EFI_PHYSICAL_ADDRESS	 heap;
UINTN			 heapsiz = 1 * 1024 * 1024;
EFI_MEMORY_DESCRIPTOR	*mmap;
UINTN			 mmap_key;
UINTN			 mmap_ndesc;
UINTN			 mmap_descsiz;
UINT32			 mmap_version;

static EFI_GUID		 imgp_guid = LOADED_IMAGE_PROTOCOL;
static EFI_GUID		 blkio_guid = BLOCK_IO_PROTOCOL;
static EFI_GUID		 devp_guid = DEVICE_PATH_PROTOCOL;
static EFI_GUID		 gop_guid = EFI_GRAPHICS_OUTPUT_PROTOCOL_GUID;

static int efi_device_path_depth(EFI_DEVICE_PATH *dp, int);
static int efi_device_path_ncmp(EFI_DEVICE_PATH *, EFI_DEVICE_PATH *, int);
static void efi_heap_init(void);
static void efi_memprobe_internal(void);
static void efi_timer_init(void);
static void efi_timer_cleanup(void);
static EFI_STATUS efi_memprobe_find(UINTN, UINTN, EFI_PHYSICAL_ADDRESS *);

EFI_STATUS
efi_main(EFI_HANDLE image, EFI_SYSTEM_TABLE *systab)
{
	extern char		*progname;
	EFI_LOADED_IMAGE	*imgp;
	EFI_DEVICE_PATH		*dp = NULL;
	EFI_STATUS		 status;

	ST = systab;
	BS = ST->BootServices;
	IH = image;

	status = EFI_CALL(BS->HandleProtocol, image, &imgp_guid,
	    (void **)&imgp);
	if (status == EFI_SUCCESS)
		status = EFI_CALL(BS->HandleProtocol, imgp->DeviceHandle,
		    &devp_guid, (void **)&dp);
	if (status == EFI_SUCCESS)
		efi_bootdp = dp;

	progname = "BOOTAA64";

	boot(0);

	return (EFI_SUCCESS);
}

static SIMPLE_TEXT_OUTPUT_INTERFACE *conout;
static SIMPLE_INPUT_INTERFACE *conin;

void
efi_cons_probe(struct consdev *cn)
{
	cn->cn_pri = CN_MIDPRI;
	cn->cn_dev = makedev(12, 0);
}

void
efi_cons_init(struct consdev *cp)
{
	conin = ST->ConIn;
	conout = ST->ConOut;
}

int
efi_cons_getc(dev_t dev)
{
	EFI_INPUT_KEY	 key;
	EFI_STATUS	 status;
#if 0
	UINTN		 dummy;
#endif
	static int	 lastchar = 0;

	if (lastchar) {
		int r = lastchar;
		if ((dev & 0x80) == 0)
			lastchar = 0;
		return (r);
	}

	status = conin->ReadKeyStroke(conin, &key);
	while (status == EFI_NOT_READY) {
		if (dev & 0x80)
			return (0);
		/*
		 * XXX The implementation of WaitForEvent() in U-boot
		 * is broken and neverreturns.
		 */
#if 0
		BS->WaitForEvent(1, &conin->WaitForKey, &dummy);
#endif
		status = conin->ReadKeyStroke(conin, &key);
	}

	if (dev & 0x80)
		lastchar = key.UnicodeChar;

	return (key.UnicodeChar);
}

void
efi_cons_putc(dev_t dev, int c)
{
	CHAR16	buf[2];

	if (c == '\n')
		efi_cons_putc(dev, '\r');

	buf[0] = c;
	buf[1] = 0;

	conout->OutputString(conout, buf);
}

static void
efi_heap_init(void)
{
	EFI_STATUS	 status;

	status = EFI_CALL(BS->AllocatePages, AllocateAnyPages, EfiLoaderData,
	    EFI_SIZE_TO_PAGES(heapsiz), &heap);
	if (status != EFI_SUCCESS)
		panic("BS->AllocatePages()");
}

EFI_BLOCK_IO	*disk;

void
efi_diskprobe(void)
{
	int			 i, depth = -1;
	UINTN			 sz;
	EFI_STATUS		 status;
	EFI_HANDLE		*handles = NULL;
	EFI_BLOCK_IO		*blkio;
	EFI_BLOCK_IO_MEDIA	*media;
	EFI_DEVICE_PATH		*dp;

	sz = 0;
	status = EFI_CALL(BS->LocateHandle, ByProtocol, &blkio_guid, 0, &sz, 0);
	if (status == EFI_BUFFER_TOO_SMALL) {
		handles = alloc(sz);
		status = EFI_CALL(BS->LocateHandle, ByProtocol, &blkio_guid,
		    0, &sz, handles);
	}
	if (handles == NULL || EFI_ERROR(status))
		panic("BS->LocateHandle() returns %d", status);

	if (efi_bootdp != NULL)
		depth = efi_device_path_depth(efi_bootdp, MEDIA_DEVICE_PATH);

	/*
	 * U-Boot incorrectly represents devices with a single
	 * MEDIA_DEVICE_PATH component.  In that case include that
	 * component into the matching, otherwise we'll blindly select
	 * the first device.
	 */
	if (depth == 0)
		depth = 1;

	for (i = 0; i < sz / sizeof(EFI_HANDLE); i++) {
		status = EFI_CALL(BS->HandleProtocol, handles[i], &blkio_guid,
		    (void **)&blkio);
		if (EFI_ERROR(status))
			panic("BS->HandleProtocol() returns %d", status);

		media = blkio->Media;
		if (media->LogicalPartition || !media->MediaPresent)
			continue;

		if (efi_bootdp == NULL || depth == -1)
			continue;
		status = EFI_CALL(BS->HandleProtocol, handles[i], &devp_guid,
		    (void **)&dp);
		if (EFI_ERROR(status))
			continue;
		if (efi_device_path_ncmp(efi_bootdp, dp, depth) == 0) {
			disk = blkio;
			break;
		}
	}

	free(handles, sz);
}

/*
 * Determine the number of nodes up to, but not including, the first
 * node of the specified type.
 */
static int
efi_device_path_depth(EFI_DEVICE_PATH *dp, int dptype)
{
	int	i;

	for (i = 0; !IsDevicePathEnd(dp); dp = NextDevicePathNode(dp), i++) {
		if (DevicePathType(dp) == dptype)
			return (i);
	}

	return (-1);
}

static int
efi_device_path_ncmp(EFI_DEVICE_PATH *dpa, EFI_DEVICE_PATH *dpb, int deptn)
{
	int	 i, cmp;

	for (i = 0; i < deptn; i++) {
		if (IsDevicePathEnd(dpa) || IsDevicePathEnd(dpb))
			return ((IsDevicePathEnd(dpa) && IsDevicePathEnd(dpb))
			    ? 0 : (IsDevicePathEnd(dpa))? -1 : 1);
		cmp = DevicePathNodeLength(dpa) - DevicePathNodeLength(dpb);
		if (cmp)
			return (cmp);
		cmp = memcmp(dpa, dpb, DevicePathNodeLength(dpa));
		if (cmp)
			return (cmp);
		dpa = NextDevicePathNode(dpa);
		dpb = NextDevicePathNode(dpb);
	}

	return (0);
}

void
efi_framebuffer(void)
{
	EFI_GRAPHICS_OUTPUT *gop;
	EFI_STATUS status;
	void *node, *child;
	uint32_t acells, scells;
	uint64_t base, size;
	uint32_t reg[4];
	uint32_t width, height, stride;
	char *format;

	/*
	 * Don't create a "simple-framebuffer" node if we already have
	 * one.  Besides "/chosen", we also check under "/" since that
	 * is where the Raspberry Pi firmware puts it.
	 */
	node = fdt_find_node("/chosen");
	for (child = fdt_child_node(node); child;
	     child = fdt_next_node(child)) {
		if (fdt_node_is_compatible(child, "simple-framebuffer"))
			return;
	}
	node = fdt_find_node("/");
	for (child = fdt_child_node(node); child;
	     child = fdt_next_node(child)) {
		if (fdt_node_is_compatible(child, "simple-framebuffer"))
			return;
	}

	status = EFI_CALL(BS->LocateProtocol, &gop_guid, NULL, (void **)&gop);
	if (status != EFI_SUCCESS)
		return;

	/* Paranoia! */
	if (gop == NULL || gop->Mode == NULL || gop->Mode->Info == NULL)
		return;

	/* We only support 32-bit pixel modes for now. */
	switch (gop->Mode->Info->PixelFormat) {
	case PixelRedGreenBlueReserved8BitPerColor:
		format = "a8r8g8b8";
		break;
	case PixelBlueGreenRedReserved8BitPerColor:
		format = "a8b8g8r8";
		break;
	default:
		return;
	}

	base = gop->Mode->FrameBufferBase;
	size = gop->Mode->FrameBufferSize;
	width = htobe32(gop->Mode->Info->HorizontalResolution);
	height = htobe32(gop->Mode->Info->VerticalResolution);
	stride = htobe32(gop->Mode->Info->PixelsPerScanLine * 4);

	node = fdt_find_node("/");
	if (fdt_node_property_int(node, "#address-cells", &acells) != 1)
		acells = 1;
	if (fdt_node_property_int(node, "#size-cells", &scells) != 1)
		scells = 1;
	if (acells > 2 || scells > 2)
		return;
	if (acells >= 1)
		reg[0] = htobe32(base);
	if (acells == 2) {
		reg[1] = reg[0];
		reg[0] = htobe32(base >> 32);
	}
	if (scells >= 1)
		reg[acells] = htobe32(size);
	if (scells == 2) {
		reg[acells + 1] = reg[acells];
		reg[acells] = htobe32(size >> 32);
	}

	node = fdt_find_node("/chosen");
	fdt_node_add_node(node, "framebuffer", &child);
	fdt_node_add_property(child, "status", "okay", strlen("okay") + 1);
	fdt_node_add_property(child, "format", format, strlen(format) + 1);
	fdt_node_add_property(child, "stride", &stride, 4);
	fdt_node_add_property(child, "height", &height, 4);
	fdt_node_add_property(child, "width", &width, 4);
	fdt_node_add_property(child, "reg", reg, (acells + scells) * 4);
	fdt_node_add_property(child, "compatible",
	    "simple-framebuffer", strlen("simple-framebuffer") + 1);
}

static EFI_GUID fdt_guid = FDT_TABLE_GUID;

#define	efi_guidcmp(_a, _b)	memcmp((_a), (_b), sizeof(EFI_GUID))

void *
efi_makebootargs(char *bootargs)
{
	void *fdt = NULL;
	u_char bootduid[8];
	u_char zero[8] = { 0 };
	uint64_t uefi_system_table = htobe64((uintptr_t)ST);
	void *node;
	size_t len;
	int i;

	for (i = 0; i < ST->NumberOfTableEntries; i++) {
		if (efi_guidcmp(&fdt_guid,
		    &ST->ConfigurationTable[i].VendorGuid) == 0)
			fdt = ST->ConfigurationTable[i].VendorTable;
	}

	if (!fdt_init(fdt))
		return NULL;

	node = fdt_find_node("/chosen");
	if (!node)
		return NULL;

	len = strlen(bootargs) + 1;
	fdt_node_add_property(node, "bootargs", bootargs, len);

	/* Pass DUID of the boot disk. */
	memcpy(&bootduid, diskinfo.disklabel.d_uid, sizeof(bootduid));
	if (memcmp(bootduid, zero, sizeof(bootduid)) != 0) {
		fdt_node_add_property(node, "openbsd,bootduid", bootduid,
		    sizeof(bootduid));
	}

	/* Pass EFI system table. */
	fdt_node_add_property(node, "openbsd,uefi-system-table",
	    &uefi_system_table, sizeof(uefi_system_table));

	/* Placeholders for EFI memory map. */
	fdt_node_add_property(node, "openbsd,uefi-mmap-start", zero, 8);
	fdt_node_add_property(node, "openbsd,uefi-mmap-size", zero, 4);
	fdt_node_add_property(node, "openbsd,uefi-mmap-desc-size", zero, 4);
	fdt_node_add_property(node, "openbsd,uefi-mmap-desc-ver", zero, 4);

	efi_framebuffer();

	fdt_finalize();

	return fdt;
}

void
efi_updatefdt(void)
{
	uint64_t uefi_mmap_start = htobe64((uintptr_t)mmap);
	uint32_t uefi_mmap_size = htobe32(mmap_ndesc * mmap_descsiz);
	uint32_t uefi_mmap_desc_size = htobe32(mmap_descsiz);
	uint32_t uefi_mmap_desc_ver = htobe32(mmap_version);
	void *node;

	node = fdt_find_node("/chosen");
	if (!node)
		return;

	/* Pass EFI memory map. */
	fdt_node_set_property(node, "openbsd,uefi-mmap-start",
	    &uefi_mmap_start, sizeof(uefi_mmap_start));
	fdt_node_set_property(node, "openbsd,uefi-mmap-size",
	    &uefi_mmap_size, sizeof(uefi_mmap_size));
	fdt_node_set_property(node, "openbsd,uefi-mmap-desc-size",
	    &uefi_mmap_desc_size, sizeof(uefi_mmap_desc_size));
	fdt_node_set_property(node, "openbsd,uefi-mmap-desc-ver",
	    &uefi_mmap_desc_ver, sizeof(uefi_mmap_desc_ver));

	fdt_finalize();
}

u_long efi_loadaddr;

void
machdep(void)
{
	EFI_PHYSICAL_ADDRESS addr;

	cninit();
	efi_heap_init();

	/*
	 * The kernel expects to be loaded into a block of memory aligned
	 * on a 2MB boundary.  We allocate a block of 64MB of memory, which
	 * gives us plenty of room for growth.
	 */
	if (efi_memprobe_find(EFI_SIZE_TO_PAGES(64 * 1024 * 1024),
	    0x200000, &addr) != EFI_SUCCESS)
		printf("Can't allocate memory\n");
	efi_loadaddr = addr;

	efi_timer_init();
	efi_diskprobe();
}

void
efi_cleanup(void)
{
	int		 retry;
	EFI_STATUS	 status;

	efi_timer_cleanup();

	/* retry once in case of failure */
	for (retry = 1; retry >= 0; retry--) {
		efi_memprobe_internal();	/* sync the current map */
		efi_updatefdt();
		status = EFI_CALL(BS->ExitBootServices, IH, mmap_key);
		if (status == EFI_SUCCESS)
			break;
		if (retry == 0)
			panic("ExitBootServices failed (%d)", status);
	}
}

void
_rtt(void)
{
#ifdef EFI_DEBUG
	printf("Hit any key to reboot\n");
	efi_cons_getc(0);
#endif
	RS->ResetSystem(EfiResetCold, EFI_SUCCESS, 0, NULL);
	for (;;)
		continue;
}

/*
 * U-Boot only implements the GetTime() Runtime Service if it has been
 * configured with CONFIG_DM_RTC.  Most board configurations don't
 * include that option, so we can't use it to implement our boot
 * prompt timeout.  Instead we use timer events to simulate a clock
 * that ticks ever second.
 */

EFI_EVENT timer;
int ticks;

static VOID
efi_timer(EFI_EVENT event, VOID *context)
{
	ticks++;
}

static void
efi_timer_init(void)
{
	EFI_STATUS status;

	status = BS->CreateEvent(EVT_TIMER | EVT_NOTIFY_SIGNAL, TPL_CALLBACK,
	    efi_timer, NULL, &timer);
	if (status == EFI_SUCCESS)
		status = BS->SetTimer(timer, TimerPeriodic, 10000000);
	if (EFI_ERROR(status))
		printf("Can't create timer\n");
}

static void
efi_timer_cleanup(void)
{
	BS->CloseEvent(timer);
}

time_t
getsecs(void)
{
	return ticks;
}

/*
 * Various device-related bits.
 */

void
devboot(dev_t dev, char *p)
{
	strlcpy(p, "sd0a", 5);
}

int
cnspeed(dev_t dev, int sp)
{
	return 115200;
}

char *
ttyname(int fd)
{
	return "com0";
}

dev_t
ttydev(char *name)
{
	return NODEV;
}

#define MAXDEVNAME	16

/*
 * Parse a device spec.
 *
 * [A-Za-z]*[0-9]*[A-Za-z]:file
 *    dev   uint    part
 */
int
devparse(const char *fname, int *dev, int *unit, int *part, const char **file)
{
	const char *s;

	*unit = 0;	/* default to wd0a */
	*part = 0;
	*dev  = 0;

	s = strchr(fname, ':');
	if (s != NULL) {
		int devlen;
		int i, u, p = 0;
		struct devsw *dp;
		char devname[MAXDEVNAME];

		devlen = s - fname;
		if (devlen > MAXDEVNAME)
			return (EINVAL);

		/* extract device name */
		for (i = 0; isalpha(fname[i]) && (i < devlen); i++)
			devname[i] = fname[i];
		devname[i] = 0;

		if (!isdigit(fname[i]))
			return (EUNIT);

		/* device number */
		for (u = 0; isdigit(fname[i]) && (i < devlen); i++)
			u = u * 10 + (fname[i] - '0');

		if (!isalpha(fname[i]))
			return (EPART);

		/* partition number */
		if (i < devlen)
			p = fname[i++] - 'a';

		if (i != devlen)
			return (ENXIO);

		/* check device name */
		for (dp = devsw, i = 0; i < ndevs; dp++, i++) {
			if (dp->dv_name && !strcmp(devname, dp->dv_name))
				break;
		}

		if (i >= ndevs)
			return (ENXIO);

		*unit = u;
		*part = p;
		*dev  = i;
		fname = ++s;
	}

	*file = fname;

	return (0);
}

int
devopen(struct open_file *f, const char *fname, char **file)
{
	struct devsw *dp;
	int dev, unit, part, error;

	error = devparse(fname, &dev, &unit, &part, (const char **)file);
	if (error)
		return (error);

	dp = &devsw[0];
	f->f_dev = dp;

	return (*dp->dv_open)(f, unit, part);
}

static void
efi_memprobe_internal(void)
{
	EFI_STATUS		 status;
	UINTN			 mapkey, mmsiz, siz;
	UINT32			 mmver;
	EFI_MEMORY_DESCRIPTOR	*mm;
	int			 n;

	free(mmap, mmap_ndesc * mmap_descsiz);

	siz = 0;
	status = EFI_CALL(BS->GetMemoryMap, &siz, NULL, &mapkey, &mmsiz,
	    &mmver);
	if (status != EFI_BUFFER_TOO_SMALL)
		panic("cannot get the size of memory map");
	mm = alloc(siz);
	status = EFI_CALL(BS->GetMemoryMap, &siz, mm, &mapkey, &mmsiz, &mmver);
	if (status != EFI_SUCCESS)
		panic("cannot get the memory map");
	n = siz / mmsiz;
	mmap = mm;
	mmap_key = mapkey;
	mmap_ndesc = n;
	mmap_descsiz = mmsiz;
	mmap_version = mmver;
}

/*
 * 64-bit ARMs can have a much wider memory mapping, as in somewhere
 * after the 32-bit region.  To cope with our alignment requirement,
 * use the memory table to find a place where we can fit.
 */
static EFI_STATUS
efi_memprobe_find(UINTN pages, UINTN align, EFI_PHYSICAL_ADDRESS *addr)
{
	EFI_MEMORY_DESCRIPTOR	*mm;
	int			 i, j;

	if (align < EFI_PAGE_SIZE)
		return EFI_INVALID_PARAMETER;

	efi_memprobe_internal();	/* sync the current map */

	for (i = 0, mm = mmap; i < mmap_ndesc;
	    i++, mm = NextMemoryDescriptor(mm, mmap_descsiz)) {
		if (mm->Type != EfiConventionalMemory)
			continue;

		if (mm->NumberOfPages < pages)
			continue;

		for (j = 0; j < mm->NumberOfPages; j++) {
			EFI_PHYSICAL_ADDRESS paddr;

			if (mm->NumberOfPages - j < pages)
				break;

			paddr = mm->PhysicalStart + (j * EFI_PAGE_SIZE);
			if (paddr & (align - 1))
				continue;

			if (EFI_CALL(BS->AllocatePages, AllocateAddress,
			    EfiLoaderData, pages, &paddr) == EFI_SUCCESS) {
				*addr = paddr;
				return EFI_SUCCESS;
			}
		}
	}
	return EFI_OUT_OF_RESOURCES;
}

/*
 * Commands
 */

int Xexit_efi(void);
int Xpoweroff_efi(void);

const struct cmd_table cmd_machine[] = {
	{ "exit",	CMDT_CMD, Xexit_efi },
	{ "poweroff",	CMDT_CMD, Xpoweroff_efi },
	{ NULL, 0 }
};

int
Xexit_efi(void)
{
	EFI_CALL(BS->Exit, IH, 0, 0, NULL);
	for (;;)
		continue;
	return (0);
}

int
Xpoweroff_efi(void)
{
	EFI_CALL(RS->ResetSystem, EfiResetShutdown, EFI_SUCCESS, 0, NULL);
	return (0);
}
@


1.12
log
@Some small cleanups to reduce the diffs to the armv7 efiboot.

ok tom@@, jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: efiboot.c,v 1.11 2017/08/07 19:34:53 kettenis Exp $	*/
d54 1
d269 88
d404 2
@


1.11
log
@Add "machine exit" and "machine poweroff" commands to the arm64 and armv7
bootloaders.  Replace while (1) { } with for (;;) continue; per request
from tom@@.

ok tom@@, jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: efiboot.c,v 1.10 2017/07/31 14:06:29 kettenis Exp $	*/
d41 1
a41 1
EFI_HANDLE		 IH, efi_bootdp = NULL;
d45 1
a45 1
EFI_MEMORY_DESCRIPTOR	*mmap = NULL;
d57 4
a60 4
static void	 efi_heap_init(void);
static void	 efi_memprobe_internal(void);
static void	 efi_timer_init(void);
static void	 efi_timer_cleanup(void);
@


1.10
log
@Back out previous commit but handle the case where the device path consists
of a single MEDIA_DEVICE_PATH component specially to cater for U-Boot's
somewhat broken device path handling.  Add comments to prevent confusion
in the future.  Bump the version number once again.

ok brynet@@
@
text
@d1 1
a1 1
/*	$OpenBSD: efiboot.c,v 1.9 2017/07/29 19:51:50 kettenis Exp $	*/
a397 8
	/*
	 * XXX ResetSystem doesn't seem to work on U-Boot 2016.05 on
	 * the CuBox-i.  So trigger an unimplemented instruction trap
	 * instead.
	 */
#if 1
	asm volatile(".word 0xa000f7f0\n");
#else
d399 2
a400 2
#endif
	while (1) { }
d629 29
@


1.9
log
@Fix off-by-one in return value of efi_device_path_depth().

ok patrick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: efiboot.c,v 1.8 2017/07/24 12:12:09 patrick Exp $	*/
d195 9
d229 4
d240 1
a240 1
			return (i + 1);
@


1.8
log
@Port amd64's updates to the device path comparison to arm64 as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: efiboot.c,v 1.7 2017/05/07 11:07:48 kettenis Exp $	*/
d227 1
a227 1
			return (i);
@


1.7
log
@Pass the address of the EFI system table and the EFI memory map through
properties in the /chosen node of the FDT.  The properties match the ones
used by Linux (see Documentation/arm/uefi.txt in the Linux kernel source
tree) but with the "linux," prefix replaced by "openbsd,".

ok jmatthew@@, tom@@
@
text
@d1 1
a1 1
/*	$OpenBSD: efiboot.c,v 1.6 2017/03/11 09:09:14 jsg Exp $	*/
d55 2
d174 1
a174 1
	int			 i, bootdev;
d180 1
a180 1
	EFI_DEVICE_PATH		*dp, *bp;
d192 3
a195 1
		bootdev = 0;
d205 2
a206 2
		if (efi_bootdp == NULL)
			goto next;
d210 2
a211 15
			goto next;
		bp = efi_bootdp;
		while (1) {
			if (IsDevicePathEnd(dp)) {
				bootdev = 1;
				break;
			}
			if (memcmp(dp, bp, sizeof(EFI_DEVICE_PATH)) != 0 ||
			    memcmp(dp, bp, DevicePathNodeLength(dp)) != 0)
				break;
			dp = NextDevicePathNode(dp);
			bp = NextDevicePathNode(bp);
		}
next:
		if (bootdev) {
d218 35
@


1.6
log
@Set EVT_NOTIFY_SIGNAL when calling boot services CreateEvent().
The UEFI specification states this is required to have the notification
function called.  U-Boot's EFI loader calls the notification function
without the flag set but the EDK2 implementation of UEFI requires the
flag.

With this change the timer ticks and autoboot works on the OverDrive
3000.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: efiboot.c,v 1.5 2017/02/08 09:13:25 patrick Exp $	*/
d49 1
d237 3
a239 2
	char bootduid[8];
	u_char zero[8];
a260 1
	memset(&zero, 0, sizeof(zero));
d267 10
d282 26
d343 1
d553 1
@


1.5
log
@Retry BS->ExitBootServices() if it fails, like on amd64.  Also we need
to make sure to pass the current mapkey to prove EFI that we know the
current memory map and its constraints.  Otherwise EFI can choose to
only partially exit until we pass the correct key.  As we already use
the memory map to allocate memory for the kernel, split the previous
function into one simply retrieving the table and another one who uses
the map to allocate memory.  At some point it would be nice to actually
pass the table to the kernel since its data is more reliable than the
FDT only.  While there, sync a bit of style with the amd64 version.
@
text
@d1 1
a1 1
/*	$OpenBSD: efiboot.c,v 1.4 2017/02/04 22:43:46 patrick Exp $	*/
d356 1
a356 1
	status = BS->CreateEvent(EVT_TIMER, TPL_CALLBACK,
@


1.4
log
@In reality our kernel does not need to be aligned at a 256M boundary,
but simply at 2M boundary.  This might have been a requirement from
armv7, but it's not true for arm64.  This also helps reduce memory
holes below the kernel.
@
text
@d1 1
a1 1
/*	$OpenBSD: efiboot.c,v 1.3 2017/02/03 08:48:40 patrick Exp $	*/
d41 1
a41 1
EFI_HANDLE		 IH;
d43 6
a48 1
EFI_HANDLE		 efi_bootdp;
d54 4
a57 2
static void efi_timer_init(void);
static void efi_timer_cleanup(void);
a154 3
EFI_PHYSICAL_ADDRESS	 heap;
UINTN			 heapsiz = 1 * 1024 * 1024;

d298 3
d303 9
a311 1
	BS->ExitBootServices(NULL, 0);
d490 2
a491 7
/*
 * 64-bit ARMs can have a much wider memory mapping, as in somewhere
 * after the 32-bit region.  To cope with our alignment requirement,
 * use the memory table to find a place where we can fit.
 */
static EFI_STATUS
efi_memprobe_find(UINTN pages, UINTN align, EFI_PHYSICAL_ADDRESS *addr)
d496 2
a497 2
	EFI_MEMORY_DESCRIPTOR	*mm0, *mm;
	int			 i, j, n;
d499 1
a499 2
	if (align < EFI_PAGE_SIZE)
		return EFI_INVALID_PARAMETER;
d506 2
a507 2
	mm0 = alloc(siz);
	status = EFI_CALL(BS->GetMemoryMap, &siz, mm0, &mapkey, &mmsiz, &mmver);
d511 21
d533 2
a534 1
	for (i = 0, mm = mm0; i < n; i++, mm = NextMemoryDescriptor(mm, mmsiz)) {
a553 1
				free(mm0, siz);
a557 1
	free(mm0, siz);
@


1.3
log
@Explicitly ask EFI to allocate the page we picked out to lay our
kernel in, and not just use some memory address that we found in
the table.
@
text
@d1 1
a1 1
/*	$OpenBSD: efiboot.c,v 1.2 2017/01/22 04:18:52 kettenis Exp $	*/
d278 3
a280 4
	 * The kernel expects to be loaded at offset 0x00200000 into a
	 * block of memory aligned on a 256MB boundary.  We allocate a
	 * block of 32MB of memory, which gives us plenty of room for
	 * growth.
d282 2
a283 2
	if (efi_memprobe_find(EFI_SIZE_TO_PAGES(32 * 1024 * 1024),
	    0x10000000, &addr) != EFI_SUCCESS)
@


1.2
log
@Increment the right loop variable.

ok patrick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: efiboot.c,v 1.1 2016/12/17 23:38:33 patrick Exp $	*/
d518 5
a522 1
			if (!(paddr & (align - 1))) {
@


1.1
log
@Import of OpenBSD/arm64

This commit contains all the kernel files related to the OpenBSD/arm64
port.  It is based on the PowerPC pmap, loongson, arm/armv7 code and
FreeBSD aarch64 code.  Hard work done by Dale Rahn.
@
text
@d1 1
a1 1
/*	$OpenBSD: efiboot.c,v 1.13 2016/10/23 19:06:08 kettenis Exp $	*/
d511 1
a511 1
		for (j = 0; j < mm->NumberOfPages; i++) {
@

