head	1.5;
access;
symbols;
locks; strict;
comment	@ * @;


1.5
date	2017.02.08.09.18.24;	author patrick;	state Exp;
branches;
next	1.4;
commitid	Qs36oCn0rzyBLZSt;

1.4
date	2017.02.05.13.11.06;	author patrick;	state Exp;
branches;
next	1.3;
commitid	Jo0MHsCjyYok7XKS;

1.3
date	2017.02.03.13.06.20;	author patrick;	state Exp;
branches;
next	1.2;
commitid	YeViSGwbni5unZGR;

1.2
date	2017.01.23.12.02.14;	author patrick;	state Exp;
branches;
next	1.1;
commitid	39tTbW4Z3oGEfML9;

1.1
date	2016.12.17.23.38.33;	author patrick;	state Exp;
branches;
next	;
commitid	uicSPzuCfsvjSNQ4;


desc
@@


1.5
log
@Pass the physical address to the end of symbols to the kernel.  From
armv7 we inherited the mechanism to manually modify the kernel symbol
table to change the value of esym.  We don't use this, but instead use
the virtual address that is passed to the kernel.  This change makes us
only work on and hand out physical addresses.  Bump the efiboot version
to make this ABI change more visible.
@
text
@/*	$OpenBSD: exec.c,v 1.4 2017/02/05 13:11:06 patrick Exp $	*/

/*
 * Copyright (c) 2006, 2016 Mark Kettenis
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/reboot.h>
#include <dev/cons.h>

#include <lib/libkern/libkern.h>
#include <lib/libsa/loadfile.h>
#include <sys/exec_elf.h>

#include <efi.h>
#include <stand/boot/cmd.h>

#include <machine/armreg.h>

#include "efiboot.h"
#include "libsa.h"
#include "fdt.h"

typedef void (*startfuncp)(void *, void *, void *) __attribute__ ((noreturn));

unsigned int cpu_get_dcache_line_size(void);
void cpu_flush_dcache(vaddr_t, vsize_t);
void cpu_inval_icache(void);

unsigned int
cpu_get_dcache_line_size(void)
{
	uint64_t ctr;
	unsigned int dcl_size;

	/* Accessible from all security levels */
	ctr = READ_SPECIALREG(ctr_el0);

	/*
	 * Relevant field [19:16] is LOG2
	 * of the number of words in DCache line
	 */
	dcl_size = CTR_DLINE_SIZE(ctr);

	/* Size of word shifted by cache line size */
	return (sizeof(int) << dcl_size);
}

void
cpu_flush_dcache(vaddr_t addr, vsize_t len)
{
	uint64_t cl_size;
	vaddr_t end;

	cl_size = cpu_get_dcache_line_size();

	/* Calculate end address to clean */
	end = addr + len;
	/* Align start address to cache line */
	addr = addr & ~(cl_size - 1);

	for (; addr < end; addr += cl_size)
		__asm volatile("dc civac, %0" :: "r" (addr) : "memory");

	/* Full system DSB */
	__asm volatile("dsb sy" ::: "memory");
}

void
cpu_inval_icache(void)
{
	__asm volatile(
	    "ic		ialluis	\n"
	    "dsb	ish	\n"
	    : : : "memory");
}

void
run_loadfile(u_long *marks, int howto)
{
	char args[256];
	char *cp;
	void *fdt;

	snprintf(args, sizeof(args) - 8, "%s:%s", cmd.bootdev, cmd.image);
	cp = args + strlen(args);

	*cp++ = ' ';
	*cp = '-';
	if (howto & RB_ASKNAME)
		*++cp = 'a';
	if (howto & RB_CONFIG)
		*++cp = 'c';
	if (howto & RB_SINGLE)
		*++cp = 's';
	if (howto & RB_KDB)
		*++cp = 'd';
	if (*cp == '-')
		*--cp = 0;
	else
		*++cp = 0;

	fdt = efi_makebootargs(args);

	efi_cleanup();

	cpu_flush_dcache(marks[MARK_ENTRY], marks[MARK_END] - marks[MARK_ENTRY]);
	cpu_inval_icache();

	cpu_flush_dcache((vaddr_t)fdt, fdt_get_size(fdt));

	(*(startfuncp)(marks[MARK_ENTRY]))((void *)marks[MARK_END], 0, fdt);

	/* NOTREACHED */
}
@


1.4
log
@Since turning of the MMU in the beginning of the kernel removes
the caches' contents, we lose data about the freshly copied and
created kernel.  This leads to bootup failures.  Make sure to
clean the caches to make sure that the data is in memory before
we turn off the MMU.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.3 2017/02/03 13:06:20 patrick Exp $	*/
a92 4
	Elf_Ehdr *elf = (Elf_Ehdr *)marks[MARK_SYM];
	Elf_Shdr *shp = (Elf_Shdr *)(marks[MARK_SYM] + elf->e_shoff);
	u_long esym = marks[MARK_END] & 0x000fffffff;
	u_long offset = 0;
a95 16
	int i;

	/*
	 * Tell locore.S where the symbol table ends by setting
	 * 'esym', which should be the first word in the .data
	 * section.
	 */
	for (i = 0; i < elf->e_shnum; i++) {
		/* XXX Assume .data is the first writable segment. */
		if (shp[i].sh_flags & SHF_WRITE) {
			/* XXX We have to store the virtual address. */
			esym |= shp[i].sh_addr & 0xffffff8000000000;
			*(u_long *)(LOADADDR(shp[i].sh_addr)) = esym;
			break;
		}
	}
d124 1
a124 1
	(*(startfuncp)(marks[MARK_ENTRY]))((void *)esym, 0, fdt);
@


1.3
log
@whitespace fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.2 2017/01/23 12:02:14 patrick Exp $	*/
d30 2
d34 1
d38 52
d138 5
@


1.2
log
@We are supposed to be mapped on a 128 MB block, so skip the first
few bits to calculate a valid virtual address for esym.

Found with kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.1 2016/12/17 23:38:33 patrick Exp $	*/
d67 9
a75 9
        if (howto & RB_ASKNAME)
                *++cp = 'a';
        if (howto & RB_CONFIG)
                *++cp = 'c';
        if (howto & RB_SINGLE)
                *++cp = 's';
        if (howto & RB_KDB)
                *++cp = 'd';
        if (*cp == '-')
@


1.1
log
@Import of OpenBSD/arm64

This commit contains all the kernel files related to the OpenBSD/arm64
port.  It is based on the PowerPC pmap, loongson, arm/armv7 code and
FreeBSD aarch64 code.  Hard work done by Dale Rahn.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.10 2016/10/06 18:15:44 kettenis Exp $	*/
d40 1
a40 1
	u_long esym = marks[MARK_END] & 0x7fffffffff;
@

