head	1.6;
access;
symbols
	OPENBSD_6_2:1.6.0.6
	OPENBSD_6_2_BASE:1.6
	OPENBSD_6_1:1.6.0.4
	OPENBSD_6_1_BASE:1.6;
locks; strict;
comment	@ * @;


1.6
date	2017.03.09.14.23.59;	author kettenis;	state Exp;
branches;
next	1.5;
commitid	17EOhWfdHZkVby6Q;

1.5
date	2017.03.08.08.48.02;	author patrick;	state Exp;
branches;
next	1.4;
commitid	dbI3tRB0bl1Vdz6m;

1.4
date	2017.02.25.16.53.09;	author patrick;	state Exp;
branches;
next	1.3;
commitid	mfIpn6be0Yc8SKSx;

1.3
date	2017.02.24.17.16.41;	author patrick;	state Exp;
branches;
next	1.2;
commitid	lhR7JNEsuPtWHDQF;

1.2
date	2017.02.24.17.10.59;	author patrick;	state Exp;
branches;
next	1.1;
commitid	6kDmLcAWsy60SM1b;

1.1
date	2016.12.17.23.38.33;	author patrick;	state Exp;
branches;
next	;
commitid	uicSPzuCfsvjSNQ4;


desc
@@


1.6
log
@Change the interrupt routing API to take a pointer to a "struct cpu_info"
instead of a cpu number.

ok patrick@@
@
text
@/*	$OpenBSD: intr.h,v 1.5 2017/03/08 08:48:02 patrick Exp $ */

/*
 * Copyright (c) 2001-2004 Opsycon AB  (www.opsycon.se / www.opsycon.com)
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#ifndef	_MACHINE_INTR_H_
#define	_MACHINE_INTR_H_

/*
 * The interrupt level ipl is a logical level; per-platform interrupt
 * code will turn it into the appropriate hardware interrupt masks
 * values.
 *
 * Interrupt sources on the CPU are kept enabled regardless of the
 * current ipl value; individual hardware sources interrupting while
 * logically masked are masked on the fly, remembered as pending, and
 * unmasked at the first splx() opportunity.
 */
#ifdef _KERNEL

/* Interrupt priority `levels'; not mutually exclusive. */
#define	IPL_NONE	0	/* nothing */
#define	IPL_SOFT	1	/* soft interrupts */
#define	IPL_SOFTCLOCK	2	/* soft clock interrupts */
#define	IPL_SOFTNET	3	/* soft network interrupts */
#define	IPL_SOFTTTY	4	/* soft terminal interrupts */
#define	IPL_BIO		5	/* block I/O */
#define	IPL_NET		6	/* network */
#define	IPL_TTY		7	/* terminal */
#define	IPL_VM		8	/* memory allocation */
#define	IPL_AUDIO	9	/* audio */
#define	IPL_CLOCK	10	/* clock */
#define	IPL_SCHED	IPL_CLOCK
#define	IPL_STATCLOCK	IPL_CLOCK
#define	IPL_HIGH	11	/* everything */
#define	IPL_IPI		12	/* interprocessor interrupt */
#define	NIPL		13	/* number of levels */

/* Interrupt priority 'flags'. */
#define	IPL_MPSAFE	0	/* no "mpsafe" interrupts */

/* Interrupt sharing types. */
#define	IST_NONE	0	/* none */
#define	IST_PULSE	1	/* pulsed */
#define	IST_EDGE	2	/* edge-triggered */
#define	IST_LEVEL	3	/* level-triggered */

#define	IST_LEVEL_LOW		IST_LEVEL
#define	IST_LEVEL_HIGH		4
#define	IST_EDGE_FALLING	IST_EDGE
#define	IST_EDGE_RISING		5
#define	IST_EDGE_BOTH		6

#ifndef _LOCORE
#include <sys/device.h>
#include <sys/queue.h>

int	 splraise(int);
int	 spllower(int);
void	 splx(int);

void	 arm_do_pending_intr(int);
void	 arm_set_intr_handler(int (*raise)(int), int (*lower)(int),
    void (*x)(int), void (*setipl)(int),
    void (*intr_handle)(void *));

struct arm_intr_func {
	int (*raise)(int);
	int (*lower)(int);
	void (*x)(int);
	void (*setipl)(int);
};

extern struct arm_intr_func arm_intr_func;

#define	splraise(cpl)		(arm_intr_func.raise(cpl))
#define	_splraise(cpl)		(arm_intr_func.raise(cpl))
#define	spllower(cpl)		(arm_intr_func.lower(cpl))
#define	splx(cpl)		(arm_intr_func.x(cpl))

#define	splsoft()	splraise(IPL_SOFT)
#define	splsoftclock()	splraise(IPL_SOFTCLOCK)
#define	splsoftnet()	splraise(IPL_SOFTNET)
#define	splsofttty()	splraise(IPL_SOFTTTY)
#define	splbio()	splraise(IPL_BIO)
#define	splnet()	splraise(IPL_NET)
#define	spltty()	splraise(IPL_TTY)
#define	splvm()		splraise(IPL_VM)
#define	splaudio()	splraise(IPL_AUDIO)
#define	splclock()	splraise(IPL_CLOCK)
#define	splsched()	splraise(IPL_SCHED)
#define	splstatclock()	splraise(IPL_STATCLOCK)
#define	splhigh()	splraise(IPL_HIGH)

#define	spllock()	splhigh()
#define	spl0()		spllower(IPL_NONE)

void	 intr_barrier(void *);

void	 arm_init_smask(void); /* XXX */
extern uint32_t arm_smask[NIPL];

#include <machine/softintr.h>

/* XXX - this is probably the wrong location for this */
void arm_clock_register(void (*)(void), void (*)(u_int), void (*)(int),
    void (*)(void));

struct cpu_info;

struct interrupt_controller {
	int	ic_node;
	void	*ic_cookie;
	void	*(*ic_establish)(void *, int *, int, int (*)(void *),
		    void *, char *);
	void	*(*ic_establish_msi)(void *, uint64_t *, uint64_t *, int,
		    int (*)(void *), void *, char *);
	void	 (*ic_disestablish)(void *);
	void	 (*ic_route)(void *, int, struct cpu_info *);

	LIST_ENTRY(interrupt_controller) ic_list;
	uint32_t ic_phandle;
	uint32_t ic_cells;
};

void	 arm_intr_init_fdt(void);
void	 arm_intr_register_fdt(struct interrupt_controller *);
void	*arm_intr_establish_fdt(int, int, int (*)(void *),
	    void *, char *);
void	*arm_intr_establish_fdt_idx(int, int, int, int (*)(void *),
	    void *, char *);
void	*arm_intr_establish_fdt_imap(int, int *, int, int, int, int (*)(void *),
	    void *, char *);
void	*arm_intr_establish_fdt_msi(int, uint64_t *, uint64_t *, int ,
	    int (*)(void *), void *, char *);
void	 arm_intr_disestablish_fdt(void *);
void	 arm_intr_route(void *, int, struct cpu_info *);

void	*arm_intr_parent_establish_fdt(void *, int *, int,
	    int (*)(void *), void *, char *);
void	 arm_intr_parent_disestablish_fdt(void *);

#ifdef DIAGNOSTIC
/*
 * Although this function is implemented in MI code, it must be in this MD
 * header because we don't want this header to include MI includes.
 */
void splassert_fail(int, int, const char *);
extern int splassert_ctl;
void arm_splassert_check(int, const char *);
#define splassert(__wantipl) do {				\
	if (splassert_ctl > 0) {				\
		arm_splassert_check(__wantipl, __func__);	\
	}							\
} while (0)
#define	splsoftassert(wantipl)	splassert(wantipl)
#else
#define	splassert(wantipl)	do { /* nothing */ } while (0)
#define	splsoftassert(wantipl)	do { /* nothing */ } while (0)
#endif

#endif /* ! _LOCORE */

#endif /* _KERNEL */

#endif	/* _MACHINE_INTR_H_ */

@


1.5
log
@Establish API to route interrupts to specific CPU cores.
Based on and ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.4 2017/02/25 16:53:09 patrick Exp $ */
d132 2
d142 1
a142 1
	void	 (*ic_route)(void *, int, int);
d160 1
a160 1
void	 arm_intr_route(void *, int, int);
@


1.4
log
@MSI interrupts are established in a different way as well.  Instead of
simply hooking up the interrupt handler and returning an MD cookie, we
need to pass back information for the PCI controller to configure its
interrupt correctly.  For this, add another establish routine into the
FDT-based interrupt API which looks up msi-controller nodes and calls
their MSI-specific establish function if requested.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.3 2017/02/24 17:16:41 patrick Exp $ */
d140 1
d158 1
@


1.3
log
@Retire the global interrupt establish and disestablish API.  It has been
of good use for supporting multiple SoCs with each their own interrupt
controllers, but as of now we have replaced it wit the FDT-enabled API.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.2 2017/02/24 17:10:59 patrick Exp $ */
d137 2
d154 2
@


1.2
log
@Implement an API for establishing legacy PCI interrupts.  This specific
establish function parses the device tree's interrupt map to discover
the correct interrupt controller node and interrupt cells for the given
PCI node.  After retrieving that information we can do the same the
normal FDT establish API already does.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.1 2016/12/17 23:38:33 patrick Exp $ */
a87 3
    void *(*intr_establish)(int irqno, int level, int (*func)(void *),
        void *cookie, char *name),
    void (*intr_disestablish)(void *cookie),
a94 3
	void *(*intr_establish)(int irqno, int level, int (*func)(void *),
	    void *cookie, char *name);
	void (*intr_disestablish)(void *cookie);
a126 4

void	*arm_intr_establish(int irqno, int level, int (*func)(void *),
    void *cookie, char *name);
void	 arm_intr_disestablish(void *cookie);
@


1.1
log
@Import of OpenBSD/arm64

This commit contains all the kernel files related to the OpenBSD/arm64
port.  It is based on the PowerPC pmap, loongson, arm/armv7 code and
FreeBSD aarch64 code.  Hard work done by Dale Rahn.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.8 2016/12/08 16:27:46 visa Exp $ */
d159 2
@

