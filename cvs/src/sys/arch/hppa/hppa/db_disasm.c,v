head	1.20;
access;
symbols
	OPENBSD_6_0:1.20.0.8
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.20.0.4
	OPENBSD_5_9_BASE:1.20
	OPENBSD_5_8:1.20.0.6
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.20.0.2
	OPENBSD_5_7_BASE:1.20
	OPENBSD_5_6:1.19.0.20
	OPENBSD_5_6_BASE:1.19
	OPENBSD_5_5:1.19.0.18
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.19.0.14
	OPENBSD_5_4_BASE:1.19
	OPENBSD_5_3:1.19.0.12
	OPENBSD_5_3_BASE:1.19
	OPENBSD_5_2:1.19.0.10
	OPENBSD_5_2_BASE:1.19
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.8
	OPENBSD_5_0:1.19.0.6
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.19.0.4
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.19.0.2
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.18.0.16
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.18.0.18
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.18.0.14
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.18.0.12
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.18.0.10
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.18.0.8
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.18.0.6
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.18.0.4
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.18.0.2
	OPENBSD_3_9_BASE:1.18
	OPENBSD_3_8:1.17.0.4
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.17.0.2
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.16.0.2
	OPENBSD_3_6_BASE:1.16
	SMP_SYNC_A:1.16
	SMP_SYNC_B:1.16
	OPENBSD_3_5:1.15.0.2
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.14.0.6
	OPENBSD_3_4_BASE:1.14
	UBC_SYNC_A:1.14
	OPENBSD_3_3:1.14.0.4
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.14.0.2
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	UBC_SYNC_B:1.14
	UBC:1.9.0.10
	UBC_BASE:1.9
	OPENBSD_3_0:1.9.0.8
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9:1.9.0.6
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_8:1.9.0.4
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.9.0.2
	OPENBSD_2_7_BASE:1.9
	SMP:1.7.0.2
	SMP_BASE:1.7
	kame_19991208:1.6
	OPENBSD_2_6:1.4.0.2
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.20
date	2014.10.15.17.22.56;	author miod;	state Exp;
branches;
next	1.19;
commitid	WWkLkWemgFxsGncA;

1.19
date	2010.05.24.15.04.54;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2006.02.06.17.19.30;	author jmc;	state Exp;
branches;
next	1.17;

1.17
date	2005.01.23.16.26.43;	author mickey;	state Exp;
branches;
next	1.16;

1.16
date	2004.04.07.18.24.19;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	2003.12.20.21.49.06;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2002.08.13.07.00.50;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	2002.07.24.20.17.03;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	2002.05.16.13.01.41;	author art;	state Exp;
branches;
next	1.11;

1.11
date	2002.03.14.01.26.31;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2002.02.04.21.20.32;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	2000.04.18.20.02.45;	author mickey;	state Exp;
branches
	1.9.10.1;
next	1.8;

1.8
date	2000.03.06.14.16.23;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	2000.01.17.06.56.41;	author mickey;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	99.11.14.02.39.06;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	99.11.02.05.50.37;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	99.09.10.19.55.15;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	99.06.21.01.12.56;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	99.02.15.21.13.38;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	99.02.14.15.21.00;	author mickey;	state Exp;
branches;
next	;

1.7.2.1
date	2000.03.24.09.07.28;	author niklas;	state Exp;
branches;
next	1.7.2.2;

1.7.2.2
date	2001.04.18.16.06.07;	author niklas;	state Exp;
branches;
next	1.7.2.3;

1.7.2.3
date	2002.03.06.00.57.22;	author niklas;	state Exp;
branches;
next	1.7.2.4;

1.7.2.4
date	2002.03.28.10.07.19;	author niklas;	state Exp;
branches;
next	1.7.2.5;

1.7.2.5
date	2003.03.27.23.26.53;	author niklas;	state Exp;
branches;
next	1.7.2.6;

1.7.2.6
date	2004.02.19.10.48.40;	author niklas;	state Exp;
branches;
next	1.7.2.7;

1.7.2.7
date	2004.06.05.23.10.48;	author niklas;	state Exp;
branches;
next	;

1.9.10.1
date	2002.06.11.03.35.36;	author art;	state Exp;
branches;
next	1.9.10.2;

1.9.10.2
date	2002.10.29.00.28.02;	author art;	state Exp;
branches;
next	;


desc
@@


1.20
log
@Do not panic when attempting to decode invalid condition codes, or if
the disassembler initialization fails.

Correctly compute the destination of pc-relative branches.
@
text
@/*	$OpenBSD: db_disasm.c,v 1.19 2010/05/24 15:04:54 deraadt Exp $	*/

/* TODO parse 64bit insns or rewrite */

/*
 * Copyright (c) 1999,2005 Michael Shalayeff
 * All rights reserved.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER IN
 * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
 * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
/*
 *  (c) Copyright 1992 HEWLETT-PACKARD COMPANY
 *
 *  To anyone who acknowledges that this file is provided "AS IS"
 *  without any express or implied warranty:
 *      permission to use, copy, modify, and distribute this file
 *  for any purpose is hereby granted without fee, provided that
 *  the above copyright notice and this notice appears in all
 *  copies, and that the name of Hewlett-Packard Company not be
 *  used in advertising or publicity pertaining to distribution
 *  of the software without specific, written prior permission.
 *  Hewlett-Packard Company makes no representations about the
 *  suitability of this software for any purpose.
 */

/*
 * unasm.c -- HP_PA Instruction Printer
 */

#include <sys/param.h>
#include <sys/systm.h>

#include <machine/db_machdep.h>
#include <ddb/db_access.h>
#include <ddb/db_sym.h>
#include <ddb/db_output.h>
#include <ddb/db_interface.h>


/* IMPORTANT NOTE:
 *  All modules using this header may assume that the datatype "int" is a
 *   32-bit (or > 32-bit) signed quantity.
 */


/* Spectrum Architecturally Defined Datatypes */
struct doubleword {
	int	wd0;
	int	wd1;
};

struct quadword {
	struct	doubleword	d0;
	struct	doubleword	d1;
};

	/* datatypes for halfword and byte fields of a word are defined
	 *  in ssBits.h */

/* Memory addressing datatypes */
typedef	unsigned int	SID,	/* range [0..MAXSID] */
			PGID,	/* range [0..MAXPGID] */
			OFS,	/* range [0..MAXINT]  */
			REALADR; /* range [0..MAXINT] */


/* data sizes */
enum datasize { Byte, Halfword, Word, Doubleword, Quadword, Variable };

/* Miscellaneous datatypes */
typedef	unsigned int	FLAGS;

/* struct for entry in unwind table */
struct ute {
	int	word1;
	int	word2;
	int	word3;
	int	word4;
};
/*
 *  Header: /n/schirf/u/baford/CVS/mach4-parisc/kernel_unused/parisc/kdb/unasm.c,v 1.5 1994/07/21 22:32:05 mike Exp
 *
 *  Spectrum Instruction Set Condition Completer Bit Assignments
 *  Dan Magenheimer - 6/14/82
 *  Terrence Miller - 6/21/82
 *  Computer Research Center, Hewlett-Packard Labs
 *
 *  (c) copyright 1982
 *  (p) protected 1982
 *  The Hewlett-Packard Company
 *  Hewlett-Packard Laboratories
 *  Computer Research Center
 *  Palo Alto, California
 *
 *  *** HP Company Confidential ***
 *
 * Log: unasm.c,v
 * Revision 1.5  1994/07/21  22:32:05  mike
 * official HP copyright notice
 *
 * Revision 1.4  1992/07/08  12:19:52  dalton
 * Checkin before split to 1.0.4 release (by LBS).
 *
 * Revision 1.3  92/06/06  16:16:45  dalton
 * *** empty log message ***
 *
 * Revision 1.2  92/06/06  15:42:28  dalton
 * Changed include to be a path relative to hp800.
 *
 * Revision 1.1  92/06/06  14:05:33  dalton
 * Initial revision
 *
 * Revision 1.2  91/04/14  20:29:49  osfrcs
 * 	Initial version.
 * 	[91/03/30  09:20:34  brezak]
 *
 * Revision 1.1.2.2  91/04/02  10:42:50  brezak
 * 	Initial version.
 * 	[91/03/30  09:20:34  brezak]
 *
 * Revision 1.1.1.2  91/03/30  09:20:34  brezak
 * 	Initial version.
 *
 * Revision 1.1  88/07/11  14:05:15  14:05:15  ren (Bob Naas)
 * 	Initial revision
 *
 * Revision 5.2  87/07/02  14:45:57  14:45:57  kent (Kent McMullen)
 * added constants to support addDasm and addDCond added to ssDID.c
 *
 * Revision 5.1  87/02/27  11:12:08  11:12:08  kent (Kent McMullen)
 * update all src to 5.1
 *
 * Revision 5.0  87/02/18  16:31:15  16:31:15  kent (Kent McMullen)
 * update all revision numbers to 5.0 for release
 *
 * Revision 1.1  86/07/15  08:34:55  08:34:55  kent (Kent McMullen)
 * Initial revision
 *
 * Revision 4.1  83/10/25  17:01:22  17:01:22  djm (Daniel J Magenheimer)
 * First release for ACD v4
 *
 * Revision 3.0  83/06/13  10:22:59  djm (Daniel Magenheimer)
 * First release for distribution
 *
 *
 */


/* Arithmetic/Logical Conditions */
#define	NEV	0x0
#define	EQZ	0x2
#define	LT	0x4
#define	LE	0x6
#define	LLT	0x8
#define	NUV	0x8
#define	LLE	0xA
#define	ZNV	0xA
#define	SV	0xC
#define	OD	0xE
#define	TR	0x1
#define	NEQZ	0x3
#define	GE	0x5
#define	GT	0x7
#define	LGE	0x9
#define	UV	0x9
#define	LGT	0xB
#define	VNZ	0xB
#define	NSV	0xD
#define	EV	0xF

/* unit conditions */
#define	SBZ	0x4
#define	SHZ	0x6
#define	SDC	0x8
#define	SBC	0xC
#define	SHC	0xE
#define	NBZ	0x5
#define	NHZ	0x7
#define	NDC	0x9
#define	NBC	0xD
#define	NHC	0xF

/*field conditions */
#define XEQ	0x1
#define XLT	0x2
#define	XOD	0x3
#define XTR	0x4
#define XNE	0x5
#define XGE	0x6
#define XEV	0x7



/*
 *  These macros are designed to be portable to all machines that have
 *  a wordsize greater than or equal to 32 bits that support the portable
 *  C compiler and the standard C preprocessor.  Wordsize (default 32)
 *  and bitfield assignment (default left-to-right,  unlike VAX, PDP-11)
 *  should be predefined using the constants HOSTWDSZ and BITFRL and
 *  the C compiler "-D" flag (e.g., -DHOSTWDSZ=36 -DBITFLR for the DEC-20).
 *  Note that the macro arguments assume that the integer being referenced
 *  is a 32-bit integer (right-justified on the 20) and that bit 0 is the
 *  most significant bit.
 */

#ifndef HOSTWDSZ
#define	HOSTWDSZ	32
#endif

#ifdef	vax
#ifndef BITFLR
#define	BITFRL
#endif
#else
#define	BITFLR
#endif

/*###########################  Macros  ######################################*/

/*---------------------------------------------------------------------------
 * DeclareBitfield$Reference - Declare a structure to be used to reference
 *  a specified bitfield within an integer (using BitfR, see below).
 *  The argument "n" must be an identifier name not used elsewhere in the
 *  program , "s" and "l" must (alas!) be constants.  (Suggestion: if
 *  "s" == 2 and "l" == 8, use _b28 for "n".)  The name "BITFLR" should
 *  be pre-defined if the compiler assigns bitfields from left-to-right.
 *  The resultant macro expansion defines a structure in which the bit field
 *  starting at position "s" with length "l" may be referenced by accessing
 *  member "n".  [Note: The leftmost bits in a 36-bit word may be accessed
 *  by specifying -4 <= s < 0 on the DEC-20.]
 *---------------------------------------------------------------------------*/

#ifdef	BITFRL
#define	DeclBitfR(s,l,n) struct n { int:(HOSTWDSZ-(s)-(l)); unsigned n:l;};
#else
#define	DeclBitfR(s,l,n) struct n { int:((s)+(HOSTWDSZ-32)); unsigned n:l;};
#endif

/*---------------------------------------------------------------------------
 * Bitfield$Reference - Reference a specified bitfield within an integer.
 *  The argument "i" must be an addressable variable (i.e., not a register
 *  variable or an expression... but see BitfX below), "n" must be an
 *  identifier name declared in a DeclBitfR invocation.  The resultant
 *  macro expansion references the bit field in "i" described by the
 *  DeclBitfR invocation with the same name ("n").  BitfR may be used as
 *  an lvalue or an rvalue. (i.e., either side of an assignment statement)
 *  The "s" and "l" arguments are historical and are now unused.  (They
 *  correspond to the "s" and "l" arguments in DeclBitfR)
 *  Translates to a single instruction on both the VAX and the DEC-20.
 *---------------------------------------------------------------------------*/
#define	BitfR(i,s,l,n)	(((struct n *)&i)->n)

/*---------------------------------------------------------------------------
 * Bitfield$eXtract - Extract the specified field from an integer.  Arguments
 *  are the same as for BitfR (except no "n"), however both "s" and "l" need
 *  no longer be constants. May only be used as an rvalue. Translates to
 *  two instructions on the VAX, three on the DEC-20.
 *---------------------------------------------------------------------------*/

#define	BitfX(i,s,l)	 (((i) >> (32-(s)-(l))) & ((1 << (l)) - 1))


/*---------------------------------------------------------------------------
 * Mask$32bits - Mask the low order 32 bits of passed word.  No-op on 32
 *  bit machines.
 *---------------------------------------------------------------------------*/

#if	HOSTWDSZ > 32
#define	Mask32(x)	((x) & 0xffffffff)
#else
#define	Mask32(x)	(x)
#endif


/*---------------------------------------------------------------------------
 * SignExtend$32bits - Force the high-order bits in machines with wordsize
 *  longer than 32 to match bit 0.
 *---------------------------------------------------------------------------*/

#if	HOSTWDSZ > 32
#define	SignEx32(x)	(((x) & 0x80000000) ? ((x) | ((unsigned)-1 << 32)) \
					    : Mask32(x))
#else
#define	SignEx32(x)	(x)
#endif

/**************************/
/* bit field declarations */
/**************************/

/* since the compiler complains if a structure name is declared twice, even
 *  if the declarations are identical, all DeclBitfR invocations are
 *  given here in one file. */

DeclBitfR(0,1,_b01)
DeclBitfR(0,15,_b015)
DeclBitfR(0,16,_b016)
DeclBitfR(0,4,_b04)
DeclBitfR(0,6,_b06)
DeclBitfR(0,8,_b08)
DeclBitfR(4,1,_b41)
DeclBitfR(4,4,_b44)
DeclBitfR(6,1,_b61)
DeclBitfR(6,13,_b613)
DeclBitfR(6,15,_b615)
DeclBitfR(6,17,_b617)
DeclBitfR(6,26,_b626)
DeclBitfR(6,5,_b65)
DeclBitfR(7,1,_b71)
DeclBitfR(8,1,_b81)
DeclBitfR(8,4,_b84)
DeclBitfR(8,8,_b88)
DeclBitfR(9,1,_b91)
DeclBitfR(10,1,_b101)
DeclBitfR(11,1,_b111)
DeclBitfR(11,10,_b1110)
DeclBitfR(11,4,_b114)
DeclBitfR(11,5,_b115)
DeclBitfR(12,1,_b121)
DeclBitfR(12,4,_b124)
DeclBitfR(13,1,_b131)
DeclBitfR(14,1,_b141)
DeclBitfR(15,1,_b151)
DeclBitfR(16,1,_b161)
DeclBitfR(16,15,_b1615)
DeclBitfR(16,16,_b1616)
DeclBitfR(16,2,_b162)
DeclBitfR(16,3,_b163)
DeclBitfR(16,4,_b164)
DeclBitfR(16,5,_b165)
DeclBitfR(16,8,_b168)
DeclBitfR(17,1,_b171)
DeclBitfR(18,1,_b181)
DeclBitfR(18,13,_b1813)
DeclBitfR(18,2,_b182)
DeclBitfR(18,7,_b187)
DeclBitfR(19,1,_b191)
DeclBitfR(19,8,_b198)
DeclBitfR(19,10,_b1910)
DeclBitfR(20,11,_b2011)
DeclBitfR(20,2,_b202)
DeclBitfR(20,4,_b204)
DeclBitfR(21,10,_b2110)
DeclBitfR(21,2,_b212)
DeclBitfR(21,5,_b215)
DeclBitfR(22,5,_b225)
DeclBitfR(23,3,_b233)
DeclBitfR(24,1,_b241)
DeclBitfR(24,4,_b244)
DeclBitfR(24,8,_b248)
DeclBitfR(25,1,_b251)
DeclBitfR(26,1,_b261)
DeclBitfR(27,1,_b271)
DeclBitfR(27,4,_b274)
DeclBitfR(27,5,_b275)
DeclBitfR(28,1,_b281)
DeclBitfR(28,4,_b284)
DeclBitfR(29,1,_b291)
DeclBitfR(30,1,_b301)
DeclBitfR(30,2,_b302)
DeclBitfR(31,1,_b311)

/******************/
/* Word subfields */
/******************/

#define	Sign(i)		BitfR(i,0,1,_b01)
/* halfwords */
#define	Hwd0(i)		BitfR(i,0,16,_b016)
#define	Hwd1sign(i)	BitfR(i,16,1,_b161)
#define	Hwd1(i)		BitfR(i,16,16,_b1616)
/* bytes */
#define	Byte0(i)	BitfR(i,0,8,_b08)
#define	Byte1sign(i)	BitfR(i,8,1,_b81)
#define	Byte1(i)	BitfR(i,8,8,_b88)
#define	Byte2(i)	BitfR(i,16,8,_b168)
#define	Byte3sign(i)	BitfR(i,24,1,_b241)
#define	Byte3(i)	BitfR(i,24,8,_b248)
/* digits */
#define	Digit0(i)	BitfR(i,0,4,_b04)
#define	Digit1(i)	BitfR(i,4,4,_b44)
#define	Digit2(i)	BitfR(i,8,4,_b84)
#define	Digit3(i)	BitfR(i,12,4,_b124)
#define	Digit4(i)	BitfR(i,16,4,_b164)
#define	Digit5(i)	BitfR(i,20,4,_b204)
#define	Digit6(i)	BitfR(i,24,4,_b244)
#define	Digit7(i)	BitfR(i,28,4,_b284)

/* Wordsize definitions */

#define		BIT_P_DW	64	/* bits/doubleword */
#define		BIT_P_WD	32	/* bits/word */
#define		BIT_P_HW	16	/* bits/halfword */
#define		BIT_P_BYT	8	/* bits/byte */
#define		BYT_P_DW	8	/* bytes/doubleword */
#define		BYT_P_WD	4	/* bytes/word */
#define		BYT_P_HW	2	/* bytes/halfword */

/* Masks */

#define		WDMASK		0xffffffff	/* 32-bit mask */
#define		OFSMASK		0xffffffff	/* 32-bit mask */
#define		SIDMASK		0xffffffff	/* 32-bit mask */
#define		SIGNMASK	0x80000000	/* 32 bit word sign bit */

/* Alignments */

#define		wdalign(ofs)	(ofs &= ~3)
/*
 *  Header: /n/schirf/u/baford/CVS/mach4-parisc/kernel_unused/parisc/kdb/unasm.c,v 1.5 1994/07/21 22:32:05 mike Exp
 *
 *  Spectrum Simulator Instruction Opcode Definitions
 *  Dan Magenheimer
 *  Computer Research Center, Hewlett-Packard Labs
 *
 *  (c) copyright 1982
 *  (p) protected 1982
 *  The Hewlett-Packard Company
 *  Hewlett-Packard Laboratories
 *  Computer Research Center
 *  Palo Alto, California
 *
 *  *** HP Company Confidential ***
 *
 * Log: unasm.c,v
 * Revision 1.5  1994/07/21  22:32:05  mike
 * official HP copyright notice
 *
 * Revision 1.4  1992/07/08  12:19:52  dalton
 * Checkin before split to 1.0.4 release (by LBS).
 *
 * Revision 1.3  92/06/06  16:16:45  dalton
 * *** empty log message ***
 *
 * Revision 1.2  92/06/06  15:42:28  dalton
 * Changed include to be a path relative to hp800.
 *
 * Revision 1.1  92/06/06  14:05:33  dalton
 * Initial revision
 *
 * Revision 1.2  91/04/14  20:29:49  osfrcs
 * 	Initial version.
 * 	[91/03/30  09:20:34  brezak]
 *
 * Revision 1.1.2.2  91/04/02  10:42:50  brezak
 * 	Initial version.
 * 	[91/03/30  09:20:34  brezak]
 *
 * Revision 1.1.1.2  91/03/30  09:20:34  brezak
 * 	Initial version.
 *
 * Revision 6.1  89/09/06  10:39:58  burroughs
 * Added shadow registers for gr0-gr7.
 *     gr0-7 are copied into sh0-7 whenever a trap occurs
 *     the instruction RFIR restores gr0-7 from sh0-7 and returns from
 *     interrupt.
 *     the "sh" command displays the shadow registers
 *     = sh7 0x789 works, too.
 *
 * Revision 6.0  89/09/01  15:46:37  15:46:37  burroughs (Greg Burroughs)
 * baseline for pcx simple offsite
 *
 * Revision 5.2  87/09/02  14:30:23  14:30:23  kent
 * separated stat gathering for indexed vs short.
 * this will NOT work if cache hints ever get used
 * since this field was assumed always zero
 *
 * Revision 5.1  87/02/27  11:12:16  11:12:16  kent (Kent McMullen)
 * update all src to 5.1
 *
 * Revision 5.0  87/02/18  16:31:35  16:31:35  kent (Kent McMullen)
 * update all revision numbers to 5.0 for release
 *
 * Revision 1.1  86/07/15  08:34:57  08:34:57  kent (Kent McMullen)
 * Initial revision
 *
 * Revision 4.1  83/10/25  17:02:34  17:02:34  djm (Daniel J Magenheimer)
 * First release for ACD v4
 *
 * Revision 3.0  83/06/13  10:24:45  djm (Daniel Magenheimer)
 * First release for distribution
 *
 *
 */

/*
 * Changes:
 *   01/30/90 ejf Simplify SPOPn support, now only gives assist emulation trap.
 *   01/19/90 ejf Replace linpak instructions with just FSTQ[SX].
 *   12/19/89 ejf Add PA89 new floating point opcode 0E.
 *   12/18/89 ejf Change 5 ops to PA89 format.
 *   12/01/89 ejf Move additional instructions fmas, fmaa, fld2, fst2 to ssILst
 *   09/22/89 ejf Fix unbalanced comments.
 */


/* ..and modified by hand to remove the load/store short references */
/* ..and modified by hand to make memory management ops conform to the
 *   requirement that all subops of a major opcode begin in the same
 *   place and have the same length */

#define	LDW	0x12, 0x00, 0, 0	/* LOAD WORD */
#define	LDWM	0x13, 0x00, 0, 0	/* LOAD WORD and MODIFY */
#define	LDH	0x11, 0x00, 0, 0	/* LOAD HALFWORD */
#define	LDB	0x10, 0x00, 0, 0	/* LOAD BYTE */
#define	LDO	0x0d, 0x00, 0, 0	/* LOAD OFFSET */
#define	STW	0x1a, 0x00, 0, 0	/* STORE WORD */
#define	STWM	0x1b, 0x00, 0, 0	/* STORE WORD and MODIFY */
#define	STH	0x19, 0x00, 0, 0	/* STORE HALFWORD */
#define	STB	0x18, 0x00, 0, 0	/* STORE BYTE */
#define	LDWX	0x03, 0x02, 19, 7	/* LOAD WORD INDEXED */
#define	LDHX	0x03, 0x01, 19, 7	/* LOAD HALFWORD INDEXED */
#define	LDBX	0x03, 0x00, 19, 7	/* LOAD BYTE INDEXED */
#define	LDWAX	0x03, 0x06, 19, 7	/* LOAD WORD ABSOLUTE INDEXED */
#define	LDCWX	0x03, 0x07, 19, 7	/* LOAD and CLEAR WORD INDEXED */
#define LDWS	0x03, 0x42, 19, 7	/* LOAD WORD SHORT DISP */
#define LDHS	0x03, 0x41, 19, 7	/* LOAD HALFWORD SHORT DISP */
#define LDBS	0x03, 0x40, 19, 7	/* LOAD BYTE SHORT DISP */
#define LDWAS	0x03, 0x46, 19, 7	/* LOAD WORD ABSOLUTE SHORT DISP */
#define LDCWS	0x03, 0x47, 19, 7	/* LOAD and CLEAR WORD SHORT DISP */
#define	STWS	0x03, 0x4a, 19, 7	/* STORE WORD SHORT DISP */
#define	STHS	0x03, 0x49, 19, 7	/* STORE HALFWORD SHORT DISP */
#define	STBS	0x03, 0x48, 19, 7	/* STORE BYTE SHORT DISP */
#define	STWAS	0x03, 0x4e, 19, 7	/* STORE WORD ABSOLUTE SHORT DISP */
#define	STBYS	0x03, 0x4c, 19, 7	/* STORE BYTES SHORT DISP */
#define	LDIL	0x08, 0x00, 0, 0	/* LOAD IMMED LEFT */
#define	ADDIL	0x0a, 0x00, 0, 0	/* ADD IMMED LEFT */
#define	BL	0x3a, 0x00, 16, 3	/* BRANCH [and LINK] */
#define	GATE	0x3a, 0x01, 16, 3	/* GATEWAY */
#define	BLR	0x3a, 0x02, 16, 3	/* BRANCH and LINK REGISTER */
#define	BV	0x3a, 0x06, 16, 3	/* BRANCH VECTORED */
#define	BE	0x38, 0x00, 0, 0	/* BRANCH EXTERNAL */
#define	BLE	0x39, 0x00, 0, 0	/* BRANCH and LINK EXTERNAL */
#define	MOVB	0x32, 0x00, 0, 0	/* MOVE and BRANCH */
#define	MOVIB	0x33, 0x00, 0, 0	/* MOVE IMMED and BRANCH */
#define	COMBT	0x20, 0x00, 0, 0	/* COMPARE and BRANCH if TRUE */
#define	COMBF	0x22, 0x00, 0, 0	/* COMPARE and BRANCH if FALSE */
#define	COMIBT	0x21, 0x00, 0, 0	/* COMPARE IMMED and BRANCH if TRUE */
#define	COMIBF	0x23, 0x00, 0, 0	/* COMPARE IMMED and BRANCH if FALSE */
#define	ADDBT	0x28, 0x00, 0, 0	/* ADD and BRANCH if TRUE */
#define	ADDBF	0x2a, 0x00, 0, 0	/* ADD and BRANCH if FALSE */
#define	ADDIBT	0x29, 0x00, 0, 0	/* ADD IMMED and BRANCH if TRUE */
#define	ADDIBF	0x2b, 0x00, 0, 0	/* ADD IMMED and BRANCH if FALSE */
#define	BVB	0x30, 0x00, 0, 0	/* BRANCH on VARIABLE BIT */
#define	BB	0x31, 0x00, 0, 0	/* BRANCH on BIT */
#define	ADD	0x02, 0x30, 20, 7	/* ADD  */
#define	ADDL	0x02, 0x50, 20, 7	/* ADD LOGICAL */
#define	ADDO	0x02, 0x70, 20, 7	/* ADD and TRAP on OVFLO */
#define	SH1ADD	0x02, 0x32, 20, 7	/* SHIFT 1, ADD  */
#define	SH1ADDL	0x02, 0x52, 20, 7	/* SHIFT 1, ADD LOGICAL */
#define	SH1ADDO	0x02, 0x72, 20, 7	/* SHIFT 1, ADD and TRAP on OVFLO */
#define	SH2ADD	0x02, 0x34, 20, 7	/* SHIFT 2, ADD  */
#define	SH2ADDL	0x02, 0x54, 20, 7	/* SHIFT 2, ADD LOGICAL */
#define	SH2ADDO	0x02, 0x74, 20, 7	/* SHIFT 2, ADD and TRAP on OVFLO */
#define	SH3ADD	0x02, 0x36, 20, 7	/* SHIFT 3, ADD  */
#define	SH3ADDL	0x02, 0x56, 20, 7	/* SHIFT 3, ADD LOGICAL */
#define	SH3ADDO	0x02, 0x76, 20, 7	/* SHIFT 3, ADD and TRAP on OVFLO */
#define	ADDC	0x02, 0x38, 20, 7	/* ADD with CARRY  */
#define	ADDCO	0x02, 0x78, 20, 7	/* ADD with CARRY and TRAP on OVFLO */
#define	SUB	0x02, 0x20, 20, 7	/* SUBTRACT  */
#define	SUBO	0x02, 0x60, 20, 7	/* SUBTRACT and TRAP on OVFLO */
#define	SUBB	0x02, 0x28, 20, 7	/* SUBTRACT with BORROW  */
#define	SUBBO	0x02, 0x68, 20, 7	/* SUBTRACT with BORROW and TRAP on OVFLO */
#define	SUBT	0x02, 0x26, 20, 7	/* SUBTRACT and TRAP on COND */
#define	SUBTO	0x02, 0x66, 20, 7	/* SUBTRACT and TRAP on COND or OVFLO */
#define	DS	0x02, 0x22, 20, 7	/* DIVIDE STEP */
#define	COMCLR	0x02, 0x44, 20, 7	/* COMPARE and CLEAR */
#define	OR	0x02, 0x12, 20, 7	/* INCLUSIVE OR */
#define	XOR	0x02, 0x14, 20, 7	/* EXCLUSIVE OR */
#define	AND	0x02, 0x10, 20, 7	/* AND */
#define	ANDCM	0x02, 0x00, 20, 7	/* AND COMPLEMENT */
#define	UXOR	0x02, 0x1c, 20, 7	/* UNIT XOR */
#define	UADDCM	0x02, 0x4c, 20, 7	/* UNIT ADD COMPLEMENT */
#define	UADDCMT	0x02, 0x4e, 20, 7	/* UNIT ADD COMPLEMENT and TRAP on COND */
#define	DCOR	0x02, 0x5c, 20, 7	/* DECIMAL CORRECT */
#define	IDCOR	0x02, 0x5e, 20, 7	/* INTERMEDIATE DECIMAL CORRECT */
#define	ADDI	0x2d, 0x00, 20, 1	/* ADD to IMMED  */
#define	ADDIO	0x2d, 0x01, 20, 1	/* ADD to IMMED and TRAP on OVFLO */
#define	ADDIT	0x2c, 0x00, 20, 1	/* ADD to IMMED and TRAP on COND */
#define	ADDITO	0x2c, 0x01, 20, 1	/* ADD to IMMED and TRAP on COND or OVFLO */
#define	SUBI	0x25, 0x00, 20, 1	/* SUBTRACT from IMMED  */
#define	SUBIO	0x25, 0x01, 20, 1	/* SUBTRACT from IMMED and TRAP on OVFLO */
#define	COMICLR	0x24, 0x00, 0, 0	/* COMPARE IMMED and CLEAR */
#define	VSHD	0x34, 0x00, 19, 3	/* VARIABLE SHIFT DOUBLE */
#define	SHD	0x34, 0x02, 19, 3	/* SHIFT DOUBLE */
#define	VEXTRU	0x34, 0x04, 19, 3	/* VARIABLE EXTRACT RIGHT UNSIGNED */
#define	VEXTRS	0x34, 0x05, 19, 3	/* VARIABLE EXTRACT RIGHT SIGNED */
#define	EXTRU	0x34, 0x06, 19, 3	/* EXTRACT RIGHT UNSIGNED  */
#define	EXTRS	0x34, 0x07, 19, 3	/* EXTRACT RIGHT SIGNED */
#define	VDEP	0x35, 0x01, 19, 3	/* VARIABLE DEPOSIT */
#define	DEP	0x35, 0x03, 19, 3	/* DEPOSIT */
#define	VDEPI	0x35, 0x05, 19, 3	/* VARIABLE DEPOSIT IMMED */
#define	DEPI	0x35, 0x07, 19, 3	/* DEPOSIT IMMED */
#define	ZVDEP	0x35, 0x00, 19, 3	/* ZERO and VARIABLE DEPOSIT */
#define	ZDEP	0x35, 0x02, 19, 3	/* ZERO and DEPOSIT */
#define	ZVDEPI	0x35, 0x04, 19, 3	/* ZERO and VARIABLE DEPOSIT IMMED */
#define	ZDEPI	0x35, 0x06, 19, 3	/* ZERO and DEPOSIT IMMED */
#define	BREAK	0x00, 0x00, 19, 8	/* BREAK */
#define	RFI	0x00, 0x60, 19, 8	/* RETURN FROM INTERRUPTION */
#define	RFIR	0x00, 0x65, 19, 8	/* RFI & RESTORE SHADOW REGISTERS */
#define	SSM	0x00, 0x6b, 19, 8	/* SET SYSTEM MASK */
#define	RSM	0x00, 0x73, 19, 8	/* RESET SYSTEM MASK */
#define	MTSM	0x00, 0xc3, 19, 8	/* MOVE TO SYSTEM MASK */
#define	LDSID	0x00, 0x85, 19, 8	/* LOAD SPACE IDENTIFIER */
#define	MTSP	0x00, 0xc1, 19, 8	/* MOVE TO SPACE REGISTER */
#define	MTCTL	0x00, 0xc2, 19, 8	/* MOVE TO SYSTEM CONTROL REGISTER */
#define	MFSP	0x00, 0x25, 19, 8	/* MOVE FROM SPACE REGISTER */
#define	MFCTL	0x00, 0x45, 19, 8	/* MOVE FROM SYSTEM CONTROL REGISTER */
#define	SYNC	0x00, 0x20, 19, 8	/* SYNCHRONIZE DATA CACHE */
#define	DIAG	0x05, 0x00, 0, 0	/* DIAGNOSE */
#define	SPOP	0x04, 0x00, 0, 0	/* SPECIAL FUNCTION UNIT */
#define	COPR	0x0c, 0x00, 0, 0	/* COPROCESSOR */
#define	CLDWX	0x09, 0x00, 19, 4	/* COPROCESSOR LOAD WORD INDEXED */
#define	CLDDX	0x0b, 0x00, 19, 4	/* COPROCESSOR LOAD WORD INDEXED */
#define	CSTWX	0x09, 0x01, 19, 4	/* COPROCESSOR STORE WORD INDEXED */
#define	CSTDX	0x0b, 0x01, 19, 4	/* COPROCESSOR STORE WORD INDEXED */
#define CLDWS	0x09, 0x08, 19, 4	/* COPROCESSOR LOAD WORD SHORT */
#define CLDDS	0x0b, 0x08, 19, 4	/* COPROCESSOR LOAD WORD SHORT */
#define CSTWS	0x09, 0x09, 19, 4	/* COPROCESSOR STORE WORD SHORT */
#define CSTDS	0x0b, 0x09, 19, 4	/* COPROCESSOR STORE WORD SHORT */
#define	FLOAT0	0x0e, 0x00, 21, 2	/* FLOATING POINT CLASS 0 */
#define	FLOAT1	0x0e, 0x01, 21, 2	/* FLOATING POINT CLASS 1 */
#define	FLOAT2	0x0e, 0x02, 21, 2	/* FLOATING POINT CLASS 2 */
#define	FLOAT3	0x0e, 0x03, 21, 2	/* FLOATING POINT CLASS 3 */
#define	FMPYSUB	0x26, 0x00, 0, 0	/* FP MULTIPLY AND SUBTRACT */
#define	FMPYADD	0x06, 0x00, 0, 0	/* FP MULTIPLY AND ADD/TRUNCATE */
#define	FSTQX	0x0f, 0x01, 19, 4	/* FLOATING POINT STORE QUAD INDEXED */
#define FSTQS	0x0f, 0x09, 19, 4	/* FLOATING POINT STORE QUAD SHORT */
/* all of the following have been pushed around to conform */
#define	PROBER	0x01, 0x46, 19, 7	/* PROBE READ ACCESS */
#ifdef notdef
#define PROBERI 0x01, 0xc6, 19, 7	/* PROBE READ ACCESS IMMEDIATE */
#endif
#define	PROBEW	0x01, 0x47, 19, 7	/* PROBE WRITE ACCESS */
#ifdef notdef
#define PROBEWI 0x01, 0xc7, 19, 7	/* PROBE WRITE ACCESS IMMEDIATE */
#endif
#define	LPA	0x01, 0x4d, 19, 7	/* LOAD PHYSICAL ADDRESS */
#define	LHA	0x01, 0x4c, 19, 7	/* LOAD HASH ADDRESS */
#define	PDTLB	0x01, 0x48, 19, 7	/* PURGE DATA TRANS LOOKASIDE BUFFER */
#define	PITLB	0x01, 0x08, 19, 7	/* PURGE INST TRANS LOOKASIDE BUFFER */
#define	PDTLBE	0x01, 0x49, 19, 7	/* PURGE DATA TLB ENTRY */
#define	PITLBE	0x01, 0x09, 19, 7	/* PURGE INST TLB ENTRY */
#define	IDTLBA	0x01, 0x41, 19, 7	/* INSERT DATA TLB ADDRESS */
#define	IITLBA	0x01, 0x01, 19, 7	/* INSERT INSTRUCTION TLB ADDRESS */
#define	IDTLBP	0x01, 0x40, 19, 7	/* INSERT DATA TLB PROTECTION */
#define	IITLBP	0x01, 0x00, 19, 7	/* INSERT INSTRUCTION TLB PROTECTION */
#define	PDC	0x01, 0x4e, 19, 7	/* PURGE DATA CACHE */
#define	FDC	0x01, 0x4a, 19, 7	/* FLUSH DATA CACHE */
#define	FIC	0x01, 0x0a, 19, 7	/* FLUSH INSTRUCTION CACHE */
#define	FDCE	0x01, 0x4b, 19, 7	/* FLUSH DATA CACHE ENTRY */
#define	FICE	0x01, 0x0b, 19, 7	/* FLUSH DATA CACHE ENTRY */

/*
 *  Header: /n/schirf/u/baford/CVS/mach4-parisc/kernel_unused/parisc/kdb/unasm.c,v 1.5 1994/07/21 22:32:05 mike Exp
 *
 *  Spectrum Simulator Instruction Set Constants and Datatypes
 *  Dan Magenheimer - 4/28/82
 *  Computer Research Center, Hewlett-Packard Labs
 *
 *  (c) copyright 1982
 *  (p) protected 1982
 *  The Hewlett-Packard Company
 *  Hewlett-Packard Laboratories
 *  Computer Research Center
 *  Palo Alto, California
 *
 *  *** HP Company Confidential ***
 *
 * Log: unasm.c,v
 * Revision 1.5  1994/07/21  22:32:05  mike
 * official HP copyright notice
 *
 * Revision 1.4  1992/07/08  12:19:52  dalton
 * Checkin before split to 1.0.4 release (by LBS).
 *
 * Revision 1.3  92/06/06  16:16:45  dalton
 * *** empty log message ***
 *
 * Revision 1.2  92/06/06  15:42:28  dalton
 * Changed include to be a path relative to hp800.
 *
 * Revision 1.1  92/06/06  14:05:33  dalton
 * Initial revision
 *
 * Revision 1.2  91/04/14  20:29:49  osfrcs
 * 	Initial version.
 * 	[91/03/30  09:20:34  brezak]
 *
 * Revision 1.1.2.2  91/04/02  10:42:50  brezak
 * 	Initial version.
 * 	[91/03/30  09:20:34  brezak]
 *
 * Revision 1.1.1.2  91/03/30  09:20:34  brezak
 * 	Initial version.
 *
;Revision 1.1  88/07/11  14:05:21  14:05:21  ren (Bob Naas)
;Initial revision
;
 * Revision 5.1  87/02/27  11:12:23  11:12:23  kent (Kent McMullen)
 * update all src to 5.1
 *
 * Revision 5.0  87/02/18  16:31:52  16:31:52  kent (Kent McMullen)
 * update all revision numbers to 5.0 for release
 *
 * Revision 1.1  86/07/15  08:35:00  08:35:00  kent (Kent McMullen)
 * Initial revision
 *
 * Revision 4.3  85/11/12  09:28:44  09:28:44  viggy (Viggy Mokkarala)
 * first mpsim version, partially stable
 *
 * Revision 4.2  84/07/16  17:20:57  17:20:57  djm ()
 * Define field macros for COPR and SFU insts
 *
 * Revision 4.1  83/10/25  17:10:14  djm (Daniel Magenheimer)
 * First release for ACD v4
 *
 * Revision 3.1  83/08/03  14:09:59  djm (Daniel Magenheimer)
 * Sys calls, args, -S, bug fixes, etc.
 *
 * Revision 3.0  83/06/13  10:25:13  djm (Daniel Magenheimer)
 * First release for distribution
 *
 *
 */
/*
 * Changes:
 *   12/01/89 ejf Add Rsd(), Rse(), Rtd(), Rte() for 5 ops.
 *   11/30/89 ejf Make instruction use counters shared, not per cpu.
 *   11/28/89 ejf Change majoropcode for quicker extension extract.
 */



/*
 *  Dependencies: std.h, ssDefs.h, bits.h
 */


/* Lookup/Execute structure for instructions */
struct inst {
	u_char	majopc;		/* major opcode of instruction, 0..MAXOPC */
	u_char	opcext;		/* opcode extension, 0 if not applic. */
	u_char	extbs;		/* starting bit pos of extension field */
	u_char	extbl;		/* bit length of extension field */
	u_int	count;		/* frequency counter for analysis */
	char	mnem[8];	/* ascii mnemonic */
				/* disassembly function */
	int	(*dasmfcn)(const struct inst *, OFS, int);
};


#define	NMAJOPCS	64

struct majoropcode {
	const struct inst **subops; /* pointer to table of subops indexed by
				     *  opcode extension */
	u_int	maxsubop;	/* largest opcode extension value or 0 */
	u_int	extshft;	/* right shift amount for extension field */
	u_int	extmask;	/* post shift mask for extension field */
};

#define	OpExt(i,m)	((i >> m->extshft) & m->extmask)	/* extract opcode extension */


/*****************************/
/* Miscellaneous definitions */
/*****************************/

/* Load/Store Indexed Opcode Extension Cache Control */
#define	NOACTION	0
#define	STACKREF	1
#define	SEQPASS		2
#define	PREFETCH	3

/******************************/
/* Fields within instructions */
/******************************/

/* opcode */
#define	Opcode(i)	BitfR(i,0,6,_b06)
/* opcode true/false bit */
#define	OpcTF(i)	BitfR(i,4,1,_b41)
/* register sources */
#define	Rsa(i)		BitfR(i,11,5,_b115)
#define	Rsb(i)		BitfR(i,6,5,_b65)
#define	Rsc(i)		BitfR(i,27,5,_b275)
#define	Rsd(i)		BitfR(i,21,5,_b215)
#define	Rse(i)		BitfR(i,16,5,_b165)
/* register targets */
#define	Rta(i)		BitfR(i,11,5,_b115)
#define	Rtb(i)		BitfR(i,6,5,_b65)
#define	Rtc(i)		BitfR(i,27,5,_b275)
#define	Rtd(i)		BitfR(i,21,5,_b215)
#define	Rte(i)		BitfR(i,16,5,_b165)
/* 5-bit immediates (Magnitude, Sign) */
#define	Imb5(i)		BitfR(i,6,5,_b65)
#define	Ima5M(i)	BitfR(i,11,4,_b114)
#define	Ima5S(i)	BitfR(i,15,1,_b151)
#define	Ima5A(i)	BitfR(i,11,5,_b115)
#define	Imd5(i)		BitfR(i,22,5,_b225)
#define	Imc5M(i)	BitfR(i,27,4,_b274)
#define	Imc5S(i)	BitfR(i,31,1,_b311)
#define	Imc5A(i)	BitfR(i,27,5,_b275)
/* Other immediates */
#define	Im21L(i)	BitfR(i,18,2,_b182)
#define	Im21H(i)	BitfR(i,20,11,_b2011)
#define	Im21M1(i)	BitfR(i,16,2,_b162)
#define	Im21M2(i)	BitfR(i,11,5,_b115)
#define	Im21S(i)	BitfR(i,31,1,_b311)
#define	Im11M(i)	BitfR(i,21,10,_b2110)
#define	Im11S(i)	BitfR(i,31,1,_b311)
/* displacements/offsets */
#define	DispM(i)	BitfR(i,18,13,_b1813)
#define	DispS(i)	BitfR(i,31,1,_b311)
#define	Off5(i)		BitfR(i,11,5,_b115)
#define	Off11H(i)	BitfR(i,19,10,_b1910)
#define	Off11L(i)	BitfR(i,29,1,_b291)
#define	OffS(i)		BitfR(i,31,1,_b311)
/* miscellaneous */
#define	Dss(i)		BitfR(i,16,2,_b162)
#define	Cond(i)		BitfR(i,16,3,_b163)
#define	Cneg(i)		BitfR(i,19,1,_b191)
#define	Cond4(i)	BitfR(i,16,4,_b164)	/* Cond AND Cneg */
#define	Nu(i)		BitfR(i,30,1,_b301)
#define	SrL(i)		BitfR(i,16,2,_b162)
#define	SrH(i)		BitfR(i,18,1,_b181)
#define	ShortDisp(i)	BitfR(i,19,1,_b191)
#define	IndxShft(i)	BitfR(i,18,1,_b181)
#define	ModBefore(i)	BitfR(i,18,1,_b181)
#define	CacheCtrl(i)	BitfR(i,20,2,_b202)
#define	Modify(i)	BitfR(i,26,1,_b261)
#define	ProbeI(i)	BitfR(i,18,1,_b181)
#define	Uid(i)		BitfR(i,23,3,_b233)
#define	Sfu(i)		BitfR(i,23,3,_b233)
#define	CopExt17(i)	BitfR(i,6,17,_b617)
#define	CopExt5(i)	BitfR(i,27,5,_b275)
#define	SpopType(i)	BitfR(i,21,2,_b212)
#define	SpopExt15(i)	BitfR(i,6,15,_b615)
#define	SpopExt10(i)	BitfR(i,11,10,_b1110)
#define	SpopExt5L(i)	BitfR(i,16,5,_b165)
#define	SpopExt5(i)	BitfR(i,27,5,_b275)
#define	NoMajOpc(i)	BitfR(i,6,26,_b626)
#define	Bi1(i)		BitfR(i,27,5,_b275)	/* fields in BREAK */
#define	Bi2(i)		BitfR(i,6,13,_b613)

/* fragmented field collating macros */
#define	Ima5(i)		(Ima5S(i) ? Ima5M(i) | (-1<<4) : Ima5M(i))

#define	Imc5(i)		(Imc5S(i) ? Imc5M(i) | (-1<<4) : Imc5M(i))

#define	Disp(i)		(DispS(i) ?   DispM(i) | (-1<<13) : DispM(i))

#define	Im21(i)		(Im21S(i) << 31 | Im21H(i) << 20 | Im21M1(i) << 18 | \
				Im21M2(i) << 13 | Im21L(i) << 11)

#define	Im11(i)		(Im11S(i) ?   Im11M(i) | (-1<<10) : Im11M(i))

#define	Bdisp(i)	((OffS(i) ? (Off5(i)<<11 | Off11L(i)<<10|Off11H(i)) \
/* branch displacement (bytes) */	| (-1 << 16)			\
				  : (Off5(i)<<11|Off11L(i)<<10|Off11H(i))) << 2)

#define	Cbdisp(i)	((OffS(i) ?   (Off11L(i) << 10 | Off11H(i)) \
 /* compare/branch disp (bytes) */ | (-1 << 11)			\
				  :    Off11L(i) << 10 | Off11H(i)) << 2)

#define	Sr(i)		(SrH(i)<<2 | SrL(i))

/* sfu/copr */
#define	CoprExt1(i)	(CopExt17(i))
#define	CoprExt2(i)	(CopExt5(i))
#define	CoprExt(i)	((CopExt17(i)<<5) | CopExt5(i))
#define	Spop0Ext(i)	((SpopExt15(i)<<5) | SpopExt5(i))
#define	Spop1Ext(i)	(SpopExt15(i))
#define	Spop2Ext(i)	((SpopExt10(i)<<5) | SpopExt5(i))
#define	Spop3Ext(i)	((SpopExt5L(i)<<5) | SpopExt5(i))


/*##################### Globals - Imports ##################################*/

/* Disassembly functions */
int fcoprDasm(int w, u_int op1, u_int);
char *edDCond(u_int cond);
char *unitDCond(u_int cond);
char *addDCond(u_int cond);
char *subDCond(u_int cond);
int blDasm(const struct inst *i, OFS ofs, int w);
int ldDasm(const struct inst *, OFS, int);
int stDasm(const struct inst *i, OFS, int);
int addDasm(const struct inst *i, OFS, int);
int unitDasm(const struct inst *i, OFS, int);
int iaDasm(const struct inst *i, OFS, int);
int shdDasm(const struct inst *i, OFS, int);
int extrDasm(const struct inst *i, OFS, int);
int vextrDasm(const struct inst *i, OFS, int);
int depDasm(const struct inst *i, OFS, int);
int vdepDasm(const struct inst *i, OFS, int);
int depiDasm(const struct inst *i, OFS, int);
int vdepiDasm(const struct inst *i, OFS, int);
int limmDasm(const struct inst *i, OFS, int);
int brkDasm(const struct inst *i, OFS, int);
int lpkDasm(const struct inst *i, OFS, int);
int fmpyaddDasm(const struct inst *i, OFS, int);
int fmpysubDasm(const struct inst *i, OFS, int);
int floatDasm(const struct inst *i, OFS, int);
int coprDasm(const struct inst *i, OFS, int);
int diagDasm(const struct inst *i, OFS, int);
int scDasm(const struct inst *i, OFS, int);
int mmgtDasm(const struct inst *i, OFS, int);
int ldxDasm(const struct inst *i, OFS, int);
int stsDasm(const struct inst *i, OFS, int);
int stbysDasm(const struct inst *i, OFS, int);
int brDasm(const struct inst *i, OFS, int);
int bvDasm(const struct inst *i, OFS, int);
int beDasm(const struct inst *i, OFS, int);
int cbDasm(const struct inst *i,OFS ofs, int);
int cbiDasm(const struct inst *i,OFS ofs, int);
int bbDasm(const struct inst *i,OFS ofs, int);
int ariDasm(const struct inst *i, OFS, int);

/*##################### Globals - Exports ##################################*/
/*##################### Local Variables ####################################*/

static	const char	fmtStrTbl[][5] = { "sgl", "dbl", "sgl", "quad" };
static	const char	condStrTbl[][7] = {
	    "false?", "false", "?", "!<=>", "=", "=t", "?=", "!<>",
	    "!?>=", "<", "?<", "!>=", "!?>", "<=", "?<=", "!>",
	    "!?<=", ">", "?>", "!<=", "!?<", ">=", "?>=", "!<",
	    "!?=", "<>", "!=", "!=t", "!?", "<=>", "true?", "true"
};
static	const char	fsreg[][5] = {
	    "r0L",  "r0R",  "r1L",  "r1R",  "r2L",  "r2R",  "r3L",  "r3R",
	    "r4L",  "r4R",  "r5L",  "r5R",  "r6L",  "r6R",  "r7L",  "r7R",
	    "r8L",  "r8R",  "r9L",  "r9R",  "r10L", "r10R", "r11L", "r11R",
	    "r12L", "r12R", "r13L", "r13R", "r14L", "r14R", "r15L", "r15R",
	    "r16L", "r16R", "r17L", "r17R", "r18L", "r18R", "r19L", "r19R",
	    "r20L", "r20R", "r21L", "r21R", "r22L", "r22R", "r23L", "r23R",
	    "r24L", "r24R", "r25L", "r25R", "r26L", "r26R", "r27L", "r27R",
	    "r28L", "r28R", "r29L", "r29R", "r30L", "r30R", "r31L", "r31R"
};
static	const char	fdreg[][4] = {
	    "r0",   "r0",   "r1",   "r1",   "r2",   "r2",   "r3",   "r3",
	    "r4",   "r4",   "r5",   "r5",   "r6",   "r6",   "r7",   "r7",
	    "r8",   "r8",   "r9",   "r9",   "r10",  "r10",  "r11",  "r11",
	    "r12",  "r12",  "r13",  "r13",  "r14",  "r14",  "r15",  "r15",
	    "r16",  "r16",  "r17",  "r17",  "r18",  "r18",  "r19",  "r19",
	    "r20",  "r20",  "r21",  "r21",  "r22",  "r22",  "r23",  "r23",
	    "r24",  "r24",  "r25",  "r25",  "r26",  "r26",  "r27",  "r27",
	    "r28",  "r28",  "r29",  "r29",  "r30",  "r30",  "r31",  "r31"
};

/*##################### Macros #############################################*/

#define	Match(s)	(strncmp(s,i->mnem,sizeof(s)-1) == 0)

/* bits for assist ops */
#define	AstNu(w)	Modify(w)
#define	Fpi(w)		(Uid(w)>3)

/* bits for 5 ops */
#define	SinglePrec(i)	Modify(i)
#define	Ms1(i)		((Rsb(i)<<1)+(SinglePrec(i)?((Rsb(i)>15)?1:32):0))
#define	Ms2(i)		((Rsa(i)<<1)+(SinglePrec(i)?((Rsa(i)>15)?1:32):0))
#define	Mt(i)		((Rtc(i)<<1)+(SinglePrec(i)?((Rtc(i)>15)?1:32):0))
#define	As(i)		((Rsd(i)<<1)+(SinglePrec(i)?((Rsd(i)>15)?1:32):0))
#define	Ad(i)		((Rte(i)<<1)+(SinglePrec(i)?((Rte(i)>15)?1:32):0))

/*##################### Globals - Exports ##################################*/

/* To replace instr function, do the following:				*/
/*	a) locate the desired entry in instrs[] below			*/
/*	b) change the 3rd field if an alternate mneumonic is 		*/
/*	   desired for window disassembly				*/
/*	c) change the 4th field to the name of the function being	*/
/* 	   used for replacement (i.e. ldwRepl instead of ldw)		*/
/*	d) change the 5th field if an alternate disassembly routine	*/
/*	   is desired (i.e. ldDasmRepl)					*/

static const struct inst instrs[] = {
	{ LDW,    0, "ldw",	ldDasm },
	{ LDH,    0, "ldh",	ldDasm },
	{ LDB,    0, "ldb",	ldDasm },
	{ LDWM,   0, "ldwm",    ldDasm },
	{ LDO,    0, "ldo",     ldDasm },
	{ STW,    0, "stw",     stDasm },
	{ STH,    0, "sth",     stDasm },
	{ STB,    0, "stb",     stDasm },
	{ STWM,   0, "stwm",    stDasm },
	{ LDWX,   0, "ldw",	ldxDasm },
	{ LDHX,   0, "ldh",	ldxDasm },
	{ LDBX,   0, "ldb",	ldxDasm },
	{ LDCWX,  0, "ldcw",	ldxDasm },
	{ LDWAX,  0, "ldwa",	ldxDasm },
	{ LDWS,   0, "ldw",	ldxDasm },
	{ LDHS,   0, "ldh",	ldxDasm },
	{ LDBS,   0, "ldb",	ldxDasm },
	{ LDCWS,  0, "ldcw",	ldxDasm },
	{ LDWAS,  0, "ldwa",	ldxDasm },
	{ STWS,   0, "stws",    stsDasm },
	{ STHS,   0, "sths",    stsDasm },
	{ STBS,   0, "stbs",    stsDasm },
	{ STWAS,  0, "stwas",   stsDasm },
	{ STBYS,  0, "stbys",   stbysDasm },
	{ LDIL,   0, "ldil",    limmDasm },
	{ ADDIL,  0, "addil",   limmDasm },
	{ GATE,   0, "gate",    blDasm },
	{ BL,     0, "b",	blDasm },
	{ BLR,    0, "blr",     brDasm },
	{ BV,     0, "bv",      bvDasm },
	{ BE,     0, "be",      beDasm },
	{ BLE,    0, "ble",     beDasm },
	{ COMBT,  0, "combt",   cbDasm },
	{ COMBF,  0, "combf",   cbDasm },
	{ COMIBT, 0, "comibt",  cbiDasm },
	{ COMIBF, 0, "comibf",  cbiDasm },
	{ ADDBT,  0, "addbt",   cbDasm },
	{ ADDBF,  0, "addbf",   cbDasm },
	{ ADDIBT, 0, "addibt",  cbiDasm },
	{ ADDIBF, 0, "addibf",  cbiDasm },
	{ MOVB,   0, "movb",    cbDasm },
	{ MOVIB,  0, "movib",   cbiDasm },
	{ BB,     0, "bb",      bbDasm },
	{ BVB,    0, "bvb",     bbDasm },
	{ SUBO,   0, "subo",    ariDasm },
	{ ADD,    0, "add",     addDasm },
	{ ADDL,   0, "addl",    addDasm },
	{ ADDO,   0, "addo",    ariDasm },
	{ SH1ADD, 0, "sh1add",  ariDasm },
	{ SH1ADDL,0, "sh1addl", ariDasm },
	{ SH1ADDO,0, "sh1addo", ariDasm },
	{ SH2ADD, 0, "sh2add",  ariDasm },
	{ SH2ADDL,0, "sh2addl", ariDasm },
	{ SH2ADDO,0, "sh2addo", ariDasm },
	{ SH3ADD, 0, "sh3add",  ariDasm },
	{ SH3ADDL,0, "sh3addl", ariDasm },
	{ SH3ADDO,0, "sh3addo", ariDasm },
	{ SUB,    0, "sub",     ariDasm },
	{ ADDCO,  0, "addco",   ariDasm },
	{ SUBBO,  0, "subbo",   ariDasm },
	{ ADDC,   0, "addc",    ariDasm },
	{ SUBB,   0, "subb",    ariDasm },
	{ COMCLR, 0, "comclr",  ariDasm },
	{ OR,     0, "or",      ariDasm },
	{ AND,    0, "and",     ariDasm },
	{ XOR,    0, "xor",     ariDasm },
	{ ANDCM,  0, "andcm",   ariDasm },
	{ DS,     0, "ds",      ariDasm },
	{ UXOR,   0, "uxor",    unitDasm },
	{ UADDCM, 0, "uaddcm",  unitDasm },
	{ UADDCMT,0, "uaddcmt", unitDasm },
	{ SUBTO,  0, "subto",   ariDasm },
	{ SUBT,   0, "subt",    ariDasm },
	{ DCOR,   0, "dcor",    unitDasm },
	{ IDCOR,  0, "idcor",   unitDasm },
	{ ADDIO,  0, "addio",   iaDasm },
	{ SUBIO,  0, "subio",   iaDasm },
	{ ADDI,   0, "addi",    iaDasm },
	{ SUBI,   0, "subi",    iaDasm },
	{ COMICLR,0, "comiclr", iaDasm },
	{ ADDITO, 0, "addito",  iaDasm },
	{ ADDIT,  0, "addit",   iaDasm },
	{ SHD,    0, "shd",     shdDasm },
	{ VSHD,   0, "vshd",    shdDasm },
	{ EXTRU,  0, "extru",   extrDasm },
	{ EXTRS,  0, "extrs",   extrDasm },
	{ VEXTRU, 0, "vextru",  vextrDasm },
	{ VEXTRS, 0, "vextrs",  vextrDasm },
	{ DEP,    0, "dep",     depDasm },
	{ VDEP,   0, "vdep",    vdepDasm },
	{ DEPI,   0, "depi",    depiDasm },
	{ VDEPI,  0, "vdepi",   vdepiDasm },
	{ ZDEP,   0, "zdep",    depDasm },
	{ ZVDEP,  0, "zvdep",   vdepDasm },
	{ ZDEPI,  0, "zdepi",   depiDasm },
	{ ZVDEPI, 0, "zvdepi",  vdepiDasm },
	{ BREAK,  0, "break",   brkDasm },
	{ RFI,    0, "rfi",     0 },
	{ RFIR,   0, "rfir",    0 },
	{ SSM,    0, "ssm",     scDasm },
	{ RSM,    0, "rsm",     scDasm },
	{ MTSM,   0, "mtsm",    scDasm },
	{ PROBER, 0, "prober",  mmgtDasm },
	{ PROBEW, 0, "probew",  mmgtDasm },
	{ LPA,    0, "lpa",     mmgtDasm },
	{ LHA,    0, "lha",     mmgtDasm },
	{ LDSID,  0, "ldsid",   scDasm },
	{ PDTLB,  0, "pdtlb",   mmgtDasm },
	{ PDTLBE, 0, "pdtlbe",  mmgtDasm },
	{ PITLB,  0, "pitlb",   mmgtDasm },
	{ PITLBE, 0, "pitlbe",  mmgtDasm },
	{ IDTLBA, 0, "idtlba",  mmgtDasm },
	{ IITLBA, 0, "iitlba",  mmgtDasm },
	{ IDTLBP, 0, "idtlbp",  mmgtDasm },
	{ IITLBP, 0, "iitlbp",  mmgtDasm },
	{ FIC,    0, "fic",     mmgtDasm },
	{ FICE,   0, "fice",    mmgtDasm },
	{ PDC,    0, "pdc",     mmgtDasm },
	{ FDC,    0, "fdc",     mmgtDasm },
	{ FDCE,   0, "fdce",    mmgtDasm },
	{ SYNC,   0, "sync",    0 },
	{ MTSP,   0, "mtsp",    scDasm },
	{ MTCTL,  0, "mtctl",   scDasm },
	{ MFSP,   0, "mfsp",    scDasm },
	{ MFCTL,  0, "mfctl",   scDasm },
	{ DIAG,   0, "diag",    diagDasm },
	{ SPOP,   0, "???",     0 },
	{ COPR,   0, "copr",    coprDasm },
	{ CLDWX,  0, "cldw",    coprDasm },
	{ CLDDX,  0, "cldd",    coprDasm },
	{ CSTWX,  0, "cstw",    coprDasm },
	{ CSTDX,  0, "cstd",    coprDasm },
	{ CLDWS,  0, "cldw",    coprDasm },
	{ CLDDS,  0, "cldd",    coprDasm },
	{ CSTWS,  0, "cstw",    coprDasm },
	{ CSTDS,  0, "cstd",    coprDasm },
	{ FLOAT0, 0, "f",       floatDasm },
	{ FLOAT1, 0, "fcnv",    floatDasm },
	{ FLOAT2, 0, "f",       floatDasm },
	{ FLOAT3, 0, "f",       floatDasm },
	{ FMPYSUB,0, "fmpy",    fmpysubDasm },
	{ FMPYADD,0, "fmpy",    fmpyaddDasm },
	{ FSTQX,  0, "fstqx",   lpkDasm  },
	{ FSTQS,  0, "fstqs",   lpkDasm  },
	{0}
};


static const struct inst illeg = { 0, 0, 0, 0, 0, "???", 0 };
static const struct inst *so_sysop[0xd0];
static const struct inst *so_mmuop[0x50];
static const struct inst *so_arith[0x80];
static const struct inst *so_loads[0x50];
static const struct inst *so_cldw [0x0A];
static const struct inst *so_cldd [0x0A];
static const struct inst *so_float[0x04];
static const struct inst *so_fstq [0x0A];
static const struct inst *so_ebran[0x08];
static const struct inst *so_addit[0x02];
static const struct inst *so_addi [0x02];
static const struct inst *so_subi [0x02];
static const struct inst *so_shext[0x08];
static const struct inst *so_deps [0x08];

#define ILLEG (const struct inst **)&illeg
#define NENTS(a) (sizeof(a)/sizeof(a[0])-1)
static struct majoropcode majopcs[NMAJOPCS] = {
	{ so_sysop, NENTS(so_sysop) }, /* 00 */
	{ so_mmuop, NENTS(so_mmuop) }, /* 01 */
	{ so_arith, NENTS(so_arith) }, /* 02 */
	{ so_loads, NENTS(so_loads) }, /* 03 */
	{ ILLEG, 1 }, /* 04 */
	{ ILLEG, 1 }, /* 05 */
	{ ILLEG, 1 }, /* 06 */
	{ ILLEG, 1 }, /* 07 */
	{ ILLEG, 1 }, /* 08 */
	{ so_cldw , NENTS(so_cldw ) }, /* 09 */
	{ ILLEG, 1 }, /* 0A */
	{ so_cldd , NENTS(so_cldd ) }, /* 0B */
	{ ILLEG, 1 }, /* 0C */
	{ ILLEG, 1 }, /* 0D */
	{ so_float, NENTS(so_float) }, /* 0E */
	{ so_fstq , NENTS(so_fstq ) }, /* 0F */
	{ ILLEG, 1 }, /* 10 */
	{ ILLEG, 1 }, /* 11 */
	{ ILLEG, 1 }, /* 12 */
	{ ILLEG, 1 }, /* 13 */
	{ ILLEG, 1 }, /* 14 */
	{ ILLEG, 1 }, /* 15 */
	{ ILLEG, 1 }, /* 16 */
	{ ILLEG, 1 }, /* 17 */
	{ ILLEG, 1 }, /* 18 */
	{ ILLEG, 1 }, /* 19 */
	{ ILLEG, 1 }, /* 1A */
	{ ILLEG, 1 }, /* 1B */
	{ ILLEG, 1 }, /* 1C */
	{ ILLEG, 1 }, /* 1D */
	{ ILLEG, 1 }, /* 1E */
	{ ILLEG, 1 }, /* 1F */
	{ ILLEG, 1 }, /* 20 */
	{ ILLEG, 1 }, /* 21 */
	{ ILLEG, 1 }, /* 22 */
	{ ILLEG, 1 }, /* 23 */
	{ ILLEG, 1 }, /* 24 */
	{ so_subi , NENTS(so_subi ) }, /* 25 */
	{ ILLEG, 1 }, /* 26 */
	{ ILLEG, 1 }, /* 27 */
	{ ILLEG, 1 }, /* 28 */
	{ ILLEG, 1 }, /* 29 */
	{ ILLEG, 1 }, /* 2A */
	{ ILLEG, 1 }, /* 2B */
	{ so_addit, NENTS(so_addit) }, /* 2C */
	{ so_addi , NENTS(so_addi ) }, /* 2D */
	{ ILLEG, 1 }, /* 2E */
	{ ILLEG, 1 }, /* 2F */
	{ ILLEG, 1 }, /* 30 */
	{ ILLEG, 1 }, /* 31 */
	{ ILLEG, 1 }, /* 32 */
	{ ILLEG, 1 }, /* 33 */
	{ so_shext, NENTS(so_shext) }, /* 34 */
	{ so_deps , NENTS(so_deps ) }, /* 35 */
	{ ILLEG, 1 }, /* 36 */
	{ ILLEG, 1 }, /* 37 */
	{ ILLEG, 1 }, /* 38 */
	{ ILLEG, 1 }, /* 39 */
	{ so_ebran, NENTS(so_ebran) }, /* 3A */
	{ ILLEG, 1 }, /* 3B */
	{ ILLEG, 1 }, /* 3C */
	{ ILLEG, 1 }, /* 3D */
	{ ILLEG, 1 }, /* 3E */
	{ ILLEG, 1 }, /* 3F */
};
#undef NENTS
#undef ILLEG

int iExInit(void);

/*--------------------------------------------------------------------------
 * instruction$ExecutionInitialize - Initialize the instruction execution
 *  data structures.
 *---------------------------------------------------------------------------*/
int
iExInit(void)
{
	static int unasm_initted = 0;
	register const struct inst *i;
	register struct majoropcode *m;
	u_int	shft, mask;

	if (unasm_initted)
		return 1;

	/*
	 * Determine maxsubop for each major opcode.
	 * Also, check all instructions of a given major opcode
	 * for consistent opcode extension field definition, and
	 * save a converted form of this definition in the majopcs
	 * entry for this major opcode.
	 */
	for (i = &instrs[0]; *i->mnem; i++) {
		m = &majopcs[i->majopc];
		if (m->maxsubop < i->opcext) {
			db_printf("iExInit not enough space for opcode %d",
			    i->majopc);
			return 0;
		}
		shft = 32 - i->extbs - i->extbl;
		mask = (1 << i->extbl) - 1;
		if (m->extshft || m->extmask) {
			if (m->extshft != shft || m->extmask != mask) {
				db_printf("%s - Bad instruction initialization!\n", i->mnem);
				return 0;
			}
		} else {
			m->extshft = shft;
			m->extmask = mask;
		}
	}

	/*
	 * Lastly, fill in all legal subops with the appropriate info.
	 */
	for (i = &instrs[0]; *i->mnem; i++) {
		m = &majopcs[i->majopc];
		if (m->maxsubop == 1)
			m->subops = (const struct inst **)i;
		else
			m->subops[i->opcext] = i;
	}

	unasm_initted++;
	return 1;
}



/*##################### Functions and Subroutines ##########################*/

/**************************************/
/* Miscellaneous Disassembly Routines */
/**************************************/

/* Add instructions */
int
addDasm(i, ofs, w)
	const struct inst *i;
	OFS ofs;
	int w;
{
	db_printf("%s\t%%r%d,%%r%d,%%r%d",addDCond(Cond4(w)),
		Rsa(w),Rsb(w),Rtc(w));
	return (1);
}

/* Unit instructions */
int
unitDasm(i, ofs, w)
	const struct inst *i;
	OFS ofs;
	int w;
{
	db_printf(unitDCond(Cond4(w)));
	if (Match("dcor") || Match("idcor"))
		db_printf("\t%%r%d,%%r%d",Rsb(w),Rtc(w));
	else
		db_printf("\t%%r%d,%%r%d,%%r%d",Rsa(w),Rsb(w),Rtc(w));
	return (1);
}

/* Immediate Arithmetic instructions */
int
iaDasm(i, ofs, w)
	const struct inst *i;
	OFS ofs;
	int w;
{
	if (Match("addi"))
		db_printf("%s\t%d,%%r%d,%%r%d",
		    addDCond(Cond4(w)),Im11(w),Rsb(w),Rta(w));
	else
		db_printf("%s\t%d,%%r%d,%%r%d",
		    subDCond(Cond4(w)),Im11(w),Rsb(w),Rta(w));
	return (1);
}

/* Shift double instructions */
int
shdDasm(i, ofs, w)
	const struct inst *i;
	OFS ofs;
	int w;
{
	if (Match("vshd"))
		db_printf("%s\t%%r%d,%%r%d,%%r%d",
		    edDCond(Cond(w)), Rsa(w),Rsb(w),Rtc(w));
	else
		db_printf("%s\t%%r%d,%%r%d,%d,%%r%d",
		    edDCond(Cond(w)),Rsa(w),Rsb(w),31-Imd5(w),Rtc(w));
	return (1);
}

/* Extract instructions */
int
extrDasm(i, ofs, w)
	const struct inst *i;
	OFS ofs;
	int w;
{
	db_printf("%s\t%%r%d,%d,%d,%%r%d",
	    edDCond(Cond(w)),Rsb(w),Imd5(w),32 - Rsc(w),Rta(w));
	return (1);
}


/* Variable extract instructions */
int
vextrDasm(i, ofs, w)
	const struct inst *i;
	OFS ofs;
	int w;
{
	db_printf("%s\t%%r%d,%d,%%r%d",
	    edDCond(Cond(w)),Rsb(w),32 - Rsc(w),Rta(w));
	return (1);
}


/* Deposit instructions */
int
depDasm(i, ofs, w)
	const struct inst *i;
	OFS ofs;
	int w;
{
	db_printf("%s\t%%r%d,%d,%d,%%r%d",
	    edDCond(Cond(w)),Rsa(w),31 - Imd5(w),32 - Rsc(w),Rtb(w));
	return (1);
}


/* Variable deposit instructions */
int
vdepDasm(i, ofs, w)
	const struct inst *i;
	OFS ofs;
	int w;
{
	db_printf("%s\t%%r%d,%d,%%r%d",
	    edDCond(Cond(w)),Rsa(w),32 - Rsc(w),Rtb(w));
	return (1);
}


/* Deposit Immediate instructions */
int
depiDasm(i, ofs, w)
	const struct inst *i;
	OFS ofs;
	int w;
{
	db_printf("%s\t%d,%d,%d,%%r%d",
	    edDCond(Cond(w)),Ima5(w),31 - Imd5(w),32 - Imc5A(w),Rtb(w));
	return (1);
}

/* Variable Deposit Immediate instructions */
int
vdepiDasm(i, ofs, w)
	const struct inst *i;
	OFS ofs;
	int w;
{
	db_printf("%s\t%d,%d,%%r%d",edDCond(Cond(w)),Ima5(w),32-Imc5A(w),Rtb(w));
	return (1);
}

/*---------------------------------------------------------------------------
 * conditionType$DisassembleCondition - Return a string which contains the
 *  ascii description of the passed numeric condition.
 *---------------------------------------------------------------------------*/

char *
subDCond(cond)
	u_int cond;
{
	switch(cond) {
	case EQZ:	return(",=");
	case LT:	return(",<");
	case LE:	return(",<=");
	case LLT:	return(",<<");
	case LLE:	return(",<<=");
	case SV:	return(",sv");
	case OD:	return(",od");
	case NEQZ:	return(",<>");
	case GE:	return(",>=");
	case GT:	return(",>");
	case LGE:	return(",>>=");
	case LGT:	return(",>>");
	case NSV:	return(",nsv");
	case EV:	return(",ev");
	case TR:	return(",tr");
	case NEV:	return("");
	default:
		return(",<unknown subDCond condition>");
	}
}


/*---------------------------------------------------------------------------
 * conditionType$DisassembleCondition - Return a string which contains the
 *  ascii description of the passed numeric condition.
 *---------------------------------------------------------------------------*/

char *
addDCond(cond)
	u_int cond;
{
	switch(cond) {
	case EQZ:	return(",=");
	case LT:	return(",<");
	case LE:	return(",<=");
	case NUV:	return(",nuv");
	case ZNV:	return(",znv");
	case SV:	return(",sv");
	case OD:	return(",od");
	case NEQZ:	return(",<>");
	case GE:	return(",>=");
	case GT:	return(",>");
	case UV:	return(",uv");
	case VNZ:	return(",vnz");
	case NSV:	return(",nsv");
	case EV:	return(",ev");
	case TR:	return(",tr");
	case NEV:	return("");
	default:
		return(",<unknown addDCond condition>");
	}
}

char *
unitDCond(cond)
	u_int cond;
{
	switch(cond) {
	case SHC:	return(",shc");
	case SHZ:	return(",shz");
	case SBC:	return(",sbc");
	case SBZ:	return(",sbz");
	case SDC:	return(",sdc");
	case NHC:	return(",nhc");
	case NHZ:	return(",nhz");
	case NBC:	return(",nbc");
	case NBZ:	return(",nbz");
	case NDC:	return(",ndc");
	case TR:	return(",tr");
	case NEV:	return("");
	default:
		return(",<unknown unitDCond condition>");
	}
}

char *
edDCond(cond)
	u_int cond;
{
	switch(cond) {
	case XOD:	return(",od");
	case XTR:	return(",tr");
	case XNE:	return(",<>");
	case XLT:	return(",<");
	case XEQ:	return(",=");
	case XGE:	return(",>=");
	case XEV:	return(",ev");
	case NEV:	return("");
	default:
		return(",<unknown edDCond condition>");
	}
}



/****************************************/
/* Format Specific Disassembly Routines */
/****************************************/


/* Load [modify] instructions */
int
ldDasm(i, ofs, w)
	const struct inst *i;
	OFS ofs;
	int w;
{
	register int d = Disp(w);
	char s[2];

	s[1] = '\0';
	if (d < 0) {
		d = -d;
		s[0] = '-';
	} else
		s[0] = '\0';

	if (Rsb(w) == 0 && Match("ldo")) {
		db_printf("ldi\t%s%X,%%r%d",s,d,Rta(w));
		return (1);
	}
	db_printf("%s\t%s%s%X",i->mnem,(d < 2048? "R'":""), s, d);
	if (Dss(w))
		db_printf("(%%sr%d,%%r%d),%%r%d",Dss(w),Rsb(w),Rta(w));
	else
		db_printf("(%%r%d),%%r%d",Rsb(w),Rta(w));
	return (1);
}

/* Store [modify] instructions */
int
stDasm(i, ofs, w)
	const struct inst *i;
	OFS ofs;
	int w;
{
	register int d = Disp(w);
	char s[2];

	db_printf("\t%%r%d,",Rta(w));

	s[1] = '\0';
	if (d < 0) {
		d = -d;
		s[0] = '-';
	} else
		s[0] = '\0';

	db_printf("%s%s%X", (d < 2048? "R'":""), s, d);

	if (Dss(w))
		db_printf("(%%sr%d,%%r%d)",Dss(w),Rsb(w));
	else
		db_printf("(%%r%d)",Rsb(w));
	return (1);
}

/* Load indexed instructions */
int
ldxDasm(i, ofs, w)
	const struct inst *i;
	OFS ofs;
	int w;
{
	register const char *p;

	if (ShortDisp(w)) {
		db_printf("s");
		if (Modify(w))
			db_printf(",m%s", ModBefore(w)? "b": "a");
	} else {
		db_printf("x");
		if (Modify(w))
			db_printf(",%sm", IndxShft(w)? "s":"");
	}
	switch (CacheCtrl(w)) {
	case NOACTION:	p = "";   break;
	case STACKREF:	p = ",c"; break;
	case SEQPASS:	p = ",q"; break;
	case PREFETCH:	p = ",p"; break;
	}
	if (ShortDisp(w))
		db_printf("%s\t%d", p, Ima5(w));
	else
		db_printf("%s\t%%r%d", p, Rsa(w));

	if (Dss(w))
		db_printf("(%%sr%d,%%r%d),%%r%d",Dss(w),Rsb(w),Rtc(w));
	else
		db_printf("(%%r%d),%%r%d",Rsb(w),Rtc(w));
	return (1);
}

/* Store short displacement instructions */
int
stsDasm(i, ofs, w)
	const struct inst *i;
	OFS ofs;
	int w;
{
	register const char *p;
	if (Modify(w))
		db_printf(",m%s", ModBefore(w)? "b":"a");

	switch (CacheCtrl(w)) {
	case NOACTION:	p = "";   break;
	case STACKREF:	p = ",c"; break;
	case SEQPASS:	p = ",q"; break;
	case PREFETCH:	p = ",p"; break;
	}
	db_printf("%s\t%%r%d,", p, Rta(w));
	if (Dss(w))
		db_printf("%d(%%sr%d,%%r%d)",Imc5(w),Dss(w),Rsb(w));
	else
		db_printf("%d(%%r%d)",Imc5(w),Rsb(w));
	return (1);
}

/* Store Bytes Instruction */
int
stbysDasm(i, ofs, w)
	const struct inst *i;
	OFS ofs;
	int w;
{
	register const char *p;
	db_printf(ModBefore(w)? ",e":",b");
	if (Modify(w))
		db_printf(",m");
	switch (CacheCtrl(w)) {
	case NOACTION:	p = "";   break;
	case STACKREF:	p = ",f"; break;
	case SEQPASS:	p = ",r"; break;
	case PREFETCH:	p = ",z"; break;
	}
	db_printf("%s\t%%r%d,", p, Rta(w));
	if (Dss(w))
		db_printf("%d(%%sr%d,%%r%d)",Imc5(w),Dss(w),Rsb(w));
	else
		db_printf("%d(%%r%d)",Imc5(w),Rsb(w));
	return (1);
}

/* Long Immediate instructions */
int
limmDasm(i, ofs, w)
	const struct inst *i;
	OFS ofs;
	int w;
{
	db_printf("\tL'%X,%%r%d", Im21(w), Rtb(w));
	return (1);
}


/* Branch and Link instruction(s) (Branch, too!!) */
int
blDasm(i, ofs, w)
	const struct inst *i;
	OFS ofs;
	int w;
{
	register OFS tgtofs = ofs + 8 + Bdisp(w);
	register u_int link = Rtb(w);

	if (link && !Match("gate"))
		db_printf("l");
	if (Nu(w))
		db_printf(",n");
	db_printf("\t");

	db_printsym((db_addr_t)tgtofs, DB_STGY_ANY, db_printf);

	if (link || Match("gate"))
		db_printf(",%%r%d",link);

	return (1);
}

/* Branch Register instruction */
int
brDasm(i, ofs, w)
	const struct inst *i;
	OFS ofs;
	int w;
{
	db_printf("%s\t%%r%d,%%r%d", Nu(w)?",n":"", Rsa(w), Rtb(w));
	return (1);
}

/* Dispatch instructions */
int
bvDasm(i, ofs, w)
	const struct inst *i;
	OFS ofs;
	int w;
{
	db_printf("%s\t%%r%d(%%r%d)", Nu(w)?",n":"", Rsa(w), Rsb(w));
	return (1);
}

/* Branch External instructions */
int
beDasm(i, ofs, w)
	const struct inst *i;
	OFS ofs;
	int w;
{
	register int d = Bdisp(w);
	register const char *p;
	char s[2];

	s[1] = '\0';
	if (d < 0) {
		d = -d;
		s[0] = '-';
	} else
		s[0] = '\0';

	p =  Nu(w)? ",n":"";
	db_printf("%s\tR'%s%X(%%sr%d,%%r%d)", p, s, d, Sr(w), Rsb(w));
	return (1);
}


/* Compare/Add and Branch instructions */
int
cbDasm(i, ofs, w)
	const struct inst *i;
	OFS ofs;
	int w;
{
	register OFS tgtofs = ofs + 8 + Cbdisp(w);

	if (Match("movb"))
		db_printf(edDCond(Cond(w)));
	else if (Match("addb"))
		db_printf(addDCond(Cond(w) << 1));
	else
		db_printf(subDCond(Cond(w) << 1));
	db_printf("%s\t%%r%d,%%r%d,", Nu(w)?",n":"", Rsa(w), Rsb(w));
	db_printsym((db_addr_t)tgtofs, DB_STGY_ANY, db_printf);
	return (1);
}

/* Compare/Add and Branch Immediate instructions */
int
cbiDasm(i, ofs, w)
	const struct inst *i;
	OFS ofs;
	int w;
{
	register OFS tgtofs = ofs + 8 + Cbdisp(w);

	if (Match("movib"))
		db_printf(edDCond(Cond(w)));
	else if (Match("addib"))
		db_printf(addDCond(Cond(w) << 1));
	else
		db_printf(subDCond(Cond(w) << 1));
	db_printf("%s\t%d,%%r%d,", Nu(w)? ",n":"", Ima5(w), Rsb(w));
	db_printsym((db_addr_t)tgtofs, DB_STGY_ANY, db_printf);
	return (1);
}

/* Branch on Bit instructions */
int
bbDasm(i, ofs, w)
	const struct inst *i;
	OFS ofs;
	int w;
{
	register OFS tgtofs = ofs + 8 + Cbdisp(w);
	register const char *p;

	db_printf(edDCond(Cond(w)));
	p = Nu(w)? ",n":"";
	if (Match("bvb"))
		db_printf("%s\t%%r%d,", p, Rta(w));
	else
		db_printf("%s\t%%r%d,%d,", p, Rsa(w), Imb5(w));
	db_printsym((db_addr_t)tgtofs, DB_STGY_ANY, db_printf);
	return (1);
}

/* Arithmetic instructions */
int
ariDasm(i, ofs, w)
	const struct inst *i;
	OFS ofs;
	int w;
{
	if (Match("or") && Rsb(w) == 0 && Cond4(w) == NEV) {
		if (Rsa(w) == 0 && Rtc(w) == 0)
			db_printf("nop");
		else
			db_printf("copy\t%%r%d,%%r%d",Rsa(w),Rtc(w));
	} else
		db_printf("%s%s\t%%r%d,%%r%d,%%r%d", i->mnem,
			  subDCond(Cond4(w)), Rsa(w),Rsb(w),Rtc(w));
	return(1);
}

/* System control operations */
int
scDasm(i, ofs, w)
	const struct inst *i;
	OFS ofs;
	int w;
{
	if (Match("mtctl")) {
		if (Rtb(w) == 11)
			db_printf("mtsar\t%%r%d",Rsa(w));
		else
			db_printf("mtctl\t%%r%d,%%cr%d",Rsa(w),Rtb(w));
		return (1);
	}
	db_printf(i->mnem);
	if (Match("ssm") || Match("rsm"))
		db_printf("\t%d,%%r%d",Ima5A(w),Rtc(w));
	else if (Match("mtsm")) db_printf("\t%%r%d",Rsa(w));
	else if (Match("ldprid")) db_printf("\t%%r%d",Rtc(w));
	else if (Match("mtsp")) db_printf("\t%%r%d,%%sr%d",Rsa(w),Sr(w));
	else if (Match("mfsp")) db_printf("\t%%sr%d,%%r%d",Sr(w),Rtc(w));
	else if (Match("mfctl")) db_printf("\t%%cr%d,%%r%d",Rsb(w),Rtc(w));
	else if (Match("ldsid")) {
		if (Dss(w))
			db_printf("\t(%%sr%d,%%r%d),%%r%d",Dss(w),Rsb(w),Rtc(w));
		else
			db_printf("\t(%%r%d),%%r%d",Rsb(w),Rtc(w));
	} else
		return (0);

	return (1);
}

/* Instruction cache/tlb control instructions */
int
mmgtDasm(i, ofs, w)
	const struct inst *i;
	OFS ofs;
	int w;
{
	if (Match("probe")) {
		if (ProbeI(w)) {
			if (Dss(w))
				db_printf("i\t(%%sr%d,%%r%d),%d,%%r%d",
				    Dss(w),Rsb(w),Rsa(w),Rtc(w));
			else
				db_printf("i\t(%%r%d),%d,%%r%d",
				    Rsb(w),Rsa(w),Rtc(w));
		} else {
			if (Dss(w))
				db_printf("\t(%%sr%d,%%r%d),%%r%d,%%r%d",
				    Dss(w),Rsb(w),Rsa(w),Rtc(w));
			else
				db_printf("\t(%%r%d),%%r%d,%%r%d",
				    Rsb(w),Rsa(w),Rtc(w));
		}
	}
	else if (Match("lha") || Match("lpa")) {
		if (Modify(w))
			db_printf(",m");
		if (Dss(w))
			db_printf("\t%%r%d(%%sr%d,%%r%d),%%r%d",
			    Rsa(w),Dss(w),Rsb(w),Rtc(w));
		else
			db_printf("\t%%r%d(%%r%d),%%r%d",Rsa(w),Rsb(w),Rtc(w));
	}
	else if (Match("pdtlb") || Match("pdc") || Match("fdc")) {
		if (Modify(w)) db_printf(",m");
		if (Dss(w))
			db_printf("\t%%r%d(%%sr%d,%%r%d)",Rsa(w),Dss(w),Rsb(w));
		else
			db_printf("\t%%r%d(%%r%d)",Rsa(w),Rsb(w));
	}
	else if (Match("pitlb") || Match("fic")) {
		if (Modify(w))
			db_printf(",m");
		db_printf("\t%%r%d(%%sr%d,%%r%d)",Rsa(w),Sr(w),Rsb(w));
	}
	else if (Match("idtlb")) {
		if (Dss(w))
			db_printf("\t%%r%d,(%%sr%d,%%r%d)",Rsa(w),Dss(w),Rsb(w));
		else
			db_printf("\t%%r%d,(%%r%d)",Rsa(w),Rsb(w));
	}
	else if (Match("iitlb"))
		db_printf("\t%%r%d,(%%sr%d,%%r%d)",Rsa(w),Sr(w),Rsb(w));
	else
		return (0);

	return(1);
}

/* break instruction */
int
brkDasm(i, ofs, w)
	const struct inst *i;
	OFS ofs;
	int w;
{
	db_printf("\t%d,%d",Bi1(w),Bi2(w));
	return (1);
}

int
floatDasm(i, ofs, w)
	const struct inst *i;
	OFS ofs;
	int w;
{
	register u_int op1, r1, fmt, t;
	u_int op2, r2, dfmt;
	char *p;

	op1 = CoprExt1(w);
	op2 = CoprExt2(w);
	fmt = (op1 >> 2) & 3;		/* get precision of source  */

#define ST(r) ((fmt & 1)? fdreg[(r)]:fsreg[(r)])
	/*
	 * get first (or only) source register
	 * (independent of class)
	 */
	r1 = (op1 >> 11) & 0x3e;
	if ((fmt & 1) == 0 && (Uid(w) & 2))
		r1++;

	if (op1 & 2) {				/* class 2 or 3 */
		/*
		 * get second source register
		 */
		r2 = (op1 >> 6) & 0x3e;
		if (fmt == 2)
			r2++;

		if ((op1 & 1) == 0) {		/* class 2 */
			/* Opclass 2: 2 sources, no destination */
			switch((op1 >> 4) & 7) {
			case 0:
				p = "cmp";
				break;
			default:
				return(0);
			}
			db_printf("%s,%s",p,fmtStrTbl[fmt]);
			db_printf(",%s\t%%f%s,%%f%s",
			    condStrTbl[op2], ST(r1), ST(r2));
			return (1);
		}
		/*
		 * get target register (class 3)
		 */
		t = (op2 << 1);
		if ((fmt & 1) == 0 && (Uid(w) & 1))
			t++;
		/* Opclass 3: 2 sources, 1 destination */
		switch((op1 >> 4) & 7) {
		case 0: p = "add"; break;
		case 1: p = "sub"; break;
		case 2: p = (Fpi(w)) ? "mpyi" : "mpy"; break;
		case 3: p = "div"; break;
		case 4: p = "rem"; break;
		default: return (0);
		}
		db_printf("%s,%s", p, fmtStrTbl[fmt]);
		db_printf("\t%%f%s,%%f%s,%%f%s",ST(r1),ST(r2),ST(t));
	} else if (op1 & 1) {			/* class 1 */
		dfmt = (op1 >> 4) & 3;
#define DT(r) ((dfmt & 1)? fdreg[(r)]:fsreg[(r)])

		/*
		 * get target register
		 */
		t = (op2 << 1);
		if ((dfmt & 1) == 0 && (Uid(w) & 1))
			t++;
		/* Opclass 1: 1 source, 1 destination conversions */
		switch((op1 >> 6) & 3) {
		case 0: p = "ff"; break;
		case 1: p = "xf"; break;
		case 2: p = "fx"; break;
		case 3: p = "fxt"; break;
		}
		db_printf("%s,%s", p, fmtStrTbl[fmt]);
		db_printf(",%s\t%%f%s,%%f%s",fmtStrTbl[dfmt],ST(r1),DT(t));
	} else {				/* class 0 */
		/*
		 * get target register
		 */
		t = (op2 << 1);
		if ((fmt & 1) == 0 && (Uid(w) & 1))
			t++;
		/* Opclass 0: 1 source, 1 destination */
		switch((op1 >> 4) & 7) {
		case 1: p = "rsqrt"; break;
		case 2: p = "cpy"; break;
		case 3: p = "abs"; break;
		case 4: p = "sqrt"; break;
		case 5: p = "rnd"; break;
		default: return (0);
		}
		db_printf("%s,%s",p,fmtStrTbl[fmt]);
		db_printf("\t%%f%s,%%f%s",ST(r1),ST(t));
	}
	return (1);
}

int
fcoprDasm(w, op1, op2)
	int w;
	u_int op1, op2;
{
	register u_int r1, r2, t, fmt, dfmt;
	register char *p;

	if (AstNu(w) && op1 == ((1<<4) | 2)) {
		if (op2 == 0 || op2 == 1 || op2 == 2) {
			db_printf("ftest");
			if (op2 == 1)
				db_printf(",acc");
			else if (op2 == 2)
				db_printf(",rej");
			return (1);
		}
		return (0);
	} else if (0 == op1 && 0 == op2) {
		db_printf("fcopr identify");
		return (1);
	}
	switch(op1 & 3) {
	    case 0:
		/* Opclass 0: 1 source, 1 destination */
		r1 = (op1 >> 12) & 0x1f; t = op2; fmt = (op1 >> 2) & 3;
		switch((op1 >> 4) & 7) {
		case 1: p = "rsqrt"; break;
		case 2: p = "cpy"; break;
		case 3: p = "abs"; break;
		case 4: p = "sqrt"; break;
		case 5: p = "rnd"; break;
		default: return(0);
		}
		db_printf("f%s,%s\t%%fr%d,%%fr%d", p, fmtStrTbl[fmt], r1, t);
		break;
	    case 1:
		/* Opclass 1: 1 source, 1 destination conversions */
		r1 = (op1 >> 12) & 0x1f; t = op2;
		fmt = (op1 >> 2) & 3; dfmt = (op1 >> 4) & 3;
		switch((op1 >> 6) & 3) {
		case 0: p = "ff"; break;
		case 1: p = "xf"; break;
		case 2: p = "fx"; break;
		case 3: p = "fxt"; break;
		}
		db_printf("fcnv%s,%s,%s\t%%fr%d,%%fr%d",
		    p, fmtStrTbl[fmt], fmtStrTbl[dfmt], r1, t);
		break;
	    case 2:
		/* Opclass 2: 2 sources, no destination */
		r1 = (op1 >> 12) & 0x1f; r2 = (op1 >> 7) & 0x1f;
		fmt = (op1 >> 2) & 3;
		switch((op1 >> 4) & 7) {
		case 0: p = "fcmp"; break;
		default: return (0);
		}
		db_printf("%s,%s,%s\t%%fr%d,%%fr%d",
		    p,fmtStrTbl[fmt],condStrTbl[op2],r1,r2);
		break;
	    case 3:
		/* Opclass 3: 2 sources, 1 destination */
		r1 = (op1 >> 12) & 0x1f; r2 = (op1 >> 7) & 0x1f; t = op2;
		fmt = (op1 >> 2) & 3;
		switch((op1 >> 4) & 7) {
		case 0: p = "add"; break;
		case 1: p = "sub"; break;
		case 2: p = "mpy"; break;
		case 3: p = "div"; break;
		case 4: p = "rem"; break;
		default: return (0);
		}
		db_printf("f%s,%s\t%%fr%d,%%fr%d,%%fr%d",
		    p, fmtStrTbl[fmt], r1, r2, t);
		break;
	    default:
		    return(0);
	}
	return (1);
}

int
coprDasm(i, ofs, w)
	const struct inst *i;
	OFS ofs;
	int w;
{
	register u_int uid = Uid(w);
	register int load = 0;
	register char *pfx = uid > 1 ? "c" : "f";
	register int dreg = 0;

	if (Match("copr")) {
		if (uid) {
			db_printf("copr,%d,0x%x",uid,CoprExt(w));
			if (AstNu(w))
				db_printf(",n");
			return (1);
		}
		return fcoprDasm(w, CoprExt1(w),CoprExt2(w));
	}
	if (Match("cldd")) {
		dreg = 1;
		load = 1;
		db_printf("%sldd",pfx);
	} else if (Match("cldw")) {
		load = 1;
		db_printf("%sldw",pfx);
	} else if (Match("cstd")) {
		dreg = 1;
		db_printf("%sstd",pfx);
	} else if (Match("cstw"))
		db_printf("%sstw",pfx);
	else
		return (0);

	if (ShortDisp(w)) {
		db_printf("s");
		if (AstNu(w))
			db_printf(",m%s", ModBefore(w)?"b":"a");
	}
	else {
		db_printf("x");
		if (AstNu(w))
			db_printf(",%sm", IndxShft(w)?"s":"");
		else if (IndxShft(w))
			db_printf(",s");
	}
	switch (CacheCtrl(w)) {
	case NOACTION:	break;
	case STACKREF:	db_printf(",c"); break;
	case SEQPASS:	db_printf(",q"); break;
	case PREFETCH:	db_printf(",p"); break;
	}
	if (load) {
		register const char *p;

		if (dreg)
			p = fdreg[(Rtc(w)<<1)+(uid&1)];
		else
			p = fsreg[(Rtc(w)<<1)+(uid&1)];

		if (ShortDisp(w))
			db_printf("\t%d",Ima5(w));
		else
			db_printf("\t%%r%d",Rsa(w));
		if (Dss(w))
			db_printf("(%%sr%d,%%r%d),%%f%s", Dss(w),Rsb(w), p);
		else
			db_printf("(%%r%d),%%f%s",Rsb(w), p);
	} else {
		register const char *p;

		if (dreg)
			p = fdreg[(Rsc(w)<<1)+(uid&1)];
		else
			p = fsreg[(Rsc(w)<<1)+(uid&1)];

		if (ShortDisp(w))
			db_printf("\t%%f%s,%d", p, Ima5(w));
		else
			db_printf("\t%%f%s,%%r%d", p, Rta(w));
		if (Dss(w))
			db_printf("(%%sr%d,%%r%d)",Dss(w),Rsb(w));
		else
			db_printf("(%%r%d)",Rsb(w));
	}
	return (1);
}

int
lpkDasm(i, ofs, w)
	const struct inst *i;
	OFS ofs;
	int w;
{
	/*
	 * Floating point STore Quad
	 * Short or Indexed
	 */
	if (ShortDisp(w)) {
		if (Modify(w))
			db_printf(",m%s", ModBefore(w)?"b":"a");
	} else {
		if (Modify(w))
			db_printf(",%sm", IndxShft(w)? "s":"");
		else if (IndxShft(w))
			db_printf(",s");
	}
	switch (CacheCtrl(w)) {
	case NOACTION:	break;
	case STACKREF:	db_printf(",c"); break;
	case SEQPASS:	db_printf(",q"); break;
	case PREFETCH:	db_printf(",p"); break;
	}
	if (ShortDisp(w))
		db_printf("\t%%fr%d,%d",Rsc(w),Ima5(w));
	else
		db_printf("\t%%fr%d,%%r%d",Rsc(w),Rta(w));
	if (Dss(w))
		db_printf("(%%sr%d,%%r%d)",Dss(w),Rsb(w));
	else
		db_printf("(%%r%d)",Rsb(w));
	return (1);
}

int
diagDasm(i, ofs, w)
	const struct inst *i;
	OFS ofs;
	int w;
{
	if (0x0b0 == BitfR(w,19,8,_b198))	/* mtcpu */
		db_printf("mtcpu\t%%r%d,%%dr%d", Rsa(w), Rtb(w));
	else if (0x0d0 == BitfR(w,19,8,_b198))	/* mfcpu */
		db_printf("mfcpu\t%%dr%d,%%r%d", Rsb(w), Rta(w));
	else {
		db_printf(i->mnem);
		if (Match("diag"))
			db_printf("\t0x%X",w & 0x03ffffff);
		else
			return (0);
	}
	return (1);
}

int
fmpysubDasm(i, ofs, w)
	const struct inst *i;
	OFS ofs;
	int w;
{
	if (SinglePrec(w))
		db_printf("SUB,SGL\t%%f%s,%%f%s,%%f%s,%%f%s,%%f%s",
		    fsreg[Ms1(w)], fsreg[Ms2(w)], fsreg[Mt(w)],
		    fsreg[As(w)], fsreg[Ad(w)]);
	else
		db_printf("SUB,DBL\t%%f%s,%%f%s,%%f%s,%%f%s,%%f%s",
		    fdreg[Ms1(w)], fdreg[Ms2(w)], fdreg[Mt(w)],
		    fdreg[As(w)], fdreg[Ad(w)]);
	return (1);
}

int
fmpyaddDasm(i, ofs, w)
	const struct inst *i;
	OFS ofs;
	int w;
{
	register const char
		*ms1 = SinglePrec(w) ? fsreg[Ms1(w)] : fdreg[Ms1(w)],
		*ms2 = SinglePrec(w) ? fsreg[Ms2(w)] : fdreg[Ms2(w)],
		*mt  = SinglePrec(w) ? fsreg[Mt(w)]  : fdreg[Mt(w)],
		*as  = SinglePrec(w) ? fsreg[As(w)]  : fdreg[As(w)],
		*ad  = SinglePrec(w) ? fsreg[Ad(w)]  : fdreg[Ad(w)];

	if (Rsd(w) == 0)
		db_printf("\t%%fcfxt,%s,%%f%s,%%f%s,%%f%s",
		    ((SinglePrec(w)) ? "sgl" : "dbl"), ms1, ms2, mt);
	else
		db_printf("add%s\t%%f%s,%%f%s,%%f%s,%%f%s,%%f%s",
		    ((SinglePrec(w)) ? "sgl" : "dbl"), ms1, ms2, mt, as, ad);

	return (1);
}

vaddr_t
db_disasm(loc, flag)
	vaddr_t loc;
	boolean_t flag;
{
	register const struct inst *i;
	register const struct majoropcode *m;
	register u_int ext;
	int ok, instruct;
	OFS ofs = loc;

	if (loc == PC_REGS(&ddb_regs) && ddb_regs.tf_iir)
		instruct = ddb_regs.tf_iir;
	else if (USERMODE(loc)) {
		if (copyin((caddr_t)(loc &~ HPPA_PC_PRIV_MASK),
		    &instruct, sizeof(instruct)))
			instruct = 0;
	} else
		instruct = *(int *)loc;

	ok = 0;
	if (iExInit() != 0) {
		m = &majopcs[Opcode(instruct)];
		ext = OpExt(instruct, m);
		if (ext <= m->maxsubop) {
			/* special hack for majopcs table layout */
			if (m->maxsubop == 1)
				i = (const struct inst *)m->subops;
			else
				i = m->subops[ext];

			if (i && i->mnem[0] != '?') {
				if (i->dasmfcn != coprDasm &&
				    i->dasmfcn != diagDasm &&
				    i->dasmfcn != ariDasm &&
				    i->dasmfcn != scDasm &&
				    i->dasmfcn != ldDasm)
					db_printf(i->mnem);
				if (i->dasmfcn)
					ok = (*i->dasmfcn)(i, ofs, instruct);
			}
		}
	}

	if (!ok)
		db_printf("<%08x>", instruct);

	db_printf("\n");
	return (loc + sizeof(instruct));
}
@


1.19
log
@Add missing prototypes
ok jsing kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.18 2006/02/06 17:19:30 jmc Exp $	*/
d1240 1
a1240 1
		return 0;
d1251 2
a1252 2
		if (m->maxsubop < i->opcext)
			panic("iExInit not enough space for opcode %d",
d1254 2
d1261 1
a1261 1
				return (0);
d1281 1
a1281 1
	return (1);
d1453 1
a1453 1
		panic("subDCond: unknown condition");
d1485 1
a1485 1
		panic("addDCond: unknown condition");
d1507 1
a1507 1
		panic("unitDCond: unknown condition");
d1525 1
a1525 1
		panic("edDCond: unknown condition");
d2320 1
a2320 1
	OFS ofs = 0;
a2321 1
	iExInit();
d2332 9
a2340 8
	m = &majopcs[Opcode(instruct)];
	ext = OpExt(instruct, m);
	if (ext <= m->maxsubop) {
		/* special hack for majopcs table layout */
		if (m->maxsubop == 1)
			i = (const struct inst *)m->subops;
		else
			i = m->subops[ext];
d2342 10
a2351 7
		if (i && i->mnem[0] != '?') {
			if (i->dasmfcn != coprDasm && i->dasmfcn != diagDasm &&
			    i->dasmfcn != ariDasm && i->dasmfcn != scDasm &&
			    i->dasmfcn != ldDasm)
				db_printf(i->mnem);
			if (i->dasmfcn)
				ok = (*i->dasmfcn)(i, ofs, instruct);
@


1.18
log
@typos from alexey dobriyan;
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.17 2005/01/23 16:26:43 mickey Exp $	*/
d1224 2
@


1.17
log
@better print for ill insns -- just print a hex instead of questionable marks
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d237 1
a237 1
 *  The resultant macro expansion defines a stucture in which the bit field
@


1.16
log
@update copyright; miod@@ is fine w/ files where he holds it too
@
text
@d1 3
a3 1
/*	$OpenBSD: db_disasm.c,v 1.15 2003/12/20 21:49:06 miod Exp $	*/
d6 1
a6 1
 * Copyright (c) 1999 Michael Shalayeff
d9 11
a19 20
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR OR HIS RELATIVES BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
a933 1
static	const char	fcoprUndef[] = "copr\t(rsvd or undef.)";
d1862 1
a1862 2
	} else {
		db_printf("?????");
d1864 1
a1864 1
	}
d1921 1
a1921 2
	else {
		db_printf("?????");
d1923 1
a1923 1
	}
a1975 1
				db_printf(fcoprUndef);
d1996 1
a1996 1
		default: db_printf(fcoprUndef); return (0);
d2033 1
a2033 1
		default: db_printf(fcoprUndef); return (0);
d2073 1
a2073 1
		default: db_printf(fcoprUndef); return(0);
d2096 1
a2096 1
		default: db_printf(fcoprUndef); return (0);
d2111 1
a2111 1
		default: db_printf(fcoprUndef); return (0);
a2116 1
		    db_printf(fcoprUndef);
d2154 1
a2154 2
	else {
		db_printf("copr???");
d2156 1
a2156 1
	}
d2261 1
a2261 2
		else {
			db_printf("?????");
a2262 1
		}
d2315 1
a2315 1
	int instruct;
d2319 1
a2319 1
	if (loc == ddb_regs.tf_iioq_head && ddb_regs.tf_iir)
d2328 1
d2338 12
a2349 10
		if (i->dasmfcn != coprDasm && i->dasmfcn != diagDasm &&
		    i->dasmfcn != ariDasm && i->dasmfcn != scDasm &&
		    i->dasmfcn != ldDasm)
			db_printf(i->mnem);
		if (i->dasmfcn)
			(*i->dasmfcn)(i, ofs, instruct);
		else if (i->mnem[0] == '?')
			db_printf(illeg.mnem);
	} else
		db_printf(illeg.mnem);
@


1.15
log
@Pass -Wformat, fix a few uninitialized variables as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.14 2002/08/13 07:00:50 mickey Exp $	*/
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Michael Shalayeff.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d19 8
a26 7
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@


1.14
log
@reset iir in the frame on _onfault handling, for mr.ddb
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.13 2002/07/24 20:17:03 mickey Exp $	*/
d2147 1
a2147 1
	register int dreg;
@


1.13
log
@if it appears we are disassembling insn at the pc do not cause an extra memory fetch (and possibly a fault loop) get one from the iir in the frame
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.12 2002/05/16 13:01:41 art Exp $	*/
d2338 1
a2338 1
	if (loc == ddb_regs.tf_iioq_head)
@


1.12
log
@Add a an argument to db_printsym that specifies the printf function
we'll use for printing the information.
miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.11 2002/03/14 01:26:31 millert Exp $	*/
d2338 3
a2340 2

	if (USERMODE(loc)) {
@


1.11
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.10 2002/02/04 21:20:32 mickey Exp $	*/
d1715 1
a1715 1
	db_printsym((db_addr_t)tgtofs, DB_STGY_ANY);
d1785 1
a1785 1
	db_printsym((db_addr_t)tgtofs, DB_STGY_ANY);
d1805 1
a1805 1
	db_printsym((db_addr_t)tgtofs, DB_STGY_ANY);
d1825 1
a1825 1
	db_printsym((db_addr_t)tgtofs, DB_STGY_ANY);
@


1.10
log
@a couple of extraneous args for printf; from netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.9 2000/04/18 20:02:45 mickey Exp $	*/
d903 38
a940 38
int fcoprDasm __P((int w, u_int op1, u_int));
char *edDCond __P((u_int cond));
char *unitDCond __P((u_int cond));
char *addDCond __P((u_int cond));
char *subDCond __P((u_int cond));
int blDasm __P((const struct inst *i, OFS ofs, int w));
int ldDasm __P((const struct inst *, OFS, int));
int stDasm __P((const struct inst *i, OFS, int));
int addDasm __P((const struct inst *i, OFS, int));
int unitDasm __P((const struct inst *i, OFS, int));
int iaDasm __P((const struct inst *i, OFS, int));
int shdDasm __P((const struct inst *i, OFS, int));
int extrDasm __P((const struct inst *i, OFS, int));
int vextrDasm __P((const struct inst *i, OFS, int));
int depDasm __P((const struct inst *i, OFS, int));
int vdepDasm __P((const struct inst *i, OFS, int));
int depiDasm __P((const struct inst *i, OFS, int));
int vdepiDasm __P((const struct inst *i, OFS, int));
int limmDasm __P((const struct inst *i, OFS, int));
int brkDasm __P((const struct inst *i, OFS, int));
int lpkDasm __P((const struct inst *i, OFS, int));
int fmpyaddDasm __P((const struct inst *i, OFS, int));
int fmpysubDasm __P((const struct inst *i, OFS, int));
int floatDasm __P((const struct inst *i, OFS, int));
int coprDasm __P((const struct inst *i, OFS, int));
int diagDasm __P((const struct inst *i, OFS, int));
int scDasm __P((const struct inst *i, OFS, int));
int mmgtDasm __P((const struct inst *i, OFS, int));
int ldxDasm __P((const struct inst *i, OFS, int));
int stsDasm __P((const struct inst *i, OFS, int));
int stbysDasm __P((const struct inst *i, OFS, int));
int brDasm __P((const struct inst *i, OFS, int));
int bvDasm __P((const struct inst *i, OFS, int));
int beDasm __P((const struct inst *i, OFS, int));
int cbDasm __P((const struct inst *i,OFS ofs, int));
int cbiDasm __P((const struct inst *i,OFS ofs, int));
int bbDasm __P((const struct inst *i,OFS ofs, int));
int ariDasm __P((const struct inst *i, OFS, int));
@


1.9
log
@vm/vm.h not needed anymore
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.8 2000/03/06 14:16:23 mickey Exp $	*/
d1764 1
a1764 2
	db_printf("%s\tR'%s%X(%%sr%d,%%r%d)", p, (d < 2048? "R'":""),
	    s, d, Sr(w), Rsb(w));
d2318 1
a2318 1
		    ((SinglePrec(w)) ? "sgl" : "dbl"), ms1, ms2, mt, ad);
@


1.9.10.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.9 2000/04/18 20:02:45 mickey Exp $	*/
d903 38
a940 38
int fcoprDasm(int w, u_int op1, u_int);
char *edDCond(u_int cond);
char *unitDCond(u_int cond);
char *addDCond(u_int cond);
char *subDCond(u_int cond);
int blDasm(const struct inst *i, OFS ofs, int w);
int ldDasm(const struct inst *, OFS, int);
int stDasm(const struct inst *i, OFS, int);
int addDasm(const struct inst *i, OFS, int);
int unitDasm(const struct inst *i, OFS, int);
int iaDasm(const struct inst *i, OFS, int);
int shdDasm(const struct inst *i, OFS, int);
int extrDasm(const struct inst *i, OFS, int);
int vextrDasm(const struct inst *i, OFS, int);
int depDasm(const struct inst *i, OFS, int);
int vdepDasm(const struct inst *i, OFS, int);
int depiDasm(const struct inst *i, OFS, int);
int vdepiDasm(const struct inst *i, OFS, int);
int limmDasm(const struct inst *i, OFS, int);
int brkDasm(const struct inst *i, OFS, int);
int lpkDasm(const struct inst *i, OFS, int);
int fmpyaddDasm(const struct inst *i, OFS, int);
int fmpysubDasm(const struct inst *i, OFS, int);
int floatDasm(const struct inst *i, OFS, int);
int coprDasm(const struct inst *i, OFS, int);
int diagDasm(const struct inst *i, OFS, int);
int scDasm(const struct inst *i, OFS, int);
int mmgtDasm(const struct inst *i, OFS, int);
int ldxDasm(const struct inst *i, OFS, int);
int stsDasm(const struct inst *i, OFS, int);
int stbysDasm(const struct inst *i, OFS, int);
int brDasm(const struct inst *i, OFS, int);
int bvDasm(const struct inst *i, OFS, int);
int beDasm(const struct inst *i, OFS, int);
int cbDasm(const struct inst *i,OFS ofs, int);
int cbiDasm(const struct inst *i,OFS ofs, int);
int bbDasm(const struct inst *i,OFS ofs, int);
int ariDasm(const struct inst *i, OFS, int);
d1715 1
a1715 1
	db_printsym((db_addr_t)tgtofs, DB_STGY_ANY, db_printf);
d1764 2
a1765 1
	db_printf("%s\tR'%s%X(%%sr%d,%%r%d)", p, s, d, Sr(w), Rsb(w));
d1786 1
a1786 1
	db_printsym((db_addr_t)tgtofs, DB_STGY_ANY, db_printf);
d1806 1
a1806 1
	db_printsym((db_addr_t)tgtofs, DB_STGY_ANY, db_printf);
d1826 1
a1826 1
	db_printsym((db_addr_t)tgtofs, DB_STGY_ANY, db_printf);
d2319 1
a2319 1
		    ((SinglePrec(w)) ? "sgl" : "dbl"), ms1, ms2, mt);
@


1.9.10.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.9.10.1 2002/06/11 03:35:36 art Exp $	*/
d2338 2
a2339 3
	if (loc == ddb_regs.tf_iioq_head && ddb_regs.tf_iir)
		instruct = ddb_regs.tf_iir;
	else if (USERMODE(loc)) {
@


1.8
log
@do signed hex instead of %D
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.7 2000/01/17 06:56:41 mickey Exp $	*/
a52 1
#include <vm/vm.h>
@


1.7
log
@spaces everywhere, some knf
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.6 1999/11/14 02:39:06 mickey Exp $	*/
d1552 9
a1560 1
	register u_int d = Disp(w);
d1563 1
a1563 1
		db_printf("ldi\t%D,%%r%d",d,Rta(w));
d1566 1
a1566 4
	if (d < 2048)
		db_printf("%s\tR'%X",i->mnem,d);
	else
		db_printf("%s\t%D",i->mnem,d);
d1581 2
a1582 1
	register u_int d = Disp(w);
d1585 10
a1594 4
	if (d < 2048)
		db_printf("R'%X",d);
	else
		db_printf("%D",d);
d1753 1
a1753 1
	register u_int d = Bdisp(w);
d1755 8
d1765 2
a1766 4
	if (d < 2048)
		db_printf("%s\tR'%X(%%sr%d,%%r%d)", p, d, Sr(w), Rsb(w));
	else
		db_printf("%s\t%D(%%sr%d,%%r%d)", p, d, Sr(w), Rsb(w));
@


1.7.2.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d1552 1
a1552 9
	register int d = Disp(w);
	char s[2];

	s[1] = '\0';
	if (d < 0) {
		d = -d;
		s[0] = '-';
	} else
		s[0] = '\0';
d1555 1
a1555 1
		db_printf("ldi\t%s%X,%%r%d",s,d,Rta(w));
d1558 4
a1561 1
	db_printf("%s\t%s%s%X",i->mnem,(d < 2048? "R'":""), s, d);
d1576 1
a1576 2
	register int d = Disp(w);
	char s[2];
d1579 4
a1582 10

	s[1] = '\0';
	if (d < 0) {
		d = -d;
		s[0] = '-';
	} else
		s[0] = '\0';

	db_printf("%s%s%X", (d < 2048? "R'":""), s, d);

d1741 1
a1741 1
	register int d = Bdisp(w);
a1742 8
	char s[2];

	s[1] = '\0';
	if (d < 0) {
		d = -d;
		s[0] = '-';
	} else
		s[0] = '\0';
d1745 4
a1748 2
	db_printf("%s\tR'%s%X(%%sr%d,%%r%d)", p, (d < 2048? "R'":""),
	    s, d, Sr(w), Rsb(w));
@


1.7.2.2
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.9 2000/04/18 20:02:45 mickey Exp $	*/
d53 1
@


1.7.2.3
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d1764 2
a1765 1
	db_printf("%s\tR'%s%X(%%sr%d,%%r%d)", p, s, d, Sr(w), Rsb(w));
d2319 1
a2319 1
		    ((SinglePrec(w)) ? "sgl" : "dbl"), ms1, ms2, mt);
@


1.7.2.4
log
@Merge in -current from about a week ago
@
text
@d903 38
a940 38
int fcoprDasm(int w, u_int op1, u_int);
char *edDCond(u_int cond);
char *unitDCond(u_int cond);
char *addDCond(u_int cond);
char *subDCond(u_int cond);
int blDasm(const struct inst *i, OFS ofs, int w);
int ldDasm(const struct inst *, OFS, int);
int stDasm(const struct inst *i, OFS, int);
int addDasm(const struct inst *i, OFS, int);
int unitDasm(const struct inst *i, OFS, int);
int iaDasm(const struct inst *i, OFS, int);
int shdDasm(const struct inst *i, OFS, int);
int extrDasm(const struct inst *i, OFS, int);
int vextrDasm(const struct inst *i, OFS, int);
int depDasm(const struct inst *i, OFS, int);
int vdepDasm(const struct inst *i, OFS, int);
int depiDasm(const struct inst *i, OFS, int);
int vdepiDasm(const struct inst *i, OFS, int);
int limmDasm(const struct inst *i, OFS, int);
int brkDasm(const struct inst *i, OFS, int);
int lpkDasm(const struct inst *i, OFS, int);
int fmpyaddDasm(const struct inst *i, OFS, int);
int fmpysubDasm(const struct inst *i, OFS, int);
int floatDasm(const struct inst *i, OFS, int);
int coprDasm(const struct inst *i, OFS, int);
int diagDasm(const struct inst *i, OFS, int);
int scDasm(const struct inst *i, OFS, int);
int mmgtDasm(const struct inst *i, OFS, int);
int ldxDasm(const struct inst *i, OFS, int);
int stsDasm(const struct inst *i, OFS, int);
int stbysDasm(const struct inst *i, OFS, int);
int brDasm(const struct inst *i, OFS, int);
int bvDasm(const struct inst *i, OFS, int);
int beDasm(const struct inst *i, OFS, int);
int cbDasm(const struct inst *i,OFS ofs, int);
int cbiDasm(const struct inst *i,OFS ofs, int);
int bbDasm(const struct inst *i,OFS ofs, int);
int ariDasm(const struct inst *i, OFS, int);
@


1.7.2.5
log
@Sync the SMP branch with 3.3
@
text
@d1715 1
a1715 1
	db_printsym((db_addr_t)tgtofs, DB_STGY_ANY, db_printf);
d1785 1
a1785 1
	db_printsym((db_addr_t)tgtofs, DB_STGY_ANY, db_printf);
d1805 1
a1805 1
	db_printsym((db_addr_t)tgtofs, DB_STGY_ANY, db_printf);
d1825 1
a1825 1
	db_printsym((db_addr_t)tgtofs, DB_STGY_ANY, db_printf);
d2338 2
a2339 3
	if (loc == ddb_regs.tf_iioq_head && ddb_regs.tf_iir)
		instruct = ddb_regs.tf_iir;
	else if (USERMODE(loc)) {
@


1.7.2.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d2147 1
a2147 1
	register int dreg = 0;
@


1.7.2.7
log
@Merge with the trunk
@
text
@d15 5
d24 7
a30 8
 * IN NO EVENT SHALL THE AUTHOR OR HIS RELATIVES BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
@


1.6
log
@protect against copuin faults
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.5 1999/11/02 05:50:37 mickey Exp $	*/
d128 1
a128 1
 * 
d131 1
a131 1
 * 
d134 1
a134 1
 * 
d138 1
a138 1
 * 
d142 1
a142 1
 * 
d145 1
a145 1
 * 
d151 1
a151 1
 * 
d154 1
a154 1
 * 
d157 1
a157 1
 * 
d160 1
a160 1
 * 
d163 1
a163 1
 * 
d166 1
a166 1
 * 
d456 1
a456 1
 * 
d459 1
a459 1
 * 
d462 1
a462 1
 * 
d466 1
a466 1
 * 
d470 1
a470 1
 * 
d473 1
a473 1
 * 
d481 1
a481 1
 * 
d484 1
a484 1
 * 
d489 1
a489 1
 * 
d492 1
a492 1
 * 
d495 1
a495 1
 * 
d498 1
a498 1
 * 
d501 1
a501 1
 * 
d504 1
a504 1
 * 
d701 1
a701 1
 * 
d704 1
a704 1
 * 
d707 1
a707 1
 * 
d711 1
a711 1
 * 
d715 1
a715 1
 * 
d718 1
a718 1
 * 
d724 1
a724 1
 * 
d727 1
a727 1
 * 
d730 1
a730 1
 * 
d733 1
a733 1
 * 
d736 1
a736 1
 * 
d739 1
a739 1
 * 
d742 1
a742 1
 * 
d745 1
a745 1
 * 
d1264 1
a1264 1
			      i->majopc);
d1337 1
a1337 1
		       addDCond(Cond4(w)),Im11(w),Rsb(w),Rta(w));
d1340 1
a1340 1
		       subDCond(Cond4(w)),Im11(w),Rsb(w),Rta(w));
d1353 1
a1353 1
		       edDCond(Cond(w)), Rsa(w),Rsb(w),Rtc(w));
d1356 1
a1356 1
		       edDCond(Cond(w)),Rsa(w),Rsb(w),31-Imd5(w),Rtc(w));
d1368 1
a1368 1
	       edDCond(Cond(w)),Rsb(w),Imd5(w),32 - Rsc(w),Rta(w));
d1381 1
a1381 1
	       edDCond(Cond(w)),Rsb(w),32 - Rsc(w),Rta(w));
d1394 1
a1394 1
	       edDCond(Cond(w)),Rsa(w),31 - Imd5(w),32 - Rsc(w),Rtb(w));
d1407 1
a1407 1
	       edDCond(Cond(w)),Rsa(w),32 - Rsc(w),Rtb(w));
d1420 1
a1420 1
	       edDCond(Cond(w)),Ima5(w),31 - Imd5(w),32 - Imc5A(w),Rtb(w));
d1876 1
a1876 1
				       Dss(w),Rsb(w),Rsa(w),Rtc(w));
d1879 1
a1879 1
				       Rsb(w),Rsa(w),Rtc(w));
d1883 1
a1883 1
				       Dss(w),Rsb(w),Rsa(w),Rtc(w));
d1886 1
a1886 1
				       Rsb(w),Rsa(w),Rtc(w));
d1894 1
a1894 1
			       Rsa(w),Dss(w),Rsb(w),Rtc(w));
d1979 1
a1979 1
			       condStrTbl[op2], ST(r1), ST(r2));
d2087 1
a2087 1
		       p, fmtStrTbl[fmt], fmtStrTbl[dfmt], r1, t);
d2098 1
a2098 1
		       p,fmtStrTbl[fmt],condStrTbl[op2],r1,r2);
d2113 1
a2113 1
		       p, fmtStrTbl[fmt], r1, r2, t);
d2143 1
a2143 1
		dreg = 1; 
d2278 2
a2279 2
		       fsreg[Ms1(w)], fsreg[Ms2(w)], fsreg[Mt(w)],
		       fsreg[As(w)], fsreg[Ad(w)]);
d2282 2
a2283 2
		       fdreg[Ms1(w)], fdreg[Ms2(w)], fdreg[Mt(w)],
		       fdreg[As(w)], fdreg[Ad(w)]);
d2302 1
a2302 2
		       ((SinglePrec(w)) ? "sgl" : "dbl"),
		       ms1, ms2, mt, ad);
d2305 1
a2305 2
		       ((SinglePrec(w)) ? "sgl" : "dbl"),
		       ms1, ms2, mt, as, ad);
@


1.5
log
@support usermode disasm
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.4 1999/09/10 19:55:15 mickey Exp $	*/
d2325 5
a2329 4
	if (USERMODE(loc))
		copyin((caddr_t)(loc &~ HPPA_PC_PRIV_MASK),
		    &instruct, sizeof(instruct));
	else
@


1.4
log
@s/vm_offset_t/vaddr_t/g
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.3 1999/06/21 01:12:56 mickey Exp $	*/
d2320 1
a2320 1
	int instruct = *(int *)loc;
d2324 6
@


1.3
log
@unexpectedly working disasm
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.2 1999/02/15 21:13:38 mickey Exp $	*/
d2312 1
a2312 1
vm_offset_t
d2314 1
a2314 1
	vm_offset_t loc;
@


1.2
log
@lower case even more
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.1 1999/02/14 15:21:00 mickey Exp $	*/
a50 8
#define TRUE (-1)
#define FALSE (0)

#define NSYM 0
#define DSYM 1
#define ISYM DSYM
#define PSYM 3

d53 1
a53 1
#include <vm/vm_param.h>
a60 23
#define psymoff(val,typ,str) (db_printsym((db_addr_t)val, DB_STGY_ANY))
#define printf db_printf

/*
 *  Header: /n/schirf/u/baford/CVS/mach4-parisc/kernel_unused/parisc/kdb/unasm.c,v 1.5 1994/07/21 22:32:05 mike Exp
 *
 *  Spectrum Simulator Datatype Definitions
 *  Dan Magenheimer - 4/5/82
 *  Computer Research Center, Hewlett-Packard Labs
 */

typedef	int		VOID, BOOL, WORD;
typedef	char		*TEXT;

#define		FAST		register

#define		EXPORT
#define		IMPORT		extern

#undef		NULL
#define		NULL		0
#define		NO		0
#define		YES		1
d70 2
a71 2
	WORD	wd0;
	WORD	wd1;
d97 4
a100 4
	WORD	word1;
	WORD	word2;
	WORD	word3;
	WORD	word4;
d146 3
a148 3
;Revision 1.1  88/07/11  14:05:15  14:05:15  ren (Bob Naas)
;Initial revision
;
a239 1

d771 1
a771 1
	BOOL	(*dasmfcn)(const struct inst *, OFS, WORD);
d904 38
a941 41
/* Any instr disassembly replacement routines must be IMPORTed here */

static BOOL fcoprDasm __P((WORD w, u_int op1, u_int));
static TEXT edDCond __P((FAST u_int cond));
static TEXT edDCond __P((FAST u_int cond));
static TEXT unitDCond __P((FAST u_int cond));
static TEXT addDCond __P((FAST u_int cond));
static TEXT subDCond __P((FAST u_int cond));
static BOOL blDasm __P((const struct inst *i, OFS ofs, WORD w));
static BOOL ldDasm __P((const struct inst *, OFS, WORD));
static BOOL stDasm __P((const struct inst *i, OFS, WORD));
static BOOL addDasm __P((const struct inst *i, OFS, WORD));
static BOOL unitDasm __P((const struct inst *i, OFS, WORD));
static BOOL iaDasm __P((const struct inst *i, OFS, WORD));
static BOOL shdDasm __P((const struct inst *i, OFS, WORD));
static BOOL extrDasm __P((const struct inst *i, OFS, WORD));
static BOOL vextrDasm __P((const struct inst *i, OFS, WORD));
static BOOL depDasm __P((const struct inst *i, OFS, WORD));
static BOOL vdepDasm __P((const struct inst *i, OFS, WORD));
static BOOL depiDasm __P((const struct inst *i, OFS, WORD));
static BOOL vdepiDasm __P((const struct inst *i, OFS, WORD));
static BOOL limmDasm __P((const struct inst *i, OFS, WORD));
static BOOL brkDasm __P((const struct inst *i, OFS, WORD));
static BOOL lpkDasm __P((const struct inst *i, OFS, WORD));
static BOOL fmpyaddDasm __P((const struct inst *i, OFS, WORD));
static BOOL fmpysubDasm __P((const struct inst *i, OFS, WORD));
static BOOL floatDasm __P((const struct inst *i, OFS, WORD));
static BOOL coprDasm __P((const struct inst *i, OFS, WORD));
static BOOL diagDasm __P((const struct inst *i, OFS, WORD));
static BOOL scDasm __P((const struct inst *i, OFS, WORD));
static BOOL mmgtDasm __P((const struct inst *i, OFS, WORD));
static BOOL ldxDasm __P((const struct inst *i, OFS, WORD));
static BOOL stsDasm __P((const struct inst *i, OFS, WORD));
static BOOL stbysDasm __P((const struct inst *i, OFS, WORD));
static BOOL brDasm __P((const struct inst *i, OFS, WORD));
static BOOL bvDasm __P((const struct inst *i, OFS, WORD));
static BOOL beDasm __P((const struct inst *i, OFS, WORD));
static BOOL cbDasm __P((const struct inst *i,OFS ofs, WORD));
static BOOL cbiDasm __P((const struct inst *i,OFS ofs, WORD));
static BOOL bbDasm __P((const struct inst *i,OFS ofs, WORD));
static BOOL ariDasm __P((const struct inst *i, OFS, WORD));
a945 1
/*static	WORD	w;	* temp for saving passed instruction */
d1246 2
a1247 2
	FAST const struct inst *i;
	FAST const struct majoropcode *m;
d1269 2
a1270 2
				printf("%s - Bad instruction initialization!!\n", i->mnem);
				return(NO);
d1273 2
a1274 2
			((struct majoropcode *)m)->extshft = shft;
			((struct majoropcode *)m)->extmask = mask;
d1281 2
a1282 1
	for (i = &instrs[0]; *i->mnem; i++)
d1284 1
a1284 1
			majopcs[i->majopc].subops = (const struct inst **)i;
d1286 2
a1287 1
			majopcs[i->majopc].subops[i->opcext] = i;
d1290 1
a1290 1
	return(YES);
d1302 1
a1302 1
static BOOL
d1306 1
a1306 1
	WORD w;
d1308 3
a1310 3
	printf(addDCond(Cond4(w)));
	printf("\t%%r%d,%%r%d,%%r%d",Rsa(w),Rsb(w),Rtc(w));
	return(YES);
d1314 1
a1314 1
static BOOL
d1318 1
a1318 1
	WORD w;
d1320 1
a1320 1
	printf(unitDCond(Cond4(w)));
d1322 1
a1322 1
		printf("\t%%r%d,%%r%d",Rsb(w),Rtc(w));
d1324 2
a1325 2
		printf("\t%%r%d,%%r%d,%%r%d",Rsa(w),Rsb(w),Rtc(w));
	return(YES);
d1329 1
a1329 1
static BOOL
d1333 1
a1333 1
	WORD w;
d1336 1
a1336 1
		printf("%s\t%d,%%r%d,%%r%d",
d1339 1
a1339 1
		printf("%s\t%d,%%r%d,%%r%d",
d1341 1
a1341 1
	return(YES);
d1345 1
a1345 1
static BOOL
d1349 1
a1349 1
	WORD w;
d1352 1
a1352 1
		printf("%s\t%%r%d,%%r%d,%%r%d",
d1355 1
a1355 1
		printf("%s\t%%r%d,%%r%d,%d,%%r%d",
d1357 1
a1357 1
	return(YES);
d1361 1
a1361 1
static BOOL
d1365 1
a1365 1
	WORD w;
d1367 1
a1367 1
	printf("%s\t%%r%d,%d,%d,%%r%d",
d1369 1
a1369 1
	return(YES);
d1374 1
a1374 1
static BOOL
d1378 1
a1378 1
	WORD w;
d1380 1
a1380 1
	printf("%s\t%%r%d,%d,%%r%d",
d1382 1
a1382 1
	return(YES);
d1387 1
a1387 1
static BOOL
d1391 1
a1391 1
	WORD w;
d1393 1
a1393 1
	printf("%s\t%%r%d,%d,%d,%%r%d",
d1395 1
a1395 1
	return(YES);
d1400 1
a1400 1
static BOOL
d1404 1
a1404 1
	WORD w;
d1406 1
a1406 1
	printf("%s\t%%r%d,%d,%%r%d",
d1408 1
a1408 1
	return(YES);
d1413 1
a1413 1
static BOOL
d1417 1
a1417 1
	WORD w;
d1419 1
a1419 1
	printf("%s\t%d,%d,%d,%%r%d",
d1421 1
a1421 1
	return(YES);
d1425 1
a1425 1
static BOOL
d1429 1
a1429 1
	WORD w;
d1431 2
a1432 2
	printf("%s\t%d,%d,%%r%d",edDCond(Cond(w)),Ima5(w),32-Imc5A(w),Rtb(w));
	return(YES);
d1440 1
a1440 1
static TEXT
d1442 1
a1442 1
	FAST u_int cond;
d1472 1
a1472 1
static TEXT
d1474 1
a1474 1
	FAST u_int cond;
d1498 1
a1498 1
static TEXT
d1500 1
a1500 1
	FAST u_int cond;
d1520 1
a1520 1
static TEXT
d1522 1
a1522 1
	FAST u_int cond;
d1546 1
a1546 1
static BOOL
d1550 1
a1550 1
	WORD w;
d1552 1
a1552 1
	FAST u_int d = Disp(w);
d1555 2
a1556 2
		printf("ldi\t%D,%%r%d",d,Rta(w));
		return(YES);
d1559 1
a1559 1
		printf("%s\tR'%X",i->mnem,d);
d1561 1
a1561 1
		printf("%s\t%D",i->mnem,d);
d1563 1
a1563 1
		printf("(%%sr%d,%%r%d),%%r%d",Dss(w),Rsb(w),Rta(w));
d1565 2
a1566 2
		printf("(%%r%d),%%r%d",Rsb(w),Rta(w));
	return(YES);
d1570 1
a1570 1
static BOOL
d1574 1
a1574 1
	WORD w;
d1576 1
a1576 1
	FAST u_int d = Disp(w);
d1578 1
a1578 1
	printf("\t%%r%d,",Rta(w));
d1580 1
a1580 1
		printf("R'%X",d);
d1582 1
a1582 1
		printf("%D",d);
d1584 1
a1584 1
		printf("(%%sr%d,%%r%d)",Dss(w),Rsb(w));
d1586 2
a1587 2
		printf("(%%r%d)",Rsb(w));
	return(YES);
d1591 1
a1591 1
static BOOL
d1595 1
a1595 1
	WORD w;
d1597 2
d1600 1
a1600 1
		printf("s");
d1602 3
a1604 4
			printf(",m%s", ModBefore(w)? "b": "a");
	}
	else {
		printf("x");
d1606 1
a1606 1
			printf(",%sm", IndxShft(w)? "s":"");
d1609 4
a1612 4
	case NOACTION:	break;
	case STACKREF:	printf(",c"); break;
	case SEQPASS:	printf(",q"); break;
	case PREFETCH:	printf(",p"); break;
d1615 1
a1615 1
		printf("\t%d",Ima5(w));
d1617 2
a1618 1
		printf("\t%%r%d",Rsa(w));
d1620 1
a1620 1
		printf("(%%sr%d,%%r%d),%%r%d",Dss(w),Rsb(w),Rtc(w));
d1622 2
a1623 2
		printf("(%%r%d),%%r%d",Rsb(w),Rtc(w));
	return(YES);
d1627 1
a1627 1
static BOOL
d1631 1
a1631 1
	WORD w;
d1633 1
d1635 1
a1635 1
		printf(",m%s", ModBefore(w)? "b":"a");
d1638 4
a1641 4
	case NOACTION:	break;
	case STACKREF:	printf(",c"); break;
	case SEQPASS:	printf(",q"); break;
	case PREFETCH:	printf(",p"); break;
d1643 1
a1643 1
	printf("\t%%r%d,",Rta(w));
d1645 1
a1645 1
		printf("%d(%%sr%d,%%r%d)",Imc5(w),Dss(w),Rsb(w));
d1647 2
a1648 2
		printf("%d(%%r%d)",Imc5(w),Rsb(w));
	return(YES);
d1652 1
a1652 1
static BOOL
d1656 1
a1656 1
	WORD w;
d1658 2
a1659 4
	if (ModBefore(w))
		printf(",e");
	else
		printf(",b");
d1661 1
a1661 1
		printf(",m");
d1663 4
a1666 4
	case NOACTION:	break;
	case STACKREF:	printf(",f"); break;
	case SEQPASS:	printf(",r"); break;
	case PREFETCH:	printf(",z"); break;
d1668 1
a1668 1
	printf("\t%%r%d,",Rta(w));
d1670 1
a1670 1
		printf("%d(%%sr%d,%%r%d)",Imc5(w),Dss(w),Rsb(w));
d1672 2
a1673 2
		printf("%d(%%r%d)",Imc5(w),Rsb(w));
	return(YES);
d1677 1
a1677 1
static BOOL
d1681 1
a1681 1
	WORD w;
d1683 2
a1684 2
	printf("\tL'%X,%%r%d", Im21(w), Rtb(w));
	return(YES);
d1689 1
a1689 1
static BOOL
d1693 1
a1693 1
	WORD w;
d1695 2
a1696 2
	FAST OFS tgtofs = ofs + 8 + Bdisp(w);
	FAST u_int link = Rtb(w);
d1699 1
a1699 1
		printf("l");
d1701 9
a1709 5
		printf(",n");
	printf("\t");
	psymoff(tgtofs, ISYM, "");
	if (link || Match("gate")) printf(",%%r%d",link);
	return(YES);
d1713 1
a1713 1
static BOOL
d1717 1
a1717 1
	WORD w;
d1719 2
a1720 4
	if (Nu(w))
		printf(",n");
	printf("\t%%r%d,%%r%d",Rsa(w),Rtb(w));
	return(YES);
d1724 1
a1724 1
static BOOL
d1728 1
a1728 1
	WORD w;
d1730 2
a1731 4
	if (Nu(w))
		printf(",n");
	printf("\t%%r%d(%%r%d)",Rsa(w),Rsb(w));
	return(YES);
d1735 1
a1735 1
static BOOL
d1739 1
a1739 1
	WORD w;
d1741 2
a1742 1
	FAST u_int d = Bdisp(w);
d1744 1
a1744 2
	if (Nu(w))
		printf(",n");
d1746 1
a1746 1
		printf("\tR'%X(%%sr%d,%%r%d)",d,Sr(w),Rsb(w));
d1748 2
a1749 2
		printf("\t%D(%%sr%d,%%r%d)",d,Sr(w),Rsb(w));
	return(YES);
d1754 1
a1754 1
static BOOL
d1758 1
a1758 1
	WORD w;
d1760 1
a1760 1
	FAST OFS tgtofs = ofs + 8 + Cbdisp(w);
d1763 1
a1763 1
		printf(edDCond(Cond(w)));
d1765 1
a1765 1
		printf(addDCond(Cond(w) << 1));
d1767 4
a1770 6
		printf(subDCond(Cond(w) << 1));
	if (Nu(w))
		printf(",n");
	printf("\t%%r%d,%%r%d,",Rsa(w),Rsb(w));
	psymoff(tgtofs, ISYM, "");
	return(YES);
d1774 1
a1774 1
static BOOL
d1778 1
a1778 1
	WORD w;
d1780 1
a1780 1
	FAST OFS tgtofs = ofs + 8 + Cbdisp(w);
d1783 1
a1783 1
		printf(edDCond(Cond(w)));
d1785 1
a1785 1
		printf(addDCond(Cond(w) << 1));
d1787 4
a1790 6
		printf(subDCond(Cond(w) << 1));
	if (Nu(w))
		printf(",n");
	printf("\t%d,%%r%d,",Ima5(w),Rsb(w));
	psymoff(tgtofs, ISYM, "");
	return(YES);
d1794 1
a1794 1
static BOOL
d1798 1
a1798 1
	WORD w;
d1800 2
a1801 1
	FAST OFS tgtofs = ofs + 8 + Cbdisp(w);
d1803 2
a1804 3
	printf(edDCond(Cond(w)));
	if (Nu(w))
		printf(",n");
d1806 1
a1806 1
		printf("\t%%r%d,",Rta(w));
d1808 3
a1810 3
		printf("\t%%r%d,%d,",Rsa(w),Imb5(w));
	psymoff(tgtofs, ISYM, "");
	return(YES);
d1814 1
a1814 1
static BOOL
d1818 1
a1818 1
	WORD w;
d1822 1
a1822 1
			printf("nop");
d1824 5
a1828 7
			printf("copy\t%%r%d,%%r%d",Rsa(w),Rtc(w));
		return(YES);
	}
	printf(i->mnem);
	printf(subDCond(Cond4(w)));
	printf("\t%%r%d,%%r%d,%%r%d",Rsa(w),Rsb(w),Rtc(w));
	return(YES);
d1832 1
a1832 1
static BOOL
d1836 1
a1836 1
	WORD w;
d1840 1
a1840 1
			printf("mtsar\t%%r%d",Rsa(w));
d1842 2
a1843 2
			printf("mtctl\t%%r%d,%%cr%d",Rsa(w),Rtb(w));
		return(YES);
d1845 1
a1845 1
	printf(i->mnem);
d1847 6
a1852 6
		printf("\t%d,%%r%d",Ima5A(w),Rtc(w));
	else if (Match("mtsm")) printf("\t%%r%d",Rsa(w));
	else if (Match("ldprid")) printf("\t%%r%d",Rtc(w));
	else if (Match("mtsp")) printf("\t%%r%d,%%sr%d",Rsa(w),Sr(w));
	else if (Match("mfsp")) printf("\t%%sr%d,%%r%d",Sr(w),Rtc(w));
	else if (Match("mfctl")) printf("\t%%cr%d,%%r%d",Rsb(w),Rtc(w));
d1855 1
a1855 1
			printf("\t(%%sr%d,%%r%d),%%r%d",Dss(w),Rsb(w),Rtc(w));
d1857 1
a1857 1
			printf("\t(%%r%d),%%r%d",Rsb(w),Rtc(w));
d1859 2
a1860 2
		printf("?????");
		return(NO);
d1862 1
a1862 1
	return(YES);
d1866 1
a1866 1
static BOOL
d1870 1
a1870 1
	WORD w;
d1875 1
a1875 1
				printf("i\t(%%sr%d,%%r%d),%d,%%r%d",
d1878 1
a1878 1
				printf("i\t(%%r%d),%d,%%r%d",
d1882 1
a1882 1
				printf("\t(%%sr%d,%%r%d),%%r%d,%%r%d",
d1885 1
a1885 1
				printf("\t(%%r%d),%%r%d,%%r%d",
d1891 1
a1891 1
			printf(",m");
d1893 1
a1893 1
			printf("\t%%r%d(%%sr%d,%%r%d),%%r%d",
d1896 1
a1896 1
			printf("\t%%r%d(%%r%d),%%r%d",Rsa(w),Rsb(w),Rtc(w));
d1899 1
a1899 1
		if (Modify(w)) printf(",m");
d1901 1
a1901 1
			printf("\t%%r%d(%%sr%d,%%r%d)",Rsa(w),Dss(w),Rsb(w));
d1903 1
a1903 1
			printf("\t%%r%d(%%r%d)",Rsa(w),Rsb(w));
d1907 2
a1908 2
			printf(",m");
		printf("\t%%r%d(%%sr%d,%%r%d)",Rsa(w),Sr(w),Rsb(w));
d1912 1
a1912 1
			printf("\t%%r%d,(%%sr%d,%%r%d)",Rsa(w),Dss(w),Rsb(w));
d1914 1
a1914 1
			printf("\t%%r%d,(%%r%d)",Rsa(w),Rsb(w));
d1917 1
a1917 1
		printf("\t%%r%d,(%%sr%d,%%r%d)",Rsa(w),Sr(w),Rsb(w));
d1919 2
a1920 2
		printf("?????");
		return(NO);
d1922 1
a1922 1
	return(YES);
d1926 1
a1926 1
static BOOL
d1930 1
a1930 1
	WORD w;
d1932 2
a1933 2
	printf("\t%d,%d",Bi1(w),Bi2(w));
	return(YES);
d1936 1
a1936 1
static BOOL
d1940 1
a1940 1
	WORD w;
d1942 1
a1942 1
	FAST u_int op1, r1, fmt, t;
d1974 2
a1975 2
				printf(fcoprUndef);
				return(NO);
d1977 2
a1978 2
			printf("%s,%s",p,fmtStrTbl[fmt]);
			printf(",%s\t%%f%s,%%f%s",
d1980 1
a1980 1
			return(YES);
d1995 1
a1995 1
		default: printf(fcoprUndef); return(NO);
d1997 2
a1998 2
		printf("%s,%s", p, fmtStrTbl[fmt]);
		printf("\t%%f%s,%%f%s,%%f%s",ST(r1),ST(r2),ST(t));
d2016 2
a2017 2
		printf("%s,%s", p, fmtStrTbl[fmt]);
		printf(",%s\t%%f%s,%%f%s",fmtStrTbl[dfmt],ST(r1),DT(t));
d2032 1
a2032 1
		default: printf(fcoprUndef); return(NO);
d2034 2
a2035 2
		printf("%s,%s",p,fmtStrTbl[fmt]);
		printf("\t%%f%s,%%f%s",ST(r1),ST(t));
d2037 1
a2037 1
	return(YES);
d2040 1
a2040 1
BOOL
d2042 1
a2042 1
	WORD w;
d2045 2
a2046 2
	FAST u_int r1, r2, t, fmt, dfmt;
	FAST char *p;
d2050 1
a2050 1
			printf("ftest");
d2052 1
a2052 1
				printf(",acc");
d2054 2
a2055 2
				printf(",rej");
			return(YES);
d2057 1
a2057 1
		return(NO);
d2059 2
a2060 1
		printf("fcopr identify"); return(YES);
d2072 1
a2072 1
		default: printf(fcoprUndef); return(NO);
d2074 2
a2075 2
		printf("f%s,%s\t%%fr%d,%%fr%d", p, fmtStrTbl[fmt], r1, t);
		return(YES);
d2086 1
a2086 1
		printf("fcnv%s,%s,%s\t%%fr%d,%%fr%d",
d2088 1
a2088 1
		return(YES);
d2095 1
a2095 1
		default: printf(fcoprUndef); return(NO);
d2097 1
a2097 1
		printf("%s,%s,%s\t%%fr%d,%%fr%d",
d2099 1
a2099 1
		return(YES);
d2110 1
a2110 1
		default: printf(fcoprUndef); return(NO);
d2112 1
a2112 1
		printf("f%s,%s\t%%fr%d,%%fr%d,%%fr%d",
d2114 4
a2117 2
		return(YES);
	    default: printf(fcoprUndef); return(NO);
d2119 1
a2119 1
	return(YES);
d2122 1
a2122 1
static BOOL
d2126 1
a2126 1
	WORD w;
d2128 4
a2131 4
	FAST u_int uid = Uid(w);
	FAST BOOL load = NO;
	FAST char *pfx = uid > 1 ? "c" : "f";
	FAST BOOL dreg;
d2135 1
a2135 1
			printf("copr,%d,0x%x",uid,CoprExt(w));
d2137 2
a2138 2
				printf(",n");
			return(YES);
d2142 16
a2157 5
	if (Match("cldd")) { dreg = YES; load = YES; printf("%sldd",pfx); }
	else if (Match("cldw")) { load = YES; printf("%sldw",pfx); }
	else if (Match("cstd")) { dreg = YES; printf("%sstd",pfx); }
	else if (Match("cstw")) printf("%sstw",pfx);
	else { printf("copr???"); return(NO); }
d2159 1
a2159 1
		printf("s");
d2161 1
a2161 1
			printf(",m%s", ModBefore(w)?"b":"a");
d2164 1
a2164 1
		printf("x");
d2166 1
a2166 1
			printf(",%sm", IndxShft(w)?"s":"");
d2168 1
a2168 1
			printf(",s");
d2172 3
a2174 3
	case STACKREF:	printf(",c"); break;
	case SEQPASS:	printf(",q"); break;
	case PREFETCH:	printf(",p"); break;
d2177 1
a2177 1
		FAST const char *p;
d2185 1
a2185 1
			printf("\t%d",Ima5(w));
d2187 1
a2187 1
			printf("\t%%r%d",Rsa(w));
d2189 1
a2189 1
			printf("(%%sr%d,%%r%d),%%f%s", Dss(w),Rsb(w), p);
d2191 1
a2191 1
			printf("(%%r%d),%%f%s",Rsb(w), p);
d2193 1
a2193 1
		FAST const char *p;
d2201 1
a2201 1
			printf("\t%%f%s,%d", p, Ima5(w));
d2203 1
a2203 1
			printf("\t%%f%s,%%r%d", p, Rta(w));
d2205 1
a2205 1
			printf("(%%sr%d,%%r%d)",Dss(w),Rsb(w));
d2207 1
a2207 1
			printf("(%%r%d)",Rsb(w));
d2209 1
a2209 1
	return(YES);
d2212 1
a2212 1
static BOOL
d2216 1
a2216 1
	WORD w;
d2224 1
a2224 1
			printf(",m%s", ModBefore(w)?"b":"a");
d2227 1
a2227 1
			printf(",%sm", IndxShft(w)? "s":"");
d2229 1
a2229 1
			printf(",s");
d2233 3
a2235 3
	case STACKREF:	printf(",c"); break;
	case SEQPASS:	printf(",q"); break;
	case PREFETCH:	printf(",p"); break;
d2238 1
a2238 1
		printf("\t%%fr%d,%d",Rsc(w),Ima5(w));
d2240 1
a2240 1
		printf("\t%%fr%d,%%r%d",Rsc(w),Rta(w));
d2242 1
a2242 1
		printf("(%%sr%d,%%r%d)",Dss(w),Rsb(w));
d2244 2
a2245 2
		printf("(%%r%d)",Rsb(w));
	return(YES);
d2248 1
a2248 1
static BOOL
d2252 1
a2252 1
	WORD w;
d2254 12
a2265 13
	if (0x0b0 == BitfR(w,19,8,_b198)) {	/* mtcpu */
		printf("mtcpu\t%%r%d,%%dr%d", Rsa(w), Rtb(w));
		return(YES);
	}
	if (0x0d0 == BitfR(w,19,8,_b198)) {	/* mfcpu */
		printf("mfcpu\t%%dr%d,%%r%d", Rsb(w), Rta(w));
		return(YES);
	}

	printf(i->mnem);
	if (Match("diag")) {
		printf("\t0x%X",w & 0x03ffffff);
		return(YES);
d2267 1
a2267 2
	printf("?????");
	return(NO);
d2270 1
a2270 1
static BOOL
d2274 1
a2274 1
	WORD w;
d2277 1
a2277 1
		printf("SUB,SGL\t%%f%s,%%f%s,%%f%s,%%f%s,%%f%s",
d2281 1
a2281 1
		printf("SUB,DBL\t%%f%s,%%f%s,%%f%s,%%f%s,%%f%s",
d2284 1
a2284 1
	return(YES);
d2287 1
a2287 1
static BOOL
d2291 1
a2291 1
	WORD w;
d2293 1
a2293 1
	FAST const char
d2301 1
a2301 1
		printf("\t%%fcfxt,%s,%%f%s,%%f%s,%%f%s",
d2305 1
a2305 1
		printf("add%s\t%%f%s,%%f%s,%%f%s,%%f%s,%%f%s",
d2309 1
a2309 1
	return(YES);
d2317 4
a2320 4
	FAST const struct inst *i;
	FAST const struct majoropcode *m;
	FAST u_int ext;
	WORD instruct = *(WORD*)loc;
d2330 1
a2330 1
			i = m->subops[ext];
d2334 5
a2338 3
		if (i->dasmfcn == coprDasm || i->dasmfcn == diagDasm ||
		    i->dasmfcn == ariDasm || i->dasmfcn == scDasm ||
		    i->dasmfcn == ldDasm)
d2340 2
a2341 7
		else {
			printf(i->mnem);
			if (i->dasmfcn)
				(*i->dasmfcn)(i, ofs, instruct);
			else if (i->mnem[0] == '?')
				db_printf(illeg.mnem);
		}
d2345 1
@


1.1
log
@add disassembler, mainly HP code, tamed to ddb by me
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d982 2
a983 2
static	const char	fcoprUndef[] = "COPR\t(rsvd or undef.)";
static	const char	fmtStrTbl[][5] = { "SGL", "DBL", "SGL", "QUAD" };
d985 1
a985 1
	    "false?", "false", "?", "!<=>", "=", "=T", "?=", "!<>",
d988 1
a988 1
	    "!?=", "<>", "!=", "!=T", "!?", "<=>", "true?", "true"
d1355 1
a1355 1
	if (Match("DCOR") || Match("IDCOR"))
d1369 1
a1369 1
	if (Match("ADDI"))
d1385 1
a1385 1
	if (Match("VSHD"))
d1484 2
a1485 2
	case SV:	return(",SV");
	case OD:	return(",OD");
d1491 3
a1493 3
	case NSV:	return(",NSV");
	case EV:	return(",EV");
	case TR:	return(",TR");
d1514 4
a1517 4
	case NUV:	return(",NUV");
	case ZNV:	return(",ZNV");
	case SV:	return(",SV");
	case OD:	return(",OD");
d1521 5
a1525 5
	case UV:	return(",UV");
	case VNZ:	return(",VNZ");
	case NSV:	return(",NSV");
	case EV:	return(",EV");
	case TR:	return(",TR");
d1537 11
a1547 11
	case SHC:	return(",SHC");
	case SHZ:	return(",SHZ");
	case SBC:	return(",SBC");
	case SBZ:	return(",SBZ");
	case SDC:	return(",SDC");
	case NHC:	return(",NHC");
	case NHZ:	return(",NHZ");
	case NBC:	return(",NBC");
	case NBZ:	return(",NBZ");
	case NDC:	return(",NDC");
	case TR:	return(",TR");
d1559 2
a1560 2
	case XOD:	return(",OD");
	case XTR:	return(",TR");
d1565 1
a1565 1
	case XEV:	return(",EV");
d1588 2
a1589 2
	if (Rsb(w) == 0 && Match("LDO")) {
		printf("LDI\t%D,%%r%d",d,Rta(w));
d1632 3
a1634 5
		printf("S");
		if (Modify(w)) {
			if (ModBefore(w)) printf(",MB");
			else printf(",MA");
		}
d1637 3
a1639 6
		printf("X");
		if (Modify(w)) {
			if (IndxShft(w)) printf(",SM");
			else printf(",M");
		}
		else if (IndxShft(w)) printf(",S");
d1642 4
a1645 4
		case NOACTION:	break;
		case STACKREF:	printf(",C"); break;
		case SEQPASS:	printf(",Q"); break;
		case PREFETCH:	printf(",P"); break;
d1665 3
a1667 4
	if (Modify(w)) {
		if (ModBefore(w)) printf(",MB");
		else printf(",MA");
	}
d1669 4
a1672 4
		case NOACTION:	break;
		case STACKREF:	printf(",C"); break;
		case SEQPASS:	printf(",Q"); break;
		case PREFETCH:	printf(",P"); break;
d1689 6
a1694 3
	if (ModBefore(w)) printf(",E");
	else printf(",B");
	if (Modify(w)) printf(",M");
d1696 4
a1699 4
		case NOACTION:	break;
		case STACKREF:	printf(",F"); break;
		case SEQPASS:	printf(",R"); break;
		case PREFETCH:	printf(",Z"); break;
d1731 4
a1734 2
	if (link && !Match("GATE")) printf("L");
	if (Nu(w)) printf(",N");
d1737 1
a1737 1
	if (link || Match("GATE")) printf(",%%r%d",link);
d1748 2
a1749 1
	if (Nu(w)) printf(",N");
d1762 1
a1762 1
		printf(",N");
d1777 1
a1777 1
		printf(",N");
d1795 8
a1802 4
	if (Match("MOVB")) printf(edDCond(Cond(w)));
	else if (Match("ADDB")) printf(addDCond(Cond(w) << 1));
	else printf(subDCond(Cond(w) << 1));
	if (Nu(w)) printf(",N");
d1817 8
a1824 4
	if (Match("MOVIB")) printf(edDCond(Cond(w)));
	else if (Match("ADDIB")) printf(addDCond(Cond(w) << 1));
	else printf(subDCond(Cond(w) << 1));
	if (Nu(w)) printf(",N");
d1840 6
a1845 3
	if (Nu(w)) printf(",N");
	if (Match("BVB")) printf("\t%%r%d,",Rta(w));
	else printf("\t%%r%d,%d,",Rsa(w),Imb5(w));
d1857 1
a1857 1
	if (Match("OR") && Rsb(w) == 0 && Cond4(w) == NEV) {
d1859 1
a1859 1
			printf("NOP");
d1861 1
a1861 1
			printf("COPY\t%%r%d,%%r%d",Rsa(w),Rtc(w));
d1877 1
a1877 1
	if (Match("MTCTL")) {
d1879 1
a1879 1
			printf("MTSAR\t%%r%d",Rsa(w));
d1881 1
a1881 1
			printf("MTCTL\t%%r%d,%%cr%d",Rsa(w),Rtb(w));
d1885 8
a1892 7
	if (Match("SSM") || Match("RSM")) printf("\t%d,%%r%d",Ima5A(w),Rtc(w));
	else if (Match("MTSM")) printf("\t%%r%d",Rsa(w));
	else if (Match("LDPRID")) printf("\t%%r%d",Rtc(w));
	else if (Match("MTSP")) printf("\t%%r%d,%%sr%d",Rsa(w),Sr(w));
	else if (Match("MFSP")) printf("\t%%sr%d,%%r%d",Sr(w),Rtc(w));
	else if (Match("MFCTL")) printf("\t%%cr%d,%%r%d",Rsb(w),Rtc(w));
	else if (Match("LDSID")) {
d1911 1
a1911 1
	if (Match("PROBE")) {
d1914 1
a1914 1
				printf("I\t(%%sr%d,%%r%d),%d,%%r%d",
d1917 1
a1917 1
				printf("I\t(%%r%d),%d,%%r%d",
d1928 3
a1930 2
	else if (Match("LHA") || Match("LPA")) {
		if (Modify(w)) printf(",M");
d1937 2
a1938 2
	else if (Match("PDTLB") || Match("PDC") || Match("FDC")) {
		if (Modify(w)) printf(",M");
d1944 3
a1946 2
	else if (Match("PITLB") || Match("FIC")) {
		if (Modify(w)) printf(",M");
d1949 1
a1949 1
	else if (Match("IDTLB")) {
d1955 1
a1955 1
	else if (Match("IITLB"))
d2010 1
a2010 1
				p = "CMP";
d2029 6
a2034 6
		    case 0: p = "ADD"; break;
		    case 1: p = "SUB"; break;
		    case 2: p = (Fpi(w)) ? "MPYI" : "MPY"; break;
		    case 3: p = "DIV"; break;
		    case 4: p = "REM"; break;
		    default: printf(fcoprUndef); return(NO);
d2036 1
a2036 1
		printf("%s,%s",p,fmtStrTbl[fmt]);
d2050 4
a2053 4
		    case 0: p = "FF"; break;
		    case 1: p = "XF"; break;
		    case 2: p = "FX"; break;
		    case 3: p = "FXT"; break;
d2055 1
a2055 1
		printf("%s,%s",p,fmtStrTbl[fmt]);
d2066 6
a2071 6
		    case 1: p = "RSQRT"; break;
		    case 2: p = "CPY"; break;
		    case 3: p = "ABS"; break;
		    case 4: p = "SQRT"; break;
		    case 5: p = "RND"; break;
		    default: printf(fcoprUndef); return(NO);
d2088 7
a2094 8
		if (op2 == 0) {
			printf("FTEST"); return(YES);
		}
		if (op2 == 1) {
			printf("FTEST,ACC"); return(YES);
		}
		if (op2 == 2) {
			printf("FTEST,REJ"); return(YES);
d2098 1
a2098 1
		printf("FCOPR IDENTIFY"); return(YES);
d2105 6
a2110 6
		    case 1: p = "FRSQRT"; break;
		    case 2: p = "FCPY"; break;
		    case 3: p = "FABS"; break;
		    case 4: p = "FSQRT"; break;
		    case 5: p = "FRND"; break;
		    default: printf(fcoprUndef); return(NO);
d2112 1
a2112 1
		printf("%s,%s\t%%fr%d,%%fr%d",p,fmtStrTbl[fmt],r1,t);
d2119 4
a2122 4
		    case 0: p = "FCNVFF"; break;
		    case 1: p = "FCNVXF"; break;
		    case 2: p = "FCNVFX"; break;
		    case 3: p = "FCNVFXT"; break;
d2124 2
a2125 1
		printf("%s,%s,%s\t%%fr%d,%%fr%d",p,fmtStrTbl[fmt],fmtStrTbl[dfmt],r1,t);
d2132 2
a2133 2
		    case 0: p = "FCMP"; break;
		    default: printf(fcoprUndef); return(NO);
d2135 2
a2136 1
		printf("%s,%s,%s\t%%fr%d,%%fr%d",p,fmtStrTbl[fmt],condStrTbl[op2],r1,r2);
d2143 6
a2148 6
		    case 0: p = "FADD"; break;
		    case 1: p = "FSUB"; break;
		    case 2: p = "FMPY"; break;
		    case 3: p = "FDIV"; break;
		    case 4: p = "FREM"; break;
		    default: printf(fcoprUndef); return(NO);
d2150 2
a2151 1
		printf("%s,%s\t%%fr%d,%%fr%d,%%fr%d",p,fmtStrTbl[fmt],r1,r2,t);
d2166 1
a2166 1
	FAST char *pfx = uid > 1 ? "C" : "F";
d2169 1
a2169 1
	if (Match("COPR")) {
d2171 3
a2173 2
			printf("COPR,%d,0x%x",uid,CoprExt(w));
			if (AstNu(w)) printf(",N");
d2178 5
a2182 5
	if (Match("CLDD")) { dreg = YES; load = YES; printf("%sLDD",pfx); }
	else if (Match("CLDW")) { load = YES; printf("%sLDW",pfx); }
	else if (Match("CSTD")) { dreg = YES; printf("%sSTD",pfx); }
	else if (Match("CSTW")) printf("%sSTW",pfx);
	else { printf("COPR???"); return(NO); }
d2184 1
a2184 1
		printf("S");
d2186 1
a2186 1
			printf(ModBefore(w)?",MB":",MA");
d2189 1
a2189 1
		printf("X");
d2191 1
a2191 1
			printf(IndxShft(w)?",SM":",M");
d2193 1
a2193 1
			printf(",S");
d2196 4
a2199 4
		case NOACTION:	break;
		case STACKREF:	printf(",C"); break;
		case SEQPASS:	printf(",Q"); break;
		case PREFETCH:	printf(",P"); break;
d2248 2
a2249 4
		if (Modify(w)) {
			if (ModBefore(w)) printf(",MB");
			else printf(",MA");
		}
d2251 4
a2254 5
		if (Modify(w)) {
			if (IndxShft(w)) printf(",SM");
			else printf(",M");
		}
		else if (IndxShft(w)) printf(",S");
d2257 4
a2260 4
		case NOACTION:	break;
		case STACKREF:	printf(",C"); break;
		case SEQPASS:	printf(",Q"); break;
		case PREFETCH:	printf(",P"); break;
d2280 1
a2280 1
		printf("MTCPU\t%%r%d,%%dr%d", Rsa(w), Rtb(w));
d2284 1
a2284 1
		printf("MFCPU\t%%dr%d,%%r%d", Rsb(w), Rta(w));
d2289 1
a2289 1
	if (Match("DIAG")) {
d2328 2
a2329 2
		printf("\t%%f%s,%%f%s,%%f%s,%%f%s",
		       ((SinglePrec(w)) ? "CFXT,SGL" : "CFXT,DBL"),
d2332 2
a2333 2
		printf("%s\t%%f%s,%%f%s,%%f%s,%%f%s,%%f%s",
		       ((SinglePrec(w)) ? "ADD,SGL" : "ADD,DBL"),
@

