head	1.247;
access;
symbols
	OPENBSD_6_1:1.247.0.4
	OPENBSD_6_1_BASE:1.247
	OPENBSD_6_0:1.245.0.2
	OPENBSD_6_0_BASE:1.245
	OPENBSD_5_9:1.242.0.2
	OPENBSD_5_9_BASE:1.242
	OPENBSD_5_8:1.241.0.6
	OPENBSD_5_8_BASE:1.241
	OPENBSD_5_7:1.241.0.2
	OPENBSD_5_7_BASE:1.241
	OPENBSD_5_6:1.233.0.4
	OPENBSD_5_6_BASE:1.233
	OPENBSD_5_5:1.213.0.4
	OPENBSD_5_5_BASE:1.213
	OPENBSD_5_4:1.211.0.2
	OPENBSD_5_4_BASE:1.211
	OPENBSD_5_3:1.210.0.2
	OPENBSD_5_3_BASE:1.210
	OPENBSD_5_2:1.206.0.2
	OPENBSD_5_2_BASE:1.206
	OPENBSD_5_1_BASE:1.205
	OPENBSD_5_1:1.205.0.2
	OPENBSD_5_0:1.204.0.2
	OPENBSD_5_0_BASE:1.204
	OPENBSD_4_9:1.199.0.2
	OPENBSD_4_9_BASE:1.199
	OPENBSD_4_8:1.193.0.2
	OPENBSD_4_8_BASE:1.193
	OPENBSD_4_7:1.179.0.2
	OPENBSD_4_7_BASE:1.179
	OPENBSD_4_6:1.173.0.4
	OPENBSD_4_6_BASE:1.173
	OPENBSD_4_5:1.171.0.2
	OPENBSD_4_5_BASE:1.171
	OPENBSD_4_4:1.168.0.2
	OPENBSD_4_4_BASE:1.168
	OPENBSD_4_3:1.165.0.2
	OPENBSD_4_3_BASE:1.165
	OPENBSD_4_2:1.164.0.2
	OPENBSD_4_2_BASE:1.164
	OPENBSD_4_1:1.151.0.4
	OPENBSD_4_1_BASE:1.151
	OPENBSD_4_0:1.151.0.2
	OPENBSD_4_0_BASE:1.151
	OPENBSD_3_9:1.149.0.2
	OPENBSD_3_9_BASE:1.149
	OPENBSD_3_8:1.148.0.2
	OPENBSD_3_8_BASE:1.148
	OPENBSD_3_7:1.141.0.2
	OPENBSD_3_7_BASE:1.141
	OPENBSD_3_6:1.132.0.2
	OPENBSD_3_6_BASE:1.132
	SMP_SYNC_A:1.130
	SMP_SYNC_B:1.130
	OPENBSD_3_5:1.125.0.2
	OPENBSD_3_5_BASE:1.125
	OPENBSD_3_4:1.113.0.2
	OPENBSD_3_4_BASE:1.113
	UBC_SYNC_A:1.104
	OPENBSD_3_3:1.102.0.2
	OPENBSD_3_3_BASE:1.102
	OPENBSD_3_2:1.81.0.2
	OPENBSD_3_2_BASE:1.81
	OPENBSD_3_1:1.66.0.2
	OPENBSD_3_1_BASE:1.66
	UBC_SYNC_B:1.87
	UBC:1.47.0.2
	UBC_BASE:1.47
	OPENBSD_3_0:1.40.0.2
	OPENBSD_3_0_BASE:1.40
	OPENBSD_2_9:1.31.0.2
	OPENBSD_2_9_BASE:1.31
	OPENBSD_2_8:1.29.0.2
	OPENBSD_2_8_BASE:1.29
	OPENBSD_2_7:1.25.0.2
	OPENBSD_2_7_BASE:1.25
	SMP:1.21.0.2
	SMP_BASE:1.21
	kame_19991208:1.15
	OPENBSD_2_6:1.14.0.2
	OPENBSD_2_6_BASE:1.14
	OPENBSD_2_5:1.4.0.2
	OPENBSD_2_5_BASE:1.4;
locks; strict;
comment	@ * @;


1.247
date	2016.10.09.11.25.39;	author tom;	state Exp;
branches;
next	1.246;
commitid	DfYvEDcFmu1LY9q1;

1.246
date	2016.09.15.02.00.17;	author dlg;	state Exp;
branches;
next	1.245;
commitid	RlO92XR575sygHqm;

1.245
date	2016.05.21.00.56.43;	author deraadt;	state Exp;
branches;
next	1.244;
commitid	oWpLaBOdDMvIxei3;

1.244
date	2016.05.10.18.39.44;	author deraadt;	state Exp;
branches;
next	1.243;
commitid	qfOifNidEGDB2jL1;

1.243
date	2016.04.20.23.52.04;	author dlg;	state Exp;
branches;
next	1.242;
commitid	hfeQvhMJUSqav4QG;

1.242
date	2015.10.21.07.59.18;	author mpi;	state Exp;
branches;
next	1.241;
commitid	XglPgGQ8qaiL0M4l;

1.241
date	2015.01.20.19.43.20;	author kettenis;	state Exp;
branches;
next	1.240;
commitid	Fn841MmVYz2JHvBP;

1.240
date	2014.12.10.15.29.53;	author mikeb;	state Exp;
branches;
next	1.239;
commitid	qHQiR2HLROzvZr7B;

1.239
date	2014.10.25.17.31.26;	author kettenis;	state Exp;
branches;
next	1.238;
commitid	4yulu09TU8ouklVA;

1.238
date	2014.10.23.16.57.45;	author miod;	state Exp;
branches;
next	1.237;
commitid	qauDGov2q6wKwrNg;

1.237
date	2014.10.23.16.49.58;	author miod;	state Exp;
branches;
next	1.236;
commitid	6uMeMEEXeyenIHoc;

1.236
date	2014.09.22.12.12.23;	author dlg;	state Exp;
branches;
next	1.235;
commitid	110ZOYfYFru8WqOb;

1.235
date	2014.09.19.18.21.14;	author kettenis;	state Exp;
branches;
next	1.234;
commitid	oXw0lqB9A4Arhr2x;

1.234
date	2014.08.18.05.11.03;	author dlg;	state Exp;
branches;
next	1.233;
commitid	hjFdrSJM3VTXJUZV;

1.233
date	2014.07.22.01.04.04;	author uebayasi;	state Exp;
branches;
next	1.232;
commitid	NQKNjqRml7IP6o0a;

1.232
date	2014.07.21.17.25.47;	author uebayasi;	state Exp;
branches;
next	1.231;
commitid	7QO4UJr3EKVAMc8t;

1.231
date	2014.07.13.22.53.38;	author uebayasi;	state Exp;
branches;
next	1.230;
commitid	wsdp3qtXGjMj98oD;

1.230
date	2014.07.13.22.13.06;	author uebayasi;	state Exp;
branches;
next	1.229;
commitid	qYPOd6Qi4aRBKldK;

1.229
date	2014.07.13.09.08.20;	author miod;	state Exp;
branches;
next	1.228;
commitid	2861ZNGwagNBNLEr;

1.228
date	2014.07.12.22.37.03;	author uebayasi;	state Exp;
branches;
next	1.227;
commitid	5h3kYJioMDqUXM3V;

1.227
date	2014.07.12.14.12.44;	author uebayasi;	state Exp;
branches;
next	1.226;
commitid	CwxiCWSX4kdxVfoo;

1.226
date	2014.07.10.21.46.02;	author mpi;	state Exp;
branches;
next	1.225;
commitid	iYq3Z1ZWDKR3sS9G;

1.225
date	2014.07.10.20.15.26;	author uebayasi;	state Exp;
branches;
next	1.224;
commitid	YzvTa4t6mddz7Mh4;

1.224
date	2014.07.10.13.34.32;	author uebayasi;	state Exp;
branches;
next	1.223;
commitid	xpsLTYRIkonFtkr1;

1.223
date	2014.07.10.12.13.48;	author uebayasi;	state Exp;
branches;
next	1.222;
commitid	aofvn6ceiucgjg4N;

1.222
date	2014.05.31.15.49.28;	author mpi;	state Exp;
branches;
next	1.221;
commitid	eA4Y0YE1IUzj6hpW;

1.221
date	2014.05.30.13.46.16;	author mpi;	state Exp;
branches;
next	1.220;

1.220
date	2014.05.08.21.32.45;	author miod;	state Exp;
branches;
next	1.219;

1.219
date	2014.04.08.09.34.23;	author mpi;	state Exp;
branches;
next	1.218;

1.218
date	2014.04.04.20.25.21;	author miod;	state Exp;
branches;
next	1.217;

1.217
date	2014.03.29.18.09.29;	author guenther;	state Exp;
branches;
next	1.216;

1.216
date	2014.03.26.05.23.42;	author guenther;	state Exp;
branches;
next	1.215;

1.215
date	2014.03.22.06.05.45;	author guenther;	state Exp;
branches;
next	1.214;

1.214
date	2014.03.13.03.52.55;	author dlg;	state Exp;
branches;
next	1.213;

1.213
date	2013.11.23.07.20.52;	author uebayasi;	state Exp;
branches;
next	1.212;

1.212
date	2013.09.28.12.40.29;	author miod;	state Exp;
branches;
next	1.211;

1.211
date	2013.06.11.16.42.08;	author deraadt;	state Exp;
branches;
next	1.210;

1.210
date	2012.12.02.07.03.31;	author guenther;	state Exp;
branches;
next	1.209;

1.209
date	2012.10.26.12.32.48;	author kettenis;	state Exp;
branches;
next	1.208;

1.208
date	2012.10.08.21.47.47;	author deraadt;	state Exp;
branches;
next	1.207;

1.207
date	2012.10.07.20.39.15;	author kettenis;	state Exp;
branches;
next	1.206;

1.206
date	2012.06.21.00.56.59;	author guenther;	state Exp;
branches;
next	1.205;

1.205
date	2011.09.20.09.49.38;	author miod;	state Exp;
branches;
next	1.204;

1.204
date	2011.07.05.04.48.01;	author guenther;	state Exp;
branches;
next	1.203;

1.203
date	2011.06.26.22.39.59;	author deraadt;	state Exp;
branches;
next	1.202;

1.202
date	2011.06.05.19.41.06;	author deraadt;	state Exp;
branches;
next	1.201;

1.201
date	2011.04.18.21.44.55;	author guenther;	state Exp;
branches;
next	1.200;

1.200
date	2011.04.15.04.52.39;	author guenther;	state Exp;
branches;
next	1.199;

1.199
date	2011.01.14.13.32.43;	author jsing;	state Exp;
branches;
next	1.198;

1.198
date	2011.01.04.17.59.14;	author jasper;	state Exp;
branches;
next	1.197;

1.197
date	2011.01.01.19.00.56;	author jasper;	state Exp;
branches;
next	1.196;

1.196
date	2011.01.01.18.59.26;	author jasper;	state Exp;
branches;
next	1.195;

1.195
date	2010.12.30.14.26.14;	author jsing;	state Exp;
branches;
next	1.194;

1.194
date	2010.11.20.20.33.23;	author miod;	state Exp;
branches;
next	1.193;

1.193
date	2010.07.01.05.33.32;	author jsing;	state Exp;
branches;
next	1.192;

1.192
date	2010.06.29.20.30.32;	author guenther;	state Exp;
branches;
next	1.191;

1.191
date	2010.06.29.04.03.21;	author jsing;	state Exp;
branches;
next	1.190;

1.190
date	2010.06.29.00.50.40;	author jsing;	state Exp;
branches;
next	1.189;

1.189
date	2010.06.27.03.03.48;	author thib;	state Exp;
branches;
next	1.188;

1.188
date	2010.06.27.00.04.44;	author jsing;	state Exp;
branches;
next	1.187;

1.187
date	2010.06.10.17.54.13;	author deraadt;	state Exp;
branches;
next	1.186;

1.186
date	2010.06.09.15.44.17;	author miod;	state Exp;
branches;
next	1.185;

1.185
date	2010.05.24.15.04.55;	author deraadt;	state Exp;
branches;
next	1.184;

1.184
date	2010.05.09.17.37.33;	author kettenis;	state Exp;
branches;
next	1.183;

1.183
date	2010.05.02.22.59.11;	author kettenis;	state Exp;
branches;
next	1.182;

1.182
date	2010.04.27.21.09.49;	author kettenis;	state Exp;
branches;
next	1.181;

1.181
date	2010.04.19.14.05.04;	author jsing;	state Exp;
branches;
next	1.180;

1.180
date	2010.04.01.12.30.38;	author jsing;	state Exp;
branches;
next	1.179;

1.179
date	2009.12.31.12.52.35;	author jsing;	state Exp;
branches;
next	1.178;

1.178
date	2009.08.11.19.17.16;	author miod;	state Exp;
branches;
next	1.177;

1.177
date	2009.08.11.18.46.32;	author miod;	state Exp;
branches;
next	1.176;

1.176
date	2009.08.09.10.40.17;	author blambert;	state Exp;
branches;
next	1.175;

1.175
date	2009.08.02.16.28.39;	author beck;	state Exp;
branches;
next	1.174;

1.174
date	2009.07.29.18.31.11;	author kettenis;	state Exp;
branches;
next	1.173;

1.173
date	2009.06.15.17.01.25;	author beck;	state Exp;
branches;
next	1.172;

1.172
date	2009.06.03.21.30.19;	author beck;	state Exp;
branches;
next	1.171;

1.171
date	2009.02.14.18.51.03;	author kettenis;	state Exp;
branches;
next	1.170;

1.170
date	2009.02.04.17.22.23;	author miod;	state Exp;
branches;
next	1.169;

1.169
date	2009.02.04.17.19.17;	author miod;	state Exp;
branches;
next	1.168;

1.168
date	2008.07.14.13.37.39;	author miod;	state Exp;
branches;
next	1.167;

1.167
date	2008.06.27.17.22.14;	author miod;	state Exp;
branches;
next	1.166;

1.166
date	2008.04.09.16.58.10;	author deraadt;	state Exp;
branches;
next	1.165;

1.165
date	2007.09.22.09.57.40;	author martin;	state Exp;
branches;
next	1.164;

1.164
date	2007.07.22.19.24.45;	author kettenis;	state Exp;
branches;
next	1.163;

1.163
date	2007.07.20.22.12.39;	author kettenis;	state Exp;
branches;
next	1.162;

1.162
date	2007.07.15.19.25.49;	author kettenis;	state Exp;
branches;
next	1.161;

1.161
date	2007.07.14.22.41.54;	author kettenis;	state Exp;
branches;
next	1.160;

1.160
date	2007.07.10.17.28.32;	author kettenis;	state Exp;
branches;
next	1.159;

1.159
date	2007.06.24.17.00.50;	author kettenis;	state Exp;
branches;
next	1.158;

1.158
date	2007.06.06.17.15.11;	author deraadt;	state Exp;
branches;
next	1.157;

1.157
date	2007.05.27.17.31.56;	author miod;	state Exp;
branches;
next	1.156;

1.156
date	2007.05.26.20.26.50;	author pedro;	state Exp;
branches;
next	1.155;

1.155
date	2007.05.21.23.05.44;	author kettenis;	state Exp;
branches;
next	1.154;

1.154
date	2007.05.21.23.00.19;	author kettenis;	state Exp;
branches;
next	1.153;

1.153
date	2007.05.17.14.24.59;	author art;	state Exp;
branches;
next	1.152;

1.152
date	2007.05.14.19.54.21;	author martin;	state Exp;
branches;
next	1.151;

1.151
date	2006.05.28.23.08.07;	author martin;	state Exp;
branches;
next	1.150;

1.150
date	2006.04.15.15.35.20;	author martin;	state Exp;
branches;
next	1.149;

1.149
date	2005.10.26.18.35.44;	author martin;	state Exp;
branches;
next	1.148;

1.148
date	2005.08.06.14.26.52;	author miod;	state Exp;
branches;
next	1.147;

1.147
date	2005.07.11.04.04.30;	author mickey;	state Exp;
branches;
next	1.146;

1.146
date	2005.05.10.11.23.39;	author mickey;	state Exp;
branches;
next	1.145;

1.145
date	2005.04.18.12.16.03;	author mickey;	state Exp;
branches;
next	1.144;

1.144
date	2005.04.07.13.16.12;	author mickey;	state Exp;
branches;
next	1.143;

1.143
date	2005.04.07.00.21.51;	author mickey;	state Exp;
branches;
next	1.142;

1.142
date	2005.03.26.20.04.37;	author mickey;	state Exp;
branches;
next	1.141;

1.141
date	2005.02.24.17.20.53;	author mickey;	state Exp;
branches;
next	1.140;

1.140
date	2004.11.17.16.06.50;	author mickey;	state Exp;
branches;
next	1.139;

1.139
date	2004.10.26.20.18.01;	author mickey;	state Exp;
branches;
next	1.138;

1.138
date	2004.10.14.18.30.49;	author mickey;	state Exp;
branches;
next	1.137;

1.137
date	2004.09.19.01.30.11;	author mickey;	state Exp;
branches;
next	1.136;

1.136
date	2004.09.18.05.06.17;	author mickey;	state Exp;
branches;
next	1.135;

1.135
date	2004.09.15.21.32.43;	author mickey;	state Exp;
branches;
next	1.134;

1.134
date	2004.09.14.23.39.32;	author mickey;	state Exp;
branches;
next	1.133;

1.133
date	2004.09.14.22.37.16;	author mickey;	state Exp;
branches;
next	1.132;

1.132
date	2004.07.01.21.03.32;	author mickey;	state Exp;
branches;
next	1.131;

1.131
date	2004.06.30.18.18.54;	author mickey;	state Exp;
branches;
next	1.130;

1.130
date	2004.05.13.15.09.19;	author mickey;	state Exp;
branches;
next	1.129;

1.129
date	2004.05.05.02.18.43;	author mickey;	state Exp;
branches;
next	1.128;

1.128
date	2004.05.05.00.32.17;	author mickey;	state Exp;
branches;
next	1.127;

1.127
date	2004.04.08.17.10.18;	author mickey;	state Exp;
branches;
next	1.126;

1.126
date	2004.04.07.18.24.19;	author mickey;	state Exp;
branches;
next	1.125;

1.125
date	2004.03.10.23.02.53;	author tom;	state Exp;
branches;
next	1.124;

1.124
date	2004.02.14.15.09.22;	author grange;	state Exp;
branches;
next	1.123;

1.123
date	2004.01.05.17.07.00;	author mickey;	state Exp;
branches;
next	1.122;

1.122
date	2003.12.23.23.47.07;	author mickey;	state Exp;
branches;
next	1.121;

1.121
date	2003.12.20.16.13.53;	author miod;	state Exp;
branches;
next	1.120;

1.120
date	2003.12.18.08.05.20;	author mickey;	state Exp;
branches;
next	1.119;

1.119
date	2003.12.17.05.46.37;	author mickey;	state Exp;
branches;
next	1.118;

1.118
date	2003.12.10.20.57.32;	author mickey;	state Exp;
branches;
next	1.117;

1.117
date	2003.11.24.19.27.03;	author mickey;	state Exp;
branches;
next	1.116;

1.116
date	2003.10.15.18.54.55;	author mickey;	state Exp;
branches;
next	1.115;

1.115
date	2003.10.05.14.13.28;	author mickey;	state Exp;
branches;
next	1.114;

1.114
date	2003.09.25.22.20.44;	author mickey;	state Exp;
branches;
next	1.113;

1.113
date	2003.09.04.07.02.37;	author mickey;	state Exp;
branches;
next	1.112;

1.112
date	2003.08.31.00.23.16;	author miod;	state Exp;
branches;
next	1.111;

1.111
date	2003.08.20.03.15.44;	author mickey;	state Exp;
branches;
next	1.110;

1.110
date	2003.08.07.19.54.14;	author mickey;	state Exp;
branches;
next	1.109;

1.109
date	2003.08.07.19.26.19;	author mickey;	state Exp;
branches;
next	1.108;

1.108
date	2003.08.03.18.55.04;	author mickey;	state Exp;
branches;
next	1.107;

1.107
date	2003.07.30.21.24.19;	author mickey;	state Exp;
branches;
next	1.106;

1.106
date	2003.05.22.19.27.50;	author mickey;	state Exp;
branches;
next	1.105;

1.105
date	2003.05.18.15.57.46;	author mickey;	state Exp;
branches;
next	1.104;

1.104
date	2003.05.11.19.41.09;	author deraadt;	state Exp;
branches;
next	1.103;

1.103
date	2003.04.07.16.20.38;	author mickey;	state Exp;
branches;
next	1.102;

1.102
date	2003.02.18.19.01.50;	author deraadt;	state Exp;
branches;
next	1.101;

1.101
date	2003.02.12.21.33.40;	author jason;	state Exp;
branches;
next	1.100;

1.100
date	2003.02.12.05.30.47;	author mickey;	state Exp;
branches;
next	1.99;

1.99
date	2003.02.10.15.47.02;	author mickey;	state Exp;
branches;
next	1.98;

1.98
date	2003.01.22.18.16.34;	author mickey;	state Exp;
branches;
next	1.97;

1.97
date	2003.01.14.16.06.53;	author mickey;	state Exp;
branches;
next	1.96;

1.96
date	2003.01.14.12.17.07;	author mickey;	state Exp;
branches;
next	1.95;

1.95
date	2003.01.13.19.53.34;	author mickey;	state Exp;
branches;
next	1.94;

1.94
date	2003.01.09.22.27.09;	author miod;	state Exp;
branches;
next	1.93;

1.93
date	2002.12.19.00.46.21;	author mickey;	state Exp;
branches;
next	1.92;

1.92
date	2002.12.19.00.41.20;	author mickey;	state Exp;
branches;
next	1.91;

1.91
date	2002.12.17.23.11.32;	author millert;	state Exp;
branches;
next	1.90;

1.90
date	2002.11.27.21.47.14;	author mickey;	state Exp;
branches;
next	1.89;

1.89
date	2002.11.08.01.59.53;	author mickey;	state Exp;
branches;
next	1.88;

1.88
date	2002.11.01.00.14.43;	author mickey;	state Exp;
branches;
next	1.87;

1.87
date	2002.10.22.19.35.45;	author mickey;	state Exp;
branches;
next	1.86;

1.86
date	2002.10.15.14.44.45;	author mickey;	state Exp;
branches;
next	1.85;

1.85
date	2002.10.13.15.53.39;	author mickey;	state Exp;
branches;
next	1.84;

1.84
date	2002.10.07.15.32.37;	author mickey;	state Exp;
branches;
next	1.83;

1.83
date	2002.10.07.14.42.07;	author mickey;	state Exp;
branches;
next	1.82;

1.82
date	2002.10.07.14.38.34;	author mickey;	state Exp;
branches;
next	1.81;

1.81
date	2002.09.23.17.43.20;	author mickey;	state Exp;
branches;
next	1.80;

1.80
date	2002.09.17.03.51.49;	author mickey;	state Exp;
branches;
next	1.79;

1.79
date	2002.09.11.16.01.37;	author mickey;	state Exp;
branches;
next	1.78;

1.78
date	2002.09.11.15.55.58;	author mickey;	state Exp;
branches;
next	1.77;

1.77
date	2002.09.09.18.33.42;	author mickey;	state Exp;
branches;
next	1.76;

1.76
date	2002.08.03.18.57.04;	author mickey;	state Exp;
branches;
next	1.75;

1.75
date	2002.07.25.22.32.33;	author mickey;	state Exp;
branches;
next	1.74;

1.74
date	2002.07.25.04.45.31;	author mickey;	state Exp;
branches;
next	1.73;

1.73
date	2002.07.20.19.24.55;	author art;	state Exp;
branches;
next	1.72;

1.72
date	2002.05.14.00.25.02;	author mickey;	state Exp;
branches;
next	1.71;

1.71
date	2002.05.13.19.11.15;	author mickey;	state Exp;
branches;
next	1.70;

1.70
date	2002.05.08.03.16.08;	author mickey;	state Exp;
branches;
next	1.69;

1.69
date	2002.05.08.03.06.45;	author mickey;	state Exp;
branches;
next	1.68;

1.68
date	2002.04.22.00.19.59;	author mickey;	state Exp;
branches;
next	1.67;

1.67
date	2002.04.21.22.30.46;	author mickey;	state Exp;
branches;
next	1.66;

1.66
date	2002.03.26.05.24.02;	author mickey;	state Exp;
branches;
next	1.65;

1.65
date	2002.03.25.20.46.49;	author deraadt;	state Exp;
branches;
next	1.64;

1.64
date	2002.03.23.13.28.34;	author espie;	state Exp;
branches;
next	1.63;

1.63
date	2002.03.19.19.03.20;	author mickey;	state Exp;
branches;
next	1.62;

1.62
date	2002.03.15.21.44.18;	author mickey;	state Exp;
branches;
next	1.61;

1.61
date	2002.03.14.01.26.31;	author millert;	state Exp;
branches;
next	1.60;

1.60
date	2002.02.20.19.33.01;	author mickey;	state Exp;
branches;
next	1.59;

1.59
date	2002.02.17.22.59.52;	author maja;	state Exp;
branches;
next	1.58;

1.58
date	2002.02.12.06.42.26;	author mickey;	state Exp;
branches;
next	1.57;

1.57
date	2002.02.12.05.23.27;	author mickey;	state Exp;
branches;
next	1.56;

1.56
date	2002.02.11.19.42.11;	author mickey;	state Exp;
branches;
next	1.55;

1.55
date	2002.02.07.05.48.54;	author mickey;	state Exp;
branches;
next	1.54;

1.54
date	2002.02.06.19.39.20;	author mickey;	state Exp;
branches;
next	1.53;

1.53
date	2002.02.03.03.25.46;	author mickey;	state Exp;
branches;
next	1.52;

1.52
date	2002.02.02.21.10.56;	author mickey;	state Exp;
branches;
next	1.51;

1.51
date	2002.02.02.21.06.46;	author mickey;	state Exp;
branches;
next	1.50;

1.50
date	2002.01.23.17.51.52;	author art;	state Exp;
branches;
next	1.49;

1.49
date	2002.01.23.17.35.56;	author art;	state Exp;
branches;
next	1.48;

1.48
date	2002.01.16.20.50.16;	author miod;	state Exp;
branches;
next	1.47;

1.47
date	2001.12.02.02.55.42;	author mickey;	state Exp;
branches
	1.47.2.1;
next	1.46;

1.46
date	2001.11.28.16.13.28;	author art;	state Exp;
branches;
next	1.45;

1.45
date	2001.11.28.13.47.38;	author art;	state Exp;
branches;
next	1.44;

1.44
date	2001.11.24.17.53.41;	author miod;	state Exp;
branches;
next	1.43;

1.43
date	2001.11.09.15.25.55;	author art;	state Exp;
branches;
next	1.42;

1.42
date	2001.11.07.01.18.00;	author art;	state Exp;
branches;
next	1.41;

1.41
date	2001.11.06.19.53.14;	author miod;	state Exp;
branches;
next	1.40;

1.40
date	2001.09.19.20.50.56;	author mickey;	state Exp;
branches;
next	1.39;

1.39
date	2001.09.12.00.23.33;	author art;	state Exp;
branches;
next	1.38;

1.38
date	2001.08.23.14.01.03;	author art;	state Exp;
branches;
next	1.37;

1.37
date	2001.08.23.12.02.04;	author art;	state Exp;
branches;
next	1.36;

1.36
date	2001.07.25.13.25.31;	author art;	state Exp;
branches;
next	1.35;

1.35
date	2001.07.05.10.12.08;	author art;	state Exp;
branches;
next	1.34;

1.34
date	2001.05.17.18.41.48;	author provos;	state Exp;
branches;
next	1.33;

1.33
date	2001.05.05.22.33.40;	author art;	state Exp;
branches;
next	1.32;

1.32
date	2001.05.05.20.56.36;	author art;	state Exp;
branches;
next	1.31;

1.31
date	2001.03.29.00.47.53;	author mickey;	state Exp;
branches;
next	1.30;

1.30
date	2001.03.22.23.40.55;	author mickey;	state Exp;
branches;
next	1.29;

1.29
date	2000.08.15.20.21.49;	author mickey;	state Exp;
branches;
next	1.28;

1.28
date	2000.08.15.20.12.14;	author mickey;	state Exp;
branches;
next	1.27;

1.27
date	2000.08.08.21.46.05;	author mickey;	state Exp;
branches;
next	1.26;

1.26
date	2000.07.02.03.59.51;	author mickey;	state Exp;
branches;
next	1.25;

1.25
date	2000.03.23.20.25.41;	author mickey;	state Exp;
branches;
next	1.24;

1.24
date	2000.03.23.09.59.54;	author art;	state Exp;
branches;
next	1.23;

1.23
date	2000.03.16.22.11.03;	author art;	state Exp;
branches;
next	1.22;

1.22
date	2000.02.22.20.08.15;	author mickey;	state Exp;
branches;
next	1.21;

1.21
date	2000.02.09.05.04.22;	author mickey;	state Exp;
branches
	1.21.2.1;
next	1.20;

1.20
date	2000.01.25.22.11.39;	author mickey;	state Exp;
branches;
next	1.19;

1.19
date	2000.01.17.20.18.16;	author mickey;	state Exp;
branches;
next	1.18;

1.18
date	2000.01.11.20.27.56;	author mickey;	state Exp;
branches;
next	1.17;

1.17
date	99.12.31.09.07.13;	author mickey;	state Exp;
branches;
next	1.16;

1.16
date	99.12.17.06.24.38;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	99.11.25.18.46.07;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	99.09.20.21.40.14;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	99.09.03.18.00.46;	author art;	state Exp;
branches;
next	1.12;

1.12
date	99.08.14.03.19.42;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	99.07.21.07.37.20;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	99.07.12.18.16.46;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	99.06.12.18.13.18;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	99.05.23.19.11.19;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	99.05.21.17.56.05;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	99.05.21.17.46.42;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	99.04.20.20.55.38;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	99.02.17.03.51.43;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	99.01.04.13.48.16;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	99.01.03.17.55.13;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	98.12.30.02.13.52;	author mickey;	state Exp;
branches;
next	;

1.21.2.1
date	2000.03.02.07.04.27;	author niklas;	state Exp;
branches;
next	1.21.2.2;

1.21.2.2
date	2000.03.24.09.07.29;	author niklas;	state Exp;
branches;
next	1.21.2.3;

1.21.2.3
date	2001.04.18.16.06.13;	author niklas;	state Exp;
branches;
next	1.21.2.4;

1.21.2.4
date	2001.07.04.10.16.03;	author niklas;	state Exp;
branches;
next	1.21.2.5;

1.21.2.5
date	2001.10.31.02.52.47;	author nate;	state Exp;
branches;
next	1.21.2.6;

1.21.2.6
date	2001.11.13.21.00.51;	author niklas;	state Exp;
branches;
next	1.21.2.7;

1.21.2.7
date	2001.12.05.00.39.10;	author niklas;	state Exp;
branches;
next	1.21.2.8;

1.21.2.8
date	2002.03.06.00.57.22;	author niklas;	state Exp;
branches;
next	1.21.2.9;

1.21.2.9
date	2002.03.28.10.19.25;	author niklas;	state Exp;
branches;
next	1.21.2.10;

1.21.2.10
date	2003.03.27.23.26.53;	author niklas;	state Exp;
branches;
next	1.21.2.11;

1.21.2.11
date	2003.05.13.19.41.03;	author ho;	state Exp;
branches;
next	1.21.2.12;

1.21.2.12
date	2003.06.07.11.11.36;	author ho;	state Exp;
branches;
next	1.21.2.13;

1.21.2.13
date	2004.02.19.10.48.40;	author niklas;	state Exp;
branches;
next	1.21.2.14;

1.21.2.14
date	2004.06.05.23.10.48;	author niklas;	state Exp;
branches;
next	;

1.47.2.1
date	2002.01.31.22.55.09;	author niklas;	state Exp;
branches;
next	1.47.2.2;

1.47.2.2
date	2002.06.11.03.35.37;	author art;	state Exp;
branches;
next	1.47.2.3;

1.47.2.3
date	2002.10.29.00.28.02;	author art;	state Exp;
branches;
next	1.47.2.4;

1.47.2.4
date	2003.05.19.21.49.41;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.247
log
@Apply consistency to forever loops with continue and NOTREACHED

Same thought from kettenis@@, ok krw@@ phessler@@ millert@@
@
text
@/*	$OpenBSD: machdep.c,v 1.246 2016/09/15 02:00:17 dlg Exp $	*/

/*
 * Copyright (c) 1999-2003 Michael Shalayeff
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR OR HIS RELATIVES BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/signalvar.h>
#include <sys/kernel.h>
#include <sys/proc.h>
#include <sys/buf.h>
#include <sys/reboot.h>
#include <sys/device.h>
#include <sys/conf.h>
#include <sys/file.h>
#include <sys/timeout.h>
#include <sys/malloc.h>
#include <sys/pool.h>
#include <sys/msgbuf.h>
#include <sys/ioctl.h>
#include <sys/tty.h>
#include <sys/user.h>
#include <sys/exec.h>
#include <sys/sysctl.h>
#include <sys/core.h>
#include <sys/kcore.h>
#include <sys/extent.h>

#include <sys/mount.h>
#include <sys/syscallargs.h>

#include <net/if.h>
#include <uvm/uvm.h>

#include <dev/cons.h>

#include <machine/pdc.h>
#include <machine/iomod.h>
#include <machine/psl.h>
#include <machine/reg.h>
#include <machine/cpufunc.h>
#include <machine/autoconf.h>
#include <machine/kcore.h>
#include <machine/fpu.h>

#ifdef DDB
#include <machine/db_machdep.h>
#include <ddb/db_access.h>
#include <ddb/db_sym.h>
#include <ddb/db_extern.h>
#endif

#include <hppa/dev/cpudevs.h>

/*
 * Different kinds of flags used throughout the kernel.
 */
int cold = 1;			/* unset when engine is up to go */
extern int msgbufmapped;	/* set when safe to use msgbuf */

/*
 * cache configuration, for most machines is the same
 * numbers, so it makes sense to do defines w/ numbers depending
 * on configured cpu types in the kernel
 */
int icache_stride, icache_line_mask;
int dcache_stride, dcache_line_mask;

/*
 * things to not kill
 */
volatile u_int8_t *machine_ledaddr;
int machine_ledword, machine_leds;
struct cpu_info cpu_info[HPPA_MAXCPUS];

/*
 * CPU params (should be the same for all cpus in the system)
 */
struct pdc_cache pdc_cache PDC_ALIGNMENT;
struct pdc_btlb pdc_btlb PDC_ALIGNMENT;
struct pdc_model pdc_model PDC_ALIGNMENT;

	/* w/ a little deviation should be the same for all installed cpus */
u_int	cpu_ticksnum, cpu_ticksdenom;

	/* exported info */
char	machine[] = MACHINE;
char	cpu_model[128];
enum hppa_cpu_type cpu_type;
const char *cpu_typename;
int	cpu_hvers;
u_int	fpu_version;

int	led_blink;

/*
 * exported methods for cpus
 */
int (*cpu_desidhash)(void);
int (*cpu_hpt_init)(vaddr_t hpt, vsize_t hptsize);
int (*cpu_ibtlb_ins)(int i, pa_space_t sp, vaddr_t va, paddr_t pa,
	    vsize_t sz, u_int prot);
int (*cpu_dbtlb_ins)(int i, pa_space_t sp, vaddr_t va, paddr_t pa,
	    vsize_t sz, u_int prot);

dev_t	bootdev;
int	physmem, resvmem, resvphysmem, esym;

#ifdef MULTIPROCESSOR
__cpu_simple_lock_t atomic_lock = __SIMPLELOCK_UNLOCKED;
#endif

/*
 * Things for MI glue to stick on.
 */
struct user *proc0paddr;
long mem_ex_storage[EXTENT_FIXED_STORAGE_SIZE(64) / sizeof(long)];
struct extent *hppa_ex;
struct pool hppa_fppl;
struct hppa_fpstate proc0fpstate;
struct consdev *cn_tab;

struct vm_map *exec_map = NULL;
struct vm_map *phys_map = NULL;

void delay_init(void);
static __inline void fall(int, int, int, int, int);
void dumpsys(void);
void hpmc_dump(void);
void cpuid(void);
void blink_led_timeout(void *);

/*
 * safepri is a safe priority for sleep to set for a spin-wait
 * during autoconfiguration or after a panic.
 */
int   safepri = 0;

/*
 * wide used hardware params
 */
struct pdc_hwtlb pdc_hwtlb PDC_ALIGNMENT;
struct pdc_coherence pdc_coherence PDC_ALIGNMENT;
struct pdc_spidb pdc_spidbits PDC_ALIGNMENT;
struct pdc_model pdc_model PDC_ALIGNMENT;

#ifdef DEBUG
int sigdebug = 0;
pid_t sigpid = 0;
#define SDB_FOLLOW	0x01
#endif

struct uvm_constraint_range  dma_constraint = { 0x0, (paddr_t)-1 };
struct uvm_constraint_range *uvm_md_constraints[] = { NULL };

/*
 * Whatever CPU types we support
 */
extern const u_int itlb_x[], itlbna_x[], dtlb_x[], dtlbna_x[], tlbd_x[];
extern const u_int itlb_s[], itlbna_s[], dtlb_s[], dtlbna_s[], tlbd_s[];
extern const u_int itlb_t[], itlbna_t[], dtlb_t[], dtlbna_t[], tlbd_t[];
extern const u_int itlb_l[], itlbna_l[], dtlb_l[], dtlbna_l[], tlbd_l[];
extern const u_int itlb_u[], itlbna_u[], dtlb_u[], dtlbna_u[], tlbd_u[];
int iibtlb_s(int i, pa_space_t sp, vaddr_t va, paddr_t pa,
    vsize_t sz, u_int prot);
int idbtlb_s(int i, pa_space_t sp, vaddr_t va, paddr_t pa,
    vsize_t sz, u_int prot);
int ibtlb_t(int i, pa_space_t sp, vaddr_t va, paddr_t pa,
    vsize_t sz, u_int prot);
int ibtlb_l(int i, pa_space_t sp, vaddr_t va, paddr_t pa,
    vsize_t sz, u_int prot);
int ibtlb_u(int i, pa_space_t sp, vaddr_t va, paddr_t pa,
    vsize_t sz, u_int prot);
int ibtlb_g(int i, pa_space_t sp, vaddr_t va, paddr_t pa,
    vsize_t sz, u_int prot);
int pbtlb_g(int i);
int pbtlb_u(int i);
int hpti_l(vaddr_t, vsize_t);
int hpti_u(vaddr_t, vsize_t);
int hpti_g(vaddr_t, vsize_t);
int desidhash_s(void);
int desidhash_t(void);
int desidhash_l(void);
int desidhash_u(void);
const struct hppa_cpu_typed {
	char name[8];
	enum hppa_cpu_type type;
	int  cpuid;
	int  features;
	int  patch;
	int  (*desidhash)(void);
	int  (*dbtlbins)(int i, pa_space_t sp, vaddr_t va, paddr_t pa,
	     vsize_t sz, u_int prot);
	int  (*ibtlbins)(int i, pa_space_t sp, vaddr_t va, paddr_t pa,
	     vsize_t sz, u_int prot);
	int  (*btlbprg)(int i);
	int  (*hptinit)(vaddr_t hpt, vsize_t hptsize);
} cpu_types[] = {
#ifdef HP7000_CPU
	{ "PCXS",  hpcxs,  0, 0, 3, desidhash_s, ibtlb_g, NULL, pbtlb_g},
#endif
#ifdef HP7100_CPU
	{ "PCXT",  hpcxt, 0, HPPA_FTRS_BTLBU,
	  2, desidhash_t, ibtlb_g, NULL, pbtlb_g},
#endif
#ifdef HP7200_CPU
	{ "PCXT'", hpcxta,HPPA_CPU_PCXT2, HPPA_FTRS_BTLBU,
	  2, desidhash_t, ibtlb_g, NULL, pbtlb_g},
#endif
#ifdef HP7100LC_CPU
	{ "PCXL",  hpcxl, HPPA_CPU_PCXL, HPPA_FTRS_BTLBU|HPPA_FTRS_HVT,
	  0, desidhash_l, ibtlb_g, NULL, pbtlb_g, hpti_g},
#endif
#ifdef HP7300LC_CPU
	{ "PCXL2", hpcxl2,HPPA_CPU_PCXL2, HPPA_FTRS_BTLBU|HPPA_FTRS_HVT,
	  0, desidhash_l, ibtlb_g, NULL, pbtlb_g, hpti_g},
#endif
#ifdef HP8000_CPU
	{ "PCXU",  hpcxu, HPPA_CPU_PCXU, HPPA_FTRS_W32B,
	  4, desidhash_u, ibtlb_u, NULL, pbtlb_u },
#endif
#ifdef HP8200_CPU
	{ "PCXU+", hpcxu2,HPPA_CPU_PCXUP, HPPA_FTRS_W32B,
	  4, desidhash_u, ibtlb_u, NULL, pbtlb_u },
#endif
#ifdef HP8500_CPU
	{ "PCXW",  hpcxw, HPPA_CPU_PCXW, HPPA_FTRS_W32B,
	  4, desidhash_u, ibtlb_u, NULL, pbtlb_u },
#endif
#ifdef HP8700_CPU
	{ "PCXW2",  hpcxw, HPPA_CPU_PCXW2, HPPA_FTRS_W32B,
	  4, desidhash_u, ibtlb_u, NULL, pbtlb_u },
#endif
	{ "", 0 }
};

int	hppa_cpuspeed(int *mhz);

int
hppa_cpuspeed(int *mhz)
{
	*mhz = PAGE0->mem_10msec / 10000;

	return (0);
}

void
hppa_init(paddr_t start)
{
	extern int kernel_text;
	struct cpu_info *ci;
	int error;
	paddr_t	avail_end;

	pdc_init();	/* init PDC iface, so we can call em easy */

	delay_init();	/* calculate cpu clock ratio */

	/* cache parameters */
	if ((error = pdc_call((iodcio_t)pdc, 0, PDC_CACHE, PDC_CACHE_DFLT,
	    &pdc_cache)) < 0) {
#ifdef DEBUG
		printf("WARNING: PDC_CACHE error %d\n", error);
#endif
	}

	dcache_line_mask = pdc_cache.dc_conf.cc_line * 16 - 1;
	dcache_stride = pdc_cache.dc_stride;
	icache_line_mask = pdc_cache.ic_conf.cc_line * 16 - 1;
	icache_stride = pdc_cache.ic_stride;

	/* cache coherence params (pbably available for 8k only) */
	error = pdc_call((iodcio_t)pdc, 0, PDC_CACHE, PDC_CACHE_SETCS,
	    &pdc_coherence, 1, 1, 1, 1);
#ifdef DEBUG
	printf ("PDC_CACHE_SETCS: %d, %d, %d, %d (%d)\n",
	    pdc_coherence.ia_cst, pdc_coherence.da_cst,
	    pdc_coherence.ita_cst, pdc_coherence.dta_cst, error);
#endif
	error = pdc_call((iodcio_t)pdc, 0, PDC_CACHE, PDC_CACHE_GETSPIDB,
	    &pdc_spidbits, 0, 0, 0, 0);
	printf("SPID bits: 0x%x, error = %d\n", pdc_spidbits.spidbits, error);

	/* setup hpmc handler */
	{
		/* from locore.s */
		extern uint32_t hpmc_v[], hpmc_tramp[], hpmc_tramp_end[];
		uint32_t *p;
		uint32_t cksum = 0;

		for (p = hpmc_tramp; p < hpmc_tramp_end; p++)
			cksum += *p;

		p = hpmc_v;
		if (pdc_call((iodcio_t)pdc, 0, PDC_INSTR, PDC_INSTR_DFLT, p))
			*p = 0x08000240;

		p[6] = (uint32_t)&hpmc_tramp;
		p[7] = (hpmc_tramp_end - hpmc_tramp) * sizeof(uint32_t);
		p[5] =
		    -(p[0] + p[1] + p[2] + p[3] + p[4] + p[6] + p[7] + cksum);
	}

	{
		extern u_int hppa_toc[], hppa_toc_end[];
		u_int cksum, *p;

		for (cksum = 0, p = hppa_toc; p < hppa_toc_end; p++)
			cksum += *p;

		*p = cksum;
		PAGE0->ivec_toc = (u_int)hppa_toc;
		PAGE0->ivec_toclen = (hppa_toc_end - hppa_toc + 1) * 4;
	}

	{
		extern u_int hppa_pfr[], hppa_pfr_end[];
		u_int cksum, *p;

		for (cksum = 0, p = hppa_pfr; p < hppa_pfr_end; p++)
			cksum += *p;

		*p = cksum;
		PAGE0->ivec_mempf = (u_int)hppa_pfr;
		PAGE0->ivec_mempflen = (hppa_pfr_end - hppa_pfr + 1) * 4;
	}

	ci = curcpu();
	ci->ci_cpl = IPL_NESTED;
	ci->ci_psw = PSL_Q | PSL_P | PSL_C | PSL_D;

	cpuid();
	ptlball();
	ficacheall();
	fdcacheall();

	avail_end = trunc_page(PAGE0->imm_max_mem);
	if (avail_end > SYSCALLGATE)
		avail_end = SYSCALLGATE;
	physmem = atop(avail_end);
	resvmem = atop(((vaddr_t)&kernel_text));

	/* we hope this won't fail */
	hppa_ex = extent_create("mem", 0x0, 0xffffffff, M_DEVBUF,
	    (caddr_t)mem_ex_storage, sizeof(mem_ex_storage),
	    EX_NOCOALESCE|EX_NOWAIT);
	if (extent_alloc_region(hppa_ex, 0, (vaddr_t)PAGE0->imm_max_mem,
	    EX_NOWAIT))
		panic("cannot reserve main memory");

	/* sets resvphysmem */
	pmap_bootstrap(round_page(start));

	/* space has been reserved in pmap_bootstrap() */
	initmsgbuf((caddr_t)(ptoa(physmem) - round_page(MSGBUFSIZE)),
	    round_page(MSGBUFSIZE));

	/* they say PDC_COPROC might turn fault light on */
	pdc_call((iodcio_t)pdc, 0, PDC_CHASSIS, PDC_CHASSIS_DISP,
	    PDC_OSTAT(PDC_OSTAT_RUN) | 0xCEC0);

	cpu_cpuspeed = &hppa_cpuspeed;
#ifdef DDB
	ddb_init();
#endif
	ficacheall();
	fdcacheall();

	proc0paddr->u_pcb.pcb_fpstate = &proc0fpstate;
	pool_init(&hppa_fppl, sizeof(struct hppa_fpstate), 16, IPL_NONE, 0,
	    "hppafp", NULL);
}

void
cpuid()
{
	/*
	 * Ptrs to various tlb handlers, to be filled
	 * based on cpu features.
	 * from locore.S
	 */
	extern u_int trap_ep_T_TLB_DIRTY[];
	extern u_int trap_ep_T_DTLBMISS[];
	extern u_int trap_ep_T_DTLBMISSNA[];
	extern u_int trap_ep_T_ITLBMISS[];
	extern u_int trap_ep_T_ITLBMISSNA[];

	extern u_int fpu_enable;
	extern int cpu_fpuena;
	struct pdc_cpuid pdc_cpuid PDC_ALIGNMENT;
	struct pdc_coproc pdc_coproc PDC_ALIGNMENT;
	const struct hppa_cpu_typed *p = NULL;
	u_int cpu_features;
	int error;

	/* may the scientific guessing begin */
	cpu_features = 0;
	cpu_type = 0;

	/* identify system type */
	if ((error = pdc_call((iodcio_t)pdc, 0, PDC_MODEL, PDC_MODEL_INFO,
	    &pdc_model)) < 0) {
#ifdef DEBUG
		printf("WARNING: PDC_MODEL error %d\n", error);
#endif
		pdc_model.hvers = 0;
	}

	bzero(&pdc_cpuid, sizeof(pdc_cpuid));
	if (pdc_call((iodcio_t)pdc, 0, PDC_MODEL, PDC_MODEL_CPUID,
	    &pdc_cpuid, 0, 0, 0, 0) >= 0) {

		/* patch for old 8200 */
		if (pdc_cpuid.version == HPPA_CPU_PCXU &&
		    pdc_cpuid.revision > 0x0d)
			pdc_cpuid.version = HPPA_CPU_PCXUP;

		cpu_type = pdc_cpuid.version;
	}

	/* locate coprocessors and SFUs */
	bzero(&pdc_coproc, sizeof(pdc_coproc));
	if ((error = pdc_call((iodcio_t)pdc, 0, PDC_COPROC, PDC_COPROC_DFLT,
	    &pdc_coproc, 0, 0, 0, 0, 0)) < 0) {
		/*
		 * Some 1.1 systems fail the PDC_COPROC call with error == -3,
		 * when booting from disk (but not when netbooting).
		 * Until the cause of this misbehaviour is found, assume the
		 * usual 1.1 FPU settings, so that userland gets a chance to
		 * run.
		 */
		if ((pdc_model.hvers >> 4) != 0 && pdc_model.arch_rev == 4) {
			printf("WARNING: PDC_COPROC error %d,"
			    " assuming 1.1 FPU\n", error);
			fpu_enable = 0xc0;
			cpu_fpuena = 1;
		} else {
			printf("WARNING: PDC_COPROC error %d\n", error);
			cpu_fpuena = 0;
		}
	} else {
		printf("pdc_coproc: 0x%x, 0x%x; model %x rev %x\n",
		    pdc_coproc.ccr_enable, pdc_coproc.ccr_present,
		    pdc_coproc.fpu_model, pdc_coproc.fpu_revision);
		fpu_enable = pdc_coproc.ccr_enable & CCR_MASK;
		cpu_fpuena = 1;

		/* a kludge to detect PCXW */
		if (pdc_coproc.fpu_model == HPPA_FPU_PCXW)
			cpu_type = HPPA_CPU_PCXW;
	}

	/* BTLB params */
	if (cpu_type < HPPA_CPU_PCXU &&
	    (error = pdc_call((iodcio_t)pdc, 0, PDC_BLOCK_TLB,
	     PDC_BTLB_DEFAULT, &pdc_btlb)) < 0) {
#ifdef DEBUG
		printf("WARNING: PDC_BTLB error %d\n", error);
#endif
	} else {
#ifdef BTLBDEBUG
		printf("btlb info: minsz=%d, maxsz=%d\n",
		    pdc_btlb.min_size, pdc_btlb.max_size);
		printf("btlb fixed: i=%d, d=%d, c=%d\n",
		    pdc_btlb.finfo.num_i,
		    pdc_btlb.finfo.num_d,
		    pdc_btlb.finfo.num_c);
		printf("btlb varbl: i=%d, d=%d, c=%d\n",
		    pdc_btlb.vinfo.num_i,
		    pdc_btlb.vinfo.num_d,
		    pdc_btlb.vinfo.num_c);
#endif /* BTLBDEBUG */
		/* purge TLBs and caches */
		if (pdc_call((iodcio_t)pdc, 0, PDC_BLOCK_TLB,
		    PDC_BTLB_PURGE_ALL) < 0)
			printf("WARNING: BTLB purge failed\n");

		if (pdc_btlb.finfo.num_c)
			cpu_features |= HPPA_FTRS_BTLBU;
	}

	if (!pdc_call((iodcio_t)pdc, 0, PDC_TLB, PDC_TLB_INFO, &pdc_hwtlb) &&
	    pdc_hwtlb.min_size && pdc_hwtlb.max_size) {
		cpu_features |= HPPA_FTRS_HVT;
		if (pmap_hptsize > pdc_hwtlb.max_size)
			pmap_hptsize = pdc_hwtlb.max_size;
		else if (pmap_hptsize && pmap_hptsize < pdc_hwtlb.min_size)
			pmap_hptsize = pdc_hwtlb.min_size;
	} else {
#ifdef DEBUG
		printf("WARNING: no HPT support, fine!\n");
#endif
		pmap_hptsize = 0;
	}

	if (cpu_type)
		for (p = cpu_types; p->name[0] && p->cpuid != cpu_type; p++);
	else
		for (p = cpu_types;
		    p->name[0] && p->features != cpu_features; p++);

	if (!p->name[0]) {
		printf("WARNING: UNKNOWN CPU TYPE; GOOD LUCK "
		    "(type 0x%x, features 0x%x)\n", cpu_type, cpu_features);
		p = cpu_types;
	} else if ((p->type == hpcxl || p->type == hpcxl2) && !fpu_enable) {
		/* we know PCXL and PCXL2 do not exist w/o FPU */
		fpu_enable = 0xc0;
		cpu_fpuena = 1;
	}

	/*
	 * TODO: HPT on 7200 is not currently supported
	 */
	if (pmap_hptsize && p->type != hpcxl && p->type != hpcxl2)
		pmap_hptsize = 0;

	cpu_type = p->type;
	cpu_typename = p->name;
	cpu_ibtlb_ins = p->ibtlbins;
	cpu_dbtlb_ins = p->dbtlbins;
	cpu_hpt_init = p->hptinit;
	cpu_desidhash = p->desidhash;

	/* patch tlb handler branches */
	if (p->patch) {
		trap_ep_T_TLB_DIRTY [0] = trap_ep_T_TLB_DIRTY [p->patch];
		trap_ep_T_DTLBMISS  [0] = trap_ep_T_DTLBMISS  [p->patch];
		trap_ep_T_DTLBMISSNA[0] = trap_ep_T_DTLBMISSNA[p->patch];
		trap_ep_T_ITLBMISS  [0] = trap_ep_T_ITLBMISS  [p->patch];
		trap_ep_T_ITLBMISSNA[0] = trap_ep_T_ITLBMISSNA[p->patch];
	}

	/* force strong ordering for now */
	if (p->features & HPPA_FTRS_W32B) {
		curcpu()->ci_psw |= PSL_O;
	}

	{
		const char *p, *q;
		char buf[32];
		int lev;

		lev = 0xa + (*cpu_desidhash)();
		cpu_hvers = pdc_model.hvers >> 4;
		if (!cpu_hvers) {
			p = "(UNKNOWN)";
			q = lev == 0xa? "1.0" : "1.1";
		} else {
			p = hppa_mod_info(HPPA_TYPE_BOARD, cpu_hvers);
			if (!p) {
				snprintf(buf, sizeof buf, "(UNKNOWN 0x%x)",
				    cpu_hvers);
				p = buf;
			}

			switch (pdc_model.arch_rev) {
			default:
			case 0:
				q = "1.0";
				break;
			case 4:
				q = "1.1";
				/* this one is just a 100MHz pcxl */
				if (lev == 0x10)
					lev = 0xc;
				/* this one is a pcxl2 */
				if (lev == 0x16)
					lev = 0xe;
				break;
			case 8:
				q = "2.0";
				break;
			}
		}

		snprintf(cpu_model, sizeof cpu_model,
		    "HP 9000/%s PA-RISC %s%x", p, q, lev);
	}
#ifdef DEBUG
	printf("cpu: %s\n", cpu_model);
#endif
}

void
cpu_startup(void)
{
	vaddr_t minaddr, maxaddr;

	/*
	 * i won't understand a friend of mine,
	 * who sat in a room full of artificial ice,
	 * fogging the air w/ humid cries --
	 *	WELCOME TO SUMMER!
	 */
	printf(version);

	printf("%s\n", cpu_model);
	printf("real mem = %lu (%luMB)\n", ptoa(physmem),
	    ptoa(physmem) / 1024 / 1024);
	printf("rsvd mem = %lu (%luKB)\n", ptoa(resvmem), ptoa(resvmem) / 1024);

	/*
	 * Allocate a submap for exec arguments.  This map effectively
	 * limits the number of processes exec'ing at any time.
	 */
	minaddr = vm_map_min(kernel_map);
	exec_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
	    16*NCARGS, VM_MAP_PAGEABLE, FALSE, NULL);

	/*
	 * Allocate a submap for physio
	 */
	phys_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
	    VM_PHYS_SIZE, 0, FALSE, NULL);

	printf("avail mem = %lu (%luMB)\n", ptoa(uvmexp.free),
	    ptoa(uvmexp.free) / 1024 / 1024);

	/*
	 * Set up buffers, so they can be used to read disk labels.
	 */
	bufinit();

	/*
	 * Configure the system.
	 */
	if (boothowto & RB_CONFIG) {
#ifdef BOOT_CONFIG
		user_config();
#else
		printf("kernel does not support -c; continuing..\n");
#endif
	}
}

/*
 * compute cpu clock ratio such as:
 *	cpu_ticksnum / cpu_ticksdenom = t + delta
 *	delta -> 0
 */
void
delay_init(void)
{
	u_int num, denom, delta, mdelta;

	mdelta = UINT_MAX;
	for (denom = 1; denom < 1000; denom++) {
		num = (PAGE0->mem_10msec * denom) / 10000;
		delta = num * 10000 / denom - PAGE0->mem_10msec;
		if (!delta) {
			cpu_ticksdenom = denom;
			cpu_ticksnum = num;
			break;
		} else if (delta < mdelta) {
			cpu_ticksdenom = denom;
			cpu_ticksnum = num;
			mdelta = delta;
		}
	}
}

void
delay(u_int us)
{
	u_int start, end, n;

	mfctl(CR_ITMR, start);
	while (us) {
		n = min(1000, us);
		end = start + n * cpu_ticksnum / cpu_ticksdenom;

		/* N.B. Interval Timer may wrap around */
		if (end < start)
			do
				mfctl(CR_ITMR, start);
			while (start > end);

		do
			mfctl(CR_ITMR, start);
		while (start < end);

		us -= n;
	}
}

static __inline void
fall(int c_base, int c_count, int c_loop, int c_stride, int data)
{
	int loop;

	for (; c_count--; c_base += c_stride)
		for (loop = c_loop; loop--; )
			if (data)
				fdce(0, c_base);
			else
				fice(0, c_base);
}

void
ficacheall(void)
{
	/*
	 * Flush the instruction, then data cache.
	 */
	fall(pdc_cache.ic_base, pdc_cache.ic_count, pdc_cache.ic_loop,
	    pdc_cache.ic_stride, 0);
	sync_caches();
}

void
fdcacheall(void)
{
	fall(pdc_cache.dc_base, pdc_cache.dc_count, pdc_cache.dc_loop,
	    pdc_cache.dc_stride, 1);
	sync_caches();
}

void
ptlball(void)
{
	pa_space_t sp;
	int i, j, k;

	/* instruction TLB */
	sp = pdc_cache.it_sp_base;
	for (i = 0; i < pdc_cache.it_sp_count; i++) {
		vaddr_t off = pdc_cache.it_off_base;
		for (j = 0; j < pdc_cache.it_off_count; j++) {
			for (k = 0; k < pdc_cache.it_loop; k++)
				pitlbe(sp, off);
			off += pdc_cache.it_off_stride;
		}
		sp += pdc_cache.it_sp_stride;
	}

	/* data TLB */
	sp = pdc_cache.dt_sp_base;
	for (i = 0; i < pdc_cache.dt_sp_count; i++) {
		vaddr_t off = pdc_cache.dt_off_base;
		for (j = 0; j < pdc_cache.dt_off_count; j++) {
			for (k = 0; k < pdc_cache.dt_loop; k++)
				pdtlbe(sp, off);
			off += pdc_cache.dt_off_stride;
		}
		sp += pdc_cache.dt_sp_stride;
	}
}

int
hpti_g(vaddr_t hpt, vsize_t hptsize)
{
	return pdc_call((iodcio_t)pdc, 0, PDC_TLB, PDC_TLB_CONFIG,
	    &pdc_hwtlb, hpt, hptsize, PDC_TLB_CURRPDE);
}

int
pbtlb_g(int i)
{
	return -1;
}

int
ibtlb_g(int i, pa_space_t sp, vaddr_t va, paddr_t pa, vsize_t sz, u_int prot)
{
	int error;

	if ((error = pdc_call((iodcio_t)pdc, 0, PDC_BLOCK_TLB, PDC_BTLB_INSERT,
	    sp, va, pa, sz, prot, i)) < 0) {
#ifdef BTLBDEBUG
		printf("WARNING: BTLB insert failed (%d)\n", error);
#endif
	}
	return error;
}

int
btlb_insert(pa_space_t space, vaddr_t va, paddr_t pa, vsize_t *lenp, u_int prot)
{
	static u_int32_t mask;
	vsize_t len;
	int error, i, btlb_max;

	if (!pdc_btlb.min_size && !pdc_btlb.max_size)
		return -(ENXIO);

	/*
	 * On PCXS processors with split BTLB, we should theoretically
	 * insert in the IBTLB (if executable mapping requested), and
	 * into the DBTLB. The PDC documentation is very clear that
	 * slot numbers are, in order, IBTLB, then DBTLB, then combined
	 * BTLB.
	 *
	 * However it also states that ``successful completion may not mean
	 * that the entire address range specified in the call has been
	 * mapped in the block TLB. For both fixed range slots and variable
	 * range slots, complete coverage of the address range specified
	 * is not guaranteed. Only a portion of the address range specified
	 * may get mapped as a result''.
	 *
	 * On an HP 9000/720 with PDC ROM v1.2, it turns out that IBTLB
	 * entries are inserted as expected, but no DBTLB gets inserted
	 * at all, despite PDC returning success.
	 *
	 * So play it dumb, and do not attempt to insert DBTLB entries at
	 * all on split BTLB systems. Callers are supposed to be able to
	 * cope with this.
	 */

	if (pdc_btlb.finfo.num_c == 0) {
		if ((prot & TLB_EXECUTE) == 0)
			return -(EINVAL);

		btlb_max = pdc_btlb.finfo.num_i;
	} else {
		btlb_max = pdc_btlb.finfo.num_c;
	}

	/* align size */
	for (len = pdc_btlb.min_size << PGSHIFT; len < *lenp; len <<= 1);
	len >>= PGSHIFT;
	i = ffs(~mask) - 1;
	if (len > pdc_btlb.max_size || i < 0 || i >= btlb_max) {
#ifdef BTLBDEBUG
		printf("btln_insert: too big (%u < %u < %u)\n",
		    pdc_btlb.min_size, len, pdc_btlb.max_size);
#endif
		return -(ENOMEM);
	}

	mask |= 1 << i;
	pa >>= PGSHIFT;
	va >>= PGSHIFT;
	/* check address alignment */
	if (pa & (len - 1)) {
#ifdef BTLBDEBUG
		printf("WARNING: BTLB address misaligned pa=0x%x, len=0x%x\n",
		    pa, len);
#endif
		return -(ERANGE);
	}

	/* ensure IO space is uncached */
	if ((pa & (HPPA_IOBEGIN >> PGSHIFT)) == (HPPA_IOBEGIN >> PGSHIFT))
		prot |= TLB_UNCACHABLE;

#ifdef BTLBDEBUG
	printf("btlb_insert(%d): %x:%x=%x[%x,%x]\n",
	    i, space, va, pa, len, prot);
#endif
	if ((error = (*cpu_dbtlb_ins)(i, space, va, pa, len, prot)) < 0)
		return -(EINVAL);
	*lenp = len << PGSHIFT;

	return i;
}

int waittime = -1;

__dead void
boot(int howto)
{
	/*
	 * On older systems without software power control, prevent mi code
	 * from spinning disks off, in case the operator changes his mind
	 * and prefers to reboot - the firmware will not send a spin up
	 * command to the disks.
	 */
	if (cold_hook == NULL)
		howto &= ~RB_POWERDOWN;

	if (cold) {
		if ((howto & RB_USERREQ) == 0)
			howto |= RB_HALT;
		goto haltsys;
	}

	boothowto = howto | (boothowto & RB_HALT);

	if ((howto & RB_NOSYNC) == 0) {
		waittime = 0;
		vfs_shutdown();

		if ((howto & RB_TIMEBAD) == 0) {
			resettodr();
		} else {
			printf("WARNING: not updating battery clock\n");
		}
	}
	if_downall();

	uvm_shutdown();
	splhigh();
	cold = 1;

	if ((howto & RB_DUMP) != 0)
		dumpsys();

haltsys:
	config_suspend_all(DVACT_POWERDOWN);

#ifdef MULTIPROCESSOR
	hppa_ipi_broadcast(HPPA_IPI_HALT);
#endif

	/* in case we came on powerfail interrupt */
	if (cold_hook)
		(*cold_hook)(HPPA_COLD_COLD);

	if ((howto & RB_HALT) != 0) {
		if ((howto & RB_POWERDOWN) != 0) {
			printf("Powering off...");
			DELAY(2000000);
			(*cold_hook)(HPPA_COLD_OFF);
			DELAY(1000000);
		}

		printf("System halted!\n");
		DELAY(2000000);
		__asm volatile("stwas %0, 0(%1)"
		    :: "r" (CMD_STOP), "r" (HPPA_LBCAST + iomod_command));
	} else {
		printf("rebooting...");
		DELAY(2000000);

		/* ask firmware to reset */
                pdc_call((iodcio_t)pdc, 0, PDC_BROADCAST_RESET, PDC_DO_RESET);

		/* forcably reset module if that fails */
		__asm volatile(".export hppa_reset, entry\n\t"
		    ".label hppa_reset");
		__asm volatile("stwas %0, 0(%1)"
		    :: "r" (CMD_RESET), "r" (HPPA_LBCAST + iomod_command));
	}

	for (;;)
		continue;
	/* NOTREACHED */
}

u_long	dumpmag = 0x8fca0101;	/* magic number */
int	dumpsize = 0;		/* pages */
long	dumplo = 0;		/* blocks */

/*
 * cpu_dumpsize: calculate size of machine-dependent kernel core dump headers.
 */
int
cpu_dumpsize(void)
{
	int size;

	size = ALIGN(sizeof(kcore_seg_t)) + ALIGN(sizeof(cpu_kcore_hdr_t));
	if (roundup(size, dbtob(1)) != dbtob(1))
		return -1;

	return 1;
}

/*
 * Called from HPMC handler in locore
 */
void
hpmc_dump(void)
{
	cold = 0;
	panic("HPMC");
	/* NOTREACHED */
}

int
cpu_dump(void)
{
	long buf[dbtob(1) / sizeof (long)];
	kcore_seg_t	*segp;
	cpu_kcore_hdr_t	*cpuhdrp;

	segp = (kcore_seg_t *)buf;
	cpuhdrp = (cpu_kcore_hdr_t *)&buf[ALIGN(sizeof(*segp)) / sizeof (long)];

	/*
	 * Generate a segment header.
	 */
	CORE_SETMAGIC(*segp, KCORE_MAGIC, MID_MACHINE, CORE_CPU);
	segp->c_size = dbtob(1) - ALIGN(sizeof(*segp));

	/*
	 * Add the machine-dependent header info
	 */
	/* nothing for now */

	return (bdevsw[major(dumpdev)].d_dump)
	    (dumpdev, dumplo, (caddr_t)buf, dbtob(1));
}

/*
 * Dump the kernel's image to the swap partition.
 */
#define	BYTES_PER_DUMP	NBPG

void
dumpsys(void)
{
	int psize, bytes, i, n;
	caddr_t maddr;
	daddr_t blkno;
	int (*dump)(dev_t, daddr_t, caddr_t, size_t);
	int error;

	/* Save registers
	savectx(&dumppcb); */

	if (dumpsize == 0)
		dumpconf();
	if (dumplo <= 0) {
		printf("\ndump to dev %x not possible\n", dumpdev);
		return;
	}
	printf("\ndumping to dev %x, offset %ld\n", dumpdev, dumplo);

	psize = (*bdevsw[major(dumpdev)].d_psize)(dumpdev);
	printf("dump ");
	if (psize == -1) {
		printf("area unavailable\n");
		return;
	}

	if (!(error = cpu_dump())) {

		bytes = ptoa(physmem);
		maddr = NULL;
		blkno = dumplo + cpu_dumpsize();
		dump = bdevsw[major(dumpdev)].d_dump;
		/* TODO block map the whole physical memory */
		for (i = 0; i < bytes; i += n) {

			/* Print out how many MBs we are to go. */
			n = bytes - i;
			if (n && (n % (1024*1024)) == 0)
				printf("%d ", n / (1024 * 1024));

			/* Limit size for next transfer. */

			if (n > BYTES_PER_DUMP)
				n = BYTES_PER_DUMP;

			if ((error = (*dump)(dumpdev, blkno, maddr, n)))
				break;
			maddr += n;
			blkno += btodb(n);
		}
	}

	switch (error) {
	case ENXIO:	printf("device bad\n");			break;
	case EFAULT:	printf("device not ready\n");		break;
	case EINVAL:	printf("area improper\n");		break;
	case EIO:	printf("i/o error\n");			break;
	case EINTR:	printf("aborted from console\n");	break;
	case 0:		printf("succeeded\n");			break;
	default:	printf("error %d\n", error);		break;
	}
}

/* bcopy(), error on fault */
int
kcopy(const void *from, void *to, size_t size)
{
	return spcopy(HPPA_SID_KERNEL, from, HPPA_SID_KERNEL, to, size);
}

int
copystr(const void *src, void *dst, size_t size, size_t *lenp)
{
	return spstrcpy(HPPA_SID_KERNEL, src, HPPA_SID_KERNEL, dst, size, lenp);
}

int
copyinstr(const void *src, void *dst, size_t size, size_t *lenp)
{
	return spstrcpy(curproc->p_addr->u_pcb.pcb_space, src,
	    HPPA_SID_KERNEL, dst, size, lenp);
}


int
copyoutstr(const void *src, void *dst, size_t size, size_t *lenp)
{
	return spstrcpy(HPPA_SID_KERNEL, src,
	    curproc->p_addr->u_pcb.pcb_space, dst, size, lenp);
}


int
copyin(const void *src, void *dst, size_t size)
{
	return spcopy(curproc->p_addr->u_pcb.pcb_space, src,
	    HPPA_SID_KERNEL, dst, size);
}

int
copyout(const void *src, void *dst, size_t size)
{
	return spcopy(HPPA_SID_KERNEL, src,
	    curproc->p_addr->u_pcb.pcb_space, dst, size);
}

/*
 * Set up tf_sp and tf_r3 (the frame pointer) and copy out the
 * frame marker and the old r3
 */
int
setstack(struct trapframe *tf, u_long stack, register_t old_r3)
{
	static const register_t zero = 0;
	int err;

	tf->tf_r3 = stack;
	err = copyout(&old_r3, (caddr_t)stack, sizeof(register_t));

	tf->tf_sp = stack += HPPA_FRAME_SIZE;
	return (copyout(&zero, (caddr_t)(stack + HPPA_FRAME_CRP),
	    sizeof(register_t)) || err);
}


/*
 * Set registers on exec.
 */
void
setregs(struct proc *p, struct exec_package *pack, u_long stack,
    register_t *retval)
{
	struct trapframe *tf = p->p_md.md_regs;
	struct pcb *pcb = &p->p_addr->u_pcb;

	bzero(tf, sizeof(*tf));
	tf->tf_flags = TFF_SYS|TFF_LAST;
	tf->tf_iioq_head = pack->ep_entry | HPPA_PC_PRIV_USER;
	tf->tf_iioq_tail = tf->tf_iioq_head + 4;
	tf->tf_iisq_head = tf->tf_iisq_tail = pcb->pcb_space;
	tf->tf_arg0 = p->p_p->ps_strings;

	/* setup terminal stack frame */
	setstack(tf, (stack + 0x3f) & ~0x3f, 0);

	tf->tf_cr30 = (paddr_t)pcb->pcb_fpstate;

	tf->tf_sr0 = tf->tf_sr1 = tf->tf_sr2 = tf->tf_sr3 =
	tf->tf_sr4 = tf->tf_sr5 = tf->tf_sr6 = pcb->pcb_space;
	tf->tf_pidr1 = tf->tf_pidr2 = pmap_sid2pid(tf->tf_sr0);

	/*
	 * theoretically these could be inherited,
	 * but just in case.
	 */
	tf->tf_sr7 = HPPA_SID_KERNEL;
	mfctl(CR_EIEM, tf->tf_eiem);
	tf->tf_ipsw = PSL_C | PSL_Q | PSL_P | PSL_D | PSL_I /* | PSL_L */ |
	    (curcpu()->ci_psw & PSL_O);

	/* clear the FPU */
	fpu_proc_flush(p);
	bzero(&pcb->pcb_fpstate->hfp_regs, sizeof(pcb->pcb_fpstate->hfp_regs));
	pcb->pcb_fpstate->hfp_regs.fpr_regs[0] =
	    ((u_int64_t)HPPA_FPU_INIT) << 32;
	pcb->pcb_fpstate->hfp_regs.fpr_regs[1] = 0;
	pcb->pcb_fpstate->hfp_regs.fpr_regs[2] = 0;
	pcb->pcb_fpstate->hfp_regs.fpr_regs[3] = 0;

	p->p_md.md_bpva = 0;

	retval[1] = 0;
}

/*
 * Send an interrupt to process.
 */
void
sendsig(sig_t catcher, int sig, int mask, u_long code, int type,
    union sigval val)
{
	struct proc *p = curproc;
	struct trapframe *tf = p->p_md.md_regs;
	struct pcb *pcb = &p->p_addr->u_pcb;
	struct sigacts *psp = p->p_p->ps_sigacts;
	struct sigcontext ksc;
	siginfo_t ksi;
	register_t scp, sip;
	int sss;

	/* Save the FPU context first. */
	fpu_proc_save(p);

	/*
	 * Allocate space for the signal handler context.
	 */
	if ((p->p_sigstk.ss_flags & SS_DISABLE) == 0 &&
	    !sigonstack(tf->tf_sp) && (psp->ps_sigonstack & sigmask(sig)))
		scp = (register_t)p->p_sigstk.ss_sp;
	else
		scp = (tf->tf_sp + 63) & ~63;

	sss = (sizeof(ksc) + 63) & ~63;
	sip = 0;
	if (psp->ps_siginfo & sigmask(sig)) {
		sip = scp + sizeof(ksc);
		sss += (sizeof(ksi) + 63) & ~63;
	}

	bzero(&ksc, sizeof(ksc));
	ksc.sc_mask = mask;
	ksc.sc_fp = scp + sss;
	ksc.sc_ps = tf->tf_ipsw;
	ksc.sc_pcoqh = tf->tf_iioq_head;
	ksc.sc_pcoqt = tf->tf_iioq_tail;
	ksc.sc_regs[0] = tf->tf_t1;
	ksc.sc_regs[1] = tf->tf_t2;
	ksc.sc_regs[2] = tf->tf_sp;
	ksc.sc_regs[3] = tf->tf_t3;
	ksc.sc_regs[4] = tf->tf_sar;
	ksc.sc_regs[5] = tf->tf_r1;
	ksc.sc_regs[6] = tf->tf_rp;
	ksc.sc_regs[7] = tf->tf_r3;
	ksc.sc_regs[8] = tf->tf_r4;
	ksc.sc_regs[9] = tf->tf_r5;
	ksc.sc_regs[10] = tf->tf_r6;
	ksc.sc_regs[11] = tf->tf_r7;
	ksc.sc_regs[12] = tf->tf_r8;
	ksc.sc_regs[13] = tf->tf_r9;
	ksc.sc_regs[14] = tf->tf_r10;
	ksc.sc_regs[15] = tf->tf_r11;
	ksc.sc_regs[16] = tf->tf_r12;
	ksc.sc_regs[17] = tf->tf_r13;
	ksc.sc_regs[18] = tf->tf_r14;
	ksc.sc_regs[19] = tf->tf_r15;
	ksc.sc_regs[20] = tf->tf_r16;
	ksc.sc_regs[21] = tf->tf_r17;
	ksc.sc_regs[22] = tf->tf_r18;
	ksc.sc_regs[23] = tf->tf_t4;
	ksc.sc_regs[24] = tf->tf_arg3;
	ksc.sc_regs[25] = tf->tf_arg2;
	ksc.sc_regs[26] = tf->tf_arg1;
	ksc.sc_regs[27] = tf->tf_arg0;
	ksc.sc_regs[28] = tf->tf_dp;
	ksc.sc_regs[29] = tf->tf_ret0;
	ksc.sc_regs[30] = tf->tf_ret1;
	ksc.sc_regs[31] = tf->tf_r31;
	bcopy(&p->p_addr->u_pcb.pcb_fpstate->hfp_regs, ksc.sc_fpregs,
	    sizeof(ksc.sc_fpregs));

	if (setstack(tf, scp + sss, tf->tf_r3))
		sigexit(p, SIGILL);

	tf->tf_arg0 = sig;
	tf->tf_arg1 = sip;
	tf->tf_arg2 = tf->tf_r4 = scp;
	tf->tf_arg3 = (register_t)catcher;
	tf->tf_ipsw &= ~(PSL_N|PSL_B|PSL_T);
	tf->tf_iioq_head = HPPA_PC_PRIV_USER | p->p_p->ps_sigcode;
	tf->tf_iioq_tail = tf->tf_iioq_head + 4;
	tf->tf_iisq_tail = tf->tf_iisq_head = pcb->pcb_space;
	/* disable tracing in the trapframe */

	ksc.sc_cookie = (long)scp ^ p->p_p->ps_sigcookie;
	if (copyout(&ksc, (void *)scp, sizeof(ksc)))
		sigexit(p, SIGILL);

	if (sip) {
		initsiginfo(&ksi, sig, code, type, val);
		if (copyout(&ksi, (void *)sip, sizeof(ksi)))
			sigexit(p, SIGILL);
	}
}

int
sys_sigreturn(struct proc *p, void *v, register_t *retval)
{
	struct sys_sigreturn_args /* {
		syscallarg(struct sigcontext *) sigcntxp;
	} */ *uap = v;
	struct sigcontext ksc, *scp = SCARG(uap, sigcntxp);
	struct trapframe *tf = p->p_md.md_regs;
	int error;

	if (PROC_PC(p) != p->p_p->ps_sigcoderet) {
		sigexit(p, SIGILL);
		return (EPERM);
	}

	/* Flush the FPU context first. */
	fpu_proc_flush(p);

	if ((error = copyin((caddr_t)scp, (caddr_t)&ksc, sizeof ksc)))
		return (error);

	if (ksc.sc_cookie != ((long)scp ^ p->p_p->ps_sigcookie)) {
		sigexit(p, SIGILL);
		return (EFAULT);
	}

	/* Prevent reuse of the sigcontext cookie */
	ksc.sc_cookie = 0;
	(void)copyout(&ksc.sc_cookie, (caddr_t)scp +
	    offsetof(struct sigcontext, sc_cookie), sizeof (ksc.sc_cookie));

#define PSL_MBS (PSL_C|PSL_Q|PSL_P|PSL_D|PSL_I)
#define PSL_MBZ (PSL_Y|PSL_Z|PSL_S|PSL_X|PSL_M|PSL_R)
	if ((ksc.sc_ps & (PSL_MBS|PSL_MBZ)) != PSL_MBS)
		return (EINVAL);

	p->p_sigmask = ksc.sc_mask &~ sigcantmask;

	tf->tf_t1 = ksc.sc_regs[0];		/* r22 */
	tf->tf_t2 = ksc.sc_regs[1];		/* r21 */
	tf->tf_sp = ksc.sc_regs[2];
	tf->tf_t3 = ksc.sc_regs[3];		/* r20 */
	tf->tf_sar = ksc.sc_regs[4];
	tf->tf_r1 = ksc.sc_regs[5];
	tf->tf_rp = ksc.sc_regs[6];
	tf->tf_r3 = ksc.sc_regs[7];
	tf->tf_r4 = ksc.sc_regs[8];
	tf->tf_r5 = ksc.sc_regs[9];
	tf->tf_r6 = ksc.sc_regs[10];
	tf->tf_r7 = ksc.sc_regs[11];
	tf->tf_r8 = ksc.sc_regs[12];
	tf->tf_r9 = ksc.sc_regs[13];
	tf->tf_r10 = ksc.sc_regs[14];
	tf->tf_r11 = ksc.sc_regs[15];
	tf->tf_r12 = ksc.sc_regs[16];
	tf->tf_r13 = ksc.sc_regs[17];
	tf->tf_r14 = ksc.sc_regs[18];
	tf->tf_r15 = ksc.sc_regs[19];
	tf->tf_r16 = ksc.sc_regs[20];
	tf->tf_r17 = ksc.sc_regs[21];
	tf->tf_r18 = ksc.sc_regs[22];
	tf->tf_t4 = ksc.sc_regs[23];		/* r19 */
	tf->tf_arg3 = ksc.sc_regs[24];		/* r23 */
	tf->tf_arg2 = ksc.sc_regs[25];		/* r24 */
	tf->tf_arg1 = ksc.sc_regs[26];		/* r25 */
	tf->tf_arg0 = ksc.sc_regs[27];		/* r26 */
	tf->tf_dp = ksc.sc_regs[28];
	tf->tf_ret0 = ksc.sc_regs[29];
	tf->tf_ret1 = ksc.sc_regs[30];
	tf->tf_r31 = ksc.sc_regs[31];
	bcopy(ksc.sc_fpregs, &p->p_addr->u_pcb.pcb_fpstate->hfp_regs,
	    sizeof(ksc.sc_fpregs));

	tf->tf_iioq_head = ksc.sc_pcoqh | HPPA_PC_PRIV_USER;
	tf->tf_iioq_tail = ksc.sc_pcoqt | HPPA_PC_PRIV_USER;
	if ((tf->tf_iioq_head & ~PAGE_MASK) == SYSCALLGATE)
		tf->tf_iisq_head = HPPA_SID_KERNEL;
	else
		tf->tf_iisq_head = p->p_addr->u_pcb.pcb_space;
	if ((tf->tf_iioq_tail & ~PAGE_MASK) == SYSCALLGATE)
		tf->tf_iisq_tail = HPPA_SID_KERNEL;
	else
		tf->tf_iisq_tail = p->p_addr->u_pcb.pcb_space;
	tf->tf_ipsw = ksc.sc_ps | (curcpu()->ci_psw & PSL_O);

	return (EJUSTRETURN);
}

void
signotify(struct proc *p)
{
	setsoftast(p);
	cpu_unidle(p->p_cpu);
}

/*
 * machine dependent system variables.
 */
int
cpu_sysctl(int *name, u_int namelen, void *oldp, size_t *oldlenp, void *newp,
    size_t newlen, struct proc *p)
{
	extern u_int fpu_enable;
	extern int cpu_fpuena;
	dev_t consdev;
	int oldval, ret;

	/* all sysctl names at this level are terminal */
	if (namelen != 1)
		return (ENOTDIR);	/* overloaded */
	switch (name[0]) {
	case CPU_CONSDEV:
		if (cn_tab != NULL)
			consdev = cn_tab->cn_dev;
		else
			consdev = NODEV;
		return (sysctl_rdstruct(oldp, oldlenp, newp, &consdev,
		    sizeof consdev));
	case CPU_FPU:
		if (curcpu()->ci_fpu_state) {
			mtctl(fpu_enable, CR_CCR);
			fpu_save(curcpu()->ci_fpu_state);
			curcpu()->ci_fpu_state = 0;
			mtctl(0, CR_CCR);
		}
		return (sysctl_int(oldp, oldlenp, newp, newlen, &cpu_fpuena));
	case CPU_LED_BLINK:
		oldval = led_blink;
		ret = sysctl_int(oldp, oldlenp, newp, newlen, &led_blink);
		/*
		 * If we were false and are now true, start the timer.
		 */
		if (!oldval && led_blink > oldval)
			blink_led_timeout(NULL);
		return (ret);
	default:
		return (EOPNOTSUPP);
	}
	/* NOTREACHED */
}


/*
 * consinit:
 * initialize the system console.
 */
void
consinit(void)
{
	/*
	 * Initial console setup has been done in pdc_init().
	 */
}


struct blink_led_softc {
	SLIST_HEAD(, blink_led) bls_head;
	int bls_on;
	struct timeout bls_to;
} blink_sc = { SLIST_HEAD_INITIALIZER(bls_head), 0 };

void
blink_led_register(struct blink_led *l)
{
	if (SLIST_EMPTY(&blink_sc.bls_head)) {
		timeout_set(&blink_sc.bls_to, blink_led_timeout, &blink_sc);
		blink_sc.bls_on = 0;
		if (led_blink)
			timeout_add(&blink_sc.bls_to, 1);
	}
	SLIST_INSERT_HEAD(&blink_sc.bls_head, l, bl_next);
}

void
blink_led_timeout(void *vsc)
{
	struct blink_led_softc *sc = &blink_sc;
	struct blink_led *l;
	int t;

	if (SLIST_EMPTY(&sc->bls_head))
		return;

	SLIST_FOREACH(l, &sc->bls_head, bl_next) {
		(*l->bl_func)(l->bl_arg, sc->bls_on);
	}
	sc->bls_on = !sc->bls_on;

	if (!led_blink)
		return;

	/*
	 * Blink rate is:
	 *      full cycle every second if completely idle (loadav = 0)
	 *      full cycle every 2 seconds if loadav = 1
	 *      full cycle every 3 seconds if loadav = 2
	 * etc.
	 */
	t = (((averunnable.ldavg[0] + FSCALE) * hz) >> (FSHIFT + 1));
	timeout_add(&sc->bls_to, t);
}
@


1.246
log
@all pools have their ipl set via pool_setipl, so fold it into pool_init.

the ioff argument to pool_init() is unused and has been for many
years, so this replaces it with an ipl argument. because the ipl
will be set on init we no longer need pool_setipl.

most of these changes have been done with coccinelle using the spatch
below. cocci sucks at formatting code though, so i fixed that by hand.

the manpage and subr_pool.c bits i did myself.

ok tedu@@ jmatthew@@

@@ipl@@
expression pp;
expression ipl;
expression s, a, o, f, m, p;
@@@@
-pool_init(pp, s, a, o, f, m, p);
-pool_setipl(pp, ipl);
+pool_init(pp, s, a, ipl, f, m, p);
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.245 2016/05/21 00:56:43 deraadt Exp $	*/
d959 2
a960 1
	for (;;) ;
@


1.245
log
@hand-massage sendsig() and sys_sigreturn() to be much more similar.
ok guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.244 2016/05/10 18:39:44 deraadt Exp $	*/
d393 1
a393 1
	pool_init(&hppa_fppl, sizeof(struct hppa_fpstate), 16, 0, 0,
a394 1
	pool_setipl(&hppa_fppl, IPL_NONE);
@


1.244
log
@SROP mitigation.  sendsig() stores a (per-process ^ &sigcontext) cookie
inside the sigcontext.  sigreturn(2) checks syscall entry was from the
exact PC addr in the (per-process ASLR) sigtramp, verifies the cookie,
and clears it to prevent sigcontext reuse.
not yet tested on landisk, sparc, *88k, socppc.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.243 2016/04/20 23:52:04 dlg Exp $	*/
a1214 6
#ifdef DEBUG
	if ((sigdebug & SDB_FOLLOW) && (!sigpid || p->p_pid == sigpid))
		printf("sendsig: %s[%d] sig %d catcher %p\n",
		    p->p_comm, p->p_pid, sig, catcher);
#endif

a1233 6
#ifdef DEBUG
	if ((tf->tf_iioq_head & ~PAGE_MASK) == SYSCALLGATE)
		printf("sendsig: interrupted syscall at 0x%x:0x%x flags %b\n",
		    tf->tf_iioq_head, tf->tf_iioq_tail, tf->tf_ipsw, PSL_BITS);
#endif

a1287 6
#ifdef DEBUG
	if ((sigdebug & SDB_FOLLOW) && (!sigpid || p->p_pid == sigpid))
		printf("sendsig(%d): sig %d scp %p fp %p sp 0x%x\n",
		    p->p_pid, sig, scp, ksc.sc_fp, tf->tf_sp);
#endif

a1296 6

#ifdef DEBUG
	if ((sigdebug & SDB_FOLLOW) && (!sigpid || p->p_pid == sigpid))
		printf("sendsig(%d): pc 0x%x catcher 0x%x\n", p->p_pid,
		    tf->tf_iioq_head, tf->tf_arg3);
#endif
d1305 1
a1305 1
	struct sigcontext *scp = SCARG(uap, sigcntxp), ksc;
a1309 2
		printf("%s(%d): sigreturn not from tramp [pc 0x%lx 0x%lx]\n",
		    p->p_comm, p->p_pid, PROC_PC(p), p->p_p->ps_sigcoderet);
a1313 5
#ifdef DEBUG
	if ((sigdebug & SDB_FOLLOW) && (!sigpid || p->p_pid == sigpid))
		printf("sigreturn: pid %d, scp %p\n", p->p_pid, scp);
#endif

a1320 3
		printf("%s(%d): cookie %lx should have been %lx\n",
		    p->p_comm, p->p_pid, ksc.sc_cookie,
		    (long)scp ^ p->p_p->ps_sigcookie);
d1328 1
a1328 2
	    offsetof(struct sigcontext, sc_cookie),
	    sizeof (ksc.sc_cookie));
a1383 4
#ifdef DEBUG
	if ((sigdebug & SDB_FOLLOW) && (!sigpid || p->p_pid == sigpid))
		printf("sigreturn(%d): returns\n", p->p_pid);
#endif
@


1.243
log
@pool_setipl for floating point context things

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.242 2015/10/21 07:59:18 mpi Exp $	*/
d1306 1
d1329 1
a1329 1
	struct sigcontext *scp, ksc;
d1333 7
a1339 1
	scp = SCARG(uap, sigcntxp);
d1350 14
@


1.242
log
@Do not call uvm_swap_finicrypt_all() a second time in dumpsys().

ok tedu@@, deraadt@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.241 2015/01/20 19:43:20 kettenis Exp $	*/
d395 1
@


1.241
log
@Move ps_strings "after" the random stackgap.  This makes its location a
per-process value, and therefpore turns the VM_PSSTRINGS sysctl into a
per-process one as well.  This gets rid of a pointer to the bottom of the
stack at a fixed location.  Also clears the road for unmapping the stackgap.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.240 2014/12/10 15:29:53 mikeb Exp $	*/
a1041 4

#ifdef UVM_SWAP_ENCRYPT
	uvm_swap_finicrypt_all();
#endif
@


1.240
log
@retire shutdown hooks; ok deraadt, krw
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.239 2014/10/25 17:31:26 kettenis Exp $	*/
d1168 1
a1168 1
	tf->tf_arg0 = (u_long)PS_STRINGS;
@


1.239
log
@Remove vmmap; it isn't used.

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.238 2014/10/23 16:57:45 miod Exp $	*/
a922 1
	doshutdownhooks();
@


1.238
log
@Correctly set up the HPMC trap entry: according to the PA-RISC Firmware
Architecture Reference Specification, the sum of the 8 trap entry words
*and* of the payload which address and length are to be set at well-known
positions in the aforementioned trap entry, needs to be zero; the existing
code was only enforcing that the sum of the trap entry words is zero.

This matches what Linux and NetBSD do.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.237 2014/10/23 16:49:58 miod Exp $	*/
a147 2
/* Virtual page frame for /dev/mem (see mem.c) */
vaddr_t vmmap;
a646 1
	vmmap = uvm_km_valloc_wait(kernel_map, NBPG);
@


1.237
log
@Revert limiting physmem to 2GB; the culprit was likely in uvm and uvm has
changed a lot in the last 5 years; verified to work on a 3GB system, in
snapshots for a few weeks already.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.236 2014/09/22 12:12:23 dlg Exp $	*/
d311 4
a314 2
		extern u_int hpmc_v[];	/* from locore.s */
		u_int *p = hpmc_v;
d316 4
d323 4
a326 3
		p[6] = (u_int)&hpmc_dump;
		p[7] = 32;
		p[5] = -(p[0] + p[1] + p[2] + p[3] + p[4] + p[6] + p[7]);
@


1.236
log
@implement atomic_{cas,swap}_{uint,ulong,ptr} and
atomic_{add,sub}_{int,long}_nv. sys/atomic.h turns these into the
rest of the atomic api.

on uniprocessor hppa systems "atomic" operations are implemented
as a non-interruptable sequence by disabling all interrupts on the
cpu, doing the operation, and then restoring the interrupt mask.

this isnt enough on MP systems, so we added a global atomic memory
mutex that is taken inside the interrupt disabling above to coordinate
operations between cpus.

this is a lot of overhead though cos mutexes dance around with ipls,
which is unecessary in our case because of the interrupt disabling
that is already done. also, hppa spinlocks are implemented with
ldcw which requires the word it operates on to be 16 byte aligned.
mutexes arent guaranteed to have this alignment so they compensate
by having lots of words inside themselves so they can hit the
appropriate one to use for the ldcw op.

with this in mind, this change pulls __cpu_simple_locks, which are
simply ldcw spinlocks with a 16 byte aligned word, out of
src/sys/arch/hppa/include/lock.h into src/sys/arch/hppa/include/atomic.h
so atomic.h can use them. lock.h includes atomic.h, so it still
gets and provides the same functionality as before.

finally, this also pulls the rwlock cas implementation apart. cas
ops now share the same serialising lock on MP systems as the other
memory operations, and rw_cas is defined as a wrapper around
atomic_cas_uint.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.235 2014/09/19 18:21:14 kettenis Exp $	*/
a355 6
	/*
	 * XXX For some reason, using any physical memory above the
	 * 2GB marker causes memory corruption on PA-RISC 2.0
	 * machines.  Cap physical memory at 2GB for now.
	 */
#if 0
a357 4
#else
	if (avail_end > 0x80000000)
		avail_end = 0x80000000;
#endif
@


1.235
log
@Use config_suspend_all(9).
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.234 2014/08/18 05:11:03 dlg Exp $	*/
d133 1
a133 1
struct mutex mtx_atomic = MUTEX_INITIALIZER(IPL_NONE);
@


1.234
log
@dont rely on mbuf.h to provide pool.h.

ok miod@@, who has offerred to help with any MD fallout
ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.233 2014/07/22 01:04:04 uebayasi Exp $	*/
a891 2
	struct device *mainbus;

d930 1
a930 3
	mainbus = device_mainbus();
	if (mainbus != NULL)
		config_suspend(mainbus, DVACT_POWERDOWN);
@


1.233
log
@boot(9): Reduce diffs between hppa & hppa64 (& others)
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d41 1
a41 1
#include <sys/mbuf.h>
@


1.232
log
@boot(9): Reduce annoying style diffs

- Always use either: ((x & RB_XXX) != 0) or ((x & RB_XXX) == 0) in boolean
  context (mostly if (x), or x ? y : z)
  - prom_halt() in alpha is confirmed to take int as boolean

Converted by coccinelle.  No functional change intended.
@
text
@d945 1
a945 1
		if ((howto & RB_POWERDOWN) != 0 && cold_hook) {
@


1.231
log
@boot(9): Cosmetic changes to improve diff'ability.
@
text
@d911 1
a911 1
	if (!(howto & RB_NOSYNC)) {
d927 1
a927 1
	if (howto & RB_DUMP)
d944 2
a945 2
	if (howto & RB_HALT) {
		if (howto & RB_POWERDOWN && cold_hook) {
@


1.230
log
@Cosmetic changes to reduce diffs.
@
text
@d970 1
a970 1
	for (;;) ; /* loop while bus reset is coming up */
@


1.229
log
@These still need <sys/reboot.h> for the RB_ constants.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.228 2014/07/12 22:37:03 uebayasi Exp $	*/
d915 1
a915 1
		if ((howto & RB_TIMEBAD) == 0)
d917 1
a917 1
		else
d919 1
@


1.228
log
@reboot(9), panic(9): Call panic(9) for unrecoverable MD H/W errors (NMIs)

Some architectures have ability to detect hardware sanity and notify system
(NMI, firmware callback, etc.).  Handle these hardware severe errors, same
as software errors, with panic(9).

According to miod@@, SGI IP27 NMI is triggered by pushing some "hidden" button,
which "usual" users/admins don't know.  Pushing such a button is "RB_USERREQ"
(human-triggered) in that the button is pushed by a human, but not "RB_USERREQ"
in that no user intervention in system (== no command input) is done.  miod@@
agreed that changing these from RB_USERREQ to !RB_USERREQ (== panic(9)) is
not a big problem.

OK miod@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d35 1
@


1.227
log
@boot(9), reboot(9): Migrate MD callers of boot(9) to reboot(9)

I have found that some ports call boot(9) from machine-dependent code to
reboot system.  These should be changed to either:

- Sending signal to init(8) to trigger it to shutdown system cleanly, like
  acpi(4) does, in cases where found problems don't prevent system from working
  immediately, or

- Just doing panic(9) if the situation is severely broken.

For now, just rewrite boot() to reboot().  Actual fixes follow.

Discussed with & OK from kettenis@@
@
text
@a34 1
#include <sys/reboot.h>
a996 2
	printf("HPMC\n");

d998 2
a999 1
	reboot(RB_NOSYNC);
@


1.226
log
@Set cold to 1 before executing the DVACT_POWERDOWN handlers when halting or
rebooting a machine, like it is done in the hibernate case.

At least some USB host controller drivers rely on this to busy way instead
of sleeping.  Avoid a panic on macppc with an uhci(4) cardbus plugged in.

ok deraadt@@, uebayashi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.225 2014/07/10 20:15:26 uebayasi Exp $	*/
d1001 1
a1001 1
	boot(RB_NOSYNC);
@


1.225
log
@boot(9): Remove comments about RB_*, "cold", and savectx()

Again remove slightly different comments to reduce diffs.  These will be
re-added once boot() become MI and its specification is clearly re-defined.

OK miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a921 2
	/* XXX probably save howto into stable storage */

d924 1
@


1.224
log
@boot(): Remove comments about RB_TIMEBAD to reduce diffs

RB_TIMEBAD is documented well enough that the comment is not needed.  sparc64
does slightly different and its comment is left with XXX.

OK deraadt@@ miod@@
@
text
@a902 1
	/* If system is cold, just halt. */
a903 1
		/* (Unless the user explicitly asked for reboot.) */
@


1.223
log
@boot(): Unify declarations

OK deraadt@@
@
text
@d916 1
a916 5
		/*
		 * If we've been adjusting the clock, the todr
		 * will be out of synch; adjust it now unless
		 * the system was sitting in ddb.
		 */
@


1.222
log
@Revert previous diff setting cold to 1 on shutdown because it breaks machine
with softraid(4) disks.

softraid(4) is the last real consumer of the doshutdownhooks(9) API and it is
not trivial to convert its hook to a DVACT_POWERDOWN handler since the latter
does not allow to sleep.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.221 2014/05/30 13:46:16 mpi Exp $	*/
d889 1
a889 1
void
@


1.221
log
@Set cold to 1 before executing the DVACT_POWERDOWN handlers when halting or
rebooting a machine, like it is done in the hibernate case.

At least some USB host controller drivers rely on this to busy way instead
of sleeping.  Avoid a panic on macppc with an uhci(4) cardbus plugged in.

ok deraadt@@, uebayashi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.220 2014/05/08 21:32:45 miod Exp $	*/
d928 2
a931 1
	cold = 1;
@


1.220
log
@Format string fixes and removal of -Wno-format for hppa kernels.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.219 2014/04/08 09:34:23 mpi Exp $	*/
a927 2
	/* XXX probably save howto into stable storage */

d930 1
@


1.219
log
@Less <uvm/uvm.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.218 2014/04/04 20:25:21 miod Exp $	*/
d627 1
a627 1
	printf("real mem = %u (%uMB)\n", ptoa(physmem),
d629 1
a629 1
	printf("rsvd mem = %u (%uKB)\n", ptoa(resvmem), ptoa(resvmem) / 1024);
@


1.218
log
@If the PDC_COPROC call fails, and we are running on a PA 1.1 system, assume
the usual 1.1 coprocessor mask, instead of using zero and having every
userland process dying with signal 4.

The circumstances under which this call fails are unclear and could be
tied to specific PROM version (I have tried overzealous stack alignment and
other tricks, to no avail). Interestingly enough, the 715/75 system which
hits this problem, only triggers it when booting from disk, and never when
booting from network.

This diff is an ugly bandaid until the problem is better understood. Or maybe
it is not worth investigating, seeing that Linux hardcodes the coprocessor
mask and never issues PDC_COPROC calls; I wonder what HP/UX does.

In my tree for over 18 months; "Looks like a nice hack" deraadt@@
715/75 system provided by Sebastiaan Indesteege, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.217 2014/03/29 18:09:29 guenther Exp $	*/
a56 2
#include <uvm/uvm_page.h>
#include <uvm/uvm_swap.h>
@


1.217
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.216 2014/03/26 05:23:42 guenther Exp $	*/
a169 1
struct pdc_coproc pdc_coproc PDC_ALIGNMENT;
a207 1
int desidhash_x(void);
d421 1
d454 17
a470 3
	    &pdc_coproc, 0, 0, 0, 0)) < 0) {
		printf("WARNING: PDC_COPROC error %d\n", error);
		cpu_fpuena = 0;
@


1.216
log
@Move p_emul and p_sigcode from proc to process.
Tweak the handling of ktrace EMUL when changing ktracing: only
generate one per process (not one per thread) and pass the correct
proc pointer down to the VFS layer.  Permit generating of NAMI and
CSW records inside ktrace(2) itself.

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.215 2014/03/22 06:05:45 guenther Exp $	*/
d949 1
a949 1
		__asm __volatile("stwas %0, 0(%1)"
d959 1
a959 1
		__asm __volatile(".export hppa_reset, entry\n\t"
d961 1
a961 1
		__asm __volatile("stwas %0, 0(%1)"
@


1.215
log
@Move p_sigacts from struct proc to struct process.

testing help mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.214 2014/03/13 03:52:55 dlg Exp $	*/
d1305 1
a1305 1
	tf->tf_iioq_head = HPPA_PC_PRIV_USER | p->p_sigcode;
@


1.214
log
@get rid of the assumption that the head of the alldevs list is the
"mainbus" device. this breaks when mpath is enabled because it
attaches before mainbus and therefore takes the head position.

have autoconf provide device_mainbus() which looks up mainbus_cd,
and use that instead.

discussed with deraadt who just wants mpath stuff to move forward
despite there being many ways to shine this particular turd.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.213 2013/11/23 07:20:52 uebayasi Exp $	*/
d1219 1
a1219 1
	struct sigacts *psp = p->p_sigacts;
@


1.213
log
@Run doshutdownhooks() and config_suspend() even when boot() is called while
cold != 0.  Indent and make hppa/hppa64 boot() closer to others.

OK kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d881 2
d927 3
a929 2
	if (!TAILQ_EMPTY(&alldevs))
		config_suspend(TAILQ_FIRST(&alldevs), DVACT_POWERDOWN);
@


1.212
log
@In boot(), do not iterate over alldevs if it's empty (i.e. halting from ddb
with ddb entered early with boot -d or from UKC).
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.211 2013/06/11 16:42:08 deraadt Exp $	*/
d895 2
a896 3
	} else {

		boothowto = howto | (boothowto & RB_HALT);
d898 1
a898 14
		if (!(howto & RB_NOSYNC)) {
			waittime = 0;
			vfs_shutdown();
			/*
			 * If we've been adjusting the clock, the todr
			 * will be out of synch; adjust it now unless
			 * the system was sitting in ddb.
			 */
			if ((howto & RB_TIMEBAD) == 0)
				resettodr();
			else
				printf("WARNING: not updating battery clock\n");
		}
		if_downall();
d900 27
a926 11
		/* XXX probably save howto into stable storage */

		uvm_shutdown();
		splhigh();

		if (howto & RB_DUMP)
			dumpsys();

		doshutdownhooks();
		if (!TAILQ_EMPTY(&alldevs))
			config_suspend(TAILQ_FIRST(&alldevs), DVACT_POWERDOWN);
d929 1
a929 1
		hppa_ipi_broadcast(HPPA_IPI_HALT);
a930 1
	}
@


1.211
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.210 2012/12/02 07:03:31 guenther Exp $	*/
d923 2
a924 1
		config_suspend(TAILQ_FIRST(&alldevs), DVACT_POWERDOWN);
@


1.210
log
@Determine whether we're currently on the alternative signal stack
dynamically, by comparing the stack pointer against the altstack
base and size, so that you get the correct answer if you longjmp
out of the signal handler, as tested by regress/sys/kern/stackjmp/.
Also, fix alt stack handling on vax, where it was completely broken.

Testing and corrections by miod@@, krw@@, tobiasu@@, pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.209 2012/10/26 12:32:48 kettenis Exp $	*/
d1030 2
a1031 2
	daddr64_t blkno;
	int (*dump)(dev_t, daddr64_t, caddr_t, size_t);
@


1.209
log
@Properly clear trap frame in setregs() to avoid leaking registers across exec.

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.208 2012/10/08 21:47:47 deraadt Exp $	*/
a1228 2
	ksc.sc_onstack = p->p_sigstk.ss_flags & SS_ONSTACK;

d1232 2
a1233 2
	if ((p->p_sigstk.ss_flags & SS_DISABLE) == 0 && !ksc.sc_onstack &&
	    (psp->ps_sigonstack & sigmask(sig))) {
d1235 1
a1235 2
		p->p_sigstk.ss_flags |= SS_ONSTACK;
	} else
d1251 1
a1353 4
	if (ksc.sc_onstack)
		p->p_sigstk.ss_flags |= SS_ONSTACK;
	else
		p->p_sigstk.ss_flags &= ~SS_ONSTACK;
@


1.208
log
@Revamp the sequences for suspend/hibernate -> resume so that the code
paths are reflexive.  It is now possible to fail part-way through a
suspend sequence, and recover along the resume code path.
Split DVACT_SUSPEND by adding a new DVACT_POWERDOWN method is used
after hibernate (and suspend too) to finish the job.  Some drivers
must be converted at the same time to use this instead of shutdown hooks
(the others will follow at a later time)
ok kettenis mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.207 2012/10/07 20:39:15 kettenis Exp $	*/
d1165 1
d1167 3
a1169 3
	tf->tf_iioq_tail = 4 +
	    (tf->tf_iioq_head = pack->ep_entry | HPPA_PC_PRIV_USER);
	tf->tf_rp = 0;
a1170 1
	tf->tf_arg1 = tf->tf_arg2 = 0; /* XXX dynload stuff */
d1175 16
a1190 1
	/* reset any of the pending FPU exceptions */
d1192 1
@


1.207
log
@Align the stack on a 64-byte boundary as required by "The 32-bit PA-RISC
Run-time Architecture Document".  GCC relies on this to properly align
stack variables.

ok guenther@@, beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.206 2012/06/21 00:56:59 guenther Exp $	*/
d923 1
@


1.206
log
@__tfork() needs to set the stack address of the new thread in the kernel,
so that it can't get a signal while still running on the parent thread's
stack.  Also, pass in sizeof(struct __tfork) to provide forward compat
when more members are added.  This is an ABI change, so switch syscall
numbers and bump lib majors this time.

ok deraadt@@ matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.205 2011/09/20 09:49:38 miod Exp $	*/
d1172 1
a1172 1
	setstack(tf, (stack + 0x1f) & ~0x1f, 0);
@


1.205
log
@Clear RB_POWERDOWN early in boot() on systems which can not powerdown and
which firmware does not send spin up commands to the disks, in case the
operator changes his mind and reboots instead of manually powering down
after the system has halted.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.204 2011/07/05 04:48:01 guenther Exp $	*/
d1136 19
a1162 1
	register_t zero;
d1172 1
a1172 6
	stack = (stack + 0x1f) & ~0x1f;
	tf->tf_r3 = stack;
	tf->tf_sp = stack += HPPA_FRAME_SIZE;
	zero = 0;
	copyout(&zero, (caddr_t)(stack - HPPA_FRAME_SIZE), sizeof(register_t));
	copyout(&zero, (caddr_t)(stack + HPPA_FRAME_CRP), sizeof(register_t));
d1277 3
a1279 1
	sss += HPPA_FRAME_SIZE;
a1283 1
	tf->tf_sp = scp + sss;
d1293 1
a1293 1
		    p->p_pid, sig, scp, ksc.sc_fp, (register_t)scp + sss);
a1303 5

	if (copyout(&tf->tf_r3, (caddr_t)(tf->tf_sp - HPPA_FRAME_SIZE),
	    sizeof(register_t)))
		sigexit(p, SIGILL);
	tf->tf_r3 = tf->tf_sp - HPPA_FRAME_SIZE;
@


1.204
log
@Recommit the reverted sigacts change now that the NFS use-after-free
problem has been tracked down.  This fixes the sharing of the signal
handling state: shared bits go in sigacts, per-rthread bits goes in
struct proc.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.203 2011/06/26 22:39:59 deraadt Exp $	*/
d881 9
@


1.203
log
@if_downall() cannot be done MI in sys_reboot() because vfs_shutdown()
might need network (ie. nfs).  Move the call to the MD boot() routines.
This cause for boot hangs diagnosed by kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.202 2011/06/05 19:41:06 deraadt Exp $	*/
d1190 1
a1190 1
	ksc.sc_onstack = psp->ps_sigstk.ss_flags & SS_ONSTACK;
d1195 1
a1195 1
	if ((psp->ps_flags & SAS_ALTSTACK) && !ksc.sc_onstack &&
d1197 2
a1198 2
		scp = (register_t)psp->ps_sigstk.ss_sp;
		psp->ps_sigstk.ss_flags |= SS_ONSTACK;
d1322 1
a1322 1
		p->p_sigacts->ps_sigstk.ss_flags |= SS_ONSTACK;
d1324 1
a1324 1
		p->p_sigacts->ps_sigstk.ss_flags &= ~SS_ONSTACK;
@


1.202
log
@Move the bufcachepercent setting code to MI locations -- set it to 42%
for now; that is unlikely to hit some of the remaining starvation bugs.
Repair the bufpages calculation too; i386 was doing it ahead of time
(incorrectly) and then re-calculating it.
ok thib
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.201 2011/04/18 21:44:55 guenther Exp $	*/
d55 1
d903 1
@


1.201
log
@Revert the sigacts diff: NFS can apparently retain pointers to processes
until they're zombies and then send them signals (for intr mounts).  Until
that is untangled, the sigacts change is unsafe.  sthen@@ was the victim
for this one
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.199 2011/01/14 13:32:43 jsing Exp $	*/
a77 14

/*
 * Patchable buffer cache parameters
 */
#ifndef BUFCACHEPERCENT
#define BUFCACHEPERCENT 10
#endif /* BUFCACHEPERCENT */

#ifdef BUFPAGES
int bufpages = BUFPAGES;
#else
int bufpages = 0;
#endif
int bufcachepercent = BUFCACHEPERCENT;
@


1.200
log
@Correct the sharing of the signal handling state: stuff that should
be shared (p_sigignore, p_sigcatch, P_NOCLDSTOP, P_NOCLDWAIT) moves
to struct sigacts, wihle stuff that should be per rthread (ps_oldmask,
SAS_OLDMASK, ps_sigstk) moves to struct proc.  Treat the coredumping
state bits (ps_sig, ps_code, ps_type, ps_sigval) as per-rthread
until our locking around coredumping is better.

Oh, and remove the old SunOS-compat ps_usertramp member.

"I like the sound of this" tedu@@
@
text
@d1202 1
a1202 1
	ksc.sc_onstack = p->p_sigstk.ss_flags & SS_ONSTACK;
d1207 1
a1207 1
	if ((p->p_sigstk.ss_flags & SS_DISABLE) == 0 && !ksc.sc_onstack &&
d1209 2
a1210 2
		scp = (register_t)p->p_sigstk.ss_sp;
		p->p_sigstk.ss_flags |= SS_ONSTACK;
d1334 1
a1334 1
		p->p_sigstk.ss_flags |= SS_ONSTACK;
d1336 1
a1336 1
		p->p_sigstk.ss_flags &= ~SS_ONSTACK;
@


1.199
log
@Halt secondary CPUs when shutting down or rebooting. This should prevent
occasional hangs during reboot.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.197 2011/01/01 19:00:56 jasper Exp $	*/
d1202 1
a1202 1
	ksc.sc_onstack = psp->ps_sigstk.ss_flags & SS_ONSTACK;
d1207 1
a1207 1
	if ((psp->ps_flags & SAS_ALTSTACK) && !ksc.sc_onstack &&
d1209 2
a1210 2
		scp = (register_t)psp->ps_sigstk.ss_sp;
		psp->ps_sigstk.ss_flags |= SS_ONSTACK;
d1334 1
a1334 1
		p->p_sigacts->ps_sigstk.ss_flags |= SS_ONSTACK;
d1336 1
a1336 1
		p->p_sigacts->ps_sigstk.ss_flags &= ~SS_ONSTACK;
@


1.198
log
@- de-register. no binary change.

ok jsing@@
@
text
@d926 4
d962 1
a962 1
	for(;;); /* loop while bus reset is comming up */
@


1.197
log
@Move setting cpu_hzticks to the clock initialization function, like
other ports (e.g. hppa64) do.

ok jsing@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.196 2011/01/01 18:59:26 jasper Exp $	*/
d329 1
a329 1
		register u_int *p = hpmc_v;
d341 1
a341 1
		register u_int cksum, *p;
d353 1
a353 1
		register u_int cksum, *p;
d676 1
a676 1
	register u_int num, denom, delta, mdelta;
d697 1
a697 1
	register u_int start, end, n;
d721 1
a721 1
	register int loop;
d753 2
a754 2
	register pa_space_t sp;
	register int i, j, k;
d759 1
a759 1
		register vaddr_t off = pdc_cache.it_off_base;
d771 1
a771 1
		register vaddr_t off = pdc_cache.dt_off_base;
d812 2
a813 2
	register vsize_t len;
	register int error, i, btlb_max;
@


1.196
log
@- ansify

ok jsing@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.195 2010/12/30 14:26:14 jsing Exp $	*/
a291 1
	extern u_long cpu_hzticks;
a298 1
	cpu_hzticks = (PAGE0->mem_10msec * 100) / hz;
@


1.195
log
@Turn signotify() into a function that also calls cpu_unidle().

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.193 2010/07/01 05:33:32 jsing Exp $	*/
d290 1
a290 2
hppa_init(start)
	paddr_t start;
d697 1
a697 2
delay(us)
	u_int us;
d721 1
a721 2
fall(c_base, c_count, c_loop, c_stride, data)
	int c_base, c_count, c_loop, c_stride, data;
d784 1
a784 3
hpti_g(hpt, hptsize)
	vaddr_t hpt;
	vsize_t hptsize;
d791 1
a791 2
pbtlb_g(i)
	int i;
d797 1
a797 7
ibtlb_g(i, sp, va, pa, sz, prot)
	int i;
	pa_space_t sp;
	vaddr_t va;
	paddr_t pa;
	vsize_t sz;
	u_int prot;
d811 1
a811 6
btlb_insert(space, va, pa, lenp, prot)
	pa_space_t space;
	vaddr_t va;
	paddr_t pa;
	vsize_t *lenp;
	u_int prot;
d894 1
a894 2
boot(howto)
	int howto;
d1095 1
a1095 4
kcopy(from, to, size)
	const void *from;
	void *to;
	size_t size;
d1101 1
a1101 5
copystr(src, dst, size, lenp)
	const void *src;
	void *dst;
	size_t size;
	size_t *lenp;
d1107 1
a1107 5
copyinstr(src, dst, size, lenp)
	const void *src;
	void *dst;
	size_t size;
	size_t *lenp;
d1115 1
a1115 5
copyoutstr(src, dst, size, lenp)
	const void *src;
	void *dst;
	size_t size;
	size_t *lenp;
d1123 1
a1123 4
copyin(src, dst, size)
	const void *src;
	void *dst;
	size_t size;
d1130 1
a1130 4
copyout(src, dst, size)
	const void *src;
	void *dst;
	size_t size;
d1140 2
a1141 5
setregs(p, pack, stack, retval)
	struct proc *p;
	struct exec_package *pack;
	u_long stack;
	register_t *retval;
d1179 2
a1180 6
sendsig(catcher, sig, mask, code, type, val)
	sig_t catcher;
	int sig, mask;
	u_long code;
	int type;
	union sigval val;
d1305 1
a1305 4
sys_sigreturn(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d1402 2
a1403 8
cpu_sysctl(name, namelen, oldp, oldlenp, newp, newlen, p)
	int *name;
	u_int namelen;
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
	struct proc *p;
@


1.194
log
@This is a first step towards getting rid of avail_start and avail_end in the
kernel, currently limited to low-hanging fruit: these variables were used
by bus_dma to specify the range in which to allocate memory, back when
uvm_pglistalloc() was stupid and would not walk the vm_physseg[].

Nowadays, except on some platforms for early initialization, these variables
are not used, or do not need to be global variables. Therefore:
- remove `extern' declarations of avail_start and avail_end (or close cousins,
  such as arm physical_start and physical_end) from files which no longer need
  to use them.
- make them local variables whenever possible.
- remove them when they are assigned to but no longer used.
@
text
@d1440 7
@


1.193
log
@Create a struct to store FP state and include a pointer to the CPU that
currently holds the FPU context for this process. This will be soon used
to implement FPU shootdowns on multiprocessor kernels.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.192 2010/06/29 20:30:32 guenther Exp $	*/
a145 1
paddr_t	avail_end;
d297 1
@


1.192
log
@Remove COMPAT_HPUX.  No one wanted to support it and its fewmets were
blocking other cleanups
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.191 2010/06/29 04:03:21 jsing Exp $	*/
d159 1
a159 1
struct fpreg proc0fpregs;
d417 3
a419 2
	proc0paddr->u_pcb.pcb_fpregs = &proc0fpregs;
	pool_init(&hppa_fppl, sizeof(struct fpreg), 16, 0, 0, "hppafp", NULL);
d1206 5
a1210 4
	pcb->pcb_fpregs->fpr_regs[0] = ((u_int64_t)HPPA_FPU_INIT) << 32;
	pcb->pcb_fpregs->fpr_regs[1] = 0;
	pcb->pcb_fpregs->fpr_regs[2] = 0;
	pcb->pcb_fpregs->fpr_regs[3] = 0;
d1308 1
a1308 1
	bcopy(p->p_addr->u_pcb.pcb_fpregs, ksc.sc_fpregs,
d1418 1
a1418 1
	bcopy(ksc.sc_fpregs, p->p_addr->u_pcb.pcb_fpregs,
@


1.191
log
@Factor out code used to save and flushe process FPU context.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.190 2010/06/29 00:50:40 jsing Exp $	*/
a69 8
#ifdef COMPAT_HPUX
#include <compat/hpux/hpux.h>
#include <compat/hpux/hpux_sig.h>
#include <compat/hpux/hpux_util.h>
#include <compat/hpux/hpux_syscallargs.h>
#include <machine/hpux_machdep.h>
#endif

a130 3
#ifdef COMPAT_HPUX
int	cpu_model_hpux;	/* contains HPUX_SYSCONF_CPU* kind of value */
#endif
a592 3
#ifdef COMPAT_HPUX
				cpu_model_hpux = HPUX_SYSCONF_CPUPA10;
#endif
a595 3
#ifdef COMPAT_HPUX
				cpu_model_hpux = HPUX_SYSCONF_CPUPA11;
#endif
a604 3
#ifdef COMPAT_HPUX
				cpu_model_hpux = HPUX_SYSCONF_CPUPA20;
#endif
a1436 136

#ifdef COMPAT_HPUX
void
hpux_sendsig(sig_t catcher, int sig, int mask, u_long code, int type,
    union sigval val)
{
	struct proc *p = curproc;
	struct pcb *pcb = &p->p_addr->u_pcb;
	struct trapframe *tf = p->p_md.md_regs;
	struct sigacts *psp = p->p_sigacts;
	struct hpux_sigcontext hsc;
	int sss;
	register_t scp;

#ifdef DEBUG
	if ((sigdebug & SDB_FOLLOW) && (!sigpid || p->p_pid == sigpid))
		printf("hpux_sendsig: %s[%d] sig %d catcher %p\n",
		    p->p_comm, p->p_pid, sig, catcher);
#endif
	/* Save the FPU context first. */
	fpu_proc_save(p);

	bzero(&hsc, sizeof hsc);
	hsc.sc_onstack = psp->ps_sigstk.ss_flags & SS_ONSTACK;
	hsc.sc_omask = mask;
	/* sc_scact ??? */

	hsc.sc_ret0 = tf->tf_ret0;
	hsc.sc_ret1 = tf->tf_ret1;

	hsc.sc_frame[0] = hsc.sc_args[0] = sig;
	hsc.sc_frame[1] = hsc.sc_args[1] = NULL;
	hsc.sc_frame[2] = hsc.sc_args[2] = scp;

	/*
	 * Allocate space for the signal handler context.
	 */
	if ((psp->ps_flags & SAS_ALTSTACK) && !hsc.sc_onstack &&
	    (psp->ps_sigonstack & sigmask(sig))) {
		scp = (register_t)psp->ps_sigstk.ss_sp;
		psp->ps_sigstk.ss_flags |= SS_ONSTACK;
	} else
		scp = (tf->tf_sp + 63) & ~63;

	sss = (sizeof(hsc) + 63) & ~63;

	if (tf->tf_flags & TFF_SYS) {
		hsc.sc_tfflags = HPUX_TFF_SYSCALL;
		hsc.sc_syscall = tf->tf_t1;
	} else if (tf->tf_flags & TFF_INTR)
		hsc.sc_tfflags = HPUX_TFF_INTR;
	else
		hsc.sc_tfflags = HPUX_TFF_TRAP;

	hsc.sc_regs[0] = tf->tf_r1;
	hsc.sc_regs[1] = tf->tf_rp;
	hsc.sc_regs[2] = tf->tf_r3;
	hsc.sc_regs[3] = tf->tf_r4;
	hsc.sc_regs[4] = tf->tf_r5;
	hsc.sc_regs[5] = tf->tf_r6;
	hsc.sc_regs[6] = tf->tf_r7;
	hsc.sc_regs[7] = tf->tf_r8;
	hsc.sc_regs[8] = tf->tf_r9;
	hsc.sc_regs[9] = tf->tf_r10;
	hsc.sc_regs[10] = tf->tf_r11;
	hsc.sc_regs[11] = tf->tf_r12;
	hsc.sc_regs[12] = tf->tf_r13;
	hsc.sc_regs[13] = tf->tf_r14;
	hsc.sc_regs[14] = tf->tf_r15;
	hsc.sc_regs[15] = tf->tf_r16;
	hsc.sc_regs[16] = tf->tf_r17;
	hsc.sc_regs[17] = tf->tf_r18;
	hsc.sc_regs[18] = tf->tf_t4;
	hsc.sc_regs[19] = tf->tf_t3;
	hsc.sc_regs[20] = tf->tf_t2;
	hsc.sc_regs[21] = tf->tf_t1;
	hsc.sc_regs[22] = tf->tf_arg3;
	hsc.sc_regs[23] = tf->tf_arg2;
	hsc.sc_regs[24] = tf->tf_arg1;
	hsc.sc_regs[25] = tf->tf_arg0;
	hsc.sc_regs[26] = tf->tf_dp;
	hsc.sc_regs[27] = tf->tf_ret0;
	hsc.sc_regs[28] = tf->tf_ret1;
	hsc.sc_regs[29] = tf->tf_sp;
	hsc.sc_regs[30] = tf->tf_r31;
	hsc.sc_regs[31] = tf->tf_sar;
	hsc.sc_regs[32] = tf->tf_iioq_head;
	hsc.sc_regs[33] = tf->tf_iisq_head;
	hsc.sc_regs[34] = tf->tf_iioq_tail;
	hsc.sc_regs[35] = tf->tf_iisq_tail;
	hsc.sc_regs[35] = tf->tf_eiem;
	hsc.sc_regs[36] = tf->tf_iir;
	hsc.sc_regs[37] = tf->tf_isr;
	hsc.sc_regs[38] = tf->tf_ior;
	hsc.sc_regs[39] = tf->tf_ipsw;
	hsc.sc_regs[40] = 0;
	hsc.sc_regs[41] = tf->tf_sr4;
	hsc.sc_regs[42] = tf->tf_sr0;
	hsc.sc_regs[43] = tf->tf_sr1;
	hsc.sc_regs[44] = tf->tf_sr2;
	hsc.sc_regs[45] = tf->tf_sr3;
	hsc.sc_regs[46] = tf->tf_sr5;
	hsc.sc_regs[47] = tf->tf_sr6;
	hsc.sc_regs[48] = tf->tf_sr7;
	hsc.sc_regs[49] = tf->tf_rctr;
	hsc.sc_regs[50] = tf->tf_pidr1;
	hsc.sc_regs[51] = tf->tf_pidr2;
	hsc.sc_regs[52] = tf->tf_ccr;
	hsc.sc_regs[53] = tf->tf_pidr3;
	hsc.sc_regs[54] = tf->tf_pidr4;
	/* hsc.sc_regs[55] = tf->tf_cr24; */
	hsc.sc_regs[56] = tf->tf_vtop;
	/* hsc.sc_regs[57] = tf->tf_cr26; */
	/* hsc.sc_regs[58] = tf->tf_cr27; */
	hsc.sc_regs[59] = 0;
	hsc.sc_regs[60] = 0;
	bcopy(p->p_addr->u_pcb.pcb_fpregs, hsc.sc_fpregs,
	    sizeof(hsc.sc_fpregs));

	tf->tf_rp = (register_t)pcb->pcb_sigreturn;
	tf->tf_arg3 = (register_t)catcher;
	tf->tf_sp = scp + sss;
	tf->tf_ipsw &= ~(PSL_N|PSL_B);
	tf->tf_iioq_head = HPPA_PC_PRIV_USER | p->p_sigcode;
	tf->tf_iioq_tail = tf->tf_iioq_head + 4;

	if (copyout(&hsc, (void *)scp, sizeof(hsc)))
		sigexit(p, SIGILL);

#ifdef DEBUG
	if ((sigdebug & SDB_FOLLOW) && (!sigpid || p->p_pid == sigpid))
		printf("sendsig(%d): pc 0x%x rp 0x%x\n", p->p_pid,
		    tf->tf_iioq_head, tf->tf_rp);
#endif
}
#endif
@


1.190
log
@Store pointer to process FPU state in struct cpu_info.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.189 2010/06/27 03:03:48 thib Exp $	*/
d68 1
d1224 1
a1224 4
	if (tf->tf_cr30 == curcpu()->ci_fpu_state) {
		fpu_exit();
		curcpu()->ci_fpu_state = 0;
	}
a1245 1
	extern u_int fpu_enable;
d1261 2
a1262 7
	/* flush the FPU ctx first */
	if (tf->tf_cr30 == curcpu()->ci_fpu_state) {
		mtctl(fpu_enable, CR_CCR);
		fpu_save(curcpu()->ci_fpu_state);
		/* fpu_curpcb = 0; only needed if fpregs are preset */
		mtctl(0, CR_CCR);
	}
d1387 2
a1388 5
	/* flush the FPU ctx first */
	if (tf->tf_cr30 == curcpu()->ci_fpu_state) {
		fpu_exit();
		curcpu()->ci_fpu_state = 0;
	}
a1462 1
	extern u_int fpu_enable;
d1476 2
a1477 7
	/* flush the FPU ctx first */
	if (tf->tf_cr30 == curcpu()->ci_fpu_state) {
		mtctl(fpu_enable, CR_CCR);
		fpu_save(curcpu()->ci_fpu_state);
		curcpu()->ci_fpu_state = 0;
		mtctl(0, CR_CCR);
	}
@


1.189
log
@uvm constraints. Add two mandatory MD symbols, uvm_md_constraints
which contains the constraints for DMA/memory allocation for each
architecture, and dma_constraints which contains the range of addresses
that are dma accessable by the system.

This is based on ariane@@'s physcontig diff, with lots of bugfixes and
additions the following additions by my self:

Introduce a new function pool_set_constraints() which sets the address
range for which we allocate pages for the pool from, this is now used
for the mbuf/mbuf cluster pools to keep them dma accessible.

The !direct archs no longer stuff pages into the kernel object in
uvm_km_getpage_pla but rather do a pmap_extract() in uvm_km_putpages.

Tested heavily by my self on i386, amd64 and sparc64. Some tests on
alpha and SGI.

"commit it" beck, art, oga, deraadt
"i like the diff" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.187 2010/06/10 17:54:13 deraadt Exp $	*/
a1202 1
	extern paddr_t fpu_curpcb;	/* from locore.S */
d1223 1
a1223 1
	if (tf->tf_cr30 == fpu_curpcb) {
d1225 1
a1225 1
		fpu_curpcb = 0;
a1247 1
	extern paddr_t fpu_curpcb;	/* from locore.S */
d1265 1
a1265 1
	if (tf->tf_cr30 == fpu_curpcb) {
d1267 1
a1267 1
		fpu_save(fpu_curpcb);
a1381 1
	extern paddr_t fpu_curpcb;	/* from locore.S */
d1396 1
a1396 1
	if (tf->tf_cr30 == fpu_curpcb) {
d1398 1
a1398 1
		fpu_curpcb = 0;
a1473 1
	extern paddr_t fpu_curpcb;	/* from locore.S */
d1489 1
a1489 1
	if (tf->tf_cr30 == fpu_curpcb) {
d1491 2
a1492 2
		fpu_save(fpu_curpcb);
		fpu_curpcb = 0;
a1623 1
	extern paddr_t fpu_curpcb;	/* from locore.S */
d1641 1
a1641 1
		if (fpu_curpcb) {
d1643 2
a1644 2
			fpu_save(fpu_curpcb);
			fpu_curpcb = 0;
@


1.188
log
@Use a mutex to make atomic operations atomic on multiprocessor kernels.

ok kettenis@@
@
text
@d205 3
@


1.187
log
@Declare safepri at the MD level on each platform, so that the kern_synch.c
does not have to deal with it as a common.  Some platforms may be missed
by this commit... if you spot one, fix it the same way.
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.186 2010/06/09 15:44:17 miod Exp $	*/
d157 4
@


1.186
log
@Move declaration of cn_tab from dev/cons.c to dev/cninit.c, or appropriate
md files for ports which do not use dev/cninit.c. This gets rid of a common
at kernel link time.
feedback drahn@@ ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.185 2010/05/24 15:04:55 deraadt Exp $	*/
d179 6
@


1.185
log
@Add missing prototypes
ok jsing kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.184 2010/05/09 17:37:33 kettenis Exp $	*/
d166 1
@


1.184
log
@Prevent "taken branch" exceptions from kernel space by clearing the PSL_T
bit before we enter a signal handler.

"if you say so" miod@@, "seems to make sense" jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.183 2010/05/02 22:59:11 kettenis Exp $	*/
d275 2
@


1.183
log
@Properly initialize the members of `struct mdproc' that deal with
single-stepping when we fork and reset them upon exec.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.182 2010/04/27 21:09:49 kettenis Exp $	*/
d1329 1
a1329 1
	tf->tf_ipsw &= ~(PSL_N|PSL_B);
@


1.182
log
@Avoid null-pointer dereference by giving proc0 a place to store its
floating-point registers.  Pointed out by Nick Hudson.

ok miod@@, jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.181 2010/04/19 14:05:04 jsing Exp $	*/
d1216 2
@


1.181
log
@Make the Processor Status Word (PSW) a per-CPU value.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.178 2009/08/11 19:17:16 miod Exp $	*/
d165 1
d411 1
@


1.180
log
@Allow for multiple CPUs by moving to an array of cpu_info.

ok kettenis@@
@
text
@d361 1
d560 1
a560 1
		kpsw |= PSL_O;
d1443 1
a1443 1
	tf->tf_ipsw = ksc.sc_ps | (kpsw & PSL_O);
@


1.179
log
@Make cpl and cpu_inintr per CPU variables. For locore.S, cpl becomes an
offset within cpu_primary_info - this will need to be revisited shortly.

ok kettenis@@
@
text
@d119 1
a119 1
struct cpu_info cpu_info_primary;
@


1.178
log
@Do not bother initializing bufpages in the md code if the computation is
exactly the same the mi could will use if bufinit() is invoked with
bufpages == 0.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.177 2009/08/11 18:46:32 miod Exp $	*/
d289 1
d358 3
@


1.177
log
@With the SysV memory allocation changes, allocsys() doesn't do anything
anymore. Get rid of it completely.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.176 2009/08/09 10:40:17 blambert Exp $	*/
a629 7

	/*
	 * Determine how many buffers to allocate.
	 * We allocate bufcachepercent% of memory for buffer space.
	 */
	if (bufpages == 0)
		bufpages = physmem * bufcachepercent / 100;
@


1.176
log
@Rototill system V message queues.

No longer allocate a static amount of memory for messages in MD
boot path; message queues, message metadata, and message data now
all use dynamic memory, which means that runtime sysctls should now
be trivial to implement.

Since I'm going to be around all week to fix any breakage, this should
probably just go in now.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.175 2009/08/02 16:28:39 beck Exp $	*/
a288 1
	vaddr_t v, v1;
a386 10
	/*
	 * Now allocate kernel dynamic variables
	 */

	v1 = v = round_page(start);
#define valloc(name, type, num) (name) = (type *)v; v = (vaddr_t)((name)+(num))
#undef valloc
	v = round_page(v);
	bzero ((void *)v1, (v - v1));

d388 1
a388 1
	pmap_bootstrap(v);
@


1.175
log
@
Dynamic buffer cache support - a re-commit of what was backed out
after c2k9

allows buffer cache to be extended and grow/shrink dynamically

tested by many, ok oga@@, "why not just commit it" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.174 2009/07/29 18:31:11 kettenis Exp $	*/
a50 3
#ifdef SYSVMSG
#include <sys/msg.h>
#endif
a393 7

#ifdef SYSVMSG
	valloc(msgpool, char, msginfo.msgmax);
	valloc(msgmaps, struct msgmap, msginfo.msgseg);
	valloc(msghdrs, struct msg, msginfo.msgtql);
	valloc(msqids, struct msqid_ds, msginfo.msgmni);
#endif
@


1.174
log
@Get rid of non-equivalent aliases of the pcb by moving the fpu state out
of the pcb and using the p_addr member of 'struct proc' to calculate the
address of the kernel stack when switching to virtual mode after taking a trap.
Remove the now unecessary cache flushes; they're actually harmful since they
create non-equivalent aliases.  This seems to fix the memory corruption we
have been observing from time to time.

This diff does not rename fpu_curpcb, which is now somewhat incorrectly named.
I hope to change things back again as soon as we are able to map the pcb 1:1.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.173 2009/06/15 17:01:25 beck Exp $	*/
a657 6

	/* Restrict to at most 25% filled kvm */
	if (bufpages >
	    (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) / PAGE_SIZE / 4) 
		bufpages = (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) /
		    PAGE_SIZE / 4;
@


1.173
log
@Back out all the buffer cache changes I committed during c2k9. This reverts three
commits:

1) The sysctl allowing bufcachepercent to be changed at boot time.
2) The change moving the buffer cache hash chains to a red-black tree
3) The dynamic buffer cache (Which depended on the earlier too).

ok on the backout from marco and todd
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.172 2009/06/03 21:30:19 beck Exp $	*/
d167 1
d425 2
d1239 4
a1242 5
	pcb->pcb_fpregs[0] = ((u_int64_t)HPPA_FPU_INIT) << 32;
	pcb->pcb_fpregs[1] = 0;
	pcb->pcb_fpregs[2] = 0;
	pcb->pcb_fpregs[3] = 0;
	fdcache(HPPA_SID_KERNEL, (vaddr_t)pcb->pcb_fpregs, 8 * 4);
a1459 2
	    sizeof(ksc.sc_fpregs));
	fdcache(HPPA_SID_KERNEL, (vaddr_t)p->p_addr->u_pcb.pcb_fpregs,
@


1.172
log
@add kern.bufcachepercent sysctl to allow adjusting the buffer cache
size on a running system.
ok art@@, oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.171 2009/02/14 18:51:03 kettenis Exp $	*/
d655 6
@


1.171
log
@Limit the amount of physical memory to 2GB.  Using more causes memory
corruption on PA-RISC 2.0 systems (and there are very few PA-RISC 1.1
systems that support more than 2GB).

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.170 2009/02/04 17:22:23 miod Exp $	*/
a654 6

	/* Restrict to at most 25% filled kvm */
	if (bufpages >
	    (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) / PAGE_SIZE / 4) 
		bufpages = (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) /
		    PAGE_SIZE / 4;
@


1.170
log
@On systems with split BTLB, do not bother trying to insert DBTLB entries,
as PDC will lie to us pretending it did while it didn't.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.169 2009/02/04 17:19:17 miod Exp $	*/
d367 6
d375 4
@


1.169
log
@Unify memory size reports a bit more: always report size in MB, and report
reserved memory on alpha and hppa on its own line (as done on sgi).
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.168 2008/07/14 13:37:39 miod Exp $	*/
d848 1
a848 1
	register int error, i;
d853 32
d889 1
a889 1
	if (len > pdc_btlb.max_size || i < 0) {
d914 2
a915 1
	printf("btlb_insert(%d): %x:%x=%x[%x,%x]\n", i, space, va, pa, len, prot);
@


1.168
log
@Be sure to propagate PSL_O in psw on PCXU* processors to userland processes
and signal handlers.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.167 2008/06/27 17:22:14 miod Exp $	*/
d635 3
a637 2
	printf("real mem = %u (%u reserved for PROM, %u used by OpenBSD)\n",
	    ptoa(physmem), ptoa(resvmem), ptoa(resvphysmem - resvmem));
d666 2
a667 1
	printf("avail mem = %lu\n", ptoa(uvmexp.free));
@


1.167
log
@Clear swap encryption keys before dumping a kernel image.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.166 2008/04/09 16:58:10 deraadt Exp $	*/
a562 2
		extern register_t kpsw;	/* intr.c */

d1427 1
a1427 1
	tf->tf_ipsw = ksc.sc_ps;
@


1.166
log
@Add new stub uvm_shutdown() and call it from the right place in MD boot()
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.166 2008/04/09 16:50:27 deraadt Exp $	*/
d60 1
d1045 4
@


1.165
log
@replace even more ctob and btoc with ptoa and atop respectively plus
uvm_extern.h where needed
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.164 2007/07/22 19:24:45 kettenis Exp $	*/
d921 1
@


1.164
log
@Move hppa to __HAVE_TIMECOUNTERS.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.163 2007/07/20 22:12:39 kettenis Exp $	*/
d368 2
a369 2
	physmem = btoc(avail_end);
	resvmem = btoc(((vaddr_t)&kernel_text));
d637 1
a637 1
	    ctob(physmem), ctob(resvmem), ctob(resvphysmem - resvmem));
d1053 1
a1053 1
		bytes = ctob(physmem);
@


1.163
log
@Give hppa the blink_led API from sparc64, and the associated machdep.led_blink
sysctl.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.162 2007/07/15 19:25:49 kettenis Exp $	*/
a735 25

void
microtime(struct timeval *tv)
{
	extern u_long cpu_itmr;
	u_long itmr, mask;
	int s;

	s = splhigh();
	tv->tv_sec  = time.tv_sec;
	tv->tv_usec = time.tv_usec;

	rsm(PSL_I, mask);
	mfctl(CR_ITMR, itmr);
	itmr -= cpu_itmr;
	ssm(PSL_I, mask);
	splx(s);

	tv->tv_usec += itmr * cpu_ticksdenom / cpu_ticksnum;
	if (tv->tv_usec >= 1000000) {
		tv->tv_usec -= 1000000;
		tv->tv_sec++;
	}
}

@


1.162
log
@Delay switching to the real serial console until we attach the serial device.
The variety of different serial devices is just too big to make a decision up
front.  This should make the second serial port on four-digit B/C/J-class
workstation work as a serial console too.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.161 2007/07/14 22:41:54 kettenis Exp $	*/
d144 2
d177 1
d1617 1
d1638 9
d1664 48
@


1.161
log
@Make sigreturn(2) set the proper space ID for the instruction queue.  Fixes
a few more pthreads regression tests.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.160 2007/07/10 17:28:32 kettenis Exp $	*/
d1648 3
a1650 6
	static int initted;

	if (!initted) {
		initted++;
		cninit();
	}
@


1.160
log
@Don't trust the privilige level in the sigcontext passed to sigreturn(2).

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.159 2007/06/24 17:00:50 kettenis Exp $	*/
d1437 8
@


1.159
log
@Crank initial storage for extents a bit.  We really should allocate extents
using malloc once vm is initialised, but this will do for now.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.158 2007/06/06 17:15:11 deraadt Exp $	*/
d1435 2
a1436 2
	tf->tf_iioq_head = ksc.sc_pcoqh;
	tf->tf_iioq_tail = ksc.sc_pcoqt;
@


1.158
log
@now that all partition size/offsets are potentially 64-bit, change the
type of all variables to daddr64_t.  this includes the APIs for XXsize()
and XXdump(), all range checks inside bio drivers, internal variables
for disklabel handling, and even uvm's swap offsets.  re-read numerous
times by otto, miod, krw, thib to look for errors
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.157 2007/05/27 17:31:56 miod Exp $	*/
d162 1
a162 1
long mem_ex_storage[EXTENT_FIXED_STORAGE_SIZE(32) / sizeof(long)];
@


1.157
log
@Make sure the minaddr hint for uvm_km_suballoc() calls is always initialized.
ok pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.156 2007/05/26 20:26:50 pedro Exp $	*/
d1050 4
a1053 4
	register caddr_t maddr;
	register daddr_t blkno;
	register int (*dump)(dev_t, daddr_t, caddr_t, size_t);
	register int error;
@


1.156
log
@Dynamic buffer cache. Initial diff from mickey@@, okay art@@ beck@@ toby@@
deraadt@@ dlg@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.155 2007/05/21 23:05:44 kettenis Exp $	*/
d653 1
@


1.155
log
@Add support for 8700/pcxw2 cpu.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.154 2007/05/21 23:00:19 kettenis Exp $	*/
a90 6
#ifdef NBUF
int nbuf = NBUF;
#else
int nbuf = 0;
#endif

a379 18
	/* buffer cache parameters */
	if (bufpages == 0)
		bufpages = physmem / 100 *
		    (physmem <= 0x1000? 5 : bufcachepercent);

	if (nbuf == 0)
		nbuf = bufpages < 16? 16 : bufpages;

	/* Restrict to at most 30% filled kvm */
	if (nbuf * MAXBSIZE >
	    (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) * 3 / 10)
		nbuf = (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) /
		    MAXBSIZE * 3 / 10;

	/* More buffer pages than fits into the buffers is senseless. */
	if (bufpages > nbuf * MAXBSIZE / PAGE_SIZE)
		bufpages = nbuf * MAXBSIZE / PAGE_SIZE;

a382 2
	valloc(buf, struct buf, nbuf);

a622 2
	vsize_t size;
	int i, base, residual;
d636 12
a647 33
	size = MAXBSIZE * nbuf;
	minaddr = vm_map_min(kernel_map);
	if (uvm_map(kernel_map, &minaddr, round_page(size),
	    NULL, UVM_UNKNOWN_OFFSET, PAGE_SIZE, UVM_MAPFLAG(UVM_PROT_NONE,
	    UVM_PROT_NONE, UVM_INH_NONE, UVM_ADV_NORMAL, 0)))
		panic("cpu_startup: cannot allocate VM for buffers");
	buffers = (caddr_t)minaddr;
	base = bufpages / nbuf;
	residual = bufpages % nbuf;
	for (i = 0; i < nbuf; i++) {
		vaddr_t curbuf;
		int cbpgs;

		/*
		 * First <residual> buffers get (base+1) physical pages
		 * allocated for them.  The rest get (base) physical pages.
		 *
		 * The rest of each buffer occupies virtual space,
		 * but has no physical memory allocated for it.
		 */
		curbuf = (vaddr_t) buffers + (i * MAXBSIZE);

		for (cbpgs = base + (i < residual? 1 : 0); cbpgs--; ) {
			struct vm_page *pg;

			if ((pg = uvm_pagealloc(NULL, 0, NULL, 0)) == NULL)
				panic("cpu_startup: not enough memory for "
				    "buffer cache");
			pmap_kenter_pa(curbuf, VM_PAGE_TO_PHYS(pg),
			    UVM_PROT_RW);
			curbuf += PAGE_SIZE;
		}
	}
a662 2
	printf("using %d buffers containing %u bytes of memory\n",
	    nbuf, (unsigned)bufpages * PAGE_SIZE);
@


1.154
log
@Ask firmware for reset before trying ourselves; needed for four-digit b/c/j
workstations.

tested by otto@@, krw@@; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.153 2007/05/17 14:24:59 art Exp $	*/
d270 4
@


1.153
log
@Limit hppa buffer cache to 30%. It used to be 70% because stack garbage
that was used for minaddr instead of the proper vm_map_min(kernel_map)
(fixed in this diff).

From mickey. art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.152 2007/05/14 19:54:21 martin Exp $	*/
d1016 5
@


1.152
log
@move hppa to __HAVE_CPUINFO

input from miod@@, ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.151 2006/05/28 23:08:07 martin Exp $	*/
d390 1
a390 1
	/* Restrict to at most 70% filled kvm */
d392 1
a392 1
	    (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) * 7 / 10)
d394 1
a394 1
		    MAXBSIZE * 7 / 10;
d661 1
d663 1
a663 1
	    NULL, UVM_UNKNOWN_OFFSET, 0, UVM_MAPFLAG(UVM_PROT_NONE,
@


1.151
log
@minor nit, use CPU ID instead of FPU ID for BTLB parameters after passing
all kludges
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.150 2006/04/15 15:35:20 martin Exp $	*/
d127 1
@


1.150
log
@make warning about missing HPT support DEBUG for now

ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.149 2005/10/26 18:35:44 martin Exp $	*/
d498 1
a498 1
	if (cpu_type < HPPA_FPU_PCXU &&
@


1.149
log
@no more hppa_round_page() and hppa_trunc_page() macros

ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.148 2005/08/06 14:26:52 miod Exp $	*/
d534 1
d536 1
@


1.148
log
@We do not need a char machine_arch[] constant.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.147 2005/07/11 04:04:30 mickey Exp $	*/
d399 1
a399 1
	v1 = v = hppa_round_page(start);
d411 1
a411 1
	v = hppa_round_page(v);
@


1.147
log
@align some stupid comments
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.146 2005/05/10 11:23:39 mickey Exp $	*/
d139 1
a139 1
char	machine[] = MACHINE_ARCH;
@


1.146
log
@set pcsq in case we get signal delivery once interrupted from the gateway page; from chs
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.145 2005/04/18 12:16:03 mickey Exp $	*/
d1459 4
a1462 4
	tf->tf_arg3 = ksc.sc_regs[24];	/* r23 */
	tf->tf_arg2 = ksc.sc_regs[25];	/* r24 */
	tf->tf_arg1 = ksc.sc_regs[26];	/* r25 */
	tf->tf_arg0 = ksc.sc_regs[27];	/* r26 */
@


1.145
log
@do not do some of the initmsgbuf()s job
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.144 2005/04/07 13:16:12 mickey Exp $	*/
d1270 1
d1365 1
@


1.144
log
@on some machines it's possible to limit the amount of physmem initialised dring post so having msgbuf at the end of memory shall work
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.143 2005/04/07 00:21:51 mickey Exp $	*/
d418 2
a419 3
	msgbufp = (struct msgbuf *)(ptoa(physmem) - round_page(MSGBUFSIZE));
	initmsgbuf((caddr_t)msgbufp, round_page(MSGBUFSIZE));
	msgbufmapped = 1;
@


1.143
log
@64bit-friendly pdc.h and iomod.h and correspondent changes elsewhere
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.142 2005/03/26 20:04:37 mickey Exp $	*/
a413 4
	msgbufp = (struct msgbuf *)v;
	v += round_page(MSGBUFSIZE);
	bzero(msgbufp, MSGBUFSIZE);

d417 3
a420 1
	initmsgbuf((caddr_t)msgbufp, round_page(MSGBUFSIZE));
@


1.142
log
@md parts for hpux_compa code; some problems w/ signals delivery still exist
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.141 2005/02/24 17:20:53 mickey Exp $	*/
d342 1
a342 1
		PAGE0->ivec_toc = (int (*)(void))hppa_toc;
d354 1
a354 1
		PAGE0->ivec_mempf = (int (*)(void))hppa_pfr;
d1011 1
a1011 1
		    :: "r" (CMD_STOP), "r" (LBCAST_ADDR + iomod_command));
d1018 1
a1018 1
		    :: "r" (CMD_RESET), "r" (LBCAST_ADDR + iomod_command));
@


1.141
log
@do not even ask for btlb on 8k cpus as pdc pretends there is some but then it does not work; found w/ Moritz Kiese <mbk@@mytum.de> on c180; add a debug print and fix pcxu entry
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.140 2004/11/17 16:06:50 mickey Exp $	*/
d73 4
d1276 1
a1276 1
	register_t scp, sip, zero;
d1314 1
a1314 1
		printf("sendsig: interrupted syscall at 0x%x:0x%x, flags %b\n",
d1384 1
a1384 2
	zero = 0;
	if (copyout(&zero, (caddr_t)scp + sss - HPPA_FRAME_SIZE,
d1387 1
d1391 1
a1391 1
		printf("sendsig(%d): pc 0x%x, catcher 0x%x\n", p->p_pid,
d1483 143
@


1.140
log
@print real/avail/bufcache sizes as unsigned
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.139 2004/10/26 20:18:01 mickey Exp $	*/
d257 1
a257 1
	  4, desidhash_u, ibtlb_u, NULL, pbtlb_g },
d497 3
a499 2
	if ((error = pdc_call((iodcio_t)pdc, 0, PDC_BLOCK_TLB,
	    PDC_BTLB_DEFAULT, &pdc_btlb)) < 0) {
d632 3
@


1.139
log
@disable sid hashing on pcxu and above
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.138 2004/10/14 18:30:49 mickey Exp $	*/
d649 1
a649 1
	printf("real mem = %d (%d reserved for PROM, %d used by OpenBSD)\n",
d698 3
a700 3
	printf("avail mem = %ld\n", ptoa(uvmexp.free));
	printf("using %d buffers containing %d bytes of memory\n",
	    nbuf, bufpages * PAGE_SIZE);
@


1.138
log
@a bit larger delays during boot() to let msgs appear
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.137 2004/09/19 01:30:11 mickey Exp $	*/
a221 1
int desidhash_g(void);
d257 1
a257 1
	  4, desidhash_g, ibtlb_u, NULL, pbtlb_g },
d261 1
a261 1
	  4, desidhash_g, ibtlb_u, NULL, pbtlb_u },
d265 1
a265 1
	  4, desidhash_g, ibtlb_u, NULL, pbtlb_u },
a857 8
}

int
desidhash_g(void)
{
	/* TODO call PDC to disable SID hashing in the cache index */

	return 0;
@


1.137
log
@turn totalphysmem into physmem and name old physmem into smth it really is
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.136 2004/09/18 05:06:17 mickey Exp $	*/
d1004 1
a1004 1
			DELAY(1000000);
d1010 1
a1010 1
		DELAY(1000000);
d1015 1
a1015 1
		DELAY(1000000);
@


1.136
log
@oops
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.135 2004/09/15 21:32:43 mickey Exp $	*/
d156 1
a156 1
int	totalphysmem, resvmem, physmem, esym;
d363 1
a363 1
	totalphysmem = btoc(avail_end);
d380 2
a381 2
		bufpages = totalphysmem / 100 *
		    (totalphysmem <= 0x1000? 5 : bufcachepercent);
d415 1
a415 1
	/* sets physmem */
d651 1
a651 1
	    ctob(totalphysmem), ctob(resvmem), ctob(physmem - resvmem));
d1116 1
a1116 1
		bytes = ctob(totalphysmem);
@


1.135
log
@add pcxu tlb handlers and cpu probing
add u2/uturn ioa driver in dumb mode now
enable pcxu/pcxw support
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.134 2004/09/14 23:39:32 mickey Exp $	*/
d1277 1
a1277 1
	register_t scp, sip;
@


1.134
log
@store fpu version for later use. make sure to proper store/clear fpu state in fork/exec/exit/sendsig
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.133 2004/09/14 22:37:16 mickey Exp $	*/
d199 1
d208 2
d213 1
d215 1
d221 1
d257 2
a258 2
	{ "PCXU",  hpcxu, HPPA_CPU_PCXU, HPPA_FTRS_W32B|HPPA_FTRS_BTLBU,
	  4, desidhash_g, ibtlb_g, NULL, pbtlb_g, hpti_g},
d261 2
a262 2
	{ "PCXU+", hpcxu2,HPPA_CPU_PCXUP, HPPA_FTRS_W32B|HPPA_FTRS_BTLBU,
	  4, desidhash_g, ibtlb_g, NULL, pbtlb_g, hpti_g},
d265 2
a266 2
	{ "PCXW",  hpcxw, HPPA_CPU_PCXW, HPPA_FTRS_W32B|HPPA_FTRS_BTLBU,
	  4, desidhash_g, ibtlb_g, NULL, pbtlb_g, hpti_g},
d486 3
a488 2
		printf("pdc_coproc: 0x%x, 0x%x\n", pdc_coproc.ccr_enable,
		    pdc_coproc.ccr_present);
d491 4
d573 7
@


1.133
log
@error out from btlb_insert() if there is none
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.132 2004/07/01 21:03:32 mickey Exp $	*/
d140 1
d355 2
a356 2
	/*if (avail_end > 32*1024*1024)
		avail_end = 32*1024*1024;*/
d1228 4
d1237 1
a1237 5
	if (tf->tf_cr30 == fpu_curpcb) {
		fpu_curpcb = 0;
		/* force an fpu ctxsw, we won't be hugged by the cpu_switch */
		mtctl(0, CR_CCR);
	}
d1253 1
d1259 1
a1260 1
	register_t zero, scp, sip;
d1270 1
d1272 2
a1273 1
		fpu_curpcb = 0;
d1401 1
a1401 1
		fpu_save(fpu_curpcb);
d1481 1
d1498 1
@


1.132
log
@have separate insn and data cache all-flushers
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.131 2004/06/30 18:18:54 mickey Exp $	*/
d897 3
@


1.131
log
@allow forced fpu emulation through a sysctl
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.130 2004/05/13 15:09:19 mickey Exp $	*/
d350 2
a351 1
	fcacheall();
d422 2
a423 1
	fcacheall();
d793 1
a793 1
fcacheall(void)
d801 5
@


1.130
log
@8ks do not have hvt
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.129 2004/05/05 02:18:43 mickey Exp $	*/
d439 1
d473 1
a473 1
	    &pdc_coproc, 0, 0, 0, 0)) < 0)
d475 2
a476 1
	else {
d480 1
d533 1
a533 1
	} else if ((p->type == hpcxl || p->type == hpcxl2) && !fpu_enable)
d536 2
d1224 1
a1224 1
		/* force an fpu ctxsw, we'll not be hugged by the cpu_switch */
a1226 1

d1466 2
d1469 1
d1481 7
@


1.129
log
@much easier tlb handler branch patching
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.128 2004/05/05 00:32:17 mickey Exp $	*/
d250 1
a250 1
	{ "PCXU",  hpcxu, HPPA_CPU_PCXU, HPPA_FTRS_W32B|HPPA_FTRS_BTLBU|HPPA_FTRS_HVT,
d254 1
a254 1
	{ "PCXU+", hpcxu2,HPPA_CPU_PCXUP, HPPA_FTRS_W32B|HPPA_FTRS_BTLBU|HPPA_FTRS_HVT,
d258 1
a258 1
	{ "PCXW",  hpcxw, HPPA_CPU_PCXW, HPPA_FTRS_W32B|HPPA_FTRS_BTLBU|HPPA_FTRS_HVT,
@


1.128
log
@do not engage HPT on PCXT' (yet)
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.127 2004/04/08 17:10:18 mickey Exp $	*/
d221 8
a228 8
	int (*desidhash)(void);
	const u_int *itlbh, *itlbnah, *dtlbh, *dtlbnah, *tlbdh;
	int (*dbtlbins)(int i, pa_space_t sp, vaddr_t va, paddr_t pa,
	    vsize_t sz, u_int prot);
	int (*ibtlbins)(int i, pa_space_t sp, vaddr_t va, paddr_t pa,
	    vsize_t sz, u_int prot);
	int (*btlbprg)(int i);
	int (*hptinit)(vaddr_t hpt, vsize_t hptsize);
d231 1
a231 3
	{ "PCXS",  hpcxs,  0, 0,
	  desidhash_s, itlb_s, itlbna_s, dtlb_s, dtlbna_s, tlbd_s,
	  ibtlb_g, NULL, pbtlb_g},
d235 1
a235 2
	  desidhash_t, itlb_t, itlbna_t, dtlb_t, dtlbna_t, tlbd_t,
	  ibtlb_g, NULL, pbtlb_g},
d239 1
a239 2
	  desidhash_t, itlb_t, itlbna_t, dtlb_t, dtlbna_t, tlbd_t,
	  ibtlb_g, NULL, pbtlb_g},
d243 1
a243 2
	  desidhash_l, itlb_l, itlbna_l, dtlb_l, dtlbna_l, tlbd_l,
	  ibtlb_g, NULL, pbtlb_g, hpti_g},
d247 1
a247 2
	  desidhash_l, itlb_l, itlbna_l, dtlb_l, dtlbna_l, tlbd_l,
	  ibtlb_g, NULL, pbtlb_g, hpti_g},
d251 1
a251 2
	  desidhash_g, itlb_l, itlbna_l, dtlb_l, dtlbna_l, tlbd_l,
	  ibtlb_g, NULL, pbtlb_g, hpti_g},
d255 1
a255 2
	  desidhash_g, itlb_l, itlbna_l, dtlb_l, dtlbna_l, tlbd_l,
	  ibtlb_g, NULL, pbtlb_g, hpti_g},
d259 1
a259 2
	  desidhash_g, itlb_l, itlbna_l, dtlb_l, dtlbna_l, tlbd_l,
	  ibtlb_g, NULL, pbtlb_g, hpti_g},
d547 8
a554 7
#define	LDILDO(t,f) ((t)[0] = (f)[0], (t)[1] = (f)[1])
	LDILDO(trap_ep_T_TLB_DIRTY , p->tlbdh);
	LDILDO(trap_ep_T_DTLBMISS  , p->dtlbh);
	LDILDO(trap_ep_T_DTLBMISSNA, p->dtlbnah);
	LDILDO(trap_ep_T_ITLBMISS  , p->itlbh);
	LDILDO(trap_ep_T_ITLBMISSNA, p->itlbnah);
#undef LDILDO
@


1.127
log
@repair pcxs/t confoosion
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.126 2004/04/07 18:24:19 mickey Exp $	*/
d542 6
@


1.126
log
@update copyright; miod@@ is fine w/ files where he holds it too
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.125 2004/03/10 23:02:53 tom Exp $	*/
d231 1
a231 1
	{ "PCXS",  hpcx,  0, 0,
d236 1
a236 1
	{ "PCXT",  hpcxs, 0, HPPA_FTRS_BTLBU,
d242 1
a242 1
	  desidhash_t, itlb_t, itlbna_l, dtlb_t, dtlbna_t, tlbd_t,
@


1.125
log
@Ensure that we obey a user's ddb> boot reboot command even if the system
is cold (during startup).

This adds RB_USERREQ to sys/reboot.h, uses it in the ddb commands, and
ensures that */*/machdep.c:boot() won't set RB_HALT when cold if this
flag is set.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.124 2004/02/14 15:09:22 grange Exp $	*/
d4 1
a4 1
 * Copyright (c) 1999-2002 Michael Shalayeff
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Michael Shalayeff.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.124
log
@Simplify hw.{cpuspeed,setperf} api moving all the sysctl stuff
from the underlying callbacks.

Testing hppa mickey@@, ppc drahn@@
Ok markus@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.123 2004/01/05 17:07:00 mickey Exp $	*/
d938 5
a942 3
	if (cold)
		howto |= RB_HALT;
	else {
@


1.123
log
@kill debugging code that is not needed anymore
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.122 2003/12/23 23:47:07 mickey Exp $	*/
d279 1
a279 1
hppa_cpuspeed(void *oldp, size_t *oldlenp, void *newp, size_t newlen)
d281 1
a281 1
	int mhz = PAGE0->mem_10msec / 10000;
d283 1
a283 1
	return sysctl_rdint(oldp, oldlenp, newp, mhz);
@


1.122
log
@provide cpuspeed fluff
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.121 2003/12/20 16:13:53 miod Exp $	*/
a620 6
#ifdef DEBUG
	extern int pmapdebug;
	int opmapdebug = pmapdebug;

	pmapdebug = 0;
#endif
a679 3
#ifdef DEBUG
	pmapdebug = opmapdebug;
#endif
d1200 1
a1200 7
#ifdef DEBUG
	/*extern int pmapdebug;*/
	/*pmapdebug = 13;
	printf("setregs(%p, %p, 0x%x, %p), ep=0x%x, cr30=0x%x\n",
	    p, pack, stack, retval, pack->ep_entry, tf->tf_cr30);
	*/
#endif
@


1.121
log
@Don't let microtime() return a struct timeval with exactly 1000000 microseconds.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.120 2003/12/18 08:05:20 mickey Exp $	*/
d278 8
d431 1
@


1.120
log
@spls do not protect cpu_itmr and thus time might jump back sometimes due to cpu_itmr modified to a higher value than a read itmr; found and testing by miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.119 2003/12/17 05:46:37 mickey Exp $	*/
d771 1
a771 1
	if (tv->tv_usec > 1000000) {
@


1.119
log
@in the real mem print do not include reserved for prom into used by openbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.118 2003/12/10 20:57:32 mickey Exp $	*/
d757 1
a757 1
	u_long itmr;
d764 1
d767 1
@


1.118
log
@for unaligned btlb mapping attempts -- just fail
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.117 2003/11/24 19:27:03 mickey Exp $	*/
d629 1
a629 1
	    ctob(totalphysmem), ctob(resvmem), ctob(physmem));
@


1.117
log
@experimental support for HVT as a 2nd level tlb
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.116 2003/10/15 18:54:55 mickey Exp $	*/
d907 2
a908 1
	if (pa & (len - 1))
d911 3
@


1.116
log
@less global name space pollution
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.115 2003/10/05 14:13:28 mickey Exp $	*/
d253 1
a253 1
	  ibtlb_g, NULL, pbtlb_g, hpti_l},
d258 1
a258 1
	  ibtlb_g, NULL, pbtlb_g, hpti_l},
d514 1
a514 1
	    pdc_hwtlb.min_size && pdc_hwtlb.max_size)
d516 5
a520 1
	else {
@


1.115
log
@reload the itmr as soon as we get the intr to avoid lagging on slower machines
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.114 2003/09/25 22:20:44 mickey Exp $	*/
d282 1
a282 1
	extern u_int cpu_hzticks;
d752 2
a753 1
	u_int itmr;
@


1.114
log
@some pcxl2 do not report fpus -- assume it's there
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.113 2003/09/04 07:02:37 mickey Exp $	*/
d137 1
a137 1
u_int	cpu_itmr, cpu_ticksnum, cpu_ticksdenom, cpu_hzticks;
d282 1
@


1.113
log
@a better cpu identification; testing by miod
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.112 2003/08/31 00:23:16 miod Exp $	*/
d530 2
a531 2
	} else if (p->type == hpcxl && !fpu_enable)
		/* we know PCXL does not exist w/o FPU */
@


1.112
log
@pdc_model needs to be visible from cpu.c
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.111 2003/08/20 03:15:44 mickey Exp $	*/
d179 1
d188 1
d224 1
a224 1
	int  arch;
d236 1
a236 1
	{ "PCXS",   hpcx,  0x10, 0,
d241 1
a241 1
	{ "PCXT",  hpcxs, 0x11, HPPA_FTRS_BTLBU,
d246 1
a246 2
/* these seem to support the cpu model pdc call */
/* HOW?	{ "PCXT'", hpcxta,0x11, HPPA_FTRS_BTLBU,
d248 1
a248 1
	  ibtlb_g, NULL, pbtlb_g}, */
d251 1
a251 1
	{ "PCXL",  hpcxl, 0x11, HPPA_FTRS_BTLBU|HPPA_FTRS_HVT,
d256 1
a256 1
/* HOW?	{ "PCXL2", hpcxl2,0x11, HPPA_FTRS_BTLBU|HPPA_FTRS_HVT,
d258 1
a258 1
	  ibtlb_g, NULL, pbtlb_g, hpti_l}, */
d261 1
a261 1
	{ "PCXU",  hpcxu, 0x20, HPPA_FTRS_W32B|HPPA_FTRS_BTLBU|HPPA_FTRS_HVT,
d266 1
a266 1
/* HOW?	{ "PCXU2", hpcxu2,0x20, HPPA_FTRS_W32B|HPPA_FTRS_BTLBU|HPPA_FTRS_HVT,
d268 1
a268 1
	  ibtlb_g, NULL, pbtlb_g, hpti_g}, */
d271 1
a271 1
/* HOW?	{ "PCXW",  hpcxw, 0x20, HPPA_FTRS_W32B|HPPA_FTRS_BTLBU|HPPA_FTRS_HVT,
d273 1
a273 6
	  ibtlb_g, NULL, pbtlb_g, hpti_g}, */
#endif
#ifdef HP8600_CPU
/* HOW?	{ "PCXW+", hpcxw, 0x20, HPPA_FTRS_W32B|HPPA_FTRS_BTLBU|HPPA_FTRS_HVT,
	  desidhash_g, itlb_l, itlbna_l, dtlb_l, dtlbna_l, tlbd_l,
	  ibtlb_g, NULL, pbtlb_g, hpti_g}, */
d284 1
a284 1
	int error, cpu_features = 0;
d353 95
d450 1
d461 23
a511 8
	ptlball();
	fcacheall();

	totalphysmem = btoc(PAGE0->imm_max_mem);
	resvmem = btoc(((vaddr_t)&kernel_text));
	avail_end = ctob(totalphysmem);

#if defined(HP7100LC_CPU) || defined(HP7300LC_CPU)
a518 7
#endif

	/*
	 * Deal w/ CPU now
	 */
	{
		const struct hppa_cpu_typed *p;
d520 3
d524 1
a524 1
		    p->arch && p->features != cpu_features; p++);
d526 14
a539 24
		if (!p->arch) {
			printf("WARNING: UNKNOWN CPU TYPE; GOOD LUCK (%x)\n",
			    cpu_features);
			p = cpu_types;
		}

		{
			/*
			 * Ptrs to various tlb handlers, to be filled
			 * based on cpu features.
			 * from locore.S
			 */
			extern u_int trap_ep_T_TLB_DIRTY[];
			extern u_int trap_ep_T_DTLBMISS[];
			extern u_int trap_ep_T_DTLBMISSNA[];
			extern u_int trap_ep_T_ITLBMISS[];
			extern u_int trap_ep_T_ITLBMISSNA[];

			cpu_type = p->type;
			cpu_typename = p->name;
			cpu_ibtlb_ins = p->ibtlbins;
			cpu_dbtlb_ins = p->dbtlbins;
			cpu_hpt_init = p->hptinit;
			cpu_desidhash = p->desidhash;
d542 5
a546 5
			LDILDO(trap_ep_T_TLB_DIRTY , p->tlbdh);
			LDILDO(trap_ep_T_DTLBMISS  , p->dtlbh);
			LDILDO(trap_ep_T_DTLBMISSNA, p->dtlbnah);
			LDILDO(trap_ep_T_ITLBMISS  , p->itlbh);
			LDILDO(trap_ep_T_ITLBMISSNA, p->itlbnah);
a547 2
		}
	}
a598 78

	/* we hope this won't fail */
	hppa_ex = extent_create("mem", 0x0, 0xffffffff, M_DEVBUF,
	    (caddr_t)mem_ex_storage, sizeof(mem_ex_storage),
	    EX_NOCOALESCE|EX_NOWAIT);
	if (extent_alloc_region(hppa_ex, 0, (vaddr_t)PAGE0->imm_max_mem,
	    EX_NOWAIT))
		panic("cannot reserve main memory");

	/*
	 * Now allocate kernel dynamic variables
	 */

	/* buffer cache parameters */
	if (bufpages == 0)
		bufpages = totalphysmem / 100 *
		    (totalphysmem <= 0x1000? 5 : bufcachepercent);

	if (nbuf == 0)
		nbuf = bufpages < 16? 16 : bufpages;

	/* Restrict to at most 70% filled kvm */
	if (nbuf * MAXBSIZE >
	    (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) * 7 / 10)
		nbuf = (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) /
		    MAXBSIZE * 7 / 10;

	/* More buffer pages than fits into the buffers is senseless. */
	if (bufpages > nbuf * MAXBSIZE / PAGE_SIZE)
		bufpages = nbuf * MAXBSIZE / PAGE_SIZE;

	v1 = v = hppa_round_page(start);
#define valloc(name, type, num) (name) = (type *)v; v = (vaddr_t)((name)+(num))

	valloc(buf, struct buf, nbuf);

#ifdef SYSVMSG
	valloc(msgpool, char, msginfo.msgmax);
	valloc(msgmaps, struct msgmap, msginfo.msgseg);
	valloc(msghdrs, struct msg, msginfo.msgtql);
	valloc(msqids, struct msqid_ds, msginfo.msgmni);
#endif
#undef valloc

	v = hppa_round_page(v);
	bzero ((void *)v1, (v - v1));

	msgbufp = (struct msgbuf *)v;
	v += round_page(MSGBUFSIZE);
	bzero(msgbufp, MSGBUFSIZE);

	/* sets physmem */
	pmap_bootstrap(v);

	msgbufmapped = 1;
	initmsgbuf((caddr_t)msgbufp, round_page(MSGBUFSIZE));

	/* locate coprocessors and SFUs */
	if ((error = pdc_call((iodcio_t)pdc, 0, PDC_COPROC, PDC_COPROC_DFLT,
	    &pdc_coproc)) < 0)
		printf("WARNING: PDC_COPROC error %d\n", error);
	else {
		extern u_int fpu_enable;
#ifdef DEBUG
		printf("pdc_coproc: %x, %x\n", pdc_coproc.ccr_enable,
		    pdc_coproc.ccr_present);
#endif
		fpu_enable = pdc_coproc.ccr_enable & CCR_MASK;
	}

	/* they say PDC_COPROC might turn fault light on */
	pdc_call((iodcio_t)pdc, 0, PDC_CHASSIS, PDC_CHASSIS_DISP,
	    PDC_OSTAT(PDC_OSTAT_RUN) | 0xCEC0);

#ifdef DDB
	ddb_init();
#endif
	fcacheall();
@


1.111
log
@missing nl in debugging prontf
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.110 2003/08/07 19:54:14 mickey Exp $	*/
d134 1
a285 1
	struct pdc_model pdc_model PDC_ALIGNMENT;
@


1.110
log
@dead proto
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.109 2003/08/07 19:26:19 mickey Exp $	*/
d373 1
a373 1
		printf("WARNING: PDC_BTLB error %d", error);
@


1.109
log
@first allocate space on stack then copyout signal shits. add a DEBUG check for a whacky user pc (as impossible due to the recent trap.c change)
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.108 2003/08/03 18:55:04 mickey Exp $	*/
a177 1
void hppa_user2frame(struct trapframe *sf, struct trapframe *tf);
@


1.108
log
@clear branch and nullify bits in psw on sending a signal
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.107 2003/07/30 21:24:19 mickey Exp $	*/
d1228 2
a1229 2
	struct sigcontext ksc, *scp;
	siginfo_t ksi, *sip;
d1231 1
a1231 1
	register_t zero;
d1252 1
a1252 1
		scp = (struct sigcontext *)psp->ps_sigstk.ss_sp;
d1255 1
a1255 1
		scp = (struct sigcontext *)tf->tf_sp;
d1257 2
a1258 2
	sss = sizeof(*scp);
	sip = NULL;
d1260 2
a1261 5
		initsiginfo(&ksi, sig, code, type, val);
		sip = (siginfo_t *)(scp + 1);
		if (copyout((caddr_t)&ksi, sip, sizeof(ksi)))
			sigexit(p, SIGILL);
		sss += sizeof(*sip);
d1264 6
d1271 1
a1271 1
	ksc.sc_fp = (register_t)scp + sss;
a1308 2
	if (copyout((caddr_t)&ksc, scp, sizeof(*scp)))
		sigexit(p, SIGILL);
d1311 9
a1319 6
	zero = 0;
	if (copyout(&zero, (caddr_t)scp + sss - HPPA_FRAME_SIZE,
	    sizeof(register_t)) ||
	    copyout(&zero, (caddr_t)scp + sss + HPPA_FRAME_CRP,
	    sizeof(register_t)))
		sigexit(p, SIGILL);
d1327 13
a1339 9
	tf->tf_arg0 = sig;
	tf->tf_arg1 = (register_t)sip;
	tf->tf_arg2 = tf->tf_r3 = (register_t)scp;
	tf->tf_arg3 = (register_t)catcher;
	tf->tf_sp = (register_t)scp + sss;
	tf->tf_ipsw &= ~(PSL_B | PSL_N);
	tf->tf_iioq_head = HPPA_PC_PRIV_USER | p->p_sigcode;
	tf->tf_iioq_tail = tf->tf_iioq_head + 4;
	/* disable tracing in the trapframe */
d1425 2
a1426 2
	tf->tf_iioq_head = ksc.sc_pcoqh | HPPA_PC_PRIV_USER;
	tf->tf_iioq_tail = ksc.sc_pcoqt | HPPA_PC_PRIV_USER;
@


1.107
log
@deduce the leds address from the model number and thus make some more use of that lichtenblinkenschmutz on some more machinens
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.106 2003/05/22 19:27:50 mickey Exp $	*/
d1328 1
@


1.106
log
@imprecision in delay_init()
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.105 2003/05/18 15:57:46 mickey Exp $	*/
d143 1
d462 1
a462 1
		int lev, hv;
d465 2
a466 2
		hv = pdc_model.hvers >> 4;
		if (!hv) {
d470 1
a470 1
			p = hppa_mod_info(HPPA_TYPE_BOARD, hv);
d472 2
a473 1
				snprintf(buf, sizeof buf, "(UNKNOWN 0x%x)", hv);
@


1.105
log
@save the fpu state for the signal handler. this is essential
as the fpu regs can be used by the gcc even for non-fpu
means and data copying.
rearrange the sigcontext a bit to include only the general
registers that are needed restoring upon return and thus
less waste of space and make up some space for the fpu regs.

ALL software that used the signal context on the stack
needs at least rebuilding now. a new snap has bin built as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.104 2003/05/11 19:41:09 deraadt Exp $	*/
d704 1
@


1.104
log
@string cleaning; krw ok
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.103 2003/04/07 16:20:38 mickey Exp $	*/
d1176 1
a1176 1
	printf("setregs(%p, %p, %x, %p), ep=%x, cr30=%x\n",
d1221 1
d1236 6
a1264 1
	ksc.sc_sp = tf->tf_sp;
d1269 34
a1302 1
	bcopy(tf, &ksc.sc_tf, sizeof(ksc.sc_tf));
d1316 2
a1317 2
		printf("sendsig(%d): sig %d scp %p fp %p sp %x\n",
		    p->p_pid, sig, scp, ksc.sc_fp, ksc.sc_sp);
a1328 2
	/* TODO FPU */

d1331 1
a1331 1
		printf("sendsig(%d): pc %x, catcher %x\n", p->p_pid,
d1342 1
d1356 6
d1376 36
a1411 1
	hppa_user2frame((struct trapframe *)&ksc.sc_tf, tf);
a1412 1
	tf->tf_sp = ksc.sc_sp;
a1416 2
	/* TODO FPU */

a1421 40
}

void
hppa_user2frame(sf, tf)
	struct trapframe *sf, *tf;
{
	/* only restore r1-r31, sar */
	tf->tf_t1 = sf->tf_t1;		/* r22 */
	tf->tf_t2 = sf->tf_t2;		/* r21 */
	tf->tf_sp = sf->tf_sp;
	tf->tf_t3 = sf->tf_t3;		/* r20 */

	tf->tf_sar = sf->tf_sar;
	tf->tf_r1 = sf->tf_r1;
	tf->tf_rp = sf->tf_rp;
	tf->tf_r3 = sf->tf_r3;
	tf->tf_r4 = sf->tf_r4;
	tf->tf_r5 = sf->tf_r5;
	tf->tf_r6 = sf->tf_r6;
	tf->tf_r7 = sf->tf_r7;
	tf->tf_r8 = sf->tf_r8;
	tf->tf_r9 = sf->tf_r9;
	tf->tf_r10 = sf->tf_r10;
	tf->tf_r11 = sf->tf_r11;
	tf->tf_r12 = sf->tf_r12;
	tf->tf_r13 = sf->tf_r13;
	tf->tf_r14 = sf->tf_r14;
	tf->tf_r15 = sf->tf_r15;
	tf->tf_r16 = sf->tf_r16;
	tf->tf_r17 = sf->tf_r17;
	tf->tf_r18 = sf->tf_r18;
	tf->tf_t4 = sf->tf_t4;		/* r19 */
	tf->tf_arg3 = sf->tf_arg3;	/* r23 */
	tf->tf_arg2 = sf->tf_arg2;	/* r24 */
	tf->tf_arg1 = sf->tf_arg1;	/* r25 */
	tf->tf_arg0 = sf->tf_arg0;	/* r26 */
	tf->tf_dp = sf->tf_dp;
	tf->tf_ret0 = sf->tf_ret0;
	tf->tf_ret1 = sf->tf_ret1;
	tf->tf_r31 = sf->tf_r31;
@


1.103
log
@s/HP9000/HP 9000/; from weissmanndude
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.102 2003/02/18 19:01:50 deraadt Exp $	*/
d471 1
a471 1
				sprintf(buf, "(UNKNOWN 0x%x)", hv);
d504 2
a505 1
		sprintf(cpu_model, "HP 9000/%s PA-RISC %s%x", p, q, lev);
@


1.102
log
@knf; mickey ok
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.101 2003/02/12 21:33:40 jason Exp $	*/
d504 1
a504 1
		sprintf(cpu_model, "HP9000/%s PA-RISC %s%x", p, q, lev);
@


1.101
log
@How uncommon... hppa only has one common: msgbufmapped (decl'd in /sys/kern)
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.100 2003/02/12 05:30:47 mickey Exp $	*/
d421 1
a421 1
		     p->arch && p->features != cpu_features; p++);
d441 2
a442 2
			cpu_type      = p->type;
			cpu_typename  = p->name;
d445 1
a445 1
			cpu_hpt_init  = p->hptinit;
d536 1
a536 1
	
d587 1
a587 1
cpu_startup()
d769 1
a769 1
fcacheall()
d783 1
a783 1
ptlball()
d814 1
a814 1
desidhash_g()
d977 1
a977 1
cpu_dumpsize()
d992 1
a992 1
hpmc_dump()
d1001 1
a1001 1
cpu_dump()
d1031 1
a1031 1
dumpsys()
d1065 1
a1065 1
		
d1269 1
a1269 1
	      sizeof(register_t)) ||
d1271 1
a1271 1
	      sizeof(register_t)))
d1424 1
a1424 1
consinit()
@


1.100
log
@only align the first stack frame onto the minimal required alignment
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.99 2003/02/10 15:47:02 mickey Exp $	*/
d112 2
a113 2
int cold = 1;		/* unset when engine is up to go */
int msgbufmapped;	/* set when safe to use msgbuf */
@


1.99
log
@fix pcs and pcxt recognition. from weissmanndude
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.98 2003/01/22 18:16:34 mickey Exp $	*/
d1187 1
a1187 1
	stack = hppa_round_page(stack);
@


1.98
log
@consistantly use uvm_prot_* vs vm_prot_* evewrhere
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.97 2003/01/14 16:06:53 mickey Exp $	*/
d233 2
a234 2
	{ "PCX",   hpcx,  0x10, 0,
	  desidhash_x, itlb_x, itlbna_x, dtlb_x, dtlbna_x, tlbd_x,
d238 2
a239 2
	{ "PCXS",  hpcxs, 0x11, 0,
	  desidhash_s, itlb_s, itlbna_s, dtlb_s, dtlbna_s, tlbd_s,
d243 1
a243 3
	{ "PCXT",  hpcxt, 0x11, HPPA_FTRS_BTLBU,
	  desidhash_t, itlb_t, itlbna_t, dtlb_t, dtlbna_t, tlbd_t,
	  ibtlb_g, NULL, pbtlb_g},
@


1.97
log
@fix cutnpaste in the cpu table for the itlbna field; from herr weissmanndude
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.96 2003/01/14 12:17:07 mickey Exp $	*/
d641 1
a641 1
			    VM_PROT_READ|VM_PROT_WRITE);
@


1.96
log
@need pdc_hwtlb always; pt out by herr weissmanndude
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.95 2003/01/13 19:53:34 mickey Exp $	*/
d234 1
a234 1
	  desidhash_x, itlb_x, itlbna_l, dtlb_x, dtlbna_x, tlbd_x,
d239 1
a239 1
	  desidhash_s, itlb_s, itlbna_l, dtlb_s, dtlbna_s, tlbd_s,
d244 1
a244 1
	  desidhash_t, itlb_t, itlbna_l, dtlb_t, dtlbna_t, tlbd_t,
@


1.95
log
@fix the logic in hvt probing
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.94 2003/01/09 22:27:09 miod Exp $	*/
a181 1
#if defined(HP7100LC_CPU) || defined(HP7300LC_CPU)
a182 1
#endif
@


1.94
log
@Remove fetch(9) and store(9) functions from the kernel, and replace the few
remaining instances of them with appropriate copy(9) usage.

ok art@@, tested on all arches unless my memory is non-ECC
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.93 2002/12/19 00:46:21 mickey Exp $	*/
d409 4
a412 2
	if (pdc_call((iodcio_t)pdc, 0, PDC_TLB, PDC_TLB_INFO, &pdc_hwtlb) &&
	    !pdc_hwtlb.min_size && !pdc_hwtlb.max_size) {
d415 1
a415 2
	} else
		cpu_features |= HPPA_FTRS_HVT;
@


1.93
log
@setregs: put the whole frame setup into one place
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.92 2002/12/19 00:41:20 mickey Exp $	*/
d1166 1
a1166 1
	register struct proc *p;
d1172 3
a1174 2
	register struct trapframe *tf = p->p_md.md_regs;
	register struct pcb *pcb = &p->p_addr->u_pcb;
d1193 3
a1195 2
	suword((caddr_t)(stack - HPPA_FRAME_SIZE), 0);
	suword((caddr_t)(stack + HPPA_FRAME_CRP), 0);
d1229 1
d1270 5
a1274 2
	if (suword((caddr_t)scp + sss - HPPA_FRAME_SIZE, 0) ||
	    suword((caddr_t)scp + sss + HPPA_FRAME_CRP, 0))
@


1.92
log
@level 0x16 is really an l2
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.91 2002/12/17 23:11:32 millert Exp $	*/
a1180 1

d1188 7
a1205 8

	/* setup terminal stack frame */
	stack = hppa_round_page(stack);
	tf->tf_r3 = stack;
	suword((caddr_t)(stack), 0);
	stack += HPPA_FRAME_SIZE;
	suword((caddr_t)(stack + HPPA_FRAME_CRP), 0);
	tf->tf_sp = stack;
@


1.91
log
@Make SysV-style shared memory and semaphore limits sysctl'able.
Instead of allocating a static amount of memory for the data
structures via valloc() in allocsys(), allocate things dynamically
using pool(9) when possible and malloc(9) when not.  The various
members of struct seminfo and struct shminfo are in kern.seminfo
and kern.shminfo respectively (not all members of kern.seminfo are
changable).

The data structures used still leave something to be desired but
things are not made worse in that respect by this commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.90 2002/11/27 21:47:14 mickey Exp $	*/
d493 3
@


1.90
log
@no wrapper arounf hardclock(), use CPU_CLOCKUPDATE, real microtime; miod ok
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.89 2002/11/08 01:59:53 mickey Exp $	*/
a58 6
#ifdef SYSVSEM
#include <sys/sem.h>
#endif
#ifdef SYSVSHM
#include <sys/shm.h>
#endif
a541 12
#ifdef SYSVSHM
	shminfo.shmmax = shmmaxpgs;
	shminfo.shmall = shmmaxpgs;
	shminfo.shmseg = shmseg;
	valloc(shmsegs, struct shmid_ds, shminfo.shmmni);
#endif
#ifdef SYSVSEM
	valloc(sema, struct semid_ds, seminfo.semmni);
	valloc(sem, struct sem, seminfo.semmns);
	/* This is pretty disgusting! */
	valloc(semu, int, (seminfo.semmnu * seminfo.semusz) / sizeof(int));
#endif
@


1.89
log
@Don't uvm_useracc the user sigcontext in sys_sigreturn and then access
the user addresses directly from the kernel. copyin is faster and can
correctly deal properly with mappings that uvm_useracc thinks are
correct but will fault anyway (to figure out how to generate such
mappings is left as en excercise for the reader).
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.88 2002/11/01 00:14:43 mickey Exp $	*/
d142 1
a142 1
u_int	cpu_ticksnum, cpu_ticksdenom, cpu_hzticks;
a746 1
		mfctl(CR_ITMR, start);
d749 22
@


1.88
log
@add a missing delay after printf on halt[-p], proper arg for a cold hook
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.87 2002/10/22 19:35:45 mickey Exp $	*/
d1302 1
d1310 2
a1311 3
	if (uvm_useracc((caddr_t)scp, sizeof (*scp), B_WRITE) == 0 ||
	    copyin((caddr_t)scp, (caddr_t)&ksc, sizeof ksc))
		return (EINVAL);
@


1.87
log
@do not force single-user; pt out by fries@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.86 2002/10/15 14:44:45 mickey Exp $	*/
d944 2
a945 1
			(*cold_hook)(HPPA_COLD_COLD);
d950 1
@


1.86
log
@missing initmsgbuf(), noticed by miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.85 2002/10/13 15:53:39 mickey Exp $	*/
a298 2

	boothowto |= RB_SINGLE;	/* XXX always go into single-user while debug */
@


1.85
log
@track the end of physmem for use in dmmem_alloc
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.84 2002/10/07 15:32:37 mickey Exp $	*/
d574 1
a574 1
	v += hppa_round_page(MSGBUFSIZE);
a575 1
	msgbufmapped = 1;
d579 3
@


1.84
log
@s/PSW_/PSL_/ to match other archs
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.83 2002/10/07 14:42:07 mickey Exp $	*/
d165 1
d412 3
a414 2
	totalphysmem = PAGE0->imm_max_mem / NBPG;
	resvmem = ((vaddr_t)&kernel_text) / NBPG;
@


1.83
log
@proper terminate the user stack on signal
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.82 2002/10/07 14:38:34 mickey Exp $	*/
d1309 3
a1311 3
#define PSW_MBS (PSW_C|PSW_Q|PSW_P|PSW_D|PSW_I)
#define PSW_MBZ (PSW_Y|PSW_Z|PSW_S|PSW_X|PSW_M|PSW_R)
	if ((ksc.sc_ps & (PSW_MBS|PSW_MBZ)) != PSW_MBS)
@


1.82
log
@on implementations w/ fpu included unimplemented instructions
are signaled through the exception trap w/ invalid opcode marked
instruction in the exception registers, not through the emulation
trap (as long as the fpu is enabled, of  course).
parse emulation from the exception trap as well as the emulation
trap and fix the dispatcher into usable condition.
parse invalid op exception on trap and signal the user appropriately.
reset the exception on exec and for child on fork.
the later is appropriate since exceptions are delayed until next
fpu instruction, which was in the parent indeed, let him get it.
save parent's fpu context on fork before cipying it, if the
parent owned the fpu.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.81 2002/09/23 17:43:20 mickey Exp $	*/
a1213 1
	struct sigcontext *scp, ksc;
d1216 2
a1217 1
	siginfo_t ksi, *sip = NULL;
d1239 1
d1242 2
a1243 2
		sip = (void *)(scp + 1);
		if (copyout((caddr_t)&ksi, sip, sizeof(*sip)))
d1259 1
a1259 1
	if (suword((caddr_t)scp + sss, 0) ||
@


1.81
log
@parisc level 0x10 is just an overclocked 0xe
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.80 2002/09/17 03:51:49 mickey Exp $	*/
d1161 1
d1180 1
a1180 1
	pcb->pcb_fpregs[0] = HPPA_FPU_INIT;
d1184 6
@


1.80
log
@handle fpu exceptions properly, might use a regress, i guess
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.79 2002/09/11 16:01:37 mickey Exp $	*/
d497 3
@


1.79
log
@provide a convinient reset label
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.78 2002/09/11 15:55:58 mickey Exp $	*/
d1159 1
a1159 1
	/* register struct pcb *pcb = &p->p_addr->u_pcb; */
d1174 6
@


1.78
log
@stack grows the other way, but the frame is the other way to that. hehe
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.77 2002/09/09 18:33:42 mickey Exp $	*/
d949 2
@


1.77
log
@set up the frame flags and a user frame better on exec
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.76 2002/08/03 18:57:04 mickey Exp $	*/
d1178 1
a1178 1
	suword((caddr_t)(stack - HPPA_FRAME_CRP), 0);
d1240 2
a1241 2
	if (suword((caddr_t)scp + sss - HPPA_FRAME_PSP, 0) ||
	    suword((caddr_t)scp + sss - HPPA_FRAME_CRP, 0))
@


1.76
log
@rework boot() w/o a goto
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.75 2002/07/25 22:32:33 mickey Exp $	*/
d1166 1
d1175 2
a1177 1
	suword((caddr_t)(stack - HPPA_FRAME_PSP), 0);
@


1.75
log
@missing arg in the call to the pdc_call since some old times
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.74 2002/07/25 04:45:31 mickey Exp $	*/
d902 1
a902 1
	if (cold) {
d904 1
a904 2
		goto haltsys;
	}
d906 1
a906 1
	boothowto = howto | (boothowto & RB_HALT);
d908 15
a922 13
	if (!(howto & RB_NOSYNC)) {
		waittime = 0;
		vfs_shutdown();
		/*
		 * If we've been adjusting the clock, the todr
		 * will be out of synch; adjust it now unless
		 * the system was sitting in ddb.
		 */
		if ((howto & RB_TIMEBAD) == 0)
			resettodr();
		else
			printf("WARNING: not updating battery clock\n");
	}
d924 1
a924 1
	/* XXX probably save howto into stable storage */
d926 2
a927 1
	splhigh();
d929 2
a930 2
	if (howto & RB_DUMP)
		dumpsys();
a931 2
	doshutdownhooks();
haltsys:
@


1.74
log
@kcopy is a space-to-space copy from kernel space, to guess where, -- to the same kernel space, just error on fault
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.73 2002/07/20 19:24:55 art Exp $	*/
d590 1
a590 1
	pdc_call((iodcio_t)pdc, PDC_CHASSIS, PDC_CHASSIS_DISP,
@


1.73
log
@Instead of copying out the signal trampoline on top of the stack, create
an uvm aobj, copy out the signal trampoline into it and share that page
among all processes for the same emulation.

This also requires us to actually be able to tell signal code where the
trampoline is located, so introduce a new field in struct proc - p_sigcode
that is a pointer to sigcode. This allows us to remove all the ugly
calculations of the signal trampoline address done in every sendsig
function in the tree (that's why so many files are changed).

Tested by various people. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.72 2002/05/14 00:25:02 mickey Exp $	*/
d1089 1
a1089 7
	register u_int oldh = curproc->p_addr->u_pcb.pcb_onfault;

	curproc->p_addr->u_pcb.pcb_onfault = (u_int)&copy_on_fault;
	bcopy(from, to, size);
	curproc->p_addr->u_pcb.pcb_onfault = oldh;

	return 0;
@


1.72
log
@disable sid hashing while still in real mode, alos print the parisc arch once and not per each cpu since they are not intermixable architecture-wise
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.71 2002/05/13 19:11:15 mickey Exp $	*/
d1259 1
a1259 2
	tf->tf_iioq_head = HPPA_PC_PRIV_USER |
	    ((register_t)PS_STRINGS + sizeof(struct ps_strings));
@


1.71
log
@ldi-ldo whatever was in the table, be that much clever
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.70 2002/05/08 03:16:08 mickey Exp $	*/
d294 1
d371 9
d467 43
a601 1
	struct pdc_model pdc_model PDC_ALIGNMENT;
d604 1
a604 2
	int base, residual;
	int err, i;
d620 1
a620 45
	/* identify system type */
	if ((err = pdc_call((iodcio_t)pdc, 0, PDC_MODEL, PDC_MODEL_INFO,
	    &pdc_model)) < 0) {
#ifdef DEBUG
		printf("WARNING: PDC_MODEL error %d\n", err);
#endif
	} else {
		const char *p, *q;
		char buf[32];
		int lev;

		i = pdc_model.hvers >> 4;
		p = hppa_mod_info(HPPA_TYPE_BOARD, i);
		if (!p) {
			sprintf(buf, "(UNKNOWN 0x%x)", i);
			p = buf;
		}

		switch (pdc_model.arch_rev) {
		default:
		case 0:
			q = "1.0";
#ifdef COMPAT_HPUX
			cpu_model_hpux = HPUX_SYSCONF_CPUPA10;
#endif
			break;
		case 4:
			q = "1.1";
#ifdef COMPAT_HPUX
			cpu_model_hpux = HPUX_SYSCONF_CPUPA11;
#endif
			break;
		case 8:
			q = "2.0";
#ifdef COMPAT_HPUX
			cpu_model_hpux = HPUX_SYSCONF_CPUPA20;
#endif
			break;
		}

		lev = 'a' + (*cpu_desidhash)();
		sprintf(cpu_model, "HP9000/%s PA-RISC %s%c", p, q, lev);
		printf("%s\n", cpu_model);
	}

@


1.70
log
@print parisc level w/ the the parisc version, not for each cpu
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.69 2002/05/08 03:06:45 mickey Exp $	*/
d451 2
a452 7
			if (pdc_cache.dt_conf.tc_sh) {
				LDILDO(trap_ep_T_DTLBMISS  , p->dtlbh);
				LDILDO(trap_ep_T_DTLBMISSNA, p->dtlbnah);
			} else {
				LDILDO(trap_ep_T_ITLBMISS  , p->itlbh);
				LDILDO(trap_ep_T_ITLBMISSNA, p->itlbnah);
			}
@


1.69
log
@kill debugging printfski
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.68 2002/04/22 00:19:59 mickey Exp $	*/
d582 3
d587 5
d614 2
a615 5
		if (p)
			sprintf(cpu_model, "HP9000/%s PA-RISC %s", p, q);
		else
			sprintf(cpu_model, "HP9000/(UNKNOWN %x) PA-RISC %s",
				i, q);
@


1.68
log
@no longer batc the data, only the code.
this removes a constraint and an ld.script dependancy
for the .data and the dynamically allocated kernel
structures existed w/ batcing. also makes pmap_steal_memory
obsolete and replaced w/ the pmap_virtual_space.
implement batching for pmap_remove to avoid
zeroing out the pte entries if pde will be removed anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.67 2002/04/21 22:30:46 mickey Exp $	*/
a624 1
printf("base=%d res=%d\n", base, residual);
@


1.67
log
@better buf's mapping and less magic constants in checking for io space cachability
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.66 2002/03/26 05:24:02 mickey Exp $	*/
d520 5
a527 5
	/* alloc msgbuf */
	if (!(msgbufp = (void *)pmap_steal_memory(MSGBUFSIZE, NULL, NULL)))
		panic("cannot allocate msgbuf");
	msgbufmapped = 1;

d548 1
@


1.66
log
@if cannot guess cpu model default to the lowest supported one
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.65 2002/03/25 20:46:49 deraadt Exp $	*/
d617 1
a617 1
	if (uvm_map(kernel_map, (vaddr_t *) &buffers, round_page(size),
d621 1
a621 1
	minaddr = (vaddr_t)buffers;
d624 1
a625 1
		vsize_t curbufsize;
d627 1
a627 1
		struct vm_page *pg;
a636 1
		curbufsize = PAGE_SIZE * ((i < residual) ? (base+1) : base);
d638 3
a640 1
		while (curbufsize) {
a646 1
			curbufsize -= PAGE_SIZE;
d875 1
a875 1
	if ((pa & 0xF0000) == 0xF0000)
d1159 1
a1159 2
	/*pmapdebug = 13;*/
	/*
@


1.65
log
@spelling
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.64 2002/03/23 13:28:34 espie Exp $	*/
d422 1
a422 1
		if (!p->arch)
d425 4
a428 1
		else {
@


1.64
log
@Add variables for config(8) -e time tweak of systemV shared memory
parameters.

Ok millert@@, miod@@, maja@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.63 2002/03/19 19:03:20 mickey Exp $	*/
d124 1
a124 1
 * on cofigured cpu types in the kernel
@


1.63
log
@mtcpu seq requires a pre-sync, implement hpt init for pcxl
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.62 2002/03/15 21:44:18 mickey Exp $	*/
d495 3
@


1.62
log
@rewrite a pmap to use multilevel page tables.
lower 12 bits contain the perms, no unused bits left,
but a couple for off-tlb use (as the ref implemented now).
do not use the hvt, which might get some use later
if proven to speed thigs up, tlb handlers would po
another dozen of insns though, but if that's worth its...
move on the data seg and map kernel text rdonly (idea form fredette),
since all of the page0 mods done before that we are all fine
except for some viper fluff, but later w/ that.
this also picks up a bit more of ddb magic for bpt and ss.
tlb handlers can use a little bit more of attention,
but things, visually, seem to be much faster already, --
sorry, no benchmarks for now.

* effort sponsored in part by the `henry st. old ale house'
* and mr.pete and mr.lee in particular in thier generous entrirety.
* the proj took a little more that 72man*h as it was expected,
* but within murhy's law estimations.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.61 2002/03/14 01:26:31 millert Exp $	*/
d260 1
a260 1
	  ibtlb_g, NULL, pbtlb_g, hpti_g},
d265 1
a265 1
	  ibtlb_g, NULL, pbtlb_g, hpti_g}, */
@


1.61
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.60 2002/02/20 19:33:01 mickey Exp $	*/
d187 1
d189 1
d203 4
a206 4
extern const u_int itlb_x[], dtlb_x[], dtlbna_x[], tlbd_x[];
extern const u_int itlb_s[], dtlb_s[], dtlbna_s[], tlbd_s[];
extern const u_int itlb_t[], dtlb_t[], dtlbna_t[], tlbd_t[];
extern const u_int itlb_l[], dtlb_l[], dtlbna_l[], tlbd_l[];
d231 1
a231 1
	const u_int *itlbh, *dtlbh, *dtlbnah, *tlbdh;
d241 1
a241 1
	  desidhash_x, itlb_x, dtlb_x, dtlbna_x, tlbd_x,
d245 2
a246 2
	{ "PCXS",  hpcxs, 0x11, HPPA_FTRS_BTLBS,
	  desidhash_s, itlb_s, dtlb_s, dtlbna_s, tlbd_s,
d251 1
a251 1
	  desidhash_t, itlb_t, dtlb_t, dtlbna_t, tlbd_t,
d254 1
a254 1
	  desidhash_t, itlb_t, dtlb_t, dtlbna_t, tlbd_t,
d259 1
a259 1
	  desidhash_l, itlb_l, dtlb_l, dtlbna_l, tlbd_l,
d264 1
a264 1
	  desidhash_l, itlb_l, dtlb_l, dtlbna_l, tlbd_l,
d269 1
a269 1
	  desidhash_g, itlb_l, dtlb_l, dtlbna_l, tlbd_l,
d274 1
a274 1
	  desidhash_g, itlb_l, dtlb_l, dtlbna_l, tlbd_l,
d279 1
a279 1
	  desidhash_g, itlb_l, dtlb_l, dtlbna_l, tlbd_l,
d284 1
a284 1
	  desidhash_g, itlb_l, dtlb_l, dtlbna_l, tlbd_l,
d295 2
a296 4
	vaddr_t v, vstart, vend;
	register int error;
	int hptsize;	/* size of HPT table if supported */
	int cpu_features = 0;
d367 3
d394 2
a395 2
		cpu_features = pdc_btlb.finfo.num_c?
		    HPPA_FTRS_BTLBU : HPPA_FTRS_BTLBS;
d404 1
a404 4
	/* calculate HPT size */
	for (hptsize = 256; hptsize < totalphysmem; hptsize *= 2);
	hptsize *= 16;	/* sizeof(hpt_entry) */

d408 2
a409 3
		mtctl(hptsize - 1, CR_HPTMASK);
		hptsize = 0;
	} else {
d411 1
a411 7

		if (hptsize > pdc_hwtlb.max_size)
			hptsize = pdc_hwtlb.max_size;
		else if (hptsize < pdc_hwtlb.min_size)
			hptsize = pdc_hwtlb.min_size;
		mtctl(hptsize - 1, CR_HPTMASK);
	}
d448 7
a454 2
			LDILDO(trap_ep_T_ITLBMISS  , p->itlbh);
			LDILDO(trap_ep_T_ITLBMISSNA, p->itlbh);
a466 3
	vstart = hppa_round_page(start);
	vend = VM_MAX_KERNEL_ADDRESS;

d489 1
a489 1
	v = vstart;
d512 1
a512 2
	bzero ((void *)vstart, (v - vstart));
	vstart = v;
d515 1
a515 1
	pmap_bootstrap(&vstart, &vend);
a521 17
	/* Turn on the HW TLB assist */
	if (hptsize) {
		u_int hpt;

		mfctl(CR_VTOP, hpt);
		if ((error = (cpu_hpt_init)(hpt, hptsize)) < 0) {
#ifdef DEBUG
			printf("WARNING: HPT init error %d\n", error);
#endif
		} else {
#ifdef PMAPDEBUG
			printf("HPT: %d entries @@ 0x%x\n",
			    hptsize / sizeof(struct hpt_entry), hpt);
#endif
		}
	}

a609 4
	/*
	 * Now allocate buffers proper.  They are different than the above
	 * in that they usually occupy more virtual memory than physical.
	 */
d637 2
a638 3
			pmap_enter(kernel_map->pmap, curbuf,
			    VM_PAGE_TO_PHYS(pg), VM_PROT_READ|VM_PROT_WRITE,
			    VM_PROT_READ|VM_PROT_WRITE|PMAP_WIRED);
d865 2
a866 1
		printf("WARNING: BTLB address misaligned\n");
d870 1
a870 1
		prot |= TLB_UNCACHEABLE;
@


1.60
log
@setup power failure handler (for sw-controlled power button), move toc handler
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.59 2002/02/17 22:59:52 maja Exp $	*/
d156 6
a161 6
int (*cpu_desidhash) __P((void));
int (*cpu_hpt_init) __P((vaddr_t hpt, vsize_t hptsize));
int (*cpu_ibtlb_ins) __P((int i, pa_space_t sp, vaddr_t va, paddr_t pa,
	    vsize_t sz, u_int prot));
int (*cpu_dbtlb_ins) __P((int i, pa_space_t sp, vaddr_t va, paddr_t pa,
	    vsize_t sz, u_int prot));
d178 5
a182 5
void delay_init __P((void));
static __inline void fall __P((int, int, int, int, int));
void dumpsys __P((void));
void hpmc_dump __P((void));
void hppa_user2frame __P((struct trapframe *sf, struct trapframe *tf));
d205 18
a222 18
int iibtlb_s __P((int i, pa_space_t sp, vaddr_t va, paddr_t pa,
    vsize_t sz, u_int prot));
int idbtlb_s __P((int i, pa_space_t sp, vaddr_t va, paddr_t pa,
    vsize_t sz, u_int prot));
int ibtlb_t __P((int i, pa_space_t sp, vaddr_t va, paddr_t pa,
    vsize_t sz, u_int prot));
int ibtlb_l __P((int i, pa_space_t sp, vaddr_t va, paddr_t pa,
    vsize_t sz, u_int prot));
int ibtlb_g __P((int i, pa_space_t sp, vaddr_t va, paddr_t pa,
    vsize_t sz, u_int prot));
int pbtlb_g __P((int i));
int hpti_l __P((vaddr_t, vsize_t));
int hpti_g __P((vaddr_t, vsize_t));
int desidhash_x __P((void));
int desidhash_s __P((void));
int desidhash_t __P((void));
int desidhash_l __P((void));
int desidhash_g __P((void));
d228 1
a228 1
	int (*desidhash) __P((void));
d230 6
a235 6
	int (*dbtlbins) __P((int i, pa_space_t sp, vaddr_t va, paddr_t pa,
	    vsize_t sz, u_int prot));
	int (*ibtlbins) __P((int i, pa_space_t sp, vaddr_t va, paddr_t pa,
	    vsize_t sz, u_int prot));
	int (*btlbprg) __P((int i));
	int (*hptinit) __P((vaddr_t hpt, vsize_t hptsize));
d1038 1
a1038 1
	register int (*dump) __P((dev_t, daddr_t, caddr_t, size_t));
@


1.59
log
@Patch from Daniel Lucq <daniel@@lucq.org>

The patch allows you to change the value of NMBCLUSTERS, BUFCACHEPERCENT
and NKMEMPAGES using the config command, instead of recompiling the kernel.

This is the kernel part of the patch. I have compiled it on i386, sparc64,
alpha and macppc. -moj ok art@@ maja@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.58 2002/02/12 06:42:26 mickey Exp $	*/
d352 13
a364 1
		PAGE0->ivec_toclen = hppa_toc_end - hppa_toc + 1;
@


1.58
log
@support 712's programmable power switch, no interrupt yet
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.57 2002/02/12 05:23:27 mickey Exp $	*/
d103 5
d113 1
a464 3
#ifndef BUFCACHEPERCENT
#define BUFCACHEPERCENT 10
#endif /* BUFCACHEPERCENT */
d467 1
a467 1
		    (totalphysmem <= 0x1000? 5 : BUFCACHEPERCENT);
@


1.57
log
@small repairs to hpmc and toc handlers
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.56 2002/02/11 19:42:11 mickey Exp $	*/
d931 3
d936 6
@


1.56
log
@disable fpu on csw, print fpu version on cpu line, if present
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.55 2002/02/07 05:48:54 mickey Exp $	*/
d326 2
a327 2
		extern u_int hpmc_v;	/* from locore.s */
		register u_int *p = &hpmc_v;
d330 1
a330 1
			*p = 0;	/* XXX nop is more appropriate? */
d332 2
d337 12
d929 1
a930 1
	doshutdownhooks();
d972 1
d974 2
@


1.55
log
@fix sigdebug cases; init sigcontext before it's used (;
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.54 2002/02/06 19:39:20 mickey Exp $	*/
d521 1
d526 1
a526 1
		mtctl(pdc_coproc.ccr_enable & CCR_MASK, CR_CCR);
@


1.54
log
@implement signal delivery; based on fredette@@'s work
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.53 2002/02/03 03:25:46 mickey Exp $	*/
d187 1
a187 1
int sigdebug = 0xff;
d1154 2
a1155 1
	suword((caddr_t)(stack + HPPA_FRAME_PSP), 0);
d1180 1
a1180 1
	if ((sigdebug | SDB_FOLLOW) && (!sigpid || p->p_pid == sigpid))
d1185 2
a1205 1
	ksc.sc_onstack = psp->ps_sigstk.ss_flags & SS_ONSTACK;
d1216 3
a1218 1
	if (suword((caddr_t)scp + sss + HPPA_FRAME_SIZE - HPPA_FRAME_PSP, 0))
a1219 1
	sss += HPPA_FRAME_SIZE;
d1222 1
a1222 1
	if (sigdebug & SDB_FOLLOW)
d1235 1
d1240 1
a1240 1
	if (sigdebug & SDB_FOLLOW)
d1260 1
a1260 1
	if (sigdebug & SDB_FOLLOW)
d1289 1
a1289 1
	if (sigdebug & SDB_FOLLOW)
@


1.53
log
@restore hpt size computation, does not break things as i thought
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.52 2002/02/02 21:10:56 mickey Exp $	*/
d176 1
d1139 1
d1142 1
d1152 1
d1172 5
a1176 2
	struct trapframe sf, *tf = p->p_md.md_regs;
	register_t sp = tf->tf_sp;
d1184 29
a1212 2
	sf = *tf;
	/* TODO send signal */
d1214 1
a1214 1
	if (copyout(&sf, (void *)sp, sizeof(sf)))
d1216 24
d1248 81
a1328 2
	/* TODO sigreturn */
	return EINVAL;
@


1.52
log
@fix 'physmem' usage
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.51 2002/02/02 21:06:46 mickey Exp $	*/
d369 1
a369 2
	/* for (hptsize = 256; hptsize < totalphysmem; hptsize *= 2); */
hptsize=256;	/* XXX one page for now */
@


1.51
log
@implement the rest of /dev/mem devices; from netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.50 2002/01/23 17:51:52 art Exp $	*/
d491 1
a492 1
	physmem = totalphysmem - btoc(vstart);
d1019 1
a1019 1
		bytes = ctob(physmem);
@


1.50
log
@move mb_map allocation to mbinit()
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.49 2002/01/23 17:35:56 art Exp $	*/
d4 1
a4 1
 * Copyright (c) 1999-2000 Michael Shalayeff
d169 2
a170 1

d666 1
@


1.49
log
@move definition of mb_map from zillions of machdep.c to uipc_mbuf.c
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.48 2002/01/16 20:50:16 miod Exp $	*/
a652 3

	mb_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
	    VM_MBUF_SIZE, VM_MAP_INTRSAFE, FALSE, NULL);
@


1.48
log
@Don't include <sys/map.h> when you don't need what's in it.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.47 2001/12/02 02:55:42 mickey Exp $	*/
a167 1
struct vm_map *mb_map = NULL;
@


1.47
log
@increase fixed extent storage
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.46 2001/11/28 16:13:28 art Exp $	*/
a37 1
#include <sys/map.h>
@


1.47.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.50 2002/01/23 17:51:52 art Exp $	*/
d38 1
d169 1
d655 3
@


1.47.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.47.2.1 2002/01/31 22:55:09 niklas Exp $	*/
d4 1
a4 1
 * Copyright (c) 1999-2002 Michael Shalayeff
a102 5

#ifndef BUFCACHEPERCENT
#define BUFCACHEPERCENT 10
#endif /* BUFCACHEPERCENT */

a107 1
int bufcachepercent = BUFCACHEPERCENT;
d118 1
a118 1
 * on configured cpu types in the kernel
d150 6
a155 6
int (*cpu_desidhash)(void);
int (*cpu_hpt_init)(vaddr_t hpt, vsize_t hptsize);
int (*cpu_ibtlb_ins)(int i, pa_space_t sp, vaddr_t va, paddr_t pa,
	    vsize_t sz, u_int prot);
int (*cpu_dbtlb_ins)(int i, pa_space_t sp, vaddr_t va, paddr_t pa,
	    vsize_t sz, u_int prot);
a168 2
/* Virtual page frame for /dev/mem (see mem.c) */
vaddr_t vmmap;
d170 5
a174 5
void delay_init(void);
static __inline void fall(int, int, int, int, int);
void dumpsys(void);
void hpmc_dump(void);
void hppa_user2frame(struct trapframe *sf, struct trapframe *tf);
a178 1
#if defined(HP7100LC_CPU) || defined(HP7300LC_CPU)
a179 1
#endif
d185 1
a185 1
int sigdebug = 0;
d193 22
a214 22
extern const u_int itlb_x[], itlbna_x[], dtlb_x[], dtlbna_x[], tlbd_x[];
extern const u_int itlb_s[], itlbna_s[], dtlb_s[], dtlbna_s[], tlbd_s[];
extern const u_int itlb_t[], itlbna_t[], dtlb_t[], dtlbna_t[], tlbd_t[];
extern const u_int itlb_l[], itlbna_l[], dtlb_l[], dtlbna_l[], tlbd_l[];
int iibtlb_s(int i, pa_space_t sp, vaddr_t va, paddr_t pa,
    vsize_t sz, u_int prot);
int idbtlb_s(int i, pa_space_t sp, vaddr_t va, paddr_t pa,
    vsize_t sz, u_int prot);
int ibtlb_t(int i, pa_space_t sp, vaddr_t va, paddr_t pa,
    vsize_t sz, u_int prot);
int ibtlb_l(int i, pa_space_t sp, vaddr_t va, paddr_t pa,
    vsize_t sz, u_int prot);
int ibtlb_g(int i, pa_space_t sp, vaddr_t va, paddr_t pa,
    vsize_t sz, u_int prot);
int pbtlb_g(int i);
int hpti_l(vaddr_t, vsize_t);
int hpti_g(vaddr_t, vsize_t);
int desidhash_x(void);
int desidhash_s(void);
int desidhash_t(void);
int desidhash_l(void);
int desidhash_g(void);
d220 8
a227 8
	int (*desidhash)(void);
	const u_int *itlbh, *itlbnah, *dtlbh, *dtlbnah, *tlbdh;
	int (*dbtlbins)(int i, pa_space_t sp, vaddr_t va, paddr_t pa,
	    vsize_t sz, u_int prot);
	int (*ibtlbins)(int i, pa_space_t sp, vaddr_t va, paddr_t pa,
	    vsize_t sz, u_int prot);
	int (*btlbprg)(int i);
	int (*hptinit)(vaddr_t hpt, vsize_t hptsize);
d231 1
a231 1
	  desidhash_x, itlb_x, itlbna_l, dtlb_x, dtlbna_x, tlbd_x,
d235 2
a236 2
	{ "PCXS",  hpcxs, 0x11, 0,
	  desidhash_s, itlb_s, itlbna_l, dtlb_s, dtlbna_s, tlbd_s,
d241 1
a241 1
	  desidhash_t, itlb_t, itlbna_l, dtlb_t, dtlbna_t, tlbd_t,
d244 1
a244 1
	  desidhash_t, itlb_t, itlbna_l, dtlb_t, dtlbna_t, tlbd_t,
d249 2
a250 2
	  desidhash_l, itlb_l, itlbna_l, dtlb_l, dtlbna_l, tlbd_l,
	  ibtlb_g, NULL, pbtlb_g, hpti_l},
d254 2
a255 2
	  desidhash_l, itlb_l, itlbna_l, dtlb_l, dtlbna_l, tlbd_l,
	  ibtlb_g, NULL, pbtlb_g, hpti_l}, */
d259 1
a259 1
	  desidhash_g, itlb_l, itlbna_l, dtlb_l, dtlbna_l, tlbd_l,
d264 1
a264 1
	  desidhash_g, itlb_l, itlbna_l, dtlb_l, dtlbna_l, tlbd_l,
d269 1
a269 1
	  desidhash_g, itlb_l, itlbna_l, dtlb_l, dtlbna_l, tlbd_l,
d274 1
a274 1
	  desidhash_g, itlb_l, itlbna_l, dtlb_l, dtlbna_l, tlbd_l,
a283 1
	struct pdc_model pdc_model PDC_ALIGNMENT;
d285 4
a288 2
	vaddr_t v, v1;
	int error, cpu_features = 0;
d324 2
a325 2
		extern u_int hpmc_v[];	/* from locore.s */
		register u_int *p = hpmc_v;
d328 1
a328 1
			*p = 0x08000240;
a329 2
		p[6] = (u_int)&hpmc_dump;
		p[7] = 32;
a332 36
	{
		extern u_int hppa_toc[], hppa_toc_end[];
		register u_int cksum, *p;

		for (cksum = 0, p = hppa_toc; p < hppa_toc_end; p++)
			cksum += *p;

		*p = cksum;
		PAGE0->ivec_toc = (int (*)(void))hppa_toc;
		PAGE0->ivec_toclen = (hppa_toc_end - hppa_toc + 1) * 4;
	}

	{
		extern u_int hppa_pfr[], hppa_pfr_end[];
		register u_int cksum, *p;

		for (cksum = 0, p = hppa_pfr; p < hppa_pfr_end; p++)
			cksum += *p;

		*p = cksum;
		PAGE0->ivec_mempf = (int (*)(void))hppa_pfr;
		PAGE0->ivec_mempflen = (hppa_pfr_end - hppa_pfr + 1) * 4;
	}

	/* may the scientific guessing begin */
	cpu_features = 0;

	/* identify system type */
	if ((error = pdc_call((iodcio_t)pdc, 0, PDC_MODEL, PDC_MODEL_INFO,
	    &pdc_model)) < 0) {
#ifdef DEBUG
		printf("WARNING: PDC_MODEL error %d\n", error);
#endif
		pdc_model.hvers = 0;
	}

d357 2
a358 2
		if (pdc_btlb.finfo.num_c)
			cpu_features |= HPPA_FTRS_BTLBU;
d367 5
a371 1
#if defined(HP7100LC_CPU) || defined(HP7300LC_CPU)
d375 3
a377 2
		pmap_hptsize = 0;
	} else
d379 7
a385 1
#endif
d396 1
a396 1
		if (!p->arch) {
d399 1
a399 4
			p = cpu_types;
		}

		{
d423 1
a423 1
			LDILDO(trap_ep_T_ITLBMISSNA, p->itlbnah);
a427 43
	{
		const char *p, *q;
		char buf[32];
		int lev, hv;

		lev = 0xa + (*cpu_desidhash)();
		hv = pdc_model.hvers >> 4;
		if (!hv) {
			p = "(UNKNOWN)";
			q = lev == 0xa? "1.0" : "1.1";
		} else {
			p = hppa_mod_info(HPPA_TYPE_BOARD, hv);
			if (!p) {
				sprintf(buf, "(UNKNOWN 0x%x)", hv);
				p = buf;
			}

			switch (pdc_model.arch_rev) {
			default:
			case 0:
				q = "1.0";
#ifdef COMPAT_HPUX
				cpu_model_hpux = HPUX_SYSCONF_CPUPA10;
#endif
				break;
			case 4:
				q = "1.1";
#ifdef COMPAT_HPUX
				cpu_model_hpux = HPUX_SYSCONF_CPUPA11;
#endif
				break;
			case 8:
				q = "2.0";
#ifdef COMPAT_HPUX
				cpu_model_hpux = HPUX_SYSCONF_CPUPA20;
#endif
				break;
			}
		}

		sprintf(cpu_model, "HP9000/%s PA-RISC %s%x", p, q, lev);
	}

d436 3
d444 3
d449 1
a449 1
		    (totalphysmem <= 0x1000? 5 : bufcachepercent);
d464 1
a464 1
	v1 = v = hppa_round_page(start);
a469 3
	shminfo.shmmax = shmmaxpgs;
	shminfo.shmall = shmmaxpgs;
	shminfo.shmseg = shmseg;
d487 5
a491 1
	bzero ((void *)v1, (v - v1));
d493 3
a495 3
	msgbufp = (struct msgbuf *)v;
	v += hppa_round_page(MSGBUFSIZE);
	bzero(msgbufp, MSGBUFSIZE);
d498 16
a513 2
	/* sets physmem */
	pmap_bootstrap(v);
a519 1
		extern u_int fpu_enable;
d524 1
a524 1
		fpu_enable = pdc_coproc.ccr_enable & CCR_MASK;
a533 1
	fcacheall();
d539 1
d542 2
a543 1
	int i, base, residual;
d559 40
a598 1
	printf("%s\n", cpu_model);
d602 4
d607 1
a607 1
	if (uvm_map(kernel_map, &minaddr, round_page(size),
d611 1
a611 1
	buffers = (caddr_t)minaddr;
d615 1
d617 1
a617 1
		int cbpgs;
d627 1
d629 1
a629 3
		for (cbpgs = base + (i < residual? 1 : 0); cbpgs--; ) {
			struct vm_page *pg;

d633 3
a635 2
			pmap_kenter_pa(curbuf, VM_PAGE_TO_PHYS(pg),
			    VM_PROT_READ|VM_PROT_WRITE);
d637 1
a664 1
	vmmap = uvm_km_valloc_wait(kernel_map, NBPG);
d861 1
a861 2
		printf("WARNING: BTLB address misaligned pa=0x%x, len=0x%x\n",
		    pa, len);
d864 2
a865 2
	if ((pa & (HPPA_IOBEGIN >> PGSHIFT)) == (HPPA_IOBEGIN >> PGSHIFT))
		prot |= TLB_UNCACHABLE;
d912 1
a913 4
haltsys:
	/* in case we came on powerfail interrupt */
	if (cold_hook)
		(*cold_hook)(HPPA_COLD_COLD);
a915 6
		if (howto & RB_POWERDOWN && cold_hook) {
			printf("Powering off...");
			(*cold_hook)(HPPA_COLD_COLD);
			DELAY(1000000);
		}

a954 1
	printf("HPMC\n");
a955 2
	cold = 0;
	boot(RB_NOSYNC);
d994 1
a994 1
	register int (*dump)(dev_t, daddr_t, caddr_t, size_t);
d1017 1
a1017 1
		bytes = ctob(totalphysmem);
d1136 1
a1136 1
	/*pmapdebug = 13;
a1138 1
	*/
a1147 1
	stack = hppa_round_page(stack);
d1149 1
a1149 2
	suword((caddr_t)(stack - HPPA_FRAME_PSP), 0);
	suword((caddr_t)(stack - HPPA_FRAME_CRP), 0);
d1167 2
a1168 5
	struct sigcontext *scp, ksc;
	struct trapframe *tf = p->p_md.md_regs;
	struct sigacts *psp = p->p_sigacts;
	siginfo_t ksi, *sip = NULL;
	int sss;
d1171 1
a1171 1
	if ((sigdebug & SDB_FOLLOW) && (!sigpid || p->p_pid == sigpid))
d1176 2
a1177 30
	ksc.sc_onstack = psp->ps_sigstk.ss_flags & SS_ONSTACK;

	/*
	 * Allocate space for the signal handler context.
	 */
	if ((psp->ps_flags & SAS_ALTSTACK) && !ksc.sc_onstack &&
	    (psp->ps_sigonstack & sigmask(sig))) {
		scp = (struct sigcontext *)psp->ps_sigstk.ss_sp;
		psp->ps_sigstk.ss_flags |= SS_ONSTACK;
	} else
		scp = (struct sigcontext *)tf->tf_sp;

	sss = sizeof(*scp);
	if (psp->ps_siginfo & sigmask(sig)) {
		initsiginfo(&ksi, sig, code, type, val);
		sip = (void *)(scp + 1);
		if (copyout((caddr_t)&ksi, sip, sizeof(*sip)))
			sigexit(p, SIGILL);
		sss += sizeof(*sip);
	}

	ksc.sc_mask = mask;
	ksc.sc_sp = tf->tf_sp;
	ksc.sc_fp = (register_t)scp + sss;
	ksc.sc_ps = tf->tf_ipsw;
	ksc.sc_pcoqh = tf->tf_iioq_head;
	ksc.sc_pcoqt = tf->tf_iioq_tail;
	bcopy(tf, &ksc.sc_tf, sizeof(ksc.sc_tf));
	if (copyout((caddr_t)&ksc, scp, sizeof(*scp)))
		sigexit(p, SIGILL);
d1179 1
a1179 3
	sss += HPPA_FRAME_SIZE;
	if (suword((caddr_t)scp + sss - HPPA_FRAME_PSP, 0) ||
	    suword((caddr_t)scp + sss - HPPA_FRAME_CRP, 0))
a1180 24

#ifdef DEBUG
	if ((sigdebug & SDB_FOLLOW) && (!sigpid || p->p_pid == sigpid))
		printf("sendsig(%d): sig %d scp %p fp %p sp %x\n",
		    p->p_pid, sig, scp, ksc.sc_fp, ksc.sc_sp);
#endif

	tf->tf_arg0 = sig;
	tf->tf_arg1 = (register_t)sip;
	tf->tf_arg2 = tf->tf_r3 = (register_t)scp;
	tf->tf_arg3 = (register_t)catcher;
	tf->tf_sp = (register_t)scp + sss;
	tf->tf_iioq_head = HPPA_PC_PRIV_USER |
	    ((register_t)PS_STRINGS + sizeof(struct ps_strings));
	tf->tf_iioq_tail = tf->tf_iioq_head + 4;
	/* disable tracing in the trapframe */

	/* TODO FPU */

#ifdef DEBUG
	if ((sigdebug & SDB_FOLLOW) && (!sigpid || p->p_pid == sigpid))
		printf("sendsig(%d): pc %x, catcher %x\n", p->p_pid,
		    tf->tf_iioq_head, tf->tf_arg3);
#endif
d1189 2
a1190 81
	struct sys_sigreturn_args /* {
		syscallarg(struct sigcontext *) sigcntxp;
	} */ *uap = v;
	struct sigcontext *scp, ksc;
	struct trapframe *tf = p->p_md.md_regs;

	scp = SCARG(uap, sigcntxp);
#ifdef DEBUG
	if ((sigdebug & SDB_FOLLOW) && (!sigpid || p->p_pid == sigpid))
		printf("sigreturn: pid %d, scp %p\n", p->p_pid, scp);
#endif

	if (uvm_useracc((caddr_t)scp, sizeof (*scp), B_WRITE) == 0 ||
	    copyin((caddr_t)scp, (caddr_t)&ksc, sizeof ksc))
		return (EINVAL);

#define PSW_MBS (PSW_C|PSW_Q|PSW_P|PSW_D|PSW_I)
#define PSW_MBZ (PSW_Y|PSW_Z|PSW_S|PSW_X|PSW_M|PSW_R)
	if ((ksc.sc_ps & (PSW_MBS|PSW_MBZ)) != PSW_MBS)
		return (EINVAL);

	if (ksc.sc_onstack)
		p->p_sigacts->ps_sigstk.ss_flags |= SS_ONSTACK;
	else
		p->p_sigacts->ps_sigstk.ss_flags &= ~SS_ONSTACK;
	p->p_sigmask = ksc.sc_mask &~ sigcantmask;

	hppa_user2frame((struct trapframe *)&ksc.sc_tf, tf);

	tf->tf_sp = ksc.sc_sp;
	tf->tf_iioq_head = ksc.sc_pcoqh | HPPA_PC_PRIV_USER;
	tf->tf_iioq_tail = ksc.sc_pcoqt | HPPA_PC_PRIV_USER;
	tf->tf_ipsw = ksc.sc_ps;

	/* TODO FPU */

#ifdef DEBUG
	if ((sigdebug & SDB_FOLLOW) && (!sigpid || p->p_pid == sigpid))
		printf("sigreturn(%d): returns\n", p->p_pid);
#endif
	return (EJUSTRETURN);
}

void
hppa_user2frame(sf, tf)
	struct trapframe *sf, *tf;
{
	/* only restore r1-r31, sar */
	tf->tf_t1 = sf->tf_t1;		/* r22 */
	tf->tf_t2 = sf->tf_t2;		/* r21 */
	tf->tf_sp = sf->tf_sp;
	tf->tf_t3 = sf->tf_t3;		/* r20 */

	tf->tf_sar = sf->tf_sar;
	tf->tf_r1 = sf->tf_r1;
	tf->tf_rp = sf->tf_rp;
	tf->tf_r3 = sf->tf_r3;
	tf->tf_r4 = sf->tf_r4;
	tf->tf_r5 = sf->tf_r5;
	tf->tf_r6 = sf->tf_r6;
	tf->tf_r7 = sf->tf_r7;
	tf->tf_r8 = sf->tf_r8;
	tf->tf_r9 = sf->tf_r9;
	tf->tf_r10 = sf->tf_r10;
	tf->tf_r11 = sf->tf_r11;
	tf->tf_r12 = sf->tf_r12;
	tf->tf_r13 = sf->tf_r13;
	tf->tf_r14 = sf->tf_r14;
	tf->tf_r15 = sf->tf_r15;
	tf->tf_r16 = sf->tf_r16;
	tf->tf_r17 = sf->tf_r17;
	tf->tf_r18 = sf->tf_r18;
	tf->tf_t4 = sf->tf_t4;		/* r19 */
	tf->tf_arg3 = sf->tf_arg3;	/* r23 */
	tf->tf_arg2 = sf->tf_arg2;	/* r24 */
	tf->tf_arg1 = sf->tf_arg1;	/* r25 */
	tf->tf_arg0 = sf->tf_arg0;	/* r26 */
	tf->tf_dp = sf->tf_dp;
	tf->tf_ret0 = sf->tf_ret0;
	tf->tf_ret1 = sf->tf_ret1;
	tf->tf_r31 = sf->tf_r31;
@


1.47.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.47.2.2 2002/06/11 03:35:37 art Exp $	*/
a164 1
paddr_t	avail_end;
d299 2
d411 2
a412 3
	totalphysmem = btoc(PAGE0->imm_max_mem);
	resvmem = btoc(((vaddr_t)&kernel_text));
	avail_end = ctob(totalphysmem);
a496 3
				/* this one is just a 100MHz pcxl */
				if (lev == 0x10)
					lev = 0xe;
d569 1
a569 1
	v += round_page(MSGBUFSIZE);
d571 1
a575 3
	msgbufmapped = 1;
	initmsgbuf((caddr_t)msgbufp, round_page(MSGBUFSIZE));

d590 1
a590 1
	pdc_call((iodcio_t)pdc, 0, PDC_CHASSIS, PDC_CHASSIS_DISP,
d902 1
a902 1
	if (cold)
d904 2
a905 1
	else {
d907 1
a907 1
		boothowto = howto | (boothowto & RB_HALT);
d909 13
a921 13
		if (!(howto & RB_NOSYNC)) {
			waittime = 0;
			vfs_shutdown();
			/*
			 * If we've been adjusting the clock, the todr
			 * will be out of synch; adjust it now unless
			 * the system was sitting in ddb.
			 */
			if ((howto & RB_TIMEBAD) == 0)
				resettodr();
			else
				printf("WARNING: not updating battery clock\n");
		}
d923 1
a923 1
		/* XXX probably save howto into stable storage */
d925 1
a925 1
		splhigh();
d927 2
a928 5
		if (howto & RB_DUMP)
			dumpsys();

		doshutdownhooks();
	}
d930 2
a948 2
		__asm __volatile(".export hppa_reset, entry\n\t"
		    ".label hppa_reset");
d1089 7
a1095 1
	return spcopy(HPPA_SID_KERNEL, from, HPPA_SID_KERNEL, to, size);
a1161 1
	extern paddr_t fpu_curpcb;	/* from locore.S */
d1163 1
a1163 1
	register struct pcb *pcb = &p->p_addr->u_pcb;
a1171 1
	tf->tf_flags = TFF_SYS|TFF_LAST;
a1177 12
	/* reset any of the pending FPU exceptions */
	pcb->pcb_fpregs[0] = ((u_int64_t)HPPA_FPU_INIT) << 32;
	pcb->pcb_fpregs[1] = 0;
	pcb->pcb_fpregs[2] = 0;
	pcb->pcb_fpregs[3] = 0;
	fdcache(HPPA_SID_KERNEL, (vaddr_t)pcb->pcb_fpregs, 8 * 4);
	if (tf->tf_cr30 == fpu_curpcb) {
		fpu_curpcb = 0;
		/* force an fpu ctxsw, we'll not be hugged by the cpu_switch */
		mtctl(0, CR_CCR);
	}

a1179 2
	tf->tf_r3 = stack;
	suword((caddr_t)(stack), 0);
d1181 2
a1182 1
	suword((caddr_t)(stack + HPPA_FRAME_CRP), 0);
d1200 1
d1203 1
a1203 2
	struct sigcontext ksc, *scp;
	siginfo_t ksi, *sip;
a1224 1
	sip = NULL;
d1227 2
a1228 2
		sip = (siginfo_t *)(scp + 1);
		if (copyout((caddr_t)&ksi, sip, sizeof(ksi)))
d1244 2
a1245 2
	if (suword((caddr_t)scp + sss - HPPA_FRAME_SIZE, 0) ||
	    suword((caddr_t)scp + sss + HPPA_FRAME_CRP, 0))
d1259 2
a1260 1
	tf->tf_iioq_head = HPPA_PC_PRIV_USER | p->p_sigcode;
d1295 3
a1297 3
#define PSL_MBS (PSL_C|PSL_Q|PSL_P|PSL_D|PSL_I)
#define PSL_MBZ (PSL_Y|PSL_Z|PSL_S|PSL_X|PSL_M|PSL_R)
	if ((ksc.sc_ps & (PSL_MBS|PSL_MBZ)) != PSL_MBS)
@


1.47.2.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d59 6
d118 2
a119 2
int cold = 1;			/* unset when engine is up to go */
extern int msgbufmapped;	/* set when safe to use msgbuf */
d142 1
a142 1
u_int	cpu_itmr, cpu_ticksnum, cpu_ticksdenom, cpu_hzticks;
d188 1
d190 1
d241 2
a242 2
	{ "PCXS",   hpcx,  0x10, 0,
	  desidhash_s, itlb_s, itlbna_s, dtlb_s, dtlbna_s, tlbd_s,
d246 2
a247 2
	{ "PCXT",  hpcxs, 0x11, HPPA_FTRS_BTLBU,
	  desidhash_t, itlb_t, itlbna_t, dtlb_t, dtlbna_t, tlbd_t,
d251 3
a253 1
/* these seem to support the cpu model pdc call */
d415 2
a416 4
	if (!pdc_call((iodcio_t)pdc, 0, PDC_TLB, PDC_TLB_INFO, &pdc_hwtlb) &&
	    pdc_hwtlb.min_size && pdc_hwtlb.max_size)
		cpu_features |= HPPA_FTRS_HVT;
	else {
d419 2
a420 1
	}
d430 1
a430 1
		    p->arch && p->features != cpu_features; p++);
d450 2
a451 2
			cpu_type = p->type;
			cpu_typename = p->name;
d454 1
a454 1
			cpu_hpt_init = p->hptinit;
d480 1
a480 1
				snprintf(buf, sizeof buf, "(UNKNOWN 0x%x)", hv);
a498 3
					lev = 0xc;
				/* this one is a pcxl2 */
				if (lev == 0x16)
d510 1
a510 2
		snprintf(cpu_model, sizeof cpu_model,
		    "HP 9000/%s PA-RISC %s%x", p, q, lev);
d542 1
a542 1

d548 12
d605 1
a605 1
cpu_startup(void)
d657 1
a657 1
			    UVM_PROT_RW);
d747 1
a750 22
void
microtime(struct timeval *tv)
{
	u_int itmr;
	int s;

	s = splhigh();
	tv->tv_sec  = time.tv_sec;
	tv->tv_usec = time.tv_usec;

	mfctl(CR_ITMR, itmr);
	itmr -= cpu_itmr;
	splx(s);

	tv->tv_usec += itmr * cpu_ticksdenom / cpu_ticksnum;
	if (tv->tv_usec > 1000000) {
		tv->tv_usec -= 1000000;
		tv->tv_sec++;
	}
}


d766 1
a766 1
fcacheall(void)
d780 1
a780 1
ptlball(void)
d811 1
a811 1
desidhash_g(void)
d944 1
a944 2
			DELAY(1000000);
			(*cold_hook)(HPPA_COLD_OFF);
a948 1
		DELAY(1000000);
d972 1
a972 1
cpu_dumpsize(void)
d987 1
a987 1
hpmc_dump(void)
d996 1
a996 1
cpu_dump(void)
d1026 1
a1026 1
dumpsys(void)
d1060 1
a1060 1

d1158 1
a1158 1
	struct proc *p;
d1164 2
a1165 3
	struct trapframe *tf = p->p_md.md_regs;
	struct pcb *pcb = &p->p_addr->u_pcb;
	register_t zero;
d1173 1
a1180 8
	/* setup terminal stack frame */
	stack = (stack + 0x1f) & ~0x1f;
	tf->tf_r3 = stack;
	tf->tf_sp = stack += HPPA_FRAME_SIZE;
	zero = 0;
	copyout(&zero, (caddr_t)(stack - HPPA_FRAME_SIZE), sizeof(register_t));
	copyout(&zero, (caddr_t)(stack + HPPA_FRAME_CRP), sizeof(register_t));

d1193 8
a1220 1
	register_t zero;
d1261 2
a1262 5
	zero = 0;
	if (copyout(&zero, (caddr_t)scp + sss - HPPA_FRAME_SIZE,
	    sizeof(register_t)) ||
	    copyout(&zero, (caddr_t)scp + sss + HPPA_FRAME_CRP,
	    sizeof(register_t)))
a1299 1
	int error;
d1307 3
a1309 2
	if ((error = copyin((caddr_t)scp, (caddr_t)&ksc, sizeof ksc)))
		return (error);
d1415 1
a1415 1
consinit(void)
@


1.46
log
@zap some typedefs.
vm_map_t -> struct vm_map *
vm_map_entry_t -> struct vm_map_entry *
simple_lock_data_t -> struct simplelock

(uvm not done yet, coming in the next commit)
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.45 2001/11/28 13:47:38 art Exp $	*/
d165 1
a165 1
long mem_ex_storage[EXTENT_FIXED_STORAGE_SIZE(8) / sizeof(long)];
@


1.45
log
@Sync in more uvm changes from NetBSD.
This time we're getting rid of KERN_* and VM_PAGER_* error codes and
use errnos instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.44 2001/11/24 17:53:41 miod Exp $	*/
d168 3
a170 3
vm_map_t exec_map = NULL;
vm_map_t mb_map = NULL;
vm_map_t phys_map = NULL;
@


1.44
log
@Harmonize boot() logic across arches:
- ensure RB_DUMP | RB_HALT will cause a dump
- or RB_HALT if (cold)
While there, honor RB_TIMEBAD on sparc64.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.43 2001/11/09 15:25:55 art Exp $	*/
d611 1
a611 1
	    UVM_PROT_NONE, UVM_INH_NONE, UVM_ADV_NORMAL, 0)) != KERN_SUCCESS)
@


1.43
log
@nswbuf hasn't been used for ages. gc.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.42 2001/11/07 01:18:00 art Exp $	*/
d888 5
a892 4
	if (cold)
		/* XXX howto |= RB_HALT */;
	else {
		boothowto = howto | (boothowto & RB_HALT);
d894 1
a894 2
		if (!(howto & RB_NOSYNC) && waittime < 0) {
			extern struct proc proc0;
d896 12
a907 11
			/* protect against curproc->p_stats refs in sync XXX */
			if (curproc == NULL)
				curproc = &proc0;

			waittime = 0;
			vfs_shutdown();
			if ((howto & RB_TIMEBAD) == 0)
				resettodr();
			else
				printf("WARNING: not updating battery clock\n");
		}
d914 1
a914 1
	if ((howto & (RB_DUMP /* | RB_HALT */)) == RB_DUMP)
d917 1
@


1.42
log
@Add an alignment argument to uvm_map that specifies an alignment hint
for the virtual address.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.41 2001/11/06 19:53:14 miod Exp $	*/
a98 1
int nswbuf = 0;
a464 6

	if (nswbuf == 0) {
		nswbuf = (nbuf / 2) &~ 1;
		if (nswbuf > 256)
			nswbuf = 256;
	}
@


1.41
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.40 2001/09/19 20:50:56 mickey Exp $	*/
d617 2
a618 2
	    NULL, UVM_UNKNOWN_OFFSET, UVM_MAPFLAG(UVM_PROT_NONE, UVM_PROT_NONE,
	    UVM_INH_NONE, UVM_ADV_NORMAL, 0)) != KERN_SUCCESS)
@


1.40
log
@merge vm/vm_kern.h into uvm/uvm_extern.h; art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.39 2001/09/12 00:23:33 art Exp $	*/
d70 1
a70 1
#include <vm/vm.h>
a71 1
#include <uvm/uvm.h>
@


1.39
log
@mbutl no more
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.38 2001/08/23 14:01:03 art Exp $	*/
a70 1
#include <vm/vm_kern.h>
@


1.38
log
@We can now move timeout_init into main().
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.37 2001/08/23 12:02:04 art Exp $	*/
d665 1
a665 1
	mb_map = uvm_km_suballoc(kernel_map, (vaddr_t *)&mbutl, &maxaddr,
@


1.37
log
@Remove even more old timeout tentacles.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.36 2001/07/25 13:25:31 art Exp $	*/
a666 5

	/*
	 * Initialize timeouts
	 */
	timeout_init();
@


1.36
log
@Change the pmap_enter interface to merge access_type and the wired boolean
and arbitrary flags into one argument.

One new flag is PMAP_CANFAIL that tells pmap_enter that it can fail if there
are not enough resources to satisfy the request. If this flag is not passed,
pmap_enter should panic as it should have done before this change (XXX - many
pmaps are still not doing that).

Only i386 and alpha implement CANFAIL for now.

Includes uvm updates from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.35 2001/07/05 10:12:08 art Exp $	*/
a477 1
	valloc(timeouts, struct timeout, ntimeout);
@


1.35
log
@Get rid of REAL_CLISTS. It was never implemented and the tentacles are
everywhhere.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.34 2001/05/17 18:41:48 provos Exp $	*/
d647 1
a647 1
			    TRUE, VM_PROT_READ|VM_PROT_WRITE);
@


1.34
log
@convert mbuf and cluster allocation to pool, mostly from NetBSD
okay art@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.33 2001/05/05 22:33:40 art Exp $	*/
a476 4

#ifdef REAL_CLISTS
	valloc(cfree, struct cblock, nclist);
#endif
@


1.33
log
@Rename configure() to cpu_configure().
Move it from cpu_startup() to main().
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.32 2001/05/05 20:56:36 art Exp $	*/
a669 7
	/*
	 * Finally, allocate mbuf pool.  Since mclrefcnt is an off-size
	 * we use the more space efficient malloc in place of kmem_alloc.
	 */
	mclrefcnt = (char *)malloc(NMBCLUSTERS+PAGE_SIZE/MCLBYTES,
	    M_MBUF, M_NOWAIT);
	bzero(mclrefcnt, NMBCLUSTERS+PAGE_SIZE/MCLBYTES);
@


1.32
log
@Get rid of CLSIZE and all related stuff.
CLSIZE -> 1
CLBYTES -> PAGE_SIZE
OLOFSET -> PAGE_MASK
etc.
At the same time some archs needed some cleaning in vmparam.h so that
goes in at the same time.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.31 2001/03/29 00:47:53 mickey Exp $	*/
a706 1
	configure();
@


1.31
log
@cpudev_data.h here needed not
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.30 2001/03/22 23:40:55 mickey Exp $	*/
d466 2
a467 2
	if (bufpages > nbuf * MAXBSIZE / CLBYTES)
		bufpages = nbuf * MAXBSIZE / CLBYTES;
d643 1
a643 1
		curbufsize = CLBYTES * ((i < residual) ? (base+1) : base);
d674 1
a674 1
	mclrefcnt = (char *)malloc(NMBCLUSTERS+CLBYTES/MCLBYTES,
d676 1
a676 1
	bzero(mclrefcnt, NMBCLUSTERS+CLBYTES/MCLBYTES);
d690 1
a690 1
	    nbuf, bufpages * CLBYTES);
@


1.30
log
@shuffle the tlb handlers a little,
make a new one for na data fault,
since those w/ hpt need it.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.29 2000/08/15 20:21:49 mickey Exp $	*/
a96 1
#include <hppa/dev/cpudevs_data.h>
@


1.29
log
@two btlb routines (i & d) for pcxs
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.28 2000/08/15 20:12:14 mickey Exp $	*/
d199 4
a202 4
extern u_int itlb_x[], dtlb_x[], tlbd_x[];
extern u_int itlb_s[], dtlb_s[], tlbd_s[];
extern u_int itlb_t[], dtlb_t[], tlbd_t[];
extern u_int itlb_l[], dtlb_l[], tlbd_l[];
d227 1
a227 1
	u_int *itlbh, *dtlbh, *tlbdh;
d237 2
a238 1
	    desidhash_x, itlb_x, dtlb_x, tlbd_x, ibtlb_g, NULL, pbtlb_g},
d242 2
a243 1
	    desidhash_s, itlb_s, dtlb_s, tlbd_s, ibtlb_g, NULL, pbtlb_g},
d247 2
a248 1
	    desidhash_t, itlb_t, dtlb_t, tlbd_t, ibtlb_g, NULL, pbtlb_g},
d250 2
a251 1
	    desidhash_t, itlb_t, dtlb_t, tlbd_t, ibtlb_g, NULL, pbtlb_g}, */
d255 2
a256 1
	    desidhash_l, itlb_l, dtlb_l, tlbd_l, ibtlb_g, NULL, pbtlb_g, hpti_g},
d260 2
a261 1
	    desidhash_l, itlb_l, dtlb_l, tlbd_l, ibtlb_g, NULL, pbtlb_g, hpti_g}, */
d265 2
a266 1
	    desidhash_g, itlb_l, dtlb_l, tlbd_l, ibtlb_g, NULL, pbtlb_g, hpti_g},
d270 2
a271 1
	    desidhash_g, itlb_l, dtlb_l, tlbd_l, ibtlb_g, NULL, pbtlb_g, hpti_g}, */
d275 7
a281 1
	    desidhash_g, itlb_l, dtlb_l, tlbd_l, ibtlb_g, NULL, pbtlb_g, hpti_g}, */
d374 2
a375 1
	for (hptsize = 256; hptsize < totalphysmem; hptsize *= 2);
d412 2
a414 1
			extern u_int trap_ep_T_DTLBMISS[];
a415 1
			extern u_int trap_ep_T_DTLBMISSNA[];
d426 2
a428 1
			LDILDO(trap_ep_T_DTLBMISS  , p->dtlbh);
a429 1
			LDILDO(trap_ep_T_DTLBMISSNA, p->dtlbh);
d1198 2
d1207 1
d1209 3
@


1.28
log
@expand per-cpu control routines switch
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.27 2000/08/08 21:46:05 mickey Exp $	*/
d157 3
a159 1
int (*cpu_btlb_ins) __P((int i, pa_space_t sp, vaddr_t va, paddr_t pa,
d203 3
a205 1
int ibtlb_s __P((int i, pa_space_t sp, vaddr_t va, paddr_t pa,
d228 3
a230 1
	int (*btlbins) __P((int i, pa_space_t sp, vaddr_t va, paddr_t pa,
d237 1
a237 1
	    desidhash_x, itlb_x, dtlb_x, tlbd_x, ibtlb_g, pbtlb_g},
d241 1
a241 1
	    desidhash_s, itlb_s, dtlb_s, tlbd_s, ibtlb_g, pbtlb_g},
d245 1
a245 1
	    desidhash_t, itlb_t, dtlb_t, tlbd_t, ibtlb_g, pbtlb_g},
d247 1
a247 1
	    desidhash_t, itlb_t, dtlb_t, tlbd_t, ibtlb_g, pbtlb_g}, */
d251 1
a251 1
	    desidhash_l, itlb_l, dtlb_l, tlbd_l, ibtlb_g, pbtlb_g, hpti_g},
d255 1
a255 1
	    desidhash_l, itlb_l, dtlb_l, tlbd_l, ibtlb_g, pbtlb_g, hpti_g}, */
d259 1
a259 1
	    desidhash_g, itlb_l, dtlb_l, tlbd_l, ibtlb_g, pbtlb_g, hpti_g},
d263 1
a263 1
	    desidhash_g, itlb_l, dtlb_l, tlbd_l, ibtlb_g, pbtlb_g, hpti_g}, */
d267 1
a267 1
	    desidhash_g, itlb_l, dtlb_l, tlbd_l, ibtlb_g, pbtlb_g, hpti_g}, */
d404 2
a405 1
			cpu_btlb_ins  = p->btlbins;
d888 1
a888 1
	if ((error = (*cpu_btlb_ins)(i, space, va, pa, len, prot)) < 0)
@


1.27
log
@print btlb params w/ BTLBDEBUG; from Havard.Eidnes@@runit.sintef.no
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.26 2000/07/02 03:59:51 mickey Exp $	*/
d121 3
a123 1
 * things to kill
d125 2
a126 3
int icache_stride;
int dcache_stride;
int dcache_line_mask;
d139 1
d142 1
d147 1
a147 2
int (*cpu_btlb_ins) __P((int i, pa_space_t sp, vaddr_t va, paddr_t pa,
	    vsize_t sz, u_int prot));
d152 8
d186 1
d201 16
a216 2
int btlb_g __P((int i, pa_space_t sp, vaddr_t va, paddr_t pa,
	    vsize_t sz, u_int prot));
d218 1
a218 1
	char symid[8];
d222 1
d226 2
d229 1
d231 3
a233 1
				itlb_x, dtlb_x, tlbd_x, btlb_g},
d235 3
a237 1
				itlb_s, dtlb_s, tlbd_s, btlb_g},
d239 5
a243 3
				itlb_t, dtlb_t, tlbd_t, btlb_g},
	{ "PCXT'", hpcxta,0x11, HPPA_FTRS_BTLBU,
				itlb_t, dtlb_t, tlbd_t, btlb_g},
d245 7
a251 3
				itlb_l, dtlb_l, tlbd_l, btlb_g},
	{ "PCXL2", hpcxl2,0x11, HPPA_FTRS_BTLBU|HPPA_FTRS_HVT,
				itlb_l, dtlb_l, tlbd_l, btlb_g},
d253 10
a262 5
				itlb_l, dtlb_l, tlbd_l, btlb_g},
	{ "PCXU2", hpcxu2,0x20, HPPA_FTRS_W32B|HPPA_FTRS_BTLBU|HPPA_FTRS_HVT,
				itlb_l, dtlb_l, tlbd_l, btlb_g},
	{ "PCXW",  hpcxw, 0x20, HPPA_FTRS_W32B|HPPA_FTRS_BTLBU|HPPA_FTRS_HVT,
				itlb_l, dtlb_l, tlbd_l, btlb_g},
a290 1
	/* XXX these gonna die */
d293 1
d304 3
d385 17
a401 10
		/*
		 * Ptrs to various tlb handlers, to be filled based on cpu
		 * features.
		 * from locore.S
		 */
		extern u_int trap_ep_T_TLB_DIRTY[];
		extern u_int trap_ep_T_ITLBMISS[];
		extern u_int trap_ep_T_DTLBMISS[];
		extern u_int trap_ep_T_ITLBMISSNA[];
		extern u_int trap_ep_T_DTLBMISSNA[];
a402 7

#ifdef DEBUG
			printf("cputype: %s\n", p->symid);
#endif
			cpu_type = p->type;

			cpu_btlb_ins = p->btlbins;
d498 1
a498 3
		if ((error = pdc_call((iodcio_t)pdc, 0, PDC_TLB,
		    PDC_TLB_CONFIG, &pdc_hwtlb, hpt, hptsize,
		    PDC_TLB_CURRPDE)) < 0) {
d546 6
a551 1
	/* good night */
d800 25
a824 1
btlb_g(i, sp, va, pa, sz, prot)
@


1.26
log
@no bays for stinger
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.25 2000/03/23 20:25:41 mickey Exp $	*/
a33 2
#undef BTLBDEBUG

d279 12
@


1.25
log
@new cpu type switch code.
initializes tlb miss handlers correspondent to probed cpu features.
also btlb load routine.
versions written are for pcxl and others.
cpu-dep btlb loaders are missing, only generic for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.24 2000/03/23 09:59:54 art Exp $	*/
a535 19

	/*
	 * Kludge for STI graphics, which may have rom outside the IO space
	 */
#include "sti.h"
#if NSTI > 0
	{
		vaddr_t addr = PAGE0->pd_resv2[1];

		/* reserve virtual address space for the sti rom */
		if (addr && addr < 0xf0000000 &&
		    uvm_map(kernel_map, &addr, 0x1000000, NULL,
			UVM_UNKNOWN_OFFSET, UVM_MAPFLAG(UVM_PROT_NONE,
			    UVM_PROT_NONE, UVM_INH_NONE, UVM_ADV_NORMAL,
			    UVM_FLAG_FIXED)) != KERN_SUCCESS)
			printf("WARNING: don't have space for stinger @@0x%x\n",
			    addr);
	}
#endif
@


1.24
log
@New API for timeouts. Replaces the old timeout()/untimeout() API and
makes it the callers responsibility to allocate resources for the
timeouts.

This is a KISS implementation and does _not_ solve the problems of slow
handling of a large number of pending timeouts (this will be solved in
future work) (although hardclock is now guarateed to take constant time
for handling of timeouts).

Old timeout() and untimeout() are implemented as wrappers around the new
API and kept for compatibility. They will be removed as soon as all
subsystems are converted to use the new API.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.23 2000/03/16 22:11:03 art Exp $	*/
d145 3
d185 38
d232 1
d276 9
a284 2
	    PDC_BTLB_DEFAULT, &pdc_btlb)) < 0)
		panic("WARNING: PDC_BTLB error %d", error);
d286 3
a288 3
	/* purge TLBs and caches */
	if (pdc_call((iodcio_t)pdc, 0, PDC_BLOCK_TLB, PDC_BTLB_PURGE_ALL) < 0)
		printf("WARNING: BTLB purge failed\n");
d297 2
a298 2
	for (hptsize = 1; hptsize < totalphysmem; hptsize *= 2);
	mtctl(hptsize - 1, CR_HPTMASK);
d303 1
d306 2
a311 1
		/* have to reload after adjustment */
d315 40
d759 20
d816 1
a816 5
	if ((error = pdc_call((iodcio_t)pdc, 0, PDC_BLOCK_TLB,PDC_BTLB_INSERT,
	    space, va, pa, len, prot, i)) < 0) {
#ifdef BTLBDEBUG
		printf("WARNING: BTLB insert failed (%d)\n", error);
#endif
a817 1
	}
@


1.23
log
@Bring in some new UVM code from NetBSD (not current).

 - Introduce a new type of map that are interrupt safe and never allow faults
   in them. mb_map and kmem_map are made intrsafe.
 - Add "access protection" to uvm_vslock (to be passed down to uvm_fault and
   later to pmap_enter).
 - madvise(2) now works.
 - various cleanups.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.22 2000/02/22 20:08:15 mickey Exp $	*/
d47 1
a47 1
#include <sys/callout.h>
d313 1
a313 1
	valloc(callout, struct callout, ncallout);
d528 1
a528 1
	 * Initialize callouts
d530 1
a530 4
	callfree = callout;
	for (i = 1; i < ncallout; i++)
		callout[i-1].c_next = &callout[i];
	callout[i-1].c_next = NULL;
@


1.22
log
@blah, blah, blah, msgbuf
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.21 2000/02/09 05:04:22 mickey Exp $	*/
d509 1
a509 1
	    16*NCARGS, TRUE, FALSE, NULL);
d515 1
a515 1
	    VM_PHYS_SIZE, TRUE, FALSE, NULL);
d525 1
a525 1
	    VM_MBUF_SIZE, FALSE, FALSE, NULL);
@


1.21
log
@heartbeat -- yeah we have a patch for that
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.20 2000/01/25 22:11:39 mickey Exp $	*/
d341 1
a341 2
	if (!(msgbufp = (void *)pmap_steal_memory(sizeof(struct msgbuf),
	    NULL, NULL)))
@


1.21.2.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d341 2
a342 1
	if (!(msgbufp = (void *)pmap_steal_memory(MSGBUFSIZE, NULL, NULL)))
@


1.21.2.2
log
@Sync with -current
@
text
@d47 1
a47 1
#include <sys/timeout.h>
a144 3
enum hppa_cpu_type cpu_type;
int (*cpu_btlb_ins) __P((int i, pa_space_t sp, vaddr_t va, paddr_t pa,
	    vsize_t sz, u_int prot));
a181 38
/*
 * Whatever CPU types we support
 */
extern u_int itlb_x[], dtlb_x[], tlbd_x[];
extern u_int itlb_s[], dtlb_s[], tlbd_s[];
extern u_int itlb_t[], dtlb_t[], tlbd_t[];
extern u_int itlb_l[], dtlb_l[], tlbd_l[];
int btlb_g __P((int i, pa_space_t sp, vaddr_t va, paddr_t pa,
	    vsize_t sz, u_int prot));
const struct hppa_cpu_typed {
	char symid[8];
	enum hppa_cpu_type type;
	int  arch;
	int  features;
	u_int *itlbh, *dtlbh, *tlbdh;
	int (*btlbins) __P((int i, pa_space_t sp, vaddr_t va, paddr_t pa,
	    vsize_t sz, u_int prot));
} cpu_types[] = {
	{ "PCX",   hpcx,  0x10, 0,
				itlb_x, dtlb_x, tlbd_x, btlb_g},
	{ "PCXS",  hpcxs, 0x11, HPPA_FTRS_BTLBS,
				itlb_s, dtlb_s, tlbd_s, btlb_g},
	{ "PCXT",  hpcxt, 0x11, HPPA_FTRS_BTLBU,
				itlb_t, dtlb_t, tlbd_t, btlb_g},
	{ "PCXT'", hpcxta,0x11, HPPA_FTRS_BTLBU,
				itlb_t, dtlb_t, tlbd_t, btlb_g},
	{ "PCXL",  hpcxl, 0x11, HPPA_FTRS_BTLBU|HPPA_FTRS_HVT,
				itlb_l, dtlb_l, tlbd_l, btlb_g},
	{ "PCXL2", hpcxl2,0x11, HPPA_FTRS_BTLBU|HPPA_FTRS_HVT,
				itlb_l, dtlb_l, tlbd_l, btlb_g},
	{ "PCXU",  hpcxu, 0x20, HPPA_FTRS_W32B|HPPA_FTRS_BTLBU|HPPA_FTRS_HVT,
				itlb_l, dtlb_l, tlbd_l, btlb_g},
	{ "PCXU2", hpcxu2,0x20, HPPA_FTRS_W32B|HPPA_FTRS_BTLBU|HPPA_FTRS_HVT,
				itlb_l, dtlb_l, tlbd_l, btlb_g},
	{ "PCXW",  hpcxw, 0x20, HPPA_FTRS_W32B|HPPA_FTRS_BTLBU|HPPA_FTRS_HVT,
				itlb_l, dtlb_l, tlbd_l, btlb_g},
	{ "", 0 }
};
a190 1
	int cpu_features = 0;
d234 2
a235 9
	    PDC_BTLB_DEFAULT, &pdc_btlb)) < 0) {
#ifdef DEBUG
		printf("WARNING: PDC_BTLB error %d", error);
#endif
	} else {
		/* purge TLBs and caches */
		if (pdc_call((iodcio_t)pdc, 0, PDC_BLOCK_TLB,
		    PDC_BTLB_PURGE_ALL) < 0)
			printf("WARNING: BTLB purge failed\n");
d237 3
a239 3
		cpu_features = pdc_btlb.finfo.num_c?
		    HPPA_FTRS_BTLBU : HPPA_FTRS_BTLBS;
	}
d248 2
a249 2
	for (hptsize = 256; hptsize < totalphysmem; hptsize *= 2);
	hptsize *= 16;	/* sizeof(hpt_entry) */
a253 1
		mtctl(hptsize - 1, CR_HPTMASK);
a255 2
		cpu_features |= HPPA_FTRS_HVT;

d260 1
a263 40
	/*
	 * Deal w/ CPU now
	 */
	{
		const struct hppa_cpu_typed *p;

		for (p = cpu_types;
		     p->arch && p->features != cpu_features; p++);

		if (!p->arch)
			printf("WARNING: UNKNOWN CPU TYPE; GOOD LUCK (%x)\n",
			    cpu_features);
		else {
		/*
		 * Ptrs to various tlb handlers, to be filled based on cpu
		 * features.
		 * from locore.S
		 */
		extern u_int trap_ep_T_TLB_DIRTY[];
		extern u_int trap_ep_T_ITLBMISS[];
		extern u_int trap_ep_T_DTLBMISS[];
		extern u_int trap_ep_T_ITLBMISSNA[];
		extern u_int trap_ep_T_DTLBMISSNA[];
#define	LDILDO(t,f) ((t)[0] = (f)[0], (t)[1] = (f)[1])

#ifdef DEBUG
			printf("cputype: %s\n", p->symid);
#endif
			cpu_type = p->type;

			cpu_btlb_ins = p->btlbins;
			LDILDO(trap_ep_T_TLB_DIRTY , p->tlbdh);
			LDILDO(trap_ep_T_ITLBMISS  , p->itlbh);
			LDILDO(trap_ep_T_DTLBMISS  , p->dtlbh);
			LDILDO(trap_ep_T_ITLBMISSNA, p->itlbh);
			LDILDO(trap_ep_T_DTLBMISSNA, p->dtlbh);
#undef LDILDO
		}
	}

d313 1
a313 1
	valloc(timeouts, struct timeout, ntimeout);
d509 1
a509 1
	    16*NCARGS, VM_MAP_PAGEABLE, FALSE, NULL);
d515 1
a515 1
	    VM_PHYS_SIZE, 0, FALSE, NULL);
d525 1
a525 1
	    VM_MBUF_SIZE, VM_MAP_INTRSAFE, FALSE, NULL);
d528 1
a528 1
	 * Initialize timeouts
d530 4
a533 1
	timeout_init();
a670 20
btlb_g(i, sp, va, pa, sz, prot)
	int i;
	pa_space_t sp;
	vaddr_t va;
	paddr_t pa;
	vsize_t sz;
	u_int prot;
{
	int error;

	if ((error = pdc_call((iodcio_t)pdc, 0, PDC_BLOCK_TLB, PDC_BTLB_INSERT,
	    sp, va, pa, sz, prot, i)) < 0) {
#ifdef BTLBDEBUG
		printf("WARNING: BTLB insert failed (%d)\n", error);
#endif
	}
	return error;
}

int
d708 5
a712 1
	if ((error = (*cpu_btlb_ins)(i, space, va, pa, len, prot)) < 0)
d714 1
@


1.21.2.3
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.31 2001/03/29 00:47:53 mickey Exp $	*/
d34 2
d99 1
d123 1
a123 3
 * cache configuration, for most machines is the same
 * numbers, so it makes sense to do defines w/ numbers depending
 * on cofigured cpu types in the kernel
d125 3
a127 2
int icache_stride, icache_line_mask;
int dcache_stride, dcache_line_mask;
a139 1

a141 1

d146 2
a147 1
const char *cpu_typename;
a151 10
/*
 * exported methods for cpus
 */
int (*cpu_desidhash) __P((void));
int (*cpu_hpt_init) __P((vaddr_t hpt, vsize_t hptsize));
int (*cpu_ibtlb_ins) __P((int i, pa_space_t sp, vaddr_t va, paddr_t pa,
	    vsize_t sz, u_int prot));
int (*cpu_dbtlb_ins) __P((int i, pa_space_t sp, vaddr_t va, paddr_t pa,
	    vsize_t sz, u_int prot));

a177 1
struct pdc_spidb pdc_spidbits PDC_ALIGNMENT;
d188 6
a193 22
extern const u_int itlb_x[], dtlb_x[], dtlbna_x[], tlbd_x[];
extern const u_int itlb_s[], dtlb_s[], dtlbna_s[], tlbd_s[];
extern const u_int itlb_t[], dtlb_t[], dtlbna_t[], tlbd_t[];
extern const u_int itlb_l[], dtlb_l[], dtlbna_l[], tlbd_l[];
int iibtlb_s __P((int i, pa_space_t sp, vaddr_t va, paddr_t pa,
    vsize_t sz, u_int prot));
int idbtlb_s __P((int i, pa_space_t sp, vaddr_t va, paddr_t pa,
    vsize_t sz, u_int prot));
int ibtlb_t __P((int i, pa_space_t sp, vaddr_t va, paddr_t pa,
    vsize_t sz, u_int prot));
int ibtlb_l __P((int i, pa_space_t sp, vaddr_t va, paddr_t pa,
    vsize_t sz, u_int prot));
int ibtlb_g __P((int i, pa_space_t sp, vaddr_t va, paddr_t pa,
    vsize_t sz, u_int prot));
int pbtlb_g __P((int i));
int hpti_l __P((vaddr_t, vsize_t));
int hpti_g __P((vaddr_t, vsize_t));
int desidhash_x __P((void));
int desidhash_s __P((void));
int desidhash_t __P((void));
int desidhash_l __P((void));
int desidhash_g __P((void));
d195 1
a195 1
	char name[8];
d199 2
a200 5
	int (*desidhash) __P((void));
	const u_int *itlbh, *dtlbh, *dtlbnah, *tlbdh;
	int (*dbtlbins) __P((int i, pa_space_t sp, vaddr_t va, paddr_t pa,
	    vsize_t sz, u_int prot));
	int (*ibtlbins) __P((int i, pa_space_t sp, vaddr_t va, paddr_t pa,
a201 2
	int (*btlbprg) __P((int i));
	int (*hptinit) __P((vaddr_t hpt, vsize_t hptsize));
a202 1
#ifdef HP7000_CPU
d204 1
a204 4
	  desidhash_x, itlb_x, dtlb_x, dtlbna_x, tlbd_x,
	  ibtlb_g, NULL, pbtlb_g},
#endif
#ifdef HP7100_CPU
d206 1
a206 4
	  desidhash_s, itlb_s, dtlb_s, dtlbna_s, tlbd_s,
	  ibtlb_g, NULL, pbtlb_g},
#endif
#ifdef HP7200_CPU
d208 3
a210 7
	  desidhash_t, itlb_t, dtlb_t, dtlbna_t, tlbd_t,
	  ibtlb_g, NULL, pbtlb_g},
/* HOW?	{ "PCXT'", hpcxta,0x11, HPPA_FTRS_BTLBU,
	  desidhash_t, itlb_t, dtlb_t, dtlbna_t, tlbd_t,
	  ibtlb_g, NULL, pbtlb_g}, */
#endif
#ifdef HP7100LC_CPU
d212 3
a214 9
	  desidhash_l, itlb_l, dtlb_l, dtlbna_l, tlbd_l,
	  ibtlb_g, NULL, pbtlb_g, hpti_g},
#endif
#ifdef HP7300LC_CPU
/* HOW?	{ "PCXL2", hpcxl2,0x11, HPPA_FTRS_BTLBU|HPPA_FTRS_HVT,
	  desidhash_l, itlb_l, dtlb_l, dtlbna_l, tlbd_l,
	  ibtlb_g, NULL, pbtlb_g, hpti_g}, */
#endif
#ifdef HP8000_CPU
d216 5
a220 18
	  desidhash_g, itlb_l, dtlb_l, dtlbna_l, tlbd_l,
	  ibtlb_g, NULL, pbtlb_g, hpti_g},
#endif
#ifdef HP8200_CPU
/* HOW?	{ "PCXU2", hpcxu2,0x20, HPPA_FTRS_W32B|HPPA_FTRS_BTLBU|HPPA_FTRS_HVT,
	  desidhash_g, itlb_l, dtlb_l, dtlbna_l, tlbd_l,
	  ibtlb_g, NULL, pbtlb_g, hpti_g}, */
#endif
#ifdef HP8500_CPU
/* HOW?	{ "PCXW",  hpcxw, 0x20, HPPA_FTRS_W32B|HPPA_FTRS_BTLBU|HPPA_FTRS_HVT,
	  desidhash_g, itlb_l, dtlb_l, dtlbna_l, tlbd_l,
	  ibtlb_g, NULL, pbtlb_g, hpti_g}, */
#endif
#ifdef HP8600_CPU
/* HOW?	{ "PCXW+", hpcxw, 0x20, HPPA_FTRS_W32B|HPPA_FTRS_BTLBU|HPPA_FTRS_HVT,
	  desidhash_g, itlb_l, dtlb_l, dtlbna_l, tlbd_l,
	  ibtlb_g, NULL, pbtlb_g, hpti_g}, */
#endif
d249 1
a251 1
	icache_line_mask = pdc_cache.ic_conf.cc_line * 16 - 1;
a261 3
	error = pdc_call((iodcio_t)pdc, 0, PDC_CACHE, PDC_CACHE_GETSPIDB,
	    &pdc_spidbits, 0, 0, 0, 0);
	printf("SPID bits: 0x%x, error = %d\n", pdc_spidbits.spidbits, error);
a280 12
#ifdef BTLBDEBUG
		printf("btlb info: minsz=%d, maxsz=%d\n",
		    pdc_btlb.min_size, pdc_btlb.max_size);
		printf("btlb fixed: i=%d, d=%d, c=%d\n",
		    pdc_btlb.finfo.num_i,
		    pdc_btlb.finfo.num_d,
		    pdc_btlb.finfo.num_c);
		printf("btlb varbl: i=%d, d=%d, c=%d\n",
		    pdc_btlb.vinfo.num_i,
		    pdc_btlb.vinfo.num_d,
		    pdc_btlb.vinfo.num_c);
#endif /* BTLBDEBUG */
d297 1
a297 2
	/* for (hptsize = 256; hptsize < totalphysmem; hptsize *= 2); */
hptsize=256;	/* XXX one page for now */
d328 16
a343 17
			/*
			 * Ptrs to various tlb handlers, to be filled
			 * based on cpu features.
			 * from locore.S
			 */
			extern u_int trap_ep_T_TLB_DIRTY[];
			extern u_int trap_ep_T_DTLBMISS[];
			extern u_int trap_ep_T_DTLBMISSNA[];
			extern u_int trap_ep_T_ITLBMISS[];
			extern u_int trap_ep_T_ITLBMISSNA[];

			cpu_type      = p->type;
			cpu_typename  = p->name;
			cpu_ibtlb_ins = p->ibtlbins;
			cpu_dbtlb_ins = p->dbtlbins;
			cpu_hpt_init  = p->hptinit;
			cpu_desidhash = p->desidhash;
d345 1
a345 1
#define	LDILDO(t,f) ((t)[0] = (f)[0], (t)[1] = (f)[1])
d347 1
a348 2
			LDILDO(trap_ep_T_DTLBMISSNA, p->dtlbnah);
			LDILDO(trap_ep_T_ITLBMISS  , p->itlbh);
d350 1
d441 3
a443 1
		if ((error = (cpu_hpt_init)(hpt, hptsize)) < 0) {
d491 1
a491 6
	/*
	 * i won't understand a friend of mine,
	 * who sat in a room full of artificial ice,
	 * fogging the air w/ humid cries --
	 *	WELCOME TO SUMMER!
	 */
d538 19
d759 1
a759 25
desidhash_g()
{
	/* TODO call PDC to disable SID hashing in the cache index */

	return 0;
}

int
hpti_g(hpt, hptsize)
	vaddr_t hpt;
	vsize_t hptsize;
{
	return pdc_call((iodcio_t)pdc, 0, PDC_TLB, PDC_TLB_CONFIG,
	    &pdc_hwtlb, hpt, hptsize, PDC_TLB_CURRPDE);
}

int
pbtlb_g(i)
	int i;
{
	return -1;
}

int
ibtlb_g(i, sp, va, pa, sz, prot)
d816 1
a816 1
	if ((error = (*cpu_dbtlb_ins)(i, space, va, pa, len, prot)) < 0)
a1110 2
	struct trapframe sf, *tf = p->p_md.md_regs;
	register_t sp = tf->tf_sp;
a1117 1
	sf = *tf;
a1118 3

	if (copyout(&sf, (void *)sp, sizeof(sf)))
		sigexit(p, SIGILL);
@


1.21.2.4
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.21.2.3 2001/04/18 16:06:13 niklas Exp $	*/
d466 2
a467 2
	if (bufpages > nbuf * MAXBSIZE / PAGE_SIZE)
		bufpages = nbuf * MAXBSIZE / PAGE_SIZE;
d643 1
a643 1
		curbufsize = PAGE_SIZE * ((i < residual) ? (base+1) : base);
d670 7
d690 1
a690 1
	    nbuf, bufpages * PAGE_SIZE);
d707 1
@


1.21.2.5
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.21.2.4 2001/07/04 10:16:03 niklas Exp $	*/
d71 1
d478 5
d651 1
a651 1
			    VM_PROT_READ|VM_PROT_WRITE|PMAP_WIRED);
d670 1
a670 1
	mb_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
d672 5
@


1.21.2.6
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d70 2
a72 1
#include <uvm/uvm_page.h>
d100 1
d467 6
d618 2
a619 2
	    NULL, UVM_UNKNOWN_OFFSET, 0, UVM_MAPFLAG(UVM_PROT_NONE,
	    UVM_PROT_NONE, UVM_INH_NONE, UVM_ADV_NORMAL, 0)) != KERN_SUCCESS)
@


1.21.2.7
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.21.2.6 2001/11/13 21:00:51 niklas Exp $	*/
d165 1
a165 1
long mem_ex_storage[EXTENT_FIXED_STORAGE_SIZE(32) / sizeof(long)];
d168 3
a170 3
struct vm_map *exec_map = NULL;
struct vm_map *mb_map = NULL;
struct vm_map *phys_map = NULL;
d611 1
a611 1
	    UVM_PROT_NONE, UVM_INH_NONE, UVM_ADV_NORMAL, 0)))
d888 4
a891 5
	/* If system is cold, just halt. */
	if (cold) {
		howto |= RB_HALT;
		goto haltsys;
	}
d893 2
a894 1
	boothowto = howto | (boothowto & RB_HALT);
d896 11
a906 12
	if (!(howto & RB_NOSYNC)) {
		waittime = 0;
		vfs_shutdown();
		/*
		 * If we've been adjusting the clock, the todr
		 * will be out of synch; adjust it now unless
		 * the system was sitting in ddb.
		 */
		if ((howto & RB_TIMEBAD) == 0)
			resettodr();
		else
			printf("WARNING: not updating battery clock\n");
d913 1
a913 1
	if (howto & RB_DUMP)
a915 1
haltsys:
@


1.21.2.8
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d4 1
a4 1
 * Copyright (c) 1999-2002 Michael Shalayeff
d38 1
a103 5

#ifndef BUFCACHEPERCENT
#define BUFCACHEPERCENT 10
#endif /* BUFCACHEPERCENT */

a108 1
int bufcachepercent = BUFCACHEPERCENT;
d169 1
d171 1
a171 2
/* Virtual page frame for /dev/mem (see mem.c) */
vaddr_t vmmap;
a176 1
void hppa_user2frame __P((struct trapframe *sf, struct trapframe *tf));
d187 1
a187 1
int sigdebug = 0;
d326 2
a327 2
		extern u_int hpmc_v[];	/* from locore.s */
		register u_int *p = hpmc_v;
d330 1
a330 1
			*p = 0x08000240;
a331 2
		p[6] = (u_int)&hpmc_dump;
		p[7] = 32;
a334 24
	{
		extern u_int hppa_toc[], hppa_toc_end[];
		register u_int cksum, *p;

		for (cksum = 0, p = hppa_toc; p < hppa_toc_end; p++)
			cksum += *p;

		*p = cksum;
		PAGE0->ivec_toc = (int (*)(void))hppa_toc;
		PAGE0->ivec_toclen = (hppa_toc_end - hppa_toc + 1) * 4;
	}

	{
		extern u_int hppa_pfr[], hppa_pfr_end[];
		register u_int cksum, *p;

		for (cksum = 0, p = hppa_pfr; p < hppa_pfr_end; p++)
			cksum += *p;

		*p = cksum;
		PAGE0->ivec_mempf = (int (*)(void))hppa_pfr;
		PAGE0->ivec_mempflen = (hppa_pfr_end - hppa_pfr + 1) * 4;
	}

d370 2
a371 1
	for (hptsize = 256; hptsize < totalphysmem; hptsize *= 2);
d446 3
d451 1
a451 1
		    (totalphysmem <= 0x1000? 5 : bufcachepercent);
a491 1
	/* sets physmem */
d493 1
a521 1
		extern u_int fpu_enable;
d526 1
a526 1
		fpu_enable = pdc_coproc.ccr_enable & CCR_MASK;
d656 3
a669 1
	vmmap = uvm_km_valloc_wait(kernel_map, NBPG);
d917 1
a918 4
haltsys:
	/* in case we came on powerfail interrupt */
	if (cold_hook)
		(*cold_hook)(HPPA_COLD_COLD);
a920 6
		if (howto & RB_POWERDOWN && cold_hook) {
			printf("Powering off...");
			(*cold_hook)(HPPA_COLD_COLD);
			DELAY(1000000);
		}

a959 1
	printf("HPMC\n");
a960 2
	cold = 0;
	boot(RB_NOSYNC);
d1022 1
a1022 1
		bytes = ctob(totalphysmem);
a1141 1
	/*
a1143 1
	*/
a1152 1
	stack = hppa_round_page(stack);
d1154 1
a1154 2
	suword((caddr_t)(stack - HPPA_FRAME_PSP), 0);
	suword((caddr_t)(stack - HPPA_FRAME_CRP), 0);
d1172 2
a1173 5
	struct sigcontext *scp, ksc;
	struct trapframe *tf = p->p_md.md_regs;
	struct sigacts *psp = p->p_sigacts;
	siginfo_t ksi, *sip = NULL;
	int sss;
d1176 1
a1176 1
	if ((sigdebug & SDB_FOLLOW) && (!sigpid || p->p_pid == sigpid))
d1181 2
a1182 1
	ksc.sc_onstack = psp->ps_sigstk.ss_flags & SS_ONSTACK;
d1184 1
a1184 32
	/*
	 * Allocate space for the signal handler context.
	 */
	if ((psp->ps_flags & SAS_ALTSTACK) && !ksc.sc_onstack &&
	    (psp->ps_sigonstack & sigmask(sig))) {
		scp = (struct sigcontext *)psp->ps_sigstk.ss_sp;
		psp->ps_sigstk.ss_flags |= SS_ONSTACK;
	} else
		scp = (struct sigcontext *)tf->tf_sp;

	sss = sizeof(*scp);
	if (psp->ps_siginfo & sigmask(sig)) {
		initsiginfo(&ksi, sig, code, type, val);
		sip = (void *)(scp + 1);
		if (copyout((caddr_t)&ksi, sip, sizeof(*sip)))
			sigexit(p, SIGILL);
		sss += sizeof(*sip);
	}

	ksc.sc_mask = mask;
	ksc.sc_sp = tf->tf_sp;
	ksc.sc_fp = (register_t)scp + sss;
	ksc.sc_ps = tf->tf_ipsw;
	ksc.sc_pcoqh = tf->tf_iioq_head;
	ksc.sc_pcoqt = tf->tf_iioq_tail;
	bcopy(tf, &ksc.sc_tf, sizeof(ksc.sc_tf));
	if (copyout((caddr_t)&ksc, scp, sizeof(*scp)))
		sigexit(p, SIGILL);

	sss += HPPA_FRAME_SIZE;
	if (suword((caddr_t)scp + sss - HPPA_FRAME_PSP, 0) ||
	    suword((caddr_t)scp + sss - HPPA_FRAME_CRP, 0))
a1185 24

#ifdef DEBUG
	if ((sigdebug & SDB_FOLLOW) && (!sigpid || p->p_pid == sigpid))
		printf("sendsig(%d): sig %d scp %p fp %p sp %x\n",
		    p->p_pid, sig, scp, ksc.sc_fp, ksc.sc_sp);
#endif

	tf->tf_arg0 = sig;
	tf->tf_arg1 = (register_t)sip;
	tf->tf_arg2 = tf->tf_r3 = (register_t)scp;
	tf->tf_arg3 = (register_t)catcher;
	tf->tf_sp = (register_t)scp + sss;
	tf->tf_iioq_head = HPPA_PC_PRIV_USER |
	    ((register_t)PS_STRINGS + sizeof(struct ps_strings));
	tf->tf_iioq_tail = tf->tf_iioq_head + 4;
	/* disable tracing in the trapframe */

	/* TODO FPU */

#ifdef DEBUG
	if ((sigdebug & SDB_FOLLOW) && (!sigpid || p->p_pid == sigpid))
		printf("sendsig(%d): pc %x, catcher %x\n", p->p_pid,
		    tf->tf_iioq_head, tf->tf_arg3);
#endif
d1194 2
a1195 81
	struct sys_sigreturn_args /* {
		syscallarg(struct sigcontext *) sigcntxp;
	} */ *uap = v;
	struct sigcontext *scp, ksc;
	struct trapframe *tf = p->p_md.md_regs;

	scp = SCARG(uap, sigcntxp);
#ifdef DEBUG
	if ((sigdebug & SDB_FOLLOW) && (!sigpid || p->p_pid == sigpid))
		printf("sigreturn: pid %d, scp %p\n", p->p_pid, scp);
#endif

	if (uvm_useracc((caddr_t)scp, sizeof (*scp), B_WRITE) == 0 ||
	    copyin((caddr_t)scp, (caddr_t)&ksc, sizeof ksc))
		return (EINVAL);

#define PSW_MBS (PSW_C|PSW_Q|PSW_P|PSW_D|PSW_I)
#define PSW_MBZ (PSW_Y|PSW_Z|PSW_S|PSW_X|PSW_M|PSW_R)
	if ((ksc.sc_ps & (PSW_MBS|PSW_MBZ)) != PSW_MBS)
		return (EINVAL);

	if (ksc.sc_onstack)
		p->p_sigacts->ps_sigstk.ss_flags |= SS_ONSTACK;
	else
		p->p_sigacts->ps_sigstk.ss_flags &= ~SS_ONSTACK;
	p->p_sigmask = ksc.sc_mask &~ sigcantmask;

	hppa_user2frame((struct trapframe *)&ksc.sc_tf, tf);

	tf->tf_sp = ksc.sc_sp;
	tf->tf_iioq_head = ksc.sc_pcoqh | HPPA_PC_PRIV_USER;
	tf->tf_iioq_tail = ksc.sc_pcoqt | HPPA_PC_PRIV_USER;
	tf->tf_ipsw = ksc.sc_ps;

	/* TODO FPU */

#ifdef DEBUG
	if ((sigdebug & SDB_FOLLOW) && (!sigpid || p->p_pid == sigpid))
		printf("sigreturn(%d): returns\n", p->p_pid);
#endif
	return (EJUSTRETURN);
}

void
hppa_user2frame(sf, tf)
	struct trapframe *sf, *tf;
{
	/* only restore r1-r31, sar */
	tf->tf_t1 = sf->tf_t1;		/* r22 */
	tf->tf_t2 = sf->tf_t2;		/* r21 */
	tf->tf_sp = sf->tf_sp;
	tf->tf_t3 = sf->tf_t3;		/* r20 */

	tf->tf_sar = sf->tf_sar;
	tf->tf_r1 = sf->tf_r1;
	tf->tf_rp = sf->tf_rp;
	tf->tf_r3 = sf->tf_r3;
	tf->tf_r4 = sf->tf_r4;
	tf->tf_r5 = sf->tf_r5;
	tf->tf_r6 = sf->tf_r6;
	tf->tf_r7 = sf->tf_r7;
	tf->tf_r8 = sf->tf_r8;
	tf->tf_r9 = sf->tf_r9;
	tf->tf_r10 = sf->tf_r10;
	tf->tf_r11 = sf->tf_r11;
	tf->tf_r12 = sf->tf_r12;
	tf->tf_r13 = sf->tf_r13;
	tf->tf_r14 = sf->tf_r14;
	tf->tf_r15 = sf->tf_r15;
	tf->tf_r16 = sf->tf_r16;
	tf->tf_r17 = sf->tf_r17;
	tf->tf_r18 = sf->tf_r18;
	tf->tf_t4 = sf->tf_t4;		/* r19 */
	tf->tf_arg3 = sf->tf_arg3;	/* r23 */
	tf->tf_arg2 = sf->tf_arg2;	/* r24 */
	tf->tf_arg1 = sf->tf_arg1;	/* r25 */
	tf->tf_arg0 = sf->tf_arg0;	/* r26 */
	tf->tf_dp = sf->tf_dp;
	tf->tf_ret0 = sf->tf_ret0;
	tf->tf_ret1 = sf->tf_ret1;
	tf->tf_r31 = sf->tf_r31;
@


1.21.2.9
log
@Merge in -current from about a week ago
@
text
@d156 6
a161 6
int (*cpu_desidhash)(void);
int (*cpu_hpt_init)(vaddr_t hpt, vsize_t hptsize);
int (*cpu_ibtlb_ins)(int i, pa_space_t sp, vaddr_t va, paddr_t pa,
	    vsize_t sz, u_int prot);
int (*cpu_dbtlb_ins)(int i, pa_space_t sp, vaddr_t va, paddr_t pa,
	    vsize_t sz, u_int prot);
d178 5
a182 5
void delay_init(void);
static __inline void fall(int, int, int, int, int);
void dumpsys(void);
void hpmc_dump(void);
void hppa_user2frame(struct trapframe *sf, struct trapframe *tf);
a186 1
#if defined(HP7100LC_CPU) || defined(HP7300LC_CPU)
a187 1
#endif
d201 22
a222 22
extern const u_int itlb_x[], itlbna_x[], dtlb_x[], dtlbna_x[], tlbd_x[];
extern const u_int itlb_s[], itlbna_s[], dtlb_s[], dtlbna_s[], tlbd_s[];
extern const u_int itlb_t[], itlbna_t[], dtlb_t[], dtlbna_t[], tlbd_t[];
extern const u_int itlb_l[], itlbna_l[], dtlb_l[], dtlbna_l[], tlbd_l[];
int iibtlb_s(int i, pa_space_t sp, vaddr_t va, paddr_t pa,
    vsize_t sz, u_int prot);
int idbtlb_s(int i, pa_space_t sp, vaddr_t va, paddr_t pa,
    vsize_t sz, u_int prot);
int ibtlb_t(int i, pa_space_t sp, vaddr_t va, paddr_t pa,
    vsize_t sz, u_int prot);
int ibtlb_l(int i, pa_space_t sp, vaddr_t va, paddr_t pa,
    vsize_t sz, u_int prot);
int ibtlb_g(int i, pa_space_t sp, vaddr_t va, paddr_t pa,
    vsize_t sz, u_int prot);
int pbtlb_g(int i);
int hpti_l(vaddr_t, vsize_t);
int hpti_g(vaddr_t, vsize_t);
int desidhash_x(void);
int desidhash_s(void);
int desidhash_t(void);
int desidhash_l(void);
int desidhash_g(void);
d228 8
a235 8
	int (*desidhash)(void);
	const u_int *itlbh, *itlbnah, *dtlbh, *dtlbnah, *tlbdh;
	int (*dbtlbins)(int i, pa_space_t sp, vaddr_t va, paddr_t pa,
	    vsize_t sz, u_int prot);
	int (*ibtlbins)(int i, pa_space_t sp, vaddr_t va, paddr_t pa,
	    vsize_t sz, u_int prot);
	int (*btlbprg)(int i);
	int (*hptinit)(vaddr_t hpt, vsize_t hptsize);
d239 1
a239 1
	  desidhash_x, itlb_x, itlbna_l, dtlb_x, dtlbna_x, tlbd_x,
d243 2
a244 2
	{ "PCXS",  hpcxs, 0x11, 0,
	  desidhash_s, itlb_s, itlbna_l, dtlb_s, dtlbna_s, tlbd_s,
d249 1
a249 1
	  desidhash_t, itlb_t, itlbna_l, dtlb_t, dtlbna_t, tlbd_t,
d252 1
a252 1
	  desidhash_t, itlb_t, itlbna_l, dtlb_t, dtlbna_t, tlbd_t,
d257 2
a258 2
	  desidhash_l, itlb_l, itlbna_l, dtlb_l, dtlbna_l, tlbd_l,
	  ibtlb_g, NULL, pbtlb_g, hpti_l},
d262 2
a263 2
	  desidhash_l, itlb_l, itlbna_l, dtlb_l, dtlbna_l, tlbd_l,
	  ibtlb_g, NULL, pbtlb_g, hpti_l}, */
d267 1
a267 1
	  desidhash_g, itlb_l, itlbna_l, dtlb_l, dtlbna_l, tlbd_l,
d272 1
a272 1
	  desidhash_g, itlb_l, itlbna_l, dtlb_l, dtlbna_l, tlbd_l,
d277 1
a277 1
	  desidhash_g, itlb_l, itlbna_l, dtlb_l, dtlbna_l, tlbd_l,
d282 1
a282 1
	  desidhash_g, itlb_l, itlbna_l, dtlb_l, dtlbna_l, tlbd_l,
d293 4
a296 2
	vaddr_t v, v1;
	int error, cpu_features = 0;
a366 3
	/* may the scientific guessing begin */
	cpu_features = 0;

d391 2
a392 2
		if (pdc_btlb.finfo.num_c)
			cpu_features |= HPPA_FTRS_BTLBU;
d401 4
a404 1
#if defined(HP7100LC_CPU) || defined(HP7300LC_CPU)
d408 3
a410 2
		pmap_hptsize = 0;
	} else
d412 7
a418 1
#endif
d455 2
a456 7
			if (pdc_cache.dt_conf.tc_sh) {
				LDILDO(trap_ep_T_DTLBMISS  , p->dtlbh);
				LDILDO(trap_ep_T_DTLBMISSNA, p->dtlbnah);
			} else {
				LDILDO(trap_ep_T_ITLBMISS  , p->itlbh);
				LDILDO(trap_ep_T_ITLBMISSNA, p->itlbnah);
			}
d469 3
d494 1
a494 1
	v1 = v = hppa_round_page(start);
d517 2
a518 1
	bzero ((void *)v1, (v - v1));
d521 1
a521 1
	pmap_bootstrap(v);
d528 17
d633 4
d664 3
a666 2
			pmap_kenter_pa(curbuf, VM_PAGE_TO_PHYS(pg),
			    VM_PROT_READ|VM_PROT_WRITE);
d893 1
a893 2
		printf("WARNING: BTLB address misaligned pa=0x%x, len=0x%x\n",
		    pa, len);
d897 1
a897 1
		prot |= TLB_UNCACHABLE;
d1038 1
a1038 1
	register int (*dump)(dev_t, daddr_t, caddr_t, size_t);
@


1.21.2.10
log
@Sync the SMP branch with 3.3
@
text
@d59 6
d118 2
a119 2
int cold = 1;			/* unset when engine is up to go */
extern int msgbufmapped;	/* set when safe to use msgbuf */
d124 1
a124 1
 * on configured cpu types in the kernel
d142 1
a142 1
u_int	cpu_itmr, cpu_ticksnum, cpu_ticksdenom, cpu_hzticks;
a164 1
paddr_t	avail_end;
d187 1
d189 1
d240 2
a241 2
	{ "PCXS",   hpcx,  0x10, 0,
	  desidhash_s, itlb_s, itlbna_s, dtlb_s, dtlbna_s, tlbd_s,
d245 2
a246 2
	{ "PCXT",  hpcxs, 0x11, HPPA_FTRS_BTLBU,
	  desidhash_t, itlb_t, itlbna_t, dtlb_t, dtlbna_t, tlbd_t,
d250 3
a252 1
/* these seem to support the cpu model pdc call */
a293 1
	struct pdc_model pdc_model PDC_ALIGNMENT;
d298 2
a369 9
	/* identify system type */
	if ((error = pdc_call((iodcio_t)pdc, 0, PDC_MODEL, PDC_MODEL_INFO,
	    &pdc_model)) < 0) {
#ifdef DEBUG
		printf("WARNING: PDC_MODEL error %d\n", error);
#endif
		pdc_model.hvers = 0;
	}

d401 2
a402 3
	totalphysmem = btoc(PAGE0->imm_max_mem);
	resvmem = btoc(((vaddr_t)&kernel_text));
	avail_end = ctob(totalphysmem);
d405 2
a406 4
	if (!pdc_call((iodcio_t)pdc, 0, PDC_TLB, PDC_TLB_INFO, &pdc_hwtlb) &&
	    pdc_hwtlb.min_size && pdc_hwtlb.max_size)
		cpu_features |= HPPA_FTRS_HVT;
	else {
d409 2
a410 1
	}
d420 1
a420 1
		    p->arch && p->features != cpu_features; p++);
d422 1
a422 1
		if (!p->arch) {
d425 1
a425 4
			p = cpu_types;
		}

		{
d437 2
a438 2
			cpu_type = p->type;
			cpu_typename = p->name;
d441 1
a441 1
			cpu_hpt_init = p->hptinit;
d448 7
a454 2
			LDILDO(trap_ep_T_ITLBMISS  , p->itlbh);
			LDILDO(trap_ep_T_ITLBMISSNA, p->itlbnah);
a458 49
	{
		const char *p, *q;
		char buf[32];
		int lev, hv;

		lev = 0xa + (*cpu_desidhash)();
		hv = pdc_model.hvers >> 4;
		if (!hv) {
			p = "(UNKNOWN)";
			q = lev == 0xa? "1.0" : "1.1";
		} else {
			p = hppa_mod_info(HPPA_TYPE_BOARD, hv);
			if (!p) {
				sprintf(buf, "(UNKNOWN 0x%x)", hv);
				p = buf;
			}

			switch (pdc_model.arch_rev) {
			default:
			case 0:
				q = "1.0";
#ifdef COMPAT_HPUX
				cpu_model_hpux = HPUX_SYSCONF_CPUPA10;
#endif
				break;
			case 4:
				q = "1.1";
#ifdef COMPAT_HPUX
				cpu_model_hpux = HPUX_SYSCONF_CPUPA11;
#endif
				/* this one is just a 100MHz pcxl */
				if (lev == 0x10)
					lev = 0xc;
				/* this one is a pcxl2 */
				if (lev == 0x16)
					lev = 0xe;
				break;
			case 8:
				q = "2.0";
#ifdef COMPAT_HPUX
				cpu_model_hpux = HPUX_SYSCONF_CPUPA20;
#endif
				break;
			}
		}

		sprintf(cpu_model, "HP9000/%s PA-RISC %s%x", p, q, lev);
	}

d488 1
a488 1

d494 9
a513 4
	msgbufp = (struct msgbuf *)v;
	v += round_page(MSGBUFSIZE);
	bzero(msgbufp, MSGBUFSIZE);

d517 3
a520 1
	initmsgbuf((caddr_t)msgbufp, round_page(MSGBUFSIZE));
d536 1
a536 1
	pdc_call((iodcio_t)pdc, 0, PDC_CHASSIS, PDC_CHASSIS_DISP,
a541 1
	fcacheall();
d545 1
a545 1
cpu_startup(void)
d547 1
d550 2
a551 1
	int i, base, residual;
d567 40
a606 1
	printf("%s\n", cpu_model);
d611 1
a611 1
	if (uvm_map(kernel_map, &minaddr, round_page(size),
d615 1
a615 1
	buffers = (caddr_t)minaddr;
d619 1
d621 1
a621 1
		int cbpgs;
d631 1
d633 1
a633 3
		for (cbpgs = base + (i < residual? 1 : 0); cbpgs--; ) {
			struct vm_page *pg;

d638 1
a638 1
			    UVM_PROT_RW);
d640 1
d729 1
a732 22
void
microtime(struct timeval *tv)
{
	u_int itmr;
	int s;

	s = splhigh();
	tv->tv_sec  = time.tv_sec;
	tv->tv_usec = time.tv_usec;

	mfctl(CR_ITMR, itmr);
	itmr -= cpu_itmr;
	splx(s);

	tv->tv_usec += itmr * cpu_ticksdenom / cpu_ticksnum;
	if (tv->tv_usec > 1000000) {
		tv->tv_usec -= 1000000;
		tv->tv_sec++;
	}
}


d748 1
a748 1
fcacheall(void)
d762 1
a762 1
ptlball(void)
d793 1
a793 1
desidhash_g(void)
d869 1
a869 1
	if ((pa & (HPPA_IOBEGIN >> PGSHIFT)) == (HPPA_IOBEGIN >> PGSHIFT))
d889 1
a889 1
	if (cold)
d891 2
a892 1
	else {
d894 1
a894 1
		boothowto = howto | (boothowto & RB_HALT);
d896 13
a908 15
		if (!(howto & RB_NOSYNC)) {
			waittime = 0;
			vfs_shutdown();
			/*
			 * If we've been adjusting the clock, the todr
			 * will be out of synch; adjust it now unless
			 * the system was sitting in ddb.
			 */
			if ((howto & RB_TIMEBAD) == 0)
				resettodr();
			else
				printf("WARNING: not updating battery clock\n");
		}

		/* XXX probably save howto into stable storage */
d910 1
a910 1
		splhigh();
d912 1
a912 2
		if (howto & RB_DUMP)
			dumpsys();
d914 2
a915 2
		doshutdownhooks();
	}
d917 2
d926 1
a926 2
			DELAY(1000000);
			(*cold_hook)(HPPA_COLD_OFF);
a930 1
		DELAY(1000000);
a935 2
		__asm __volatile(".export hppa_reset, entry\n\t"
		    ".label hppa_reset");
d952 1
a952 1
cpu_dumpsize(void)
d967 1
a967 1
hpmc_dump(void)
d976 1
a976 1
cpu_dump(void)
d1006 1
a1006 1
dumpsys(void)
d1040 1
a1040 1

d1076 7
a1082 1
	return spcopy(HPPA_SID_KERNEL, from, HPPA_SID_KERNEL, to, size);
d1144 1
a1144 1
	struct proc *p;
d1149 2
a1150 4
	extern paddr_t fpu_curpcb;	/* from locore.S */
	struct trapframe *tf = p->p_md.md_regs;
	struct pcb *pcb = &p->p_addr->u_pcb;
	register_t zero;
d1153 2
a1154 1
	/*pmapdebug = 13;
d1159 1
a1159 1
	tf->tf_flags = TFF_SYS|TFF_LAST;
d1167 5
a1171 18
	stack = (stack + 0x1f) & ~0x1f;
	tf->tf_r3 = stack;
	tf->tf_sp = stack += HPPA_FRAME_SIZE;
	zero = 0;
	copyout(&zero, (caddr_t)(stack - HPPA_FRAME_SIZE), sizeof(register_t));
	copyout(&zero, (caddr_t)(stack + HPPA_FRAME_CRP), sizeof(register_t));

	/* reset any of the pending FPU exceptions */
	pcb->pcb_fpregs[0] = ((u_int64_t)HPPA_FPU_INIT) << 32;
	pcb->pcb_fpregs[1] = 0;
	pcb->pcb_fpregs[2] = 0;
	pcb->pcb_fpregs[3] = 0;
	fdcache(HPPA_SID_KERNEL, (vaddr_t)pcb->pcb_fpregs, 8 * 4);
	if (tf->tf_cr30 == fpu_curpcb) {
		fpu_curpcb = 0;
		/* force an fpu ctxsw, we'll not be hugged by the cpu_switch */
		mtctl(0, CR_CCR);
	}
d1188 1
d1191 1
a1191 2
	struct sigcontext ksc, *scp;
	siginfo_t ksi, *sip;
a1192 1
	register_t zero;
a1212 1
	sip = NULL;
d1215 2
a1216 2
		sip = (siginfo_t *)(scp + 1);
		if (copyout((caddr_t)&ksi, sip, sizeof(ksi)))
d1232 2
a1233 5
	zero = 0;
	if (copyout(&zero, (caddr_t)scp + sss - HPPA_FRAME_SIZE,
	    sizeof(register_t)) ||
	    copyout(&zero, (caddr_t)scp + sss + HPPA_FRAME_CRP,
	    sizeof(register_t)))
d1247 2
a1248 1
	tf->tf_iioq_head = HPPA_PC_PRIV_USER | p->p_sigcode;
a1271 1
	int error;
d1279 3
a1281 2
	if ((error = copyin((caddr_t)scp, (caddr_t)&ksc, sizeof ksc)))
		return (error);
d1283 3
a1285 3
#define PSL_MBS (PSL_C|PSL_Q|PSL_P|PSL_D|PSL_I)
#define PSL_MBZ (PSL_Y|PSL_Z|PSL_S|PSL_X|PSL_M|PSL_R)
	if ((ksc.sc_ps & (PSL_MBS|PSL_MBZ)) != PSL_MBS)
d1387 1
a1387 1
consinit(void)
@


1.21.2.11
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.21.2.10 2003/03/27 23:26:53 niklas Exp $	*/
d471 1
a471 1
				snprintf(buf, sizeof buf, "(UNKNOWN 0x%x)", hv);
d504 1
a504 2
		snprintf(cpu_model, sizeof cpu_model,
		    "HP 9000/%s PA-RISC %s%x", p, q, lev);
@


1.21.2.12
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.21.2.11 2003/05/13 19:41:03 ho Exp $	*/
a703 1
			mdelta = delta;
d1176 1
a1176 1
	printf("setregs(%p, %p, 0x%x, %p), ep=0x%x, cr30=0x%x\n",
a1220 1
	extern paddr_t fpu_curpcb;	/* from locore.S */
a1234 6
	/* flush the FPU ctx first */
	if (tf->tf_cr30 == fpu_curpcb) {
		fpu_save(fpu_curpcb);
		fpu_curpcb = 0;
	}

d1258 1
d1263 1
a1263 34
	ksc.sc_regs[0] = tf->tf_t1;
	ksc.sc_regs[1] = tf->tf_t2;
	ksc.sc_regs[2] = tf->tf_sp;
	ksc.sc_regs[3] = tf->tf_t3;
	ksc.sc_regs[4] = tf->tf_sar;
	ksc.sc_regs[5] = tf->tf_r1;
	ksc.sc_regs[6] = tf->tf_rp;
	ksc.sc_regs[7] = tf->tf_r3;
	ksc.sc_regs[8] = tf->tf_r4;
	ksc.sc_regs[9] = tf->tf_r5;
	ksc.sc_regs[10] = tf->tf_r6;
	ksc.sc_regs[11] = tf->tf_r7;
	ksc.sc_regs[12] = tf->tf_r8;
	ksc.sc_regs[13] = tf->tf_r9;
	ksc.sc_regs[14] = tf->tf_r10;
	ksc.sc_regs[15] = tf->tf_r11;
	ksc.sc_regs[16] = tf->tf_r12;
	ksc.sc_regs[17] = tf->tf_r13;
	ksc.sc_regs[18] = tf->tf_r14;
	ksc.sc_regs[19] = tf->tf_r15;
	ksc.sc_regs[20] = tf->tf_r16;
	ksc.sc_regs[21] = tf->tf_r17;
	ksc.sc_regs[22] = tf->tf_r18;
	ksc.sc_regs[23] = tf->tf_t4;
	ksc.sc_regs[24] = tf->tf_arg3;
	ksc.sc_regs[25] = tf->tf_arg2;
	ksc.sc_regs[26] = tf->tf_arg1;
	ksc.sc_regs[27] = tf->tf_arg0;
	ksc.sc_regs[28] = tf->tf_dp;
	ksc.sc_regs[29] = tf->tf_ret0;
	ksc.sc_regs[30] = tf->tf_ret1;
	ksc.sc_regs[31] = tf->tf_r31;
	bcopy(p->p_addr->u_pcb.pcb_fpregs, ksc.sc_fpregs,
	    sizeof(ksc.sc_fpregs));
d1277 2
a1278 2
		printf("sendsig(%d): sig %d scp %p fp %p sp 0x%x\n",
		    p->p_pid, sig, scp, ksc.sc_fp, (register_t)scp + sss);
d1290 2
d1294 1
a1294 1
		printf("sendsig(%d): pc 0x%x, catcher 0x%x\n", p->p_pid,
a1304 1
	extern paddr_t fpu_curpcb;	/* from locore.S */
a1317 6
	/* flush the FPU ctx first */
	if (tf->tf_cr30 == fpu_curpcb) {
		fpu_save(fpu_curpcb);
		fpu_curpcb = 0;
	}

d1332 1
a1332 36
	tf->tf_t1 = ksc.sc_regs[0];		/* r22 */
	tf->tf_t2 = ksc.sc_regs[1];		/* r21 */
	tf->tf_sp = ksc.sc_regs[2];
	tf->tf_t3 = ksc.sc_regs[3];		/* r20 */
	tf->tf_sar = ksc.sc_regs[4];
	tf->tf_r1 = ksc.sc_regs[5];
	tf->tf_rp = ksc.sc_regs[6];
	tf->tf_r3 = ksc.sc_regs[7];
	tf->tf_r4 = ksc.sc_regs[8];
	tf->tf_r5 = ksc.sc_regs[9];
	tf->tf_r6 = ksc.sc_regs[10];
	tf->tf_r7 = ksc.sc_regs[11];
	tf->tf_r8 = ksc.sc_regs[12];
	tf->tf_r9 = ksc.sc_regs[13];
	tf->tf_r10 = ksc.sc_regs[14];
	tf->tf_r11 = ksc.sc_regs[15];
	tf->tf_r12 = ksc.sc_regs[16];
	tf->tf_r13 = ksc.sc_regs[17];
	tf->tf_r14 = ksc.sc_regs[18];
	tf->tf_r15 = ksc.sc_regs[19];
	tf->tf_r16 = ksc.sc_regs[20];
	tf->tf_r17 = ksc.sc_regs[21];
	tf->tf_r18 = ksc.sc_regs[22];
	tf->tf_t4 = ksc.sc_regs[23];		/* r19 */
	tf->tf_arg3 = ksc.sc_regs[24];	/* r23 */
	tf->tf_arg2 = ksc.sc_regs[25];	/* r24 */
	tf->tf_arg1 = ksc.sc_regs[26];	/* r25 */
	tf->tf_arg0 = ksc.sc_regs[27];	/* r26 */
	tf->tf_dp = ksc.sc_regs[28];
	tf->tf_ret0 = ksc.sc_regs[29];
	tf->tf_ret1 = ksc.sc_regs[30];
	tf->tf_r31 = ksc.sc_regs[31];
	bcopy(ksc.sc_fpregs, p->p_addr->u_pcb.pcb_fpregs,
	    sizeof(ksc.sc_fpregs));
	fdcache(HPPA_SID_KERNEL, (vaddr_t)p->p_addr->u_pcb.pcb_fpregs,
	    sizeof(ksc.sc_fpregs));
d1334 1
d1339 2
d1346 40
@


1.21.2.13
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a133 1
struct pdc_model pdc_model PDC_ALIGNMENT;
d136 1
a136 1
u_int	cpu_ticksnum, cpu_ticksdenom;
a142 1
int	cpu_hvers;
d177 1
a177 1
void cpuid(void);
a185 1
struct pdc_model pdc_model PDC_ALIGNMENT;
d221 1
a221 1
	int  cpuid;
d233 1
a233 1
	{ "PCXS",  hpcx,  0, 0,
d238 1
a238 1
	{ "PCXT",  hpcxs, 0, HPPA_FTRS_BTLBU,
d243 2
a244 1
	{ "PCXT'", hpcxta,HPPA_CPU_PCXT2, HPPA_FTRS_BTLBU,
d246 1
a246 1
	  ibtlb_g, NULL, pbtlb_g},
d249 1
a249 1
	{ "PCXL",  hpcxl, HPPA_CPU_PCXL, HPPA_FTRS_BTLBU|HPPA_FTRS_HVT,
d251 1
a251 1
	  ibtlb_g, NULL, pbtlb_g, hpti_g},
d254 1
a254 1
	{ "PCXL2", hpcxl2,HPPA_CPU_PCXL2, HPPA_FTRS_BTLBU|HPPA_FTRS_HVT,
d256 1
a256 1
	  ibtlb_g, NULL, pbtlb_g, hpti_g},
d259 1
a259 1
	{ "PCXU",  hpcxu, HPPA_CPU_PCXU, HPPA_FTRS_W32B|HPPA_FTRS_BTLBU|HPPA_FTRS_HVT,
d264 1
a264 1
	{ "PCXU+", hpcxu2,HPPA_CPU_PCXUP, HPPA_FTRS_W32B|HPPA_FTRS_BTLBU|HPPA_FTRS_HVT,
d266 1
a266 1
	  ibtlb_g, NULL, pbtlb_g, hpti_g},
d269 1
a269 1
	{ "PCXW",  hpcxw, HPPA_CPU_PCXW, HPPA_FTRS_W32B|HPPA_FTRS_BTLBU|HPPA_FTRS_HVT,
d271 6
a276 1
	  ibtlb_g, NULL, pbtlb_g, hpti_g},
a280 8
int
hppa_cpuspeed(void *oldp, size_t *oldlenp, void *newp, size_t newlen)
{
	int mhz = PAGE0->mem_10msec / 10000;

	return sysctl_rdint(oldp, oldlenp, newp, mhz);
}

d285 1
a285 1
	extern u_long cpu_hzticks;
d288 1
a288 1
	int error;
a356 96
	cpuid();
	ptlball();
	fcacheall();

	avail_end = trunc_page(PAGE0->imm_max_mem);
	/*if (avail_end > 32*1024*1024)
		avail_end = 32*1024*1024;*/
	totalphysmem = btoc(avail_end);
	resvmem = btoc(((vaddr_t)&kernel_text));

	/* we hope this won't fail */
	hppa_ex = extent_create("mem", 0x0, 0xffffffff, M_DEVBUF,
	    (caddr_t)mem_ex_storage, sizeof(mem_ex_storage),
	    EX_NOCOALESCE|EX_NOWAIT);
	if (extent_alloc_region(hppa_ex, 0, (vaddr_t)PAGE0->imm_max_mem,
	    EX_NOWAIT))
		panic("cannot reserve main memory");

	/*
	 * Now allocate kernel dynamic variables
	 */

	/* buffer cache parameters */
	if (bufpages == 0)
		bufpages = totalphysmem / 100 *
		    (totalphysmem <= 0x1000? 5 : bufcachepercent);

	if (nbuf == 0)
		nbuf = bufpages < 16? 16 : bufpages;

	/* Restrict to at most 70% filled kvm */
	if (nbuf * MAXBSIZE >
	    (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) * 7 / 10)
		nbuf = (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) /
		    MAXBSIZE * 7 / 10;

	/* More buffer pages than fits into the buffers is senseless. */
	if (bufpages > nbuf * MAXBSIZE / PAGE_SIZE)
		bufpages = nbuf * MAXBSIZE / PAGE_SIZE;

	v1 = v = hppa_round_page(start);
#define valloc(name, type, num) (name) = (type *)v; v = (vaddr_t)((name)+(num))

	valloc(buf, struct buf, nbuf);

#ifdef SYSVMSG
	valloc(msgpool, char, msginfo.msgmax);
	valloc(msgmaps, struct msgmap, msginfo.msgseg);
	valloc(msghdrs, struct msg, msginfo.msgtql);
	valloc(msqids, struct msqid_ds, msginfo.msgmni);
#endif
#undef valloc
	v = hppa_round_page(v);
	bzero ((void *)v1, (v - v1));

	msgbufp = (struct msgbuf *)v;
	v += round_page(MSGBUFSIZE);
	bzero(msgbufp, MSGBUFSIZE);

	/* sets physmem */
	pmap_bootstrap(v);

	msgbufmapped = 1;
	initmsgbuf((caddr_t)msgbufp, round_page(MSGBUFSIZE));

	/* they say PDC_COPROC might turn fault light on */
	pdc_call((iodcio_t)pdc, 0, PDC_CHASSIS, PDC_CHASSIS_DISP,
	    PDC_OSTAT(PDC_OSTAT_RUN) | 0xCEC0);

	cpu_cpuspeed = &hppa_cpuspeed;
#ifdef DDB
	ddb_init();
#endif
	fcacheall();
}

void
cpuid()
{
	/*
	 * Ptrs to various tlb handlers, to be filled
	 * based on cpu features.
	 * from locore.S
	 */
	extern u_int trap_ep_T_TLB_DIRTY[];
	extern u_int trap_ep_T_DTLBMISS[];
	extern u_int trap_ep_T_DTLBMISSNA[];
	extern u_int trap_ep_T_ITLBMISS[];
	extern u_int trap_ep_T_ITLBMISSNA[];

	extern u_int fpu_enable;
	struct pdc_cpuid pdc_cpuid PDC_ALIGNMENT;
	const struct hppa_cpu_typed *p = NULL;
	u_int cpu_features;
	int error;

a358 1
	cpu_type = 0;
a368 23
	bzero(&pdc_cpuid, sizeof(pdc_cpuid));
	if (pdc_call((iodcio_t)pdc, 0, PDC_MODEL, PDC_MODEL_CPUID,
	    &pdc_cpuid, 0, 0, 0, 0) >= 0) {

		/* patch for old 8200 */
		if (pdc_cpuid.version == HPPA_CPU_PCXU &&
		    pdc_cpuid.revision > 0x0d)
			pdc_cpuid.version = HPPA_CPU_PCXUP;

		cpu_type = pdc_cpuid.version;
	}

	/* locate coprocessors and SFUs */
	bzero(&pdc_coproc, sizeof(pdc_coproc));
	if ((error = pdc_call((iodcio_t)pdc, 0, PDC_COPROC, PDC_COPROC_DFLT,
	    &pdc_coproc, 0, 0, 0, 0)) < 0)
		printf("WARNING: PDC_COPROC error %d\n", error);
	else {
		printf("pdc_coproc: 0x%x, 0x%x\n", pdc_coproc.ccr_enable,
		    pdc_coproc.ccr_present);
		fpu_enable = pdc_coproc.ccr_enable & CCR_MASK;
	}

d373 1
a373 1
		printf("WARNING: PDC_BTLB error %d\n", error);
d397 8
d406 1
a406 1
	    pdc_hwtlb.min_size && pdc_hwtlb.max_size) {
d408 1
a408 5
		if (pmap_hptsize > pdc_hwtlb.max_size)
			pmap_hptsize = pdc_hwtlb.max_size;
		else if (pmap_hptsize && pmap_hptsize < pdc_hwtlb.min_size)
			pmap_hptsize = pdc_hwtlb.min_size;
	} else {
d412 7
a419 3
	if (cpu_type)
		for (p = cpu_types; p->name[0] && p->cpuid != cpu_type; p++);
	else
d421 1
a421 1
		    p->name[0] && p->features != cpu_features; p++);
d423 24
a446 14
	if (!p->name[0]) {
		printf("WARNING: UNKNOWN CPU TYPE; GOOD LUCK "
		    "(type 0x%x, features 0x%x)\n", cpu_type, cpu_features);
		p = cpu_types;
	} else if ((p->type == hpcxl || p->type == hpcxl2) && !fpu_enable)
		/* we know PCXL and PCXL2 do not exist w/o FPU */
		fpu_enable = 0xc0;

	cpu_type = p->type;
	cpu_typename = p->name;
	cpu_ibtlb_ins = p->ibtlbins;
	cpu_dbtlb_ins = p->dbtlbins;
	cpu_hpt_init = p->hptinit;
	cpu_desidhash = p->desidhash;
d449 5
a453 5
	LDILDO(trap_ep_T_TLB_DIRTY , p->tlbdh);
	LDILDO(trap_ep_T_DTLBMISS  , p->dtlbh);
	LDILDO(trap_ep_T_DTLBMISSNA, p->dtlbnah);
	LDILDO(trap_ep_T_ITLBMISS  , p->itlbh);
	LDILDO(trap_ep_T_ITLBMISSNA, p->itlbnah);
d455 2
d461 1
a461 1
		int lev;
d464 2
a465 2
		cpu_hvers = pdc_model.hvers >> 4;
		if (!cpu_hvers) {
d469 1
a469 1
			p = hppa_mod_info(HPPA_TYPE_BOARD, cpu_hvers);
d471 1
a471 2
				snprintf(buf, sizeof buf, "(UNKNOWN 0x%x)",
				    cpu_hvers);
d507 78
d593 6
d610 1
a610 1
	    ctob(totalphysmem), ctob(resvmem), ctob(physmem - resvmem));
d658 3
d737 1
a737 2
	extern u_long cpu_itmr;
	u_long itmr, mask;
a743 1
	rsm(PSL_I, mask);
a745 1
	ssm(PSL_I, mask);
d749 1
a749 1
	if (tv->tv_usec >= 1000000) {
d887 1
a887 2
	if (pa & (len - 1)) {
#ifdef BTLBDEBUG
a889 3
#endif
		return -(ERANGE);
	}
d1174 7
a1180 1

d1226 2
a1227 2
	struct sigcontext ksc;
	siginfo_t ksi;
d1229 1
a1229 1
	register_t zero, scp, sip;
d1250 1
a1250 1
		scp = (register_t)psp->ps_sigstk.ss_sp;
d1253 1
a1253 1
		scp = (tf->tf_sp + 63) & ~63;
d1255 2
a1256 2
	sss = (sizeof(ksc) + 63) & ~63;
	sip = 0;
d1258 5
a1262 2
		sip = scp + sizeof(ksc);
		sss += (sizeof(ksi) + 63) & ~63;
a1264 6
#ifdef DEBUG
	if ((tf->tf_iioq_head & ~PAGE_MASK) == SYSCALLGATE)
		printf("sendsig: interrupted syscall at 0x%x:0x%x, flags %b\n",
		    tf->tf_iioq_head, tf->tf_iioq_tail, tf->tf_ipsw, PSL_BITS);
#endif

d1266 1
a1266 1
	ksc.sc_fp = scp + sss;
d1304 2
d1308 6
a1313 9
	tf->tf_arg0 = sig;
	tf->tf_arg1 = sip;
	tf->tf_arg2 = tf->tf_r4 = scp;
	tf->tf_arg3 = (register_t)catcher;
	tf->tf_sp = scp + sss;
	tf->tf_ipsw &= ~(PSL_N|PSL_B);
	tf->tf_iioq_head = HPPA_PC_PRIV_USER | p->p_sigcode;
	tf->tf_iioq_tail = tf->tf_iioq_head + 4;
	/* disable tracing in the trapframe */
d1321 8
a1328 13
	if (copyout(&ksc, (void *)scp, sizeof(ksc)))
		sigexit(p, SIGILL);

	if (sip) {
		initsiginfo(&ksi, sig, code, type, val);
		if (copyout(&ksi, (void *)sip, sizeof(ksi)))
			sigexit(p, SIGILL);
	}

	zero = 0;
	if (copyout(&zero, (caddr_t)scp + sss - HPPA_FRAME_SIZE,
	    sizeof(register_t)))
		sigexit(p, SIGILL);
d1414 2
a1415 2
	tf->tf_iioq_head = ksc.sc_pcoqh;
	tf->tf_iioq_tail = ksc.sc_pcoqt;
@


1.21.2.14
log
@Merge with the trunk
@
text
@d4 1
a4 1
 * Copyright (c) 1999-2003 Michael Shalayeff
d15 5
d226 8
a233 8
	int  patch;
	int  (*desidhash)(void);
	int  (*dbtlbins)(int i, pa_space_t sp, vaddr_t va, paddr_t pa,
	     vsize_t sz, u_int prot);
	int  (*ibtlbins)(int i, pa_space_t sp, vaddr_t va, paddr_t pa,
	     vsize_t sz, u_int prot);
	int  (*btlbprg)(int i);
	int  (*hptinit)(vaddr_t hpt, vsize_t hptsize);
d236 3
a238 1
	{ "PCXS",  hpcxs,  0, 0, 3, desidhash_s, ibtlb_g, NULL, pbtlb_g},
d241 3
a243 2
	{ "PCXT",  hpcxt, 0, HPPA_FTRS_BTLBU,
	  2, desidhash_t, ibtlb_g, NULL, pbtlb_g},
d247 2
a248 1
	  2, desidhash_t, ibtlb_g, NULL, pbtlb_g},
d252 2
a253 1
	  0, desidhash_l, ibtlb_g, NULL, pbtlb_g, hpti_g},
d257 2
a258 1
	  0, desidhash_l, ibtlb_g, NULL, pbtlb_g, hpti_g},
d261 3
a263 2
	{ "PCXU",  hpcxu, HPPA_CPU_PCXU, HPPA_FTRS_W32B|HPPA_FTRS_BTLBU,
	  4, desidhash_g, ibtlb_g, NULL, pbtlb_g, hpti_g},
d266 3
a268 2
	{ "PCXU+", hpcxu2,HPPA_CPU_PCXUP, HPPA_FTRS_W32B|HPPA_FTRS_BTLBU,
	  4, desidhash_g, ibtlb_g, NULL, pbtlb_g, hpti_g},
d271 3
a273 2
	{ "PCXW",  hpcxw, HPPA_CPU_PCXW, HPPA_FTRS_W32B|HPPA_FTRS_BTLBU,
	  4, desidhash_g, ibtlb_g, NULL, pbtlb_g, hpti_g},
d279 1
a279 1
hppa_cpuspeed(int *mhz)
d281 1
a281 1
	*mhz = PAGE0->mem_10msec / 10000;
d283 1
a283 1
	return (0);
a547 6
	/*
	 * TODO: HPT on 7200 is not currently supported
	 */
	if (pmap_hptsize && p->type != hpcxl && p->type != hpcxl2)
		pmap_hptsize = 0;

d555 7
a561 8
	/* patch tlb handler branches */
	if (p->patch) {
		trap_ep_T_TLB_DIRTY [0] = trap_ep_T_TLB_DIRTY [p->patch];
		trap_ep_T_DTLBMISS  [0] = trap_ep_T_DTLBMISS  [p->patch];
		trap_ep_T_DTLBMISSNA[0] = trap_ep_T_DTLBMISSNA[p->patch];
		trap_ep_T_ITLBMISS  [0] = trap_ep_T_ITLBMISS  [p->patch];
		trap_ep_T_ITLBMISSNA[0] = trap_ep_T_ITLBMISSNA[p->patch];
	}
d938 3
a940 5
	if (cold) {
		/* (Unless the user explicitly asked for reboot.) */
		if ((howto & RB_USERREQ) == 0)
			howto |= RB_HALT;
	} else {
@


1.20
log
@better copy and zero inlines in locore;
proper setregs() in machedep;
start of hpmc handler;
some cleanup here and there;
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.19 2000/01/17 20:18:16 mickey Exp $	*/
d130 6
d178 1
a178 1
pid_t sigpid;
d461 2
a462 1
			panic("cpu_startup: cannot allocate VM for graphics");
d863 1
a863 1
		/* TODO block map the whole memory */
d866 1
a866 1
			/* Print out how many MBs we to go. */
@


1.19
log
@remove unneeded stuff from setregs; force single-user for now, enable signal debug
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.18 2000/01/11 20:27:56 mickey Exp $	*/
d161 1
d215 11
d784 9
a975 1
	/* tf->tf_r?? = PS_STRINGS */
d979 1
a979 1
	tf->tf_arg0 = stack;
d984 1
a984 2
	copyout(&tf->tf_rp, (caddr_t)(stack + HPPA_FRAME_PSP),
	    sizeof(tf->tf_rp));
@


1.18
log
@s/fpu_curproc/fpu_curpcb/ which also points into physical.
move it's definition into locore (where it's used the most).
adjust fpu context switch and save on swapout accordingly.
fix context save (in switch).
add accounting for fpu context switches (since it differes
from proc switching, we might get provided w/ some usefull
numbers as to how effective this lazy switch technique is).
enable handling fpu/sfu exceptions.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.17 1999/12/31 09:07:13 mickey Exp $	*/
d4 1
a4 1
 * Copyright (c) 1999 Michael Shalayeff
d170 1
a170 1
int sigdebug;
d185 2
d946 2
a947 1
	register struct trapframe *tf;
d951 2
a952 2
	printf("setregs(%p, %p, %x, %p), ep=%x\n",
	    p, pack, stack, retval, pack->ep_entry);
a953 1
	/* FPU: setup regs */
a954 1
	tf = p->p_md.md_regs;
d956 2
a957 4
	tf->tf_ipsw = PSW_C | PSW_Q | PSW_P | PSW_D | PSW_I;
	tf->tf_iioq_head = tf->tf_iioq_tail =
	    pack->ep_entry | HPPA_PC_PRIV_USER;
	tf->tf_iisq_head = tf->tf_iisq_tail = p->p_addr->u_pcb.pcb_space;
a960 7
	tf->tf_eiem = 0;
	tf->tf_sr4 = p->p_addr->u_pcb.pcb_space;
	tf->tf_sr5 = p->p_addr->u_pcb.pcb_space;
	tf->tf_sr6 = p->p_addr->u_pcb.pcb_space;
	tf->tf_sr7 = HPPA_SID_KERNEL;
	tf->tf_pidr1 = p->p_vmspace->vm_map.pmap->pmap_pid;
	tf->tf_pidr2 = p->p_vmspace->vm_map.pmap->pmap_pid;
@


1.17
log
@don't bother about pidr3 and pidr4
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.16 1999/12/17 06:24:38 mickey Exp $	*/
a149 1
struct proc *fpu_curproc;
@


1.16
log
@fix the panic message for sti memory mapping
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.15 1999/11/25 18:46:07 mickey Exp $	*/
a969 2
	tf->tf_pidr3 = p->p_vmspace->vm_map.pmap->pmap_pid;
	tf->tf_pidr4 = p->p_vmspace->vm_map.pmap->pmap_pid;
@


1.15
log
@bus stuff is in mainbus now, the rest is rewritten many ways
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d442 1
a442 1
			panic("cpu_startup: cannot allocate VM for buffers");
@


1.14
log
@fix uvm_pagealloc() call
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.13 1999/09/03 18:00:46 art Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998,1999 Michael Shalayeff
d17 1
a17 1
 *	This product includes software developed by Michael Shalayeff.
d24 8
a31 56
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * follows are the copyrights of other sources used in this file.
 */
/*
 * Copyright 1996 1995 by Open Software Foundation, Inc.   
 *              All Rights Reserved 
 *  
 * Permission to use, copy, modify, and distribute this software and 
 * its documentation for any purpose and without fee is hereby granted, 
 * provided that the above copyright notice appears in all copies and 
 * that both the copyright notice and this permission notice appear in 
 * supporting documentation. 
 *  
 * OSF DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE 
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS 
 * FOR A PARTICULAR PURPOSE. 
 *  
 * IN NO EVENT SHALL OSF BE LIABLE FOR ANY SPECIAL, INDIRECT, OR 
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM 
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN ACTION OF CONTRACT, 
 * NEGLIGENCE, OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION 
 * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. 
 */
/*
 *  (c) Copyright 1988 HEWLETT-PACKARD COMPANY
 *
 *  To anyone who acknowledges that this file is provided "AS IS"
 *  without any express or implied warranty:
 *      permission to use, copy, modify, and distribute this file
 *  for any purpose is hereby granted without fee, provided that
 *  the above copyright notice and this notice appears in all
 *  copies, and that the name of Hewlett-Packard Company not be
 *  used in advertising or publicity pertaining to distribution
 *  of the software without specific, written prior permission.
 *  Hewlett-Packard Company makes no representations about the
 *  suitability of this software for any purpose.
 */
/*
 * Copyright (c) 1990,1991,1992,1994 The University of Utah and
 * the Computer Systems Laboratory (CSL).  All rights reserved.
 *
 * THE UNIVERSITY OF UTAH AND CSL PROVIDE THIS SOFTWARE IN ITS "AS IS"
 * CONDITION, AND DISCLAIM ANY LIABILITY OF ANY KIND FOR ANY DAMAGES
 * WHATSOEVER RESULTING FROM ITS USE.
 *
 * CSL requests users of this software to return to csl-dist@@cs.utah.edu any
 * improvements that they make and grant CSL redistribution rights.
 *
 * 	Utah $Hdr: model_dep.c 1.34 94/12/14$
d34 1
a34 1
#undef	BTLBDEBUG
a119 1
int kernelmapped;	/* set when kernel is mapped */
a120 2
int hppa_malloc_ok;	/* set when safe to use malloc */
int intr_recurse;	/* interrupt/trap recursion level */
d123 1
a123 1
 * used in locore.S
a127 2
int dcache_size;
double fpu_zero = 0.0;
d130 1
a130 1
 * CPU params
d134 3
a136 2

/* the following is used externally (sysctl_hw) */
d140 1
a140 1
int	cpu_model_hpux; /* contains HPUX_SYSCONF_CPU* kind of value */
a142 1
u_int	cpu_ticksnum, cpu_ticksdenom, cpu_hzticks;
d144 1
a144 1
int	totalphysmem, physmem, resvmem, esym;
d146 3
d151 2
a152 7
int copr_sfu_config;

#ifdef TLB_STATS
struct dtlb_stats dtlb_stats;
struct itlb_stats itlb_stats;
struct tlbd_stats tlbd_stats;
#endif
a157 2
struct extent *hppa_ex;
static long mem_ex_storage[EXTENT_FIXED_STORAGE_SIZE(8) / sizeof(long)];
d160 1
a160 1
static __inline void fall __P((int, int, int, int, int)); 
a161 2
int bus_mem_add_mapping __P((bus_addr_t bpa, bus_size_t size, int cacheable,
			     bus_space_handle_t *bshp));
d163 3
a165 1
/* wide used hardware params */
d170 7
d183 2
a184 2
	register int pdcerr;
	int usehpt;
d186 1
a186 2
	/* init PDC iface, so we can call em easy */
	pdc_init();
a187 1
	/* calculate cpu speed */
d189 1
a189 1
	delay_init();
d191 3
a193 5
	/*
	 * get cache parameters from the PDC
	 */
	if ((pdcerr = pdc_call((iodcio_t)pdc, 0, PDC_CACHE, PDC_CACHE_DFLT,
			       &pdc_cache)) < 0) {
d195 1
a195 1
                printf("Warning: PDC_CACHE call Ret'd %d\n", pdcerr);
d199 1
a200 1
	dcache_size = pdc_cache.dc_size;
d204 3
a206 5
	/*
	 * get cache coherence parameters
	 */
	pdcerr = pdc_call((iodcio_t)pdc, 0, PDC_CACHE, PDC_CACHE_SETCS,
			  &pdc_coherence, 1, 1, 1, 1);
d209 2
a210 3
		pdc_coherence.ia_cst, pdc_coherence.da_cst,
		pdc_coherence.ita_cst, pdc_coherence.dta_cst,
		pdcerr);
d213 4
a216 9
	/*
	 * Fetch BTLB params
	 */
	if ((pdcerr = pdc_call((iodcio_t)pdc, 0, PDC_BLOCK_TLB,
			       PDC_BTLB_DEFAULT, &pdc_btlb)) < 0) {
#ifdef DEBUG
                printf("WARNING: PDC_BTLB call Ret'd %d\n", pdcerr);
#endif
	}
d218 1
a218 3
	/*
	 * purge TLBs and flush caches
	 */
d221 1
d226 33
a258 1
	resvmem = ((vm_offset_t)&kernel_text) / NBPG;
d260 1
a260 1
	/* calculate buffer cache size */
d264 6
a269 11
	if (bufpages == 0) {
		if (totalphysmem <= 0x1000) /* 16M */
			bufpages = totalphysmem / 100 * 5;
		else
			bufpages = totalphysmem / 100 * BUFCACHEPERCENT;
	}
	if (nbuf == 0) {
		nbuf = bufpages;
		if (nbuf < 16)
			nbuf = 16;
	}
d277 1
a277 1
	/* More buffer pages than fits into the buffers is senseless.  */
a285 26

	/* calculate HPT size */
	for (usehpt = 1; usehpt < totalphysmem; usehpt *= 2);
	mtctl(usehpt - 1, CR_HPTMASK);

	/*
	 * If we want to use the HW TLB support, ensure that it exists.
	 */
	if (pdc_call((iodcio_t)pdc, 0, PDC_TLB, PDC_TLB_INFO, &pdc_hwtlb) &&
	    !pdc_hwtlb.min_size && !pdc_hwtlb.max_size) {
		printf("WARNING: no HW tlb walker\n");
		usehpt = 0;
	} else {
#ifdef PMAPDEBUG
		printf("hwtlb: %u-%u, %u/",
		       pdc_hwtlb.min_size, pdc_hwtlb.max_size, usehpt);
#endif
		if (usehpt > pdc_hwtlb.max_size)
			usehpt = pdc_hwtlb.max_size;
		else if (usehpt < pdc_hwtlb.min_size)
			usehpt = pdc_hwtlb.min_size;
#ifdef PMAPDEBUG
		printf("%u\n", usehpt);
#endif
		mtctl(usehpt - 1, CR_HPTMASK);
	}
a286 12
	vstart = hppa_round_page(start);
	vend = VM_MAX_KERNEL_ADDRESS;

	/* we hope this won't fail */
	hppa_ex = extent_create("mem", 0x0, 0xffffffff, M_DEVBUF,
				(caddr_t)mem_ex_storage,
				sizeof(mem_ex_storage),
				EX_NOCOALESCE|EX_NOWAIT);
	if (extent_alloc_region(hppa_ex, 0, (vm_offset_t)PAGE0->imm_max_mem,
				EX_NOWAIT))
		panic("cannot reserve main memory");

d288 1
a288 1
#define	valloc(name, type, num)	(name) = (type *)v; v = (vaddr_t)((name)+(num))
d293 1
d300 1
a300 1
#ifdef SYSVSEM 
d302 1
a302 1
	valloc(sem, struct sem, seminfo.semmns); 
d313 1
d323 1
a323 1
						  NULL, NULL)))
a326 3
#ifdef PMAPDEBUG
	printf("mem: %x+%x, %x\n", physmem, resvmem, totalphysmem);
#endif
d328 3
a330 2
	if (usehpt) {
		int hpt, hptsize;
d332 7
a338 8
		mfctl(CR_HPTMASK, hptsize);
		hptsize++;
		if ((pdcerr = pdc_call((iodcio_t)pdc, 0, PDC_TLB,
				       PDC_TLB_CONFIG, &pdc_hwtlb, hpt,
				       hptsize, PDC_TLB_CURRPDE)) < 0) {
			printf("Warning: HW TLB init failed (%d), disabled\n",
			       pdcerr);
		} else
d340 2
a341 2
			printf("HW TLB(%d entries at 0x%x) initialized (%d)\n",
			       hptsize / sizeof(struct hpt_entry), hpt, pdcerr);
d343 1
d346 4
a349 8
        /*
         * Locate any coprocessors and enable them by setting up the CCR.
         * SFU's are ignored (since we dont have any).  Also, initialize
         * the floating point registers here.
         */
        if ((pdcerr = pdc_call((iodcio_t)pdc, 0, PDC_COPROC, PDC_COPROC_DFLT,
			       &pdc_coproc)) < 0)
                printf("WARNING: PDC_COPROC call Ret'd %d\n", pdcerr);
d353 1
a353 1
		       pdc_coproc.ccr_present);
d355 1
a356 2
        copr_sfu_config = pdc_coproc.ccr_enable;
        mtctl(copr_sfu_config & CCR_MASK, CR_CCR);
d358 3
a360 6
        /*
         * Clear the FAULT light (so we know when we get a real one)
         * PDC_COPROC apparently turns it on (for whatever reason).
         */
        pdcerr = PDC_OSTAT(PDC_OSTAT_RUN) | 0xCEC0;
        (void) (*pdc)(PDC_CHASSIS, PDC_CHASSIS_DISP, pdcerr);
a364 4
#ifdef DEBUG
	printf("hppa_init: leaving\n");
#endif
	kernelmapped++;
d371 2
a372 2
	vm_offset_t minaddr, maxaddr;
	vm_size_t size;
d387 1
a387 1
			    &pdc_model)) < 0) {
d389 1
a389 1
		printf("WARNING: PDC_MODEL failed (%d)\n", err);
d426 19
a444 1
	       ctob(totalphysmem), ctob(resvmem), ctob(physmem));
d452 2
a453 3
		    NULL, UVM_UNKNOWN_OFFSET,
		    UVM_MAPFLAG(UVM_PROT_NONE, UVM_PROT_NONE, UVM_INH_NONE,
				UVM_ADV_NORMAL, 0)) != KERN_SUCCESS)
d476 1
a476 1
				      "buffer cache");
d478 2
a479 3
				   VM_PAGE_TO_PHYS(pg),
				   VM_PROT_READ|VM_PROT_WRITE, TRUE,
				   VM_PROT_READ|VM_PROT_WRITE);
d490 1
a490 1
				   16*NCARGS, TRUE, FALSE, NULL);
d496 1
a496 1
				   VM_PHYS_SIZE, TRUE, FALSE, NULL);
d503 1
a503 1
				   M_MBUF, M_NOWAIT);
d505 2
a506 2
	mb_map = uvm_km_suballoc(kernel_map, (vm_offset_t *)&mbutl, &maxaddr,
			         VM_MBUF_SIZE, FALSE, FALSE, NULL);
d521 1
a521 1
		nbuf, bufpages * CLBYTES);
a537 1
	hppa_malloc_ok = 1;
d542 1
a542 2
 * compute cpu_ticksdenom and cpu_ticksnum such as:
 *
d594 1
a594 1
	int c_base, c_count, c_loop, c_stride, data; 
d596 1
a596 1
        register int loop;                  /* Internal vars */
d598 2
a599 2
        for (; c_count--; c_base += c_stride)
                for (loop = c_loop; loop--; )
a603 1
        
d609 5
a613 5
        /*
         * Flush the instruction, then data cache.
         */
        fall (pdc_cache.ic_base, pdc_cache.ic_count,
              pdc_cache.ic_loop, pdc_cache.ic_stride, 0);
d615 2
a616 2
        fall (pdc_cache.dc_base, pdc_cache.dc_count,
              pdc_cache.dc_loop, pdc_cache.dc_stride, 1);
d623 2
a624 4
        register pa_space_t sp;
        register vm_offset_t off;
	register int six, oix, lix;
	int sixend, oixend, lixend;
a626 3
        sixend = pdc_cache.it_sp_count;
        oixend = pdc_cache.it_off_count;
        lixend = pdc_cache.it_loop;
d628 4
a631 4
	for (six = 0; six < sixend; six++) {
		off = pdc_cache.it_off_base;
		for (oix = 0; oix < oixend; oix++) {
			for (lix = 0; lix < lixend; lix++)
a638 3
        sixend = pdc_cache.dt_sp_count;
        oixend = pdc_cache.dt_off_count;
        lixend = pdc_cache.dt_loop;
d640 4
a643 4
	for (six = 0; six < sixend; six++) {
		off = pdc_cache.dt_off_base;
		for (oix = 0; oix < oixend; oix++) {
			for (lix = 0; lix < lixend; lix++)
d656 1
a656 1
	vm_size_t *lenp;
d660 2
a661 2
	register vm_size_t len;
	register int pdcerr, i;
d670 1
a670 1
		       pdc_btlb.min_size, len, pdc_btlb.max_size);
d687 1
a687 2
	printf ("btlb_insert(%d): %x:%x=%x[%x,%x]\n",
		i, space, va, pa, len, prot);
d689 2
a690 2
	if ((pdcerr = pdc_call((iodcio_t)pdc, 0, PDC_BLOCK_TLB,PDC_BTLB_INSERT,
				space, va, pa, len, prot, i)) < 0) {
d692 1
a692 1
		printf("WARNING: BTLB insert failed (%d)\n", pdcerr);
a700 222
int
bus_space_map (t, bpa, size, cacheable, bshp)
	bus_space_tag_t t;
	bus_addr_t bpa;
	bus_size_t size;
	int cacheable;
	bus_space_handle_t *bshp;
{
	register int error;

	bpa += HPPA_BUS_TAG_BASE(t);
	if ((error = extent_alloc_region(hppa_ex, bpa, size, EX_NOWAIT |
					 (hppa_malloc_ok? EX_MALLOCOK : 0))))
		return (error);

	if ((error = bus_mem_add_mapping(bpa, size, cacheable, bshp))) {
		if (extent_free(hppa_ex, bpa, size, EX_NOWAIT |
				(hppa_malloc_ok? EX_MALLOCOK : 0))) {
			printf ("bus_space_map: pa 0x%lx, size 0x%lx\n",
				bpa, size);
			printf ("bus_space_map: can't free region\n");
		}
	}

	return 0;
}

void
bus_space_unmap (t, bsh, size)
	bus_space_tag_t t;
	bus_space_handle_t bsh;
	bus_size_t size;
{
	register u_long sva, eva;
	register bus_addr_t bpa;

	sva = hppa_trunc_page(bsh);
	eva = hppa_round_page(bsh + size);

#ifdef DIAGNOSTIC
	if (eva <= sva)
		panic("bus_space_unmap: overflow");
#endif

	bpa = kvtop((caddr_t)bsh);
	if (bpa != bsh)
		uvm_km_free(kernel_map, sva, eva - sva);

	if (extent_free(hppa_ex, bpa, size, EX_NOWAIT |
			(hppa_malloc_ok? EX_MALLOCOK : 0))) {
		printf("bus_space_unmap: ps 0x%lx, size 0x%lx\n",
		       bpa, size);
		printf("bus_space_unmap: can't free region\n");
	}
}

int
bus_space_alloc (t, rstart, rend, size, align, bndary, cacheable, addrp, bshp)
	bus_space_tag_t t;
	bus_addr_t rstart, rend;
	bus_size_t size, align, bndary;
	int cacheable;
	bus_addr_t *addrp;
	bus_space_handle_t *bshp;
{
	u_long bpa;
	int error;

	if (rstart < hppa_ex->ex_start || rend > hppa_ex->ex_end)
		panic("bus_space_alloc: bad region start/end");

	if ((error = extent_alloc_subregion(hppa_ex, rstart, rend, size,
					    align, bndary, EX_NOWAIT | 
					    (hppa_malloc_ok? EX_MALLOCOK:0),
					    &bpa)))
		return (error);

	if ((error = bus_mem_add_mapping(bpa, size, cacheable, bshp))) {
		if (extent_free(hppa_ex, bpa, size, EX_NOWAIT |
				(hppa_malloc_ok ? EX_MALLOCOK : 0))) {
			printf("bus_space_alloc: pa 0x%lx, size 0x%lx\n",
				bpa, size);
			printf("bus_space_alloc: can't free region\n");
		}
	}

	*addrp = bpa;

	return error;
}

void
bus_space_free(t, bsh, size)
	bus_space_tag_t t;
	bus_space_handle_t bsh;
	bus_size_t size;
{
	/* bus_space_unmap() does all that we need to do. */
	bus_space_unmap(t, bsh, size);
}

int
bus_mem_add_mapping(bpa, size, cacheable, bshp)
	bus_addr_t bpa;
	bus_size_t size;
	int cacheable;
	bus_space_handle_t *bshp;
{
	extern u_int virtual_avail;
	register u_int64_t spa, epa;
	int bank, off;

	if (bpa > 0 && bpa < virtual_avail)
		*bshp = bpa;
	else if ((bank = vm_physseg_find(atop(bpa), &off)) < 0) {
		/*
		 * determine if we are mapping IO space, or beyond the physmem
		 * region. use block mapping then
		 *
		 * we map the whole bus module (there are 1024 of those max)
		 * so, check here if it's mapped already, map if needed.
		 * all mappings a equal mappings.
		 */
		static u_int8_t bmm[1024/8];
		int flex = HPPA_FLEX(bpa);

		/* need a new mapping */
		if (!(bmm[flex / 8] & (1 << (flex & 3)))) {
			spa = bpa & FLEX_MASK;
			epa = ((u_long)((u_int64_t)bpa + size +
				~FLEX_MASK - 1) & FLEX_MASK) - 1;
#ifdef BTLBDEBUG
			printf ("bus_mem_add_mapping: adding flex=%x "
				"%qx-%qx, ", flex, spa, epa);
#endif
			while (spa < epa) {
				vm_size_t len = epa - spa;
				u_int64_t pa;
				if (len > pdc_btlb.max_size << PGSHIFT)
					len = pdc_btlb.max_size << PGSHIFT;
				if (btlb_insert(kernel_pmap->pmap_space, spa,
						spa, &len,
						kernel_pmap->pmap_pid |
					    	pmap_prot(kernel_pmap,
							  VM_PROT_ALL)) < 0)
					return -1;
				pa = spa + len - 1;
#ifdef BTLBDEBUG
				printf ("------ %d/%d, %qx, %qx-%qx",
					flex, HPPA_FLEX(pa), pa, spa, epa);
#endif
				/* do the mask */
				for (; flex <= HPPA_FLEX(pa); flex++) {
#ifdef BTLBDEBUG
					printf ("mask %x ", flex);
#endif
					bmm[flex / 8] |= (1 << (flex & 3));
				}
				spa = pa;
			}
#ifdef BTLBDEBUG
			printf ("\n");
#endif
		}
		*bshp = bpa;
	} else {
		register vm_offset_t va;

#ifdef PMAPDEBUG
		printf ("%d, %d, %x\n", bank, off, vm_physmem[0].end);
#endif
		spa = hppa_trunc_page(bpa);
		epa = hppa_round_page(bpa + size);

#ifdef DIAGNOSTIC
		if (epa <= spa)
			panic("bus_mem_add_mapping: overflow");
#endif

		if (!(va = uvm_km_valloc(kernel_map, epa - spa)))
			return (ENOMEM);

		*bshp = (bus_space_handle_t)(va + (bpa & PGOFSET));

		for (; spa < epa; spa += NBPG, va += NBPG) {
			pmap_enter(pmap_kernel(), va, spa,
				   VM_PROT_READ | VM_PROT_WRITE, TRUE, 0);
			if (!cacheable)
				pmap_changebit(spa, TLB_UNCACHEABLE, ~0);
			else
				pmap_changebit(spa, 0, ~TLB_UNCACHEABLE);
		}
	}
 
	return 0;
}

#if 0
void
flush_cache(tag, h, off, l, op)
	bus_space_tag_t tag;
	bus_space_handle_t h;
        bus_addr_t off;
	bus_size_t l;
	int op;
{
	if (l) {
		register u_int32_t p = h + off; 

		do {
			if (op == BUS_SPACE_BARRIER_READ)
				__asm __volatile ("pdc (%%sr0,%0)":: "r" (p));
			else
				__asm __volatile ("fdc (%%sr0,%0)":: "r" (p));
			__asm __volatile ("fic,m %2(%%sr0,%0)": "=r" (p)
					  : "0" (p), "r" (dcache_stride));
		} while (p < (h + off + l));
		sync_caches();
	}
}
#endif

d708 1
a708 1
		howto |= RB_HALT;
d740 1
a740 2
				 :: "r" (CMD_STOP),
				    "r" (LBCAST_ADDR + iomod_command));
d745 1
a745 2
				 :: "r" (CMD_RESET),
				    "r" (LBCAST_ADDR + iomod_command));
d793 1
a793 1
			(dumpdev, dumplo, (caddr_t)buf, dbtob(1));
d845 1
a845 1
				n =  BYTES_PER_DUMP;
d872 1
a872 1
	register void *oldh = curproc->p_addr->u_pcb.pcb_onfault;
d874 1
a874 1
	curproc->p_addr->u_pcb.pcb_onfault = &copy_on_fault;
d888 1
a888 2
	return spstrcpy(HPPA_SID_KERNEL, src,
			HPPA_SID_KERNEL, dst, size, lenp);
d899 1
a899 1
			HPPA_SID_KERNEL, dst, size, lenp);
d911 1
a911 1
			curproc->p_addr->u_pcb.pcb_space, dst, size, lenp);
d922 1
a922 1
		      HPPA_SID_KERNEL, dst, size);
d932 1
a932 1
		      curproc->p_addr->u_pcb.pcb_space, dst, size);
d946 6
a951 1

d955 1
a955 1
	/* tf->tf_r??? = PS_STRINGS */
d957 2
a958 1
	tf->tf_iioq_head = tf->tf_iioq_tail = pack->ep_entry;
a959 1
	tf->tf_sp = stack;
d961 2
d973 6
d993 8
d1006 1
a1006 1
        struct proc *p;
d1030 1
a1030 1
		return (ENOTDIR);               /* overloaded */
d1032 1
a1032 1
	case CPU_CONSDEV: 
d1038 1
a1038 1
					sizeof consdev));
@


1.13
log
@Change the pmap_enter api to pass down an argument that indicates
the access type that caused this mapping. This is to simplify pmaps
with mod/ref emulation (none for the moment) and in some cases speed
up pmap_is_{referenced,modified}.
At the same time, clean up some mappings that had too high protection.

XXX - the access type is incorrect in old vm, it's only used by uvm and MD code.
The actual use of this in pmap_enter implementations is not in this commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.12 1999/08/14 03:19:42 mickey Exp $	*/
d543 1
a543 1
			if ((pg = uvm_pagealloc(NULL, 0, NULL)) == NULL)
@


1.12
log
@proper debugging ifdefs
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.11 1999/07/21 07:37:20 mickey Exp $	*/
d547 3
a549 1
				   VM_PAGE_TO_PHYS(pg), VM_PROT_ALL, TRUE);
d969 1
a969 1
				   VM_PROT_READ | VM_PROT_WRITE, TRUE);
@


1.11
log
@rewrite the tlb miss handler and tlb dirty handler.
optimize for HVT usage (when compiled for proper cpu type).
drop hpt_* global variables, use info from control registers instead.
there are still ways to improve the tlb handlers tho.
machdep also prints cache and tlb coherence states (not related to the above).
You eat greenish muffin. --More-- You write real code.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.10 1999/07/12 18:16:46 mickey Exp $	*/
d248 1
a248 1
#ifdef DIAGNOSTIC
d399 1
a399 1
#ifdef DEBUG
d414 1
d417 1
@


1.10
log
@allocate 5% bufcache if <=16M memory installed
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.9 1999/06/12 18:13:18 mickey Exp $	*/
d82 2
d225 1
d259 12
d324 2
a325 2
	hpt_hashsize = totalphysmem;
	mtctl(hpt_hashsize - 1, CR_HPTMASK);
a334 1
		usehpt = 1;
d337 1
a337 1
		       pdc_hwtlb.min_size, pdc_hwtlb.max_size, hpt_hashsize);
d339 4
a342 4
		if (hpt_hashsize > pdc_hwtlb.max_size)
			hpt_hashsize = pdc_hwtlb.max_size;
		else if (hpt_hashsize < pdc_hwtlb.min_size)
			hpt_hashsize = pdc_hwtlb.min_size;
d344 1
a344 2
		printf("%u (0x%x)\n", hpt_hashsize,
		       hpt_hashsize * sizeof(struct hpt_entry));
d346 1
d404 4
d409 2
a410 3
				       PDC_TLB_CONFIG, &pdc_hwtlb, hpt_table,
				       sizeof(struct hpt_entry) * hpt_hashsize,
				       PDC_TLB_WORD3)) < 0) {
a412 1
			usehpt = 0;
d415 1
a415 1
			       hpt_hashsize, hpt_table, pdcerr);
d925 1
a925 1
				pa = spa += len - 1;
d937 1
@


1.9
log
@hppa_init() now takes an argument from locore,
meaning the start of available memory.
cleanup machdep somewhat.
fix vm_map.pmap vs vm_pmap isue; 10x art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.8 1999/05/23 19:11:19 mickey Exp $	*/
d280 6
a285 2
	if (bufpages == 0)
		bufpages = totalphysmem / 100 * BUFCACHEPERCENT;
@


1.8
log
@new swap stuff
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.7 1999/05/21 17:56:05 mickey Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998 Michael Shalayeff
d31 2
d148 1
a148 1
 * Declare these as initialized data so we can patch them.
d150 11
a160 1
int	nswbuf = 0;
d187 1
a187 1
char	machine[] = "hppa";
d192 1
d196 1
a199 1
int fpcopr_version;
d220 4
d225 2
a226 1
hppa_init()
d228 2
a229 4
	extern int kernel_text, end;
	struct pdc_hwtlb pdc_hwtlb PDC_ALIGNMENT;
	struct pdc_coproc pdc_coproc PDC_ALIGNMENT;
	vm_offset_t v, vstart, vend;
d273 31
d305 1
a305 1
	hpt_hashsize = PAGE0->imm_max_mem / NBPG;
d317 1
a317 1
#ifdef DEBUG
d325 1
a325 1
#ifdef DEBUG
d331 1
a331 4
	totalphysmem = PAGE0->imm_max_mem / NBPG;
	resvmem = ((vm_offset_t)&kernel_text) / NBPG;

	vstart = hppa_round_page(&end);
a342 10
	/*
	 * Allocate space for system data structures.  We are given
	 * a starting virtual address and we return a final virtual
	 * address; along the way we set each data structure pointer.
	 *
	 * We call allocsys() with 0 to find out how much space we want,
	 * allocate that much and fill it with zeroes, and the call
	 * allocsys() again with the correct base virtual address.
	 */

d344 1
a344 2
#define	valloc(name, type, num)	\
	    (name) = (type *)v; v = (vm_offset_t)((name)+(num))
d350 2
a366 33

#ifndef BUFCACHEPERCENT
#define BUFCACHEPERCENT 10
#endif /* BUFCACHEPERCENT */

	if (bufpages == 0)
		bufpages = totalphysmem / BUFCACHEPERCENT / CLSIZE;
	if (nbuf == 0) {
		nbuf = bufpages;
		if (nbuf < 16)
			nbuf = 16;
	}

	/* Restrict to at most 70% filled kvm */
	if (nbuf * MAXBSIZE >
	    (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) * 7 / 10)
		nbuf = (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) /
		    MAXBSIZE * 7 / 10;

	/* More buffer pages than fits into the buffers is senseless.  */
	if (bufpages > nbuf * MAXBSIZE / CLBYTES)
		bufpages = nbuf * MAXBSIZE / CLBYTES;

	if (nswbuf == 0) {
		nswbuf = (nbuf / 2) & ~1;	/* force even */
		if (nswbuf > 256)
			nswbuf = 256;		/* sanity */
	}

#ifndef UVM
	valloc(swbuf, struct buf, nswbuf);
#endif
	valloc(buf, struct buf, nbuf);
d368 1
d414 1
a414 5
/*
        fprinit(&fpcopr_version);
	fpcopr_version = (fpcopr_version & 0x003ff800) >> 11;
        mtctl(CR_CCR, 0);
*/
a523 3
#ifdef PMAP_NEW
			pmap_kenter_pgs(curbuf, &pg, 1);
#else
a525 1
#endif
a585 6
#if 0
	/* TODO: map SysCall gateways page once for everybody */
	pmap_enter_pv(pmap_kernel(), SYSCALLGATE, TLB_GATE_PROT,
		tlbbtop((paddr_t)&gateway_page),
		pmap_find_va(HPPA_SID_KERNEL, SYSCALLGATE));
#endif
d622 1
a622 1
		n = min(100, us);
d1243 4
a1246 4
	tf->tf_pidr1 = p->p_vmspace->vm_pmap.pmap_pid;
	tf->tf_pidr2 = p->p_vmspace->vm_pmap.pmap_pid;
	tf->tf_pidr3 = p->p_vmspace->vm_pmap.pmap_pid;
	tf->tf_pidr4 = p->p_vmspace->vm_pmap.pmap_pid;
d1262 1
a1262 1
	/* TODO */
d1271 1
a1271 1
	/* TODO */
@


1.7
log
@group all theMD f;ags together, add interrupt recursion one
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.6 1999/05/21 17:46:42 mickey Exp $	*/
a316 2
	nswapmap = maxproc * 2;
	valloc(swapmap, struct map, nswapmap);
@


1.6
log
@define fpu_curproc
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.5 1999/04/20 20:55:38 mickey Exp $	*/
d150 8
a157 5

vm_offset_t istackptr;
int cold = 1;
int kernelmapped;		/* set when kernel is mapped */
int msgbufmapped;		/* set when safe to use msgbuf */
a197 1
int hppa_malloc_ok;
a998 2
	extern int cold;

@


1.5
log
@do lazy blok mapping of io space in bus_*
add copy{in,out}*, kcopy, etc
boot routines
cpu-id-hpux-compat stuff
rest of scheduler and such
uvm
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.4 1999/02/17 03:51:43 mickey Exp $	*/
d181 1
@


1.4
log
@print pa-risc here as well, since, finally, cpu will have to print processor type
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.3 1999/01/04 13:48:16 mickey Exp $	*/
d118 2
a119 1
#include <vm/vm_page.h>
d129 5
d142 2
a143 2
#include <hppa/dev/boards.h>
#include <hppa/dev/boards_data.h>
a158 1
struct pdc_cache pdc_cache PDC_ALIGNMENT;
d165 6
d174 3
d190 4
d200 1
d237 10
d360 1
d362 1
d434 1
a434 2
	struct pdc_model pdc_model;
	register const struct hppa_board_info *bip;
d456 30
a485 16
		i = pdc_model.hvers >> 4; /* board type */
		for (bip = hppa_knownboards;
		     bip->bi_id >= 0 && bip->bi_id != i; bip++);
		if (bip->bi_id >= 0) {
			char *p;
			switch(pdc_model.arch_rev) {
			case  0:  p = "1.0";	break;
			case  4:  p = "1.1";	break;
			case  8:  p = "2.0";	break;
			default:  p = "?.?";	break;
			}
			/* my babe said: 6010, 481, 0, 0, 77b657b1, 0, 4 */
			sprintf(cpu_model, "HP9000/%s PA-RISC %s",
				bip->bi_name, p);
		} else
			sprintf(cpu_model, "HP9000/(UNKNOWN %x)", i);
d497 6
a502 7
	buffer_map = kmem_suballoc(kernel_map, (vm_offset_t *)&buffers,
				   &maxaddr, size, TRUE);
	minaddr = (vm_offset_t)buffers;
	if (vm_map_find(buffer_map, vm_object_allocate(size), (vm_offset_t)0,
			&minaddr, size, FALSE) != KERN_SUCCESS)
		panic("cpu_startup: cannot allocate buffers");

d506 4
d517 16
a532 4
		vm_map_pageable(buffer_map, minaddr, minaddr +
				CLBYTES * (base + (i < residual)), FALSE);
		vm_map_simplify(buffer_map, minaddr);
		minaddr += MAXBSIZE;
d539 2
a540 2
	exec_map = kmem_suballoc(kernel_map, &minaddr, &maxaddr,
				 16*NCARGS, TRUE);
d545 2
a546 2
	phys_map = kmem_suballoc(kernel_map, &minaddr, &maxaddr,
				 VM_PHYS_SIZE, TRUE);
d555 2
a556 2
	mb_map = kmem_suballoc(kernel_map, (vm_offset_t *)&mbutl, &maxaddr,
			       VM_MBUF_SIZE, FALSE);
d569 1
a569 1
	printf("avail mem = %ld\n", ptoa(cnt.v_free_count));
d590 6
d721 2
a722 1
	vm_offset_t va, pa;
a726 1
	struct pdc_btlb pdc_btlb PDC_ALIGNMENT;
a729 8
	if ((pdcerr = pdc_call((iodcio_t)pdc, 0, PDC_BLOCK_TLB,
			       PDC_BTLB_DEFAULT, &pdc_btlb)) < 0) {
#ifdef DEBUG
                printf("WARNING: PDC_BTLB call Ret'd %d\n", pdcerr);
#endif
		return -1;
	}

d735 1
a735 1
#ifdef DEBUG
d753 2
a754 2
#ifdef DEBUG
	printf ("btlb_insert(%d): %x:%x, %x, %x, %x\n",
d757 3
a759 3
	if (pdc_call((iodcio_t)pdc, 0, PDC_BLOCK_TLB, PDC_BTLB_INSERT,
		     space, va, pa, len, prot, i) < 0) {
#ifdef DEBUG
a776 1
	extern u_int virtual_avail;
a783 6
	if ((bpa > 0 && bpa < virtual_avail) ||
	    (bpa > HPPA_IOBEGIN)) {
		*bshp = bpa;
		return 0;
	}

d815 1
a815 1
		kmem_free(kernel_map, sva, eva - sva);
d834 24
a857 1
	return -1;
d866 2
a867 1

d877 17
a893 2
	register u_long spa, epa;
	register vm_offset_t va;
d895 46
a940 2
	spa = hppa_trunc_page(bpa);
	epa = hppa_round_page(bpa + size);
d943 2
a944 2
	if (epa <= spa)
		panic("bus_mem_add_mapping: overflow");
d947 2
a948 2
	if (!(va = kmem_alloc_pageable(kernel_map, epa - spa)))
		return (ENOMEM);
d950 1
a950 1
	*bshp = (bus_space_handle_t)(va + (bpa & PGOFSET));
d952 8
a959 7
	for (; spa < epa; spa += NBPG, va += NBPG) {
		pmap_enter(pmap_kernel(), va, spa,
			   VM_PROT_READ | VM_PROT_WRITE, TRUE);
		if (!cacheable)
			pmap_changebit(spa, TLB_UNCACHEABLE, ~0);
		else
			pmap_changebit(spa, 0, ~TLB_UNCACHEABLE);
d990 2
d996 31
a1026 1
	/* TODO: probably save howto into stable storage */
a1029 1
		splhigh();
d1045 129
d1181 2
a1182 1
	return 0;
d1192 2
a1193 1
	return 0;
d1204 2
a1205 1
	return 0;
d1215 2
a1216 1
	return 0;
d1225 2
a1226 94
	return 0;
}

int
fubyte(addr)
	const void *addr;
{
	return 0;
}

int
subyte(addr, val)
	void *addr;
	int val;
{
	return 0;
}

int
suibyte(addr, val)
	void *addr;
	int val;
{
	return 0;
}

long
fuword(addr)
	const void *addr;
{
	return 0;
}

long
fuiword(addr)
	const void *addr;
{
	return 0;
}

int
suword(addr, val)
	void *addr;
	long val;
{
	return 0;
}

int
suiword(addr, val)
	void *addr;
	long val;
{
	return 0;
}

int
fuswintr(addr)
	const caddr_t addr;
{
	return 0;
}

int
suswintr(addr, val)
	caddr_t addr;
	u_int val;
{
	return 0;
}


/*
 * setrunqueue(p)
 *      proc *p;
 * 
 * Call should be made at splclock(), and p->p_stat should be SRUN.
 */ 
void
setrunqueue(p)
struct proc *p;
{

}

/*
 * remrunqueue(p)
 * 
 * Call should be made at splclock().
 */
void
remrunqueue(p)
	struct proc *p;
{
d1239 22
d1274 1
a1274 1

d1283 1
@


1.3
log
@better cache handling in bus_space_barrier(), seem to work now
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.2 1999/01/03 17:55:13 mickey Exp $	*/
d430 7
d438 2
a439 2
			sprintf(cpu_model, "HP9000/%s rev %x",
				bip->bi_name, pdc_model.arch_rev);
d831 1
d833 1
a833 1
bus_space_barrier(tag, h, off, l, op)
d854 1
@


1.2
log
@implement bus_space_{un,}map w/ extents
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.1 1998/12/30 02:13:52 mickey Exp $	*/
d832 2
a833 1
	register u_int32_t p = h + off; 
d835 10
a844 10
	l += p & dcache_line_mask;
	l = (l + dcache_line_mask) & ~dcache_line_mask;
	p &= ~dcache_line_mask;

	do {
		__asm __volatile ("pdc %%r0(%%sr0,%0)":: "r" (p));
		__asm __volatile ("fic %%r0(%%sr0,%0)":: "r" (p));
		p += dcache_line_mask + 1;
		l -= dcache_line_mask + 1;
	} while (l);
@


1.1
log
@machdep; more work needed
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d102 1
d176 4
d182 2
d258 9
d522 1
d705 119
d839 2
a840 1
		__asm __volatile ("fdc %%r0(%%sr0,%0)":: "r" (p));
@

