head	1.61;
access;
symbols
	OPENBSD_6_0:1.61.0.8
	OPENBSD_6_0_BASE:1.61
	OPENBSD_5_9:1.61.0.4
	OPENBSD_5_9_BASE:1.61
	OPENBSD_5_8:1.61.0.6
	OPENBSD_5_8_BASE:1.61
	OPENBSD_5_7:1.61.0.2
	OPENBSD_5_7_BASE:1.61
	OPENBSD_5_6:1.58.0.4
	OPENBSD_5_6_BASE:1.58
	OPENBSD_5_5:1.57.0.4
	OPENBSD_5_5_BASE:1.57
	OPENBSD_5_4:1.56.0.14
	OPENBSD_5_4_BASE:1.56
	OPENBSD_5_3:1.56.0.12
	OPENBSD_5_3_BASE:1.56
	OPENBSD_5_2:1.56.0.10
	OPENBSD_5_2_BASE:1.56
	OPENBSD_5_1_BASE:1.56
	OPENBSD_5_1:1.56.0.8
	OPENBSD_5_0:1.56.0.6
	OPENBSD_5_0_BASE:1.56
	OPENBSD_4_9:1.56.0.4
	OPENBSD_4_9_BASE:1.56
	OPENBSD_4_8:1.56.0.2
	OPENBSD_4_8_BASE:1.56
	OPENBSD_4_7:1.53.0.6
	OPENBSD_4_7_BASE:1.53
	OPENBSD_4_6:1.53.0.8
	OPENBSD_4_6_BASE:1.53
	OPENBSD_4_5:1.53.0.4
	OPENBSD_4_5_BASE:1.53
	OPENBSD_4_4:1.53.0.2
	OPENBSD_4_4_BASE:1.53
	OPENBSD_4_3:1.51.0.2
	OPENBSD_4_3_BASE:1.51
	OPENBSD_4_2:1.50.0.2
	OPENBSD_4_2_BASE:1.50
	OPENBSD_4_1:1.45.0.2
	OPENBSD_4_1_BASE:1.45
	OPENBSD_4_0:1.44.0.4
	OPENBSD_4_0_BASE:1.44
	OPENBSD_3_9:1.44.0.2
	OPENBSD_3_9_BASE:1.44
	OPENBSD_3_8:1.43.0.4
	OPENBSD_3_8_BASE:1.43
	OPENBSD_3_7:1.43.0.2
	OPENBSD_3_7_BASE:1.43
	OPENBSD_3_6:1.39.0.4
	OPENBSD_3_6_BASE:1.39
	SMP_SYNC_A:1.39
	SMP_SYNC_B:1.39
	OPENBSD_3_5:1.39.0.2
	OPENBSD_3_5_BASE:1.39
	OPENBSD_3_4:1.35.0.2
	OPENBSD_3_4_BASE:1.35
	UBC_SYNC_A:1.32
	OPENBSD_3_3:1.29.0.2
	OPENBSD_3_3_BASE:1.29
	OPENBSD_3_2:1.21.0.2
	OPENBSD_3_2_BASE:1.21
	OPENBSD_3_1:1.18.0.2
	OPENBSD_3_1_BASE:1.18
	UBC_SYNC_B:1.22
	UBC:1.15.0.4
	UBC_BASE:1.15
	OPENBSD_3_0:1.15.0.2
	OPENBSD_3_0_BASE:1.15
	OPENBSD_2_9:1.13.0.2
	OPENBSD_2_9_BASE:1.13
	OPENBSD_2_8:1.10.0.4
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.10.0.2
	OPENBSD_2_7_BASE:1.10
	SMP:1.7.0.2
	SMP_BASE:1.7
	kame_19991208:1.7
	OPENBSD_2_6:1.5.0.2
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.61
date	2014.09.15.19.08.21;	author miod;	state Exp;
branches;
next	1.60;
commitid	uuiU9j2I8AUx0fez;

1.60
date	2014.09.04.19.01.02;	author miod;	state Exp;
branches;
next	1.59;
commitid	E2EstJWFDNJM8qzB;

1.59
date	2014.08.29.21.21.39;	author miod;	state Exp;
branches;
next	1.58;
commitid	XcQ9UrJqjYkBnPTz;

1.58
date	2014.05.08.21.32.45;	author miod;	state Exp;
branches;
next	1.57;

1.57
date	2013.10.04.18.34.46;	author kettenis;	state Exp;
branches;
next	1.56;

1.56
date	2010.05.24.15.04.54;	author deraadt;	state Exp;
branches;
next	1.55;

1.55
date	2010.05.06.14.39.52;	author jsing;	state Exp;
branches;
next	1.54;

1.54
date	2010.04.29.13.48.29;	author jsing;	state Exp;
branches;
next	1.53;

1.53
date	2008.07.21.04.35.54;	author todd;	state Exp;
branches;
next	1.52;

1.52
date	2008.04.20.18.01.33;	author kettenis;	state Exp;
branches;
next	1.51;

1.51
date	2007.08.22.19.32.11;	author kettenis;	state Exp;
branches;
next	1.50;

1.50
date	2007.06.01.22.40.33;	author miod;	state Exp;
branches;
next	1.49;

1.49
date	2007.06.01.19.25.09;	author deraadt;	state Exp;
branches;
next	1.48;

1.48
date	2007.05.29.20.36.47;	author deraadt;	state Exp;
branches;
next	1.47;

1.47
date	2007.05.04.19.30.55;	author deraadt;	state Exp;
branches;
next	1.46;

1.46
date	2007.05.04.03.44.44;	author deraadt;	state Exp;
branches;
next	1.45;

1.45
date	2006.11.28.16.56.50;	author dlg;	state Exp;
branches;
next	1.44;

1.44
date	2005.12.27.18.31.08;	author miod;	state Exp;
branches;
next	1.43;

1.43
date	2005.01.17.22.33.40;	author mickey;	state Exp;
branches;
next	1.42;

1.42
date	2004.12.25.23.02.24;	author miod;	state Exp;
branches;
next	1.41;

1.41
date	2004.09.15.20.11.29;	author mickey;	state Exp;
branches;
next	1.40;

1.40
date	2004.09.14.23.07.56;	author mickey;	state Exp;
branches;
next	1.39;

1.39
date	2003.12.23.23.07.47;	author mickey;	state Exp;
branches;
next	1.38;

1.38
date	2003.12.20.21.49.06;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2003.12.09.14.35.03;	author mickey;	state Exp;
branches;
next	1.36;

1.36
date	2003.10.15.17.42.09;	author mickey;	state Exp;
branches;
next	1.35;

1.35
date	2003.07.30.22.29.45;	author mickey;	state Exp;
branches;
next	1.34;

1.34
date	2003.07.30.21.18.09;	author mickey;	state Exp;
branches;
next	1.33;

1.33
date	2003.06.02.23.27.46;	author millert;	state Exp;
branches;
next	1.32;

1.32
date	2003.05.11.19.41.09;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2003.04.03.21.41.19;	author mickey;	state Exp;
branches;
next	1.30;

1.30
date	2003.03.29.01.08.15;	author mickey;	state Exp;
branches;
next	1.29;

1.29
date	2003.02.18.19.01.50;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2003.02.18.01.45.53;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2003.02.15.00.52.26;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2003.01.04.10.35.32;	author mickey;	state Exp;
branches;
next	1.25;

1.25
date	2002.12.18.23.52.45;	author mickey;	state Exp;
branches;
next	1.24;

1.24
date	2002.12.18.20.56.59;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2002.12.17.21.54.25;	author mickey;	state Exp;
branches;
next	1.22;

1.22
date	2002.10.07.15.32.37;	author mickey;	state Exp;
branches;
next	1.21;

1.21
date	2002.09.23.06.11.47;	author mickey;	state Exp;
branches;
next	1.20;

1.20
date	2002.06.06.23.53.53;	author mickey;	state Exp;
branches;
next	1.19;

1.19
date	2002.04.22.01.49.42;	author mickey;	state Exp;
branches;
next	1.18;

1.18
date	2002.03.14.01.26.31;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2002.02.12.06.42.26;	author mickey;	state Exp;
branches;
next	1.16;

1.16
date	2002.02.08.03.43.30;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	2001.06.25.00.43.10;	author mickey;	state Exp;
branches
	1.15.4.1;
next	1.14;

1.14
date	2001.05.05.22.33.39;	author art;	state Exp;
branches;
next	1.13;

1.13
date	2001.04.01.06.25.33;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	2001.03.29.00.46.49;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	2001.01.26.22.15.04;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	2000.04.06.20.05.39;	author todd;	state Exp;
branches;
next	1.9;

1.9
date	2000.03.30.16.33.27;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	2000.03.29.23.11.12;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	99.11.25.18.31.53;	author mickey;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	99.11.16.17.00.30;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	99.08.14.03.17.32;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	99.06.22.23.45.04;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	99.04.20.20.37.10;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	99.02.25.19.13.31;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	98.12.29.18.10.37;	author mickey;	state Exp;
branches;
next	;

1.7.2.1
date	2001.04.18.16.06.06;	author niklas;	state Exp;
branches;
next	1.7.2.2;

1.7.2.2
date	2001.07.04.10.16.01;	author niklas;	state Exp;
branches;
next	1.7.2.3;

1.7.2.3
date	2002.03.06.00.57.22;	author niklas;	state Exp;
branches;
next	1.7.2.4;

1.7.2.4
date	2002.03.28.10.07.19;	author niklas;	state Exp;
branches;
next	1.7.2.5;

1.7.2.5
date	2003.03.27.23.26.53;	author niklas;	state Exp;
branches;
next	1.7.2.6;

1.7.2.6
date	2003.05.13.19.41.03;	author ho;	state Exp;
branches;
next	1.7.2.7;

1.7.2.7
date	2003.06.07.11.11.36;	author ho;	state Exp;
branches;
next	1.7.2.8;

1.7.2.8
date	2004.02.19.10.48.40;	author niklas;	state Exp;
branches;
next	;

1.15.4.1
date	2002.06.11.03.35.36;	author art;	state Exp;
branches;
next	1.15.4.2;

1.15.4.2
date	2002.10.29.00.28.02;	author art;	state Exp;
branches;
next	1.15.4.3;

1.15.4.3
date	2003.05.19.21.49.41;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.61
log
@Remove non-standard <sys/dkstat.h> header. It has not contained anything
related to disk stastics for almost 17 years, and the remaining
userland-visible defines duplicate those found in <sys/sched.h>.

Move the remaining _KERNEL defines to <sys/tty.h> where they belong, and
update all users to cope with this.

ok kettenis@@
@
text
@/*	$OpenBSD: autoconf.c,v 1.60 2014/09/04 19:01:02 miod Exp $	*/

/*
 * Copyright (c) 1998-2003 Michael Shalayeff
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
 *
 * All advertising materials mentioning features or use of this software
 * must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Lawrence Berkeley Laboratory.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)autoconf.c	8.4 (Berkeley) 10/1/93
 */

#include "pci.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/disklabel.h>
#include <sys/conf.h>
#include <sys/reboot.h>
#include <sys/device.h>
#include <sys/timeout.h>

#include <uvm/uvm_extern.h>

#include <machine/iomod.h>
#include <machine/autoconf.h>

#include <dev/cons.h>

#include <hppa/dev/cpudevs.h>

#if NPCI > 0
#include <dev/pci/pcivar.h>
#include <dev/pci/pcireg.h>
#endif

/* device we booted from */
struct device *bootdv;
void	dumpconf(void);

void (*cold_hook)(int); /* see below */

/*
 * LED blinking thing
 */
#ifdef USELEDS
#include <sys/kernel.h>

struct timeout heartbeat_tmo;
void heartbeat(void *);
#endif

#include "cd.h"
#include "sd.h"
#include "st.h"
#include "mpath.h"

#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>
#if NMPATH > 0
#include <scsi/mpathvar.h>
#endif

#ifdef USELEDS
/*
 * turn the heartbeat alive.
 * right thing would be to pass counter to each subsequent timeout
 * as an argument to heartbeat() incrementing every turn,
 * i.e. avoiding the static hbcnt, but doing timeout_set() on each
 * timeout_add() sounds ugly, guts of struct timeout looks ugly
 * to ponder in even more.
 */
void
heartbeat(v)
	void *v;
{
	static u_int hbcnt = 0, ocp_total, ocp_idle;
	int toggle, cp_mask, cp_total, cp_idle;
	struct schedstate_percpu *spc = &(curcpu()->ci_schedstate);

	timeout_add(&heartbeat_tmo, hz / 16);

	cp_idle = spc->spc_cp_time[CP_IDLE];
	cp_total = spc->spc_cp_time[CP_USER] + spc->spc_cp_time[CP_NICE] +
	    spc->spc_cp_time[CP_SYS] + spc->spc_cp_time[CP_INTR] +
	    spc->spc_cp_time[CP_IDLE];
	if (cp_total == ocp_total)
		cp_total = ocp_total + 1;
	if (cp_idle == ocp_idle)
		cp_idle = ocp_idle + 1;
	cp_mask = 0xf0 >> (cp_idle - ocp_idle) * 4 / (cp_total - ocp_total);
	cp_mask &= 0xf0;
	ocp_total = cp_total;
	ocp_idle = cp_idle;
	/*
	 * do this:
	 *
	 *   |~| |~|
	 *  _| |_| |_,_,_,_
	 *   0 1 2 3 4 6 7
	 */
	toggle = 0;
	if (hbcnt++ < 8 && hbcnt & 1)
		toggle = PALED_HEARTBEAT;
	hbcnt &= 15;
	ledctl(cp_mask,
	    (~cp_mask & 0xf0) | PALED_NETRCV | PALED_NETSND | PALED_DISK,
	    toggle);
}
#endif

/*
 * This is called by configure to set dumplo and dumpsize.
 * Dumps always skip the first CLBYTES of disk space
 * in case there might be a disk label stored there.
 * If there is extra space, put dump at the end to
 * reduce the chance that swapping trashes it.
 */
void
dumpconf(void)
{
	extern int dumpsize;
	int nblks, dumpblks;	/* size of dump area */

	if (dumpdev == NODEV ||
	    (nblks = (bdevsw[major(dumpdev)].d_psize)(dumpdev)) == 0)
		return;
	if (nblks <= ctod(1))
		return;

	dumpblks = cpu_dumpsize();
	if (dumpblks < 0)
		return;
	dumpblks += ctod(physmem);

	/* If dump won't fit (incl. room for possible label), punt. */
	if (dumpblks > (nblks - ctod(1)))
		return;

	/* Put dump at end of partition */
	dumplo = nblks - dumpblks;

	/* dumpsize is in page units, and doesn't include headers. */
	dumpsize = physmem;
}

void	print_devpath(const char *label, struct pz_device *pz);

void
print_devpath(const char *label, struct pz_device *pz)
{
	int i;

	printf("%s: ", label);

	for (i = 0; i < 6; i++)
		if (pz->pz_bc[i] >= 0)
			printf("%d/", pz->pz_bc[i]);

	printf("%d.%x", pz->pz_mod, pz->pz_layers[0]);
	for (i = 1; i < 6 && pz->pz_layers[i]; i++)
		printf(".%x", pz->pz_layers[i]);

	printf(" class=%d flags=%b hpa=0x%x spa=0x%x io=0x%x\n", pz->pz_class,
	    pz->pz_flags, PZF_BITS, pz->pz_hpa, pz->pz_spa, pz->pz_iodc_io);
}

struct pdc_memmap pdc_memmap PDC_ALIGNMENT;
struct pdc_sysmap_find pdc_find PDC_ALIGNMENT;
struct pdc_sysmap_addrs pdc_addr PDC_ALIGNMENT;
struct pdc_iodc_read pdc_iodc_read PDC_ALIGNMENT;

void
pdc_scanbus(struct device *self, struct confargs *ca, int maxmod,
    hppa_hpa_t hpa, int cpu_scan)
{
	int start, end, incr, i;

	/* Scan forwards for CPUs, backwards for everything else. */
	if (cpu_scan) {
		start = 0;
		incr = 1;
		end = maxmod;
	} else {
		start = maxmod - 1;
		incr = -1;
		end = -1;
	}

	for (i = start; i != end; i += incr) {
		struct confargs nca;
		int error;

		bzero(&nca, sizeof(nca));
		nca.ca_iot = ca->ca_iot;
		nca.ca_dmatag = ca->ca_dmatag;
		nca.ca_dp.dp_bc[0] = ca->ca_dp.dp_bc[1];
		nca.ca_dp.dp_bc[1] = ca->ca_dp.dp_bc[2];
		nca.ca_dp.dp_bc[2] = ca->ca_dp.dp_bc[3];
		nca.ca_dp.dp_bc[3] = ca->ca_dp.dp_bc[4];
		nca.ca_dp.dp_bc[4] = ca->ca_dp.dp_bc[5];
		nca.ca_dp.dp_bc[5] = ca->ca_dp.dp_mod;
		nca.ca_dp.dp_mod = i;
		nca.ca_hpamask = ca->ca_hpamask;
		nca.ca_naddrs = 0;
		nca.ca_hpa = 0;

		if (hpa) {
			nca.ca_hpa = hpa + IOMOD_HPASIZE * i;
			nca.ca_dp.dp_mod = i;
		} else if ((error = pdc_call((iodcio_t)pdc, 0, PDC_MEMMAP,
		    PDC_MEMMAP_HPA, &pdc_memmap, &nca.ca_dp)) == 0)
			nca.ca_hpa = pdc_memmap.hpa;
		else if ((error = pdc_call((iodcio_t)pdc, 0, PDC_SYSMAP,
		    PDC_SYSMAP_HPA, &pdc_memmap, &nca.ca_dp)) == 0) {
			struct device_path path;
			int im, ia;

			nca.ca_hpa = pdc_memmap.hpa;

			for (im = 0; !(error = pdc_call((iodcio_t)pdc, 0,
			    PDC_SYSMAP, PDC_SYSMAP_FIND,
			    &pdc_find, &path, im)) &&
			    pdc_find.hpa != nca.ca_hpa; im++)
				;

			if (!error)
				nca.ca_hpasz = pdc_find.size << PGSHIFT;

			if (!error && pdc_find.naddrs) {
				nca.ca_naddrs = pdc_find.naddrs;
				if (nca.ca_naddrs > 16) {
					nca.ca_naddrs = 16;
					printf("WARNING: too many (%d) addrs\n",
					    pdc_find.naddrs);
				}

				if (autoconf_verbose)
					printf(">> ADDRS:");

				for (ia = 0; !(error = pdc_call((iodcio_t)pdc,
				    0, PDC_SYSMAP, PDC_SYSMAP_ADDR, &pdc_addr,
				    im, ia + 1)) && ia < nca.ca_naddrs; ia++) {
					nca.ca_addrs[ia].addr = pdc_addr.hpa;
					nca.ca_addrs[ia].size =
					    pdc_addr.size << PGSHIFT;

					if (autoconf_verbose)
						printf(" 0x%lx[0x%x]",
						    nca.ca_addrs[ia].addr,
						    nca.ca_addrs[ia].size);
				}
				if (autoconf_verbose)
					printf("\n");
			}
		}

		if (!nca.ca_hpa)
			continue;

		if (autoconf_verbose)
			printf(">> HPA 0x%lx[0x%x]\n",
			    nca.ca_hpa, nca.ca_hpasz);

		if ((error = pdc_call((iodcio_t)pdc, 0, PDC_IODC,
		    PDC_IODC_READ, &pdc_iodc_read, nca.ca_hpa, IODC_DATA,
		    &nca.ca_type, sizeof(nca.ca_type))) < 0) {
			if (autoconf_verbose)
				printf(">> iodc_data error %d\n", error);
			continue;
		}

		nca.ca_pdc_iodc_read = &pdc_iodc_read;
		nca.ca_name = hppa_mod_info(nca.ca_type.iodc_type,
					    nca.ca_type.iodc_sv_model);

		if (autoconf_verbose) {
			printf(">> probing: flags %b bc %d/%d/%d/%d/%d/%d ",
			    nca.ca_dp.dp_flags, PZF_BITS,
			    nca.ca_dp.dp_bc[0], nca.ca_dp.dp_bc[1],
			    nca.ca_dp.dp_bc[2], nca.ca_dp.dp_bc[3],
			    nca.ca_dp.dp_bc[4], nca.ca_dp.dp_bc[5]);
			printf("mod %x hpa %lx type %x sv %x\n",
			    nca.ca_dp.dp_mod, nca.ca_hpa,
			    nca.ca_type.iodc_type, nca.ca_type.iodc_sv_model);
		}

		if (cpu_scan && nca.ca_type.iodc_type == HPPA_TYPE_NPROC &&
		    nca.ca_type.iodc_sv_model == HPPA_NPROC_HPPA)
			ncpusfound++;

		if (cpu_scan &&
		    ((nca.ca_type.iodc_type != HPPA_TYPE_NPROC ||
	            nca.ca_type.iodc_sv_model != HPPA_NPROC_HPPA) &&
		    (nca.ca_type.iodc_type != HPPA_TYPE_MEMORY ||
		    nca.ca_type.iodc_sv_model != HPPA_MEMORY_PDEP)))
			continue;

		if (!cpu_scan &&
		    ((nca.ca_type.iodc_type == HPPA_TYPE_NPROC &&
		    nca.ca_type.iodc_sv_model == HPPA_NPROC_HPPA) ||
		    (nca.ca_type.iodc_type == HPPA_TYPE_MEMORY &&
		    nca.ca_type.iodc_sv_model == HPPA_MEMORY_PDEP)))
			continue;

		config_found_sm(self, &nca, mbprint, mbsubmatch);
	}
}

const struct hppa_mod_info hppa_knownmods[] = {
#include <hppa/dev/cpudevs_data.h>
};

const char *
hppa_mod_info(type, sv)
	int type, sv;
{
	const struct hppa_mod_info *mi;
	static char fakeid[32];

	for (mi = hppa_knownmods; mi->mi_type >= 0 &&
	    (mi->mi_type != type || mi->mi_sv != sv); mi++);

	if (mi->mi_type < 0) {
		snprintf(fakeid, sizeof fakeid, "type %x, sv %x", type, sv);
		return fakeid;
	} else
		return mi->mi_name;
}

void
device_register(struct device *dev, void *aux)
{
#if NPCI > 0
	extern struct cfdriver pci_cd;
#endif
#if NCD > 0 || NSD > 0 || NST > 0
	extern struct cfdriver scsibus_cd;
#endif
	struct confargs *ca = aux;
	static struct device *elder = NULL;

	if (bootdv != NULL)
		return;	/* We already have a winner */

#if NPCI > 0
	if (dev->dv_parent &&
	    dev->dv_parent->dv_cfdata->cf_driver == &pci_cd) {
		struct pci_attach_args *pa = aux;
		pcireg_t addr;
		int reg;

		for (reg = PCI_MAPREG_START; reg < PCI_MAPREG_END; reg += 4) {
			addr = pci_conf_read(pa->pa_pc, pa->pa_tag, reg);
			if (PCI_MAPREG_TYPE(addr) == PCI_MAPREG_TYPE_IO)
				addr = PCI_MAPREG_IO_ADDR(addr);
			else
				addr = PCI_MAPREG_MEM_ADDR(addr);

			if (addr == (pcireg_t)PAGE0->mem_boot.pz_hpa) {
				elder = dev;
				break;
			}
		}
	} else
#endif
	if (ca->ca_hpa == (hppa_hpa_t)PAGE0->mem_boot.pz_hpa) {
		/*
		 * If hpa matches, the only thing we know is that the
		 * booted device is either this one or one of its children.
		 * And the children will not necessarily have the correct
		 * hpa value.
		 * Save this elder for now.
		 */
		elder = dev;
	} else if (elder == NULL) {
		return;	/* not the device we booted from */
	}

	/*
	 * Unfortunately, we can not match on pz_class vs dv_class on
	 * older snakes netbooting using the rbootd protocol.
	 * In this case, we'll end up with pz_class == PCL_RANDOM...
	 * Instead, trust the device class from what the kernel attached
	 * now...
	 */
	switch (dev->dv_class) {
	case DV_IFNET:
		/*
		 * Netboot is the top elder
		 */
		if (elder == dev) {
			bootdv = dev;
		}
		return;
	case DV_DISK:
	case DV_DULL:
		if ((PAGE0->mem_boot.pz_class & PCL_CLASS_MASK) != PCL_RANDOM)
			return;
		break;
	case DV_TAPE:
		if ((PAGE0->mem_boot.pz_class & PCL_CLASS_MASK) != PCL_SEQU)
			return;
		break;
	default:
		/* No idea what we were booted from, but better ask the user */
		return;
	}

	/*
	 * If control goes here, we are booted from a block device and we
	 * matched a block device.
	 *
	 * We only grok SCSI boot currently.  Match on proper device
	 * hierarchy and unit/lun values.
	 */

#if NCD > 0 || NSD > 0 || NST > 0
	if (dev->dv_parent &&
	    dev->dv_parent->dv_cfdata->cf_driver == &scsibus_cd) {
		struct scsi_attach_args *sa = aux;
		struct scsi_link *sl = sa->sa_sc_link;

		/*
		 * sd/st/cd is attached to scsibus which is attached to
		 * the controller. Hence the grandparent here should be
		 * the elder.
		 */
		if (dev->dv_parent->dv_parent != elder) {
			return;
		}

		/*
		 * And now check for proper target and lun values
		 */
		if (sl->target == PAGE0->mem_boot.pz_layers[0] &&
		    sl->lun == PAGE0->mem_boot.pz_layers[1]) {
			bootdv = dev;
		}
	}
#endif
}

/*
 * cpu_configure:
 * called at boot time, configure all devices on system
 */
void
cpu_configure(void)
{
	splhigh();
	if (config_rootfound("mainbus", "mainbus") == NULL)
		panic("no mainbus found");

	cpu_intr_init();
	spl0();

	if (cold_hook)
		(*cold_hook)(HPPA_COLD_HOT);

#ifdef USELEDS
	timeout_set(&heartbeat_tmo, heartbeat, NULL);
	heartbeat(NULL);
#endif
	cold = 0;
}

void
diskconf(void)
{
	print_devpath("bootpath", &PAGE0->mem_boot);

#if NMPATH > 0
	if (bootdv != NULL)
		bootdv = mpath_bootdv(bootdv);
#endif

	setroot(bootdv, 0, RB_USERREQ);
	dumpconf();
}

struct nam2blk nam2blk[] = {
	{ "rd",		3 },
	{ "sd",		4 },
	{ "st",		5 },
	{ "cd",		6 },
	{ "fd",		7 },
	{ "wd",		8 },
	{ "vnd",	2 },
	{ NULL,		-1 }
};
@


1.60
log
@Revert previous change, but use curcpu()->ci_schedstate.spc_cp_time[] instead
of global cp_time[] for live information, as loadavg is not updated fast
enough for hz/16 blinking rate. Prompted by feedback from mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.59 2014/08/29 21:21:39 miod Exp $	*/
a78 1
#include <sys/dkstat.h>
@


1.59
log
@Use the load average from averunnable.ldavg[] instead of bogus cp_time[]
arithmetic to display the load average in leds 5-8 of 8 led systems.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.58 2014/05/08 21:32:45 miod Exp $	*/
d110 3
a112 2
	static u_int hbcnt = 0;
	int toggle, cp_mask;
d116 12
a127 5
	/* display the load average in the upper leds if any */
	cp_mask = averunnable.ldavg[0] >> FSHIFT;
	if (cp_mask > 0x0f)
		cp_mask = 0x0f;
	cp_mask <<= 4;
@


1.58
log
@Format string fixes and removal of -Wno-format for hppa kernels.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.57 2013/10/04 18:34:46 kettenis Exp $	*/
d110 2
a111 2
	static u_int hbcnt = 0, ocp_total, ocp_idle;
	int toggle, cp_mask, cp_total, cp_idle;
d115 5
a119 11
	cp_idle = cp_time[CP_IDLE];
	cp_total = cp_time[CP_USER] + cp_time[CP_NICE] + cp_time[CP_SYS] +
	    cp_time[CP_INTR] + cp_time[CP_IDLE];
	if (cp_total == ocp_total)
		cp_total = ocp_total + 1;
	if (cp_idle == ocp_idle)
		cp_idle = ocp_idle + 1;
	cp_mask = 0xf0 >> (cp_idle - ocp_idle) * 4 / (cp_total - ocp_total);
	cp_mask &= 0xf0;
	ocp_total = cp_total;
	ocp_idle = cp_idle;
@


1.57
log
@Fix boot device matching in the presence of mpath(4).

ok dlg@@, jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.56 2010/05/24 15:04:54 deraadt Exp $	*/
d195 1
a195 1
	printf(" class=%d flags=%b hpa=%p spa=%p io=%p\n", pz->pz_class,
@


1.56
log
@Add missing prototypes
ok jsing kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.55 2010/05/06 14:39:52 jsing Exp $	*/
d89 2
a90 1
#if NCD > 0 || NSD > 0 || NST > 0
d93 2
d368 3
a371 1
	char *basename;
d428 1
d444 3
a447 1
	basename = dev->dv_cfdata->cf_driver->cd_name;
a448 4
	/*
	 * We only grok SCSI boot currently. Match on proper device hierarchy,
	 * name and unit/lun values.
	 */
d450 2
a451 2
	if (strcmp(basename, "sd") == 0 || strcmp(basename, "cd") == 0 ||
	    strcmp(basename, "st") == 0) {
d460 1
a460 2
		if (dev->dv_parent == NULL ||
		    dev->dv_parent->dv_parent != elder) {
d503 6
@


1.55
log
@Count the number of CPUs in the system.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.52 2008/04/20 18:01:33 kettenis Exp $	*/
d174 2
@


1.54
log
@Currently pdc_scanbus() scans in reverse, which results in physical CPU0
attaching as cpu1 and physical CPU1 attaching as cpu0. Split the device
scan into two parts - the first pass scans forward and attaches memory
and CPUs, whilst the second pass scans in reverse attaching the
remaining devices, thus preserving current semantics.

Found the hard way whilst trying to spin up the secondary CPU on my j6750.

ok miod@@ kettenis@@
@
text
@d314 4
@


1.53
log
@nam2blk[] needs a "vnd" entry for some things (like softraid)
ok marco@@ no objection miod@@ need this for regress djm@@ no objection krw@@
@
text
@d200 2
a201 5
pdc_scanbus(self, ca, maxmod, hpa)
	struct device *self;
	struct confargs *ca;
	int maxmod;
	hppa_hpa_t hpa;
d203 1
a203 1
	int i;
d205 12
a216 1
	for (i = maxmod; i--; ) {
d313 14
@


1.52
log
@Print bootpath in the canonical place.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.51 2007/08/22 19:32:11 kettenis Exp $	*/
d483 1
@


1.51
log
@Subsequent address ranges start at index 1, not index 0.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.50 2007/06/01 22:40:33 miod Exp $	*/
a457 2
	print_devpath("bootpath", &PAGE0->mem_boot);

d471 1
@


1.50
log
@Infrastructure to allow root on wd0.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.49 2007/06/01 19:25:09 deraadt Exp $	*/
d261 1
a261 1
				    im, ia)) && ia < nca.ca_naddrs; ia++) {
@


1.49
log
@some architectures called setroot() from cpu_configure(), *way* before some
subsystems were enabled.  others used a *md_diskconf -> diskconf() method to
make sure init_main could "do late setroot".  Change all architectures to
have diskconf(), use it directly & late.  tested by todd and myself on most
architectures, ok miod too
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.49 2007/06/01 19:20:46 deraadt Exp $	*/
a481 2
#if 0
	{ "wd",		? },
d483 1
a483 1
#endif
@


1.48
log
@start of dumpconf() unification, which one day we can pray will be MI
(and part of setroot); ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.47 2007/05/04 19:30:55 deraadt Exp $	*/
a459 2
	setroot(bootdv, 0, RB_USERREQ);
	dumpconf();
d468 7
@


1.47
log
@make findblkmajor() and findblkname() MI; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.46 2007/05/04 03:44:44 deraadt Exp $	*/
a151 1
	int maj;
d153 3
a155 8
	if (dumpdev == NODEV)
		goto bad;
	maj = major(dumpdev);
	if (maj < 0 || maj >= nblkdev)
		panic("dumpconf: bad dumpdev=0x%x", dumpdev);
	if (bdevsw[maj].d_psize == NULL)
		goto bad;
	nblks = (*bdevsw[maj].d_psize)(dumpdev);
d157 2
a158 1
		goto bad;
d161 1
a161 1
		goto bad;
d166 1
a166 1
		goto bad;
a172 5
	return;

bad:
	dumpsize = 0;
	return;
@


1.46
log
@setroot() was a ugly mix of MI and MD code, with different bugs on different
machines.  Instead -- build one solid clean MI version, and thenchange all
the architectures to use it.  ok various people, tested on almost all cases.
(it is a 10094 line diff..)
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.45 2006/11/28 16:56:50 dlg Exp $	*/
d482 1
a482 4
static struct {
	char	*name;
	int	maj;
} nam2blk[] = {
d486 1
a486 1
	{ "cd",		6 }
d491 1
a492 23

int
findblkmajor(struct device *dv)
{
	char *name = dv->dv_xname;
	int i;

	for (i = 0; i < sizeof(nam2blk)/sizeof(nam2blk[0]); i++)
		if (!strncmp(name, nam2blk[i].name, strlen(nam2blk[i].name)))
			return (nam2blk[i].maj);
	return (-1);
}

char *
findblkname(int maj)
{
	int i;

	for (i = 0; i < sizeof(nam2blk)/sizeof(nam2blk[0]); i++)
		if (nam2blk[i].maj == maj)
			return (nam2blk[i].name);
	return (NULL);
}
@


1.45
log
@rename scsibus_attach_args to scsi_attach_args. this can help avoid
confusing when trying to attach scsibus to a hba, since it is really meant
for attaching scsi devices to scsibus.

ok deraadt@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.44 2005/12/27 18:31:08 miod Exp $	*/
d55 2
d69 2
a70 1
void	setroot(void);
a72 6
int findblkmajor(struct device *dv);
const char *findblkname(int maj);
struct device *parsedisk(char *str, int len, int defpart, dev_t *devp);
struct device *getdisk(char *str, int len, int defpart, dev_t *devp);
int getstr(char *cp, int size);

a74 3
/* device we booted from */
struct device *bootdv;

a93 26
/*
 * cpu_configure:
 * called at boot time, configure all devices on system
 */
void
cpu_configure(void)
{
	splhigh();
	if (config_rootfound("mainbus", "mainbus") == NULL)
		panic("no mainbus found");

	cpu_intr_init();
	spl0();

	setroot();
	dumpconf();
	if (cold_hook)
		(*cold_hook)(HPPA_COLD_HOT);

#ifdef USELEDS
	timeout_set(&heartbeat_tmo, heartbeat, NULL);
	heartbeat(NULL);
#endif
	cold = 0;
}

a184 124
const struct nam2blk {
	char name[4];
	int maj;
} nam2blk[] = {
	{ "rd",		3 },
	{ "sd",		4 },
	{ "st",		5 },
	{ "cd",		6 },
#if 0
	{ "wd",		? },
	{ "fd",		7 },
#endif
};

#ifdef RAMDISK_HOOKS
struct device fakerdrootdev = { DV_DISK, {}, NULL, 0, "rd0", NULL };
#endif

int
findblkmajor(dv)
	struct device *dv;
{
	char *name = dv->dv_xname;
	int i;

	for (i = 0; i < sizeof(nam2blk)/sizeof(nam2blk[0]); ++i)
		if (!strncmp(name, nam2blk[i].name, strlen(nam2blk[0].name)))
			return (nam2blk[i].maj);
	return (-1);
}

const char *
findblkname(maj)
	int maj;
{
	int i;

	for (i = 0; i < sizeof(nam2blk) / sizeof(nam2blk[0]); ++i)
		if (maj == nam2blk[i].maj)
			return (nam2blk[i].name);
	return (NULL);
}

struct device *
getdisk(str, len, defpart, devp)
	char *str;
	int len, defpart;
	dev_t *devp;
{
	struct device *dv;

	if ((dv = parsedisk(str, len, defpart, devp)) == NULL) {
		printf("use one of:");
#ifdef RAMDISK_HOOKS
		printf(" %s[a-p]", fakerdrootdev.dv_xname);
#endif
		TAILQ_FOREACH(dv, &alldevs, dv_list) {
			if (dv->dv_class == DV_DISK)
				printf(" %s[a-p]", dv->dv_xname);
#ifdef NFSCLIENT
			if (dv->dv_class == DV_IFNET)
				printf(" %s", dv->dv_xname);
#endif
		}
		printf(" halt\n");
	}
	return (dv);
}

struct device *
parsedisk(str, len, defpart, devp)
	char *str;
	int len, defpart;
	dev_t *devp;
{
	struct device *dv;
	char *cp, c;
	int majdev, part;

	if (len == 0)
		return (NULL);

	if (len == 4 && !strcmp(str, "halt"))
		boot(RB_HALT);

	cp = str + len - 1;
	c = *cp;
	if (c >= 'a' && c <= ('a' + MAXPARTITIONS - 1)) {
		part = c - 'a';
		*cp = '\0';
	} else
		part = defpart;

#ifdef RAMDISK_HOOKS
	if (strcmp(str, fakerdrootdev.dv_xname) == 0) {
		dv = &fakerdrootdev;
		goto gotdisk;
	}
#endif
	TAILQ_FOREACH(dv, &alldevs, dv_list) {
		if (dv->dv_class == DV_DISK &&
		    strcmp(str, dv->dv_xname) == 0) {
#ifdef RAMDISK_HOOKS
gotdisk:
#endif
			majdev = findblkmajor(dv);
			if (majdev < 0)
				panic("parsedisk");
			*devp = MAKEDISKDEV(majdev, dv->dv_unit, part);
			break;
		}
#ifdef NFSCLIENT
		if (dv->dv_class == DV_IFNET &&
		    strcmp(str, dv->dv_xname) == 0) {
			*devp = NODEV;
			break;
		}
#endif
	}

	*cp = c;
	return (dv);
}

a203 242
/*
 * Attempt to find the device from which we were booted.
 * If we can do so, and not instructed not to do so,
 * change rootdev to correspond to the load device.
 *
 * XXX Actually, swap and root must be on the same type of device,
 * (ie. DV_DISK or DV_IFNET) because of how (*mountroot) is written.
 * That should be fixed.
 */
void
setroot(void)
{
	struct swdevt *swp;
	struct device *dv;
	int len, majdev, part;
	dev_t nrootdev, nswapdev = NODEV;
	char buf[128];
	dev_t temp;
	const char *rootdevname;
	struct device *rootdv, *swapdv;
#ifdef NFSCLIENT
	extern char *nfsbootdevname;
#endif

#ifdef RAMDISK_HOOKS
	bootdv = &fakerdrootdev;
#endif
	part = 0;

	print_devpath("boot path", &PAGE0->mem_boot);

	/*
	 * If 'swap generic' and we couldn't determine boot device,
	 * ask the user.
	 */
	if (mountroot == NULL && bootdv == NULL)
		boothowto |= RB_ASKNAME;

	if (boothowto & RB_ASKNAME) {
		for (;;) {
			printf("root device? ");
			if (bootdv != NULL) {
				printf(" (default %s", bootdv->dv_xname);
				if (bootdv->dv_class == DV_DISK)
					printf("%c", part + 'a');
				printf(")");
			}
			printf(": ");
			len = getstr(buf, sizeof(buf));
			if (len == 0 && bootdv != NULL) {
				strlcpy(buf, bootdv->dv_xname, sizeof buf);
				len = strlen(buf);
			}
			if (len > 0 && buf[len - 1] == '*') {
				buf[--len] = '\0';
				dv = getdisk(buf, len, 1, &nrootdev);
				if (dv != NULL) {
					rootdv = swapdv = dv;
					nswapdev = nrootdev;
					goto gotswap;
				}
			}
			dv = getdisk(buf, len, part, &nrootdev);
			if (dv != NULL) {
				rootdv = dv;
				break;
			}
		}

		/*
		 * because swap must be on same device type as root, for
		 * network devices this is easy.
		 */
		if (rootdv->dv_class == DV_IFNET) {
			swapdv = NULL;
			goto gotswap;
		}
		for (;;) {
			printf("swap device (default %s", rootdv->dv_xname);
			if (rootdv->dv_class == DV_DISK)
				printf("b");
			printf("): ");
			len = getstr(buf, sizeof(buf));
			if (len == 0) {
				switch (rootdv->dv_class) {
				case DV_IFNET:
					nswapdev = NODEV;
					break;
				case DV_DISK:
					nswapdev = MAKEDISKDEV(major(nrootdev),
					    DISKUNIT(nrootdev), 1);
					break;
				case DV_TAPE:
				case DV_TTY:
				case DV_DULL:
				case DV_CPU:
					break;
				}
				swapdv = rootdv;
				break;
			}
			dv = getdisk(buf, len, 1, &nswapdev);
			if (dv) {
				if (dv->dv_class == DV_IFNET)
					nswapdev = NODEV;
				swapdv = dv;
				break;
			}
		}
gotswap:
		majdev = major(nrootdev);
		rootdev = nrootdev;
		dumpdev = nswapdev;
		swdevt[0].sw_dev = nswapdev;
		swdevt[1].sw_dev = NODEV;
	} else if (mountroot == NULL) {

		/*
		 * `swap generic': Use the device the ROM told us to use.
		 */
		majdev = findblkmajor(bootdv);
		if (majdev >= 0) {
			/*
			 * Root and swap are on a disk.
			 * Assume swap is on partition b.
			 */
			rootdv = swapdv = bootdv;
			rootdev = MAKEDISKDEV(majdev, bootdv->dv_unit, part);
			nswapdev = dumpdev =
			    MAKEDISKDEV(majdev, bootdv->dv_unit, 1);
		} else {
			/*
			 * Root and swap are on a net.
			 */
			rootdv = swapdv = bootdv;
			nswapdev = dumpdev = NODEV;
		}
		swdevt[0].sw_dev = nswapdev;
		swdevt[1].sw_dev = NODEV;
	} else {
		/*
		 * `root DEV swap DEV': honour rootdev/swdevt.
		 * rootdev/swdevt/mountroot already properly set.
		 */

		rootdevname = findblkname(major(rootdev));
		return;
	}

	switch (rootdv->dv_class) {
#ifdef NFSCLIENT
	case DV_IFNET:
		mountroot = nfs_mountroot;
		nfsbootdevname = rootdv->dv_xname;
		return;
#endif
#ifndef DISKLESS
	case DV_DISK:
		mountroot = dk_mountroot;
		printf("root on %s%c", rootdv->dv_xname,
		    DISKPART(rootdev) + 'a');
		if (nswapdev != NODEV)
			printf(" swap on %s%c", swapdv->dv_xname,
			    DISKPART(nswapdev) + 'a');
		printf("\n");
		break;
#endif
	default:
		printf("can't figure root, hope your kernel is right\n");
		return;
	}

	/*
	 * Make the swap partition on the root drive the primary swap.
	 */
	temp = NODEV;
	for (swp = swdevt; swp->sw_dev != NODEV; swp++) {
		if (majdev == major(swp->sw_dev) &&
		    DISKUNIT(rootdev) == DISKUNIT(swp->sw_dev)) {
			temp = swdevt[0].sw_dev;
			swdevt[0].sw_dev = swp->sw_dev;
			swp->sw_dev = temp;
			break;
		}
	}
	if (swp->sw_dev == NODEV)
		return;

	/*
	 * If dumpdev was the same as the old primary swap device,
	 * move it to the new primary swap device.
	 */
	if (temp == dumpdev)
		dumpdev = swdevt[0].sw_dev;
}

int
getstr(cp, size)
	char *cp;
	int size;
{
	char *lp;
	int c;
	int len;

	lp = cp;
	len = 0;
	for (;;) {
		c = cngetc();
		switch (c) {
		case '\n':
		case '\r':
			printf("\n");
			*lp++ = '\0';
			return (len);
		case '\b':
		case '\177':
		case '#':
			if (len) {
				--len;
				--lp;
				printf("\b \b");
			}
			continue;
		case '@@':
		case 'u'&037:
			len = 0;
			lp = cp;
			printf("\n");
			continue;
		default:
			if (len + 1 >= size || c < ' ') {
				printf("\007");
				continue;
			}
			printf("%c", c);
			++len;
			*lp++ = c;
		}
	}
}

d452 65
@


1.44
log
@Remove unused sw_nblks field of struct swdevt. Then, remove swapconf()
which duplicates work done by uvm_swap_init().
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.43 2005/01/17 22:33:40 mickey Exp $	*/
d828 1
a828 1
		struct scsibus_attach_args *sa = aux;
@


1.43
log
@remove stale todo-comment
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.42 2004/12/25 23:02:24 miod Exp $	*/
a67 1
void	swapconf(void);
a114 1
	swapconf();
a170 23

/*
 * Configure swap space and related parameters.
 */
void
swapconf(void)
{
	struct swdevt *swp;
	int nblks, maj;

	for (swp = swdevt; swp->sw_dev != NODEV; swp++) {
		maj = major(swp->sw_dev);
		if (maj > nblkdev)
			break;
		if (bdevsw[maj].d_psize) {
			nblks = (*bdevsw[maj].d_psize)(swp->sw_dev);
			if (nblks != -1 &&
			    (swp->sw_nblks == 0 || swp->sw_nblks > nblks))
				swp->sw_nblks = nblks;
			swp->sw_nblks = ctod(dtoc(swp->sw_nblks));
		}
	}
}
@


1.42
log
@Use list and queue macros where applicable to make the code easier to read;
no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.41 2004/09/15 20:11:29 mickey Exp $	*/
a671 1
			/* TODO fetch the hpa size and the addrs */
@


1.41
log
@scan cpu bus manually for some machines do not support that in prom
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.40 2004/09/14 23:07:56 mickey Exp $	*/
d298 1
a298 2
		for (dv = alldevs.tqh_first; dv != NULL;
		    dv = dv->dv_list.tqe_next) {
d341 1
a341 1
	for (dv = alldevs.tqh_first; dv != NULL; dv = dv->dv_list.tqe_next) {
@


1.40
log
@print layers in hex
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.39 2003/12/23 23:07:47 mickey Exp $	*/
d634 1
a634 1
pdc_scanbus(self, ca, maxmod)
d638 1
d657 2
d660 4
a663 1
		if ((error = pdc_call((iodcio_t)pdc, 0, PDC_MEMMAP,
@


1.39
log
@make it a righteous print of the bootpath (tail gravity it has that is)
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.38 2003/12/20 21:49:06 miod Exp $	*/
d378 1
a378 1
	printf("%d.%d", pz->pz_mod, pz->pz_layers[0]);
d380 1
a380 1
		printf(".%d", pz->pz_layers[i]);
@


1.38
log
@Pass -Wformat, fix a few uninitialized variables as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.37 2003/12/09 14:35:03 mickey Exp $	*/
d374 3
a376 2
	for (i = 0; i < 6 && pz->pz_bc[i] >= 0; i++)
		printf("%s%d", i? "/" : "", pz->pz_bc[i]);
d378 1
a378 1
	printf("%s%d.%d", i? "." : "", pz->pz_mod, pz->pz_layers[0]);
@


1.37
log
@on pci systems bootdevice is specified by the hpa only
and thus just scan the bars for the matching hpa for each pci device
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.36 2003/10/15 17:42:09 mickey Exp $	*/
d87 1
a90 1
extern int hz;
d399 1
a399 1
	int len, majdev, unit, part;
d495 1
d563 1
a563 1
		    unit == DISKUNIT(swp->sw_dev)) {
d695 1
a695 1
						printf(" 0x%x[0x%x]",
d708 1
a708 1
			printf(">> HPA 0x%x[0x%x]\n",
d729 1
a729 1
			printf("mod %x hpa %x type %x sv %x\n",
@


1.36
log
@avoid possible /0 when drawing the led load graph
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.35 2003/07/30 22:29:45 mickey Exp $	*/
d44 2
d62 5
d367 18
d414 2
d761 3
d771 21
@


1.35
log
@an absolute cure for an inherited arrhythmia w/ uninitialized variable
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.34 2003/07/30 21:18:09 mickey Exp $	*/
d135 1
a135 1
	int toggle, cp_mask, cp_total;
d139 1
d142 5
a146 4
	if (!cp_total)
		cp_total = 1;
	cp_mask = 0xf0 >> (cp_time[CP_IDLE] - ocp_idle) * 4 /
	    (cp_total - ocp_total);
d149 1
a149 1
	ocp_idle = cp_time[CP_IDLE];
@


1.34
log
@give those leds some haste
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.33 2003/06/02 23:27:46 millert Exp $	*/
d155 1
@


1.33
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.32 2003/05/11 19:41:09 deraadt Exp $	*/
d137 2
d155 1
a155 1
	if (hbcnt++ < 4)
d157 1
a157 2
	timeout_add(&heartbeat_tmo, hz / 8);
	hbcnt &= 7;
@


1.32
log
@string cleaning; krw ok
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.31 2003/04/03 21:41:19 mickey Exp $	*/
d25 1
a25 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.31
log
@make large pdc_scanbus-related structs global to avoid blowing the kernel stack
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.30 2003/03/29 01:08:15 mickey Exp $	*/
d408 1
a408 1
				strcpy(buf, bootdv->dv_xname);
d725 1
a725 1
		sprintf(fakeid, "type %x, sv %x", type, sv);
@


1.30
log
@fetch the device address list for where supported; say 16 addresses is ought to be enough for every case. dim off the disk led amongst the other lights
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.29 2003/02/18 19:01:50 deraadt Exp $	*/
d599 5
a612 2
		struct pdc_iodc_read pdc_iodc_read PDC_ALIGNMENT;
		struct pdc_memmap pdc_memmap PDC_ALIGNMENT;
d633 1
a633 3
			struct pdc_sysmap_find find PDC_ALIGNMENT;
			struct pdc_sysmap_addrs addr PDC_ALIGNMENT;
			struct device_path path PDC_ALIGNMENT;
d640 3
a642 2
			    PDC_SYSMAP, PDC_SYSMAP_FIND, &find, &path, im)) &&
			    find.hpa != nca.ca_hpa; im++)
d646 1
a646 1
				nca.ca_hpasz = find.size << PGSHIFT;
d648 2
a649 2
			if (!error && find.naddrs) {
				nca.ca_naddrs = find.naddrs;
d653 1
a653 1
					    find.naddrs);
d660 1
a660 1
				    0, PDC_SYSMAP, PDC_SYSMAP_ADDR, &addr,
d662 1
a662 1
					nca.ca_addrs[ia].addr = addr.hpa;
d664 1
a664 1
					    addr.size << PGSHIFT;
@


1.29
log
@knf; mickey ok
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.28 2003/02/18 01:45:53 miod Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998-2001 Michael Shalayeff
d161 3
a163 1
	ledctl(cp_mask, (~cp_mask & 0xf0)|PALED_NETRCV|PALED_NETSND, toggle);
d608 2
a609 2
		struct pdc_iodc_read pdc_iodc_read;
		struct pdc_memmap pdc_memmap;
a610 1
		hppa_hpa_t hpa;
d613 3
a615 2
		hpa = 0;
		nca = *ca;
d623 1
d627 1
a627 1
			hpa = pdc_memmap.hpa;
d629 44
a672 2
		    PDC_SYSMAP_HPA, &pdc_memmap, &nca.ca_dp)) == 0)
			hpa = pdc_memmap.hpa;
d674 1
a674 1
		if (!hpa)
d678 2
a679 1
			printf(">> HPA 0x%x\n", hpa);
d682 1
a682 1
		    PDC_IODC_READ, &pdc_iodc_read, hpa, IODC_DATA,
a688 1
		nca.ca_hpa = hpa;
d700 1
a700 1
			    nca.ca_dp.dp_mod, hpa,
@


1.28
log
@The previous boot device detection code would not work on old pdc machines
netbooting from an rbootd server.
In this case, the pdc masquerades the boot device as a disk class device,
although keeping the device_path correct.

So, rather than trusting the device class the pdc reports, trust what the
kernel just configured - it must know better.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.27 2003/02/15 00:52:26 miod Exp $	*/
d103 1
a103 1
cpu_configure()
d142 1
a142 1
	     cp_time[CP_INTR] + cp_time[CP_IDLE];
d169 1
a169 1
swapconf()
d196 1
a196 1
dumpconf()
d274 1
a274 1
} 
d368 1
a368 1
setroot()
d675 1
a675 1
	     (mi->mi_type != type || mi->mi_sv != sv); mi++);
d762 1
a762 1
		/* 
@


1.27
log
@The current hppa code would always ask for the root device, when running
a kernel configured with "swap generic". This feature was relied upon
by Theo de Raadt, so that he would have to go downstairs to type "sd0a\n\n"
every time he would want to try a new kernel, effectively forcing his body
to take exercise trim the fat.

No more! This commit adds code to correctly detect the root device, currently
either a network interface or an scsi block device. This is slightly tricky,
as all the information the PDC gives up is the controller device and its
numeric subpath, and we need to match the real device from that...
Tested and found to be working on ie and sd only so far.

This commit is brought to you by the so-called friends of Theo de Raadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.26 2003/01/04 10:35:32 mickey Exp $	*/
a688 1
	enum devclass target;
a693 1

d707 9
a715 2
	/* What are we looking for? */
	if (PAGE0->mem_boot.pz_class & PCL_NET_MASK) {
d723 3
a725 4
	} else
	switch (PAGE0->mem_boot.pz_class & PCL_CLASS_MASK) {
	case PCL_RANDOM:
		target = DV_DISK;
d727 3
a729 2
	case PCL_SEQU:
		target = DV_TAPE;
d737 2
a738 4
	 * If control goes here, we are booted from a block device.
	 * Since multiple devices will attach with the same hpa value
	 * in their confargs, get rid of at least the controller by
	 * hunting for an appropriate device class.
a739 3
	if (dev->dv_class != target)
		return;

@


1.26
log
@reset cold at the end of cpu_configure(), add a comment when fooling w/ itmr
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.25 2002/12/18 23:52:45 mickey Exp $	*/
d76 3
d90 8
d377 1
a377 1
	struct device *bootdv, *rootdv, *swapdv;
d384 1
a385 4
#else
	bootdv = NULL;	/* XXX */
	part = 0;
#endif
a478 1
			 * val[2] of the boot device is the partition number.
a480 1
			/* part = bp->val[2]; */
d684 88
@


1.25
log
@newer machines use phantom bus to attach lasi and other bus adapters.
oledr machines did not have a real device for the phantom bus port.
change the device scanning technique to both include a full device path
in the attach_args and do proper shifting in the pdc_scanbus() and
add a device for the newer machines as well as use a newer device
mapping (path to hpa) available on newer firmware versions, where
old (hversion-dependant) is not available.
tested on 712,715/33,c110, miod@@ ok, weissmandude -- testing
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.24 2002/12/18 20:56:59 miod Exp $	*/
d111 1
@


1.24
log
@boot -a support.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.23 2002/12/17 21:54:25 mickey Exp $	*/
d591 1
a591 1
pdc_scanbus(self, ca, bus, maxmod)
d594 1
a594 1
	int bus, maxmod;
a595 2
	struct pdc_memmap pdc_memmap;
	struct device_path dp;
d599 2
d602 2
a603 1
		struct pdc_iodc_read pdc_iodc_read;
d605 16
a620 4
		dp.dp_bc[0] = dp.dp_bc[1] = dp.dp_bc[2] = dp.dp_bc[3] = -1;
		dp.dp_bc[4] = bus;
		dp.dp_bc[5] = bus < 0? -1 : 0;
		dp.dp_mod = i;
d622 1
a622 2
		if (pdc_call((iodcio_t)pdc, 0, PDC_MEMMAP,
			     PDC_MEMMAP_HPA, &pdc_memmap, &dp) < 0)
d625 8
a632 4
		nca = *ca;
		if (pdc_call((iodcio_t)pdc, 0, PDC_IODC, PDC_IODC_READ,
			     &pdc_iodc_read, pdc_memmap.hpa, IODC_DATA,
			     &nca.ca_type, sizeof(nca.ca_type)) < 0)
d634 1
d636 1
a636 2
		nca.ca_mod = i;
		nca.ca_hpa = pdc_memmap.hpa;
d643 4
a646 3
			    dp.dp_flags, PZF_BITS,
			    dp.dp_bc[0], dp.dp_bc[1], dp.dp_bc[2],
			    dp.dp_bc[3], dp.dp_bc[4], dp.dp_bc[5]);
d648 1
a648 1
			    dp.dp_mod, pdc_memmap.hpa,
@


1.23
log
@real interrupts/spl framework.
tested on 712/* 715/100, 715/33 which main cpu/bus types.
miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.22 2002/10/07 15:32:37 mickey Exp $	*/
d70 3
d221 1
a221 1
static const struct nam2blk {
d225 4
a228 4
	{ "st",		2 },
	{ "cd",		3 },
	{ "rd",		6 },
	{ "sd",		8 },
d230 2
a231 2
	{ "wd",		0 },
	{ "fd",		XXX },
d236 1
a236 1
/*static struct device fakerdrootdev = { DV_DISK, {}, NULL, 0, "rd0", NULL };*/
d244 1
a244 1
	register int i;
d256 1
a256 1
	register int i;
d264 81
d359 5
a363 1
	dev_t temp, nswapdev;
d365 1
a365 3
	struct device *bootdv;
	struct device *swapdv;
	int majdev, unit, part;
d370 8
d379 1
a379 1
	 * If 'swap generic' and we couldn't determine root device,
d388 27
d416 7
d424 37
d474 4
a477 4
			unit = bootdv->dv_unit;
			rootdev = MAKEDISKDEV(majdev, unit, part);
			nswapdev = dumpdev = MAKEDISKDEV(major(rootdev),
			    DISKUNIT(rootdev), 1);
d482 1
a486 5
		rootdevname = findblkname(major(rootdev));
		if (rootdevname == NULL) {
			return;
		}

a487 1

d492 2
a493 3
		majdev = major(rootdev);
		unit = DISKUNIT(rootdev);
		part = DISKPART(rootdev);
d497 1
a497 1
	switch (bootdv->dv_class) {
d501 1
a501 1
		nfsbootdevname = bootdv->dv_xname;
d507 1
a507 4
		majdev = major(rootdev);
		unit = DISKUNIT(rootdev);
		part = DISKPART(rootdev);
		printf("root on %s%c", bootdv->dv_xname,
d533 54
a586 7
	if (swp->sw_dev != NODEV) {
		/*
		 * If dumpdev was the same as the old primary swap device,
		 * move it to the new primary swap device.
		 */
		if (temp == dumpdev)
			dumpdev = swdevt[0].sw_dev;
d598 1
a598 1
	register int i;
d639 1
a639 1
static const struct hppa_mod_info hppa_knownmods[] = {
d647 1
a647 1
	register const struct hppa_mod_info *mi;
@


1.22
log
@s/PSW_/PSL_/ to match other archs
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.21 2002/09/23 06:11:47 mickey Exp $	*/
a71 1
register_t	kpsw = PSL_Q | PSL_P | PSL_C | PSL_D;
d95 1
a95 3
	/* in spl*() we trust */
	__asm __volatile("ssm %0, %%r0" :: "i" (PSL_I));
	kpsw |= PSL_I;
a100 1
	cold = 0;
@


1.21
log
@make the leds blink (on those machines where we have 'em).
simple logic is to light up the led in the intrhook and dim in the
heartbeat always, makes a believable impression.
upper four bits represent a cpu usage w/in the last Hz/8
made up from the cp_time[] times.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.20 2002/06/06 23:53:53 mickey Exp $	*/
d72 1
a72 1
register_t	kpsw = PSW_Q | PSW_P | PSW_C | PSW_D;
d97 2
a98 2
	__asm __volatile("ssm %0, %%r0" :: "i" (PSW_I));
	kpsw |= PSW_I;
@


1.20
log
@implement findblkname() and some more fluff around
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.19 2002/04/22 01:49:42 mickey Exp $	*/
d78 2
d127 2
a128 1
	static u_int hbcnt = 0;
d130 9
d146 5
a150 8
	if (hbcnt < 4) {
		ledctl(0, 0, PALED_HEARTBEAT);
		hbcnt++;
		timeout_add(&heartbeat_tmo, hz / 8);
	} else {
		hbcnt = 0;
		timeout_add(&heartbeat_tmo, hz / 2);
	}
@


1.19
log
@better autoconf_verbose prints
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.18 2002/03/14 01:26:31 millert Exp $	*/
d68 2
a69 1
static int findblkmajor(struct device *dv);
d231 1
a231 1
static int
d244 13
d271 1
d273 1
d316 4
d346 6
a351 2
		printf("root on %s%c\n", bootdv->dv_xname,
		    part + 'a');
@


1.18
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.17 2002/02/12 06:42:26 mickey Exp $	*/
d398 3
a400 5
			printf("mod %x layers %x/%x/%x/%x/%x/%x\n",
			    dp.dp_mod,
			    dp.dp_layers[0], dp.dp_layers[1],
			    dp.dp_layers[2], dp.dp_layers[3],
			    dp.dp_layers[4], dp.dp_layers[5]);
@


1.17
log
@support 712's programmable power switch, no interrupt yet
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.16 2002/02/08 03:43:30 mickey Exp $	*/
d64 3
a66 3
void	setroot __P((void));
void	swapconf __P((void));
void	dumpconf __P((void));
d68 1
a68 1
static int findblkmajor __P((struct device *dv));
d70 1
a70 1
void (*cold_hook) __P((int)); /* see below */
d78 1
a78 1
void heartbeat __P((void *));
@


1.16
log
@when doing the autoconf in verbose mode print the devpath
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.15 2001/06/25 00:43:10 mickey Exp $	*/
d70 1
a70 1
void (*cold_hook) __P((void)); /* see below */
d103 1
a103 1
		(*cold_hook)();
@


1.15
log
@cold is in systm now
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.14 2001/05/05 22:33:39 art Exp $	*/
d392 12
@


1.15.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.15 2001/06/25 00:43:10 mickey Exp $	*/
d64 3
a66 3
void	setroot(void);
void	swapconf(void);
void	dumpconf(void);
d68 1
a68 2
int findblkmajor(struct device *dv);
const char *findblkname(int maj);
d70 1
a70 1
void (*cold_hook)(int); /* see below */
d78 1
a78 1
void heartbeat(void *);
d103 1
a103 1
		(*cold_hook)(HPPA_COLD_HOT);
d230 1
a230 1
int
a242 13
const char *
findblkname(maj)
	int maj;
{
	register int i;

	for (i = 0; i < sizeof(nam2blk) / sizeof(nam2blk[0]); ++i)
		if (maj == nam2blk[i].maj)
			return (nam2blk[i].name);
	return (NULL);
} 


a256 1
	const char *rootdevname;
a257 1
	struct device *swapdv;
a299 4
		rootdevname = findblkname(major(rootdev));
		if (rootdevname == NULL) {
			return;
		}
d326 2
a327 6
		printf("root on %s%c", bootdv->dv_xname,
		    DISKPART(rootdev) + 'a');
		if (nswapdev != NODEV)
			printf(" swap on %s%c", swapdv->dv_xname,
			    DISKPART(nswapdev) + 'a');
		printf("\n");
a391 10

		if (autoconf_verbose) {
			printf(">> probing: flags %b bc %d/%d/%d/%d/%d/%d ",
			    dp.dp_flags, PZF_BITS,
			    dp.dp_bc[0], dp.dp_bc[1], dp.dp_bc[2],
			    dp.dp_bc[3], dp.dp_bc[4], dp.dp_bc[5]);
			printf("mod %x hpa %x type %x sv %x\n",
			    dp.dp_mod, pdc_memmap.hpa,
			    nca.ca_type.iodc_type, nca.ca_type.iodc_sv_model);
		}
@


1.15.4.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.15.4.1 2002/06/11 03:35:36 art Exp $	*/
d72 1
a72 1
register_t	kpsw = PSL_Q | PSL_P | PSL_C | PSL_D;
a77 2
#include <sys/dkstat.h>

d95 2
a96 2
	__asm __volatile("ssm %0, %%r0" :: "i" (PSL_I));
	kpsw |= PSL_I;
d125 1
a125 2
	static u_int hbcnt = 0, ocp_total, ocp_idle;
	int toggle, cp_mask, cp_total;
a126 9
	cp_total = cp_time[CP_USER] + cp_time[CP_NICE] + cp_time[CP_SYS] +
	     cp_time[CP_INTR] + cp_time[CP_IDLE];
	if (!cp_total)
		cp_total = 1;
	cp_mask = 0xf0 >> (cp_time[CP_IDLE] - ocp_idle) * 4 /
	    (cp_total - ocp_total);
	cp_mask &= 0xf0;
	ocp_total = cp_total;
	ocp_idle = cp_time[CP_IDLE];
d134 8
a141 5
	if (hbcnt++ < 4)
		toggle = PALED_HEARTBEAT;
	timeout_add(&heartbeat_tmo, hz / 8);
	hbcnt &= 7;
	ledctl(cp_mask, (~cp_mask & 0xf0)|PALED_NETRCV|PALED_NETSND, toggle);
@


1.15.4.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d4 1
a4 1
 * Copyright (c) 1998-2003 Michael Shalayeff
a69 3
struct device *parsedisk(char *str, int len, int defpart, dev_t *devp);
struct device *getdisk(char *str, int len, int defpart, dev_t *devp);
int getstr(char *cp, int size);
d72 1
a72 3

/* device we booted from */
struct device *bootdv;
a84 8
#include "cd.h"
#include "sd.h"
#include "st.h"
#if NCD > 0 || NSD > 0 || NST > 0
#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>
#endif

d90 1
a90 1
cpu_configure(void)
d96 3
a98 1
	cpu_intr_init();
d104 1
a111 1
	cold = 0;
d131 1
a131 1
	    cp_time[CP_INTR] + cp_time[CP_IDLE];
d150 1
a150 3
	ledctl(cp_mask,
	    (~cp_mask & 0xf0) | PALED_NETRCV | PALED_NETSND | PALED_DISK,
	    toggle);
d158 1
a158 1
swapconf(void)
d185 1
a185 1
dumpconf(void)
d222 1
a222 1
const struct nam2blk {
d226 4
a229 4
	{ "rd",		3 },
	{ "sd",		4 },
	{ "st",		5 },
	{ "cd",		6 },
d231 2
a232 2
	{ "wd",		? },
	{ "fd",		7 },
d237 1
a237 1
struct device fakerdrootdev = { DV_DISK, {}, NULL, 0, "rd0", NULL };
d245 1
a245 1
	int i;
d257 1
a257 1
	int i;
d263 1
a263 1
}
a264 81
struct device *
getdisk(str, len, defpart, devp)
	char *str;
	int len, defpart;
	dev_t *devp;
{
	struct device *dv;

	if ((dv = parsedisk(str, len, defpart, devp)) == NULL) {
		printf("use one of:");
#ifdef RAMDISK_HOOKS
		printf(" %s[a-p]", fakerdrootdev.dv_xname);
#endif
		for (dv = alldevs.tqh_first; dv != NULL;
		    dv = dv->dv_list.tqe_next) {
			if (dv->dv_class == DV_DISK)
				printf(" %s[a-p]", dv->dv_xname);
#ifdef NFSCLIENT
			if (dv->dv_class == DV_IFNET)
				printf(" %s", dv->dv_xname);
#endif
		}
		printf(" halt\n");
	}
	return (dv);
}

struct device *
parsedisk(str, len, defpart, devp)
	char *str;
	int len, defpart;
	dev_t *devp;
{
	struct device *dv;
	char *cp, c;
	int majdev, part;

	if (len == 0)
		return (NULL);

	if (len == 4 && !strcmp(str, "halt"))
		boot(RB_HALT);

	cp = str + len - 1;
	c = *cp;
	if (c >= 'a' && c <= ('a' + MAXPARTITIONS - 1)) {
		part = c - 'a';
		*cp = '\0';
	} else
		part = defpart;

#ifdef RAMDISK_HOOKS
	if (strcmp(str, fakerdrootdev.dv_xname) == 0) {
		dv = &fakerdrootdev;
		goto gotdisk;
	}
#endif
	for (dv = alldevs.tqh_first; dv != NULL; dv = dv->dv_list.tqe_next) {
		if (dv->dv_class == DV_DISK &&
		    strcmp(str, dv->dv_xname) == 0) {
#ifdef RAMDISK_HOOKS
gotdisk:
#endif
			majdev = findblkmajor(dv);
			if (majdev < 0)
				panic("parsedisk");
			*devp = MAKEDISKDEV(majdev, dv->dv_unit, part);
			break;
		}
#ifdef NFSCLIENT
		if (dv->dv_class == DV_IFNET &&
		    strcmp(str, dv->dv_xname) == 0) {
			*devp = NODEV;
			break;
		}
#endif
	}

	*cp = c;
	return (dv);
}
d276 1
a276 1
setroot(void)
d279 1
a279 5
	struct device *dv;
	int len, majdev, unit, part;
	dev_t nrootdev, nswapdev = NODEV;
	char buf[128];
	dev_t temp;
d281 3
a283 1
	struct device *rootdv, *swapdv;
a287 5
#ifdef RAMDISK_HOOKS
	bootdv = &fakerdrootdev;
#endif
	part = 0;

d289 1
a289 1
	 * If 'swap generic' and we couldn't determine boot device,
a297 27
			if (bootdv != NULL) {
				printf(" (default %s", bootdv->dv_xname);
				if (bootdv->dv_class == DV_DISK)
					printf("%c", part + 'a');
				printf(")");
			}
			printf(": ");
			len = getstr(buf, sizeof(buf));
			if (len == 0 && bootdv != NULL) {
				strlcpy(buf, bootdv->dv_xname, sizeof buf);
				len = strlen(buf);
			}
			if (len > 0 && buf[len - 1] == '*') {
				buf[--len] = '\0';
				dv = getdisk(buf, len, 1, &nrootdev);
				if (dv != NULL) {
					rootdv = swapdv = dv;
					nswapdev = nrootdev;
					goto gotswap;
				}
			}
			dv = getdisk(buf, len, part, &nrootdev);
			if (dv != NULL) {
				rootdv = dv;
				break;
			}
		}
a298 39
		/*
		 * because swap must be on same device type as root, for
		 * network devices this is easy.
		 */
		if (rootdv->dv_class == DV_IFNET) {
			swapdv = NULL;
			goto gotswap;
		}
		for (;;) {
			printf("swap device (default %s", rootdv->dv_xname);
			if (rootdv->dv_class == DV_DISK)
				printf("b");
			printf("): ");
			len = getstr(buf, sizeof(buf));
			if (len == 0) {
				switch (rootdv->dv_class) {
				case DV_IFNET:
					nswapdev = NODEV;
					break;
				case DV_DISK:
					nswapdev = MAKEDISKDEV(major(nrootdev),
					    DISKUNIT(nrootdev), 1);
					break;
				case DV_TAPE:
				case DV_TTY:
				case DV_DULL:
				case DV_CPU:
					break;
				}
				swapdv = rootdv;
				break;
			}
			dv = getdisk(buf, len, 1, &nswapdev);
			if (dv) {
				if (dv->dv_class == DV_IFNET)
					nswapdev = NODEV;
				swapdv = dv;
				break;
			}
a299 5
gotswap:
		rootdev = nrootdev;
		dumpdev = nswapdev;
		swdevt[0].sw_dev = nswapdev;
		swdevt[1].sw_dev = NODEV;
d309 1
d312 5
a316 4
			rootdv = swapdv = bootdv;
			rootdev = MAKEDISKDEV(majdev, bootdv->dv_unit, part);
			nswapdev = dumpdev =
			    MAKEDISKDEV(majdev, bootdv->dv_unit, 1);
a320 1
			rootdv = swapdv = bootdv;
d325 5
d331 1
d336 3
a338 2

		rootdevname = findblkname(major(rootdev));
d342 1
a342 1
	switch (rootdv->dv_class) {
d346 1
a346 1
		nfsbootdevname = rootdv->dv_xname;
d352 4
a355 1
		printf("root on %s%c", rootdv->dv_xname,
d381 7
a387 54
	if (swp->sw_dev == NODEV)
		return;

	/*
	 * If dumpdev was the same as the old primary swap device,
	 * move it to the new primary swap device.
	 */
	if (temp == dumpdev)
		dumpdev = swdevt[0].sw_dev;
}

int
getstr(cp, size)
	char *cp;
	int size;
{
	char *lp;
	int c;
	int len;

	lp = cp;
	len = 0;
	for (;;) {
		c = cngetc();
		switch (c) {
		case '\n':
		case '\r':
			printf("\n");
			*lp++ = '\0';
			return (len);
		case '\b':
		case '\177':
		case '#':
			if (len) {
				--len;
				--lp;
				printf("\b \b");
			}
			continue;
		case '@@':
		case 'u'&037:
			len = 0;
			lp = cp;
			printf("\n");
			continue;
		default:
			if (len + 1 >= size || c < ' ') {
				printf("\007");
				continue;
			}
			printf("%c", c);
			++len;
			*lp++ = c;
		}
a390 5
struct pdc_memmap pdc_memmap PDC_ALIGNMENT;
struct pdc_sysmap_find pdc_find PDC_ALIGNMENT;
struct pdc_sysmap_addrs pdc_addr PDC_ALIGNMENT;
struct pdc_iodc_read pdc_iodc_read PDC_ALIGNMENT;

d392 1
a392 1
pdc_scanbus(self, ca, maxmod)
d395 1
a395 1
	int maxmod;
d397 3
a399 1
	int i;
d403 1
a403 1
		int error;
d405 4
a408 59
		bzero(&nca, sizeof(nca));
		nca.ca_iot = ca->ca_iot;
		nca.ca_dmatag = ca->ca_dmatag;
		nca.ca_dp.dp_bc[0] = ca->ca_dp.dp_bc[1];
		nca.ca_dp.dp_bc[1] = ca->ca_dp.dp_bc[2];
		nca.ca_dp.dp_bc[2] = ca->ca_dp.dp_bc[3];
		nca.ca_dp.dp_bc[3] = ca->ca_dp.dp_bc[4];
		nca.ca_dp.dp_bc[4] = ca->ca_dp.dp_bc[5];
		nca.ca_dp.dp_bc[5] = ca->ca_dp.dp_mod;
		nca.ca_dp.dp_mod = i;
		nca.ca_hpamask = ca->ca_hpamask;

		if ((error = pdc_call((iodcio_t)pdc, 0, PDC_MEMMAP,
		    PDC_MEMMAP_HPA, &pdc_memmap, &nca.ca_dp)) == 0)
			nca.ca_hpa = pdc_memmap.hpa;
		else if ((error = pdc_call((iodcio_t)pdc, 0, PDC_SYSMAP,
		    PDC_SYSMAP_HPA, &pdc_memmap, &nca.ca_dp)) == 0) {
			struct device_path path;
			int im, ia;

			nca.ca_hpa = pdc_memmap.hpa;

			/* TODO fetch the hpa size and the addrs */
			for (im = 0; !(error = pdc_call((iodcio_t)pdc, 0,
			    PDC_SYSMAP, PDC_SYSMAP_FIND,
			    &pdc_find, &path, im)) &&
			    pdc_find.hpa != nca.ca_hpa; im++)
				;

			if (!error)
				nca.ca_hpasz = pdc_find.size << PGSHIFT;

			if (!error && pdc_find.naddrs) {
				nca.ca_naddrs = pdc_find.naddrs;
				if (nca.ca_naddrs > 16) {
					nca.ca_naddrs = 16;
					printf("WARNING: too many (%d) addrs\n",
					    pdc_find.naddrs);
				}

				if (autoconf_verbose)
					printf(">> ADDRS:");

				for (ia = 0; !(error = pdc_call((iodcio_t)pdc,
				    0, PDC_SYSMAP, PDC_SYSMAP_ADDR, &pdc_addr,
				    im, ia)) && ia < nca.ca_naddrs; ia++) {
					nca.ca_addrs[ia].addr = pdc_addr.hpa;
					nca.ca_addrs[ia].size =
					    pdc_addr.size << PGSHIFT;

					if (autoconf_verbose)
						printf(" 0x%x[0x%x]",
						    nca.ca_addrs[ia].addr,
						    nca.ca_addrs[ia].size);
				}
				if (autoconf_verbose)
					printf("\n");
			}
		}
d410 2
a411 1
		if (!nca.ca_hpa)
d414 4
a417 9
		if (autoconf_verbose)
			printf(">> HPA 0x%x[0x%x]\n",
			    nca.ca_hpa, nca.ca_hpasz);

		if ((error = pdc_call((iodcio_t)pdc, 0, PDC_IODC,
		    PDC_IODC_READ, &pdc_iodc_read, nca.ca_hpa, IODC_DATA,
		    &nca.ca_type, sizeof(nca.ca_type))) < 0) {
			if (autoconf_verbose)
				printf(">> iodc_data error %d\n", error);
a418 1
		}
d420 2
d428 3
a430 4
			    nca.ca_dp.dp_flags, PZF_BITS,
			    nca.ca_dp.dp_bc[0], nca.ca_dp.dp_bc[1],
			    nca.ca_dp.dp_bc[2], nca.ca_dp.dp_bc[3],
			    nca.ca_dp.dp_bc[4], nca.ca_dp.dp_bc[5]);
d432 1
a432 1
			    nca.ca_dp.dp_mod, nca.ca_hpa,
d440 1
a440 1
const struct hppa_mod_info hppa_knownmods[] = {
d448 1
a448 1
	const struct hppa_mod_info *mi;
d452 1
a452 1
	    (mi->mi_type != type || mi->mi_sv != sv); mi++);
d455 1
a455 1
		snprintf(fakeid, sizeof fakeid, "type %x, sv %x", type, sv);
a460 88
void
device_register(struct device *dev, void *aux)
{
	struct confargs *ca = aux;
	char *basename;
	static struct device *elder = NULL;

	if (bootdv != NULL)
		return;	/* We already have a winner */

	if (ca->ca_hpa == (hppa_hpa_t)PAGE0->mem_boot.pz_hpa) {
		/*
		 * If hpa matches, the only thing we know is that the
		 * booted device is either this one or one of its children.
		 * And the children will not necessarily have the correct
		 * hpa value.
		 * Save this elder for now.
		 */
		elder = dev;
	} else if (elder == NULL) {
		return;	/* not the device we booted from */
	}

	/*
	 * Unfortunately, we can not match on pz_class vs dv_class on
	 * older snakes netbooting using the rbootd protocol.
	 * In this case, we'll end up with pz_class == PCL_RANDOM...
	 * Instead, trust the device class from what the kernel attached
	 * now...
	 */
	switch (dev->dv_class) {
	case DV_IFNET:
		/*
		 * Netboot is the top elder
		 */
		if (elder == dev) {
			bootdv = dev;
		}
		return;
	case DV_DISK:
		if ((PAGE0->mem_boot.pz_class & PCL_CLASS_MASK) != PCL_RANDOM)
			return;
		break;
	case DV_TAPE:
		if ((PAGE0->mem_boot.pz_class & PCL_CLASS_MASK) != PCL_SEQU)
			return;
		break;
	default:
		/* No idea what we were booted from, but better ask the user */
		return;
	}

	/*
	 * If control goes here, we are booted from a block device and we
	 * matched a block device.
	 */
	basename = dev->dv_cfdata->cf_driver->cd_name;

	/*
	 * We only grok SCSI boot currently. Match on proper device hierarchy,
	 * name and unit/lun values.
	 */
#if NCD > 0 || NSD > 0 || NST > 0
	if (strcmp(basename, "sd") == 0 || strcmp(basename, "cd") == 0 ||
	    strcmp(basename, "st") == 0) {
		struct scsibus_attach_args *sa = aux;
		struct scsi_link *sl = sa->sa_sc_link;

		/*
		 * sd/st/cd is attached to scsibus which is attached to
		 * the controller. Hence the grandparent here should be
		 * the elder.
		 */
		if (dev->dv_parent == NULL ||
		    dev->dv_parent->dv_parent != elder) {
			return;
		}

		/*
		 * And now check for proper target and lun values
		 */
		if (sl->target == PAGE0->mem_boot.pz_layers[0] &&
		    sl->lun == PAGE0->mem_boot.pz_layers[1]) {
			bootdv = dev;
		}
	}
#endif
}
@


1.14
log
@Rename configure() to cpu_configure().
Move it from cpu_startup() to main().
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.13 2001/04/01 06:25:33 mickey Exp $	*/
a88 2
	extern int cold;

@


1.13
log
@cleanup a little
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.12 2001/03/29 00:46:49 mickey Exp $	*/
d83 1
a83 1
 * configure:
d87 1
a87 1
configure()
@


1.12
log
@here labels we define
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.11 2001/01/26 22:15:04 mickey Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998-2000 Michael Shalayeff
a222 1
	{ "acd",	4 },
@


1.11
log
@constify nam2blk
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.10 2000/04/06 20:05:39 todd Exp $	*/
a62 1
#include <hppa/dev/cpudevs_data.h>
d214 1
a214 1
const struct nam2blk {
d399 4
@


1.10
log
@in the heat of the night...
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.9 2000/03/30 16:33:27 mickey Exp $	*/
d215 2
a216 2
struct nam2blk {
	char *name;
@


1.9
log
@smarter heartbeat()
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.8 2000/03/29 23:11:12 mickey Exp $	*/
d110 1
a110 1
	heatbeat(NULL);
@


1.8
log
@timeout-driven heartbeat.
right thing would be to pass beat count as an argument to timeout
routine (casted to (void *)) avoiding static counter, but
doing timeout_set() every timeout_add() sounds kinda uncool.
well, pondering in the struct timeout guts would be even more ugly.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.7 1999/11/25 18:31:53 mickey Exp $	*/
d110 1
a110 1
	timeout_add(&heartbeat_tmo, hz / 8);
d136 1
a136 1
	if (hbcnt % 8 < 4)
d138 6
a143 3
	hbcnt++;

	timeout_add(&heartbeat_tmo, hz / 8);
@


1.7
log
@kernel psw register
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.6 1999/11/16 17:00:30 mickey Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998 Michael Shalayeff
d55 1
d75 9
d107 34
d142 1
d192 1
a192 1
	if (dumpblks < 0)  
@


1.7.2.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.13 2001/04/01 06:25:33 mickey Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998-2001 Michael Shalayeff
a54 1
#include <sys/timeout.h>
d62 1
a73 9
 * LED blinking thing
 */
#ifdef USELEDS
struct timeout heartbeat_tmo;
void heartbeat __P((void *));
extern int hz;
#endif

/*
a96 37

#ifdef USELEDS
	timeout_set(&heartbeat_tmo, heartbeat, NULL);
	heartbeat(NULL);
#endif
}

#ifdef USELEDS
/*
 * turn the heartbeat alive.
 * right thing would be to pass counter to each subsequent timeout
 * as an argument to heartbeat() incrementing every turn,
 * i.e. avoiding the static hbcnt, but doing timeout_set() on each
 * timeout_add() sounds ugly, guts of struct timeout looks ugly
 * to ponder in even more.
 */
void
heartbeat(v)
	void *v;
{
	static u_int hbcnt = 0;

	/*
	 * do this:
	 *
	 *   |~| |~|
	 *  _| |_| |_,_,_,_
	 *   0 1 2 3 4 6 7
	 */
	if (hbcnt < 4) {
		ledctl(0, 0, PALED_HEARTBEAT);
		hbcnt++;
		timeout_add(&heartbeat_tmo, hz / 8);
	} else {
		hbcnt = 0;
		timeout_add(&heartbeat_tmo, hz / 2);
	}
a97 1
#endif
d147 1
a147 1
	if (dumpblks < 0)
d167 2
a168 2
static const struct nam2blk {
	char name[4];
d176 1
a351 4

static const struct hppa_mod_info hppa_knownmods[] = {
#include <hppa/dev/cpudevs_data.h>
};
@


1.7.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.7.2.1 2001/04/18 16:06:06 niklas Exp $	*/
d83 1
a83 1
 * cpu_configure:
d87 1
a87 1
cpu_configure()
d89 2
@


1.7.2.3
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d70 1
a70 1
void (*cold_hook) __P((int)); /* see below */
d103 1
a103 1
		(*cold_hook)(HPPA_COLD_HOT);
a391 12

		if (autoconf_verbose) {
			printf(">> probing: flags %b bc %d/%d/%d/%d/%d/%d ",
			    dp.dp_flags, PZF_BITS,
			    dp.dp_bc[0], dp.dp_bc[1], dp.dp_bc[2],
			    dp.dp_bc[3], dp.dp_bc[4], dp.dp_bc[5]);
			printf("mod %x layers %x/%x/%x/%x/%x/%x\n",
			    dp.dp_mod,
			    dp.dp_layers[0], dp.dp_layers[1],
			    dp.dp_layers[2], dp.dp_layers[3],
			    dp.dp_layers[4], dp.dp_layers[5]);
		}
@


1.7.2.4
log
@Merge in -current from about a week ago
@
text
@d64 3
a66 3
void	setroot(void);
void	swapconf(void);
void	dumpconf(void);
d68 1
a68 1
static int findblkmajor(struct device *dv);
d70 1
a70 1
void (*cold_hook)(int); /* see below */
d78 1
a78 1
void heartbeat(void *);
@


1.7.2.5
log
@Sync the SMP branch with 3.3
@
text
@d68 1
a68 5
int findblkmajor(struct device *dv);
const char *findblkname(int maj);
struct device *parsedisk(char *str, int len, int defpart, dev_t *devp);
struct device *getdisk(char *str, int len, int defpart, dev_t *devp);
int getstr(char *cp, int size);
d71 1
a71 3

/* device we booted from */
struct device *bootdv;
a76 2
#include <sys/dkstat.h>

a81 8
#include "cd.h"
#include "sd.h"
#include "st.h"
#if NCD > 0 || NSD > 0 || NST > 0
#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>
#endif

d87 1
a87 1
cpu_configure(void)
d93 3
a95 1
	cpu_intr_init();
d101 1
a108 1
	cold = 0;
d124 1
a124 2
	static u_int hbcnt = 0, ocp_total, ocp_idle;
	int toggle, cp_mask, cp_total;
a125 9
	cp_total = cp_time[CP_USER] + cp_time[CP_NICE] + cp_time[CP_SYS] +
	    cp_time[CP_INTR] + cp_time[CP_IDLE];
	if (!cp_total)
		cp_total = 1;
	cp_mask = 0xf0 >> (cp_time[CP_IDLE] - ocp_idle) * 4 /
	    (cp_total - ocp_total);
	cp_mask &= 0xf0;
	ocp_total = cp_total;
	ocp_idle = cp_time[CP_IDLE];
d133 8
a140 5
	if (hbcnt++ < 4)
		toggle = PALED_HEARTBEAT;
	timeout_add(&heartbeat_tmo, hz / 8);
	hbcnt &= 7;
	ledctl(cp_mask, (~cp_mask & 0xf0)|PALED_NETRCV|PALED_NETSND, toggle);
d148 1
a148 1
swapconf(void)
d175 1
a175 1
dumpconf(void)
d212 1
a212 1
const struct nam2blk {
d216 4
a219 4
	{ "rd",		3 },
	{ "sd",		4 },
	{ "st",		5 },
	{ "cd",		6 },
d221 2
a222 2
	{ "wd",		? },
	{ "fd",		7 },
d227 1
a227 1
struct device fakerdrootdev = { DV_DISK, {}, NULL, 0, "rd0", NULL };
d230 1
a230 1
int
d235 1
a235 1
	int i;
a242 94
const char *
findblkname(maj)
	int maj;
{
	int i;

	for (i = 0; i < sizeof(nam2blk) / sizeof(nam2blk[0]); ++i)
		if (maj == nam2blk[i].maj)
			return (nam2blk[i].name);
	return (NULL);
}

struct device *
getdisk(str, len, defpart, devp)
	char *str;
	int len, defpart;
	dev_t *devp;
{
	struct device *dv;

	if ((dv = parsedisk(str, len, defpart, devp)) == NULL) {
		printf("use one of:");
#ifdef RAMDISK_HOOKS
		printf(" %s[a-p]", fakerdrootdev.dv_xname);
#endif
		for (dv = alldevs.tqh_first; dv != NULL;
		    dv = dv->dv_list.tqe_next) {
			if (dv->dv_class == DV_DISK)
				printf(" %s[a-p]", dv->dv_xname);
#ifdef NFSCLIENT
			if (dv->dv_class == DV_IFNET)
				printf(" %s", dv->dv_xname);
#endif
		}
		printf(" halt\n");
	}
	return (dv);
}

struct device *
parsedisk(str, len, defpart, devp)
	char *str;
	int len, defpart;
	dev_t *devp;
{
	struct device *dv;
	char *cp, c;
	int majdev, part;

	if (len == 0)
		return (NULL);

	if (len == 4 && !strcmp(str, "halt"))
		boot(RB_HALT);

	cp = str + len - 1;
	c = *cp;
	if (c >= 'a' && c <= ('a' + MAXPARTITIONS - 1)) {
		part = c - 'a';
		*cp = '\0';
	} else
		part = defpart;

#ifdef RAMDISK_HOOKS
	if (strcmp(str, fakerdrootdev.dv_xname) == 0) {
		dv = &fakerdrootdev;
		goto gotdisk;
	}
#endif
	for (dv = alldevs.tqh_first; dv != NULL; dv = dv->dv_list.tqe_next) {
		if (dv->dv_class == DV_DISK &&
		    strcmp(str, dv->dv_xname) == 0) {
#ifdef RAMDISK_HOOKS
gotdisk:
#endif
			majdev = findblkmajor(dv);
			if (majdev < 0)
				panic("parsedisk");
			*devp = MAKEDISKDEV(majdev, dv->dv_unit, part);
			break;
		}
#ifdef NFSCLIENT
		if (dv->dv_class == DV_IFNET &&
		    strcmp(str, dv->dv_xname) == 0) {
			*devp = NODEV;
			break;
		}
#endif
	}

	*cp = c;
	return (dv);
}

d253 1
a253 1
setroot(void)
d256 3
a258 7
	struct device *dv;
	int len, majdev, unit, part;
	dev_t nrootdev, nswapdev = NODEV;
	char buf[128];
	dev_t temp;
	const char *rootdevname;
	struct device *rootdv, *swapdv;
a262 5
#ifdef RAMDISK_HOOKS
	bootdv = &fakerdrootdev;
#endif
	part = 0;

d264 1
a264 1
	 * If 'swap generic' and we couldn't determine boot device,
a272 27
			if (bootdv != NULL) {
				printf(" (default %s", bootdv->dv_xname);
				if (bootdv->dv_class == DV_DISK)
					printf("%c", part + 'a');
				printf(")");
			}
			printf(": ");
			len = getstr(buf, sizeof(buf));
			if (len == 0 && bootdv != NULL) {
				strcpy(buf, bootdv->dv_xname);
				len = strlen(buf);
			}
			if (len > 0 && buf[len - 1] == '*') {
				buf[--len] = '\0';
				dv = getdisk(buf, len, 1, &nrootdev);
				if (dv != NULL) {
					rootdv = swapdv = dv;
					nswapdev = nrootdev;
					goto gotswap;
				}
			}
			dv = getdisk(buf, len, part, &nrootdev);
			if (dv != NULL) {
				rootdv = dv;
				break;
			}
		}
a273 39
		/*
		 * because swap must be on same device type as root, for
		 * network devices this is easy.
		 */
		if (rootdv->dv_class == DV_IFNET) {
			swapdv = NULL;
			goto gotswap;
		}
		for (;;) {
			printf("swap device (default %s", rootdv->dv_xname);
			if (rootdv->dv_class == DV_DISK)
				printf("b");
			printf("): ");
			len = getstr(buf, sizeof(buf));
			if (len == 0) {
				switch (rootdv->dv_class) {
				case DV_IFNET:
					nswapdev = NODEV;
					break;
				case DV_DISK:
					nswapdev = MAKEDISKDEV(major(nrootdev),
					    DISKUNIT(nrootdev), 1);
					break;
				case DV_TAPE:
				case DV_TTY:
				case DV_DULL:
				case DV_CPU:
					break;
				}
				swapdv = rootdv;
				break;
			}
			dv = getdisk(buf, len, 1, &nswapdev);
			if (dv) {
				if (dv->dv_class == DV_IFNET)
					nswapdev = NODEV;
				swapdv = dv;
				break;
			}
a274 5
gotswap:
		rootdev = nrootdev;
		dumpdev = nswapdev;
		swdevt[0].sw_dev = nswapdev;
		swdevt[1].sw_dev = NODEV;
d284 1
d287 5
a291 4
			rootdv = swapdv = bootdv;
			rootdev = MAKEDISKDEV(majdev, bootdv->dv_unit, part);
			nswapdev = dumpdev =
			    MAKEDISKDEV(majdev, bootdv->dv_unit, 1);
a295 1
			rootdv = swapdv = bootdv;
d300 1
d302 1
d307 3
a309 2

		rootdevname = findblkname(major(rootdev));
d313 1
a313 1
	switch (rootdv->dv_class) {
d317 1
a317 1
		nfsbootdevname = rootdv->dv_xname;
d323 5
a327 6
		printf("root on %s%c", rootdv->dv_xname,
		    DISKPART(rootdev) + 'a');
		if (nswapdev != NODEV)
			printf(" swap on %s%c", swapdv->dv_xname,
			    DISKPART(nswapdev) + 'a');
		printf("\n");
d348 7
a354 54
	if (swp->sw_dev == NODEV)
		return;

	/*
	 * If dumpdev was the same as the old primary swap device,
	 * move it to the new primary swap device.
	 */
	if (temp == dumpdev)
		dumpdev = swdevt[0].sw_dev;
}

int
getstr(cp, size)
	char *cp;
	int size;
{
	char *lp;
	int c;
	int len;

	lp = cp;
	len = 0;
	for (;;) {
		c = cngetc();
		switch (c) {
		case '\n':
		case '\r':
			printf("\n");
			*lp++ = '\0';
			return (len);
		case '\b':
		case '\177':
		case '#':
			if (len) {
				--len;
				--lp;
				printf("\b \b");
			}
			continue;
		case '@@':
		case 'u'&037:
			len = 0;
			lp = cp;
			printf("\n");
			continue;
		default:
			if (len + 1 >= size || c < ' ') {
				printf("\007");
				continue;
			}
			printf("%c", c);
			++len;
			*lp++ = c;
		}
d359 1
a359 1
pdc_scanbus(self, ca, maxmod)
d362 1
a362 1
	int maxmod;
d364 3
a366 1
	int i;
d369 1
a370 4
		struct pdc_memmap pdc_memmap;
		struct confargs nca;
		hppa_hpa_t hpa;
		int error;
d372 4
a375 16
		hpa = 0;
		nca = *ca;
		nca.ca_dp.dp_bc[0] = ca->ca_dp.dp_bc[1];
		nca.ca_dp.dp_bc[1] = ca->ca_dp.dp_bc[2];
		nca.ca_dp.dp_bc[2] = ca->ca_dp.dp_bc[3];
		nca.ca_dp.dp_bc[3] = ca->ca_dp.dp_bc[4];
		nca.ca_dp.dp_bc[4] = ca->ca_dp.dp_bc[5];
		nca.ca_dp.dp_bc[5] = ca->ca_dp.dp_mod;
		nca.ca_dp.dp_mod = i;

		if ((error = pdc_call((iodcio_t)pdc, 0, PDC_MEMMAP,
		    PDC_MEMMAP_HPA, &pdc_memmap, &nca.ca_dp)) == 0)
			hpa = pdc_memmap.hpa;
		else if ((error = pdc_call((iodcio_t)pdc, 0, PDC_SYSMAP,
		    PDC_SYSMAP_HPA, &pdc_memmap, &nca.ca_dp)) == 0)
			hpa = pdc_memmap.hpa;
d377 2
a378 1
		if (!hpa)
d381 4
a384 8
		if (autoconf_verbose)
			printf(">> HPA 0x%x\n", hpa);

		if ((error = pdc_call((iodcio_t)pdc, 0, PDC_IODC,
		    PDC_IODC_READ, &pdc_iodc_read, hpa, IODC_DATA,
		    &nca.ca_type, sizeof(nca.ca_type))) < 0) {
			if (autoconf_verbose)
				printf(">> iodc_data error %d\n", error);
a385 1
		}
d387 2
a388 1
		nca.ca_hpa = hpa;
d395 8
a402 7
			    nca.ca_dp.dp_flags, PZF_BITS,
			    nca.ca_dp.dp_bc[0], nca.ca_dp.dp_bc[1],
			    nca.ca_dp.dp_bc[2], nca.ca_dp.dp_bc[3],
			    nca.ca_dp.dp_bc[4], nca.ca_dp.dp_bc[5]);
			printf("mod %x hpa %x type %x sv %x\n",
			    nca.ca_dp.dp_mod, hpa,
			    nca.ca_type.iodc_type, nca.ca_type.iodc_sv_model);
d409 1
a409 1
const struct hppa_mod_info hppa_knownmods[] = {
d417 1
a417 1
	const struct hppa_mod_info *mi;
d421 1
a421 1
	    (mi->mi_type != type || mi->mi_sv != sv); mi++);
a429 88
void
device_register(struct device *dev, void *aux)
{
	struct confargs *ca = aux;
	char *basename;
	static struct device *elder = NULL;

	if (bootdv != NULL)
		return;	/* We already have a winner */

	if (ca->ca_hpa == (hppa_hpa_t)PAGE0->mem_boot.pz_hpa) {
		/*
		 * If hpa matches, the only thing we know is that the
		 * booted device is either this one or one of its children.
		 * And the children will not necessarily have the correct
		 * hpa value.
		 * Save this elder for now.
		 */
		elder = dev;
	} else if (elder == NULL) {
		return;	/* not the device we booted from */
	}

	/*
	 * Unfortunately, we can not match on pz_class vs dv_class on
	 * older snakes netbooting using the rbootd protocol.
	 * In this case, we'll end up with pz_class == PCL_RANDOM...
	 * Instead, trust the device class from what the kernel attached
	 * now...
	 */
	switch (dev->dv_class) {
	case DV_IFNET:
		/*
		 * Netboot is the top elder
		 */
		if (elder == dev) {
			bootdv = dev;
		}
		return;
	case DV_DISK:
		if ((PAGE0->mem_boot.pz_class & PCL_CLASS_MASK) != PCL_RANDOM)
			return;
		break;
	case DV_TAPE:
		if ((PAGE0->mem_boot.pz_class & PCL_CLASS_MASK) != PCL_SEQU)
			return;
		break;
	default:
		/* No idea what we were booted from, but better ask the user */
		return;
	}

	/*
	 * If control goes here, we are booted from a block device and we
	 * matched a block device.
	 */
	basename = dev->dv_cfdata->cf_driver->cd_name;

	/*
	 * We only grok SCSI boot currently. Match on proper device hierarchy,
	 * name and unit/lun values.
	 */
#if NCD > 0 || NSD > 0 || NST > 0
	if (strcmp(basename, "sd") == 0 || strcmp(basename, "cd") == 0 ||
	    strcmp(basename, "st") == 0) {
		struct scsibus_attach_args *sa = aux;
		struct scsi_link *sl = sa->sa_sc_link;

		/*
		 * sd/st/cd is attached to scsibus which is attached to
		 * the controller. Hence the grandparent here should be
		 * the elder.
		 */
		if (dev->dv_parent == NULL ||
		    dev->dv_parent->dv_parent != elder) {
			return;
		}

		/*
		 * And now check for proper target and lun values
		 */
		if (sl->target == PAGE0->mem_boot.pz_layers[0] &&
		    sl->lun == PAGE0->mem_boot.pz_layers[1]) {
			bootdv = dev;
		}
	}
#endif
}
@


1.7.2.6
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.7.2.5 2003/03/27 23:26:53 niklas Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998-2003 Michael Shalayeff
d161 1
a161 3
	ledctl(cp_mask,
	    (~cp_mask & 0xf0) | PALED_NETRCV | PALED_NETSND | PALED_DISK,
	    toggle);
d406 1
a406 1
				strlcpy(buf, bootdv->dv_xname, sizeof buf);
a596 5
struct pdc_memmap pdc_memmap PDC_ALIGNMENT;
struct pdc_sysmap_find pdc_find PDC_ALIGNMENT;
struct pdc_sysmap_addrs pdc_addr PDC_ALIGNMENT;
struct pdc_iodc_read pdc_iodc_read PDC_ALIGNMENT;

d606 2
d609 1
d612 2
a613 3
		bzero(&nca, sizeof(nca));
		nca.ca_iot = ca->ca_iot;
		nca.ca_dmatag = ca->ca_dmatag;
a620 1
		nca.ca_hpamask = ca->ca_hpamask;
d624 1
a624 1
			nca.ca_hpa = pdc_memmap.hpa;
d626 2
a627 43
		    PDC_SYSMAP_HPA, &pdc_memmap, &nca.ca_dp)) == 0) {
			struct device_path path;
			int im, ia;

			nca.ca_hpa = pdc_memmap.hpa;

			/* TODO fetch the hpa size and the addrs */
			for (im = 0; !(error = pdc_call((iodcio_t)pdc, 0,
			    PDC_SYSMAP, PDC_SYSMAP_FIND,
			    &pdc_find, &path, im)) &&
			    pdc_find.hpa != nca.ca_hpa; im++)
				;

			if (!error)
				nca.ca_hpasz = pdc_find.size << PGSHIFT;

			if (!error && pdc_find.naddrs) {
				nca.ca_naddrs = pdc_find.naddrs;
				if (nca.ca_naddrs > 16) {
					nca.ca_naddrs = 16;
					printf("WARNING: too many (%d) addrs\n",
					    pdc_find.naddrs);
				}

				if (autoconf_verbose)
					printf(">> ADDRS:");

				for (ia = 0; !(error = pdc_call((iodcio_t)pdc,
				    0, PDC_SYSMAP, PDC_SYSMAP_ADDR, &pdc_addr,
				    im, ia)) && ia < nca.ca_naddrs; ia++) {
					nca.ca_addrs[ia].addr = pdc_addr.hpa;
					nca.ca_addrs[ia].size =
					    pdc_addr.size << PGSHIFT;

					if (autoconf_verbose)
						printf(" 0x%x[0x%x]",
						    nca.ca_addrs[ia].addr,
						    nca.ca_addrs[ia].size);
				}
				if (autoconf_verbose)
					printf("\n");
			}
		}
d629 1
a629 1
		if (!nca.ca_hpa)
d633 1
a633 2
			printf(">> HPA 0x%x[0x%x]\n",
			    nca.ca_hpa, nca.ca_hpasz);
d636 1
a636 1
		    PDC_IODC_READ, &pdc_iodc_read, nca.ca_hpa, IODC_DATA,
d643 1
d655 1
a655 1
			    nca.ca_dp.dp_mod, nca.ca_hpa,
d678 1
a678 1
		snprintf(fakeid, sizeof fakeid, "type %x, sv %x", type, sv);
@


1.7.2.7
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.7.2.6 2003/05/13 19:41:03 ho Exp $	*/
d25 5
a29 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.7.2.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a43 2
#include "pci.h"

a59 5
#if NPCI > 0
#include <dev/pci/pcivar.h>
#include <dev/pci/pcireg.h>
#endif

a79 1
#include <sys/kernel.h>
d83 1
d135 1
a135 1
	int toggle, cp_mask, cp_total, cp_idle;
a136 3
	timeout_add(&heartbeat_tmo, hz / 16);

	cp_idle = cp_time[CP_IDLE];
d139 4
a142 5
	if (cp_total == ocp_total)
		cp_total = ocp_total + 1;
	if (cp_idle == ocp_idle)
		cp_idle = ocp_idle + 1;
	cp_mask = 0xf0 >> (cp_idle - ocp_idle) * 4 / (cp_total - ocp_total);
d145 1
a145 1
	ocp_idle = cp_idle;
d153 1
a153 2
	toggle = 0;
	if (hbcnt++ < 8 && hbcnt & 1)
d155 2
a156 1
	hbcnt &= 15;
a355 19
void
print_devpath(const char *label, struct pz_device *pz)
{
	int i;

	printf("%s: ", label);

	for (i = 0; i < 6; i++)
		if (pz->pz_bc[i] >= 0)
			printf("%d/", pz->pz_bc[i]);

	printf("%d.%d", pz->pz_mod, pz->pz_layers[0]);
	for (i = 1; i < 6 && pz->pz_layers[i]; i++)
		printf(".%d", pz->pz_layers[i]);

	printf(" class=%d flags=%b hpa=%p spa=%p io=%p\n", pz->pz_class,
	    pz->pz_flags, PZF_BITS, pz->pz_hpa, pz->pz_spa, pz->pz_iodc_io);
}

d370 1
a370 1
	int len, majdev, part;
a384 2
	print_devpath("boot path", &PAGE0->mem_boot);

a463 1
		majdev = major(nrootdev);
d531 1
a531 1
		    DISKUNIT(rootdev) == DISKUNIT(swp->sw_dev)) {
d663 1
a663 1
						printf(" 0x%lx[0x%x]",
d676 1
a676 1
			printf(">> HPA 0x%lx[0x%x]\n",
d697 1
a697 1
			printf("mod %x hpa %lx type %x sv %x\n",
a729 3
#if NPCI > 0
	extern struct cfdriver pci_cd;
#endif
a736 21
#if NPCI > 0
	if (dev->dv_parent &&
	    dev->dv_parent->dv_cfdata->cf_driver == &pci_cd) {
		struct pci_attach_args *pa = aux;
		pcireg_t addr;
		int reg;

		for (reg = PCI_MAPREG_START; reg < PCI_MAPREG_END; reg += 4) {
			addr = pci_conf_read(pa->pa_pc, pa->pa_tag, reg);
			if (PCI_MAPREG_TYPE(addr) == PCI_MAPREG_TYPE_IO)
				addr = PCI_MAPREG_IO_ADDR(addr);
			else
				addr = PCI_MAPREG_MEM_ADDR(addr);

			if (addr == (pcireg_t)PAGE0->mem_boot.pz_hpa) {
				elder = dev;
				break;
			}
		}
	} else
#endif
@


1.6
log
@make a copy of attach args for each attachment
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.5 1999/08/14 03:17:32 mickey Exp $	*/
d71 1
d85 1
d87 2
a89 2
	__asm __volatile("nop\n\tnop\n\tssm %0, %%r0\n\tnop\n\tnop\n\tnop"
			 :: "i" (PSW_I));
@


1.5
log
@enable interrupts after device configuration, provide cold_hook() for things like lasi to enable power management
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.4 1999/06/22 23:45:04 mickey Exp $	*/
d323 1
d335 1
d338 1
a338 1
			     &ca->ca_type, sizeof(ca->ca_type)) < 0)
d341 5
a345 6
		ca->ca_mod = i;
		ca->ca_hpa = pdc_memmap.hpa;
		ca->ca_iot = 0;
		ca->ca_pdc_iodc_read = &pdc_iodc_read;
		ca->ca_name = hppa_mod_info(ca->ca_type.iodc_type,
					    ca->ca_type.iodc_sv_model);
d347 1
a347 1
		config_found_sm(self, ca, mbprint, mbsubmatch);
a348 1

@


1.4
log
@sprintf unknown device's id numbers in hex
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.3 1999/04/20 20:37:10 mickey Exp $	*/
d70 1
d84 1
d86 2
a87 1

d93 2
@


1.3
log
@dumpconf()
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.2 1999/02/25 19:13:31 mickey Exp $	*/
d357 1
a357 1
		sprintf(fakeid, "type %d, sv %d", type, sv);
@


1.2
log
@use config_found_sm to allow irq passing in confargs
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.1 1998/12/29 18:10:37 mickey Exp $	*/
d88 1
a112 1
	dumpconf();
d115 7
d125 33
a159 1

d176 1
a176 1
static struct device fakerdrootdev = { DV_DISK, {}, NULL, 0, "rd0", NULL };
@


1.1
log
@-a don't work yet
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d302 1
a302 1
		config_found(self, ca, mbprint);
@

