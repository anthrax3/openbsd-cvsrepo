head	1.87;
access;
symbols
	OPENBSD_6_2:1.87.0.6
	OPENBSD_6_2_BASE:1.87
	OPENBSD_6_1:1.87.0.8
	OPENBSD_6_1_BASE:1.87
	OPENBSD_6_0:1.87.0.4
	OPENBSD_6_0_BASE:1.87
	OPENBSD_5_9:1.87.0.2
	OPENBSD_5_9_BASE:1.87
	OPENBSD_5_8:1.86.0.6
	OPENBSD_5_8_BASE:1.86
	OPENBSD_5_7:1.86.0.2
	OPENBSD_5_7_BASE:1.86
	OPENBSD_5_6:1.85.0.4
	OPENBSD_5_6_BASE:1.85
	OPENBSD_5_5:1.81.0.18
	OPENBSD_5_5_BASE:1.81
	OPENBSD_5_4:1.81.0.14
	OPENBSD_5_4_BASE:1.81
	OPENBSD_5_3:1.81.0.12
	OPENBSD_5_3_BASE:1.81
	OPENBSD_5_2:1.81.0.10
	OPENBSD_5_2_BASE:1.81
	OPENBSD_5_1_BASE:1.81
	OPENBSD_5_1:1.81.0.8
	OPENBSD_5_0:1.81.0.6
	OPENBSD_5_0_BASE:1.81
	OPENBSD_4_9:1.81.0.4
	OPENBSD_4_9_BASE:1.81
	OPENBSD_4_8:1.81.0.2
	OPENBSD_4_8_BASE:1.81
	OPENBSD_4_7:1.75.0.2
	OPENBSD_4_7_BASE:1.75
	OPENBSD_4_6:1.75.0.4
	OPENBSD_4_6_BASE:1.75
	OPENBSD_4_5:1.70.0.2
	OPENBSD_4_5_BASE:1.70
	OPENBSD_4_4:1.69.0.4
	OPENBSD_4_4_BASE:1.69
	OPENBSD_4_3:1.69.0.2
	OPENBSD_4_3_BASE:1.69
	OPENBSD_4_2:1.66.0.2
	OPENBSD_4_2_BASE:1.66
	OPENBSD_4_1:1.63.0.6
	OPENBSD_4_1_BASE:1.63
	OPENBSD_4_0:1.63.0.4
	OPENBSD_4_0_BASE:1.63
	OPENBSD_3_9:1.63.0.2
	OPENBSD_3_9_BASE:1.63
	OPENBSD_3_8:1.62.0.2
	OPENBSD_3_8_BASE:1.62
	OPENBSD_3_7:1.61.0.2
	OPENBSD_3_7_BASE:1.61
	OPENBSD_3_6:1.56.0.2
	OPENBSD_3_6_BASE:1.56
	SMP_SYNC_A:1.56
	SMP_SYNC_B:1.56
	OPENBSD_3_5:1.55.0.2
	OPENBSD_3_5_BASE:1.55
	OPENBSD_3_4:1.51.0.2
	OPENBSD_3_4_BASE:1.51
	UBC_SYNC_A:1.44
	OPENBSD_3_3:1.41.0.2
	OPENBSD_3_3_BASE:1.41
	OPENBSD_3_2:1.33.0.2
	OPENBSD_3_2_BASE:1.33
	OPENBSD_3_1:1.29.0.2
	OPENBSD_3_1_BASE:1.29
	UBC_SYNC_B:1.37
	UBC:1.20.0.2
	UBC_BASE:1.20
	OPENBSD_3_0:1.13.0.2
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9:1.10.0.2
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_8:1.9.0.6
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.9.0.4
	OPENBSD_2_7_BASE:1.9
	SMP:1.9.0.2
	SMP_BASE:1.9
	kame_19991208:1.6
	OPENBSD_2_6:1.4.0.2
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.3.0.2
	OPENBSD_2_5_BASE:1.3;
locks; strict;
comment	@ * @;


1.87
date	2015.09.13.11.40.01;	author kettenis;	state Exp;
branches;
next	1.86;
commitid	Qqqm7587qW7vB6m3;

1.86
date	2014.11.16.12.30.57;	author deraadt;	state Exp;
branches;
next	1.85;
commitid	yv0ECmCdICvq576h;

1.85
date	2014.07.12.18.44.41;	author tedu;	state Exp;
branches;
next	1.84;
commitid	uKVPYMN2MLxdZxzH;

1.84
date	2014.05.08.21.32.45;	author miod;	state Exp;
branches;
next	1.83;

1.83
date	2014.04.08.09.34.23;	author mpi;	state Exp;
branches;
next	1.82;

1.82
date	2014.03.29.18.09.29;	author guenther;	state Exp;
branches;
next	1.81;

1.81
date	2010.06.19.14.06.54;	author miod;	state Exp;
branches;
next	1.80;

1.80
date	2010.05.24.15.04.55;	author deraadt;	state Exp;
branches;
next	1.79;

1.79
date	2010.05.06.14.39.52;	author jsing;	state Exp;
branches;
next	1.78;

1.78
date	2010.04.29.13.48.29;	author jsing;	state Exp;
branches;
next	1.77;

1.77
date	2010.04.27.18.29.39;	author kettenis;	state Exp;
branches;
next	1.76;

1.76
date	2010.04.20.23.27.00;	author deraadt;	state Exp;
branches;
next	1.75;

1.75
date	2009.06.11.20.10.51;	author kettenis;	state Exp;
branches;
next	1.74;

1.74
date	2009.04.20.00.42.06;	author oga;	state Exp;
branches;
next	1.73;

1.73
date	2009.04.14.16.01.04;	author oga;	state Exp;
branches;
next	1.72;

1.72
date	2009.03.08.19.26.39;	author martin;	state Exp;
branches;
next	1.71;

1.71
date	2009.03.07.15.34.34;	author miod;	state Exp;
branches;
next	1.70;

1.70
date	2009.02.01.14.53.02;	author miod;	state Exp;
branches;
next	1.69;

1.69
date	2007.12.28.19.48.50;	author kettenis;	state Exp;
branches;
next	1.68;

1.68
date	2007.12.19.19.10.54;	author kettenis;	state Exp;
branches;
next	1.67;

1.67
date	2007.10.02.00.59.12;	author krw;	state Exp;
branches;
next	1.66;

1.66
date	2007.07.15.20.11.12;	author kettenis;	state Exp;
branches;
next	1.65;

1.65
date	2007.05.29.21.00.50;	author jason;	state Exp;
branches;
next	1.64;

1.64
date	2007.05.23.18.07.19;	author kettenis;	state Exp;
branches;
next	1.63;

1.63
date	2005.10.26.18.35.44;	author martin;	state Exp;
branches;
next	1.62;

1.62
date	2005.04.07.00.21.51;	author mickey;	state Exp;
branches;
next	1.61;

1.61
date	2004.11.09.19.17.01;	author claudio;	state Exp;
branches;
next	1.60;

1.60
date	2004.09.18.21.40.20;	author mickey;	state Exp;
branches;
next	1.59;

1.59
date	2004.09.16.00.05.03;	author mickey;	state Exp;
branches;
next	1.58;

1.58
date	2004.09.15.21.32.43;	author mickey;	state Exp;
branches;
next	1.57;

1.57
date	2004.09.15.20.11.29;	author mickey;	state Exp;
branches;
next	1.56;

1.56
date	2004.04.07.18.24.19;	author mickey;	state Exp;
branches;
next	1.55;

1.55
date	2004.03.02.21.06.15;	author mickey;	state Exp;
branches;
next	1.54;

1.54
date	2003.12.20.21.49.06;	author miod;	state Exp;
branches;
next	1.53;

1.53
date	2003.09.29.19.23.02;	author mickey;	state Exp;
branches;
next	1.52;

1.52
date	2003.09.26.00.10.40;	author mickey;	state Exp;
branches;
next	1.51;

1.51
date	2003.08.20.23.33.36;	author mickey;	state Exp;
branches;
next	1.50;

1.50
date	2003.08.20.21.44.03;	author mickey;	state Exp;
branches;
next	1.49;

1.49
date	2003.08.20.20.53.31;	author mickey;	state Exp;
branches;
next	1.48;

1.48
date	2003.08.20.20.28.40;	author mickey;	state Exp;
branches;
next	1.47;

1.47
date	2003.07.29.20.49.29;	author mickey;	state Exp;
branches;
next	1.46;

1.46
date	2003.07.15.17.04.33;	author mickey;	state Exp;
branches;
next	1.45;

1.45
date	2003.06.12.17.50.27;	author mickey;	state Exp;
branches;
next	1.44;

1.44
date	2003.04.07.17.01.08;	author mickey;	state Exp;
branches;
next	1.43;

1.43
date	2003.04.04.00.25.34;	author mickey;	state Exp;
branches;
next	1.42;

1.42
date	2003.04.01.23.11.55;	author mickey;	state Exp;
branches;
next	1.41;

1.41
date	2003.02.18.19.01.50;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2003.01.22.02.13.40;	author mickey;	state Exp;
branches;
next	1.39;

1.39
date	2003.01.21.17.32.40;	author mickey;	state Exp;
branches;
next	1.38;

1.38
date	2002.12.18.23.52.45;	author mickey;	state Exp;
branches;
next	1.37;

1.37
date	2002.10.21.15.58.21;	author mickey;	state Exp;
branches;
next	1.36;

1.36
date	2002.10.13.15.53.39;	author mickey;	state Exp;
branches;
next	1.35;

1.35
date	2002.10.07.18.35.56;	author mickey;	state Exp;
branches;
next	1.34;

1.34
date	2002.10.06.22.06.15;	author art;	state Exp;
branches;
next	1.33;

1.33
date	2002.04.22.20.03.08;	author mickey;	state Exp;
branches;
next	1.32;

1.32
date	2002.04.22.01.49.42;	author mickey;	state Exp;
branches;
next	1.31;

1.31
date	2002.04.21.22.54.10;	author mickey;	state Exp;
branches;
next	1.30;

1.30
date	2002.04.21.22.27.56;	author mickey;	state Exp;
branches;
next	1.29;

1.29
date	2002.03.19.23.04.16;	author mickey;	state Exp;
branches;
next	1.28;

1.28
date	2002.03.14.01.26.31;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2002.02.21.06.17.19;	author mickey;	state Exp;
branches;
next	1.26;

1.26
date	2002.02.21.06.12.30;	author mickey;	state Exp;
branches;
next	1.25;

1.25
date	2002.02.16.02.41.15;	author mickey;	state Exp;
branches;
next	1.24;

1.24
date	2002.02.16.02.21.56;	author mickey;	state Exp;
branches;
next	1.23;

1.23
date	2002.02.12.02.44.00;	author mickey;	state Exp;
branches;
next	1.22;

1.22
date	2002.02.11.21.12.59;	author mickey;	state Exp;
branches;
next	1.21;

1.21
date	2002.02.07.05.43.51;	author mickey;	state Exp;
branches;
next	1.20;

1.20
date	2001.12.08.02.24.06;	author art;	state Exp;
branches
	1.20.2.1;
next	1.19;

1.19
date	2001.12.02.04.10.25;	author mickey;	state Exp;
branches;
next	1.18;

1.18
date	2001.12.02.04.03.57;	author mickey;	state Exp;
branches;
next	1.17;

1.17
date	2001.11.28.13.47.38;	author art;	state Exp;
branches;
next	1.16;

1.16
date	2001.11.07.01.18.00;	author art;	state Exp;
branches;
next	1.15;

1.15
date	2001.11.06.19.53.14;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2001.11.05.17.25.57;	author art;	state Exp;
branches;
next	1.13;

1.13
date	2001.09.19.20.50.56;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	2001.08.01.20.32.13;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2001.07.05.10.00.28;	author art;	state Exp;
branches;
next	1.10;

1.10
date	2001.01.12.23.49.52;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	2000.02.09.05.56.50;	author mickey;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2000.01.17.06.43.04;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	99.12.17.06.18.38;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	99.11.26.17.34.59;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	99.11.25.18.25.31;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	99.04.20.20.43.25;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	99.02.25.19.16.02;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	98.11.30.21.38.01;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	98.10.30.18.54.11;	author mickey;	state Exp;
branches;
next	;

1.9.2.1
date	2001.04.18.16.06.14;	author niklas;	state Exp;
branches;
next	1.9.2.2;

1.9.2.2
date	2001.10.31.02.52.47;	author nate;	state Exp;
branches;
next	1.9.2.3;

1.9.2.3
date	2001.11.13.21.00.51;	author niklas;	state Exp;
branches;
next	1.9.2.4;

1.9.2.4
date	2001.12.05.00.39.10;	author niklas;	state Exp;
branches;
next	1.9.2.5;

1.9.2.5
date	2002.03.06.00.57.22;	author niklas;	state Exp;
branches;
next	1.9.2.6;

1.9.2.6
date	2002.03.28.10.19.25;	author niklas;	state Exp;
branches;
next	1.9.2.7;

1.9.2.7
date	2003.03.27.23.26.53;	author niklas;	state Exp;
branches;
next	1.9.2.8;

1.9.2.8
date	2003.05.13.19.41.03;	author ho;	state Exp;
branches;
next	1.9.2.9;

1.9.2.9
date	2004.02.19.10.48.40;	author niklas;	state Exp;
branches;
next	1.9.2.10;

1.9.2.10
date	2004.06.05.23.10.48;	author niklas;	state Exp;
branches;
next	;

1.20.2.1
date	2002.06.11.03.35.37;	author art;	state Exp;
branches;
next	1.20.2.2;

1.20.2.2
date	2002.10.29.00.28.02;	author art;	state Exp;
branches;
next	1.20.2.3;

1.20.2.3
date	2003.05.19.21.49.41;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.87
log
@Adjust printf for the fact that device locators are now long.
@
text
@/*	$OpenBSD: mainbus.c,v 1.86 2014/11/16 12:30:57 deraadt Exp $	*/

/*
 * Copyright (c) 1998-2004 Michael Shalayeff
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR OR HIS RELATIVES BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

#include "lcd.h"
#include "power.h"

#undef BTLBDEBUG

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/device.h>
#include <sys/reboot.h>
#include <sys/extent.h>
#include <sys/mbuf.h>

#include <uvm/uvm_extern.h>

#include <machine/bus.h>
#include <machine/pdc.h>
#include <machine/iomod.h>
#include <machine/autoconf.h>

#include <hppa/dev/cpudevs.h>

struct mainbus_softc {
	struct  device sc_dv;

	hppa_hpa_t sc_hpa;
};

int	mbmatch(struct device *, void *, void *);
void	mbattach(struct device *, struct device *, void *);

struct cfattach mainbus_ca = {
	sizeof(struct mainbus_softc), mbmatch, mbattach
};

struct cfdriver mainbus_cd = {
	NULL, "mainbus", DV_DULL
};

struct pdc_hpa pdc_hpa PDC_ALIGNMENT;
struct pdc_power_info pdc_power_info PDC_ALIGNMENT;
struct pdc_chassis_info pdc_chassis_info PDC_ALIGNMENT;
struct pdc_chassis_lcd pdc_chassis_lcd PDC_ALIGNMENT;

/* from machdep.c */
extern struct extent *hppa_ex;
extern struct pdc_btlb pdc_btlb;

int		 mbus_add_mapping(bus_addr_t bpa, bus_size_t size, int flags,
		    bus_space_handle_t *bshp);
int		 mbus_map(void *v, bus_addr_t bpa, bus_size_t size,
		    int flags, bus_space_handle_t *bshp);
void		 mbus_unmap(void *v, bus_space_handle_t bsh, bus_size_t size);
int		 mbus_alloc(void *v, bus_addr_t rstart, bus_addr_t rend,
		    bus_size_t size, bus_size_t align, bus_size_t boundary,
		    int flags, bus_addr_t *addrp, bus_space_handle_t *bshp);
void		 mbus_free(void *v, bus_space_handle_t h, bus_size_t size);
int		 mbus_subregion(void *v, bus_space_handle_t bsh,
		    bus_size_t offset, bus_size_t size,
		    bus_space_handle_t *nbshp);
void		 mbus_barrier(void *v, bus_space_handle_t h, bus_size_t o,
		    bus_size_t l, int op);
void		*mbus_vaddr(void *v, bus_space_handle_t h);
u_int8_t	 mbus_r1(void *v, bus_space_handle_t h, bus_size_t o);
u_int16_t	 mbus_r2(void *v, bus_space_handle_t h, bus_size_t o);
u_int32_t	 mbus_r4(void *v, bus_space_handle_t h, bus_size_t o);
u_int64_t	 mbus_r8(void *v, bus_space_handle_t h, bus_size_t o);
void		 mbus_w1(void *v, bus_space_handle_t h, bus_size_t o,
		    u_int8_t vv);
void		 mbus_w2(void *v, bus_space_handle_t h, bus_size_t o,
		    u_int16_t vv);
void		 mbus_w4(void *v, bus_space_handle_t h, bus_size_t o,
		    u_int32_t vv);
void		 mbus_w8(void *v, bus_space_handle_t h, bus_size_t o,
		    u_int64_t vv);
void		 mbus_rm_1(void *v, bus_space_handle_t h, bus_size_t o,
		    u_int8_t *a, bus_size_t c);
void		 mbus_rm_2(void *v, bus_space_handle_t h, bus_size_t o,
		    u_int16_t *a, bus_size_t c);
void		 mbus_rm_4(void *v, bus_space_handle_t h, bus_size_t o,
		    u_int32_t *a, bus_size_t c);
void		 mbus_rm_8(void *v, bus_space_handle_t h, bus_size_t o,
		    u_int64_t *a, bus_size_t c);
void		 mbus_wm_1(void *v, bus_space_handle_t h, bus_size_t o,
		    const u_int8_t *a, bus_size_t c);
void		 mbus_wm_2(void *v, bus_space_handle_t h, bus_size_t o,
		    const u_int16_t *a, bus_size_t c);
void		 mbus_wm_4(void *v, bus_space_handle_t h, bus_size_t o,
		    const u_int32_t *a, bus_size_t c);
void		 mbus_wm_8(void *v, bus_space_handle_t h, bus_size_t o,
		    const u_int64_t *a, bus_size_t c);
void		 mbus_sm_1(void *v, bus_space_handle_t h, bus_size_t o,
		    u_int8_t vv, bus_size_t c);
void		 mbus_sm_2(void *v, bus_space_handle_t h, bus_size_t o,
		    u_int16_t vv, bus_size_t c);
void		 mbus_sm_4(void *v, bus_space_handle_t h, bus_size_t o,
		    u_int32_t vv, bus_size_t c);
void		 mbus_sm_8(void *v, bus_space_handle_t h, bus_size_t o,
		    u_int64_t vv, bus_size_t c);

void		 mbus_rr_1(void *v, bus_space_handle_t h, bus_size_t o,
		    u_int8_t *a, bus_size_t c);
void		 mbus_rr_2(void *v, bus_space_handle_t h, bus_size_t o,
		    u_int16_t *a, bus_size_t c);
void		 mbus_rr_4(void *v, bus_space_handle_t h, bus_size_t o,
		    u_int32_t *a, bus_size_t c);
void		 mbus_rr_8(void *v, bus_space_handle_t h, bus_size_t o,
		    u_int64_t *a, bus_size_t c);
void		 mbus_wr_1(void *v, bus_space_handle_t h, bus_size_t o,
		    const u_int8_t *a, bus_size_t c);
void		 mbus_wr_2(void *v, bus_space_handle_t h, bus_size_t o,
		    const u_int16_t *a, bus_size_t c);
void		 mbus_wr_4(void *v, bus_space_handle_t h, bus_size_t o,
		    const u_int32_t *a, bus_size_t c);
void		 mbus_wr_8(void *v, bus_space_handle_t h, bus_size_t o,
		    const u_int64_t *a, bus_size_t c);
void		 mbus_sr_1(void *v, bus_space_handle_t h, bus_size_t o,
		    u_int8_t vv, bus_size_t c);
void		 mbus_sr_2(void *v, bus_space_handle_t h, bus_size_t o,
		    u_int16_t vv, bus_size_t c);
void		 mbus_sr_4(void *v, bus_space_handle_t h, bus_size_t o,
		    u_int32_t vv, bus_size_t c);
void		 mbus_sr_8(void *v, bus_space_handle_t h, bus_size_t o,
		    u_int64_t vv, bus_size_t c);
void		 mbus_cp_1(void *v, bus_space_handle_t h1, bus_size_t o1,
		    bus_space_handle_t h2, bus_size_t o2, bus_size_t c);
void		 mbus_cp_2(void *v, bus_space_handle_t h1, bus_size_t o1,
		    bus_space_handle_t h2, bus_size_t o2, bus_size_t c);
void		 mbus_cp_4(void *v, bus_space_handle_t h1, bus_size_t o1,
		    bus_space_handle_t h2, bus_size_t o2, bus_size_t c);
void		 mbus_cp_8(void *v, bus_space_handle_t h1, bus_size_t o1,
		    bus_space_handle_t h2, bus_size_t o2, bus_size_t c);

int
mbus_add_mapping(bus_addr_t bpa, bus_size_t size, int flags,
    bus_space_handle_t *bshp)
{
	static u_int32_t bmm[0x4000/32];
	int bank, off, flex;
	vaddr_t pa, spa, epa;
	vsize_t len;

#ifdef BTLBDEBUG
	printf("bus_mem_add_mapping(%x,%x,%scachable,%p)\n",
	    bpa, size, flags? "" : "non", bshp);
#endif

	if ((bank = vm_physseg_find(atop(bpa), &off)) >= 0)
		panic("mbus_add_mapping: mapping real memory @@0x%lx", bpa);

#ifdef DEBUG
	if (flags & BUS_SPACE_MAP_CACHEABLE) {
		printf("WARNING: mapping I/O space cachable\n");
		flags &= ~BUS_SPACE_MAP_CACHEABLE;
	}
#endif

	/*
	 * Mappings are established in HPPA_FLEX_SIZE units,
	 * either with BTLB, or regular mappings of the whole area.
	 */
	pa = bpa;
	while (size != 0) {
		flex = HPPA_FLEX(pa);
		spa = pa & HPPA_FLEX_MASK;
		epa = spa + HPPA_FLEX_SIZE; /* may wrap to 0... */

		size -= min(size, HPPA_FLEX_SIZE - (pa - spa));

		/* do need a new mapping? */
		if (!(bmm[flex / 32] & (1 << (flex % 32)))) {
#ifdef BTLBDEBUG
			printf("bus_mem_add_mapping: adding flex=%x "
			    "%x-%x, ", flex, spa, epa - 1);
#endif
			while (spa != epa) {
				len = epa - spa;

				/*
				 * Try to map with a BTLB first (might map
				 * much more than what we are requesting
				 * for, and cross HPPA_FLEX boundaries).
				 *
				 * Note that this code assumes that
				 * BTLB size are a power of two, so if
				 * the size is larger than HPPA_FLEX_SIZE
				 * it will span an integral number of
				 * HPPA_FLEX_SIZE slots.
				 */
				if (len > pdc_btlb.max_size << PGSHIFT)
					len = pdc_btlb.max_size << PGSHIFT;

				if (btlb_insert(HPPA_SID_KERNEL, spa, spa, &len,
				    pmap_sid2pid(HPPA_SID_KERNEL) |
				    pmap_prot(pmap_kernel(), PROT_READ | PROT_WRITE))
				    >= 0) {
					pa = spa + len;	/* may wrap to 0... */
#ifdef BTLBDEBUG
					printf("--- %x/%x, %x-%x ",
					    flex, HPPA_FLEX(pa - 1),
					    spa, pa - 1);
#endif
					/* register all ranges */
					for (; flex <= HPPA_FLEX(pa - 1);
					    flex++) {
#ifdef BTLBDEBUG
						printf("mask %x ", flex);
#endif
						bmm[flex / 32] |=
						    (1 << (flex % 32));
					}
					if (len > epa - spa)
						spa = epa;
					else
						spa = pa;
				} else {
#ifdef BTLBDEBUG
					printf("kenter 0x%x-0x%x", spa, epa);
#endif
					for (; spa != epa; spa += PAGE_SIZE)
						pmap_kenter_pa(spa, spa,
						    PROT_READ | PROT_WRITE);
				}
#ifdef BTLBDEBUG
				printf("\n");
#endif
			}
		}
#ifdef BTLBDEBUG
		else {
			printf("+++ already b-mapped flex=%x, mask=%x\n",
			    flex, bmm[flex / 32]);
		}
#endif

		pa = epa;
	}

	*bshp = bpa;
	return (0);
}

int
mbus_map(void *v, bus_addr_t bpa, bus_size_t size,
    int flags, bus_space_handle_t *bshp)
{
	int error;

	if ((error = extent_alloc_region(hppa_ex, bpa, size, EX_NOWAIT)))
		return (error);

	if ((error = mbus_add_mapping(bpa, size, flags, bshp))) {
		if (extent_free(hppa_ex, bpa, size, EX_NOWAIT)) {
			printf("bus_space_map: pa 0x%lx, size 0x%lx\n",
				bpa, size);
			printf("bus_space_map: can't free region\n");
		}
	}

	return error;
}

void
mbus_unmap(void *v, bus_space_handle_t bsh, bus_size_t size)
{
	u_long sva, eva;

	sva = trunc_page(bsh);
	eva = round_page(bsh + size);

#ifdef DIAGNOSTIC
	if (eva <= sva)
		panic("bus_space_unmap: overflow");
#endif

	if (pmap_extract(pmap_kernel(), bsh, NULL))
		pmap_kremove(sva, eva - sva);
	else
		;	/* XXX assuming equ b-mapping been done */

	if (extent_free(hppa_ex, bsh, size, EX_NOWAIT)) {
		printf("bus_space_unmap: ps 0x%lx, size 0x%lx\n",
		    bsh, size);
		printf("bus_space_unmap: can't free region\n");
	}
}

int
mbus_alloc(void *v, bus_addr_t rstart, bus_addr_t rend, bus_size_t size,
    bus_size_t align, bus_size_t boundary, int flags,
    bus_addr_t *addrp, bus_space_handle_t *bshp)
{
	u_long bpa;
	int error;

	if (rstart < hppa_ex->ex_start || rend > hppa_ex->ex_end)
		panic("bus_space_alloc: bad region start/end");

	if ((error = extent_alloc_subregion(hppa_ex, rstart, rend, size,
	    align, 0, boundary, EX_NOWAIT, &bpa)))
		return (error);

	if ((error = mbus_add_mapping(bpa, size, flags, bshp))) {
		if (extent_free(hppa_ex, bpa, size, EX_NOWAIT)) {
			printf("bus_space_alloc: pa 0x%lx, size 0x%lx\n",
				bpa, size);
			printf("bus_space_alloc: can't free region\n");
		}
	}

	*addrp = bpa;
	return (error);
}

void
mbus_free(void *v, bus_space_handle_t h, bus_size_t size)
{
	/* bus_space_unmap() does all that we need to do. */
	mbus_unmap(v, h, size);
}

int
mbus_subregion(void *v, bus_space_handle_t bsh, bus_size_t offset,
    bus_size_t size, bus_space_handle_t *nbshp)
{
	*nbshp = bsh + offset;
	return (0);
}

void
mbus_barrier(void *v, bus_space_handle_t h, bus_size_t o, bus_size_t l, int op)
{
	sync_caches();
}

void *
mbus_vaddr(void *v, bus_space_handle_t h)
{
	return ((void *)h);
}

u_int8_t
mbus_r1(void *v, bus_space_handle_t h, bus_size_t o)
{
	return *((volatile u_int8_t *)(h + o));
}

u_int16_t
mbus_r2(void *v, bus_space_handle_t h, bus_size_t o)
{
	return *((volatile u_int16_t *)(h + o));
}

u_int32_t
mbus_r4(void *v, bus_space_handle_t h, bus_size_t o)
{
	return *((volatile u_int32_t *)(h + o));
}

u_int64_t
mbus_r8(void *v, bus_space_handle_t h, bus_size_t o)
{
	return *((volatile u_int64_t *)(h + o));
}

void
mbus_w1(void *v, bus_space_handle_t h, bus_size_t o, u_int8_t vv)
{
	*((volatile u_int8_t *)(h + o)) = vv;
}

void
mbus_w2(void *v, bus_space_handle_t h, bus_size_t o, u_int16_t vv)
{
	*((volatile u_int16_t *)(h + o)) = vv;
}

void
mbus_w4(void *v, bus_space_handle_t h, bus_size_t o, u_int32_t vv)
{
	*((volatile u_int32_t *)(h + o)) = vv;
}

void
mbus_w8(void *v, bus_space_handle_t h, bus_size_t o, u_int64_t vv)
{
	*((volatile u_int64_t *)(h + o)) = vv;
}


void
mbus_rm_1(void *v, bus_space_handle_t h, bus_size_t o, u_int8_t *a, bus_size_t c)
{
	h += o;
	while (c--)
		*(a++) = *(volatile u_int8_t *)h;
}

void
mbus_rm_2(void *v, bus_space_handle_t h, bus_size_t o, u_int16_t *a, bus_size_t c)
{
	h += o;
	while (c--)
		*(a++) = *(volatile u_int16_t *)h;
}

void
mbus_rm_4(void *v, bus_space_handle_t h, bus_size_t o, u_int32_t *a, bus_size_t c)
{
	h += o;
	while (c--)
		*(a++) = *(volatile u_int32_t *)h;
}

void
mbus_rm_8(void *v, bus_space_handle_t h, bus_size_t o, u_int64_t *a, bus_size_t c)
{
	h += o;
	while (c--)
		*(a++) = *(volatile u_int64_t *)h;
}

void
mbus_wm_1(void *v, bus_space_handle_t h, bus_size_t o, const u_int8_t *a, bus_size_t c)
{
	h += o;
	while (c--)
		*(volatile u_int8_t *)h = *(a++);
}

void
mbus_wm_2(void *v, bus_space_handle_t h, bus_size_t o, const u_int16_t *a, bus_size_t c)
{
	h += o;
	while (c--)
		*(volatile u_int16_t *)h = *(a++);
}

void
mbus_wm_4(void *v, bus_space_handle_t h, bus_size_t o, const u_int32_t *a, bus_size_t c)
{
	h += o;
	while (c--)
		*(volatile u_int32_t *)h = *(a++);
}

void
mbus_wm_8(void *v, bus_space_handle_t h, bus_size_t o, const u_int64_t *a, bus_size_t c)
{
	h += o;
	while (c--)
		*(volatile u_int64_t *)h = *(a++);
}

void
mbus_sm_1(void *v, bus_space_handle_t h, bus_size_t o, u_int8_t vv, bus_size_t c)
{
	h += o;
	while (c--)
		*(volatile u_int8_t *)h = vv;
}

void
mbus_sm_2(void *v, bus_space_handle_t h, bus_size_t o, u_int16_t vv, bus_size_t c)
{
	h += o;
	while (c--)
		*(volatile u_int16_t *)h = vv;
}

void
mbus_sm_4(void *v, bus_space_handle_t h, bus_size_t o, u_int32_t vv, bus_size_t c)
{
	h += o;
	while (c--)
		*(volatile u_int32_t *)h = vv;
}

void
mbus_sm_8(void *v, bus_space_handle_t h, bus_size_t o, u_int64_t vv, bus_size_t c)
{
	h += o;
	while (c--)
		*(volatile u_int64_t *)h = vv;
}

void
mbus_rr_1(void *v, bus_space_handle_t h, bus_size_t o, u_int8_t *a, bus_size_t c)
{
	volatile u_int8_t *p = (u_int8_t *)(h + o);

	while (c--)
		*a++ = *p++;
}

void
mbus_rr_2(void *v, bus_space_handle_t h, bus_size_t o, u_int16_t *a, bus_size_t c)
{
	volatile u_int16_t *p = (u_int16_t *)(h + o);

	while (c--)
		*a++ = *p++;
}

void
mbus_rr_4(void *v, bus_space_handle_t h, bus_size_t o, u_int32_t *a, bus_size_t c)
{
	volatile u_int32_t *p = (u_int32_t *)(h + o);

	while (c--)
		*a++ = *p++;
}

void
mbus_rr_8(void *v, bus_space_handle_t h, bus_size_t o, u_int64_t *a, bus_size_t c)
{
	volatile u_int64_t *p = (u_int64_t *)(h + o);

	while (c--)
		*a++ = *p++;
}

void
mbus_wr_1(void *v, bus_space_handle_t h, bus_size_t o, const u_int8_t *a, bus_size_t c)
{
	volatile u_int8_t *p = (u_int8_t *)(h + o);

	while (c--)
		*p++ = *a++;
}

void
mbus_wr_2(void *v, bus_space_handle_t h, bus_size_t o, const u_int16_t *a, bus_size_t c)
{
	volatile u_int16_t *p = (u_int16_t *)(h + o);

	while (c--)
		*p++ = *a++;
}

void
mbus_wr_4(void *v, bus_space_handle_t h, bus_size_t o, const u_int32_t *a, bus_size_t c)
{
	volatile u_int32_t *p = (u_int32_t *)(h + o);

	while (c--)
		*p++ = *a++;
}

void
mbus_wr_8(void *v, bus_space_handle_t h, bus_size_t o, const u_int64_t *a, bus_size_t c)
{
	volatile u_int64_t *p = (u_int64_t *)(h + o);

	while (c--)
		*p++ = *a++;
}

void
mbus_sr_1(void *v, bus_space_handle_t h, bus_size_t o, u_int8_t vv, bus_size_t c)
{
	volatile u_int8_t *p = (u_int8_t *)(h + o);

	while (c--)
		*p++ = vv;
}

void
mbus_sr_2(void *v, bus_space_handle_t h, bus_size_t o, u_int16_t vv, bus_size_t c)
{
	volatile u_int16_t *p = (u_int16_t *)(h + o);

	while (c--)
		*p++ = vv;
}

void
mbus_sr_4(void *v, bus_space_handle_t h, bus_size_t o, u_int32_t vv, bus_size_t c)
{
	volatile u_int32_t *p = (u_int32_t *)(h + o);

	while (c--)
		*p++ = vv;
}

void
mbus_sr_8(void *v, bus_space_handle_t h, bus_size_t o, u_int64_t vv, bus_size_t c)
{
	volatile u_int64_t *p = (u_int64_t *)(h + o);

	while (c--)
		*p++ = vv;
}

void
mbus_cp_1(void *v, bus_space_handle_t h1, bus_size_t o1,
	  bus_space_handle_t h2, bus_size_t o2, bus_size_t c)
{
	volatile u_int8_t *p1 = (u_int8_t *)(h1 + o1);
	volatile u_int8_t *p2 = (u_int8_t *)(h2 + o2);

	while (c--)
		*p1++ = *p2++;
}

void
mbus_cp_2(void *v, bus_space_handle_t h1, bus_size_t o1,
	  bus_space_handle_t h2, bus_size_t o2, bus_size_t c)
{
	volatile u_int16_t *p1 = (u_int16_t *)(h1 + o1);
	volatile u_int16_t *p2 = (u_int16_t *)(h2 + o2);

	while (c--)
		*p1++ = *p2++;
}

void
mbus_cp_4(void *v, bus_space_handle_t h1, bus_size_t o1,
	  bus_space_handle_t h2, bus_size_t o2, bus_size_t c)
{
	volatile u_int32_t *p1 = (u_int32_t *)(h1 + o1);
	volatile u_int32_t *p2 = (u_int32_t *)(h2 + o2);

	while (c--)
		*p1++ = *p2++;
}

void
mbus_cp_8(void *v, bus_space_handle_t h1, bus_size_t o1,
	  bus_space_handle_t h2, bus_size_t o2, bus_size_t c)
{
	volatile u_int64_t *p1 = (u_int64_t *)(h1 + o1);
	volatile u_int64_t *p2 = (u_int64_t *)(h2 + o2);

	while (c--)
		*p1++ = *p2++;
}


/* ugly typecast macro */
#define	crr(n)	((void (*)(void *, bus_space_handle_t, bus_size_t, u_int8_t *, bus_size_t))(n))
#define	cwr(n)	((void (*)(void *, bus_space_handle_t, bus_size_t, const u_int8_t *, bus_size_t))(n))

const struct hppa_bus_space_tag hppa_bustag = {
	NULL,

	mbus_map, mbus_unmap, mbus_subregion, mbus_alloc, mbus_free,
	mbus_barrier, mbus_vaddr,
	mbus_r1,    mbus_r2,   mbus_r4,   mbus_r8,
	mbus_w1,    mbus_w2,   mbus_w4,   mbus_w8,
	mbus_rm_1,  mbus_rm_2, mbus_rm_4, mbus_rm_8,
	mbus_wm_1,  mbus_wm_2, mbus_wm_4, mbus_wm_8,
	mbus_sm_1,  mbus_sm_2, mbus_sm_4, mbus_sm_8,
	/* *_raw_* are the same as non-raw for native busses */
	            crr(mbus_rm_1), crr(mbus_rm_1), crr(mbus_rm_1),
	            cwr(mbus_wm_1), cwr(mbus_wm_1), cwr(mbus_wm_1),
	mbus_rr_1,  mbus_rr_2, mbus_rr_4, mbus_rr_8,
	mbus_wr_1,  mbus_wr_2, mbus_wr_4, mbus_wr_8,
	/* *_raw_* are the same as non-raw for native busses */
	            crr(mbus_rr_1), crr(mbus_rr_1), crr(mbus_rr_1),
	            cwr(mbus_wr_1), cwr(mbus_wr_1), cwr(mbus_wr_1),
	mbus_sr_1,  mbus_sr_2, mbus_sr_4, mbus_sr_8,
	mbus_cp_1,  mbus_cp_2, mbus_cp_4, mbus_cp_8
};

int		 mbus_dmamap_create(void *v, bus_size_t size, int nsegments,
		   bus_size_t maxsegsz, bus_size_t boundary, int flags,
		   bus_dmamap_t *dmamp);
void		 mbus_dmamap_unload(void *v, bus_dmamap_t map);
void		 mbus_dmamap_destroy(void *v, bus_dmamap_t map);
int		 _bus_dmamap_load_buffer(bus_dma_tag_t t, bus_dmamap_t map,
		    void *buf, bus_size_t buflen, struct proc *p, int flags,
		    paddr_t *lastaddrp, int *segp, int first);
int		 mbus_dmamap_load(void *v, bus_dmamap_t map, void *addr,
		    bus_size_t size, struct proc *p, int flags);
int		 mbus_dmamap_load_mbuf(void *v, bus_dmamap_t map,
		    struct mbuf *m0, int flags);
int		 mbus_dmamap_load_uio(void *v, bus_dmamap_t map,
		    struct uio *uio, int flags);
int		 mbus_dmamap_load_raw(void *v, bus_dmamap_t map,
		    bus_dma_segment_t *segs, int nsegs, bus_size_t size,
		    int flags);
void		 mbus_dmamap_sync(void *v, bus_dmamap_t map, bus_addr_t off,
		    bus_size_t len, int ops);
int		 mbus_dmamem_alloc(void *v, bus_size_t size,
		    bus_size_t alignment, bus_size_t boundary,
		    bus_dma_segment_t *segs, int nsegs, int *rsegs, int flags);
void		 mbus_dmamem_free(void *v, bus_dma_segment_t *segs, int nsegs);
int		 mbus_dmamem_map(void *v, bus_dma_segment_t *segs, int nsegs,
		    size_t size, caddr_t *kvap, int flags);
void		 mbus_dmamem_unmap(void *v, caddr_t kva, size_t size);
paddr_t		 mbus_dmamem_mmap(void *v, bus_dma_segment_t *segs, int nsegs,
		    off_t off, int prot, int flags);

int
mbus_dmamap_create(void *v, bus_size_t size, int nsegments,
		   bus_size_t maxsegsz, bus_size_t boundary, int flags,
		   bus_dmamap_t *dmamp)
{
	struct hppa_bus_dmamap *map;
	size_t mapsize;

	mapsize = sizeof(struct hppa_bus_dmamap) +
	    (sizeof(bus_dma_segment_t) * (nsegments - 1));
	map = malloc(mapsize, M_DEVBUF, (flags & BUS_DMA_NOWAIT) ?
	    (M_NOWAIT | M_ZERO) : (M_WAITOK | M_ZERO));
	if (!map)
		return (ENOMEM);

	map->_dm_size = size;
	map->_dm_segcnt = nsegments;
	map->_dm_maxsegsz = maxsegsz;
	map->_dm_boundary = boundary;
	map->_dm_flags = flags & ~(BUS_DMA_WAITOK|BUS_DMA_NOWAIT);
	map->dm_mapsize = 0;
	map->dm_nsegs = 0;

	*dmamp = map;
	return (0);
}

void
mbus_dmamap_unload(void *v, bus_dmamap_t map)
{
	map->dm_mapsize = 0;
	map->dm_nsegs = 0;
}

void
mbus_dmamap_destroy(void *v, bus_dmamap_t map)
{
	if (map->dm_mapsize != 0)
		mbus_dmamap_unload(v, map);

	free(map, M_DEVBUF, 0);
}

/*
 * Utility function to load a linear buffer.  lastaddrp holds state
 * between invocations (for multiple-buffer loads).  segp contains
 * the starting segment on entrance, and the ending segment on exit.
 * first indicates if this is the first invocation of this function.
 */
int
_bus_dmamap_load_buffer(bus_dma_tag_t t, bus_dmamap_t map, void *buf,
    bus_size_t buflen, struct proc *p, int flags, paddr_t *lastaddrp,
    int *segp, int first)
{
	bus_size_t sgsize;
	bus_addr_t curaddr, lastaddr, baddr, bmask;
	vaddr_t vaddr = (vaddr_t)buf;
	int seg;
	pmap_t pmap;

	pmap = p? p->p_vmspace->vm_map.pmap : pmap_kernel();
	lastaddr = *lastaddrp;
	bmask  = ~(map->_dm_boundary - 1);

	for (seg = *segp; buflen > 0 ; ) {
		/*
		 * Get the physical address for this segment.
		 */
		pmap_extract(pmap, vaddr, (paddr_t *)&curaddr);

		/*
		 * Compute the segment size, and adjust counts.
		 */
		sgsize = PAGE_SIZE - ((u_long)vaddr & PGOFSET);
		if (buflen < sgsize)
			sgsize = buflen;

		/*
		 * Make sure we don't cross any boundaries.
		 */
		if (map->_dm_boundary > 0) {
			baddr = (curaddr + map->_dm_boundary) & bmask;
			if (sgsize > (baddr - curaddr))
				sgsize = (baddr - curaddr);
		}

		/*
		 * Insert chunk into a segment, coalescing with
		 * previous segment if possible.
		 */
		if (first) {
			map->dm_segs[seg].ds_addr = curaddr;
			map->dm_segs[seg].ds_len = sgsize;
			map->dm_segs[seg]._ds_va = vaddr;
			first = 0;
		} else {
			if (curaddr == lastaddr &&
			    (map->dm_segs[seg].ds_len + sgsize) <=
			     map->_dm_maxsegsz &&
			    (map->_dm_boundary == 0 ||
			     (map->dm_segs[seg].ds_addr & bmask) ==
			     (curaddr & bmask)))
				map->dm_segs[seg].ds_len += sgsize;
			else {
				if (++seg >= map->_dm_segcnt)
					break;
				map->dm_segs[seg].ds_addr = curaddr;
				map->dm_segs[seg].ds_len = sgsize;
				map->dm_segs[seg]._ds_va = vaddr;
			}
		}

		lastaddr = curaddr + sgsize;
		vaddr += sgsize;
		buflen -= sgsize;
	}

	*segp = seg;
	*lastaddrp = lastaddr;

	/*
	 * Did we fit?
	 */
	if (buflen != 0)
		return (EFBIG);		/* XXX better return value here? */
	return (0);
}

int
mbus_dmamap_load(void *v, bus_dmamap_t map, void *addr, bus_size_t size,
		 struct proc *p, int flags)
{
	paddr_t lastaddr;
	int seg, error;

	/*
	 * Make sure that on error condition we return "no valid mappings".
	 */
	map->dm_nsegs = 0;
	map->dm_mapsize = 0;

	if (size > map->_dm_size)
		return (EINVAL);

	seg = 0;
	lastaddr = 0;
	error = _bus_dmamap_load_buffer(NULL, map, addr, size, p, flags,
	    &lastaddr, &seg, 1);
	if (error == 0) {
		map->dm_mapsize = size;
		map->dm_nsegs = seg + 1;
	}

	return (0);
}

int
mbus_dmamap_load_mbuf(void *v, bus_dmamap_t map, struct mbuf *m0, int flags)
{
	paddr_t lastaddr;
	int seg, error, first;
	struct mbuf *m;

	map->dm_mapsize = 0;
	map->dm_nsegs = 0;

#ifdef DIAGNOSTIC
	if ((m0->m_flags & M_PKTHDR) == 0)
		panic("_bus_dmamap_load_mbuf: no packet header");
#endif  

	if (m0->m_pkthdr.len > map->_dm_size)
		return (EINVAL);

	first = 1;
	seg = 0;
	error = 0;
	lastaddr = 0;
	for (m = m0; m != NULL && error == 0; m = m->m_next) {
		if (m->m_len == 0)
			continue;
		error = _bus_dmamap_load_buffer(NULL, map, m->m_data, m->m_len,
		    NULL, flags, &lastaddr, &seg, first);
		first = 0;
	}
	if (error == 0) {
		map->dm_mapsize = m0->m_pkthdr.len;
		map->dm_nsegs = seg + 1;
	}

	return (error);
}

int
mbus_dmamap_load_uio(void *v, bus_dmamap_t map, struct uio *uio, int flags)
{
	paddr_t lastaddr;
	int seg, i, error, first;
	bus_size_t minlen, resid;
	struct proc *p = NULL;
	struct iovec *iov;
	caddr_t addr;

	/*
	 * Make sure that on error condition we return "no valid mappings".
	 */
	map->dm_mapsize = 0;
	map->dm_nsegs = 0;

	resid = uio->uio_resid;
	iov = uio->uio_iov;

	if (resid > map->_dm_size)
		return (EINVAL);

	if (uio->uio_segflg == UIO_USERSPACE) {
		p = uio->uio_procp;
#ifdef DIAGNOSTIC
		if (p == NULL)
			panic("_bus_dmamap_load_uio: USERSPACE but no proc");
#endif
	}

	first = 1;
	seg = 0;
	error = 0;
	lastaddr = 0;
	for (i = 0; i < uio->uio_iovcnt && resid != 0 && error == 0; i++) {
		/*
		 * Now at the first iovec to load.  Load each iovec
		 * until we have exhausted the residual count.
		 */
		minlen = resid < iov[i].iov_len ? resid : iov[i].iov_len;
		addr = (caddr_t)iov[i].iov_base;

		error = _bus_dmamap_load_buffer(NULL, map, addr, minlen,
		    p, flags, &lastaddr, &seg, first);
		first = 0;

		resid -= minlen;
	}
	if (error == 0) {
		map->dm_mapsize = uio->uio_resid;
		map->dm_nsegs = seg + 1;
	}
	return (error);
}

int
mbus_dmamap_load_raw(void *v, bus_dmamap_t map, bus_dma_segment_t *segs,
    int nsegs, bus_size_t size, int flags)
{
	if (nsegs > map->_dm_segcnt || size > map->_dm_size)
		return (EINVAL);

	/*
	 * Make sure we don't cross any boundaries.
	 */
	if (map->_dm_boundary) {
		bus_addr_t bmask = ~(map->_dm_boundary - 1);
		int i;

		for (i = 0; i < nsegs; i++) {
			if (segs[i].ds_len > map->_dm_maxsegsz)
				return (EINVAL);
			if ((segs[i].ds_addr & bmask) !=
			    ((segs[i].ds_addr + segs[i].ds_len - 1) & bmask))
				return (EINVAL);
		}
	}

	bcopy(segs, map->dm_segs, nsegs * sizeof(*segs));
	map->dm_nsegs = nsegs;
	map->dm_mapsize = size;
	return (0);
}

void
mbus_dmamap_sync(void *v, bus_dmamap_t map, bus_addr_t off, bus_size_t len,
    int ops)
{
	bus_dma_segment_t *ps = map->dm_segs,
	    *es = &map->dm_segs[map->dm_nsegs];

	if (off >= map->_dm_size)
		return;

	if ((off + len) > map->_dm_size)
		len = map->_dm_size - off;

	for (; len && ps < es; ps++)
		if (off > ps->ds_len)
			off -= ps->ds_len;
		else {
			bus_size_t l = ps->ds_len - off;
			if (l > len)
				l = len;
			fdcache(HPPA_SID_KERNEL, ps->_ds_va + off, l);
			len -= l;
			off = 0;
		}

	/* for either operation sync the shit away */
	__asm volatile ("sync\n\tsyncdma\n\tsync\n\t"
	    "nop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop");
}

int
mbus_dmamem_alloc(void *v, bus_size_t size, bus_size_t alignment,
		  bus_size_t boundary, bus_dma_segment_t *segs, int nsegs,
		  int *rsegs, int flags)
{
	struct pglist pglist;
	struct vm_page *pg;
	int plaflag;

	size = round_page(size);

	plaflag = flags & BUS_DMA_NOWAIT ? UVM_PLA_NOWAIT : UVM_PLA_WAITOK;
	if (flags & BUS_DMA_ZERO)
		plaflag |= UVM_PLA_ZERO;

	TAILQ_INIT(&pglist);
	if (uvm_pglistalloc(size, 0, -1, alignment, boundary,
	    &pglist, 1, plaflag))
		return (ENOMEM);

	pg = TAILQ_FIRST(&pglist);
	segs[0]._ds_va = segs[0].ds_addr = VM_PAGE_TO_PHYS(pg);
	segs[0].ds_len = size;
	*rsegs = 1;

	for(; pg; pg = TAILQ_NEXT(pg, pageq))
		/* XXX for now */
		pmap_changebit(pg, PTE_PROT(TLB_UNCACHABLE), 0);
	pmap_update(pmap_kernel());

	return (0);
}

void
mbus_dmamem_free(void *v, bus_dma_segment_t *segs, int nsegs)
{
	struct pglist pglist;
	paddr_t pa, epa;

	TAILQ_INIT(&pglist);
	for(; nsegs--; segs++)
		for (pa = segs->ds_addr, epa = pa + segs->ds_len;
		     pa < epa; pa += PAGE_SIZE) {
			struct vm_page *pg = PHYS_TO_VM_PAGE(pa);
			if (!pg)
				panic("mbus_dmamem_free: no page for pa");
			TAILQ_INSERT_TAIL(&pglist, pg, pageq);
			pdcache(HPPA_SID_KERNEL, pa, PAGE_SIZE);
			pdtlb(HPPA_SID_KERNEL, pa);
			pitlb(HPPA_SID_KERNEL, pa);
		}
	uvm_pglistfree(&pglist);
}

int
mbus_dmamem_map(void *v, bus_dma_segment_t *segs, int nsegs, size_t size,
		caddr_t *kvap, int flags)
{
	*kvap = (caddr_t)segs[0].ds_addr;
	return 0;
}

void
mbus_dmamem_unmap(void *v, caddr_t kva, size_t size)
{
}

paddr_t
mbus_dmamem_mmap(void *v, bus_dma_segment_t *segs, int nsegs, off_t off,
		 int prot, int flags)
{
	panic("_dmamem_mmap: not implemented");
}

const struct hppa_bus_dma_tag hppa_dmatag = {
	NULL,
	mbus_dmamap_create, mbus_dmamap_destroy,
	mbus_dmamap_load, mbus_dmamap_load_mbuf,
	mbus_dmamap_load_uio, mbus_dmamap_load_raw,
	mbus_dmamap_unload, mbus_dmamap_sync,

	mbus_dmamem_alloc, mbus_dmamem_free, mbus_dmamem_map,
	mbus_dmamem_unmap, mbus_dmamem_mmap
};

int
mbmatch(parent, cfdata, aux)
	struct device *parent;
	void *cfdata;
	void *aux;
{
	struct cfdata *cf = cfdata;

	/* there will be only one */
	if (cf->cf_unit)
		return 0;

	return 1;
}

void
mbattach(parent, self, aux)
	struct device *parent;
	struct device *self;
	void *aux;
{
	struct mainbus_softc *sc = (struct mainbus_softc *)self;
	struct confargs nca;
	bus_space_handle_t ioh;

	/* fetch the "default" cpu hpa */
	if (pdc_call((iodcio_t)pdc, 0, PDC_HPA, PDC_HPA_DFLT, &pdc_hpa) < 0)
		panic("mbattach: PDC_HPA failed");

	printf(" [flex %x]\n", pdc_hpa.hpa & HPPA_FLEX_MASK);

	/* map all the way till the end of the memory */
	if (bus_space_map(&hppa_bustag, pdc_hpa.hpa,
	    (~0LU - pdc_hpa.hpa + 1), 0, &ioh))
		panic("mbattach: cannot map mainbus IO space");

	/*
	 * Local-Broadcast the HPA to all modules on this bus
	 */
	((struct iomod *)HPPA_LBCAST)->io_flex =
	    (pdc_hpa.hpa & HPPA_FLEX_MASK) | DMA_ENABLE;

	sc->sc_hpa = pdc_hpa.hpa;

	/* PDC first */
	bzero(&nca, sizeof(nca));
	nca.ca_name = "pdc";
	nca.ca_iot = &hppa_bustag;
	nca.ca_dmatag = &hppa_dmatag;
	config_found(self, &nca, mbprint);

#if NPOWER > 0
	/* get some power */
	bzero(&nca, sizeof(nca));
	nca.ca_name = "power";
	nca.ca_irq = -1;
	if (!pdc_call((iodcio_t)pdc, 0, PDC_SOFT_POWER,
	    PDC_SOFT_POWER_INFO, &pdc_power_info, 0)) {
		nca.ca_iot = &hppa_bustag;
		nca.ca_hpa = pdc_power_info.addr;
		nca.ca_hpamask = HPPA_IOBEGIN;
	}
	config_found(self, &nca, mbprint);
#endif

#if NLCD > 0
	if (!pdc_call((iodcio_t)pdc, 0, PDC_CHASSIS, PDC_CHASSIS_INFO,
	    &pdc_chassis_info, &pdc_chassis_lcd, sizeof(pdc_chassis_lcd)) &&
	    pdc_chassis_lcd.enabled) {
		bzero(&nca, sizeof(nca));
		nca.ca_name = "lcd";
		nca.ca_irq = -1;
		nca.ca_iot = &hppa_bustag;
		nca.ca_hpa = pdc_chassis_lcd.cmd_addr;
		nca.ca_hpamask = HPPA_IOBEGIN;
		nca.ca_pdc_iodc_read = (void *)&pdc_chassis_lcd;

		config_found(self, &nca, mbprint);
	}
#endif

	bzero(&nca, sizeof(nca));
	nca.ca_hpa = 0;
	nca.ca_irq = -1;
	nca.ca_hpamask = HPPA_IOBEGIN;
	nca.ca_iot = &hppa_bustag;
	nca.ca_dmatag = &hppa_dmatag;
	nca.ca_dp.dp_bc[0] = nca.ca_dp.dp_bc[1] = nca.ca_dp.dp_bc[2] =
	nca.ca_dp.dp_bc[3] = nca.ca_dp.dp_bc[4] = nca.ca_dp.dp_bc[5] = -1;
	nca.ca_dp.dp_mod = -1;
	switch (cpu_hvers) {
	case HPPA_BOARD_HP809:
	case HPPA_BOARD_HP819:
	case HPPA_BOARD_HP829:
	case HPPA_BOARD_HP839:
	case HPPA_BOARD_HP849:
	case HPPA_BOARD_HP859:
	case HPPA_BOARD_HP869:
#if 0
	case HPPA_BOARD_HP770_J200:
	case HPPA_BOARD_HP770_J210:
	case HPPA_BOARD_HP770_J210XC:
	case HPPA_BOARD_HP780_J282:
	case HPPA_BOARD_HP782_J2240:
#endif
	case HPPA_BOARD_HP780_C160:
	case HPPA_BOARD_HP780_C180P:
	case HPPA_BOARD_HP780_C180XP:
	case HPPA_BOARD_HP780_C200:
	case HPPA_BOARD_HP780_C230:
	case HPPA_BOARD_HP780_C240:
	case HPPA_BOARD_HP785_C360:
		/* Attach CPUs first, then everything else... */
		ncpusfound = 0;
		pdc_scanbus(self, &nca, MAXMODBUS, HPPA_FPA, 1);
		pdc_scanbus(self, &nca, MAXMODBUS, HPPA_FPA, 0);
	break;
	default:
		/* Attach CPUs first, then everything else... */
		ncpusfound = 0;
		pdc_scanbus(self, &nca, MAXMODBUS, 0, 1);
		pdc_scanbus(self, &nca, MAXMODBUS, 0, 0);
	}
}

/*
 * retrive CPU #N HPA value
 */
hppa_hpa_t
cpu_gethpa(n)
	int n;
{
	struct mainbus_softc *sc;

	sc = mainbus_cd.cd_devs[0];

	return sc->sc_hpa;
}

int
mbprint(aux, pnp)
	void *aux;
	const char *pnp;
{
	struct confargs *ca = aux;

	if (pnp)
		printf("\"%s\" at %s (type %x sv %x mod %x hv %x)",
		    ca->ca_name, pnp,
		    ca->ca_type.iodc_type, ca->ca_type.iodc_sv_model,
		    ca->ca_type.iodc_model, ca->ca_type.iodc_revision);
	if (ca->ca_hpa) {
		if (~ca->ca_hpamask)
			printf(" offset %lx", ca->ca_hpa & ~ca->ca_hpamask);
		if (!pnp && ca->ca_irq >= 0)
			printf(" irq %d", ca->ca_irq);
	}

	return (UNCONF);
}

int
mbsubmatch(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	struct cfdata *cf = match;
	struct confargs *ca = aux;
	int ret;

	if (autoconf_verbose)
		printf(">> hpa %lx off %lx cf_off %lx\n",
		    ca->ca_hpa, ca->ca_hpa & ~ca->ca_hpamask, cf->hppacf_off);

	if (ca->ca_hpa && ~ca->ca_hpamask && cf->hppacf_off != -1 &&
	    ((ca->ca_hpa & ~ca->ca_hpamask) != cf->hppacf_off))
		return (0);

	if ((ret = (*cf->cf_attach->ca_match)(parent, match, aux)))
		ca->ca_irq = cf->hppacf_irq;

	return ret;
}

@


1.86
log
@Replace a plethora of historical protection options with just
PROT_NONE, PROT_READ, PROT_WRITE, and PROT_EXEC from mman.h.
PROT_MASK is introduced as the one true way of extracting those bits.
Remove UVM_ADV_* wrapper, using the standard names.
ok doug guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.85 2014/07/12 18:44:41 tedu Exp $	*/
d1286 1
a1286 1
		printf(">> hpa %lx off %lx cf_off %x\n",
@


1.85
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.84 2014/05/08 21:32:45 miod Exp $	*/
d223 1
a223 1
				    pmap_prot(pmap_kernel(), UVM_PROT_RW))
d250 1
a250 1
						    UVM_PROT_RW);
@


1.84
log
@Format string fixes and removal of -Wno-format for hppa kernels.
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.83 2014/04/08 09:34:23 mpi Exp $	*/
d763 1
a763 1
	free(map, M_DEVBUF);
@


1.83
log
@Less <uvm/uvm.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.82 2014/03/29 18:09:29 guenther Exp $	*/
d1144 1
a1144 1
	printf(" [flex %lx]\n", pdc_hpa.hpa & HPPA_FLEX_MASK);
@


1.82
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.81 2010/06/19 14:06:54 miod Exp $	*/
d42 1
a42 2
#include <uvm/uvm.h>
#include <uvm/uvm_page.h>
@


1.81
log
@Remove unused md BUS_SPACE_MAP_NOEXTENT flag; ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.80 2010/05/24 15:04:55 deraadt Exp $	*/
d1027 1
a1027 1
	__asm __volatile ("sync\n\tsyncdma\n\tsync\n\t"
@


1.80
log
@Add missing prototypes
ok jsing kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.79 2010/05/06 14:39:52 jsing Exp $	*/
d278 1
a278 2
	if (!(flags & BUS_SPACE_MAP_NOEXTENT) &&
	    (error = extent_alloc_region(hppa_ex, bpa, size, EX_NOWAIT)))
@


1.79
log
@Count the number of CPUs in the system.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.76 2010/04/20 23:27:00 deraadt Exp $	*/
d78 85
d320 2
a321 2
	 bus_size_t align, bus_size_t boundary, int flags,
	 bus_addr_t *addrp, bus_space_handle_t *bshp)
a516 14
void mbus_rrm_2(void *v, bus_space_handle_t h,
	    bus_size_t o, u_int16_t*a, bus_size_t c);
void mbus_rrm_4(void *v, bus_space_handle_t h,
	    bus_size_t o, u_int32_t*a, bus_size_t c);
void mbus_rrm_8(void *v, bus_space_handle_t h,
	    bus_size_t o, u_int64_t*a, bus_size_t c);

void mbus_wrm_2(void *v, bus_space_handle_t h,
	    bus_size_t o, const u_int16_t *a, bus_size_t c);
void mbus_wrm_4(void *v, bus_space_handle_t h,
	    bus_size_t o, const u_int32_t *a, bus_size_t c);
void mbus_wrm_8(void *v, bus_space_handle_t h,
	    bus_size_t o, const u_int64_t *a, bus_size_t c);

a588 14
void mbus_rrr_2(void *v, bus_space_handle_t h,
		   bus_size_t o, u_int16_t *a, bus_size_t c);
void mbus_rrr_4(void *v, bus_space_handle_t h,
		   bus_size_t o, u_int32_t *a, bus_size_t c);
void mbus_rrr_8(void *v, bus_space_handle_t h,
		   bus_size_t o, u_int64_t *a, bus_size_t c);

void mbus_wrr_2(void *v, bus_space_handle_t h,
		   bus_size_t o, const u_int16_t *a, bus_size_t c);
void mbus_wrr_4(void *v, bus_space_handle_t h,
		   bus_size_t o, const u_int32_t *a, bus_size_t c);
void mbus_wrr_8(void *v, bus_space_handle_t h,
		   bus_size_t o, const u_int64_t *a, bus_size_t c);

d695 29
@


1.78
log
@Currently pdc_scanbus() scans in reverse, which results in physical CPU0
attaching as cpu1 and physical CPU1 attaching as cpu0. Split the device
scan into two parts - the first pass scans forward and attaches memory
and CPUs, whilst the second pass scans in reverse attaching the
remaining devices, thus preserving current semantics.

Found the hard way whilst trying to spin up the secondary CPU on my j6750.

ok miod@@ kettenis@@
@
text
@d1144 1
d1150 1
@


1.77
log
@Don't use cast expressions as lvalues; gcc4 complains about them.  And gcc3
generates smaller code without them.

ok miod@@
@
text
@d1143 3
a1145 1
		pdc_scanbus(self, &nca, MAXMODBUS, HPPA_FPA);
d1148 3
a1150 2
		pdc_scanbus(self, &nca, MAXMODBUS, 0);
	break;
@


1.76
log
@cleanup more confusion regarding user.h before proc.h, or missing proc.h
ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.75 2009/06/11 20:10:51 kettenis Exp $	*/
d449 2
a450 1
	h += o;
d452 1
a452 1
		*(a++) = *((volatile u_int8_t *)h)++;
d458 2
a459 1
	h += o;
d461 1
a461 1
		*(a++) = *((volatile u_int16_t *)h)++;
d467 2
a468 1
	h += o;
d470 1
a470 1
		*(a++) = *((volatile u_int32_t *)h)++;
d476 2
a477 1
	h += o;
d479 1
a479 1
		*(a++) = *((volatile u_int64_t *)h)++;
d485 2
a486 1
	h += o;
d488 1
a488 1
		*((volatile u_int8_t *)h)++ = *(a++);
d494 2
a495 1
	h += o;
d497 1
a497 1
		*((volatile u_int16_t *)h)++ = *(a++);
d503 2
a504 1
	h += o;
d506 1
a506 1
		*((volatile u_int32_t *)h)++ = *(a++);
d512 2
a513 1
	h += o;
d515 1
a515 1
		*((volatile u_int64_t *)h)++ = *(a++);
d535 2
a536 1
	h += o;
d538 1
a538 1
		*((volatile u_int8_t *)h)++ = vv;
d544 2
a545 1
	h += o;
d547 1
a547 1
		*((volatile u_int16_t *)h)++ = vv;
d553 2
a554 1
	h += o;
d556 1
a556 1
		*((volatile u_int32_t *)h)++ = vv;
d562 2
a563 1
	h += o;
d565 1
a565 1
		*((volatile u_int64_t *)h)++ = vv;
d572 3
a574 2
	h1 += o1;
	h2 += o2;
d576 1
a576 2
		*((volatile u_int8_t *)h1)++ =
			*((volatile u_int8_t *)h2)++;
d583 3
a585 2
	h1 += o1;
	h2 += o2;
d587 1
a587 2
		*((volatile u_int16_t *)h1)++ =
			*((volatile u_int16_t *)h2)++;
d594 3
a596 2
	h1 += o1;
	h2 += o2;
d598 1
a598 2
		*((volatile u_int32_t *)h1)++ =
			*((volatile u_int32_t *)h2)++;
d605 3
a607 2
	h1 += o1;
	h2 += o2;
d609 1
a609 2
		*((volatile u_int64_t *)h1)++ =
			*((volatile u_int64_t *)h2)++;
@


1.75
log
@Correctly flush direct mappings (cache/tlb).  Uncovered by ariane's new
allocator.
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.74 2009/04/20 00:42:06 oga Exp $	*/
d36 1
@


1.74
log
@Add a BUS_DMA_ZERO flag for bus_dmamem_alloc() to return zeroed memory.

Saves every damned driver calling bzero(), and continues the M_ZERO,
PR_ZERO symmetry.
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.73 2009/04/14 16:01:04 oga Exp $	*/
d980 3
@


1.73
log
@Convert the waitok field of uvm_pglistalloc to "flags", more will be added soon.

For the possibility of sleeping, the first two flags are UVM_PLA_WAITOK
and UVM_PLA_NOWAIT. It is an error not to show intention, so assert that
one of the two is provided. Switch over every caller in the tree to
using the appropriate flag.

ok art@@, ariane@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.72 2009/03/08 19:26:39 martin Exp $	*/
d945 2
@


1.72
log
@g/c now unused extern declaration for avail_end

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.71 2009/03/07 15:34:34 miod Exp $	*/
d940 1
d944 2
d948 1
a948 1
	    &pglist, 1, flags & BUS_DMA_NOWAIT))
@


1.71
log
@When allocating memory in bus_dmamem_alloc() with uvm_pglistalloc(), do not
try to be smart for the address range, uvm_pglistalloc() is smart enough
nowadays.
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.70 2009/02/01 14:53:02 miod Exp $	*/
a937 1
	extern paddr_t avail_end;
@


1.70
log
@Fix the logic in mbus_add_mapping() to correctly handle requests spanning
more than one flex ``tile'', when the first one is already mapped.
Some sti(4) devices have such requests.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.69 2007/12/28 19:48:50 kettenis Exp $	*/
d945 1
a945 1
	if (uvm_pglistalloc(size, 0, avail_end, alignment, boundary,
@


1.69
log
@Add a few more K-class models to the list of machines that have more devices
than PDC tells us about.
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.68 2007/12/19 19:10:54 kettenis Exp $	*/
d82 3
a84 2
	int bank, off, flex = HPPA_FLEX(bpa);
	u_int64_t spa, epa;
a93 8
	/*
	 * determine if we are mapping IO space, or beyond the physmem
	 * region. use block mapping then
	 *
	 * we map the whole bus module (there are 1024 of those max)
	 * so, check here if it's mapped already, map if needed.
	 * all mappings are equal mappings.
	 */
d101 65
a165 28
	/* need a new mapping */
	if (!(bmm[flex / 32] & (1 << (flex % 32)))) {
		spa = bpa & HPPA_FLEX_MASK;
		epa = ((u_long)((u_int64_t)bpa + size +
			~HPPA_FLEX_MASK - 1) & HPPA_FLEX_MASK) - 1;
#ifdef BTLBDEBUG
		printf("bus_mem_add_mapping: adding flex=%x "
			"%qx-%qx, ", flex, spa, epa);
#endif
		while (spa < epa) {
			vsize_t len = epa - spa;
			u_int64_t pa;
			if (len > pdc_btlb.max_size << PGSHIFT)
				len = pdc_btlb.max_size << PGSHIFT;
			if (btlb_insert(HPPA_SID_KERNEL, spa, spa, &len,
			    pmap_sid2pid(HPPA_SID_KERNEL) |
			    pmap_prot(pmap_kernel(), UVM_PROT_RW)) >= 0) {
				pa = spa + len - 1;
#ifdef BTLBDEBUG
				printf("--- %x/%x, %qx, %qx-%qx",
				    flex, HPPA_FLEX(pa), pa, spa, epa);
#endif
				/* do the mask */
				for (; flex <= HPPA_FLEX(pa); flex++) {
#ifdef BTLBDEBUG
					printf("mask %x ", flex);
#endif
					bmm[flex / 32] |= (1 << (flex % 32));
a166 8
				spa = pa;
			} else {
				spa = trunc_page(bpa);
				epa = round_page(bpa + size);

				if (epa - 1 > ~0U)
					epa = (u_int64_t)~0U + 1;

d168 1
a168 1
				printf("kenter 0x%qx-0x%qx", spa, epa);
a169 2
				for (; spa < epa; spa += PAGE_SIZE)
					pmap_kenter_pa(spa, spa, UVM_PROT_RW);
d171 1
d173 4
a176 1
			printf("\n");
d178 2
a179 6
		}
	}
#ifdef BTLBDEBUG
	else {
		printf("+++ already b-mapped flex=%x, mask=%x",
		    flex, bmm[flex / 8]);
a180 1
#endif
@


1.68
log
@Looks like K-class needs the same hack as C-class.  Gives us some, but not all
devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.67 2007/10/02 00:59:12 krw Exp $	*/
d1085 1
d1087 1
d1089 1
@


1.67
log
@Apply (with slight variants) this elimination of bzero() with M_ZERO:

-	if ((mapstore = malloc(mapsize, M_DEVBUF,
-	    (flags & BUS_DMA_NOWAIT) ? M_NOWAIT : M_WAITOK)) == NULL)
+	if ((mapstore = malloc(mapsize, M_DEVBUF, (flags & BUS_DMA_NOWAIT) ?
+	    (M_NOWAIT | M_ZERO) : (M_WAITOK | M_ZERO))) == NULL)
 		return (ENOMEM);

-	bzero(mapstore, mapsize);
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.66 2007/07/15 20:11:12 kettenis Exp $	*/
a1082 1
#if 0
d1087 1
@


1.66
log
@lcd(4); a driver for the front panel LCD display found on the four-digit
B/C/J-class workstations, and many server systems.

This is still work in progress; for now it only displays that the machine
is running OpenBSD.  Not enabled yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.65 2007/05/29 21:00:50 jason Exp $	*/
d617 2
a618 2
	map = malloc(mapsize, M_DEVBUF,
		(flags & BUS_DMA_NOWAIT) ? M_NOWAIT : M_WAITOK);
a621 1
	bzero(map, mapsize);
@


1.65
log
@s/entrace/entrance (not obvious that the code was cut/paste =)
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.64 2007/05/23 18:07:19 kettenis Exp $	*/
d29 1
d44 1
d70 2
d1038 1
a1038 1
	bzero (&nca, sizeof(nca));
d1046 1
a1046 1
	bzero (&nca, sizeof(nca));
d1058 17
a1074 1
	bzero (&nca, sizeof(nca));
@


1.64
log
@Add proper bus_space_vaddr() implementation.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.63 2005/10/26 18:35:44 martin Exp $	*/
d650 1
a650 1
 * the starting segment on entrace, and the ending segment on exit.
@


1.63
log
@no more hppa_round_page() and hppa_trunc_page() macros

ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.62 2005/04/07 00:21:51 mickey Exp $	*/
d257 6
d585 1
a585 1
	mbus_barrier,
@


1.62
log
@64bit-friendly pdc.h and iomod.h and correspondent changes elsewhere
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.61 2004/11/09 19:17:01 claudio Exp $	*/
d135 2
a136 2
				spa = hppa_trunc_page(bpa);
				epa = hppa_round_page(bpa + size);
d189 2
a190 2
	sva = hppa_trunc_page(bsh);
	eva = hppa_round_page(bsh + size);
@


1.61
log
@Do not map empty mbufs (m_len == 0) in bus_dmamap_load_mbuf() as these mappings
may disturb the dma as seen in ipw(4). Emtpy mbufs are at the beginning of the
mbuf chain and are as example a "side-effect" of a previous m_adj() call.
OK miod@@ mickey@@ jason@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.60 2004/09/18 21:40:20 mickey Exp $	*/
d1022 2
a1023 2
	((struct iomod *)LBCAST_ADDR)->io_flex =
	    (void *)((pdc_hpa.hpa & HPPA_FLEX_MASK) | DMA_ENABLE);
d1043 1
a1043 1
		nca.ca_hpamask = HPPA_IOSPACE;
d1051 1
a1051 1
	nca.ca_hpamask = HPPA_IOSPACE;
d1076 1
a1076 1
		pdc_scanbus(self, &nca, MAXMODBUS, FP_ADDR);
@


1.60
log
@for unconfigured devices also print model number
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.59 2004/09/16 00:05:03 mickey Exp $	*/
d777 2
@


1.59
log
@stupid propagated typo
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.58 2004/09/15 21:32:43 mickey Exp $	*/
d1104 2
a1105 1
		printf("\"%s\" at %s (type %x, sv %x, hv %x)", ca->ca_name, pnp,
d1107 1
a1107 1
		    ca->ca_type.iodc_revision);
@


1.58
log
@add pcxu tlb handlers and cpu probing
add u2/uturn ioa driver in dumb mode now
enable pcxu/pcxw support
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.57 2004/09/15 20:11:29 mickey Exp $	*/
d1067 6
a1072 6
	case HPPA_BOARD_HP785_C160:
	case HPPA_BOARD_HP785_C180P:
	case HPPA_BOARD_HP785_C180XP:
	case HPPA_BOARD_HP785_C200:
	case HPPA_BOARD_HP785_C230:
	case HPPA_BOARD_HP785_C240:
@


1.57
log
@scan cpu bus manually for some machines do not support that in prom
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.56 2004/04/07 18:24:19 mickey Exp $	*/
d1018 1
a1018 1
	 * Local-Broadcast the HPA to all modules on the bus
d1020 2
a1021 2
	((struct iomod *)(pdc_hpa.hpa & HPPA_FLEX_MASK))[FPA_IOMOD].io_flex =
		(void *)((pdc_hpa.hpa & HPPA_FLEX_MASK) | DMA_ENABLE);
@


1.56
log
@update copyright; miod@@ is fine w/ files where he holds it too
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.55 2004/03/02 21:06:15 mickey Exp $	*/
d47 2
a1046 1
	nca.ca_name = "mainbus";
d1055 25
a1079 1
	pdc_scanbus(self, &nca, MAXMODBUS);
@


1.55
log
@track va for each segment and not for the whole map.
simplifies the cache syncing a lot.
testing by miod@@ and mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.54 2003/12/20 21:49:06 miod Exp $	*/
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Michael Shalayeff.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.54
log
@Pass -Wformat, fix a few uninitialized variables as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.53 2003/09/29 19:23:02 mickey Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998-2003 Michael Shalayeff
d694 1
a694 1
			map->_dm_va = vaddr;
d709 1
a779 2
		/* XXX as we later can only flush by pa -- flush now */
		fdcache(HPPA_SID_KERNEL, (vaddr_t)m->m_data, m->m_len);
a786 1
		map->_dm_va = 0;	/* means sync by pa */
a872 1
	map->_dm_va = segs->ds_addr;
d880 6
d889 11
a899 23
	if (map->_dm_va) {
		/*
		 * cannot use purge since the data for dma is not
		 * guarantied to be aligned in any way
		 */
		fdcache(HPPA_SID_KERNEL, map->_dm_va + off, len);
	} else {
		/* this is an mbuf chain thus flush by segs */
		bus_dma_segment_t *ps = map->dm_segs,
		    *es = &map->dm_segs[map->dm_nsegs];

		for (; len && ps < es; ps++)
			if (off > ps->ds_len)
				off -= ps->ds_len;
			else {
				bus_size_t l = ps->ds_len - off;
				if (l > len)
					l = len;
				fdcache(HPPA_SID_KERNEL, ps->ds_addr + off, l);
				len -= l;
				off = 0;
			}
	}
d923 1
a923 1
	segs[0].ds_addr = VM_PAGE_TO_PHYS(pg);
@


1.53
log
@dino/cujo pci bridge
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.52 2003/09/26 00:10:40 mickey Exp $	*/
d90 1
a90 1
		panic("mbus_add_mapping: mapping real memory @@0x%x", bpa);
d1022 1
a1022 1
	printf(" [flex %x]\n", pdc_hpa.hpa & HPPA_FLEX_MASK);
d1098 1
a1098 1
			printf(" offset %x", ca->ca_hpa & ~ca->ca_hpamask);
d1116 1
a1116 1
		printf(">> hpa %x off %x cf_off %x\n",
@


1.52
log
@dmamap_syncing the loaded mbufs is whacky trip per physaddrs
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.51 2003/08/20 23:33:36 mickey Exp $	*/
d77 1
a77 1
mbus_add_mapping(bus_addr_t bpa, bus_size_t size, int cachable,
d86 1
a86 1
	    bpa, size, cachable? "" : "non", bshp);
d101 1
a101 1
	if (cachable) {
d103 1
a103 1
		cachable = 0;
d168 1
a168 1
    int cachable, bus_space_handle_t *bshp)
d172 2
a173 1
	if ((error = extent_alloc_region(hppa_ex, bpa, size, EX_NOWAIT)))
d176 1
a176 1
	if ((error = mbus_add_mapping(bpa, size, cachable, bshp))) {
d214 1
a214 1
	 bus_size_t align, bus_size_t boundary, int cachable,
d227 1
a227 1
	if ((error = mbus_add_mapping(bpa, size, cachable, bshp))) {
d745 1
d777 1
d827 1
@


1.51
log
@devise the power reg address as hpa for the power device and thus avoid manual offset printing. add some code for interrupt-driven power-fail
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.50 2003/08/20 21:44:03 mickey Exp $	*/
d776 2
d785 1
d876 1
a876 1
mbus_dmamap_sync(void *v, bus_dmamap_t map, bus_addr_t offset, bus_size_t len,
d879 26
a904 5
	/*
	 * cannot use purge since the data for dma is not
	 * guarantied to be aligned in any way
	 */
	fdcache(HPPA_SID_KERNEL, map->_dm_va + offset, len);
@


1.50
log
@allow powerless kernels
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.49 2003/08/20 20:53:31 mickey Exp $	*/
d69 3
a986 1
	struct pdc_hpa pdc_hpa PDC_ALIGNMENT;
d1018 1
d1020 7
@


1.49
log
@handle power button (on 712 for now)
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.48 2003/08/20 20:28:40 mickey Exp $	*/
d34 1
d1014 1
d1018 1
@


1.48
log
@print hv for unconfigured devices as well
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.47 2003/07/29 20:49:29 mickey Exp $	*/
a1008 2
	nca.ca_hpa = 0;
	nca.ca_hpamask = 0;
d1011 4
@


1.47
log
@load_raw did not set all the needed fields in the dmamap.
make sure to allocate dmamem in one segment.
do not allocate extra va for dmamem allocated -- just reuse
the already there equ mapping of pa and thus implement
the dmamem_free as a pglist free.
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.46 2003/07/15 17:04:33 mickey Exp $	*/
d1050 3
a1052 2
		printf("\"%s\" at %s (type %x, sv %x)", ca->ca_name, pnp,
		    ca->ca_type.iodc_type, ca->ca_type.iodc_sv_model);
@


1.46
log
@more dmamap_load_* functions stolen from other places and de-register
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.45 2003/06/12 17:50:27 mickey Exp $	*/
d727 1
a727 1
	bus_addr_t lastaddr;
d863 2
a890 1
	vaddr_t va;
d896 1
a896 1
	    &pglist, nsegs, flags & BUS_DMA_NOWAIT))
d899 2
a900 8
	if (uvm_map(kernel_map, &va, size, NULL, UVM_UNKNOWN_OFFSET, 0,
	    UVM_MAPFLAG(UVM_PROT_RW, UVM_PROT_RW, UVM_INH_NONE,
	    UVM_ADV_RANDOM, 0))) {
		uvm_pglistfree(&pglist);
		return (ENOMEM);
	}

	segs[0].ds_addr = va;
d904 1
a904 3
	TAILQ_FOREACH(pg, &pglist, pageq) {

		pmap_kenter_pa(va, VM_PAGE_TO_PHYS(pg), UVM_PROT_RW);
a906 2
		va += PAGE_SIZE;
	}
d915 13
a927 1
	uvm_km_free(kernel_map, segs[0].ds_addr, segs[0].ds_len);
@


1.45
log
@cannot ever use purge() since dmaed memory is not necessarily aligned always
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.44 2003/04/07 17:01:08 mickey Exp $	*/
d166 1
a166 1
	register int error;
d639 84
d727 2
a728 4
	paddr_t pa, pa_next;
	bus_size_t mapsize;
	bus_size_t off, pagesz;
	int seg;
a734 1
	map->_dm_va = (vaddr_t)addr;
d736 9
a744 23
	/* Load the memory. */
	pa_next = 0;
	seg = -1;
	mapsize = size;
	off = (bus_size_t)addr & PAGE_MASK;
	addr = (void *) ((caddr_t)addr - off);
	for(; size > 0; ) {

		pmap_extract(pmap_kernel(), (vaddr_t)addr, &pa);
		if (pa != pa_next) {
			if (++seg >= map->_dm_segcnt)
				panic("mbus_dmamap_load: nsegs botch");
			map->dm_segs[seg].ds_addr = pa + off;
			map->dm_segs[seg].ds_len = 0;
		}
		pa_next = pa + PAGE_SIZE;
		pagesz = PAGE_SIZE - off;
		if (size < pagesz)
			pagesz = size;
		map->dm_segs[seg].ds_len += pagesz;
		size -= pagesz;
		addr = (caddr_t)addr + off + pagesz;
		off = 0;
a746 4
	/* Make the map truly valid. */
	map->dm_nsegs = seg + 1;
	map->dm_mapsize = mapsize;

d751 1
a751 1
mbus_dmamap_load_mbuf(void *v, bus_dmamap_t map, struct mbuf *m, int flags)
d753 29
a781 1
	panic("_dmamap_load_mbuf: not implemented");
d787 49
a835 1
	panic("_dmamap_load_uio: not implemented");
d842 22
a863 1
	panic("_dmamap_load_raw: not implemented");
d979 1
a979 1
	register struct mainbus_softc *sc = (struct mainbus_softc *)self;
d1032 1
a1032 1
	register struct mainbus_softc *sc;
d1064 3
a1066 3
	register struct cfdata *cf = match;
	register struct confargs *ca = aux;
	register int ret;
@


1.44
log
@properly recalculate spa-epa when it comes to per-page
mapping of the bus space (this fixes improper mappings
of the devices such as sti when btlb is not usable).
fix MALLOC/free mismatch.
print the dmesg piece before bus mapping.
map the whole rest of the io space after the mainbus
hpa that includes local and global bcast space and
that fixes the case where btlb is not available to map that.
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.43 2003/04/04 00:25:34 mickey Exp $	*/
d710 5
a714 4
	if (ops & (BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE))
		fdcache(HPPA_SID_KERNEL, map->_dm_va + offset, len);
	else
		pdcache(HPPA_SID_KERNEL, map->_dm_va + offset, len);
@


1.43
log
@always flush on pre-ops. data flushed may involve
flushing other data on the same cache lines
(such other local vars around the scsi_*_data
sturcts allocated on the satck) and that might
need to be flushed and not purged.
shows up on the cpu types that implement purge
as purge and not purge as flush.
no need for extra \n\t at the end of the asm (cosmetique).
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.42 2003/04/01 23:11:55 mickey Exp $	*/
a76 1
	register u_int64_t spa, epa;
d78 1
d134 2
a135 2
				spa = max(spa, hppa_trunc_page(bpa));
				epa = min(epa, hppa_round_page(bpa));
d140 3
a144 1

d600 2
a601 2
	register struct hppa_bus_dmamap *map;
	register size_t mapsize;
d605 1
a605 1
	MALLOC(map, struct hppa_bus_dmamap *, mapsize, M_DEVBUF,
d827 5
a831 1
	if (bus_space_map(&hppa_bustag, pdc_hpa.hpa, IOMOD_HPASIZE, 0, &ioh))
a840 1
	printf(" [flex %x]\n", pdc_hpa.hpa & HPPA_FLEX_MASK);
@


1.42
log
@use PAGE_MASK instead of PAGE_SIZE-1
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.41 2003/02/18 19:01:50 deraadt Exp $	*/
d708 1
a708 1
	if (ops & BUS_DMASYNC_PREWRITE)
d715 1
a715 1
	    "nop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\t");
@


1.41
log
@knf; mickey ok
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.40 2003/01/22 02:13:40 mickey Exp $	*/
d657 1
a657 1
	off = (bus_size_t)addr & (PAGE_SIZE - 1);
@


1.40
log
@ugh, unless we flush, always purge
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.39 2003/01/21 17:32:40 mickey Exp $	*/
d399 1
a399 1
		     bus_size_t o, u_int16_t*a, bus_size_t c);
d401 1
a401 1
		     bus_size_t o, u_int32_t*a, bus_size_t c);
d403 1
a403 1
		     bus_size_t o, u_int64_t*a, bus_size_t c);
d406 1
a406 1
		     bus_size_t o, const u_int16_t *a, bus_size_t c);
d408 1
a408 1
		     bus_size_t o, const u_int32_t *a, bus_size_t c);
d410 1
a410 1
		     bus_size_t o, const u_int64_t *a, bus_size_t c);
d737 1
a737 1
	      UVM_ADV_RANDOM, 0))) {
@


1.39
log
@reverse logic in dma sync flush as long as prewrite was given and purge for preread otherwise
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.38 2002/12/18 23:52:45 mickey Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998-2001 Michael Shalayeff
a707 1

d710 1
a710 1
	else if (ops & BUS_DMASYNC_PREREAD)
@


1.38
log
@newer machines use phantom bus to attach lasi and other bus adapters.
oledr machines did not have a real device for the phantom bus port.
change the device scanning technique to both include a full device path
in the attach_args and do proper shifting in the pdc_scanbus() and
add a device for the newer machines as well as use a newer device
mapping (path to hpa) available on newer firmware versions, where
old (hversion-dependant) is not available.
tested on 712,715/33,c110, miod@@ ok, weissmandude -- testing
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.37 2002/10/21 15:58:21 mickey Exp $	*/
d709 4
a712 3
	if (ops & (BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE))
		__asm __volatile ("sync\n\tsyncdma\n\tsync\n\t"
		    "nop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\t");
d714 3
a716 4
	if (ops & BUS_DMASYNC_PREREAD)
		pdcache(HPPA_SID_KERNEL, map->_dm_va + offset, len);
	else if (ops & BUS_DMASYNC_PREWRITE)
		fdcache(HPPA_SID_KERNEL, map->_dm_va + offset, len);
@


1.37
log
@try harder to sync in dmamap_sync
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.36 2002/10/13 15:53:39 mickey Exp $	*/
d854 4
a857 1
	pdc_scanbus(self, &nca, -1, MAXMODBUS);
@


1.36
log
@track the end of physmem for use in dmmem_alloc
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.35 2002/10/07 18:35:56 mickey Exp $	*/
d710 2
a711 1
		__asm __volatile ("syncdma");
@


1.35
log
@this removes the functionality of adding allocated
pages into the queue already containing allocated pages.
breaks i386:setup_buffers() because of this.
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.34 2002/10/06 22:06:15 art Exp $	*/
d723 1
d731 3
a733 3
	if (uvm_pglistalloc(size, VM_MIN_KERNEL_ADDRESS, VM_MAX_KERNEL_ADDRESS,
	    alignment, 0, &pglist, 1, FALSE))
		return ENOMEM;
d739 1
a739 1
		return ENOMEM;
@


1.34
log
@No more need to initialize the result list before uvm_pglistalloc.
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.33 2002/04/22 20:03:08 mickey Exp $	*/
d729 1
@


1.33
log
@always print the offset, mask allowing
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.32 2002/04/22 01:49:42 mickey Exp $	*/
a728 1
	TAILQ_INIT(&pglist);
@


1.32
log
@better autoconf_verbose prints
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.31 2002/04/21 22:54:10 mickey Exp $	*/
d880 1
a880 1
		if (ca->ca_hpa & ~ca->ca_hpamask)
@


1.31
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.30 2002/04/21 22:27:56 mickey Exp $	*/
d897 4
@


1.30
log
@map io rw, not rwx and dmamem uncached (until sync does the flush)
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.29 2002/03/19 23:04:16 mickey Exp $	*/
d749 1
a749 1
		pmap_changebit(pg, PTE_PROT(TLB_UNCACHEABLE), 0);
@


1.29
log
@if we are out of our bats -- map page by page
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.28 2002/03/14 01:26:31 millert Exp $	*/
d119 1
a119 1
			    pmap_prot(pmap_kernel(), VM_PROT_ALL)) >= 0) {
d141 1
a141 1
					pmap_kenter_pa(spa, spa, VM_PROT_ALL);
d735 1
a735 1
	    UVM_MAPFLAG(UVM_PROT_ALL, UVM_PROT_ALL, UVM_INH_NONE,
d745 1
a745 1
	for (pg = TAILQ_FIRST(&pglist); pg; pg = TAILQ_NEXT(pg, pageq)) {
d747 3
a749 5
		pmap_kenter_pa(va, VM_PAGE_TO_PHYS(pg),
		    VM_PROT_READ|VM_PROT_WRITE);
#if notused
		pmap_changebit(va, TLB_UNCACHEABLE, 0); /* XXX for now */
#endif
d754 1
a754 1
	return 0;
@


1.28
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.27 2002/02/21 06:17:19 mickey Exp $	*/
d76 1
a76 1
	extern u_int virtual_avail;
d78 1
a78 1
	int bank, off;
d82 1
a82 1
	    bpa, size, cachable?"":"non", bshp);
a83 13
	if (bpa > 0 && bpa < virtual_avail)
		*bshp = bpa;
	else if ((bank = vm_physseg_find(atop(bpa), &off)) < 0) {
		/*
		 * determine if we are mapping IO space, or beyond the physmem
		 * region. use block mapping then
		 *
		 * we map the whole bus module (there are 1024 of those max)
		 * so, check here if it's mapped already, map if needed.
		 * all mappings are equal mappings.
		 */
		static u_int32_t bmm[0x4000/32];
		int flex = HPPA_FLEX(bpa);
d85 11
d97 4
a100 4
		if (cachable) {
			printf("WARNING: mapping I/O space cachable\n");
			cachable = 0;
		}
d103 5
a107 5
		/* need a new mapping */
		if (!(bmm[flex / 32] & (1 << (flex % 32)))) {
			spa = bpa & HPPA_FLEX_MASK;
			epa = ((u_long)((u_int64_t)bpa + size +
				~HPPA_FLEX_MASK - 1) & HPPA_FLEX_MASK) - 1;
d109 2
a110 2
			printf ("bus_mem_add_mapping: adding flex=%x "
				"%qx-%qx, ", flex, spa, epa);
d112 8
a119 10
			while (spa < epa) {
				vsize_t len = epa - spa;
				u_int64_t pa;
				if (len > pdc_btlb.max_size << PGSHIFT)
					len = pdc_btlb.max_size << PGSHIFT;
				if (btlb_insert(HPPA_SID_KERNEL, spa, spa, &len,
						pmap_sid2pid(HPPA_SID_KERNEL) |
					    	pmap_prot(pmap_kernel(),
							  VM_PROT_ALL)) < 0)
					return -1;
d122 2
a123 2
				printf ("--- %x/%x, %qx, %qx-%qx",
					flex, HPPA_FLEX(pa), pa, spa, epa);
d128 1
a128 1
					printf ("mask %x ", flex);
d133 10
d145 1
a145 1
			printf ("\n");
d148 1
d150 4
a153 4
		else {
			printf("+++ already mapped flex=%x, mask=%x",
			    flex, bmm[flex / 8]);
		}
a154 3
		*bshp = bpa;
	} else {
		/* register vaddr_t va; */
d156 2
a157 31
#ifdef PMAPDEBUG
		printf ("%d, %d, %lx\n", bank, off, vm_physmem[0].end);
#endif
		spa = hppa_trunc_page(bpa);
		epa = hppa_round_page(bpa + size);

#ifdef DIAGNOSTIC
		if (epa <= spa)
			panic("bus_mem_add_mapping: overflow");
#endif
#if 0

		if (!(va = uvm_pagealloc_contig(epa - spa, spa, epa, NBPG)))
			return (ENOMEM);

		*bshp = (bus_space_handle_t)(va + (bpa & PGOFSET));

#if notused
		for (; spa < epa; spa += NBPG, va += NBPG) {
			if (!cachable)
				pmap_changebit(va, TLB_UNCACHEABLE, ~0);
			else
				pmap_changebit(va, 0, ~TLB_UNCACHEABLE);
		}
#endif /* notused */
#else
		panic("mbus_add_mapping: not implemented");
#endif
	}

	return 0;
d171 1
a171 1
			printf ("bus_space_map: pa 0x%lx, size 0x%lx\n",
d173 1
a173 1
			printf ("bus_space_map: can't free region\n");
a183 1
	paddr_t bpa;
d193 2
a194 2
	if (pmap_extract(pmap_kernel(), bsh, &bpa) && bpa != bsh)
		uvm_km_free(kernel_map, sva, eva - sva);
d196 1
a196 1
		bpa = bsh;	/* XXX assuming equ b-mapping been done */
d198 1
a198 1
	if (extent_free(hppa_ex, bpa, size, EX_NOWAIT)) {
d200 1
a200 1
		    bpa, size);
d217 1
a217 1
					    align, 0, boundary, EX_NOWAIT, &bpa)))
d229 1
a229 2

	return error;
d836 1
a836 1
	printf (" [flex %x]\n", pdc_hpa.hpa & HPPA_FLEX_MASK);
@


1.27
log
@oops
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.26 2002/02/21 06:12:30 mickey Exp $	*/
d57 2
a58 2
int	mbmatch __P((struct device *, void *, void *));
void	mbattach __P((struct device *, struct device *, void *));
d425 13
a437 13
void mbus_rrm_2 __P((void *v, bus_space_handle_t h,
		     bus_size_t o, u_int16_t*a, bus_size_t c));
void mbus_rrm_4 __P((void *v, bus_space_handle_t h,
		     bus_size_t o, u_int32_t*a, bus_size_t c));
void mbus_rrm_8 __P((void *v, bus_space_handle_t h,
		     bus_size_t o, u_int64_t*a, bus_size_t c));

void mbus_wrm_2 __P((void *v, bus_space_handle_t h,
		     bus_size_t o, const u_int16_t *a, bus_size_t c));
void mbus_wrm_4 __P((void *v, bus_space_handle_t h,
		     bus_size_t o, const u_int32_t *a, bus_size_t c));
void mbus_wrm_8 __P((void *v, bus_space_handle_t h,
		     bus_size_t o, const u_int64_t *a, bus_size_t c));
d503 13
a515 13
void mbus_rrr_2 __P((void *v, bus_space_handle_t h,
		   bus_size_t o, u_int16_t *a, bus_size_t c));
void mbus_rrr_4 __P((void *v, bus_space_handle_t h,
		   bus_size_t o, u_int32_t *a, bus_size_t c));
void mbus_rrr_8 __P((void *v, bus_space_handle_t h,
		   bus_size_t o, u_int64_t *a, bus_size_t c));

void mbus_wrr_2 __P((void *v, bus_space_handle_t h,
		   bus_size_t o, const u_int16_t *a, bus_size_t c));
void mbus_wrr_4 __P((void *v, bus_space_handle_t h,
		   bus_size_t o, const u_int32_t *a, bus_size_t c));
void mbus_wrr_8 __P((void *v, bus_space_handle_t h,
		   bus_size_t o, const u_int64_t *a, bus_size_t c));
d595 2
a596 2
#define	crr(n)	((void (*) __P((void *, bus_space_handle_t, bus_size_t, u_int8_t *, bus_size_t)))(n))
#define	cwr(n)	((void (*) __P((void *, bus_space_handle_t, bus_size_t, const u_int8_t *, bus_size_t)))(n))
@


1.26
log
@pmap.pmap_pd is redundant -- no more
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.25 2002/02/16 02:41:15 mickey Exp $	*/
d121 1
a121 1
					    	pmap_prot(pmap_kernel,
@


1.25
log
@dma_cachectl() no more
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.24 2002/02/16 02:21:56 mickey Exp $	*/
d119 3
a121 4
				if (btlb_insert(kernel_pmap->pmap_space, spa,
						spa, &len,
						kernel_pmap->pmap_pid |
					    	pmap_prot(kernel_pmap,
@


1.24
log
@implement a few dma methods; from fredette@@. some fixes from me
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.23 2002/02/12 02:44:00 mickey Exp $	*/
a810 10
}

int
dma_cachectl(p, size)
	caddr_t p;
	int size;
{
	fdcache(HPPA_SID_KERNEL, (vaddr_t)p, size);
	sync_caches();
	return 0;
@


1.23
log
@leftover form dekvtop (which did the block maps too)
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.22 2002/02/11 21:12:59 mickey Exp $	*/
d154 1
a154 1
		printf ("%d, %d, %x\n", bank, off, vm_physmem[0].end);
d271 2
a272 1
	panic("mbus_subregion: unimplemented");
d642 2
d650 7
d659 3
d669 42
a710 1
	panic("_dmamap_load: not implemented");
a732 6
mbus_dmamap_unload(void *v, bus_dmamap_t map)
{
	panic("_dmamap_unload: not implemented");
}

void
d736 2
a737 4
	int i;
	switch (ops) {
	case BUS_DMASYNC_POSTREAD:
	case BUS_DMASYNC_POSTWRITE:
a738 1
		break;
d740 4
a743 16
	case BUS_DMASYNC_PREREAD:
		for (i = map->dm_nsegs; i--; )
			pdcache(HPPA_SID_KERNEL,
			    map->dm_segs[i].ds_addr + offset,
			    len);
		sync_caches();
		break;

	case BUS_DMASYNC_PREWRITE:
		for (i = map->dm_nsegs; i--; )
			fdcache(HPPA_SID_KERNEL,
			    map->dm_segs[i].ds_addr + offset,
			    len);
		sync_caches();
		break;
	}
@


1.22
log
@do not use kvtop
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.21 2002/02/07 05:43:51 mickey Exp $	*/
d222 2
@


1.21
log
@fix irq passing on match
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.20 2001/12/08 02:24:06 art Exp $	*/
d209 2
a210 2
	register u_long sva, eva;
	register bus_addr_t bpa;
d220 1
a220 2
	bpa = kvtop((caddr_t)bsh);
	if (bpa != bsh)
@


1.20
log
@Sprinkle pmap_update calls where relevant and some other
misc pmap usage fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.19 2001/12/02 04:10:25 mickey Exp $	*/
d854 1
d908 1
a908 2
	if ((ret = (*cf->cf_attach->ca_match)(parent, match, aux)) &&
	    cf->hppacf_irq != -1)
@


1.20.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.20 2001/12/08 02:24:06 art Exp $	*/
d57 2
a58 2
int	mbmatch(struct device *, void *, void *);
void	mbattach(struct device *, struct device *, void *);
d76 1
a76 1
	static u_int32_t bmm[0x4000/32];
d78 1
a78 1
	int bank, off, flex = HPPA_FLEX(bpa);
d82 1
a82 1
	    bpa, size, cachable? "" : "non", bshp);
d84 13
a97 11
	if ((bank = vm_physseg_find(atop(bpa), &off)) >= 0)
		panic("mbus_add_mapping: mapping real memory @@0x%x", bpa);

	/*
	 * determine if we are mapping IO space, or beyond the physmem
	 * region. use block mapping then
	 *
	 * we map the whole bus module (there are 1024 of those max)
	 * so, check here if it's mapped already, map if needed.
	 * all mappings are equal mappings.
	 */
d99 4
a102 4
	if (cachable) {
		printf("WARNING: mapping I/O space cachable\n");
		cachable = 0;
	}
d105 5
a109 5
	/* need a new mapping */
	if (!(bmm[flex / 32] & (1 << (flex % 32)))) {
		spa = bpa & HPPA_FLEX_MASK;
		epa = ((u_long)((u_int64_t)bpa + size +
			~HPPA_FLEX_MASK - 1) & HPPA_FLEX_MASK) - 1;
d111 2
a112 2
		printf("bus_mem_add_mapping: adding flex=%x "
			"%qx-%qx, ", flex, spa, epa);
d114 11
a124 8
		while (spa < epa) {
			vsize_t len = epa - spa;
			u_int64_t pa;
			if (len > pdc_btlb.max_size << PGSHIFT)
				len = pdc_btlb.max_size << PGSHIFT;
			if (btlb_insert(HPPA_SID_KERNEL, spa, spa, &len,
			    pmap_sid2pid(HPPA_SID_KERNEL) |
			    pmap_prot(pmap_kernel(), UVM_PROT_RW)) >= 0) {
d127 2
a128 2
				printf("--- %x/%x, %qx, %qx-%qx",
				    flex, HPPA_FLEX(pa), pa, spa, epa);
d133 1
a133 1
					printf("mask %x ", flex);
a137 10
			} else {
				spa = max(spa, hppa_trunc_page(bpa));
				epa = min(epa, hppa_round_page(bpa));

				if (epa - 1 > ~0U)
					epa = (u_int64_t)~0U + 1;

				for (; spa < epa; spa += PAGE_SIZE)
					pmap_kenter_pa(spa, spa, UVM_PROT_RW);

d140 1
a140 1
			printf("\n");
a142 1
	}
d144 37
a180 3
	else {
		printf("+++ already b-mapped flex=%x, mask=%x",
		    flex, bmm[flex / 8]);
a181 1
#endif
d183 1
a183 2
	*bshp = bpa;
	return (0);
d197 1
a197 1
			printf("bus_space_map: pa 0x%lx, size 0x%lx\n",
d199 1
a199 1
			printf("bus_space_map: can't free region\n");
d209 2
a210 1
	u_long sva, eva;
d220 3
a222 4
	if (pmap_extract(pmap_kernel(), bsh, NULL))
		pmap_kremove(sva, eva - sva);
	else
		;	/* XXX assuming equ b-mapping been done */
d224 1
a224 1
	if (extent_free(hppa_ex, bsh, size, EX_NOWAIT)) {
d226 1
a226 1
		    bsh, size);
d243 1
a243 1
	    align, 0, boundary, EX_NOWAIT, &bpa)))
d255 2
a256 1
	return (error);
d270 1
a270 2
	*nbshp = bsh + offset;
	return (0);
d424 13
a436 13
void mbus_rrm_2(void *v, bus_space_handle_t h,
		     bus_size_t o, u_int16_t*a, bus_size_t c);
void mbus_rrm_4(void *v, bus_space_handle_t h,
		     bus_size_t o, u_int32_t*a, bus_size_t c);
void mbus_rrm_8(void *v, bus_space_handle_t h,
		     bus_size_t o, u_int64_t*a, bus_size_t c);

void mbus_wrm_2(void *v, bus_space_handle_t h,
		     bus_size_t o, const u_int16_t *a, bus_size_t c);
void mbus_wrm_4(void *v, bus_space_handle_t h,
		     bus_size_t o, const u_int32_t *a, bus_size_t c);
void mbus_wrm_8(void *v, bus_space_handle_t h,
		     bus_size_t o, const u_int64_t *a, bus_size_t c);
d502 13
a514 13
void mbus_rrr_2(void *v, bus_space_handle_t h,
		   bus_size_t o, u_int16_t *a, bus_size_t c);
void mbus_rrr_4(void *v, bus_space_handle_t h,
		   bus_size_t o, u_int32_t *a, bus_size_t c);
void mbus_rrr_8(void *v, bus_space_handle_t h,
		   bus_size_t o, u_int64_t *a, bus_size_t c);

void mbus_wrr_2(void *v, bus_space_handle_t h,
		   bus_size_t o, const u_int16_t *a, bus_size_t c);
void mbus_wrr_4(void *v, bus_space_handle_t h,
		   bus_size_t o, const u_int32_t *a, bus_size_t c);
void mbus_wrr_8(void *v, bus_space_handle_t h,
		   bus_size_t o, const u_int64_t *a, bus_size_t c);
d594 2
a595 2
#define	crr(n)	((void (*)(void *, bus_space_handle_t, bus_size_t, u_int8_t *, bus_size_t))(n))
#define	cwr(n)	((void (*)(void *, bus_space_handle_t, bus_size_t, const u_int8_t *, bus_size_t))(n))
a639 2
	map->dm_mapsize = 0;
	map->dm_nsegs = 0;
a645 7
mbus_dmamap_unload(void *v, bus_dmamap_t map)
{
	map->dm_mapsize = 0;
	map->dm_nsegs = 0;
}

void
a647 3
	if (map->dm_mapsize != 0)
		mbus_dmamap_unload(v, map);

d655 1
a655 42
	paddr_t pa, pa_next;
	bus_size_t mapsize;
	bus_size_t off, pagesz;
	int seg;

	/*
	 * Make sure that on error condition we return "no valid mappings".
	 */
	map->dm_nsegs = 0;
	map->dm_mapsize = 0;
	map->_dm_va = (vaddr_t)addr;

	/* Load the memory. */
	pa_next = 0;
	seg = -1;
	mapsize = size;
	off = (bus_size_t)addr & (PAGE_SIZE - 1);
	addr = (void *) ((caddr_t)addr - off);
	for(; size > 0; ) {

		pmap_extract(pmap_kernel(), (vaddr_t)addr, &pa);
		if (pa != pa_next) {
			if (++seg >= map->_dm_segcnt)
				panic("mbus_dmamap_load: nsegs botch");
			map->dm_segs[seg].ds_addr = pa + off;
			map->dm_segs[seg].ds_len = 0;
		}
		pa_next = pa + PAGE_SIZE;
		pagesz = PAGE_SIZE - off;
		if (size < pagesz)
			pagesz = size;
		map->dm_segs[seg].ds_len += pagesz;
		size -= pagesz;
		addr = (caddr_t)addr + off + pagesz;
		off = 0;
	}

	/* Make the map truly valid. */
	map->dm_nsegs = seg + 1;
	map->dm_mapsize = mapsize;

	return (0);
d678 6
d687 4
a690 2

	if (ops & (BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE))
d692 1
d694 16
a709 4
	if (ops & BUS_DMASYNC_PREREAD)
		pdcache(HPPA_SID_KERNEL, map->_dm_va + offset, len);
	else if (ops & BUS_DMASYNC_PREWRITE)
		fdcache(HPPA_SID_KERNEL, map->_dm_va + offset, len);
d729 1
a729 1
	    UVM_MAPFLAG(UVM_PROT_RW, UVM_PROT_RW, UVM_INH_NONE,
d739 1
a739 1
	TAILQ_FOREACH(pg, &pglist, pageq) {
d741 5
a745 3
		pmap_kenter_pa(va, VM_PAGE_TO_PHYS(pg), UVM_PROT_RW);
		/* XXX for now */
		pmap_changebit(pg, PTE_PROT(TLB_UNCACHABLE), 0);
d750 1
a750 1
	return (0);
d779 10
d840 1
a840 1
	printf(" [flex %x]\n", pdc_hpa.hpa & HPPA_FLEX_MASK);
a853 1
	nca.ca_irq = -1;
d885 1
a885 1
		if (~ca->ca_hpamask)
a902 4
	if (autoconf_verbose)
		printf(">> hpa %x off %x cf_off %x\n",
		    ca->ca_hpa, ca->ca_hpa & ~ca->ca_hpamask, cf->hppacf_off);

d907 2
a908 1
	if ((ret = (*cf->cf_attach->ca_match)(parent, match, aux)))
@


1.20.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.20.2.1 2002/06/11 03:35:37 art Exp $	*/
d710 1
a710 2
		__asm __volatile ("sync\n\tsyncdma\n\tsync\n\t"
		    "nop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\t");
a722 1
	extern paddr_t avail_end;
d730 3
a732 3
	if (uvm_pglistalloc(size, 0, avail_end, alignment, boundary,
	    &pglist, nsegs, flags & BUS_DMA_NOWAIT))
		return (ENOMEM);
d738 1
a738 1
		return (ENOMEM);
@


1.20.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d4 1
a4 1
 * Copyright (c) 1998-2003 Michael Shalayeff
d77 1
a78 1
	u_int64_t spa, epa;
d134 2
a135 2
				spa = hppa_trunc_page(bpa);
				epa = hppa_round_page(bpa + size);
a139 3
#ifdef BTLBDEBUG
				printf("kenter 0x%qx-0x%qx", spa, epa);
#endif
d142 1
d399 1
a399 1
	    bus_size_t o, u_int16_t*a, bus_size_t c);
d401 1
a401 1
	    bus_size_t o, u_int32_t*a, bus_size_t c);
d403 1
a403 1
	    bus_size_t o, u_int64_t*a, bus_size_t c);
d406 1
a406 1
	    bus_size_t o, const u_int16_t *a, bus_size_t c);
d408 1
a408 1
	    bus_size_t o, const u_int32_t *a, bus_size_t c);
d410 1
a410 1
	    bus_size_t o, const u_int64_t *a, bus_size_t c);
d598 2
a599 2
	struct hppa_bus_dmamap *map;
	size_t mapsize;
d603 1
a603 1
	map = malloc(mapsize, M_DEVBUF,
d657 1
a657 1
	off = (bus_size_t)addr & PAGE_MASK;
d708 8
a715 1
	if (ops & (BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE))
a716 6
	else
		pdcache(HPPA_SID_KERNEL, map->_dm_va + offset, len);

	/* for either operation sync the shit away */
	__asm __volatile ("sync\n\tsyncdma\n\tsync\n\t"
	    "nop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop");
d738 1
a738 1
	    UVM_ADV_RANDOM, 0))) {
d826 1
a826 5
	printf(" [flex %x]\n", pdc_hpa.hpa & HPPA_FLEX_MASK);

	/* map all the way till the end of the memory */
	if (bus_space_map(&hppa_bustag, pdc_hpa.hpa,
	    (~0LU - pdc_hpa.hpa + 1), 0, &ioh))
d836 1
d854 1
a854 4
	nca.ca_dp.dp_bc[0] = nca.ca_dp.dp_bc[1] = nca.ca_dp.dp_bc[2] =
	nca.ca_dp.dp_bc[3] = nca.ca_dp.dp_bc[4] = nca.ca_dp.dp_bc[5] = -1;
	nca.ca_dp.dp_mod = -1;
	pdc_scanbus(self, &nca, MAXMODBUS);
@


1.19
log
@s/FLAX_MASK/HPPA_FLEX_MASK/ where not yet
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.18 2001/12/02 04:03:57 mickey Exp $	*/
d748 1
@


1.18
log
@allow to configure devices on particular bus offsets
to be able to attach units to them.
main reason is the secondary gsc busses on add-on cards
which stick 'emselves in the front.
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.17 2001/11/28 13:47:38 art Exp $	*/
d107 1
a107 1
			spa = bpa & FLEX_MASK;
d109 1
a109 1
				~FLEX_MASK - 1) & FLEX_MASK) - 1;
d835 2
a836 2
	((struct iomod *)(pdc_hpa.hpa & FLEX_MASK))[FPA_IOMOD].io_flex =
		(void *)((pdc_hpa.hpa & FLEX_MASK) | DMA_ENABLE);
d839 1
a839 1
	printf (" [flex %x]\n", pdc_hpa.hpa & FLEX_MASK);
@


1.17
log
@Sync in more uvm changes from NetBSD.
This time we're getting rid of KERN_* and VM_PAGER_* error codes and
use errnos instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.16 2001/11/07 01:18:00 art Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998-2000 Michael Shalayeff
d845 1
d853 1
d884 2
a885 1
		printf(" hpa %x", ca->ca_hpa);
d902 6
a907 1
	if ((ret = (*cf->cf_attach->ca_match)(parent, match, aux))) {
a908 1
	}
@


1.16
log
@Add an alignment argument to uvm_map that specifies an alignment hint
for the virtual address.
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.15 2001/11/06 19:53:14 miod Exp $	*/
d730 1
a730 1
	      UVM_ADV_RANDOM, 0)) != KERN_SUCCESS) {
@


1.15
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.14 2001/11/05 17:25:57 art Exp $	*/
d728 1
a728 1
	if (uvm_map(kernel_map, &va, size, NULL, UVM_UNKNOWN_OFFSET,
@


1.14
log
@Switch everything to the new bus_dmamap_sync API.
Most work by Wilbern Cobb <vedge@@csoft.org> with some fixes from me, mickey@@
and drahn@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.13 2001/09/19 20:50:56 mickey Exp $	*/
d44 1
a44 1
#include <vm/vm.h>
a45 1
#include <uvm/uvm.h>
@


1.13
log
@merge vm/vm_kern.h into uvm/uvm_extern.h; art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.12 2001/08/01 20:32:13 miod Exp $	*/
d685 2
a686 1
mbus_dmamap_sync(void *v, bus_dmamap_t map, bus_dmasync_op_t ops)
d697 3
a699 2
			pdcache(HPPA_SID_KERNEL, map->dm_segs[i].ds_addr,
			    map->dm_segs[i].ds_len);
d705 3
a707 2
			fdcache(HPPA_SID_KERNEL, map->dm_segs[i].ds_addr,
			    map->dm_segs[i].ds_len);
@


1.12
log
@Sync with busdma_map api change.
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.11 2001/07/05 10:00:28 art Exp $	*/
a44 1
#include <vm/vm_kern.h>
@


1.11
log
@Get rid of the wrapper macros around extent_alloc*1
Pass the right amount of arguments and rename them back to their right names.
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.10 2001/01/12 23:49:52 mickey Exp $	*/
d770 2
a771 2
int
mbus_dmamem_mmap(void *v, bus_dma_segment_t *segs, int nsegs, int off,
@


1.10
log
@no pmap_changebit no more; better barrier thing
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.9 2000/02/09 05:56:50 mickey Exp $	*/
d245 1
a245 1
					    align, boundary, EX_NOWAIT, &bpa)))
@


1.9
log
@raw bus transfers are unaligned, also some spells
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.8 2000/01/17 06:43:04 mickey Exp $	*/
d172 1
d175 1
a175 1
				pmap_changebit(spa, TLB_UNCACHEABLE, ~0);
d177 1
a177 1
				pmap_changebit(spa, 0, ~TLB_UNCACHEABLE);
d179 1
d181 1
a181 1
			panic("mbus_add_mapping: not implemented");
d688 21
a708 1
	__asm __volatile ("syncdma");
d727 3
a729 1
	if ((va = uvm_km_valloc(kernel_map, size)) == 0) {
d742 3
a744 3

		pmap_changebit(pg, TLB_UNCACHEABLE, 0); /* XXX for now */

@


1.9.2.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.10 2001/01/12 23:49:52 mickey Exp $	*/
a171 1
#if notused
d174 1
a174 1
				pmap_changebit(va, TLB_UNCACHEABLE, ~0);
d176 1
a176 1
				pmap_changebit(va, 0, ~TLB_UNCACHEABLE);
a177 1
#endif /* notused */
d179 1
a179 1
		panic("mbus_add_mapping: not implemented");
d686 1
a686 21
	int i;
	switch (ops) {
	case BUS_DMASYNC_POSTREAD:
	case BUS_DMASYNC_POSTWRITE:
		__asm __volatile ("syncdma");
		break;

	case BUS_DMASYNC_PREREAD:
		for (i = map->dm_nsegs; i--; )
			pdcache(HPPA_SID_KERNEL, map->dm_segs[i].ds_addr,
			    map->dm_segs[i].ds_len);
		sync_caches();
		break;

	case BUS_DMASYNC_PREWRITE:
		for (i = map->dm_nsegs; i--; )
			fdcache(HPPA_SID_KERNEL, map->dm_segs[i].ds_addr,
			    map->dm_segs[i].ds_len);
		sync_caches();
		break;
	}
d705 1
a705 3
	if (uvm_map(kernel_map, &va, size, NULL, UVM_UNKNOWN_OFFSET,
	    UVM_MAPFLAG(UVM_PROT_ALL, UVM_PROT_ALL, UVM_INH_NONE,
	      UVM_ADV_RANDOM, 0)) != KERN_SUCCESS) {
d718 3
a720 3
#if notused
		pmap_changebit(va, TLB_UNCACHEABLE, 0); /* XXX for now */
#endif
@


1.9.2.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.9.2.1 2001/04/18 16:06:14 niklas Exp $	*/
d45 1
d245 1
a245 1
					    align, 0, boundary, EX_NOWAIT, &bpa)))
d770 2
a771 2
paddr_t
mbus_dmamem_mmap(void *v, bus_dma_segment_t *segs, int nsegs, off_t off,
@


1.9.2.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d44 2
a46 1
#include <uvm/uvm_page.h>
d685 1
a685 2
mbus_dmamap_sync(void *v, bus_dmamap_t map, bus_addr_t offset, bus_size_t len,
    int ops)
d696 2
a697 3
			pdcache(HPPA_SID_KERNEL,
			    map->dm_segs[i].ds_addr + offset,
			    len);
d703 2
a704 3
			fdcache(HPPA_SID_KERNEL,
			    map->dm_segs[i].ds_addr + offset,
			    len);
d726 1
a726 1
	if (uvm_map(kernel_map, &va, size, NULL, UVM_UNKNOWN_OFFSET, 0,
@


1.9.2.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.9.2.3 2001/11/13 21:00:51 niklas Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998-2001 Michael Shalayeff
d107 1
a107 1
			spa = bpa & HPPA_FLEX_MASK;
d109 1
a109 1
				~HPPA_FLEX_MASK - 1) & HPPA_FLEX_MASK) - 1;
d730 1
a730 1
	      UVM_ADV_RANDOM, 0))) {
d835 2
a836 2
	((struct iomod *)(pdc_hpa.hpa & HPPA_FLEX_MASK))[FPA_IOMOD].io_flex =
		(void *)((pdc_hpa.hpa & HPPA_FLEX_MASK) | DMA_ENABLE);
d839 1
a839 1
	printf (" [flex %x]\n", pdc_hpa.hpa & HPPA_FLEX_MASK);
a844 1
	nca.ca_hpamask = 0;
a851 1
	nca.ca_hpamask = HPPA_IOSPACE;
d882 1
a882 2
		if (ca->ca_hpa & ~ca->ca_hpamask)
			printf(" offset %x", ca->ca_hpa & ~ca->ca_hpamask);
d899 1
a899 6
	if (ca->ca_hpa && ~ca->ca_hpamask && cf->hppacf_off != -1 &&
	    ((ca->ca_hpa & ~ca->ca_hpamask) != cf->hppacf_off))
		return (0);

	if ((ret = (*cf->cf_attach->ca_match)(parent, match, aux)) &&
	    cf->hppacf_irq != -1)
d901 1
@


1.9.2.5
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d119 4
a122 3
				if (btlb_insert(HPPA_SID_KERNEL, spa, spa, &len,
						pmap_sid2pid(HPPA_SID_KERNEL) |
					    	pmap_prot(pmap_kernel(),
d154 1
a154 1
		printf ("%d, %d, %lx\n", bank, off, vm_physmem[0].end);
d209 2
a210 2
	u_long sva, eva;
	paddr_t bpa;
d220 2
a221 1
	if (pmap_extract(pmap_kernel(), bsh, &bpa) && bpa != bsh)
a222 2
	else
		bpa = bsh;	/* XXX assuming equ b-mapping been done */
d270 1
a270 2
	*nbshp = bsh + offset;
	return (0);
a639 2
	map->dm_mapsize = 0;
	map->dm_nsegs = 0;
a645 7
mbus_dmamap_unload(void *v, bus_dmamap_t map)
{
	map->dm_mapsize = 0;
	map->dm_nsegs = 0;
}

void
a647 3
	if (map->dm_mapsize != 0)
		mbus_dmamap_unload(v, map);

d655 1
a655 42
	paddr_t pa, pa_next;
	bus_size_t mapsize;
	bus_size_t off, pagesz;
	int seg;

	/*
	 * Make sure that on error condition we return "no valid mappings".
	 */
	map->dm_nsegs = 0;
	map->dm_mapsize = 0;
	map->_dm_va = (vaddr_t)addr;

	/* Load the memory. */
	pa_next = 0;
	seg = -1;
	mapsize = size;
	off = (bus_size_t)addr & (PAGE_SIZE - 1);
	addr = (void *) ((caddr_t)addr - off);
	for(; size > 0; ) {

		pmap_extract(pmap_kernel(), (vaddr_t)addr, &pa);
		if (pa != pa_next) {
			if (++seg >= map->_dm_segcnt)
				panic("mbus_dmamap_load: nsegs botch");
			map->dm_segs[seg].ds_addr = pa + off;
			map->dm_segs[seg].ds_len = 0;
		}
		pa_next = pa + PAGE_SIZE;
		pagesz = PAGE_SIZE - off;
		if (size < pagesz)
			pagesz = size;
		map->dm_segs[seg].ds_len += pagesz;
		size -= pagesz;
		addr = (caddr_t)addr + off + pagesz;
		off = 0;
	}

	/* Make the map truly valid. */
	map->dm_nsegs = seg + 1;
	map->dm_mapsize = mapsize;

	return (0);
d678 6
d687 4
a690 2

	if (ops & (BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE))
d692 1
d694 16
a709 4
	if (ops & BUS_DMASYNC_PREREAD)
		pdcache(HPPA_SID_KERNEL, map->_dm_va + offset, len);
	else if (ops & BUS_DMASYNC_PREWRITE)
		fdcache(HPPA_SID_KERNEL, map->_dm_va + offset, len);
a747 1
	pmap_update(pmap_kernel());
d778 10
a852 1
	nca.ca_irq = -1;
d906 2
a907 1
	if ((ret = (*cf->cf_attach->ca_match)(parent, match, aux)))
@


1.9.2.6
log
@Merge in -current from about a week ago
@
text
@d57 2
a58 2
int	mbmatch(struct device *, void *, void *);
void	mbattach(struct device *, struct device *, void *);
d76 1
a76 1
	static u_int32_t bmm[0x4000/32];
d78 1
a78 1
	int bank, off, flex = HPPA_FLEX(bpa);
d82 1
a82 1
	    bpa, size, cachable? "" : "non", bshp);
d84 13
a97 11
	if ((bank = vm_physseg_find(atop(bpa), &off)) >= 0)
		panic("mbus_add_mapping: mapping real memory @@0x%x", bpa);

	/*
	 * determine if we are mapping IO space, or beyond the physmem
	 * region. use block mapping then
	 *
	 * we map the whole bus module (there are 1024 of those max)
	 * so, check here if it's mapped already, map if needed.
	 * all mappings are equal mappings.
	 */
d99 4
a102 4
	if (cachable) {
		printf("WARNING: mapping I/O space cachable\n");
		cachable = 0;
	}
d105 5
a109 5
	/* need a new mapping */
	if (!(bmm[flex / 32] & (1 << (flex % 32)))) {
		spa = bpa & HPPA_FLEX_MASK;
		epa = ((u_long)((u_int64_t)bpa + size +
			~HPPA_FLEX_MASK - 1) & HPPA_FLEX_MASK) - 1;
d111 2
a112 2
		printf("bus_mem_add_mapping: adding flex=%x "
			"%qx-%qx, ", flex, spa, epa);
d114 10
a123 8
		while (spa < epa) {
			vsize_t len = epa - spa;
			u_int64_t pa;
			if (len > pdc_btlb.max_size << PGSHIFT)
				len = pdc_btlb.max_size << PGSHIFT;
			if (btlb_insert(HPPA_SID_KERNEL, spa, spa, &len,
			    pmap_sid2pid(HPPA_SID_KERNEL) |
			    pmap_prot(pmap_kernel(), VM_PROT_ALL)) >= 0) {
d126 2
a127 2
				printf("--- %x/%x, %qx, %qx-%qx",
				    flex, HPPA_FLEX(pa), pa, spa, epa);
d132 1
a132 1
					printf("mask %x ", flex);
a136 10
			} else {
				spa = max(spa, hppa_trunc_page(bpa));
				epa = min(epa, hppa_round_page(bpa));

				if (epa - 1 > ~0U)
					epa = (u_int64_t)~0U + 1;

				for (; spa < epa; spa += PAGE_SIZE)
					pmap_kenter_pa(spa, spa, VM_PROT_ALL);

d139 1
a139 1
			printf("\n");
a141 1
	}
d143 37
a179 3
	else {
		printf("+++ already b-mapped flex=%x, mask=%x",
		    flex, bmm[flex / 8]);
a180 1
#endif
d182 1
a182 2
	*bshp = bpa;
	return (0);
d196 1
a196 1
			printf("bus_space_map: pa 0x%lx, size 0x%lx\n",
d198 1
a198 1
			printf("bus_space_map: can't free region\n");
d209 1
d219 2
a220 2
	if (pmap_extract(pmap_kernel(), bsh, NULL))
		pmap_kremove(sva, eva - sva);
d222 1
a222 1
		;	/* XXX assuming equ b-mapping been done */
d224 1
a224 1
	if (extent_free(hppa_ex, bsh, size, EX_NOWAIT)) {
d226 1
a226 1
		    bsh, size);
d243 1
a243 1
	    align, 0, boundary, EX_NOWAIT, &bpa)))
d255 2
a256 1
	return (error);
d425 13
a437 13
void mbus_rrm_2(void *v, bus_space_handle_t h,
		     bus_size_t o, u_int16_t*a, bus_size_t c);
void mbus_rrm_4(void *v, bus_space_handle_t h,
		     bus_size_t o, u_int32_t*a, bus_size_t c);
void mbus_rrm_8(void *v, bus_space_handle_t h,
		     bus_size_t o, u_int64_t*a, bus_size_t c);

void mbus_wrm_2(void *v, bus_space_handle_t h,
		     bus_size_t o, const u_int16_t *a, bus_size_t c);
void mbus_wrm_4(void *v, bus_space_handle_t h,
		     bus_size_t o, const u_int32_t *a, bus_size_t c);
void mbus_wrm_8(void *v, bus_space_handle_t h,
		     bus_size_t o, const u_int64_t *a, bus_size_t c);
d503 13
a515 13
void mbus_rrr_2(void *v, bus_space_handle_t h,
		   bus_size_t o, u_int16_t *a, bus_size_t c);
void mbus_rrr_4(void *v, bus_space_handle_t h,
		   bus_size_t o, u_int32_t *a, bus_size_t c);
void mbus_rrr_8(void *v, bus_space_handle_t h,
		   bus_size_t o, u_int64_t *a, bus_size_t c);

void mbus_wrr_2(void *v, bus_space_handle_t h,
		   bus_size_t o, const u_int16_t *a, bus_size_t c);
void mbus_wrr_4(void *v, bus_space_handle_t h,
		   bus_size_t o, const u_int32_t *a, bus_size_t c);
void mbus_wrr_8(void *v, bus_space_handle_t h,
		   bus_size_t o, const u_int64_t *a, bus_size_t c);
d595 2
a596 2
#define	crr(n)	((void (*)(void *, bus_space_handle_t, bus_size_t, u_int8_t *, bus_size_t))(n))
#define	cwr(n)	((void (*)(void *, bus_space_handle_t, bus_size_t, const u_int8_t *, bus_size_t))(n))
d863 1
a863 1
	printf(" [flex %x]\n", pdc_hpa.hpa & HPPA_FLEX_MASK);
@


1.9.2.7
log
@Sync the SMP branch with 3.3
@
text
@d4 1
a4 1
 * Copyright (c) 1998-2003 Michael Shalayeff
d119 1
a119 1
			    pmap_prot(pmap_kernel(), UVM_PROT_RW)) >= 0) {
d141 1
a141 1
					pmap_kenter_pa(spa, spa, UVM_PROT_RW);
d399 1
a399 1
	    bus_size_t o, u_int16_t*a, bus_size_t c);
d401 1
a401 1
	    bus_size_t o, u_int32_t*a, bus_size_t c);
d403 1
a403 1
	    bus_size_t o, u_int64_t*a, bus_size_t c);
d406 1
a406 1
	    bus_size_t o, const u_int16_t *a, bus_size_t c);
d408 1
a408 1
	    bus_size_t o, const u_int32_t *a, bus_size_t c);
d410 1
a410 1
	    bus_size_t o, const u_int64_t *a, bus_size_t c);
d708 7
a714 1
	if (ops & BUS_DMASYNC_PREWRITE)
a715 6
	else
		pdcache(HPPA_SID_KERNEL, map->_dm_va + offset, len);

	/* for either operation sync the shit away */
	__asm __volatile ("sync\n\tsyncdma\n\tsync\n\t"
	    "nop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\t");
a722 1
	extern paddr_t avail_end;
d730 3
a732 3
	if (uvm_pglistalloc(size, 0, avail_end, alignment, boundary,
	    &pglist, nsegs, flags & BUS_DMA_NOWAIT))
		return (ENOMEM);
d735 2
a736 2
	    UVM_MAPFLAG(UVM_PROT_RW, UVM_PROT_RW, UVM_INH_NONE,
	    UVM_ADV_RANDOM, 0))) {
d738 1
a738 1
		return (ENOMEM);
d745 1
a745 1
	TAILQ_FOREACH(pg, &pglist, pageq) {
d747 5
a751 3
		pmap_kenter_pa(va, VM_PAGE_TO_PHYS(pg), UVM_PROT_RW);
		/* XXX for now */
		pmap_changebit(pg, PTE_PROT(TLB_UNCACHABLE), 0);
d756 1
a756 1
	return (0);
d854 1
a854 4
	nca.ca_dp.dp_bc[0] = nca.ca_dp.dp_bc[1] = nca.ca_dp.dp_bc[2] =
	nca.ca_dp.dp_bc[3] = nca.ca_dp.dp_bc[4] = nca.ca_dp.dp_bc[5] = -1;
	nca.ca_dp.dp_mod = -1;
	pdc_scanbus(self, &nca, MAXMODBUS);
d882 1
a882 1
		if (~ca->ca_hpamask)
a898 4

	if (autoconf_verbose)
		printf(">> hpa %x off %x cf_off %x\n",
		    ca->ca_hpa, ca->ca_hpa & ~ca->ca_hpamask, cf->hppacf_off);
@


1.9.2.8
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.9.2.7 2003/03/27 23:26:53 niklas Exp $	*/
d77 1
a78 1
	u_int64_t spa, epa;
d134 2
a135 2
				spa = hppa_trunc_page(bpa);
				epa = hppa_round_page(bpa + size);
a139 3
#ifdef BTLBDEBUG
				printf("kenter 0x%qx-0x%qx", spa, epa);
#endif
d142 1
d598 2
a599 2
	struct hppa_bus_dmamap *map;
	size_t mapsize;
d603 1
a603 1
	map = malloc(mapsize, M_DEVBUF,
d657 1
a657 1
	off = (bus_size_t)addr & PAGE_MASK;
d708 1
a708 1
	if (ops & (BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE))
d715 1
a715 1
	    "nop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop");
d825 1
a825 5
	printf(" [flex %x]\n", pdc_hpa.hpa & HPPA_FLEX_MASK);

	/* map all the way till the end of the memory */
	if (bus_space_map(&hppa_bustag, pdc_hpa.hpa,
	    (~0LU - pdc_hpa.hpa + 1), 0, &ioh))
d835 1
@


1.9.2.9
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a33 1
#include "power.h"
a67 3
struct pdc_hpa pdc_hpa PDC_ALIGNMENT;
struct pdc_power_info pdc_power_info PDC_ALIGNMENT;

d73 1
a73 1
mbus_add_mapping(bus_addr_t bpa, bus_size_t size, int flags,
d82 1
a82 1
	    bpa, size, flags? "" : "non", bshp);
d86 1
a86 1
		panic("mbus_add_mapping: mapping real memory @@0x%lx", bpa);
d97 1
a97 1
	if (flags & BUS_SPACE_MAP_CACHEABLE) {
d99 1
a99 1
		flags &= ~BUS_SPACE_MAP_CACHEABLE;
d164 1
a164 1
    int flags, bus_space_handle_t *bshp)
d166 1
a166 1
	int error;
d168 1
a168 2
	if (!(flags & BUS_SPACE_MAP_NOEXTENT) &&
	    (error = extent_alloc_region(hppa_ex, bpa, size, EX_NOWAIT)))
d171 1
a171 1
	if ((error = mbus_add_mapping(bpa, size, flags, bshp))) {
d209 1
a209 1
	 bus_size_t align, bus_size_t boundary, int flags,
d222 1
a222 1
	if ((error = mbus_add_mapping(bpa, size, flags, bshp))) {
a638 84
/*
 * Utility function to load a linear buffer.  lastaddrp holds state
 * between invocations (for multiple-buffer loads).  segp contains
 * the starting segment on entrace, and the ending segment on exit.
 * first indicates if this is the first invocation of this function.
 */
int
_bus_dmamap_load_buffer(bus_dma_tag_t t, bus_dmamap_t map, void *buf,
    bus_size_t buflen, struct proc *p, int flags, paddr_t *lastaddrp,
    int *segp, int first)
{
	bus_size_t sgsize;
	bus_addr_t curaddr, lastaddr, baddr, bmask;
	vaddr_t vaddr = (vaddr_t)buf;
	int seg;
	pmap_t pmap;

	pmap = p? p->p_vmspace->vm_map.pmap : pmap_kernel();
	lastaddr = *lastaddrp;
	bmask  = ~(map->_dm_boundary - 1);

	for (seg = *segp; buflen > 0 ; ) {
		/*
		 * Get the physical address for this segment.
		 */
		pmap_extract(pmap, vaddr, (paddr_t *)&curaddr);

		/*
		 * Compute the segment size, and adjust counts.
		 */
		sgsize = PAGE_SIZE - ((u_long)vaddr & PGOFSET);
		if (buflen < sgsize)
			sgsize = buflen;

		/*
		 * Make sure we don't cross any boundaries.
		 */
		if (map->_dm_boundary > 0) {
			baddr = (curaddr + map->_dm_boundary) & bmask;
			if (sgsize > (baddr - curaddr))
				sgsize = (baddr - curaddr);
		}

		/*
		 * Insert chunk into a segment, coalescing with
		 * previous segment if possible.
		 */
		if (first) {
			map->dm_segs[seg].ds_addr = curaddr;
			map->dm_segs[seg].ds_len = sgsize;
			map->_dm_va = vaddr;
			first = 0;
		} else {
			if (curaddr == lastaddr &&
			    (map->dm_segs[seg].ds_len + sgsize) <=
			     map->_dm_maxsegsz &&
			    (map->_dm_boundary == 0 ||
			     (map->dm_segs[seg].ds_addr & bmask) ==
			     (curaddr & bmask)))
				map->dm_segs[seg].ds_len += sgsize;
			else {
				if (++seg >= map->_dm_segcnt)
					break;
				map->dm_segs[seg].ds_addr = curaddr;
				map->dm_segs[seg].ds_len = sgsize;
			}
		}

		lastaddr = curaddr + sgsize;
		vaddr += sgsize;
		buflen -= sgsize;
	}

	*segp = seg;
	*lastaddrp = lastaddr;

	/*
	 * Did we fit?
	 */
	if (buflen != 0)
		return (EFBIG);		/* XXX better return value here? */
	return (0);
}

d643 4
a646 2
	paddr_t lastaddr;
	int seg, error;
d653 1
d655 24
a678 2
	if (size > map->_dm_size)
		return (EINVAL);
d680 3
a682 8
	seg = 0;
	lastaddr = 0;
	error = _bus_dmamap_load_buffer(NULL, map, addr, size, p, flags,
	    &lastaddr, &seg, 1);
	if (error == 0) {
		map->dm_mapsize = size;
		map->dm_nsegs = seg + 1;
	}
d688 1
a688 1
mbus_dmamap_load_mbuf(void *v, bus_dmamap_t map, struct mbuf *m0, int flags)
d690 1
a690 33
	paddr_t lastaddr;
	int seg, error, first;
	struct mbuf *m;

	map->dm_mapsize = 0;
	map->dm_nsegs = 0;

#ifdef DIAGNOSTIC
	if ((m0->m_flags & M_PKTHDR) == 0)
		panic("_bus_dmamap_load_mbuf: no packet header");
#endif  

	if (m0->m_pkthdr.len > map->_dm_size)
		return (EINVAL);

	first = 1;
	seg = 0;
	error = 0;
	lastaddr = 0;
	for (m = m0; m != NULL && error == 0; m = m->m_next) {
		/* XXX as we later can only flush by pa -- flush now */
		fdcache(HPPA_SID_KERNEL, (vaddr_t)m->m_data, m->m_len);
		error = _bus_dmamap_load_buffer(NULL, map, m->m_data, m->m_len,
		    NULL, flags, &lastaddr, &seg, first);
		first = 0;
	}
	if (error == 0) {
		map->dm_mapsize = m0->m_pkthdr.len;
		map->dm_nsegs = seg + 1;
		map->_dm_va = 0;	/* means sync by pa */
	}

	return (error);
d696 1
a696 50
	paddr_t lastaddr;
	int seg, i, error, first;
	bus_size_t minlen, resid;
	struct proc *p = NULL;
	struct iovec *iov;
	caddr_t addr;

	/*
	 * Make sure that on error condition we return "no valid mappings".
	 */
	map->dm_mapsize = 0;
	map->dm_nsegs = 0;

	resid = uio->uio_resid;
	iov = uio->uio_iov;

	if (resid > map->_dm_size)
		return (EINVAL);

	if (uio->uio_segflg == UIO_USERSPACE) {
		p = uio->uio_procp;
#ifdef DIAGNOSTIC
		if (p == NULL)
			panic("_bus_dmamap_load_uio: USERSPACE but no proc");
#endif
	}

	first = 1;
	seg = 0;
	error = 0;
	lastaddr = 0;
	for (i = 0; i < uio->uio_iovcnt && resid != 0 && error == 0; i++) {
		/*
		 * Now at the first iovec to load.  Load each iovec
		 * until we have exhausted the residual count.
		 */
		minlen = resid < iov[i].iov_len ? resid : iov[i].iov_len;
		addr = (caddr_t)iov[i].iov_base;

		error = _bus_dmamap_load_buffer(NULL, map, addr, minlen,
		    p, flags, &lastaddr, &seg, first);
		first = 0;

		resid -= minlen;
	}
	if (error == 0) {
		map->dm_mapsize = uio->uio_resid;
		map->dm_nsegs = seg + 1;
	}
	return (error);
d703 1
a703 24
	if (nsegs > map->_dm_segcnt || size > map->_dm_size)
		return (EINVAL);

	/*
	 * Make sure we don't cross any boundaries.
	 */
	if (map->_dm_boundary) {
		bus_addr_t bmask = ~(map->_dm_boundary - 1);
		int i;

		for (i = 0; i < nsegs; i++) {
			if (segs[i].ds_len > map->_dm_maxsegsz)
				return (EINVAL);
			if ((segs[i].ds_addr & bmask) !=
			    ((segs[i].ds_addr + segs[i].ds_len - 1) & bmask))
				return (EINVAL);
		}
	}

	bcopy(segs, map->dm_segs, nsegs * sizeof(*segs));
	map->dm_nsegs = nsegs;
	map->dm_mapsize = size;
	map->_dm_va = segs->ds_addr;
	return (0);
d707 1
a707 1
mbus_dmamap_sync(void *v, bus_dmamap_t map, bus_addr_t off, bus_size_t len,
d710 4
a713 26
	if ((off + len) > map->_dm_size)
		len = map->_dm_size - off;

	if (map->_dm_va) {
		/*
		 * cannot use purge since the data for dma is not
		 * guarantied to be aligned in any way
		 */
		fdcache(HPPA_SID_KERNEL, map->_dm_va + off, len);
	} else {
		/* this is an mbuf chain thus flush by segs */
		bus_dma_segment_t *ps = map->dm_segs,
		    *es = &map->dm_segs[map->dm_nsegs];

		for (; len && ps < es; ps++)
			if (off > ps->ds_len)
				off -= ps->ds_len;
			else {
				bus_size_t l = ps->ds_len - off;
				if (l > len)
					l = len;
				fdcache(HPPA_SID_KERNEL, ps->ds_addr + off, l);
				len -= l;
				off = 0;
			}
	}
d728 1
d734 1
a734 1
	    &pglist, 1, flags & BUS_DMA_NOWAIT))
d737 8
a744 2
	pg = TAILQ_FIRST(&pglist);
	segs[0].ds_addr = VM_PAGE_TO_PHYS(pg);
d748 3
a750 1
	for(; pg; pg = TAILQ_NEXT(pg, pageq))
d753 2
d763 1
a763 13
	struct pglist pglist;
	paddr_t pa, epa;

	TAILQ_INIT(&pglist);
	for(; nsegs--; segs++)
		for (pa = segs->ds_addr, epa = pa + segs->ds_len;
		     pa < epa; pa += PAGE_SIZE) {
			struct vm_page *pg = PHYS_TO_VM_PAGE(pa);
			if (!pg)
				panic("mbus_dmamem_free: no page for pa");
			TAILQ_INSERT_TAIL(&pglist, pg, pageq);
		}
	uvm_pglistfree(&pglist);
d818 2
a819 1
	struct mainbus_softc *sc = (struct mainbus_softc *)self;
d827 1
a827 1
	printf(" [flex %lx]\n", pdc_hpa.hpa & HPPA_FLEX_MASK);
d845 2
a850 14
#if NPOWER > 0
	/* get some power */
	bzero (&nca, sizeof(nca));
	nca.ca_name = "power";
	nca.ca_irq = -1;
	if (!pdc_call((iodcio_t)pdc, 0, PDC_SOFT_POWER,
	    PDC_SOFT_POWER_INFO, &pdc_power_info, 0)) {
		nca.ca_iot = &hppa_bustag;
		nca.ca_hpa = pdc_power_info.addr;
		nca.ca_hpamask = HPPA_IOSPACE;
	}
	config_found(self, &nca, mbprint);
#endif

d871 1
a871 1
	struct mainbus_softc *sc;
d886 2
a887 3
		printf("\"%s\" at %s (type %x, sv %x, hv %x)", ca->ca_name, pnp,
		    ca->ca_type.iodc_type, ca->ca_type.iodc_sv_model,
		    ca->ca_type.iodc_revision);
d890 1
a890 1
			printf(" offset %lx", ca->ca_hpa & ~ca->ca_hpamask);
d903 3
a905 3
	struct cfdata *cf = match;
	struct confargs *ca = aux;
	int ret;
d908 1
a908 1
		printf(">> hpa %lx off %lx cf_off %x\n",
@


1.9.2.10
log
@Merge with the trunk
@
text
@d4 1
a4 1
 * Copyright (c) 1998-2004 Michael Shalayeff
d15 5
d694 1
a694 1
			map->dm_segs[seg]._ds_va = vaddr;
a708 1
				map->dm_segs[seg]._ds_va = vaddr;
d779 2
d788 1
d875 1
a882 6
	bus_dma_segment_t *ps = map->dm_segs,
	    *es = &map->dm_segs[map->dm_nsegs];

	if (off >= map->_dm_size)
		return;

d886 23
a908 11
	for (; len && ps < es; ps++)
		if (off > ps->ds_len)
			off -= ps->ds_len;
		else {
			bus_size_t l = ps->ds_len - off;
			if (l > len)
				l = len;
			fdcache(HPPA_SID_KERNEL, ps->_ds_va + off, l);
			len -= l;
			off = 0;
		}
d932 1
a932 1
	segs[0]._ds_va = segs[0].ds_addr = VM_PAGE_TO_PHYS(pg);
@


1.8
log
@spaces and knf
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.7 1999/12/17 06:18:38 mickey Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998,1999 Michael Shalayeff
d75 1
a75 1
mbus_add_mapping(bus_addr_t bpa, bus_size_t size, int cacheable,
d83 2
a84 2
	printf("bus_mem_add_mapping(%x,%x,%scaceable,%p)\n",
	    bpa, size, cacheable?"":"non", bshp);
d100 7
d173 1
a173 1
			if (!cacheable)
d188 1
a188 1
    int cacheable, bus_space_handle_t *bshp)
d195 1
a195 1
	if ((error = mbus_add_mapping(bpa, size, cacheable, bshp))) {
d233 1
a233 1
	 bus_size_t align, bus_size_t boundary, int cacheable,
d246 1
a246 1
	if ((error = mbus_add_mapping(bpa, size, cacheable, bshp))) {
d608 2
a609 2
	            crr(mbus_rm_2), crr(mbus_rm_4), crr(mbus_rm_8),
	            cwr(mbus_wm_2), cwr(mbus_wm_4), cwr(mbus_wm_8),
d613 2
a614 2
	            crr(mbus_rr_2), crr(mbus_rr_4), crr(mbus_rr_8),
	            cwr(mbus_wr_2), cwr(mbus_wr_4), cwr(mbus_wr_8),
@


1.7
log
@inline uvm_pagealloc_contig, as art said it must die
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.6 1999/11/26 17:34:59 mickey Exp $	*/
d76 1
a76 1
	       bus_space_handle_t *bshp)
d84 1
a84 1
	      bpa, size, cacheable?"":"non", bshp);
d141 1
a141 1
			       flex, bmm[flex / 8]);
d175 1
a175 1
 
d181 1
a181 1
       int cacheable, bus_space_handle_t *bshp)
d219 1
a219 1
		       bpa, size);
d261 1
a261 1
	       bus_size_t size, bus_space_handle_t *nbshp)
d418 1
a418 1
		      bus_size_t o, u_int16_t*a, bus_size_t c));
d420 1
a420 1
		      bus_size_t o, u_int32_t*a, bus_size_t c));
d422 1
a422 1
		      bus_size_t o, u_int64_t*a, bus_size_t c));
d425 1
a425 1
		      bus_size_t o, const u_int16_t *a, bus_size_t c));
d427 1
a427 1
		      bus_size_t o, const u_int32_t *a, bus_size_t c));
d429 1
a429 1
		      bus_size_t o, const u_int64_t *a, bus_size_t c));
d548 1
a548 1
		*((volatile u_int8_t *)h1)++ = 
d559 1
a559 1
		*((volatile u_int16_t *)h1)++ = 
d570 1
a570 1
		*((volatile u_int32_t *)h1)++ = 
d581 1
a581 1
		*((volatile u_int64_t *)h1)++ = 
d665 1
a665 1
		     int nsegs, bus_size_t size, int flags)
d768 1
a768 1
mbmatch(parent, cfdata, aux)   
d800 1
a800 1
	/* 
d848 1
a848 1
		       ca->ca_type.iodc_type, ca->ca_type.iodc_sv_model);
@


1.6
log
@fix types for raw routines, also fix macros in bus.h for raw multi; 10x niklas@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.5 1999/11/25 18:25:31 mickey Exp $	*/
d146 1
a146 1
		register vaddr_t va;
d158 1
d171 3
d687 2
a689 1
	paddr_t spa, epa;
d693 9
a701 3
	if (!(va = uvm_pagealloc_contig(size, VM_MIN_KERNEL_ADDRESS,
					VM_MAX_KERNEL_ADDRESS, NBPG)))
		return (ENOMEM);
d707 9
a715 3
	/* XXX for now */
	for (epa = size + (spa = kvtop((caddr_t)va)); spa < epa; spa += NBPG)
		pmap_changebit(spa, TLB_UNCACHEABLE, 0);
a717 1

d723 1
a723 1
	uvm_km_free(kmem_map, segs[0].ds_addr, M_DEVBUF);
@


1.5
log
@do bus stuff through pointers, native devices use memory ops where possible
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.4 1999/04/20 20:43:25 mickey Exp $	*/
d318 1
a318 1
mbus_rm_1(void *v, bus_space_handle_t h, bus_size_t o, u_int8_t *a, size_t c)
d326 1
a326 1
mbus_rm_2(void *v, bus_space_handle_t h, bus_size_t o, u_int16_t *a, size_t c)
d334 1
a334 1
mbus_rm_4(void *v, bus_space_handle_t h, bus_size_t o, u_int32_t *a, size_t c)
d342 1
a342 1
mbus_rm_8(void *v, bus_space_handle_t h, bus_size_t o, u_int64_t *a, size_t c)
d350 1
a350 1
mbus_wm_1(void *v, bus_space_handle_t h, bus_size_t o, const u_int8_t *a, size_t c)
d358 1
a358 1
mbus_wm_2(void *v, bus_space_handle_t h, bus_size_t o, const u_int16_t *a, size_t c)
d366 1
a366 1
mbus_wm_4(void *v, bus_space_handle_t h, bus_size_t o, const u_int32_t *a, size_t c)
d374 1
a374 1
mbus_wm_8(void *v, bus_space_handle_t h, bus_size_t o, const u_int64_t *a, size_t c)
d382 1
a382 1
mbus_sm_1(void *v, bus_space_handle_t h, bus_size_t o, u_int8_t vv, size_t c)
d390 1
a390 1
mbus_sm_2(void *v, bus_space_handle_t h, bus_size_t o, u_int16_t vv, size_t c)
d398 1
a398 1
mbus_sm_4(void *v, bus_space_handle_t h, bus_size_t o, u_int32_t vv, size_t c)
d406 1
a406 1
mbus_sm_8(void *v, bus_space_handle_t h, bus_size_t o, u_int64_t vv, size_t c)
d414 1
a414 1
		      bus_size_t o, u_int16_t*a, size_t c));
d416 1
a416 1
		      bus_size_t o, u_int32_t*a, size_t c));
d418 1
a418 1
		      bus_size_t o, u_int64_t*a, size_t c));
d421 1
a421 1
		      bus_size_t o, const u_int16_t *a, size_t c));
d423 1
a423 1
		      bus_size_t o, const u_int32_t *a, size_t c));
d425 1
a425 1
		      bus_size_t o, const u_int64_t *a, size_t c));
d428 1
a428 1
mbus_rr_1(void *v, bus_space_handle_t h, bus_size_t o, u_int8_t *a, size_t c)
d436 1
a436 1
mbus_rr_2(void *v, bus_space_handle_t h, bus_size_t o, u_int16_t *a, size_t c)
d444 1
a444 1
mbus_rr_4(void *v, bus_space_handle_t h, bus_size_t o, u_int32_t *a, size_t c)
d452 1
a452 1
mbus_rr_8(void *v, bus_space_handle_t h, bus_size_t o, u_int64_t *a, size_t c)
d460 1
a460 1
mbus_wr_1(void *v, bus_space_handle_t h, bus_size_t o, const u_int8_t *a, size_t c)
d468 1
a468 1
mbus_wr_2(void *v, bus_space_handle_t h, bus_size_t o, const u_int16_t *a, size_t c)
d476 1
a476 1
mbus_wr_4(void *v, bus_space_handle_t h, bus_size_t o, const u_int32_t *a, size_t c)
d484 1
a484 1
mbus_wr_8(void *v, bus_space_handle_t h, bus_size_t o, const u_int64_t *a, size_t c)
d492 1
a492 1
		   bus_size_t o, u_int16_t *a, size_t c));
d494 1
a494 1
		   bus_size_t o, u_int32_t *a, size_t c));
d496 1
a496 1
		   bus_size_t o, u_int64_t *a, size_t c));
d499 1
a499 1
		   bus_size_t o, const u_int16_t *a, size_t c));
d501 1
a501 1
		   bus_size_t o, const u_int32_t *a, size_t c));
d503 1
a503 1
		   bus_size_t o, const u_int64_t *a, size_t c));
d506 1
a506 1
mbus_sr_1(void *v, bus_space_handle_t h, bus_size_t o, u_int8_t vv, size_t c)
d514 1
a514 1
mbus_sr_2(void *v, bus_space_handle_t h, bus_size_t o, u_int16_t vv, size_t c)
d522 1
a522 1
mbus_sr_4(void *v, bus_space_handle_t h, bus_size_t o, u_int32_t vv, size_t c)
d530 1
a530 1
mbus_sr_8(void *v, bus_space_handle_t h, bus_size_t o, u_int64_t vv, size_t c)
d582 4
d597 2
a598 2
	            mbus_rm_2, mbus_rm_4, mbus_rm_8,
	            mbus_wm_2, mbus_wm_4, mbus_wm_8,
d602 2
a603 2
	            mbus_rr_2, mbus_rr_4, mbus_rr_8,
	            mbus_wr_2, mbus_wr_4, mbus_wr_8,
@


1.4
log
@map mainbus space
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.3 1999/02/25 19:16:02 mickey Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998 Michael Shalayeff
d17 1
a17 1
 *	This product includes software developed by Michael Shalayeff.
d24 8
a31 7
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d34 3
d41 7
d70 667
a736 1
struct hppa_bus_dma_tag hppa_dmatag = {
d738 7
a744 14
	_dmamap_create,
	_dmamap_destroy,
	_dmamap_load,
	_dmamap_load_mbuf,
	_dmamap_load_uio,
	_dmamap_load_raw,
	_dmamap_unload,
	_dmamap_sync,

	_dmamem_alloc,
	_dmamem_free,
	_dmamem_map,
	_dmamem_unmap,
	_dmamem_mmap
d756 1
a756 1
	if (cf->cf_unit > 0)
d777 1
a777 1
	if (bus_space_map(0, pdc_hpa.hpa, IOMOD_HPASIZE, 0, &ioh))
d793 1
d800 1
@


1.3
log
@add irq and dma glues (the green one)
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.2 1998/11/30 21:38:01 mickey Exp $	*/
d101 1
d106 3
@


1.2
log
@zero confargs before device scan, less verbose printing for probed device
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.1 1998/10/30 18:54:11 mickey Exp $	*/
d44 2
d59 18
d98 2
d102 12
a113 1
	printf("\n");
d118 2
a119 1
	nca.ca_mod = -1;
d124 2
a125 1
	nca.ca_mod = -1;
d129 14
d153 5
a157 2
	if (ca->ca_mod >= 0)
		printf(" mod %d", ca->ca_mod);
d161 17
@


1.1
log
@some mainbus
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d83 1
d88 1
d104 1
a104 1
	if (ca->ca_mod >= 0) {
a105 3
		if (!pnp)
			printf(" \"%s\"", ca->ca_name);
	}
@

