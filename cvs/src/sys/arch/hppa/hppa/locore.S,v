head	1.196;
access;
symbols
	OPENBSD_6_1:1.195.0.6
	OPENBSD_6_1_BASE:1.195
	OPENBSD_6_0:1.195.0.2
	OPENBSD_6_0_BASE:1.195
	OPENBSD_5_9:1.193.0.4
	OPENBSD_5_9_BASE:1.193
	OPENBSD_5_8:1.193.0.6
	OPENBSD_5_8_BASE:1.193
	OPENBSD_5_7:1.193.0.2
	OPENBSD_5_7_BASE:1.193
	OPENBSD_5_6:1.190.0.4
	OPENBSD_5_6_BASE:1.190
	OPENBSD_5_5:1.189.0.12
	OPENBSD_5_5_BASE:1.189
	OPENBSD_5_4:1.189.0.8
	OPENBSD_5_4_BASE:1.189
	OPENBSD_5_3:1.189.0.6
	OPENBSD_5_3_BASE:1.189
	OPENBSD_5_2:1.189.0.4
	OPENBSD_5_2_BASE:1.189
	OPENBSD_5_1_BASE:1.189
	OPENBSD_5_1:1.189.0.2
	OPENBSD_5_0:1.186.0.2
	OPENBSD_5_0_BASE:1.186
	OPENBSD_4_9:1.184.0.2
	OPENBSD_4_9_BASE:1.184
	OPENBSD_4_8:1.178.0.2
	OPENBSD_4_8_BASE:1.178
	OPENBSD_4_7:1.164.0.2
	OPENBSD_4_7_BASE:1.164
	OPENBSD_4_6:1.160.0.6
	OPENBSD_4_6_BASE:1.160
	OPENBSD_4_5:1.160.0.2
	OPENBSD_4_5_BASE:1.160
	OPENBSD_4_4:1.158.0.2
	OPENBSD_4_4_BASE:1.158
	OPENBSD_4_3:1.156.0.2
	OPENBSD_4_3_BASE:1.156
	OPENBSD_4_2:1.155.0.2
	OPENBSD_4_2_BASE:1.155
	OPENBSD_4_1:1.152.0.6
	OPENBSD_4_1_BASE:1.152
	OPENBSD_4_0:1.152.0.4
	OPENBSD_4_0_BASE:1.152
	OPENBSD_3_9:1.152.0.2
	OPENBSD_3_9_BASE:1.152
	OPENBSD_3_8:1.151.0.2
	OPENBSD_3_8_BASE:1.151
	OPENBSD_3_7:1.146.0.2
	OPENBSD_3_7_BASE:1.146
	OPENBSD_3_6:1.136.0.2
	OPENBSD_3_6_BASE:1.136
	SMP_SYNC_A:1.133
	SMP_SYNC_B:1.133
	OPENBSD_3_5:1.122.0.2
	OPENBSD_3_5_BASE:1.122
	OPENBSD_3_4:1.111.0.2
	OPENBSD_3_4_BASE:1.111
	UBC_SYNC_A:1.108
	OPENBSD_3_3:1.105.0.2
	OPENBSD_3_3_BASE:1.105
	OPENBSD_3_2:1.89.0.2
	OPENBSD_3_2_BASE:1.89
	OPENBSD_3_1:1.64.0.2
	OPENBSD_3_1_BASE:1.64
	UBC_SYNC_B:1.94
	UBC:1.46.0.4
	UBC_BASE:1.46
	OPENBSD_3_0:1.46.0.2
	OPENBSD_3_0_BASE:1.46
	OPENBSD_2_9:1.44.0.2
	OPENBSD_2_9_BASE:1.44
	OPENBSD_2_8:1.37.0.2
	OPENBSD_2_8_BASE:1.37
	OPENBSD_2_7:1.32.0.2
	OPENBSD_2_7_BASE:1.32
	SMP:1.28.0.2
	SMP_BASE:1.28
	kame_19991208:1.21
	OPENBSD_2_6:1.20.0.2
	OPENBSD_2_6_BASE:1.20
	OPENBSD_2_5:1.5.0.2
	OPENBSD_2_5_BASE:1.5;
locks; strict;
comment	@# @;


1.196
date	2017.04.30.16.45.45;	author mpi;	state Exp;
branches;
next	1.195;
commitid	2Gtqjzrin9LL2yHk;

1.195
date	2016.05.23.20.11.49;	author deraadt;	state Exp;
branches;
next	1.194;
commitid	0oWSDXhpPUnuLpPD;

1.194
date	2016.05.10.18.39.44;	author deraadt;	state Exp;
branches;
next	1.193;
commitid	qfOifNidEGDB2jL1;

1.193
date	2014.10.23.16.57.45;	author miod;	state Exp;
branches;
next	1.192;
commitid	qauDGov2q6wKwrNg;

1.192
date	2014.10.23.16.51.30;	author miod;	state Exp;
branches;
next	1.191;
commitid	peMfZtZ9eSC58WDG;

1.191
date	2014.10.14.17.25.48;	author miod;	state Exp;
branches;
next	1.190;
commitid	15zIxQDVAcuE7ZUx;

1.190
date	2014.05.30.13.55.58;	author kettenis;	state Exp;
branches;
next	1.189;

1.189
date	2011.12.30.12.30.59;	author miod;	state Exp;
branches;
next	1.188;

1.188
date	2011.11.08.15.39.50;	author kettenis;	state Exp;
branches;
next	1.187;

1.187
date	2011.10.12.18.30.09;	author miod;	state Exp;
branches;
next	1.186;

1.186
date	2011.05.05.20.50.43;	author kettenis;	state Exp;
branches;
next	1.185;

1.185
date	2011.04.16.21.55.49;	author kettenis;	state Exp;
branches;
next	1.184;

1.184
date	2010.12.30.15.10.54;	author kettenis;	state Exp;
branches;
next	1.183;

1.183
date	2010.12.30.14.30.12;	author jsing;	state Exp;
branches;
next	1.182;

1.182
date	2010.12.21.14.56.23;	author claudio;	state Exp;
branches;
next	1.181;

1.181
date	2010.12.10.09.13.02;	author kettenis;	state Exp;
branches;
next	1.180;

1.180
date	2010.11.28.20.09.14;	author miod;	state Exp;
branches;
next	1.179;

1.179
date	2010.08.18.21.01.14;	author jasper;	state Exp;
branches;
next	1.178;

1.178
date	2010.08.01.14.20.41;	author kettenis;	state Exp;
branches;
next	1.177;

1.177
date	2010.07.01.23.20.13;	author jsing;	state Exp;
branches;
next	1.176;

1.176
date	2010.07.01.05.33.32;	author jsing;	state Exp;
branches;
next	1.175;

1.175
date	2010.06.30.20.38.49;	author tedu;	state Exp;
branches;
next	1.174;

1.174
date	2010.06.29.20.30.31;	author guenther;	state Exp;
branches;
next	1.173;

1.173
date	2010.06.29.00.50.40;	author jsing;	state Exp;
branches;
next	1.172;

1.172
date	2010.06.03.15.48.58;	author jsing;	state Exp;
branches;
next	1.171;

1.171
date	2010.05.27.11.52.23;	author jsing;	state Exp;
branches;
next	1.170;

1.170
date	2010.05.19.13.10.24;	author jsing;	state Exp;
branches;
next	1.169;

1.169
date	2010.05.16.14.54.43;	author jsing;	state Exp;
branches;
next	1.168;

1.168
date	2010.04.19.16.32.53;	author jsing;	state Exp;
branches;
next	1.167;

1.167
date	2010.04.19.14.05.04;	author jsing;	state Exp;
branches;
next	1.166;

1.166
date	2010.04.01.12.30.38;	author jsing;	state Exp;
branches;
next	1.165;

1.165
date	2010.03.27.17.46.59;	author deraadt;	state Exp;
branches;
next	1.164;

1.164
date	2009.12.31.12.52.35;	author jsing;	state Exp;
branches;
next	1.163;

1.163
date	2009.12.29.16.37.10;	author jsing;	state Exp;
branches;
next	1.162;

1.162
date	2009.07.29.20.00.47;	author kettenis;	state Exp;
branches;
next	1.161;

1.161
date	2009.07.29.18.31.11;	author kettenis;	state Exp;
branches;
next	1.160;

1.160
date	2009.02.14.19.03.50;	author kettenis;	state Exp;
branches;
next	1.159;

1.159
date	2009.02.08.18.33.29;	author miod;	state Exp;
branches;
next	1.158;

1.158
date	2008.07.28.19.08.46;	author miod;	state Exp;
branches;
next	1.157;

1.157
date	2008.05.21.19.42.05;	author miod;	state Exp;
branches;
next	1.156;

1.156
date	2007.10.10.15.53.51;	author art;	state Exp;
branches;
next	1.155;

1.155
date	2007.07.20.22.09.23;	author kettenis;	state Exp;
branches;
next	1.154;

1.154
date	2007.05.26.00.36.03;	author krw;	state Exp;
branches;
next	1.153;

1.153
date	2007.05.14.19.54.21;	author martin;	state Exp;
branches;
next	1.152;

1.152
date	2006.01.10.01.17.28;	author martin;	state Exp;
branches;
next	1.151;

1.151
date	2005.05.26.03.42.43;	author mickey;	state Exp;
branches;
next	1.150;

1.150
date	2005.04.21.04.39.35;	author mickey;	state Exp;
branches;
next	1.149;

1.149
date	2005.04.07.00.24.57;	author mickey;	state Exp;
branches;
next	1.148;

1.148
date	2005.04.07.00.21.51;	author mickey;	state Exp;
branches;
next	1.147;

1.147
date	2005.03.26.20.04.37;	author mickey;	state Exp;
branches;
next	1.146;

1.146
date	2005.03.16.13.20.43;	author mickey;	state Exp;
branches;
next	1.145;

1.145
date	2005.01.23.16.28.29;	author mickey;	state Exp;
branches;
next	1.144;

1.144
date	2005.01.17.19.01.00;	author mickey;	state Exp;
branches;
next	1.143;

1.143
date	2004.12.24.22.50.29;	author miod;	state Exp;
branches;
next	1.142;

1.142
date	2004.10.26.20.18.01;	author mickey;	state Exp;
branches;
next	1.141;

1.141
date	2004.09.18.07.21.27;	author mickey;	state Exp;
branches;
next	1.140;

1.140
date	2004.09.15.21.32.43;	author mickey;	state Exp;
branches;
next	1.139;

1.139
date	2004.09.15.00.25.43;	author mickey;	state Exp;
branches;
next	1.138;

1.138
date	2004.09.14.23.39.32;	author mickey;	state Exp;
branches;
next	1.137;

1.137
date	2004.09.14.22.44.58;	author mickey;	state Exp;
branches;
next	1.136;

1.136
date	2004.06.30.21.01.08;	author mickey;	state Exp;
branches;
next	1.135;

1.135
date	2004.06.30.18.18.54;	author mickey;	state Exp;
branches;
next	1.134;

1.134
date	2004.06.13.21.49.14;	author niklas;	state Exp;
branches;
next	1.133;

1.133
date	2004.06.08.22.00.25;	author mickey;	state Exp;
branches;
next	1.132;

1.132
date	2004.05.25.22.14.02;	author mickey;	state Exp;
branches;
next	1.131;

1.131
date	2004.05.05.02.18.43;	author mickey;	state Exp;
branches;
next	1.130;

1.130
date	2004.05.04.23.53.07;	author mickey;	state Exp;
branches;
next	1.129;

1.129
date	2004.04.21.22.25.31;	author mickey;	state Exp;
branches;
next	1.128;

1.128
date	2004.04.08.17.14.50;	author mickey;	state Exp;
branches;
next	1.127;

1.127
date	2004.04.08.17.10.18;	author mickey;	state Exp;
branches;
next	1.126;

1.126
date	2004.04.07.18.24.19;	author mickey;	state Exp;
branches;
next	1.125;

1.125
date	2004.04.06.18.33.50;	author mickey;	state Exp;
branches;
next	1.124;

1.124
date	2004.04.06.18.25.39;	author mickey;	state Exp;
branches;
next	1.123;

1.123
date	2004.04.02.20.56.31;	author mickey;	state Exp;
branches;
next	1.122;

1.122
date	2004.03.09.04.43.55;	author mickey;	state Exp;
branches;
next	1.121;

1.121
date	2003.12.17.15.35.40;	author miod;	state Exp;
branches;
next	1.120;

1.120
date	2003.11.24.19.27.03;	author mickey;	state Exp;
branches;
next	1.119;

1.119
date	2003.11.07.18.43.25;	author mickey;	state Exp;
branches;
next	1.118;

1.118
date	2003.10.16.03.45.07;	author mickey;	state Exp;
branches;
next	1.117;

1.117
date	2003.10.15.19.54.13;	author mickey;	state Exp;
branches;
next	1.116;

1.116
date	2003.10.15.18.54.55;	author mickey;	state Exp;
branches;
next	1.115;

1.115
date	2003.10.05.14.13.28;	author mickey;	state Exp;
branches;
next	1.114;

1.114
date	2003.09.29.19.23.02;	author mickey;	state Exp;
branches;
next	1.113;

1.113
date	2003.09.26.00.07.05;	author mickey;	state Exp;
branches;
next	1.112;

1.112
date	2003.09.25.22.17.40;	author mickey;	state Exp;
branches;
next	1.111;

1.111
date	2003.08.07.19.23.52;	author mickey;	state Exp;
branches;
next	1.110;

1.110
date	2003.08.05.02.04.58;	author mickey;	state Exp;
branches;
next	1.109;

1.109
date	2003.07.15.18.15.41;	author mickey;	state Exp;
branches;
next	1.108;

1.108
date	2003.05.07.18.48.12;	author mickey;	state Exp;
branches;
next	1.107;

1.107
date	2003.05.07.18.23.14;	author mickey;	state Exp;
branches;
next	1.106;

1.106
date	2003.04.07.16.20.38;	author mickey;	state Exp;
branches;
next	1.105;

1.105
date	2003.02.18.21.06.43;	author mickey;	state Exp;
branches;
next	1.104;

1.104
date	2003.02.12.00.43.08;	author mickey;	state Exp;
branches;
next	1.103;

1.103
date	2003.01.15.12.33.34;	author mickey;	state Exp;
branches;
next	1.102;

1.102
date	2003.01.14.12.09.53;	author mickey;	state Exp;
branches;
next	1.101;

1.101
date	2003.01.09.22.27.08;	author miod;	state Exp;
branches;
next	1.100;

1.100
date	2002.12.17.22.46.31;	author miod;	state Exp;
branches;
next	1.99;

1.99
date	2002.12.17.21.54.25;	author mickey;	state Exp;
branches;
next	1.98;

1.98
date	2002.12.09.18.36.33;	author mickey;	state Exp;
branches;
next	1.97;

1.97
date	2002.11.27.21.47.14;	author mickey;	state Exp;
branches;
next	1.96;

1.96
date	2002.11.14.01.41.55;	author mickey;	state Exp;
branches;
next	1.95;

1.95
date	2002.10.29.03.03.38;	author mickey;	state Exp;
branches;
next	1.94;

1.94
date	2002.10.25.22.02.19;	author mickey;	state Exp;
branches;
next	1.93;

1.93
date	2002.10.17.20.35.24;	author mickey;	state Exp;
branches;
next	1.92;

1.92
date	2002.10.07.15.40.39;	author mickey;	state Exp;
branches;
next	1.91;

1.91
date	2002.10.07.15.32.37;	author mickey;	state Exp;
branches;
next	1.90;

1.90
date	2002.10.07.14.38.34;	author mickey;	state Exp;
branches;
next	1.89;

1.89
date	2002.09.15.09.39.36;	author mickey;	state Exp;
branches;
next	1.88;

1.88
date	2002.09.15.09.37.18;	author mickey;	state Exp;
branches;
next	1.87;

1.87
date	2002.09.12.05.31.34;	author mickey;	state Exp;
branches;
next	1.86;

1.86
date	2002.09.10.22.43.49;	author mickey;	state Exp;
branches;
next	1.85;

1.85
date	2002.09.10.21.20.23;	author mickey;	state Exp;
branches;
next	1.84;

1.84
date	2002.09.09.18.32.27;	author mickey;	state Exp;
branches;
next	1.83;

1.83
date	2002.09.05.21.37.18;	author mickey;	state Exp;
branches;
next	1.82;

1.82
date	2002.09.05.18.15.23;	author mickey;	state Exp;
branches;
next	1.81;

1.81
date	2002.08.27.16.29.22;	author mickey;	state Exp;
branches;
next	1.80;

1.80
date	2002.08.13.05.27.44;	author mickey;	state Exp;
branches;
next	1.79;

1.79
date	2002.08.03.20.56.42;	author mickey;	state Exp;
branches;
next	1.78;

1.78
date	2002.08.03.20.23.00;	author mickey;	state Exp;
branches;
next	1.77;

1.77
date	2002.08.03.20.19.41;	author mickey;	state Exp;
branches;
next	1.76;

1.76
date	2002.08.03.20.07.58;	author mickey;	state Exp;
branches;
next	1.75;

1.75
date	2002.08.03.19.07.53;	author mickey;	state Exp;
branches;
next	1.74;

1.74
date	2002.08.03.19.04.24;	author mickey;	state Exp;
branches;
next	1.73;

1.73
date	2002.07.25.04.49.53;	author mickey;	state Exp;
branches;
next	1.72;

1.72
date	2002.07.18.14.00.53;	author mickey;	state Exp;
branches;
next	1.71;

1.71
date	2002.07.18.04.35.03;	author mickey;	state Exp;
branches;
next	1.70;

1.70
date	2002.06.09.02.50.29;	author mickey;	state Exp;
branches;
next	1.69;

1.69
date	2002.05.20.07.59.11;	author mickey;	state Exp;
branches;
next	1.68;

1.68
date	2002.05.20.03.46.53;	author mickey;	state Exp;
branches;
next	1.67;

1.67
date	2002.05.20.02.26.40;	author mickey;	state Exp;
branches;
next	1.66;

1.66
date	2002.05.14.02.16.27;	author mickey;	state Exp;
branches;
next	1.65;

1.65
date	2002.05.09.17.20.09;	author mickey;	state Exp;
branches;
next	1.64;

1.64
date	2002.04.02.17.54.27;	author mickey;	state Exp;
branches;
next	1.63;

1.63
date	2002.04.01.16.19.58;	author mickey;	state Exp;
branches;
next	1.62;

1.62
date	2002.03.24.07.52.24;	author mickey;	state Exp;
branches;
next	1.61;

1.61
date	2002.03.19.19.03.20;	author mickey;	state Exp;
branches;
next	1.60;

1.60
date	2002.03.15.21.44.18;	author mickey;	state Exp;
branches;
next	1.59;

1.59
date	2002.03.15.19.53.49;	author mickey;	state Exp;
branches;
next	1.58;

1.58
date	2002.03.12.21.36.47;	author mickey;	state Exp;
branches;
next	1.57;

1.57
date	2002.03.12.07.35.06;	author mickey;	state Exp;
branches;
next	1.56;

1.56
date	2002.03.08.08.56.11;	author mickey;	state Exp;
branches;
next	1.55;

1.55
date	2002.03.08.08.34.03;	author mickey;	state Exp;
branches;
next	1.54;

1.54
date	2002.02.20.19.33.01;	author mickey;	state Exp;
branches;
next	1.53;

1.53
date	2002.02.12.05.23.27;	author mickey;	state Exp;
branches;
next	1.52;

1.52
date	2002.02.11.21.29.37;	author mickey;	state Exp;
branches;
next	1.51;

1.51
date	2002.02.11.19.42.11;	author mickey;	state Exp;
branches;
next	1.50;

1.50
date	2002.02.06.19.37.02;	author mickey;	state Exp;
branches;
next	1.49;

1.49
date	2002.02.04.19.52.21;	author mickey;	state Exp;
branches;
next	1.48;

1.48
date	2002.02.03.01.30.38;	author mickey;	state Exp;
branches;
next	1.47;

1.47
date	2002.02.02.21.14.03;	author mickey;	state Exp;
branches;
next	1.46;

1.46
date	2001.09.20.18.33.03;	author mickey;	state Exp;
branches
	1.46.4.1;
next	1.45;

1.45
date	2001.09.16.14.28.43;	author miod;	state Exp;
branches;
next	1.44;

1.44
date	2001.03.29.02.18.44;	author mickey;	state Exp;
branches;
next	1.43;

1.43
date	2001.03.29.00.03.34;	author mickey;	state Exp;
branches;
next	1.42;

1.42
date	2001.03.28.20.58.03;	author mickey;	state Exp;
branches;
next	1.41;

1.41
date	2001.03.28.18.24.51;	author mickey;	state Exp;
branches;
next	1.40;

1.40
date	2001.03.22.23.40.52;	author mickey;	state Exp;
branches;
next	1.39;

1.39
date	2001.02.26.22.19.17;	author mickey;	state Exp;
branches;
next	1.38;

1.38
date	2001.02.23.22.54.32;	author mickey;	state Exp;
branches;
next	1.37;

1.37
date	2000.08.15.20.12.15;	author mickey;	state Exp;
branches;
next	1.36;

1.36
date	2000.08.15.19.56.17;	author mickey;	state Exp;
branches;
next	1.35;

1.35
date	2000.07.02.02.41.57;	author mickey;	state Exp;
branches;
next	1.34;

1.34
date	2000.06.05.12.58.29;	author art;	state Exp;
branches;
next	1.33;

1.33
date	2000.05.15.17.22.39;	author mickey;	state Exp;
branches;
next	1.32;

1.32
date	2000.04.27.18.00.11;	author mickey;	state Exp;
branches;
next	1.31;

1.31
date	2000.03.23.20.25.40;	author mickey;	state Exp;
branches;
next	1.30;

1.30
date	2000.03.06.03.03.52;	author mickey;	state Exp;
branches;
next	1.29;

1.29
date	2000.03.06.02.21.01;	author mickey;	state Exp;
branches;
next	1.28;

1.28
date	2000.02.10.15.16.59;	author mickey;	state Exp;
branches
	1.28.2.1;
next	1.27;

1.27
date	2000.01.25.22.11.38;	author mickey;	state Exp;
branches;
next	1.26;

1.26
date	2000.01.12.05.55.56;	author mickey;	state Exp;
branches;
next	1.25;

1.25
date	2000.01.12.04.44.14;	author mickey;	state Exp;
branches;
next	1.24;

1.24
date	2000.01.11.20.27.57;	author mickey;	state Exp;
branches;
next	1.23;

1.23
date	99.12.31.09.07.10;	author mickey;	state Exp;
branches;
next	1.22;

1.22
date	99.12.12.03.31.23;	author mickey;	state Exp;
branches;
next	1.21;

1.21
date	99.11.25.18.47.45;	author mickey;	state Exp;
branches;
next	1.20;

1.20
date	99.09.20.21.40.53;	author mickey;	state Exp;
branches;
next	1.19;

1.19
date	99.08.14.03.11.31;	author mickey;	state Exp;
branches;
next	1.18;

1.18
date	99.08.03.15.48.18;	author mickey;	state Exp;
branches;
next	1.17;

1.17
date	99.07.21.07.37.19;	author mickey;	state Exp;
branches;
next	1.16;

1.16
date	99.07.18.04.42.28;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	99.07.08.16.14.50;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	99.06.24.01.19.16;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	99.06.22.17.56.05;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	99.06.22.17.46.38;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	99.06.18.05.19.52;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	99.06.12.17.35.10;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	99.05.21.23.19.17;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	99.05.21.17.06.56;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	99.05.02.03.42.42;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	99.04.20.20.36.06;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	99.02.25.19.22.50;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	99.02.17.22.29.19;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	99.01.20.19.32.02;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	99.01.16.07.53.02;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	98.12.05.17.44.48;	author mickey;	state Exp;
branches;
next	;

1.28.2.1
date	2000.03.24.09.07.29;	author niklas;	state Exp;
branches;
next	1.28.2.2;

1.28.2.2
date	2001.04.18.16.06.12;	author niklas;	state Exp;
branches;
next	1.28.2.3;

1.28.2.3
date	2001.10.31.02.52.47;	author nate;	state Exp;
branches;
next	1.28.2.4;

1.28.2.4
date	2002.03.06.00.57.22;	author niklas;	state Exp;
branches;
next	1.28.2.5;

1.28.2.5
date	2002.03.28.10.19.25;	author niklas;	state Exp;
branches;
next	1.28.2.6;

1.28.2.6
date	2003.03.27.23.26.53;	author niklas;	state Exp;
branches;
next	1.28.2.7;

1.28.2.7
date	2003.05.13.19.41.03;	author ho;	state Exp;
branches;
next	1.28.2.8;

1.28.2.8
date	2004.02.19.10.48.40;	author niklas;	state Exp;
branches;
next	1.28.2.9;

1.28.2.9
date	2004.06.05.23.10.48;	author niklas;	state Exp;
branches;
next	1.28.2.10;

1.28.2.10
date	2004.06.07.18.46.50;	author tedu;	state Exp;
branches;
next	1.28.2.11;

1.28.2.11
date	2004.06.10.11.40.23;	author niklas;	state Exp;
branches;
next	;

1.46.4.1
date	2002.06.11.03.35.37;	author art;	state Exp;
branches;
next	1.46.4.2;

1.46.4.2
date	2002.10.29.00.28.02;	author art;	state Exp;
branches;
next	1.46.4.3;

1.46.4.3
date	2003.05.19.21.49.41;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.196
log
@Rename Debugger() into db_enter().

Using a name with the 'db_' prefix makes it invisible from the dynamic
profiler.

ok deraadt@@, kettenis@@, visa@@
@
text
@/*	$OpenBSD: locore.S,v 1.195 2016/05/23 20:11:49 deraadt Exp $	*/

/*
 * Copyright (c) 1998-2004 Michael Shalayeff
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR OR HIS RELATIVES BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Portitions of this file are derived from other sources, see
 * the copyrights and acknowledgements below.
 */
/*
 *  (c) Copyright 1988 HEWLETT-PACKARD COMPANY
 *
 *  To anyone who acknowledges that this file is provided "AS IS"
 *  without any express or implied warranty:
 *      permission to use, copy, modify, and distribute this file
 *  for any purpose is hereby granted without fee, provided that
 *  the above copyright notice and this notice appears in all
 *  copies, and that the name of Hewlett-Packard Company not be
 *  used in advertising or publicity pertaining to distribution
 *  of the software without specific, written prior permission.
 *  Hewlett-Packard Company makes no representations about the
 *  suitability of this software for any purpose.
 */
/*
 * Copyright (c) 1990,1991,1992,1994 The University of Utah and
 * the Computer Systems Laboratory (CSL).  All rights reserved.
 *
 * Permission to use, copy, modify and distribute this software is hereby
 * granted provided that (1) source code retains these copyright, permission,
 * and disclaimer notices, and (2) redistributions including binaries
 * reproduce the notices in supporting documentation, and (3) all advertising
 * materials mentioning features or use of this software display the following
 * acknowledgement: ``This product includes software developed by the
 * Computer Systems Laboratory at the University of Utah.''
 *
 * THE UNIVERSITY OF UTAH AND CSL ALLOW FREE USE OF THIS SOFTWARE IN ITS "AS
 * IS" CONDITION.  THE UNIVERSITY OF UTAH AND CSL DISCLAIM ANY LIABILITY OF
 * ANY KIND FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * CSL requests users of this software to return to csl-dist@@cs.utah.edu any
 * improvements that they make and grant CSL redistribution rights.
 *
 *	Utah $Hdr: locore.s 1.63 95/01/20$
 */

#include <sys/reboot.h>
#include <machine/param.h>
#include <machine/asm.h>
#include <machine/psl.h>
#include <machine/trap.h>
#include <machine/iomod.h>
#include <machine/pdc.h>
#include <machine/frame.h>
#include <machine/reg.h>
#include "assym.h"

/*
 * hv-specific instructions
 */
#define	DR_PAGE0	.word	0x14001200
#define	DR_PAGE1	.word	0x14001240
#define	MTCPU_T(x,t)	.word	0x14001600 | ((t) << 21) | ((x) << 16)
#define	MFCPU_T(r,x)	.word	0x14001a00 | ((r) << 21) | ((x) << 16)
#define	MTCPU_C(x,t)	.word	0x14000240 | ((t) << 21) | ((x) << 16)
#define	MFCPU_C(r,x)	.word	0x14000600 | ((r) << 21) | ((x) << 16)
#define	MFCPU_U(r,x)	.word	0x140008a0 | ((r) << 21) | ((x))
#define	MTCPU_U(x,r)	.word	0x14001840 | ((r) << 21) | ((x) << 16)

	.import	$global$, data
	.import pdc, data
	.import	boothowto, data
	.import	bootdev, data
	.import	esym, data
	.import cpu_info, data
	.import	proc0, data
	.import	proc0paddr, data
	.import proc0fpstate, data
	.import	panic, code

#define	EMRG_STACKSIZE	(1*NBPG)
#define	FPEMU_STACKSIZE	(1*NBPG)

	.data

	BSS(pdc_stack, 4)	/* temp stack for PDC call */
	BSS(emrg_stack, 4)	/* stack for HPMC/TOC/PWRF */

	.export	kernelmapped, data
	BSS(kernelmapped, 4)	/* set when kernel is mapped */
	.export fpu_enable, data
	BSS(fpu_enable, 4)	/* bits to set in the ccr to enable fpu */
	BSS(cpu_fpuena, 4)	/* enable FPU, otherwise force emulate */
	BSS(fpu_scratch, 16)	/* FPU scratch space, enough for a quad */
	.export hppa_vtop, data
	BSS(hppa_vtop, 4)	/* a vtop translation table addr (pa=va) */

	.text
	.import	$kernel_setup, entry

/*
 * This is the starting location for the kernel
 */
ENTRY($start,0)
/*
 *	start(pdc, boothowto, bootdev, esym, bootapiver, argv, argc)
 *
 *	pdc - PDC entry point
 *	boothowto - boot flags (see "reboot.h")
 *	bootdev - boot device (index into bdevsw)
 *	esym - end of symbol table (or &end if not present)
 *	bootapiver - /boot API version
 *	argv - options block passed from /boot
 *	argc - the length of the block
 */

	/*
	 * save the pdc, boothowto, bootdev and esym arguments
	 */
	ldil	L%pdc,r1
	stw	arg0,R%pdc(r1)
	ldil	L%boothowto,r1
	stw	arg1,R%boothowto(r1)
	ldil	L%bootdev,r1
	stw	arg2,R%bootdev(r1)
	ldil	L%esym,r1
	stw	arg3,R%esym(r1)

	/* Align arg3, which is the start of available memory */
	ldo	NBPG-1(arg3), arg3
	dep	r0, 31, PGSHIFT, arg3

	/* assuming size being page-aligned */
#define	STACK_ALLOC(n,s)	\
	ldil	L%(n), t1	! \
	ldil	L%(s), t2	! \
	stw	arg3, R%(n)(t1)	! \
	add	arg3, t2, arg3

	STACK_ALLOC(pdc_stack, PDC_STACKSIZE)
	STACK_ALLOC(emrg_stack, EMRG_STACKSIZE)

#undef	STACK_ALLOC

	/* zero fake trapframe and proc0 u-area */
	copy	arg3, t2
	ldi	NBPG+TRAPFRAME_SIZEOF, t1
$start_zero_tf
	stws,ma r0, 4(t2)
	addib,>= -8, t1, $start_zero_tf
	stws,ma r0, 4(t2)	/* XXX could use ,bc here, but gas is broken */

	/*
	 * kernel stack lives here (arg3 is page-aligned esym)
	 * initialize the pcb
	 * arg0 will be available space for hppa_init()
	 */
	ldo	NBPG+TRAPFRAME_SIZEOF(arg3), sp
	stw	r0, U_PCB+PCB_ONFAULT(arg3)
	stw	r0, U_PCB+PCB_SPACE(arg3)	/* XXX HPPA_SID_KERNEL == 0 */
	ldil	L%(USPACE+NBPG), arg0		/* normal U plus red zone */
	add	arg0, arg3, arg0
	ldil	L%proc0paddr, t1
	stw	arg3, R%proc0paddr(t1)
	ldil	L%proc0, t2
	stw	arg3, R%proc0+P_ADDR(t2)
	ldo	-TRAPFRAME_SIZEOF(sp), t3
	stw	t3, R%proc0+P_MD_REGS(t2)

	ldil	L%TFF_LAST, t1
	stw	t1, TF_FLAGS-TRAPFRAME_SIZEOF(sp)
	ldil	L%proc0fpstate, t1
	ldo	R%proc0fpstate(t1), t1
	stw	t1, TF_CR30-TRAPFRAME_SIZEOF(sp)
	mtctl	t1, cr30

	/*
	 * disable all coprocessors
	 */
	mtctl	r0, ccr

	/* Store pointer to cpu_info in CR29. */
	ldil	L%cpu_info, r1
	ldo	R%cpu_info(r1), r1
	mtctl	r1, cr29

#ifdef MULTIPROCESSOR
	/* Setup SMP rendezvous address. */
	ldil	L%hw_cpu_spinup_trampoline, r1
	ldo	R%hw_cpu_spinup_trampoline(r1), r1
	stw	r1, 0x10(0)	/* MEM_RENDEZ */
	stw	r0, 0x28(0)	/* MEM_RENDEZ */
#endif

	copy	sp, arg1
	ldil	L%$qisnowon, rp
	ldo	R%$qisnowon(rp), rp
	b	$kernel_setup
	ldi	PSL_Q|PSL_I, arg2

$qisnowon
	/*
	 * call C routine hppa_init() to initialize VM
	 */
	ldil	L%hppa_init, r1
	ldo	R%hppa_init(r1), r1
	.import hppa_init, code
	.call
	blr	r0, rp
	bv,n	(r1)
	nop

	/*
	 * Cannot change the queues or IPSW with the Q-bit on
	 */
	rsm	RESET_PSL, r0
	nop ! nop ! nop ! nop ! nop ! nop ! nop

	/*
	 * We need to do an rfi to get the C bit set
	 */
	mtctl	r0, pcsq
	mtctl	r0, pcsq
	ldil	L%$virtual_mode, t1
	ldo	R%$virtual_mode(t1), t1
	mtctl	t1, pcoq
	ldo	4(t1), t1
	mtctl	t1, pcoq
	mfctl	r29, t1
	ldw	CI_PSW(t1), t2
	mtctl	t2, ipsw
	rfi
	nop

$virtual_mode
	ldil	L%kernelmapped, t1
	stw	t1, R%kernelmapped(t1)

#ifdef DDB
	.import	db_enter, code
	/* have to call debugger from here, from virtual mode */
	ldil	L%boothowto, r1
	ldw	R%boothowto(r1), r1
	bb,>=	r1, 25, $noddb
	nop

	break	HPPA_BREAK_KERNEL, HPPA_BREAK_KGDB
$noddb
#endif

	.import main,code
	ldil	L%main, r1
	ldo	R%main(r1), r1
$callmain
	.call
	blr	r0, rp
	bv,n	(r1)
	nop

	/* should never return... */
	bv	(rp)
	nop
EXIT($start)

LEAF_ENTRY($kernel_setup)

	/*
	 * disable interrupts and turn off all bits in the psw so that
	 * we start in a known state.
	 */
	rsm	RESET_PSL, r0
	nop ! nop ! nop ! nop ! nop ! nop

	/* get things ready for the kernel to run in virtual mode */
	ldi	HPPA_PID_KERNEL, r1
	mtctl	r1, pidr1
	mtctl	r1, pidr2
#if pbably_not_worth_it
	mtctl	r0, pidr3
	mtctl	r0, pidr4
#endif
	mtsp	r0, sr0
	mtsp	r0, sr1
	mtsp	r0, sr2
	mtsp	r0, sr3
	mtsp	r0, sr4
	mtsp	r0, sr5
	mtsp	r0, sr6
	mtsp	r0, sr7

	/*
	 * to keep the spl() routines consistent we need to put the correct
	 * spl level into eiem, and reset any pending interrupts
	 */
	ldi	-1, r1
	mtctl	r0, eiem
	mtctl	r1, eirr

	/*
	 * load address of interrupt vector table
	 */
	ldil	L%$ivaaddr, t2
	ldo	R%$ivaaddr(t2), t2
	mtctl	t2, iva

	/*
	 * set up the dp pointer so that we can do quick references off of it
	 */
	ldil	L%$global$,dp
	ldo	R%$global$(dp),dp

	/*
	 * Create a stack frame for us to call C with. Clear out the previous
	 * sp marker to mark that this is the first frame on the stack.
	 */
	copy	arg1, sp
	ldo	0(arg1), r3
	stw,ma	r0, HPPA_FRAME_SIZE(sp)
	stw	r0, HPPA_FRAME_CRP(sp)
	stw	r0, HPPA_FRAME_PSP(sp)

	/*
	 * We need to set the Q bit so that we can take TLB misses after we
	 * turn on virtual memory.
	 */
	mtctl	r0, pcsq
	mtctl	r0, pcsq
	mtctl	rp, pcoq
	ldo	4(rp), rp
	mtctl	rp, pcoq
	mtctl	arg2, ipsw
	rfi
	nop
	nop
EXIT($kernel_setup)

/* int
 * pdc_call(func, pdc_flag, ...)
 *	iodcio_t func;
 *	int pdc_flag;
 */
ENTRY(pdc_call,160)

	mfctl	eiem, t1
	mtctl	r0, eiem
	stw	rp, HPPA_FRAME_CRP(sp)
	copy	arg0, r31
	copy	sp, ret1

	ldil	L%kernelmapped, ret0
	ldw	R%kernelmapped(ret0), ret0
	comb,=	r0, ret0, pdc_call_unmapped1
	nop
	ldil	L%pdc_stack, ret1
	ldw	R%pdc_stack(ret1), ret1

pdc_call_unmapped1
	copy	sp, r1
	ldo	HPPA_FRAME_SIZE+24*4(ret1), sp

	stw	r1, HPPA_FRAME_PSP(sp)

	/* save kernelmapped and eiem */
	stw	ret0, HPPA_FRAME_ARG(21)(sp)
	stw	t1, HPPA_FRAME_ARG(22)(sp)

	/* copy arguments */
	copy	arg2, arg0
	copy	arg3, arg1
	ldw	HPPA_FRAME_ARG(4)(r1), arg2
	ldw	HPPA_FRAME_ARG(5)(r1), arg3
	ldw	HPPA_FRAME_ARG(6)(r1), t1
	ldw	HPPA_FRAME_ARG(7)(r1), t2
	ldw	HPPA_FRAME_ARG(8)(r1), t3
	ldw	HPPA_FRAME_ARG(9)(r1), t4
	stw	t1, HPPA_FRAME_ARG(4)(sp)	/* XXX can use ,bc */
	stw	t2, HPPA_FRAME_ARG(5)(sp)
	stw	t3, HPPA_FRAME_ARG(6)(sp)
	stw	t4, HPPA_FRAME_ARG(7)(sp)
	ldw	HPPA_FRAME_ARG(10)(r1), t1
	ldw	HPPA_FRAME_ARG(11)(r1), t2
	ldw	HPPA_FRAME_ARG(12)(r1), t3
	ldw	HPPA_FRAME_ARG(13)(r1), t4
	stw	t1, HPPA_FRAME_ARG(8)(sp)
	stw	t2, HPPA_FRAME_ARG(9)(sp)
	stw	t3, HPPA_FRAME_ARG(10)(sp)
	stw	t4, HPPA_FRAME_ARG(11)(sp)

	/* save temp control regs */
	mfctl	cr24, t1
	mfctl	cr25, t2
	mfctl	cr26, t3
	mfctl	cr27, t4
	stw	t1, HPPA_FRAME_ARG(12)(sp)	/* XXX can use ,bc */
	stw	t2, HPPA_FRAME_ARG(13)(sp)
	stw	t3, HPPA_FRAME_ARG(14)(sp)
	stw	t4, HPPA_FRAME_ARG(15)(sp)
	mfctl	cr28, t1
	mfctl	cr29, t2
	mfctl	cr30, t3
	mfctl	cr31, t4
	stw	t1, HPPA_FRAME_ARG(16)(sp)
	stw	t2, HPPA_FRAME_ARG(17)(sp)
	stw	t3, HPPA_FRAME_ARG(18)(sp)
	stw	t4, HPPA_FRAME_ARG(19)(sp)

	comb,=	r0, ret0, pdc_call_unmapped2
	nop

	copy	arg0, t4
	ldi	PSL_Q, arg0 /* (!pdc_flag && args[0] == PDC_PIM)? PSL_M:0) */
	break	HPPA_BREAK_KERNEL, HPPA_BREAK_SET_PSW
	stw	ret0, HPPA_FRAME_ARG(23)(sp)
	copy	t4, arg0

pdc_call_unmapped2
	.call
	blr	r0, rp
	bv,n	(r31)
	nop

	/* load temp control regs */
	ldw	HPPA_FRAME_ARG(12)(sp), t1
	ldw	HPPA_FRAME_ARG(13)(sp), t2
	ldw	HPPA_FRAME_ARG(14)(sp), t3
	ldw	HPPA_FRAME_ARG(15)(sp), t4
	mtctl	t1, cr24
	mtctl	t2, cr25
	mtctl	t3, cr26
	mtctl	t4, cr27
	ldw	HPPA_FRAME_ARG(16)(sp), t1
	ldw	HPPA_FRAME_ARG(17)(sp), t2
	ldw	HPPA_FRAME_ARG(18)(sp), t3
	ldw	HPPA_FRAME_ARG(19)(sp), t4
	mtctl	t1, cr28
	mtctl	t2, cr29
	mtctl	t3, cr30
	mtctl	t4, cr31

	ldw	HPPA_FRAME_ARG(21)(sp), t1
	ldw	HPPA_FRAME_ARG(22)(sp), t2
	comb,=	r0, t1, pdc_call_unmapped3
	nop

	copy	ret0, t3
	ldw	HPPA_FRAME_ARG(23)(sp), arg0
	break	HPPA_BREAK_KERNEL, HPPA_BREAK_SET_PSW
	copy	t3, ret0

pdc_call_unmapped3
	ldw	HPPA_FRAME_PSP(sp), sp
	ldw	HPPA_FRAME_CRP(sp), rp
	bv	r0(rp)
	mtctl	t2, eiem
EXIT(pdc_call)

/*
 * Kernel Gateway Page (must be at known address)
 *	System Call Gate
 *	Signal Return Gate
 *
 * GATEway instructions have to be at a fixed known locations
 * because their addresses are hard coded in routines such as
 * those in the C library.
 */
	.align	NBPG
	.export	gateway_page, entry
gateway_page
	nop				/* @@ 0.C0000000 (Nothing)  */
	gate,n	$bsd_syscall,r0		/* @@ 0.C0000004 (HPUX/BSD) */
	nop				/* @@ 0.C0000008 (HPOSF UNIX) */
	nop				/* @@ 0.C000000C (HPOSF Mach) */
	nop
	nop
	nop
	nop

$bsd_syscall
	/*
	 * set up a space register and a protection id so that
	 * we can access kernel memory
	 */
	mfctl	eiem, r1
	mtctl	r0, eiem
	mtsp	r0, sr1
	mfctl	pidr1, ret0
	ldi	HPPA_PID_KERNEL, t2
	mtctl	t2, pidr1

	.import $syscall,code
	.call
	ldil	L%$syscall, t2
	be	R%$syscall(sr1, t2)
	nop ! nop ! nop ! nop

	.size	gateway_page, .-gateway_page
	.align	NBPG
	.export	gateway_page_end, entry
gateway_page_end

	.export $syscall,entry
	.proc
	.callinfo calls
	.entry
$syscall
	/*
	 *
	 * t1:	syscall number
	 * t2:	user
	 * t3:	args
	 * t4:	user stack
	 *
	 */
	mfctl	cr29, t2
	ldw	CI_CURPROC(sr1, t2), t2
	ldw	P_ADDR(sr1, t2), t3	/* XXX can use ,sl */

	/* calculate kernel sp, load, create kernel stack frame */
	ldo	NBPG(t3), t3
	stw	t3, P_MD_REGS(sr1, t2)
	ldo	TRAPFRAME_SIZEOF(t3), t3
	stw	t4, TF_R19 -TRAPFRAME_SIZEOF(sr1, t3)	/* t4 for vfork() */
	stw	t1, TF_R22 -TRAPFRAME_SIZEOF(sr1, t3)	/* syscall # */
	/* gotta save the args, in case we gonna restart */
	stw	arg3, TF_R23-TRAPFRAME_SIZEOF(sr1, t3)
	stw	arg2, TF_R24-TRAPFRAME_SIZEOF(sr1, t3)
	stw	arg1, TF_R25-TRAPFRAME_SIZEOF(sr1, t3)
	stw	arg0, TF_R26-TRAPFRAME_SIZEOF(sr1, t3)
	stw	r27, TF_R27-TRAPFRAME_SIZEOF(sr1, t3)	/* dp */
	stw	sp, TF_R30 -TRAPFRAME_SIZEOF(sr1, t3)	/* user stack */
	copy	t3, sp
	stw,ma	r0, HPPA_FRAME_SIZE+HPPA_FRAME_MAXARGS(sr1, sp)
	stw	r0, HPPA_FRAME_CRP(sr1, sp)
	mfctl	r29, t1
	ldw	CI_PSW(sr1, t1), t1
	stw	r1, TF_CR15-TRAPFRAME_SIZEOF(sr1, t3)	/* eiem ,bc */
	stw	t1, TF_CR22-TRAPFRAME_SIZEOF(sr1, t3)	/* ipsw */
	mfsp	sr3, t1
	stw	t1, TF_SR3-TRAPFRAME_SIZEOF(sr1, t3)
	stw	ret0, TF_CR8-TRAPFRAME_SIZEOF(sr1, t3)	/* pidr1 */
	/* now we can allow interrupts to happen */
	mtctl	r1, eiem

	/*
	 * we believe that any callee-save registers
	 * will be saved accordingly in either syscall()
	 * or deeper called functions and caller-save
	 * are saved in userland.
	 */
	stw	r2 , TF_R2 -TRAPFRAME_SIZEOF(sr1, t3)
	stw	r3 , TF_R3 -TRAPFRAME_SIZEOF(sr1, t3)
	copy	t3, r3
	/* save callee-save registers */
	stw	r4 , TF_R4 -TRAPFRAME_SIZEOF(sr1, t3)
	stw	r5 , TF_R5 -TRAPFRAME_SIZEOF(sr1, t3)
	stw	r6 , TF_R6 -TRAPFRAME_SIZEOF(sr1, t3)
	stw	r7 , TF_R7 -TRAPFRAME_SIZEOF(sr1, t3)
	stw	r8 , TF_R8 -TRAPFRAME_SIZEOF(sr1, t3)
	stw	r9 , TF_R9 -TRAPFRAME_SIZEOF(sr1, t3)
	stw	r10, TF_R10-TRAPFRAME_SIZEOF(sr1, t3)
	stw	r11, TF_R11-TRAPFRAME_SIZEOF(sr1, t3)
	stw	r12, TF_R12-TRAPFRAME_SIZEOF(sr1, t3)
	stw	r13, TF_R13-TRAPFRAME_SIZEOF(sr1, t3)
	stw	r14, TF_R14-TRAPFRAME_SIZEOF(sr1, t3)
	stw	r15, TF_R15-TRAPFRAME_SIZEOF(sr1, t3)
	stw	r16, TF_R16-TRAPFRAME_SIZEOF(sr1, t3)
	stw	r17, TF_R17-TRAPFRAME_SIZEOF(sr1, t3)
	stw	r18, TF_R18-TRAPFRAME_SIZEOF(sr1, t3)
	/*
	 * Save the rest of the CPU context
	 */
	mfsp	sr0, arg0				/* use ,bc */
	stw	arg0, TF_IISQH-TRAPFRAME_SIZEOF(sr1, t3)
	stw	arg0, TF_IISQT-TRAPFRAME_SIZEOF(sr1, t3)

	ldo	4(r31), arg1
	stw	r31, TF_IIOQH-TRAPFRAME_SIZEOF(sr1, t3)
	stw	arg1, TF_IIOQT-TRAPFRAME_SIZEOF(sr1, t3)

	stw	arg0, TF_CR20-TRAPFRAME_SIZEOF(sr1, t3)	/* use ,bc */
	stw	r31, TF_CR21-TRAPFRAME_SIZEOF(sr1, t3)

	ldil	L%TFF_LAST|TFF_SYS, arg1
	stw	r0, TF_CR19-TRAPFRAME_SIZEOF(sr1, t3)	/* iir */
	stw	arg1, TF_FLAGS-TRAPFRAME_SIZEOF(sr1, t3)

	mfsp	sr2, arg2
	mfsp	sr4, arg3
	stw	arg0, TF_SR0-TRAPFRAME_SIZEOF(sr1, t3)
	stw	arg0, TF_SR1-TRAPFRAME_SIZEOF(sr1, t3)
	stw	arg2, TF_SR2-TRAPFRAME_SIZEOF(sr1, t3)
	stw	arg3, TF_SR4-TRAPFRAME_SIZEOF(sr1, t3)

	mfsp	sr5, arg0
	mfsp	sr6, arg1
	mfsp	sr7, arg2
	mfctl	pidr2, arg3
	stw	arg0, TF_SR5-TRAPFRAME_SIZEOF(sr1, t3)
	stw	arg1, TF_SR6-TRAPFRAME_SIZEOF(sr1, t3)
	stw	arg2, TF_SR7-TRAPFRAME_SIZEOF(sr1, t3)
	stw	arg3, TF_CR9-TRAPFRAME_SIZEOF(sr1, t3)

#if pbably_not_worth_it
	mfctl	pidr3, arg2
	mfctl	pidr4, arg3
	stw	arg2, TF_CR12-TRAPFRAME_SIZEOF(sr1, t3)
	stw	arg3, TF_CR13-TRAPFRAME_SIZEOF(sr1, t3)
#endif

#ifdef DDB
	/*
	 * Save hpt mask and v2p translation table pointer
	 */
	mfctl	eirr, arg0
	mfctl	vtop, arg1
	stw	arg0, TF_CR23-TRAPFRAME_SIZEOF(sr1, t3)
	stw	arg1, TF_CR25-TRAPFRAME_SIZEOF(sr1, t3)

	mfctl	cr28, arg1
	stw	arg1, TF_CR28-TRAPFRAME_SIZEOF(sr1, t3)
#endif

	/* setup kernel context */
	mtsp	r0, sr0
	mtsp	r0, sr1
	mtsp	r0, sr2
	mtsp	r0, sr3
	mtsp	r0, sr4
	mtsp	r0, sr5
	mtsp	r0, sr6
	mtsp	r0, sr7

	ldo	-TRAPFRAME_SIZEOF(t3), arg0
	ldo	4(t3), arg1

	ldil	L%$global$,dp
	ldo	R%$global$(dp),dp

	/* do a syscall */
	.import	syscall,code
	ldil	L%syscall, r1
	ldo	R%syscall(r1), r1
	.call
	blr	r0, rp
	bv,n	0(r1)
	nop

	mfctl	cr29, r1
	ldw	CI_CURPROC(r1), r1
	ldw	P_MD_REGS(r1), t3

	.exit
	.procend
	/* FALLTHROUGH */

	.export	$syscall_return, entry
	.proc
	.callinfo no_calls
	.entry
$syscall_return
	/* t3 == VA trapframe */

	/* disable interrupts, just in case */
#ifdef MULTIPROCESSOR
	mfctl	eiem, t1
	stw	t1, TF_CR15(t3)
#endif
	mtctl	r0, eiem

	/*
	 * 1a. Copy a `phys' part of the frame into temp store
	 *	(see a note for trapall)
	 *	hopefully no page fault would happen on or after the copy,
	 *	and interrupts are disabled.
	 */
	mfctl	cr29, t2
	ldo	CI_TRAP_SAVE(t2), t2
	/* use ,bc each cache line */
	ldw  0(t3), r1 ! ldw  4(t3), t1 ! stw r1,  0(t2) ! stw t1,  4(t2)
	ldw  8(t3), r1 ! ldw 12(t3), t1 ! stw r1,  8(t2) ! stw t1, 12(t2)
	ldw 16(t3), r1 ! ldw 20(t3), t1 ! stw r1, 16(t2) ! stw t1, 20(t2)
	ldw 24(t3), r1 ! ldw 28(t3), t1 ! stw r1, 24(t2) ! stw t1, 28(t2)
	ldw 32(t3), r1 ! ldw 36(t3), t1 ! stw r1, 32(t2) ! stw t1, 36(t2)
	ldw 40(t3), r1 ! ldw 44(t3), t1 ! stw r1, 40(t2) ! stw t1, 44(t2)
	ldw 48(t3), r1 ! ldw 52(t3), t1 ! stw r1, 48(t2) ! stw t1, 52(t2)
	ldw 56(t3), r1 ! ldw 60(t3), t1 ! stw r1, 56(t2) ! stw t1, 60(t2)

	/* 1b. restore most of the general registers */
	ldw	TF_CR11(t3), t1
	mtctl	t1, sar
	ldw	TF_R1(t3), r1
	ldw	TF_R2(t3), r2
	ldw	TF_R3(t3), r3
	ldw	TF_R4(t3), r4
	ldw	TF_R5(t3), r5
	ldw	TF_R6(t3), r6
	ldw	TF_R7(t3), r7
	ldw	TF_R8(t3), r8
	ldw	TF_R9(t3), r9
	ldw	TF_R10(t3), r10
	ldw	TF_R11(t3), r11
	ldw	TF_R12(t3), r12
	ldw	TF_R13(t3), r13
	ldw	TF_R14(t3), r14
	ldw	TF_R15(t3), r15
	ldw	TF_R16(t3), r16
	ldw	TF_R17(t3), r17
	ldw	TF_R18(t3), r18
	ldw	TF_R19(t3), t4
	/*	r20(t3) is used as a temporary and will be restored later */
	/*	r21(t2) is used as a temporary and will be restored later */
	/*	r22(t1) is used as a temporary and will be restored later */
	ldw	TF_R23(t3), r23
	ldw	TF_R24(t3), r24
	ldw	TF_R25(t3), r25
	ldw	TF_R26(t3), r26
	ldw	TF_R27(t3), r27
	ldw	TF_R28(t3), r28
	ldw	TF_R29(t3), r29
	/*	r30 (sp) will be restored later */
	ldw	TF_R31(t3), r31

	/* 2. restore all the space regs and pid regs, except sr3, pidr1 */
	ldw	TF_SR0(t3), t1
	ldw	TF_SR1(t3), t2
	mtsp	t1, sr0
	mtsp	t2, sr1

	ldw	TF_SR2(sr3, t3), t1
	ldw	TF_SR4(sr3, t3), t2
	mtsp	t1, sr2
	mtsp	t2, sr4

	ldw	TF_SR5(sr3, t3), t1
	ldw	TF_SR6(sr3, t3), t2
	mtsp	t1, sr5
	mtsp	t2, sr6

	ldw	TF_SR7(sr3, t3), t1
	ldw	TF_CR9(sr3, t3), t2
	mtsp	t1, sr7
	mtctl	t2, pidr2

#if pbably_not_worth_it
	ldw	TF_CR12(sr3, t3), t1
	ldw	TF_CR13(sr3, t3), t2
	mtctl	t1, pidr3
	mtctl	t2, pidr4
#endif
	ldw	TF_CR0(sr3, t3), t1
	mtctl	t1, rctr
	ldw	TF_CR27(sr3, t3), t1
	ldw	TF_CR30(sr3, t3), t2
	mtctl	t1, cr27
	mtctl	t2, cr30

	/*
	 * clear the system mask, this puts us back into physical mode.
	 * reload trapframe pointer w/ correspondent PA value.
	 * sp will be left in virtual until restored from trapframe,
	 * since we don't use it anyway.
	 */
	ssm	0, r0
	mfctl	cr29, t3
	ldo	CI_TRAP_SAVE(t3), t3
	nop ! nop ! nop ! nop ! nop
	rsm	RESET_PSL, r0
$syscall_return_phys

	/* finally we can restore the space and offset queues and the ipsw */
	ldw	TF_IISQH(t3), t1
	ldw	TF_IISQT(t3), t2
	mtctl	t1, pcsq
	mtctl	t2, pcsq

	ldw	TF_IIOQH(t3), t1
	ldw	TF_IIOQT(t3), t2
	mtctl	t1, pcoq
	mtctl	t2, pcoq

	ldw	TF_CR15(t3), t1
	ldw	TF_CR22(t3), t2
	mtctl	t1, eiem
	mtctl	t2, ipsw

	ldw	TF_SR3(t3), t1
	ldw	TF_CR8(t3), t2
	mtsp	t1, sr3
	mtctl	t2, pidr1

	ldw	TF_R22(t3), t1
	ldw	TF_R21(t3), t2
	ldw	TF_R30(t3), sp
	ldw	TF_R20(t3), t3

	rfi
	nop
	.exit
	.procend
	.size	$syscall, .-$syscall
$syscall_end

/*
 * interrupt vector table
 */
#define	TLABEL(name)	$trap$name
#define TRAP(name,num) \
	mtctl	r1, tr7			! \
	.call				! \
	.import TLABEL(name), code	! \
	b	TLABEL(name)		! \
	ldi	num, r1			! \
	.align	32

#define	ATRAP(name,num) \
	.export	TLABEL(name)$num, entry	! \
	.label	TLABEL(name)$num	! \
	TRAP(all,num)			! \
	.size	TLABEL(name)$num, .-TLABEL(name)$num

#define	CTRAP(name,num,pre) \
	.export	TLABEL(name)$num, entry	! \
	.label	TLABEL(name)$num	! \
	pre				! \
	TRAP(name,num)			! \
	.size	TLABEL(name)$num, .-TLABEL(name)$num

#define	STRAP(name,num,pre) \
	.export	TLABEL(name)$num, entry	! \
	.label	TLABEL(name)$num	! \
	pre				! \
	mtctl	r1, tr7			! \
	.export	trap_ep_##num, entry	! \
	.label	trap_ep_##num		! \
	.call				! \
	b	__CONCAT($name,_l)	! \
	ldi	num, r1			! \
	b	__CONCAT($name,_t)+8	! \
	b	__CONCAT($name,_s)+12	! \
	b	__CONCAT($name,_u)+16	! \
	.size	TLABEL(name)$num, .-TLABEL(name)$num

#define	ITLBPRE \
	mfctl	pcoq,r9 ! \
	mfctl	pcsq,r8
#define	DTLBPRE \
	mfctl	ior, r9 ! \
	mfctl	isr, r8	
	/* CR28XXX according to a popular belief cr28 should be read here */

#define	HPMCPRE	nop
#define	INTRPRE	\
	mfctl	eirr, r8	! \
	mtctl	r8, eirr

	.align NBPG
	.export $ivaaddr, entry
	.export hpmc_v, entry
$ivaaddr
	ATRAP(null,T_NONEXIST)		/*  0. invalid interrupt vector */
hpmc_v
	CTRAP(hpmc,T_HPMC,HPMCPRE)	/*  1. high priority machine check */
	ATRAP(power,T_POWERFAIL)	/*  2. power failure */
	ATRAP(recnt,T_RECOVERY)		/*  3. recovery counter trap */
	CTRAP(intr,T_INTERRUPT,INTRPRE)	/*  4. external interrupt */
	ATRAP(lpmc,T_LPMC)		/*  5. low-priority machine check */
	STRAP(itlb,T_ITLBMISS,ITLBPRE)	/*  6. instruction TLB miss fault */
	ATRAP(iprot,T_IPROT)		/*  7. instruction protection trap */
	ATRAP(ill,T_ILLEGAL)		/*  8. Illegal instruction trap */
	CTRAP(ibrk,T_IBREAK,)		/*  9. break instruction trap */
	ATRAP(privop,T_PRIV_OP)		/* 10. privileged operation trap */
	ATRAP(privr,T_PRIV_REG)		/* 11. privileged register trap */
	ATRAP(ovrfl,T_OVERFLOW)		/* 12. overflow trap */
	ATRAP(cond,T_CONDITION)		/* 13. conditional trap */
	CTRAP(excpt,T_EXCEPTION,)	/* 14. assist exception trap */
	STRAP(dtlb,T_DTLBMISS,DTLBPRE)	/* 15. data TLB miss fault */
	STRAP(itlbna,T_ITLBMISSNA,DTLBPRE)/* 16. ITLB non-access miss fault */
	STRAP(dtlbna,T_DTLBMISSNA,DTLBPRE)/* 17. DTLB non-access miss fault */
	ATRAP(dprot,T_DPROT)		/* 18. data protection trap
					      unaligned data reference trap */
	ATRAP(dbrk,T_DBREAK)		/* 19. data break trap */
	STRAP(tlbd,T_TLB_DIRTY,DTLBPRE)	/* 20. TLB dirty bit trap */
	ATRAP(pgref,T_PAGEREF)		/* 21. page reference trap */
	CTRAP(emu,T_EMULATION,)		/* 22. assist emulation trap */
	ATRAP(hpl,T_HIGHERPL)		/* 23. higher-privelege transfer trap*/
	ATRAP(lpl,T_LOWERPL)		/* 24. lower-privilege transfer trap */
	ATRAP(tknbr,T_TAKENBR)		/* 25. taken branch trap */
	ATRAP(dacc,T_DATACC)		/* 26. data access rights trap */
	ATRAP(dpid,T_DATAPID)		/* 27. data protection ID trap */
	ATRAP(dalgn,T_DATALIGN)		/* 28. unaligned data ref trap */
	ATRAP(unk29,29)
	ATRAP(unk30,30)
	ATRAP(unk31,31)
	ATRAP(unk32,32)
	ATRAP(unk33,33)
	ATRAP(unk34,34)
	ATRAP(unk35,35)
	ATRAP(unk36,36)
	ATRAP(unk37,37)
	ATRAP(unk38,38)
	ATRAP(unk39,39)
	ATRAP(unk40,40)
	ATRAP(unk41,41)
	ATRAP(unk42,42)
	ATRAP(unk43,43)
	ATRAP(unk44,44)
	ATRAP(unk45,45)
	ATRAP(unk46,46)
	ATRAP(unk47,47)
	ATRAP(unk48,48)
	ATRAP(unk49,49)
	ATRAP(unk50,50)
	ATRAP(unk51,51)
	ATRAP(unk52,52)
	ATRAP(unk53,53)
	ATRAP(unk54,54)
	ATRAP(unk55,55)
	ATRAP(unk56,56)
	ATRAP(unk57,57)
	ATRAP(unk58,58)
	ATRAP(unk59,59)
	ATRAP(unk60,60)
	ATRAP(unk61,61)
	ATRAP(unk62,62)
	ATRAP(unk63,63)
					/* 64 */
	.size	$ivaaddr, .-$ivaaddr

	.export TLABEL(excpt), entry
ENTRY(TLABEL(excpt),0)
	/* assume we never get this one w/o fpu [enabled] */
	copy	rp, r1
	copy	arg0, r8
	mfctl	cr30, r9
#if HFP_REGS != 0
	ldo	HFP_REGS(r9), r9
#endif
	.import	fpu_save, code
	.call
	bl	fpu_save, rp
	copy	r9, arg0
	copy	r1, rp
	copy	r8, arg0
	mfctl	cr29, r1
	mtctl	r0, ccr		/* cause a reload after exception */
	ldw	CI_FPU_STATE(r1), r16
	stw	r0, CI_FPU_STATE(r1)
	stw	r0, HFP_CPU(r16)
	sync

	/* now, check for trap */
	ldw	0(r9), r1
	bb,>=,n	r1, HPPA_FPU_T_POS, excpt_notrap
	ldw	1*4(r9), r1
	comb,<>,n r0, r1, excpt_emulate
	ldw	2*4(r9), r1
	comb,<>,n r0, r1, excpt_emulate
	ldw	3*4(r9), r1
	comb,<>,n r0, r1, excpt_emulate
	ldw	4*4(r9), r1
	comb,<>,n r0, r1, excpt_emulate
	ldw	5*4(r9), r1
	comb,<>,n r0, r1, excpt_emulate
	ldw	6*4(r9), r1
	comb,<>,n r0, r1, excpt_emulate
	ldw	7*4(r9), r1

excpt_emulate
	bb,>=,n r1, 5, excpt_notrap	/* HPPA_FPU_UNMPL not set */

	ldw	0(r9), r16
	depi	0, HPPA_FPU_T_POS, 1, r16
	.import	$fpu_emulate, code
	b	$fpu_emulate
	stw	r16, 0(r9)

excpt_notrap
	sync
	b	TLABEL(all)
	ldi	T_EXCEPTION, r1
EXIT(TLABEL(excpt))

	.export TLABEL(emu), entry
ENTRY(TLABEL(emu),0)

	/*
	 * Switch FPU/SFU context
	 *
	 * isr:ior - data address
	 * iir - instruction to emulate
	 * iisq:iioq - address of instruction to emulate
	 *
	 * note: ISR and IOR contain valid data only if the
	 *	 instruction is a coprocessor load or store.
	 *
	 */

	mfctl	iir, r8
	extru	r8, 5, 6, r9	/* no sfu implementation right now */
	comib,=	4, r9, TLABEL(all)
	ldi	T_ILLEGAL, r1

	/*
	 * pass through for all coprocessors now and
	 * do not check the uid here.
	 * in case that piece does not exist emulate
	 * or the trap will be generated later.
	 */

	ldil	L%cpu_fpuena, r1
	ldw	R%cpu_fpuena(r1), r9
	comib,=	0, r9, $fpusw_emu

	/* if we are already enabled and hit again, emulate */
	mfctl	ccr, r1
	extru,<> r1, 25, 2, r0
	b,n	$fpusw_set
	nop

$fpusw_emu
	mfctl	cr29, r1
	mtctl	r0, ccr		/* cause a reload after exception */
	ldw	CI_FPU_STATE(r1), r16
	stw	r0, CI_FPU_STATE(r1)
	stw	r0, HFP_CPU(r16)
	sync
#if 0
	/* here we emulate the fld/fst */
	mfctl	iir, r1
	extru	r1, 5, 6, r1
	comib,=	0xb, r9, TLABEL(all)
	ldi	T_ILLEGAL, r1

	mfctl	iir, r1
	extru	r1, 5, 6, r1
	comib,=	0x9, r9, TLABEL(all)
	ldi	T_ILLEGAL, r1
#endif
	mfctl	iir, r1
	.import	$fpu_emulate, code
	b	$fpu_emulate
	nop

$fpusw_set
	/* enable coprocessor XXX */
	depi	3, 25, 2, r1
	mtctl	r1, ccr

	mfctl	cr29, r16
	mfctl	cr30, r9
	ldw	CI_FPU_STATE(r16), r16

	comb,=,n r16, r0, $fpusw_nosave
	comb,=,n r16, r9, $fpusw_done

	copy	arg0, r17
	copy	rp, r1
#if HFP_REGS != 0
	ldo	HFP_REGS(r16), r16
#endif
	.import	fpu_save, code
	.call
	bl	fpu_save, rp
	copy	r16, arg0
	copy	r1, rp
	copy	r17, arg0

	mfctl	cr29, r1
	ldw	CI_FPU_STATE(r1), r16
	stw	r0, CI_FPU_STATE(r1)
	stw	r0, HFP_CPU(r16)
	sync

$fpusw_nosave

#ifdef MULTIPROCESSOR
	/* See if this process has FPU context on another CPU. */
	ldw	HFP_CPU(r9), r1
	comb,=,n r1, r0, $fpusw_noshoot

	/* Perform FPU shootdown. */
	ldi	(1 << HPPA_IPI_FPU_SAVE), r1
	ldw	HFP_CPU(r9), r16
	stw	r1, CI_IPI(r16)
	ldi	1, r1
	ldw	CI_HPA(r16), r16
	stw	r1, 0(r16)

$fpusw_spin
	/* Wait for shootdown to complete. */
	sync
	ldw	HFP_CPU(r9), r1
	comb,<>,n r1, r0, $fpusw_spin

$fpusw_noshoot
#endif

	/* count switches */
	.import	uvmexp, data
	ldil	L%(uvmexp+FPSWTCH), r1
	ldw	R%(uvmexp+FPSWTCH)(r1), r16
	ldo	31*8+HFP_REGS(r9), r17
	ldo	1(r16), r16
	stw	r16, R%(uvmexp+FPSWTCH)(r1)

	fldds,ma -8(r17), fr31
	fldds,ma -8(r17), fr30
	fldds,ma -8(r17), fr29
	fldds,ma -8(r17), fr28
	fldds,ma -8(r17), fr27
	fldds,ma -8(r17), fr26
	fldds,ma -8(r17), fr25
	fldds,ma -8(r17), fr24
	fldds,ma -8(r17), fr23
	fldds,ma -8(r17), fr22
	fldds,ma -8(r17), fr21
	fldds,ma -8(r17), fr20
	fldds,ma -8(r17), fr19
	fldds,ma -8(r17), fr18
	fldds,ma -8(r17), fr17
	fldds,ma -8(r17), fr16
	fldds,ma -8(r17), fr15
	fldds,ma -8(r17), fr14
	fldds,ma -8(r17), fr13
	fldds,ma -8(r17), fr12
	fldds,ma -8(r17), fr11
	fldds,ma -8(r17), fr10
	fldds,ma -8(r17), fr9
	fldds,ma -8(r17), fr8
	fldds,ma -8(r17), fr7
	fldds,ma -8(r17), fr6
	fldds,ma -8(r17), fr5
	fldds,ma -8(r17), fr4
	fldds,ma -8(r17), fr3
	fldds,ma -8(r17), fr2
	fldds,ma -8(r17), fr1
	fldds     0(r17), fr0	/* fr0 must be restored last */

	mfctl	cr29, r1
	stw	r9, CI_FPU_STATE(r1)
	stw	r1, HFP_CPU(r9)
	sync

$fpusw_done
	rfir
	nop
EXIT(TLABEL(emu))

	/* Construct the virtual address tag. */
#define	VTAG ! \
	shd	r0, r9, 1, r16		/* r16[1..15] = off[0..14] */	! \
	dep	r8, 31, 16, r16		/* put in the space id */	! \
	depi	1, 0, 1, r16		/* and set the valid bit */

#if 0
	.export	dtlb_c, data
	BSS(dtlb_c, 8)
	.export	tlbd_c, data
	BSS(tlbd_c, 8)
	.export	itlb_c, data
	BSS(itlb_c, 8)

	.text
	/* XXX this touches tr5, which it should not, perhaps */

#define	TLB_STATS_PRE(t) \
	mfctl	itmr, r17	! \
	mtctl	r17, tr5
#define	TLB_STATS_AFT(t) \
	mfctl	itmr, r16			! \
	mfctl	tr5, r17			! \
	ldil	L%__CONCAT(t,_c), r25		! \
	ldo	R%__CONCAT(t,_c)(r25), r25	! \
	sub	r16, r17, r16			! \
	ldw	0(r25), r24			! \
	ldw	4(r25), r17			! \
	ldo	1(r24), r24			! \
	ldo	-2(r16), r16 /* for mtctl */	! \
	add	r16, r17, r17			! \
	stw	r24, 0(r25)			! \
	stw	r17, 4(r25)

#else
#define	TLB_STATS_PRE(t)	/**/
#define	TLB_STATS_AFT(t)	/**/
#endif

#if defined(HP7000_CPU) || defined(HP7100_CPU) || defined(HP7200_CPU)
#define	TLB_PULL(bits,lbl)							! \
	/* space:pgaddr -- r8:r9 */					! \
	mfctl	vtop, r16						! \
	ldwax,s	r8(r16), r17		/* space -> page directory */	! \
	extru	r9, 9, 10, r25						! \
	combt,=,n r0, r17, lbl						! \
	ldwax,s	r25(r17), r24		/* page -> page table */	! \
	extru	r9, 19, 10, r16						! \
	combt,=,n r0, r24, lbl						! \
	ldwax,s	r16(r24), r17		/* va -> pa:prot */		! \
	sh2addl	r16, r24, r25						! \
	combt,=,n r0, r17, lbl						! \
	copy	r17, r16						! \
	depi	(bits), 21+bits, 1+bits, r17				! \
	sub,=	r16, r17, r0		/* do not store if unchanged */	! \
	stwas	r17, 0(r25)		/* store back w/ the bits */	! \
	shd	r17, r0, 13, r25					! \
	dep	r8, 30, 15, r25		/* mix0r the pid from the sid */! \
	dep	r0, 31, 12, r17		/* needed ? */			! \
	addi	2, r25, r25						! \
	extru	r17, 24, 25, r17

	.align	32
LEAF_ENTRY($tlbd_s)
ALTENTRY($tlbd_t)
	TLB_STATS_PRE(tlbd)
	TLB_PULL(1, TLABEL(all))
	mfsp	sr1, r16
	mtsp	r8, sr1
	idtlba	r17,(sr1, r9)
	idtlbp	r25,(sr1, r9)
	mtsp	r16, sr1
	TLB_STATS_AFT(tlbd)
	rfir
	nop
EXIT($tlbd_s)

LEAF_ENTRY($itlb_s)
ALTENTRY($itlb_t)
	TLB_STATS_PRE(itlb)
	TLB_PULL(0, TLABEL(all))
	extru,=	r25, 5, 1, r0	/* gateway page needs to be public */
	depi	0, 30, 15, r25
	mfsp	sr1, r16
	mtsp	r8, sr1
	iitlba	r17,(sr1, r9)
	iitlbp	r25,(sr1, r9)
	mtsp	r16, sr1
	TLB_STATS_AFT(itlb)
	rfir
	nop
EXIT($itlb_s)

LEAF_ENTRY($dtlb_s)
ALTENTRY($dtlb_t)
	TLB_STATS_PRE(dtlb)
	TLB_PULL(0, TLABEL(all))
	mfsp	sr1, r16
	mtsp	r8, sr1
	idtlba	r17,(sr1, r9)
	idtlbp	r25,(sr1, r9)
	mtsp	r16, sr1
	TLB_STATS_AFT(dtlb)
	rfir
	nop
EXIT($dtlb_s)

LEAF_ENTRY($dtlbna_s)
ALTENTRY($itlbna_s)
ALTENTRY($dtlbna_t)
ALTENTRY($itlbna_t)
	TLB_STATS_PRE(dtlb)
	TLB_PULL(0, $dtlbna_t_fake)
	mfsp	sr1, r16
	mtsp	r8, sr1
	idtlba	r17,(sr1, r9)
	idtlbp	r25,(sr1, r9)
	mtsp	r16, sr1
	TLB_STATS_AFT(dtlb)
	rfir
	nop
$dtlbna_s_fake
$dtlbna_t_fake
	/* parse prober/w insns, have to decent to trap() to set regs proper */
	mfctl	iir, r16
	extru	r16, 6, 6, r24
	comib,=,n 1, r24, TLABEL(all)
	extru	r16, 24, 6, r24
	subi,<>	0x23, r24, r0
	b	TLABEL(all)
	/* otherwise generate a flush-only tlb entry */
	copy	r0, r17
	zdep	r8, 30, 15, r25
	depi	-13, 11, 7, r25
	ldo	2(r25), r25   /* 3? */
	mfsp	sr1, r16
	mtsp	r8, sr1
	idtlba	r17,(sr1, r9)
	idtlbp	r25,(sr1, r9)
	mtsp	r16, sr1
	TLB_STATS_AFT(dtlb)
	rfir
	nop
EXIT($dtlbna_s)

#endif /*  defined(HP7000_CPU) || defined(HP7100_CPU) || defined(HP7200_CPU) */

#if defined(HP7100LC_CPU) || defined(HP7300LC_CPU)

#define	IITLBAF(r)	.word	0x04000440 | ((r) << 16)
#define	IITLBPF(r)	.word	0x04000400 | ((r) << 16)
#define	IDTLBAF(r)	.word	0x04001440 | ((r) << 16)
#define	IDTLBPF(r)	.word	0x04001400 | ((r) << 16)

/*
 * possible optimizations:
 *	change pte to reduce number of shifts
 *	reorder to reduce stalls
 */
#define	TLB_PULL_L(bits,lbl)						! \
	/* space:pgaddr -- r8:r9 */					! \
	mfctl	vtop, r16						! \
	ldwx,s	r8(r16), r17		/* space -> page directory */	! \
	extru	r9, 9, 10, r25						! \
	combt,=,n r0, r17, lbl						! \
	ldwx,s	r25(r17), r24		/* page -> page table */	! \
	extru	r9, 19, 10, r16						! \
	combt,=,n r0, r24, lbl						! \
	ldwx,s	r16(r24), r17		/* va -> pa:prot */		! \
	sh2addl	r16, r24, r25						! \
	combt,=,n r0, r17, lbl						! \
	copy	r17, r16						! \
	depi	(bits), 21+bits, 1+bits, r17				! \
	sub,=	r16, r17, r0		/* do not store if unchanged */	! \
	stws	r17, 0(r25)		/* store back w/ the bits */	! \
	shd	r17, r0, 13, r25					! \
	dep	r8, 30, 15, r25		/* mix0r the pid from the sid */! \
	dep	r0, 31, 12, r17		/* needed ? */			! \
	addi	2, r25, r25						! \
	extru	r17, 24, 25, r17	/* tlbbtop(r17) */		! \
	sync

	.align	32
LEAF_ENTRY($tlbd_l)
	TLB_STATS_PRE(tlbd)
	TLB_PULL_L(1, TLABEL(all))
	IDTLBAF(17)
	IDTLBPF(25)
#ifdef USE_HPT
	/* invalidate instead of update */
	mfctl	cr28, r17
	ldw	0(r17), r24
	VTAG
	sub,<>	r16, r24, r0
	stw	r0, 0(r17)
#endif
	TLB_STATS_AFT(tlbd)
	rfir
	nop
EXIT($tlbd_l)

	/*
	 * from 7100lc ers, pg.6:
	 * we found a post-silicon bug that makes cr28
	 * unreliable for the itlb miss handler
	 */
LEAF_ENTRY($itlb_l)
	TLB_STATS_PRE(itlb)
	TLB_PULL_L(0, TLABEL(all))
	extru,=	r25, 5, 1, r0	/* gateway page needs to be public */
	depi	0, 30, 15, r25
	IITLBAF(17)
	IITLBPF(25)
	TLB_STATS_AFT(itlb)
	rfir
	nop
EXIT($itlb_l)

LEAF_ENTRY($dtlbna_l)
ALTENTRY($itlbna_l)
	TLB_STATS_PRE(dtlb)
	TLB_PULL_L(0, $dtlbna_l_fake)
	IDTLBAF(17)
	IDTLBPF(25)
	TLB_STATS_AFT(dtlb)
	rfir
	nop
$dtlbna_l_fake
	/* parse prober/w insns, have to decent to trap() to set regs proper */
	mfctl	iir, r16
	extru	r16, 6, 6, r24
	comib,=,n 1, r24, TLABEL(all)
	extru	r16, 24, 6, r24
	subi,<>	0x23, r24, r0
	b	TLABEL(all)
	/* otherwise generate a flush-only tlb entry */
	copy	r0, r17
	zdep	r8, 30, 15, r25
	depi	-13, 11, 7, r25
	ldo	2(r25), r25   /* 3? */
	IDTLBAF(17)
	IDTLBPF(25)
	TLB_STATS_AFT(dtlb)
	rfir
	nop
EXIT($dtlbna_l)

LEAF_ENTRY($dtlb_l)
	TLB_STATS_PRE(dtlb)
	TLB_PULL_L(0, TLABEL(all))
	IDTLBAF(17)
	IDTLBPF(25)
#ifdef USE_HPT
	/*
	 * cache the next page mapping in the hpt.
	 *
	 * mapping for a page at the end of each 128k is uncachable
	 * in the hvt since it'd be in the tlb itself and thus there
	 * is no reason to cache it!
	 * as a side effect this avoids recomputing hpt entry and
	 * retraversing the whole page table each time.
	 */

	ldo	PAGE_SIZE(r9), r9
	extru,<> r9, 20, 5, r0
	b,n	$dtlb_done_l	/* skip if no simple advance */
	/* do not check the PT overlap since the above
	 * check already guaranties that */

	/* ripped from TLB_PULL_L(0) */
	extru	r9, 19, 10, r16		/* r24 was loaded in the TLB_PULL_L */
	ldwx,s	r16(r24), r17		/* va -> pa:prot */
	sh2addl	r16, r24, r25
	combt,=,n r0, r17, $dtlb_done_l
	copy	r17, r16
	depi	0, 21, 1, r17
	sub,=	r16, r17, r0		/* do not store if unchanged */
	stws	r17, 0(r25)		/* store back w/ the bits */
	shd	r17, r0, 13, r25
	dep	r8, 30, 15, r25		/* mix0r the pid from the sid */
	dep	r0, 31, 12, r17		/* needed ? */
	addi	2, r25, r25
	extru	r17, 24, 25, r17
	sync

	mfctl	cr28, r24
	VTAG
	ldo	16(r24), r24
	stw	r16, 0(r24)
	stw	r25, 4(r24)
	stw	r17, 8(r24)
$dtlb_done_l
#endif
	TLB_STATS_AFT(dtlb)
	rfir
	nop
EXIT($dtlb_l)
#endif /* HP7100LC_CPU */

#if defined(HP8000_CPU) || defined(HP8200_CPU) || defined(HP8500_CPU)
	.level	2.0w

	/* xlate 32bit->64bit pte */
#define	TLB_PCX2PCXU \
	extrw,u	r25, 14, 13, r16		! \
	depdi	0, 31, 32, r17			! \
		/* fix io mappings */		! \
	extrd,s	r17, 42, 4, r1			! \
	addi,<>	1, r1, r0			! \
	depdi	-1, 38, 32, r17			! \
		/* fix prom mappings */		! \
	extrd,s	r17, 46, 8, r1			! \
	addi,<>	0x10, r1, r0			! \
	depdi	0, 38, 4, r17			! \
		/* weak ordering, dyn bp */	! \
	depwi	1, 31, 2, r16			! \
	depdi	0, 44, 30, r25			! \
	depd	r16, 14, 15, r25

LEAF_ENTRY($tlbd_u)
	TLB_STATS_PRE(tlbd)
	TLB_PULL_L(1, TLABEL(all))
	TLB_PCX2PCXU
	idtlbt	r17, r25
	TLB_STATS_AFT(tlbd)
	rfir
	nop
EXIT($tlbd_u)

LEAF_ENTRY($itlb_u)
	TLB_STATS_PRE(itlb)
	TLB_PULL_L(0, TLABEL(all))
	extru,=	r25, 5, 1, r0	/* gateway page needs to be public */
	depi	0, 30, 15, r25
	TLB_PCX2PCXU
	iitlbt	r17, r25
	TLB_STATS_AFT(itlb)
	rfir
	nop
EXIT($itlb_u)

LEAF_ENTRY($dtlbna_u)
ALTENTRY($itlbna_u)
	TLB_STATS_PRE(dtlb)
	TLB_PULL_L(0, $dtlbna_u_fake)
	TLB_PCX2PCXU
	idtlbt	r17, r25
	TLB_STATS_AFT(dtlb)
	rfir
	nop
$dtlbna_u_fake
	/* parse prober/w insns, have to decent to trap() to set regs proper */
	mfctl	iir, r16
	extru	r16, 6, 6, r24
	comib,=,n 1, r24, TLABEL(all)
	extru	r16, 24, 6, r24
	subi,<>	0x23, r24, r0
	b	TLABEL(all)
	/* otherwise generate a flush-only tlb entry */
	copy	r0, r17
	zdep	r8, 30, 15, r25
	depi	-13, 11, 7, r25
	ldo	2(r25), r25   /* 3? */
	idtlbt	r17, r25
	TLB_STATS_AFT(dtlb)
	rfir
	nop
EXIT($dtlbna_u)

LEAF_ENTRY($dtlb_u)
	TLB_STATS_PRE(dtlb)
	TLB_PULL_L(0, TLABEL(all))
	TLB_PCX2PCXU
	idtlbt	r17, r25
	TLB_STATS_AFT(dtlb)
	rfir
	nop
EXIT($dtlb_u)

	.level	1.1
#endif /* HP8000_CPU */

	.align	64
	.export	TLABEL(all), entry
ENTRY(TLABEL(all),0)
	/* r1 still has trap type */

	/*
	 * at this point we have:
	 *	psw copied into ipsw
	 *	psw = E(default), M(1 if HPMC, else 0)
	 *	PL = 0
	 *	r1, r8, r9, r16, r17, r24, r25 shadowed (maybe)
	 *	trap number in r1 (old r1 is saved in tr7)
	 */

	/* do not overwrite tr4(cr28) */
	mtctl	t3, tr2

	mfctl	cr29, t3
	ldo	CI_TRAP_SAVE(t3), t3
	stw	t1, TF_R22(t3)		/* use ,bc */
	stw	t2, TF_R21(t3)

	mfctl	tr2, t1
	stw	sp, TF_R30(t3)	/* sp */
	stw	t1, TF_R20(t3)	/* t3 */

	/*
	 * Now, save away other volatile state that prevents us from turning
	 * the PC queue back on, namely, the pc queue and ipsw, and the
	 * interrupt information.
	 */

	mfctl	eiem, t1
	mfctl	ipsw, t2
	stw	t1, TF_CR15(t3)		/* use ,bc */
	stw	t2, TF_CR22(t3)

	mfsp	sr3, t1
	mfctl	pidr1, t2
	stw	t1, TF_SR3(t3)
	stw	t2, TF_CR8(t3)

	/*
	 * Setup kernel context
	 */

	ldi	HPPA_PID_KERNEL,t1
	mtctl	t1, pidr1
	mtsp	r0, sr3

	/* this will enable interrupts after `cold' */
	mfctl	cr29, t1
	ldw	CI_PSW(t1), t2
	mtctl	r0, eiem
	mtctl	t2, ipsw

	mfctl	pcsq, t1
	mtctl	r0, pcsq
	mfctl	pcsq, t2
	stw	t1, TF_IISQH(t3)	/* use ,bc */
	stw	t2, TF_IISQT(t3)
	mtctl	r0, pcsq

	/*
	 * Set up the kernel stack pointer.  If the trap happened
	 * while we were in unprivileged code, or in privileged
	 * code in the SYSCALLGATE page, move to the kernel stack
	 * in curproc's PCB; otherwise, start a new stack frame
	 * on whatever kernel stack we're already on.
	 *
	 * This used to check only for a trap while we were in
	 * unprivileged code, but this ignored the possibility
	 * that a trap could come in during the period between
	 * a gateway instruction to raise privilege and the
	 * disabling of interrupts.  During this period we're
	 * still on the user's stack, and we must move to the
	 * kernel stack.
	 *
	 * - fredette@@
	 */
	mfctl	pcoq, t1
	ldil	L%SYSCALLGATE, t2
	ldo	TF_PHYS-1(sp), sp
	dep	t1, 31, PGSHIFT, t2
	dep,<>	t1, 31, 2, r0
	comb,<>	t1, t2, $trap_from_kernel
	dep	r0, 31, 6, sp

	mfctl	cr29, t2
	ldw	CI_CURPROC(t2), t2
	depi	1, T_USER_POS, 1, r1
	depi	1, TFF_LAST_POS, 1, r1
	ldw	P_ADDR(t2), sp
	ldo	NBPG(sp), sp

$trap_from_kernel
	ldil	L%$trapnowvirt, t2
	ldo	R%$trapnowvirt(t2), t2
	mtctl	t2, pcoq
	stw	t1, TF_IIOQH(t3)
	ldo	4(t2), t2
	mfctl	pcoq, t1
	stw	t1, TF_IIOQT(t3)
	mtctl	t2, pcoq

	mfctl	isr, t1
	mfctl	ior, t2
	stw	t1, TF_CR20(t3)		/* use ,bc */
	stw	t2, TF_CR21(t3)

	mfctl	iir, t2
	stw	t2, TF_CR19(t3)
	stw	r1, TF_FLAGS(t3)

	mfctl	rctr, t1		/* gotta get it before R is up */

	copy	sp, t3
	ldo	HPPA_FRAME_SIZE+TRAPFRAME_SIZEOF(sp), sp
	rfir
	nop ! nop ! nop ! nop ! nop ! nop ! nop ! nop
$trapnowvirt
	/*
	 * t3 contains the virtual address of the trapframe
	 * sp is loaded w/ the right VA (we did not need it being physical)
	 */

	mfctl	ccr, t2
	stw	t1, TF_CR0(sr3, t3)
	stw	t2, TF_CR10(sr3, t3)

	mfsp	sr0, t1
	mfsp	sr1, t2
	stw	t1, TF_SR0(sr3, t3)
	stw	t2, TF_SR1(sr3, t3)

	mfsp	sr2, t1
	mfsp	sr4, t2
	stw	t1, TF_SR2(sr3, t3)
	stw	t2, TF_SR4(sr3, t3)

	mfsp	sr5, t2
	mfsp	sr6, t1
	stw	t2, TF_SR5(sr3, t3)
	stw	t1, TF_SR6(sr3, t3)

	mfsp	sr7, t1
	mfctl	pidr2, t2
	stw	t1, TF_SR7(sr3, t3)
	stw	t2, TF_CR9(sr3, t3)

	mtsp	r0, sr0
	mtsp	r0, sr1
	mtsp	r0, sr2
	mtsp	r0, sr4
	mtsp	r0, sr5
	mtsp	r0, sr6
	mtsp	r0, sr7

#if pbably_not_worth_it
	mfctl	pidr3, t1
	mfctl	pidr4, t2
	stw	t1, TF_CR12(t3)
	stw	t2, TF_CR13(t3)
#endif

	/*
	 * Save all general registers that we haven't saved already
	 */

	mfctl	sar, t1			/* use ,bc each cache line */
	stw	t1, TF_CR11(t3)
	stw	r1, TF_R1(t3)
	stw	r2, TF_R2(t3)
	stw	r3, TF_R3(t3)

	copy	sp, r3
	stw,mb	r0, -HPPA_FRAME_SIZE(r3)

	/*
	 * Copy partially saved state from the store into the frame
	 */
	mfctl	cr29, t2
	ldo	CI_TRAP_SAVE(t2), t2
	/* use ,bc each cache line */
	ldw  0(t2), r1 ! ldw  4(t2), t1 ! stw r1,  0(t3) ! stw t1,  4(t3)
	ldw  8(t2), r1 ! ldw 12(t2), t1 ! stw r1,  8(t3) ! stw t1, 12(t3)
	ldw 16(t2), r1 ! ldw 20(t2), t1 ! stw r1, 16(t3) ! stw t1, 20(t3)
	ldw 24(t2), r1 ! ldw 28(t2), t1 ! stw r1, 24(t3) ! stw t1, 28(t3)
	ldw 32(t2), r1 ! ldw 36(t2), t1 ! stw r1, 32(t3) ! stw t1, 36(t3)
	ldw 40(t2), r1 ! ldw 44(t2), t1 ! stw r1, 40(t3) ! stw t1, 44(t3)
	ldw 48(t2), r1 ! ldw 52(t2), t1 ! stw r1, 48(t3) ! stw t1, 52(t3)
	ldw 56(t2), r1 ! ldw 60(t2), t1 ! stw r1, 56(t3) ! stw t1, 60(t3)

	stw	r4, TF_R4(t3)
	stw	r5, TF_R5(t3)
	stw	r6, TF_R6(t3)
	stw	r7, TF_R7(t3)
	stw	r8, TF_R8(t3)
	stw	r9, TF_R9(t3)
	stw	r10, TF_R10(t3)
	stw	r11, TF_R11(t3)
	stw	r12, TF_R12(t3)
	stw	r13, TF_R13(t3)
	stw	r14, TF_R14(t3)
	stw	r15, TF_R15(t3)
	stw	r16, TF_R16(t3)
	stw	r17, TF_R17(t3)
	stw	r18, TF_R18(t3)
	stw	r19, TF_R19(t3)	/* t4 */
	stw	r23, TF_R23(t3)
	stw	r24, TF_R24(t3)
	stw	r25, TF_R25(t3)
	stw	r26, TF_R26(t3)
	stw	r27, TF_R27(t3)
	stw	r28, TF_R28(t3)
	stw	r29, TF_R29(t3)
	stw	r31, TF_R31(t3)

	/*
	 * Save the necessary control registers that have not already saved.
	 */

#ifdef DDB
	/*
	 * Save hpt mask and v2p translation table pointer
	 */
	mfctl	eirr, t1
	mfctl	vtop, t2
	stw	t1, TF_CR23(t3)
	stw	t2, TF_CR25(t3)

	mfctl	cr28, t2
	stw	t2, TF_CR28(t3)
#endif
	mfctl	cr27, t1
	mfctl	cr30, t2
	stw	t1, TF_CR27(t3)
	stw	t2, TF_CR30(t3)

	/*
	 * load the global pointer for the kernel
	 */

	ldil	L%$global$, dp
	ldo	R%$global$(dp), dp

	/*
	 * call the C routine trap().
	 * form trap type in the first argument to trap()
	 */
	ldw	TF_FLAGS(t3), arg0
	dep	r0, 24, 25, arg0
	copy	t3, arg1

	copy	arg0, r4
	copy	arg1, r5

	.import	trap, code
	ldil	L%trap,t1
	ldo	R%trap(t1),t1
	.call
	blr	r0,rp
	bv,n	r0(t1)
	nop

	copy	r5, t3

	/* see if curproc have changed */
	extru,<> r4, TFF_LAST_POS, 1, r0
	b	$syscall_return

	/* see if curproc have really changed */
	mfctl	cr29, t1
	ldw	CI_CURPROC(t1), t2
	sub,<>	r0, t2, r0
	ldw	P_MD_REGS(t2), t3

	/* means curproc has actually changed */
	b	$syscall_return
	nop
EXIT(TLABEL(all))

#if defined(HP7000_CPU)
/*
 * void desidhash_s(void)
 */
LEAF_ENTRY(desidhash_s)
	sync
	MFCPU_T(DR_CPUCFG,22)	/* t1 */
	MFCPU_T(DR_CPUCFG,22)
	nop
	nop
	depi	0, DR0_PCXS_DHE, 3, t1	/* 3: DR0_PCXS_DOMAIN|DR0_PCXS_IHE */
	depi	1, DR0_PCXS_EQWSTO, 1, t1
	/* clear `write to clear' bits so they don't get reset */
	depi	0, DR0_PCXS_DHPMC, 1, t1
	depi	0, DR0_PCXS_ILPMC, 1, t1
	sync
	MTCPU_T(22,DR_CPUCFG)
	MTCPU_T(22,DR_CPUCFG)
	nop
	nop
	bv	0(rp)
	extru	t1, 4, 5, ret0	/* return chip revision */
EXIT(desidhash_s)
#endif /* HP7000_CPU */

#if defined(HP7100_CPU) || defined(HP7200_CPU)
/*
 * void desidhash_t(void)
 */
LEAF_ENTRY(desidhash_t)
	sync
	MFCPU_T(DR_CPUCFG,22)	/* t1 */
	MFCPU_T(DR_CPUCFG,22)
	nop
	nop
	depi	0, DR0_PCXT_IHE, 1, t1
	depi	0, DR0_PCXT_DHE, 1, t1
	/* clear `write to clear' bits so they don't get reset */
	depi	0, DR0_PCXT_DHPMC, 1, t1
	depi	0, DR0_PCXT_ILPMC, 1, t1
	sync
	MTCPU_T(22,DR_CPUCFG)
	MTCPU_T(22,DR_CPUCFG)
	nop
	nop
	bv	0(rp)
	extru	t1, 4, 5, ret0	/* return chip revision */
EXIT(desidhash_t)
#endif /* HP7100_CPU || HP7200_CPU */

#ifdef HP7300LC_CPU
	.data
	BSS(eaio_l2_mask, 4)
LEAF_ENTRY(eaio_l2)
	ldil	L%eaio_l2_mask, t2
	ldw	R%eaio_l2_mask(t2), t1
	or	t1, arg0, t1
	MTCPU_C(22, DR0_PCXL2_ACCEL_IO)
	nop
	nop
	bv	0(rp)
	stw	t1, R%eaio_l2_mask(t2)
EXIT(eaio_l2)
#endif /* HP7300LC_CPU */

#if defined(HP7100LC_CPU) || defined(HP7300LC_CPU)

/*
 * int
 * ibtlb_l(int i, pa_space_t sp, vaddr_t va, paddr_t pa, vsize_t sz, u_int prot)
 */
LEAF_ENTRY(ibtlb_l)
	rsm	(PSL_R|PSL_I), t4
	nop ! nop ! nop ! nop ! nop ! nop ! nop

	bv	0(rp)
	mtsm	t4
EXIT(ibtlb_l)

/* hpti_l(addr,size) */
LEAF_ENTRY(hpti_l)
	ldo	-1(arg1), arg1
	depi	0, 31, 12, arg1
	ldi	0x1c0, t1		/* cache size assumed 128k XXX */
	or	arg0, t1, arg0
	sync
	MTCPU_C(26,DR0_PCXL2_HTLB_ADDR)
	MTCPU_C(25,DR0_PCXL2_HTLB_CFG)
	nop
	nop
	bv,n	r0(rp)
	nop
EXIT(hpti_l)

/*
 * int
 * pbtlb_l(int i)
 */
LEAF_ENTRY(pbtlb_l)
	; DR_PAGE0
	rsm	(PSL_R|PSL_I), t4
	nop ! nop ! nop ! nop
	ldil	L%0xc041, t1
	ldo	R%0xc041(t1), t1
	dep	arg0, 30, 3, t1
	sync
	MTCPU_T(22,DR_DTLB)	/* t1 */
	nop
	nop
	mtsp	r0, sr1
	idtlba	r0,(sr1,r0)
	idtlbp	r0,(sr1,r0)
	zdepi	-1, 18, 1, t1
	nop
	sync
	MTCPU_T(22,DR_DTLB)
	nop
	nop
	bv	0(rp)
	mtsm	t4
EXIT(pbtlb_l)

/*
 * int desidhash_l(void)
 */
LEAF_ENTRY(desidhash_l)
	MFCPU_C(DR_CPUCFG,22)	/* t1 */
	nop
	nop
	depi	0, DR0_PCXL_L2IHASH_EN, 2, t1	/* 2: DR0_PCXL_L2DHASH_EN */
#if 0 /* better trust the PROM if it left some bits set here */
	depi	0, DR0_PCXL_DUAL_DIS, 2, t1
#endif
	/* clear `write to clear' bits so they don't get reset */
	depi	0, DR0_PCXL_L2IHPMC, 1, t1
	depi	0, DR0_PCXL_L2DHPMC, 1, t1
	depi	0, DR0_PCXL_L1IHPMC, 1, t1
	depi	0, DR0_PCXL_L2PARERR, 4, t1
	sync
	MTCPU_C(22,DR_CPUCFG)
	nop
	nop
	bv	0(rp)
	extru	t1, 4, 5, ret0	/* return chip revision */
EXIT(desidhash_l)

#endif /* HP7100LC_CPU */

#if defined(HP8000_CPU) || defined(HP8200_CPU) || defined(HP8500_CPU)
	.level	2.0w
LEAF_ENTRY(desidhash_u)
	MFCPU_U(2,28)
	depdi	0, 54, 1, r28
	MTCPU_U(28,2)
	bv	r0(rp)
	copy	r0, ret0	/* XXX dunno how to get chip rev */
EXIT(desidhash_u)

LEAF_ENTRY(ibtlb_u)
	/* TODO insert a locked large tlb entry */
	bv	0(rp)
	nop
EXIT(ibtlb_u)

LEAF_ENTRY(pbtlb_u)
	/* TODO purge a locked tlb entry */
	bv	0(rp)
	nop
EXIT(pbtlb_u)
	.level	1.1
#endif /* HP8000_CPU */

/*
 * High Priority Machine Check Interrupt
 */
	.export	TLABEL(hpmc), entry
ENTRY(TLABEL(hpmc),0)
ALTENTRY(hpmc_tramp)

	mtsp	r0, sr0
	ldil	L%hppa_vtop, t1
	ldw	R%hppa_vtop(t1), t1
	mtctl	t1, CR_VTOP

	.import	hpmc_dump, code
	ldil	L%hpmc_dump, rp
	ldo	R%hpmc_dump(rp), rp
	mfctl	cr29, %arg2
	ldw	CI_PSW(%arg2), %arg2
	depi	0, PSL_I_POS, 1, %arg2
	stw	%arg2, CI_PSW(t1)
	ldil	L%emrg_stack, arg1
	b	$kernel_setup
	ldw	R%emrg_stack(arg1), arg1

	/* never returns, but still */
	ldil	L%HPPA_GBCAST, t1
	ldi	CMD_RESET, t2
	stw	t2, R%HPPA_GBCAST(t1)
hpmc_never_dies
	b	hpmc_never_dies
	nop
ALTENTRY(hpmc_tramp_end)
EXIT(TLABEL(hpmc))

/*
 * transfer of control handler
 */
ENTRY(hppa_toc,0)

	mtsp	r0, sr0
	ldil	L%hppa_vtop, t1
	ldw	R%hppa_vtop(t1), t1
	mtctl	t1, CR_VTOP

	/* TODO reload btlb */

	.import	boot, code
	ldil	L%boot, rp
	ldo	R%boot(rp), rp
	mfctl	cr29, %arg2
	ldw	CI_PSW(%arg2), %arg2
	depi	0, PSL_I_POS, 1, %arg2
	stw	%arg2, CI_PSW(t1)
	ldi	0, arg0
	ldil	L%emrg_stack, arg1
	b	$kernel_setup
	ldw	R%emrg_stack(arg1), arg1

ALTENTRY(hppa_toc_end)
	.word	0
EXIT(hppa_toc)

/*
 * power fail recovery handler
 */
ENTRY(hppa_pfr,0)

	mtsp	r0, sr0
	ldil	L%hppa_vtop, t1
	ldw	R%hppa_vtop(t1), t1
	mtctl	t1, CR_VTOP

	/* TODO reload btlb */

	.import	boot, code
	ldil	L%boot, rp
	ldo	R%boot(rp), rp
	mfctl	cr29, %arg2
	ldw	CI_PSW(%arg2), %arg2
	depi	0, PSL_I_POS, 1, %arg2
	stw	%arg2, CI_PSW(t1)
	ldi	RB_HALT|RB_POWERDOWN, arg0
	ldil	L%emrg_stack, arg1
	b	$kernel_setup
	ldw	R%emrg_stack(arg1), arg1

ALTENTRY(hppa_pfr_end)
	.word	0
EXIT(hppa_pfr)

#if 0
	.align	8
intr_ticks
	.word	0, 0

#define	INTR_PROF_PRE \
	mfctl	itmr, r9		! \
	mtctl	r9, tr5
#define	INTR_PROF_AFT \
	mfctl	itmr, r8		! \
	mfctl	tr5, r9			! \
	ldil	L%intr_ticks, r1	! \
	ldo	R%intr_ticks(r1), r1	! \
	sub	r8, r9, r8		! \
	ldw	0(r1), r16		! \
	ldw	4(r1), r17		! \
	add	r8, r16, r16		! \
	addi	1, r17, r17		! \
	stw	r16, 0(r1)		! \
	stw	r17, 4(r1)
#else
#define	INTR_PROF_PRE	/* */
#define	INTR_PROF_AFT	/* */
#endif

	.import	imask, data
	.import	intr_table, data
	.align	32
ENTRY(TLABEL(intr),0)
	/*
	 * r8 is set to eirr in the INTRPRE
	 */

	INTR_PROF_PRE

	ldil	L%intr_table + 32*32, r1
	ldo	R%intr_table + 32*32(r1), r1
	mfctl	cr29, r17
	b	$intr_cont
	ldw	CI_IPENDING(r17), r24

$intr_ffs
	addi	-32, r1, r1
	bb,>=	r8, 0, $intr_ffs
	zdep	r8, 30, 31, r8

	ldw	0(r1), r17
	bb,>=,n	r17, 23, $intr_nocall

	ldw	2*4(r1), r16	/* func */
	ldw	3*4(r1), r9	/* arg: ioreg */
	mtctl	r1, tr7
	bv	r0(r16)
	ldw	6*4(r1), r1	/* next: sub-intr_table */

$intr_nocall
	ldw	4*4(r1), r17	/* bit */
	or	r17, r24, r24	/* ipending */

	/* also return from nested handlers */
$intr_cont
	comb,<>,n r0, r8, $intr_ffs
	ldw	-32(r1), r0	/* preload cache */

	mfctl	cr29, r17
	stw	r24, CI_IPENDING(r17)
	ldw	CI_CPL(r17), r17
	ldil	L%imask, r16
	ldo	R%imask(r16), r16
	ldwx,s	r17(r16), r25

	INTR_PROF_AFT

	ldi	T_INTERRUPT, r1
	andcm,=	r24, r25, r0
	b	TLABEL(all)
	nop

	rfir
	nop
EXIT(TLABEL(intr))

/*
 * called with:
 *	r1	sub intr_table
 *	r9	ioregs
 *	r24	ipending (in/out)
 *	tr7	saved r1 (restore on return)
 * free:
 *	r9, r16, r17, r25
 */
	.align	32
LEAF_ENTRY(gsc_intr)
	ldw	0(r9), r16	/* irr */

	/* we know that first 5 bits are never used ... should skip */
$gsc_intr_loop
	comb,=,n r0, r16, $intr_cont
	mfctl	tr7, r1
$gsc_ffs
	addi	32, r1, r1
	bb,>=	r16, 31, $gsc_ffs
	shd	r0, r16, 1, r16

	ldo	-32(r1), r9
$gsc_share
	ldw	4*4(r9), r17	/* bit */
	ldw	5*4(r9), r9	/* share */

	comb,<>	r0, r9, $gsc_share
	or	r17, r24, r24	/* ipending */

	b,n	$gsc_intr_loop
EXIT(gsc_intr)

	/* see above for calling conventions */
	.align	32
LEAF_ENTRY(dino_intr)
	ldw	3*4(r9), r16	/* irr0 */

$dino_intr_loop
	comb,=,n r0, r16, $intr_cont
	mfctl	tr7, r1
$dino_ffs
	addi	32, r1, r1
	bb,>=	r16, 31, $dino_ffs
	shd	r0, r16, 1, r16

	ldo	-32(r1), r9
$dino_share
	ldw	4*4(r9), r17	/* bit */
	ldw	5*4(r9), r9	/* share */

	comb,<>	r0, r9, $dino_share
	or	r17, r24, r24	/* ipending */

	b,n	$dino_intr_loop
EXIT(dino_intr)

	.export	TLABEL(ibrk), entry
ENTRY(TLABEL(ibrk),0)
	/* If called by a user process then always pass it to trap() */
	mfctl	pcoq, r8
	extru,=	r8, 31, 2, r0
	b,n	$ibrk_bad

	/* don't accept breaks from data segments */
	.import etext
	ldil	L%etext, r9
	ldo	R%etext(r9), r9
	comb,>>=,n r8, r9, $ibrk_bad

	mfctl	iir, r8
	extru	r8, 31, 5, r9
	comib,<>,n HPPA_BREAK_KERNEL, r9, $ibrk_bad

	/* now process all those `break' calls we make */
	extru	r8, 18, 13, r9
	comib,=,n HPPA_BREAK_GET_PSW, r9, $ibrk_getpsw
	comib,=,n HPPA_BREAK_SET_PSW, r9, $ibrk_setpsw
	comib,=,n HPPA_BREAK_SPLLOWER, r9, $ibrk_spllower

$ibrk_bad
	/* illegal (unimplemented) break entry point */
	b	TLABEL(all)
	nop

$ibrk_getpsw
	b	$ibrk_exit
	mfctl	ipsw, ret0

$ibrk_setpsw
	mfctl	ipsw, ret0
	b	$ibrk_exit
	mtctl	arg0, ipsw

$ibrk_spllower
	/* skip the break */
	mtctl	r0, pcoq
	mfctl	pcoq, r9
	mtctl	r9, pcoq
	ldo	4(r9), r9
	mtctl	r9, pcoq

	mfctl	cr29, r17
	ldw	CI_IPENDING(r17), r8
	ldil	L%imask, r9
	ldo	R%imask(r9), r9
	ldw	CI_CPL(r17), ret0
	ldwx,s	arg0(r9), r16
	stw	arg0, CI_CPL(r17)
	ldi	T_INTERRUPT, r1
	andcm,=	r8, r16, r0
	b	TLABEL(all)
	nop
	rfir
	nop

	/* insert other fast breaks here */
	nop ! nop

$ibrk_exit
	/* skip the break */
	mtctl	r0, pcoq
	mfctl	pcoq, r9
	mtctl	r9, pcoq
	ldo	4(r9), r9
	mtctl	r9, pcoq

	rfir
	nop
EXIT(TLABEL(ibrk))

LEAF_ENTRY(fpu_exit)
	/* enable coprocessor XXX */
	depi	3, 25, 2, r1
	mtctl	r1, ccr

	ldil	L%fpu_scratch, %r25
	ldo	R%fpu_scratch(%r25), %r25
	fstds	%fr0, 0(%r25)
	sync
	bv	%r0(%rp)
	mtctl	r0, ccr
EXIT(fpu_exit)

LEAF_ENTRY(fpu_save)
	fstds,ma %fr0 , 8(arg0)
	fstds,ma %fr1 , 8(arg0)
	fstds,ma %fr2 , 8(arg0)
	fstds,ma %fr3 , 8(arg0)
	fstds,ma %fr4 , 8(arg0)
	fstds,ma %fr5 , 8(arg0)
	fstds,ma %fr6 , 8(arg0)
	fstds,ma %fr7 , 8(arg0)
	fstds,ma %fr8 , 8(arg0)
	fstds,ma %fr9 , 8(arg0)
	fstds,ma %fr10, 8(arg0)
	fstds,ma %fr11, 8(arg0)
	fstds,ma %fr12, 8(arg0)
	fstds,ma %fr13, 8(arg0)
	fstds,ma %fr14, 8(arg0)
	fstds,ma %fr15, 8(arg0)
	fstds,ma %fr16, 8(arg0)
	fstds,ma %fr17, 8(arg0)
	fstds,ma %fr18, 8(arg0)
	fstds,ma %fr19, 8(arg0)
	fstds,ma %fr20, 8(arg0)
	fstds,ma %fr21, 8(arg0)
	fstds,ma %fr22, 8(arg0)
	fstds,ma %fr23, 8(arg0)
	fstds,ma %fr24, 8(arg0)
	fstds,ma %fr25, 8(arg0)
	fstds,ma %fr26, 8(arg0)
	fstds,ma %fr27, 8(arg0)
	fstds,ma %fr28, 8(arg0)
	fstds,ma %fr29, 8(arg0)
	fstds,ma %fr30, 8(arg0)
	fstds    %fr31, 0(arg0)
	bv	r0(rp)
	sync
EXIT(fpu_save)

#ifdef FPEMUL
	/*
	 * Emulate FPU
	 *
	 * iisq:iioq - exception triggered instruction
	 */
ENTRY($fpu_emulate,320)
	copy	r31, r9

	mfctl	cr29, r31
	ldw	CI_STACK(r31), r31

	/* stw	r1 , TF_R1 (r31) shadowed */
	stw	r2 , TF_R2 (r31)
	stw	r3 , TF_R3 (r31)
	stw	r4 , TF_R4 (r31)
	stw	r5 , TF_R5 (r31)
	stw	r6 , TF_R6 (r31)
	stw	r7 , TF_R7 (r31)
	/* stw	r8 , TF_R8 (r31) shadowed */
	/* stw	r9 , TF_R9 (r31) shadowed */
	stw	r10, TF_R10(r31)
	stw	r11, TF_R11(r31)
	stw	r12, TF_R12(r31)
	stw	r13, TF_R13(r31)
	stw	r14, TF_R14(r31)
	stw	r15, TF_R15(r31)
	/* stw	r16, TF_R16(r31) shadowed */
	/* stw	r17, TF_R17(r31) shadowed */
	stw	r18, TF_R18(r31)
	stw	r19, TF_R19(r31)
	stw	r20, TF_R20(r31)
	stw	r21, TF_R21(r31)
	stw	r22, TF_R22(r31)
	stw	r23, TF_R23(r31)
	/* stw	r24, TF_R24(r31) shadowed */
	/* stw	r25, TF_R25(r31) shadowed */
	stw	r26, TF_R26(r31)
	stw	r27, TF_R27(r31)
	stw	r28, TF_R28(r31)
	stw	r29, TF_R29(r31)
	stw	sp, TF_R30(r31)
	stw	r9, TF_R31(r31)
	copy	r1, arg0
	mfctl	sar, r1
	stw	r1, TF_CR11(r31)
	stw	arg0, TF_CR19(r31)

	ldo	TRAPFRAME_SIZEOF(r31), r3
	ldo	TRAPFRAME_SIZEOF+HPPA_FRAME_SIZE(r31), sp

	ldil	L%$global$, dp
	ldo	R%$global$(dp), dp

	.import	fpu_emulate, code
	ldil	L%fpu_emulate,t1
	ldo	R%fpu_emulate(t1),t1
	mfctl	cr30, arg2
	.call
	blr	r0,rp
	bv,n	0(t1)
	nop

	mfctl	cr30, r25
	ldi	32, r1

	ldw	4(r25), r17	/* fpu exception reg 0 */
	zdep	ret0, 5, 6, r17	/* intentionally zero the insn */
	stw	r17, 4(r25)

	mfctl	cr29, r31
	ldw	CI_STACK(r31), r31

	ldw	TF_CR11(r31), r1
	ldw	TF_R2 (r31), r2
	ldw	TF_R3 (r31), r3
	mtsar	r1
	copy	ret0, r1
	ldw	TF_R4 (r31), r4
	ldw	TF_R5 (r31), r5
	ldw	TF_R6 (r31), r6
	ldw	TF_R7 (r31), r7
	/* ldw	TF_R8 (r31), r8 shadowed */
	/* ldw	TF_R9 (r31), r9 shadowed */
	ldw	TF_R10(r31), r10
	ldw	TF_R11(r31), r11
	ldw	TF_R12(r31), r12
	ldw	TF_R13(r31), r13
	ldw	TF_R14(r31), r14
	ldw	TF_R15(r31), r15
	/* ldw	TF_R16(r31), r16 shadowed */
	/* ldw	TF_R17(r31), r17 shadowed */
	ldw	TF_R18(r31), r18
	ldw	TF_R19(r31), r19
	ldw	TF_R20(r31), r20
	ldw	TF_R21(r31), r21
	ldw	TF_R22(r31), r22
	ldw	TF_R23(r31), r23
	/* ldw	TF_R24(r31), r24 shadowed */
	/* ldw	TF_R25(r31), r25 shadowed */
	ldw	TF_R26(r31), r26
	ldw	TF_R27(r31), r27
	ldw	TF_R28(r31), r28
	ldw	TF_R29(r31), r29
	ldw	TF_R30(r31), r30
	ldw	TF_R31(r31), r31

	bb,>=,n	r1, 24, $fpu_emulate_done

	b	TLABEL(all)
	ldi	T_EMULATION, r1

$fpu_emulate_done
	comb,<>	r0, r1, TLABEL(all)
	ldi	T_EXCEPTION, r1

	rfir
	nop
EXIT($fpu_emulate)

#endif /* FPEMUL */

	.import	dcache_stride, data
LEAF_ENTRY(fdcache)
	ldil	L%dcache_stride,t1
	ldw	R%dcache_stride(t1), arg3

	mtsp	arg0, sr1		/* move the space register to sr1 */
	add	arg1, arg2, arg0	/* get the last byte to flush in arg0 */

	zdep	arg3, 27, 28, t1	/* get size of a 16X loop in t1 */
	comb,<	arg2, t1, fdc_short	/* check for count < 16 * stride */
	addi	-1, t1, t1		/* compute size of large loop - 1 */

	andcm	arg2, t1, t1		/* L = count - (count mod lenbigloop) */
	add	arg1, t1, t1		/* ub for big loop is lb + L */

	fdc,m	arg3(sr1, arg1)		/* Start flushing first cache line. */
fdc_long
	fdc,m	arg3(sr1, arg1)
	fdc,m	arg3(sr1, arg1)
	fdc,m	arg3(sr1, arg1)
	fdc,m	arg3(sr1, arg1)
	fdc,m	arg3(sr1, arg1)
	fdc,m	arg3(sr1, arg1)
	fdc,m	arg3(sr1, arg1)
	fdc,m	arg3(sr1, arg1)
	fdc,m	arg3(sr1, arg1)
	fdc,m	arg3(sr1, arg1)
	fdc,m	arg3(sr1, arg1)
	fdc,m	arg3(sr1, arg1)
	fdc,m	arg3(sr1, arg1)
	fdc,m	arg3(sr1, arg1)
	fdc,m	arg3(sr1, arg1)
	comb,<<,n arg1, t1, fdc_long
	fdc,m	arg3(sr1, arg1)
fdc_short				/* flush one line at a time */
	comb,<<,n arg1, arg0, fdc_short
	fdc,m	arg3(sr1, arg1)

	addi	-1, arg0, arg1
	fdc	r0(sr1, arg1)

	sync
	syncdma
	bv	r0(r2)
	nop
EXIT(fdcache)

	.import	dcache_stride, data
LEAF_ENTRY(pdcache)
	ldil	L%dcache_stride,t1
	ldw	R%dcache_stride(t1), arg3

	mtsp	arg0, sr1		/* move the space register to sr1 */
	add	arg1, arg2, arg0	/* get the last byte to purge in arg0 */

	zdep	arg3, 27, 28, t1	/* get size of a 16X loop in t1 */
	comb,<	arg2, t1, pdc_short	/* check for count < 16 * stride */
	addi	-1, t1, t1		/* compute size of large loop - 1 */

	andcm	arg2, t1, t1		/* L = count - (count mod lenbigloop) */
	add	arg1, t1, t1		/* ub for big loop is lb + L */

	pdc,m	arg3(sr1, arg1)		/* Start purging first cache line. */
pdc_long
	pdc,m	arg3(sr1, arg1)
	pdc,m	arg3(sr1, arg1)
	pdc,m	arg3(sr1, arg1)
	pdc,m	arg3(sr1, arg1)
	pdc,m	arg3(sr1, arg1)
	pdc,m	arg3(sr1, arg1)
	pdc,m	arg3(sr1, arg1)
	pdc,m	arg3(sr1, arg1)
	pdc,m	arg3(sr1, arg1)
	pdc,m	arg3(sr1, arg1)
	pdc,m	arg3(sr1, arg1)
	pdc,m	arg3(sr1, arg1)
	pdc,m	arg3(sr1, arg1)
	pdc,m	arg3(sr1, arg1)
	pdc,m	arg3(sr1, arg1)
	comb,<<,n arg1, t1, pdc_long
	pdc,m	arg3(sr1, arg1)
pdc_short				/* purge one line at a time */
	comb,<<,n arg1, arg0, pdc_short
	pdc,m	arg3(sr1, arg1)

	addi	-1, arg0, arg1
	pdc	r0(sr1, arg1)

	sync
	syncdma
	bv	r0(r2)
	nop
EXIT(pdcache)

	.import	icache_stride, data
LEAF_ENTRY(ficache)
	ldil	L%icache_stride,t1
	ldw	R%icache_stride(t1), arg3

	mtsp	arg0, sr1		/* move the space register to sr1 */
	add	arg1, arg2, arg0	/* get the last byte to flush in arg0 */

	zdep	arg3, 27, 28, t1	/* get size of a 16X loop in t1 */
	comb,<	arg2, t1, fic_short	/* check for count < 16 * stride */
	addi	-1, t1, t1		/* compute size of large loop - 1 */

	andcm	arg2, t1, t1		/* L = count - (count mod lenbigloop) */
	add	arg1, t1, t1		/* ub for big loop is lb + L */

	fic,m	arg3(sr1, arg1)		/* Start flushing first cache line. */
fic_long
	fic,m	arg3(sr1, arg1)
	fic,m	arg3(sr1, arg1)
	fic,m	arg3(sr1, arg1)
	fic,m	arg3(sr1, arg1)
	fic,m	arg3(sr1, arg1)
	fic,m	arg3(sr1, arg1)
	fic,m	arg3(sr1, arg1)
	fic,m	arg3(sr1, arg1)
	fic,m	arg3(sr1, arg1)
	fic,m	arg3(sr1, arg1)
	fic,m	arg3(sr1, arg1)
	fic,m	arg3(sr1, arg1)
	fic,m	arg3(sr1, arg1)
	fic,m	arg3(sr1, arg1)
	fic,m	arg3(sr1, arg1)
	comb,<<,n arg1, t1, fic_long
	fic,m	arg3(sr1, arg1)
fic_short				/* flush one line at a time */
	comb,<<,n arg1, arg0, fic_short
	fic,m	arg3(sr1, arg1)

	addi	-1, arg0, arg1
	fic	r0(sr1, arg1)

	sync
	syncdma
	bv	r0(r2)
	nop
EXIT(ficache)


LEAF_ENTRY(setjmp)
/*
 * Save the other general registers whose contents are expected to remain
 * across function calls.  According to the "HP 9000 Series 800 Assembly
 * Language Reference Manual", procedures can use general registers 19-26,
 * 28, 29, 1, and 31 without restoring them.  Hence, we do not save these.
 */
	stwm	r3,4(arg0)
	stwm	r4,4(arg0)
	stwm	r5,4(arg0)
	stwm	r6,4(arg0)
	stwm	r7,4(arg0)
	stwm	r8,4(arg0)
	stwm	r9,4(arg0)
	stwm	r10,4(arg0)
	stwm	r11,4(arg0)
	stwm	r12,4(arg0)
	stwm	r13,4(arg0)
	stwm	r14,4(arg0)
	stwm	r15,4(arg0)
	stwm	r16,4(arg0)
	stwm	r17,4(arg0)
	stwm	r18,4(arg0)
	stwm	r27,4(arg0)	/* Good idea to save the data pointer (dp) */
	stwm	rp,4(arg0)	/* Save the return pointer */
	stwm	sp,4(arg0)	/* Save the original stack pointer */

	bv	0(rp)
	copy	r0, ret0
EXIT(setjmp)

LEAF_ENTRY(longjmp)
/*
 * Restore general registers.
 */
	ldwm	4(arg0),r3
	ldwm	4(arg0),r4
	ldwm	4(arg0),r5
	ldwm	4(arg0),r6
	ldwm	4(arg0),r7
	ldwm	4(arg0),r8
	ldwm	4(arg0),r9
	ldwm	4(arg0),r10
	ldwm	4(arg0),r11
	ldwm	4(arg0),r12
	ldwm	4(arg0),r13
	ldwm	4(arg0),r14
	ldwm	4(arg0),r15
	ldwm	4(arg0),r16
	ldwm	4(arg0),r17
	ldwm	4(arg0),r18
	ldwm	4(arg0),r27
	ldwm	4(arg0),rp	/* Restore return address pointer, */
	ldwm	4(arg0),sp	/* stack pointer, */

	bv	0(rp)
	ldi	1, ret0
EXIT(longjmp)


	.align	32

LEAF_ENTRY(copy_on_fault)
	mtsp	r0, sr1
	mtsp	r0, sr2
	stw	r1, PCB_ONFAULT+U_PCB(r2)
	ldw	HPPA_FRAME_CRP(sp), rp
	ldo	-64(sp), sp
	bv	0(rp)
	ldi	EFAULT, %ret0
EXIT(copy_on_fault)

/*
 * int spstrcpy (pa_space_t ssp, const void *src, pa_space_t dsp, void *dst,
 *		 size_t size, size_t *rsize)
 * do a space to space strncpy, return actual copy size in the rsize;
 */
LEAF_ENTRY(spstrcpy)
	ldw	HPPA_FRAME_ARG(4)(sp), t2
	ldo	64(sp), sp
	add	t2, arg1, t2
	stw	rp, HPPA_FRAME_CRP(sp)
	/* setup fault handler */
	mfctl	cr29, t1
	ldw	CI_CURPROC(t1), t3
	ldil	L%copy_on_fault, t4
	ldw	P_ADDR(t3), r2
	ldo	R%copy_on_fault(t4), t4
	ldw	PCB_ONFAULT+U_PCB(r2), r1
	stw	t4, PCB_ONFAULT+U_PCB(r2)

	mtsp	arg0, sr1
	mtsp	arg2, sr2
	copy	arg1, arg0
	copy	r0, ret0

$spstrcpy_loop
	ldbs,ma	1(sr1, arg1), t1
	comb,=	r0, t1, $spstrcpy_exit
	stbs,ma	t1, 1(sr2, arg3)
	comb,<>,n t2, arg1, $spstrcpy_loop
	nop
	ldi	ENAMETOOLONG, ret0

$spstrcpy_exit
	mtsp	r0, sr1
	mtsp	r0, sr2
	stw	r1, PCB_ONFAULT+U_PCB(r2)
	ldw	HPPA_FRAME_CRP(sp), rp
	sub	arg1, arg0, arg1
	ldo	-64(sp), sp
	ldw	HPPA_FRAME_ARG(5)(sp), arg0
	sub,=	r0, arg0, r0
	stw	arg1, 0(arg0)
	bv	0(rp)
	nop
EXIT(spstrcpy)

/*
 * int cpu_switchto(struct proc *old, struct proc *new)
 * Switch from "old" proc to "new".
 */
	.align	32
ENTRY(cpu_switchto,128)
	copy	r3, r1
	stw	rp, HPPA_FRAME_CRP(sp)
	copy	sp, r3
	stwm	r1, HPPA_FRAME_SIZE+20*4(sp)

#ifdef DIAGNOSTIC
	b	kstack_check
	nop
switch_error
	copy	arg1, arg2
	copy	arg0, arg1
	ldil	L%panic, r1
	ldil	L%Lcspstr, arg0
	ldo	R%panic(r1), r1
	ldo	R%Lcspstr(arg0), arg0
	.call
	blr	%r0, rp
	bv,n	%r0(r1)
	nop
Lcspstr
	.asciz	"cpu_switch:old=%p, new=%p"
	.align	8
kstack_check
	/*
	 * The new process' kernel stack must be reasonable.
	 */
	ldw     P_ADDR(arg1), arg2
	ldw	U_PCB+PCB_KSP(arg2), t1
	ldo     NBPG(arg2), arg2
	comb,>>,n arg2, t1, switch_error
	nop
	sub     t1, arg2, t1
	ldil    L%USPACE, arg2
	ldo     R%USPACE(arg2), arg2
	comb,<<=,n arg2, t1, switch_error
	nop
kstack_ok
#endif

	/* Record new proc. */
	ldi	SONPROC, t1
	stb	t1, P_STAT(arg1)
	mfctl	cr29, t1
	stw	arg1, CI_CURPROC(t1)

	/* If old process exited, don't bother. */
	comb,=,n r0, arg0, switch_exited

	/*
	 * 2. save old proc context
	 *
	 * arg0: old proc
	 */
	ldw	P_ADDR(arg0), t1
	/* save callee-save registers */
	stw	r4,   1*4(r3)
	stw	sp, U_PCB+PCB_KSP(t1)
	stw	r5,   2*4(r3)
	stw	r6,   3*4(r3)
	stw	r7,   4*4(r3)
	stw	r8,   5*4(r3)
	stw	r9,   6*4(r3)
	stw	r10,  7*4(r3)
	stw	r11,  8*4(r3)
	stw	r12,  9*4(r3)
	stw	r13, 10*4(r3)
	stw	r14, 11*4(r3)
	stw	r15, 12*4(r3)
	stw	r16, 13*4(r3)
	stw	r17, 14*4(r3)
	stw	r18, 15*4(r3)
	fdc	r0(t1)
	stw	r0, HPPA_FRAME_ARG(1)(sp)	/* say no trampoline */
	sync

	/* don't need old curproc (arg0) starting from here */
switch_exited
	/*
	 * 3. restore new proc context
	 *
	 * arg1: new proc
	 */
	/* XXX disable interrupts? */
	ldw	P_ADDR(arg1), t2
	ldw	P_MD_REGS(arg1), t1
	ldw	U_PCB+PCB_KSP(t2), sp
	mtctl	r0, ccr			/* disable FPU */
	ldw	TF_CR30(t1), t2
	ldw	TF_CR9(t1), t3
	mtctl	t2, cr30
	mtctl	t3, pidr2
	/* XXX enable interrupts? */
	ldo	-(HPPA_FRAME_SIZE+20*4)(sp), r3
	ldw	HPPA_FRAME_ARG(0)(sp), arg0
	ldw	HPPA_FRAME_ARG(1)(sp), t4 /* in case we're on trampoline */
	sub,=	r0, t4, r0
	b	switch_return
	ldw	 1*4(r3), r4
	ldw	 2*4(r3), r5
	ldw	 3*4(r3), r6
	ldw	 4*4(r3), r7
	ldw	 5*4(r3), r8
	ldw	 6*4(r3), r9
	ldw	 7*4(r3), r10
	ldw	 8*4(r3), r11
	ldw	 9*4(r3), r12
	ldw	10*4(r3), r13
	ldw	11*4(r3), r14
	ldw	12*4(r3), r15
	ldw	13*4(r3), r16
	ldw	14*4(r3), r17
	ldw	15*4(r3), r18

switch_return
	ldw	HPPA_FRAME_CRP(r3), rp
	bv	0(rp)
	ldwm	-(HPPA_FRAME_SIZE+20*4)(sp), r3
EXIT(cpu_switchto)

LEAF_ENTRY(cpu_idle_enter)
	bv	0(rp)
	nop
EXIT(cpu_idle_enter)

LEAF_ENTRY(cpu_idle_cycle)
	bv	0(rp)
	nop
EXIT(cpu_idle_cycle)

LEAF_ENTRY(cpu_idle_leave)
	bv	0(rp)
	nop
EXIT(cpu_idle_leave)

ENTRY(switch_trampoline,0)
#ifdef MULTIPROCESSOR
	copy	t4, r3
	copy	arg0, r4
	bl	proc_trampoline_mp, rp
	nop
	copy	r4, arg0
	copy	r3, t4
#endif
	mfctl	cr29, t1
	stw	r0, CI_CPL(t1)
	.call
	blr	r0, rp
	bv,n	r0(t4)
	nop
	mfctl	cr29, t1
	ldw	CI_CURPROC(t1), t2
	.call
	b	$syscall_return
	ldw	P_MD_REGS(t2), t3
EXIT(switch_trampoline)

#ifdef MULTIPROCESSOR
/*
 * Trampoline to spin up secondary processors.
 */
ENTRY(hw_cpu_spinup_trampoline, 0)

	/*
	 * disable interrupts and turn off all bits in the psw so that
	 * we start in a known state.
	 */
	rsm	RESET_PSL, r0
	nop ! nop ! nop ! nop ! nop ! nop

	/* get things ready for the kernel to run in virtual mode */
	ldi	HPPA_PID_KERNEL, r1
	mtctl	r1, pidr1
	mtctl	r1, pidr2
#if pbably_not_worth_it
	mtctl	r0, pidr3
	mtctl	r0, pidr4
#endif
	mtsp	r0, sr0
	mtsp	r0, sr1
	mtsp	r0, sr2
	mtsp	r0, sr3
	mtsp	r0, sr4
	mtsp	r0, sr5
	mtsp	r0, sr6
	mtsp	r0, sr7

	/*
	 * disable all coprocessors
	 */
	mtctl   r0, ccr

	/*
	 * to keep the spl() routines consistent we need to put the correct
	 * spl level into eiem, and reset any pending interrupts
	 */
	ldi	-1, r1
	mtctl	r0, eiem
	mtctl	r1, eirr

	/*
	 * load address of interrupt vector table
	 */
	ldil	L%$ivaaddr, t2
	ldo	R%$ivaaddr(t2), t2
	mtctl	t2, iva

	/*
	 * set up the dp pointer so that we can do quick references off of it
	 */
	ldil	L%$global$,dp
	ldo	R%$global$(dp),dp

	/*
	 * Store address of cpu_info in CR29.
	 */
	ldil	L%cpu_hatch_info, r3
	ldw	R%cpu_hatch_info(r3), r3
	mtctl	r3, cr29

	/*
	 * Setup the stack frame for us to call C with and mark this as the
	 * first frame on the stack.
	 */
	ldw	CI_STACK(r3), sp
	stw,ma	r0, HPPA_FRAME_SIZE(sp)
	stw	r0, HPPA_FRAME_CRP(sp)
	stw	r0, HPPA_FRAME_PSP(sp)

	/* Provide CPU with page tables. */
	ldil	L%hppa_vtop, t1
	ldw	R%hppa_vtop(t1), t1
	mtctl	t1, CR_VTOP

	/* Turn on the Q bit so that we can handle TLB traps. */
	ldil	L%$q_enabled, t1
	ldo	R%$q_enabled(t1), t1
	mtctl	r0, pcsq
	mtctl	r0, pcsq
	mtctl	t1, pcoq
	ldo	4(t1), t1
	mtctl	t1, pcoq
	ldi	PSL_Q|PSL_I, t2
	mtctl	t2, ipsw
	rfi
	nop

$q_enabled

	/* Call C routine to setup CPU. */
	ldil	L%cpu_hw_init, r1
	ldo	R%cpu_hw_init(r1), r1
	.import cpu_hw_init, code
	.call
	blr	r0, rp
	bv,n	(r1)
	nop

	/* Switch CPU mode. */
	ldil	L%$cpu_spinup_vm, t1
	ldo	R%$cpu_spinup_vm(t1), t1
	mtctl	r0, pcsq
	mtctl	r0, pcsq
	mtctl	t1, pcoq
	ldo	4(t1), t1
	mtctl	t1, pcoq
	mfctl	cr29, t2
	ldw	CI_PSW(t2), t2
	mtctl	t2, ipsw
	rfi
	nop

$cpu_spinup_vm

	/*
	 * Okay, time to return to the land of C.
	 */
	b	cpu_hatch
	nop

EXIT(hw_cpu_spinup_trampoline)
#endif

/*
 * Signal "trampoline" code. Invoked from RTE setup by sendsig().
 */
	.section .rodata
	.align 4
	.export	sigcode, entry
	.label sigcode
	.proc
	.callinfo frame=0,calls, save_rp, save_sp
	.entry
sigcode:
	bb,>=,n	arg3, 30, sigcode_call
	dep	r0, 31, 2, arg3
	ldw	4(arg3), r19
	ldw	0(arg3), arg3
sigcode_call
	.call
	ble	0(sr0, arg3)
	copy	r31, rp

	ldil	L%SYSCALLGATE, r1
	copy	r4, arg0
	.call
	ble	4(sr7, r1)
	ldi	SYS_sigreturn, t1
	.globl  sigcoderet
sigcoderet:

	ldil	L%SYSCALLGATE, r1
	copy	ret0, arg0
	.call
	ble	4(sr7, r1)
	ldi	SYS_exit, t1
ALTENTRY(esigcode)
EXIT(sigcode)

	.globl	sigfill
sigfill:
	break	0,0
esigfill:
	.align	4
	.globl	sigfillsiz
sigfillsiz:
	.word	esigfill - sigfill

	.text

	.end
@


1.195
log
@Place a cpu-dependent trap/illegal instruction over the remainder of the
sigtramp page, so that it will generate a nice kernel fault if touched.
While here, move most of the sigtramps to the .rodata segment, because
they are not executed in the kernel.
Also some preparation for sliding the actual sigtramp forward (will need
some gdb changes)
ok mlarkin kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.194 2016/05/10 18:39:44 deraadt Exp $	*/
d260 1
a260 1
	.import	Debugger, code
@


1.194
log
@SROP mitigation.  sendsig() stores a (per-process ^ &sigcontext) cookie
inside the sigcontext.  sigreturn(2) checks syscall entry was from the
exact PC addr in the (per-process ASLR) sigtramp, verifies the cookie,
and clears it to prevent sigcontext reuse.
not yet tested on landisk, sparc, *88k, socppc.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.193 2014/10/23 16:57:45 miod Exp $	*/
d3030 8
a3037 1
ENTRY(sigcode,0)
d3062 11
@


1.193
log
@Correctly set up the HPMC trap entry: according to the PA-RISC Firmware
Architecture Reference Specification, the sum of the 8 trap entry words
*and* of the payload which address and length are to be set at well-known
positions in the aforementioned trap entry, needs to be zero; the existing
code was only enforcing that the sum of the trap entry words is zero.

This matches what Linux and NetBSD do.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.192 2014/10/23 16:51:30 miod Exp $	*/
d3045 2
@


1.192
log
@In the various desidhash_*() functions, make sure we clear the `set to clear'
bit fields with their right sizes (the L2PARERR field on PCXL processors being
4 bits wide, not 1 bit), and make comments consistent accross these functions.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.191 2014/10/14 17:25:48 miod Exp $	*/
d2010 1
d2035 1
@


1.191
log
@Do not skip saving callee-saved registers in trap frames if compiling without
option DDB; some parts of trap() depend upon the whole frame being
populated (especially when running on PCXS processors).
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.190 2014/05/30 13:55:58 kettenis Exp $	*/
d1843 1
a1843 1
	depi	0, DR0_PCXS_DHE, 3, t1	/* 3 4 DR0_PCXS_DOMAIN|DR0_PCXS_IHE */
d1845 1
d1870 1
d1962 9
a1970 5
	depi	0, DR0_PCXL_L2IHASH_EN, 2, t1	/* + DR0_PCXL_L2DHASH_EN */
	depi	0, DR0_PCXL_L2IHPMC, 1, t1	/* don't reset */
	depi	0, DR0_PCXL_L2DHPMC, 1, t1	/* don't reset */
	depi	0, DR0_PCXL_L1IHPMC, 1, t1	/* don't reset */
	depi	0, DR0_PCXL_L2PARERR,1, t1	/* don't reset */
@


1.190
log
@Eliminate some duplicated "mfctl cr29, rN" instructions.

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.189 2011/12/30 12:30:59 miod Exp $	*/
a572 1
#ifdef DDB
a588 1
#endif
a713 1
#ifdef DDB
a728 1
#endif
a1743 5
	/*
	 * hmm, we don't need to save all the regs, only caller-save
	 * (except when DDB)
	 */
#ifdef DDB
a1758 1
#endif
a2363 1
#ifdef DDB
a2378 1
#endif
a2426 1
#ifdef DDB
a2441 1
#endif
@


1.189
log
@Fix encoding of DIAG instructions in the MFCPU_T and MTCPU_T macros. MTCPU_T
was encoded as a read instruction, while MFCPU_T was encoded as a
read-through-TH instruction, although the only uses of it concern registers
read through CH.

(You are not supposed to understand this, this is a dark corner of undocumented
rotten PA-RISC bowels).

Cache SID hashing will now correctly be disabled on PCXS, PCXT and PCXT'
processors.

Proper encoding from the old PA-RISC mklinux sources; tested on 720 (PCXS)
and 715/75 (PCXT); ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.188 2011/11/08 15:39:50 kettenis Exp $	*/
a2159 2
	mfctl	cr29, r25
	stw	r24, CI_IPENDING(r25)
d2161 1
d2280 2
a2281 2
	mfctl	cr29, r8
	ldw	CI_IPENDING(r8), r8
a2283 1
	mfctl	cr29, r17
@


1.188
log
@Save and restore cr27 and add the necessary glue to use it as the userland
thread register.

ok guenther@@, jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.187 2011/10/12 18:30:09 miod Exp $	*/
d83 2
a84 2
#define	MTCPU_T(x,t)	.word	0x14001400 | ((t) << 21) | ((x) << 16)
#define	MFCPU_T(r,x)	.word	0x14001400 | ((r) << 21) | (x)
d1843 1
a1843 1
#if defined(HP7000_CPU) || defined(HP7100_CPU)
d1865 1
a1865 1
#endif /* HP7000_CPU || HP7100_CPU */
d1867 1
a1867 1
#ifdef HP7200_CPU
d1889 1
a1889 1
#endif /* HP7200_CPU */
@


1.187
log
@Remove all MD diagnostics in cpu_switchto(), and move them to MI code if
they apply.

ok oga@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.186 2011/05/05 20:50:43 kettenis Exp $	*/
d776 4
a779 2
	ldw	TF_CR30(sr3, t3), t1
	mtctl	t1, cr30
d1795 4
a1798 2
	mfctl	cr30, t1
	stw	t1, TF_CR30(t3)
@


1.186
log
@Adjust comments on the statements in the various ITLB handlers that make sure
the gateway pages is mapped as a public page.  The origional comment didn't
really explain what was happening here.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.185 2011/04/16 21:55:49 kettenis Exp $	*/
a2771 6
	ldw	P_WCHAN(arg1), t1
	comb,<>,n r0, t1, switch_error
	nop
	ldb	P_STAT(arg1), t1
	comib,<>,n SRUN, t1, switch_error
	nop
@


1.185
log
@Initialize %cr30 for proc0 with the address of proc0fpstate.  Shouldn't really
matter, since we shouldn't be using the FPU inside the kernel, but we need to
initialize %cr30 with something, and this is more consistent than using the
address of the pcb.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.184 2010/12/30 15:10:54 kettenis Exp $	*/
d1252 1
a1252 1
	extru,=	r25, 5, 1, r0	/* gate needs a kernel pid */
d1380 1
a1380 1
	extru,=	r25, 5, 1, r0	/* gate needs a kernel pid */
d1503 1
a1503 1
	extru,=	r25, 5, 1, r0	/* gate needs a kernel pid */
@


1.184
log
@Since we save the interrupt mask in the trapframe when we get a trap, we
might restore the wrong mask when we switch CPUs.  Since we should be
running with the proper mask when we enter $syscall_return, simply save
the proper mask into the trapframe such that we restore the right interrupt
mask later on.

tested by jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.183 2010/12/30 14:30:12 jsing Exp $	*/
d98 1
a178 1
	mtctl	arg3, cr30
d192 4
a195 1
	stw	arg3, TF_CR30-TRAPFRAME_SIZEOF(sp)
@


1.183
log
@Prior to loading the FPU context onto the current CPU, check to see if the
FPU context is still present on another CPU. If so, perform an FPU
shootdown and wait for the FPU context to be saved before continuing.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.181 2010/12/10 09:13:02 kettenis Exp $	*/
d683 4
@


1.182
log
@Convert netisr to a normal soft interrupt instead of hanving MD code
for it. This makes the netisr a real C function which will help further
development. No noticable performance change on i386 and amd64.
With input from kettenis@@ and miod@@ additional OKs mikeb@@ and henning@@
@
text
@d1090 23
@


1.181
log
@There's no need to flush the cache for the FPU state ever since we got rid
of the non-equivalent aliases for it.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.180 2010/11/28 20:09:14 miod Exp $	*/
a103 7

	.export netisr, data
	.align 16
netisr
	.word	0
	.size	netisr, .-netisr
	.align	16
@


1.180
log
@Don't bother .import'ing a dead global.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.179 2010/08/18 21:01:14 jasper Exp $	*/
a2329 10
	ldo	-24(arg0), arg0
	ldi	-32, r25	/* gotta be free for all callers */
	fdc,m	r25(arg0)
	fdc,m	r25(arg0)
	fdc,m	r25(arg0)
	fdc,m	r25(arg0)
	fdc,m	r25(arg0)
	fdc,m	r25(arg0)
	fdc,m	r25(arg0)
	fdc,m	r25(arg0)
a2404 10

	fdc,m	r1(r25)
	fdc,m	r1(r25)
	fdc,m	r1(r25)
	fdc,m	r1(r25)
	fdc,m	r1(r25)
	fdc,m	r1(r25)
	fdc,m	r1(r25)
	fdc	r0(r25)
	sync
@


1.179
log
@- remove COMPAT_LINUX bits. these architectures are not targetted by  the
  linux emulation layer, nor will they in the future.

  ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.178 2010/08/01 14:20:41 kettenis Exp $	*/
a95 1
	.import virtual_avail, data
@


1.178
log
@Small cleanup of the fpu switching code; don't rely on the fact the HFP_REGS
is actually zero and remove a redundant instruction.

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.177 2010/07/01 23:20:13 jsing Exp $	*/
a3060 11


#ifdef COMPAT_LINUX
ENTRY(linux_sigcode,0)

	/* TODO linux signal trampoline */
	bv	0(rp)
	nop
ALTENTRY(linux_esigcode)
EXIT(linux_sigcode)
#endif /* COMPAT_LINUX */
@


1.177
log
@When a process' FPU context is evicted or restored record which CPU the
context is on so that we can handle FPU shootdowns.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.176 2010/07/01 05:33:32 jsing Exp $	*/
d1140 2
a1141 3
	stw	r17, CI_FPU_STATE(r1)
	mfctl	cr30, r17
	stw	r1, HFP_CPU(r17)
@


1.176
log
@Create a struct to store FP state and include a pointer to the CPU that
currently holds the FPU context for this process. This will be soon used
to implement FPU shootdowns on multiprocessor kernels.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.175 2010/06/30 20:38:49 tedu Exp $	*/
d969 1
d971 2
d1046 1
d1048 2
d1091 6
d1141 3
@


1.175
log
@remove compat_osf1 support from the kernel
ok deraadt miod
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.174 2010/06/29 20:30:31 guenther Exp $	*/
d958 2
a959 2
#if (PCB_FPREGS+U_PCB) != 0
	ldo	PCB_FPREGS+U_PCB(r9), r9
d1075 2
a1076 2
#if (PCB_FPREGS+U_PCB) != 0
	ldo	PCB_FPREGS+U_PCB(r16), r16
d1090 1
a1090 1
	ldo	31*8+PCB_FPREGS+U_PCB(r9), r17
@


1.174
log
@Remove COMPAT_HPUX.  No one wanted to support it and its fewmets were
blocking other cleanups
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.173 2010/06/29 00:50:40 jsing Exp $	*/
a495 4
#ifdef COMPAT_OSF1
	bl,n	$osf_syscall,r0
	bl,n	$osf_syscall,r0
#else
a497 1
#endif
a501 20

#ifdef COMPAT_OSF1
$osf_syscall
	/*
	 * Ripped screaming from OSF/MkLinux:
	 *
	 * Convert HPOSF system call to a BSD one by stashing arg4 and arg5
	 * back into the frame, and moving the system call number into r22.
	 * Fortunately, the HPOSF compiler has a bigger stack frame, which
	 * allows this horrible hack.
	 *
	 * We also need to save r29 (aka ret1) for the emulator since it may
	 * get clobbered between here and there.
	 */
	stw	r22, HPPA_FRAME_ARG(4)(sp)
	stw	r21, HPPA_FRAME_ARG(5)(sp)
	stw	r29, HPPA_FRAME_SL(sp)
	gate	$bsd_syscall,r0
	copy	r1, r22
#endif /* COMPAT_OSF1 */
@


1.173
log
@Store pointer to process FPU state in struct cpu_info.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.172 2010/06/03 15:48:58 jsing Exp $	*/
a3071 14

#ifdef COMPAT_HPUX
ENTRY(hpux_sigcode,0)
	bb,>=,n	arg3, 30, hpux_sigcode_call
	dep	r0, 31, 2, arg3
	ldw	4(arg3), r19
	ldw	0(arg3), arg3
hpux_sigcode_call
	.call
	ble	0(sr0, arg3)
	nop	/* rp has already been set */
ALTENTRY(hpux_esigcode)
EXIT(hpux_sigcode)
#endif /* COMPAT_HPUX */
@


1.172
log
@Rename ci_spinup_stack to ci_stack and use it as the stack for both CPU
spin up and FPU emulation. Since all CPUs need a stack for FPU emulation,
move the allocation code to cpuattach().

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.170 2010/05/19 13:10:24 jsing Exp $	*/
a117 2
	.export	fpu_curpcb, data
	BSS(fpu_curpcb, 4)	/* pcb of the fpu owner */
d992 1
d994 1
a994 2
	ldil	L%fpu_curpcb, r1
	stw	r0, R%fpu_curpcb(r1)
a1057 1
	ldil	L%fpu_curpcb, r1
d1066 1
d1068 1
a1068 1
	stw	r0, R%fpu_curpcb(r1)
d1091 1
a1091 1
	ldil	L%fpu_curpcb, r16
d1093 1
a1093 1
	ldw	R%fpu_curpcb(r16), r16
d1152 2
a1153 2
	ldil	L%fpu_curpcb, r1
	stw	r17, R%fpu_curpcb(r1)
@


1.171
log
@Generate exported names using token pasting rather than a macro. Otherwise
without -traditional-cpp the trap name gets preprocessed to the defined
value rather than remaining as text.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.169 2010/05/16 14:54:43 jsing Exp $	*/
a114 1
	BSS(fpemu_stack, 4)	/* stack for FPU emulation */
a170 1
	STACK_ALLOC(fpemu_stack, FPEMU_STACKSIZE)
d2367 2
a2368 2
	ldil	L%fpemu_stack, r31
	ldw	R%fpemu_stack(r31), r31
d2440 2
a2441 2
	ldil	L%fpemu_stack, r31
	ldw	R%fpemu_stack(r31), r31
d2989 1
a2989 1
	ldw	CI_SPINUP_STACK(r3), sp
@


1.170
log
@Spin up secondary CPUs on hppa multiprocessor kernels. At this stage we
enable clock interrupts, however do not allow processes to be scheduled
onto the secondary CPUs - hopefully we can change this shortly...

ok kettenis@@
@
text
@a858 1
#define	TELABEL(num)	__CONCAT(trap_ep_,num)
d885 2
a886 2
	.export	TELABEL(num), entry	! \
	.label	TELABEL(num)		! \
@


1.169
log
@Use a per CPU trap save area, ensuring that we maintain 64-byte alignment
so that it stays within a single cache line.

Feedback and ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.167 2010/04/19 14:05:04 jsing Exp $	*/
d216 8
d2924 126
@


1.168
log
@Make ipending a per-CPU value.

ok kettenis@@
@
text
@a104 4
	.align	64
$trap_tmp_save
	.block	TF_PHYS
	.size	$trap_tmp_save, .-$trap_tmp_save
d720 2
a721 2
	ldil	L%$trap_tmp_save, t2
	ldo	R%$trap_tmp_save(t2), t2
d808 2
a809 2
	ldil	L%$trap_tmp_save, t3
	ldo	R%$trap_tmp_save(t3), t3
d1556 2
a1557 2
	ldil	L%$trap_tmp_save, t3
	ldo	R%$trap_tmp_save(t3), t3
d1720 2
a1721 2
	ldil	L%$trap_tmp_save, t2
	ldo	R%$trap_tmp_save(t2), t2
@


1.167
log
@Make the Processor Status Word (PSW) a per-CPU value.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.164 2009/12/31 12:52:35 jsing Exp $	*/
a2106 1
	.import	ipending, data
d2119 1
a2119 1
	ldil	L%ipending, r17
d2121 1
a2121 1
	ldw	R%ipending(r17), r24
d2146 2
a2147 2
	ldil	L%ipending, r25
	stw	r24, R%ipending(r25)
d2267 2
a2268 2
	ldil	L%ipending, r8
	ldw	R%ipending(r8), r8
@


1.166
log
@Allow for multiple CPUs by moving to an array of cpu_info.

ok kettenis@@
@
text
@a98 1
	.import	kpsw, data
d254 2
a255 2
	ldil	L%kpsw, t1
	ldw	R%kpsw(t1), t2
d584 2
a585 2
	ldil	L%kpsw, t1
	ldw	R%kpsw(sr1, t1), t1
d1594 2
a1595 2
	ldil	L%kpsw, t1
	ldw	R%kpsw(t1), t2
d2009 2
a2010 2
	ldil	L%kpsw, %arg2
	ldw	R%kpsw(%arg2), %arg2
d2012 1
a2012 1
	stw	%arg2, R%kpsw(t1)
d2041 2
a2042 2
	ldil	L%kpsw, %arg2
	ldw	R%kpsw(%arg2), %arg2
d2044 1
a2044 1
	stw	%arg2, R%kpsw(t1)
d2069 2
a2070 2
	ldil	L%kpsw, %arg2
	ldw	R%kpsw(%arg2), %arg2
d2072 1
a2072 1
	stw	%arg2, R%kpsw(t1)
@


1.165
log
@correct the documentation to distinguish cache line purges from
cache line flushes
ok miod
@
text
@d95 1
a95 2
	.import	curproc, data
	.import cpu_info_primary, data
a101 3
#define curproc	(cpu_info_primary + CI_CURPROC)
#define cpl	(cpu_info_primary + CI_CPL)

d216 5
d565 2
a566 2
	ldil	L%curproc, t2
	ldw	R%curproc(sr1, t2), t2
d701 2
a702 2
	ldil	L%curproc, r1
	ldw	R%curproc(r1), r1
d1632 2
a1633 2
	ldil	L%curproc, t2
	ldw	R%curproc(t2), t2
d1820 2
a1821 2
	ldil	L%curproc, t1
	ldw	R%curproc(t1), t2
d2150 2
a2151 2
	ldil	L%cpl, r17
	ldw	R%cpl(r17), r17
d2273 2
a2274 2
	ldil	L%cpl, r17
	ldw	R%cpl(r17), ret0
d2276 1
a2276 1
	stw	arg0, R%cpl(r17)
d2720 2
a2721 2
	ldil	L%curproc, t1
	ldw	R%curproc(t1), t3
d2809 2
a2810 2
	ldil	L%curproc, t1
	stw	arg1, R%curproc(t1)
d2910 2
a2911 2
	ldil	L%cpl, t1
	stw	r0, R%cpl(t1)
d2916 2
a2917 2
	ldil	L%curproc, t1
	ldw	R%curproc(t1), t2
@


1.164
log
@Make cpl and cpu_inintr per CPU variables. For locore.S, cpl becomes an
offset within cpu_primary_info - this will need to be revisited shortly.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.163 2009/12/29 16:37:10 jsing Exp $	*/
d2547 1
a2547 1
	add	arg1, arg2, arg0	/* get the last byte to flush in arg0 */
d2556 1
a2556 1
	pdc,m	arg3(sr1, arg1)		/* Start flushing first cache line. */
d2575 1
a2575 1
pdc_short				/* flush one line at a time */
@


1.163
log
@Call proc_trampoline_mp() from the process trampoline when compiled for MP.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.162 2009/07/29 20:00:47 kettenis Exp $	*/
d104 1
a2106 1
	.import	cpl, data
@


1.162
log
@Fix bogus comment; requested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.161 2009/07/29 18:31:11 kettenis Exp $	*/
d2901 8
@


1.161
log
@Get rid of non-equivalent aliases of the pcb by moving the fpu state out
of the pcb and using the p_addr member of 'struct proc' to calculate the
address of the kernel stack when switching to virtual mode after taking a trap.
Remove the now unecessary cache flushes; they're actually harmful since they
create non-equivalent aliases.  This seems to fix the memory corruption we
have been observing from time to time.

This diff does not rename fpu_curpcb, which is now somewhat incorrectly named.
I hope to change things back again as soon as we are able to map the pcb 1:1.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.160 2009/02/14 19:03:50 kettenis Exp $	*/
d714 1
a714 1
	/* splhigh(), just in case */
@


1.160
log
@Make spstrcpy() return ENAMETOOLONG if the string being copied is too long.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.159 2009/02/08 18:33:29 miod Exp $	*/
a200 1
	stw	arg3, U_PCB+PCB_UVA(arg3)
d1630 2
a1631 1
	mfctl	cr30, t2
d1634 1
a1634 1
	ldw	U_PCB+PCB_UVA(t2), sp
@


1.159
log
@Make sure than cpu_hardclock() never sets a ``next interrupt value'' which has
already been hit by the running timer; this happens very often on oosiop-based
machines, due to these machines being among the slowest hppa, and oosiop
being interrupt greedy. Unfortunately, when this happened, one had to wait
for the timer to wrap, which would take up to 128 seconds on the 33MHz
machines.

Also, invoke hardclock() as many times as necessary if it turns out that
we had to delay the interrupt 1/hz seconds to avoid the aforementioned
wrap problem.

With help from kettenis@@; ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.158 2008/07/28 19:08:46 miod Exp $	*/
d2730 1
d2734 1
a2734 1
	comb,=	t2, arg1, $spstrcpy_exit
d2736 1
a2736 1
	comb,<>,n r0, t1, $spstrcpy_loop
d2738 1
d2751 1
a2751 1
	copy	r0, ret0
@


1.158
log
@No longer clear ci_want_resched within cpu_switchto(), now that it's done
in the MI code.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.157 2008/05/21 19:42:05 miod Exp $	*/
a120 9
	.export cpu_hzticks, data
cpu_hzticks			/* itmr ticks in one hz */
	.word	0
	.size	cpu_hzticks, .-cpu_hzticks
	.export cpu_itmr, data
cpu_itmr			/* itmr value at the most recent clk int */
	.word	0
	.size	cpu_itmr, .-cpu_itmr

a2117 12
	bb,>=,n	r8, 0, $intr_noclock

	/* reload the itmr */
	ldil	L%cpu_hzticks, r25	/* those both are aligned properly */
	ldw	R%cpu_hzticks(r25), r16
	ldw	R%cpu_itmr(r25), r9
	sh1add	r16, r9, r17
	add	r16, r9, r16
	mtctl	r17, itmr
	stw	r16, R%cpu_itmr(r25)

$intr_noclock
@


1.157
log
@ddb expects the kernel longjmp() to only take a single parameter and always
return 1 since 12+ years, it's about time to fix the offending ports.

Reported by Pierre Riteau (firstname.lastname at gmail)
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.156 2007/10/10 15:53:51 art Exp $	*/
a96 1
	.import	want_resched, data
a2822 2
	ldil	L%want_resched, t4
	stw	r0, R%want_resched(t4)
@


1.156
log
@Make context switching much more MI:
 - Move the functionality of choosing a process from cpu_switch into
   a much simpler function: cpu_switchto. Instead of having the locore
   code walk the run queues, let the MI code choose the process we
   want to run and only implement the context switching itself in MD
   code.
 - Let MD context switching run without worrying about spls or locks.
 - Instead of having the idle loop implemented with special contexts
   in MD code, implement one idle proc for each cpu. make the idle
   loop MI with MD hooks.
 - Change the proc lists from the old style vax queues to TAILQs.
 - Change the sleep queue from vax queues to TAILQs. This makes
   wakeup() go from O(n^2) to O(n)

there will be some MD fallout, but it will be fixed shortly.
There's also a few cleanups to be done after this.

deraadt@@, kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.155 2007/07/20 22:09:23 kettenis Exp $	*/
d2714 1
a2714 1
	copy	arg1,ret0	/* Move return value to where it belongs. */
@


1.155
log
@PDC I/O space lives at 0xf0f0000000, not 0xf000000000, at least on astr(4)
based systems.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.154 2007/05/26 00:36:03 krw Exp $	*/
a2773 2
	.import	whichqs, data
	.import	qs, data
d2775 2
a2776 2
 * setrunqueue(struct proc *p);
 * Insert a process on the appropriate queue.  Should be called at splclock().
d2779 1
a2779 92
ENTRY(setrunqueue,0)
#ifdef DIAGNOSTIC
	ldw	P_BACK(arg0), t1
	comb,<>,n r0, t1, Lsetrunqueue_panic
	ldw	P_WCHAN(arg0), t1
	comb,<>,n r0, t1, Lsetrunqueue_panic
	ldb	P_STAT(arg0), t1
	comib,=,n SRUN, t1, Lsetrunqueue_ok
Lsetrunqueue_panic
	copy	arg0, arg1
	ldil	L%panic, r1
	ldil	L%Lsrqpstr, arg0
	ldo	R%panic(r1), r1
	ldo	R%Lsrqpstr(arg0), arg0
	.call
	blr	%r0, rp
	bv,n	%r0(r1)
	nop
Lsrqpstr
	.asciz	"setrunqueue(%p)"
	.align	8
Lsetrunqueue_ok
#endif

	ldb	P_PRIORITY(arg0), t2
	ldil	L%qs, t4
	extru	t2, 29, 5, t1
	ldo	R%qs(t4), t4
	sh3add	t1, t4, t4
	ldil	L%whichqs, arg3
	ldw	P_BACK(t4), t2
	stw	t4, P_FORW(arg0)
	stw	arg0, P_BACK(t4)
	ldw	R%whichqs(arg3), t3
	stw	arg0, P_FORW(t2)
	mtctl	t1, sar
	stw	t2, P_BACK(arg0)
	vdepi	1, 1, t3
	bv	0(rp)
	stw	t3, R%whichqs(arg3)
EXIT(setrunqueue)

/*
 * remrunqueue(struct proc *p);
 * Remove a process from its queue.  Should be called at splclock().
 */
	.align	32
ENTRY(remrunqueue,0)
	ldb	P_PRIORITY(arg0), t2
	extru	t2, 29, 5, arg2
	ldil	L%whichqs, t2
	mtsar	arg2
	ldw	R%whichqs(t2), t3

#ifdef DIAGNOSTIC
	bvb,<,n	t3, remrunqueue_ok

Lremrunqueue_panic
	copy	arg0, arg1
	ldil	L%panic, r1
	ldil	L%Lrrqpstr, arg0
	ldo	R%panic(r1), r1
	ldo	R%Lrrqpstr(arg0), arg0
	.call
	blr	%r0, rp
	bv,n	%r0(r1)
	nop

Lrrqpstr
	.asciz	"remrunqueue(%p), bit=%x"
	.align	8
remrunqueue_ok
#endif
	ldw	P_BACK(arg0), t4
	stw	r0, P_BACK(arg0)
	ldw	P_FORW(arg0), arg0
	stw	arg0, P_FORW(t4)
	vdepi	0, 1, t3
	sub,<>	t4, arg0, r0
	stw	t3, R%whichqs(t2)
	bv	0(rp)
	stw	t4, P_BACK(arg0)
EXIT(remrunqueue)

/*
 * cpu_switch()
 * Find the highest priority process and resume it.
 */
	.align	32
ENTRY(cpu_switch,128)
	ldil	L%cpl, t1
	ldw	R%cpl(t1), ret0
a2782 1
	stw	ret0, HPPA_FRAME_SL(sp)
a2784 54
	/*
	 * Clear curproc so that we don't accumulate system time while idle.
	 */
	ldil	L%curproc, t1
	ldw	R%curproc(t1), arg2
	b	switch_search
	stw	r0, R%curproc(t1)
	/* remain on the old (curproc)'s stack until we have a better choice */

cpu_idle
	copy	r0, arg0
	break	HPPA_BREAK_KERNEL, HPPA_BREAK_SPLLOWER
	.import uvm, data
	ldil	L%(uvm + PAGE_IDLE_ZERO), t3
	ldw	R%(uvm + PAGE_IDLE_ZERO)(t3), t4
	sub,<>	r0, t4, r0
	b	cpu_loop

	stw	arg2, 4(r3)
	ldil	L%uvm_pageidlezero, t1
	ldo	R%uvm_pageidlezero(t1), t2
	.call
	ble	0(sr0, t2)
	copy	r31, rp

	ldw	HPPA_FRAME_SL(r3), ret0
	ldw	4(r3), arg2

cpu_loop
	ldil	L%cpl, arg0
	stw	ret0, R%cpl(arg0)

switch_search
	/*
	 * t1:   &whichqs
	 * arg2: old curproc
	 *
	 */
	ldil	L%whichqs, t1
	ldw	R%whichqs(t1), t3
	comb,=,n r0, t3, cpu_idle
	copy	r0, arg0

	ldi	0, t4
getbit
	mtsar	t4
	bvb,>=,n t3, getbit
	ldo	1(t4), t4

	ldil	L%qs, t2
	ldo	R%qs(t2), t2
	sh3add	t4, t2, t2

	ldw	P_FORW(t2), arg1
d2786 1
a2786 1
	comb,<>	t2, arg1, link_ok
d2789 2
a2790 2
	copy	t4, arg1
	copy	t2, arg2
d2800 1
a2800 1
	.asciz	"cpu_switch: bit=%x, q/p=%p"
d2802 1
a2802 16
link_ok
#endif
	ldil	L%want_resched, t4
	stw	r0, R%want_resched(t4)

	ldw	P_FORW(arg1), arg0
	stw	arg0, P_FORW(t2)
	stw	t2, P_BACK(arg0)
	stw	r0, P_BACK(arg1)

	vdepi	0, 1, t3
	sub,<>	t2, arg0, r0
	stw	t3, R%whichqs(t1)

	/* don't need &whichqs (t1) starting here */
#ifdef DIAGNOSTIC
d2805 1
a2805 1
	copy	arg1, t2
d2808 1
a2808 1
	copy	arg1, t2
d2810 1
a2810 2
	 * Either we must be switching to the same process, or
	 * the new process' kernel stack must be reasonable.
d2812 10
a2821 11
	comb,=,n arg1, arg2, kstack_ok
	ldw     P_ADDR(arg1), arg0
	ldw	U_PCB+PCB_KSP(arg0), t1
	ldo     NBPG(arg0), arg0
	comb,>>,n arg0, t1, switch_error
	copy    arg1, t2
	sub     t1, arg0, t1
	ldil    L%USPACE, arg0
	ldo     R%USPACE(arg0), arg0
	comb,<<=,n arg0, t1, switch_error
	copy    arg1, t2
d2824 4
d2830 2
a2831 2
	/* Skip context switch if same process. */
	comb,=,n arg1, arg2, switch_return
d2834 1
a2834 1
	comb,=,n r0, arg2, switch_exited
d2839 1
a2839 1
	 * arg2: old proc
d2841 1
a2841 1
	ldw	P_ADDR(arg2), t1
d2863 1
a2863 1
	/* don't need old curproc (arg2) starting from here */
d2870 1
d2879 1
d2884 1
a2884 1
	b	switch_gonnajump
a2899 5
switch_gonnajump
	ldw	HPPA_FRAME_SL(r3), ret0
	ldil	L%cpl, t1
	stw	ret0, R%cpl(t1)
	sync
a2901 2
	ldil	L%curproc, t1
	stw	arg1, R%curproc(t1)
d2905 16
a2920 1
EXIT(cpu_switch)
d2923 2
@


1.154
log
@More comment typos from Diego Casati. Including winners like funtion, allmost,
oustside, seqencer, toghether, nessissary, etc.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.153 2007/05/14 19:54:21 martin Exp $	*/
d1484 1
a1484 1
	depdi	0, 42, 8, r17			! \
@


1.153
log
@move hppa to __HAVE_CPUINFO

input from miod@@, ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.152 2006/01/10 01:17:28 martin Exp $	*/
d939 1
a939 1
					      unalligned data reference trap */
@


1.152
log
@The __CONCAT macro here collides with the one in cdefs.h pulled in via
errno.h. Don't include errno.h and export EFAULT therefore.

looks good miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.151 2005/05/26 03:42:43 mickey Exp $	*/
d96 1
d103 2
@


1.151
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.150 2005/04/21 04:39:35 mickey Exp $	*/
a66 1
#include <sys/errno.h>
@


1.150
log
@count fpu lazy context switches; deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.149 2005/04/07 00:24:57 mickey Exp $	*/
d1061 1
a1061 1
	 * or the trap will be generted later.
@


1.149
log
@simpler logic for trap exit
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.148 2005/04/07 00:21:51 mickey Exp $	*/
a134 2
	.export fpu_csw, data
	BSS(fpu_csw, 4)		/* count fpu context switches */
d1121 3
a1123 2
	ldil	L%fpu_csw, r1
	ldw	R%fpu_csw(r1), r16
d1126 1
a1126 1
	stw	r16, R%fpu_csw(r1)
@


1.148
log
@64bit-friendly pdc.h and iomod.h and correspondent changes elsewhere
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.147 2005/03/26 20:04:37 mickey Exp $	*/
d1809 3
d1820 2
d1823 1
a1823 3
	ldw	-HPPA_FRAME_SIZE-TRAPFRAME_SIZEOF+TF_FLAGS(sp), arg0
	ldo	-HPPA_FRAME_SIZE-TRAPFRAME_SIZEOF(sp), t3
	extru,<> arg0, TFF_LAST_POS, 1, r0
d1832 1
a1832 1
	/* means curproc have actually changed */
@


1.147
log
@md parts for hpux_compa code; some problems w/ signals delivery still exist
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.146 2005/03/16 13:20:43 mickey Exp $	*/
d2023 1
a2023 1
	ldil	L%GBCAST_ADDR, t1
d2025 1
a2025 1
	stw	t2, R%GBCAST_ADDR(t1)
@


1.146
log
@play the relied-upon-xlation proper; deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.145 2005/01/23 16:28:29 mickey Exp $	*/
d1098 1
a1098 1
	/* enable coprocessor */
d3108 15
d3130 1
a3130 1
EXIT(linix_sigcode)
@


1.145
log
@generate .size for asm objects too (and kill *end labels)
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.144 2005/01/17 19:01:00 mickey Exp $	*/
d821 4
a825 1
	nop ! nop ! nop ! nop ! nop ! nop ! nop
a826 3

	ldil	L%$trap_tmp_save, t3
	ldo	R%$trap_tmp_save(t3), t3
@


1.144
log
@proper non-access fault handlers and probe emulations; testing by pval@@ miod@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.143 2004/12/24 22:50:29 miod Exp $	*/
d111 1
d117 1
d123 1
d127 1
d556 1
d858 1
d877 2
a878 1
	TRAP(all,num)
d884 2
a885 1
	TRAP(name,num)
d899 2
a900 1
	b	__CONCAT($name,_u)+16
d986 1
d1233 2
a1234 2
$tlbd_s
$tlbd_t
d1245 1
d1247 2
a1248 2
$itlb_s
$itlb_t
d1261 1
d1263 2
a1264 2
$dtlb_s
$dtlb_t
d1275 1
d1277 4
a1280 4
$itlbna_s
$dtlbna_s
$itlbna_t
$dtlbna_t
d1313 1
d1353 1
a1353 1
$tlbd_l
d1369 1
d1376 1
a1376 1
$itlb_l
d1386 1
d1388 2
a1389 2
$itlbna_l
$dtlbna_l
d1415 1
d1417 1
a1417 1
$dtlb_l
d1466 1
d1489 1
a1489 1
$tlbd_u
d1497 1
d1499 1
a1499 1
$itlb_u
d1509 1
d1511 2
a1512 2
$itlbna_u
$dtlbna_u
d1537 1
d1539 1
a1539 1
$dtlb_u
d1547 1
a1551 3
	.export	$tlb_missend, entry
$tlb_missend

a1831 3

	.export	$trap$all$end, entry
$trap$all$end
@


1.143
log
@{e,}intr{cnt,names} bye-bye.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.142 2004/10/26 20:18:01 mickey Exp $	*/
d1200 1
a1200 1
#define	TLB_PULL(bits)							! \
d1205 1
a1205 1
	combt,=,n r0, r17, TLABEL(all)					! \
d1208 1
a1208 1
	combt,=,n r0, r24, TLABEL(all)					! \
d1211 1
a1211 1
	combt,=,n r0, r17, TLABEL(all)					! \
d1226 1
a1226 1
	TLB_PULL(1)
a1236 1
$itlbna_s
a1237 1
$itlbna_t
d1239 1
a1239 1
	TLB_PULL(0)
d1252 13
d1266 1
a1266 1
$dtlb_t
d1269 23
a1291 1
	TLB_PULL(0)
d1300 1
d1315 1
a1315 1
#define	TLB_PULL_L(bits)						! \
d1320 1
a1320 1
	combt,=,n r0, r17, TLABEL(all)					! \
d1323 1
a1323 1
	combt,=,n r0, r24, TLABEL(all)					! \
d1326 1
a1326 1
	combt,=,n r0, r17, TLABEL(all)					! \
d1341 1
a1341 1
	TLB_PULL_L(1)
a1361 1
$itlbna_l
d1363 1
a1363 1
	TLB_PULL_L(0)
d1371 2
d1375 19
a1393 1
	TLB_PULL_L(0)
a1395 1
	/* figure out later if it's worth caching mappings here as well */
d1399 1
d1402 1
a1402 1
	TLB_PULL_L(0)
d1473 1
a1473 1
	TLB_PULL_L(1)
a1480 1
$itlbna_u
d1482 1
a1482 1
	TLB_PULL_L(0)
d1491 1
d1493 25
d1520 1
a1520 1
	TLB_PULL_L(0)
a1799 1
	bb,>=,n	arg0, TFF_LAST_POS, $syscall_return
d1801 2
d1807 2
a1808 2
	comb,=,n r0, t2, $syscall_return
	ldo	-HPPA_FRAME_SIZE-TRAPFRAME_SIZEOF(sp), t3
d1812 1
a1812 1
	ldw	P_MD_REGS(t2), t3
@


1.142
log
@disable sid hashing on pcxu and above
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.141 2004/09/18 07:21:27 mickey Exp $	*/
a140 11

	.export intrcnt, data
	.export eintrcnt, data
	.export intrnames, data
	.export eintrnames, data
intrcnt
	.word	0
eintrcnt
intrnames
	.word	0
eintrnames
@


1.141
log
@use ret0 instead of r28 to match how it's done later in the code
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.140 2004/09/15 21:32:43 mickey Exp $	*/
d88 2
d1410 1
a1410 1
	.level	2.0
d1893 1
d1895 3
d1899 1
a1899 1
	nop
d1913 1
@


1.140
log
@add pcxu tlb handlers and cpu probing
add u2/uturn ioa driver in dumb mode now
enable pcxu/pcxw support
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.139 2004/09/15 00:25:43 mickey Exp $	*/
d551 1
a551 1
	mfctl	pidr1, r28
@


1.139
log
@simplify error check in fpu_emulate
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.138 2004/09/14 23:39:32 mickey Exp $	*/
d900 1
a900 1
	nop /*b	__CONCAT($name,_u)+16 */
d1310 1
a1310 1
	extru	r17, 24, 25, r17					! \
d1407 54
d1889 19
@


1.138
log
@store fpu version for later use. make sure to proper store/clear fpu state in fork/exec/exit/sendsig
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.137 2004/09/14 22:44:58 mickey Exp $	*/
d2339 1
a2339 3
	comb,=,n r0, r1, $fpu_emulate_done2

	b	TLABEL(all)
a2341 1
$fpu_emulate_done2
@


1.137
log
@poke and clean all exceptions regs and not just one
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.136 2004/06/30 21:01:08 mickey Exp $	*/
d2153 4
d2160 1
d2162 1
a2162 1
	sync
@


1.136
log
@use evconuts for device interrupts counting
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.135 2004/06/30 18:18:54 mickey Exp $	*/
d1009 15
a1023 1
	ldw	8(r9), r1
d2275 1
a2275 1
	ldw	8(r25), r17	/* fpu exception reg 0 */
d2277 1
a2277 1
	stw	r17, 8(r25)
@


1.135
log
@allow forced fpu emulation through a sysctl
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.134 2004/06/13 21:49:14 niklas Exp $	*/
a109 26
	.globl	intrcnt, eintrcnt, intrnames, eintrnames
	.export	intrcnt, data
intrcnt
	.block	16 * 4
	.export	eintrcnt, data
eintrcnt
	.export	intrnames, data
intrnames
	.asciz	"spur"
	.asciz	"lev1"
	.asciz	"lev2"
	.asciz	"lev3"
	.asciz	"lev4"
	.asciz	"lev5"
	.asciz	"lev6"
	.asciz	"lev7"
	.asciz	"lev8"
	.asciz	"clock"
	.asciz	"lev10"
	.asciz	"lev11"
	.asciz	"lev12"
	.asciz	"lev13"
	.asciz	"lev14"
	.asciz	"lev15"
	.export	eintrnames, data
eintrnames
d140 11
d1976 1
a1976 1
	ldw	4*4(r1), r1	/* next: sub-intr_table */
d1979 1
a1979 2
	ldw	6*4(r1), r17	/* bit */
	ldw	7*4(r1), r25	/* &intrcnt[pri] */
a1981 4
	ldw	0(r25), r9
	addi	1, r9, r9
	stw	r9, 0(r25)

d2030 2
a2031 3
	ldw	6*4(r9), r17	/* bit */
	ldw	7*4(r9), r25	/* &intrcnt[pri] */
	or	r17, r24, r24	/* ipending */
a2032 3
	ldw	0(r25), r17
	ldw	5*4(r9), r9	/* share */
	addi	1, r17, r17
d2034 1
a2034 1
	stw	r17, 0(r25)
d2054 2
a2055 3
	ldw	6*4(r9), r17	/* bit */
	ldw	7*4(r9), r25	/* &intrcnt[pri] */
	or	r17, r24, r24	/* ipending */
a2056 3
	ldw	0(r25), r17
	ldw	5*4(r9), r9	/* share */
	addi	1, r17, r17
d2058 1
a2058 1
	stw	r17, 0(r25)
@


1.134
log
@debranch SMP, have fun
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d161 1
d1066 5
d1077 1
a1078 1
	ldil	L%fpu_curpcb, r1
d1326 1
a1326 1
	stw	r25, 4(r17)
@


1.133
log
@always create a stack frame in cpu_switch() and put a stub
for doing page idle zeroing.
store the kernele stack pointer into pcb instead of trapframe
for debuggers doing stack traces; from kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.132 2004/05/25 22:14:02 mickey Exp $	*/
d2827 2
@


1.132
log
@catcher ptr can be a plabel -- handle that in sigcode
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.131 2004/05/05 02:18:43 mickey Exp $	*/
d2711 3
d2715 1
a2715 1
	stw	rp, HPPA_FRAME_CRP(sp)
d2722 1
d2726 24
a2754 2

switch_search
d2757 1
a2757 3
	comb,<>	r0, t3, gotprocs
	nop

a2758 8
	break	HPPA_BREAK_KERNEL, HPPA_BREAK_SPLLOWER

	/* XXX do idle work here */
	nop ! nop ! nop ! nop ! nop ! nop ! nop ! nop

	ldil	L%cpl, arg0
	b	switch_search
	stw	ret0, R%cpl(arg0)
a2759 1
gotprocs
a2814 1
	ldw     P_MD_REGS(arg1), t1
d2816 1
a2816 1
	ldw     TF_R30(t1), t1
d2838 18
a2855 7
	ldw	P_MD_REGS(arg2), t1
	ldw	TF_R30(t1), t3
	copy	sp, t2
	stw,ma	r3, HPPA_FRAME_SIZE+20*4(sp)
	stw	sp, TF_R30(t1)
	stw	t2, HPPA_FRAME_PSP(sp)
	stw	t3, HPPA_FRAME_ARG(0)(sp)	/* real user's stack */
d2857 2
a2858 16
	/* save callee-save registers */
	stw	r4,   1*4(t2)
	stw	r5,   2*4(t2)
	stw	r6,   3*4(t2)
	stw	r7,   4*4(t2)
	stw	r8,   5*4(t2)
	stw	r9,   6*4(t2)
	stw	r10,  7*4(t2)
	stw	r11,  8*4(t2)
	stw	r12,  9*4(t2)
	stw	r13, 10*4(t2)
	stw	r14, 11*4(t2)
	stw	r15, 12*4(t2)
	stw	r16, 13*4(t2)
	stw	r17, 14*4(t2)
	stw	r18, 15*4(t2)
d2867 3
a2870 1
	ldw	P_MD_REGS(arg1), t1
a2871 1
	ldw	TF_R30(t1), sp
d2875 2
a2876 2
	ldw	HPPA_FRAME_PSP(sp), t2
	ldw	HPPA_FRAME_ARG(0)(sp), t3
d2878 19
a2896 21
	ldw	HPPA_FRAME_ARG(2)(sp), arg0
	ldw	HPPA_FRAME_SL(t2), ret0
	ldw	HPPA_FRAME_CRP(t2), rp
	ldw	 0*4(t2), r3
	ldw	 1*4(t2), r4
	ldw	 2*4(t2), r5
	ldw	 3*4(t2), r6
	ldw	 4*4(t2), r7
	ldw	 5*4(t2), r8
	ldw	 6*4(t2), r9
	ldw	 7*4(t2), r10
	ldw	 8*4(t2), r11
	ldw	 9*4(t2), r12
	ldw	10*4(t2), r13
	ldw	11*4(t2), r14
	ldw	12*4(t2), r15
	ldw	13*4(t2), r16
	ldw	14*4(t2), r17
	ldw	15*4(t2), r18
	stw	t3, TF_R30(t1)
	copy	t2, sp
d2899 1
d2903 2
d2906 1
a2906 1
	stw	arg1, R%curproc(t1)
@


1.131
log
@much easier tlb handler branch patching
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.130 2004/05/04 23:53:07 mickey Exp $	*/
d2912 5
@


1.130
log
@better faster scooter^Winterrupts; miod@@ testing
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.129 2004/04/21 22:25:31 mickey Exp $	*/
a908 2
	ldil	0,r1			! \
	ldo	0(r1), r1		! \
d910 5
a914 32
	bv	0(r1)			! \
	ldi	num, r1

#define	LDILDO(name)			! \
	.export	name, entry		! \
	.label	name			! \
	ldil	L%$name,%r1		! \
	ldo	R%$name(%r1), %r1

#ifdef HP7000_CPU
LDILDO(itlb_s)
LDILDO(itlbna_s)
LDILDO(dtlb_s)
LDILDO(dtlbna_s)
LDILDO(tlbd_s)
#endif

#if defined(HP7100_CPU) || defined(HP7200_CPU)
LDILDO(itlb_t)
LDILDO(itlbna_t)
LDILDO(dtlb_t)
LDILDO(dtlbna_t)
LDILDO(tlbd_t)
#endif

#if defined(HP7100LC_CPU) || defined(HP7300LC_CPU)
LDILDO(itlb_l)
LDILDO(itlbna_l)
LDILDO(dtlb_l)
LDILDO(dtlbna_l)
LDILDO(tlbd_l)
#endif
d917 2
a918 3
	mfctl	pcoq,r9		/* Offset */			! \
	mfctl	pcsq,r8		/* Space  */			! \
	depi	0,31,PGSHIFT,r9	/* align offset to page */
d920 2
a921 3
	mfctl	ior, r9		/* Offset */			! \
	mfctl	isr, r8		/* Space  */			! \
	depi	0,31,PGSHIFT,r9	/* align offset to page */
@


1.129
log
@simplify the fpemu path
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.128 2004/04/08 17:14:50 mickey Exp $	*/
a883 1
	.import TLABEL(name), code	! \
a884 1
	ldil	L%TLABEL(name), r1	! \
d886 2
a887 1
	be	R%TLABEL(name)(sr7, r1)	! \
d954 1
d957 1
a957 1
	mfctl	eirr, r8 ! \
d1949 25
a1973 1
	.export	TLABEL(intr), entry
d1978 1
d1980 5
a1984 1
	/* r8 set to eirr in the INTRPRE */
a1986 1
	nop
d1998 2
d2001 1
d2003 1
a2003 2
	ldil	L%intr_table, r1
	ldo	R%intr_table(r1), r1
d2005 12
a2016 3
	addi	32, r1, r1
	bb,>=	r8, 31, $intr_ffs
	shd	r0, r8, 1, r8
d2018 8
a2025 19
	ldb	2-32(r1), r17
	ldw	4-32(r1), r9
	subi,<>	1, r17, r0
	bv,n	r0(r9)
	nop

	mfctl	sar, r25
	ldb	1-32(r1), r9
	mtsar	r9
	vdepi	1, 1, r24
	mtsar	r25

	ldb	0-32(r1), r9
	ldil	L%intrcnt, r25
	ldo	R%intrcnt(r25), r25
	sh2add	r9, r25, r25
	ldw	0(r25), r17
	addi	1, r17, r17
	stw	r17, 0(r25)
d2027 1
d2029 2
a2030 2
	comb,<>	r0, r8, $intr_ffs
	nop
d2032 2
a2033 2
	ldil	L%ipending, r17
	stw	r24, R%ipending(r17)
d2036 6
a2041 3
	ldil	L%imask, r9
	ldo	R%imask(r9), r9
	ldwx,s	r17(r9), r16
d2043 1
a2043 1
	andcm,=	r24, r16, r0
d2051 10
a2060 1
	.export	gsc_intr, entry
a2061 3

	ldw	8-32(r1), r9	/* arg: ioreg */
	mtctl	r1, tr7
d2064 1
a2064 2
	ldw	12-32(r1), r1	/* next: sub-intr_table */

d2073 1
a2073 1
	copy	r1, r9
d2075 4
a2078 10
	mfctl	sar, r25
	ldb	1-32(r1), r17
	mtsar	r17
	vdepi	1, 1, r24
	mtsar	r25

	ldb	0-32(r1), r17
	ldil	L%intrcnt, r25
	ldo	R%intrcnt(r25), r25
	sh2add	r17, r25, r25
d2080 1
d2082 1
d2085 1
a2085 6
	ldw	16-32(r1), r17
	comb,<>,n r0, r17, $gsc_share
	ldo	32(r17), r1

	b	$gsc_intr_loop
	copy	r9, r1
d2088 2
a2089 1
	.export	dino_intr, entry
d2091 1
a2091 3
	ldw	8-32(r1), r9	/* arg: ioreg */
	mtctl	r1, tr7
	ldw	12(r9), r16	/* irr0 */
a2092 1
	ldw	12-32(r1), r1	/* next: sub-intr_table */
d2101 1
a2101 1
	copy	r1, r9
d2103 4
a2106 10
	mfctl	sar, r25
	ldb	1-32(r1), r17
	mtsar	r17
	vdepi	1, 1, r24
	mtsar	r25

	ldb	0-32(r1), r17
	ldil	L%intrcnt, r25
	ldo	R%intrcnt(r25), r25
	sh2add	r17, r25, r25
d2108 1
d2110 1
d2113 1
a2113 6
	ldw	16-32(r1), r17
	comb,<>,n r0, r17, $dino_share
	ldo	32(r17), r1

	b	$dino_intr_loop
	copy	r9, r1
@


1.128
log
@kill misplaced comment
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.127 2004/04/08 17:10:18 mickey Exp $	*/
d1038 3
d1057 2
a1058 4
	ldw	0(r9), r1
	depi	0, HPPA_FPU_T_POS, 1, r1
	stw	r1, 0(r9)
	ldw	8(r9), r1
d1061 1
a1061 1
	fdc	r0(r9)
d1131 1
a1132 1
	comb,=,n r16, r0, $fpusw_nosave
d1136 3
a1138 1
	copy	r16, arg0
d1142 1
a1142 1
	ldo	PCB_FPREGS+U_PCB(arg0), arg0
a1146 1

d1150 1
a1151 1
	ldo	31*8+PCB_FPREGS+U_PCB(r9), r17
@


1.127
log
@repair pcxs/t confoosion
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.126 2004/04/07 18:24:19 mickey Exp $	*/
a1287 4
	/*
	 * from the 7100lc ers, pg.6:
	 * pa7100 provides cr28 for dtlb traps only
	 */
@


1.126
log
@update copyright; miod@@ is fine w/ files where he holds it too
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.125 2004/04/06 18:33:50 mickey Exp $	*/
a922 8
LDILDO(itlb_x)
LDILDO(itlbna_x)
LDILDO(dtlb_x)
LDILDO(dtlbna_x)
LDILDO(tlbd_x)
#endif

#ifdef HP7100_CPU
d930 1
a930 1
#ifdef HP7200_CPU
a1255 1
$tlbd_x
a1268 2
$itlb_x
$itlbna_x
a1285 2
$dtlb_x
$dtlbna_x
a1726 1
ALTENTRY(desidhash_x)
@


1.125
log
@in cpu_exit() make sure to flush the fpu operation (store fr0)
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.124 2004/04/06 18:25:39 mickey Exp $	*/
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Michael Shalayeff.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.124
log
@repair last: proper unimplemented'' trap check
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.123 2004/04/02 20:56:31 mickey Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998-2003 Michael Shalayeff
d166 1
d2194 8
@


1.123
log
@repair fcnv* emulation.
generate proper signals/siginfo.
partially repairs the "otto" case.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.122 2004/03/09 04:43:55 mickey Exp $	*/
d1064 1
a1064 2
	extru	r1, 5, 6, r1
	bb,<,n	r1, HPPA_FPU_UNMPL, excpt_notrap
@


1.122
log
@faster cache flushing for fpu context (after save or emulation)
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.121 2003/12/17 15:35:40 miod Exp $	*/
d1065 1
a1065 1
	comib,<>,n HPPA_FPU_UNMPL, r1, excpt_notrap
a1070 1
	stw	r0, 8(r9)
d2307 1
a2307 1
	mfctl	cr30, arg0
d2309 13
a2321 8
	fdc,m	r1(arg0)
	fdc,m	r1(arg0)
	fdc,m	r1(arg0)
	fdc,m	r1(arg0)
	fdc,m	r1(arg0)
	fdc,m	r1(arg0)
	fdc,m	r1(arg0)
	fdc	r0(arg0)
d2363 9
a2371 1
	comb,<>	r0, r1, TLABEL(all)
d2374 1
@


1.121
log
@Always use the nitty-gritty name for cr16.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.120 2003/11/24 19:27:03 mickey Exp $	*/
d2229 10
a2238 15
	fdc	r0(arg0)
	ldo	-56(arg0), arg0
	fdc	r0(arg0)
	ldo	-32(arg0), arg0
	fdc	r0(arg0)
	ldo	-32(arg0), arg0
	fdc	r0(arg0)
	ldo	-32(arg0), arg0
	fdc	r0(arg0)
	ldo	-32(arg0), arg0
	fdc	r0(arg0)
	ldo	-32(arg0), arg0
	fdc	r0(arg0)
	ldo	-32(arg0), arg0
	fdc	r0(arg0)
d2309 8
d2318 1
a2318 14
	ldo	32(arg0), arg0
	fdc	r0(arg0)
	ldo	32(arg0), arg0
	fdc	r0(arg0)
	ldo	32(arg0), arg0
	fdc	r0(arg0)
	ldo	32(arg0), arg0
	fdc	r0(arg0)
	ldo	32(arg0), arg0
	fdc	r0(arg0)
	ldo	32(arg0), arg0
	fdc	r0(arg0)
	ldo	32(arg0), arg0
	fdc	r0(arg0)
@


1.120
log
@experimental support for HVT as a 2nd level tlb
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.119 2003/11/07 18:43:25 mickey Exp $	*/
d1988 1
a1988 1
	mtctl	r17, cr16
@


1.119
log
@the the; from rohee@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.118 2003/10/16 03:45:07 mickey Exp $	*/
d1366 8
d1395 8
d1408 41
@


1.118
log
@need to give space reg saving rctr and ccr
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.117 2003/10/15 19:54:13 mickey Exp $	*/
d2764 1
a2764 1
	 * the the new process' kernel stack must be reasonable.
@


1.117
log
@have to fetch the rctr while still in real mode for it is not valid after
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.116 2003/10/15 18:54:55 mickey Exp $	*/
d1526 2
a1527 2
	stw	t1, TF_CR0(t3)
	stw	t2, TF_CR10(t3)
@


1.116
log
@less global name space pollution
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.115 2003/10/05 14:13:28 mickey Exp $	*/
d1513 2
d1525 4
a1625 5

	mfctl	rctr, t1
	mfctl	ccr, t2
	stw	t1, TF_CR0(t3)
	stw	t2, TF_CR10(t3)
@


1.115
log
@reload the itmr as soon as we get the intr to avoid lagging on slower machines
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.114 2003/09/29 19:23:02 mickey Exp $	*/
d147 6
a152 2
	BSS(cpu_hzticks, 4)	/* itmr ticks in one hz */
	BSS(cpu_itmr, 4)	/* itmr value at the most recent clk int */
@


1.114
log
@dino/cujo pci bridge
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.113 2003/09/26 00:07:05 mickey Exp $	*/
d147 3
d964 3
d977 1
a977 1
	CTRAP(intr,T_INTERRUPT,)	/*  4. external interrupt */
d1915 4
d1920 8
a1927 2
	mfctl	eirr, r8
	mtctl	r8, eirr	/* ack now */
d1929 1
@


1.113
log
@typos in tlb stats vars' export
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.112 2003/09/25 22:17:40 mickey Exp $	*/
d2002 39
@


1.112
log
@provide a function to enable accel io on pcxl2 and use it on the fb
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.111 2003/08/07 19:23:52 mickey Exp $	*/
d1206 1
a1206 1
	.export	dtlb_c, data
d1208 1
a1208 1
	.export	dtlb_c, data
@


1.111
log
@be more careful when loading trap_tmp_save and a bit better sigcode
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.110 2003/08/05 02:04:58 mickey Exp $	*/
d1721 15
@


1.110
log
@support for shared interrupts as required by isa/eisa/pci. remove a gsckbc kludge; miod@@ testing
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.109 2003/07/15 18:15:41 mickey Exp $	*/
d111 3
a113 2
$trap_tmp_save			/* XXX assumed to be aligned on 2048 */
	.block	TF_PHYS		/* XXX must be aligned to 64 */
d750 1
d841 1
d1408 1
d1565 1
d2804 3
a2806 4
	blr	r0, rp
	bv,n	r0(arg3)
	nop
	copy	r3, arg0
d2808 1
d2812 2
a2814 1
	ldil	L%SYSCALLGATE, r1
@


1.109
log
@hptmask goes away as a register and frees one tmp cr
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.108 2003/05/07 18:48:12 mickey Exp $	*/
d1898 1
a1898 1
	addi	16, r1, r1
d1902 2
a1903 2
	ldb	2-16(r1), r17
	ldw	4-16(r1), r9
d1909 1
a1909 1
	ldb	1-16(r1), r9
d1914 1
a1914 1
	ldb	0-16(r1), r9
d1945 1
a1945 1
	ldw	8-16(r1), r9	/* arg: ioreg */
d1949 5
a1953 1
	ldw	12-16(r1), r1	/* next: sub-intr_table */
d1955 1
a1955 1
	addi	16, r1, r1
d1959 2
d1962 1
a1962 1
	ldb	1-16(r1), r17
d1967 1
a1967 1
	ldb	0-16(r1), r17
d1975 3
a1977 2
	comb,<>	r0, r16, $gsc_ffs
	nop
d1979 2
a1980 2
	b	$intr_cont
	mfctl	tr7, r1
@


1.108
log
@disable profiling for tlb fault handlers
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.107 2003/05/07 18:23:14 mickey Exp $	*/
d691 1
a691 1
	mfctl	hptmask, arg1
d693 1
a693 1
	stw	arg1, TF_CR24-TRAPFRAME_SIZEOF(sr1, t3)
a694 1
	mfctl	vtop, arg0
a695 1
	stw	arg0, TF_CR25-TRAPFRAME_SIZEOF(sr1, t3)
a1193 10
	/* Compute the hpt entry ptr */
#define	HPTENT \
	extru	r9, 23, 24, r16		/* r16 = (offset >> 8) */	! \
	zdep	r8, 22, 16, r24		/* r24 = (space << 9) */	! \
	mfctl	hptmask, r17		/* r17 = sizeof(HPT)-1 */	! \
	xor	r16, r24, r24		/* r24 ^= r16 */		! \
	and	r17, r24, r24		/* r24 &= r17 */		! \
	mfctl	vtop, r16		/* r16 = address of HPT table */! \
	or	r16, r24, r24		/* r24 = HPT entry */

d1616 1
a1616 1
	mfctl	hptmask, t2
d1618 1
a1618 1
	stw	t2, TF_CR24(t3)
a1619 1
	mfctl	vtop, t1
a1620 1
	stw	t1, TF_CR25(t3)
@


1.107
log
@exit stack is not used anymore. fpemu and emergency are fine w/ just a page per face
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.106 2003/04/07 16:20:38 mickey Exp $	*/
d1212 1
a1212 1
#if 1
@


1.106
log
@s/HP9000/HP 9000/; from weissmanndude
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.105 2003/02/18 21:06:43 mickey Exp $	*/
d107 2
a108 3
#define	EXIT_STACKSIZE	(2*NBPG)
#define	EMRG_STACKSIZE	(2*NBPG)
#define	FPEMU_STACKSIZE	(4*NBPG)
@


1.105
log
@gsc_intr is a leaf
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.104 2003/02/12 00:43:08 mickey Exp $	*/
d2393 1
a2393 1
 * across function calls.  According to the "HP9000 Series 800 Assembly
@


1.104
log
@do not filter the coprocessor uid on the fpu context switch.
it will be emulated later or a trap generated appropriately.
this way we do not have to share the knowledge of the present
units all over the sources and keep it relatively easy.

this fixes the random sig4 seen before.
apparently it was caused by the xmpy instruction
triggering the fpu context switch and being of a
problem for the existing uid check to parse.

also force the fpu context reload after the exception
being taken for the fpu or other coprocessor.

reload r1 with iir after load/store emulation.

add a comment on r1 being shadowed on cpu context save before emulation.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.103 2003/01/15 12:33:34 mickey Exp $	*/
d1958 1
a1958 1
ENTRY(gsc_intr,0)
@


1.103
log
@there is no machine/gprof.h
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.102 2003/01/14 12:09:53 mickey Exp $	*/
d1092 6
a1097 3
	extru	r8, 25, 3, r9	/* only fpu coprocessor emulation now */
	comib,<< 4, r9, TLABEL(all)
	ldi	T_ILLEGAL, r1
d1105 3
d1120 1
d2130 1
d2208 1
a2208 1
#ifdef DDB1
@


1.102
log
@include the _l tlb functions for 7300lc as well; pt put by the weissmanndude
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.101 2003/01/09 22:27:08 miod Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998-2002 Michael Shalayeff
a81 3
#ifdef	GPROF
#include <machine/gprof.h>
#endif
@


1.101
log
@Remove fetch(9) and store(9) functions from the kernel, and replace the few
remaining instances of them with appropriate copy(9) usage.

ok art@@, tested on all arches unless my memory is non-ECC
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.100 2002/12/17 22:46:31 miod Exp $	*/
d946 1
a946 1
#ifdef HP7100LC_CPU
d1321 1
a1321 1
#ifdef HP7100LC_CPU
d1728 1
a1728 1
#ifdef HP7100LC_CPU
@


1.100
log
@Export a few more symbols to kvm realm; ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.99 2002/12/17 21:54:25 mickey Exp $	*/
a2443 49

	.align	32

#define	FUSUX(name)				  \
LEAF_ENTRY(name)				! \
	ldil	L%VM_MAXUSER_ADDRESS, t1	! \
	comb,>>= arg0, t1, fusubadaddr		! \
	ldil	L%curproc, t1			! \
	ldw	R%curproc(t1), t1		! \
	ldw	P_ADDR(t1), t1			! \
	ldil	L%fusufault, t2			! \
	ldo	R%fusufault(t2), t2		! \
	ldw	U_PCB+PCB_ONFAULT(t1), r1	! \
	stw	t2, U_PCB+PCB_ONFAULT(t1)	! \
	ldw	U_PCB+PCB_SPACE(t1), t2		! \
	mtsp	t2, sr1

#define	FUX(name,insn)				  \
	FUSUX(name)				! \
	insn	0(sr1, arg0), ret0		! \
	mtsp	r0, sr1				! \
	bv	r0(rp)				! \
	stw	r1, U_PCB+PCB_ONFAULT(t1)	! \
EXIT(name)

#define	SUX(name,insn)				  \
	FUSUX(name)				! \
	insn	arg1, 0(sr1, arg0)		! \
	mtsp	r0, sr1				! \
	bv	r0(rp)				! \
	stw	r1, U_PCB+PCB_ONFAULT(t1)	! \
EXIT(name)

LEAF_ENTRY(fusufault)
	mtsp	r0, sr1
	stw	r1, U_PCB+PCB_ONFAULT(t1)
ALTENTRY(fusubadaddr)
	bv	0(rp)
	ldi	-1, ret0
EXIT(fusuexit)

FUX(fubyte,   ldb)
FUX(fusword,  ldh)
FUX(fuword,   ldw)
FUX(fuswintr, ldh)
SUX(subyte,   stb)
SUX(susword,  sth)
SUX(suword,   stw)
SUX(suswintr, sth)
@


1.99
log
@real interrupts/spl framework.
tested on 712/* 715/100, 715/33 which main cpu/bus types.
miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.98 2002/12/09 18:36:33 mickey Exp $	*/
d119 1
d122 1
d124 1
d142 1
@


1.98
log
@update utah-u copyright from the newer pmk snap; 10x to mike hibler for rolling one just for this
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.97 2002/11/27 21:47:14 mickey Exp $	*/
d69 1
a69 1
 * 	Utah $Hdr: locore.s 1.63 95/01/20$
a79 1
#include <machine/intr.h>
d132 1
a132 1
	.asciz	"lev9"
a138 1
	.asciz	"clock"
d140 5
a144 1
	.align	NBPG
a159 8
	.export netisr, data
	.align 16
netisr
	.word	0
	.export sir, data
	.align 16
sir
	.word	0
a297 1
	nop
d346 1
a346 1
	mtctl	r0, eiem	/* IPL_NONE */
a462 1
	nop
a497 1
	nop
a739 1
	/* check for AST ? XXX */
d970 1
a970 1
	ATRAP(intr,T_INTERRUPT)		/*  4. external interrupt */
d1890 93
a1982 1
	.align	32
d2004 1
d2020 22
a2041 4
$ibrk_setpsw_tovirt

	b	$ibrk_exit
	ldw	HPPA_FRAME_PSP(sp), sp
d2049 5
a2053 4
	mfctl	pcoq, r8
	mtctl	r8, pcoq
	ldo	4(r8), r8
	mtctl	r8, pcoq
d2441 1
a2441 1
	.align	NBPG	/* let's fit 'em on a single page */
d2490 1
a2490 1
	.align	64
d2643 4
d2657 2
a2658 3
	 * arg3: spl
	 * t1:	&whichqs
	 * t2:	old curproc
a2662 2
	/* arg3 = splhigh() */
	mfctl	eiem, arg3
a2663 3
	ldi	-1, t2
idle_loop
	mtctl	r0, eiem
a2664 1

d2668 2
a2669 1
	mtctl	t2, eiem
d2674 3
a2676 2
	b	idle_loop
	nop
a2758 1
	stw	rp, HPPA_FRAME_CRP(sp)
d2801 1
d2821 2
a2824 1
	mtctl	arg3, eiem
@


1.97
log
@no wrapper arounf hardclock(), use CPU_CLOCKUPDATE, real microtime; miod ok
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.96 2002/11/14 01:41:55 mickey Exp $	*/
a36 13
 * Copyright (c) 1990,1991,1992,1994 The University of Utah and
 * the Computer Systems Laboratory (CSL).  All rights reserved.
 *
 * THE UNIVERSITY OF UTAH AND CSL PROVIDE THIS SOFTWARE IN ITS "AS IS"
 * CONDITION, AND DISCLAIM ANY LIABILITY OF ANY KIND FOR ANY DAMAGES
 * WHATSOEVER RESULTING FROM ITS USE.
 *
 * CSL requests users of this software to return to csl-dist@@cs.utah.edu any
 * improvements that they make and grant CSL redistribution rights.
 *
 *	Utah $Hdr: locore.s 1.62 94/12/15$
 */
/*
d49 21
@


1.96
log
@get more use of the shadowed regs
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.95 2002/10/29 03:03:38 mickey Exp $	*/
a2434 35

/*
 * adjust the time value
 * XXX: do it the easy way, later we will calculate actual fuzz from itmr
 */
LEAF_ENTRY(microtime)

	/* t4 = splhigh() */
	mfctl	eiem, t4
	mtctl	r0, eiem

	.import time, data
	ldil	L%time, t3
	ldo	R%time(t3), t3
	ldw	0(t3), t1
	ldw	4(t3), t2

	/* splx(t4) */
	mtctl	t4, eiem

	ldil	L%-1000000, t3
	ldo	R%-1000000(t3), t3

	addi	1, t2, t2
	addb,<,n t2, t3, microtime_no

	addi	1, t1, t1
	copy	t3, t2

microtime_no
	stwm	t1, 4(arg0)
	bv	(rp)
	stw	t2, 0(arg0)

EXIT(microtime)
@


1.95
log
@no need to restore shadowed reg, shaves 10% from runtime for tlb handler on pcxl, more on pcxs/pcxt due to conditional pte ref update; tested on pcxt,pcxl by me on pcxs by miod
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.94 2002/10/25 22:02:19 mickey Exp $	*/
d105 1
a105 1
#define	FPEMU_STACKSIZE	(2*NBPG)
d1039 2
a1040 1
	mtctl	arg0, tr5
d1044 1
a1044 1
	mfctl	cr30, arg0
d1046 1
a1048 1
	mfctl	cr30, arg0
d1052 1
a1052 1
	ldw	0(arg0), r1
d1054 1
a1054 1
	ldw	8(arg0), r1
d1058 1
a1058 1
	ldw	0(arg0), r1
d1060 3
a1062 4
	stw	r1, 0(arg0)
	ldw	8(arg0), r1
	stw	r0, 8(arg0)
	fdc	r0(arg0)
d1065 1
a1065 1
	mfctl	tr5, arg0
a1067 2
	fdc	r0(arg0)
	mfctl	tr5, arg0
a1504 1
	mfctl	tr7, r1
a1894 3
	mtctl	t1, tr2
	mtctl	t2, tr3

d1896 2
a1897 2
	mfctl	pcoq, t1
	extru,=	t1, 31, 2, r0
d1902 7
a1908 7
	ldil	L%etext, t2
	ldo	R%etext(t2), t2
	comb,>>=,n t1, t2, $ibrk_bad

	mfctl	iir, t1
	extru	t1, 31, 5, t2
	comib,<>,n HPPA_BREAK_KERNEL, t2, $ibrk_bad
d1911 3
a1913 3
	extru	t1, 18, 13, t2
	comib,=,n HPPA_BREAK_GET_PSW, t2, $ibrk_getpsw
	comib,=,n HPPA_BREAK_SET_PSW, t2, $ibrk_setpsw
a1916 1
	mfctl	tr3, t2
d1918 1
a1918 1
	mfctl	tr2, t1
d1940 4
a1943 7
	mfctl	pcoq, t1
	mtctl	t1, pcoq
	ldo	4(t1), t1
	mtctl	t1, pcoq
	mfctl	tr3, t2
	mfctl	tr2, t1
	mfctl	tr7, r1
d1982 1
a1982 1
	ldo	-60(arg0), arg0
d2007 1
a2007 2
	mtctl	sp, tr3
	mtctl	r31, tr2
d2019 2
a2020 2
	stw	r8 , TF_R8 (r31)
	stw	r9 , TF_R9 (r31)
d2027 2
a2028 2
	stw	r16, TF_R16(r31)
	stw	r17, TF_R17(r31)
d2036 2
a2037 2
	stw	r24, TF_R24(r31)
	stw	r25, TF_R25(r31)
d2042 2
a2043 4
	mfctl	tr2, t2
	mfctl	tr3, t1
	stw	t1, TF_R30(r31)
	stw	t2, TF_R31(r31)
a2084 1
	mtsar	r1
d2087 1
d2089 1
a2089 1
#ifdef DDB
d2094 2
a2095 2
	ldw	TF_R8 (r31), r8
	ldw	TF_R9 (r31), r9
d2102 2
a2103 2
	ldw	TF_R16(r31), r16
	ldw	TF_R17(r31), r17
d2111 2
a2112 2
	ldw	TF_R24(r31), r24
	ldw	TF_R25(r31), r25
@


1.94
log
@fake intrcnt (for now) such that vmstat works (;
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.93 2002/10/17 20:35:24 mickey Exp $	*/
d1255 1
d1257 1
a1257 1
	mfctl	tr7, r1							! \
a1346 1
	mfctl	tr7, r1							! \
@


1.93
log
@use shadows on fpu cxsw (and fix arg0 trashing), do not restore shadowed regs before rfir
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.92 2002/10/07 15:40:39 mickey Exp $	*/
d110 24
@


1.92
log
@also s/_PSW/_PSL/
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.91 2002/10/07 15:32:37 mickey Exp $	*/
d1066 3
a1068 3
	mfctl	iir, r1
	extru	r1, 5, 6, r1	/* no sfu implementation right now */
	comib,=	4, r1, TLABEL(all)
d1071 2
a1072 3
	mfctl	iir, r1
	extru	r1, 25, 3, r1	/* only fpu coprocessor emulation now */
	comib,<< 4, r1, TLABEL(all)
d1102 1
a1102 2
	copy	arg0, arg1
	ldil	L%fpu_curpcb, arg0
d1104 1
a1104 1
	ldw	R%fpu_curpcb(arg0), arg0
d1106 2
a1107 2
	comb,=,n arg0, r9, $fpusw_done
	comb,=,n arg0, r0, $fpusw_nosave
d1109 1
d1111 1
d1117 1
d1123 37
a1159 38
	ldw	R%fpu_csw(r1), arg0
	ldo	1(arg0), arg0
	stw	arg0, R%fpu_csw(r1)

	ldo	31*8+PCB_FPREGS+U_PCB(r9), arg0

	fldds,ma -8(arg0), fr31
	fldds,ma -8(arg0), fr30
	fldds,ma -8(arg0), fr29
	fldds,ma -8(arg0), fr28
	fldds,ma -8(arg0), fr27
	fldds,ma -8(arg0), fr26
	fldds,ma -8(arg0), fr25
	fldds,ma -8(arg0), fr24
	fldds,ma -8(arg0), fr23
	fldds,ma -8(arg0), fr22
	fldds,ma -8(arg0), fr21
	fldds,ma -8(arg0), fr20
	fldds,ma -8(arg0), fr19
	fldds,ma -8(arg0), fr18
	fldds,ma -8(arg0), fr17
	fldds,ma -8(arg0), fr16
	fldds,ma -8(arg0), fr15
	fldds,ma -8(arg0), fr14
	fldds,ma -8(arg0), fr13
	fldds,ma -8(arg0), fr12
	fldds,ma -8(arg0), fr11
	fldds,ma -8(arg0), fr10
	fldds,ma -8(arg0), fr9
	fldds,ma -8(arg0), fr8
	fldds,ma -8(arg0), fr7
	fldds,ma -8(arg0), fr6
	fldds,ma -8(arg0), fr5
	fldds,ma -8(arg0), fr4
	fldds,ma -8(arg0), fr3
	fldds,ma -8(arg0), fr2
	fldds,ma -8(arg0), fr1
	fldds     0(arg0), fr0	/* fr0 must be restored last */
d1162 1
a1162 1
	stw	arg0, R%fpu_curpcb(r1)
a1164 1
	copy	arg1, arg0
d1930 1
a1930 1
	rfi
a2111 1
	mfctl	tr7, r1
@


1.91
log
@s/PSW_/PSL_/ to match other archs
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.90 2002/10/07 14:38:34 mickey Exp $	*/
d240 1
a240 1
	rsm	RESET_PSW, r0
d296 1
a296 1
	rsm	RESET_PSW, r0
d814 1
a814 1
	rsm	RESET_PSW, r0
@


1.90
log
@on implementations w/ fpu included unimplemented instructions
are signaled through the exception trap w/ invalid opcode marked
instruction in the exception registers, not through the emulation
trap (as long as the fpu is enabled, of  course).
parse emulation from the exception trap as well as the emulation
trap and fix the dispatcher into usable condition.
parse invalid op exception on trap and signal the user appropriately.
reset the exception on exec and for child on fork.
the later is appropriate since exceptions are delayed until next
fpu instruction, which was in the parent indeed, let him get it.
save parent's fpu context on fork before cipying it, if the
parent owned the fpu.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.89 2002/09/15 09:39:36 mickey Exp $	*/
d223 1
a223 1
	ldi	PSW_Q|PSW_I, arg2
d436 1
a436 1
	ldi	PSW_Q, arg0 /* (!pdc_flag && args[0] == PDC_PIM)? PSW_M:0) */
d1713 1
a1713 1
	rsm	(PSW_R|PSW_I), t4
d1741 1
a1741 1
	rsm	(PSW_R|PSW_I), t4
d1801 1
a1801 1
	depi	0, PSW_I_POS, 1, %arg2
d1833 1
a1833 1
	depi	0, PSW_I_POS, 1, %arg2
d1861 1
a1861 1
	depi	0, PSW_I_POS, 1, %arg2
@


1.89
log
@be more precise on what we save on traps. flush fpu regs in pcb since they are possibly accessed through non-coherent mappings
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.88 2002/09/15 09:37:18 mickey Exp $	*/
d958 1
a958 1
	ATRAP(excpt,T_EXCEPTION)	/* 14. assist exception trap */
d1011 40
d1052 1
a1052 1
LEAF_ENTRY(TLABEL(emu))
d1066 11
d1078 21
d1103 1
a1103 1
	mtctl	arg0, tr5
d1105 1
a1105 1
	mfctl	cr30, r1
d1108 2
a1109 2
	comb,=,n arg0, r1, $fpusw_done
	comb,=,n r0, arg0, $fpusw_nosave
d1112 1
a1112 1
	.import	fpu_save, entry
d1126 1
a1126 2
	mfctl	cr30, r1
	ldo	31*8+PCB_FPREGS+U_PCB(r1), arg0
d1165 2
a1166 3
	mfctl	tr7, r1
	mfctl	tr5, arg0
	rfi
d1594 1
d1596 1
a1596 1
	/* XXX save ccr here w/ rctr */
d1989 1
a1989 1
	 * Emulate FPU/SFU if none/disabled
d1993 1
a1993 1
ENTRY($fpu_emulate,0)
a1998 1
	ldo	R%TRAPFRAME_SIZEOF+HPPA_FRAME_SIZE(r31), sp
d2001 18
a2018 1
	stw	r3 , TF_R2 (r31)
d2030 5
a2035 1
	mfctl	iir, arg0
d2039 5
a2043 5
	extru,<> arg0, 10, 1, r0
	extru,= arg0, 11, 1, r0
	or,tr	r0, r0, r0
	.call
	bl,n	$sfu_emu, rp
d2048 1
a2048 2
	mfctl	iir, arg0
	/* arg3 -- regs */
d2054 17
d2076 30
d2107 2
a2108 15
	ldw	TF_R28(r31), r27
	mtctl	r27, tr5
	ldw	TF_R27(r31), r27
	ldw	TF_R26(r31), r26
	ldw	TF_R25(r31), r25
	ldw	TF_R24(r31), r24
	ldw	TF_R23(r31), r23
	ldw	TF_R22(r31), r22
	ldw	TF_R21(r31), r21
	ldw	TF_R20(r31), r20
	ldw	TF_R19(r31), r19
	ldw	TF_R3 (r31), r3
	ldw	TF_R2 (r31), r2
	mfctl	tr3, sp
	mfctl	tr2, r31
d2110 2
a2111 2
	comb,<>	r0, ret0, TLABEL(all)
	mfctl	tr5, ret0
d2114 1
a2114 1
	rfi
a2116 6

	.export	$sfu_emu, entry
ENTRY($sfu_emu,0)
	bv	r0(rp)
	ldo	1(r0), ret0	/* none supported by now */
EXIT($sfu_emu)
@


1.88
log
@fix for an interrupt happening in the 2 insn window during a syscall, comment added; from fredette@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.87 2002/09/12 05:31:34 mickey Exp $	*/
d803 2
d1897 15
d1913 1
a1913 1
	nop
a1929 1
	stw	r1 , TF_R1 (r31)
d1931 1
d1946 1
d1981 1
@


1.87
log
@reset want_resched earlier, set curproc after we are done w/ switching, rearrange syscall savements
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.86 2002/09/10 22:43:49 mickey Exp $	*/
d1363 17
d1381 1
d1383 3
a1385 1
	bb,>=	t1, 31, $trap_from_kernel
@


1.86
log
@copy syscall args in the syscall() based on the
amount given in the sysent.
deal w/ the words swappage phenomena due to reverse
long word storage on the stack and that being
reverse copied by words yielding long word being word swapped.
do it only for syscall(2) and __syscall(2) since that's how those
w/ long word args syscalls get used (for proper alignment).
discussed and ideas from: deraadt@@, drahn@@ and fredette@@

note: this might be a good point for a regress.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.85 2002/09/10 21:20:23 mickey Exp $	*/
d575 6
d582 3
a584 1
	ldo	HPPA_FRAME_SIZE+HPPA_FRAME_MAXARGS(t3), sp
d603 1
a621 11
	/* gotta save the args, in case we gonna restart */
	stw	arg3, TF_R23-TRAPFRAME_SIZEOF(sr1, t3)
	stw	arg2, TF_R24-TRAPFRAME_SIZEOF(sr1, t3)
	stw	arg1, TF_R25-TRAPFRAME_SIZEOF(sr1, t3)
	stw	arg0, TF_R26-TRAPFRAME_SIZEOF(sr1, t3)
	stw	r27, TF_R27-TRAPFRAME_SIZEOF(sr1, t3)	/* dp */
	stw	r0, 0(sr1, t3)	/* terminate frame */
	copy	r0 , r3
	stw	r0, HPPA_FRAME_PSP(sr1, sp)
	stw	r0, HPPA_FRAME_CRP(sr1, sp)

d636 1
a636 1
	ldil	TFF_LAST|TFF_SYS, arg1
a639 1
	copy	arg0, arg1
d643 1
a643 1
	stw	arg1, TF_SR1-TRAPFRAME_SIZEOF(sr1, t3)
d2469 3
a2481 3
	ldil	L%want_resched, t3
	stw	r0, R%want_resched(t3)

a2506 3
	ldil	L%curproc, t1
	stw	arg1, R%curproc(t1)

d2583 2
d2586 1
a2586 2
	mtctl	arg3, eiem

@


1.85
log
@rework the fpu csw a bit better and move non-trap related stuff to later
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.84 2002/09/09 18:32:27 mickey Exp $	*/
a575 1
	copy	sp, t4
a622 28

	/*
	 * Copy Arguments
	 * unfortunately mmap() under bsd requires 7 words;
	 * linux is confined to 5, and hpux to 6.
	 * assuming the `long' syscall it gives us the maximum
	 * 9 words, which very much overkill for an average of 3.
	 * we keep it at 10, since bundling will keep it
	 * at the same speed as 9 anyway.
	 *
	 * TODO: setup the onfault handler
	 */
	stw	arg0, 1*4(sr1, t3)	/* XXX can use ,bc */
	stw	arg1, 2*4(sr1, t3)
	stw	arg2, 3*4(sr1, t3)
	stw	arg3, 4*4(sr1, t3)
	ldw	HPPA_FRAME_ARG( 4)(sr2, t4), arg0
	ldw	HPPA_FRAME_ARG( 5)(sr2, t4), arg1
	ldw	HPPA_FRAME_ARG( 6)(sr2, t4), arg2
	ldw	HPPA_FRAME_ARG( 7)(sr2, t4), arg3
	stw	arg0, 5*4(sr1, t3)
	stw	arg1, 6*4(sr1, t3)
	stw	arg2, 7*4(sr1, t3)
	stw	arg3, 8*4(sr1, t3)
	ldw	HPPA_FRAME_ARG( 8)(sr2, t4), arg0
	ldw	HPPA_FRAME_ARG( 9)(sr2, t4), arg1
	stw	arg0, 9*4(sr1, t3)
	stw	arg1,10*4(sr1, t3)
@


1.84
log
@no need for a fdc there
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.83 2002/09/05 21:37:18 mickey Exp $	*/
d988 1
a988 5
#ifdef FPEMUL
	CTRAP(excpt,T_EXCEPTION,)	/* 14. assist exception trap */
#else
	ATRAP(excpt,T_EXCEPTION)
#endif
a1040 1

a1042 2
	/* restore %r1 from CTRAP() */
	mfctl	tr7, r1
a1054 9
	mtctl	t1, tr2
	mtctl	t2, tr3
	mtctl	t3, tr5

	ldil	L%fpu_curpcb, t1
	ldw	R%fpu_curpcb(t1), t1

	mfctl	ccr, t3
	mfctl	cr30, t2
d1056 1
d1058 2
a1059 2
	depi	3, 25, 2, t3
	mtctl	t3, ccr
d1061 4
a1064 2
	comb,=,n t1, t2, $fpusw_done
	comb,=,n r0, t1, $fpusw_nosave
d1066 2
a1067 3
#if PCB_FPREGS != 0 || U_PCB != 0
	ldo	PCB_FPREGS+U_PCB(t1), t1
#endif
d1069 6
a1074 32
	fstds,ma fr0 , 8(t3)	/* fr0 must be saved first */
	fstds,ma fr1 , 8(t3)
	fstds,ma fr2 , 8(t3)
	fstds,ma fr3 , 8(t3)
	fstds,ma fr4 , 8(t3)
	fstds,ma fr5 , 8(t3)
	fstds,ma fr6 , 8(t3)
	fstds,ma fr7 , 8(t3)
	fstds,ma fr8 , 8(t3)
	fstds,ma fr9 , 8(t3)
	fstds,ma fr10, 8(t3)
	fstds,ma fr11, 8(t3)
	fstds,ma fr12, 8(t3)
	fstds,ma fr13, 8(t3)
	fstds,ma fr14, 8(t3)
	fstds,ma fr15, 8(t3)
	fstds,ma fr16, 8(t3)
	fstds,ma fr17, 8(t3)
	fstds,ma fr18, 8(t3)
	fstds,ma fr19, 8(t3)
	fstds,ma fr20, 8(t3)
	fstds,ma fr21, 8(t3)
	fstds,ma fr22, 8(t3)
	fstds,ma fr23, 8(t3)
	fstds,ma fr24, 8(t3)
	fstds,ma fr25, 8(t3)
	fstds,ma fr26, 8(t3)
	fstds,ma fr27, 8(t3)
	fstds,ma fr28, 8(t3)
	fstds,ma fr29, 8(t3)
	fstds,ma fr30, 8(t3)
	fstds    fr31, 0(t3)
d1079 40
a1118 39
	ldil	L%fpu_csw, t1
	ldw	R%fpu_csw(t1), t3
	ldo	1(t3), t3
	stw	t3, R%fpu_csw(t1)

	ldo	31*8+PCB_FPREGS+U_PCB(t2), t3

	fldds,ma -8(t3), fr31
	fldds,ma -8(t3), fr30
	fldds,ma -8(t3), fr29
	fldds,ma -8(t3), fr28
	fldds,ma -8(t3), fr27
	fldds,ma -8(t3), fr26
	fldds,ma -8(t3), fr25
	fldds,ma -8(t3), fr24
	fldds,ma -8(t3), fr23
	fldds,ma -8(t3), fr22
	fldds,ma -8(t3), fr21
	fldds,ma -8(t3), fr20
	fldds,ma -8(t3), fr19
	fldds,ma -8(t3), fr18
	fldds,ma -8(t3), fr17
	fldds,ma -8(t3), fr16
	fldds,ma -8(t3), fr15
	fldds,ma -8(t3), fr14
	fldds,ma -8(t3), fr13
	fldds,ma -8(t3), fr12
	fldds,ma -8(t3), fr11
	fldds,ma -8(t3), fr10
	fldds,ma -8(t3), fr9
	fldds,ma -8(t3), fr8
	fldds,ma -8(t3), fr7
	fldds,ma -8(t3), fr6
	fldds,ma -8(t3), fr5
	fldds,ma -8(t3), fr4
	fldds,ma -8(t3), fr3
	fldds,ma -8(t3), fr2
	fldds,ma -8(t3), fr1
	fldds     0(t3), fr0	/* fr0 must be restored last */
d1120 2
a1121 2
	ldil	L%fpu_curpcb, t1
	stw	t2, R%fpu_curpcb(t1)
d1124 2
a1125 3
	mfctl	tr5, t3
	mfctl	tr3, t2
	mfctl	tr2, t1
a1129 85
#ifdef FPEMUL
	.export TLABEL(excpt), entry
	/*
	 * Emulate FPU/SFU if none/disabled
	 *
	 * iisq:iioq - exception triggered instruction
	 */
ENTRY(TLABEL(excpt),0)
	mtctl	sp, tr3
	mtctl	r31, tr2

	ldil	L%fpemu_stack, r31
	ldw	R%fpemu_stack(r31), r31
	ldo	R%TRAPFRAME_SIZEOF+HPPA_FRAME_SIZE(r31), sp

	stw	r1 , TF_R1 (r31)
	stw	r2 , TF_R2 (r31)
	stw	r19, TF_R19(r31)
	stw	r20, TF_R20(r31)
	stw	r21, TF_R21(r31)
	stw	r22, TF_R22(r31)
	stw	r23, TF_R23(r31)
	stw	r24, TF_R24(r31)
	stw	r25, TF_R25(r31)
	stw	r26, TF_R26(r31)
	stw	r27, TF_R27(r31)
	stw	r28, TF_R28(r31)
	stw	r29, TF_R29(r31)
	mfctl	sar, r1
	mfctl	iir, arg0
	stw	r1, TF_CR11(r31)

	extru,<> arg0, 10, 1, r0
	extru,= arg0, 11, 1, r0
	or,tr	r0, r0, r0
	.call
	bl,n	$sfu_emu, rp

	.import	fpu_emulate, code
	ldil	L%fpu_emulate,t1
	ldo	R%fpu_emulate(t1),t1
	mfctl	iir, arg0
	/* arg3 -- regs */
	.call
	blr	r0,rp
	bv,n	0(t1)
	nop

	ldil	L%fpemu_stack, r31
	ldw	R%fpemu_stack(r31), r31

	ldw	TF_CR11(r31), r1
	mtsar	r1
	ldw	TF_R29(r31), r29
	ldw	TF_R28(r31), r27
	mtctl	r27, tr5
	ldw	TF_R27(r31), r27
	ldw	TF_R26(r31), r26
	ldw	TF_R25(r31), r25
	ldw	TF_R24(r31), r24
	ldw	TF_R23(r31), r23
	ldw	TF_R22(r31), r22
	ldw	TF_R21(r31), r21
	ldw	TF_R20(r31), r20
	ldw	TF_R19(r31), r19
	ldw	TF_R2 (r31), r2
	mfctl	tr3, sp
	mfctl	tr2, r31

	comb,<>	r0, ret0, TLABEL(all)
	mfctl	tr5, ret0

	mfctl	tr7, r1
	rfi
	nop
EXIT(TLABEL(excpt))

	.export	$sfu_emu, entry
ENTRY($sfu_emu,0)
	bv	r0(rp)
	ldo	1(r0), ret0	/* none supported by now */
EXIT($sfu_emu)

#endif /* FPEMUL */

d1169 1
a1169 1
	ldo	-2(r16), r16			! \
d1911 84
a2300 1

@


1.83
log
@fpu save state is a separate magic function now
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.82 2002/09/05 18:15:23 mickey Exp $	*/
a2656 1
	fdc	r0(t1)
@


1.82
log
@no need for one extra frame
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.81 2002/08/27 16:29:22 mickey Exp $	*/
d1998 37
@


1.81
log
@do not just bail out of the copy loop, but go to the
'done' label for the job finish.
major register missallocation for copyonfault, fix it.
clean the space regs after use.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.80 2002/08/13 05:27:44 mickey Exp $	*/
a345 3
	copy	r3, r1
	copy	sp, r3
	stw,ma	r1, HPPA_FRAME_SIZE(sp)
@


1.80
log
@hypasupadupacarefulness in spstrcpy
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.79 2002/08/03 20:56:42 mickey Exp $	*/
d2223 1
d2231 1
d2237 1
d2256 5
a2260 1
	stw	r1, PCB_ONFAULT+U_PCB(t4)
d2271 4
d2276 8
a2283 11
	ldil	L%curproc, t4
	ldw	R%curproc(t4), t4
	ldil	L%copy_on_fault, t2
	ldw	P_ADDR(t4), t4
	ldo	R%copy_on_fault(t2), t2
	ldw	PCB_ONFAULT+U_PCB(t4), r1
	stw	t2, PCB_ONFAULT+U_PCB(t4)

	ldw	HPPA_FRAME_ARG(4)(sp), ret1
	mfsp	sr1, ret0	/* XXX need this? */
	mfsp	sr2, ret1	/* XXX need this? */
a2285 1
	add	ret1, arg1, ret1
d2290 1
a2290 1
	comb,=	ret1, arg1, $spstrcpy_exit
d2296 4
d2301 1
a2301 2
	mtsp	ret0, sr1
	mtsp	ret1, sr2	/* XXX need this? */
a2302 1
	copy	r0, ret0
d2306 1
a2306 1
	stw	r1, PCB_ONFAULT+U_PCB(t4)
@


1.79
log
@in fact, no need for switch_exit() completely, cpu_exit() handles the reins to the cpu_switch and basta!
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.78 2002/08/03 20:23:00 mickey Exp $	*/
d2267 1
d2269 1
a2270 2
	ldil	L%copy_on_fault, t2
	ldo	R%copy_on_fault(t2), t2
d2274 2
a2275 1
	mfsp	sr2, ret0	/* XXX need this? */
a2288 1
	/* reset fault handler */
d2290 2
a2291 1
	mtsp	ret0, sr2	/* XXX need this? */
d2294 1
a2294 1
	add,=	r0, arg0, r0
@


1.78
log
@reorder stack_alloc() and add a comment
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.77 2002/08/03 20:19:41 mickey Exp $	*/
a2396 2
	ldb	P_STAT(arg0), t1
	comib,=,n SRUN, t1, Lremrunqueue_panic
a2503 3
	comb,<> arg0, t2, sw_qnempty
	nop

d2505 1
a2508 1
sw_qnempty
a2620 24

/*
 * switch_exit(struct proc *p)
 * restore proc0 context and go into cpu_switch to select the next runable
 * process.
 */
	.import	kernel_map, data
	.import	uvmspace_free, code
	.import	uvm_km_free, code
ENTRY(switch_exit,0)

	/* arg0 -- oldproc */
	.import exit2, code
	ldil	L%exit2, t2
	ldo	R%exit2(t2), t2
	.call
	blr	%r0, rp
	bv,n	%r0(t2)
	nop

	.call
	b	switch_search
	copy	r0, arg2	/* no old proc */
EXIT(switch_exit)
@


1.77
log
@store md_regs ptr before interrupts are enabled on syscall, do not store the frame pointer on the stack on traps, just offset back from sp upon return
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.76 2002/08/03 20:07:58 mickey Exp $	*/
d170 5
a174 4
#define	STACK_ALLOC(n,s)		\
	ldil	L%(n), t1		! \
	stw	arg3, R%(n)(t1)		! \
	ldil	L%(s), t2		! \
@


1.76
log
@some more opt and diagnostic checks in set/remrunqueue
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.75 2002/08/03 19:07:53 mickey Exp $	*/
d567 3
a569 3
	ldil	L%curproc, t3
	ldw	R%curproc(sr1, t3), t3
	ldw	P_ADDR(sr1, t3), t2	/* XXX can use ,sl */
d572 3
a574 1
	ldo	NBPG+TRAPFRAME_SIZEOF(t2), t3
d586 1
a586 1
	stw	r28, TF_CR8-TRAPFRAME_SIZEOF(sr1, t3)	/* pidr1 */
a767 2
	fdc	r0(t2)
	ldi	32, t4
a771 2
	fdc	t4(t2)
	sync
d1411 1
a1411 1
	xor,=	r16, r17, r0		/* do not store if unchanged */	! \
a1609 1
	stw	t3, HPPA_FRAME_ARG(1)(sp)
a1703 1
	ldw	HPPA_FRAME_ARG(1)(sp), t3
d1705 1
a1705 1
	ldw	TF_FLAGS(t3), arg0
d1707 1
a1707 1
	nop
d1713 1
a1713 1
	nop
@


1.75
log
@opt {set,rem}runqueue a littlebit
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.74 2002/08/03 19:04:24 mickey Exp $	*/
d2348 1
a2348 1
	comb,<>,n r0, t1, $setrunqueue_panic
d2350 1
a2350 1
	comb,<>,n r0, t1, $setrunqueue_panic
d2352 2
a2353 2
	comib,=,n SRUN, t1, $setrunqueue_ok
$setrunqueue_panic
d2366 1
a2366 1
$setrunqueue_ok
d2374 1
a2374 18
	ldil	L%whichqs, t2
	ldw	R%whichqs(t2), t3
	mtctl	t1, sar
	vdepi	1, 1, t3

#if 0
	/* this actually trashes all the regs we use, be advised ;) */
	copy	t1, arg1
	copy	t4, arg2
	ldil	L%printf, r1
	ldil	L%Lsrqfmt, arg0
	ldo	R%printf(r1), r1
	ldo	R%Lsrqfmt(arg0), arg0
	.call
	blr	%r0, rp
	bv,n	%r0(r1)
	nop
#endif
d2378 1
d2380 1
d2382 1
d2384 1
a2384 4
	stw	t3, R%whichqs(t2)
Lsrqfmt
	.asciz	"setrunqueue: bit=%x, qs=%p\n"
	.align	8
d2400 2
a2423 1
	stw	t4, P_BACK(arg0)
d2428 1
a2428 1
	nop
@


1.74
log
@no need for a stack on exit() since u gets freed in a different context, also s/P_MD/P_MD_REGS
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.73 2002/07/25 04:49:53 mickey Exp $	*/
a2377 1
	stw	t3, R%whichqs(t2)
d2396 1
d2398 1
a2398 1
	stw	t2, P_BACK(arg0)
d2411 1
a2411 2
	extru	t2, 29, 5, t1
	mtsar	t1
d2413 1
a2420 1
	copy	t1, arg2
d2428 1
a2439 3
	comb,<>	t4, arg0, Lqnempty
	nop

d2441 1
a2442 1
Lqnempty
@


1.73
log
@preserve t4 as a saviour for the rp for the vfork() syscall. idea from fredette@@
unroll the tmp copy loop in the trap return and take care of the frame.
remove unused altlabel in copy_on_fault
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.72 2002/07/18 14:00:53 mickey Exp $	*/
a112 1
	BSS(exit_stack, 4)	/* temp stack used during exit2() */
a176 1
	STACK_ALLOC(exit_stack, EXIT_STACKSIZE)
d207 1
a207 1
	stw	t3, R%proc0+P_MD(t2)
d737 1
a737 1
	ldw	P_MD(r1), t3
d1721 1
a1721 1
	ldw	P_MD(t2), t3
d2578 1
a2578 1
	ldw	P_MD(arg2), t1
d2612 1
a2612 1
	ldw	P_MD(arg1), t1
a2658 25
	/* setup kernel context */
	mtctl	r0, sr0
	mtctl	r0, sr1
	mtctl	r0, sr2
	mtctl	r0, sr3
	mtctl	r0, sr4
	mtctl	r0, sr5
	mtctl	r0, sr6
	mtctl	r0, sr7

	ldi	HPPA_PID_KERNEL, t4
	mtctl	t4, pidr2

	/* switch onto the temporary stack */
	ldil	L%exit_stack, t4
	ldw	R%exit_stack(t4), t4
	stw	r0, HPPA_FRAME_SIZE+HPPA_FRAME_PSP(t4)
	stw	r0, HPPA_FRAME_SIZE+HPPA_FRAME_CRP(t4)
	ldo	HPPA_FRAME_SIZE(t4), sp

	/* start the stack frame for our callee */
	copy	sp, r3
	ldo	HPPA_FRAME_SIZE(sp), sp
	stw	r3, HPPA_FRAME_PSP(sp)

d2682 1
a2682 1
	ldw	P_MD(t2), t3
@


1.72
log
@if such an occasion occures that hpmc_dump() returns -- just summon the global broadcast and reset
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.71 2002/07/18 04:35:03 mickey Exp $	*/
a545 3
	/*
	 * now call the syscall handler
	 */
d549 2
a550 2
	be,n	R%$syscall(sr1, t2)
	nop
a570 1
	copy	sp, t4
d575 4
a579 2
	stw	t1, TF_R22 -TRAPFRAME_SIZEOF(sr1, t3)	/* syscall # */
	stw	t4, TF_R30 -TRAPFRAME_SIZEOF(sr1, t3)	/* user stack */
d596 1
d616 5
d642 4
a645 4
	ldw	HPPA_FRAME_ARG( 4)(t4), arg0
	ldw	HPPA_FRAME_ARG( 5)(t4), arg1
	ldw	HPPA_FRAME_ARG( 6)(t4), arg2
	ldw	HPPA_FRAME_ARG( 7)(t4), arg3
d650 2
a651 2
	ldw	HPPA_FRAME_ARG( 8)(t4), arg0
	ldw	HPPA_FRAME_ARG( 9)(t4), arg1
d673 1
a673 2
	mfsp	sr0, arg0
	mfsp	sr0, arg1
a710 2
	mfctl	cr30, arg0
	stw	arg0, TF_CR30(sr1, t3)
d762 14
a775 17
	copy	t3, arg0
	ldil	L%$trap_tmp_save, arg1
	ldi	TF_PHYS-4, arg2		/* not all of it is needed, unroll */
$syscall_return_copy_loop
	ldwm	4(arg0), t1
	addib,>,n -4, arg2, $syscall_return_copy_loop
	stwm	t1, 4(arg1)

#if 0
	ldw	TF_IIOQH(t3), t1
	dep	r0, 31, 2, t1
	comb,<>,n r0, t1, $syscall_return_ok
	nop
	break	0, 8

$syscall_return_ok
#endif
d1560 1
a1560 1
	nop
a1605 6
#ifdef DDB
	stw	rp, HPPA_FRAME_CRP(sp)
	stw	r0, -HPPA_FRAME_SIZE(sp)
#endif
	stw	t3, -HPPA_FRAME_SIZE+4(sp)

d1612 4
a1700 3
#ifdef DDB
	ldo	-HPPA_FRAME_SIZE(sp), r3
#endif
d1709 1
a1709 1
	ldw	-HPPA_FRAME_SIZE+4(sp), t3
d1719 1
a1719 1
	ldw	-HPPA_FRAME_SIZE+4(sp), t3
d2257 1
a2257 1
LEAF_ENTRY($copy_on_fault)
a2258 1
ALTENTRY(copy_on_fault)		/* for kcopy() */
d2261 1
a2261 1
EXIT($copy_on_fault)
d2274 2
a2275 2
	ldil	L%$copy_on_fault, t2
	ldo	R%$copy_on_fault(t2), t2
@


1.71
log
@make reserved pages for the pv_pool variable on physmem (should pool get preload in the future this is to be changed immidiately). map the page above the kernel stack unmapped
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.70 2002/06/09 02:50:29 mickey Exp $	*/
d1887 3
@


1.70
log
@an agr(0) was overwriting the saved r18, fix that
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.69 2002/05/20 07:59:11 mickey Exp $	*/
d202 1
a202 1
	ldil	L%USPACE, arg0
@


1.69
log
@force alignment on the netisr and sir by mobving 'em into .data
and allocating space in the locore (ldcw require a 16byte alignment).
inform gcc that ldcw will change the memory (in asm()).
fix spl handling in the soft intrs piece.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.68 2002/05/20 03:46:53 mickey Exp $	*/
d2553 17
d2586 2
d2589 2
a2590 2
	ldo	HPPA_FRAME_SIZE+16*4(sp), sp
	ldw	TF_R30(t1), t3
d2592 1
a2592 3
	stw	rp, HPPA_FRAME_CRP(sp)
	stw	t3, HPPA_FRAME_ARG(0)(sp)
	stw	sp, TF_R30(t1)
a2594 1
	stw	r3,   0*4(t2)
d2625 1
d2627 1
a2627 5
	ldw	HPPA_FRAME_CRP(sp), rp
	ldw	HPPA_FRAME_PSP(sp), t2
	stw	t3, TF_R30(t1)
	fdc	r0(t1)
	ldw	HPPA_FRAME_ARG(1)(sp), t3 /* in case we're on trampoline */
d2629 1
d2646 2
d2682 2
a2684 2
	stw	r0, HPPA_FRAME_PSP(sp)
	stw	r0, HPPA_FRAME_CRP(sp)
d2708 1
a2708 1
	bv,n	r0(t3)
@


1.68
log
@make sure all the funky stack we allocate are properly alligned, the trap_phys is still uncertain, but it's at the beginning of the section (;
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.67 2002/05/20 02:26:40 mickey Exp $	*/
d127 8
@


1.67
log
@gateway is not fixated on the pid in the tlb, make it a not-care value in itlbh
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.66 2002/05/14 02:16:27 mickey Exp $	*/
d103 5
a107 12
	.section .bss
	.export	pdc_stack, data
	.align	NBPG
pdc_stack			/* temp stack for PDC call, must be > 9k */
	.comm	4*NBPG
	.export	exit_stack, data
exit_stack			/* temp stack used during exit2() */
	.comm   2*NBPG
	.export	emerge_stack, data
emerge_stack			/* stack for HPMC/TOC/PWRF */
	.comm	2*NBPG
	.export	$trap_tmp_save, data
d110 7
a116 1
	.align	64
d118 1
a118 2
kernelmapped			/* set when kernel is mapped */
	.comm	4
d120 1
a120 2
fpu_csw
	.comm	4
d122 1
a122 2
fpu_curpcb
	.comm	4
d124 1
a124 4
fpu_enable
	.comm	4

	.data
d126 1
a126 2
hppa_vtop
	.word	0
d138 1
a138 1
 *	pdc - PDC entry point (not used, HP-UX compatibility)
d163 13
d376 1
a376 1
	ldo	R%pdc_stack(ret1), ret1
d1181 2
a1182 3
	.import	$fpemu_stack, data
	ldil	L%$fpemu_stack, r31
	ldo	R%$fpemu_stack(r31), r31
d1218 2
a1219 2
	ldil	L%$fpemu_stack, r31
	ldo	R%$fpemu_stack(r31), r31
a1271 2
	.section .bss
	.align	8
d1273 1
a1273 2
dtlb_c
	.comm	8
d1275 1
a1275 2
tlbd_c
	.comm	8
d1277 1
a1277 2
itlb_c
	.comm	8
d1874 1
d1876 1
a1876 1
	ldil	L%emerge_stack, arg1
d1904 1
d1906 1
a1906 1
	ldil	L%emerge_stack, arg1
d1932 1
d1934 1
a1934 1
	ldil	L%emerge_stack, arg1
d2657 1
@


1.66
log
@fix the diag insns, make copy_on_fault() usable by the kcopy as well
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.65 2002/05/09 17:20:09 mickey Exp $	*/
d1350 2
d1438 2
@


1.65
log
@add stats gathering for tlb handlers, count the calls for
itlb, dtlb and tlb-dirty traps and cumulative time spent
in each of those, being average 37 for the dtlb handler of 24 insns.
move unrelated to traps code out of the traps way since
profiled  tlb handlers grew up and shifted the trap-all too far.
insert required nops/sync and implied regs here and there.
encode diag-reg insns in .word to see better what is
being generated for the code.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.64 2002/04/02 17:54:27 mickey Exp $	*/
d83 6
a88 6
#define	DR_PAGE0	.word	0x04001200
#define	DR_PAGE1	.word	0x04001240
#define	MTCPU_T(x,t)	.word	0x04001400 | ((t) << 21) | ((x) << 16)
#define	MFCPU_T(r,x)	.word	0x04001400 | ((r) << 21) | (x)
#define	MTCPU_C(x,t)	.word	0x04000240 | ((t) << 21) | ((x) << 16)
#define	MFCPU_C(r,x)	.word	0x04000600 | ((r) << 21) | ((x) << 16)
a1391 1
 *	check if stwas is needed (if we changed the bits)
d1433 1
a1440 1
$itlbna_l
a1842 6
	/* XXX disable all i-cache ops */
	depi	0, DR0_PCXL_ISTRM_EN,1, t1
	depi	0, DR0_PCXL_IPREF_EN,1, t1
	depi	0, DR0_PCXL_L1ICACHE_EN,1, t1
	depi	0, DR0_PCXL_L2IHASH_EN,1, t1
	depi	0, DR0_PCXL_L2DHASH_EN,1, t1
d2247 3
a2249 2
LEAF_ENTRY(copy_on_fault)
	stw	r1, PCB_ONFAULT+U_PCB(r31)
d2252 1
a2252 1
EXIT(copy_on_fault)
d2261 7
a2267 7
	ldil	L%curproc, r31
	ldw	R%curproc(r31), r31
	ldw	P_ADDR(r31), r31
	ldw	PCB_ONFAULT+U_PCB(r31), r1
	ldil	L%copy_on_fault, t2
	ldo	R%copy_on_fault(t2), t2
	stw	t2, PCB_ONFAULT+U_PCB(r31)
d2292 1
a2292 1
	stw	r1, PCB_ONFAULT+U_PCB(r31)
@


1.64
log
@time and time+4 might not be the same in the %hi (copycat jason)
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.63 2002/04/01 16:19:58 mickey Exp $	*/
d83 6
a88 6
#define	DR_PAGE0	diag (0x70 << 5)
#define	DR_PAGE1	diag (0x72 << 5)
#define	MTCPU_T(x,t)	diag ((t) << 21) | ((x) << 16) | (0xc0 << 5)
#define	MTCPU_C(x,t)	diag ((t) << 21) | ((x) << 16) | (0x12 << 5)
#define	MFCPU_T(r,x)	diag ((r) << 21) | (0xa0 << 5) | (x)
#define	MFCPU_C(r,x)	diag ((r) << 21) | ((x) << 16) | (0x30 << 5)
d229 1
d285 1
d840 1
a840 1
	nop ! nop ! nop ! nop ! nop ! nop ! nop ! nop	/* XXX really? */
d1267 32
a1298 25
	.align	64
/*
 * void desidhash_s(void)
 */
#if defined(HP7000_CPU) || defined(HP7100_CPU)
LEAF_ENTRY(desidhash_s)
ALTENTRY(desidhash_x)
	sync
	MFCPU_T(DR_CPUCFG,22)	/* t1 */
	MFCPU_T(DR_CPUCFG,22)
	nop
	nop
	depi	0, DR0_PCXS_DHE, 3, t1	/* 3 4 DR0_PCXS_DOMAIN|DR0_PCXS_IHE */
	depi	1, DR0_PCXS_EQWSTO, 1, t1
	depi	0, DR0_PCXS_DHPMC, 1, t1
	depi	0, DR0_PCXS_ILPMC, 1, t1
	sync
	MTCPU_T(22,DR_CPUCFG)
	MTCPU_T(22,DR_CPUCFG)
	nop
	nop
	bv	0(rp)
	extru	t1, 4, 5, ret0	/* return chip revision */
EXIT(desidhash_s)
#endif /* HP7000_CPU || HP7100_CPU */
d1300 3
a1302 22
#ifdef HP7200_CPU
/*
 * void desidhash_t(void)
 */
LEAF_ENTRY(desidhash_t)
	sync
	MFCPU_T(DR_CPUCFG,22)	/* t1 */
	MFCPU_T(DR_CPUCFG,22)
	nop
	nop
	depi	0, DR0_PCXT_IHE, 1, t1
	depi	0, DR0_PCXT_DHE, 1, t1
	depi	0, DR0_PCXT_DHPMC, 1, t1
	depi	0, DR0_PCXT_ILPMC, 1, t1
	sync
	MTCPU_T(22,DR_CPUCFG)
	MTCPU_T(22,DR_CPUCFG)
	nop
	nop
	bv	0(rp)
	extru	t1, 4, 5, ret0	/* return chip revision */
EXIT(desidhash_t)
d1327 1
d1331 1
d1338 1
d1348 1
d1355 1
d1363 4
d1369 1
d1376 1
a1381 6
/*
 * int
 * ibtlb_l(int i, pa_space_t sp, vaddr_t va, paddr_t pa, vsize_t sz, u_int prot)
 */
LEAF_ENTRY(ibtlb_l)
	rsm	(PSW_R|PSW_I), t4
a1382 70
	bv	0(rp)
	mtsm	t4
EXIT(ibtlb_l)

/* hpti_l(addr,size) */
LEAF_ENTRY(hpti_l)
	ldo	-1(arg1), arg1
	depi	0, 31, 12, arg1
	ldi	0x1c0, t1		/* cache size assumed 128k XXX */
	or	arg0, t1, arg0
	sync
	MTCPU_C(26,DR0_PCXL2_HTLB_ADDR)
	MTCPU_C(25,DR0_PCXL2_HTLB_CFG)
	nop
	nop
	bv,n	r0(rp)
	nop
EXIT(hpti_l)

/*
 * int
 * pbtlb_l(int i)
 */
LEAF_ENTRY(pbtlb_l)
	; DR_PAGE0
	rsm	(PSW_R|PSW_I), t4
	ldil	L%0xc041, t1
	ldo	R%0xc041(t1), t1
	dep	arg0, 30, 3, t1
	sync
	MTCPU_T(22,DR_DTLB)	/* t1 */
	nop
	nop
	mtsp	r0, sr1
	idtlba	r0,(sr1,r0)
	idtlbp	r0,(sr1,r0)
	zdepi	-1, 18, 1, t1
	nop
	sync
	MTCPU_T(22,DR_DTLB)
	nop
	nop
	bv	0(rp)
	mtsm	t4
EXIT(pbtlb_l)

/*
 * int desidhash_l(void)
 */
LEAF_ENTRY(desidhash_l)
	MFCPU_C(DR_CPUCFG,22)	/* t1 */
	nop
	nop
	depi	0, DR0_PCXL_L2IHASH_EN, 2, t1	/* + DR0_PCXL_L2DHASH_EN */
	depi	0, DR0_PCXL_L2IHPMC, 1, t1	/* don't reset */
	depi	0, DR0_PCXL_L2DHPMC, 1, t1	/* don't reset */
	depi	0, DR0_PCXL_L1IHPMC, 1, t1	/* don't reset */
	depi	0, DR0_PCXL_L2PARERR,1, t1	/* don't reset */
		/* set DR0_PCXL_L1ICACHE_EN ??? */
	depi	0, DR0_PCXL_PFMASK, 1, t1	/* enable power fail int */
	sync
	MTCPU_C(22,DR_CPUCFG)
	nop
	nop
	bv	0(rp)
	extru	t1, 4, 5, ret0	/* return chip revision */
EXIT(desidhash_l)


	.align	32
d1397 1
a1397 1
	ldwax,s	r8(r16), r17		/* space -> page directory */	! \
d1400 1
a1400 1
	ldwax,s	r25(r17), r24		/* page -> page table */	! \
d1403 1
a1403 1
	ldwax,s	r16(r24), r17		/* va -> pa:prot */		! \
d1406 1
d1409 2
a1410 1
	stwas	r17, 0(r25)		/* store back w/ the bits */	! \
d1415 2
a1416 1
	extru	r17, 24, 25, r17
d1418 1
d1420 1
a1421 1
	sync
d1424 1
a1424 1
	nop
d1427 6
a1432 1
$itlbna_l
d1434 1
a1435 1
	sync
d1438 1
a1438 1
	nop
d1441 1
d1444 1
a1445 1
	sync
d1448 1
a1448 1
	nop
d1726 134
d2043 1
a2043 1
	fdc	(sr1, arg1)
d2048 1
a2048 1
	sync
d2090 1
a2090 1
	pdc	(sr1, arg1)
d2095 1
a2095 1
	sync
d2137 1
a2137 1
	fic	(sr1, arg1)
d2142 1
a2142 1
	sync
@


1.63
log
@better support for machine checks tocs and power fails
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.62 2002/03/24 07:52:24 mickey Exp $	*/
d1415 1
d2235 1
a2235 1
 * XXX: do it the easy way, later we will calculate actual fuzz from itr
a2238 5
	.import time, data
	ldil	L%-1000000, t3
	ldil	L%time, t1
	ldo	R%-1000000(t3), t3

d2243 5
a2247 2
	ldw	R%time+4(t1), t2
	ldw	R%time(t1), t1
d2252 3
d2256 2
a2257 1
	addb,<	t2, t3, microtime_no
a2258 1

@


1.62
log
@non-access itlb fault puts the addr in isr:ior, not pcsq:pcoq
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.61 2002/03/19 19:03:20 mickey Exp $	*/
d105 1
d111 8
d127 1
d130 5
a134 4
$trap_tmp_save			/* XXX assumed to be aligned on 2048 */
	.align	2048
	.block	TF_PHYS		/* XXX must be aligned to 64 */
	.align	64
d137 1
a170 20
	/*
	 * disable interrupts and turn off all bits in the psw so that
	 * we start in a known state.
	 */
	rsm	RESET_PSW, r0

	/*
	 * to keep the spl() routines consistent we need to put the correct
	 * spl level into eiem, and reset any pending interrupts
	 */
	ldi	-1, r1
	mtctl	r0, eiem	/* IPL_NONE */
	mtctl	r1, eirr

	/*
	 * set up the dp pointer so that we can do quick references off of it
	 */
	ldil	L%$global$,dp
	ldo	R%$global$(dp),dp

d190 1
a190 1
	add	arg3, arg0, arg0
a202 33
	 * We need to set the Q bit so that we can take TLB misses after we
	 * turn on virtual memory.
	 */
	mtctl	r0, pcsq
	mtctl	r0, pcsq
	ldil	L%$qisnowon, t1
	ldo	R%$qisnowon(t1), t1
	mtctl	t1, pcoq
	ldo	4(t1),t1
	mtctl	t1, pcoq
	ldi	PSW_Q|PSW_I, t1
	mtctl	t1, ipsw
	rfi
	nop

$qisnowon
	/*
	 * load address of interrupt vector table
	 */
	ldil	L%$ivaaddr,t2
	ldo	R%$ivaaddr(t2),t2
	mtctl	t2,iva

	/*
	 * Create a stack frame for us to call C with. Clear out the previous
	 * sp marker to mark that this is the first frame on the stack.
	 */
	copy	sp, t1
	stwm	r0, HPPA_FRAME_SIZE(sp)
	copy	sp, r3
	stwm	t1, HPPA_FRAME_SIZE(sp)

	/*
d207 7
a216 1
	.import hppa_init, code
d219 1
a225 20
	 * go to virtual mode...
	 * get things ready for the kernel to run in virtual mode
	 */
	ldi	HPPA_PID_KERNEL, r1
	mtctl	r1, pidr1
	mtctl	r1, pidr2
#if pbably_not_worth_it
	mtctl	r0, pidr3
	mtctl	r0, pidr4
#endif
	mtsp	r0, sr0
	mtsp	r0, sr1
	mtsp	r0, sr2
	mtsp	r0, sr3
	mtsp	r0, sr4
	mtsp	r0, sr5
	mtsp	r0, sr6
	mtsp	r0, sr7

	/*
a246 1
	addi	1, r0, t2
d248 1
a248 1
	stw	t2, R%kernelmapped(t1)
d277 74
a1037 19
	.export	TLABEL(hpmc), entry
ENTRY(TLABEL(hpmc),0)
	/* TODO: save cpu context */
	/* TODO: save PIM info */
	/* TODO: call pdc appropriately */

	.import	hpmc_dump, code
	ldil	L%hpmc_dump, t1
	ldo	R%hpmc_dump(t1), t1
	.call
	blr	r0, rp
	bv,n	0(t1)
	nop

	/* never returns, but still */
hpmc_never_dies
	b	hpmc_never_dies
	nop
EXIT(TLABEL(hpmc))
d1491 1
d1494 1
a1498 1
#if 0			/* only needed for a separate i/d tlb */
d1500 1
d1503 1
a1505 1
#endif
d1509 1
d1512 1
d1791 27
d1822 7
d1830 6
a1835 2
	ldil	L%boot, t1
	ldo	R%boot(t1), t1
d1837 2
a1838 4
	.call
	blr	r0, rp
	bv,n	0(t1)
	nop
d1849 7
d1857 6
a1862 2
	ldil	L%boot, t1
	ldo	R%boot(t1), t1
d1864 2
a1865 4
	.call
	blr	r0, rp
	bv,n	0(t1)
	nop
@


1.61
log
@mtcpu seq requires a pre-sync, implement hpt init for pcxl
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.60 2002/03/15 21:44:18 mickey Exp $	*/
d968 1
a968 1
	STRAP(itlbna,T_ITLBMISSNA,ITLBPRE)/* 16. ITLB non-access miss fault */
@


1.60
log
@rewrite a pmap to use multilevel page tables.
lower 12 bits contain the perms, no unused bits left,
but a couple for off-tlb use (as the ref implemented now).
do not use the hvt, which might get some use later
if proven to speed thigs up, tlb handlers would po
another dozen of insns though, but if that's worth its...
move on the data seg and map kernel text rdonly (idea form fredette),
since all of the page0 mods done before that we are all fine
except for some viper fluff, but later w/ that.
this also picks up a bit more of ddb magic for bpt and ss.
tlb handlers can use a little bit more of attention,
but things, visually, seem to be much faster already, --
sorry, no benchmarks for now.

* effort sponsored in part by the `henry st. old ale house'
* and mr.pete and mr.lee in particular in thier generous entrirety.
* the proj took a little more that 72man*h as it was expected,
* but within murhy's law estimations.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.59 2002/03/15 19:53:49 mickey Exp $	*/
d1272 1
d1281 1
d1296 1
d1305 1
d1392 15
d1416 1
d1424 2
d1446 2
d1497 1
a1497 1
#if 0	/* XXX assume combined TLB */
d2479 1
a2480 1
	mtctl	t2, cr30
@


1.59
log
@doh
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.58 2002/03/12 21:36:47 mickey Exp $	*/
d120 5
a524 4
$trap_tmp_save			/* XXX assumed to be aligned on 2048 */
	.block	TF_PHYS		/* XXX must be aligned to 64 */
	.align	64

d902 1
d910 1
d918 1
d926 1
d968 2
a969 2
	STRAP(itlb,T_ITLBMISSNA,ITLBPRE)/* 16. ITLB non-access miss fault */
	STRAP(dtlb,T_DTLBMISSNA,DTLBPRE)/* 17. DTLB non-access miss fault */
d1311 22
d1336 8
a1343 34
#if 1
	HPTENT
	mtctl	r24, cr28

	/*
	 * Chase the list of entries for this hash bucket until we find
	 * the correct mapping or NULL.
	 */
	ldw	HPT_ENTRY(r24), r24
$hash_loop_tlbd_t
	comb,=,n r0, r24, TLABEL(all)
	ldw	PV_VA(r24), r25
	ldw	PV_SPACE(r24), r17
	comb,<>,n r9, r25, $hash_loop_tlbd_t
	ldw	PV_HASH(r24), r24
	comb,<>,n r8, r17, $hash_loop_tlbd_t
	ldw	PV_HASH(r24), r24

	VTAG	/* (r8,r9) -> r16 */
	/* Set the dirty bit for this physical page. */
	ldw	PV_TLBPROT(r24), r25
	b	$tlb_inshpt_t
	depi	1, TLB_DIRTY_POS, 1, r25
#else

	mfsp	%sr1, %r25
	mtsp	%r8, %sr1
	lpa	%r0(%sr1, %r9), %r17
	mfctl	%cr29, %r16
	mtsp	%r25, %sr1
	extru	%r17, 20, 21, %r24
	sh3add	%r24, %r16, %r16
	
#endif
d1346 1
d1348 1
d1350 9
a1358 1
	depi	1, TFF_ITLB_POS, 1, r1	/* mark for ITLB insert */
d1366 1
a1366 53
	/*
	 * r1 is the trap type
	 * r8 is the space of the address that had the TLB miss
	 * r9 is the offset of the address that had the TLB miss
	 * r24 is the correspondent HPT entry pointer
	 */

	HPTENT
	mtctl	r24, cr28

	ldw	HPT_TAG(r24),r17
	VTAG	/* (r8,r9) -> r16 */

	/* Compare the tag against the HPT entry.
	   If it matches, then do the TLB insertion. */
	comb,<>,n r16, r17, $tlb_gottalook_t

	ldw	HPT_TLBPAGE(r24), r17
	b	$tlb_gothpt_t
	ldw	HPT_TLBPROT(r24), r25

$tlb_gottalook_t
	/*
	 * Chase the list of entries for this hash bucket until we find
	 * the correct mapping or NULL.
	 */
	ldw	HPT_ENTRY(r24),r24
$hash_loop_t
	comb,=,n r0, r24, TLABEL(all)
	ldw	PV_VA(r24),r25
	ldw	PV_SPACE(r24),r17
	comb,<>,n r9,r25,$hash_loop_t
	ldw	PV_HASH(r24),r24
	comb,<>,n r8,r17,$hash_loop_t
	ldw	PV_HASH(r24),r24

	/* Now set things up to enter the real mapping that we want */
	ldw	PV_TLBPROT(r24),r25
	depi	1, TLB_REF_POS, 1, r25

	/*
	 * Load the HPT cache with the miss information for the next time.
	 */
$tlb_inshpt_t
	stw	r25, PV_TLBPROT(r24)
	ldw	PV_TLBPAGE(r24),r17
	mfctl	cr28, r24

	stw	r16, HPT_TAG(r24)
	stw	r25, HPT_TLBPROT(r24)
	stw	r17, HPT_TLBPAGE(r24)

$tlb_gothpt_t
a1367 1
	bb,<	r1, TFF_ITLB_POS, $tlb_itlb_t
a1368 1

a1370 9
	nop ! nop
	mtsp	r16, sr1
	rfir
	nop

$tlb_itlb_t
	iitlba	r17,(sr1, r9)
	iitlbp	r25,(sr1, r9)
	nop ! nop
d1374 1
d1433 32
d1466 3
a1468 31
	mfctl	cr28, r24

	/*
	 * Chase the list of entries for this hash bucket until we find
	 * the correct mapping or NULL.
	 */
	ldw	HPT_ENTRY(r24), r16
$hash_loop_tlbd_l
	comb,=,n r0, r16, TLABEL(all)
	ldw	PV_VA(r16), r25
	ldw	PV_SPACE(r16), r17
	comb,<>,n r9, r25, $hash_loop_tlbd_l
	ldw	PV_HASH(r16), r16
	comb,<>,n r8, r17, $hash_loop_tlbd_l
	ldw	PV_HASH(r16), r16

	/* Set the dirty bit for this physical page. */
	ldw	PV_TLBPAGE(r16), r17
	ldw	PV_TLBPROT(r16), r25
	depi	1, TLB_DIRTY_POS, 1, r25
	depi	1, TLB_REF_POS, 1, r25
	stw	r25, PV_TLBPROT(r16)
	VTAG	/* (r8,r9) -> r16 */

	stw	r16, HPT_TAG(r24)
	stw	r25, HPT_TLBPROT(r24)
	stw	r17, HPT_TLBPAGE(r24)

	.word	0x04111440	; idtlbaf	r17
	.word	0x04191400	; idtlbpf	r25
	nop ! nop
d1471 1
a1471 2

	.align	8
d1473 7
a1479 1
	depi	1, TFF_ITLB_POS, 1, r1	/* mark for ITLB insert */
a1480 3
	HPTENT
	mtctl	r24, cr28

d1482 3
a1484 49
	mfctl	cr28, r24
	/*
	 * r1 is the trap type
	 * r8 is the space of the address that had the TLB miss
	 * r9 is the offset of the address that had the TLB miss
	 * r24 is the correspondent HPT entry pointer
	 */

	/*
	 * Chase the list of entries for this hash bucket until we find
	 * the correct mapping or NULL.
	 */
	ldw	HPT_ENTRY(r24), r16
$hash_loop_l
	comb,=,n r0, r16, TLABEL(all)
	ldw	PV_VA(r16), r25
	ldw	PV_SPACE(r16), r17
	comb,<>,n r9, r25, $hash_loop_l
	ldw	PV_HASH(r16), r16
	comb,<>,n r8, r17, $hash_loop_l
	ldw	PV_HASH(r16), r16

	/* Now set things up to enter the real mapping that we want */
	ldw	PV_TLBPAGE(r16), r17
	ldw	PV_TLBPROT(r16), r25

	/*
	 * Load the HPT cache with the miss information for the next time.
	 * The HPT entry address was saved by the HPTENT
	 */
	depi	1, TLB_REF_POS, 1, r25
	stw	r25, PV_TLBPROT(r16)
	VTAG	/* (r8,r9) -> r16 */

	stw	r16, HPT_TAG(r24)
	stw	r25, HPT_TLBPROT(r24)
	bb,<	r1, TFF_ITLB_POS, $tlb_itlb_l
	stw	r17, HPT_TLBPAGE(r24)

	.word	0x04111440	; idtlbaf	r17
	.word	0x04191400	; idtlbpf	r25
	nop ! nop
	rfir
	nop

$tlb_itlb_l
	.word	0x04110440	; iitlbaf	r17
	.word	0x04190400	; iitlbpf	r25
	nop ! nop
@


1.58
log
@rest of copy_on_fault proper handlings
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.57 2002/03/12 07:35:06 mickey Exp $	*/
d296 1
d298 1
a298 1
	stw	t1, R%kernelmapped(t1)
@


1.57
log
@oops
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.56 2002/03/08 08:56:11 mickey Exp $	*/
d2164 1
a2164 1
	ldw	U_PCB+PCB_ONFAULT(t1), t3	! \
d2173 1
a2173 1
	stw	r0, U_PCB+PCB_ONFAULT(t1)	! \
d2180 1
a2180 1
	stw	r0, U_PCB+PCB_ONFAULT(t1)	! \
d2184 1
a2184 1
	stw	r0, U_PCB+PCB_ONFAULT(t1)
d2202 1
d2217 1
a2217 1
	ldw	PCB_ONFAULT+U_PCB(r31), t3
d2245 1
a2245 1
	stw	t3, PCB_ONFAULT+U_PCB(r31)
@


1.56
log
@have to set p_md as well, used to shoot clouds before
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.55 2002/03/08 08:34:03 mickey Exp $	*/
d2233 1
@


1.55
log
@last arg to the copystr could be 0, also correct onfault handling
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.54 2002/02/20 19:33:01 mickey Exp $	*/
d198 2
@


1.54
log
@setup power failure handler (for sw-controlled power button), move toc handler
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.53 2002/02/12 05:23:27 mickey Exp $	*/
d2214 1
d2234 1
a2234 2
	stw	r0, PCB_ONFAULT+U_PCB(r31)
	copy	r0, ret0
a2235 1
	sub	arg1, arg0, arg1
d2237 3
d2241 1
a2241 1
	stw	arg1, 0(arg0)
@


1.53
log
@small repairs to hpmc and toc handlers
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.52 2002/02/11 21:29:37 mickey Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998-2001 Michael Shalayeff
d65 1
a1030 15
ENTRY(hppa_toc,0)

	.import	boot, code
	ldil	L%boot, t1
	ldo	R%boot(t1), t1
	ldi	0, arg0
	.call
	blr	r0, rp
	bv,n	0(t1)
	nop

ALTENTRY(hppa_toc_end)
	.word	0
EXIT(hppa_toc)

d1849 36
@


1.52
log
@remove lpa support (used for kvtop), copy a piece of pcxl fault handler into the dirty handler to avoid excessive branching
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.51 2002/02/11 19:42:11 mickey Exp $	*/
d1029 15
@


1.51
log
@disable fpu on csw, print fpu version on cpu line, if present
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.50 2002/02/06 19:37:02 mickey Exp $	*/
d1379 1
a1379 1
	comb,=,n r0, r24, $tlbiflpa
a1499 1
	b	$tlb_inshpt_l
d1501 13
d1537 1
a1537 1
	comb,=,n r0, r16, $tlbiflpa
a1547 1
	depi	1, TLB_REF_POS, 1, r25
d1553 1
a1553 1
$tlb_inshpt_l
a1574 53

	.export $tlbiflpa, entry
$tlbiflpa
	ldi	T_DTLBMISSNA, r16
	mfctl	iir, r17
	comb,<>,n r1, r16, TLABEL(all)
	extru	r17, 5, 6, r16
	ldi	0x4d, r25
	comib,<>,n 1, r16, TLABEL(all)
	extru	r17, 25, 8, r16
	comb,<>,n r25, r16, TLABEL(all)

	/* ok, this is a miss in LPA */
	mfctl	ipsw, r16
	depi	1, PSW_N_POS, 1, r16
	depi	0, 26, 27, r17
	mtctl	r16, ipsw

	ldi	$tlbiflpa_zr, r25
	bv	r17(r25)
$tlbiflpa_zr
	copy	r0, r0	!	rfir
	copy	r0, r1	!	rfir
	copy	r0, r2	!	rfir
	copy	r0, r3	!	rfir
	copy	r0, r4	!	rfir
	copy	r0, r5	!	rfir
	copy	r0, r6	!	rfir
	copy	r0, r7	!	rfir
	copy	r0, r8	!	rfir
	copy	r0, r9	!	rfir
	copy	r0, r10	!	rfir
	copy	r0, r11	!	rfir
	copy	r0, r12	!	rfir
	copy	r0, r13	!	rfir
	copy	r0, r14	!	rfir
	copy	r0, r15	!	rfir
	copy	r0, r16	!	rfir
	copy	r0, r17	!	rfir
	copy	r0, r18	!	rfir
	copy	r0, r19	!	rfir
	copy	r0, r20	!	rfir
	copy	r0, r21	!	rfir
	copy	r0, r22	!	rfir
	copy	r0, r23	!	rfir
	copy	r0, r24	!	rfir
	copy	r0, r25	!	rfir
	copy	r0, r26	!	rfir
	copy	r0, r27	!	rfir
	copy	r0, r28	!	rfir
	copy	r0, r29	!	rfir
	copy	r0, r30	!	rfir
	copy	r0, r31	!	rfir
@


1.50
log
@add a todo remark
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.49 2002/02/04 19:52:21 mickey Exp $	*/
d117 2
a118 1

d1063 3
a1065 1
	/* ldo	PCB_FPREGS+U_PCB(t1), t1 */
d2539 1
d2551 1
a2551 1
	ldw	HPPA_FRAME_ARG(1)(sp), t3 /* in case we're in trampoline */
@


1.49
log
@switch onto temp stack for exit2(); implementation from netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.48 2002/02/03 01:30:38 mickey Exp $	*/
d591 2
@


1.48
log
@fix missing srNs
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.47 2002/02/02 21:14:03 mickey Exp $	*/
d104 1
a104 1
pdc_stack
d106 3
d2594 11
a2604 1
	/* XXX we need to switch to some stupid stack here */
@


1.47
log
@small stupid tyops (mostly from netbsd); some cleanups from me
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.46 2001/09/20 18:33:03 mickey Exp $	*/
d505 1
a505 1
	be,n	R%$syscall(sr7, t2)
d540 1
a540 1
	ldw	R%kpsw(t1), t1
d718 1
a718 1
	ldi	TF_PHYS, arg2
d721 1
a721 1
	addib,>= -4, arg2, $syscall_return_copy_loop
d724 10
d1771 1
a1771 1
	/* use ,bc each line */
d1802 9
a1810 9
	stw	t4, TF_R19(t3)
	stw	r23,TF_R23(t3)
	stw	r24,TF_R24(t3)
	stw	r25,TF_R25(t3)
	stw	r26,TF_R26(t3)
	stw	r27,TF_R27(t3)
	stw	r28,TF_R28(t3)
	stw	r29,TF_R29(t3)
	stw	r31,TF_R31(t3)
d1984 2
a1985 2
	/*addi	-1, arg0, arg1
	fdc	(sr1, arg1)*/
d2031 2
a2032 2
	/*addi	-1, arg0, arg1
	pdc	(sr1, arg1)*/
d2078 2
a2079 2
	/*addi	-1, arg0, arg1
	fic	(sr1, arg1)*/
@


1.46
log
@s/TF_SIZE/TRAPFRAME_SIZEOF/ to make it compile now
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.45 2001/09/16 14:28:43 miod Exp $	*/
d504 2
a505 2
	ldil	L%$syscall,r1
	be,n	R%$syscall(sr7,r1)
d523 1
a523 1
	 * t1:	curproc
a527 5
	 * N.B. we are trying to rely on the fact that bottom of kernel
	 *	stack contains a print of some past trapframe, so
	 *	we do not save hard to get information, but do restore
	 *	the whole context later on return anyway.
	 * XXXXXX this is very bad. everything must be saved
d531 1
a534 1
	copy	sp, t4
d539 8
a546 1
	stw	r1, TF_CR15-TRAPFRAME_SIZEOF(sr1, t3)	/* eiem */
d552 2
a553 1
	 * or deeper called functions
a554 1
	stw	r27, TF_R27-TRAPFRAME_SIZEOF(sr1, t3)	/* dp */
d574 1
d609 3
d617 1
a617 5
	mfsp	sr0, arg0
	stw	arg0, TF_IISQH-TRAPFRAME_SIZEOF(sr1, t3)
	stw	arg0, TF_IISQT-TRAPFRAME_SIZEOF(sr1, t3)

	stw	arg0, TF_CR20-TRAPFRAME_SIZEOF(sr1, t3)
a619 5
	mfsp	sr3, arg0
	stw	arg0, TF_SR3-TRAPFRAME_SIZEOF(sr1, t3)
	stw	r28, TF_CR8-TRAPFRAME_SIZEOF(sr1, t3)	/* pidr1 */

	mfctl	iir, arg0	/* XXX bogus */
d621 1
a621 1
	stw	arg0, TF_CR19-TRAPFRAME_SIZEOF(sr1, t3)
d663 2
d689 1
d845 1
a845 1
	be	R%TLABEL(name)(sr4, r1)	! \
d1247 2
d1255 2
d1269 2
d1277 2
d1427 2
d1434 2
d1445 2
d1454 2
d1839 1
a1839 1
	dep	r0, 26, 27, arg0
d2251 1
a2251 1
	add	1, t2, t2
d2253 1
a2253 1
	add	1, t1, t1
d2369 1
a2369 1
	vdepi	1, 1, t3
@


1.46.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.46 2001/09/20 18:33:03 mickey Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998-2002 Michael Shalayeff
a64 1
#include <sys/reboot.h>
d82 6
a87 6
#define	DR_PAGE0	.word	0x14001200
#define	DR_PAGE1	.word	0x14001240
#define	MTCPU_T(x,t)	.word	0x14001400 | ((t) << 21) | ((x) << 16)
#define	MFCPU_T(r,x)	.word	0x14001400 | ((r) << 21) | (x)
#define	MTCPU_C(x,t)	.word	0x14000240 | ((t) << 21) | ((x) << 16)
#define	MFCPU_C(r,x)	.word	0x14000600 | ((r) << 21) | ((x) << 16)
d102 6
a107 16
#define	EXIT_STACKSIZE	(2*NBPG)
#define	EMRG_STACKSIZE	(2*NBPG)
#define	FPEMU_STACKSIZE	(2*NBPG)

	.data
$trap_tmp_save			/* XXX assumed to be aligned on 2048 */
	.block	TF_PHYS		/* XXX must be aligned to 64 */
	.align	NBPG

	BSS(pdc_stack, 4)	/* temp stack for PDC call */
	BSS(exit_stack, 4)	/* temp stack used during exit2() */
	BSS(emrg_stack, 4)	/* stack for HPMC/TOC/PWRF */
	BSS(fpemu_stack, 4)	/* stack for FPU emulation */

	.export	kernelmapped, data
	BSS(kernelmapped, 4)	/* set when kernel is mapped */
d109 2
a110 1
	BSS(fpu_csw, 4)		/* count fpu context switches */
d112 2
a113 13
	BSS(fpu_curpcb, 4)	/* pcb of the fpu owner */
	.export fpu_enable, data
	BSS(fpu_enable, 4)	/* bits to set in the ccr to enable fpu */
	.export hppa_vtop, data
	BSS(hppa_vtop, 4)	/* a vtop translation table addr (pa=va) */
	.export netisr, data
	.align 16
netisr
	.word	0
	.export sir, data
	.align 16
sir
	.word	0
a115 1
	.import	$kernel_setup, entry
d124 1
a124 1
 *	pdc - PDC entry point
d149 13
a161 10
#define	STACK_ALLOC(n,s)		\
	ldil	L%(n), t1		! \
	stw	arg3, R%(n)(t1)		! \
	ldil	L%(s), t2		! \
	add	arg3, t2, arg3

	STACK_ALLOC(pdc_stack, PDC_STACKSIZE)
	STACK_ALLOC(exit_stack, EXIT_STACKSIZE)
	STACK_ALLOC(emrg_stack, EMRG_STACKSIZE)
	STACK_ALLOC(fpemu_stack, FPEMU_STACKSIZE)
d163 5
a167 1
#undef	STACK_ALLOC
d188 1
a188 1
	add	arg0, arg3, arg0
a192 2
	ldo	-TRAPFRAME_SIZEOF(sp), t3
	stw	t3, R%proc0+P_MD(t2)
d199 33
a235 7
	copy	sp, arg1
	ldil	L%$qisnowon, rp
	ldo	R%$qisnowon(rp), rp
	b	$kernel_setup
	ldi	PSW_Q|PSW_I, arg2

$qisnowon
d239 1
a241 1
	.import hppa_init, code
d248 20
a270 1
	nop ! nop ! nop ! nop ! nop ! nop ! nop
a318 75
LEAF_ENTRY($kernel_setup)

	/*
	 * disable interrupts and turn off all bits in the psw so that
	 * we start in a known state.
	 */
	rsm	RESET_PSW, r0
	nop ! nop ! nop ! nop ! nop ! nop

	/* get things ready for the kernel to run in virtual mode */
	ldi	HPPA_PID_KERNEL, r1
	mtctl	r1, pidr1
	mtctl	r1, pidr2
#if pbably_not_worth_it
	mtctl	r0, pidr3
	mtctl	r0, pidr4
#endif
	mtsp	r0, sr0
	mtsp	r0, sr1
	mtsp	r0, sr2
	mtsp	r0, sr3
	mtsp	r0, sr4
	mtsp	r0, sr5
	mtsp	r0, sr6
	mtsp	r0, sr7

	/*
	 * to keep the spl() routines consistent we need to put the correct
	 * spl level into eiem, and reset any pending interrupts
	 */
	ldi	-1, r1
	mtctl	r0, eiem	/* IPL_NONE */
	mtctl	r1, eirr

	/*
	 * load address of interrupt vector table
	 */
	ldil	L%$ivaaddr, t2
	ldo	R%$ivaaddr(t2), t2
	mtctl	t2, iva

	/*
	 * set up the dp pointer so that we can do quick references off of it
	 */
	ldil	L%$global$,dp
	ldo	R%$global$(dp),dp

	/*
	 * Create a stack frame for us to call C with. Clear out the previous
	 * sp marker to mark that this is the first frame on the stack.
	 */
	copy	arg1, sp
	ldo	0(arg1), r3
	stw,ma	r0, HPPA_FRAME_SIZE(sp)
	stw	r0, HPPA_FRAME_CRP(sp)
	stw	r0, HPPA_FRAME_PSP(sp)
	copy	r3, r1
	copy	sp, r3
	stw,ma	r1, HPPA_FRAME_SIZE(sp)

	/*
	 * We need to set the Q bit so that we can take TLB misses after we
	 * turn on virtual memory.
	 */
	mtctl	r0, pcsq
	mtctl	r0, pcsq
	mtctl	rp, pcoq
	ldo	4(rp), rp
	mtctl	rp, pcoq
	mtctl	arg2, ipsw
	rfi
	nop
	nop
EXIT($kernel_setup)

d337 1
a337 1
	ldw	R%pdc_stack(ret1), ret1
d504 2
a505 2
	ldil	L%$syscall, t2
	be,n	R%$syscall(sr1, t2)
d512 4
d523 1
a523 1
	 * t1:	syscall number
d528 5
a535 1
	copy	sp, t4
d539 1
d544 1
a544 8
	ldil	L%kpsw, t1
	ldw	R%kpsw(sr1, t1), t1
	stw	r1, TF_CR15-TRAPFRAME_SIZEOF(sr1, t3)	/* eiem ,bc */
	stw	t1, TF_CR22-TRAPFRAME_SIZEOF(sr1, t3)	/* ipsw */
	mfsp	sr3, t1
	stw	t1, TF_SR3-TRAPFRAME_SIZEOF(sr1, t3)
	stw	r28, TF_CR8-TRAPFRAME_SIZEOF(sr1, t3)	/* pidr1 */
	/* now we can allow interrupts to happen */
d550 1
a550 2
	 * or deeper called functions and caller-save
	 * are saved in userland.
d552 1
a571 1
	stw	r27, TF_R27-TRAPFRAME_SIZEOF(sr1, t3)	/* dp */
a584 2
	 *
	 * TODO: setup the onfault handler
a605 3
	mfsp	sr0, arg0				/* use ,bc */
	stw	arg0, TF_IISQH-TRAPFRAME_SIZEOF(sr1, t3)
	stw	arg0, TF_IISQT-TRAPFRAME_SIZEOF(sr1, t3)
d611 5
a615 1
	stw	arg0, TF_CR20-TRAPFRAME_SIZEOF(sr1, t3)	/* use ,bc */
d618 5
d624 1
a624 1
	stw	r0, TF_CR19-TRAPFRAME_SIZEOF(sr1, t3)	/* iir */
a665 2
	mfctl	cr30, arg0
	stw	arg0, TF_CR30(sr1, t3)
a689 1
	nop
d718 1
a718 1
	ldi	TF_PHYS-4, arg2		/* not all of it is needed, unroll */
d721 1
a721 1
	addib,>,n -4, arg2, $syscall_return_copy_loop
a723 10
#if 0
	ldw	TF_IIOQH(t3), t1
	dep	r0, 31, 2, t1
	comb,<>,n r0, t1, $syscall_return_ok
	nop
	break	0, 8

$syscall_return_ok
#endif

d798 1
a798 1
	nop ! nop ! nop ! nop ! nop ! nop ! nop
d845 1
a845 1
	be	R%TLABEL(name)(sr7, r1)	! \
a880 1
LDILDO(itlbna_x)
a887 1
LDILDO(itlbna_s)
a894 1
LDILDO(itlbna_t)
a901 1
LDILDO(itlbna_l)
d943 2
a944 2
	STRAP(itlbna,T_ITLBMISSNA,DTLBPRE)/* 16. ITLB non-access miss fault */
	STRAP(dtlbna,T_DTLBMISSNA,DTLBPRE)/* 17. DTLB non-access miss fault */
d994 19
d1047 1
a1047 3
#if PCB_FPREGS != 0 || U_PCB != 0
	ldo	PCB_FPREGS+U_PCB(t1), t1
#endif
d1147 3
a1149 2
	ldil	L%fpemu_stack, r31
	ldw	R%fpemu_stack(r31), r31
d1185 2
a1186 2
	ldil	L%fpemu_stack, r31
	ldw	R%fpemu_stack(r31), r31
d1238 19
a1256 7
#if 1
	.export	dtlb_c, data
	BSS(dtlb_c, 8)
	.export	dtlb_c, data
	BSS(tlbd_c, 8)
	.export	dtlb_c, data
	BSS(itlb_c, 8)
d1258 16
a1273 23
	.text
	/* XXX this touches tr5, which it should not, perhaps */

#define	TLB_STATS_PRE(t) \
	mfctl	itmr, r17	! \
	mtctl	r17, tr5
#define	TLB_STATS_AFT(t) \
	mfctl	itmr, r16			! \
	mfctl	tr5, r17			! \
	ldil	L%__CONCAT(t,_c), r25		! \
	ldo	R%__CONCAT(t,_c)(r25), r25	! \
	sub	r16, r17, r16			! \
	ldw	0(r25), r24			! \
	ldw	4(r25), r17			! \
	ldo	1(r24), r24			! \
	ldo	-2(r16), r16			! \
	add	r16, r17, r17			! \
	stw	r24, 0(r25)			! \
	stw	r17, 4(r25)

#else
#define	TLB_STATS_PRE(t)	/**/
#define	TLB_STATS_AFT(t)	/**/
a1275 23
#if defined(HP7000_CPU) || defined(HP7100_CPU) || defined(HP7200_CPU)
#define	TLB_PULL(bits)							! \
	/* space:pgaddr -- r8:r9 */					! \
	mfctl	vtop, r16						! \
	ldwax,s	r8(r16), r17		/* space -> page directory */	! \
	extru	r9, 9, 10, r25						! \
	combt,=,n r0, r17, TLABEL(all)					! \
	ldwax,s	r25(r17), r24		/* page -> page table */	! \
	extru	r9, 19, 10, r16						! \
	combt,=,n r0, r24, TLABEL(all)					! \
	ldwax,s	r16(r24), r17		/* va -> pa:prot */		! \
	sh2addl	r16, r24, r25						! \
	combt,=,n r0, r17, TLABEL(all)					! \
	depi	(bits), 21+bits, 1+bits, r17				! \
	mfctl	tr7, r1							! \
	stwas	r17, 0(r25)		/* store back w/ the bits */	! \
	shd	r17, r0, 13, r25					! \
	dep	r8, 30, 15, r25		/* mix0r the pid from the sid */! \
	dep	r0, 31, 12, r17		/* needed ? */			! \
	addi	2, r25, r25						! \
	extru	r17, 24, 25, r17

	.align	32
d1279 34
a1312 10
	TLB_STATS_PRE(tlbd)
	TLB_PULL(1)
	mfsp	sr1, r16
	mtsp	r8, sr1
	idtlba	r17,(sr1, r9)
	idtlbp	r25,(sr1, r9)
	mtsp	r16, sr1
	TLB_STATS_AFT(tlbd)
	rfir
	nop
a1314 1
$itlbna_x
a1315 1
$itlbna_s
d1317 1
a1317 13
$itlbna_t
	TLB_STATS_PRE(itlb)
	TLB_PULL(0)
	extru,=	r25, 5, 1, r0	/* gate needs a kernel pid */
	depi	0, 30, 15, r25
	mfsp	sr1, r16
	mtsp	r8, sr1
	iitlba	r17,(sr1, r9)
	iitlbp	r25,(sr1, r9)
	mtsp	r16, sr1
	TLB_STATS_AFT(itlb)
	rfir
	nop
d1323 24
d1348 2
a1349 2
	 * from the 7100lc ers, pg.6:
	 * pa7100 provides cr28 for dtlb traps only
d1351 27
a1377 4
$dtlb_t
$dtlbna_t
	TLB_STATS_PRE(dtlb)
	TLB_PULL(0)
d1379 1
d1381 1
d1384 9
a1393 1
	TLB_STATS_AFT(dtlb)
a1395 1
#endif /*  defined(HP7000_CPU) || defined(HP7100_CPU) || defined(HP7200_CPU) */
d1398 45
a1443 33
#define	IITLBAF(r)	.word	0x04000440 | ((r) << 16)
#define	IITLBPF(r)	.word	0x04000400 | ((r) << 16)
#define	IDTLBAF(r)	.word	0x04001440 | ((r) << 16)
#define	IDTLBPF(r)	.word	0x04001400 | ((r) << 16)

/*
 * possible optimizations:
 *	change pte to reduce number of shifts
 *	reorder to reduce stalls
 */
#define	TLB_PULL_L(bits)						! \
	/* space:pgaddr -- r8:r9 */					! \
	mfctl	vtop, r16						! \
	ldwx,s	r8(r16), r17		/* space -> page directory */	! \
	extru	r9, 9, 10, r25						! \
	combt,=,n r0, r17, TLABEL(all)					! \
	ldwx,s	r25(r17), r24		/* page -> page table */	! \
	extru	r9, 19, 10, r16						! \
	combt,=,n r0, r24, TLABEL(all)					! \
	ldwx,s	r16(r24), r17		/* va -> pa:prot */		! \
	sh2addl	r16, r24, r25						! \
	combt,=,n r0, r17, TLABEL(all)					! \
	copy	r17, r16						! \
	depi	(bits), 21+bits, 1+bits, r17				! \
	mfctl	tr7, r1							! \
	xor,=	r16, r17, r0		/* do not store if unchanged */	! \
	stws	r17, 0(r25)		/* store back w/ the bits */	! \
	shd	r17, r0, 13, r25					! \
	dep	r8, 30, 15, r25		/* mix0r the pid from the sid */! \
	dep	r0, 31, 12, r17		/* needed ? */			! \
	addi	2, r25, r25						! \
	extru	r17, 24, 25, r17					! \
	sync
d1447 1
a1447 7
	TLB_STATS_PRE(tlbd)
	TLB_PULL_L(1)
	IDTLBAF(17)
	IDTLBPF(25)
	TLB_STATS_AFT(tlbd)
	rfir
	nop
d1450 2
a1451 3
	 * from 7100lc ers, pg.6:
	 * we found a post-silicon bug that makes cr28
	 * unreliable for the itlb miss handler
d1453 17
d1471 49
a1519 8
$itlbna_l
	TLB_STATS_PRE(itlb)
	TLB_PULL_L(0)
	extru,=	r25, 5, 1, r0	/* gate needs a kernel pid */
	depi	0, 30, 15, r25
	IITLBAF(17)
	IITLBPF(25)
	TLB_STATS_AFT(itlb)
d1522 5
a1526 7
$dtlbna_l
$dtlb_l
	TLB_STATS_PRE(dtlb)
	TLB_PULL_L(0)
	IDTLBAF(17)
	IDTLBPF(25)
	TLB_STATS_AFT(dtlb)
d1531 53
d1745 1
a1745 1
	/* use ,bc each cache line */
d1776 9
a1784 9
	stw	r19, TF_R19(t3)	/* t4 */
	stw	r23, TF_R23(t3)
	stw	r24, TF_R24(t3)
	stw	r25, TF_R25(t3)
	stw	r26, TF_R26(t3)
	stw	r27, TF_R27(t3)
	stw	r28, TF_R28(t3)
	stw	r29, TF_R29(t3)
	stw	r31, TF_R31(t3)
d1823 1
a1823 1
	dep	r0, 24, 25, arg0
a1856 212
#if defined(HP7000_CPU) || defined(HP7100_CPU)
/*
 * void desidhash_s(void)
 */
LEAF_ENTRY(desidhash_s)
ALTENTRY(desidhash_x)
	sync
	MFCPU_T(DR_CPUCFG,22)	/* t1 */
	MFCPU_T(DR_CPUCFG,22)
	nop
	nop
	depi	0, DR0_PCXS_DHE, 3, t1	/* 3 4 DR0_PCXS_DOMAIN|DR0_PCXS_IHE */
	depi	1, DR0_PCXS_EQWSTO, 1, t1
	depi	0, DR0_PCXS_DHPMC, 1, t1
	depi	0, DR0_PCXS_ILPMC, 1, t1
	sync
	MTCPU_T(22,DR_CPUCFG)
	MTCPU_T(22,DR_CPUCFG)
	nop
	nop
	bv	0(rp)
	extru	t1, 4, 5, ret0	/* return chip revision */
EXIT(desidhash_s)
#endif /* HP7000_CPU || HP7100_CPU */

#ifdef HP7200_CPU
/*
 * void desidhash_t(void)
 */
LEAF_ENTRY(desidhash_t)
	sync
	MFCPU_T(DR_CPUCFG,22)	/* t1 */
	MFCPU_T(DR_CPUCFG,22)
	nop
	nop
	depi	0, DR0_PCXT_IHE, 1, t1
	depi	0, DR0_PCXT_DHE, 1, t1
	depi	0, DR0_PCXT_DHPMC, 1, t1
	depi	0, DR0_PCXT_ILPMC, 1, t1
	sync
	MTCPU_T(22,DR_CPUCFG)
	MTCPU_T(22,DR_CPUCFG)
	nop
	nop
	bv	0(rp)
	extru	t1, 4, 5, ret0	/* return chip revision */
EXIT(desidhash_t)
#endif /* HP7200_CPU */

#ifdef HP7100LC_CPU

/*
 * int
 * ibtlb_l(int i, pa_space_t sp, vaddr_t va, paddr_t pa, vsize_t sz, u_int prot)
 */
LEAF_ENTRY(ibtlb_l)
	rsm	(PSW_R|PSW_I), t4
	nop ! nop ! nop ! nop ! nop ! nop ! nop

	bv	0(rp)
	mtsm	t4
EXIT(ibtlb_l)

/* hpti_l(addr,size) */
LEAF_ENTRY(hpti_l)
	ldo	-1(arg1), arg1
	depi	0, 31, 12, arg1
	ldi	0x1c0, t1		/* cache size assumed 128k XXX */
	or	arg0, t1, arg0
	sync
	MTCPU_C(26,DR0_PCXL2_HTLB_ADDR)
	MTCPU_C(25,DR0_PCXL2_HTLB_CFG)
	nop
	nop
	bv,n	r0(rp)
	nop
EXIT(hpti_l)

/*
 * int
 * pbtlb_l(int i)
 */
LEAF_ENTRY(pbtlb_l)
	; DR_PAGE0
	rsm	(PSW_R|PSW_I), t4
	nop ! nop ! nop ! nop
	ldil	L%0xc041, t1
	ldo	R%0xc041(t1), t1
	dep	arg0, 30, 3, t1
	sync
	MTCPU_T(22,DR_DTLB)	/* t1 */
	nop
	nop
	mtsp	r0, sr1
	idtlba	r0,(sr1,r0)
	idtlbp	r0,(sr1,r0)
	zdepi	-1, 18, 1, t1
	nop
	sync
	MTCPU_T(22,DR_DTLB)
	nop
	nop
	bv	0(rp)
	mtsm	t4
EXIT(pbtlb_l)

/*
 * int desidhash_l(void)
 */
LEAF_ENTRY(desidhash_l)
	MFCPU_C(DR_CPUCFG,22)	/* t1 */
	nop
	nop
	depi	0, DR0_PCXL_L2IHASH_EN, 2, t1	/* + DR0_PCXL_L2DHASH_EN */
	depi	0, DR0_PCXL_L2IHPMC, 1, t1	/* don't reset */
	depi	0, DR0_PCXL_L2DHPMC, 1, t1	/* don't reset */
	depi	0, DR0_PCXL_L1IHPMC, 1, t1	/* don't reset */
	depi	0, DR0_PCXL_L2PARERR,1, t1	/* don't reset */
	sync
	MTCPU_C(22,DR_CPUCFG)
	nop
	nop
	bv	0(rp)
	extru	t1, 4, 5, ret0	/* return chip revision */
EXIT(desidhash_l)

#endif /* HP7100LC_CPU */

/*
 * High Priority Machine Check Interrupt
 */
	.export	TLABEL(hpmc), entry
ENTRY(TLABEL(hpmc),0)

	mtsp	r0, sr0
	ldil	L%hppa_vtop, t1
	ldw	R%hppa_vtop(t1), t1
	mtctl	t1, CR_VTOP

	.import	hpmc_dump, code
	ldil	L%hpmc_dump, rp
	ldo	R%hpmc_dump(rp), rp
	ldil	L%kpsw, %arg2
	ldw	R%kpsw(%arg2), %arg2
	depi	0, PSW_I_POS, 1, %arg2
	stw	%arg2, R%kpsw(t1)
	ldil	L%emrg_stack, arg1
	b	$kernel_setup
	ldw	R%emrg_stack(arg1), arg1

	/* never returns, but still */
hpmc_never_dies
	b	hpmc_never_dies
	nop
EXIT(TLABEL(hpmc))

/*
 * transfer of control handler
 */
ENTRY(hppa_toc,0)

	mtsp	r0, sr0
	ldil	L%hppa_vtop, t1
	ldw	R%hppa_vtop(t1), t1
	mtctl	t1, CR_VTOP

	/* TODO reload btlb */

	.import	boot, code
	ldil	L%boot, rp
	ldo	R%boot(rp), rp
	ldil	L%kpsw, %arg2
	ldw	R%kpsw(%arg2), %arg2
	depi	0, PSW_I_POS, 1, %arg2
	stw	%arg2, R%kpsw(t1)
	ldi	0, arg0
	ldil	L%emrg_stack, arg1
	b	$kernel_setup
	ldw	R%emrg_stack(arg1), arg1

ALTENTRY(hppa_toc_end)
	.word	0
EXIT(hppa_toc)

/*
 * power fail recovery handler
 */
ENTRY(hppa_pfr,0)

	mtsp	r0, sr0
	ldil	L%hppa_vtop, t1
	ldw	R%hppa_vtop(t1), t1
	mtctl	t1, CR_VTOP

	/* TODO reload btlb */

	.import	boot, code
	ldil	L%boot, rp
	ldo	R%boot(rp), rp
	ldil	L%kpsw, %arg2
	ldw	R%kpsw(%arg2), %arg2
	depi	0, PSW_I_POS, 1, %arg2
	stw	%arg2, R%kpsw(t1)
	ldi	RB_HALT|RB_POWERDOWN, arg0
	ldil	L%emrg_stack, arg1
	b	$kernel_setup
	ldw	R%emrg_stack(arg1), arg1

ALTENTRY(hppa_pfr_end)
	.word	0
EXIT(hppa_pfr)

d1958 2
a1959 2
	addi	-1, arg0, arg1
	fdc	r0(sr1, arg1)
d1964 1
a1964 1
	nop
d2005 2
a2006 2
	addi	-1, arg0, arg1
	pdc	r0(sr1, arg1)
d2011 1
a2011 1
	nop
d2052 2
a2053 2
	addi	-1, arg0, arg1
	fic	r0(sr1, arg1)
d2058 1
a2058 1
	nop
d2133 1
a2133 1
	ldw	U_PCB+PCB_ONFAULT(t1), r1	! \
d2142 1
a2142 1
	stw	r1, U_PCB+PCB_ONFAULT(t1)	! \
d2149 1
a2149 1
	stw	r1, U_PCB+PCB_ONFAULT(t1)	! \
d2153 1
a2153 1
	stw	r1, U_PCB+PCB_ONFAULT(t1)
d2170 1
a2170 3
LEAF_ENTRY($copy_on_fault)
	stw	r1, PCB_ONFAULT+U_PCB(t4)
ALTENTRY(copy_on_fault)		/* for kcopy() */
d2173 1
a2173 1
EXIT($copy_on_fault)
d2182 6
a2187 7
	ldil	L%curproc, t4
	ldw	R%curproc(t4), t4
	ldw	P_ADDR(t4), t4
	ldw	PCB_ONFAULT+U_PCB(t4), r1
	ldil	L%$copy_on_fault, t2
	ldo	R%$copy_on_fault(t2), t2
	stw	t2, PCB_ONFAULT+U_PCB(t4)
a2200 1
	nop
d2204 3
a2207 1
	mtsp	ret0, sr2	/* XXX need this? */
d2209 1
a2209 2
	copy	r0, ret0
	add,=	r0, arg0, r0
a2210 2
	bv	0(rp)
	stw	r1, PCB_ONFAULT+U_PCB(t4)
d2216 1
a2216 1
 * XXX: do it the easy way, later we will calculate actual fuzz from itmr
d2220 5
d2229 2
a2230 5
	.import time, data
	ldil	L%time, t3
	ldo	R%time(t3), t3
	ldw	0(t3), t1
	ldw	4(t3), t2
d2235 3
a2237 5
	ldil	L%-1000000, t3
	ldo	R%-1000000(t3), t3

	addi	1, t2, t2
	addb,<,n t2, t3, microtime_no
a2238 1
	addi	1, t1, t1
d2353 1
a2353 1
	vdepi	0, 1, t3
a2455 17
	/*
	 * Either we must be switching to the same process, or
	 * the the new process' kernel stack must be reasonable.
	 */
	comb,=,n arg1, arg2, kstack_ok
	ldw     P_MD_REGS(arg1), t1
	ldw     P_ADDR(arg1), arg0
	ldw     TF_R30(t1), t1
	ldo     NBPG(arg0), arg0
	comb,>>,n arg0, t1, switch_error
	copy    arg1, t2
	sub     t1, arg0, t1
	ldil    L%USPACE, arg0
	ldo     R%USPACE(arg0), arg0
	comb,<<=,n arg0, t1, switch_error
	copy    arg1, t2
kstack_ok
d2472 4
d2477 1
a2477 3
	ldw	TF_R30(t1), t3
	copy	sp, t2
	stw,ma	r3, HPPA_FRAME_SIZE+20*4(sp)
a2478 2
	stw	t2, HPPA_FRAME_PSP(sp)
	stw	t3, HPPA_FRAME_ARG(0)(sp)	/* real user's stack */
d2481 1
a2504 1
	mtctl	r0, ccr			/* disable FPU */
d2509 1
d2511 2
a2512 1
	mtctl	t3, pidr2
d2514 3
a2516 2
	ldw	HPPA_FRAME_ARG(0)(sp), t3
	ldw	HPPA_FRAME_ARG(1)(sp), t4 /* in case we're on trampoline */
a2517 1
	ldw	HPPA_FRAME_CRP(t2), rp
a2533 2
	stw	t3, TF_R30(t1)
	fdc	r0(t1)
d2565 1
a2565 12
	/* switch onto the temporary stack */
	ldil	L%exit_stack, t4
	ldw	R%exit_stack(t4), t4
	stw	r0, HPPA_FRAME_SIZE+HPPA_FRAME_PSP(t4)
	stw	r0, HPPA_FRAME_SIZE+HPPA_FRAME_CRP(t4)
	ldo	HPPA_FRAME_SIZE(t4), sp

	/* start the stack frame for our callee */
	copy	sp, r3
	ldo	HPPA_FRAME_SIZE(sp), sp
	stw	r3, HPPA_FRAME_PSP(sp)

d2583 1
a2583 1
	bv,n	r0(t4)
@


1.46.4.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.46.4.1 2002/06/11 03:35:37 art Exp $	*/
a109 24

	.globl	intrcnt, eintrcnt, intrnames, eintrnames
intrcnt
	.block	16 * 4
eintrcnt
intrnames
	.asciz	"spur"
	.asciz	"lev1"
	.asciz	"lev2"
	.asciz	"lev3"
	.asciz	"lev4"
	.asciz	"lev5"
	.asciz	"lev6"
	.asciz	"lev7"
	.asciz	"lev8"
	.asciz	"lev9"
	.asciz	"lev10"
	.asciz	"lev11"
	.asciz	"lev12"
	.asciz	"lev13"
	.asciz	"lev14"
	.asciz	"lev15"
	.asciz	"clock"
eintrnames
d113 1
d171 4
a174 5
	/* assuming size being page-aligned */
#define	STACK_ALLOC(n,s)	\
	ldil	L%(n), t1	! \
	ldil	L%(s), t2	! \
	stw	arg3, R%(n)(t1)	! \
d178 1
d202 1
a202 1
	ldil	L%(USPACE+NBPG), arg0		/* normal U plus red zone */
d209 1
a209 1
	stw	t3, R%proc0+P_MD_REGS(t2)
d224 1
a224 1
	ldi	PSL_Q|PSL_I, arg2
d241 1
a241 1
	rsm	RESET_PSL, r0
d297 1
a297 1
	rsm	RESET_PSL, r0
d347 3
d440 1
a440 1
	ldi	PSL_Q, arg0 /* (!pdc_flag && args[0] == PDC_PIM)? PSL_M:0) */
d546 3
d552 2
a553 2
	be	R%$syscall(sr1, t2)
	nop ! nop ! nop ! nop
d572 4
a575 3
	ldil	L%curproc, t2
	ldw	R%curproc(sr1, t2), t2
	ldw	P_ADDR(sr1, t2), t3	/* XXX can use ,sl */
d578 2
a579 4
	ldo	NBPG(t3), t3
	stw	t3, P_MD_REGS(sr1, t2)
	ldo	TRAPFRAME_SIZEOF(t3), t3
	stw	t4, TF_R19 -TRAPFRAME_SIZEOF(sr1, t3)	/* t4 for vfork() */
d581 1
a581 10
	/* gotta save the args, in case we gonna restart */
	stw	arg3, TF_R23-TRAPFRAME_SIZEOF(sr1, t3)
	stw	arg2, TF_R24-TRAPFRAME_SIZEOF(sr1, t3)
	stw	arg1, TF_R25-TRAPFRAME_SIZEOF(sr1, t3)
	stw	arg0, TF_R26-TRAPFRAME_SIZEOF(sr1, t3)
	stw	r27, TF_R27-TRAPFRAME_SIZEOF(sr1, t3)	/* dp */
	stw	sp, TF_R30 -TRAPFRAME_SIZEOF(sr1, t3)	/* user stack */
	copy	t3, sp
	stw,ma	r0, HPPA_FRAME_SIZE+HPPA_FRAME_MAXARGS(sr1, sp)
	stw	r0, HPPA_FRAME_CRP(sr1, sp)
d588 1
a588 1
	stw	ret0, TF_CR8-TRAPFRAME_SIZEOF(sr1, t3)	/* pidr1 */
a597 1
	stw	r2 , TF_R2 -TRAPFRAME_SIZEOF(sr1, t3)
a598 1
	copy	t3, r3
d617 34
d665 1
a665 1
	ldil	L%TFF_LAST|TFF_SYS, arg1
d669 2
d674 1
a674 1
	stw	arg0, TF_SR1-TRAPFRAME_SIZEOF(sr1, t3)
d708 2
d738 1
a738 1
	ldw	P_MD_REGS(r1), t3
d761 17
a777 10
	ldil	L%$trap_tmp_save, t2
	/* use ,bc each cache line */
	ldw  0(t3), r1 ! ldw  4(t3), t1 ! stw r1,  0(t2) ! stw t1,  4(t2)
	ldw  8(t3), r1 ! ldw 12(t3), t1 ! stw r1,  8(t2) ! stw t1, 12(t2)
	ldw 16(t3), r1 ! ldw 20(t3), t1 ! stw r1, 16(t2) ! stw t1, 20(t2)
	ldw 24(t3), r1 ! ldw 28(t3), t1 ! stw r1, 24(t2) ! stw t1, 28(t2)
	ldw 32(t3), r1 ! ldw 36(t3), t1 ! stw r1, 32(t2) ! stw t1, 36(t2)
	ldw 40(t3), r1 ! ldw 44(t3), t1 ! stw r1, 40(t2) ! stw t1, 44(t2)
	ldw 48(t3), r1 ! ldw 52(t3), t1 ! stw r1, 48(t2) ! stw t1, 52(t2)
	ldw 56(t3), r1 ! ldw 60(t3), t1 ! stw r1, 56(t2) ! stw t1, 60(t2)
a842 2
	ldw	TF_CR0(sr3, t3), t1
	mtctl	t1, rctr
d852 1
a852 1
	rsm	RESET_PSL, r0
d996 1
d998 3
a1052 39
	.export TLABEL(excpt), entry
ENTRY(TLABEL(excpt),0)
	/* assume we never get this one w/o fpu [enabled] */
	copy	rp, r1
	mtctl	arg0, tr5
	.import	fpu_save, code
	.call
	bl	fpu_save, rp
	mfctl	cr30, arg0
	copy	r1, rp
	mtctl	r0, ccr		/* cause a reload after exception */
	ldil	L%fpu_curpcb, r1
	mfctl	cr30, arg0
	stw	r0, R%fpu_curpcb(r1)

	/* now, check for trap */
	ldw	0(arg0), r1
	bb,>=,n	r1, HPPA_FPU_T_POS, excpt_notrap
	ldw	8(arg0), r1
	extru	r1, 5, 6, r1
	comib,<>,n HPPA_FPU_UNMPL, r1, excpt_notrap

	ldw	0(arg0), r1
	depi	0, HPPA_FPU_T_POS, 1, r1
	stw	r1, 0(arg0)
	ldw	8(arg0), r1
	stw	r0, 8(arg0)
	fdc	r0(arg0)
	.import	$fpu_emulate, code
	b	$fpu_emulate
	mfctl	tr5, arg0

excpt_notrap
	fdc	r0(arg0)
	mfctl	tr5, arg0
	sync
	b	TLABEL(all)
	ldi	T_EXCEPTION, r1
EXIT(TLABEL(excpt))
d1055 3
a1057 1
ENTRY(TLABEL(emu),0)
d1070 3
d1074 2
a1075 14
	mfctl	iir, r8
	extru	r8, 5, 6, r9	/* no sfu implementation right now */
	comib,=	4, r9, TLABEL(all)
	ldi	T_ILLEGAL, r1

	extru	r8, 25, 3, r9	/* only fpu coprocessor emulation now */
	comib,<< 4, r9, TLABEL(all)
	ldi	T_ILLEGAL, r1

	/* if we are already enabled and hit again, emulate */
	mfctl	ccr, r1
	extru,<> r1, 25, 2, r0
	b,n	$fpusw_set
	nop
d1077 2
a1078 15
#if 0
	/* here we emulate the fld/fst */
	mfctl	iir, r1
	extru	r1, 5, 6, r1
	comib,=	0xb, r9, TLABEL(all)
	ldi	T_ILLEGAL, r1

	mfctl	iir, r1
	extru	r1, 5, 6, r1
	comib,=	0x9, r9, TLABEL(all)
	ldi	T_ILLEGAL, r1
#endif
	.import	$fpu_emulate, code
	b	$fpu_emulate
	nop
a1079 1
$fpusw_set
d1081 9
a1089 2
	depi	3, 25, 2, r1
	mtctl	r1, ccr
d1091 32
a1122 16
	ldil	L%fpu_curpcb, r16
	mfctl	cr30, r9
	ldw	R%fpu_curpcb(r16), r16

	comb,=,n r16, r9, $fpusw_done
	comb,=,n r16, r0, $fpusw_nosave

	copy	arg0, r17
	copy	rp, r1
	copy	r16, arg0
	.import	fpu_save, code
	.call
	bl	fpu_save, rp
	ldo	PCB_FPREGS+U_PCB(arg0), arg0
	copy	r1, rp
	copy	r17, arg0
d1127 39
a1165 38
	ldil	L%fpu_csw, r1
	ldw	R%fpu_csw(r1), r16
	ldo	1(r16), r16
	ldo	31*8+PCB_FPREGS+U_PCB(r9), r17
	stw	r16, R%fpu_csw(r1)

	fldds,ma -8(r17), fr31
	fldds,ma -8(r17), fr30
	fldds,ma -8(r17), fr29
	fldds,ma -8(r17), fr28
	fldds,ma -8(r17), fr27
	fldds,ma -8(r17), fr26
	fldds,ma -8(r17), fr25
	fldds,ma -8(r17), fr24
	fldds,ma -8(r17), fr23
	fldds,ma -8(r17), fr22
	fldds,ma -8(r17), fr21
	fldds,ma -8(r17), fr20
	fldds,ma -8(r17), fr19
	fldds,ma -8(r17), fr18
	fldds,ma -8(r17), fr17
	fldds,ma -8(r17), fr16
	fldds,ma -8(r17), fr15
	fldds,ma -8(r17), fr14
	fldds,ma -8(r17), fr13
	fldds,ma -8(r17), fr12
	fldds,ma -8(r17), fr11
	fldds,ma -8(r17), fr10
	fldds,ma -8(r17), fr9
	fldds,ma -8(r17), fr8
	fldds,ma -8(r17), fr7
	fldds,ma -8(r17), fr6
	fldds,ma -8(r17), fr5
	fldds,ma -8(r17), fr4
	fldds,ma -8(r17), fr3
	fldds,ma -8(r17), fr2
	fldds,ma -8(r17), fr1
	fldds     0(r17), fr0	/* fr0 must be restored last */
d1167 2
a1168 2
	ldil	L%fpu_curpcb, r1
	stw	r17, R%fpu_curpcb(r1)
d1171 4
a1174 1
	rfir
d1178 85
d1302 1
a1302 1
	ldo	-2(r16), r16 /* for mtctl */	! \
d1417 1
a1417 1
	sub,=	r16, r17, r0		/* do not store if unchanged */	! \
a1527 17
	/*
	 * Set up the kernel stack pointer.  If the trap happened
	 * while we were in unprivileged code, or in privileged
	 * code in the SYSCALLGATE page, move to the kernel stack
	 * in curproc's PCB; otherwise, start a new stack frame
	 * on whatever kernel stack we're already on.
	 *
	 * This used to check only for a trap while we were in
	 * unprivileged code, but this ignored the possibility
	 * that a trap could come in during the period between
	 * a gateway instruction to raise privilege and the
	 * disabling of interrupts.  During this period we're
	 * still on the user's stack, and we must move to the
	 * kernel stack.
	 *
	 * - fredette@@
	 */
a1528 1
	ldil	L%SYSCALLGATE, t2
d1530 1
a1530 3
	dep	t1, 31, PGSHIFT, t2
	dep,<>	t1, 31, 2, r0
	comb,<>	t1, t2, $trap_from_kernel
d1562 1
a1562 1
	nop ! nop ! nop ! nop ! nop ! nop ! nop ! nop
d1608 6
a1619 3
	copy	sp, r3
	stw,mb	r0, -HPPA_FRAME_SIZE(r3)

a1669 1
	mfctl	ccr, t2
d1671 1
a1671 1
	stw	t2, TF_CR10(t3)
d1705 3
d1716 1
d1718 1
a1718 1
	ldw	-HPPA_FRAME_SIZE-TRAPFRAME_SIZEOF+TF_FLAGS(sp), arg0
d1720 1
a1720 1
	ldo	-HPPA_FRAME_SIZE-TRAPFRAME_SIZEOF(sp), t3
d1726 1
a1726 1
	ldo	-HPPA_FRAME_SIZE-TRAPFRAME_SIZEOF(sp), t3
d1730 1
a1730 1
	ldw	P_MD_REGS(t2), t3
d1792 1
a1792 1
	rsm	(PSL_R|PSL_I), t4
d1820 1
a1820 1
	rsm	(PSL_R|PSL_I), t4
d1880 1
a1880 1
	depi	0, PSL_I_POS, 1, %arg2
a1886 3
	ldil	L%GBCAST_ADDR, t1
	ldi	CMD_RESET, t2
	stw	t2, R%GBCAST_ADDR(t1)
d1909 1
a1909 1
	depi	0, PSL_I_POS, 1, %arg2
d1937 1
a1937 1
	depi	0, PSL_I_POS, 1, %arg2
d2007 1
a2007 1
	rfir
a2010 184
LEAF_ENTRY(fpu_save)
	fstds,ma %fr0 , 8(arg0)
	fstds,ma %fr1 , 8(arg0)
	fstds,ma %fr2 , 8(arg0)
	fstds,ma %fr3 , 8(arg0)
	fstds,ma %fr4 , 8(arg0)
	fstds,ma %fr5 , 8(arg0)
	fstds,ma %fr6 , 8(arg0)
	fstds,ma %fr7 , 8(arg0)
	fstds,ma %fr8 , 8(arg0)
	fstds,ma %fr9 , 8(arg0)
	fstds,ma %fr10, 8(arg0)
	fstds,ma %fr11, 8(arg0)
	fstds,ma %fr12, 8(arg0)
	fstds,ma %fr13, 8(arg0)
	fstds,ma %fr14, 8(arg0)
	fstds,ma %fr15, 8(arg0)
	fstds,ma %fr16, 8(arg0)
	fstds,ma %fr17, 8(arg0)
	fstds,ma %fr18, 8(arg0)
	fstds,ma %fr19, 8(arg0)
	fstds,ma %fr20, 8(arg0)
	fstds,ma %fr21, 8(arg0)
	fstds,ma %fr22, 8(arg0)
	fstds,ma %fr23, 8(arg0)
	fstds,ma %fr24, 8(arg0)
	fstds,ma %fr25, 8(arg0)
	fstds,ma %fr26, 8(arg0)
	fstds,ma %fr27, 8(arg0)
	fstds,ma %fr28, 8(arg0)
	fstds,ma %fr29, 8(arg0)
	fstds,ma %fr30, 8(arg0)
	fstds    %fr31, 0(arg0)
	fdc	r0(arg0)
	ldo	-60(arg0), arg0
	fdc	r0(arg0)
	ldo	-32(arg0), arg0
	fdc	r0(arg0)
	ldo	-32(arg0), arg0
	fdc	r0(arg0)
	ldo	-32(arg0), arg0
	fdc	r0(arg0)
	ldo	-32(arg0), arg0
	fdc	r0(arg0)
	ldo	-32(arg0), arg0
	fdc	r0(arg0)
	ldo	-32(arg0), arg0
	fdc	r0(arg0)
	bv	r0(rp)
	sync
EXIT(fpu_save)

#ifdef FPEMUL
	/*
	 * Emulate FPU
	 *
	 * iisq:iioq - exception triggered instruction
	 */
ENTRY($fpu_emulate,320)
	mtctl	sp, tr3
	mtctl	r31, tr2

	ldil	L%fpemu_stack, r31
	ldw	R%fpemu_stack(r31), r31

	stw	r2 , TF_R2 (r31)
	stw	r3 , TF_R3 (r31)
#ifdef DDB
	stw	r4 , TF_R4 (r31)
	stw	r5 , TF_R5 (r31)
	stw	r6 , TF_R6 (r31)
	stw	r7 , TF_R7 (r31)
	stw	r8 , TF_R8 (r31)
	stw	r9 , TF_R9 (r31)
	stw	r10, TF_R10(r31)
	stw	r11, TF_R11(r31)
	stw	r12, TF_R12(r31)
	stw	r13, TF_R13(r31)
	stw	r14, TF_R14(r31)
	stw	r15, TF_R15(r31)
	stw	r16, TF_R16(r31)
	stw	r17, TF_R17(r31)
	stw	r18, TF_R18(r31)
#endif
	stw	r19, TF_R19(r31)
	stw	r20, TF_R20(r31)
	stw	r21, TF_R21(r31)
	stw	r22, TF_R22(r31)
	stw	r23, TF_R23(r31)
	stw	r24, TF_R24(r31)
	stw	r25, TF_R25(r31)
	stw	r26, TF_R26(r31)
	stw	r27, TF_R27(r31)
	stw	r28, TF_R28(r31)
	stw	r29, TF_R29(r31)
	mfctl	tr2, t2
	mfctl	tr3, t1
	stw	t1, TF_R30(r31)
	stw	t2, TF_R31(r31)
	copy	r1, arg0
	mfctl	sar, r1
	stw	r1, TF_CR11(r31)
	stw	arg0, TF_CR19(r31)

	ldo	TRAPFRAME_SIZEOF(r31), r3
	ldo	TRAPFRAME_SIZEOF+HPPA_FRAME_SIZE(r31), sp

	ldil	L%$global$, dp
	ldo	R%$global$(dp), dp

	.import	fpu_emulate, code
	ldil	L%fpu_emulate,t1
	ldo	R%fpu_emulate(t1),t1
	mfctl	cr30, arg2
	.call
	blr	r0,rp
	bv,n	0(t1)
	nop

	mfctl	cr30, arg0
	fdc	r0(arg0)
	ldo	32(arg0), arg0
	fdc	r0(arg0)
	ldo	32(arg0), arg0
	fdc	r0(arg0)
	ldo	32(arg0), arg0
	fdc	r0(arg0)
	ldo	32(arg0), arg0
	fdc	r0(arg0)
	ldo	32(arg0), arg0
	fdc	r0(arg0)
	ldo	32(arg0), arg0
	fdc	r0(arg0)
	ldo	32(arg0), arg0
	fdc	r0(arg0)

	ldil	L%fpemu_stack, r31
	ldw	R%fpemu_stack(r31), r31

	ldw	TF_CR11(r31), r1
	mtsar	r1
	ldw	TF_R2 (r31), r2
	ldw	TF_R3 (r31), r3
	copy	ret0, r1
#ifdef DDB
	ldw	TF_R4 (r31), r4
	ldw	TF_R5 (r31), r5
	ldw	TF_R6 (r31), r6
	ldw	TF_R7 (r31), r7
	ldw	TF_R8 (r31), r8
	ldw	TF_R9 (r31), r9
	ldw	TF_R10(r31), r10
	ldw	TF_R11(r31), r11
	ldw	TF_R12(r31), r12
	ldw	TF_R13(r31), r13
	ldw	TF_R14(r31), r14
	ldw	TF_R15(r31), r15
	ldw	TF_R16(r31), r16
	ldw	TF_R17(r31), r17
	ldw	TF_R18(r31), r18
#endif
	ldw	TF_R19(r31), r19
	ldw	TF_R20(r31), r20
	ldw	TF_R21(r31), r21
	ldw	TF_R22(r31), r22
	ldw	TF_R23(r31), r23
	ldw	TF_R24(r31), r24
	ldw	TF_R25(r31), r25
	ldw	TF_R26(r31), r26
	ldw	TF_R27(r31), r27
	ldw	TF_R28(r31), r28
	ldw	TF_R29(r31), r29
	ldw	TF_R30(r31), r30
	ldw	TF_R31(r31), r31

	comb,<>	r0, r1, TLABEL(all)
	ldi	T_EXCEPTION, r1

	rfir
	nop
EXIT($fpu_emulate)

#endif /* FPEMUL */

a2231 1
	mtsp	r0, sr1				! \
a2238 1
	mtsp	r0, sr1				! \
a2243 1
	mtsp	r0, sr1
d2261 3
a2263 6
LEAF_ENTRY(copy_on_fault)
	mtsp	r0, sr1
	mtsp	r0, sr2
	stw	r1, PCB_ONFAULT+U_PCB(r2)
	ldw	HPPA_FRAME_CRP(sp), rp
	ldo	-64(sp), sp
d2266 1
a2266 1
EXIT(copy_on_fault)
a2273 4
	ldw	HPPA_FRAME_ARG(4)(sp), t2
	ldo	64(sp), sp
	add	t2, arg1, t2
	stw	rp, HPPA_FRAME_CRP(sp)
d2275 7
a2281 7
	ldil	L%curproc, t1
	ldw	R%curproc(t1), t3
	ldil	L%copy_on_fault, t4
	ldw	P_ADDR(t3), r2
	ldo	R%copy_on_fault(t4), t4
	ldw	PCB_ONFAULT+U_PCB(r2), r1
	stw	t4, PCB_ONFAULT+U_PCB(r2)
d2283 2
d2287 1
d2292 1
a2292 1
	comb,=	t2, arg1, $spstrcpy_exit
d2298 1
a2298 4
	mtsp	r0, sr1
	mtsp	r0, sr2
	stw	r1, PCB_ONFAULT+U_PCB(r2)
	ldw	HPPA_FRAME_CRP(sp), rp
d2300 1
a2300 1
	ldo	-64(sp), sp
d2302 2
a2303 1
	sub,=	r0, arg0, r0
d2306 1
a2306 1
	copy	r0, ret0
d2309 1
d2355 1
a2355 1
	comb,<>,n r0, t1, Lsetrunqueue_panic
d2357 1
a2357 1
	comb,<>,n r0, t1, Lsetrunqueue_panic
d2359 2
a2360 2
	comib,=,n SRUN, t1, Lsetrunqueue_ok
Lsetrunqueue_panic
d2373 1
a2373 1
Lsetrunqueue_ok
d2381 19
a2399 1
	ldil	L%whichqs, arg3
a2402 1
	ldw	R%whichqs(arg3), t3
d2404 1
a2404 1
	mtctl	t1, sar
d2406 3
a2408 3
	vdepi	1, 1, t3
	bv	0(rp)
	stw	t3, R%whichqs(arg3)
d2418 2
a2419 1
	extru	t2, 29, 5, arg2
a2420 1
	mtsar	arg2
d2428 1
a2435 1
	nop
d2446 4
a2450 1
	sub,<>	t4, arg0, r0
d2452 1
d2454 1
a2454 1
	stw	t4, P_BACK(arg0)
a2529 3
	ldil	L%want_resched, t4
	stw	r0, R%want_resched(t4)

d2535 3
a2538 1
	sub,<>	t2, arg0, r0
d2542 4
d2571 3
d2585 1
a2585 1
	ldw	P_MD_REGS(arg2), t1
d2619 1
a2619 1
	ldw	P_MD_REGS(arg1), t1
d2647 1
d2651 1
d2653 1
a2653 3
	ldil	L%curproc, t1
	bv	0(rp)
	stw	arg1, R%curproc(t1)
d2656 49
d2714 1
a2714 1
	ldw	P_MD_REGS(t2), t3
@


1.46.4.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d4 1
a4 1
 * Copyright (c) 1998-2003 Michael Shalayeff
d37 13
a62 21
/*
 * Copyright (c) 1990,1991,1992,1994 The University of Utah and
 * the Computer Systems Laboratory (CSL).  All rights reserved.
 *
 * Permission to use, copy, modify and distribute this software is hereby
 * granted provided that (1) source code retains these copyright, permission,
 * and disclaimer notices, and (2) redistributions including binaries
 * reproduce the notices in supporting documentation, and (3) all advertising
 * materials mentioning features or use of this software display the following
 * acknowledgement: ``This product includes software developed by the
 * Computer Systems Laboratory at the University of Utah.''
 *
 * THE UNIVERSITY OF UTAH AND CSL ALLOW FREE USE OF THIS SOFTWARE IN ITS "AS
 * IS" CONDITION.  THE UNIVERSITY OF UTAH AND CSL DISCLAIM ANY LIABILITY OF
 * ANY KIND FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * CSL requests users of this software to return to csl-dist@@cs.utah.edu any
 * improvements that they make and grant CSL redistribution rights.
 *
 *	Utah $Hdr: locore.s 1.63 95/01/20$
 */
d72 1
d75 3
d103 3
a105 2
#define	EMRG_STACKSIZE	(1*NBPG)
#define	FPEMU_STACKSIZE	(1*NBPG)
a111 1
	.export	intrcnt, data
a113 1
	.export	eintrcnt, data
a114 1
	.export	intrnames, data
d125 1
a125 1
	.asciz	"clock"
d132 1
a132 1
	.export	eintrnames, data
d134 1
a134 5
	.export netisr, data
	.align 16
netisr
	.word	0
	.align	16
d150 8
d296 1
d345 1
a345 1
	mtctl	r0, eiem
d462 1
d498 1
d741 1
d944 1
a944 1
#if defined(HP7100LC_CPU) || defined(HP7300LC_CPU)
d972 1
a972 1
	CTRAP(intr,T_INTERRUPT,)	/*  4. external interrupt */
d1039 1
a1039 2
	copy	arg0, r8
	mfctl	cr30, r9
d1043 1
a1043 1
	copy	r9, arg0
a1044 1
	copy	r8, arg0
d1047 1
d1051 1
a1051 1
	ldw	0(r9), r1
d1053 1
a1053 1
	ldw	8(r9), r1
d1057 1
a1057 1
	ldw	0(r9), r1
d1059 4
a1062 3
	stw	r1, 0(r9)
	ldw	8(r9), r1
	stw	r0, 8(r9)
d1065 1
a1065 1
	fdc	r0(r9)
d1068 2
d1095 3
a1097 6
	/*
	 * pass through for all coprocessors now and
	 * do not check the uid here.
	 * in case that piece does not exist emulate
	 * or the trap will be generted later.
	 */
a1104 3
	mtctl	r0, ccr		/* cause a reload after exception */
	ldil	L%fpu_curpcb, r1
	stw	r0, R%fpu_curpcb(r1)
a1116 1
	mfctl	iir, r1
d1209 1
a1209 1
#if 0
a1254 1
	copy	r17, r16						! \
d1256 1
a1256 1
	sub,=	r16, r17, r0		/* do not store if unchanged */	! \
d1320 1
a1320 1
#if defined(HP7100LC_CPU) || defined(HP7300LC_CPU)
d1346 1
d1507 1
d1729 1
a1729 1
#if defined(HP7100LC_CPU) || defined(HP7300LC_CPU)
d1895 1
a1895 93
	.export	TLABEL(intr), entry
	.import	cpl, data
	.import	ipending, data
	.import	imask, data
	.import	intr_table, data
ENTRY(TLABEL(intr),0)

	mfctl	eirr, r8
	mtctl	r8, eirr	/* ack now */

	ldil	L%ipending, r17
	ldw	R%ipending(r17), r24
	ldil	L%intr_table, r1
	ldo	R%intr_table(r1), r1
$intr_ffs
	addi	16, r1, r1
	bb,>=	r8, 31, $intr_ffs
	shd	r0, r8, 1, r8

	ldb	2-16(r1), r17
	ldw	4-16(r1), r9
	subi,<>	1, r17, r0
	bv,n	r0(r9)
	nop

	mfctl	sar, r25
	ldb	1-16(r1), r9
	mtsar	r9
	vdepi	1, 1, r24
	mtsar	r25

	ldb	0-16(r1), r9
	ldil	L%intrcnt, r25
	ldo	R%intrcnt(r25), r25
	sh2add	r9, r25, r25
	ldw	0(r25), r17
	addi	1, r17, r17
	stw	r17, 0(r25)

$intr_cont
	comb,<>	r0, r8, $intr_ffs
	nop

	ldil	L%ipending, r17
	stw	r24, R%ipending(r17)
	ldil	L%cpl, r17
	ldw	R%cpl(r17), r17
	ldil	L%imask, r9
	ldo	R%imask(r9), r9
	ldwx,s	r17(r9), r16
	ldi	T_INTERRUPT, r1
	andcm,=	r24, r16, r0
	b	TLABEL(all)
	nop

	rfir
	nop
EXIT(TLABEL(intr))

	.export	gsc_intr, entry
LEAF_ENTRY(gsc_intr)

	ldw	8-16(r1), r9	/* arg: ioreg */
	mtctl	r1, tr7
	ldw	0(r9), r16	/* irr */

	ldw	12-16(r1), r1	/* next: sub-intr_table */
$gsc_ffs
	addi	16, r1, r1
	bb,>=	r16, 31, $gsc_ffs
	shd	r0, r16, 1, r16

	mfctl	sar, r25
	ldb	1-16(r1), r17
	mtsar	r17
	vdepi	1, 1, r24
	mtsar	r25

	ldb	0-16(r1), r17
	ldil	L%intrcnt, r25
	ldo	R%intrcnt(r25), r25
	sh2add	r17, r25, r25
	ldw	0(r25), r17
	addi	1, r17, r17
	stw	r17, 0(r25)

	comb,<>	r0, r16, $gsc_ffs
	nop

	b	$intr_cont
	mfctl	tr7, r1
EXIT(gsc_intr)

d1898 3
d1902 2
a1903 2
	mfctl	pcoq, r8
	extru,=	r8, 31, 2, r0
d1908 7
a1914 7
	ldil	L%etext, r9
	ldo	R%etext(r9), r9
	comb,>>=,n r8, r9, $ibrk_bad

	mfctl	iir, r8
	extru	r8, 31, 5, r9
	comib,<>,n HPPA_BREAK_KERNEL, r9, $ibrk_bad
d1917 3
a1919 4
	extru	r8, 18, 13, r9
	comib,=,n HPPA_BREAK_GET_PSW, r9, $ibrk_getpsw
	comib,=,n HPPA_BREAK_SET_PSW, r9, $ibrk_setpsw
	comib,=,n HPPA_BREAK_SPLLOWER, r9, $ibrk_spllower
d1923 1
d1925 1
a1925 1
	nop
d1936 4
a1939 22
$ibrk_spllower
	/* skip the break */
	mtctl	r0, pcoq
	mfctl	pcoq, r9
	mtctl	r9, pcoq
	ldo	4(r9), r9
	mtctl	r9, pcoq

	ldil	L%ipending, r8
	ldw	R%ipending(r8), r8
	ldil	L%imask, r9
	ldo	R%imask(r9), r9
	ldil	L%cpl, r17
	ldw	R%cpl(r17), ret0
	ldwx,s	arg0(r9), r16
	stw	arg0, R%cpl(r17)
	ldi	T_INTERRUPT, r1
	andcm,=	r8, r16, r0
	b	TLABEL(all)
	nop
	rfir
	nop
d1947 7
a1953 5
	mfctl	pcoq, r9
	mtctl	r9, pcoq
	ldo	4(r9), r9
	mtctl	r9, pcoq

d1992 1
a1992 1
	ldo	-56(arg0), arg0
d2017 2
a2018 1
	copy	r31, r9
a2022 1
	/* stw	r1 , TF_R1 (r31) shadowed */
d2030 2
a2031 2
	/* stw	r8 , TF_R8 (r31) shadowed */
	/* stw	r9 , TF_R9 (r31) shadowed */
d2038 2
a2039 2
	/* stw	r16, TF_R16(r31) shadowed */
	/* stw	r17, TF_R17(r31) shadowed */
d2047 2
a2048 2
	/* stw	r24, TF_R24(r31) shadowed */
	/* stw	r25, TF_R25(r31) shadowed */
d2053 4
a2056 2
	stw	sp, TF_R30(r31)
	stw	r9, TF_R31(r31)
d2098 1
a2100 1
	mtsar	r1
d2107 2
a2108 2
	/* ldw	TF_R8 (r31), r8 shadowed */
	/* ldw	TF_R9 (r31), r9 shadowed */
d2115 2
a2116 2
	/* ldw	TF_R16(r31), r16 shadowed */
	/* ldw	TF_R17(r31), r17 shadowed */
d2124 2
a2125 2
	/* ldw	TF_R24(r31), r24 shadowed */
	/* ldw	TF_R25(r31), r25 shadowed */
d2287 1
a2287 1
 * across function calls.  According to the "HP 9000 Series 800 Assembly
d2344 50
a2393 1
	.align	32
d2449 35
a2580 4
	ldil	L%cpl, t1
	ldw	R%cpl(t1), ret0
	stw	ret0, HPPA_FRAME_SL(sp)
	stw	rp, HPPA_FRAME_CRP(sp)
d2591 3
a2593 2
	 * t1:   &whichqs
	 * arg2: old curproc
d2598 2
d2601 3
d2605 1
d2609 1
a2609 2
	copy	r0, arg0
	break	HPPA_BREAK_KERNEL, HPPA_BREAK_SPLLOWER
d2614 2
a2615 3
	ldil	L%cpl, arg0
	b	switch_search
	stw	ret0, R%cpl(arg0)
d2698 1
a2740 1
	ldw	HPPA_FRAME_SL(t2), ret0
a2759 2
	ldil	L%cpl, t1
	stw	ret0, R%cpl(t1)
d2762 1
@


1.45
log
@genassym.cf changes force a lot of case changes here.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.44 2001/03/29 02:18:44 mickey Exp $	*/
d171 1
a171 1
	ldi	NBPG+TF_SIZE, t1
d182 1
a182 1
	ldo	NBPG+TF_SIZE(arg3), sp
d195 2
a196 2
	stw	t1, TF_FLAGS-TF_SIZE(sp)
	stw	arg3, TF_CR30-TF_SIZE(sp)
d540 1
a540 1
	ldo	NBPG+TF_SIZE(t2), t3
d542 3
a544 3
	stw	t1, TF_R22 -TF_SIZE(sr1, t3)	/* syscall # */
	stw	t4, TF_R30 -TF_SIZE(sr1, t3)	/* user stack */
	stw	r1, TF_CR15-TF_SIZE(sr1, t3)	/* eiem */
d552 2
a553 2
	stw	r27, TF_R27-TF_SIZE(sr1, t3)	/* dp */
	stw	r3 , TF_R3 -TF_SIZE(sr1, t3)
d556 15
a570 15
	stw	r4 , TF_R4 -TF_SIZE(sr1, t3)
	stw	r5 , TF_R5 -TF_SIZE(sr1, t3)
	stw	r6 , TF_R6 -TF_SIZE(sr1, t3)
	stw	r7 , TF_R7 -TF_SIZE(sr1, t3)
	stw	r8 , TF_R8 -TF_SIZE(sr1, t3)
	stw	r9 , TF_R9 -TF_SIZE(sr1, t3)
	stw	r10, TF_R10-TF_SIZE(sr1, t3)
	stw	r11, TF_R11-TF_SIZE(sr1, t3)
	stw	r12, TF_R12-TF_SIZE(sr1, t3)
	stw	r13, TF_R13-TF_SIZE(sr1, t3)
	stw	r14, TF_R14-TF_SIZE(sr1, t3)
	stw	r15, TF_R15-TF_SIZE(sr1, t3)
	stw	r16, TF_R16-TF_SIZE(sr1, t3)
	stw	r17, TF_R17-TF_SIZE(sr1, t3)
	stw	r18, TF_R18-TF_SIZE(sr1, t3)
d608 2
a609 2
	stw	r31, TF_IIOQH-TF_SIZE(sr1, t3)
	stw	arg1, TF_IIOQT-TF_SIZE(sr1, t3)
d612 2
a613 2
	stw	arg0, TF_IISQH-TF_SIZE(sr1, t3)
	stw	arg0, TF_IISQT-TF_SIZE(sr1, t3)
d615 2
a616 2
	stw	arg0, TF_CR20-TF_SIZE(sr1, t3)
	stw	r31, TF_CR21-TF_SIZE(sr1, t3)
d619 2
a620 2
	stw	arg0, TF_SR3-TF_SIZE(sr1, t3)
	stw	r28, TF_CR8-TF_SIZE(sr1, t3)	/* pidr1 */
d624 2
a625 2
	stw	arg0, TF_CR19-TF_SIZE(sr1, t3)
	stw	arg1, TF_FLAGS-TF_SIZE(sr1, t3)
d631 4
a634 4
	stw	arg0, TF_SR0-TF_SIZE(sr1, t3)
	stw	arg1, TF_SR1-TF_SIZE(sr1, t3)
	stw	arg2, TF_SR2-TF_SIZE(sr1, t3)
	stw	arg3, TF_SR4-TF_SIZE(sr1, t3)
d640 4
a643 4
	stw	arg0, TF_SR5-TF_SIZE(sr1, t3)
	stw	arg1, TF_SR6-TF_SIZE(sr1, t3)
	stw	arg2, TF_SR7-TF_SIZE(sr1, t3)
	stw	arg3, TF_CR9-TF_SIZE(sr1, t3)
d648 2
a649 2
	stw	arg2, TF_CR12-TF_SIZE(sr1, t3)
	stw	arg3, TF_CR13-TF_SIZE(sr1, t3)
d658 2
a659 2
	stw	arg0, TF_CR23-TF_SIZE(sr1, t3)
	stw	arg1, TF_CR24-TF_SIZE(sr1, t3)
d663 2
a664 2
	stw	arg0, TF_CR25-TF_SIZE(sr1, t3)
	stw	arg1, TF_CR28-TF_SIZE(sr1, t3)
d677 1
a677 1
	ldo	-TF_SIZE(t3), arg0
d1150 1
a1150 1
	ldo	R%TF_SIZE+HPPA_FRAME_SIZE(r31), sp
d1681 1
a1681 1
	ldo	HPPA_FRAME_SIZE+TF_SIZE(sp), sp
d2596 5
a2600 3
	/* TODO call signal handler */

	/*ldo	SIGF_SC(sp), arg0*/
@


1.44
log
@leaf_entry, better entry
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.43 2001/03/29 00:03:34 mickey Exp $	*/
d184 3
a186 3
	stw	r0, u_pcb+pcb_onfault(arg3)
	stw	r0, u_pcb+pcb_space(arg3)	/* XXX HPPA_SID_KERNEL == 0 */
	stw	arg3, u_pcb+pcb_uva(arg3)
d192 1
a192 1
	stw	arg3, R%proc0+p_addr(t2)
d536 1
a536 1
	ldw	p_addr(sr1, t3), t2	/* XXX can use ,sl */
d693 1
a693 1
	ldw	p_md(r1), t3
d1047 1
a1047 1
	/* ldo	pcb_fpregs+u_pcb(t1), t1 */
d1090 1
a1090 1
	ldo	31*8+pcb_fpregs+u_pcb(t2), t3
d1287 1
a1287 1
	ldw	hpt_entry(r24), r24
d1290 2
a1291 2
	ldw	pv_va(r24), r25
	ldw	pv_space(r24), r17
d1293 1
a1293 1
	ldw	pv_hash(r24), r24
d1295 1
a1295 1
	ldw	pv_hash(r24), r24
d1299 1
a1299 1
	ldw	pv_tlbprot(r24), r25
d1335 1
a1335 1
	ldw	hpt_tag(r24),r17
d1342 1
a1342 1
	ldw	hpt_tlbpage(r24), r17
d1344 1
a1344 1
	ldw	hpt_tlbprot(r24), r25
d1351 1
a1351 1
	ldw	hpt_entry(r24),r24
d1354 2
a1355 2
	ldw	pv_va(r24),r25
	ldw	pv_space(r24),r17
d1357 1
a1357 1
	ldw	pv_hash(r24),r24
d1359 1
a1359 1
	ldw	pv_hash(r24),r24
d1362 1
a1362 1
	ldw	pv_tlbprot(r24),r25
d1369 2
a1370 2
	stw	r25, pv_tlbprot(r24)
	ldw	pv_tlbpage(r24),r17
d1373 3
a1375 3
	stw	r16, hpt_tag(r24)
	stw	r25, hpt_tlbprot(r24)
	stw	r17, hpt_tlbpage(r24)
d1453 1
a1453 1
	ldw	hpt_entry(r24), r16
d1456 2
a1457 2
	ldw	pv_va(r16), r25
	ldw	pv_space(r16), r17
d1459 1
a1459 1
	ldw	pv_hash(r16), r16
d1461 1
a1461 1
	ldw	pv_hash(r16), r16
d1464 2
a1465 2
	ldw	pv_tlbpage(r16), r17
	ldw	pv_tlbprot(r16), r25
d1489 1
a1489 1
	ldw	hpt_entry(r24), r16
d1492 2
a1493 2
	ldw	pv_va(r16), r25
	ldw	pv_space(r16), r17
d1495 1
a1495 1
	ldw	pv_hash(r16), r16
d1497 1
a1497 1
	ldw	pv_hash(r16), r16
d1500 2
a1501 2
	ldw	pv_tlbpage(r16), r17
	ldw	pv_tlbprot(r16), r25
d1509 1
a1509 1
	stw	r25, pv_tlbprot(r16)
d1512 2
a1513 2
	stw	r16, hpt_tag(r24)
	stw	r25, hpt_tlbprot(r24)
d1515 1
a1515 1
	stw	r17, hpt_tlbpage(r24)
d1657 1
a1657 1
	ldw	u_pcb+pcb_uva(t2), sp
d1851 1
a1851 1
	ldw	p_md(t2), t3
d2130 1
a2130 1
	ldw	p_addr(t1), t1			! \
d2133 3
a2135 3
	ldw	u_pcb+pcb_onfault(t1), t3	! \
	stw	t2, u_pcb+pcb_onfault(t1)	! \
	ldw	u_pcb+pcb_space(t1), t2		! \
d2142 1
a2142 1
	stw	r0, u_pcb+pcb_onfault(t1)	! \
d2149 1
a2149 1
	stw	r0, u_pcb+pcb_onfault(t1)	! \
d2153 1
a2153 1
	stw	r0, u_pcb+pcb_onfault(t1)
d2184 1
a2184 1
	ldw	p_addr(r31), r31
d2187 1
a2187 1
	stw	t2, pcb_onfault+u_pcb(r31)
d2204 1
a2204 1
	stw	r0, pcb_onfault+u_pcb(r31)
d2257 1
a2257 1
	ldw	p_back(arg0), t1
d2259 1
a2259 1
	ldw	p_wchan(arg0), t1
d2261 1
a2261 1
	ldb	p_stat(arg0), t1
d2279 1
a2279 1
	ldb	p_priority(arg0), t2
d2303 4
a2306 4
	ldw	p_back(t4), t2
	stw	t4, p_forw(arg0)
	stw	arg0, p_back(t4)
	stw	arg0, p_forw(t2)
d2308 1
a2308 1
	stw	t2, p_back(arg0)
d2320 1
a2320 1
	ldb	p_priority(arg0), t2
d2345 5
a2349 5
	ldw	p_back(arg0), t4
	stw	r0, p_back(arg0)
	ldw	p_forw(arg0), arg0
	stw	arg0, p_forw(t4)
	stw	t4, p_back(arg0)
d2413 1
a2413 1
	ldw	p_forw(t2), arg1
d2433 4
a2436 4
	ldw	p_forw(arg1), arg0
	stw	arg0, p_forw(t2)
	stw	t2, p_back(arg0)
	stw	r0, p_back(arg1)
d2450 1
a2450 1
	ldw	p_wchan(arg1), t1
d2453 1
a2453 1
	ldb	p_stat(arg1), t1
d2471 1
a2471 1
	ldw	p_md(arg2), t1
d2505 1
a2505 1
	ldw	p_md(arg1), t1
d2589 1
a2589 1
	ldw	p_md(t2), t3
@


1.43
log
@.comm in .bss, ldo R% of pdc wrapper stack
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.42 2001/03/28 20:58:03 mickey Exp $	*/
d120 1
a120 1
ENTRY($start)
d324 1
a324 1
ENTRY(pdc_call)
d995 1
a995 1
ENTRY(TLABEL(hpmc))
d1015 1
a1015 1
ENTRY(TLABEL(emu))
d1143 1
a1143 1
ENTRY(TLABEL(excpt))
d1172 1
d1215 1
a1215 1
ENTRY($sfu_emu)
d1243 1
a1243 1
ENTRY(desidhash_s)
d1262 1
a1262 1
ENTRY(desidhash_t)
d1402 1
a1402 1
ENTRY(ibtlb_l)
d1413 1
a1413 1
ENTRY(pbtlb_l)
d1431 1
a1431 1
ENTRY(desidhash_l)
d1589 1
a1589 1
ENTRY(TLABEL(all))
d1859 1
a1859 1
ENTRY(TLABEL(ibrk))
d1921 1
a1921 1
ENTRY(fdcache)
d1968 1
a1968 1
ENTRY(pdcache)
d2015 1
a2015 1
ENTRY(ficache)
d2062 1
a2062 1
ENTRY(setjmp)
d2093 1
a2093 1
ENTRY(longjmp)
d2125 1
a2125 1
ENTRY(name)					! \
d2152 1
a2152 1
ENTRY(fusufault)
d2170 1
a2170 1
ENTRY(copy_on_fault)
d2180 1
a2180 1
ENTRY(spstrcpy)
d2218 1
a2218 1
ENTRY(microtime)
d2255 1
a2255 1
ENTRY(setrunqueue)
d2319 1
a2319 1
ENTRY(remrunqueue)
d2365 1
a2365 1
ENTRY(cpu_switch)
d2550 1
a2550 1
ENTRY(switch_exit)
d2575 1
d2580 1
a2580 1
ENTRY(switch_trampoline)
d2587 1
d2595 1
a2595 1
ENTRY(sigcode)
d2600 1
d2605 1
d2612 1
a2612 1
ENTRY(linux_sigcode)
@


1.42
log
@use diag not .word, better tlabel usage
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.41 2001/03/28 18:24:51 mickey Exp $	*/
d102 1
a102 2
	.space $PRIVATE$
	.subspa $BSS$
d105 1
a105 1
	.block	4*NBPG
d107 1
a107 1
	.block	4
d110 1
a110 1
	.block	4
d113 3
a115 1
	.block	4
d337 1
@


1.41
log
@ldil requires L% always it seems
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.40 2001/03/22 23:40:52 mickey Exp $	*/
d82 6
a87 6
#define	DR_PAGE0	.word (5 << 26) | (0x70 << 5)
#define	DR_PAGE1	.word (5 << 26) | (0x72 << 5)
#define	MTCPU_T(x,t) .word (5 << 26) | ((t) << 21) | ((x) << 16) | (0xc0 << 5)
#define	MTCPU_C(x,t) .word (5 << 26) | ((t) << 21) | ((x) << 16) | (0x12 << 5)
#define	MFCPU_T(r,x) .word (5 << 26) | ((r) << 21) | (0xa0 << 5) | (x)
#define	MFCPU_C(r,x) .word (5 << 26) | ((r) << 21) | ((x) << 16) | (0x30 << 5)
d993 1
a993 1
TLABEL(hpmc)
d1010 1
d1013 1
a1013 1
TLABEL(emu)
d1132 1
d1141 1
a1141 1
TLABEL(excpt)
d1209 1
d1212 1
a1212 1
$sfu_emu
d1215 1
d1242 2
a1243 2
	MFCPU_T(DR_CPUCFG,t1)
	MFCPU_T(DR_CPUCFG,t1)
d1248 2
a1249 2
	MTCPU_T(t1,DR_CPUCFG)
	MTCPU_T(t1,DR_CPUCFG)
d1260 2
a1261 2
	MFCPU_T(DR_CPUCFG,t1)
	MFCPU_T(DR_CPUCFG,t1)
d1266 2
a1267 2
	MTCPU_T(t1,DR_CPUCFG)
	MTCPU_T(t1,DR_CPUCFG)
d1415 1
a1415 1
	MTCPU_T(t1,DR_DTLB)
d1420 1
a1420 1
	MTCPU_T(t1,DR_DTLB)
d1429 1
a1429 1
	MFCPU_C(DR_CPUCFG,t1)
d1436 1
a1436 1
	MTCPU_C(t1,DR_CPUCFG)
d1586 1
a1586 1
TLABEL(all)
d1852 1
d1856 1
a1856 1
TLABEL(ibrk)
d1915 1
a1915 1

@


1.40
log
@shuffle the tlb handlers a little,
make a new one for na data fault,
since those w/ hpt need it.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.39 2001/02/26 22:19:17 mickey Exp $	*/
d715 1
a715 1
	ldil	$trap_tmp_save, arg1
d799 1
a799 1
	ldil	$trap_tmp_save, t3
d1597 1
a1597 1
	ldil	$trap_tmp_save, t3
d1737 1
a1737 1
	ldil	$trap_tmp_save, t2
@


1.39
log
@fix tlbd_l for a new register usage convention
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.38 2001/02/23 22:54:32 mickey Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998-2000 Michael Shalayeff
d106 1
a106 1
	.block	3*NBPG
d546 1
a546 1
	 * we beleive that any calee-save registers
d554 16
a569 15
	stw	r4,   1*4(sr1, t3)
	stw	r5,   2*4(sr1, t3)
	stw	r6,   3*4(sr1, t3)
	stw	r7,   4*4(sr1, t3)
	stw	r8,   5*4(sr1, t3)
	stw	r9,   6*4(sr1, t3)
	stw	r10,  7*4(sr1, t3)
	stw	r11,  8*4(sr1, t3)
	stw	r12,  9*4(sr1, t3)
	stw	r13, 10*4(sr1, t3)
	stw	r14, 11*4(sr1, t3)
	stw	r15, 12*4(sr1, t3)
	stw	r16, 13*4(sr1, t3)
	stw	r17, 14*4(sr1, t3)
	stw	r18, 15*4(sr1, t3)
a573 1
#endif
d880 1
d887 1
d894 1
d901 1
d1272 1
d1295 11
d1313 1
d1315 1
d1317 1
a1420 5
ENTRY(hpti_l)
	bv,n	r0(rp)
	nop
EXIT(hpti_l)

d1426 1
a1426 1
	depi	0, DR0_PCXL_L2IHASH_EN, 2, t1	/* 2 is 4 DR0_PCXL_L2DHASH_EN */
d1464 2
a1466 1
#ifdef DDB
a1467 3
#endif
	b	$tlbmiss_l
	depi	1, TFF_ITLB_POS, 1, r1	/* mark for ITLB insert */
a1468 1
	.align	8
d1470 1
a1470 6
	/*mfctl	cr28, r24*/
	HPTENT	/* weird, but sometimes dtlbmissna does not set cr28 */
#ifdef DDB
	mtctl	r24, cr28
#endif
$tlbmiss_l
d1482 1
a1482 1
	ldw	hpt_entry(r24),r16
d1485 6
a1490 6
	ldw	pv_va(r16),r25
	ldw	pv_space(r16),r17
	comb,<>,n r9,r25,$hash_loop_l
	ldw	pv_hash(r16),r16
	comb,<>,n r8,r17,$hash_loop_l
	ldw	pv_hash(r16),r16
d1493 2
a1494 2
	ldw	pv_tlbpage(r16),r17
	ldw	pv_tlbprot(r16),r25
a1579 62
	.align	32
	.export	TLABEL(ibrk), entry
TLABEL(ibrk)
	mtctl	t1, tr2
	mtctl	t2, tr3

	/* If called by a user process then always pass it to trap() */
	mfctl	pcoq, t1
	extru,=	t1, 31, 2, r0
	b,n	$ibrk_bad

	/* don't accept breaks from data segments */
	.import etext
	ldil	L%etext, t2
	ldo	R%etext(t2), t2
	comb,>>=,n t1, t2, $ibrk_bad

	mfctl	iir, t1
	extru	t1, 31, 5, t2
	comib,<>,n HPPA_BREAK_KERNEL, t2, $ibrk_bad

	/* now process all those `break' calls we make */
	extru	t1, 18, 13, t2
	comib,=,n HPPA_BREAK_GET_PSW, t2, $ibrk_getpsw
	comib,=,n HPPA_BREAK_SET_PSW, t2, $ibrk_setpsw

$ibrk_bad
	/* illegal (unimplemented) break entry point */
	mfctl	tr3, t2
	b	TLABEL(all)
	mfctl	tr2, t1

$ibrk_getpsw
	b	$ibrk_exit
	mfctl	ipsw, ret0

$ibrk_setpsw
	mfctl	ipsw, ret0
	b	$ibrk_exit
	mtctl	arg0, ipsw

$ibrk_setpsw_tovirt

	b	$ibrk_exit
	ldw	HPPA_FRAME_PSP(sp), sp

	/* insert other fast breaks here */
	nop ! nop

$ibrk_exit
	/* skip the break */
	mtctl	r0, pcoq
	mfctl	pcoq, t1
	mtctl	t1, pcoq
	ldo	4(t1), t1
	mtctl	t1, pcoq
	mfctl	tr3, t2
	mfctl	tr2, t1
	mfctl	tr7, r1
	rfi
	nop

d1595 1
a1595 3
	mtctl	t1, tr2
	mtctl	t2, tr3
	mtctl	t3, tr5
d1597 3
a1599 3
	mfctl	pcoq, t2
	bb,>=	t2, 31, $trap_from_kernel
	nop
a1600 18
	/* if trapped from user space load proc's ksp pa */
	mfctl	cr30, t1
	depi	1, T_USER_POS, 1, r1
	depi	1, TFF_LAST_POS, 1, r1
	ldw	u_pcb+pcb_uva(t1), t3
	b	$trap_make_frame
	ldo	NBPG(t3), t3

$trap_from_kernel
	/* align stack */
	ldo	TF_PHYS-1(sp), t3
	dep	r0, 31, 6, t3

$trap_make_frame
	/* t3 is va, t1 is pa of (struct trapframe *) */
	mfctl	tr3, t2
	mtctl	t3, tr3
	ldil	$trap_tmp_save, t3	/* we know it's in the low mem XXX */
a1601 4
	stw	t1, TF_R22(t3)
	stw	t2, TF_R21(t3)

	mfctl	tr5, t1
a1610 13
	mfctl	pcsq, t1
	mtctl	r0, pcsq
	mfctl	pcsq, t2
	stw	t1, TF_IISQH(t3)
	stw	t2, TF_IISQT(t3)
	mtctl	r0, pcsq

	mfctl	pcoq, t1
	mtctl	r0, pcoq
	mfctl	pcoq, t2
	stw	t1, TF_IIOQH(t3)
	stw	t2, TF_IIOQT(t3)

d1613 1
a1613 1
	stw	t1, TF_CR15(t3)
a1620 10
	mfctl	isr, t1
	mfctl	ior, t2
	stw	t1, TF_CR20(t3)
	stw	t2, TF_CR21(t3)

	mfctl	iir, t2
	stw	t2, TF_CR19(t3)
	stw	r1, TF_FLAGS(t3)
	mfctl	tr7, r1

a1628 4
	/* load the space queue */
	mtctl	r0, pcsq
	mtctl	r0, pcsq

d1635 27
a1661 3
	/* load in the address to "return" to with the rfir instruction */
	ldil	L%$trapnowvirt, t1
	ldo	R%$trapnowvirt(t1), t1
d1663 9
a1671 7
	/*
	 * load the offset queue, space queue was loaded as a side effect of
	 * saving the space queue above
	 */
	mtctl	t1, pcoq
	ldo	4(t1), t1
	mtctl	t1, pcoq
d1673 2
a1674 8
	/*
	 * Must do rfir not rfi since we may be called from tlbmiss routine
	 * (to handle page fault) and it uses the shadowed registers.
	 *
	 * Also translate the t3 (trapframe) back into va
	 */
	mfctl	tr3, t3
	ldo	HPPA_FRAME_SIZE+TF_SIZE(t3), sp
a1676 1

d1679 1
a1679 1
	 * t3 contains the physical address of the trapframe
d1727 21
a1751 5
	mfctl	sar, t1
	stw	t1, TF_CR11(t3)
	stw	r1, TF_R1(t3)
	stw	r2, TF_R2(t3)
	stw	r3, TF_R3(t3)
a1769 3
	/*	r20 already saved (t3)
	 *	r21 already saved (t2)
	 *	r22 already saved (t1) */
a1776 1
	/*	r30 already saved (sp) */
a1779 12
	 * Copy partially saved state from the store into the frame
	 * N.B. we are not doing any bundleing since it's only 16 words
	 */
	ldil	$trap_tmp_save, arg0
	copy	t3, arg1
	ldi	TF_PHYS, arg2
$trap_copy_loop
	ldwm	4(arg0), t1
	addib,>= -4, arg2, $trap_copy_loop
	stwm	t1, 4(arg1)

	/*
d1849 63
d2365 1
a2365 1
	/* remain on the old (curproc)'s stack until we have better choice */
d2508 2
a2571 2
	ldw	HPPA_FRAME_ARG(1)(sp), t1
	ldw	HPPA_FRAME_ARG(2)(sp), arg0
d2573 2
a2574 2
	blr	%r0, rp
	bv,n	%r0(t1)
@


1.38
log
@fix damn pcxl damn function
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.37 2000/08/15 20:12:15 mickey Exp $	*/
d1426 1
a1426 1
	mfctl	cr28, r16
d1432 1
a1432 1
	ldw	hpt_entry(r16), r24
d1434 3
a1436 3
	comb,=,n r0, r24, TLABEL(all)
	ldw	pv_va(r24), r25
	ldw	pv_space(r24), r17
d1438 1
a1438 1
	ldw	pv_hash(r24), r24
d1440 1
a1440 1
	ldw	pv_hash(r24), r24
d1443 2
a1444 2
	ldw	pv_tlbpage(r24),r17
	ldw	pv_tlbprot(r24), r25
@


1.37
log
@expand per-cpu control routines switch
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.36 2000/08/15 19:56:17 mickey Exp $	*/
d1213 2
a1214 2
	extru	r9, 23, 24, r16		/* r17 = (offset >> 8) */	! \
	zdep	r8, 26, 16, r24		/* r24 = (space << 5) */	! \
@


1.36
log
@ugly spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.35 2000/07/02 02:41:57 mickey Exp $	*/
d73 1
d79 9
d877 1
d881 1
d883 1
d887 1
d889 1
d893 1
d895 1
d899 1
d1162 1
a1162 1
	extru,=  arg0, 11, 1, r0
d1219 1
a1219 1
	or	r24, r16, r16		/* r16 = HPT entry */
d1228 37
d1269 1
a1269 1
	mtctl	r16, cr28
d1275 2
a1276 2
	ldw	hpt_entry(r16), r24
$hash_loop_tlbd_t		/* XXX must use ,sl */
a1290 1
	.align	32
d1307 1
a1307 2
	mtctl	r16, cr28
	copy	r16, r24
d1309 1
a1309 1
	ldw	hpt_tag(r16),r17
a1340 1
	 * The HPT entry address was saved by the HPTENT
d1358 1
d1366 1
d1371 53
d1452 1
a1452 1
	mtctl	r16, cr28
d1459 1
a1459 1
	/*mfctl	cr28, r16*/
d1462 1
a1462 1
	mtctl	r16, cr28
d1469 1
a1469 1
	 * r16 is the correspondent HPT entry pointer
d1476 1
a1476 1
	ldw	hpt_entry(r16),r24
d1478 3
a1480 3
	comb,=,n r0, r24, $tlbiflpa
	ldw	pv_va(r24),r25
	ldw	pv_space(r24),r17
d1482 1
a1482 1
	ldw	pv_hash(r24),r24
d1484 1
a1484 1
	ldw	pv_hash(r24),r24
d1487 2
a1488 2
	ldw	pv_tlbpage(r24),r17
	ldw	pv_tlbprot(r24),r25
d1496 1
a1496 2
	stw	r25, pv_tlbprot(r24)
	copy	r16, r24
d1516 1
d1518 1
d1521 1
a1522 1
	mfctl	iir, r17
d1524 1
a1525 1
	ldi	0x4d, r25
d1857 1
a1857 1
	 * N.B. we are not doing any bundeling since it's only 16 words
d1975 2
a1976 2
	addi	-1, arg0, arg1
	fdc	(sr1, arg1)
d1978 2
d2022 2
a2023 2
	addi	-1, arg0, arg1
	pdc	(sr1, arg1)
d2025 2
d2069 2
a2070 2
	addi	-1, arg0, arg1
	fic	(sr1, arg1)
d2072 2
d2611 10
a2620 3
	/* TODO signal trampoline */
	bv	0(rp)
	nop
@


1.35
log
@new kvtop through lpa; also put some spu/sfu bits in cpu.h
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.34 2000/06/05 12:58:29 art Exp $	*/
d47 1
a47 1
 * 	Utah $Hdr: locore.s 1.62 94/12/15$
d148 1
a148 1
	ldi    	-1, r1
d150 1
a150 1
	mtctl   r1, eirr
d195 1
a195 1
	mtctl	t1, pcoq	
d197 1
a197 1
	mtctl	t1, pcoq	
d268 1
a268 1
	mtctl	t1, pcoq	
d270 1
a270 1
	mtctl	t1, pcoq	
d300 1
a300 1
	bv,n    (r1)
d363 1
a363 1
	mfctl	cr27, t4	
d371 1
a371 1
	mfctl	cr31, t4	
d390 1
a390 1
	bv,n    (r31)
d431 2
a432 2
 *    System Call Gate
 *    Signal Return Gate
d438 1
a438 1
	.align  NBPG
d492 2
a493 2
	ldil    L%$syscall,r1
	be,n    R%$syscall(sr7,r1)
d528 1
a528 1
	ldo	NBPG+TF_SIZE(t2), t3	
d594 1
a594 1
	
d609 1
a609 1
	
d788 1
a788 1
	
d861 1
a861 1
#define	LDILDO(name) 			! \
d890 1
a890 1
	depi    0,31,PGSHIFT,r9	/* align offset to page */
d1014 1
a1014 1
	
d1141 1
a1141 1
	stw	r1,  TF_CR11(r31)
d1145 1
a1145 1
	or,tr    r0, r0, r0
d1185 1
a1185 1
	
d1195 1
a1195 1
	extru	r9, 23, 24, r16  	/* r17 = (offset >> 8) */	! \
d1215 1
a1215 1
	
d1235 1
a1235 1
	
d1340 1
a1340 1
	
d1564 1
a1564 1
$trap_make_frame	
d1744 1
a1744 1
 	/*	r30 already saved (sp) */
d1766 1
a1766 1
	
d1846 1
a1846 1
        fdc,m	arg3(sr1, arg1)
d1863 1
a1863 1
fdc_short                               /* flush one line at a time */
d1891 1
a1891 1
        pdc,m	arg3(sr1, arg1)
d1908 1
a1908 1
pdc_short                               /* flush one line at a time */
d1936 1
a1936 1
        fic,m	arg3(sr1, arg1)
d1953 1
a1953 1
fic_short                               /* flush one line at a time */
d2148 1
a2148 1
	
d2235 1
a2235 1
	ldil    L%panic, r1
d2241 1
a2241 1
	bv,n    %r0(r1)
d2323 1
a2323 1
	ldil    L%panic, r1
d2329 1
a2329 1
	bv,n    %r0(r1)
d2469 2
a2470 2
	ldil    L%exit2, t2
	ldo     R%exit2(t2), t2
d2472 2
a2473 2
	blr     %r0, rp
	bv,n    %r0(t2)
d2485 1
a2485 1
	bv,n    %r0(t1)
@


1.34
log
@Adjust for the reaper.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.33 2000/05/15 17:22:39 mickey Exp $	*/
d162 1
a162 2
	stw	r0, 0(t2)
	stw	r0, 4(t2)
d164 1
a164 1
	ldo	8(t2), t2
d346 1
a346 1
	stw	t1, HPPA_FRAME_ARG(4)(sp)
d364 1
a364 1
	stw	t1, HPPA_FRAME_ARG(12)(sp)
d520 1
d524 1
a524 1
	ldw	p_addr(sr1, t3), t2
d540 1
a541 1
	stw	r27, TF_R27-TF_SIZE(sr1, t3)	/* dp */
d543 17
a559 1
	stw	r0, 0(t3)	/* terminate frame */
d561 2
a562 2
	stw	r0, HPPA_FRAME_PSP(sp)
	stw	r0, HPPA_FRAME_CRP(sp)
d574 1
a574 1
	stw	arg0, 1*4(sr1, t3)
d1221 1
a1221 1
$hash_loop_tlbd_t
d1274 1
a1274 1
	comb,=,n r0, r24, TLABEL(all)
d1371 1
a1371 1
	comb,=,n r0, r24, TLABEL(all)
d1410 52
@


1.33
log
@fdcache/pdcache/ficache as out of line functions from lites
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.32 2000/04/27 18:00:11 mickey Exp $	*/
d2399 8
@


1.32
log
@fix pcxt tlb handler
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.31 2000/03/23 20:25:40 mickey Exp $	*/
d1761 135
a1895 1
	.align 32
@


1.31
log
@new cpu type switch code.
initializes tlb miss handlers correspondent to probed cpu features.
also btlb load routine.
versions written are for pcxl and others.
cpu-dep btlb loaders are missing, only generic for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.30 2000/03/06 03:03:52 mickey Exp $	*/
d1197 1
a1197 1
	HPTENT	/* will update cr28 */
d1224 1
d1236 1
a1236 1
	HPTENT	/* will update cr28 */
d1238 2
a1239 1
	
d1327 1
a1327 1
	HPTENT	/* will update cr28 */
@


1.30
log
@oops
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.29 2000/03/06 02:21:01 mickey Exp $	*/
a78 4
	/* this macro determines when to use cr28 (ie HVT works) */
#define	USECR28	((defined(HP7100LC_CPU) || defined(HP7300LC_CPU)) && \
	!(defined(HP71000_CPU) || defined(HP7200_CPU) || defined(HP7300_CPU)))

d811 1
d832 35
a866 5
#if USECR28
#define	LDCR28	mfctl	cr28, r24
#else
#define	LDCR28	/* nop */
#endif
d874 2
a875 2
	depi    0,31,PGSHIFT,r9	/* align offset to page */	! \
	LDCR28
d889 1
a889 1
	CTRAP(itlb,T_ITLBMISS,ITLBPRE)	/*  6. instruction TLB miss fault */
d902 3
a904 3
	CTRAP(dtlb,T_DTLBMISS,DTLBPRE)	/* 15. data TLB miss fault */
	CTRAP(itlb,T_ITLBMISSNA,ITLBPRE)/* 16. ITLB non-access miss fault */
	CTRAP(dtlb,T_DTLBMISSNA,DTLBPRE)/* 17. DTLB non-access miss fault */
d908 1
a908 1
	CTRAP(tlbd,T_TLB_DIRTY,DTLBPRE)	/* 20. TLB dirty bit trap */
d1185 1
a1185 2
	or	r16, r24, r24		/* r24 = HPT entry */		! \
	mtctl	r24, cr28
a1192 1

d1194 3
a1196 3
	.export	TLABEL(tlbd), entry
TLABEL(tlbd)
#if ! USECR28
d1198 1
a1198 1
#endif
d1204 2
a1205 2
	ldw	hpt_entry(r24), r24
$hash_loop_tlbd
d1209 1
a1209 1
	comb,<>,n r9, r25, $hash_loop_tlbd
d1211 1
a1211 1
	comb,<>,n r8, r17, $hash_loop_tlbd
a1213 1
#if ! USECR28
a1214 1
#endif
d1217 1
a1217 1
	b	$tlb_inshpt
d1221 9
a1229 13
	.export	TLABEL(itlb), entry
TLABEL(itlb)
#if USECR28
	HPTENT	/* will update cr28 */
#endif
	depi	1, TFF_ITLB_POS, 1, r1	/* mark for ITLB insert */
	/* FALLTHROUGH */

	.export	TLABEL(dtlb), entry
TLABEL(dtlb)

$tlbmiss
	/* r1 is the trap type
a1234 1
#if ! USECR28
d1236 1
d1238 1
a1239 1
	ldw	hpt_tag(r24),r17
d1243 1
a1243 1
	comb,<>,n r16, r17, $tlb_gottalook
d1246 1
a1246 1
	b	$tlb_gothpt
d1249 1
a1249 2
$tlb_gottalook
#endif
d1255 1
a1255 1
$hash_loop
d1259 1
a1259 1
	comb,<>,n r9,r25,$hash_loop
d1261 1
a1261 1
	comb,<>,n r8,r17,$hash_loop
d1272 1
a1272 1
$tlb_inshpt
a1273 3
#if USECR28
	VTAG	/* (r8,r9) -> r16 */
#endif
d1281 1
a1281 1
$tlb_gothpt
d1283 1
a1283 1
	bb,<	r1, TFF_ITLB_POS, $tlb_itlb
d1292 1
a1292 1
$tlb_itlb
d1298 95
@


1.29
log
@do not save/restore callee-save regs on trap, except for DDB
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.28 2000/02/10 15:16:59 mickey Exp $	*/
d1543 9
a1551 9
	stw	t10, TF_R10(t3)
	stw	t11, TF_R11(t3)
	stw	t12, TF_R12(t3)
	stw	t13, TF_R13(t3)
	stw	t14, TF_R14(t3)
	stw	t15, TF_R15(t3)
	stw	t16, TF_R16(t3)
	stw	t17, TF_R17(t3)
	stw	t18, TF_R18(t3)
@


1.28
log
@ack all ints along w/ masking 'em outi; on very early sys init
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.27 2000/01/25 22:11:38 mickey Exp $	*/
a321 1
	stw	t1, HPPA_FRAME_ARG(0)(sp)
d333 2
a334 1
	ldo	HPPA_FRAME_SIZE+24*4(ret1), ret1
d336 7
a342 1
	stw	sp, HPPA_FRAME_PSP(ret1)
d345 18
a362 18
	ldw	HPPA_FRAME_ARG(4)(sp), arg2
	ldw	HPPA_FRAME_ARG(5)(sp), arg3
	ldw	HPPA_FRAME_ARG(6)(sp), t1
	ldw	HPPA_FRAME_ARG(7)(sp), t2
	ldw	HPPA_FRAME_ARG(8)(sp), t3
	ldw	HPPA_FRAME_ARG(9)(sp), t4
	stw	t1, HPPA_FRAME_ARG(4)(ret1)
	stw	t2, HPPA_FRAME_ARG(5)(ret1)
	stw	t3, HPPA_FRAME_ARG(6)(ret1)
	stw	t4, HPPA_FRAME_ARG(7)(ret1)
	ldw	HPPA_FRAME_ARG(10)(sp), t1
	ldw	HPPA_FRAME_ARG(11)(sp), t2
	ldw	HPPA_FRAME_ARG(12)(sp), t3
	ldw	HPPA_FRAME_ARG(13)(sp), t4
	stw	t1, HPPA_FRAME_ARG(8)(ret1)
	stw	t2, HPPA_FRAME_ARG(9)(ret1)
	stw	t3, HPPA_FRAME_ARG(10)(ret1)
	stw	t4, HPPA_FRAME_ARG(11)(ret1)
d369 4
a372 4
	stw	t1, HPPA_FRAME_ARG(12)(ret1)
	stw	t2, HPPA_FRAME_ARG(13)(ret1)
	stw	t3, HPPA_FRAME_ARG(14)(ret1)
	stw	t4, HPPA_FRAME_ARG(15)(ret1)
d377 4
a380 4
	stw	t1, HPPA_FRAME_ARG(16)(ret1)
	stw	t2, HPPA_FRAME_ARG(17)(ret1)
	stw	t3, HPPA_FRAME_ARG(18)(ret1)
	stw	t4, HPPA_FRAME_ARG(19)(ret1)
a385 3
	mfctl	eiem, t1
	mtctl	r0, eiem

d389 1
a389 2
	stw	t1, HPPA_FRAME_ARG(22)(ret1)
	stw	ret0, HPPA_FRAME_ARG(23)(ret1)
a392 1
	copy	ret1, sp
d416 2
a417 5
	copy	sp, t4	
	ldw	HPPA_FRAME_PSP(t4), sp

	ldil	L%kernelmapped, t1
	ldw	R%kernelmapped(t1), t1
d422 1
a422 2
	ldw	HPPA_FRAME_ARG(22)(t4), t1
	ldw	HPPA_FRAME_ARG(23)(t4), arg0
a425 1
	mtctl	t1, eiem
d428 1
a428 1
	ldw	HPPA_FRAME_ARG(0)(sp), t1
d431 1
a431 1
	mtctl	t1, eiem
d539 5
a543 1
	stw	r2 , TF_R2 -TF_SIZE(sr1, t3)
a544 15
	stw	r4 , TF_R4 -TF_SIZE(sr1, t3)
	stw	r5 , TF_R5 -TF_SIZE(sr1, t3)
	stw	r6 , TF_R6 -TF_SIZE(sr1, t3)
	stw	r7 , TF_R7 -TF_SIZE(sr1, t3)
	stw	r8 , TF_R8 -TF_SIZE(sr1, t3)
	stw	r9 , TF_R9 -TF_SIZE(sr1, t3)
	stw	r10, TF_R10-TF_SIZE(sr1, t3)
	stw	r11, TF_R11-TF_SIZE(sr1, t3)
	stw	r12, TF_R12-TF_SIZE(sr1, t3)
	stw	r13, TF_R13-TF_SIZE(sr1, t3)
	stw	r14, TF_R14-TF_SIZE(sr1, t3)
	stw	r15, TF_R15-TF_SIZE(sr1, t3)
	stw	r16, TF_R16-TF_SIZE(sr1, t3)
	stw	r17, TF_R17-TF_SIZE(sr1, t3)
	stw	r18, TF_R18-TF_SIZE(sr1, t3)
d546 6
d553 13
a565 5
	/* copy arguments */
	stw	arg0,  0(sr1, t3)
	stw	arg1,  4(sr1, t3)
	stw	arg2,  8(sr1, t3)
	stw	arg3, 12(sr1, t3)
d570 4
a573 4
	stw	arg0, 16(sr1, t3)
	stw	arg1, 20(sr1, t3)
	stw	arg2, 24(sr1, t3)
	stw	arg3, 28(sr1, t3)
d576 2
a577 6
	ldw	HPPA_FRAME_ARG(10)(t4), arg2
	ldw	HPPA_FRAME_ARG(11)(t4), arg3
	stw	arg0, 32(sr1, t3)
	stw	arg1, 36(sr1, t3)
	stw	arg2, 40(sr1, t3)
	stw	arg3, 44(sr1, t3)
a652 4
	/* setup frame */
	stw	r0, HPPA_FRAME_PSP(sp)
	stw	r0, HPPA_FRAME_CRP(sp)

d654 1
a654 1
	copy	t3, arg1
d702 1
a703 1
	mtctl	t1, sar
d706 1
d722 2
a723 1
	ldw	TF_R19(t3), r19
d725 2
a726 2
	/*	r21(t3) is used as a temporary and will be restored later */
	/*	r22(t3) is used as a temporary and will be restored later */
d1522 9
d1533 3
a1535 2
	stw	r1,TF_R1(t3)
	stw	r2,TF_R2(t3)
d1537 15
a1551 2
	stw	rp, HPPA_FRAME_CRP(sp)
	stw	r3, -HPPA_FRAME_SIZE(sp)
d1553 2
a1554 18
	stw	r3,TF_R3(t3)
	stw	r4,TF_R4(t3)
	stw	r5,TF_R5(t3)
	stw	r6,TF_R6(t3)
	stw	r7,TF_R7(t3)
	stw	r8,TF_R8(t3)
	stw	r9,TF_R9(t3)
	stw	r10,TF_R10(t3)
	stw	r11,TF_R11(t3)
	stw	r12,TF_R12(t3)
	stw	r13,TF_R13(t3)
	stw	r14,TF_R14(t3)
	stw	r15,TF_R15(t3)
	stw	r16,TF_R16(t3)
	stw	r17,TF_R17(t3)
	stw	r18,TF_R18(t3)
	stw	r19,TF_R19(t3)
	/*	r20 already saved (t1)
d1556 1
a1556 1
	 *	r22 already saved (t3) */
d1580 1
a1580 1
	 * Save the necessary control registers that were not already saved.
a1624 1
	copy	t3, r5
d1630 1
d1632 1
a1632 1
	ldw	TF_FLAGS(r5), arg0
d1634 1
a1634 1
	copy	r5, t3
d1640 1
a1640 1
	copy	r5, t3
d2155 1
a2155 1
	nop
@


1.28.2.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d79 4
d322 1
d334 1
a334 4
	copy	sp, r1
	ldo	HPPA_FRAME_SIZE+24*4(ret1), sp

	stw	r1, HPPA_FRAME_PSP(sp)
d336 1
a336 5
	/* save kernelmapped and eiem */
	stw	ret0, HPPA_FRAME_ARG(21)(sp)
	stw	t1, HPPA_FRAME_ARG(22)(sp)

	/* copy arguments */
d339 18
a356 18
	ldw	HPPA_FRAME_ARG(4)(r1), arg2
	ldw	HPPA_FRAME_ARG(5)(r1), arg3
	ldw	HPPA_FRAME_ARG(6)(r1), t1
	ldw	HPPA_FRAME_ARG(7)(r1), t2
	ldw	HPPA_FRAME_ARG(8)(r1), t3
	ldw	HPPA_FRAME_ARG(9)(r1), t4
	stw	t1, HPPA_FRAME_ARG(4)(sp)
	stw	t2, HPPA_FRAME_ARG(5)(sp)
	stw	t3, HPPA_FRAME_ARG(6)(sp)
	stw	t4, HPPA_FRAME_ARG(7)(sp)
	ldw	HPPA_FRAME_ARG(10)(r1), t1
	ldw	HPPA_FRAME_ARG(11)(r1), t2
	ldw	HPPA_FRAME_ARG(12)(r1), t3
	ldw	HPPA_FRAME_ARG(13)(r1), t4
	stw	t1, HPPA_FRAME_ARG(8)(sp)
	stw	t2, HPPA_FRAME_ARG(9)(sp)
	stw	t3, HPPA_FRAME_ARG(10)(sp)
	stw	t4, HPPA_FRAME_ARG(11)(sp)
d363 4
a366 4
	stw	t1, HPPA_FRAME_ARG(12)(sp)
	stw	t2, HPPA_FRAME_ARG(13)(sp)
	stw	t3, HPPA_FRAME_ARG(14)(sp)
	stw	t4, HPPA_FRAME_ARG(15)(sp)
d371 4
a374 4
	stw	t1, HPPA_FRAME_ARG(16)(sp)
	stw	t2, HPPA_FRAME_ARG(17)(sp)
	stw	t3, HPPA_FRAME_ARG(18)(sp)
	stw	t4, HPPA_FRAME_ARG(19)(sp)
d380 3
d386 2
a387 1
	stw	ret0, HPPA_FRAME_ARG(23)(sp)
d391 1
d415 5
a419 2
	ldw	HPPA_FRAME_ARG(21)(sp), t1
	ldw	HPPA_FRAME_ARG(22)(sp), t2
d424 2
a425 1
	ldw	HPPA_FRAME_ARG(23)(sp), arg0
d429 1
d432 1
a432 1
	ldw	HPPA_FRAME_PSP(sp), sp
d435 1
a435 1
	mtctl	t2, eiem
d543 1
a543 5
	/*
	 * we beleive that any calee-save registers
	 * will be saved accordingly in either syscall()
	 * or deeper called functions
	 */
d545 15
a560 6
#ifdef DDB
	stw	r0, 0(t3)	/* terminate frame */
	copy	r0 , r3
	stw	r0, HPPA_FRAME_PSP(sp)
	stw	r0, HPPA_FRAME_CRP(sp)
#endif
d562 5
a566 13
	/*
	 * Copy Arguments
	 * unfortunately mmap() under bsd requires 7 words;
	 * linux is confined to 5, and hpux to 6.
	 * assuming the `long' syscall it gives us the maximum
	 * 9 words, which very much overkill for an average of 3.
	 * we keep it at 10, since bundling will keep it
	 * at the same speed as 9 anyway.
	 */
	stw	arg0, 1*4(sr1, t3)
	stw	arg1, 2*4(sr1, t3)
	stw	arg2, 3*4(sr1, t3)
	stw	arg3, 4*4(sr1, t3)
d571 4
a574 4
	stw	arg0, 5*4(sr1, t3)
	stw	arg1, 6*4(sr1, t3)
	stw	arg2, 7*4(sr1, t3)
	stw	arg3, 8*4(sr1, t3)
d577 6
a582 2
	stw	arg0, 9*4(sr1, t3)
	stw	arg1,10*4(sr1, t3)
d658 4
d663 1
a663 1
	ldo	4(t3), arg1
d711 1
a712 1
	ldw	TF_R1(t3), r1
a714 1
#ifdef DDB
d730 1
a730 2
#endif
	ldw	TF_R19(t3), t4
d732 2
a733 2
	/*	r21(t2) is used as a temporary and will be restored later */
	/*	r22(t1) is used as a temporary and will be restored later */
a821 1
#define	TELABEL(num)	__CONCAT(trap_ep_,num)
d842 5
a846 35
#define	STRAP(name,num,pre) \
	.export	TLABEL(name)$num, entry	! \
	.label	TLABEL(name)$num	! \
	pre				! \
	mtctl	r1, tr7			! \
	.export	TELABEL(num), entry	! \
	.label	TELABEL(num)		! \
	ldil	0,r1			! \
	ldo	0(r1), r1		! \
	.call				! \
	bv	0(r1)			! \
	ldi	num, r1

#define	LDILDO(name) 			! \
	.export	name, entry		! \
	.label	name			! \
	ldil	L%$name,%r1		! \
	ldo	R%$name(%r1), %r1

LDILDO(itlb_x)
LDILDO(dtlb_x)
LDILDO(tlbd_x)

LDILDO(itlb_s)
LDILDO(dtlb_s)
LDILDO(tlbd_s)

LDILDO(itlb_t)
LDILDO(dtlb_t)
LDILDO(tlbd_t)

LDILDO(itlb_l)
LDILDO(dtlb_l)
LDILDO(tlbd_l)

d854 2
a855 2
	depi    0,31,PGSHIFT,r9	/* align offset to page */
	/* CR28XXX according to a popular belief cr28 should be read here */
d869 1
a869 1
	STRAP(itlb,T_ITLBMISS,ITLBPRE)	/*  6. instruction TLB miss fault */
d882 3
a884 3
	STRAP(dtlb,T_DTLBMISS,DTLBPRE)	/* 15. data TLB miss fault */
	STRAP(itlb,T_ITLBMISSNA,ITLBPRE)/* 16. ITLB non-access miss fault */
	STRAP(dtlb,T_DTLBMISSNA,DTLBPRE)/* 17. DTLB non-access miss fault */
d888 1
a888 1
	STRAP(tlbd,T_TLB_DIRTY,DTLBPRE)	/* 20. TLB dirty bit trap */
d1165 2
a1166 1
	or	r24, r16, r16		/* r16 = HPT entry */
d1174 1
d1176 3
a1178 3
$tlbd_x
$tlbd_s
$tlbd_t
d1180 1
a1180 1
	mtctl	r16, cr28
d1186 2
a1187 2
	ldw	hpt_entry(r16), r24
$hash_loop_tlbd_t
d1191 1
a1191 1
	comb,<>,n r9, r25, $hash_loop_tlbd_t
d1193 1
a1193 1
	comb,<>,n r8, r17, $hash_loop_tlbd_t
d1196 1
d1198 1
d1201 1
a1201 1
	b	$tlb_inshpt_t
d1205 13
a1217 9
$itlb_x
$itlb_s
$itlb_t

$dtlb_x
$dtlb_s
$dtlb_t
	/*
	 * r1 is the trap type
d1223 1
a1224 1
	mtctl	r16, cr28
a1225 1
	ldw	hpt_tag(r16),r17
d1227 1
d1231 1
a1231 1
	comb,<>,n r16, r17, $tlb_gottalook_t
d1234 1
a1234 1
	b	$tlb_gothpt_t
d1237 2
a1238 1
$tlb_gottalook_t
d1244 1
a1244 1
$hash_loop_t
d1248 1
a1248 1
	comb,<>,n r9,r25,$hash_loop_t
d1250 1
a1250 1
	comb,<>,n r8,r17,$hash_loop_t
d1261 1
a1261 1
$tlb_inshpt_t
d1263 3
d1273 1
a1273 1
$tlb_gothpt_t
d1275 1
a1275 1
	bb,<	r1, TFF_ITLB_POS, $tlb_itlb_t
d1284 1
a1284 1
$tlb_itlb_t
a1289 95

	.align	32
$tlbd_l
	mfctl	cr28, r16

	/*
	 * Chase the list of entries for this hash bucket until we find
	 * the correct mapping or NULL.
	 */
	ldw	hpt_entry(r16), r24
$hash_loop_tlbd_l
	comb,=,n r0, r24, TLABEL(all)
	ldw	pv_va(r24), r25
	ldw	pv_space(r24), r17
	comb,<>,n r9, r25, $hash_loop_tlbd_l
	ldw	pv_hash(r24), r24
	comb,<>,n r8, r17, $hash_loop_tlbd_l
	ldw	pv_hash(r24), r24

	/* Set the dirty bit for this physical page. */
	ldw	pv_tlbpage(r24),r17
	ldw	pv_tlbprot(r24), r25
	b	$tlb_inshpt_l
	depi	1, TLB_DIRTY_POS, 1, r25
	
	.align	8
$itlb_l
	HPTENT	/* will update cr28 */
#ifdef DDB
	mtctl	r16, cr28
#endif
	b	$tlbmiss_l
	depi	1, TFF_ITLB_POS, 1, r1	/* mark for ITLB insert */

	.align	8
$dtlb_l
	/*mfctl	cr28, r16*/
	HPTENT	/* weird, but sometimes dtlbmissna does not set cr28 */
#ifdef DDB
	mtctl	r16, cr28
#endif
$tlbmiss_l
	/*
	 * r1 is the trap type
	 * r8 is the space of the address that had the TLB miss
	 * r9 is the offset of the address that had the TLB miss
	 * r16 is the correspondent HPT entry pointer
	 */

	/*
	 * Chase the list of entries for this hash bucket until we find
	 * the correct mapping or NULL.
	 */
	ldw	hpt_entry(r16),r24
$hash_loop_l
	comb,=,n r0, r24, TLABEL(all)
	ldw	pv_va(r24),r25
	ldw	pv_space(r24),r17
	comb,<>,n r9,r25,$hash_loop_l
	ldw	pv_hash(r24),r24
	comb,<>,n r8,r17,$hash_loop_l
	ldw	pv_hash(r24),r24

	/* Now set things up to enter the real mapping that we want */
	ldw	pv_tlbpage(r24),r17
	ldw	pv_tlbprot(r24),r25
	depi	1, TLB_REF_POS, 1, r25

	/*
	 * Load the HPT cache with the miss information for the next time.
	 * The HPT entry address was saved by the HPTENT
	 */
$tlb_inshpt_l
	stw	r25, pv_tlbprot(r24)
	copy	r16, r24
	VTAG	/* (r8,r9) -> r16 */

	stw	r16, hpt_tag(r24)
	stw	r25, hpt_tlbprot(r24)
	bb,<	r1, TFF_ITLB_POS, $tlb_itlb_l
	stw	r17, hpt_tlbpage(r24)

	.word	0x04111440	; idtlbaf	r17
	.word	0x04191400	; idtlbpf	r25
	nop ! nop
	rfir
	nop

$tlb_itlb_l
	.word	0x04110440	; iitlbaf	r17
	.word	0x04190400	; iitlbpf	r25
	nop ! nop
	rfir
	nop

a1528 9
#ifdef DDB
	stw	rp, HPPA_FRAME_CRP(sp)
	stw	r0, -HPPA_FRAME_SIZE(sp)
#endif
	stw	t3, -HPPA_FRAME_SIZE+4(sp)
	/*
	 * hmm, we don't need to save all the regs, only caller-save
	 * (except when DDB)
	 */
d1531 2
a1532 3
	stw	r1, TF_R1(t3)
	stw	r2, TF_R2(t3)
	stw	r3, TF_R3(t3)
d1534 2
a1535 15
	stw	r4, TF_R4(t3)
	stw	r5, TF_R5(t3)
	stw	r6, TF_R6(t3)
	stw	r7, TF_R7(t3)
	stw	r8, TF_R8(t3)
	stw	r9, TF_R9(t3)
	stw	r10, TF_R10(t3)
	stw	r11, TF_R11(t3)
	stw	r12, TF_R12(t3)
	stw	r13, TF_R13(t3)
	stw	r14, TF_R14(t3)
	stw	r15, TF_R15(t3)
	stw	r16, TF_R16(t3)
	stw	r17, TF_R17(t3)
	stw	r18, TF_R18(t3)
d1537 18
a1554 2
	stw	t4, TF_R19(t3)
	/*	r20 already saved (t3)
d1556 1
a1556 1
	 *	r22 already saved (t1) */
d1580 1
a1580 1
	 * Save the necessary control registers that have not already saved.
d1625 1
a1630 1
	ldw	-HPPA_FRAME_SIZE+4(sp), t3
d1632 1
a1632 1
	ldw	TF_FLAGS(t3), arg0
d1634 1
a1634 1
	nop
d1640 1
a1640 1
	ldw	-HPPA_FRAME_SIZE+4(sp), t3
d2155 1
a2155 1
	copy	r0, arg2	/* no old proc */
@


1.28.2.2
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.44 2001/03/29 02:18:44 mickey Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998-2001 Michael Shalayeff
d47 1
a47 1
 *	Utah $Hdr: locore.s 1.62 94/12/15$
a72 1
#include <machine/reg.h>
a77 9
/*
 * hv-specific instructions
 */
#define	DR_PAGE0	diag (0x70 << 5)
#define	DR_PAGE1	diag (0x72 << 5)
#define	MTCPU_T(x,t)	diag ((t) << 21) | ((x) << 16) | (0xc0 << 5)
#define	MTCPU_C(x,t)	diag ((t) << 21) | ((x) << 16) | (0x12 << 5)
#define	MFCPU_T(r,x)	diag ((r) << 21) | (0xa0 << 5) | (x)
#define	MFCPU_C(r,x)	diag ((r) << 21) | ((x) << 16) | (0x30 << 5)
d92 2
a93 1
	.section .bss
d96 1
a96 1
	.comm	4*NBPG
d98 1
a98 1
	.comm	4
d101 1
a101 1
	.comm	4
d104 1
a104 3
	.comm	4

	.text
d109 1
a109 1
ENTRY($start,0)
d148 1
a148 1
	ldi	-1, r1
d150 1
a150 1
	mtctl	r1, eirr
d162 2
a163 1
	stws,ma r0, 4(t2)
d165 1
a165 1
	stws,ma r0, 4(t2)	/* XXX could use ,bc here, but gas is broken */
d196 1
a196 1
	mtctl	t1, pcoq
d198 1
a198 1
	mtctl	t1, pcoq
d269 1
a269 1
	mtctl	t1, pcoq
d271 1
a271 1
	mtctl	t1, pcoq
d301 1
a301 1
	bv,n	(r1)
d314 1
a314 1
ENTRY(pdc_call,160)
a326 1
	ldo	R%pdc_stack(ret1), ret1
d347 1
a347 1
	stw	t1, HPPA_FRAME_ARG(4)(sp)	/* XXX can use ,bc */
d364 2
a365 2
	mfctl	cr27, t4
	stw	t1, HPPA_FRAME_ARG(12)(sp)	/* XXX can use ,bc */
d372 1
a372 1
	mfctl	cr31, t4
d391 1
a391 1
	bv,n	(r31)
d432 2
a433 2
 *	System Call Gate
 *	Signal Return Gate
d439 1
a439 1
	.align	NBPG
d493 2
a494 2
	ldil	L%$syscall,r1
	be,n	R%$syscall(sr7,r1)
a520 1
	 * XXXXXX this is very bad. everything must be saved
d524 1
a524 1
	ldw	p_addr(sr1, t3), t2	/* XXX can use ,sl */
d528 1
a528 1
	ldo	NBPG+TF_SIZE(t2), t3
d536 1
a536 1
	 * we believe that any callee-save registers
d540 1
a541 1
	stw	r3 , TF_R3 -TF_SIZE(sr1, t3)
d543 4
a546 16
	/* save callee-save registers */
	stw	r4 , TF_R4 -TF_SIZE(sr1, t3)
	stw	r5 , TF_R5 -TF_SIZE(sr1, t3)
	stw	r6 , TF_R6 -TF_SIZE(sr1, t3)
	stw	r7 , TF_R7 -TF_SIZE(sr1, t3)
	stw	r8 , TF_R8 -TF_SIZE(sr1, t3)
	stw	r9 , TF_R9 -TF_SIZE(sr1, t3)
	stw	r10, TF_R10-TF_SIZE(sr1, t3)
	stw	r11, TF_R11-TF_SIZE(sr1, t3)
	stw	r12, TF_R12-TF_SIZE(sr1, t3)
	stw	r13, TF_R13-TF_SIZE(sr1, t3)
	stw	r14, TF_R14-TF_SIZE(sr1, t3)
	stw	r15, TF_R15-TF_SIZE(sr1, t3)
	stw	r16, TF_R16-TF_SIZE(sr1, t3)
	stw	r17, TF_R17-TF_SIZE(sr1, t3)
	stw	r18, TF_R18-TF_SIZE(sr1, t3)
a547 4
	stw	r0, 0(sr1, t3)	/* terminate frame */
	copy	r0 , r3
	stw	r0, HPPA_FRAME_PSP(sr1, sp)
	stw	r0, HPPA_FRAME_CRP(sr1, sp)
d558 1
a558 1
	stw	arg0, 1*4(sr1, t3)	/* XXX can use ,bc */
d578 1
a578 1

d593 1
a593 1

d689 1
a689 1
	ldil	L%$trap_tmp_save, arg1
d772 2
a773 2

	ldil	L%$trap_tmp_save, t3
d845 1
a845 1
#define	LDILDO(name)			! \
a850 1
#ifdef HP7000_CPU
a852 1
LDILDO(dtlbna_x)
a853 1
#endif
a854 1
#ifdef HP7100_CPU
a856 1
LDILDO(dtlbna_s)
a857 1
#endif
a858 1
#ifdef HP7200_CPU
a860 1
LDILDO(dtlbna_t)
a861 1
#endif
a862 1
#ifdef HP7100LC_CPU
a864 1
LDILDO(dtlbna_l)
a865 1
#endif
d874 1
a874 1
	depi	0,31,PGSHIFT,r9	/* align offset to page */
d955 1
a955 1
ENTRY(TLABEL(hpmc),0)
a971 1
EXIT(TLABEL(hpmc))
d974 1
a974 1
LEAF_ENTRY(TLABEL(emu))
d998 1
a998 1

a1092 1
EXIT(TLABEL(emu))
d1101 1
a1101 1
ENTRY(TLABEL(excpt),0)
d1125 1
a1125 1
	stw	r1, TF_CR11(r31)
d1128 2
a1129 3
	extru,= arg0, 11, 1, r0
	or,tr	r0, r0, r0
	.call
d1169 1
a1169 2
EXIT(TLABEL(excpt))

d1171 1
a1171 1
ENTRY($sfu_emu,0)
a1173 1
EXIT($sfu_emu)
d1179 2
a1180 2
	extru	r9, 23, 24, r16		/* r16 = (offset >> 8) */	! \
	zdep	r8, 22, 16, r24		/* r24 = (space << 9) */	! \
d1185 1
a1185 1
	or	r16, r24, r24		/* r24 = HPT entry */
a1193 37
/*
 * void desidhash_s(void)
 */
#if defined(HP7000_CPU) || defined(HP7100_CPU)
LEAF_ENTRY(desidhash_s)
ALTENTRY(desidhash_x)
	MFCPU_T(DR_CPUCFG,22)	/* t1 */
	MFCPU_T(DR_CPUCFG,22)
	depi	0, DR0_PCXS_DHE, 3, t1	/* 3 4 DR0_PCXS_DOMAIN|DR0_PCXS_IHE */
	depi	1, DR0_PCXS_EQWSTO, 1, t1
	depi	0, DR0_PCXS_DHPMC, 1, t1
	depi	0, DR0_PCXS_ILPMC, 1, t1
	MTCPU_T(22,DR_CPUCFG)
	MTCPU_T(22,DR_CPUCFG)
	bv	0(rp)
	extru	t1, 4, 5, ret0	/* return chip revision */
EXIT(desidhash_s)
#endif /* HP7000_CPU || HP7100_CPU */

#ifdef HP7200_CPU
/*
 * void desidhash_t(void)
 */
LEAF_ENTRY(desidhash_t)
	MFCPU_T(DR_CPUCFG,22)	/* t1 */
	MFCPU_T(DR_CPUCFG,22)
	depi	0, DR0_PCXT_IHE, 1, t1
	depi	0, DR0_PCXT_DHE, 1, t1
	depi	0, DR0_PCXT_DHPMC, 1, t1
	depi	0, DR0_PCXT_ILPMC, 1, t1
	MTCPU_T(22,DR_CPUCFG)
	MTCPU_T(22,DR_CPUCFG)
	bv	0(rp)
	extru	t1, 4, 5, ret0	/* return chip revision */
EXIT(desidhash_t)
#endif

d1197 3
a1199 4
#if 1
	HPTENT
	mtctl	r24, cr28

d1204 1
a1204 1
	ldw	hpt_entry(r24), r24
a1218 9
#else

	mfsp	%sr1, %r25
	mtsp	%r8, %sr1
	lpa	%r0(%sr1, %r9), %r17
	mfctl	%cr29, %r16
	mtsp	%r25, %sr1
	extru	%r17, 20, 21, %r24
	sh3add	%r24, %r16, %r16
d1220 1
a1220 2
#endif

a1223 1
	depi	1, TFF_ITLB_POS, 1, r1	/* mark for ITLB insert */
a1225 1
$dtlbna_x
a1226 1
$dtlbna_s
a1227 1
$dtlbna_t
d1235 4
a1238 4
	HPTENT
	mtctl	r24, cr28

	ldw	hpt_tag(r24),r17
d1256 1
a1256 1
	comb,=,n r0, r24, $tlbiflpa
d1270 1
a1287 1
	nop ! nop
a1294 1
	nop ! nop
a1298 48
#ifdef HP7100LC_CPU
/*
 * int
 * ibtlb_l(int i, pa_space_t sp, vaddr_t va, paddr_t pa, vsize_t sz, u_int prot)
 */
LEAF_ENTRY(ibtlb_l)
	rsm	(PSW_R|PSW_I), t4

	bv	0(rp)
	mtsm	t4
EXIT(ibtlb_l)

/*
 * int
 * pbtlb_l(int i)
 */
LEAF_ENTRY(pbtlb_l)
	; DR_PAGE0
	rsm	(PSW_R|PSW_I), t4
	ldil	L%0xc041, t1
	dep	arg0, 30, 3, t1
	MTCPU_T(22,DR_DTLB)	/* t1 */
	mtsp	r0, sr1
	idtlba	r0,(sr1,r0)
	idtlbp	r0,(sr1,r0)
	zdepi	-1, 18, 1, t1
	MTCPU_T(22,DR_DTLB)
	bv	0(rp)
	mtsm	t4
EXIT(pbtlb_l)

/*
 * int desidhash_l(void)
 */
LEAF_ENTRY(desidhash_l)
	MFCPU_C(DR_CPUCFG,22)	/* t1 */
	depi	0, DR0_PCXL_L2IHASH_EN, 2, t1	/* + DR0_PCXL_L2DHASH_EN */
	depi	0, DR0_PCXL_L2IHPMC, 1, t1	/* don't reset */
	depi	0, DR0_PCXL_L2DHPMC, 1, t1	/* don't reset */
	depi	0, DR0_PCXL_L1IHPMC, 1, t1	/* don't reset */
	depi	0, DR0_PCXL_L2PARERR,1, t1	/* don't reset */
		/* set DR0_PCXL_L1ICACHE_EN ??? */
	MTCPU_C(22,DR_CPUCFG)
	bv	0(rp)
	extru	t1, 4, 5, ret0	/* return chip revision */
EXIT(desidhash_l)


d1301 1
a1301 1
	mfctl	cr28, r24
d1307 1
a1307 1
	ldw	hpt_entry(r24), r16
d1309 3
a1311 3
	comb,=,n r0, r16, TLABEL(all)
	ldw	pv_va(r16), r25
	ldw	pv_space(r16), r17
d1313 1
a1313 1
	ldw	pv_hash(r16), r16
d1315 1
a1315 1
	ldw	pv_hash(r16), r16
d1318 2
a1319 2
	ldw	pv_tlbpage(r16), r17
	ldw	pv_tlbprot(r16), r25
d1322 1
a1322 1

d1325 5
a1330 3
$dtlbna_l
	HPTENT
	mtctl	r24, cr28
d1332 1
d1334 6
a1339 1
	mfctl	cr28, r24
d1344 1
a1344 1
	 * r24 is the correspondent HPT entry pointer
d1351 1
a1351 1
	ldw	hpt_entry(r24), r16
d1353 7
a1359 7
	comb,=,n r0, r16, $tlbiflpa
	ldw	pv_va(r16), r25
	ldw	pv_space(r16), r17
	comb,<>,n r9, r25, $hash_loop_l
	ldw	pv_hash(r16), r16
	comb,<>,n r8, r17, $hash_loop_l
	ldw	pv_hash(r16), r16
d1362 2
a1363 2
	ldw	pv_tlbpage(r16), r17
	ldw	pv_tlbprot(r16), r25
d1371 2
a1372 1
	stw	r25, pv_tlbprot(r16)
a1391 54
#endif /* HP7100LC_CPU */

	.export $tlbiflpa, entry
$tlbiflpa
	ldi	T_DTLBMISSNA, r16
	mfctl	iir, r17
	comb,<>,n r1, r16, TLABEL(all)
	extru	r17, 5, 6, r16
	ldi	0x4d, r25
	comib,<>,n 1, r16, TLABEL(all)
	extru	r17, 25, 8, r16
	comb,<>,n r25, r16, TLABEL(all)

	/* ok, this is a miss in LPA */
	mfctl	ipsw, r16
	depi	1, PSW_N_POS, 1, r16
	depi	0, 26, 27, r17
	mtctl	r16, ipsw

	ldi	$tlbiflpa_zr, r25
	bv	r17(r25)
$tlbiflpa_zr
	copy	r0, r0	!	rfir
	copy	r0, r1	!	rfir
	copy	r0, r2	!	rfir
	copy	r0, r3	!	rfir
	copy	r0, r4	!	rfir
	copy	r0, r5	!	rfir
	copy	r0, r6	!	rfir
	copy	r0, r7	!	rfir
	copy	r0, r8	!	rfir
	copy	r0, r9	!	rfir
	copy	r0, r10	!	rfir
	copy	r0, r11	!	rfir
	copy	r0, r12	!	rfir
	copy	r0, r13	!	rfir
	copy	r0, r14	!	rfir
	copy	r0, r15	!	rfir
	copy	r0, r16	!	rfir
	copy	r0, r17	!	rfir
	copy	r0, r18	!	rfir
	copy	r0, r19	!	rfir
	copy	r0, r20	!	rfir
	copy	r0, r21	!	rfir
	copy	r0, r22	!	rfir
	copy	r0, r23	!	rfir
	copy	r0, r24	!	rfir
	copy	r0, r25	!	rfir
	copy	r0, r26	!	rfir
	copy	r0, r27	!	rfir
	copy	r0, r28	!	rfir
	copy	r0, r29	!	rfir
	copy	r0, r30	!	rfir
	copy	r0, r31	!	rfir
d1396 62
d1460 1
a1460 1
ENTRY(TLABEL(all),0)
d1473 20
a1492 1
	mtctl	t3, tr2
d1494 7
a1500 2
	ldil	L%$trap_tmp_save, t3
	stw	t1, TF_R22(t3)		/* use ,bc */
d1503 1
a1503 1
	mfctl	tr2, t1
d1513 13
d1528 1
a1528 1
	stw	t1, TF_CR15(t3)		/* use ,bc */
d1536 10
d1554 4
d1564 3
a1566 6
	mfctl	pcsq, t1
	mtctl	r0, pcsq
	mfctl	pcsq, t2
	stw	t1, TF_IISQH(t3)	/* use ,bc */
	stw	t2, TF_IISQT(t3)
	mtctl	r0, pcsq
d1568 7
a1574 4
	mfctl	pcoq, t1
	ldo	TF_PHYS-1(sp), sp
	bb,>=	t1, 31, $trap_from_kernel
	dep	r0, 31, 6, sp
d1576 8
a1583 28
	mfctl	cr30, t2
	depi	1, T_USER_POS, 1, r1
	depi	1, TFF_LAST_POS, 1, r1
	ldw	u_pcb+pcb_uva(t2), sp
	ldo	NBPG(sp), sp

$trap_from_kernel
	ldil	L%$trapnowvirt, t2
	ldo	R%$trapnowvirt(t2), t2
	mtctl	t2, pcoq
	stw	t1, TF_IIOQH(t3)
	ldo	4(t2), t2
	mfctl	pcoq, t1
	stw	t1, TF_IIOQT(t3)
	mtctl	t2, pcoq

	mfctl	isr, t1
	mfctl	ior, t2
	stw	t1, TF_CR20(t3)		/* use ,bc */
	stw	t2, TF_CR21(t3)

	mfctl	iir, t2
	stw	t2, TF_CR19(t3)
	stw	r1, TF_FLAGS(t3)
	mfctl	tr7, r1

	copy	sp, t3
	ldo	HPPA_FRAME_SIZE+TF_SIZE(sp), sp
d1586 1
d1589 1
a1589 1
	 * t3 contains the virtual address of the trapframe
d1637 5
a1641 2

	mfctl	sar, t1			/* use ,bc each cache line */
a1645 19

	/*
	 * Copy partially saved state from the store into the frame
	 */
	ldil	L%$trap_tmp_save, t2
	/* use ,bc each line */
	ldw  0(t2), r1 ! ldw  4(t2), t1 ! stw r1,  0(t3) ! stw t1,  4(t3)
	ldw  8(t2), r1 ! ldw 12(t2), t1 ! stw r1,  8(t3) ! stw t1, 12(t3)
	ldw 16(t2), r1 ! ldw 20(t2), t1 ! stw r1, 16(t3) ! stw t1, 20(t3)
	ldw 24(t2), r1 ! ldw 28(t2), t1 ! stw r1, 24(t3) ! stw t1, 28(t3)
	ldw 32(t2), r1 ! ldw 36(t2), t1 ! stw r1, 32(t3) ! stw t1, 36(t3)
	ldw 40(t2), r1 ! ldw 44(t2), t1 ! stw r1, 40(t3) ! stw t1, 44(t3)
	ldw 48(t2), r1 ! ldw 52(t2), t1 ! stw r1, 48(t3) ! stw t1, 52(t3)
	ldw 56(t2), r1 ! ldw 60(t2), t1 ! stw r1, 56(t3) ! stw t1, 60(t3)

	/*
	 * hmm, we don't need to save all the regs, only caller-save
	 * (except when DDB)
	 */
d1664 3
d1674 1
d1678 12
d1696 1
a1696 1

a1757 1
EXIT(TLABEL(all))
d1759 1
a1759 42
	.align	32
	.export	TLABEL(ibrk), entry
ENTRY(TLABEL(ibrk),0)
	mtctl	t1, tr2
	mtctl	t2, tr3

	/* If called by a user process then always pass it to trap() */
	mfctl	pcoq, t1
	extru,=	t1, 31, 2, r0
	b,n	$ibrk_bad

	/* don't accept breaks from data segments */
	.import etext
	ldil	L%etext, t2
	ldo	R%etext(t2), t2
	comb,>>=,n t1, t2, $ibrk_bad

	mfctl	iir, t1
	extru	t1, 31, 5, t2
	comib,<>,n HPPA_BREAK_KERNEL, t2, $ibrk_bad

	/* now process all those `break' calls we make */
	extru	t1, 18, 13, t2
	comib,=,n HPPA_BREAK_GET_PSW, t2, $ibrk_getpsw
	comib,=,n HPPA_BREAK_SET_PSW, t2, $ibrk_setpsw

$ibrk_bad
	/* illegal (unimplemented) break entry point */
	mfctl	tr3, t2
	b	TLABEL(all)
	mfctl	tr2, t1

$ibrk_getpsw
	b	$ibrk_exit
	mfctl	ipsw, ret0

$ibrk_setpsw
	mfctl	ipsw, ret0
	b	$ibrk_exit
	mtctl	arg0, ipsw

$ibrk_setpsw_tovirt
d1761 1
a1761 163
	b	$ibrk_exit
	ldw	HPPA_FRAME_PSP(sp), sp

	/* insert other fast breaks here */
	nop ! nop

$ibrk_exit
	/* skip the break */
	mtctl	r0, pcoq
	mfctl	pcoq, t1
	mtctl	t1, pcoq
	ldo	4(t1), t1
	mtctl	t1, pcoq
	mfctl	tr3, t2
	mfctl	tr2, t1
	mfctl	tr7, r1
	rfi
	nop
EXIT(TLABEL(ibrk))

	.import	dcache_stride, data
LEAF_ENTRY(fdcache)
	ldil	L%dcache_stride,t1
	ldw	R%dcache_stride(t1), arg3

	mtsp	arg0, sr1		/* move the space register to sr1 */
	add	arg1, arg2, arg0	/* get the last byte to flush in arg0 */

	zdep	arg3, 27, 28, t1	/* get size of a 16X loop in t1 */
	comb,<	arg2, t1, fdc_short	/* check for count < 16 * stride */
	addi	-1, t1, t1		/* compute size of large loop - 1 */

	andcm	arg2, t1, t1		/* L = count - (count mod lenbigloop) */
	add	arg1, t1, t1		/* ub for big loop is lb + L */

	fdc,m	arg3(sr1, arg1)		/* Start flushing first cache line. */
fdc_long
	fdc,m	arg3(sr1, arg1)
	fdc,m	arg3(sr1, arg1)
	fdc,m	arg3(sr1, arg1)
	fdc,m	arg3(sr1, arg1)
	fdc,m	arg3(sr1, arg1)
	fdc,m	arg3(sr1, arg1)
	fdc,m	arg3(sr1, arg1)
	fdc,m	arg3(sr1, arg1)
	fdc,m	arg3(sr1, arg1)
	fdc,m	arg3(sr1, arg1)
	fdc,m	arg3(sr1, arg1)
	fdc,m	arg3(sr1, arg1)
	fdc,m	arg3(sr1, arg1)
	fdc,m	arg3(sr1, arg1)
	fdc,m	arg3(sr1, arg1)
	comb,<<,n arg1, t1, fdc_long
	fdc,m	arg3(sr1, arg1)
fdc_short				/* flush one line at a time */
	comb,<<,n arg1, arg0, fdc_short
	fdc,m	arg3(sr1, arg1)

	/*addi	-1, arg0, arg1
	fdc	(sr1, arg1)*/

	sync
	syncdma
	bv	r0(r2)
	sync
EXIT(fdcache)

	.import	dcache_stride, data
LEAF_ENTRY(pdcache)
	ldil	L%dcache_stride,t1
	ldw	R%dcache_stride(t1), arg3

	mtsp	arg0, sr1		/* move the space register to sr1 */
	add	arg1, arg2, arg0	/* get the last byte to flush in arg0 */

	zdep	arg3, 27, 28, t1	/* get size of a 16X loop in t1 */
	comb,<	arg2, t1, pdc_short	/* check for count < 16 * stride */
	addi	-1, t1, t1		/* compute size of large loop - 1 */

	andcm	arg2, t1, t1		/* L = count - (count mod lenbigloop) */
	add	arg1, t1, t1		/* ub for big loop is lb + L */

	pdc,m	arg3(sr1, arg1)		/* Start flushing first cache line. */
pdc_long
	pdc,m	arg3(sr1, arg1)
	pdc,m	arg3(sr1, arg1)
	pdc,m	arg3(sr1, arg1)
	pdc,m	arg3(sr1, arg1)
	pdc,m	arg3(sr1, arg1)
	pdc,m	arg3(sr1, arg1)
	pdc,m	arg3(sr1, arg1)
	pdc,m	arg3(sr1, arg1)
	pdc,m	arg3(sr1, arg1)
	pdc,m	arg3(sr1, arg1)
	pdc,m	arg3(sr1, arg1)
	pdc,m	arg3(sr1, arg1)
	pdc,m	arg3(sr1, arg1)
	pdc,m	arg3(sr1, arg1)
	pdc,m	arg3(sr1, arg1)
	comb,<<,n arg1, t1, pdc_long
	pdc,m	arg3(sr1, arg1)
pdc_short				/* flush one line at a time */
	comb,<<,n arg1, arg0, pdc_short
	pdc,m	arg3(sr1, arg1)

	/*addi	-1, arg0, arg1
	pdc	(sr1, arg1)*/

	sync
	syncdma
	bv	r0(r2)
	sync
EXIT(pdcache)

	.import	icache_stride, data
LEAF_ENTRY(ficache)
	ldil	L%icache_stride,t1
	ldw	R%icache_stride(t1), arg3

	mtsp	arg0, sr1		/* move the space register to sr1 */
	add	arg1, arg2, arg0	/* get the last byte to flush in arg0 */

	zdep	arg3, 27, 28, t1	/* get size of a 16X loop in t1 */
	comb,<	arg2, t1, fic_short	/* check for count < 16 * stride */
	addi	-1, t1, t1		/* compute size of large loop - 1 */

	andcm	arg2, t1, t1		/* L = count - (count mod lenbigloop) */
	add	arg1, t1, t1		/* ub for big loop is lb + L */

	fic,m	arg3(sr1, arg1)		/* Start flushing first cache line. */
fic_long
	fic,m	arg3(sr1, arg1)
	fic,m	arg3(sr1, arg1)
	fic,m	arg3(sr1, arg1)
	fic,m	arg3(sr1, arg1)
	fic,m	arg3(sr1, arg1)
	fic,m	arg3(sr1, arg1)
	fic,m	arg3(sr1, arg1)
	fic,m	arg3(sr1, arg1)
	fic,m	arg3(sr1, arg1)
	fic,m	arg3(sr1, arg1)
	fic,m	arg3(sr1, arg1)
	fic,m	arg3(sr1, arg1)
	fic,m	arg3(sr1, arg1)
	fic,m	arg3(sr1, arg1)
	fic,m	arg3(sr1, arg1)
	comb,<<,n arg1, t1, fic_long
	fic,m	arg3(sr1, arg1)
fic_short				/* flush one line at a time */
	comb,<<,n arg1, arg0, fic_short
	fic,m	arg3(sr1, arg1)

	/*addi	-1, arg0, arg1
	fic	(sr1, arg1)*/

	sync
	syncdma
	bv	r0(r2)
	sync
EXIT(ficache)


LEAF_ENTRY(setjmp)
d1792 1
a1792 1
LEAF_ENTRY(longjmp)
d1824 1
a1824 1
LEAF_ENTRY(name)				! \
d1851 1
a1851 1
LEAF_ENTRY(fusufault)
d1869 1
a1869 1
LEAF_ENTRY(copy_on_fault)
d1879 1
a1879 1
LEAF_ENTRY(spstrcpy)
d1917 1
a1917 1
LEAF_ENTRY(microtime)
d1944 1
a1944 1

d1954 1
a1954 1
ENTRY(setrunqueue,0)
d2018 1
a2018 1
ENTRY(remrunqueue,0)
d2031 1
a2031 1
	ldil	L%panic, r1
d2037 1
a2037 1
	bv,n	%r0(r1)
d2064 1
a2064 1
ENTRY(cpu_switch,128)
d2072 1
a2072 1
	/* remain on the old (curproc)'s stack until we have a better choice */
d2119 1
a2119 1
	ldil	L%panic, r1
d2125 1
a2125 1
	bv,n	%r0(r1)
a2214 2
	ldw	HPPA_FRAME_ARG(1)(sp), t3 /* in case we're in trampoline */
	ldw	HPPA_FRAME_ARG(2)(sp), arg0
d2247 1
a2247 1
ENTRY(switch_exit,0)
a2262 8
	/* arg0 -- oldproc */
	.import exit2, code
	ldil	L%exit2, t2
	ldo	R%exit2(t2), t2
	.call
	blr	%r0, rp
	bv,n	%r0(t2)
	nop
a2263 1
	.call
d2268 3
a2270 1
ENTRY(switch_trampoline,0)
d2272 2
a2273 2
	blr	r0, rp
	bv,n	r0(t3)
a2276 1
	.call
d2284 4
a2287 13
ENTRY(sigcode,0)
	/* TODO call signal handler */

	/*ldo	SIGF_SC(sp), arg0*/
	ldil	L%SYSCALLGATE, r1
	.call
	ble	4(sr7, r1)
	ldi	SYS_sigreturn, t1
	copy	ret0, arg0
	ldil	L%SYSCALLGATE, r1
	.call
	ble	4(sr7, r1)
	ldi	SYS_exit, t1
d2292 1
a2292 1
ENTRY(linux_sigcode,0)
@


1.28.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.28.2.2 2001/04/18 16:06:12 niklas Exp $	*/
d171 1
a171 1
	ldi	NBPG+TRAPFRAME_SIZEOF, t1
d182 1
a182 1
	ldo	NBPG+TRAPFRAME_SIZEOF(arg3), sp
d184 3
a186 3
	stw	r0, U_PCB+PCB_ONFAULT(arg3)
	stw	r0, U_PCB+PCB_SPACE(arg3)	/* XXX HPPA_SID_KERNEL == 0 */
	stw	arg3, U_PCB+PCB_UVA(arg3)
d192 1
a192 1
	stw	arg3, R%proc0+P_ADDR(t2)
d195 2
a196 2
	stw	t1, TF_FLAGS-TRAPFRAME_SIZEOF(sp)
	stw	arg3, TF_CR30-TRAPFRAME_SIZEOF(sp)
d536 1
a536 1
	ldw	P_ADDR(sr1, t3), t2	/* XXX can use ,sl */
d540 1
a540 1
	ldo	NBPG+TRAPFRAME_SIZEOF(t2), t3
d542 3
a544 3
	stw	t1, TF_R22 -TRAPFRAME_SIZEOF(sr1, t3)	/* syscall # */
	stw	t4, TF_R30 -TRAPFRAME_SIZEOF(sr1, t3)	/* user stack */
	stw	r1, TF_CR15-TRAPFRAME_SIZEOF(sr1, t3)	/* eiem */
d552 2
a553 2
	stw	r27, TF_R27-TRAPFRAME_SIZEOF(sr1, t3)	/* dp */
	stw	r3 , TF_R3 -TRAPFRAME_SIZEOF(sr1, t3)
d556 15
a570 15
	stw	r4 , TF_R4 -TRAPFRAME_SIZEOF(sr1, t3)
	stw	r5 , TF_R5 -TRAPFRAME_SIZEOF(sr1, t3)
	stw	r6 , TF_R6 -TRAPFRAME_SIZEOF(sr1, t3)
	stw	r7 , TF_R7 -TRAPFRAME_SIZEOF(sr1, t3)
	stw	r8 , TF_R8 -TRAPFRAME_SIZEOF(sr1, t3)
	stw	r9 , TF_R9 -TRAPFRAME_SIZEOF(sr1, t3)
	stw	r10, TF_R10-TRAPFRAME_SIZEOF(sr1, t3)
	stw	r11, TF_R11-TRAPFRAME_SIZEOF(sr1, t3)
	stw	r12, TF_R12-TRAPFRAME_SIZEOF(sr1, t3)
	stw	r13, TF_R13-TRAPFRAME_SIZEOF(sr1, t3)
	stw	r14, TF_R14-TRAPFRAME_SIZEOF(sr1, t3)
	stw	r15, TF_R15-TRAPFRAME_SIZEOF(sr1, t3)
	stw	r16, TF_R16-TRAPFRAME_SIZEOF(sr1, t3)
	stw	r17, TF_R17-TRAPFRAME_SIZEOF(sr1, t3)
	stw	r18, TF_R18-TRAPFRAME_SIZEOF(sr1, t3)
d608 2
a609 2
	stw	r31, TF_IIOQH-TRAPFRAME_SIZEOF(sr1, t3)
	stw	arg1, TF_IIOQT-TRAPFRAME_SIZEOF(sr1, t3)
d612 2
a613 2
	stw	arg0, TF_IISQH-TRAPFRAME_SIZEOF(sr1, t3)
	stw	arg0, TF_IISQT-TRAPFRAME_SIZEOF(sr1, t3)
d615 2
a616 2
	stw	arg0, TF_CR20-TRAPFRAME_SIZEOF(sr1, t3)
	stw	r31, TF_CR21-TRAPFRAME_SIZEOF(sr1, t3)
d619 2
a620 2
	stw	arg0, TF_SR3-TRAPFRAME_SIZEOF(sr1, t3)
	stw	r28, TF_CR8-TRAPFRAME_SIZEOF(sr1, t3)	/* pidr1 */
d624 2
a625 2
	stw	arg0, TF_CR19-TRAPFRAME_SIZEOF(sr1, t3)
	stw	arg1, TF_FLAGS-TRAPFRAME_SIZEOF(sr1, t3)
d631 4
a634 4
	stw	arg0, TF_SR0-TRAPFRAME_SIZEOF(sr1, t3)
	stw	arg1, TF_SR1-TRAPFRAME_SIZEOF(sr1, t3)
	stw	arg2, TF_SR2-TRAPFRAME_SIZEOF(sr1, t3)
	stw	arg3, TF_SR4-TRAPFRAME_SIZEOF(sr1, t3)
d640 4
a643 4
	stw	arg0, TF_SR5-TRAPFRAME_SIZEOF(sr1, t3)
	stw	arg1, TF_SR6-TRAPFRAME_SIZEOF(sr1, t3)
	stw	arg2, TF_SR7-TRAPFRAME_SIZEOF(sr1, t3)
	stw	arg3, TF_CR9-TRAPFRAME_SIZEOF(sr1, t3)
d648 2
a649 2
	stw	arg2, TF_CR12-TRAPFRAME_SIZEOF(sr1, t3)
	stw	arg3, TF_CR13-TRAPFRAME_SIZEOF(sr1, t3)
d658 2
a659 2
	stw	arg0, TF_CR23-TRAPFRAME_SIZEOF(sr1, t3)
	stw	arg1, TF_CR24-TRAPFRAME_SIZEOF(sr1, t3)
d663 2
a664 2
	stw	arg0, TF_CR25-TRAPFRAME_SIZEOF(sr1, t3)
	stw	arg1, TF_CR28-TRAPFRAME_SIZEOF(sr1, t3)
d677 1
a677 1
	ldo	-TRAPFRAME_SIZEOF(t3), arg0
d693 1
a693 1
	ldw	P_MD(r1), t3
d1047 1
a1047 1
	/* ldo	PCB_FPREGS+U_PCB(t1), t1 */
d1090 1
a1090 1
	ldo	31*8+PCB_FPREGS+U_PCB(t2), t3
d1150 1
a1150 1
	ldo	R%TRAPFRAME_SIZEOF+HPPA_FRAME_SIZE(r31), sp
d1287 1
a1287 1
	ldw	HPT_ENTRY(r24), r24
d1290 2
a1291 2
	ldw	PV_VA(r24), r25
	ldw	PV_SPACE(r24), r17
d1293 1
a1293 1
	ldw	PV_HASH(r24), r24
d1295 1
a1295 1
	ldw	PV_HASH(r24), r24
d1299 1
a1299 1
	ldw	PV_TLBPROT(r24), r25
d1335 1
a1335 1
	ldw	HPT_TAG(r24),r17
d1342 1
a1342 1
	ldw	HPT_TLBPAGE(r24), r17
d1344 1
a1344 1
	ldw	HPT_TLBPROT(r24), r25
d1351 1
a1351 1
	ldw	HPT_ENTRY(r24),r24
d1354 2
a1355 2
	ldw	PV_VA(r24),r25
	ldw	PV_SPACE(r24),r17
d1357 1
a1357 1
	ldw	PV_HASH(r24),r24
d1359 1
a1359 1
	ldw	PV_HASH(r24),r24
d1362 1
a1362 1
	ldw	PV_TLBPROT(r24),r25
d1369 2
a1370 2
	stw	r25, PV_TLBPROT(r24)
	ldw	PV_TLBPAGE(r24),r17
d1373 3
a1375 3
	stw	r16, HPT_TAG(r24)
	stw	r25, HPT_TLBPROT(r24)
	stw	r17, HPT_TLBPAGE(r24)
d1453 1
a1453 1
	ldw	HPT_ENTRY(r24), r16
d1456 2
a1457 2
	ldw	PV_VA(r16), r25
	ldw	PV_SPACE(r16), r17
d1459 1
a1459 1
	ldw	PV_HASH(r16), r16
d1461 1
a1461 1
	ldw	PV_HASH(r16), r16
d1464 2
a1465 2
	ldw	PV_TLBPAGE(r16), r17
	ldw	PV_TLBPROT(r16), r25
d1489 1
a1489 1
	ldw	HPT_ENTRY(r24), r16
d1492 2
a1493 2
	ldw	PV_VA(r16), r25
	ldw	PV_SPACE(r16), r17
d1495 1
a1495 1
	ldw	PV_HASH(r16), r16
d1497 1
a1497 1
	ldw	PV_HASH(r16), r16
d1500 2
a1501 2
	ldw	PV_TLBPAGE(r16), r17
	ldw	PV_TLBPROT(r16), r25
d1509 1
a1509 1
	stw	r25, PV_TLBPROT(r16)
d1512 2
a1513 2
	stw	r16, HPT_TAG(r24)
	stw	r25, HPT_TLBPROT(r24)
d1515 1
a1515 1
	stw	r17, HPT_TLBPAGE(r24)
d1657 1
a1657 1
	ldw	U_PCB+PCB_UVA(t2), sp
d1681 1
a1681 1
	ldo	HPPA_FRAME_SIZE+TRAPFRAME_SIZEOF(sp), sp
d1851 1
a1851 1
	ldw	P_MD(t2), t3
d2130 1
a2130 1
	ldw	P_ADDR(t1), t1			! \
d2133 3
a2135 3
	ldw	U_PCB+PCB_ONFAULT(t1), t3	! \
	stw	t2, U_PCB+PCB_ONFAULT(t1)	! \
	ldw	U_PCB+PCB_SPACE(t1), t2		! \
d2142 1
a2142 1
	stw	r0, U_PCB+PCB_ONFAULT(t1)	! \
d2149 1
a2149 1
	stw	r0, U_PCB+PCB_ONFAULT(t1)	! \
d2153 1
a2153 1
	stw	r0, U_PCB+PCB_ONFAULT(t1)
d2184 1
a2184 1
	ldw	P_ADDR(r31), r31
d2187 1
a2187 1
	stw	t2, PCB_ONFAULT+U_PCB(r31)
d2204 1
a2204 1
	stw	r0, PCB_ONFAULT+U_PCB(r31)
d2257 1
a2257 1
	ldw	P_BACK(arg0), t1
d2259 1
a2259 1
	ldw	P_WCHAN(arg0), t1
d2261 1
a2261 1
	ldb	P_STAT(arg0), t1
d2279 1
a2279 1
	ldb	P_PRIORITY(arg0), t2
d2303 4
a2306 4
	ldw	P_BACK(t4), t2
	stw	t4, P_FORW(arg0)
	stw	arg0, P_BACK(t4)
	stw	arg0, P_FORW(t2)
d2308 1
a2308 1
	stw	t2, P_BACK(arg0)
d2320 1
a2320 1
	ldb	P_PRIORITY(arg0), t2
d2345 5
a2349 5
	ldw	P_BACK(arg0), t4
	stw	r0, P_BACK(arg0)
	ldw	P_FORW(arg0), arg0
	stw	arg0, P_FORW(t4)
	stw	t4, P_BACK(arg0)
d2413 1
a2413 1
	ldw	P_FORW(t2), arg1
d2433 4
a2436 4
	ldw	P_FORW(arg1), arg0
	stw	arg0, P_FORW(t2)
	stw	t2, P_BACK(arg0)
	stw	r0, P_BACK(arg1)
d2450 1
a2450 1
	ldw	P_WCHAN(arg1), t1
d2453 1
a2453 1
	ldb	P_STAT(arg1), t1
d2471 1
a2471 1
	ldw	P_MD(arg2), t1
d2505 1
a2505 1
	ldw	P_MD(arg1), t1
d2589 1
a2589 1
	ldw	P_MD(t2), t3
d2596 3
a2598 5
	.call
	blr	r0, rp
	bv,n	r0(arg3)
	nop
	copy	r3, arg0
@


1.28.2.4
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d4 1
a4 1
 * Copyright (c) 1998-2002 Michael Shalayeff
a64 1
#include <sys/reboot.h>
d104 1
a104 1
pdc_stack			/* temp stack for PDC call, must be > 9k */
a105 3
	.export	exit_stack, data
exit_stack			/* temp stack used during exit2() */
	.comm   2*NBPG
d114 1
a114 2
fpu_enable
	.comm	4
d504 2
a505 2
	ldil	L%$syscall, t2
	be,n	R%$syscall(sr1, t2)
d523 1
a523 1
	 * t1:	syscall number
d528 5
a535 1
	copy	sp, t4
d539 1
d544 1
a544 8
	ldil	L%kpsw, t1
	ldw	R%kpsw(sr1, t1), t1
	stw	r1, TF_CR15-TRAPFRAME_SIZEOF(sr1, t3)	/* eiem ,bc */
	stw	t1, TF_CR22-TRAPFRAME_SIZEOF(sr1, t3)	/* ipsw */
	mfsp	sr3, t1
	stw	t1, TF_SR3-TRAPFRAME_SIZEOF(sr1, t3)
	stw	r28, TF_CR8-TRAPFRAME_SIZEOF(sr1, t3)	/* pidr1 */
	/* now we can allow interrupts to happen */
d550 1
a550 2
	 * or deeper called functions and caller-save
	 * are saved in userland.
d552 1
a571 1
	stw	r27, TF_R27-TRAPFRAME_SIZEOF(sr1, t3)	/* dp */
a584 2
	 *
	 * TODO: setup the onfault handler
a605 3
	mfsp	sr0, arg0				/* use ,bc */
	stw	arg0, TF_IISQH-TRAPFRAME_SIZEOF(sr1, t3)
	stw	arg0, TF_IISQT-TRAPFRAME_SIZEOF(sr1, t3)
d611 5
a615 1
	stw	arg0, TF_CR20-TRAPFRAME_SIZEOF(sr1, t3)	/* use ,bc */
d618 5
d624 1
a624 1
	stw	r0, TF_CR19-TRAPFRAME_SIZEOF(sr1, t3)	/* iir */
a665 2
	mfctl	cr30, arg0
	stw	arg0, TF_CR30(sr1, t3)
a689 1
	nop
d718 1
a718 1
	ldi	TF_PHYS-4, arg2		/* not all of it is needed, unroll */
d721 1
a721 1
	addib,>,n -4, arg2, $syscall_return_copy_loop
a723 10
#if 0
	ldw	TF_IIOQH(t3), t1
	dep	r0, 31, 2, t1
	comb,<>,n r0, t1, $syscall_return_ok
	nop
	break	0, 8

$syscall_return_ok
#endif

d845 1
a845 1
	be	R%TLABEL(name)(sr7, r1)	! \
d1047 1
a1047 3
#if PCB_FPREGS != 0 || U_PCB != 0
	ldo	PCB_FPREGS+U_PCB(t1), t1
#endif
a1246 2
	nop
	nop
a1252 2
	nop
	nop
a1264 2
	nop
	nop
a1270 2
	nop
	nop
d1353 1
a1353 1
	comb,=,n r0, r24, TLABEL(all)
a1418 2
	nop
	nop
a1423 2
	nop
	nop
a1432 2
	nop
	nop
a1439 2
	nop
	nop
d1466 1
a1467 13
	depi	1, TLB_REF_POS, 1, r25
	stw	r25, PV_TLBPROT(r16)
	VTAG	/* (r8,r9) -> r16 */

	stw	r16, HPT_TAG(r24)
	stw	r25, HPT_TLBPROT(r24)
	stw	r17, HPT_TLBPAGE(r24)

	.word	0x04111440	; idtlbaf	r17
	.word	0x04191400	; idtlbpf	r25
	nop ! nop
	rfir
	nop
d1491 1
a1491 1
	comb,=,n r0, r16, TLABEL(all)
d1502 1
d1508 1
a1508 1
	depi	1, TLB_REF_POS, 1, r25
d1531 53
d1745 1
a1745 1
	/* use ,bc each cache line */
d1776 9
a1784 9
	stw	r19, TF_R19(t3)	/* t4 */
	stw	r23, TF_R23(t3)
	stw	r24, TF_R24(t3)
	stw	r25, TF_R25(t3)
	stw	r26, TF_R26(t3)
	stw	r27, TF_R27(t3)
	stw	r28, TF_R28(t3)
	stw	r29, TF_R29(t3)
	stw	r31, TF_R31(t3)
d1823 1
a1823 1
	dep	r0, 24, 25, arg0
a1856 36
/*
 * transfer of control handler
 */
ENTRY(hppa_toc,0)

	.import	boot, code
	ldil	L%boot, t1
	ldo	R%boot(t1), t1
	ldi	0, arg0
	.call
	blr	r0, rp
	bv,n	0(t1)
	nop

ALTENTRY(hppa_toc_end)
	.word	0
EXIT(hppa_toc)

/*
 * power fail recovery handler
 */
ENTRY(hppa_pfr,0)

	.import	boot, code
	ldil	L%boot, t1
	ldo	R%boot(t1), t1
	ldi	RB_HALT|RB_POWERDOWN, arg0
	.call
	blr	r0, rp
	bv,n	0(t1)
	nop

ALTENTRY(hppa_pfr_end)
	.word	0
EXIT(hppa_pfr)

d1958 2
a1959 2
	addi	-1, arg0, arg1
	fdc	(sr1, arg1)
d2005 2
a2006 2
	addi	-1, arg0, arg1
	pdc	(sr1, arg1)
d2052 2
a2053 2
	addi	-1, arg0, arg1
	fic	(sr1, arg1)
d2235 1
a2235 1
	addi	1, t2, t2
d2237 1
a2237 1
	addi	1, t1, t1
d2353 1
a2353 1
	vdepi	0, 1, t3
a2504 1
	mtctl	r0, ccr			/* disable FPU */
d2516 1
a2516 1
	ldw	HPPA_FRAME_ARG(1)(sp), t3 /* in case we're on trampoline */
d2565 1
a2565 11
	/* switch onto the temporary stack */
	ldil	L%exit_stack, t4
	ldo	HPPA_FRAME_SIZE(t4), sp
	stw	r0, HPPA_FRAME_PSP(sp)
	stw	r0, HPPA_FRAME_CRP(sp)

	/* start the stack frame for our callee */
	copy	sp, r3
	ldo	HPPA_FRAME_SIZE(sp), sp
	stw	r3, HPPA_FRAME_PSP(sp)

@


1.28.2.5
log
@Merge in -current from about a week ago
@
text
@a119 5
$trap_tmp_save			/* XXX assumed to be aligned on 2048 */
	.align	2048
	.block	TF_PHYS		/* XXX must be aligned to 64 */
	.align	64

a197 2
	ldo	-TRAPFRAME_SIZEOF(sp), t3
	stw	t3, R%proc0+P_MD(t2)
a293 1
	addi	1, r0, t2
d295 1
a295 1
	stw	t2, R%kernelmapped(t1)
d517 4
a897 1
LDILDO(itlbna_x)
a904 1
LDILDO(itlbna_s)
a911 1
LDILDO(itlbna_t)
a918 1
LDILDO(itlbna_l)
d960 2
a961 2
	STRAP(itlbna,T_ITLBMISSNA,ITLBPRE)/* 16. ITLB non-access miss fault */
	STRAP(dtlbna,T_DTLBMISSNA,DTLBPRE)/* 17. DTLB non-access miss fault */
a1263 1
	sync
a1271 1
	sync
a1285 1
	sync
a1293 1
	sync
a1302 22
#if defined(HP7000_CPU) || defined(HP7100_CPU) || defined(HP7200_CPU)
#define	TLB_PULL(bits)							! \
	/* space:pgaddr -- r8:r9 */					! \
	mfctl	vtop, r16						! \
	ldwax,s	r8(r16), r17		/* space -> page directory */	! \
	extru	r9, 9, 10, r25						! \
	combt,=,n r0, r17, TLABEL(all)					! \
	ldwax,s	r25(r17), r24		/* page -> page table */	! \
	extru	r9, 19, 10, r16						! \
	combt,=,n r0, r24, TLABEL(all)					! \
	ldwax,s	r16(r24), r17		/* va -> pa:prot */		! \
	sh2addl	r16, r24, r25						! \
	combt,=,n r0, r17, TLABEL(all)					! \
	depi	(bits), 21+bits, 1+bits, r17				! \
	mfctl	tr7, r1							! \
	stwas	r17, 0(r25)		/* store back w/ the bits */	! \
	shd	r17, r0, 13, r25					! \
	dep	r8, 30, 15, r25		/* mix0r the pid from the sid */! \
	dep	r0, 31, 12, r17		/* needed ? */			! \
	addi	2, r25, r25						! \
	extru	r17, 24, 25, r17

d1306 34
a1339 8
	TLB_PULL(1)
	mfsp	sr1, r16
	mtsp	r8, sr1
	idtlba	r17,(sr1, r9)
	idtlbp	r25,(sr1, r9)
	mtsp	r16, sr1
	rfir
	nop
a1341 1
$itlbna_x
a1342 1
$itlbna_s
d1344 1
a1344 9
$itlbna_t
	TLB_PULL(0)
	mfsp	sr1, r16
	mtsp	r8, sr1
	iitlba	r17,(sr1, r9)
	iitlbp	r25,(sr1, r9)
	mtsp	r16, sr1
	rfir
	nop
d1352 53
a1404 1
	TLB_PULL(0)
d1406 1
d1408 1
d1411 9
a1422 1
#endif /*  defined(HP7000_CPU) || defined(HP7100_CPU) || defined(HP7200_CPU) */
a1435 15
/* hpti_l(addr,size) */
LEAF_ENTRY(hpti_l)
	ldo	-1(arg1), arg1
	depi	0, 31, 12, arg1
	ldi	0x1c0, t1		/* cache size assumed 128k XXX */
	or	arg0, t1, arg0
	sync
	MTCPU_C(26,DR0_PCXL2_HTLB_ADDR)
	MTCPU_C(25,DR0_PCXL2_HTLB_CFG)
	nop
	nop
	bv,n	r0(rp)
	nop
EXIT(hpti_l)

a1444 1
	sync
a1451 2
	nop
	sync
a1471 2
	depi	0, DR0_PCXL_PFMASK, 1, t1	/* enable power fail int */
	sync
d1481 2
a1482 4
#define	IITLBAF(r)	.word	0x04000440 | ((r) << 16)
#define	IITLBPF(r)	.word	0x04000400 | ((r) << 16)
#define	IDTLBAF(r)	.word	0x04001440 | ((r) << 16)
#define	IDTLBPF(r)	.word	0x04001400 | ((r) << 16)
d1484 25
a1508 26
/*
 * possible optimizations:
 *	change pte to reduce number of shifts
 *	reorder to reduce stalls
 *	check if stwas is needed (if we changed the bits)
 */
#define	TLB_PULL_L(bits)						! \
	/* space:pgaddr -- r8:r9 */					! \
	mfctl	vtop, r16						! \
	ldwax,s	r8(r16), r17		/* space -> page directory */	! \
	extru	r9, 9, 10, r25						! \
	combt,=,n r0, r17, TLABEL(all)					! \
	ldwax,s	r25(r17), r24		/* page -> page table */	! \
	extru	r9, 19, 10, r16						! \
	combt,=,n r0, r24, TLABEL(all)					! \
	ldwax,s	r16(r24), r17		/* va -> pa:prot */		! \
	sh2addl	r16, r24, r25						! \
	combt,=,n r0, r17, TLABEL(all)					! \
	depi	(bits), 21+bits, 1+bits, r17				! \
	mfctl	tr7, r1							! \
	stwas	r17, 0(r25)		/* store back w/ the bits */	! \
	shd	r17, r0, 13, r25					! \
	dep	r8, 30, 15, r25		/* mix0r the pid from the sid */! \
	dep	r0, 31, 12, r17		/* needed ? */			! \
	addi	2, r25, r25						! \
	extru	r17, 24, 25, r17
d1510 3
a1512 4
$tlbd_l
	TLB_PULL_L(1)
	IDTLBAF(17)
	IDTLBPF(25)
d1515 2
a1516 1
$itlbna_l
d1518 48
a1565 4
#if 0			/* only needed for a separate i/d tlb */
	TLB_PULL_L(0)
	IITLBAF(17)
	IITLBPF(25)
d1568 5
a1572 6
#endif
$dtlbna_l
$dtlb_l
	TLB_PULL_L(0)
	IDTLBAF(17)
	IDTLBPF(25)
d2162 1
a2162 1
	ldw	U_PCB+PCB_ONFAULT(t1), r1	! \
d2171 1
a2171 1
	stw	r1, U_PCB+PCB_ONFAULT(t1)	! \
d2178 1
a2178 1
	stw	r1, U_PCB+PCB_ONFAULT(t1)	! \
d2182 1
a2182 1
	stw	r1, U_PCB+PCB_ONFAULT(t1)
a2199 1
	stw	r1, PCB_ONFAULT+U_PCB(r31)
a2213 1
	ldw	PCB_ONFAULT+U_PCB(r31), r1
a2229 1
	nop
d2233 3
a2236 1
	mtsp	ret0, sr2	/* XXX need this? */
d2238 1
a2238 2
	copy	r0, ret0
	add,=	r0, arg0, r0
a2239 2
	bv	0(rp)
	stw	r1, PCB_ONFAULT+U_PCB(r31)
d2539 1
a2540 1
	mtctl	t3, pidr2
@


1.28.2.6
log
@Sync the SMP branch with 3.3
@
text
@d4 1
a4 1
 * Copyright (c) 1998-2003 Michael Shalayeff
d37 13
a62 21
/*
 * Copyright (c) 1990,1991,1992,1994 The University of Utah and
 * the Computer Systems Laboratory (CSL).  All rights reserved.
 *
 * Permission to use, copy, modify and distribute this software is hereby
 * granted provided that (1) source code retains these copyright, permission,
 * and disclaimer notices, and (2) redistributions including binaries
 * reproduce the notices in supporting documentation, and (3) all advertising
 * materials mentioning features or use of this software display the following
 * acknowledgement: ``This product includes software developed by the
 * Computer Systems Laboratory at the University of Utah.''
 *
 * THE UNIVERSITY OF UTAH AND CSL ALLOW FREE USE OF THIS SOFTWARE IN ITS "AS
 * IS" CONDITION.  THE UNIVERSITY OF UTAH AND CSL DISCLAIM ANY LIABILITY OF
 * ANY KIND FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * CSL requests users of this software to return to csl-dist@@cs.utah.edu any
 * improvements that they make and grant CSL redistribution rights.
 *
 *	Utah $Hdr: locore.s 1.63 95/01/20$
 */
d72 1
d75 3
d83 6
a88 6
#define	DR_PAGE0	.word	0x14001200
#define	DR_PAGE1	.word	0x14001240
#define	MTCPU_T(x,t)	.word	0x14001400 | ((t) << 21) | ((x) << 16)
#define	MFCPU_T(r,x)	.word	0x14001400 | ((r) << 21) | (x)
#define	MTCPU_C(x,t)	.word	0x14000240 | ((t) << 21) | ((x) << 16)
#define	MFCPU_C(r,x)	.word	0x14000600 | ((r) << 21) | ((x) << 16)
d103 17
a119 5
#define	EXIT_STACKSIZE	(2*NBPG)
#define	EMRG_STACKSIZE	(2*NBPG)
#define	FPEMU_STACKSIZE	(4*NBPG)

	.data
d121 1
d123 1
a123 47

	.globl	intrcnt, eintrcnt, intrnames, eintrnames
	.export	intrcnt, data
intrcnt
	.block	16 * 4
	.export	eintrcnt, data
eintrcnt
	.export	intrnames, data
intrnames
	.asciz	"spur"
	.asciz	"lev1"
	.asciz	"lev2"
	.asciz	"lev3"
	.asciz	"lev4"
	.asciz	"lev5"
	.asciz	"lev6"
	.asciz	"lev7"
	.asciz	"lev8"
	.asciz	"clock"
	.asciz	"lev10"
	.asciz	"lev11"
	.asciz	"lev12"
	.asciz	"lev13"
	.asciz	"lev14"
	.asciz	"lev15"
	.export	eintrnames, data
eintrnames
	.export netisr, data
	.align 16
netisr
	.word	0
	.align	16

	BSS(pdc_stack, 4)	/* temp stack for PDC call */
	BSS(emrg_stack, 4)	/* stack for HPMC/TOC/PWRF */
	BSS(fpemu_stack, 4)	/* stack for FPU emulation */

	.export	kernelmapped, data
	BSS(kernelmapped, 4)	/* set when kernel is mapped */
	.export fpu_csw, data
	BSS(fpu_csw, 4)		/* count fpu context switches */
	.export	fpu_curpcb, data
	BSS(fpu_curpcb, 4)	/* pcb of the fpu owner */
	.export fpu_enable, data
	BSS(fpu_enable, 4)	/* bits to set in the ccr to enable fpu */
	.export hppa_vtop, data
	BSS(hppa_vtop, 4)	/* a vtop translation table addr (pa=va) */
a125 1
	.import	$kernel_setup, entry
d134 1
a134 1
 *	pdc - PDC entry point
d159 13
a171 10
	/* assuming size being page-aligned */
#define	STACK_ALLOC(n,s)	\
	ldil	L%(n), t1	! \
	ldil	L%(s), t2	! \
	stw	arg3, R%(n)(t1)	! \
	add	arg3, t2, arg3

	STACK_ALLOC(pdc_stack, PDC_STACKSIZE)
	STACK_ALLOC(emrg_stack, EMRG_STACKSIZE)
	STACK_ALLOC(fpemu_stack, FPEMU_STACKSIZE)
d173 5
a177 1
#undef	STACK_ALLOC
d197 2
a198 2
	ldil	L%(USPACE+NBPG), arg0		/* normal U plus red zone */
	add	arg0, arg3, arg0
d204 1
a204 1
	stw	t3, R%proc0+P_MD_REGS(t2)
d211 33
a247 7
	copy	sp, arg1
	ldil	L%$qisnowon, rp
	ldo	R%$qisnowon(rp), rp
	b	$kernel_setup
	ldi	PSL_Q|PSL_I, arg2

$qisnowon
d251 1
a253 1
	.import hppa_init, code
d260 20
d282 1
a282 2
	rsm	RESET_PSL, r0
	nop ! nop ! nop ! nop ! nop ! nop ! nop
d301 1
d303 1
a303 1
	stw	t1, R%kernelmapped(t1)
d314 1
a331 72
LEAF_ENTRY($kernel_setup)

	/*
	 * disable interrupts and turn off all bits in the psw so that
	 * we start in a known state.
	 */
	rsm	RESET_PSL, r0
	nop ! nop ! nop ! nop ! nop ! nop

	/* get things ready for the kernel to run in virtual mode */
	ldi	HPPA_PID_KERNEL, r1
	mtctl	r1, pidr1
	mtctl	r1, pidr2
#if pbably_not_worth_it
	mtctl	r0, pidr3
	mtctl	r0, pidr4
#endif
	mtsp	r0, sr0
	mtsp	r0, sr1
	mtsp	r0, sr2
	mtsp	r0, sr3
	mtsp	r0, sr4
	mtsp	r0, sr5
	mtsp	r0, sr6
	mtsp	r0, sr7

	/*
	 * to keep the spl() routines consistent we need to put the correct
	 * spl level into eiem, and reset any pending interrupts
	 */
	ldi	-1, r1
	mtctl	r0, eiem
	mtctl	r1, eirr

	/*
	 * load address of interrupt vector table
	 */
	ldil	L%$ivaaddr, t2
	ldo	R%$ivaaddr(t2), t2
	mtctl	t2, iva

	/*
	 * set up the dp pointer so that we can do quick references off of it
	 */
	ldil	L%$global$,dp
	ldo	R%$global$(dp),dp

	/*
	 * Create a stack frame for us to call C with. Clear out the previous
	 * sp marker to mark that this is the first frame on the stack.
	 */
	copy	arg1, sp
	ldo	0(arg1), r3
	stw,ma	r0, HPPA_FRAME_SIZE(sp)
	stw	r0, HPPA_FRAME_CRP(sp)
	stw	r0, HPPA_FRAME_PSP(sp)

	/*
	 * We need to set the Q bit so that we can take TLB misses after we
	 * turn on virtual memory.
	 */
	mtctl	r0, pcsq
	mtctl	r0, pcsq
	mtctl	rp, pcoq
	ldo	4(rp), rp
	mtctl	rp, pcoq
	mtctl	arg2, ipsw
	rfi
	nop
	nop
EXIT($kernel_setup)

d350 1
a350 1
	ldw	R%pdc_stack(ret1), ret1
d406 1
a406 1
	ldi	PSL_Q, arg0 /* (!pdc_flag && args[0] == PDC_PIM)? PSL_M:0) */
d408 1
d444 1
d512 3
d518 2
a519 2
	be	R%$syscall(sr1, t2)
	nop ! nop ! nop ! nop
d538 4
a541 3
	ldil	L%curproc, t2
	ldw	R%curproc(sr1, t2), t2
	ldw	P_ADDR(sr1, t2), t3	/* XXX can use ,sl */
d544 2
a545 4
	ldo	NBPG(t3), t3
	stw	t3, P_MD_REGS(sr1, t2)
	ldo	TRAPFRAME_SIZEOF(t3), t3
	stw	t4, TF_R19 -TRAPFRAME_SIZEOF(sr1, t3)	/* t4 for vfork() */
d547 1
a547 10
	/* gotta save the args, in case we gonna restart */
	stw	arg3, TF_R23-TRAPFRAME_SIZEOF(sr1, t3)
	stw	arg2, TF_R24-TRAPFRAME_SIZEOF(sr1, t3)
	stw	arg1, TF_R25-TRAPFRAME_SIZEOF(sr1, t3)
	stw	arg0, TF_R26-TRAPFRAME_SIZEOF(sr1, t3)
	stw	r27, TF_R27-TRAPFRAME_SIZEOF(sr1, t3)	/* dp */
	stw	sp, TF_R30 -TRAPFRAME_SIZEOF(sr1, t3)	/* user stack */
	copy	t3, sp
	stw,ma	r0, HPPA_FRAME_SIZE+HPPA_FRAME_MAXARGS(sr1, sp)
	stw	r0, HPPA_FRAME_CRP(sr1, sp)
d554 1
a554 1
	stw	ret0, TF_CR8-TRAPFRAME_SIZEOF(sr1, t3)	/* pidr1 */
a563 1
	stw	r2 , TF_R2 -TRAPFRAME_SIZEOF(sr1, t3)
a564 1
	copy	t3, r3
d583 34
d631 1
a631 1
	ldil	L%TFF_LAST|TFF_SYS, arg1
d635 2
d640 1
a640 1
	stw	arg0, TF_SR1-TRAPFRAME_SIZEOF(sr1, t3)
d674 2
d704 1
a704 1
	ldw	P_MD_REGS(r1), t3
d716 1
d727 17
a743 10
	ldil	L%$trap_tmp_save, t2
	/* use ,bc each cache line */
	ldw  0(t3), r1 ! ldw  4(t3), t1 ! stw r1,  0(t2) ! stw t1,  4(t2)
	ldw  8(t3), r1 ! ldw 12(t3), t1 ! stw r1,  8(t2) ! stw t1, 12(t2)
	ldw 16(t3), r1 ! ldw 20(t3), t1 ! stw r1, 16(t2) ! stw t1, 20(t2)
	ldw 24(t3), r1 ! ldw 28(t3), t1 ! stw r1, 24(t2) ! stw t1, 28(t2)
	ldw 32(t3), r1 ! ldw 36(t3), t1 ! stw r1, 32(t2) ! stw t1, 36(t2)
	ldw 40(t3), r1 ! ldw 44(t3), t1 ! stw r1, 40(t2) ! stw t1, 44(t2)
	ldw 48(t3), r1 ! ldw 52(t3), t1 ! stw r1, 48(t2) ! stw t1, 52(t2)
	ldw 56(t3), r1 ! ldw 60(t3), t1 ! stw r1, 56(t2) ! stw t1, 60(t2)
a808 2
	ldw	TF_CR0(sr3, t3), t1
	mtctl	t1, rctr
d818 2
a819 2
	rsm	RESET_PSL, r0
	nop ! nop ! nop ! nop ! nop ! nop ! nop
d924 1
a924 1
#if defined(HP7100LC_CPU) || defined(HP7300LC_CPU)
d952 1
a952 1
	CTRAP(intr,T_INTERRUPT,)	/*  4. external interrupt */
d962 1
d964 3
d968 1
a968 1
	STRAP(itlbna,T_ITLBMISSNA,DTLBPRE)/* 16. ITLB non-access miss fault */
d1019 9
a1027 7
	.export TLABEL(excpt), entry
ENTRY(TLABEL(excpt),0)
	/* assume we never get this one w/o fpu [enabled] */
	copy	rp, r1
	copy	arg0, r8
	mfctl	cr30, r9
	.import	fpu_save, code
d1029 3
a1031 23
	bl	fpu_save, rp
	copy	r9, arg0
	copy	r1, rp
	copy	r8, arg0
	mtctl	r0, ccr		/* cause a reload after exception */
	ldil	L%fpu_curpcb, r1
	stw	r0, R%fpu_curpcb(r1)

	/* now, check for trap */
	ldw	0(r9), r1
	bb,>=,n	r1, HPPA_FPU_T_POS, excpt_notrap
	ldw	8(r9), r1
	extru	r1, 5, 6, r1
	comib,<>,n HPPA_FPU_UNMPL, r1, excpt_notrap

	ldw	0(r9), r1
	depi	0, HPPA_FPU_T_POS, 1, r1
	stw	r1, 0(r9)
	ldw	8(r9), r1
	stw	r0, 8(r9)
	.import	$fpu_emulate, code
	b	$fpu_emulate
	fdc	r0(r9)
d1033 5
a1037 5
excpt_notrap
	sync
	b	TLABEL(all)
	ldi	T_EXCEPTION, r1
EXIT(TLABEL(excpt))
d1040 3
a1042 1
ENTRY(TLABEL(emu),0)
d1055 3
d1059 2
a1060 4
	mfctl	iir, r8
	extru	r8, 5, 6, r9	/* no sfu implementation right now */
	comib,=	4, r9, TLABEL(all)
	ldi	T_ILLEGAL, r1
d1062 2
a1063 6
	/*
	 * pass through for all coprocessors now and
	 * do not check the uid here.
	 * in case that piece does not exist emulate
	 * or the trap will be generted later.
	 */
d1065 3
a1067 5
	/* if we are already enabled and hit again, emulate */
	mfctl	ccr, r1
	extru,<> r1, 25, 2, r0
	b,n	$fpusw_set
	nop
d1069 2
a1070 19
	mtctl	r0, ccr		/* cause a reload after exception */
	ldil	L%fpu_curpcb, r1
	stw	r0, R%fpu_curpcb(r1)
#if 0
	/* here we emulate the fld/fst */
	mfctl	iir, r1
	extru	r1, 5, 6, r1
	comib,=	0xb, r9, TLABEL(all)
	ldi	T_ILLEGAL, r1

	mfctl	iir, r1
	extru	r1, 5, 6, r1
	comib,=	0x9, r9, TLABEL(all)
	ldi	T_ILLEGAL, r1
#endif
	mfctl	iir, r1
	.import	$fpu_emulate, code
	b	$fpu_emulate
	nop
d1072 3
a1074 4
$fpusw_set
	/* enable coprocessor */
	depi	3, 25, 2, r1
	mtctl	r1, ccr
d1076 32
a1107 16
	ldil	L%fpu_curpcb, r16
	mfctl	cr30, r9
	ldw	R%fpu_curpcb(r16), r16

	comb,=,n r16, r9, $fpusw_done
	comb,=,n r16, r0, $fpusw_nosave

	copy	arg0, r17
	copy	rp, r1
	copy	r16, arg0
	.import	fpu_save, code
	.call
	bl	fpu_save, rp
	ldo	PCB_FPREGS+U_PCB(arg0), arg0
	copy	r1, rp
	copy	r17, arg0
d1112 39
a1150 38
	ldil	L%fpu_csw, r1
	ldw	R%fpu_csw(r1), r16
	ldo	1(r16), r16
	ldo	31*8+PCB_FPREGS+U_PCB(r9), r17
	stw	r16, R%fpu_csw(r1)

	fldds,ma -8(r17), fr31
	fldds,ma -8(r17), fr30
	fldds,ma -8(r17), fr29
	fldds,ma -8(r17), fr28
	fldds,ma -8(r17), fr27
	fldds,ma -8(r17), fr26
	fldds,ma -8(r17), fr25
	fldds,ma -8(r17), fr24
	fldds,ma -8(r17), fr23
	fldds,ma -8(r17), fr22
	fldds,ma -8(r17), fr21
	fldds,ma -8(r17), fr20
	fldds,ma -8(r17), fr19
	fldds,ma -8(r17), fr18
	fldds,ma -8(r17), fr17
	fldds,ma -8(r17), fr16
	fldds,ma -8(r17), fr15
	fldds,ma -8(r17), fr14
	fldds,ma -8(r17), fr13
	fldds,ma -8(r17), fr12
	fldds,ma -8(r17), fr11
	fldds,ma -8(r17), fr10
	fldds,ma -8(r17), fr9
	fldds,ma -8(r17), fr8
	fldds,ma -8(r17), fr7
	fldds,ma -8(r17), fr6
	fldds,ma -8(r17), fr5
	fldds,ma -8(r17), fr4
	fldds,ma -8(r17), fr3
	fldds,ma -8(r17), fr2
	fldds,ma -8(r17), fr1
	fldds     0(r17), fr0	/* fr0 must be restored last */
d1152 2
a1153 2
	ldil	L%fpu_curpcb, r1
	stw	r17, R%fpu_curpcb(r1)
d1156 4
a1159 1
	rfir
d1163 10
a1172 9
	/* Compute the hpt entry ptr */
#define	HPTENT \
	extru	r9, 23, 24, r16		/* r16 = (offset >> 8) */	! \
	zdep	r8, 22, 16, r24		/* r24 = (space << 9) */	! \
	mfctl	hptmask, r17		/* r17 = sizeof(HPT)-1 */	! \
	xor	r16, r24, r24		/* r24 ^= r16 */		! \
	and	r17, r24, r24		/* r24 &= r17 */		! \
	mfctl	vtop, r16		/* r16 = address of HPT table */! \
	or	r16, r24, r24		/* r24 = HPT entry */
d1174 4
a1177 5
	/* Construct the virtual address tag. */
#define	VTAG ! \
	shd	r0, r9, 1, r16		/* r16[1..15] = off[0..14] */	! \
	dep	r8, 31, 16, r16		/* put in the space id */	! \
	depi	1, 0, 1, r16		/* and set the valid bit */
d1179 16
a1194 7
#if 1
	.export	dtlb_c, data
	BSS(dtlb_c, 8)
	.export	dtlb_c, data
	BSS(tlbd_c, 8)
	.export	dtlb_c, data
	BSS(itlb_c, 8)
d1196 5
a1200 2
	.text
	/* XXX this touches tr5, which it should not, perhaps */
d1202 9
a1210 16
#define	TLB_STATS_PRE(t) \
	mfctl	itmr, r17	! \
	mtctl	r17, tr5
#define	TLB_STATS_AFT(t) \
	mfctl	itmr, r16			! \
	mfctl	tr5, r17			! \
	ldil	L%__CONCAT(t,_c), r25		! \
	ldo	R%__CONCAT(t,_c)(r25), r25	! \
	sub	r16, r17, r16			! \
	ldw	0(r25), r24			! \
	ldw	4(r25), r17			! \
	ldo	1(r24), r24			! \
	ldo	-2(r16), r16 /* for mtctl */	! \
	add	r16, r17, r17			! \
	stw	r24, 0(r25)			! \
	stw	r17, 4(r25)
d1212 102
a1313 4
#else
#define	TLB_STATS_PRE(t)	/**/
#define	TLB_STATS_AFT(t)	/**/
#endif
a1327 1
	copy	r17, r16						! \
d1329 1
a1329 1
	sub,=	r16, r17, r0		/* do not store if unchanged */	! \
a1336 1
	.align	32
a1339 1
	TLB_STATS_PRE(tlbd)
a1345 1
	TLB_STATS_AFT(tlbd)
a1354 1
	TLB_STATS_PRE(itlb)
a1355 2
	extru,=	r25, 5, 1, r0	/* gate needs a kernel pid */
	depi	0, 30, 15, r25
a1360 1
	TLB_STATS_AFT(itlb)
a1367 4
	/*
	 * from the 7100lc ers, pg.6:
	 * pa7100 provides cr28 for dtlb traps only
	 */
a1369 1
	TLB_STATS_PRE(dtlb)
a1375 1
	TLB_STATS_AFT(dtlb)
d1380 75
a1454 1
#if defined(HP7100LC_CPU) || defined(HP7300LC_CPU)
d1456 1
d1466 1
d1471 1
a1471 1
	ldwx,s	r8(r16), r17		/* space -> page directory */	! \
d1474 1
a1474 1
	ldwx,s	r25(r17), r24		/* page -> page table */	! \
d1477 1
a1477 1
	ldwx,s	r16(r24), r17		/* va -> pa:prot */		! \
a1479 1
	copy	r17, r16						! \
d1481 2
a1482 2
	sub,=	r16, r17, r0		/* do not store if unchanged */	! \
	stws	r17, 0(r25)		/* store back w/ the bits */	! \
d1487 1
a1487 2
	extru	r17, 24, 25, r17					! \
	sync
a1488 1
	.align	32
a1489 1
	TLB_STATS_PRE(tlbd)
a1492 1
	TLB_STATS_AFT(tlbd)
d1495 1
a1495 6

	/*
	 * from 7100lc ers, pg.6:
	 * we found a post-silicon bug that makes cr28
	 * unreliable for the itlb miss handler
	 */
d1497 1
a1497 2
$itlbna_l
	TLB_STATS_PRE(itlb)
a1498 2
	extru,=	r25, 5, 1, r0	/* gate needs a kernel pid */
	depi	0, 30, 15, r25
a1500 1
	TLB_STATS_AFT(itlb)
d1503 1
a1505 1
	TLB_STATS_PRE(dtlb)
a1508 1
	TLB_STATS_AFT(dtlb)
a1577 17
	/*
	 * Set up the kernel stack pointer.  If the trap happened
	 * while we were in unprivileged code, or in privileged
	 * code in the SYSCALLGATE page, move to the kernel stack
	 * in curproc's PCB; otherwise, start a new stack frame
	 * on whatever kernel stack we're already on.
	 *
	 * This used to check only for a trap while we were in
	 * unprivileged code, but this ignored the possibility
	 * that a trap could come in during the period between
	 * a gateway instruction to raise privilege and the
	 * disabling of interrupts.  During this period we're
	 * still on the user's stack, and we must move to the
	 * kernel stack.
	 *
	 * - fredette@@
	 */
a1578 1
	ldil	L%SYSCALLGATE, t2
d1580 1
a1580 3
	dep	t1, 31, PGSHIFT, t2
	dep,<>	t1, 31, 2, r0
	comb,<>	t1, t2, $trap_from_kernel
d1607 1
d1612 1
a1612 1
	nop ! nop ! nop ! nop ! nop ! nop ! nop ! nop
d1658 6
a1669 3
	copy	sp, r3
	stw,mb	r0, -HPPA_FRAME_SIZE(r3)

a1719 1
	mfctl	ccr, t2
d1721 1
a1721 1
	stw	t2, TF_CR10(t3)
d1755 3
d1765 5
a1769 140

	/* see if curproc have changed */
	ldw	-HPPA_FRAME_SIZE-TRAPFRAME_SIZEOF+TF_FLAGS(sp), arg0
	bb,>=,n	arg0, TFF_LAST_POS, $syscall_return
	ldo	-HPPA_FRAME_SIZE-TRAPFRAME_SIZEOF(sp), t3

	/* see if curproc have really changed */
	ldil	L%curproc, t1
	ldw	R%curproc(t1), t2
	comb,=,n r0, t2, $syscall_return
	ldo	-HPPA_FRAME_SIZE-TRAPFRAME_SIZEOF(sp), t3

	/* means curproc have actually changed */
	b	$syscall_return
	ldw	P_MD_REGS(t2), t3

	.export	$trap$all$end, entry
$trap$all$end
EXIT(TLABEL(all))

#if defined(HP7000_CPU) || defined(HP7100_CPU)
/*
 * void desidhash_s(void)
 */
LEAF_ENTRY(desidhash_s)
ALTENTRY(desidhash_x)
	sync
	MFCPU_T(DR_CPUCFG,22)	/* t1 */
	MFCPU_T(DR_CPUCFG,22)
	nop
	nop
	depi	0, DR0_PCXS_DHE, 3, t1	/* 3 4 DR0_PCXS_DOMAIN|DR0_PCXS_IHE */
	depi	1, DR0_PCXS_EQWSTO, 1, t1
	depi	0, DR0_PCXS_DHPMC, 1, t1
	depi	0, DR0_PCXS_ILPMC, 1, t1
	sync
	MTCPU_T(22,DR_CPUCFG)
	MTCPU_T(22,DR_CPUCFG)
	nop
	nop
	bv	0(rp)
	extru	t1, 4, 5, ret0	/* return chip revision */
EXIT(desidhash_s)
#endif /* HP7000_CPU || HP7100_CPU */

#ifdef HP7200_CPU
/*
 * void desidhash_t(void)
 */
LEAF_ENTRY(desidhash_t)
	sync
	MFCPU_T(DR_CPUCFG,22)	/* t1 */
	MFCPU_T(DR_CPUCFG,22)
	nop
	nop
	depi	0, DR0_PCXT_IHE, 1, t1
	depi	0, DR0_PCXT_DHE, 1, t1
	depi	0, DR0_PCXT_DHPMC, 1, t1
	depi	0, DR0_PCXT_ILPMC, 1, t1
	sync
	MTCPU_T(22,DR_CPUCFG)
	MTCPU_T(22,DR_CPUCFG)
	nop
	nop
	bv	0(rp)
	extru	t1, 4, 5, ret0	/* return chip revision */
EXIT(desidhash_t)
#endif /* HP7200_CPU */

#if defined(HP7100LC_CPU) || defined(HP7300LC_CPU)

/*
 * int
 * ibtlb_l(int i, pa_space_t sp, vaddr_t va, paddr_t pa, vsize_t sz, u_int prot)
 */
LEAF_ENTRY(ibtlb_l)
	rsm	(PSL_R|PSL_I), t4
	nop ! nop ! nop ! nop ! nop ! nop ! nop

	bv	0(rp)
	mtsm	t4
EXIT(ibtlb_l)

/* hpti_l(addr,size) */
LEAF_ENTRY(hpti_l)
	ldo	-1(arg1), arg1
	depi	0, 31, 12, arg1
	ldi	0x1c0, t1		/* cache size assumed 128k XXX */
	or	arg0, t1, arg0
	sync
	MTCPU_C(26,DR0_PCXL2_HTLB_ADDR)
	MTCPU_C(25,DR0_PCXL2_HTLB_CFG)
	nop
	nop
	bv,n	r0(rp)
	nop
EXIT(hpti_l)

/*
 * int
 * pbtlb_l(int i)
 */
LEAF_ENTRY(pbtlb_l)
	; DR_PAGE0
	rsm	(PSL_R|PSL_I), t4
	nop ! nop ! nop ! nop
	ldil	L%0xc041, t1
	ldo	R%0xc041(t1), t1
	dep	arg0, 30, 3, t1
	sync
	MTCPU_T(22,DR_DTLB)	/* t1 */
	nop
	nop
	mtsp	r0, sr1
	idtlba	r0,(sr1,r0)
	idtlbp	r0,(sr1,r0)
	zdepi	-1, 18, 1, t1
	nop
	sync
	MTCPU_T(22,DR_DTLB)
	nop
	nop
	bv	0(rp)
	mtsm	t4
EXIT(pbtlb_l)

/*
 * int desidhash_l(void)
 */
LEAF_ENTRY(desidhash_l)
	MFCPU_C(DR_CPUCFG,22)	/* t1 */
	nop
	nop
	depi	0, DR0_PCXL_L2IHASH_EN, 2, t1	/* + DR0_PCXL_L2DHASH_EN */
	depi	0, DR0_PCXL_L2IHPMC, 1, t1	/* don't reset */
	depi	0, DR0_PCXL_L2DHPMC, 1, t1	/* don't reset */
	depi	0, DR0_PCXL_L1IHPMC, 1, t1	/* don't reset */
	depi	0, DR0_PCXL_L2PARERR,1, t1	/* don't reset */
	sync
	MTCPU_C(22,DR_CPUCFG)
a1770 4
	nop
	bv	0(rp)
	extru	t1, 4, 5, ret0	/* return chip revision */
EXIT(desidhash_l)
d1772 5
a1776 1
#endif /* HP7100LC_CPU */
d1778 3
a1780 5
/*
 * High Priority Machine Check Interrupt
 */
	.export	TLABEL(hpmc), entry
ENTRY(TLABEL(hpmc),0)
d1782 3
a1784 24
	mtsp	r0, sr0
	ldil	L%hppa_vtop, t1
	ldw	R%hppa_vtop(t1), t1
	mtctl	t1, CR_VTOP

	.import	hpmc_dump, code
	ldil	L%hpmc_dump, rp
	ldo	R%hpmc_dump(rp), rp
	ldil	L%kpsw, %arg2
	ldw	R%kpsw(%arg2), %arg2
	depi	0, PSL_I_POS, 1, %arg2
	stw	%arg2, R%kpsw(t1)
	ldil	L%emrg_stack, arg1
	b	$kernel_setup
	ldw	R%emrg_stack(arg1), arg1

	/* never returns, but still */
	ldil	L%GBCAST_ADDR, t1
	ldi	CMD_RESET, t2
	stw	t2, R%GBCAST_ADDR(t1)
hpmc_never_dies
	b	hpmc_never_dies
	nop
EXIT(TLABEL(hpmc))
a1790 7
	mtsp	r0, sr0
	ldil	L%hppa_vtop, t1
	ldw	R%hppa_vtop(t1), t1
	mtctl	t1, CR_VTOP

	/* TODO reload btlb */

d1792 2
a1793 6
	ldil	L%boot, rp
	ldo	R%boot(rp), rp
	ldil	L%kpsw, %arg2
	ldw	R%kpsw(%arg2), %arg2
	depi	0, PSL_I_POS, 1, %arg2
	stw	%arg2, R%kpsw(t1)
d1795 4
a1798 3
	ldil	L%emrg_stack, arg1
	b	$kernel_setup
	ldw	R%emrg_stack(arg1), arg1
a1808 7
	mtsp	r0, sr0
	ldil	L%hppa_vtop, t1
	ldw	R%hppa_vtop(t1), t1
	mtctl	t1, CR_VTOP

	/* TODO reload btlb */

d1810 2
a1811 6
	ldil	L%boot, rp
	ldo	R%boot(rp), rp
	ldil	L%kpsw, %arg2
	ldw	R%kpsw(%arg2), %arg2
	depi	0, PSL_I_POS, 1, %arg2
	stw	%arg2, R%kpsw(t1)
d1813 4
a1816 3
	ldil	L%emrg_stack, arg1
	b	$kernel_setup
	ldw	R%emrg_stack(arg1), arg1
d1822 1
a1822 93
	.export	TLABEL(intr), entry
	.import	cpl, data
	.import	ipending, data
	.import	imask, data
	.import	intr_table, data
ENTRY(TLABEL(intr),0)

	mfctl	eirr, r8
	mtctl	r8, eirr	/* ack now */

	ldil	L%ipending, r17
	ldw	R%ipending(r17), r24
	ldil	L%intr_table, r1
	ldo	R%intr_table(r1), r1
$intr_ffs
	addi	16, r1, r1
	bb,>=	r8, 31, $intr_ffs
	shd	r0, r8, 1, r8

	ldb	2-16(r1), r17
	ldw	4-16(r1), r9
	subi,<>	1, r17, r0
	bv,n	r0(r9)
	nop

	mfctl	sar, r25
	ldb	1-16(r1), r9
	mtsar	r9
	vdepi	1, 1, r24
	mtsar	r25

	ldb	0-16(r1), r9
	ldil	L%intrcnt, r25
	ldo	R%intrcnt(r25), r25
	sh2add	r9, r25, r25
	ldw	0(r25), r17
	addi	1, r17, r17
	stw	r17, 0(r25)

$intr_cont
	comb,<>	r0, r8, $intr_ffs
	nop

	ldil	L%ipending, r17
	stw	r24, R%ipending(r17)
	ldil	L%cpl, r17
	ldw	R%cpl(r17), r17
	ldil	L%imask, r9
	ldo	R%imask(r9), r9
	ldwx,s	r17(r9), r16
	ldi	T_INTERRUPT, r1
	andcm,=	r24, r16, r0
	b	TLABEL(all)
	nop

	rfir
	nop
EXIT(TLABEL(intr))

	.export	gsc_intr, entry
LEAF_ENTRY(gsc_intr)

	ldw	8-16(r1), r9	/* arg: ioreg */
	mtctl	r1, tr7
	ldw	0(r9), r16	/* irr */

	ldw	12-16(r1), r1	/* next: sub-intr_table */
$gsc_ffs
	addi	16, r1, r1
	bb,>=	r16, 31, $gsc_ffs
	shd	r0, r16, 1, r16

	mfctl	sar, r25
	ldb	1-16(r1), r17
	mtsar	r17
	vdepi	1, 1, r24
	mtsar	r25

	ldb	0-16(r1), r17
	ldil	L%intrcnt, r25
	ldo	R%intrcnt(r25), r25
	sh2add	r17, r25, r25
	ldw	0(r25), r17
	addi	1, r17, r17
	stw	r17, 0(r25)

	comb,<>	r0, r16, $gsc_ffs
	nop

	b	$intr_cont
	mfctl	tr7, r1
EXIT(gsc_intr)

d1825 3
d1829 2
a1830 2
	mfctl	pcoq, r8
	extru,=	r8, 31, 2, r0
d1835 7
a1841 7
	ldil	L%etext, r9
	ldo	R%etext(r9), r9
	comb,>>=,n r8, r9, $ibrk_bad

	mfctl	iir, r8
	extru	r8, 31, 5, r9
	comib,<>,n HPPA_BREAK_KERNEL, r9, $ibrk_bad
d1844 3
a1846 4
	extru	r8, 18, 13, r9
	comib,=,n HPPA_BREAK_GET_PSW, r9, $ibrk_getpsw
	comib,=,n HPPA_BREAK_SET_PSW, r9, $ibrk_setpsw
	comib,=,n HPPA_BREAK_SPLLOWER, r9, $ibrk_spllower
d1850 1
d1852 1
a1852 1
	nop
d1863 4
a1866 22
$ibrk_spllower
	/* skip the break */
	mtctl	r0, pcoq
	mfctl	pcoq, r9
	mtctl	r9, pcoq
	ldo	4(r9), r9
	mtctl	r9, pcoq

	ldil	L%ipending, r8
	ldw	R%ipending(r8), r8
	ldil	L%imask, r9
	ldo	R%imask(r9), r9
	ldil	L%cpl, r17
	ldw	R%cpl(r17), ret0
	ldwx,s	arg0(r9), r16
	stw	arg0, R%cpl(r17)
	ldi	T_INTERRUPT, r1
	andcm,=	r8, r16, r0
	b	TLABEL(all)
	nop
	rfir
	nop
d1874 8
a1881 6
	mfctl	pcoq, r9
	mtctl	r9, pcoq
	ldo	4(r9), r9
	mtctl	r9, pcoq

	rfir
a1884 182
LEAF_ENTRY(fpu_save)
	fstds,ma %fr0 , 8(arg0)
	fstds,ma %fr1 , 8(arg0)
	fstds,ma %fr2 , 8(arg0)
	fstds,ma %fr3 , 8(arg0)
	fstds,ma %fr4 , 8(arg0)
	fstds,ma %fr5 , 8(arg0)
	fstds,ma %fr6 , 8(arg0)
	fstds,ma %fr7 , 8(arg0)
	fstds,ma %fr8 , 8(arg0)
	fstds,ma %fr9 , 8(arg0)
	fstds,ma %fr10, 8(arg0)
	fstds,ma %fr11, 8(arg0)
	fstds,ma %fr12, 8(arg0)
	fstds,ma %fr13, 8(arg0)
	fstds,ma %fr14, 8(arg0)
	fstds,ma %fr15, 8(arg0)
	fstds,ma %fr16, 8(arg0)
	fstds,ma %fr17, 8(arg0)
	fstds,ma %fr18, 8(arg0)
	fstds,ma %fr19, 8(arg0)
	fstds,ma %fr20, 8(arg0)
	fstds,ma %fr21, 8(arg0)
	fstds,ma %fr22, 8(arg0)
	fstds,ma %fr23, 8(arg0)
	fstds,ma %fr24, 8(arg0)
	fstds,ma %fr25, 8(arg0)
	fstds,ma %fr26, 8(arg0)
	fstds,ma %fr27, 8(arg0)
	fstds,ma %fr28, 8(arg0)
	fstds,ma %fr29, 8(arg0)
	fstds,ma %fr30, 8(arg0)
	fstds    %fr31, 0(arg0)
	fdc	r0(arg0)
	ldo	-56(arg0), arg0
	fdc	r0(arg0)
	ldo	-32(arg0), arg0
	fdc	r0(arg0)
	ldo	-32(arg0), arg0
	fdc	r0(arg0)
	ldo	-32(arg0), arg0
	fdc	r0(arg0)
	ldo	-32(arg0), arg0
	fdc	r0(arg0)
	ldo	-32(arg0), arg0
	fdc	r0(arg0)
	ldo	-32(arg0), arg0
	fdc	r0(arg0)
	bv	r0(rp)
	sync
EXIT(fpu_save)

#ifdef FPEMUL
	/*
	 * Emulate FPU
	 *
	 * iisq:iioq - exception triggered instruction
	 */
ENTRY($fpu_emulate,320)
	copy	r31, r9

	ldil	L%fpemu_stack, r31
	ldw	R%fpemu_stack(r31), r31

	/* stw	r1 , TF_R1 (r31) shadowed */
	stw	r2 , TF_R2 (r31)
	stw	r3 , TF_R3 (r31)
#ifdef DDB
	stw	r4 , TF_R4 (r31)
	stw	r5 , TF_R5 (r31)
	stw	r6 , TF_R6 (r31)
	stw	r7 , TF_R7 (r31)
	/* stw	r8 , TF_R8 (r31) shadowed */
	/* stw	r9 , TF_R9 (r31) shadowed */
	stw	r10, TF_R10(r31)
	stw	r11, TF_R11(r31)
	stw	r12, TF_R12(r31)
	stw	r13, TF_R13(r31)
	stw	r14, TF_R14(r31)
	stw	r15, TF_R15(r31)
	/* stw	r16, TF_R16(r31) shadowed */
	/* stw	r17, TF_R17(r31) shadowed */
	stw	r18, TF_R18(r31)
#endif
	stw	r19, TF_R19(r31)
	stw	r20, TF_R20(r31)
	stw	r21, TF_R21(r31)
	stw	r22, TF_R22(r31)
	stw	r23, TF_R23(r31)
	/* stw	r24, TF_R24(r31) shadowed */
	/* stw	r25, TF_R25(r31) shadowed */
	stw	r26, TF_R26(r31)
	stw	r27, TF_R27(r31)
	stw	r28, TF_R28(r31)
	stw	r29, TF_R29(r31)
	stw	sp, TF_R30(r31)
	stw	r9, TF_R31(r31)
	copy	r1, arg0
	mfctl	sar, r1
	stw	r1, TF_CR11(r31)
	stw	arg0, TF_CR19(r31)

	ldo	TRAPFRAME_SIZEOF(r31), r3
	ldo	TRAPFRAME_SIZEOF+HPPA_FRAME_SIZE(r31), sp

	ldil	L%$global$, dp
	ldo	R%$global$(dp), dp

	.import	fpu_emulate, code
	ldil	L%fpu_emulate,t1
	ldo	R%fpu_emulate(t1),t1
	mfctl	cr30, arg2
	.call
	blr	r0,rp
	bv,n	0(t1)
	nop

	mfctl	cr30, arg0
	fdc	r0(arg0)
	ldo	32(arg0), arg0
	fdc	r0(arg0)
	ldo	32(arg0), arg0
	fdc	r0(arg0)
	ldo	32(arg0), arg0
	fdc	r0(arg0)
	ldo	32(arg0), arg0
	fdc	r0(arg0)
	ldo	32(arg0), arg0
	fdc	r0(arg0)
	ldo	32(arg0), arg0
	fdc	r0(arg0)
	ldo	32(arg0), arg0
	fdc	r0(arg0)

	ldil	L%fpemu_stack, r31
	ldw	R%fpemu_stack(r31), r31

	ldw	TF_CR11(r31), r1
	ldw	TF_R2 (r31), r2
	ldw	TF_R3 (r31), r3
	mtsar	r1
	copy	ret0, r1
#ifdef DDB
	ldw	TF_R4 (r31), r4
	ldw	TF_R5 (r31), r5
	ldw	TF_R6 (r31), r6
	ldw	TF_R7 (r31), r7
	/* ldw	TF_R8 (r31), r8 shadowed */
	/* ldw	TF_R9 (r31), r9 shadowed */
	ldw	TF_R10(r31), r10
	ldw	TF_R11(r31), r11
	ldw	TF_R12(r31), r12
	ldw	TF_R13(r31), r13
	ldw	TF_R14(r31), r14
	ldw	TF_R15(r31), r15
	/* ldw	TF_R16(r31), r16 shadowed */
	/* ldw	TF_R17(r31), r17 shadowed */
	ldw	TF_R18(r31), r18
#endif
	ldw	TF_R19(r31), r19
	ldw	TF_R20(r31), r20
	ldw	TF_R21(r31), r21
	ldw	TF_R22(r31), r22
	ldw	TF_R23(r31), r23
	/* ldw	TF_R24(r31), r24 shadowed */
	/* ldw	TF_R25(r31), r25 shadowed */
	ldw	TF_R26(r31), r26
	ldw	TF_R27(r31), r27
	ldw	TF_R28(r31), r28
	ldw	TF_R29(r31), r29
	ldw	TF_R30(r31), r30
	ldw	TF_R31(r31), r31

	comb,<>	r0, r1, TLABEL(all)
	ldi	T_EXCEPTION, r1

	rfir
	nop
EXIT($fpu_emulate)

#endif /* FPEMUL */

d1924 1
a1924 1
	fdc	r0(sr1, arg1)
d1929 1
a1929 1
	nop
d1971 1
a1971 1
	pdc	r0(sr1, arg1)
d1976 1
a1976 1
	nop
d2018 1
a2018 1
	fic	r0(sr1, arg1)
d2023 1
a2023 1
	nop
d2087 47
a2133 1
	.align	32
d2136 1
a2136 5
	mtsp	r0, sr1
	mtsp	r0, sr2
	stw	r1, PCB_ONFAULT+U_PCB(r2)
	ldw	HPPA_FRAME_CRP(sp), rp
	ldo	-64(sp), sp
a2146 4
	ldw	HPPA_FRAME_ARG(4)(sp), t2
	ldo	64(sp), sp
	add	t2, arg1, t2
	stw	rp, HPPA_FRAME_CRP(sp)
d2148 7
a2154 7
	ldil	L%curproc, t1
	ldw	R%curproc(t1), t3
	ldil	L%copy_on_fault, t4
	ldw	P_ADDR(t3), r2
	ldo	R%copy_on_fault(t4), t4
	ldw	PCB_ONFAULT+U_PCB(r2), r1
	stw	t4, PCB_ONFAULT+U_PCB(r2)
d2156 2
d2160 1
d2165 1
a2165 1
	comb,=	t2, arg1, $spstrcpy_exit
d2171 1
a2171 4
	mtsp	r0, sr1
	mtsp	r0, sr2
	stw	r1, PCB_ONFAULT+U_PCB(r2)
	ldw	HPPA_FRAME_CRP(sp), rp
d2173 1
a2173 1
	ldo	-64(sp), sp
d2175 2
a2176 1
	sub,=	r0, arg0, r0
d2179 1
a2179 1
	copy	r0, ret0
d2182 35
d2227 1
a2227 1
	comb,<>,n r0, t1, Lsetrunqueue_panic
d2229 1
a2229 1
	comb,<>,n r0, t1, Lsetrunqueue_panic
d2231 2
a2232 2
	comib,=,n SRUN, t1, Lsetrunqueue_ok
Lsetrunqueue_panic
d2245 1
a2245 1
Lsetrunqueue_ok
d2253 19
a2271 1
	ldil	L%whichqs, arg3
a2274 1
	ldw	R%whichqs(arg3), t3
d2276 1
a2276 1
	mtctl	t1, sar
d2278 3
a2280 3
	vdepi	1, 1, t3
	bv	0(rp)
	stw	t3, R%whichqs(arg3)
d2290 2
a2291 1
	extru	t2, 29, 5, arg2
a2292 1
	mtsar	arg2
d2300 1
a2307 1
	nop
d2318 4
a2322 1
	sub,<>	t4, arg0, r0
d2324 1
d2326 1
a2326 1
	stw	t4, P_BACK(arg0)
a2334 4
	ldil	L%cpl, t1
	ldw	R%cpl(t1), ret0
	stw	ret0, HPPA_FRAME_SL(sp)
	stw	rp, HPPA_FRAME_CRP(sp)
d2345 3
a2347 2
	 * t1:   &whichqs
	 * arg2: old curproc
d2352 2
d2355 3
d2359 1
d2363 1
a2363 2
	copy	r0, arg0
	break	HPPA_BREAK_KERNEL, HPPA_BREAK_SPLLOWER
d2368 2
a2369 3
	ldil	L%cpl, arg0
	b	switch_search
	stw	ret0, R%cpl(arg0)
a2401 3
	ldil	L%want_resched, t4
	stw	r0, R%want_resched(t4)

d2407 3
a2410 1
	sub,<>	t2, arg0, r0
d2414 4
a2424 17
	/*
	 * Either we must be switching to the same process, or
	 * the the new process' kernel stack must be reasonable.
	 */
	comb,=,n arg1, arg2, kstack_ok
	ldw     P_MD_REGS(arg1), t1
	ldw     P_ADDR(arg1), arg0
	ldw     TF_R30(t1), t1
	ldo     NBPG(arg0), arg0
	comb,>>,n arg0, t1, switch_error
	copy    arg1, t2
	sub     t1, arg0, t1
	ldil    L%USPACE, arg0
	ldo     R%USPACE(arg0), arg0
	comb,<<=,n arg0, t1, switch_error
	copy    arg1, t2
kstack_ok
d2426 3
d2440 3
a2442 1
	ldw	P_MD_REGS(arg2), t1
d2444 3
a2446 2
	copy	sp, t2
	stw,ma	r3, HPPA_FRAME_SIZE+20*4(sp)
a2447 2
	stw	t2, HPPA_FRAME_PSP(sp)
	stw	t3, HPPA_FRAME_ARG(0)(sp)	/* real user's stack */
d2450 1
d2475 1
a2475 1
	ldw	P_MD_REGS(arg1), t1
d2481 2
d2484 3
a2486 2
	ldw	HPPA_FRAME_ARG(0)(sp), t3
	ldw	HPPA_FRAME_ARG(1)(sp), t4 /* in case we're on trampoline */
a2487 2
	ldw	HPPA_FRAME_SL(t2), ret0
	ldw	HPPA_FRAME_CRP(t2), rp
a2503 1
	stw	t3, TF_R30(t1)
a2504 2
	ldil	L%cpl, t1
	stw	ret0, R%cpl(t1)
a2506 1
	ldil	L%curproc, t1
d2508 2
a2509 1
	stw	arg1, R%curproc(t1)
d2512 48
d2563 1
a2563 1
	bv,n	r0(t4)
d2569 1
a2569 1
	ldw	P_MD_REGS(t2), t3
@


1.28.2.7
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.28.2.6 2003/03/27 23:26:53 niklas Exp $	*/
d107 3
a109 2
#define	EMRG_STACKSIZE	(1*NBPG)
#define	FPEMU_STACKSIZE	(1*NBPG)
d1213 1
a1213 1
#if 0
d2393 1
a2393 1
 * across function calls.  According to the "HP 9000 Series 800 Assembly
@


1.28.2.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d111 2
a112 3
	.align	64
$trap_tmp_save
	.block	TF_PHYS
a145 7
	.export cpu_hzticks, data
cpu_hzticks			/* itmr ticks in one hz */
	.word	0
	.export cpu_itmr, data
cpu_itmr			/* itmr value at the most recent clk int */
	.word	0

d691 1
a691 1
	mfctl	vtop, arg1
d693 1
a693 1
	stw	arg1, TF_CR25-TRAPFRAME_SIZEOF(sr1, t3)
d695 1
d697 1
a750 1
	ldo	R%$trap_tmp_save(t2), t2
a840 1
	ldo	R%$trap_tmp_save(t3), t3
a959 3
#define	INTRPRE	\
	mfctl	eirr, r8 ! \
	mtctl	r8, eirr
d970 1
a970 1
	CTRAP(intr,T_INTERRUPT,INTRPRE)	/*  4. external interrupt */
d1196 10
d1215 1
a1215 1
	.export	tlbd_c, data
d1217 1
a1217 1
	.export	itlb_c, data
a1364 8
#ifdef USE_HPT
	/* invalidate instead of update */
	mfctl	cr28, r17
	ldw	0(r17), r24
	VTAG
	sub,<>	r16, r24, r0
	stw	r25, 4(r17)
#endif
a1385 8
	TLB_STATS_PRE(dtlb)
	TLB_PULL_L(0)
	IDTLBAF(17)
	IDTLBPF(25)
	/* figure out later if it's worth caching mappings here as well */
	TLB_STATS_AFT(dtlb)
	rfir
	nop
a1390 41
#ifdef USE_HPT
	/*
	 * cache the next page mapping in the hpt.
	 *
	 * mapping for a page at the end of each 128k is uncachable
	 * in the hvt since it'd be in the tlb itself and thus there
	 * is no reason to cache it!
	 * as a side effect this avoids recomputing hpt entry and
	 * retraversing the whole page table each time.
	 */

	ldo	PAGE_SIZE(r9), r9
	extru,<> r9, 20, 5, r0
	b,n	$dtlb_done_l	/* skip if no simple advance */
	/* do not check the PT overlap since the above
	 * check already guaranties that */

	/* ripped from TLB_PULL_L(0) */
	extru	r9, 19, 10, r16		/* r24 was loaded in the TLB_PULL_L */
	ldwx,s	r16(r24), r17		/* va -> pa:prot */
	sh2addl	r16, r24, r25
	combt,=,n r0, r17, $dtlb_done_l
	copy	r17, r16
	depi	0, 21, 1, r17
	sub,=	r16, r17, r0		/* do not store if unchanged */
	stws	r17, 0(r25)		/* store back w/ the bits */
	shd	r17, r0, 13, r25
	dep	r8, 30, 15, r25		/* mix0r the pid from the sid */
	dep	r0, 31, 12, r17		/* needed ? */
	addi	2, r25, r25
	extru	r17, 24, 25, r17
	sync

	mfctl	cr28, r24
	VTAG
	ldo	16(r24), r24
	stw	r16, 0(r24)
	stw	r25, 4(r24)
	stw	r17, 8(r24)
$dtlb_done_l
#endif
a1416 1
	ldo	R%$trap_tmp_save(t3), t3
a1510 2
	mfctl	rctr, t1		/* gotta get it before R is up */

a1520 4
	mfctl	ccr, t2
	stw	t1, TF_CR0(sr3, t3)
	stw	t2, TF_CR10(sr3, t3)

a1572 1
	ldo	R%$trap_tmp_save(t2), t2
d1618 5
d1628 1
a1628 1
	mfctl	vtop, t2
d1630 1
a1630 1
	stw	t2, TF_CR25(t3)
d1632 1
d1634 1
a1730 15
#ifdef HP7300LC_CPU
	.data
	BSS(eaio_l2_mask, 4)
LEAF_ENTRY(eaio_l2)
	ldil	L%eaio_l2_mask, t2
	ldw	R%eaio_l2_mask(t2), t1
	or	t1, arg0, t1
	MTCPU_C(22, DR0_PCXL2_ACCEL_IO)
	nop
	nop
	bv	0(rp)
	stw	t1, R%eaio_l2_mask(t2)
EXIT(eaio_l2)
#endif /* HP7300LC_CPU */

a1902 1
	/* r8 set to eirr in the INTRPRE */
d1904 2
a1905 11
	bb,>=,n	r8, 0, $intr_noclock
	nop

	/* reload the itmr */
	ldil	L%cpu_hzticks, r25	/* those both are aligned properly */
	ldw	R%cpu_hzticks(r25), r16
	ldw	R%cpu_itmr(r25), r9
	sh1add	r16, r9, r17
	add	r16, r9, r16
	mtctl	r17, itmr
	stw	r16, R%cpu_itmr(r25)
a1906 1
$intr_noclock
d1912 1
a1912 1
	addi	32, r1, r1
d1916 2
a1917 2
	ldb	2-32(r1), r17
	ldw	4-32(r1), r9
d1923 1
a1923 1
	ldb	1-32(r1), r9
d1928 1
a1928 1
	ldb	0-32(r1), r9
d1959 1
a1959 1
	ldw	8-32(r1), r9	/* arg: ioreg */
d1963 1
a1963 5
	ldw	12-32(r1), r1	/* next: sub-intr_table */

$gsc_intr_loop
	comb,=,n r0, r16, $intr_cont
	mfctl	tr7, r1
d1965 1
a1965 1
	addi	32, r1, r1
a1968 2
	copy	r1, r9
$gsc_share
d1970 1
a1970 1
	ldb	1-32(r1), r17
d1975 1
a1975 1
	ldb	0-32(r1), r17
d1983 2
a1984 3
	ldw	16-32(r1), r17
	comb,<>,n r0, r17, $gsc_share
	ldo	32(r17), r1
d1986 2
a1987 2
	b	$gsc_intr_loop
	copy	r9, r1
a1989 39
	.export	dino_intr, entry
LEAF_ENTRY(dino_intr)
	ldw	8-32(r1), r9	/* arg: ioreg */
	mtctl	r1, tr7
	ldw	12(r9), r16	/* irr0 */

	ldw	12-32(r1), r1	/* next: sub-intr_table */
$dino_intr_loop
	comb,=,n r0, r16, $intr_cont
	mfctl	tr7, r1
$dino_ffs
	addi	32, r1, r1
	bb,>=	r16, 31, $dino_ffs
	shd	r0, r16, 1, r16

	copy	r1, r9
$dino_share
	mfctl	sar, r25
	ldb	1-32(r1), r17
	mtsar	r17
	vdepi	1, 1, r24
	mtsar	r25

	ldb	0-32(r1), r17
	ldil	L%intrcnt, r25
	ldo	R%intrcnt(r25), r25
	sh2add	r17, r25, r25
	ldw	0(r25), r17
	addi	1, r17, r17
	stw	r17, 0(r25)

	ldw	16-32(r1), r17
	comb,<>,n r0, r17, $dino_share
	ldo	32(r17), r1

	b	$dino_intr_loop
	copy	r9, r1
EXIT(dino_intr)

d2690 1
a2690 1
	 * the new process' kernel stack must be reasonable.
d2806 4
a2809 3
	ble	0(sr0, arg3)
	copy	r31, rp

a2810 1
	copy	r4, arg0
d2814 1
a2814 1

a2815 1
	copy	ret0, arg0
@


1.28.2.9
log
@Merge with the trunk
@
text
@d4 1
a4 1
 * Copyright (c) 1998-2004 Michael Shalayeff
d15 5
a165 1
	BSS(fpu_scratch, 16)	/* FPU scratch space, enough for a quad */
d888 1
d890 1
d892 1
a892 2
	.import TLABEL(name), code	! \
	b	TLABEL(name)		! \
d914 2
d917 40
a956 5
	b	__CONCAT($name,_l)	! \
	ldi	num, r1			! \
	b	__CONCAT($name,_t)+8	! \
	b	__CONCAT($name,_s)+12	! \
	nop /*b	__CONCAT($name,_u)+16 */
d959 3
a961 2
	mfctl	pcoq,r9 ! \
	mfctl	pcsq,r8
d963 3
a965 2
	mfctl	ior, r9 ! \
	mfctl	isr, r8	
a966 1

d969 1
a969 1
	mfctl	eirr, r8	! \
a1049 3
#if (PCB_FPREGS+U_PCB) != 0
	ldo	PCB_FPREGS+U_PCB(r9), r9
#endif
d1064 2
a1065 1
	bb,>=,n r1, 5, excpt_notrap	/* HPPA_FPU_UNMPL not set */
d1067 5
a1071 2
	ldw	0(r9), r16
	depi	0, HPPA_FPU_T_POS, 1, r16
d1074 1
a1074 1
	stw	r16, 0(r9)
d1144 1
a1145 1
	comb,=,n r16, r9, $fpusw_done
d1149 1
a1149 3
#if (PCB_FPREGS+U_PCB) != 0
	ldo	PCB_FPREGS+U_PCB(r16), r16
#endif
d1153 1
a1153 1
	copy	r16, arg0
d1158 1
d1162 1
a1163 1
	ldo	1(r16), r16
d1270 1
d1284 2
d1303 2
d1307 4
d1746 1
d1971 1
a1971 25
#if 0
	.align	8
intr_ticks
	.word	0, 0

#define	INTR_PROF_PRE \
	mfctl	itmr, r9		! \
	mtctl	r9, tr5
#define	INTR_PROF_AFT \
	mfctl	itmr, r8		! \
	mfctl	tr5, r9			! \
	ldil	L%intr_ticks, r1	! \
	ldo	R%intr_ticks(r1), r1	! \
	sub	r8, r9, r8		! \
	ldw	0(r1), r16		! \
	ldw	4(r1), r17		! \
	add	r8, r16, r16		! \
	addi	1, r17, r17		! \
	stw	r16, 0(r1)		! \
	stw	r17, 4(r1)
#else
#define	INTR_PROF_PRE	/* */
#define	INTR_PROF_AFT	/* */
#endif

a1975 1
	.align	32
d1977 1
a1977 5
	/*
	 * r8 is set to eirr in the INTRPRE
	 */

	INTR_PROF_PRE
d1980 1
a1991 2
	ldil	L%intr_table + 32*32, r1
	ldo	R%intr_table + 32*32(r1), r1
a1992 1
	b	$intr_cont
d1994 2
a1995 1

d1997 3
a1999 3
	addi	-32, r1, r1
	bb,>=	r8, 0, $intr_ffs
	zdep	r8, 30, 31, r8
d2001 19
a2019 17
	ldw	0(r1), r17
	bb,>=,n	r17, 23, $intr_nocall

	ldw	2*4(r1), r16	/* func */
	ldw	3*4(r1), r9	/* arg: ioreg */
	mtctl	r1, tr7
	bv	r0(r16)
	ldw	4*4(r1), r1	/* next: sub-intr_table */

$intr_nocall
	ldw	6*4(r1), r17	/* bit */
	ldw	7*4(r1), r25	/* &intrcnt[pri] */
	or	r17, r24, r24	/* ipending */

	ldw	0(r25), r9
	addi	1, r9, r9
	stw	r9, 0(r25)
a2020 1
	/* also return from nested handlers */
d2022 2
a2023 2
	comb,<>,n r0, r8, $intr_ffs
	ldw	-32(r1), r0	/* preload cache */
d2025 2
a2026 2
	ldil	L%ipending, r25
	stw	r24, R%ipending(r25)
d2029 3
a2031 6
	ldil	L%imask, r16
	ldo	R%imask(r16), r16
	ldwx,s	r17(r16), r25

	INTR_PROF_AFT

d2033 1
a2033 1
	andcm,=	r24, r25, r0
d2041 1
a2041 10
/*
 * called with:
 *	r1	sub intr_table
 *	r9	ioregs
 *	r24	ipending (in/out)
 *	tr7	saved r1 (restore on return)
 * free:
 *	r9, r16, r17, r25
 */
	.align	32
d2043 3
d2048 2
a2049 1
	/* we know that first 5 bits are never used ... should skip */
d2058 1
a2058 1
	ldo	-32(r1), r9
d2060 10
a2069 4
	ldw	6*4(r9), r17	/* bit */
	ldw	7*4(r9), r25	/* &intrcnt[pri] */
	or	r17, r24, r24	/* ipending */

a2070 1
	ldw	5*4(r9), r9	/* share */
a2071 1
	comb,<>	r0, r9, $gsc_share
d2074 6
a2079 1
	b,n	$gsc_intr_loop
d2082 1
a2082 2
	/* see above for calling conventions */
	.align	32
d2084 3
a2086 1
	ldw	3*4(r9), r16	/* irr0 */
d2088 1
d2097 1
a2097 1
	ldo	-32(r1), r9
d2099 10
a2108 4
	ldw	6*4(r9), r17	/* bit */
	ldw	7*4(r9), r25	/* &intrcnt[pri] */
	or	r17, r24, r24	/* ipending */

a2109 1
	ldw	5*4(r9), r9	/* share */
a2110 1
	comb,<>	r0, r9, $dino_share
d2113 6
a2118 1
	b,n	$dino_intr_loop
a2195 8
LEAF_ENTRY(fpu_exit)
	ldil	L%fpu_scratch, %r25
	ldo	R%fpu_scratch(%r25), %r25
	fstds	%fr0, 0(%r25)
	bv	%r0(%rp)
	sync
EXIT(fpu_exit)

d2229 15
a2243 10
	ldo	-24(arg0), arg0
	ldi	-32, r25	/* gotta be free for all callers */
	fdc,m	r25(arg0)
	fdc,m	r25(arg0)
	fdc,m	r25(arg0)
	fdc,m	r25(arg0)
	fdc,m	r25(arg0)
	fdc,m	r25(arg0)
	fdc,m	r25(arg0)
	fdc,m	r25(arg0)
d2313 16
a2328 16
	mfctl	cr30, r25
	ldi	32, r1

	ldw	8(r25), r17	/* fpu exception reg 0 */
	zdep	ret0, 5, 6, r17	/* intentionally zero the insn */
	stw	r17, 8(r25)

	fdc,m	r1(r25)
	fdc,m	r1(r25)
	fdc,m	r1(r25)
	fdc,m	r1(r25)
	fdc,m	r1(r25)
	fdc,m	r1(r25)
	fdc,m	r1(r25)
	fdc	r0(r25)
	sync
d2369 1
a2369 9
	bb,>=,n	r1, 24, $fpu_emulate_done

	b	TLABEL(all)
	ldi	T_EMULATION, r1

$fpu_emulate_done
	comb,=,n r0, r1, $fpu_emulate_done2

	b	TLABEL(all)
a2371 1
$fpu_emulate_done2
a2935 5
	bb,>=,n	arg3, 30, sigcode_call
	dep	r0, 31, 2, arg3
	ldw	4(arg3), r19
	ldw	0(arg3), arg3
sigcode_call
@


1.28.2.10
log
@set SONPROC, help from mickey
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.28.2.9 2004/06/05 23:10:48 niklas Exp $	*/
a2812 2
	ldi	SONPROC, t1
	stb	t1, P_STAT(arg1)
@


1.28.2.11
log
@sync with head, make i386 __HAVE_CPUINFO
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d2711 1
a2711 1
	copy	r3, r1
a2712 3
	copy	sp, r3
	stw	ret0, HPPA_FRAME_SL(sp)
	stwm	r1, HPPA_FRAME_SIZE+20*4(sp)
a2718 1
	b	switch_search
a2721 24
cpu_idle
	copy	r0, arg0
	break	HPPA_BREAK_KERNEL, HPPA_BREAK_SPLLOWER
	.import uvm, data
	ldil	L%(uvm + PAGE_IDLE_ZERO), t3
	ldw	R%(uvm + PAGE_IDLE_ZERO)(t3), t4
	sub,<>	r0, t4, r0
	b	cpu_loop

	stw	arg2, 4(r3)
	ldil	L%uvm_pageidlezero, t1
	ldo	R%uvm_pageidlezero(t1), t2
	.call
	ble	0(sr0, t2)
	copy	r31, rp

	ldw	HPPA_FRAME_SL(r3), ret0
	ldw	4(r3), arg2

cpu_loop
	ldil	L%cpl, arg0
	stw	ret0, R%cpl(arg0)

switch_search
d2727 2
d2731 3
a2733 1
	comb,=,n r0, t3, cpu_idle
d2735 8
d2744 1
d2800 1
d2802 1
a2802 1
	ldw	U_PCB+PCB_KSP(arg0), t1
d2826 8
a2833 1
	ldw	P_ADDR(arg2), t1
d2835 15
a2849 19
	stw	r4,   1*4(r3)
	stw	sp, U_PCB+PCB_KSP(t1)
	stw	r5,   2*4(r3)
	stw	r6,   3*4(r3)
	stw	r7,   4*4(r3)
	stw	r8,   5*4(r3)
	stw	r9,   6*4(r3)
	stw	r10,  7*4(r3)
	stw	r11,  8*4(r3)
	stw	r12,  9*4(r3)
	stw	r13, 10*4(r3)
	stw	r14, 11*4(r3)
	stw	r15, 12*4(r3)
	stw	r16, 13*4(r3)
	stw	r17, 14*4(r3)
	stw	r18, 15*4(r3)
	fdc	r0(t1)
	stw	r0, HPPA_FRAME_ARG(1)(sp)	/* say no trampoline */
	sync
d2858 1
a2858 1
	ldw	P_ADDR(arg1), t2
a2859 2
	ldw	U_PCB+PCB_KSP(t2), sp
	mtctl	r0, ccr			/* disable FPU */
d2861 1
d2865 2
a2866 2
	ldo	-(HPPA_FRAME_SIZE+20*4)(sp), r3
	ldw	HPPA_FRAME_ARG(0)(sp), arg0
d2868 21
a2888 19
	sub,=	r0, t4, r0
	b	switch_gonnajump
	ldw	 1*4(r3), r4
	ldw	 2*4(r3), r5
	ldw	 3*4(r3), r6
	ldw	 4*4(r3), r7
	ldw	 5*4(r3), r8
	ldw	 6*4(r3), r9
	ldw	 7*4(r3), r10
	ldw	 8*4(r3), r11
	ldw	 9*4(r3), r12
	ldw	10*4(r3), r13
	ldw	11*4(r3), r14
	ldw	12*4(r3), r15
	ldw	13*4(r3), r16
	ldw	14*4(r3), r17
	ldw	15*4(r3), r18
switch_gonnajump
	ldw	HPPA_FRAME_SL(r3), ret0
a2890 1
	sync
d2894 1
a2895 3
	ldw	HPPA_FRAME_CRP(r3), rp
	bv	0(rp)
	ldwm	-(HPPA_FRAME_SIZE+20*4)(sp), r3
@


1.27
log
@better copy and zero inlines in locore;
proper setregs() in machedep;
start of hpmc handler;
some cleanup here and there;
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.26 2000/01/12 05:55:56 mickey Exp $	*/
d150 1
a150 1
	 * spl level into eiem
d152 3
a154 2
	ldi	IPL_NONE, r1
	mtctl	r1, eiem
a208 7
	
	/*
	 * Initialize the external interrupt request register
	 */
	/* ldi    	-1,r1 */
	mtctl   r0,eirr

@


1.26
log
@spstrcopy: store copied size by dereffing 5th arg, not into it's place on stack
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.25 2000/01/12 04:44:14 mickey Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998,1999 Michael Shalayeff
d146 1
a146 1
	rsm	RESET_PSW,r0
d152 2
a153 2
	ldi	IPL_NONE,r1
	mtctl	r1,eiem
a161 1
	ldo	NBPG+TF_SIZE(arg3), t1
d163 1
d167 1
a167 1
	comb,<,n t2, t1, $start_zero_tf
d175 1
a175 1
	ldo	NBPG(arg3), sp
a186 1
	/* create a fake trapframe */
d188 2
a189 3
	stw	t1, TF_FLAGS(sp)
	/* accomodate the trapframe, once we created one */
	ldo	TF_SIZE(sp), sp
d209 1
a209 1
	/* 
d310 1
a310 1
	blr     r0, rp
d399 1
a399 1
	blr     r0, rp
d457 1
a457 1
	gate,n	$bsd_syscall,r0         /* @@ 0.C0000004 (HPUX/BSD) */
d492 1
a492 1
	 * set up a space register and a protection id so that 
d495 2
d515 1
a515 1
$trap_tmp_save
d517 1
d519 1
a519 2
	.import	syscall,code
        .export $syscall,entry
d530 5
d542 25
a566 23
	ldo	NBPG(t2), t2	
	ldo	TF_SIZE(t2), sp
	stw	t1, TF_R22 (sr1, t2)
	stw	t4, TF_R30 (sr1, t2)

	stw	r2 , TF_R2 (sr1, t2)
	stw	r3 , TF_R3 (sr1, t2)
	stw	r4 , TF_R4 (sr1, t2)
	stw	r5 , TF_R5 (sr1, t2)
	stw	r6 , TF_R6 (sr1, t2)
	stw	r7 , TF_R7 (sr1, t2)
	stw	r8 , TF_R8 (sr1, t2)
	stw	r9 , TF_R9 (sr1, t2)
	stw	r10, TF_R10(sr1, t2)
	stw	r11, TF_R11(sr1, t2)
	stw	r12, TF_R12(sr1, t2)
	stw	r13, TF_R13(sr1, t2)
	stw	r14, TF_R14(sr1, t2)
	stw	r15, TF_R15(sr1, t2)
	stw	r16, TF_R16(sr1, t2)
	stw	r17, TF_R17(sr1, t2)
	stw	r18, TF_R18(sr1, t2)
	stw	r27, TF_R27(sr1, t2)	/* dp */
a568 3
	ldo	0(sp), t3
	ldo	HPPA_FRAME_SIZE+HPPA_FRAME_MAXARGS(sp), sp
	copy	t3, r1
d594 3
a596 3
	ldo	-4(r31), arg1
	stw	r31, TF_IIOQH(sr1, t2)
	stw	arg1, TF_IIOQT(sr1, t2)
d599 2
a600 3
	mfsp	sr0, arg1
	stw	arg0, TF_IISQH(sr1, t2)
	stw	arg1, TF_IISQT(sr1, t2)
d602 2
a603 4
	mfctl	eiem, arg0
	mfctl	ipsw, arg1
	stw	arg0, TF_CR15(sr1, t2)
	stw	arg1, TF_CR22(sr1, t2)
d606 2
a607 3
	copy	r28, arg1
	stw	arg0, TF_SR3(sr1, t2)
	stw	arg1, TF_CR8(sr1, t2)
d609 4
a612 8
	mfctl	isr, arg0
	mfctl	ior, arg1
	stw	arg0, TF_CR20(sr1, t2)
	stw	arg1, TF_CR21(sr1, t2)

	mfctl	iir, arg0
	stw	arg0, TF_CR19(sr1, t2)
	stw	arg1, TF_FLAGS(sr1, t2)
d618 4
a621 4
	stw	arg0, TF_SR0(sr1, t2)
	stw	arg1, TF_SR1(sr1, t2)
	stw	arg2, TF_SR2(sr1, t2)
	stw	arg3, TF_SR4(sr1, t2)
d627 4
a630 4
	stw	arg0, TF_SR5(sr1, t2)
	stw	arg1, TF_SR6(sr1, t2)
	stw	arg2, TF_SR7(sr1, t2)
	stw	arg3, TF_CR9 (sr1, t2)
d632 1
d635 3
a637 2
	stw	arg2, TF_CR12(sr1, t2)
	stw	arg3, TF_CR13(sr1, t2)
d645 2
a646 2
	stw	arg0, TF_CR23(sr1, t2)
	stw	arg1, TF_CR24(sr1, t2)
d650 2
a651 2
	stw	arg0, TF_CR25(sr1, t2)
	stw	arg1, TF_CR28(sr1, t2)
d668 2
a669 2
	copy	t2, arg0
	copy	r1, arg1
d675 1
d698 3
d702 4
a705 1
	 * Copy partially saved state from the store into the frame
a706 1
	ldi	$trap_tmp_save, arg1
d708 2
a709 1
	ldo	TF_PHYS(arg0), arg2
d711 3
a713 7
	ldw	0(arg0), t1
	ldw	4(arg0), t2
	stw	t1, 0(arg1)
	stw	t2, 4(arg1)
	ldo	8(arg0), arg0
	comb,<,n arg0, arg2, $syscall_return_copy_loop
	ldo	8(arg1), arg1
d715 1
a715 1
	/* 1. restore most of the general registers */
d760 1
a760 1
       
d765 1
a765 1
       
d787 1
a787 1
	nop ! nop ! nop ! nop ! nop ! nop ! nop ! nop
d790 1
a790 1
	ldi	$trap_tmp_save, t3
d862 1
d866 1
d869 2
a870 1
	CTRAP(hpmc,T_HPMC,)		/*  1. high priority machine check */
d942 16
a957 1
	break	0, 0
d1166 1
a1166 1
	zdep	r8, 26, 16, r24	     	/* r24 = (space << 5) */	! \
d1195 2
a1196 2
	ldw     pv_va(r24), r25
	ldw     pv_space(r24), r17
d1252 2
a1253 2
	ldw     pv_va(r24),r25
	ldw     pv_space(r24),r17
d1401 1
a1401 1
	ldi	$trap_tmp_save, t3	/* we know it's in the low mem XXX */
d1575 1
d1577 1
a1577 1
	ldi	$trap_tmp_save, arg0
d1579 1
a1579 1
	ldo	TF_PHYS(arg0), arg2
d1581 3
a1583 7
	ldw	0(arg0), t1
	ldw	4(arg0), t2
	ldo	8(arg0), arg0
	stw	t1, 0(arg1)
	stw	t2, 4(arg1)
	comb,<,n arg0, arg2, $trap_copy_loop
	ldo	8(arg1), arg1
d1929 1
a1929 1
	ldo     R%panic(r1), r1
d1932 1
a1932 1
	blr     %r0, rp
d2017 1
a2017 1
	ldo     R%panic(r1), r1
d2020 1
a2020 1
	blr     %r0, rp
a2144 7
	ldil	L%proc0, t2
	ldo	R%proc0(t2), t2

	ldw	p_md(t2), t1
	ldw	TF_CR30(t1), t1
	mtctl	t1, cr30

a2154 1
	/* leave pidr2 in user space so copy* work */
d2156 3
a2158 1
	mtctl	t4, pidr1
a2164 1
	/* XXX load curproc here? */
d2168 1
a2168 1
	blr     %r0, rp
@


1.25
log
@fix {f,s}uword address check, align end of setrunqueue
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.24 2000/01/11 20:27:57 mickey Exp $	*/
d1773 1
d1785 3
a1787 3
	ldw	HPPA_FRAME_ARG(4)(sp), t1
	mtsp	ret0, sr2
	sub	ret1, t1, ret1
d1789 1
a1789 1
	stw	ret1, HPPA_FRAME_ARG(5)(sp)
@


1.24
log
@s/fpu_curproc/fpu_curpcb/ which also points into physical.
move it's definition into locore (where it's used the most).
adjust fpu context switch and save on swapout accordingly.
fix context save (in switch).
add accounting for fpu context switches (since it differes
from proc switching, we might get provided w/ some usefull
numbers as to how effective this lazy switch technique is).
enable handling fpu/sfu exceptions.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.23 1999/12/31 09:07:10 mickey Exp $	*/
d319 1
a319 1
EXIT(__start)
d1706 1
a1706 1
	comb,>=	arg0, t1, fusubadaddr		! \
d1708 1
d1711 1
a1712 1
	ldo	R%fusufault(t2), t2		! \
d1720 2
a1721 1
	b,n	fusuexit			! \
d1727 2
a1728 1
	b,n	fusuexit			! \
d1731 1
a1731 3
ENTRY(fusuexit)
	bv	r0(rp)	/* execute stw in a delay slot */
ALTENTRY(fusufault)
d1889 1
@


1.23
log
@don't bother about pidr3 and pidr4
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.22 1999/12/12 03:31:23 mickey Exp $	*/
a88 1
	.import	fpu_curproc, data
d103 6
a707 1
	ldo	8(arg0), arg0
d710 1
d879 1
a879 1
#ifdef FPEMUL_notyet
d960 2
a961 2
	ldil	L%fpu_curproc, t1
	ldw	R%fpu_curproc(t1), t1
d964 2
a965 4

	ldil	L%curproc, t2
	ldw	R%curproc(t2), t2

d973 1
a973 2
	ldw	p_addr(t1), t3
	ldo	pcb_fpregs+u_pcb(t3), t3
d1006 1
a1006 1
	fstds    fr31, 8(t3)
d1010 7
a1016 2
	ldw	p_addr(t2), t3
	ldo	31*8+pcb_fpregs+u_pcb(t3), t3
d1051 2
a1052 2
	ldil	L%fpu_curproc, t1
	stw	t2, R%fpu_curproc(t1)
d1061 1
a1061 1
#ifdef notyet
d1072 1
a1072 1
	.import	$fpemu_stack
d1103 1
a1135 1
#endif
d1139 1
d1141 2
a1142 2
	rfi
	nop
@


1.22
log
@they say that cr 24-31 are for interrupt handlers use, so pdc may mangle those
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.21 1999/11/25 18:47:45 mickey Exp $	*/
d251 4
a254 2
	mtctl	r1, pidr3
	mtctl	r1, pidr4
a660 7
#ifdef notdef
	/* leave pidr2 in user space so copy* work */
	ldi	HPPA_PID_KERNEL, t4
	mtctl	t4, pidr3
	mtctl	t4, pidr4
#endif

d765 1
d770 1
a770 1

d1497 1
d1502 1
a2137 2
	mtctl	t4, pidr3
	mtctl	t4, pidr4
@


1.21
log
@convey and convex it traps on both ways, and a little syscalls in between
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.20 1999/09/20 21:40:53 mickey Exp $	*/
d335 1
a335 1
	ldo	HPPA_FRAME_SIZE+16*4(ret1), ret1
d359 18
d387 2
a388 2
	stw	t1, HPPA_FRAME_ARG(12)(ret1)
	stw	ret0, HPPA_FRAME_ARG(13)(ret1)
d398 18
d425 2
a426 2
	ldw	HPPA_FRAME_ARG(12)(t4), t1
	ldw	HPPA_FRAME_ARG(13)(t4), arg0
d1808 1
a1809 1
	add	1, t1, t1
@


1.20
log
@fix for new frame.h
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.19 1999/08/14 03:11:31 mickey Exp $	*/
d17 1
a17 1
 *	This product includes software developed by Michael Shalayeff.
d24 8
a31 7
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d34 1
a34 1
 * the copyrights and acknowledgements.
d65 1
d91 1
d94 1
a94 1
	.import	intr_recurse, data
d99 5
a103 16
	.export	proc0stack, data
	.export	proc0stack_end, data
proc0stack
	.block	4*NBPG
proc0stack_end

	.export	intr_stack, data
	.export	intr_stack_end, data
	.export	intr_stack_red, data
intr_stack
	.block	5*NBPG
intr_stack_end
	.block	2*NBPG
intr_stack_red
	.block	1*NBPG

d133 4
d156 9
d166 2
a167 1
	 * kernel stack lives here (arg3 is esym)
d170 7
a176 2
	ldil	L%proc0stack, t2
	ldo	R%proc0stack(t2), sp
a177 1
	ldo	NBPG(arg3), arg0
d182 6
d192 5
a196 5
	mtctl	r0,pcsq
	mtctl	r0,pcsq
	ldil	L%$qisnowon,t1
	ldo	R%$qisnowon(t1),t1
	mtctl	t1,pcoq	
d198 3
a200 3
	mtctl	t1,pcoq	
	ldi	PSW_Q|PSW_I,t1
	mtctl	t1,ipsw
d248 13
a260 13
	ldi	HPPA_PID_KERNEL,r1
	mtctl	r1,pidr1
	mtctl	r1,pidr2
	mtctl	r1,pidr3
	mtctl	r1,pidr4
	mtsp	r0,sr0
	mtsp	r0,sr1
	mtsp	r0,sr2
	mtsp	r0,sr3
	mtsp	r0,sr4
	mtsp	r0,sr5
	mtsp	r0,sr6
	mtsp	r0,sr7
d265 1
a265 1
	rsm	RESET_PSW,r0
d270 10
a279 10
	mtctl	r0,pcsq
	mtctl	r0,pcsq
	ldil	L%$virtual_mode,t1
	ldo	R%$virtual_mode(t1),t1
	mtctl	t1,pcoq	
	ldo	4(t1),t1
	mtctl	t1,pcoq	
	ldil	L%KERNEL_PSW,t1
	ldo	R%KERNEL_PSW(t1),t1
	mtctl	t1,ipsw
d284 2
d287 1
a287 1
#ifdef DDB_DDB
d291 3
a293 2
	ldo	R%boothowto(r1), r1
	bb,>=,n	r1,25,$noddb
d295 1
a295 5
	ldil	L%Debugger, r1
	ldo	R%Debugger(r1), r1
	.call
	blr     r0,rp
	bv,n    (r1)
d303 1
d310 2
a311 1
	bv,n	(rp)
d314 89
d442 3
a444 3
	stw	r22,HPPA_FRAME_ARG(4)(sp)
	stw	r21,HPPA_FRAME_ARG(5)(sp)
	stw	r29,HPPA_FRAME_SL(sp)
d446 1
a446 1
	copy	r1,r22
d455 3
a457 3
	mfctl	pidr2, r28
	ldi	HPPA_PID_KERNEL, r1
	mtctl	r1, pidr2
d465 1
a465 1
	be,n    R%$syscall(sr1,r1)
d468 1
d472 3
d488 3
a490 3
	ldil	L%curproc, t1
	ldw	R%curproc(sr1, t1), t1
	ldw	p_addr(sr1, t1), t2
d492 1
a492 2
	/* save sp first */
	stw	sp, TF_R30+pcb_tf+u_pcb(sr1, t2)
d494 48
d543 22
a564 2
	/* calculate kernel sp, load, create kernel stack frame */
	ldo	HPPA_FRAME_SIZE+HPPA_FRAME_MAXARGS+NBPG(t2), sp
d566 4
a569 20
	stw	r1 , TF_R1 +pcb_tf+u_pcb(sr1, t2)
	stw	r2 , TF_R2 +pcb_tf+u_pcb(sr1, t2)
	stw	r3 , TF_R3 +pcb_tf+u_pcb(sr1, t2)
	stw	r4 , TF_R4 +pcb_tf+u_pcb(sr1, t2)
	stw	r5 , TF_R5 +pcb_tf+u_pcb(sr1, t2)
	stw	r6 , TF_R6 +pcb_tf+u_pcb(sr1, t2)
	stw	r7 , TF_R7 +pcb_tf+u_pcb(sr1, t2)
	stw	r8 , TF_R8 +pcb_tf+u_pcb(sr1, t2)
	stw	r9 , TF_R9 +pcb_tf+u_pcb(sr1, t2)
	stw	r10, TF_R10+pcb_tf+u_pcb(sr1, t2)
	stw	r11, TF_R11+pcb_tf+u_pcb(sr1, t2)
	stw	r12, TF_R12+pcb_tf+u_pcb(sr1, t2)
	stw	r13, TF_R13+pcb_tf+u_pcb(sr1, t2)
	stw	r14, TF_R14+pcb_tf+u_pcb(sr1, t2)
	stw	r15, TF_R15+pcb_tf+u_pcb(sr1, t2)
	stw	r16, TF_R16+pcb_tf+u_pcb(sr1, t2)
	stw	r17, TF_R17+pcb_tf+u_pcb(sr1, t2)
	stw	r18, TF_R18+pcb_tf+u_pcb(sr1, t2)
	stw	r27, TF_R27+pcb_tf+u_pcb(sr1, t2)	/* dp */
	stw	r28, TF_CR8+pcb_tf+u_pcb(sr1, t2)	/* saved pidr2 */
d571 41
a611 22
	/* copy arguments */
	copy	t3, r1
	stwm	arg0, 4(sr1, t3)
	stwm	arg1, 4(sr1, t3)
	stwm	arg2, 4(sr1, t3)
	stwm	arg3, 4(sr1, t3)
	ldw	HPPA_FRAME_ARG( 4)(sr0, t4), arg0
	ldw	HPPA_FRAME_ARG( 5)(sr0, t4), arg1
	ldw	HPPA_FRAME_ARG( 6)(sr0, t4), arg2
	ldw	HPPA_FRAME_ARG( 7)(sr0, t4), arg3
	stwm	arg0, 4(sr1, t3)
	stwm	arg1, 4(sr1, t3)
	stwm	arg2, 4(sr1, t3)
	stwm	arg3, 4(sr1, t3)
	ldw	HPPA_FRAME_ARG( 8)(sr0, t4), arg0
	ldw	HPPA_FRAME_ARG( 9)(sr0, t4), arg1
	ldw	HPPA_FRAME_ARG(10)(sr0, t4), arg2
	ldw	HPPA_FRAME_ARG(11)(sr0, t4), arg3
	stwm	arg0, 4(sr1, t3)
	stwm	arg1, 4(sr1, t3)
	stwm	arg2, 4(sr1, t3)
	stwm	arg3, 4(sr1, t3)
d614 8
a621 8
	mtctl	r0, sr0
	mtctl	r0, sr1
	mtctl	r0, sr2
	mtctl	r0, sr3
	mtctl	r0, sr4
	mtctl	r0, sr5
	mtctl	r0, sr6
	mtctl	r0, sr7
d623 2
a624 1
	/* leave pidr4 in user space so copy* work */
a625 1
	mtctl	t4, pidr1
d627 2
d631 2
a632 2
	stw	r0, HPPA_FRAME_PSP(sr1, sp)
	stw	r0, HPPA_FRAME_CRP(sr1, sp)
d634 1
a634 1
	ldo	pcb_tf+u_pcb(t2), arg0
d641 2
a642 2
	ldil	L%syscall, ret0
	ldo	R%syscall(ret0), ret0
d645 6
a650 1
	bv,n	0(ret0)
d653 2
a654 1
/* fall through */
d660 1
d662 1
d664 1
a664 2
	 * t1:	curproc
	 * t2:	user
d666 52
a717 3
	ldil	L%curproc, t1
	ldw	R%curproc(t1), t1
	ldw	p_addr(t1), t4
d719 13
a731 24
	/* restore state */
	ldw	TF_R1 +pcb_tf+u_pcb(t4), r1
	ldw	TF_R2 +pcb_tf+u_pcb(t4), r2
	ldw	TF_R3 +pcb_tf+u_pcb(t4), r3
	ldw	TF_R4 +pcb_tf+u_pcb(t4), r4
	ldw	TF_R5 +pcb_tf+u_pcb(t4), r5
	ldw	TF_R6 +pcb_tf+u_pcb(t4), r6
	ldw	TF_R7 +pcb_tf+u_pcb(t4), r7
	ldw	TF_R8 +pcb_tf+u_pcb(t4), r8
	ldw	TF_R9 +pcb_tf+u_pcb(t4), r9
	ldw	TF_R10+pcb_tf+u_pcb(t4), r10
	ldw	TF_R11+pcb_tf+u_pcb(t4), r11
	ldw	TF_R12+pcb_tf+u_pcb(t4), r12
	ldw	TF_R13+pcb_tf+u_pcb(t4), r13
	ldw	TF_R14+pcb_tf+u_pcb(t4), r14
	ldw	TF_R15+pcb_tf+u_pcb(t4), r15
	ldw	TF_R16+pcb_tf+u_pcb(t4), r16
	ldw	TF_R17+pcb_tf+u_pcb(t4), r17
	ldw	TF_R18+pcb_tf+u_pcb(t4), r18

	ldw	TF_CR8+pcb_tf(sr1,t4), t1
	ldw	TF_CR9+pcb_tf(sr1,t4), t2
	ldw	TF_CR12+pcb_tf(sr1,t4), t3
	mtctl	t1, pidr1
a732 8
	mtctl	t3, pidr3
	ldw	pcb_space+u_pcb(t4), t3
	mtctl	t3, sr0
	mtctl	t3, sr2
	mtctl	t3, sr3
	mtctl	t3, sr4
	mtctl	t3, sr5
	mtctl	t3, sr6
d734 45
a778 3
	ldw	TF_CR13+pcb_tf(sr1,t4), t4
	bv	0(rp)
	mtctl	t4, pidr4
d780 2
a783 1

a784 1
	.align NBPG
d818 1
a818 1
	depi	0,31,12,r9	/* align offset to page */
d822 1
a822 1
	depi    0,31,12,r9	/* align offset to page */	! \
d865 33
a897 3
					/* 32 */
	.align	32*32

d1100 1
d1102 1
a1102 1
	ldo	1(r0), ret0	/* none supported by now */
d1157 1
a1157 1
	depi	1, 0, 1, r1	/* mark for ITLB insert */
d1222 1
a1222 1
	bb,<	r1, 0, $tlb_itlb
d1281 5
d1287 1
d1316 3
a1318 2
	mtctl	sp, tr2	/* do not overwrite tr4(cr28) */
	mtctl	t1, tr3
d1321 16
a1336 18
	ldil	L%intr_recurse, t1
	ldw	R%intr_recurse(t1), t3
	ldo	1(t3), t3
	comib,<> 1, t3, $trap_recurse
	stw	t3, R%intr_recurse(t1)

	ldil	L%intr_stack, sp
	ldo	R%intr_stack(sp), sp

$trap_recurse
	copy	sp, t3
	ldo	HPPA_FRAME_SIZE+TF_SIZE(sp), sp

	/* t3 is (struct trapframe *) */
$trap_trap
	stw	arg0, TF_R26(t3)
	copy	r1, arg0
	mfctl	tr7, r1
d1338 5
d1344 2
a1345 1
	stw	t1, TF_R30(t3)
d1348 2
a1349 5
	stw	t1, TF_R20(t3) /* t3 */
	stw	t2, TF_R21(t3)

	mfctl	tr3, t1
	stw	t1, TF_R22(t3)
a1356 6
	mfctl	pcoq, t1
	mtctl	r0, pcoq
	mfctl	pcoq, t2
	stw	t1, TF_IIOQH(t3)
	stw	t2, TF_IIOQT(t3)

d1362 1
d1364 5
a1368 4
	mfctl	ior, t1
	mfctl	ipsw, t2
	stw	t1, TF_CR21(t3)
	stw	t2, TF_CR22(t3)
d1371 1
d1373 1
d1375 14
a1388 4
	mfctl	iir, t1
	mfctl	isr, t2
	stw	t1, TF_CR19(t3)
	stw	t2, TF_CR20(t3)
d1391 1
a1391 3
	 * Now we're about to turn on the PC queue.  We'll also go to virtual
	 * mode in the same step. Save the space registers sr4 - sr7 and
	 * point them to the kernel space
a1393 32
	mfsp	sr4, t1
	mfsp	sr5, t2
	stw	t1, TF_SR4(t3)
	stw	t2, TF_SR5(t3)

	mfsp	sr6, t1
	mfsp	sr7, t2
	stw	t1, TF_SR6(t3)
	stw	t2, TF_SR7(t3)

	/* XXX HPPA_SID_KERNEL == 0 */
	mtsp	r0, sr4
	mtsp	r0, sr5
	mtsp	r0, sr6
	mtsp	r0, sr7

	/*
	 * save the protection ID registers. We will keep the last one
	 * with the protection of the user's area and set the remaining
	 * ones to be the kernel.
	 */

	mfctl	pidr1, t1
	mfctl	pidr2, t2
	stw	t1, TF_CR8(t3)
	stw	t2, TF_CR9(t3)

	mfctl	pidr3, t1
	mfctl	pidr4, t2
	stw	t1, TF_CR12(t3)
	stw	t2, TF_CR13(t3)

d1395 2
a1396 3
	mtctl	t1,pidr1
	mtctl	t1,pidr2
	mtctl	t1,pidr3
d1402 5
a1406 15
	/*
	 * set the new psw to be data and code translation, interrupts
	 * disabled, protection enabled, Q bit on
	 */

	ldil	L%KERNEL_PSW, t1
	ldo	R%KERNEL_PSW(t1), t1
	mtctl	t1, ipsw

	/*
	 * Load up a real value into eiem to reflect an spl level of splhigh.
	 * Right now interrupts are still off.
	 */
	ldi	IPL_NONE, t1
	mtctl	t1, eiem
d1412 4
a1415 1
	/* load the offset queue */
d1423 2
d1426 2
d1433 2
a1434 3
	 * t3 contains the virtual address of the saved status area
	 * t1 contains the trap flags
	 * sp contains the virtual address of the stack pointer
a1435 5
#if 0
	ldil	L%curproc, t1
	ldw	R%curproc(t1), t3
	comb,=	r0, t3, $trap_recurse
	nop
d1437 32
a1468 5
	ldo	HPPA_FRAME_SIZE(sp), sp
	b	$trap_trap
	ldo	p_md(t3), t3
#endif
	stw	t1, TF_FLAGS(t3) /* XXX not really */
d1474 2
d1479 2
a1480 2
	stw	rp,HPPA_FRAME_CRP(sp)
	stw	r3,HPPA_FRAME_PSP(sp)
d1499 3
a1501 3
	/*	r20 already saved
	 *	r21 already saved
	 *	r22 already saved */
d1505 1
a1505 1
	/*	r26 already saved */
d1509 1
a1509 1
 	/*	r30 already saved */
d1513 1
a1513 1
	 * Save the space registers.
d1515 11
a1525 10

	mfsp	sr0, t1
	mfsp	sr1, t2
	stw	t1, TF_SR0(t3)
	stw	t2, TF_SR1(t3)

	mfsp	sr2, t1
	mfsp	sr3, t2
	stw	t1, TF_SR2(t3)
	stw	t2, TF_SR3(t3)
d1533 2
a1534 4

	mfctl	sar, t1
	stw	t1, TF_CR11(t3)

d1549 2
d1556 2
a1557 2
	ldil	L%$global$,dp
	ldo	R%$global$(dp),dp
d1561 1
a1561 1
	 * Trap type (arg0) was setup back in the beginning of the handler
d1563 2
d1578 7
a1584 2
#if 0
	/* see if context really changed */
d1587 1
a1587 1
	comb,=	t2, r0, $curproc_zero
d1590 3
a1592 9
	ldo	p_md(t2), t3	
$curproc_zero
#else
	copy	r5, t3
#endif
	/*
	 * Restore most of the state, up to the point where we need to turn
	 * off the PC queue. Going backwards, starting with control regs.
	 */
a1593 130
	ldw	TF_CR0(t3), t1
	ldw	TF_CR15(t3), t2
	mtctl	t1, rctr
	mtctl	t2, eiem

	ldw	TF_CR11(t3),t1
	mtctl	t1,sar

	ldw	TF_CR8(t3),t1
	mtctl	t1,pidr1


	/*
	 * Restore the lower space registers, we'll restore sr4 - sr7 after
	 * we have turned off translations
	 */

	ldw	TF_SR0(t3), t1
	ldw	TF_SR1(t3), t2
	mtsp	t1, sr0
	mtsp	t2, sr1

	ldw	TF_SR2(t3), t1
	ldw	TF_SR3(t3), t2
	mtsp	t1, sr2
	mtsp	t2, sr3

	/*
	 * restore most of the general registers
	 */

	ldw	TF_R1(t3),r1
	ldw	TF_R2(t3),r2
	ldw	TF_R3(t3),r3
	ldw	TF_R4(t3),r4
	ldw	TF_R5(t3),r5
	ldw	TF_R6(t3),r6
	ldw	TF_R7(t3),r7
	ldw	TF_R8(t3),r8
	ldw	TF_R9(t3),r9
	ldw	TF_R10(t3),r10
	ldw	TF_R11(t3),r11
	ldw	TF_R12(t3),r12
	ldw	TF_R13(t3),r13
	ldw	TF_R14(t3),r14
	ldw	TF_R15(t3),r15
	ldw	TF_R16(t3),r16
	ldw	TF_R17(t3),r17
	ldw	TF_R18(t3),r18
	ldw	TF_R19(t3),r19
	/*	r20(t3) is used as a temporary and will be restored later */
	/*	r21(t3) is used as a temporary and will be restored later */
	/*	r22(t3) is used as a temporary and will be restored later */
	ldw	TF_R23(t3),r23
	ldw	TF_R24(t3),r24
	ldw	TF_R25(t3),r25
	ldw	TF_R26(t3),r26
	ldw	TF_R27(t3),r27
	ldw	TF_R28(t3),r28
	ldw	TF_R29(t3),r29
	/*	r30 (sp) will be restored later */
	ldw	TF_R31(t3),r31

	/*
	 * clear the system mask, this puts us back into physical mode.
	 *
	 * N.B: Better not be any code translation traps from this point
	 * on. Of course, we know this routine could never be *that* big.
	 */
	rsm	RESET_PSW,r0

	/*
	 * restore the protection ID registers
	 */

	ldw	TF_CR8(t3),t1
	mtctl	t1,pidr1

	ldw	TF_CR9(t3),t1
	mtctl	t1,pidr2

	ldw	TF_CR12(t3),t1
	mtctl	t1,pidr3

	/*
	 * restore the space registers
	 */

	ldw	TF_SR4(t3),t1
	ldw	TF_SR5(t3),t2
	mtsp	t1,sr4
	mtsp	t2,sr5

	ldw	TF_SR6(t3), t1
	ldw	TF_SR7(t3), t2
	mtsp	t1, sr6
	mtsp	t2, sr7

	/*
	 * finally we can restore the space and offset queues and the ipsw
	 */

	ldw	TF_IISQH(t3), t1
	ldw	TF_IISQT(t3), t2
	mtctl	t1, pcsq
	mtctl	t2, pcsq

	ldw	TF_IIOQH(t3), t1
	ldw	TF_IIOQT(t3), t2
	mtctl	t1, pcoq
	mtctl	t2, pcoq

	ldw	TF_CR22(t3), t1
	mtctl	t1, ipsw

	/*
	 * restore the last registers,r30, r22, and finally r21(t2)
	 * decrement interrupt recursion level
	 */
	ldil	L%intr_recurse, t1
	ldw	R%intr_recurse(t1), t2
	addi	-1, t2, t2
	stw	t2, R%intr_recurse(t1)
	ldw	TF_R22(t3),t1
	ldw	TF_R21(t3),t2
	ldw	TF_R30(t3),sp
	ldw	TF_R20(t3),t3

	rfi
	nop
d1726 3
a1728 3
	mfctl	sr2, ret0	/* XXX need this? */
	mtctl	arg0, sr1
	mtctl	arg2, sr2
d1742 1
a1742 1
	mtctl	ret0, sr2
d1905 1
a1905 1
	ldw	R%curproc(t1), t2
d1907 1
d1970 1
a1991 1
	stw	r0, p_back(arg1)
d1995 1
a1995 1
	comb,=,n arg1, t2, switch_return
d1998 1
a1998 1
	comb,=,n r0, t2, switch_exited
d2003 1
a2003 4
	 * t2: old proc
	 *
	 * nothing to save, everything needed to be done is already
	 * done on enter, wonderfull.
d2005 26
d2032 1
a2032 1
	/* don't need old curproc(t2) starting from here */
a2037 1
	 * arg2: new pcb
d2039 28
a2066 5

	ldw	p_addr(arg1), arg2
	/* only pidr needs restoring, so we can access user space */
	ldw	TF_CR13+pcb_tf+u_pcb(arg2), t1
	mtctl	t1, pidr4
d2087 4
d2101 1
a2101 1
	/* leave pidr4 in user space so copy* work */
a2103 1
	mtctl	t4, pidr2
d2105 1
d2113 10
a2122 2
	bv	0(arg0)
	copy	arg1, arg0
a2129 1
ALTENTRY(esigcode)
d2132 1
a2137 1
ALTENTRY(linux_esigcode)
d2141 2
a2142 1
EXIT(linix_esigcode)
@


1.19
log
@rework interruptions framewrok a little to use that space in the IV table.
cpu_switch, setrunqueu, remrunqueu now tested and seem working.
trapall needs some more work for user mode.
optimizations here and there.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.18 1999/08/03 15:48:18 mickey Exp $	*/
d70 1
d151 1
a151 1
	ldi	INT_NONE,r1
d208 1
a208 1
	stwm	r0, FM_SIZE(sp)
d210 1
a210 1
	stwm	t1, FM_SIZE(sp)
d336 3
a338 3
	stw	r22,VA_ARG4(sp)
	stw	r21,VA_ARG5(sp)
	stw	r29,FM_SL(sp)
d387 1
a387 1
	ldo	FM_SIZE+ARG_SIZE+NBPG(t2), sp
d416 4
a419 4
	ldw	VA_ARG4(sr0, t4), arg0
	ldw	VA_ARG5(sr0, t4), arg1
	ldw	VA_ARG6(sr0, t4), arg2
	ldw	VA_ARG7(sr0, t4), arg3
d424 4
a427 4
	ldw	VA_ARG8 (sr0, t4), arg0
	ldw	VA_ARG9 (sr0, t4), arg1
	ldw	VA_ARG10(sr0, t4), arg2
	ldw	VA_ARG11(sr0, t4), arg3
d449 2
a450 2
	stw	r0, FM_PSP(sr1, sp)
	stw	r0, FM_CRP(sr1, sp)
d745 1
a745 1
	ldo	R%TF_SIZE+FM_SIZE(r31), sp
d1033 1
a1033 1
	ldo	FM_SIZE+TF_SIZE(sp), sp
d1142 1
a1142 1
	ldi	INT_NONE, t1
d1173 1
a1173 1
	ldo	FM_SIZE(sp), sp
d1186 2
a1187 2
	stw	rp,FM_CRP(sp)
	stw	r3,FM_PSP(sp)
d1272 1
a1272 1
	ldo	-FM_SIZE(sp), r3
d1560 1
a1560 1
	ldw	VA_ARG4(sp), ret1
d1576 1
a1576 1
	ldw	VA_ARG4(sp), t1
d1580 1
a1580 1
	stw	ret1, VA_ARG5(sp)
@


1.18
log
@straitify tlbmissers a little more; fix stack mangling for trapall
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.17 1999/07/21 07:37:19 mickey Exp $	*/
d122 1
a123 1
 *	esym - end of symbol table (or &end if not present)
d451 1
a451 1
	addi	pcb_tf+u_pcb, t2, arg0
d500 6
a505 1
	ldw	TF_CR8+pcb_tf(sr1,t4), t2
a506 3
	mtctl	t2, pidr1
	mtctl	t2, pidr3
	mtctl	t2, pidr4
d514 1
a514 1
	ldw	TF_CR9+pcb_tf(sr1,t4), t4
d516 1
a516 1
	mtctl	t4, pidr2
d528 2
a529 2
#define TRAP(reason) \
	.import TLABEL(all), code	! \
d531 1
a531 1
	ldil	L%TLABEL(all), r1	! \
d533 3
a535 2
	be	R%TLABEL(all)(sr4, r1)	! \
	ldi	reason, r1
d537 10
a546 6
	/* 8 bytes per entry */
#define	ATRAP(name, reason) \
	.export	TLABEL(name), entry	! \
	.label	TLABEL(name)		! \
	TRAP(reason)			! \
	nop ! .word 0, 0, 0
d548 14
a561 8
#define	CTRAP(name, reason) \
	.import	TLABEL(name), code	! \
	mtctl	r1, tr7			! \
	ldil	L%TLABEL(name), r1	! \
	.call				! \
	be	R%TLABEL(name)(sr4, r1)	! \
	ldi	reason, r1		! \
	nop ! .word 0, 0, 0
d566 14
a579 14
	ATRAP(nexist,T_NONEXIST)/*  0. invalid interrupt vector */
	CTRAP(hpmc,T_HPMC)	/*  1. high priority machine check */
	ATRAP(power,T_POWERFAIL)/*  2. power failure */
	ATRAP(recnt,T_RECOVERY)	/*  3. recovery counter trap */
	ATRAP(int,T_INTERRUPT)	/*  4. external interrupt */
	ATRAP(lpmc,T_LPMC)	/*  5. low-priority machine check */
	CTRAP(itlb,T_ITLBMISS)	/*  6. instruction TLB miss fault */
	ATRAP(iprot,T_IPROT)	/*  7. instruction protection trap */
	ATRAP(illegal,T_ILLEGAL)/*  8. Illegal instruction trap */
	CTRAP(ibreak,T_IBREAK)	/*  9. break instruction trap */
	ATRAP(privop,T_PRIV_OP)	/* 10. privileged operation trap */
	ATRAP(privr,T_PRIV_REG)	/* 11. privileged register trap */
	ATRAP(ovrfl,T_OVERFLOW)	/* 12. overflow trap */
	ATRAP(cond,T_CONDITION)	/* 13. conditional trap */
d581 1
a581 1
	CTRAP(excpt,T_EXCEPTION)/* 14. assist exception trap */
d583 1
a583 1
	ATRAP(excpt,T_EXCEPTION)/* 14. assist exception trap */
d585 15
a599 20
	CTRAP(dtlb,T_DTLBMISS)	/* 15. data TLB miss fault */
	CTRAP(itlb,T_ITLBMISS)	/* 16. ITLB non-access miss fault */
	CTRAP(dtlb,T_DTLBMISS)	/* 17. DTLB non-access miss fault */
	ATRAP(dprot,T_DPROT)	/* 18. data protection trap
				       unalligned data reference trap */
	ATRAP(dbreak,T_DBREAK)	/* 19. data break trap */
	CTRAP(tlbd,T_TLB_DIRTY)	/* 20. TLB dirty bit trap */
	ATRAP(pageref,T_PAGEREF)/* 21. page reference trap */
	CTRAP(emu,T_EMULATION)	/* 22. assist emulation trap */
	ATRAP(hpl,T_HIGHERPL)	/* 23. higher-privelege transfer trap */
	ATRAP(lpl,T_LOWERPL)	/* 24. lower-privilege transfer trap */
	ATRAP(tknbr,T_TAKENBR)	/* 25. taken branch trap */
#ifdef HP7100_CPU
	ATRAP(datacc,T_DATACC)	/* 26. data access rights trap (T-chip) */
	ATRAP(datapid,T_DATAPID)/* 27. data protection ID trap (T-chip) */
#else
	ATRAP(unk26,26)
	ATRAP(unk27,27)
#endif
	ATRAP(datal,T_DATALIGN)	/* 28. unaligned data ref trap */
d603 1
a603 1
				/* 32 */
d609 1
a609 4
	copy	%r0, arg0
	b	boot
	addi,tr 0,r0,arg0		; Skip first instr at target.
	break	0,0
d629 1
a629 1
	mtctl	t3, tr4
d724 1
a724 1
	mfctl	tr4, t3
d739 1
a739 1
	mtctl	r31, tr4
d744 1
a744 2
	mtctl	sp, tr4
	ldo	R%TF_SIZE(r31), sp
a781 1
	mfctl	tr4, r31
d784 1
a784 1
	mtctl	r27, tr4
d796 1
d799 1
a799 1
	mfctl	tr4, ret0
d812 1
a812 1
#define	HPTENT ! \
d832 1
a832 7
	mfctl	ior, r9		/* Offset */
	mfctl	isr, r8		/* Space  */
	depi    0, 31, 12, r9	/* Clear the byte offset into the page */

#if USECR28
	mfctl	cr28, r24
#else
a860 4
	mfctl	pcoq,r9		/* Offset */
	mfctl	pcsq,r8		/* Space  */
	depi    0,31,12,r9	/* Clear the byte offset into the page */

a863 1
	b	$tlbmiss
d865 1
a866 1
	.align	32
a868 8
	mfctl	ior, r9		/* Offset */
	mfctl	isr, r8		/* Space  */
	depi    0,31,12,r9	/* Clear the byte offset into the page */

#if USECR28
	mfctl	cr28, r24
#endif
	/* FALL THROUGH */
d948 4
a951 8
	.export	TLABEL(ibreak), entry
TLABEL(ibreak)
	mtctl	t1, tr6
	mtctl	t2, tr5
	mtctl	t3, tr4
	mfctl	iir, t1
	extru	t1, 31, 5, t2
	comib,<>,n HPPA_BREAK_KERNEL, t2, $ibreak_bad
d953 4
a956 4
	/* If this was called by a user process then always pass it to trap() */
	mfctl	pcoq, t2
	extru,=	t2, 31, 2, r0
	b,n	$ibreak_bad
d960 7
a966 3
	ldil	L%etext, t3
	ldo	R%etext(t3), t3
	comb,>>=,n t2, t3, $ibreak_bad
d970 2
a971 2
	comib,=,n HPPA_BREAK_GET_PSW, t2, $ibreak_getpsw
	comib,=,n HPPA_BREAK_SET_PSW, t2, $ibreak_setpsw
d973 1
a973 1
$ibreak_bad
d975 1
a975 2
	mfctl	tr4, t3
	mfctl	tr5, t2
d977 1
a977 1
	mfctl	tr6, t1
d979 2
a980 2
$ibreak_getpsw
	b	$ibreak_exit
d983 1
a983 1
$ibreak_setpsw
d985 1
a985 1
	b	$ibreak_exit
d990 1
a990 1
$ibreak_exit
d997 2
a998 3
	mfctl	tr4, t3
	mfctl	tr5, t2
	mfctl	tr6, t1
d1013 1
a1013 1
	 *	r1, r8, r9, r16, r17, r24, r25 shadowed
d1017 3
a1019 3
	mtctl	sp, tr3	/* do not overwrite cr28 */
	mtctl	t1, tr5
	mtctl	t2, tr6
d1022 3
a1024 3
	ldw	R%intr_recurse(t1), t2
	addi	1, t2, t3
	comb,<>	r0, t2, $trap_recurse
a1029 10
	/* first level recursion always goes into pcb, if any */
	ldil	L%curproc, t1
	ldw	R%curproc(t1), t2
	comb,=	r0, t2, $trap_recurse
	nop

	ldo	FM_SIZE(sp), sp
	b	$trap_trap
	ldo	p_md(t2), t2

d1031 1
a1031 1
	copy	sp, t2
d1034 1
a1034 1
	/* t2 is (struct trapframe *) */
d1036 1
a1036 1
	stw	arg0,TF_R26(t2)
d1040 2
a1041 2
	mfctl	tr3,t1
	stw	t1,TF_R30(t2)
d1043 3
a1045 2
	mfctl	tr5,t1
	stw	t1,TF_R22(t2)
d1047 2
a1048 2
	mfctl	tr6,t1
	stw	t1,TF_R21(t2)
d1056 5
a1060 2
	mfctl	pcoq,t1
	stw	t1,TF_IIOQH(t2)
d1062 10
a1071 1
	mtctl	r0,pcoq
d1073 2
a1074 2
	mfctl	pcoq,t1
	stw	t1,TF_IIOQT(t2)
d1076 4
a1079 22
	mfctl	pcsq,t1
	stw	t1,TF_IISQH(t2)

	mtctl	r0,pcsq

	mfctl	pcsq,t1
	stw	t1,TF_IISQT(t2)

	mfctl	ipsw,t1
	stw	t1,TF_CR22(t2)

	mfctl	eiem,t1
	stw	t1,TF_CR15(t2)

	mfctl	ior,t1
	stw	t1,TF_CR21(t2)

	mfctl	isr,t1
	stw	t1,TF_CR20(t2)

	mfctl	iir,t1
	stw	t1,TF_CR19(t2)
d1087 15
a1101 16
	mfsp	sr4,t1
	stw	t1,TF_SR4(t2)

	mfsp	sr5,t1
	stw	t1,TF_SR5(t2)

	mfsp	sr6,t1
	stw	t1,TF_SR6(t2)

	mfsp	sr7,t1
	stw	t1,TF_SR7(t2)

	mtsp	r0,sr4
	mtsp	r0,sr5
	mtsp	r0,sr6
	mtsp	r0,sr7
d1109 9
a1117 8
	mfctl	pidr1,t1
	stw	t1,TF_CR8(t2)

	mfctl	pidr2,t1
	stw	t1,TF_CR9(t2)

	mfctl	pidr3,t1
	stw	t1,TF_CR12(t2)
d1125 2
a1126 2
	mtctl	r0,pcsq
	mtctl	r0,pcsq
d1133 3
a1135 3
	ldil	L%KERNEL_PSW,t1
	ldo	R%KERNEL_PSW(t1),t1
	mtctl	t1,ipsw
d1141 2
a1142 2
	ldi	INT_NONE,t1
	mtctl	t1,eiem
d1145 2
a1146 2
	ldil	L%$trapnowvirt,t1
	ldo	R%$trapnowvirt(t1),t1
d1149 3
a1151 3
	mtctl	t1,pcoq
	ldo	4(t1),t1
	mtctl	t1,pcoq
d1162 1
a1162 1
	 * t2 contains the virtual address of the saved status area
d1166 5
d1172 5
a1176 1
	stw	t1,TF_FLAGS(t2)
d1182 2
a1183 2
	stw	r1,TF_R1(t2)
	stw	r2,TF_R2(t2)
d1188 19
a1206 19
	stw	r3,TF_R3(t2)
	stw	r4,TF_R4(t2)
	stw	r5,TF_R5(t2)
	stw	r6,TF_R6(t2)
	stw	r7,TF_R7(t2)
	stw	r8,TF_R8(t2)
	stw	r9,TF_R9(t2)
	stw	r10,TF_R10(t2)
	stw	r11,TF_R11(t2)
	stw	r12,TF_R12(t2)
	stw	r13,TF_R13(t2)
	stw	r14,TF_R14(t2)
	stw	r15,TF_R15(t2)
	stw	r16,TF_R16(t2)
	stw	r17,TF_R17(t2)
	stw	r18,TF_R18(t2)
	stw	r19,TF_R19(t2)
	stw	r20,TF_R20(t2)
	/*	r21 already saved
d1208 3
a1210 3
	stw	r23,TF_R23(t2)
	stw	r24,TF_R24(t2)
	stw	r25,TF_R25(t2)
d1212 3
a1214 3
	stw	r27,TF_R27(t2)
	stw	r28,TF_R28(t2)
	stw	r29,TF_R29(t2)
d1216 1
a1216 1
	stw	r31,TF_R31(t2)
d1222 9
a1230 11
	mfsp	sr0,t1
	stw	t1,TF_SR0(t2)

	mfsp	sr1,t1
	stw	t1,TF_SR1(t2)

	mfsp	sr2,t1
	stw	t1,TF_SR2(t2)

	mfsp	sr3,t1
	stw	t1,TF_SR3(t2)
d1236 2
a1237 2
	mfctl	rctr,t1
	stw	t1,TF_CR0(t2)
d1239 2
a1240 2
	mfctl	sar,t1
	stw	t1,TF_CR11(t2)
d1246 4
a1249 2
	mfctl	hptmask, t1
	stw	t1, TF_CR24(t2)
d1252 3
a1254 4
	stw	t1, TF_CR25(t2)

	mfctl	cr28, t1
	stw	t1, TF_CR28(t2)
d1268 1
a1268 1
	copy	t2, arg1
d1271 1
a1271 2
	/* TODO: setup a call frame */
	copy	r0, r3
d1276 1
a1276 1
	copy	t2, r5
d1281 1
a1281 1

d1285 1
d1287 1
a1287 1
	add,<>	t2, r0, t4
d1289 4
a1292 1

d1298 4
a1301 2
	ldw	TF_CR15(t3),t1
	mtctl	t1,eiem
a1308 2
	ldw	TF_CR0(t3),t1
	mtctl	t1,rctr
d1315 4
a1318 8
	ldw	TF_SR0(t3),t1
	mtsp	t1,sr0

	ldw	TF_SR1(t3),t1
	mtsp	t1,sr1

	ldw	TF_SR2(t3),t1
	mtsp	t1,sr2
d1320 4
a1323 2
	ldw	TF_SR3(t3),t1
	mtsp	t1,sr3
d1361 1
a1361 4
	ldil	L%intr_recurse, t1
	ldw	R%intr_recurse(t1), t2

		/*
d1387 1
d1389 1
d1391 4
a1394 8
	ldw	TF_SR5(t3),t1
	mtsp	t1,sr5

	ldw	TF_SR6(t3),t1
	mtsp	t1,sr6

	ldw	TF_SR7(t3),t1
	mtsp	t1,sr7
d1400 4
a1403 2
	ldw	TF_IIOQH(t3),t1
	mtctl	t1,pcoq
d1405 4
a1408 2
	ldw	TF_IIOQT(t3),t1
	mtctl	t1,pcoq
d1410 2
a1411 8
	ldw	TF_IISQH(t3),t1
	mtctl	t1,pcsq

	ldw	TF_IISQT(t3),t1
	mtctl	t1,pcsq

	ldw	TF_CR22(t3),t1
	mtctl	t1,ipsw
d1417 2
d1623 1
d1633 1
d1635 1
a1635 1
	ldil	L%$srqpstr, arg0
d1637 1
a1637 1
	ldo	R%$srqpstr(arg0), arg0
d1641 4
a1644 4

$srqpstr
	.asciz	"setrunqueue"
	.align	4
d1648 5
a1652 3
	ldb	p_priority(arg0), t1
	shd	r0, t1, 2, t1
	mtctl	t1, sar
d1655 1
a1655 1
	ldil	L%qs, t4
a1656 1
	ldo	R%qs(t4), t4
d1658 17
a1674 4
	sh3add	t1, t4, t1
	ldw	p_back(t1), t2
	stw	t1, p_forw(arg0)
	stw	arg0, p_back(t1)
d1678 2
d1686 1
d1688 5
a1692 2
	ldb	p_priority(arg0), t1
	shd	r0, t1, 2, t1
a1694 3
	ldil	L%whichqs, t3
	ldw	R%whichqs(t3), t3
	mtctl	t1, sar
d1698 2
d1709 2
a1710 2
	.asciz	"remrunqueue"
	.align	4
d1713 2
a1714 2
	ldw	p_back(arg0), t2
	stw	%r0, p_back(arg0)
d1716 5
a1720 8
	stw	arg0, p_forw(t2)
	stw	t2, p_back(arg0)
	comb,<>	t2, arg0, Lqnempty
	ldil	L%whichqs, t2
#ifndef DIAGNOSTIC
	ldw	R%whichqs(t2), t3
	mtctl	t1, sar
#endif
d1732 1
d1752 2
a1754 1
	rsm	PSW_I, r0
a1755 3

	/* 1. find new process */
	ldil	L%whichqs, t1
d1759 3
a1762 2
	mtctl	arg3, eiem
	ssm	PSW_I, r0
d1764 2
d1772 7
a1778 8
	addi	1, t4, t4
	bb,>=,n	t3,0,getbit
	shd	t3, t3, 1, t3

	addi	-1, t4, t4
	ldil	L%qs, t3
	ldo	R%qs(t3), t3
	sh3add	t4, t3, t3
d1780 1
a1780 1
	ldw	p_forw(t3), arg1
d1782 2
a1783 1
	comb,<>,n t3, arg1, link_ok
d1785 2
a1786 2
	ldil	L%switch_panic, arg0
	ldo	R%switch_panic(arg0), arg0
d1788 1
d1790 1
d1794 4
a1797 3

switch_panic	.asciz	"cpu_switch"
	.align	4
d1801 2
a1802 2
	stw	arg0, p_forw(t3)
	stw	t3, p_back(arg0)
d1804 4
a1807 4
	comb,<>,n arg0, t3, sw_qnempty
	ldw	R%whichqs(t1), t3
	mtctl	t4, sar
	vdepi	1, 1, t3
d1817 2
a1818 1
	comb,=,n r0, t1, switch_error
d1821 1
a1826 3
	/* enable interrupts */
	ssm	PSW_I, r0

a1849 1
	rsm	PSW_I, r0
d1857 1
a1858 2
	bv	0(rp)
	ssm	PSW_I, r0
@


1.17
log
@rewrite the tlb miss handler and tlb dirty handler.
optimize for HVT usage (when compiled for proper cpu type).
drop hpt_* global variables, use info from control registers instead.
there are still ways to improve the tlb handlers tho.
machdep also prints cache and tlb coherence states (not related to the above).
You eat greenish muffin. --More-- You write real code.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.16 1999/07/18 04:42:28 mickey Exp $	*/
d361 1
a361 1
	.export	gateway_page_end, code
d551 1
a551 1
	.export $ivaaddr, code
d599 1
a599 1
	.export	TLABEL(hpmc), code
d606 1
a606 1
	.export TLABEL(emu)
d721 1
d723 1
a723 1
	mfctl	tr2, t1
d726 1
a726 1
	.export TLABEL(excpt)
d797 1
d799 1
a799 1
	mfctl	tr7, r1
d802 1
a802 1
	.export	$sfu_emu, code
d820 3
a822 4
	extru	r9,14,15,r16		   /* r16 = off[0..14] */	! \
	zdep	r16,15,15,r16		   /* r16 = tag[1..15] */	! \
	dep	r8,31,16,r16		   /* put in the space id */	! \
	depi	1,0,1,r16		   /* and set the valid bit */
d826 1
a826 1
	.export	TLABEL(tlbd), code
a855 1
	ldw	pv_tlbpage(r24), r17
d861 1
a861 1
	.export	TLABEL(itlb), code
d870 2
a871 1
	b,n	$tlbmiss
d874 1
a874 1
	.export	TLABEL(dtlb), code
d895 1
a896 1
	VTAG	/* (r8,r9) -> r16 */
a922 1
	ldw	pv_tlbpage(r24),r17
d935 1
d944 1
a945 2
	
	comib,=,n T_ITLBMISS, r1, $itlb
a947 1
	b	$tlbret
d949 5
a953 1
$itlb
a955 3

	/* And return ... */
$tlbret
d959 1
d962 2
a963 1
	.export	TLABEL(ibreak), code
d1016 1
d1018 1
a1018 1
	mfctl	tr7, r1
d1021 1
a1021 1
	.export	TLABEL(all), code
d1041 1
a1041 1
	comb,=	r0, t2, $trap_recurse
d1137 1
a1137 1
	 * save the protection ID registers. We will keep the first one
d1142 3
a1150 3
	mfctl	pidr4,t1
	stw	t1,TF_CR13(t2)

d1156 1
a1156 4
	/*
	 * load the space queue
	 */

d1176 1
a1176 4
	/*
	 * load in the address to "return" to with the rfir instruction
	 */

d1180 1
a1180 4
	/*
	 * load the offset queue
	 */

a1263 3
	mfctl	pidr1,t1
	stw	t1,TF_CR8(t2)

d1305 1
d1399 3
a1407 3
	ldw	TF_CR13(t3),t1
	mtctl	t1,pidr4

d1456 2
d1459 1
a1459 1
	.align NBPG	
a1897 1
	mtctl	t4, pidr4
@


1.16
log
@fix {set,rem}runqueue wrt sizeof(p_stat) and some logic,
fix %r1 restoration in several traps,
also better kernel stack handling, and other fixes and typos.
all inspired by the recent hot weather and humid nyc climate in general.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.15 1999/07/08 16:14:50 mickey Exp $	*/
d75 5
d113 1
a113 2

	 * This is the starting location for the kernel
a805 1
#if 1
d807 16
a822 12
	extru	r9,19,20,r16  		/* r16 = (offset >> 12) */	! \
	zdep	r8,26,16,r24	     	/* r24 = (space << 5) */	! \
	mfctl	hptmask,r17		/* r17 = sizeof(HPT)-1 */	! \
	xor	r16,r24,r24		/* r24 ^= r16 */		! \
	and	r17,r24,r24		/* r24 &= r17 */		! \
	mfctl	vtop,r16		/* r16 = address of HPT table */! \
	zdep	r24,27,28,r17		/* r24 <<= 4 */			! \
	add	r17,r16,r24		/* r24 = HPT entry */
#else
#define	HPTENT ! \
	mfctl	cr28, r24
#endif
d824 1
d829 1
d831 5
a835 15
	mfsp	sr1, r25	/* Need a space reg, so save it in a shadow */
	mtsp	r8, sr1		/* Put the space id where we can use it */

	depi    0,31,12,r9	/* Clear the byte offset into the page */

	HPTENT

	/* Construct the virtual address tag. */
	extru	r9,14,15,r16		   /* r16 = off[0..14] */
	zdep	r16,15,15,r16		   /* r16 = tag[1..15] */
	or	r16,r8,r16		   /* or in the space id */
	depi	1,0,1,r16		   /* and set the valid bit */

	mtctl	r16, tr6
	mtctl	r24, tr5
d841 1
a841 1
	ldw	hpt_entry(r24),r24
d843 7
a849 8
	comb,=	r0, r24, TLABEL(all)
	mtsp	r25, sr1
	ldw     pv_va(r24),r16
	comb,<>,n r9,r16,$hash_loop_tlbd
	ldw	pv_hash(r24),r24
	ldw     pv_space(r24),r16
	comb,<>,n r8,r16,$hash_loop_tlbd
	ldw	pv_hash(r24),r24
d851 4
a854 4
	/*
	 * Set the dirty bit for this physical page.
	 */
	ldw	pv_tlbprot(r24), r16
d856 1
a856 2
	depi	1,TLB_DIRTY_POS,1, r16

d858 1
a858 1
	stw	r16, pv_tlbprot(r24)
d860 1
a860 1

a863 1
	b	$tlbmiss
d865 6
d872 1
d877 5
d888 1
d891 5
a895 12
	mfsp	sr1, r25	/* Need a space reg, so save it in a shadow */
	mtsp	r8, sr1		/* Put the space id where we can use it */

	depi    0,31,12,r9	/* Clear the byte offset into the page */

	HPTENT

	/* Construct the virtual address tag. */
	extru	r9,14,15,r16		   /* r16 = off[0..14] */
	zdep	r16,15,15,r16		   /* r16 = tag[1..15] */
	or	r16,r8,r16		   /* or in the space id */
	depi	1,0,1,r16		   /* and set the valid bit */
d899 1
a899 2
	ldw	hpt_tag(r24),r17
	comb,=,n r16,r17,$tlb_gothpt
d901 3
a903 9
	/*
	 * Okay, so we missed in the HPT cache. Stash away the HPT entry
	 * pointer and the virtual tag for later ...
	 *
	 * Switch r24 to point to the corresponding VTOP table entry so
	 * we can move onto chasing the hash chain.
	 */
	mtctl	r16, tr6
	mtctl	r24, tr5
d905 2
d913 4
a916 4
	comb,=	r0, r24, TLABEL(all)
	mtsp	r25, sr1
	ldw     pv_va(r24),r16
	comb,<>,n r9,r16,$hash_loop
d918 1
a918 2
	ldw     pv_space(r24),r16
	comb,<>,n r8,r16,$hash_loop
a921 3
	ldw	pv_tlbprot(r24),r16
	depi	1,TLB_REF_POS,1,r16
	stw	r16, pv_tlbprot(r24)
d923 2
d928 1
a928 2
	 * The HTP entry address and virtual tag were saved above in
	 * control registers.
d931 5
a935 2
	mfctl	tr6, r8
	mfctl	tr5, r24
d937 3
a939 4
	stw	r16,hpt_tlbprot(r24)
	stw	r17,hpt_tlbpage(r24)
	b	$tlb_gothptld
	stw	r8,hpt_tag(r24)
d942 4
a945 2
	ldw	hpt_tlbpage(r24),r17
	ldw	hpt_tlbprot(r24),r16
a946 2
$tlb_gothptld
	comib,=,n T_ITLBMISS,r1,$itlb
d949 1
a949 1
	idtlbp	r16,(sr1, r9)
d952 1
a952 1
	iitlbp	r16,(sr1, r9)
d956 1
a956 1
	mtsp	r25, sr1
d958 2
a959 1
	mfctl	tr7, r1
d1031 1
a1031 1
	mtctl	sp, tr4
d1064 1
a1064 1
	mfctl	tr4,t1
d1285 3
@


1.15
log
@microtime(), s/cr15/eiem/, some comments, tabs vs spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.14 1999/06/24 01:19:16 mickey Exp $	*/
d91 1
d93 7
d101 5
d108 2
a109 1
 * This is the starting location for the kernel
d160 1
a160 2
	ldo	R%proc0stack(t2), t2
	copy	t2, sp
d164 2
a165 3
	stw	r0, TF_R2 +pcb_tf+u_pcb(sr0, arg3)
	stw	dp, TF_R27+pcb_tf+u_pcb(sr0, arg3)
	stw	sp, TF_R30+pcb_tf+u_pcb(sr0, arg3)
d382 1
a382 4
	copy	r0, t2
	depi	-1, 31, 12, t2
	depi	0, 19, 12, t3
	addi	FM_SIZE+ARG_SIZE, t3, sp
d563 1
a563 1
#ifdef FPEMUL
a582 1
	ATRAP(datal,T_DATALIGN)	/* 28. unaligned data ref trap (T-chip) */
a585 1
	ATRAP(unk28,28)
d587 1
d604 3
d616 1
d618 3
a620 4
	mtctl	t1, tr4
	mtctl	t2, tr5
	mtctl	t3, tr6
	mtctl	t4, tr7
d715 2
a716 2
	mfctl	tr6, t3
	mfctl	tr5, t2
d718 1
a718 1
	mfctl	tr4, t1
d720 1
d728 42
d771 27
d799 1
a799 1
	nop
a834 1
	mtctl	r24, tr7
d836 1
a906 1
	mtctl	r24, tr7
d908 1
d932 1
a932 1
	 * Load the HPT cache with the miss information for next the time.
a936 1
	mfctl	tr7, r24
d938 1
d962 1
a962 1
	nop
d990 1
a990 1
	/* illegal (unimplemented break entry point) */
d1017 1
a1018 3
	rfi
	nop

d1020 1
d1040 3
a1042 3
	addi	1, t2, t2
	stw	t2, R%intr_recurse(t1)
	addib,= -1, t2, $trap_recurse
d1044 2
a1045 3
	ldil	L%proc0paddr, t1
	ldw	R%proc0paddr(t1), t1
	ldw	TF_R30+pcb_tf+u_pcb(sr0, t1), sp
d1050 2
a1051 1
	comb,=,n r0, t2, $trap_recurse
d1053 1
d1059 1
a1059 1
	ldo	TF_SIZE(sp), sp
d1152 1
a1154 1
	mtctl	t1,pidr4
d1216 4
d1279 11
d1305 1
d1310 1
a1310 1
	copy	t2, r4
d1315 7
a1321 1
	copy	r4, t3
d1380 2
a1381 2
	ldw	TF_R21(t3),r21
	/*	r22(t1) is used as a temporary and will be restored later */
d1392 4
a1395 1
	/*
d1453 1
d1455 4
a1459 1
	ldw	TF_R22(t3),t1
a1664 2
$srqpstr
	.asciz	"setrunqueue"
d1669 1
d1672 5
a1676 2
	bv	%r0(r1)
	ldo	R%$srqpstr(arg0), arg0
d1680 2
a1681 2
	ldw	p_priority(arg0), t1
	extru	t1,29,6,t1
d1685 1
d1687 1
d1689 1
a1689 3
	ldil	L%qs, t2
	ldo	R%qs(t2), t2
	sh3add	t1, t2, t3
d1691 2
a1692 2
	stw	t3, p_forw(arg0)
	stw	arg0, p_back(t3)
d1703 2
a1704 2
	ldw	p_priority(arg0), t1
	extru	t1,29,6,t1
d1710 1
a1710 1
	bvb,<	t3, remrunqueue_ok
d1713 1
d1715 1
a1716 2
	ldil    L%panic, r1
	ldo     R%panic(r1), r1
d1720 1
d1723 1
d1787 1
a1787 1
	bb,>=	t3,0,getbit
d1790 1
d1808 1
d1815 1
a1815 1
	comb,<> arg0, t3, sw_qnempty
d1821 1
a1821 1
	/* don't need &whichqs(t1) starting here */
d1829 1
a1829 1
	ldw	p_stat(arg1), t1
d1851 1
a1851 1
	 * dome on enter, wonderfull.
@


1.14
log
@fix cpu_switch panic
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.13 1999/06/22 17:56:05 mickey Exp $	*/
d924 2
d936 1
d938 1
a938 1
	mfctl	tr7, r1
d1381 1
a1381 1
	stwm    rp,4(arg0)	/* Save the return pointer */
d1385 1
a1385 1
	or      r0,r0,ret0
d1413 1
a1413 1
	or	arg1,r0,ret0	/* Move return value to where it belongs. */
d1509 1
d1513 25
a1538 1
	bv,n	(rp)
d1652 1
a1652 1
	mfctl	cr15, arg3
d1655 1
a1655 1
	mtctl	r0, cr15
d1663 1
a1663 1
	mtctl	arg3, cr15
d1754 1
a1754 1
	mtctl	arg3, cr15
@


1.13
log
@allow stack tracing up to the very bottom of the stack; also tabs vs spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.12 1999/06/22 17:46:38 mickey Exp $	*/
d1658 2
a1659 2
	ldil    L%panic, arg1
	ldo     R%panic(arg1), arg1
@


1.12
log
@why underscore if we have dollars
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.11 1999/06/18 05:19:52 mickey Exp $	*/
a141 5
	 * clear GCC frame pointer to avoid back-tracing off the end
	 */
	copy	r0,r4

	/*
d183 2
a184 2
	ldo     R%$ivaaddr(t2),t2
	mtctl   t2,iva
d190 4
a193 2
	ldo     TF_SIZE(sp),sp
	stw     r0,FM_PSP(sp)
d198 1
a198 1
	mtctl   r0,ccr
d204 2
a205 2
	ldil	L%hppa_init,r1
	ldo	R%hppa_init(r1),r1
d207 1
a207 1
	blr	r0,rp
@


1.11
log
@do not include fpu regs into trapframe, according to the
lazy fpu context switching it could be well saved into pcb.
this brings trapframe to 256 bytes (including 5 spare words).
adjust all the code to deal w/ moved fpu regs save area.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.10 1999/06/12 17:35:10 mickey Exp $	*/
d97 1
a97 1
ENTRY(__start)
@


1.10
log
@allocate kernel stack in .bss
fix vm_map.pmap vs vm_pmap issue; 10x art@@
fix setrunqueue()'s DIAGNOSTIC section, also p_stat is a char
p_md is a member, not a pointer.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.9 1999/05/21 23:19:17 mickey Exp $	*/
d630 1
a630 1
	ldo	TF_FPREGS+pcb_tf+u_pcb(t3), t3
d668 1
a668 1
	ldo	31*8+TF_FPREGS+pcb_tf+u_pcb(t3), t3
@


1.9
log
@s/globl/export/g
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.8 1999/05/21 17:06:56 mickey Exp $	*/
d80 1
a80 1
	.import	curproc, code
d86 1
d88 5
a92 1
	.import	panic, code
d150 3
a152 3
#define	PROC0STKSZ	5*NBPG
	ldo	R%NBPG(arg3), sp
	ldo	R%PROC0STKSZ(sp), arg0
d154 1
d490 5
a494 7
	ldw	TF_CR8+pcb_tf(sr1,t4), t3
	mtctl	t3, pidr1
	mtctl	t3, pidr3
	mtctl	t3, pidr4

	ldw	p_vmspace(t1), t3
	ldw	vm_pmap+pmap_space(t3), t3
d974 1
a974 1
	ldw	p_md(t2), t2
d1506 10
d1524 2
a1525 2
	ldw	p_back(%arg0), t1
	comb,=	r0, t1, Lsetrunqueue_panic
d1527 4
a1530 5
	comb,=	r0, t1, Lsetrunqueue_panic
	ldw	p_stat(arg0), t1
	comib,<> SRUN, t1, Lsetrunqueue_panic
	b	Lsetrunqueue_ok
Lsrqpstr
d1532 4
a1535 5
Lsetrunqueue_panic
	ldil	L%Lsrqpstr, arg0
	ldo	R%Lsrqpstr(arg0), arg0
	ldil    L%panic, r1
	ldo     R%panic(r1), r1
d1537 4
a1540 3
	blr     %r0, rp
	bv,n    %r0(r1)
Lsetrunqueue_ok
@


1.8
log
@do lazy context switches for FPU
fix break handling
better context saving sequence
some cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.7 1999/05/02 03:42:42 mickey Exp $	*/
d287 1
a287 1
	.globl	gateway_page, code
d342 1
a342 1
	.globl	gateway_page_end, code
@


1.7
log
@new {s,g}et_psw()
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.6 1999/04/20 20:36:06 mickey Exp $	*/
d75 1
a75 4
	.import istackptr, data
	.import tmp_saved_state, data
	.import fpu_zero, data
	.import	fpu_pcb, data
a79 1
	.import istackptr, data
d81 1
d83 3
a85 3
/*
 * Declare data sections
 */
d87 1
a87 47
	.space  $PRIVATE$
	.subspa $DATA$

/*
 * allocate the interrupt stack and a page after it for a red zone...
 */
	.align  NBPG
	.export intstack_base,data
intstack_base

	.blockz INTSTACK_SIZE

	.export intstack_top,data
intstack_top

	/* 
	 * interrupt stack red zone
	 */
	.blockz NBPG
	.align  NBPG

dumpstk
recoverstack
panic_stack
	.export panic_stack,data
	.blockz 2 * NBPG
	.align  NBPG

#ifdef	GPROF
	/*
	 * We want these on 1 cache line to make the interrupt handler
	 * as fast as possible.
	 */
	.align	32
	.export profiling,data
	.export s_lowpc,data
	.export kcount,data
	.export s_textsize,data
profiling
	.word	PROFILING_OFF
s_lowpc
	.word	0
kcount
	.word	0
s_textsize
	.word	0
#endif
d106 1
a106 1
	 * save the pdc, boothowto and bootdev arguments
d137 1
a137 1
	 * establish an interrupt stack
d139 1
a139 2
	ldil	L%intstack_base,sp
	ldo	R%intstack_base(sp),sp
d142 2
a143 1
	 * clear intstackptr to indicate that we are on the interrupt stack
d145 8
a152 7
	ldil	L%istackptr,t1
	stw	r0,R%istackptr(t1)

	/*
	 * clear GCC frame pointer to avoid back-tracing off the end
	 */
	copy	r0,r4
d175 2
a176 2
	ldi    	-1,r1
	mtctl   r1,eirr
d181 3
a183 3
	ldil	L%$ivaaddr,r2
	ldo     R%$ivaaddr(r2),r2
	mtctl   r2,iva
d213 4
a216 4
	mtctl	r1,cr8
	mtctl	r1,cr9
	mtctl	r1,cr12
	mtctl	r1,cr13
d254 1
a254 1
	bb,>=	r1,25,$noddb
d274 1
d417 8
a424 9
	ldi	HPPA_SID_KERNEL, t4
	mtctl	t4, sr0
	mtctl	t4, sr1
	mtctl	t4, sr2
	mtctl	t4, sr3
	mtctl	t4, sr4
	mtctl	t4, sr5
	mtctl	t4, sr6
	mtctl	t4, sr7
d529 1
a529 1
	nop				! \
d553 3
d557 1
d566 1
a566 1
	ATRAP(emu,T_EMULATION)	/* 22. assist emulation trap */
d570 1
d574 5
d586 1
a586 1
	.export	$trap$hpmc, code
d593 125
d884 6
a889 3
	mfctl	iir, r16
	extru	r16, 31, 5, r9
	comib,<>,n HPPA_BREAK_KERNEL, r9, TLABEL(all)
d892 3
a894 3
	mfctl	pcoq, r8
	extru,=	r8, 31, 2, r0
	b,n	TLABEL(all)
d898 3
a900 3
	ldil	L%etext, r9
	ldo	R%etext(r9), r9
	comb,<<,n r8, r9, TLABEL(all)
d903 10
a912 2
	extru	r16, 18, 13, r9
	comib,<>,n HPPA_BREAK_GET_PSW, r9, $ibreak_ngetpsw
d914 1
d918 1
a918 3
$ibreak_ngetpsw
	comib,<>,n HPPA_BREAK_SET_PSW, r9, $ibreak_nsetpsw

a922 4
$ibreak_nsetpsw
	b	TLABEL(all)
	nop

d925 10
a934 7
	mfctl	pcoq, r8
	mfctl	pcoq, r8
	mtctl	r8, pcoq
	add	r8, 4, r8
	mtctl	r8, pcoq
	rfir
	nop
d947 1
a947 1
	 *	trap number in r1 (old r1 is saved in cr31)
d950 21
a970 5
	mtctl	arg0, tr2
	mtctl	sp, tr3
	copy	r1, arg0
	mtctl	t1, tr4
	mtctl	t2, tr5
d972 1
d974 1
a974 2
	ldo	TF_SIZE+FM_SIZE(sp), sp
	stw	t2, FM_PSP(sp)
d976 5
a980 4
	/*
	 * now start saving the temporary registers into the saved state.
	 * These four get us out of temporary registers
	 */
d982 1
a982 4
	mfctl	tr2,t1
	stw	t1,TF_R26(t2)

	mfctl	tr3,t1
d985 1
a985 1
	mfctl	tr4,t1
d988 1
a988 1
	mfctl	tr5,t1
d1198 2
a1199 2
	 * call the C routine trap. Interrupt type (arg0) was setup back before
	 * the call to thandler.
a1201 1
	copy	t2, r4
d1203 2
a1204 8
#if KGDB
	/*
	 * Artificially create another frame so that gdb will
	 * show real trapped routine.
	 */
	stw	r2,FM_CRP-(FM_SIZE+ARG_SIZE)(sp)
	stw	r3,-(FM_SIZE+ARG_SIZE)(sp)	/* this overwrites ARG11 */
	ldo	-(FM_SIZE+ARG_SIZE)(sp),r3
a1205 1

d1209 1
d1211 2
a1212 2
	blr     r0,rp
	bv,n    0(t1)
a1503 1
	.import	panic, code
d1526 1
a1526 1
	bv,n    (r1)
d1569 1
a1569 1
	bv,n    (r1)
d1652 1
a1652 1
	bv,n    (r1)
a1726 1
	.import	proc0, data
d1732 2
a1733 6
	/* no curproc */
	ldil	L%curproc, t1
	stw	r0, R%curproc(t1)

	ldil	L%proc0, arg0
	ldo	R%proc0(t1), arg0
d1736 8
a1743 9
	ldi	HPPA_SID_KERNEL, t4
	mtctl	t4, sr0
	mtctl	t4, sr1
	mtctl	t4, sr2
	mtctl	t4, sr3
	mtctl	t4, sr4
	mtctl	t4, sr5
	mtctl	t4, sr6
	mtctl	t4, sr7
@


1.6
log
@scheduler, syscalls, {fs}u{,s}words
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.5 1999/02/25 19:22:50 mickey Exp $	*/
d143 1
a143 1
 *	start(pdc, boothowto, bootdev, esym bootapiver, argv, argc)
a323 16
ENTRY(set_psw)
	mtctl	r0,pcsq
	mtctl	r0,pcsq
	ldil	L%$set_psw,t1
	ldo	R%$set_psw(t1),t1
	mtctl	t1,pcoq	
	ldo	4(t1),t1
	mtctl	t1,pcoq	
	mtctl	arg0,ipsw
	rfi
	nop
$set_psw
	bv	0(rp)
	nop
EXIT(set_psw)

d596 1
a596 1
	ATRAP(ibreak,T_IBREAK)	/*  9. break instruction trap */
d795 46
d1661 3
a1663 3
	/* TODO */
	bv	0(rp)
	nop
a1665 6
ENTRY(child_return)
	/* TODO */
	bv	0(rp)
	nop
EXIT(child_return)

d1670 1
a1670 1
	/* TODO */
d1680 1
a1680 1
	/* TODO */
a1685 7
	/* Leave this down here.  It avoids a nasty, hard-to-fix bug in gas. */
	.space $PRIVATE$

	.export $global$,data
$global$
	.word 0

a1686 1

@


1.5
log
@save 'esym' passed from /boot
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.4 1999/02/17 22:29:19 mickey Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998 Michael Shalayeff
d31 16
a61 13
/*
 * Copyright (c) 1990,1991,1992,1994 The University of Utah and
 * the Computer Systems Laboratory (CSL).  All rights reserved.
 *
 * THE UNIVERSITY OF UTAH AND CSL PROVIDE THIS SOFTWARE IN ITS "AS IS"
 * CONDITION, AND DISCLAIM ANY LIABILITY OF ANY KIND FOR ANY DAMAGES
 * WHATSOEVER RESULTING FROM ITS USE.
 *
 * CSL requests users of this software to return to csl-dist@@cs.utah.edu any
 * improvements that they make and grant CSL redistribution rights.
 *
 * 	Utah $Hdr: locore.s 1.62 94/12/15$
 */
d63 1
d84 2
d143 1
a143 1
 *	start(pdc, boothowto, bootdev, bootapiver, argv, argc)
d149 1
d336 2
a337 1

d350 2
a351 1
$gateway_page
d354 4
d360 1
d366 20
d388 1
a388 1
	 * set up a space register and a protection register so that 
d392 1
d394 1
a394 1
	mtctl	r1, pidr4
d405 4
a408 4
	/*
	 * Don't let anything else get on the gateway page.
	 */
	.align  NBPG
d410 3
d414 87
d502 16
d519 52
d691 1
a691 1
	comb,=	r0,r24,$pageflt
d763 1
a763 1
	comb,=	r0,r24,$pageflt
a810 4
	.align 32
$pageflt
	/* r1 still has trap type */
	/* FALL THROUGH */
d813 2
d1247 1
d1275 1
d1279 181
d1464 177
a1640 2
	ENTRY(cpu_switch)
	EXIT(cpu_switch)
d1645 9
a1653 1
	ENTRY(sigcode)
d1655 6
a1660 2
	ALTENTRY(esigcode)
	EXIT(sigcode)
@


1.4
log
@no more break.h
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.3 1999/01/20 19:32:02 mickey Exp $	*/
d78 1
d156 2
@


1.3
log
@yes, some more
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.2 1999/01/16 07:53:02 mickey Exp $	*/
a62 1
#include <machine/break.h>
@


1.2
log
@use right defines for eiem, some cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.1 1998/12/05 17:44:48 mickey Exp $	*/
a575 6

	/* got it, set software flags */
	copy	r0, r16
	depi	1,TLB_DCACHE_POS,1,r16
	depi	1,TLB_ICACHE_POS,1,r16	
	stw	r16,pv_tlbsw(r24)
@


1.1
log
@some locore.S
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a79 1

d167 1
a167 1
	ldi	SPLHIGH,r1
d372 4
a398 1
	mtctl	r1, tr7			! \
d403 1
a403 11
	nop ! .word 0, 0

#define	ITRAP(name, reason) \
	.import	TLABEL(name), code	! \
	nop				! \
	mtctl	r1, tr7			! \
	ldil	L%TLABEL(name), r1	! \
	.call				! \
	be	R%TLABEL(name)(sr4, r1)	! \
	ldi	reason, r1		! \
	nop ! .word 0, 0
d471 2
a472 2
	mfctl	ior,r9		/* Offset */
	mfctl	isr,r8		/* Space  */
d487 2
a488 2
	mtctl	r24, cr28
	mtctl	r16, cr29
d524 2
a525 2
	mfctl	ior,r9		/* Offset */
	mfctl	isr,r8		/* Space  */
d559 2
a560 2
	mtctl	r24,cr28
	mtctl	r16,cr29
d595 2
a596 2
	mfctl	cr28,r24
	mfctl	cr29,r8
d610 1
a611 1
	b,n	$tlbret
a743 7
	copy	r0, t1

	/*
	 * Save trap flags
	 */
	mtctl	t1,tr6

d764 1
a764 1
	ldi	SPLHIGH,t1
a782 6
	 * Restore trap flags
	 */

	mfctl	tr6,t1

	/*
a1106 3
#ifndef	BFD_SUBSPA_BUG
	.subspa $GLOBAL$
#endif
d1110 1
d1113 1
@

