head	1.39;
access;
symbols
	OPENBSD_6_1:1.38.0.4
	OPENBSD_6_1_BASE:1.38
	OPENBSD_6_0:1.37.0.2
	OPENBSD_6_0_BASE:1.37
	OPENBSD_5_9:1.35.0.6
	OPENBSD_5_9_BASE:1.35
	OPENBSD_5_8:1.35.0.8
	OPENBSD_5_8_BASE:1.35
	OPENBSD_5_7:1.35.0.2
	OPENBSD_5_7_BASE:1.35
	OPENBSD_5_6:1.35.0.4
	OPENBSD_5_6_BASE:1.35
	OPENBSD_5_5:1.33.0.6
	OPENBSD_5_5_BASE:1.33
	OPENBSD_5_4:1.33.0.2
	OPENBSD_5_4_BASE:1.33
	OPENBSD_5_3:1.32.0.32
	OPENBSD_5_3_BASE:1.32
	OPENBSD_5_2:1.32.0.30
	OPENBSD_5_2_BASE:1.32
	OPENBSD_5_1_BASE:1.32
	OPENBSD_5_1:1.32.0.28
	OPENBSD_5_0:1.32.0.26
	OPENBSD_5_0_BASE:1.32
	OPENBSD_4_9:1.32.0.24
	OPENBSD_4_9_BASE:1.32
	OPENBSD_4_8:1.32.0.22
	OPENBSD_4_8_BASE:1.32
	OPENBSD_4_7:1.32.0.18
	OPENBSD_4_7_BASE:1.32
	OPENBSD_4_6:1.32.0.20
	OPENBSD_4_6_BASE:1.32
	OPENBSD_4_5:1.32.0.16
	OPENBSD_4_5_BASE:1.32
	OPENBSD_4_4:1.32.0.14
	OPENBSD_4_4_BASE:1.32
	OPENBSD_4_3:1.32.0.12
	OPENBSD_4_3_BASE:1.32
	OPENBSD_4_2:1.32.0.10
	OPENBSD_4_2_BASE:1.32
	OPENBSD_4_1:1.32.0.8
	OPENBSD_4_1_BASE:1.32
	OPENBSD_4_0:1.32.0.6
	OPENBSD_4_0_BASE:1.32
	OPENBSD_3_9:1.32.0.4
	OPENBSD_3_9_BASE:1.32
	OPENBSD_3_8:1.32.0.2
	OPENBSD_3_8_BASE:1.32
	OPENBSD_3_7:1.31.0.2
	OPENBSD_3_7_BASE:1.31
	OPENBSD_3_6:1.30.0.2
	OPENBSD_3_6_BASE:1.30
	SMP_SYNC_A:1.29
	SMP_SYNC_B:1.29
	OPENBSD_3_5:1.28.0.4
	OPENBSD_3_5_BASE:1.28
	OPENBSD_3_4:1.28.0.2
	OPENBSD_3_4_BASE:1.28
	UBC_SYNC_A:1.27
	OPENBSD_3_3:1.27.0.2
	OPENBSD_3_3_BASE:1.27
	OPENBSD_3_2:1.25.0.2
	OPENBSD_3_2_BASE:1.25
	OPENBSD_3_1:1.18.0.2
	OPENBSD_3_1_BASE:1.18
	UBC_SYNC_B:1.25
	UBC:1.16.0.6
	UBC_BASE:1.16
	OPENBSD_3_0:1.16.0.4
	OPENBSD_3_0_BASE:1.16
	OPENBSD_2_9:1.16.0.2
	OPENBSD_2_9_BASE:1.16
	OPENBSD_2_8:1.13.0.2
	OPENBSD_2_8_BASE:1.13
	OPENBSD_2_7:1.12.0.4
	OPENBSD_2_7_BASE:1.12
	SMP:1.12.0.2
	SMP_BASE:1.12
	kame_19991208:1.9
	OPENBSD_2_6:1.8.0.2
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.39
date	2017.04.30.16.45.45;	author mpi;	state Exp;
branches;
next	1.38;
commitid	2Gtqjzrin9LL2yHk;

1.38
date	2016.09.19.21.18.35;	author jasper;	state Exp;
branches;
next	1.37;
commitid	504EMnf4FZsQ0Gj3;

1.37
date	2016.03.01.21.35.13;	author mpi;	state Exp;
branches;
next	1.36;
commitid	cgyWVaMY5TPuOMDK;

1.36
date	2016.02.27.13.08.06;	author mpi;	state Exp;
branches;
next	1.35;
commitid	hnv9KfQtxhCytAnd;

1.35
date	2014.07.13.12.11.01;	author jasper;	state Exp;
branches;
next	1.34;
commitid	XHZxhpAa5R1Ymp1z;

1.34
date	2014.03.29.18.09.29;	author guenther;	state Exp;
branches;
next	1.33;

1.33
date	2013.07.07.14.08.05;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2005.04.07.00.17.32;	author mickey;	state Exp;
branches;
next	1.31;

1.31
date	2004.12.22.20.36.00;	author mickey;	state Exp;
branches;
next	1.30;

1.30
date	2004.06.27.14.16.22;	author mickey;	state Exp;
branches;
next	1.29;

1.29
date	2004.04.07.18.24.19;	author mickey;	state Exp;
branches;
next	1.28;

1.28
date	2003.07.15.18.15.41;	author mickey;	state Exp;
branches;
next	1.27;

1.27
date	2003.03.03.18.28.35;	author mickey;	state Exp;
branches;
next	1.26;

1.26
date	2003.02.18.19.01.50;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2002.09.17.19.15.31;	author mickey;	state Exp;
branches;
next	1.24;

1.24
date	2002.08.13.03.44.48;	author mickey;	state Exp;
branches;
next	1.23;

1.23
date	2002.07.25.04.51.40;	author mickey;	state Exp;
branches;
next	1.22;

1.22
date	2002.07.23.16.56.52;	author mickey;	state Exp;
branches;
next	1.21;

1.21
date	2002.05.18.09.49.17;	author art;	state Exp;
branches;
next	1.20;

1.20
date	2002.05.16.20.16.15;	author mickey;	state Exp;
branches;
next	1.19;

1.19
date	2002.05.16.13.01.41;	author art;	state Exp;
branches;
next	1.18;

1.18
date	2002.03.14.03.15.53;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2002.03.14.01.26.31;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2001.03.22.23.31.45;	author mickey;	state Exp;
branches
	1.16.6.1;
next	1.15;

1.15
date	2001.01.30.21.45.32;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	2001.01.12.23.08.56;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	2000.05.30.22.09.45;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	2000.01.05.18.37.40;	author mickey;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	2000.01.05.18.35.35;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	2000.01.01.22.54.55;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	99.11.16.17.08.53;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	99.09.10.19.56.25;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	99.08.14.03.18.29;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	99.07.21.04.28.36;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	99.07.12.18.12.49;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	99.06.22.17.58.27;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	99.04.20.21.02.28;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	99.02.25.19.19.20;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	98.10.30.18.59.03;	author mickey;	state Exp;
branches;
next	;

1.12.2.1
date	2001.04.18.16.06.07;	author niklas;	state Exp;
branches;
next	1.12.2.2;

1.12.2.2
date	2002.03.28.10.07.19;	author niklas;	state Exp;
branches;
next	1.12.2.3;

1.12.2.3
date	2003.03.27.23.26.53;	author niklas;	state Exp;
branches;
next	1.12.2.4;

1.12.2.4
date	2004.02.19.10.48.40;	author niklas;	state Exp;
branches;
next	1.12.2.5;

1.12.2.5
date	2004.06.05.23.10.48;	author niklas;	state Exp;
branches;
next	;

1.16.6.1
date	2002.06.11.03.35.37;	author art;	state Exp;
branches;
next	1.16.6.2;

1.16.6.2
date	2002.10.29.00.28.02;	author art;	state Exp;
branches;
next	1.16.6.3;

1.16.6.3
date	2003.05.19.21.49.41;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.39
log
@Rename Debugger() into db_enter().

Using a name with the 'db_' prefix makes it invisible from the dynamic
profiler.

ok deraadt@@, kettenis@@, visa@@
@
text
@/*	$OpenBSD: db_interface.c,v 1.38 2016/09/19 21:18:35 jasper Exp $	*/

/*
 * Copyright (c) 1999-2003 Michael Shalayeff
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR OR HIS RELATIVES BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

#undef DDB_DEBUG

#include <sys/param.h>
#include <sys/systm.h>

#include <machine/db_machdep.h>
#include <machine/frame.h>
#include <machine/cpufunc.h>

#include <ddb/db_access.h>
#include <ddb/db_command.h>
#include <ddb/db_output.h>
#include <ddb/db_run.h>
#include <ddb/db_sym.h>
#include <ddb/db_var.h>
#include <ddb/db_variables.h>
#include <ddb/db_extern.h>
#include <ddb/db_interface.h>

#include <dev/cons.h>

void kdbprinttrap(int, int);

extern char *trap_type[];
extern int trap_types;

db_regs_t	ddb_regs;
struct db_variable db_regs[] = {
	{ "flags", (long *)&ddb_regs.tf_flags,  FCN_NULL },
	{ "r1",    (long *)&ddb_regs.tf_r1,  FCN_NULL },
	{ "rp",    (long *)&ddb_regs.tf_rp,  FCN_NULL },
	{ "r3",    (long *)&ddb_regs.tf_r3,  FCN_NULL },
	{ "r4",    (long *)&ddb_regs.tf_r4,  FCN_NULL },
	{ "r5",    (long *)&ddb_regs.tf_r5,  FCN_NULL },
	{ "r6",    (long *)&ddb_regs.tf_r6,  FCN_NULL },
	{ "r7",    (long *)&ddb_regs.tf_r7,  FCN_NULL },
	{ "r8",    (long *)&ddb_regs.tf_r8,  FCN_NULL },
	{ "r9",    (long *)&ddb_regs.tf_r9,  FCN_NULL },
	{ "r10",   (long *)&ddb_regs.tf_r10, FCN_NULL },
	{ "r11",   (long *)&ddb_regs.tf_r11, FCN_NULL },
	{ "r12",   (long *)&ddb_regs.tf_r12, FCN_NULL },
	{ "r13",   (long *)&ddb_regs.tf_r13, FCN_NULL },
	{ "r14",   (long *)&ddb_regs.tf_r14, FCN_NULL },
	{ "r15",   (long *)&ddb_regs.tf_r15, FCN_NULL },
	{ "r16",   (long *)&ddb_regs.tf_r16, FCN_NULL },
	{ "r17",   (long *)&ddb_regs.tf_r17, FCN_NULL },
	{ "r18",   (long *)&ddb_regs.tf_r18, FCN_NULL },
	{ "r19",   (long *)&ddb_regs.tf_t4,  FCN_NULL },
	{ "r20",   (long *)&ddb_regs.tf_t3,  FCN_NULL },
	{ "r21",   (long *)&ddb_regs.tf_t2,  FCN_NULL },
	{ "r22",   (long *)&ddb_regs.tf_t1,  FCN_NULL },
	{ "r23",   (long *)&ddb_regs.tf_arg3,  FCN_NULL },
	{ "r24",   (long *)&ddb_regs.tf_arg2,  FCN_NULL },
	{ "r25",   (long *)&ddb_regs.tf_arg1,  FCN_NULL },
	{ "r26",   (long *)&ddb_regs.tf_arg0,  FCN_NULL },
	{ "r27",   (long *)&ddb_regs.tf_dp,    FCN_NULL },
	{ "r28",   (long *)&ddb_regs.tf_ret0,  FCN_NULL },
	{ "r29",   (long *)&ddb_regs.tf_ret1,  FCN_NULL },
	{ "r30",   (long *)&ddb_regs.tf_sp,    FCN_NULL },
	{ "r31",   (long *)&ddb_regs.tf_r31,   FCN_NULL },
	{ "sar",   (long *)&ddb_regs.tf_sar,   FCN_NULL },

	{ "rctr",  (long *)&ddb_regs.tf_rctr,  FCN_NULL },
	{ "ccr",   (long *)&ddb_regs.tf_ccr,   FCN_NULL },
	{ "eirr",  (long *)&ddb_regs.tf_eirr,  FCN_NULL },
	{ "eiem",  (long *)&ddb_regs.tf_eiem,  FCN_NULL },
	{ "iir",   (long *)&ddb_regs.tf_iir,   FCN_NULL },
	{ "isr",   (long *)&ddb_regs.tf_isr,   FCN_NULL },
	{ "ior",   (long *)&ddb_regs.tf_ior,   FCN_NULL },
	{ "ipsw",  (long *)&ddb_regs.tf_ipsw,  FCN_NULL },
	{ "iisqh", (long *)&ddb_regs.tf_iisq_head,  FCN_NULL },
	{ "iioqh", (long *)&ddb_regs.tf_iioq_head,  FCN_NULL },
	{ "iisqt", (long *)&ddb_regs.tf_iisq_tail,  FCN_NULL },
	{ "iioqt", (long *)&ddb_regs.tf_iioq_tail,  FCN_NULL },

	{ "sr0",   (long *)&ddb_regs.tf_sr0,   FCN_NULL },
	{ "sr1",   (long *)&ddb_regs.tf_sr1,   FCN_NULL },
	{ "sr2",   (long *)&ddb_regs.tf_sr2,   FCN_NULL },
	{ "sr3",   (long *)&ddb_regs.tf_sr3,   FCN_NULL },
	{ "sr4",   (long *)&ddb_regs.tf_sr4,   FCN_NULL },
	{ "sr5",   (long *)&ddb_regs.tf_sr5,   FCN_NULL },
	{ "sr6",   (long *)&ddb_regs.tf_sr6,   FCN_NULL },
	{ "sr7",   (long *)&ddb_regs.tf_sr7,   FCN_NULL },

	{ "pidr1", (long *)&ddb_regs.tf_pidr1, FCN_NULL },
	{ "pidr2", (long *)&ddb_regs.tf_pidr2, FCN_NULL },
#ifdef pbably_not_worth_it
	{ "pidr3", (long *)&ddb_regs.tf_pidr3, FCN_NULL },
	{ "pidr4", (long *)&ddb_regs.tf_pidr4, FCN_NULL },
#endif

	{ "vtop",  (long *)&ddb_regs.tf_vtop,  FCN_NULL },
	{ "cr28",  (long *)&ddb_regs.tf_cr28,  FCN_NULL },
	{ "cr30",  (long *)&ddb_regs.tf_cr30,  FCN_NULL },
};
struct db_variable *db_eregs = db_regs + nitems(db_regs);
int db_active = 0;

void
db_enter(void)
{
	extern int kernelmapped;	/* from locore.S */
	if (kernelmapped)
		__asm volatile ("break %0, %1"
		    :: "i" (HPPA_BREAK_KERNEL), "i" (HPPA_BREAK_KGDB));
}

void
db_read_bytes(vaddr_t addr, size_t size, char *data)
{
	register char *src = (char *)addr;

	while (size--)
		*data++ = *src++;
}

void
db_write_bytes(vaddr_t addr, size_t size, char *data)
{
	register char *dst = (char *)addr;

	while (size--)
		*dst++ = *data++;

	/* unfortunately ddb does not provide any hooks for these */
	ficache(HPPA_SID_KERNEL, (vaddr_t)data, size);
	fdcache(HPPA_SID_KERNEL, (vaddr_t)data, size);
}


/*
 * Print trap reason.
 */
void
kdbprinttrap(int type, int code)
{
	type &= ~T_USER;	/* just in case */
	db_printf("kernel: ");
	if (type >= trap_types || type < 0)
		db_printf("type 0x%x", type);
	else
		db_printf("%s", trap_type[type]);
	db_printf(" trap, code=0x%x\n", code);
}

/*
 *  db_ktrap - field a BPT trap
 */
int
db_ktrap(int type, int code, db_regs_t *regs)
{
	extern label_t *db_recover;
	int s;

	switch (type) {
	case T_IBREAK:
	case T_DBREAK:
	case -1:
		break;
	default:
		if (!db_panic)
			return (0);

		kdbprinttrap(type, code);
		if (db_recover != 0) {
			db_error("Caught exception in DDB; continuing...\n");
			/* NOT REACHED */
		}
	}

	/* XXX Should switch to kdb`s own stack here. */

	s = splhigh();
	ddb_regs = *regs;
	db_active++;
	cnpollc(TRUE);
	db_trap(type, code);
	cnpollc(FALSE);
	db_active--;
	splx(s);

	*regs = ddb_regs;

	return (1);
}

/*
 *  Validate an address for use as a breakpoint.
 *  Any address is allowed for now.
 */
int
db_valid_breakpoint(db_addr_t addr)
{
	return (1);
}

void
db_stack_trace_print(db_expr_t addr, int have_addr, db_expr_t count,
    char *modif, int (*pr)(const char *, ...))
{
	register_t *fp, pc, rp, *argp;
	db_sym_t sym;
	db_expr_t off;
	char *name;
	int nargs;

	if (count < 0)
		count = 65536;

	if (!have_addr) {
		fp = (register_t *)ddb_regs.tf_r3;
		pc = ddb_regs.tf_iioq_head;
		rp = ddb_regs.tf_rp;
	} else {
		fp = (register_t *)addr;
		pc = 0;
		rp = ((register_t *)fp)[-5];
	}

#ifdef DDB_DEBUG
	(*pr) (">> %p, 0x%x, 0x%x\t", fp, pc, rp);
#endif
	while (fp && count--) {

		if (USERMODE(pc))
			return;

		sym = db_search_symbol(pc, DB_STGY_ANY, &off);
		db_symbol_values (sym, &name, NULL);

		(*pr)("%s(", name);

		/* args */
		nargs = 4;
		/*
		 * XXX first four args are passed on registers, and may not
		 * be stored on stack, dunno how to recover their values yet
		 */
		for (argp = &fp[-9]; nargs--; argp--) {
			(*pr)("%x%s", db_get_value((int)argp, 4, FALSE),
				  nargs? ",":"");
		}
		(*pr)(") at ");
		db_printsym(pc, DB_STGY_PROC, pr);
		(*pr)("\n");

		/* TODO: print locals */

		/* next frame */
		pc = rp;
		rp = fp[-5];

		/* if a terminal frame and not a start of a page
		 * then skip the trapframe and the terminal frame */
		if (!fp[0]) {
			struct trapframe *tf;

			tf = (struct trapframe *)((char *)fp - sizeof(*tf));

			if (tf->tf_flags & TFF_SYS)
				(*pr)("-- syscall #%d(%x, %x, %x, %x, ...)\n",
				    tf->tf_t1, tf->tf_arg0, tf->tf_arg1,
				    tf->tf_arg2, tf->tf_arg3);
			else
				(*pr)("-- trap #%d%s\n", tf->tf_flags & 0x3f,
				    (tf->tf_flags & T_USER)? " from user" : "");

			if (!(tf->tf_flags & TFF_LAST)) {
				fp = (register_t *)tf->tf_r3;
				pc = tf->tf_iioq_head;
				rp = tf->tf_rp;
			} else
				fp = 0;
		} else
			fp = (register_t *)fp[0];
#ifdef DDB_DEBUG
		(*pr) (">> %x, %x, %x\t", fp, pc, rp);
#endif
	}

	if (count && pc) {
		db_printsym(pc, DB_STGY_XTRN, pr);
		(*pr)(":\n");
	}
}
@


1.38
log
@ansify function definitions

ok guenther@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.37 2016/03/01 21:35:13 mpi Exp $	*/
d128 1
a128 1
Debugger()
@


1.37
log
@db_sym_numargs() has always been defined to FALSE so nuke it with all
its associated dead code.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.36 2016/02/27 13:08:06 mpi Exp $	*/
d137 1
a137 4
db_read_bytes(addr, size, data)
	vaddr_t addr;
	size_t size;
	char *data;
d146 1
a146 4
db_write_bytes(addr, size, data)
	vaddr_t addr;
	size_t size;
	char *data;
d163 1
a163 2
kdbprinttrap(type, code)
	int type, code;
d178 1
a178 3
db_ktrap(type, code, regs)
	int type, code;
	db_regs_t *regs;
d220 1
a220 2
db_valid_breakpoint(addr)
	db_addr_t addr;
d226 2
a227 6
db_stack_trace_print(addr, have_addr, count, modif, pr)
	db_expr_t	addr;
	int		have_addr;
	db_expr_t	count;
	char		*modif;
	int		(*pr)(const char *, ...);
@


1.36
log
@Rename kdb_trap() into db_ktrap().

The goal is to include it in the list of functions that must not be
instrumented.  All ddb(8) functions should be in this list and have
their names start with 'db_'.

ok visa@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.35 2014/07/13 12:11:01 jasper Exp $	*/
a246 1
	char **argnp, *argnames[HPPA_FRAME_NARGS];
d276 1
a276 6
		nargs = HPPA_FRAME_NARGS;
		argnp = NULL;
		if (db_sym_numargs(sym, &nargs, argnames))
			argnp = argnames;
		else
			nargs = 4;
a281 2
			if (argnp)
				(*pr)("%s=", *argnp++);
@


1.35
log
@use nitems() instead of handrolling something identical

ok mpi@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.34 2014/03/29 18:09:29 guenther Exp $	*/
d182 1
a182 1
 *  kdb_trap - field a BPT trap
d185 1
a185 1
kdb_trap(type, code, regs)
@


1.34
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.33 2013/07/07 14:08:05 deraadt Exp $	*/
d124 1
a124 1
struct db_variable *db_eregs = db_regs + sizeof(db_regs)/sizeof(db_regs[0]);
@


1.33
log
@fix int vs long assumption; ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.32 2005/04/07 00:17:32 mickey Exp $	*/
d132 1
a132 1
		__asm __volatile ("break %0, %1"
@


1.32
log
@fix debug printf
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.31 2004/12/22 20:36:00 mickey Exp $	*/
d243 1
a243 1
	register_t *fp, pc, rp, nargs, *argp;
d248 1
@


1.31
log
@proper DDB_DEBUG
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.30 2004/06/27 14:16:22 mickey Exp $	*/
d263 1
a263 1
	*pr) (">> %p, 0x%x, 0x%x\t", fp, pc, rp);
@


1.30
log
@for a syscall trapframe print out the number and a few args
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.29 2004/04/07 18:24:19 mickey Exp $	*/
d29 1
a29 1
#define DDB_DEBUG
d263 1
a263 1
	/* (*pr) (">> %p, 0x%x, 0x%x\t", fp, pc, rp); */
d326 1
a326 1
		/* (*pr) (">> %x, %x, %x\t", fp, pc, rp); */
@


1.29
log
@update copyright; miod@@ is fine w/ files where he holds it too
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.28 2003/07/15 18:15:41 mickey Exp $	*/
d309 7
a315 2
			(*pr)("-- trap #%d%s\n", tf->tf_flags & 0x3f,
			    (tf->tf_flags & T_USER)? " from user" : "");
@


1.28
log
@hptmask goes away as a register and frees one tmp cr
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.27 2003/03/03 18:28:35 mickey Exp $	*/
d4 1
a4 1
 * Copyright (c) 1999-2002 Michael Shalayeff
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Michael Shalayeff.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d19 8
a26 7
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@


1.27
log
@march through the trapframes on the stack trace until the very last
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.26 2003/02/18 19:01:50 deraadt Exp $	*/
a123 1
	{ "hptm",  (long *)&ddb_regs.tf_hptm,  FCN_NULL },
@


1.26
log
@knf; mickey ok
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.25 2002/09/17 19:15:31 mickey Exp $	*/
d248 1
a248 1
	register_t fp, pc, rp, nargs, *argp;
d258 1
a258 1
		fp = ddb_regs.tf_r3;
d262 1
a262 1
		fp = addr;
d268 1
a268 1
	/* (*pr) (">> %x, %x, %x\t", fp, pc, rp); */
d291 1
a291 1
		for (argp = &((register_t *)fp)[-9]; nargs--; argp--) {
d305 20
a324 2
		rp = ((register_t *)fp)[-5];
		fp = ((register_t *)fp)[0];
a334 1

@


1.25
log
@print out the ccr and rctr
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.24 2002/08/13 03:44:48 mickey Exp $	*/
d225 1
a225 1
	
@


1.24
log
@remove a bogus extern, move another into another scope
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.23 2002/07/25 04:51:40 mickey Exp $	*/
d4 1
a4 1
 * Copyright (c) 1999-2000 Michael Shalayeff
d95 2
@


1.23
log
@better kdbprinttrap() and copy over the frame into the db_regs when already spl-high
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.22 2002/07/23 16:56:52 mickey Exp $	*/
a55 2
extern label_t *db_recover;
extern int db_active;
d192 1
@


1.22
log
@only break in ddb if the kernel has been mapped
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.21 2002/05/18 09:49:17 art Exp $	*/
d177 1
d180 1
a180 1
		db_printf("type %d", type);
d183 1
a183 1
	db_printf(" trap, code=%x\n", code);
d214 1
a215 2

	s = splhigh();
@


1.21
log
@Rename the MD db_stack_trace_cmd to db_stack_trace_print. Add an argument
that specifies which printf funciton it should use. Implement
db_stack_trace_cmd in MI code.

Thanks to miod@@ for all the tests.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.20 2002/05/16 20:16:15 mickey Exp $	*/
d135 4
a138 2
	__asm __volatile ("break	%0, %1"
			  :: "i" (HPPA_BREAK_KERNEL), "i" (HPPA_BREAK_KGDB));
@


1.20
log
@name the registers ignoring the calling conventions
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.19 2002/05/16 13:01:41 art Exp $	*/
d238 1
a238 1
db_stack_trace_cmd(addr, have_addr, count, modif)
d243 1
d265 1
a265 1
	/* db_printf (">> %x, %x, %x\t", fp, pc, rp); */
d275 1
a275 1
		db_printf("%s(", name);
d290 2
a291 2
				db_printf("%s=", *argnp++);
			db_printf("%x%s", db_get_value((int)argp, 4, FALSE),
d294 3
a296 3
		db_printf(") at ");
		db_printsym(pc, DB_STGY_PROC, db_printf);
		db_printf("\n");
d305 1
a305 1
		/* db_printf (">> %x, %x, %x\t", fp, pc, rp); */
d310 2
a311 2
		db_printsym(pc, DB_STGY_XTRN, db_printf);
		db_printf(":\n");
@


1.19
log
@Add a an argument to db_printsym that specifies the printf function
we'll use for printing the information.
miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.18 2002/03/14 03:15:53 millert Exp $	*/
d82 12
a93 12
	{ "t4",    (long *)&ddb_regs.tf_t4,  FCN_NULL },
	{ "t3",    (long *)&ddb_regs.tf_t3,  FCN_NULL },
	{ "t2",    (long *)&ddb_regs.tf_t2,  FCN_NULL },
	{ "t1",    (long *)&ddb_regs.tf_t1,  FCN_NULL },
	{ "arg3",  (long *)&ddb_regs.tf_arg3,  FCN_NULL },
	{ "arg2",  (long *)&ddb_regs.tf_arg2,  FCN_NULL },
	{ "arg1",  (long *)&ddb_regs.tf_arg1,  FCN_NULL },
	{ "arg0",  (long *)&ddb_regs.tf_arg0,  FCN_NULL },
	{ "dp",    (long *)&ddb_regs.tf_dp,    FCN_NULL },
	{ "ret0",  (long *)&ddb_regs.tf_ret0,  FCN_NULL },
	{ "ret1",  (long *)&ddb_regs.tf_ret1,  FCN_NULL },
	{ "sp",    (long *)&ddb_regs.tf_sp,    FCN_NULL },
@


1.18
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.17 2002/03/14 01:26:31 millert Exp $	*/
d294 1
a294 1
		db_printsym(pc, DB_STGY_PROC);
d309 1
a309 1
		db_printsym(pc, DB_STGY_XTRN);
@


1.17
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.16 2001/03/22 23:31:45 mickey Exp $	*/
d145 1
a145 1
	register char *src = (char*)addr;
@


1.16
log
@make sure we stop stack tracing on user pc
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.15 2001/01/30 21:45:32 mickey Exp $	*/
d54 1
a54 1
void kdbprinttrap __P((int, int));
@


1.16.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.16 2001/03/22 23:31:45 mickey Exp $	*/
d54 1
a54 1
void kdbprinttrap(int, int);
d82 12
a93 12
	{ "r19",   (long *)&ddb_regs.tf_t4,  FCN_NULL },
	{ "r20",   (long *)&ddb_regs.tf_t3,  FCN_NULL },
	{ "r21",   (long *)&ddb_regs.tf_t2,  FCN_NULL },
	{ "r22",   (long *)&ddb_regs.tf_t1,  FCN_NULL },
	{ "r23",   (long *)&ddb_regs.tf_arg3,  FCN_NULL },
	{ "r24",   (long *)&ddb_regs.tf_arg2,  FCN_NULL },
	{ "r25",   (long *)&ddb_regs.tf_arg1,  FCN_NULL },
	{ "r26",   (long *)&ddb_regs.tf_arg0,  FCN_NULL },
	{ "r27",   (long *)&ddb_regs.tf_dp,    FCN_NULL },
	{ "r28",   (long *)&ddb_regs.tf_ret0,  FCN_NULL },
	{ "r29",   (long *)&ddb_regs.tf_ret1,  FCN_NULL },
	{ "r30",   (long *)&ddb_regs.tf_sp,    FCN_NULL },
d145 1
a145 1
	register char *src = (char *)addr;
d238 1
a238 1
db_stack_trace_print(addr, have_addr, count, modif, pr)
a242 1
	int		(*pr)(const char *, ...);
d264 1
a264 1
	/* (*pr) (">> %x, %x, %x\t", fp, pc, rp); */
d274 1
a274 1
		(*pr)("%s(", name);
d289 2
a290 2
				(*pr)("%s=", *argnp++);
			(*pr)("%x%s", db_get_value((int)argp, 4, FALSE),
d293 3
a295 3
		(*pr)(") at ");
		db_printsym(pc, DB_STGY_PROC, pr);
		(*pr)("\n");
d304 1
a304 1
		/* (*pr) (">> %x, %x, %x\t", fp, pc, rp); */
d309 2
a310 2
		db_printsym(pc, DB_STGY_XTRN, pr);
		(*pr)(":\n");
@


1.16.6.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.16.6.1 2002/06/11 03:35:37 art Exp $	*/
d4 1
a4 1
 * Copyright (c) 1999-2002 Michael Shalayeff
d56 2
a96 2
	{ "rctr",  (long *)&ddb_regs.tf_rctr,  FCN_NULL },
	{ "ccr",   (long *)&ddb_regs.tf_ccr,   FCN_NULL },
d135 2
a136 4
	extern int kernelmapped;	/* from locore.S */
	if (kernelmapped)
		__asm __volatile ("break %0, %1"
		    :: "i" (HPPA_BREAK_KERNEL), "i" (HPPA_BREAK_KGDB));
a174 1
	type &= ~T_USER;	/* just in case */
d177 1
a177 1
		db_printf("type 0x%x", type);
d180 1
a180 1
	db_printf(" trap, code=0x%x\n", code);
a190 1
	extern label_t *db_recover;
d211 2
a213 1
	ddb_regs = *regs;
@


1.16.6.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d225 1
a225 1

d248 1
a248 1
	register_t *fp, pc, rp, nargs, *argp;
d258 1
a258 1
		fp = (register_t *)ddb_regs.tf_r3;
d262 1
a262 1
		fp = (register_t *)addr;
d268 1
a268 1
	/* (*pr) (">> %p, 0x%x, 0x%x\t", fp, pc, rp); */
d291 1
a291 1
		for (argp = &fp[-9]; nargs--; argp--) {
d305 2
a306 20
		rp = fp[-5];

		/* if a terminal frame and not a start of a page
		 * then skip the trapframe and the terminal frame */
		if (!fp[0]) {
			struct trapframe *tf;

			tf = (struct trapframe *)((char *)fp - sizeof(*tf));

			(*pr)("-- trap #%d%s\n", tf->tf_flags & 0x3f,
			    (tf->tf_flags & T_USER)? " from user" : "");

			if (!(tf->tf_flags & TFF_LAST)) {
				fp = (register_t *)tf->tf_r3;
				pc = tf->tf_iioq_head;
				rp = tf->tf_rp;
			} else
				fp = 0;
		} else
			fp = (register_t *)fp[0];
d317 1
@


1.15
log
@local beef escaped
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.14 2001/01/12 23:08:56 mickey Exp $	*/
a249 3
	if (USERMODE(pc))
		return;

d267 3
@


1.14
log
@do not print pidr3,pidr4 which we do not use anyway
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.13 2000/05/30 22:09:45 mickey Exp $	*/
d247 1
a247 1
	const char *name;
@


1.13
log
@no need to include vm/vm.h
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.12 2000/01/05 18:37:40 mickey Exp $	*/
d119 1
d122 1
d247 1
a247 1
	char *name;
@


1.12
log
@unintended piece escaped
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.11 2000/01/05 18:35:35 mickey Exp $	*/
a36 2

#include <vm/vm.h>
@


1.12.2.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.16 2001/03/22 23:31:45 mickey Exp $	*/
d38 2
a120 1
#ifdef pbably_not_worth_it
a122 1
#endif
d250 3
a269 3

		if (USERMODE(pc))
			return;
@


1.12.2.2
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d54 1
a54 1
void kdbprinttrap(int, int);
d145 1
a145 1
	register char *src = (char *)addr;
@


1.12.2.3
log
@Sync the SMP branch with 3.3
@
text
@d4 1
a4 1
 * Copyright (c) 1999-2002 Michael Shalayeff
d56 2
d82 12
a93 12
	{ "r19",   (long *)&ddb_regs.tf_t4,  FCN_NULL },
	{ "r20",   (long *)&ddb_regs.tf_t3,  FCN_NULL },
	{ "r21",   (long *)&ddb_regs.tf_t2,  FCN_NULL },
	{ "r22",   (long *)&ddb_regs.tf_t1,  FCN_NULL },
	{ "r23",   (long *)&ddb_regs.tf_arg3,  FCN_NULL },
	{ "r24",   (long *)&ddb_regs.tf_arg2,  FCN_NULL },
	{ "r25",   (long *)&ddb_regs.tf_arg1,  FCN_NULL },
	{ "r26",   (long *)&ddb_regs.tf_arg0,  FCN_NULL },
	{ "r27",   (long *)&ddb_regs.tf_dp,    FCN_NULL },
	{ "r28",   (long *)&ddb_regs.tf_ret0,  FCN_NULL },
	{ "r29",   (long *)&ddb_regs.tf_ret1,  FCN_NULL },
	{ "r30",   (long *)&ddb_regs.tf_sp,    FCN_NULL },
a96 2
	{ "rctr",  (long *)&ddb_regs.tf_rctr,  FCN_NULL },
	{ "ccr",   (long *)&ddb_regs.tf_ccr,   FCN_NULL },
d135 2
a136 4
	extern int kernelmapped;	/* from locore.S */
	if (kernelmapped)
		__asm __volatile ("break %0, %1"
		    :: "i" (HPPA_BREAK_KERNEL), "i" (HPPA_BREAK_KGDB));
a174 1
	type &= ~T_USER;	/* just in case */
d177 1
a177 1
		db_printf("type 0x%x", type);
d180 1
a180 1
	db_printf(" trap, code=0x%x\n", code);
a190 1
	extern label_t *db_recover;
d211 2
a213 1
	ddb_regs = *regs;
d222 1
a222 1

d238 1
a238 1
db_stack_trace_print(addr, have_addr, count, modif, pr)
a242 1
	int		(*pr)(const char *, ...);
d244 1
a244 1
	register_t *fp, pc, rp, nargs, *argp;
d254 1
a254 1
		fp = (register_t *)ddb_regs.tf_r3;
d258 1
a258 1
		fp = (register_t *)addr;
d264 1
a264 1
	/* (*pr) (">> %p, 0x%x, 0x%x\t", fp, pc, rp); */
d274 1
a274 1
		(*pr)("%s(", name);
d287 1
a287 1
		for (argp = &fp[-9]; nargs--; argp--) {
d289 2
a290 2
				(*pr)("%s=", *argnp++);
			(*pr)("%x%s", db_get_value((int)argp, 4, FALSE),
d293 3
a295 3
		(*pr)(") at ");
		db_printsym(pc, DB_STGY_PROC, pr);
		(*pr)("\n");
d301 2
a302 20
		rp = fp[-5];

		/* if a terminal frame and not a start of a page
		 * then skip the trapframe and the terminal frame */
		if (!fp[0]) {
			struct trapframe *tf;

			tf = (struct trapframe *)((char *)fp - sizeof(*tf));

			(*pr)("-- trap #%d%s\n", tf->tf_flags & 0x3f,
			    (tf->tf_flags & T_USER)? " from user" : "");

			if (!(tf->tf_flags & TFF_LAST)) {
				fp = (register_t *)tf->tf_r3;
				pc = tf->tf_iioq_head;
				rp = tf->tf_rp;
			} else
				fp = 0;
		} else
			fp = (register_t *)fp[0];
d304 1
a304 1
		/* (*pr) (">> %x, %x, %x\t", fp, pc, rp); */
d309 2
a310 2
		db_printsym(pc, DB_STGY_XTRN, pr);
		(*pr)(":\n");
d313 1
@


1.12.2.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d124 1
@


1.12.2.5
log
@Merge with the trunk
@
text
@d4 1
a4 1
 * Copyright (c) 1999-2003 Michael Shalayeff
d15 5
d24 7
a30 8
 * IN NO EVENT SHALL THE AUTHOR OR HIS RELATIVES BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
@


1.11
log
@missing include
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.10 2000/01/01 22:54:55 mickey Exp $	*/
d247 1
a247 1
	const char *name;
@


1.10
log
@do stop in kdb_trap() based on db_panic value
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.9 1999/11/16 17:08:53 mickey Exp $	*/
d4 1
a4 1
 * Copyright (c) 1999 Michael Shalayeff
d49 1
d247 2
a248 1
	char *name, **argnp, *argnames[HPPA_FRAME_NARGS];
@


1.9
log
@flush the cache once we patched memory in ddb
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.8 1999/09/10 19:56:25 mickey Exp $	*/
d191 16
@


1.8
log
@s/vm_offset_t/vaddr_t/g
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.7 1999/08/14 03:18:29 mickey Exp $	*/
d42 1
a56 1

d160 4
@


1.7
log
@more registers to print and play
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.6 1999/07/21 04:28:36 mickey Exp $	*/
d64 1
d126 1
d140 1
a140 1
	vm_offset_t addr;
d152 1
a152 1
	vm_offset_t addr;
@


1.6
log
@skip break insn in the proper place, print cr28 in ddb, some debugging cruft
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.5 1999/07/12 18:12:49 mickey Exp $	*/
d97 1
d103 4
a124 4
#if 0
	u_int	ccr;	/* cr10 */
	u_int	tr2;	/* cr26 */
#endif
@


1.5
log
@don't resolve NULL at the bottom of the stack trace (parse trapframe later)
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.4 1999/06/22 17:58:27 mickey Exp $	*/
d119 1
a185 4

	/* skip break instruction */
	regs->tf_iioq_head += 4;
	regs->tf_iioq_tail += 4;
@


1.4
log
@do the trace cmd
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.2 1999/02/25 19:19:20 mickey Exp $	*/
d286 1
a286 1
	if (count) {
@


1.3
log
@name changes
@
text
@d33 2
d130 2
a131 1
	__asm("break 0,0");
d186 4
d201 1
d223 67
@


1.2
log
@print hptm (hpt mask) and vtop (virt to phys has table) registers
@
text
@d1 31
a31 1
/*	$OpenBSD: db_interface.c,v 1.1 1998/10/30 18:59:03 mickey Exp $	*/
a32 1
#include <sys/types.h>
d62 52
a113 52
	{ "r1",    (long *)&ddb_regs.r1,  FCN_NULL },
	{ "rp",    (long *)&ddb_regs.rp,  FCN_NULL },
	{ "r3",    (long *)&ddb_regs.r3,  FCN_NULL },
	{ "r4",    (long *)&ddb_regs.r4,  FCN_NULL },
	{ "r5",    (long *)&ddb_regs.r5,  FCN_NULL },
	{ "r6",    (long *)&ddb_regs.r6,  FCN_NULL },
	{ "r7",    (long *)&ddb_regs.r7,  FCN_NULL },
	{ "r8",    (long *)&ddb_regs.r8,  FCN_NULL },
	{ "r9",    (long *)&ddb_regs.r9,  FCN_NULL },
	{ "r10",   (long *)&ddb_regs.r10, FCN_NULL },
	{ "r11",   (long *)&ddb_regs.r11, FCN_NULL },
	{ "r12",   (long *)&ddb_regs.r12, FCN_NULL },
	{ "r13",   (long *)&ddb_regs.r13, FCN_NULL },
	{ "r14",   (long *)&ddb_regs.r14, FCN_NULL },
	{ "r15",   (long *)&ddb_regs.r15, FCN_NULL },
	{ "r16",   (long *)&ddb_regs.r16, FCN_NULL },
	{ "r17",   (long *)&ddb_regs.r17, FCN_NULL },
	{ "r18",   (long *)&ddb_regs.r18, FCN_NULL },
	{ "t4",    (long *)&ddb_regs.t4,  FCN_NULL },
	{ "t3",    (long *)&ddb_regs.t3,  FCN_NULL },
	{ "t2",    (long *)&ddb_regs.t2,  FCN_NULL },
	{ "t1",    (long *)&ddb_regs.t1,  FCN_NULL },
	{ "arg3",  (long *)&ddb_regs.arg3,  FCN_NULL },
	{ "arg2",  (long *)&ddb_regs.arg2,  FCN_NULL },
	{ "arg1",  (long *)&ddb_regs.arg1,  FCN_NULL },
	{ "arg0",  (long *)&ddb_regs.arg0,  FCN_NULL },
	{ "dp",    (long *)&ddb_regs.dp,    FCN_NULL },
	{ "ret0",  (long *)&ddb_regs.ret0,  FCN_NULL },
	{ "ret1",  (long *)&ddb_regs.ret1,  FCN_NULL },
	{ "sp",    (long *)&ddb_regs.sp,    FCN_NULL },
	{ "r31",   (long *)&ddb_regs.r31,   FCN_NULL },
	{ "sar",   (long *)&ddb_regs.sar,   FCN_NULL },

	{ "eiem",  (long *)&ddb_regs.eiem,  FCN_NULL },
	{ "iir",   (long *)&ddb_regs.iir,   FCN_NULL },
	{ "isr",   (long *)&ddb_regs.isr,   FCN_NULL },
	{ "ior",   (long *)&ddb_regs.ior,   FCN_NULL },
	{ "ipsw",  (long *)&ddb_regs.ipsw,  FCN_NULL },

	{ "sr0",   (long *)&ddb_regs.sr0,   FCN_NULL },
	{ "sr1",   (long *)&ddb_regs.sr1,   FCN_NULL },
	{ "sr2",   (long *)&ddb_regs.sr2,   FCN_NULL },
	{ "sr3",   (long *)&ddb_regs.sr3,   FCN_NULL },
	{ "sr4",   (long *)&ddb_regs.sr4,   FCN_NULL },
	{ "sr5",   (long *)&ddb_regs.sr5,   FCN_NULL },
	{ "sr6",   (long *)&ddb_regs.sr6,   FCN_NULL },
	{ "sr7",   (long *)&ddb_regs.sr7,   FCN_NULL },

	{ "pidr1", (long *)&ddb_regs.pidr1, FCN_NULL },
	{ "pidr2", (long *)&ddb_regs.pidr2, FCN_NULL },
	{ "pidr3", (long *)&ddb_regs.pidr3, FCN_NULL },
	{ "pidr4", (long *)&ddb_regs.pidr4, FCN_NULL },
d115 2
a116 2
	{ "hptm",  (long *)&ddb_regs.hptm,  FCN_NULL },
	{ "vtop",  (long *)&ddb_regs.vtop,  FCN_NULL },
d197 4
a214 1

@


1.1
log
@some ddb interface
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d85 3
d89 2
a90 4
	u_int	ccr;	       /* cr10 */
	u_int	ptov;         /* cr24 */
	u_int	tr1;          /* cr25 */
	u_int	tr2;          /* cr26 */
@

