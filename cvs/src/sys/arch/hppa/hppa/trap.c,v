head	1.141;
access;
symbols
	OPENBSD_6_0:1.139.0.2
	OPENBSD_6_0_BASE:1.139
	OPENBSD_5_9:1.138.0.4
	OPENBSD_5_9_BASE:1.138
	OPENBSD_5_8:1.138.0.6
	OPENBSD_5_8_BASE:1.138
	OPENBSD_5_7:1.138.0.2
	OPENBSD_5_7_BASE:1.138
	OPENBSD_5_6:1.136.0.4
	OPENBSD_5_6_BASE:1.136
	OPENBSD_5_5:1.127.0.6
	OPENBSD_5_5_BASE:1.127
	OPENBSD_5_4:1.127.0.2
	OPENBSD_5_4_BASE:1.127
	OPENBSD_5_3:1.126.0.2
	OPENBSD_5_3_BASE:1.126
	OPENBSD_5_2:1.122.0.2
	OPENBSD_5_2_BASE:1.122
	OPENBSD_5_1_BASE:1.121
	OPENBSD_5_1:1.121.0.2
	OPENBSD_5_0:1.118.0.2
	OPENBSD_5_0_BASE:1.118
	OPENBSD_4_9:1.113.0.2
	OPENBSD_4_9_BASE:1.113
	OPENBSD_4_8:1.110.0.2
	OPENBSD_4_8_BASE:1.110
	OPENBSD_4_7:1.104.0.2
	OPENBSD_4_7_BASE:1.104
	OPENBSD_4_6:1.101.0.6
	OPENBSD_4_6_BASE:1.101
	OPENBSD_4_5:1.101.0.2
	OPENBSD_4_5_BASE:1.101
	OPENBSD_4_4:1.100.0.4
	OPENBSD_4_4_BASE:1.100
	OPENBSD_4_3:1.100.0.2
	OPENBSD_4_3_BASE:1.100
	OPENBSD_4_2:1.99.0.2
	OPENBSD_4_2_BASE:1.99
	OPENBSD_4_1:1.97.0.2
	OPENBSD_4_1_BASE:1.97
	OPENBSD_4_0:1.93.0.4
	OPENBSD_4_0_BASE:1.93
	OPENBSD_3_9:1.93.0.2
	OPENBSD_3_9_BASE:1.93
	OPENBSD_3_8:1.88.0.2
	OPENBSD_3_8_BASE:1.88
	OPENBSD_3_7:1.84.0.2
	OPENBSD_3_7_BASE:1.84
	OPENBSD_3_6:1.80.0.2
	OPENBSD_3_6_BASE:1.80
	SMP_SYNC_A:1.76
	SMP_SYNC_B:1.75
	OPENBSD_3_5:1.70.0.2
	OPENBSD_3_5_BASE:1.70
	OPENBSD_3_4:1.68.0.2
	OPENBSD_3_4_BASE:1.68
	UBC_SYNC_A:1.65
	OPENBSD_3_3:1.62.0.2
	OPENBSD_3_3_BASE:1.62
	OPENBSD_3_2:1.51.0.2
	OPENBSD_3_2_BASE:1.51
	OPENBSD_3_1:1.41.0.2
	OPENBSD_3_1_BASE:1.41
	UBC_SYNC_B:1.53
	UBC:1.34.0.2
	UBC_BASE:1.34
	OPENBSD_3_0:1.30.0.2
	OPENBSD_3_0_BASE:1.30
	OPENBSD_2_9:1.27.0.2
	OPENBSD_2_9_BASE:1.27
	OPENBSD_2_8:1.21.0.2
	OPENBSD_2_8_BASE:1.21
	OPENBSD_2_7:1.19.0.4
	OPENBSD_2_7_BASE:1.19
	SMP:1.19.0.2
	SMP_BASE:1.19
	kame_19991208:1.11
	OPENBSD_2_6:1.10.0.2
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.141
date	2016.10.19.08.31.32;	author guenther;	state Exp;
branches;
next	1.140;
commitid	FyYQJQUG0i6W5gNT;

1.140
date	2016.10.08.05.49.08;	author guenther;	state Exp;
branches;
next	1.139;
commitid	z63v1DilayzHcfkw;

1.139
date	2016.02.27.13.08.06;	author mpi;	state Exp;
branches;
next	1.138;
commitid	hnv9KfQtxhCytAnd;

1.138
date	2014.11.16.12.30.57;	author deraadt;	state Exp;
branches;
next	1.137;
commitid	yv0ECmCdICvq576h;

1.137
date	2014.10.08.22.23.57;	author deraadt;	state Exp;
branches;
next	1.136;
commitid	rIzyHyspi1VRtpkn;

1.136
date	2014.07.07.19.01.26;	author miod;	state Exp;
branches;
next	1.135;
commitid	cpi0ANwwd87dxrJC;

1.135
date	2014.06.13.00.02.37;	author tobiasu;	state Exp;
branches;
next	1.134;
commitid	RhZmxi603nLX0zI6;

1.134
date	2014.05.11.00.12.44;	author guenther;	state Exp;
branches;
next	1.133;

1.133
date	2014.05.10.21.58.56;	author deraadt;	state Exp;
branches;
next	1.132;

1.132
date	2014.05.10.05.33.00;	author guenther;	state Exp;
branches;
next	1.131;

1.131
date	2014.05.08.21.32.45;	author miod;	state Exp;
branches;
next	1.130;

1.130
date	2014.04.18.11.51.16;	author guenther;	state Exp;
branches;
next	1.129;

1.129
date	2014.04.08.09.34.23;	author mpi;	state Exp;
branches;
next	1.128;

1.128
date	2014.03.26.05.23.42;	author guenther;	state Exp;
branches;
next	1.127;

1.127
date	2013.04.10.20.55.34;	author miod;	state Exp;
branches;
next	1.126;

1.126
date	2012.12.31.06.46.13;	author guenther;	state Exp;
branches;
next	1.125;

1.125
date	2012.08.29.18.49.56;	author kettenis;	state Exp;
branches;
next	1.124;

1.124
date	2012.08.07.11.17.34;	author kettenis;	state Exp;
branches;
next	1.123;

1.123
date	2012.08.07.05.16.53;	author guenther;	state Exp;
branches;
next	1.122;

1.122
date	2012.04.11.14.38.55;	author mikeb;	state Exp;
branches;
next	1.121;

1.121
date	2011.11.16.20.56.01;	author deraadt;	state Exp;
branches;
next	1.120;

1.120
date	2011.11.16.20.50.18;	author deraadt;	state Exp;
branches;
next	1.119;

1.119
date	2011.11.08.14.02.30;	author miod;	state Exp;
branches;
next	1.118;

1.118
date	2011.07.11.15.40.47;	author guenther;	state Exp;
branches;
next	1.117;

1.117
date	2011.07.07.18.11.23;	author art;	state Exp;
branches;
next	1.116;

1.116
date	2011.07.06.21.41.37;	author art;	state Exp;
branches;
next	1.115;

1.115
date	2011.06.06.14.20.50;	author jsing;	state Exp;
branches;
next	1.114;

1.114
date	2011.04.03.14.56.28;	author guenther;	state Exp;
branches;
next	1.113;

1.113
date	2011.01.23.15.09.12;	author jsing;	state Exp;
branches;
next	1.112;

1.112
date	2010.12.21.14.56.23;	author claudio;	state Exp;
branches;
next	1.111;

1.111
date	2010.11.27.19.57.23;	author miod;	state Exp;
branches;
next	1.110;

1.110
date	2010.07.01.05.33.32;	author jsing;	state Exp;
branches;
next	1.109;

1.109
date	2010.06.26.00.50.03;	author jsing;	state Exp;
branches;
next	1.108;

1.108
date	2010.05.24.15.04.55;	author deraadt;	state Exp;
branches;
next	1.107;

1.107
date	2010.05.09.17.14.20;	author kettenis;	state Exp;
branches;
next	1.106;

1.106
date	2010.03.30.14.57.02;	author kettenis;	state Exp;
branches;
next	1.105;

1.105
date	2010.03.27.14.55.01;	author jsing;	state Exp;
branches;
next	1.104;

1.104
date	2009.12.31.12.52.35;	author jsing;	state Exp;
branches;
next	1.103;

1.103
date	2009.12.29.13.40.09;	author jsing;	state Exp;
branches;
next	1.102;

1.102
date	2009.12.29.13.11.40;	author jsing;	state Exp;
branches;
next	1.101;

1.101
date	2009.02.04.17.23.18;	author miod;	state Exp;
branches;
next	1.100;

1.100
date	2007.09.15.14.55.30;	author krw;	state Exp;
branches;
next	1.99;

1.99
date	2007.05.14.19.54.21;	author martin;	state Exp;
branches;
next	1.98;

1.98
date	2007.03.15.10.22.29;	author art;	state Exp;
branches;
next	1.97;

1.97
date	2007.03.05.17.13.59;	author mickey;	state Exp;
branches;
next	1.96;

1.96
date	2007.01.17.19.30.12;	author mickey;	state Exp;
branches;
next	1.95;

1.95
date	2007.01.15.17.09.50;	author mickey;	state Exp;
branches;
next	1.94;

1.94
date	2006.12.24.20.29.17;	author miod;	state Exp;
branches;
next	1.93;

1.93
date	2005.12.12.18.59.02;	author miod;	state Exp;
branches;
next	1.92;

1.92
date	2005.12.11.21.30.30;	author miod;	state Exp;
branches;
next	1.91;

1.91
date	2005.10.26.18.35.44;	author martin;	state Exp;
branches;
next	1.90;

1.90
date	2005.09.15.21.14.27;	author miod;	state Exp;
branches;
next	1.89;

1.89
date	2005.09.15.21.09.29;	author miod;	state Exp;
branches;
next	1.88;

1.88
date	2005.08.14.10.54.15;	author miod;	state Exp;
branches;
next	1.87;

1.87
date	2005.07.18.02.43.25;	author fgsch;	state Exp;
branches;
next	1.86;

1.86
date	2005.05.26.04.34.52;	author kettenis;	state Exp;
branches;
next	1.85;

1.85
date	2005.04.07.00.23.51;	author mickey;	state Exp;
branches;
next	1.84;

1.84
date	2005.01.17.20.47.40;	author mickey;	state Exp;
branches;
next	1.83;

1.83
date	2005.01.17.19.01.00;	author mickey;	state Exp;
branches;
next	1.82;

1.82
date	2004.12.06.20.12.24;	author miod;	state Exp;
branches;
next	1.81;

1.81
date	2004.09.14.22.44.58;	author mickey;	state Exp;
branches;
next	1.80;

1.80
date	2004.07.13.19.34.23;	author mickey;	state Exp;
branches;
next	1.79;

1.79
date	2004.07.02.04.19.50;	author mickey;	state Exp;
branches;
next	1.78;

1.78
date	2004.06.17.00.30.08;	author mickey;	state Exp;
branches;
next	1.77;

1.77
date	2004.06.16.02.09.55;	author mickey;	state Exp;
branches;
next	1.76;

1.76
date	2004.06.10.21.13.55;	author kettenis;	state Exp;
branches;
next	1.75;

1.75
date	2004.05.13.01.22.56;	author mickey;	state Exp;
branches;
next	1.74;

1.74
date	2004.05.12.22.56.59;	author mickey;	state Exp;
branches;
next	1.73;

1.73
date	2004.04.21.23.09.30;	author mickey;	state Exp;
branches;
next	1.72;

1.72
date	2004.04.07.18.24.19;	author mickey;	state Exp;
branches;
next	1.71;

1.71
date	2004.04.02.20.56.31;	author mickey;	state Exp;
branches;
next	1.70;

1.70
date	2003.12.20.21.49.06;	author miod;	state Exp;
branches;
next	1.69;

1.69
date	2003.10.23.18.33.52;	author miod;	state Exp;
branches;
next	1.68;

1.68
date	2003.08.07.05.19.57;	author mickey;	state Exp;
branches;
next	1.67;

1.67
date	2003.07.26.04.14.56;	author mickey;	state Exp;
branches;
next	1.66;

1.66
date	2003.06.17.04.39.39;	author jfb;	state Exp;
branches;
next	1.65;

1.65
date	2003.04.11.00.25.40;	author mickey;	state Exp;
branches;
next	1.64;

1.64
date	2003.04.11.00.24.09;	author mickey;	state Exp;
branches;
next	1.63;

1.63
date	2003.04.07.17.09.42;	author mickey;	state Exp;
branches;
next	1.62;

1.62
date	2003.02.25.14.04.09;	author miod;	state Exp;
branches;
next	1.61;

1.61
date	2003.02.18.19.01.50;	author deraadt;	state Exp;
branches;
next	1.60;

1.60
date	2003.02.18.09.40.43;	author miod;	state Exp;
branches;
next	1.59;

1.59
date	2003.01.22.18.16.34;	author mickey;	state Exp;
branches;
next	1.58;

1.58
date	2003.01.09.20.48.56;	author mickey;	state Exp;
branches;
next	1.57;

1.57
date	2003.01.08.07.00.58;	author mickey;	state Exp;
branches;
next	1.56;

1.56
date	2003.01.07.19.39.26;	author mickey;	state Exp;
branches;
next	1.55;

1.55
date	2002.12.19.21.08.43;	author mickey;	state Exp;
branches;
next	1.54;

1.54
date	2002.12.17.21.54.25;	author mickey;	state Exp;
branches;
next	1.53;

1.53
date	2002.10.18.19.48.54;	author mickey;	state Exp;
branches;
next	1.52;

1.52
date	2002.10.07.14.38.34;	author mickey;	state Exp;
branches;
next	1.51;

1.51
date	2002.09.23.06.11.46;	author mickey;	state Exp;
branches;
next	1.50;

1.50
date	2002.09.17.03.51.49;	author mickey;	state Exp;
branches;
next	1.49;

1.49
date	2002.09.12.04.36.19;	author mickey;	state Exp;
branches;
next	1.48;

1.48
date	2002.09.11.18.37.29;	author mickey;	state Exp;
branches;
next	1.47;

1.47
date	2002.09.10.22.43.49;	author mickey;	state Exp;
branches;
next	1.46;

1.46
date	2002.08.13.07.00.50;	author mickey;	state Exp;
branches;
next	1.45;

1.45
date	2002.07.25.02.26.17;	author mickey;	state Exp;
branches;
next	1.44;

1.44
date	2002.07.21.11.47.39;	author mickey;	state Exp;
branches;
next	1.43;

1.43
date	2002.05.20.07.59.11;	author mickey;	state Exp;
branches;
next	1.42;

1.42
date	2002.05.16.21.11.14;	author miod;	state Exp;
branches;
next	1.41;

1.41
date	2002.03.16.01.13.42;	author mickey;	state Exp;
branches;
next	1.40;

1.40
date	2002.03.15.21.44.18;	author mickey;	state Exp;
branches;
next	1.39;

1.39
date	2002.03.14.01.26.32;	author millert;	state Exp;
branches;
next	1.38;

1.38
date	2002.02.07.13.54.16;	author mickey;	state Exp;
branches;
next	1.37;

1.37
date	2002.02.06.19.28.18;	author mickey;	state Exp;
branches;
next	1.36;

1.36
date	2002.02.05.04.26.06;	author mickey;	state Exp;
branches;
next	1.35;

1.35
date	2002.02.02.03.07.46;	author mickey;	state Exp;
branches;
next	1.34;

1.34
date	2001.11.28.16.13.28;	author art;	state Exp;
branches
	1.34.2.1;
next	1.33;

1.33
date	2001.11.28.13.47.38;	author art;	state Exp;
branches;
next	1.32;

1.32
date	2001.11.06.20.58.48;	author mickey;	state Exp;
branches;
next	1.31;

1.31
date	2001.11.06.19.53.14;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2001.09.19.20.50.56;	author mickey;	state Exp;
branches;
next	1.29;

1.29
date	2001.09.14.14.58.44;	author art;	state Exp;
branches;
next	1.28;

1.28
date	2001.05.05.20.56.37;	author art;	state Exp;
branches;
next	1.27;

1.27
date	2001.04.01.06.13.40;	author mickey;	state Exp;
branches;
next	1.26;

1.26
date	2001.03.22.23.42.52;	author mickey;	state Exp;
branches;
next	1.25;

1.25
date	2001.01.29.00.01.59;	author mickey;	state Exp;
branches;
next	1.24;

1.24
date	2001.01.22.21.15.23;	author mickey;	state Exp;
branches;
next	1.23;

1.23
date	2000.11.10.18.15.38;	author art;	state Exp;
branches;
next	1.22;

1.22
date	2000.11.08.16.22.36;	author mickey;	state Exp;
branches;
next	1.21;

1.21
date	2000.07.05.22.20.02;	author mickey;	state Exp;
branches;
next	1.20;

1.20
date	2000.06.08.22.25.19;	author niklas;	state Exp;
branches;
next	1.19;

1.19
date	2000.02.10.20.29.09;	author mickey;	state Exp;
branches
	1.19.2.1;
next	1.18;

1.18
date	2000.01.25.22.39.57;	author mickey;	state Exp;
branches;
next	1.17;

1.17
date	2000.01.17.00.30.17;	author mickey;	state Exp;
branches;
next	1.16;

1.16
date	2000.01.12.05.51.02;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	2000.01.11.05.39.52;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	99.12.31.18.27.40;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	99.12.17.01.48.45;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	99.12.08.15.58.27;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	99.11.25.18.36.29;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	99.08.16.04.05.38;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	99.08.16.03.22.58;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	99.08.16.02.48.39;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	99.08.14.03.06.55;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	99.07.21.04.28.36;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	99.07.16.01.59.26;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	99.05.03.16.33.10;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	99.04.20.20.58.01;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	99.01.11.05.11.22;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	99.01.01.16.10.29;	author mickey;	state Exp;
branches;
next	;

1.19.2.1
date	2001.04.18.16.06.16;	author niklas;	state Exp;
branches;
next	1.19.2.2;

1.19.2.2
date	2001.07.04.10.16.05;	author niklas;	state Exp;
branches;
next	1.19.2.3;

1.19.2.3
date	2001.10.31.02.52.47;	author nate;	state Exp;
branches;
next	1.19.2.4;

1.19.2.4
date	2001.11.13.21.00.51;	author niklas;	state Exp;
branches;
next	1.19.2.5;

1.19.2.5
date	2001.12.05.00.39.10;	author niklas;	state Exp;
branches;
next	1.19.2.6;

1.19.2.6
date	2002.03.06.00.57.22;	author niklas;	state Exp;
branches;
next	1.19.2.7;

1.19.2.7
date	2002.03.28.10.19.25;	author niklas;	state Exp;
branches;
next	1.19.2.8;

1.19.2.8
date	2003.03.27.23.26.54;	author niklas;	state Exp;
branches;
next	1.19.2.9;

1.19.2.9
date	2003.05.13.19.41.04;	author ho;	state Exp;
branches;
next	1.19.2.10;

1.19.2.10
date	2004.02.19.10.48.40;	author niklas;	state Exp;
branches;
next	1.19.2.11;

1.19.2.11
date	2004.06.05.23.10.48;	author niklas;	state Exp;
branches;
next	1.19.2.12;

1.19.2.12
date	2004.06.13.08.50.06;	author niklas;	state Exp;
branches;
next	;

1.34.2.1
date	2002.06.11.03.35.37;	author art;	state Exp;
branches;
next	1.34.2.2;

1.34.2.2
date	2002.10.29.00.28.02;	author art;	state Exp;
branches;
next	1.34.2.3;

1.34.2.3
date	2003.05.19.21.49.41;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.141
log
@Change process_{domem,auxv_offset}() to take a process instead of a proc.
Make process_auxv_offset() take and release a reference of the vmspace like
process_domem() does.

ok kettenis@@
@
text
@/*	$OpenBSD: trap.c,v 1.140 2016/10/08 05:49:08 guenther Exp $	*/

/*
 * Copyright (c) 1998-2004 Michael Shalayeff
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR OR HIS RELATIVES BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

/* #define TRAPDEBUG */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/syscall.h>
#include <sys/proc.h>
#include <sys/signalvar.h>
#include <sys/user.h>
#include <sys/syscall_mi.h>

#include <uvm/uvm_extern.h>

#include <machine/autoconf.h>

#ifdef DDB
#ifdef TRAPDEBUG
#include <ddb/db_output.h>
#else
#include <machine/db_machdep.h>
#endif
#endif

static __inline int inst_store(u_int ins) {
	return (ins & 0xf0000000) == 0x60000000 ||	/* st */
	       (ins & 0xf4000200) == 0x24000200 ||	/* fst/cst */
	       (ins & 0xfc000200) == 0x0c000200 ||	/* stby */
	       (ins & 0xfc0003c0) == 0x0c0001c0;	/* ldcw */
}

int	pcxs_unaligned(u_int opcode, vaddr_t va);
#ifdef PTRACE
void	ss_clear_breakpoints(struct proc *p);
#endif

void	ast(struct proc *);

/* single-step breakpoint */
#define SSBREAKPOINT	(HPPA_BREAK_KERNEL | (HPPA_BREAK_SS << 13))

const char *trap_type[] = {
	"invalid",
	"HPMC",
	"power failure",
	"recovery counter",
	"external interrupt",
	"LPMC",
	"ITLB miss fault",
	"instruction protection",
	"Illegal instruction",
	"break instruction",
	"privileged operation",
	"privileged register",
	"overflow",
	"conditional",
	"assist exception",
	"DTLB miss",
	"ITLB non-access miss",
	"DTLB non-access miss",
	"data protection/rights/alignment",
	"data break",
	"TLB dirty",
	"page reference",
	"assist emulation",
	"higher-priv transfer",
	"lower-priv transfer",
	"taken branch",
	"data access rights",
	"data protection",
	"unaligned data ref",
};
int trap_types = sizeof(trap_type)/sizeof(trap_type[0]);

#define	frame_regmap(tf,r)	(((u_int *)(tf))[hppa_regmap[(r)]])
u_char hppa_regmap[32] = {
	offsetof(struct trapframe, tf_pad[0]) / 4,	/* r0 XXX */
	offsetof(struct trapframe, tf_r1) / 4,
	offsetof(struct trapframe, tf_rp) / 4,
	offsetof(struct trapframe, tf_r3) / 4,
	offsetof(struct trapframe, tf_r4) / 4,
	offsetof(struct trapframe, tf_r5) / 4,
	offsetof(struct trapframe, tf_r6) / 4,
	offsetof(struct trapframe, tf_r7) / 4,
	offsetof(struct trapframe, tf_r8) / 4,
	offsetof(struct trapframe, tf_r9) / 4,
	offsetof(struct trapframe, tf_r10) / 4,
	offsetof(struct trapframe, tf_r11) / 4,
	offsetof(struct trapframe, tf_r12) / 4,
	offsetof(struct trapframe, tf_r13) / 4,
	offsetof(struct trapframe, tf_r14) / 4,
	offsetof(struct trapframe, tf_r15) / 4,
	offsetof(struct trapframe, tf_r16) / 4,
	offsetof(struct trapframe, tf_r17) / 4,
	offsetof(struct trapframe, tf_r18) / 4,
	offsetof(struct trapframe, tf_t4) / 4,
	offsetof(struct trapframe, tf_t3) / 4,
	offsetof(struct trapframe, tf_t2) / 4,
	offsetof(struct trapframe, tf_t1) / 4,
	offsetof(struct trapframe, tf_arg3) / 4,
	offsetof(struct trapframe, tf_arg2) / 4,
	offsetof(struct trapframe, tf_arg1) / 4,
	offsetof(struct trapframe, tf_arg0) / 4,
	offsetof(struct trapframe, tf_dp) / 4,
	offsetof(struct trapframe, tf_ret0) / 4,
	offsetof(struct trapframe, tf_ret1) / 4,
	offsetof(struct trapframe, tf_sp) / 4,
	offsetof(struct trapframe, tf_r31) / 4,
};

void
ast(struct proc *p)
{
	if (p->p_md.md_astpending) {
		p->p_md.md_astpending = 0;
		uvmexp.softs++;
		mi_ast(p, curcpu()->ci_want_resched);
	}

}

void
trap(int type, struct trapframe *frame)
{
	struct proc *p = curproc;
	vaddr_t va;
	struct vm_map *map;
	struct vmspace *vm;
	register vm_prot_t vftype;
	register pa_space_t space;
	union sigval sv;
	u_int opcode;
	int ret, trapnum;
	const char *tts;
	vm_fault_t fault = VM_FAULT_INVALID;
#ifdef DIAGNOSTIC
	int oldcpl = curcpu()->ci_cpl;
#endif

	trapnum = type & ~T_USER;
	opcode = frame->tf_iir;
	if (trapnum <= T_EXCEPTION || trapnum == T_HIGHERPL ||
	    trapnum == T_LOWERPL || trapnum == T_TAKENBR ||
	    trapnum == T_IDEBUG || trapnum == T_PERFMON) {
		va = frame->tf_iioq_head;
		space = frame->tf_iisq_head;
		vftype = PROT_EXEC;
	} else {
		va = frame->tf_ior;
		space = frame->tf_isr;
		if (va == frame->tf_iioq_head)
			vftype = PROT_EXEC;
		else if (inst_store(opcode))
			vftype = PROT_WRITE;
		else
			vftype = PROT_READ;
	}

	if (frame->tf_flags & TFF_LAST)
		p->p_md.md_regs = frame;

	if (trapnum > trap_types)
		tts = "reserved";
	else
		tts = trap_type[trapnum];

#ifdef TRAPDEBUG
	if (trapnum != T_INTERRUPT && trapnum != T_IBREAK)
		db_printf("trap: %x, %s for %x:%x at %x:%x, fl=%x, fp=%p\n",
		    type, tts, space, va, frame->tf_iisq_head,
		    frame->tf_iioq_head, frame->tf_flags, frame);
	else if (trapnum  == T_IBREAK)
		db_printf("trap: break instruction %x:%x at %x:%x, fp=%p\n",
		    break5(opcode), break13(opcode),
		    frame->tf_iisq_head, frame->tf_iioq_head, frame);

	{
		extern int etext;
		if (frame < (struct trapframe *)&etext) {
			printf("trap: bogus frame ptr %p\n", frame);
			goto dead_end;
		}
	}
#endif
	if (trapnum != T_INTERRUPT) {
		uvmexp.traps++;
		mtctl(frame->tf_eiem, CR_EIEM);
	}

	if (type & T_USER)
		refreshcreds(p);

	switch (type) {
	case T_NONEXIST:
	case T_NONEXIST | T_USER:
		/* we've got screwed up by the central scrutinizer */
		printf("trap: elvis has just left the building!\n");
		goto dead_end;

	case T_RECOVERY:
	case T_RECOVERY | T_USER:
		/* XXX will implement later */
		printf("trap: handicapped");
		goto dead_end;

#ifdef DIAGNOSTIC
	case T_EXCEPTION:
		panic("FPU/SFU emulation botch");

		/* these just can't happen ever */
	case T_PRIV_OP:
	case T_PRIV_REG:
		/* these just can't make it to the trap() ever */
	case T_HPMC:
	case T_HPMC | T_USER:
#endif
	case T_IBREAK:
	case T_DATALIGN:
	case T_DBREAK:
	dead_end:
#ifdef DDB
		if (db_ktrap(type, va, frame)) {
			if (type == T_IBREAK) {
				/* skip break instruction */
				frame->tf_iioq_head = frame->tf_iioq_tail;
				frame->tf_iioq_tail += 4;
			}
			return;
		}
#else
		if (type == T_DATALIGN || type == T_DPROT)
			panic ("trap: %s at 0x%lx", tts, va);
		else
			panic ("trap: no debugger for \"%s\" (%d)", tts, type);
#endif
		break;

	case T_IBREAK | T_USER:
	case T_DBREAK | T_USER: {
		int code = TRAP_BRKPT;

		KERNEL_LOCK();
#ifdef PTRACE
		ss_clear_breakpoints(p);
		if (opcode == SSBREAKPOINT)
			code = TRAP_TRACE;
#endif
		/* pass to user debugger */
		trapsignal(p, SIGTRAP, type & ~T_USER, code, sv);
		KERNEL_UNLOCK();
		}
		break;

#ifdef PTRACE
	case T_TAKENBR | T_USER:
		KERNEL_LOCK();
		ss_clear_breakpoints(p);
		/* pass to user debugger */
		trapsignal(p, SIGTRAP, type & ~T_USER, TRAP_TRACE, sv);
		KERNEL_UNLOCK();
		break;
#endif

	case T_EXCEPTION | T_USER: {
		struct hppa_fpstate *hfp;
		u_int64_t *fpp;
		u_int32_t *pex;
		int i, flt;

		hfp = (struct hppa_fpstate *)frame->tf_cr30;
		fpp = (u_int64_t *)&hfp->hfp_regs;

		pex = (u_int32_t *)&fpp[0];
		for (i = 0, pex++; i < 7 && !*pex; i++, pex++);
		flt = 0;
		if (i < 7) {
			u_int32_t stat = HPPA_FPU_OP(*pex);
			if (stat & HPPA_FPU_UNMPL)
				flt = FPE_FLTINV;
			else if (stat & (HPPA_FPU_V << 1))
				flt = FPE_FLTINV;
			else if (stat & (HPPA_FPU_Z << 1))
				flt = FPE_FLTDIV;
			else if (stat & (HPPA_FPU_I << 1))
				flt = FPE_FLTRES;
			else if (stat & (HPPA_FPU_O << 1))
				flt = FPE_FLTOVF;
			else if (stat & (HPPA_FPU_U << 1))
				flt = FPE_FLTUND;
			/* still left: under/over-flow w/ inexact */

			/* cleanup exceptions (XXX deliver all ?) */
			while (i++ < 7)
				*pex++ = 0;
		}
		/* reset the trap flag, as if there was none */
		fpp[0] &= ~(((u_int64_t)HPPA_FPU_T) << 32);

		sv.sival_int = va;
		KERNEL_LOCK();
		trapsignal(p, SIGFPE, type & ~T_USER, flt, sv);
		KERNEL_UNLOCK();
		}
		break;

	case T_EMULATION:
		panic("trap: emulation trap in the kernel");
		break;

	case T_EMULATION | T_USER:
		sv.sival_int = va;
		KERNEL_LOCK();
		trapsignal(p, SIGILL, type & ~T_USER, ILL_COPROC, sv);
		KERNEL_UNLOCK();
		break;

	case T_OVERFLOW | T_USER:
		sv.sival_int = va;
		KERNEL_LOCK();
		trapsignal(p, SIGFPE, type & ~T_USER, FPE_INTOVF, sv);
		KERNEL_UNLOCK();
		break;

	case T_CONDITION | T_USER:
		sv.sival_int = va;
		KERNEL_LOCK();
		trapsignal(p, SIGFPE, type & ~T_USER, FPE_INTDIV, sv);
		KERNEL_UNLOCK();
		break;

	case T_PRIV_OP | T_USER:
		sv.sival_int = va;
		KERNEL_LOCK();
		trapsignal(p, SIGILL, type & ~T_USER, ILL_PRVOPC, sv);
		KERNEL_UNLOCK();
		break;

	case T_PRIV_REG | T_USER:
		/*
		 * On PCXS processors, attempting to read control registers
		 * cr26 and cr27 from userland causes a ``privileged register''
		 * trap.  Later processors do not restrict read accesses to
		 * these registers.
		 */
		if (cpu_type == hpcxs &&
		    (opcode & (0xfc1fffe0 | (0x1e << 21))) ==
		     (0x000008a0 | (0x1a << 21))) { /* mfctl %cr{26,27}, %r# */
			register_t cr;

			if (((opcode >> 21) & 0x1f) == 27)
				mfctl(CR_TR3, cr);	/* cr27 */
			else
				mfctl(CR_TR2, cr);	/* cr26 */
			frame_regmap(frame, opcode & 0x1f) = cr;
			frame->tf_ipsw |= PSL_N;
		} else {
			sv.sival_int = va;
			KERNEL_LOCK();
			trapsignal(p, SIGILL, type & ~T_USER, ILL_PRVREG, sv);
			KERNEL_UNLOCK();
		}
		break;

		/* these should never got here */
	case T_HIGHERPL | T_USER:
	case T_LOWERPL | T_USER:
	case T_DATAPID | T_USER:
		sv.sival_int = va;
		KERNEL_LOCK();
		trapsignal(p, SIGSEGV, vftype, SEGV_ACCERR, sv);
		KERNEL_UNLOCK();
		break;

	/*
	 * On PCXS processors, traps T_DATACC, T_DATAPID and T_DATALIGN
	 * are shared.  We need to sort out the unaligned access situation
	 * first, before handling this trap as T_DATACC.
	 */
	case T_DPROT | T_USER:
		if (cpu_type == hpcxs) {
			if (pcxs_unaligned(opcode, va))
				goto datalign_user;
			else
				goto datacc;
		}

		sv.sival_int = va;
		KERNEL_LOCK();
		trapsignal(p, SIGSEGV, vftype, SEGV_ACCERR, sv);
		KERNEL_UNLOCK();
		break;

	case T_ITLBMISSNA:
	case T_ITLBMISSNA | T_USER:
	case T_DTLBMISSNA:
	case T_DTLBMISSNA | T_USER:
		if (space == HPPA_SID_KERNEL)
			map = kernel_map;
		else {
			vm = p->p_vmspace;
			map = &vm->vm_map;
		}

		if ((opcode & 0xfc003fc0) == 0x04001340) {
			/* lpa failure case */
			frame_regmap(frame, opcode & 0x1f) = 0;
			frame->tf_ipsw |= PSL_N;
		} else if ((opcode & 0xfc001f80) == 0x04001180) {
			int pl;

			/* dig probe[rw]i? insns */
			if (opcode & 0x2000)
				pl = (opcode >> 16) & 3;
			else
				pl = frame_regmap(frame,
				    (opcode >> 16) & 0x1f) & 3;

			KERNEL_LOCK();

			if ((type & T_USER && space == HPPA_SID_KERNEL) ||
			    (frame->tf_iioq_head & 3) != pl ||
			    (type & T_USER && va >= VM_MAXUSER_ADDRESS) ||
			    uvm_fault(map, trunc_page(va), fault,
			     opcode & 0x40? PROT_WRITE : PROT_READ)) {
				frame_regmap(frame, opcode & 0x1f) = 0;
				frame->tf_ipsw |= PSL_N;
			}

			KERNEL_UNLOCK();
		} else if (type & T_USER) {
			sv.sival_int = va;
			KERNEL_LOCK();
			trapsignal(p, SIGILL, type & ~T_USER, ILL_ILLTRP, sv);
			KERNEL_UNLOCK();
		} else
			panic("trap: %s @@ 0x%lx:0x%lx for 0x%x:0x%lx irr 0x%08x",
			    tts, frame->tf_iisq_head, frame->tf_iioq_head,
			    space, va, opcode);
		break;

	case T_IPROT | T_USER:
	case T_TLB_DIRTY:
	case T_TLB_DIRTY | T_USER:
	case T_DATACC:
	case T_DATACC | T_USER:
datacc:
		fault = VM_FAULT_PROTECT;
	case T_ITLBMISS:
	case T_ITLBMISS | T_USER:
	case T_DTLBMISS:
	case T_DTLBMISS | T_USER:
		/*
		 * it could be a kernel map for exec_map faults
		 */
		if (space == HPPA_SID_KERNEL)
			map = kernel_map;
		else {
			vm = p->p_vmspace;
			map = &vm->vm_map;
		}

		/*
		 * user faults out of user addr space are always a fail,
		 * this happens on va >= VM_MAXUSER_ADDRESS, where
		 * space id will be zero and therefore cause
		 * a misbehave lower in the code.
		 *
		 * also check that faulted space id matches the curproc.
		 */
		if ((type & T_USER && va >= VM_MAXUSER_ADDRESS) ||
		   (type & T_USER && map->pmap->pm_space != space)) {
			sv.sival_int = va;
			KERNEL_LOCK();
			trapsignal(p, SIGSEGV, vftype, SEGV_MAPERR, sv);
			KERNEL_UNLOCK();
			break;
		}

		KERNEL_LOCK();

		ret = uvm_fault(map, trunc_page(va), fault, vftype);

		/*
		 * If this was a stack access we keep track of the maximum
		 * accessed stack size.  Also, if uvm_fault gets a protection
		 * failure it is due to accessing the stack region outside
		 * the current limit and we need to reflect that as an access
		 * error.
		 */
		if (space != HPPA_SID_KERNEL &&
		    va < (vaddr_t)vm->vm_minsaddr) {
			if (ret == 0)
				uvm_grow(p, va);
			else if (ret == EACCES)
				ret = EFAULT;
		}

		KERNEL_UNLOCK();

		if (ret != 0) {
			if (type & T_USER) {
				sv.sival_int = va;
				KERNEL_LOCK();
				trapsignal(p, SIGSEGV, vftype,
				    ret == EACCES? SEGV_ACCERR : SEGV_MAPERR,
				    sv);
				KERNEL_UNLOCK();
			} else {
				if (p && p->p_addr->u_pcb.pcb_onfault) {
					frame->tf_iioq_tail = 4 +
					    (frame->tf_iioq_head =
						p->p_addr->u_pcb.pcb_onfault);
#ifdef DDB
					frame->tf_iir = 0;
#endif
				} else {
					panic("trap: "
					    "uvm_fault(%p, %lx, %d, %d): %d",
					    map, va, fault, vftype, ret);
				}
			}
		}
		break;

	case T_DATAPID:
		/* This should never happen, unless within spcopy() */
		if (p && p->p_addr->u_pcb.pcb_onfault) {
			frame->tf_iioq_tail = 4 +
			    (frame->tf_iioq_head =
				p->p_addr->u_pcb.pcb_onfault);
#ifdef DDB
			frame->tf_iir = 0;
#endif
		} else
			goto dead_end;
		break;

	case T_DATALIGN | T_USER:
datalign_user:
		sv.sival_int = va;
		KERNEL_LOCK();
		trapsignal(p, SIGBUS, vftype, BUS_ADRALN, sv);
		KERNEL_UNLOCK();
		break;

	case T_INTERRUPT:
	case T_INTERRUPT | T_USER:
		cpu_intr(frame);
		break;

	case T_CONDITION:
		panic("trap: divide by zero in the kernel");
		break;

	case T_ILLEGAL:
	case T_ILLEGAL | T_USER:
		/* see if it's a SPOP1,,0 */
		if ((opcode & 0xfffffe00) == 0x10000200) {
			frame_regmap(frame, opcode & 0x1f) = 0;
			frame->tf_ipsw |= PSL_N;
			break;
		}
		if (type & T_USER) {
			sv.sival_int = va;
			KERNEL_LOCK();
			trapsignal(p, SIGILL, type & ~T_USER, ILL_ILLOPC, sv);
			KERNEL_UNLOCK();
			break;
		}
		/* FALLTHROUGH */

	/*
	 * On PCXS processors, traps T_DATACC, T_DATAPID and T_DATALIGN
	 * are shared.  We need to sort out the unaligned access situation
	 * first, before handling this trap as T_DATACC.
	 */
	case T_DPROT:
		if (cpu_type == hpcxs) {
			if (pcxs_unaligned(opcode, va))
				goto dead_end;
			else
				goto datacc;
		}
		/* FALLTHROUGH to unimplemented */

	case T_LOWERPL:
	case T_IPROT:
	case T_OVERFLOW:
	case T_HIGHERPL:
	case T_TAKENBR:
	case T_POWERFAIL:
	case T_LPMC:
	case T_PAGEREF:
		/* FALLTHROUGH to unimplemented */
	default:
#ifdef TRAPDEBUG
		if (db_ktrap(type, va, frame))
			return;
#endif
		panic("trap: unimplemented \'%s\' (%d)", tts, trapnum);
	}

#ifdef DIAGNOSTIC
	if (curcpu()->ci_cpl != oldcpl)
		printf("WARNING: SPL (%d) NOT LOWERED ON "
		    "TRAP (%d) EXIT\n", curcpu()->ci_cpl, trapnum);
#endif

	if (trapnum != T_INTERRUPT)
		splx(curcpu()->ci_cpl);	/* process softints */

	/*
	 * in case we were interrupted from the syscall gate page
	 * treat this as we were not really running user code no more
	 * for weird things start to happen on return to the userland
	 * and also see a note in locore.S:TLABEL(all)
	 */
	if ((type & T_USER) && !(frame->tf_iisq_head == HPPA_SID_KERNEL &&
	    (frame->tf_iioq_head & ~PAGE_MASK) == SYSCALLGATE)) {
		ast(p);
		userret(p);
	}
}

void
child_return(void *arg)
{
	struct proc *p = (struct proc *)arg;
	struct trapframe *tf = p->p_md.md_regs;

	/*
	 * Set up return value registers as libc:fork() expects
	 */
	tf->tf_ret0 = 0;
	tf->tf_ret1 = 1;	/* ischild */
	tf->tf_t1 = 0;		/* errno */

	KERNEL_UNLOCK();

	ast(p);

	mi_child_return(p);
}

#ifdef PTRACE

#include <sys/ptrace.h>

int	ss_get_value(struct proc *p, vaddr_t addr, u_int *value);
int	ss_put_value(struct proc *p, vaddr_t addr, u_int value);

int
ss_get_value(struct proc *p, vaddr_t addr, u_int *value)
{
	struct uio uio;
	struct iovec iov;

	iov.iov_base = (caddr_t)value;
	iov.iov_len = sizeof(u_int);
	uio.uio_iov = &iov;
	uio.uio_iovcnt = 1;
	uio.uio_offset = (off_t)addr;
	uio.uio_resid = sizeof(u_int);
	uio.uio_segflg = UIO_SYSSPACE;
	uio.uio_rw = UIO_READ;
	uio.uio_procp = curproc;
	return (process_domem(curproc, p->p_p, &uio, PT_READ_I));
}

int
ss_put_value(struct proc *p, vaddr_t addr, u_int value)
{
	struct uio uio;
	struct iovec iov;

	iov.iov_base = (caddr_t)&value;
	iov.iov_len = sizeof(u_int);
	uio.uio_iov = &iov;
	uio.uio_iovcnt = 1;
	uio.uio_offset = (off_t)addr;
	uio.uio_resid = sizeof(u_int);
	uio.uio_segflg = UIO_SYSSPACE;
	uio.uio_rw = UIO_WRITE;
	uio.uio_procp = curproc;
	return (process_domem(curproc, p->p_p, &uio, PT_WRITE_I));
}

void
ss_clear_breakpoints(struct proc *p)
{
	/* Restore origional instructions. */
	if (p->p_md.md_bpva != 0) {
		ss_put_value(p, p->p_md.md_bpva, p->p_md.md_bpsave[0]);
		ss_put_value(p, p->p_md.md_bpva + 4, p->p_md.md_bpsave[1]);
		p->p_md.md_bpva = 0;
	}
}

int
process_sstep(struct proc *p, int sstep)
{
	int error;

	ss_clear_breakpoints(p);

	if (sstep == 0) {
		p->p_md.md_regs->tf_ipsw &= ~PSL_T;
		return (0);
	}

	/*
	 * Don't touch the syscall gateway page.  Instead, insert a
	 * breakpoint where we're supposed to return.
	 */
	if ((p->p_md.md_regs->tf_iioq_tail & ~PAGE_MASK) == SYSCALLGATE)
		p->p_md.md_bpva = p->p_md.md_regs->tf_r31 & ~HPPA_PC_PRIV_MASK;
	else
		p->p_md.md_bpva = p->p_md.md_regs->tf_iioq_tail & ~HPPA_PC_PRIV_MASK;

	/*
	 * Insert two breakpoint instructions; the first one might be
	 * nullified.  Of course we need to save two instruction
	 * first.
	 */

	error = ss_get_value(p, p->p_md.md_bpva, &p->p_md.md_bpsave[0]);
	if (error)
		return (error);
	error = ss_get_value(p, p->p_md.md_bpva + 4, &p->p_md.md_bpsave[1]);
	if (error)
		return (error);

	error = ss_put_value(p, p->p_md.md_bpva, SSBREAKPOINT);
	if (error)
		return (error);
	error = ss_put_value(p, p->p_md.md_bpva + 4, SSBREAKPOINT);
	if (error)
		return (error);

	if ((p->p_md.md_regs->tf_iioq_tail & ~PAGE_MASK) != SYSCALLGATE)
		p->p_md.md_regs->tf_ipsw |= PSL_T;
	else
		p->p_md.md_regs->tf_ipsw &= ~PSL_T;

	return (0);
}

#endif	/* PTRACE */

void	syscall(struct trapframe *frame);

/*
 * call actual syscall routine
 */
void
syscall(struct trapframe *frame)
{
	register struct proc *p = curproc;
	register const struct sysent *callp;
	int retq, nsys, code, argsize, argoff, error;
	register_t args[8], rval[2];
#ifdef DIAGNOSTIC
	int oldcpl = curcpu()->ci_cpl;
#endif

	uvmexp.syscalls++;

	if (!USERMODE(frame->tf_iioq_head))
		panic("syscall");

	p->p_md.md_regs = frame;
	nsys = p->p_p->ps_emul->e_nsysent;
	callp = p->p_p->ps_emul->e_sysent;

	argoff = 4; retq = 0;
	switch (code = frame->tf_t1) {
	case SYS_syscall:
		code = frame->tf_arg0;
		args[0] = frame->tf_arg1;
		args[1] = frame->tf_arg2;
		args[2] = frame->tf_arg3;
		argoff = 3;
		break;
	case SYS___syscall:
		if (callp != sysent)
			break;
		/*
		 * this works, because quads get magically swapped
		 * due to the args being laid backwards on the stack
		 * and then copied in words
		 */
		code = frame->tf_arg0;
		args[0] = frame->tf_arg2;
		args[1] = frame->tf_arg3;
		argoff = 2;
		retq = 1;
		break;
	default:
		args[0] = frame->tf_arg0;
		args[1] = frame->tf_arg1;
		args[2] = frame->tf_arg2;
		args[3] = frame->tf_arg3;
		break;
	}

	if (code < 0 || code >= nsys)
		callp += p->p_p->ps_emul->e_nosys;	/* bad syscall # */
	else
		callp += code;

	if ((argsize = callp->sy_argsize)) {
		register_t *s, *e, t;
		int i;

		argsize -= argoff * 4;
		if (argsize > 0) {
			i = argsize / 4;
			if ((error = copyin((void *)(frame->tf_sp +
			    HPPA_FRAME_ARG(4 + i - 1)), args + argoff,
			    argsize)))
				goto bad;
			/* reverse the args[] entries */
			s = args + argoff;
			e = s + i - 1;
			while (s < e) {
				t = *s;
				*s = *e;
				*e = t;
				s++, e--;
			}
		}

		/*
		 * System calls with 64-bit arguments need a word swap
		 * due to the order of the arguments on the stack.
		 */
		i = 0;
		switch (code) {
		case SYS_lseek:		retq = 0;
		case SYS_truncate:
		case SYS_ftruncate:	i = 2;	break;
		case SYS_preadv:
		case SYS_pwritev:
		case SYS_pread:
		case SYS_pwrite:	i = 4;	break;
		case SYS_mquery:
		case SYS_mmap:		i = 6;	break;
		}

		if (i) {
			t = args[i];
			args[i] = args[i + 1];
			args[i + 1] = t;
		}
	}

	rval[0] = 0;
	rval[1] = frame->tf_ret1;

	error = mi_syscall(p, code, callp, args, rval);

	switch (error) {
	case 0:
		frame->tf_ret0 = rval[0];
		frame->tf_ret1 = rval[!retq];
		frame->tf_t1 = 0;
		break;
	case ERESTART:
		frame->tf_iioq_head -= 12;
		frame->tf_iioq_tail -= 12;
	case EJUSTRETURN:
		break;
	default:
	bad:
		frame->tf_t1 = error;
		frame->tf_ret0 = error;
		frame->tf_ret1 = 0;
		break;
	}

	ast(p);

	mi_syscall_return(p, code, error, rval);

#ifdef DIAGNOSTIC
	if (curcpu()->ci_cpl != oldcpl) {
		printf("WARNING: SPL (0x%x) NOT LOWERED ON "
		    "syscall(0x%x, 0x%lx, 0x%lx, 0x%lx...) EXIT, PID %d\n",
		    curcpu()->ci_cpl, code, args[0], args[1], args[2],
		    p->p_p->ps_pid);
		curcpu()->ci_cpl = oldcpl;
	}
#endif
	splx(curcpu()->ci_cpl);	/* process softints */
}

/*
 * Decide if opcode `opcode' accessing virtual address `va' caused an
 * unaligned trap. Returns zero if the access is correctly aligned.
 * Used on PCXS processors to sort out exception causes.
 */
int
pcxs_unaligned(u_int opcode, vaddr_t va)
{
	u_int mbz_bits;

	/*
	 * Exit early if the va is obviously aligned enough.
	 */
	if ((va & 0x0f) == 0)
		return 0;

	mbz_bits = 0;

	/*
	 * Only load and store instructions can cause unaligned access.
	 * There are three opcode patterns to look for:
	 * - canonical load/store
	 * - load/store short or indexed
	 * - coprocessor load/store
	 */

	if ((opcode & 0xd0000000) == 0x40000000) {
		switch ((opcode >> 26) & 0x03) {
		case 0x00:	/* ldb, stb */
			mbz_bits = 0x00;
			break;
		case 0x01:	/* ldh, sth */
			mbz_bits = 0x01;
			break;
		case 0x02:	/* ldw, stw */
		case 0x03:	/* ldwm, stwm */
			mbz_bits = 0x03;
			break;
		}
	} else

	if ((opcode & 0xfc000000) == 0x0c000000) {
		switch ((opcode >> 6) & 0x0f) {
		case 0x01:	/* ldhx, ldhs */
			mbz_bits = 0x01;
			break;
		case 0x02:	/* ldwx, ldws */
			mbz_bits = 0x03;
			break;
		case 0x07:	/* ldcwx, ldcws */
			mbz_bits = 0x0f;
			break;
		case 0x09:
			if ((opcode & (1 << 12)) != 0)	/* sths */
				mbz_bits = 0x01;
			break;
		case 0x0a:
			if ((opcode & (1 << 12)) != 0)	/* stws */
				mbz_bits = 0x03;
			break;
		}
	} else

	if ((opcode & 0xf4000000) == 0x24000000) {
		if ((opcode & (1 << 27)) != 0) {
			/* cldwx, cstwx, cldws, cstws */
			mbz_bits = 0x03;
		} else {
			/* clddx, cstdx, cldds, cstds */
			mbz_bits = 0x07;
		}
	}

	return (va & mbz_bits);
}
@


1.140
log
@Various printf claim to report the PID, so actually report that and not the TID

Build testing assistance from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.139 2016/02/27 13:08:06 mpi Exp $	*/
d693 1
a693 1
	return (process_domem(curproc, p, &uio, PT_READ_I));
d711 1
a711 1
	return (process_domem(curproc, p, &uio, PT_WRITE_I));
@


1.139
log
@Rename kdb_trap() into db_ktrap().

The goal is to include it in the list of functions that must not be
instrumented.  All ddb(8) functions should be in this list and have
their names start with 'db_'.

ok visa@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.138 2014/11/16 12:30:57 deraadt Exp $	*/
d916 1
a916 1
		    p->p_pid);
@


1.138
log
@Replace a plethora of historical protection options with just
PROT_NONE, PROT_READ, PROT_WRITE, and PROT_EXEC from mman.h.
PROT_MASK is introduced as the one true way of extracting those bits.
Remove UVM_ADV_* wrapper, using the standard names.
ok doug guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.137 2014/10/08 22:23:57 deraadt Exp $	*/
d248 1
a248 1
		if (kdb_trap(type, va, frame)) {
d623 1
a623 1
		if (kdb_trap(type, va, frame))
@


1.137
log
@#ifndef DDB, correct a format string..
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.136 2014/07/07 19:01:26 miod Exp $	*/
d173 1
a173 1
		vftype = UVM_PROT_EXEC;
d178 1
a178 1
			vftype = UVM_PROT_EXEC;
d180 1
a180 1
			vftype = UVM_PROT_WRITE;
d182 1
a182 1
			vftype = UVM_PROT_READ;
d450 1
a450 1
			     opcode & 0x40? UVM_PROT_WRITE : UVM_PROT_READ)) {
@


1.136
log
@Do the 64-bit argument swap dance, for the syscalls which require it,
unconditionaly instead of only doing it if invoked indirectly through syscall
or __syscall.

While there, tweak stack argument fetching to only perform one large copyin()
call, rather than a loop of small ones.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.135 2014/06/13 00:02:37 tobiasu Exp $	*/
d258 1
a258 1
			panic ("trap: %s at 0x%x", tts, va);
@


1.135
log
@Fix ptrace() hanging hppa MP systems

Fiddling with uvm, registers and breakpoints requires taking the kernel lock
Problem spotted by tedu@@

ok kettenis@@ deraadt@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.134 2014/05/11 00:12:44 guenther Exp $	*/
d838 1
d841 3
a843 2
		for (i = 0, argsize -= argoff * 4;
		    argsize > 0; i++, argsize -= 4) {
d845 2
a846 1
			    HPPA_FRAME_ARG(i + 4)), args + i + argoff, 4)))
d848 9
d860 2
a861 7
		 * coming from syscall() or __syscall we must be
		 * having one of those w/ a 64 bit arguments,
		 * which needs a word swap due to the order
		 * of the arguments on the stack.
		 * this assumes that none of 'em are called
		 * by their normal syscall number, maybe a regress
		 * test should be used, to watch the behaviour.
d863 17
a879 21
		if (argoff < 4) {
			int t;

			i = 0;
			switch (code) {
			case SYS_lseek:		retq = 0;
			case SYS_truncate:
			case SYS_ftruncate:	i = 2;	break;
			case SYS_preadv:
			case SYS_pwritev:
			case SYS_pread:
			case SYS_pwrite:	i = 4;	break;
			case SYS_mquery:
			case SYS_mmap:		i = 6;	break;
			}

			if (i) {
				t = args[i];
				args[i] = args[i + 1];
				args[i + 1] = t;
			}
@


1.134
log
@Move the increment of uvmexp.softs back to the caller of mi_ast():
it needs to be done atomicly on some MP archs and we don't have
atomic_add_int() everywhere yet.  Also, mi_ast() was meant to be inline.

noted by miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.133 2014/05/10 21:58:56 deraadt Exp $	*/
d267 2
a274 1
		KERNEL_LOCK();
d282 1
a283 1

a284 1
		KERNEL_LOCK();
@


1.133
log
@sigh, another case of user.h before syscall_mi.h
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.132 2014/05/10 05:33:00 guenther Exp $	*/
d142 1
@


1.132
log
@Factor out the common ast bits into mi_ast()

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.131 2014/05/08 21:32:45 miod Exp $	*/
a33 1
#include <sys/syscall_mi.h>
d37 1
@


1.131
log
@Format string fixes and removal of -Wno-format for hppa kernels.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.130 2014/04/18 11:51:16 guenther Exp $	*/
d142 1
a142 8
		uvmexp.softs++;
		if (p->p_flag & P_OWEUPC) {
			KERNEL_LOCK();
			ADDUPROF(p);
			KERNEL_UNLOCK();
		}
		if (curcpu()->ci_want_resched)
			preempt(NULL);
@


1.130
log
@Have each thread keeps its own (counted!) reference to the process's ucreds
to avoid possible use-after-free references when swapping ids in threaded
processes.  "Do I have the right creds?" checks are always made with the
threads creds.

Inspired by FreeBSD and NetBSD
"right time" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.129 2014/04/08 09:34:23 mpi Exp $	*/
d468 1
a468 1
			panic("trap: %s @@ 0x%x:0x%x for 0x%x:0x%x irr 0x%08x",
d917 1
a917 1
		    "syscall(0x%x, 0x%x, 0x%x, 0x%x...) EXIT, PID %d\n",
@


1.129
log
@Less <uvm/uvm.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.128 2014/03/26 05:23:42 guenther Exp $	*/
d221 3
@


1.128
log
@Move p_emul and p_sigcode from proc to process.
Tweak the handling of ktrace EMUL when changing ktracing: only
generate one per process (not one per thread) and pass the correct
proc pointer down to the VFS layer.  Permit generating of NAMI and
CSW records inside ktrace(2) itself.

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.127 2013/04/10 20:55:34 miod Exp $	*/
d39 1
a39 1
#include <uvm/uvm.h>
@


1.127
log
@Correctly handle data memory protection ID traps: if occuring in user mode,
SIGSEGV the process; if occuring in kernel mode, check for a possible
pcb_onfault to recover, before otherwise panicing.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.126 2012/12/31 06:46:13 guenther Exp $	*/
d801 2
a802 2
	nsys = p->p_emul->e_nsysent;
	callp = p->p_emul->e_sysent;
d836 1
a836 1
		callp += p->p_emul->e_nosys;	/* bad syscall # */
@


1.126
log
@Remove emulation errno mapping code from platforms that no longer have
non-native emulations.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.125 2012/08/29 18:49:56 kettenis Exp $	*/
d396 1
d554 13
a622 2
	case T_DATAPID:
	case T_DATAPID | T_USER:
@


1.125
log
@Handle T_IPROT traps from userland by call vm_fault() instead of doing an
unconditional SIGSEGV.  Fixes random SIGSEGVs during single-stepping.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.124 2012/08/07 11:17:34 kettenis Exp $	*/
d777 1
a777 1
	int retq, nsys, code, argsize, argoff, oerror, error;
d874 1
a874 1
	oerror = error = mi_syscall(p, code, callp, args, rval);
a888 2
		if (p->p_emul->e_errno)
			error = p->p_emul->e_errno[error];
d897 1
a897 1
	mi_syscall_return(p, code, oerror, rval);
@


1.124
log
@Don't include <sys/ktrace.h>; makes this file compile again.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.123 2012/08/07 05:16:53 guenther Exp $	*/
a413 1
		/* FALLTHROUGH */
a414 1
	case T_IPROT | T_USER:
d469 1
@


1.123
log
@Move the common bits of syscall invocation and return handling into
an MI file, <sys/syscall_mi.h>, correcting inconsistencies and the
handling when copyin() of arguments fails.

Tested on i386, amd64, sparc64, and alpha (thanks naddy@@)
Any issues with other platforms will be fixed in tree.

header name from millert@@; ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.122 2012/04/11 14:38:55 mikeb Exp $	*/
a34 1
#include <sys/ktrace.h>
@


1.122
log
@The first ktrace record for a newly spawned thread is a return
from a fork syscall done by the parent.  Use __tfork, not rfork
here to match the ktrace records for the parent (CALL __tfork,
RET __tfork).  ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.121 2011/11/16 20:56:01 deraadt Exp $	*/
d34 1
a39 3
#include "systrace.h"
#include <dev/systrace.h>

d660 2
a661 11
	userret(p);
#ifdef KTRACE
	if (KTRPOINT(p, KTR_SYSRET)) {
		KERNEL_LOCK();
		ktrsysret(p,
		    (p->p_flag & P_THREAD) ? SYS___tfork :
		    (p->p_p->ps_flags & PS_PPWAIT) ? SYS_vfork : SYS_fork,
		    0, 0);
		KERNEL_UNLOCK();
	}
#endif
a829 1
	oerror = error = 0;
d835 3
a837 5
			error = copyin((void *)(frame->tf_sp +
			    HPPA_FRAME_ARG(i + 4)), args + i + argoff, 4);

			if (error)
				break;
d849 1
a849 1
		if (!error && argoff < 4) {
a872 15
#ifdef SYSCALL_DEBUG
	KERNEL_LOCK();
	scdebug_call(p, code, args);
	KERNEL_UNLOCK();
#endif
#ifdef KTRACE
	if (KTRPOINT(p, KTR_SYSCALL)) {
		KERNEL_LOCK();
		ktrsyscall(p, code, callp->sy_argsize, args);
		KERNEL_UNLOCK();
	}
#endif
	if (error)
		goto bad;

a874 14
#if NSYSTRACE > 0
	if (ISSET(p->p_flag, P_SYSTRACE)) {
		KERNEL_LOCK();
		oerror = error = systrace_redirect(code, p, args, rval);
		KERNEL_UNLOCK();
	} else
#endif
	{
		int nolock = (callp->sy_flags & SY_NOLOCK);
		if (!nolock)
			KERNEL_LOCK();
		oerror = error = (*callp->sy_call)(p, args, rval);
		if (!nolock)
			KERNEL_UNLOCK();
d876 2
a877 1
	}
d898 1
a898 5
#ifdef SYSCALL_DEBUG
	KERNEL_LOCK();
	scdebug_ret(p, code, oerror, rval);
	KERNEL_UNLOCK();
#endif
d900 3
a902 8
	userret(p);
#ifdef KTRACE
	if (KTRPOINT(p, KTR_SYSRET)) {
		KERNEL_LOCK();
		ktrsysret(p, code, oerror, rval[0]);
		KERNEL_UNLOCK();
	}
#endif
@


1.121
log
@oops, need a prototype for ast()
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.120 2011/11/16 20:50:18 deraadt Exp $	*/
d667 1
a667 1
		    (p->p_flag & P_THREAD) ? SYS_rfork :
@


1.120
log
@Make userret() MI.  On architectures which jammed stuff into it in the
past, pull that code out seperately.
ok guenther miod
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.119 2011/11/08 14:02:30 miod Exp $	*/
d65 2
@


1.119
log
@On PCXS processors, reading %cr26 and %cr27 from userland causes a
privileged register trap. Cope with this in the trap handler to let
userland use these registers; this will be necessary in the not-so-distant
future.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.118 2011/07/11 15:40:47 guenther Exp $	*/
a137 2
void	userret(struct proc *p);

d139 1
a139 1
userret(struct proc *p)
a140 2
	int sig;

a152 4
	while ((sig = CURSIG(p)) != 0)
		postsig(sig);

	p->p_cpu->ci_schedstate.spc_curpriority = p->p_priority = p->p_usrpri;
d638 2
a639 1
	    (frame->tf_iioq_head & ~PAGE_MASK) == SYSCALLGATE))
d641 1
d659 1
d943 1
@


1.118
log
@Revert art@@'s moving around of the KERNEL_LOCK()/KERNEL_UNLOCK() calls,
as it causes hangs in some ports, including libsigsegv's configure script

confirmed by krw@@, landry@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.116 2011/07/06 21:41:37 art Exp $	*/
d286 1
a286 1
		trapsignal(p, SIGTRAP, type &~ T_USER, code, sv);
d297 1
a297 1
		trapsignal(p, SIGTRAP, type &~ T_USER, TRAP_TRACE, sv);
d339 1
a339 1
		trapsignal(p, SIGFPE, type &~ T_USER, flt, sv);
d351 1
a351 1
		trapsignal(p, SIGILL, type &~ T_USER, ILL_COPROC, sv);
d358 1
a358 1
		trapsignal(p, SIGFPE, type &~ T_USER, FPE_INTOVF, sv);
d365 1
a365 1
		trapsignal(p, SIGFPE, type &~ T_USER, FPE_INTDIV, sv);
d372 1
a372 1
		trapsignal(p, SIGILL, type &~ T_USER, ILL_PRVOPC, sv);
d377 23
a399 4
		sv.sival_int = va;
		KERNEL_LOCK();
		trapsignal(p, SIGILL, type &~ T_USER, ILL_PRVREG, sv);
		KERNEL_UNLOCK();
d591 1
a591 1
			trapsignal(p, SIGILL, type &~ T_USER, ILL_ILLOPC, sv);
@


1.117
log
@There is a bunch of places in the kernel entry points where we don't
hold the kernel lock, but still need call one function that needs it.

Instead of grabbing the lock all over the place, move the locks into
the affected functions: trapsignal, scdebug*, ktrsyscall, ktrsysret,
systrace_redirect and ADDUPROF. In the cases we already hold the biglock
we'll just recurse.

kettenis@@, beck@@ ok
@
text
@d149 1
d151 1
d285 1
d287 1
d296 1
d298 1
d338 1
d340 1
d350 1
d352 1
d357 1
d359 1
d364 1
d366 1
d371 1
d373 1
d378 1
d380 1
d387 1
d389 1
d408 1
d410 1
d452 1
d454 1
d492 1
d494 1
d522 1
d526 1
d547 1
d549 1
d571 1
d573 1
d649 1
d654 1
d872 1
d874 1
d878 1
d880 1
d890 1
d892 1
d925 1
d927 1
d932 1
d934 1
@


1.116
log
@Clean up after P_BIGLOCK removal.
KERNEL_PROC_LOCK -> KERNEL_LOCK
KERNEL_PROC_UNLOCK -> KERNEL_UNLOCK

oga@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.115 2011/06/06 14:20:50 jsing Exp $	*/
a148 1
			KERNEL_LOCK();
a149 1
			KERNEL_UNLOCK();
a282 1
		KERNEL_LOCK();
a283 1
		KERNEL_UNLOCK();
a291 1
		KERNEL_LOCK();
a292 1
		KERNEL_UNLOCK();
a331 1
		KERNEL_LOCK();
a332 1
		KERNEL_UNLOCK();
a341 1
		KERNEL_LOCK();
a342 1
		KERNEL_UNLOCK();
a346 1
		KERNEL_LOCK();
a347 1
		KERNEL_UNLOCK();
a351 1
		KERNEL_LOCK();
a352 1
		KERNEL_UNLOCK();
a356 1
		KERNEL_LOCK();
a357 1
		KERNEL_UNLOCK();
a361 1
		KERNEL_LOCK();
a362 1
		KERNEL_UNLOCK();
a368 1
		KERNEL_LOCK();
a369 1
		KERNEL_UNLOCK();
a387 1
		KERNEL_LOCK();
a388 1
		KERNEL_UNLOCK();
a429 1
			KERNEL_LOCK();
a430 1
			KERNEL_UNLOCK();
a467 1
			KERNEL_LOCK();
a468 1
			KERNEL_UNLOCK();
a495 1
				KERNEL_LOCK();
a498 1
				KERNEL_UNLOCK();
a518 1
		KERNEL_LOCK();
a519 1
		KERNEL_UNLOCK();
a540 1
			KERNEL_LOCK();
a541 1
			KERNEL_UNLOCK();
a616 1
		KERNEL_LOCK();
a620 1
		KERNEL_UNLOCK();
a837 1
	KERNEL_LOCK();
a838 1
	KERNEL_UNLOCK();
a841 1
		KERNEL_LOCK();
a842 1
		KERNEL_UNLOCK();
a851 1
		KERNEL_LOCK();
a852 1
		KERNEL_UNLOCK();
a884 1
	KERNEL_LOCK();
a885 1
	KERNEL_UNLOCK();
a889 1
		KERNEL_LOCK();
a890 1
		KERNEL_UNLOCK();
@


1.115
log
@Fix whitespace and use #ifdef TRAPDEBUG instead of #if 0.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.113 2011/01/23 15:09:12 jsing Exp $	*/
d149 1
a149 1
			KERNEL_PROC_LOCK(p);
d151 1
a151 1
			KERNEL_PROC_UNLOCK(p);
d285 1
a285 1
		KERNEL_PROC_LOCK(p);
d287 1
a287 1
		KERNEL_PROC_UNLOCK(p);
d296 1
a296 1
		KERNEL_PROC_LOCK(p);
d298 1
a298 1
		KERNEL_PROC_UNLOCK(p);
d338 1
a338 1
		KERNEL_PROC_LOCK(p);
d340 1
a340 1
		KERNEL_PROC_UNLOCK(p);
d350 1
a350 1
		KERNEL_PROC_LOCK(p);
d352 1
a352 1
		KERNEL_PROC_UNLOCK(p);
d357 1
a357 1
		KERNEL_PROC_LOCK(p);
d359 1
a359 1
		KERNEL_PROC_UNLOCK(p);
d364 1
a364 1
		KERNEL_PROC_LOCK(p);
d366 1
a366 1
		KERNEL_PROC_UNLOCK(p);
d371 1
a371 1
		KERNEL_PROC_LOCK(p);
d373 1
a373 1
		KERNEL_PROC_UNLOCK(p);
d378 1
a378 1
		KERNEL_PROC_LOCK(p);
d380 1
a380 1
		KERNEL_PROC_UNLOCK(p);
d387 1
a387 1
		KERNEL_PROC_LOCK(p);
d389 1
a389 1
		KERNEL_PROC_UNLOCK(p);
d408 1
a408 1
		KERNEL_PROC_LOCK(p);
d410 1
a410 1
		KERNEL_PROC_UNLOCK(p);
d438 1
a438 4
			if (type & T_USER)
				KERNEL_PROC_LOCK(p);
			else
				KERNEL_LOCK();
d449 1
a449 4
			if (type & T_USER)
				KERNEL_PROC_UNLOCK(p);
			else
				KERNEL_UNLOCK();
d452 1
a452 1
			KERNEL_PROC_LOCK(p);
d454 1
a454 1
			KERNEL_PROC_UNLOCK(p);
d492 1
a492 1
			KERNEL_PROC_LOCK(p);
d494 1
a494 1
			KERNEL_PROC_UNLOCK(p);
d498 1
a498 4
		if (type & T_USER)
			KERNEL_PROC_LOCK(p);
		else
			KERNEL_LOCK();
d517 1
a517 4
		if (type & T_USER)
			KERNEL_PROC_UNLOCK(p);
		else
			KERNEL_UNLOCK();
d522 1
a522 1
				KERNEL_PROC_LOCK(p);
d526 1
a526 1
				KERNEL_PROC_UNLOCK(p);
d547 1
a547 1
		KERNEL_PROC_LOCK(p);
d549 1
a549 1
		KERNEL_PROC_UNLOCK(p);
d571 1
a571 1
			KERNEL_PROC_LOCK(p);
d573 1
a573 1
			KERNEL_PROC_UNLOCK(p);
d644 1
a644 1
	KERNEL_PROC_UNLOCK(p);
d649 1
a649 1
		KERNEL_PROC_LOCK(p);
d654 1
a654 1
		KERNEL_PROC_UNLOCK(p);
d872 1
a872 1
	KERNEL_PROC_LOCK(p);
d874 1
a874 1
	KERNEL_PROC_UNLOCK(p);
d878 1
a878 1
		KERNEL_PROC_LOCK(p);
d880 1
a880 1
		KERNEL_PROC_UNLOCK(p);
d890 1
a890 1
		KERNEL_PROC_LOCK(p);
d892 1
a892 1
		KERNEL_PROC_UNLOCK(p);
d898 1
a898 1
			KERNEL_PROC_LOCK(p);
d901 1
a901 1
			KERNEL_PROC_UNLOCK(p);
d925 1
a925 1
	KERNEL_PROC_LOCK(p);
d927 1
a927 1
	KERNEL_PROC_UNLOCK(p);
d932 1
a932 1
		KERNEL_PROC_LOCK(p);
d934 1
a934 1
		KERNEL_PROC_UNLOCK(p);
@


1.114
log
@Move PPWAIT flag from struct proc to process, so that rthreads in
a vforked child behave correctly.  Have the parent in a vfork()
wait on a (different) flag in *its* process instead of the child
to prevent a possible use-after-free.  When ktracing the child
return from a fork, call it rfork if an rthread was created.

ok blambert@@
@
text
@d260 1
a260 1
		if (kdb_trap (type, va, frame)) {
d616 3
a618 3
#if 0
if (kdb_trap (type, va, frame))
	return;
@


1.113
log
@Ansify function.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.112 2010/12/21 14:56:23 claudio Exp $	*/
d663 3
a665 1
		    (p->p_flag & P_PPWAIT) ? SYS_vfork : SYS_fork, 0, 0);
@


1.112
log
@Convert netisr to a normal soft interrupt instead of hanving MD code
for it. This makes the netisr a real C function which will help further
development. No noticable performance change on i386 and amd64.
With input from kettenis@@ and miod@@ additional OKs mikeb@@ and henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.111 2010/11/27 19:57:23 miod Exp $	*/
d164 1
a164 3
trap(type, frame)
	int type;
	struct trapframe *frame;
@


1.111
log
@Remove ddb single-step load and store counters. Most platforms do not
implement them, and they are of questionable usefulness.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.110 2010/07/01 05:33:32 jsing Exp $	*/
a37 2

#include <net/netisr.h>
@


1.110
log
@Create a struct to store FP state and include a pointer to the CPU that
currently holds the FPU context for this process. This will be soon used
to implement FPU shootdowns on multiprocessor kernels.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.109 2010/06/26 00:50:03 jsing Exp $	*/
a47 1
#include <machine/db_machdep.h>	/* XXX always needed for inst_store() */
d51 2
d55 7
@


1.109
log
@Do not store curcpu() in syscall and trap handlers since we can go to
sleep and wake up on another CPU.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.108 2010/05/24 15:04:55 deraadt Exp $	*/
d299 2
a300 1
		u_int64_t *fpp = (u_int64_t *)frame->tf_cr30;
d303 3
@


1.108
log
@Add missing prototypes
ok jsing kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.107 2010/05/09 17:14:20 kettenis Exp $	*/
a136 1
	struct cpu_info *ci = curcpu();
d147 1
a147 1
		if (ci->ci_want_resched)
a161 1
	struct cpu_info *ci = curcpu();
d174 1
a174 1
	int oldcpl = ci->ci_cpl;
d616 1
a616 1
	if (ci->ci_cpl != oldcpl)
d618 1
a618 1
		    "TRAP (%d) EXIT\n", ci->ci_cpl, trapnum);
d622 1
a622 1
		splx(ci->ci_cpl);	/* process softints */
a773 1
	struct cpu_info *ci = curcpu();
d779 1
a779 1
	int oldcpl = ci->ci_cpl;
d940 1
a940 1
	if (ci->ci_cpl != oldcpl) {
d943 3
a945 2
		    ci->ci_cpl, code, args[0], args[1], args[2], p->p_pid);
		ci->ci_cpl = oldcpl;
d948 1
a948 1
	splx(ci->ci_cpl);	/* process softints */
@


1.107
log
@Make single stepping a system call work.  Instead of single stepping through
the syscall gateway page, which doesn't work since that page is shared
between processes, this makes us step over that bit by setting a breakpoint
on the instruction where the system call returns.

ok miod@@, jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.106 2010/03/30 14:57:02 kettenis Exp $	*/
d132 2
d667 3
d767 2
@


1.106
log
@Since we use a direct mapping for the area where we save a process' floating
point registers, we no longer need to flush/purge the cache.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.105 2010/03/27 14:55:01 jsing Exp $	*/
d719 1
a719 3
	/* Don't touch the syscall gateway page. */
	if (sstep == 0 ||
	    (p->p_md.md_regs->tf_iioq_tail & ~PAGE_MASK) == SYSCALLGATE) {
d724 8
a731 1
	p->p_md.md_bpva = p->p_md.md_regs->tf_iioq_tail & ~HPPA_PC_PRIV_MASK;
d753 5
a757 1
	p->p_md.md_regs->tf_ipsw |= PSL_T;
@


1.105
log
@Add locking to trap and syscall handlers.

ok kettenis@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.104 2009/12/31 12:52:35 jsing Exp $	*/
a327 2
		/* flush out, since load is done from phys, only 4 regs */
		fdcache(HPPA_SID_KERNEL, (vaddr_t)fpp, 8 * 4);
@


1.104
log
@Make cpl and cpu_inintr per CPU variables. For locore.S, cpl becomes an
offset within cpu_primary_info - this will need to be revisited shortly.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.103 2009/12/29 13:40:09 jsing Exp $	*/
d142 1
d144 1
d281 1
d283 1
d292 1
d294 1
d332 1
d334 1
d344 1
d346 1
d351 1
d353 1
d358 1
d360 1
d365 1
d367 1
d372 1
d374 1
d381 1
d383 1
d402 1
d404 1
d432 5
d445 5
d452 1
d454 1
d492 1
d494 1
d498 5
d520 5
d528 1
d532 1
d553 1
d555 1
d577 1
d579 1
d638 1
a638 2
child_return(arg)
	void *arg;
d650 2
d654 2
a655 1
	if (KTRPOINT(p, KTR_SYSRET))
d658 2
d863 1
d865 1
d868 2
a869 1
	if (KTRPOINT(p, KTR_SYSCALL))
d871 2
d880 2
a881 1
	if (ISSET(p->p_flag, P_SYSTRACE))
d883 2
a884 1
	else
d886 4
d891 4
d916 1
d918 1
d922 2
a923 1
	if (KTRPOINT(p, KTR_SYSRET))
d925 2
@


1.103
log
@Make want_resched a per CPU variable.

ok kettenis@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.102 2009/12/29 13:11:40 jsing Exp $	*/
d159 1
d172 1
a172 1
	int oldcpl = cpl;
d566 1
a566 1
	if (cpl != oldcpl)
d568 1
a568 1
		    "TRAP (%d) EXIT\n", cpl, trapnum);
d572 1
a572 1
		splx(cpl);	/* process softints */
d706 1
d712 1
a712 1
	int oldcpl = cpl;
d853 1
a853 1
	if (cpl != oldcpl) {
d856 2
a857 2
		    cpl, code, args[0], args[1], args[2], p->p_pid);
		cpl = oldcpl;
d860 1
a860 1
	splx(cpl);	/* process softints */
@


1.102
log
@Move hppa to per process AST.

ok kettenis@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.100 2007/09/15 14:55:30 krw Exp $	*/
a95 2
int want_resched;

d135 1
d144 1
a144 1
		if (want_resched)
@


1.101
log
@Handle PCXS data protection traps. Unlike other PA1.1 chips, there is a
single trap code for alignment and protection faults, so we have to
figure out which kind of problem we are facing.

ok kettenis@@
@
text
@d96 1
a96 1
int want_resched, astpending;
d139 2
a140 2
	if (astpending) {
		astpending = 0;
@


1.100
log
@realy -> really in comments. Most reported on tech@@ by Jung.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.99 2007/05/14 19:54:21 martin Exp $	*/
d55 1
d57 1
a57 1
void ss_clear_breakpoints(struct proc *p);
d263 1
a263 1
		if (type == T_DATALIGN)
d366 14
a380 1
	case T_DPROT | T_USER:
d431 1
d503 1
d532 14
a546 1
	case T_DPROT:
a555 3
		if (0 /* T-chip */) {
			break;
		}
d860 76
@


1.99
log
@move hppa to __HAVE_CPUINFO

input from miod@@, ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.98 2007/03/15 10:22:29 art Exp $	*/
d550 1
a550 1
	 * treat this as we were not realy running user code no more
@


1.98
log
@Since p_flag is often manipulated in interrupts and without biglock
it's a good idea to use atomic.h operations on it. This mechanic
change updates all bit operations on p_flag to atomic_{set,clear}bits_int.

Only exception is that P_OWEUPC is set by MI code before calling
need_proftick and it's automatically cleared by ADDUPC. There's
no reason for MD handling of that flag since everyone handles it the
same way.

kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.97 2007/03/05 17:13:59 mickey Exp $	*/
d151 1
a151 1
	curpriority = p->p_priority = p->p_usrpri;
@


1.97
log
@proper check for [non]user returns to syscall gate page; found by miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.96 2007/01/17 19:30:12 mickey Exp $	*/
a141 1
			p->p_flag &= ~P_OWEUPC;
@


1.96
log
@new shorter version of userret() as surely miod ment it to be like (; miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.95 2007/01/15 17:09:50 mickey Exp $	*/
d555 2
a556 2
	if ((type & T_USER) &&
	    (frame->tf_iioq_head & ~PAGE_MASK) != SYSCALLGATE)
@


1.95
log
@undo last broken userret() change here; miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.93 2005/12/12 18:59:02 miod Exp $	*/
d134 1
a134 1
userret(struct proc *p, register_t pc, u_quad_t oticks)
a137 5
	/* take pending signals */
	while ((sig = CURSIG(p)) != 0)
		postsig(sig);

	p->p_priority = p->p_usrpri;
d140 1
d145 2
a146 8
	}
	if (want_resched) {
		/*
		 * We're being preempted.
		 */
		preempt(NULL);
		while ((sig = CURSIG(p)) != 0)
			postsig(sig);
d149 2
a150 8
	/*
	 * If profiling, charge recent system time to the trapped pc.
	 */
	if (p->p_flag & P_PROFIL) {
		extern int psratio;

		addupc_task(p, pc, (int)(p->p_sticks - oticks) * psratio);
	}
d152 1
a152 1
	curpriority = p->p_priority;
d557 1
a557 1
		userret(p, frame->tf_iioq_head, 0);
d574 1
a574 1
	userret(p, tf->tf_iioq_head, 0);
d821 1
a821 1
	userret(p, frame->tf_iioq_head, 0);
@


1.94
log
@Check for want_resched when processing AST and nowhere else. But then, when
doing so, do not check for signals - userret() will do this.
@
text
@d149 8
a156 2
		if (want_resched)
			preempt(NULL);
@


1.93
log
@Nuke leftover references to procfs_mem.h.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.92 2005/12/11 21:30:30 miod Exp $	*/
d149 2
a150 8
	}
	if (want_resched) {
		/*
		 * We're being preempted.
		 */
		preempt(NULL);
		while ((sig = CURSIG(p)) != 0)
			postsig(sig);
@


1.92
log
@Replace procfs_domem() with a similar interface, process_domem(), which lives
out of procfs and gets a ptrace request PT_{READ,WRITE}_{I,D} as argument;
also procfs_checkioperm() becomes process_checkioperm().

From art@@ some time ago; ok kettenis@@ pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.91 2005/10/26 18:35:44 martin Exp $	*/
a55 1
#include <miscfs/procfs/procfs.h>
@


1.91
log
@no more hppa_round_page() and hppa_trunc_page() macros

ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.90 2005/09/15 21:14:27 miod Exp $	*/
d618 1
a618 1
	return (procfs_domem(curproc, p, NULL, &uio));
d636 1
a636 1
	return (procfs_domem(curproc, p, NULL, &uio));
@


1.90
log
@In syscall(), do not recompute the struct proc * after the syscall has
succeeded. This used to be necessary for fork(), when returning in the child,
but we return in the child in child_return() which does TRT.

ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.89 2005/09/15 21:09:29 miod Exp $	*/
d417 1
a417 1
			    uvm_fault(map, hppa_trunc_page(va), fault,
d465 1
a465 1
		ret = uvm_fault(map, hppa_trunc_page(va), fault, vftype);
@


1.89
log
@Change child_return() to record a proper ktrace record for vfork child
processes.

ok art@@ uwe@@ (some time ago)
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.88 2005/08/14 10:54:15 miod Exp $	*/
a814 2
	p = curproc;
	frame = p->p_md.md_regs;
@


1.88
log
@Add mquery to the system calls which need extra care due to off_t arguments
and reversed stack direction; ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.87 2005/07/18 02:43:25 fgsch Exp $	*/
d594 2
a595 1
		ktrsysret(p, SYS_fork, 0, 0);
@


1.87
log
@remove trailing newline in panic(9); ok millert@@ and deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.86 2005/05/26 04:34:52 kettenis Exp $	*/
d784 1
@


1.86
log
@Implement PT_STEP for hppa.
ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.85 2005/04/07 00:23:51 mickey Exp $	*/
d426 1
a426 1
			panic("trap: %s @@ 0x%x:0x%x for 0x%x:0x%x irr 0x%08x\n",
@


1.85
log
@dig lpa
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.84 2005/01/17 20:47:40 mickey Exp $	*/
d55 8
d288 16
a303 1
	case T_DBREAK | T_USER:
d305 1
a305 1
		trapsignal(p, SIGTRAP, type &~ T_USER, TRAP_BRKPT, sv);
d307 1
d598 92
@


1.84
log
@proper fault address selection (list all possible pc-based traps)
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.83 2005/01/17 19:01:00 mickey Exp $	*/
d376 5
a380 2
		/* dig probe[rw]i? insns */
		if ((opcode & 0xfc001f80) == 0x04001180) {
d383 1
@


1.83
log
@proper non-access fault handlers and probe emulations; testing by pval@@ miod@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.82 2004/12/06 20:12:24 miod Exp $	*/
d186 3
a188 2
	if (trapnum == T_ITLBMISS ||
	    trapnum == T_EXCEPTION || trapnum == T_EMULATION) {
@


1.82
log
@Use uvm_grow() to account for stack growth, rather than home-grown code
or nothing.
Inspired by a similar recent change in NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.81 2004/09/14 22:44:58 mickey Exp $	*/
a193 1
		/* what is the vftype for the T_ITLBMISSNA ??? XXX */
d364 40
a410 18
	case T_ITLBMISSNA:
	case T_ITLBMISSNA | T_USER:
	case T_DTLBMISSNA:
	case T_DTLBMISSNA | T_USER:
	case T_TLB_DIRTY:
	case T_TLB_DIRTY | T_USER:
		/*
		 * user faults out of user addr space are always a fail,
		 * this happens on va >= VM_MAXUSER_ADDRESS, where
		 * space id will be zero and therefore cause
		 * a misbehave lower in the code.
		 */
		if (type & T_USER && va >= VM_MAXUSER_ADDRESS) {
			sv.sival_int = va;
			trapsignal(p, SIGSEGV, vftype, SEGV_ACCERR, sv);
			break;
		}

d421 10
a430 1
		if (type & T_USER && map->pmap->pm_space != space) {
a436 8

		/* dig probe insn */
		if (ret && trapnum == T_DTLBMISSNA &&
		    (opcode & 0xfc001f80) == 0x04001180) {
			frame_regmap(frame, opcode & 0x1f) = 0;
			frame->tf_ipsw |= PSL_N;
			break;
		}
@


1.81
log
@poke and clean all exceptions regs and not just one
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.80 2004/07/13 19:34:23 mickey Exp $	*/
d424 4
a427 7
		    va < (vaddr_t)vm->vm_minsaddr &&
		    va >= (vaddr_t)vm->vm_maxsaddr + ctob(vm->vm_ssize)) {
			if (ret == 0) {
				vsize_t nss = btoc(va - USRSTACK + NBPG - 1);
				if (nss > vm->vm_ssize)
					vm->vm_ssize = nss;
			} else if (ret == EACCES)
@


1.80
log
@more coherent intrs counting
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.79 2004/07/02 04:19:50 mickey Exp $	*/
d308 4
a311 1
			*pex = 0;
@


1.79
log
@fill out error info into ret* regs upon failed syscall return
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.78 2004/06/17 00:30:08 mickey Exp $	*/
d232 1
a232 2
	} else
		uvmexp.intrs++;
@


1.78
log
@use local var copy of frame->tf_iir everywhere and fix one panic
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.77 2004/06/16 02:09:55 mickey Exp $	*/
d689 2
@


1.77
log
@handle zero division for userland as well; from otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.76 2004/06/10 21:13:55 kettenis Exp $	*/
d408 2
a409 2
		    (frame->tf_iir & 0xfc001f80) == 0x04001180) {
			frame_regmap(frame, frame->tf_iir & 0x1f) = 0;
d449 1
a449 1
					    map, va, 0, vftype, ret);
d472 2
a473 2
		if ((frame->tf_iir & 0xfffffe00) == 0x10000200) {
			frame_regmap(frame, frame->tf_iir & 0x1f) = 0;
@


1.76
log
@Generate SIGTRAP for breakpoint instructions.
ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.75 2004/05/13 01:22:56 mickey Exp $	*/
d336 2
@


1.75
log
@implement spop1,,0 support
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.74 2004/05/12 22:56:59 mickey Exp $	*/
a280 3
		/* XXX */
		frame->tf_iioq_head = frame->tf_iioq_tail;
		frame->tf_iioq_tail += 4;
d283 1
@


1.74
log
@support probe instructions
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.73 2004/04/21 23:09:30 mickey Exp $	*/
a339 5
	case T_ILLEGAL | T_USER:
		sv.sival_int = va;
		trapsignal(p, SIGILL, type &~ T_USER, ILL_ILLOPC, sv);
		break;

d469 15
a487 1
	case T_ILLEGAL:
@


1.73
log
@only set child return values in the child_return() more like other archs
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.72 2004/04/07 18:24:19 mickey Exp $	*/
d90 36
d410 8
@


1.72
log
@update copyright; miod@@ is fine w/ files where he holds it too
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.71 2004/04/02 20:56:31 mickey Exp $	*/
d479 10
a488 1
	userret(p, p->p_md.md_regs->tf_iioq_head, 0);
@


1.71
log
@repair fcnv* emulation.
generate proper signals/siginfo.
partially repairs the "otto" case.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.70 2003/12/20 21:49:06 miod Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998-2003 Michael Shalayeff
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Michael Shalayeff.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d19 8
a26 7
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF MIND,
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@


1.70
log
@Pass -Wformat, fix a few uninitialized variables as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.69 2003/10/23 18:33:52 miod Exp $	*/
d266 1
a266 1
			if (stat == HPPA_FPU_UNMPL)
d268 1
a268 1
			else if (stat & HPPA_FPU_V)
d270 1
a270 1
			else if (stat & HPPA_FPU_Z)
d272 1
a272 1
			else if (stat & HPPA_FPU_I)
d274 1
a274 1
			else if (stat & HPPA_FPU_O)
d276 1
a276 1
			else if (stat & HPPA_FPU_U)
d297 1
a297 1
		trapsignal(p, SIGILL, type &~ T_USER, ILL_ILLOPC, sv);
@


1.69
log
@Maybe fixing typos will unbore me.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.68 2003/08/07 05:19:57 mickey Exp $	*/
d386 2
a387 1
		if (space != 0 && va < (vaddr_t)vm->vm_minsaddr &&
d413 1
a413 1
					    "uvm_fault(%p, %x, %d, %d): %d",
@


1.68
log
@do not treat traps from the syscall gate page as user code
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.67 2003/07/26 04:14:56 mickey Exp $	*/
d569 1
a569 1
		 * test should be used, to whatch the behaviour.
@


1.67
log
@on syscall exit restore old cpl if there is a need; move call for softints processing towards after that
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.66 2003/06/17 04:39:39 jfb Exp $	*/
d466 8
a473 1
	if (type & T_USER)
@


1.66
log
@typos

ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.65 2003/04/11 00:25:40 mickey Exp $	*/
a628 1
	splx(cpl);	/* process softints */
d634 1
a634 1
	if (cpl != oldcpl)
d638 2
d641 1
@


1.65
log
@always reread curproc and frame on return from the system call
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.64 2003/04/11 00:24:09 mickey Exp $	*/
d520 1
a520 1
		 * due to the args being layed backwards on the stack
@


1.64
log
@count traps and interrupts
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.63 2003/04/07 17:09:42 mickey Exp $	*/
d605 2
a608 2
		p = curproc;			/* changes on exec() */
		frame = p->p_md.md_regs;
a615 1
		break;
a616 2
		p = curproc;
		frame = p->p_md.md_regs;
@


1.63
log
@only check for space mismatch when coming from user.
the only case of user refering the kernel space is for the
syscall and that never faults since always mapped.
this fixes some random sig11 occurences.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.62 2003/02/25 14:04:09 miod Exp $	*/
d197 2
a198 1
	if (trapnum != T_INTERRUPT)
d200 2
@


1.62
log
@In trap(), always initialize tts, even if TRAPDEBUG is not defined, as it
might needed for panic() messages.
ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.61 2003/02/18 19:01:50 deraadt Exp $	*/
a357 5
		if (!(vm = p->p_vmspace)) {
			printf("trap: no vm, p=%p\n", p);
			goto dead_end;
		}

d361 1
a361 1
		if (!(type & T_USER) && space == HPPA_SID_KERNEL)
d363 2
a364 1
		else
d366 1
d368 4
a371 9
		if (map->pmap->pm_space != space) {
			if (map->pmap->pm_space != HPPA_SID_KERNEL) {
				sv.sival_int = va;
				trapsignal(p, SIGSEGV, vftype, SEGV_MAPERR, sv);
			} else {
				printf("trap: space missmatch %d != %d\n",
				    space, map->pmap->pm_space);
				goto dead_end;
			}
a373 6
#ifdef TRAPDEBUG
		if (space == -1) {
			extern int pmapdebug;
			pmapdebug = 0xffffff;
		}
#endif
a374 10

#ifdef TRAPDEBUG
		if (space == -1) {
			extern int pmapdebug;
			pmapdebug = 0;
		}

		printf("uvm_fault(%p, %x, %d, %d)=%d\n",
		    map, va, 0, vftype, ret);
#endif
@


1.61
log
@knf; mickey ok
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.60 2003/02/18 09:40:43 miod Exp $	*/
a173 1
#ifdef TRAPDEBUG
d179 1
@


1.60
log
@Let kernels compile without DDB, USELEDS, and DIAGNOSTIC.
For future intallation media.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.59 2003/01/22 18:16:34 mickey Exp $	*/
d202 1
a202 1
	case T_NONEXIST|T_USER:
d208 1
a208 1
	case T_RECOVERY|T_USER:
d221 2
a222 1
	case T_HPMC:      case T_HPMC | T_USER:
d301 1
a301 1
		
d333 2
a334 1
	case T_DATACC:   	case T_USER | T_DATACC:
d336 10
a345 5
	case T_ITLBMISS:	case T_USER | T_ITLBMISS:
	case T_DTLBMISS:	case T_USER | T_DTLBMISS:
	case T_ITLBMISSNA:	case T_USER | T_ITLBMISSNA:
	case T_DTLBMISSNA:	case T_USER | T_DTLBMISSNA:
	case T_TLB_DIRTY:	case T_USER | T_TLB_DIRTY:
d446 1
a446 1
	case T_INTERRUPT|T_USER:
d464 2
a465 1
	case T_DATAPID:  	case T_DATAPID  | T_USER:
@


1.59
log
@consistantly use uvm_prot_* vs vm_prot_* evewrhere
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.58 2003/01/09 20:48:56 mickey Exp $	*/
d52 1
a53 1
#include <machine/db_machdep.h>
@


1.58
log
@on user trap space mismatch just kill the offender, panic the kernel otherwise
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.57 2003/01/08 07:00:58 mickey Exp $	*/
d158 1
a158 1
		vftype = VM_PROT_EXECUTE;
d164 1
a164 1
			vftype = VM_PROT_EXECUTE;
d166 1
a166 1
			vftype = VM_PROT_WRITE;
d168 1
a168 1
			vftype = VM_PROT_READ;
@


1.57
log
@make sure we are not allowing user to fault outside user address space and always print smth before dead_end
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.56 2003/01/07 19:39:26 mickey Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998-2001 Michael Shalayeff
d26 2
a27 2
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
d347 1
a347 1
			trapsignal(p, SIGSEGV, vftype, SEGV_MAPERR, sv);
d365 8
a372 4
			printf("trap: space missmatch %d != %d\n",
			    space, map->pmap->pm_space);
			/* actually dump the user, crap the kernel */
			goto dead_end;
@


1.56
log
@kill some debugging kdb_traps
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.55 2002/12/19 21:08:43 mickey Exp $	*/
a202 1
#ifndef DDB
d204 1
a204 3
		panic ("trap: elvis has just left the building!");
		break;
#else
d206 1
a206 1
#endif
a208 1
#ifndef DDB
d210 1
a210 3
		printf ("trap: handicapped");
		break;
#else
a211 1
#endif
d245 3
d339 11
a349 1
		vm = p->p_vmspace;
d351 1
a351 2
		if (!vm) {
#ifdef TRAPDEBUG
a352 1
#endif
a364 1
#ifdef TRAPDEBUG
a366 1
#endif
@


1.55
log
@make sure we are hitting user stack and not smth else here, make init show normal vsz in ps now
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.54 2002/12/17 21:54:25 mickey Exp $	*/
a405 4
#if 0
if (kdb_trap (type, va, frame))
	return;
#endif
a411 4
#if 0
if (kdb_trap (type, va, frame))
	return;
#endif
a418 4
#if 0
if (kdb_trap (type, va, frame))
	return;
#else
a421 1
#endif
@


1.54
log
@real interrupts/spl framework.
tested on 712/* 715/100, 715/33 which main cpu/bus types.
miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.53 2002/10/18 19:48:54 mickey Exp $	*/
d394 2
a395 1
		if (va >= (vaddr_t)vm->vm_maxsaddr + ctob(vm->vm_ssize)) {
@


1.53
log
@this is a precision architecture -- be more precise about fault types and in sigsegv deliveries; vm_ssize is in pages, apparently
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.52 2002/10/07 14:38:34 mickey Exp $	*/
d94 2
a95 4
void syscall(struct trapframe *frame);

static __inline void
userret (struct proc *p, register_t pc, u_quad_t oticks)
d104 7
a136 1
	extern u_int32_t sir;
d145 1
a145 1
	int ret, s, si, trapnum;
d148 3
d197 3
a446 25
#if 0
if (kdb_trap (type, va, frame))
return;
#endif
		/* FALLTHROUGH */
	case T_LOWERPL:
		__asm __volatile (
		    "ldcws 0(%1), %0" : "=&r" (si) : "r" (&sir) : "memory");
		if (si & SIR_CLOCK) {
			s = splsoftclock();
			softclock();
			splx(s);
		}

		if (si & SIR_NET) {
			register int ni;
			/* use atomic "load & clear" */
			__asm __volatile (
			    "ldcws 0(%1), %0"
			    : "=&r" (ni) : "r" (&netisr) : "memory");
			s = splnet();
#define	DONETISR(m,c) if (ni & (1 << (m))) c()
#include <net/netisr_dispatch.h>
			splx(s);
		}
d453 1
d473 1
a473 1
		panic("trap: unimplemented \'%s\' (%d)", tts, type);
d476 9
d486 1
a486 1
		userret(p, p->p_md.md_regs->tf_iioq_head, 0);
d506 1
a506 2
syscall(frame)
	struct trapframe *frame;
d512 3
d651 1
d655 6
@


1.52
log
@on implementations w/ fpu included unimplemented instructions
are signaled through the exception trap w/ invalid opcode marked
instruction in the exception registers, not through the emulation
trap (as long as the fpu is enabled, of  course).
parse emulation from the exception trap as well as the emulation
trap and fix the dispatcher into usable condition.
parse invalid op exception on trap and signal the user appropriately.
reset the exception on exec and for child on fork.
the later is appropriate since exceptions are delayed until next
fpu instruction, which was in the parent indeed, let him get it.
save parent's fpu context on fork before cipying it, if the
parent owned the fpu.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.51 2002/09/23 06:11:46 mickey Exp $	*/
d156 6
a161 1
		vftype = inst_store(opcode) ? VM_PROT_WRITE : VM_PROT_READ;
d317 1
a317 1
		trapsignal(p, SIGSEGV, type &~ T_USER, SEGV_ACCERR, sv);
a332 1
		va = hppa_trunc_page(va);
d365 1
a365 1
		ret = uvm_fault(map, va, fault, vftype);
d384 1
a384 1
		if (va >= (vaddr_t)vm->vm_maxsaddr + vm->vm_ssize) {
d386 1
a386 1
				vsize_t nss = btoc(va - USRSTACK + NBPG);
d399 4
a402 2
				sv.sival_int = frame->tf_ior;
				trapsignal(p, SIGSEGV, vftype, SEGV_MAPERR, sv);
@


1.51
log
@make the leds blink (on those machines where we have 'em).
simple logic is to light up the led in the intrhook and dim in the
heartbeat always, makes a believable impression.
upper four bits represent a cpu usage w/in the last Hz/8
made up from the cp_time[] times.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.50 2002/09/17 03:51:49 mickey Exp $	*/
d147 2
a148 1
	if (trapnum == T_ITLBMISS) {
a213 1
	case T_EMULATION:
d242 2
a243 3
		extern u_int32_t fpu_enable;	/* from machdep */
		extern paddr_t fpu_curpcb;
		u_int32_t stat, *pex;
d246 1
a246 13
#ifdef DIAGNOSTIC
		if (fpu_curpcb != frame->tf_cr30)
			panic("trap: FPU is not owned");
#endif
		mfctl(CR_CCR, stat);
		if (stat & fpu_enable)	/* net quite there yet */
			fpu_save((vaddr_t)p->p_addr->u_pcb.pcb_fpregs);
		/* nobody owns it anymore */
		fpu_curpcb = 0;
		mtctl(stat & ~fpu_enable, CR_CCR);

		/* get the exceptions and mask by the enabled mask */
		pex = (u_int32_t *)&p->p_addr->u_pcb.pcb_fpregs[0];
d248 22
a269 15
		stat = HPPA_FPU_OP(*pex);
		if (stat & HPPA_FPU_V)
			flt = FPE_FLTINV;
		else if (stat & HPPA_FPU_Z)
			flt = FPE_FLTDIV;
		else if (stat & HPPA_FPU_O)
			flt = FPE_FLTOVF;
		else if (stat & HPPA_FPU_U)
			flt = FPE_FLTUND;
		else if (stat & HPPA_FPU_I)
			flt = FPE_FLTRES;
		else
			flt = 0;
		/* still left: under/over-flow and inexact */
		*pex = 0;
d276 5
a280 1
	case T_EMULATION | T_USER:	/* co-proc assist trap */
d282 1
a282 1
		trapsignal(p, SIGFPE, type &~ T_USER, FPE_FLTINV, sv);
a458 4
#if 0
if (kdb_trap (type, va, frame))
	return;
#endif
@


1.50
log
@handle fpu exceptions properly, might use a regress, i guess
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.49 2002/09/12 04:36:19 mickey Exp $	*/
a431 1
		frame->tf_flags |= TFF_INTR;
@


1.49
log
@give a condition trap own treatment, per millicode; and, oh horror, swap return of quad_t, sort of, sometimes
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.48 2002/09/11 18:37:29 mickey Exp $	*/
a133 1
	struct pcb *pcbp;
d213 1
a213 1
	case T_EMULATION: case T_EMULATION | T_USER:
d241 42
a282 1
	case T_EXCEPTION | T_USER:	/* co-proc assist trap */
a404 1
					pcbp = &p->p_addr->u_pcb;
d407 1
a407 1
						pcbp->pcb_onfault);
@


1.48
log
@correct argsize for ktrsyscall
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.47 2002/09/10 22:43:49 mickey Exp $	*/
d353 4
d422 8
a432 1
	case T_CONDITION:
d449 1
a449 1
		panic ("trap: unimplemented \'%s\' (%d)", tts, type);
d478 2
a479 2
	int nsys, code, argsize, argoff, oerror, error;
	int args[8], rval[2];
d490 1
a490 1
	argoff = 4;
d511 1
d553 1
a553 1
			case SYS_lseek:
d594 1
a594 1
		frame->tf_ret1 = rval[1];
d603 1
@


1.47
log
@copy syscall args in the syscall() based on the
amount given in the sysent.
deal w/ the words swappage phenomena due to reverse
long word storage on the stack and that being
reverse copied by words yielding long word being word swapped.
do it only for syscall(2) and __syscall(2) since that's how those
w/ long word args syscalls get used (for proper alignment).
discussed and ideas from: deraadt@@, drahn@@ and fredette@@

note: this might be a good point for a regress.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.46 2002/08/13 07:00:50 mickey Exp $	*/
d564 1
a564 1
		ktrsyscall(p, code, argsize, args);
@


1.46
log
@reset iir in the frame on _onfault handling, for mr.ddb
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.45 2002/07/25 02:26:17 mickey Exp $	*/
d94 1
a94 1
void syscall(struct trapframe *frame, int *args);
d357 4
d368 1
a368 2
					break;
				}
d373 3
a375 2
				panic("trap: uvm_fault(%p, %x, %d, %d): %d",
				    map, va, 0, vftype, ret);
d377 1
d457 1
a459 4
 * from the low-level syscall handler:
 * - all HPPA_FRAME_NARGS syscall's arguments supposed to be copied onto
 *   our stack, this wins compared to copyin just needed amount anyway
 * - register args are copied onto stack too
d462 1
a462 1
syscall(frame, args)
a463 1
	int *args;
d465 1
a465 1
	register struct proc *p;
d467 2
a468 2
	int nsys, code, argsize, error;
	int rval[2];
a474 1
	p = curproc;
d478 3
a480 2
	code = frame->tf_t1;
	switch (code) {
d482 5
a486 2
		code = *args;
		args += 1;
d491 16
a506 2
		code = *args;
		args += 2;
d513 45
a557 1
	argsize = callp->sy_argsize;
d566 2
d570 1
a570 1
	rval[1] = 0;
d573 1
a573 1
		error = systrace_redirect(code, p, args, rval);
d576 1
a576 1
		error = (*callp->sy_call)(p, args, rval);
d593 1
d600 1
a600 1
	scdebug_ret(p, code, error, rval);
d605 1
a605 1
		ktrsysret(p, code, error, rval[0]);
@


1.45
log
@only one trap generates exec fault and fetches the fault address from the pc queues, also supply fault_type (not that it is used that much)
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.44 2002/07/21 11:47:39 mickey Exp $	*/
d361 3
@


1.44
log
@on itlb miss say type is VM_PROT_EXECUTE, per art@@s suggestion
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.43 2002/05/20 07:59:11 mickey Exp $	*/
d144 1
d148 1
a148 1
	if (trapnum == T_ITLBMISS || trapnum == T_ITLBMISSNA) {
d155 1
d284 1
d323 1
a323 2

		ret = uvm_fault(map, va, 0, vftype);
@


1.43
log
@force alignment on the netisr and sir by mobving 'em into .data
and allocating space in the locore (ldcw require a 16byte alignment).
inform gcc that ldcw will change the memory (in asm()).
fix spl handling in the soft intrs piece.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.42 2002/05/16 21:11:14 miod Exp $	*/
d150 1
a150 1
		vftype = VM_PROT_READ;	/* XXX VM_PROT_EXECUTE ??? */
@


1.42
log
@Add systrace support to all the remaining architectures.

Tested by various people on various platforms, I'm willing to fix any
breakage this causes.

ok niels@@ deraadt@@ and mickey@@ (after his comments were applied)
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.41 2002/03/16 01:13:42 mickey Exp $	*/
a91 1
u_int32_t sir;
d132 1
d387 2
a388 3
		__asm __volatile ("ldcws 0(%1), %0"
				  : "=r" (si) : "r" (&sir));
		s = spl0();
d390 1
a390 1
			splclock();
d392 1
a392 1
			spl0();
d398 4
a401 3
			__asm __volatile ("ldcws 0(%1), %0"
					  : "=r" (ni) : "r" (&netisr));
			splnet();
d404 1
a405 1
		splx(s);
@


1.41
log
@separate out interrupt handling stuff
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.40 2002/03/15 21:44:18 mickey Exp $	*/
d45 3
d502 7
a508 1
	switch (error = (*callp->sy_call)(p, args, rval)) {
@


1.40
log
@rewrite a pmap to use multilevel page tables.
lower 12 bits contain the perms, no unused bits left,
but a couple for off-tlb use (as the ref implemented now).
do not use the hvt, which might get some use later
if proven to speed thigs up, tlb handlers would po
another dozen of insns though, but if that's worth its...
move on the data seg and map kernel text rdonly (idea form fredette),
since all of the page0 mods done before that we are all fine
except for some viper fluff, but later w/ that.
this also picks up a bit more of ddb magic for bpt and ss.
tlb handlers can use a little bit more of attention,
but things, visually, seem to be much faster already, --
sorry, no benchmarks for now.

* effort sponsored in part by the `henry st. old ale house'
* and mr.pete and mr.lee in particular in thier generous entrirety.
* the proj took a little more that 72man*h as it was expected,
* but within murhy's law estimations.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.39 2002/03/14 01:26:32 millert Exp $	*/
a32 1
/* #define INTRDEBUG */
a36 1
#include <sys/kernel.h>
a41 3
#include <sys/acct.h>
#include <sys/signal.h>
#include <sys/device.h>
a46 3
#include <machine/iomod.h>
#include <machine/cpufunc.h>
#include <machine/reg.h>
d51 2
a53 3

#if defined(INTRDEBUG) || defined(TRAPDEBUG)
#include <ddb/db_output.h>
a55 1

a91 2
void pmap_hptdump(void);
void cpu_intr(struct trapframe *frame);
a351 3
#ifdef PMAPDEBUG
					printf("trap: copyin/out %d\n",ret);
#endif
a355 1
					pcbp->pcb_onfault = 0;
a527 78
}

/* all the interrupts, minus cpu clock, which is the last */
struct cpu_intr_vector {
	struct evcnt evcnt;
	int pri;
	int (*handler)(void *);
	void *arg;
} cpu_intr_vectors[CPU_NINTS];

void *
cpu_intr_establish(pri, irq, handler, arg, dv)
	int pri, irq;
	int (*handler)(void *);
	void *arg;
	struct device *dv;
{
	register struct cpu_intr_vector *iv;

	if (0 <= irq && irq < CPU_NINTS && cpu_intr_vectors[irq].handler)
		return NULL;

	iv = &cpu_intr_vectors[irq];
	iv->pri = pri;
	iv->handler = handler;
	iv->arg = arg;
	evcnt_attach(dv, dv->dv_xname, &iv->evcnt);

	return iv;
}

void
cpu_intr(frame)
	struct trapframe *frame;
{
	u_int32_t eirr = 0, r;
	register struct cpu_intr_vector *iv;
	register int bit;

	do {
		mfctl(CR_EIRR, r);
		eirr |= r;
#ifdef INTRDEBUG
		if (eirr & 0x7fffffff)
			db_printf ("cpu_intr: 0x%08x & 0x%08x\n",
			    eirr, frame->tf_eiem);
#endif
		eirr &= frame->tf_eiem;
		bit = ffs(eirr) - 1;
		if (bit >= 0) {
			mtctl(1 << bit, CR_EIRR);
			eirr &= ~(1 << bit);
			/* ((struct iomod *)cpu_gethpa(0))->io_eir = 0; */
#ifdef INTRDEBUG
			if (bit != 31)
				db_printf ("cpu_intr: 0x%08x\n", (1 << bit));
#endif
			iv = &cpu_intr_vectors[bit];
			if (iv->handler) {
				register int s, r;

				iv->evcnt.ev_count++;
				s = splraise(iv->pri);
				/* no arg means pass the frame */
				r = (iv->handler)(iv->arg? iv->arg:frame);
				splx(s);
#ifdef INTRDEBUG
				if (!r)
					db_printf ("%s: can't handle interrupt\n",
						   iv->evcnt.ev_name);
#endif
			}
#ifdef INTRDEBUG
			else
				db_printf ("cpu_intr: stray interrupt %d\n", bit);
#endif
		}
	} while (eirr);
@


1.39
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.38 2002/02/07 13:54:16 mickey Exp $	*/
d314 1
a314 1
		if (map->pmap->pmap_space != space) {
d317 1
a317 1
			    space, map->pmap->pmap_space);
d374 1
a374 1
#if 1
d437 1
a437 1
#if 1
@


1.38
log
@remove debugging printf
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.37 2002/02/06 19:28:18 mickey Exp $	*/
d102 3
a104 3
void pmap_hptdump __P((void));
void cpu_intr __P((struct trapframe *frame));
void syscall __P((struct trapframe *frame, int *args));
d550 1
a550 1
	int (*handler) __P((void *));
d557 1
a557 1
	int (*handler) __P((void *));
@


1.37
log
@disable trapdebug, better handling of eirr too
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.36 2002/02/05 04:26:06 mickey Exp $	*/
a359 1
printf("trapsignal: uvm_fault\n");
@


1.36
log
@use splraise() when calling handlers; from fredette@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.35 2002/02/02 03:07:46 mickey Exp $	*/
d34 1
a34 1
#define TRAPDEBUG
d323 7
d333 5
d580 1
a580 1
	u_int32_t eirr;
d585 7
a591 1
		mfctl(CR_EIRR, eirr);
@


1.35
log
@tiny fixens from netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.34 2001/11/28 16:13:28 art Exp $	*/
d176 1
a176 1
		db_printf("trap: %d, %s for %x:%x at %x:%x, fl=%x, fp=%p\n",
d589 1
a589 1
				s = splx(iv->pri);
@


1.34
log
@zap some typedefs.
vm_map_t -> struct vm_map *
vm_map_entry_t -> struct vm_map_entry *
simple_lock_data_t -> struct simplelock

(uvm not done yet, coming in the next commit)
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.33 2001/11/28 13:47:38 art Exp $	*/
d34 1
a34 1
/* #define TRAPDEBUG */
d149 1
d151 1
a151 3
	int ret;
	union sigval sv;
	int s, si;
d154 1
d156 1
a156 1
	if (type == T_ITLBMISS || type == T_ITLBMISSNA) {
d170 1
a170 1
	if ((type & ~T_USER) > trap_types)
d173 1
a173 1
		tts = trap_type[type & ~T_USER];
d175 1
a175 1
	if (type != T_INTERRUPT && (type & ~T_USER) != T_IBREAK)
d179 1
a179 1
	else if ((type & ~T_USER) == T_IBREAK)
d513 2
a514 2
		frame->tf_iioq_head -= 4; /* right? XXX */
		frame->tf_iioq_tail -= 4; /* right? XXX */
@


1.34.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.34 2001/11/28 16:13:28 art Exp $	*/
d33 1
d38 1
d44 3
a49 3
#include "systrace.h"
#include <dev/systrace.h>

d52 3
d59 3
a61 1
#ifdef TRAPDEBUG
d64 1
a64 1
#endif
d99 1
d102 3
a104 1
void syscall(struct trapframe *frame, int *args);
a141 1
	extern u_int32_t sir;
d149 2
d152 1
a152 2
	u_int opcode;
	int ret, s, si, trapnum;
a154 1
	trapnum = type & ~T_USER;
d156 1
a156 1
	if (trapnum == T_ITLBMISS || trapnum == T_ITLBMISSNA) {
d170 1
a170 1
	if (trapnum > trap_types)
d173 1
a173 1
		tts = trap_type[trapnum];
d175 2
a176 2
	if (trapnum != T_INTERRUPT && trapnum != T_IBREAK)
		db_printf("trap: %x, %s for %x:%x at %x:%x, fl=%x, fp=%p\n",
d179 1
a179 1
	else if (trapnum  == T_IBREAK)
d314 1
a314 1
		if (map->pmap->pm_space != space) {
d317 1
a317 1
			    space, map->pmap->pm_space);
a322 7
#ifdef TRAPDEBUG
		if (space == -1) {
			extern int pmapdebug;
			pmapdebug = 0xffffff;
		}
#endif

a325 5
		if (space == -1) {
			extern int pmapdebug;
			pmapdebug = 0;
		}

d348 1
d353 3
d360 1
d363 1
a363 1
#if 0
d389 3
a391 2
		__asm __volatile (
		    "ldcws 0(%1), %0" : "=&r" (si) : "r" (&sir) : "memory");
d393 1
a393 1
			s = splsoftclock();
d395 1
a395 1
			splx(s);
d401 3
a403 4
			__asm __volatile (
			    "ldcws 0(%1), %0"
			    : "=&r" (ni) : "r" (&netisr) : "memory");
			s = splnet();
a405 1
			splx(s);
d407 1
d426 1
a426 1
#if 0
d504 1
a504 7
#if NSYSTRACE > 0
	if (ISSET(p->p_flag, P_SYSTRACE))
		error = systrace_redirect(code, p, args, rval);
	else
#endif
		error = (*callp->sy_call)(p, args, rval);
	switch (error) {
d513 2
a514 2
		frame->tf_iioq_head -= 12;
		frame->tf_iioq_tail -= 12;
d533 72
@


1.34.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.34.2.1 2002/06/11 03:35:37 art Exp $	*/
d94 1
a94 1
void syscall(struct trapframe *frame);
d134 1
a143 1
	vm_fault_t fault = VM_FAULT_INVALID;
d147 1
a147 2
	if (trapnum == T_ITLBMISS ||
	    trapnum == T_EXCEPTION || trapnum == T_EMULATION) {
d150 1
a150 1
		vftype = VM_PROT_EXECUTE;
d154 1
a154 7
		/* what is the vftype for the T_ITLBMISSNA ??? XXX */
		if (va == frame->tf_iioq_head)
			vftype = VM_PROT_EXECUTE;
		else if (inst_store(opcode))
			vftype = VM_PROT_WRITE;
		else
			vftype = VM_PROT_READ;
d212 1
d240 1
a240 40
	case T_EXCEPTION | T_USER: {
		u_int64_t *fpp = (u_int64_t *)frame->tf_cr30;
		u_int32_t *pex;
		int i, flt;

		pex = (u_int32_t *)&fpp[0];
		for (i = 0, pex++; i < 7 && !*pex; i++, pex++);
		flt = 0;
		if (i < 7) {
			u_int32_t stat = HPPA_FPU_OP(*pex);
			if (stat == HPPA_FPU_UNMPL)
				flt = FPE_FLTINV;
			else if (stat & HPPA_FPU_V)
				flt = FPE_FLTINV;
			else if (stat & HPPA_FPU_Z)
				flt = FPE_FLTDIV;
			else if (stat & HPPA_FPU_I)
				flt = FPE_FLTRES;
			else if (stat & HPPA_FPU_O)
				flt = FPE_FLTOVF;
			else if (stat & HPPA_FPU_U)
				flt = FPE_FLTUND;
			/* still left: under/over-flow w/ inexact */
			*pex = 0;
		}
		/* reset the trap flag, as if there was none */
		fpp[0] &= ~(((u_int64_t)HPPA_FPU_T) << 32);
		/* flush out, since load is done from phys, only 4 regs */
		fdcache(HPPA_SID_KERNEL, (vaddr_t)fpp, 8 * 4);

		sv.sival_int = va;
		trapsignal(p, SIGFPE, type &~ T_USER, flt, sv);
		}
		break;

	case T_EMULATION:
		panic("trap: emulation trap in the kernel");
		break;

	case T_EMULATION | T_USER:
d242 1
a242 1
		trapsignal(p, SIGILL, type &~ T_USER, ILL_ILLOPC, sv);
d272 1
a272 1
		trapsignal(p, SIGSEGV, vftype, SEGV_ACCERR, sv);
a281 1
		fault = VM_FAULT_PROTECT;
d287 1
d320 2
a321 1
		ret = uvm_fault(map, hppa_trunc_page(va), fault, vftype);
d340 1
a340 1
		if (va >= (vaddr_t)vm->vm_maxsaddr + ctob(vm->vm_ssize)) {
d342 1
a342 1
				vsize_t nss = btoc(va - USRSTACK + NBPG - 1);
d351 2
a352 8
#if 0
if (kdb_trap (type, va, frame))
	return;
#endif
				sv.sival_int = va;
				trapsignal(p, SIGSEGV, vftype,
				    ret == EACCES? SEGV_ACCERR : SEGV_MAPERR,
				    sv);
d355 1
a355 4
#if 0
if (kdb_trap (type, va, frame))
	return;
#endif
d358 3
a360 5
						p->p_addr->u_pcb.pcb_onfault);
#ifdef DDB
					frame->tf_iir = 0;
#endif
				} else {
d365 2
a366 3
					panic("trap: "
					    "uvm_fault(%p, %x, %d, %d): %d",
					    map, va, 0, vftype, ret);
a367 1
				}
d379 1
a407 4
	case T_CONDITION:
		panic("trap: divide by zero in the kernel");
		break;

d411 1
d428 1
a428 1
		panic("trap: unimplemented \'%s\' (%d)", tts, type);
a446 1

d449 4
d455 1
a455 1
syscall(frame)
d457 1
d459 1
a459 1
	register struct proc *p = curproc;
d461 2
a462 2
	int retq, nsys, code, argsize, argoff, oerror, error;
	register_t args[8], rval[2];
d469 1
d473 2
a474 3

	argoff = 4; retq = 0;
	switch (code = frame->tf_t1) {
d476 2
a477 5
		code = frame->tf_arg0;
		args[0] = frame->tf_arg1;
		args[1] = frame->tf_arg2;
		args[2] = frame->tf_arg3;
		argoff = 3;
d482 2
a483 17
		/*
		 * this works, because quads get magically swapped
		 * due to the args being layed backwards on the stack
		 * and then copied in words
		 */
		code = frame->tf_arg0;
		args[0] = frame->tf_arg2;
		args[1] = frame->tf_arg3;
		argoff = 2;
		retq = 1;
		break;
	default:
		args[0] = frame->tf_arg0;
		args[1] = frame->tf_arg1;
		args[2] = frame->tf_arg2;
		args[3] = frame->tf_arg3;
		break;
d490 1
a490 45

	oerror = error = 0;
	if ((argsize = callp->sy_argsize)) {
		int i;

		for (i = 0, argsize -= argoff * 4;
		    argsize > 0; i++, argsize -= 4) {
			error = copyin((void *)(frame->tf_sp +
			    HPPA_FRAME_ARG(i + 4)), args + i + argoff, 4);

			if (error)
				break;
		}

		/*
		 * coming from syscall() or __syscall we must be
		 * having one of those w/ a 64 bit arguments,
		 * which needs a word swap due to the order
		 * of the arguments on the stack.
		 * this assumes that none of 'em are called
		 * by their normal syscall number, maybe a regress
		 * test should be used, to whatch the behaviour.
		 */
		if (!error && argoff < 4) {
			int t;

			i = 0;
			switch (code) {
			case SYS_lseek:		retq = 0;
			case SYS_truncate:
			case SYS_ftruncate:	i = 2;	break;
			case SYS_preadv:
			case SYS_pwritev:
			case SYS_pread:
			case SYS_pwrite:	i = 4;	break;
			case SYS_mmap:		i = 6;	break;
			}

			if (i) {
				t = args[i];
				args[i] = args[i + 1];
				args[i + 1] = t;
			}
		}
	}
d497 1
a497 1
		ktrsyscall(p, code, callp->sy_argsize, args);
a498 2
	if (error)
		goto bad;
d501 1
a501 1
	rval[1] = frame->tf_ret1;
d504 1
a504 1
		oerror = error = systrace_redirect(code, p, args, rval);
d507 1
a507 1
		oerror = error = (*callp->sy_call)(p, args, rval);
d513 1
a513 1
		frame->tf_ret1 = rval[!retq];
a521 1
		frame = p->p_md.md_regs;
a523 1
	bad:
d530 1
a530 1
	scdebug_ret(p, code, oerror, rval);
d535 1
a535 1
		ktrsysret(p, code, oerror, rval[0]);
@


1.34.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d4 1
a4 1
 * Copyright (c) 1998-2003 Michael Shalayeff
d26 2
a27 2
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF MIND,
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
a51 1
#include <machine/db_machdep.h>	/* XXX always needed for inst_store() */
d53 1
d94 4
a97 2
void
userret(struct proc *p, register_t pc, u_quad_t oticks)
a105 7
	if (astpending) {
		astpending = 0;
		if (p->p_flag & P_OWEUPC) {
			p->p_flag &= ~P_OWEUPC;
			ADDUPROF(p);
		}
	}
d132 1
d141 1
a141 1
	int ret, trapnum;
a143 3
#ifdef DIAGNOSTIC
	int oldcpl = cpl;
#endif
d151 1
a151 1
		vftype = UVM_PROT_EXEC;
d157 1
a157 1
			vftype = UVM_PROT_EXEC;
d159 1
a159 1
			vftype = UVM_PROT_WRITE;
d161 1
a161 1
			vftype = UVM_PROT_READ;
d167 1
a172 1
#ifdef TRAPDEBUG
a189 6
	if (trapnum != T_INTERRUPT) {
		uvmexp.traps++;
		mtctl(frame->tf_eiem, CR_EIEM);
	} else
		uvmexp.intrs++;

d192 2
a193 1
	case T_NONEXIST | T_USER:
d195 3
a197 1
		printf("trap: elvis has just left the building!\n");
d199 1
a199 1

d201 2
a202 1
	case T_RECOVERY | T_USER:
d204 3
a206 1
		printf("trap: handicapped");
d208 1
d218 1
a218 2
	case T_HPMC:
	case T_HPMC | T_USER:
a241 3
		/* XXX */
		frame->tf_iioq_head = frame->tf_iioq_tail;
		frame->tf_iioq_tail += 4;
d294 1
a294 1

d326 1
a326 2
	case T_DATACC:
	case T_DATACC | T_USER:
d328 12
a339 20
	case T_ITLBMISS:
	case T_ITLBMISS | T_USER:
	case T_DTLBMISS:
	case T_DTLBMISS | T_USER:
	case T_ITLBMISSNA:
	case T_ITLBMISSNA | T_USER:
	case T_DTLBMISSNA:
	case T_DTLBMISSNA | T_USER:
	case T_TLB_DIRTY:
	case T_TLB_DIRTY | T_USER:
		/*
		 * user faults out of user addr space are always a fail,
		 * this happens on va >= VM_MAXUSER_ADDRESS, where
		 * space id will be zero and therefore cause
		 * a misbehave lower in the code.
		 */
		if (type & T_USER && va >= VM_MAXUSER_ADDRESS) {
			sv.sival_int = va;
			trapsignal(p, SIGSEGV, vftype, SEGV_ACCERR, sv);
			break;
d345 1
a345 1
		if (space == HPPA_SID_KERNEL)
d347 1
a347 2
		else {
			vm = p->p_vmspace;
d349 14
d364 2
d367 4
a370 4
		if (type & T_USER && map->pmap->pm_space != space) {
			sv.sival_int = va;
			trapsignal(p, SIGSEGV, vftype, SEGV_MAPERR, sv);
			break;
d373 3
a375 1
		ret = uvm_fault(map, hppa_trunc_page(va), fault, vftype);
d384 1
a384 2
		if (space != 0 && va < (vaddr_t)vm->vm_minsaddr &&
		    va >= (vaddr_t)vm->vm_maxsaddr + ctob(vm->vm_ssize)) {
d395 4
d405 4
d416 4
d423 1
d435 1
a435 1
	case T_INTERRUPT | T_USER:
d437 25
a467 1
	case T_LOWERPL:
d477 1
a477 2
	case T_DATAPID:
	case T_DATAPID | T_USER:
d487 1
a487 1
		panic("trap: unimplemented \'%s\' (%d)", tts, trapnum);
a489 9
#ifdef DIAGNOSTIC
	if (cpl != oldcpl)
		printf("WARNING: SPL (%d) NOT LOWERED ON "
		    "TRAP (%d) EXIT\n", cpl, trapnum);
#endif

	if (trapnum != T_INTERRUPT)
		splx(cpl);	/* process softints */

d491 1
a491 1
		userret(p, frame->tf_iioq_head, 0);
d511 2
a512 1
syscall(struct trapframe *frame)
a517 3
#ifdef DIAGNOSTIC
	int oldcpl = cpl;
#endif
a626 2
	p = curproc;
	frame = p->p_md.md_regs;
d629 2
d638 1
d640 2
a653 1
	splx(cpl);	/* process softints */
a656 6
#endif
#ifdef DIAGNOSTIC
	if (cpl != oldcpl)
		printf("WARNING: SPL (0x%x) NOT LOWERED ON "
		    "syscall(0x%x, 0x%x, 0x%x, 0x%x...) EXIT, PID %d\n",
		    cpl, code, args[0], args[1], args[2], p->p_pid);
@


1.33
log
@Sync in more uvm changes from NetBSD.
This time we're getting rid of KERN_* and VM_PAGER_* error codes and
use errnos instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.32 2001/11/06 20:58:48 mickey Exp $	*/
d144 2
a145 2
	register vaddr_t va;
	register vm_map_t map;
@


1.32
log
@child_return unscrewart
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.31 2001/11/06 19:53:14 miod Exp $	*/
d338 1
a338 1
			if (ret == KERN_SUCCESS) {
d342 2
a343 2
			} else if (ret == KERN_PROTECTION_FAILURE)
				ret = KERN_INVALID_ADDRESS;
d346 1
a346 1
		if (ret != KERN_SUCCESS) {
@


1.31
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.30 2001/09/19 20:50:56 mickey Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998-2000 Michael Shalayeff
d438 2
a439 2
child_return(p)
	struct proc *p;
d441 1
@


1.30
log
@merge vm/vm_kern.h into uvm/uvm_extern.h; art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.29 2001/09/14 14:58:44 art Exp $	*/
a49 1
#include <vm/vm.h>
@


1.29
log
@simplify userret
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.28 2001/05/05 20:56:37 art Exp $	*/
a50 1
#include <vm/vm_kern.h>
@


1.28
log
@Get rid of CLSIZE and all related stuff.
CLSIZE -> 1
CLBYTES -> PAGE_SIZE
OLOFSET -> PAGE_MASK
etc.
At the same time some archs needed some cleaning in vmparam.h so that
goes in at the same time.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.27 2001/04/01 06:13:40 mickey Exp $	*/
a118 1
		register int s;
d120 1
a120 6
		 * Since we are curproc, a clock interrupt could
		 * change our priority without changing run queues
		 * (the running process is not kept on a run queue).
		 * If this happened after we setrunqueue ourselves but
		 * before we switch()'ed, we might not be on the queue
		 * indicated by our priority.
d122 1
a122 5
		s = splstatclock();
		setrunqueue(p);
		p->p_stats->p_ru.ru_nivcsw++;
		mi_switch();
		splx(s);
@


1.27
log
@remove a little debugging
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.26 2001/03/22 23:42:52 mickey Exp $	*/
d351 1
a351 1
				vsize_t nss = clrnd(btoc(va - USRSTACK + NBPG));
@


1.26
log
@handle d/i prot traps proper
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.25 2001/01/29 00:01:59 mickey Exp $	*/
d166 1
a166 2
extern db_regs_t ddb_regs;
ddb_regs = *frame;
@


1.25
log
@implement a few macros in cpu.h; pointer out by miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.23 2000/11/10 18:15:38 art Exp $	*/
d33 2
a34 2
#undef INTRDEBUG
#undef TRAPDEBUG
a302 2
	case T_DPROT:
	case T_IPROT:
d423 2
@


1.24
log
@dirty trap should be handed w/ uvm_fault() as well
@
text
@d102 1
a102 1
int want_resched;
d311 1
a311 1
		va = trunc_page(va);
@


1.23
log
@Change the ktrace interface functions from taking the trace vnode to taking the
traced proc. The vnode is in the proc and all functions need the proc.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.22 2000/11/08 16:22:36 mickey Exp $	*/
a234 1
	case T_TLB_DIRTY: case T_TLB_DIRTY | T_USER:
d305 6
a310 5
	case T_DATACC:   	case T_DATACC   | T_USER:
	case T_ITLBMISS:	case T_ITLBMISS | T_USER:
	case T_DTLBMISS:	case T_DTLBMISS | T_USER:
	case T_ITLBMISSNA:	case T_ITLBMISSNA | T_USER:
	case T_DTLBMISSNA:	case T_DTLBMISSNA | T_USER:
@


1.22
log
@use net/netisr_dispatch.h
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.21 2000/07/05 22:20:02 mickey Exp $	*/
d457 1
a457 1
		ktrsysret(p->p_tracep, SYS_fork, 0, 0);
d511 1
a511 1
		ktrsyscall(p->p_tracep, code, argsize, args);
d543 1
a543 1
		ktrsysret(p->p_tracep, code, error, rval[0]);
@


1.21
log
@missing semicolon
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.20 2000/06/08 22:25:19 niklas Exp $	*/
d419 2
a420 40
#define	DONET(m,c) if (ni & (1 << (m))) c()
#include "ether.h"
#if NETHER > 0
			DONET(NETISR_ARP, arpintr);
#endif
#ifdef INET
			DONET(NETISR_IP, ipintr);
#endif
#ifdef INET6
			DONET(NETISR_IPV6, ip6intr);
#endif
#ifdef NETATALK
			DONET(NETISR_ATALK, atintr);
#endif
#ifdef IMP
			DONET(NETISR_IMP, impintr);
#endif
#ifdef IPX
			DONET(NETISR_IPX, ipxintr);
#endif
#ifdef NS
			DONET(NETISR_NS, nsintr);
#endif
#ifdef ISO
			DONET(NETISR_ISO, clnlintr);
#endif
#ifdef CCITT
			DONET(NETISR_CCITT, ccittintr);
#endif
#ifdef NATM
			DONET(NETISR_NATM, natmintr);
#endif
#include "ppp.h"
#if NPPP > 0
			DONET(NETISR_PPP, pppintr);
#endif
#include "bridge.h"
#if NBRIDGE > 0
			DONET(NETISR_BRIDGE, bridgeintr);
#endif
@


1.20
log
@Add explicit inclusions of signalvar.h to files actually using syms defined
there but relying on an indirect inclusion
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.20 2000/06/08 21:11:58 niklas Exp $	*/
d457 1
a457 1
			DONET(NETISR_BRIDGE, bridgeintr)
@


1.19
log
@mark interrupt frames
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.18 2000/01/25 22:39:57 mickey Exp $	*/
d42 1
@


1.19.2.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.27 2001/04/01 06:13:40 mickey Exp $	*/
d33 2
a34 2
/* #define INTRDEBUG */
/* #define TRAPDEBUG */
a41 1
#include <sys/signalvar.h>
d101 1
a101 1
int want_resched, astpending;
d165 2
a166 1

d234 1
d303 8
a310 7
	case T_DATACC:   	case T_USER | T_DATACC:
	case T_ITLBMISS:	case T_USER | T_ITLBMISS:
	case T_DTLBMISS:	case T_USER | T_DTLBMISS:
	case T_ITLBMISSNA:	case T_USER | T_ITLBMISSNA:
	case T_DTLBMISSNA:	case T_USER | T_DTLBMISSNA:
	case T_TLB_DIRTY:	case T_USER | T_TLB_DIRTY:
		va = hppa_trunc_page(va);
d418 40
a457 2
#define	DONETISR(m,c) if (ni & (1 << (m))) c()
#include <net/netisr_dispatch.h>
a461 2
	case T_DPROT:
	case T_IPROT:
d494 1
a494 1
		ktrsysret(p, SYS_fork, 0, 0);
d548 1
a548 1
		ktrsyscall(p, code, argsize, args);
d580 1
a580 1
		ktrsysret(p, code, error, rval[0]);
@


1.19.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.19.2.1 2001/04/18 16:06:16 niklas Exp $	*/
d351 1
a351 1
				vsize_t nss = btoc(va - USRSTACK + NBPG);
@


1.19.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.19.2.2 2001/07/04 10:16:05 niklas Exp $	*/
d51 1
d119 1
d121 6
a126 1
		 * We're being preempted.
d128 5
a132 1
		preempt(NULL);
@


1.19.2.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d4 1
a4 1
 * Copyright (c) 1998-2001 Michael Shalayeff
d50 1
d439 2
a440 2
child_return(arg)
	void *arg;
a441 1
	struct proc *p = (struct proc *)arg;
@


1.19.2.5
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.19.2.4 2001/11/13 21:00:51 niklas Exp $	*/
d144 2
a145 2
	vaddr_t va;
	struct vm_map *map;
d338 1
a338 1
			if (ret == 0) {
d342 2
a343 2
			} else if (ret == EACCES)
				ret = EFAULT;
d346 1
a346 1
		if (ret != 0) {
@


1.19.2.6
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d149 2
d152 1
a152 2
	u_int opcode;
	int ret, s, si, trapnum;
a154 1
	trapnum = type & ~T_USER;
d156 1
a156 1
	if (trapnum == T_ITLBMISS || trapnum == T_ITLBMISSNA) {
d170 1
a170 1
	if (trapnum > trap_types)
d173 1
a173 1
		tts = trap_type[trapnum];
d175 2
a176 2
	if (trapnum != T_INTERRUPT && trapnum != T_IBREAK)
		db_printf("trap: %x, %s for %x:%x at %x:%x, fl=%x, fp=%p\n",
d179 1
a179 1
	else if (trapnum  == T_IBREAK)
a322 7
#ifdef TRAPDEBUG
		if (space == -1) {
			extern int pmapdebug;
			pmapdebug = 0xffffff;
		}
#endif

a325 5
		if (space == -1) {
			extern int pmapdebug;
			pmapdebug = 0;
		}

d348 1
d513 2
a514 2
		frame->tf_iioq_head -= 12;
		frame->tf_iioq_tail -= 12;
d568 1
a568 1
	u_int32_t eirr = 0, r;
d573 1
a573 7
		mfctl(CR_EIRR, r);
		eirr |= r;
#ifdef INTRDEBUG
		if (eirr & 0x7fffffff)
			db_printf ("cpu_intr: 0x%08x & 0x%08x\n",
			    eirr, frame->tf_eiem);
#endif
d589 1
a589 1
				s = splraise(iv->pri);
@


1.19.2.7
log
@Merge in -current from about a week ago
@
text
@d33 1
d38 1
d44 3
d52 3
d59 3
a61 1
#ifdef TRAPDEBUG
d64 1
a64 1
#endif
d102 3
a104 1
void syscall(struct trapframe *frame, int *args);
d314 1
a314 1
		if (map->pmap->pm_space != space) {
d317 1
a317 1
			    space, map->pmap->pm_space);
d364 3
d371 1
d374 1
a374 1
#if 0
d437 1
a437 1
#if 0
d544 78
@


1.19.2.8
log
@Sync the SMP branch with 3.3
@
text
@d4 1
a4 1
 * Copyright (c) 1998-2003 Michael Shalayeff
d26 2
a27 2
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF MIND,
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
a44 3
#include "systrace.h"
#include <dev/systrace.h>

a48 1
#include <machine/db_machdep.h>	/* XXX always needed for inst_store() */
d50 1
d89 1
d92 4
a95 2
void
userret(struct proc *p, register_t pc, u_quad_t oticks)
a103 7
	if (astpending) {
		astpending = 0;
		if (p->p_flag & P_OWEUPC) {
			p->p_flag &= ~P_OWEUPC;
			ADDUPROF(p);
		}
	}
d131 1
d139 1
a139 1
	int ret, trapnum;
a140 4
	vm_fault_t fault = VM_FAULT_INVALID;
#ifdef DIAGNOSTIC
	int oldcpl = cpl;
#endif
d144 1
a144 2
	if (trapnum == T_ITLBMISS ||
	    trapnum == T_EXCEPTION || trapnum == T_EMULATION) {
d147 1
a147 1
		vftype = UVM_PROT_EXEC;
d151 1
a151 7
		/* what is the vftype for the T_ITLBMISSNA ??? XXX */
		if (va == frame->tf_iioq_head)
			vftype = UVM_PROT_EXEC;
		else if (inst_store(opcode))
			vftype = UVM_PROT_WRITE;
		else
			vftype = UVM_PROT_READ;
d157 1
a162 1
#ifdef TRAPDEBUG
a179 3
	if (trapnum != T_INTERRUPT)
		mtctl(frame->tf_eiem, CR_EIEM);

d182 2
a183 1
	case T_NONEXIST | T_USER:
d185 3
a187 1
		printf("trap: elvis has just left the building!\n");
d189 1
a189 1

d191 2
a192 1
	case T_RECOVERY | T_USER:
d194 3
a196 1
		printf("trap: handicapped");
d198 1
d208 2
a209 2
	case T_HPMC:
	case T_HPMC | T_USER:
a232 3
		/* XXX */
		frame->tf_iioq_head = frame->tf_iioq_tail;
		frame->tf_iioq_tail += 4;
d237 1
a237 30
	case T_EXCEPTION | T_USER: {
		u_int64_t *fpp = (u_int64_t *)frame->tf_cr30;
		u_int32_t *pex;
		int i, flt;

		pex = (u_int32_t *)&fpp[0];
		for (i = 0, pex++; i < 7 && !*pex; i++, pex++);
		flt = 0;
		if (i < 7) {
			u_int32_t stat = HPPA_FPU_OP(*pex);
			if (stat == HPPA_FPU_UNMPL)
				flt = FPE_FLTINV;
			else if (stat & HPPA_FPU_V)
				flt = FPE_FLTINV;
			else if (stat & HPPA_FPU_Z)
				flt = FPE_FLTDIV;
			else if (stat & HPPA_FPU_I)
				flt = FPE_FLTRES;
			else if (stat & HPPA_FPU_O)
				flt = FPE_FLTOVF;
			else if (stat & HPPA_FPU_U)
				flt = FPE_FLTUND;
			/* still left: under/over-flow w/ inexact */
			*pex = 0;
		}
		/* reset the trap flag, as if there was none */
		fpp[0] &= ~(((u_int64_t)HPPA_FPU_T) << 32);
		/* flush out, since load is done from phys, only 4 regs */
		fdcache(HPPA_SID_KERNEL, (vaddr_t)fpp, 8 * 4);

d239 1
a239 11
		trapsignal(p, SIGFPE, type &~ T_USER, flt, sv);
		}
		break;

	case T_EMULATION:
		panic("trap: emulation trap in the kernel");
		break;

	case T_EMULATION | T_USER:
		sv.sival_int = va;
		trapsignal(p, SIGILL, type &~ T_USER, ILL_ILLOPC, sv);
d246 1
a246 1

d269 1
a269 1
		trapsignal(p, SIGSEGV, vftype, SEGV_ACCERR, sv);
d278 8
a285 24
	case T_DATACC:
	case T_DATACC | T_USER:
		fault = VM_FAULT_PROTECT;
	case T_ITLBMISS:
	case T_ITLBMISS | T_USER:
	case T_DTLBMISS:
	case T_DTLBMISS | T_USER:
	case T_ITLBMISSNA:
	case T_ITLBMISSNA | T_USER:
	case T_DTLBMISSNA:
	case T_DTLBMISSNA | T_USER:
	case T_TLB_DIRTY:
	case T_TLB_DIRTY | T_USER:
		/*
		 * user faults out of user addr space are always a fail,
		 * this happens on va >= VM_MAXUSER_ADDRESS, where
		 * space id will be zero and therefore cause
		 * a misbehave lower in the code.
		 */
		if (type & T_USER && va >= VM_MAXUSER_ADDRESS) {
			sv.sival_int = va;
			trapsignal(p, SIGSEGV, vftype, SEGV_ACCERR, sv);
			break;
		}
d287 2
a288 1
		if (!(vm = p->p_vmspace)) {
d290 1
d303 6
a308 8
			if (map->pmap->pm_space != HPPA_SID_KERNEL) {
				sv.sival_int = va;
				trapsignal(p, SIGSEGV, vftype, SEGV_MAPERR, sv);
			} else {
				printf("trap: space missmatch %d != %d\n",
				    space, map->pmap->pm_space);
				goto dead_end;
			}
d317 2
a318 1
		ret = uvm_fault(map, hppa_trunc_page(va), fault, vftype);
d337 1
a337 2
		if (space != 0 && va < (vaddr_t)vm->vm_minsaddr &&
		    va >= (vaddr_t)vm->vm_maxsaddr + ctob(vm->vm_ssize)) {
d339 1
a339 1
				vsize_t nss = btoc(va - USRSTACK + NBPG - 1);
d348 2
a349 4
				sv.sival_int = va;
				trapsignal(p, SIGSEGV, vftype,
				    ret == EACCES? SEGV_ACCERR : SEGV_MAPERR,
				    sv);
d352 1
d355 9
a363 3
						p->p_addr->u_pcb.pcb_onfault);
#ifdef DDB
					frame->tf_iir = 0;
a364 5
				} else {
					panic("trap: "
					    "uvm_fault(%p, %x, %d, %d): %d",
					    map, va, 0, vftype, ret);
				}
d375 2
a376 1
	case T_INTERRUPT | T_USER:
d378 25
a404 5
	case T_CONDITION:
		panic("trap: divide by zero in the kernel");
		break;

	case T_LOWERPL:
d408 1
d415 1
a415 2
	case T_DATAPID:
	case T_DATAPID | T_USER:
d425 1
a425 1
		panic("trap: unimplemented \'%s\' (%d)", tts, trapnum);
a427 9
#ifdef DIAGNOSTIC
	if (cpl != oldcpl)
		printf("WARNING: SPL (%d) NOT LOWERED ON "
		    "TRAP (%d) EXIT\n", cpl, trapnum);
#endif

	if (trapnum != T_INTERRUPT)
		splx(cpl);	/* process softints */

d429 1
a429 1
		userret(p, frame->tf_iioq_head, 0);
a443 1

d446 4
d452 3
a454 1
syscall(struct trapframe *frame)
d456 1
a456 1
	register struct proc *p = curproc;
d458 2
a459 5
	int retq, nsys, code, argsize, argoff, oerror, error;
	register_t args[8], rval[2];
#ifdef DIAGNOSTIC
	int oldcpl = cpl;
#endif
d466 1
d470 2
a471 3

	argoff = 4; retq = 0;
	switch (code = frame->tf_t1) {
d473 2
a474 5
		code = frame->tf_arg0;
		args[0] = frame->tf_arg1;
		args[1] = frame->tf_arg2;
		args[2] = frame->tf_arg3;
		argoff = 3;
d479 2
a480 17
		/*
		 * this works, because quads get magically swapped
		 * due to the args being layed backwards on the stack
		 * and then copied in words
		 */
		code = frame->tf_arg0;
		args[0] = frame->tf_arg2;
		args[1] = frame->tf_arg3;
		argoff = 2;
		retq = 1;
		break;
	default:
		args[0] = frame->tf_arg0;
		args[1] = frame->tf_arg1;
		args[2] = frame->tf_arg2;
		args[3] = frame->tf_arg3;
		break;
d487 1
a487 45

	oerror = error = 0;
	if ((argsize = callp->sy_argsize)) {
		int i;

		for (i = 0, argsize -= argoff * 4;
		    argsize > 0; i++, argsize -= 4) {
			error = copyin((void *)(frame->tf_sp +
			    HPPA_FRAME_ARG(i + 4)), args + i + argoff, 4);

			if (error)
				break;
		}

		/*
		 * coming from syscall() or __syscall we must be
		 * having one of those w/ a 64 bit arguments,
		 * which needs a word swap due to the order
		 * of the arguments on the stack.
		 * this assumes that none of 'em are called
		 * by their normal syscall number, maybe a regress
		 * test should be used, to whatch the behaviour.
		 */
		if (!error && argoff < 4) {
			int t;

			i = 0;
			switch (code) {
			case SYS_lseek:		retq = 0;
			case SYS_truncate:
			case SYS_ftruncate:	i = 2;	break;
			case SYS_preadv:
			case SYS_pwritev:
			case SYS_pread:
			case SYS_pwrite:	i = 4;	break;
			case SYS_mmap:		i = 6;	break;
			}

			if (i) {
				t = args[i];
				args[i] = args[i + 1];
				args[i + 1] = t;
			}
		}
	}
d494 1
a494 1
		ktrsyscall(p, code, callp->sy_argsize, args);
a495 2
	if (error)
		goto bad;
d498 2
a499 8
	rval[1] = frame->tf_ret1;
#if NSYSTRACE > 0
	if (ISSET(p->p_flag, P_SYSTRACE))
		oerror = error = systrace_redirect(code, p, args, rval);
	else
#endif
		oerror = error = (*callp->sy_call)(p, args, rval);
	switch (error) {
d504 1
a504 1
		frame->tf_ret1 = rval[!retq];
a512 1
		frame = p->p_md.md_regs;
a514 1
	bad:
d521 1
a521 1
	scdebug_ret(p, code, oerror, rval);
a523 1
	splx(cpl);	/* process softints */
d526 1
a526 7
		ktrsysret(p, code, oerror, rval[0]);
#endif
#ifdef DIAGNOSTIC
	if (cpl != oldcpl)
		printf("WARNING: SPL (0x%x) NOT LOWERED ON "
		    "syscall(0x%x, 0x%x, 0x%x, 0x%x...) EXIT, PID %d\n",
		    cpl, code, args[0], args[1], args[2], p->p_pid);
@


1.19.2.9
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.19.2.8 2003/03/27 23:26:54 niklas Exp $	*/
d197 1
a197 2
	if (trapnum != T_INTERRUPT) {
		uvmexp.traps++;
a198 2
	} else
		uvmexp.intrs++;
d358 5
d366 1
a366 1
		if (space == HPPA_SID_KERNEL)
d368 1
a368 2
		else {
			vm = p->p_vmspace;
d370 16
d387 2
d390 4
a393 4
		if (type & T_USER && map->pmap->pm_space != space) {
			sv.sival_int = va;
			trapsignal(p, SIGSEGV, vftype, SEGV_MAPERR, sv);
			break;
d396 3
a398 1
		ret = uvm_fault(map, hppa_trunc_page(va), fault, vftype);
a625 2
	p = curproc;
	frame = p->p_md.md_regs;
d628 2
d637 1
d639 2
@


1.19.2.10
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d386 1
a386 2
		if (space != HPPA_SID_KERNEL &&
		    va < (vaddr_t)vm->vm_minsaddr &&
d412 1
a412 1
					    "uvm_fault(%p, %lx, %d, %d): %d",
d466 1
a466 8
	/*
	 * in case we were interrupted from the syscall gate page
	 * treat this as we were not realy running user code no more
	 * for weird things start to happen on return to the userland
	 * and also see a note in locore.S:TLABEL(all)
	 */
	if ((type & T_USER) &&
	    (frame->tf_iioq_head & ~PAGE_MASK) != SYSCALLGATE)
d520 1
a520 1
		 * due to the args being laid backwards on the stack
d562 1
a562 1
		 * test should be used, to watch the behaviour.
d629 1
d635 1
a635 1
	if (cpl != oldcpl) {
a638 2
		cpl = oldcpl;
	}
a639 1
	splx(cpl);	/* process softints */
@


1.19.2.11
log
@Merge with the trunk
@
text
@d4 1
a4 1
 * Copyright (c) 1998-2004 Michael Shalayeff
d15 5
d24 7
a30 8
 * IN NO EVENT SHALL THE AUTHOR OR HIS RELATIVES BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
a93 36
#define	frame_regmap(tf,r)	(((u_int *)(tf))[hppa_regmap[(r)]])
u_char hppa_regmap[32] = {
	offsetof(struct trapframe, tf_pad[0]) / 4,	/* r0 XXX */
	offsetof(struct trapframe, tf_r1) / 4,
	offsetof(struct trapframe, tf_rp) / 4,
	offsetof(struct trapframe, tf_r3) / 4,
	offsetof(struct trapframe, tf_r4) / 4,
	offsetof(struct trapframe, tf_r5) / 4,
	offsetof(struct trapframe, tf_r6) / 4,
	offsetof(struct trapframe, tf_r7) / 4,
	offsetof(struct trapframe, tf_r8) / 4,
	offsetof(struct trapframe, tf_r9) / 4,
	offsetof(struct trapframe, tf_r10) / 4,
	offsetof(struct trapframe, tf_r11) / 4,
	offsetof(struct trapframe, tf_r12) / 4,
	offsetof(struct trapframe, tf_r13) / 4,
	offsetof(struct trapframe, tf_r14) / 4,
	offsetof(struct trapframe, tf_r15) / 4,
	offsetof(struct trapframe, tf_r16) / 4,
	offsetof(struct trapframe, tf_r17) / 4,
	offsetof(struct trapframe, tf_r18) / 4,
	offsetof(struct trapframe, tf_t4) / 4,
	offsetof(struct trapframe, tf_t3) / 4,
	offsetof(struct trapframe, tf_t2) / 4,
	offsetof(struct trapframe, tf_t1) / 4,
	offsetof(struct trapframe, tf_arg3) / 4,
	offsetof(struct trapframe, tf_arg2) / 4,
	offsetof(struct trapframe, tf_arg1) / 4,
	offsetof(struct trapframe, tf_arg0) / 4,
	offsetof(struct trapframe, tf_dp) / 4,
	offsetof(struct trapframe, tf_ret0) / 4,
	offsetof(struct trapframe, tf_ret1) / 4,
	offsetof(struct trapframe, tf_sp) / 4,
	offsetof(struct trapframe, tf_r31) / 4,
};

d266 1
a266 1
			if (stat & HPPA_FPU_UNMPL)
d268 1
a268 1
			else if (stat & (HPPA_FPU_V << 1))
d270 1
a270 1
			else if (stat & (HPPA_FPU_Z << 1))
d272 1
a272 1
			else if (stat & (HPPA_FPU_I << 1))
d274 1
a274 1
			else if (stat & (HPPA_FPU_O << 1))
d276 1
a276 1
			else if (stat & (HPPA_FPU_U << 1))
d297 1
a297 1
		trapsignal(p, SIGILL, type &~ T_USER, ILL_COPROC, sv);
d308 5
a378 8
		/* dig probe insn */
		if (ret && trapnum == T_DTLBMISSNA &&
		    (frame->tf_iir & 0xfc001f80) == 0x04001180) {
			frame_regmap(frame, frame->tf_iir & 0x1f) = 0;
			frame->tf_ipsw |= PSL_N;
			break;
		}

a433 15
	case T_ILLEGAL:
	case T_ILLEGAL | T_USER:
		/* see if it's a SPOP1,,0 */
		if ((frame->tf_iir & 0xfffffe00) == 0x10000200) {
			frame_regmap(frame, frame->tf_iir & 0x1f) = 0;
			frame->tf_ipsw |= PSL_N;
			break;
		}
		if (type & T_USER) {
			sv.sival_int = va;
			trapsignal(p, SIGILL, type &~ T_USER, ILL_ILLOPC, sv);
			break;
		}
		/* FALLTHROUGH */

d438 1
d483 1
a483 10
	struct trapframe *tf = p->p_md.md_regs;

	/*
	 * Set up return value registers as libc:fork() expects
	 */
	tf->tf_ret0 = 0;
	tf->tf_ret1 = 1;	/* ischild */
	tf->tf_t1 = 0;		/* errno */

	userret(p, tf->tf_iioq_head, 0);
@


1.19.2.12
log
@sync to HEAD
@
text
@d281 3
a285 1
		trapsignal(p, SIGTRAP, type &~ T_USER, TRAP_BRKPT, sv);
@


1.18
log
@some more cautions and debuggings; repair __syscall
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.17 2000/01/17 00:30:17 mickey Exp $	*/
d395 1
@


1.17
log
@some more paranoid checks, shorter trap desriptions
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.16 2000/01/12 05:51:02 mickey Exp $	*/
d34 1
a34 1
#define TRAPDEBUG
a65 1
#define	FAULT_TYPE(op)	(VM_PROT_READ|(inst_store(op) ? VM_PROT_WRITE : 0))
d165 2
a166 1

d171 1
a171 1
		vftype = VM_PROT_EXECUTE;
d175 1
a175 1
		vftype = FAULT_TYPE(opcode);
d198 2
a199 1
		if (frame < (struct trapframe *)&etext)
d201 1
d211 2
d220 2
d241 1
a241 1
		if (kdb_trap (type, 0, frame)) {
d313 4
a316 1
		if (!vm)
d318 1
d328 9
d339 5
d378 1
a378 1
if (kdb_trap (type, 0, frame))
a385 2
if (type == (T_DATACC|T_USER) && kdb_trap (type, 0, frame))
	return;
d397 1
a397 1
if (kdb_trap (type, 0, frame))
d476 1
a476 1
if (kdb_trap (type, 0, frame))
d526 1
a526 1
		code = frame->tf_arg0;
d532 1
a532 1
		code = frame->tf_arg0; /* XXX or arg1? */
d554 2
a555 1
		/* curproc may change inside the fork() */
d562 1
d565 1
a572 1
	p = curproc;
d576 1
a576 1
	userret(p, p->p_md.md_regs->tf_iioq_head, 0);
d641 1
a641 1
#ifdef DEBUG
d646 3
a648 1
			} else
d650 1
@


1.16
log
@choose right map for a fault, better pcq advancement technique
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.15 2000/01/11 05:39:52 mickey Exp $	*/
d69 2
a70 2
	"invalid interrupt vector",
	"high priority machine check",
d74 2
a75 2
	"low-priority machine check",
	"instruction TLB miss fault",
d84 1
a84 1
	"data TLB miss",
d89 1
a89 1
	"TLB dirty bit",
d92 2
a93 2
	"higher-privelege transfer",
	"lower-privilege transfer",
d96 1
a96 1
	"data protection ID",
d187 1
a187 2
	if ((type & ~T_USER) != T_INTERRUPT &&
	    (type & ~T_USER) != T_IBREAK)
d195 6
d311 1
a311 1
		 * if could be a kernel map for exec_map faults
@


1.15
log
@rearrange diagnostic trap cases
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.14 1999/12/31 18:27:40 mickey Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998,1999 Michael Shalayeff
d50 1
d228 1
d233 1
a233 1
				frame->tf_iioq_head += 4;
d301 11
a311 1
		map = &vm->vm_map;
d337 3
a339 4
				pcbp = &p->p_addr->u_pcb;
				if (p && pcbp->pcb_onfault) {
#if PMAPDEBUG
					printf("trap: copyin/copyout\n");
d341 4
a344 3
					frame->tf_iioq_tail =
					    frame->tf_iioq_head =
					    pcbp->pcb_onfault;
@


1.14
log
@fix order of uvm_fault() arguments in debug printf (;
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.13 1999/12/17 01:48:45 mickey Exp $	*/
d211 13
a243 16
#ifdef DIAGNOSTIC
		/* these just can't happen ever */
	case T_PRIV_OP:
	case T_PRIV_REG:
		panic ("loss of mind");
		break;

		/* these just can't make it to the trap() ever */
	case T_HPMC:      case T_HPMC | T_USER:
	case T_EXCEPTION:
	case T_EMULATION:
	case T_TLB_DIRTY: case T_TLB_DIRTY | T_USER:
		panic ("trap: impossible \'%s\' (%d)", tts, type);
		break;
#endif

a248 1
	case T_EMULATION | T_USER:
@


1.13
log
@track the maximum accessed stack size; basically this small piece of code is the same in all the archs
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.12 1999/12/08 15:58:27 mickey Exp $	*/
d345 1
a345 1
				    map, va, vftype, FALSE, ret);
@


1.12
log
@s/ipv6intr/ip6intr/
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.11 1999/11/25 18:36:29 mickey Exp $	*/
d157 1
d302 2
a303 1
		map = &p->p_vmspace->vm_map;
d306 17
@


1.11
log
@many traps, syscall nad other stuff
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.10 1999/08/16 04:05:38 mickey Exp $	*/
d372 1
a372 1
			DONET(NETISR_IPV6, ipv6intr);
@


1.10
log
@report unhandled interrupts w/ DEBUG only
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.9 1999/08/16 03:22:58 mickey Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998 Michael Shalayeff
d55 3
d59 5
a63 1
#include <machine/autoconf.h>
d65 1
a65 1
#define	FAULT_TYPE(op)	(VM_PROT_READ|(inst_load(op) ? 0 : VM_PROT_WRITE))
d71 1
a71 1
	"recovery counter trap",
d75 22
a96 24
	"instruction protection trap",
	"Illegal instruction trap",
	"break instruction trap",
	"privileged operation trap",
	"privileged register trap",
	"overflow trap",
	"conditional trap",
	"assist exception trap",
	"data TLB miss fault",
	"ITLB non-access miss fault",
	"DTLB non-access miss fault",
	"data protection trap/unalligned data reference trap",
	"data break trap",
	"TLB dirty bit trap",
	"page reference trap",
	"assist emulation trap",
	"higher-privelege transfer trap",
	"lower-privilege transfer trap",
	"taken branch trap",
	"data access rights trap",
	"data protection ID trap",
	"unaligned data ref trap",
	"reserved",
	"reserved 2"
d154 2
a155 1
	register vm_offset_t va;
d163 1
d165 1
d169 1
d173 1
a174 2
	opcode = frame->tf_iir;
	vftype = FAULT_TYPE(opcode);
d176 1
a176 2
	if (USERMODE(frame->tf_iioq_head)) {
		type |= T_USER;
d178 1
a178 1
	}
d180 5
d187 3
a189 3
		printf ("trap: %d, %s for %x:%x at %x:%x\n",
			type, trap_type[type & ~T_USER], space, va,
			frame->tf_iisq_head, frame->tf_iioq_head);
d191 3
a193 3
		printf ("trap: break instruction %x:%x at %x:%x\n",
			break5(opcode), break13(opcode),
			frame->tf_iisq_head, frame->tf_iioq_head);
d198 1
d200 1
a200 1
		panic ("trap: zombie's on the bridge!!!");
d202 1
a202 1

d205 1
a208 11

#ifdef DIAGNOSTIC
	case T_HPMC:
	case T_HPMC | T_USER:
	case T_EXCEPTION:
	case T_EMULATION:
	case T_TLB_DIRTY:
	case T_TLB_DIRTY | T_USER:
		panic ("trap: impossible \'%s\' (%d)",
			trap_type[type & ~T_USER], type);
		break;
a209 1

d222 5
a227 1
		/* probably panic otherwise */
d230 16
d253 1
a253 1
		sv.sival_int = frame->tf_ior;
d258 1
a258 1
		sv.sival_int = frame->tf_ior;
d266 1
a266 1
		sv.sival_int = frame->tf_ior;
d271 1
a271 1
		sv.sival_int = frame->tf_ior;
d276 1
a276 1
		sv.sival_int = frame->tf_ior;
d283 1
a283 1
		sv.sival_int = frame->tf_ior;
d293 1
d295 5
a299 14
	case T_DPROT:
	case T_ITLBMISS:
	case T_ITLBMISS | T_USER:
	case T_ITLBMISSNA:
	case T_ITLBMISSNA | T_USER:
	case T_DTLBMISS:
	case T_DTLBMISS | T_USER:
	case T_DTLBMISSNA:
	case T_DTLBMISSNA | T_USER:
#if 0
if (kdb_trap (type, 0, frame))
return;
break;
#endif
d303 1
a303 1
		ret = uvm_fault(map, va, vftype, FALSE);
d306 1
d309 20
a328 3
			} else
				panic ("trap: uvm_fault(%p, %x, %d, %d): %d",
				       map, frame->tf_ior, vftype, 0, ret);
d330 2
d335 1
a335 1
		sv.sival_int = frame->tf_ior;
d342 4
a409 2
	case T_PRIV_OP:
	case T_PRIV_REG:
d415 1
a415 2
	case T_DATACC:   case T_DATACC   | T_USER:
	case T_DATAPID:  case T_DATAPID  | T_USER:
d421 5
a425 2
		panic ("trap: unimplemented \'%s\' (%d)",
			trap_type[type & ~T_USER], type);
d466 1
d469 1
a469 1
	code = frame->tf_arg0;
d472 1
a472 1
		code = frame->tf_arg1;
d478 1
a478 1
		code = frame->tf_arg1; /* XXX or arg2? */
d500 1
a500 2
		/* curproc may change iside the fork() */
		p = curproc;
d503 1
d513 1
a513 1
		frame->tf_ret0 = error;
d516 1
a516 1

d520 1
a520 1
	userret(p, p->p_md.md_regs->tf_rp, 0);
d574 1
a574 1
				printf ("cpu_intr: 0x%08x\n", (1 << bit));
d587 2
a588 2
					printf ("%s: can't handle interrupt\n",
						iv->evcnt.ev_name);
d591 1
a591 1
				printf ("cpu_intr: stray interrupt %d\n", bit);
a594 1

@


1.9
log
@unscrew the screup
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.8 1999/08/16 02:48:39 mickey Exp $	*/
d543 1
d546 1
a546 2

				/* no arg means pass the frame */
a547 4
#ifdef INTRDEBUG1
					panic ("%s: can't handle interrupt",
					       iv->evcnt.ev_name);
#else
d551 1
a551 5
				splx(s);
			} else {
#ifdef INTRDEBUG
				panic  ("cpu_intr: stray interrupt %d", bit);
#else
a552 2
#endif
			}
@


1.8
log
@evcnt count the interrupts, also optimize diagnostic printing
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.7 1999/08/14 03:06:55 mickey Exp $	*/
d45 1
d512 1
a512 1
	evcnt_attach(dv, dv->dv_xname, iv->evcnt);
d514 1
a514 1
	return p;
d539 1
a539 1
				register int s = splx(iv->pri);
d542 4
d547 1
a547 1
				if (!(iv->handler)(iv->arg? iv->arg:frame))
d550 1
a550 1
					       iv->name);
d553 1
a553 1
						iv->name);
@


1.7
log
@do the clock interrupt the narrow way.
fix soft interrupts.
some more debugs and other fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.6 1999/07/21 04:28:36 mickey Exp $	*/
d489 1
a489 1
	const char *name;
d496 1
a496 1
cpu_intr_establish(pri, irq, handler, arg, name)
d500 1
a500 1
	const char *name;
d502 1
a502 1
	register struct cpu_intr_vector *p;
d507 5
a511 5
	p = &cpu_intr_vectors[irq];
	p->name = name;
	p->pri = pri;
	p->handler = handler;
	p->arg = arg;
d521 1
a521 1
	register struct cpu_intr_vector *p;
d536 5
a540 3
			p = &cpu_intr_vectors[bit];
			if (p->handler) {
				register int s = splx(p->pri);
d542 1
a542 1
				if (!(p->handler)(p->arg? p->arg:frame))
d545 1
a545 1
					       p->name);
d548 1
a548 1
						p->name);
@


1.6
log
@skip break insn in the proper place, print cr28 in ddb, some debugging cruft
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.5 1999/07/16 01:59:26 mickey Exp $	*/
d33 1
a33 1
#define INTRDEBUG
d98 1
a98 1
void cpu_intr __P((u_int32_t t, struct trapframe *frame));
d152 1
a152 1
	u_int opcode, t;
d155 1
a155 1
	int s;
d157 7
a163 2
	va = frame->tf_ior;
	space = (pa_space_t) frame->tf_isr;
d172 9
a180 4
	if ((type & ~T_USER) != T_INTERRUPT)
		printf("trap: %d, %s for %x:%x at %x:%x\n",
		       type, trap_type[type & ~T_USER], space, va,
		       frame->tf_iisq_head, frame->tf_iioq_head);
a194 17
	case T_INTERRUPT:
	case T_INTERRUPT|T_USER:
		mfctl(CR_EIRR, t);
		t &= frame->tf_eiem;
		/* ACK it now */
		/* hardcode intvl timer intr, to save for proc switching */
		if (t & INT_ITMR) {
			mtctl(INT_ITMR, CR_EIRR);
			/* we've got an interval timer interrupt */
			cpu_initclocks();
			hardclock(frame);
			t ^= INT_ITMR;
		}
		if (t)
			cpu_intr(t, frame);
		break;

a207 3
		/* skip break instruction */
		frame->tf_iioq_head += 4;
		frame->tf_iioq_tail += 4;
d210 7
a216 1
		if (kdb_trap (type, 0, frame))
d218 3
d304 4
d309 2
a310 1
		/* do softint stuff here */
d312 1
a312 1
		if (sir & SIR_CLOCK) {
a313 1
			sir &= ~SIR_CLOCK;
d318 1
a318 1
		if (sir & SIR_NET) {
d324 2
a325 1
#define	DONET(m,c) if (ni & m) c()
d327 1
a327 1
			DONET (NETISR_ARP, arpintr);
a377 1
#ifdef HP7100_CPU
a383 1
#endif
d493 1
a493 1
} cpu_intr_vectors[CPU_NINTS - 1];
d504 1
a504 3
	/* don't allow to override any established vectors,
	   AND interval timer hard-bound one */
	if (irq >= (CPU_NINTS - 1) || cpu_intr_vectors[irq].handler)
d517 1
a517 2
cpu_intr(t, frame)
	u_int32_t t;
d526 1
a526 1
		eirr = (t | eirr) & frame->tf_eiem;
d533 2
a534 1
			printf ("cpu_intr: 0x%08x\n", (1 << bit));
d539 2
a540 1
				if (!(p->handler)(p->arg))
@


1.5
log
@almost all of them
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.4 1999/05/03 16:33:10 mickey Exp $	*/
d214 4
a219 1
	case T_IBREAK:
d281 5
@


1.4
log
@child_return(), some more traps to handle
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.3 1999/04/20 20:58:01 mickey Exp $	*/
d34 1
d46 2
d105 1
d150 1
d154 2
d159 2
d166 1
a166 1
#ifdef DEBUG
d175 2
a176 2
		/* we are screwd up by the central scrutinizer */
		panic ("trap: zombie on the bridge!!!");
d181 1
d200 1
a200 1
		return;
a202 1
	case T_IBREAK:
d204 3
d208 1
d214 16
a229 1
	case T_POWERFAIL:
d232 6
a237 1
	case T_LPMC:
d240 3
a242 1
	case T_PAGEREF:
d245 3
a247 3
	case T_DBREAK:
		if (kdb_trap (type, 0, frame))
			return;
d250 3
a252 1
	case T_EXCEPTION:	/* co-proc assist trap */
d255 5
a259 2
	case T_OVERFLOW:
	case T_CONDITION:
d262 4
a265 6
	case T_ILLEGAL:
	case T_PRIV_OP:
	case T_PRIV_REG:
	case T_HIGHERPL:
	case T_LOWERPL:
	case T_TAKENBR:
d268 2
a269 2
	case T_IPROT:	case T_IPROT | T_USER:
	case T_DPROT:	case T_DPROT | T_USER:
a278 1
		opcode = frame->tf_iir;
d281 14
a294 4
		ret = uvm_fault(map, va, FAULT_TYPE(opcode), FALSE);
		if (ret != KERN_SUCCESS)
			panic ("trap: uvm_fault(%p, %x, %d, %d): %d",
			       map, va, FAULT_TYPE(opcode), 0, ret);
d297 69
a368 1
	case T_DATALIGN: case T_DATALIGN | T_USER:
a373 2
	case T_EMULATION:
	case T_EMULATION | T_USER:
d378 3
@


1.3
log
@syscall(), fix interrupt handling
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.2 1999/01/11 05:11:22 millert Exp $	*/
d37 1
d40 4
d98 40
d157 1
a157 1

d162 1
a162 1

d192 2
d195 6
d202 2
d207 3
a209 1
	case T_IBREAK:
d215 21
d237 3
d242 1
a243 3
#ifdef DDB
		Debugger();
#endif
d245 10
a254 1
		if (ret == KERN_SUCCESS)
d256 5
a260 3
		panic("trap: vm_fault(%p, %x, %d, %d): %d",
		      map, va, FAULT_TYPE(opcode), 0, ret);
		break;
d262 13
a274 3
		/* pmap_hptdump(); */
#ifdef DDB
		Debugger();
a275 1
	}
d354 1
@


1.2
log
@panic prints a newline for you, don't do it in the panic string
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.1 1999/01/01 16:10:29 mickey Exp $	*/
d37 2
d41 1
d87 1
d90 2
a91 1
void cpu_intr __P((struct trapframe *));
d105 2
a106 2
	va = frame->ior;
	space = (pa_space_t) frame->isr;
d108 1
a108 1
	if (USERMODE(frame->iioq_head)) {
d116 1
a116 1
		       frame->iisq_head, frame->iioq_head);
d133 2
a134 1
		t &= frame->eiem;
a136 1
			/* ACK it now */
d141 1
a141 5
		} else {
#ifdef INTRDEBUG
			printf ("cpu_intr: 0x%08x\n", t);
#endif
			cpu_intr(frame);
d143 2
d160 1
a160 1
		opcode = frame->iir;
d165 1
a165 1
		ret = vm_fault(map, va, FAULT_TYPE(opcode), FALSE);
d179 82
a267 1
#define	ECPU_INTR_VECTORS	&cpu_intr_vectors[CPU_NINTS - 1]
d269 3
a271 3
int
cpu_intr_establish(pri, handler, arg, name)
	int pri;
d278 4
a281 7
	for (p = cpu_intr_vectors; p < ECPU_INTR_VECTORS; p++)
		if (!p->handler)
			break;

	/* no more vectors, fail */
	if (p >= ECPU_INTR_VECTORS)
		return 0;
d283 1
d289 1
a289 1
	return p - cpu_intr_vectors;
d293 2
a294 1
cpu_intr(frame)
d297 1
a297 1
	register u_int32_t t;
d302 3
a304 3
		mfctl(CR_EIRR, t);
		t &= frame->eiem;
		bit = ffs(t) - 1;
d307 2
d310 1
a310 1
			printf ("cpu_intr: 0x%x\n", (1 << bit));
d316 4
d322 1
d324 4
a327 1
			} else
d329 2
d332 1
a332 1
	} while (bit >= 0);
@


1.1
log
@some traps, hehe
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d165 1
a165 1
		panic("trap: vm_fault(%p, %x, %d, %d): %d\n",
@

