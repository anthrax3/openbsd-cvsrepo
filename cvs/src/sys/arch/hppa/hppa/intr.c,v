head	1.49;
access;
symbols
	OPENBSD_6_1_BASE:1.49
	OPENBSD_6_0:1.49.0.4
	OPENBSD_6_0_BASE:1.49
	OPENBSD_5_9:1.49.0.2
	OPENBSD_5_9_BASE:1.49
	OPENBSD_5_8:1.47.0.4
	OPENBSD_5_8_BASE:1.47
	OPENBSD_5_7:1.46.0.2
	OPENBSD_5_7_BASE:1.46
	OPENBSD_5_6:1.44.0.4
	OPENBSD_5_6_BASE:1.44
	OPENBSD_5_5:1.42.0.4
	OPENBSD_5_5_BASE:1.42
	OPENBSD_5_4:1.41.0.2
	OPENBSD_5_4_BASE:1.41
	OPENBSD_5_3:1.40.0.8
	OPENBSD_5_3_BASE:1.40
	OPENBSD_5_2:1.40.0.6
	OPENBSD_5_2_BASE:1.40
	OPENBSD_5_1_BASE:1.40
	OPENBSD_5_1:1.40.0.4
	OPENBSD_5_0:1.40.0.2
	OPENBSD_5_0_BASE:1.40
	OPENBSD_4_9:1.37.0.2
	OPENBSD_4_9_BASE:1.37
	OPENBSD_4_8:1.34.0.2
	OPENBSD_4_8_BASE:1.34
	OPENBSD_4_7:1.27.0.2
	OPENBSD_4_7_BASE:1.27
	OPENBSD_4_6:1.25.0.8
	OPENBSD_4_6_BASE:1.25
	OPENBSD_4_5:1.25.0.4
	OPENBSD_4_5_BASE:1.25
	OPENBSD_4_4:1.25.0.2
	OPENBSD_4_4_BASE:1.25
	OPENBSD_4_3:1.23.0.4
	OPENBSD_4_3_BASE:1.23
	OPENBSD_4_2:1.23.0.2
	OPENBSD_4_2_BASE:1.23
	OPENBSD_4_1:1.22.0.12
	OPENBSD_4_1_BASE:1.22
	OPENBSD_4_0:1.22.0.10
	OPENBSD_4_0_BASE:1.22
	OPENBSD_3_9:1.22.0.8
	OPENBSD_3_9_BASE:1.22
	OPENBSD_3_8:1.22.0.6
	OPENBSD_3_8_BASE:1.22
	OPENBSD_3_7:1.22.0.4
	OPENBSD_3_7_BASE:1.22
	OPENBSD_3_6:1.22.0.2
	OPENBSD_3_6_BASE:1.22
	SMP_SYNC_A:1.18
	SMP_SYNC_B:1.18
	OPENBSD_3_5:1.16.0.2
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	UBC_SYNC_A:1.7
	OPENBSD_3_3:1.7.0.2
	OPENBSD_3_3_BASE:1.7
	UBC_SYNC_B:1.3
	OPENBSD_3_2:1.3.0.2
	OPENBSD_3_2_BASE:1.3
	UBC:1.2.0.6
	OPENBSD_3_1:1.2.0.4
	OPENBSD_3_1_BASE:1.2
	SMP:1.2.0.2;
locks; strict;
comment	@ * @;


1.49
date	2015.09.13.14.58.20;	author kettenis;	state Exp;
branches;
next	1.48;
commitid	i9UZOLCV7gZqx23M;

1.48
date	2015.09.08.07.14.04;	author deraadt;	state Exp;
branches;
next	1.47;
commitid	EsikxqfygOQoIEgZ;

1.47
date	2015.04.28.18.39.13;	author kettenis;	state Exp;
branches;
next	1.46;
commitid	KenuMg6RXoY1amBy;

1.46
date	2015.02.11.01.55.40;	author dlg;	state Exp;
branches;
next	1.45;
commitid	1h4it0dOUW25xHFq;

1.45
date	2015.02.11.01.36.13;	author miod;	state Exp;
branches;
next	1.44;
commitid	bmo8QGe1JvgxhKiO;

1.44
date	2014.07.12.18.44.41;	author tedu;	state Exp;
branches;
next	1.43;
commitid	uKVPYMN2MLxdZxzH;

1.43
date	2014.07.08.17.19.24;	author deraadt;	state Exp;
branches;
next	1.42;
commitid	EF98ch02VpFassUi;

1.42
date	2013.11.26.20.33.12;	author deraadt;	state Exp;
branches;
next	1.41;

1.41
date	2013.07.12.04.08.26;	author jsg;	state Exp;
branches;
next	1.40;

1.40
date	2011.05.12.12.54.38;	author kettenis;	state Exp;
branches;
next	1.39;

1.39
date	2011.05.01.21.59.38;	author kettenis;	state Exp;
branches;
next	1.38;

1.38
date	2011.03.24.10.52.22;	author kettenis;	state Exp;
branches;
next	1.37;

1.37
date	2011.01.01.16.33.37;	author kettenis;	state Exp;
branches;
next	1.36;

1.36
date	2010.12.21.14.56.23;	author claudio;	state Exp;
branches;
next	1.35;

1.35
date	2010.09.20.06.33.47;	author matthew;	state Exp;
branches;
next	1.34;

1.34
date	2010.07.01.21.14.01;	author jsing;	state Exp;
branches;
next	1.33;

1.33
date	2010.05.24.15.04.54;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2010.05.21.15.24.29;	author jsing;	state Exp;
branches;
next	1.31;

1.31
date	2010.04.29.13.14.44;	author jsing;	state Exp;
branches;
next	1.30;

1.30
date	2010.04.28.16.46.48;	author jsing;	state Exp;
branches;
next	1.29;

1.29
date	2010.04.19.16.32.53;	author jsing;	state Exp;
branches;
next	1.28;

1.28
date	2010.04.19.14.05.04;	author jsing;	state Exp;
branches;
next	1.27;

1.27
date	2009.12.31.12.52.35;	author jsing;	state Exp;
branches;
next	1.26;

1.26
date	2009.07.30.14.50.20;	author kettenis;	state Exp;
branches;
next	1.25;

1.25
date	2008.05.19.18.42.12;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2008.04.27.14.36.38;	author kettenis;	state Exp;
branches;
next	1.23;

1.23
date	2007.05.27.16.36.07;	author kettenis;	state Exp;
branches;
next	1.22;

1.22
date	2004.07.13.19.34.22;	author mickey;	state Exp;
branches;
next	1.21;

1.21
date	2004.07.13.19.12.30;	author mickey;	state Exp;
branches;
next	1.20;

1.20
date	2004.06.30.21.01.08;	author mickey;	state Exp;
branches;
next	1.19;

1.19
date	2004.06.30.15.24.12;	author mickey;	state Exp;
branches;
next	1.18;

1.18
date	2004.05.04.23.53.07;	author mickey;	state Exp;
branches;
next	1.17;

1.17
date	2004.04.07.18.24.19;	author mickey;	state Exp;
branches;
next	1.16;

1.16
date	2003.12.30.22.53.54;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	2003.12.30.21.21.40;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	2003.12.20.21.49.06;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2003.11.16.20.30.06;	author avsm;	state Exp;
branches;
next	1.12;

1.12
date	2003.10.15.16.59.23;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	2003.08.07.19.47.33;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	2003.08.05.02.04.58;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.23.18.24.32;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	2003.06.19.03.05.21;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	2003.02.18.19.01.50;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2003.01.04.10.35.32;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	2002.12.17.22.05.47;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	2002.12.17.21.54.25;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.23.06.11.47;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	2002.03.19.14.57.16;	author mickey;	state Exp;
branches
	1.2.2.1
	1.2.6.1;
next	1.1;

1.1
date	2002.03.16.01.13.42;	author mickey;	state Exp;
branches;
next	;

1.2.2.1
date	2003.03.27.23.26.53;	author niklas;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2004.02.19.10.48.40;	author niklas;	state Exp;
branches;
next	1.2.2.3;

1.2.2.3
date	2004.06.05.23.10.48;	author niklas;	state Exp;
branches;
next	;

1.2.6.1
date	2002.06.11.03.35.37;	author art;	state Exp;
branches;
next	1.2.6.2;

1.2.6.2
date	2002.10.29.00.28.02;	author art;	state Exp;
branches;
next	1.2.6.3;

1.2.6.3
date	2003.05.19.21.49.41;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.49
log
@intr_barrier(9) for hppa.
@
text
@/*	$OpenBSD: intr.c,v 1.48 2015/09/08 07:14:04 deraadt Exp $	*/

/*
 * Copyright (c) 2002-2004 Michael Shalayeff
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR OR HIS RELATIVES BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/evcount.h>
#include <sys/malloc.h>
#include <sys/atomic.h>

#include <uvm/uvm_extern.h>

#include <machine/autoconf.h>
#include <machine/frame.h>
#include <machine/reg.h>

struct hppa_iv {
	char pri;
	char irq;
	char flags;
#define	HPPA_IV_CALL	0x01
#define	HPPA_IV_SOFT	0x02
	char pad;
	int pad2;
	int (*handler)(void *);
	void *arg;
	u_int bit;
	struct hppa_iv *share;
	struct hppa_iv *next;
	struct evcount *cnt;
} __packed;

struct hppa_iv intr_store[8*2*CPU_NINTS] __attribute__ ((aligned(32))),
    *intr_more = intr_store, *intr_list;
struct hppa_iv intr_table[CPU_NINTS] __attribute__ ((aligned(32))) = {
	{ IPL_SOFTCLOCK, 0, HPPA_IV_SOFT, 0, 0, NULL },
	{ IPL_SOFTNET  , 0, HPPA_IV_SOFT, 0, 0, NULL },
	{ 0 },
	{ 0 },
	{ IPL_SOFTTTY  , 0, HPPA_IV_SOFT, 0, 0, NULL }
};
volatile u_long imask[NIPL] = {
	0,
	1 << (IPL_SOFTCLOCK - 1),
	1 << (IPL_SOFTNET - 1),
	0,
	0,
	1 << (IPL_SOFTTTY - 1)
};

#ifdef DIAGNOSTIC
void
splassert_check(int wantipl, const char *func)
{
	struct cpu_info *ci = curcpu();

	if (ci->ci_cpl < wantipl)
		splassert_fail(wantipl, ci->ci_cpl, func);
}
#endif

void
cpu_intr_init(void)
{
	struct cpu_info *ci = curcpu();
	struct hppa_iv *iv;
	int level, bit;
	u_long mask;

	mask = ci->ci_mask | SOFTINT_MASK;

	/* map the shared ints */
	while (intr_list) {
		iv = intr_list;
		intr_list = iv->next;
		bit = ffs(imask[(int)iv->pri]);
		if (!bit--) {
			bit = ffs(~mask);
			if (!bit--)
				panic("cpu_intr_init: out of bits");

			iv->next = NULL;
			iv->bit = 1 << bit;
			intr_table[bit] = *iv;
			mask |= (1 << bit);
			imask[(int)iv->pri] |= (1 << bit);
		} else {
			iv->bit = 1 << bit;
			iv->next = intr_table[bit].next;
			intr_table[bit].next = iv;
		}
	}

	for (level = 0; level < NIPL - 1; level++)
		imask[level + 1] |= imask[level];

	/* XXX the whacky trick is to prevent hardclock from happenning */
	mfctl(CR_ITMR, mask);
	mtctl(mask - 1, CR_ITMR);

	mtctl(ci->ci_mask, CR_EIEM);
	/* ack the unwanted interrupts */
	mfctl(CR_EIRR, mask);
	mtctl(mask & (1U << 31), CR_EIRR);

	/* in spl*() we trust, clock is started in initclocks() */
	ci->ci_psw |= PSL_I;
	ssm(PSL_I, mask);
}

int
cpu_intr_findirq(void)
{
	int irq;

	for (irq = 0; irq < CPU_NINTS; irq++)
		if (intr_table[irq].handler == NULL &&
		    intr_table[irq].pri == 0)
			return irq;

	return -1;
}

void *
cpu_intr_map(void *v, int pri, int irq, int (*handler)(void *), void *arg,
    const char *name)
{
	struct hppa_iv *iv, *pv = v, *ivb = pv->next;
	struct evcount *cnt;

	if (irq < 0 || irq >= CPU_NINTS)
		return (NULL);

	cnt = (struct evcount *)malloc(sizeof *cnt, M_DEVBUF, M_NOWAIT);
	if (!cnt)
		return (NULL);

	iv = &ivb[irq];
	if (iv->handler) {
		if (!pv->share) {
			free(cnt, M_DEVBUF, sizeof *cnt);
			return (NULL);
		} else {
			iv = pv->share;
			pv->share = iv->share;
			iv->share = ivb[irq].share;
			ivb[irq].share = iv;
		}
	}

	evcount_attach(cnt, name, NULL);
	iv->pri = pri;
	iv->irq = irq;
	iv->flags = 0;
	iv->handler = handler;
	iv->arg = arg;
	iv->cnt = cnt;
	iv->next = intr_list;
	intr_list = iv;

	return (iv);
}

void *
cpu_intr_establish(int pri, int irq, int (*handler)(void *), void *arg,
    const char *name)
{
	struct cpu_info *ci = curcpu();
	struct hppa_iv *iv, *ev;
	struct evcount *cnt;

	if (irq < 0 || irq >= CPU_NINTS || intr_table[irq].handler)
		return (NULL);

	if ((intr_table[irq].flags & HPPA_IV_SOFT) != 0)
		return (NULL);

	cnt = (struct evcount *)malloc(sizeof *cnt, M_DEVBUF, M_NOWAIT);
	if (!cnt)
		return (NULL);

	ci->ci_mask |= (1 << irq);
	imask[pri] |= (1 << irq);

	iv = &intr_table[irq];
	iv->pri = pri;
	iv->irq = irq;
	iv->bit = 1 << irq;
	iv->flags = 0;
	iv->handler = handler;
	iv->arg = arg;
	iv->cnt = cnt;
	iv->next = NULL;
	iv->share = NULL;

	if (pri == IPL_NESTED) {
		iv->flags = HPPA_IV_CALL;
		iv->next = intr_more;
		intr_more += 2 * CPU_NINTS;
		for (ev = iv->next + CPU_NINTS; ev < intr_more; ev++)
			ev->share = iv->share, iv->share = ev;
		free(cnt, M_DEVBUF, sizeof *cnt);
		iv->cnt = NULL;
	} else if (name == NULL) {
		free(cnt, M_DEVBUF, sizeof *cnt);
		iv->cnt = NULL;
	} else
		evcount_attach(cnt, name, NULL);

	return (iv);
}

void
cpu_intr(void *v)
{
	struct cpu_info *ci = curcpu();
	struct trapframe *frame = v;
	struct hppa_iv *iv;
	int pri, r, s, bit;
	u_long mask;
	void *arg;

	mtctl(0, CR_EIEM);

	s = ci->ci_cpl;
	if (ci->ci_in_intr++)
		frame->tf_flags |= TFF_INTR;

	/* Process higher priority interrupts first. */
	for (pri = NIPL - 1; pri > s; pri--) {

		mask = imask[pri] ^ imask[pri - 1];

		while (ci->ci_ipending & mask) {
			bit = fls(ci->ci_ipending & mask) - 1;
			iv = &intr_table[bit];

			ci->ci_ipending &= ~(1L << bit);

			if (iv->flags & HPPA_IV_CALL)
				continue;

			uvmexp.intrs++;
			if (iv->flags & HPPA_IV_SOFT)
				uvmexp.softs++;

			ci->ci_cpl = iv->pri;
			mtctl(frame->tf_eiem, CR_EIEM);

#ifdef MULTIPROCESSOR
			if (pri < IPL_CLOCK)
				__mp_lock(&kernel_lock);
#endif

			for (r = iv->flags & HPPA_IV_SOFT;
			     iv && iv->handler; iv = iv->next) {
				/* no arg means pass the frame */
				arg = iv->arg ? iv->arg : v;
				if ((iv->handler)(arg) == 1) {
					if (iv->cnt)
						iv->cnt->ec_count++;
					r |= 1;
				}
			}
#if 0	/* XXX this does not work, lasi gives us double ints */
			if (!r) {
				ci->ci_cpl = 0;
				printf("stray interrupt %d\n", bit);
			}
#endif

#ifdef MULTIPROCESSOR
			if (pri < IPL_CLOCK)
				__mp_unlock(&kernel_lock);
#endif
			mtctl(0, CR_EIEM);
		}
	}
	ci->ci_in_intr--;
	ci->ci_cpl = s;

	mtctl(frame->tf_eiem, CR_EIEM);
}

void
intr_barrier(void *cookie)
{
	sched_barrier(NULL);
}

void *
softintr_establish(int pri, void (*handler)(void *), void *arg)
{
	struct hppa_iv *iv;
	int irq;

	if (pri == IPL_TTY)
		pri = IPL_SOFTTTY;

	irq = pri - 1;
	iv = &intr_table[irq];
	if ((iv->flags & HPPA_IV_SOFT) == 0 || iv->pri != pri)
		return (NULL);

	if (iv->handler) {
		struct hppa_iv *nv;

		nv = malloc(sizeof *iv, M_DEVBUF, M_NOWAIT);
		if (!nv)
			return (NULL);
		while (iv->next)
			iv = iv->next;
		iv->next = nv;
		iv = nv;
	} else
		imask[pri] |= (1 << irq);

	iv->pri = pri;
	iv->irq = 0;
	iv->bit = 1 << irq;
	iv->flags = HPPA_IV_SOFT;
	iv->handler = (int (*)(void *))handler;	/* XXX */
	iv->arg = arg;
	iv->cnt = NULL;
	iv->next = NULL;
	iv->share = NULL;

	return (iv);
}

void
softintr_disestablish(void *cookie)
{
	struct hppa_iv *iv = cookie;
	int irq = iv->pri - 1;

	if (&intr_table[irq] == cookie) {
		if (iv->next) {
			struct hppa_iv *nv = iv->next;

			iv->handler = nv->handler;
			iv->arg = nv->arg;
			iv->next = nv->next;
			free(nv, M_DEVBUF, sizeof *nv);
			return;
		} else {
			iv->handler = NULL;
			iv->arg = NULL;
			return;
		}
	}

	for (iv = &intr_table[irq]; iv; iv = iv->next) {
		if (iv->next == cookie) {
			iv->next = iv->next->next;
			free(cookie, M_DEVBUF, 0);
			return;
		}
	}
}

void
softintr_schedule(void *cookie)
{
	struct hppa_iv *iv = cookie;

	atomic_setbits_long(&curcpu()->ci_ipending, 1 << (iv->pri - 1));
}
@


1.48
log
@sizes for free(), when known; ok semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.47 2015/04/28 18:39:13 kettenis Exp $	*/
d309 6
@


1.47
log
@Don't grab the kernel lock for clock interrupts.  The way we use mutexes
these days is incompatible with that practice and leads to deadlocks.

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.46 2015/02/11 01:55:40 dlg Exp $	*/
d167 1
a167 1
			free(cnt, M_DEVBUF, 0);
d228 1
a228 1
		free(cnt, M_DEVBUF, 0);
d231 1
a231 1
		free(cnt, M_DEVBUF, 0);
d364 1
a364 1
			free(nv, M_DEVBUF, 0);
@


1.46
log
@intr.c needs atomic.h for atomic_setbits_int to say softints are pending.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.45 2015/02/11 01:36:13 miod Exp $	*/
d277 1
a277 1
			if (pri < IPL_IPI && s < IPL_SCHED)
d299 1
a299 1
			if (pri < IPL_IPI && s < IPL_SCHED)
@


1.45
log
@Needs <sys/atomic.h> now.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.44 2014/07/12 18:44:41 tedu Exp $	*/
d387 1
a387 1
	softintr(1 << (iv->pri - 1));
@


1.44
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.43 2014/07/08 17:19:24 deraadt Exp $	*/
d35 1
@


1.43
log
@decouple struct uvmexp into a new file, so that uvm_extern.h and sysctl.h
don't need to be married.
ok guenther miod beck jsing kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.42 2013/11/26 20:33:12 deraadt Exp $	*/
d166 1
a166 1
			free(cnt, M_DEVBUF);
d227 1
a227 1
		free(cnt, M_DEVBUF);
d230 1
a230 1
		free(cnt, M_DEVBUF);
d363 1
a363 1
			free(nv, M_DEVBUF);
d375 1
a375 1
			free(cookie, M_DEVBUF);
@


1.42
log
@1 << 31 cleanup.  Eitan Adler pointed out that there has been a
resurrection of the bad idiom in the tree.
sufficient review by miod, kettenis, tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.41 2013/07/12 04:08:26 jsg Exp $	*/
d36 1
a36 1
#include <uvm/uvm_extern.h>	/* for uvmexp */
@


1.41
log
@replace fls functions with calls to the libkern versions
found the hard way by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.40 2011/05/12 12:54:38 kettenis Exp $	*/
d129 1
a129 1
	mtctl(mask & (1 << 31), CR_EIRR);
@


1.40
log
@Get rid of the biomask printf here as well.  Suggested by mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.39 2011/05/01 21:59:38 kettenis Exp $	*/
a235 36
}

int	fls(u_int mask);

int
fls(u_int mask)
{
	int bit;

	bit = 32;
	if (!(mask & 0xffff0000)) {
		bit -= 16;
		mask <<= 16;
	}

	if (!(mask & 0xff000000)) {
		bit -= 8;
		mask <<= 8;
	}

	if (!(mask & 0xf0000000)) {
		bit -= 4;
		mask <<= 4;
	}

	if (!(mask & 0xc0000000)) {
		bit -= 2;
		mask <<= 2;
	}

	if (!(mask & 0x80000000)) {
		bit -= 1;
		mask <<= 1;
	}

	return mask? bit : 0;
@


1.39
log
@Fix counting of interrupts for devices that attach to elroy(4).  Shared
interrupts would be counted double, once for the interrupting device and
once for the device at the head of the chain.  The handlers would run properly
though.  Avoid this by giving each device its own interrupt counter instead
of using the counter provided by the generic interrupt handling code for the
head of the chain.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.38 2011/03/24 10:52:22 kettenis Exp $	*/
a120 3

	printf("biomask 0x%lx netmask 0x%lx ttymask 0x%lx\n",
	    imask[IPL_BIO], imask[IPL_NET], imask[IPL_TTY]);
@


1.38
log
@Process interrupts in priority order.  Joint work with jsing@@.

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.37 2011/01/01 16:33:37 kettenis Exp $	*/
d230 3
@


1.37
log
@Fix horribly broken softintr_establish().  The old code was not managing the
linked list of handlers properly.  Fixes issues with usb(4) reported by
matthieu@@.

tested by matthieu@@, ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.36 2010/12/21 14:56:23 claudio Exp $	*/
d279 2
d282 1
a282 4
#ifdef MULTIPROCESSOR
	int pri;
#endif
	int s;
d290 8
a297 2
	while ((mask = ci->ci_ipending & ~imask[s])) {
		int r, bit = fls(mask) - 1;
d299 1
a299 5
#ifdef MULTIPROCESSOR
		/* XXX - Ensure that IPIs run first. */
		if (mask & (1 << 30))
			bit = 30;
#endif
d301 2
a302 1
		struct hppa_iv *iv = &intr_table[bit];
d304 3
a306 7
		ci->ci_ipending &= ~(1L << bit);
		if (iv->flags & HPPA_IV_CALL)
			continue;

		uvmexp.intrs++;
		if (iv->flags & HPPA_IV_SOFT)
			uvmexp.softs++;
d308 2
a309 2
		ci->ci_cpl = iv->pri;
		mtctl(frame->tf_eiem, CR_EIEM);
d312 2
a313 3
		pri = iv->pri;
		if (pri < IPL_IPI && s < IPL_SCHED)
			__mp_lock(&kernel_lock);
d316 9
a324 7
		for (r = iv->flags & HPPA_IV_SOFT;
		    iv && iv->handler; iv = iv->next)
			/* no arg means pass the frame */
			if ((iv->handler)(iv->arg? iv->arg : v) == 1) {
				if (iv->cnt)
					iv->cnt->ec_count++;
				r |= 1;
d327 4
a330 4
		if (!r) {
			ci->ci_cpl = 0;
			printf("stray interrupt %d\n", bit);
		}
d334 2
a335 2
		if (pri < IPL_IPI && s < IPL_SCHED)
			__mp_unlock(&kernel_lock);
d337 2
a338 1
		mtctl(0, CR_EIEM);
@


1.36
log
@Convert netisr to a normal soft interrupt instead of hanving MD code
for it. This makes the netisr a real C function which will help further
development. No noticable performance change on i386 and amd64.
With input from kettenis@@ and miod@@ additional OKs mikeb@@ and henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.35 2010/09/20 06:33:47 matthew Exp $	*/
d361 9
a369 2
		iv->next = malloc(sizeof *iv, M_DEVBUF, M_NOWAIT);
		iv = iv->next;
d373 9
a381 11
	if (iv != NULL) {
		iv->pri = pri;
		iv->irq = 0;
		iv->bit = 1 << irq;
		iv->flags = HPPA_IV_SOFT;
		iv->handler = (int (*)(void *))handler;	/* XXX */
		iv->arg = arg;
		iv->cnt = NULL;
		iv->next = NULL;
		iv->share = NULL;
	}
@


1.35
log
@Get rid of evcount's support for arranging counters in a tree
hierarchy.  Everything attached to a single root node anyway, so at
best we had a bush.

"i think it is good" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.34 2010/07/01 21:14:01 jsing Exp $	*/
a35 2
#include <net/netisr.h>

a41 3
void softnet(void);
void softtty(void);

d62 1
a62 1
	{ IPL_SOFTNET  , 0, HPPA_IV_SOFT, 0, 0, (int (*)(void *))&softnet },
a85 12

void
softnet(void)
{
	int ni;

	/* use atomic "load & clear" */
	__asm __volatile(
	    "ldcws	0(%2), %0": "=&r" (ni), "+m" (netisr): "r" (&netisr));
#define DONETISR(m,c) if (ni & (1 << (m))) c()
#include <net/netisr_dispatch.h>
}
@


1.34
log
@Ensure that IPIs have priority and are run first to avoid deadlock. This
is a rather ugly hack and needs to be revisited at a later date.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.33 2010/05/24 15:04:54 deraadt Exp $	*/
d196 1
a196 1
	evcount_attach(cnt, name, NULL, &evcount_intr);
d250 1
a250 1
		evcount_attach(cnt, name, NULL, &evcount_intr);
@


1.33
log
@Add missing prototypes
ok jsing kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.32 2010/05/21 15:24:29 jsing Exp $	*/
d310 7
@


1.32
log
@Add support for IPIs on hppa.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.29 2010/04/19 16:32:53 jsing Exp $	*/
d254 2
@


1.31
log
@Use per CPU hardware interrupt mask.

ok kettenis@@
@
text
@d295 3
d320 7
d341 5
a352 1

@


1.30
log
@Do not modify hardware interrupt mask when establishing a soft interrupt
handler. Also, do not allow a hardware interrupt handler to be established
for a soft interrupt.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.28 2010/04/19 14:05:04 jsing Exp $	*/
a62 1
u_long cpu_mask;
d107 1
a107 1
	u_long mask = cpu_mask | SOFTINT_MASK;
d110 3
d146 1
a146 1
	mtctl(cpu_mask, CR_EIEM);
d152 1
a152 1
	curcpu()->ci_psw |= PSL_I;
d213 1
d227 1
a227 1
	cpu_mask |= (1 << irq);
@


1.29
log
@Make ipending a per-CPU value.

ok kettenis@@
@
text
@d69 2
a70 1
	{ 0 }, { 0 },
d77 2
a78 1
	0, 0,
d217 3
d354 1
a354 2
	} else {
		cpu_mask |= (1 << irq);
a355 1
	}
@


1.28
log
@Make the Processor Status Word (PSW) a per-CPU value.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.26 2009/07/30 14:50:20 kettenis Exp $	*/
d72 1
a72 1
volatile u_long ipending, imask[NIPL] = {
d295 1
a295 1
	while ((mask = ipending & ~imask[s])) {
d299 1
a299 1
		ipending &= ~(1L << bit);
@


1.27
log
@Make cpl and cpu_inintr per CPU variables. For locore.S, cpl becomes an
offset within cpu_primary_info - this will need to be revisited shortly.

ok kettenis@@
@
text
@a62 1
register_t kpsw = PSL_Q | PSL_P | PSL_C | PSL_D;
d148 1
a148 1
	kpsw |= PSL_I;
@


1.26
log
@Disable interrupts when we enter cpu_intr() and enable them again when leaving
that function.  It seems this function was intended to be called with
interrupts disabled but that is not (no longer?) the case.  As a result
there were some races accessing the list of interrupt handlers and we would
leave the function with interrupts disabled if there were any interrupts
pending.  This could make us end up in the idle loop with interrupts disabled,
which would "hang" the machine.

Found with help from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.25 2008/05/19 18:42:12 miod Exp $	*/
a63 1
volatile int cpu_inintr, cpl = IPL_NESTED;
d85 4
a88 3
	if (cpl < wantipl) {
		splassert_fail(wantipl, cpl, func);
	}
d285 1
d292 2
a293 2
	s = cpl;
	if (cpu_inintr++)
d308 1
a308 1
		cpl = iv->pri;
d320 1
a320 1
			cpl = 0;
d326 2
a327 2
	cpu_inintr--;
	cpl = s;
@


1.25
log
@Change all remaining MD uses of MALLOC and FREE into proper malloc() and
free() calls; prodded by chl@@, ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.24 2008/04/27 14:36:38 kettenis Exp $	*/
d287 1
a287 1
	int s = cpl;
d289 3
d327 2
@


1.24
log
@Move hppa to __HAVE_GENERIC_SOFT_INTERRUPTS
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.23 2007/05/27 16:36:07 kettenis Exp $	*/
d176 1
a176 1
	MALLOC(cnt, struct evcount *, sizeof *cnt, M_DEVBUF, M_NOWAIT);
d183 1
a183 1
			FREE(cnt, M_DEVBUF);
d216 1
a216 1
	MALLOC(cnt, struct evcount *, sizeof *cnt, M_DEVBUF, M_NOWAIT);
d240 1
a240 1
		FREE(cnt, M_DEVBUF);
@


1.23
log
@Dynamically allocate irq's for pci devices on elroy(4).

ok martin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.22 2004/07/13 19:34:22 mickey Exp $	*/
d69 1
a69 1
	{ IPL_SOFTCLOCK, 0, HPPA_IV_SOFT, 0, 0, (int (*)(void *))&softclock },
d72 1
a72 1
	{ IPL_SOFTTTY  , 0, HPPA_IV_SOFT, 0, 0, (int (*)(void *))&softtty }
a104 6
softtty(void)
{

}

void
d159 2
a160 1
		if (intr_table[irq].handler == NULL)
d324 77
@


1.22
log
@more coherent intrs counting
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.21 2004/07/13 19:12:30 mickey Exp $	*/
d157 12
@


1.21
log
@count soft ints
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.20 2004/06/30 21:01:08 mickey Exp $	*/
d293 1
@


1.20
log
@use evconuts for device interrupts counting
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.19 2004/06/30 15:24:12 mickey Exp $	*/
d38 2
d292 3
@


1.19
log
@call handlers for higher priority first to avoid needless recursion
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.18 2004/05/04 23:53:07 mickey Exp $	*/
d33 2
d55 2
d58 1
a58 3
	struct hppa_iv *share;
	u_int bit;
	int *cnt;
a61 1
extern int intrcnt[];
d162 1
d167 4
d173 2
a174 1
		if (!pv->share)
d176 1
a176 1
		else {
d184 1
d190 1
a190 1
	iv->cnt = &intrcnt[pri];
d202 1
d207 4
d221 1
a221 1
	iv->cnt = &intrcnt[pri];
d231 4
a234 1
	}
d296 5
a300 1
			r |= (iv->handler)(iv->arg? iv->arg : v) == 1;
@


1.18
log
@better faster scooter^Winterrupts; miod@@ testing
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.17 2004/04/07 18:24:19 mickey Exp $	*/
d223 34
d268 1
a268 1
		int r, bit = ffs(mask) - 1;
@


1.17
log
@update copyright; miod@@ is fine w/ files where he holds it too
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.16 2003/12/30 22:53:54 mickey Exp $	*/
d45 1
a45 1
	char bit;
d50 1
d55 2
a56 1
	int pad2[3];
d60 1
d63 5
a67 4
struct hppa_iv *intr_list, intr_store[8*2*CPU_NINTS], *intr_more = intr_store;
struct hppa_iv intr_table[CPU_NINTS] = {
	{ IPL_SOFTCLOCK, 0, HPPA_IV_SOFT, 0, (int (*)(void *))&softclock },
	{ IPL_SOFTNET  , 0, HPPA_IV_SOFT, 0, (int (*)(void *))&softnet },
d69 1
a69 1
	{ IPL_SOFTTTY  , 0, HPPA_IV_SOFT, 0, (int (*)(void *))&softtty }
a123 1
			iv->bit = 31 - bit;
d125 1
d130 1
a130 1
			iv->bit = 31 - bit;
d178 1
a178 1
	iv->bit = irq;
d182 1
d203 2
a204 1
	iv->bit = 31 - irq;
d208 1
@


1.16
log
@kill a local var that is set and never used then later
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.15 2003/12/30 21:21:40 mickey Exp $	*/
d4 1
a4 1
 * Copyright (c) 2002 Michael Shalayeff
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Michael Shalayeff.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.15
log
@provide accounting for the intr time properly from fredette@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.14 2003/12/20 21:49:06 miod Exp $	*/
d226 1
a226 1
	int oldintr, s = cpl;
d228 1
a228 1
	if ((oldintr = cpu_inintr++))
@


1.14
log
@Pass -Wformat, fix a few uninitialized variables as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.13 2003/11/16 20:30:06 avsm Exp $	*/
d63 1
a63 1
volatile int cpl = IPL_NESTED;
d226 4
a229 1
	int s = cpl;
d253 1
@


1.13
log
@convert __attribute__((__packed__)) to __packed so that parsers unaware
of gcc extensions have more of a chance.
ok mcbride@@, no objections from millert@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.12 2003/10/15 16:59:23 mickey Exp $	*/
d140 1
a140 1
	printf("biomask 0x%x netmask 0x%x ttymask 0x%x\n",
@


1.12
log
@somehow a line of code got tired of gcc abuse and sneaked itself into an #if 0'ed piece right beore itself thus causing all kinds of hell
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.11 2003/08/07 19:47:33 mickey Exp $	*/
d60 1
a60 1
} __attribute__((__packed__));
@


1.11
log
@make all intr_establish take the same last arg for name
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.10 2003/08/05 02:04:58 mickey Exp $	*/
d247 1
a248 1
#endif
@


1.10
log
@support for shared interrupts as required by isa/eisa/pci. remove a gsckbc kludge; miod@@ testing
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.9 2003/06/23 18:24:32 mickey Exp $	*/
d159 1
a159 1
    struct device *dv)
d191 1
a191 1
    struct device *dv)
@


1.9
log
@strange things happen if we ack latched lasi ints on older machines
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.8 2003/06/19 03:05:21 mickey Exp $	*/
d58 2
a63 1
volatile u_long ipending, imask[NIPL];
d65 1
a65 1
struct hppa_iv *intr_list, intr_store[8*CPU_NINTS], *intr_more = intr_store;
d72 7
d112 2
a113 1
	int level;
d117 1
a117 2
		struct hppa_iv *iv = intr_list;
		int bit = ffs(imask[(int)iv->pri]);
d119 1
a119 1

d125 1
a126 1
			iv->bit = 31 - bit;
a136 5
	/* match the init for intr_table */
	imask[IPL_SOFTCLOCK] = 1 << (IPL_SOFTCLOCK - 1);
	imask[IPL_SOFTNET  ] = 1 << (IPL_SOFTNET - 1);
	imask[IPL_SOFTTTY  ] = 1 << (IPL_SOFTTTY - 1);

d163 1
a163 1
	if (irq < 0 || irq >= CPU_NINTS || ivb[irq].handler)
d167 11
d193 1
a193 1
	struct hppa_iv *iv;
d207 2
d213 4
a216 3
		intr_more += CPU_NINTS;
	} else
		iv->next = NULL;
@


1.8
log
@ack all unmasked cpu interrupts here to cancel effect of device probing activities
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.7 2003/02/18 19:01:50 deraadt Exp $	*/
d146 2
a147 1
	mtctl(cpu_mask, CR_EIRR);
@


1.7
log
@knf; mickey ok
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.6 2003/01/04 10:35:32 mickey Exp $	*/
d143 1
a143 1
	/* ack the unwanted clock interrupt */
d145 2
a146 1
	mtctl((1 << 31), CR_EIRR);
d150 1
a150 1
	__asm __volatile("ssm %0, %%r0" :: "i" (PSL_I));
@


1.6
log
@reset cold at the end of cpu_configure(), add a comment when fooling w/ itmr
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.5 2002/12/17 22:05:47 mickey Exp $	*/
d63 1
a63 1
u_long cpu_mask;   
d101 1
a101 1
cpu_intr_init()
d153 2
a154 1
cpu_intr_map(void *v, int pri, int irq, int (*handler)(void *), void *arg, struct device *dv)
d174 2
a175 1
cpu_intr_establish(int pri, int irq, int (*handler)(void *), void *arg, struct device *dv)
@


1.5
log
@try to deal w/ a premature clock interrupt; does not break the 'it works scenario'
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.4 2002/12/17 21:54:25 mickey Exp $	*/
d143 1
a143 1

a145 2

	cold = 0;
@


1.4
log
@real interrupts/spl framework.
tested on 712/* 715/100, 715/33 which main cpu/bus types.
miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.3 2002/09/23 06:11:47 mickey Exp $	*/
d144 3
d149 1
a149 2
	/* in spl*() we trust, clock is enabled in initclocks() */
	mtctl(cpu_mask, CR_EIEM);
@


1.3
log
@make the leds blink (on those machines where we have 'em).
simple logic is to light up the led in the intrhook and dim in the
heartbeat always, makes a believable impression.
upper four bits represent a cpu usage w/in the last Hz/8
made up from the cp_time[] times.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.2 2002/03/19 14:57:16 mickey Exp $	*/
a33 2
/* #define INTRDEBUG */

d39 2
d42 1
d45 35
a79 2
#ifdef DDB
#include <machine/db_machdep.h>
d82 86
a167 3
#ifdef INTRDEBUG
#include <ddb/db_output.h>
#endif
d169 2
a170 7
/* all the interrupts, minus cpu clock, which is the last */
struct cpu_intr_vector {
	struct evcnt evcnt;
	int pri;
	int (*handler)(void *);
	void *arg;
} cpu_intr_vectors[CPU_NINTS];
d173 1
a173 5
cpu_intr_establish(pri, irq, handler, arg, dv)
	int pri, irq;
	int (*handler)(void *);
	void *arg;
	struct device *dv;
d175 4
a178 1
	register struct cpu_intr_vector *iv;
d180 2
a181 2
	if (0 <= irq && irq < CPU_NINTS && cpu_intr_vectors[irq].handler)
		return NULL;
d183 1
a183 1
	iv = &cpu_intr_vectors[irq];
d185 2
a188 1
	evcnt_attach(dv, dv->dv_xname, &iv->evcnt);
d190 8
a197 1
	return iv;
d201 1
a201 2
cpu_intr(frame)
	struct trapframe *frame;
d203 24
a226 21
	u_int32_t eirr = 0, r;
	register struct cpu_intr_vector *iv;
	register int bit;

	do {
		mfctl(CR_EIRR, r);
		eirr |= r;
#ifdef INTRDEBUG
		if (eirr & 0x7fffffff)
			db_printf ("cpu_intr: 0x%08x & 0x%08x\n",
			    eirr, frame->tf_eiem);
#endif
		eirr &= frame->tf_eiem;
		bit = ffs(eirr) - 1;
		if (bit >= 0) {
			mtctl(1 << bit, CR_EIRR);
			eirr &= ~(1 << bit);
			/* ((struct iomod *)cpu_gethpa(0))->io_eir = 0; */
			if (bit != 31) {
#ifdef INTRDEBUG
				db_printf ("cpu_intr: 0x%08x\n", (1 << bit));
d228 2
a229 25
				frame->tf_flags |= TFF_INTR;
			} else
				frame->tf_flags &= ~TFF_INTR;

			iv = &cpu_intr_vectors[bit];
			if (iv->handler) {
				register int s, r;

				iv->evcnt.ev_count++;
				s = splraise(iv->pri);
				/* no arg means pass the frame */
				r = (iv->handler)(iv->arg? iv->arg:frame);
				splx(s);
#ifdef INTRDEBUG
				if (!r)
					db_printf ("%s: can't handle interrupt\n",
						   iv->evcnt.ev_name);
#endif
			}
#ifdef INTRDEBUG
			else
				db_printf ("cpu_intr: stray interrupt %d\n", bit);
#endif
		}
	} while (eirr);
@


1.2
log
@need reg.h here as well, from sharpeyed hawk David Krause
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.1 2002/03/16 01:13:42 mickey Exp $	*/
d103 1
a104 1
			if (bit != 31)
d107 4
@


1.2.2.1
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d34 2
a40 2
#include <net/netisr.h>

a41 1
#include <machine/frame.h>
d44 7
a50 2
void softnet(void);
void softtty(void);
d52 4
a55 7
struct hppa_iv {
	char pri;
	char bit;
	char flags;
#define	HPPA_IV_CALL	0x01
#define	HPPA_IV_SOFT	0x02
	char pad;
d58 1
a58 94
	struct hppa_iv *next;
} __attribute__((__packed__));

register_t kpsw = PSL_Q | PSL_P | PSL_C | PSL_D;
volatile int cpl = IPL_NESTED;
volatile u_long ipending, imask[NIPL];
u_long cpu_mask;
struct hppa_iv *intr_list, intr_store[8*CPU_NINTS], *intr_more = intr_store;
struct hppa_iv intr_table[CPU_NINTS] = {
	{ IPL_SOFTCLOCK, 0, HPPA_IV_SOFT, 0, (int (*)(void *))&softclock },
	{ IPL_SOFTNET  , 0, HPPA_IV_SOFT, 0, (int (*)(void *))&softnet },
	{ 0 }, { 0 },
	{ IPL_SOFTTTY  , 0, HPPA_IV_SOFT, 0, (int (*)(void *))&softtty }
};

#ifdef DIAGNOSTIC
void
splassert_check(int wantipl, const char *func)
{
	if (cpl < wantipl) {
		splassert_fail(wantipl, cpl, func);
	}
}
#endif

void
softnet(void)
{
	int ni;

	/* use atomic "load & clear" */
	__asm __volatile(
	    "ldcws	0(%2), %0": "=&r" (ni), "+m" (netisr): "r" (&netisr));
#define DONETISR(m,c) if (ni & (1 << (m))) c()
#include <net/netisr_dispatch.h>
}

void
softtty(void)
{

}

void
cpu_intr_init(void)
{
	u_long mask = cpu_mask | SOFTINT_MASK;
	int level;

	/* map the shared ints */
	while (intr_list) {
		struct hppa_iv *iv = intr_list;
		int bit = ffs(imask[(int)iv->pri]);
		intr_list = iv->next;

		if (!bit--) {
			bit = ffs(~mask);
			if (!bit--)
				panic("cpu_intr_init: out of bits");

			iv->next = NULL;
			iv->bit = 31 - bit;
			intr_table[bit] = *iv;
			mask |= (1 << bit);
			imask[(int)iv->pri] |= (1 << bit);
		} else {
			iv->bit = 31 - bit;
			iv->next = intr_table[bit].next;
			intr_table[bit].next = iv;
		}
	}

	/* match the init for intr_table */
	imask[IPL_SOFTCLOCK] = 1 << (IPL_SOFTCLOCK - 1);
	imask[IPL_SOFTNET  ] = 1 << (IPL_SOFTNET - 1);
	imask[IPL_SOFTTTY  ] = 1 << (IPL_SOFTTTY - 1);

	for (level = 0; level < NIPL - 1; level++)
		imask[level + 1] |= imask[level];

	printf("biomask 0x%x netmask 0x%x ttymask 0x%x\n",
	    imask[IPL_BIO], imask[IPL_NET], imask[IPL_TTY]);

	/* XXX the whacky trick is to prevent hardclock from happenning */
	mfctl(CR_ITMR, mask);
	mtctl(mask - 1, CR_ITMR);
	/* ack the unwanted clock interrupt */
	mtctl(cpu_mask, CR_EIEM);
	mtctl((1 << 31), CR_EIRR);

	/* in spl*() we trust, clock is started in initclocks() */
	kpsw |= PSL_I;
	__asm __volatile("ssm %0, %%r0" :: "i" (PSL_I));
}
d61 5
a65 2
cpu_intr_map(void *v, int pri, int irq, int (*handler)(void *), void *arg,
    struct device *dv)
d67 1
a67 1
	struct hppa_iv *iv, *pv = v, *ivb = pv->next;
d69 2
a70 2
	if (irq < 0 || irq >= CPU_NINTS || ivb[irq].handler)
		return (NULL);
d72 1
a72 1
	iv = &ivb[irq];
a73 2
	iv->bit = irq;
	iv->flags = 0;
d76 1
a76 2
	iv->next = intr_list;
	intr_list = iv;
d78 1
a78 30
	return (iv);
}

void *
cpu_intr_establish(int pri, int irq, int (*handler)(void *), void *arg,
    struct device *dv)
{
	struct hppa_iv *iv;

	if (irq < 0 || irq >= CPU_NINTS || intr_table[irq].handler)
		return (NULL);

	cpu_mask |= (1 << irq);
	imask[pri] |= (1 << irq);

	iv = &intr_table[irq];
	iv->pri = pri;
	iv->bit = 31 - irq;
	iv->flags = 0;
	iv->handler = handler;
	iv->arg = arg;

	if (pri == IPL_NESTED) {
		iv->flags = HPPA_IV_CALL;
		iv->next = intr_more;
		intr_more += CPU_NINTS;
	} else
		iv->next = NULL;

	return (iv);
d82 2
a83 1
cpu_intr(void *v)
d85 41
a125 22
	struct trapframe *frame = v;
	u_long mask;
	int s = cpl;

	while ((mask = ipending & ~imask[s])) {
		int r, bit = ffs(mask) - 1;
		struct hppa_iv *iv = &intr_table[bit];

		ipending &= ~(1L << bit);
		if (iv->flags & HPPA_IV_CALL)
			continue;

		cpl = iv->pri;
		mtctl(frame->tf_eiem, CR_EIEM);
		for (r = iv->flags & HPPA_IV_SOFT;
		    iv && iv->handler; iv = iv->next)
			/* no arg means pass the frame */
			r |= (iv->handler)(iv->arg? iv->arg : v) == 1;
#if 0	/* XXX this does not work, lasi gives us double ints */
		if (!r) {
			cpl = 0;
			printf("stray interrupt %d\n", bit);
d127 1
a127 4
		mtctl(0, CR_EIEM);
#endif
	}
	cpl = s;
@


1.2.2.2
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d58 1
a58 3
	struct hppa_iv *share;
	int pad2[3];
} __packed;
d61 2
a62 1
volatile int cpu_inintr, cpl = IPL_NESTED;
d64 1
a64 1
struct hppa_iv *intr_list, intr_store[8*2*CPU_NINTS], *intr_more = intr_store;
a70 7
volatile u_long ipending, imask[NIPL] = {
	0,
	1 << (IPL_SOFTCLOCK - 1),
	1 << (IPL_SOFTNET - 1),
	0, 0,
	1 << (IPL_SOFTTTY - 1)
};
d104 1
a104 2
	struct hppa_iv *iv;
	int level, bit;
d108 2
a109 1
		iv = intr_list;
d111 1
a111 1
		bit = ffs(imask[(int)iv->pri]);
d117 1
a118 1
			iv->next = NULL;
d129 5
d137 1
a137 1
	printf("biomask 0x%lx netmask 0x%lx ttymask 0x%lx\n",
d143 1
a143 1

d145 1
a145 3
	/* ack the unwanted interrupts */
	mfctl(CR_EIRR, mask);
	mtctl(mask & (1 << 31), CR_EIRR);
d149 1
a149 1
	ssm(PSL_I, mask);
d154 1
a154 1
    const char *name)
d158 1
a158 1
	if (irq < 0 || irq >= CPU_NINTS)
a161 11
	if (iv->handler) {
		if (!pv->share)
			return (NULL);
		else {
			iv = pv->share;
			pv->share = iv->share;
			iv->share = ivb[irq].share;
			ivb[irq].share = iv;
		}
	}

d175 1
a175 1
    const char *name)
d177 1
a177 1
	struct hppa_iv *iv, *ev;
a190 2
	iv->next = NULL;
	iv->share = NULL;
d195 3
a197 4
		intr_more += 2 * CPU_NINTS;
		for (ev = iv->next + CPU_NINTS; ev < intr_more; ev++)
			ev->share = iv->share, iv->share = ev;
	}
a208 3
	if (cpu_inintr++)
		frame->tf_flags |= TFF_INTR;

d228 1
a229 1
		mtctl(0, CR_EIEM);
a230 1
	cpu_inintr--;
@


1.2.2.3
log
@Merge with the trunk
@
text
@d4 1
a4 1
 * Copyright (c) 2002-2004 Michael Shalayeff
d15 5
d50 1
a50 1
	char irq;
a54 1
	int pad2;
d59 1
a59 2
	u_int bit;
	int *cnt;
a62 1
extern int intrcnt[];
d65 4
a68 5
struct hppa_iv intr_store[8*2*CPU_NINTS] __attribute__ ((aligned(32))),
    *intr_more = intr_store, *intr_list;
struct hppa_iv intr_table[CPU_NINTS] __attribute__ ((aligned(32))) = {
	{ IPL_SOFTCLOCK, 0, HPPA_IV_SOFT, 0, 0, (int (*)(void *))&softclock },
	{ IPL_SOFTNET  , 0, HPPA_IV_SOFT, 0, 0, (int (*)(void *))&softnet },
d70 1
a70 1
	{ IPL_SOFTTTY  , 0, HPPA_IV_SOFT, 0, 0, (int (*)(void *))&softtty }
d125 1
a126 1
			iv->bit = 1 << bit;
d131 1
a131 1
			iv->bit = 1 << bit;
d179 1
a179 1
	iv->irq = irq;
a182 1
	iv->cnt = &intrcnt[pri];
d203 1
a203 2
	iv->irq = irq;
	iv->bit = 1 << irq;
a206 1
	iv->cnt = &intrcnt[pri];
@


1.2.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.2.6.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.c,v 1.2.6.1 2002/06/11 03:35:37 art Exp $	*/
a102 1
			if (bit != 31) {
d104 1
a106 4
				frame->tf_flags |= TFF_INTR;
			} else
				frame->tf_flags &= ~TFF_INTR;

@


1.2.6.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d34 2
a40 2
#include <net/netisr.h>

a41 1
#include <machine/frame.h>
d44 7
a50 2
void softnet(void);
void softtty(void);
d52 4
a55 7
struct hppa_iv {
	char pri;
	char bit;
	char flags;
#define	HPPA_IV_CALL	0x01
#define	HPPA_IV_SOFT	0x02
	char pad;
d58 1
a58 94
	struct hppa_iv *next;
} __attribute__((__packed__));

register_t kpsw = PSL_Q | PSL_P | PSL_C | PSL_D;
volatile int cpl = IPL_NESTED;
volatile u_long ipending, imask[NIPL];
u_long cpu_mask;
struct hppa_iv *intr_list, intr_store[8*CPU_NINTS], *intr_more = intr_store;
struct hppa_iv intr_table[CPU_NINTS] = {
	{ IPL_SOFTCLOCK, 0, HPPA_IV_SOFT, 0, (int (*)(void *))&softclock },
	{ IPL_SOFTNET  , 0, HPPA_IV_SOFT, 0, (int (*)(void *))&softnet },
	{ 0 }, { 0 },
	{ IPL_SOFTTTY  , 0, HPPA_IV_SOFT, 0, (int (*)(void *))&softtty }
};

#ifdef DIAGNOSTIC
void
splassert_check(int wantipl, const char *func)
{
	if (cpl < wantipl) {
		splassert_fail(wantipl, cpl, func);
	}
}
#endif

void
softnet(void)
{
	int ni;

	/* use atomic "load & clear" */
	__asm __volatile(
	    "ldcws	0(%2), %0": "=&r" (ni), "+m" (netisr): "r" (&netisr));
#define DONETISR(m,c) if (ni & (1 << (m))) c()
#include <net/netisr_dispatch.h>
}

void
softtty(void)
{

}

void
cpu_intr_init(void)
{
	u_long mask = cpu_mask | SOFTINT_MASK;
	int level;

	/* map the shared ints */
	while (intr_list) {
		struct hppa_iv *iv = intr_list;
		int bit = ffs(imask[(int)iv->pri]);
		intr_list = iv->next;

		if (!bit--) {
			bit = ffs(~mask);
			if (!bit--)
				panic("cpu_intr_init: out of bits");

			iv->next = NULL;
			iv->bit = 31 - bit;
			intr_table[bit] = *iv;
			mask |= (1 << bit);
			imask[(int)iv->pri] |= (1 << bit);
		} else {
			iv->bit = 31 - bit;
			iv->next = intr_table[bit].next;
			intr_table[bit].next = iv;
		}
	}

	/* match the init for intr_table */
	imask[IPL_SOFTCLOCK] = 1 << (IPL_SOFTCLOCK - 1);
	imask[IPL_SOFTNET  ] = 1 << (IPL_SOFTNET - 1);
	imask[IPL_SOFTTTY  ] = 1 << (IPL_SOFTTTY - 1);

	for (level = 0; level < NIPL - 1; level++)
		imask[level + 1] |= imask[level];

	printf("biomask 0x%x netmask 0x%x ttymask 0x%x\n",
	    imask[IPL_BIO], imask[IPL_NET], imask[IPL_TTY]);

	/* XXX the whacky trick is to prevent hardclock from happenning */
	mfctl(CR_ITMR, mask);
	mtctl(mask - 1, CR_ITMR);
	/* ack the unwanted clock interrupt */
	mtctl(cpu_mask, CR_EIEM);
	mtctl((1 << 31), CR_EIRR);

	/* in spl*() we trust, clock is started in initclocks() */
	kpsw |= PSL_I;
	__asm __volatile("ssm %0, %%r0" :: "i" (PSL_I));
}
d61 5
a65 2
cpu_intr_map(void *v, int pri, int irq, int (*handler)(void *), void *arg,
    struct device *dv)
d67 1
a67 1
	struct hppa_iv *iv, *pv = v, *ivb = pv->next;
d69 2
a70 2
	if (irq < 0 || irq >= CPU_NINTS || ivb[irq].handler)
		return (NULL);
d72 1
a72 1
	iv = &ivb[irq];
a73 2
	iv->bit = irq;
	iv->flags = 0;
d76 1
a76 2
	iv->next = intr_list;
	intr_list = iv;
d78 1
a78 30
	return (iv);
}

void *
cpu_intr_establish(int pri, int irq, int (*handler)(void *), void *arg,
    struct device *dv)
{
	struct hppa_iv *iv;

	if (irq < 0 || irq >= CPU_NINTS || intr_table[irq].handler)
		return (NULL);

	cpu_mask |= (1 << irq);
	imask[pri] |= (1 << irq);

	iv = &intr_table[irq];
	iv->pri = pri;
	iv->bit = 31 - irq;
	iv->flags = 0;
	iv->handler = handler;
	iv->arg = arg;

	if (pri == IPL_NESTED) {
		iv->flags = HPPA_IV_CALL;
		iv->next = intr_more;
		intr_more += CPU_NINTS;
	} else
		iv->next = NULL;

	return (iv);
d82 2
a83 1
cpu_intr(void *v)
d85 45
a129 22
	struct trapframe *frame = v;
	u_long mask;
	int s = cpl;

	while ((mask = ipending & ~imask[s])) {
		int r, bit = ffs(mask) - 1;
		struct hppa_iv *iv = &intr_table[bit];

		ipending &= ~(1L << bit);
		if (iv->flags & HPPA_IV_CALL)
			continue;

		cpl = iv->pri;
		mtctl(frame->tf_eiem, CR_EIEM);
		for (r = iv->flags & HPPA_IV_SOFT;
		    iv && iv->handler; iv = iv->next)
			/* no arg means pass the frame */
			r |= (iv->handler)(iv->arg? iv->arg : v) == 1;
#if 0	/* XXX this does not work, lasi gives us double ints */
		if (!r) {
			cpl = 0;
			printf("stray interrupt %d\n", bit);
d131 1
a131 4
		mtctl(0, CR_EIEM);
#endif
	}
	cpl = s;
@


1.1
log
@separate out interrupt handling stuff
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d42 1
@

