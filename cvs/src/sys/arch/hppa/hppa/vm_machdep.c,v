head	1.82;
access;
symbols
	OPENBSD_6_1:1.82.0.2
	OPENBSD_6_1_BASE:1.82
	OPENBSD_6_0:1.81.0.6
	OPENBSD_6_0_BASE:1.81
	OPENBSD_5_9:1.81.0.2
	OPENBSD_5_9_BASE:1.81
	OPENBSD_5_8:1.81.0.4
	OPENBSD_5_8_BASE:1.81
	OPENBSD_5_7:1.80.0.2
	OPENBSD_5_7_BASE:1.80
	OPENBSD_5_6:1.78.0.4
	OPENBSD_5_6_BASE:1.78
	OPENBSD_5_5:1.77.0.8
	OPENBSD_5_5_BASE:1.77
	OPENBSD_5_4:1.77.0.4
	OPENBSD_5_4_BASE:1.77
	OPENBSD_5_3:1.77.0.2
	OPENBSD_5_3_BASE:1.77
	OPENBSD_5_2:1.76.0.2
	OPENBSD_5_2_BASE:1.76
	OPENBSD_5_1_BASE:1.75
	OPENBSD_5_1:1.75.0.2
	OPENBSD_5_0:1.74.0.6
	OPENBSD_5_0_BASE:1.74
	OPENBSD_4_9:1.74.0.4
	OPENBSD_4_9_BASE:1.74
	OPENBSD_4_8:1.74.0.2
	OPENBSD_4_8_BASE:1.74
	OPENBSD_4_7:1.68.0.2
	OPENBSD_4_7_BASE:1.68
	OPENBSD_4_6:1.67.0.4
	OPENBSD_4_6_BASE:1.67
	OPENBSD_4_5:1.64.0.2
	OPENBSD_4_5_BASE:1.64
	OPENBSD_4_4:1.63.0.2
	OPENBSD_4_4_BASE:1.63
	OPENBSD_4_3:1.62.0.2
	OPENBSD_4_3_BASE:1.62
	OPENBSD_4_2:1.61.0.2
	OPENBSD_4_2_BASE:1.61
	OPENBSD_4_1:1.58.0.2
	OPENBSD_4_1_BASE:1.58
	OPENBSD_4_0:1.56.0.8
	OPENBSD_4_0_BASE:1.56
	OPENBSD_3_9:1.56.0.6
	OPENBSD_3_9_BASE:1.56
	OPENBSD_3_8:1.56.0.4
	OPENBSD_3_8_BASE:1.56
	OPENBSD_3_7:1.56.0.2
	OPENBSD_3_7_BASE:1.56
	OPENBSD_3_6:1.54.0.2
	OPENBSD_3_6_BASE:1.54
	SMP_SYNC_A:1.54
	SMP_SYNC_B:1.54
	OPENBSD_3_5:1.50.0.6
	OPENBSD_3_5_BASE:1.50
	OPENBSD_3_4:1.50.0.4
	OPENBSD_3_4_BASE:1.50
	UBC_SYNC_A:1.50
	OPENBSD_3_3:1.50.0.2
	OPENBSD_3_3_BASE:1.50
	OPENBSD_3_2:1.42.0.2
	OPENBSD_3_2_BASE:1.42
	OPENBSD_3_1:1.37.0.2
	OPENBSD_3_1_BASE:1.37
	UBC_SYNC_B:1.44
	UBC:1.30.0.2
	UBC_BASE:1.30
	OPENBSD_3_0:1.25.0.2
	OPENBSD_3_0_BASE:1.25
	OPENBSD_2_9:1.19.0.2
	OPENBSD_2_9_BASE:1.19
	OPENBSD_2_8:1.18.0.2
	OPENBSD_2_8_BASE:1.18
	OPENBSD_2_7:1.16.0.4
	OPENBSD_2_7_BASE:1.16
	SMP:1.16.0.2
	SMP_BASE:1.16
	kame_19991208:1.10
	OPENBSD_2_6:1.9.0.2
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.3.0.2
	OPENBSD_2_5_BASE:1.3;
locks; strict;
comment	@ * @;


1.82
date	2017.02.12.04.55.08;	author guenther;	state Exp;
branches;
next	1.81;
commitid	1rXx7AiXIWFC9gYa;

1.81
date	2015.05.05.02.13.46;	author guenther;	state Exp;
branches;
next	1.80;
commitid	dNPv28CJI5BxtRGW;

1.80
date	2014.12.16.18.30.03;	author tedu;	state Exp;
branches;
next	1.79;
commitid	P6Av4XGqOi3rFasL;

1.79
date	2014.11.16.12.30.57;	author deraadt;	state Exp;
branches;
next	1.78;
commitid	yv0ECmCdICvq576h;

1.78
date	2014.04.08.09.34.23;	author mpi;	state Exp;
branches;
next	1.77;

1.77
date	2013.01.16.19.04.43;	author miod;	state Exp;
branches;
next	1.76;

1.76
date	2012.06.21.00.56.59;	author guenther;	state Exp;
branches;
next	1.75;

1.75
date	2011.09.20.21.46.08;	author miod;	state Exp;
branches;
next	1.74;

1.74
date	2010.07.01.05.33.32;	author jsing;	state Exp;
branches;
next	1.73;

1.73
date	2010.06.29.04.54.26;	author jsing;	state Exp;
branches;
next	1.72;

1.72
date	2010.06.29.04.03.22;	author jsing;	state Exp;
branches;
next	1.71;

1.71
date	2010.06.29.00.50.40;	author jsing;	state Exp;
branches;
next	1.70;

1.70
date	2010.05.02.22.59.11;	author kettenis;	state Exp;
branches;
next	1.69;

1.69
date	2010.04.19.14.05.04;	author jsing;	state Exp;
branches;
next	1.68;

1.68
date	2009.07.29.18.31.11;	author kettenis;	state Exp;
branches;
next	1.67;

1.67
date	2009.06.26.18.55.20;	author miod;	state Exp;
branches;
next	1.66;

1.66
date	2009.06.11.20.10.51;	author kettenis;	state Exp;
branches;
next	1.65;

1.65
date	2009.03.26.17.24.33;	author oga;	state Exp;
branches;
next	1.64;

1.64
date	2008.09.30.18.54.26;	author miod;	state Exp;
branches;
next	1.63;

1.63
date	2008.07.14.13.37.39;	author miod;	state Exp;
branches;
next	1.62;

1.62
date	2007.10.10.15.53.51;	author art;	state Exp;
branches;
next	1.61;

1.61
date	2007.06.20.17.29.34;	author miod;	state Exp;
branches;
next	1.60;

1.60
date	2007.06.05.17.15.21;	author miod;	state Exp;
branches;
next	1.59;

1.59
date	2007.05.27.20.59.25;	author miod;	state Exp;
branches;
next	1.58;

1.58
date	2006.11.29.12.47.49;	author mickey;	state Exp;
branches;
next	1.57;

1.57
date	2006.11.29.12.26.13;	author miod;	state Exp;
branches;
next	1.56;

1.56
date	2005.03.15.05.13.32;	author mickey;	state Exp;
branches;
next	1.55;

1.55
date	2004.09.14.23.39.32;	author mickey;	state Exp;
branches;
next	1.54;

1.54
date	2004.06.08.22.00.25;	author mickey;	state Exp;
branches;
next	1.53;

1.53
date	2004.04.21.23.09.30;	author mickey;	state Exp;
branches;
next	1.52;

1.52
date	2004.04.07.18.24.19;	author mickey;	state Exp;
branches;
next	1.51;

1.51
date	2004.04.06.18.33.50;	author mickey;	state Exp;
branches;
next	1.50;

1.50
date	2003.02.18.19.01.50;	author deraadt;	state Exp;
branches;
next	1.49;

1.49
date	2003.01.29.20.57.01;	author mickey;	state Exp;
branches;
next	1.48;

1.48
date	2003.01.22.16.23.24;	author mickey;	state Exp;
branches;
next	1.47;

1.47
date	2003.01.01.10.03.15;	author mickey;	state Exp;
branches;
next	1.46;

1.46
date	2002.12.17.21.54.25;	author mickey;	state Exp;
branches;
next	1.45;

1.45
date	2002.11.08.21.42.12;	author mickey;	state Exp;
branches;
next	1.44;

1.44
date	2002.10.07.15.32.37;	author mickey;	state Exp;
branches;
next	1.43;

1.43
date	2002.10.07.14.38.34;	author mickey;	state Exp;
branches;
next	1.42;

1.42
date	2002.09.11.15.55.58;	author mickey;	state Exp;
branches;
next	1.41;

1.41
date	2002.09.05.21.37.18;	author mickey;	state Exp;
branches;
next	1.40;

1.40
date	2002.08.03.20.56.42;	author mickey;	state Exp;
branches;
next	1.39;

1.39
date	2002.06.09.02.50.29;	author mickey;	state Exp;
branches;
next	1.38;

1.38
date	2002.06.06.16.36.09;	author mickey;	state Exp;
branches;
next	1.37;

1.37
date	2002.04.01.16.05.10;	author mickey;	state Exp;
branches;
next	1.36;

1.36
date	2002.03.28.07.21.12;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2002.03.28.07.02.27;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2002.03.15.21.44.18;	author mickey;	state Exp;
branches;
next	1.33;

1.33
date	2002.02.21.06.12.30;	author mickey;	state Exp;
branches;
next	1.32;

1.32
date	2002.02.11.21.16.32;	author mickey;	state Exp;
branches;
next	1.31;

1.31
date	2002.02.01.21.03.20;	author mickey;	state Exp;
branches;
next	1.30;

1.30
date	2001.12.08.02.24.06;	author art;	state Exp;
branches
	1.30.2.1;
next	1.29;

1.29
date	2001.11.28.13.47.38;	author art;	state Exp;
branches;
next	1.28;

1.28
date	2001.11.07.01.18.00;	author art;	state Exp;
branches;
next	1.27;

1.27
date	2001.11.06.19.53.14;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2001.11.06.18.41.09;	author art;	state Exp;
branches;
next	1.25;

1.25
date	2001.09.19.20.50.56;	author mickey;	state Exp;
branches;
next	1.24;

1.24
date	2001.07.25.13.25.31;	author art;	state Exp;
branches;
next	1.23;

1.23
date	2001.06.10.02.55.43;	author mickey;	state Exp;
branches;
next	1.22;

1.22
date	2001.06.08.08.08.49;	author art;	state Exp;
branches;
next	1.21;

1.21
date	2001.05.06.00.45.49;	author art;	state Exp;
branches;
next	1.20;

1.20
date	2001.05.05.21.26.36;	author art;	state Exp;
branches;
next	1.19;

1.19
date	2001.03.29.00.17.00;	author mickey;	state Exp;
branches;
next	1.18;

1.18
date	2000.06.08.22.25.19;	author niklas;	state Exp;
branches;
next	1.17;

1.17
date	2000.06.05.12.58.29;	author art;	state Exp;
branches;
next	1.16;

1.16
date	2000.01.25.12.55.04;	author mickey;	state Exp;
branches
	1.16.2.1;
next	1.15;

1.15
date	2000.01.24.20.44.14;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	2000.01.17.20.18.16;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	2000.01.17.06.02.49;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	2000.01.11.20.27.57;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	99.12.31.09.07.13;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	99.11.25.18.37.43;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	99.09.20.21.14.22;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	99.09.03.18.00.47;	author art;	state Exp;
branches;
next	1.7;

1.7
date	99.08.17.10.32.16;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	99.06.12.18.13.18;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	99.05.21.17.49.47;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	99.04.20.20.45.37;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	99.02.25.19.08.50;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	99.01.10.13.34.18;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	98.12.29.18.06.48;	author mickey;	state Exp;
branches;
next	;

1.16.2.1
date	2001.04.18.16.06.16;	author niklas;	state Exp;
branches;
next	1.16.2.2;

1.16.2.2
date	2001.07.04.10.16.06;	author niklas;	state Exp;
branches;
next	1.16.2.3;

1.16.2.3
date	2001.10.31.02.52.47;	author nate;	state Exp;
branches;
next	1.16.2.4;

1.16.2.4
date	2001.11.13.21.00.51;	author niklas;	state Exp;
branches;
next	1.16.2.5;

1.16.2.5
date	2001.12.05.00.39.10;	author niklas;	state Exp;
branches;
next	1.16.2.6;

1.16.2.6
date	2002.03.06.00.57.22;	author niklas;	state Exp;
branches;
next	1.16.2.7;

1.16.2.7
date	2002.03.28.10.19.25;	author niklas;	state Exp;
branches;
next	1.16.2.8;

1.16.2.8
date	2003.03.27.23.26.54;	author niklas;	state Exp;
branches;
next	1.16.2.9;

1.16.2.9
date	2004.06.05.23.10.48;	author niklas;	state Exp;
branches;
next	1.16.2.10;

1.16.2.10
date	2004.06.10.11.40.23;	author niklas;	state Exp;
branches;
next	;

1.30.2.1
date	2002.06.11.03.35.37;	author art;	state Exp;
branches;
next	1.30.2.2;

1.30.2.2
date	2002.10.29.00.28.02;	author art;	state Exp;
branches;
next	1.30.2.3;

1.30.2.3
date	2003.05.19.21.49.41;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.82
log
@Split up fork1():
 - FORK_THREAD handling is a totally separate function, thread_fork(),
   that is only used by sys___tfork() and which loses the flags, func,
   arg, and newprocp parameters and gains tcb parameter to guarantee
   the new thread's TCB is set before the creating thread returns
 - fork1() loses its stack and tidptr parameters
Common bits factor out:
 - struct proc allocation and initialization moves to thread_new()
 - maxthread handling moves to fork_check_maxthread()
 - setting the new thread running moves to fork_thread_start()
The MD cpu_fork() function swaps its unused stacksize parameter for
a tcb parameter.

luna88k testing by aoyama@@, alpha testing by dlg@@
ok mpi@@
@
text
@/*	$OpenBSD: vm_machdep.c,v 1.81 2015/05/05 02:13:46 guenther Exp $	*/

/*
 * Copyright (c) 1999-2004 Michael Shalayeff
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR OR HIS RELATIVES BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */


#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/signalvar.h>
#include <sys/malloc.h>
#include <sys/buf.h>
#include <sys/vnode.h>
#include <sys/user.h>
#include <sys/ptrace.h>
#include <sys/exec.h>
#include <sys/pool.h>

#include <uvm/uvm_extern.h>

#include <machine/cpufunc.h>
#include <machine/fpu.h>
#include <machine/pmap.h>
#include <machine/pcb.h>

extern struct pool hppa_fppl;

void
cpu_fork(struct proc *p1, struct proc *p2, void *stack, void *tcb,
    void (*func)(void *), void *arg)
{
	struct pcb *pcbp;
	struct trapframe *tf;
	register_t sp, osp;

#ifdef DIAGNOSTIC
	if (round_page(sizeof(struct user)) > NBPG)
		panic("USPACE too small for user");
#endif
	fpu_proc_save(p1);

	pcbp = &p2->p_addr->u_pcb;
	bcopy(&p1->p_addr->u_pcb, pcbp, sizeof(*pcbp));
	/* space is cached for the copy{in,out}'s pleasure */
	pcbp->pcb_space = p2->p_vmspace->vm_map.pmap->pm_space;
	pcbp->pcb_fpstate = pool_get(&hppa_fppl, PR_WAITOK);
	*pcbp->pcb_fpstate = *p1->p_addr->u_pcb.pcb_fpstate;
	/* reset any of the pending FPU exceptions from parent */
	pcbp->pcb_fpstate->hfp_regs.fpr_regs[0] =
	    HPPA_FPU_FORK(pcbp->pcb_fpstate->hfp_regs.fpr_regs[0]);
	pcbp->pcb_fpstate->hfp_regs.fpr_regs[1] = 0;
	pcbp->pcb_fpstate->hfp_regs.fpr_regs[2] = 0;
	pcbp->pcb_fpstate->hfp_regs.fpr_regs[3] = 0;

	p2->p_md.md_bpva = p1->p_md.md_bpva;
	p2->p_md.md_bpsave[0] = p1->p_md.md_bpsave[0];
	p2->p_md.md_bpsave[1] = p1->p_md.md_bpsave[1];

	sp = (register_t)p2->p_addr + NBPG;
	p2->p_md.md_regs = tf = (struct trapframe *)sp;
	sp += sizeof(struct trapframe);
	bcopy(p1->p_md.md_regs, tf, sizeof(*tf));

	tf->tf_cr30 = (paddr_t)pcbp->pcb_fpstate;

	tf->tf_sr0 = tf->tf_sr1 = tf->tf_sr2 = tf->tf_sr3 =
	tf->tf_sr4 = tf->tf_sr5 = tf->tf_sr6 =
	tf->tf_iisq_head = tf->tf_iisq_tail =
		p2->p_vmspace->vm_map.pmap->pm_space;
	tf->tf_pidr1 = tf->tf_pidr2 = pmap_sid2pid(tf->tf_sr0);

	/*
	 * theoretically these could be inherited from the father,
	 * but just in case.
	 */
	tf->tf_sr7 = HPPA_SID_KERNEL;
	mfctl(CR_EIEM, tf->tf_eiem);
	tf->tf_ipsw = PSL_C | PSL_Q | PSL_P | PSL_D | PSL_I /* | PSL_L */ |
	    (curcpu()->ci_psw & PSL_O);

	/*
	 * If specified, give the child a different stack and/or TCB
	 */
	if (stack != NULL)
		setstack(tf, (u_long)stack, 0);	/* XXX ignore error? */
	if (tcb != NULL)
		tf->tf_cr27 = (u_long)tcb;

	/*
	 * Build stack frames for the cpu_switchto & co.
	 */
	osp = sp + HPPA_FRAME_SIZE;
	*(register_t*)(osp - HPPA_FRAME_SIZE) = 0;
	*(register_t*)(osp + HPPA_FRAME_CRP) = (register_t)&switch_trampoline;
	*(register_t*)(osp) = (osp - HPPA_FRAME_SIZE);

	sp = osp + HPPA_FRAME_SIZE + 20*4; /* frame + callee-saved registers */
	*HPPA_FRAME_CARG(0, sp) = (register_t)arg;
	*HPPA_FRAME_CARG(1, sp) = KERNMODE(func);
	pcbp->pcb_ksp = sp;
}

void
cpu_exit(struct proc *p)
{
	struct pcb *pcb = &p->p_addr->u_pcb;

	fpu_proc_flush(p);

	pool_put(&hppa_fppl, pcb->pcb_fpstate);

	pmap_deactivate(p);
	sched_exit(p);
}

/*
 * Map an IO request into kernel virtual address space.
 */
void
vmapbuf(struct buf *bp, vsize_t len)
{
	struct pmap *pm = vm_map_pmap(&bp->b_proc->p_vmspace->vm_map);
	vaddr_t kva, uva;
	vsize_t size, off;

#ifdef DIAGNOSTIC
	if ((bp->b_flags & B_PHYS) == 0)
		panic("vmapbuf");
#endif
	bp->b_saveaddr = bp->b_data;
	uva = trunc_page((vaddr_t)bp->b_data);
	off = (vaddr_t)bp->b_data - uva;
	size = round_page(off + len);

	kva = uvm_km_valloc_prefer_wait(phys_map, size, uva);
	bp->b_data = (caddr_t)(kva + off);
	while (size > 0) {
		paddr_t pa;

		if (pmap_extract(pm, uva, &pa) == FALSE)
			panic("vmapbuf: null page frame");
		else
			pmap_kenter_pa(kva, pa, PROT_READ | PROT_WRITE);
		uva += PAGE_SIZE;
		kva += PAGE_SIZE;
		size -= PAGE_SIZE;
	}
	pmap_update(pmap_kernel());
}

/*
 * Unmap IO request from the kernel virtual address space.
 */
void
vunmapbuf(struct buf *bp, vsize_t len)
{
	vaddr_t addr, off;

#ifdef DIAGNOSTIC
	if ((bp->b_flags & B_PHYS) == 0)
		panic("vunmapbuf");
#endif
	addr = trunc_page((vaddr_t)bp->b_data);
	off = (vaddr_t)bp->b_data - addr;
	len = round_page(off + len);
	pmap_kremove(addr, len);
	pmap_update(pmap_kernel());
	uvm_km_free_wakeup(phys_map, addr, len);
	bp->b_data = bp->b_saveaddr;
	bp->b_saveaddr = NULL;
}
@


1.81
log
@emul_native is only used for kernel threads which can't dump core, so
delete coredump_trad(), uvm_coredump(), cpu_coredump(), struct md_coredump,
and various #includes that are superfluous.

This leaves compat_linux processes without a coredump callback.  If that
ability is desired, someone should update it to use coredump_elf32() and
verify the results...

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.80 2014/12/16 18:30:03 tedu Exp $	*/
d52 1
a52 1
cpu_fork(struct proc *p1, struct proc *p2, void *stack, size_t stacksize,
d105 1
a105 1
	 * If specified, give the child a different stack.
d109 2
@


1.80
log
@primary change: move uvm_vnode out of vnode, keeping only a pointer.
objective: vnode.h doesn't include uvm_extern.h anymore.
followup changes: include uvm_extern.h or lock.h where necessary.
ok and help from deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.79 2014/11/16 12:30:57 deraadt Exp $	*/
a39 1
#include <sys/core.h>
a49 41

/*
 * Dump the machine specific header information at the start of a core dump.
 */
int
cpu_coredump(struct proc *p, struct vnode *vp, struct ucred *cred,
    struct core *core)
{
	struct md_coredump md_core;
	struct coreseg cseg;
	off_t off;
	int error;

	CORE_SETMAGIC(*core, COREMAGIC, MID_HPPA, 0);
	core->c_hdrsize = ALIGN(sizeof(*core));
	core->c_seghdrsize = ALIGN(sizeof(cseg));
	core->c_cpusize = sizeof(md_core);

	process_read_regs(p, &md_core.md_reg);
	process_read_fpregs(p, &md_core.md_fpreg);

	CORE_SETMAGIC(cseg, CORESEGMAGIC, MID_HPPA, CORE_CPU);
	cseg.c_addr = 0;
	cseg.c_size = core->c_cpusize;

#define	write(vp, addr, n) \
	vn_rdwr(UIO_WRITE, (vp), (caddr_t)(addr), (n), off, \
	    UIO_SYSSPACE, IO_UNIT, cred, NULL, p)

	off = core->c_hdrsize;
	if ((error = write(vp, &cseg, core->c_seghdrsize)))
		return error;
	off += core->c_seghdrsize;
	if ((error = write(vp, &md_core, sizeof md_core)))
		return error;

#undef write
	core->c_nseg++;

	return error;
}
@


1.79
log
@Replace a plethora of historical protection options with just
PROT_NONE, PROT_READ, PROT_WRITE, and PROT_EXEC from mman.h.
PROT_MASK is introduced as the one true way of extracting those bits.
Remove UVM_ADV_* wrapper, using the standard names.
ok doug guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.78 2014/04/08 09:34:23 mpi Exp $	*/
d43 2
a48 2

#include <uvm/uvm_extern.h>
@


1.78
log
@Less <uvm/uvm.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.77 2013/01/16 19:04:43 miod Exp $	*/
d206 1
a206 1
			pmap_kenter_pa(kva, pa, UVM_PROT_RW);
@


1.77
log
@cpu_coredump() also needs to invoke vn_rdwr() without IO_NODELOCKED; only
affects a.out binaries' core dumps.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.76 2012/06/21 00:56:59 guenther Exp $	*/
d48 1
a48 1
#include <uvm/uvm.h>
@


1.76
log
@__tfork() needs to set the stack address of the new thread in the kernel,
so that it can't get a signal while still running on the parent thread's
stack.  Also, pass in sizeof(struct __tfork) to provide forward compat
when more members are added.  This is an ABI change, so switch syscall
numbers and bump lib majors this time.

ok deraadt@@ matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.75 2011/09/20 21:46:08 miod Exp $	*/
d78 1
a78 1
	    UIO_SYSSPACE, IO_NODELOCKED|IO_UNIT, cred, NULL, p)
@


1.75
log
@calee -> callee
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.74 2010/07/01 05:33:32 jsing Exp $	*/
d150 1
a150 1
		tf->tf_sp = (register_t)stack;
@


1.74
log
@Create a struct to store FP state and include a pointer to the CPU that
currently holds the FPU context for this process. This will be soon used
to implement FPU shootdowns on multiprocessor kernels.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.73 2010/06/29 04:54:26 jsing Exp $	*/
d160 1
a160 1
	sp = osp + HPPA_FRAME_SIZE + 20*4; /* frame + calee-save registers */
@


1.73
log
@Ansify function declarations.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.72 2010/06/29 04:03:22 jsing Exp $	*/
d111 2
a112 2
	pcbp->pcb_fpregs = pool_get(&hppa_fppl, PR_WAITOK);
	*pcbp->pcb_fpregs = *p1->p_addr->u_pcb.pcb_fpregs;
d114 5
a118 5
	pcbp->pcb_fpregs->fpr_regs[0] =
	    HPPA_FPU_FORK(pcbp->pcb_fpregs->fpr_regs[0]);
	pcbp->pcb_fpregs->fpr_regs[1] = 0;
	pcbp->pcb_fpregs->fpr_regs[2] = 0;
	pcbp->pcb_fpregs->fpr_regs[3] = 0;
d129 1
a129 1
	tf->tf_cr30 = (paddr_t)pcbp->pcb_fpregs;
d173 1
a173 1
	pool_put(&hppa_fppl, pcb->pcb_fpregs);
@


1.72
log
@Factor out code used to save and flushe process FPU context.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.71 2010/06/29 00:50:40 jsing Exp $	*/
d56 2
a57 5
cpu_coredump(p, vp, cred, core)
	struct proc *p;
	struct vnode *vp;
	struct ucred *cred;
	struct core *core;
d94 2
a95 6
cpu_fork(p1, p2, stack, stacksize, func, arg)
	struct proc *p1, *p2;
	void *stack;
	size_t stacksize;
	void (*func)(void *);
	void *arg;
d167 1
a167 2
cpu_exit(p)
	struct proc *p;
d183 1
a183 3
vmapbuf(bp, len)
	struct buf *bp;
	vsize_t len;
d218 1
a218 3
vunmapbuf(bp, len)
	struct buf *bp;
	vsize_t len;
@


1.71
log
@Store pointer to process FPU state in struct cpu_info.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.70 2010/05/02 22:59:11 kettenis Exp $	*/
d44 1
a103 1
	extern u_int fpu_enable;
d112 1
a112 5
	if (p1->p_md.md_regs->tf_cr30 == curcpu()->ci_fpu_state) {
		mtctl(fpu_enable, CR_CCR);
		fpu_save(curcpu()->ci_fpu_state);
		mtctl(0, CR_CCR);
	}
a176 1
	struct trapframe *tf = p->p_md.md_regs;
d179 2
a180 4
	if (tf->tf_cr30 == curcpu()->ci_fpu_state) {
		fpu_exit();
		curcpu()->ci_fpu_state = 0;
	}
@


1.70
log
@Properly initialize the members of `struct mdproc' that deal with
single-stepping when we fork and reset them upon exec.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.69 2010/04/19 14:05:04 jsing Exp $	*/
a102 1
	extern paddr_t fpu_curpcb;	/* from locore.S */
d112 1
a112 1
	if (p1->p_md.md_regs->tf_cr30 == fpu_curpcb) {
d114 1
a114 1
		fpu_save(fpu_curpcb);
a180 1
	extern paddr_t fpu_curpcb;	/* from locore.S */
d184 1
a184 1
	if (fpu_curpcb == tf->tf_cr30) {
d186 1
a186 1
		fpu_curpcb = 0;
@


1.69
log
@Make the Processor Status Word (PSW) a per-CPU value.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.67 2009/06/26 18:55:20 miod Exp $	*/
d131 4
@


1.68
log
@Get rid of non-equivalent aliases of the pcb by moving the fpu state out
of the pcb and using the p_addr member of 'struct proc' to calculate the
address of the kernel stack when switching to virtual mode after taking a trap.
Remove the now unecessary cache flushes; they're actually harmful since they
create non-equivalent aliases.  This seems to fix the memory corruption we
have been observing from time to time.

This diff does not rename fpu_curpcb, which is now somewhat incorrectly named.
I hope to change things back again as soon as we are able to map the pcb 1:1.
@
text
@d152 1
a152 1
	    (kpsw & PSL_O);
@


1.67
log
@Prefer fdcache() to pdcache() in cpu_fork(), as the MI uvm code has touched
p->p_stats earlier, and loss of information there can cause spurious
SIGPROF or SIGVTALRM to be delivered. ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.66 2009/06/11 20:10:51 kettenis Exp $	*/
d41 1
d49 1
a107 1
	paddr_t pa;
a118 15
	/*
	 * Stash the physical for the pcb of U for later perusal
	 */
	if (!pmap_extract(pmap_kernel(), (vaddr_t)p2->p_addr, &pa))
		panic("pmap_extract(%p) failed", p2->p_addr);

	/*
	 * XXX This shouldn't be necessary, since there shouldn't be any
	 * allocated cache lines for this new pcb.  But for some reason
	 * that is not the case...
	 */
	fdcache(HPPA_SID_KERNEL, pa, PAGE_SIZE);
	pdtlb(HPPA_SID_KERNEL, pa);
	pitlb(HPPA_SID_KERNEL, pa);

d123 2
a124 1
	pcbp->pcb_uva = (vaddr_t)p2->p_addr;
d126 5
a130 4
	pcbp->pcb_fpregs[0] = HPPA_FPU_FORK(pcbp->pcb_fpregs[0]);
	pcbp->pcb_fpregs[1] = 0;
	pcbp->pcb_fpregs[2] = 0;
	pcbp->pcb_fpregs[3] = 0;
d137 1
a137 1
	tf->tf_cr30 = pa;
a171 5

	fdcache(HPPA_SID_KERNEL, (vaddr_t)p2->p_addr, PAGE_SIZE);
	pdtlb(HPPA_SID_KERNEL, (vaddr_t)p2->p_addr);
	ficache(HPPA_SID_KERNEL, (vaddr_t)p2->p_addr, PAGE_SIZE);
	pitlb(HPPA_SID_KERNEL, (vaddr_t)p2->p_addr);
d180 1
d186 1
@


1.66
log
@Correctly flush direct mappings (cache/tlb).  Uncovered by ariane's new
allocator.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.65 2009/03/26 17:24:33 oga Exp $	*/
d129 1
a129 1
	pdcache(HPPA_SID_KERNEL, pa, PAGE_SIZE);
@


1.65
log
@Remove cpu_wait(). It's original use was to be called from the reaper so
MD code would free resources that couldn't be freed until we were no
longer running in that processor. However, it's is unused on all
architectures since mikeb@@'s tss changes on x86 earlier in the year.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.64 2008/09/30 18:54:26 miod Exp $	*/
d118 15
a148 6
	/*
	 * Stash the physical for the pcb of U for later perusal
	 */
	if (!pmap_extract(pmap_kernel(), (vaddr_t)p2->p_addr, &pa))
		panic("pmap_extract(%p) failed", p2->p_addr);

d184 5
a188 1
	fdcache(HPPA_SID_KERNEL, (vaddr_t)p2->p_addr, sp - (vaddr_t)p2->p_addr);
@


1.64
log
@Do not perform cache operations in vmapbuf(), pmap is supposed to do them
for us if needed.

ok art@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.63 2008/07/14 13:37:39 miod Exp $	*/
a191 6
}

void
cpu_wait(p)
	struct proc *p;
{
@


1.63
log
@Be sure to propagate PSL_O in psw on PCXU* processors to userland processes
and signal handlers.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.62 2007/10/10 15:53:51 art Exp $	*/
a220 5
	/*
	 * We do it on our own here to be able to specify an offset to uvm_map
	 * so that we can get all benefits of PMAP_PREFER.
	 * - art@@
	 */
a221 1
	fdcache(pm->pm_space, uva, size);
@


1.62
log
@Make context switching much more MI:
 - Move the functionality of choosing a process from cpu_switch into
   a much simpler function: cpu_switchto. Instead of having the locore
   code walk the run queues, let the MI code choose the process we
   want to run and only implement the context switching itself in MD
   code.
 - Let MD context switching run without worrying about spls or locks.
 - Instead of having the idle loop implemented with special contexts
   in MD code, implement one idle proc for each cpu. make the idle
   loop MI with MD hooks.
 - Change the proc lists from the old style vax queues to TAILQs.
 - Change the sleep queue from vax queues to TAILQs. This makes
   wakeup() go from O(n^2) to O(n)

there will be some MD fallout, but it will be fixed shortly.
There's also a few cleanups to be done after this.

deraadt@@, kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.61 2007/06/20 17:29:34 miod Exp $	*/
d154 2
a155 1
	tf->tf_ipsw = PSL_C | PSL_Q | PSL_P | PSL_D | PSL_I /* | PSL_L */;
@


1.61
log
@In vunmapbuf(), explicitely remove mappings before invoking uvm_km_free().
Even if the latter would end up removing the mappings by itself, it would
do so using pmap_remove() because phys_map is not intrsafe; but some
platforms use pmap_kenter_pa() in vmapbuf(). By removing the mappings
ourselves, we can ensure the remove function used matches the enter function
which has been used.
Discussed and theoretical ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.60 2007/06/05 17:15:21 miod Exp $	*/
d163 1
a163 1
	 * Build stack frames for the cpu_switch & co.
a167 1
	*(register_t*)(osp + HPPA_FRAME_SL) = 0;	/* cpl */
d189 2
a190 2
	exit2(p);
	cpu_switch(p);
@


1.60
log
@Use phys_map, not kernel_map in v{,un}mapbuf. ok mickey
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.59 2007/05/27 20:59:25 miod Exp $	*/
d260 2
@


1.59
log
@pagemove() is no longer used.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.58 2006/11/29 12:47:49 mickey Exp $	*/
d226 1
a226 1
	kva = uvm_km_valloc_prefer_wait(kernel_map, size, uva);
d260 1
a260 1
	uvm_km_free_wakeup(kernel_map, addr, len);
@


1.58
log
@cpu_swapin is nomore
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.57 2006/11/29 12:26:13 miod Exp $	*/
a90 23
}

/*
 * Move pages from one kernel virtual address to another.
 * Both addresses are assumed to reside in the Sysmap.
 */
void
pagemove(from, to, size)
	register caddr_t from, to;
	size_t size;
{
	paddr_t pa;

	while (size > 0) {
		if (pmap_extract(pmap_kernel(), (vaddr_t)from, &pa) == FALSE)
			panic("pagemove");
		pmap_kremove((vaddr_t)from, PAGE_SIZE);
		pmap_kenter_pa((vaddr_t)to, pa, UVM_PROT_RW);
		from += PAGE_SIZE;
		to += PAGE_SIZE;
		size -= PAGE_SIZE;
	}
	pmap_update(pmap_kernel());
@


1.57
log
@Remove cpu_swapin() and cpu_swapout(), they are no longer necessary (except
for cpu_swapin() on hppa* which is kept).
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.56 2005/03/15 05:13:32 mickey Exp $	*/
a115 17
void cpu_swapin(struct proc *p);

void
cpu_swapin(struct proc *p)
{
	struct trapframe *tf = p->p_md.md_regs;
	paddr_t pa;

	/*
	 * Stash the physical for the pcb of U for later perusal
	 */
	if (!pmap_extract(pmap_kernel(), (vaddr_t)p->p_addr, &pa))
		panic("pmap_extract(%p) failed", p->p_addr);

	tf->tf_cr30 = pa;
}

d129 1
d158 1
a158 2
	 * cpu_swapin() is supposed to fill out all the PAs
	 * we gonna need in locore
d160 4
a163 1
	cpu_swapin(p2);
@


1.56
log
@no need to flush a few fpregs since soon the whole pcb get flushed
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.55 2004/09/14 23:39:32 mickey Exp $	*/
d116 2
d119 1
a119 2
cpu_swapin(p)
	struct proc *p;
a130 16
}

void
cpu_swapout(p)
	struct proc *p;
{
	extern paddr_t fpu_curpcb;	/* from locore.S */
	extern u_int fpu_enable;
	struct trapframe *tf = p->p_md.md_regs;

	if (tf->tf_cr30 == fpu_curpcb) {
		mtctl(fpu_enable, CR_CCR);
		fpu_save(fpu_curpcb);
		fpu_curpcb = 0;
		mtctl(0, CR_CCR);
	}
@


1.55
log
@store fpu version for later use. make sure to proper store/clear fpu state in fork/exec/exit/sendsig
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.54 2004/06/08 22:00:25 mickey Exp $	*/
a181 1
	fdcache(HPPA_SID_KERNEL, (vaddr_t)&pcbp->pcb_fpregs[0], 8 * 4);
@


1.54
log
@always create a stack frame in cpu_switch() and put a stub
for doing page idle zeroing.
store the kernele stack pointer into pcb instead of trapframe
for debuggers doing stack traces; from kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.53 2004/04/21 23:09:30 mickey Exp $	*/
d137 1
d141 1
d144 1
d157 1
d166 2
a167 1
	if (p1->p_md.md_regs->tf_cr30 == fpu_curpcb)
d169 2
@


1.53
log
@only set child return values in the child_return() more like other archs
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.52 2004/04/07 18:24:19 mickey Exp $	*/
d209 1
a209 1
	 * Build a stack frame for the cpu_switch & co.
d212 1
a212 6
	sp += 2*HPPA_FRAME_SIZE + 20*4; /* std frame + calee-save registers */
	*HPPA_FRAME_CARG(0, sp) = tf->tf_sp;
	*HPPA_FRAME_CARG(1, sp) = KERNMODE(func);
	*HPPA_FRAME_CARG(2, sp) = (register_t)arg;
	*(register_t*)(osp) = (sp - HPPA_FRAME_SIZE);
	*(register_t*)(sp + HPPA_FRAME_PSP) = osp;
d215 6
a220 1
	tf->tf_sp = sp;
@


1.52
log
@update copyright; miod@@ is fine w/ files where he holds it too
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.51 2004/04/06 18:33:50 mickey Exp $	*/
a200 7

	/*
	 * Set up return value registers as libc:fork() expects
	 */
	tf->tf_ret0 = p1->p_pid;
	tf->tf_ret1 = 1;	/* ischild */
	tf->tf_t1 = 0;		/* errno */
@


1.51
log
@in cpu_exit() make sure to flush the fpu operation (store fr0)
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.50 2003/02/18 19:01:50 deraadt Exp $	*/
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Michael Shalayeff.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.50
log
@knf; mickey ok
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.49 2003/01/29 20:57:01 mickey Exp $	*/
d4 1
a4 1
 * Copyright (c) 1999-2003 Michael Shalayeff
d243 2
a244 1
	if (fpu_curpcb == tf->tf_cr30)
d246 1
@


1.49
log
@save fpregs in coredump
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.48 2003/01/22 16:23:24 mickey Exp $	*/
d81 4
a84 3
#define	write(vp, addr, n) vn_rdwr(UIO_WRITE, (vp), (caddr_t)(addr), (n), off, \
			     UIO_SYSSPACE, IO_NODELOCKED|IO_UNIT, cred, NULL, p)
	
@


1.48
log
@print out the failed p_addr in the panic message
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.47 2003/01/01 10:03:15 mickey Exp $	*/
d75 1
@


1.47
log
@rip off a vmapbuf() from sparc, fix a bug in the vunmapbuf
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.46 2002/12/17 21:54:25 mickey Exp $	*/
d4 1
a4 1
 * Copyright (c) 1999-2002 Michael Shalayeff
d130 1
a130 1
		panic("pmap_extract(p_addr) failed");
@


1.46
log
@real interrupts/spl framework.
tested on 712/* 715/100, 715/33 which main cpu/bus types.
miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.45 2002/11/08 21:42:12 mickey Exp $	*/
d262 2
a263 3
	struct proc *p = bp->b_proc;
	struct vm_map *map = &p->p_vmspace->vm_map;
	vaddr_t addr, kva;
a264 2
	paddr_t pa;
	int npf;
d270 4
a273 3
	addr = (vaddr_t)(bp->b_saveaddr = bp->b_data);
	off = addr & PGOFSET;
	size = round_page(bp->b_bcount + off);
a275 2
	 * Note that this is an expanded version of:
	 *   kva = uvm_km_valloc_wait(kernel_map, size);
d280 5
a284 10
	while (1) {
		kva = vm_map_min(phys_map);
		if (uvm_map(phys_map, &kva, size, NULL, addr, 0,
		    UVM_MAPFLAG(UVM_PROT_RW, UVM_PROT_RW,
		    UVM_INH_NONE, UVM_ADV_RANDOM, 0)) == 0) {
			bp->b_data = (caddr_t)(kva + off);
			break;
		}
		tsleep(phys_map, PVM, "vallocwait", 0);
	}
d286 1
a286 4
	fdcache(vm_map_pmap(map)->pm_space, addr, size);
	for (npf = btoc(size), addr = trunc_page(addr); npf--;
	     addr += PAGE_SIZE, kva += PAGE_SIZE)
		if (pmap_extract(vm_map_pmap(map), addr, &pa) == FALSE)
d290 5
d314 1
a314 1
	uvm_km_free_wakeup(phys_map, addr, len);
@


1.45
log
@only reset the pending fpu exceptions on fork, not the rest of the fpu status reg
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.44 2002/10/07 15:32:37 mickey Exp $	*/
d202 1
a202 1
	tf->tf_eiem = ~0;
d229 1
@


1.44
log
@s/PSW_/PSL_/ to match other archs
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.43 2002/10/07 14:38:34 mickey Exp $	*/
d174 1
a174 1
	pcbp->pcb_fpregs[0] = ((u_int64_t)HPPA_FPU_INIT) << 32;
@


1.43
log
@on implementations w/ fpu included unimplemented instructions
are signaled through the exception trap w/ invalid opcode marked
instruction in the exception registers, not through the emulation
trap (as long as the fpu is enabled, of  course).
parse emulation from the exception trap as well as the emulation
trap and fix the dispatcher into usable condition.
parse invalid op exception on trap and signal the user appropriately.
reset the exception on exec and for child on fork.
the later is appropriate since exceptions are delayed until next
fpu instruction, which was in the parent indeed, let him get it.
save parent's fpu context on fork before cipying it, if the
parent owned the fpu.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.42 2002/09/11 15:55:58 mickey Exp $	*/
d203 1
a203 1
	tf->tf_ipsw = PSW_C | PSW_Q | PSW_P | PSW_D | PSW_I /* | PSW_L */;
@


1.42
log
@stack grows the other way, but the frame is the other way to that. hehe
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.41 2002/09/05 21:37:18 mickey Exp $	*/
d139 1
a139 1
	extern vaddr_t fpu_curpcb;
d156 1
d165 2
d173 6
a203 1
	pcbp->pcb_fpregs[32] = 0;
@


1.41
log
@fpu save state is a separate magic function now
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.40 2002/08/03 20:56:42 mickey Exp $	*/
d108 2
a109 1
		pmap_extract(pmap_kernel(), (vaddr_t)from, &pa);
d218 1
a218 1
	*(register_t*)(osp) = 0;
a236 2

	/* switch_exit(p); */
@


1.40
log
@in fact, no need for switch_exit() completely, cpu_exit() handles the reins to the cpu_switch and basta!
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.39 2002/06/09 02:50:29 mickey Exp $	*/
d138 1
a138 1
	extern paddr_t fpu_curpcb;
d142 1
a142 34
		__asm __volatile(
		    "fstds,ma %%fr0 , 8(%0)\n\t"
		    "fstds,ma %%fr1 , 8(%0)\n\t"
		    "fstds,ma %%fr2 , 8(%0)\n\t"
		    "fstds,ma %%fr3 , 8(%0)\n\t"
		    "fstds,ma %%fr4 , 8(%0)\n\t"
		    "fstds,ma %%fr5 , 8(%0)\n\t"
		    "fstds,ma %%fr6 , 8(%0)\n\t"
		    "fstds,ma %%fr7 , 8(%0)\n\t"
		    "fstds,ma %%fr8 , 8(%0)\n\t"
		    "fstds,ma %%fr9 , 8(%0)\n\t"
		    "fstds,ma %%fr10, 8(%0)\n\t"
		    "fstds,ma %%fr11, 8(%0)\n\t"
		    "fstds,ma %%fr12, 8(%0)\n\t"
		    "fstds,ma %%fr13, 8(%0)\n\t"
		    "fstds,ma %%fr14, 8(%0)\n\t"
		    "fstds,ma %%fr15, 8(%0)\n\t"
		    "fstds,ma %%fr16, 8(%0)\n\t"
		    "fstds,ma %%fr17, 8(%0)\n\t"
		    "fstds,ma %%fr18, 8(%0)\n\t"
		    "fstds,ma %%fr19, 8(%0)\n\t"
		    "fstds,ma %%fr20, 8(%0)\n\t"
		    "fstds,ma %%fr21, 8(%0)\n\t"
		    "fstds,ma %%fr22, 8(%0)\n\t"
		    "fstds,ma %%fr23, 8(%0)\n\t"
		    "fstds,ma %%fr24, 8(%0)\n\t"
		    "fstds,ma %%fr25, 8(%0)\n\t"
		    "fstds,ma %%fr26, 8(%0)\n\t"
		    "fstds,ma %%fr27, 8(%0)\n\t"
		    "fstds,ma %%fr28, 8(%0)\n\t"
		    "fstds,ma %%fr29, 8(%0)\n\t"
		    "fstds,ma %%fr30, 8(%0)\n\t"
		    "fstds    %%fr31, 0(%0)\n\t"
		    : "+r" (fpu_curpcb) :: "memory");
@


1.39
log
@an agr(0) was overwriting the saved r18, fix that
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.38 2002/06/06 16:36:09 mickey Exp $	*/
a263 4
	uvmexp.swtch++;

	splhigh();
	curproc = NULL;
d267 4
a270 1
	switch_exit(p);
@


1.38
log
@use shorter uvm_prot_rw
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.37 2002/04/01 16:05:10 mickey Exp $	*/
d245 2
a246 2
	osp = sp;
	sp += HPPA_FRAME_SIZE + 16*4; /* std frame + calee-save registers */
d250 1
d252 1
a252 2
	*(register_t*)(sp + HPPA_FRAME_CRP) =
		(register_t)switch_trampoline;
@


1.37
log
@kenter map the buffers
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.36 2002/03/28 07:21:12 deraadt Exp $	*/
d110 1
a110 2
		pmap_kenter_pa((vaddr_t)to, pa,
		    VM_PROT_READ|VM_PROT_WRITE);
@


1.36
log
@do not use MID_ZERO!  then file(1) does not work
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.35 2002/03/28 07:02:27 deraadt Exp $	*/
d289 2
d292 1
a293 1
	vsize_t size, off;
a294 2
	struct proc *p;
	struct vm_map *map;
d300 1
a300 4
	p = bp->b_proc;
	map = &p->p_vmspace->vm_map;
	bp->b_saveaddr = bp->b_data;
	addr = (vaddr_t)bp->b_saveaddr;
d314 3
a316 2
		    UVM_MAPFLAG(UVM_PROT_ALL, UVM_PROT_ALL,
		    UVM_INH_NONE, UVM_ADV_RANDOM, 0)) == 0)
d318 1
d322 3
a324 7
	bp->b_data = (caddr_t)(kva + off);
	addr = trunc_page(addr);
	npf = btoc(size);
	while (npf--) {
		/* not needed, thanks to PMAP_PREFER() */
		/* fdcache(vm_map_pmap(map)->pmap_space, addr, PAGE_SIZE); */

d327 2
a328 6
		pmap_enter(vm_map_pmap(phys_map), kva, pa,
		    VM_PROT_READ|VM_PROT_WRITE, PMAP_WIRED);

		addr += PAGE_SIZE;
		kva += PAGE_SIZE;
	}
@


1.35
log
@use MID_HPPA for core file marking
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.34 2002/03/15 21:44:18 mickey Exp $	*/
d69 1
a69 1
	CORE_SETMAGIC(*core, COREMAGIC, MID_ZERO, 0);
@


1.34
log
@rewrite a pmap to use multilevel page tables.
lower 12 bits contain the perms, no unused bits left,
but a couple for off-tlb use (as the ref implemented now).
do not use the hvt, which might get some use later
if proven to speed thigs up, tlb handlers would po
another dozen of insns though, but if that's worth its...
move on the data seg and map kernel text rdonly (idea form fredette),
since all of the page0 mods done before that we are all fine
except for some viper fluff, but later w/ that.
this also picks up a bit more of ddb magic for bpt and ss.
tlb handlers can use a little bit more of attention,
but things, visually, seem to be much faster already, --
sorry, no benchmarks for now.

* effort sponsored in part by the `henry st. old ale house'
* and mr.pete and mr.lee in particular in thier generous entrirety.
* the proj took a little more that 72man*h as it was expected,
* but within murhy's law estimations.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.33 2002/02/21 06:12:30 mickey Exp $	*/
d76 1
a76 1
	CORE_SETMAGIC(cseg, CORESEGMAGIC, MID_ZERO, CORE_CPU);
@


1.33
log
@pmap.pmap_pd is redundant -- no more
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.32 2002/02/11 21:16:32 mickey Exp $	*/
d201 1
a201 1
	pcbp->pcb_space = p2->p_vmspace->vm_map.pmap->pmap_space;
a216 1
		p2->p_vmspace->vm_map.pmap->pmap_space;
d218 1
a218 1
		p2->p_vmspace->vm_map.pmap->pmap_space;
@


1.32
log
@fpu_curpcb has pa in it, use accordingly, do not use kvtop
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.31 2002/02/01 21:03:20 mickey Exp $	*/
d220 1
a220 1
	tf->tf_pidr1 = tf->tf_pidr2 = p2->p_vmspace->vm_map.pmap->pmap_pid;
@


1.31
log
@use kenter/kremove in pagemove(), from netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.31 2002/02/01 20:55:05 mickey Exp $	*/
d124 1
d129 4
a132 1
	tf->tf_cr30 = kvtop((caddr_t)p->p_addr);
d140 1
a140 3
	paddr_t q = fpu_curpcb;

	fpu_curpcb = 0;
d142 1
a142 4
	/*
	 * TODO: determine if we have an fpu
	 */
	if (kvtop((caddr_t)&p->p_addr->u_pcb) == q) {
d176 2
a177 1
		    : "+r" (q) :: "memory");
d264 1
d270 1
a270 1
	if (fpu_curpcb == (paddr_t)&p->p_addr->u_pcb)
@


1.30
log
@Sprinkle pmap_update calls where relevant and some other
misc pmap usage fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.29 2001/11/28 13:47:38 art Exp $	*/
d4 1
a4 1
 * Copyright (c) 1999-2000 Michael Shalayeff
d109 3
a111 5
		pmap_remove(pmap_kernel(),
			    (vaddr_t)from, (vaddr_t)from + PAGE_SIZE);
		pmap_enter(pmap_kernel(), (vaddr_t)to, pa,
			   VM_PROT_READ|VM_PROT_WRITE,
			   VM_PROT_READ|VM_PROT_WRITE|PMAP_WIRED);
@


1.30.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.30 2001/12/08 02:24:06 art Exp $	*/
d4 1
a4 1
 * Copyright (c) 1999-2002 Michael Shalayeff
d69 1
a69 1
	CORE_SETMAGIC(*core, COREMAGIC, MID_HPPA, 0);
d76 1
a76 1
	CORE_SETMAGIC(cseg, CORESEGMAGIC, MID_HPPA, CORE_CPU);
d109 5
a113 2
		pmap_kremove((vaddr_t)from, PAGE_SIZE);
		pmap_kenter_pa((vaddr_t)to, pa, UVM_PROT_RW);
a125 1
	paddr_t pa;
d130 1
a130 4
	if (!pmap_extract(pmap_kernel(), (vaddr_t)p->p_addr, &pa))
		panic("pmap_extract(p_addr) failed");

	tf->tf_cr30 = pa;
d138 3
a140 1
	struct trapframe *tf = p->p_md.md_regs;
d142 4
a145 1
	if (tf->tf_cr30 == fpu_curpcb) {
d179 1
a179 2
		    : "+r" (fpu_curpcb) :: "memory");
		fpu_curpcb = 0;
d203 1
a203 1
	pcbp->pcb_space = p2->p_vmspace->vm_map.pmap->pm_space;
d219 1
d221 2
a222 2
		p2->p_vmspace->vm_map.pmap->pm_space;
	tf->tf_pidr1 = tf->tf_pidr2 = pmap_sid2pid(tf->tf_sr0);
d249 2
a250 2
	osp = sp + HPPA_FRAME_SIZE;
	sp += 2*HPPA_FRAME_SIZE + 20*4; /* std frame + calee-save registers */
a253 1
	*(register_t*)(osp) = 0;
d255 2
a256 1
	*(register_t*)(osp + HPPA_FRAME_CRP) = (register_t)&switch_trampoline;
a265 1
	struct trapframe *tf = p->p_md.md_regs;
d271 1
a271 1
	if (fpu_curpcb == tf->tf_cr30)
a290 2
	struct proc *p = bp->b_proc;
	struct vm_map *map = &p->p_vmspace->vm_map;
d292 1
a293 1
	paddr_t pa;
d295 2
d302 4
a305 1
	addr = (vaddr_t)(bp->b_saveaddr = bp->b_data);
d319 2
a320 3
		    UVM_MAPFLAG(UVM_PROT_RW, UVM_PROT_RW,
		    UVM_INH_NONE, UVM_ADV_RANDOM, 0)) == 0) {
			bp->b_data = (caddr_t)(kva + off);
a321 1
		}
d325 7
a331 3
	fdcache(vm_map_pmap(map)->pm_space, addr, size);
	for (npf = btoc(size), addr = trunc_page(addr); npf--;
	     addr += PAGE_SIZE, kva += PAGE_SIZE)
d334 6
a339 2
		else
			pmap_kenter_pa(kva, pa, UVM_PROT_RW);
@


1.30.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.30.2.1 2002/06/11 03:35:37 art Exp $	*/
d108 1
a108 2
		if (pmap_extract(pmap_kernel(), (vaddr_t)from, &pa) == FALSE)
			panic("pagemove");
d138 1
a138 1
	extern paddr_t fpu_curpcb;	/* from locore.S */
d142 34
a175 1
		fpu_save(fpu_curpcb);
a187 1
	extern paddr_t fpu_curpcb;	/* from locore.S */
a195 2
	if (p1->p_md.md_regs->tf_cr30 == fpu_curpcb)
		fpu_save(fpu_curpcb);
a201 6
	/* reset any of the pending FPU exceptions from parent */
	pcbp->pcb_fpregs[0] = ((u_int64_t)HPPA_FPU_INIT) << 32;
	pcbp->pcb_fpregs[1] = 0;
	pcbp->pcb_fpregs[2] = 0;
	pcbp->pcb_fpregs[3] = 0;
	fdcache(HPPA_SID_KERNEL, (vaddr_t)&pcbp->pcb_fpregs[0], 8 * 4);
d226 2
a227 1
	tf->tf_ipsw = PSL_C | PSL_Q | PSL_P | PSL_D | PSL_I /* | PSL_L */;
d250 1
a250 1
	*(register_t*)(osp) = (sp - HPPA_FRAME_SIZE);
d264 4
d271 1
a271 2
	exit2(p);
	cpu_switch(p);
@


1.30.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d4 1
a4 1
 * Copyright (c) 1999-2003 Michael Shalayeff
a74 1
	process_read_fpregs(p, &md_core.md_fpreg);
d80 3
a82 4
#define	write(vp, addr, n) \
	vn_rdwr(UIO_WRITE, (vp), (caddr_t)(addr), (n), off, \
	    UIO_SYSSPACE, IO_NODELOCKED|IO_UNIT, cred, NULL, p)

d130 1
a130 1
		panic("pmap_extract(%p) failed", p->p_addr);
d174 1
a174 1
	pcbp->pcb_fpregs[0] = HPPA_FPU_FORK(pcbp->pcb_fpregs[0]);
d202 1
a202 1
	mfctl(CR_EIEM, tf->tf_eiem);
a228 1
	*(register_t*)(osp + HPPA_FRAME_SL) = 0;	/* cpl */
d261 3
a263 2
	struct pmap *pm = vm_map_pmap(&bp->b_proc->p_vmspace->vm_map);
	vaddr_t kva, uva;
d265 2
d272 3
a274 4
	bp->b_saveaddr = bp->b_data;
	uva = trunc_page((vaddr_t)bp->b_data);
	off = (vaddr_t)bp->b_data - uva;
	size = round_page(off + len);
d277 2
d283 10
a292 5
	kva = uvm_km_valloc_prefer_wait(kernel_map, size, uva);
	fdcache(pm->pm_space, uva, size);
	bp->b_data = (caddr_t)(kva + off);
	while (size > 0) {
		paddr_t pa;
d294 4
a297 1
		if (pmap_extract(pm, uva, &pa) == FALSE)
a300 5
		uva += PAGE_SIZE;
		kva += PAGE_SIZE;
		size -= PAGE_SIZE;
	}
	pmap_update(pmap_kernel());
d320 1
a320 1
	uvm_km_free_wakeup(kernel_map, addr, len);
@


1.29
log
@Sync in more uvm changes from NetBSD.
This time we're getting rid of KERN_* and VM_PAGER_* error codes and
use errnos instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.28 2001/11/07 01:18:00 art Exp $	*/
d118 1
@


1.28
log
@Add an alignment argument to uvm_map that specifies an alignment hint
for the virtual address.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.27 2001/11/06 19:53:14 miod Exp $	*/
d319 1
a319 1
		    UVM_INH_NONE, UVM_ADV_RANDOM, 0)) == KERN_SUCCESS)
@


1.27
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.26 2001/11/06 18:41:09 art Exp $	*/
d317 1
a317 1
		if (uvm_map(phys_map, &kva, size, NULL, addr,
@


1.26
log
@Let fork1, uvm_fork, and cpu_fork take a function/argument pair as argument,
instead of doing fork1, cpu_set_kpc. This lets us retire cpu_set_kpc and
avoid a multiprocessor race.

This commit breaks vax because it doesn't look like any other arch, someone
working on vax might want to look at this and try to adapt the code to be
more like the rest of the world.

Idea and uvm parts from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.25 2001/09/19 20:50:56 mickey Exp $	*/
a50 1
#include <vm/vm.h>
@


1.25
log
@merge vm/vm_kern.h into uvm/uvm_extern.h; art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.24 2001/07/25 13:25:31 art Exp $	*/
d184 1
a184 1
cpu_fork(p1, p2, stack, stacksize)
d188 2
d191 2
a192 2
	register struct pcb *pcbp;
	register struct trapframe *tf;
d252 2
a253 2
	*HPPA_FRAME_CARG(1, sp) = KERNMODE(child_return);
	*HPPA_FRAME_CARG(2, sp) = (register_t)p2;
a258 17
}

void
cpu_set_kpc(p, pc, arg)
	struct proc *p;
	void (*pc) __P((void *));
	void *arg;
{
	struct trapframe *tf = p->p_md.md_regs;
	register_t sp = tf->tf_sp;

	/*
	 * Overwrite normally stashed there &child_return(p)
	 */
	*HPPA_FRAME_CARG(1, sp) = (register_t)pc;
	*HPPA_FRAME_CARG(2, sp) = (register_t)arg;
	fdcache(HPPA_SID_KERNEL, (vaddr_t)sp, HPPA_FRAME_SIZE);
@


1.24
log
@Change the pmap_enter interface to merge access_type and the wired boolean
and arbitrary flags into one argument.

One new flag is PMAP_CANFAIL that tells pmap_enter that it can fail if there
are not enough resources to satisfy the request. If this flag is not passed,
pmap_enter should panic as it should have done before this change (XXX - many
pmaps are still not doing that).

Only i386 and alpha implement CANFAIL for now.

Includes uvm updates from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.23 2001/06/10 02:55:43 mickey Exp $	*/
a51 1
#include <vm/vm_kern.h>
@


1.23
log
@free commit from art
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.22 2001/06/08 08:08:49 art Exp $	*/
d114 2
a115 2
			   VM_PROT_READ|VM_PROT_WRITE, 1,
			   VM_PROT_READ|VM_PROT_WRITE);
d351 1
a351 1
		    VM_PROT_READ|VM_PROT_WRITE, TRUE, 0);
@


1.22
log
@Change the paddr_t pmap_extract(struct pmap *, vaddr_t) interface to
boolean_t pmap_extract(struct pmap *, vaddr_t, paddr_t *).
Matches NetBSD. Tested by various people on various platforms.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.21 2001/05/06 00:45:49 art Exp $	*/
d107 1
a107 1
	register paddr_t pa;
@


1.21
log
@Update some comments wrt. the CLSIZE changes.
And remove that memory price comment from 1981. It is amusing, but also
confusing because the math in there is only correct on vax.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.20 2001/05/05 21:26:36 art Exp $	*/
d110 1
a110 1
		pa = pmap_extract(pmap_kernel(), (vaddr_t)from);
d348 1
a348 3
		pa = pmap_extract(vm_map_pmap(map), addr);
#ifdef DIAGNOSTIC
		if (pa == 0)
a349 1
#endif
@


1.20
log
@Remove the (vaddr_t) casts inside the round_page and trunc_page macros.
We might want to use them on types that are bigger than vaddr_t.

Fix all callers that pass pointers without casts.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.19 2001/03/29 00:17:00 mickey Exp $	*/
d100 1
a100 2
 * Both addresses are assumed to reside in the Sysmap,
 * and size must be a multiple of CLSIZE.
@


1.19
log
@context and stack setup proper, better map/unmapbuf
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.18 2000/06/08 22:25:19 niklas Exp $	*/
d376 1
a376 1
	addr = trunc_page(bp->b_data);
@


1.18
log
@Add explicit inclusions of signalvar.h to files actually using syms defined
there but relying on an indirect inclusion
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.18 2000/06/08 21:11:58 niklas Exp $	*/
d193 1
a193 1
	register_t sp;
d249 1
d254 1
a254 1
	*(register_t*)(sp + HPPA_FRAME_PSP) = sp;
d267 2
a268 1
	register struct trapframe *tf = p->p_md.md_regs;
d273 3
a275 3
	*HPPA_FRAME_CARG(1, tf->tf_sp) = (register_t)pc;
	*HPPA_FRAME_CARG(2, tf->tf_sp) = (register_t)arg;
	fdcache(HPPA_SID_KERNEL, (vaddr_t)tf->tf_sp, HPPA_FRAME_SIZE);
d308 1
a308 1
	vaddr_t faddr, taddr, off;
d310 2
d313 1
d315 1
d318 1
d320 31
a350 8
	faddr = trunc_page(bp->b_saveaddr = bp->b_data);
	off = (vaddr_t)bp->b_data - faddr;
	len = round_page(off + len);
	taddr = uvm_km_valloc_wait(phys_map, len);
	bp->b_data = (caddr_t)(taddr + off);
	len = atop(len);
	while (len--) {
		pa = pmap_extract(vm_map_pmap(&p->p_vmspace->vm_map), faddr);
d353 6
a358 4
		pmap_enter(vm_map_pmap(phys_map), taddr, trunc_page(pa),
			   VM_PROT_READ|VM_PROT_WRITE, TRUE, 0);
		faddr += PAGE_SIZE;
		taddr += PAGE_SIZE;
d372 1
d375 1
a381 1

@


1.17
log
@Adjust for the reaper.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.16 2000/01/25 12:55:04 mickey Exp $	*/
d38 1
@


1.16
log
@cpu_wait(); flush cache in setkpc; explicit bcopy() use in cpu_fork()
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.15 2000/01/24 20:44:14 mickey Exp $	*/
a287 2
	uvmspace_free(p->p_vmspace);

a294 1
	uvm_km_free(kernel_map, (vaddr_t)p->p_addr, USPACE);
@


1.16.2.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.19 2001/03/29 00:17:00 mickey Exp $	*/
a37 1
#include <sys/signalvar.h>
d192 1
a192 1
	register_t sp, osp;
a247 1
	osp = sp;
d252 1
a252 1
	*(register_t*)(sp + HPPA_FRAME_PSP) = osp;
d265 1
a265 2
	struct trapframe *tf = p->p_md.md_regs;
	register_t sp = tf->tf_sp;
d270 3
a272 3
	*HPPA_FRAME_CARG(1, sp) = (register_t)pc;
	*HPPA_FRAME_CARG(2, sp) = (register_t)arg;
	fdcache(HPPA_SID_KERNEL, (vaddr_t)sp, HPPA_FRAME_SIZE);
d288 2
d297 1
d308 1
a308 1
	vaddr_t addr, kva;
a309 2
	vsize_t size, off;
	int npf;
a310 1
	struct vm_map *map;
a311 1
#ifdef DIAGNOSTIC
a313 1
#endif
d315 8
a322 31
	map = &p->p_vmspace->vm_map;
	bp->b_saveaddr = bp->b_data;
	addr = (vaddr_t)bp->b_saveaddr;
	off = addr & PGOFSET;
	size = round_page(bp->b_bcount + off);

	/*
	 * Note that this is an expanded version of:
	 *   kva = uvm_km_valloc_wait(kernel_map, size);
	 * We do it on our own here to be able to specify an offset to uvm_map
	 * so that we can get all benefits of PMAP_PREFER.
	 * - art@@
	 */
	while (1) {
		kva = vm_map_min(phys_map);
		if (uvm_map(phys_map, &kva, size, NULL, addr,
		    UVM_MAPFLAG(UVM_PROT_ALL, UVM_PROT_ALL,
		    UVM_INH_NONE, UVM_ADV_RANDOM, 0)) == KERN_SUCCESS)
			break;
		tsleep(phys_map, PVM, "vallocwait", 0);
	}

	bp->b_data = (caddr_t)(kva + off);
	addr = trunc_page(addr);
	npf = btoc(size);
	while (npf--) {
		/* not needed, thanks to PMAP_PREFER() */
		/* fdcache(vm_map_pmap(map)->pmap_space, addr, PAGE_SIZE); */

		pa = pmap_extract(vm_map_pmap(map), addr);
#ifdef DIAGNOSTIC
d325 4
a328 6
#endif
		pmap_enter(vm_map_pmap(phys_map), kva, pa,
		    VM_PROT_READ|VM_PROT_WRITE, TRUE, 0);

		addr += PAGE_SIZE;
		kva += PAGE_SIZE;
a341 1
#ifdef DIAGNOSTIC
a343 1
#endif
d350 1
@


1.16.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.16.2.1 2001/04/18 16:06:16 niklas Exp $	*/
d100 2
a101 1
 * Both addresses are assumed to reside in the Sysmap.
d108 1
a108 1
	paddr_t pa;
d111 1
a111 1
		pmap_extract(pmap_kernel(), (vaddr_t)from, &pa);
d349 3
a351 1
		if (pmap_extract(vm_map_pmap(map), addr, &pa) == FALSE)
d353 1
d376 1
a376 1
	addr = trunc_page((vaddr_t)bp->b_data);
@


1.16.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.16.2.2 2001/07/04 10:16:06 niklas Exp $	*/
d52 1
d114 2
a115 2
			   VM_PROT_READ|VM_PROT_WRITE,
			   VM_PROT_READ|VM_PROT_WRITE|PMAP_WIRED);
d351 1
a351 1
		    VM_PROT_READ|VM_PROT_WRITE, PMAP_WIRED);
@


1.16.2.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d51 1
d184 1
a184 1
cpu_fork(p1, p2, stack, stacksize, func, arg)
a187 2
	void (*func)(void *);
	void *arg;
d189 2
a190 2
	struct pcb *pcbp;
	struct trapframe *tf;
d250 2
a251 2
	*HPPA_FRAME_CARG(1, sp) = KERNMODE(func);
	*HPPA_FRAME_CARG(2, sp) = (register_t)arg;
d260 17
d333 1
a333 1
		if (uvm_map(phys_map, &kva, size, NULL, addr, 0,
@


1.16.2.5
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.16.2.4 2001/11/13 21:00:51 niklas Exp $	*/
d319 1
a319 1
		    UVM_INH_NONE, UVM_ADV_RANDOM, 0)) == 0)
@


1.16.2.6
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d4 1
a4 1
 * Copyright (c) 1999-2002 Michael Shalayeff
d109 5
a113 3
		pmap_kremove((vaddr_t)from, PAGE_SIZE);
		pmap_kenter_pa((vaddr_t)to, pa,
		    VM_PROT_READ|VM_PROT_WRITE);
a117 1
	pmap_update(pmap_kernel());
a124 1
	paddr_t pa;
d129 1
a129 4
	if (!pmap_extract(pmap_kernel(), (vaddr_t)p->p_addr, &pa))
		panic("pmap_extract(p_addr) failed");

	tf->tf_cr30 = pa;
d137 3
a139 1
	struct trapframe *tf = p->p_md.md_regs;
d141 4
a144 1
	if (tf->tf_cr30 == fpu_curpcb) {
d178 1
a178 2
		    : "+r" (fpu_curpcb) :: "memory");
		fpu_curpcb = 0;
d221 1
a221 1
	tf->tf_pidr1 = tf->tf_pidr2 = pmap_sid2pid(tf->tf_sr0);
a264 1
	struct trapframe *tf = p->p_md.md_regs;
d270 1
a270 1
	if (fpu_curpcb == tf->tf_cr30)
@


1.16.2.7
log
@Merge in -current from about a week ago
@
text
@d201 1
a201 1
	pcbp->pcb_space = p2->p_vmspace->vm_map.pmap->pm_space;
d217 1
d219 1
a219 1
		p2->p_vmspace->vm_map.pmap->pm_space;
@


1.16.2.8
log
@Sync the SMP branch with 3.3
@
text
@d4 1
a4 1
 * Copyright (c) 1999-2003 Michael Shalayeff
d69 1
a69 1
	CORE_SETMAGIC(*core, COREMAGIC, MID_HPPA, 0);
a74 1
	process_read_fpregs(p, &md_core.md_fpreg);
d76 1
a76 1
	CORE_SETMAGIC(cseg, CORESEGMAGIC, MID_HPPA, CORE_CPU);
d80 3
a82 4
#define	write(vp, addr, n) \
	vn_rdwr(UIO_WRITE, (vp), (caddr_t)(addr), (n), off, \
	    UIO_SYSSPACE, IO_NODELOCKED|IO_UNIT, cred, NULL, p)

d108 1
a108 2
		if (pmap_extract(pmap_kernel(), (vaddr_t)from, &pa) == FALSE)
			panic("pagemove");
d110 2
a111 1
		pmap_kenter_pa((vaddr_t)to, pa, UVM_PROT_RW);
d130 1
a130 1
		panic("pmap_extract(%p) failed", p->p_addr);
d139 1
a139 1
	extern paddr_t fpu_curpcb;	/* from locore.S */
d143 34
a176 1
		fpu_save(fpu_curpcb);
a188 1
	extern paddr_t fpu_curpcb;	/* from locore.S */
a196 2
	if (p1->p_md.md_regs->tf_cr30 == fpu_curpcb)
		fpu_save(fpu_curpcb);
a202 6
	/* reset any of the pending FPU exceptions from parent */
	pcbp->pcb_fpregs[0] = HPPA_FPU_FORK(pcbp->pcb_fpregs[0]);
	pcbp->pcb_fpregs[1] = 0;
	pcbp->pcb_fpregs[2] = 0;
	pcbp->pcb_fpregs[3] = 0;
	fdcache(HPPA_SID_KERNEL, (vaddr_t)&pcbp->pcb_fpregs[0], 8 * 4);
d226 3
a228 2
	mfctl(CR_EIEM, tf->tf_eiem);
	tf->tf_ipsw = PSL_C | PSL_Q | PSL_P | PSL_D | PSL_I /* | PSL_L */;
d246 2
a247 2
	osp = sp + HPPA_FRAME_SIZE;
	sp += 2*HPPA_FRAME_SIZE + 20*4; /* std frame + calee-save registers */
a250 1
	*(register_t*)(osp) = (sp - HPPA_FRAME_SIZE);
d252 2
a253 2
	*(register_t*)(osp + HPPA_FRAME_CRP) = (register_t)&switch_trampoline;
	*(register_t*)(osp + HPPA_FRAME_SL) = 0;	/* cpl */
d265 4
d272 1
a272 2
	exit2(p);
	cpu_switch(p);
d289 2
a290 2
	struct pmap *pm = vm_map_pmap(&bp->b_proc->p_vmspace->vm_map);
	vaddr_t kva, uva;
d292 3
d300 2
d303 3
a305 3
	uva = trunc_page((vaddr_t)bp->b_data);
	off = (vaddr_t)bp->b_data - uva;
	size = round_page(off + len);
d308 2
d314 9
a322 2
	kva = uvm_km_valloc_prefer_wait(kernel_map, size, uva);
	fdcache(pm->pm_space, uva, size);
d324 5
a328 2
	while (size > 0) {
		paddr_t pa;
d330 1
a330 1
		if (pmap_extract(pm, uva, &pa) == FALSE)
d332 4
a335 3
		else
			pmap_kenter_pa(kva, pa, UVM_PROT_RW);
		uva += PAGE_SIZE;
a336 1
		size -= PAGE_SIZE;
a337 1
	pmap_update(pmap_kernel());
d357 1
a357 1
	uvm_km_free_wakeup(kernel_map, addr, len);
@


1.16.2.9
log
@Merge with the trunk
@
text
@d4 1
a4 1
 * Copyright (c) 1999-2004 Michael Shalayeff
d15 5
d208 7
d243 1
a243 2
	if (fpu_curpcb == tf->tf_cr30) {
		fpu_exit();
a244 1
	}
@


1.16.2.10
log
@sync with head, make i386 __HAVE_CPUINFO
@
text
@d209 1
a209 1
	 * Build stack frames for the cpu_switch & co.
d212 6
a217 1
	*(register_t*)(osp - HPPA_FRAME_SIZE) = 0;
d220 1
a220 6
	*(register_t*)(osp) = (osp - HPPA_FRAME_SIZE);

	sp = osp + HPPA_FRAME_SIZE + 20*4; /* frame + calee-save registers */
	*HPPA_FRAME_CARG(0, sp) = (register_t)arg;
	*HPPA_FRAME_CARG(1, sp) = KERNMODE(func);
	pcbp->pcb_ksp = sp;
@


1.15
log
@setup fork() child return values
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.14 2000/01/17 20:18:16 mickey Exp $	*/
d200 1
a200 1
	*pcbp = p1->p_addr->u_pcb;
d208 1
a208 1
	*tf = *p1->p_md.md_regs;
a226 1
#ifdef DIAGNOSTIC
a230 1
#endif
d272 1
d285 3
a287 1
	fpu_curpcb = 0;
d290 7
a296 1
	/* XXX should be in the locore? */
a297 2

	switch_exit(p);
@


1.14
log
@remove unneeded stuff from setregs; force single-user for now, enable signal debug
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.13 2000/01/17 06:02:49 mickey Exp $	*/
d233 7
@


1.13
log
@on fork, flush pcb too, update pcsq
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.12 2000/01/11 20:27:57 mickey Exp $	*/
d221 7
d229 4
a232 1
	tf->tf_pidr1 = tf->tf_pidr2 = p2->p_vmspace->vm_map.pmap->pmap_pid;
@


1.12
log
@s/fpu_curproc/fpu_curpcb/ which also points into physical.
move it's definition into locore (where it's used the most).
adjust fpu context switch and save on swapout accordingly.
fix context save (in switch).
add accounting for fpu context switches (since it differes
from proc switching, we might get provided w/ some usefull
numbers as to how effective this lazy switch technique is).
enable handling fpu/sfu exceptions.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.11 1999/12/31 09:07:13 mickey Exp $	*/
d4 1
a4 1
 * Copyright (c) 1999 Michael Shalayeff
d217 3
a219 1
		     tf->tf_sr5 = tf->tf_sr6 =
d241 1
a241 1
	fdcache(HPPA_SID_KERNEL, (vaddr_t)tf, sizeof(*tf));
@


1.11
log
@don't bother about pidr3 and pidr4
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.10 1999/11/25 18:37:43 mickey Exp $	*/
d138 2
a139 2
	extern struct proc *fpu_curproc;
	struct proc *q = fpu_curproc;
d141 1
a141 1
	fpu_curproc = NULL;
d144 1
a144 3
	 * TODO: explicit FPU save state if we own the FPU,
	 * since user area might get swapped out as well,
	 * and we won't be able to save it no more
d146 35
a180 1
	if (p == q) {
d261 1
a261 1
	extern struct proc *fpu_curproc;	/* from machdep.c */
d267 1
a267 1
	fpu_curproc = NULL;
@


1.10
log
@it forks, it execs, it syscalls
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.9 1999/09/20 21:14:22 mickey Exp $	*/
d188 1
a188 2
	tf->tf_pidr1 = tf->tf_pidr2 = tf->tf_pidr3 = tf->tf_pidr4 =
		p2->p_vmspace->vm_map.pmap->pmap_pid;
@


1.9
log
@fix after frame.h changes
@
text
@d1 33
a33 1
/*	$OpenBSD: vm_machdep.c,v 1.8 1999/09/03 18:00:47 art Exp $	*/
d46 1
d88 1
a88 1
	if ((error = write(vp, (caddr_t)&md_core, sizeof md_core)))
d107 1
a107 1
	register vm_offset_t pa;
d110 1
a110 1
		pa = pmap_extract(pmap_kernel(), (vm_offset_t)from);
d112 2
a113 2
			    (vm_offset_t)from, (vm_offset_t)from + PAGE_SIZE);
		pmap_enter(pmap_kernel(), (vm_offset_t)to, pa,
d126 6
a131 1
	/* nothing yet, move to macros later */
d138 5
d144 3
a146 2
	 * explicit FPU save state, since user area might get
	 * swapped out as well, and won't be able to save it no more
d148 2
d162 5
d171 1
d173 4
a176 4
#ifdef DIAGNOSTIC
	if (round_page(sizeof(struct user)) >= USPACE)
		panic("USPACE too small for user");
#endif
d178 5
a182 2
	p2->p_md.md_regs = tf = &pcbp->pcb_tf;
	sp = (register_t)p2->p_addr + round_page(sizeof(struct user));
d184 6
a189 3
	/* setup initial stack frame */
	bzero((caddr_t)sp, HPPA_FRAME_SIZE);
	tf->tf_sp = sp + HPPA_FRAME_SIZE;
d198 1
a198 2
	 * everybody recomends to note here the inline version of
	 * the cpu_set_kpc(), so note it !
d200 9
a208 3
	tf->tf_arg0 = KERNMODE(child_return);
	tf->tf_arg1 = (register_t)p2;
	tf->tf_iioq_tail = tf->tf_iioq_head = (register_t)switch_trampoline;
d217 1
a217 6
	register struct pcb *pcbp = &p->p_addr->u_pcb;

	pcbp->pcb_tf.tf_arg0 = (register_t)pc;
	pcbp->pcb_tf.tf_arg1 = (register_t)arg;
	pcbp->pcb_tf.tf_iioq_tail = pcbp->pcb_tf.tf_iioq_head = 
		(register_t)switch_trampoline;
d219 5
d231 1
d234 1
a241 1
	splhigh();
d251 1
a251 1
	vm_size_t len;
d253 2
a254 1
	vm_offset_t faddr, taddr, off, pa;
d261 1
a261 1
	off = (vm_offset_t)bp->b_data - faddr;
d283 1
a283 1
	vm_size_t len;
d285 1
a285 1
	vm_offset_t addr, off;
d290 1
a290 1
	off = (vm_offset_t)bp->b_data - addr;
@


1.8
log
@Change the pmap_enter api to pass down an argument that indicates
the access type that caused this mapping. This is to simplify pmaps
with mod/ref emulation (none for the moment) and in some cases speed
up pmap_is_{referenced,modified}.
At the same time, clean up some mappings that had too high protection.

XXX - the access type is incorrect in old vm, it's only used by uvm and MD code.
The actual use of this in pmap_enter implementations is not in this commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.7 1999/08/17 10:32:16 niklas Exp $	*/
d114 1
a114 1
	register struct hppa_frame *sp;
d127 1
a127 2
	sp = (struct hppa_frame *)((register_t)p2->p_addr +
				   round_page(sizeof(struct user)));
d130 2
a131 2
	bzero(sp, sizeof(struct hppa_frame));
	tf->tf_sp = (register_t)(sp + 1);
@


1.7
log
@New cpu_fork API to take a stack in which you point the child's stackpointer
to, at the bottom or the top, depending on your architecture's stack growth
direction.  This is in preparation for Linux' clone(2) emulation.
port maintainers, please check that I did the work right.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.6 1999/06/12 18:13:18 mickey Exp $	*/
d80 3
a82 2
		pmap_enter(pmap_kernel(),
			   (vm_offset_t)to, pa, VM_PROT_READ|VM_PROT_WRITE, 1);
d207 1
a207 1
			   VM_PROT_READ|VM_PROT_WRITE, TRUE);
@


1.6
log
@hppa_init() now takes an argument from locore,
meaning the start of available memory.
cleanup machdep somewhat.
fix vm_map.pmap vs vm_pmap isue; 10x art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.5 1999/05/21 17:49:47 mickey Exp $	*/
d106 1
a106 1
cpu_fork(p1, p2)
d108 2
d128 1
d132 6
@


1.5
log
@zero the fpu_curproc on proc exit, clarify the cpu_swapout()'s job
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.4 1999/04/20 20:45:37 mickey Exp $	*/
d116 1
a116 1
	pcbp->pcb_space = p2->p_vmspace->vm_pmap.pmap_space;
@


1.4
log
@some cpu_* routines, uvm
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.3 1999/02/25 19:08:50 mickey Exp $	*/
d99 4
a102 1
	/* FPU save state */
d158 1
a158 2
	/* FPU: save state */

d162 1
@


1.3
log
@vmapbuf/vunmapbuf
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.2 1999/01/10 13:34:18 niklas Exp $	*/
d10 3
a13 1
#include <vm/vm_kern.h>
d15 1
d18 2
d32 30
a61 1
	return EIO;
d92 1
a92 1

d99 1
a99 1

d106 28
a133 5
	p2->p_md.md_flags = p1->p_md.md_flags;

	p2->p_addr->u_pcb = p1->p_addr->u_pcb;

	/* TODO: create the child's kernel stack */
d137 1
a137 1
cpu_exit(p)
d139 2
d142 6
a147 1
	/* TODO: anything to be done about FPU */
a148 2
	vmspace_free(p->p_vmspace);
	/* to the switch */
a150 1

d152 1
a152 1
cpu_wait(p)
d155 1
d157 4
a160 1
}
d162 2
a163 6
void
cpu_set_kpc(p, pc, arg)
	struct proc *p;
	void (*pc) __P((void *));
	void *arg;
{
d165 2
d186 1
a186 1
	taddr = kmem_alloc_wait(phys_map, len);
d215 1
a215 1
	kmem_free_wakeup(phys_map, addr, len);
@


1.2
log
@Generalize cpu_set_kpc to take any kind of arg; mostly from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.1 1998/12/29 18:06:48 mickey Exp $	*/
d11 1
d72 5
d83 1
d85 2
d106 3
d114 2
d117 18
d137 3
d145 10
@


1.1
log
@some *machdep stuff
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d89 1
a89 1
cpu_set_kpc(p, pc)
d91 2
a92 1
	void (*pc) __P((struct proc *));
@

