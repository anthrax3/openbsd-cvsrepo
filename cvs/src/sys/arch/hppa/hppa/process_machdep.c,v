head	1.21;
access;
symbols
	OPENBSD_6_0:1.21.0.16
	OPENBSD_6_0_BASE:1.21
	OPENBSD_5_9:1.21.0.12
	OPENBSD_5_9_BASE:1.21
	OPENBSD_5_8:1.21.0.14
	OPENBSD_5_8_BASE:1.21
	OPENBSD_5_7:1.21.0.6
	OPENBSD_5_7_BASE:1.21
	OPENBSD_5_6:1.21.0.10
	OPENBSD_5_6_BASE:1.21
	OPENBSD_5_5:1.21.0.8
	OPENBSD_5_5_BASE:1.21
	OPENBSD_5_4:1.21.0.4
	OPENBSD_5_4_BASE:1.21
	OPENBSD_5_3:1.21.0.2
	OPENBSD_5_3_BASE:1.21
	OPENBSD_5_2:1.20.0.8
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.6
	OPENBSD_5_0:1.20.0.4
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.20.0.2
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.19.0.2
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.15.0.2
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.14.0.12
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.14.0.8
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.14.0.6
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.14.0.4
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.14.0.2
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.13.0.8
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.13.0.6
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.13.0.4
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.13.0.2
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.11.0.2
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.10.0.2
	OPENBSD_3_6_BASE:1.10
	SMP_SYNC_A:1.10
	SMP_SYNC_B:1.10
	OPENBSD_3_5:1.9.0.6
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.4
	OPENBSD_3_4_BASE:1.9
	UBC_SYNC_A:1.9
	OPENBSD_3_3:1.9.0.2
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	UBC_SYNC_B:1.6
	UBC:1.3.0.14
	UBC_BASE:1.3
	OPENBSD_3_0:1.3.0.12
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9:1.3.0.10
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.8
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.6
	OPENBSD_2_7_BASE:1.3
	SMP:1.3.0.4
	SMP_BASE:1.3
	kame_19991208:1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.1.0.2
	OPENBSD_2_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.21
date	2012.08.29.18.58.45;	author kettenis;	state Exp;
branches;
next	1.20;

1.20
date	2011.01.23.09.46.25;	author jsing;	state Exp;
branches;
next	1.19;

1.19
date	2010.07.01.05.33.32;	author jsing;	state Exp;
branches;
next	1.18;

1.18
date	2010.06.29.04.03.21;	author jsing;	state Exp;
branches;
next	1.17;

1.17
date	2010.06.29.00.50.40;	author jsing;	state Exp;
branches;
next	1.16;

1.16
date	2010.03.30.14.57.02;	author kettenis;	state Exp;
branches;
next	1.15;

1.15
date	2009.07.29.18.31.11;	author kettenis;	state Exp;
branches;
next	1.14;

1.14
date	2007.07.20.20.52.51;	author kettenis;	state Exp;
branches;
next	1.13;

1.13
date	2005.05.26.04.34.51;	author kettenis;	state Exp;
branches;
next	1.12;

1.12
date	2005.05.10.11.32.51;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	2004.09.14.23.39.32;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	2004.04.07.18.24.19;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	2003.01.16.00.33.14;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	2003.01.15.22.07.06;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	2002.11.08.22.30.48;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	2002.09.20.19.06.26;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	2002.03.15.19.02.54;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	2002.03.14.00.42.24;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	99.06.18.05.19.52;	author mickey;	state Exp;
branches
	1.3.4.1
	1.3.14.1;
next	1.2;

1.2
date	99.04.20.20.46.11;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	98.12.29.18.06.48;	author mickey;	state Exp;
branches;
next	;

1.3.4.1
date	2002.03.28.10.19.25;	author niklas;	state Exp;
branches;
next	1.3.4.2;

1.3.4.2
date	2003.03.27.23.26.54;	author niklas;	state Exp;
branches;
next	1.3.4.3;

1.3.4.3
date	2004.06.05.23.10.48;	author niklas;	state Exp;
branches;
next	;

1.3.14.1
date	2002.06.11.03.35.37;	author art;	state Exp;
branches;
next	1.3.14.2;

1.3.14.2
date	2002.10.29.00.28.02;	author art;	state Exp;
branches;
next	1.3.14.3;

1.3.14.3
date	2003.05.19.21.49.41;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.21
log
@Change "struct reg" to include a few more registers.  We now use the same
layout as NetBSD.
@
text
@/*	$OpenBSD: process_machdep.c,v 1.20 2011/01/23 09:46:25 jsing Exp $	*/

/*
 * Copyright (c) 1999-2004 Michael Shalayeff
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR OR HIS RELATIVES BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/ptrace.h>
#include <sys/user.h>

#include <machine/cpufunc.h>
#include <machine/fpu.h>
#include <machine/frame.h>

int
process_read_regs(struct proc *p, struct reg *regs)
{
	struct trapframe *tf = p->p_md.md_regs;

	regs->r_regs[ 0] = tf->tf_ipsw;
	regs->r_regs[ 1] = tf->tf_r1;
	regs->r_regs[ 2] = tf->tf_rp;
	regs->r_regs[ 3] = tf->tf_r3;
	regs->r_regs[ 4] = tf->tf_r4;
	regs->r_regs[ 5] = tf->tf_r5;
	regs->r_regs[ 6] = tf->tf_r6;
	regs->r_regs[ 7] = tf->tf_r7;
	regs->r_regs[ 8] = tf->tf_r8;
	regs->r_regs[ 9] = tf->tf_r9;
	regs->r_regs[10] = tf->tf_r10;
	regs->r_regs[11] = tf->tf_r11;
	regs->r_regs[12] = tf->tf_r12;
	regs->r_regs[13] = tf->tf_r13;
	regs->r_regs[14] = tf->tf_r14;
	regs->r_regs[15] = tf->tf_r15;
	regs->r_regs[16] = tf->tf_r16;
	regs->r_regs[17] = tf->tf_r17;
	regs->r_regs[18] = tf->tf_r18;
	regs->r_regs[19] = tf->tf_t4;
	regs->r_regs[20] = tf->tf_t3;
	regs->r_regs[21] = tf->tf_t2;
	regs->r_regs[22] = tf->tf_t1;
	regs->r_regs[23] = tf->tf_arg3;
	regs->r_regs[24] = tf->tf_arg2;
	regs->r_regs[25] = tf->tf_arg1;
	regs->r_regs[26] = tf->tf_arg0;
	regs->r_regs[27] = tf->tf_dp;
	regs->r_regs[28] = tf->tf_ret0;
	regs->r_regs[29] = tf->tf_ret1;
	regs->r_regs[30] = tf->tf_sp;
	regs->r_regs[31] = tf->tf_r31;

	regs->r_sar	 = tf->tf_sar;

	regs->r_pcsqh	 = tf->tf_iisq_head;
	regs->r_pcsqt	 = tf->tf_iisq_tail;
	regs->r_pcoqh	 = tf->tf_iioq_head;
	regs->r_pcoqt	 = tf->tf_iioq_tail;

	regs->r_sr0	 = tf->tf_sr0;
	regs->r_sr1	 = tf->tf_sr1;
	regs->r_sr2	 = tf->tf_sr2;
	regs->r_sr3	 = tf->tf_sr3;
	regs->r_sr4	 = tf->tf_sr4;
	regs->r_sr5	 = tf->tf_sr5;
	regs->r_sr6	 = tf->tf_sr6;
	regs->r_sr7	 = tf->tf_sr7;

	regs->r_cr26	 = 0;
	regs->r_cr27	 = tf->tf_cr27;

	return (0);
}

int
process_read_fpregs(struct proc *p, struct fpreg *fpregs)
{
	fpu_proc_save(p);

	bcopy(&p->p_addr->u_pcb.pcb_fpstate->hfp_regs, fpregs, 32 * 8);

	return (0);
}

#ifdef PTRACE

int
process_write_regs(struct proc *p, struct reg *regs)
{
	struct trapframe *tf = p->p_md.md_regs;

	tf->tf_r1   = regs->r_regs[ 1];
	tf->tf_rp   = regs->r_regs[ 2];
	tf->tf_r3   = regs->r_regs[ 3];
	tf->tf_r4   = regs->r_regs[ 4];
	tf->tf_r5   = regs->r_regs[ 5];
	tf->tf_r6   = regs->r_regs[ 6];
	tf->tf_r7   = regs->r_regs[ 7];
	tf->tf_r8   = regs->r_regs[ 8];
	tf->tf_r9   = regs->r_regs[ 9];
	tf->tf_r10  = regs->r_regs[10];
	tf->tf_r11  = regs->r_regs[11];
	tf->tf_r12  = regs->r_regs[12];
	tf->tf_r13  = regs->r_regs[13];
	tf->tf_r14  = regs->r_regs[14];
	tf->tf_r15  = regs->r_regs[15];
	tf->tf_r16  = regs->r_regs[16];
	tf->tf_r17  = regs->r_regs[17];
	tf->tf_r18  = regs->r_regs[18];
	tf->tf_t4   = regs->r_regs[19];
	tf->tf_t3   = regs->r_regs[20];
	tf->tf_t2   = regs->r_regs[21];
	tf->tf_t1   = regs->r_regs[22];
	tf->tf_arg3 = regs->r_regs[23];
	tf->tf_arg2 = regs->r_regs[24];
	tf->tf_arg1 = regs->r_regs[25];
	tf->tf_arg0 = regs->r_regs[26];
	tf->tf_dp   = regs->r_regs[27];
	tf->tf_ret0 = regs->r_regs[28];
	tf->tf_ret1 = regs->r_regs[29];
	tf->tf_sp   = regs->r_regs[30];
	tf->tf_r31  = regs->r_regs[31];

	tf->tf_sar  = regs->r_sar;

	tf->tf_iioq_head = regs->r_pcoqh | HPPA_PC_PRIV_USER;
	tf->tf_iioq_tail = regs->r_pcoqt | HPPA_PC_PRIV_USER;

	return (0);
}

int
process_write_fpregs(struct proc *p, struct fpreg *fpregs)
{
	fpu_proc_flush(p);

	bcopy(fpregs, &p->p_addr->u_pcb.pcb_fpstate->hfp_regs, 32 * 8);

	return (0);
}

/* process_sstep() is in trap.c */

int
process_set_pc(struct proc *p, caddr_t addr)
{
	p->p_md.md_regs->tf_iioq_head = (register_t)addr | HPPA_PC_PRIV_USER;
	p->p_md.md_regs->tf_iioq_tail = p->p_md.md_regs->tf_iioq_head + 4;

	return (0);
}

#endif	/* PTRACE */
@


1.20
log
@Ansify functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: process_machdep.c,v 1.18 2010/06/29 04:03:21 jsing Exp $	*/
d44 1
a44 1
	regs->r_regs[ 0] = tf->tf_sar;
d76 19
a94 2
	regs->r_pc	 = tf->tf_iioq_head;
	regs->r_npc	 = tf->tf_iioq_tail;
a115 1
	tf->tf_sar  = regs->r_regs[ 0];
d147 5
a151 2
	tf->tf_iioq_head = regs->r_pc | HPPA_PC_PRIV_USER;
	tf->tf_iioq_tail = regs->r_npc | HPPA_PC_PRIV_USER;
@


1.19
log
@Create a struct to store FP state and include a pointer to the CPU that
currently holds the FPU context for this process. This will be soon used
to implement FPU shootdowns on multiprocessor kernels.

ok kettenis@@
@
text
@a28 1

d40 1
a40 3
process_read_regs(p, regs)
	struct proc *p;
	struct reg *regs;
d83 1
a83 3
process_read_fpregs(p, fpregs)
	struct proc *p;
	struct fpreg *fpregs;
d95 1
a95 3
process_write_regs(p, regs)
	struct proc *p;
	struct reg *regs;
d138 1
a138 3
process_write_fpregs(p, fpregs)
	struct proc *p;
	struct fpreg *fpregs;
d150 1
a150 3
process_set_pc(p, addr)
	struct proc *p;
	caddr_t addr;
@


1.18
log
@Factor out code used to save and flushe process FPU context.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: process_machdep.c,v 1.17 2010/06/29 00:50:40 jsing Exp $	*/
d92 1
a92 1
	bcopy(p->p_addr->u_pcb.pcb_fpregs, fpregs, 32 * 8);
d151 1
a151 1
	bcopy(fpregs, p->p_addr->u_pcb.pcb_fpregs, 32 * 8);
@


1.17
log
@Store pointer to process FPU state in struct cpu_info.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: process_machdep.c,v 1.16 2010/03/30 14:57:02 kettenis Exp $	*/
d37 1
d90 1
a90 1
	extern u_int fpu_enable;
a91 5
	if (p->p_md.md_regs->tf_cr30 == curcpu()->ci_fpu_state) {
		mtctl(fpu_enable, CR_CCR);
		fpu_save(curcpu()->ci_fpu_state);
		mtctl(0, CR_CCR);
	}
d149 1
a149 4
	if (p->p_md.md_regs->tf_cr30 == curcpu()->ci_fpu_state) {
		fpu_exit();
		curcpu()->ci_fpu_state = 0;
	}
@


1.16
log
@Since we use a direct mapping for the area where we save a process' floating
point registers, we no longer need to flush/purge the cache.
@
text
@d1 1
a1 1
/*	$OpenBSD: process_machdep.c,v 1.15 2009/07/29 18:31:11 kettenis Exp $	*/
a88 1
	extern paddr_t fpu_curpcb;
d91 1
a91 1
	if (p->p_md.md_regs->tf_cr30 == fpu_curpcb) {
d93 1
a93 1
		fpu_save((vaddr_t)p->p_addr->u_pcb.pcb_fpregs);
d153 1
a153 3
	extern paddr_t fpu_curpcb;

	if (p->p_md.md_regs->tf_cr30 == fpu_curpcb) {
d155 1
a155 1
		fpu_curpcb = 0;
@


1.15
log
@Get rid of non-equivalent aliases of the pcb by moving the fpu state out
of the pcb and using the p_addr member of 'struct proc' to calculate the
address of the kernel stack when switching to virtual mode after taking a trap.
Remove the now unecessary cache flushes; they're actually harmful since they
create non-equivalent aliases.  This seems to fix the memory corruption we
have been observing from time to time.

This diff does not rename fpu_curpcb, which is now somewhat incorrectly named.
I hope to change things back again as soon as we are able to map the pcb 1:1.
@
text
@d1 1
a1 1
/*	$OpenBSD: process_machdep.c,v 1.14 2007/07/20 20:52:51 kettenis Exp $	*/
a97 1
	pdcache(HPPA_SID_KERNEL, (vaddr_t)p->p_addr->u_pcb.pcb_fpregs, 32 * 8);
@


1.14
log
@Use HPPA_PC_PRIV_USER instead of hardcoded 3.

requested by miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: process_machdep.c,v 1.13 2005/05/26 04:34:51 kettenis Exp $	*/
a162 1
	fdcache(HPPA_SID_KERNEL, (vaddr_t)p->p_addr->u_pcb.pcb_fpregs, 32 * 8);
@


1.13
log
@Implement PT_STEP for hppa.
ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: process_machdep.c,v 1.12 2005/05/10 11:32:51 mickey Exp $	*/
d37 1
d144 2
a145 2
	tf->tf_iioq_head = regs->r_pc | 3;
	tf->tf_iioq_tail = regs->r_npc | 3;
d175 2
a176 2
	p->p_md.md_regs->tf_iioq_tail = 4 +
	    (p->p_md.md_regs->tf_iioq_head = (register_t)addr | 3);
@


1.12
log
@after copyin/out fpu regs flush and purge as they gonna be accessed from phys later; from chs
@
text
@d1 1
a1 1
/*	$OpenBSD: process_machdep.c,v 1.11 2004/09/14 23:39:32 mickey Exp $	*/
d167 1
a167 10
int
process_sstep(p, sstep)
	struct proc *p;
	int sstep;
{
	if (sstep)
		return (EINVAL);

	return (0);
}
@


1.11
log
@store fpu version for later use. make sure to proper store/clear fpu state in fork/exec/exit/sendsig
@
text
@d1 1
a1 1
/*	$OpenBSD: process_machdep.c,v 1.10 2004/04/07 18:24:19 mickey Exp $	*/
d96 2
a97 1
	bcopy(p->p_addr->u_pcb.pcb_fpregs, fpregs, 32*8);
d162 1
@


1.10
log
@update copyright; miod@@ is fine w/ files where he holds it too
@
text
@d1 1
a1 1
/*	$OpenBSD: process_machdep.c,v 1.9 2003/01/16 00:33:14 mickey Exp $	*/
d89 1
d91 2
a92 1
	if (p->p_md.md_regs->tf_cr30 == fpu_curpcb)
d94 2
a154 2
	bcopy(fpregs, p->p_addr->u_pcb.pcb_fpregs, 32 * 8);

d156 1
a156 1
		mtctl(0, CR_CCR);
d159 2
@


1.9
log
@optimize accessing the md_regs through use of local vars
@
text
@d1 1
a1 1
/*	$OpenBSD: process_machdep.c,v 1.8 2003/01/15 22:07:06 mickey Exp $	*/
d4 1
a4 1
 * Copyright (c) 1999-2003 Michael Shalayeff
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Michael Shalayeff.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d19 8
a26 7
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF MIND,
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@


1.8
log
@a few missing bits (not all) and force pc into user mode when writing in, allows pmdb use
@
text
@d1 1
a1 1
/*	$OpenBSD: process_machdep.c,v 1.7 2002/11/08 22:30:48 mickey Exp $	*/
d47 36
a82 34
	regs->r_regs[ 0] = p->p_md.md_regs->tf_sar;
	regs->r_regs[ 1] = p->p_md.md_regs->tf_r1;
	regs->r_regs[ 2] = p->p_md.md_regs->tf_rp;
	regs->r_regs[ 3] = p->p_md.md_regs->tf_r3;
	regs->r_regs[ 4] = p->p_md.md_regs->tf_r4;
	regs->r_regs[ 5] = p->p_md.md_regs->tf_r5;
	regs->r_regs[ 6] = p->p_md.md_regs->tf_r6;
	regs->r_regs[ 7] = p->p_md.md_regs->tf_r7;
	regs->r_regs[ 8] = p->p_md.md_regs->tf_r8;
	regs->r_regs[ 9] = p->p_md.md_regs->tf_r9;
	regs->r_regs[10] = p->p_md.md_regs->tf_r10;
	regs->r_regs[11] = p->p_md.md_regs->tf_r11;
	regs->r_regs[12] = p->p_md.md_regs->tf_r12;
	regs->r_regs[13] = p->p_md.md_regs->tf_r13;
	regs->r_regs[14] = p->p_md.md_regs->tf_r14;
	regs->r_regs[15] = p->p_md.md_regs->tf_r15;
	regs->r_regs[16] = p->p_md.md_regs->tf_r16;
	regs->r_regs[17] = p->p_md.md_regs->tf_r17;
	regs->r_regs[18] = p->p_md.md_regs->tf_r18;
	regs->r_regs[19] = p->p_md.md_regs->tf_t4;
	regs->r_regs[20] = p->p_md.md_regs->tf_t3;
	regs->r_regs[21] = p->p_md.md_regs->tf_t2;
	regs->r_regs[22] = p->p_md.md_regs->tf_t1;
	regs->r_regs[23] = p->p_md.md_regs->tf_arg3;
	regs->r_regs[24] = p->p_md.md_regs->tf_arg2;
	regs->r_regs[25] = p->p_md.md_regs->tf_arg1;
	regs->r_regs[26] = p->p_md.md_regs->tf_arg0;
	regs->r_regs[27] = p->p_md.md_regs->tf_dp;
	regs->r_regs[28] = p->p_md.md_regs->tf_ret0;
	regs->r_regs[29] = p->p_md.md_regs->tf_ret1;
	regs->r_regs[30] = p->p_md.md_regs->tf_sp;
	regs->r_regs[31] = p->p_md.md_regs->tf_r31;
	regs->r_pc	 = p->p_md.md_regs->tf_iioq_head;
	regs->r_npc	 = p->p_md.md_regs->tf_iioq_tail;
d108 36
a143 34
	p->p_md.md_regs->tf_sar  = regs->r_regs[ 0];
	p->p_md.md_regs->tf_r1   = regs->r_regs[ 1];
	p->p_md.md_regs->tf_rp   = regs->r_regs[ 2];
	p->p_md.md_regs->tf_r3   = regs->r_regs[ 3];
	p->p_md.md_regs->tf_r4   = regs->r_regs[ 4];
	p->p_md.md_regs->tf_r5   = regs->r_regs[ 5];
	p->p_md.md_regs->tf_r6   = regs->r_regs[ 6];
	p->p_md.md_regs->tf_r7   = regs->r_regs[ 7];
	p->p_md.md_regs->tf_r8   = regs->r_regs[ 8];
	p->p_md.md_regs->tf_r9   = regs->r_regs[ 9];
	p->p_md.md_regs->tf_r10  = regs->r_regs[10];
	p->p_md.md_regs->tf_r11  = regs->r_regs[11];
	p->p_md.md_regs->tf_r12  = regs->r_regs[12];
	p->p_md.md_regs->tf_r13  = regs->r_regs[13];
	p->p_md.md_regs->tf_r14  = regs->r_regs[14];
	p->p_md.md_regs->tf_r15  = regs->r_regs[15];
	p->p_md.md_regs->tf_r16  = regs->r_regs[16];
	p->p_md.md_regs->tf_r17  = regs->r_regs[17];
	p->p_md.md_regs->tf_r18  = regs->r_regs[18];
	p->p_md.md_regs->tf_t4   = regs->r_regs[19];
	p->p_md.md_regs->tf_t3   = regs->r_regs[20];
	p->p_md.md_regs->tf_t2   = regs->r_regs[21];
	p->p_md.md_regs->tf_t1   = regs->r_regs[22];
	p->p_md.md_regs->tf_arg3 = regs->r_regs[23];
	p->p_md.md_regs->tf_arg2 = regs->r_regs[24];
	p->p_md.md_regs->tf_arg1 = regs->r_regs[25];
	p->p_md.md_regs->tf_arg0 = regs->r_regs[26];
	p->p_md.md_regs->tf_dp   = regs->r_regs[27];
	p->p_md.md_regs->tf_ret0 = regs->r_regs[28];
	p->p_md.md_regs->tf_ret1 = regs->r_regs[29];
	p->p_md.md_regs->tf_sp   = regs->r_regs[30];
	p->p_md.md_regs->tf_r31  = regs->r_regs[31];
	p->p_md.md_regs->tf_iioq_head = regs->r_pc | 3;
	p->p_md.md_regs->tf_iioq_tail = regs->r_npc | 3;
@


1.7
log
@absolutely no need to save the fpu state before rewriting the fpu regs, just reset the curpcb and force a reload
@
text
@d1 1
a1 1
/*	$OpenBSD: process_machdep.c,v 1.6 2002/09/20 19:06:26 mickey Exp $	*/
d4 1
a4 1
 * Copyright (c) 1999-2002 Michael Shalayeff
d82 1
a82 1
	return 0;
d96 1
a96 1
	return 0;
d138 2
a139 2
	p->p_md.md_regs->tf_iioq_head = regs->r_pc;
	p->p_md.md_regs->tf_iioq_tail = regs->r_npc;
d141 1
a141 1
	return 0;
d158 1
a158 1
	return 0;
d166 4
a169 2
	/* TODO */
	return EINVAL;
d177 4
a180 4
	if (!USERMODE(addr))	/* XXX */
		return EINVAL;
	p->p_md.md_regs->tf_iioq_head = (register_t)addr;
	return 0;
@


1.6
log
@flush cpu state on read/write fpregs, force reload on write
@
text
@d1 1
a1 1
/*	$OpenBSD: process_machdep.c,v 1.5 2002/03/15 19:02:54 mickey Exp $	*/
a150 2
	if (p->p_md.md_regs->tf_cr30 == fpu_curpcb)
		fpu_save((vaddr_t)p->p_addr->u_pcb.pcb_fpregs);
@


1.5
log
@regs get/set for pmdb
@
text
@d1 1
a1 1
/*	$OpenBSD: process_machdep.c,v 1.4 2002/03/14 00:42:24 miod Exp $	*/
d40 2
d90 6
a95 1
	bcopy (p->p_addr->u_pcb.pcb_fpregs, fpregs, sizeof(*fpregs));
d149 11
a159 1
	bcopy (fpregs, p->p_addr->u_pcb.pcb_fpregs, sizeof(*fpregs));
@


1.4
log
@Turn the ptrace(2) syscall into a kernel compile option, option PTRACE in
your kernel configuration file.
By default, GENERIC will enable this.

When PTRACE is not enabled, several ptrace-like features of the procfs
filesystem will be disabled as well (namely, the ability to read and write
any process' registers, as well as attching, single stepping and detaching
to/from processes).

This should help paranoid people build better sandboxens, and us to build
smaller ramdisks.
@
text
@d1 1
a1 1
/*	$OpenBSD: process_machdep.c,v 1.3 1999/06/18 05:19:52 mickey Exp $	*/
d4 1
a4 1
 * Copyright (c) 1999 Michael Shalayeff
d26 2
a27 2
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
d45 35
a79 2
	bcopy (p->p_md.md_regs, regs, sizeof(*regs));
	regs->r_regs[0] = 0;
d99 35
a133 1
	bcopy (&regs[1], &p->p_md.md_regs->tf_r1, sizeof(*regs) - sizeof(*regs));
@


1.3
log
@do not include fpu regs into trapframe, according to the
lazy fpu context switching it could be well saved into pcb.
this brings trapframe to 256 bytes (including 5 spare words).
adjust all the code to deal w/ moved fpu regs save area.
@
text
@d1 1
a1 1
/*	$OpenBSD: process_machdep.c,v 1.2 1999/04/20 20:46:11 mickey Exp $	*/
d51 1
a51 1
process_write_regs(p, regs)
d53 1
a53 1
	struct reg *regs;
d55 1
a55 1
	bcopy (&regs[1], &p->p_md.md_regs->tf_r1, sizeof(*regs) - sizeof(*regs));
d59 2
d62 1
a62 1
process_read_fpregs(p, fpregs)
d64 1
a64 1
	struct fpreg *fpregs;
d66 1
a66 1
	bcopy (p->p_addr->u_pcb.pcb_fpregs, fpregs, sizeof(*fpregs));
d99 1
@


1.3.14.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: process_machdep.c,v 1.3 1999/06/18 05:19:52 mickey Exp $	*/
d4 1
a4 1
 * Copyright (c) 1999-2002 Michael Shalayeff
d26 2
a27 2
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF MIND,
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
d45 2
a46 35
	regs->r_regs[ 0] = p->p_md.md_regs->tf_sar;
	regs->r_regs[ 1] = p->p_md.md_regs->tf_r1;
	regs->r_regs[ 2] = p->p_md.md_regs->tf_rp;
	regs->r_regs[ 3] = p->p_md.md_regs->tf_r3;
	regs->r_regs[ 4] = p->p_md.md_regs->tf_r4;
	regs->r_regs[ 5] = p->p_md.md_regs->tf_r5;
	regs->r_regs[ 6] = p->p_md.md_regs->tf_r6;
	regs->r_regs[ 7] = p->p_md.md_regs->tf_r7;
	regs->r_regs[ 8] = p->p_md.md_regs->tf_r8;
	regs->r_regs[ 9] = p->p_md.md_regs->tf_r9;
	regs->r_regs[10] = p->p_md.md_regs->tf_r10;
	regs->r_regs[11] = p->p_md.md_regs->tf_r11;
	regs->r_regs[12] = p->p_md.md_regs->tf_r12;
	regs->r_regs[13] = p->p_md.md_regs->tf_r13;
	regs->r_regs[14] = p->p_md.md_regs->tf_r14;
	regs->r_regs[15] = p->p_md.md_regs->tf_r15;
	regs->r_regs[16] = p->p_md.md_regs->tf_r16;
	regs->r_regs[17] = p->p_md.md_regs->tf_r17;
	regs->r_regs[18] = p->p_md.md_regs->tf_r18;
	regs->r_regs[19] = p->p_md.md_regs->tf_t4;
	regs->r_regs[20] = p->p_md.md_regs->tf_t3;
	regs->r_regs[21] = p->p_md.md_regs->tf_t2;
	regs->r_regs[22] = p->p_md.md_regs->tf_t1;
	regs->r_regs[23] = p->p_md.md_regs->tf_arg3;
	regs->r_regs[24] = p->p_md.md_regs->tf_arg2;
	regs->r_regs[25] = p->p_md.md_regs->tf_arg1;
	regs->r_regs[26] = p->p_md.md_regs->tf_arg0;
	regs->r_regs[27] = p->p_md.md_regs->tf_dp;
	regs->r_regs[28] = p->p_md.md_regs->tf_ret0;
	regs->r_regs[29] = p->p_md.md_regs->tf_ret1;
	regs->r_regs[30] = p->p_md.md_regs->tf_sp;
	regs->r_regs[31] = p->p_md.md_regs->tf_r31;
	regs->r_pc	 = p->p_md.md_regs->tf_iioq_head;
	regs->r_npc	 = p->p_md.md_regs->tf_iioq_tail;

d51 1
a51 1
process_read_fpregs(p, fpregs)
d53 1
a53 1
	struct fpreg *fpregs;
d55 1
a55 1
	bcopy (p->p_addr->u_pcb.pcb_fpregs, fpregs, sizeof(*fpregs));
a58 2
#ifdef PTRACE

d60 1
a60 1
process_write_regs(p, regs)
d62 1
a62 1
	struct reg *regs;
d64 1
a64 35
	p->p_md.md_regs->tf_sar  = regs->r_regs[ 0];
	p->p_md.md_regs->tf_r1   = regs->r_regs[ 1];
	p->p_md.md_regs->tf_rp   = regs->r_regs[ 2];
	p->p_md.md_regs->tf_r3   = regs->r_regs[ 3];
	p->p_md.md_regs->tf_r4   = regs->r_regs[ 4];
	p->p_md.md_regs->tf_r5   = regs->r_regs[ 5];
	p->p_md.md_regs->tf_r6   = regs->r_regs[ 6];
	p->p_md.md_regs->tf_r7   = regs->r_regs[ 7];
	p->p_md.md_regs->tf_r8   = regs->r_regs[ 8];
	p->p_md.md_regs->tf_r9   = regs->r_regs[ 9];
	p->p_md.md_regs->tf_r10  = regs->r_regs[10];
	p->p_md.md_regs->tf_r11  = regs->r_regs[11];
	p->p_md.md_regs->tf_r12  = regs->r_regs[12];
	p->p_md.md_regs->tf_r13  = regs->r_regs[13];
	p->p_md.md_regs->tf_r14  = regs->r_regs[14];
	p->p_md.md_regs->tf_r15  = regs->r_regs[15];
	p->p_md.md_regs->tf_r16  = regs->r_regs[16];
	p->p_md.md_regs->tf_r17  = regs->r_regs[17];
	p->p_md.md_regs->tf_r18  = regs->r_regs[18];
	p->p_md.md_regs->tf_t4   = regs->r_regs[19];
	p->p_md.md_regs->tf_t3   = regs->r_regs[20];
	p->p_md.md_regs->tf_t2   = regs->r_regs[21];
	p->p_md.md_regs->tf_t1   = regs->r_regs[22];
	p->p_md.md_regs->tf_arg3 = regs->r_regs[23];
	p->p_md.md_regs->tf_arg2 = regs->r_regs[24];
	p->p_md.md_regs->tf_arg1 = regs->r_regs[25];
	p->p_md.md_regs->tf_arg0 = regs->r_regs[26];
	p->p_md.md_regs->tf_dp   = regs->r_regs[27];
	p->p_md.md_regs->tf_ret0 = regs->r_regs[28];
	p->p_md.md_regs->tf_ret1 = regs->r_regs[29];
	p->p_md.md_regs->tf_sp   = regs->r_regs[30];
	p->p_md.md_regs->tf_r31  = regs->r_regs[31];
	p->p_md.md_regs->tf_iioq_head = regs->r_pc;
	p->p_md.md_regs->tf_iioq_tail = regs->r_npc;

a96 1
#endif	/* PTRACE */
@


1.3.14.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: process_machdep.c,v 1.3.14.1 2002/06/11 03:35:37 art Exp $	*/
a39 2
#include <machine/cpufunc.h>

d88 1
a88 6
	extern paddr_t fpu_curpcb;

	if (p->p_md.md_regs->tf_cr30 == fpu_curpcb)
		fpu_save((vaddr_t)p->p_addr->u_pcb.pcb_fpregs);
	bcopy(p->p_addr->u_pcb.pcb_fpregs, fpregs, 32*8);

d142 1
a142 11
	extern paddr_t fpu_curpcb;

	if (p->p_md.md_regs->tf_cr30 == fpu_curpcb)
		fpu_save((vaddr_t)p->p_addr->u_pcb.pcb_fpregs);
	bcopy(fpregs, p->p_addr->u_pcb.pcb_fpregs, 32 * 8);

	if (p->p_md.md_regs->tf_cr30 == fpu_curpcb) {
		mtctl(0, CR_CCR);
		fpu_curpcb = 0;
	}

@


1.3.14.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d4 1
a4 1
 * Copyright (c) 1999-2003 Michael Shalayeff
d47 34
a80 1
	struct trapframe *tf = p->p_md.md_regs;
d82 1
a82 36
	regs->r_regs[ 0] = tf->tf_sar;
	regs->r_regs[ 1] = tf->tf_r1;
	regs->r_regs[ 2] = tf->tf_rp;
	regs->r_regs[ 3] = tf->tf_r3;
	regs->r_regs[ 4] = tf->tf_r4;
	regs->r_regs[ 5] = tf->tf_r5;
	regs->r_regs[ 6] = tf->tf_r6;
	regs->r_regs[ 7] = tf->tf_r7;
	regs->r_regs[ 8] = tf->tf_r8;
	regs->r_regs[ 9] = tf->tf_r9;
	regs->r_regs[10] = tf->tf_r10;
	regs->r_regs[11] = tf->tf_r11;
	regs->r_regs[12] = tf->tf_r12;
	regs->r_regs[13] = tf->tf_r13;
	regs->r_regs[14] = tf->tf_r14;
	regs->r_regs[15] = tf->tf_r15;
	regs->r_regs[16] = tf->tf_r16;
	regs->r_regs[17] = tf->tf_r17;
	regs->r_regs[18] = tf->tf_r18;
	regs->r_regs[19] = tf->tf_t4;
	regs->r_regs[20] = tf->tf_t3;
	regs->r_regs[21] = tf->tf_t2;
	regs->r_regs[22] = tf->tf_t1;
	regs->r_regs[23] = tf->tf_arg3;
	regs->r_regs[24] = tf->tf_arg2;
	regs->r_regs[25] = tf->tf_arg1;
	regs->r_regs[26] = tf->tf_arg0;
	regs->r_regs[27] = tf->tf_dp;
	regs->r_regs[28] = tf->tf_ret0;
	regs->r_regs[29] = tf->tf_ret1;
	regs->r_regs[30] = tf->tf_sp;
	regs->r_regs[31] = tf->tf_r31;
	regs->r_pc	 = tf->tf_iioq_head;
	regs->r_npc	 = tf->tf_iioq_tail;

	return (0);
d96 1
a96 1
	return (0);
d106 34
a139 36
	struct trapframe *tf = p->p_md.md_regs;

	tf->tf_sar  = regs->r_regs[ 0];
	tf->tf_r1   = regs->r_regs[ 1];
	tf->tf_rp   = regs->r_regs[ 2];
	tf->tf_r3   = regs->r_regs[ 3];
	tf->tf_r4   = regs->r_regs[ 4];
	tf->tf_r5   = regs->r_regs[ 5];
	tf->tf_r6   = regs->r_regs[ 6];
	tf->tf_r7   = regs->r_regs[ 7];
	tf->tf_r8   = regs->r_regs[ 8];
	tf->tf_r9   = regs->r_regs[ 9];
	tf->tf_r10  = regs->r_regs[10];
	tf->tf_r11  = regs->r_regs[11];
	tf->tf_r12  = regs->r_regs[12];
	tf->tf_r13  = regs->r_regs[13];
	tf->tf_r14  = regs->r_regs[14];
	tf->tf_r15  = regs->r_regs[15];
	tf->tf_r16  = regs->r_regs[16];
	tf->tf_r17  = regs->r_regs[17];
	tf->tf_r18  = regs->r_regs[18];
	tf->tf_t4   = regs->r_regs[19];
	tf->tf_t3   = regs->r_regs[20];
	tf->tf_t2   = regs->r_regs[21];
	tf->tf_t1   = regs->r_regs[22];
	tf->tf_arg3 = regs->r_regs[23];
	tf->tf_arg2 = regs->r_regs[24];
	tf->tf_arg1 = regs->r_regs[25];
	tf->tf_arg0 = regs->r_regs[26];
	tf->tf_dp   = regs->r_regs[27];
	tf->tf_ret0 = regs->r_regs[28];
	tf->tf_ret1 = regs->r_regs[29];
	tf->tf_sp   = regs->r_regs[30];
	tf->tf_r31  = regs->r_regs[31];
	tf->tf_iioq_head = regs->r_pc | 3;
	tf->tf_iioq_tail = regs->r_npc | 3;
d141 1
a141 1
	return (0);
d151 2
d160 1
a160 1
	return (0);
d168 2
a169 4
	if (sstep)
		return (EINVAL);

	return (0);
d177 4
a180 4
	p->p_md.md_regs->tf_iioq_tail = 4 +
	    (p->p_md.md_regs->tf_iioq_head = (register_t)addr | 3);

	return (0);
@


1.3.4.1
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d4 1
a4 1
 * Copyright (c) 1999-2002 Michael Shalayeff
d26 2
a27 2
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF MIND,
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
d45 2
a46 35
	regs->r_regs[ 0] = p->p_md.md_regs->tf_sar;
	regs->r_regs[ 1] = p->p_md.md_regs->tf_r1;
	regs->r_regs[ 2] = p->p_md.md_regs->tf_rp;
	regs->r_regs[ 3] = p->p_md.md_regs->tf_r3;
	regs->r_regs[ 4] = p->p_md.md_regs->tf_r4;
	regs->r_regs[ 5] = p->p_md.md_regs->tf_r5;
	regs->r_regs[ 6] = p->p_md.md_regs->tf_r6;
	regs->r_regs[ 7] = p->p_md.md_regs->tf_r7;
	regs->r_regs[ 8] = p->p_md.md_regs->tf_r8;
	regs->r_regs[ 9] = p->p_md.md_regs->tf_r9;
	regs->r_regs[10] = p->p_md.md_regs->tf_r10;
	regs->r_regs[11] = p->p_md.md_regs->tf_r11;
	regs->r_regs[12] = p->p_md.md_regs->tf_r12;
	regs->r_regs[13] = p->p_md.md_regs->tf_r13;
	regs->r_regs[14] = p->p_md.md_regs->tf_r14;
	regs->r_regs[15] = p->p_md.md_regs->tf_r15;
	regs->r_regs[16] = p->p_md.md_regs->tf_r16;
	regs->r_regs[17] = p->p_md.md_regs->tf_r17;
	regs->r_regs[18] = p->p_md.md_regs->tf_r18;
	regs->r_regs[19] = p->p_md.md_regs->tf_t4;
	regs->r_regs[20] = p->p_md.md_regs->tf_t3;
	regs->r_regs[21] = p->p_md.md_regs->tf_t2;
	regs->r_regs[22] = p->p_md.md_regs->tf_t1;
	regs->r_regs[23] = p->p_md.md_regs->tf_arg3;
	regs->r_regs[24] = p->p_md.md_regs->tf_arg2;
	regs->r_regs[25] = p->p_md.md_regs->tf_arg1;
	regs->r_regs[26] = p->p_md.md_regs->tf_arg0;
	regs->r_regs[27] = p->p_md.md_regs->tf_dp;
	regs->r_regs[28] = p->p_md.md_regs->tf_ret0;
	regs->r_regs[29] = p->p_md.md_regs->tf_ret1;
	regs->r_regs[30] = p->p_md.md_regs->tf_sp;
	regs->r_regs[31] = p->p_md.md_regs->tf_r31;
	regs->r_pc	 = p->p_md.md_regs->tf_iioq_head;
	regs->r_npc	 = p->p_md.md_regs->tf_iioq_tail;

d51 1
a51 1
process_read_fpregs(p, fpregs)
d53 1
a53 1
	struct fpreg *fpregs;
d55 1
a55 1
	bcopy (p->p_addr->u_pcb.pcb_fpregs, fpregs, sizeof(*fpregs));
a58 2
#ifdef PTRACE

d60 1
a60 1
process_write_regs(p, regs)
d62 1
a62 1
	struct reg *regs;
d64 1
a64 35
	p->p_md.md_regs->tf_sar  = regs->r_regs[ 0];
	p->p_md.md_regs->tf_r1   = regs->r_regs[ 1];
	p->p_md.md_regs->tf_rp   = regs->r_regs[ 2];
	p->p_md.md_regs->tf_r3   = regs->r_regs[ 3];
	p->p_md.md_regs->tf_r4   = regs->r_regs[ 4];
	p->p_md.md_regs->tf_r5   = regs->r_regs[ 5];
	p->p_md.md_regs->tf_r6   = regs->r_regs[ 6];
	p->p_md.md_regs->tf_r7   = regs->r_regs[ 7];
	p->p_md.md_regs->tf_r8   = regs->r_regs[ 8];
	p->p_md.md_regs->tf_r9   = regs->r_regs[ 9];
	p->p_md.md_regs->tf_r10  = regs->r_regs[10];
	p->p_md.md_regs->tf_r11  = regs->r_regs[11];
	p->p_md.md_regs->tf_r12  = regs->r_regs[12];
	p->p_md.md_regs->tf_r13  = regs->r_regs[13];
	p->p_md.md_regs->tf_r14  = regs->r_regs[14];
	p->p_md.md_regs->tf_r15  = regs->r_regs[15];
	p->p_md.md_regs->tf_r16  = regs->r_regs[16];
	p->p_md.md_regs->tf_r17  = regs->r_regs[17];
	p->p_md.md_regs->tf_r18  = regs->r_regs[18];
	p->p_md.md_regs->tf_t4   = regs->r_regs[19];
	p->p_md.md_regs->tf_t3   = regs->r_regs[20];
	p->p_md.md_regs->tf_t2   = regs->r_regs[21];
	p->p_md.md_regs->tf_t1   = regs->r_regs[22];
	p->p_md.md_regs->tf_arg3 = regs->r_regs[23];
	p->p_md.md_regs->tf_arg2 = regs->r_regs[24];
	p->p_md.md_regs->tf_arg1 = regs->r_regs[25];
	p->p_md.md_regs->tf_arg0 = regs->r_regs[26];
	p->p_md.md_regs->tf_dp   = regs->r_regs[27];
	p->p_md.md_regs->tf_ret0 = regs->r_regs[28];
	p->p_md.md_regs->tf_ret1 = regs->r_regs[29];
	p->p_md.md_regs->tf_sp   = regs->r_regs[30];
	p->p_md.md_regs->tf_r31  = regs->r_regs[31];
	p->p_md.md_regs->tf_iioq_head = regs->r_pc;
	p->p_md.md_regs->tf_iioq_tail = regs->r_npc;

a96 1
#endif	/* PTRACE */
@


1.3.4.2
log
@Sync the SMP branch with 3.3
@
text
@d4 1
a4 1
 * Copyright (c) 1999-2003 Michael Shalayeff
a39 2
#include <machine/cpufunc.h>

d45 34
a78 36
	struct trapframe *tf = p->p_md.md_regs;

	regs->r_regs[ 0] = tf->tf_sar;
	regs->r_regs[ 1] = tf->tf_r1;
	regs->r_regs[ 2] = tf->tf_rp;
	regs->r_regs[ 3] = tf->tf_r3;
	regs->r_regs[ 4] = tf->tf_r4;
	regs->r_regs[ 5] = tf->tf_r5;
	regs->r_regs[ 6] = tf->tf_r6;
	regs->r_regs[ 7] = tf->tf_r7;
	regs->r_regs[ 8] = tf->tf_r8;
	regs->r_regs[ 9] = tf->tf_r9;
	regs->r_regs[10] = tf->tf_r10;
	regs->r_regs[11] = tf->tf_r11;
	regs->r_regs[12] = tf->tf_r12;
	regs->r_regs[13] = tf->tf_r13;
	regs->r_regs[14] = tf->tf_r14;
	regs->r_regs[15] = tf->tf_r15;
	regs->r_regs[16] = tf->tf_r16;
	regs->r_regs[17] = tf->tf_r17;
	regs->r_regs[18] = tf->tf_r18;
	regs->r_regs[19] = tf->tf_t4;
	regs->r_regs[20] = tf->tf_t3;
	regs->r_regs[21] = tf->tf_t2;
	regs->r_regs[22] = tf->tf_t1;
	regs->r_regs[23] = tf->tf_arg3;
	regs->r_regs[24] = tf->tf_arg2;
	regs->r_regs[25] = tf->tf_arg1;
	regs->r_regs[26] = tf->tf_arg0;
	regs->r_regs[27] = tf->tf_dp;
	regs->r_regs[28] = tf->tf_ret0;
	regs->r_regs[29] = tf->tf_ret1;
	regs->r_regs[30] = tf->tf_sp;
	regs->r_regs[31] = tf->tf_r31;
	regs->r_pc	 = tf->tf_iioq_head;
	regs->r_npc	 = tf->tf_iioq_tail;
d80 1
a80 1
	return (0);
d88 2
a89 7
	extern paddr_t fpu_curpcb;

	if (p->p_md.md_regs->tf_cr30 == fpu_curpcb)
		fpu_save((vaddr_t)p->p_addr->u_pcb.pcb_fpregs);
	bcopy(p->p_addr->u_pcb.pcb_fpregs, fpregs, 32*8);

	return (0);
d99 34
a132 36
	struct trapframe *tf = p->p_md.md_regs;

	tf->tf_sar  = regs->r_regs[ 0];
	tf->tf_r1   = regs->r_regs[ 1];
	tf->tf_rp   = regs->r_regs[ 2];
	tf->tf_r3   = regs->r_regs[ 3];
	tf->tf_r4   = regs->r_regs[ 4];
	tf->tf_r5   = regs->r_regs[ 5];
	tf->tf_r6   = regs->r_regs[ 6];
	tf->tf_r7   = regs->r_regs[ 7];
	tf->tf_r8   = regs->r_regs[ 8];
	tf->tf_r9   = regs->r_regs[ 9];
	tf->tf_r10  = regs->r_regs[10];
	tf->tf_r11  = regs->r_regs[11];
	tf->tf_r12  = regs->r_regs[12];
	tf->tf_r13  = regs->r_regs[13];
	tf->tf_r14  = regs->r_regs[14];
	tf->tf_r15  = regs->r_regs[15];
	tf->tf_r16  = regs->r_regs[16];
	tf->tf_r17  = regs->r_regs[17];
	tf->tf_r18  = regs->r_regs[18];
	tf->tf_t4   = regs->r_regs[19];
	tf->tf_t3   = regs->r_regs[20];
	tf->tf_t2   = regs->r_regs[21];
	tf->tf_t1   = regs->r_regs[22];
	tf->tf_arg3 = regs->r_regs[23];
	tf->tf_arg2 = regs->r_regs[24];
	tf->tf_arg1 = regs->r_regs[25];
	tf->tf_arg0 = regs->r_regs[26];
	tf->tf_dp   = regs->r_regs[27];
	tf->tf_ret0 = regs->r_regs[28];
	tf->tf_ret1 = regs->r_regs[29];
	tf->tf_sp   = regs->r_regs[30];
	tf->tf_r31  = regs->r_regs[31];
	tf->tf_iioq_head = regs->r_pc | 3;
	tf->tf_iioq_tail = regs->r_npc | 3;
d134 1
a134 1
	return (0);
d142 2
a143 10
	extern paddr_t fpu_curpcb;

	bcopy(fpregs, p->p_addr->u_pcb.pcb_fpregs, 32 * 8);

	if (p->p_md.md_regs->tf_cr30 == fpu_curpcb) {
		mtctl(0, CR_CCR);
		fpu_curpcb = 0;
	}

	return (0);
d151 2
a152 4
	if (sstep)
		return (EINVAL);

	return (0);
d160 4
a163 4
	p->p_md.md_regs->tf_iioq_tail = 4 +
	    (p->p_md.md_regs->tf_iioq_head = (register_t)addr | 3);

	return (0);
@


1.3.4.3
log
@Merge with the trunk
@
text
@d4 1
a4 1
 * Copyright (c) 1999-2004 Michael Shalayeff
d15 5
d24 7
a30 8
 * IN NO EVENT SHALL THE AUTHOR OR HIS RELATIVES BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
@


1.2
log
@flesh out, who cares about single-step anyway
@
text
@d1 1
a1 1
/*	$OpenBSD: process_machdep.c,v 1.1 1998/12/29 18:06:48 mickey Exp $	*/
d38 1
d64 1
a64 1
	bcopy (p->p_md.md_regs->tf_fpregs, fpregs, sizeof(*fpregs));
d73 1
a73 1
	bcopy (fpregs, p->p_md.md_regs->tf_fpregs, sizeof(*fpregs));
@


1.1
log
@some *machdep stuff
@
text
@d1 32
a32 1
/*	$OpenBSD$	*/
d35 1
d44 3
a46 1
	return EINVAL;
d54 2
a55 1
	return EINVAL;
d63 2
a64 1
	return EINVAL;
d72 2
a73 1
	return EINVAL;
d81 1
d90 4
a93 1
	return EINVAL;
d95 1
@

