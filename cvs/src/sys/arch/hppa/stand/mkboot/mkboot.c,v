head	1.20;
access;
symbols
	OPENBSD_6_1:1.20.0.12
	OPENBSD_6_1_BASE:1.20
	OPENBSD_6_0:1.20.0.8
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.20.0.4
	OPENBSD_5_9_BASE:1.20
	OPENBSD_5_8:1.20.0.6
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.20.0.2
	OPENBSD_5_7_BASE:1.20
	OPENBSD_5_6:1.18.0.6
	OPENBSD_5_6_BASE:1.18
	OPENBSD_5_5:1.18.0.4
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.16.0.16
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.16.0.14
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.12
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.10
	OPENBSD_5_0:1.16.0.8
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.16.0.6
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.16.0.4
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.16.0.2
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.15.0.22
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.18
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.16
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.15.0.14
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.15.0.12
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.15.0.10
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.15.0.8
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.15.0.6
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.15.0.4
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.15.0.2
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.14.0.6
	OPENBSD_3_6_BASE:1.14
	SMP_SYNC_A:1.14
	SMP_SYNC_B:1.14
	OPENBSD_3_5:1.14.0.4
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.14.0.2
	OPENBSD_3_4_BASE:1.14
	UBC_SYNC_A:1.12
	OPENBSD_3_3:1.11.0.4
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.2
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	UBC_SYNC_B:1.11
	UBC:1.9.0.4
	UBC_BASE:1.9
	OPENBSD_3_0:1.9.0.2
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9:1.8.0.4
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_8:1.8.0.2
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.7.0.6
	OPENBSD_2_7_BASE:1.7
	SMP:1.7.0.4
	SMP_BASE:1.7
	kame_19991208:1.7
	OPENBSD_2_6:1.7.0.2
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.5.0.4
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.2
	OPENBSD_2_4_BASE:1.5
	mickey-boot:1.1.1.1
	mickey:1.1.1;
locks; strict;
comment	@ * @;


1.20
date	2014.10.26.10.32.30;	author miod;	state Exp;
branches;
next	1.19;
commitid	DS8qg0KthyPhQQD3;

1.19
date	2014.09.24.00.13.13;	author doug;	state Exp;
branches;
next	1.18;
commitid	vbzyzJXrp3exZiEy;

1.18
date	2014.01.22.09.18.04;	author jsing;	state Exp;
branches;
next	1.17;

1.17
date	2013.10.17.08.02.15;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2009.10.27.23.59.34;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2004.11.22.18.41.42;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	2003.08.11.06.51.45;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.02.23.27.47;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2003.05.11.19.41.09;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2002.06.11.05.18.22;	author jsyn;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.14.01.26.32;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.05.17.00.57.55;	author pvalchev;	state Exp;
branches
	1.9.4.1;
next	1.8;

1.8
date	2000.06.30.16.00.11;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	99.05.23.17.19.22;	author aaron;	state Exp;
branches
	1.7.4.1
	1.7.6.1;
next	1.6;

1.6
date	99.05.03.22.47.05;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	98.09.29.07.12.58;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	98.08.29.01.46.53;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	98.07.27.15.41.08;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	98.07.13.02.11.29;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	98.06.23.18.46.43;	author mickey;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.06.23.18.46.43;	author mickey;	state Exp;
branches;
next	;

1.7.4.1
date	2001.04.18.16.06.58;	author niklas;	state Exp;
branches;
next	1.7.4.2;

1.7.4.2
date	2001.07.04.10.16.15;	author niklas;	state Exp;
branches;
next	1.7.4.3;

1.7.4.3
date	2002.03.28.10.31.03;	author niklas;	state Exp;
branches;
next	1.7.4.4;

1.7.4.4
date	2003.03.27.23.26.54;	author niklas;	state Exp;
branches;
next	1.7.4.5;

1.7.4.5
date	2003.05.13.19.41.05;	author ho;	state Exp;
branches;
next	1.7.4.6;

1.7.4.6
date	2003.06.07.11.11.36;	author ho;	state Exp;
branches;
next	1.7.4.7;

1.7.4.7
date	2004.02.19.10.48.41;	author niklas;	state Exp;
branches;
next	;

1.7.6.1
date	2000.10.06.21.16.11;	author jason;	state Exp;
branches;
next	;

1.9.4.1
date	2002.06.11.03.35.38;	author art;	state Exp;
branches;
next	1.9.4.2;

1.9.4.2
date	2002.10.29.00.28.03;	author art;	state Exp;
branches;
next	1.9.4.3;

1.9.4.3
date	2003.05.19.21.43.13;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.20
log
@Don't forget to free() the malloc()s.
@
text
@/*	$OpenBSD: mkboot.c,v 1.19 2014/09/24 00:13:13 doug Exp $	*/

/*
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)mkboot.c	8.1 (Berkeley) 7/15/93
 */

#include <sys/param.h>
#include <sys/exec.h>
#include <sys/exec_elf.h>
#include <sys/file.h>
#include <sys/stat.h>

#include <ctype.h>
#include <err.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

#ifndef hppa
/* hack for cross compile XXX */
#include "../../include/disklabel.h"
#else
#include <sys/disklabel.h>
#endif

int putfile(char *, int);
void __dead usage(void);
void bcddate(char *, char *);
char *lifname(char *);
int cksum(int, int *, int);

char *to_file;
int loadpoint, verbose;
u_long entry;

/*
 * Old Format:
 *	sector 0:	LIF volume header (40 bytes)
 *	sector 1:	<unused>
 *	sector 2:	LIF directory (8 x 32 == 256 bytes)
 *	sector 3-:	LIF file 0, LIF file 1, etc.
 * where sectors are 256 bytes.
 *
 * New Format:
 *	sector 0:	LIF volume header (40 bytes)
 *	sector 1:	<unused>
 *	sector 2:	LIF directory (8 x 32 == 256 bytes)
 *	sector 3:	<unused>
 *	sector 4-31:	disklabel (~300 bytes right now)
 *	sector 32-:	LIF file 0, LIF file 1, etc.
 */
int
main(int argc, char **argv)
{
	int to;
	register int n, pos, c;
	char buf[LIF_FILESTART];
	struct lifvol *lifv = (struct lifvol *)buf;
	struct lifdir *lifd = (struct lifdir *)(buf + LIF_DIRSTART);

	while ((c = getopt(argc, argv, "vl:")) != -1) {
		switch (c) {
		case 'v':
			verbose++;
			break;
		case 'l':
			sscanf(optarg, "0x%x", &loadpoint);
			break;
		default:
			usage();
		}
	}
	if (argc - optind < 2)
		usage();
	else if (argc - optind > 8)
		errx(1, "too many boot programs (max 8 supported)");

	to_file = argv[--argc];
	if ((to = open(to_file, O_RDWR | O_TRUNC | O_CREAT, 0644)) < 0)
		err(1, "%s: open", to_file);

	bzero(buf, sizeof(buf));
	/* clear possibly unused directory entries */
	memset(lifd[1].dir_name, ' ', sizeof lifd[1].dir_name);
	lifd[1].dir_type = -1;
	lifd[1].dir_addr = 0;
	lifd[1].dir_length = 0;
	lifd[1].dir_flag = 0xFF;
	lifd[1].dir_implement = 0;
	lifd[7] = lifd[6] = lifd[5] = lifd[4] = lifd[3] = lifd[2] = lifd[1];

	/* record volume info */
	lifv->vol_id = htobe16(LIF_VOL_ID);
	strncpy(lifv->vol_label, "BOOT44", 6);
	lifv->vol_addr = htobe32(btolifs(LIF_DIRSTART));
	lifv->vol_oct = htobe16(LIF_VOL_OCT);
	lifv->vol_dirsize = htobe32(btolifs(LIF_DIRSIZE));
	lifv->vol_version = htobe16(1);
	lifv->vol_lastvol = lifv->vol_number =  htobe16(1);
	lifv->vol_length = LIF_FILESTART;
	bcddate(to_file, lifv->vol_toc);
	lifv->ipl_addr = htobe32(LIF_FILESTART);
	lifv->ipl_size = 0;
	lifv->ipl_entry = 0;

	argv += optind;
	argc -= optind;
	optind = 0;
	for (pos = LIF_FILESTART; optind < argc; optind++) {

		/* output bootfile */
		lseek(to, pos, 0);
		lifd[optind].dir_addr = htobe32(btolifs(pos));
		n = btolifs(putfile(argv[optind], to));
		if (lifv->ipl_entry == 0) {
			lifv->ipl_entry = htobe32(loadpoint + entry);
			lifv->ipl_size = htobe32(lifstob(n));
			lifd[optind].dir_type = htobe16(LIF_DIR_ISL);
			lifd[optind].dir_implement = 0;
		} else {
			lifd[optind].dir_type = htobe16(LIF_DIR_TYPE);
			lifd[1].dir_implement = htobe32(loadpoint + entry);
		}

		strlcpy(lifd[optind].dir_name, lifname(argv[optind]),
		    sizeof lifd[optind].dir_name);
		lifd[optind].dir_length = htobe32(n);
		bcddate(argv[optind], lifd[optind].dir_toc);
		lifd[optind].dir_flag = htobe16(LIF_DIR_FLAG);

		lifv->vol_length += n;
		pos += lifstob(n);
	}

	lifv->vol_length = htobe32(lifv->vol_length);

	/* output volume/directory header info */
	lseek(to, LIF_VOLSTART, 0);
	if (write(to, buf, sizeof(buf)) != sizeof(buf))
		err(1, "%s: write LIF volume", to_file);
	lseek(to, 0, SEEK_END);

	if (close(to) < 0)
		err(1, "%s", to_file);

	return (0);
}

int
putfile(char *from_file, int to)
{
	struct exec ex;
	register int n, total;
	char buf[2048];
	int from, check_sum = 0;
	struct lif_load load;

	if ((from = open(from_file, O_RDONLY)) < 0)
		err(1, "%s", from_file);

	n = read(from, &ex, sizeof(ex));
	if (n != sizeof(ex))
		err(1, "%s: reading file header", from_file);

	entry = ex.a_entry;
	if (N_GETMAGIC(ex) == OMAGIC || N_GETMAGIC(ex) == NMAGIC)
		entry += sizeof(ex);
	else if (IS_ELF(*(Elf32_Ehdr *)&ex)) {
		Elf32_Ehdr elf_header;
		Elf32_Phdr *elf_segments;
		int i, header_count, memory_needed, elf_load_image_segment;

		(void) lseek(from, 0, SEEK_SET);
		n = read(from, &elf_header, sizeof(elf_header));
		if (n != sizeof (elf_header))
			err(1, "%s: reading ELF header", from_file);
		header_count = ntohs(elf_header.e_phnum);
		elf_segments = reallocarray(NULL, header_count,
		    sizeof(*elf_segments));
		if (elf_segments == NULL)
			err(1, "malloc");
		memory_needed = header_count * sizeof(*elf_segments);
		(void) lseek(from, ntohl(elf_header.e_phoff), SEEK_SET);
		n = read(from, elf_segments, memory_needed);
		if (n != memory_needed)
			err(1, "%s: reading ELF segments", from_file);
		elf_load_image_segment = -1;
		for (i = 0; i < header_count; i++) {
			if (elf_segments[i].p_filesz &&
			    ntohl(elf_segments[i].p_flags) & PF_X) {
				if (elf_load_image_segment != -1)
					errx(1, "%s: more than one ELF program segment", from_file);
				elf_load_image_segment = i;
			}
		}
		if (elf_load_image_segment == -1)
			errx(1, "%s: no suitable ELF program segment", from_file);
		entry = ntohl(elf_header.e_entry) +
			ntohl(elf_segments[elf_load_image_segment].p_offset) -
			ntohl(elf_segments[elf_load_image_segment].p_vaddr);
		free(elf_segments);
	} else if (*(u_char *)&ex == 0x1f && ((u_char *)&ex)[1] == 0x8b) {
		entry = 0;
	} else
		errx(1, "%s: bad magic number", from_file);

	entry += sizeof(load);
	lseek(to, sizeof(load), SEEK_CUR);
	total = 0;
	n = sizeof(buf) - sizeof(load);
	/* copy the whole file */
	for (lseek(from, 0, 0); ; n = sizeof(buf)) {
		bzero(buf, sizeof(buf));
		if ((n = read(from, buf, n)) < 0)
			err(1, "%s", from_file);
		else if (n == 0)
			break;

		if (write(to, buf, n) != n)
			err(1, "%s", to_file);

		total += n;
		check_sum = cksum(check_sum, (int *)buf, n);
	}

	/* load header */
	load.address = htobe32(loadpoint + sizeof(load));
	load.count = htobe32(4 + total);
	check_sum = cksum(check_sum, (int *)&load, sizeof(load));

	if (verbose)
		warnx("wrote %d bytes of file \'%s\'", total, from_file);

	total += sizeof(load);
	/* insert the header */
	lseek(to, -total, SEEK_CUR);
	if (write(to, &load, sizeof(load)) != sizeof(load))
		err(1, "%s", to_file);
	lseek(to, total - sizeof(load), SEEK_CUR);

	bzero(buf, sizeof(buf));
	/* pad to int */
	n = sizeof(int) - total % sizeof(int);
	if (total % sizeof(int)) {
		if (write(to, buf, n) != n)
			err(1, "%s", to_file);
		else
			total += n;
	}

	/* pad to the blocksize */
	n = sizeof(buf) - total % sizeof(buf);

	if (n < sizeof(int)) {
		n += sizeof(buf);
		total += sizeof(buf);
	} else
		total += n;

	/* TODO should pad here to the 65k boundary for tape boot */

	if (verbose)
		warnx("checksum is 0x%08x", -check_sum);

	check_sum = htobe32(-check_sum);
	if (write(to, &check_sum, sizeof(int)) != sizeof(int))
		err(1, "%s", to_file);

	n -= sizeof(int);

	if (write(to, buf, n) != n)
		err(1, "%s", to_file);

	if (close(from) < 0 )
		err(1, "%s", from_file);

	return total;
}

int
cksum(int ck, int *p, int size)
{
	/* we assume size is int-aligned */
	for (size = (size + sizeof(int) - 1) / sizeof(int); size--; p++ )
		ck += betoh32(*p);

	return ck;
}

void __dead
usage(void)
{
	extern char *__progname;
	fprintf(stderr,
		"usage: %s [-v] [-l loadpoint] prog1 {progN} outfile\n",
		__progname);
	exit(1);
}

char *
lifname(char *str)
{
	static char lname[10] = "XXXXXXXXXX";
	register int i;

	for (i = 0; i < 9; i++) {
		if (islower(*str))
			lname[i] = toupper(*str);
		else if (isalnum(*str) || *str == '_')
			lname[i] = *str;
		else
			break;
		str++;
	}
	for ( ; i < 10; i++)
		lname[i] = ' ';
	return(lname);
}


void
bcddate(char *file, char *toc)
{
	struct stat statb;
	struct tm *tm;

	stat(file, &statb);
	tm = localtime(&statb.st_ctime);
	*toc = (tm->tm_year / 10) << 4;
	*toc++ |= tm->tm_year % 10;
	*toc = ((tm->tm_mon+1) / 10) << 4;
	*toc++ |= (tm->tm_mon+1) % 10;
	*toc = (tm->tm_mday / 10) << 4;
	*toc++ |= tm->tm_mday % 10;
	*toc = (tm->tm_hour / 10) << 4;
	*toc++ |= tm->tm_hour % 10;
	*toc = (tm->tm_min / 10) << 4;
	*toc++ |= tm->tm_min % 10;
	*toc = (tm->tm_sec / 10) << 4;
	*toc |= tm->tm_sec % 10;
}
@


1.19
log
@Replace a few malloc() calls with reallocarray() so it checks for overflow.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mkboot.c,v 1.18 2014/01/22 09:18:04 jsing Exp $	*/
d200 1
a200 1
		int i,header_count, memory_needed, elf_load_image_segment;
d203 1
a203 1
		n = read(from, &elf_header, sizeof (elf_header));
a223 2
			if (elf_load_image_segment == -1)
				errx(1, "%s: no suitable ELF program segment", from_file);
d225 2
d230 1
@


1.18
log
@Clean up code - sort headers, remove __OpenBSD__ #ifdefs and ansify
function declarations.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mkboot.c,v 1.17 2013/10/17 08:02:15 deraadt Exp $	*/
d207 2
a208 2
		memory_needed = header_count * sizeof (*elf_segments);
		elf_segments = malloc(memory_needed);
d211 1
@


1.17
log
@Remove support for a.out and ecoff.  We only do elf now.
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: mkboot.c,v 1.16 2009/10/27 23:59:34 deraadt Exp $	*/
d35 2
d39 5
d45 1
a45 1
#include <stdlib.h>
a46 7
#include <time.h>
#ifdef __OpenBSD__
#include <err.h>
#endif

#include <sys/exec.h>
#include <sys/exec_elf.h>
a54 3
#include <stdio.h>
#include <ctype.h>

a63 3
#ifndef __OpenBSD__
char *__progname = "mkboot";
#endif
d175 1
a175 1
	return(0);
d179 1
a179 3
putfile(from_file, to)
	char *from_file;
	int to;
d308 1
a308 4
cksum(ck, p, size)
	int ck;
	int *p;
	int size;
d318 1
a318 1
usage()
d328 1
a328 2
lifname(str)
	char *str;
d349 1
a349 3
bcddate(file, toc)
	char *file;
	char *toc;
a351 13
#ifndef __OpenBSD__
	struct tm {
		int tm_sec;    /* second (0-61, allows for leap seconds) */
		int tm_min;    /* minute (0-59) */
		int tm_hour;   /* hour (0-23) */
		int tm_mday;   /* day of the month (1-31) */
		int tm_mon;    /* month (0-11) */
		int tm_year;   /* years since 1900 */
		int tm_wday;   /* day of the week (0-6) */
		int tm_yday;   /* day of the year (0-365) */
		int tm_isdst;  /* non-0 if daylight saving time is in effect */
	} *tm;
#else
a352 1
#endif
a368 20

#ifndef __OpenBSD__
int
err(ex, str)
	int ex;
	char *str;
{
	perror(str);
	exit(ex);
}

int
errx(ex, str)
	int ex;
	char *str;
{
	perror(str);
	exit(ex);
}
#endif
@


1.16
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: mkboot.c,v 1.15 2004/11/22 18:41:42 mickey Exp $	*/
d45 1
a45 1
#include <sys/exec_aout.h>
@


1.15
log
@better types; from hppa64 (;
@
text
@d1 1
a1 1
/*	$OpenBSD: mkboot.c,v 1.14 2003/08/11 06:51:45 mickey Exp $	*/
a32 12

#if 0
#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1990, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
static char rcsid[] = "$OpenBSD: mkboot.c,v 1.14 2003/08/11 06:51:45 mickey Exp $";
#endif /* not lint */
#endif
@


1.14
log
@a few strict protos
@
text
@d1 1
a1 1
/*	$OpenBSD: mkboot.c,v 1.13 2003/06/02 23:27:47 millert Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: mkboot.c,v 1.13 2003/06/02 23:27:47 millert Exp $";
d227 2
a228 2
		memory_needed = header_count * sizeof (Elf32_Phdr);
		elf_segments = (Elf32_Phdr *)malloc(memory_needed);
@


1.13
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: mkboot.c,v 1.12 2003/05/11 19:41:09 deraadt Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: mkboot.c,v 1.12 2003/05/11 19:41:09 deraadt Exp $";
d100 1
a100 2
main(argc, argv)
	char **argv;
@


1.12
log
@string cleaning; krw ok
@
text
@d1 1
a1 1
/*	$OpenBSD: mkboot.c,v 1.11 2002/06/11 05:18:22 jsyn Exp $	*/
d15 1
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d42 1
a42 1
static char rcsid[] = "$OpenBSD: mkboot.c,v 1.11 2002/06/11 05:18:22 jsyn Exp $";
@


1.11
log
@err(3) appends a newline already; ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mkboot.c,v 1.10 2002/03/14 01:26:32 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: mkboot.c,v 1.10 2002/03/14 01:26:32 millert Exp $";
d136 1
a136 1
	memset(lifd[1].dir_name, ' ', 10);
d177 2
a178 1
		strcpy(lifd[optind].dir_name, lifname(argv[optind]));
@


1.10
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: mkboot.c,v 1.9 2001/05/17 00:57:55 pvalchev Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: mkboot.c,v 1.9 2001/05/17 00:57:55 pvalchev Exp $";
d256 1
a256 1
		errx(1, "%s: bad magic number\n", from_file);
@


1.9
log
@It's Daylight Saving Time, not Savings.  Fix comments.
Discussed with pjanzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mkboot.c,v 1.8 2000/06/30 16:00:11 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: mkboot.c,v 1.8 2000/06/30 16:00:11 millert Exp $";
d74 5
a78 5
int putfile __P((char *, int));
void __dead usage __P((void));
void bcddate __P((char *, char *));
char *lifname __P((char *));
int cksum __P((int, int *, int));
@


1.9.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: mkboot.c,v 1.9 2001/05/17 00:57:55 pvalchev Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: mkboot.c,v 1.9 2001/05/17 00:57:55 pvalchev Exp $";
d74 5
a78 5
int putfile(char *, int);
void __dead usage(void);
void bcddate(char *, char *);
char *lifname(char *);
int cksum(int, int *, int);
@


1.9.4.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: mkboot.c,v 1.9.4.1 2002/06/11 03:35:38 art Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: mkboot.c,v 1.9.4.1 2002/06/11 03:35:38 art Exp $";
d256 1
a256 1
		errx(1, "%s: bad magic number", from_file);
@


1.9.4.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD$";
d136 1
a136 1
	memset(lifd[1].dir_name, ' ', sizeof lifd[1].dir_name);
d177 1
a177 2
		strlcpy(lifd[optind].dir_name, lifname(argv[optind]),
		    sizeof lifd[optind].dir_name);
@


1.8
log
@warnx?/errx? paranoia (use "%s" not a bare string unless it is a
constant).  These are not security holes but it is worth fixing
them anyway both for robustness and so folks looking for examples
in the tree are not misled into doing something potentially dangerous.
Furthermore, it is a bad idea to assume that pathnames will not
include '%' in them and that error routines don't return strings
with '%' in them (especially in light of the possibility of locales).
@
text
@d1 1
a1 1
/*	$OpenBSD: mkboot.c,v 1.7 1999/05/23 17:19:22 aaron Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: mkboot.c,v 1.7 1999/05/23 17:19:22 aaron Exp $";
d392 1
a392 1
		int tm_isdst;  /* non-0 if daylight savings time is in effect */
@


1.7
log
@getopt(3) returns -1, not EOF
@
text
@d1 1
a1 1
/*	$OpenBSD: mkboot.c,v 1.6 1999/05/03 22:47:05 mickey Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: mkboot.c,v 1.6 1999/05/03 22:47:05 mickey Exp $";
d195 1
a195 1
		err(1, to_file);
d212 1
a212 1
		err(1, from_file);
d266 1
a266 1
			err(1, from_file);
d271 1
a271 1
			err(1, to_file);
d289 1
a289 1
		err(1, to_file);
d297 1
a297 1
			err(1, to_file);
d318 1
a318 1
		err(1, to_file);
d323 1
a323 1
		err(1, to_file);
d326 1
a326 1
		err(1, from_file);
@


1.7.4.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: mkboot.c,v 1.8 2000/06/30 16:00:11 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: mkboot.c,v 1.8 2000/06/30 16:00:11 millert Exp $";
d195 1
a195 1
		err(1, "%s", to_file);
d212 1
a212 1
		err(1, "%s", from_file);
d266 1
a266 1
			err(1, "%s", from_file);
d271 1
a271 1
			err(1, "%s", to_file);
d289 1
a289 1
		err(1, "%s", to_file);
d297 1
a297 1
			err(1, "%s", to_file);
d318 1
a318 1
		err(1, "%s", to_file);
d323 1
a323 1
		err(1, "%s", to_file);
d326 1
a326 1
		err(1, "%s", from_file);
@


1.7.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: mkboot.c,v 1.7.4.1 2001/04/18 16:06:58 niklas Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: mkboot.c,v 1.7.4.1 2001/04/18 16:06:58 niklas Exp $";
d392 1
a392 1
		int tm_isdst;  /* non-0 if daylight saving time is in effect */
@


1.7.4.3
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD$";
d74 5
a78 5
int putfile(char *, int);
void __dead usage(void);
void bcddate(char *, char *);
char *lifname(char *);
int cksum(int, int *, int);
@


1.7.4.4
log
@Sync the SMP branch with 3.3
@
text
@d256 1
a256 1
		errx(1, "%s: bad magic number", from_file);
@


1.7.4.5
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: mkboot.c,v 1.7.4.4 2003/03/27 23:26:54 niklas Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: mkboot.c,v 1.7.4.4 2003/03/27 23:26:54 niklas Exp $";
d136 1
a136 1
	memset(lifd[1].dir_name, ' ', sizeof lifd[1].dir_name);
d177 1
a177 2
		strlcpy(lifd[optind].dir_name, lifname(argv[optind]),
		    sizeof lifd[optind].dir_name);
@


1.7.4.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: mkboot.c,v 1.7.4.5 2003/05/13 19:41:05 ho Exp $	*/
d15 5
a19 1
 * 3. Neither the name of the University nor the names of its contributors
d46 1
a46 1
static char rcsid[] = "$OpenBSD: mkboot.c,v 1.7.4.5 2003/05/13 19:41:05 ho Exp $";
@


1.7.4.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD$";
d100 2
a101 1
main(int argc, char **argv)
@


1.7.6.1
log
@Pull in patch from current (even more to come):
Fix (millert):
warnx?/errx? paranoia (use "%s" not a bare string unless it is a
constant).  These are not security holes but it is worth fixing
them anyway both for robustness and so folks looking for examples
in the tree are not misled into doing something potentially dangerous.
Furthermore, it is a bad idea to assume that pathnames will not
include '%' in them and that error routines don't return strings
with '%' in them (especially in light of the possibility of locales).
@
text
@d1 1
a1 1
/*	$OpenBSD: mkboot.c,v 1.8 2000/06/30 16:00:11 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: mkboot.c,v 1.8 2000/06/30 16:00:11 millert Exp $";
d195 1
a195 1
		err(1, "%s", to_file);
d212 1
a212 1
		err(1, "%s", from_file);
d266 1
a266 1
			err(1, "%s", from_file);
d271 1
a271 1
			err(1, "%s", to_file);
d289 1
a289 1
		err(1, "%s", to_file);
d297 1
a297 1
			err(1, "%s", to_file);
d318 1
a318 1
		err(1, "%s", to_file);
d323 1
a323 1
		err(1, "%s", to_file);
d326 1
a326 1
		err(1, "%s", from_file);
@


1.6
log
@lifvar.h -- bye, bye
@
text
@d1 1
a1 1
/*	$OpenBSD: mkboot.c,v 1.5 1998/09/29 07:12:58 mickey Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: mkboot.c,v 1.5 1998/09/29 07:12:58 mickey Exp $";
d113 1
a113 1
	while ((c = getopt(argc, argv, "vl:")) != EOF) {
@


1.5
log
@'acceppt gzip files for lif
@
text
@d1 1
a1 1
/*	$OpenBSD: mkboot.c,v 1.4 1998/08/29 01:46:53 mickey Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: mkboot.c,v 1.4 1998/08/29 01:46:53 mickey Exp $";
d66 1
a66 1
#include "../../include/lifvar.h"
d68 1
a68 1
#include <machine/lifvar.h>
d145 1
a145 1
	lifv->vol_id = htobe16(VOL_ID);
d148 1
a148 1
	lifv->vol_oct = htobe16(VOL_OCT);
d170 1
a170 1
			lifd[optind].dir_type = htobe16(DIR_ISL);
d173 1
a173 1
			lifd[optind].dir_type = htobe16(DIR_TYPE);
d180 1
a180 1
		lifd[optind].dir_flag = htobe16(DIR_FLAG);
d209 1
a209 1
	struct load load;
a220 1

d310 2
@


1.4
log
@postpone bzero buffer on padding
@
text
@d1 1
a1 1
/*	$OpenBSD: mkboot.c,v 1.3 1998/07/27 15:41:08 mickey Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: mkboot.c,v 1.3 1998/07/27 15:41:08 mickey Exp $";
d254 2
@


1.3
log
@make LIF definitions machine-wide
fix bug w/ blank LIF file names (\t crept into "" string), use memset
don't prepend names w/ SYS_
@
text
@d1 1
a1 1
/*	$OpenBSD: mkboot.c,v 1.2 1998/07/13 02:11:29 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: mkboot.c,v 1.2 1998/07/13 02:11:29 millert Exp $";
a283 1
	bzero(buf, sizeof(buf));
d291 1
@


1.2
log
@ftpd: sleep for an indeterminate amount for non-existant logins
      to simulate a crypt, like login does.
Use SEEK_* not L_* and kill some 0L's used in lseek while we're there.
@
text
@d1 1
a1 1
/*	$OpenBSD: mkboot.c,v 1.1.1.1 1998/06/23 18:46:43 mickey Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: mkboot.c,v 1.1.1.1 1998/06/23 18:46:43 mickey Exp $";
d64 6
a69 1
#include "volhdr.h"
a79 11
#define LIF_NUMDIR	8

#define LIF_VOLSTART	0
#define LIF_VOLSIZE	sizeof(struct lifvol)
#define LIF_DIRSTART	2048
#define LIF_DIRSIZE	(LIF_NUMDIR * sizeof(struct lifdir))
#define LIF_FILESTART	4096

#define btolifs(b)	(((b) + (SECTSIZE - 1)) / SECTSIZE)
#define lifstob(s)	((s) * SECTSIZE)

d136 1
a136 1
	strncpy(lifd[1].dir_name, "	     ", 10);
d161 1
a161 1
	for (pos = btolifs(LIF_FILESTART); optind < argc; optind++) {
d164 2
a165 2
		lseek(to, lifstob(pos), 0);
		lifd[optind].dir_addr = htobe32(pos);
d355 1
a355 1
	static char lname[10] = "SYS_XXXXXX";
d358 1
a358 1
	for (i = 4; i < 9; i++) {
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD$";
d233 1
a233 1
		(void) lseek(from, 0, L_SET);
d242 1
a242 1
		(void) lseek(from, ntohl(elf_header.e_phoff), L_SET);
@


1.1.1.1
log
@ok, it boots, include and libkern to come
@
text
@@
