head	1.15;
access;
symbols
	OPENBSD_6_2:1.15.0.10
	OPENBSD_6_2_BASE:1.15
	OPENBSD_6_1:1.15.0.8
	OPENBSD_6_1_BASE:1.15
	OPENBSD_6_0:1.15.0.4
	OPENBSD_6_0_BASE:1.15
	OPENBSD_5_9:1.15.0.2
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.14.0.16
	OPENBSD_5_8_BASE:1.14
	OPENBSD_5_7:1.14.0.8
	OPENBSD_5_7_BASE:1.14
	OPENBSD_5_6:1.14.0.12
	OPENBSD_5_6_BASE:1.14
	OPENBSD_5_5:1.14.0.10
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.14.0.6
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.14.0.4
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.2
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.30
	OPENBSD_5_0:1.13.0.28
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.26
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.24
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.20
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.13.0.22
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.18
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.16
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.14
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.12
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.13.0.10
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.13.0.8
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.13.0.6
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.13.0.4
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.13.0.2
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.12.0.6
	OPENBSD_3_6_BASE:1.12
	SMP_SYNC_A:1.12
	SMP_SYNC_B:1.12
	OPENBSD_3_5:1.12.0.4
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.12.0.2
	OPENBSD_3_4_BASE:1.12
	UBC_SYNC_A:1.11
	OPENBSD_3_3:1.8.0.2
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.6.0.4
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	UBC_SYNC_B:1.6
	UBC:1.5.0.14
	UBC_BASE:1.5
	OPENBSD_3_0:1.5.0.12
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9:1.5.0.10
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.5.0.8
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.6
	OPENBSD_2_7_BASE:1.5
	SMP:1.5.0.4
	SMP_BASE:1.5
	kame_19991208:1.5
	OPENBSD_2_6:1.5.0.2
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.4.0.2
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.3.0.2
	OPENBSD_2_4_BASE:1.3
	mickey-boot:1.1.1.1
	mickey:1.1.1;
locks; strict;
comment	@ * @;


1.15
date	2015.10.01.16.08.20;	author krw;	state Exp;
branches;
next	1.14;
commitid	43YBo4Ce0DxgFS6N;

1.14
date	2012.02.25.20.12.00;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2004.11.22.18.41.41;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	2003.08.11.06.51.45;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	2003.04.30.03.46.28;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	2003.04.29.22.38.50;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	2003.04.16.07.20.50;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	2003.01.14.19.32.23;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	2003.01.14.11.40.18;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	2002.03.15.18.19.52;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	99.04.20.20.01.01;	author mickey;	state Exp;
branches
	1.5.4.1
	1.5.14.1;
next	1.4;

1.4
date	98.10.30.19.42.17;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	98.09.29.07.20.45;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	98.07.08.21.34.34;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	98.06.23.18.46.42;	author mickey;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.06.23.18.46.42;	author mickey;	state Exp;
branches;
next	;

1.5.4.1
date	2002.03.28.10.31.03;	author niklas;	state Exp;
branches;
next	1.5.4.2;

1.5.4.2
date	2003.03.27.23.26.54;	author niklas;	state Exp;
branches;
next	1.5.4.3;

1.5.4.3
date	2003.05.13.19.41.04;	author ho;	state Exp;
branches;
next	1.5.4.4;

1.5.4.4
date	2004.02.19.10.48.41;	author niklas;	state Exp;
branches;
next	;

1.5.14.1
date	2002.06.11.03.35.38;	author art;	state Exp;
branches;
next	1.5.14.2;

1.5.14.2
date	2003.05.19.21.43.13;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.15
log
@Remove more blinding trailing whitespace.
@
text
@/*	$OpenBSD: dk.c,v 1.14 2012/02/25 20:12:00 miod Exp $	*/

/*
 * Copyright 1996 1995 by Open Software Foundation, Inc.
 *              All Rights Reserved
 *
 * Permission to use, copy, modify, and distribute this software and
 * its documentation for any purpose and without fee is hereby granted,
 * provided that the above copyright notice appears in all copies and
 * that both the copyright notice and this permission notice appear in
 * supporting documentation.
 *
 * OSF DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE.
 *
 * IN NO EVENT SHALL OSF BE LIABLE FOR ANY SPECIAL, INDIRECT, OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN ACTION OF CONTRACT,
 * NEGLIGENCE, OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
 * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

#include "libsa.h"

#include <sys/param.h>
#include <sys/disklabel.h>
#include <sys/reboot.h>
#include <machine/pdc.h>
#include <machine/iomod.h>

#include "dev_hppa.h"

const char *
dk_disklabel(struct hppa_dev *dp, struct disklabel *label)
{
	char buf[DEV_BSIZE];
	size_t ret;

	if (iodcstrategy(dp, F_READ, LABELSECTOR, DEV_BSIZE, buf, &ret))
		if (ret != DEV_BSIZE)
			return "cannot read disklabel";

	return (getdisklabel(buf, label));
}

int
dkopen(struct open_file *f, ...)
{
	struct disklabel *lp;
	struct hppa_dev *dp = f->f_devdata;
	const char *st;

#ifdef	DEBUG
	if (debug)
		printf("dkopen(%p)\n", f);
#endif

	if (!(dp->pz_dev = pdc_findev(-1, PCL_RANDOM)))
		return ENXIO;

	lp = dp->label;
	st = NULL;

#ifdef DEBUG
	if (debug)
		printf ("disklabel\n");
#endif

	if ((st = dk_disklabel(dp, lp)) != NULL) {
#ifdef DEBUG
		if (debug)
			printf ("dkopen: %s\n", st);
#endif
		/* we do not know if it's a disk or net, but do not fail */
	} else {
		u_int i;

		i = B_PARTITION(dp->bootdev);
		if (i >= lp->d_npartitions || !lp->d_partitions[i].p_size)
			return (EPART);

		dp->fsoff = lp->d_partitions[i].p_offset;
	}

#ifdef DEBUG
	if (debug)
		printf ("dkopen() ret\n");
#endif
	return (0);
}

int
dkclose(f)
	struct open_file *f;
{
	free (f->f_devdata, sizeof(struct hppa_dev));
	f->f_devdata = NULL;
	return 0;
}
@


1.14
log
@:%s,DEBUGBUG,DEBUG,
@
text
@d1 1
a1 1
/*	$OpenBSD: dk.c,v 1.13 2004/11/22 18:41:41 mickey Exp $	*/
d4 19
a22 19
 * Copyright 1996 1995 by Open Software Foundation, Inc.   
 *              All Rights Reserved 
 *  
 * Permission to use, copy, modify, and distribute this software and 
 * its documentation for any purpose and without fee is hereby granted, 
 * provided that the above copyright notice appears in all copies and 
 * that both the copyright notice and this permission notice appear in 
 * supporting documentation. 
 *  
 * OSF DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE 
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS 
 * FOR A PARTICULAR PURPOSE. 
 *  
 * IN NO EVENT SHALL OSF BE LIABLE FOR ANY SPECIAL, INDIRECT, OR 
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM 
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN ACTION OF CONTRACT, 
 * NEGLIGENCE, OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION 
 * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. 
 * 
@


1.13
log
@better types; from hppa64 (;
@
text
@d1 1
a1 1
/*	$OpenBSD: dk.c,v 1.12 2003/08/11 06:51:45 mickey Exp $	*/
d87 1
a87 1
#ifdef DEBUGBUG
@


1.12
log
@a few strict protos
@
text
@d1 1
a1 1
/*	$OpenBSD: dk.c,v 1.11 2003/04/30 03:46:28 mickey Exp $	*/
d39 1
a39 1
	int ret;
@


1.11
log
@oops. fixed endif in a wrong place
@
text
@d1 1
a1 1
/*	$OpenBSD: dk.c,v 1.10 2003/04/29 22:38:50 mickey Exp $	*/
d36 1
a36 3
dk_disklabel(dp, label)
	struct hppa_dev *dp;
	struct disklabel *label;
@


1.10
log
@some cleanup and redo ct as lf (just different dev type). saves some memory
@
text
@d1 1
a1 1
/*	$OpenBSD: dk.c,v 1.10 2003/04/29 22:27:07 mickey Exp $	*/
d71 1
d88 1
a88 1
#endif
@


1.9
log
@clean some spaces and registers and other fluff
@
text
@d1 1
a1 1
/*	$OpenBSD: dk.c,v 1.8 2003/01/14 19:32:23 mickey Exp $	*/
a33 2

iodcio_t dkiodc;	/* boot IODC entry point */
@


1.8
log
@do not fail if there is no disklabel found, could be netbooting
@
text
@d1 1
a1 1
/*	$OpenBSD: dk.c,v 1.7 2003/01/14 11:40:18 mickey Exp $	*/
d55 3
a57 3
	register struct disklabel *lp;
	register struct hppa_dev *dp = f->f_devdata;
	register const char *st;
d81 1
a81 1
		register u_int i;
@


1.7
log
@during the open store the partition offset and do subsequent io relative to that offset, allows reading kernel from scsi disk
@
text
@d1 1
a1 1
/*	$OpenBSD: dk.c,v 1.6 2002/03/15 18:19:52 millert Exp $	*/
d79 1
a79 1
		return ERDLAB;
@


1.6
log
@Kill #if __STDC__ used to do K&R vs. ANSI varargs/stdarg; just do things
the ANSI way.
@
text
@d1 1
a1 1
/*	$OpenBSD: dk.c,v 1.5 1999/04/20 20:01:01 mickey Exp $	*/
d69 1
a69 1
#if 0	
d73 1
a73 1
#endif
d84 1
a84 1
		if (i >= lp->d_npartitions || !lp->d_partitions[i].p_size) {
d86 2
a87 1
		}
@


1.5
log
@fix different alignment problems
correct PDC/IODC call formats
factor some more code out to the dev_hppa.c routines
basically boot on many more machine by now
@
text
@d1 1
a1 1
/*	$OpenBSD: dk.c,v 1.4 1998/10/30 19:42:17 mickey Exp $	*/
a52 1
#ifdef __STDC__
a53 4
#else
dkopen(f, va_alist)
	struct open_file *f;
#endif
@


1.5.14.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: dk.c,v 1.5 1999/04/20 20:01:01 mickey Exp $	*/
d53 1
d55 4
@


1.5.14.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d35 2
d55 3
a57 3
	struct disklabel *lp;
	struct hppa_dev *dp = f->f_devdata;
	const char *st;
d69 1
a69 1

a73 1

d79 1
a79 1
		/* we do not know if it's a disk or net, but do not fail */
d81 1
a81 1
		u_int i;
d84 1
a84 1
		if (i >= lp->d_npartitions || !lp->d_partitions[i].p_size)
d86 1
a86 2

		dp->fsoff = lp->d_partitions[i].p_offset;
d88 1
a88 1

@


1.5.4.1
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d53 1
d55 4
@


1.5.4.2
log
@Sync the SMP branch with 3.3
@
text
@d69 1
a69 1

d73 1
a73 1

d79 1
a79 1
		/* we do not know if it's a disk or net, but do not fail */
d84 1
a84 1
		if (i >= lp->d_npartitions || !lp->d_partitions[i].p_size)
d86 1
a86 2

		dp->fsoff = lp->d_partitions[i].p_offset;
@


1.5.4.3
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: dk.c,v 1.5.4.2 2003/03/27 23:26:54 niklas Exp $	*/
d35 2
d55 3
a57 3
	struct disklabel *lp;
	struct hppa_dev *dp = f->f_devdata;
	const char *st;
a72 1
#endif
d81 1
a81 1
		u_int i;
d89 1
a89 1

@


1.5.4.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d36 3
a38 1
dk_disklabel(struct hppa_dev *dp, struct disklabel *label)
@


1.4
log
@support booting from disk in raw LIF mode
@
text
@d1 1
a1 1
/*	$OpenBSD: dk.c,v 1.3 1998/09/29 07:20:45 mickey Exp $	*/
d42 2
a43 2
	char buf[IONBPG];
	size_t ret;
d45 1
a45 1
	if (iodcstrategy(dp, F_READ, LABELSECTOR, IONBPG, buf, &ret))
d47 1
a47 1
			return "cannot read LIF header";
d61 1
a61 2
	register struct hppa_dev *dp;
	register struct pz_device *pzd;
d69 1
a69 1
	if (!(pzd = pdc_findev(-1, PCL_RANDOM)))
a71 15
#ifdef	DEBUG
	if (debug)
		printf("alloc\n");
#endif
	if (!(dp = alloc(sizeof *dp))) {
#ifdef DEBUG
		printf ("dkopen: no mem\n");
#endif
		return ENODEV;
	}

	bzero(dp, sizeof *dp);

	dp->bootdev = bootdev;
	dp->pz_dev = pzd;
d94 1
a94 1
#ifdef DEBUG
a97 1
	f->f_devdata = dp;
@


1.3
log
@there is only one strategy routine: iodcstrategy
@
text
@d1 1
a1 1
/*	$OpenBSD: dk.c,v 1.2 1998/07/08 21:34:34 mickey Exp $	*/
d60 4
a63 5
	struct disklabel *lp;
	struct hppa_dev *dp;
	struct pz_device *pzd;
	const char *st;
	int i;
d66 2
a67 1
	printf("dkopen(%p)\n", f);
d72 4
a75 3
#ifdef PDCDEBUG
	else if (debug)
		PZDEV_PRINT(pzd);
d77 6
a82 4

	if (f->f_devdata == 0) 
		f->f_devdata = alloc(sizeof *dp);
	dp = f->f_devdata;
d89 6
a94 1
	
d98 1
a98 1
			printf ("%s\n", st);
d101 2
a102 1
	}
d104 4
a107 4
	i = B_PARTITION(dp->bootdev);
	if ((unsigned int)i >= lp->d_npartitions ||
	    lp->d_partitions[i].p_size == 0) {
		return (EPART);
d109 6
a114 1

@


1.2
log
@use those new pdc call types
@
text
@d1 1
a1 1
/*	$OpenBSD: dk.c,v 1.1.1.1 1998/06/23 18:46:42 mickey Exp $	*/
a30 1
#include <machine/iodc.h>
d35 1
a35 134
iodcio_t btiodc;	/* boot IODC entry point */

char btbuf[BTIOSIZ] __attribute ((aligned (MINIOSIZ)));
int HP800;	

void
btinit()
{
	int err;
	static int firstime = 1;

	btiodc = (iodcio_t)(PAGE0->mem_free + IODC_MAXSIZE);

	if (firstime) {
		/*
		 * If we _rtt(), we will call btinit() again.
		 * We only want to do ctdev initialization once.
		 */
		bcopy((char *)&PAGE0->mem_boot, (char *)&ctdev,
		      sizeof(struct pz_device));
		firstime = 0;
	}

	/*
	 * Initialize "HP800" to boolean value (T=HP800 F=HP700).
	 */
	if (!HP800) {
		struct pdc_model model;
		err = (*pdc)(PDC_MODEL, PDC_MODEL_INFO, &model, 0,0,0,0,0);
		if (err < 0) {
			HP800 = 1;	/* default: HP800 */
			printf("Proc model info ret'd %d (assuming %s)\n",
			       err, HP800? "HP800": "HP700");
		}
		HP800 = (((model.hvers >> 4) & 0xfff) < 0x200);
	}
}

int
dkreset(slot, unit)
	int slot, unit;
{
	struct device_path bootdp;
	int err, srchtype;

	/*
	 * Save a copy of the previous boot device path.
	 */
	bcopy((char *)&PAGE0->mem_boot.pz_dp, (char *)&bootdp,
	      sizeof(struct device_path));

	/*
	 * Read the boot device initialization code into memory.
	 */
	err = (*pdc)(PDC_IODC, PDC_IODC_READ, pdcbuf, BT_HPA, IODC_INIT,
	             btiodc, IODC_MAXSIZE);
	if (err < 0) {
		printf("Boot module ENTRY_INIT Read ret'd %d\n", err);
		goto bad;
	}

	/*
	 * Plod over boot devices looking for one with the same unit
	 * number as that which is in `unit'.
	 */
	srchtype = IODC_INIT_FIRST;
	while (1) {
		err = (*btiodc)(BT_HPA,srchtype,BT_SPA,BT_LAYER,pdcbuf,0,0,0,0);
		if (err < 0) {
			if (err == -9) {
				BT_IODC = 0;
				return(EUNIT);
			}
			printf("Boot module ENTRY_INIT Search ret'd %d\n", err);
			goto bad;
		}

		srchtype = IODC_INIT_NEXT;	/* for next time... */

		if (pdcbuf[1] != PCL_RANDOM)	/* only want disks */
			continue;

		if (HP800) {
			if (slot != ANYSLOT && slot != BT_LAYER[0])
				continue;

			if (BT_LAYER[1] == unit) {
				BT_CLASS = pdcbuf[1];
				break;
			}
		} else {
			if (slot != NOSLOT)
				continue;

			if (BT_LAYER[0] == unit) {
				BT_CLASS = pdcbuf[1];
				break;
			}
		}
	}

	/*
	 * If this is not the "currently initialized" boot device,
	 * initialize the new boot device we just found.
	 *
	 * N.B. We do not need/want to initialize the entire module
	 * (e.g. CIO, SCSI), and doing so may blow away our console.
	 * if the user specified a boot module other than the
	 * console module, we initialize both the module and device.
	 */
	if (bcmp((char *)&PAGE0->mem_boot.pz_dp, (char *)&bootdp,
	         sizeof(struct device_path)) != 0) {
		err = (*btiodc)(BT_HPA,(!HP800||BT_HPA==CN_HPA||BT_HPA==KY_HPA)?
		                IODC_INIT_DEV: IODC_INIT_ALL,
		                BT_SPA, BT_LAYER, pdcbuf, 0,0,0,0);
		if (err < 0) {
			printf("Boot module/device IODC Init ret'd %d\n", err);
			goto bad;
		}
	}

	err = (*pdc)(PDC_IODC, PDC_IODC_READ, pdcbuf, BT_HPA, IODC_IO,
	             btiodc, IODC_MAXSIZE);
	if (err < 0) {
		printf("Boot device ENTRY_IO Read ret'd %d\n", err);
		goto bad;
	}

	BT_IODC = btiodc;
	return (0);
bad:
	BT_IODC = 0;
	return(-1);
}
d42 1
a42 1
	char buf[DEV_BSIZE];
d45 3
a47 3
	if (dkstrategy(dp, F_READ, LABELOFFSET, DEV_BSIZE, buf, &ret) ||
	    ret != DEV_BSIZE)
		return "cannot read disklbael";
d62 1
d66 11
d83 3
a85 19
	{
		int adapt, ctlr, unit, part, type;
		va_list ap;

#ifdef __STDC__
		va_start(ap, f);
#else
		va_start(ap);
#endif
		adapt = va_arg(ap, int);
		ctlr = va_arg(ap, int);
		unit = va_arg(ap, int);
		part = va_arg(ap, int);
		type = va_arg(ap, int);
		va_end(ap);

		dp->bootdev = MAKEBOOTDEV(type, adapt, ctlr, unit, part);
	}
	lp = &dp->label;
d88 4
a91 1
		printf ("%s\n", st);
a104 21
dkstrategy(devdata, rw, blk, size, buf, rsize)
	void *devdata;
	int rw;
	daddr_t blk;
	size_t size;
	void *buf;
	size_t *rsize;
{
	int ret;

	ret = iodc_rw(buf, blk, size, rw, &PAGE0->mem_boot);
	if (ret < 0) {
		printf("dk: iodc ret'd %d\n", ret);
		return (-1);
	}
	
	*rsize = ret;
	return (ret);
}

int
d108 2
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d36 1
a36 1
int (*btiodc)();	/* boot IODC entry point */
d47 1
a47 1
	btiodc = (int (*)()) ((unsigned int)PAGE0->mem_free + IODC_MAXSIZE);
@


1.1.1.1
log
@ok, it boots, include and libkern to come
@
text
@@
