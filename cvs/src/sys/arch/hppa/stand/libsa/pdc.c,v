head	1.21;
access;
symbols
	OPENBSD_6_1:1.21.0.16
	OPENBSD_6_1_BASE:1.21
	OPENBSD_6_0:1.21.0.14
	OPENBSD_6_0_BASE:1.21
	OPENBSD_5_9:1.21.0.10
	OPENBSD_5_9_BASE:1.21
	OPENBSD_5_8:1.21.0.12
	OPENBSD_5_8_BASE:1.21
	OPENBSD_5_7:1.21.0.4
	OPENBSD_5_7_BASE:1.21
	OPENBSD_5_6:1.21.0.8
	OPENBSD_5_6_BASE:1.21
	OPENBSD_5_5:1.21.0.6
	OPENBSD_5_5_BASE:1.21
	OPENBSD_5_4:1.21.0.2
	OPENBSD_5_4_BASE:1.21
	OPENBSD_5_3:1.20.0.8
	OPENBSD_5_3_BASE:1.20
	OPENBSD_5_2:1.20.0.6
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.4
	OPENBSD_5_0:1.20.0.2
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.19.0.24
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.19.0.22
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.19.0.18
	OPENBSD_4_7_BASE:1.19
	OPENBSD_4_6:1.19.0.20
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.19.0.16
	OPENBSD_4_5_BASE:1.19
	OPENBSD_4_4:1.19.0.14
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.19.0.12
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.19.0.10
	OPENBSD_4_2_BASE:1.19
	OPENBSD_4_1:1.19.0.8
	OPENBSD_4_1_BASE:1.19
	OPENBSD_4_0:1.19.0.6
	OPENBSD_4_0_BASE:1.19
	OPENBSD_3_9:1.19.0.4
	OPENBSD_3_9_BASE:1.19
	OPENBSD_3_8:1.19.0.2
	OPENBSD_3_8_BASE:1.19
	OPENBSD_3_7:1.18.0.4
	OPENBSD_3_7_BASE:1.18
	OPENBSD_3_6:1.18.0.2
	OPENBSD_3_6_BASE:1.18
	SMP_SYNC_A:1.18
	SMP_SYNC_B:1.18
	OPENBSD_3_5:1.17.0.4
	OPENBSD_3_5_BASE:1.17
	OPENBSD_3_4:1.17.0.2
	OPENBSD_3_4_BASE:1.17
	UBC_SYNC_A:1.16
	OPENBSD_3_3:1.13.0.2
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.11.0.4
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	UBC_SYNC_B:1.11
	UBC:1.10.0.14
	UBC_BASE:1.10
	OPENBSD_3_0:1.10.0.12
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9:1.10.0.10
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_8:1.10.0.8
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.10.0.6
	OPENBSD_2_7_BASE:1.10
	SMP:1.10.0.4
	SMP_BASE:1.10
	kame_19991208:1.10
	OPENBSD_2_6:1.10.0.2
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.8.0.2
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.3.0.2
	OPENBSD_2_4_BASE:1.3
	mickey-boot:1.1.1.1
	mickey:1.1.1;
locks; strict;
comment	@ * @;


1.21
date	2013.03.23.16.08.28;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2011.03.13.00.13.52;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2005.04.07.00.21.51;	author mickey;	state Exp;
branches;
next	1.18;

1.18
date	2004.04.07.18.24.20;	author mickey;	state Exp;
branches;
next	1.17;

1.17
date	2003.08.11.06.51.45;	author mickey;	state Exp;
branches;
next	1.16;

1.16
date	2003.04.30.23.03.55;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	2003.04.30.04.09.38;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	2003.04.16.07.20.50;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	2003.01.14.11.40.18;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	2002.12.19.00.39.01;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	2002.03.14.03.15.53;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	99.05.06.02.27.44;	author mickey;	state Exp;
branches
	1.10.4.1
	1.10.14.1;
next	1.9;

1.9
date	99.04.20.20.01.02;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	99.02.13.04.43.18;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	99.01.25.20.16.07;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	98.12.13.06.45.05;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	98.12.13.06.41.43;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	98.10.30.19.40.22;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	98.09.29.07.27.02;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	98.07.08.21.34.37;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	98.06.23.18.46.42;	author mickey;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.06.23.18.46.42;	author mickey;	state Exp;
branches;
next	;

1.10.4.1
date	2002.03.28.10.31.03;	author niklas;	state Exp;
branches;
next	1.10.4.2;

1.10.4.2
date	2003.03.27.23.26.54;	author niklas;	state Exp;
branches;
next	1.10.4.3;

1.10.4.3
date	2003.05.13.19.41.04;	author ho;	state Exp;
branches;
next	1.10.4.4;

1.10.4.4
date	2004.02.19.10.48.41;	author niklas;	state Exp;
branches;
next	1.10.4.5;

1.10.4.5
date	2004.06.05.23.10.49;	author niklas;	state Exp;
branches;
next	;

1.10.14.1
date	2002.06.11.03.35.38;	author art;	state Exp;
branches;
next	1.10.14.2;

1.10.14.2
date	2003.05.19.21.43.13;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.21
log
@Avoid using DEV_BSHIFT, and use DEV_BSIZE instead.
@
text
@/*	$OpenBSD: pdc.c,v 1.20 2011/03/13 00:13:52 deraadt Exp $	*/

/*
 * Copyright (c) 1998-2004 Michael Shalayeff
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR OR HIS RELATIVES BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */
/*
 * Copyright 1996 1995 by Open Software Foundation, Inc.
 *              All Rights Reserved
 *
 * Permission to use, copy, modify, and distribute this software and
 * its documentation for any purpose and without fee is hereby granted,
 * provided that the above copyright notice appears in all copies and
 * that both the copyright notice and this permission notice appear in
 * supporting documentation.
 *
 * OSF DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE.
 *
 * IN NO EVENT SHALL OSF BE LIABLE FOR ANY SPECIAL, INDIRECT, OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN ACTION OF CONTRACT,
 * NEGLIGENCE, OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
 * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */
/*
 * Copyright (c) 1990 mt Xinu, Inc.  All rights reserved.
 * Copyright (c) 1990 University of Utah.  All rights reserved.
 *
 * This file may be freely distributed in any form as long as
 * this copyright notice is included.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 *	Utah $Hdr: pdc.c 1.8 92/03/14$
 */

#include <sys/param.h>
#include <sys/time.h>
#include "libsa.h"
#include <sys/reboot.h>
#include <sys/disklabel.h>

#include <machine/trap.h>
#include <machine/pdc.h>
#include <machine/iomod.h>
#include <machine/nvm.h>
#include <machine/cpufunc.h>

#include "dev_hppa.h"

/*
 * Interface routines to initialize and access the PDC.
 */

pdcio_t pdc;
int	pdcbuf[64] PDC_ALIGNMENT;/* PDC return buffer */
struct	stable_storage sstor;	/* contents of Stable Storage */
int	sstorsiz;		/* size of Stable Storage */
struct bootdata bd;
int bdsize = sizeof(struct bootdata);

/*
 * Initialize PDC and related variables.
 */
void
pdc_init()
{
	int err;

	/*
	 * Initialize important global variables (defined above).
	 */
	pdc = (pdcio_t)PAGE0->mem_pdc;

	err = (*pdc)(PDC_STABLE, PDC_STABLE_SIZE, pdcbuf, 0, 0);
	if (err >= 0) {
		sstorsiz = min(pdcbuf[0],sizeof(sstor));
		err = (*pdc)(PDC_STABLE, PDC_STABLE_READ, 0, &sstor, sstorsiz);
	}

	/*
	 * Now that we (may) have an output device, if we encountered
	 * an error reading Stable Storage (above), let them know.
	 */
#ifdef DEBUG
	if (debug && err)
		printf("Stable storage PDC_STABLE Read Ret'd %d\n", err);
#endif

	/*
	 * Clear the FAULT light (so we know when we get a real one)
	 */
	(*pdc)(PDC_CHASSIS, PDC_CHASSIS_DISP,
	    PDC_OSTAT(PDC_OSTAT_BOOT) | 0xCEC0);
}

/*
 * Generic READ/WRITE through IODC.  Takes pointer to PDC device
 * information, returns (positive) number of bytes actually read or
 * the (negative) error condition, or zero if at "EOF".
 */
int
iodcstrategy(devdata, rw, blk, size, buf, rsize)
	void *devdata;
	int rw;
	daddr32_t blk;
	size_t size;
	void *buf;
	size_t *rsize;
{
	struct hppa_dev *dp = devdata;
	struct pz_device *pzdev = dp->pz_dev;
	int	offset, xfer, ret;

#ifdef PDCDEBUG
	if (debug)
		printf("iodcstrategy(%p, %s, %u, %u, %p, %p)\n", devdata,
		    rw==F_READ? "READ" : "WRITE", blk, size, buf, rsize);

	if (debug > 1)
		PZDEV_PRINT(pzdev);
#endif

	blk += dp->fsoff;
	blk *= DEV_BSIZE;
	if ((pzdev->pz_class & PCL_CLASS_MASK) == PCL_SEQU) {
		/* rewind and re-read to seek */
		if (blk < dp->last_blk) {
#ifdef PDCDEBUG
			if (debug)
				printf("iodc: rewind ");
#endif
			if ((ret = ((iodcio_t)pzdev->pz_iodc_io)(pzdev->pz_hpa,
			    IODC_IO_READ, pzdev->pz_spa, pzdev->pz_layers,
			    pdcbuf, 0, dp->buf, 0, 0)) < 0) {
#ifdef DEBUG
				if (debug)
					printf("IODC_IO: %d\n", ret);
#endif
				return (EIO);
			} else {
				dp->last_blk = 0;
				dp->last_read = 0;
			}
		}

#ifdef PDCDEBUG
		if (debug)
			printf("seek %d ", dp->last_blk);
#endif
		for (; (dp->last_blk + dp->last_read) <= blk;
		     dp->last_read = ret) {
			twiddle();
			dp->last_blk += dp->last_read;
			if ((ret = ((iodcio_t)pzdev->pz_iodc_io)(pzdev->pz_hpa,
			    IODC_IO_READ, pzdev->pz_spa, pzdev->pz_layers,
			    pdcbuf, dp->last_blk, dp->buf, IODC_IOSIZ,
			    IODC_IOSIZ)) < 0) {
#ifdef DEBUG
				if (debug)
					printf("IODC_IO: %d\n", ret);
#endif
				return (EIO);
			}
			if ((ret = pdcbuf[0]) == 0)
				break;
#ifdef PDCDEBUG
			if (debug)
				printf("-");
#endif
		}
#ifdef PDCDEBUG
		if (debug)
			printf("> %d[%d]\n", dp->last_blk, dp->last_read);
#endif
	}

	xfer = 0;
	/* see if we can scratch anything from buffer */
	if (dp->last_blk <= blk && (dp->last_blk + dp->last_read) > blk) {
		twiddle();
		offset = blk - dp->last_blk;
		xfer = min(dp->last_read - offset, size);
		size -= xfer;
		blk += xfer;
#ifdef PDCDEBUG
		if (debug)
			printf("off=%d,xfer=%d,size=%d,blk=%d\n",
			    offset, xfer, size, blk);
#endif
		bcopy(dp->buf + offset, buf, xfer);
		buf += xfer;
	}

	/*
	 * double buffer it all the time, to cache
	 */
	for (; size; size -= ret, buf += ret, blk += ret, xfer += ret) {
		offset = blk & IOPGOFSET;
		if ((ret = ((iodcio_t)pzdev->pz_iodc_io)(pzdev->pz_hpa,
		    (rw == F_READ? IODC_IO_READ: IODC_IO_WRITE),
		    pzdev->pz_spa, pzdev->pz_layers, pdcbuf,
		    blk - offset, dp->buf, IODC_IOSIZ, IODC_IOSIZ)) < 0) {
#ifdef DEBUG
			if (debug)
				printf("iodc_read(%d,%d): %d\n",
				    blk - offset, IODC_IOSIZ, ret);
#endif
			if (xfer)
				break;
			else
				return (EIO);
		}
		if ((ret = pdcbuf[0]) <= 0)
			break;
		dp->last_blk = blk - offset;
		dp->last_read = ret;
		if ((ret -= offset) > size)
			ret = size;
		bcopy(dp->buf + offset, buf, ret);
#ifdef PDCDEBUG
		if (debug)
			printf("read %d(%d,%d)@@%x ", ret,
			    dp->last_blk, dp->last_read, (u_int)buf);
#endif
	    }

#ifdef PDCDEBUG
	if (debug)
		printf("\n");
#endif

	if (rsize)
		*rsize = xfer;
	return (0);
}

/*
 * Find a device with specified unit number
 * (any if unit == -1), and of specified class (PCL_*).
 */
struct pz_device *
pdc_findev(unit, class)
	int unit, class;
{
	static struct pz_device pz;
	int layers[sizeof(pz.pz_layers)/sizeof(pz.pz_layers[0])];
	struct iomod *io;
	iodcio_t iodc;
	int err = 0;

#ifdef	PDCDEBUG
	if (debug)
		printf("pdc_finddev(%d, %x)\n", unit, class);
#endif
	iodc = (iodcio_t)(PAGE0->mem_free + IODC_MAXSIZE);
	io = (struct iomod *)PAGE0->mem_boot.pz_hpa;

	/* quick hack for boot device */
	if (PAGE0->mem_boot.pz_class == class &&
	    (unit == -1 || PAGE0->mem_boot.pz_layers[0] == unit)) {

		bcopy (&PAGE0->mem_boot.pz_dp, &pz.pz_dp, sizeof(pz.pz_dp));
		bcopy (pz.pz_layers, layers, sizeof(layers));
		if ((err = (pdc)(PDC_IODC, PDC_IODC_READ, pdcbuf, io,
		    IODC_INIT, iodc, IODC_MAXSIZE)) < 0) {
#ifdef DEBUG
			if (debug)
				printf("IODC_READ: %d\n", err);
#endif
			return NULL;
		}
	} else {
		struct pdc_memmap memmap;
		struct iodc_data mptr;
		int i, stp;

		for (i = 0; i < 0xf; i++) {
			pz.pz_bc[0] = pz.pz_bc[1] =
			pz.pz_bc[2] = pz.pz_bc[3] = -1;
			pz.pz_bc[4] = 2;
			pz.pz_bc[5] = 0;	/* core bus */
			pz.pz_mod = i;
			if ((pdc)(PDC_MEMMAP, PDC_MEMMAP_HPA, &memmap,
			    &pz.pz_dp) < 0)
				continue;
#ifdef PDCDEBUG
			if (debug)
				printf("memap: %d.%d.%d, hpa=%x, mpgs=%x\n",
				    pz.pz_bc[4], pz.pz_bc[5], pz.pz_mod,
				    memmap.hpa, memmap.morepages);
#endif
			io = (struct iomod *) memmap.hpa;

			if ((err = (pdc)(PDC_IODC, PDC_IODC_READ, &pdcbuf, io,
			    IODC_DATA, &mptr, sizeof(mptr))) < 0) {
#ifdef DEBUG
				if (debug)
					printf("IODC_DATA: %d\n", err);
#endif
				continue;
			}

			if ((err = (pdc)(PDC_IODC, PDC_IODC_READ, pdcbuf, io,
			    IODC_INIT, iodc, IODC_MAXSIZE)) < 0) {
#ifdef DEBUG
				if (debug)
					printf("IODC_READ: %d\n", err);
#endif
				continue;
			}

			stp = IODC_INIT_FIRST;
			do {
				if ((err = (iodc)((u_int)io, stp, io->io_spa,
				    layers, pdcbuf, 0, 0, 0, 0)) < 0) {
#ifdef DEBUG
					if (debug && err != PDC_ERR_EOD)
						printf("IODC_INIT_%s: %d\n",
						    stp==IODC_INIT_FIRST?
						    "FIRST":"NEXT", err);
#endif
					break;
				}
#ifdef PDCDEBUG
				if (debug)
					printf("[%x,%x,%x,%x,%x,%x], "
					    "[%x,%x,%x,%x,%x,%x]\n",
					    pdcbuf[0], pdcbuf[1], pdcbuf[2],
					    pdcbuf[3], pdcbuf[4], pdcbuf[5],
					    layers[0], layers[1], layers[2],
					    layers[3], layers[4], layers[5]);
#endif
				stp = IODC_INIT_NEXT;

			} while (pdcbuf[1] != class &&
				 unit != -1 && unit != layers[0]);

			if (err >= 0)
				break;
		}
	}

	if (err >= 0) {
		/* init device */
		if (0  && (err = (iodc)((u_int)io, IODC_INIT_DEV, io->io_spa,
		    layers, pdcbuf, 0, 0, 0, 0)) < 0) {
#ifdef DEBUG
			if (debug)
				printf("INIT_DEV: %d\n", err);
#endif
			return NULL;
		}

		/* read i/o entry code */
		if ((err = (pdc)(PDC_IODC, PDC_IODC_READ, pdcbuf, io,
		    IODC_IO, iodc, IODC_MAXSIZE)) < 0) {
#ifdef DEBUG
			if (debug)
				printf("IODC_READ: %d\n", err);
#endif
			return NULL;
		}

		pz.pz_flags = 0;
		bcopy(layers, pz.pz_layers, sizeof(pz.pz_layers));
		pz.pz_hpa = (u_int)io;
/* XXX		pz.pz_spa = io->io_spa; */
		pz.pz_iodc_io = (u_int)iodc;
		pz.pz_class = class;

		return &pz;
	}

	return NULL;
}

static __inline void
fall(int c_base, int c_count, int c_loop, int c_stride, int data)
{
        int loop;                  /* Internal vars */

        for (; c_count--; c_base += c_stride)
                for (loop = c_loop; loop--; )
			if (data)
				fdce(0, c_base);
			else
				fice(0, c_base);
}

/*
 * fcacheall - Flush all caches.
 *
 * This routine is just a wrapper around the real cache flush routine.
 */
struct pdc_cache pdc_cacheinfo PDC_ALIGNMENT;

void
fcacheall()
{
	int err;

        if ((err = (*pdc)(PDC_CACHE, PDC_CACHE_DFLT, &pdc_cacheinfo)) < 0) {
#ifdef DEBUG
		if (debug)
			printf("fcacheall: PDC_CACHE failed (%d).\n", err);
#endif
		return;
        }
#if PDCDEBUG
	if (debug)
		printf("pdc_cache:\nic={%u,%x,%x,%u,%u,%u}\n"
		       "dc={%u,%x,%x,%u,%u,%u}\n",
		       pdc_cacheinfo.ic_size, *(u_int *)&pdc_cacheinfo.ic_conf,
		       pdc_cacheinfo.ic_base, pdc_cacheinfo.ic_stride,
		       pdc_cacheinfo.ic_count, pdc_cacheinfo.ic_loop,
		       pdc_cacheinfo.dc_size, *(u_int *)&pdc_cacheinfo.ic_conf,
		       pdc_cacheinfo.dc_base, pdc_cacheinfo.dc_stride,
		       pdc_cacheinfo.dc_count, pdc_cacheinfo.dc_loop);
#endif
        /*
         * Flush the instruction, then data cache.
         */
        fall(pdc_cacheinfo.ic_base, pdc_cacheinfo.ic_count,
	     pdc_cacheinfo.ic_loop, pdc_cacheinfo.ic_stride, 0);
	sync_caches();
        fall(pdc_cacheinfo.dc_base, pdc_cacheinfo.dc_count,
	     pdc_cacheinfo.dc_loop, pdc_cacheinfo.dc_stride, 1);
	sync_caches();
}
@


1.20
log
@Change daddr_t to daddr32_t.  The bootblocks on our architectures only
do 32-bit block spanning.  If later on we get some that can/should do
64-bit, that can be done now using daddr64_t (but of course, we are taking
this step to finalize the daddr_t 64-bit conversion).
ok miod krw
@
text
@d1 1
a1 1
/*	$OpenBSD: pdc.c,v 1.19 2005/04/07 00:21:51 mickey Exp $	*/
d62 1
a71 1
#include <machine/param.h>
d150 1
a150 1
	blk <<= DEV_BSHIFT;
@


1.19
log
@64bit-friendly pdc.h and iomod.h and correspondent changes elsewhere
@
text
@d1 1
a1 1
/*	$OpenBSD: pdc.c,v 1.18 2004/04/07 18:24:20 mickey Exp $	*/
d131 1
a131 1
	daddr_t blk;
@


1.18
log
@update copyright; miod@@ is fine w/ files where he holds it too
@
text
@d1 1
a1 1
/*	$OpenBSD: pdc.c,v 1.17 2003/08/11 06:51:45 mickey Exp $	*/
d158 1
a158 1
			if ((ret = (pzdev->pz_iodc_io)(pzdev->pz_hpa,
d180 1
a180 1
			if ((ret = (pzdev->pz_iodc_io)(pzdev->pz_hpa,
d225 1
a225 1
		if ((ret = (pzdev->pz_iodc_io)(pzdev->pz_hpa,
d282 1
a282 1
	io = PAGE0->mem_boot.pz_hpa;
d340 2
a341 2
				if ((err = (iodc)(io, stp, io->io_spa, layers,
				    pdcbuf, 0, 0, 0, 0)) < 0) {
d371 1
a371 1
		if (0  && (err = (iodc)(io, IODC_INIT_DEV, io->io_spa,
d392 1
a392 1
		pz.pz_hpa = io;
d394 1
a394 1
		pz.pz_iodc_io = iodc;
@


1.17
log
@a few strict protos
@
text
@d1 1
a1 1
/*	$OpenBSD: pdc.c,v 1.16 2003/04/30 23:03:55 mickey Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998 Michael Shalayeff
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Michael Shalayeff.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d19 8
a26 7
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@


1.16
log
@do not be hungry for buffers and allocate lower than a max (for iodc io)
@
text
@d1 1
a1 1
/*	$OpenBSD: pdc.c,v 1.15 2003/04/30 04:09:38 mickey Exp $	*/
d408 1
a408 2
fall(c_base, c_count, c_loop, c_stride, data)
	int c_base, c_count, c_loop, c_stride, data;
@


1.15
log
@no need to twiddle here. it's twiddling elsewhere already
@
text
@d1 1
a1 1
/*	$OpenBSD: pdc.c,v 1.14 2003/04/16 07:20:50 mickey Exp $	*/
d147 1
a147 1
		    rw==F_READ?"READ":"WRITE", blk, size, buf, rsize);
a161 1
			twiddle();
d186 2
a187 2
			    pdcbuf, dp->last_blk, dp->buf, IODC_MAXIOSIZ,
			    IODC_MAXIOSIZ)) < 0) {
d232 1
a232 2
		    blk - offset, dp->buf, IODC_MAXIOSIZ,
		    IODC_MAXIOSIZ)) < 0) {
d236 1
a236 1
				    blk - offset, IODC_MAXIOSIZ, ret);
@


1.14
log
@clean some spaces and registers and other fluff
@
text
@d1 1
a1 1
/*	$OpenBSD: pdc.c,v 1.13 2003/01/14 11:40:18 mickey Exp $	*/
a228 1
		twiddle();
@


1.13
log
@during the open store the partition offset and do subsequent io relative to that offset, allows reading kernel from scsi disk
@
text
@d1 1
a1 1
/*	$OpenBSD: pdc.c,v 1.12 2002/12/19 00:39:01 mickey Exp $	*/
a463 1

@


1.12
log
@knf, remove register, space trim
@
text
@d1 1
a1 1
/*	$OpenBSD: pdc.c,v 1.11 2002/03/14 03:15:53 millert Exp $	*/
d153 1
@


1.11
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: pdc.c,v 1.10 1999/05/06 02:27:44 mickey Exp $	*/
d33 19
a51 19
 * Copyright 1996 1995 by Open Software Foundation, Inc.   
 *              All Rights Reserved 
 *  
 * Permission to use, copy, modify, and distribute this software and 
 * its documentation for any purpose and without fee is hereby granted, 
 * provided that the above copyright notice appears in all copies and 
 * that both the copyright notice and this permission notice appear in 
 * supporting documentation. 
 *  
 * OSF DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE 
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS 
 * FOR A PARTICULAR PURPOSE. 
 *  
 * IN NO EVENT SHALL OSF BE LIABLE FOR ANY SPECIAL, INDIRECT, OR 
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM 
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN ACTION OF CONTRACT, 
 * NEGLIGENCE, OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION 
 * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. 
 * 
d122 2
a123 2
	(void) (*pdc)(PDC_CHASSIS, PDC_CHASSIS_DISP,
		      PDC_OSTAT(PDC_OSTAT_BOOT) | 0xCEC0);
d142 1
a142 1
	register int	offset, xfer, ret;
d147 1
a147 1
		       rw==F_READ?"READ":"WRITE", blk, size, buf, rsize);
d163 2
a164 2
				IODC_IO_READ, pzdev->pz_spa, pzdev->pz_layers,
				pdcbuf, 0, dp->buf, 0, 0)) < 0) {
d185 3
a187 3
				IODC_IO_READ, pzdev->pz_spa, pzdev->pz_layers,
				pdcbuf, dp->last_blk, dp->buf, IODC_MAXIOSIZ,
				IODC_MAXIOSIZ)) < 0) {
d218 1
a218 1
			       offset, xfer, size, blk);
d231 4
a234 4
				(rw == F_READ? IODC_IO_READ: IODC_IO_WRITE),
				pzdev->pz_spa, pzdev->pz_layers, pdcbuf,
				blk - offset, dp->buf, IODC_MAXIOSIZ,
				IODC_MAXIOSIZ)) < 0) {
d238 1
a238 1
					blk - offset, IODC_MAXIOSIZ, ret);
d255 1
a255 1
			       dp->last_blk, dp->last_read, (u_int)buf);
d279 3
a281 3
	register iodcio_t iodc;
	register struct iomod *io;
	register int err = 0;
d297 1
a297 1
				  IODC_INIT, iodc, IODC_MAXSIZE)) < 0) {
d307 1
a307 1
		register int i, stp;
d316 1
a316 1
				  &pz.pz_dp) < 0)
d321 2
a322 2
				       pz.pz_bc[4], pz.pz_bc[5], pz.pz_mod,
				       memmap.hpa, memmap.morepages);
d327 1
a327 1
				   IODC_DATA, &mptr, sizeof(mptr))) < 0) {
d336 1
a336 1
					  IODC_INIT, iodc, IODC_MAXSIZE)) < 0) {
d347 1
a347 1
						  pdcbuf, 0, 0, 0, 0)) < 0) {
d351 2
a352 2
						       stp==IODC_INIT_FIRST?
						       "FIRST":"NEXT", err);
d359 5
a363 5
					       "[%x,%x,%x,%x,%x,%x]\n",
					       pdcbuf[0], pdcbuf[1], pdcbuf[2],
					       pdcbuf[3], pdcbuf[4], pdcbuf[5],
					       layers[0], layers[1], layers[2],
					       layers[3], layers[4], layers[5]);
d378 1
a378 1
				  layers, pdcbuf, 0, 0, 0, 0)) < 0) {
d388 1
a388 1
			  	IODC_IO, iodc, IODC_MAXSIZE)) < 0) {
d411 1
a411 1
	int c_base, c_count, c_loop, c_stride, data; 
d413 1
a413 1
        register int loop;                  /* Internal vars */
a420 1
        
d430 1
a430 1
void 
d433 1
a433 1
	register int err;
d446 2
a447 2
		       pdc_cacheinfo.ic_size, *(u_int *)&pdc_cacheinfo.ic_conf, 
		       pdc_cacheinfo.ic_base, pdc_cacheinfo.ic_stride, 
d449 2
a450 2
		       pdc_cacheinfo.dc_size, *(u_int *)&pdc_cacheinfo.ic_conf, 
		       pdc_cacheinfo.dc_base, pdc_cacheinfo.dc_stride, 
d456 2
a457 2
        fall (pdc_cacheinfo.ic_base, pdc_cacheinfo.ic_count,
	      pdc_cacheinfo.ic_loop, pdc_cacheinfo.ic_stride, 0);
d459 2
a460 2
        fall (pdc_cacheinfo.dc_base, pdc_cacheinfo.dc_count,
	      pdc_cacheinfo.dc_loop, pdc_cacheinfo.dc_stride, 1);
@


1.10
log
@needs machine/trap.h
@
text
@d1 1
a1 1
/*	$OpenBSD: pdc.c,v 1.9 1999/04/20 20:01:02 mickey Exp $	*/
d447 1
a447 1
		       pdc_cacheinfo.ic_size, *(u_int*)&pdc_cacheinfo.ic_conf, 
d450 1
a450 1
		       pdc_cacheinfo.dc_size, *(u_int*)&pdc_cacheinfo.ic_conf, 
@


1.10.14.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pdc.c,v 1.10 1999/05/06 02:27:44 mickey Exp $	*/
d447 1
a447 1
		       pdc_cacheinfo.ic_size, *(u_int *)&pdc_cacheinfo.ic_conf, 
d450 1
a450 1
		       pdc_cacheinfo.dc_size, *(u_int *)&pdc_cacheinfo.ic_conf, 
@


1.10.14.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d33 19
a51 19
 * Copyright 1996 1995 by Open Software Foundation, Inc.
 *              All Rights Reserved
 *
 * Permission to use, copy, modify, and distribute this software and
 * its documentation for any purpose and without fee is hereby granted,
 * provided that the above copyright notice appears in all copies and
 * that both the copyright notice and this permission notice appear in
 * supporting documentation.
 *
 * OSF DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE.
 *
 * IN NO EVENT SHALL OSF BE LIABLE FOR ANY SPECIAL, INDIRECT, OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN ACTION OF CONTRACT,
 * NEGLIGENCE, OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
 * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
d122 2
a123 2
	(*pdc)(PDC_CHASSIS, PDC_CHASSIS_DISP,
	    PDC_OSTAT(PDC_OSTAT_BOOT) | 0xCEC0);
d142 1
a142 1
	int	offset, xfer, ret;
d147 1
a147 1
		    rw==F_READ? "READ" : "WRITE", blk, size, buf, rsize);
a152 1
	blk += dp->fsoff;
d161 1
d163 2
a164 2
			    IODC_IO_READ, pzdev->pz_spa, pzdev->pz_layers,
			    pdcbuf, 0, dp->buf, 0, 0)) < 0) {
d185 3
a187 3
			    IODC_IO_READ, pzdev->pz_spa, pzdev->pz_layers,
			    pdcbuf, dp->last_blk, dp->buf, IODC_IOSIZ,
			    IODC_IOSIZ)) < 0) {
d218 1
a218 1
			    offset, xfer, size, blk);
d228 1
d231 4
a234 3
		    (rw == F_READ? IODC_IO_READ: IODC_IO_WRITE),
		    pzdev->pz_spa, pzdev->pz_layers, pdcbuf,
		    blk - offset, dp->buf, IODC_IOSIZ, IODC_IOSIZ)) < 0) {
d238 1
a238 1
				    blk - offset, IODC_IOSIZ, ret);
d255 1
a255 1
			    dp->last_blk, dp->last_read, (u_int)buf);
d279 3
a281 3
	struct iomod *io;
	iodcio_t iodc;
	int err = 0;
d297 1
a297 1
		    IODC_INIT, iodc, IODC_MAXSIZE)) < 0) {
d307 1
a307 1
		int i, stp;
d316 1
a316 1
			    &pz.pz_dp) < 0)
d321 2
a322 2
				    pz.pz_bc[4], pz.pz_bc[5], pz.pz_mod,
				    memmap.hpa, memmap.morepages);
d327 1
a327 1
			    IODC_DATA, &mptr, sizeof(mptr))) < 0) {
d336 1
a336 1
			    IODC_INIT, iodc, IODC_MAXSIZE)) < 0) {
d347 1
a347 1
				    pdcbuf, 0, 0, 0, 0)) < 0) {
d351 2
a352 2
						    stp==IODC_INIT_FIRST?
						    "FIRST":"NEXT", err);
d359 5
a363 5
					    "[%x,%x,%x,%x,%x,%x]\n",
					    pdcbuf[0], pdcbuf[1], pdcbuf[2],
					    pdcbuf[3], pdcbuf[4], pdcbuf[5],
					    layers[0], layers[1], layers[2],
					    layers[3], layers[4], layers[5]);
d378 1
a378 1
		    layers, pdcbuf, 0, 0, 0, 0)) < 0) {
d388 1
a388 1
		    IODC_IO, iodc, IODC_MAXSIZE)) < 0) {
d411 1
a411 1
	int c_base, c_count, c_loop, c_stride, data;
d413 1
a413 1
        int loop;                  /* Internal vars */
d421 1
d431 1
a431 1
void
d434 1
a434 1
	int err;
d447 2
a448 2
		       pdc_cacheinfo.ic_size, *(u_int *)&pdc_cacheinfo.ic_conf,
		       pdc_cacheinfo.ic_base, pdc_cacheinfo.ic_stride,
d450 2
a451 2
		       pdc_cacheinfo.dc_size, *(u_int *)&pdc_cacheinfo.ic_conf,
		       pdc_cacheinfo.dc_base, pdc_cacheinfo.dc_stride,
d457 2
a458 2
        fall(pdc_cacheinfo.ic_base, pdc_cacheinfo.ic_count,
	     pdc_cacheinfo.ic_loop, pdc_cacheinfo.ic_stride, 0);
d460 2
a461 2
        fall(pdc_cacheinfo.dc_base, pdc_cacheinfo.dc_count,
	     pdc_cacheinfo.dc_loop, pdc_cacheinfo.dc_stride, 1);
d464 1
@


1.10.4.1
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d447 1
a447 1
		       pdc_cacheinfo.ic_size, *(u_int *)&pdc_cacheinfo.ic_conf, 
d450 1
a450 1
		       pdc_cacheinfo.dc_size, *(u_int *)&pdc_cacheinfo.ic_conf, 
@


1.10.4.2
log
@Sync the SMP branch with 3.3
@
text
@d33 19
a51 19
 * Copyright 1996 1995 by Open Software Foundation, Inc.
 *              All Rights Reserved
 *
 * Permission to use, copy, modify, and distribute this software and
 * its documentation for any purpose and without fee is hereby granted,
 * provided that the above copyright notice appears in all copies and
 * that both the copyright notice and this permission notice appear in
 * supporting documentation.
 *
 * OSF DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE.
 *
 * IN NO EVENT SHALL OSF BE LIABLE FOR ANY SPECIAL, INDIRECT, OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN ACTION OF CONTRACT,
 * NEGLIGENCE, OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
 * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
d122 2
a123 2
	(*pdc)(PDC_CHASSIS, PDC_CHASSIS_DISP,
	    PDC_OSTAT(PDC_OSTAT_BOOT) | 0xCEC0);
d142 1
a142 1
	int	offset, xfer, ret;
d147 1
a147 1
		    rw==F_READ?"READ":"WRITE", blk, size, buf, rsize);
a152 1
	blk += dp->fsoff;
d163 2
a164 2
			    IODC_IO_READ, pzdev->pz_spa, pzdev->pz_layers,
			    pdcbuf, 0, dp->buf, 0, 0)) < 0) {
d185 3
a187 3
			    IODC_IO_READ, pzdev->pz_spa, pzdev->pz_layers,
			    pdcbuf, dp->last_blk, dp->buf, IODC_MAXIOSIZ,
			    IODC_MAXIOSIZ)) < 0) {
d218 1
a218 1
			    offset, xfer, size, blk);
d231 4
a234 4
		    (rw == F_READ? IODC_IO_READ: IODC_IO_WRITE),
		    pzdev->pz_spa, pzdev->pz_layers, pdcbuf,
		    blk - offset, dp->buf, IODC_MAXIOSIZ,
		    IODC_MAXIOSIZ)) < 0) {
d238 1
a238 1
				    blk - offset, IODC_MAXIOSIZ, ret);
d255 1
a255 1
			    dp->last_blk, dp->last_read, (u_int)buf);
d279 3
a281 3
	struct iomod *io;
	iodcio_t iodc;
	int err = 0;
d297 1
a297 1
		    IODC_INIT, iodc, IODC_MAXSIZE)) < 0) {
d307 1
a307 1
		int i, stp;
d316 1
a316 1
			    &pz.pz_dp) < 0)
d321 2
a322 2
				    pz.pz_bc[4], pz.pz_bc[5], pz.pz_mod,
				    memmap.hpa, memmap.morepages);
d327 1
a327 1
			    IODC_DATA, &mptr, sizeof(mptr))) < 0) {
d336 1
a336 1
			    IODC_INIT, iodc, IODC_MAXSIZE)) < 0) {
d347 1
a347 1
				    pdcbuf, 0, 0, 0, 0)) < 0) {
d351 2
a352 2
						    stp==IODC_INIT_FIRST?
						    "FIRST":"NEXT", err);
d359 5
a363 5
					    "[%x,%x,%x,%x,%x,%x]\n",
					    pdcbuf[0], pdcbuf[1], pdcbuf[2],
					    pdcbuf[3], pdcbuf[4], pdcbuf[5],
					    layers[0], layers[1], layers[2],
					    layers[3], layers[4], layers[5]);
d378 1
a378 1
		    layers, pdcbuf, 0, 0, 0, 0)) < 0) {
d388 1
a388 1
		    IODC_IO, iodc, IODC_MAXSIZE)) < 0) {
d411 1
a411 1
	int c_base, c_count, c_loop, c_stride, data;
d413 1
a413 1
        int loop;                  /* Internal vars */
d421 1
d431 1
a431 1
void
d434 1
a434 1
	int err;
d447 2
a448 2
		       pdc_cacheinfo.ic_size, *(u_int *)&pdc_cacheinfo.ic_conf,
		       pdc_cacheinfo.ic_base, pdc_cacheinfo.ic_stride,
d450 2
a451 2
		       pdc_cacheinfo.dc_size, *(u_int *)&pdc_cacheinfo.ic_conf,
		       pdc_cacheinfo.dc_base, pdc_cacheinfo.dc_stride,
d457 2
a458 2
        fall(pdc_cacheinfo.ic_base, pdc_cacheinfo.ic_count,
	     pdc_cacheinfo.ic_loop, pdc_cacheinfo.ic_stride, 0);
d460 2
a461 2
        fall(pdc_cacheinfo.dc_base, pdc_cacheinfo.dc_count,
	     pdc_cacheinfo.dc_loop, pdc_cacheinfo.dc_stride, 1);
@


1.10.4.3
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: pdc.c,v 1.10.4.2 2003/03/27 23:26:54 niklas Exp $	*/
d147 1
a147 1
		    rw==F_READ? "READ" : "WRITE", blk, size, buf, rsize);
d162 1
d187 2
a188 2
			    pdcbuf, dp->last_blk, dp->buf, IODC_IOSIZ,
			    IODC_IOSIZ)) < 0) {
d229 1
d234 2
a235 1
		    blk - offset, dp->buf, IODC_IOSIZ, IODC_IOSIZ)) < 0) {
d239 1
a239 1
				    blk - offset, IODC_IOSIZ, ret);
d464 1
@


1.10.4.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d408 2
a409 1
fall(int c_base, int c_count, int c_loop, int c_stride, int data)
@


1.10.4.5
log
@Merge with the trunk
@
text
@d4 1
a4 1
 * Copyright (c) 1998-2004 Michael Shalayeff
d15 5
d24 7
a30 8
 * IN NO EVENT SHALL THE AUTHOR OR HIS RELATIVES BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
@


1.9
log
@fix different alignment problems
correct PDC/IODC call formats
factor some more code out to the dev_hppa.c routines
basically boot on many more machine by now
@
text
@d1 1
a1 1
/*	$OpenBSD: pdc.c,v 1.8 1999/02/13 04:43:18 mickey Exp $	*/
d71 1
@


1.8
log
@remove local cvs Id
@
text
@d1 1
a1 1
/*	$OpenBSD: pdc.c,v 1.7 1999/01/25 20:16:07 mickey Exp $	*/
a141 2
	register char	*bbuf = (void*)		/* align */
		((((int)dp->buf) + MINIOSIZ - 1) & ~(MINIOSIZ - 1));
d163 1
a163 1
				pdcbuf, 0, bbuf, 0, 0)) < 0) {
d184 3
a186 3
				IODC_IO_READ,
				pzdev->pz_spa, pzdev->pz_layers, pdcbuf,
				dp->last_blk, bbuf, BTIOSIZ, BTIOSIZ)) < 0) {
d219 1
a219 1
		bcopy(bbuf + offset, buf, xfer);
d232 2
a233 1
				blk - offset, bbuf, BTIOSIZ, BTIOSIZ)) < 0) {
d237 1
a237 1
					blk - offset, BTIOSIZ, ret);
d250 1
a250 1
		bcopy(bbuf + offset, buf, ret);
@


1.7
log
@mask one more debug printf out
@
text
@d1 1
a1 1
/*	$OpenBSD: pdc.c,v 1.6 1998/12/13 06:45:05 mickey Exp $	*/
d237 2
a238 1
				printf("IODC_IO: %d\n", ret);
d240 4
a243 1
			return (EIO);
@


1.6
log
@use PDC_ALIGNMENT; oops
@
text
@d1 1
a1 1
/*	$OpenBSD: pdc.c,v 1.5 1998/12/13 06:41:43 mickey Exp $	*/
d216 1
a216 1
#ifdef DEBUG
@


1.5
log
@PDC_ALIGNMENT; remove global chasdata
@
text
@d1 1
a1 1
/*	$OpenBSD: pdc.c,v 1.4 1998/10/30 19:40:22 mickey Exp $	*/
d425 1
a425 1
struct pdc_cache pdc_cacheinfo __attribute__ ((aligned(8)));
@


1.4
log
@don't call INIT code since that seems
to confuse older boxens IODC code.
@
text
@d1 1
a1 1
/*	$OpenBSD: pdc.c,v 1.3 1998/09/29 07:27:02 mickey Exp $	*/
d84 1
a84 2
int	pdcbuf[64]		/* PDC return buffer */
		__attribute ((aligned(8)));
a88 1
u_int chasdata;
d121 2
a122 2
	chasdata = PDC_OSTAT(PDC_OSTAT_BOOT) | 0xCEC0;
	(void) (*pdc)(PDC_CHASSIS, PDC_CHASSIS_DISP, chasdata);
@


1.3
log
@add iodcstrategy() -- generic strategy through IODC routine
add device finger/mapper
@
text
@d1 1
a1 1
/*	$OpenBSD: pdc.c,v 1.2 1998/07/08 21:34:37 mickey Exp $	*/
d276 2
a277 4
	iodcio_t iodc;
	struct pdc_memmap memmap;
	struct iodc_data mptr;
	int layers[6];
d279 1
a279 1
	register int i, err, stp;
d286 1
a286 2
	err = 0;
	io = NULL;
a291 1
		io = PAGE0->mem_boot.pz_hpa;
d303 3
d375 1
a375 1
		if ((err = (iodc)(io, IODC_INIT_DEV, io->io_spa,
d383 1
d395 1
a395 1
		bcopy(layers, pz.pz_layers, sizeof(layers));
d397 1
a397 1
		pz.pz_spa = io->io_spa;
d400 1
@


1.2
log
@use those new pdc call types
@
text
@d1 1
a1 1
/*	$OpenBSD: pdc.c,v 1.1.1.1 1998/06/23 18:46:42 mickey Exp $	*/
d4 29
a70 2
#include "dev_hppa.h"

a71 1
#include <machine/iodc.h>
d74 2
d77 1
a77 1
#define MIN(a,b) ((a) < (b) ? (a) : (b))
d84 2
a85 1
int	pdcbuf[64] __attribute ((aligned(8)));		/* PDC return buffer */
a87 1
unsigned int rstaddr;
d90 1
a90 3
unsigned int chasdata;

extern unsigned int howto, bootdev;
d107 1
a107 1
		sstorsiz = MIN(pdcbuf[0],sizeof(sstor));
d115 2
a116 1
	if (err)
d118 1
d128 3
a130 1
 * Read in `bootdev' and `howto' from Non-Volatile Memory.
d132 8
a139 2
void
getbinfo()
d141 37
a177 1
	int err;
d179 24
a202 23
	/*
	 * Try to read bootdata from NVM through PDC.
	 * If successful, set `howto' and `bootdev'.
	 */
	if ((err = (*pdc)(PDC_NVM, PDC_NVM_READ, NVM_BOOTDATA, &bd, bdsize)) < 0) {
		/*
		 * First, determine if this machine has Non-Volatile Memory.
		 * If not, just return (until we come up with a new plan)!
		 */
		if (err == -1)		/* Nonexistent procedure */
			return;
		printf("NVM bootdata Read ret'd %d\n", err);
	} else {
		if (bd.cksum == NVM_BOOTCKSUM(bd)) {
			/*
			 * The user may override the PDC auto-boot, setting
			 * an interactive boot.  We give them this right by
			 * or'ing the bootaddr flags into `howto'.
			 */
			howto |= bd.flags;
			bootdev = bd.device;
		} else {
			printf("NVM bootdata Bad Checksum (%x)\n", bd.cksum);
d204 21
d228 1
a228 1
	 * Reset the bootdata to defaults (if necessary).
d230 35
a264 8
	if (bd.flags != RB_AUTOBOOT || bd.device != 0) {
		bd.flags = RB_AUTOBOOT;
		bd.device = 0;
		bd.cksum = NVM_BOOTCKSUM(bd);
		if ((err = (*pdc)(PDC_NVM, PDC_NVM_WRITE, NVM_BOOTDATA,
				  &bd, bdsize)) < 0)
			printf("NVM bootdata Write ret'd %d\n", err);
	}
d268 2
a269 3
 * Generic READ/WRITE through IODC.  Takes pointer to PDC device
 * information, returns (positive) number of bytes actually read or
 * the (negative) error condition, or zero if at "EOF".
d271 3
a273 7
int
iodc_rw(maddr, daddr, count, func, pzdev)
	char * maddr; /* io->i_ma = labelbuf */
	unsigned int daddr;
	unsigned int count;   /* io->i_cc = DEV_BSIZE */
	int func;      
	struct pz_device *pzdev;
d275 90
a364 9
	register int	offset;
	register int	xfer_cnt = 0;
	register int	ret;

	if (pzdev == 0)		/* default: use BOOT device */ 
		pzdev = &PAGE0->mem_boot;
	
	if (pzdev->pz_iodc_io == 0)
		return(-1);
d366 4
a369 34
	/*
	 * IODC arguments are constrained in a number of ways.  If the
	 * request doesn't fit one or more of these constraints, we have
	 * to do the transfer to a buffer and copy it.
	 */
	if ((((int)maddr)&(MINIOSIZ-1))||(count&IOPGOFSET)||(daddr&IOPGOFSET))
	    for (; count > 0; count -= ret, maddr += ret, daddr += ret) {
		offset = daddr & IOPGOFSET;
		if ((ret = (*pzdev->pz_iodc_io)(pzdev->pz_hpa,
					(func == F_READ)? IODC_IO_BOOTIN:
							  IODC_IO_BOOTOUT,
					pzdev->pz_spa, pzdev->pz_layers, pdcbuf,
					daddr - offset, btbuf, BTIOSIZ,
					BTIOSIZ)) < 0)
			return (ret);
		if ((ret = pdcbuf[0]) == 0)
			break;
		if ((ret -= offset) > count)
			ret = count;
		bcopy(btbuf + offset, maddr, ret);
		xfer_cnt += ret;
	    }
	else 
		for (; count > 0; count -= ret, maddr += ret, daddr += ret) {
			if ((offset = count) > MAXIOSIZ)
				offset = MAXIOSIZ;
			if ((ret = (*pzdev->pz_iodc_io)(pzdev->pz_hpa,
					(func == F_READ)? IODC_IO_BOOTIN:
							  IODC_IO_BOOTOUT,
					pzdev->pz_spa, pzdev->pz_layers,
					pdcbuf, daddr, maddr, offset,
					count)) < 0)
				return (ret);
			if ((ret = pdcbuf[0]) == 0)
d371 21
a391 1
			xfer_cnt += ret;
d394 25
a418 1
	return (xfer_cnt);
d420 42
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d55 1
a55 1
int (*pdc)();
d77 1
a77 1
	pdc = PAGE0->mem_pdc;
@


1.1.1.1
log
@ok, it boots, include and libkern to come
@
text
@@
