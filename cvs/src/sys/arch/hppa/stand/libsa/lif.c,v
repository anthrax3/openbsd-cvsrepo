head	1.10;
access;
symbols
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.10.0.48
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.44
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.10.0.46
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.38
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.10.0.42
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.10.0.40
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.10.0.36
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.10.0.34
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.32
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.30
	OPENBSD_5_0:1.10.0.28
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.26
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.10.0.24
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.20
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.10.0.22
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.18
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.16
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.14
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.12
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.10
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.8
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.10.0.6
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.4
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.2
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.9.0.2
	OPENBSD_3_6_BASE:1.9
	SMP_SYNC_A:1.9
	SMP_SYNC_B:1.9
	OPENBSD_3_5:1.8.0.4
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.8.0.2
	OPENBSD_3_4_BASE:1.8
	UBC_SYNC_A:1.8
	OPENBSD_3_3:1.7.0.10
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.8
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.7.0.6
	OPENBSD_3_1_BASE:1.7
	UBC_SYNC_B:1.7
	UBC:1.7.0.4
	UBC_BASE:1.7
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9:1.6.0.10
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_8:1.6.0.8
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.6
	OPENBSD_2_7_BASE:1.6
	SMP:1.6.0.4
	SMP_BASE:1.6
	kame_19991208:1.6
	OPENBSD_2_6:1.6.0.2
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.3.0.2
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.2.0.2
	OPENBSD_2_4_BASE:1.2;
locks; strict;
comment	@ * @;


1.10
date	2004.11.22.18.41.41;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	2004.04.07.18.24.20;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	2003.04.16.07.20.50;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	2001.06.09.03.54.41;	author mickey;	state Exp;
branches
	1.7.4.1;
next	1.6;

1.6
date	99.05.31.02.41.11;	author todd;	state Exp;
branches
	1.6.4.1;
next	1.5;

1.5
date	99.05.06.02.26.49;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	99.05.03.22.46.38;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	99.01.25.20.15.23;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	98.09.29.07.17.00;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	98.07.30.16.01.48;	author mickey;	state Exp;
branches;
next	;

1.6.4.1
date	2001.07.04.10.16.13;	author niklas;	state Exp;
branches;
next	1.6.4.2;

1.6.4.2
date	2003.05.13.19.41.04;	author ho;	state Exp;
branches;
next	1.6.4.3;

1.6.4.3
date	2004.06.05.23.10.49;	author niklas;	state Exp;
branches;
next	;

1.7.4.1
date	2003.05.19.21.43.13;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.10
log
@better types; from hppa64 (;
@
text
@/*	$OpenBSD: lif.c,v 1.9 2004/04/07 18:24:20 mickey Exp $	*/

/*
 * Copyright (c) 1998-2004 Michael Shalayeff
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR OR HIS RELATIVES BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/disklabel.h>
#include "libsa.h"

extern int debug;

struct file {
	char f_buf[LIF_FILESTART];/* buffer for lif volume header and dir */
	struct lifvol *f_lp;	/* lif volume header pointer */
	struct lifdir *f_ld;	/* lif dir pointer */
	int	f_nfiles;	/* gross number for lif dir entries */

	off_t	f_seek;		/* seek pointer for file read */
	struct lifdir *f_rd;	/* lif dir pointer for readdir */

	int	f_isdir;	/* special hacky flag for '.' dir */
	int	f_count;	/* this file length */
	int	f_off;		/* this file offset */
};

int
lif_open (path, f)
	char *path;
	struct open_file *f;
{
	struct file *fp;
	struct lifdir *dp;
	char *p, *q;
	struct lif_load load;
	size_t buf_size;
	int err, l;

#ifdef LIFDEBUG
	if (debug)
		printf("lif_open(%s, %p)\n", path, f);
#endif

	fp = alloc(sizeof(*fp));
	/* XXX we're assuming here that sizeof(fp->f_buf) >= LIF_FILESTART */
	if ((err = (f->f_dev->dv_strategy)(f->f_devdata, F_READ, 0,
	    sizeof(fp->f_buf), &fp->f_buf, &buf_size)) ||
	    buf_size != sizeof(fp->f_buf)) {
#ifdef LIFDEBUG
		if (debug)
			printf("lif_open: unable to read LIF header (%d)\n", err);
#endif
	} else if ((fp->f_lp = (struct lifvol *)fp->f_buf)->vol_id == LIF_VOL_ID) {
		f->f_fsdata = fp;
		fp->f_ld = (struct lifdir *)(fp->f_buf + LIF_DIRSTART);
		fp->f_seek = 0;
		fp->f_rd = fp->f_ld;
		fp->f_nfiles = lifstob(fp->f_lp->vol_dirsize) /
			sizeof(struct lifdir);

		/* no dirs on the lif */
		for (p = path + (l = strlen(path)); p >= path; p--)
			if (*p == '/') {
				p++;
				break;
			}
		if (p > path)
			path = p;
	} else
		err = EINVAL;

	if (!err && *path != '.') {
		fp->f_isdir = 0;
		err = ENOENT;
		for (dp = fp->f_ld; dp < &fp->f_ld[fp->f_nfiles]; dp++) {
#ifdef LIFDEBUG
			if (debug)
				printf("lif_open: "
				       "%s <--> '%c%c%c%c%c%c%c%c%c%c'\n",
				       path, dp->dir_name[0], dp->dir_name[1],
				       dp->dir_name[2], dp->dir_name[3],
				       dp->dir_name[4], dp->dir_name[5],
				       dp->dir_name[6], dp->dir_name[7],
				       dp->dir_name[8], dp->dir_name[9]);
#endif
			for (p = path, q = dp->dir_name;
			     *q && *q != ' '; q++, p++)
				if (tolower(*q) != tolower(*p))
					break;
			if ((!*q || *q == ' ') && !*p) {
				err = 0;
				break;
			}
		}
		if (!err) {
			fp->f_off = lifstodb(dp->dir_addr);
			if (!(err =(f->f_dev->dv_strategy)(f->f_devdata, F_READ,
			      fp->f_off, sizeof(load), &load, &buf_size)) &&
			    buf_size == sizeof(load)) {
				/* no checksum */
				fp->f_count = load.count - sizeof(int);
				fp->f_off = dbtob(fp->f_off) + sizeof(load);
#ifdef LIFDEBUG
				if (debug)
					printf("lif_open: %u @@ %u [%x]\n",
					       fp->f_count, fp->f_off,
					       load.address);
#endif
			} else if (!err)
				err = EIO;
		}
	} else
		fp->f_isdir = 1;

	if (err) {
		free (fp, sizeof(*fp));
		f->f_fsdata = NULL;
	}
#ifdef LIFDEBUG
	if (debug)
		printf("ret(%d)\n", err);
#endif
	return err;
}

int
lif_close(f)
	struct open_file *f;
{
	free (f->f_fsdata, sizeof(struct file));
	f->f_fsdata = NULL;
	return 0;
}

int
lif_read(f, buf, size, resid)
	struct open_file *f;
	void *buf;
	size_t size;
	size_t *resid;
{
	struct file *fp = (struct file *)f->f_fsdata;
	char *p;
	char bbuf[DEV_BSIZE];
	size_t bsize, count = sizeof(bbuf);
	int err = 0;
	int foff;

#ifdef LIFDEBUG
	if (debug)
		printf("lif_read(%p, %p, %u, %p)\n", f, buf, size, resid);
#endif

	for (p = bbuf; size; fp->f_seek += bsize, p += bsize) {
		twiddle();
		foff = fp->f_off + fp->f_seek;
		if (fp->f_seek >= fp->f_count ||
		    (err = (f->f_dev->dv_strategy)(f->f_devdata, F_READ,
		     btodb(foff), count, p, &bsize)))
			break;
		if (p == bbuf) {
			bsize = sizeof(bbuf) - (foff & (sizeof(bbuf) - 1));
			bsize = min(bsize, size);
			bcopy(bbuf + (foff & (sizeof(bbuf) - 1)), buf, bsize);
			p = buf;
		}
		count = size -= bsize;
	}
	if (resid)
		*resid = size;

	return err;
}

int
lif_write(f, buf, size, resid)
	struct open_file *f;
	void *buf;
	size_t size;
	size_t *resid;
{
	return EOPNOTSUPP;
}

off_t
lif_seek(f, offset, where)
	struct open_file *f;
	off_t offset;
	int where;
{
	struct file *fp = (struct file *)f->f_fsdata;

	switch (where) {
	case SEEK_SET:
		fp->f_seek = offset;
		break;
	case SEEK_CUR:
		fp->f_seek += offset;
		break;
	case SEEK_END:
		fp->f_seek = fp->f_count - offset;
		break;
	default:
		return (-1);
	}
	return (fp->f_seek);
}

int
lif_stat(f, sb)
	struct open_file *f;
	struct stat *sb;
{
	struct file *fp = (struct file *)f->f_fsdata;

	sb->st_mode = 0755 | (fp->f_isdir? S_IFDIR: 0);	/* XXX */
	sb->st_uid = 0;
	sb->st_gid = 0;
	sb->st_size = fp->f_count;
	return 0;
}

int
lif_readdir(f, name)
	struct open_file *f;
	char *name;
{
	struct file *fp = (struct file *)f->f_fsdata;
	char *p;

	if (name) {
		while ((fp->f_rd->dir_name[0] == ' ' ||
			!fp->f_rd->dir_name[0]) &&
		       (fp->f_rd - fp->f_ld) < fp->f_nfiles)
			fp->f_rd++;
		if ((fp->f_rd - fp->f_ld) >= fp->f_nfiles) {
			*name = '\0';
			return -1;
		}
		strncpy(name, fp->f_rd->dir_name, sizeof(fp->f_rd->dir_name));
		if ((p = strchr(name, ' ')))
			*p = '\0';
		fp->f_rd++;
	} else
		fp->f_rd = fp->f_ld;

	return 0;
}
@


1.9
log
@update copyright; miod@@ is fine w/ files where he holds it too
@
text
@d1 1
a1 1
/*	$OpenBSD: lif.c,v 1.8 2003/04/16 07:20:50 mickey Exp $	*/
d58 2
a59 1
	int err, buf_size, l;
@


1.8
log
@clean some spaces and registers and other fluff
@
text
@d1 1
a1 1
/*	$OpenBSD: lif.c,v 1.7 2001/06/09 03:54:41 mickey Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998 Michael Shalayeff
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Michael Shalayeff.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d19 8
a26 7
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@


1.7
log
@print return value for debugging purposes
@
text
@d1 1
a1 1
/*	$OpenBSD: lif.c,v 1.6 1999/05/31 02:41:11 todd Exp $	*/
d58 3
a60 3
	register struct file *fp;
	register struct lifdir *dp;
	register char *p, *q;
d105 4
a108 4
				       path, dp->dir_name[0], dp->dir_name[1], 
				       dp->dir_name[2], dp->dir_name[3], 
				       dp->dir_name[4], dp->dir_name[5], 
				       dp->dir_name[6], dp->dir_name[7], 
d167 2
a168 2
	register struct file *fp = (struct file *)f->f_fsdata;
	register char *p;
d216 1
a216 1
	register struct file *fp = (struct file *)f->f_fsdata;
d239 1
a239 1
	register struct file *fp = (struct file *)f->f_fsdata;
d253 2
a254 2
	register struct file *fp = (struct file *)f->f_fsdata;
	register char *p;
@


1.7.4.1
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d58 3
a60 3
	struct file *fp;
	struct lifdir *dp;
	char *p, *q;
d105 4
a108 4
				       path, dp->dir_name[0], dp->dir_name[1],
				       dp->dir_name[2], dp->dir_name[3],
				       dp->dir_name[4], dp->dir_name[5],
				       dp->dir_name[6], dp->dir_name[7],
d167 2
a168 2
	struct file *fp = (struct file *)f->f_fsdata;
	char *p;
d216 1
a216 1
	struct file *fp = (struct file *)f->f_fsdata;
d239 1
a239 1
	struct file *fp = (struct file *)f->f_fsdata;
d253 2
a254 2
	struct file *fp = (struct file *)f->f_fsdata;
	char *p;
@


1.6
log
@typo; now we can 'set debug off' at 'boot>'
@
text
@d1 1
a1 1
/*	$OpenBSD: lif.c,v 1.5 1999/05/06 02:26:49 mickey Exp $	*/
d60 1
a60 1
	register char *p = NULL, *q = NULL; /* XXX shut up gcc */
d144 4
@


1.6.4.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: lif.c,v 1.6 1999/05/31 02:41:11 todd Exp $	*/
d60 1
a60 1
	register char *p, *q;
a143 4
#ifdef LIFDEBUG
	if (debug)
		printf("ret(%d)\n", err);
#endif
@


1.6.4.2
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: lif.c,v 1.6.4.1 2001/07/04 10:16:13 niklas Exp $	*/
d58 3
a60 3
	struct file *fp;
	struct lifdir *dp;
	char *p, *q;
d105 4
a108 4
				       path, dp->dir_name[0], dp->dir_name[1],
				       dp->dir_name[2], dp->dir_name[3],
				       dp->dir_name[4], dp->dir_name[5],
				       dp->dir_name[6], dp->dir_name[7],
d167 2
a168 2
	struct file *fp = (struct file *)f->f_fsdata;
	char *p;
d216 1
a216 1
	struct file *fp = (struct file *)f->f_fsdata;
d239 1
a239 1
	struct file *fp = (struct file *)f->f_fsdata;
d253 2
a254 2
	struct file *fp = (struct file *)f->f_fsdata;
	char *p;
@


1.6.4.3
log
@Merge with the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d4 1
a4 1
 * Copyright (c) 1998-2004 Michael Shalayeff
d15 5
d24 7
a30 8
 * IN NO EVENT SHALL THE AUTHOR OR HIS RELATIVES BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
@


1.5
log
@comment
@
text
@d1 1
a1 1
/*	$OpenBSD: lif.c,v 1.4 1999/05/03 22:46:38 mickey Exp $	*/
d101 1
a102 1
#ifdef LIFDEBUG
@


1.4
log
@lifvar.h -- bye, bye
@
text
@d1 1
a1 1
/*	$OpenBSD: lif.c,v 1.3 1999/01/25 20:15:23 mickey Exp $	*/
d70 1
@


1.3
log
@shut up gcc
@
text
@d1 1
a1 1
/*	$OpenBSD: lif.c,v 1.2 1998/09/29 07:17:00 mickey Exp $	*/
d34 2
a35 3
#include <lib/libsa/stand.h>

#include <machine/lifvar.h>
d61 1
a61 1
	struct load load;
d77 1
a77 1
	} else if ((fp->f_lp = (struct lifvol *)fp->f_buf)->vol_id == VOL_ID) {
@


1.2
log
@add twiddle(), so it'll twiddle
@
text
@d1 1
a1 1
/*	$OpenBSD: lif.c,v 1.1 1998/07/30 16:01:48 mickey Exp $	*/
d61 1
a61 1
	register char *p, *q;
@


1.1
log
@LIF file system
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d176 1
@

