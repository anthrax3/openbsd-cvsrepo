head	1.12;
access;
symbols
	OPENBSD_6_2:1.12.0.28
	OPENBSD_6_2_BASE:1.12
	OPENBSD_6_1:1.12.0.26
	OPENBSD_6_1_BASE:1.12
	OPENBSD_6_0:1.12.0.22
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.12.0.18
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.12.0.20
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.12
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.12.0.16
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.12.0.14
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.12.0.10
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.12.0.8
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.6
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.4
	OPENBSD_5_0:1.12.0.2
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.11.0.26
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.11.0.24
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.20
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.11.0.22
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.18
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.16
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.14
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.12
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.10
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.8
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.11.0.6
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.4
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.11.0.2
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.10.0.6
	OPENBSD_3_6_BASE:1.10
	SMP_SYNC_A:1.10
	SMP_SYNC_B:1.10
	OPENBSD_3_5:1.10.0.4
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	UBC_SYNC_A:1.10
	OPENBSD_3_3:1.9.0.2
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	HPUX_REL9_05_800:1.1.1.1
	HP:1.1.1
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	UBC_SYNC_B:1.8
	UBC:1.5.0.6
	UBC_BASE:1.5
	OPENBSD_3_0:1.5.0.4
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.3.0.12
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.10
	OPENBSD_2_7_BASE:1.3
	SMP:1.3.0.8
	SMP_BASE:1.3
	kame_19991208:1.3
	OPENBSD_2_6:1.3.0.6
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.4
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.2
	OPENBSD_2_4_BASE:1.3;
locks; strict;
comment	@# @;


1.12
date	2011.04.16.20.52.12;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2005.01.23.18.01.30;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	2003.04.10.17.27.58;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	2003.01.23.20.25.21;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	2002.09.20.19.26.59;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	2002.05.07.22.19.30;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	2002.02.04.23.04.18;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	2001.03.29.03.58.18;	author mickey;	state Exp;
branches
	1.5.6.1;
next	1.4;

1.4
date	2001.03.28.23.55.59;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	98.07.02.19.05.33;	author mickey;	state Exp;
branches
	1.3.8.1;
next	1.2;

1.2
date	98.06.23.21.19.43;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	98.06.23.20.34.02;	author mickey;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.05.07.21.37.19;	author mickey;	state Exp;
branches;
next	;

1.3.8.1
date	2001.04.18.16.06.42;	author niklas;	state Exp;
branches;
next	1.3.8.2;

1.3.8.2
date	2002.03.06.00.57.23;	author niklas;	state Exp;
branches;
next	1.3.8.3;

1.3.8.3
date	2003.03.27.23.26.54;	author niklas;	state Exp;
branches;
next	1.3.8.4;

1.3.8.4
date	2003.05.13.19.41.04;	author ho;	state Exp;
branches;
next	;

1.5.6.1
date	2002.06.11.03.35.38;	author art;	state Exp;
branches;
next	1.5.6.2;

1.5.6.2
date	2002.10.29.00.28.03;	author art;	state Exp;
branches;
next	1.5.6.3;

1.5.6.3
date	2003.05.19.21.49.42;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.12
log
@_LOCORE is already defined
@
text
@/*	$OpenBSD: impyu.S,v 1.11 2005/01/23 18:01:30 mickey Exp $	*/
/*
  (c) Copyright 1986 HEWLETT-PACKARD COMPANY
  To anyone who acknowledges that this file is provided "AS IS"
  without any express or implied warranty:
      permission to use, copy, modify, and distribute this file
  for any purpose is hereby granted without fee, provided that
  the above copyright notice and this notice appears in all
  copies, and that the name of Hewlett-Packard Company not be
  used in advertising or publicity pertaining to distribution
  of the software without specific, written prior permission.
  Hewlett-Packard Company makes no representations about the
  suitability of this software for any purpose.
*/
/* @@(#)impyu.s: Revision: 1.11.88.1 Date: 93/12/07 15:06:31 */

#include <machine/asm.h>
#include <machine/frame.h>

;****************************************************************************
;
;Implement an integer multiply routine for 32-bit operands and 64-bit product
; with operand values of zero (multiplicand only) and 2**32reated specially.
; The algorithm uses the multiplier, four bits at a time, from right to left,
; to generate partial product.  Execution speed is more important than program
; size in this implementation.
;
;******************************************************************************
;
; Definitions - General registers
;
gr0	.reg		%r0		; General register zero
pu	.reg		%r3		; upper part of product
pl	.reg		%r4		; lower part of product
op2	.reg		%r4		; multiplier
op1	.reg		%r5		; multiplicand
cnt	.reg		%r6		; count in multiply
brindex	.reg		%r7		; index into the br. table
saveop2	.reg		%r8		; save op2 if high bit of multiplicand
					; is set
pc	.reg		%r9		; carry bit of product, = 00...01
pm	.reg		%r10		; value of -1 used in shifting
temp	.reg		%r6

;****************************************************************************
	.text
LEAF_ENTRY(u_xmpy)
	stws,ma		pu,4(sp)		; save registers on stack
	stws,ma		pl,4(sp)		; save registers on stack
	stws,ma		op1,4(sp)		; save registers on stack
	stws,ma		cnt,4(sp)		; save registers on stack
	stws,ma		brindex,4(sp)		; save registers on stack
	stws,ma		saveop2,4(sp)		; save registers on stack
	stws,ma		pc,4(sp)		; save registers on stack
	stws,ma		pm,4(sp)		; save registers on stack
;
;   Start multiply process
;
	ldws		0(arg0),op1		; get multiplicand
	ldws		0(arg1),op2		; get multiplier
	addib,=		0,op1,fini0		; op1 = 0, product = 0
	addi		0,gr0,pu		; clear product
	bb,>=		op1,0,mpy1		; test msb of multiplicand
	addi		0,gr0,saveop2		; clear saveop2
;
; msb of multiplicand is set so will save multiplier for a final
; addition into the result
;
	extru,=		op1,31,31,op1		; clear msb of multiplicand
	b		mpy1			; if op1 < 2**32, start multiply
	add		op2,gr0,saveop2		;   save op2 in saveop2
	shd		gr0,op2,1,pu		; shift op2 left 31 for result
	b		fini			; go to finish
	shd		op2,gr0,1,pl
;
mpy1	addi		-1,gr0,pm		; initialize pm to 111...1
	addi		1,gr0,pc		; initialize pc to 00...01
	movib,tr	8,cnt,mloop		; set count for mpy loop
	extru		op2,31,4,brindex	; 4 bits as index into table
;
	.align		8
;
	b		sh4c			; br. if sign overflow
sh4n	shd		pu,pl,4,pl		; shift product right 4 bits
	addib,<=	-1,cnt,mulend		; reduce count by 1, exit if
	extru		pu,27,28,pu		;   <= zero
;
mloop	blr		brindex,gr0		; br. into table
						;   entries of 2 words
	extru		op2,27,4,brindex	; next 4 bits into index
;
;
;	branch table for the multiplication process with four multiplier bits
;
mtable						; two words per entry
;
; ----	bits = 0000 ---- shift product 4 bits -------------------------------
;
	b		sh4n+4			; just shift partial
	shd		pu,pl,4,pl		;   product right 4 bits
;
;  ----	bits = 0001 ---- add op1, then shift 4 bits
;
	addb,tr		op1,pu,sh4n+4		; add op1 to product, to shift
	shd		pu,pl,4,pl		;   product right 4 bits
;
;  ----	bits = 0010 ---- add op1, add op1, then shift 4 bits
;
	addb,tr		op1,pu,sh4n		; add 2*op1, to shift
	addb,uv		op1,pu,sh4c		;   product right 4 bits
;
;  ---- bits = 0011 ---- add op1, add 2*op1, shift 4 bits
;
	addb,tr		op1,pu,sh4n-4		; add op1 & 2*op1, shift
	sh1add,nuv	op1,pu,pu			;   product right 4 bits
;
;  ----	bits = 0100 ---- shift 2, add op1, shift 2
;
	b		sh2sa
	shd		pu,pl,2,pl		; shift product 2 bits
;
;  ----	bits = 0101 ---- add op1, shift 2, add op1, and shift 2 again
;
	addb,tr		op1,pu,sh2us		; add op1 to product
	shd		pu,pl,2,pl		; shift 2 bits
;
;  ----	bits = 0110 ---- add op1, add op1, shift 2, add op1, and shift 2 again
;
	addb,tr		op1,pu,sh2c		; add 2*op1, to shift 2 bits
	addb,nuv	op1,pu,sh2us		; br. if not overflow
;
;  ----	bits = 0111 ---- subtract op1, shift 3, add op1, and shift 1
;
	b		sh3s
	sub		pu,op1,pu		; subtract op1, br. to sh3s

;
;  ----	bits = 1000 ---- shift 3, add op1, shift 1
;
	b		sh3sa
	shd		pu,pl,3,pl		; shift product right 3 bits
;
;  ----	bits = 1001 ---- add op1, shift 3, add op1, shift 1
;
	addb,tr		op1,pu,sh3us		; add op1, to shift 3, add op1,
	shd		pu,pl,3,pl		;   and shift 1
;
;  ----	bits = 1010 ---- add op1, add op1, shift 3, add op1, shift 1
;
	addb,tr		op1,pu,sh3c		; add 2*op1, to shift 3 bits
	addb,nuv	op1,pu,sh3us		;   br. if no overflow
;
;  ----	bits = 1011 ---- add -op1, shift 2, add -op1, shift 2, inc. next index
;
	addib,tr	1,brindex,sh2s		; add 1 to index, subtract op1,
	sub		pu,op1,pu		;   shift 2 with minus sign
;
;  ----	bits = 1100 ---- shift 2, subtract op1, shift 2, increment next index
;
	addib,tr	1,brindex,sh2sb		; add 1 to index, to shift
	shd		pu,pl,2,pl		; shift right 2 bits signed
;
;  ----	bits = 1101 ---- add op1, shift 2, add -op1, shift 2
;
	addb,tr		op1,pu,sh2ns		; add op1, to shift 2
	shd		pu,pl,2,pl		;   right 2 unsigned, etc.
;
;  ----	bits = 1110 ---- shift 1 signed, add -op1, shift 3 signed
;
	addib,tr	1,brindex,sh1sa		; add 1 to index, to shift
	shd		pu,pl,1,pl		; shift 1 bit
;
;  ----	bits = 1111 ---- add -op1, shift 4 signed
;
	addib,tr	1,brindex,sh4s		; add 1 to index, subtract op1,
	sub		pu,op1,pu		;   to shift 4 signed

;
;  ----	bits = 10000 ---- shift 4 signed
;
	addib,tr	1,brindex,sh4s+4		; add 1 to index
	shd		pu,pl,4,pl		; shift 4 signed
;
;  ---- end of table ---------------------------------------------------------
;
sh4s	shd		pu,pl,4,pl
	addib,>		-1,cnt,mloop		; decrement count, loop if > 0
	shd		pm,pu,4,pu		; shift 4, minus signed
	addb,tr		op1,pu,lastadd		; do one more add, then finish
	addb,=,n	saveop2,gr0,fini	; check saveop2
;
sh4c	addib,>		-1,cnt,mloop		; decrement count, loop if > 0
	shd		pc,pu,4,pu		; shift 4 with overflow
	b		lastadd			; end of multiply
	addb,=,n	saveop2,gr0,fini	; check saveop2
;
sh3c	shd		pu,pl,3,pl		; shift product 3 bits
	shd		pc,pu,3,pu		; shift 3 signed
	addb,tr		op1,pu,sh1		; add op1, to shift 1 bit
	shd		pu,pl,1,pl
;
sh3us	extru		pu,28,29,pu		; shift 3 unsigned
	addb,tr		op1,pu,sh1		; add op1, to shift 1 bit
	shd		pu,pl,1,pl
;
sh3sa	extrs		pu,28,29,pu		; shift 3 signed
	addb,tr		op1,pu,sh1		; add op1, to shift 1 bit
	shd		pu,pl,1,pl
;
sh3s	shd		pu,pl,3,pl		; shift 3 minus signed
	shd		pm,pu,3,pu
	addb,tr		op1,pu,sh1		; add op1, to shift 1 bit
	shd		pu,pl,1,pl
;
sh1	addib,>		-1,cnt,mloop		; loop if count > 0
	extru		pu,30,31,pu
	b		lastadd			; end of multiply
	addb,=,n	saveop2,gr0,fini	; check saveop2
;
sh2ns	addib,tr	1,brindex,sh2sb+4	; increment index
	extru		pu,29,30,pu		; shift unsigned
;
sh2s	shd		pu,pl,2,pl		; shift with minus sign
	shd		pm,pu,2,pu		;
	sub		pu,op1,pu		; subtract op1
	shd		pu,pl,2,pl		; shift with minus sign
	addib,>		-1,cnt,mloop		; decrement count, loop if > 0
	shd		pm,pu,2,pu		; shift with minus sign
	addb,tr		op1,pu,lastadd		; do one more add, then finish
	addb,=,n	saveop2,gr0,fini	; check saveop2
;
sh2sb	extrs		pu,29,30,pu		; shift 2 signed
	sub		pu,op1,pu		; subtract op1 from product
	shd		pu,pl,2,pl		; shift with minus sign
	addib,>		-1,cnt,mloop		; decrement count, loop if > 0
	shd		pm,pu,2,pu		; shift with minus sign
	addb,tr		op1,pu,lastadd		; do one more add, then finish
	addb,=,n	saveop2,gr0,fini	; check saveop2
;
sh1sa	extrs		pu,30,31,pu		;   signed
	sub		pu,op1,pu		; subtract op1 from product
	shd		pu,pl,3,pl		; shift 3 with minus sign
	addib,>		-1,cnt,mloop		; decrement count, loop if >0
	shd		pm,pu,3,pu
	addb,tr		op1,pu,lastadd		; do one more add, then finish
	addb,=,n	saveop2,gr0,fini	; check saveop2
;
fini0	movib,tr	0,pl,fini		; product = 0 as op1 = 0
	stws		pu,0(arg2)		; save high part of result
;
sh2us	extru		pu,29,30,pu		; shift 2 unsigned
	addb,tr		op1,pu,sh2a		; add op1
	shd		pu,pl,2,pl		; shift 2 bits
;
sh2c	shd		pu,pl,2,pl
	shd		pc,pu,2,pu		; shift with carry
	addb,tr		op1,pu,sh2a		; add op1 to product
	shd		pu,pl,2,pl		; br. to sh2 to shift pu
;
sh2sa	extrs		pu,29,30,pu		; shift with sign
	addb,tr		op1,pu,sh2a		; add op1 to product
	shd		pu,pl,2,pl		; br. to sh2 to shift pu
;
sh2a	addib,>		-1,cnt,mloop		; loop if count > 0
	extru		pu,29,30,pu
;
mulend	addb,=,n	saveop2,gr0,fini	; check saveop2
lastadd	shd		saveop2,gr0,1,temp	;  if saveop2 <> 0, shift it
	shd		gr0,saveop2,1,saveop2	;  left 31 and add to result
	add		pl,temp,pl
	addc		pu,saveop2,pu
;
;	finish
;
fini	stws		pu,0(arg2)		; save high part of result
	stws		pl,4(arg2)		; save low part of result

	ldws,mb		-4(sp),pm		; restore registers
	ldws,mb		-4(sp),pc		; restore registers
	ldws,mb		-4(sp),saveop2		; restore registers
	ldws,mb		-4(sp),brindex		; restore registers
	ldws,mb		-4(sp),cnt		; restore registers
	ldws,mb		-4(sp),op1		; restore registers
	ldws,mb		-4(sp),pl		; restore registers
	bv		0(rp)			; return
	ldws,mb		-4(sp),pu		; restore registers
EXIT(u_xmpy)

	.end
@


1.11
log
@use register names instead of numbers
@
text
@d1 1
a1 1
/*	$OpenBSD: impyu.S,v 1.10 2003/04/10 17:27:58 mickey Exp $	*/
a17 1
#define _LOCORE
@


1.10
log
@make all entry points of the same number of arguments and that greatly simplifies the call setup in the scheduler
@
text
@d1 1
a1 1
/*	$OpenBSD: impyu.S,v 1.9 2003/01/23 20:25:21 mickey Exp $	*/
d33 8
a40 8
gr0	.equ		0		; General register zero
pu	.equ		3		; upper part of product
pl	.equ		4		; lower part of product
op2	.equ		4		; multiplier
op1	.equ		5		; multiplicand
cnt	.equ		6		; count in multiply
brindex	.equ		7		; index into the br. table
saveop2	.equ		8		; save op2 if high bit of multiplicand
d42 3
a44 3
pc	.equ		9		; carry bit of product, = 00...01
pm	.equ	       10		; value of -1 used in shifting
temp	.equ		6
@


1.9
log
@will need machine/frame.h for profiling
@
text
@d1 1
a1 1
/*	$OpenBSD: impyu.S,v 1.8 2002/09/20 19:26:59 mickey Exp $	*/
d48 1
a48 1
LEAF_ENTRY(impyu)
d288 1
a288 1
EXIT(impu)
@


1.8
log
@kill dangling space, line and a space in the tab
@
text
@d1 1
a1 1
/*	$OpenBSD: impyu.S,v 1.7 2002/05/07 22:19:30 mickey Exp $	*/
d18 2
@


1.7
log
@bring over our mods; the cnv*c have a problem now, described in the osf version of the cnv_float.h, at the end
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d21 1
a21 1
;Implement an integer multiply routine for 32-bit operands and 64-bit product 
d25 1
a25 1
; size in this implementation. 
d38 1
a38 1
saveop2	.equ		8		; save op2 if high bit of multiplicand 
d72 1
a72 1
	b		fini			; go to finish 
d75 1
a75 1
mpy1 	addi		-1,gr0,pm		; initialize pm to 111...1
d78 1
a78 1
	extru		op2,31,4,brindex	; 4 bits as index into table 
d85 1
a85 1
	extru  		pu,27,28,pu		;   <= zero
d108 2
a109 2
	addb,tr		op1,pu,sh4n		; add 2*op1, to shift 
	addb,uv 	op1,pu,sh4c		;   product right 4 bits
d113 2
a114 2
	addb,tr		op1,pu,sh4n-4		; add op1 & 2*op1, shift 
	sh1add,nuv 	op1,pu,pu			;   product right 4 bits
d222 2
a223 2
sh2s	shd		pu,pl,2,pl		; shift with minus sign 
	shd		pm,pu,2,pu		; 
d243 1
a243 1
	shd		pm,pu,3,pu		 
d254 1
a254 1
sh2c	shd		pu,pl,2,pl	
@


1.6
log
@missing LEAF_ENTRY()
@
text
@d1 1
a1 23
/*	$OpenBSD: impyu.S,v 1.5 2001/03/29 03:58:18 mickey Exp $	*/

/*
 * Copyright 1996 1995 by Open Software Foundation, Inc.
 *              All Rights Reserved
 *
 * Permission to use, copy, modify, and distribute this software and
 * its documentation for any purpose and without fee is hereby granted,
 * provided that the above copyright notice appears in all copies and
 * that both the copyright notice and this permission notice appear in
 * supporting documentation.
 *
 * OSF DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE.
 *
 * IN NO EVENT SHALL OSF BE LIABLE FOR ANY SPECIAL, INDIRECT, OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN ACTION OF CONTRACT,
 * NEGLIGENCE, OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
 * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */
d3 13
a15 16
 * pmk1.1
 */
/*
 * (c) Copyright 1986 HEWLETT-PACKARD COMPANY
 *
 * To anyone who acknowledges that this file is provided "AS IS"
 * without any express or implied warranty:
 *     permission to use, copy, modify, and distribute this file
 * for any purpose is hereby granted without fee, provided that
 * the above copyright notice and this notice appears in all
 * copies, and that the name of Hewlett-Packard Company not be
 * used in advertising or publicity pertaining to distribution
 * of the software without specific, written prior permission.
 * Hewlett-Packard Company makes no representations about the
 * suitability of this software for any purpose.
 */
d19 9
a27 9
/****************************************************************************
 *
 *Implement an integer multiply routine for 32-bit operands and 64-bit product
 * with operand values of zero (multiplicand only) and 2**32reated specially.
 * The algorithm uses the multiplier, four bits at a time, from right to left,
 * to generate partial product.  Execution speed is more important than program
 * size in this implementation.
 *
 *****************************************************************************/
d38 1
a38 1
saveop2	.equ		8		; save op2 if high bit of multiplicand
d44 2
d72 1
a72 1
	b		fini			; go to finish
d75 1
a75 1
mpy1	addi		-1,gr0,pm		; initialize pm to 111...1
d78 1
a78 1
	extru		op2,31,4,brindex	; 4 bits as index into table
d85 1
a85 1
	extru		pu,27,28,pu		;   <= zero
d108 2
a109 2
	addb,tr		op1,pu,sh4n		; add 2*op1, to shift
	addb,uv		op1,pu,sh4c		;   product right 4 bits
d113 2
a114 2
	addb,tr		op1,pu,sh4n-4		; add op1 & 2*op1, shift
	sh1add,nuv	op1,pu,pu			;   product right 4 bits
d222 2
a223 2
sh2s	shd		pu,pl,2,pl		; shift with minus sign
	shd		pm,pu,2,pu		;
d243 1
a243 1
	shd		pm,pu,3,pu
d254 1
a254 1
sh2c	shd		pu,pl,2,pl
d286 1
a286 2

EXIT(impyu)
@


1.5
log
@big bang
@
text
@d1 1
a1 1
/*	$OpenBSD: impyu.S,v 1.4 2001/03/28 23:55:59 mickey Exp $	*/
d69 2
a70 9
;****************************************************************************
	.export impyu,entry
	.text
	.align 4
	.proc
	.callinfo
;
;****************************************************************************
impyu	stws,ma		pu,4(sp)		; save registers on stack
d310 2
a311 1
	.procend
@


1.5.6.1
log
@Sync UBC branch to -current
@
text
@d1 26
a26 1
/*	$OpenBSD$	*/
d28 13
a40 13
  (c) Copyright 1986 HEWLETT-PACKARD COMPANY
  To anyone who acknowledges that this file is provided "AS IS"
  without any express or implied warranty:
      permission to use, copy, modify, and distribute this file
  for any purpose is hereby granted without fee, provided that
  the above copyright notice and this notice appears in all
  copies, and that the name of Hewlett-Packard Company not be
  used in advertising or publicity pertaining to distribution
  of the software without specific, written prior permission.
  Hewlett-Packard Company makes no representations about the
  suitability of this software for any purpose.
*/
/* @@(#)impyu.s: Revision: 1.11.88.1 Date: 93/12/07 15:06:31 */
d44 9
a52 9
;****************************************************************************
;
;Implement an integer multiply routine for 32-bit operands and 64-bit product 
; with operand values of zero (multiplicand only) and 2**32reated specially.
; The algorithm uses the multiplier, four bits at a time, from right to left,
; to generate partial product.  Execution speed is more important than program
; size in this implementation. 
;
;******************************************************************************
d63 1
a63 1
saveop2	.equ		8		; save op2 if high bit of multiplicand 
d70 1
d72 6
a77 2
LEAF_ENTRY(impyu)
	stws,ma		pu,4(sp)		; save registers on stack
d102 1
a102 1
	b		fini			; go to finish 
d105 1
a105 1
mpy1 	addi		-1,gr0,pm		; initialize pm to 111...1
d108 1
a108 1
	extru		op2,31,4,brindex	; 4 bits as index into table 
d115 1
a115 1
	extru  		pu,27,28,pu		;   <= zero
d138 2
a139 2
	addb,tr		op1,pu,sh4n		; add 2*op1, to shift 
	addb,uv 	op1,pu,sh4c		;   product right 4 bits
d143 2
a144 2
	addb,tr		op1,pu,sh4n-4		; add op1 & 2*op1, shift 
	sh1add,nuv 	op1,pu,pu			;   product right 4 bits
d252 2
a253 2
sh2s	shd		pu,pl,2,pl		; shift with minus sign 
	shd		pm,pu,2,pu		; 
d273 1
a273 1
	shd		pm,pu,3,pu		 
d284 1
a284 1
sh2c	shd		pu,pl,2,pl	
a315 1
EXIT(impu)
d317 1
@


1.5.6.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: impyu.S,v 1.5.6.1 2002/06/11 03:35:38 art Exp $	*/
d21 1
a21 1
;Implement an integer multiply routine for 32-bit operands and 64-bit product
d25 1
a25 1
; size in this implementation.
d38 1
a38 1
saveop2	.equ		8		; save op2 if high bit of multiplicand
d72 1
a72 1
	b		fini			; go to finish
d75 1
a75 1
mpy1	addi		-1,gr0,pm		; initialize pm to 111...1
d78 1
a78 1
	extru		op2,31,4,brindex	; 4 bits as index into table
d85 1
a85 1
	extru		pu,27,28,pu		;   <= zero
d108 2
a109 2
	addb,tr		op1,pu,sh4n		; add 2*op1, to shift
	addb,uv		op1,pu,sh4c		;   product right 4 bits
d113 2
a114 2
	addb,tr		op1,pu,sh4n-4		; add op1 & 2*op1, shift
	sh1add,nuv	op1,pu,pu			;   product right 4 bits
d222 2
a223 2
sh2s	shd		pu,pl,2,pl		; shift with minus sign
	shd		pm,pu,2,pu		;
d243 1
a243 1
	shd		pm,pu,3,pu
d254 1
a254 1
sh2c	shd		pu,pl,2,pl
@


1.5.6.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a17 2
#define _LOCORE
#include <machine/frame.h>
d46 1
a46 1
LEAF_ENTRY(u_xmpy)
d286 1
a286 1
EXIT(u_xmpy)
@


1.4
log
@start of text
@
text
@d1 1
a1 1
/*	$OpenBSD: impyu.S,v 1.3 1998/07/02 19:05:33 mickey Exp $	*/
d4 19
a22 19
 * Copyright 1996 1995 by Open Software Foundation, Inc.   
 *              All Rights Reserved 
 *  
 * Permission to use, copy, modify, and distribute this software and 
 * its documentation for any purpose and without fee is hereby granted, 
 * provided that the above copyright notice appears in all copies and 
 * that both the copyright notice and this permission notice appear in 
 * supporting documentation. 
 *  
 * OSF DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE 
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS 
 * FOR A PARTICULAR PURPOSE. 
 *  
 * IN NO EVENT SHALL OSF BE LIABLE FOR ANY SPECIAL, INDIRECT, OR 
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM 
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN ACTION OF CONTRACT, 
 * NEGLIGENCE, OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION 
 * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. 
 * 
d30 1
a30 1
 * To anyone who acknowledges that this file is provided "AS IS" 
d32 7
a38 7
 *     permission to use, copy, modify, and distribute this file 
 * for any purpose is hereby granted without fee, provided that 
 * the above copyright notice and this notice appears in all 
 * copies, and that the name of Hewlett-Packard Company not be 
 * used in advertising or publicity pertaining to distribution 
 * of the software without specific, written prior permission.  
 * Hewlett-Packard Company makes no representations about the 
d46 1
a46 1
 *Implement an integer multiply routine for 32-bit operands and 64-bit product 
d50 1
a50 1
 * size in this implementation. 
d63 1
a63 1
saveop2	.equ		8		; save op2 if high bit of multiplicand 
d102 1
a102 1
	b		fini			; go to finish 
d105 1
a105 1
mpy1 	addi		-1,gr0,pm		; initialize pm to 111...1
d108 1
a108 1
	extru		op2,31,4,brindex	; 4 bits as index into table 
d115 1
a115 1
	extru  		pu,27,28,pu		;   <= zero
d138 2
a139 2
	addb,tr		op1,pu,sh4n		; add 2*op1, to shift 
	addb,uv 	op1,pu,sh4c		;   product right 4 bits
d143 2
a144 2
	addb,tr		op1,pu,sh4n-4		; add op1 & 2*op1, shift 
	sh1add,nuv 	op1,pu,pu			;   product right 4 bits
d252 2
a253 2
sh2s	shd		pu,pl,2,pl		; shift with minus sign 
	shd		pm,pu,2,pu		; 
d273 1
a273 1
	shd		pm,pu,3,pu		 
d284 1
a284 1
sh2c	shd		pu,pl,2,pl	
@


1.3
log
@ansi and fancy gcc
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d71 1
a71 2
	.space $TEXT$
	.subspa $CODE$
@


1.3.8.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: impyu.S,v 1.5 2001/03/29 03:58:18 mickey Exp $	*/
d4 19
a22 19
 * Copyright 1996 1995 by Open Software Foundation, Inc.
 *              All Rights Reserved
 *
 * Permission to use, copy, modify, and distribute this software and
 * its documentation for any purpose and without fee is hereby granted,
 * provided that the above copyright notice appears in all copies and
 * that both the copyright notice and this permission notice appear in
 * supporting documentation.
 *
 * OSF DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE.
 *
 * IN NO EVENT SHALL OSF BE LIABLE FOR ANY SPECIAL, INDIRECT, OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN ACTION OF CONTRACT,
 * NEGLIGENCE, OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
 * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
d30 1
a30 1
 * To anyone who acknowledges that this file is provided "AS IS"
d32 7
a38 7
 *     permission to use, copy, modify, and distribute this file
 * for any purpose is hereby granted without fee, provided that
 * the above copyright notice and this notice appears in all
 * copies, and that the name of Hewlett-Packard Company not be
 * used in advertising or publicity pertaining to distribution
 * of the software without specific, written prior permission.
 * Hewlett-Packard Company makes no representations about the
d46 1
a46 1
 *Implement an integer multiply routine for 32-bit operands and 64-bit product
d50 1
a50 1
 * size in this implementation.
d63 1
a63 1
saveop2	.equ		8		; save op2 if high bit of multiplicand
d71 2
a72 1
	.text
d103 1
a103 1
	b		fini			; go to finish
d106 1
a106 1
mpy1	addi		-1,gr0,pm		; initialize pm to 111...1
d109 1
a109 1
	extru		op2,31,4,brindex	; 4 bits as index into table
d116 1
a116 1
	extru		pu,27,28,pu		;   <= zero
d139 2
a140 2
	addb,tr		op1,pu,sh4n		; add 2*op1, to shift
	addb,uv		op1,pu,sh4c		;   product right 4 bits
d144 2
a145 2
	addb,tr		op1,pu,sh4n-4		; add op1 & 2*op1, shift
	sh1add,nuv	op1,pu,pu			;   product right 4 bits
d253 2
a254 2
sh2s	shd		pu,pl,2,pl		; shift with minus sign
	shd		pm,pu,2,pu		;
d274 1
a274 1
	shd		pm,pu,3,pu
d285 1
a285 1
sh2c	shd		pu,pl,2,pl
@


1.3.8.2
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d69 9
a77 2
LEAF_ENTRY(impyu)
	stws,ma		pu,4(sp)		; save registers on stack
d317 1
a317 2
EXIT(impyu)

@


1.3.8.3
log
@Sync the SMP branch with 3.3
@
text
@d2 25
d28 13
a40 13
  (c) Copyright 1986 HEWLETT-PACKARD COMPANY
  To anyone who acknowledges that this file is provided "AS IS"
  without any express or implied warranty:
      permission to use, copy, modify, and distribute this file
  for any purpose is hereby granted without fee, provided that
  the above copyright notice and this notice appears in all
  copies, and that the name of Hewlett-Packard Company not be
  used in advertising or publicity pertaining to distribution
  of the software without specific, written prior permission.
  Hewlett-Packard Company makes no representations about the
  suitability of this software for any purpose.
*/
/* @@(#)impyu.s: Revision: 1.11.88.1 Date: 93/12/07 15:06:31 */
a42 2
#define _LOCORE
#include <machine/frame.h>
d44 9
a52 9
;****************************************************************************
;
;Implement an integer multiply routine for 32-bit operands and 64-bit product
; with operand values of zero (multiplicand only) and 2**32reated specially.
; The algorithm uses the multiplier, four bits at a time, from right to left,
; to generate partial product.  Execution speed is more important than program
; size in this implementation.
;
;******************************************************************************
a68 2
;****************************************************************************
	.text
d309 2
a310 1
EXIT(impu)
@


1.3.8.4
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: impyu.S,v 1.3.8.3 2003/03/27 23:26:54 niklas Exp $	*/
d48 1
a48 1
LEAF_ENTRY(u_xmpy)
d288 1
a288 1
EXIT(u_xmpy)
@


1.2
log
@remove brain damaged rcs tags
@
text
@d1 2
d53 14
a66 14
#
# Definitions - General registers
#
gr0	.equ		0		# General register zero
pu	.equ		3		# upper part of product
pl	.equ		4		# lower part of product
op2	.equ		4		# multiplier
op1	.equ		5		# multiplicand
cnt	.equ		6		# count in multiply
brindex	.equ		7		# index into the br. table
saveop2	.equ		8		# save op2 if high bit of multiplicand 
					# is set
pc	.equ		9		# carry bit of product, = 00...01
pm	.equ	       10		# value of -1 used in shifting
d69 1
a69 1
#****************************************************************************
d76 28
a103 28
#
#****************************************************************************
impyu	stws,ma		pu,4(sp)		# save registers on stack
	stws,ma		pl,4(sp)		# save registers on stack
	stws,ma		op1,4(sp)		# save registers on stack
	stws,ma		cnt,4(sp)		# save registers on stack
	stws,ma		brindex,4(sp)		# save registers on stack
	stws,ma		saveop2,4(sp)		# save registers on stack
	stws,ma		pc,4(sp)		# save registers on stack
	stws,ma		pm,4(sp)		# save registers on stack
#
#   Start multiply process
#
	ldws		0(arg0),op1		# get multiplicand
	ldws		0(arg1),op2		# get multiplier
	addib,=		0,op1,fini0		# op1 = 0, product = 0
	addi		0,gr0,pu		# clear product
	bb,>=		op1,0,mpy1		# test msb of multiplicand
	addi		0,gr0,saveop2		# clear saveop2
#
# msb of multiplicand is set so will save multiplier for a final
# addition into the result
#
	extru,=		op1,31,31,op1		# clear msb of multiplicand
	b		mpy1			# if op1 < 2**32, start multiply
	add		op2,gr0,saveop2		#   save op2 in saveop2
	shd		gr0,op2,1,pu		# shift op2 left 31 for result
	b		fini			# go to finish 
d105 6
a110 6
#
mpy1 	addi		-1,gr0,pm		# initialize pm to 111...1
	addi		1,gr0,pc		# initialize pc to 00...01
	movib,tr	8,cnt,mloop		# set count for mpy loop
	extru		op2,31,4,brindex	# 4 bits as index into table 
#
d112 37
a148 37
#
	b		sh4c			# br. if sign overflow
sh4n	shd		pu,pl,4,pl		# shift product right 4 bits
	addib,<=	-1,cnt,mulend		# reduce count by 1, exit if
	extru  		pu,27,28,pu		#   <= zero
#
mloop	blr		brindex,gr0		# br. into table
						#   entries of 2 words
	extru		op2,27,4,brindex	# next 4 bits into index
#
#
#	branch table for the multiplication process with four multiplier bits
#
mtable						# two words per entry
#
# ----	bits = 0000 ---- shift product 4 bits -------------------------------
#
	b		sh4n+4			# just shift partial
	shd		pu,pl,4,pl		#   product right 4 bits
#
#  ----	bits = 0001 ---- add op1, then shift 4 bits
#
	addb,tr		op1,pu,sh4n+4		# add op1 to product, to shift
	shd		pu,pl,4,pl		#   product right 4 bits
#
#  ----	bits = 0010 ---- add op1, add op1, then shift 4 bits
#
	addb,tr		op1,pu,sh4n		# add 2*op1, to shift 
	addb,uv 	op1,pu,sh4c		#   product right 4 bits
#
#  ---- bits = 0011 ---- add op1, add 2*op1, shift 4 bits
#
	addb,tr		op1,pu,sh4n-4		# add op1 & 2*op1, shift 
	sh1add,nuv 	op1,pu,pu			#   product right 4 bits
#
#  ----	bits = 0100 ---- shift 2, add op1, shift 2
#
d150 14
a163 14
	shd		pu,pl,2,pl		# shift product 2 bits
#
#  ----	bits = 0101 ---- add op1, shift 2, add op1, and shift 2 again
#
	addb,tr		op1,pu,sh2us		# add op1 to product
	shd		pu,pl,2,pl		# shift 2 bits
#
#  ----	bits = 0110 ---- add op1, add op1, shift 2, add op1, and shift 2 again
#
	addb,tr		op1,pu,sh2c		# add 2*op1, to shift 2 bits
	addb,nuv	op1,pu,sh2us		# br. if not overflow
#
#  ----	bits = 0111 ---- subtract op1, shift 3, add op1, and shift 1
#
d165 1
a165 1
	sub		pu,op1,pu		# subtract op1, br. to sh3s
d167 3
a169 3
#
#  ----	bits = 1000 ---- shift 3, add op1, shift 1
#
d171 36
a206 36
	shd		pu,pl,3,pl		# shift product right 3 bits
#
#  ----	bits = 1001 ---- add op1, shift 3, add op1, shift 1
#
	addb,tr		op1,pu,sh3us		# add op1, to shift 3, add op1,
	shd		pu,pl,3,pl		#   and shift 1
#
#  ----	bits = 1010 ---- add op1, add op1, shift 3, add op1, shift 1
#
	addb,tr		op1,pu,sh3c		# add 2*op1, to shift 3 bits
	addb,nuv	op1,pu,sh3us		#   br. if no overflow
#
#  ----	bits = 1011 ---- add -op1, shift 2, add -op1, shift 2, inc. next index
#
	addib,tr	1,brindex,sh2s		# add 1 to index, subtract op1,
	sub		pu,op1,pu		#   shift 2 with minus sign
#
#  ----	bits = 1100 ---- shift 2, subtract op1, shift 2, increment next index
#
	addib,tr	1,brindex,sh2sb		# add 1 to index, to shift
	shd		pu,pl,2,pl		# shift right 2 bits signed
#
#  ----	bits = 1101 ---- add op1, shift 2, add -op1, shift 2
#
	addb,tr		op1,pu,sh2ns		# add op1, to shift 2
	shd		pu,pl,2,pl		#   right 2 unsigned, etc.
#
#  ----	bits = 1110 ---- shift 1 signed, add -op1, shift 3 signed
#
	addib,tr	1,brindex,sh1sa		# add 1 to index, to shift
	shd		pu,pl,1,pl		# shift 1 bit
#
#  ----	bits = 1111 ---- add -op1, shift 4 signed
#
	addib,tr	1,brindex,sh4s		# add 1 to index, subtract op1,
	sub		pu,op1,pu		#   to shift 4 signed
d208 8
a215 8
#
#  ----	bits = 10000 ---- shift 4 signed
#
	addib,tr	1,brindex,sh4s+4		# add 1 to index
	shd		pu,pl,4,pl		# shift 4 signed
#
#  ---- end of table ---------------------------------------------------------
#
d217 13
a229 13
	addib,>		-1,cnt,mloop		# decrement count, loop if > 0
	shd		pm,pu,4,pu		# shift 4, minus signed
	addb,tr		op1,pu,lastadd		# do one more add, then finish
	addb,=,n	saveop2,gr0,fini	# check saveop2
#
sh4c	addib,>		-1,cnt,mloop		# decrement count, loop if > 0
	shd		pc,pu,4,pu		# shift 4 with overflow
	b		lastadd			# end of multiply
	addb,=,n	saveop2,gr0,fini	# check saveop2
#
sh3c	shd		pu,pl,3,pl		# shift product 3 bits
	shd		pc,pu,3,pu		# shift 3 signed
	addb,tr		op1,pu,sh1		# add op1, to shift 1 bit
d231 3
a233 3
#
sh3us	extru		pu,28,29,pu		# shift 3 unsigned
	addb,tr		op1,pu,sh1		# add op1, to shift 1 bit
d235 3
a237 3
#
sh3sa	extrs		pu,28,29,pu		# shift 3 signed
	addb,tr		op1,pu,sh1		# add op1, to shift 1 bit
d239 2
a240 2
#
sh3s	shd		pu,pl,3,pl		# shift 3 minus signed
d242 1
a242 1
	addb,tr		op1,pu,sh1		# add op1, to shift 1 bit
d244 2
a245 2
#
sh1	addib,>		-1,cnt,mloop		# loop if count > 0
d247 27
a273 27
	b		lastadd			# end of multiply
	addb,=,n	saveop2,gr0,fini	# check saveop2
#
sh2ns	addib,tr	1,brindex,sh2sb+4	# increment index
	extru		pu,29,30,pu		# shift unsigned
#
sh2s	shd		pu,pl,2,pl		# shift with minus sign 
	shd		pm,pu,2,pu		# 
	sub		pu,op1,pu		# subtract op1
	shd		pu,pl,2,pl		# shift with minus sign
	addib,>		-1,cnt,mloop		# decrement count, loop if > 0
	shd		pm,pu,2,pu		# shift with minus sign
	addb,tr		op1,pu,lastadd		# do one more add, then finish
	addb,=,n	saveop2,gr0,fini	# check saveop2
#
sh2sb	extrs		pu,29,30,pu		# shift 2 signed
	sub		pu,op1,pu		# subtract op1 from product
	shd		pu,pl,2,pl		# shift with minus sign
	addib,>		-1,cnt,mloop		# decrement count, loop if > 0
	shd		pm,pu,2,pu		# shift with minus sign
	addb,tr		op1,pu,lastadd		# do one more add, then finish
	addb,=,n	saveop2,gr0,fini	# check saveop2
#
sh1sa	extrs		pu,30,31,pu		#   signed
	sub		pu,op1,pu		# subtract op1 from product
	shd		pu,pl,3,pl		# shift 3 with minus sign
	addib,>		-1,cnt,mloop		# decrement count, loop if >0
d275 10
a284 10
	addb,tr		op1,pu,lastadd		# do one more add, then finish
	addb,=,n	saveop2,gr0,fini	# check saveop2
#
fini0	movib,tr	0,pl,fini		# product = 0 as op1 = 0
	stws		pu,0(arg2)		# save high part of result
#
sh2us	extru		pu,29,30,pu		# shift 2 unsigned
	addb,tr		op1,pu,sh2a		# add op1
	shd		pu,pl,2,pl		# shift 2 bits
#
d286 9
a294 9
	shd		pc,pu,2,pu		# shift with carry
	addb,tr		op1,pu,sh2a		# add op1 to product
	shd		pu,pl,2,pl		# br. to sh2 to shift pu
#
sh2sa	extrs		pu,29,30,pu		# shift with sign
	addb,tr		op1,pu,sh2a		# add op1 to product
	shd		pu,pl,2,pl		# br. to sh2 to shift pu
#
sh2a	addib,>		-1,cnt,mloop		# loop if count > 0
d296 4
a299 4
#
mulend	addb,=,n	saveop2,gr0,fini	# check saveop2
lastadd	shd		saveop2,gr0,1,temp	#  if saveop2 <> 0, shift it
	shd		gr0,saveop2,1,saveop2	#  left 31 and add to result
d302 5
a306 5
#
#	finish
#
fini	stws		pu,0(arg2)		# save high part of result
	stws		pl,4(arg2)		# save low part of result
d308 9
a316 9
	ldws,mb		-4(sp),pm		# restore registers
	ldws,mb		-4(sp),pc		# restore registers
	ldws,mb		-4(sp),saveop2		# restore registers
	ldws,mb		-4(sp),brindex		# restore registers
	ldws,mb		-4(sp),cnt		# restore registers
	ldws,mb		-4(sp),op1		# restore registers
	ldws,mb		-4(sp),pl		# restore registers
	bv		0(rp)			# return
	ldws,mb		-4(sp),pu		# restore registers
@


1.1
log
@initial import of osf-hacked HP one
@
text
@a38 5
/* $Source: /cvs/mickey/src/arch/hppa/spmath/impyu.S,v $
 * $Revision: 2.0 $	$Author: mickey $
 * $State: Exp $   	$Locker:  $
 * $Date: 1998/06/17 20:47:35 $
 */
@


1.1.1.1
log
@import the original hp sources for the spmath library w/
the a bsd-like hp licensing on 'em.
w/ many thanks to:
Mike Hibler <mike@@fast.cs.utah.edu>
James Loveluck <loveluck@@ri.silicomp.fr>
Patrick Roudaud <patrick@@enserg.fr>
@
text
@d2 39
a40 14
  (c) Copyright 1986 HEWLETT-PACKARD COMPANY
  To anyone who acknowledges that this file is provided "AS IS"
  without any express or implied warranty:
      permission to use, copy, modify, and distribute this file
  for any purpose is hereby granted without fee, provided that
  the above copyright notice and this notice appears in all
  copies, and that the name of Hewlett-Packard Company not be
  used in advertising or publicity pertaining to distribution
  of the software without specific, written prior permission.
  Hewlett-Packard Company makes no representations about the
  suitability of this software for any purpose.
*/
/* $Source: /usr/local/kcs/sys.REL9_05_800/spmath/RCS/impyu.s,v $
 * $Revision: 1.11.88.1 $	$Author: root $
d42 1
a42 1
 * $Date: 93/12/07 15:06:31 $
d45 1
d47 23
a69 23
;****************************************************************************
;
;Implement an integer multiply routine for 32-bit operands and 64-bit product 
; with operand values of zero (multiplicand only) and 2**32reated specially.
; The algorithm uses the multiplier, four bits at a time, from right to left,
; to generate partial product.  Execution speed is more important than program
; size in this implementation. 
;
;******************************************************************************
;
; Definitions - General registers
;
gr0	.equ		0		; General register zero
pu	.equ		3		; upper part of product
pl	.equ		4		; lower part of product
op2	.equ		4		; multiplier
op1	.equ		5		; multiplicand
cnt	.equ		6		; count in multiply
brindex	.equ		7		; index into the br. table
saveop2	.equ		8		; save op2 if high bit of multiplicand 
					; is set
pc	.equ		9		; carry bit of product, = 00...01
pm	.equ	       10		; value of -1 used in shifting
d72 1
a72 1
;****************************************************************************
d79 28
a106 28
;
;****************************************************************************
impyu	stws,ma		pu,4(sp)		; save registers on stack
	stws,ma		pl,4(sp)		; save registers on stack
	stws,ma		op1,4(sp)		; save registers on stack
	stws,ma		cnt,4(sp)		; save registers on stack
	stws,ma		brindex,4(sp)		; save registers on stack
	stws,ma		saveop2,4(sp)		; save registers on stack
	stws,ma		pc,4(sp)		; save registers on stack
	stws,ma		pm,4(sp)		; save registers on stack
;
;   Start multiply process
;
	ldws		(arg0),op1		; get multiplicand
	ldws		(arg1),op2		; get multiplier
	addib,=		0,op1,fini0		; op1 = 0, product = 0
	addi		0,gr0,pu		; clear product
	bb,>=		op1,0,mpy1		; test msb of multiplicand
	addi		0,gr0,saveop2		; clear saveop2
;
; msb of multiplicand is set so will save multiplier for a final
; addition into the result
;
	extru,=		op1,31,31,op1		; clear msb of multiplicand
	b		mpy1			; if op1 < 2**32, start multiply
	add		op2,gr0,saveop2		;   save op2 in saveop2
	shd		gr0,op2,1,pu		; shift op2 left 31 for result
	b		fini			; go to finish 
d108 6
a113 6
;
mpy1 	addi		-1,gr0,pm		; initialize pm to 111...1
	addi		1,gr0,pc		; initialize pc to 00...01
	movib,tr	8,cnt,mloop		; set count for mpy loop
	extru		op2,31,4,brindex	; 4 bits as index into table 
;
d115 37
a151 37
;
	b		sh4c			; br. if sign overflow
sh4n	shd		pu,pl,4,pl		; shift product right 4 bits
	addib,<=	-1,cnt,mulend		; reduce count by 1, exit if
	extru  		pu,27,28,pu		;   <= zero
;
mloop	blr		brindex,gr0		; br. into table
						;   entries of 2 words
	extru		op2,27,4,brindex	; next 4 bits into index
;
;
;	branch table for the multiplication process with four multiplier bits
;
mtable						; two words per entry
;
; ----	bits = 0000 ---- shift product 4 bits -------------------------------
;
	b		sh4n+4			; just shift partial
	shd		pu,pl,4,pl		;   product right 4 bits
;
;  ----	bits = 0001 ---- add op1, then shift 4 bits
;
	addb,tr		op1,pu,sh4n+4		; add op1 to product, to shift
	shd		pu,pl,4,pl		;   product right 4 bits
;
;  ----	bits = 0010 ---- add op1, add op1, then shift 4 bits
;
	addb,tr		op1,pu,sh4n		; add 2*op1, to shift 
	addb,uv 	op1,pu,sh4c		;   product right 4 bits
;
;  ---- bits = 0011 ---- add op1, add 2*op1, shift 4 bits
;
	addb,tr		op1,pu,sh4n-4		; add op1 & 2*op1, shift 
	sh1add,nuv 	op1,pu,pu			;   product right 4 bits
;
;  ----	bits = 0100 ---- shift 2, add op1, shift 2
;
d153 14
a166 14
	shd		pu,pl,2,pl		; shift product 2 bits
;
;  ----	bits = 0101 ---- add op1, shift 2, add op1, and shift 2 again
;
	addb,tr		op1,pu,sh2us		; add op1 to product
	shd		pu,pl,2,pl		; shift 2 bits
;
;  ----	bits = 0110 ---- add op1, add op1, shift 2, add op1, and shift 2 again
;
	addb,tr		op1,pu,sh2c		; add 2*op1, to shift 2 bits
	addb,nuv	op1,pu,sh2us		; br. if not overflow
;
;  ----	bits = 0111 ---- subtract op1, shift 3, add op1, and shift 1
;
d168 1
a168 1
	sub		pu,op1,pu		; subtract op1, br. to sh3s
d170 3
a172 3
;
;  ----	bits = 1000 ---- shift 3, add op1, shift 1
;
d174 36
a209 36
	shd		pu,pl,3,pl		; shift product right 3 bits
;
;  ----	bits = 1001 ---- add op1, shift 3, add op1, shift 1
;
	addb,tr		op1,pu,sh3us		; add op1, to shift 3, add op1,
	shd		pu,pl,3,pl		;   and shift 1
;
;  ----	bits = 1010 ---- add op1, add op1, shift 3, add op1, shift 1
;
	addb,tr		op1,pu,sh3c		; add 2*op1, to shift 3 bits
	addb,nuv	op1,pu,sh3us		;   br. if no overflow
;
;  ----	bits = 1011 ---- add -op1, shift 2, add -op1, shift 2, inc. next index
;
	addib,tr	1,brindex,sh2s		; add 1 to index, subtract op1,
	sub		pu,op1,pu		;   shift 2 with minus sign
;
;  ----	bits = 1100 ---- shift 2, subtract op1, shift 2, increment next index
;
	addib,tr	1,brindex,sh2sb		; add 1 to index, to shift
	shd		pu,pl,2,pl		; shift right 2 bits signed
;
;  ----	bits = 1101 ---- add op1, shift 2, add -op1, shift 2
;
	addb,tr		op1,pu,sh2ns		; add op1, to shift 2
	shd		pu,pl,2,pl		;   right 2 unsigned, etc.
;
;  ----	bits = 1110 ---- shift 1 signed, add -op1, shift 3 signed
;
	addib,tr	1,brindex,sh1sa		; add 1 to index, to shift
	shd		pu,pl,1,pl		; shift 1 bit
;
;  ----	bits = 1111 ---- add -op1, shift 4 signed
;
	addib,tr	1,brindex,sh4s		; add 1 to index, subtract op1,
	sub		pu,op1,pu		;   to shift 4 signed
d211 8
a218 8
;
;  ----	bits = 10000 ---- shift 4 signed
;
	addib,tr	1,brindex,sh4s+4		; add 1 to index
	shd		pu,pl,4,pl		; shift 4 signed
;
;  ---- end of table ---------------------------------------------------------
;
d220 13
a232 13
	addib,>		-1,cnt,mloop		; decrement count, loop if > 0
	shd		pm,pu,4,pu		; shift 4, minus signed
	addb,tr		op1,pu,lastadd		; do one more add, then finish
	addb,=,n	saveop2,gr0,fini	; check saveop2
;
sh4c	addib,>		-1,cnt,mloop		; decrement count, loop if > 0
	shd		pc,pu,4,pu		; shift 4 with overflow
	b		lastadd			; end of multiply
	addb,=,n	saveop2,gr0,fini	; check saveop2
;
sh3c	shd		pu,pl,3,pl		; shift product 3 bits
	shd		pc,pu,3,pu		; shift 3 signed
	addb,tr		op1,pu,sh1		; add op1, to shift 1 bit
d234 3
a236 3
;
sh3us	extru		pu,28,29,pu		; shift 3 unsigned
	addb,tr		op1,pu,sh1		; add op1, to shift 1 bit
d238 3
a240 3
;
sh3sa	extrs		pu,28,29,pu		; shift 3 signed
	addb,tr		op1,pu,sh1		; add op1, to shift 1 bit
d242 2
a243 2
;
sh3s	shd		pu,pl,3,pl		; shift 3 minus signed
d245 1
a245 1
	addb,tr		op1,pu,sh1		; add op1, to shift 1 bit
d247 2
a248 2
;
sh1	addib,>		-1,cnt,mloop		; loop if count > 0
d250 27
a276 27
	b		lastadd			; end of multiply
	addb,=,n	saveop2,gr0,fini	; check saveop2
;
sh2ns	addib,tr	1,brindex,sh2sb+4	; increment index
	extru		pu,29,30,pu		; shift unsigned
;
sh2s	shd		pu,pl,2,pl		; shift with minus sign 
	shd		pm,pu,2,pu		; 
	sub		pu,op1,pu		; subtract op1
	shd		pu,pl,2,pl		; shift with minus sign
	addib,>		-1,cnt,mloop		; decrement count, loop if > 0
	shd		pm,pu,2,pu		; shift with minus sign
	addb,tr		op1,pu,lastadd		; do one more add, then finish
	addb,=,n	saveop2,gr0,fini	; check saveop2
;
sh2sb	extrs		pu,29,30,pu		; shift 2 signed
	sub		pu,op1,pu		; subtract op1 from product
	shd		pu,pl,2,pl		; shift with minus sign
	addib,>		-1,cnt,mloop		; decrement count, loop if > 0
	shd		pm,pu,2,pu		; shift with minus sign
	addb,tr		op1,pu,lastadd		; do one more add, then finish
	addb,=,n	saveop2,gr0,fini	; check saveop2
;
sh1sa	extrs		pu,30,31,pu		;   signed
	sub		pu,op1,pu		; subtract op1 from product
	shd		pu,pl,3,pl		; shift 3 with minus sign
	addib,>		-1,cnt,mloop		; decrement count, loop if >0
d278 10
a287 10
	addb,tr		op1,pu,lastadd		; do one more add, then finish
	addb,=,n	saveop2,gr0,fini	; check saveop2
;
fini0	movib,tr	0,pl,fini		; product = 0 as op1 = 0
	stws		pu,(arg2)		; save high part of result
;
sh2us	extru		pu,29,30,pu		; shift 2 unsigned
	addb,tr		op1,pu,sh2a		; add op1
	shd		pu,pl,2,pl		; shift 2 bits
;
d289 9
a297 9
	shd		pc,pu,2,pu		; shift with carry
	addb,tr		op1,pu,sh2a		; add op1 to product
	shd		pu,pl,2,pl		; br. to sh2 to shift pu
;
sh2sa	extrs		pu,29,30,pu		; shift with sign
	addb,tr		op1,pu,sh2a		; add op1 to product
	shd		pu,pl,2,pl		; br. to sh2 to shift pu
;
sh2a	addib,>		-1,cnt,mloop		; loop if count > 0
d299 4
a302 4
;
mulend	addb,=,n	saveop2,gr0,fini	; check saveop2
lastadd	shd		saveop2,gr0,1,temp	;  if saveop2 <> 0, shift it
	shd		gr0,saveop2,1,saveop2	;  left 31 and add to result
d305 5
a309 5
;
;	finish
;
fini	stws		pu,(arg2)		; save high part of result
	stws		pl,4(arg2)		; save low part of result
d311 9
a319 9
	ldws,mb		-4(sp),pm		; restore registers
	ldws,mb		-4(sp),pc		; restore registers
	ldws,mb		-4(sp),saveop2		; restore registers
	ldws,mb		-4(sp),brindex		; restore registers
	ldws,mb		-4(sp),cnt		; restore registers
	ldws,mb		-4(sp),op1		; restore registers
	ldws,mb		-4(sp),pl		; restore registers
	bv		0(rp)			; return
	ldws,mb		-4(sp),pu		; restore registers
@


