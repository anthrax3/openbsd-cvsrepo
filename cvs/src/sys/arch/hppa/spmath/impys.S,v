head	1.12;
access;
symbols
	OPENBSD_6_1:1.12.0.24
	OPENBSD_6_1_BASE:1.12
	OPENBSD_6_0:1.12.0.22
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.12.0.18
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.12.0.20
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.12
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.12.0.16
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.12.0.14
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.12.0.10
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.12.0.8
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.6
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.4
	OPENBSD_5_0:1.12.0.2
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.11.0.26
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.11.0.24
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.20
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.11.0.22
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.18
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.16
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.14
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.12
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.10
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.8
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.11.0.6
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.4
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.11.0.2
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.10.0.6
	OPENBSD_3_6_BASE:1.10
	SMP_SYNC_A:1.10
	SMP_SYNC_B:1.10
	OPENBSD_3_5:1.10.0.4
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	UBC_SYNC_A:1.10
	OPENBSD_3_3:1.9.0.2
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	HPUX_REL9_05_800:1.1.1.1
	HP:1.1.1
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	UBC_SYNC_B:1.8
	UBC:1.5.0.6
	UBC_BASE:1.5
	OPENBSD_3_0:1.5.0.4
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.3.0.12
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.10
	OPENBSD_2_7_BASE:1.3
	SMP:1.3.0.8
	SMP_BASE:1.3
	kame_19991208:1.3
	OPENBSD_2_6:1.3.0.6
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.4
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.2
	OPENBSD_2_4_BASE:1.3;
locks; strict;
comment	@# @;


1.12
date	2011.04.16.20.52.12;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2005.01.23.18.01.30;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	2003.04.10.17.27.58;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	2003.01.23.20.25.21;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	2002.09.20.19.26.59;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	2002.05.07.22.19.30;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	2002.01.04.08.50.30;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2001.03.29.03.58.18;	author mickey;	state Exp;
branches
	1.5.6.1;
next	1.4;

1.4
date	2001.03.28.23.55.59;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	98.07.02.19.05.32;	author mickey;	state Exp;
branches
	1.3.8.1;
next	1.2;

1.2
date	98.06.23.21.19.41;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	98.06.23.20.34.01;	author mickey;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.05.07.21.37.19;	author mickey;	state Exp;
branches;
next	;

1.3.8.1
date	2001.04.18.16.06.42;	author niklas;	state Exp;
branches;
next	1.3.8.2;

1.3.8.2
date	2002.03.06.00.57.23;	author niklas;	state Exp;
branches;
next	1.3.8.3;

1.3.8.3
date	2003.03.27.23.26.54;	author niklas;	state Exp;
branches;
next	1.3.8.4;

1.3.8.4
date	2003.05.13.19.41.04;	author ho;	state Exp;
branches;
next	;

1.5.6.1
date	2002.01.31.22.55.10;	author niklas;	state Exp;
branches;
next	1.5.6.2;

1.5.6.2
date	2002.06.11.03.35.38;	author art;	state Exp;
branches;
next	1.5.6.3;

1.5.6.3
date	2002.10.29.00.28.03;	author art;	state Exp;
branches;
next	1.5.6.4;

1.5.6.4
date	2003.05.19.21.49.42;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.12
log
@_LOCORE is already defined
@
text
@/*	$OpenBSD: impys.S,v 1.11 2005/01/23 18:01:30 mickey Exp $	*/
/*
  (c) Copyright 1986 HEWLETT-PACKARD COMPANY
  To anyone who acknowledges that this file is provided "AS IS"
  without any express or implied warranty:
      permission to use, copy, modify, and distribute this file
  for any purpose is hereby granted without fee, provided that
  the above copyright notice and this notice appears in all
  copies, and that the name of Hewlett-Packard Company not be
  used in advertising or publicity pertaining to distribution
  of the software without specific, written prior permission.
  Hewlett-Packard Company makes no representations about the
  suitability of this software for any purpose.
*/
/* @@(#)impys.s: Revision: 1.11.88.1 Date: 93/12/07 15:06:28 */

#include <machine/asm.h>
#include <machine/frame.h>

;****************************************************************************
;
;Implement an integer multiply routine for 32-bit operands and 64-bit product
;with operand values of zero (multiplicand only) and -2**31 treated specially.
;The algorithm uses the absolute value of the multiplier, four bits at a time,
;from right to left, to generate partial product.  Execution speed is more
;important than program size in this implementation.
;
;****************************************************************************
;
; Definitions - General registers
;
gr0	.reg		%r0		; General register zero
pu	.reg		%r3		; upper part of product
pl	.reg		%r4		; lower part of product
op2	.reg		%r4		; multiplier
op1	.reg		%r5		; multiplicand
cnt	.reg		%r6		; count in multiply
brindex	.reg		%r7		; index into the br. table
sign	.reg		%r8		; sign of product
pc	.reg		%r9		; carry bit of product, = 00...01
pm	.reg		%r10		; value of -1 used in shifting

;*****************************************************************************
	.text

LEAF_ENTRY(s_xmpy)
	stws,ma		pu,4(sp)		; save registers on stack
	stws,ma		pl,4(sp)		; save registers on stack
	stws,ma		op1,4(sp)		; save registers on stack
	stws,ma		cnt,4(sp)		; save registers on stack
	stws,ma		brindex,4(sp)		; save registers on stack
	stws,ma		sign,4(sp)		; save registers on stack
	stws,ma		pc,4(sp)		; save registers on stack
	stws,ma		pm,4(sp)		; save registers on stack
;
;   Start multiply process
;
	ldws		0(arg1),op2		; get multiplier
	ldws		0(arg0),op1		; get multiplicand
	addi		-1,gr0,pm		; initialize pm to 111...1
	comb,<		op2,gr0,mpyb		; br. if multiplier < 0
	xor		op2,op1,sign		; sign(0) = sign of product
mpy1	comb,<		op1,gr0,mpya		; br. if multiplicand < 0
	addi		0,gr0,pu		; clear product
	addib,=		0,op1,fini0		; op1 = 0, product = 0
mpy2	addi		1,gr0,pc		; initialize pc to 00...01
	movib,tr	8,cnt,mloop		; set count for mpy loop
	extru		op2,31,4,brindex	; 4 bits as index into table
;
	.align		8
;
	b		sh4c			; br. if sign overflow
sh4n	shd		pu,pl,4,pl		; shift product right 4 bits
	addib,<=	-1,cnt,mulend		; reduce count by 1, exit if
	extru		pu,27,28,pu		;   <= zero
;
mloop	blr		brindex,gr0		; br. into table
						;   entries of 2 words
	extru		op2,27,4,brindex	; next 4 bits into index
;
;
;	branch table for the multiplication process with four multiplier bits
;
mtable						; two words per entry
;
; ----	bits = 0000 ---- shift product 4 bits -------------------------------
;
	b		sh4n+4			; just shift partial
	shd		pu,pl,4,pl		;   product right 4 bits
;
;  ----	bits = 0001 ---- add op1, then shift 4 bits
;
	addb,tr		op1,pu,sh4n+4		; add op1 to product, to shift
	shd		pu,pl,4,pl		;   product right 4 bits
;
;  ----	bits = 0010 ---- add op1, add op1, then shift 4 bits
;
	addb,tr		op1,pu,sh4n		; add 2*op1, to shift
	addb,uv		op1,pu,sh4c		;   product right 4 bits
;
;  ---- bits = 0011 ---- add op1, add 2*op1, shift 4 bits
;
	addb,tr		op1,pu,sh4n-4		; add op1 & 2*op1, shift
	sh1add,nsv	op1,pu,pu			;   product right 4 bits
;
;  ----	bits = 0100 ---- shift 2, add op1, shift 2
;
	b		sh2sa
	shd		pu,pl,2,pl		; shift product 2 bits
;
;  ----	bits = 0101 ---- add op1, shift 2, add op1, and shift 2 again
;
	addb,tr		op1,pu,sh2us		; add op1 to product
	shd		pu,pl,2,pl		; shift 2 bits
;
;  ----	bits = 0110 ---- add op1, add op1, shift 2, add op1, and shift 2 again
;
	addb,tr		op1,pu,sh2c		; add 2*op1, to shift 2 bits
	addb,nuv	op1,pu,sh2us		; br. if not overflow
;
;  ----	bits = 0111 ---- subtract op1, shift 3, add op1, and shift 1
;
	b		sh3s
	sub		pu,op1,pu		; subtract op1, br. to sh3s

;
;  ----	bits = 1000 ---- shift 3, add op1, shift 1
;
	b		sh3sa
	shd		pu,pl,3,pl		; shift product right 3 bits
;
;  ----	bits = 1001 ---- add op1, shift 3, add op1, shift 1
;
	addb,tr		op1,pu,sh3us		; add op1, to shift 3, add op1,
	shd		pu,pl,3,pl		;   and shift 1
;
;  ----	bits = 1010 ---- add op1, add op1, shift 3, add op1, shift 1
;
	addb,tr		op1,pu,sh3c		; add 2*op1, to shift 3 bits
	addb,nuv	op1,pu,sh3us		;   br. if no overflow
;
;  ----	bits = 1011 ---- add -op1, shift 2, add -op1, shift 2, inc. next index
;
	addib,tr	1,brindex,sh2s		; add 1 to index, subtract op1,
	sub		pu,op1,pu		;   shift 2 with minus sign
;
;  ----	bits = 1100 ---- shift 2, subtract op1, shift 2, increment next index
;
	addib,tr	1,brindex,sh2sb		; add 1 to index, to shift
	shd		pu,pl,2,pl		; shift right 2 bits signed
;
;  ----	bits = 1101 ---- add op1, shift 2, add -op1, shift 2
;
	addb,tr		op1,pu,sh2ns		; add op1, to shift 2
	shd		pu,pl,2,pl		;   right 2 unsigned, etc.
;
;  ----	bits = 1110 ---- shift 1 signed, add -op1, shift 3 signed
;
	addib,tr	1,brindex,sh1sa		; add 1 to index, to shift
	shd		pu,pl,1,pl		; shift 1 bit
;
;  ----	bits = 1111 ---- add -op1, shift 4 signed
;
	addib,tr	1,brindex,sh4s		; add 1 to index, subtract op1,
	sub		pu,op1,pu		;   to shift 4 signed

;
;  ----	bits = 10000 ---- shift 4 signed
;
	addib,tr	1,brindex,sh4s+4	; add 1 to index
	shd		pu,pl,4,pl		; shift 4 signed
;
;  ---- end of table ---------------------------------------------------------
;
sh4s	shd		pu,pl,4,pl
	addib,tr	-1,cnt,mloop		; loop (count > 0 always here)
	shd		pm,pu,4,pu		; shift 4, minus signed
;
sh4c	addib,>		-1,cnt,mloop		; decrement count, loop if > 0
	shd		pc,pu,4,pu		; shift 4 with overflow
	b		signs			; end of multiply
	bb,>=,n		sign,0,fini		; test sign of procduct
;
mpyb	add,=		op2,op2,gr0		; if <> 0, back to main sect.
	b		mpy1
	sub		0,op2,op2		; op2 = |multiplier|
	add,>=		op1,gr0,gr0		; if op1 < 0, invert sign,
	xor		pm,sign,sign		;   for correct result
;
;	special case for multiplier = -2**31, op1 = signed multiplicand
;		or multiplicand = -2**31, op1 = signed multiplier
;
	shd		op1,0,1,pl		; shift op1 left 31 bits
mmax	extrs		op1,30,31,pu
	b		signs			; negate product (if needed)
	bb,>=,n		sign,0,fini		; test sign of product
;
mpya	add,=		op1,op1,gr0		; op1 = -2**31, special case
	b		mpy2
	sub		0,op1,op1		; op1 = |multiplicand|
	add,>=		op2,gr0,gr0		; if op2 < 0, invert sign,
	xor		pm,sign,sign		;   for correct result
	movb,tr		op2,op1,mmax		; use op2 as multiplicand
	shd		op1,0,1,pl		; shift it left 31 bits
;
sh3c	shd		pu,pl,3,pl		; shift product 3 bits
	shd		pc,pu,3,pu		; shift 3 signed
	addb,tr		op1,pu,sh1		; add op1, to shift 1 bit
	shd		pu,pl,1,pl
;
sh3us	extru		pu,28,29,pu		; shift 3 unsigned
	addb,tr		op1,pu,sh1		; add op1, to shift 1 bit
	shd		pu,pl,1,pl
;
sh3sa	extrs		pu,28,29,pu		; shift 3 signed
	addb,tr		op1,pu,sh1		; add op1, to shift 1 bit
	shd		pu,pl,1,pl
;
sh3s	shd		pu,pl,3,pl		; shift 3 minus signed
	shd		pm,pu,3,pu
	addb,tr		op1,pu,sh1		; add op1, to shift 1 bit
	shd		pu,pl,1,pl
;
sh1	addib,>		-1,cnt,mloop		; loop if count > 0
	extru		pu,30,31,pu
	b		signs			; end of multiply
	bb,>=,n		sign,0,fini		; test sign of product
;
sh2ns	addib,tr	1,brindex,sh2sb+4	; increment index
	extru		pu,29,30,pu		; shift unsigned
;
sh2s	shd		pu,pl,2,pl		; shift with minus sign
	shd		pm,pu,2,pu		;
	sub		pu,op1,pu		; subtract op1
	shd		pu,pl,2,pl		; shift with minus sign
	addib,tr	-1,cnt,mloop		; decrement count, loop
	shd		pm,pu,2,pu		; shift with minus sign
						; count never reaches 0 here
;
sh2sb	extrs		pu,29,30,pu		; shift 2 signed
	sub		pu,op1,pu		; subtract op1 from product
	shd		pu,pl,2,pl		; shift with minus sign
	addib,tr	-1,cnt,mloop		; decrement count, loop
	shd		pm,pu,2,pu		; shift with minus sign
						; count never reaches 0 here
;
sh1sa	extrs		pu,30,31,pu		;   signed
	sub		pu,op1,pu		; subtract op1 from product
	shd		pu,pl,3,pl		; shift 3 with minus sign
	addib,tr	-1,cnt,mloop		; dec. count, to loop
	shd		pm,pu,3,pu		; count never reaches 0 here
;
fini0	movib,tr,n	0,pl,fini		; product = 0 as op1 = 0
;
sh2us	extru		pu,29,30,pu		; shift 2 unsigned
	addb,tr		op1,pu,sh2a		; add op1
	shd		pu,pl,2,pl		; shift 2 bits
;
sh2c	shd		pu,pl,2,pl
	shd		pc,pu,2,pu		; shift with carry
	addb,tr		op1,pu,sh2a		; add op1 to product
	shd		pu,pl,2,pl		; br. to sh2 to shift pu
;
sh2sa	extrs		pu,29,30,pu		; shift with sign
	addb,tr		op1,pu,sh2a		; add op1 to product
	shd		pu,pl,2,pl		; br. to sh2 to shift pu
;
sh2a	addib,>		-1,cnt,mloop		; loop if count > 0
	extru		pu,29,30,pu
;
mulend	bb,>=,n		sign,0,fini		; test sign of product
signs	sub		0,pl,pl			; negate product if sign
	subb		0,pu,pu			;   is negative
;
;	finish
;
fini	stws		pu,0(arg2)		; save high part of result
	stws		pl,4(arg2)		; save low part of result

	ldws,mb		-4(sp),pm		; restore registers
	ldws,mb		-4(sp),pc		; restore registers
	ldws,mb		-4(sp),sign		; restore registers
	ldws,mb		-4(sp),brindex		; restore registers
	ldws,mb		-4(sp),cnt		; restore registers
	ldws,mb		-4(sp),op1		; restore registers
	ldws,mb		-4(sp),pl		; restore registers
	bv		0(rp)			; return
	ldws,mb		-4(sp),pu		; restore registers
EXIT(s_xmpy)

	.end
@


1.11
log
@use register names instead of numbers
@
text
@d1 1
a1 1
/*	$OpenBSD: impys.S,v 1.10 2003/04/10 17:27:58 mickey Exp $	*/
a17 1
#define _LOCORE
@


1.10
log
@make all entry points of the same number of arguments and that greatly simplifies the call setup in the scheduler
@
text
@d1 1
a1 1
/*	$OpenBSD: impys.S,v 1.9 2003/01/23 20:25:21 mickey Exp $	*/
d33 10
a42 10
gr0	.equ		0		; General register zero
pu	.equ		3		; upper part of product
pl	.equ		4		; lower part of product
op2	.equ		4		; multiplier
op1	.equ		5		; multiplicand
cnt	.equ		6		; count in multiply
brindex	.equ		7		; index into the br. table
sign	.equ		8		; sign of product
pc	.equ		9		; carry bit of product, = 00...01
pm	.equ	       10		; value of -1 used in shifting
@


1.9
log
@will need machine/frame.h for profiling
@
text
@d1 1
a1 1
/*	$OpenBSD: impys.S,v 1.8 2002/09/20 19:26:59 mickey Exp $	*/
d47 1
a47 1
LEAF_ENTRY(impys)
d290 1
a290 1
EXIT(imyps)
@


1.8
log
@kill dangling space, line and a space in the tab
@
text
@d1 1
a1 1
/*	$OpenBSD: impys.S,v 1.7 2002/05/07 22:19:30 mickey Exp $	*/
d18 2
@


1.7
log
@bring over our mods; the cnv*c have a problem now, described in the osf version of the cnv_float.h, at the end
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d21 1
a21 1
;Implement an integer multiply routine for 32-bit operands and 64-bit product 
d25 1
a25 1
;important than program size in this implementation. 
d67 1
a67 1
	extru		op2,31,4,brindex	; 4 bits as index into table 
d74 1
a74 1
	extru  		pu,27,28,pu		;   <= zero
d97 2
a98 2
	addb,tr		op1,pu,sh4n		; add 2*op1, to shift 
	addb,uv 	op1,pu,sh4c		;   product right 4 bits
d102 2
a103 2
	addb,tr		op1,pu,sh4n-4		; add op1 & 2*op1, shift 
	sh1add,nsv 	op1,pu,pu			;   product right 4 bits
d186 1
a186 1
	add,>=		op1,gr0,gr0		; if op1 < 0, invert sign, 
d193 1
a193 1
mmax	extrs		op1,30,31,pu	
d200 1
a200 1
	add,>=		op2,gr0,gr0		; if op2 < 0, invert sign, 
d231 2
a232 2
sh2s	shd		pu,pl,2,pl		; shift with minus sign 
	shd		pm,pu,2,pu		; 
d258 1
a258 1
sh2c	shd		pu,pl,2,pl	
@


1.6
log
@Use LEAF_ENTRY not ENTRY.
@
text
@d1 1
a1 26
/*	$OpenBSD: impys.S,v 1.5 2001/03/29 03:58:18 mickey Exp $	*/

/*
 * Copyright 1996 1995 by Open Software Foundation, Inc.
 *              All Rights Reserved
 *
 * Permission to use, copy, modify, and distribute this software and
 * its documentation for any purpose and without fee is hereby granted,
 * provided that the above copyright notice appears in all copies and
 * that both the copyright notice and this permission notice appear in
 * supporting documentation.
 *
 * OSF DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE.
 *
 * IN NO EVENT SHALL OSF BE LIABLE FOR ANY SPECIAL, INDIRECT, OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN ACTION OF CONTRACT,
 * NEGLIGENCE, OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
 * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */
/*
 * pmk1.1
 */
d3 13
a15 13
 * (c) Copyright 1986 HEWLETT-PACKARD COMPANY
 *
 * To anyone who acknowledges that this file is provided "AS IS"
 * without any express or implied warranty:
 *     permission to use, copy, modify, and distribute this file
 * for any purpose is hereby granted without fee, provided that
 * the above copyright notice and this notice appears in all
 * copies, and that the name of Hewlett-Packard Company not be
 * used in advertising or publicity pertaining to distribution
 * of the software without specific, written prior permission.
 * Hewlett-Packard Company makes no representations about the
 * suitability of this software for any purpose.
 */
d19 22
a40 22
/****************************************************************************
 *
 * Implement an integer multiply routine for 32-bit operands and 64-bit product
 * with operand values of zero (multiplicand only) and -2**31 treated specially.
 * The algorithm uses the absolute value of the multiplier, four bits at a time,
 * from right to left, to generate partial product.  Execution speed is more
 * important than program size in this implementation.
 *
 ***************************************************************************/
/*
 * Definitions - General registers
 */
gr0	.equ		0		/* General register zero */
pu	.equ		3		/* upper part of product */
pl	.equ		4		/* lower part of product */
op2	.equ		4		/* multiplier */
op1	.equ		5		/* multiplicand */
cnt	.equ		6		/* count in multiply */
brindex	.equ		7		/* index into the br. table */
sign	.equ		8		/* sign of product */
pc	.equ		9		/* carry bit of product, = 00...01 */
pm	.equ	       10		/* value of -1 used in shifting */
d42 1
d67 1
a67 1
	extru		op2,31,4,brindex	; 4 bits as index into table
d74 1
a74 1
	extru		pu,27,28,pu		;   <= zero
d97 2
a98 2
	addb,tr		op1,pu,sh4n		; add 2*op1, to shift
	addb,uv		op1,pu,sh4c		;   product right 4 bits
d102 2
a103 2
	addb,tr		op1,pu,sh4n-4		; add op1 & 2*op1, shift
	sh1add,nsv	op1,pu,pu		;   product right 4 bits
d186 1
a186 1
	add,>=		op1,gr0,gr0		; if op1 < 0, invert sign,
d193 1
a193 1
mmax	extrs		op1,30,31,pu
d200 1
a200 1
	add,>=		op2,gr0,gr0		; if op2 < 0, invert sign,
d231 2
a232 2
sh2s	shd		pu,pl,2,pl		; shift with minus sign
	shd		pm,pu,2,pu		;
d258 1
a258 1
sh2c	shd		pu,pl,2,pl
d288 1
a289 1
EXIT(impys)
@


1.5
log
@big bang
@
text
@d1 1
a1 1
/*	$OpenBSD: impys.S,v 1.4 2001/03/28 23:55:59 mickey Exp $	*/
d69 1
a69 1
ENTRY(impys)
@


1.5.6.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: impys.S,v 1.6 2002/01/04 08:50:30 miod Exp $	*/
d69 1
a69 1
LEAF_ENTRY(impys)
@


1.5.6.2
log
@Sync UBC branch to -current
@
text
@d1 26
a26 1
/*	$OpenBSD$	*/
d28 13
a40 13
  (c) Copyright 1986 HEWLETT-PACKARD COMPANY
  To anyone who acknowledges that this file is provided "AS IS"
  without any express or implied warranty:
      permission to use, copy, modify, and distribute this file
  for any purpose is hereby granted without fee, provided that
  the above copyright notice and this notice appears in all
  copies, and that the name of Hewlett-Packard Company not be
  used in advertising or publicity pertaining to distribution
  of the software without specific, written prior permission.
  Hewlett-Packard Company makes no representations about the
  suitability of this software for any purpose.
*/
/* @@(#)impys.s: Revision: 1.11.88.1 Date: 93/12/07 15:06:28 */
d44 22
a65 22
;****************************************************************************
;
;Implement an integer multiply routine for 32-bit operands and 64-bit product 
;with operand values of zero (multiplicand only) and -2**31 treated specially.
;The algorithm uses the absolute value of the multiplier, four bits at a time,
;from right to left, to generate partial product.  Execution speed is more
;important than program size in this implementation. 
;
;****************************************************************************
;
; Definitions - General registers
;
gr0	.equ		0		; General register zero
pu	.equ		3		; upper part of product
pl	.equ		4		; lower part of product
op2	.equ		4		; multiplier
op1	.equ		5		; multiplicand
cnt	.equ		6		; count in multiply
brindex	.equ		7		; index into the br. table
sign	.equ		8		; sign of product
pc	.equ		9		; carry bit of product, = 00...01
pm	.equ	       10		; value of -1 used in shifting
a66 1
;*****************************************************************************
d91 1
a91 1
	extru		op2,31,4,brindex	; 4 bits as index into table 
d98 1
a98 1
	extru  		pu,27,28,pu		;   <= zero
d121 2
a122 2
	addb,tr		op1,pu,sh4n		; add 2*op1, to shift 
	addb,uv 	op1,pu,sh4c		;   product right 4 bits
d126 2
a127 2
	addb,tr		op1,pu,sh4n-4		; add op1 & 2*op1, shift 
	sh1add,nsv 	op1,pu,pu			;   product right 4 bits
d210 1
a210 1
	add,>=		op1,gr0,gr0		; if op1 < 0, invert sign, 
d217 1
a217 1
mmax	extrs		op1,30,31,pu	
d224 1
a224 1
	add,>=		op2,gr0,gr0		; if op2 < 0, invert sign, 
d255 2
a256 2
sh2s	shd		pu,pl,2,pl		; shift with minus sign 
	shd		pm,pu,2,pu		; 
d282 1
a282 1
sh2c	shd		pu,pl,2,pl	
a311 1
EXIT(imyps)
d313 1
@


1.5.6.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: impys.S,v 1.5.6.2 2002/06/11 03:35:38 art Exp $	*/
d21 1
a21 1
;Implement an integer multiply routine for 32-bit operands and 64-bit product
d25 1
a25 1
;important than program size in this implementation.
d67 1
a67 1
	extru		op2,31,4,brindex	; 4 bits as index into table
d74 1
a74 1
	extru		pu,27,28,pu		;   <= zero
d97 2
a98 2
	addb,tr		op1,pu,sh4n		; add 2*op1, to shift
	addb,uv		op1,pu,sh4c		;   product right 4 bits
d102 2
a103 2
	addb,tr		op1,pu,sh4n-4		; add op1 & 2*op1, shift
	sh1add,nsv	op1,pu,pu			;   product right 4 bits
d186 1
a186 1
	add,>=		op1,gr0,gr0		; if op1 < 0, invert sign,
d193 1
a193 1
mmax	extrs		op1,30,31,pu
d200 1
a200 1
	add,>=		op2,gr0,gr0		; if op2 < 0, invert sign,
d231 2
a232 2
sh2s	shd		pu,pl,2,pl		; shift with minus sign
	shd		pm,pu,2,pu		;
d258 1
a258 1
sh2c	shd		pu,pl,2,pl
@


1.5.6.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a17 2
#define _LOCORE
#include <machine/frame.h>
d45 1
a45 1
LEAF_ENTRY(s_xmpy)
d288 1
a288 1
EXIT(s_xmpy)
@


1.4
log
@start of text
@
text
@d1 1
a1 1
/*	$OpenBSD: impys.S,v 1.3 1998/07/02 19:05:32 mickey Exp $	*/
d4 19
a22 19
 * Copyright 1996 1995 by Open Software Foundation, Inc.   
 *              All Rights Reserved 
 *  
 * Permission to use, copy, modify, and distribute this software and 
 * its documentation for any purpose and without fee is hereby granted, 
 * provided that the above copyright notice appears in all copies and 
 * that both the copyright notice and this permission notice appear in 
 * supporting documentation. 
 *  
 * OSF DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE 
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS 
 * FOR A PARTICULAR PURPOSE. 
 *  
 * IN NO EVENT SHALL OSF BE LIABLE FOR ANY SPECIAL, INDIRECT, OR 
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM 
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN ACTION OF CONTRACT, 
 * NEGLIGENCE, OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION 
 * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. 
 * 
d30 1
a30 1
 * To anyone who acknowledges that this file is provided "AS IS" 
d32 7
a38 7
 *     permission to use, copy, modify, and distribute this file 
 * for any purpose is hereby granted without fee, provided that 
 * the above copyright notice and this notice appears in all 
 * copies, and that the name of Hewlett-Packard Company not be 
 * used in advertising or publicity pertaining to distribution 
 * of the software without specific, written prior permission.  
 * Hewlett-Packard Company makes no representations about the 
d46 1
a46 1
 * Implement an integer multiply routine for 32-bit operands and 64-bit product 
d50 1
a50 1
 * important than program size in this implementation. 
d91 1
a91 1
	extru		op2,31,4,brindex	; 4 bits as index into table 
d98 1
a98 1
	extru  		pu,27,28,pu		;   <= zero
d121 2
a122 2
	addb,tr		op1,pu,sh4n		; add 2*op1, to shift 
	addb,uv 	op1,pu,sh4c		;   product right 4 bits
d126 2
a127 2
	addb,tr		op1,pu,sh4n-4		; add op1 & 2*op1, shift 
	sh1add,nsv 	op1,pu,pu		;   product right 4 bits
d210 1
a210 1
	add,>=		op1,gr0,gr0		; if op1 < 0, invert sign, 
d217 1
a217 1
mmax	extrs		op1,30,31,pu	
d224 1
a224 1
	add,>=		op2,gr0,gr0		; if op2 < 0, invert sign, 
d255 2
a256 2
sh2s	shd		pu,pl,2,pl		; shift with minus sign 
	shd		pm,pu,2,pu		; 
d282 1
a282 1
sh2c	shd		pu,pl,2,pl	
@


1.3
log
@ansi and fancy gcc
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d66 2
@


1.3.8.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: impys.S,v 1.5 2001/03/29 03:58:18 mickey Exp $	*/
d4 19
a22 19
 * Copyright 1996 1995 by Open Software Foundation, Inc.
 *              All Rights Reserved
 *
 * Permission to use, copy, modify, and distribute this software and
 * its documentation for any purpose and without fee is hereby granted,
 * provided that the above copyright notice appears in all copies and
 * that both the copyright notice and this permission notice appear in
 * supporting documentation.
 *
 * OSF DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE.
 *
 * IN NO EVENT SHALL OSF BE LIABLE FOR ANY SPECIAL, INDIRECT, OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN ACTION OF CONTRACT,
 * NEGLIGENCE, OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
 * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
d30 1
a30 1
 * To anyone who acknowledges that this file is provided "AS IS"
d32 7
a38 7
 *     permission to use, copy, modify, and distribute this file
 * for any purpose is hereby granted without fee, provided that
 * the above copyright notice and this notice appears in all
 * copies, and that the name of Hewlett-Packard Company not be
 * used in advertising or publicity pertaining to distribution
 * of the software without specific, written prior permission.
 * Hewlett-Packard Company makes no representations about the
d46 1
a46 1
 * Implement an integer multiply routine for 32-bit operands and 64-bit product
d50 1
a50 1
 * important than program size in this implementation.
a66 2
	.text

d89 1
a89 1
	extru		op2,31,4,brindex	; 4 bits as index into table
d96 1
a96 1
	extru		pu,27,28,pu		;   <= zero
d119 2
a120 2
	addb,tr		op1,pu,sh4n		; add 2*op1, to shift
	addb,uv		op1,pu,sh4c		;   product right 4 bits
d124 2
a125 2
	addb,tr		op1,pu,sh4n-4		; add op1 & 2*op1, shift
	sh1add,nsv	op1,pu,pu		;   product right 4 bits
d208 1
a208 1
	add,>=		op1,gr0,gr0		; if op1 < 0, invert sign,
d215 1
a215 1
mmax	extrs		op1,30,31,pu
d222 1
a222 1
	add,>=		op2,gr0,gr0		; if op2 < 0, invert sign,
d253 2
a254 2
sh2s	shd		pu,pl,2,pl		; shift with minus sign
	shd		pm,pu,2,pu		;
d280 1
a280 1
sh2c	shd		pu,pl,2,pl
@


1.3.8.2
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d69 1
a69 1
LEAF_ENTRY(impys)
@


1.3.8.3
log
@Sync the SMP branch with 3.3
@
text
@d2 25
d28 13
a40 13
  (c) Copyright 1986 HEWLETT-PACKARD COMPANY
  To anyone who acknowledges that this file is provided "AS IS"
  without any express or implied warranty:
      permission to use, copy, modify, and distribute this file
  for any purpose is hereby granted without fee, provided that
  the above copyright notice and this notice appears in all
  copies, and that the name of Hewlett-Packard Company not be
  used in advertising or publicity pertaining to distribution
  of the software without specific, written prior permission.
  Hewlett-Packard Company makes no representations about the
  suitability of this software for any purpose.
*/
/* @@(#)impys.s: Revision: 1.11.88.1 Date: 93/12/07 15:06:28 */
a42 2
#define _LOCORE
#include <machine/frame.h>
d44 22
a65 22
;****************************************************************************
;
;Implement an integer multiply routine for 32-bit operands and 64-bit product
;with operand values of zero (multiplicand only) and -2**31 treated specially.
;The algorithm uses the absolute value of the multiplier, four bits at a time,
;from right to left, to generate partial product.  Execution speed is more
;important than program size in this implementation.
;
;****************************************************************************
;
; Definitions - General registers
;
gr0	.equ		0		; General register zero
pu	.equ		3		; upper part of product
pl	.equ		4		; lower part of product
op2	.equ		4		; multiplier
op1	.equ		5		; multiplicand
cnt	.equ		6		; count in multiply
brindex	.equ		7		; index into the br. table
sign	.equ		8		; sign of product
pc	.equ		9		; carry bit of product, = 00...01
pm	.equ	       10		; value of -1 used in shifting
a66 1
;*****************************************************************************
d127 1
a127 1
	sh1add,nsv	op1,pu,pu			;   product right 4 bits
a311 1
EXIT(imyps)
d313 1
@


1.3.8.4
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: impys.S,v 1.3.8.3 2003/03/27 23:26:54 niklas Exp $	*/
d47 1
a47 1
LEAF_ENTRY(s_xmpy)
d290 1
a290 1
EXIT(s_xmpy)
@


1.2
log
@remove brain damaged rcs tags
@
text
@d1 2
d53 13
a65 13
#
# Definitions - General registers
#
gr0	.equ		0		# General register zero
pu	.equ		3		# upper part of product
pl	.equ		4		# lower part of product
op2	.equ		4		# multiplier
op1	.equ		5		# multiplicand
cnt	.equ		6		# count in multiply
brindex	.equ		7		# index into the br. table
sign	.equ		8		# sign of product
pc	.equ		9		# carry bit of product, = 00...01
pm	.equ	       10		# value of -1 used in shifting
d67 24
a90 32
#*****************************************************************************
	.export impys,entry
	.space $TEXT$
	.subspa $CODE$
	.align 4
	.proc
	.callinfo
#
#****************************************************************************
impys	stws,ma		pu,4(sp)		# save registers on stack
	stws,ma		pl,4(sp)		# save registers on stack
	stws,ma		op1,4(sp)		# save registers on stack
	stws,ma		cnt,4(sp)		# save registers on stack
	stws,ma		brindex,4(sp)		# save registers on stack
	stws,ma		sign,4(sp)		# save registers on stack
	stws,ma		pc,4(sp)		# save registers on stack
	stws,ma		pm,4(sp)		# save registers on stack
#
#   Start multiply process
#
	ldws		0(arg1),op2		# get multiplier
	ldws		0(arg0),op1		# get multiplicand
	addi		-1,gr0,pm		# initialize pm to 111...1
	comb,<		op2,gr0,mpyb		# br. if multiplier < 0
	xor		op2,op1,sign		# sign(0) = sign of product
mpy1	comb,<		op1,gr0,mpya		# br. if multiplicand < 0
	addi		0,gr0,pu		# clear product
	addib,=		0,op1,fini0		# op1 = 0, product = 0
mpy2	addi		1,gr0,pc		# initialize pc to 00...01
	movib,tr	8,cnt,mloop		# set count for mpy loop
	extru		op2,31,4,brindex	# 4 bits as index into table 
#
d92 37
a128 37
#
	b		sh4c			# br. if sign overflow
sh4n	shd		pu,pl,4,pl		# shift product right 4 bits
	addib,<=	-1,cnt,mulend		# reduce count by 1, exit if
	extru  		pu,27,28,pu		#   <= zero
#
mloop	blr		brindex,gr0		# br. into table
						#   entries of 2 words
	extru		op2,27,4,brindex	# next 4 bits into index
#
#
#	branch table for the multiplication process with four multiplier bits
#
mtable						# two words per entry
#
# ----	bits = 0000 ---- shift product 4 bits -------------------------------
#
	b		sh4n+4			# just shift partial
	shd		pu,pl,4,pl		#   product right 4 bits
#
#  ----	bits = 0001 ---- add op1, then shift 4 bits
#
	addb,tr		op1,pu,sh4n+4		# add op1 to product, to shift
	shd		pu,pl,4,pl		#   product right 4 bits
#
#  ----	bits = 0010 ---- add op1, add op1, then shift 4 bits
#
	addb,tr		op1,pu,sh4n		# add 2*op1, to shift 
	addb,uv 	op1,pu,sh4c		#   product right 4 bits
#
#  ---- bits = 0011 ---- add op1, add 2*op1, shift 4 bits
#
	addb,tr		op1,pu,sh4n-4		# add op1 & 2*op1, shift 
	sh1add,nsv 	op1,pu,pu			#   product right 4 bits
#
#  ----	bits = 0100 ---- shift 2, add op1, shift 2
#
d130 14
a143 14
	shd		pu,pl,2,pl		# shift product 2 bits
#
#  ----	bits = 0101 ---- add op1, shift 2, add op1, and shift 2 again
#
	addb,tr		op1,pu,sh2us		# add op1 to product
	shd		pu,pl,2,pl		# shift 2 bits
#
#  ----	bits = 0110 ---- add op1, add op1, shift 2, add op1, and shift 2 again
#
	addb,tr		op1,pu,sh2c		# add 2*op1, to shift 2 bits
	addb,nuv	op1,pu,sh2us		# br. if not overflow
#
#  ----	bits = 0111 ---- subtract op1, shift 3, add op1, and shift 1
#
d145 1
a145 1
	sub		pu,op1,pu		# subtract op1, br. to sh3s
d147 3
a149 3
#
#  ----	bits = 1000 ---- shift 3, add op1, shift 1
#
d151 36
a186 36
	shd		pu,pl,3,pl		# shift product right 3 bits
#
#  ----	bits = 1001 ---- add op1, shift 3, add op1, shift 1
#
	addb,tr		op1,pu,sh3us		# add op1, to shift 3, add op1,
	shd		pu,pl,3,pl		#   and shift 1
#
#  ----	bits = 1010 ---- add op1, add op1, shift 3, add op1, shift 1
#
	addb,tr		op1,pu,sh3c		# add 2*op1, to shift 3 bits
	addb,nuv	op1,pu,sh3us		#   br. if no overflow
#
#  ----	bits = 1011 ---- add -op1, shift 2, add -op1, shift 2, inc. next index
#
	addib,tr	1,brindex,sh2s		# add 1 to index, subtract op1,
	sub		pu,op1,pu		#   shift 2 with minus sign
#
#  ----	bits = 1100 ---- shift 2, subtract op1, shift 2, increment next index
#
	addib,tr	1,brindex,sh2sb		# add 1 to index, to shift
	shd		pu,pl,2,pl		# shift right 2 bits signed
#
#  ----	bits = 1101 ---- add op1, shift 2, add -op1, shift 2
#
	addb,tr		op1,pu,sh2ns		# add op1, to shift 2
	shd		pu,pl,2,pl		#   right 2 unsigned, etc.
#
#  ----	bits = 1110 ---- shift 1 signed, add -op1, shift 3 signed
#
	addib,tr	1,brindex,sh1sa		# add 1 to index, to shift
	shd		pu,pl,1,pl		# shift 1 bit
#
#  ----	bits = 1111 ---- add -op1, shift 4 signed
#
	addib,tr	1,brindex,sh4s		# add 1 to index, subtract op1,
	sub		pu,op1,pu		#   to shift 4 signed
d188 8
a195 8
#
#  ----	bits = 10000 ---- shift 4 signed
#
	addib,tr	1,brindex,sh4s+4	# add 1 to index
	shd		pu,pl,4,pl		# shift 4 signed
#
#  ---- end of table ---------------------------------------------------------
#
d197 9
a205 9
	addib,tr	-1,cnt,mloop		# loop (count > 0 always here)
	shd		pm,pu,4,pu		# shift 4, minus signed
#
sh4c	addib,>		-1,cnt,mloop		# decrement count, loop if > 0
	shd		pc,pu,4,pu		# shift 4 with overflow
	b		signs			# end of multiply
	bb,>=,n		sign,0,fini		# test sign of procduct
#
mpyb	add,=		op2,op2,gr0		# if <> 0, back to main sect.
d207 8
a214 8
	sub		0,op2,op2		# op2 = |multiplier|
	add,>=		op1,gr0,gr0		# if op1 < 0, invert sign, 
	xor		pm,sign,sign		#   for correct result
#
#	special case for multiplier = -2**31, op1 = signed multiplicand
#		or multiplicand = -2**31, op1 = signed multiplier
#
	shd		op1,0,1,pl		# shift op1 left 31 bits
d216 4
a219 4
	b		signs			# negate product (if needed)
	bb,>=,n		sign,0,fini		# test sign of product
#
mpya	add,=		op1,op1,gr0		# op1 = -2**31, special case
d221 9
a229 9
	sub		0,op1,op1		# op1 = |multiplicand|
	add,>=		op2,gr0,gr0		# if op2 < 0, invert sign, 
	xor		pm,sign,sign		#   for correct result
	movb,tr		op2,op1,mmax		# use op2 as multiplicand
	shd		op1,0,1,pl		# shift it left 31 bits
#
sh3c	shd		pu,pl,3,pl		# shift product 3 bits
	shd		pc,pu,3,pu		# shift 3 signed
	addb,tr		op1,pu,sh1		# add op1, to shift 1 bit
d231 3
a233 3
#
sh3us	extru		pu,28,29,pu		# shift 3 unsigned
	addb,tr		op1,pu,sh1		# add op1, to shift 1 bit
d235 3
a237 3
#
sh3sa	extrs		pu,28,29,pu		# shift 3 signed
	addb,tr		op1,pu,sh1		# add op1, to shift 1 bit
d239 2
a240 2
#
sh3s	shd		pu,pl,3,pl		# shift 3 minus signed
d242 1
a242 1
	addb,tr		op1,pu,sh1		# add op1, to shift 1 bit
d244 2
a245 2
#
sh1	addib,>		-1,cnt,mloop		# loop if count > 0
d247 33
a279 33
	b		signs			# end of multiply
	bb,>=,n		sign,0,fini		# test sign of product
#
sh2ns	addib,tr	1,brindex,sh2sb+4	# increment index
	extru		pu,29,30,pu		# shift unsigned
#
sh2s	shd		pu,pl,2,pl		# shift with minus sign 
	shd		pm,pu,2,pu		# 
	sub		pu,op1,pu		# subtract op1
	shd		pu,pl,2,pl		# shift with minus sign
	addib,tr	-1,cnt,mloop		# decrement count, loop
	shd		pm,pu,2,pu		# shift with minus sign
						# count never reaches 0 here
#
sh2sb	extrs		pu,29,30,pu		# shift 2 signed
	sub		pu,op1,pu		# subtract op1 from product
	shd		pu,pl,2,pl		# shift with minus sign
	addib,tr	-1,cnt,mloop		# decrement count, loop
	shd		pm,pu,2,pu		# shift with minus sign
						# count never reaches 0 here
#
sh1sa	extrs		pu,30,31,pu		#   signed
	sub		pu,op1,pu		# subtract op1 from product
	shd		pu,pl,3,pl		# shift 3 with minus sign
	addib,tr	-1,cnt,mloop		# dec. count, to loop
	shd		pm,pu,3,pu		# count never reaches 0 here
#
fini0	movib,tr,n	0,pl,fini		# product = 0 as op1 = 0
#
sh2us	extru		pu,29,30,pu		# shift 2 unsigned
	addb,tr		op1,pu,sh2a		# add op1
	shd		pu,pl,2,pl		# shift 2 bits
#
d281 9
a289 9
	shd		pc,pu,2,pu		# shift with carry
	addb,tr		op1,pu,sh2a		# add op1 to product
	shd		pu,pl,2,pl		# br. to sh2 to shift pu
#
sh2sa	extrs		pu,29,30,pu		# shift with sign
	addb,tr		op1,pu,sh2a		# add op1 to product
	shd		pu,pl,2,pl		# br. to sh2 to shift pu
#
sh2a	addib,>		-1,cnt,mloop		# loop if count > 0
d291 9
a299 9
#
mulend	bb,>=,n		sign,0,fini		# test sign of product
signs	sub		0,pl,pl			# negate product if sign
	subb		0,pu,pu			#   is negative
#
#	finish
#
fini	stws		pu,0(arg2)		# save high part of result
	stws		pl,4(arg2)		# save low part of result
d301 9
a309 9
	ldws,mb		-4(sp),pm		# restore registers
	ldws,mb		-4(sp),pc		# restore registers
	ldws,mb		-4(sp),sign		# restore registers
	ldws,mb		-4(sp),brindex		# restore registers
	ldws,mb		-4(sp),cnt		# restore registers
	ldws,mb		-4(sp),op1		# restore registers
	ldws,mb		-4(sp),pl		# restore registers
	bv		0(rp)			# return
	ldws,mb		-4(sp),pu		# restore registers
d311 1
a311 1
	.procend
@


1.1
log
@initial import of osf-hacked HP one
@
text
@a38 5
/* $Source: /cvs/mickey/src/arch/hppa/spmath/impys.S,v $
 * $Revision: 2.0 $	$Author: mickey $
 * $State: Exp $   	$Locker:  $
 * $Date: 1998/06/17 20:47:34 $
 */
@


1.1.1.1
log
@import the original hp sources for the spmath library w/
the a bsd-like hp licensing on 'em.
w/ many thanks to:
Mike Hibler <mike@@fast.cs.utah.edu>
James Loveluck <loveluck@@ri.silicomp.fr>
Patrick Roudaud <patrick@@enserg.fr>
@
text
@d2 39
a40 14
  (c) Copyright 1986 HEWLETT-PACKARD COMPANY
  To anyone who acknowledges that this file is provided "AS IS"
  without any express or implied warranty:
      permission to use, copy, modify, and distribute this file
  for any purpose is hereby granted without fee, provided that
  the above copyright notice and this notice appears in all
  copies, and that the name of Hewlett-Packard Company not be
  used in advertising or publicity pertaining to distribution
  of the software without specific, written prior permission.
  Hewlett-Packard Company makes no representations about the
  suitability of this software for any purpose.
*/
/* $Source: /usr/local/kcs/sys.REL9_05_800/spmath/RCS/impys.s,v $
 * $Revision: 1.11.88.1 $	$Author: root $
d42 1
a42 1
 * $Date: 93/12/07 15:06:28 $
d45 1
d47 22
a68 22
;****************************************************************************
;
;Implement an integer multiply routine for 32-bit operands and 64-bit product 
;with operand values of zero (multiplicand only) and -2**31 treated specially.
;The algorithm uses the absolute value of the multiplier, four bits at a time,
;from right to left, to generate partial product.  Execution speed is more
;important than program size in this implementation. 
;
;****************************************************************************
;
; Definitions - General registers
;
gr0	.equ		0		; General register zero
pu	.equ		3		; upper part of product
pl	.equ		4		; lower part of product
op2	.equ		4		; multiplier
op1	.equ		5		; multiplicand
cnt	.equ		6		; count in multiply
brindex	.equ		7		; index into the br. table
sign	.equ		8		; sign of product
pc	.equ		9		; carry bit of product, = 00...01
pm	.equ	       10		; value of -1 used in shifting
d70 1
a70 1
;*****************************************************************************
d77 25
a101 25
;
;****************************************************************************
impys	stws,ma		pu,4(sp)		; save registers on stack
	stws,ma		pl,4(sp)		; save registers on stack
	stws,ma		op1,4(sp)		; save registers on stack
	stws,ma		cnt,4(sp)		; save registers on stack
	stws,ma		brindex,4(sp)		; save registers on stack
	stws,ma		sign,4(sp)		; save registers on stack
	stws,ma		pc,4(sp)		; save registers on stack
	stws,ma		pm,4(sp)		; save registers on stack
;
;   Start multiply process
;
	ldws		(arg1),op2		; get multiplier
	ldws		(arg0),op1		; get multiplicand
	addi		-1,gr0,pm		; initialize pm to 111...1
	comb,<		op2,gr0,mpyb		; br. if multiplier < 0
	xor		op2,op1,sign		; sign(0) = sign of product
mpy1	comb,<		op1,gr0,mpya		; br. if multiplicand < 0
	addi		0,gr0,pu		; clear product
	addib,=		0,op1,fini0		; op1 = 0, product = 0
mpy2	addi		1,gr0,pc		; initialize pc to 00...01
	movib,tr	8,cnt,mloop		; set count for mpy loop
	extru		op2,31,4,brindex	; 4 bits as index into table 
;
d103 37
a139 37
;
	b		sh4c			; br. if sign overflow
sh4n	shd		pu,pl,4,pl		; shift product right 4 bits
	addib,<=	-1,cnt,mulend		; reduce count by 1, exit if
	extru  		pu,27,28,pu		;   <= zero
;
mloop	blr		brindex,gr0		; br. into table
						;   entries of 2 words
	extru		op2,27,4,brindex	; next 4 bits into index
;
;
;	branch table for the multiplication process with four multiplier bits
;
mtable						; two words per entry
;
; ----	bits = 0000 ---- shift product 4 bits -------------------------------
;
	b		sh4n+4			; just shift partial
	shd		pu,pl,4,pl		;   product right 4 bits
;
;  ----	bits = 0001 ---- add op1, then shift 4 bits
;
	addb,tr		op1,pu,sh4n+4		; add op1 to product, to shift
	shd		pu,pl,4,pl		;   product right 4 bits
;
;  ----	bits = 0010 ---- add op1, add op1, then shift 4 bits
;
	addb,tr		op1,pu,sh4n		; add 2*op1, to shift 
	addb,uv 	op1,pu,sh4c		;   product right 4 bits
;
;  ---- bits = 0011 ---- add op1, add 2*op1, shift 4 bits
;
	addb,tr		op1,pu,sh4n-4		; add op1 & 2*op1, shift 
	sh1add,nsv 	op1,pu,pu			;   product right 4 bits
;
;  ----	bits = 0100 ---- shift 2, add op1, shift 2
;
d141 14
a154 14
	shd		pu,pl,2,pl		; shift product 2 bits
;
;  ----	bits = 0101 ---- add op1, shift 2, add op1, and shift 2 again
;
	addb,tr		op1,pu,sh2us		; add op1 to product
	shd		pu,pl,2,pl		; shift 2 bits
;
;  ----	bits = 0110 ---- add op1, add op1, shift 2, add op1, and shift 2 again
;
	addb,tr		op1,pu,sh2c		; add 2*op1, to shift 2 bits
	addb,nuv	op1,pu,sh2us		; br. if not overflow
;
;  ----	bits = 0111 ---- subtract op1, shift 3, add op1, and shift 1
;
d156 1
a156 1
	sub		pu,op1,pu		; subtract op1, br. to sh3s
d158 3
a160 3
;
;  ----	bits = 1000 ---- shift 3, add op1, shift 1
;
d162 36
a197 36
	shd		pu,pl,3,pl		; shift product right 3 bits
;
;  ----	bits = 1001 ---- add op1, shift 3, add op1, shift 1
;
	addb,tr		op1,pu,sh3us		; add op1, to shift 3, add op1,
	shd		pu,pl,3,pl		;   and shift 1
;
;  ----	bits = 1010 ---- add op1, add op1, shift 3, add op1, shift 1
;
	addb,tr		op1,pu,sh3c		; add 2*op1, to shift 3 bits
	addb,nuv	op1,pu,sh3us		;   br. if no overflow
;
;  ----	bits = 1011 ---- add -op1, shift 2, add -op1, shift 2, inc. next index
;
	addib,tr	1,brindex,sh2s		; add 1 to index, subtract op1,
	sub		pu,op1,pu		;   shift 2 with minus sign
;
;  ----	bits = 1100 ---- shift 2, subtract op1, shift 2, increment next index
;
	addib,tr	1,brindex,sh2sb		; add 1 to index, to shift
	shd		pu,pl,2,pl		; shift right 2 bits signed
;
;  ----	bits = 1101 ---- add op1, shift 2, add -op1, shift 2
;
	addb,tr		op1,pu,sh2ns		; add op1, to shift 2
	shd		pu,pl,2,pl		;   right 2 unsigned, etc.
;
;  ----	bits = 1110 ---- shift 1 signed, add -op1, shift 3 signed
;
	addib,tr	1,brindex,sh1sa		; add 1 to index, to shift
	shd		pu,pl,1,pl		; shift 1 bit
;
;  ----	bits = 1111 ---- add -op1, shift 4 signed
;
	addib,tr	1,brindex,sh4s		; add 1 to index, subtract op1,
	sub		pu,op1,pu		;   to shift 4 signed
d199 8
a206 8
;
;  ----	bits = 10000 ---- shift 4 signed
;
	addib,tr	1,brindex,sh4s+4	; add 1 to index
	shd		pu,pl,4,pl		; shift 4 signed
;
;  ---- end of table ---------------------------------------------------------
;
d208 9
a216 9
	addib,tr	-1,cnt,mloop		; loop (count > 0 always here)
	shd		pm,pu,4,pu		; shift 4, minus signed
;
sh4c	addib,>		-1,cnt,mloop		; decrement count, loop if > 0
	shd		pc,pu,4,pu		; shift 4 with overflow
	b		signs			; end of multiply
	bb,>=,n		sign,0,fini		; test sign of procduct
;
mpyb	add,=		op2,op2,gr0		; if <> 0, back to main sect.
d218 8
a225 8
	sub		0,op2,op2		; op2 = |multiplier|
	add,>=		op1,gr0,gr0		; if op1 < 0, invert sign, 
	xor		pm,sign,sign		;   for correct result
;
;	special case for multiplier = -2**31, op1 = signed multiplicand
;		or multiplicand = -2**31, op1 = signed multiplier
;
	shd		op1,0,1,pl		; shift op1 left 31 bits
d227 4
a230 4
	b		signs			; negate product (if needed)
	bb,>=,n		sign,0,fini		; test sign of product
;
mpya	add,=		op1,op1,gr0		; op1 = -2**31, special case
d232 9
a240 9
	sub		0,op1,op1		; op1 = |multiplicand|
	add,>=		op2,gr0,gr0		; if op2 < 0, invert sign, 
	xor		pm,sign,sign		;   for correct result
	movb,tr		op2,op1,mmax		; use op2 as multiplicand
	shd		op1,0,1,pl		; shift it left 31 bits
;
sh3c	shd		pu,pl,3,pl		; shift product 3 bits
	shd		pc,pu,3,pu		; shift 3 signed
	addb,tr		op1,pu,sh1		; add op1, to shift 1 bit
d242 3
a244 3
;
sh3us	extru		pu,28,29,pu		; shift 3 unsigned
	addb,tr		op1,pu,sh1		; add op1, to shift 1 bit
d246 3
a248 3
;
sh3sa	extrs		pu,28,29,pu		; shift 3 signed
	addb,tr		op1,pu,sh1		; add op1, to shift 1 bit
d250 2
a251 2
;
sh3s	shd		pu,pl,3,pl		; shift 3 minus signed
d253 1
a253 1
	addb,tr		op1,pu,sh1		; add op1, to shift 1 bit
d255 2
a256 2
;
sh1	addib,>		-1,cnt,mloop		; loop if count > 0
d258 33
a290 33
	b		signs			; end of multiply
	bb,>=,n		sign,0,fini		; test sign of product
;
sh2ns	addib,tr	1,brindex,sh2sb+4	; increment index
	extru		pu,29,30,pu		; shift unsigned
;
sh2s	shd		pu,pl,2,pl		; shift with minus sign 
	shd		pm,pu,2,pu		; 
	sub		pu,op1,pu		; subtract op1
	shd		pu,pl,2,pl		; shift with minus sign
	addib,tr	-1,cnt,mloop		; decrement count, loop
	shd		pm,pu,2,pu		; shift with minus sign
						; count never reaches 0 here
;
sh2sb	extrs		pu,29,30,pu		; shift 2 signed
	sub		pu,op1,pu		; subtract op1 from product
	shd		pu,pl,2,pl		; shift with minus sign
	addib,tr	-1,cnt,mloop		; decrement count, loop
	shd		pm,pu,2,pu		; shift with minus sign
						; count never reaches 0 here
;
sh1sa	extrs		pu,30,31,pu		;   signed
	sub		pu,op1,pu		; subtract op1 from product
	shd		pu,pl,3,pl		; shift 3 with minus sign
	addib,tr	-1,cnt,mloop		; dec. count, to loop
	shd		pm,pu,3,pu		; count never reaches 0 here
;
fini0	movib,tr,n	0,pl,fini		; product = 0 as op1 = 0
;
sh2us	extru		pu,29,30,pu		; shift 2 unsigned
	addb,tr		op1,pu,sh2a		; add op1
	shd		pu,pl,2,pl		; shift 2 bits
;
d292 9
a300 9
	shd		pc,pu,2,pu		; shift with carry
	addb,tr		op1,pu,sh2a		; add op1 to product
	shd		pu,pl,2,pl		; br. to sh2 to shift pu
;
sh2sa	extrs		pu,29,30,pu		; shift with sign
	addb,tr		op1,pu,sh2a		; add op1 to product
	shd		pu,pl,2,pl		; br. to sh2 to shift pu
;
sh2a	addib,>		-1,cnt,mloop		; loop if count > 0
d302 9
a310 9
;
mulend	bb,>=,n		sign,0,fini		; test sign of product
signs	sub		0,pl,pl			; negate product if sign
	subb		0,pu,pu			;   is negative
;
;	finish
;
fini	stws		pu,(arg2)		; save high part of result
	stws		pl,4(arg2)		; save low part of result
d312 9
a320 9
	ldws,mb		-4(sp),pm		; restore registers
	ldws,mb		-4(sp),pc		; restore registers
	ldws,mb		-4(sp),sign		; restore registers
	ldws,mb		-4(sp),brindex		; restore registers
	ldws,mb		-4(sp),cnt		; restore registers
	ldws,mb		-4(sp),op1		; restore registers
	ldws,mb		-4(sp),pl		; restore registers
	bv		0(rp)			; return
	ldws,mb		-4(sp),pu		; restore registers
@


