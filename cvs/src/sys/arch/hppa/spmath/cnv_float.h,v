head	1.9;
access;
symbols
	OPENBSD_6_2:1.9.0.56
	OPENBSD_6_2_BASE:1.9
	OPENBSD_6_1:1.9.0.58
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.9.0.54
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.50
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.9.0.52
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.44
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.9.0.48
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.9.0.46
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.42
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.40
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.38
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.36
	OPENBSD_5_0:1.9.0.34
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.32
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.30
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.26
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.28
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.24
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.22
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.20
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.18
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.16
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.14
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.12
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.10
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.8
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.6
	OPENBSD_3_6_BASE:1.9
	SMP_SYNC_A:1.9
	SMP_SYNC_B:1.9
	OPENBSD_3_5:1.9.0.4
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	UBC_SYNC_A:1.9
	OPENBSD_3_3:1.8.0.4
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	HPUX_REL9_05_800:1.1.1.1
	HP:1.1.1
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	UBC_SYNC_B:1.8
	UBC:1.5.0.6
	UBC_BASE:1.5
	OPENBSD_3_0:1.5.0.4
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.4.0.6
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.4
	OPENBSD_2_7_BASE:1.4
	SMP:1.4.0.2
	SMP_BASE:1.4
	kame_19991208:1.3
	OPENBSD_2_6:1.3.0.6
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.4
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.2
	OPENBSD_2_4_BASE:1.3;
locks; strict;
comment	@ * @;


1.9
date	2003.04.10.17.27.58;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	2002.09.20.19.26.59;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	2002.05.07.22.19.30;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	2002.03.14.01.26.32;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.03.29.03.58.17;	author mickey;	state Exp;
branches
	1.5.6.1;
next	1.4;

1.4
date	2000.01.11.08.18.42;	author mickey;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	98.07.02.19.04.54;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	98.06.23.21.19.04;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	98.06.23.20.33.50;	author mickey;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.05.07.21.37.19;	author mickey;	state Exp;
branches;
next	;

1.4.2.1
date	2001.04.18.16.06.30;	author niklas;	state Exp;
branches;
next	1.4.2.2;

1.4.2.2
date	2002.03.28.10.31.03;	author niklas;	state Exp;
branches;
next	1.4.2.3;

1.4.2.3
date	2003.03.27.23.26.54;	author niklas;	state Exp;
branches;
next	1.4.2.4;

1.4.2.4
date	2003.05.13.19.41.04;	author ho;	state Exp;
branches;
next	;

1.5.6.1
date	2002.06.11.03.35.37;	author art;	state Exp;
branches;
next	1.5.6.2;

1.5.6.2
date	2002.10.29.00.28.03;	author art;	state Exp;
branches;
next	1.5.6.3;

1.5.6.3
date	2003.05.19.21.49.42;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.9
log
@make all entry points of the same number of arguments and that greatly simplifies the call setup in the scheduler
@
text
@/*	$OpenBSD: cnv_float.h,v 1.8 2002/09/20 19:26:59 mickey Exp $	*/
/*
  (c) Copyright 1986 HEWLETT-PACKARD COMPANY
  To anyone who acknowledges that this file is provided "AS IS"
  without any express or implied warranty:
      permission to use, copy, modify, and distribute this file
  for any purpose is hereby granted without fee, provided that
  the above copyright notice and this notice appears in all
  copies, and that the name of Hewlett-Packard Company not be
  used in advertising or publicity pertaining to distribution
  of the software without specific, written prior permission.
  Hewlett-Packard Company makes no representations about the
  suitability of this software for any purpose.
*/
/* @@(#)cnv_float.h: Revision: 2.9.88.1 Date: 93/12/07 15:05:29 */

/*
 * Some more constants
 */
#define SGL_FX_MAX_EXP 30
#define DBL_FX_MAX_EXP 62
#define QUAD_FX_MAX_EXP 126


#define Dintp1(object) (object)
#define Dintp2(object) (object)

#define Qintp0(object) (object)
#define Qintp1(object) (object)
#define Qintp2(object) (object)
#define Qintp3(object) (object)


/*
 * These macros will be used specifically by the convert instructions.
 *
 *
 * Single format macros
 */

#define Sgl_to_dbl_exponent(src_exponent,dest)			\
    Deposit_dexponent(dest,src_exponent+(DBL_BIAS-SGL_BIAS))

#define Sgl_to_dbl_mantissa(src_mantissa,destA,destB)	\
    Deposit_dmantissap1(destA,src_mantissa>>3);		\
    Dmantissap2(destB) = src_mantissa << 29

#define Sgl_isinexact_to_fix(sgl_value,exponent)	\
    ((exponent < (SGL_P - 1)) ?				\
     (Sall(sgl_value) << (SGL_EXP_LENGTH + 1 + exponent)) : FALSE)

#define Int_isinexact_to_sgl(int_value)	(int_value << (33 - SGL_EXP_LENGTH))

#define Sgl_roundnearest_from_int(int_value,sgl_value)			\
    if (int_value & 1<<(SGL_EXP_LENGTH - 2))   /* round bit */		\
	if ((int_value << (34 - SGL_EXP_LENGTH)) || Slow(sgl_value))	\
		Sall(sgl_value)++

#define Dint_isinexact_to_sgl(dint_valueA,dint_valueB)		\
    ((Dintp1(dint_valueA) << (33 - SGL_EXP_LENGTH)) || Dintp2(dint_valueB))

#define Sgl_roundnearest_from_dint(dint_valueA,dint_valueB,sgl_value)	\
    if (Dintp1(dint_valueA) & 1<<(SGL_EXP_LENGTH - 2))			\
	if ((Dintp1(dint_valueA) << (34 - SGL_EXP_LENGTH)) ||		\
	Dintp2(dint_valueB) || Slow(sgl_value)) Sall(sgl_value)++

#define Dint_isinexact_to_dbl(dint_value)	\
    (Dintp2(dint_value) << (33 - DBL_EXP_LENGTH))

#define Dbl_roundnearest_from_dint(dint_opndB,dbl_opndA,dbl_opndB)	\
    if (Dintp2(dint_opndB) & 1<<(DBL_EXP_LENGTH - 2))			\
       if ((Dintp2(dint_opndB) << (34 - DBL_EXP_LENGTH)) || Dlowp2(dbl_opndB))  \
          if ((++Dallp2(dbl_opndB))==0) Dallp1(dbl_opndA)++

#define Sgl_isone_roundbit(sgl_value,exponent)			\
    ((Sall(sgl_value) << (SGL_EXP_LENGTH + 1 + exponent)) >> 31)

#define Sgl_isone_stickybit(sgl_value,exponent)		\
    (exponent < (SGL_P - 2) ?				\
     Sall(sgl_value) << (SGL_EXP_LENGTH + 2 + exponent) : FALSE)


/*
 * Double format macros
 */

#define Dbl_to_sgl_exponent(src_exponent,dest)			\
    dest = src_exponent + (SGL_BIAS - DBL_BIAS)

#define Dbl_to_sgl_mantissa(srcA,srcB,dest,inexact,guard,sticky,odd)	\
    Shiftdouble(Dmantissap1(srcA),Dmantissap2(srcB),29,dest);	\
    guard = Dbit3p2(srcB);					\
    sticky = Dallp2(srcB)<<4;					\
    inexact = guard | sticky;					\
    odd = Dbit2p2(srcB)

#define Dbl_to_sgl_denormalized(srcA,srcB,exp,dest,inexact,guard,sticky,odd,tiny) \
    Deposit_dexponent(srcA,1);						\
    tiny = TRUE;							\
    if (exp >= -2) {							\
	if (exp == 0) {							\
	    inexact = Dallp2(srcB) << 3;				\
	    guard = inexact >> 31;					\
	    sticky = inexact << 1;					\
	    Shiftdouble(Dmantissap1(srcA),Dmantissap2(srcB),29,dest);	\
	    odd = dest << 31;						\
	    if (inexact) {						\
		switch(Rounding_mode()) {				\
		    case ROUNDPLUS:					\
			if (Dbl_iszero_sign(srcA)) {			\
			    dest++;					\
			    if (Sgl_isone_hidden(dest))	\
				tiny = FALSE;				\
			    dest--;					\
			}						\
			break;						\
		    case ROUNDMINUS:					\
			if (Dbl_isone_sign(srcA)) {			\
			    dest++;					\
			    if (Sgl_isone_hidden(dest))	\
				tiny = FALSE;				\
			    dest--;					\
			}						\
			break;						\
		    case ROUNDNEAREST:					\
			if (guard && (sticky || odd)) {			\
			    dest++;					\
			    if (Sgl_isone_hidden(dest))	\
				tiny = FALSE;				\
			    dest--;					\
			}						\
			break;						\
		}							\
	    }								\
		/* shift right by one to get correct result */		\
		guard = odd;						\
		sticky = inexact;					\
		inexact |= guard;					\
		dest >>= 1;						\
		Deposit_dsign(srcA,0);					\
	        Shiftdouble(Dallp1(srcA),Dallp2(srcB),30,dest);		\
	        odd = dest << 31;					\
	}								\
	else {								\
	    inexact = Dallp2(srcB) << (2 + exp);			\
	    guard = inexact >> 31;					\
	    sticky = inexact << 1;					\
	    Deposit_dsign(srcA,0);					\
	    if (exp == -2) dest = Dallp1(srcA);				\
	    else Variable_shift_double(Dallp1(srcA),Dallp2(srcB),30-exp,dest); \
	    odd = dest << 31;						\
	}								\
    }									\
    else {								\
	Deposit_dsign(srcA,0);						\
	if (exp > (1 - SGL_P)) {					\
	    dest = Dallp1(srcA) >> (- 2 - exp);				\
	    inexact = Dallp1(srcA) << (34 + exp);			\
	    guard = inexact >> 31;					\
	    sticky = (inexact << 1) | Dallp2(srcB);			\
	    inexact |= Dallp2(srcB);					\
	    odd = dest << 31;						\
	}								\
	else {								\
	    dest = 0;							\
	    inexact = Dallp1(srcA) | Dallp2(srcB);			\
	    if (exp == (1 - SGL_P)) {					\
		guard = Dhidden(srcA);					\
		sticky = Dmantissap1(srcA) | Dallp2(srcB);		\
	    }								\
	    else {							\
		guard = 0;						\
		sticky = inexact;					\
	    }								\
	    odd = 0;							\
	}								\
    }									\
    exp = 0

#define Dbl_isinexact_to_fix(dbl_valueA,dbl_valueB,exponent)		\
    (exponent < (DBL_P-33) ?						\
     Dallp2(dbl_valueB) || Dallp1(dbl_valueA) << (DBL_EXP_LENGTH+1+exponent) : \
     (exponent < (DBL_P-1) ? Dallp2(dbl_valueB) << (exponent + (33-DBL_P)) :   \
      FALSE))

#define Dbl_isoverflow_to_int(exponent,dbl_valueA,dbl_valueB)		\
    ((exponent > SGL_FX_MAX_EXP + 1) || Dsign(dbl_valueA)==0 ||		\
     Dmantissap1(dbl_valueA)!=0 || (Dallp2(dbl_valueB)>>21)!=0 )

#define Dbl_isone_roundbit(dbl_valueA,dbl_valueB,exponent)              \
    ((exponent < (DBL_P - 33) ?						\
      Dallp1(dbl_valueA) >> ((30 - DBL_EXP_LENGTH) - exponent) :	\
      Dallp2(dbl_valueB) >> ((DBL_P - 2) - exponent)) & 1)

#define Dbl_isone_stickybit(dbl_valueA,dbl_valueB,exponent)		\
    (exponent < (DBL_P-34) ?						\
     (Dallp2(dbl_valueB) || Dallp1(dbl_valueA)<<(DBL_EXP_LENGTH+2+exponent)) : \
     (exponent<(DBL_P-2) ? (Dallp2(dbl_valueB) << (exponent + (34-DBL_P))) : \
      FALSE))


/* Int macros */

#define Int_from_sgl_mantissa(sgl_value,exponent)	\
    Sall(sgl_value) =				\
	(unsigned)(Sall(sgl_value) << SGL_EXP_LENGTH)>>(31 - exponent)

#define Int_from_dbl_mantissa(dbl_valueA,dbl_valueB,exponent)	\
    Shiftdouble(Dallp1(dbl_valueA),Dallp2(dbl_valueB),22,Dallp1(dbl_valueA)); \
    if (exponent < 31) Dallp1(dbl_valueA) >>= 30 - exponent;	\
    else Dallp1(dbl_valueA) <<= 1

#define Int_negate(int_value) int_value = -int_value


/* Dint macros */

#define Dint_from_sgl_mantissa(sgl_value,exponent,dresultA,dresultB)	\
    {Sall(sgl_value) <<= SGL_EXP_LENGTH;  /*  left-justify  */		\
    if (exponent <= 31) {						\
	Dintp1(dresultA) = 0;						\
	Dintp2(dresultB) = (unsigned)Sall(sgl_value) >> (31 - exponent); \
    }									\
    else {								\
	Dintp1(dresultA) = Sall(sgl_value) >> (63 - exponent);		\
	Dintp2(dresultB) = Sall(sgl_value) << (exponent - 31);		\
    }}


#define Dint_from_dbl_mantissa(dbl_valueA,dbl_valueB,exponent,destA,destB) \
    {if (exponent < 32) {						\
	Dintp1(destA) = 0;						\
	if (exponent <= 20)						\
	    Dintp2(destB) = Dallp1(dbl_valueA) >> (20-exponent);	\
	else Variable_shift_double(Dallp1(dbl_valueA),Dallp2(dbl_valueB), \
	     52-exponent,Dintp2(destB));					\
    }									\
    else {								\
	if (exponent <= 52) {						\
	    Dintp1(destA) = Dallp1(dbl_valueA) >> (52-exponent);	\
	    if (exponent == 52) Dintp2(destB) = Dallp2(dbl_valueB);	\
	    else Variable_shift_double(Dallp1(dbl_valueA),Dallp2(dbl_valueB), \
	    52-exponent,Dintp2(destB));					\
        }								\
	else {								\
	    Variable_shift_double(Dallp1(dbl_valueA),Dallp2(dbl_valueB), \
	    84-exponent,Dintp1(destA));					\
	    Dintp2(destB) = Dallp2(dbl_valueB) << (exponent-52);	\
	}								\
    }}

#define Dint_setzero(dresultA,dresultB)		\
    Dintp1(dresultA) = 0;			\
    Dintp2(dresultB) = 0

#define Dint_setone_sign(dresultA,dresultB)		\
    Dintp1(dresultA) = ~Dintp1(dresultA);		\
    if ((Dintp2(dresultB) = -Dintp2(dresultB)) == 0) Dintp1(dresultA)++

#define Dint_set_minint(dresultA,dresultB)		\
    Dintp1(dresultA) = 1<<31;				\
    Dintp2(dresultB) = 0

#define Dint_isone_lowp2(dresultB)  (Dintp2(dresultB) & 01)

#define Dint_increment(dresultA,dresultB)		\
    if ((++Dintp2(dresultB))==0) Dintp1(dresultA)++

#define Dint_decrement(dresultA,dresultB)		\
    if ((Dintp2(dresultB)--)==0) Dintp1(dresultA)--

#define Dint_negate(dresultA,dresultB)			\
    Dintp1(dresultA) = ~Dintp1(dresultA);		\
    if ((Dintp2(dresultB) = -Dintp2(dresultB))==0) Dintp1(dresultA)++

#define Dint_copyfromptr(src,destA,destB) \
     Dintp1(destA) = src->wd0;		\
     Dintp2(destB) = src->wd1
#define Dint_copytoptr(srcA,srcB,dest)	\
    dest->wd0 = Dintp1(srcA);		\
    dest->wd1 = Dintp2(srcB)


/* other macros  */

#define Find_ms_one_bit(value, position)	\
    {						\
	int var;				\
	for (var = 8; var >= 1; var >>= 1) {	\
	    if (value >> (32 - position))	\
		position -= var;		\
		else position += var;		\
	}					\
	if ((value >> (32 - position)) == 0)	\
	    position--;				\
	else position -= 2;			\
    }

int sgl_to_sgl_fcnvfx(sgl_floating_point *, sgl_floating_point *, sgl_floating_point *, unsigned int *);
int sgl_to_dbl_fcnvfx(sgl_floating_point *, sgl_floating_point *, dbl_integer *, unsigned int *);
int dbl_to_sgl_fcnvfx(dbl_floating_point *, dbl_floating_point *, int *, unsigned int *);
int dbl_to_dbl_fcnvfx(dbl_floating_point *, dbl_floating_point *, dbl_integer *, unsigned int *);

int sgl_to_sgl_fcnvfxt(sgl_floating_point *, sgl_floating_point *, int *, unsigned int *);
int sgl_to_dbl_fcnvfxt(sgl_floating_point *, sgl_floating_point *, dbl_integer *, unsigned int *);
int dbl_to_sgl_fcnvfxt(dbl_floating_point *, dbl_floating_point *, int *, unsigned int *);
int dbl_to_dbl_fcnvfxt(dbl_floating_point *, dbl_floating_point *, dbl_integer *, unsigned int *);

int sgl_to_sgl_fcnvxf(int *, int *, sgl_floating_point *, unsigned int *);
int sgl_to_dbl_fcnvxf(int *, int *, dbl_floating_point *, unsigned int *);
int dbl_to_sgl_fcnvxf(dbl_integer *, dbl_integer *, sgl_floating_point *, unsigned int *);
int dbl_to_dbl_fcnvxf(dbl_integer *, dbl_integer *, dbl_floating_point *, unsigned int *);
@


1.8
log
@kill dangling space, line and a space in the tab
@
text
@d1 1
a1 1
/*	$OpenBSD: cnv_float.h,v 1.7 2002/05/07 22:19:30 mickey Exp $	*/
d299 14
a312 14
int sgl_to_sgl_fcnvfx(sgl_floating_point *, sgl_floating_point *, unsigned int *);
int sgl_to_dbl_fcnvfx(sgl_floating_point *, dbl_integer *, unsigned int *);
int dbl_to_sgl_fcnvfx(dbl_floating_point *, int *, unsigned int *);
int dbl_to_dbl_fcnvfx(dbl_floating_point *, dbl_integer *, unsigned int *);

int sgl_to_sgl_fcnvfxt(sgl_floating_point *, int *, unsigned int *);
int sgl_to_dbl_fcnvfxt(sgl_floating_point *, dbl_integer *, unsigned int *);
int dbl_to_sgl_fcnvfxt(dbl_floating_point *, int *, unsigned int *);
int dbl_to_dbl_fcnvfxt(dbl_floating_point *, dbl_integer *, unsigned int *);

int sgl_to_sgl_fcnvxf(int *, sgl_floating_point *, unsigned int *);
int sgl_to_dbl_fcnvxf(int *, dbl_floating_point *, unsigned int *);
int dbl_to_sgl_fcnvxf(dbl_integer *, sgl_floating_point *, unsigned int *);
int dbl_to_dbl_fcnvxf(dbl_integer *, dbl_floating_point *, unsigned int *);
@


1.7
log
@bring over our mods; the cnv*c have a problem now, described in the osf version of the cnv_float.h, at the end
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a312 1

@


1.6
log
@First round of __P removal in sys
@
text
@d1 1
a1 25
/*	$OpenBSD: cnv_float.h,v 1.5 2001/03/29 03:58:17 mickey Exp $	*/

/*
 * Copyright 1996 1995 by Open Software Foundation, Inc.
 *              All Rights Reserved
 *
 * Permission to use, copy, modify, and distribute this software and
 * its documentation for any purpose and without fee is hereby granted,
 * provided that the above copyright notice appears in all copies and
 * that both the copyright notice and this permission notice appear in
 * supporting documentation.
 *
 * OSF DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE.
 *
 * IN NO EVENT SHALL OSF BE LIABLE FOR ANY SPECIAL, INDIRECT, OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN ACTION OF CONTRACT,
 * NEGLIGENCE, OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
 * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
/*
 * pmk1.1
 */
d3 13
a15 13
 * (c) Copyright 1986 HEWLETT-PACKARD COMPANY
 *
 * To anyone who acknowledges that this file is provided "AS IS"
 * without any express or implied warranty:
 *     permission to use, copy, modify, and distribute this file
 * for any purpose is hereby granted without fee, provided that
 * the above copyright notice and this notice appears in all
 * copies, and that the name of Hewlett-Packard Company not be
 * used in advertising or publicity pertaining to distribution
 * of the software without specific, written prior permission.
 * Hewlett-Packard Company makes no representations about the
 * suitability of this software for any purpose.
 */
d72 2
a73 2
       if ((Dintp2(dint_opndB) << (34 -DBL_EXP_LENGTH)) || Dlowp2(dbl_opndB))  \
	  if ((++Dallp2(dbl_opndB))==0) Dallp1(dbl_opndA)++
d141 2
a142 2
		Shiftdouble(Dallp1(srcA),Dallp2(srcB),30,dest);		\
		odd = dest << 31;					\
d190 1
a190 1
#define Dbl_isone_roundbit(dbl_valueA,dbl_valueB,exponent)	      \
d234 1
a234 1
	    Dintp2(destB) = Dallp1(dbl_valueA) >> (20-(exponent));	\
d236 1
a236 1
	     (52-(exponent)),Dintp2(destB));				\
d240 1
a240 1
	    Dintp1(destA) = Dallp1(dbl_valueA) >> (52-(exponent));	\
d244 1
a244 1
	}								\
d248 1
a248 1
	    Dintp2(destB) = Dallp2(dbl_valueB) << ((exponent)-52);	\
d252 2
a253 2
#define Dint_setzero(dresultA,dresultB)	\
    Dintp1(dresultA) = 0;	\
d289 1
a289 1
	for (var=8; var >=1; var >>= 1) {	\
a298 94
/*
 * The following 4 functions handle the assignment of a floating point
 * number to a 32-bit integer in cases where the floating point number
 * is too large (or small) to fit in the integer field.
 *
 * In all these cases, HP-UX would return an UNIMPLEMENTEDEXCEPTION
 * resulting in a SIGFPE being sent to the process.  For BSD's math
 * library (and various other applications), this was unacceptable.
 * As a result, we now return maxint/minint (like most other OS's)
 * and either return an INEXACTEXCEPTION (SIGFPE) or set the inexact
 * flag (so that the program may continue execution).
 *
 * After discussing this with Jerry Huck @@ HP, the one case where we
 * differ from BSD is for programs that try to convert a NaN to an
 * integer; in this case, we will return an UNIMPLEMENTEDEXCEPTION
 * since doing anything else would be completely unreasonable.
 *
 *	jef
 */

#define	Dbl_return_overflow(srcp1, srcp2, resultp)	\
    {						\
	if (Dbl_isnan(srcp1, srcp2))		\
		return(UNIMPLEMENTEDEXCEPTION);	\
	if (Dbl_iszero_sign(srcp1))		\
		*resultp = 0x7fffffff;		\
	else					\
		*resultp = 0x80000000;		\
	if (Is_overflowtrap_enabled()) {	\
		if (Is_inexacttrap_enabled())	\
			return(OVERFLOWEXCEPTION|INEXACTEXCEPTION);	\
		else				\
			Set_inexactflag();	\
		return(OVERFLOWEXCEPTION);	\
	}					\
	return(NOEXCEPTION);			\
    }

#define	Dbl_return_overflow_dbl(srcp1, srcp2, resultp)	\
    {						\
	if (Dbl_isnan(srcp1, srcp2))		\
		return(UNIMPLEMENTEDEXCEPTION);	\
	if (Dbl_iszero_sign(srcp1)) {		\
		Dint_copytoptr(0x7fffffff,0xffffffff,resultp); \
	} else {				\
		Dint_copytoptr(0x80000000,0x00000000,resultp); \
	}					\
	if (Is_overflowtrap_enabled()) {	\
		if (Is_inexacttrap_enabled())	\
			return(OVERFLOWEXCEPTION|INEXACTEXCEPTION);	\
		else				\
			Set_inexactflag();	\
		return(OVERFLOWEXCEPTION);	\
	}					\
	return(NOEXCEPTION);			\
    }

#define	Sgl_return_overflow(src, resultp)	\
    {						\
	if (Sgl_isnan(src))			\
		return(UNIMPLEMENTEDEXCEPTION);	\
	if (Sgl_iszero_sign(src))		\
		*resultp = 0x7fffffff;		\
	else					\
		*resultp = 0x80000000;		\
	if (Is_overflowtrap_enabled()) {	\
		if (Is_inexacttrap_enabled())	\
			return(OVERFLOWEXCEPTION|INEXACTEXCEPTION);	\
		else				\
			Set_inexactflag();	\
		return(OVERFLOWEXCEPTION);	\
	}					\
	return(NOEXCEPTION);			\
    }

#define	Sgl_return_overflow_dbl(src, resultp)	\
    {						\
	if (Sgl_isnan(src))			\
		return(UNIMPLEMENTEDEXCEPTION);	\
	if (Sgl_iszero_sign(src)) {		\
		Dint_copytoptr(0x7fffffff,0xffffffff,resultp); \
	} else {				\
		Dint_copytoptr(0x80000000,0x00000000,resultp); \
	}					\
	if (Is_overflowtrap_enabled()) {	\
		if (Is_inexacttrap_enabled())	\
			return(OVERFLOWEXCEPTION|INEXACTEXCEPTION);	\
		else				\
			Set_inexactflag();	\
		return(OVERFLOWEXCEPTION);	\
	}					\
	return(NOEXCEPTION);			\
    }

a312 2


@


1.5
log
@big bang
@
text
@d1 1
a1 1
/*	$OpenBSD: cnv_float.h,v 1.4 2000/01/11 08:18:42 mickey Exp $	*/
d417 14
a430 14
int sgl_to_sgl_fcnvfx __P((sgl_floating_point *, sgl_floating_point *, unsigned int *));
int sgl_to_dbl_fcnvfx __P((sgl_floating_point *, dbl_integer *, unsigned int *));
int dbl_to_sgl_fcnvfx __P((dbl_floating_point *, int *, unsigned int *));
int dbl_to_dbl_fcnvfx __P((dbl_floating_point *, dbl_integer *, unsigned int *));

int sgl_to_sgl_fcnvfxt __P((sgl_floating_point *, int *, unsigned int *));
int sgl_to_dbl_fcnvfxt __P((sgl_floating_point *, dbl_integer *, unsigned int *));
int dbl_to_sgl_fcnvfxt __P((dbl_floating_point *, int *, unsigned int *));
int dbl_to_dbl_fcnvfxt __P((dbl_floating_point *, dbl_integer *, unsigned int *));

int sgl_to_sgl_fcnvxf __P((int *, sgl_floating_point *, unsigned int *));
int sgl_to_dbl_fcnvxf __P((int *, dbl_floating_point *, unsigned int *));
int dbl_to_sgl_fcnvxf __P((dbl_integer *, sgl_floating_point *, unsigned int *));
int dbl_to_dbl_fcnvxf __P((dbl_integer *, dbl_floating_point *, unsigned int *));
@


1.5.6.1
log
@Sync UBC branch to -current
@
text
@d1 25
a25 1
/*	$OpenBSD$	*/
d27 13
a39 13
  (c) Copyright 1986 HEWLETT-PACKARD COMPANY
  To anyone who acknowledges that this file is provided "AS IS"
  without any express or implied warranty:
      permission to use, copy, modify, and distribute this file
  for any purpose is hereby granted without fee, provided that
  the above copyright notice and this notice appears in all
  copies, and that the name of Hewlett-Packard Company not be
  used in advertising or publicity pertaining to distribution
  of the software without specific, written prior permission.
  Hewlett-Packard Company makes no representations about the
  suitability of this software for any purpose.
*/
/* @@(#)cnv_float.h: Revision: 2.9.88.1 Date: 93/12/07 15:05:29 */
d96 2
a97 2
       if ((Dintp2(dint_opndB) << (34 - DBL_EXP_LENGTH)) || Dlowp2(dbl_opndB))  \
          if ((++Dallp2(dbl_opndB))==0) Dallp1(dbl_opndA)++
d165 2
a166 2
	        Shiftdouble(Dallp1(srcA),Dallp2(srcB),30,dest);		\
	        odd = dest << 31;					\
d214 1
a214 1
#define Dbl_isone_roundbit(dbl_valueA,dbl_valueB,exponent)              \
d258 1
a258 1
	    Dintp2(destB) = Dallp1(dbl_valueA) >> (20-exponent);	\
d260 1
a260 1
	     52-exponent,Dintp2(destB));					\
d264 1
a264 1
	    Dintp1(destA) = Dallp1(dbl_valueA) >> (52-exponent);	\
d268 1
a268 1
        }								\
d272 1
a272 1
	    Dintp2(destB) = Dallp2(dbl_valueB) << (exponent-52);	\
d276 2
a277 2
#define Dint_setzero(dresultA,dresultB)		\
    Dintp1(dresultA) = 0;			\
d313 1
a313 1
	for (var = 8; var >= 1; var >>= 1) {	\
d323 110
a432 14
int sgl_to_sgl_fcnvfx(sgl_floating_point *, sgl_floating_point *, unsigned int *);
int sgl_to_dbl_fcnvfx(sgl_floating_point *, dbl_integer *, unsigned int *);
int dbl_to_sgl_fcnvfx(dbl_floating_point *, int *, unsigned int *);
int dbl_to_dbl_fcnvfx(dbl_floating_point *, dbl_integer *, unsigned int *);

int sgl_to_sgl_fcnvfxt(sgl_floating_point *, int *, unsigned int *);
int sgl_to_dbl_fcnvfxt(sgl_floating_point *, dbl_integer *, unsigned int *);
int dbl_to_sgl_fcnvfxt(dbl_floating_point *, int *, unsigned int *);
int dbl_to_dbl_fcnvfxt(dbl_floating_point *, dbl_integer *, unsigned int *);

int sgl_to_sgl_fcnvxf(int *, sgl_floating_point *, unsigned int *);
int sgl_to_dbl_fcnvxf(int *, dbl_floating_point *, unsigned int *);
int dbl_to_sgl_fcnvxf(dbl_integer *, sgl_floating_point *, unsigned int *);
int dbl_to_dbl_fcnvxf(dbl_integer *, dbl_floating_point *, unsigned int *);
@


1.5.6.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cnv_float.h,v 1.5.6.1 2002/06/11 03:35:37 art Exp $	*/
d313 1
@


1.5.6.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d299 14
a312 14
int sgl_to_sgl_fcnvfx(sgl_floating_point *, sgl_floating_point *, sgl_floating_point *, unsigned int *);
int sgl_to_dbl_fcnvfx(sgl_floating_point *, sgl_floating_point *, dbl_integer *, unsigned int *);
int dbl_to_sgl_fcnvfx(dbl_floating_point *, dbl_floating_point *, int *, unsigned int *);
int dbl_to_dbl_fcnvfx(dbl_floating_point *, dbl_floating_point *, dbl_integer *, unsigned int *);

int sgl_to_sgl_fcnvfxt(sgl_floating_point *, sgl_floating_point *, int *, unsigned int *);
int sgl_to_dbl_fcnvfxt(sgl_floating_point *, sgl_floating_point *, dbl_integer *, unsigned int *);
int dbl_to_sgl_fcnvfxt(dbl_floating_point *, dbl_floating_point *, int *, unsigned int *);
int dbl_to_dbl_fcnvfxt(dbl_floating_point *, dbl_floating_point *, dbl_integer *, unsigned int *);

int sgl_to_sgl_fcnvxf(int *, int *, sgl_floating_point *, unsigned int *);
int sgl_to_dbl_fcnvxf(int *, int *, dbl_floating_point *, unsigned int *);
int dbl_to_sgl_fcnvxf(dbl_integer *, dbl_integer *, sgl_floating_point *, unsigned int *);
int dbl_to_dbl_fcnvxf(dbl_integer *, dbl_integer *, dbl_floating_point *, unsigned int *);
@


1.4
log
@remove unused nullptr arg, effectively unifying calling conventions for emulator routines
@
text
@d1 1
a1 1
/*	$OpenBSD: cnv_float.h,v 1.3 1998/07/02 19:04:54 mickey Exp $	*/
d4 18
a21 18
 * Copyright 1996 1995 by Open Software Foundation, Inc.   
 *              All Rights Reserved 
 *  
 * Permission to use, copy, modify, and distribute this software and 
 * its documentation for any purpose and without fee is hereby granted, 
 * provided that the above copyright notice appears in all copies and 
 * that both the copyright notice and this permission notice appear in 
 * supporting documentation. 
 *  
 * OSF DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE 
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS 
 * FOR A PARTICULAR PURPOSE. 
 *  
 * IN NO EVENT SHALL OSF BE LIABLE FOR ANY SPECIAL, INDIRECT, OR 
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM 
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN ACTION OF CONTRACT, 
 * NEGLIGENCE, OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION 
 * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. 
d29 1
a29 1
 * To anyone who acknowledges that this file is provided "AS IS" 
d31 7
a37 7
 *     permission to use, copy, modify, and distribute this file 
 * for any purpose is hereby granted without fee, provided that 
 * the above copyright notice and this notice appears in all 
 * copies, and that the name of Hewlett-Packard Company not be 
 * used in advertising or publicity pertaining to distribution 
 * of the software without specific, written prior permission.  
 * Hewlett-Packard Company makes no representations about the 
d80 1
a80 1
    	if ((int_value << (34 - SGL_EXP_LENGTH)) || Slow(sgl_value))	\
d87 3
a89 3
    if (Dintp1(dint_valueA) & 1<<(SGL_EXP_LENGTH - 2)) 			\
    	if ((Dintp1(dint_valueA) << (34 - SGL_EXP_LENGTH)) ||		\
    	Dintp2(dint_valueB) || Slow(sgl_value)) Sall(sgl_value)++
d91 1
a91 1
#define Dint_isinexact_to_dbl(dint_value) 	\
d94 1
a94 1
#define Dbl_roundnearest_from_dint(dint_opndB,dbl_opndA,dbl_opndB) 	\
d97 1
a97 1
          if ((++Dallp2(dbl_opndB))==0) Dallp1(dbl_opndA)++
d107 1
a107 1
/* 
d115 1
a115 1
    Shiftdouble(Dmantissap1(srcA),Dmantissap2(srcB),29,dest); 	\
d164 3
a166 3
    		Deposit_dsign(srcA,0);					\
    	        Shiftdouble(Dallp1(srcA),Dallp2(srcB),30,dest);		\
	        odd = dest << 31;					\
d169 7
a175 7
    	    inexact = Dallp2(srcB) << (2 + exp);			\
    	    guard = inexact >> 31;					\
    	    sticky = inexact << 1; 					\
    	    Deposit_dsign(srcA,0);					\
    	    if (exp == -2) dest = Dallp1(srcA);				\
    	    else Variable_shift_double(Dallp1(srcA),Dallp2(srcB),30-exp,dest); \
    	    odd = dest << 31;						\
d179 22
a200 22
    	Deposit_dsign(srcA,0);						\
    	if (exp > (1 - SGL_P)) {					\
    	    dest = Dallp1(srcA) >> (- 2 - exp);				\
    	    inexact = Dallp1(srcA) << (34 + exp);			\
    	    guard = inexact >> 31;					\
    	    sticky = (inexact << 1) | Dallp2(srcB);			\
    	    inexact |= Dallp2(srcB); 					\
    	    odd = dest << 31;						\
    	}								\
    	else {								\
    	    dest = 0;							\
    	    inexact = Dallp1(srcA) | Dallp2(srcB);			\
    	    if (exp == (1 - SGL_P)) {					\
    	    	guard = Dhidden(srcA);					\
    	    	sticky = Dmantissap1(srcA) | Dallp2(srcB); 		\
    	    }								\
    	    else {							\
    	    	guard = 0;						\
    	    	sticky = inexact;					\
    	    }								\
    	    odd = 0;							\
    	}								\
d205 1
a205 1
    (exponent < (DBL_P-33) ? 						\
d212 1
a212 1
     Dmantissap1(dbl_valueA)!=0 || (Dallp2(dbl_valueB)>>21)!=0 ) 
d214 1
a214 1
#define Dbl_isone_roundbit(dbl_valueA,dbl_valueB,exponent)              \
d220 1
a220 1
    (exponent < (DBL_P-34) ? 						\
d229 2
a230 2
    Sall(sgl_value) = 				\
    	(unsigned)(Sall(sgl_value) << SGL_EXP_LENGTH)>>(31 - exponent)
d245 2
a246 2
    	Dintp1(dresultA) = 0;						\
    	Dintp2(dresultB) = (unsigned)Sall(sgl_value) >> (31 - exponent); \
d249 2
a250 2
    	Dintp1(dresultA) = Sall(sgl_value) >> (63 - exponent);		\
    	Dintp2(dresultB) = Sall(sgl_value) << (exponent - 31);		\
d256 4
a259 4
    	Dintp1(destA) = 0;						\
    	if (exponent <= 20)						\
    	    Dintp2(destB) = Dallp1(dbl_valueA) >> (20-(exponent));	\
    	else Variable_shift_double(Dallp1(dbl_valueA),Dallp2(dbl_valueB), \
d263 2
a264 2
    	if (exponent <= 52) {						\
    	    Dintp1(destA) = Dallp1(dbl_valueA) >> (52-(exponent));	\
d268 3
a270 3
        }								\
    	else {								\
    	    Variable_shift_double(Dallp1(dbl_valueA),Dallp2(dbl_valueB), \
d272 2
a273 2
    	    Dintp2(destB) = Dallp2(dbl_valueB) << ((exponent)-52);	\
    	}								\
d276 2
a277 2
#define Dint_setzero(dresultA,dresultB) 	\
    Dintp1(dresultA) = 0; 	\
d290 1
a290 1
#define Dint_increment(dresultA,dresultB) 		\
d293 1
a293 1
#define Dint_decrement(dresultA,dresultB) 		\
@


1.4.2.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: cnv_float.h,v 1.5 2001/03/29 03:58:17 mickey Exp $	*/
d4 18
a21 18
 * Copyright 1996 1995 by Open Software Foundation, Inc.
 *              All Rights Reserved
 *
 * Permission to use, copy, modify, and distribute this software and
 * its documentation for any purpose and without fee is hereby granted,
 * provided that the above copyright notice appears in all copies and
 * that both the copyright notice and this permission notice appear in
 * supporting documentation.
 *
 * OSF DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE.
 *
 * IN NO EVENT SHALL OSF BE LIABLE FOR ANY SPECIAL, INDIRECT, OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN ACTION OF CONTRACT,
 * NEGLIGENCE, OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
 * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
d29 1
a29 1
 * To anyone who acknowledges that this file is provided "AS IS"
d31 7
a37 7
 *     permission to use, copy, modify, and distribute this file
 * for any purpose is hereby granted without fee, provided that
 * the above copyright notice and this notice appears in all
 * copies, and that the name of Hewlett-Packard Company not be
 * used in advertising or publicity pertaining to distribution
 * of the software without specific, written prior permission.
 * Hewlett-Packard Company makes no representations about the
d80 1
a80 1
	if ((int_value << (34 - SGL_EXP_LENGTH)) || Slow(sgl_value))	\
d87 3
a89 3
    if (Dintp1(dint_valueA) & 1<<(SGL_EXP_LENGTH - 2))			\
	if ((Dintp1(dint_valueA) << (34 - SGL_EXP_LENGTH)) ||		\
	Dintp2(dint_valueB) || Slow(sgl_value)) Sall(sgl_value)++
d91 1
a91 1
#define Dint_isinexact_to_dbl(dint_value)	\
d94 1
a94 1
#define Dbl_roundnearest_from_dint(dint_opndB,dbl_opndA,dbl_opndB)	\
d97 1
a97 1
	  if ((++Dallp2(dbl_opndB))==0) Dallp1(dbl_opndA)++
d107 1
a107 1
/*
d115 1
a115 1
    Shiftdouble(Dmantissap1(srcA),Dmantissap2(srcB),29,dest);	\
d164 3
a166 3
		Deposit_dsign(srcA,0);					\
		Shiftdouble(Dallp1(srcA),Dallp2(srcB),30,dest);		\
		odd = dest << 31;					\
d169 7
a175 7
	    inexact = Dallp2(srcB) << (2 + exp);			\
	    guard = inexact >> 31;					\
	    sticky = inexact << 1;					\
	    Deposit_dsign(srcA,0);					\
	    if (exp == -2) dest = Dallp1(srcA);				\
	    else Variable_shift_double(Dallp1(srcA),Dallp2(srcB),30-exp,dest); \
	    odd = dest << 31;						\
d179 22
a200 22
	Deposit_dsign(srcA,0);						\
	if (exp > (1 - SGL_P)) {					\
	    dest = Dallp1(srcA) >> (- 2 - exp);				\
	    inexact = Dallp1(srcA) << (34 + exp);			\
	    guard = inexact >> 31;					\
	    sticky = (inexact << 1) | Dallp2(srcB);			\
	    inexact |= Dallp2(srcB);					\
	    odd = dest << 31;						\
	}								\
	else {								\
	    dest = 0;							\
	    inexact = Dallp1(srcA) | Dallp2(srcB);			\
	    if (exp == (1 - SGL_P)) {					\
		guard = Dhidden(srcA);					\
		sticky = Dmantissap1(srcA) | Dallp2(srcB);		\
	    }								\
	    else {							\
		guard = 0;						\
		sticky = inexact;					\
	    }								\
	    odd = 0;							\
	}								\
d205 1
a205 1
    (exponent < (DBL_P-33) ?						\
d212 1
a212 1
     Dmantissap1(dbl_valueA)!=0 || (Dallp2(dbl_valueB)>>21)!=0 )
d214 1
a214 1
#define Dbl_isone_roundbit(dbl_valueA,dbl_valueB,exponent)	      \
d220 1
a220 1
    (exponent < (DBL_P-34) ?						\
d229 2
a230 2
    Sall(sgl_value) =				\
	(unsigned)(Sall(sgl_value) << SGL_EXP_LENGTH)>>(31 - exponent)
d245 2
a246 2
	Dintp1(dresultA) = 0;						\
	Dintp2(dresultB) = (unsigned)Sall(sgl_value) >> (31 - exponent); \
d249 2
a250 2
	Dintp1(dresultA) = Sall(sgl_value) >> (63 - exponent);		\
	Dintp2(dresultB) = Sall(sgl_value) << (exponent - 31);		\
d256 4
a259 4
	Dintp1(destA) = 0;						\
	if (exponent <= 20)						\
	    Dintp2(destB) = Dallp1(dbl_valueA) >> (20-(exponent));	\
	else Variable_shift_double(Dallp1(dbl_valueA),Dallp2(dbl_valueB), \
d263 2
a264 2
	if (exponent <= 52) {						\
	    Dintp1(destA) = Dallp1(dbl_valueA) >> (52-(exponent));	\
d268 3
a270 3
	}								\
	else {								\
	    Variable_shift_double(Dallp1(dbl_valueA),Dallp2(dbl_valueB), \
d272 2
a273 2
	    Dintp2(destB) = Dallp2(dbl_valueB) << ((exponent)-52);	\
	}								\
d276 2
a277 2
#define Dint_setzero(dresultA,dresultB)	\
    Dintp1(dresultA) = 0;	\
d290 1
a290 1
#define Dint_increment(dresultA,dresultB)		\
d293 1
a293 1
#define Dint_decrement(dresultA,dresultB)		\
@


1.4.2.2
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d417 14
a430 14
int sgl_to_sgl_fcnvfx(sgl_floating_point *, sgl_floating_point *, unsigned int *);
int sgl_to_dbl_fcnvfx(sgl_floating_point *, dbl_integer *, unsigned int *);
int dbl_to_sgl_fcnvfx(dbl_floating_point *, int *, unsigned int *);
int dbl_to_dbl_fcnvfx(dbl_floating_point *, dbl_integer *, unsigned int *);

int sgl_to_sgl_fcnvfxt(sgl_floating_point *, int *, unsigned int *);
int sgl_to_dbl_fcnvfxt(sgl_floating_point *, dbl_integer *, unsigned int *);
int dbl_to_sgl_fcnvfxt(dbl_floating_point *, int *, unsigned int *);
int dbl_to_dbl_fcnvfxt(dbl_floating_point *, dbl_integer *, unsigned int *);

int sgl_to_sgl_fcnvxf(int *, sgl_floating_point *, unsigned int *);
int sgl_to_dbl_fcnvxf(int *, dbl_floating_point *, unsigned int *);
int dbl_to_sgl_fcnvxf(dbl_integer *, sgl_floating_point *, unsigned int *);
int dbl_to_dbl_fcnvxf(dbl_integer *, dbl_floating_point *, unsigned int *);
@


1.4.2.3
log
@Sync the SMP branch with 3.3
@
text
@d2 24
d27 13
a39 13
  (c) Copyright 1986 HEWLETT-PACKARD COMPANY
  To anyone who acknowledges that this file is provided "AS IS"
  without any express or implied warranty:
      permission to use, copy, modify, and distribute this file
  for any purpose is hereby granted without fee, provided that
  the above copyright notice and this notice appears in all
  copies, and that the name of Hewlett-Packard Company not be
  used in advertising or publicity pertaining to distribution
  of the software without specific, written prior permission.
  Hewlett-Packard Company makes no representations about the
  suitability of this software for any purpose.
*/
/* @@(#)cnv_float.h: Revision: 2.9.88.1 Date: 93/12/07 15:05:29 */
d96 2
a97 2
       if ((Dintp2(dint_opndB) << (34 - DBL_EXP_LENGTH)) || Dlowp2(dbl_opndB))  \
          if ((++Dallp2(dbl_opndB))==0) Dallp1(dbl_opndA)++
d165 2
a166 2
	        Shiftdouble(Dallp1(srcA),Dallp2(srcB),30,dest);		\
	        odd = dest << 31;					\
d214 1
a214 1
#define Dbl_isone_roundbit(dbl_valueA,dbl_valueB,exponent)              \
d258 1
a258 1
	    Dintp2(destB) = Dallp1(dbl_valueA) >> (20-exponent);	\
d260 1
a260 1
	     52-exponent,Dintp2(destB));					\
d264 1
a264 1
	    Dintp1(destA) = Dallp1(dbl_valueA) >> (52-exponent);	\
d268 1
a268 1
        }								\
d272 1
a272 1
	    Dintp2(destB) = Dallp2(dbl_valueB) << (exponent-52);	\
d276 2
a277 2
#define Dint_setzero(dresultA,dresultB)		\
    Dintp1(dresultA) = 0;			\
d313 1
a313 1
	for (var = 8; var >= 1; var >>= 1) {	\
d323 94
d431 3
@


1.4.2.4
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: cnv_float.h,v 1.4.2.3 2003/03/27 23:26:54 niklas Exp $	*/
d299 14
a312 14
int sgl_to_sgl_fcnvfx(sgl_floating_point *, sgl_floating_point *, sgl_floating_point *, unsigned int *);
int sgl_to_dbl_fcnvfx(sgl_floating_point *, sgl_floating_point *, dbl_integer *, unsigned int *);
int dbl_to_sgl_fcnvfx(dbl_floating_point *, dbl_floating_point *, int *, unsigned int *);
int dbl_to_dbl_fcnvfx(dbl_floating_point *, dbl_floating_point *, dbl_integer *, unsigned int *);

int sgl_to_sgl_fcnvfxt(sgl_floating_point *, sgl_floating_point *, int *, unsigned int *);
int sgl_to_dbl_fcnvfxt(sgl_floating_point *, sgl_floating_point *, dbl_integer *, unsigned int *);
int dbl_to_sgl_fcnvfxt(dbl_floating_point *, dbl_floating_point *, int *, unsigned int *);
int dbl_to_dbl_fcnvfxt(dbl_floating_point *, dbl_floating_point *, dbl_integer *, unsigned int *);

int sgl_to_sgl_fcnvxf(int *, int *, sgl_floating_point *, unsigned int *);
int sgl_to_dbl_fcnvxf(int *, int *, dbl_floating_point *, unsigned int *);
int dbl_to_sgl_fcnvxf(dbl_integer *, dbl_integer *, sgl_floating_point *, unsigned int *);
int dbl_to_dbl_fcnvxf(dbl_integer *, dbl_integer *, dbl_floating_point *, unsigned int *);
@


1.3
log
@ansi and fancy gcc
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d417 14
a430 14
int sgl_to_sgl_fcnvfx __P((sgl_floating_point *, sgl_floating_point *, int *, sgl_floating_point *));
int sgl_to_dbl_fcnvfx __P((sgl_floating_point *, void *, dbl_integer *, unsigned int *));
int dbl_to_sgl_fcnvfx __P((dbl_floating_point *, void *, int *, unsigned int *));
int dbl_to_dbl_fcnvfx __P((dbl_floating_point *, void *, dbl_integer *, unsigned int *));

int sgl_to_sgl_fcnvfxt __P((sgl_floating_point *, void *, int *, unsigned int *));
int sgl_to_dbl_fcnvfxt __P((sgl_floating_point *, void *, dbl_integer *, unsigned int *));
int dbl_to_sgl_fcnvfxt __P((dbl_floating_point *, void *, int *, unsigned int *));
int dbl_to_dbl_fcnvfxt __P((dbl_floating_point *, void *, dbl_integer *, unsigned int *));

int sgl_to_sgl_fcnvxf __P((int *, void *, sgl_floating_point *, unsigned int *));
int sgl_to_dbl_fcnvxf __P((int *, void *, dbl_floating_point *, unsigned int *));
int dbl_to_sgl_fcnvxf __P((dbl_integer *, void *, sgl_floating_point *, unsigned int *));
int dbl_to_dbl_fcnvxf __P((dbl_integer *, void *, dbl_floating_point *, unsigned int *));
@


1.2
log
@remove brain damaged rcs tags
@
text
@d1 2
d76 1
a76 1
#define Int_isinexact_to_sgl(int_value)	(int_value << 33 - SGL_EXP_LENGTH)
d80 1
a80 1
    	if ((int_value << 34 - SGL_EXP_LENGTH) || Slow(sgl_value))	\
d84 1
a84 1
    ((Dintp1(dint_valueA) << 33 - SGL_EXP_LENGTH) || Dintp2(dint_valueB))
d88 1
a88 1
    	if ((Dintp1(dint_valueA) << 34 - SGL_EXP_LENGTH) ||		\
d92 1
a92 1
    (Dintp2(dint_value) << 33 - DBL_EXP_LENGTH)
d96 1
a96 1
       if ((Dintp2(dint_opndB) << 34 - DBL_EXP_LENGTH) || Dlowp2(dbl_opndB))  \
d258 1
a258 1
    	    Dintp2(destB) = Dallp1(dbl_valueA) >> 20-exponent;		\
d260 1
a260 1
	     52-exponent,Dintp2(destB));					\
d264 1
a264 1
    	    Dintp1(destA) = Dallp1(dbl_valueA) >> 52-exponent;		\
d272 1
a272 1
    	    Dintp2(destB) = Dallp2(dbl_valueB) << exponent-52;		\
d314 1
a314 1
	    if (value >> 32 - position)		\
d318 1
a318 1
	if ((value >> 32 - position) == 0)	\
d416 17
@


1.1
log
@initial import of osf-hacked HP one
@
text
@a37 5
/*
 * @@(#)cnv_float.h: $Revision: 2.0 $ $Date: 1998/06/17 20:47:06 $
 * $Locker:  $
 * 
 */
@


1.1.1.1
log
@import the original hp sources for the spmath library w/
the a bsd-like hp licensing on 'em.
w/ many thanks to:
Mike Hibler <mike@@fast.cs.utah.edu>
James Loveluck <loveluck@@ri.silicomp.fr>
Patrick Roudaud <patrick@@enserg.fr>
@
text
@d2 36
a37 12
  (c) Copyright 1986 HEWLETT-PACKARD COMPANY
  To anyone who acknowledges that this file is provided "AS IS"
  without any express or implied warranty:
      permission to use, copy, modify, and distribute this file
  for any purpose is hereby granted without fee, provided that
  the above copyright notice and this notice appears in all
  copies, and that the name of Hewlett-Packard Company not be
  used in advertising or publicity pertaining to distribution
  of the software without specific, written prior permission.
  Hewlett-Packard Company makes no representations about the
  suitability of this software for any purpose.
*/
d39 1
a39 1
 * @@(#)cnv_float.h: $Revision: 2.9.88.1 $ $Date: 93/12/07 15:05:29 $
d325 95
@


