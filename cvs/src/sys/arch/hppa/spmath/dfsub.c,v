head	1.7;
access;
symbols
	OPENBSD_6_0:1.7.0.56
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.52
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.7.0.54
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.46
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.50
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.48
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.44
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.42
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.40
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.38
	OPENBSD_5_0:1.7.0.36
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.34
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.32
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.28
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.30
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.26
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.24
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.22
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.20
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.18
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.16
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.14
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.12
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.10
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.8
	OPENBSD_3_6_BASE:1.7
	SMP_SYNC_A:1.7
	SMP_SYNC_B:1.7
	OPENBSD_3_5:1.7.0.6
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.7.0.4
	OPENBSD_3_4_BASE:1.7
	UBC_SYNC_A:1.7
	OPENBSD_3_3:1.7.0.2
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	HPUX_REL9_05_800:1.1.1.1
	HP:1.1.1
	OPENBSD_3_1:1.4.0.8
	OPENBSD_3_1_BASE:1.4
	UBC_SYNC_B:1.6
	UBC:1.4.0.6
	UBC_BASE:1.4
	OPENBSD_3_0:1.4.0.4
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.3.0.12
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.10
	OPENBSD_2_7_BASE:1.3
	SMP:1.3.0.8
	SMP_BASE:1.3
	kame_19991208:1.3
	OPENBSD_2_6:1.3.0.6
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.4
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.2
	OPENBSD_2_4_BASE:1.3;
locks; strict;
comment	@ * @;


1.7
date	2002.11.29.09.27.34;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2002.09.20.19.26.59;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.07.22.19.30;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	2001.03.29.03.58.17;	author mickey;	state Exp;
branches
	1.4.6.1;
next	1.3;

1.3
date	98.07.02.19.05.08;	author mickey;	state Exp;
branches
	1.3.8.1;
next	1.2;

1.2
date	98.06.23.21.19.17;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	98.06.23.20.33.54;	author mickey;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.05.07.21.37.19;	author mickey;	state Exp;
branches;
next	;

1.3.8.1
date	2001.04.18.16.06.35;	author niklas;	state Exp;
branches;
next	1.3.8.2;

1.3.8.2
date	2003.03.27.23.26.54;	author niklas;	state Exp;
branches;
next	;

1.4.6.1
date	2002.06.11.03.35.37;	author art;	state Exp;
branches;
next	1.4.6.2;

1.4.6.2
date	2002.10.29.00.28.03;	author art;	state Exp;
branches;
next	1.4.6.3;

1.4.6.3
date	2003.05.19.21.49.42;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Foward; torh@@bogus.net
@
text
@/*	$OpenBSD: dfsub.c,v 1.6 2002/09/20 19:26:59 mickey Exp $	*/
/*
  (c) Copyright 1986 HEWLETT-PACKARD COMPANY
  To anyone who acknowledges that this file is provided "AS IS"
  without any express or implied warranty:
      permission to use, copy, modify, and distribute this file
  for any purpose is hereby granted without fee, provided that
  the above copyright notice and this notice appears in all
  copies, and that the name of Hewlett-Packard Company not be
  used in advertising or publicity pertaining to distribution
  of the software without specific, written prior permission.
  Hewlett-Packard Company makes no representations about the
  suitability of this software for any purpose.
*/
/* @@(#)dfsub.c: Revision: 2.8.88.1 Date: 93/12/07 15:05:48 */

#include "float.h"
#include "dbl_float.h"

/*
 * Double_subtract: subtract two double precision values.
 */
int
dbl_fsub(leftptr, rightptr, dstptr, status)
    dbl_floating_point *leftptr, *rightptr, *dstptr;
    unsigned int *status;
{
    register unsigned int signless_upper_left, signless_upper_right, save;
    register unsigned int leftp1, leftp2, rightp1, rightp2, extent;
    register unsigned int resultp1 = 0, resultp2 = 0;

    register int result_exponent, right_exponent, diff_exponent;
    register int sign_save, jumpsize;
    register int inexact = FALSE, underflowtrap;

    /* Create local copies of the numbers */
    Dbl_copyfromptr(leftptr,leftp1,leftp2);
    Dbl_copyfromptr(rightptr,rightp1,rightp2);

    /* A zero "save" helps discover equal operands (for later),  *
     * and is used in swapping operands (if needed).	     */
    Dbl_xortointp1(leftp1,rightp1,/*to*/save);

    /*
     * check first operand for NaN's or infinity
     */
    if ((result_exponent = Dbl_exponent(leftp1)) == DBL_INFINITY_EXPONENT)
	{
	if (Dbl_iszero_mantissa(leftp1,leftp2))
	    {
	    if (Dbl_isnotnan(rightp1,rightp2))
		{
		if (Dbl_isinfinity(rightp1,rightp2) && save==0)
		    {
		    /*
		     * invalid since operands are same signed infinity's
		     */
		    if (Is_invalidtrap_enabled()) return(INVALIDEXCEPTION);
		    Set_invalidflag();
		    Dbl_makequietnan(resultp1,resultp2);
		    Dbl_copytoptr(resultp1,resultp2,dstptr);
		    return(NOEXCEPTION);
		    }
		/*
		 * return infinity
		 */
		Dbl_copytoptr(leftp1,leftp2,dstptr);
		return(NOEXCEPTION);
		}
	    }
	else
	    {
	    /*
	     * is NaN; signaling or quiet?
	     */
	    if (Dbl_isone_signaling(leftp1))
		{
		/* trap if INVALIDTRAP enabled */
		if (Is_invalidtrap_enabled()) return(INVALIDEXCEPTION);
		/* make NaN quiet */
		Set_invalidflag();
		Dbl_set_quiet(leftp1);
		}
	    /*
	     * is second operand a signaling NaN?
	     */
	    else if (Dbl_is_signalingnan(rightp1))
		{
		/* trap if INVALIDTRAP enabled */
		if (Is_invalidtrap_enabled()) return(INVALIDEXCEPTION);
		/* make NaN quiet */
		Set_invalidflag();
		Dbl_set_quiet(rightp1);
		Dbl_copytoptr(rightp1,rightp2,dstptr);
		return(NOEXCEPTION);
		}
	    /*
	     * return quiet NaN
	     */
	    Dbl_copytoptr(leftp1,leftp2,dstptr);
	    return(NOEXCEPTION);
	    }
	} /* End left NaN or Infinity processing */
    /*
     * check second operand for NaN's or infinity
     */
    if (Dbl_isinfinity_exponent(rightp1))
	{
	if (Dbl_iszero_mantissa(rightp1,rightp2))
	    {
	    /* return infinity */
	    Dbl_invert_sign(rightp1);
	    Dbl_copytoptr(rightp1,rightp2,dstptr);
	    return(NOEXCEPTION);
	    }
	/*
	 * is NaN; signaling or quiet?
	 */
	if (Dbl_isone_signaling(rightp1))
	    {
	    /* trap if INVALIDTRAP enabled */
	    if (Is_invalidtrap_enabled()) return(INVALIDEXCEPTION);
	    /* make NaN quiet */
	    Set_invalidflag();
	    Dbl_set_quiet(rightp1);
	    }
	/*
	 * return quiet NaN
	 */
	Dbl_copytoptr(rightp1,rightp2,dstptr);
	return(NOEXCEPTION);
	} /* End right NaN or Infinity processing */

    /* Invariant: Must be dealing with finite numbers */

    /* Compare operands by removing the sign */
    Dbl_copytoint_exponentmantissap1(leftp1,signless_upper_left);
    Dbl_copytoint_exponentmantissap1(rightp1,signless_upper_right);

    /* sign difference selects add or sub operation. */
    if(Dbl_ismagnitudeless(leftp2,rightp2,signless_upper_left,signless_upper_right))
	{
	/* Set the left operand to the larger one by XOR swap *
	 *  First finish the first word using "save"	  */
	Dbl_xorfromintp1(save,rightp1,/*to*/rightp1);
	Dbl_xorfromintp1(save,leftp1,/*to*/leftp1);
	Dbl_swap_lower(leftp2,rightp2);
	result_exponent = Dbl_exponent(leftp1);
	Dbl_invert_sign(leftp1);
	}
    /* Invariant:  left is not smaller than right. */

    if((right_exponent = Dbl_exponent(rightp1)) == 0)
	{
	/* Denormalized operands.  First look for zeroes */
	if(Dbl_iszero_mantissa(rightp1,rightp2))
	    {
	    /* right is zero */
	    if(Dbl_iszero_exponentmantissa(leftp1,leftp2))
		{
		/* Both operands are zeros */
		Dbl_invert_sign(rightp1);
		if(Is_rounding_mode(ROUNDMINUS))
		    {
		    Dbl_or_signs(leftp1,/*with*/rightp1);
		    }
		else
		    {
		    Dbl_and_signs(leftp1,/*with*/rightp1);
		    }
		}
	    else
		{
		/* Left is not a zero and must be the result.  Trapped
		 * underflows are signaled if left is denormalized.  Result
		 * is always exact. */
		if( (result_exponent == 0) && Is_underflowtrap_enabled() )
		    {
		    /* need to normalize results mantissa */
		    sign_save = Dbl_signextendedsign(leftp1);
		    Dbl_leftshiftby1(leftp1,leftp2);
		    Dbl_normalize(leftp1,leftp2,result_exponent);
		    Dbl_set_sign(leftp1,/*using*/sign_save);
		    Dbl_setwrapped_exponent(leftp1,result_exponent,unfl);
		    Dbl_copytoptr(leftp1,leftp2,dstptr);
		    /* inexact = FALSE */
		    return(UNDERFLOWEXCEPTION);
		    }
		}
	    Dbl_copytoptr(leftp1,leftp2,dstptr);
	    return(NOEXCEPTION);
	    }

	/* Neither are zeroes */
	Dbl_clear_sign(rightp1);	/* Exponent is already cleared */
	if(result_exponent == 0 )
	    {
	    /* Both operands are denormalized.  The result must be exact
	     * and is simply calculated.  A sum could become normalized and a
	     * difference could cancel to a true zero. */
	    if( (/*signed*/int) save >= 0 )
		{
		Dbl_subtract(leftp1,leftp2,/*minus*/rightp1,rightp2,
		 /*into*/resultp1,resultp2);
		if(Dbl_iszero_mantissa(resultp1,resultp2))
		    {
		    if(Is_rounding_mode(ROUNDMINUS))
			{
			Dbl_setone_sign(resultp1);
			}
		    else
			{
			Dbl_setzero_sign(resultp1);
			}
		    Dbl_copytoptr(resultp1,resultp2,dstptr);
		    return(NOEXCEPTION);
		    }
		}
	    else
		{
		Dbl_addition(leftp1,leftp2,rightp1,rightp2,
		 /*into*/resultp1,resultp2);
		if(Dbl_isone_hidden(resultp1))
		    {
		    Dbl_copytoptr(resultp1,resultp2,dstptr);
		    return(NOEXCEPTION);
		    }
		}
	    if(Is_underflowtrap_enabled())
		{
		/* need to normalize result */
		sign_save = Dbl_signextendedsign(resultp1);
		Dbl_leftshiftby1(resultp1,resultp2);
		Dbl_normalize(resultp1,resultp2,result_exponent);
		Dbl_set_sign(resultp1,/*using*/sign_save);
		Dbl_setwrapped_exponent(resultp1,result_exponent,unfl);
		Dbl_copytoptr(resultp1,resultp2,dstptr);
		/* inexact = FALSE */
		return(UNDERFLOWEXCEPTION);
		}
	    Dbl_copytoptr(resultp1,resultp2,dstptr);
	    return(NOEXCEPTION);
	    }
	right_exponent = 1;	/* Set exponent to reflect different bias
				 * with denomalized numbers. */
	}
    else
	{
	Dbl_clear_signexponent_set_hidden(rightp1);
	}
    Dbl_clear_exponent_set_hidden(leftp1);
    diff_exponent = result_exponent - right_exponent;

    /*
     * Special case alignment of operands that would force alignment
     * beyond the extent of the extension.  A further optimization
     * could special case this but only reduces the path length for this
     * infrequent case.
     */
    if(diff_exponent > DBL_THRESHOLD)
	{
	diff_exponent = DBL_THRESHOLD;
	}

    /* Align right operand by shifting to right */
    Dbl_right_align(/*operand*/rightp1,rightp2,/*shifted by*/diff_exponent,
     /*and lower to*/extent);

    /* Treat sum and difference of the operands separately. */
    if( (/*signed*/int) save >= 0 )
	{
	/*
	 * Difference of the two operands.  Their can be no overflow.  A
	 * borrow can occur out of the hidden bit and force a post
	 * normalization phase.
	 */
	Dbl_subtract_withextension(leftp1,leftp2,/*minus*/rightp1,rightp2,
	 /*with*/extent,/*into*/resultp1,resultp2);
	if(Dbl_iszero_hidden(resultp1))
	    {
	    /* Handle normalization */
	    /* A straight forward algorithm would now shift the result
	     * and extension left until the hidden bit becomes one.  Not
	     * all of the extension bits need participate in the shift.
	     * Only the two most significant bits (round and guard) are
	     * needed.  If only a single shift is needed then the guard
	     * bit becomes a significant low order bit and the extension
	     * must participate in the rounding.  If more than a single
	     * shift is needed, then all bits to the right of the guard
	     * bit are zeros, and the guard bit may or may not be zero. */
	    sign_save = Dbl_signextendedsign(resultp1);
	    Dbl_leftshiftby1_withextent(resultp1,resultp2,extent,resultp1,resultp2);

	    /* Need to check for a zero result.  The sign and exponent
	     * fields have already been zeroed.  The more efficient test
	     * of the full object can be used.
	     */
	    if(Dbl_iszero(resultp1,resultp2))
		/* Must have been "x-x" or "x+(-x)". */
		{
		if(Is_rounding_mode(ROUNDMINUS)) Dbl_setone_sign(resultp1);
		Dbl_copytoptr(resultp1,resultp2,dstptr);
		return(NOEXCEPTION);
		}
	    result_exponent--;
	    /* Look to see if normalization is finished. */
	    if(Dbl_isone_hidden(resultp1)) {
		if(result_exponent==0) {
		    /* Denormalized, exponent should be zero.  Left operand *
		     * was normalized, so extent (guard, round) was zero    */
		    goto underflow;
		} else {
			/* No further normalization is needed. */
			Dbl_set_sign(resultp1,/*using*/sign_save);
			Ext_leftshiftby1(extent);
			goto round;
		}
	    }

	    /* Check for denormalized, exponent should be zero.  Left    *
	     * operand was normalized, so extent (guard, round) was zero */
	    if(!(underflowtrap = Is_underflowtrap_enabled()) &&
	       result_exponent==0) goto underflow;

	    /* Shift extension to complete one bit of normalization and
	     * update exponent. */
	    Ext_leftshiftby1(extent);

	    /* Discover first one bit to determine shift amount.  Use a
	     * modified binary search.  We have already shifted the result
	     * one position right and still not found a one so the remainder
	     * of the extension must be zero and simplifies rounding. */
	    /* Scan bytes */
	    while(Dbl_iszero_hiddenhigh7mantissa(resultp1))
		{
		Dbl_leftshiftby8(resultp1,resultp2);
		if((result_exponent -= 8) <= 0  && !underflowtrap)
		    goto underflow;
		}
	    /* Now narrow it down to the nibble */
	    if(Dbl_iszero_hiddenhigh3mantissa(resultp1))
		{
		/* The lower nibble contains the normalizing one */
		Dbl_leftshiftby4(resultp1,resultp2);
		if((result_exponent -= 4) <= 0 && !underflowtrap)
		    goto underflow;
		}
	    /* Select case were first bit is set (already normalized)
	     * otherwise select the proper shift. */
	    if((jumpsize = Dbl_hiddenhigh3mantissa(resultp1)) > 7)
		{
		/* Already normalized */
		if(result_exponent <= 0) goto underflow;
		Dbl_set_sign(resultp1,/*using*/sign_save);
		Dbl_set_exponent(resultp1,/*using*/result_exponent);
		Dbl_copytoptr(resultp1,resultp2,dstptr);
		return(NOEXCEPTION);
		}
	    Dbl_sethigh4bits(resultp1,/*using*/sign_save);
	    switch(jumpsize)
		{
		case 1:
		    {
		    Dbl_leftshiftby3(resultp1,resultp2);
		    result_exponent -= 3;
		    break;
		    }
		case 2:
		case 3:
		    {
		    Dbl_leftshiftby2(resultp1,resultp2);
		    result_exponent -= 2;
		    break;
		    }
		case 4:
		case 5:
		case 6:
		case 7:
		    {
		    Dbl_leftshiftby1(resultp1,resultp2);
		    result_exponent -= 1;
		    break;
		    }
		}
	    if(result_exponent > 0)
		{
		Dbl_set_exponent(resultp1,/*using*/result_exponent);
		Dbl_copytoptr(resultp1,resultp2,dstptr);
		return(NOEXCEPTION);		/* Sign bit is already set */
		}
	    /* Fixup potential underflows */
	  underflow:
	    if(Is_underflowtrap_enabled())
		{
		Dbl_set_sign(resultp1,sign_save);
		Dbl_setwrapped_exponent(resultp1,result_exponent,unfl);
		Dbl_copytoptr(resultp1,resultp2,dstptr);
		/* inexact = FALSE */
		return(UNDERFLOWEXCEPTION);
		}
	    /*
	     * Since we cannot get an inexact denormalized result,
	     * we can now return.
	     */
	    Dbl_fix_overshift(resultp1,resultp2,(1-result_exponent),extent);
	    Dbl_clear_signexponent(resultp1);
	    Dbl_set_sign(resultp1,sign_save);
	    Dbl_copytoptr(resultp1,resultp2,dstptr);
	    return(NOEXCEPTION);
	    } /* end if(hidden...)... */
	/* Fall through and round */
	} /* end if(save >= 0)... */
    else
	{
	/* Subtract magnitudes */
	Dbl_addition(leftp1,leftp2,rightp1,rightp2,/*to*/resultp1,resultp2);
	if(Dbl_isone_hiddenoverflow(resultp1))
	    {
	    /* Prenormalization required. */
	    Dbl_rightshiftby1_withextent(resultp2,extent,extent);
	    Dbl_arithrightshiftby1(resultp1,resultp2);
	    result_exponent++;
	    } /* end if hiddenoverflow... */
	} /* end else ...subtract magnitudes... */

    /* Round the result.  If the extension is all zeros,then the result is
     * exact.  Otherwise round in the correct direction.  No underflow is
     * possible. If a postnormalization is necessary, then the mantissa is
     * all zeros so no shift is needed. */
  round:
    if(Ext_isnotzero(extent))
	{
	inexact = TRUE;
	switch(Rounding_mode())
	    {
	    case ROUNDNEAREST: /* The default. */
	    if(Ext_isone_sign(extent))
		{
		/* at least 1/2 ulp */
		if(Ext_isnotzero_lower(extent)  ||
		  Dbl_isone_lowmantissap2(resultp2))
		    {
		    /* either exactly half way and odd or more than 1/2ulp */
		    Dbl_increment(resultp1,resultp2);
		    }
		}
	    break;

	    case ROUNDPLUS:
	    if(Dbl_iszero_sign(resultp1))
		{
		/* Round up positive results */
		Dbl_increment(resultp1,resultp2);
		}
	    break;

	    case ROUNDMINUS:
	    if(Dbl_isone_sign(resultp1))
		{
		/* Round down negative results */
		Dbl_increment(resultp1,resultp2);
		}

	    case ROUNDZERO:;
	    /* truncate is simple */
	    } /* end switch... */
	if(Dbl_isone_hiddenoverflow(resultp1)) result_exponent++;
	}
    if(result_exponent == DBL_INFINITY_EXPONENT)
	{
	/* Overflow */
	if(Is_overflowtrap_enabled())
	    {
	    Dbl_setwrapped_exponent(resultp1,result_exponent,ovfl);
	    Dbl_copytoptr(resultp1,resultp2,dstptr);
	    if (inexact) {
		if (Is_inexacttrap_enabled())
		    return(OVERFLOWEXCEPTION | INEXACTEXCEPTION);
		else
		    Set_inexactflag();
	    }
	    return(OVERFLOWEXCEPTION);
	    }
	else
	    {
	    inexact = TRUE;
	    Set_overflowflag();
	    Dbl_setoverflow(resultp1,resultp2);
	    }
	}
    else Dbl_set_exponent(resultp1,result_exponent);
    Dbl_copytoptr(resultp1,resultp2,dstptr);
    if(inexact) {
	if(Is_inexacttrap_enabled())
		return(INEXACTEXCEPTION);
	else
		Set_inexactflag();
    }
    return(NOEXCEPTION);
}
@


1.6
log
@kill dangling space, line and a space in the tab
@
text
@d1 1
a1 1
/*	$OpenBSD: dfsub.c,v 1.5 2002/05/07 22:19:30 mickey Exp $	*/
d282 1
a282 1
	    /* A straight foward algorithm would now shift the result
@


1.5
log
@bring over our mods; the cnv*c have a problem now, described in the osf version of the cnv_float.h, at the end
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d500 1
a500 1
    }
@


1.4
log
@big bang
@
text
@d1 1
a1 23
/*	$OpenBSD: dfsub.c,v 1.3 1998/07/02 19:05:08 mickey Exp $	*/

/*
 * Copyright 1996 1995 by Open Software Foundation, Inc.
 *              All Rights Reserved
 *
 * Permission to use, copy, modify, and distribute this software and
 * its documentation for any purpose and without fee is hereby granted,
 * provided that the above copyright notice appears in all copies and
 * that both the copyright notice and this permission notice appear in
 * supporting documentation.
 *
 * OSF DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE.
 *
 * IN NO EVENT SHALL OSF BE LIABLE FOR ANY SPECIAL, INDIRECT, OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN ACTION OF CONTRACT,
 * NEGLIGENCE, OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
 * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */
d3 13
a15 16
 * pmk1.1
 */
/*
 * (c) Copyright 1986 HEWLETT-PACKARD COMPANY
 *
 * To anyone who acknowledges that this file is provided "AS IS"
 * without any express or implied warranty:
 *     permission to use, copy, modify, and distribute this file
 * for any purpose is hereby granted without fee, provided that
 * the above copyright notice and this notice appears in all
 * copies, and that the name of Hewlett-Packard Company not be
 * used in advertising or publicity pertaining to distribution
 * of the software without specific, written prior permission.
 * Hewlett-Packard Company makes no representations about the
 * suitability of this software for any purpose.
 */
d17 2
a18 2
#include "../spmath/float.h"
#include "../spmath/dbl_float.h"
d27 1
a27 1
    {
@


1.4.6.1
log
@Sync UBC branch to -current
@
text
@d1 23
a23 1
/*	$OpenBSD$	*/
d25 16
a40 13
  (c) Copyright 1986 HEWLETT-PACKARD COMPANY
  To anyone who acknowledges that this file is provided "AS IS"
  without any express or implied warranty:
      permission to use, copy, modify, and distribute this file
  for any purpose is hereby granted without fee, provided that
  the above copyright notice and this notice appears in all
  copies, and that the name of Hewlett-Packard Company not be
  used in advertising or publicity pertaining to distribution
  of the software without specific, written prior permission.
  Hewlett-Packard Company makes no representations about the
  suitability of this software for any purpose.
*/
/* @@(#)dfsub.c: Revision: 2.8.88.1 Date: 93/12/07 15:05:48 */
d42 2
a43 2
#include "float.h"
#include "dbl_float.h"
d52 1
a52 1
{
@


1.4.6.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: dfsub.c,v 1.4.6.1 2002/06/11 03:35:37 art Exp $	*/
d500 1
a500 1
}
@


1.4.6.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d282 1
a282 1
	    /* A straight forward algorithm would now shift the result
@


1.3
log
@ansi and fancy gcc
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d4 19
a22 19
 * Copyright 1996 1995 by Open Software Foundation, Inc.   
 *              All Rights Reserved 
 *  
 * Permission to use, copy, modify, and distribute this software and 
 * its documentation for any purpose and without fee is hereby granted, 
 * provided that the above copyright notice appears in all copies and 
 * that both the copyright notice and this permission notice appear in 
 * supporting documentation. 
 *  
 * OSF DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE 
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS 
 * FOR A PARTICULAR PURPOSE. 
 *  
 * IN NO EVENT SHALL OSF BE LIABLE FOR ANY SPECIAL, INDIRECT, OR 
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM 
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN ACTION OF CONTRACT, 
 * NEGLIGENCE, OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION 
 * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. 
 * 
d30 1
a30 1
 * To anyone who acknowledges that this file is provided "AS IS" 
d32 7
a38 7
 *     permission to use, copy, modify, and distribute this file 
 * for any purpose is hereby granted without fee, provided that 
 * the above copyright notice and this notice appears in all 
 * copies, and that the name of Hewlett-Packard Company not be 
 * used in advertising or publicity pertaining to distribution 
 * of the software without specific, written prior permission.  
 * Hewlett-Packard Company makes no representations about the 
d56 1
a56 1
    
d59 2
a60 2
    register boolean inexact = FALSE, underflowtrap;
        
d66 1
a66 1
     * and is used in swapping operands (if needed).             */
d74 1
a74 1
	if (Dbl_iszero_mantissa(leftp1,leftp2)) 
d76 1
a76 1
	    if (Dbl_isnotnan(rightp1,rightp2)) 
d78 1
a78 1
		if (Dbl_isinfinity(rightp1,rightp2) && save==0) 
d80 1
a80 1
		    /* 
d84 2
a85 2
                    Set_invalidflag();
                    Dbl_makequietnan(resultp1,resultp2);
d90 2
a91 2
	 	 * return infinity
	 	 */
d96 1
a96 1
	else 
d98 4
a101 4
            /*
             * is NaN; signaling or quiet?
             */
            if (Dbl_isone_signaling(leftp1)) 
d103 1
a103 1
               	/* trap if INVALIDTRAP enabled */
d105 6
a110 6
        	/* make NaN quiet */
        	Set_invalidflag();
        	Dbl_set_quiet(leftp1);
        	}
	    /* 
	     * is second operand a signaling NaN? 
d112 1
a112 1
	    else if (Dbl_is_signalingnan(rightp1)) 
d114 2
a115 2
        	/* trap if INVALIDTRAP enabled */
               	if (Is_invalidtrap_enabled()) return(INVALIDEXCEPTION);
d123 2
a124 2
 	     * return quiet NaN
 	     */
d126 1
a126 1
 	    return(NOEXCEPTION);
d132 1
a132 1
    if (Dbl_isinfinity_exponent(rightp1)) 
d134 1
a134 1
	if (Dbl_iszero_mantissa(rightp1,rightp2)) 
d141 4
a144 4
        /*
         * is NaN; signaling or quiet?
         */
        if (Dbl_isone_signaling(rightp1)) 
d146 1
a146 1
            /* trap if INVALIDTRAP enabled */
d154 1
a154 1
 	 */
d157 1
a157 1
    	} /* End right NaN or Infinity processing */
d169 1
a169 1
	 *  First finish the first word using "save"          */
d172 1
a172 1
     	Dbl_swap_lower(leftp2,rightp2);
d176 1
a176 1
    /* Invariant:  left is not smaller than right. */ 
d179 1
a179 1
        {
d181 1
a181 1
	if(Dbl_iszero_mantissa(rightp1,rightp2)) 
d197 1
a197 1
	    else 
d205 1
a205 1
	    	    sign_save = Dbl_signextendedsign(leftp1);
d209 1
a209 1
                    Dbl_setwrapped_exponent(leftp1,result_exponent,unfl);
d257 1
a257 1
	    	sign_save = Dbl_signextendedsign(resultp1);
d261 1
a261 1
                Dbl_setwrapped_exponent(resultp1,result_exponent,unfl);
d279 2
a280 2
    /* 
     * Special case alignment of operands that would force alignment 
d289 1
a289 1
    
d313 2
a314 2
	     * must participate in the rounding.  If more than a single 
	     * shift is needed, then all bits to the right of the guard 
d317 1
a317 1
            Dbl_leftshiftby1_withextent(resultp1,resultp2,extent,resultp1,resultp2);
d319 1
a319 1
            /* Need to check for a zero result.  The sign and exponent
d323 1
a323 1
    	    if(Dbl_iszero(resultp1,resultp2))
d332 2
a333 4
	    if(Dbl_isone_hidden(resultp1))
		{
		if(result_exponent==0)
		    {
d337 5
a341 8
		    }
		else
		    {
		    /* No further normalization is needed. */
		    Dbl_set_sign(resultp1,/*using*/sign_save);
	    	    Ext_leftshiftby1(extent);
		    goto round;
		    }
d343 1
d385 1
a385 1
	    switch(jumpsize) 
d410 1
a410 1
	    if(result_exponent > 0) 
d421 1
a421 1
                Dbl_setwrapped_exponent(resultp1,result_exponent,unfl);
d426 1
a426 1
	    /* 
d438 1
a438 1
    else 
d450 1
a450 1
    
d481 1
a481 1
	    
d488 1
a488 1
	    
d495 3
a497 3
        {
        /* Overflow */
        if(Is_overflowtrap_enabled())
d502 1
a502 1
	        if (Is_inexacttrap_enabled())
d509 1
a509 1
        else
@


1.3.8.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: dfsub.c,v 1.4 2001/03/29 03:58:17 mickey Exp $	*/
d4 19
a22 19
 * Copyright 1996 1995 by Open Software Foundation, Inc.
 *              All Rights Reserved
 *
 * Permission to use, copy, modify, and distribute this software and
 * its documentation for any purpose and without fee is hereby granted,
 * provided that the above copyright notice appears in all copies and
 * that both the copyright notice and this permission notice appear in
 * supporting documentation.
 *
 * OSF DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE.
 *
 * IN NO EVENT SHALL OSF BE LIABLE FOR ANY SPECIAL, INDIRECT, OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN ACTION OF CONTRACT,
 * NEGLIGENCE, OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
 * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
d30 1
a30 1
 * To anyone who acknowledges that this file is provided "AS IS"
d32 7
a38 7
 *     permission to use, copy, modify, and distribute this file
 * for any purpose is hereby granted without fee, provided that
 * the above copyright notice and this notice appears in all
 * copies, and that the name of Hewlett-Packard Company not be
 * used in advertising or publicity pertaining to distribution
 * of the software without specific, written prior permission.
 * Hewlett-Packard Company makes no representations about the
d56 1
a56 1

d59 2
a60 2
    register int inexact = FALSE, underflowtrap;

d66 1
a66 1
     * and is used in swapping operands (if needed).	     */
d74 1
a74 1
	if (Dbl_iszero_mantissa(leftp1,leftp2))
d76 1
a76 1
	    if (Dbl_isnotnan(rightp1,rightp2))
d78 1
a78 1
		if (Dbl_isinfinity(rightp1,rightp2) && save==0)
d80 1
a80 1
		    /*
d84 2
a85 2
		    Set_invalidflag();
		    Dbl_makequietnan(resultp1,resultp2);
d90 2
a91 2
		 * return infinity
		 */
d96 1
a96 1
	else
d98 4
a101 4
	    /*
	     * is NaN; signaling or quiet?
	     */
	    if (Dbl_isone_signaling(leftp1))
d103 1
a103 1
		/* trap if INVALIDTRAP enabled */
d105 6
a110 6
		/* make NaN quiet */
		Set_invalidflag();
		Dbl_set_quiet(leftp1);
		}
	    /*
	     * is second operand a signaling NaN?
d112 1
a112 1
	    else if (Dbl_is_signalingnan(rightp1))
d114 2
a115 2
		/* trap if INVALIDTRAP enabled */
		if (Is_invalidtrap_enabled()) return(INVALIDEXCEPTION);
d123 2
a124 2
	     * return quiet NaN
	     */
d126 1
a126 1
	    return(NOEXCEPTION);
d132 1
a132 1
    if (Dbl_isinfinity_exponent(rightp1))
d134 1
a134 1
	if (Dbl_iszero_mantissa(rightp1,rightp2))
d141 4
a144 4
	/*
	 * is NaN; signaling or quiet?
	 */
	if (Dbl_isone_signaling(rightp1))
d146 1
a146 1
	    /* trap if INVALIDTRAP enabled */
d154 1
a154 1
	 */
d157 1
a157 1
	} /* End right NaN or Infinity processing */
d169 1
a169 1
	 *  First finish the first word using "save"	  */
d172 1
a172 1
	Dbl_swap_lower(leftp2,rightp2);
d176 1
a176 1
    /* Invariant:  left is not smaller than right. */
d179 1
a179 1
	{
d181 1
a181 1
	if(Dbl_iszero_mantissa(rightp1,rightp2))
d197 1
a197 1
	    else
d205 1
a205 1
		    sign_save = Dbl_signextendedsign(leftp1);
d209 1
a209 1
		    Dbl_setwrapped_exponent(leftp1,result_exponent,unfl);
d257 1
a257 1
		sign_save = Dbl_signextendedsign(resultp1);
d261 1
a261 1
		Dbl_setwrapped_exponent(resultp1,result_exponent,unfl);
d279 2
a280 2
    /*
     * Special case alignment of operands that would force alignment
d289 1
a289 1

d313 2
a314 2
	     * must participate in the rounding.  If more than a single
	     * shift is needed, then all bits to the right of the guard
d317 1
a317 1
	    Dbl_leftshiftby1_withextent(resultp1,resultp2,extent,resultp1,resultp2);
d319 1
a319 1
	    /* Need to check for a zero result.  The sign and exponent
d323 1
a323 1
	    if(Dbl_iszero(resultp1,resultp2))
d332 4
a335 2
	    if(Dbl_isone_hidden(resultp1)) {
		if(result_exponent==0) {
d339 8
a346 5
		} else {
			/* No further normalization is needed. */
			Dbl_set_sign(resultp1,/*using*/sign_save);
			Ext_leftshiftby1(extent);
			goto round;
a347 1
	    }
d389 1
a389 1
	    switch(jumpsize)
d414 1
a414 1
	    if(result_exponent > 0)
d425 1
a425 1
		Dbl_setwrapped_exponent(resultp1,result_exponent,unfl);
d430 1
a430 1
	    /*
d442 1
a442 1
    else
d454 1
a454 1

d485 1
a485 1

d492 1
a492 1

d499 3
a501 3
	{
	/* Overflow */
	if(Is_overflowtrap_enabled())
d506 1
a506 1
		if (Is_inexacttrap_enabled())
d513 1
a513 1
	else
@


1.3.8.2
log
@Sync the SMP branch with 3.3
@
text
@d1 23
a23 1
/*	$OpenBSD$	*/
d25 16
a40 13
  (c) Copyright 1986 HEWLETT-PACKARD COMPANY
  To anyone who acknowledges that this file is provided "AS IS"
  without any express or implied warranty:
      permission to use, copy, modify, and distribute this file
  for any purpose is hereby granted without fee, provided that
  the above copyright notice and this notice appears in all
  copies, and that the name of Hewlett-Packard Company not be
  used in advertising or publicity pertaining to distribution
  of the software without specific, written prior permission.
  Hewlett-Packard Company makes no representations about the
  suitability of this software for any purpose.
*/
/* @@(#)dfsub.c: Revision: 2.8.88.1 Date: 93/12/07 15:05:48 */
d42 2
a43 2
#include "float.h"
#include "dbl_float.h"
d52 1
a52 1
{
d307 1
a307 1
	    /* A straight forward algorithm would now shift the result
d525 1
a525 1
}
@


1.2
log
@remove brain damaged rcs tags
@
text
@d1 2
d48 1
d505 6
a510 4
	    if (inexact)
	    if (Is_inexacttrap_enabled())
		return(OVERFLOWEXCEPTION | INEXACTEXCEPTION);
		else Set_inexactflag();
d522 6
a527 3
    if(inexact) 
	if(Is_inexacttrap_enabled()) return(INEXACTEXCEPTION);
	else Set_inexactflag();
@


1.1
log
@initial import of osf-hacked HP one
@
text
@a38 5
/* $Source: /cvs/mickey/src/arch/hppa/spmath/dfsub.c,v $
 * $Revision: 2.0 $	$Author: mickey $
 * $State: Exp $   	$Locker:  $
 * $Date: 1998/06/17 20:47:15 $
 */
@


1.1.1.1
log
@import the original hp sources for the spmath library w/
the a bsd-like hp licensing on 'em.
w/ many thanks to:
Mike Hibler <mike@@fast.cs.utah.edu>
James Loveluck <loveluck@@ri.silicomp.fr>
Patrick Roudaud <patrick@@enserg.fr>
@
text
@d2 39
a40 14
  (c) Copyright 1986 HEWLETT-PACKARD COMPANY
  To anyone who acknowledges that this file is provided "AS IS"
  without any express or implied warranty:
      permission to use, copy, modify, and distribute this file
  for any purpose is hereby granted without fee, provided that
  the above copyright notice and this notice appears in all
  copies, and that the name of Hewlett-Packard Company not be
  used in advertising or publicity pertaining to distribution
  of the software without specific, written prior permission.
  Hewlett-Packard Company makes no representations about the
  suitability of this software for any purpose.
*/
/* $Source: /usr/local/kcs/sys.REL9_05_800/spmath/RCS/dfsub.c,v $
 * $Revision: 2.8.88.1 $	$Author: root $
d42 1
a42 1
 * $Date: 93/12/07 15:05:48 $
@


