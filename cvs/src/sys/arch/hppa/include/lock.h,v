head	1.9;
access;
symbols
	OPENBSD_6_1:1.9.0.12
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.9.0.8
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.4
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.9.0.6
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.7.0.4
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.6.0.14
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.10
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.8
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.6
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.4
	OPENBSD_5_0:1.6.0.2
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.2.0.2
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.1.0.10
	OPENBSD_4_7_BASE:1.1
	OPENBSD_4_6:1.1.0.12
	OPENBSD_4_6_BASE:1.1
	OPENBSD_4_5:1.1.0.8
	OPENBSD_4_5_BASE:1.1
	OPENBSD_4_4:1.1.0.6
	OPENBSD_4_4_BASE:1.1
	OPENBSD_4_3:1.1.0.4
	OPENBSD_4_3_BASE:1.1
	OPENBSD_4_2:1.1.0.2
	OPENBSD_4_2_BASE:1.1;
locks; strict;
comment	@ * @;


1.9
date	2015.02.11.00.14.11;	author dlg;	state Exp;
branches;
next	1.8;
commitid	OPUATglsyqcmeG4g;

1.8
date	2014.09.22.12.12.23;	author dlg;	state Exp;
branches;
next	1.7;
commitid	110ZOYfYFru8WqOb;

1.7
date	2014.03.29.18.09.29;	author guenther;	state Exp;
branches;
next	1.6;

1.6
date	2011.06.24.12.49.06;	author jsing;	state Exp;
branches;
next	1.5;

1.5
date	2011.03.23.16.54.35;	author pirofti;	state Exp;
branches;
next	1.4;

1.4
date	2011.01.12.21.11.12;	author kettenis;	state Exp;
branches;
next	1.3;

1.3
date	2011.01.12.21.07.12;	author kettenis;	state Exp;
branches;
next	1.2;

1.2
date	2010.07.01.03.38.50;	author jsing;	state Exp;
branches;
next	1.1;

1.1
date	2007.05.01.18.56.30;	author miod;	state Exp;
branches;
next	;


desc
@@


1.9
log
@make the rwlock implementation MI.

each arch used to have to provide an rw_cas operation, but now we
have the rwlock code build its own version. on smp machines it uses
atomic_cas_ulong. on uniproc machines it avoids interlocked
instructions by using straight loads and stores. this is safe because
rwlocks are only used from process context and processes are currently
not preemptible in our kernel. so alpha/ppc/etc might get a benefit.

ok miod@@ kettenis@@ deraadt@@
@
text
@/*	$OpenBSD: lock.h,v 1.8 2014/09/22 12:12:23 dlg Exp $	*/

/* public domain */

#ifndef	_MACHINE_LOCK_H_
#define	_MACHINE_LOCK_H_

#endif	/* _MACHINE_LOCK_H_ */
@


1.8
log
@implement atomic_{cas,swap}_{uint,ulong,ptr} and
atomic_{add,sub}_{int,long}_nv. sys/atomic.h turns these into the
rest of the atomic api.

on uniprocessor hppa systems "atomic" operations are implemented
as a non-interruptable sequence by disabling all interrupts on the
cpu, doing the operation, and then restoring the interrupt mask.

this isnt enough on MP systems, so we added a global atomic memory
mutex that is taken inside the interrupt disabling above to coordinate
operations between cpus.

this is a lot of overhead though cos mutexes dance around with ipls,
which is unecessary in our case because of the interrupt disabling
that is already done. also, hppa spinlocks are implemented with
ldcw which requires the word it operates on to be 16 byte aligned.
mutexes arent guaranteed to have this alignment so they compensate
by having lots of words inside themselves so they can hit the
appropriate one to use for the ldcw op.

with this in mind, this change pulls __cpu_simple_locks, which are
simply ldcw spinlocks with a 16 byte aligned word, out of
src/sys/arch/hppa/include/lock.h into src/sys/arch/hppa/include/atomic.h
so atomic.h can use them. lock.h includes atomic.h, so it still
gets and provides the same functionality as before.

finally, this also pulls the rwlock cas implementation apart. cas
ops now share the same serialising lock on MP systems as the other
memory operations, and rw_cas is defined as a wrapper around
atomic_cas_uint.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lock.h,v 1.7 2014/03/29 18:09:29 guenther Exp $	*/
a6 4

#include <machine/atomic.h>

#define rw_cas(p, o, n) (atomic_cas_ulong(p, o, n) != o)
@


1.7
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lock.h,v 1.6 2011/06/24 12:49:06 jsing Exp $	*/
d10 1
a10 43
typedef volatile u_int __cpu_simple_lock_t __attribute__((__aligned__(16)));

#define	__SIMPLELOCK_LOCKED	0
#define	__SIMPLELOCK_UNLOCKED	1

static __inline__ void
__cpu_simple_lock_init(__cpu_simple_lock_t *l)
{
	*l = __SIMPLELOCK_UNLOCKED;
}

static __inline__ void
__cpu_simple_lock(__cpu_simple_lock_t *l)
{
	volatile u_int old;

	do {
		__asm__ volatile
		    ("ldcws 0(%2), %0" : "=&r" (old), "+m" (l) : "r" (l));
	} while (old != __SIMPLELOCK_UNLOCKED);
}

static __inline__ int
__cpu_simple_lock_try(__cpu_simple_lock_t *l)
{
	volatile u_int old;

	__asm__ volatile
	    ("ldcws 0(%2), %0" : "=&r" (old), "+m" (l) : "r" (l));

	return (old == __SIMPLELOCK_UNLOCKED);
}

static __inline__ void
__cpu_simple_unlock(__cpu_simple_lock_t *l)
{
	*l = __SIMPLELOCK_UNLOCKED;
}

#if defined(_KERNEL) && defined(MULTIPROCESSOR)
int	rw_cas_hppa(volatile unsigned long *, unsigned long, unsigned long);
#define	rw_cas rw_cas_hppa
#endif
@


1.6
log
@When reading the value from a simple lock, we do not need to ldcws into a
__cpu_simple_lock_t - gcc most likely ignores the alignment for a stack
variable anyway. Also remove unnecessary initialisation.

ok kettenis@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lock.h,v 1.4 2011/01/12 21:11:12 kettenis Exp $	*/
d27 1
a27 1
		__asm__ __volatile__
d37 1
a37 1
	__asm__ __volatile__
@


1.5
log
@Normalize sentinel. Use _MACHINE_*_H_ and _<ARCH>_*_H_ properly and consitently.

Discussed and okay drahn@@. Okay deraadt@@.
@
text
@d24 1
a24 1
	__cpu_simple_lock_t old;
a26 1
		old = __SIMPLELOCK_LOCKED;
d35 1
a35 1
	__cpu_simple_lock_t old = __SIMPLELOCK_LOCKED;
@


1.4
log
@Provide a specific rw_cas() function for MP kernels; stolen from m88k.

ok jsing@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lock.h,v 1.3 2011/01/12 21:07:12 kettenis Exp $	*/
d5 2
a6 2
#ifndef	_HPPA_LOCK_H_
#define	_HPPA_LOCK_H_
d55 1
a55 1
#endif	/* _HPPA_LOCK_H_ */
@


1.3
log
@Make __cpu_simple_lock implementation actually work.

ok deraadt@@, jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lock.h,v 1.2 2010/07/01 03:38:50 jsing Exp $	*/
d49 5
@


1.2
log
@Include atomic.h via lock.h like other architectures do.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lock.h,v 1.1 2007/05/01 18:56:30 miod Exp $	*/
d29 1
a29 1
		    ("ldcw %1, %0" : "=r" (old), "=m" (l) : "m" (l));
d39 1
a39 1
	    ("ldcw %1, %0" : "=r" (old), "=m" (l) : "m" (l));
@


1.1
log
@Provide <machine/lock.h> on all platforms, so that MI code may #include it
unconditionnaly.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d7 2
@

