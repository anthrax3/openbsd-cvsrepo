head	1.19;
access;
symbols
	OPENBSD_6_0:1.19.0.32
	OPENBSD_6_0_BASE:1.19
	OPENBSD_5_9:1.19.0.28
	OPENBSD_5_9_BASE:1.19
	OPENBSD_5_8:1.19.0.30
	OPENBSD_5_8_BASE:1.19
	OPENBSD_5_7:1.19.0.22
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.19.0.26
	OPENBSD_5_6_BASE:1.19
	OPENBSD_5_5:1.19.0.24
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.19.0.20
	OPENBSD_5_4_BASE:1.19
	OPENBSD_5_3:1.19.0.18
	OPENBSD_5_3_BASE:1.19
	OPENBSD_5_2:1.19.0.16
	OPENBSD_5_2_BASE:1.19
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.14
	OPENBSD_5_0:1.19.0.12
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.19.0.10
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.19.0.8
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.19.0.4
	OPENBSD_4_7_BASE:1.19
	OPENBSD_4_6:1.19.0.6
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.19.0.2
	OPENBSD_4_5_BASE:1.19
	OPENBSD_4_4:1.18.0.4
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.18.0.2
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.17.0.10
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.17.0.8
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.17.0.6
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.17.0.4
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.17.0.2
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.16.0.4
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.16.0.2
	OPENBSD_3_6_BASE:1.16
	SMP_SYNC_A:1.16
	SMP_SYNC_B:1.16
	OPENBSD_3_5:1.15.0.2
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.13.0.2
	OPENBSD_3_4_BASE:1.13
	UBC_SYNC_A:1.13
	OPENBSD_3_3:1.12.0.2
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.11.0.4
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	UBC_SYNC_B:1.11
	UBC:1.9.0.2
	UBC_BASE:1.9
	OPENBSD_3_0:1.8.0.6
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9:1.8.0.4
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_8:1.8.0.2
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.7.0.2
	OPENBSD_2_7_BASE:1.7
	SMP:1.6.0.4
	SMP_BASE:1.6
	kame_19991208:1.6
	OPENBSD_2_6:1.6.0.2
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.5.0.2
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.1.0.2
	OPENBSD_2_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.19
date	2009.02.06.17.26.21;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2007.10.20.16.41.45;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2005.04.07.00.21.51;	author mickey;	state Exp;
branches;
next	1.16;

1.16
date	2004.04.07.18.24.19;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	2004.01.05.09.53.40;	author jmc;	state Exp;
branches;
next	1.14;

1.14
date	2003.11.03.05.34.44;	author david;	state Exp;
branches;
next	1.13;

1.13
date	2003.03.29.01.00.49;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	2003.01.22.23.36.03;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	2002.03.15.01.20.04;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.14.01.26.32;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.12.02.04.10.25;	author mickey;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2000.05.15.15.16.41;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	2000.04.24.14.24.48;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	99.04.20.19.36.32;	author mickey;	state Exp;
branches
	1.6.4.1;
next	1.5;

1.5
date	99.02.25.17.25.09;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	99.01.11.18.14.52;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	98.12.13.06.47.02;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	98.10.30.19.26.02;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	98.06.23.19.45.23;	author mickey;	state Exp;
branches;
next	;

1.6.4.1
date	2001.04.18.16.06.25;	author niklas;	state Exp;
branches;
next	1.6.4.2;

1.6.4.2
date	2001.12.05.00.39.10;	author niklas;	state Exp;
branches;
next	1.6.4.3;

1.6.4.3
date	2002.03.28.10.29.05;	author niklas;	state Exp;
branches;
next	1.6.4.4;

1.6.4.4
date	2003.03.27.23.26.54;	author niklas;	state Exp;
branches;
next	1.6.4.5;

1.6.4.5
date	2003.05.13.19.41.04;	author ho;	state Exp;
branches;
next	1.6.4.6;

1.6.4.6
date	2004.02.19.10.48.40;	author niklas;	state Exp;
branches;
next	1.6.4.7;

1.6.4.7
date	2004.06.05.23.10.49;	author niklas;	state Exp;
branches;
next	;

1.9.2.1
date	2002.06.11.03.35.37;	author art;	state Exp;
branches;
next	1.9.2.2;

1.9.2.2
date	2003.05.19.21.49.41;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.19
log
@typo
@
text
@/*	$OpenBSD: iomod.h,v 1.18 2007/10/20 16:41:45 miod Exp $	*/

/*
 * Copyright (c) 2000-2004 Michael Shalayeff
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR OR HIS RELATIVES BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */
/*
 * Copyright (c) 1990 mt Xinu, Inc.  All rights reserved.
 * Copyright (c) 1990,1991,1992,1994 University of Utah.  All rights reserved.
 *
 * Permission to use, copy, modify and distribute this software is hereby
 * granted provided that (1) source code retains these copyright, permission,
 * and disclaimer notices, and (2) redistributions including binaries
 * reproduce the notices in supporting documentation, and (3) all advertising
 * materials mentioning features or use of this software display the following
 * acknowledgement: ``This product includes software developed by the
 * Computer Systems Laboratory at the University of Utah.''
 *
 * Copyright (c) 1990 mt Xinu, Inc.
 * This file may be freely distributed in any form as long as
 * this copyright notice is included.
 * MTXINU, THE UNIVERSITY OF UTAH, AND CSL PROVIDE THIS SOFTWARE ``AS
 * IS'' AND WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,
 * WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND
 * FITNESS FOR A PARTICULAR PURPOSE.
 *
 * CSL requests users of this software to return to csl-dist@@cs.utah.edu any
 * improvements that they make and grant CSL redistribution rights.
 *
 *	Utah $Hdr: iomod.h 1.6 94/12/14$
 *	Author: Jeff Forys (CSS), Dave Slattengren (mtXinu)
 */

#ifndef	_MACHINE_IOMOD_H_
#define	_MACHINE_IOMOD_H_

#include <machine/pdc.h>

/*
 * Structures and definitions for I/O Modules on HP-PA (9000/800).
 *
 * Memory layout:
 *
 *	0x00000000	+---------------------------------+
 *			|           Page Zero             |
 *	0x00000800	+ - - - - - - - - - - - - - - - - +
 *			|                                 |
 *			|                                 |
 *			|      Memory Address Space       |
 *			|                                 |
 *			|                                 |
 *	0xEF000000	+---------------------------------+
 *			|                                 |
 *			|        PDC Address Space        |
 *			|                                 |
 *	0xF1000000	+---------------------------------+
 *			|                                 |
 *			|                                 |
 *			|        I/O Address Space        |
 *			|                                 |
 *			|                                 |
 *	0xFFF80000	+ - - - - - - - - - - - - - - - - +
 *			|  Fixed Physical Address Space   |
 *	0xFFFC0000	+ - - - - - - - - - - - - - - - - +
 *			|  Local Broadcast Address Space  |
 *	0xFFFE0000	+ - - - - - - - - - - - - - - - - +
 *			| Global Broadcast Address Space  |
 *	0xFFFFFFFF	+---------------------------------+
 *
 * "Memory Address Space" is used by memory modules,
 *   "Page Zero" is described below.
 * "PDC Address Space" is used by Processor-Dependent Code.
 * "I/O Address Space" is used by I/O modules (and is not cached),
 *   "Fixed Physical" is used by modules on the central bus,
 *   "Local Broadcast" is used to reach all modules on the same bus, and
 *   "Global Broadcast" is used to reach all modules (thru bus converters).
 *   
 * SPA space (see below) ranges from 0xF1000000 thru 0xFFFC0000.
 */

#define	PDC_LOW		0xEF000000	/* define some ranges */
#define	PDC_HIGH	0xF1000000
#define	FPA_LOW		0xFFF80000
#define	FPA_HIGH	0xFFFC0000
#define	SPA_LOW		0xF1000000
#define	SPA_HIGH	0xFFFC0000
#define	SGC_LOW		0xF4000000
#define	SGC_HIGH	0xFA000000

#define	FPA_IOMOD	((FPA_HIGH-FPA_LOW)/sizeof(struct iomod))
#define	MAXMODBUS	((int)(FPA_IOMOD))	/* maximum modules/bus */

/* size of HPA space for any device */
#define	IOMOD_HPASIZE	0x1000

/* ASP prom offset for an lan stattion id */
#define	ASP_PROM	(0xf0810000)

/* offset to the device-specific registers,
 * basically sizeof(struct iomod) (see later)
 */
#define	IOMOD_DEVOFFSET	0x800

#if !defined(_LOCORE)

/*
 * The first 2K of Soft Physical Address space on the Initial Memory Module
 * is aptly called "page zero".  The following structure defines the format
 * of page zero.  Individual members of this structure should be accessed
 * as "PAGE0->member".
 */

#define	PAGE0	((struct pagezero *)0)	/* can't get any lower than this! */

struct pagezero {
	/* [0x000] Initialize Vectors */
	int	ivec_special;		/* must be zero */
	u_int	ivec_mempf;		/* powerfail recovery software */
	u_int	ivec_toc;		/* exec'd after Transfer Of Control */
	u_int	ivec_toclen;		/* bytes of ivec_toc code */
	u_int	ivec_rendz;		/* exec'd after Rendezvous Signal */
	u_int	ivec_mempflen;		/* bytes of ivec_mempf code */
	u_int	ivec_resv[2];		/* (reserved) */
	u_int	ivec_mbz;		/* must be zero */
	u_int	ivec_resv2[7];		/* (reserved) */

	/* [0x040] Processor Dependent */
	union	{
		u_int	pd_Resv1[112];	/* (reserved) processor dependent */
		struct	{		/* Viper-specific data */
			u_int	v_Resv1[39];
			u_int	v_Ctrlcpy;	/* copy of Viper `vi_control' */
			u_int	v_Resv2[72];
		} pd_Viper;
	} pz_Pdep;

	/* [0x200] IODC Data Area Descriptors
		   use PDC_ALLOC to allocate these memory regions */
	u_int	iodc_cons_base;		/* */
	u_int	iodc_cons_size;		/* */
	u_int	iodc_kbrd_base;		/* */
	u_int	iodc_kbrd_size;		/* */
	u_int	iodc_boot_base;		/* */
	u_int	iodc_boot_size;		/* */

	/* [0x218] */
	u_int	resv1[0x41];

	/* [0x31C] Capability Flags */
	u_int	cap_flags;		/* system capabilities */
#define	HPPA_CAP_WIDESCSI	0x00000001

	/* [0x320] Keyboard Extensions */
	u_int	kbrd_ext[2];

	/* [0x328] Boot Device Extensions */
	u_int	boot_ext[2];

	/* [0x330] Console/Display Extensions */
	u_int	cons_ext[2];

	/* [0x338] Initial Memory Module Extensions */
	u_int	imm_ext[2];

	/* [0x340] Memory Configuration */
	u_int	memc_cont_l;		/* memc_cont low part */
	u_int	memc_phsize_l;		/* memc_phsize low part */
	u_int	memc_adsize_l;		/* memc_adsize low part */
	u_int	memc_resv;		/* (reserved) */
	u_int	memc_cont;		/* bytes of contiguous valid memory */
	u_int	memc_phsize;		/* bytes of valid physical memory */
	u_int	memc_adsize;		/* bytes of SPA space used by PDC */
	u_int	memc_hpa_h;		/* HPA of CPU (high) */

	/* [0x360] Miscellaneous */
	struct boot_err mem_be[8];	/* boot errors (see above) */
	u_int	mem_free;		/* first free phys. memory location */
	u_int	mem_hpa;		/* HPA of CPU */
	u_int	mem_pdc;		/* PDC entry point */
	u_int	mem_10msec;		/* # of Interval Timer ticks in 10msec*/

	/* [0x390] Initial Memory Module */
	u_int	imm_hpa;		/* HPA of Initial Memory module */
	u_int	imm_soft_boot;		/* 0 == hard boot, 1 == soft boot */
	u_int	imm_spa_size;		/* bytes of SPA in IMM */
	u_int	imm_max_mem;		/* bytes of mem in IMM (<= spa_size) */

	/* [0x3A0] Boot Console/Display, Device, and Keyboard */
	struct pz_device mem_cons;	/* description of console device */
	struct pz_device mem_boot;	/* description of boot device */
	struct pz_device mem_kbd;	/* description of keyboard device */

	/* [0x430] Reserved */
	u_int	resv2[116];		/* (reserved) */

	/* [0x600] Processor Dependent */
	u_int	pd_resv2[128];		/* (reserved) processor dependent */
};
#define	v_ctrlcpy	pz_Pdep.pd_Viper.v_Ctrlcpy


/*
 * Every module has 4K-bytes of address space associated with it.
 * A Hard Physical Address (HPA) can be broken down as follows.
 *
 * Since this is an I/O space, the high 4 bits are always 1's.
 *
 * The "flex" address specifies which bus a module is on; there are
 * 256K-bytes of HPA space for each bus, however only values from
 * 64 - 1022 are valid for the "flex" field (1022 designates the
 * central bus).  The "flex" addr is set at bus configuration time.
 *
 * The "fixed" address specifies a particular module on the same
 * bus (i.e. among modules with the same "flex" address).  This
 * value can also be found in "device_path.dp_mod" in "pdc.h".
 *
 * A modules HPA space consists of 2 pages; the "up" bit specifies
 * which of these pages is being addressed.  In general, the lower
 * page is privileged and the upper page it module-type dependent.
 *
 */

struct hpa {
	u_int	hpa_ones: 4,	/* must be 1's; this is an I/O space addr */
		hpa_flex:10,	/* bus address for this module */
		hpa_fixed:6,	/* location of module on bus */
		hpa_up	: 1,	/* 1 == upper page, 0 == lower page */
		hpa_set	: 5,	/* register set */
		hpa_reg	: 4,	/* register number within a register set */
		hpa_zeros:2;	/* must be 0's; addrs are word aligned */
};


/*
 * Certain modules require additional memory (i.e. more than that
 * provided by the HPA space).  A Soft Physical Address (SPA) can be
 * broken down as follows, on a module-type specific basis (either
 * Memory SPA or I/O SPA).
 *
 * SPA space must be a power of 2, and aligned accordingly.  The IODC
 * provides all information needed by software to configure SPA space
 * for a particular module.
 */

struct memspa {
	u_int	spa_page:21,	/* page of memory */
		spa_off	:11;	/* offset into memory page */
};

struct iospa {
	u_int	spa_ones: 4,	/* must be 1's; this is an I/O space addr */
		spa_iopg:17,	/* page in I/O address space */
		spa_set	: 5,	/* register set */
		spa_reg	: 4,	/* register number within a register set */
		spa_mode: 2;	/* aligned according to bus transaction mode */
};


/*
 * It is possible to send a command to all modules on a particular bus
 * (local broadcast), or all modules (global broadcast).  A Broadcast
 * Physical Address (BPA) can be broken down as follows.
 *
 * Read and Clear transactions are not allowed in BPA space.  All pages
 * in BPA space are privileged.
 */

struct bpa {
	u_int	bpa_ones:14,	/* must be 1's; this is in BPA space */
		bpa_gbl	: 1,	/* 0 == local, 1 == global broadcast */
		bpa_page: 6,	/* page in local/global BPA space */
		bpa_set	: 5,	/* register set */
		bpa_reg	: 4,	/* register number within a register set */
		bpa_zeros:2;	/* must be 0's; addrs are word aligned */
};


/*
 * All I/O and Memory modules have 4K-bytes of HPA space associated with
 * it (described above), however not all modules implement every register.
 * The first 2K-bytes of registers are "privileged".
 *
 * (WO) == Write Only, (RO) == Read Only
 */

struct iomod {
/* SRS (Supervisor Register Set) */
	u_int	io_eir;		/* (WO) interrupt CPU; set bits in EIR CR */
	u_int	io_eim;		/* (WO) External Interrupt Message address */
	u_int	io_dc_rw;	/* write address of IODC to read IODC data */
	u_int	io_ii_rw;	/* read/clear external intrpt msg (bit-26) */
	u_int	io_dma_link;	/* pointer to "next quad" in DMA chain */
	u_int	io_dma_command;	/* (RO) chain command to exec on "next quad" */
	u_int	io_dma_address;	/* (RO) start of DMA */
	u_int	io_dma_count;	/* (RO) number of bytes remaining to xfer */
	u_int	io_flex;	/* (WO) HPA flex addr, LSB: bus master flag */
	u_int	io_spa;		/* (WO) SPA space; 0-20:addr, 24-31:iodc_spa */
	u_int	resv1[2];	/* (reserved) */
	u_int	io_command;	/* (WO) module commands (see below) */
	u_int	io_status;	/* (RO) error returns (see below) */
	u_int	io_control;	/* memory err logging (bit-9), bc forwarding */
	u_int	io_test;	/* (RO) self-test information */
/* ARS (Auxiliary Register Set) */
	u_int	io_err_sadd;	/* (RO) slave bus error or memory error addr */
	u_int	chain_addr;	/* start address of chain RAM */
	u_int	sub_mask_clr;	/* ignore intrpts on sub-channel (bitmask) */
	u_int	sub_mask_set;	/* service intrpts on sub-channel (bitmask) */
	u_int	diagnostic;	/* diagnostic use (reserved) */
	u_int	resv2[2];	/* (reserved) */
	u_int	nmi_address;	/* address to send data to when NMI detected */
	u_int	nmi_data;	/* NMI data to be sent */
	u_int	resv3[3];	/* (reserved) */
	u_int	io_mem_low;	/* bottom of memory address range */
	u_int	io_mem_high;	/* top of memory address range */
	u_int	io_io_low;	/* bottom of I/O HPA address Range */
	u_int	io_io_high;	/* top of I/O HPA address Range */

	u_int	priv_trs[160];	/* TRSes (Type-dependent Reg Sets) */

	u_int	priv_hvrs[320];	/* HVRSes (HVERSION-dependent Register Sets) */

	u_int	hvrs[512];	/* HVRSes (HVERSION-dependent Register Sets) */
};
#endif	/* !_LOCORE */

/* primarily for a "reboot" and "_rtt" routines */
#define	iomod_command	(4*12)

/* io_flex */
#define	DMA_ENABLE	0x1	/* flex register enable DMA bit */

/* io_spa */
#define	IOSPA(spa,iodc_data)	\
	((volatile caddr_t)		\
	 (spa | iodc_data.iodc_spa_shift | iodc_data.iodc_spa_enb << 5 | \
	  iodc_data.iodc_spa_pack << 6 | iodc_data.iodc_spa_io << 7))

/* io_command */
#define	CMD_STOP	0	/* halt any I/O, enable diagnostic access */
#define	CMD_FLUSH	1	/* abort DMA */
#define	CMD_CHAIN	2	/* initiate DMA */
#define	CMD_CLEAR	3	/* clear errors */
#define	CMD_RESET	5	/* reset any module */

/* io_status */
#define	IO_ERR_MEM_SL	0x10000	/* SPA space lost or corrupted */
#define	IO_ERR_MEM_SE	0x00200	/* severity: minor */
#define	IO_ERR_MEM_HE	0x00100	/* severity: affects invalid parts */
#define	IO_ERR_MEM_FE	0x00080	/* severity: bad */
#define	IO_ERR_MEM_RY	0x00040	/* IO_COMMAND register ready for command */
#define	IO_ERR_DMA_DG	0x00010	/* module in diagnostic mode */
#define	IO_ERR_DMA_PW	0x00004	/* Power Failing */
#define	IO_ERR_DMA_PL	0x00002	/* Power Lost */
#define	IO_ERR_VAL(x)	 (((x) >> 10) & 0x3f)
#define	IO_ERR_DEPEND	 0	/* unspecified error */
#define	IO_ERR_SPA	 1	/* (module-type specific) */
#define	IO_ERR_INTERNAL	 2	/* (module-type specific) */
#define	IO_ERR_MODE	 3	/* invalid mode or address space mapping */
#define	IO_ERR_ERROR_M	 4	/* bus error (master detect) */
#define	IO_ERR_DPARITY_S 5	/* data parity (slave detect) */
#define	IO_ERR_PROTO_M	 6	/* protocol error (master detect) */
#define	IO_ERR_ADDRESS	 7	/* no slave acknowledgement in transaction */
#define	IO_ERR_MORE	 8	/* device transferred more data than expected */
#define	IO_ERR_LESS	 9	/* device transferred less data than expected */
#define	IO_ERR_SAPARITY	10	/* slave address phase parity */
#define	IO_ERR_MAPARITY	11	/* master address phase parity */
#define	IO_ERR_MDPARITY	12	/* mode phase parity */
#define	IO_ERR_STPARITY	13	/* status phase parity */
#define	IO_ERR_CMD	14	/* unimplemented I/O Command */
#define	IO_ERR_BUS	15	/* generic bus error */
#define	IO_ERR_CORR	24	/* correctable memory error */
#define	IO_ERR_UNCORR	25	/* uncorrectable memory error */
#define	IO_ERR_MAP	26	/* equivalent to IO_ERR_CORR */
#define	IO_ERR_LINK	28	/* Bus Converter "link" (connection) error */
#define	IO_ERR_CCMD	32	/* Illegal DMA command */
#define	IO_ERR_ERROR_S	52	/* bus error (slave detect) */
#define	IO_ERR_DPARITY_M 53	/* data parity (master detect) */
#define	IO_ERR_PROTOCOL	54	/* protocol error (slave detect) */
#define	IO_ERR_SELFTEST	58	/* (module-type specific) */
#define	IO_ERR_BUSY	59	/* slave was busy too often or too long */
#define	IO_ERR_RETRY	60	/* "busied" transaction not retried soon enough */
#define	IO_ERR_ACCESS	61	/* illegal register access */
#define	IO_ERR_IMPROP	62	/* "improper" data written */
#define	IO_ERR_UNKNOWN	63

/* io_control (memory) */
#define	IO_CTL_MEMINIT	0x0	/* prevent some bus errors during memory init */
#define	IO_CTL_MEMOKAY	0x100	/* enable all bus error logging */

/* io_spa */
#define	SPA_ENABLE	0x20	/* io_spa register enable spa bit */

#endif	/* _MACHINE_IOMOD_H_ */
@


1.18
log
@enuf -> enough
@
text
@d1 1
a1 1
/*	$OpenBSD: iomod.h,v 1.17 2005/04/07 00:21:51 mickey Exp $	*/
d171 1
a171 1
	u_int	cap_flags;		/* system capabitlities */
@


1.17
log
@64bit-friendly pdc.h and iomod.h and correspondent changes elsewhere
@
text
@d1 1
a1 1
/*	$OpenBSD: iomod.h,v 1.16 2004/04/07 18:24:19 mickey Exp $	*/
d379 1
a379 1
#define	IO_ERR_MODE	 3	/* invlaid mode or address space mapping */
d386 1
a386 1
#define	IO_ERR_SAPARITY	10	/* slave addrss phase parity */
d402 1
a402 1
#define	IO_ERR_RETRY	60	/* "busied" transaction not retried soon enuf */
@


1.16
log
@update copyright; miod@@ is fine w/ files where he holds it too
@
text
@d1 1
a1 1
/*	$OpenBSD: iomod.h,v 1.15 2004/01/05 09:53:40 jmc Exp $	*/
d102 8
a109 19
#define	HPPA_IOBEGIN	0xF0000000
#define	HPPA_IOLEN	0x10000000
#define	PDC_ADDR	0xEF000000	/* explained above */
#define	IO_ADDR		0xF1000000
#define	SGC_SLOT1	0xF4000000	/* (hp700) */
#define	SGC_SLOT2	0xF8000000	/* (hp700) */
#define	SGC_SIZE	0x02000000	/* (hp700) */
#define	FP_ADDR		0xFFF80000
#define	LBCAST_ADDR	0xFFFC0000
#define	GBCAST_ADDR	0xFFFE0000

#define	PDC_LOW		PDC_ADDR	/* define some ranges */
#define	PDC_HIGH	IO_ADDR
#define	FPA_LOW		FP_ADDR
#define	FPA_HIGH	LBCAST_ADDR
#define	SPA_LOW		IO_ADDR
#define	SPA_HIGH	LBCAST_ADDR
#define	SGC_LOW		SGC_SLOT1
#define	SGC_HIGH	(SGC_SLOT2+SGC_SIZE)
d139 2
a140 2
	int	(*ivec_mempf)(void);	/* powerfail recovery software */
	int	(*ivec_toc)(void);	/* exec'd after Transfer Of Control */
d142 1
a142 1
	int	(*ivec_rendz)(void);	/* exec'd after Rendezvous Signal */
d200 1
a200 1
	int	(*mem_pdc)(void);	/* PDC entry point */
d204 1
a204 1
	struct iomod *imm_hpa;		/* HPA of Initial Memory module */
d313 1
a313 1
	caddr_t	io_dma_link;	/* pointer to "next quad" in DMA chain */
d315 1
a315 1
	caddr_t	io_dma_address;	/* (RO) start of DMA */
d317 2
a318 2
	caddr_t	io_flex;	/* (WO) HPA flex addr, LSB: bus master flag */
	caddr_t	io_spa;		/* (WO) SPA space; 0-20:addr, 24-31:iodc_spa */
d326 1
a326 1
	caddr_t	chain_addr;	/* start address of chain RAM */
d331 2
a332 2
	caddr_t	nmi_address;	/* address to send data to when NMI detected */
	caddr_t	nmi_data;	/* NMI data to be sent */
@


1.15
log
@typos from Jared Yanovich;
@
text
@d1 1
a1 1
/*	$OpenBSD: iomod.h,v 1.14 2003/11/03 05:34:44 david Exp $	*/
d4 1
a4 1
 * Copyright (c) 2000-2003 Michael Shalayeff
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Michael Shalayeff.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.14
log
@spelling fixes (in the comments)
@
text
@d1 1
a1 1
/*	$OpenBSD: iomod.h,v 1.13 2003/03/29 01:00:49 mickey Exp $	*/
d318 1
a318 1
 * The first 2K-bytes of registers are "priviliged".
@


1.13
log
@add some author refs from the older versions of these from much older projects
@
text
@d1 1
a1 1
/*	$OpenBSD: iomod.h,v 1.12 2003/01/22 23:36:03 mickey Exp $	*/
d400 2
a401 2
#define	IO_ERR_MORE	 8	/* device transfered more data than expected */
#define	IO_ERR_LESS	 9	/* device transfered less data than expected */
@


1.12
log
@kill the eiem defines we do not use
@
text
@d1 1
a1 1
/*	$OpenBSD: iomod.h,v 1.11 2002/03/15 01:20:04 millert Exp $	*/
d57 1
@


1.11
log
@Cosmetic changes only, primarily making comments line up nicely after the
__P removal.
@
text
@d1 1
a1 1
/*	$OpenBSD: iomod.h,v 1.10 2002/03/14 01:26:32 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 2000 Michael Shalayeff
a427 4

#define	EIM_GRPMASK	0x1F	/* EIM register group mask */
#define	EIEM_MASK(eim)	(0x80000000 >> (eim & EIM_GRPMASK))
#define	EIEM_BITCNT	32	/* number of bits in EIEM register */
@


1.10
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: iomod.h,v 1.9 2001/12/02 04:10:25 mickey Exp $	*/
d154 1
a154 1
	int	(*ivec_mempf)(void); /* powerfail recovery software */
d157 1
a157 1
	int	(*ivec_rendz)(void); /* exec'd after Rendezvous Signal */
@


1.9
log
@s/FLAX_MASK/HPPA_FLEX_MASK/ where not yet
@
text
@d1 1
a1 1
/*	$OpenBSD: iomod.h,v 1.8 2000/05/15 15:16:41 mickey Exp $	*/
d154 2
a155 2
	int	(*ivec_mempf)__P((void)); /* powerfail recovery software */
	int	(*ivec_toc)__P((void));	/* exec'd after Transfer Of Control */
d157 1
a157 1
	int	(*ivec_rendz)__P((void)); /* exec'd after Rendezvous Signal */
d215 1
a215 1
	int	(*mem_pdc)__P((void));	/* PDC entry point */
@


1.9.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: iomod.h,v 1.9 2001/12/02 04:10:25 mickey Exp $	*/
d154 2
a155 2
	int	(*ivec_mempf)(void);	/* powerfail recovery software */
	int	(*ivec_toc)(void);	/* exec'd after Transfer Of Control */
d157 1
a157 1
	int	(*ivec_rendz)(void);	/* exec'd after Rendezvous Signal */
d215 1
a215 1
	int	(*mem_pdc)(void);	/* PDC entry point */
@


1.9.2.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d4 1
a4 1
 * Copyright (c) 2000-2003 Michael Shalayeff
a56 1
 *	Author: Jeff Forys (CSS), Dave Slattengren (mtXinu)
d428 4
@


1.8
log
@extend page zero layout according to 2.x specification
@
text
@d1 1
a1 1
/*	$OpenBSD: iomod.h,v 1.7 2000/04/24 14:24:48 mickey Exp $	*/
a127 3

#define	FLEX_MASK	0xFFFC0000	/* (see below) */
#define	HPPA_FLEX(a)	(((a) & FLEX_MASK) >> 18)
@


1.7
log
@s/int/u_int/ pass iint page0 and generic io module, fixes a few obscure problems
@
text
@d1 1
a1 1
/*	$OpenBSD: iomod.h,v 1.6 1999/04/20 19:36:32 mickey Exp $	*/
d4 30
d162 3
a164 1
	int	ivec_resv[10];		/* (reserved) must be zero */
d176 33
a208 4
	/* [0x200] Reserved */
	u_int	resv1[84];		/* (reserved) */

	/* [0x350] Memory Configuration */
d212 1
a212 1
	u_int	memc_resv;		/* (reserved) */
d217 1
a217 1
	struct iomod *mem_hpa;		/* HPA of CPU */
@


1.6
log
@add HPPA_FLEX()
@
text
@d1 1
a1 1
/*	$OpenBSD: iomod.h,v 1.5 1999/02/25 17:25:09 mickey Exp $	*/
d127 2
a128 4
					/* powerfail recovery software */
	int	(*ivec_mempf)__P((void));
					/* exec'd after Transfer Of Control */
	int	(*ivec_toc)__P((void));
d130 1
a130 2
					/* exec'd after Rendezvous Signal */
	int	(*ivec_rendz)__P((void));
d136 1
a136 1
		int	pd_Resv1[112];	/* (reserved) processor dependent */
d138 1
a138 1
			int	v_Resv1[39];
d140 1
a140 1
			int	v_Resv2[72];
d145 1
a145 1
	int	resv1[84];		/* (reserved) */
d148 4
a151 4
	int	memc_cont;		/* bytes of contiguous valid memory */
	int	memc_phsize;		/* bytes of valid physical memory */
	int	memc_adsize;		/* bytes of SPA space used by PDC */
	int	memc_resv;		/* (reserved) */
d155 1
a155 1
	int	mem_free;		/* first free phys. memory location */
d162 3
a164 3
	int	imm_soft_boot;		/* 0 == hard boot, 1 == soft boot */
	int	imm_spa_size;		/* bytes of SPA in IMM */
	int	imm_max_mem;		/* bytes of mem in IMM (<= spa_size) */
d172 1
a172 1
	int	resv2[116];		/* (reserved) */
d175 1
a175 1
	int	pd_resv2[128];		/* (reserved) processor dependent */
d269 1
a269 1
	int	io_ii_rw;	/* read/clear external intrpt msg (bit-26) */
d273 1
a273 1
	int	io_dma_count;	/* (RO) number of bytes remaining to xfer */
d276 1
a276 1
	int	resv1[2];	/* (reserved) */
d287 1
a287 1
	int	resv2[2];	/* (reserved) */
d290 1
a290 1
	int	resv3[3];	/* (reserved) */
d296 1
a296 1
	int	priv_trs[160];	/* TRSes (Type-dependent Reg Sets) */
d298 1
a298 1
	int	priv_hvrs[320];	/* HVRSes (HVERSION-dependent Register Sets) */
d300 1
a300 1
	int	hvrs[512];	/* HVRSes (HVERSION-dependent Register Sets) */
@


1.6.4.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: iomod.h,v 1.8 2000/05/15 15:16:41 mickey Exp $	*/
a3 30
 * Copyright (c) 2000 Michael Shalayeff
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Michael Shalayeff.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR OR HIS RELATIVES BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */
/*
d127 4
a130 2
	int	(*ivec_mempf)__P((void)); /* powerfail recovery software */
	int	(*ivec_toc)__P((void));	/* exec'd after Transfer Of Control */
d132 2
a133 1
	int	(*ivec_rendz)__P((void)); /* exec'd after Rendezvous Signal */
d135 1
a135 3
	u_int	ivec_resv[2];		/* (reserved) */
	u_int	ivec_mbz;		/* must be zero */
	u_int	ivec_resv2[7];		/* (reserved) */
d139 1
a139 1
		u_int	pd_Resv1[112];	/* (reserved) processor dependent */
d141 1
a141 1
			u_int	v_Resv1[39];
d143 1
a143 1
			u_int	v_Resv2[72];
d147 8
a154 37
	/* [0x200] IODC Data Area Descriptors
		   use PDC_ALLOC to allocate these memory regions */
	u_int	iodc_cons_base;		/* */
	u_int	iodc_cons_size;		/* */
	u_int	iodc_kbrd_base;		/* */
	u_int	iodc_kbrd_size;		/* */
	u_int	iodc_boot_base;		/* */
	u_int	iodc_boot_size;		/* */

	/* [0x218] */
	u_int	resv1[0x41];

	/* [0x31C] Capability Flags */
	u_int	cap_flags;		/* system capabitlities */
#define	HPPA_CAP_WIDESCSI	0x00000001

	/* [0x320] Keyboard Extensions */
	u_int	kbrd_ext[2];

	/* [0x328] Boot Device Extensions */
	u_int	boot_ext[2];

	/* [0x330] Console/Display Extensions */
	u_int	cons_ext[2];

	/* [0x338] Initial Memory Module Extensions */
	u_int	imm_ext[2];

	/* [0x340] Memory Configuration */
	u_int	memc_cont_l;		/* memc_cont low part */
	u_int	memc_phsize_l;		/* memc_phsize low part */
	u_int	memc_adsize_l;		/* memc_adsize low part */
	u_int	memc_resv;		/* (reserved) */
	u_int	memc_cont;		/* bytes of contiguous valid memory */
	u_int	memc_phsize;		/* bytes of valid physical memory */
	u_int	memc_adsize;		/* bytes of SPA space used by PDC */
	u_int	memc_hpa_h;		/* HPA of CPU (high) */
d158 2
a159 2
	u_int	mem_free;		/* first free phys. memory location */
	u_int	mem_hpa;		/* HPA of CPU */
d165 3
a167 3
	u_int	imm_soft_boot;		/* 0 == hard boot, 1 == soft boot */
	u_int	imm_spa_size;		/* bytes of SPA in IMM */
	u_int	imm_max_mem;		/* bytes of mem in IMM (<= spa_size) */
d175 1
a175 1
	u_int	resv2[116];		/* (reserved) */
d178 1
a178 1
	u_int	pd_resv2[128];		/* (reserved) processor dependent */
d272 1
a272 1
	u_int	io_ii_rw;	/* read/clear external intrpt msg (bit-26) */
d276 1
a276 1
	u_int	io_dma_count;	/* (RO) number of bytes remaining to xfer */
d279 1
a279 1
	u_int	resv1[2];	/* (reserved) */
d290 1
a290 1
	u_int	resv2[2];	/* (reserved) */
d293 1
a293 1
	u_int	resv3[3];	/* (reserved) */
d299 1
a299 1
	u_int	priv_trs[160];	/* TRSes (Type-dependent Reg Sets) */
d301 1
a301 1
	u_int	priv_hvrs[320];	/* HVRSes (HVERSION-dependent Register Sets) */
d303 1
a303 1
	u_int	hvrs[512];	/* HVRSes (HVERSION-dependent Register Sets) */
@


1.6.4.2
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD: iomod.h,v 1.6.4.1 2001/04/18 16:06:25 niklas Exp $	*/
d128 3
@


1.6.4.3
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d154 2
a155 2
	int	(*ivec_mempf)(void);	/* powerfail recovery software */
	int	(*ivec_toc)(void);	/* exec'd after Transfer Of Control */
d157 1
a157 1
	int	(*ivec_rendz)(void);	/* exec'd after Rendezvous Signal */
d215 1
a215 1
	int	(*mem_pdc)(void);	/* PDC entry point */
@


1.6.4.4
log
@Sync the SMP branch with 3.3
@
text
@d4 1
a4 1
 * Copyright (c) 2000-2003 Michael Shalayeff
d428 4
@


1.6.4.5
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: iomod.h,v 1.6.4.4 2003/03/27 23:26:54 niklas Exp $	*/
a56 1
 *	Author: Jeff Forys (CSS), Dave Slattengren (mtXinu)
@


1.6.4.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d318 1
a318 1
 * The first 2K-bytes of registers are "privileged".
d400 2
a401 2
#define	IO_ERR_MORE	 8	/* device transferred more data than expected */
#define	IO_ERR_LESS	 9	/* device transferred less data than expected */
@


1.6.4.7
log
@Merge with the trunk
@
text
@d4 1
a4 1
 * Copyright (c) 2000-2004 Michael Shalayeff
d15 5
@


1.5
log
@comment iomod_command usage
@
text
@d1 1
a1 1
/*	$OpenBSD: iomod.h,v 1.4 1999/01/11 18:14:52 mickey Exp $	*/
d100 1
@


1.4
log
@ASP prom offset for an lan stattion id
@
text
@d1 1
a1 1
/*	$OpenBSD: iomod.h,v 1.3 1998/12/13 06:47:02 mickey Exp $	*/
a279 1
#define	iomod_command	(4*12)
d305 3
@


1.3
log
@define HPA region
@
text
@d1 1
a1 1
/*	$OpenBSD: iomod.h,v 1.2 1998/10/30 19:26:02 mickey Exp $	*/
d103 3
@


1.2
log
@remove unused definitions, cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: iomod.h,v 1.1 1998/06/23 19:45:23 mickey Exp $	*/
d76 2
@


1.1
log
@some includes
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d29 2
a30 2
#ifndef	_IOMOD_
#define	_IOMOD_
d99 5
a103 3
#if !defined(_LOCORE) && !defined(ASSEMBLER)
/*
 * Simplify typing for all these volatile things.
d105 3
a107 1
typedef	volatile char *			v_caddr;
d121 8
a128 5
	int	(*ivec_mempf)__P((void));	/* powerfail recovery software */
	int	(*ivec_toc)__P((void));		/* exec'd after Transfer Of Control */
	int	ivec_toclen;		/* bytes of ivec_toc code */
	int	(*ivec_rendz)__P((void));	/* exec'd after Rendezvous Signal */
	int	ivec_mempflen;		/* bytes of ivec_mempf code */
d154 1
a154 1
	int	(*mem_pdc)__P((void));		/* PDC entry point */
d275 1
d307 1
a307 1
	((v_caddr)		\
a365 45

/*
 * Before configuring the bus, we build a table which consists of
 * "useful information" on each module.  We then use this table to
 * allocate SPA's and reconfigure the bus.
 */

#define	MODTABSIZ MAXMODBUS	/* size of static I/O module table */

#if !defined(_LOCORE) && !defined(ASSEMBLER)
struct modtab {
	struct modtab	*mt_next;	/* pointer to next `modtab' entry */
	u_int		m_fixed;	/* fixed bus address */
	struct iodc_data mt_type;	/* type specific info from IODC */
	volatile struct iomod *m_hpa;	/* ptr to HPA */
	u_int		m_spa;		/* location of SPA */
	u_int		m_spasiz;	/* size of SPA */
	union {
		struct {		/* Memory module */
			u_int	M_memsiz;	/* size (m_memsiz) */
		} m_Mem;
		struct {		/* I/O module */
			u_int	M_cioeim;	/* EIM address (m_cioeim) */
			caddr_t	M_ciochain;	/* CIO chain RAM (m_ciochain) */
		} m_Io;
		struct {		/* Viper memory controller module */
			u_int	M_vi_eim;	/* EIM address (m_vi_eim) */
			u_int	M_vi_iwd;	/* EIM intr word (m_vi_iwd) */
		} m_Vi;
		union {			/* Foriegn I/O module */
			u_int	M_scsiclk;	/* SCSI: clock frequency */
			u_int	M_stirom;	/* GRF: location of STI ROM */
		} m_Fio;
	} m_Dep;
};

#define	m_memsiz	m_Dep.m_Mem.M_memsiz
#define	m_cioeim	m_Dep.m_Io.M_cioeim
#define	m_ciochain	m_Dep.m_Io.M_ciochain
#define	m_vi_eim	m_Dep.m_Vi.M_vi_eim
#define	m_vi_iwd	m_Dep.m_Vi.M_vi_iwd
#define m_scsiclk	m_Dep.m_Fio.M_scsiclk
#define m_stirom	m_Dep.m_Fio.M_stirom
#endif	/* !(_LOCORE || ASSEMBLER) */

d370 1
a370 1
#endif	/* _IOMOD_ */
@

