head	1.42;
access;
symbols
	OPENBSD_6_1_BASE:1.42
	OPENBSD_6_0:1.42.0.4
	OPENBSD_6_0_BASE:1.42
	OPENBSD_5_9:1.42.0.2
	OPENBSD_5_9_BASE:1.42
	OPENBSD_5_8:1.41.0.6
	OPENBSD_5_8_BASE:1.41
	OPENBSD_5_7:1.41.0.2
	OPENBSD_5_7_BASE:1.41
	OPENBSD_5_6:1.40.0.4
	OPENBSD_5_6_BASE:1.40
	OPENBSD_5_5:1.38.0.6
	OPENBSD_5_5_BASE:1.38
	OPENBSD_5_4:1.38.0.2
	OPENBSD_5_4_BASE:1.38
	OPENBSD_5_3:1.37.0.10
	OPENBSD_5_3_BASE:1.37
	OPENBSD_5_2:1.37.0.8
	OPENBSD_5_2_BASE:1.37
	OPENBSD_5_1_BASE:1.37
	OPENBSD_5_1:1.37.0.6
	OPENBSD_5_0:1.37.0.4
	OPENBSD_5_0_BASE:1.37
	OPENBSD_4_9:1.37.0.2
	OPENBSD_4_9_BASE:1.37
	OPENBSD_4_8:1.34.0.2
	OPENBSD_4_8_BASE:1.34
	OPENBSD_4_7:1.28.0.2
	OPENBSD_4_7_BASE:1.28
	OPENBSD_4_6:1.25.0.4
	OPENBSD_4_6_BASE:1.25
	OPENBSD_4_5:1.24.0.4
	OPENBSD_4_5_BASE:1.24
	OPENBSD_4_4:1.24.0.2
	OPENBSD_4_4_BASE:1.24
	OPENBSD_4_3:1.23.0.4
	OPENBSD_4_3_BASE:1.23
	OPENBSD_4_2:1.23.0.2
	OPENBSD_4_2_BASE:1.23
	OPENBSD_4_1:1.20.0.4
	OPENBSD_4_1_BASE:1.20
	OPENBSD_4_0:1.20.0.2
	OPENBSD_4_0_BASE:1.20
	OPENBSD_3_9:1.19.0.4
	OPENBSD_3_9_BASE:1.19
	OPENBSD_3_8:1.19.0.2
	OPENBSD_3_8_BASE:1.19
	OPENBSD_3_7:1.18.0.2
	OPENBSD_3_7_BASE:1.18
	OPENBSD_3_6:1.17.0.2
	OPENBSD_3_6_BASE:1.17
	SMP_SYNC_A:1.17
	SMP_SYNC_B:1.17
	OPENBSD_3_5:1.16.0.2
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.14.0.4
	OPENBSD_3_4_BASE:1.14
	UBC_SYNC_A:1.14
	OPENBSD_3_3:1.14.0.2
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.13.0.2
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.12.0.2
	OPENBSD_3_1_BASE:1.12
	UBC_SYNC_B:1.13
	UBC:1.11.0.4
	UBC_BASE:1.11
	OPENBSD_3_0:1.11.0.2
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9:1.10.0.2
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_8:1.9.0.2
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.8.0.6
	OPENBSD_2_7_BASE:1.8
	SMP:1.8.0.4
	SMP_BASE:1.8
	kame_19991208:1.8
	OPENBSD_2_6:1.8.0.2
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.7.0.2
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.3.0.2
	OPENBSD_2_4_BASE:1.3;
locks; strict;
comment	@ * @;


1.42
date	2015.09.13.14.58.20;	author kettenis;	state Exp;
branches;
next	1.41;
commitid	i9UZOLCV7gZqx23M;

1.41
date	2015.02.11.01.55.40;	author dlg;	state Exp;
branches;
next	1.40;
commitid	1h4it0dOUW25xHFq;

1.40
date	2014.06.03.13.30.24;	author kettenis;	state Exp;
branches;
next	1.39;
commitid	F6Vr6D6paSMhKsGL;

1.39
date	2014.03.29.18.09.29;	author guenther;	state Exp;
branches;
next	1.38;

1.38
date	2013.05.17.19.38.51;	author kettenis;	state Exp;
branches;
next	1.37;

1.37
date	2011.01.14.13.20.06;	author jsing;	state Exp;
branches;
next	1.36;

1.36
date	2011.01.14.13.09.45;	author jsing;	state Exp;
branches;
next	1.35;

1.35
date	2010.12.21.14.56.23;	author claudio;	state Exp;
branches;
next	1.34;

1.34
date	2010.07.02.00.00.45;	author jsing;	state Exp;
branches;
next	1.33;

1.33
date	2010.07.01.03.38.50;	author jsing;	state Exp;
branches;
next	1.32;

1.32
date	2010.06.08.12.33.30;	author jsing;	state Exp;
branches;
next	1.31;

1.31
date	2010.05.21.15.24.29;	author jsing;	state Exp;
branches;
next	1.30;

1.30
date	2010.04.23.03.50.22;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2010.04.19.16.32.53;	author jsing;	state Exp;
branches;
next	1.28;

1.28
date	2009.12.31.13.22.02;	author jsing;	state Exp;
branches;
next	1.27;

1.27
date	2009.12.31.12.52.35;	author jsing;	state Exp;
branches;
next	1.26;

1.26
date	2009.12.29.13.11.40;	author jsing;	state Exp;
branches;
next	1.25;

1.25
date	2009.03.15.19.40.40;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2008.04.27.14.36.38;	author kettenis;	state Exp;
branches;
next	1.23;

1.23
date	2007.05.16.19.37.06;	author thib;	state Exp;
branches;
next	1.22;

1.22
date	2007.05.14.19.54.21;	author martin;	state Exp;
branches;
next	1.21;

1.21
date	2007.04.26.20.52.48;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2006.03.12.03.14.36;	author brad;	state Exp;
branches;
next	1.19;

1.19
date	2005.04.19.15.29.47;	author mickey;	state Exp;
branches;
next	1.18;

1.18
date	2004.09.15.21.28.34;	author mickey;	state Exp;
branches;
next	1.17;

1.17
date	2004.04.07.18.24.19;	author mickey;	state Exp;
branches;
next	1.16;

1.16
date	2003.12.24.01.24.15;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	2003.10.15.17.43.48;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	2002.12.17.21.54.25;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	2002.04.29.07.35.18;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2002.02.05.05.12.27;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	2001.06.24.17.05.36;	author miod;	state Exp;
branches
	1.11.4.1;
next	1.10;

1.10
date	2001.01.29.00.01.58;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	2000.07.06.15.25.03;	author ho;	state Exp;
branches;
next	1.8;

1.8
date	99.08.14.03.36.11;	author mickey;	state Exp;
branches
	1.8.4.1;
next	1.7;

1.7
date	99.02.25.17.27.57;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	98.12.23.17.53.54;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	98.12.05.17.42.10;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	98.11.23.03.32.19;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	98.07.14.17.47.28;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	98.07.07.21.32.41;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	98.06.23.19.45.22;	author mickey;	state Exp;
branches;
next	;

1.8.4.1
date	2001.04.18.16.06.24;	author niklas;	state Exp;
branches;
next	1.8.4.2;

1.8.4.2
date	2001.07.04.10.16.10;	author niklas;	state Exp;
branches;
next	1.8.4.3;

1.8.4.3
date	2002.03.06.00.57.22;	author niklas;	state Exp;
branches;
next	1.8.4.4;

1.8.4.4
date	2003.03.27.23.26.54;	author niklas;	state Exp;
branches;
next	1.8.4.5;

1.8.4.5
date	2004.02.19.10.48.40;	author niklas;	state Exp;
branches;
next	1.8.4.6;

1.8.4.6
date	2004.06.05.23.10.49;	author niklas;	state Exp;
branches;
next	;

1.11.4.1
date	2002.06.11.03.35.37;	author art;	state Exp;
branches;
next	1.11.4.2;

1.11.4.2
date	2003.05.19.21.49.41;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.42
log
@intr_barrier(9) for hppa.
@
text
@/*	$OpenBSD: intr.h,v 1.41 2015/02/11 01:55:40 dlg Exp $	*/

/*
 * Copyright (c) 2002-2004 Michael Shalayeff
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR OR HIS RELATIVES BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef _MACHINE_INTR_H_
#define _MACHINE_INTR_H_

#include <machine/psl.h>

#define	CPU_NINTS	32
#define	NIPL		17

#define	IPL_NONE	0
#define	IPL_SOFTCLOCK	1
#define	IPL_SOFTNET	2
#define	IPL_BIO		3
#define	IPL_NET		4
#define	IPL_SOFTTTY	5
#define	IPL_TTY		6
#define	IPL_VM		7
#define	IPL_AUDIO	8
#define	IPL_CLOCK	9
#define	IPL_STATCLOCK	10
#define	IPL_SCHED	10
#define	IPL_HIGH	10
#define	IPL_IPI		11
#define	IPL_NESTED	12	/* pseudo-level for sub-tables */

#define	IPL_MPSAFE	0	/* no "mpsafe" interrupts */

#define	IST_NONE	0
#define	IST_PULSE	1
#define	IST_EDGE	2
#define	IST_LEVEL	3

#ifdef MULTIPROCESSOR
#define	HPPA_IPI_NOP		0
#define	HPPA_IPI_HALT		1
#define	HPPA_IPI_FPU_SAVE	2
#define	HPPA_IPI_FPU_FLUSH	3
#define	HPPA_NIPI		4
#endif

#if !defined(_LOCORE) && defined(_KERNEL)

extern volatile u_long imask[NIPL];

#ifdef DIAGNOSTIC
void splassert_fail(int, int, const char *);
extern int splassert_ctl;
void splassert_check(int, const char *);
#define splassert(__wantipl) do {			\
	if (splassert_ctl > 0) {			\
		splassert_check(__wantipl, __func__);	\
	}						\
} while (0)
#define splsoftassert(__wantipl) splassert(__wantipl)
#else
#define	splassert(__wantipl)		do { /* nada */ } while (0)
#define	splsoftassert(__wantipl)	do { /* nada */ } while (0)
#endif /* DIAGNOSTIC */

void	cpu_intr_init(void);
void	cpu_intr(void *);

void	intr_barrier(void *);

static __inline int
spllower(int ncpl)
{
	register int ocpl asm("r28") = ncpl;
	__asm volatile("copy  %0, %%arg0\n\tbreak %1, %2"
	    : "+r" (ocpl) : "i" (HPPA_BREAK_KERNEL), "i" (HPPA_BREAK_SPLLOWER)
	    : "r26", "memory");
	return (ocpl);
}

static __inline int
splraise(int ncpl)
{
	struct cpu_info *ci = curcpu();
	int ocpl = ci->ci_cpl;

	if (ocpl < ncpl)
		ci->ci_cpl = ncpl;
	__asm volatile ("sync" : : : "memory");

	return (ocpl);
}

static __inline void
splx(int ncpl)
{
	(void)spllower(ncpl);
}

static __inline register_t
hppa_intr_disable(void)
{
	register_t eiem;

	__asm volatile("mfctl %%cr15, %0": "=r" (eiem));
	__asm volatile("mtctl %r0, %cr15");

	return eiem;
}

static __inline void
hppa_intr_enable(register_t eiem)
{
	__asm volatile("mtctl %0, %%cr15":: "r" (eiem));
}

#define	splsoftclock()	splraise(IPL_SOFTCLOCK)
#define	splsoftnet()	splraise(IPL_SOFTNET)
#define	splbio()	splraise(IPL_BIO)
#define	splnet()	splraise(IPL_NET)
#define	splsofttty()	splraise(IPL_SOFTTTY)
#define	spltty()	splraise(IPL_TTY)
#define	splvm()		splraise(IPL_VM)
#define	splaudio()	splraise(IPL_AUDIO)
#define	splclock()	splraise(IPL_CLOCK)
#define	splsched()	splraise(IPL_SCHED)
#define	splstatclock()	splraise(IPL_STATCLOCK)
#define	splhigh()	splraise(IPL_HIGH)
#define	splipi()	splraise(IPL_IPI)
#define	spl0()		spllower(IPL_NONE)

#define	SOFTINT_MASK ((1 << (IPL_SOFTCLOCK - 1)) | \
    (1 << (IPL_SOFTNET - 1)) | (1 << (IPL_SOFTTTY - 1)))

#ifdef MULTIPROCESSOR
void	 hppa_ipi_init(struct cpu_info *);
int	 hppa_ipi_send(struct cpu_info *, u_long);
int	 hppa_ipi_broadcast(u_long);
#endif

#define	setsoftast(p)	(p->p_md.md_astpending = 1)

void	*softintr_establish(int, void (*)(void *), void *);
void	 softintr_disestablish(void *);
void	 softintr_schedule(void *);

#ifdef MULTIPROCESSOR
void	 hppa_ipi_init(struct cpu_info *);
int	 hppa_ipi_intr(void *arg);
int	 hppa_ipi_send(struct cpu_info *, u_long);
#endif

#endif /* !_LOCORE && _KERNEL */
#endif /* _MACHINE_INTR_H_ */
@


1.41
log
@intr.c needs atomic.h for atomic_setbits_int to say softints are pending.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.40 2014/06/03 13:30:24 kettenis Exp $	*/
d89 2
@


1.40
log
@Use a proper compiler barrier; just having the inline asm for the "sync"
instruction depend on ci->ci_cpl makes the compiler generate strange code
and might not be enough to stop the compiler moving instructions around.

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.39 2014/03/29 18:09:29 guenther Exp $	*/
a149 2

#define	softintr(mask)	atomic_setbits_long(&curcpu()->ci_ipending, mask)
@


1.39
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.38 2013/05/17 19:38:51 kettenis Exp $	*/
d108 1
a108 1
	__asm volatile ("sync" : "+r" (ci->ci_cpl));
@


1.38
log
@Add a dummy IPL_MPSAFE definition.

ok miod@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.37 2011/01/14 13:20:06 jsing Exp $	*/
d94 1
a94 1
	__asm __volatile("copy  %0, %%arg0\n\tbreak %1, %2"
d108 1
a108 1
	__asm __volatile ("sync" : "+r" (ci->ci_cpl));
d124 2
a125 2
	__asm __volatile("mfctl %%cr15, %0": "=r" (eiem));
	__asm __volatile("mtctl %r0, %cr15");
d133 1
a133 1
	__asm __volatile("mtctl %0, %%cr15":: "r" (eiem));
@


1.37
log
@Implement a function to broadcast IPIs to all running CPUs.

ok kettenis@@ deraadt@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.36 2011/01/14 13:09:45 jsing Exp $	*/
d52 2
@


1.36
log
@Provide an IPI to halt a CPU.

ok kettenis@@ deraadt@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.35 2010/12/21 14:56:23 claudio Exp $	*/
d157 1
@


1.35
log
@Convert netisr to a normal soft interrupt instead of hanving MD code
for it. This makes the netisr a real C function which will help further
development. No noticable performance change on i386 and amd64.
With input from kettenis@@ and miod@@ additional OKs mikeb@@ and henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.34 2010/07/02 00:00:45 jsing Exp $	*/
d60 4
a63 3
#define	HPPA_IPI_FPU_SAVE	1
#define	HPPA_IPI_FPU_FLUSH	2
#define	HPPA_NIPI		3
@


1.34
log
@Implement FPU shootdowns for hppa multiprocessor kernels. There are still
some subtle bugs however these can be fixed in tree.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.33 2010/07/01 03:38:50 jsing Exp $	*/
a158 1
#define	setsoftnet()	softintr(1 << (IPL_SOFTNET - 1))
@


1.33
log
@Include atomic.h via lock.h like other architectures do.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.32 2010/06/08 12:33:30 jsing Exp $	*/
d60 3
a62 2

#define	HPPA_NIPI		1
d152 5
@


1.32
log
@Add missing function prototype.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.29 2010/04/19 16:32:53 jsing Exp $	*/
a64 2

#include <machine/atomic.h>
@


1.31
log
@Add support for IPIs on hppa.

ok kettenis@@
@
text
@d163 1
@


1.30
log
@Make sure IPL_SCHED is always defined by MD headers, instead of having a MI
fallback definition in <sys/sched.h>, so that there is no hidden include
ordering requirement between <machine/intr.h> and <sys/sched.h>.
ok deraadt@@ tedu@@
@
text
@d35 1
a35 1
#define	NIPL		16
d50 2
a51 1
#define	IPL_NESTED	11	/* pseudo-level for sub-tables */
d58 6
d146 1
d160 5
@


1.29
log
@Make ipending a per-CPU value.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.27 2009/12/31 12:52:35 jsing Exp $	*/
d48 1
@


1.28
log
@Implement wrappers for enabling and disabling interrupts.

ok miod@@
@
text
@d60 1
a60 1
extern volatile u_long ipending, imask[NIPL];
d140 1
a140 1
#define	softintr(mask)	atomic_setbits_long(&ipending, mask)
@


1.27
log
@Make cpl and cpu_inintr per CPU variables. For locore.S, cpl becomes an
offset within cpu_primary_info - this will need to be revisited shortly.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.26 2009/12/29 13:11:40 jsing Exp $	*/
d107 17
@


1.26
log
@Move hppa to per process AST.

ok kettenis@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.24 2008/04/27 14:36:38 kettenis Exp $	*/
a59 1
extern volatile int cpl;
d93 2
a94 1
	int ocpl = cpl;
d97 2
a98 2
		cpl = ncpl;
	__asm __volatile ("sync" : "+r" (cpl));
@


1.25
log
@Introduce splsoftassert(), similar to splassert() but for soft interrupt
levels. This will allow for platforms where soft interrupt levels do not
map to real hardware interrupt levels to have soft ipl values overlapping
hard ipl values without breaking spl asserts.
@
text
@a61 1
extern int astpending;
d128 1
a128 1
#define	setsoftast()	(astpending = 1)
@


1.24
log
@Move hppa to __HAVE_GENERIC_SOFT_INTERRUPTS
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.23 2007/05/16 19:37:06 thib Exp $	*/
d73 1
d75 2
a76 1
#define	splassert(__wantipl)	do { /* nada */ } while (0)
@


1.23
log
@splassert_ctl defaults to 1 now, so dont wrap the checks for
splassert_ctl > 0 in __predict_false().

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.22 2007/05/14 19:54:21 martin Exp $	*/
a127 1
#define	setsoftclock()	softintr(1 << (IPL_SOFTCLOCK - 1))
d129 4
a132 1
#define	setsofttty()	softintr(1 << (IPL_SOFTTTY - 1))
@


1.22
log
@move hppa to __HAVE_CPUINFO

input from miod@@, ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.21 2007/04/26 20:52:48 miod Exp $	*/
d69 1
a69 1
	if (__predict_false(splassert_ctl > 0)) {	\
@


1.21
log
@Proper atomic_{set,clear}bits_{int,long} implementation, and use it for
softintr(); ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.20 2006/03/12 03:14:36 brad Exp $	*/
d117 1
@


1.20
log
@remove splimp.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.19 2005/04/19 15:29:47 mickey Exp $	*/
d58 2
d121 1
a121 10
static __inline void
softintr(u_long mask)
{
	register_t eiem;

	__asm __volatile("mfctl	%%cr15, %0": "=r" (eiem));
	__asm __volatile("mtctl	%r0, %cr15");
	ipending |= mask;
	__asm __volatile("mtctl	%0, %%cr15":: "r" (eiem));
}
@


1.19
log
@nothing uses spllowersoftclock() anymore
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.18 2004/09/15 21:28:34 mickey Exp $	*/
a112 1
#define	splimp()	splvm()
@


1.18
log
@force ordering in splraise
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.17 2004/04/07 18:24:19 mickey Exp $	*/
a105 1
#define	spllowersoftclock() spllower(IPL_SOFTCLOCK)
@


1.17
log
@update copyright; miod@@ is fine w/ files where he holds it too
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.16 2003/12/24 01:24:15 mickey Exp $	*/
d95 1
a95 1
	__asm __volatile ("nop" : "+r" (cpl));
@


1.16
log
@kill unused define
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.15 2003/10/15 17:43:48 mickey Exp $	*/
d4 1
a4 1
 * Copyright (c) 2002 Michael Shalayeff
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Michael Shalayeff.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.15
log
@do not define IPL_IMP
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.14 2002/12/17 21:54:25 mickey Exp $	*/
a39 1
#define	CPU_INTITMR	0x80000000
@


1.14
log
@real interrupts/spl framework.
tested on 712/* 715/100, 715/33 which main cpu/bus types.
miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a50 1
#define	IPL_IMP		IPL_VM
d119 2
a120 2
#define	splvm()		splimp()
#define	splimp()	splraise(IPL_IMP)
d123 1
a124 1
#define	splstatclock()	splhigh()
@


1.13
log
@Define placeholders for art's splassert() debugging stuff on all arches.
Currently as no-ops everywhere.

ok art@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.12 2002/02/05 05:12:27 mickey Exp $	*/
d3 2
a4 3
/* 
 * Copyright (c) 1990,1991,1992,1994 The University of Utah and
 * the Computer Systems Laboratory at the University of Utah (CSL).
d7 13
a19 11
 * Permission to use, copy, modify and distribute this software is hereby
 * granted provided that (1) source code retains these copyright, permission,
 * and disclaimer notices, and (2) redistributions including binaries
 * reproduce the notices in supporting documentation, and (3) all advertising
 * materials mentioning features or use of this software display the following
 * acknowledgement: ``This product includes software developed by the
 * Computer Systems Laboratory at the University of Utah.''
 *
 * THE UNIVERSITY OF UTAH AND CSL ALLOW FREE USE OF THIS SOFTWARE IN ITS "AS
 * IS" CONDITION.  THE UNIVERSITY OF UTAH AND CSL DISCLAIM ANY LIABILITY OF
 * ANY KIND FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
d21 11
a31 5
 * CSL requests users of this software to return to csl-dist@@cs.utah.edu any
 * improvements that they make and grant CSL redistribution rights.
 *
 * 	Utah $Hdr: machspl.h 1.16 94/12/14$
 *	Author: Jeff Forys, Bob Wheeler, University of Utah CSL
d34 2
a35 2
#ifndef	_MACHINE_INTR_H_
#define	_MACHINE_INTR_H_
d40 2
a41 1
#define	CPU_INTITMR	(0x80000000)
d43 14
a56 7
#define	IPL_NONE	(0xffffffff)
#define	IPL_BIO		(0x80000000)
#define	IPL_NET		(0x80000000)
#define	IPL_TTY		(0x80000000)
#define	IPL_IO		(IPL_BIO|IPL_NET|IPL_TTY)
#define	IPL_CLOCK	(0)
#define	IPL_HIGH	(0)
d63 1
a63 4
#if !defined(_LOCORE)

/* SPL asserts */
#define	splassert(wantipl)	/* nothing */
d65 2
a66 43
/*
 * Define the machine-independent SPL routines in terms of splx().
 */
#define splraise(splhval)	({					\
	register u_int _ctl_r;						\
	__asm __volatile("mfctl	%%cr15,%0\n\t"				\
			 "mtctl	%1,%%cr15"				\
			: "=&r" (_ctl_r): "r" (splhval));		\
	_ctl_r;								\
})

#define spllower(spllval)	({					\
	register u_int _ctl_r;						\
	__asm __volatile("mfctl	%%cr15,%0\n\t"				\
			 "mtctl	%1,%%cr15"				\
			: "=&r" (_ctl_r): "r" (spllval));		\
	_ctl_r;								\
})

#define	splx(splval)		({					\
	register u_int _ctl_r;						\
	__asm __volatile("mfctl   %%cr15,%0\n\t"			\
			 "mtctl   %1,%%cr15\n\t"			\
			 : "=&r" (_ctl_r): "r" (splval));		\
	_ctl_r;								\
})

#define	spl0()			spllower(IPL_NONE)
#define	splsoft()		spllower(IPL_CLOCK)
#define	splsoftnet()		splsoft()
#define	spllowersoftclock()	splsoft()
#define	splsoftclock()		splsoft()
#define	splbio()		spllower(IPL_BIO)
#define	splnet()		spllower(IPL_NET)
#define	spltty()		spllower(IPL_TTY)
#define	splimp()		spllower(IPL_CLOCK)
#define	splclock()		spllower(IPL_CLOCK)
#define	splstatclock()		spllower(IPL_CLOCK)
#define	splvm()			spllower(IPL_CLOCK)
#define	splhigh()		splraise(IPL_HIGH)

/* software interrupt register */
extern u_int32_t sir;
d69 77
a145 6
#define	SIR_CLOCK	0x01
#define	SIR_NET		0x02

#define	setsoftclock()		(sir |= SIR_CLOCK)
#define	setsoftnet()		(sir |= SIR_NET)
#define	setsoftast()		(astpending = 1)
d147 2
a148 2
#endif	/* !_LOCORE */
#endif	/* _MACHINE_INTR_H_ */
@


1.12
log
@redo the spl*() names
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.11 2001/06/24 17:05:36 miod Exp $	*/
d49 4
@


1.11
log
@Define splvm() for arches who don't already provide it, with the same
definition as splimp().
art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.10 2001/01/29 00:01:58 mickey Exp $	*/
d52 1
a52 1
#define __splhigh(splhval)	({					\
d60 1
a60 1
#define __spllow(spllval)	({					\
d76 2
a77 2
#define	spl0()			__spllow(IPL_NONE)
#define	splsoft()		__spllow(IPL_CLOCK)
d81 8
a88 8
#define	splbio()		__spllow(IPL_BIO)
#define	splnet()		__spllow(IPL_NET)
#define	spltty()		__spllow(IPL_TTY)
#define	splimp()		__spllow(IPL_CLOCK)
#define	splclock()		__spllow(IPL_CLOCK)
#define	splstatclock()		__spllow(IPL_CLOCK)
#define	splvm()			__spllow(IPL_CLOCK)
#define	splhigh()		__splhigh(IPL_HIGH)
@


1.11.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.11 2001/06/24 17:05:36 miod Exp $	*/
a48 4

/* SPL asserts */
#define	splassert(wantipl)	/* nothing */

d52 1
a52 1
#define splraise(splhval)	({					\
d60 1
a60 1
#define spllower(spllval)	({					\
d76 2
a77 2
#define	spl0()			spllower(IPL_NONE)
#define	splsoft()		spllower(IPL_CLOCK)
d81 8
a88 8
#define	splbio()		spllower(IPL_BIO)
#define	splnet()		spllower(IPL_NET)
#define	spltty()		spllower(IPL_TTY)
#define	splimp()		spllower(IPL_CLOCK)
#define	splclock()		spllower(IPL_CLOCK)
#define	splstatclock()		spllower(IPL_CLOCK)
#define	splvm()			spllower(IPL_CLOCK)
#define	splhigh()		splraise(IPL_HIGH)
@


1.11.4.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d3 3
a5 2
/*
 * Copyright (c) 2002 Michael Shalayeff
d8 11
a18 13
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Michael Shalayeff.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d20 5
a24 11
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR OR HIS RELATIVES BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
d27 2
a28 2
#ifndef _MACHINE_INTR_H_
#define _MACHINE_INTR_H_
d33 1
a33 2
#define	CPU_INTITMR	0x80000000
#define	NIPL		16
d35 7
a41 14
#define	IPL_NONE	0
#define	IPL_SOFTCLOCK	1
#define	IPL_SOFTNET	2
#define	IPL_BIO		3
#define	IPL_NET		4
#define	IPL_SOFTTTY	5
#define	IPL_TTY		6
#define	IPL_VM		7
#define	IPL_IMP		IPL_VM
#define	IPL_AUDIO	8
#define	IPL_CLOCK	9
#define	IPL_STATCLOCK	10
#define	IPL_HIGH	10
#define	IPL_NESTED	11	/* pseudo-level for sub-tables */
d48 4
a51 1
#if !defined(_LOCORE) && defined(_KERNEL)
d53 43
a95 2
extern volatile int cpl;
extern volatile u_long ipending, imask[NIPL];
d98 6
a103 77
#ifdef DIAGNOSTIC
void splassert_fail(int, int, const char *);
extern int splassert_ctl;
void splassert_check(int, const char *);
#define splassert(__wantipl) do {			\
	if (__predict_false(splassert_ctl > 0)) {	\
		splassert_check(__wantipl, __func__);	\
	}						\
} while (0)
#else
#define	splassert(__wantipl)	do { /* nada */ } while (0)
#endif /* DIAGNOSTIC */

void	cpu_intr_init(void);
void	cpu_intr(void *);

static __inline int
spllower(int ncpl)
{
	register int ocpl asm("r28") = ncpl;
	__asm __volatile("copy  %0, %%arg0\n\tbreak %1, %2"
	    : "+r" (ocpl) : "i" (HPPA_BREAK_KERNEL), "i" (HPPA_BREAK_SPLLOWER)
	    : "r26", "memory");
	return (ocpl);
}

static __inline int
splraise(int ncpl)
{
	int ocpl = cpl;

	if (ocpl < ncpl)
		cpl = ncpl;
	__asm __volatile ("nop" : "+r" (cpl));

	return (ocpl);
}

static __inline void
splx(int ncpl)
{
	(void)spllower(ncpl);
}

#define	spllowersoftclock() spllower(IPL_SOFTCLOCK)
#define	splsoftclock()	splraise(IPL_SOFTCLOCK)
#define	splsoftnet()	splraise(IPL_SOFTNET)
#define	splbio()	splraise(IPL_BIO)
#define	splnet()	splraise(IPL_NET)
#define	splsofttty()	splraise(IPL_SOFTTTY)
#define	spltty()	splraise(IPL_TTY)
#define	splvm()		splimp()
#define	splimp()	splraise(IPL_IMP)
#define	splaudio()	splraise(IPL_AUDIO)
#define	splclock()	splraise(IPL_CLOCK)
#define	splhigh()	splraise(IPL_HIGH)
#define	splstatclock()	splhigh()
#define	spl0()		spllower(IPL_NONE)

static __inline void
softintr(u_long mask)
{
	register_t eiem;

	__asm __volatile("mfctl	%%cr15, %0": "=r" (eiem));
	__asm __volatile("mtctl	%r0, %cr15");
	ipending |= mask;
	__asm __volatile("mtctl	%0, %%cr15":: "r" (eiem));
}

#define	SOFTINT_MASK ((1 << (IPL_SOFTCLOCK - 1)) | \
    (1 << (IPL_SOFTNET - 1)) | (1 << (IPL_SOFTTTY - 1)))

#define	setsoftast()	(astpending = 1)
#define	setsoftclock()	softintr(1 << (IPL_SOFTCLOCK - 1))
#define	setsoftnet()	softintr(1 << (IPL_SOFTNET - 1))
#define	setsofttty()	softintr(1 << (IPL_SOFTTTY - 1))
d105 2
a106 2
#endif /* !_LOCORE && _KERNEL */
#endif /* _MACHINE_INTR_H_ */
@


1.10
log
@implement a few macros in cpu.h; pointer out by miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.9 2000/07/06 15:25:03 ho Exp $	*/
d87 1
@


1.9
log
@Add spllowersoftclock(), same as splsoftclock(). (art@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.8 1999/08/14 03:36:11 mickey Exp $	*/
d91 1
d98 1
@


1.8
log
@proper ipl values.
spl's do not mask Ibit anymore, prevent int lossage.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.7 1999/02/25 17:27:57 mickey Exp $	*/
d76 12
a87 11
#define	spl0()		__spllow(IPL_NONE)
#define	splsoft()	__spllow(IPL_CLOCK)
#define	splsoftnet()	splsoft()
#define	splsoftclock()	splsoft()
#define	splbio()	__spllow(IPL_BIO)
#define	splnet()	__spllow(IPL_NET)
#define	spltty()	__spllow(IPL_TTY)
#define	splimp()	__spllow(IPL_CLOCK)
#define	splclock()	__spllow(IPL_CLOCK)
#define	splstatclock()	__spllow(IPL_CLOCK)
#define	splhigh()	__splhigh(IPL_HIGH)
@


1.8.4.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.10 2001/01/29 00:01:58 mickey Exp $	*/
d76 11
a86 12
#define	spl0()			__spllow(IPL_NONE)
#define	splsoft()		__spllow(IPL_CLOCK)
#define	splsoftnet()		splsoft()
#define	spllowersoftclock()	splsoft()
#define	splsoftclock()		splsoft()
#define	splbio()		__spllow(IPL_BIO)
#define	splnet()		__spllow(IPL_NET)
#define	spltty()		__spllow(IPL_TTY)
#define	splimp()		__spllow(IPL_CLOCK)
#define	splclock()		__spllow(IPL_CLOCK)
#define	splstatclock()		__spllow(IPL_CLOCK)
#define	splhigh()		__splhigh(IPL_HIGH)
a89 1
extern int astpending;
a95 1
#define	setsoftast()		(astpending = 1)
@


1.8.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.8.4.1 2001/04/18 16:06:24 niklas Exp $	*/
a86 1
#define	splvm()			__spllow(IPL_CLOCK)
@


1.8.4.3
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d52 1
a52 1
#define splraise(splhval)	({					\
d60 1
a60 1
#define spllower(spllval)	({					\
d76 2
a77 2
#define	spl0()			spllower(IPL_NONE)
#define	splsoft()		spllower(IPL_CLOCK)
d81 8
a88 8
#define	splbio()		spllower(IPL_BIO)
#define	splnet()		spllower(IPL_NET)
#define	spltty()		spllower(IPL_TTY)
#define	splimp()		spllower(IPL_CLOCK)
#define	splclock()		spllower(IPL_CLOCK)
#define	splstatclock()		spllower(IPL_CLOCK)
#define	splvm()			spllower(IPL_CLOCK)
#define	splhigh()		splraise(IPL_HIGH)
@


1.8.4.4
log
@Sync the SMP branch with 3.3
@
text
@d3 3
a5 2
/*
 * Copyright (c) 2002 Michael Shalayeff
d8 14
a21 13
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Michael Shalayeff.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d23 2
a24 11
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR OR HIS RELATIVES BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
d27 2
a28 2
#ifndef _MACHINE_INTR_H_
#define _MACHINE_INTR_H_
d33 1
a33 2
#define	CPU_INTITMR	0x80000000
#define	NIPL		16
d35 7
a41 14
#define	IPL_NONE	0
#define	IPL_SOFTCLOCK	1
#define	IPL_SOFTNET	2
#define	IPL_BIO		3
#define	IPL_NET		4
#define	IPL_SOFTTTY	5
#define	IPL_TTY		6
#define	IPL_VM		7
#define	IPL_IMP		IPL_VM
#define	IPL_AUDIO	8
#define	IPL_CLOCK	9
#define	IPL_STATCLOCK	10
#define	IPL_HIGH	10
#define	IPL_NESTED	11	/* pseudo-level for sub-tables */
d48 41
a88 1
#if !defined(_LOCORE) && defined(_KERNEL)
d90 2
a91 2
extern volatile int cpl;
extern volatile u_long ipending, imask[NIPL];
d94 6
a99 77
#ifdef DIAGNOSTIC
void splassert_fail(int, int, const char *);
extern int splassert_ctl;
void splassert_check(int, const char *);
#define splassert(__wantipl) do {			\
	if (__predict_false(splassert_ctl > 0)) {	\
		splassert_check(__wantipl, __func__);	\
	}						\
} while (0)
#else
#define	splassert(__wantipl)	do { /* nada */ } while (0)
#endif /* DIAGNOSTIC */

void	cpu_intr_init(void);
void	cpu_intr(void *);

static __inline int
spllower(int ncpl)
{
	register int ocpl asm("r28") = ncpl;
	__asm __volatile("copy  %0, %%arg0\n\tbreak %1, %2"
	    : "+r" (ocpl) : "i" (HPPA_BREAK_KERNEL), "i" (HPPA_BREAK_SPLLOWER)
	    : "r26", "memory");
	return (ocpl);
}

static __inline int
splraise(int ncpl)
{
	int ocpl = cpl;

	if (ocpl < ncpl)
		cpl = ncpl;
	__asm __volatile ("nop" : "+r" (cpl));

	return (ocpl);
}

static __inline void
splx(int ncpl)
{
	(void)spllower(ncpl);
}

#define	spllowersoftclock() spllower(IPL_SOFTCLOCK)
#define	splsoftclock()	splraise(IPL_SOFTCLOCK)
#define	splsoftnet()	splraise(IPL_SOFTNET)
#define	splbio()	splraise(IPL_BIO)
#define	splnet()	splraise(IPL_NET)
#define	splsofttty()	splraise(IPL_SOFTTTY)
#define	spltty()	splraise(IPL_TTY)
#define	splvm()		splimp()
#define	splimp()	splraise(IPL_IMP)
#define	splaudio()	splraise(IPL_AUDIO)
#define	splclock()	splraise(IPL_CLOCK)
#define	splhigh()	splraise(IPL_HIGH)
#define	splstatclock()	splhigh()
#define	spl0()		spllower(IPL_NONE)

static __inline void
softintr(u_long mask)
{
	register_t eiem;

	__asm __volatile("mfctl	%%cr15, %0": "=r" (eiem));
	__asm __volatile("mtctl	%r0, %cr15");
	ipending |= mask;
	__asm __volatile("mtctl	%0, %%cr15":: "r" (eiem));
}

#define	SOFTINT_MASK ((1 << (IPL_SOFTCLOCK - 1)) | \
    (1 << (IPL_SOFTNET - 1)) | (1 << (IPL_SOFTTTY - 1)))

#define	setsoftast()	(astpending = 1)
#define	setsoftclock()	softintr(1 << (IPL_SOFTCLOCK - 1))
#define	setsoftnet()	softintr(1 << (IPL_SOFTNET - 1))
#define	setsofttty()	softintr(1 << (IPL_SOFTTTY - 1))
d101 2
a102 2
#endif /* !_LOCORE && _KERNEL */
#endif /* _MACHINE_INTR_H_ */
@


1.8.4.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d40 1
d51 1
d120 2
a121 2
#define	splvm()		splraise(IPL_VM)
#define	splimp()	splvm()
a123 1
#define	splstatclock()	splraise(IPL_STATCLOCK)
d125 1
@


1.8.4.6
log
@Merge with the trunk
@
text
@d4 1
a4 1
 * Copyright (c) 2002-2004 Michael Shalayeff
d15 5
@


1.7
log
@better __splhigh(); define INT_NONE for 'no ints allowed'
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.6 1998/12/23 17:53:54 mickey Exp $	*/
d33 1
d35 7
a41 12
/* hardwired clock int line */
#define	INT_NONE	(0)
#define	INT_ITMR	(0x80000000)
#define	INT_IO		(0x80000000)
#define	INT_ALL		(0xffffffff)

#define	IPL_NONE	0
#define	IPL_BIO		1
#define	IPL_NET		2
#define	IPL_TTY		3
#define	IPL_CLOCK	4
#define	IPL_HIGH	5
a47 1

d54 1
a54 2
	__asm __volatile("rsm %2, %%r0\n\t"				\
			 "mfctl	%%cr15,%0\n\t"				\
d56 1
a56 1
			: "=r" (_ctl_r): "r" (splhval), "i" (PSW_I));	\
d63 2
a64 3
			 "mtctl	%1,%%cr15\n\t"				\
			 "ssm %2, %%r0"					\
			: "=r" (_ctl_r): "r" (spllval), "i" (PSW_I));	\
d70 1
a70 2
	__asm __volatile("rsm     %2,%%r0\n\t"				\
			 "mfctl   %%cr15,%0\n\t"			\
d72 1
a72 3
			 "comiclr,= 0,%1,0\n\t"				\
			 "ssm     %2,%%r0"				\
			 : "=r" (_ctl_r): "r" (splval), "i" (PSW_I));	\
d76 2
a77 2
#define	spl0()		__spllow(INT_ALL)
#define	splsoft()	__spllow(INT_ITMR)
d80 7
a86 7
#define	splnet()	__spllow(INT_IO)
#define	splbio()	__spllow(INT_IO)
#define	splimp()	__spllow(INT_IO)
#define	spltty()	__spllow(INT_IO)
#define	splclock()	__spllow(INT_NONE)
#define	splstatclock()	__spllow(INT_NONE)
#define	splhigh()	__splhigh(INT_NONE)
@


1.6
log
@remove bogus comments
better inline for spl{hign,low}
inline splx(), which is 5 insn long, and call would add 2-3 more, which is
50% loss (not that "small or none" as it was in those (see above) comments)
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.5 1998/12/05 17:42:10 mickey Exp $	*/
d35 1
d59 3
a61 3
	__asm __volatile("mfctl	%%cr15,%0\n\t"				\
			 "mtctl	%1,%%cr15\n\t"				\
			 "rsm %2, %%r0"					\
d94 3
a96 3
#define	splclock()	__spllow(0)
#define	splstatclock()	__spllow(0)
#define	splhigh()	__splhigh(0)
@


1.5
log
@define INT_IO and INT_ALL masks for spl*() macros to use
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.4 1998/11/23 03:32:19 mickey Exp $	*/
d30 2
a54 6
 * To prevent cluttering the global spl() namespace, routines that
 * need machine-dependent SPLs should roll their own.
 *
 * If compiling with GCC, it's easy to inline spl's with constant
 * arguments.  However, when the argument can be variable, there
 * is little or no win; as a result, splx() is not inline'd.
d56 16
a71 6
#define __splhigh(splhval)	({				\
	register u_int _ctl_r;					\
	__asm __volatile("mfctl	%%cr15,%0" : "=r" (_ctl_r));	\
	__asm __volatile("mtctl	%0,%%cr15" :: "r" (splhval));	\
	__asm __volatile("rsm 1, %%r0"::);			\
	_ctl_r;							\
d74 9
a82 6
#define __spllow(spllval)	({				\
	register u_int _ctl_r;					\
	__asm __volatile("mfctl	%%cr15,%0" : "=r" (_ctl_r));	\
	__asm __volatile("mtctl	%0,%%cr15" :: "r" (spllval));	\
	__asm __volatile("ssm 1, %%r0"::);			\
	_ctl_r;							\
a95 1
int	splx __P((int));
@


1.4
log
@get closer to the interrupt handling times
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.3 1998/07/14 17:47:28 mickey Exp $	*/
d34 2
d76 1
a76 1
#define	spl0()		__spllow(0xffffffff)
d80 4
a83 4
#define	splnet()	__spllow(INT_ITMR)
#define	splbio()	__spllow(INT_ITMR)
#define	splimp()	__spllow(INT_ITMR)
#define	spltty()	__spllow(INT_ITMR)
@


1.3
log
@board ids will be auto-gen
move iodc.h and iomod.h into cpu.h so MI part won't see 'em
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.2 1998/07/07 21:32:41 mickey Exp $	*/
d27 2
a28 2
#ifndef	_HPPA_INTR_H_
#define	_HPPA_INTR_H_
d30 1
a30 19
/*
 * While the original 8 SPL's were "plenty", the PA-RISC chip provides us
 * with 32 possible interrupt levels.  We take advantage of this by using
 * the standard SPL names (e.g. splbio, splimp) and mapping them into the
 * PA-RISC interrupt scheme.  Obviously, to understand how SPL's work on
 * the PA-RISC, one must first have an understanding as to how interrupts
 * are handled on these chips!
 *
 * Briefly, the CPU has a 32-bit control register for External Interrupt
 * Requests (EIR).  Each bit corresponds to a specific external interrupt.
 * Bits in the EIR can be masked by the External Interrupt Enable Mask
 * (EIEM) control register.  Zero bits in the EIEM mask pending external
 * interrupt requests for the corresponding bit positions.  Finally, the
 * PSW I-bit must be set to allow interrupts to occur.
 *
 * SPL values then, are possible values for the EIEM.  For example, SPL0
 * would set the EIEM to 0xffffffff (enable all external interrupts), and
 * SPLCLOCK would set the EIEM to 0x0 (disable all external interrupts).
 */
d32 2
a33 36
/*
 * Define all possible External Interrupt Enable Masks (EIEMs).
 */
#define	INTPRI_00	0x00000000
#define	INTPRI_01	0x80000000
#define	INTPRI_02	0xc0000000
#define	INTPRI_03	0xe0000000
#define	INTPRI_04	0xf0000000
#define	INTPRI_05	0xf8000000
#define	INTPRI_06	0xfc000000
#define	INTPRI_07	0xfe000000
#define	INTPRI_08	0xff000000
#define	INTPRI_09	0xff800000
#define	INTPRI_10	0xffc00000
#define	INTPRI_11	0xffe00000
#define	INTPRI_12	0xfff00000
#define	INTPRI_13	0xfff80000
#define	INTPRI_14	0xfffc0000
#define	INTPRI_15	0xfffe0000
#define	INTPRI_16	0xffff0000
#define	INTPRI_17	0xffff8000
#define	INTPRI_18	0xffffc000
#define	INTPRI_19	0xffffe000
#define	INTPRI_20	0xfffff000
#define	INTPRI_21	0xfffff800
#define	INTPRI_22	0xfffffc00
#define	INTPRI_23	0xfffffe00
#define	INTPRI_24	0xffffff00
#define	INTPRI_25	0xffffff80
#define	INTPRI_26	0xffffffc0
#define	INTPRI_27	0xffffffe0
#define	INTPRI_28	0xfffffff0
#define	INTPRI_29	0xfffffff8
#define	INTPRI_30	0xfffffffc
#define	INTPRI_31	0xfffffffe
#define	INTPRI_32	0xffffffff
d35 11
a45 58
/*
 * Convert PA-RISC EIEMs into machine-independent SPLs as follows:
 *
 *                        1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3
 *  0 1 2 3 4 5 6 7  8  9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 * +-+-+-+-+-+-+-+-+---+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |c|p| | |v| | | |b i| | | | | | | |t| | | | | | | |n| | |s| | | | |
 * |l|w| | |m| | | |i m| | | | | | | |t| | | | | | | |e| | |c| | | | |
 * |k|r| | | | | | |o p| | | | | | | |y| | | | | | | |t| | |l| | | | |
 * | | | | | | | | |   | | | | | | | | | | | | | | | | | | |k| | | | |
 * +-+-+-+-+-+-+-+-+---+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *
 * The machine-dependent SPL's are also included below (indented).
 * To change the interrupt priority of a particular device, you need
 * only change it's corresponding #define below.
 *
 * Notes:
 *	- software prohibits more than one machine-dependent SPL per bit on
 *	  a given architecture (e.g. hp700 or hp800).  In cases where there
 *	  are multiple equivalent devices which interrupt at the same level
 *	  (e.g. ASP RS232 #1 and #2), the interrupt table insertion routine
 *	  will always add in the unit number (arg0) to offset the entry.
 *	- hard clock must be the first bit (i.e. 0x80000000).
 *	- SPL7 is any non-zero value (since the PSW I-bit is off).
 *	- SPLIMP serves two purposes: blocks network interfaces and blocks
 *	  memory allocation via malloc.  In theory, SPLLAN would be high
 *	  enough.  However, on the 700, the SCSI driver uses malloc at
 *	  interrupt time requiring SPLIMP >= SPLBIO.  On the 800, we are
 *	  still using HP-UX drivers which make the assumption that
 *	  SPLIMP >= SPLCIO.  New drivers would address both problems.
 */
#define	SPLHIGH		0x00000007	/* any non-zero, non-INTPRI value */
#define	SPLCLOCK	INTPRI_00	/* hard clock */
#define	SPLPOWER	INTPRI_01	/* power failure (unused) */
#define	 SPLVIPER	 INTPRI_03		/* (hp700) Viper */
#define	SPLVM		INTPRI_04	/* TLB shootdown (unused) */
#define	SPLBIO		INTPRI_08	/* block I/O */
#define	 SPLASP		 INTPRI_08		/* (hp700) ASP */
#define	 SPLCIO		 INTPRI_08		/* (hp800) CIO */
#define	SPLIMP		INTPRI_08	/* network & malloc */
#define	 SPLEISA	 INTPRI_09		/* (hp700 EISA) */
#define  SPLCIOHPIB	 INTPRI_09		/* (hp800) CIO HP-IB */
#define	 SPLFWSCSI	 INTPRI_10		/* (hp700 internal FW SCSI) */
#define	 SPLSCSI	 INTPRI_11		/* (hp700 internal SCSI) */
#define	 SPLLAN		 INTPRI_12		/* (hp700 LAN) */
#define	 SPLCIOLAN	 INTPRI_12		/* (hp800 CIO LAN) */
#define  SPLFDDI_1	 INTPRI_13		/* FDDI #1 (graphics #1) */
#define	 SPLFDDI_2	 INTPRI_14		/* FDDI #2 (graphics #2) */
#define	SPLTTY		INTPRI_16	/* TTY */
#define	 SPLCIOMUX	 INTPRI_16		/* (hp800) CIO MUX */
#define	 SPLDCA		 INTPRI_16		/* (hp700) RS232 #1 */
/*			 INTPRI_17		 * (hp700) RS232 #2 */
#define	 SPLGRF		 INTPRI_18		/* (hp700/hp800) graphics #1) */
/*			 INTPRI_19		 * (hp700/hp800) graphics #2) */
#define	 SPLHIL		 INTPRI_20		/* (hp700/hp800) HIL */
#define	SPLNET		INTPRI_24	/* soft net */
#define	SPLSCLK		INTPRI_27	/* soft clock */
#define	SPL0		INTPRI_32	/* no interrupts masked */
a46 13
/*
 * Define interrupt bits/masks.
 * N.B. A lower privilege transfer trap uses an illegal SPL_IBIT.
 */
#define SPL_IMASK_CLOCK		INTPRI_01

#define SPL_IBIT_CIO		8
#define SPL_IBIT_CIOHPIB	9
#define SPL_IBIT_CIOLAN		12
#define SPL_IBIT_CIOMUX		16
#define	SPL_IBIT_SOFTNET	24
#define	SPL_IBIT_SOFTCLK	27
#define	SPL_IBIT_LPRIV		32	/* fake interrupt */
d58 6
a63 7
#define __splhigh(splhval) \
({ \
	register unsigned int _ctl_r; \
	__asm __volatile	("mfctl	15,%0"	: "=r" (_ctl_r) : ); \
	__asm __volatile	("mtctl	%0,15"	: : "r" (splhval) ); \
	__asm __volatile	("rsm	1,%%r0"	: : ); \
	_ctl_r; \
d66 6
a71 7
#define __spllow(spllval) \
({ \
	register unsigned int _ctl_r; \
	__asm __volatile	("mfctl	15,%0"	: "=r" (_ctl_r) : ); \
	__asm __volatile	("mtctl	%0,15"	: : "r" (spllval) ); \
	__asm __volatile	("ssm	1,%%r0"	: : ); \
	_ctl_r; \
d74 2
a75 10
#define	splhigh()	__splhigh(SPLHIGH)
#define	splclock()	__spllow(SPLCLOCK)
#define	splpower()	__spllow(SPLPOWER)
#define	splvm()		__spllow(SPLVM)
#define	splbio()	__spllow(SPLBIO)
#define	splimp()	__spllow(SPLIMP)
#define	spltty()	__spllow(SPLTTY)
#define	splnet()	__spllow(SPLNET)
#define	splstatclock()	__spllow(SPLCLOCK)
#define	splsoft()	__spllow(SPLSCLK)
d78 8
a85 1
#define	spl0()		__spllow(SPL0)
d87 2
a88 3
int	splx __P((int));
#define	setsoftclock()		(PAGE0->mem_hpa->io_eir = SPL_IBIT_SOFTCLK)
#define	setsoftnet()		(void)(1)
d90 2
a91 5
/*
 * BASEPRI is true when the specified EIEM is equal to the SPL level of
 * the idle loop in swtch() (i.e. SPL0).
 */
#define	BASEPRI(eiem)	((eiem) == (unsigned int)SPL0)
d93 2
a94 13
/*
 * This is a generic interrupt switch table.  It may be used by various
 * interrupt systems.  For each interrupt, it holds a handler and an
 * EIEM mask (selected from SPL* or, more generally, INTPRI*).
 *
 * So that these tables can be easily found, please prefix them with
 * the label "itab_" (e.g. "itab_proc").
 */
struct intrtab {
	int (*handler) __P((void));	/* ptr to routine to call */
	unsigned int intpri;	/* INTPRI (SPL) with which to call it */
	int arg0, arg1;		/* 2 arguments to handler: arg0 is unit */
};
d97 1
a97 1
#endif	/* _HPPA_INTR_H_ */
@


1.2
log
@more includes
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.1 1998/06/23 19:45:22 mickey Exp $	*/
a28 3

#include <machine/iodc.h>
#include <machine/iomod.h>
@


1.1
log
@some includes
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a207 3

void	mtctl __P((u_int, u_int));
u_int	mfctl __P((u_int));
@

