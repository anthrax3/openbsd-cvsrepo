head	1.89;
access;
symbols
	OPENBSD_6_1:1.89.0.4
	OPENBSD_6_1_BASE:1.89
	OPENBSD_6_0:1.89.0.2
	OPENBSD_6_0_BASE:1.89
	OPENBSD_5_9:1.88.0.2
	OPENBSD_5_9_BASE:1.88
	OPENBSD_5_8:1.88.0.4
	OPENBSD_5_8_BASE:1.88
	OPENBSD_5_7:1.87.0.2
	OPENBSD_5_7_BASE:1.87
	OPENBSD_5_6:1.87.0.4
	OPENBSD_5_6_BASE:1.87
	OPENBSD_5_5:1.86.0.6
	OPENBSD_5_5_BASE:1.86
	OPENBSD_5_4:1.86.0.2
	OPENBSD_5_4_BASE:1.86
	OPENBSD_5_3:1.83.0.2
	OPENBSD_5_3_BASE:1.83
	OPENBSD_5_2:1.80.0.4
	OPENBSD_5_2_BASE:1.80
	OPENBSD_5_1_BASE:1.80
	OPENBSD_5_1:1.80.0.2
	OPENBSD_5_0:1.79.0.4
	OPENBSD_5_0_BASE:1.79
	OPENBSD_4_9:1.79.0.2
	OPENBSD_4_9_BASE:1.79
	OPENBSD_4_8:1.75.0.2
	OPENBSD_4_8_BASE:1.75
	OPENBSD_4_7:1.63.0.2
	OPENBSD_4_7_BASE:1.63
	OPENBSD_4_6:1.60.0.6
	OPENBSD_4_6_BASE:1.60
	OPENBSD_4_5:1.60.0.2
	OPENBSD_4_5_BASE:1.60
	OPENBSD_4_4:1.55.0.2
	OPENBSD_4_4_BASE:1.55
	OPENBSD_4_3:1.52.0.2
	OPENBSD_4_3_BASE:1.52
	OPENBSD_4_2:1.51.0.2
	OPENBSD_4_2_BASE:1.51
	OPENBSD_4_1:1.47.0.2
	OPENBSD_4_1_BASE:1.47
	OPENBSD_4_0:1.46.0.6
	OPENBSD_4_0_BASE:1.46
	OPENBSD_3_9:1.46.0.4
	OPENBSD_3_9_BASE:1.46
	OPENBSD_3_8:1.46.0.2
	OPENBSD_3_8_BASE:1.46
	OPENBSD_3_7:1.44.0.4
	OPENBSD_3_7_BASE:1.44
	OPENBSD_3_6:1.44.0.2
	OPENBSD_3_6_BASE:1.44
	SMP_SYNC_A:1.42
	SMP_SYNC_B:1.42
	OPENBSD_3_5:1.39.0.2
	OPENBSD_3_5_BASE:1.39
	OPENBSD_3_4:1.37.0.2
	OPENBSD_3_4_BASE:1.37
	UBC_SYNC_A:1.36
	OPENBSD_3_3:1.36.0.2
	OPENBSD_3_3_BASE:1.36
	OPENBSD_3_2:1.32.0.2
	OPENBSD_3_2_BASE:1.32
	OPENBSD_3_1:1.29.0.2
	OPENBSD_3_1_BASE:1.29
	UBC_SYNC_B:1.34
	UBC:1.24.0.2
	UBC_BASE:1.24
	OPENBSD_3_0:1.20.0.4
	OPENBSD_3_0_BASE:1.20
	OPENBSD_2_9:1.20.0.2
	OPENBSD_2_9_BASE:1.20
	OPENBSD_2_8:1.19.0.2
	OPENBSD_2_8_BASE:1.19
	OPENBSD_2_7:1.14.0.2
	OPENBSD_2_7_BASE:1.14
	SMP:1.13.0.2
	SMP_BASE:1.13
	kame_19991208:1.11
	OPENBSD_2_6:1.11.0.2
	OPENBSD_2_6_BASE:1.11
	OPENBSD_2_5:1.6.0.2
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.4.0.2
	OPENBSD_2_4_BASE:1.4;
locks; strict;
comment	@ * @;


1.89
date	2016.05.10.14.52.03;	author deraadt;	state Exp;
branches;
next	1.88;
commitid	aNSqBA9rHcR32TY2;

1.88
date	2015.07.02.01.33.59;	author dlg;	state Exp;
branches;
next	1.87;
commitid	HBmwORlhlW47BLMN;

1.87
date	2014.07.11.10.53.07;	author uebayasi;	state Exp;
branches;
next	1.86;
commitid	CaCLs5fTSVpJlqFi;

1.86
date	2013.03.31.17.07.03;	author deraadt;	state Exp;
branches;
next	1.85;

1.85
date	2013.03.23.16.12.22;	author deraadt;	state Exp;
branches;
next	1.84;

1.84
date	2013.03.12.09.37.16;	author mpi;	state Exp;
branches;
next	1.83;

1.83
date	2013.02.12.08.06.22;	author mpi;	state Exp;
branches;
next	1.82;

1.82
date	2013.02.11.17.05.25;	author mpi;	state Exp;
branches;
next	1.81;

1.81
date	2012.12.02.07.03.31;	author guenther;	state Exp;
branches;
next	1.80;

1.80
date	2011.09.20.21.44.09;	author miod;	state Exp;
branches;
next	1.79;

1.79
date	2011.01.02.20.41.22;	author kettenis;	state Exp;
branches;
next	1.78;

1.78
date	2010.12.30.14.26.14;	author jsing;	state Exp;
branches;
next	1.77;

1.77
date	2010.12.30.14.10.14;	author jsing;	state Exp;
branches;
next	1.76;

1.76
date	2010.09.28.20.27.54;	author miod;	state Exp;
branches;
next	1.75;

1.75
date	2010.06.29.00.50.40;	author jsing;	state Exp;
branches;
next	1.74;

1.74
date	2010.06.03.15.48.58;	author jsing;	state Exp;
branches;
next	1.73;

1.73
date	2010.06.03.15.05.52;	author jsing;	state Exp;
branches;
next	1.72;

1.72
date	2010.05.21.15.24.29;	author jsing;	state Exp;
branches;
next	1.71;

1.71
date	2010.05.19.13.10.24;	author jsing;	state Exp;
branches;
next	1.70;

1.70
date	2010.05.16.14.54.43;	author jsing;	state Exp;
branches;
next	1.69;

1.69
date	2010.04.29.13.14.44;	author jsing;	state Exp;
branches;
next	1.68;

1.68
date	2010.04.29.12.35.14;	author jsing;	state Exp;
branches;
next	1.67;

1.67
date	2010.04.19.16.32.53;	author jsing;	state Exp;
branches;
next	1.66;

1.66
date	2010.04.19.14.05.04;	author jsing;	state Exp;
branches;
next	1.65;

1.65
date	2010.04.01.12.30.38;	author jsing;	state Exp;
branches;
next	1.64;

1.64
date	2010.03.28.16.26.47;	author jsing;	state Exp;
branches;
next	1.63;

1.63
date	2009.12.31.12.52.35;	author jsing;	state Exp;
branches;
next	1.62;

1.62
date	2009.12.29.13.40.09;	author jsing;	state Exp;
branches;
next	1.61;

1.61
date	2009.12.29.13.11.40;	author jsing;	state Exp;
branches;
next	1.60;

1.60
date	2009.02.01.14.53.04;	author miod;	state Exp;
branches;
next	1.59;

1.59
date	2008.10.15.23.23.47;	author deraadt;	state Exp;
branches;
next	1.58;

1.58
date	2008.10.10.08.36.28;	author art;	state Exp;
branches;
next	1.57;

1.57
date	2008.10.10.08.05.45;	author art;	state Exp;
branches;
next	1.56;

1.56
date	2008.10.09.08.43.43;	author art;	state Exp;
branches;
next	1.55;

1.55
date	2008.07.23.17.39.35;	author kettenis;	state Exp;
branches;
next	1.54;

1.54
date	2008.07.18.23.43.31;	author art;	state Exp;
branches;
next	1.53;

1.53
date	2008.07.14.13.39.06;	author miod;	state Exp;
branches;
next	1.52;

1.52
date	2007.10.10.15.53.51;	author art;	state Exp;
branches;
next	1.51;

1.51
date	2007.07.20.22.12.39;	author kettenis;	state Exp;
branches;
next	1.50;

1.50
date	2007.05.15.16.03.52;	author miod;	state Exp;
branches;
next	1.49;

1.49
date	2007.05.14.19.54.21;	author martin;	state Exp;
branches;
next	1.48;

1.48
date	2007.03.15.10.22.29;	author art;	state Exp;
branches;
next	1.47;

1.47
date	2007.01.17.19.30.12;	author mickey;	state Exp;
branches;
next	1.46;

1.46
date	2005.04.07.00.26.21;	author mickey;	state Exp;
branches;
next	1.45;

1.45
date	2005.04.07.00.21.51;	author mickey;	state Exp;
branches;
next	1.44;

1.44
date	2004.06.30.18.18.54;	author mickey;	state Exp;
branches;
next	1.43;

1.43
date	2004.06.13.21.49.14;	author niklas;	state Exp;
branches;
next	1.42;

1.42
date	2004.04.08.17.10.18;	author mickey;	state Exp;
branches;
next	1.41;

1.41
date	2004.04.07.18.24.19;	author mickey;	state Exp;
branches;
next	1.40;

1.40
date	2004.04.02.20.56.31;	author mickey;	state Exp;
branches;
next	1.39;

1.39
date	2003.10.15.18.54.55;	author mickey;	state Exp;
branches;
next	1.38;

1.38
date	2003.10.05.14.13.28;	author mickey;	state Exp;
branches;
next	1.37;

1.37
date	2003.07.30.21.24.19;	author mickey;	state Exp;
branches;
next	1.36;

1.36
date	2002.11.27.21.47.14;	author mickey;	state Exp;
branches;
next	1.35;

1.35
date	2002.11.08.21.42.12;	author mickey;	state Exp;
branches;
next	1.34;

1.34
date	2002.10.21.18.41.05;	author mickey;	state Exp;
branches;
next	1.33;

1.33
date	2002.10.07.14.38.40;	author mickey;	state Exp;
branches;
next	1.32;

1.32
date	2002.09.17.03.51.49;	author mickey;	state Exp;
branches;
next	1.31;

1.31
date	2002.08.03.20.56.42;	author mickey;	state Exp;
branches;
next	1.30;

1.30
date	2002.06.07.21.33.43;	author nordin;	state Exp;
branches;
next	1.29;

1.29
date	2002.03.15.21.44.18;	author mickey;	state Exp;
branches;
next	1.28;

1.28
date	2002.03.14.01.26.32;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2002.02.16.02.41.15;	author mickey;	state Exp;
branches;
next	1.26;

1.26
date	2002.02.11.21.21.55;	author mickey;	state Exp;
branches;
next	1.25;

1.25
date	2002.02.11.19.42.11;	author mickey;	state Exp;
branches;
next	1.24;

1.24
date	2001.12.02.04.14.11;	author mickey;	state Exp;
branches
	1.24.2.1;
next	1.23;

1.23
date	2001.12.02.04.10.25;	author mickey;	state Exp;
branches;
next	1.22;

1.22
date	2001.11.08.23.57.35;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2001.11.06.18.41.09;	author art;	state Exp;
branches;
next	1.20;

1.20
date	2001.01.29.00.01.58;	author mickey;	state Exp;
branches;
next	1.19;

1.19
date	2000.08.15.19.50.42;	author mickey;	state Exp;
branches;
next	1.18;

1.18
date	2000.07.02.04.14.45;	author mickey;	state Exp;
branches;
next	1.17;

1.17
date	2000.07.02.04.11.31;	author mickey;	state Exp;
branches;
next	1.16;

1.16
date	2000.07.02.02.41.56;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	2000.06.15.19.11.24;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	2000.03.23.20.25.41;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	2000.02.10.20.05.40;	author mickey;	state Exp;
branches
	1.13.2.1;
next	1.12;

1.12
date	2000.01.25.12.52.51;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	99.09.18.20.02.42;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	99.08.14.03.25.59;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	99.06.12.18.13.16;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	99.05.02.03.41.08;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	99.04.20.19.26.42;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	98.12.14.01.19.18;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	98.10.30.19.18.32;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	98.08.29.01.17.06;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	98.07.14.17.47.27;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	98.07.07.21.32.38;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	98.06.23.19.45.20;	author mickey;	state Exp;
branches;
next	;

1.13.2.1
date	2000.03.24.09.07.30;	author niklas;	state Exp;
branches;
next	1.13.2.2;

1.13.2.2
date	2001.04.18.16.06.19;	author niklas;	state Exp;
branches;
next	1.13.2.3;

1.13.2.3
date	2001.11.13.21.00.51;	author niklas;	state Exp;
branches;
next	1.13.2.4;

1.13.2.4
date	2001.12.05.00.39.10;	author niklas;	state Exp;
branches;
next	1.13.2.5;

1.13.2.5
date	2002.03.06.00.57.22;	author niklas;	state Exp;
branches;
next	1.13.2.6;

1.13.2.6
date	2002.03.28.10.27.10;	author niklas;	state Exp;
branches;
next	1.13.2.7;

1.13.2.7
date	2003.03.27.23.26.54;	author niklas;	state Exp;
branches;
next	1.13.2.8;

1.13.2.8
date	2004.02.19.10.48.40;	author niklas;	state Exp;
branches;
next	1.13.2.9;

1.13.2.9
date	2004.06.05.23.10.49;	author niklas;	state Exp;
branches;
next	1.13.2.10;

1.13.2.10
date	2004.06.06.05.23.39;	author tedu;	state Exp;
branches;
next	;

1.24.2.1
date	2002.06.11.03.35.37;	author art;	state Exp;
branches;
next	1.24.2.2;

1.24.2.2
date	2002.10.29.00.28.03;	author art;	state Exp;
branches;
next	1.24.2.3;

1.24.2.3
date	2003.05.19.21.49.41;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.89
log
@The hppa trapframe PC is marked (in the low two bits) to indicate a
userland addressspace address.  Those bits should be masked to
callers of the PROC_PC() macro.
ok kettenis
@
text
@/*	$OpenBSD: cpu.h,v 1.88 2015/07/02 01:33:59 dlg Exp $	*/

/*
 * Copyright (c) 2000-2004 Michael Shalayeff
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR OR HIS RELATIVES BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */
/* 
 * Copyright (c) 1988-1994, The University of Utah and
 * the Computer Systems Laboratory at the University of Utah (CSL).
 * All rights reserved.
 *
 * Permission to use, copy, modify and distribute this software is hereby
 * granted provided that (1) source code retains these copyright, permission,
 * and disclaimer notices, and (2) redistributions including binaries
 * reproduce the notices in supporting documentation, and (3) all advertising
 * materials mentioning features or use of this software display the following
 * acknowledgement: ``This product includes software developed by the
 * Computer Systems Laboratory at the University of Utah.''
 *
 * THE UNIVERSITY OF UTAH AND CSL ALLOW FREE USE OF THIS SOFTWARE IN ITS "AS
 * IS" CONDITION.  THE UNIVERSITY OF UTAH AND CSL DISCLAIM ANY LIABILITY OF
 * ANY KIND FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * CSL requests users of this software to return to csl-dist@@cs.utah.edu any
 * improvements that they make and grant CSL redistribution rights.
 *
 * 	Utah $Hdr: cpu.h 1.19 94/12/16$
 */

#ifndef	_MACHINE_CPU_H_
#define	_MACHINE_CPU_H_

#ifdef _KERNEL
#include <machine/trap.h>
#include <machine/frame.h>
#endif /* _KERNEL */

/*
 * CPU types and features
 */
#define	HPPA_FTRS_TLBU		0x00000001
#define	HPPA_FTRS_BTLBU		0x00000002
#define	HPPA_FTRS_HVT		0x00000004
#define	HPPA_FTRS_W32B		0x00000008

#ifndef _LOCORE
#ifdef _KERNEL
#include <sys/device.h>
#include <sys/queue.h>
#include <sys/sched.h>

#include <machine/mutex.h>

/*
 * Note that the alignment of ci_trap_save is important since we want to keep
 * it within a single cache line. As a result, it must be kept as the first
 * entry within the cpu_info struct.
 */
struct cpu_info {
	register_t	ci_trap_save[16];

	struct device	*ci_dev;
	int		ci_cpuid;
	hppa_hpa_t	ci_hpa;
	volatile int	ci_flags;

	struct proc	*ci_curproc;
	paddr_t		ci_fpu_state;		/* Process FPU state. */
	paddr_t		ci_stack;

#if defined(MULTIPROCESSOR)
	struct srp_hazard ci_srp_hazards[SRP_HAZARD_NUM];
#endif

	register_t	ci_psw;			/* Processor Status Word. */
	volatile int	ci_cpl;
	volatile u_long	ci_mask;		/* Hardware interrupt mask. */
	volatile u_long	ci_ipending;
	volatile int	ci_in_intr;
	int		ci_want_resched;
	u_long		ci_itmr;

	volatile u_long	ci_ipi;			/* IPIs pending. */
	struct mutex	ci_ipi_mtx;

	struct schedstate_percpu ci_schedstate;
	u_int32_t	ci_randseed;
#ifdef DIAGNOSTIC
	int		ci_mutex_level;
#endif
#ifdef GPROF
	struct gmonparam *ci_gmon;
#endif
} __attribute__((__aligned__(64)));

#define		CPUF_RUNNING	0x0001		/* CPU is running. */

#ifdef MULTIPROCESSOR
#define		HPPA_MAXCPUS	4
#else
#define		HPPA_MAXCPUS	1
#endif

extern struct cpu_info cpu_info[HPPA_MAXCPUS];

#define MAXCPUS		HPPA_MAXCPUS

static __inline struct cpu_info *
curcpu(void)
{
	struct cpu_info *ci;

	asm volatile ("mfctl    %%cr29, %0" : "=r"(ci));

	return ci;
}

#define cpu_number()		(curcpu()->ci_cpuid)

#define CPU_INFO_UNIT(ci)	((ci)->ci_dev ? (ci)->ci_dev->dv_unit : 0)
#define CPU_IS_PRIMARY(ci)	((ci)->ci_cpuid == 0)
#define	CPU_INFO_ITERATOR	int
#define CPU_INFO_FOREACH(cii, ci) \
	for (cii = 0, ci = &cpu_info[0]; cii < ncpus; cii++, ci++)

#define CPU_BUSY_CYCLE()	do {} while (0)

/* types */
enum hppa_cpu_type {
	hpcxs, hpcxt, hpcxta, hpcxl, hpcxl2, hpcxu, hpcxu2, hpcxw
};
extern enum hppa_cpu_type cpu_type;
extern const char *cpu_typename;
extern int cpu_hvers;
#endif
#endif

/*
 * COPR/SFUs
 */
#define	HPPA_FPUS	0xc0
#define	HPPA_FPUVER(w)	(((w) & 0x003ff800) >> 11)
#define	HPPA_FPU_OP(w)	((w) >> 26)
#define	HPPA_FPU_UNMPL	0x01	/* exception reg, the rest is << 1 */
#define	HPPA_FPU_ILL	0x80	/* software-only */
#define	HPPA_FPU_I	0x01
#define	HPPA_FPU_U	0x02
#define	HPPA_FPU_O	0x04
#define	HPPA_FPU_Z	0x08
#define	HPPA_FPU_V	0x10
#define	HPPA_FPU_D	0x20
#define	HPPA_FPU_T	0x40
#define	HPPA_FPU_XMASK	0x7f
#define	HPPA_FPU_T_POS	25
#define	HPPA_FPU_RM	0x00000600
#define	HPPA_FPU_CQ	0x00fff800
#define	HPPA_FPU_C	0x04000000
#define	HPPA_FPU_FLSH	27
#define	HPPA_FPU_INIT	(0)
#define	HPPA_FPU_FORK(s) ((s) & ~((u_int64_t)(HPPA_FPU_XMASK)<<32))
#define	HPPA_PMSFUS	0x20	/* ??? */

/*
 * Exported definitions unique to hp700/PA-RISC cpu support.
 */

#define	HPPA_PGALIAS	0x00400000
#define	HPPA_PGAMASK	0xffc00000
#define	HPPA_PGAOFF	0x003fffff

#define	HPPA_IOBEGIN    0xf0000000
#define	HPPA_IOLEN      0x10000000
#define	HPPA_PDC_LOW	0xef000000
#define	HPPA_PDC_HIGH	0xf1000000
#define	HPPA_IOBCAST	0xfffc0000
#define	HPPA_LBCAST	0xfffc0000
#define	HPPA_GBCAST	0xfffe0000
#define	HPPA_FPA	0xfff80000
#define	HPPA_FLEX_DATA	0xfff80001
#define	HPPA_DMA_ENABLE	0x00000001
#define	HPPA_FLEX_MASK	0xfffc0000
#define	HPPA_FLEX_SIZE	(1 + ~HPPA_FLEX_MASK)
#define	HPPA_FLEX(a)	(((a) & HPPA_FLEX_MASK) >> 18)
#define	HPPA_SPA_ENABLE	0x00000020
#define	HPPA_NMODSPBUS	64

#define	clockframe		trapframe
#define	CLKF_PC(framep)		((framep)->tf_iioq_head)
#define	CLKF_INTR(framep)	((framep)->tf_flags & TFF_INTR)
#define	CLKF_USERMODE(framep)	((framep)->tf_flags & T_USER)
#define	CLKF_SYSCALL(framep)	((framep)->tf_flags & TFF_SYS)

#define	need_proftick(p)	setsoftast(p)
#define	PROC_PC(p)		((p)->p_md.md_regs->tf_iioq_head & ~HPPA_PC_PRIV_MASK)
#define	PROC_STACK(p)		((p)->p_md.md_regs->tf_sp)

#ifndef _LOCORE
#ifdef _KERNEL

#define DELAY(x) delay(x)

extern int (*cpu_desidhash)(void);

void	signotify(struct proc *);
void	delay(u_int us);
void	hppa_init(paddr_t start);
void	trap(int type, struct trapframe *frame);
int	spcopy(pa_space_t ssp, const void *src,
		    pa_space_t dsp, void *dst, size_t size);
int	spstrcpy(pa_space_t ssp, const void *src,
		      pa_space_t dsp, void *dst, size_t size, size_t *rsize);
int	copy_on_fault(void);
void	switch_trampoline(void);
int	cpu_dumpsize(void);
int	cpu_dump(void);

#ifdef MULTIPROCESSOR
void	cpu_boot_secondary_processors(void);
void	cpu_hw_init(void);
void	cpu_hatch(void);
void	cpu_unidle(struct cpu_info *);
#else
#define	cpu_unidle(ci)
#endif

extern void need_resched(struct cpu_info *);
#define clear_resched(ci) 	(ci)->ci_want_resched = 0

#endif

/*
 * Boot arguments stuff
 */

#define	BOOTARG_LEN	PAGE_SIZE
#define	BOOTARG_OFF	0x10000

/*
 * CTL_MACHDEP definitions.
 */
#define	CPU_CONSDEV		1	/* dev_t: console terminal device */
#define	CPU_FPU			2	/* int: fpu present/enabled */
#define	CPU_LED_BLINK		3	/* int: twiddle heartbeat LED/LCD */
#define	CPU_MAXID		4	/* number of valid machdep ids */

#define CTL_MACHDEP_NAMES { \
	{ 0, 0 }, \
	{ "console_device", CTLTYPE_STRUCT }, \
	{ "fpu", CTLTYPE_INT }, \
	{ "led_blink", CTLTYPE_INT }, \
}

#ifdef _KERNEL
#include <sys/queue.h>

#ifdef MULTIPROCESSOR
#include <sys/mplock.h>
#endif

struct blink_led {
	void (*bl_func)(void *, int);
	void *bl_arg;
	SLIST_ENTRY(blink_led) bl_next;
};

extern void blink_led_register(struct blink_led *);
#endif
#endif

#endif /* _MACHINE_CPU_H_ */
@


1.88
log
@introduce srp, which according to the manpage i wrote is short for
"shared reference pointers".

srp allows concurrent access to a data structure by multiple cpus
while avoiding interlocking cpu opcodes. it manages its own reference
counts and the garbage collection of those data structure to avoid
use after frees.

internally srp is a twisted version of hazard pointers, which are
a relative of RCU.

jmatthew wrote the bulk of a hazard pointer implementation and
changed bpf to use it to allow mpsafe access to bpfilters. however,
at s2k15 we were trying to apply it to other data structures but
the memory overhead of every hazard pointer would have blown out
significantly in several uses cases. a bulk of our time at s2k15
was spent reworking hazard pointers into srp.

this diff adds the srp api and adds the necessary metadata to struct
cpuinfo on our MP architectures. srp on uniprocessor platforms has
alternate code that is optimised because it knows there'll be no
concurrent access to data by multiple cpus.

srp is made available to the system via param.h, so it should be
available everywhere in the kernel.

the docs likely need improvement cos im too close to the implementation.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.87 2014/07/11 10:53:07 uebayasi Exp $	*/
d215 1
a215 1
#define	PROC_PC(p)		((p)->p_md.md_regs->tf_iioq_head)
@


1.87
log
@CPU_BUSY_CYCLE(): A new MI statement for busy loop power reduction

The new CPU_BUSY_CYCLE() may be put in a busy loop body so that CPU can reduce
power consumption, as Linux's cpu_relax() and FreeBSD's cpu_spinwait().  To
start minimally, use PAUSE on i386/amd64 and empty on others.  The name is
chosen following the existing cpu_idle_*() functions.  Naming and API may be
polished later.

OK kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d91 4
@


1.86
log
@try to avoid pulling in pte.h and other more crazy things.  Checked against
the things that libkvm needs.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.85 2013/03/23 16:12:22 deraadt Exp $	*/
d142 2
@


1.85
log
@refactor sys/param.h and machine/param.h.  A lot of #ifdef _KERNEL is added
to keep definitions our of user space.  The MD files now follow a consistant
order -- all namespace intrusion is at the tail can be cleaned up
independently.  locore, bootblocks, and libkvm still see enough visibility to
build.  Checked on 90% of platforms...
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.84 2013/03/12 09:37:16 mpi Exp $	*/
d54 1
d57 1
@


1.84
log
@Fix kernel profiling on MP systems by using per-CPU buffers and teach
kgmon(8) to deal with them, this time without public header changes.

Previously various CPUs were iterating over the same global buffer at
the same time to modify it and never ended.

This diff includes some ideas submited by Thor Simon to NetBSD via miod@@.

ok deraadt@@, mikeb@@, haesbaert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.83 2013/02/12 08:06:22 mpi Exp $	*/
d248 2
a249 2
#define	BOOTARG_LEN	(NBPG)
#define	BOOTARG_OFF	(0x10000)
@


1.83
log
@Back out per-CPU kernel profiling, it shouldn't modify a public header
at this moment.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.82 2013/02/11 17:05:25 mpi Exp $	*/
d105 3
@


1.82
log
@Fix kernel profiling on MP systems by using per-CPU buffer. Previously
various CPUs were iterating over the same global buffer at the same
time to modify it and never ended.

This diff includes some ideas submited by Thor Simon to NetBSD via miod@@.

ok mikeb@@, haesbaert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.81 2012/12/02 07:03:31 guenther Exp $	*/
a104 3
#endif
#ifdef GPROF
	struct gmonparam *ci_gmon;
@


1.81
log
@Determine whether we're currently on the alternative signal stack
dynamically, by comparing the stack pointer against the altstack
base and size, so that you get the correct answer if you longjmp
out of the signal handler, as tested by regress/sys/kern/stackjmp/.
Also, fix alt stack handling on vax, where it was completely broken.

Testing and corrections by miod@@, krw@@, tobiasu@@, pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.80 2011/09/20 21:44:09 miod Exp $	*/
d105 3
@


1.80
log
@Remove unused MD_CACHE_CTL() macro and related defines.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.79 2011/01/02 20:41:22 kettenis Exp $	*/
d205 1
@


1.79
log
@Make need_resched() call cpu_unidle() such that we wake up a process running on
another CPU.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.78 2010/12/30 14:26:14 jsing Exp $	*/
a207 4
#define MD_CACHE_FLUSH 0
#define MD_CACHE_PURGE 1
#define MD_CACHE_CTL(a,s,t)	\
	(((t)? pdcache : fdcache) (HPPA_SID_KERNEL,(vaddr_t)(a),(s)))
@


1.78
log
@Turn signotify() into a function that also calls cpu_unidle().

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.75 2010/06/29 00:50:40 jsing Exp $	*/
a202 7
#define	need_resched(ci)						\
	do {								\
		(ci)->ci_want_resched = 1;				\
		if ((ci)->ci_curproc != NULL)				\
			setsoftast((ci)->ci_curproc);			\
	} while (0)
#define clear_resched(ci) 	(ci)->ci_want_resched = 0
d238 4
@


1.77
log
@Implement cpu_unidle() for MP kernels.

ok kettenis@@
@
text
@a202 1
#define	signotify(p)		setsoftast(p)
d224 1
@


1.76
log
@Implement a per-cpu held mutex counter if DIAGNOSTIC on all non-x86 platforms,
to complete matthew@@'s commit of a few days ago, and drop __HAVE_CPU_MUTEX_LEVEL
define. With help from, and ok deraadt@@.
@
text
@a137 2
#define cpu_unidle(ci)

d241 3
@


1.75
log
@Store pointer to process FPU state in struct cpu_info.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.74 2010/06/03 15:48:58 jsing Exp $	*/
d103 3
@


1.74
log
@Rename ci_spinup_stack to ci_stack and use it as the stack for both CPU
spin up and FPU emulation. Since all CPUs need a stack for FPU emulation,
move the allocation code to cpuattach().

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.72 2010/05/21 15:24:29 jsing Exp $	*/
d87 1
@


1.73
log
@Add missing function prototypes for MP kernels.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.71 2010/05/19 13:10:24 jsing Exp $	*/
d87 1
a87 1
	paddr_t		ci_spinup_stack;
@


1.72
log
@Add support for IPIs on hppa.

ok kettenis@@
@
text
@d237 2
@


1.71
log
@Spin up secondary CPUs on hppa multiprocessor kernels. At this stage we
enable clock interrupts, however do not allow processes to be scheduled
onto the secondary CPUs - hopefully we can change this shortly...

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.70 2010/05/16 14:54:43 jsing Exp $	*/
d71 2
d96 3
@


1.70
log
@Use a per CPU trap save area, ensuring that we maintain 64-byte alignment
so that it stays within a single cache line.

Feedback and ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.68 2010/04/29 12:35:14 jsing Exp $	*/
d82 1
d85 1
d99 2
d102 1
a102 1
#define        HPPA_MAXCPUS            1
d104 1
a104 1
#define        HPPA_MAXCPUS            4
@


1.69
log
@Use per CPU hardware interrupt mask.

ok kettenis@@
@
text
@d71 5
d77 2
d95 1
a95 1
};
@


1.68
log
@Store hardware timer information per CPU.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.67 2010/04/19 16:32:53 jsing Exp $	*/
d80 1
@


1.67
log
@Make ipending a per-CPU value.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.66 2010/04/19 14:05:04 jsing Exp $	*/
d83 1
@


1.66
log
@Make the Processor Status Word (PSW) a per-CPU value.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.62 2009/12/29 13:40:09 jsing Exp $	*/
d80 1
@


1.65
log
@Allow for multiple CPUs by moving to an array of cpu_info.

ok kettenis@@
@
text
@d78 1
a123 1
extern register_t kpsw;
@


1.64
log
@Allow a multiprocessor kernel to compile.

ok kettenis@@
@
text
@d67 1
d72 4
d86 21
a106 1
extern struct cpu_info cpu_info_primary;
d108 5
a112 1
#define curcpu()	(&cpu_info_primary)
a113 7
#define CPU_IS_PRIMARY(ci)	1
#define CPU_INFO_ITERATOR	int
#define CPU_INFO_FOREACH(cii, ci)	\
	for (cii = 0, ci = curcpu(); ci != NULL; ci = NULL)
#define CPU_INFO_UNIT(ci)	0
#define MAXCPUS	1
#define cpu_number()	0
@


1.63
log
@Make cpl and cpu_inintr per CPU variables. For locore.S, cpl becomes an
offset within cpu_primary_info - this will need to be revisited shortly.

ok kettenis@@
@
text
@d193 4
d223 4
@


1.62
log
@Make want_resched a per CPU variable.

ok kettenis@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.61 2009/12/29 13:11:40 jsing Exp $	*/
d73 2
@


1.61
log
@Move hppa to per process AST.

ok kettenis@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.59 2008/10/15 23:23:47 deraadt Exp $	*/
d73 2
d161 1
a161 1
		want_resched = 1;					\
d165 1
a165 1
#define clear_resched(ci) 	want_resched = 0
a174 2

extern int want_resched;
@


1.60
log
@Fix the logic in mbus_add_mapping() to correctly handle requests spanning
more than one flex ``tile'', when the first one is already mapped.
Some sti(4) devices have such requests.

ok kettenis@@
@
text
@d156 7
a162 2
#define	signotify(p)		(setsoftast())
#define	need_resched(ci)	(want_resched = 1, setsoftast())
d164 1
a164 1
#define	need_proftick(p)	setsoftast()
@


1.59
log
@make random(9) return per-cpu values (by saving the seed in the cpuinfo),
which are uniform for the profclock on each cpu in a SMP system (but using
a different seed for each cpu).  on all cpus, avoid seeding with a value out
of the [0, 2^31-1] range (since that is not stable)
ok kettenis drahn
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.58 2008/10/10 08:36:28 art Exp $	*/
d145 1
@


1.58
log
@Add empty cpu_unidle() macros for architectures that currently don't do
anything special to prod a cpu to leave the idle loop in signotify.
powerpc, i386, amd64 and sparc64 will follow soon so that everyone has
the same interface to wake an idling cpu.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.57 2008/10/10 08:05:45 art Exp $	*/
d71 1
a71 1
	struct proc *ci_curproc;
d74 1
@


1.57
log
@Define MAXCPUS on all architectures.
For now, sparc64 is arbitrarily set to 256 (only architecture that didn't have
a practical limit in the code on the number of cpus).
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.56 2008/10/09 08:43:43 art Exp $	*/
d87 1
@


1.56
log
@Implement CPU_INFO_UNIT for everyone, not just MP kernels.
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.55 2008/07/23 17:39:35 kettenis Exp $	*/
d85 1
a85 1

@


1.55
log
@So it turns outthe HP engineers changed the PA-RISC 2.0 architecture
after it was published.  In particular, they changed the maximum cache
aliasing boundary from 1MB to 16MB.

It turns that on the PA-8700 the aliasing boundary is actually 4MB
(reported as such by the firmware at least).  There are some comments
in the Linux code that suggest that HP never actually built PA-RISC
CPUs with an 8MB or 16MB aliasing boundary.

So raise the aliasing boundary to 4MB.  This fixes the weird ps(1) problem
where it didn't print its own arguments correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.54 2008/07/18 23:43:31 art Exp $	*/
d84 1
@


1.54
log
@Add a macro that clears the want_resched flag that need_resched sets.
Right now when mi_switch picks up the same proc, we didn't clear the
flag which would mean that every time we service an AST we would attempt
a context switch. For some architectures, amd64 being probably the
most extreme, that meant attempting to context switch for every
trap and interrupt.

Now we clear_resched explicitly after every context switch, even if it
didn't do anything. Which also allows us to remove some more code
in cpu_switchto (not done yet).

miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.53 2008/07/14 13:39:06 miod Exp $	*/
d127 3
a129 3
#define	HPPA_PGALIAS	0x00100000
#define	HPPA_PGAMASK	0xfff00000
#define	HPPA_PGAOFF	0x000fffff
@


1.53
log
@Be sure to propagate PSL_O in psw on PCXU* processors to userland processes
and signal handlers.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.52 2007/10/10 15:53:51 art Exp $	*/
d154 1
@


1.52
log
@Make context switching much more MI:
 - Move the functionality of choosing a process from cpu_switch into
   a much simpler function: cpu_switchto. Instead of having the locore
   code walk the run queues, let the MI code choose the process we
   want to run and only implement the context switching itself in MD
   code.
 - Let MD context switching run without worrying about spls or locks.
 - Instead of having the idle loop implemented with special contexts
   in MD code, implement one idle proc for each cpu. make the idle
   loop MI with MD hooks.
 - Change the proc lists from the old style vax queues to TAILQs.
 - Change the sleep queue from vax queues to TAILQs. This makes
   wakeup() go from O(n^2) to O(n)

there will be some MD fallout, but it will be fixed shortly.
There's also a few cleanups to be done after this.

deraadt@@, kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.51 2007/07/20 22:12:39 kettenis Exp $	*/
d94 1
@


1.51
log
@Give hppa the blink_led API from sparc64, and the associated machdep.led_blink
sysctl.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.50 2007/05/15 16:03:52 miod Exp $	*/
d67 1
@


1.50
log
@Userland has the right to compile, too; not sure this will be enough yet
but deraadt@@ insists this goes in now.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.49 2007/05/14 19:54:21 martin Exp $	*/
d193 2
a194 1
#define	CPU_MAXID		3	/* number of valid machdep ids */
d200 1
d202 12
@


1.49
log
@move hppa to __HAVE_CPUINFO

input from miod@@, ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.48 2007/03/15 10:22:29 art Exp $	*/
d66 1
d93 1
@


1.48
log
@Since p_flag is often manipulated in interrupts and without biglock
it's a good idea to use atomic.h operations on it. This mechanic
change updates all bit operations on p_flag to atomic_{set,clear}bits_int.

Only exception is that P_OWEUPC is set by MI code before calling
need_proftick and it's automatically cleared by ADDUPC. There's
no reason for MD handling of that flag since everyone handles it the
same way.

kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.47 2007/01/17 19:30:12 mickey Exp $	*/
d66 19
@


1.47
log
@new shorter version of userret() as surely miod ment it to be like (; miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.46 2005/04/07 00:26:21 mickey Exp $	*/
d131 1
a131 1
#define	need_proftick(p)	((p)->p_flag |= P_OWEUPC, setsoftast())
@


1.46
log
@duh. space vs tab
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.45 2005/04/07 00:21:51 mickey Exp $	*/
d132 1
@


1.45
log
@64bit-friendly pdc.h and iomod.h and correspondent changes elsewhere
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.44 2004/06/30 18:18:54 mickey Exp $	*/
d108 2
a109 2
#define HPPA_IOBEGIN    0xf0000000
#define HPPA_IOLEN      0x10000000
@


1.44
log
@allow forced fpu emulation through a sysctl
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.43 2004/06/13 21:49:14 niklas Exp $	*/
d108 2
a109 2
#define	HPPA_IOSPACE	0xf0000000
#define	HPPA_IOBCAST	0xfffc0000
d112 3
@


1.43
log
@debranch SMP, have fun
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d167 2
a168 1
#define	CPU_MAXID		2	/* number of valid machdep ids */
d173 1
@


1.42
log
@repair pcxs/t confoosion
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.41 2004/04/07 18:24:19 mickey Exp $	*/
d127 1
a127 1
#define	need_resched()		(want_resched = 1, setsoftast())
@


1.41
log
@update copyright; miod@@ is fine w/ files where he holds it too
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.40 2004/04/02 20:56:31 mickey Exp $	*/
d68 1
a68 1
	hpcx, hpcxs, hpcxt, hpcxta, hpcxl, hpcxl2, hpcxu, hpcxu2, hpcxw
@


1.40
log
@repair fcnv* emulation.
generate proper signals/siginfo.
partially repairs the "otto" case.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.39 2003/10/15 18:54:55 mickey Exp $	*/
d4 1
a4 1
 * Copyright (c) 2000-2002 Michael Shalayeff
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Michael Shalayeff.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.39
log
@less global name space pollution
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.38 2003/10/05 14:13:28 mickey Exp $	*/
d86 2
a87 1
#define	HPPA_FPU_UNMPL	0x9
@


1.38
log
@reload the itmr as soon as we get the intr to avoid lagging on slower machines
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.37 2003/07/30 21:24:19 mickey Exp $	*/
a141 1
extern u_int cpu_itmr, cpu_hzticks;
@


1.37
log
@deduce the leds address from the model number and thus make some more use of that lichtenblinkenschmutz on some more machinens
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.36 2002/11/27 21:47:14 mickey Exp $	*/
a122 8

#define	CPU_CLOCKUPDATE() do {					\
	register_t __itmr;					\
	__asm __volatile("mfctl	%%cr16, %0" : "=r" (__itmr));	\
	cpu_itmr = __itmr;					\
	__itmr += cpu_hzticks;					\
	__asm __volatile("mtctl	%0, %%cr16" :: "r" (__itmr));	\
} while (0)
@


1.36
log
@no wrapper arounf hardclock(), use CPU_CLOCKUPDATE, real microtime; miod ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.35 2002/11/08 21:42:12 mickey Exp $	*/
d77 1
@


1.35
log
@only reset the pending fpu exceptions on fork, not the rest of the fpu status reg
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.34 2002/10/21 18:41:05 mickey Exp $	*/
d123 8
d149 1
@


1.34
log
@make an ieeefp regress pass; miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.33 2002/10/07 14:38:40 mickey Exp $	*/
d93 1
d100 1
@


1.33
log
@on implementations w/ fpu included unimplemented instructions
are signaled through the exception trap w/ invalid opcode marked
instruction in the exception registers, not through the emulation
trap (as long as the fpu is enabled, of  course).
parse emulation from the exception trap as well as the emulation
trap and fix the dispatcher into usable condition.
parse invalid op exception on trap and signal the user appropriately.
reset the exception on exec and for child on fork.
the later is appropriate since exceptions are delayed until next
fpu instruction, which was in the parent indeed, let him get it.
save parent's fpu context on fork before cipying it, if the
parent owned the fpu.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.32 2002/09/17 03:51:49 mickey Exp $	*/
d98 1
a98 1
#define	HPPA_FPU_INIT	(HPPA_FPU_U | HPPA_FPU_O | HPPA_FPU_Z | HPPA_FPU_V)
@


1.32
log
@handle fpu exceptions properly, might use a regress, i guess
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.31 2002/08/03 20:56:42 mickey Exp $	*/
d4 1
a4 1
 * Copyright (c) 2000-2001 Michael Shalayeff
d85 1
d93 1
d98 1
a98 1
#define	HPPA_FPU_INIT	(HPPA_FPU_I | HPPA_FPU_U | HPPA_FPU_O | HPPA_FPU_Z | HPPA_FPU_V)
@


1.31
log
@in fact, no need for switch_exit() completely, cpu_exit() handles the reins to the cpu_switch and basta!
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.30 2002/06/07 21:33:43 nordin Exp $	*/
d84 13
@


1.30
log
@Remove obsolete CLKF_BASEPRI(). ok niklas@@, miod@@ and art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.29 2002/03/15 21:44:18 mickey Exp $	*/
a137 1
void	switch_exit(struct proc *p);
@


1.29
log
@rewrite a pmap to use multilevel page tables.
lower 12 bits contain the perms, no unused bits left,
but a couple for off-tlb use (as the ref implemented now).
do not use the hvt, which might get some use later
if proven to speed thigs up, tlb handlers would po
another dozen of insns though, but if that's worth its...
move on the data seg and map kernel text rdonly (idea form fredette),
since all of the page0 mods done before that we are all fine
except for some viper fluff, but later w/ that.
this also picks up a bit more of ddb magic for bpt and ss.
tlb handlers can use a little bit more of attention,
but things, visually, seem to be much faster already, --
sorry, no benchmarks for now.

* effort sponsored in part by the `henry st. old ale house'
* and mr.pete and mr.lee in particular in thier generous entrirety.
* the proj took a little more that 72man*h as it was expected,
* but within murhy's law estimations.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.28 2002/03/14 01:26:32 millert Exp $	*/
a106 1
#define	CLKF_BASEPRI(framep)	((framep)->tf_eiem == ~0U)
@


1.28
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.27 2002/02/16 02:41:15 mickey Exp $	*/
d65 1
a65 1
#define	HPPA_FTRS_BTLBS		0x00000001
@


1.27
log
@dma_cachectl() no more
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.26 2002/02/11 21:21:55 mickey Exp $	*/
d128 1
a128 1
extern int (*cpu_desidhash) __P((void));
d130 12
a141 12
void	delay __P((u_int us));
void	hppa_init __P((paddr_t start));
void	trap __P((int type, struct trapframe *frame));
int	spcopy __P((pa_space_t ssp, const void *src,
		    pa_space_t dsp, void *dst, size_t size));
int	spstrcpy __P((pa_space_t ssp, const void *src,
		      pa_space_t dsp, void *dst, size_t size, size_t *rsize));
int	copy_on_fault __P((void));
void	switch_trampoline __P((void));
void	switch_exit __P((struct proc *p));
int	cpu_dumpsize __P((void));
int	cpu_dump __P((void));
@


1.26
log
@kvtop no more
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.25 2002/02/11 19:42:11 mickey Exp $	*/
a132 1
int	dma_cachectl __P((caddr_t p, int size));
@


1.25
log
@disable fpu on csw, print fpu version on cpu line, if present
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.24 2001/12/02 04:14:11 mickey Exp $	*/
a126 8

static __inline long
kvtop (const caddr_t va)
{
	long ret;
	__asm __volatile ("lpa %%r0(%1), %0" : "=r" (ret) : "r" (va));
	return ret;
}
@


1.24
log
@few lines are too close to see, gimme another file!
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.23 2001/12/02 04:10:25 mickey Exp $	*/
d83 1
@


1.24.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.24 2001/12/02 04:14:11 mickey Exp $	*/
d65 1
a65 1
#define	HPPA_FTRS_TLBU		0x00000001
a82 1
#define	HPPA_FPUVER(w)	(((w) & 0x003ff800) >> 11)
d106 1
d127 23
a149 14
extern int (*cpu_desidhash)(void);

void	delay(u_int us);
void	hppa_init(paddr_t start);
void	trap(int type, struct trapframe *frame);
int	spcopy(pa_space_t ssp, const void *src,
		    pa_space_t dsp, void *dst, size_t size);
int	spstrcpy(pa_space_t ssp, const void *src,
		      pa_space_t dsp, void *dst, size_t size, size_t *rsize);
int	copy_on_fault(void);
void	switch_trampoline(void);
void	switch_exit(struct proc *p);
int	cpu_dumpsize(void);
int	cpu_dump(void);
@


1.24.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.24.2.1 2002/06/11 03:35:37 art Exp $	*/
d4 1
a4 1
 * Copyright (c) 2000-2002 Michael Shalayeff
a83 15
#define	HPPA_FPU_OP(w)	((w) >> 26)
#define	HPPA_FPU_UNMPL	0x9
#define	HPPA_FPU_I	0x01
#define	HPPA_FPU_U	0x02
#define	HPPA_FPU_O	0x04
#define	HPPA_FPU_Z	0x08
#define	HPPA_FPU_V	0x10
#define	HPPA_FPU_D	0x20
#define	HPPA_FPU_T	0x40
#define	HPPA_FPU_T_POS	25
#define	HPPA_FPU_RM	0x00000600
#define	HPPA_FPU_CQ	0x00fff800
#define	HPPA_FPU_C	0x04000000
#define	HPPA_FPU_FLSH	27
#define	HPPA_FPU_INIT	(0)
d138 1
@


1.24.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a92 1
#define	HPPA_FPU_XMASK	0x7f
a98 1
#define	HPPA_FPU_FORK(s) ((s) & ~((u_int64_t)(HPPA_FPU_XMASK)<<32))
a120 8
#define	CPU_CLOCKUPDATE() do {					\
	register_t __itmr;					\
	__asm __volatile("mfctl	%%cr16, %0" : "=r" (__itmr));	\
	cpu_itmr = __itmr;					\
	__itmr += cpu_hzticks;					\
	__asm __volatile("mtctl	%0, %%cr16" :: "r" (__itmr));	\
} while (0)

a138 1
extern u_int cpu_itmr, cpu_hzticks;
@


1.23
log
@s/FLAX_MASK/HPPA_FLEX_MASK/ where not yet
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.22 2001/11/08 23:57:35 miod Exp $	*/
d101 1
a101 1
#define	HPPA_FLEX(a)	(((a) & FLEX_MASK) >> 18)
@


1.22
log
@COPY_SIGCODE serve no purpose nowadays.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.21 2001/11/06 18:41:09 art Exp $	*/
d101 1
@


1.21
log
@Let fork1, uvm_fork, and cpu_fork take a function/argument pair as argument,
instead of doing fork1, cpu_set_kpc. This lets us retire cpu_set_kpc and
avoid a multiprocessor race.

This commit breaks vax because it doesn't look like any other arch, someone
working on vax might want to look at this and try to adapt the code to be
more like the rest of the world.

Idea and uvm parts from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.20 2001/01/29 00:01:58 mickey Exp $	*/
a87 6

/*
 * definitions of cpu-dependent requirements
 * referenced in generic code
 */
#undef	COPY_SIGCODE		/* copy sigcode above user stack in exec */
@


1.20
log
@implement a few macros in cpu.h; pointer out by miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.19 2000/08/15 19:50:42 mickey Exp $	*/
a150 1
void	child_return __P((struct proc *p));
@


1.19
log
@compress MD_CACHE_CTL in one line
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.18 2000/07/02 04:14:45 mickey Exp $	*/
d4 1
a4 1
 * Copyright (c) 2000 Michael Shalayeff
d110 1
a110 1
#define	clockframe	trapframe
d117 3
a119 3
#define	signotify(p)		(void)(p)
#define	need_resched()		{(void)1;}
#define	need_proftick(p)	{(void)(p);}
d127 2
@


1.18
log
@yes, it will; forgot, oops, ouch
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.17 2000/07/02 04:11:31 mickey Exp $	*/
d125 2
a126 3
#define MD_CACHE_CTL(CACHE_ADDR,CACHE_SIZE,CACHE_FLUSHTYPE)		\
	(((CACHE_FLUSHTYPE)? pdcache : fdcache)				\
		(HPPA_SID_KERNEL,(vaddr_t)CACHE_ADDR,CACHE_SIZE))	\
@


1.17
log
@constraints misscount; that's how it goes typing on the train
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.16 2000/07/02 02:41:56 mickey Exp $	*/
a134 1
	/* XXX will it keep page offset ok? */
@


1.16
log
@new kvtop through lpa; also put some spu/sfu bits in cpu.h
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.15 2000/06/15 19:11:24 mickey Exp $	*/
d136 1
a136 1
	__asm __volatile ("lpa %%r0(%0), %1" : "=r" (ret) : "r" (va));
@


1.15
log
@add MD_CACHE* defines
export more about cpu type.
prorotype for `disable sid hashing', returning cpu version as a side effect
define virtual pages coherency parameters.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.14 2000/03/23 20:25:41 mickey Exp $	*/
d80 6
d131 9
a144 1
int	kvtop __P((const caddr_t va));
@


1.14
log
@new cpu type switch code.
initializes tlb miss handlers correspondent to probed cpu features.
also btlb load routine.
versions written are for pcxl and others.
cpu-dep btlb loaders are missing, only generic for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.13 2000/02/10 20:05:40 mickey Exp $	*/
d75 2
d89 4
d117 6
d124 3
d137 1
a137 1
void child_return __P((struct proc *p));
@


1.13
log
@clkf_intr() implementation, better clkf_usermode()
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.12 2000/01/25 12:52:51 mickey Exp $	*/
d3 30
d61 15
@


1.13.2.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a2 30
/*
 * Copyright (c) 2000 Michael Shalayeff
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Michael Shalayeff.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR OR HIS RELATIVES BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */
a30 15

/*
 * CPU types and features
 */
#define	HPPA_FTRS_BTLBS		0x00000001
#define	HPPA_FTRS_BTLBU		0x00000002
#define	HPPA_FTRS_HVT		0x00000004
#define	HPPA_FTRS_W32B		0x00000008

#ifndef _LOCORE
/* types */
enum hppa_cpu_type {
	hpcx, hpcxs, hpcxt, hpcxta, hpcxl, hpcxl2, hpcxu, hpcxu2, hpcxw
};
#endif
@


1.13.2.2
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.20 2001/01/29 00:01:58 mickey Exp $	*/
d4 1
a4 1
 * Copyright (c) 2000-2001 Michael Shalayeff
a74 2
extern enum hppa_cpu_type cpu_type;
extern const char *cpu_typename;
a77 6
 * COPR/SFUs
 */
#define	HPPA_FPUS	0xc0
#define	HPPA_PMSFUS	0x20	/* ??? */

/*
a86 4
#define	HPPA_PGALIAS	0x00100000
#define	HPPA_PGAMASK	0xfff00000
#define	HPPA_PGAOFF	0x000fffff

d98 1
a98 1
#define	clockframe		trapframe
d105 3
a107 3
#define	signotify(p)		(setsoftast())
#define	need_resched()		(want_resched = 1, setsoftast())
#define	need_proftick(p)	((p)->p_flag |= P_OWEUPC, setsoftast())
a110 7
#define MD_CACHE_FLUSH 0
#define MD_CACHE_PURGE 1
#define MD_CACHE_CTL(a,s,t)	\
	(((t)? pdcache : fdcache) (HPPA_SID_KERNEL,(vaddr_t)(a),(s)))

extern int want_resched;

a111 11

static __inline long
kvtop (const caddr_t va)
{
	long ret;
	__asm __volatile ("lpa %%r0(%1), %0" : "=r" (ret) : "r" (va));
	return ret;
}

extern int (*cpu_desidhash) __P((void));

d115 1
d122 1
a122 1
void	child_return __P((struct proc *p));
@


1.13.2.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d89 6
d151 1
@


1.13.2.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.13.2.3 2001/11/13 21:00:51 niklas Exp $	*/
a100 1
#define	HPPA_FLEX(a)	(((a) & HPPA_FLEX_MASK) >> 18)
@


1.13.2.5
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a82 1
#define	HPPA_FPUVER(w)	(((w) & 0x003ff800) >> 11)
d127 8
d140 1
@


1.13.2.6
log
@Merge in -current from about a week ago
@
text
@d65 1
a65 1
#define	HPPA_FTRS_TLBU		0x00000001
d128 1
a128 1
extern int (*cpu_desidhash)(void);
d130 12
a141 12
void	delay(u_int us);
void	hppa_init(paddr_t start);
void	trap(int type, struct trapframe *frame);
int	spcopy(pa_space_t ssp, const void *src,
		    pa_space_t dsp, void *dst, size_t size);
int	spstrcpy(pa_space_t ssp, const void *src,
		      pa_space_t dsp, void *dst, size_t size, size_t *rsize);
int	copy_on_fault(void);
void	switch_trampoline(void);
void	switch_exit(struct proc *p);
int	cpu_dumpsize(void);
int	cpu_dump(void);
@


1.13.2.7
log
@Sync the SMP branch with 3.3
@
text
@d4 1
a4 1
 * Copyright (c) 2000-2002 Michael Shalayeff
a83 17
#define	HPPA_FPU_OP(w)	((w) >> 26)
#define	HPPA_FPU_UNMPL	0x9
#define	HPPA_FPU_I	0x01
#define	HPPA_FPU_U	0x02
#define	HPPA_FPU_O	0x04
#define	HPPA_FPU_Z	0x08
#define	HPPA_FPU_V	0x10
#define	HPPA_FPU_D	0x20
#define	HPPA_FPU_T	0x40
#define	HPPA_FPU_XMASK	0x7f
#define	HPPA_FPU_T_POS	25
#define	HPPA_FPU_RM	0x00000600
#define	HPPA_FPU_CQ	0x00fff800
#define	HPPA_FPU_C	0x04000000
#define	HPPA_FPU_FLSH	27
#define	HPPA_FPU_INIT	(0)
#define	HPPA_FPU_FORK(s) ((s) & ~((u_int64_t)(HPPA_FPU_XMASK)<<32))
a105 8
#define	CPU_CLOCKUPDATE() do {					\
	register_t __itmr;					\
	__asm __volatile("mfctl	%%cr16, %0" : "=r" (__itmr));	\
	cpu_itmr = __itmr;					\
	__itmr += cpu_hzticks;					\
	__asm __volatile("mtctl	%0, %%cr16" :: "r" (__itmr));	\
} while (0)

d107 1
a124 1
extern u_int cpu_itmr, cpu_hzticks;
d139 1
@


1.13.2.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@a76 1
extern int cpu_hvers;
d123 8
d149 1
@


1.13.2.9
log
@Merge with the trunk
@
text
@d4 1
a4 1
 * Copyright (c) 2000-2004 Michael Shalayeff
d15 5
d73 1
a73 1
	hpcxs, hpcxt, hpcxta, hpcxl, hpcxl2, hpcxu, hpcxu2, hpcxw
d86 1
a86 2
#define	HPPA_FPU_UNMPL	0x01	/* exception reg, the rest is << 1 */
#define	HPPA_FPU_ILL	0x80	/* software-only */
@


1.13.2.10
log
@need_resched macro needs to take ci arg to be compat with MP function
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.13.2.9 2004/06/05 23:10:49 niklas Exp $	*/
d127 1
a127 1
#define	need_resched(ci)	(want_resched = 1, setsoftast())
@


1.12
log
@cpu_wait() and cpu_swapin() do exist
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.11 1999/09/18 20:02:42 mickey Exp $	*/
d29 1
d56 3
a58 2
#define	CLKF_INTR(framep)	(0)	/* XXX */
#define	CLKF_USERMODE(framep)	(USERMODE((framep)->tf_iioq_head))
@


1.11
log
@hide c-code from asm
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.10 1999/08/14 03:25:59 mickey Exp $	*/
a77 4
#define	cpu_wait(p)	/* so, nobody uses it nomore */
#if 0
#define	cpu_swapin(p)	/* nothing */
#endif
@


1.10
log
@better CLKF_BASEPRI
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.9 1999/06/12 18:13:16 mickey Exp $	*/
d62 1
d103 1
@


1.9
log
@hppa_init() now takes an argument from locore,
meaning the start of available memory.
cleanup machdep somewhat.
fix vm_map.pmap vs vm_pmap isue; 10x art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.8 1999/05/02 03:41:08 mickey Exp $	*/
d53 1
a53 1
#define	CLKF_BASEPRI(framep)	((framep)->tf_eiem)
@


1.8
log
@child_return() proto
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.7 1999/04/20 19:26:42 mickey Exp $	*/
d64 5
a68 5
void	delay __P((u_int));
void	hppa_init __P((void));
void	trap __P((int, struct trapframe *));
int	kvtop __P((const caddr_t));
int	dma_cachectl __P((caddr_t, int));
d74 1
a74 1
void child_return __P((struct proc *));
d76 1
a76 1
void	switch_exit __P((struct proc *));
@


1.7
log
@name changes; more cpu_* functions
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.6 1998/12/14 01:19:18 mickey Exp $	*/
d74 1
a74 1
void	child_return __P((void));
@


1.6
log
@remove bogus^H^H^H^H^Hconstant cache line size definition
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.5 1998/10/30 19:18:32 mickey Exp $	*/
d53 2
a54 2
#define	CLKF_BASEPRI(framep)	((framep)->eiem)
#define	CLKF_PC(framep)		((framep)->iioq_head)
d56 1
a56 1
#define	CLKF_USERMODE(framep)	(USERMODE((framep)->iioq_head))
d69 14
@


1.5
log
@add some protos and defines
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.4 1998/08/29 01:17:06 mickey Exp $	*/
a60 5

/*
 * Expected (and optimized for) cache line size (in bytes).
 */
#define CACHE_LINE_SIZE 32
@


1.4
log
@add delay() and trap() protos
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.3 1998/07/14 17:47:27 mickey Exp $	*/
d26 2
a27 2
#ifndef	_HPPA_CPU_H_
#define	_HPPA_CPU_H_
d52 3
a54 2
#define	CLKF_BASEPRI(framep)	(0)	/* XXX */
#define	CLKF_PC(framep)		(0)	/* XXX */
d56 1
a56 1
#define	CLKF_USERMODE(framep)	(0)	/* XXX */
d72 2
d94 1
a94 1
#endif /* _HPPA_CPU_H_ */
@


1.3
log
@board ids will be auto-gen
move iodc.h and iomod.h into cpu.h so MI part won't see 'em
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.2 1998/07/07 21:32:38 mickey Exp $	*/
a28 2
#include <machine/iodc.h>
#include <machine/iomod.h>
d67 2
d70 1
d78 1
a78 1
#define	BOOTARG_OFF	(NBPG)
@


1.2
log
@more includes
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.1 1998/06/23 19:45:20 mickey Exp $	*/
d29 2
a41 53

/*
 * Supported systems
 */
#define	HP_810		0x100
#define	HP_815		0x103
#define	HP_822		0x101
#define	HP_825		0x008
#define	HP_827		0x102
#define	HP_835		0x00a
#define	HP_840		0x004
#define	HP_842		0x104
#define	HP_845		0x00b
#define	HP_850		0x080
#define	HP_852		0x105
#define	HP_855		0x081
#define	HP_860		0x082
#define	HP_870		0x083

#define	HP_720		0x200	/* [S] Cobra */
#define	HP_750		0x201	/* [S] Coral */
#define	HP_730		0x202	/* [S] King Cobra */

#define	HP_710		0x300	/* [S] Bushmaster */
#define	HP_705		0x302	/* [S] Bushmaster */

#define	HP_715_33	0x311	/* [S] Scorpio */
#define	HP_715_50	0x310	/* [S] Scorpio */
#define	HP_715T_50	0x312	/* [S] Scorpio (upgrade from 4XXt) */
#define	HP_715S_50	0x314	/* [S] Scorpio (upgrade from 4XXs) */
#define	HP_715_75	0x316	/* [S] Scorpio */
#define	HP_725		0xFFF	/* [S] Scorpio -- is this the real ID? */
#define	HP_735		0x203	/* [S] Hardball */
#define HP_735_125	0x206	/* [S] Hardball */
#define	HP_755		0xFFD	/* [S] Coral II -- is this the real ID? */

#define	HP_712_60	0x600	/* [S] Gekko */
#define	HP_712_80	0x601	/* [S] Gekko */
#define	HP_712_100	0x602	/* [S] Gekko */
#define	HP_743i_1	0x603
#define	HP_743i_2	0x604
#define	HP_712_4	0x605	/* [S] Gekko */
#define	HP_7GL_1	0x606
#define	HP_7GL_2	0x607
#define	HP_7GL_3	0x608
#define	HP_743v_1	0x617
#define	HP_743v_2	0x618
#define	HP_743i_3	0x619

#define	CPU_M770_100	0x585   /* J-class J200 */
#define	CPU_M770_120	0x586   /* J-class J210 */
#define	CPU_M777_100	0x592   /* C-class C200 */
#define	CPU_M777_120	0x58E   /* C-class C210 */
@


1.1
log
@some includes
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d26 3
d89 5
d115 9
d140 2
@

