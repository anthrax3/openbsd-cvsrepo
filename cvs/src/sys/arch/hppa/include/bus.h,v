head	1.31;
access;
symbols
	OPENBSD_6_0:1.31.0.20
	OPENBSD_6_0_BASE:1.31
	OPENBSD_5_9:1.31.0.16
	OPENBSD_5_9_BASE:1.31
	OPENBSD_5_8:1.31.0.18
	OPENBSD_5_8_BASE:1.31
	OPENBSD_5_7:1.31.0.10
	OPENBSD_5_7_BASE:1.31
	OPENBSD_5_6:1.31.0.14
	OPENBSD_5_6_BASE:1.31
	OPENBSD_5_5:1.31.0.12
	OPENBSD_5_5_BASE:1.31
	OPENBSD_5_4:1.31.0.8
	OPENBSD_5_4_BASE:1.31
	OPENBSD_5_3:1.31.0.6
	OPENBSD_5_3_BASE:1.31
	OPENBSD_5_2:1.31.0.4
	OPENBSD_5_2_BASE:1.31
	OPENBSD_5_1_BASE:1.31
	OPENBSD_5_1:1.31.0.2
	OPENBSD_5_0:1.29.0.6
	OPENBSD_5_0_BASE:1.29
	OPENBSD_4_9:1.29.0.4
	OPENBSD_4_9_BASE:1.29
	OPENBSD_4_8:1.29.0.2
	OPENBSD_4_8_BASE:1.29
	OPENBSD_4_7:1.28.0.2
	OPENBSD_4_7_BASE:1.28
	OPENBSD_4_6:1.27.0.4
	OPENBSD_4_6_BASE:1.27
	OPENBSD_4_5:1.25.0.8
	OPENBSD_4_5_BASE:1.25
	OPENBSD_4_4:1.25.0.6
	OPENBSD_4_4_BASE:1.25
	OPENBSD_4_3:1.25.0.4
	OPENBSD_4_3_BASE:1.25
	OPENBSD_4_2:1.25.0.2
	OPENBSD_4_2_BASE:1.25
	OPENBSD_4_1:1.24.0.10
	OPENBSD_4_1_BASE:1.24
	OPENBSD_4_0:1.24.0.8
	OPENBSD_4_0_BASE:1.24
	OPENBSD_3_9:1.24.0.6
	OPENBSD_3_9_BASE:1.24
	OPENBSD_3_8:1.24.0.4
	OPENBSD_3_8_BASE:1.24
	OPENBSD_3_7:1.24.0.2
	OPENBSD_3_7_BASE:1.24
	OPENBSD_3_6:1.23.0.2
	OPENBSD_3_6_BASE:1.23
	SMP_SYNC_A:1.23
	SMP_SYNC_B:1.23
	OPENBSD_3_5:1.22.0.2
	OPENBSD_3_5_BASE:1.22
	OPENBSD_3_4:1.20.0.2
	OPENBSD_3_4_BASE:1.20
	UBC_SYNC_A:1.20
	OPENBSD_3_3:1.19.0.6
	OPENBSD_3_3_BASE:1.19
	OPENBSD_3_2:1.19.0.4
	OPENBSD_3_2_BASE:1.19
	OPENBSD_3_1:1.19.0.2
	OPENBSD_3_1_BASE:1.19
	UBC_SYNC_B:1.19
	UBC:1.14.0.2
	UBC_BASE:1.14
	OPENBSD_3_0:1.13.0.2
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9:1.12.0.4
	OPENBSD_2_9_BASE:1.12
	OPENBSD_2_8:1.12.0.2
	OPENBSD_2_8_BASE:1.12
	OPENBSD_2_7:1.11.0.4
	OPENBSD_2_7_BASE:1.11
	SMP:1.11.0.2
	SMP_BASE:1.11
	kame_19991208:1.10
	OPENBSD_2_6:1.8.0.4
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.8.0.2
	OPENBSD_2_5_BASE:1.8;
locks; strict;
comment	@ * @;


1.31
date	2011.11.14.14.29.53;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2011.11.10.22.48.13;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2010.06.19.14.06.56;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2009.07.30.21.39.54;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2009.05.31.17.42.11;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2009.04.20.00.42.06;	author oga;	state Exp;
branches;
next	1.25;

1.25
date	2007.05.23.18.07.19;	author kettenis;	state Exp;
branches;
next	1.24;

1.24
date	2005.01.09.06.58.51;	author mickey;	state Exp;
branches;
next	1.23;

1.23
date	2004.04.07.18.24.19;	author mickey;	state Exp;
branches;
next	1.22;

1.22
date	2004.03.02.21.06.15;	author mickey;	state Exp;
branches;
next	1.21;

1.21
date	2003.09.29.19.23.02;	author mickey;	state Exp;
branches;
next	1.20;

1.20
date	2003.03.29.00.58.50;	author mickey;	state Exp;
branches;
next	1.19;

1.19
date	2002.03.14.01.26.32;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2002.03.07.18.08.08;	author jason;	state Exp;
branches;
next	1.17;

1.17
date	2002.02.16.03.13.32;	author mickey;	state Exp;
branches;
next	1.16;

1.16
date	2002.02.16.02.40.12;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	2002.02.16.02.21.56;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	2001.11.05.17.25.57;	author art;	state Exp;
branches
	1.14.2.1;
next	1.13;

1.13
date	2001.07.30.14.15.59;	author art;	state Exp;
branches;
next	1.12;

1.12
date	2000.06.15.19.05.09;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	2000.01.29.03.12.12;	author mickey;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	99.11.26.17.34.59;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	99.11.25.18.25.31;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	99.02.25.17.32.39;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	99.01.03.17.55.13;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	98.12.29.22.20.27;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	98.12.13.07.08.38;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	98.12.13.06.36.54;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	98.12.05.17.31.21;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	98.12.05.15.50.45;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	98.11.23.03.36.53;	author mickey;	state Exp;
branches;
next	;

1.11.2.1
date	2001.04.18.16.06.18;	author niklas;	state Exp;
branches;
next	1.11.2.2;

1.11.2.2
date	2001.10.31.02.52.47;	author nate;	state Exp;
branches;
next	1.11.2.3;

1.11.2.3
date	2001.11.13.21.00.51;	author niklas;	state Exp;
branches;
next	1.11.2.4;

1.11.2.4
date	2002.03.06.00.57.22;	author niklas;	state Exp;
branches;
next	1.11.2.5;

1.11.2.5
date	2002.03.28.10.27.10;	author niklas;	state Exp;
branches;
next	1.11.2.6;

1.11.2.6
date	2003.05.13.19.41.04;	author ho;	state Exp;
branches;
next	1.11.2.7;

1.11.2.7
date	2004.02.19.10.48.40;	author niklas;	state Exp;
branches;
next	1.11.2.8;

1.11.2.8
date	2004.06.05.23.10.49;	author niklas;	state Exp;
branches;
next	;

1.14.2.1
date	2002.06.11.03.35.37;	author art;	state Exp;
branches;
next	1.14.2.2;

1.14.2.2
date	2003.05.19.21.49.41;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.31
log
@merge various differences between hppa and hppa64
ok jsing
@
text
@/*	$OpenBSD: bus.h,v 1.30 2011/11/10 22:48:13 deraadt Exp $	*/

/*
 * Copyright (c) 1998-2004 Michael Shalayeff
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR OR HIS RELATIVES BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef _MACHINE_BUS_H_
#define _MACHINE_BUS_H_

#include <machine/cpufunc.h>

/* addresses in bus space */
typedef u_long bus_addr_t;
typedef u_long bus_size_t;

/* access methods for bus space */
typedef u_long bus_space_handle_t;

struct hppa_bus_space_tag {
	void *hbt_cookie;

	int  (*hbt_map)(void *v, bus_addr_t addr, bus_size_t size,
		    int flags, bus_space_handle_t *bshp);
	void (*hbt_unmap)(void *v, bus_space_handle_t bsh, bus_size_t size);
	int  (*hbt_subregion)(void *v, bus_space_handle_t bsh,
		    bus_size_t offset, bus_size_t size,
		    bus_space_handle_t *nbshp);
	int  (*hbt_alloc)(void *v, bus_addr_t rstart, bus_addr_t rend,
		    bus_size_t size, bus_size_t align, bus_size_t boundary,
		    int flags, bus_addr_t *addrp, bus_space_handle_t *bshp);
	void (*hbt_free)(void *, bus_space_handle_t, bus_size_t);
	void (*hbt_barrier)(void *v, bus_space_handle_t h,
		    bus_size_t o, bus_size_t l, int op);
	void *(*hbt_vaddr)(void *v, bus_space_handle_t h);

	u_int8_t  (*hbt_r1)(void *, bus_space_handle_t, bus_size_t);
	u_int16_t (*hbt_r2)(void *, bus_space_handle_t, bus_size_t);
	u_int32_t (*hbt_r4)(void *, bus_space_handle_t, bus_size_t);
	u_int64_t (*hbt_r8)(void *, bus_space_handle_t, bus_size_t);

	void (*hbt_w1)(void *, bus_space_handle_t, bus_size_t, u_int8_t);
	void (*hbt_w2)(void *, bus_space_handle_t, bus_size_t, u_int16_t);
	void (*hbt_w4)(void *, bus_space_handle_t, bus_size_t, u_int32_t);
	void (*hbt_w8)(void *, bus_space_handle_t, bus_size_t, u_int64_t);

	void (*hbt_rm_1)(void *v, bus_space_handle_t h,
	      bus_size_t o, u_int8_t *a, bus_size_t c);
	void (*hbt_rm_2)(void *v, bus_space_handle_t h,
	      bus_size_t o, u_int16_t *a, bus_size_t c);
	void (*hbt_rm_4)(void *v, bus_space_handle_t h,
	      bus_size_t o, u_int32_t *a, bus_size_t c);
	void (*hbt_rm_8)(void *v, bus_space_handle_t h,
	      bus_size_t o, u_int64_t *a, bus_size_t c);

	void (*hbt_wm_1)(void *v, bus_space_handle_t h, bus_size_t o,
	      const u_int8_t *a, bus_size_t c);
	void (*hbt_wm_2)(void *v, bus_space_handle_t h, bus_size_t o,
	      const u_int16_t *a, bus_size_t c);
	void (*hbt_wm_4)(void *v, bus_space_handle_t h, bus_size_t o,
	      const u_int32_t *a, bus_size_t c);
	void (*hbt_wm_8)(void *v, bus_space_handle_t h, bus_size_t o,
	      const u_int64_t *a, bus_size_t c);

	void (*hbt_sm_1)(void *v, bus_space_handle_t h, bus_size_t o,
	      u_int8_t  vv, bus_size_t c);
	void (*hbt_sm_2)(void *v, bus_space_handle_t h, bus_size_t o,
	      u_int16_t vv, bus_size_t c);
	void (*hbt_sm_4)(void *v, bus_space_handle_t h, bus_size_t o,
	      u_int32_t vv, bus_size_t c);
	void (*hbt_sm_8)(void *v, bus_space_handle_t h, bus_size_t o,
	      u_int64_t vv, bus_size_t c);

	void (*hbt_rrm_2)(void *v, bus_space_handle_t h,
	       bus_size_t o, u_int8_t *a, bus_size_t c);
	void (*hbt_rrm_4)(void *v, bus_space_handle_t h,
	       bus_size_t o, u_int8_t *a, bus_size_t c);
	void (*hbt_rrm_8)(void *v, bus_space_handle_t h,
	       bus_size_t o, u_int8_t *a, bus_size_t c);

	void (*hbt_wrm_2)(void *v, bus_space_handle_t h,
	       bus_size_t o, const u_int8_t *a, bus_size_t c);
	void (*hbt_wrm_4)(void *v, bus_space_handle_t h,
	       bus_size_t o, const u_int8_t *a, bus_size_t c);
	void (*hbt_wrm_8)(void *v, bus_space_handle_t h,
	       bus_size_t o, const u_int8_t *a, bus_size_t c);

	void (*hbt_rr_1)(void *v, bus_space_handle_t h,
	      bus_size_t o, u_int8_t *a, bus_size_t c);
	void (*hbt_rr_2)(void *v, bus_space_handle_t h,
	      bus_size_t o, u_int16_t *a, bus_size_t c);
	void (*hbt_rr_4)(void *v, bus_space_handle_t h,
	      bus_size_t o, u_int32_t *a, bus_size_t c);
	void (*hbt_rr_8)(void *v, bus_space_handle_t h,
	      bus_size_t o, u_int64_t *a, bus_size_t c);

	void (*hbt_wr_1)(void *v, bus_space_handle_t h,
	      bus_size_t o, const u_int8_t *a, bus_size_t c);
	void (*hbt_wr_2)(void *v, bus_space_handle_t h,
	      bus_size_t o, const u_int16_t *a, bus_size_t c);
	void (*hbt_wr_4)(void *v, bus_space_handle_t h,
	      bus_size_t o, const u_int32_t *a, bus_size_t c);
	void (*hbt_wr_8)(void *v, bus_space_handle_t h,
	      bus_size_t o, const u_int64_t *a, bus_size_t c);

	void (*hbt_rrr_2)(void *v, bus_space_handle_t h,
	       bus_size_t o, u_int8_t *a, bus_size_t c);
	void (*hbt_rrr_4)(void *v, bus_space_handle_t h,
	       bus_size_t o, u_int8_t *a, bus_size_t c);
	void (*hbt_rrr_8)(void *v, bus_space_handle_t h,
	       bus_size_t o, u_int8_t *a, bus_size_t c);

	void (*hbt_wrr_2)(void *v, bus_space_handle_t h,
	       bus_size_t o, const u_int8_t *a, bus_size_t c);
	void (*hbt_wrr_4)(void *v, bus_space_handle_t h,
	       bus_size_t o, const u_int8_t *a, bus_size_t c);
	void (*hbt_wrr_8)(void *v, bus_space_handle_t h,
	       bus_size_t o, const u_int8_t *a, bus_size_t c);

	void (*hbt_sr_1)(void *v, bus_space_handle_t h,
	       bus_size_t o, u_int8_t vv, bus_size_t c);
	void (*hbt_sr_2)(void *v, bus_space_handle_t h,
	       bus_size_t o, u_int16_t vv, bus_size_t c);
	void (*hbt_sr_4)(void *v, bus_space_handle_t h,
	       bus_size_t o, u_int32_t vv, bus_size_t c);
	void (*hbt_sr_8)(void *v, bus_space_handle_t h,
	       bus_size_t o, u_int64_t vv, bus_size_t c);

	void (*hbt_cp_1)(void *v, bus_space_handle_t h1, bus_size_t o1,
	      bus_space_handle_t h2, bus_size_t o2, bus_size_t c);
	void (*hbt_cp_2)(void *v, bus_space_handle_t h1, bus_size_t o1,
	      bus_space_handle_t h2, bus_size_t o2, bus_size_t c);
	void (*hbt_cp_4)(void *v, bus_space_handle_t h1, bus_size_t o1,
	      bus_space_handle_t h2, bus_size_t o2, bus_size_t c);
	void (*hbt_cp_8)(void *v, bus_space_handle_t h1, bus_size_t o1,
	      bus_space_handle_t h2, bus_size_t o2, bus_size_t c);
};
typedef const struct hppa_bus_space_tag *bus_space_tag_t;
extern const struct hppa_bus_space_tag hppa_bustag;

/* flags for bus space map functions */
#define	BUS_SPACE_MAP_CACHEABLE		0x0001
#define	BUS_SPACE_MAP_LINEAR		0x0002
#define	BUS_SPACE_MAP_READONLY		0x0004
#define	BUS_SPACE_MAP_PREFETCHABLE	0x0008

/* bus access routines */

#define	bus_space_map(t,a,c,ca,hp) \
	(((t)->hbt_map)((t)->hbt_cookie,(a),(c),(ca),(hp)))
#define	bus_space_unmap(t,h,c) \
	(((t)->hbt_unmap)((t)->hbt_cookie,(h),(c)))
#define	bus_space_subregion(t,h,o,c,hp) \
	(((t)->hbt_subregion)((t)->hbt_cookie,(h),(o),(c),(hp)))
#define	bus_space_alloc(t,b,e,c,al,bn,ca,ap,hp) \
	(((t)->hbt_alloc)((t)->hbt_cookie,(b),(e),(c),(al),(bn),(ca),(ap),(hp)))
#define	bus_space_free(t,h,c) \
	(((t)->hbt_free)((t)->hbt_cookie,(h),(c)))

#define	bus_space_read_1(t,h,o) (((t)->hbt_r1)((t)->hbt_cookie,(h),(o)))
#define	bus_space_read_2(t,h,o) (((t)->hbt_r2)((t)->hbt_cookie,(h),(o)))
#define	bus_space_read_4(t,h,o) (((t)->hbt_r4)((t)->hbt_cookie,(h),(o)))
#define	bus_space_read_8(t,h,o) (((t)->hbt_r8)((t)->hbt_cookie,(h),(o)))

#define	bus_space_write_1(t,h,o,v) (((t)->hbt_w1)((t)->hbt_cookie,(h),(o),(v)))
#define	bus_space_write_2(t,h,o,v) (((t)->hbt_w2)((t)->hbt_cookie,(h),(o),(v)))
#define	bus_space_write_4(t,h,o,v) (((t)->hbt_w4)((t)->hbt_cookie,(h),(o),(v)))
#define	bus_space_write_8(t,h,o,v) (((t)->hbt_w8)((t)->hbt_cookie,(h),(o),(v)))

#define	bus_space_read_multi_1(t,h,o,a,c) \
	(((t)->hbt_rm_1)((t)->hbt_cookie, (h), (o), (a), (c)))
#define	bus_space_read_multi_2(t,h,o,a,c) \
	(((t)->hbt_rm_2)((t)->hbt_cookie, (h), (o), (a), (c)))
#define	bus_space_read_multi_4(t,h,o,a,c) \
	(((t)->hbt_rm_4)((t)->hbt_cookie, (h), (o), (a), (c)))
#define	bus_space_read_multi_8(t,h,o,a,c) \
	(((t)->hbt_rm_8)((t)->hbt_cookie, (h), (o), (a), (c)))

#define	bus_space_write_multi_1(t,h,o,a,c) \
	(((t)->hbt_wm_1)((t)->hbt_cookie, (h), (o), (a), (c)))
#define	bus_space_write_multi_2(t,h,o,a,c) \
	(((t)->hbt_wm_2)((t)->hbt_cookie, (h), (o), (a), (c)))
#define	bus_space_write_multi_4(t,h,o,a,c) \
	(((t)->hbt_wm_4)((t)->hbt_cookie, (h), (o), (a), (c)))
#define	bus_space_write_multi_8(t,h,o,a,c) \
	(((t)->hbt_wm_8)((t)->hbt_cookie, (h), (o), (a), (c)))

#define	bus_space_set_multi_1(t,h,o,v,c) \
	(((t)->hbt_sm_1)((t)->hbt_cookie, (h), (o), (v), (c)))
#define	bus_space_set_multi_2(t,h,o,v,c) \
	(((t)->hbt_sm_2)((t)->hbt_cookie, (h), (o), (v), (c)))
#define	bus_space_set_multi_4(t,h,o,v,c) \
	(((t)->hbt_sm_4)((t)->hbt_cookie, (h), (o), (v), (c)))
#define	bus_space_set_multi_8(t,h,o,v,c) \
	(((t)->hbt_sm_8)((t)->hbt_cookie, (h), (o), (v), (c)))

#define	bus_space_read_raw_multi_2(t, h, o, a, c) \
	(((t)->hbt_rrm_2)((t)->hbt_cookie, (h), (o), (a), (c)))
#define	bus_space_read_raw_multi_4(t, h, o, a, c) \
	(((t)->hbt_rrm_4)((t)->hbt_cookie, (h), (o), (a), (c)))
#define	bus_space_read_raw_multi_8(t, h, o, a, c) \
	(((t)->hbt_rrm_8)((t)->hbt_cookie, (h), (o), (a), (c)))

#define	bus_space_write_raw_multi_2(t, h, o, a, c) \
	(((t)->hbt_wrm_2)((t)->hbt_cookie, (h), (o), (a), (c)))
#define	bus_space_write_raw_multi_4(t, h, o, a, c) \
	(((t)->hbt_wrm_4)((t)->hbt_cookie, (h), (o), (a), (c)))
#define	bus_space_write_raw_multi_8(t, h, o, a, c) \
	(((t)->hbt_wrm_8)((t)->hbt_cookie, (h), (o), (a), (c)))

#define	bus_space_read_region_1(t, h, o, a, c) \
	(((t)->hbt_rr_1)((t)->hbt_cookie, (h), (o), (a), (c)))
#define	bus_space_read_region_2(t, h, o, a, c) \
	(((t)->hbt_rr_2)((t)->hbt_cookie, (h), (o), (a), (c)))
#define	bus_space_read_region_4(t, h, o, a, c) \
	(((t)->hbt_rr_4)((t)->hbt_cookie, (h), (o), (a), (c)))
#define	bus_space_read_region_8(t, h, o, a, c) \
	(((t)->hbt_rr_8)((t)->hbt_cookie, (h), (o), (a), (c)))

#define	bus_space_write_region_1(t, h, o, a, c) \
	(((t)->hbt_wr_1)((t)->hbt_cookie, (h), (o), (a), (c)))
#define	bus_space_write_region_2(t, h, o, a, c) \
	(((t)->hbt_wr_2)((t)->hbt_cookie, (h), (o), (a), (c)))
#define	bus_space_write_region_4(t, h, o, a, c) \
	(((t)->hbt_wr_4)((t)->hbt_cookie, (h), (o), (a), (c)))
#define	bus_space_write_region_8(t, h, o, a, c) \
	(((t)->hbt_wr_8)((t)->hbt_cookie, (h), (o), (a), (c)))

#define	bus_space_read_raw_region_2(t, h, o, a, c) \
	(((t)->hbt_rrr_2)((t)->hbt_cookie, (h), (o), (a), (c)))
#define	bus_space_read_raw_region_4(t, h, o, a, c) \
	(((t)->hbt_rrr_4)((t)->hbt_cookie, (h), (o), (a), (c)))
#define	bus_space_read_raw_region_8(t, h, o, a, c) \
	(((t)->hbt_rrr_8)((t)->hbt_cookie, (h), (o), (a), (c)))

#define	bus_space_write_raw_region_2(t, h, o, a, c) \
	(((t)->hbt_wrr_2)((t)->hbt_cookie, (h), (o), (a), (c)))
#define	bus_space_write_raw_region_4(t, h, o, a, c) \
	(((t)->hbt_wrr_4)((t)->hbt_cookie, (h), (o), (a), (c)))
#define	bus_space_write_raw_region_8(t, h, o, a, c) \
	(((t)->hbt_wrr_8)((t)->hbt_cookie, (h), (o), (a), (c)))

#define	bus_space_set_region_1(t, h, o, v, c) \
	(((t)->hbt_sr_1)((t)->hbt_cookie, (h), (o), (v), (c)))
#define	bus_space_set_region_2(t, h, o, v, c) \
	(((t)->hbt_sr_2)((t)->hbt_cookie, (h), (o), (v), (c)))
#define	bus_space_set_region_4(t, h, o, v, c) \
	(((t)->hbt_sr_4)((t)->hbt_cookie, (h), (o), (v), (c)))
#define	bus_space_set_region_8(t, h, o, v, c) \
	(((t)->hbt_sr_8)((t)->hbt_cookie, (h), (o), (v), (c)))

#define	bus_space_copy_1(t, h1, o1, h2, o2, c) \
	(((t)->hbt_cp_1)((t)->hbt_cookie, (h1), (o1), (h2), (o2), (c)))
#define	bus_space_copy_2(t, h1, o1, h2, o2, c) \
	(((t)->hbt_cp_2)((t)->hbt_cookie, (h1), (o1), (h2), (o2), (c)))
#define	bus_space_copy_4(t, h1, o1, h2, o2, c) \
	(((t)->hbt_cp_4)((t)->hbt_cookie, (h1), (o1), (h2), (o2), (c)))
#define	bus_space_copy_8(t, h1, o1, h2, o2, c) \
	(((t)->hbt_cp_8)((t)->hbt_cookie, (h1), (o1), (h2), (o2), (c)))

#define	BUS_SPACE_BARRIER_READ	0x01
#define	BUS_SPACE_BARRIER_WRITE	0x02

#define	bus_space_barrier(t,h,o,l,op) \
	((t)->hbt_barrier((t)->hbt_cookie, (h), (o), (l), (op)))
#define	bus_space_vaddr(t,h) \
	((t)->hbt_vaddr((t)->hbt_cookie, (h)))

#define	BUS_DMA_WAITOK		0x0000	/* safe to sleep (pseudo-flag) */
#define	BUS_DMA_NOWAIT		0x0001	/* not safe to sleep */
#define	BUS_DMA_ALLOCNOW	0x0002	/* perform resource allocation now */
#define	BUS_DMA_COHERENT	0x0004	/* hint: map memory DMA coherent */
#define	BUS_DMA_BUS1		0x0020	/* placeholders for bus functions... */
#define	BUS_DMA_BUS2		0x0040
#define	BUS_DMA_BUS3		0x0080
#define	BUS_DMA_BUS4		0x0100
#define	BUS_DMA_STREAMING	0x0200	/* hint: sequential, unidirectional */
#define	BUS_DMA_READ		0x0400	/* mapping is device -> memory only */
#define	BUS_DMA_WRITE		0x0800	/* mapping is memory -> device only */
#define	BUS_DMA_ZERO		0x1000	/* zero memory in dmamem_alloc */

/* Forwards needed by prototypes below. */
struct mbuf;
struct proc;
struct uio;

/* Operations performed by bus_dmamap_sync().  */
#define BUS_DMASYNC_POSTREAD	0x01
#define BUS_DMASYNC_POSTWRITE	0x02
#define BUS_DMASYNC_PREREAD	0x04
#define BUS_DMASYNC_PREWRITE	0x08

typedef const struct hppa_bus_dma_tag	*bus_dma_tag_t;
typedef struct hppa_bus_dmamap	*bus_dmamap_t;

/*
 *	bus_dma_segment_t
 *
 *	Describes a single contiguous DMA transaction.  Values
 *	are suitable for programming into DMA registers.
 */
struct hppa_bus_dma_segment {
	vaddr_t		_ds_va;		/* needed for syncing */

	bus_addr_t	ds_addr;	/* DMA address */
	bus_size_t	ds_len;		/* length of transfer */
};
typedef struct hppa_bus_dma_segment	bus_dma_segment_t;

/*
 *	bus_dma_tag_t
 *
 *	A machine-dependent opaque type describing the implementation of
 *	DMA for a given bus.
 */

struct hppa_bus_dma_tag {
	void	*_cookie;		/* cookie used in the guts */

	/*
	 * DMA mapping methods.
	 */
	int	(*_dmamap_create)(void *, bus_size_t, int,
		    bus_size_t, bus_size_t, int, bus_dmamap_t *);
	void	(*_dmamap_destroy)(void *, bus_dmamap_t);
	int	(*_dmamap_load)(void *, bus_dmamap_t, void *,
		    bus_size_t, struct proc *, int);
	int	(*_dmamap_load_mbuf)(void *, bus_dmamap_t,
		    struct mbuf *, int);
	int	(*_dmamap_load_uio)(void *, bus_dmamap_t,
		    struct uio *, int);
	int	(*_dmamap_load_raw)(void *, bus_dmamap_t,
		    bus_dma_segment_t *, int, bus_size_t, int);
	void	(*_dmamap_unload)(void *, bus_dmamap_t);
	void	(*_dmamap_sync)(void *, bus_dmamap_t, bus_addr_t,
		    bus_size_t, int);

	/*
	 * DMA memory utility functions.
	 */
	int	(*_dmamem_alloc)(void *, bus_size_t, bus_size_t,
		    bus_size_t, bus_dma_segment_t *, int, int *, int);
	void	(*_dmamem_free)(void *, bus_dma_segment_t *, int);
	int	(*_dmamem_map)(void *, bus_dma_segment_t *,
		    int, size_t, caddr_t *, int);
	void	(*_dmamem_unmap)(void *, caddr_t, size_t);
	paddr_t	(*_dmamem_mmap)(void *, bus_dma_segment_t *,
		    int, off_t, int, int);
};

#define	bus_dmamap_create(t, s, n, m, b, f, p)			\
	(*(t)->_dmamap_create)((t)->_cookie, (s), (n), (m), (b), (f), (p))
#define	bus_dmamap_destroy(t, p)				\
	(*(t)->_dmamap_destroy)((t)->_cookie, (p))
#define	bus_dmamap_load(t, m, b, s, p, f)			\
	(*(t)->_dmamap_load)((t)->_cookie, (m), (b), (s), (p), (f))
#define	bus_dmamap_load_mbuf(t, m, b, f)			\
	(*(t)->_dmamap_load_mbuf)((t)->_cookie, (m), (b), (f))
#define	bus_dmamap_load_uio(t, m, u, f)				\
	(*(t)->_dmamap_load_uio)((t)->_cookie, (m), (u), (f))
#define	bus_dmamap_load_raw(t, m, sg, n, s, f)			\
	(*(t)->_dmamap_load_raw)((t)->_cookie, (m), (sg), (n), (s), (f))
#define	bus_dmamap_unload(t, p)					\
	(*(t)->_dmamap_unload)((t)->_cookie, (p))
#define	bus_dmamap_sync(t, p, a, l, o)				\
	(void)((t)->_dmamap_sync ?				\
	    (*(t)->_dmamap_sync)((t)->_cookie, (p), (a), (l), (o)) : (void)0)

#define	bus_dmamem_alloc(t, s, a, b, sg, n, r, f)		\
	(*(t)->_dmamem_alloc)((t)->_cookie, (s), (a), (b), (sg), (n), (r), (f))
#define	bus_dmamem_free(t, sg, n)				\
	(*(t)->_dmamem_free)((t)->_cookie, (sg), (n))
#define	bus_dmamem_map(t, sg, n, s, k, f)			\
	(*(t)->_dmamem_map)((t)->_cookie, (sg), (n), (s), (k), (f))
#define	bus_dmamem_unmap(t, k, s)				\
	(*(t)->_dmamem_unmap)((t)->_cookie, (k), (s))
#define	bus_dmamem_mmap(t, sg, n, o, p, f)			\
	(*(t)->_dmamem_mmap)((t)->_cookie, (sg), (n), (o), (p), (f))

/*
 *	bus_dmamap_t
 *
 *	Describes a DMA mapping.
 */
struct hppa_bus_dmamap {
	/*
	 * PRIVATE MEMBERS: not for use by machine-independent code.
	 */
	bus_size_t	_dm_size;	/* largest DMA transfer mappable */
	int		_dm_segcnt;	/* number of segs this map can map */
	bus_size_t	_dm_maxsegsz;	/* largest possible segment */
	bus_size_t	_dm_boundary;	/* don't cross this */
	int		_dm_flags;	/* misc. flags */

	void		*_dm_cookie;	/* cookie for bus-specific functions */

	/*
	 * PUBLIC MEMBERS: these are used by machine-independent code.
	 */
	bus_size_t	dm_mapsize;	/* size of the mapping */
	int		dm_nsegs;	/* # valid segments in mapping */
	bus_dma_segment_t dm_segs[1];	/* segments; variable length */
};

#endif /* _MACHINE_BUS_H_ */
@


1.30
log
@mindless unification with hppa64; remove meaningless differences before
attacking the complicated stuff
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.29 2010/06/19 14:06:56 miod Exp $	*/
a27 1

@


1.29
log
@Remove unused md BUS_SPACE_MAP_NOEXTENT flag; ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.28 2009/07/30 21:39:54 miod Exp $	*/
d46 2
a47 3
			     int flags, bus_space_handle_t *bshp);
	void (*hbt_unmap)(void *v, bus_space_handle_t bsh,
			       bus_size_t size);
d49 2
a50 2
				   bus_size_t offset, bus_size_t size,
				   bus_space_handle_t *nbshp);
d52 2
a53 3
			       bus_size_t size, bus_size_t align,
			       bus_size_t boundary, int flags,
			       bus_addr_t *addrp, bus_space_handle_t *bshp);
d56 1
a56 1
				 bus_size_t o, bus_size_t l, int op);
d70 1
a70 1
			      bus_size_t o, u_int8_t *a, bus_size_t c);
d72 1
a72 1
			      bus_size_t o, u_int16_t *a, bus_size_t c);
d74 1
a74 1
			      bus_size_t o, u_int32_t *a, bus_size_t c);
d76 1
a76 1
			      bus_size_t o, u_int64_t *a, bus_size_t c);
d79 1
a79 1
			      const u_int8_t *a, bus_size_t c);
d81 1
a81 1
			      const u_int16_t *a, bus_size_t c);
d83 1
a83 1
			      const u_int32_t *a, bus_size_t c);
d85 1
a85 1
			      const u_int64_t *a, bus_size_t c);
d88 1
a88 1
			      u_int8_t  vv, bus_size_t c);
d90 1
a90 1
			      u_int16_t vv, bus_size_t c);
d92 1
a92 1
			      u_int32_t vv, bus_size_t c);
d94 1
a94 1
			      u_int64_t vv, bus_size_t c);
d97 1
a97 1
			       bus_size_t o, u_int8_t *a, bus_size_t c);
d99 1
a99 1
			       bus_size_t o, u_int8_t *a, bus_size_t c);
d101 1
a101 1
			       bus_size_t o, u_int8_t *a, bus_size_t c);
d104 1
a104 1
			       bus_size_t o, const u_int8_t *a, bus_size_t c);
d106 1
a106 1
			       bus_size_t o, const u_int8_t *a, bus_size_t c);
d108 1
a108 1
			       bus_size_t o, const u_int8_t *a, bus_size_t c);
d111 1
a111 1
			      bus_size_t o, u_int8_t *a, bus_size_t c);
d113 1
a113 1
			      bus_size_t o, u_int16_t *a, bus_size_t c);
d115 1
a115 1
			      bus_size_t o, u_int32_t *a, bus_size_t c);
d117 1
a117 1
			      bus_size_t o, u_int64_t *a, bus_size_t c);
d120 1
a120 1
			      bus_size_t o, const u_int8_t *a, bus_size_t c);
d122 1
a122 1
			      bus_size_t o, const u_int16_t *a, bus_size_t c);
d124 1
a124 1
			      bus_size_t o, const u_int32_t *a, bus_size_t c);
d126 1
a126 1
			      bus_size_t o, const u_int64_t *a, bus_size_t c);
d129 1
a129 1
			       bus_size_t o, u_int8_t *a, bus_size_t c);
d131 1
a131 1
			       bus_size_t o, u_int8_t *a, bus_size_t c);
d133 1
a133 1
			       bus_size_t o, u_int8_t *a, bus_size_t c);
d136 1
a136 1
			       bus_size_t o, const u_int8_t *a, bus_size_t c);
d138 1
a138 1
			       bus_size_t o, const u_int8_t *a, bus_size_t c);
d140 1
a140 1
			       bus_size_t o, const u_int8_t *a, bus_size_t c);
d143 1
a143 1
			       bus_size_t o, u_int8_t vv, bus_size_t c);
d145 1
a145 1
			       bus_size_t o, u_int16_t vv, bus_size_t c);
d147 1
a147 1
			       bus_size_t o, u_int32_t vv, bus_size_t c);
d149 1
a149 1
			       bus_size_t o, u_int64_t vv, bus_size_t c);
d152 1
a152 1
			      bus_space_handle_t h2, bus_size_t o2, bus_size_t c);
d154 1
a154 1
			      bus_space_handle_t h2, bus_size_t o2, bus_size_t c);
d156 1
a156 1
			      bus_space_handle_t h2, bus_size_t o2, bus_size_t c);
d158 1
a158 1
			      bus_space_handle_t h2, bus_size_t o2, bus_size_t c);
@


1.28
log
@Make sure the BUS_SPACE_BARRIER_xxx constants are all non-zero and can be
or'ed together, even on platforms where bus_space_barrier() ignores the
barrier argument yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.27 2009/05/31 17:42:11 miod Exp $	*/
a169 1
#define	BUS_SPACE_MAP_NOEXTENT		0x8000	/* no extent ops */
@


1.27
log
@Remove BUS_DMAMEM_NOSYNC definition. Its name is not consistent with
other BUS_DMA_xxx flag names, and nothing uses it.

ok many@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.26 2009/04/20 00:42:06 oga Exp $	*/
d286 2
a287 2
#define	BUS_SPACE_BARRIER_READ	0
#define	BUS_SPACE_BARRIER_WRITE	1
@


1.26
log
@Add a BUS_DMA_ZERO flag for bus_dmamem_alloc() to return zeroed memory.

Saves every damned driver calling bzero(), and continues the M_ZERO,
PR_ZERO symmetry.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.25 2007/05/23 18:07:19 kettenis Exp $	*/
a297 1
#define	BUS_DMAMEM_NOSYNC	0x0010
@


1.25
log
@Add proper bus_space_vaddr() implementation.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.24 2005/01/09 06:58:51 mickey Exp $	*/
d294 13
a306 12
#define	BUS_DMA_WAITOK		0x000	/* safe to sleep (pseudo-flag) */
#define	BUS_DMA_NOWAIT		0x001	/* not safe to sleep */
#define	BUS_DMA_ALLOCNOW	0x002	/* perform resource allocation now */
#define	BUS_DMA_COHERENT	0x004	/* hint: map memory DMA coherent */
#define	BUS_DMAMEM_NOSYNC	0x010
#define	BUS_DMA_BUS1		0x020	/* placeholders for bus functions... */
#define	BUS_DMA_BUS2		0x040
#define	BUS_DMA_BUS3		0x080
#define	BUS_DMA_BUS4		0x100
#define	BUS_DMA_STREAMING	0x200	/* hint: sequential, unidirectional */
#define	BUS_DMA_READ		0x400	/* mapping is device -> memory only */
#define	BUS_DMA_WRITE		0x800	/* mapping is memory -> device only */
@


1.24
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.23 2004/04/07 18:24:19 mickey Exp $	*/
d59 1
d291 2
a292 2
#define	bus_space_vaddr(t,h,o,l,op) \
	((t)->hbt_vaddr((t)->hbt_cookie, (h), (o), (l), (op)))
@


1.23
log
@update copyright; miod@@ is fine w/ files where he holds it too
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.22 2004/03/02 21:06:15 mickey Exp $	*/
d180 1
a180 1
	(((t)->hbt_alloc)((t)->hbt_alloc,(b),(e),(c),(al),(bn),(ca),(ap),(hp)))
@


1.22
log
@track va for each segment and not for the whole map.
simplifies the cache syncing a lot.
testing by miod@@ and mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.21 2003/09/29 19:23:02 mickey Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998,1999 Michael Shalayeff
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Michael Shalayeff.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.21
log
@dino/cujo pci bridge
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.20 2003/03/29 00:58:50 mickey Exp $	*/
d332 2
a422 1
	vaddr_t		_dm_va;		/* needed for syncing */
@


1.20
log
@bus_space_vaddr and related definitions (needs actual implementations)
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.19 2002/03/14 01:26:32 millert Exp $	*/
d51 1
a51 1
			     int cacheable, bus_space_handle_t *bshp);
d59 1
a59 1
			       bus_size_t boundary, int cacheable,
d174 1
@


1.19
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.18 2002/03/07 18:08:08 jason Exp $	*/
d169 6
d294 2
@


1.18
log
@Clean up BUS_DMA_* flags, and make sure all arch's define:
BUS_DMA_READ, BUS_DMA_WRITE, and BUS_DMA_STREAMING
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.17 2002/02/16 03:13:32 mickey Exp $	*/
d50 5
a54 5
	int  (*hbt_map) __P((void *v, bus_addr_t addr, bus_size_t size,
			     int cacheable, bus_space_handle_t *bshp));
	void (*hbt_unmap) __P((void *v, bus_space_handle_t bsh,
			       bus_size_t size));
	int  (*hbt_subregion) __P((void *v, bus_space_handle_t bsh,
d56 2
a57 2
				   bus_space_handle_t *nbshp));
	int  (*hbt_alloc) __P((void *v, bus_addr_t rstart, bus_addr_t rend,
d60 105
a164 105
			       bus_addr_t *addrp, bus_space_handle_t *bshp));
	void (*hbt_free) __P((void *, bus_space_handle_t, bus_size_t));
	void (*hbt_barrier) __P((void *v, bus_space_handle_t h,
				 bus_size_t o, bus_size_t l, int op));

	u_int8_t  (*hbt_r1) __P((void *, bus_space_handle_t, bus_size_t));
	u_int16_t (*hbt_r2) __P((void *, bus_space_handle_t, bus_size_t));
	u_int32_t (*hbt_r4) __P((void *, bus_space_handle_t, bus_size_t));
	u_int64_t (*hbt_r8) __P((void *, bus_space_handle_t, bus_size_t));

	void (*hbt_w1)__P((void *, bus_space_handle_t, bus_size_t, u_int8_t));
	void (*hbt_w2)__P((void *, bus_space_handle_t, bus_size_t, u_int16_t));
	void (*hbt_w4)__P((void *, bus_space_handle_t, bus_size_t, u_int32_t));
	void (*hbt_w8)__P((void *, bus_space_handle_t, bus_size_t, u_int64_t));

	void (*hbt_rm_1) __P((void *v, bus_space_handle_t h,
			      bus_size_t o, u_int8_t *a, bus_size_t c));
	void (*hbt_rm_2) __P((void *v, bus_space_handle_t h,
			      bus_size_t o, u_int16_t *a, bus_size_t c));
	void (*hbt_rm_4) __P((void *v, bus_space_handle_t h,
			      bus_size_t o, u_int32_t *a, bus_size_t c));
	void (*hbt_rm_8) __P((void *v, bus_space_handle_t h,
			      bus_size_t o, u_int64_t *a, bus_size_t c));

	void (*hbt_wm_1) __P((void *v, bus_space_handle_t h, bus_size_t o,
			      const u_int8_t *a, bus_size_t c));
	void (*hbt_wm_2) __P((void *v, bus_space_handle_t h, bus_size_t o,
			      const u_int16_t *a, bus_size_t c));
	void (*hbt_wm_4) __P((void *v, bus_space_handle_t h, bus_size_t o,
			      const u_int32_t *a, bus_size_t c));
	void (*hbt_wm_8) __P((void *v, bus_space_handle_t h, bus_size_t o,
			      const u_int64_t *a, bus_size_t c));

	void (*hbt_sm_1) __P((void *v, bus_space_handle_t h, bus_size_t o,
			      u_int8_t  vv, bus_size_t c));
	void (*hbt_sm_2) __P((void *v, bus_space_handle_t h, bus_size_t o,
			      u_int16_t vv, bus_size_t c));
	void (*hbt_sm_4) __P((void *v, bus_space_handle_t h, bus_size_t o,
			      u_int32_t vv, bus_size_t c));
	void (*hbt_sm_8) __P((void *v, bus_space_handle_t h, bus_size_t o,
			      u_int64_t vv, bus_size_t c));

	void (*hbt_rrm_2) __P((void *v, bus_space_handle_t h,
			       bus_size_t o, u_int8_t *a, bus_size_t c));
	void (*hbt_rrm_4) __P((void *v, bus_space_handle_t h,
			       bus_size_t o, u_int8_t *a, bus_size_t c));
	void (*hbt_rrm_8) __P((void *v, bus_space_handle_t h,
			       bus_size_t o, u_int8_t *a, bus_size_t c));

	void (*hbt_wrm_2) __P((void *v, bus_space_handle_t h,
			       bus_size_t o, const u_int8_t *a, bus_size_t c));
	void (*hbt_wrm_4) __P((void *v, bus_space_handle_t h,
			       bus_size_t o, const u_int8_t *a, bus_size_t c));
	void (*hbt_wrm_8) __P((void *v, bus_space_handle_t h,
			       bus_size_t o, const u_int8_t *a, bus_size_t c));

	void (*hbt_rr_1) __P((void *v, bus_space_handle_t h,
			      bus_size_t o, u_int8_t *a, bus_size_t c));
	void (*hbt_rr_2) __P((void *v, bus_space_handle_t h,
			      bus_size_t o, u_int16_t *a, bus_size_t c));
	void (*hbt_rr_4) __P((void *v, bus_space_handle_t h,
			      bus_size_t o, u_int32_t *a, bus_size_t c));
	void (*hbt_rr_8) __P((void *v, bus_space_handle_t h,
			      bus_size_t o, u_int64_t *a, bus_size_t c));

	void (*hbt_wr_1) __P((void *v, bus_space_handle_t h,
			      bus_size_t o, const u_int8_t *a, bus_size_t c));
	void (*hbt_wr_2) __P((void *v, bus_space_handle_t h,
			      bus_size_t o, const u_int16_t *a, bus_size_t c));
	void (*hbt_wr_4) __P((void *v, bus_space_handle_t h,
			      bus_size_t o, const u_int32_t *a, bus_size_t c));
	void (*hbt_wr_8) __P((void *v, bus_space_handle_t h,
			      bus_size_t o, const u_int64_t *a, bus_size_t c));

	void (*hbt_rrr_2) __P((void *v, bus_space_handle_t h,
			       bus_size_t o, u_int8_t *a, bus_size_t c));
	void (*hbt_rrr_4) __P((void *v, bus_space_handle_t h,
			       bus_size_t o, u_int8_t *a, bus_size_t c));
	void (*hbt_rrr_8) __P((void *v, bus_space_handle_t h,
			       bus_size_t o, u_int8_t *a, bus_size_t c));

	void (*hbt_wrr_2) __P((void *v, bus_space_handle_t h,
			       bus_size_t o, const u_int8_t *a, bus_size_t c));
	void (*hbt_wrr_4) __P((void *v, bus_space_handle_t h,
			       bus_size_t o, const u_int8_t *a, bus_size_t c));
	void (*hbt_wrr_8) __P((void *v, bus_space_handle_t h,
			       bus_size_t o, const u_int8_t *a, bus_size_t c));

	void (*hbt_sr_1) __P((void *v, bus_space_handle_t h,
			       bus_size_t o, u_int8_t vv, bus_size_t c));
	void (*hbt_sr_2) __P((void *v, bus_space_handle_t h,
			       bus_size_t o, u_int16_t vv, bus_size_t c));
	void (*hbt_sr_4) __P((void *v, bus_space_handle_t h,
			       bus_size_t o, u_int32_t vv, bus_size_t c));
	void (*hbt_sr_8) __P((void *v, bus_space_handle_t h,
			       bus_size_t o, u_int64_t vv, bus_size_t c));

	void (*hbt_cp_1) __P((void *v, bus_space_handle_t h1, bus_size_t o1,
			      bus_space_handle_t h2, bus_size_t o2, bus_size_t c));
	void (*hbt_cp_2) __P((void *v, bus_space_handle_t h1, bus_size_t o1,
			      bus_space_handle_t h2, bus_size_t o2, bus_size_t c));
	void (*hbt_cp_4) __P((void *v, bus_space_handle_t h1, bus_size_t o1,
			      bus_space_handle_t h2, bus_size_t o2, bus_size_t c));
	void (*hbt_cp_8) __P((void *v, bus_space_handle_t h1, bus_size_t o1,
			      bus_space_handle_t h2, bus_size_t o2, bus_size_t c));
d341 14
a354 14
	int	(*_dmamap_create) __P((void *, bus_size_t, int,
		    bus_size_t, bus_size_t, int, bus_dmamap_t *));
	void	(*_dmamap_destroy) __P((void *, bus_dmamap_t));
	int	(*_dmamap_load) __P((void *, bus_dmamap_t, void *,
		    bus_size_t, struct proc *, int));
	int	(*_dmamap_load_mbuf) __P((void *, bus_dmamap_t,
		    struct mbuf *, int));
	int	(*_dmamap_load_uio) __P((void *, bus_dmamap_t,
		    struct uio *, int));
	int	(*_dmamap_load_raw) __P((void *, bus_dmamap_t,
		    bus_dma_segment_t *, int, bus_size_t, int));
	void	(*_dmamap_unload) __P((void *, bus_dmamap_t));
	void	(*_dmamap_sync) __P((void *, bus_dmamap_t, bus_addr_t,
		    bus_size_t, int));
d359 8
a366 8
	int	(*_dmamem_alloc) __P((void *, bus_size_t, bus_size_t,
		    bus_size_t, bus_dma_segment_t *, int, int *, int));
	void	(*_dmamem_free) __P((void *, bus_dma_segment_t *, int));
	int	(*_dmamem_map) __P((void *, bus_dma_segment_t *,
		    int, size_t, caddr_t *, int));
	void	(*_dmamem_unmap) __P((void *, caddr_t, size_t));
	paddr_t	(*_dmamem_mmap) __P((void *, bus_dma_segment_t *,
		    int, off_t, int, int));
@


1.17
log
@there are bugs, and then there are pastos
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.16 2002/02/16 02:40:12 mickey Exp $	*/
d289 12
a300 5
#define	BUS_DMA_WAITOK		0x00
#define	BUS_DMA_NOWAIT		0x01
#define	BUS_DMA_ALLOCNOW	0x02
#define	BUS_DMA_COHERENT	0x04
#define	BUS_DMAMEM_NOSYNC	0x10
@


1.16
log
@remove bogus DCIAS (used to be used for scsi driver
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.15 2002/02/16 02:21:56 mickey Exp $	*/
d412 1
a414 1
	bus_size_t	dm_mapsize;	/* size of the mapping */
@


1.15
log
@implement a few dma methods; from fredette@@. some fixes from me
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.14 2001/11/05 17:25:57 art Exp $	*/
a169 1
#define DCIAS(pa)	((void)(pa))
@


1.14
log
@Switch everything to the new bus_dmamap_sync API.
Most work by Wilbern Cobb <vedge@@csoft.org> with some fixes from me, mickey@@
and drahn@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.13 2001/07/30 14:15:59 art Exp $	*/
d406 1
d415 1
@


1.14.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.14 2001/11/05 17:25:57 art Exp $	*/
d50 5
a54 5
	int  (*hbt_map)(void *v, bus_addr_t addr, bus_size_t size,
			     int cacheable, bus_space_handle_t *bshp);
	void (*hbt_unmap)(void *v, bus_space_handle_t bsh,
			       bus_size_t size);
	int  (*hbt_subregion)(void *v, bus_space_handle_t bsh,
d56 2
a57 2
				   bus_space_handle_t *nbshp);
	int  (*hbt_alloc)(void *v, bus_addr_t rstart, bus_addr_t rend,
d60 105
a164 105
			       bus_addr_t *addrp, bus_space_handle_t *bshp);
	void (*hbt_free)(void *, bus_space_handle_t, bus_size_t);
	void (*hbt_barrier)(void *v, bus_space_handle_t h,
				 bus_size_t o, bus_size_t l, int op);

	u_int8_t  (*hbt_r1)(void *, bus_space_handle_t, bus_size_t);
	u_int16_t (*hbt_r2)(void *, bus_space_handle_t, bus_size_t);
	u_int32_t (*hbt_r4)(void *, bus_space_handle_t, bus_size_t);
	u_int64_t (*hbt_r8)(void *, bus_space_handle_t, bus_size_t);

	void (*hbt_w1)(void *, bus_space_handle_t, bus_size_t, u_int8_t);
	void (*hbt_w2)(void *, bus_space_handle_t, bus_size_t, u_int16_t);
	void (*hbt_w4)(void *, bus_space_handle_t, bus_size_t, u_int32_t);
	void (*hbt_w8)(void *, bus_space_handle_t, bus_size_t, u_int64_t);

	void (*hbt_rm_1)(void *v, bus_space_handle_t h,
			      bus_size_t o, u_int8_t *a, bus_size_t c);
	void (*hbt_rm_2)(void *v, bus_space_handle_t h,
			      bus_size_t o, u_int16_t *a, bus_size_t c);
	void (*hbt_rm_4)(void *v, bus_space_handle_t h,
			      bus_size_t o, u_int32_t *a, bus_size_t c);
	void (*hbt_rm_8)(void *v, bus_space_handle_t h,
			      bus_size_t o, u_int64_t *a, bus_size_t c);

	void (*hbt_wm_1)(void *v, bus_space_handle_t h, bus_size_t o,
			      const u_int8_t *a, bus_size_t c);
	void (*hbt_wm_2)(void *v, bus_space_handle_t h, bus_size_t o,
			      const u_int16_t *a, bus_size_t c);
	void (*hbt_wm_4)(void *v, bus_space_handle_t h, bus_size_t o,
			      const u_int32_t *a, bus_size_t c);
	void (*hbt_wm_8)(void *v, bus_space_handle_t h, bus_size_t o,
			      const u_int64_t *a, bus_size_t c);

	void (*hbt_sm_1)(void *v, bus_space_handle_t h, bus_size_t o,
			      u_int8_t  vv, bus_size_t c);
	void (*hbt_sm_2)(void *v, bus_space_handle_t h, bus_size_t o,
			      u_int16_t vv, bus_size_t c);
	void (*hbt_sm_4)(void *v, bus_space_handle_t h, bus_size_t o,
			      u_int32_t vv, bus_size_t c);
	void (*hbt_sm_8)(void *v, bus_space_handle_t h, bus_size_t o,
			      u_int64_t vv, bus_size_t c);

	void (*hbt_rrm_2)(void *v, bus_space_handle_t h,
			       bus_size_t o, u_int8_t *a, bus_size_t c);
	void (*hbt_rrm_4)(void *v, bus_space_handle_t h,
			       bus_size_t o, u_int8_t *a, bus_size_t c);
	void (*hbt_rrm_8)(void *v, bus_space_handle_t h,
			       bus_size_t o, u_int8_t *a, bus_size_t c);

	void (*hbt_wrm_2)(void *v, bus_space_handle_t h,
			       bus_size_t o, const u_int8_t *a, bus_size_t c);
	void (*hbt_wrm_4)(void *v, bus_space_handle_t h,
			       bus_size_t o, const u_int8_t *a, bus_size_t c);
	void (*hbt_wrm_8)(void *v, bus_space_handle_t h,
			       bus_size_t o, const u_int8_t *a, bus_size_t c);

	void (*hbt_rr_1)(void *v, bus_space_handle_t h,
			      bus_size_t o, u_int8_t *a, bus_size_t c);
	void (*hbt_rr_2)(void *v, bus_space_handle_t h,
			      bus_size_t o, u_int16_t *a, bus_size_t c);
	void (*hbt_rr_4)(void *v, bus_space_handle_t h,
			      bus_size_t o, u_int32_t *a, bus_size_t c);
	void (*hbt_rr_8)(void *v, bus_space_handle_t h,
			      bus_size_t o, u_int64_t *a, bus_size_t c);

	void (*hbt_wr_1)(void *v, bus_space_handle_t h,
			      bus_size_t o, const u_int8_t *a, bus_size_t c);
	void (*hbt_wr_2)(void *v, bus_space_handle_t h,
			      bus_size_t o, const u_int16_t *a, bus_size_t c);
	void (*hbt_wr_4)(void *v, bus_space_handle_t h,
			      bus_size_t o, const u_int32_t *a, bus_size_t c);
	void (*hbt_wr_8)(void *v, bus_space_handle_t h,
			      bus_size_t o, const u_int64_t *a, bus_size_t c);

	void (*hbt_rrr_2)(void *v, bus_space_handle_t h,
			       bus_size_t o, u_int8_t *a, bus_size_t c);
	void (*hbt_rrr_4)(void *v, bus_space_handle_t h,
			       bus_size_t o, u_int8_t *a, bus_size_t c);
	void (*hbt_rrr_8)(void *v, bus_space_handle_t h,
			       bus_size_t o, u_int8_t *a, bus_size_t c);

	void (*hbt_wrr_2)(void *v, bus_space_handle_t h,
			       bus_size_t o, const u_int8_t *a, bus_size_t c);
	void (*hbt_wrr_4)(void *v, bus_space_handle_t h,
			       bus_size_t o, const u_int8_t *a, bus_size_t c);
	void (*hbt_wrr_8)(void *v, bus_space_handle_t h,
			       bus_size_t o, const u_int8_t *a, bus_size_t c);

	void (*hbt_sr_1)(void *v, bus_space_handle_t h,
			       bus_size_t o, u_int8_t vv, bus_size_t c);
	void (*hbt_sr_2)(void *v, bus_space_handle_t h,
			       bus_size_t o, u_int16_t vv, bus_size_t c);
	void (*hbt_sr_4)(void *v, bus_space_handle_t h,
			       bus_size_t o, u_int32_t vv, bus_size_t c);
	void (*hbt_sr_8)(void *v, bus_space_handle_t h,
			       bus_size_t o, u_int64_t vv, bus_size_t c);

	void (*hbt_cp_1)(void *v, bus_space_handle_t h1, bus_size_t o1,
			      bus_space_handle_t h2, bus_size_t o2, bus_size_t c);
	void (*hbt_cp_2)(void *v, bus_space_handle_t h1, bus_size_t o1,
			      bus_space_handle_t h2, bus_size_t o2, bus_size_t c);
	void (*hbt_cp_4)(void *v, bus_space_handle_t h1, bus_size_t o1,
			      bus_space_handle_t h2, bus_size_t o2, bus_size_t c);
	void (*hbt_cp_8)(void *v, bus_space_handle_t h1, bus_size_t o1,
			      bus_space_handle_t h2, bus_size_t o2, bus_size_t c);
d170 1
d290 5
a294 12
#define	BUS_DMA_WAITOK		0x000	/* safe to sleep (pseudo-flag) */
#define	BUS_DMA_NOWAIT		0x001	/* not safe to sleep */
#define	BUS_DMA_ALLOCNOW	0x002	/* perform resource allocation now */
#define	BUS_DMA_COHERENT	0x004	/* hint: map memory DMA coherent */
#define	BUS_DMAMEM_NOSYNC	0x010
#define	BUS_DMA_BUS1		0x020	/* placeholders for bus functions... */
#define	BUS_DMA_BUS2		0x040
#define	BUS_DMA_BUS3		0x080
#define	BUS_DMA_BUS4		0x100
#define	BUS_DMA_STREAMING	0x200	/* hint: sequential, unidirectional */
#define	BUS_DMA_READ		0x400	/* mapping is device -> memory only */
#define	BUS_DMA_WRITE		0x800	/* mapping is memory -> device only */
d335 14
a348 14
	int	(*_dmamap_create)(void *, bus_size_t, int,
		    bus_size_t, bus_size_t, int, bus_dmamap_t *);
	void	(*_dmamap_destroy)(void *, bus_dmamap_t);
	int	(*_dmamap_load)(void *, bus_dmamap_t, void *,
		    bus_size_t, struct proc *, int);
	int	(*_dmamap_load_mbuf)(void *, bus_dmamap_t,
		    struct mbuf *, int);
	int	(*_dmamap_load_uio)(void *, bus_dmamap_t,
		    struct uio *, int);
	int	(*_dmamap_load_raw)(void *, bus_dmamap_t,
		    bus_dma_segment_t *, int, bus_size_t, int);
	void	(*_dmamap_unload)(void *, bus_dmamap_t);
	void	(*_dmamap_sync)(void *, bus_dmamap_t, bus_addr_t,
		    bus_size_t, int);
d353 8
a360 8
	int	(*_dmamem_alloc)(void *, bus_size_t, bus_size_t,
		    bus_size_t, bus_dma_segment_t *, int, int *, int);
	void	(*_dmamem_free)(void *, bus_dma_segment_t *, int);
	int	(*_dmamem_map)(void *, bus_dma_segment_t *,
		    int, size_t, caddr_t *, int);
	void	(*_dmamem_unmap)(void *, caddr_t, size_t);
	paddr_t	(*_dmamem_mmap)(void *, bus_dma_segment_t *,
		    int, off_t, int, int);
a405 1
	vaddr_t		_dm_va;		/* needed for syncing */
a411 1
	bus_size_t	dm_mapsize;	/* size of the mapping */
@


1.14.2.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a168 6
/* flags for bus space map functions */
#define	BUS_SPACE_MAP_CACHEABLE		0x0001
#define	BUS_SPACE_MAP_LINEAR		0x0002
#define	BUS_SPACE_MAP_READONLY		0x0004
#define	BUS_SPACE_MAP_PREFETCHABLE	0x0008

a287 2
#define	bus_space_vaddr(t,h,o,l,op) \
	((t)->hbt_vaddr((t)->hbt_cookie, (h), (o), (l), (op)))
@


1.13
log
@Change:
int bus_dmamem_mmap(bus_dma_tag_t, bus_dma_segment_t, int, int, int, int);
to:
paddr_t bus_dmamem_mmap(bus_dma_tag_t, bus_dma_segment_t, int, int, off_t, int);

To allow mmaping offsets larger than INT_MAX. And to simply make more sense.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.12 2000/06/15 19:05:09 mickey Exp $	*/
d301 5
a305 6
typedef enum {
	BUS_DMASYNC_POSTREAD,
	BUS_DMASYNC_POSTWRITE,
	BUS_DMASYNC_PREREAD,
	BUS_DMASYNC_PREWRITE
} bus_dmasync_op_t;
d347 2
a348 1
	void	(*_dmamap_sync) __P((void *, bus_dmamap_t, bus_dmasync_op_t));
d377 1
a377 1
#define	bus_dmamap_sync(t, p, o)				\
d379 1
a379 1
	    (*(t)->_dmamap_sync)((t)->_cookie, (p), (o)) : (void)0)
@


1.12
log
@add BUS_DMA_COHERENT, fix BUS_DMAMEM_NOSYNC
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.11 2000/01/29 03:12:12 mickey Exp $	*/
d359 2
a360 2
	int	(*_dmamem_mmap) __P((void *, bus_dma_segment_t *,
		    int, int, int, int));
@


1.11
log
@repair busdma calls w/o cookies
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.10 1999/11/26 17:34:59 mickey Exp $	*/
d293 2
a294 1
#define	BUS_DMAMEM_NOSYNC	0x04
@


1.11.2.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.12 2000/06/15 19:05:09 mickey Exp $	*/
d293 1
a293 2
#define	BUS_DMA_COHERENT	0x04
#define	BUS_DMAMEM_NOSYNC	0x10
@


1.11.2.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.11.2.1 2001/04/18 16:06:18 niklas Exp $	*/
d359 2
a360 2
	paddr_t	(*_dmamem_mmap) __P((void *, bus_dma_segment_t *,
		    int, off_t, int, int));
@


1.11.2.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d301 6
a306 5
/* Operations performed by bus_dmamap_sync().  */
#define BUS_DMASYNC_POSTREAD	0x01
#define BUS_DMASYNC_POSTWRITE	0x02
#define BUS_DMASYNC_PREREAD	0x04
#define BUS_DMASYNC_PREWRITE	0x08
d348 1
a348 2
	void	(*_dmamap_sync) __P((void *, bus_dmamap_t, bus_addr_t,
		    bus_size_t, int));
d377 1
a377 1
#define	bus_dmamap_sync(t, p, a, l, o)				\
d379 1
a379 1
	    (*(t)->_dmamap_sync)((t)->_cookie, (p), (a), (l), (o)) : (void)0)
@


1.11.2.4
log
@Merge in trunk
@
text
@d170 1
a405 1
	vaddr_t		_dm_va;		/* needed for syncing */
a411 1
	bus_size_t	dm_mapsize;	/* size of the mapping */
@


1.11.2.5
log
@Merge in -current from about a week ago
@
text
@d50 5
a54 5
	int  (*hbt_map)(void *v, bus_addr_t addr, bus_size_t size,
			     int cacheable, bus_space_handle_t *bshp);
	void (*hbt_unmap)(void *v, bus_space_handle_t bsh,
			       bus_size_t size);
	int  (*hbt_subregion)(void *v, bus_space_handle_t bsh,
d56 2
a57 2
				   bus_space_handle_t *nbshp);
	int  (*hbt_alloc)(void *v, bus_addr_t rstart, bus_addr_t rend,
d60 105
a164 105
			       bus_addr_t *addrp, bus_space_handle_t *bshp);
	void (*hbt_free)(void *, bus_space_handle_t, bus_size_t);
	void (*hbt_barrier)(void *v, bus_space_handle_t h,
				 bus_size_t o, bus_size_t l, int op);

	u_int8_t  (*hbt_r1)(void *, bus_space_handle_t, bus_size_t);
	u_int16_t (*hbt_r2)(void *, bus_space_handle_t, bus_size_t);
	u_int32_t (*hbt_r4)(void *, bus_space_handle_t, bus_size_t);
	u_int64_t (*hbt_r8)(void *, bus_space_handle_t, bus_size_t);

	void (*hbt_w1)(void *, bus_space_handle_t, bus_size_t, u_int8_t);
	void (*hbt_w2)(void *, bus_space_handle_t, bus_size_t, u_int16_t);
	void (*hbt_w4)(void *, bus_space_handle_t, bus_size_t, u_int32_t);
	void (*hbt_w8)(void *, bus_space_handle_t, bus_size_t, u_int64_t);

	void (*hbt_rm_1)(void *v, bus_space_handle_t h,
			      bus_size_t o, u_int8_t *a, bus_size_t c);
	void (*hbt_rm_2)(void *v, bus_space_handle_t h,
			      bus_size_t o, u_int16_t *a, bus_size_t c);
	void (*hbt_rm_4)(void *v, bus_space_handle_t h,
			      bus_size_t o, u_int32_t *a, bus_size_t c);
	void (*hbt_rm_8)(void *v, bus_space_handle_t h,
			      bus_size_t o, u_int64_t *a, bus_size_t c);

	void (*hbt_wm_1)(void *v, bus_space_handle_t h, bus_size_t o,
			      const u_int8_t *a, bus_size_t c);
	void (*hbt_wm_2)(void *v, bus_space_handle_t h, bus_size_t o,
			      const u_int16_t *a, bus_size_t c);
	void (*hbt_wm_4)(void *v, bus_space_handle_t h, bus_size_t o,
			      const u_int32_t *a, bus_size_t c);
	void (*hbt_wm_8)(void *v, bus_space_handle_t h, bus_size_t o,
			      const u_int64_t *a, bus_size_t c);

	void (*hbt_sm_1)(void *v, bus_space_handle_t h, bus_size_t o,
			      u_int8_t  vv, bus_size_t c);
	void (*hbt_sm_2)(void *v, bus_space_handle_t h, bus_size_t o,
			      u_int16_t vv, bus_size_t c);
	void (*hbt_sm_4)(void *v, bus_space_handle_t h, bus_size_t o,
			      u_int32_t vv, bus_size_t c);
	void (*hbt_sm_8)(void *v, bus_space_handle_t h, bus_size_t o,
			      u_int64_t vv, bus_size_t c);

	void (*hbt_rrm_2)(void *v, bus_space_handle_t h,
			       bus_size_t o, u_int8_t *a, bus_size_t c);
	void (*hbt_rrm_4)(void *v, bus_space_handle_t h,
			       bus_size_t o, u_int8_t *a, bus_size_t c);
	void (*hbt_rrm_8)(void *v, bus_space_handle_t h,
			       bus_size_t o, u_int8_t *a, bus_size_t c);

	void (*hbt_wrm_2)(void *v, bus_space_handle_t h,
			       bus_size_t o, const u_int8_t *a, bus_size_t c);
	void (*hbt_wrm_4)(void *v, bus_space_handle_t h,
			       bus_size_t o, const u_int8_t *a, bus_size_t c);
	void (*hbt_wrm_8)(void *v, bus_space_handle_t h,
			       bus_size_t o, const u_int8_t *a, bus_size_t c);

	void (*hbt_rr_1)(void *v, bus_space_handle_t h,
			      bus_size_t o, u_int8_t *a, bus_size_t c);
	void (*hbt_rr_2)(void *v, bus_space_handle_t h,
			      bus_size_t o, u_int16_t *a, bus_size_t c);
	void (*hbt_rr_4)(void *v, bus_space_handle_t h,
			      bus_size_t o, u_int32_t *a, bus_size_t c);
	void (*hbt_rr_8)(void *v, bus_space_handle_t h,
			      bus_size_t o, u_int64_t *a, bus_size_t c);

	void (*hbt_wr_1)(void *v, bus_space_handle_t h,
			      bus_size_t o, const u_int8_t *a, bus_size_t c);
	void (*hbt_wr_2)(void *v, bus_space_handle_t h,
			      bus_size_t o, const u_int16_t *a, bus_size_t c);
	void (*hbt_wr_4)(void *v, bus_space_handle_t h,
			      bus_size_t o, const u_int32_t *a, bus_size_t c);
	void (*hbt_wr_8)(void *v, bus_space_handle_t h,
			      bus_size_t o, const u_int64_t *a, bus_size_t c);

	void (*hbt_rrr_2)(void *v, bus_space_handle_t h,
			       bus_size_t o, u_int8_t *a, bus_size_t c);
	void (*hbt_rrr_4)(void *v, bus_space_handle_t h,
			       bus_size_t o, u_int8_t *a, bus_size_t c);
	void (*hbt_rrr_8)(void *v, bus_space_handle_t h,
			       bus_size_t o, u_int8_t *a, bus_size_t c);

	void (*hbt_wrr_2)(void *v, bus_space_handle_t h,
			       bus_size_t o, const u_int8_t *a, bus_size_t c);
	void (*hbt_wrr_4)(void *v, bus_space_handle_t h,
			       bus_size_t o, const u_int8_t *a, bus_size_t c);
	void (*hbt_wrr_8)(void *v, bus_space_handle_t h,
			       bus_size_t o, const u_int8_t *a, bus_size_t c);

	void (*hbt_sr_1)(void *v, bus_space_handle_t h,
			       bus_size_t o, u_int8_t vv, bus_size_t c);
	void (*hbt_sr_2)(void *v, bus_space_handle_t h,
			       bus_size_t o, u_int16_t vv, bus_size_t c);
	void (*hbt_sr_4)(void *v, bus_space_handle_t h,
			       bus_size_t o, u_int32_t vv, bus_size_t c);
	void (*hbt_sr_8)(void *v, bus_space_handle_t h,
			       bus_size_t o, u_int64_t vv, bus_size_t c);

	void (*hbt_cp_1)(void *v, bus_space_handle_t h1, bus_size_t o1,
			      bus_space_handle_t h2, bus_size_t o2, bus_size_t c);
	void (*hbt_cp_2)(void *v, bus_space_handle_t h1, bus_size_t o1,
			      bus_space_handle_t h2, bus_size_t o2, bus_size_t c);
	void (*hbt_cp_4)(void *v, bus_space_handle_t h1, bus_size_t o1,
			      bus_space_handle_t h2, bus_size_t o2, bus_size_t c);
	void (*hbt_cp_8)(void *v, bus_space_handle_t h1, bus_size_t o1,
			      bus_space_handle_t h2, bus_size_t o2, bus_size_t c);
d289 5
a293 12
#define	BUS_DMA_WAITOK		0x000	/* safe to sleep (pseudo-flag) */
#define	BUS_DMA_NOWAIT		0x001	/* not safe to sleep */
#define	BUS_DMA_ALLOCNOW	0x002	/* perform resource allocation now */
#define	BUS_DMA_COHERENT	0x004	/* hint: map memory DMA coherent */
#define	BUS_DMAMEM_NOSYNC	0x010
#define	BUS_DMA_BUS1		0x020	/* placeholders for bus functions... */
#define	BUS_DMA_BUS2		0x040
#define	BUS_DMA_BUS3		0x080
#define	BUS_DMA_BUS4		0x100
#define	BUS_DMA_STREAMING	0x200	/* hint: sequential, unidirectional */
#define	BUS_DMA_READ		0x400	/* mapping is device -> memory only */
#define	BUS_DMA_WRITE		0x800	/* mapping is memory -> device only */
d334 14
a347 14
	int	(*_dmamap_create)(void *, bus_size_t, int,
		    bus_size_t, bus_size_t, int, bus_dmamap_t *);
	void	(*_dmamap_destroy)(void *, bus_dmamap_t);
	int	(*_dmamap_load)(void *, bus_dmamap_t, void *,
		    bus_size_t, struct proc *, int);
	int	(*_dmamap_load_mbuf)(void *, bus_dmamap_t,
		    struct mbuf *, int);
	int	(*_dmamap_load_uio)(void *, bus_dmamap_t,
		    struct uio *, int);
	int	(*_dmamap_load_raw)(void *, bus_dmamap_t,
		    bus_dma_segment_t *, int, bus_size_t, int);
	void	(*_dmamap_unload)(void *, bus_dmamap_t);
	void	(*_dmamap_sync)(void *, bus_dmamap_t, bus_addr_t,
		    bus_size_t, int);
d352 8
a359 8
	int	(*_dmamem_alloc)(void *, bus_size_t, bus_size_t,
		    bus_size_t, bus_dma_segment_t *, int, int *, int);
	void	(*_dmamem_free)(void *, bus_dma_segment_t *, int);
	int	(*_dmamem_map)(void *, bus_dma_segment_t *,
		    int, size_t, caddr_t *, int);
	void	(*_dmamem_unmap)(void *, caddr_t, size_t);
	paddr_t	(*_dmamem_mmap)(void *, bus_dma_segment_t *,
		    int, off_t, int, int);
@


1.11.2.6
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.11.2.5 2002/03/28 10:27:10 niklas Exp $	*/
a168 6
/* flags for bus space map functions */
#define	BUS_SPACE_MAP_CACHEABLE		0x0001
#define	BUS_SPACE_MAP_LINEAR		0x0002
#define	BUS_SPACE_MAP_READONLY		0x0004
#define	BUS_SPACE_MAP_PREFETCHABLE	0x0008

a287 2
#define	bus_space_vaddr(t,h,o,l,op) \
	((t)->hbt_vaddr((t)->hbt_cookie, (h), (o), (l), (op)))
@


1.11.2.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d51 1
a51 1
			     int flags, bus_space_handle_t *bshp);
d59 1
a59 1
			       bus_size_t boundary, int flags,
a173 1
#define	BUS_SPACE_MAP_NOEXTENT		0x8000	/* no extent ops */
@


1.11.2.8
log
@Merge with the trunk
@
text
@d4 1
a4 1
 * Copyright (c) 1998-2004 Michael Shalayeff
d15 5
a331 2
	vaddr_t		_ds_va;		/* needed for syncing */

d421 1
@


1.10
log
@fix types for raw routines, also fix macros in bus.h for raw multi; 10x niklas@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.9 1999/11/25 18:25:31 mickey Exp $	*/
d363 1
a363 1
	(*(t)->_dmamap_create)((t), (s), (n), (m), (b), (f), (p))
d365 1
a365 1
	(*(t)->_dmamap_destroy)((t), (p))
d367 1
a367 1
	(*(t)->_dmamap_load)((t), (m), (b), (s), (p), (f))
d369 1
a369 1
	(*(t)->_dmamap_load_mbuf)((t), (m), (b), (f))
d371 1
a371 1
	(*(t)->_dmamap_load_uio)((t), (m), (u), (f))
d373 1
a373 1
	(*(t)->_dmamap_load_raw)((t), (m), (sg), (n), (s), (f))
d375 1
a375 1
	(*(t)->_dmamap_unload)((t), (p))
d378 1
a378 1
	    (*(t)->_dmamap_sync)((t), (p), (o)) : (void)0)
@


1.9
log
@do bus stuff through pointers, native devices use memory ops where possible
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.8 1999/02/25 17:32:39 mickey Exp $	*/
d76 1
a76 1
			      bus_size_t o, u_int8_t *a, size_t c));
d78 1
a78 1
			      bus_size_t o, u_int16_t *a, size_t c));
d80 1
a80 1
			      bus_size_t o, u_int32_t *a, size_t c));
d82 1
a82 1
			      bus_size_t o, u_int64_t *a, size_t c));
d85 1
a85 1
			      const u_int8_t *a, size_t c));
d87 1
a87 1
			      const u_int16_t *a, size_t c));
d89 1
a89 1
			      const u_int32_t *a, size_t c));
d91 1
a91 1
			      const u_int64_t *a, size_t c));
d94 1
a94 1
			      u_int8_t  vv, size_t c));
d96 1
a96 1
			      u_int16_t vv, size_t c));
d98 1
a98 1
			      u_int32_t vv, size_t c));
d100 1
a100 1
			      u_int64_t vv, size_t c));
d103 1
a103 1
			       bus_size_t o, u_int16_t*a, size_t c));
d105 1
a105 1
			       bus_size_t o, u_int32_t*a, size_t c));
d107 1
a107 1
			       bus_size_t o, u_int64_t*a, size_t c));
d110 1
a110 1
			       bus_size_t o, const u_int16_t *a, size_t c));
d112 1
a112 1
			       bus_size_t o, const u_int32_t *a, size_t c));
d114 1
a114 1
			       bus_size_t o, const u_int64_t *a, size_t c));
d117 1
a117 1
			      bus_size_t o, u_int8_t *a, size_t c));
d119 1
a119 1
			      bus_size_t o, u_int16_t *a, size_t c));
d121 1
a121 1
			      bus_size_t o, u_int32_t *a, size_t c));
d123 1
a123 1
			      bus_size_t o, u_int64_t *a, size_t c));
d126 1
a126 1
			      bus_size_t o, const u_int8_t *a, size_t c));
d128 1
a128 1
			      bus_size_t o, const u_int16_t *a, size_t c));
d130 1
a130 1
			      bus_size_t o, const u_int32_t *a, size_t c));
d132 1
a132 1
			      bus_size_t o, const u_int64_t *a, size_t c));
d135 1
a135 1
			       bus_size_t o, u_int16_t *a, size_t c));
d137 1
a137 1
			       bus_size_t o, u_int32_t *a, size_t c));
d139 1
a139 1
			       bus_size_t o, u_int64_t *a, size_t c));
d142 1
a142 1
			       bus_size_t o, const u_int16_t *a, size_t c));
d144 1
a144 1
			       bus_size_t o, const u_int32_t *a, size_t c));
d146 1
a146 1
			       bus_size_t o, const u_int64_t *a, size_t c));
d149 1
a149 1
			       bus_size_t o, u_int8_t vv, size_t c));
d151 1
a151 1
			       bus_size_t o, u_int16_t vv, size_t c));
d153 1
a153 1
			       bus_size_t o, u_int32_t vv, size_t c));
d155 1
a155 1
			       bus_size_t o, u_int64_t vv, size_t c));
d221 1
a221 1
	(((t)->hbt_rm_2)((t)->hbt_cookie, (h), (o), (a), (c)))
d223 1
a223 1
	(((t)->hbt_rm_4)((t)->hbt_cookie, (h), (o), (a), (c)))
d225 1
a225 1
	(((t)->hbt_rm_8)((t)->hbt_cookie, (h), (o), (a), (c)))
d228 1
a228 1
	(((t)->hbt_wm_2)((t)->hbt_cookie, (h), (o), (a), (c)))
d230 1
a230 1
	(((t)->hbt_wm_4)((t)->hbt_cookie, (h), (o), (a), (c)))
d232 1
a232 1
	(((t)->hbt_wm_8)((t)->hbt_cookie, (h), (o), (a), (c)))
@


1.8
log
@better bus_space_barrier(); proper dma stuff; some more bus tags
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.7 1999/01/03 17:55:13 mickey Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998 Michael Shalayeff
d17 1
a17 1
 *	This product includes software developed by Michael Shalayeff.
d24 8
a31 7
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d34 1
a44 1
typedef u_long bus_space_tag_t;
d47 121
a167 12
/* we are trying to avoid using bus.h interface whenever we can to avoid
   overheads because of different bus access types */
#define	HPPA_BUS_TAG_CORE	(0x000)
#define	HPPA_BUS_TAG_ISA	(0x001)
#define	HPPA_BUS_TAG_EISA	(0x002)
#define	HPPA_BUS_TAG_PCI	(0x003)
#define	HPPA_BUS_TAG_VME	(0x004)
#define	HPPA_BUS_TAG_BUSMASK	(0x00f)
#define	HPPA_BUS_TAG_MASK	(0xfff)
#define	HPPA_BUS_TAG_SET_BASE(tag,base)	\
		((((tag) & HPPA_BUS_TAG_MASK)) | ((base) & ~HPPA_BUS_TAG_MASK))
#define	HPPA_BUS_TAG_BASE(tag)		((tag) & ~HPPA_BUS_TAG_MASK)
d172 47
a218 60
int bus_space_map __P((bus_space_tag_t t, bus_addr_t addr, bus_size_t size,
		       int cacheable, bus_space_handle_t *bshp));
void bus_space_unmap __P((bus_space_tag_t t, bus_space_handle_t bsh,
			  bus_size_t size));

int	bus_space_subregion __P((bus_space_tag_t t, bus_space_handle_t bsh,
	    bus_size_t offset, bus_size_t size, bus_space_handle_t *nbshp));

int	bus_space_alloc __P((bus_space_tag_t t, bus_addr_t rstart,
	    bus_addr_t rend, bus_size_t size, bus_size_t align,
	    bus_size_t boundary, int cacheable, bus_addr_t *addrp,
	    bus_space_handle_t *bshp));
void	bus_space_free __P((bus_space_tag_t t, bus_space_handle_t bsh,
	    bus_size_t size));

#define	bus_space_read_1(t, h, o)	\
	((void)(t), (*((volatile u_int8_t *)((h) + (o)))))
#define	bus_space_read_2(t, h, o)	\
	((void)(t), (*((volatile u_int16_t *)((h) + (o)))))
#define	bus_space_read_4(t, h, o)	\
	((void)(t), (*((volatile u_int32_t *)((h) + (o)))))
#define	bus_space_read_8(t, h, o)	\
	((void)(t), (*((volatile u_int64_t *)((h) + (o)))))

static __inline void
bus_space_read_multi_1(bus_space_tag_t t, bus_space_handle_t h,
		       bus_size_t o, u_int8_t *a, size_t c)
{
	h += o;
	while (c--)
		*(a++) = *((volatile u_int8_t *)h)++;
}

static __inline void
bus_space_read_multi_2(bus_space_tag_t t, bus_space_handle_t h,
		       bus_size_t o, u_int16_t *a, size_t c)
{
	h += o;
	while (c--)
		*(a++) = *((volatile u_int16_t *)h)++;
}

static __inline void
bus_space_read_multi_4(bus_space_tag_t t, bus_space_handle_t h,
		       bus_size_t o, u_int32_t *a, size_t c)
{
	h += o;
	while (c--)
		*(a++) = *((volatile u_int32_t *)h)++;
}

static __inline void
bus_space_read_multi_8(bus_space_tag_t t, bus_space_handle_t h,
		       bus_size_t o, u_int64_t *a, size_t c)
{
	h += o;
	while (c--)
		*(a++) = *((volatile u_int64_t *)h)++;
}

d221 1
a221 1
    bus_space_read_multi_2((t), (h), (o), (u_int16_t *)(a), (c) >> 1)
d223 1
a223 1
    bus_space_read_multi_4((t), (h), (o), (u_int32_t *)(a), (c) >> 2)
d225 1
a225 1
    bus_space_read_multi_8((t), (h), (o), (u_int32_t *)(a), (c) >> 2)
d227 6
a232 5
#if 0
#define	bus_space_read_region_1(t, h, o, a, c) do {		\
} while (0)

#define	bus_space_read_region_2(t, h, o, a, c) do {		\
d234 17
a250 7
} while (0)

#define	bus_space_read_region_4(t, h, o, a, c) do {		\
} while (0)

#define	bus_space_read_region_8
#endif
d253 1
a253 1
    bus_space_read_region_2((t), (h), (o), (u_int16_t *)(a), (c) >> 1)
d255 1
a255 1
    bus_space_read_region_4((t), (h), (o), (u_int32_t *)(a), (c) >> 2)
d257 1
a257 67
    bus_space_read_region_8((t), (h), (o), (u_int32_t *)(a), (c) >> 2)

#define	bus_space_write_1(t, h, o, v)	\
	((void)(t), *((volatile u_int8_t *)((h) + (o))) = (v))
#define	bus_space_write_2(t, h, o, v)	\
	((void)(t), *((volatile u_int16_t *)((h) + (o))) = (v))
#define	bus_space_write_4(t, h, o, v)	\
	((void)(t), *((volatile u_int32_t *)((h) + (o))) = (v))
#define	bus_space_write_8(t, h, o, v)	\
	((void)(t), *((volatile u_int64_t *)((h) + (o))) = (v))

static __inline void
bus_space_write_multi_1(bus_space_tag_t t, bus_space_handle_t h,
		       bus_size_t o, const u_int8_t *a, size_t c)
{
	h += o;
	while (c--)
		*((volatile u_int8_t *)h)++ = *(a++);
}

static __inline void
bus_space_write_multi_2(bus_space_tag_t t, bus_space_handle_t h,
		       bus_size_t o, const u_int16_t *a, size_t c)
{
	h += o;
	while (c--)
		*((volatile u_int16_t *)h)++ = *(a++);
}

static __inline void
bus_space_write_multi_4(bus_space_tag_t t, bus_space_handle_t h,
		       bus_size_t o, const u_int32_t *a, size_t c)
{
	h += o;
	while (c--)
		*((volatile u_int32_t *)h)++ = *(a++);
}

static __inline void
bus_space_write_multi_8(bus_space_tag_t t, bus_space_handle_t h,
		       bus_size_t o, const u_int64_t *a, size_t c)
{
	h += o;
	while (c--)
		*((volatile u_int64_t *)h)++ = *(a++);
}


#define	bus_space_write_raw_multi_2(t, h, o, a, c) \
    bus_space_write_multi_2((t), (h), (o), (const u_int16_t *)(a), (c) >> 1)
#define	bus_space_write_raw_multi_4(t, h, o, a, c) \
    bus_space_write_multi_4((t), (h), (o), (const u_int32_t *)(a), (c) >> 2)
#define	bus_space_write_raw_multi_8(t, h, o, a, c) \
    bus_space_write_multi_8((t), (h), (o), (const u_int32_t *)(a), (c) >> 2)

#if 0
#define	bus_space_write_region_1(t, h, o, a, c) do {		\
} while (0)

#define	bus_space_write_region_2(t, h, o, a, c) do {		\
} while (0)

#define	bus_space_write_region_4(t, h, o, a, c) do {		\
} while (0)

#define	bus_space_write_region_8
#endif
d260 1
a260 1
    bus_space_write_region_2((t), (h), (o), (const u_int16_t *)(a), (c) >> 1)
d262 1
a262 1
    bus_space_write_region_4((t), (h), (o), (const u_int32_t *)(a), (c) >> 2)
d264 1
a264 14
    bus_space_write_region_8((t), (h), (o), (const u_int32_t *)(a), (c) >> 2)

#if 0
#define	bus_space_set_multi_1(t, h, o, v, c) do {		\
} while (0)

#define	bus_space_set_multi_2(t, h, o, v, c) do {		\
} while (0)

#define	bus_space_set_multi_4(t, h, o, v, c) do {		\
} while (0)

#define	bus_space_set_multi_8
#endif
d266 17
a282 25
#if 0
#define	bus_space_set_region_1(t, h, o, v, c) do {		\
} while (0)

#define	bus_space_set_region_2(t, h, o, v, c) do {		\
} while (0)

#define	bus_space_set_region_4(t, h, o, v, c) do {		\
} while (0)

#define	bus_space_set_region_8
#endif

#if 0
#define	bus_space_copy_1(t, h1, o1, h2, o2, c) do {		\
} while (0)

#define	bus_space_copy_2(t, h1, o1, h2, o2, c) do {		\
} while (0)

#define	bus_space_copy_4(t, h1, o1, h2, o2, c) do {		\
} while (0)

#define	bus_space_copy_8
#endif
d287 2
a288 4
#define	bus_space_barrier(t,h,o,l,op)	{			\
	((void)(t),(void)(h),(void)(o),(void)(l),(void)(op));	\
	sync_caches();						\
}
d307 1
a307 1
typedef struct hppa_bus_dma_tag	*bus_dma_tag_t;
a389 20

int	_dmamap_create __P((void *, bus_size_t, int,
	    bus_size_t, bus_size_t, int, bus_dmamap_t *));
void	_dmamap_destroy __P((void *, bus_dmamap_t));
int	_dmamap_load __P((void *, bus_dmamap_t, void *,
	    bus_size_t, struct proc *, int));
int	_dmamap_load_mbuf __P((void *, bus_dmamap_t, struct mbuf *, int));
int	_dmamap_load_uio __P((void *, bus_dmamap_t, struct uio *, int));
int	_dmamap_load_raw __P((void *, bus_dmamap_t,
	    bus_dma_segment_t *, int, bus_size_t, int));
void	_dmamap_unload __P((void *, bus_dmamap_t));
void	_dmamap_sync __P((void *, bus_dmamap_t, bus_dmasync_op_t));

int	_dmamem_alloc __P((void *, bus_size_t, bus_size_t,
	    bus_size_t, bus_dma_segment_t *, int, int *, int));
void	_dmamem_free __P((void *, bus_dma_segment_t *, int));
int	_dmamem_map __P((void *, bus_dma_segment_t *,
	    int, size_t, caddr_t *, int));
void	_dmamem_unmap __P((void *, caddr_t, size_t));
int	_dmamem_mmap __P((void *, bus_dma_segment_t *, int, int, int, int));
@


1.7
log
@implement bus_space_{un,}map w/ extents
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.6 1998/12/29 22:20:27 mickey Exp $	*/
d46 9
d56 2
a57 2
		((((tag) & 0x00000fff)) | ((base) & 0xfffff000))
#define	HPPA_BUS_TAG_BASE(tag)		((tag) & 0xfffff000)
d60 1
a60 3
#define DCIAS(pa) \
	__asm __volatile ("rsm %1, %%r0\n\tfdc %%r0(%0)\n\tssm %1, %%r0" \
			  :: "r" (pa), "i" (PSW_D));
d266 4
a269 2
void bus_space_barrier __P((bus_space_tag_t tag, bus_space_handle_t h,
	bus_addr_t off, bus_size_t len, int op));
d316 1
a316 1
	int	(*_dmamap_create) __P((bus_dma_tag_t, bus_size_t, int,
d318 2
a319 2
	void	(*_dmamap_destroy) __P((bus_dma_tag_t, bus_dmamap_t));
	int	(*_dmamap_load) __P((bus_dma_tag_t, bus_dmamap_t, void *,
d321 1
a321 1
	int	(*_dmamap_load_mbuf) __P((bus_dma_tag_t, bus_dmamap_t,
d323 1
a323 1
	int	(*_dmamap_load_uio) __P((bus_dma_tag_t, bus_dmamap_t,
d325 1
a325 1
	int	(*_dmamap_load_raw) __P((bus_dma_tag_t, bus_dmamap_t,
d327 2
a328 3
	void	(*_dmamap_unload) __P((bus_dma_tag_t, bus_dmamap_t));
	void	(*_dmamap_sync) __P((bus_dma_tag_t, bus_dmamap_t,
		    bus_dmasync_op_t));
d333 1
a333 1
	int	(*_dmamem_alloc) __P((bus_dma_tag_t, bus_size_t, bus_size_t,
d335 2
a336 3
	void	(*_dmamem_free) __P((bus_dma_tag_t,
		    bus_dma_segment_t *, int));
	int	(*_dmamem_map) __P((bus_dma_tag_t, bus_dma_segment_t *,
d338 2
a339 2
	void	(*_dmamem_unmap) __P((bus_dma_tag_t, caddr_t, size_t));
	int	(*_dmamem_mmap) __P((bus_dma_tag_t, bus_dma_segment_t *,
d362 1
a362 1
	(*(t)->_dmamem_alloc)((t), (s), (a), (b), (sg), (n), (r), (f))
d364 1
a364 1
	(*(t)->_dmamem_free)((t), (sg), (n))
d366 1
a366 1
	(*(t)->_dmamem_map)((t), (sg), (n), (s), (k), (f))
d368 1
a368 1
	(*(t)->_dmamem_unmap)((t), (k), (s))
d370 21
a390 1
	(*(t)->_dmamem_mmap)((t), (sg), (n), (o), (p), (f))
d399 1
a399 1
	 * PRIVATE MEMBERS: not for use my machine-independent code.
@


1.6
log
@add bus_space_barrier() proto
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.5 1998/12/13 07:08:38 mickey Exp $	*/
d55 4
a58 15
/* no extent handlng for now
   we won't have overlaps from PDC anyway */
static __inline int
bus_space_map (bus_space_tag_t t, bus_addr_t addr, bus_size_t size,
	       int cacheable, bus_space_handle_t *bshp)
{
	*bshp = addr + HPPA_BUS_TAG_BASE(t);
	return 0;
}

static __inline void
bus_space_unmap (bus_space_tag_t t, bus_space_handle_t bsh, bus_size_t size)
{
	/* nothing to do */
}
@


1.5
log
@implement some more of those write_multi routines; also some 64 bit ones
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.4 1998/12/13 06:36:54 mickey Exp $	*/
d267 2
a268 2
#define	bus_space_barrier(t, h, o, l, f) \
	((void)(t), (void)(h), (void)(o), (void)(o), (void)(l), (void)(f))
d270 2
a271 2
#define	BUS_SPACE_BARRIER_READ	1
#define	BUS_SPACE_BARRIER_WRITE	2
@


1.4
log
@take advantage of IO space equal mapping
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.3 1998/12/05 17:31:21 mickey Exp $	*/
d117 9
a125 3
#if 0
#define	bus_space_read_multi_8
#endif
d164 17
a180 3
#if 0
#define	bus_space_write_multi_1(t, h, o, a, c) do {		\
} while (0)
d182 8
a189 2
#define bus_space_write_multi_2(t, h, o, a, c) do {		\
} while (0)
d191 8
a198 2
#define bus_space_write_multi_4(t, h, o, a, c) do {		\
} while (0)
a199 2
#define	bus_space_write_multi_8(t, h, o, a, c)
#endif
@


1.3
log
@fake bus_space_barrier()
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.2 1998/12/05 15:50:45 mickey Exp $	*/
a45 4
#define	HPPA_BUS_TAG_SET_BYTE(tag)	((tag) & (~1))
#define	HPPA_BUS_TAG_SET_WORD(tag,off)	((tag) | (1) | ((off) << 1))
#define	HPPA_BUS_TAG_PROTO(tag)		((tag) & 1)
#define	HPPA_BUS_TAG_OFFSET(tag)	(((tag) >> 1) & 3)
d57 3
a59 3
static __inline int bus_space_map (bus_space_tag_t t, bus_addr_t addr,
				   bus_size_t size, int cacheable,
				   bus_space_handle_t *bshp)
d65 2
a66 3
static __inline void bus_space_unmap (bus_space_tag_t t,
				      bus_space_handle_t bsh,
				      bus_size_t size)
d81 8
a88 30
static __inline u_int8_t
bus_space_read_1(bus_space_tag_t t, bus_space_handle_t h, int o)
{		
	if (HPPA_BUS_TAG_PROTO(t))
		o = (o << 2) | HPPA_BUS_TAG_OFFSET(t);

	return *((volatile u_int8_t *)(h + o));
}

static __inline u_int16_t
bus_space_read_2(bus_space_tag_t t, bus_space_handle_t h, int o)
{		
	if (HPPA_BUS_TAG_PROTO(t))
		o = (o << 2) | HPPA_BUS_TAG_OFFSET(t);

	return *((volatile u_int16_t *)(h + o));
}

static __inline u_int32_t
bus_space_read_4(bus_space_tag_t t, bus_space_handle_t h, int o)
{		
	if (HPPA_BUS_TAG_PROTO(t))
		o = (o << 2) | HPPA_BUS_TAG_OFFSET(t);

	return *((volatile u_int32_t *)(h + o));
}

#if 0
#define	bus_space_read_8(t, h, o)
#endif
a93 3
	if (HPPA_BUS_TAG_PROTO(t))
		o = (o << 2) | HPPA_BUS_TAG_OFFSET(t);

a102 3
	if (HPPA_BUS_TAG_PROTO(t))
		o = (o << 2) | HPPA_BUS_TAG_OFFSET(t);

a111 3
	if (HPPA_BUS_TAG_PROTO(t))
		o = (o << 2) | HPPA_BUS_TAG_OFFSET(t);

d125 2
a126 4

#if 0
#define	bus_space_read_raw_multi_8
#endif
a141 1
#if 0
d146 2
d149 8
a156 14
#define	bus_space_read_raw_region_8
#endif

#define	bus_space_write_1(t, h, o, v)					\
	*((volatile u_int8_t *)(h + ((HPPA_BUS_TAG_PROTO(t))?		\
		((o) << 2) | HPPA_BUS_TAG_OFFSET(t):(o)))) = (u_int8_t)v

#define	bus_space_write_2(t, h, o, v)					\
	*((volatile u_int16_t *)(h + ((HPPA_BUS_TAG_PROTO(t))?		\
		((o) << 2) | HPPA_BUS_TAG_OFFSET(t):(o)))) = (u_int16_t)v

#define	bus_space_write_4(t, h, o, v)					\
	*((volatile u_int32_t *)(h + ((HPPA_BUS_TAG_PROTO(t))?		\
		((o) << 2) | HPPA_BUS_TAG_OFFSET(t):(o)))) = (u_int32_t)v
a158 3
#define	bus_space_write_8
#endif

a167 1
#if 0
d175 2
a176 4

#if 0
#define	bus_space_write_raw_multi_8
#endif
d195 2
a196 4

#if 0
#define	bus_space_write_raw_region_8
#endif
@


1.2
log
@finally, i block mapped the io space, so bus.h is kind of fake now, just *(h + o) pointer arithmetic
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.1 1998/11/23 03:36:53 mickey Exp $	*/
d287 3
@


1.1
log
@some bus.h
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a44 1
typedef	u_long bus_dma_tag_t;
d56 1
a56 1
	__asm __volatile ("rsm %1, %%r0\n\tpdc %%r0(%0)\n\tssm %1, %%r0" \
a88 2
	register u_int32_t v;

d92 1
a92 6
	__asm __volatile ("rsm %3, %%r0\n\t"
			  "ldbx %2(%1), %0\n\t"
			  "pdc %2(%1)\n\t"
			  "ssm %3, %%r0"
			  : "=r" (v): "r" (h), "r" (o), "i" (PSW_D));
	return v & 0xff;
a97 2
	register u_int32_t v;

d101 1
a101 6
	__asm __volatile ("rsm %3, %%r0\n\t"
			  "ldhx %2(%1), %0\n\t"
			  "pdc %2(%1)\n\t"
			  "ssm %3, %%r0"
			  : "=r" (v): "r" (h), "r" (o), "i" (PSW_D));
	return v & 0xffff;
a106 2
	register u_int32_t v;

d110 1
a110 6
	__asm __volatile ("rsm %3, %%r0\n\t"
			  "ldwx %2(%1), %0\n\t"
			  "pdc %2(%1)\n\t"
			  "ssm %3, %%r0"
			  : "=r" (v): "r" (h), "r" (o), "i" (PSW_D));
	return v;
a120 2
	register u_int32_t v;

d124 3
a126 6
	for (; c--; *(a++) = v & 0xff)
		__asm __volatile ("rsm %3, %%r0\n\t"
				  "ldbx %2(%1), %0\n\t"
				  "pdc %2(%1)\n\t"
				  "ssm %3, %%r0"
				  : "=r" (v): "r" (h), "r" (o), "i" (PSW_D));
a132 2
	register u_int32_t v;

d136 3
a138 6
	for (; c--; *(a++) = v & 0xffff)
		__asm __volatile ("rsm %3, %%r0\n\t"
				  "ldhx %2(%1), %0\n\t"
				  "pdc %2(%1)\n\t"
				  "ssm %3, %%r0"
				  : "=r" (v): "r" (h), "r" (o), "i" (PSW_D));
a144 2
	register u_int32_t v;

d148 3
a150 6
	for (; c--; *(a++) = v)
		__asm __volatile ("rsm %3, %%r0\n\t"
				  "ldwx %2(%1), %0\n\t"
				  "pdc %2(%1)\n\t"
				  "ssm %3, %%r0"
				  : "=r" (v): "r" (h), "r" (o), "i" (PSW_D));
d189 11
a199 32
#define	bus_space_write_1(t, h, o, v)	do {				\
	__asm __volatile (						\
		"rsm %0, %%r0\n\t"					\
		"stbs %1, 0(%2)\n\t"					\
		"fdc %%r0(%2)\n\t"					\
		"ssm %0, %%r0"						\
		:: "i" (PSW_D), "r" (v),				\
		   "r" (h + ((HPPA_BUS_TAG_PROTO(t))?			\
			     ((o) << 2) | HPPA_BUS_TAG_OFFSET(t):(o))));\
} while (0)

#define	bus_space_write_2(t, h, o, v)	do {				\
	__asm __volatile (						\
		"rsm %0, %%r0\n\t"					\
		"sths %1, 0(%2)\n\t"					\
		"fdc %%r0(%2)\n\t"					\
		"ssm %0, %%r0"						\
		:: "i" (PSW_D), "r" (v),				\
		   "r" (h + ((HPPA_BUS_TAG_PROTO(t))?			\
			     ((o) << 2) | HPPA_BUS_TAG_OFFSET(t):(o))));\
} while (0)

#define	bus_space_write_4(t, h, o, v)	do {				\
	__asm __volatile (						\
		"rsm %0, %%r0\n\t"					\
		"stws %1, 0(%2)\n\t"					\
		"fdc %%r0(%2)\n\t"					\
		"ssm %0, %%r0"						\
		:: "i" (PSW_D), "r" (v),				\
		   "r" (h + ((HPPA_BUS_TAG_PROTO(t))?			\
			     ((o) << 2) | HPPA_BUS_TAG_OFFSET(t):(o))));\
} while (0)
d288 130
a418 1

@

