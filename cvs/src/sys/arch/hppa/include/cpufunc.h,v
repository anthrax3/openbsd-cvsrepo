head	1.29;
access;
symbols
	OPENBSD_6_2_BASE:1.29
	OPENBSD_6_1:1.29.0.14
	OPENBSD_6_1_BASE:1.29
	OPENBSD_6_0:1.29.0.10
	OPENBSD_6_0_BASE:1.29
	OPENBSD_5_9:1.29.0.6
	OPENBSD_5_9_BASE:1.29
	OPENBSD_5_8:1.29.0.8
	OPENBSD_5_8_BASE:1.29
	OPENBSD_5_7:1.29.0.2
	OPENBSD_5_7_BASE:1.29
	OPENBSD_5_6:1.29.0.4
	OPENBSD_5_6_BASE:1.29
	OPENBSD_5_5:1.28.0.6
	OPENBSD_5_5_BASE:1.28
	OPENBSD_5_4:1.28.0.2
	OPENBSD_5_4_BASE:1.28
	OPENBSD_5_3:1.27.0.32
	OPENBSD_5_3_BASE:1.27
	OPENBSD_5_2:1.27.0.30
	OPENBSD_5_2_BASE:1.27
	OPENBSD_5_1_BASE:1.27
	OPENBSD_5_1:1.27.0.28
	OPENBSD_5_0:1.27.0.26
	OPENBSD_5_0_BASE:1.27
	OPENBSD_4_9:1.27.0.24
	OPENBSD_4_9_BASE:1.27
	OPENBSD_4_8:1.27.0.22
	OPENBSD_4_8_BASE:1.27
	OPENBSD_4_7:1.27.0.18
	OPENBSD_4_7_BASE:1.27
	OPENBSD_4_6:1.27.0.20
	OPENBSD_4_6_BASE:1.27
	OPENBSD_4_5:1.27.0.16
	OPENBSD_4_5_BASE:1.27
	OPENBSD_4_4:1.27.0.14
	OPENBSD_4_4_BASE:1.27
	OPENBSD_4_3:1.27.0.12
	OPENBSD_4_3_BASE:1.27
	OPENBSD_4_2:1.27.0.10
	OPENBSD_4_2_BASE:1.27
	OPENBSD_4_1:1.27.0.8
	OPENBSD_4_1_BASE:1.27
	OPENBSD_4_0:1.27.0.6
	OPENBSD_4_0_BASE:1.27
	OPENBSD_3_9:1.27.0.4
	OPENBSD_3_9_BASE:1.27
	OPENBSD_3_8:1.27.0.2
	OPENBSD_3_8_BASE:1.27
	OPENBSD_3_7:1.26.0.4
	OPENBSD_3_7_BASE:1.26
	OPENBSD_3_6:1.26.0.2
	OPENBSD_3_6_BASE:1.26
	SMP_SYNC_A:1.25
	SMP_SYNC_B:1.25
	OPENBSD_3_5:1.23.0.2
	OPENBSD_3_5_BASE:1.23
	OPENBSD_3_4:1.22.0.2
	OPENBSD_3_4_BASE:1.22
	UBC_SYNC_A:1.21
	OPENBSD_3_3:1.20.0.4
	OPENBSD_3_3_BASE:1.20
	OPENBSD_3_2:1.20.0.2
	OPENBSD_3_2_BASE:1.20
	OPENBSD_3_1:1.19.0.2
	OPENBSD_3_1_BASE:1.19
	UBC_SYNC_B:1.20
	UBC:1.17.0.8
	UBC_BASE:1.17
	OPENBSD_3_0:1.17.0.6
	OPENBSD_3_0_BASE:1.17
	OPENBSD_2_9:1.17.0.4
	OPENBSD_2_9_BASE:1.17
	OPENBSD_2_8:1.17.0.2
	OPENBSD_2_8_BASE:1.17
	OPENBSD_2_7:1.16.0.2
	OPENBSD_2_7_BASE:1.16
	SMP:1.14.0.2
	SMP_BASE:1.14
	kame_19991208:1.11
	OPENBSD_2_6:1.10.0.2
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.6.0.2
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.2.0.2
	OPENBSD_2_4_BASE:1.2;
locks; strict;
comment	@ * @;


1.29
date	2014.03.29.18.09.29;	author guenther;	state Exp;
branches;
next	1.28;

1.28
date	2013.03.25.19.59.22;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2005.04.07.00.19.28;	author mickey;	state Exp;
branches;
next	1.26;

1.26
date	2004.07.01.21.03.33;	author mickey;	state Exp;
branches;
next	1.25;

1.25
date	2004.04.07.18.24.19;	author mickey;	state Exp;
branches;
next	1.24;

1.24
date	2004.04.06.18.33.50;	author mickey;	state Exp;
branches;
next	1.23;

1.23
date	2003.09.25.22.17.40;	author mickey;	state Exp;
branches;
next	1.22;

1.22
date	2003.08.20.06.50.30;	author mickey;	state Exp;
branches;
next	1.21;

1.21
date	2003.04.07.17.43.28;	author mickey;	state Exp;
branches;
next	1.20;

1.20
date	2002.09.05.21.37.18;	author mickey;	state Exp;
branches;
next	1.19;

1.19
date	2002.03.15.21.44.18;	author mickey;	state Exp;
branches;
next	1.18;

1.18
date	2002.03.14.01.26.32;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2000.05.15.17.22.40;	author mickey;	state Exp;
branches
	1.17.8.1;
next	1.16;

1.16
date	2000.04.24.17.39.54;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	2000.03.29.23.11.12;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	2000.02.09.05.10.10;	author mickey;	state Exp;
branches
	1.14.2.1;
next	1.13;

1.13
date	2000.02.09.05.04.22;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	99.12.18.08.52.05;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	99.11.25.18.27.06;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	99.08.12.18.45.33;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	99.05.22.00.16.42;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	99.05.02.03.41.45;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	99.04.20.19.29.12;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	99.02.25.17.23.34;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	98.12.29.21.47.13;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	98.12.05.17.33.01;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	98.10.30.22.16.42;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	98.08.29.01.56.55;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	98.07.07.21.32.40;	author mickey;	state Exp;
branches;
next	;

1.14.2.1
date	2001.04.18.16.06.20;	author niklas;	state Exp;
branches;
next	1.14.2.2;

1.14.2.2
date	2002.03.28.10.27.10;	author niklas;	state Exp;
branches;
next	1.14.2.3;

1.14.2.3
date	2003.03.27.23.26.54;	author niklas;	state Exp;
branches;
next	1.14.2.4;

1.14.2.4
date	2003.05.13.19.41.04;	author ho;	state Exp;
branches;
next	1.14.2.5;

1.14.2.5
date	2004.02.19.10.48.40;	author niklas;	state Exp;
branches;
next	1.14.2.6;

1.14.2.6
date	2004.06.05.23.10.49;	author niklas;	state Exp;
branches;
next	;

1.17.8.1
date	2002.06.11.03.35.37;	author art;	state Exp;
branches;
next	1.17.8.2;

1.17.8.2
date	2002.10.29.00.28.03;	author art;	state Exp;
branches;
next	1.17.8.3;

1.17.8.3
date	2003.05.19.21.49.41;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.29
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@/*	$OpenBSD: cpufunc.h,v 1.28 2013/03/25 19:59:22 deraadt Exp $	*/

/*
 * Copyright (c) 1998-2004 Michael Shalayeff
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR OR HIS RELATIVES BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */
/*
 *  (c) Copyright 1988 HEWLETT-PACKARD COMPANY
 *
 *  To anyone who acknowledges that this file is provided "AS IS"
 *  without any express or implied warranty:
 *      permission to use, copy, modify, and distribute this file
 *  for any purpose is hereby granted without fee, provided that
 *  the above copyright notice and this notice appears in all
 *  copies, and that the name of Hewlett-Packard Company not be
 *  used in advertising or publicity pertaining to distribution
 *  of the software without specific, written prior permission.
 *  Hewlett-Packard Company makes no representations about the
 *  suitability of this software for any purpose.
 */
/*
 * Copyright (c) 1990,1994 The University of Utah and
 * the Computer Systems Laboratory (CSL).  All rights reserved.
 *
 * THE UNIVERSITY OF UTAH AND CSL PROVIDE THIS SOFTWARE IN ITS "AS IS"
 * CONDITION, AND DISCLAIM ANY LIABILITY OF ANY KIND FOR ANY DAMAGES
 * WHATSOEVER RESULTING FROM ITS USE.
 *
 * CSL requests users of this software to return to csl-dist@@cs.utah.edu any
 * improvements that they make and grant CSL redistribution rights.
 *
 * 	Utah $Hdr: c_support.s 1.8 94/12/14$
 *	Author: Bob Wheeler, University of Utah CSL
 */

#ifndef _MACHINE_CPUFUNC_H_
#define _MACHINE_CPUFUNC_H_

#include <machine/psl.h>
#include <machine/pte.h>

#define tlbbtop(b) ((b) >> (PAGE_SHIFT - 5))
#define tlbptob(p) ((p) << (PAGE_SHIFT - 5))

#define hptbtop(b) ((b) >> 17)

/* Get space register for an address */
static __inline register_t ldsid(vaddr_t p) {
	register_t ret;
	__asm volatile("ldsid (%1),%0" : "=r" (ret) : "r" (p));
	return ret;
}

#define mtctl(v,r) __asm volatile("mtctl %0,%1":: "r" (v), "i" (r))
#define mfctl(r,v) __asm volatile("mfctl %1,%0": "=r" (v): "i" (r))

#define	mfcpu(r,v)	/* XXX for the lack of the mnemonics */		\
	__asm volatile(".word	%1\n\t"					\
			 "copy	%%r22, %0"				\
	    : "=r" (v) : "i" ((0x14001400 | ((r) << 21) | (22)))	\
	    : "r22")

#define mtsp(v,r) __asm volatile("mtsp %0,%1":: "r" (v), "i" (r))
#define mfsp(r,v) __asm volatile("mfsp %1,%0": "=r" (v): "i" (r))

#define ssm(v,r) __asm volatile("ssm %1,%0": "=r" (r): "i" (v))
#define rsm(v,r) __asm volatile("rsm %1,%0": "=r" (r): "i" (v))

/* Move to system mask. Old value of system mask is returned. */
static __inline register_t
mtsm(register_t mask) {
	register_t ret;
	__asm volatile("ssm 0,%0\n\t"
			 "mtsm %1": "=&r" (ret) : "r" (mask));
	return ret;
}

#define	fdce(sp,off) __asm volatile("fdce 0(%0,%1)":: "i" (sp), "r" (off))
#define	fice(sp,off) __asm volatile("fice 0(%0,%1)":: "i" (sp), "r" (off))
#define sync_caches() __asm volatile(\
    "sync\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop":::"memory")

static __inline void
iitlba(u_int pg, pa_space_t sp, vaddr_t va)
{
	mtsp(sp, 1);
	__asm volatile("iitlba %0,(%%sr1, %1)":: "r" (pg), "r" (va));
}

static __inline void
idtlba(u_int pg, pa_space_t sp, vaddr_t va)
{
	mtsp(sp, 1);
	__asm volatile("idtlba %0,(%%sr1, %1)":: "r" (pg), "r" (va));
}

static __inline void
iitlbp(u_int prot, pa_space_t sp, vaddr_t va)
{
	mtsp(sp, 1);
	__asm volatile("iitlbp %0,(%%sr1, %1)":: "r" (prot), "r" (va));
}

static __inline void
idtlbp(u_int prot, pa_space_t sp, vaddr_t va)
{
	mtsp(sp, 1);
	__asm volatile("idtlbp %0,(%%sr1, %1)":: "r" (prot), "r" (va));
}

static __inline void
pitlb(pa_space_t sp, vaddr_t va)
{
	mtsp(sp, 1);
	__asm volatile("pitlb %%r0(%%sr1, %0)":: "r" (va));
}

static __inline void
pdtlb(pa_space_t sp, vaddr_t va)
{
	mtsp(sp, 1);
	__asm volatile("pdtlb %%r0(%%sr1, %0)":: "r" (va));
}

static __inline void
pitlbe(pa_space_t sp, vaddr_t va)
{
	mtsp(sp, 1);
	__asm volatile("pitlbe %%r0(%%sr1, %0)":: "r" (va));
}

static __inline void
pdtlbe(pa_space_t sp, vaddr_t va)
{
	mtsp(sp, 1);
	__asm volatile("pdtlbe %%r0(%%sr1, %0)":: "r" (va));
}

#ifdef USELEDS
#define	PALED_NETSND	0x01
#define	PALED_NETRCV	0x02
#define	PALED_DISK	0x04
#define	PALED_HEARTBEAT	0x08
#define	PALED_LOADMASK	0xf0

#define	PALED_DATA	0x01
#define	PALED_STROBE	0x02

extern volatile u_int8_t *machine_ledaddr;
extern int machine_ledword, machine_leds;

static __inline void
ledctl(int on, int off, int toggle)
{
	if (machine_ledaddr) {
		int r;

		if (on)
			machine_leds |= on;
		if (off)
			machine_leds &= ~off;
		if (toggle)
			machine_leds ^= toggle;
			
		r = ~machine_leds;	/* it seems they should be reversed */

		if (machine_ledword)
			*machine_ledaddr = r;
		else {
			register int b;
			for (b = 0x80; b; b >>= 1) {
				*machine_ledaddr = (r & b)? PALED_DATA : 0;
				DELAY(1);
				*machine_ledaddr = ((r & b)? PALED_DATA : 0) |
				    PALED_STROBE;
			}
		}
	}
}
#endif

#ifdef _KERNEL
extern int (*cpu_hpt_init)(vaddr_t hpt, vsize_t hptsize);

void fpu_save(vaddr_t va);
void fpu_exit(void);
void ficache(pa_space_t sp, vaddr_t va, vsize_t size);
void fdcache(pa_space_t sp, vaddr_t va, vsize_t size);
void pdcache(pa_space_t sp, vaddr_t va, vsize_t size);
void ficacheall(void);
void fdcacheall(void);
void ptlball(void);
int btlb_insert(pa_space_t space, vaddr_t va, paddr_t pa, vsize_t *lenp, u_int prot);
hppa_hpa_t cpu_gethpa(int n);
void eaio_l2(int i);
#endif

#endif /* _MACHINE_CPUFUNC_H_ */
@


1.28
log
@PGSHIFT -> PAGE_SHIFT
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.h,v 1.27 2005/04/07 00:19:28 mickey Exp $	*/
d71 1
a71 1
	__asm __volatile("ldsid (%1),%0" : "=r" (ret) : "r" (p));
d75 2
a76 2
#define mtctl(v,r) __asm __volatile("mtctl %0,%1":: "r" (v), "i" (r))
#define mfctl(r,v) __asm __volatile("mfctl %1,%0": "=r" (v): "i" (r))
d79 1
a79 1
	__asm __volatile(".word	%1\n\t"					\
d84 2
a85 2
#define mtsp(v,r) __asm __volatile("mtsp %0,%1":: "r" (v), "i" (r))
#define mfsp(r,v) __asm __volatile("mfsp %1,%0": "=r" (v): "i" (r))
d87 2
a88 2
#define ssm(v,r) __asm __volatile("ssm %1,%0": "=r" (r): "i" (v))
#define rsm(v,r) __asm __volatile("rsm %1,%0": "=r" (r): "i" (v))
d94 1
a94 1
	__asm __volatile("ssm 0,%0\n\t"
d99 3
a101 3
#define	fdce(sp,off) __asm __volatile("fdce 0(%0,%1)":: "i" (sp), "r" (off))
#define	fice(sp,off) __asm __volatile("fice 0(%0,%1)":: "i" (sp), "r" (off))
#define sync_caches() __asm __volatile(\
@


1.27
log
@put a memmory barrier onto the sync_caches()
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.h,v 1.26 2004/07/01 21:03:33 mickey Exp $	*/
d63 2
a64 2
#define tlbbtop(b) ((b) >> (PGSHIFT - 5))
#define tlbptob(p) ((p) << (PGSHIFT - 5))
@


1.26
log
@have separate insn and data cache all-flushers
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.h,v 1.25 2004/04/07 18:24:19 mickey Exp $	*/
d101 2
a102 2
#define sync_caches() \
    __asm __volatile("sync\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop")
@


1.25
log
@update copyright; miod@@ is fine w/ files where he holds it too
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.h,v 1.24 2004/04/06 18:33:50 mickey Exp $	*/
d211 2
a212 1
void fcacheall(void);
@


1.24
log
@in cpu_exit() make sure to flush the fpu operation (store fr0)
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.h,v 1.23 2003/09/25 22:17:40 mickey Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998,2000-2004 Michael Shalayeff
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Michael Shalayeff.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d19 8
a26 7
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@


1.23
log
@provide a function to enable accel io on pcxl2 and use it on the fb
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.h,v 1.22 2003/08/20 06:50:30 mickey Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998,2000 Michael Shalayeff
d211 1
@


1.22
log
@mfcpu_t appears to be more useful as mfcpu it seems
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.h,v 1.21 2003/04/07 17:43:28 mickey Exp $	*/
d218 1
@


1.21
log
@add mfcpu() and kill get_psw/set_psw that should not be used from the .c code
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.h,v 1.20 2002/09/05 21:37:18 mickey Exp $	*/
d85 1
a85 1
	    : "=r" (v) : "i" ((0x14000600 | ((r) << 21) | ((22) << 16)))\
@


1.20
log
@fpu save state is a separate magic function now
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.h,v 1.19 2002/03/15 21:44:18 mickey Exp $	*/
d82 6
d95 2
a96 1
static __inline register_t mtsm(register_t mask) {
a101 20

static __inline register_t get_psw(void)
{
	register_t ret;
	__asm __volatile("break %1, %2\n\tcopy %%ret0, %0" : "=r" (ret)
		: "i" (HPPA_BREAK_KERNEL), "i" (HPPA_BREAK_GET_PSW)
		: "r28");
	return ret;
}

static __inline register_t set_psw(register_t psw)
{
	register_t ret;
	__asm __volatile("copy	%0, %%arg0\n\tbreak %1, %2\n\tcopy %%ret0, %0"
		: "=r" (ret)
		: "i" (HPPA_BREAK_KERNEL), "i" (HPPA_BREAK_SET_PSW), "0" (psw)
		: "r26", "r28");
	return ret;
}

@


1.19
log
@rewrite a pmap to use multilevel page tables.
lower 12 bits contain the perms, no unused bits left,
but a couple for off-tlb use (as the ref implemented now).
do not use the hvt, which might get some use later
if proven to speed thigs up, tlb handlers would po
another dozen of insns though, but if that's worth its...
move on the data seg and map kernel text rdonly (idea form fredette),
since all of the page0 mods done before that we are all fine
except for some viper fluff, but later w/ that.
this also picks up a bit more of ddb magic for bpt and ss.
tlb handlers can use a little bit more of attention,
but things, visually, seem to be much faster already, --
sorry, no benchmarks for now.

* effort sponsored in part by the `henry st. old ale house'
* and mr.pete and mr.lee in particular in thier generous entrirety.
* the proj took a little more that 72man*h as it was expected,
* but within murhy's law estimations.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.h,v 1.18 2002/03/14 01:26:32 millert Exp $	*/
d223 1
@


1.18
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.h,v 1.17 2000/05/15 17:22:40 mickey Exp $	*/
d221 2
d228 1
a228 2
int btlb_insert(pa_space_t space, vaddr_t va, paddr_t pa,
		     vsize_t *lenp, u_int prot);
@


1.17
log
@fdcache/pdcache/ficache as out of line functions from lites
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.h,v 1.16 2000/04/24 17:39:54 mickey Exp $	*/
d221 8
a228 8
void ficache __P((pa_space_t sp, vaddr_t va, vsize_t size));
void fdcache __P((pa_space_t sp, vaddr_t va, vsize_t size));
void pdcache __P((pa_space_t sp, vaddr_t va, vsize_t size));
void fcacheall __P((void));
void ptlball __P((void));
int btlb_insert __P((pa_space_t space, vaddr_t va, paddr_t pa,
		     vsize_t *lenp, u_int prot));
hppa_hpa_t cpu_gethpa __P((int n));
@


1.17.8.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.h,v 1.17 2000/05/15 17:22:40 mickey Exp $	*/
d221 8
a228 9
extern int (*cpu_hpt_init)(vaddr_t hpt, vsize_t hptsize);

void ficache(pa_space_t sp, vaddr_t va, vsize_t size);
void fdcache(pa_space_t sp, vaddr_t va, vsize_t size);
void pdcache(pa_space_t sp, vaddr_t va, vsize_t size);
void fcacheall(void);
void ptlball(void);
int btlb_insert(pa_space_t space, vaddr_t va, paddr_t pa, vsize_t *lenp, u_int prot);
hppa_hpa_t cpu_gethpa(int n);
@


1.17.8.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.h,v 1.17.8.1 2002/06/11 03:35:37 art Exp $	*/
a222 1
void fpu_save(vaddr_t va);
@


1.17.8.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a81 6
#define	mfcpu(r,v)	/* XXX for the lack of the mnemonics */		\
	__asm __volatile(".word	%1\n\t"					\
			 "copy	%%r22, %0"				\
	    : "=r" (v) : "i" ((0x14000600 | ((r) << 21) | ((22) << 16)))\
	    : "r22")

d89 1
a89 2
static __inline register_t
mtsm(register_t mask) {
d95 20
@


1.16
log
@fix some types
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.h,v 1.15 2000/03/29 23:11:12 mickey Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998 Michael Shalayeff
a121 36
ficache(pa_space_t sp, vaddr_t va, vsize_t size)
{
	extern int icache_stride;
	vaddr_t eva = (va + size + icache_stride - 1) & ~(icache_stride - 1);

	mtsp(sp, 1);
	while (va < eva)
		__asm __volatile ("fic,m %1(%%sr1, %0)"
				  : "+r" (va) : "r" (icache_stride));
}

static __inline void
fdcache(pa_space_t sp, vaddr_t va, vsize_t size)
{
	extern int dcache_stride;
	vaddr_t eva = (va + size + dcache_stride-1) & ~(dcache_stride - 1);

	mtsp(sp, 1);
	while (va < eva)
		__asm __volatile ("fdc,m %1(%%sr1, %0)"
				  : "+r" (va) : "r" (dcache_stride));
}

static __inline void
pdcache(pa_space_t sp, vaddr_t va, vsize_t size)
{
	extern int dcache_stride;
	vaddr_t eva = (va + size + dcache_stride - 1) & ~(dcache_stride - 1);

	mtsp(sp, 1);
	while (va < eva)
		__asm __volatile ("pdc,m %1(%%sr1, %0)"
				  : "+r" (va) : "r" (dcache_stride));
}

static __inline void
d221 3
@


1.15
log
@timeout-driven heartbeat.
right thing would be to pass beat count as an argument to timeout
routine (casted to (void *)) avoiding static counter, but
doing timeout_set() every timeout_add() sounds kinda uncool.
well, pondering in the struct timeout guts would be even more ugly.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.h,v 1.14 2000/02/09 05:10:10 mickey Exp $	*/
d73 2
a74 2
static __inline u_int ldsid(vaddr_t p) {
	register u_int ret;
d89 2
a90 2
static __inline u_int mtsm(u_int mask) {
	register u_int ret;
d98 1
a98 1
	register u_int ret;
d107 1
a107 1
	register u_int ret;
d125 1
a125 1
	register vaddr_t eva = (va + size + icache_stride-1) & ~(icache_stride-1);
d137 1
a137 1
	register vaddr_t eva = (va + size + dcache_stride-1) & ~(dcache_stride-1);
d149 1
a149 1
	register vaddr_t eva = (va + size + dcache_stride-1) & ~(dcache_stride-1);
@


1.14
log
@yes, better netled names
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.h,v 1.13 2000/02/09 05:04:22 mickey Exp $	*/
a261 1
void heartbeat __P((int on));
@


1.14.2.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.h,v 1.17 2000/05/15 17:22:40 mickey Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998,2000 Michael Shalayeff
d73 2
a74 2
static __inline register_t ldsid(vaddr_t p) {
	register_t ret;
d89 2
a90 2
static __inline register_t mtsm(register_t mask) {
	register_t ret;
d98 1
a98 1
	register_t ret;
d107 1
a107 1
	register_t ret;
d122 36
a256 3
void ficache __P((pa_space_t sp, vaddr_t va, vsize_t size));
void fdcache __P((pa_space_t sp, vaddr_t va, vsize_t size));
void pdcache __P((pa_space_t sp, vaddr_t va, vsize_t size));
d262 1
@


1.14.2.2
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d221 8
a228 9
extern int (*cpu_hpt_init)(vaddr_t hpt, vsize_t hptsize);

void ficache(pa_space_t sp, vaddr_t va, vsize_t size);
void fdcache(pa_space_t sp, vaddr_t va, vsize_t size);
void pdcache(pa_space_t sp, vaddr_t va, vsize_t size);
void fcacheall(void);
void ptlball(void);
int btlb_insert(pa_space_t space, vaddr_t va, paddr_t pa, vsize_t *lenp, u_int prot);
hppa_hpa_t cpu_gethpa(int n);
@


1.14.2.3
log
@Sync the SMP branch with 3.3
@
text
@a222 1
void fpu_save(vaddr_t va);
@


1.14.2.4
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.h,v 1.14.2.3 2003/03/27 23:26:54 niklas Exp $	*/
a81 6
#define	mfcpu(r,v)	/* XXX for the lack of the mnemonics */		\
	__asm __volatile(".word	%1\n\t"					\
			 "copy	%%r22, %0"				\
	    : "=r" (v) : "i" ((0x14000600 | ((r) << 21) | ((22) << 16)))\
	    : "r22")

d89 1
a89 2
static __inline register_t
mtsm(register_t mask) {
d95 20
@


1.14.2.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d85 1
a85 1
	    : "=r" (v) : "i" ((0x14001400 | ((r) << 21) | (22)))	\
a217 1
void eaio_l2(int i);
@


1.14.2.6
log
@Merge with the trunk
@
text
@d4 1
a4 1
 * Copyright (c) 1998-2004 Michael Shalayeff
d15 5
d24 7
a30 8
 * IN NO EVENT SHALL THE AUTHOR OR HIS RELATIVES BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
a210 1
void fpu_exit(void);
@


1.13
log
@heartbeat -- yeah we have a patch for that
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.h,v 1.12 1999/12/18 08:52:05 mickey Exp $	*/
d214 2
a215 2
#define	PALED_NETOUT	0x01
#define	PALED_NETIN	0x02
@


1.12
log
@add pdcache(), purge data cache
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.h,v 1.11 1999/11/25 18:27:06 mickey Exp $	*/
d212 43
@


1.11
log
@'+' vs '=','0' constraints
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.h,v 1.10 1999/08/12 18:45:33 mickey Exp $	*/
d142 12
@


1.10
log
@fix asm() modifiers
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.h,v 1.9 1999/05/22 00:16:42 mickey Exp $	*/
d129 2
a130 2
		__asm __volatile ("fic,m %2(%%sr1, %1)"
				  : "=r" (va): "0" (va), "r" (icache_stride));
d141 2
a142 2
		__asm __volatile ("fdc,m %2(%%sr1, %1)"
				  : "=r" (va): "0" (va), "r" (dcache_stride));
@


1.9
log
@fix f{d,i}cache wrt last cache line
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.h,v 1.8 1999/05/02 03:41:45 mickey Exp $	*/
d92 1
a92 1
			 "mtsm %1": "=r" (ret) : "r" (mask));
@


1.8
log
@new {s,g}et_psw()
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.h,v 1.7 1999/04/20 19:29:12 mickey Exp $	*/
d125 1
a125 1
	register vaddr_t eva = va + size;
d137 1
a137 1
	register vaddr_t eva = va + size;
@


1.7
log
@uvm names and definitions
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.h,v 1.6 1999/02/25 17:23:34 mickey Exp $	*/
d96 7
a102 12
#if 0
static __inline void set_psw(u_int psw) {
	__asm __volatile("mtctl %0, %%cr22\n\t"
			 "mtctl %%r0, %%cr17\n\t"
			 "mtctl %%r0, %%cr17\n\t"
			 "ldil L%%., %0\n\t"
			 "ldo R%%.+24(%0), %0\n\t"
			 "mtctl %0, %%cr18\n\t"
			 "ldo 4(%0), %0\n\t"
			 "mtctl %0, %%cr18\n\t"
			 "rfi\n\tnop\n\tnop"
			 :: "r" (psw));
d104 11
a114 3
#else
void set_psw __P((u_int psw));
#endif
@


1.6
log
@fix c&p in fice() (s/fdce/fice/); cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.h,v 1.5 1998/12/29 21:47:13 mickey Exp $	*/
d73 1
a73 1
static __inline u_int ldsid(vm_offset_t p) {
d119 1
a119 1
ficache(pa_space_t sp, vm_offset_t va, vm_size_t size)
d122 1
a122 1
	register vm_offset_t eva = va + size;
d131 1
a131 1
fdcache(pa_space_t sp, vm_offset_t va, vm_size_t size)
d134 1
a134 1
	register vm_offset_t eva = va + size;
d143 1
a143 1
iitlba(u_int pg, pa_space_t sp, vm_offset_t va)
d150 1
a150 1
idtlba(u_int pg, pa_space_t sp, vm_offset_t va)
d157 1
a157 1
iitlbp(u_int prot, pa_space_t sp, vm_offset_t va)
d164 1
a164 1
idtlbp(u_int prot, pa_space_t sp, vm_offset_t va)
d171 1
a171 1
pitlb(pa_space_t sp, vm_offset_t va)
d178 1
a178 1
pdtlb(pa_space_t sp, vm_offset_t va)
d185 1
a185 1
pitlbe(pa_space_t sp, vm_offset_t va)
d192 1
a192 1
pdtlbe(pa_space_t sp, vm_offset_t va)
d201 2
a202 2
int btlb_insert __P((pa_space_t space, vm_offset_t va, vm_offset_t pa,
		     vm_size_t *lenp, u_int prot));
@


1.5
log
@make fcacheall(), ptlball() void on args, so anybody can call 'em
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.h,v 1.4 1998/12/05 17:33:01 mickey Exp $	*/
d114 1
a114 1
#define	fice(sp,off) __asm __volatile("fdce 0(%0,%1)":: "i" (sp), "r" (off))
d119 1
a119 1
ficache(pa_space_t space, vm_offset_t off, vm_size_t size)
d121 2
d124 4
d131 1
a131 1
fdcache(pa_space_t space, vm_offset_t off, vm_size_t size)
d133 2
d136 4
d143 1
a143 1
iitlba(u_int pg, pa_space_t sp, vm_offset_t off)
d145 2
a146 2
	mtsp(1, sp);
	__asm volatile("iitlba %0,(%%sr1, %1)":: "r" (pg), "r" (off));
d150 1
a150 1
idtlba(u_int pg, pa_space_t sp, vm_offset_t off)
d153 1
a153 1
	__asm volatile("idtlba %0,(%%sr1, %1)":: "r" (pg), "r" (off));
d157 1
a157 1
iitlbp(u_int prot, pa_space_t sp, vm_offset_t off)
d160 1
a160 1
	__asm volatile("iitlbp %0,(%%sr1, %1)":: "r" (prot), "r" (off));
d164 1
a164 1
idtlbp(u_int prot, pa_space_t sp, vm_offset_t off)
d167 1
a167 1
	__asm volatile("idtlbp %0,(%%sr1, %1)":: "r" (prot), "r" (off));
d171 1
a171 1
pitlb(pa_space_t sp, vm_offset_t off)
d174 1
a174 1
	__asm volatile("pitlb %%r0(%%sr1, %0)":: "r" (off));
d178 1
a178 1
pdtlb(pa_space_t sp, vm_offset_t off)
d181 1
a181 1
	__asm volatile("pdtlb %%r0(%%sr1, %0)":: "r" (off));
d185 1
a185 1
pitlbe(pa_space_t sp, vm_offset_t off)
d188 1
a188 1
	__asm volatile("pitlbe %%r0(%%sr1, %0)":: "r" (off));
d192 1
a192 1
pdtlbe(pa_space_t sp, vm_offset_t off)
d195 1
a195 1
	__asm volatile("pdtlbe %%r0(%%sr1, %0)":: "r" (off));
@


1.4
log
@btlb_insert() now returns slot number, heartbeat() and cpu_gethpa(to get cpu#0 HPA) prototypes
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.h,v 1.3 1998/10/30 22:16:42 mickey Exp $	*/
d187 2
a188 3
struct pdc_cache;
void fcacheall __P((struct pdc_cache *));
void ptlball __P((struct pdc_cache *));
@


1.3
log
@remove all those "black magic" inspired routines,
use PDC calls instead, which is more MI.
we also don't need pmap_map to be defined any more, unless
kernel mapping enforced through FORCE_MAP_KERNEL definition.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.h,v 1.2 1998/08/29 01:56:55 mickey Exp $	*/
d190 1
a190 1
int btlb_insert __P((int i, pa_space_t space, vm_offset_t va, vm_offset_t pa,
d192 2
@


1.2
log
@more functions
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.h,v 1.1 1998/07/07 21:32:40 mickey Exp $	*/
d4 29
d61 2
a62 2
#ifndef _HPPA_CPUFUNC_H_
#define _HPPA_CPUFUNC_H_
d67 1
a67 1
#define tlbbtop(b) (((b) & ~PGOFSET) >> (PGSHIFT - 5))
d70 1
a78 56
/* Disable SID hashing and flush all caches for S-CHIP */
static __inline u_int disable_S_sid_hashing(void) {
	register u_int t, ret;
	__asm ("mfcpu	(0,%1)\n\t"	/* get cpu diagnosic register */
	       "mfcpu	(0,%1)\n\t"	/* black magic */
	       "copy	%1,%0\n\t"
	       "depi	0,20,3,%1\n\t"	/* clear DHE, domain and IHE bits */
	       "depi	1,16,1,%1\n\t"	/* enable quad-word stores */
	       "depi	0,10,1,%1\n\t"	/* do not clear the DHPMC bit */
	       "depi	0,14,1,%1\n\t"	/* do not clear the ILPMC bit */
	       "mtcpu	(%1,0)\n\t"	/* set the cpu disagnostic register */
	       "mtcpu	(%1,0)\n\t"	/* black magic */
	       : "=r" (ret) : "r" (t));
	return ret;
}

/* Disable SID hashing and flush all caches for T-CHIP */
static __inline u_int disable_T_sid_hashing(void) {
	register u_int t, ret;
	__asm("mfcpu	(0,%1)\n\t"	/* get cpu diagnosic register */
	      "mfcpu	(0,%1)\n\t"	/* black magic */
	      "copy	%1,%0\n\t"
	      "depi	0,18,1,%1\n\t"	/* clear DHE bit */
	      "depi	0,20,1,%1\n\t"	/* clear IHE bit */
	      "depi	0,10,1,%1\n\t"	/* do not clear the DHPMC bit */
	      "depi	0,14,1,%1\n\t"	/* do not clear the ILPMC bit */
	      "mtcpu	(%1,0)\n\t"	/* set the cpu disagnostic register */
	      "mtcpu	(%1,0)\n\t"	/* black magic */
	       : "=r" (ret) : "r" (t));
	return ret;
}

/* Disable SID hashing and flush all caches for L-CHIP */
static __inline u_int disable_L_sid_hashing(void) {
	register u_int t, ret;
	__asm("mfcpu2	(0,%1)\n\t"	/* get cpu diagnosic register  */
/*	      ".word	0x14160600\n\t" */
	      "copy	%1,%0\n\t"
	      "depi	0,27,1,%1\n\t"	/* clear DHE bit */
	      "depi	0,28,1,%1\n\t"	/* clear IHE bit */
	      "depi	0,6,1,%1\n\t"	/* do not clear the L2IHPMC bit */
	      "depi	0,8,1,%1\n\t"	/* do not clear the L2DHPMC bit */
	      "depi	0,10,1,%1\n\t"	/* do not clear the L1IHPMC bit */
	      "mtcpu2	(%1,0)"		/* set the cpu disagnostic register */ 
/*	      ".word	0x14160240\n\t" */
	       : "=r" (ret) : "r" (t));
	return ret;
}

static __inline u_int get_dcpu_reg(void) {
	register u_int ret;
	__asm("mfcpu	(0,%0)\n\t"	/* Get cpu diagnostic register */
	      "mfcpu	(0,%0)": "=r" (ret));	/* black magic */
	return ret;
}

a81 6
#define mtcpu(v,r) __asm __volatile("mtcpu %0,%1":: "r" (v), "i" (r))
#define mfcpu(r,v) __asm __volatile("mfcpu %1,%0": "=r" (v): "i" (r))

#define mtcpu2(v,r) __asm __volatile("mtcpu2 %0,%1":: "r" (v), "i" (r))
#define mfcpu2(r,v) __asm __volatile("mfcpu2 %1,%0": "=r" (v): "i" (r))

d96 1
d98 2
a99 1
	__asm __volatile("mtctl %%r0, %%cr17\n\t"
d101 7
a107 9
			 "ldil L%%.+32, %%r21\n\t"
			 "ldo R%%.+28(%%r21), %%r21\n\t"
			 "mtctl %%r21, %%cr17\n\t"
			 "ldo 4(%%r21), %%r21\n\t"
			 "mtctl %%r21, %%cr17\n\t"
			 "mtctl %0, %%cr22\n\t"
			 "rfi\n\t"
			 "nop\n\tnop\n\tnop\n\tnop"
			 :: "r" (psw): "r21");
d109 3
a185 116
static __inline void
ibitlb(int i, vm_offset_t pa, vm_offset_t va, vm_size_t sz, u_int prot)
{

}

static __inline void
pbitlb(int i)
{
}

static __inline void
ibdtlb(int i, vm_offset_t pa, vm_offset_t va, vm_size_t sz, u_int prot)
{

}

static __inline void
pbdtlb(int i)
{
}

static __inline void
ibctlb(int i, vm_offset_t pa, vm_offset_t va, vm_size_t sz, u_int prot)
{
	register u_int psw, t;

	rsm(PSW_R|PSW_I,psw);

	t = 0x7fc1|((i&15)<<1);	/* index 127, lockin, override, mismatch */
	mtcpu(t,8);		/* move to the dtlb diag reg */
	mtcpu(t,8);		/* black magic */

	prot |= TLB_DIRTY;
	sz = (~sz >> 7) & 0x7f000;
	pa = (tlbbtop(pa) & 0x7f000) | sz;
	va = (va & 0x7f000) | sz;

	idtlba(pa, 0, va);
	idtlbp(prot, 0, va);

	t |= 0x2000;		/* no lockout, PE force-ins disable */
	mtcpu2(t,8);		/* move to the dtlb diagnostic register */

	mtsm(psw);
}

static __inline void
pbctlb(int i)
{
	register u_int psw, t;

	rsm(PSW_R|PSW_I,psw);

	t = 0xffc1|((i&15)<<1);	/* index 127, lockin, override, mismatch */
	mtcpu(t,8);		/* move to the dtlb diag reg */
	mtcpu(t,8);		/* black magic */

	idtlba(0,0,0);		/* address does not matter */
	idtlbp(0,0,0);

	t |= 0x7f << 7;
	mtcpu(t,8);		/* move to the dtlb diagnostic register */
	mtcpu(t,8);		/* black magic */

	mtsm(psw);
}

static __inline void
iLbctlb(int i, vm_offset_t pa, vm_offset_t va, vm_offset_t sz, u_int prot)
{
	register u_int psw, t;

	rsm(PSW_R|PSW_I,psw);

	t = 0x6041| ((i&7)<<1);	/* lockin, PE force-insert disable,
				   PE LRU-ins dis, BE force-ins enable
				   set the block enter select bit */
	mtcpu2(t, 8);		/* move to the dtlb diagnostic register */

	prot |= TLB_DIRTY;
	sz = (~sz >> 7) & 0x7f000;
	pa = (tlbbtop(pa) & 0x7f000) | sz;
	va = (va & 0x7f000) | sz;

	/* we assume correct address/size alignment */
	idtlba(pa, 0, va);
	idtlbp(prot, 0, va);

	t |= 0x2000;		/* no lockin, PE force-ins disable */
	mtcpu2(t, 8);		/* move to the dtlb diagnostic register */

	mtsm(psw);
}

static __inline void
pLbctlb(int i)
{
	register u_int psw, t;

	rsm(PSW_R|PSW_I,psw);

	t = 0xc041| ((i&7)<<1);	/* lockout, PE force-insert disable,
				   PE LRU-ins dis, BE force-ins enable
				   set the block enter select bit */
	mtcpu2(t,8);		/* move to the dtlb diagnostic register */

	idtlba(0,0,0);		/* address does not matter */
	idtlbp(0,0,0);

	t |= 0x2000;		/* no lockout, PE force-ins disable */
	mtcpu2(t,8);		/* move to the dtlb diagnostic register */

	mtsm(psw);
}

d190 2
d194 1
a194 4
#endif /* _HPPA_CPUFUNC_H_ */



@


1.1
log
@more includes
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a16 1

d32 5
a36 3
/*
 * hppa routines to move to and from control registers from C
 */
d38 2
a40 3
/*
 * Get space register for an address
 */
d42 1
d45 17
a61 1
	__asm __volatile("ldsid (%1),%0" : "=r" (p) : "r" (ret));
d65 14
a78 60
/*
 * Move the specified value into the control register. The register is taken
 * modulo 32. If the register is invalid the operation is ignored.
 */
static __inline void mtctl(int reg, int value) {
	reg %= 32;
	if (reg == 0)
		__asm __volatile("mtctl %0, cr0" : : "r" (value));
	else if (reg > 7)
		;
#if 0
	bv 0(r2)
	mtctl	arg1,cr8
	bv 0(r2)
	mtctl	arg1,cr9
	bv 0(r2)
	mtctl	arg1,cr10
	bv 0(r2)
	mtctl	arg1,cr11
	bv 0(r2)
	mtctl	arg1,cr12
	bv 0(r2)
	mtctl	arg1,cr13
	bv 0(r2)
	mtctl	arg1,cr14
	bv 0(r2)
	mtctl	arg1,cr15
	bv 0(r2)
	mtctl	arg1,cr16
	bv 0(r2)
	mtctl	arg1,cr17
	bv 0(r2)
	mtctl	arg1,cr18
	bv 0(r2)
	mtctl	arg1,cr19
	bv 0(r2)
	mtctl	arg1,cr20
	bv 0(r2)
	mtctl	arg1,cr21
	bv 0(r2)
	mtctl	arg1,cr22
	bv 0(r2)
	mtctl	arg1,cr23
	bv 0(r2)
	mtctl	arg1,cr24
	bv 0(r2)
	mtctl	arg1,cr25
	bv 0(r2)
	mtctl	arg1,cr26
	bv 0(r2)
	mtctl	arg1,cr27
	bv 0(r2)
	mtctl	arg1,cr28
	bv 0(r2)
	mtctl	arg1,cr29
	bv 0(r2)
	mtctl	arg1,cr30
	bv 0(r2)
	mtctl	arg1,cr31
#endif
d81 16
a96 4
/*
 * Return the contents of the specified control register. The register is taken
 * modulo 32. If the register is invalid the operation is ignored.
 */
d98 1
a98 1
static __inline u_int mfctl(int reg) {
d100 2
a101 55
	reg %= 32;
	if (reg == 0)
		__asm __volatile("mfctl cr0,%0" : "=r" (ret));
	else if (reg > 7)
		;
#if 0
	bv	0(r2)
	mfctl	cr8,ret0
	bv	0(r2)
	mfctl	cr9,ret0
	bv	0(r2)
	mfctl	cr10,ret0
	bv	0(r2)
	mfctl	cr11,ret0
	bv	0(r2)
	mfctl	cr12,ret0
	bv	0(r2)
	mfctl	cr13,ret0
	bv	0(r2)
	mfctl	cr14,ret0
	bv	0(r2)
	mfctl	cr15,ret0
	bv	0(r2)
	mfctl	cr16,ret0
	bv	0(r2)
	mfctl	cr17,ret0
	bv	0(r2)
	mfctl	cr18,ret0
	bv	0(r2)
	mfctl	cr19,ret0
	bv	0(r2)
	mfctl	cr20,ret0
	bv	0(r2)
	mfctl	cr21,ret0
	bv	0(r2)
	mfctl	cr22,ret0
	bv	0(r2)
	mfctl	cr23,ret0
	bv	0(r2)
	mfctl	cr24,ret0
	bv	0(r2)
	mfctl	cr25,ret0
	bv	0(r2)
	mfctl	cr26,ret0
	bv	0(r2)
	mfctl	cr27,ret0
	bv	0(r2)
	mfctl	cr28,ret0
	bv	0(r2)
	mfctl	cr29,ret0
	bv	0(r2)
	mfctl	cr30,ret0
	bv	0(r2)
	mfctl	cr31,ret0
#endif
d105 2
a106 9
#if 0
/*
 * int mtsp(sr, value)
 *	int	sr;
 *	int	value;
 *
 * Move the specified value into a space register. The space register is taken
 * modulo 8.
 */
d108 2
a109 4
	.export	mtsp,entry
	.proc
	.callinfo
mtsp
d111 2
a112 5
/*
 * take the register number modulo 8
 */
	ldi	7,t1
	and	t1,arg0,arg0
d114 2
a115 3
/*
 * write the value to the specified register
 */
d117 2
a118 2
	blr,n	arg0,r0
	nop
d120 7
a126 16
	bv	0(r2)
	mtsp	arg1,sr0
	bv	0(r2)
	mtsp	arg1,sr1
	bv	0(r2)
	mtsp	arg1,sr2
	bv	0(r2)
	mtsp	arg1,sr3
	bv	0(r2)
	mtsp	arg1,sr4
	bv	0(r2)
	mtsp	arg1,sr5
	bv	0(r2)
	mtsp	arg1,sr6
	bv	0(r2)
	mtsp	arg1,sr7
d128 13
a140 1
	.procend
d142 4
d147 3
a149 7
/*
 * int mfsr(reg)
 *	int	reg;
 *
 * Return the contents of the specified space register. The space register is 
 * taken modulo 8.
 */
d151 1
a151 4
	.export	mfsp,entry
	.proc
	.callinfo
mfsp
d153 3
a155 5
/*
 * take the register number modulo 8
 */
	ldi	7,t1
	and	t1,arg0,arg0
d157 1
a157 3
/*
 * write the value to the specified register
 */
d159 6
a164 2
	blr,n	arg0,r0
	nop
d166 6
a171 16
	bv	0(r2)
	mfsp	sr0,ret0
	bv	0(r2)
	mfsp	sr1,ret0
	bv	0(r2)
	mfsp	sr2,ret0
	bv	0(r2)
	mfsp	sr3,ret0
	bv	0(r2)
	mfsp	sr4,ret0
	bv	0(r2)
	mfsp	sr5,ret0
	bv	0(r2)
	mfsp	sr6,ret0
	bv	0(r2)
	mfsp	sr7,ret0
d173 6
a178 1
	.procend
d180 6
d187 6
a192 9
/*
 * int ssm(mask)
 *	int	mask;
 *
 * Set system mask. This call will not set the Q bit even if it is 
 * specified.
 *
 * Returns the old system mask
 */
d194 6
a199 4
	.export	ssm,entry
	.proc
	.callinfo
ssm
d201 6
a206 5
/*
 * look at only the lower 5 bits of the mask
 */
	ldi	31,t1
	and	t1,arg0,arg0
d208 6
d215 3
a217 3
/*
 * Set System Mask and Return
 */
d219 1
a219 2
	blr,n	arg0,r0
	nop
d221 4
a224 64
	bv	0(r2)
	ssm	0,ret0
	bv	0(r2)
	ssm	1,ret0
	bv	0(r2)
	ssm	2,ret0
	bv	0(r2)
	ssm	3,ret0
	bv	0(r2)
	ssm	4,ret0
	bv	0(r2)
	ssm	5,ret0
	bv	0(r2)
	ssm	6,ret0
	bv	0(r2)
	ssm	7,ret0
	bv	0(r2)
	ssm	0,ret0		/* can't set Q bit with ssm */
	bv	0(r2)
	ssm	1,ret0		/* can't set Q bit with ssm */
	bv	0(r2)
	ssm	2,ret0		/* can't set Q bit with ssm */
	bv	0(r2)
	ssm	3,ret0		/* can't set Q bit with ssm */
	bv	0(r2)
	ssm	4,ret0		/* can't set Q bit with ssm */
	bv	0(r2)
	ssm	5,ret0		/* can't set Q bit with ssm */
	bv	0(r2)
	ssm	6,ret0		/* can't set Q bit with ssm */
	bv	0(r2)
	ssm	7,ret0		/* can't set Q bit with ssm */
	bv	0(r2)
	ssm	16,ret0
	bv	0(r2)
	ssm	17,ret0
	bv	0(r2)
	ssm	18,ret0
	bv	0(r2)
	ssm	19,ret0
	bv	0(r2)
	ssm	20,ret0
	bv	0(r2)
	ssm	21,ret0
	bv	0(r2)
	ssm	22,ret0
	bv	0(r2)
	ssm	23,ret0
	bv	0(r2)
	ssm	16,ret0		/* can't set Q bit with ssm */
	bv	0(r2)
	ssm	17,ret0		/* can't set Q bit with ssm */
	bv	0(r2)
	ssm	18,ret0		/* can't set Q bit with ssm */
	bv	0(r2)
	ssm	19,ret0		/* can't set Q bit with ssm */
	bv	0(r2)
	ssm	20,ret0		/* can't set Q bit with ssm */
	bv	0(r2)
	ssm	21,ret0		/* can't set Q bit with ssm */
	bv	0(r2)
	ssm	22,ret0		/* can't set Q bit with ssm */
	bv	0(r2)
	ssm	23,ret0		/* can't set Q bit with ssm */
d226 3
a228 1
	.procend
d230 1
d232 4
a235 8
/*
 * int rsm(mask)
 *	int	mask;
 *
 * Reset system mask. 
 *
 * Returns the old system mask
 */
d237 4
a240 4
	.export	rsm,entry
	.proc
	.callinfo
rsm
d242 1
a242 5
/*
 * look at only the lower 5 bits of the mask
 */
	ldi	31,t1
	and	t1,arg0,arg0
d244 3
a246 3
/*
 * Set System Mask and Return
 */
d248 4
a251 2
	blr,n	arg0,r0
	nop
d253 2
a254 64
	bv	0(r2)
	rsm	0,ret0
	bv	0(r2)
	rsm	1,ret0
	bv	0(r2)
	rsm	2,ret0
	bv	0(r2)
	rsm	3,ret0
	bv	0(r2)
	rsm	4,ret0
	bv	0(r2)
	rsm	5,ret0
	bv	0(r2)
	rsm	6,ret0
	bv	0(r2)
	rsm	7,ret0
	bv	0(r2)
	rsm	8,ret0
	bv	0(r2)
	rsm	9,ret0
	bv	0(r2)
	rsm	10,ret0
	bv	0(r2)
	rsm	11,ret0
	bv	0(r2)
	rsm	12,ret0
	bv	0(r2)
	rsm	13,ret0
	bv	0(r2)
	rsm	14,ret0
	bv	0(r2)
	rsm	15,ret0
	bv	0(r2)
	rsm	16,ret0
	bv	0(r2)
	rsm	17,ret0
	bv	0(r2)
	rsm	18,ret0
	bv	0(r2)
	rsm	19,ret0
	bv	0(r2)
	rsm	20,ret0
	bv	0(r2)
	rsm	21,ret0
	bv	0(r2)
	rsm	22,ret0
	bv	0(r2)
	rsm	23,ret0
	bv	0(r2)
	rsm	24,ret0
	bv	0(r2)
	rsm	25,ret0
	bv	0(r2)
	rsm	26,ret0
	bv	0(r2)
	rsm	27,ret0
	bv	0(r2)
	rsm	28,ret0
	bv	0(r2)
	rsm	29,ret0
	bv	0(r2)
	rsm	30,ret0
	bv	0(r2)
	rsm	31,ret0
d256 2
a257 1
	.procend
d259 2
d262 4
a265 6
/*
 * int mtsm(mask)
 *	int mask;
 *
 * Move to system mask. Old value of system mask is returned.
 */
d267 1
a267 4
	.export	mtsm,entry
	.proc
	.callinfo
mtsm
d269 3
a271 6
/* 
 * Move System Mask and Return
 */
	ssm	0,ret0
	bv	0(r2)
	mtsm	arg0
d273 2
a274 2
	.procend
#endif
d276 3
a278 3
static __inline void
ficache(pa_space_t space, vm_offset_t off, vm_size_t size)
{
d280 1
d284 1
a284 1
fdcache(pa_space_t space, vm_offset_t off, vm_size_t size)
d286 1
d288 20
d311 1
a311 1
pitlb(pa_space_t sp, vm_offset_t off)
d313 8
d322 7
d331 5
a335 3
static __inline void
pdtlb(pa_space_t sp, vm_offset_t off)
{
d337 1
a337 1
}
a338 4
void phys_page_copy __P((vm_offset_t, vm_offset_t));
void phys_bzero __P((vm_offset_t, vm_size_t));
void lpage_copy __P((int, pa_space_t, vm_offset_t, vm_offset_t));
void lpage_zero __P((int, vm_offset_t, pa_space_t));
@

