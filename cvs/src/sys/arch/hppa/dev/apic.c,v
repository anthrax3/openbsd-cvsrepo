head	1.18;
access;
symbols
	OPENBSD_6_0:1.18.0.4
	OPENBSD_6_0_BASE:1.18
	OPENBSD_5_9:1.18.0.2
	OPENBSD_5_9_BASE:1.18
	OPENBSD_5_8:1.16.0.6
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.16.0.2
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.15.0.4
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.14.0.14
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.14.0.10
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.14.0.8
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.6
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.4
	OPENBSD_5_0:1.14.0.2
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.12.0.2
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.11.0.2
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.8.0.2
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.7.0.10
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.6
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.4
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.2
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.6.0.2
	OPENBSD_4_2_BASE:1.6;
locks; strict;
comment	@ * @;


1.18
date	2015.09.08.07.14.04;	author deraadt;	state Exp;
branches;
next	1.17;
commitid	EsikxqfygOQoIEgZ;

1.17
date	2015.08.12.05.39.36;	author mlarkin;	state Exp;
branches;
next	1.16;
commitid	ytvLTAwVNmN0NBWc;

1.16
date	2014.12.09.06.58.28;	author doug;	state Exp;
branches;
next	1.15;
commitid	yWAxzpQP2PPpYlfT;

1.15
date	2014.07.12.18.44.41;	author tedu;	state Exp;
branches;
next	1.14;
commitid	uKVPYMN2MLxdZxzH;

1.14
date	2011.05.01.21.59.39;	author kettenis;	state Exp;
branches;
next	1.13;

1.13
date	2011.04.23.22.20.22;	author kettenis;	state Exp;
branches;
next	1.12;

1.12
date	2010.09.20.06.33.47;	author matthew;	state Exp;
branches;
next	1.11;

1.11
date	2010.08.07.03.50.01;	author krw;	state Exp;
branches;
next	1.10;

1.10
date	2010.05.24.15.04.53;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2010.04.01.22.53.49;	author kettenis;	state Exp;
branches;
next	1.8;

1.8
date	2009.08.22.02.54.50;	author mk;	state Exp;
branches;
next	1.7;

1.7
date	2007.10.06.23.50.54;	author krw;	state Exp;
branches;
next	1.6;

1.6
date	2007.07.01.14.20.50;	author kettenis;	state Exp;
branches;
next	1.5;

1.5
date	2007.06.30.15.24.49;	author kettenis;	state Exp;
branches;
next	1.4;

1.4
date	2007.06.18.22.46.51;	author kettenis;	state Exp;
branches;
next	1.3;

1.3
date	2007.06.17.14.51.21;	author kettenis;	state Exp;
branches;
next	1.2;

1.2
date	2007.05.27.16.36.07;	author kettenis;	state Exp;
branches;
next	1.1;

1.1
date	2007.05.21.22.43.38;	author kettenis;	state Exp;
branches;
next	;


desc
@@


1.18
log
@sizes for free(), when known; ok semarie
@
text
@/*	$OpenBSD: apic.c,v 1.17 2015/08/12 05:39:36 mlarkin Exp $	*/

/*
 * Copyright (c) 2005 Michael Shalayeff
 * Copyright (c) 2007 Mark Kettenis
 * All rights reserved.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER IN
 * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
 * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/evcount.h>
#include <sys/malloc.h>

#include <machine/autoconf.h>
#include <machine/pdc.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>

#include <hppa/dev/elroyreg.h>
#include <hppa/dev/elroyvar.h>

#define APIC_INT_LINE_MASK	0x0000ff00
#define APIC_INT_LINE_SHIFT	8
#define APIC_INT_IRQ_MASK	0x0000001f

#define APIC_INT_LINE(x) (((x) & APIC_INT_LINE_MASK) >> APIC_INT_LINE_SHIFT)
#define APIC_INT_IRQ(x) ((x) & APIC_INT_IRQ_MASK)

/*
 * Interrupt types match the Intel MP Specification.
 */

#define MPS_INTPO_DEF		0
#define MPS_INTPO_ACTHI		1
#define MPS_INTPO_ACTLO		3
#define MPS_INTPO_SHIFT		0
#define MPS_INTPO_MASK		3

#define MPS_INTTR_DEF		0
#define MPS_INTTR_EDGE		1
#define MPS_INTTR_LEVEL		3
#define MPS_INTTR_SHIFT		2
#define MPS_INTTR_MASK		3

#define MPS_INT(p,t) \
    ((((p) & MPS_INTPO_MASK) << MPS_INTPO_SHIFT) | \
     (((t) & MPS_INTTR_MASK) << MPS_INTTR_SHIFT))

struct apic_iv {
	struct elroy_softc *sc;
	pci_intr_handle_t ih;
	int (*handler)(void *);
	void *arg;
	struct apic_iv *next;
	struct evcount *cnt;
};

struct apic_iv *apic_intr_list[CPU_NINTS];

void	apic_get_int_tbl(struct elroy_softc *);
u_int32_t apic_get_int_ent0(struct elroy_softc *, int);
#ifdef DEBUG
void	apic_dump(struct elroy_softc *);
#endif

void		apic_write(volatile struct elroy_regs *r, u_int32_t reg,
		    u_int32_t val);
u_int32_t	apic_read(volatile struct elroy_regs *r, u_int32_t reg);

void
apic_write(volatile struct elroy_regs *r, u_int32_t reg, u_int32_t val)
{
	elroy_write32(&r->apic_addr, htole32(reg));
	elroy_write32(&r->apic_data, htole32(val));
	elroy_read32(&r->apic_data);
}

u_int32_t
apic_read(volatile struct elroy_regs *r, u_int32_t reg)
{
	elroy_write32(&r->apic_addr, htole32(reg));
	return letoh32(elroy_read32(&r->apic_data));
}

void
apic_attach(struct elroy_softc *sc)
{
	volatile struct elroy_regs *r = sc->sc_regs;
	u_int32_t data;

	data = apic_read(r, APIC_VERSION);
	sc->sc_nints = (data & APIC_VERSION_NENT) >> APIC_VERSION_NENT_SHIFT;
	printf(" APIC ver %x, %d pins",
	    data & APIC_VERSION_MASK, sc->sc_nints);

	sc->sc_irq = mallocarray(sc->sc_nints, sizeof(int), M_DEVBUF,
	    M_NOWAIT | M_ZERO);
	if (sc->sc_irq == NULL)
		panic("apic_attach: cannot allocate irq table");

	apic_get_int_tbl(sc);

#ifdef DEBUG
	apic_dump(sc);
#endif
}

int
apic_intr_map(struct pci_attach_args *pa, pci_intr_handle_t *ihp)
{
	struct elroy_softc *sc = pa->pa_pc->_cookie;
	pci_chipset_tag_t pc = pa->pa_pc;
	pcitag_t tag = pa->pa_tag;
	pcireg_t reg;
	int line;

	reg = pci_conf_read(pc, tag, PCI_INTERRUPT_REG);
#ifdef DEBUG
	printf(" pin=%d line=%d ", PCI_INTERRUPT_PIN(reg),
	    PCI_INTERRUPT_LINE(reg));
#endif
	line = PCI_INTERRUPT_LINE(reg);
	if (sc->sc_irq[line] == 0)
		sc->sc_irq[line] = cpu_intr_findirq();
	*ihp = (line << APIC_INT_LINE_SHIFT) | sc->sc_irq[line];
	return (APIC_INT_IRQ(*ihp) == 0);
}

const char *
apic_intr_string(void *v, pci_intr_handle_t ih)
{
	static char buf[32];

	snprintf(buf, 32, "line %ld irq %ld",
	    APIC_INT_LINE(ih), APIC_INT_IRQ(ih));

	return (buf);
}

void *
apic_intr_establish(void *v, pci_intr_handle_t ih,
    int pri, int (*handler)(void *), void *arg, const char *name)
{
	struct elroy_softc *sc = v;
	volatile struct elroy_regs *r = sc->sc_regs;
	hppa_hpa_t hpa = cpu_gethpa(0);
	struct evcount *cnt;
	struct apic_iv *aiv, *biv;
	void *iv;
	int irq = APIC_INT_IRQ(ih);
	int line = APIC_INT_LINE(ih);
	u_int32_t ent0;

	/* no mapping or bogus */
	if (irq <= 0 || irq > 31)
		return (NULL);

	aiv = malloc(sizeof(struct apic_iv), M_DEVBUF, M_NOWAIT);
	if (aiv == NULL)
		return (NULL);

	cnt = malloc(sizeof(struct evcount), M_DEVBUF, M_NOWAIT);
	if (!cnt) {
		free(aiv, M_DEVBUF, sizeof *aiv);
		return (NULL);
	}

	aiv->sc = sc;
	aiv->ih = ih;
	aiv->handler = handler;
	aiv->arg = arg;
	aiv->next = NULL;
	aiv->cnt = cnt;

	evcount_attach(cnt, name, NULL);

	if (apic_intr_list[irq]) {
		biv = apic_intr_list[irq];
		while (biv->next)
			biv = biv->next;
		biv->next = aiv;
		return (arg);
	}

	if ((iv = cpu_intr_establish(pri, irq, apic_intr, aiv, NULL))) {
		ent0 = (31 - irq) & APIC_ENT0_VEC;
		ent0 |= apic_get_int_ent0(sc, line);
#if 0
		if (cold) {
			sc->sc_imr |= (1 << irq);
			ent0 |= APIC_ENT0_MASK;
		}
#endif
		apic_write(sc->sc_regs, APIC_ENT0(line), APIC_ENT0_MASK);
		apic_write(sc->sc_regs, APIC_ENT1(line),
		    ((hpa & 0x0ff00000) >> 4) | ((hpa & 0x000ff000) << 12));
		apic_write(sc->sc_regs, APIC_ENT0(line), ent0);

		/* Signal EOI. */
		elroy_write32(&r->apic_eoi,
		    htole32((31 - irq) & APIC_ENT0_VEC));

		apic_intr_list[irq] = aiv;
	}

	return (arg);
}

void
apic_intr_disestablish(void *v, void *cookie)
{
}

int
apic_intr(void *v)
{
	struct apic_iv *iv = v;
	struct elroy_softc *sc = iv->sc;
	volatile struct elroy_regs *r = sc->sc_regs;
	pci_intr_handle_t ih = iv->ih;
	int claimed = 0;

	while (iv) {
		claimed = iv->handler(iv->arg);
		if (claimed != 0 && iv->cnt)
			iv->cnt->ec_count++;
		if (claimed == 1)
			break;
		iv = iv->next;
	}

	/* Signal EOI. */
	elroy_write32(&r->apic_eoi,
	    htole32((31 - APIC_INT_IRQ(ih)) & APIC_ENT0_VEC));

	return (claimed);
}

/* Maximum number of supported interrupt routing entries. */
#define MAX_INT_TBL_SZ	16

void
apic_get_int_tbl(struct elroy_softc *sc)
{
	struct pdc_pat_io_num int_tbl_sz PDC_ALIGNMENT;
	struct pdc_pat_pci_rt int_tbl[MAX_INT_TBL_SZ] PDC_ALIGNMENT;
	size_t size;

	/*
	 * XXX int_tbl should not be allocated on the stack, but we need a
	 * 1:1 mapping, and malloc doesn't provide that.
	 */

	if (pdc_call((iodcio_t)pdc, 0, PDC_PCI_INDEX, PDC_PCI_GET_INT_TBL_SZ,
	    &int_tbl_sz, 0, 0, 0, 0, 0))
		return;

	if (int_tbl_sz.num > MAX_INT_TBL_SZ)
		panic("interrupt routing table too big (%d entries)",
		    int_tbl_sz.num);

	size = int_tbl_sz.num * sizeof(struct pdc_pat_pci_rt);
	sc->sc_int_tbl_sz = int_tbl_sz.num;
	sc->sc_int_tbl = malloc(size, M_DEVBUF, M_NOWAIT);
	if (sc->sc_int_tbl == NULL)
		return;

	if (pdc_call((iodcio_t)pdc, 0, PDC_PCI_INDEX, PDC_PCI_GET_INT_TBL,
	    &int_tbl_sz, 0, &int_tbl, 0, 0, 0))
		return;

	memcpy(sc->sc_int_tbl, int_tbl, size);
}

u_int32_t
apic_get_int_ent0(struct elroy_softc *sc, int line)
{
	volatile struct elroy_regs *r = sc->sc_regs;
	int trigger = MPS_INT(MPS_INTPO_DEF, MPS_INTTR_DEF);
	u_int32_t ent0 = APIC_ENT0_LOW | APIC_ENT0_LEV;
	int bus, mpspo, mpstr;
	int i;

	bus = letoh32(elroy_read32(&r->busnum)) & 0xff;
	for (i = 0; i < sc->sc_int_tbl_sz; i++) {
		if (bus == sc->sc_int_tbl[i].bus &&
		    line == sc->sc_int_tbl[i].line)
			trigger = sc->sc_int_tbl[i].trigger;
	}

	mpspo = (trigger >> MPS_INTPO_SHIFT) & MPS_INTPO_MASK;
	mpstr = (trigger >> MPS_INTTR_SHIFT) & MPS_INTTR_MASK;

	switch (mpspo) {
	case MPS_INTPO_DEF:
		break;
	case MPS_INTPO_ACTHI:
		ent0 &= ~APIC_ENT0_LOW;
		break;
	case MPS_INTPO_ACTLO:
		ent0 |= APIC_ENT0_LOW;
		break;
	default:
		panic("unknown MPS interrupt polarity %d", mpspo);
	}

	switch(mpstr) {
	case MPS_INTTR_DEF:
		break;
	case MPS_INTTR_LEVEL:
		ent0 |= APIC_ENT0_LEV;
		break;
	case MPS_INTTR_EDGE:
		ent0 &= ~APIC_ENT0_LEV;
		break;
	default:
		panic("unknown MPS interrupt trigger %d", mpstr);
	}

	return ent0;
}

#ifdef DEBUG
void
apic_dump(struct elroy_softc *sc)
{
	int i;

	for (i = 0; i < sc->sc_nints; i++)
		printf("0x%04x 0x%04x\n", apic_read(sc->sc_regs, APIC_ENT0(i)),
		    apic_read(sc->sc_regs, APIC_ENT1(i)));

	for (i = 0; i < sc->sc_int_tbl_sz; i++) {
		printf("type=%x ", sc->sc_int_tbl[i].type);
		printf("len=%d ", sc->sc_int_tbl[i].len);
		printf("itype=%d ", sc->sc_int_tbl[i].itype);			
		printf("trigger=%x ", sc->sc_int_tbl[i].trigger);		
		printf("pin=%x ", sc->sc_int_tbl[i].pin);		
		printf("bus=%d ", sc->sc_int_tbl[i].bus);
		printf("line=%d ", sc->sc_int_tbl[i].line);
		printf("addr=%x\n", sc->sc_int_tbl[i].addr);
	}
}
#endif
@


1.17
log
@
Fix a free of an uninitialized variable in an error path.

ok miod@@

found by Maxime Villard / Brainy Code Scanner. thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: apic.c,v 1.16 2014/12/09 06:58:28 doug Exp $	*/
d178 1
a178 1
		free(aiv, M_DEVBUF, 0);
@


1.16
log
@Replace some malloc(n*size,...) calls with mallocarray().

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: apic.c,v 1.15 2014/07/12 18:44:41 tedu Exp $	*/
d173 2
a174 4
	if (aiv == NULL) {
		free(cnt, M_DEVBUF, 0);
		return NULL;
	}
@


1.15
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: apic.c,v 1.14 2011/05/01 21:59:39 kettenis Exp $	*/
d110 1
a110 1
	sc->sc_irq = malloc(sc->sc_nints * sizeof(int), M_DEVBUF,
@


1.14
log
@Fix counting of interrupts for devices that attach to elroy(4).  Shared
interrupts would be counted double, once for the interrupting device and
once for the device at the head of the chain.  The handlers would run properly
though.  Avoid this by giving each device its own interrupt counter instead
of using the counter provided by the generic interrupt handling code for the
head of the chain.
@
text
@d1 1
a1 1
/*	$OpenBSD: apic.c,v 1.13 2011/04/23 22:20:22 kettenis Exp $	*/
d174 1
a174 1
		free(cnt, M_DEVBUF);
d180 1
a180 1
		free(aiv, M_DEVBUF);
@


1.13
log
@Stop calling shared interrupt handlers as soon as one of them return 1
(positive interrupt was for me), like we do on other architectures.
This is done here, at the elroy(4) driver level, since this is where shared
PCI interrupts are handled.  We could do something similar for dino(4) but
this optimization is probably not very relevant there.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: apic.c,v 1.12 2010/09/20 06:33:47 matthew Exp $	*/
d178 6
d189 4
a192 1
	aiv->cnt = NULL;
a193 7
		cnt = malloc(sizeof(struct evcount), M_DEVBUF, M_NOWAIT);
		if (!cnt) {
			free(aiv, M_DEVBUF);
			return (NULL);
		}

		evcount_attach(cnt, name, NULL);
a197 1
		aiv->cnt = cnt;
d201 1
a201 1
	if ((iv = cpu_intr_establish(pri, irq, apic_intr, aiv, name))) {
@


1.12
log
@Get rid of evcount's support for arranging counters in a tree
hierarchy.  Everything attached to a single root node anyway, so at
best we had a bush.

"i think it is good" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: apic.c,v 1.11 2010/08/07 03:50:01 krw Exp $	*/
d239 5
a243 6
		if (iv->handler(iv->arg)) {
			if (iv->cnt)
				iv->cnt->ec_count++;
			else
				claimed = 1;
		}
@


1.11
log
@No "\n" needed at the end of panic() strings.

Bogus chunks pointed out by matthew@@ and miod@@. No cookies for
marco@@ and jasper@@.

ok deraadt@@ miod@@ matthew@@ jasper@@ macro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: apic.c,v 1.10 2010/05/24 15:04:53 deraadt Exp $	*/
d191 1
a191 1
		evcount_attach(cnt, name, NULL, &evcount_intr);
@


1.10
log
@Add missing prototypes
ok jsing kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: apic.c,v 1.9 2010/04/01 22:53:49 kettenis Exp $	*/
d113 1
a113 1
		panic("apic_attach: cannot allocate irq table\n");
@


1.9
log
@Avoid null pointer dereference.  Pointed out by Nick Hudson; variant on his
diff from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: apic.c,v 1.8 2009/08/22 02:54:50 mk Exp $	*/
d79 4
@


1.8
log
@Constify the what/name parameter of pci_intr_establish().

Tested by myself, sthen, oga, kettenis, and jasper.
Input from sthen and jasper.

ok kettenis

(Manpage follows shortly.)
@
text
@d1 1
a1 1
/*	$OpenBSD: apic.c,v 1.7 2007/10/06 23:50:54 krw Exp $	*/
d231 1
d246 1
a246 1
	    htole32((31 - APIC_INT_IRQ(iv->ih)) & APIC_ENT0_VEC));
@


1.7
log
@Simpliest memset(,0,) -> M_ZERO changes. One (caddr *) cast removal,
otherwise just adding M_ZERO to malloc() and removing the immediately
adjacent memset(,0,).
@
text
@d1 1
a1 1
/*	$OpenBSD: apic.c,v 1.6 2007/07/01 14:20:50 kettenis Exp $	*/
d152 1
a152 1
    int pri, int (*handler)(void *), void *arg, char *name)
@


1.6
log
@Correctly count interrupts for devices that share interrupts.
@
text
@d1 1
a1 1
/*	$OpenBSD: apic.c,v 1.5 2007/06/30 15:24:49 kettenis Exp $	*/
d106 2
a107 1
	sc->sc_irq = malloc(sc->sc_nints * sizeof(int), M_DEVBUF, M_NOWAIT);
a109 1
	memset(sc->sc_irq, 0, sc->sc_nints * sizeof(int));
@


1.5
log
@Bump number of supported interrupt routing entries.
@
text
@d1 1
a1 1
/*	$OpenBSD: apic.c,v 1.4 2007/06/18 22:46:51 kettenis Exp $	*/
d23 1
d69 1
d157 1
d169 2
a170 1
	if (aiv == NULL)
d172 1
d179 1
d181 7
d192 1
d234 6
a239 1
		claimed |= iv->handler(iv->arg);
@


1.4
log
@Lookup interrupt routing info based on elroy(4) bus number.
Fix and simplify debug code that prints the interrupt routing info while
I'm there.
@
text
@d1 1
a1 1
/*	$OpenBSD: apic.c,v 1.3 2007/06/17 14:51:21 kettenis Exp $	*/
d232 1
a232 1
#define MAX_INT_TBL_SZ	8
@


1.3
log
@Get interrupt information from PDC and use it to program the IO SAPIC.
Needed to make edge triggered interrupts work.
@
text
@d1 1
a1 1
/*	$OpenBSD: apic.c,v 1.2 2007/05/27 16:36:07 kettenis Exp $	*/
d270 1
d273 1
a273 1
	int mpspo, mpstr;
d276 1
d278 2
a279 2
		if (line == sc->sc_int_tbl[i].line &&
		    sc->sc_hpa == sc->sc_int_tbl[i].addr)
a318 2
	struct pdc_pat_io_num int_tbl_sz PDC_ALIGNMENT;
	struct pdc_pat_pci_rt int_tbl[MAX_INT_TBL_SZ] PDC_ALIGNMENT;
d325 9
a333 16
	if (pdc_call((iodcio_t)pdc, 0, PDC_PCI_INDEX, PDC_PCI_GET_INT_TBL_SZ,
	    &int_tbl_sz, 0, 0, 0, 0, 0))
		printf("pdc_call failed\n");
	printf("int_tbl_sz=%d\n", int_tbl_sz.num);

	if (int_tbl_sz.num > MAX_INT_TBL_SZ)
		int_tbl_sz.num = MAX_INT_TBL_SZ;

	if (pdc_call((iodcio_t)pdc, 0, PDC_PCI_INDEX, PDC_PCI_GET_INT_TBL,
	    &int_tbl_sz, 0, &int_tbl, 0, 0, 0))
		printf("pdc_call failed\n");
	for (i = 0; i < int_tbl_sz.num; i++) {
		printf("type=%x, len=%d ", int_tbl[i].type, int_tbl[i].len);
		printf("itype=%d, trigger=%x ", int_tbl[i].itype, int_tbl[i].trigger);			
		printf("pin=%x, bus=%d ", int_tbl[i].pin, int_tbl[i].bus);			
		printf("line=%d, addr=%x\n", int_tbl[i].line, int_tbl[i].addr);			
@


1.2
log
@Dynamically allocate irq's for pci devices on elroy(4).

ok martin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: apic.c,v 1.1 2007/05/21 22:43:38 kettenis Exp $	*/
d42 20
d72 2
d109 2
d184 1
a184 2
		ent0 |= APIC_ENT0_LOW;
		ent0 |= APIC_ENT0_LEV;
d231 82
d318 1
a318 1
	struct pdc_pat_pci_rt int_tbl[5] PDC_ALIGNMENT;
d329 4
a332 1
	
d336 1
a336 1
	for (i = 0; i < 5; i++) {
@


1.1
log
@Import code to support the Elroy chip from hppa64 and make it actually work.
Still a bit of a hack, but it makes the onboard devices work.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d35 7
d82 5
d95 1
d99 1
d106 5
a110 2
	*ihp = PCI_INTERRUPT_LINE(reg) + 1;
	return (*ihp == 0);
d118 2
a119 1
	snprintf(buf, 32, "irq %ld", (ih + 8 - 1));
a130 1
	u_int32_t ent0;
d133 3
d138 1
a138 1
	if (ih <= 0 || ih > 31)
d150 2
a151 2
	if (apic_intr_list[(ih + 8 - 1)]) {
		biv = apic_intr_list[(ih + 8 - 1)];
d158 2
a159 2
	if ((iv = cpu_intr_establish(pri, (ih + 8 - 1), apic_intr, aiv, name))) {
		ent0 = (31 - (ih + 8 - 1)) & APIC_ENT0_VEC;
d164 1
a164 1
			sc->sc_imr |= (1 << (ih + 8 - 1));
d168 2
a169 2
		apic_write(sc->sc_regs, APIC_ENT0(ih - 1), APIC_ENT0_MASK);
		apic_write(sc->sc_regs, APIC_ENT1(ih - 1),
d171 1
a171 1
		apic_write(sc->sc_regs, APIC_ENT0(ih - 1), ent0);
d173 3
a175 1
		elroy_write32(&r->apic_eoi, htole32((31 - (ih + 8 - 1)) & APIC_ENT0_VEC));
d177 1
a177 1
		apic_intr_list[(ih + 8 - 1)] = aiv;
d201 3
a203 1
	elroy_write32(&r->apic_eoi, htole32((31 - (iv->ih + 8 - 1)) & APIC_ENT0_VEC));
@

