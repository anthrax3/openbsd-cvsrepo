head	1.22;
access;
symbols
	OPENBSD_6_1:1.22.0.52
	OPENBSD_6_1_BASE:1.22
	OPENBSD_6_0:1.22.0.48
	OPENBSD_6_0_BASE:1.22
	OPENBSD_5_9:1.22.0.44
	OPENBSD_5_9_BASE:1.22
	OPENBSD_5_8:1.22.0.46
	OPENBSD_5_8_BASE:1.22
	OPENBSD_5_7:1.22.0.38
	OPENBSD_5_7_BASE:1.22
	OPENBSD_5_6:1.22.0.42
	OPENBSD_5_6_BASE:1.22
	OPENBSD_5_5:1.22.0.40
	OPENBSD_5_5_BASE:1.22
	OPENBSD_5_4:1.22.0.36
	OPENBSD_5_4_BASE:1.22
	OPENBSD_5_3:1.22.0.34
	OPENBSD_5_3_BASE:1.22
	OPENBSD_5_2:1.22.0.32
	OPENBSD_5_2_BASE:1.22
	OPENBSD_5_1_BASE:1.22
	OPENBSD_5_1:1.22.0.30
	OPENBSD_5_0:1.22.0.28
	OPENBSD_5_0_BASE:1.22
	OPENBSD_4_9:1.22.0.26
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.22.0.24
	OPENBSD_4_8_BASE:1.22
	OPENBSD_4_7:1.22.0.20
	OPENBSD_4_7_BASE:1.22
	OPENBSD_4_6:1.22.0.22
	OPENBSD_4_6_BASE:1.22
	OPENBSD_4_5:1.22.0.18
	OPENBSD_4_5_BASE:1.22
	OPENBSD_4_4:1.22.0.16
	OPENBSD_4_4_BASE:1.22
	OPENBSD_4_3:1.22.0.14
	OPENBSD_4_3_BASE:1.22
	OPENBSD_4_2:1.22.0.12
	OPENBSD_4_2_BASE:1.22
	OPENBSD_4_1:1.22.0.10
	OPENBSD_4_1_BASE:1.22
	OPENBSD_4_0:1.22.0.8
	OPENBSD_4_0_BASE:1.22
	OPENBSD_3_9:1.22.0.6
	OPENBSD_3_9_BASE:1.22
	OPENBSD_3_8:1.22.0.4
	OPENBSD_3_8_BASE:1.22
	OPENBSD_3_7:1.22.0.2
	OPENBSD_3_7_BASE:1.22
	OPENBSD_3_6:1.20.0.2
	OPENBSD_3_6_BASE:1.20
	SMP_SYNC_A:1.20
	SMP_SYNC_B:1.20
	OPENBSD_3_5:1.19.0.2
	OPENBSD_3_5_BASE:1.19
	OPENBSD_3_4:1.17.0.2
	OPENBSD_3_4_BASE:1.17
	UBC_SYNC_A:1.13
	OPENBSD_3_3:1.11.0.2
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.9.0.2
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	UBC_SYNC_B:1.9
	UBC:1.4.0.4
	UBC_BASE:1.4
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9:1.3.0.10
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.8
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.6
	OPENBSD_2_7_BASE:1.3
	SMP:1.3.0.4
	SMP_BASE:1.3
	kame_19991208:1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.22
date	2004.09.15.20.11.28;	author mickey;	state Exp;
branches;
next	1.21;

1.21
date	2004.09.15.01.10.06;	author mickey;	state Exp;
branches;
next	1.20;

1.20
date	2004.04.07.18.24.19;	author mickey;	state Exp;
branches;
next	1.19;

1.19
date	2003.12.01.21.19.56;	author mickey;	state Exp;
branches;
next	1.18;

1.18
date	2003.09.25.22.43.22;	author mickey;	state Exp;
branches;
next	1.17;

1.17
date	2003.08.28.15.24.19;	author mickey;	state Exp;
branches;
next	1.16;

1.16
date	2003.08.20.22.51.07;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	2003.08.05.21.09.10;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	2003.07.30.21.24.19;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	2003.04.08.20.48.39;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	2003.04.08.20.37.39;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2002.12.18.23.52.45;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	2002.12.17.21.54.20;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	2002.04.22.01.48.37;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.14.01.26.31;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.12.06.42.26;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	2002.02.05.06.50.23;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	2002.02.03.01.50.20;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	2001.06.09.03.57.19;	author mickey;	state Exp;
branches
	1.4.4.1;
next	1.3;

1.3
date	99.04.20.20.28.32;	author mickey;	state Exp;
branches
	1.3.4.1;
next	1.2;

1.2
date	99.02.25.23.15.31;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	98.11.23.02.55.43;	author mickey;	state Exp;
branches;
next	;

1.3.4.1
date	2001.07.04.10.15.59;	author niklas;	state Exp;
branches;
next	1.3.4.2;

1.3.4.2
date	2002.03.06.00.57.22;	author niklas;	state Exp;
branches;
next	1.3.4.3;

1.3.4.3
date	2002.03.28.10.07.19;	author niklas;	state Exp;
branches;
next	1.3.4.4;

1.3.4.4
date	2003.03.27.23.26.53;	author niklas;	state Exp;
branches;
next	1.3.4.5;

1.3.4.5
date	2003.05.13.19.41.03;	author ho;	state Exp;
branches;
next	1.3.4.6;

1.3.4.6
date	2004.02.19.10.48.39;	author niklas;	state Exp;
branches;
next	1.3.4.7;

1.3.4.7
date	2004.06.05.23.10.47;	author niklas;	state Exp;
branches;
next	;

1.4.4.1
date	2002.06.11.03.35.36;	author art;	state Exp;
branches;
next	1.4.4.2;

1.4.4.2
date	2003.05.19.21.49.41;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.22
log
@scan cpu bus manually for some machines do not support that in prom
@
text
@/*	$OpenBSD: lasi.c,v 1.21 2004/09/15 01:10:06 mickey Exp $	*/

/*
 * Copyright (c) 1998-2003 Michael Shalayeff
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR OR HIS RELATIVES BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

#undef LASIDEBUG

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/reboot.h>

#include <machine/bus.h>
#include <machine/iomod.h>
#include <machine/reg.h>
#include <machine/autoconf.h>

#include <hppa/dev/cpudevs.h>

#include <hppa/gsc/gscbusvar.h>

#define	LASI_IOMASK	0xfff00000

struct lasi_hwr {
	u_int32_t lasi_power;
#define	LASI_BLINK	0x01
#define	LASI_OFF	0x02
	u_int32_t lasi_error;
	u_int32_t lasi_version;
	u_int32_t lasi_reset;
	u_int32_t lasi_arbmask;
};

struct lasi_trs {
	u_int32_t lasi_irr;	/* int requset register */
	u_int32_t lasi_imr;	/* int mask register */
	u_int32_t lasi_ipr;	/* int pending register */
	u_int32_t lasi_icr;	/* int command? register */
	u_int32_t lasi_iar;	/* int acquire? register */
};

struct lasi_softc {
	struct device sc_dev;
	struct gscbus_ic sc_ic;

	struct lasi_hwr volatile *sc_hw;
	struct lasi_trs volatile *sc_trs;
	struct gsc_attach_args ga;	/* for deferred attach */
};

int	lasimatch(struct device *, void *, void *);
void	lasiattach(struct device *, struct device *, void *);

struct cfattach lasi_ca = {
	sizeof(struct lasi_softc), lasimatch, lasiattach
};

struct cfdriver lasi_cd = {
	NULL, "lasi", DV_DULL
};

void lasi_cold_hook(int on);
void lasi_gsc_attach(struct device *self);

int
lasimatch(parent, cfdata, aux)   
	struct device *parent;
	void *cfdata;
	void *aux;
{
	register struct confargs *ca = aux;
	/* register struct cfdata *cf = cfdata; */

	if (ca->ca_type.iodc_type != HPPA_TYPE_BHA ||
	    ca->ca_type.iodc_sv_model != HPPA_BHA_LASI)
		return 0;

	return 1;
}

void
lasiattach(parent, self, aux)
	struct device *parent;
	struct device *self;
	void *aux;
{
	struct lasi_softc *sc = (struct lasi_softc *)self;
	struct confargs *ca = aux;
	bus_space_handle_t ioh, ioh2;
	int s, in;

	if (bus_space_map(ca->ca_iot, ca->ca_hpa,
	    IOMOD_HPASIZE, 0, &ioh)) {
		printf(": can't map TRS space\n");
		return;
	}

	if (bus_space_map(ca->ca_iot, ca->ca_hpa + 0xc000,
	    IOMOD_HPASIZE, 0, &ioh2)) {
		bus_space_unmap(ca->ca_iot, ioh, IOMOD_HPASIZE);
		printf(": can't map IO space\n");
		return;
	}

	sc->sc_trs = (struct lasi_trs *)ca->ca_hpa;
	sc->sc_hw = (struct lasi_hwr *)(ca->ca_hpa + 0xc000);

	/* XXX should we reset the chip here? */

	printf(": rev %d.%d\n", (sc->sc_hw->lasi_version & 0xf0) >> 4,
	    sc->sc_hw->lasi_version & 0xf);

	/* interrupts guts */
	s = splhigh();
	sc->sc_trs->lasi_iar = cpu_gethpa(0) | (31 - ca->ca_irq);
	sc->sc_trs->lasi_icr = 0;
	sc->sc_trs->lasi_imr = ~0U;
	in = sc->sc_trs->lasi_irr;
	sc->sc_trs->lasi_imr = 0;
	splx(s);

	sc->sc_ic.gsc_type = gsc_lasi;
	sc->sc_ic.gsc_dv = sc;
	sc->sc_ic.gsc_base = sc->sc_trs;

#ifdef USELEDS
	/* figure out the leds address */
	switch (cpu_hvers) {
	case HPPA_BOARD_HP712_60:
	case HPPA_BOARD_HP712_80:
	case HPPA_BOARD_HP712_100:
	case HPPA_BOARD_HP743I_64:
	case HPPA_BOARD_HP743I_100:
	case HPPA_BOARD_HP712_120:
		break;	/* only has one led. works different */

	case HPPA_BOARD_HP715_64:
	case HPPA_BOARD_HP715_80:
	case HPPA_BOARD_HP715_100:
	case HPPA_BOARD_HP715_100XC:
	case HPPA_BOARD_HP725_100:
	case HPPA_BOARD_HP725_120:
		if (bus_space_map(ca->ca_iot, ca->ca_hpa - 0x20000,
		    4, 0, (bus_space_handle_t *)&machine_ledaddr))
			machine_ledaddr = NULL;
		machine_ledword = 1;
		break;

	case HPPA_BOARD_HP800_A180C:
	case HPPA_BOARD_HP778_B132L:
	case HPPA_BOARD_HP778_B132LP:
	case HPPA_BOARD_HP778_B160L:
	case HPPA_BOARD_HP778_B180L:
	case HPPA_BOARD_HP780_C100:
	case HPPA_BOARD_HP780_C110:
	case HPPA_BOARD_HP779_C132L:
	case HPPA_BOARD_HP779_C160L:
	case HPPA_BOARD_HP779_C180L:
	case HPPA_BOARD_HP779_C160L1:
		if (bus_space_map(ca->ca_iot, 0xf0190000,
		    4, 0, (bus_space_handle_t *)&machine_ledaddr))
			machine_ledaddr = NULL;
		machine_ledword = 1;
		break;

	default:
		machine_ledaddr = (u_int8_t *)sc->sc_hw;
		machine_ledword = 1;
		break;
	}
#endif

	sc->ga.ga_ca = *ca;	/* clone from us */
	if (!strcmp(parent->dv_xname, "mainbus0")) {
		sc->ga.ga_dp.dp_bc[0] = sc->ga.ga_dp.dp_bc[1];
		sc->ga.ga_dp.dp_bc[1] = sc->ga.ga_dp.dp_bc[2];
		sc->ga.ga_dp.dp_bc[2] = sc->ga.ga_dp.dp_bc[3];
		sc->ga.ga_dp.dp_bc[3] = sc->ga.ga_dp.dp_bc[4];
		sc->ga.ga_dp.dp_bc[4] = sc->ga.ga_dp.dp_bc[5];
		sc->ga.ga_dp.dp_bc[5] = sc->ga.ga_dp.dp_mod;
		sc->ga.ga_dp.dp_mod = 0;
	}
	if (sc->sc_dev.dv_unit)
		config_defer(self, lasi_gsc_attach);
	else {
		extern void (*cold_hook)(int);

		lasi_gsc_attach(self);
		/* could be already set by power(4) */
		if (!cold_hook)
			cold_hook = lasi_cold_hook;
	}
}

void
lasi_gsc_attach(self)
	struct device *self;
{
	struct lasi_softc *sc = (struct lasi_softc *)self;

	sc->ga.ga_name = "gsc";
	sc->ga.ga_hpamask = LASI_IOMASK;
	sc->ga.ga_ic = &sc->sc_ic;
	config_found(self, &sc->ga, gscprint);
}

void
lasi_cold_hook(on)
	int on;
{
	register struct lasi_softc *sc = lasi_cd.cd_devs[0];

	if (!sc)
		return;

	switch (on) {
	case HPPA_COLD_COLD:
		sc->sc_hw->lasi_power = LASI_BLINK;
		break;
	case HPPA_COLD_HOT:
		sc->sc_hw->lasi_power = 0;
		break;
	case HPPA_COLD_OFF:
		sc->sc_hw->lasi_power = LASI_OFF;
		break;
	}
}
@


1.21
log
@map both register spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: lasi.c,v 1.20 2004/04/07 18:24:19 mickey Exp $	*/
a67 1
	int sc_phantomassed;
a75 3
void	lasi_mainbus_attach(struct device *, struct device *, void *);
void	lasi_phantomas_attach(struct device *, struct device *, void *);
void	lasi_gsc_attach(struct device *);
d77 2
a78 6
struct cfattach lasi_mainbus_ca = {
	sizeof(struct lasi_softc), lasimatch, lasi_mainbus_attach
};

struct cfattach lasi_phantomas_ca = {
	sizeof(struct lasi_softc), lasimatch, lasi_phantomas_attach
d86 1
a104 21
lasi_mainbus_attach(parent, self, aux)
	struct device *parent;
	struct device *self;
	void *aux;
{
	lasiattach(parent, self, aux);
}

void
lasi_phantomas_attach(parent, self, aux)
	struct device *parent;
	struct device *self;
	void *aux;
{
	struct lasi_softc *sc = (struct lasi_softc *)self;

	sc->sc_phantomassed = 1;
	lasiattach(parent, self, aux);
}

void
d197 1
a197 1
	if (!sc->sc_phantomassed) {
@


1.20
log
@update copyright; miod@@ is fine w/ files where he holds it too
@
text
@d1 1
a1 1
/*	$OpenBSD: lasi.c,v 1.19 2003/12/01 21:19:56 mickey Exp $	*/
d140 1
a140 1
	bus_space_handle_t ioh;
d143 6
d150 2
a151 1
	    IOMOD_HPASIZE, 0, &ioh)) {
@


1.19
log
@same leds on b132 and b160; from Hans-Joerg.Hoexer@@yerbouti.franken.de
@
text
@d1 1
a1 1
/*	$OpenBSD: lasi.c,v 1.18 2003/09/25 22:43:22 mickey Exp $	*/
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Michael Shalayeff.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d19 8
a26 7
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF MIND,
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@


1.18
log
@j2x0 do not like our fiddling over th led port; testing by pb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lasi.c,v 1.17 2003/08/28 15:24:19 mickey Exp $	*/
d198 3
@


1.17
log
@b180 wink-wink
@
text
@d1 1
a1 1
/*	$OpenBSD: lasi.c,v 1.16 2003/08/20 22:51:07 mickey Exp $	*/
a204 2
	case HPPA_BOARD_HP770_J200:
	case HPPA_BOARD_HP770_J210:
@


1.16
log
@support systems where power service is available from pdc and implement a cold hook as well thus do not powerleash lasi should we have cold_hook already set
@
text
@d1 1
a1 1
/*	$OpenBSD: lasi.c,v 1.15 2003/08/05 21:09:10 mickey Exp $	*/
d198 1
@


1.15
log
@a180c blinks too, 715/80 supposedly too
@
text
@d1 1
a1 1
/*	$OpenBSD: lasi.c,v 1.14 2003/07/30 21:24:19 mickey Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998-2002 Michael Shalayeff
d235 3
a237 1
		cold_hook = lasi_cold_hook;
@


1.14
log
@deduce the leds address from the model number and thus make some more use of that lichtenblinkenschmutz on some more machinens
@
text
@d1 1
a1 1
/*	$OpenBSD: lasi.c,v 1.13 2003/04/08 20:48:39 mickey Exp $	*/
d186 1
d197 1
a199 2
	case HPPA_BOARD_HP770_J200:
	case HPPA_BOARD_HP770_J210:
d204 2
@


1.13
log
@just wate that debug altogether
@
text
@d1 1
a1 1
/*	$OpenBSD: lasi.c,v 1.12 2003/04/08 20:37:39 miod Exp $	*/
d173 43
@


1.12
log
@Make dmesg prettier if attachment fails and no option DEBUG
@
text
@d1 1
a1 1
/*	$OpenBSD: lasi.c,v 1.11 2002/12/18 23:52:45 mickey Exp $	*/
d148 2
a149 6
			  IOMOD_HPASIZE, 0, &ioh)) {
#ifdef DEBUG
		printf("lasiattach: can't map IO space\n");
#else
		printf("\n");
#endif
@


1.11
log
@newer machines use phantom bus to attach lasi and other bus adapters.
oledr machines did not have a real device for the phantom bus port.
change the device scanning technique to both include a full device path
in the attach_args and do proper shifting in the pdc_scanbus() and
add a device for the newer machines as well as use a newer device
mapping (path to hpa) available on newer firmware versions, where
old (hversion-dependant) is not available.
tested on 712,715/33,c110, miod@@ ok, weissmandude -- testing
@
text
@d1 1
a1 1
/*	$OpenBSD: lasi.c,v 1.10 2002/12/17 21:54:20 mickey Exp $	*/
d151 2
@


1.10
log
@real interrupts/spl framework.
tested on 712/* 715/100, 715/33 which main cpu/bus types.
miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: lasi.c,v 1.9 2002/04/22 01:48:37 mickey Exp $	*/
d72 1
d81 2
d85 6
a90 2
struct cfattach lasi_ca = {
	sizeof(struct lasi_softc), lasimatch, lasiattach
d116 21
d142 2
a143 2
	register struct confargs *ca = aux;
	register struct lasi_softc *sc = (struct lasi_softc *)self;
d177 9
@


1.9
log
@do not forget to set the hpamask
@
text
@d1 1
a1 1
/*	$OpenBSD: lasi.c,v 1.8 2002/03/14 01:26:31 millert Exp $	*/
d42 1
d54 1
a54 1
#define	LASI_ON		0x02
a89 4
void lasi_intr_establish(void *v, u_int32_t mask);
void lasi_intr_disestablish(void *v, u_int32_t mask);
u_int32_t lasi_intr_check(void *v);
void lasi_intr_ack(void *v, u_int32_t mask);
a91 1

d132 2
a133 2
	printf (": rev %d.%d\n", (sc->sc_hw->lasi_version & 0xf0) >> 4,
		sc->sc_hw->lasi_version & 0xf);
d146 1
a146 4
	sc->sc_ic.gsc_intr_establish = lasi_intr_establish;
	sc->sc_ic.gsc_intr_disestablish = lasi_intr_disestablish;
	sc->sc_ic.gsc_intr_check = lasi_intr_check;
	sc->sc_ic.gsc_intr_ack = lasi_intr_ack;
a148 1
	sc->ga.ga_hpamask = LASI_IOMASK;
d166 1
d188 1
a188 1
		sc->sc_hw->lasi_power = LASI_BLINK;
a190 51
}

void
lasi_intr_establish(v, mask)
	void *v;
	u_int32_t mask;
{
	register struct lasi_softc *sc = v;

	sc->sc_trs->lasi_imr |= mask;
}

void
lasi_intr_disestablish(v, mask)
	void *v;
	u_int32_t mask;
{
	register struct lasi_softc *sc = v;

	sc->sc_trs->lasi_imr &= ~mask;
}

u_int32_t
lasi_intr_check(v)
	void *v;
{
	register struct lasi_softc *sc = v;
	register u_int32_t irr, imr, ipr;

	imr = sc->sc_trs->lasi_imr;
	ipr = sc->sc_trs->lasi_ipr;
	irr = sc->sc_trs->lasi_irr;
	sc->sc_trs->lasi_irr = irr;

#ifdef LASIDEBUG
	printf ("%s: imr=0x%x, irr=0x%x, ipr=0x%x, iar=0x%x, icr=0x%x\n",
		sc->sc_dev.dv_xname, imr, irr, ipr,
		sc->sc_trs->lasi_iar, sc->sc_trs->lasi_icr);
#endif

	return irr;
}

void
lasi_intr_ack(v, mask)
	void *v;
	u_int32_t mask;
{
	register struct lasi_softc *sc = v;

	sc->sc_trs->lasi_imr |= mask;
@


1.8
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: lasi.c,v 1.7 2002/02/12 06:42:26 mickey Exp $	*/
d48 2
d156 1
@


1.7
log
@support 712's programmable power switch, no interrupt yet
@
text
@d1 1
a1 1
/*	$OpenBSD: lasi.c,v 1.6 2002/02/05 06:50:23 mickey Exp $	*/
d75 3
a77 3
int	lasimatch __P((struct device *, void *, void *));
void	lasiattach __P((struct device *, struct device *, void *));
void	lasi_gsc_attach __P((struct device *));
d87 5
a91 5
void lasi_intr_establish __P((void *v, u_int32_t mask));
void lasi_intr_disestablish __P((void *v, u_int32_t mask));
u_int32_t lasi_intr_check __P((void *v));
void lasi_intr_ack __P((void *v, u_int32_t mask));
void lasi_cold_hook __P((int on));
d157 1
a157 1
		extern void (*cold_hook) __P((int));
@


1.6
log
@get rid of the borrowed habits in intr handling
@
text
@d1 1
a1 1
/*	$OpenBSD: lasi.c,v 1.5 2002/02/03 01:50:20 mickey Exp $	*/
d50 2
d91 1
d156 3
a158 1
	else
d160 2
d173 22
@


1.5
log
@defer non-0 units to keep iface order right
@
text
@d1 1
a1 1
/*	$OpenBSD: lasi.c,v 1.4 2001/06/09 03:57:19 mickey Exp $	*/
d198 1
a198 2
	sc->sc_trs->lasi_imr = 0;
	sc->sc_trs->lasi_imr = imr &= ~irr;
@


1.4
log
@disable debugging by default
@
text
@d1 1
a1 1
/*	$OpenBSD: lasi.c,v 1.3 1999/04/20 20:28:32 mickey Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998,1999 Michael Shalayeff
d26 2
a27 2
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
d70 1
d75 1
a114 1
	struct gsc_attach_args ga;
d150 16
a165 4
	ga.ga_ca = *ca;	/* clone from us */
	ga.ga_name = "gsc";
	ga.ga_ic = &sc->sc_ic;
	config_found(self, &ga, gscprint);
@


1.4.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: lasi.c,v 1.4 2001/06/09 03:57:19 mickey Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998-2002 Michael Shalayeff
d26 2
a27 2
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF MIND,
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
a47 2
#define	LASI_IOMASK	0xfff00000

a49 2
#define	LASI_BLINK	0x01
#define	LASI_ON		0x02
a69 1
	struct gsc_attach_args ga;	/* for deferred attach */
d72 2
a73 3
int	lasimatch(struct device *, void *, void *);
void	lasiattach(struct device *, struct device *, void *);
void	lasi_gsc_attach(struct device *);
d83 4
a86 5
void lasi_intr_establish(void *v, u_int32_t mask);
void lasi_intr_disestablish(void *v, u_int32_t mask);
u_int32_t lasi_intr_check(void *v);
void lasi_intr_ack(void *v, u_int32_t mask);
void lasi_cold_hook(int on);
d113 1
d149 4
a152 43
	sc->ga.ga_ca = *ca;	/* clone from us */
	sc->ga.ga_hpamask = LASI_IOMASK;
	if (sc->sc_dev.dv_unit)
		config_defer(self, lasi_gsc_attach);
	else {
		extern void (*cold_hook)(int);

		lasi_gsc_attach(self);
		cold_hook = lasi_cold_hook;
	}
}

void
lasi_gsc_attach(self)
	struct device *self;
{
	struct lasi_softc *sc = (struct lasi_softc *)self;

	sc->ga.ga_name = "gsc";
	sc->ga.ga_ic = &sc->sc_ic;
	config_found(self, &sc->ga, gscprint);
}

void
lasi_cold_hook(on)
	int on;
{
	register struct lasi_softc *sc = lasi_cd.cd_devs[0];

	if (!sc)
		return;

	switch (on) {
	case HPPA_COLD_COLD:
		sc->sc_hw->lasi_power = LASI_BLINK;
		break;
	case HPPA_COLD_HOT:
		sc->sc_hw->lasi_power = 0;
		break;
	case HPPA_COLD_OFF:
		sc->sc_hw->lasi_power = LASI_BLINK;
		break;
	}
d185 2
a186 1
	sc->sc_trs->lasi_irr = irr;
@


1.4.4.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a41 1
#include <machine/reg.h>
d53 1
a53 1
#define	LASI_OFF	0x02
a70 1
	int sc_phantomassed;
a78 2
void	lasi_mainbus_attach(struct device *, struct device *, void *);
void	lasi_phantomas_attach(struct device *, struct device *, void *);
d81 2
a82 6
struct cfattach lasi_mainbus_ca = {
	sizeof(struct lasi_softc), lasimatch, lasi_mainbus_attach
};

struct cfattach lasi_phantomas_ca = {
	sizeof(struct lasi_softc), lasimatch, lasi_phantomas_attach
d89 4
d95 1
a112 21
lasi_mainbus_attach(parent, self, aux)
	struct device *parent;
	struct device *self;
	void *aux;
{
	lasiattach(parent, self, aux);
}

void
lasi_phantomas_attach(parent, self, aux)
	struct device *parent;
	struct device *self;
	void *aux;
{
	struct lasi_softc *sc = (struct lasi_softc *)self;

	sc->sc_phantomassed = 1;
	lasiattach(parent, self, aux);
}

void
d118 2
a119 2
	struct lasi_softc *sc = (struct lasi_softc *)self;
	struct confargs *ca = aux;
d124 4
a127 2
	    IOMOD_HPASIZE, 0, &ioh)) {
		printf(": can't map IO space\n");
d136 2
a137 2
	printf(": rev %d.%d\n", (sc->sc_hw->lasi_version & 0xf0) >> 4,
	    sc->sc_hw->lasi_version & 0xf);
d150 4
a153 1
	sc->sc_ic.gsc_base = sc->sc_trs;
d156 1
a156 9
	if (!sc->sc_phantomassed) {
		sc->ga.ga_dp.dp_bc[0] = sc->ga.ga_dp.dp_bc[1];
		sc->ga.ga_dp.dp_bc[1] = sc->ga.ga_dp.dp_bc[2];
		sc->ga.ga_dp.dp_bc[2] = sc->ga.ga_dp.dp_bc[3];
		sc->ga.ga_dp.dp_bc[3] = sc->ga.ga_dp.dp_bc[4];
		sc->ga.ga_dp.dp_bc[4] = sc->ga.ga_dp.dp_bc[5];
		sc->ga.ga_dp.dp_bc[5] = sc->ga.ga_dp.dp_mod;
		sc->ga.ga_dp.dp_mod = 0;
	}
a173 1
	sc->ga.ga_hpamask = LASI_IOMASK;
d195 1
a195 1
		sc->sc_hw->lasi_power = LASI_OFF;
d198 51
@


1.3
log
@map the io space
@
text
@d1 1
a1 1
/*	$OpenBSD: lasi.c,v 1.2 1999/02/25 23:15:31 mickey Exp $	*/
d33 1
a33 1
#define LASIDEBUG 9
@


1.3.4.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: lasi.c,v 1.3 1999/04/20 20:28:32 mickey Exp $	*/
d33 1
a33 1
#undef LASIDEBUG
@


1.3.4.2
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d4 1
a4 1
 * Copyright (c) 1998-2002 Michael Shalayeff
d26 2
a27 2
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF MIND,
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
a49 2
#define	LASI_BLINK	0x01
#define	LASI_ON		0x02
a69 1
	struct gsc_attach_args ga;	/* for deferred attach */
a73 1
void	lasi_gsc_attach __P((struct device *));
a86 1
void lasi_cold_hook __P((int on));
d113 1
d149 4
a152 42
	sc->ga.ga_ca = *ca;	/* clone from us */
	if (sc->sc_dev.dv_unit)
		config_defer(self, lasi_gsc_attach);
	else {
		extern void (*cold_hook) __P((int));

		lasi_gsc_attach(self);
		cold_hook = lasi_cold_hook;
	}
}

void
lasi_gsc_attach(self)
	struct device *self;
{
	struct lasi_softc *sc = (struct lasi_softc *)self;

	sc->ga.ga_name = "gsc";
	sc->ga.ga_ic = &sc->sc_ic;
	config_found(self, &sc->ga, gscprint);
}

void
lasi_cold_hook(on)
	int on;
{
	register struct lasi_softc *sc = lasi_cd.cd_devs[0];

	if (!sc)
		return;

	switch (on) {
	case HPPA_COLD_COLD:
		sc->sc_hw->lasi_power = LASI_BLINK;
		break;
	case HPPA_COLD_HOT:
		sc->sc_hw->lasi_power = 0;
		break;
	case HPPA_COLD_OFF:
		sc->sc_hw->lasi_power = LASI_BLINK;
		break;
	}
d185 2
a186 1
	sc->sc_trs->lasi_irr = irr;
@


1.3.4.3
log
@Merge in -current from about a week ago
@
text
@d75 3
a77 3
int	lasimatch(struct device *, void *, void *);
void	lasiattach(struct device *, struct device *, void *);
void	lasi_gsc_attach(struct device *);
d87 5
a91 5
void lasi_intr_establish(void *v, u_int32_t mask);
void lasi_intr_disestablish(void *v, u_int32_t mask);
u_int32_t lasi_intr_check(void *v);
void lasi_intr_ack(void *v, u_int32_t mask);
void lasi_cold_hook(int on);
d157 1
a157 1
		extern void (*cold_hook)(int);
@


1.3.4.4
log
@Sync the SMP branch with 3.3
@
text
@a41 1
#include <machine/reg.h>
a47 2
#define	LASI_IOMASK	0xfff00000

d51 1
a51 1
#define	LASI_OFF	0x02
a68 1
	int sc_phantomassed;
a76 2
void	lasi_mainbus_attach(struct device *, struct device *, void *);
void	lasi_phantomas_attach(struct device *, struct device *, void *);
d79 2
a80 6
struct cfattach lasi_mainbus_ca = {
	sizeof(struct lasi_softc), lasimatch, lasi_mainbus_attach
};

struct cfattach lasi_phantomas_ca = {
	sizeof(struct lasi_softc), lasimatch, lasi_phantomas_attach
d87 4
d93 1
a110 21
lasi_mainbus_attach(parent, self, aux)
	struct device *parent;
	struct device *self;
	void *aux;
{
	lasiattach(parent, self, aux);
}

void
lasi_phantomas_attach(parent, self, aux)
	struct device *parent;
	struct device *self;
	void *aux;
{
	struct lasi_softc *sc = (struct lasi_softc *)self;

	sc->sc_phantomassed = 1;
	lasiattach(parent, self, aux);
}

void
d116 2
a117 2
	struct lasi_softc *sc = (struct lasi_softc *)self;
	struct confargs *ca = aux;
d134 2
a135 2
	printf(": rev %d.%d\n", (sc->sc_hw->lasi_version & 0xf0) >> 4,
	    sc->sc_hw->lasi_version & 0xf);
d148 4
a151 1
	sc->sc_ic.gsc_base = sc->sc_trs;
a153 9
	if (!sc->sc_phantomassed) {
		sc->ga.ga_dp.dp_bc[0] = sc->ga.ga_dp.dp_bc[1];
		sc->ga.ga_dp.dp_bc[1] = sc->ga.ga_dp.dp_bc[2];
		sc->ga.ga_dp.dp_bc[2] = sc->ga.ga_dp.dp_bc[3];
		sc->ga.ga_dp.dp_bc[3] = sc->ga.ga_dp.dp_bc[4];
		sc->ga.ga_dp.dp_bc[4] = sc->ga.ga_dp.dp_bc[5];
		sc->ga.ga_dp.dp_bc[5] = sc->ga.ga_dp.dp_mod;
		sc->ga.ga_dp.dp_mod = 0;
	}
a170 1
	sc->ga.ga_hpamask = LASI_IOMASK;
d192 1
a192 1
		sc->sc_hw->lasi_power = LASI_OFF;
d195 51
@


1.3.4.5
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: lasi.c,v 1.3.4.4 2003/03/27 23:26:53 niklas Exp $	*/
d148 4
a151 2
	    IOMOD_HPASIZE, 0, &ioh)) {
		printf(": can't map IO space\n");
@


1.3.4.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d4 1
a4 1
 * Copyright (c) 1998-2003 Michael Shalayeff
a173 47
#ifdef USELEDS
	/* figure out the leds address */
	switch (cpu_hvers) {
	case HPPA_BOARD_HP712_60:
	case HPPA_BOARD_HP712_80:
	case HPPA_BOARD_HP712_100:
	case HPPA_BOARD_HP743I_64:
	case HPPA_BOARD_HP743I_100:
	case HPPA_BOARD_HP712_120:
		break;	/* only has one led. works different */

	case HPPA_BOARD_HP715_64:
	case HPPA_BOARD_HP715_80:
	case HPPA_BOARD_HP715_100:
	case HPPA_BOARD_HP715_100XC:
	case HPPA_BOARD_HP725_100:
	case HPPA_BOARD_HP725_120:
		if (bus_space_map(ca->ca_iot, ca->ca_hpa - 0x20000,
		    4, 0, (bus_space_handle_t *)&machine_ledaddr))
			machine_ledaddr = NULL;
		machine_ledword = 1;
		break;

	case HPPA_BOARD_HP800_A180C:
	case HPPA_BOARD_HP778_B132L:
	case HPPA_BOARD_HP778_B132LP:
	case HPPA_BOARD_HP778_B160L:
	case HPPA_BOARD_HP778_B180L:
	case HPPA_BOARD_HP780_C100:
	case HPPA_BOARD_HP780_C110:
	case HPPA_BOARD_HP779_C132L:
	case HPPA_BOARD_HP779_C160L:
	case HPPA_BOARD_HP779_C180L:
	case HPPA_BOARD_HP779_C160L1:
		if (bus_space_map(ca->ca_iot, 0xf0190000,
		    4, 0, (bus_space_handle_t *)&machine_ledaddr))
			machine_ledaddr = NULL;
		machine_ledword = 1;
		break;

	default:
		machine_ledaddr = (u_int8_t *)sc->sc_hw;
		machine_ledword = 1;
		break;
	}
#endif

d190 1
a190 3
		/* could be already set by power(4) */
		if (!cold_hook)
			cold_hook = lasi_cold_hook;
@


1.3.4.7
log
@Merge with the trunk
@
text
@d15 5
d24 7
a30 8
 * IN NO EVENT SHALL THE AUTHOR OR HIS RELATIVES BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
@


1.2
log
@try to avoid using bus_* stuff for MD code, handle interrupts, gscbus changes
@
text
@d1 1
a1 1
/*	$OpenBSD: lasi.c,v 1.1 1998/11/23 02:55:43 mickey Exp $	*/
d114 1
d116 8
@


1.1
log
@some GSC bus adapters; WAX is not ready yet
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d4 1
a4 1
 * Copyright (c) 1998 Michael Shalayeff
d33 2
d48 7
a54 2
struct lasi_softc {
	struct  device sc_dv;
d56 7
a62 2
	bus_space_tag_t sc_iot;
	bus_space_handle_t sc_ioh;
d64 2
d67 3
a71 13
/* LASI registers definition */
#define	LASI_IRR	0x000
#define	LASI_IMR	0x004
#define	LASI_IPR	0x008
#define	LASI_ICR	0x00c
#define	LASI_IAR	0x010
#define	LASI_POWER	0x800
#define	LASI_ERROR	0x804
#define	LASI_VERSION	0x808
#define	LASI_RESET	0x80c
#define	LASI_ARBMASK	0x810


a82 1
void lasi_intr_attach __P((void *v, u_int in));
d95 2
a96 3
	struct confargs *ca = aux;
	/* struct cfdata *cf = cfdata; */
	bus_space_handle_t ioh;
a101 5
	if (bus_space_map(ca->ca_iot, ca->ca_hpa, IOMOD_HPASIZE, 0, &ioh))
		return 0;

	bus_space_unmap(ca->ca_iot, ioh, IOMOD_HPASIZE);

d114 1
a114 1
	u_int ver;
d116 2
a117 4
	sc->sc_iot = ca->ca_iot;
	if (bus_space_map(sc->sc_iot, ca->ca_hpa, IOMOD_HPASIZE, 0,
			  &sc->sc_ioh))
		panic("lasiattach: unable to map bus space");
d121 11
a131 2
	ver = bus_space_read_4(sc->sc_iot, sc->sc_ioh, LASI_VERSION);
	printf (": hpa 0x%x, rev %x\n", ca->ca_hpa, ver & 0xff);
a134 1
	sc->sc_ic.gsc_intr_attach = lasi_intr_attach;
a146 13
lasi_intr_attach(v, in)
	void *v;
	u_int in;
{
	register struct lasi_softc *sc = v;
	hppa_hpa_t cpu_hpa;

	cpu_hpa = cpu_gethpa(0);
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, LASI_IAR, cpu_hpa | in);
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, LASI_ICR, 0);
}

void
d153 1
a153 2
	mask |= bus_space_read_4(sc->sc_iot, sc->sc_ioh, LASI_IMR);
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, LASI_IMR, mask);
d163 1
a163 2
	mask &= ~bus_space_read_4(sc->sc_iot, sc->sc_ioh, LASI_IMR);
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, LASI_IMR, mask);
d171 1
a171 1
	register u_int32_t mask, imr;
d173 11
a183 3
	imr = bus_space_read_4(sc->sc_iot, sc->sc_ioh, LASI_IMR);
	mask = bus_space_read_4(sc->sc_iot, sc->sc_ioh, LASI_IRR);
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, LASI_IMR, imr & ~mask);
d185 1
a185 1
	return mask;
d195 1
a195 2
	mask |= bus_space_read_4(sc->sc_iot, sc->sc_ioh, LASI_IMR);
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, LASI_IMR, mask);
@

