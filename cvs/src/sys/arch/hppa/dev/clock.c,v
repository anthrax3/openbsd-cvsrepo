head	1.29;
access;
symbols
	OPENBSD_6_1:1.29.0.14
	OPENBSD_6_1_BASE:1.29
	OPENBSD_6_0:1.29.0.10
	OPENBSD_6_0_BASE:1.29
	OPENBSD_5_9:1.29.0.6
	OPENBSD_5_9_BASE:1.29
	OPENBSD_5_8:1.29.0.8
	OPENBSD_5_8_BASE:1.29
	OPENBSD_5_7:1.29.0.2
	OPENBSD_5_7_BASE:1.29
	OPENBSD_5_6:1.29.0.4
	OPENBSD_5_6_BASE:1.29
	OPENBSD_5_5:1.28.0.16
	OPENBSD_5_5_BASE:1.28
	OPENBSD_5_4:1.28.0.12
	OPENBSD_5_4_BASE:1.28
	OPENBSD_5_3:1.28.0.10
	OPENBSD_5_3_BASE:1.28
	OPENBSD_5_2:1.28.0.8
	OPENBSD_5_2_BASE:1.28
	OPENBSD_5_1_BASE:1.28
	OPENBSD_5_1:1.28.0.6
	OPENBSD_5_0:1.28.0.4
	OPENBSD_5_0_BASE:1.28
	OPENBSD_4_9:1.28.0.2
	OPENBSD_4_9_BASE:1.28
	OPENBSD_4_8:1.25.0.2
	OPENBSD_4_8_BASE:1.25
	OPENBSD_4_7:1.23.0.4
	OPENBSD_4_7_BASE:1.23
	OPENBSD_4_6:1.23.0.6
	OPENBSD_4_6_BASE:1.23
	OPENBSD_4_5:1.23.0.2
	OPENBSD_4_5_BASE:1.23
	OPENBSD_4_4:1.22.0.6
	OPENBSD_4_4_BASE:1.22
	OPENBSD_4_3:1.22.0.4
	OPENBSD_4_3_BASE:1.22
	OPENBSD_4_2:1.22.0.2
	OPENBSD_4_2_BASE:1.22
	OPENBSD_4_1:1.21.0.12
	OPENBSD_4_1_BASE:1.21
	OPENBSD_4_0:1.21.0.10
	OPENBSD_4_0_BASE:1.21
	OPENBSD_3_9:1.21.0.8
	OPENBSD_3_9_BASE:1.21
	OPENBSD_3_8:1.21.0.6
	OPENBSD_3_8_BASE:1.21
	OPENBSD_3_7:1.21.0.4
	OPENBSD_3_7_BASE:1.21
	OPENBSD_3_6:1.21.0.2
	OPENBSD_3_6_BASE:1.21
	SMP_SYNC_A:1.21
	SMP_SYNC_B:1.21
	OPENBSD_3_5:1.20.0.2
	OPENBSD_3_5_BASE:1.20
	OPENBSD_3_4:1.17.0.4
	OPENBSD_3_4_BASE:1.17
	UBC_SYNC_A:1.17
	OPENBSD_3_3:1.17.0.2
	OPENBSD_3_3_BASE:1.17
	OPENBSD_3_2:1.16.0.2
	OPENBSD_3_2_BASE:1.16
	OPENBSD_3_1:1.13.0.2
	OPENBSD_3_1_BASE:1.13
	UBC_SYNC_B:1.16
	UBC:1.11.0.2
	UBC_BASE:1.11
	OPENBSD_3_0:1.10.0.2
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9:1.9.0.6
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_8:1.9.0.4
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.9.0.2
	OPENBSD_2_7_BASE:1.9
	SMP:1.8.0.2
	SMP_BASE:1.8
	kame_19991208:1.6
	OPENBSD_2_6:1.6.0.2
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.29
date	2014.03.29.18.09.29;	author guenther;	state Exp;
branches;
next	1.28;

1.28
date	2011.01.09.19.37.51;	author jasper;	state Exp;
branches;
next	1.27;

1.27
date	2011.01.05.16.30.50;	author jasper;	state Exp;
branches;
next	1.26;

1.26
date	2011.01.01.19.00.56;	author jasper;	state Exp;
branches;
next	1.25;

1.25
date	2010.08.01.09.01.45;	author kettenis;	state Exp;
branches;
next	1.24;

1.24
date	2010.04.29.12.35.14;	author jsing;	state Exp;
branches;
next	1.23;

1.23
date	2009.02.08.18.33.28;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2007.07.22.19.24.45;	author kettenis;	state Exp;
branches;
next	1.21;

1.21
date	2004.04.07.18.24.19;	author mickey;	state Exp;
branches;
next	1.20;

1.20
date	2003.12.12.19.42.47;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2003.10.15.18.54.55;	author mickey;	state Exp;
branches;
next	1.18;

1.18
date	2003.10.05.14.13.28;	author mickey;	state Exp;
branches;
next	1.17;

1.17
date	2002.11.27.21.47.14;	author mickey;	state Exp;
branches;
next	1.16;

1.16
date	2002.09.15.09.45.15;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	2002.05.20.00.16.44;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	2002.05.14.20.41.33;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	2002.03.14.01.26.31;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2002.02.01.19.03.18;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	2001.11.06.19.53.14;	author miod;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	2001.08.31.03.13.42;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	2000.03.29.23.11.06;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	2000.02.09.05.51.21;	author mickey;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2000.02.09.05.04.22;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	99.09.07.20.50.24;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	99.08.14.03.56.12;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	99.06.24.00.10.56;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	99.06.12.17.47.08;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	99.02.07.20.24.51;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	98.12.29.21.35.42;	author mickey;	state Exp;
branches;
next	;

1.8.2.1
date	2001.04.18.16.05.54;	author niklas;	state Exp;
branches;
next	1.8.2.2;

1.8.2.2
date	2001.10.31.02.52.46;	author nate;	state Exp;
branches;
next	1.8.2.3;

1.8.2.3
date	2001.11.13.21.00.51;	author niklas;	state Exp;
branches;
next	1.8.2.4;

1.8.2.4
date	2002.03.06.00.57.22;	author niklas;	state Exp;
branches;
next	1.8.2.5;

1.8.2.5
date	2002.03.28.10.07.19;	author niklas;	state Exp;
branches;
next	1.8.2.6;

1.8.2.6
date	2003.03.27.23.26.53;	author niklas;	state Exp;
branches;
next	1.8.2.7;

1.8.2.7
date	2004.02.19.10.48.39;	author niklas;	state Exp;
branches;
next	1.8.2.8;

1.8.2.8
date	2004.06.05.23.10.47;	author niklas;	state Exp;
branches;
next	;

1.11.2.1
date	2002.06.11.03.35.36;	author art;	state Exp;
branches;
next	1.11.2.2;

1.11.2.2
date	2002.10.29.00.28.02;	author art;	state Exp;
branches;
next	1.11.2.3;

1.11.2.3
date	2003.05.19.21.49.41;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.29
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@/*	$OpenBSD: clock.c,v 1.28 2011/01/09 19:37:51 jasper Exp $	*/

/*
 * Copyright (c) 1998-2003 Michael Shalayeff
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR OR HIS RELATIVES BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/timetc.h>

#include <dev/clock_subr.h>

#include <machine/pdc.h>
#include <machine/iomod.h>
#include <machine/psl.h>
#include <machine/intr.h>
#include <machine/reg.h>
#include <machine/cpufunc.h>
#include <machine/autoconf.h>

u_long	cpu_hzticks;
int	timeset;

int	cpu_hardclock(void *);
u_int	itmr_get_timecount(struct timecounter *);

struct timecounter itmr_timecounter = {
	itmr_get_timecount, NULL, 0xffffffff, 0, "itmr", 0, NULL
};

void
cpu_initclocks(void)
{
	struct cpu_info *ci = curcpu();
	u_long __itmr;

	cpu_hzticks = (PAGE0->mem_10msec * 100) / hz;

	itmr_timecounter.tc_frequency = PAGE0->mem_10msec * 100;
	tc_init(&itmr_timecounter);

	mfctl(CR_ITMR, __itmr);
	ci->ci_itmr = __itmr;
	__itmr += cpu_hzticks;
	mtctl(__itmr, CR_ITMR);
}

int
cpu_hardclock(void *v)
{
	struct cpu_info *ci = curcpu();
	u_long __itmr, delta, eta;
	int wrap;
	register_t eiem;

	/*
	 * Invoke hardclock as many times as there has been cpu_hzticks
	 * ticks since the last interrupt.
	 */
	for (;;) {
		mfctl(CR_ITMR, __itmr);
		delta = __itmr - ci->ci_itmr;
		if (delta >= cpu_hzticks) {
			hardclock(v);
			ci->ci_itmr += cpu_hzticks;
		} else
			break;
	}

	/*
	 * Program the next clock interrupt, making sure it will
	 * indeed happen in the future. This is done with interrupts
	 * disabled to avoid a possible race.
	 */
	eta = ci->ci_itmr + cpu_hzticks;
	wrap = eta < ci->ci_itmr;	/* watch out for a wraparound */
	__asm volatile("mfctl	%%cr15, %0": "=r" (eiem));
	__asm volatile("mtctl	%r0, %cr15");
	mtctl(eta, CR_ITMR);
	mfctl(CR_ITMR, __itmr);
	/*
	 * If we were close enough to the next tick interrupt
	 * value, by the time we have programmed itmr, it might
	 * have passed the value, which would cause a complete
	 * cycle until the next interrupt occurs. On slow
	 * models, this would be a disaster (a complete cycle
	 * taking over two minutes on a 715/33).
	 *
	 * We expect that it will only be necessary to postpone
	 * the interrupt once. Thus, there are two cases:
	 * - We are expecting a wraparound: eta < cpu_itmr.
	 *   itmr is in tracks if either >= cpu_itmr or < eta.
	 * - We are not wrapping: eta > cpu_itmr.
	 *   itmr is in tracks if >= cpu_itmr and < eta (we need
	 *   to keep the >= cpu_itmr test because itmr might wrap
	 *   before eta does).
	 */
	if ((wrap && !(eta > __itmr || __itmr >= ci->ci_itmr)) ||
	    (!wrap && !(eta > __itmr && __itmr >= ci->ci_itmr))) {
		eta += cpu_hzticks;
		mtctl(eta, CR_ITMR);
	}
	__asm volatile("mtctl	%0, %%cr15":: "r" (eiem));

	return (1);
}

/*
 * initialize the system time from the time of day clock
 */
void
inittodr(time_t t)
{
	struct pdc_tod tod PDC_ALIGNMENT;
	int 	error, tbad = 0;
	struct timespec ts;

	if (t < 12*SECYR) {
		printf ("WARNING: preposterous time in file system");
		t = 6*SECYR + 186*SECDAY + SECDAY/2;
		tbad = 1;
	}

	if ((error = pdc_call((iodcio_t)pdc,
	    1, PDC_TOD, PDC_TOD_READ, &tod, 0, 0, 0, 0, 0)))
		printf("clock: failed to fetch (%d)\n", error);

	ts.tv_sec = tod.sec;
	ts.tv_nsec = tod.usec * 1000;
	tc_setclock(&ts);
	timeset = 1;

	if (!tbad) {
		u_long	dt;

		dt = (tod.sec < t)?  t - tod.sec : tod.sec - t;

		if (dt < 2 * SECDAY)
			return;
		printf("WARNING: clock %s %ld days",
		    tod.sec < t? "lost" : "gained", dt / SECDAY);
	}

	printf (" -- CHECK AND RESET THE DATE!\n");
}

/*
 * reset the time of day clock to the value in time
 */
void
resettodr()
{
	struct timeval tv;
	int error;

	/*
	 * We might have been called by boot() due to a crash early
	 * on.  Don't reset the clock chip in this case.
	 */
	if (!timeset)
		return;

	microtime(&tv);

	if ((error = pdc_call((iodcio_t)pdc, 1, PDC_TOD, PDC_TOD_WRITE,
	    tv.tv_sec, tv.tv_usec)))
		printf("clock: failed to save (%d)\n", error);
}

void
setstatclockrate(int newhz)
{
	/* nothing we can do */
}

u_int
itmr_get_timecount(struct timecounter *tc)
{
	u_long __itmr;

	mfctl(CR_ITMR, __itmr);
	return (__itmr);
}
@


1.28
log
@Check in resettodr() if inittodr() has been called, otherwise we end up
resetting the clock when we don't need to. Found out with booting hppa64
kernels, and the problem also exists on hppa when booting with '-a' and hitting
'exit' when asked for the root filesystem.

help & ok jsing@@
also ok kettenis@@ (who suggested naming the variable like amd64/i386 to
prevent creating yet another variant of this code)
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.27 2011/01/05 16:30:50 jasper Exp $	*/
d100 2
a101 2
	__asm __volatile("mfctl	%%cr15, %0": "=r" (eiem));
	__asm __volatile("mtctl	%r0, %cr15");
d126 1
a126 1
	__asm __volatile("mtctl	%0, %%cr15":: "r" (eiem));
@


1.27
log
@- remove unused headers wrapped in #if defined(DDB)

ok jsing@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.26 2011/01/01 19:00:56 jasper Exp $	*/
d45 1
d154 1
d178 7
@


1.26
log
@Move setting cpu_hzticks to the clock initialization function, like
other ports (e.g. hppa64) do.

ok jsing@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.25 2010/08/01 09:01:45 kettenis Exp $	*/
a42 7

#if defined(DDB)
#include <uvm/uvm_extern.h>
#include <machine/db_machdep.h>
#include <ddb/db_sym.h>
#include <ddb/db_extern.h>
#endif
@


1.25
log
@ANSIfy
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.24 2010/04/29 12:35:14 jsing Exp $	*/
d65 2
@


1.24
log
@Store hardware timer information per CPU.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.22 2007/07/22 19:24:45 kettenis Exp $	*/
d61 1
a61 1
cpu_initclocks()
d139 1
a139 2
inittodr(t)
	time_t t;
d190 1
a190 2
setstatclockrate(newhz)
	int newhz;
@


1.23
log
@Make sure than cpu_hardclock() never sets a ``next interrupt value'' which has
already been hit by the running timer; this happens very often on oosiop-based
machines, due to these machines being among the slowest hppa, and oosiop
being interrupt greedy. Unfortunately, when this happened, one had to wait
for the timer to wrap, which would take up to 128 seconds on the 33MHz
machines.

Also, invoke hardclock() as many times as necessary if it turns out that
we had to delay the interrupt 1/hz seconds to avoid the aforementioned
wrap problem.

With help from kettenis@@; ok kettenis@@
@
text
@d51 1
a51 1
u_long	cpu_itmr, cpu_hzticks;
d63 1
d70 1
a70 1
	cpu_itmr = __itmr;
d78 1
d89 1
a89 1
		delta = __itmr - cpu_itmr;
d92 1
a92 1
			cpu_itmr += cpu_hzticks;
d102 2
a103 2
	eta = cpu_itmr + cpu_hzticks;
	wrap = eta < cpu_itmr;	/* watch out for a wraparound */
d125 2
a126 2
	if ((wrap && !(eta > __itmr || __itmr >= cpu_itmr)) ||
	    (!wrap && !(eta > __itmr && __itmr >= cpu_itmr))) {
@


1.22
log
@Move hppa to __HAVE_TIMECOUNTERS.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.21 2004/04/07 18:24:19 mickey Exp $	*/
d51 4
a54 1
u_int itmr_get_timecount(struct timecounter *);
a62 2
	extern volatile u_long cpu_itmr;
	extern u_long cpu_hzticks;
d72 59
@


1.21
log
@update copyright; miod@@ is fine w/ files where he holds it too
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.20 2003/12/12 19:42:47 deraadt Exp $	*/
d32 1
a32 1
#include <sys/time.h>
d51 6
d64 3
d82 1
d94 3
a96 2
	time.tv_sec = tod.sec;
	time.tv_usec = tod.usec;
d101 1
a101 1
		dt = (time.tv_sec < t)?  t - time.tv_sec : time.tv_sec - t;
d106 1
a106 1
		    time.tv_sec < t? "lost" : "gained", dt / SECDAY);
d118 1
d121 2
d124 1
a124 1
	    time.tv_sec, time.tv_usec)))
d133 9
@


1.20
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.19 2003/10/15 18:54:55 mickey Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998,1999 Michael Shalayeff
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Michael Shalayeff.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d19 8
a26 7
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF MIND,
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@


1.19
log
@less global name space pollution
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.18 2003/10/05 14:13:28 mickey Exp $	*/
d115 1
a115 1
		printf("clock: failed to save (%d)\n");
@


1.18
log
@reload the itmr as soon as we get the intr to avoid lagging on slower machines
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.17 2002/11/27 21:47:14 mickey Exp $	*/
d58 5
a62 2
	register_t __itmr;
	__asm __volatile("mfctl %%cr16, %0" : "=r" (__itmr));
d65 1
a65 1
	__asm __volatile("mtctl %0, %%cr16" :: "r" (__itmr));
@


1.17
log
@no wrapper arounf hardclock(), use CPU_CLOCKUPDATE, real microtime; miod ok
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.16 2002/09/15 09:45:15 mickey Exp $	*/
d58 5
a62 1
	CPU_CLOCKUPDATE();
@


1.16
log
@check for errors on tod pdc ops. say that bad time is before 82
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.15 2002/05/20 00:16:44 mickey Exp $	*/
a54 5
struct timeval time;
int cpu_clockok;

void startrtclock(void);

d58 1
a58 33
	extern u_int cpu_hzticks;
	u_int time_inval;

	/* Start the interval timer. */
	mfctl(CR_ITMR, time_inval);
	mtctl(time_inval + cpu_hzticks, CR_ITMR);

	cpu_clockok = 1;
}

int
clock_intr (v)
	void *v;
{
	struct trapframe *frame = v;

	/* printf ("clock int 0x%x @@ 0x%x for %p\n", t,
	   frame->tf_iioq_head, curproc); */

	if (!cpu_clockok)
		return (1);

	cpu_initclocks();
	hardclock(frame);

#if 0
	ddb_regs = *frame;
	db_show_regs(NULL, 0, 0, NULL);
#endif

	/* printf ("clock out 0x%x\n", t); */

	return 1;
a60 1

a116 1

@


1.15
log
@hardclock() is not called until clock has been initialized
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.14 2002/05/14 20:41:33 mickey Exp $	*/
d107 1
a107 1
	int 	tbad = 0;
d109 1
a109 1
	if (t < 5*SECYR) {
d115 3
a117 2
	pdc_call((iodcio_t)PAGE0->mem_pdc, 1, PDC_TOD, PDC_TOD_READ,
		&tod, 0, 0, 0, 0, 0);
d142 5
a146 2
	pdc_call((iodcio_t)PAGE0->mem_pdc, 1, PDC_TOD, PDC_TOD_WRITE,
	    time.tv_sec, time.tv_usec);
@


1.14
log
@make resettodr() save the clock (per the pdc manual), tested
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.13 2002/03/14 01:26:31 millert Exp $	*/
d56 1
d69 2
d81 3
@


1.13
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.12 2002/02/01 19:03:18 mickey Exp $	*/
d135 2
a136 6
	struct pdc_tod tod PDC_ALIGNMENT;

	tod.sec = time.tv_sec;
	tod.usec = time.tv_usec;

	pdc_call((iodcio_t)PAGE0->mem_pdc, 1, PDC_TOD, PDC_TOD_WRITE, &tod);
@


1.12
log
@long arg int format fix, from netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.11 2001/11/06 19:53:14 miod Exp $	*/
d57 1
a57 1
void startrtclock __P((void));
@


1.11
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.10 2001/08/31 03:13:42 mickey Exp $	*/
d122 1
a122 1
		printf("WARNING: clock %s %d days",
@


1.11.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.11 2001/11/06 19:53:14 miod Exp $	*/
a55 1
int cpu_clockok;
d57 1
a57 1
void startrtclock(void);
a67 2

	cpu_clockok = 1;
a78 3
	if (!cpu_clockok)
		return (1);

d122 1
a122 1
		printf("WARNING: clock %s %ld days",
d135 6
a140 2
	pdc_call((iodcio_t)PAGE0->mem_pdc, 1, PDC_TOD, PDC_TOD_WRITE,
	    time.tv_sec, time.tv_usec);
@


1.11.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.11.2.1 2002/06/11 03:35:36 art Exp $	*/
d107 1
a107 1
	int 	error, tbad = 0;
d109 1
a109 1
	if (t < 12*SECYR) {
d115 2
a116 3
	if ((error = pdc_call((iodcio_t)pdc,
	    1, PDC_TOD, PDC_TOD_READ, &tod, 0, 0, 0, 0, 0)))
		printf("clock: failed to fetch (%d)\n", error);
d141 2
a142 5
	int error;

	if ((error = pdc_call((iodcio_t)pdc, 1, PDC_TOD, PDC_TOD_WRITE,
	    time.tv_sec, time.tv_usec)))
		printf("clock: failed to save (%d)\n");
@


1.11.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d55 5
d63 33
a95 1
	CPU_CLOCKUPDATE();
d98 1
d155 1
@


1.10
log
@some knf
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.9 2000/03/29 23:11:06 mickey Exp $	*/
d49 1
a49 1
#include <vm/vm.h>
@


1.9
log
@timeout-driven heartbeat.
right thing would be to pass beat count as an argument to timeout
routine (casted to (void *)) avoiding static counter, but
doing timeout_set() every timeout_add() sounds kinda uncool.
well, pondering in the struct timeout guts would be even more ugly.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.8 2000/02/09 05:51:21 mickey Exp $	*/
d122 2
a123 2
		printf ("WARNING: clock %s %d days",
			time.tv_sec < t? "lost" : "gained", dt / SECDAY);
d135 1
a135 1
	static struct pdc_tod tod;
@


1.8
log
@thinking it seems reduces heartbeat, boy
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.7 2000/02/09 05:04:22 mickey Exp $	*/
a74 7
#ifdef USELEDS
	static u_int hbcnt = 0;

	if (!(hbcnt % (hz / 8)) && ((hbcnt / (hz / 8)) & 7) < 4)
		ledctl(0, 0, PALED_HEARTBEAT);
	hbcnt++;
#endif
@


1.8.2.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.9 2000/03/29 23:11:06 mickey Exp $	*/
d75 7
@


1.8.2.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.8.2.1 2001/04/18 16:05:54 niklas Exp $	*/
d122 2
a123 2
		printf("WARNING: clock %s %d days",
		    time.tv_sec < t? "lost" : "gained", dt / SECDAY);
d135 1
a135 1
	struct pdc_tod tod PDC_ALIGNMENT;
@


1.8.2.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d49 1
a49 1
#include <uvm/uvm_extern.h>
@


1.8.2.4
log
@Merge in trunk
@
text
@d122 1
a122 1
		printf("WARNING: clock %s %ld days",
@


1.8.2.5
log
@Merge in -current from about a week ago
@
text
@d57 1
a57 1
void startrtclock(void);
@


1.8.2.6
log
@Sync the SMP branch with 3.3
@
text
@d55 4
d62 6
a67 1
	CPU_CLOCKUPDATE();
d70 23
d101 1
a101 1
	int 	error, tbad = 0;
d103 1
a103 1
	if (t < 12*SECYR) {
d109 2
a110 3
	if ((error = pdc_call((iodcio_t)pdc,
	    1, PDC_TOD, PDC_TOD_READ, &tod, 0, 0, 0, 0, 0)))
		printf("clock: failed to fetch (%d)\n", error);
d135 4
a138 1
	int error;
d140 1
a140 3
	if ((error = pdc_call((iodcio_t)pdc, 1, PDC_TOD, PDC_TOD_WRITE,
	    time.tv_sec, time.tv_usec)))
		printf("clock: failed to save (%d)\n");
d149 1
@


1.8.2.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d58 1
a58 8
	extern volatile u_long cpu_itmr;
	extern u_long cpu_hzticks;
	u_long __itmr;

	mfctl(CR_ITMR, __itmr);
	cpu_itmr = __itmr;
	__itmr += cpu_hzticks;
	mtctl(__itmr, CR_ITMR);
d108 1
a108 1
		printf("clock: failed to save (%d)\n", error);
@


1.8.2.8
log
@Merge with the trunk
@
text
@d4 1
a4 1
 * Copyright (c) 1998-2003 Michael Shalayeff
d15 5
d24 7
a30 8
 * IN NO EVENT SHALL THE AUTHOR OR HIS RELATIVES BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
@


1.7
log
@heartbeat -- yeah we have a patch for that
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.6 1999/09/07 20:50:24 mickey Exp $	*/
a63 5
#ifdef USELEDS
	static u_int hbcnt = 0;

	if (!(hbcnt % (hz / 8))) {
		register u_int r = (hbcnt / (hz / 8)) & 7;
a64 7
		if (r == 1 || r == 3)
			ledctl(PALED_HEARTBEAT, 0, 0);
		else
			ledctl(0, PALED_HEARTBEAT, 0);
	}
	hbcnt++;
#endif
d75 2
d78 4
a81 1
/*	printf ("#"); */
@


1.6
log
@make inittodr() whine some sane things
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.5 1999/08/14 03:56:12 mickey Exp $	*/
d26 2
a27 2
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
d67 2
a68 2
	if (!(hbcnt % 50)) {
		register u_int r = (hbcnt / 50) % 6;
d70 4
a73 1
		heartbeat(r < 4 && !(r % 2));
d75 1
a115 1
	long	dt;
d130 1
a130 1
		dt = time.tv_sec - t;
d132 1
a132 2
		if (dt < 0)
			dt = -dt;
@


1.5
log
@clock_intr()
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.4 1999/06/24 00:10:56 mickey Exp $	*/
d110 9
a118 1
	static struct pdc_tod tod;
d126 10
a135 3
	if ((long)time.tv_sec < 0) {
		time.tv_sec = SECYR * (1990 - 1970);
		printf("WARNING: clock not initialized -- check and reset\n");
d137 2
@


1.4
log
@manualy assign structures
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.3 1999/06/12 17:47:08 mickey Exp $	*/
d48 7
d76 24
@


1.3
log
@microtime() is moving to locore.S
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.2 1999/02/07 20:24:51 mickey Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998 Michael Shalayeff
d84 2
a85 1
	time = *(struct timeval *)&tod;
@


1.2
log
@missign extern cpu_hzticks
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.1 1998/12/29 21:35:42 mickey Exp $	*/
a50 10

/*
 * Return the best possible estimate of the current time.
 */
void
microtime(tvp)
	struct timeval *tvp;
{

}
@


1.1
log
@no microtime() yet
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d65 1
@

