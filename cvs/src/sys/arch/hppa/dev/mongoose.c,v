head	1.21;
access;
symbols
	OPENBSD_6_1:1.21.0.28
	OPENBSD_6_1_BASE:1.21
	OPENBSD_6_0:1.21.0.26
	OPENBSD_6_0_BASE:1.21
	OPENBSD_5_9:1.21.0.22
	OPENBSD_5_9_BASE:1.21
	OPENBSD_5_8:1.21.0.24
	OPENBSD_5_8_BASE:1.21
	OPENBSD_5_7:1.21.0.16
	OPENBSD_5_7_BASE:1.21
	OPENBSD_5_6:1.21.0.20
	OPENBSD_5_6_BASE:1.21
	OPENBSD_5_5:1.21.0.18
	OPENBSD_5_5_BASE:1.21
	OPENBSD_5_4:1.21.0.14
	OPENBSD_5_4_BASE:1.21
	OPENBSD_5_3:1.21.0.12
	OPENBSD_5_3_BASE:1.21
	OPENBSD_5_2:1.21.0.10
	OPENBSD_5_2_BASE:1.21
	OPENBSD_5_1_BASE:1.21
	OPENBSD_5_1:1.21.0.8
	OPENBSD_5_0:1.21.0.6
	OPENBSD_5_0_BASE:1.21
	OPENBSD_4_9:1.21.0.4
	OPENBSD_4_9_BASE:1.21
	OPENBSD_4_8:1.21.0.2
	OPENBSD_4_8_BASE:1.21
	OPENBSD_4_7:1.19.0.2
	OPENBSD_4_7_BASE:1.19
	OPENBSD_4_6:1.17.0.22
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.17.0.18
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.17.0.16
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.17.0.14
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.17.0.12
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.17.0.10
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.17.0.8
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.17.0.6
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.17.0.4
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.17.0.2
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.15.0.2
	OPENBSD_3_6_BASE:1.15
	SMP_SYNC_A:1.15
	SMP_SYNC_B:1.15
	OPENBSD_3_5:1.14.0.4
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.14.0.2
	OPENBSD_3_4_BASE:1.14
	UBC_SYNC_A:1.12
	OPENBSD_3_3:1.9.0.6
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.4
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	UBC_SYNC_B:1.9
	UBC:1.7.0.8
	UBC_BASE:1.7
	OPENBSD_3_0:1.7.0.6
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9:1.7.0.4
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_8:1.7.0.2
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.6.0.4
	OPENBSD_2_7_BASE:1.6
	SMP:1.6.0.2
	SMP_BASE:1.6
	kame_19991208:1.4
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3;
locks; strict;
comment	@ * @;


1.21
date	2010.05.24.15.04.53;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2010.04.27.18.29.39;	author kettenis;	state Exp;
branches;
next	1.19;

1.19
date	2010.01.01.20.28.42;	author kettenis;	state Exp;
branches;
next	1.18;

1.18
date	2009.07.26.18.48.55;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2004.11.08.20.54.04;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2004.10.29.20.23.37;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2004.04.07.18.24.19;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	2003.08.11.05.48.28;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	2003.08.07.19.47.33;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	2003.05.11.19.41.09;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2003.04.08.20.48.39;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	2003.04.08.20.37.39;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.14.01.26.31;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.02.05.04.26.06;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	2000.08.15.19.42.56;	author mickey;	state Exp;
branches
	1.7.8.1;
next	1.6;

1.6
date	2000.02.09.06.01.20;	author mickey;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2000.01.28.20.20.47;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	99.11.26.05.04.42;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	99.09.10.18.03.46;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	99.08.16.02.53.50;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	99.04.20.20.21.51;	author mickey;	state Exp;
branches;
next	;

1.6.2.1
date	2001.04.18.16.05.57;	author niklas;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2002.03.06.00.57.22;	author niklas;	state Exp;
branches;
next	1.6.2.3;

1.6.2.3
date	2002.03.28.10.07.19;	author niklas;	state Exp;
branches;
next	1.6.2.4;

1.6.2.4
date	2003.05.13.19.41.03;	author ho;	state Exp;
branches;
next	1.6.2.5;

1.6.2.5
date	2004.02.19.10.48.39;	author niklas;	state Exp;
branches;
next	1.6.2.6;

1.6.2.6
date	2004.06.05.23.10.47;	author niklas;	state Exp;
branches;
next	;

1.7.8.1
date	2002.06.11.03.35.36;	author art;	state Exp;
branches;
next	1.7.8.2;

1.7.8.2
date	2003.05.19.21.49.41;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.21
log
@Add missing prototypes
ok jsing kettenis
@
text
@/*	$OpenBSD: mongoose.c,v 1.20 2010/04/27 18:29:39 kettenis Exp $	*/

/*
 * Copyright (c) 1998-2003 Michael Shalayeff
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR OR HIS RELATIVES BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/reboot.h>

#include <machine/bus.h>
#include <machine/iomod.h>
#include <machine/autoconf.h>

#include <hppa/dev/cpudevs.h>
#include <hppa/dev/viper.h>

#include <dev/eisa/eisareg.h>
#include <dev/eisa/eisavar.h>

#include <dev/isa/isareg.h>
#include <dev/isa/isavar.h>

#include <hppa/dev/mongoosereg.h>
#include <hppa/dev/mongoosevar.h>

void	mgattach_gedoens(struct device *, struct device *, void *);
int	mgmatch_gedoens(struct device *, void *, void *);

struct cfattach mg_gedoens_ca = {
	sizeof(struct mongoose_softc), mgmatch_gedoens, mgattach_gedoens
};

struct cfdriver mongoose_cd = {
	NULL, "mongoose", DV_DULL
};

void		 mg_eisa_attach_hook(struct device *parent,
		    struct device *self,
		    struct eisabus_attach_args *mg);
int		 mg_intr_map(void *v, u_int irq, eisa_intr_handle_t *ehp);
const char	*mg_intr_string(void *v, int irq);
void		 mg_isa_attach_hook(struct device *parent,
		    struct device *self,
		    struct isabus_attach_args *iba);
void		*mg_intr_establish(void *v, int irq, int type, int pri,
		    int (*handler)(void *), void *arg, const char *name);
void		 mg_intr_disestablish(void *v, void *cookie);
int		 mg_intr_check(void *v, int irq, int type);
int		 mg_eisa_iomap(void *v, bus_addr_t addr, bus_size_t size,
		    int flags, bus_space_handle_t *bshp);
int		 mg_eisa_memmap(void *v, bus_addr_t addr, bus_size_t size,
		    int flags, bus_space_handle_t *bshp);
void		 mg_eisa_memunmap(void *v, bus_space_handle_t bsh,
		    bus_size_t size);
void		 mg_isa_barrier(void *v, bus_space_handle_t h, bus_size_t o,
		    bus_size_t l, int op);
u_int16_t	 mg_isa_r2(void *v, bus_space_handle_t h, bus_size_t o);
u_int32_t	 mg_isa_r4(void *v, bus_space_handle_t h, bus_size_t o);
void		 mg_isa_w2(void *v, bus_space_handle_t h, bus_size_t o,
		    u_int16_t vv);
void		 mg_isa_w4(void *v, bus_space_handle_t h, bus_size_t o,
		    u_int32_t vv);
void		 mg_isa_rm_2(void *v, bus_space_handle_t h, bus_size_t o,
		    u_int16_t *a, bus_size_t c);
void		 mg_isa_rm_4(void *v, bus_space_handle_t h, bus_size_t o,
		    u_int32_t *a, bus_size_t c);
void		 mg_isa_wm_2(void *v, bus_space_handle_t h, bus_size_t o,
		    const u_int16_t *a, bus_size_t c);
void		 mg_isa_wm_4(void *v, bus_space_handle_t h, bus_size_t o,
		    const u_int32_t *a, bus_size_t c);
void		 mg_isa_sm_2(void *v, bus_space_handle_t h, bus_size_t o,
		    u_int16_t vv, bus_size_t c);
void		 mg_isa_sm_4(void *v, bus_space_handle_t h, bus_size_t o,
		    u_int32_t vv, bus_size_t c);
void		 mg_isa_rr_2(void *v, bus_space_handle_t h, bus_size_t o,
		    u_int16_t *a, bus_size_t c);
void		 mg_isa_rr_4(void *v, bus_space_handle_t h, bus_size_t o,
		    u_int32_t *a, bus_size_t c);
void		 mg_isa_wr_2(void *v, bus_space_handle_t h, bus_size_t o,
		    const u_int16_t *a, bus_size_t c);
void		 mg_isa_wr_4(void *v, bus_space_handle_t h, bus_size_t o,
		    const u_int32_t *a, bus_size_t c);
void		 mg_isa_sr_2(void *v, bus_space_handle_t h, bus_size_t o,
		    u_int16_t vv, bus_size_t c);
void		 mg_isa_sr_4(void *v, bus_space_handle_t h, bus_size_t o,
		    u_int32_t vv, bus_size_t c);

/* TODO: DMA guts */

void
mg_eisa_attach_hook(struct device *parent, struct device *self,
	struct eisabus_attach_args *mg)
{
}

int
mg_intr_map(void *v, u_int irq, eisa_intr_handle_t *ehp)
{
	*ehp = irq;
	return 0;
}

const char *
mg_intr_string(void *v, int irq)
{
	static char buf[16];

	snprintf(buf, sizeof buf, "isa irq %d", irq);
	return buf;
}

void
mg_isa_attach_hook(struct device *parent, struct device *self,
	struct isabus_attach_args *iba)
{

}

void *
mg_intr_establish(void *v, int irq, int type, int pri,
	int (*handler)(void *), void *arg, const char *name)
{
	struct hppa_isa_iv *iv;
	struct mongoose_softc *sc = v;
	volatile u_int8_t *imr, *pic;

	if (!sc || irq < 0 || irq >= MONGOOSE_NINTS ||
	    (0 <= irq && irq < MONGOOSE_NINTS && sc->sc_iv[irq].iv_handler))
		return NULL;

	if (type != IST_LEVEL && type != IST_EDGE) {
#ifdef DEBUG
		printf("%s: bad interrupt level (%d)\n", sc->sc_dev.dv_xname,
		    type);
#endif
		return NULL;
	}

	iv = &sc->sc_iv[irq];
	if (iv->iv_handler) {
#ifdef DEBUG
		printf("%s: irq %d already established\n", sc->sc_dev.dv_xname,
		    irq);
#endif
		return NULL;
	}

	iv->iv_name = name;
	iv->iv_pri = pri;
	iv->iv_handler = handler;
	iv->iv_arg = arg;
	
	if (irq < 8) {
		imr = &sc->sc_ctrl->imr0;
		pic = &sc->sc_ctrl->pic0;
	} else {
		imr = &sc->sc_ctrl->imr1;
		pic = &sc->sc_ctrl->pic1;
		irq -= 8;
	}

	*imr |= 1 << irq;
	*pic |= (type == IST_LEVEL) << irq;

	/* TODO: ack it? */

	return iv;
}

void
mg_intr_disestablish(void *v, void *cookie)
{
	struct hppa_isa_iv *iv = cookie;
	struct mongoose_softc *sc = v;
 	int irq = iv - sc->sc_iv;
 	volatile u_int8_t *imr;

	if (!sc || !cookie)
		return;

	if (irq < 8)
		imr = &sc->sc_ctrl->imr0;
	else
		imr = &sc->sc_ctrl->imr1;
	*imr &= ~(1 << irq);
	/* TODO: ack it? */

	iv->iv_handler = NULL;
}

int
mg_intr_check(void *v, int irq, int type)
{
	return 0;
}

int
mg_intr(void *v)
{
	struct mongoose_softc *sc = v;
	struct hppa_isa_iv *iv;
	int s, irq = 0;

	iv = &sc->sc_iv[irq];
	s = splraise(iv->iv_pri);
	(iv->iv_handler)(iv->iv_arg);
	splx(s);

	return 0;
}

int
mg_eisa_iomap(void *v, bus_addr_t addr, bus_size_t size, int flags,
	bus_space_handle_t *bshp)
{
	struct mongoose_softc *sc = v;

	/* see if it's ISA space we are mapping */
	if (0x100 <= addr && addr < 0x400) {
#define	TOISA(a) ((((a) & 0x3f8) << 9) + ((a) & 7))
		size = TOISA(addr + size) - TOISA(addr);
		addr = TOISA(addr);
	}

	return (sc->sc_bt->hbt_map)(NULL, sc->sc_iomap + addr, size,
				    flags, bshp);
}

int
mg_eisa_memmap(void *v, bus_addr_t addr, bus_size_t size, int flags,
	bus_space_handle_t *bshp)
{
	/* TODO: eisa memory map */
	return -1;
}

void
mg_eisa_memunmap(void *v, bus_space_handle_t bsh, bus_size_t size)
{
	/* TODO: eisa memory unmap */
}

void
mg_isa_barrier(void *v, bus_space_handle_t h, bus_size_t o, bus_size_t l, int op)
{
	sync_caches();
}

u_int16_t
mg_isa_r2(void *v, bus_space_handle_t h, bus_size_t o)
{
	register u_int16_t r = *((volatile u_int16_t *)(h + o));
	return letoh16(r);
}

u_int32_t
mg_isa_r4(void *v, bus_space_handle_t h, bus_size_t o)
{
	register u_int32_t r = *((volatile u_int32_t *)(h + o));
	return letoh32(r);
}

void
mg_isa_w2(void *v, bus_space_handle_t h, bus_size_t o, u_int16_t vv)
{
	*((volatile u_int16_t *)(h + o)) = htole16(vv);
}

void
mg_isa_w4(void *v, bus_space_handle_t h, bus_size_t o, u_int32_t vv)
{
	*((volatile u_int32_t *)(h + o)) = htole32(vv);
}

void
mg_isa_rm_2(void *v, bus_space_handle_t h, bus_size_t o, u_int16_t *a, bus_size_t c)
{
	h += o;
	while (c--)
		*(a++) = letoh16(*(volatile u_int16_t *)h);
}

void
mg_isa_rm_4(void *v, bus_space_handle_t h, bus_size_t o, u_int32_t *a, bus_size_t c)
{
	h += o;
	while (c--)
		*(a++) = letoh32(*(volatile u_int32_t *)h);
}

void
mg_isa_wm_2(void *v, bus_space_handle_t h, bus_size_t o, const u_int16_t *a, bus_size_t c)
{
	register u_int16_t r;
	h += o;
	while (c--) {
		r = *(a++);
		*(volatile u_int16_t *)h = htole16(r);
	}
}

void
mg_isa_wm_4(void *v, bus_space_handle_t h, bus_size_t o, const u_int32_t *a, bus_size_t c)
{
	register u_int32_t r;
	h += o;
	while (c--) {
		r = *(a++);
		*(volatile u_int32_t *)h = htole32(r);
	}
}

void
mg_isa_sm_2(void *v, bus_space_handle_t h, bus_size_t o, u_int16_t vv, bus_size_t c)
{
	vv = htole16(vv);
	h += o;
	while (c--)
		*(volatile u_int16_t *)h = vv;
}

void
mg_isa_sm_4(void *v, bus_space_handle_t h, bus_size_t o, u_int32_t vv, bus_size_t c)
{
	vv = htole32(vv);
	h += o;
	while (c--)
		*(volatile u_int32_t *)h = vv;
}

void
mg_isa_rr_2(void *v, bus_space_handle_t h, bus_size_t o, u_int16_t *a, bus_size_t c)
{
	volatile u_int16_t *p = (u_int16_t *)(h + o);
	u_int32_t r;

	while (c--) {
		r = *p++;
		*a++ = letoh16(r);
	}
}

void
mg_isa_rr_4(void *v, bus_space_handle_t h, bus_size_t o, u_int32_t *a, bus_size_t c)
{
	volatile u_int32_t *p = (u_int32_t *)(h + o);
	u_int32_t r;

	while (c--) {
		r = *p++;
		*a++ = letoh32(r);
	}
}

void
mg_isa_wr_2(void *v, bus_space_handle_t h, bus_size_t o, const u_int16_t *a, bus_size_t c)
{
	volatile u_int16_t *p = (u_int16_t *)(h + o);
	u_int32_t r;

	while (c--) {
		r = *a++;
		*p++ = htole16(r);
	}
}

void
mg_isa_wr_4(void *v, bus_space_handle_t h, bus_size_t o, const u_int32_t *a, bus_size_t c)
{
	volatile u_int32_t *p = (u_int32_t *)(h + o);
	u_int32_t r;

	while (c--) {
		r = *a++;
		*p++ = htole32(r);
	}
}

void
mg_isa_sr_2(void *v, bus_space_handle_t h, bus_size_t o, u_int16_t vv, bus_size_t c)
{
	volatile u_int16_t *p = (u_int16_t *)(h + o);

	vv = htole16(vv);
	while (c--)
		*p++ = vv;
}

void
mg_isa_sr_4(void *v, bus_space_handle_t h, bus_size_t o, u_int32_t vv, bus_size_t c)
{
	volatile u_int32_t *p = (u_int32_t *)(h + o);

	vv = htole32(vv);
	while (c--)
		*p++ = vv;
}

int
mgattach_common(sc)
	struct mongoose_softc *sc;
{
	struct hppa_bus_space_tag *bt;
	union mongoose_attach_args ea;
	char brid[EISA_IDSTRINGLEN];

	viper_eisa_en();

	/* BUS RESET */
	sc->sc_ctrl->nmi_ext = MONGOOSE_NMI_BUSRESET;
	DELAY(1);
	sc->sc_ctrl->nmi_ext = 0;
	DELAY(100);

	/* determine eisa board id */
	{
		u_int8_t id[4], *p;
		p = (u_int8_t *)(sc->sc_iomap + EISA_SLOTOFF_VID);
		id[0] = *p++;
		id[1] = *p++;
		id[2] = *p++;
		id[3] = *p++;

		brid[0] = EISA_VENDID_0(id);
		brid[1] = EISA_VENDID_1(id);
		brid[2] = EISA_VENDID_2(id);
		brid[3] = EISA_PRODID_0(id + 2);
		brid[4] = EISA_PRODID_1(id + 2);
		brid[5] = EISA_PRODID_2(id + 2);
		brid[6] = EISA_PRODID_3(id + 2);
		brid[7] = '\0';
	}

	printf (": %s rev %d, %d MHz\n", brid, sc->sc_regs->version,
		(sc->sc_regs->clock? 33 : 25));
	sc->sc_regs->liowait = 1;	/* disable isa wait states */
	sc->sc_regs->lock    = 1;	/* bus unlock */

	/* attach EISA */
	sc->sc_ec.ec_v = sc;
	sc->sc_ec.ec_attach_hook = mg_eisa_attach_hook;
	sc->sc_ec.ec_intr_establish = mg_intr_establish;
	sc->sc_ec.ec_intr_disestablish = mg_intr_disestablish;
	sc->sc_ec.ec_intr_string = mg_intr_string;
	sc->sc_ec.ec_intr_map = mg_intr_map;
	/* inherit the bus tags for eisa from the mainbus */
	bt = &sc->sc_eiot;
	bcopy(sc->sc_bt, bt, sizeof(*bt));
	bt->hbt_cookie = sc;
	bt->hbt_map = mg_eisa_iomap;
#define	R(n)	bt->__CONCAT(hbt_,n) = &__CONCAT(mg_isa_,n)
	/* R(barrier); */
	R(r2); R(r4); R(w2); R(w4);
	R(rm_2);R(rm_4);R(wm_2);R(wm_4);R(sm_2);R(sm_4);
	R(rr_2);R(rr_4);R(wr_2);R(wr_4);R(sr_2);R(sr_4);

	bt = &sc->sc_ememt;
	bcopy(sc->sc_bt, bt, sizeof(*bt));
	bt->hbt_cookie = sc;
	bt->hbt_map = mg_eisa_memmap;
	bt->hbt_unmap = mg_eisa_memunmap;
	/* attachment guts */
	ea.mongoose_eisa.eba_busname = "eisa";
	ea.mongoose_eisa.eba_iot = &sc->sc_eiot;
	ea.mongoose_eisa.eba_memt = &sc->sc_ememt;
	ea.mongoose_eisa.eba_dmat = NULL /* &sc->sc_edmat */;
	ea.mongoose_eisa.eba_ec = &sc->sc_ec;
	config_found((struct device *)sc, &ea.mongoose_eisa, mgprint);

	sc->sc_ic.ic_v = sc;
	sc->sc_ic.ic_attach_hook = mg_isa_attach_hook;
	sc->sc_ic.ic_intr_establish = mg_intr_establish;
	sc->sc_ic.ic_intr_disestablish = mg_intr_disestablish;
	sc->sc_ic.ic_intr_check = mg_intr_check;
	/* inherit the bus tags for isa from the eisa */
	bt = &sc->sc_imemt;
	bcopy(&sc->sc_ememt, bt, sizeof(*bt));
	bt = &sc->sc_iiot;
	bcopy(&sc->sc_eiot, bt, sizeof(*bt));
	/* TODO: DMA tags */
	/* attachment guts */
	ea.mongoose_isa.iba_busname = "isa";
	ea.mongoose_isa.iba_iot = &sc->sc_iiot;
	ea.mongoose_isa.iba_memt = &sc->sc_imemt;
#if NISADMA > 0
	ea.mongoose_isa.iba_dmat = &sc->sc_idmat;
#endif
	ea.mongoose_isa.iba_ic = &sc->sc_ic;
	config_found((struct device *)sc, &ea.mongoose_isa, mgprint);
#undef	R

	return (0);
}

int
mgprint(aux, pnp)
	void *aux;
	const char *pnp;
{
	union mongoose_attach_args *ea = aux;

	if (pnp)
		printf ("%s at %s", ea->mongoose_name, pnp);

	return (UNCONF);
}

int
mgmatch_gedoens(parent, cfdata, aux)   
	struct device *parent;
	void *cfdata;
	void *aux;
{
	register struct confargs *ca = aux;
	/* struct cfdata *cf = cfdata; */
	bus_space_handle_t ioh;

	if (ca->ca_type.iodc_type != HPPA_TYPE_BHA ||
	    (ca->ca_type.iodc_sv_model != HPPA_BHA_EISA &&
	     ca->ca_type.iodc_sv_model != HPPA_BHA_WEISA))
		return 0;

	if (bus_space_map(ca->ca_iot, ca->ca_hpa + MONGOOSE_MONGOOSE,
	    IOMOD_HPASIZE, 0, &ioh))
		return 0;

	/* XXX check EISA signature */

	bus_space_unmap(ca->ca_iot, ioh, IOMOD_HPASIZE);

	return 1;
}

void
mgattach_gedoens(parent, self, aux)
	struct device *parent;
	struct device *self;
	void *aux;
{
	register struct confargs *ca = aux;
	register struct mongoose_softc *sc = (struct mongoose_softc *)self;
	bus_space_handle_t ioh;

	sc->sc_bt = ca->ca_iot;
	sc->sc_iomap = ca->ca_hpa;

	if (bus_space_map(ca->ca_iot, ca->ca_hpa + MONGOOSE_MONGOOSE,
	    sizeof(struct mongoose_regs), 0, &ioh) != 0) {
		printf(": can't map IO space\n");
		return;
	}
	sc->sc_regs = (struct mongoose_regs *)ioh;

	if (bus_space_map(ca->ca_iot, ca->ca_hpa + MONGOOSE_CTRL,
	    sizeof(struct mongoose_ctrl), 0, &ioh) != 0) {
		printf(": can't map control registers\n");
		bus_space_unmap(ca->ca_iot, (bus_space_handle_t)sc->sc_regs,
		    sizeof(struct mongoose_regs));
		return;
	}
	sc->sc_ctrl = (struct mongoose_ctrl *)ioh;

	if (mgattach_common(sc) != 0)
		return;

	/* attach interrupt */
	sc->sc_ih = cpu_intr_establish(IPL_HIGH, ca->ca_irq,
				       mg_intr, sc, sc->sc_dev.dv_xname);
}
@


1.20
log
@Don't use cast expressions as lvalues; gcc4 complains about them.  And gcc3
generates smaller code without them.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mongoose.c,v 1.19 2010/01/01 20:28:42 kettenis Exp $	*/
d60 51
@


1.19
log
@Map the device registers before using them.  We were lucky that some other
device already mapped the block that contains our registers, but if we change
the probe order, or disable devices we might not end up so lucky.

ok jsing@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mongoose.c,v 1.18 2009/07/26 18:48:55 miod Exp $	*/
d307 3
a309 2
	register u_int16_t r;
	h += o;
d311 2
a312 2
		r = *((volatile u_int16_t *)h)++;
		*(a++) = letoh16(r);
d319 3
a321 2
	register u_int32_t r;
	h += o;
d323 2
a324 2
		r = *((volatile u_int32_t *)h)++;
		*(a++) = letoh32(r);
d331 3
a333 2
	register u_int16_t r;
	h += o;
d335 2
a336 2
		r = *(a++);
		*((volatile u_int16_t *)h)++ = htole16(r);
d343 3
a345 2
	register u_int32_t r;
	h += o;
d347 2
a348 2
		r = *(a++);
		*((volatile u_int32_t *)h)++ = htole32(r);
d355 2
a357 1
	h += o;
d359 1
a359 1
		*((volatile u_int16_t *)h)++ = vv;
d365 2
a367 1
	h += o;
d369 1
a369 1
		*((volatile u_int32_t *)h)++ = vv;
@


1.18
log
@Make sure all platforms understand the flags argument of bus_space_map() and
bus_space_alloc() as a bitmask of flags, and not a boolean controlling
cacheability; and make sure the three MI BUS_SPACE_MAP_xxx values documented
in the manual page are defined on all platforms as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: mongoose.c,v 1.17 2004/11/08 20:54:04 miod Exp $	*/
d509 1
d513 16
a528 2
	sc->sc_regs = (struct mongoose_regs *)(ca->ca_hpa + MONGOOSE_MONGOOSE);
	sc->sc_ctrl = (struct mongoose_ctrl *)(ca->ca_hpa + MONGOOSE_CTRL);
@


1.17
log
@Show in the dmesg as mongoose, to matche the manpage and kernel configuration
file.
@
text
@d1 1
a1 1
/*	$OpenBSD: mongoose.c,v 1.16 2004/10/29 20:23:37 miod Exp $	*/
d186 1
a186 1
mg_eisa_iomap(void *v, bus_addr_t addr, bus_size_t size, int cacheable,
d199 1
a199 1
				    cacheable, bshp);
d203 1
a203 1
mg_eisa_memmap(void *v, bus_addr_t addr, bus_size_t size, int cacheable,
@


1.16
log
@Split mongoose and add a gscbus attachment, for the eisa slots in B series.
This is still a work in progress.

feedback and ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mongoose.c,v 1.15 2004/04/07 18:24:19 mickey Exp $	*/
d58 1
a58 1
	NULL, "mg", DV_DULL
@


1.15
log
@update copyright; miod@@ is fine w/ files where he holds it too
@
text
@d1 1
a1 1
/*	$OpenBSD: mongoose.c,v 1.14 2003/08/11 05:48:28 mickey Exp $	*/
a28 3

#define MONGOOSE_DEBUG 9

d47 2
a48 153
/* EISA Bus Adapter registers definitions */
#define	MONGOOSE_MONGOOSE	0x10000
struct mongoose_regs {
	u_int8_t	version;
	u_int8_t	lock;
	u_int8_t	liowait;
	u_int8_t	clock;
	u_int8_t	reserved[0xf000 - 4];
	u_int8_t	intack;
};

#define	MONGOOSE_CTRL		0x00000
#define	MONGOOSE_NINTS		16
struct mongoose_ctrl {
	struct dma0 {
		struct {
			u_int32_t	addr : 8;
			u_int32_t	count: 8;
		} ch[4];
		u_int8_t	command;
		u_int8_t	request;
		u_int8_t	mask_channel;
		u_int8_t	mode;
		u_int8_t	clr_byte_ptr;
		u_int8_t	master_clear;
		u_int8_t	mask_clear;
		u_int8_t	master_write;
		u_int8_t	pad[8];
	}	dma0;

	u_int8_t	irr0;		/* 0x20 */
	u_int8_t	imr0;
	u_int8_t	iack;		/* 0x22 -- 2 b2b reads generate
					(e)isa Iack cycle & returns int level */
	u_int8_t	pad0[29];

	struct timers {
		u_int8_t	sysclk;
		u_int8_t	refresh;
		u_int8_t	spkr;
		u_int8_t	ctrl;
		u_int32_t	pad;
	}	tmr[2];			/* 0x40 -- timers control */
	u_int8_t	pad1[16];

	u_int16_t	inmi;		/* 0x60 NMI control */
	u_int8_t	pad2[30];
	struct {
		u_int8_t	pad0;
		u_int8_t	ch2;
		u_int8_t	ch3;
		u_int8_t	ch1;
		u_int8_t	pad1;
		u_int8_t	pad2[3];
		u_int8_t	ch0;
		u_int8_t	pad4;
		u_int8_t	ch6;
		u_int8_t	ch7;
		u_int8_t	ch5;
		u_int8_t	pad5[3];
		u_int8_t	pad6[16];
	} pr;				/* 0x80 */

	u_int8_t	irr1;		/* 0xa0 */
	u_int8_t	imr1;
	u_int8_t	pad3[30];

	struct dma1 {
		struct {
			u_int32_t	addr : 8;
			u_int32_t	pad0 : 8;
			u_int32_t	count: 8;
			u_int32_t	pad1 : 8;
		} ch[4];
		u_int8_t	command;
		u_int8_t	pad0;
		u_int8_t	request;
		u_int8_t	pad1;
		u_int8_t	mask_channel;
		u_int8_t	pad2;
		u_int8_t	mode;
		u_int8_t	pad3;
		u_int8_t	clr_byte_ptr;
		u_int8_t	pad4;
		u_int8_t	master_clear;
		u_int8_t	pad5;
		u_int8_t	mask_clear;
		u_int8_t	pad6;
		u_int8_t	master_write;
		u_int8_t	pad7;
	}	dma1;			/* 0xc0 */

	u_int8_t	master_req;	/* 0xe0 master request register */
	u_int8_t	pad4[31];

	u_int8_t	pad5[0x3d0];	/* 0x4d0 */
	u_int8_t	pic0;		/* 0 - edge, 1 - level */
	u_int8_t	pic1;
	u_int8_t	pad6[0x460];
	u_int8_t	nmi;
	u_int8_t	nmi_ext;
#define	MONGOOSE_NMI_BUSRESET	0x01
#define	MONGOOSE_NMI_IOPORT_EN	0x02
#define	MONGOOSE_NMI_EN		0x04
#define	MONGOOSE_NMI_MTMO_EN	0x08
#define	MONGOOSE_NMI_RES4	0x10
#define	MONGOOSE_NMI_IOPORT_INT	0x20
#define	MONGOOSE_NMI_MASTER_INT	0x40
#define	MONGOOSE_NMI_INT	0x80
};

#define	MONGOOSE_IOMAP	0x100000

struct hppa_isa_iv {
	const char *iv_name;
	int (*iv_handler)(void *arg);
	void *iv_arg;
	int iv_pri;

	struct evcnt iv_evcnt;
	/* don't do sharing, we won't have many slots anyway
	struct hppa_isa_iv *iv_next;
	*/
};

struct mongoose_softc {
	struct  device sc_dev;
	void *sc_ih;

	bus_space_tag_t sc_bt;
	volatile struct mongoose_regs *sc_regs;
	volatile struct mongoose_ctrl *sc_ctrl;
	bus_addr_t sc_iomap;

	/* interrupts section */
	struct hppa_eisa_chipset sc_ec;
	struct hppa_isa_chipset sc_ic;
	struct hppa_isa_iv sc_iv[MONGOOSE_NINTS];

	/* isa/eisa bus guts */
	struct hppa_bus_space_tag sc_eiot;
	struct hppa_bus_space_tag sc_ememt;
	struct hppa_bus_dma_tag sc_edmat;
	struct hppa_bus_space_tag sc_iiot;
	struct hppa_bus_space_tag sc_imemt;
	struct hppa_bus_dma_tag sc_idmat;
};

union mongoose_attach_args {
	char *mongoose_name;
	struct eisabus_attach_args mongoose_eisa;
	struct isabus_attach_args mongoose_isa;
};
d50 2
a51 3
int	mgmatch(struct device *, void *, void *);
void	mgattach(struct device *, struct device *, void *);
int	mgprint(void *aux, const char *pnp);
d53 2
a54 2
struct cfattach mongoose_ca = {
	sizeof(struct mongoose_softc), mgmatch, mgattach
d367 2
a368 4
mgmatch(parent, cfdata, aux)   
	struct device *parent;
	void *cfdata;
	void *aux;
a369 28
	register struct confargs *ca = aux;
	/* struct cfdata *cf = cfdata; */
	bus_space_handle_t ioh;

	if (ca->ca_type.iodc_type != HPPA_TYPE_BHA ||
	    (ca->ca_type.iodc_sv_model != HPPA_BHA_EISA &&
	     ca->ca_type.iodc_sv_model != HPPA_BHA_WEISA))
		return 0;

	if (bus_space_map(ca->ca_iot, ca->ca_hpa + MONGOOSE_MONGOOSE,
	    IOMOD_HPASIZE, 0, &ioh))
		return 0;

	/* XXX check EISA signature */

	bus_space_unmap(ca->ca_iot, ioh, IOMOD_HPASIZE);

	return 1;
}

void
mgattach(parent, self, aux)
	struct device *parent;
	struct device *self;
	void *aux;
{
	register struct confargs *ca = aux;
	register struct mongoose_softc *sc = (struct mongoose_softc *)self;
a373 5
	sc->sc_bt = ca->ca_iot;
	sc->sc_iomap = ca->ca_hpa;
	sc->sc_regs = (struct mongoose_regs *)(ca->ca_hpa + MONGOOSE_MONGOOSE);
	sc->sc_ctrl = (struct mongoose_ctrl *)(ca->ca_hpa + MONGOOSE_CTRL);

d385 1
a385 1
		p = (u_int8_t *)(ca->ca_hpa + EISA_SLOTOFF_VID);
d415 1
a415 1
	bcopy(ca->ca_iot, bt, sizeof(*bt));
d425 1
a425 1
	bcopy(ca->ca_iot, bt, sizeof(*bt));
d435 1
a435 1
	config_found(self, &ea.mongoose_eisa, mgprint);
d456 1
a456 1
	config_found(self, &ea.mongoose_isa, mgprint);
d459 1
a459 3
	/* attach interrupt */
	sc->sc_ih = cpu_intr_establish(IPL_HIGH, ca->ca_irq,
				       mg_intr, sc, sc->sc_dev.dv_xname);
d475 47
@


1.14
log
@wax mongoose
@
text
@d1 1
a1 1
/*	$OpenBSD: mongoose.c,v 1.13 2003/08/07 19:47:33 mickey Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998,1999 Michael Shalayeff
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Michael Shalayeff.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.13
log
@make all intr_establish take the same last arg for name
@
text
@d1 1
a1 1
/*	$OpenBSD: mongoose.c,v 1.12 2003/05/11 19:41:09 deraadt Exp $	*/
d537 2
a538 1
	    ca->ca_type.iodc_sv_model != HPPA_BHA_EISA)
d541 2
a542 2
	if (bus_space_map(ca->ca_iot, ca->ca_hpa + MONGOOSE_MONGOOSE, IOMOD_HPASIZE,
			  0, &ioh))
@


1.12
log
@string cleaning; krw ok
@
text
@d1 1
a1 1
/*	$OpenBSD: mongoose.c,v 1.11 2003/04/08 20:48:39 mickey Exp $	*/
d254 1
a254 1
	int (*handler)(void *), void *arg, char *name)
d655 1
a655 1
				       mg_intr, sc, &sc->sc_dev);
@


1.11
log
@just wate that debug altogether
@
text
@d1 1
a1 1
/*	$OpenBSD: mongoose.c,v 1.10 2003/04/08 20:37:39 miod Exp $	*/
d241 1
a241 1
	sprintf (buf, "isa irq %d", irq);
@


1.10
log
@Make dmesg prettier if attachment fails and no option DEBUG
@
text
@d1 1
a1 1
/*	$OpenBSD: mongoose.c,v 1.9 2002/03/14 01:26:31 millert Exp $	*/
a267 2
#else
		printf("\n");
a276 2
#else
		printf("\n");
@


1.9
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: mongoose.c,v 1.8 2002/02/05 04:26:06 mickey Exp $	*/
d268 2
d279 2
@


1.8
log
@use splraise() when calling handlers; from fredette@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mongoose.c,v 1.7 2000/08/15 19:42:56 mickey Exp $	*/
d170 1
a170 1
	int (*iv_handler) __P((void *arg));
d209 3
a211 3
int	mgmatch __P((struct device *, void *, void *));
void	mgattach __P((struct device *, struct device *, void *));
int	mgprint __P((void *aux, const char *pnp));
d254 1
a254 1
	int (*handler) __P((void *)), void *arg, char *name)
@


1.7
log
@interrupt guts
@
text
@d1 1
a1 1
/*	$OpenBSD: mongoose.c,v 1.6 2000/02/09 06:01:20 mickey Exp $	*/
d338 1
a338 1
	s = splx(iv->iv_pri);
@


1.7.8.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: mongoose.c,v 1.7 2000/08/15 19:42:56 mickey Exp $	*/
d170 1
a170 1
	int (*iv_handler)(void *arg);
d209 3
a211 3
int	mgmatch(struct device *, void *, void *);
void	mgattach(struct device *, struct device *, void *);
int	mgprint(void *aux, const char *pnp);
d254 1
a254 1
	int (*handler)(void *), void *arg, char *name)
d338 1
a338 1
	s = splraise(iv->iv_pri);
@


1.7.8.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d241 1
a241 1
	snprintf(buf, sizeof buf, "isa irq %d", irq);
@


1.6
log
@oh, show me the way to the next little g^hendian {,e}isa card; 3com's happy
@
text
@d1 1
a1 1
/*	$OpenBSD: mongoose.c,v 1.5 2000/01/28 20:20:47 mickey Exp $	*/
d67 1
d168 12
d189 1
d192 3
d245 7
d253 2
a254 2
mg_intr_establish(void *v, int irq, int type, int level,
	int (*fn) __P((void *)), void *arg, char *name)
d256 24
a279 1
	void *cookie = "cookie";
d281 4
d286 15
a300 1
	return cookie;
d306 4
d311 2
a312 1
}
d314 6
a319 4
void
mg_isa_attach_hook(struct device *parent, struct device *self,
	struct isabus_attach_args *iba)
{
d321 1
d333 9
a630 2
#if 0
	/* TODO: attach ISA */
d636 5
a640 7
	/* inherit the bus tags for eisa from the mainbus */
	sc->sc_iiot = *ca->ca_iot;
	sc->sc_imemt = *ca->ca_iot;
	sc->sc_iiot.hbt_cookie = sc->sc_imemt.hbt_cookie = sc;
	sc->sc_iiot.hbt_map = mg_isa_iomap;
	sc->sc_imemt.hbt_map = mg_isa_memmap;
	sc->sc_imemt.hbt_unmap = mg_isa_memunmap;
a650 1
#endif
@


1.6.2.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: mongoose.c,v 1.7 2000/08/15 19:42:56 mickey Exp $	*/
a66 1
#define	MONGOOSE_NINTS		16
a166 12
struct hppa_isa_iv {
	const char *iv_name;
	int (*iv_handler) __P((void *arg));
	void *iv_arg;
	int iv_pri;

	struct evcnt iv_evcnt;
	/* don't do sharing, we won't have many slots anyway
	struct hppa_isa_iv *iv_next;
	*/
};

a175 1
	/* interrupts section */
a177 3
	struct hppa_isa_iv sc_iv[MONGOOSE_NINTS];

	/* isa/eisa bus guts */
a227 7
void
mg_isa_attach_hook(struct device *parent, struct device *self,
	struct isabus_attach_args *iba)
{

}

d229 2
a230 2
mg_intr_establish(void *v, int irq, int type, int pri,
	int (*handler) __P((void *)), void *arg, char *name)
d232 1
a232 24
	struct hppa_isa_iv *iv;
	struct mongoose_softc *sc = v;
	volatile u_int8_t *imr, *pic;

	if (!sc || irq < 0 || irq >= MONGOOSE_NINTS ||
	    (0 <= irq && irq < MONGOOSE_NINTS && sc->sc_iv[irq].iv_handler))
		return NULL;

	if (type != IST_LEVEL && type != IST_EDGE) {
#ifdef DEBUG
		printf("%s: bad interrupt level (%d)\n", sc->sc_dev.dv_xname,
		    type);
#endif
		return NULL;
	}

	iv = &sc->sc_iv[irq];
	if (iv->iv_handler) {
#ifdef DEBUG
		printf("%s: irq %d already established\n", sc->sc_dev.dv_xname,
		    irq);
#endif
		return NULL;
	}
a233 4
	iv->iv_name = name;
	iv->iv_pri = pri;
	iv->iv_handler = handler;
	iv->iv_arg = arg;
d235 1
a235 15
	if (irq < 8) {
		imr = &sc->sc_ctrl->imr0;
		pic = &sc->sc_ctrl->pic0;
	} else {
		imr = &sc->sc_ctrl->imr1;
		pic = &sc->sc_ctrl->pic1;
		irq -= 8;
	}

	*imr |= 1 << irq;
	*pic |= (type == IST_LEVEL) << irq;

	/* TODO: ack it? */

	return iv;
a240 4
	struct hppa_isa_iv *iv = cookie;
	struct mongoose_softc *sc = v;
 	int irq = iv - sc->sc_iv;
 	volatile u_int8_t *imr;
d242 1
a242 2
	if (!sc || !cookie)
		return;
d244 4
a247 6
	if (irq < 8)
		imr = &sc->sc_ctrl->imr0;
	else
		imr = &sc->sc_ctrl->imr1;
	*imr &= ~(1 << irq);
	/* TODO: ack it? */
a248 1
	iv->iv_handler = NULL;
a259 9
	struct mongoose_softc *sc = v;
	struct hppa_isa_iv *iv;
	int s, irq = 0;

	iv = &sc->sc_iv[irq];
	s = splx(iv->iv_pri);
	(iv->iv_handler)(iv->iv_arg);
	splx(s);

d549 2
d556 7
a562 5
	/* inherit the bus tags for isa from the eisa */
	bt = &sc->sc_imemt;
	bcopy(&sc->sc_ememt, bt, sizeof(*bt));
	bt = &sc->sc_iiot;
	bcopy(&sc->sc_eiot, bt, sizeof(*bt));
d573 1
@


1.6.2.2
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d338 1
a338 1
	s = splraise(iv->iv_pri);
@


1.6.2.3
log
@Merge in -current from about a week ago
@
text
@d170 1
a170 1
	int (*iv_handler)(void *arg);
d209 3
a211 3
int	mgmatch(struct device *, void *, void *);
void	mgattach(struct device *, struct device *, void *);
int	mgprint(void *aux, const char *pnp);
d254 1
a254 1
	int (*handler)(void *), void *arg, char *name)
@


1.6.2.4
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: mongoose.c,v 1.6.2.3 2002/03/28 10:07:19 niklas Exp $	*/
d241 1
a241 1
	snprintf(buf, sizeof buf, "isa irq %d", irq);
@


1.6.2.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d254 1
a254 1
	int (*handler)(void *), void *arg, const char *name)
d537 1
a537 2
	    (ca->ca_type.iodc_sv_model != HPPA_BHA_EISA &&
	     ca->ca_type.iodc_sv_model != HPPA_BHA_WEISA))
d540 2
a541 2
	if (bus_space_map(ca->ca_iot, ca->ca_hpa + MONGOOSE_MONGOOSE,
	    IOMOD_HPASIZE, 0, &ioh))
d655 1
a655 1
				       mg_intr, sc, sc->sc_dev.dv_xname);
@


1.6.2.6
log
@Merge with the trunk
@
text
@d4 1
a4 1
 * Copyright (c) 1998-2003 Michael Shalayeff
d15 5
@


1.5
log
@determine eisa motherboard id;
add more daughter devices definitions;
enable eisa bus arbitration;
@
text
@d1 1
a1 1
/*	$OpenBSD: mongoose.c,v 1.4 1999/11/26 05:04:42 mickey Exp $	*/
a34 1

d194 1
d204 83
a286 29
/* IC guts */
int mgprint __P((void *aux, const char *pnp));
void	mg_eisa_attach_hook __P((struct device *, struct device *,
				 struct eisabus_attach_args *));
int	mg_intr_map __P((void *, u_int, eisa_intr_handle_t *));
const char *mg_intr_string __P((void *, int));
void	*mg_intr_establish __P((void *, int, int, int,
				int (*) __P((void *)), void *, char *));
void	mg_intr_disestablish __P((void *, void *));

void	mg_isa_attach_hook __P((struct device *, struct device *,
				struct isabus_attach_args *));
int	mg_intr_check __P((void *, int, int));
int	mg_intr __P((void *v));

/* BUS guts */
int  mg_eisa_iomap __P((void *v, bus_addr_t addr, bus_size_t size,
			int cacheable, bus_space_handle_t *bshp));
int  mg_eisa_memmap __P((void *v, bus_addr_t addr, bus_size_t size,
			 int cacheable, bus_space_handle_t *bshp));
void mg_eisa_memunmap __P((void *v, bus_space_handle_t bsh,
			   bus_size_t size));

int  mg_isa_iomap __P((void *v, bus_addr_t addr, bus_size_t size,
		       int cacheable, bus_space_handle_t *bshp));
int  mg_isa_memmap __P((void *v, bus_addr_t addr, bus_size_t size,
			int cacheable, bus_space_handle_t *bshp));
void mg_isa_memunmap __P((void *v, bus_space_handle_t bsh,
			  bus_size_t size));
d288 155
a442 1
/* TODO: DMA guts */
d477 1
d526 15
a540 6
	sc->sc_eiot = *ca->ca_iot;
	sc->sc_ememt = *ca->ca_iot;
	sc->sc_eiot.hbt_cookie = sc->sc_ememt.hbt_cookie = sc;
	sc->sc_eiot.hbt_map = mg_eisa_iomap;
	sc->sc_ememt.hbt_map = mg_eisa_memmap;
	sc->sc_ememt.hbt_unmap = mg_eisa_memunmap;
d574 1
a592 114

void
mg_eisa_attach_hook(parent, self, mg)
	struct device *parent;
	struct device *self;
	struct eisabus_attach_args *mg;
{
}

int
mg_intr_map(v, irq, ehp)
	void *v;
	u_int irq;
	eisa_intr_handle_t *ehp;
{
	*ehp = irq;
	return 0;
}

const char *
mg_intr_string(v, irq)
	void *v;
	int irq;
{
	static char buf[16];

	sprintf (buf, "isa irq %d", irq);
	return buf;
}

void *
mg_intr_establish(v, irq, type, level, fn, arg, name)
	void *v;
	int irq;
	int type;
	int level;
	int (*fn) __P((void *));
	void *arg;
	char *name;
{
	void *cookie = "cookie";

	
	return cookie;
}

void
mg_intr_disestablish(v, cookie)
	void *v;
	void *cookie;
{

}

void
mg_isa_attach_hook(parent, self, iba)
	struct device *parent;
	struct device *self;
	struct isabus_attach_args *iba;
{

}

int
mg_intr_check(v, irq, type)
	void *v;
	int irq;
	int type;
{
	return 0;
}

int
mg_intr(v)
	void *v;
{
	return 0;
}

int
mg_eisa_iomap(v, addr, size, cacheable, bshp)
	void *v;
	bus_addr_t addr;
	bus_size_t size;
	int cacheable;
	bus_space_handle_t *bshp;
{
	struct mongoose_softc *sc = v;

	return (sc->sc_bt->hbt_map)(NULL, sc->sc_iomap + addr, size,
				    cacheable, bshp);
}

int
mg_eisa_memmap(v, addr, size, cacheable, bshp)
	void *v;
	bus_addr_t addr;
	bus_size_t size;
	int cacheable;
	bus_space_handle_t *bshp;
{
	/* TODO: eisa memory map */
	return -1;
}

void
mg_eisa_memunmap(v, bsh, size)
	void *v;
	bus_space_handle_t bsh;
	bus_size_t size;
{
	/* TODO: eisa memory unmap */
}

@


1.4
log
@new bus, some things i was not right
@
text
@d1 1
a1 1
/*	$OpenBSD: mongoose.c,v 1.3 1999/09/10 18:03:46 mickey Exp $	*/
d48 1
d67 99
d173 2
a174 1
	struct mongoose_regs *sc_regs;
d181 1
d184 1
d270 1
d273 1
d275 1
a275 1
	sc->sc_iomap = ca->ca_hpa + MONGOOSE_IOMAP;
d277 1
a277 1
	/* XXX should we reset the chip here? */
d279 24
a302 3
	/* attach interrupt */
	sc->sc_ih = cpu_intr_establish(IPL_HIGH, ca->ca_irq,
				       mg_intr, sc, &sc->sc_dev);
d304 1
a304 2
	/* XXX determine eisa board id (how?) */
	printf (": rev %d, %d MHz\n", sc->sc_regs->version,
a322 1
	/* TODO: DMA tags */
d327 1
a327 1
	ea.mongoose_eisa.eba_dmat = NULL;
d351 1
a351 1
	ea.mongoose_isa.iba_dmat = NULL;
d356 4
d463 1
a463 1
	return (sc->sc_bt->hbt_map)(v, sc->sc_iomap + addr, size,
@


1.3
log
@keep the name short since evcnt* stuff is limitted to 8 chars total
@
text
@d1 1
a1 1
/*	$OpenBSD: mongoose.c,v 1.2 1999/08/16 02:53:50 mickey Exp $	*/
d17 1
a17 1
 *	This product includes software developed by Michael Shalayeff.
d24 8
a31 7
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d34 2
d72 1
d74 1
a74 1
	u_int8_t *sc_intack;
d78 4
d101 1
d103 29
a131 12
void	mongoose_eisa_attach_hook __P((struct device *, struct device *,
				  struct eisabus_attach_args *));
int	mongoose_intr_map __P((void *, u_int, eisa_intr_handle_t *));
const char *mongoose_intr_string __P((void *, int));
void	*mongoose_intr_establish __P((void *, int, int, int,
				 int (*) __P((void *)), void *, char *));
void	mongoose_intr_disestablish __P((void *, void *));

void	mongoose_isa_attach_hook __P((struct device *, struct device *,
				 struct isabus_attach_args *));
int	mongoose_intr_check __P((void *, int, int));
int	mongoose_intr __P((void *v));
d168 1
d170 1
d176 1
a176 1
				       mongoose_intr, sc, &sc->sc_dev);
d178 1
a178 1
	/* XXX determine HP eisa board id (how?) */
d186 14
a199 5
	sc->sc_ec.ec_attach_hook = mongoose_eisa_attach_hook;
	sc->sc_ec.ec_intr_establish = mongoose_intr_establish;
	sc->sc_ec.ec_intr_disestablish = mongoose_intr_disestablish;
	sc->sc_ec.ec_intr_string = mongoose_intr_string;
	sc->sc_ec.ec_intr_map = mongoose_intr_map;
d201 2
a202 2
	ea.mongoose_eisa.eba_iot = ea.mongoose_eisa.eba_memt =
		HPPA_BUS_TAG_SET_BASE(ca->ca_iot,ca->ca_hpa); 
d207 2
a208 1
	/* attach ISA */
d210 13
a222 4
	sc->sc_ic.ic_attach_hook = mongoose_isa_attach_hook;
	sc->sc_ic.ic_intr_establish = mongoose_intr_establish;
	sc->sc_ic.ic_intr_disestablish = mongoose_intr_disestablish;
	sc->sc_ic.ic_intr_check = mongoose_intr_check;
d224 2
a225 2
	ea.mongoose_isa.iba_iot = ea.mongoose_isa.iba_memt =
		HPPA_BUS_TAG_SET_BASE(ca->ca_iot, ca->ca_hpa); 
d231 1
d248 1
a248 1
mongoose_eisa_attach_hook(parent, self, mg)
d256 1
a256 1
mongoose_intr_map(v, irq, ehp)
d266 1
a266 1
mongoose_intr_string(v, irq)
d277 1
a277 1
mongoose_intr_establish(v, irq, type, level, fn, arg, name)
d293 1
a293 1
mongoose_intr_disestablish(v, cookie)
d301 1
a301 1
mongoose_isa_attach_hook(parent, self, iba)
d310 1
a310 1
mongoose_intr_check(v, irq, type)
d319 1
a319 1
mongoose_intr(v)
d324 36
@


1.2
log
@use structures to overlay registers in memory, not offsets, also interrupt stuff (see above)
@
text
@d1 1
a1 1
/*	$OpenBSD: mongoose.c,v 1.1 1999/04/20 20:21:51 mickey Exp $	*/
d90 1
a90 1
	NULL, "mongoose", DV_DULL
@


1.1
log
@call any vegetable, call it by name
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d52 13
d69 2
a70 5
	int sc_mod;
	bus_addr_t sc_hpa;		/* HPA */
	bus_space_tag_t sc_iot;		/* IO tag */
	bus_space_handle_t sc_ioha;	/* EISA Adapter IO handle */
	bus_space_handle_t sc_iohi;	/* Intr ACK register */
a81 10
/* EISA Bus Adapter registers definitions */
#define	MONGOOSE_MONGOOSE	0x10000
#define	MONGOOSE_VERSION	0
#define	MONGOOSE_LOCK	1
#define	MONGOOSE_LIOWAIT	2
#define	MONGOOSE_SPEED	3
#define	MONGOOSE_INTACK	0x1f000
#define	MONGOOSE_INTACK_LEN	1
#define	MONGOOSE_IOMAP	0x100000

d90 1
a90 1
	NULL, "mg", DV_DULL
a140 1
	u_int ver;
d142 1
a142 10
	sc->sc_mod = ca->ca_mod;
	sc->sc_iot = ca->ca_iot;
	sc->sc_hpa = ca->ca_hpa;
	if (bus_space_map(sc->sc_iot, sc->sc_hpa + MONGOOSE_MONGOOSE,
			  IOMOD_HPASIZE, 0, &sc->sc_ioha))
		panic("mgattach: unable to map adapter bus space");

	if (bus_space_map(sc->sc_iot, sc->sc_hpa + MONGOOSE_INTACK,
			  MONGOOSE_INTACK_LEN, 0, &sc->sc_iohi))
		panic("mgattach: unable to map intack bus space");
d148 1
a148 1
				       mongoose_intr, sc, "eisa");
d151 4
a154 8
	ver = bus_space_read_1(sc->sc_iot, sc->sc_ioha, MONGOOSE_VERSION);
	printf (": rev %d, %d MHz\n", ver & 0xff,
		(bus_space_read_1(sc->sc_iot, sc->sc_ioha, MONGOOSE_SPEED)? 33:25));

	/* disable isa wait states */
	bus_space_write_1(sc->sc_iot, sc->sc_ioha, MONGOOSE_LIOWAIT, 1);
	/* bus unlock */
	bus_space_write_1(sc->sc_iot, sc->sc_ioha, MONGOOSE_LOCK, 1);
d164 3
a166 2
	ea.mongoose_eisa.eba_iot = HPPA_BUS_TAG_SET_BASE(sc->sc_iot,sc->sc_hpa);
	ea.mongoose_eisa.eba_memt = ca->ca_iot;
d177 5
a181 2
	ea.mongoose_isa.iba_iot = HPPA_BUS_TAG_SET_BASE(sc->sc_iot, sc->sc_hpa);
	ea.mongoose_isa.iba_memt = ca->ca_iot;
a204 19
#ifdef MONGOOSE_DEBUG
	register struct mongoose_softc *sc = (struct mongoose_softc *)self;
	struct pdc_memmap pdc_memmap;
	struct device_path dp;
	register int i;

	for (i = 0; i < 16; i++) {
		dp.dp_bc[0] = dp.dp_bc[1] = dp.dp_bc[2] = dp.dp_bc[3] = -1;
		dp.dp_bc[4] = sc->sc_mod;
		dp.dp_bc[5] = 0;
		dp.dp_mod = i;

		if (pdc_call((iodcio_t)pdc, 0, PDC_MEMMAP,
			     PDC_MEMMAP_HPA, &pdc_memmap, &dp) < 0)
			continue;

		printf ("eisa%d: hpa %x\n", i, pdc_memmap.hpa);
	}
#endif
@

