head	1.31;
access;
symbols
	OPENBSD_6_0:1.31.0.10
	OPENBSD_6_0_BASE:1.31
	OPENBSD_5_9:1.31.0.6
	OPENBSD_5_9_BASE:1.31
	OPENBSD_5_8:1.31.0.8
	OPENBSD_5_8_BASE:1.31
	OPENBSD_5_7:1.31.0.2
	OPENBSD_5_7_BASE:1.31
	OPENBSD_5_6:1.31.0.4
	OPENBSD_5_6_BASE:1.31
	OPENBSD_5_5:1.30.0.16
	OPENBSD_5_5_BASE:1.30
	OPENBSD_5_4:1.30.0.12
	OPENBSD_5_4_BASE:1.30
	OPENBSD_5_3:1.30.0.10
	OPENBSD_5_3_BASE:1.30
	OPENBSD_5_2:1.30.0.8
	OPENBSD_5_2_BASE:1.30
	OPENBSD_5_1_BASE:1.30
	OPENBSD_5_1:1.30.0.6
	OPENBSD_5_0:1.30.0.4
	OPENBSD_5_0_BASE:1.30
	OPENBSD_4_9:1.30.0.2
	OPENBSD_4_9_BASE:1.30
	OPENBSD_4_8:1.27.0.2
	OPENBSD_4_8_BASE:1.27
	OPENBSD_4_7:1.26.0.2
	OPENBSD_4_7_BASE:1.26
	OPENBSD_4_6:1.25.0.4
	OPENBSD_4_6_BASE:1.25
	OPENBSD_4_5:1.24.0.4
	OPENBSD_4_5_BASE:1.24
	OPENBSD_4_4:1.24.0.2
	OPENBSD_4_4_BASE:1.24
	OPENBSD_4_3:1.23.0.2
	OPENBSD_4_3_BASE:1.23
	OPENBSD_4_2:1.22.0.2
	OPENBSD_4_2_BASE:1.22
	OPENBSD_4_1:1.20.0.2
	OPENBSD_4_1_BASE:1.20
	OPENBSD_4_0:1.17.0.2
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.16.0.2
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.15.0.4
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.15.0.2
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.12.0.2
	OPENBSD_3_6_BASE:1.12
	SMP_SYNC_A:1.5
	SMP_SYNC_B:1.5
	OPENBSD_3_5:1.5.0.4
	OPENBSD_3_5_BASE:1.5
	SMP:1.5.0.2;
locks; strict;
comment	@ * @;


1.31
date	2014.03.29.18.09.29;	author guenther;	state Exp;
branches;
next	1.30;

1.30
date	2011.01.01.15.20.19;	author kettenis;	state Exp;
branches;
next	1.29;

1.29
date	2010.12.04.17.06.31;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2010.09.22.02.28.37;	author jsg;	state Exp;
branches;
next	1.27;

1.27
date	2010.04.29.13.48.29;	author jsing;	state Exp;
branches;
next	1.26;

1.26
date	2009.08.22.02.54.50;	author mk;	state Exp;
branches;
next	1.25;

1.25
date	2009.03.30.21.24.57;	author kettenis;	state Exp;
branches;
next	1.24;

1.24
date	2008.07.23.19.14.13;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2007.08.28.21.19.17;	author kettenis;	state Exp;
branches;
next	1.22;

1.22
date	2007.05.23.18.07.19;	author kettenis;	state Exp;
branches;
next	1.21;

1.21
date	2007.05.18.16.00.17;	author kettenis;	state Exp;
branches;
next	1.20;

1.20
date	2007.01.11.21.59.52;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2006.12.18.18.49.46;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2006.12.14.17.36.12;	author kettenis;	state Exp;
branches;
next	1.17;

1.17
date	2006.03.13.20.10.49;	author brad;	state Exp;
branches;
next	1.16;

1.16
date	2005.09.06.23.53.38;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	2004.09.18.07.02.23;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	2004.09.15.21.30.21;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	2004.09.15.20.11.28;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	2004.08.29.00.26.12;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	2004.08.06.20.29.47;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	2004.07.24.15.04.35;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	2004.07.21.19.54.08;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	2004.06.30.15.25.36;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	2004.06.17.06.06.18;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	2004.06.17.05.40.32;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	2004.02.13.20.39.31;	author mickey;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2003.12.23.12.07.11;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	2003.12.20.21.49.04;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2003.10.30.19.25.12;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	2003.09.29.19.30.23;	author mickey;	state Exp;
branches;
next	;

1.5.2.1
date	2004.02.19.10.48.39;	author niklas;	state Exp;
branches;
next	1.5.2.2;

1.5.2.2
date	2004.06.05.23.10.47;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.31
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@/*	$OpenBSD: dino.c,v 1.30 2011/01/01 15:20:19 kettenis Exp $	*/

/*
 * Copyright (c) 2003-2005 Michael Shalayeff
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR OR HIS RELATIVES BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

#include "cardbus.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/reboot.h>
#include <sys/malloc.h>
#include <sys/extent.h>

#include <machine/iomod.h>
#include <machine/autoconf.h>

#include <hppa/dev/cpudevs.h>

#if NCARDBUS > 0
#include <dev/cardbus/rbus.h>
#endif

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>

#include <machine/pdc.h>
#include <dev/cons.h>

#define	DINO_MEM_CHUNK	0x800000
#define	DINO_MEM_WINDOW	(2 * DINO_MEM_CHUNK)

struct dino_regs {
	u_int32_t	pad0;		/* 0x000 */
	u_int32_t	iar0;		/* 0x004 rw intr addr reg 0 */
	u_int32_t	iodc;		/* 0x008 rw iodc data/addr */
	u_int32_t	irr0;		/* 0x00c r  intr req reg 0 */
	u_int32_t	iar1;		/* 0x010 rw intr addr reg 1 */
	u_int32_t	irr1;		/* 0x014 r  intr req reg 1 */
	u_int32_t	imr;		/* 0x018 rw intr mask reg */
	u_int32_t	ipr;		/* 0x01c rw intr pending reg */
	u_int32_t	toc_addr;	/* 0x020 rw TOC addr reg */
	u_int32_t	icr;		/* 0x024 rw intr control reg */
	u_int32_t	ilr;		/* 0x028 r  intr level reg */
	u_int32_t	pad1;		/* 0x02c */
	u_int32_t	io_command;	/* 0x030  w command register */
	u_int32_t	io_status;	/* 0x034 r  status register */
	u_int32_t	io_control;	/* 0x038 rw control register */
	u_int32_t	pad2;		/* 0x03c AUX registers follow */
	u_int32_t	io_gsc_err_addr;/* 0x040 GSC error address */
	u_int32_t	io_err_info;	/* 0x044 error info register */
	u_int32_t	io_pci_err_addr;/* 0x048 PCI error address */
	u_int32_t	pad3[4];	/* 0x04c */
	u_int32_t	io_fbb_en;	/* 0x05c fast back2back enable reg */
	u_int32_t	io_addr_en;	/* 0x060 address enable reg */
	u_int32_t	pci_addr;	/* 0x064 PCI conf/io/mem addr reg */
	u_int32_t	pci_conf_data;	/* 0x068 PCI conf data reg */
	u_int32_t	pci_io_data;	/* 0x06c PCI io data reg */
	u_int32_t	pci_mem_data;	/* 0x070 PCI memory data reg */
	u_int32_t	pad4[0x740/4];	/* 0x074 */
	u_int32_t	gsc2x_config;	/* 0x7b4 GSC2X config reg */
	u_int32_t	pad5[0x48/4];	/* 0x7b8: BSRS registers follow */
	u_int32_t	gmask;		/* 0x800 GSC arbitration mask */
	u_int32_t	pamr;		/* 0x804 PCI arbitration mask */
	u_int32_t	papr;		/* 0x808 PCI arbitration priority */
	u_int32_t	damode;		/* 0x80c PCI arbitration mode */
	u_int32_t	pcicmd;		/* 0x810 PCI command register */
	u_int32_t	pcists;		/* 0x814 PCI status register */
	u_int32_t	pad6;		/* 0x818 */
	u_int32_t	mltim;		/* 0x81c PCI master latency timer */
	u_int32_t	brdg_feat;	/* 0x820 PCI bridge feature enable */
	u_int32_t	pciror;		/* 0x824 PCI read optimization reg */
	u_int32_t	pciwor;		/* 0x828 PCI write optimization reg */
	u_int32_t	pad7;		/* 0x82c */
	u_int32_t	tltim;		/* 0x830 PCI target latency reg */
};

struct dino_softc {
	struct  device sc_dv;

	int sc_ver;
	void *sc_ih;
	u_int32_t sc_imr;
	bus_space_tag_t sc_bt;
	bus_space_handle_t sc_bh;
	bus_dma_tag_t sc_dmat;
	volatile struct dino_regs *sc_regs;

	struct hppa_pci_chipset_tag sc_pc;
	struct hppa_bus_space_tag sc_iot;
	char sc_ioexname[20];
	struct extent *sc_ioex;
	struct hppa_bus_space_tag sc_memt;
	char sc_memexname[20];
	struct extent *sc_memex;
	struct hppa_bus_dma_tag sc_dmatag;

	u_int32_t io_shadow;
};

int	dinomatch(struct device *, void *, void *);
void	dinoattach(struct device *, struct device *, void *);
int	dino_intr(void *);

struct cfattach dino_ca = {
	sizeof(struct dino_softc), dinomatch, dinoattach
};

struct cfdriver dino_cd = {
	NULL, "dino", DV_DULL
};

int
dinomatch(parent, cfdata, aux)
	struct device *parent;
	void *cfdata;
	void *aux;
{
	struct confargs *ca = aux;
	/* struct cfdata *cf = cfdata; */

	/* there will be only one */
	if (ca->ca_type.iodc_type != HPPA_TYPE_BRIDGE ||
	    ca->ca_type.iodc_sv_model != HPPA_BRIDGE_DINO)
		return (0);

	/* do not match on the elroy family */
	if (ca->ca_type.iodc_model == 0x78)
		return (0);

	return (1);
}

void	dino_attach_hook(struct device *, struct device *,
	    struct pcibus_attach_args *);
int	dino_maxdevs(void *, int);
pcitag_t dino_make_tag(void *, int, int, int);
void	dino_decompose_tag(void *, pcitag_t, int *, int *, int *);
int	dino_conf_size(void *, pcitag_t);
pcireg_t dino_conf_read(void *, pcitag_t, int);
void	dino_conf_write(void *, pcitag_t, int, pcireg_t);
int	dino_intr_map(struct pci_attach_args *, pci_intr_handle_t *);
const char *dino_intr_string(void *, pci_intr_handle_t);
void *	dino_intr_establish(void *, pci_intr_handle_t, int, int (*)(void *),
	    void *, const char *);
void	dino_intr_disestablish(void *, void *);
int	dino_iomap(void *, bus_addr_t, bus_size_t, int, bus_space_handle_t *);
int	dino_memmap(void *, bus_addr_t, bus_size_t, int, bus_space_handle_t *);
int	dino_subregion(void *, bus_space_handle_t, bus_size_t, bus_size_t,
	    bus_space_handle_t *);
int	dino_ioalloc(void *, bus_addr_t, bus_addr_t, bus_size_t, bus_size_t,
	    bus_size_t, int, bus_addr_t *, bus_space_handle_t *);
int	dino_memalloc(void *, bus_addr_t, bus_addr_t, bus_size_t, bus_size_t,
	    bus_size_t, int, bus_addr_t *, bus_space_handle_t *);
void	dino_unmap(void *, bus_space_handle_t, bus_size_t);
void	dino_free(void *, bus_space_handle_t, bus_size_t);
void	dino_barrier(void *, bus_space_handle_t, bus_size_t, bus_size_t, int);
void *	dino_alloc_parent(struct device *, struct pci_attach_args *, int);
void *	dino_vaddr(void *, bus_space_handle_t);
u_int8_t dino_r1(void *, bus_space_handle_t, bus_size_t);
u_int16_t dino_r2(void *, bus_space_handle_t, bus_size_t);
u_int32_t dino_r4(void *, bus_space_handle_t, bus_size_t);
u_int64_t dino_r8(void *, bus_space_handle_t, bus_size_t);
void	dino_w1(void *, bus_space_handle_t, bus_size_t, u_int8_t);
void	dino_w2(void *, bus_space_handle_t, bus_size_t, u_int16_t);
void	dino_w4(void *, bus_space_handle_t, bus_size_t, u_int32_t);
void	dino_w8(void *, bus_space_handle_t, bus_size_t, u_int64_t);
void	dino_rm_1(void *, bus_space_handle_t, bus_size_t, u_int8_t *,
	    bus_size_t);
void	dino_rm_2(void *, bus_space_handle_t, bus_size_t, u_int16_t *,
	    bus_size_t);
void	dino_rm_4(void *, bus_space_handle_t, bus_size_t, u_int32_t *,
	    bus_size_t);
void	dino_rm_8(void *, bus_space_handle_t, bus_size_t, u_int64_t *,
	    bus_size_t);
void	dino_wm_1(void *, bus_space_handle_t, bus_size_t, const u_int8_t *,
	    bus_size_t);
void	dino_wm_2(void *, bus_space_handle_t, bus_size_t, const u_int16_t *,
	    bus_size_t);
void	dino_wm_4(void *, bus_space_handle_t, bus_size_t, const u_int32_t *,
	    bus_size_t);
void	dino_wm_8(void *, bus_space_handle_t, bus_size_t, const u_int64_t *,
	    bus_size_t);
void	dino_sm_1(void *, bus_space_handle_t, bus_size_t, u_int8_t, bus_size_t);
void	dino_sm_2(void *, bus_space_handle_t, bus_size_t, u_int16_t,
	    bus_size_t);
void	dino_sm_4(void *, bus_space_handle_t, bus_size_t, u_int32_t,
	    bus_size_t);
void	dino_sm_8(void *, bus_space_handle_t, bus_size_t, u_int64_t,
	    bus_size_t);
void	dino_rrm_2(void *, bus_space_handle_t, bus_size_t, u_int8_t *,
	    bus_size_t);
void	dino_rrm_4(void *, bus_space_handle_t, bus_size_t, u_int8_t *,
	    bus_size_t);
void	dino_rrm_8(void *, bus_space_handle_t, bus_size_t, u_int8_t *,
	    bus_size_t);
void	dino_wrm_2(void *, bus_space_handle_t, bus_size_t, const u_int8_t *,
	    bus_size_t);
void	dino_wrm_4(void *, bus_space_handle_t, bus_size_t, const u_int8_t *,
	    bus_size_t);
void	dino_wrm_8(void *, bus_space_handle_t, bus_size_t, const u_int8_t *,
	    bus_size_t);
void	dino_rr_1(void *, bus_space_handle_t, bus_size_t, u_int8_t *,
	    bus_size_t);
void	dino_rr_2(void *, bus_space_handle_t, bus_size_t, u_int16_t *,
	    bus_size_t);
void	dino_rr_4(void *, bus_space_handle_t, bus_size_t, u_int32_t *,
	    bus_size_t);
void	dino_rr_8(void *, bus_space_handle_t, bus_size_t, u_int64_t *,
	    bus_size_t);
void	dino_wr_1(void *, bus_space_handle_t, bus_size_t, const u_int8_t *,
	    bus_size_t);
void	dino_wr_2(void *, bus_space_handle_t, bus_size_t, const u_int16_t *,
	    bus_size_t);
void	dino_wr_4(void *, bus_space_handle_t, bus_size_t, const u_int32_t *,
	    bus_size_t);
void	dino_wr_8(void *, bus_space_handle_t, bus_size_t, const u_int64_t *,
	    bus_size_t);
void	dino_rrr_2(void *, bus_space_handle_t, bus_size_t, u_int8_t *,
	    bus_size_t);
void	dino_rrr_4(void *, bus_space_handle_t, bus_size_t, u_int8_t *,
	    bus_size_t);
void	dino_rrr_8(void *, bus_space_handle_t, bus_size_t, u_int8_t *,
	    bus_size_t);
void	dino_wrr_2(void *, bus_space_handle_t, bus_size_t, const u_int8_t *,
	    bus_size_t);
void	dino_wrr_4(void *, bus_space_handle_t, bus_size_t, const u_int8_t *,
	    bus_size_t);
void	dino_wrr_8(void *, bus_space_handle_t, bus_size_t, const u_int8_t *,
	    bus_size_t);
void	dino_sr_1(void *, bus_space_handle_t, bus_size_t, u_int8_t, bus_size_t);
void	dino_sr_2(void *, bus_space_handle_t, bus_size_t, u_int16_t,
	    bus_size_t);
void	dino_sr_4(void *, bus_space_handle_t, bus_size_t, u_int32_t,
	    bus_size_t);
void	dino_sr_8(void *, bus_space_handle_t, bus_size_t, u_int64_t,
	    bus_size_t);
void	dino_cp_1(void *, bus_space_handle_t, bus_size_t, bus_space_handle_t,
	    bus_size_t, bus_size_t);
void	dino_cp_2(void *, bus_space_handle_t, bus_size_t, bus_space_handle_t,
	    bus_size_t, bus_size_t);
void	dino_cp_4(void *, bus_space_handle_t, bus_size_t, bus_space_handle_t,
	    bus_size_t, bus_size_t);
void	dino_cp_8(void *, bus_space_handle_t, bus_size_t, bus_space_handle_t,
	    bus_size_t, bus_size_t);
int	dino_dmamap_create(void *, bus_size_t, int, bus_size_t, bus_size_t, int,
	    bus_dmamap_t *);
void	dino_dmamap_destroy(void *, bus_dmamap_t);
int	dino_dmamap_load(void *, bus_dmamap_t, void *, bus_size_t,
	    struct proc *, int);
int	dino_dmamap_load_mbuf(void *, bus_dmamap_t, struct mbuf *, int);
int	dino_dmamap_load_uio(void *, bus_dmamap_t, struct uio *, int);
int	dino_dmamap_load_raw(void *, bus_dmamap_t, bus_dma_segment_t *, int,
	    bus_size_t, int);
void	dino_dmamap_unload(void *, bus_dmamap_t);
void	dino_dmamap_sync(void *, bus_dmamap_t, bus_addr_t, bus_size_t, int);
int	dino_dmamem_alloc(void *, bus_size_t, bus_size_t, bus_size_t,
	    bus_dma_segment_t *, int, int *, int);
void	dino_dmamem_free(void *, bus_dma_segment_t *, int);
int	dino_dmamem_map(void *, bus_dma_segment_t *, int, size_t, caddr_t *,
	    int);
void	dino_dmamem_unmap(void *, caddr_t, size_t);
paddr_t	dino_dmamem_mmap(void *, bus_dma_segment_t *, int, off_t, int, int);
int	dinoprint(void *, const char *);
void	dino_clear_pdc_mappings(void *);

void
dino_attach_hook(struct device *parent, struct device *self,
    struct pcibus_attach_args *pba)
{

}

int
dino_maxdevs(void *v, int bus)
{
	return (32);
}

pcitag_t
dino_make_tag(void *v, int bus, int dev, int func)
{
	if (bus > 255 || dev > 31 || func > 7)
		panic("dino_make_tag: bad request");

	return ((bus << 16) | (dev << 11) | (func << 8));
}

void
dino_decompose_tag(void *v, pcitag_t tag, int *bus, int *dev, int *func)
{
	if (bus)
		*bus = (tag >> 16) & 0xff;
	if (dev)
		*dev = (tag >> 11) & 0x1f;
	if (func)
		*func= (tag >>  8) & 0x07;
}

int
dino_conf_size(void *v, pcitag_t tag)
{
	return PCI_CONFIG_SPACE_SIZE;
}

pcireg_t
dino_conf_read(void *v, pcitag_t tag, int reg)
{
	struct dino_softc *sc = v;
	volatile struct dino_regs *r = sc->sc_regs;
	pcireg_t data;
	u_int32_t pamr;

	/* fix arbitration errata by disabling all pci devs on config read */
	pamr = r->pamr;
	r->pamr = 0;

	r->pci_addr = tag | reg;
	data = r->pci_conf_data;

	/* restore arbitration */
	r->pamr = pamr;

	return (letoh32(data));
}

void
dino_conf_write(void *v, pcitag_t tag, int reg, pcireg_t data)
{
	struct dino_softc *sc = v;
	volatile struct dino_regs *r = sc->sc_regs;
	pcireg_t data1;
	u_int32_t pamr;

	/* fix arbitration errata by disabling all pci devs on config read */
	pamr = r->pamr;
	r->pamr = 0;

	r->pci_addr = tag | reg;
	r->pci_conf_data = htole32(data);

	/* fix coalescing config and io writes by interleaving w/ a read */
	r->pci_addr = tag | PCI_ID_REG;
	data1 = r->pci_conf_data;

	/* restore arbitration */
	r->pamr = pamr;
}

int
dino_intr_map(struct pci_attach_args *pa, pci_intr_handle_t *ihp)
{
	/* struct dino_softc *sc = v;
	volatile struct dino_regs *r = sc->sc_regs; */
	pci_chipset_tag_t pc = pa->pa_pc;
	pcitag_t tag = pa->pa_tag;
	pcireg_t reg;

	reg = pci_conf_read(pc, tag, PCI_INTERRUPT_REG);

	if (PCI_INTERRUPT_LINE(reg) == 0xff)
		return (1);
    
	*ihp = PCI_INTERRUPT_LINE(reg) + 1;
	return (0);
}

const char *
dino_intr_string(void *v, pci_intr_handle_t ih)
{
	static char buf[32];

	snprintf(buf, 32, "irq %ld", ih);

	return (buf);
}

void *
dino_intr_establish(void *v, pci_intr_handle_t ih,
    int pri, int (*handler)(void *), void *arg, const char *name)
{
	struct dino_softc *sc = v;
	volatile struct dino_regs *r = sc->sc_regs;
	void *iv;

	/* no mapping or bogus */
	if (ih <= 0 || ih > 11)
		return (NULL);

	if ((iv = cpu_intr_map(sc->sc_ih, pri, ih - 1, handler, arg, name))) {
		if (cold)
			sc->sc_imr |= (1 << (ih - 1));
		else
			r->imr = sc->sc_imr |= (1 << (ih - 1));
	}

	return (iv);
}

void
dino_intr_disestablish(void *v, void *cookie)
{
#if 0
	struct dino_softc *sc = v;
	volatile struct dino_regs *r = sc->sc_regs;

	r->imr &= ~(1 << (ih - 1));

	TODO cpu_intr_unmap(sc->sc_ih, cookie);
#endif
}

int
dino_iomap(void *v, bus_addr_t bpa, bus_size_t size,
    int flags, bus_space_handle_t *bshp)
{
	struct dino_softc *sc = v;
	int error;

	if ((error = extent_alloc_region(sc->sc_ioex, bpa, size, EX_NOWAIT)))
		return (error);

	if (bshp)
		*bshp = bpa;

	return (0);
}

int
dino_memmap(void *v, bus_addr_t bpa, bus_size_t size,
    int flags, bus_space_handle_t *bshp)
{
	struct dino_softc *sc = v;
	volatile struct dino_regs *r = sc->sc_regs;
	bus_addr_t sbpa;
	bus_space_handle_t bush;
	u_int32_t reg;
	int first = 1;
	int error;

	while (size != 0) {
		sbpa = bpa & 0xff800000;
		reg = sc->io_shadow;
		reg |= 1 << ((bpa >> 23) & 0x1f);
		if (reg & 0x80000001) {
#ifdef DEBUG
			panic("mapping outside the mem extent range");
#endif
			return (EINVAL);
		}
		/* map into the upper bus space, if not yet mapped this 8M */
		if (reg != sc->io_shadow) {

			if ((error = bus_space_map(sc->sc_bt, sbpa,
			    DINO_MEM_CHUNK, flags, &bush))) {
				return (error);
			}
			r->io_addr_en |= reg;
			sc->io_shadow = reg;

			if (first) {
				if (bshp)
					*bshp = bush + (bpa - sbpa);
			}
		} else {
			if (first) {
				if (bshp)
					*bshp = bpa;
			}
		}

		if (first) {
			size += (bpa - sbpa);
			first = 0;
		}
		
		if (size < DINO_MEM_CHUNK)
			size = 0;
		else {
			size -= DINO_MEM_CHUNK;
			bpa = sbpa + DINO_MEM_CHUNK;
		}
	}

	return (0);
}

int
dino_subregion(void *v, bus_space_handle_t bsh, bus_size_t offset,
    bus_size_t size, bus_space_handle_t *nbshp)
{
	*nbshp = bsh + offset;
	return (0);
}

int
dino_ioalloc(void *v, bus_addr_t rstart, bus_addr_t rend, bus_size_t size,
    bus_size_t align, bus_size_t boundary, int flags, bus_addr_t *addrp,
    bus_space_handle_t *bshp)
{
	struct dino_softc *sc = v;
	struct extent *ex = sc->sc_ioex;
	bus_addr_t bpa;
	int error;

	if (rstart < ex->ex_start || rend > ex->ex_end)
		panic("dino_ioalloc: bad region start/end");

	if ((error = extent_alloc_subregion(ex, rstart, rend, size,
	    align, 0, boundary, EX_NOWAIT, &bpa)))
		return (error);

	if (addrp)
		*addrp = bpa;
	if (bshp)
		*bshp = bpa;

	return (0);
}

int
dino_memalloc(void *v, bus_addr_t rstart, bus_addr_t rend, bus_size_t size,
    bus_size_t align, bus_size_t boundary, int flags, bus_addr_t *addrp,
    bus_space_handle_t *bshp)
{
	struct dino_softc *sc = v;
	volatile struct dino_regs *r = sc->sc_regs;
	u_int32_t reg;

	if (bus_space_alloc(sc->sc_bt, rstart, rend, size,
	    align, boundary, flags, addrp, bshp))
		return (ENOMEM);

	reg = sc->io_shadow;
	reg |= 1 << ((*addrp >> 23) & 0x1f);
	if (reg & 0x80000001) {
#ifdef DEBUG
		panic("mapping outside the mem extent range");
#endif
		return (EINVAL);
	}
	r->io_addr_en |= reg;
	sc->io_shadow = reg;

	return (0);
}

void
dino_unmap(void *v, bus_space_handle_t bsh, bus_size_t size)
{
	struct dino_softc *sc = v;
	struct extent *ex;
	bus_addr_t bpa;

	bpa = bsh;
	if (bsh & 0xf0000000) {
		/* TODO dino_unmap mem */
		/* TODO unmap from the upper bus if the last use in this 8M */
		return;
	} else
		ex = sc->sc_ioex;

	if (extent_free(ex, bpa, size, EX_NOWAIT))
		printf("dino_unmap: ps 0x%lx, size 0x%lx\n"
		    "dino_unmap: can't free region\n", bpa, size);
}

void
dino_free(void *v, bus_space_handle_t bh, bus_size_t size)
{
	/* should be enough */
	dino_unmap(v, bh, size);
}

void
dino_barrier(void *v, bus_space_handle_t h, bus_size_t o, bus_size_t l, int op)
{
	sync_caches();
}

#if NCARDBUS > 0
void *
dino_alloc_parent(struct device *self, struct pci_attach_args *pa, int io)
{
	struct dino_softc *sc = pa->pa_pc->_cookie;
	struct extent *ex;
	bus_space_tag_t tag;
	bus_addr_t start;
	bus_size_t size;

	if (io) {
		ex = sc->sc_ioex;
		tag = pa->pa_iot;
		start = 0xa000;
		size = 0x1000;
	} else {
		if (!sc->sc_memex) {
			bus_space_handle_t memh;
			bus_addr_t mem_start;

			if (dino_memalloc(sc, 0xf0800000, 0xff7fffff,
			    DINO_MEM_WINDOW, DINO_MEM_WINDOW, EX_NOBOUNDARY,
			    0, &mem_start, &memh))
				return (NULL);

			snprintf(sc->sc_memexname, sizeof(sc->sc_memexname),
			    "%s_mem", sc->sc_dv.dv_xname);
			if ((sc->sc_memex = extent_create(sc->sc_memexname,
			    mem_start, mem_start + DINO_MEM_WINDOW, M_DEVBUF,
			    NULL, 0, EX_NOWAIT | EX_MALLOCOK)) == NULL) {
				extent_destroy(sc->sc_ioex);
				bus_space_free(sc->sc_bt, memh,
				    DINO_MEM_WINDOW);
				return (NULL);
			}
		}
		ex = sc->sc_memex;
		tag = pa->pa_memt;
		start = ex->ex_start;
		size = DINO_MEM_CHUNK;
	}

	if (extent_alloc_subregion(ex, start, ex->ex_end, size, size, 0,
	    EX_NOBOUNDARY, EX_NOWAIT, &start))
		return (NULL);

	extent_free(ex, start, size, EX_NOWAIT);
	return rbus_new_root_share(tag, ex, start, size);
}
#endif

void *
dino_vaddr(void *v, bus_space_handle_t h)
{
	if (h & 0xf0000000)
		return ((void *)h);
	else
		return (NULL);
}

u_int8_t
dino_r1(void *v, bus_space_handle_t h, bus_size_t o)
{
	h += o;
	if (h & 0xf0000000)
		return *(volatile u_int8_t *)h;
	else {
		struct dino_softc *sc = v;
		volatile struct dino_regs *r = sc->sc_regs;
		u_int8_t data;

		r->pci_addr = h;
		data = *((volatile u_int8_t *)&r->pci_io_data + (h & 3));
		return (data);
	}
}

u_int16_t
dino_r2(void *v, bus_space_handle_t h, bus_size_t o)
{
	volatile u_int16_t *p;

	h += o;
	if (h & 0xf0000000)
		p = (volatile u_int16_t *)h;
	else {
		struct dino_softc *sc = v;
		volatile struct dino_regs *r = sc->sc_regs;

		r->pci_addr = h;
		p = (volatile u_int16_t *)&r->pci_io_data;
		if (h & 2)
			p++;
	}

	return (letoh16(*p));
}

u_int32_t
dino_r4(void *v, bus_space_handle_t h, bus_size_t o)
{
	u_int32_t data;

	h += o;
	if (h & 0xf0000000)
		data = *(volatile u_int32_t *)h;
	else {
		struct dino_softc *sc = v;
		volatile struct dino_regs *r = sc->sc_regs;

		r->pci_addr = h;
		data = r->pci_io_data;
	}

	return (letoh32(data));
}

u_int64_t
dino_r8(void *v, bus_space_handle_t h, bus_size_t o)
{
	u_int64_t data;

	h += o;
	if (h & 0xf0000000)
		data = *(volatile u_int64_t *)h;
	else
		panic("dino_r8: not implemented");

	return (letoh64(data));
}

void
dino_w1(void *v, bus_space_handle_t h, bus_size_t o, u_int8_t vv)
{
	h += o;
	if (h & 0xf0000000)
		*(volatile u_int8_t *)h = vv;
	else {
		struct dino_softc *sc = v;
		volatile struct dino_regs *r = sc->sc_regs;

		r->pci_addr = h;
		*((volatile u_int8_t *)&r->pci_io_data + (h & 3)) = vv;
	}
}

void
dino_w2(void *v, bus_space_handle_t h, bus_size_t o, u_int16_t vv)
{
	volatile u_int16_t *p;

	h += o;
	if (h & 0xf0000000)
		p = (volatile u_int16_t *)h;
	else {
		struct dino_softc *sc = v;
		volatile struct dino_regs *r = sc->sc_regs;

		r->pci_addr = h;
		p = (volatile u_int16_t *)&r->pci_io_data;
		if (h & 2)
			p++;
	}

	*p = htole16(vv);
}

void
dino_w4(void *v, bus_space_handle_t h, bus_size_t o, u_int32_t vv)
{
	h += o;
	vv = htole32(vv);
	if (h & 0xf0000000)
		*(volatile u_int32_t *)h = vv;
	else {
		struct dino_softc *sc = v;
		volatile struct dino_regs *r = sc->sc_regs;

		r->pci_addr = h;
		r->pci_io_data = vv;
	}
}

void
dino_w8(void *v, bus_space_handle_t h, bus_size_t o, u_int64_t vv)
{
	h += o;
	if (h & 0xf0000000)
		*(volatile u_int64_t *)h = htole64(vv);
	else
		panic("dino_w8: not implemented");
}


void
dino_rm_1(void *v, bus_space_handle_t h, bus_size_t o, u_int8_t *a, bus_size_t c)
{
	volatile u_int8_t *p;

	h += o;
	if (h & 0xf0000000)
		p = (volatile u_int8_t *)h;
	else {
		struct dino_softc *sc = v;
		volatile struct dino_regs *r = sc->sc_regs;

		r->pci_addr = h;
		p = (volatile u_int8_t *)&r->pci_io_data + (h & 3);
	}

	while (c--)
		*a++ = *p;
}

void
dino_rm_2(void *v, bus_space_handle_t h, bus_size_t o, u_int16_t *a, bus_size_t c)
{
	volatile u_int16_t *p;

	h += o;
	if (h & 0xf0000000)
		p = (volatile u_int16_t *)h;
	else {
		struct dino_softc *sc = v;
		volatile struct dino_regs *r = sc->sc_regs;

		r->pci_addr = h;
		p = (volatile u_int16_t *)&r->pci_io_data;
		if (h & 2)
			p++;
	}

	while (c--)
		*a++ = letoh16(*p);
}

void
dino_rm_4(void *v, bus_space_handle_t h, bus_size_t o, u_int32_t *a, bus_size_t c)
{
	volatile u_int32_t *p;

	h += o;
	if (h & 0xf0000000)
		p = (volatile u_int32_t *)h;
	else {
		struct dino_softc *sc = v;
		volatile struct dino_regs *r = sc->sc_regs;

		r->pci_addr = h;
		p = (volatile u_int32_t *)&r->pci_io_data;
	}

	while (c--)
		*a++ = letoh32(*p);
}

void
dino_rm_8(void *v, bus_space_handle_t h, bus_size_t o, u_int64_t *a, bus_size_t c)
{
	panic("dino_rm_8: not implemented");
}

void
dino_wm_1(void *v, bus_space_handle_t h, bus_size_t o, const u_int8_t *a, bus_size_t c)
{
	volatile u_int8_t *p;

	h += o;
	if (h & 0xf0000000)
		p = (volatile u_int8_t *)h;
	else {
		struct dino_softc *sc = v;
		volatile struct dino_regs *r = sc->sc_regs;

		r->pci_addr = h;
		p = (volatile u_int8_t *)&r->pci_io_data + (h & 3);
	}

	while (c--)
		*p = *a++;
}

void
dino_wm_2(void *v, bus_space_handle_t h, bus_size_t o, const u_int16_t *a, bus_size_t c)
{
	volatile u_int16_t *p;

	h += o;
	if (h & 0xf0000000)
		p = (volatile u_int16_t *)h;
	else {
		struct dino_softc *sc = v;
		volatile struct dino_regs *r = sc->sc_regs;

		r->pci_addr = h;
		p = (volatile u_int16_t *)&r->pci_io_data;
		if (h & 2)
			p++;
	}

	while (c--)
		*p = htole16(*a++);
}

void
dino_wm_4(void *v, bus_space_handle_t h, bus_size_t o, const u_int32_t *a, bus_size_t c)
{
	volatile u_int32_t *p;

	h += o;
	if (h & 0xf0000000)
		p = (volatile u_int32_t *)h;
	else {
		struct dino_softc *sc = v;
		volatile struct dino_regs *r = sc->sc_regs;

		r->pci_addr = h;
		p = (volatile u_int32_t *)&r->pci_io_data;
	}

	while (c--)
		*p = htole32(*a++);
}

void
dino_wm_8(void *v, bus_space_handle_t h, bus_size_t o, const u_int64_t *a, bus_size_t c)
{
	panic("dino_wm_8: not implemented");
}

void
dino_sm_1(void *v, bus_space_handle_t h, bus_size_t o, u_int8_t vv, bus_size_t c)
{
	volatile u_int8_t *p;

	h += o;
	if (h & 0xf0000000)
		p = (volatile u_int8_t *)h;
	else {
		struct dino_softc *sc = v;
		volatile struct dino_regs *r = sc->sc_regs;

		r->pci_addr = h;
		p = (volatile u_int8_t *)&r->pci_io_data + (h & 3);
	}

	while (c--)
		*p = vv;
}

void
dino_sm_2(void *v, bus_space_handle_t h, bus_size_t o, u_int16_t vv, bus_size_t c)
{
	volatile u_int16_t *p;

	h += o;
	if (h & 0xf0000000)
		p = (volatile u_int16_t *)h;
	else {
		struct dino_softc *sc = v;
		volatile struct dino_regs *r = sc->sc_regs;

		r->pci_addr = h;
		p = (volatile u_int16_t *)&r->pci_io_data;
		if (h & 2)
			p++;
	}

	vv = htole16(vv);
	while (c--)
		*p = vv;
}

void
dino_sm_4(void *v, bus_space_handle_t h, bus_size_t o, u_int32_t vv, bus_size_t c)
{
	volatile u_int32_t *p;

	h += o;
	if (h & 0xf0000000)
		p = (volatile u_int32_t *)h;
	else {
		struct dino_softc *sc = v;
		volatile struct dino_regs *r = sc->sc_regs;

		r->pci_addr = h;
		p = (volatile u_int32_t *)&r->pci_io_data;
	}

	vv = htole32(vv);
	while (c--)
		*p = vv;
}

void
dino_sm_8(void *v, bus_space_handle_t h, bus_size_t o, u_int64_t vv, bus_size_t c)
{
	panic("dino_sm_8: not implemented");
}

void
dino_rrm_2(void *v, bus_space_handle_t h, bus_size_t o,
    u_int8_t *a, bus_size_t c)
{
	volatile u_int16_t *p, *q = (u_int16_t *)a;

	h += o;
	if (h & 0xf0000000)
		p = (volatile u_int16_t *)h;
	else {
		struct dino_softc *sc = v;
		volatile struct dino_regs *r = sc->sc_regs;

		r->pci_addr = h;
		p = (volatile u_int16_t *)&r->pci_io_data;
		if (h & 2)
			p++;
	}

	c /= 2;
	while (c--)
		*q++ = *p;
}

void
dino_rrm_4(void *v, bus_space_handle_t h, bus_size_t o,
    u_int8_t *a, bus_size_t c)
{
	volatile u_int32_t *p, *q = (u_int32_t *)a;

	h += o;
	if (h & 0xf0000000)
		p = (volatile u_int32_t *)h;
	else {
		struct dino_softc *sc = v;
		volatile struct dino_regs *r = sc->sc_regs;

		r->pci_addr = h;
		p = (volatile u_int32_t *)&r->pci_io_data;
	}

	c /= 4;
	while (c--)
		*q++ = *p;
}

void
dino_rrm_8(void *v, bus_space_handle_t h, bus_size_t o,
    u_int8_t *a, bus_size_t c)
{
	panic("dino_rrm_8: not implemented");
}

void
dino_wrm_2(void *v, bus_space_handle_t h, bus_size_t o,
    const u_int8_t *a, bus_size_t c)
{
	volatile u_int16_t *p;
	const u_int16_t *q = (const u_int16_t *)a;

	h += o;
	if (h & 0xf0000000)
		p = (volatile u_int16_t *)h;
	else {
		struct dino_softc *sc = v;
		volatile struct dino_regs *r = sc->sc_regs;

		r->pci_addr = h;
		p = (volatile u_int16_t *)&r->pci_io_data;
		if (h & 2)
			p++;
	}

	c /= 2;
	while (c--)
		*p = *q++;
}

void
dino_wrm_4(void *v, bus_space_handle_t h, bus_size_t o,
    const u_int8_t *a, bus_size_t c)
{
	volatile u_int32_t *p;
	const u_int32_t *q = (const u_int32_t *)a;

	h += o;
	if (h & 0xf0000000)
		p = (volatile u_int32_t *)h;
	else {
		struct dino_softc *sc = v;
		volatile struct dino_regs *r = sc->sc_regs;

		r->pci_addr = h;
		p = (volatile u_int32_t *)&r->pci_io_data;
	}

	c /= 4;
	while (c--)
		*p = *q++;
}

void
dino_wrm_8(void *v, bus_space_handle_t h, bus_size_t o,
    const u_int8_t *a, bus_size_t c)
{
	panic("dino_wrm_8: not implemented");
}

void
dino_rr_1(void *v, bus_space_handle_t h, bus_size_t o, u_int8_t *a, bus_size_t c)
{
	volatile u_int8_t *p;

	h += o;
	if (h & 0xf0000000) {
		p = (volatile u_int8_t *)h;
		while (c--)
			*a++ = *p++;
	} else {
		struct dino_softc *sc = v;
		volatile struct dino_regs *r = sc->sc_regs;

		for (; c--; h++) {
		  	r->pci_addr = h;
			p = (volatile u_int8_t *)&r->pci_io_data + (h & 3);
			*a++ = *p;
		}
	}
}

void
dino_rr_2(void *v, bus_space_handle_t h, bus_size_t o, u_int16_t *a, bus_size_t c)
{
	volatile u_int16_t *p, data;

	h += o;
	if (h & 0xf0000000) {
		p = (volatile u_int16_t *)h;
		while (c--) {
			data = *p++;
			*a++ = letoh16(data);
		}
	} else {
		struct dino_softc *sc = v;
		volatile struct dino_regs *r = sc->sc_regs;

		for (; c--; h += 2) {
			r->pci_addr = h;
			p = (volatile u_int16_t *)&r->pci_io_data;
			if (h & 2)
				p++;
			data = *p;
			*a++ = letoh16(data);
		}
	}
}

void
dino_rr_4(void *v, bus_space_handle_t h, bus_size_t o, u_int32_t *a, bus_size_t c)
{
	volatile u_int32_t *p, data;

	h += o;
	if (h & 0xf0000000) {
		p = (volatile u_int32_t *)h;
		while (c--) {
			data = *p++;
			*a++ = letoh32(data);
		}
	} else {
		struct dino_softc *sc = v;
		volatile struct dino_regs *r = sc->sc_regs;

		for (; c--; h += 4) {
			r->pci_addr = h;
			data = r->pci_io_data;
			*a++ = letoh32(data);
		}
	}
}

void
dino_rr_8(void *v, bus_space_handle_t h, bus_size_t o, u_int64_t *a, bus_size_t c)
{
	panic("dino_rr_8: not implemented");
}

void
dino_wr_1(void *v, bus_space_handle_t h, bus_size_t o, const u_int8_t *a, bus_size_t c)
{
	volatile u_int8_t *p;

	h += o;
	if (h & 0xf0000000) {
		p = (volatile u_int8_t *)h;
		while (c--)
			*p++ = *a++;
	} else {
		struct dino_softc *sc = v;
		volatile struct dino_regs *r = sc->sc_regs;

		for (; c--; h++) {
			r->pci_addr = h;
			p = (volatile u_int8_t *)&r->pci_io_data + (h & 3);
			*p = *a++;
		}
	}
}

void
dino_wr_2(void *v, bus_space_handle_t h, bus_size_t o, const u_int16_t *a, bus_size_t c)
{
	volatile u_int16_t *p, data;

	h += o;
	if (h & 0xf0000000) {
		p = (volatile u_int16_t *)h;
		while (c--) {
			data = *a++;
			*p++ = htole16(data);
		}
	} else {
		struct dino_softc *sc = v;
		volatile struct dino_regs *r = sc->sc_regs;

		for (; c--; h += 2) {
			r->pci_addr = h;
			p = (volatile u_int16_t *)&r->pci_io_data;
			if (h & 2)
				p++;
			data = *a++;
			*p = htole16(data);
		}
	}
}

void
dino_wr_4(void *v, bus_space_handle_t h, bus_size_t o, const u_int32_t *a, bus_size_t c)
{
	volatile u_int32_t *p, data;

	h += o;
	if (h & 0xf0000000) {
		p = (volatile u_int32_t *)h;
		while (c--) {
			data = *a++;
			*p++ = htole32(data);
		}
	} else {
		struct dino_softc *sc = v;
		volatile struct dino_regs *r = sc->sc_regs;

		for (; c--; h += 4) {
			r->pci_addr = h;
			data = *a++;
			r->pci_io_data = htole32(data);
		}
	}
}

void
dino_wr_8(void *v, bus_space_handle_t h, bus_size_t o, const u_int64_t *a, bus_size_t c)
{
	panic("dino_wr_8: not implemented");
}

void
dino_rrr_2(void *v, bus_space_handle_t h, bus_size_t o,
    u_int8_t *a, bus_size_t c)
{
	volatile u_int16_t *p, *q = (u_int16_t *)a;

	c /= 2;
	h += o;
	if (h & 0xf0000000) {
		p = (volatile u_int16_t *)h;
		while (c--)
			*q++ = *p++;
	} else {
		struct dino_softc *sc = v;
		volatile struct dino_regs *r = sc->sc_regs;

		for (; c--; h += 2) {
			r->pci_addr = h;
			p = (volatile u_int16_t *)&r->pci_io_data;
			if (h & 2)
				p++;
			*q++ = *p;
		}
	}
}

void
dino_rrr_4(void *v, bus_space_handle_t h, bus_size_t o,
    u_int8_t *a, bus_size_t c)
{
	volatile u_int32_t *p, *q = (u_int32_t *)a;

	c /= 4;
	h += o;
	if (h & 0xf0000000) {
		p = (volatile u_int32_t *)h;
		while (c--)
			*q++ = *p++;
	} else {
		struct dino_softc *sc = v;
		volatile struct dino_regs *r = sc->sc_regs;

		for (; c--; h += 4) {
			r->pci_addr = h;
			*q++ = r->pci_io_data;
		}
	}
}

void
dino_rrr_8(void *v, bus_space_handle_t h, bus_size_t o,
    u_int8_t *a, bus_size_t c)
{
	panic("dino_rrr_8: not implemented");
}

void
dino_wrr_2(void *v, bus_space_handle_t h, bus_size_t o,
    const u_int8_t *a, bus_size_t c)
{
	volatile u_int16_t *p;
	const u_int16_t *q = (u_int16_t *)a;

	c /= 2;
	h += o;
	if (h & 0xf0000000) {
		p = (volatile u_int16_t *)h;
		while (c--)
			*p++ = *q++;
	} else {
		struct dino_softc *sc = v;
		volatile struct dino_regs *r = sc->sc_regs;

		for (; c--; h += 2) {
			r->pci_addr = h;
			p = (volatile u_int16_t *)&r->pci_io_data;
			if (h & 2)
				p++;
			*p = *q++;
		}
	}
}

void
dino_wrr_4(void *v, bus_space_handle_t h, bus_size_t o,
    const u_int8_t *a, bus_size_t c)
{
	volatile u_int32_t *p;
	const u_int32_t *q = (u_int32_t *)a;

	c /= 4;
	h += o;
	if (h & 0xf0000000) {
		p = (volatile u_int32_t *)h;
		while (c--)
			*p++ = *q++;
	} else {
		struct dino_softc *sc = v;
		volatile struct dino_regs *r = sc->sc_regs;

		for (; c--; h += 4) {
			r->pci_addr = h;
			r->pci_io_data = *q++;
		}
	}
}

void
dino_wrr_8(void *v, bus_space_handle_t h, bus_size_t o,
    const u_int8_t *a, bus_size_t c)
{
	panic("dino_wrr_8: not implemented");
}

void
dino_sr_1(void *v, bus_space_handle_t h, bus_size_t o, u_int8_t vv, bus_size_t c)
{
	volatile u_int8_t *p;

	h += o;
	if (h & 0xf0000000) {
		p = (volatile u_int8_t *)h;
		while (c--)
			*p++ = vv;
	} else {
		struct dino_softc *sc = v;
		volatile struct dino_regs *r = sc->sc_regs;

		for (; c--; h++) {
			r->pci_addr = h;
			p = (volatile u_int8_t *)&r->pci_io_data + (h & 3);
			*p = vv;
		}
	}
}

void
dino_sr_2(void *v, bus_space_handle_t h, bus_size_t o, u_int16_t vv, bus_size_t c)
{
	volatile u_int16_t *p;

	h += o;
	vv = htole16(vv);
	if (h & 0xf0000000) {
		p = (volatile u_int16_t *)h;
		while (c--)
			*p++ = vv;
	} else {
		struct dino_softc *sc = v;
		volatile struct dino_regs *r = sc->sc_regs;

		for (; c--; h += 2) {
			r->pci_addr = h;
			p = (volatile u_int16_t *)&r->pci_io_data;
			if (h & 2)
				p++;
			*p = vv;
		}
	}
}

void
dino_sr_4(void *v, bus_space_handle_t h, bus_size_t o, u_int32_t vv, bus_size_t c)
{
	volatile u_int32_t *p;

	h += o;
	vv = htole32(vv);
	if (h & 0xf0000000) {
		p = (volatile u_int32_t *)h;
		while (c--)
			*p++ = vv;
	} else {
		struct dino_softc *sc = v;
		volatile struct dino_regs *r = sc->sc_regs;

		for (; c--; h += 4) {
			r->pci_addr = h;
			r->pci_io_data = vv;
		}
	}
}

void
dino_sr_8(void *v, bus_space_handle_t h, bus_size_t o, u_int64_t vv, bus_size_t c)
{
	panic("dino_sr_8: not implemented");
}

void
dino_cp_1(void *v, bus_space_handle_t h1, bus_size_t o1,
	  bus_space_handle_t h2, bus_size_t o2, bus_size_t c)
{
	while (c--)
		dino_w1(v, h1, o1++, dino_r1(v, h2, o2++));
}

void
dino_cp_2(void *v, bus_space_handle_t h1, bus_size_t o1,
	  bus_space_handle_t h2, bus_size_t o2, bus_size_t c)
{
	while (c--) {
		dino_w2(v, h1, o1, dino_r2(v, h2, o2));
		o1 += 2;
		o2 += 2;
	}
}

void
dino_cp_4(void *v, bus_space_handle_t h1, bus_size_t o1,
	  bus_space_handle_t h2, bus_size_t o2, bus_size_t c)
{
	while (c--) {
		dino_w4(v, h1, o1, dino_r4(v, h2, o2));
		o1 += 4;
		o2 += 4;
	}
}

void
dino_cp_8(void *v, bus_space_handle_t h1, bus_size_t o1,
	  bus_space_handle_t h2, bus_size_t o2, bus_size_t c)
{
	while (c--) {
		dino_w8(v, h1, o1, dino_r8(v, h2, o2));
		o1 += 8;
		o2 += 8;
	}
}


const struct hppa_bus_space_tag dino_iomemt = {
	NULL,

	NULL, dino_unmap, dino_subregion, NULL, dino_free,
	dino_barrier, dino_vaddr,
	dino_r1,    dino_r2,    dino_r4,    dino_r8,
	dino_w1,    dino_w2,    dino_w4,    dino_w8,
	dino_rm_1,  dino_rm_2,  dino_rm_4,  dino_rm_8,
	dino_wm_1,  dino_wm_2,  dino_wm_4,  dino_wm_8,
	dino_sm_1,  dino_sm_2,  dino_sm_4,  dino_sm_8,
	            dino_rrm_2, dino_rrm_4, dino_rrm_8,
	            dino_wrm_2, dino_wrm_4, dino_wrm_8,
	dino_rr_1,  dino_rr_2,  dino_rr_4,  dino_rr_8,
	dino_wr_1,  dino_wr_2,  dino_wr_4,  dino_wr_8,
	            dino_rrr_2, dino_rrr_4, dino_rrr_8,
	            dino_wrr_2, dino_wrr_4, dino_wrr_8,
	dino_sr_1,  dino_sr_2,  dino_sr_4,  dino_sr_8,
	dino_cp_1,  dino_cp_2,  dino_cp_4,  dino_cp_8
};

int
dino_dmamap_create(void *v, bus_size_t size, int nsegments,
    bus_size_t maxsegsz, bus_size_t boundary, int flags, bus_dmamap_t *dmamp)
{
	struct dino_softc *sc = v;

	/* TODO check the addresses, boundary, enable dma */

	return (bus_dmamap_create(sc->sc_dmat, size, nsegments,
	    maxsegsz, boundary, flags, dmamp));
}

void
dino_dmamap_destroy(void *v, bus_dmamap_t map)
{
	struct dino_softc *sc = v;

	bus_dmamap_destroy(sc->sc_dmat, map);
}

int
dino_dmamap_load(void *v, bus_dmamap_t map, void *addr, bus_size_t size,
    struct proc *p, int flags)
{
	struct dino_softc *sc = v;

	return (bus_dmamap_load(sc->sc_dmat, map, addr, size, p, flags));
}

int
dino_dmamap_load_mbuf(void *v, bus_dmamap_t map, struct mbuf *m, int flags)
{
	struct dino_softc *sc = v;

	return (bus_dmamap_load_mbuf(sc->sc_dmat, map, m, flags));
}

int
dino_dmamap_load_uio(void *v, bus_dmamap_t map, struct uio *uio, int flags)
{
	struct dino_softc *sc = v;

	return (bus_dmamap_load_uio(sc->sc_dmat, map, uio, flags));
}

int
dino_dmamap_load_raw(void *v, bus_dmamap_t map, bus_dma_segment_t *segs,
    int nsegs, bus_size_t size, int flags)
{
	struct dino_softc *sc = v;

	return (bus_dmamap_load_raw(sc->sc_dmat, map, segs, nsegs, size, flags));
}

void
dino_dmamap_unload(void *v, bus_dmamap_t map)
{
	struct dino_softc *sc = v;

	bus_dmamap_unload(sc->sc_dmat, map);
}

void
dino_dmamap_sync(void *v, bus_dmamap_t map, bus_addr_t off,
    bus_size_t len, int ops)
{
	struct dino_softc *sc = v;

	return (bus_dmamap_sync(sc->sc_dmat, map, off, len, ops));
}

int
dino_dmamem_alloc(void *v, bus_size_t size, bus_size_t alignment,
    bus_size_t boundary, bus_dma_segment_t *segs,
    int nsegs, int *rsegs, int flags)
{
	struct dino_softc *sc = v;

	return (bus_dmamem_alloc(sc->sc_dmat, size, alignment, boundary,
	    segs, nsegs, rsegs, flags));
}

void
dino_dmamem_free(void *v, bus_dma_segment_t *segs, int nsegs)
{
	struct dino_softc *sc = v;

	bus_dmamem_free(sc->sc_dmat, segs, nsegs);
}

int
dino_dmamem_map(void *v, bus_dma_segment_t *segs, int nsegs, size_t size,
    caddr_t *kvap, int flags)
{
	struct dino_softc *sc = v;

	return (bus_dmamem_map(sc->sc_dmat, segs, nsegs, size, kvap, flags));
}

void
dino_dmamem_unmap(void *v, caddr_t kva, size_t size)
{
	struct dino_softc *sc = v;

	bus_dmamem_unmap(sc->sc_dmat, kva, size);
}

paddr_t
dino_dmamem_mmap(void *v, bus_dma_segment_t *segs, int nsegs, off_t off,
    int prot, int flags)
{
	struct dino_softc *sc = v;

	return (bus_dmamem_mmap(sc->sc_dmat, segs, nsegs, off, prot, flags));
}

const struct hppa_bus_dma_tag dino_dmat = {
	NULL,
	dino_dmamap_create, dino_dmamap_destroy,
	dino_dmamap_load, dino_dmamap_load_mbuf,
	dino_dmamap_load_uio, dino_dmamap_load_raw,
	dino_dmamap_unload, dino_dmamap_sync,

	dino_dmamem_alloc, dino_dmamem_free, dino_dmamem_map,
	dino_dmamem_unmap, dino_dmamem_mmap
};

const struct hppa_pci_chipset_tag dino_pc = {
	NULL,
	dino_attach_hook, dino_maxdevs, dino_make_tag, dino_decompose_tag,
	dino_conf_size, dino_conf_read, dino_conf_write,
	dino_intr_map, dino_intr_string,
	dino_intr_establish, dino_intr_disestablish,
#if NCARDBUS > 0
	dino_alloc_parent
#else
	NULL
#endif
};

int
dinoprint(void *aux, const char *pnp)
{
	struct pcibus_attach_args *pba = aux;

	if (pnp)
		printf("%s at %s\n", pba->pba_busname, pnp);
	return (UNCONF);
}

void
dinoattach(parent, self, aux)
	struct device *parent;
	struct device *self;
	void *aux;
{
	struct dino_softc *sc = (struct dino_softc *)self;
	struct confargs *ca = (struct confargs *)aux;
	struct pcibus_attach_args pba;
	volatile struct dino_regs *r;
	const char *p = NULL;
	u_int data;
	int s;

	sc->sc_bt = ca->ca_iot;
	sc->sc_dmat = ca->ca_dmatag;
	if (bus_space_map(sc->sc_bt, ca->ca_hpa, PAGE_SIZE, 0, &sc->sc_bh)) {
		printf(": can't map space\n");
		return;
	}

	sc->sc_regs = r = (volatile struct dino_regs *)sc->sc_bh;
	r->pciror = 0;
	r->pciwor = 0;

	/*
	 * Do not reset enabled io mappings mask if we are still running
	 * with PDC console - we'll do it after autoconf.
	 */
	if (cn_tab->cn_putc != pdccnputc)
		r->io_addr_en = 0;
	sc->io_shadow = 0;

	r->gmask &= ~1;	/* allow GSC bus req */
	r->brdg_feat &= ~0xf00;
	r->brdg_feat |= 3;
#ifdef notyet_card_mode
	r->io_control = 0x80;
	r->pamr = 0;
	r->papr = 0;
	r->io_fbb_en |= 1;
	r->damode = 0;
	r->brdg_feat = 0xc0000000 XXX;
	r->mltim = 0x40;	/* 64 clocks */
	r->tltim = 0x8c;	/* 12 clocks */

	/* PCI reset */
	r->pcicmd = 0x6f;
	DELAY(10000);		/* 10ms for reset to settle */
#endif

	snprintf(sc->sc_ioexname, sizeof(sc->sc_ioexname),
	    "%s_io", sc->sc_dv.dv_xname);
	if ((sc->sc_ioex = extent_create(sc->sc_ioexname, 0, 0xffff,
	    M_DEVBUF, NULL, 0, EX_NOWAIT | EX_MALLOCOK)) == NULL) {
		printf(": cannot allocate I/O extent map\n");
		bus_space_unmap(sc->sc_bt, sc->sc_bh, PAGE_SIZE);
		return;
	}

	/* TODO reserve dino's pci space ? */

	s = splhigh();
	r->imr = ~0;
	data = r->irr0;
	data = r->irr1;
	r->imr = 0;
	__asm volatile ("" ::: "memory");
	r->icr = 0;
	r->iar0 = cpu_gethpa(0) | (31 - ca->ca_irq);
	splx(s);

	sc->sc_ih = cpu_intr_establish(IPL_NESTED, ca->ca_irq,
	    dino_intr, (void *)sc->sc_regs, sc->sc_dv.dv_xname);
	/* TODO establish the bus error interrupt */

	sc->sc_ver = ca->ca_type.iodc_revision;
	switch ((ca->ca_type.iodc_model << 4) |
	    (ca->ca_type.iodc_revision >> 4)) {
	case 0x05d:	/* j2240 */
		p = "Dino(card)";
	case 0x680:
		if (!p)
			p = "Dino";
		switch (ca->ca_type.iodc_revision & 0xf) {
		case 0:	sc->sc_ver = 0x20;	break;
		case 1:	sc->sc_ver = 0x21;	break;
		case 2:	sc->sc_ver = 0x30;	break;
		case 3:	sc->sc_ver = 0x31;	break;
		}
		break;

	case 0x682:
		p = "Cujo";
		switch (ca->ca_type.iodc_revision & 0xf) {
		case 0:	sc->sc_ver = 0x10;	break;
		case 1:	sc->sc_ver = 0x20;	break;
		}
		break;

	default:
		p = "Mojo";
		break;
	}

	printf(": %s V%d.%d\n", p, sc->sc_ver >> 4, sc->sc_ver & 0xf);

	sc->sc_iot = dino_iomemt;
	sc->sc_iot.hbt_cookie = sc;
	sc->sc_iot.hbt_map = dino_iomap;
	sc->sc_iot.hbt_alloc = dino_ioalloc;
	sc->sc_memt = dino_iomemt;
	sc->sc_memt.hbt_cookie = sc;
	sc->sc_memt.hbt_map = dino_memmap;
	sc->sc_memt.hbt_alloc = dino_memalloc;
	sc->sc_pc = dino_pc;
	sc->sc_pc._cookie = sc;
	sc->sc_dmatag = dino_dmat;
	sc->sc_dmatag._cookie = sc;

	/* scan for ps2 kbd/ms, serial, and flying toasters */
	ca->ca_hpamask = -1;
	pdc_scanbus(self, ca, MAXMODBUS, 0, 0);

	bzero(&pba, sizeof(pba));
	pba.pba_busname = "pci";
	pba.pba_iot = &sc->sc_iot;
	pba.pba_memt = &sc->sc_memt;
	pba.pba_dmat = &sc->sc_dmatag;
	pba.pba_pc = &sc->sc_pc;
	pba.pba_domain = pci_ndomains++;
	pba.pba_bus = 0;
	config_found(self, &pba, dinoprint);

	/* postpone cleanup if necessary */
	if (r->io_addr_en != sc->io_shadow)
		startuphook_establish(dino_clear_pdc_mappings, sc);

	/* enable interrupts now that all the devices are there */
	r->imr = sc->sc_imr;
}

void
dino_clear_pdc_mappings(void *v)
{
	struct dino_softc *sc = (struct dino_softc *)v;
	volatile struct dino_regs *r;

	if (cn_tab->cn_putc == pdccnputc) {
		/* damn! */
		return;
	}

	r = sc->sc_regs;
	r->io_addr_en = sc->io_shadow;
}
@


1.30
log
@Only store bus/dev/func numbers when the corresponding pointer argument
isn't NULL.
@
text
@d1 1
a1 1
/*	$OpenBSD: dino.c,v 1.29 2010/12/04 17:06:31 miod Exp $	*/
d1739 1
a1739 1
	__asm __volatile ("" ::: "memory");
@


1.29
log
@Introduce a new pci routine, pci_conf_size(), which returns the size of a
given pcitag_t configuration address space. Currently, all pci controllers
will return the usual 0x100 bytes of PCI configuration space, but this will
eventually change on PCIe-capable controlers.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dino.c,v 1.28 2010/09/22 02:28:37 jsg Exp $	*/
d316 6
a321 3
	*bus = (tag >> 16) & 0xff;
	*dev = (tag >> 11) & 0x1f;
	*func= (tag >>  8) & 0x07;
@


1.28
log
@remove unused offset argument to rbus functions
ok krw@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dino.c,v 1.27 2010/04/29 13:48:29 jsing Exp $	*/
d163 1
d321 6
d1649 1
a1649 1
	dino_conf_read, dino_conf_write,
@


1.27
log
@Currently pdc_scanbus() scans in reverse, which results in physical CPU0
attaching as cpu1 and physical CPU1 attaching as cpu0. Split the device
scan into two parts - the first pass scans forward and attaches memory
and CPUs, whilst the second pass scans in reverse attaching the
remaining devices, thus preserving current semantics.

Found the hard way whilst trying to spin up the secondary CPU on my j6750.

ok miod@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dino.c,v 1.25 2009/03/30 21:24:57 kettenis Exp $	*/
d642 1
a642 1
	return rbus_new_root_share(tag, ex, start, size, 0);
@


1.26
log
@Constify the what/name parameter of pci_intr_establish().

Tested by myself, sthen, oga, kettenis, and jasper.
Input from sthen and jasper.

ok kettenis

(Manpage follows shortly.)
@
text
@d1784 1
a1784 1
	pdc_scanbus(self, ca, MAXMODBUS, 0);
@


1.25
log
@bzero pci attach args
@
text
@d1 1
a1 1
/*	$OpenBSD: dino.c,v 1.24 2008/07/23 19:14:13 miod Exp $	*/
d168 1
a168 1
	    void *, char *);
d394 1
a394 1
    int pri, int (*handler)(void *), void *arg, char *name)
@


1.24
log
@Do not rely on an <ichc>invisible cast</ichc> to return failure in
dino_intr_map(); rather than adding the missing cast, make the intent of
the code clearer by explicitenly testing for PCI_INTERRUPT_LINE being ff.

While there, enable the out-of-extent-range checks in dino_memmap() and
dino_memalloc() even if no option DEBUG, but return failure instead of
panicing.

discussed with and ok kettenis@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dino.c,v 1.23 2007/08/28 21:19:17 kettenis Exp $	*/
d1786 1
a1793 1
	pba.pba_bridgetag = NULL;
@


1.23
log
@Implement bus_space_vaddr().

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dino.c,v 1.22 2007/05/23 18:07:19 kettenis Exp $	*/
d374 4
d379 1
a379 1
	return (*ihp == 0);
d459 1
a460 1
		if (reg & 0x80000001)
d463 2
d550 1
a551 1
	if (reg & 0x80000001)
d554 2
@


1.22
log
@Add proper bus_space_vaddr() implementation.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dino.c,v 1.21 2007/05/18 16:00:17 kettenis Exp $	*/
d182 1
d638 9
d1488 1
a1488 1
	dino_barrier, NULL,
@


1.21
log
@Fix io space access.

tested by krw@@, miod@@, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dino.c,v 1.20 2007/01/11 21:59:52 miod Exp $	*/
d1478 1
a1478 1
	dino_barrier,
@


1.20
log
@When attaching a dino bridge, keep the presently enabled I/O mappings
(which were set up for us by the PDC), and wait until all devices are
attached to clear those noone of our supported devices has claimed.

This is necessary for pdc console to work until wsdisplay@@sti attaches.

ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dino.c,v 1.19 2006/12/18 18:49:46 miod Exp $	*/
d648 1
a648 1
		r->pci_addr = h & ~3;
d666 1
a666 1
		r->pci_addr = h & ~3;
d718 1
a718 1
		r->pci_addr = h & ~3;
d735 1
a735 1
		r->pci_addr = h & ~3;
d783 1
a783 1
		r->pci_addr = h & ~3;
d803 1
a803 1
		r->pci_addr = h & ~3;
d851 1
a851 1
		r->pci_addr = h & ~3;
d871 1
a871 1
		r->pci_addr = h & ~3;
d919 1
a919 1
		r->pci_addr = h & ~3;
d939 1
a939 1
		r->pci_addr = h & ~3;
d990 1
a990 1
		r->pci_addr = h & ~3;
d1044 1
a1044 1
		r->pci_addr = h & ~3;
d1099 2
a1100 2
		r->pci_addr = h & ~3;
		while (c--) {
a1102 2
			if (!(++h & 3))
				r->pci_addr = h;
d1123 2
a1124 2
		r->pci_addr = h & ~3;
		while (c--) {
a1129 3
			h += 2;
			if (!(h & 2))
				r->pci_addr = h;
d1178 2
a1179 2
		r->pci_addr = h & ~3;
		while (c--) {
a1181 2
			if (!(++h & 3))
				r->pci_addr = h;
d1202 2
a1203 2
		r->pci_addr = h & ~3;
		while (c--) {
a1208 3
			h += 2;
			if (!(h & 2))
				r->pci_addr = h;
d1259 2
a1260 2
		r->pci_addr = h & ~3;
		while (c--) {
a1264 3
			h += 2;
			if (!(h & 2))
				r->pci_addr = h;
d1316 2
a1317 2
		r->pci_addr = h & ~3;
		while (c--) {
a1321 3
			h += 2;
			if (!(h & 2))
				r->pci_addr = h;
d1371 2
a1372 2
		r->pci_addr = h & ~3;
		while (c--) {
a1374 2
			if (!(++h & 3))
				r->pci_addr = h;
d1394 2
a1395 2
		r->pci_addr = h & ~3;
		while (c--) {
a1399 3
			h += 2;
			if (!(h & 2))
				r->pci_addr = h;
@


1.19
log
@Allow bus_space mappings to span more than one 8MB segment; ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dino.c,v 1.18 2006/12/14 17:36:12 kettenis Exp $	*/
d51 3
d121 2
d158 131
d445 1
d452 1
a452 1
		reg = r->io_addr_en;
d459 1
a459 1
		if (reg != r->io_addr_en) {
d462 1
a462 1
			    DINO_MEM_CHUNK, flags, bshp))) {
d465 2
a466 1
			r->io_addr_en = reg;
d470 1
a470 1
					*bshp += (bpa - sbpa);
d541 1
a541 1
	reg = r->io_addr_en;
d547 2
a548 1
	r->io_addr_en = reg;
d1689 9
a1697 1
	r->io_addr_en = 0;
d1799 4
d1805 15
@


1.18
log
@Make pci subsystem aware of domains.  Each host bridge gets assigned a unique
domain number such that we can distinguish between busses with the same bus
number that are behind different host bridges.  Domains can be accessed by
using different device nodes.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dino.c,v 1.17 2006/03/13 20:10:49 brad Exp $	*/
d308 1
d310 1
d313 4
a316 2
	reg = r->io_addr_en;
	reg |= 1 << ((bpa >> 23) & 0x1f);
d318 2
a319 2
	if (reg & 0x80000001)
		panic("mapping outside the mem extent range");
d321 18
a338 7
	/* map into the upper bus space, if not yet mapped this 8M */
	if (reg != r->io_addr_en) {
		bus_addr_t sbpa = bpa & 0xff800000;

		if ((error = bus_space_map(sc->sc_bt, sbpa, DINO_MEM_CHUNK,
		    flags, bshp))) {
			return (error);
a339 1
		r->io_addr_en = reg;
d341 12
a352 4
		if (bshp)
			*bshp += (bpa - sbpa);
	} else if (bshp)
		*bshp = bpa;
@


1.17
log
@* Add "pcitag_t *pba_bridgetag" to pci_attach_args.  This is set to
  NULL for root PCI busses.  For busses behind a bridge, it points to
  a persistent copy of the bridge's pcitag_t.  This can be very useful
  for machine-dependent PCI bus enumeration code.

From NetBSD

ok grange@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dino.c,v 1.16 2005/09/06 23:53:38 mickey Exp $	*/
d1625 1
@


1.16
log
@fix two conf space related hw erratas; dino-moh-humm
@
text
@d1 1
a1 1
/*	$OpenBSD: dino.c,v 1.15 2004/09/18 07:02:23 mickey Exp $	*/
d1626 1
@


1.15
log
@do not match on elroy and mercury bridges
@
text
@d1 1
a1 1
/*	$OpenBSD: dino.c,v 1.14 2004/09/15 21:30:21 mickey Exp $	*/
d4 1
a4 1
 * Copyright (c) 2003 Michael Shalayeff
d189 5
d197 4
d210 1
d212 8
a219 1
	/* fix coalescing config writes errata by interleaving w/ a read */
d223 2
a224 2
	r->pci_addr = tag | reg;
	r->pci_conf_data = htole32(data);
@


1.14
log
@allocate resources for cardbus on demand; better version parsing
@
text
@d1 1
a1 1
/*	$OpenBSD: dino.c,v 1.13 2004/09/15 20:11:28 mickey Exp $	*/
d146 4
a1578 3
	/* case 0x782:	p = "Elroy"; */
	/* case 0x783:	p = "Mercury"; */
	/* case 0x783:	p = "Quicksilver"; AGP */
@


1.13
log
@scan cpu bus manually for some machines do not support that in prom
@
text
@d1 1
a1 1
/*	$OpenBSD: dino.c,v 1.12 2004/08/29 00:26:12 mickey Exp $	*/
a264 31
#if NCARDBUS > 0
void *
dino_alloc_parent(struct device *self, struct pci_attach_args *pa, int io)
{
	struct dino_softc *sc = pa->pa_pc->_cookie;
	struct extent *ex;
	bus_space_tag_t tag;
	bus_addr_t start;
	bus_size_t size;

	if (io) {
		ex = sc->sc_ioex;
		tag = pa->pa_iot;
		start = 0xa000;
		size = 0x1000;
	} else {
		ex = sc->sc_memex;
		tag = pa->pa_memt;
		start = ex->ex_start;
		size = DINO_MEM_CHUNK;
	}

	if (extent_alloc_subregion(ex, start, ex->ex_end, size, size, 0,
	    EX_NOBOUNDARY, EX_NOWAIT, &start))
		return (NULL);

	extent_free(ex, start, size, EX_NOWAIT);
	return rbus_new_root_share(tag, ex, start, size, 0);
}
#endif

d404 51
d1493 1
a1493 3
	bus_space_handle_t memh;
	bus_addr_t mem_start;
	const char *p;
d1495 1
a1495 1
	int s, ver;
a1536 19
	if (dino_memalloc(sc, 0xf0800000, 0xff7fffff, DINO_MEM_WINDOW,
	    DINO_MEM_WINDOW, EX_NOBOUNDARY, 0, &mem_start, &memh)) {
		printf(": cannot allocate memory window\n");
		bus_space_unmap(sc->sc_bt, sc->sc_bh, PAGE_SIZE);
		return;
	}

	snprintf(sc->sc_memexname, sizeof(sc->sc_memexname),
	    "%s_mem", sc->sc_dv.dv_xname);
	if ((sc->sc_memex = extent_create(sc->sc_memexname, mem_start,
	    mem_start + DINO_MEM_WINDOW, M_DEVBUF, NULL, 0,
	    EX_NOWAIT | EX_MALLOCOK)) == NULL) {
		printf(": cannot allocate MEM extent map\n");
		extent_destroy(sc->sc_ioex);
		bus_space_unmap(sc->sc_bt, sc->sc_bh, PAGE_SIZE);
		bus_space_free(sc->sc_bt, memh, DINO_MEM_WINDOW);
		return;
	}

d1551 13
a1563 13
	r->iodc = 0;
	data = r->iodc;
	ver = (ca->ca_type.iodc_model << 4) |
	    (ca->ca_type.iodc_revision >> 4);
	switch (ver) {
	case 0x05d:	p = "Dino";	/* j2240 */
	case 0x680:	p = "Dino";
		switch (data >> 16) {
		case 0x6800:	ver = 0x20;	break;
		case 0x6801:	ver = 0x21;	break;
		case 0x6802:	ver = 0x30;	break;
		case 0x6803:	ver = 0x31;	break;
		default:	ver = 0x40;	break;
d1567 5
a1571 5
	case 0x682:	p = "Cujo";
		switch (data >> 16) {
		case 0x6820:	ver = 0x10;	break;
		case 0x6821:	ver = 0x20;	break;
		default:	ver = 0x30;	break;
d1575 5
a1579 2
	default:	p = "Mojo";
		ver = (data >> 16) & 0xff;
d1582 2
a1583 2
	sc->sc_ver = ver;
	printf(": %s V%d.%d\n", p, ver >> 4, ver & 0xf);
@


1.12
log
@oops debugging printf
@
text
@d1 1
a1 1
/*	$OpenBSD: dino.c,v 1.11 2004/08/06 20:29:47 mickey Exp $	*/
d1598 1
a1598 1
	pdc_scanbus(self, ca, MAXMODBUS);
@


1.11
log
@support cardbus bridges and a few pcmcia devices i have working
@
text
@d1 1
a1 1
/*	$OpenBSD: dino.c,v 1.10 2004/07/24 15:04:35 mickey Exp $	*/
a1490 1
printf("feat %08x ", r->brdg_feat);
@


1.10
log
@better operated entities and quantities in raw functions
@
text
@d1 1
a1 1
/*	$OpenBSD: dino.c,v 1.9 2004/07/21 19:54:08 mickey Exp $	*/
a106 1
	bus_space_handle_t sc_memh;
d292 1
a292 1
	return rbus_new_root_share(tag, ex, start, size, start);
d303 1
a303 2
	if (!(flags & BUS_SPACE_MAP_NOEXTENT) &&
	    (error = extent_alloc_region(sc->sc_ioex, bpa, size, EX_NOWAIT)))
d383 17
a399 2
	/* TODO dino_memalloc */
	return (-1);
a416 1
	/* XXX gotta follow the BUS_SPACE_MAP_NOEXTENT flag */
d1473 1
d1491 3
d1520 2
a1521 3
	/* XXX assuming that dino attaches the last */
	if (bus_space_alloc(sc->sc_bt, 0xf0800000, 0xff7fffff, DINO_MEM_WINDOW,
	    DINO_MEM_CHUNK, EX_NOBOUNDARY, 0, &mem_start, &sc->sc_memh)) {
d1526 1
d1535 1
a1535 1
		bus_space_unmap(sc->sc_bt, sc->sc_memh, DINO_MEM_WINDOW);
@


1.9
log
@swapped byte swapping in raw vs non-raw funcs and missed swapping in rw8; from jkunz@@ pr3861
@
text
@d1 1
a1 1
/*	$OpenBSD: dino.c,v 1.8 2004/06/30 15:25:36 mickey Exp $	*/
d767 1
a767 1
	volatile u_int16_t *p;
d782 1
d784 1
a784 1
		*a++ = *p;
d791 1
a791 1
	volatile u_int32_t *p;
d804 1
d806 1
a806 1
		*a++ = *p;
d821 1
d836 1
d838 1
a838 1
		*p = *a++;
d846 1
d859 1
d861 1
a861 1
		*p = *a++;
d1043 1
a1043 1
	volatile u_int16_t *p;
d1045 1
d1050 1
a1050 1
			*a++ = *p++;
d1060 1
a1060 1
			*a++ = *p;
d1072 1
a1072 1
	volatile u_int32_t *p;
d1074 1
d1079 1
a1079 1
			*a++ = *p++;
d1086 1
a1086 1
			*a++ = r->pci_io_data;
d1103 1
d1105 1
d1110 1
a1110 1
			*p++ = *a++;
d1120 1
a1120 1
			*p = *a++;
d1133 1
d1135 1
d1140 1
a1140 1
			*p++ = *a++;
d1147 1
a1147 1
			r->pci_io_data = *a++;
@


1.8
log
@only touch bridge regs that we need now -- the rest for the card-mode
@
text
@d1 1
a1 1
/*	$OpenBSD: dino.c,v 1.7 2004/06/17 06:06:18 mickey Exp $	*/
d483 2
d487 1
a487 1
		return *(volatile u_int64_t *)h;
d490 2
d551 1
a551 1
		*(volatile u_int64_t *)h = vv;
d596 1
a596 1
		*a++ = *p;
d616 1
a616 1
		*a++ = *p;
d664 1
a664 1
		*p = *a++;
d684 1
a684 1
		*p = *a++;
d731 1
d752 1
d783 1
a783 1
		*a++ = swap16(*p);
d804 1
a804 1
		*a++ = swap32(*p);
d834 1
a834 1
		*p = swap16(*a++);
d855 1
a855 1
		*p = swap32(*a++);
d892 1
a892 1
	volatile u_int16_t *p;
d897 4
a900 2
		while (c--)
			*a++ = *p++;
d910 2
a911 1
			*a++ = *p;
d922 1
a922 1
	volatile u_int32_t *p;
d927 4
a930 2
		while (c--)
			*a++ = *p++;
d937 2
a938 1
			*a++ = r->pci_io_data;
d976 1
a976 1
	volatile u_int16_t *p;
d981 4
a984 2
		while (c--)
			*p++ = *a++;
d994 2
a995 1
			*p = *a++;
d1006 1
a1006 1
	volatile u_int32_t *p;
d1011 4
a1014 2
		while (c--)
			*p++ = *a++;
d1021 2
a1022 1
			r->pci_io_data = *a++;
d1043 1
a1043 1
			*a++ = swap16(*p++);
d1053 1
a1053 1
			*a++ = swap16(*p);
d1071 1
a1071 1
			*a++ = swap32(*p++);
d1078 1
a1078 1
			*a++ = swap32(r->pci_io_data);
d1100 1
a1100 1
			*p++ = swap16(*a++);
d1110 1
a1110 1
			*p = swap16(*a++);
d1128 1
a1128 1
			*p++ = swap32(*a++);
d1135 1
a1135 1
			r->pci_io_data = swap32(*a++);
d1177 1
d1205 1
@


1.7
log
@reset both irr's; put a barrier upon imr reset such that icr is reset properly and do it once
@
text
@d1 1
a1 1
/*	$OpenBSD: dino.c,v 1.6 2004/06/17 05:40:32 mickey Exp $	*/
d1442 5
a1450 1
	r->io_addr_en = 0;
d1452 3
a1454 4
	r->gmask &= ~1;	/* allow GSC bus req */
	r->pciror = 0;
	r->pciwor = 0;
	r->brdg_feat = 0xc0000000;
d1458 2
@


1.6
log
@fix coalescing config writes errata
@
text
@d1 1
a1 1
/*	$OpenBSD: dino.c,v 1.5 2004/02/13 20:39:31 mickey Exp $	*/
a247 1
		r->icr &= ~(1 << (ih - 1));
d1489 1
d1491 2
@


1.5
log
@support secondary com@@dino from todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dino.c,v 1.4 2003/12/23 12:07:11 mickey Exp $	*/
d197 5
@


1.5.2.1
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: dino.c,v 1.5 2004/02/13 20:39:31 mickey Exp $	*/
d234 2
a235 2
	/* no mapping */
	if (ih == 0)
d242 1
a242 1
			r->imr |= (1 << (ih - 1));
d1536 4
@


1.5.2.2
log
@Merge with the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d234 2
a235 2
	/* no mapping or bogus */
	if (ih <= 0 || ih > 11)
d242 1
a242 1
			r->imr = sc->sc_imr |= (1 << (ih - 1));
a1535 4

	/* scan for ps2 kbd/ms, serial, and flying toasters */
	ca->ca_hpamask = -1;
	pdc_scanbus(self, ca, MAXMODBUS);
@


1.4
log
@unscrew the 16bit routines w/ a proper data reg calculation
@
text
@d1 1
a1 1
/*	$OpenBSD: dino.c,v 1.3 2003/12/20 21:49:04 miod Exp $	*/
d234 2
a235 2
	/* no mapping */
	if (ih == 0)
d242 1
a242 1
			r->imr |= (1 << (ih - 1));
d1536 4
@


1.3
log
@Pass -Wformat, fix a few uninitialized variables as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: dino.c,v 1.2 2003/10/30 19:25:12 mickey Exp $	*/
d439 1
a439 1
	u_int16_t data;
d443 1
a443 1
		data = *(volatile u_int16_t *)h;
d449 3
a451 1
		data = *((volatile u_int16_t *)&r->pci_io_data + (h & 2));
d454 1
a454 1
	return (letoh16(data));
d504 2
a506 1
	vv = htole16(vv);
d508 1
a508 1
		*(volatile u_int16_t *)h = vv;
d514 3
a516 1
		*((volatile u_int16_t *)&r->pci_io_data + (h & 2)) = vv;
d518 2
d582 3
a584 1
		p = (volatile u_int16_t *)&r->pci_io_data + (h & 2);
d650 3
a652 1
		p = (volatile u_int16_t *)&r->pci_io_data + (h & 2);
d718 3
a720 1
		p = (volatile u_int16_t *)&r->pci_io_data + (h & 2);
d767 3
a769 1
		p = (volatile u_int16_t *)&r->pci_io_data + (h & 2);
d818 3
a820 1
		p = (volatile u_int16_t *)&r->pci_io_data + (h & 2);
d895 3
a897 1
			p = (volatile u_int16_t *)&r->pci_io_data + (h & 2);
d900 1
a900 1
			if (!(h & 3))
d973 3
a975 1
			p = (volatile u_int16_t *)&r->pci_io_data + (h & 2);
d978 1
a978 1
			if (!(h & 3))
d1028 3
a1030 1
			p = (volatile u_int16_t *)&r->pci_io_data + (h & 2);
d1033 1
a1033 1
			if (!(h & 3))
d1085 3
a1087 1
			p = (volatile u_int16_t *)&r->pci_io_data + (h & 2);
d1090 1
a1090 1
			if (!(h & 3))
d1165 3
a1167 1
			p = (volatile u_int16_t *)&r->pci_io_data + (h & 2);
d1170 1
a1170 1
			if (!(h & 3))
@


1.2
log
@typos and grammer from Bruno Rohee <bruno@@rohee.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: dino.c,v 1.1 2003/09/29 19:30:23 mickey Exp $	*/
d221 1
a221 1
	snprintf(buf, 32, "irq %d", ih);
@


1.1
log
@dino/cujo pci bridge
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d1518 1
a1518 1
	/* now enable interrupts that all the devices are there */
@

