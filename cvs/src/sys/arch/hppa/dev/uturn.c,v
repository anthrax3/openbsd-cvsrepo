head	1.7;
access;
symbols
	OPENBSD_6_1:1.7.0.28
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.7.0.26
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.22
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.7.0.24
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.16
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.20
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.18
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.14
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.12
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.10
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.8
	OPENBSD_5_0:1.7.0.6
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.4
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.2
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.6.0.8
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.10
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.6
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.4
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.2
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.3.0.10
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.8
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.3.0.6
	OPENBSD_4_0_BASE:1.3
	OPENBSD_3_9:1.3.0.4
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.2
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.2.0.2
	OPENBSD_3_7_BASE:1.2;
locks; strict;
comment	@ * @;


1.7
date	2010.04.29.13.48.29;	author jsing;	state Exp;
branches;
next	1.6;

1.6
date	2007.12.29.01.26.14;	author kettenis;	state Exp;
branches;
next	1.5;

1.5
date	2007.12.28.19.49.43;	author kettenis;	state Exp;
branches;
next	1.4;

1.4
date	2007.12.21.16.19.43;	author kettenis;	state Exp;
branches;
next	1.3;

1.3
date	2005.04.07.00.21.51;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	2004.09.26.21.54.00;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	2004.09.15.21.32.43;	author mickey;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Currently pdc_scanbus() scans in reverse, which results in physical CPU0
attaching as cpu1 and physical CPU1 attaching as cpu0. Split the device
scan into two parts - the first pass scans forward and attaches memory
and CPUs, whilst the second pass scans in reverse attaching the
remaining devices, thus preserving current semantics.

Found the hard way whilst trying to spin up the secondary CPU on my j6750.

ok miod@@ kettenis@@
@
text
@/*	$OpenBSD: uturn.c,v 1.5 2007/12/28 19:49:43 kettenis Exp $	*/

/*
 * Copyright (c) 2004 Michael Shalayeff
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR OR HIS RELATIVES BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

/* TODO IOA programming */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/reboot.h>

#include <machine/iomod.h>
#include <machine/autoconf.h>

#include <hppa/dev/cpudevs.h>

struct uturn_regs {
	u_int64_t	resv0[2];
	u_int64_t	status;		/* 0x10: */
	u_int64_t	resv1[5];
	u_int64_t	debug;		/* 0x40: */
};

struct uturn_softc {
	struct device sc_dv;

	struct uturn_regs volatile *sc_regs;
};

int	uturnmatch(struct device *, void *, void *);
void	uturnattach(struct device *, struct device *, void *);

struct cfattach uturn_ca = {
	sizeof(struct uturn_softc), uturnmatch, uturnattach
};

struct cfdriver uturn_cd = {
	NULL, "uturn", DV_DULL
};

int
uturnmatch(parent, cfdata, aux)   
	struct device *parent;
	void *cfdata;
	void *aux;
{
	struct confargs *ca = aux;
	/* struct cfdata *cf = cfdata; */

	/* there will be only one */
	if (ca->ca_type.iodc_type != HPPA_TYPE_IOA ||
	    ca->ca_type.iodc_sv_model != HPPA_IOA_UTURN)
		return 0;

	if (ca->ca_type.iodc_model == 0x58 &&
	    ca->ca_type.iodc_revision >= 0x20)
		return 0;

	return 1;
}

void
uturnattach(parent, self, aux)
	struct device *parent;
	struct device *self;
	void *aux;
{
	struct confargs *ca = aux, nca;
	struct uturn_softc *sc = (struct uturn_softc *)self;
	bus_space_handle_t ioh;
	hppa_hpa_t hpa;

	if (bus_space_map(ca->ca_iot, ca->ca_hpa, IOMOD_HPASIZE, 0, &ioh)) {
		printf(": can't map IO space\n");
		return;
	}
	sc->sc_regs = (struct uturn_regs *)ca->ca_hpa;

	printf(": %s rev %d\n",
	    ca->ca_type.iodc_revision < 0x10? "U2" : "UTurn",
	    ca->ca_type.iodc_revision & 0xf);

	/* keep it real */
	((struct iomod *)ioh)->io_control = 0x80;

	/*
	 * U2/UTurn is actually a combination of an Upper Bus
	 * Converter (UBC) and a Lower Bus Converter (LBC).  This
	 * driver attaches to the UBC; the LBC isn't very interesting,
	 * so we skip it.  This is easy, since it always is module 63,
	 * hence the MAXMODBUS - 1 below.
	 */
	nca = *ca;
	nca.ca_hpamask = HPPA_IOBEGIN;
	pdc_scanbus(self, &nca, MAXMODBUS - 1, 0, 0);

	/* XXX On some machines, PDC doesn't tell us about all devices. */
	switch (cpu_hvers) {
	case HPPA_BOARD_HP809:
	case HPPA_BOARD_HP819:
	case HPPA_BOARD_HP829:
	case HPPA_BOARD_HP839:
	case HPPA_BOARD_HP849:
	case HPPA_BOARD_HP859:
	case HPPA_BOARD_HP869:
		hpa = ((struct iomod *)ioh)->io_io_low << 16;
		pdc_scanbus(self, &nca, MAXMODBUS - 1, hpa, 0);
		break;
	default:
		break;
	}
}
@


1.6
log
@Skip LBC on buswalk.  Gets rid of unconfigured "Bus Converter Port" devices
on machines like the C360.
@
text
@d119 1
a119 1
	pdc_scanbus(self, &nca, MAXMODBUS - 1, 0);
d131 1
a131 1
		pdc_scanbus(self, &nca, MAXMODBUS - 1, hpa);
@


1.5
log
@Add a few more K-class models to the list of machines that have more devices
than PDC tells us about.
@
text
@d1 1
a1 1
/*	$OpenBSD: uturn.c,v 1.4 2007/12/21 16:19:43 kettenis Exp $	*/
d110 8
a117 1
	nca = *ca;	/* clone from us */
d119 1
a119 1
	pdc_scanbus(self, &nca, MAXMODBUS, 0);
d131 1
a131 1
		pdc_scanbus(self, &nca, MAXMODBUS, hpa);
@


1.4
log
@Add a hack to discover all devices on (some) K-class servers.
@
text
@d1 1
a1 1
/*	$OpenBSD: uturn.c,v 1.3 2005/04/07 00:21:51 mickey Exp $	*/
d118 1
d120 1
d122 1
@


1.3
log
@64bit-friendly pdc.h and iomod.h and correspondent changes elsewhere
@
text
@d1 1
a1 1
/*	$OpenBSD: uturn.c,v 1.2 2004/09/26 21:54:00 mickey Exp $	*/
d95 1
d113 13
@


1.2
log
@do not match on astro
@
text
@d1 1
a1 1
/*	$OpenBSD: uturn.c,v 1.1 2004/09/15 21:32:43 mickey Exp $	*/
d110 1
a110 1
	nca.ca_hpamask = HPPA_IOSPACE;
@


1.1
log
@add pcxu tlb handlers and cpu probing
add u2/uturn ioa driver in dumb mode now
enable pcxu/pcxw support
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d77 4
@

