head	1.41;
access;
symbols
	OPENBSD_6_0:1.41.0.12
	OPENBSD_6_0_BASE:1.41
	OPENBSD_5_9:1.41.0.8
	OPENBSD_5_9_BASE:1.41
	OPENBSD_5_8:1.41.0.10
	OPENBSD_5_8_BASE:1.41
	OPENBSD_5_7:1.41.0.2
	OPENBSD_5_7_BASE:1.41
	OPENBSD_5_6:1.41.0.6
	OPENBSD_5_6_BASE:1.41
	OPENBSD_5_5:1.41.0.4
	OPENBSD_5_5_BASE:1.41
	OPENBSD_5_4:1.39.0.12
	OPENBSD_5_4_BASE:1.39
	OPENBSD_5_3:1.39.0.10
	OPENBSD_5_3_BASE:1.39
	OPENBSD_5_2:1.39.0.8
	OPENBSD_5_2_BASE:1.39
	OPENBSD_5_1_BASE:1.39
	OPENBSD_5_1:1.39.0.6
	OPENBSD_5_0:1.39.0.4
	OPENBSD_5_0_BASE:1.39
	OPENBSD_4_9:1.39.0.2
	OPENBSD_4_9_BASE:1.39
	OPENBSD_4_8:1.37.0.2
	OPENBSD_4_8_BASE:1.37
	OPENBSD_4_7:1.30.0.2
	OPENBSD_4_7_BASE:1.30
	OPENBSD_4_6:1.29.0.6
	OPENBSD_4_6_BASE:1.29
	OPENBSD_4_5:1.29.0.2
	OPENBSD_4_5_BASE:1.29
	OPENBSD_4_4:1.28.0.16
	OPENBSD_4_4_BASE:1.28
	OPENBSD_4_3:1.28.0.14
	OPENBSD_4_3_BASE:1.28
	OPENBSD_4_2:1.28.0.12
	OPENBSD_4_2_BASE:1.28
	OPENBSD_4_1:1.28.0.10
	OPENBSD_4_1_BASE:1.28
	OPENBSD_4_0:1.28.0.8
	OPENBSD_4_0_BASE:1.28
	OPENBSD_3_9:1.28.0.6
	OPENBSD_3_9_BASE:1.28
	OPENBSD_3_8:1.28.0.4
	OPENBSD_3_8_BASE:1.28
	OPENBSD_3_7:1.28.0.2
	OPENBSD_3_7_BASE:1.28
	OPENBSD_3_6:1.24.0.2
	OPENBSD_3_6_BASE:1.24
	SMP_SYNC_A:1.24
	SMP_SYNC_B:1.24
	OPENBSD_3_5:1.23.0.4
	OPENBSD_3_5_BASE:1.23
	OPENBSD_3_4:1.23.0.2
	OPENBSD_3_4_BASE:1.23
	UBC_SYNC_A:1.21
	OPENBSD_3_3:1.20.0.2
	OPENBSD_3_3_BASE:1.20
	OPENBSD_3_2:1.18.0.2
	OPENBSD_3_2_BASE:1.18
	OPENBSD_3_1:1.16.0.2
	OPENBSD_3_1_BASE:1.16
	UBC_SYNC_B:1.18
	UBC:1.8.0.8
	UBC_BASE:1.8
	OPENBSD_3_0:1.8.0.6
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9:1.8.0.4
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_8:1.8.0.2
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.6.0.4
	OPENBSD_2_7_BASE:1.6
	SMP:1.6.0.2
	SMP_BASE:1.6
	kame_19991208:1.6
	OPENBSD_2_6:1.5.0.2
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.41
date	2014.01.19.12.45.35;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2013.11.26.20.33.12;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2011.01.02.20.41.22;	author kettenis;	state Exp;
branches;
next	1.38;

1.38
date	2010.12.30.14.10.14;	author jsing;	state Exp;
branches;
next	1.37;

1.37
date	2010.06.26.23.33.32;	author jsing;	state Exp;
branches;
next	1.36;

1.36
date	2010.06.03.15.48.58;	author jsing;	state Exp;
branches;
next	1.35;

1.35
date	2010.05.21.15.24.29;	author jsing;	state Exp;
branches;
next	1.34;

1.34
date	2010.05.19.13.10.24;	author jsing;	state Exp;
branches;
next	1.33;

1.33
date	2010.05.06.14.51.30;	author jsing;	state Exp;
branches;
next	1.32;

1.32
date	2010.04.01.12.30.38;	author jsing;	state Exp;
branches;
next	1.31;

1.31
date	2010.03.28.16.26.47;	author jsing;	state Exp;
branches;
next	1.30;

1.30
date	2009.12.29.14.10.29;	author jsing;	state Exp;
branches;
next	1.29;

1.29
date	2009.02.08.18.33.28;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2004.12.28.05.18.25;	author mickey;	state Exp;
branches;
next	1.27;

1.27
date	2004.10.26.21.27.53;	author mickey;	state Exp;
branches;
next	1.26;

1.26
date	2004.09.14.23.39.32;	author mickey;	state Exp;
branches;
next	1.25;

1.25
date	2004.09.14.22.29.19;	author mickey;	state Exp;
branches;
next	1.24;

1.24
date	2004.04.07.18.24.19;	author mickey;	state Exp;
branches;
next	1.23;

1.23
date	2003.08.22.18.09.52;	author mickey;	state Exp;
branches;
next	1.22;

1.22
date	2003.08.07.19.47.33;	author mickey;	state Exp;
branches;
next	1.21;

1.21
date	2003.03.29.00.52.45;	author mickey;	state Exp;
branches;
next	1.20;

1.20
date	2002.12.08.17.21.43;	author mickey;	state Exp;
branches;
next	1.19;

1.19
date	2002.11.27.21.47.14;	author mickey;	state Exp;
branches;
next	1.18;

1.18
date	2002.05.23.16.03.39;	author mickey;	state Exp;
branches;
next	1.17;

1.17
date	2002.05.08.03.16.08;	author mickey;	state Exp;
branches;
next	1.16;

1.16
date	2002.03.26.05.29.02;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	2002.03.21.01.02.09;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	2002.03.19.01.30.46;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	2002.03.14.01.26.31;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2002.03.06.20.24.03;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	2002.03.06.20.20.42;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.05.23.10.42;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	2002.02.11.19.42.11;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	2000.08.15.20.38.24;	author mickey;	state Exp;
branches
	1.8.8.1;
next	1.7;

1.7
date	2000.07.03.17.07.08;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	99.11.26.17.58.17;	author mickey;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	99.08.16.02.48.39;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	99.08.14.03.58.55;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	99.04.20.20.25.54;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	99.02.17.03.19.07;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	98.12.29.21.32.34;	author mickey;	state Exp;
branches;
next	;

1.6.2.1
date	2001.04.18.16.05.54;	author niklas;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2002.03.06.00.57.22;	author niklas;	state Exp;
branches;
next	1.6.2.3;

1.6.2.3
date	2002.03.28.10.07.19;	author niklas;	state Exp;
branches;
next	1.6.2.4;

1.6.2.4
date	2003.03.27.23.26.53;	author niklas;	state Exp;
branches;
next	1.6.2.5;

1.6.2.5
date	2003.05.13.19.41.03;	author ho;	state Exp;
branches;
next	1.6.2.6;

1.6.2.6
date	2004.02.19.10.48.39;	author niklas;	state Exp;
branches;
next	1.6.2.7;

1.6.2.7
date	2004.06.05.23.10.47;	author niklas;	state Exp;
branches;
next	;

1.8.8.1
date	2002.06.11.03.35.36;	author art;	state Exp;
branches;
next	1.8.8.2;

1.8.8.2
date	2003.05.19.21.49.41;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.41
log
@Initialize ci_randseed better using arc4random() + a trick.  Remove the
libkern srandom() API since it is not suitable for this use.
ok kettenis miod
@
text
@/*	$OpenBSD: cpu.c,v 1.40 2013/11/26 20:33:12 deraadt Exp $	*/

/*
 * Copyright (c) 1998-2003 Michael Shalayeff
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR OR HIS RELATIVES BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/proc.h>
#include <sys/reboot.h>
#include <dev/rndvar.h>

#include <uvm/uvm_extern.h>

#include <machine/cpufunc.h>
#include <machine/pdc.h>
#include <machine/reg.h>
#include <machine/iomod.h>
#include <machine/autoconf.h>

#include <hppa/dev/cpudevs.h>

struct cpu_softc {
	struct  device sc_dev;
};

#ifdef MULTIPROCESSOR
struct cpu_info *cpu_hatch_info;
static volatile int start_secondary_cpu;
#endif

int	cpumatch(struct device *, void *, void *);
void	cpuattach(struct device *, struct device *, void *);

struct cfattach cpu_ca = {
	sizeof(struct cpu_softc), cpumatch, cpuattach
};

struct cfdriver cpu_cd = {
	NULL, "cpu", DV_DULL
};

int
cpumatch(struct device *parent, void *cfdata, void *aux)
{
	struct cfdata *cf = cfdata;
	struct confargs *ca = aux;

	/* probe any 1.0, 1.1 or 2.0 */
	if (ca->ca_type.iodc_type != HPPA_TYPE_NPROC ||
	    ca->ca_type.iodc_sv_model != HPPA_NPROC_HPPA)
		return 0;

	if (cf->cf_unit >= MAXCPUS)
		return 0;

	return 1;
}

void
cpuattach(struct device *parent, struct device *self, void *aux)
{
	/* machdep.c */
	extern struct pdc_model pdc_model;
	extern struct pdc_cache pdc_cache;
	extern struct pdc_btlb pdc_btlb;
	extern u_int cpu_ticksnum, cpu_ticksdenom;
	extern u_int fpu_enable;
	/* clock.c */
	extern int cpu_hardclock(void *);
	/* ipi.c */
	extern int hppa_ipi_intr(void *);

	struct confargs *ca = (struct confargs *)aux;
	struct cpu_info *ci;
	u_int mhz = 100 * cpu_ticksnum / cpu_ticksdenom;
	int cpuno = self->dv_unit;
	struct pglist mlist;
	struct vm_page *m;
	const char *p;
	int error;

	ci = &cpu_info[cpuno];
	ci->ci_dev = self;
	ci->ci_cpuid = cpuno;
	ci->ci_hpa = ca->ca_hpa;

	/* Allocate stack for spin up and FPU emulation. */
	TAILQ_INIT(&mlist);
	error = uvm_pglistalloc(PAGE_SIZE, 0, -1L, 0, 0, &mlist, 1,
	    UVM_PLA_NOWAIT);
	if (error) {
		printf(": unable to allocate CPU stack!\n");
		return;
	}
	m = TAILQ_FIRST(&mlist);
	ci->ci_stack = VM_PAGE_TO_PHYS(m);

	printf (": %s ", cpu_typename);
	if (pdc_model.hvers) {
		static const char lvls[4][4] = { "0", "1", "1.5", "2" };

		printf("L%s-%c ", lvls[pdc_model.pa_lvl], "AB"[pdc_model.mc]);
	}

	printf ("%d", mhz / 100);
	if (mhz % 100 > 9)
		printf(".%02d", mhz % 100);
	printf("MHz");

	if (fpu_enable) {
		extern u_int fpu_version;
		u_int32_t ver[2];

		mtctl(fpu_enable, CR_CCR);
		__asm volatile(
		    "fstds   %%fr0,0(%0)\n\t"
		    "copr,0,0\n\t"
		    "fstds   %%fr0,0(%0)"
		    :: "r" (&ver) : "memory");
		mtctl(0, CR_CCR);
		fpu_version = HPPA_FPUVER(ver[0]);
		printf(", FPU %s rev %d",
		    hppa_mod_info(HPPA_TYPE_FPU, fpu_version >> 5),
		    fpu_version & 0x1f);
	}

	printf("\n%s: ", self->dv_xname);
	p = "";
	if (!pdc_cache.dc_conf.cc_sh) {
		printf("%uK(%db/l) Icache, ",
		    pdc_cache.ic_size / 1024, pdc_cache.ic_conf.cc_line * 16);
		p = "D";
	}

	printf("%uK(%db/l) wr-%s %scache, ",
	    pdc_cache.dc_size / 1024, pdc_cache.dc_conf.cc_line * 16,
	    pdc_cache.dc_conf.cc_wt? "thru" : "back", p);

	p = "";
	if (!pdc_cache.dt_conf.tc_sh) {
		printf("%u ITLB, ", pdc_cache.it_size);
		p = "D";
	}
	printf("%u %scoherent %sTLB",
	    pdc_cache.dt_size, pdc_cache.dt_conf.tc_cst? "" : "in", p);

	if (pdc_btlb.finfo.num_c)
		printf(", %u BTLB", pdc_btlb.finfo.num_c);
	else if (pdc_btlb.finfo.num_i || pdc_btlb.finfo.num_d)
		printf(", %u/%u D/I BTLBs",
		    pdc_btlb.finfo.num_i, pdc_btlb.finfo.num_d);

	cpu_intr_establish(IPL_CLOCK, 31, cpu_hardclock, NULL, "clock");
#ifdef MULTIPROCESSOR
	cpu_intr_establish(IPL_IPI, 30, hppa_ipi_intr, NULL, "ipi");
#endif

	printf("\n");
}

#ifdef MULTIPROCESSOR
void
cpu_boot_secondary_processors(void)
{
	struct cpu_info *ci;
	struct iomod *cpu;
	int i, j;

	/* Initialise primary CPU. */
	ci = curcpu();
	ci->ci_flags |= CPUF_RUNNING;
	hppa_ipi_init(ci);

	for (i = 0; i < HPPA_MAXCPUS; i++) {

		ci = &cpu_info[i];
		if (ci->ci_cpuid == 0)
			continue;

		ci->ci_randseed = (arc4random() & 0x7fffffff) + 1;

		sched_init_cpu(ci);

		/* Release the specified CPU by triggering an EIR{0}. */
		cpu_hatch_info = ci;
		cpu = (struct iomod *)(ci->ci_hpa);
		cpu->io_eir = 0;
		asm volatile ("sync" ::: "memory");

		/* Wait for CPU to wake up... */
		j = 0;
		while (!(ci->ci_flags & CPUF_RUNNING) && j++ < 10000)
			delay(1000);
		if (!(ci->ci_flags & CPUF_RUNNING))
			printf("failed to hatch cpu %i!\n", ci->ci_cpuid);
	}

	/* Release secondary CPUs. */
	start_secondary_cpu = 1;
	asm volatile ("sync" ::: "memory");
}

void
cpu_hw_init(void)
{
	struct cpu_info *ci = curcpu();

	/* Purge TLB and flush caches. */
	ptlball();
	ficacheall();
	fdcacheall();

	/* Enable address translations. */
	ci->ci_psw = PSL_I | PSL_Q | PSL_P | PSL_C | PSL_D;
	ci->ci_psw |= (cpu_info[0].ci_psw & PSL_O);
}

void
cpu_hatch(void)
{
	struct cpu_info *ci = curcpu();
	extern u_long cpu_hzticks;
	u_long itmr;
	int s;

	/* Initialise IPIs. */
	hppa_ipi_init(ci);

	/* Initialise clock. */
	mtctl((1U << 31), CR_EIRR);
	mfctl(CR_ITMR, itmr);
	ci->ci_itmr = itmr;
	itmr += cpu_hzticks;
	mtctl(itmr, CR_ITMR);
	ci->ci_mask |= (1U << 31);

	/* Enable interrupts. */
	mtctl(ci->ci_mask, CR_EIEM);

	ncpus++;
	ci->ci_flags |= CPUF_RUNNING;

	/* Wait for additional CPUs to spinup. */
	while (!start_secondary_cpu)
		;

	SCHED_LOCK(s);
	cpu_switchto(NULL, sched_chooseproc());
}

void
cpu_unidle(struct cpu_info *ci)
{
	if (ci != curcpu())
		hppa_ipi_send(ci, HPPA_IPI_NOP);
}
#endif

void
need_resched(struct cpu_info *ci)
{
	ci->ci_want_resched = 1;

	/* There's a risk we'll be called before the idle threads start */
	if (ci->ci_curproc) {
		setsoftast(ci->ci_curproc);
		cpu_unidle(ci);
	}
}
@


1.40
log
@1 << 31 cleanup.  Eitan Adler pointed out that there has been a
resurrection of the bad idiom in the tree.
sufficient review by miod, kettenis, tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.39 2011/01/02 20:41:22 kettenis Exp $	*/
d34 1
d204 1
a204 1
		ci->ci_randseed = random();
@


1.39
log
@Make need_resched() call cpu_unidle() such that we wake up a process running on
another CPU.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.38 2010/12/30 14:10:14 jsing Exp $	*/
d253 1
a253 1
	mtctl((1 << 31), CR_EIRR);
d258 1
a258 1
	ci->ci_mask |= (1 << 31);
@


1.38
log
@Implement cpu_unidle() for MP kernels.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.36 2010/06/03 15:48:58 jsing Exp $	*/
d32 1
d281 12
@


1.37
log
@Allow processes to be scheduled onto secondary CPUs.

ok kettenis@@
@
text
@d272 7
@


1.36
log
@Rename ci_spinup_stack to ci_stack and use it as the stack for both CPU
spin up and FPU emulation. Since all CPUs need a stack for FPU emulation,
move the allocation code to cpuattach().

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.35 2010/05/21 15:24:29 jsing Exp $	*/
a203 1
#ifdef notyet
a204 1
#endif
d246 1
a261 1
#ifdef notyet
a262 1
#endif
a268 3
	for (;;) ;

#ifdef notyet
a270 1
#endif
@


1.35
log
@Add support for IPIs on hppa.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.34 2010/05/19 13:10:24 jsing Exp $	*/
d99 2
d102 1
d109 11
d189 1
a189 3
	struct pglist mlist;
	struct vm_page *m;
	int error, i, j;
a206 11

		/* Allocate spinup stack. */
		TAILQ_INIT(&mlist);
		error = uvm_pglistalloc(PAGE_SIZE, 0, -1L, 0, 0, &mlist, 1,
		    UVM_PLA_NOWAIT);
		if (error) {
			printf("unable to allocate spinup stack!\n");
			return;
		}
		m = TAILQ_FIRST(&mlist);
		ci->ci_spinup_stack = VM_PAGE_TO_PHYS(m);
@


1.34
log
@Spin up secondary CPUs on hppa multiprocessor kernels. At this stage we
enable clock interrupts, however do not allow processes to be scheduled
onto the secondary CPUs - hopefully we can change this shortly...

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.28 2004/12/28 05:18:25 mickey Exp $	*/
d92 2
d162 4
a165 1
	
d182 1
d247 3
@


1.33
log
@Ansify functions and use "clock" rather than the CPU name for clock
interrupts.

ok kettenis@@
@
text
@d34 2
d46 1
d48 4
a51 2
	hppa_hpa_t sc_hpa;
};
d168 100
@


1.32
log
@Allow for multiple CPUs by moving to an array of cpu_info.

ok kettenis@@
@
text
@a45 1
	void *sc_ih;
d60 1
a60 4
cpumatch(parent, cfdata, aux)   
	struct device *parent;
	void *cfdata;
	void *aux;
d77 1
a77 4
cpuattach(parent, self, aux)
	struct device *parent;
	struct device *self;
	void *aux;
a87 1
	struct cpu_softc *sc = (struct cpu_softc *)self;
d154 1
a154 2
	sc->sc_ih = cpu_intr_establish(IPL_CLOCK, 31,
	    cpu_hardclock, NULL /*frame*/, sc->sc_dev.dv_xname);
@


1.31
log
@Allow a multiprocessor kernel to compile.

ok kettenis@@
@
text
@d96 2
d99 1
d101 5
@


1.30
log
@Move hppa to a "cpu0 at mainbus0" configuration, rather than knocking CPUs
out in the cpu match function. Whilst here also hardwire the clock to IRQ
31, thus preventing one from building a kernel without hardclock.

ok kettenis@@ miod@@
@
text
@d159 7
@


1.29
log
@Make sure than cpu_hardclock() never sets a ``next interrupt value'' which has
already been hit by the running timer; this happens very often on oosiop-based
machines, due to these machines being among the slowest hppa, and oosiop
being interrupt greedy. Unfortunately, when this happened, one had to wait
for the timer to wrap, which would take up to 128 seconds on the 33MHz
machines.

Also, invoke hardclock() as many times as necessary if it turns out that
we had to delay the interrupt 1/hz seconds to avoid the aforementioned
wrap problem.

With help from kettenis@@; ok kettenis@@
@
text
@d66 1
a67 1
	struct cfdata *cf = cfdata;
a68 1
	/* there will be only one for now XXX */
d70 1
a70 2
	if (cf->cf_unit > 0 ||
	    ca->ca_type.iodc_type != HPPA_TYPE_NPROC ||
d74 3
a95 1
	struct confargs *ca = aux;
d153 4
a157 7

	/* sanity against lusers amongst config editors */
	if (ca->ca_irq == 31)
		sc->sc_ih = cpu_intr_establish(IPL_CLOCK, ca->ca_irq,
		    cpu_hardclock, NULL /*frame*/, sc->sc_dev.dv_xname);
	else
		printf ("%s: bad irq %d\n", sc->sc_dev.dv_xname, ca->ca_irq);
@


1.28
log
@fix new line in dmesg print on 8k cpus
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.27 2004/10/26 21:27:53 mickey Exp $	*/
a78 7
int
cpu_hardclock(void *v)
{
	hardclock(v);
	return (1);
}

d91 2
@


1.27
log
@simplify cache print a bit
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.26 2004/09/14 23:39:32 mickey Exp $	*/
d154 1
a154 1
		printf(", %u BTLB\n", pdc_btlb.finfo.num_c);
d156 1
a156 1
		printf(", %u/%u D/I BTLBs\n",
d158 1
@


1.26
log
@store fpu version for later use. make sure to proper store/clear fpu state in fork/exec/exit/sendsig
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.25 2004/09/14 22:29:19 mickey Exp $	*/
d140 2
a141 2
	/* TODO decode associativity */
	printf("%uK(%db/l) wr-%s %scoherent %scache, ",
d143 1
a143 2
	    pdc_cache.dc_conf.cc_wt? "thru" : "back",
	    pdc_cache.dc_conf.cc_cst? "" : "in", p);
@


1.25
log
@do not print anything about btlb if there is none
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.24 2004/04/07 18:24:19 mickey Exp $	*/
d117 1
d127 1
a127 1
		ver[0] = HPPA_FPUVER(ver[0]);
d129 2
a130 1
		    hppa_mod_info(HPPA_TYPE_FPU, ver[0] >> 5), ver[0] & 0x1f);
@


1.24
log
@update copyright; miod@@ is fine w/ files where he holds it too
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.23 2003/08/22 18:09:52 mickey Exp $	*/
d154 1
a154 1
	else
@


1.23
log
@rework cpu identification
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.22 2003/08/07 19:47:33 mickey Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998-2002 Michael Shalayeff
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Michael Shalayeff.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d19 8
a26 7
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF MIND,
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@


1.22
log
@make all intr_establish take the same last arg for name
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.21 2003/03/29 00:52:45 mickey Exp $	*/
d97 1
d103 2
a104 6
	struct pdc_model pdc_model PDC_ALIGNMENT;
	struct pdc_cpuid pdc_cpuid PDC_ALIGNMENT;
	u_int pdc_cversion[32] PDC_ALIGNMENT;
	register struct cpu_softc *sc = (struct cpu_softc *)self;
	register struct confargs *ca = aux;
	const char *p = NULL;
d106 1
a106 1
	int err;
d108 2
a109 27
	bzero (&pdc_cpuid, sizeof(pdc_cpuid));
	if (pdc_call((iodcio_t)pdc, 0, PDC_MODEL, PDC_MODEL_CPUID,
		     &pdc_cpuid, sc->sc_dev.dv_unit, 0, 0, 0) >= 0) {

		/* patch for old 8200 */
		if (pdc_cpuid.version == HPPA_CPU_PCXUP &&
		    pdc_cpuid.revision > 0x0d)
			pdc_cpuid.version = HPPA_CPU_PCXUP1;
			
		p = hppa_mod_info(HPPA_TYPE_CPU, pdc_cpuid.version);
	}
	/* otherwise try to guess on component version numbers */
	else if (pdc_call((iodcio_t)pdc, 0, PDC_MODEL, PDC_MODEL_COMP,
		     &pdc_cversion, sc->sc_dev.dv_unit) >= 0) {
		/* XXX p = hppa_mod_info(HPPA_TYPE_CPU,pdc_cversion[0]); */
	}

	printf (": %s ", p? p : cpu_typename);
	if (sc->sc_dev.dv_xname)
		(*cpu_desidhash)();

	if ((err = pdc_call((iodcio_t)pdc, 0, PDC_MODEL, PDC_MODEL_INFO,
			    &pdc_model)) < 0) {
#ifdef DEBUG
		printf("PDC_MODEL(%d) ", err);
#endif
	} else {
@


1.21
log
@fix fpu printout and remove dead code piece
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.20 2002/12/08 17:21:43 mickey Exp $	*/
d193 1
a193 1
		    cpu_hardclock, NULL /*frame*/, &sc->sc_dev);
@


1.20
log
@duh, provide a wrapper on the hardclock() since it's void
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.19 2002/11/27 21:47:14 mickey Exp $	*/
d146 1
a146 1
	printf("MHz, ");
d159 1
a159 1
		printf("FPU %s rev %d",
a161 3

	/* if (pdc_model.sh)
		printf("shadows, "); */
@


1.19
log
@no wrapper arounf hardclock(), use CPU_CLOCKUPDATE, real microtime; miod ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.18 2002/05/23 16:03:39 mickey Exp $	*/
d83 7
d196 1
a196 1
		    (int (*)(void *))hardclock, NULL /*frame*/, &sc->sc_dev);
@


1.18
log
@fetch fpu id per the book (even it works otherwise), also, hppa_mod_info() always returns some string; idea by fredette@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.17 2002/05/08 03:16:08 mickey Exp $	*/
d189 1
a189 1
		    clock_intr, NULL /*trapframe*/, &sc->sc_dev);
@


1.17
log
@print parisc level w/ the the parisc version, not for each cpu
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.16 2002/03/26 05:29:02 mickey Exp $	*/
d142 1
a142 2
		const char *name;
		u_int ver;
d146 1
d148 1
a148 1
		    "fstws   %%fr0,0(%0)"
d151 3
a153 6
		ver = HPPA_FPUVER(ver);
		name = hppa_mod_info(HPPA_TYPE_FPU, ver >> 5);
		if (name)
			printf("FPU %s rev %d", name, ver & 0x1f);
		else
			printf("FPU v%d.%02d", ver >> 5, ver & 0x1f);
@


1.16
log
@need to mask out the upper part for the fpu version on print
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.15 2002/03/21 01:02:09 mickey Exp $	*/
d121 3
a123 1
	printf (": %s rev %d ", p? p : cpu_typename, (*cpu_desidhash)());
@


1.15
log
@better cache mode print
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.14 2002/03/19 01:30:46 mickey Exp $	*/
d152 1
a152 1
			printf("FPU %s rev %d", name, ver);
@


1.14
log
@no need for reg.h in the frame.h
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.13 2002/03/14 01:26:31 millert Exp $	*/
d168 1
a168 1
	printf("%uK(%db/l) %s %scoherent %scache, ",
d170 1
a170 1
	    pdc_cache.dc_conf.cc_wt? "w-thru" : "w-back",
@


1.13
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.12 2002/03/06 20:24:03 mickey Exp $	*/
d40 1
@


1.12
log
@no need to mask
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.11 2002/03/06 20:20:42 mickey Exp $	*/
d52 2
a53 2
int	cpumatch __P((struct device *, void *, void *));
void	cpuattach __P((struct device *, struct device *, void *));
@


1.11
log
@expand fpu name, makes line overflow a bit, maybe deal w/ it later
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.10 2002/03/05 23:10:42 mickey Exp $	*/
d149 1
a149 1
		name = hppa_mod_info(HPPA_TYPE_FPU, (ver >> 5) & 0x1f);
d151 1
a151 1
			printf("FPU %s rev %d", name, ver & 0x1f);
d153 1
a153 1
			printf("FPU v%d.%02d", (ver >> 5) & 0x1f, ver & 0x1f);
@


1.10
log
@rearrange stuff, chat about cache
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.9 2002/02/11 19:42:11 mickey Exp $	*/
d139 1
d141 1
d149 5
a153 1
		printf("FPU v%d.%02d", ver / 100, ver %100);
d167 1
a167 1
	printf("%uK(%db/l) %s %scoherent %scache\n%s: ",
d170 1
a170 1
	    pdc_cache.dc_conf.cc_cst? "" : "in", p, self->dv_xname);
@


1.9
log
@disable fpu on csw, print fpu version on cpu line, if present
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.8 2000/08/15 20:38:24 mickey Exp $	*/
d120 14
a133 2
	printf (": %s rev %d %d",
	    p? p : cpu_typename, (*cpu_desidhash)(), mhz / 100);
a135 1

d150 3
d154 16
a169 11

	if ((err = pdc_call((iodcio_t)pdc, 0, PDC_MODEL, PDC_MODEL_INFO,
			    &pdc_model)) < 0) {
#ifdef DEBUG
		printf("WARNING: PDC_MODEL failed (%d)\n", err);
#endif
	} else {
		static const char lvls[4][4] = { "0", "1", "1.5", "2" };

		printf("L %s-%c, ",
		       lvls[pdc_model.pa_lvl], "AB"[pdc_model.mc]);
d171 2
d174 2
a175 11
	if (pdc_model.sh)
		printf("shadows, ");

	if (pdc_cache.dc_conf.cc_sh)
		printf("%uK cache", pdc_cache.dc_size / 1024);
	else
		printf("%uK/%uK D/I caches",
		       pdc_cache.dc_size / 1024,
		       pdc_cache.ic_size / 1024);
	if (pdc_cache.dt_conf.tc_sh)
		printf(", %u shared TLB", pdc_cache.dt_size);
d177 2
a178 2
		printf(", %u/%u D/I TLBs",
		       pdc_cache.dt_size, pdc_cache.it_size);
d180 2
a181 12
	if (pdc_btlb.finfo.num_c)
		printf(", %u shared BTLB", pdc_btlb.finfo.num_c);
	else {
		printf(", %u/%u D/I BTLBs",
		       pdc_btlb.finfo.num_i,
		       pdc_btlb.finfo.num_d);
	}

	printf("\n");

	/* sanity against luser amongst config editors */
	if (ca->ca_irq == 31) {
d183 3
a185 6
					       clock_intr, NULL /*trapframe*/,
					       &sc->sc_dev);
	} else {
		printf ("%s: bad irq number %d\n", sc->sc_dev.dv_xname,
			ca->ca_irq);
	}
@


1.8
log
@print cpu revision and type
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.7 2000/07/03 17:07:08 mickey Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998,1999 Michael Shalayeff
d92 1
d120 20
a139 1
	printf (": %s rev %d, ", p? p : cpu_typename, (*cpu_desidhash)());
d149 1
a149 1
		printf("lev %s, cat %c, ",
d153 2
a154 6
	printf ("%d", mhz / 100);
	if (mhz % 100 > 9)
		printf(".%02d", mhz % 100);

	printf(" MHz clk\n%s: %s", self->dv_xname,
	       pdc_model.sh? "shadows, ": "");
@


1.8.8.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.8 2000/08/15 20:38:24 mickey Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998-2002 Michael Shalayeff
a39 1
#include <machine/reg.h>
d52 2
a53 2
int	cpumatch(struct device *, void *, void *);
void	cpuattach(struct device *, struct device *, void *);
a91 1
	extern u_int fpu_enable;
d119 1
a119 3
	printf (": %s ", p? p : cpu_typename);
	if (sc->sc_dev.dv_xname)
		(*cpu_desidhash)();
d124 1
a124 1
		printf("PDC_MODEL(%d) ", err);
d129 2
a130 1
		printf("L%s-%c ", lvls[pdc_model.pa_lvl], "AB"[pdc_model.mc]);
a135 1
	printf("MHz, ");
d137 2
a138 2
	if (fpu_enable) {
		u_int32_t ver[2];
d140 11
a150 11
		mtctl(fpu_enable, CR_CCR);
		__asm volatile(
		    "fstds   %%fr0,0(%0)\n\t"
		    "copr,0,0\n\t"
		    "fstds   %%fr0,0(%0)"
		    :: "r" (&ver) : "memory");
		mtctl(0, CR_CCR);
		ver[0] = HPPA_FPUVER(ver[0]);
		printf("FPU %s rev %d",
		    hppa_mod_info(HPPA_TYPE_FPU, ver[0] >> 5), ver[0] & 0x1f);
	}
d152 6
a157 20
	/* if (pdc_model.sh)
		printf("shadows, "); */

	printf("\n%s: ", self->dv_xname);
	p = "";
	if (!pdc_cache.dc_conf.cc_sh) {
		printf("%uK(%db/l) Icache, ",
		    pdc_cache.ic_size / 1024, pdc_cache.ic_conf.cc_line * 16);
		p = "D";
	}
	/* TODO decode associativity */
	printf("%uK(%db/l) wr-%s %scoherent %scache, ",
	    pdc_cache.dc_size / 1024, pdc_cache.dc_conf.cc_line * 16,
	    pdc_cache.dc_conf.cc_wt? "thru" : "back",
	    pdc_cache.dc_conf.cc_cst? "" : "in", p);

	p = "";
	if (!pdc_cache.dt_conf.tc_sh) {
		printf("%u ITLB, ", pdc_cache.it_size);
		p = "D";
a158 2
	printf("%u %scoherent %sTLB",
	    pdc_cache.dt_size, pdc_cache.dt_conf.tc_cst? "" : "in", p);
d160 1
a160 5
	if (pdc_btlb.finfo.num_c)
		printf(", %u BTLB\n", pdc_btlb.finfo.num_c);
	else
		printf(", %u/%u D/I BTLBs\n",
		    pdc_btlb.finfo.num_i, pdc_btlb.finfo.num_d);
d162 2
a163 2
	/* sanity against lusers amongst config editors */
	if (ca->ca_irq == 31)
d165 6
a170 3
		    clock_intr, NULL /*trapframe*/, &sc->sc_dev);
	else
		printf ("%s: bad irq %d\n", sc->sc_dev.dv_xname, ca->ca_irq);
@


1.8.8.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a82 7
int
cpu_hardclock(void *v)
{
	hardclock(v);
	return (1);
}

d139 1
a139 1
	printf("MHz");
d152 1
a152 1
		printf(", FPU %s rev %d",
d156 3
d189 1
a189 1
		    cpu_hardclock, NULL /*frame*/, &sc->sc_dev);
@


1.7
log
@add luseless comment
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.6 1999/11/26 17:58:17 mickey Exp $	*/
d119 1
a119 2
	printf (": %s v%d.%d, ", p? p : "PA7000",
		pdc_cpuid.revision >> 4, pdc_cpuid.revision & 0xf);
@


1.6
log
@shorter text, so it fits in 80 columns
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.5 1999/08/16 02:48:39 mickey Exp $	*/
d163 1
@


1.6.2.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.8 2000/08/15 20:38:24 mickey Exp $	*/
d119 2
a120 1
	printf (": %s rev %d, ", p? p : cpu_typename, (*cpu_desidhash)());
a162 1
	/* sanity against luser amongst config editors */
@


1.6.2.2
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d4 1
a4 1
 * Copyright (c) 1998-2002 Michael Shalayeff
a91 1
	extern u_int fpu_enable;
d119 1
a119 20
	printf (": %s rev %d %d",
	    p? p : cpu_typename, (*cpu_desidhash)(), mhz / 100);
	if (mhz % 100 > 9)
		printf(".%02d", mhz % 100);

	printf("MHz, ");

	if (fpu_enable) {
		u_int ver;
		mtctl(fpu_enable, CR_CCR);
		__asm volatile(
		    "copr,0,0\n\t"
		    "fstws   %%fr0,0(%0)"
		    :: "r" (&ver) : "memory");
		mtctl(0, CR_CCR);
		ver = HPPA_FPUVER(ver);
		printf("FPU v%d.%02d", ver / 100, ver %100);
	}

	printf("\n%s: ", self->dv_xname);
d129 1
a129 1
		printf("L %s-%c, ",
d133 6
a138 2
	if (pdc_model.sh)
		printf("shadows, ");
@


1.6.2.3
log
@Merge in -current from about a week ago
@
text
@a39 1
#include <machine/reg.h>
d52 2
a53 2
int	cpumatch(struct device *, void *, void *);
void	cpuattach(struct device *, struct device *, void *);
d120 2
a121 14
	printf (": %s rev %d ", p? p : cpu_typename, (*cpu_desidhash)());

	if ((err = pdc_call((iodcio_t)pdc, 0, PDC_MODEL, PDC_MODEL_INFO,
			    &pdc_model)) < 0) {
#ifdef DEBUG
		printf("PDC_MODEL(%d) ", err);
#endif
	} else {
		static const char lvls[4][4] = { "0", "1", "1.5", "2" };

		printf("L%s-%c ", lvls[pdc_model.pa_lvl], "AB"[pdc_model.mc]);
	}

	printf ("%d", mhz / 100);
d124 1
a127 1
		const char *name;
a128 1

d136 1
a136 5
		name = hppa_mod_info(HPPA_TYPE_FPU, ver >> 5);
		if (name)
			printf("FPU %s rev %d", name, ver);
		else
			printf("FPU v%d.%02d", ver >> 5, ver & 0x1f);
d139 1
a139 2
	/* if (pdc_model.sh)
		printf("shadows, "); */
d141 10
a150 17
	printf("\n%s: ", self->dv_xname);
	p = "";
	if (!pdc_cache.dc_conf.cc_sh) {
		printf("%uK(%db/l) Icache, ",
		    pdc_cache.ic_size / 1024, pdc_cache.ic_conf.cc_line * 16);
		p = "D";
	}
	/* TODO decode associativity */
	printf("%uK(%db/l) wr-%s %scoherent %scache, ",
	    pdc_cache.dc_size / 1024, pdc_cache.dc_conf.cc_line * 16,
	    pdc_cache.dc_conf.cc_wt? "thru" : "back",
	    pdc_cache.dc_conf.cc_cst? "" : "in", p);

	p = "";
	if (!pdc_cache.dt_conf.tc_sh) {
		printf("%u ITLB, ", pdc_cache.it_size);
		p = "D";
d152 15
a166 2
	printf("%u %scoherent %sTLB",
	    pdc_cache.dt_size, pdc_cache.dt_conf.tc_cst? "" : "in", p);
d169 8
a176 4
		printf(", %u BTLB\n", pdc_btlb.finfo.num_c);
	else
		printf(", %u/%u D/I BTLBs\n",
		    pdc_btlb.finfo.num_i, pdc_btlb.finfo.num_d);
d178 2
a179 2
	/* sanity against lusers amongst config editors */
	if (ca->ca_irq == 31)
d181 6
a186 3
		    clock_intr, NULL /*trapframe*/, &sc->sc_dev);
	else
		printf ("%s: bad irq %d\n", sc->sc_dev.dv_xname, ca->ca_irq);
@


1.6.2.4
log
@Sync the SMP branch with 3.3
@
text
@a82 7
int
cpu_hardclock(void *v)
{
	hardclock(v);
	return (1);
}

d121 1
a121 3
	printf (": %s ", p? p : cpu_typename);
	if (sc->sc_dev.dv_xname)
		(*cpu_desidhash)();
d140 2
a141 1
		u_int32_t ver[2];
a144 1
		    "fstds   %%fr0,0(%0)\n\t"
d146 1
a146 1
		    "fstds   %%fr0,0(%0)"
d149 6
a154 3
		ver[0] = HPPA_FPUVER(ver[0]);
		printf("FPU %s rev %d",
		    hppa_mod_info(HPPA_TYPE_FPU, ver[0] >> 5), ver[0] & 0x1f);
d190 1
a190 1
		    cpu_hardclock, NULL /*frame*/, &sc->sc_dev);
@


1.6.2.5
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.6.2.4 2003/03/27 23:26:53 niklas Exp $	*/
d146 1
a146 1
	printf("MHz");
d159 1
a159 1
		printf(", FPU %s rev %d",
d162 3
@


1.6.2.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a96 1
	extern struct pdc_model pdc_model;
d102 6
a107 2
	struct cpu_softc *sc = (struct cpu_softc *)self;
	struct confargs *ca = aux;
d109 18
a126 1
	const char *p;
d128 10
a137 2
	printf (": %s ", cpu_typename);
	if (pdc_model.hvers) {
d193 1
a193 1
		    cpu_hardclock, NULL /*frame*/, sc->sc_dev.dv_xname);
@


1.6.2.7
log
@Merge with the trunk
@
text
@d4 1
a4 1
 * Copyright (c) 1998-2003 Michael Shalayeff
d15 5
d24 7
a30 8
 * IN NO EVENT SHALL THE AUTHOR OR HIS RELATIVES BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
@


1.5
log
@evcnt count the interrupts, also optimize diagnostic printing
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.4 1999/08/14 03:58:55 mickey Exp $	*/
d26 2
a27 2
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
d130 1
a130 1
		printf("level %s, category %c, ",
d138 1
a138 1
	printf(" MHz clock\n%s: %s", self->dv_xname,
@


1.4
log
@next try to print cpu model number.
attach clock interrupt.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.3 1999/04/20 20:25:54 mickey Exp $	*/
d166 1
a166 1
					       sc->sc_dev.dv_xname);
@


1.3
log
@print cpu ID (type) if available
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.2 1999/02/17 03:19:07 mickey Exp $	*/
d49 1
d95 5
a99 3
	/* register struct cpu_softc *sc = (struct cpu_softc *)self; */
	/* register struct confargs *ca = aux; */
	u_int mhz;
d102 1
a102 1
	printf (": ");
d104 13
a116 6
		     &pdc_cpuid, 0, 0, 0, 0) >= 0) {
		const char *p = hppa_mod_info(HPPA_TYPE_CPU,pdc_cpuid.version);
		if (!p)
			p = "pa-risc ??";
		printf (": %s rev %d.%d",
			p, pdc_cpuid.revision >> 4, pdc_cpuid.revision & 0xf);
d119 3
a133 1
	mhz = 100 * cpu_ticksnum / cpu_ticksdenom;
d162 9
@


1.2
log
@better cpu capabilities printing.
print cpu PA level
move cpu_gethpa() to mainbus.c
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.1 1998/12/29 21:32:34 mickey Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998 Michael Shalayeff
d72 1
d74 2
a75 1
	    ca->ca_type.iodc_type != HPPA_TYPE_CPU)
d87 3
d91 3
d95 1
a95 3
	register struct confargs *ca = aux;
	struct pdc_cache pdc_cache PDC_ALIGNMENT;
	struct pdc_btlb pdc_btlb PDC_ALIGNMENT;
d97 19
a115 2
	int pdcerr;
	char *p;
d117 2
a118 7
	/* this is finally from "HP-UX Multiprocessing rev 1.3" paper
	 * identifying PA revisions! */
	switch (ca->ca_type.iodc_sv_model) {
	case  0:  p = "1.0";	break;
	case  4:  p = "1.1";	break;
	case  8:  p = "2.0";	break;
	default:  p = "?.?";	break;
d122 1
a122 1
	printf(": PA%s %d", mhz / 100);
d126 2
a127 1
	printf(" MHz clock\n%s: ", self->dv_xname);
d129 18
a146 35
	/*
	 * get cache parameters from the PDC
	 */
	if ((pdcerr = pdc_call((iodcio_t)pdc, 0, PDC_CACHE, PDC_CACHE_DFLT,
			       &pdc_cache)) < 0) {
#ifdef DEBUG
                printf("Warning: PDC_CACHE call Ret'd %d\n", pdcerr);
#endif
	} else {
		if (pdc_cache.dc_conf.cc_sh)
			printf("%uK cache", pdc_cache.dc_size / 1024);
		else
			printf("%uK/%uK D/I caches",
			       pdc_cache.dc_size / 1024,
			       pdc_cache.ic_size / 1024);
		if (pdc_cache.dt_conf.tc_sh)
			printf(", %u shared TLB", pdc_cache.dt_size);
		else
			printf(", %u/%u D/I TLBs",
			       pdc_cache.dt_size, pdc_cache.it_size);
	}

	if ((pdcerr = pdc_call((iodcio_t)pdc, 0, PDC_BLOCK_TLB,
			       PDC_BTLB_DEFAULT, &pdc_btlb)) < 0) {
#ifdef DEBUG
                printf("Warning: PDC_BTLB call Ret'd %d\n", pdcerr);
#endif
	} else {
		if (pdc_btlb.finfo.num_c)
			printf(", %u shared BTLB", pdc_btlb.finfo.num_c);
		else {
			printf(", %u/%u D/I BTLBs",
			       pdc_btlb.finfo.num_i,
			       pdc_btlb.finfo.num_d);
		}
@


1.1
log
@some cpu
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d87 1
a87 1
	/* register struct confargs *ca = aux; */
d92 10
d104 1
a104 1
	printf(": %d", mhz / 100);
d106 1
a106 1
		printf("%02d MHz", mhz % 100);
d108 1
a108 1
	printf("%s: ", self->dv_xname);
d120 1
a120 1
			printf(", %uK cache", pdc_cache.dc_size / 1024);
d122 1
a122 1
			printf(", %uK/%uK D/I caches",
a147 14
}

/*
 * retrive CPU #N HPA value
 */
hppa_hpa_t
cpu_gethpa(n)
	int n;
{
	register struct cpu_softc *sc;

	sc = cpu_cd.cd_devs[0];

	return sc->sc_hpa;
@

