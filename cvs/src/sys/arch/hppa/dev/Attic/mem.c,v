head	1.38;
access;
symbols
	OPENBSD_6_0:1.36.0.8
	OPENBSD_6_0_BASE:1.36
	OPENBSD_5_9:1.36.0.4
	OPENBSD_5_9_BASE:1.36
	OPENBSD_5_8:1.36.0.6
	OPENBSD_5_8_BASE:1.36
	OPENBSD_5_7:1.36.0.2
	OPENBSD_5_7_BASE:1.36
	OPENBSD_5_6:1.34.0.4
	OPENBSD_5_6_BASE:1.34
	OPENBSD_5_5:1.32.0.16
	OPENBSD_5_5_BASE:1.32
	OPENBSD_5_4:1.32.0.12
	OPENBSD_5_4_BASE:1.32
	OPENBSD_5_3:1.32.0.10
	OPENBSD_5_3_BASE:1.32
	OPENBSD_5_2:1.32.0.8
	OPENBSD_5_2_BASE:1.32
	OPENBSD_5_1_BASE:1.32
	OPENBSD_5_1:1.32.0.6
	OPENBSD_5_0:1.32.0.4
	OPENBSD_5_0_BASE:1.32
	OPENBSD_4_9:1.32.0.2
	OPENBSD_4_9_BASE:1.32
	OPENBSD_4_8:1.31.0.8
	OPENBSD_4_8_BASE:1.31
	OPENBSD_4_7:1.31.0.4
	OPENBSD_4_7_BASE:1.31
	OPENBSD_4_6:1.31.0.6
	OPENBSD_4_6_BASE:1.31
	OPENBSD_4_5:1.31.0.2
	OPENBSD_4_5_BASE:1.31
	OPENBSD_4_4:1.30.0.4
	OPENBSD_4_4_BASE:1.30
	OPENBSD_4_3:1.30.0.2
	OPENBSD_4_3_BASE:1.30
	OPENBSD_4_2:1.28.0.6
	OPENBSD_4_2_BASE:1.28
	OPENBSD_4_1:1.28.0.4
	OPENBSD_4_1_BASE:1.28
	OPENBSD_4_0:1.28.0.2
	OPENBSD_4_0_BASE:1.28
	OPENBSD_3_9:1.27.0.2
	OPENBSD_3_9_BASE:1.27
	OPENBSD_3_8:1.26.0.4
	OPENBSD_3_8_BASE:1.26
	OPENBSD_3_7:1.26.0.2
	OPENBSD_3_7_BASE:1.26
	OPENBSD_3_6:1.25.0.2
	OPENBSD_3_6_BASE:1.25
	SMP_SYNC_A:1.25
	SMP_SYNC_B:1.25
	OPENBSD_3_5:1.24.0.2
	OPENBSD_3_5_BASE:1.24
	OPENBSD_3_4:1.20.0.2
	OPENBSD_3_4_BASE:1.20
	UBC_SYNC_A:1.20
	OPENBSD_3_3:1.17.0.2
	OPENBSD_3_3_BASE:1.17
	OPENBSD_3_2:1.14.0.2
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.12.0.2
	OPENBSD_3_1_BASE:1.12
	UBC_SYNC_B:1.15
	UBC:1.6.0.2
	UBC_BASE:1.6
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9:1.4.0.8
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.6
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.4
	OPENBSD_2_7_BASE:1.4
	SMP:1.4.0.2
	SMP_BASE:1.4
	kame_19991208:1.4
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.1.0.2
	OPENBSD_2_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.38
date	2016.08.19.20.48.36;	author tedu;	state dead;
branches;
next	1.37;
commitid	c1ae6O4K7OArklXt;

1.37
date	2016.08.01.15.58.22;	author tedu;	state Exp;
branches;
next	1.36;
commitid	0APfmV8i34pDgCWZ;

1.36
date	2015.02.10.22.44.35;	author miod;	state Exp;
branches;
next	1.35;
commitid	lsrmQ0A4gY4UmdnD;

1.35
date	2015.02.10.21.56.09;	author miod;	state Exp;
branches;
next	1.34;
commitid	C5iGb36LQxjM60Q3;

1.34
date	2014.04.08.09.34.22;	author mpi;	state Exp;
branches;
next	1.33;

1.33
date	2014.03.29.18.09.29;	author guenther;	state Exp;
branches;
next	1.32;

1.32
date	2010.12.26.15.40.59;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2009.02.04.17.21.23;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2007.09.22.16.21.32;	author krw;	state Exp;
branches;
next	1.29;

1.29
date	2007.09.22.09.57.40;	author martin;	state Exp;
branches;
next	1.28;

1.28
date	2006.05.29.08.09.16;	author mickey;	state Exp;
branches;
next	1.27;

1.27
date	2005.11.28.20.13.08;	author martin;	state Exp;
branches;
next	1.26;

1.26
date	2004.09.19.01.30.11;	author mickey;	state Exp;
branches;
next	1.25;

1.25
date	2004.04.07.18.24.19;	author mickey;	state Exp;
branches;
next	1.24;

1.24
date	2004.03.20.18.50.36;	author mickey;	state Exp;
branches;
next	1.23;

1.23
date	2004.03.17.20.55.09;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2004.03.17.00.41.08;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2003.09.25.22.13.19;	author mickey;	state Exp;
branches;
next	1.20;

1.20
date	2003.04.07.20.18.34;	author mickey;	state Exp;
branches;
next	1.19;

1.19
date	2003.04.07.17.24.08;	author mickey;	state Exp;
branches;
next	1.18;

1.18
date	2003.04.07.17.14.59;	author mickey;	state Exp;
branches;
next	1.17;

1.17
date	2003.01.22.14.44.55;	author mickey;	state Exp;
branches;
next	1.16;

1.16
date	2003.01.22.00.21.38;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2002.10.25.18.46.35;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	2002.09.05.21.36.28;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	2002.06.06.16.32.33;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	2002.03.16.22.05.19;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	2002.03.16.00.34.56;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.15.21.44.18;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.14.01.26.31;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.02.28.22.18.03;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.02.21.06.46;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	2001.11.01.12.13.46;	author art;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2001.05.05.20.56.36;	author art;	state Exp;
branches;
next	1.4;

1.4
date	99.11.26.18.01.01;	author mickey;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	99.11.22.19.21.58;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	99.06.29.20.56.09;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	98.12.29.21.38.47;	author mickey;	state Exp;
branches;
next	;

1.4.2.1
date	2001.07.04.10.15.59;	author niklas;	state Exp;
branches;
next	1.4.2.2;

1.4.2.2
date	2001.11.13.21.00.51;	author niklas;	state Exp;
branches;
next	1.4.2.3;

1.4.2.3
date	2002.03.06.00.57.22;	author niklas;	state Exp;
branches;
next	1.4.2.4;

1.4.2.4
date	2002.03.28.10.07.19;	author niklas;	state Exp;
branches;
next	1.4.2.5;

1.4.2.5
date	2003.03.27.23.26.53;	author niklas;	state Exp;
branches;
next	1.4.2.6;

1.4.2.6
date	2003.05.13.19.41.03;	author ho;	state Exp;
branches;
next	1.4.2.7;

1.4.2.7
date	2004.02.19.10.48.39;	author niklas;	state Exp;
branches;
next	1.4.2.8;

1.4.2.8
date	2004.06.05.23.10.47;	author niklas;	state Exp;
branches;
next	;

1.6.2.1
date	2002.06.11.03.35.36;	author art;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2002.10.29.00.28.02;	author art;	state Exp;
branches;
next	1.6.2.3;

1.6.2.3
date	2003.05.19.21.49.41;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.38
log
@move mem.c to hppa directory like every other arch.
(probably landed in dev because it has support for this viper thing,
but i like consistency for the /dev/null parts.)
ok kettenis
@
text
@/*	$OpenBSD: mem.c,v 1.37 2016/08/01 15:58:22 tedu Exp $	*/

/*
 * Copyright (c) 1998-2004 Michael Shalayeff
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR OR HIS RELATIVES BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */
/*
 * Copyright (c) 1991,1992,1994, The University of Utah and
 * the Computer Systems Laboratory (CSL).  All rights reserved.
 *
 * Subject to your agreements with CMU,
 * permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * THE UNIVERSITY OF UTAH AND CSL ALLOW FREE USE OF THIS SOFTWARE IN ITS "AS
 * IS" CONDITION.  THE UNIVERSITY OF UTAH AND CSL DISCLAIM ANY LIABILITY OF
 * ANY KIND FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * CSL requests users of this software to return to csl-dist@@cs.utah.edu any
 * improvements that they make and grant CSL redistribution rights.
 *
 *	Utah $Hdr: mem.c 1.9 94/12/16$
 */
/*
 * Mach Operating System
 * Copyright (c) 1992 Carnegie Mellon University
 * All Rights Reserved.
 *
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/malloc.h>
#include <sys/proc.h>
#include <sys/uio.h>
#include <sys/types.h>
#include <sys/device.h>
#include <sys/errno.h>
#include <sys/ioctl.h>
#include <sys/file.h>

#include <uvm/uvm_extern.h>

#include <machine/conf.h>
#include <machine/bus.h>
#include <machine/iomod.h>
#include <machine/autoconf.h>
#include <machine/pmap.h>

#include <hppa/dev/cpudevs.h>
#include <hppa/dev/viper.h>

#define	VIPER_HPA	0xfffbf000

/* registers on the PCXL2 MIOC */
struct l2_mioc {
	u_int32_t	pad[0x20];	/* 0x000 */
	u_int32_t	mioc_control;	/* 0x080 MIOC control bits */
	u_int32_t	mioc_status;	/* 0x084 MIOC status bits */
	u_int32_t	pad1[6];	/* 0x088 */
	u_int32_t	sltcv;		/* 0x0a0 L2 cache control */
#define	SLTCV_AVWL	0x00002000	/* extra cycle for addr valid write low */
#define	SLTCV_UP4COUT	0x00001000	/* update cache on CPU castouts */
#define	SLTCV_EDCEN	0x08000000	/* enable error correction */
#define	SLTCV_EDTAG	0x10000000	/* enable diagtag */
#define	SLTCV_CHKTP	0x20000000	/* enable parity checking */
#define	SLTCV_LOWPWR	0x40000000	/* low power mode */
#define	SLTCV_ENABLE	0x80000000	/* enable L2 cache */
#define	SLTCV_BITS	"\020\15avwl\16up4cout\24edcen\25edtag\26chktp\27lowpwr\30l2ena"
	u_int32_t	tagmask;	/* 0x0a4 L2 cache tag mask */
	u_int32_t	diagtag;	/* 0x0a8 L2 invalidates tag */
	u_int32_t	sltestat;	/* 0x0ac L2 last logged tag read */
	u_int32_t	slteadd;	/* 0x0b0 L2 pa of -- " -- */
	u_int32_t	pad2[3];	/* 0x0b4 */
	u_int32_t	mtcv;		/* 0x0c0 MIOC timings */
	u_int32_t	ref;		/* 0x0cc MIOC refresh timings */
	u_int32_t	pad3[4];	/* 0x0d0 */
	u_int32_t	mderradd;	/* 0x0e0 addr of most evil mem error */
	u_int32_t	pad4;		/* 0x0e4 */
	u_int32_t	dmaerr;		/* 0x0e8 addr of most evil dma error */
	u_int32_t	dioerr;		/* 0x0ec addr of most evil dio error */
	u_int32_t	gsc_timeout;	/* 0x0f0 1-compl of GSC timeout delay */
	u_int32_t	hidmamem;	/* 0x0f4 amount of phys mem installed */
	u_int32_t	pad5[2];	/* 0x0f8 */
	u_int32_t	memcomp[16];	/* 0x100 memory address comparators */
	u_int32_t	memmask[16];	/* 0x140 masks for -- " -- */
	u_int32_t	memtest;	/* 0x180 test address decoding */
	u_int32_t	pad6[0xf];	/* 0x184 */
	u_int32_t	outchk;		/* 0x1c0 address decoding output */
	u_int32_t	pad7[0x168];	/* 0x200 */
	u_int32_t	gsc15x_config;	/* 0x7a0 writev enable */
};

struct mem_softc {
	struct device sc_dev;

	volatile struct vi_trs *sc_vp;
	volatile struct l2_mioc *sc_l2;
};

int	memmatch(struct device *, void *, void *);
void	memattach(struct device *, struct device *, void *);

struct cfattach mem_ca = {
	sizeof(struct mem_softc), memmatch, memattach
};

struct cfdriver mem_cd = {
	NULL, "mem", DV_DULL
};

caddr_t zeropage;

int
memmatch(struct device *parent, void *cfdata, void *aux)
{
	struct confargs *ca = aux;

	if (ca->ca_type.iodc_type != HPPA_TYPE_MEMORY ||
	    ca->ca_type.iodc_sv_model != HPPA_MEMORY_PDEP)
		return 0;

	return 1;
}

void
memattach(struct device *parent, struct device *self, void *aux)
{
	struct pdc_iodc_minit pdc_minit PDC_ALIGNMENT;
	struct mem_softc *sc = (struct mem_softc *)self;
	struct confargs *ca = aux;
	int err;

	printf (":");

	/* XXX check if we are dealing w/ Viper */
	if (ca->ca_hpa == (hppa_hpa_t)VIPER_HPA) {

		sc->sc_vp = (struct vi_trs *)
		    &((struct iomod *)ca->ca_hpa)->priv_trs;

		printf(" viper rev %x,", sc->sc_vp->vi_status.hw_rev);

		/* XXX other values seem to blow it up */
		if (sc->sc_vp->vi_status.hw_rev == 0) {
			u_int32_t vic;
			int s, settimeout;

			switch (cpu_hvers) {
			case HPPA_BOARD_HP705:
			case HPPA_BOARD_HP710:
			case HPPA_BOARD_HP715_33:
			case HPPA_BOARD_HP715S_33:
			case HPPA_BOARD_HP715T_33:
			case HPPA_BOARD_HP715_50:
			case HPPA_BOARD_HP715S_50:
			case HPPA_BOARD_HP715T_50:
			case HPPA_BOARD_HP715_75:
			case HPPA_BOARD_HP720:
			case HPPA_BOARD_HP725_50:
			case HPPA_BOARD_HP725_75:
			case HPPA_BOARD_HP730_66:
			case HPPA_BOARD_HP750_66:
				settimeout = 1;
				break;
			default:
				settimeout = 0;
				break;
			}
			if (sc->sc_dev.dv_cfdata->cf_flags & 1)
				settimeout = !settimeout;

#ifdef DEBUG
			printf(" ctrl %b", VI_CTRL, VI_CTRL_BITS);
#endif
			s = splhigh();
			vic = VI_CTRL;
			vic &= ~VI_CTRL_CORE_DEN;
			vic &= ~VI_CTRL_SGC0_DEN;
			vic &= ~VI_CTRL_SGC1_DEN;
			vic |=  VI_CTRL_EISA_DEN;
			vic |=  VI_CTRL_CORE_PRF;

			if (settimeout && (vic & VI_CTRL_VSC_TOUT) == 0)
				vic |= (850 << 19);	/* clks */

			sc->sc_vp->vi_control = vic;

			__asm volatile("stwas %1, 0(%0)"
			    :: "r" (&VI_CTRL), "r" (vic) : "memory");
			splx(s);
#ifdef DEBUG
			printf (" >> %b,", vic, VI_CTRL_BITS);
#endif
		} else {
			/* set at least VI_CTRL_EISA_DEN ? */
		}
	} else
		sc->sc_vp = NULL;

	if ((err = pdc_call((iodcio_t)pdc, 0, PDC_IODC, PDC_IODC_NINIT,
	    &pdc_minit, ca->ca_hpa, PAGE0->imm_spa_size)) < 0)
		pdc_minit.max_spa = PAGE0->imm_max_mem;

	printf(" size %d", pdc_minit.max_spa / (1024*1024));
	if (pdc_minit.max_spa % (1024*1024))
		printf(".%d", pdc_minit.max_spa % (1024*1024));
	printf("MB");

	/* L2 cache controller is a part of the memory controller on PCXL2 */
	if (cpu_type == hpcxl2) {
		sc->sc_l2 = (struct l2_mioc *)ca->ca_hpa;
#ifdef DEBUG
		printf(", sltcv %b", sc->sc_l2->sltcv, SLTCV_BITS);
#endif
		/* sc->sc_l2->sltcv |= SLTCV_UP4COUT; */
		if (sc->sc_l2->sltcv & SLTCV_ENABLE) {
			u_int32_t tagmask = sc->sc_l2->tagmask >> 20;

			printf(", %dMB L2 cache", tagmask + 1);
		}
	}

	printf("\n");
}

void
viper_setintrwnd(u_int32_t mask)
{
	struct mem_softc *sc;

	sc = mem_cd.cd_devs[0];

	if (sc->sc_vp)
		sc->sc_vp->vi_intrwd = mask;
}

void
viper_eisa_en(void)
{
	struct mem_softc *sc;

	sc = mem_cd.cd_devs[0];
	if (sc->sc_vp) {
		u_int32_t vic;
		int s;

		s = splhigh();
		vic = VI_CTRL;
		vic &= ~VI_CTRL_EISA_DEN;
		sc->sc_vp->vi_control = vic;
		__asm volatile("stwas %1, 0(%0)"
		    :: "r" (&VI_CTRL), "r" (vic) : "memory");
		splx(s);
	}
}

int
mmopen(dev_t dev, int flag, int ioflag, struct proc *p)
{
	return (0);
}

int
mmclose(dev_t dev, int flag, int mode, struct proc *p)
{
	return (0);
}

int
mmrw(dev_t dev, struct uio *uio, int flags)
{
	struct iovec *iov;
	vaddr_t	v, o;
	int error = 0;
	size_t c;

	while (uio->uio_resid > 0 && error == 0) {
		iov = uio->uio_iov;
		if (iov->iov_len == 0) {
			uio->uio_iov++;
			uio->uio_iovcnt--;
			if (uio->uio_iovcnt < 0)
				panic("mmrw");
			continue;
		}
		switch (minor(dev)) {

		case 0:				/*  /dev/mem  */

			/* If the address isn't in RAM, bail. */
			v = uio->uio_offset;
			if (atop(v) > physmem) {
				error = EFAULT;
				/* this will break us out of the loop */
				continue;
			}
			c = ptoa(physmem) - v;
			c = ulmin(c, uio->uio_resid);
			error = uiomove((caddr_t)v, c, uio);
			break;

		case 1:				/*  /dev/kmem  */
			v = uio->uio_offset;
			o = v & PGOFSET;
			c = ulmin(uio->uio_resid, PAGE_SIZE - o);
			if (atop(v) > physmem && !uvm_kernacc((caddr_t)v,
			    c, (uio->uio_rw == UIO_READ) ? B_READ : B_WRITE)) {
				error = EFAULT;
				/* this will break us out of the loop */
				continue;
			}
			error = uiomove((caddr_t)v, c, uio);
			break;

		case 2:				/*  /dev/null  */
			if (uio->uio_rw == UIO_WRITE)
				uio->uio_resid = 0;
			return (0);

		case 12:			/*  /dev/zero  */
			/* Write to /dev/zero is ignored. */
			if (uio->uio_rw == UIO_WRITE) {
				uio->uio_resid = 0;
				return (0);
			}
			/*
			 * On the first call, allocate and zero a page
			 * of memory for use with /dev/zero.
			 */
			if (zeropage == NULL) 
				zeropage = malloc(PAGE_SIZE, M_TEMP,
				    M_WAITOK | M_ZERO);
			c = ulmin(iov->iov_len, PAGE_SIZE);
			error = uiomove(zeropage, c, uio);
			break;

		default:
			return (ENXIO);
		}
	}

	return (error);
}

paddr_t
mmmmap(dev_t dev, off_t off, int prot)
{
	if (minor(dev) != 0)
		return (-1);

	/*
	 * Allow access only in RAM.
	 */
#if 0
	if (off < ptoa(firstusablepage) ||
	    off >= ptoa(lastusablepage + 1))
		return (-1);
#endif
	return (off);
}

int
mmioctl(dev_t dev, u_long cmd, caddr_t data, int flags, struct proc *p)
{
	return (EOPNOTSUPP);
}
@


1.37
log
@bring the light of ansi to a few more files
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.36 2015/02/10 22:44:35 miod Exp $	*/
@


1.36
log
@Convert to uiomove().
ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.34 2014/04/08 09:34:22 mpi Exp $	*/
d159 1
a159 4
memmatch(parent, cfdata, aux)
	struct device *parent;
	void *cfdata;
	void *aux;
d161 1
a161 1
	register struct confargs *ca = aux;
d171 1
a171 4
memattach(parent, self, aux)
	struct device *parent;
	struct device *self;
	void *aux;
d272 1
a272 2
viper_setintrwnd(mask)
	u_int32_t mask;
d274 1
a274 1
	register struct mem_softc *sc;
d283 1
a283 1
viper_eisa_en()
d303 1
a303 5
mmopen(dev, flag, ioflag, p)
	dev_t dev;
	int flag;
	int ioflag;
	struct proc *p;
a307 1
/*ARGSUSED*/
d309 1
a309 4
mmclose(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
d315 1
a315 4
mmrw(dev, uio, flags)
	dev_t dev;
	struct uio *uio;
	int flags;
d391 1
a391 4
mmmmap(dev, off, prot)
	dev_t dev;
	off_t off;
	int prot;
d408 1
a408 6
mmioctl(dev, cmd, data, flags, p)
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flags;
	struct proc *p;
@


1.35
log
@First step towards making uiomove() take a size_t size argument:
- rename uiomove() to uiomovei() and update all its users.
- introduce uiomove(), which is similar to uiomovei() but with a size_t.
- rewrite uiomovei() as an uiomove() wrapper.
ok kettenis@@
@
text
@d335 1
a335 1
	struct iovec	*iov;
d338 1
a338 1
	u_int	c;
d361 2
a362 2
			c = min(c, uio->uio_resid);
			error = uiomovei((caddr_t)v, c, uio);
d368 1
a368 1
			c = min(uio->uio_resid, (int)(PAGE_SIZE - o));
d375 1
a375 1
			error = uiomovei((caddr_t)v, c, uio);
d396 2
a397 2
			c = min(iov->iov_len, PAGE_SIZE);
			error = uiomovei(zeropage, c, uio);
@


1.34
log
@Less <uvm/uvm.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.33 2014/03/29 18:09:29 guenther Exp $	*/
d362 1
a362 1
			error = uiomove((caddr_t)v, c, uio);
d375 1
a375 1
			error = uiomove((caddr_t)v, c, uio);
d397 1
a397 1
			error = uiomove(zeropage, c, uio);
@


1.33
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.32 2010/12/26 15:40:59 miod Exp $	*/
d86 1
a86 1
#include <uvm/uvm.h>
@


1.32
log
@Kill pmap_phys_address(), and force every driver's mmap() routine to return
a physical address [more precisely, something suitable to pass to pmap_enter()'sphysical address argument].

This allows MI drivers to implement mmap() routines without having to know
about the pmap_phys_address() implementation and #ifdef obfuscation.
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.31 2009/02/04 17:21:23 miod Exp $	*/
d239 1
a239 1
			__asm __volatile("stwas %1, 0(%0)"
d303 1
a303 1
		__asm __volatile("stwas %1, 0(%0)"
@


1.31
log
@On systems with viper memory controllers, always print its revision,
and allow asp interrupts to pass through even if not revision 0.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.30 2007/09/22 16:21:32 krw Exp $	*/
d425 1
a425 1
	return (atop(off));
@


1.30
log
@M_ZERO -> bzero.

ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.29 2007/09/22 09:57:40 martin Exp $	*/
d192 2
d200 2
d209 1
d212 2
a222 1
			printf(" viper rev %x,", sc->sc_vp->vi_status.hw_rev);
d245 3
a247 2
		} else
			sc->sc_vp = NULL;
@


1.29
log
@replace even more ctob and btoc with ptoa and atop respectively plus
uvm_extern.h where needed
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.28 2006/05/29 08:09:16 mickey Exp $	*/
d386 3
a388 4
			if (zeropage == NULL) {
				zeropage = malloc(PAGE_SIZE, M_TEMP, M_WAITOK);
				bzero(zeropage, PAGE_SIZE);
			}
@


1.28
log
@allow ints for older asp; found on 710 @@session; tested on 710, 715/33 (miod), 735/125 (graham gower)
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.27 2005/11/28 20:13:08 martin Exp $	*/
d348 1
a348 1
			if (btoc(v) > physmem) {
d353 1
a353 1
			c = ctob(physmem) - v;
d362 1
a362 1
			if (btoc(v) > physmem && !uvm_kernacc((caddr_t)v,
d415 2
a416 2
	if (off < ctob(firstusablepage) ||
	    off >= ctob(lastusablepage + 1))
@


1.27
log
@use atop(), remove last traces of Mach macros from hppa and hppa64
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.26 2004/09/19 01:30:11 mickey Exp $	*/
d279 1
a279 1
		sc->sc_vp->vi_intrwd;
@


1.26
log
@turn totalphysmem into physmem and name old physmem into smth it really is
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.25 2004/04/07 18:24:19 mickey Exp $	*/
d419 1
a419 1
	return (btop(off));
@


1.25
log
@update copyright; miod@@ is fine w/ files where he holds it too
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.24 2004/03/20 18:50:36 mickey Exp $	*/
a327 1
	extern u_int totalphysmem;
d348 1
a348 1
			if (btoc(v) > totalphysmem) {
d353 1
a353 1
			c = ctob(totalphysmem) - v;
d362 1
a362 1
			if (btoc(v) > totalphysmem && !uvm_kernacc((caddr_t)v,
@


1.24
log
@add the rest of the oosiop machines for timeout programming except for /99s which i ain't sure even exist
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.23 2004/03/17 20:55:09 miod Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998-2002 Michael Shalayeff
d19 8
a26 7
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF MIND,
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@


1.23
log
@Otto@@ confirms 715/50 needs the viper timeout kluge to be really happy.
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.22 2004/03/17 00:41:08 miod Exp $	*/
d197 3
a199 1
			/* probably all oosiop-equipped machines */
d201 5
a205 1
			case HPPA_BOARD_HP715_33:
d231 1
@


1.22
log
@Tweak the viper control register:
- do not enable EISA bus grant until we really attach eisa devices;
- on some machines, booting from disk would hang in either "mem0" or "cpu0"
  probe. Tinkering eventually pointed out that setting a non-zero non-rachitic
  value for the viper's bus error timeout would help.

Right now, this kluge will only be enabled by default on a known list of
affected machines (which may grow over time...), and device attachment flags
allow users to try the other behaviour if necessary.

Discussed and crafted with mickey@@, "it's gross" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.21 2003/09/25 22:13:19 mickey Exp $	*/
d198 1
@


1.21
log
@define pcxl2's mioc regs and devise l2 cache size on pcxl2 from there
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.20 2003/04/07 20:18:34 mickey Exp $	*/
d194 13
a206 1
			int s;
d217 1
d219 4
@


1.20
log
@oops
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.19 2003/04/07 17:24:08 mickey Exp $	*/
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Michael Shalayeff.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d98 39
d141 1
d225 17
a241 1
	printf("MB\n");
@


1.19
log
@enable viper touching again.
change the bitfield struct into just a word and
a bunch of defines and define the _BITS.
only program those that revision is 0 since otherwise it seems to
comatize the perhaps not so viper other ones (even on the same hpa).
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.18 2003/04/07 17:14:59 mickey Exp $	*/
d286 2
a287 2
			if (!uvm_kernacc((caddr_t)v, c,
			    (uio->uio_rw == UIO_READ) ? B_READ : B_WRITE)) {
@


1.18
log
@do not limit the kmem to just the physmem
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.17 2003/01/22 14:44:55 mickey Exp $	*/
d144 2
a145 2
	register struct confargs *ca = aux;
	register struct mem_softc *sc = (struct mem_softc *)self;
d156 3
a158 3
		printf(" viper rev %x,", sc->sc_vp->vi_status.hw_rev);
#if 0
		{
d161 4
a164 2
			printf(" ctrl %b", VI_CTRL, VIPER_BITS);

d166 8
a173 6
			VI_CTRL |= VI_CTRL_ANYDEN;
			((struct vi_ctrl *)&VI_CTRL)->core_den = 0;
			((struct vi_ctrl *)&VI_CTRL)->sgc0_den = 0;
			((struct vi_ctrl *)&VI_CTRL)->sgc1_den = 0;
			((struct vi_ctrl *)&VI_CTRL)->core_prf = 1;
			sc->sc_vp->vi_control = VI_CTRL;
d175 2
a176 3

			printf (" >> %b,", VI_CTRL, VIPER_BITS);
		}
d178 2
d208 1
a208 1
	register struct mem_softc *sc;
d211 12
a222 4
#if 0
	if (sc->sc_vp)
		((struct vi_ctrl *)&VI_CTRL)->eisa_den = 0;
#endif
@


1.17
log
@mop up after deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.16 2003/01/22 00:21:38 deraadt Exp $	*/
d241 1
a241 1
	int rw, error = 0;
d273 2
a274 3
			rw = (uio->uio_rw == UIO_READ) ? B_READ : B_WRITE;
			if (btoc(v) > totalphysmem &&
			    !uvm_kernacc((caddr_t)v, c, rw)) {
@


1.16
log
@minor cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.15 2002/10/25 18:46:35 mickey Exp $	*/
d172 1
a172 1
			printf (" >> %b, ", VI_CTRL, VIPER_BITS);
d182 1
a182 1
	printf("size %d", pdc_minit.max_spa / (1024*1024));
@


1.15
log
@allow reading the direct mapped segment through the kmem
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.14 2002/09/05 21:36:28 mickey Exp $	*/
d154 1
a154 1
			&((struct iomod *)ca->ca_hpa)->priv_trs;
d179 1
a179 1
			    &pdc_minit, ca->ca_hpa, PAGE0->imm_spa_size)) < 0)
d182 1
a182 1
	printf (" size %d", pdc_minit.max_spa / (1024*1024));
d184 2
a185 2
		printf (".%d", pdc_minit.max_spa % (1024*1024));
	printf ("MB\n");
@


1.14
log
@things [in pmap] have changed, kundun
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.13 2002/06/06 16:32:33 mickey Exp $	*/
d274 2
a275 1
			if (!uvm_kernacc((caddr_t)v, c, rw)) {
@


1.13
log
@do not poke into the page0 for now
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.12 2002/03/16 22:05:19 mickey Exp $	*/
a119 3
/* A lock for the vmmap, 16-byte aligned as PA-RISC semaphores must be. */
static volatile int32_t vmmap_lock __attribute__ ((aligned (32))) = 1;
extern char *vmmap;
a238 1
	extern vaddr_t virtual_avail;
a239 1
	int32_t lockheld = 0;
a240 1
	vm_prot_t prot;
d264 3
a266 37

			/*
			 * If the address is inside our large
			 * directly-mapped kernel BTLB entry,
			 * use kmem instead.
			 */
			if (v < virtual_avail)
				goto use_kmem;

			/*
			 * If we don't already hold the vmmap lock,
			 * acquire it.
			 */
			while (!lockheld) {
				__asm __volatile("ldcws 0(%1), %0\n\tsync"
				    : "=r" (lockheld) : "r" (&vmmap_lock));
				if (lockheld)
					break;
				error = tsleep((caddr_t)&vmmap_lock,
				    PZERO | PCATCH,
				    "mmrw", 0);
				if (error)
					return (error);
			}

			/* Temporarily map the memory at vmmap. */
			prot = uio->uio_rw == UIO_READ ? VM_PROT_READ :
			    VM_PROT_WRITE;
			pmap_enter(pmap_kernel(), (vaddr_t)vmmap,
			    trunc_page(v), prot, prot|PMAP_WIRED);
			pmap_update(pmap_kernel());
			o = v & PGOFSET;
			c = min(uio->uio_resid, (int)(PAGE_SIZE - o));
			error = uiomove((caddr_t)vmmap + o, c, uio);
			pmap_remove(pmap_kernel(), (vaddr_t)vmmap,
			    (vaddr_t)vmmap + PAGE_SIZE);
			pmap_update(pmap_kernel());
a270 1
use_kmem:
d298 2
a299 3
				zeropage = (caddr_t)
				    malloc(PAGE_SIZE, M_TEMP, M_WAITOK);
				memset(zeropage, 0, PAGE_SIZE);
a307 7
	}

	/* If we hold the vmmap lock, release it. */
	if (lockheld) {
		__asm __volatile("sync\n\tstw	%1, 0(%0)"
		    :: "r" (&vmmap_lock), "r" (1));
		wakeup((caddr_t)&vmmap_lock);
@


1.12
log
@no need to include sys/conf.h w/ machine/conf.h; from David Krause
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.11 2002/03/16 00:34:56 mickey Exp $	*/
d209 1
a209 1

d212 1
@


1.11
log
@move cdev_decl out and kill some ugly print and some spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.10 2002/03/15 21:44:18 mickey Exp $	*/
a80 1
#include <sys/conf.h>
@


1.10
log
@rewrite a pmap to use multilevel page tables.
lower 12 bits contain the perms, no unused bits left,
but a couple for off-tlb use (as the ref implemented now).
do not use the hvt, which might get some use later
if proven to speed thigs up, tlb handlers would po
another dozen of insns though, but if that's worth its...
move on the data seg and map kernel text rdonly (idea form fredette),
since all of the page0 mods done before that we are all fine
except for some viper fluff, but later w/ that.
this also picks up a bit more of ddb magic for bpt and ss.
tlb handlers can use a little bit more of attention,
but things, visually, seem to be much faster already, --
sorry, no benchmarks for now.

* effort sponsored in part by the `henry st. old ale house'
* and mr.pete and mr.lee in particular in thier generous entrirety.
* the proj took a little more that 72man*h as it was expected,
* but within murhy's law estimations.
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.9 2002/03/14 01:26:31 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998,1999 Michael Shalayeff
d50 1
a50 1
 * 	Utah $Hdr: mem.c 1.9 94/12/16$
d52 1
a52 1
/* 
d56 1
a56 1
 * 
d62 1
a62 1
 * 
d66 1
a66 1
 * 
d68 1
a68 1
 * 
d73 2
a74 2
 * 
 * any improvements or extensions that they make and grant Carnegie Mellon 
d93 1
d121 2
a122 4
#define mmread  mmrw
#define mmwrite mmrw
cdev_decl(mm);

a125 3
/* A lock for the vmmap, 16-byte aligned as PA-RISC semaphores must be. */
static int32_t vmmap_lock __attribute__ ((aligned (16))) = 1;

d127 1
a127 1
memmatch(parent, cfdata, aux)   
d137 1
a155 1
		int s;
d160 1
a160 4
		printf (" viper rev %x, ctrl %b",
			sc->sc_vp->vi_status.hw_rev,
			VI_CTRL, VIPER_BITS);
		s = splhigh();
d162 16
a177 10
		VI_CTRL |= VI_CTRL_ANYDEN;
		((struct vi_ctrl *)&VI_CTRL)->core_den = 0;
		((struct vi_ctrl *)&VI_CTRL)->sgc0_den = 0;
		((struct vi_ctrl *)&VI_CTRL)->sgc1_den = 0;
		((struct vi_ctrl *)&VI_CTRL)->core_prf = 1;
		sc->sc_vp->vi_control = VI_CTRL;
#endif
		splx(s);
#ifdef DEBUG
		printf (" >> %b", VI_CTRL, VIPER_BITS);
d228 1
a228 1
	dev_t dev;  
d243 1
a243 1
	struct iovec 	*iov;
d248 1
a248 1
	u_int 	c;
d272 2
a273 2
			 * If the address is inside our large 
			 * directly-mapped kernel BTLB entry, 
d288 1
a288 1
				error = tsleep((caddr_t)&vmmap_lock, 
d333 2
a334 2
			} 
			/* 
d366 1
a366 1
	int prot;  
@


1.9
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.8 2002/02/28 22:18:03 mickey Exp $	*/
a166 1

d168 1
d175 1
@


1.8
log
@forgot viper_hpa
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.7 2002/02/02 21:06:46 mickey Exp $	*/
d109 2
a110 2
int	memmatch __P((struct device *, void *, void *));
void	memattach __P((struct device *, struct device *, void *));
@


1.7
log
@implement the rest of /dev/mem devices; from netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.6 2001/11/01 12:13:46 art Exp $	*/
d100 2
@


1.6
log
@Change d_mmap in struct cdevsw from:
        int     (*d_mmap)       __P((dev_t, int, int));
to:
	paddr_t	(*d_mmap)	__P((dev_t, off_t, int));

This allows us to mmap devices past 4GB offsets.
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.5 2001/05/05 20:56:36 art Exp $	*/
d79 6
a86 2

#include <sys/conf.h>
a87 3
#include <sys/systm.h>
#include <sys/uio.h>
#include <sys/buf.h>
d90 2
a91 1
#include <sys/proc.h>
d96 1
d122 1
d125 3
d239 8
a246 3
	register u_int	 	c;
	register struct iovec 	*iov;
	int 			error = 0;
d259 46
a304 2
		/* minor device 0 is physical memory */
		case 0:
d306 13
a318 2
		/* minor device 1 is kernel memory */
		case 1:
d321 1
a321 1
		case 2:
d326 2
a327 1
		case 12:
d329 11
a339 2
				c = iov->iov_len;
				break;
d343 2
a344 1
			continue;
a347 6
		if (error)
			break;
		iov->iov_base += c;
		iov->iov_len -= c;
		uio->uio_offset += c;
		uio->uio_resid -= c;
d349 8
@


1.6.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.6 2001/11/01 12:13:46 art Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998-2002 Michael Shalayeff
d50 1
a50 1
 *	Utah $Hdr: mem.c 1.9 94/12/16$
d52 1
a52 1
/*
d56 1
a56 1
 *
d62 1
a62 1
 *
d66 1
a66 1
 *
d68 1
a68 1
 *
d73 2
a74 2
 *
 * any improvements or extensions that they make and grant Carnegie Mellon
a78 5
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/malloc.h>
#include <sys/proc.h>
#include <sys/uio.h>
d81 2
d84 3
d89 1
a90 3
#include <uvm/uvm.h>

#include <machine/conf.h>
a93 1
#include <machine/pmap.h>
a97 2
#define	VIPER_HPA	0xfffbf000

d104 2
a105 2
int	memmatch(struct device *, void *, void *);
void	memattach(struct device *, struct device *, void *);
d115 4
a118 3
/* A lock for the vmmap, 16-byte aligned as PA-RISC semaphores must be. */
static volatile int32_t vmmap_lock __attribute__ ((aligned (32))) = 1;
extern char *vmmap;
d122 1
a122 1
memmatch(parent, cfdata, aux)
a131 1

d150 1
d155 14
a168 18
		printf(" viper rev %x,", sc->sc_vp->vi_status.hw_rev);
#if 0
		{
			int s;

			printf(" ctrl %b", VI_CTRL, VIPER_BITS);

			s = splhigh();
			VI_CTRL |= VI_CTRL_ANYDEN;
			((struct vi_ctrl *)&VI_CTRL)->core_den = 0;
			((struct vi_ctrl *)&VI_CTRL)->sgc0_den = 0;
			((struct vi_ctrl *)&VI_CTRL)->sgc1_den = 0;
			((struct vi_ctrl *)&VI_CTRL)->core_prf = 1;
			sc->sc_vp->vi_control = VI_CTRL;
			splx(s);

			printf (" >> %b, ", VI_CTRL, VIPER_BITS);
		}
d201 1
a201 1
#if 0
a203 1
#endif
d219 1
a219 1
	dev_t dev;
d232 3
a234 8
	extern u_int totalphysmem;
	extern vaddr_t virtual_avail;
	struct iovec	*iov;
	int32_t lockheld = 0;
	vaddr_t	v, o;
	vm_prot_t prot;
	int rw, error = 0;
	u_int	c;
d247 2
a248 46
		case 0:				/*  /dev/mem  */

			/* If the address isn't in RAM, bail. */
			v = uio->uio_offset;
			if (btoc(v) > totalphysmem) {
				error = EFAULT;
				/* this will break us out of the loop */
				continue;
			}

			/*
			 * If the address is inside our large
			 * directly-mapped kernel BTLB entry,
			 * use kmem instead.
			 */
			if (v < virtual_avail)
				goto use_kmem;

			/*
			 * If we don't already hold the vmmap lock,
			 * acquire it.
			 */
			while (!lockheld) {
				__asm __volatile("ldcws 0(%1), %0\n\tsync"
				    : "=r" (lockheld) : "r" (&vmmap_lock));
				if (lockheld)
					break;
				error = tsleep((caddr_t)&vmmap_lock,
				    PZERO | PCATCH,
				    "mmrw", 0);
				if (error)
					return (error);
			}

			/* Temporarily map the memory at vmmap. */
			prot = uio->uio_rw == UIO_READ ? VM_PROT_READ :
			    VM_PROT_WRITE;
			pmap_enter(pmap_kernel(), (vaddr_t)vmmap,
			    trunc_page(v), prot, prot|PMAP_WIRED);
			pmap_update(pmap_kernel());
			o = v & PGOFSET;
			c = min(uio->uio_resid, (int)(PAGE_SIZE - o));
			error = uiomove((caddr_t)vmmap + o, c, uio);
			pmap_remove(pmap_kernel(), (vaddr_t)vmmap,
			    (vaddr_t)vmmap + PAGE_SIZE);
			pmap_update(pmap_kernel());
d250 2
a251 13

		case 1:				/*  /dev/kmem  */
			v = uio->uio_offset;
use_kmem:
			o = v & PGOFSET;
			c = min(uio->uio_resid, (int)(PAGE_SIZE - o));
			rw = (uio->uio_rw == UIO_READ) ? B_READ : B_WRITE;
			if (!uvm_kernacc((caddr_t)v, c, rw)) {
				error = EFAULT;
				/* this will break us out of the loop */
				continue;
			}
			error = uiomove((caddr_t)v, c, uio);
d254 1
a254 1
		case 2:				/*  /dev/null  */
d259 1
a259 2
		case 12:			/*  /dev/zero  */
			/* Write to /dev/zero is ignored. */
d261 2
a262 11
				uio->uio_resid = 0;
				return (0);
			}
			/*
			 * On the first call, allocate and zero a page
			 * of memory for use with /dev/zero.
			 */
			if (zeropage == NULL) {
				zeropage = (caddr_t)
				    malloc(PAGE_SIZE, M_TEMP, M_WAITOK);
				memset(zeropage, 0, PAGE_SIZE);
d266 1
a266 2
			break;

d270 6
a276 8

	/* If we hold the vmmap lock, release it. */
	if (lockheld) {
		__asm __volatile("sync\n\tstw	%1, 0(%0)"
		    :: "r" (&vmmap_lock), "r" (1));
		wakeup((caddr_t)&vmmap_lock);
	}

d284 1
a284 1
	int prot;
@


1.6.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.6.2.1 2002/06/11 03:35:36 art Exp $	*/
d120 3
d242 1
d244 1
d246 1
d270 37
a306 3
			c = ctob(totalphysmem) - v;
			c = min(c, uio->uio_resid);
			error = uiomove((caddr_t)v, c, uio);
d311 1
d315 1
a315 2
			if (btoc(v) > totalphysmem &&
			    !uvm_kernacc((caddr_t)v, c, rw)) {
d339 3
a341 2
				zeropage = malloc(PAGE_SIZE, M_TEMP, M_WAITOK);
				bzero(zeropage, PAGE_SIZE);
d350 7
@


1.6.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d144 2
a145 2
	struct mem_softc *sc = (struct mem_softc *)self;
	struct confargs *ca = aux;
d154 1
a154 1
		    &((struct iomod *)ca->ca_hpa)->priv_trs;
d156 3
a158 3
		/* XXX other values seem to blow it up */
		if (sc->sc_vp->vi_status.hw_rev == 0) {
			u_int32_t vic;
d161 2
a162 4
			printf(" viper rev %x,", sc->sc_vp->vi_status.hw_rev);
#ifdef DEBUG
			printf(" ctrl %b", VI_CTRL, VI_CTRL_BITS);
#endif
d164 6
a169 8
			vic = VI_CTRL;
			vic &= ~VI_CTRL_CORE_DEN;
			vic &= ~VI_CTRL_SGC0_DEN;
			vic &= ~VI_CTRL_SGC1_DEN;
			vic |=  VI_CTRL_CORE_PRF;
			sc->sc_vp->vi_control = vic;
			__asm __volatile("stwas %1, 0(%0)"
			    :: "r" (&VI_CTRL), "r" (vic) : "memory");
d171 3
a173 2
#ifdef DEBUG
			printf (" >> %b,", vic, VI_CTRL_BITS);
a174 2
		} else
			sc->sc_vp = NULL;
d179 1
a179 1
	    &pdc_minit, ca->ca_hpa, PAGE0->imm_spa_size)) < 0)
d182 1
a182 1
	printf(" size %d", pdc_minit.max_spa / (1024*1024));
d184 2
a185 2
		printf(".%d", pdc_minit.max_spa % (1024*1024));
	printf("MB\n");
d203 1
a203 1
	struct mem_softc *sc;
d206 4
a209 12
	if (sc->sc_vp) {
		u_int32_t vic;
		int s;

		s = splhigh();
		vic = VI_CTRL;
		vic &= ~VI_CTRL_EISA_DEN;
		sc->sc_vp->vi_control = vic;
		__asm __volatile("stwas %1, 0(%0)"
		    :: "r" (&VI_CTRL), "r" (vic) : "memory");
		splx(s);
	}
d241 1
a241 1
	int error = 0;
d273 3
a275 2
			if (btoc(v) > totalphysmem && !uvm_kernacc((caddr_t)v,
			    c, (uio->uio_rw == UIO_READ) ? B_READ : B_WRITE)) {
@


1.5
log
@Get rid of CLSIZE and all related stuff.
CLSIZE -> 1
CLBYTES -> PAGE_SIZE
OLOFSET -> PAGE_MASK
etc.
At the same time some archs needed some cleaning in vmparam.h so that
goes in at the same time.
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.4 1999/11/26 18:01:01 mickey Exp $	*/
d280 1
a280 1
int
d283 2
a284 1
	int off, prot;  
@


1.4
log
@hide in DEBUG some extra printings
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.3 1999/11/22 19:21:58 matthieu Exp $	*/
d264 1
a264 1
			c = min(iov->iov_len, CLBYTES);
@


1.4.2.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.4 1999/11/26 18:01:01 mickey Exp $	*/
d264 1
a264 1
			c = min(iov->iov_len, PAGE_SIZE);
@


1.4.2.2
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d280 1
a280 1
paddr_t
d283 1
a283 2
	off_t off;
	int prot;  
@


1.4.2.3
log
@Merge in trunk
@
text
@a78 6
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/conf.h>
#include <sys/malloc.h>
#include <sys/proc.h>
#include <sys/uio.h>
d81 2
d84 3
d89 1
a89 2

#include <uvm/uvm.h>
a93 1
#include <machine/pmap.h>
a97 2
#define	VIPER_HPA	0xfffbf000

a118 1
extern char *vmmap;
a120 3
/* A lock for the vmmap, 16-byte aligned as PA-RISC semaphores must be. */
static int32_t vmmap_lock __attribute__ ((aligned (16))) = 1;

d232 3
a234 8
	extern u_int totalphysmem;
	extern vaddr_t virtual_avail;
	struct iovec 	*iov;
	int32_t lockheld = 0;
	vaddr_t	v, o;
	vm_prot_t prot;
	int rw, error = 0;
	u_int 	c;
d247 2
a248 46
		case 0:				/*  /dev/mem  */

			/* If the address isn't in RAM, bail. */
			v = uio->uio_offset;
			if (btoc(v) > totalphysmem) {
				error = EFAULT;
				/* this will break us out of the loop */
				continue;
			}

			/*
			 * If the address is inside our large 
			 * directly-mapped kernel BTLB entry, 
			 * use kmem instead.
			 */
			if (v < virtual_avail)
				goto use_kmem;

			/*
			 * If we don't already hold the vmmap lock,
			 * acquire it.
			 */
			while (!lockheld) {
				__asm __volatile("ldcws 0(%1), %0\n\tsync"
				    : "=r" (lockheld) : "r" (&vmmap_lock));
				if (lockheld)
					break;
				error = tsleep((caddr_t)&vmmap_lock, 
				    PZERO | PCATCH,
				    "mmrw", 0);
				if (error)
					return (error);
			}

			/* Temporarily map the memory at vmmap. */
			prot = uio->uio_rw == UIO_READ ? VM_PROT_READ :
			    VM_PROT_WRITE;
			pmap_enter(pmap_kernel(), (vaddr_t)vmmap,
			    trunc_page(v), prot, prot|PMAP_WIRED);
			pmap_update(pmap_kernel());
			o = v & PGOFSET;
			c = min(uio->uio_resid, (int)(PAGE_SIZE - o));
			error = uiomove((caddr_t)vmmap + o, c, uio);
			pmap_remove(pmap_kernel(), (vaddr_t)vmmap,
			    (vaddr_t)vmmap + PAGE_SIZE);
			pmap_update(pmap_kernel());
d250 2
a251 13

		case 1:				/*  /dev/kmem  */
			v = uio->uio_offset;
use_kmem:
			o = v & PGOFSET;
			c = min(uio->uio_resid, (int)(PAGE_SIZE - o));
			rw = (uio->uio_rw == UIO_READ) ? B_READ : B_WRITE;
			if (!uvm_kernacc((caddr_t)v, c, rw)) {
				error = EFAULT;
				/* this will break us out of the loop */
				continue;
			}
			error = uiomove((caddr_t)v, c, uio);
d254 1
a254 1
		case 2:				/*  /dev/null  */
d259 1
a259 2
		case 12:			/*  /dev/zero  */
			/* Write to /dev/zero is ignored. */
d261 2
a262 11
				uio->uio_resid = 0;
				return (0);
			} 
			/* 
			 * On the first call, allocate and zero a page
			 * of memory for use with /dev/zero.
			 */
			if (zeropage == NULL) {
				zeropage = (caddr_t)
				    malloc(PAGE_SIZE, M_TEMP, M_WAITOK);
				memset(zeropage, 0, PAGE_SIZE);
d266 1
a266 2
			break;

d270 6
a276 8

	/* If we hold the vmmap lock, release it. */
	if (lockheld) {
		__asm __volatile("sync\n\tstw	%1, 0(%0)"
		    :: "r" (&vmmap_lock), "r" (1));
		wakeup((caddr_t)&vmmap_lock);
	}

@


1.4.2.4
log
@Merge in -current from about a week ago
@
text
@d4 1
a4 1
 * Copyright (c) 1998-2002 Michael Shalayeff
d50 1
a50 1
 *	Utah $Hdr: mem.c 1.9 94/12/16$
d52 1
a52 1
/*
d56 1
a56 1
 *
d62 1
a62 1
 *
d66 1
a66 1
 *
d68 1
a68 1
 *
d73 2
a74 2
 *
 * any improvements or extensions that they make and grant Carnegie Mellon
d81 1
a92 1
#include <machine/conf.h>
d109 2
a110 2
int	memmatch(struct device *, void *, void *);
void	memattach(struct device *, struct device *, void *);
d120 4
a123 2
/* A lock for the vmmap, 16-byte aligned as PA-RISC semaphores must be. */
static volatile int32_t vmmap_lock __attribute__ ((aligned (32))) = 1;
d127 3
d131 1
a131 1
memmatch(parent, cfdata, aux)
a140 1

d159 1
d164 14
a177 18
		printf(" viper rev %x,", sc->sc_vp->vi_status.hw_rev);
#if 0
		{
			int s;

			printf(" ctrl %b", VI_CTRL, VIPER_BITS);

			s = splhigh();
			VI_CTRL |= VI_CTRL_ANYDEN;
			((struct vi_ctrl *)&VI_CTRL)->core_den = 0;
			((struct vi_ctrl *)&VI_CTRL)->sgc0_den = 0;
			((struct vi_ctrl *)&VI_CTRL)->sgc1_den = 0;
			((struct vi_ctrl *)&VI_CTRL)->core_prf = 1;
			sc->sc_vp->vi_control = VI_CTRL;
			splx(s);

			printf (" >> %b, ", VI_CTRL, VIPER_BITS);
		}
d228 1
a228 1
	dev_t dev;
d243 1
a243 1
	struct iovec	*iov;
d248 1
a248 1
	u_int	c;
d272 2
a273 2
			 * If the address is inside our large
			 * directly-mapped kernel BTLB entry,
d288 1
a288 1
				error = tsleep((caddr_t)&vmmap_lock,
d333 2
a334 2
			}
			/*
d366 1
a366 1
	int prot;
@


1.4.2.5
log
@Sync the SMP branch with 3.3
@
text
@d120 3
d157 1
a157 1
		    &((struct iomod *)ca->ca_hpa)->priv_trs;
d175 1
a175 1
			printf (" >> %b,", VI_CTRL, VIPER_BITS);
d182 1
a182 1
	    &pdc_minit, ca->ca_hpa, PAGE0->imm_spa_size)) < 0)
d185 1
a185 1
	printf(" size %d", pdc_minit.max_spa / (1024*1024));
d187 2
a188 2
		printf(".%d", pdc_minit.max_spa % (1024*1024));
	printf("MB\n");
d209 1
a209 1
#if 0
a211 1
#endif
d241 1
d243 1
d245 1
d269 37
a305 3
			c = ctob(totalphysmem) - v;
			c = min(c, uio->uio_resid);
			error = uiomove((caddr_t)v, c, uio);
d310 1
d314 1
a314 2
			if (btoc(v) > totalphysmem &&
			    !uvm_kernacc((caddr_t)v, c, rw)) {
d338 3
a340 2
				zeropage = malloc(PAGE_SIZE, M_TEMP, M_WAITOK);
				bzero(zeropage, PAGE_SIZE);
d349 7
@


1.4.2.6
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.4.2.5 2003/03/27 23:26:53 niklas Exp $	*/
d144 2
a145 2
	struct mem_softc *sc = (struct mem_softc *)self;
	struct confargs *ca = aux;
d156 3
a158 3
		/* XXX other values seem to blow it up */
		if (sc->sc_vp->vi_status.hw_rev == 0) {
			u_int32_t vic;
d161 2
a162 4
			printf(" viper rev %x,", sc->sc_vp->vi_status.hw_rev);
#ifdef DEBUG
			printf(" ctrl %b", VI_CTRL, VI_CTRL_BITS);
#endif
d164 6
a169 8
			vic = VI_CTRL;
			vic &= ~VI_CTRL_CORE_DEN;
			vic &= ~VI_CTRL_SGC0_DEN;
			vic &= ~VI_CTRL_SGC1_DEN;
			vic |=  VI_CTRL_CORE_PRF;
			sc->sc_vp->vi_control = vic;
			__asm __volatile("stwas %1, 0(%0)"
			    :: "r" (&VI_CTRL), "r" (vic) : "memory");
d171 3
a173 2
#ifdef DEBUG
			printf (" >> %b,", vic, VI_CTRL_BITS);
a174 2
		} else
			sc->sc_vp = NULL;
d203 1
a203 1
	struct mem_softc *sc;
d206 4
a209 12
	if (sc->sc_vp) {
		u_int32_t vic;
		int s;

		s = splhigh();
		vic = VI_CTRL;
		vic &= ~VI_CTRL_EISA_DEN;
		sc->sc_vp->vi_control = vic;
		__asm __volatile("stwas %1, 0(%0)"
		    :: "r" (&VI_CTRL), "r" (vic) : "memory");
		splx(s);
	}
d241 1
a241 1
	int error = 0;
d273 3
a275 2
			if (btoc(v) > totalphysmem && !uvm_kernacc((caddr_t)v,
			    c, (uio->uio_rw == UIO_READ) ? B_READ : B_WRITE)) {
@


1.4.2.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d15 5
a102 39
/* registers on the PCXL2 MIOC */
struct l2_mioc {
	u_int32_t	pad[0x20];	/* 0x000 */
	u_int32_t	mioc_control;	/* 0x080 MIOC control bits */
	u_int32_t	mioc_status;	/* 0x084 MIOC status bits */
	u_int32_t	pad1[6];	/* 0x088 */
	u_int32_t	sltcv;		/* 0x0a0 L2 cache control */
#define	SLTCV_AVWL	0x00002000	/* extra cycle for addr valid write low */
#define	SLTCV_UP4COUT	0x00001000	/* update cache on CPU castouts */
#define	SLTCV_EDCEN	0x08000000	/* enable error correction */
#define	SLTCV_EDTAG	0x10000000	/* enable diagtag */
#define	SLTCV_CHKTP	0x20000000	/* enable parity checking */
#define	SLTCV_LOWPWR	0x40000000	/* low power mode */
#define	SLTCV_ENABLE	0x80000000	/* enable L2 cache */
#define	SLTCV_BITS	"\020\15avwl\16up4cout\24edcen\25edtag\26chktp\27lowpwr\30l2ena"
	u_int32_t	tagmask;	/* 0x0a4 L2 cache tag mask */
	u_int32_t	diagtag;	/* 0x0a8 L2 invalidates tag */
	u_int32_t	sltestat;	/* 0x0ac L2 last logged tag read */
	u_int32_t	slteadd;	/* 0x0b0 L2 pa of -- " -- */
	u_int32_t	pad2[3];	/* 0x0b4 */
	u_int32_t	mtcv;		/* 0x0c0 MIOC timings */
	u_int32_t	ref;		/* 0x0cc MIOC refresh timings */
	u_int32_t	pad3[4];	/* 0x0d0 */
	u_int32_t	mderradd;	/* 0x0e0 addr of most evil mem error */
	u_int32_t	pad4;		/* 0x0e4 */
	u_int32_t	dmaerr;		/* 0x0e8 addr of most evil dma error */
	u_int32_t	dioerr;		/* 0x0ec addr of most evil dio error */
	u_int32_t	gsc_timeout;	/* 0x0f0 1-compl of GSC timeout delay */
	u_int32_t	hidmamem;	/* 0x0f4 amount of phys mem installed */
	u_int32_t	pad5[2];	/* 0x0f8 */
	u_int32_t	memcomp[16];	/* 0x100 memory address comparators */
	u_int32_t	memmask[16];	/* 0x140 masks for -- " -- */
	u_int32_t	memtest;	/* 0x180 test address decoding */
	u_int32_t	pad6[0xf];	/* 0x184 */
	u_int32_t	outchk;		/* 0x1c0 address decoding output */
	u_int32_t	pad7[0x168];	/* 0x200 */
	u_int32_t	gsc15x_config;	/* 0x7a0 writev enable */
};

a106 1
	volatile struct l2_mioc *sc_l2;
d190 1
a190 17
	printf("MB");

	/* L2 cache controller is a part of the memory controller on PCXL2 */
	if (cpu_type == hpcxl2) {
		sc->sc_l2 = (struct l2_mioc *)ca->ca_hpa;
#ifdef DEBUG
		printf(", sltcv %b", sc->sc_l2->sltcv, SLTCV_BITS);
#endif
		/* sc->sc_l2->sltcv |= SLTCV_UP4COUT; */
		if (sc->sc_l2->sltcv & SLTCV_ENABLE) {
			u_int32_t tagmask = sc->sc_l2->tagmask >> 20;

			printf(", %dMB L2 cache", tagmask + 1);
		}
	}

	printf("\n");
@


1.4.2.8
log
@Merge with the trunk
@
text
@d4 1
a4 1
 * Copyright (c) 1998-2004 Michael Shalayeff
d19 7
a25 8
 * IN NO EVENT SHALL THE AUTHOR OR HIS RELATIVES BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
d194 1
a194 20
			int s, settimeout;

			switch (cpu_hvers) {
			case HPPA_BOARD_HP715_33:
			case HPPA_BOARD_HP715S_33:
			case HPPA_BOARD_HP715T_33:
			case HPPA_BOARD_HP715_50:
			case HPPA_BOARD_HP715S_50:
			case HPPA_BOARD_HP715T_50:
			case HPPA_BOARD_HP715_75:
			case HPPA_BOARD_HP725_50:
			case HPPA_BOARD_HP725_75:
				settimeout = 1;
				break;
			default:
				settimeout = 0;
				break;
			}
			if (sc->sc_dev.dv_cfdata->cf_flags & 1)
				settimeout = !settimeout;
a204 1
			vic |=  VI_CTRL_EISA_DEN;
a205 4

			if (settimeout && (vic & VI_CTRL_VSC_TOUT) == 0)
				vic |= (850 << 19);	/* clks */

a206 1

@


1.3
log
@add empty mmioctl() implementation for new /dev/mem interface for all
architectures.
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.2 1999/06/29 20:56:09 mickey Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998 Michael Shalayeff
d26 2
a27 2
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
d167 1
a167 1

d169 1
a169 1

@


1.2
log
@do not enable eisa by ourselves, better viper size print
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.1 1998/12/29 21:38:47 mickey Exp $	*/
d299 10
@


1.1
log
@memory
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a163 1
		((struct vi_ctrl *)&VI_CTRL)->eisa_den = 0;
d175 6
a180 7
		printf (" WARNING: cannot determine size (%d)\n", err);
	else {
		printf (" size %d", pdc_minit.max_spa / (1024*1024));
		if (pdc_minit.max_spa % (1024*1024))
			printf (".%d", pdc_minit.max_spa % (1024*1024));
		printf ("MB\n");
	}
d193 11
@

