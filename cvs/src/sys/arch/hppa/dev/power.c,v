head	1.9;
access;
symbols
	OPENBSD_6_1:1.9.0.12
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.9.0.10
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.6
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.9.0.8
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.9.0.4
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.5.0.42
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.38
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.36
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.34
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.32
	OPENBSD_5_0:1.5.0.30
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.28
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.26
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.22
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.24
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.20
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.18
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.16
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.14
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.12
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.10
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.8
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.6
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.4
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.2
	OPENBSD_3_6_BASE:1.5
	SMP_SYNC_A:1.5
	SMP_SYNC_B:1.4
	OPENBSD_3_5:1.4.0.4
	OPENBSD_3_5_BASE:1.4
	SMP:1.4.0.2
	OPENBSD_3_4:1.3.0.2
	OPENBSD_3_4_BASE:1.3;
locks; strict;
comment	@ * @;


1.9
date	2014.07.13.09.09.16;	author miod;	state Exp;
branches;
next	1.8;
commitid	y1q0tI0jKPxicayN;

1.8
date	2014.07.12.20.18.08;	author uebayasi;	state Exp;
branches;
next	1.7;
commitid	nhoQgK9Q8d952hTz;

1.7
date	2014.07.12.14.12.44;	author uebayasi;	state Exp;
branches;
next	1.6;
commitid	CwxiCWSX4kdxVfoo;

1.6
date	2014.03.29.18.09.29;	author guenther;	state Exp;
branches;
next	1.5;

1.5
date	2004.06.11.12.53.09;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	2003.12.20.21.49.04;	author miod;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2003.08.20.23.33.36;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	2003.08.20.22.51.07;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	2003.08.20.20.53.31;	author mickey;	state Exp;
branches;
next	;

1.4.2.1
date	2004.06.13.08.50.05;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.9
log
@One missing boot -> prsignal(initprocess) conversion
@
text
@/*	$OpenBSD: power.c,v 1.8 2014/07/12 20:18:08 uebayasi Exp $	*/

/*
 * Copyright (c) 2003 Michael Shalayeff
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR OR HIS RELATIVES BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/proc.h>
#include <sys/signalvar.h>
#include <sys/kernel.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/kthread.h>

#include <machine/reg.h>
#include <machine/pdc.h>
#include <machine/autoconf.h>

#include <hppa/dev/cpudevs.h>

struct power_softc {
	struct device sc_dev;
	void *sc_ih;

	struct proc *sc_thread;
	void (*sc_kicker)(void *);

	int sc_dr_cnt;
	paddr_t sc_pwr_reg;
	volatile int sc_interrupted;
};

int	powermatch(struct device *, void *, void *);
void	powerattach(struct device *, struct device *, void *);

struct cfattach power_ca = {
	sizeof(struct power_softc), powermatch, powerattach
};

struct cfdriver power_cd = {
	NULL, "power", DV_DULL
};

void power_thread_create(void *v);
void power_thread_dr(void *v);
void power_thread_reg(void *v);
void power_cold_hook_reg(int);
int power_intr(void *);

int
powermatch(struct device *parent, void *cfdata, void *aux)
{
	struct cfdata *cf = cfdata;
	struct confargs *ca = aux;

	if (cf->cf_unit > 0 && !strcmp(ca->ca_name, "power"))
		return (0);

	return (1);
}

void
powerattach(struct device *parent, struct device *self, void *aux)
{
	struct power_softc *sc = (struct power_softc *)self;
	struct confargs *ca = aux;

	switch (cpu_hvers) {
	case HPPA_BOARD_HP712_60:
	case HPPA_BOARD_HP712_80:
	case HPPA_BOARD_HP712_100:
	case HPPA_BOARD_HP712_120:
		sc->sc_kicker = power_thread_dr;
		printf(": DR25\n");
		break;

	default:
		if (ca->ca_hpa) {
			extern void (*cold_hook)(int);

			sc->sc_pwr_reg = ca->ca_hpa;
			cold_hook = power_cold_hook_reg;
			sc->sc_kicker = power_thread_reg;
			printf("\n");
		} else
			printf(": not available\n");
		break;
	}

	if (ca->ca_irq >= 0)
		sc->sc_ih = cpu_intr_establish(IPL_CLOCK, ca->ca_irq,
		    power_intr, sc, sc->sc_dev.dv_xname);

	if (sc->sc_kicker)
		kthread_create_deferred(power_thread_create, sc);
}

int
power_intr(void *v)
{
	struct power_softc *sc = v;

	sc->sc_interrupted = 1;

	return (1);
}

void
power_thread_create(void *v)
{
	struct power_softc *sc = v;

	if (kthread_create(sc->sc_kicker, sc, &sc->sc_thread,
	    sc->sc_dev.dv_xname))
		printf("WARNING: failed to create kernel power thread\n");
}

void
power_thread_dr(void *v)
{
	struct power_softc *sc = v;
	u_int32_t r;

	for (;;) {
		mfcpu(DR0_PCXL_SHINT_EN, r);	/* XXX don't ask */
		if (r & 0x80000000)
			sc->sc_dr_cnt = 0;
		else
			sc->sc_dr_cnt++;

		/*
		 * the bit is undampened straight wire from the power
		 * switch and thus we have do dampen it ourselves.
		 */
		if (sc->sc_dr_cnt == hz / 10)
			prsignal(initprocess, SIGUSR2);

		tsleep(v, PWAIT, "drpower", 10);
	}
}

void
power_thread_reg(void *v)
{
	struct power_softc *sc = v;
	u_int32_t r;

	for (;;) {
		__asm volatile("ldwas 0(%1), %0"
		    : "=&r" (r) : "r" (sc->sc_pwr_reg));

		if (!(r & 1))
			prsignal(initprocess, SIGUSR2);

		tsleep(v, PWAIT, "regpower", 10);
	}
}

void
power_cold_hook_reg(int on)
{
	extern struct pdc_power_info pdc_power_info;	/* machdep.c */
	int error;

	if ((error = pdc_call((iodcio_t)pdc, 0, PDC_SOFT_POWER,
	    PDC_SOFT_POWER_ENABLE, &pdc_power_info,
	    on == HPPA_COLD_HOT)))
		printf("power_cold_hook_reg: failed (%d)\n", error);
}
@


1.8
log
@reboot(9): Shutdown system by signaling init(8) from kernel where appropriate

Some ports watch temperature in MD and try to shutdown system, when overheated,
by calling directly (re)boot(9).  Change this to signal init(8) from kernel,
as acpi(4) and acpitz(4) do, which has been more tested.  This also helps to
clarify design that ``clean shutdown must be always started by init(8)''.

Note that SIGUSR2 causes init(8) to call reboot(2) with RB_POWERDOWN, as
acpi(4) etc. already does.  It is reasonable, pointed out by kettenis@@,
considering system is overheated and immediate reboot may be dangerous.

OK deraadt@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d175 1
a175 1
			boot(RB_POWERDOWN | RB_HALT);
@


1.7
log
@boot(9), reboot(9): Migrate MD callers of boot(9) to reboot(9)

I have found that some ports call boot(9) from machine-dependent code to
reboot system.  These should be changed to either:

- Sending signal to init(8) to trigger it to shutdown system cleanly, like
  acpi(4) does, in cases where found problems don't prevent system from working
  immediately, or

- Just doing panic(9) if the situation is severely broken.

For now, just rewrite boot() to reboot().  Actual fixes follow.

Discussed with & OK from kettenis@@
@
text
@d30 2
a33 1
#include <sys/reboot.h>
d158 1
a158 1
			reboot(RB_POWERDOWN | RB_HALT);
@


1.6
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: power.c,v 1.5 2004/06/11 12:53:09 mickey Exp $	*/
d157 1
a157 1
			boot(RB_POWERDOWN | RB_HALT);
@


1.5
log
@better name for power thread (for power users only)
@
text
@d1 1
a1 1
/*	$OpenBSD: power.c,v 1.4 2003/12/20 21:49:04 miod Exp $	*/
d170 1
a170 1
		__asm __volatile("ldwas 0(%1), %0"
@


1.4
log
@Pass -Wformat, fix a few uninitialized variables as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: power.c,v 1.3 2003/08/20 23:33:36 mickey Exp $	*/
d135 1
a135 1
	    "powerbutton"))
@


1.4.2.1
log
@sync to HEAD
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d135 1
a135 1
	    sc->sc_dev.dv_xname))
@


1.3
log
@devise the power reg address as hpa for the power device and thus avoid manual offset printing. add some code for interrupt-driven power-fail
@
text
@d1 1
a1 1
/*	$OpenBSD: power.c,v 1.2 2003/08/20 22:51:07 mickey Exp $	*/
d135 1
a135 1
	    "powerbutton", 0))
@


1.2
log
@support systems where power service is available from pdc and implement a cold hook as well thus do not powerleash lasi should we have cold_hook already set
@
text
@d1 1
a1 1
/*	$OpenBSD: power.c,v 1.1 2003/08/20 20:53:31 mickey Exp $	*/
d44 1
d51 1
d69 1
a69 2

struct pdc_power_info pdc_power_info PDC_ALIGNMENT;
d87 1
a87 1
	int error;
d99 1
a99 4
		if ((error = pdc_call((iodcio_t)pdc, 0, PDC_SOFT_POWER,
		    PDC_SOFT_POWER_INFO, &pdc_power_info, 0)))
			printf(": no power control, disabled\n");
		else {
d102 1
a102 2
			sc->sc_pwr_reg = pdc_power_info.addr;
			printf(" offset %x\n", sc->sc_pwr_reg - 0xf0000000);
d105 3
a107 1
		}
d111 4
d119 10
d183 1
@


1.1
log
@handle power button (on 712 for now)
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d37 1
d49 1
d65 4
d86 1
d94 1
d96 1
d98 11
a111 2
	printf("\n");

d148 28
@

