head	1.39;
access;
symbols
	OPENBSD_6_1_BASE:1.39
	OPENBSD_6_0:1.39.0.20
	OPENBSD_6_0_BASE:1.39
	OPENBSD_5_9:1.39.0.16
	OPENBSD_5_9_BASE:1.39
	OPENBSD_5_8:1.39.0.18
	OPENBSD_5_8_BASE:1.39
	OPENBSD_5_7:1.39.0.10
	OPENBSD_5_7_BASE:1.39
	OPENBSD_5_6:1.39.0.14
	OPENBSD_5_6_BASE:1.39
	OPENBSD_5_5:1.39.0.12
	OPENBSD_5_5_BASE:1.39
	OPENBSD_5_4:1.39.0.8
	OPENBSD_5_4_BASE:1.39
	OPENBSD_5_3:1.39.0.6
	OPENBSD_5_3_BASE:1.39
	OPENBSD_5_2:1.39.0.4
	OPENBSD_5_2_BASE:1.39
	OPENBSD_5_1_BASE:1.39
	OPENBSD_5_1:1.39.0.2
	OPENBSD_5_0:1.38.0.6
	OPENBSD_5_0_BASE:1.38
	OPENBSD_4_9:1.38.0.4
	OPENBSD_4_9_BASE:1.38
	OPENBSD_4_8:1.38.0.2
	OPENBSD_4_8_BASE:1.38
	OPENBSD_4_7:1.34.0.2
	OPENBSD_4_7_BASE:1.34
	OPENBSD_4_6:1.31.0.10
	OPENBSD_4_6_BASE:1.31
	OPENBSD_4_5:1.31.0.6
	OPENBSD_4_5_BASE:1.31
	OPENBSD_4_4:1.31.0.4
	OPENBSD_4_4_BASE:1.31
	OPENBSD_4_3:1.31.0.2
	OPENBSD_4_3_BASE:1.31
	OPENBSD_4_2:1.30.0.2
	OPENBSD_4_2_BASE:1.30
	OPENBSD_4_1:1.28.0.12
	OPENBSD_4_1_BASE:1.28
	OPENBSD_4_0:1.28.0.10
	OPENBSD_4_0_BASE:1.28
	OPENBSD_3_9:1.28.0.8
	OPENBSD_3_9_BASE:1.28
	OPENBSD_3_8:1.28.0.6
	OPENBSD_3_8_BASE:1.28
	OPENBSD_3_7:1.28.0.4
	OPENBSD_3_7_BASE:1.28
	OPENBSD_3_6:1.28.0.2
	OPENBSD_3_6_BASE:1.28
	SMP_SYNC_A:1.28
	SMP_SYNC_B:1.28
	OPENBSD_3_5:1.27.0.2
	OPENBSD_3_5_BASE:1.27
	OPENBSD_3_4:1.25.0.2
	OPENBSD_3_4_BASE:1.25
	UBC_SYNC_A:1.25
	OPENBSD_3_3:1.24.0.6
	OPENBSD_3_3_BASE:1.24
	OPENBSD_3_2:1.24.0.4
	OPENBSD_3_2_BASE:1.24
	OPENBSD_3_1:1.24.0.2
	OPENBSD_3_1_BASE:1.24
	UBC_SYNC_B:1.24
	UBC:1.14.0.4
	UBC_BASE:1.14
	OPENBSD_3_0:1.14.0.2
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9:1.13.0.2
	OPENBSD_2_9_BASE:1.13
	OPENBSD_2_8:1.12.0.4
	OPENBSD_2_8_BASE:1.12
	OPENBSD_2_7:1.12.0.2
	OPENBSD_2_7_BASE:1.12
	SMP:1.11.0.2
	SMP_BASE:1.11
	kame_19991208:1.10
	OPENBSD_2_6:1.9.0.2
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.5.0.2
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.2.0.2
	OPENBSD_2_4_BASE:1.2;
locks; strict;
comment	@ * @;


1.39
date	2011.08.16.17.26.04;	author kettenis;	state Exp;
branches;
next	1.38;

1.38
date	2010.07.02.17.27.01;	author nicm;	state Exp;
branches;
next	1.37;

1.37
date	2010.06.28.14.13.27;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2010.04.20.23.27.01;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2010.04.12.12.57.51;	author tedu;	state Exp;
branches;
next	1.34;

1.34
date	2009.11.09.17.53.38;	author nicm;	state Exp;
branches;
next	1.33;

1.33
date	2009.10.31.12.00.05;	author fgsch;	state Exp;
branches;
next	1.32;

1.32
date	2009.10.31.06.40.16;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2008.01.23.16.37.56;	author jsing;	state Exp;
branches;
next	1.30;

1.30
date	2007.07.15.19.25.49;	author kettenis;	state Exp;
branches;
next	1.29;

1.29
date	2007.05.23.18.29.35;	author kettenis;	state Exp;
branches;
next	1.28;

1.28
date	2004.04.07.18.24.19;	author mickey;	state Exp;
branches;
next	1.27;

1.27
date	2003.10.31.18.31.41;	author mickey;	state Exp;
branches;
next	1.26;

1.26
date	2003.10.03.16.44.49;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2003.05.14.23.18.09;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2002.03.14.03.15.53;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2002.03.14.01.26.31;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2002.03.06.23.06.23;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2002.02.08.20.43.14;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2002.02.05.03.46.23;	author mickey;	state Exp;
branches;
next	1.19;

1.19
date	2002.02.04.21.07.13;	author mickey;	state Exp;
branches;
next	1.18;

1.18
date	2002.02.03.01.51.00;	author mickey;	state Exp;
branches;
next	1.17;

1.17
date	2002.02.01.08.48.22;	author mickey;	state Exp;
branches;
next	1.16;

1.16
date	2002.01.25.21.42.09;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	2002.01.25.21.31.53;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	2001.04.29.21.05.43;	author mickey;	state Exp;
branches
	1.14.4.1;
next	1.13;

1.13
date	2001.01.22.22.57.31;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	2000.03.23.20.14.08;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	2000.01.26.20.55.20;	author mickey;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	99.11.26.16.48.28;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	99.09.07.03.25.13;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	99.08.12.23.49.07;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	99.07.12.18.08.32;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	99.04.20.20.24.18;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	98.12.29.21.40.21;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	98.11.23.02.58.11;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	98.10.29.17.47.15;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	98.09.14.18.59.49;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	98.09.12.02.51.34;	author mickey;	state Exp;
branches;
next	;

1.11.2.1
date	2000.03.24.09.07.27;	author niklas;	state Exp;
branches;
next	1.11.2.2;

1.11.2.2
date	2001.04.18.16.05.58;	author niklas;	state Exp;
branches;
next	1.11.2.3;

1.11.2.3
date	2001.07.04.10.16.00;	author niklas;	state Exp;
branches;
next	1.11.2.4;

1.11.2.4
date	2002.03.06.00.57.22;	author niklas;	state Exp;
branches;
next	1.11.2.5;

1.11.2.5
date	2002.03.28.10.07.19;	author niklas;	state Exp;
branches;
next	1.11.2.6;

1.11.2.6
date	2003.05.16.00.29.38;	author niklas;	state Exp;
branches;
next	1.11.2.7;

1.11.2.7
date	2004.02.19.10.48.39;	author niklas;	state Exp;
branches;
next	1.11.2.8;

1.11.2.8
date	2004.06.05.23.10.47;	author niklas;	state Exp;
branches;
next	;

1.14.4.1
date	2002.01.31.22.55.09;	author niklas;	state Exp;
branches;
next	1.14.4.2;

1.14.4.2
date	2002.06.11.03.35.36;	author art;	state Exp;
branches;
next	1.14.4.3;

1.14.4.3
date	2003.05.19.21.49.41;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.39
log
@Compile in serial console settings support if any com(4) device is included
in the kernel, not only when com @@ gsc is there.

ok miod@@
@
text
@/*	$OpenBSD: pdc.c,v 1.38 2010/07/02 17:27:01 nicm Exp $	*/

/*
 * Copyright (c) 1998-2003 Michael Shalayeff
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR OR HIS RELATIVES BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

#include "com.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/tty.h>
#include <sys/timeout.h>

#include <dev/cons.h>

#include <machine/conf.h>
#include <machine/pdc.h>
#include <machine/iomod.h>
#include <machine/autoconf.h>

typedef
struct pdc_softc {
	struct device sc_dv;
	struct tty *sc_tty;
	struct timeout sc_to;
} pdcsoftc_t;

pdcio_t pdc;
int pdcret[32] PDC_ALIGNMENT;
char pdc_consbuf[IODC_MINIOSIZ] PDC_ALIGNMENT;
iodcio_t pdc_cniodc, pdc_kbdiodc;
pz_device_t *pz_kbd, *pz_cons;

int pdcngetc(dev_t);
void pdcnputc(dev_t, char *);

struct consdev pdccons = { NULL, NULL, pdccngetc, pdccnputc,
     nullcnpollc, NULL, makedev(22, 0), CN_LOWPRI };

int pdcmatch(struct device *, void *, void *);
void pdcattach(struct device *, struct device *, void *);

struct cfattach pdc_ca = {
	sizeof(pdcsoftc_t), pdcmatch, pdcattach
};

struct cfdriver pdc_cd = {
	NULL, "pdc", DV_DULL
};

void pdcstart(struct tty *tp);
void pdctimeout(void *v);
int pdcparam(struct tty *tp, struct termios *);
int pdccnlookc(dev_t dev, int *cp);

#if NCOM > 0
/* serial console speed table */
static int pdc_speeds[] = {
	B50,
	B75,
	B110,
	B150,
	B300,
	B600,
	B1200,
	B2400,
	B4800,
	B7200,
	B9600,
	B19200,
	B38400,
	B57600,
	B115200,
	B230400,
};
#endif

void
pdc_init()
{
	static int kbd_iodc[IODC_MAXSIZE/sizeof(int)];
	static int cn_iodc[IODC_MAXSIZE/sizeof(int)];
	int err;

	/* XXX locore've done it XXX pdc = (pdcio_t)PAGE0->mem_pdc; */
	pz_kbd = &PAGE0->mem_kbd;
	pz_cons = &PAGE0->mem_cons;

	/* XXX should we reset the console/kbd here?
	   well, /boot did that for us anyway */
	if ((err = pdc_call((iodcio_t)pdc, 0, PDC_IODC, PDC_IODC_READ,
	      pdcret, pz_cons->pz_hpa, IODC_IO, cn_iodc, IODC_MAXSIZE)) < 0 ||
	    (err = pdc_call((iodcio_t)pdc, 0, PDC_IODC, PDC_IODC_READ,
	      pdcret, pz_kbd->pz_hpa, IODC_IO, kbd_iodc, IODC_MAXSIZE)) < 0) {
#ifdef DEBUG
		printf("pdc_init: failed reading IODC (%d)\n", err);
#endif
	}

	pdc_cniodc = (iodcio_t)cn_iodc;
	pdc_kbdiodc = (iodcio_t)kbd_iodc;

	/* Start out with pdc as the console. */
	cn_tab = &pdccons;

	/* Figure out console settings. */
#if NCOM > 0
	if (PAGE0->mem_cons.pz_class == PCL_DUPLEX) {
		struct pz_device *pzd = &PAGE0->mem_cons;
		extern int comdefaultrate;
#ifdef DEBUG
		printf("console: class %d flags %b ",
		    pzd->pz_class, pzd->pz_flags, PZF_BITS);
		printf("bc %d/%d/%d/%d/%d/%d ",
		    pzd->pz_bc[0], pzd->pz_bc[1], pzd->pz_bc[2],
		    pzd->pz_bc[3], pzd->pz_bc[4], pzd->pz_bc[5]);
		printf("mod %x layers %x/%x/%x/%x/%x/%x hpa %x\n", pzd->pz_mod,
		    pzd->pz_layers[0], pzd->pz_layers[1], pzd->pz_layers[2],
		    pzd->pz_layers[3], pzd->pz_layers[4], pzd->pz_layers[5],
		    pzd->pz_hpa);

#endif

		/* compute correct baud rate */
		if (PZL_SPEED(pzd->pz_layers[0]) <
		    sizeof(pdc_speeds) / sizeof(int))
			comdefaultrate =
			    pdc_speeds[PZL_SPEED(pzd->pz_layers[0])];
		else
			comdefaultrate = B9600;	/* XXX */
	}
#endif
}

int
pdcmatch(parent, cfdata, aux)
	struct device *parent;
	void *cfdata;
	void *aux;
{
	struct cfdata *cf = cfdata;
	struct confargs *ca = aux;

	/* there could be only one */
	if (cf->cf_unit > 0 && !strcmp(ca->ca_name, "pdc"))
		return 0;

	return 1;
}

void
pdcattach(parent, self, aux)
	struct device *parent;
	struct device *self;
	void *aux;
{
	struct pdc_softc *sc = (struct pdc_softc *)self;

	if (!pdc)
		pdc_init();

	printf("\n");

	timeout_set(&sc->sc_to, pdctimeout, sc);
}

int
pdcopen(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
{
	int unit = minor(dev);
	struct pdc_softc *sc;
	struct tty *tp;
	int s;
	int error = 0, setuptimeout = 0;

	if (unit >= pdc_cd.cd_ndevs || (sc = pdc_cd.cd_devs[unit]) == NULL)
		return ENXIO;

	s = spltty();

	if (sc->sc_tty)
		tp = sc->sc_tty;
	else {
		tp = sc->sc_tty = ttymalloc(0);
	}

	tp->t_oproc = pdcstart;
	tp->t_param = pdcparam;
	tp->t_dev = dev;
	if ((tp->t_state & TS_ISOPEN) == 0) {
		ttychars(tp);
		tp->t_iflag = TTYDEF_IFLAG;
		tp->t_oflag = TTYDEF_OFLAG;
		tp->t_cflag = TTYDEF_CFLAG|CLOCAL;
		tp->t_lflag = TTYDEF_LFLAG;
		tp->t_ispeed = tp->t_ospeed = B9600;
		ttsetwater(tp);

		setuptimeout = 1;
	} else if (tp->t_state&TS_XCLUDE && suser(p, 0) != 0) {
		splx(s);
		return (EBUSY);
	}
	tp->t_state |= TS_CARR_ON;
	splx(s);

	error = (*linesw[tp->t_line].l_open)(dev, tp, p);
	if (error == 0 && setuptimeout)
		pdctimeout(sc);

	return error;
}

int
pdcclose(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
{
	int unit = minor(dev);
	struct tty *tp;
	struct pdc_softc *sc;

	if (unit >= pdc_cd.cd_ndevs || (sc = pdc_cd.cd_devs[unit]) == NULL)
		return ENXIO;

	tp = sc->sc_tty;
	timeout_del(&sc->sc_to);
	(*linesw[tp->t_line].l_close)(tp, flag, p);
	ttyclose(tp);
	return 0;
}

int
pdcread(dev, uio, flag)
	dev_t dev;
	struct uio *uio;
	int flag;
{
	int unit = minor(dev);
	struct tty *tp;
	struct pdc_softc *sc;

	if (unit >= pdc_cd.cd_ndevs || (sc = pdc_cd.cd_devs[unit]) == NULL)
		return ENXIO;

	tp = sc->sc_tty;
	return ((*linesw[tp->t_line].l_read)(tp, uio, flag));
}

int
pdcwrite(dev, uio, flag)
	dev_t dev;
	struct uio *uio;
	int flag;
{
	int unit = minor(dev);
	struct tty *tp;
	struct pdc_softc *sc;

	if (unit >= pdc_cd.cd_ndevs || (sc = pdc_cd.cd_devs[unit]) == NULL)
		return ENXIO;

	tp = sc->sc_tty;
	return ((*linesw[tp->t_line].l_write)(tp, uio, flag));
}

int
pdcioctl(dev, cmd, data, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
{
	int unit = minor(dev);
	int error;
	struct tty *tp;
	struct pdc_softc *sc;

	if (unit >= pdc_cd.cd_ndevs || (sc = pdc_cd.cd_devs[unit]) == NULL)
		return ENXIO;

	tp = sc->sc_tty;
	error = (*linesw[tp->t_line].l_ioctl)(tp, cmd, data, flag, p);
	if (error >= 0)
		return error;
	error = ttioctl(tp, cmd, data, flag, p);
	if (error >= 0)
		return error;

	return ENOTTY;
}

int
pdcparam(tp, t)
	struct tty *tp;
	struct termios *t;
{

	return 0;
}

void
pdcstart(tp)
	struct tty *tp;
{
	int s;

	s = spltty();
	if (tp->t_state & (TS_TTSTOP | TS_BUSY)) {
		splx(s);
		return;
	}
	ttwakeupwr(tp);
	tp->t_state |= TS_BUSY;
	while (tp->t_outq.c_cc != 0)
		pdccnputc(tp->t_dev, getc(&tp->t_outq));
	tp->t_state &= ~TS_BUSY;
	splx(s);
}

int
pdcstop(tp, flag)
	struct tty *tp;
	int flag;
{
	int s;

	s = spltty();
	if (tp->t_state & TS_BUSY)
		if ((tp->t_state & TS_TTSTOP) == 0)
			tp->t_state |= TS_FLUSH;
	splx(s);
	return 0;
}

void
pdctimeout(v)
	void *v;
{
	struct pdc_softc *sc = v;
	struct tty *tp = sc->sc_tty;
	int c;

	while (pdccnlookc(tp->t_dev, &c)) {
		if (tp->t_state & TS_ISOPEN)
			(*linesw[tp->t_line].l_rint)(c, tp);
	}
	timeout_add(&sc->sc_to, 1);
}

struct tty *
pdctty(dev)
	dev_t dev;
{
	int unit = minor(dev);
	struct pdc_softc *sc;

	if (unit >= pdc_cd.cd_ndevs || (sc = pdc_cd.cd_devs[unit]) == NULL)
		return NULL;

	return sc->sc_tty;
}

int
pdccnlookc(dev, cp)
	dev_t dev;
	int *cp;
{
	int err, l;
	int s = splhigh();

	err = pdc_call(pdc_kbdiodc, 0, pz_kbd->pz_hpa, IODC_IO_CONSIN,
	    pz_kbd->pz_spa, pz_kbd->pz_layers, pdcret, 0, pdc_consbuf, 1, 0);

	l = pdcret[0];
	*cp = pdc_consbuf[0];
	splx(s);
#ifdef DEBUG
	if (err < 0)
		printf("pdccnlookc: input error: %d\n", err);
#endif

	return l;
}

int
pdccngetc(dev)
	dev_t dev;
{
	int c;

	if (!pdc)
		return 0;

	while(!pdccnlookc(dev, &c))
		;

	return (c);
}

void
pdccnputc(dev, c)
	dev_t dev;
	int c;
{
	register int err;
	int s = splhigh();

	*pdc_consbuf = c;
	err = pdc_call(pdc_cniodc, 0, pz_cons->pz_hpa, IODC_IO_CONSOUT,
	    pz_cons->pz_spa, pz_cons->pz_layers, pdcret, 0, pdc_consbuf, 1, 0);
	splx(s);

	if (err < 0) {
#ifdef DEBUG
		printf("pdccnputc: output error: %d\n", err);
#endif
	}
}
@


1.38
log
@Move common code for waking up writers on a tty into a function.

ok deraadt matthew millert
@
text
@d1 1
a1 1
/*	$OpenBSD: pdc.c,v 1.37 2010/06/28 14:13:27 deraadt Exp $	*/
d79 1
a79 1
#if NCOM_GSC > 0
d130 1
a130 1
#if NCOM_GSC > 0
@


1.37
log
@Allow tty drivers to request larger buffers at attach time using a
max-baud-rate hint.  Adjust TTYHOG (the nearly full logic) to this new
situation.  The larger buffers are required by the very high speed
KDDI devices in Japan (CF com, or USB ucom) so those are the only two
drivers which currently ask for a larger buffer size.
ok yasuoka miod
@
text
@d1 1
a1 1
/*	$OpenBSD: pdc.c,v 1.36 2010/04/20 23:27:01 deraadt Exp $	*/
d341 1
a341 7
	if (tp->t_outq.c_cc <= tp->t_lowat) {
		if (tp->t_state & TS_ASLEEP) {
			tp->t_state &= ~TS_ASLEEP;
			wakeup((caddr_t)&tp->t_outq);
		}
		selwakeup(&tp->t_wsel);
	}
@


1.36
log
@cleanup more confusion regarding user.h before proc.h, or missing proc.h
ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: pdc.c,v 1.35 2010/04/12 12:57:51 tedu Exp $	*/
d210 1
a210 1
		tp = sc->sc_tty = ttymalloc();
@


1.35
log
@Some of the line disciplines want to check for suser.  Better to pass them
a process instead of using curproc.  ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: pdc.c,v 1.34 2009/11/09 17:53:38 nicm Exp $	*/
a34 1
#include <sys/user.h>
@


1.34
log
@Every selwakeup() should have a matching KNOTE() (even if kqueue isn't
supported it doesn't do any harm), so put the KNOTE() in selwakeup() itself and
remove it from any occurences where both are used, except one for kqueue itself
and one in sys_pipe.c (where the selwakeup is under a PIPE_SEL flag).

Based on a diff from tedu.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: pdc.c,v 1.33 2009/10/31 12:00:05 fgsch Exp $	*/
d234 1
a234 1
	error = (*linesw[tp->t_line].l_open)(dev, tp);
d256 1
a256 1
	(*linesw[tp->t_line].l_close)(tp, flag);
@


1.33
log
@Use suser when possible. Suggested by miod@@.
miod@@ deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: pdc.c,v 1.32 2009/10/31 06:40:16 deraadt Exp $	*/
a347 1
		KNOTE(&tp->t_wsel.si_note, 0);
@


1.32
log
@Add missing KNOTE() calls after selwakeup(), until we decide if the KNOTE()
calls can go directly into selwakeup() safely
long discussion with nicm, murmers of consent from tedu and miod, noone
else seems to care of kqueue is busted as long as it makes their sockets
move data fast... pretty sad.
@
text
@d1 1
a1 1
/*	$OpenBSD: pdc.c,v 1.31 2008/01/23 16:37:56 jsing Exp $	*/
d227 1
a227 1
	} else if (tp->t_state&TS_XCLUDE && p->p_ucred->cr_uid != 0) {
@


1.31
log
@Cleanup cn_pri. Change constants to more meaningful names, rather than
the hp300 related ones currently in use. CN_NORMAL becomes CN_LOWPRI,
CN_INTERNAL becomes CN_MIDPRI and CN_REMOTE becomes CN_HIGHPRI.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pdc.c,v 1.30 2007/07/15 19:25:49 kettenis Exp $	*/
d348 1
@


1.30
log
@Delay switching to the real serial console until we attach the serial device.
The variety of different serial devices is just too big to make a decision up
front.  This should make the second serial port on four-digit B/C/J-class
workstation work as a serial console too.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pdc.c,v 1.29 2007/05/23 18:29:35 kettenis Exp $	*/
d62 1
a62 1
     nullcnpollc, NULL, makedev(22, 0), CN_NORMAL };
@


1.29
log
@Add hack to prevent switching to serial console on four-digit B/C/J class
workstations.  This makes these machines actually boot.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pdc.c,v 1.28 2004/04/07 18:24:19 mickey Exp $	*/
d57 6
a62 2
hppa_hpa_t conaddr;
int conunit;
d127 2
a128 2
	/* XXX make pdc current console */
	cn_tab = &constab[0];
d130 1
a130 1
	/* setup the console */
d145 1
a146 9
		conaddr = (u_long)pzd->pz_hpa + IOMOD_DEVOFFSET;
		conunit = 0;

		/*
		 * XXX Attaching the serial console on four-digit B/C/J
		 * class workstations, so disable it for now.
		 */
		if (conaddr == 0xfee003f8 + IOMOD_DEVOFFSET)
			conaddr = 0;
a398 17
void
pdccnprobe(cn)
	struct consdev *cn;
{
	cn->cn_dev = makedev(22,0);
	cn->cn_pri = CN_NORMAL;
}

void
pdccninit(cn)
	struct consdev *cn;
{
#ifdef DEBUG
	printf("pdc0: console init\n");
#endif
}

a453 8
}

void
pdccnpollc(dev, on)
	dev_t dev;
	int on;
{

@


1.28
log
@update copyright; miod@@ is fine w/ files where he holds it too
@
text
@d1 1
a1 1
/*	$OpenBSD: pdc.c,v 1.27 2003/10/31 18:31:41 mickey Exp $	*/
d144 7
@


1.27
log
@pdc_speeds is only needed for NCOM_GSC>0; from hellmuth.michaelis@@t-online.de
@
text
@d1 1
a1 1
/*	$OpenBSD: pdc.c,v 1.26 2003/10/03 16:44:49 miod Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998-2002 Michael Shalayeff
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Michael Shalayeff.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d19 8
a26 7
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF MIND,
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@


1.26
log
@Merge tty_attach() in ttymalloc() and tty_detach() in ttyfree(). The need for
separate tty registering is gone now that sparc has switched to wscons, and
this makes the code less error-prone.

Also, remove tests for ttymalloc() failure, since it uses M_WAITOK.

ok millert@@ deraadt@@, tested by various people as well besides me...
@
text
@d1 1
a1 1
/*	$OpenBSD: pdc.c,v 1.25 2003/05/14 23:18:09 miod Exp $	*/
d33 2
d80 1
d100 1
a130 1
#include "com.h"
@


1.25
log
@Fix uninitialized variable.
@
text
@d1 1
a1 1
/*	$OpenBSD: pdc.c,v 1.24 2002/03/14 03:15:53 millert Exp $	*/
d208 3
a210 2
	else
		tty_attach(tp = sc->sc_tty = ttymalloc());
@


1.24
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: pdc.c,v 1.23 2002/03/14 01:26:31 millert Exp $	*/
d199 1
a199 1
	int error = 0, setuptimeout;
@


1.23
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: pdc.c,v 1.22 2002/03/06 23:06:23 miod Exp $	*/
d62 1
a62 1
int pdcmatch(struct device *, void *, void*);
@


1.22
log
@Support serial speed over 9600 bauds.
@
text
@d1 1
a1 1
/*	$OpenBSD: pdc.c,v 1.21 2002/02/08 20:43:14 miod Exp $	*/
d62 2
a63 2
int pdcmatch __P((struct device *, void *, void*));
void pdcattach __P((struct device *, struct device *, void *));
d73 4
a76 4
void pdcstart __P((struct tty *tp));
void pdctimeout __P((void *v));
int pdcparam __P((struct tty *tp, struct termios *));
int pdccnlookc __P((dev_t dev, int *cp));
@


1.21
log
@Teach some magic to the kernel so that it can decode serial console settings.
mickey@@ said "commitski".
@
text
@d1 1
a1 1
/*	$OpenBSD: pdc.c,v 1.20 2002/02/05 03:46:23 mickey Exp $	*/
d91 5
@


1.20
log
@only probe for the cerial if NCOM_GSC, not just any com, fix prontf
@
text
@d1 1
a1 1
/*	$OpenBSD: pdc.c,v 1.19 2002/02/04 21:07:13 mickey Exp $	*/
d78 15
d140 8
a147 2
		/* TODO detect the baud rate from layer[0] */
		comdefaultrate = B9600;
@


1.19
log
@use better tty flags names
@
text
@d1 1
a1 1
/*	$OpenBSD: pdc.c,v 1.18 2002/02/03 01:51:00 mickey Exp $	*/
d108 1
a108 1
#if NCOM > 0
d113 9
a121 9
		printf("console: class %d flags %b bc %d/%d/%d/%d/%d/%d "
		       "mod %x layers %x/%x/%x/%x/%x/%x hpa %x\n",
		   pzd->pz_class, pzd->pz_flags, PZF_BITS,
		   pzd->pz_bc[0], pzd->pz_bc[1], pzd->pz_bc[2],
		pzd->pz_bc[3], pzd->pz_bc[4], pzd->pz_bc[5], pzd->pz_mod,
		pzd->pz_layers[0], pzd->pz_layers[1], pzd->pz_layers[2],
		pzd->pz_layers[3], pzd->pz_layers[4], pzd->pz_layers[5],
		pzd->pz_hpa);
		DELAY(2000);
@


1.18
log
@only check for serial console if any compiled
@
text
@d1 1
a1 1
/*	$OpenBSD: pdc.c,v 1.17 2002/02/01 08:48:22 mickey Exp $	*/
d126 1
a126 1
		comdefaultrate = 9600;
a188 1
		tp->t_state |= TS_WOPEN|TS_CARR_ON;
d194 1
a194 1
		tp->t_ispeed = tp->t_ospeed = 9600;
d200 1
a200 1
		return EBUSY;
a202 1

@


1.17
log
@fix debugging printf
@
text
@d1 1
a1 1
/*	$OpenBSD: pdc.c,v 1.16 2002/01/25 21:42:09 mickey Exp $	*/
d107 2
d128 1
a128 1

@


1.16
log
@offset cons hpa to com regs, damnit
@
text
@d1 1
a1 1
/*	$OpenBSD: pdc.c,v 1.15 2002/01/25 21:31:53 mickey Exp $	*/
d111 2
a112 2
		printf("console: class %d flags %b bc %d/%d/%d/%d/%d/%d\n"
		       "         mod %x layers %x/%x/%x/%x/%/%x hpa %x\n",
d119 1
d123 1
a123 1
		/* TODO detect the baud rate */
@


1.15
log
@init conaddr/unit if page0->mem_cons is on serial
@
text
@d1 1
a1 1
/*	$OpenBSD: pdc.c,v 1.14 2001/04/29 21:05:43 mickey Exp $	*/
d120 1
a120 1
		conaddr = (u_long)pzd->pz_hpa;
@


1.14
log
@raise spl around pdc calling
@
text
@d1 1
a1 1
/*	$OpenBSD: pdc.c,v 1.13 2001/01/22 22:57:31 mickey Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998-2001 Michael Shalayeff
d59 2
a60 1
int CONADDR;
d105 21
a125 1
	/* TODO: detect that we are on cereal, and set CONADDR */
@


1.14.4.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: pdc.c,v 1.16 2002/01/25 21:42:09 mickey Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998-2002 Michael Shalayeff
d59 1
a59 2
hppa_hpa_t conaddr;
int conunit;
d104 1
a104 21

	/* setup the console */
	if (PAGE0->mem_cons.pz_class == PCL_DUPLEX) {
		struct pz_device *pzd = &PAGE0->mem_cons;
		extern int comdefaultrate;
#ifdef DEBUG
		printf("console: class %d flags %b bc %d/%d/%d/%d/%d/%d\n"
		       "         mod %x layers %x/%x/%x/%x/%/%x hpa %x\n",
		   pzd->pz_class, pzd->pz_flags, PZF_BITS,
		   pzd->pz_bc[0], pzd->pz_bc[1], pzd->pz_bc[2],
		pzd->pz_bc[3], pzd->pz_bc[4], pzd->pz_bc[5], pzd->pz_mod,
		pzd->pz_layers[0], pzd->pz_layers[1], pzd->pz_layers[2],
		pzd->pz_layers[3], pzd->pz_layers[4], pzd->pz_layers[5],
		pzd->pz_hpa);
#endif
		conaddr = (u_long)pzd->pz_hpa + IOMOD_DEVOFFSET;
		conunit = 0;
		/* TODO detect the baud rate */
		comdefaultrate = 9600;
	}

@


1.14.4.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pdc.c,v 1.14.4.1 2002/01/31 22:55:09 niklas Exp $	*/
d62 2
a63 2
int pdcmatch(struct device *, void *, void *);
void pdcattach(struct device *, struct device *, void *);
d73 4
a76 24
void pdcstart(struct tty *tp);
void pdctimeout(void *v);
int pdcparam(struct tty *tp, struct termios *);
int pdccnlookc(dev_t dev, int *cp);

/* serial console speed table */
static int pdc_speeds[] = {
	B50,
	B75,
	B110,
	B150,
	B300,
	B600,
	B1200,
	B2400,
	B4800,
	B7200,
	B9600,
	B19200,
	B38400,
	B57600,
	B115200,
	B230400,
};
a106 2
#include "com.h"
#if NCOM_GSC > 0
d111 8
a118 9
		printf("console: class %d flags %b ",
		    pzd->pz_class, pzd->pz_flags, PZF_BITS);
		printf("bc %d/%d/%d/%d/%d/%d ",
		    pzd->pz_bc[0], pzd->pz_bc[1], pzd->pz_bc[2],
		    pzd->pz_bc[3], pzd->pz_bc[4], pzd->pz_bc[5]);
		printf("mod %x layers %x/%x/%x/%x/%x/%x hpa %x\n", pzd->pz_mod,
		    pzd->pz_layers[0], pzd->pz_layers[1], pzd->pz_layers[2],
		    pzd->pz_layers[3], pzd->pz_layers[4], pzd->pz_layers[5],
		    pzd->pz_hpa);
d122 3
a125 9
		/* compute correct baud rate */
		if (PZL_SPEED(pzd->pz_layers[0]) <
		    sizeof(pdc_speeds) / sizeof(int))
			comdefaultrate =
			    pdc_speeds[PZL_SPEED(pzd->pz_layers[0])];
		else
			comdefaultrate = B9600;	/* XXX */
	}
#endif
d186 1
d192 1
a192 1
		tp->t_ispeed = tp->t_ospeed = B9600;
d198 1
a198 1
		return (EBUSY);
d201 1
@


1.14.4.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d199 1
a199 1
	int error = 0, setuptimeout = 0;
@


1.13
log
@paste error in pdcopen, a few formatting cnages and use int for char
@
text
@d1 1
a1 1
/*	$OpenBSD: pdc.c,v 1.12 2000/03/23 20:14:08 mickey Exp $	*/
d371 1
d378 1
d408 1
d411 5
a415 3
	if ((err = pdc_call(pdc_cniodc, 0, pz_cons->pz_hpa, IODC_IO_CONSOUT,
	    pz_cons->pz_spa, pz_cons->pz_layers,
	    pdcret, 0, pdc_consbuf, 1, 0)) < 0) {
a419 1

@


1.12
log
@new timeout code from openbsd (; remove extraneous includes
@
text
@d1 1
a1 1
/*	$OpenBSD: pdc.c,v 1.11 2000/01/26 20:55:20 mickey Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998-2000 Michael Shalayeff
d75 1
a75 1
int pdccnlookc __P((dev_t dev, char *cp));
d91 1
a91 2
			    pdcret, pz_cons->pz_hpa,
			    IODC_IO, cn_iodc, IODC_MAXSIZE)) < 0 ||
d93 1
a93 2
			    pdcret, pz_kbd->pz_hpa,
			    IODC_IO, kbd_iodc, IODC_MAXSIZE)) < 0) {
d156 1
a156 1
	if (!sc->sc_tty)
d179 1
d226 1
a226 1
 
d243 1
a243 1
 
d326 1
a326 1
	u_char c;
d368 1
a368 1
	char *cp;
d373 1
a373 2
	    pz_kbd->pz_spa, pz_kbd->pz_layers, pdcret, 0,
	    pdc_consbuf, 1, 0);
d389 1
a389 1
	char c;
d409 2
a410 2
			    pz_cons->pz_spa, pz_cons->pz_layers,
			    pdcret, 0, pdc_consbuf, 1, 0)) < 0) {
@


1.11
log
@s/PDC_DEBUG/PDCDEBUG/
@
text
@d1 1
a1 1
/*	$OpenBSD: pdc.c,v 1.10 1999/11/26 16:48:28 mickey Exp $	*/
a35 1
#include <sys/select.h>
a36 1
#include <sys/proc.h>
d38 1
a38 2
#include <sys/file.h>
#include <sys/uio.h>
d50 2
a58 1
struct tty *pdc_tty[1];
d131 2
d137 2
d148 1
d153 1
a153 1
	if (unit >= 1)
d158 4
a161 5
	if (!pdc_tty[unit]) {
		tp = pdc_tty[unit] = ttymalloc();
		tty_attach(tp);
	} else
		tp = pdc_tty[unit];
d186 1
a186 1
		timeout(pdctimeout, tp, 1);
d198 5
a202 1
	struct tty *tp = pdc_tty[unit];
d204 2
a205 1
	untimeout(pdctimeout, tp);
d217 3
a219 1
	struct tty *tp = pdc_tty[minor(dev)];
d221 4
d234 8
a241 2
	struct tty *tp = pdc_tty[minor(dev)];
 
a253 1
	struct tty *tp = pdc_tty[unit];
d255 5
d261 1
d325 2
a326 1
	struct tty *tp = v;
d333 1
a333 1
	timeout(pdctimeout, tp, 1);
d340 5
a344 2
	if (minor(dev) != 0)
		panic("pdctty: bogus");
d346 1
a346 1
	return pdc_tty[0];
@


1.11.2.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d36 1
d38 1
d40 2
a41 1
#include <sys/timeout.h>
a52 2
	struct tty *sc_tty;
	struct timeout sc_to;
d60 1
a132 2
	struct pdc_softc *sc = (struct pdc_softc *)self;

a136 2

	timeout_set(&sc->sc_to, pdctimeout, sc);
a145 1
	struct pdc_softc *sc;
d150 1
a150 1
	if (unit >= pdc_cd.cd_ndevs || (sc = pdc_cd.cd_devs[unit]) == NULL)
d155 5
a159 4
	if (!sc->sc_tty)
		tp = sc->sc_tty;
	else
		tty_attach(tp = sc->sc_tty = ttymalloc());
d184 1
a184 1
		pdctimeout(sc);
d196 1
a196 5
	struct tty *tp;
	struct pdc_softc *sc;

	if (unit >= pdc_cd.cd_ndevs || (sc = pdc_cd.cd_devs[unit]) == NULL)
		return ENXIO;
d198 1
a198 2
	tp = sc->sc_tty;
	timeout_del(&sc->sc_to);
d210 1
a210 3
	int unit = minor(dev);
	struct tty *tp;
	struct pdc_softc *sc;
a211 4
	if (unit >= pdc_cd.cd_ndevs || (sc = pdc_cd.cd_devs[unit]) == NULL)
		return ENXIO;

	tp = sc->sc_tty;
d221 2
a222 8
	int unit = minor(dev);
	struct tty *tp;
	struct pdc_softc *sc;

	if (unit >= pdc_cd.cd_ndevs || (sc = pdc_cd.cd_devs[unit]) == NULL)
		return ENXIO;

	tp = sc->sc_tty;
d235 1
a236 5
	struct tty *tp;
	struct pdc_softc *sc;

	if (unit >= pdc_cd.cd_ndevs || (sc = pdc_cd.cd_devs[unit]) == NULL)
		return ENXIO;
a237 1
	tp = sc->sc_tty;
d301 1
a301 2
	struct pdc_softc *sc = v;
	struct tty *tp = sc->sc_tty;
d308 1
a308 1
	timeout_add(&sc->sc_to, 1);
d315 2
a316 5
	int unit = minor(dev);
	struct pdc_softc *sc;

	if (unit >= pdc_cd.cd_ndevs || (sc = pdc_cd.cd_devs[unit]) == NULL)
		return NULL;
d318 1
a318 1
	return sc->sc_tty;
@


1.11.2.2
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: pdc.c,v 1.13 2001/01/22 22:57:31 mickey Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998-2001 Michael Shalayeff
d75 1
a75 1
int pdccnlookc __P((dev_t dev, int *cp));
d91 2
a92 1
	      pdcret, pz_cons->pz_hpa, IODC_IO, cn_iodc, IODC_MAXSIZE)) < 0 ||
d94 2
a95 1
	      pdcret, pz_kbd->pz_hpa, IODC_IO, kbd_iodc, IODC_MAXSIZE)) < 0) {
d158 1
a158 1
	if (sc->sc_tty)
a180 1
	tp->t_state |= TS_CARR_ON;
d227 1
a227 1

d244 1
a244 1

d327 1
a327 1
	int c;
d369 1
a369 1
	int *cp;
d374 2
a375 1
	    pz_kbd->pz_spa, pz_kbd->pz_layers, pdcret, 0, pdc_consbuf, 1, 0);
d391 1
a391 1
	int c;
d411 2
a412 2
	    pz_cons->pz_spa, pz_cons->pz_layers,
	    pdcret, 0, pdc_consbuf, 1, 0)) < 0) {
@


1.11.2.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: pdc.c,v 1.11.2.2 2001/04/18 16:05:58 niklas Exp $	*/
a370 1
	int s = splhigh();
a376 1
	splx(s);
a405 1
	int s = splhigh();
d408 3
a410 5
	err = pdc_call(pdc_cniodc, 0, pz_cons->pz_hpa, IODC_IO_CONSOUT,
	    pz_cons->pz_spa, pz_cons->pz_layers, pdcret, 0, pdc_consbuf, 1, 0);
	splx(s);

	if (err < 0) {
d415 1
@


1.11.2.4
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d4 1
a4 1
 * Copyright (c) 1998-2002 Michael Shalayeff
d59 1
a59 2
hppa_hpa_t conaddr;
int conunit;
a76 15
/* serial console speed table */
static int pdc_speeds[] = {
	B50,
	B75,
	B110,
	B150,
	B300,
	B600,
	B1200,
	B2400,
	B4800,
	B7200,
	B9600,
};

d104 1
a104 30

	/* setup the console */
#include "com.h"
#if NCOM_GSC > 0
	if (PAGE0->mem_cons.pz_class == PCL_DUPLEX) {
		struct pz_device *pzd = &PAGE0->mem_cons;
		extern int comdefaultrate;
#ifdef DEBUG
		printf("console: class %d flags %b ",
		    pzd->pz_class, pzd->pz_flags, PZF_BITS);
		printf("bc %d/%d/%d/%d/%d/%d ",
		    pzd->pz_bc[0], pzd->pz_bc[1], pzd->pz_bc[2],
		    pzd->pz_bc[3], pzd->pz_bc[4], pzd->pz_bc[5]);
		printf("mod %x layers %x/%x/%x/%x/%x/%x hpa %x\n", pzd->pz_mod,
		    pzd->pz_layers[0], pzd->pz_layers[1], pzd->pz_layers[2],
		    pzd->pz_layers[3], pzd->pz_layers[4], pzd->pz_layers[5],
		    pzd->pz_hpa);
#endif
		conaddr = (u_long)pzd->pz_hpa + IOMOD_DEVOFFSET;
		conunit = 0;

		/* compute correct baud rate */
		if (PZL_SPEED(pzd->pz_layers[0]) <
		    sizeof(pdc_speeds) / sizeof(int))
			comdefaultrate =
			    pdc_speeds[PZL_SPEED(pzd->pz_layers[0])];
		else
			comdefaultrate = B9600;	/* XXX */
	}
#endif
d165 1
d171 1
a171 1
		tp->t_ispeed = tp->t_ospeed = B9600;
d177 1
a177 1
		return (EBUSY);
d180 1
@


1.11.2.5
log
@Merge in -current from about a week ago
@
text
@d62 2
a63 2
int pdcmatch(struct device *, void *, void *);
void pdcattach(struct device *, struct device *, void *);
d73 4
a76 4
void pdcstart(struct tty *tp);
void pdctimeout(void *v);
int pdcparam(struct tty *tp, struct termios *);
int pdccnlookc(dev_t dev, int *cp);
a90 5
	B19200,
	B38400,
	B57600,
	B115200,
	B230400,
@


1.11.2.6
log
@merge the trunk so we will get the genfs and locking fixes
@
text
@d199 1
a199 1
	int error = 0, setuptimeout = 0;
@


1.11.2.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@a32 2
#include "com.h"

a77 1
#if NCOM_GSC > 0
a96 1
#endif
d127 1
d208 2
a209 3
	else {
		tp = sc->sc_tty = ttymalloc();
	}
@


1.11.2.8
log
@Merge with the trunk
@
text
@d4 1
a4 1
 * Copyright (c) 1998-2003 Michael Shalayeff
d15 5
d24 7
a30 8
 * IN NO EVENT SHALL THE AUTHOR OR HIS RELATIVES BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
@


1.10
log
@do console stuff, pdc_call is in locore now
@
text
@d1 1
a1 1
/*	$OpenBSD: pdc.c,v 1.9 1999/09/07 03:25:13 mickey Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998,1999 Michael Shalayeff
d333 1
a333 1
#ifdef PDC_DEBUG
@


1.9
log
@this is what it was supposed to be in the last commit
@
text
@d1 1
a1 1
/*	$OpenBSD: pdc.c,v 1.8 1999/08/12 23:49:07 mickey Exp $	*/
d26 2
a27 2
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
d61 1
d74 5
d108 1
d145 42
a186 1
	return ENXIO;
d195 7
a201 1
	return ENXIO;
d261 1
a261 1
}
d263 17
a279 8
struct tty *
pdctty(dev)
	dev_t dev;
{
	if (minor(dev) != 0)
		panic("pdctty: bogus");

	return pdc_tty[0];
d298 24
d325 1
a325 1
	cn->cn_dev = makedev(28,0);
d339 1
a339 1
pdccngetc(dev)
d341 1
d343 1
a343 12
	static int stash = 0;
	register int err, c, l;

	if (!pdc)
		return 0;

	if (stash) {
		c = stash;
		if (!(dev & 0x80))
			stash = 0;
		return c;
	}
d345 3
a347 5
	do {
		err = pdc_call(pdc_kbdiodc, 0, pz_kbd->pz_hpa,
			       IODC_IO_CONSIN, pz_kbd->pz_spa,
			       pz_kbd->pz_layers, pdcret,
			       0, pdc_consbuf, 1, 0);
d349 2
a350 2
		l = pdcret[0];
		c = pdc_consbuf[0];
d352 2
a353 2
		if (err < 0)
			printf("pdccngetc: input error: %d\n", err);
d356 2
a357 3
		/* if we are doing ischar() report immidiatelly */
		if (dev & 0x80 && l == 0)
			return (0);
d359 5
a363 1
	} while(!l);
d365 5
a369 2
	if (dev & 0x80)
		stash = c;
a398 32

int
pdc_call(func, pdc_flag)
	iodcio_t func;
	int pdc_flag;
{
	register register_t ret, opsw;
	va_list va;
	int args[10], i, s;

	va_start(va, pdc_flag);
	for (i = 0; i < sizeof(args)/sizeof(args[0]); i++)
		args[i] = va_arg(va, int);
	va_end(va);

	if (kernelmapped) {
		s = splhigh();
		opsw = set_psw(PSW_Q |
			       ((!pdc_flag && args[0] == PDC_PIM)? PSW_M:0));
	}

	ret = (func)((void *)args[0], args[1], args[2], args[3], args[4],
		     args[5], args[6], args[7], args[8], args[9]);

	if (kernelmapped) {
		set_psw(opsw);
		splx(s);
	}

	return ret;
}

@


1.8
log
@splhigh() when calling pdc
@
text
@d1 1
a1 1
/*	$OpenBSD: pdc.c,v 1.7 1999/07/12 18:08:32 mickey Exp $	*/
d334 1
a334 1
		splhigh();
d344 1
a344 1
		s = splx(s);
@


1.7
log
@better set_psw() usage
@
text
@d1 1
a1 1
/*	$OpenBSD: pdc.c,v 1.6 1999/04/20 20:24:18 mickey Exp $	*/
d246 1
a246 1
#ifdef DEBUG
d326 1
a326 1
	int args[10], i;
d332 3
a334 2
	
	if (kernelmapped)
d337 1
d342 1
a342 1
	if (kernelmapped)
d344 2
@


1.6
log
@s/MINIOSIZ/IODC_MINIOSIZ/
@
text
@d1 1
a1 1
/*	$OpenBSD: pdc.c,v 1.5 1998/12/29 21:40:21 mickey Exp $	*/
d324 1
a324 1
	register register_t ret, psw;
d326 1
a326 1
	int args[11], i;
d333 3
a335 8
	if (kernelmapped) {
		psw = PSW_Q;
		
		if (!pdc_flag && args[0] == PDC_PIM)
			psw |= PSW_M;

		set_psw(psw);
	}
d338 1
a338 1
		     args[5], args[6], args[7], args[8], args[9], args[10]);
d340 2
a341 3
	if (kernelmapped) {
		set_psw(KERNEL_PSW);
	}
d345 1
@


1.5
log
@utilize PDC_ALIGNMENT
@
text
@d1 1
a1 1
/*	$OpenBSD: pdc.c,v 1.4 1998/11/23 02:58:11 mickey Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998 Michael Shalayeff
d57 1
a57 1
char pdc_consbuf[MINIOSIZ] PDC_ALIGNMENT;
@


1.4
log
@merge all PDC stuff in one file
@
text
@d1 1
a1 1
/*	$OpenBSD: pdc.c,v 1.3 1998/10/29 17:47:15 mickey Exp $	*/
d56 2
a57 2
int pdcret[32] __attribute__ ((aligned(8)));
char pdc_consbuf[MINIOSIZ] __attribute__ ((aligned(MINIOSIZ)));
@


1.3
log
@fix pdccngetc() input handling
@
text
@d1 1
a1 1
/*	$OpenBSD: pdc.c,v 1.2 1998/09/14 18:59:49 mickey Exp $	*/
d319 32
@


1.2
log
@iodc.h bye, bye
@
text
@d1 1
a1 1
/*	$OpenBSD: pdc.c,v 1.1 1998/09/12 02:51:34 mickey Exp $	*/
a44 1
#include <machine/autoconf.h>
d48 1
d76 4
d84 15
a98 3
	/* following the memory mappings, console iodc is at `mem_free' */
	pdc_cniodc = (iodcio_t)PAGE0->mem_free;
	pdc_kbdiodc = (iodcio_t)PAGE0->mem_free;
d110 1
a110 1
	/* struct cfdata *cf = cfdata; */
d114 1
a114 1
	if (pdc_cd.cd_ndevs || strcmp(ca->ca_name, pdc_cd.cd_name))
a125 1
	printf("\n");
d128 2
d246 3
a248 1

d255 2
a256 1
	int err;
d261 5
a265 6
	if ((err = pdc_call(pdc_kbdiodc, 0, pz_kbd->pz_hpa, IODC_IO_CONSIN,
			    &pz_kbd->pz_spa, pz_kbd->pz_layers, pdcret,
			    0, pdc_consbuf, 1, 0)) < 0) {
#ifdef DEBUG
		printf("pdc_getc: input error: %d\n", err);
#endif
d268 8
a275 2
	if (pdcret[0] == 0)
		return (0);
d277 2
a278 2
	if (pdcret[0] > 1)
		printf("pdc_getc: input got too much (%d)\n", pdcret[0]);
d280 11
a290 1
	return *pdc_consbuf;
d305 1
a305 1
		printf("pdc_putc: output error: %d\n", err);
@


1.1
log
@PDC console/tty
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a47 1
#include <machine/iodc.h>
@

