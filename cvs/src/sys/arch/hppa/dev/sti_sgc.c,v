head	1.40;
access;
symbols
	OPENBSD_6_1:1.40.0.10
	OPENBSD_6_1_BASE:1.40
	OPENBSD_6_0:1.40.0.8
	OPENBSD_6_0_BASE:1.40
	OPENBSD_5_9:1.40.0.4
	OPENBSD_5_9_BASE:1.40
	OPENBSD_5_8:1.40.0.6
	OPENBSD_5_8_BASE:1.40
	OPENBSD_5_7:1.40.0.2
	OPENBSD_5_7_BASE:1.40
	OPENBSD_5_6:1.39.0.4
	OPENBSD_5_6_BASE:1.39
	OPENBSD_5_5:1.38.0.24
	OPENBSD_5_5_BASE:1.38
	OPENBSD_5_4:1.38.0.20
	OPENBSD_5_4_BASE:1.38
	OPENBSD_5_3:1.38.0.18
	OPENBSD_5_3_BASE:1.38
	OPENBSD_5_2:1.38.0.16
	OPENBSD_5_2_BASE:1.38
	OPENBSD_5_1_BASE:1.38
	OPENBSD_5_1:1.38.0.14
	OPENBSD_5_0:1.38.0.12
	OPENBSD_5_0_BASE:1.38
	OPENBSD_4_9:1.38.0.10
	OPENBSD_4_9_BASE:1.38
	OPENBSD_4_8:1.38.0.8
	OPENBSD_4_8_BASE:1.38
	OPENBSD_4_7:1.38.0.4
	OPENBSD_4_7_BASE:1.38
	OPENBSD_4_6:1.38.0.6
	OPENBSD_4_6_BASE:1.38
	OPENBSD_4_5:1.38.0.2
	OPENBSD_4_5_BASE:1.38
	OPENBSD_4_4:1.37.0.4
	OPENBSD_4_4_BASE:1.37
	OPENBSD_4_3:1.37.0.2
	OPENBSD_4_3_BASE:1.37
	OPENBSD_4_2:1.35.0.4
	OPENBSD_4_2_BASE:1.35
	OPENBSD_4_1:1.35.0.2
	OPENBSD_4_1_BASE:1.35
	OPENBSD_4_0:1.32.0.2
	OPENBSD_4_0_BASE:1.32
	OPENBSD_3_9:1.29.0.6
	OPENBSD_3_9_BASE:1.29
	OPENBSD_3_8:1.29.0.4
	OPENBSD_3_8_BASE:1.29
	OPENBSD_3_7:1.29.0.2
	OPENBSD_3_7_BASE:1.29
	OPENBSD_3_6:1.23.0.2
	OPENBSD_3_6_BASE:1.23
	SMP_SYNC_A:1.22
	SMP_SYNC_B:1.22
	OPENBSD_3_5:1.21.0.2
	OPENBSD_3_5_BASE:1.21
	OPENBSD_3_4:1.16.0.2
	OPENBSD_3_4_BASE:1.16
	UBC_SYNC_A:1.11
	OPENBSD_3_3:1.9.0.6
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.4
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	UBC_SYNC_B:1.9
	UBC:1.7.0.2
	UBC_BASE:1.7
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9:1.5.0.4
	OPENBSD_2_9_BASE:1.5
	SMP:1.5.0.2
	OPENBSD_2_8:1.4.0.2
	OPENBSD_2_8_BASE:1.4;
locks; strict;
comment	@ * @;


1.40
date	2014.08.30.14.42.05;	author miod;	state Exp;
branches;
next	1.39;
commitid	oj0wrK8U5rsPDSqa;

1.39
date	2014.04.08.09.34.22;	author mpi;	state Exp;
branches;
next	1.38;

1.38
date	2009.02.06.22.51.04;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2007.09.15.14.28.17;	author krw;	state Exp;
branches;
next	1.36;

1.36
date	2007.08.23.19.13.28;	author kettenis;	state Exp;
branches;
next	1.35;

1.35
date	2007.01.11.21.58.05;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2006.12.18.18.57.26;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2006.11.30.11.25.11;	author mickey;	state Exp;
branches;
next	1.32;

1.32
date	2006.04.16.21.03.45;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2006.04.01.22.50.29;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2006.03.15.20.04.36;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2005.03.17.22.31.53;	author mickey;	state Exp;
branches;
next	1.28;

1.28
date	2005.03.17.22.15.15;	author mickey;	state Exp;
branches;
next	1.27;

1.27
date	2005.03.01.15.04.45;	author mickey;	state Exp;
branches;
next	1.26;

1.26
date	2005.02.27.22.10.57;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2005.01.23.16.53.19;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2004.09.15.20.11.28;	author mickey;	state Exp;
branches;
next	1.23;

1.23
date	2004.08.30.18.37.45;	author mickey;	state Exp;
branches;
next	1.22;

1.22
date	2004.04.07.18.24.19;	author mickey;	state Exp;
branches;
next	1.21;

1.21
date	2003.12.22.23.39.06;	author mickey;	state Exp;
branches;
next	1.20;

1.20
date	2003.12.17.05.22.38;	author mickey;	state Exp;
branches;
next	1.19;

1.19
date	2003.12.16.06.07.13;	author mickey;	state Exp;
branches;
next	1.18;

1.18
date	2003.10.30.19.25.12;	author mickey;	state Exp;
branches;
next	1.17;

1.17
date	2003.09.25.22.17.40;	author mickey;	state Exp;
branches;
next	1.16;

1.16
date	2003.08.21.18.03.18;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	2003.08.11.07.35.39;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	2003.07.16.06.42.06;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	2003.05.20.20.54.43;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	2003.05.19.09.32.16;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	2003.05.07.18.26.09;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	2003.03.29.00.56.08;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.14.01.26.31;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.01.25.21.37.15;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	2001.11.06.19.53.14;	author miod;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2001.09.11.20.05.24;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2001.01.11.21.24.41;	author mickey;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2000.09.03.21.01.50;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	2000.06.15.03.04.17;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	2000.06.13.18.36.37;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	2000.05.30.19.42.02;	author mickey;	state Exp;
branches;
next	;

1.5.2.1
date	2001.04.18.16.06.01;	author niklas;	state Exp;
branches;
next	1.5.2.2;

1.5.2.2
date	2001.10.31.02.52.46;	author nate;	state Exp;
branches;
next	1.5.2.3;

1.5.2.3
date	2001.11.13.21.00.51;	author niklas;	state Exp;
branches;
next	1.5.2.4;

1.5.2.4
date	2002.03.06.00.57.22;	author niklas;	state Exp;
branches;
next	1.5.2.5;

1.5.2.5
date	2002.03.28.10.07.19;	author niklas;	state Exp;
branches;
next	1.5.2.6;

1.5.2.6
date	2003.05.13.19.41.03;	author ho;	state Exp;
branches;
next	1.5.2.7;

1.5.2.7
date	2003.06.07.11.11.36;	author ho;	state Exp;
branches;
next	1.5.2.8;

1.5.2.8
date	2004.02.19.10.48.39;	author niklas;	state Exp;
branches;
next	1.5.2.9;

1.5.2.9
date	2004.06.05.23.10.47;	author niklas;	state Exp;
branches;
next	;

1.7.2.1
date	2002.01.31.22.55.09;	author niklas;	state Exp;
branches;
next	1.7.2.2;

1.7.2.2
date	2002.06.11.03.35.36;	author art;	state Exp;
branches;
next	1.7.2.3;

1.7.2.3
date	2003.05.19.21.49.41;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.40
log
@Fix format strings in STIDEBUG code.
@
text
@/*	$OpenBSD: sti_sgc.c,v 1.39 2014/04/08 09:34:22 mpi Exp $	*/

/*
 * Copyright (c) 2000-2003 Michael Shalayeff
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR OR HIS RELATIVES BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */
/*
 * These cards has to be known to work so far:
 *	- HPA1991AGrayscale rev 0.02	(705/35) (byte-wide)
 *	- HPA1991AC19       rev 0.02	(715/33) (byte-wide)
 *	- HPA208LC1280      rev 8.04	(712/80) just works
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>

#include <machine/bus.h>
#include <machine/cpu.h>
#include <machine/iomod.h>
#include <machine/autoconf.h>

#include <dev/wscons/wsdisplayvar.h>
#include <dev/wscons/wsconsio.h>

#include <dev/ic/stireg.h>
#include <dev/ic/stivar.h>

#include <hppa/dev/cpudevs.h>

#define	STI_ROMSIZE	(sizeof(struct sti_dd) * 4)
#define	STI_ID_FDDI	0x280b31af	/* Medusa FDDI ROM id */

/* gecko optional graphics (these share the onboard's prom) */
const char sti_sgc_opt[] = { 0x17, 0x20, 0x30, 0x40, 0x70, 0xc0, 0xd0 };

extern struct cfdriver sti_cd;

int	sti_sgc_probe(struct device *, void *, void *);
void	sti_sgc_attach(struct device *, struct device *, void *);
paddr_t	sti_sgc_getrom(int, struct confargs *);

struct cfattach sti_gedoens_ca = {
	sizeof(struct sti_softc), sti_sgc_probe, sti_sgc_attach
};

/*
 * Locate STI ROM.
 * On some machines it may not be part of the HPA space.
 */
paddr_t
sti_sgc_getrom(int unit, struct confargs *ca)
{
	paddr_t rom = PAGE0->pd_resv2[1];
	int i;

	if (unit) {
		i = -1;
		if (ca->ca_type.iodc_sv_model == HPPA_FIO_GSGC)
			for (i = sizeof(sti_sgc_opt); i-- &&
			    sti_sgc_opt[i] != ca->ca_type.iodc_revision; )
				;
		if (i < 0)
			rom = 0;
	}

	if (rom < HPPA_IOBEGIN) {
		if (ca->ca_naddrs > 0)
			rom = ca->ca_addrs[0].addr;
		else
			rom = ca->ca_hpa;
	}

	return (rom);
}

int
sti_sgc_probe(struct device *parent, void *match, void *aux)
{
	struct cfdata *cf = match;
	struct confargs *ca = aux;
	bus_space_handle_t romh;
	paddr_t rom;
	u_int32_t id;
	u_char devtype;
	int rv = 0, romunmapped = 0;

	/* due to the graphic nature of this program do probe only one */
	if (cf->cf_unit > sti_cd.cd_ndevs)
		return (0);

	if (ca->ca_type.iodc_type != HPPA_TYPE_FIO)
		return (0);

	/* these need further checking for the graphics id */
	if (ca->ca_type.iodc_sv_model != HPPA_FIO_GSGC &&
	    ca->ca_type.iodc_sv_model != HPPA_FIO_SGC)
		return 0;

	rom = sti_sgc_getrom(cf->cf_unit, ca);
#ifdef STIDEBUG
	printf ("sti: hpa=%lx, rom=%lx\n", ca->ca_hpa, rom);
#endif

	/* if it does not map, probably part of the lasi space */
	if ((rv = bus_space_map(ca->ca_iot, rom, STI_ROMSIZE, 0, &romh))) {
#ifdef STIDEBUG
		printf ("sti: cannot map rom space (%d)\n", rv);
#endif
		if ((rom & HPPA_IOBEGIN) == HPPA_IOBEGIN) {
			romh = rom;
			romunmapped++;
		} else {
			/* in this case nobody has no freaking idea */
			return 0;
		}
	}

	devtype = bus_space_read_1(ca->ca_iot, romh, 3);

#ifdef STIDEBUG
	printf("sti: devtype=%d\n", devtype);
#endif
	rv = 1;
	switch (devtype) {
	case STI_DEVTYPE4:
		id = bus_space_read_4(ca->ca_iot, romh, 0x8);
		break;
	case STI_DEVTYPE1:
		id = (bus_space_read_1(ca->ca_iot, romh, 0x10 +  3) << 24) |
		     (bus_space_read_1(ca->ca_iot, romh, 0x10 +  7) << 16) |
		     (bus_space_read_1(ca->ca_iot, romh, 0x10 + 11) <<  8) |
		     (bus_space_read_1(ca->ca_iot, romh, 0x10 + 15));
		break;
	default:
#ifdef STIDEBUG
		printf("sti: unknown type (%x)\n", devtype);
#endif
		rv = 0;
	}

	if (rv &&
	    ca->ca_type.iodc_sv_model == HPPA_FIO_SGC && id == STI_ID_FDDI) {
#ifdef STIDEBUG
		printf("sti: not a graphics device\n");
#endif
		rv = 0;
	}

	if (ca->ca_naddrs >= sizeof(ca->ca_addrs)/sizeof(ca->ca_addrs[0])) {
		printf("sti: address list overflow\n");
		return (0);
	}

	ca->ca_addrs[ca->ca_naddrs].addr = rom;
	ca->ca_addrs[ca->ca_naddrs].size = sti_rom_size(ca->ca_iot, romh);
	ca->ca_naddrs++;

	if (!romunmapped)
		bus_space_unmap(ca->ca_iot, romh, STI_ROMSIZE);
	return (rv);
}

void
sti_sgc_attach(struct device *parent, struct device *self, void *aux)
{
	struct sti_softc *sc = (void *)self;
	struct confargs *ca = aux;
	bus_space_handle_t romh;
	paddr_t rom;
	u_int32_t romlen;
	int rv;
	int i;

	/* we stashed rom addr/len into the last slot during probe */
	rom = ca->ca_addrs[ca->ca_naddrs - 1].addr;
	romlen = ca->ca_addrs[ca->ca_naddrs - 1].size;
	if ((rv = bus_space_map(ca->ca_iot, rom, romlen, 0, &romh))) {
		if ((rom & HPPA_IOBEGIN) == HPPA_IOBEGIN)
			romh = rom;
		else {
			printf (": cannot map rom space (%d)\n", rv);
			return;
		}
	}

	sc->bases[0] = romh;
	for (i = 1; i < STI_REGION_MAX; i++)
		sc->bases[i] = ca->ca_hpa;

#ifdef	HP7300LC_CPU
	/* PCXL2: enable accel i/o for this space */
	if (cpu_type == hpcxl2)
		eaio_l2(0x8 >> (((ca->ca_hpa >> 25) & 3) - 2));
#endif

	if (ca->ca_hpa == (hppa_hpa_t)PAGE0->mem_cons.pz_hpa)
		sc->sc_flags |= STI_CONSOLE;
	if (sti_attach_common(sc, ca->ca_iot, ca->ca_iot, romh,
	    STI_CODEBASE_PA) == 0)
		startuphook_establish(sti_end_attach, sc);
}
@


1.39
log
@Less <uvm/uvm.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: sti_sgc.c,v 1.38 2009/02/06 22:51:04 miod Exp $	*/
d123 1
a123 1
	printf ("sti: hpa=%x, rom=%x\n", ca->ca_hpa, rom);
@


1.38
log
@Split sti structures into rom-related information and screen-related
information. This is preliminary work to help eventually supporting the
dual-head ELK model.

Also split the initialization code in several routines, this makes the
code easier to read, and makes it easier to release resources upon failure.

Finally, don't forget to clear the text planes on non-console displays
when initializing.
@
text
@d1 1
a1 1
/*	$OpenBSD: sti_sgc.c,v 1.37 2007/09/15 14:28:17 krw Exp $	*/
a37 2

#include <uvm/uvm.h>
@


1.37
log
@[fF]uther -> [fF]urther in comments and man page. First one spotted on
tech@@ by Jung.
@
text
@d1 1
a1 1
/*	$OpenBSD: sti_sgc.c,v 1.36 2007/08/23 19:13:28 kettenis Exp $	*/
d58 1
a58 1
char sti_sgc_opt[] = { 0x17, 0x20, 0x30, 0x40, 0x70, 0xc0, 0xd0 };
d101 1
a101 3
sti_sgc_probe(parent, match, aux)
	struct device *parent;
	void *match, *aux;
d188 1
a188 3
sti_sgc_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d192 1
a197 2
	sc->memt = sc->iot = ca->ca_iot;

d201 1
a201 1
	if ((rv = bus_space_map(ca->ca_iot, rom, romlen, 0, &sc->romh))) {
d203 1
a203 1
			sc->romh = rom;
d210 1
a210 1
	sc->bases[0] = sc->romh;
d222 2
a223 1
	if (sti_attach_common(sc, STI_CODEBASE_PA) == 0)
@


1.36
log
@Look for STI firmware at the additional address given by the firmware.  This
removes the need for the hardcoded address for the internal Visualize EG on the
B180L, and makes it work on the C180.  Tested on a handful of other models too.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sti_sgc.c,v 1.35 2007/01/11 21:58:05 miod Exp $	*/
d120 1
a120 1
	/* these need futher checking for the graphics id */
@


1.35
log
@Allow sti_attach_common() to return an error code, and do not fall into
sti_end_attach() if an error has occured.

ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sti_sgc.c,v 1.34 2006/12/18 18:57:26 miod Exp $	*/
a59 4
/* internal EG */
#define	STI_INEG_REV	0x60
#define	STI_INEG_PROM	0xf0011000

d91 2
a92 4
		if (unit == 0 &&
		    ca->ca_type.iodc_sv_model == HPPA_FIO_GSGC &&
		    ca->ca_type.iodc_revision == STI_INEG_REV)
			rom = STI_INEG_PROM;
@


1.34
log
@Change sti attachment to pass an array of base addresses for the sti regions,
instead of using the rom mapping for region #0 and the device mapping for
region #1. This will allow sti devices on which regions may be relative to
different origins to attach (to be used very soon).

ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sti_sgc.c,v 1.33 2006/11/30 11:25:11 mickey Exp $	*/
d233 2
a234 2
	sti_attach_common(sc, STI_CODEBASE_PA);
	startuphook_establish(sti_end_attach, sc);
@


1.33
log
@replace a bunch of ifs w/ an array scan and add a few more
@
text
@d1 1
a1 1
/*	$OpenBSD: sti_sgc.c,v 1.32 2006/04/16 21:03:45 miod Exp $	*/
d66 3
a68 2
int sti_sgc_probe(struct device *, void *, void *);
void sti_sgc_attach(struct device *, struct device *, void *);
d205 1
a207 1
	sc->base = ca->ca_hpa;
d220 4
@


1.32
log
@Introduce sti_rom_size() which will compute the size of a card's rom, and
use it instead of duplicating the same logic in 3 places.

ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sti_sgc.c,v 1.31 2006/04/01 22:50:29 miod Exp $	*/
d57 2
a58 6
/* gecko optional graphics */
#define	STI_GOPT1_REV	0x17
#define	STI_GOPT2_REV	0x70
#define	STI_GOPT3_REV	0xd0
#define	STI_GOPT4_REV	0x20
#define	STI_GOPT5_REV	0x40
d81 1
d84 6
a89 8
		if (ca->ca_type.iodc_sv_model == HPPA_FIO_GSGC &&
		    (ca->ca_type.iodc_revision == STI_GOPT1_REV ||
		     ca->ca_type.iodc_revision == STI_GOPT2_REV ||
		     ca->ca_type.iodc_revision == STI_GOPT3_REV ||
		     ca->ca_type.iodc_revision == STI_GOPT4_REV ||
		     ca->ca_type.iodc_revision == STI_GOPT5_REV))
			/* these share the onboard's prom */ ;
		else
@


1.31
log
@Revert previous commit, this causes sti1 probe to hang on some models.
@
text
@d1 1
a1 1
/*	$OpenBSD: sti_sgc.c,v 1.30 2006/03/15 20:04:36 miod Exp $	*/
d119 1
a119 1
	u_int32_t id, romend;
a162 1
		romend = bus_space_read_4(ca->ca_iot, romh, 0x18);
a168 5
		romend =
		     (bus_space_read_1(ca->ca_iot, romh, 0x50 +  3) << 24) |
		     (bus_space_read_1(ca->ca_iot, romh, 0x50 +  7) << 16) |
		     (bus_space_read_1(ca->ca_iot, romh, 0x50 + 11) <<  8) |
		     (bus_space_read_1(ca->ca_iot, romh, 0x50 + 15));
a174 1
		romend = 0;
d191 1
a191 1
	ca->ca_addrs[ca->ca_naddrs].size = round_page(romend);
@


1.30
log
@Correct checks against cd_ndevs - valid numbers are strictly inferior to
cd_ndevs.
@
text
@d1 1
a1 1
/*	$OpenBSD: sti_sgc.c,v 1.29 2005/03/17 22:31:53 mickey Exp $	*/
d124 1
a124 1
	if (sti_cd.cd_ndevs != 0)
@


1.29
log
@fix comment wrt previous change
@
text
@d1 1
a1 1
/*	$OpenBSD: sti_sgc.c,v 1.28 2005/03/17 22:15:15 mickey Exp $	*/
d124 1
a124 1
	if (cf->cf_unit > sti_cd.cd_ndevs)
@


1.28
log
@add two more revs of romless cards; from netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: sti_sgc.c,v 1.27 2005/03/01 15:04:45 mickey Exp $	*/
d93 1
a93 1
			/* these three share the onboard's prom */ ;
@


1.27
log
@only call eaio_l2() if kernel has support for pcxl2 compiled in; from weissmanndude
@
text
@d1 1
a1 1
/*	$OpenBSD: sti_sgc.c,v 1.26 2005/02/27 22:10:57 miod Exp $	*/
d61 2
d90 3
a92 1
		     ca->ca_type.iodc_revision == STI_GOPT3_REV))
d181 1
@


1.26
log
@Split sti softc in two structures, one device-related for regular device
attachment and interface, one screen-attached for the real work.

The attachment code is now required to decide whether sti_end_attach() is
run immediately, or as a startuphook.

This allows hp300 to initialize sti early, and use it as a console; hppa
is functionally unchanged, as it uses the PROM console until the root device
is mounted.
@
text
@d1 1
a1 1
/*	$OpenBSD: sti_sgc.c,v 1.25 2005/01/23 16:53:19 miod Exp $	*/
d227 1
d231 1
@


1.25
log
@Two sti(4) changes necessary for hp300:
- specify which microcode bank (pa or m68k) to use at attachment time.
- compensate for broken 8.02 m68k code which reports wrong frame buffer
  offset.

ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sti_sgc.c,v 1.24 2004/09/15 20:11:28 mickey Exp $	*/
d227 1
a227 1
	/* PCXL2: enale accel i/o for this space */
d234 1
@


1.24
log
@scan cpu bus manually for some machines do not support that in prom
@
text
@d1 1
a1 1
/*	$OpenBSD: sti_sgc.c,v 1.23 2004/08/30 18:37:45 mickey Exp $	*/
d233 1
a233 1
	sti_attach_common(sc);
@


1.23
log
@another card tat uses system prom
@
text
@d1 1
a1 1
/*	$OpenBSD: sti_sgc.c,v 1.22 2004/04/07 18:24:19 mickey Exp $	*/
d71 1
a71 5
struct cfattach sti_sgc_ca = {
	sizeof(struct sti_softc), sti_sgc_probe, sti_sgc_attach
};

struct cfattach sti_phantom_ca = {
a230 1
	sc->sc_devtype = bus_space_read_1(sc->iot, sc->romh, 3);
@


1.22
log
@update copyright; miod@@ is fine w/ files where he holds it too
@
text
@d1 1
a1 1
/*	$OpenBSD: sti_sgc.c,v 1.21 2003/12/22 23:39:06 mickey Exp $	*/
d60 1
d91 3
a93 2
		     ca->ca_type.iodc_revision == STI_GOPT2_REV))
			/* these two share the onboard's prom */ ;
@


1.21
log
@make sure to run probe only once per device w/ grumpy testing
@
text
@d1 1
a1 1
/*	$OpenBSD: sti_sgc.c,v 1.20 2003/12/17 05:22:38 mickey Exp $	*/
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Michael Shalayeff.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d19 8
a26 7
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF MIND,
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@


1.20
log
@figure out the used prom size in probe() and pass that into attach that will map rom proper instead of a fixed size that is not enough in a generic case
@
text
@d1 1
a1 1
/*	$OpenBSD: sti_sgc.c,v 1.19 2003/12/16 06:07:13 mickey Exp $	*/
d69 2
d124 4
@


1.19
log
@only map the rom and do not touch the hpa space getting rid of memsize define that was not really true; plus tested by otto@@ and miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sti_sgc.c,v 1.18 2003/10/30 19:25:12 mickey Exp $	*/
d58 1
a58 1
#define	STI_ROMSIZE	0x8000
d119 1
a119 1
	u_int32_t id;
a125 4
	/* these can only be graphics anyway */
	if (ca->ca_type.iodc_sv_model == HPPA_FIO_GSGC)
		return (1);

d127 2
a128 1
	if (ca->ca_type.iodc_sv_model != HPPA_FIO_SGC)
a149 4
#ifdef STIDEBUG
	printf("sti: romh=%x\n", romh);
#endif

d159 1
d166 5
a170 1

d187 9
d209 1
d215 4
a218 2
	rom = sti_sgc_getrom(sc->sc_dev.dv_cfdata->cf_unit, ca);
	if ((rv = bus_space_map(ca->ca_iot, rom, STI_ROMSIZE, 0, &sc->romh))) {
@


1.18
log
@typos and grammer from Bruno Rohee <bruno@@rohee.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: sti_sgc.c,v 1.17 2003/09/25 22:17:40 mickey Exp $	*/
a57 1
#define	STI_MEMSIZE	0x2000000
a203 5
	rom = sti_sgc_getrom(sc->sc_dev.dv_cfdata->cf_unit, ca);

#ifdef STIDEBUG
	printf("sti: hpa=%x, rom=%x\n", ca->ca_hpa, rom);
#endif
d205 1
d207 2
a208 12
	if ((rv = bus_space_map(ca->ca_iot, ca->ca_hpa, STI_MEMSIZE, 0,
	    &sc->ioh))) {
#ifdef STIDEBUG
		printf(": cannot map io space (%d)\n", rv);
#endif
		return;
	}

	/* if it does not map, probably part of the lasi space */
	if (rom == ca->ca_hpa)
		sc->romh = sc->ioh;
	else if ((rv = bus_space_map(ca->ca_iot, rom, STI_ROMSIZE, 0, &sc->romh))) {
a211 1
#ifdef STIDEBUG
a212 3
#endif
			/* in this case i have no freaking idea */
			bus_space_unmap(ca->ca_iot, sc->ioh,  STI_MEMSIZE);
a220 3
#ifdef STIDEBUG
	printf("sti: ioh=%x, romh=%x\n", sc->ioh, sc->romh);
#endif
@


1.17
log
@provide a function to enable accel io on pcxl2 and use it on the fb
@
text
@d1 1
a1 1
/*	$OpenBSD: sti_sgc.c,v 1.16 2003/08/21 18:03:18 mickey Exp $	*/
d149 1
a149 1
			/* in this case i have no freaking idea */
@


1.16
log
@better guess on dual-card (not dual-head cards) rom adress guessing; miod@@ testing
@
text
@d1 1
a1 1
/*	$OpenBSD: sti_sgc.c,v 1.15 2003/08/11 07:35:39 mickey Exp $	*/
d235 4
@


1.15
log
@during probe there is no need to map the whole hpa space. only rom is needed. also do not map too much of rom
@
text
@d1 1
a1 1
/*	$OpenBSD: sti_sgc.c,v 1.14 2003/07/16 06:42:06 mickey Exp $	*/
d62 5
d86 1
a86 1
sti_sgc_getrom(struct confargs *ca)
d88 1
a88 1
	paddr_t rom;
d90 1
a90 1
	if (PAGE0->pd_resv2[1] < HPPA_IOBEGIN)
d92 10
d106 1
a106 2
	else
		rom = PAGE0->pd_resv2[1];
d116 1
d135 1
a135 1
	rom = sti_sgc_getrom(ca);
d205 1
a205 1
	rom = sti_sgc_getrom(ca);
@


1.14
log
@only match int-eg on gecko sgc cards
@
text
@d1 1
a1 1
/*	$OpenBSD: sti_sgc.c,v 1.13 2003/05/20 20:54:43 mickey Exp $	*/
d59 1
a59 1
#define	STI_ROMSIZE	0x30000
d103 1
a103 1
	bus_space_handle_t ioh, romh;
a119 7
	if ((rv = bus_space_map(ca->ca_iot, ca->ca_hpa, STI_MEMSIZE, 0, &ioh))) {
#ifdef STIDEBUG
		printf("st: cannot map io space (%d)\n", rv);
#endif
		return 0;
	}

a124 5
	if (rom == ca->ca_hpa) {
		romh = ioh;
		romunmapped++;
	}

d126 1
a126 2
	if (rom != ca->ca_hpa &&
	    (rv = bus_space_map(ca->ca_iot, rom, IOMOD_HPASIZE, 0, &romh))) {
a134 1
			bus_space_unmap(ca->ca_iot, ioh,  STI_MEMSIZE);
d140 1
a140 1
	printf("sti: ioh=%x, romh=%x\n", ioh, romh);
d167 2
a168 1
	if (ca->ca_type.iodc_sv_model == HPPA_FIO_SGC && id == STI_ID_FDDI) {
a174 1
	bus_space_unmap(ca->ca_iot, ioh,  STI_MEMSIZE);
d176 1
a176 1
		bus_space_unmap(ca->ca_iot, romh, IOMOD_HPASIZE);
d187 1
a187 1
	paddr_t addr;
d190 1
a190 1
	addr = sti_sgc_getrom(ca);
d193 1
a193 1
	printf("sti: hpa=%x, rom=%x\n", ca->ca_hpa, addr);
d206 1
a206 1
	if (addr == ca->ca_hpa)
d208 3
a210 3
	else if ((rv = bus_space_map(ca->ca_iot, addr, STI_ROMSIZE, 0, &sc->romh))) {
		if ((addr & HPPA_IOBEGIN) == HPPA_IOBEGIN)
			sc->romh = addr;
@


1.13
log
@create a devine routine for devising the holy rom address and use it in both match and attach then
@
text
@d1 1
a1 1
/*	$OpenBSD: sti_sgc.c,v 1.12 2003/05/19 09:32:16 mickey Exp $	*/
d86 2
a87 1
		if (ca->ca_type.iodc_revision == STI_INEG_REV)
@


1.12
log
@dig internal EG prom address
@
text
@d1 1
a1 1
/*	$OpenBSD: sti_sgc.c,v 1.11 2003/05/07 18:26:09 mickey Exp $	*/
d76 20
d103 2
a104 1
	u_int32_t id, rom;
d126 1
a126 15
	/*
	 * Locate STI ROM.
	 * On some machines it may not be part of the HPA space.
	 */
	if (PAGE0->pd_resv2[1] < HPPA_IOBEGIN) {
		if (ca->ca_type.iodc_revision == STI_INEG_REV)
			rom = STI_INEG_PROM;
		else {
			rom = ca->ca_hpa;
			romh = ioh;
			romunmapped++;
		}
	} else
		rom = PAGE0->pd_resv2[1];

d131 5
d200 1
a200 1
	bus_addr_t addr;
d203 1
a203 7
	if (PAGE0->pd_resv2[1] < HPPA_IOBEGIN)
		if (ca->ca_type.iodc_revision == STI_INEG_REV)
			addr = STI_INEG_PROM;
		else
			addr = ca->ca_hpa;
	else
		addr = PAGE0->pd_resv2[1];
@


1.11
log
@double memsize as there might be prom as well
@
text
@d1 1
a1 1
/*	$OpenBSD: sti_sgc.c,v 1.10 2003/03/29 00:56:08 mickey Exp $	*/
d62 3
d110 7
a116 3
		rom = ca->ca_hpa;
		romh = ioh;
		romunmapped++;
d192 4
a195 1
		addr = ca->ca_hpa;
@


1.10
log
@allow attaching onto phantomas. check graphics id to seed out the medusa fddi. fix some debugging printfs
@
text
@d1 1
a1 1
/*	$OpenBSD: sti_sgc.c,v 1.9 2002/03/14 01:26:31 millert Exp $	*/
d58 1
a58 1
#define	STI_MEMSIZE	0x1000000
@


1.9
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: sti_sgc.c,v 1.8 2002/01/25 21:37:15 mickey Exp $	*/
d4 1
a4 1
 * Copyright (c) 2000 Michael Shalayeff
d59 2
d62 1
a62 1
int  sti_sgc_probe(struct device *, void *, void *);
d69 4
d78 1
a78 1
	register struct confargs *ca = aux;
d80 1
a80 1
	u_int rom;
d84 9
a92 3
	if (ca->ca_type.iodc_type != HPPA_TYPE_FIO ||
	    (ca->ca_type.iodc_sv_model != HPPA_FIO_GSGC &&
	     ca->ca_type.iodc_sv_model != HPPA_FIO_SGC))
d142 13
a154 4
#if 0 /* ignore this for now */
	if ((ca->ca_type.iodc_sv_model == HPPA_FIO_SGC &&
	     STI_ID_HI(STI_TYPE_BWGRF, rioh) == STI_ID_FDDI) ||
	    (devtype != STI_TYPE_BWGRF && devtype != STI_TYPE_WWGRF)) {
d156 1
a156 1
		printf("sti: not a graphics device (%x)\n", devtype);
d158 6
a163 1
	} else
d165 2
a166 1
		rv = 1;
d171 1
a171 1
	return rv;
d189 3
d197 1
a197 1
		printf("st: cannot map io space (%d)\n", rv);
d205 1
a205 4
	else if ((rv = bus_space_map(ca->ca_iot, addr, IOMOD_HPASIZE, 0, &sc->romh))) {
#ifdef STIDEBUG
		printf ("sti: cannot map rom space (%d)\n", rv);
#endif
d209 3
a217 1
	sc->sc_devtype = bus_space_read_1(sc->iot, sc->romh, 3);
a218 1
	printf("sti: hpa=%x, rom=%x\n", ca->ca_hpa, addr);
d221 1
a225 1

@


1.8
log
@see if we are a console
@
text
@d1 1
a1 1
/*	$OpenBSD: sti_sgc.c,v 1.7 2001/11/06 19:53:14 miod Exp $	*/
d60 2
a61 2
int  sti_sgc_probe __P((struct device *, void *, void *));
void sti_sgc_attach __P((struct device *, struct device *, void *));
@


1.7
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: sti_sgc.c,v 1.6 2001/09/11 20:05:24 miod Exp $	*/
d193 2
@


1.7.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: sti_sgc.c,v 1.8 2002/01/25 21:37:15 mickey Exp $	*/
a192 2
	if (ca->ca_hpa == (hppa_hpa_t)PAGE0->mem_cons.pz_hpa)
		sc->sc_flags |= STI_CONSOLE;
@


1.7.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: sti_sgc.c,v 1.7.2.1 2002/01/31 22:55:09 niklas Exp $	*/
d60 2
a61 2
int  sti_sgc_probe(struct device *, void *, void *);
void sti_sgc_attach(struct device *, struct device *, void *);
@


1.7.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d4 1
a4 1
 * Copyright (c) 2000-2003 Michael Shalayeff
d58 1
a58 3
#define	STI_MEMSIZE	0x2000000
#define	STI_ROMSIZE	0x30000
#define	STI_ID_FDDI	0x280b31af	/* Medusa FDDI ROM id */
d60 1
a60 1
int sti_sgc_probe(struct device *, void *, void *);
a66 4
struct cfattach sti_phantom_ca = {
	sizeof(struct sti_softc), sti_sgc_probe, sti_sgc_attach
};

d72 1
a72 1
	struct confargs *ca = aux;
d74 1
a74 1
	u_int32_t id, rom;
d78 3
a80 9
	if (ca->ca_type.iodc_type != HPPA_TYPE_FIO)
		return (0);

	/* these can only be graphics anyway */
	if (ca->ca_type.iodc_sv_model == HPPA_FIO_GSGC)
		return (1);

	/* these need futher checking for the graphics id */
	if (ca->ca_type.iodc_sv_model != HPPA_FIO_SGC)
d130 4
a133 13
	rv = 1;
	switch (devtype) {
	case STI_DEVTYPE4:
		id = bus_space_read_4(ca->ca_iot, romh, 0x8);
		break;
	case STI_DEVTYPE1:
		id = (bus_space_read_1(ca->ca_iot, romh, 0x10 +  3) << 24) |
		     (bus_space_read_1(ca->ca_iot, romh, 0x10 +  7) << 16) |
		     (bus_space_read_1(ca->ca_iot, romh, 0x10 + 11) <<  8) |
		     (bus_space_read_1(ca->ca_iot, romh, 0x10 + 15));

		break;
	default:
d135 1
a135 1
		printf("sti: unknown type (%x)\n", devtype);
d137 1
a137 6
		rv = 0;
	}

	if (ca->ca_type.iodc_sv_model == HPPA_FIO_SGC && id == STI_ID_FDDI) {
#ifdef STIDEBUG
		printf("sti: not a graphics device\n");
d139 1
a139 2
		rv = 0;
	}
d144 1
a144 1
	return (rv);
a161 3
#ifdef STIDEBUG
	printf("sti: hpa=%x, rom=%x\n", ca->ca_hpa, addr);
#endif
d167 1
a167 1
		printf(": cannot map io space (%d)\n", rv);
d175 4
a178 1
	else if ((rv = bus_space_map(ca->ca_iot, addr, STI_ROMSIZE, 0, &sc->romh))) {
a181 3
#ifdef STIDEBUG
			printf (": cannot map rom space (%d)\n", rv);
#endif
d188 1
d190 1
a192 1
	sc->sc_devtype = bus_space_read_1(sc->iot, sc->romh, 3);
d197 1
@


1.6
log
@Don't include <vm/vm_kern.h> if you don't need foo_map.
@
text
@d1 1
a1 1
/*	$OpenBSD: sti_sgc.c,v 1.5 2001/01/11 21:24:41 mickey Exp $	*/
a42 1
#include <vm/vm.h>
@


1.5
log
@read rom through the rom handle
@
text
@d1 1
a1 1
/*	$OpenBSD: sti_sgc.c,v 1.4 2000/09/03 21:01:50 mickey Exp $	*/
a43 1
#include <vm/vm_kern.h>
@


1.5.2.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: sti_sgc.c,v 1.5 2001/01/11 21:24:41 mickey Exp $	*/
@


1.5.2.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: sti_sgc.c,v 1.5.2.1 2001/04/18 16:06:01 niklas Exp $	*/
d44 1
@


1.5.2.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d43 1
@


1.5.2.4
log
@Merge in trunk
@
text
@a192 2
	if (ca->ca_hpa == (hppa_hpa_t)PAGE0->mem_cons.pz_hpa)
		sc->sc_flags |= STI_CONSOLE;
@


1.5.2.5
log
@Merge in -current from about a week ago
@
text
@d60 2
a61 2
int  sti_sgc_probe(struct device *, void *, void *);
void sti_sgc_attach(struct device *, struct device *, void *);
@


1.5.2.6
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: sti_sgc.c,v 1.5.2.5 2002/03/28 10:07:19 niklas Exp $	*/
d4 1
a4 1
 * Copyright (c) 2000-2003 Michael Shalayeff
d58 1
a58 3
#define	STI_MEMSIZE	0x2000000
#define	STI_ROMSIZE	0x30000
#define	STI_ID_FDDI	0x280b31af	/* Medusa FDDI ROM id */
d60 1
a60 1
int sti_sgc_probe(struct device *, void *, void *);
a66 4
struct cfattach sti_phantom_ca = {
	sizeof(struct sti_softc), sti_sgc_probe, sti_sgc_attach
};

d72 1
a72 1
	struct confargs *ca = aux;
d74 1
a74 1
	u_int32_t id, rom;
d78 3
a80 9
	if (ca->ca_type.iodc_type != HPPA_TYPE_FIO)
		return (0);

	/* these can only be graphics anyway */
	if (ca->ca_type.iodc_sv_model == HPPA_FIO_GSGC)
		return (1);

	/* these need futher checking for the graphics id */
	if (ca->ca_type.iodc_sv_model != HPPA_FIO_SGC)
d130 4
a133 13
	rv = 1;
	switch (devtype) {
	case STI_DEVTYPE4:
		id = bus_space_read_4(ca->ca_iot, romh, 0x8);
		break;
	case STI_DEVTYPE1:
		id = (bus_space_read_1(ca->ca_iot, romh, 0x10 +  3) << 24) |
		     (bus_space_read_1(ca->ca_iot, romh, 0x10 +  7) << 16) |
		     (bus_space_read_1(ca->ca_iot, romh, 0x10 + 11) <<  8) |
		     (bus_space_read_1(ca->ca_iot, romh, 0x10 + 15));

		break;
	default:
d135 1
a135 1
		printf("sti: unknown type (%x)\n", devtype);
d137 1
a137 6
		rv = 0;
	}

	if (ca->ca_type.iodc_sv_model == HPPA_FIO_SGC && id == STI_ID_FDDI) {
#ifdef STIDEBUG
		printf("sti: not a graphics device\n");
d139 1
a139 2
		rv = 0;
	}
d144 1
a144 1
	return (rv);
a161 3
#ifdef STIDEBUG
	printf("sti: hpa=%x, rom=%x\n", ca->ca_hpa, addr);
#endif
d167 1
a167 1
		printf(": cannot map io space (%d)\n", rv);
d175 4
a178 1
	else if ((rv = bus_space_map(ca->ca_iot, addr, STI_ROMSIZE, 0, &sc->romh))) {
a181 3
#ifdef STIDEBUG
			printf (": cannot map rom space (%d)\n", rv);
#endif
d188 1
d190 1
a192 1
	sc->sc_devtype = bus_space_read_1(sc->iot, sc->romh, 3);
d197 1
@


1.5.2.7
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: sti_sgc.c,v 1.5.2.6 2003/05/13 19:41:03 ho Exp $	*/
a61 3
#define	STI_INEG_REV	0x60
#define	STI_INEG_PROM	0xf0011000

a72 20
/*
 * Locate STI ROM.
 * On some machines it may not be part of the HPA space.
 */
paddr_t
sti_sgc_getrom(struct confargs *ca)
{
	paddr_t rom;

	if (PAGE0->pd_resv2[1] < HPPA_IOBEGIN)
		if (ca->ca_type.iodc_revision == STI_INEG_REV)
			rom = STI_INEG_PROM;
		else
			rom = ca->ca_hpa;
	else
		rom = PAGE0->pd_resv2[1];

	return (rom);
}

d80 1
a80 2
	paddr_t rom;
	u_int32_t id;
d102 11
a112 1
	rom = sti_sgc_getrom(ca);
a116 5
	if (rom == ca->ca_hpa) {
		romh = ioh;
		romunmapped++;
	}

d181 1
a181 1
	paddr_t addr;
d184 4
a187 1
	addr = sti_sgc_getrom(ca);
@


1.5.2.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d58 2
a59 1
#define	STI_ROMSIZE	(sizeof(struct sti_dd) * 4)
a61 5
/* gecko optional graphics */
#define	STI_GOPT1_REV	0x17
#define	STI_GOPT2_REV	0x70

/* internal EG */
a64 2
extern struct cfdriver sti_cd;

d81 1
a81 1
sti_sgc_getrom(int unit, struct confargs *ca)
d83 1
a83 10
	paddr_t rom = PAGE0->pd_resv2[1];

	if (unit) {
		if (ca->ca_type.iodc_sv_model == HPPA_FIO_GSGC &&
		    (ca->ca_type.iodc_revision == STI_GOPT1_REV ||
		     ca->ca_type.iodc_revision == STI_GOPT2_REV))
			/* these two share the onboard's prom */ ;
		else
			rom = 0;
	}
d85 2
a86 4
	if (rom < HPPA_IOBEGIN) {
		if (unit == 0 &&
		    ca->ca_type.iodc_sv_model == HPPA_FIO_GSGC &&
		    ca->ca_type.iodc_revision == STI_INEG_REV)
d90 2
a91 1
	}
a100 1
	struct cfdata *cf = match;
d102 1
a102 1
	bus_space_handle_t romh;
d104 1
a104 1
	u_int32_t id, romend;
d108 1
a108 2
	/* due to the graphic nature of this program do probe only one */
	if (cf->cf_unit > sti_cd.cd_ndevs)
d111 3
a113 2
	if (ca->ca_type.iodc_type != HPPA_TYPE_FIO)
		return (0);
d116 1
a116 2
	if (ca->ca_type.iodc_sv_model != HPPA_FIO_GSGC &&
	    ca->ca_type.iodc_sv_model != HPPA_FIO_SGC)
d119 8
a126 1
	rom = sti_sgc_getrom(cf->cf_unit, ca);
d131 5
d137 2
a138 1
	if ((rv = bus_space_map(ca->ca_iot, rom, STI_ROMSIZE, 0, &romh))) {
d146 2
a147 1
			/* in this case nobody has no freaking idea */
d152 4
a164 1
		romend = bus_space_read_4(ca->ca_iot, romh, 0x18);
d171 1
a171 5
		romend =
		     (bus_space_read_1(ca->ca_iot, romh, 0x50 +  3) << 24) |
		     (bus_space_read_1(ca->ca_iot, romh, 0x50 +  7) << 16) |
		     (bus_space_read_1(ca->ca_iot, romh, 0x50 + 11) <<  8) |
		     (bus_space_read_1(ca->ca_iot, romh, 0x50 + 15));
d180 1
a180 2
	if (rv &&
	    ca->ca_type.iodc_sv_model == HPPA_FIO_SGC && id == STI_ID_FDDI) {
d187 1
a187 9
	if (ca->ca_naddrs >= sizeof(ca->ca_addrs)/sizeof(ca->ca_addrs[0])) {
		printf("sti: address list overflow\n");
		return (0);
	}

	ca->ca_addrs[ca->ca_naddrs].addr = rom;
	ca->ca_addrs[ca->ca_naddrs].size = round_page(romend);
	ca->ca_naddrs++;

d189 1
a189 1
		bus_space_unmap(ca->ca_iot, romh, STI_ROMSIZE);
d200 1
a200 2
	paddr_t rom;
	u_int32_t romlen;
d203 5
a208 1
	sc->base = ca->ca_hpa;
d210 14
a223 6
	/* we stashed rom addr/len into the last slot during probe */
	rom = ca->ca_addrs[ca->ca_naddrs - 1].addr;
	romlen = ca->ca_addrs[ca->ca_naddrs - 1].size;
	if ((rv = bus_space_map(ca->ca_iot, rom, romlen, 0, &sc->romh))) {
		if ((rom & HPPA_IOBEGIN) == HPPA_IOBEGIN)
			sc->romh = rom;
d225 1
d227 3
d234 3
a236 4
	/* PCXL2: enale accel i/o for this space */
	if (cpu_type == hpcxl2)
		eaio_l2(0x8 >> (((ca->ca_hpa >> 25) & 3) - 2));

@


1.5.2.9
log
@Merge with the trunk
@
text
@d15 5
d24 7
a30 8
 * IN NO EVENT SHALL THE AUTHOR OR HIS RELATIVES BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
@


1.4
log
@a note about 705/35 graphics; from he@@obt.runit.no
@
text
@d1 1
a1 1
/*	$OpenBSD: sti_sgc.c,v 1.3 2000/06/15 03:04:17 mickey Exp $	*/
d103 1
d105 1
d123 1
d125 1
d127 1
a127 1
	devtype = bus_space_read_1(ca->ca_iot, ioh, 3);
a173 3
	sc->sc_devtype = bus_space_read_1(sc->iot, sc->ioh, 3);
	printf ("sti: hpa=%x, rom=%x\n", ca->ca_hpa, addr);

d190 3
d194 1
a194 1

@


1.3
log
@be more carefull about pg0, i think switch on sv next time
@
text
@d1 1
a1 1
/*	$OpenBSD: sti_sgc.c,v 1.2 2000/06/13 18:36:37 mickey Exp $	*/
d34 3
a36 2
 *	- HPA1991AC19  rev 0.02 (715/33) (byte-wide)
 *	- HPA208LC1280 rev 8.04 (712/80) just works
@


1.2
log
@ptr alignment is not a hack, it's a feature fix for byte-wide prom
@
text
@d1 1
a1 1
/*	$OpenBSD: sti_sgc.c,v 1.1 2000/05/30 19:42:02 mickey Exp $	*/
d95 1
a95 1
	if (!PAGE0->pd_resv2[1]) {
d154 1
a154 1
	if (!PAGE0->pd_resv2[1])
@


1.1
log
@new driver for sti graphics.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d34 1
a34 1
 *	- HPA1991AC19  rev 0.0  (715/33) w/ weird hack to align sti rom ptrs
@

