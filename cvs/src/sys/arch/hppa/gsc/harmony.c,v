head	1.33;
access;
symbols
	OPENBSD_6_1:1.33.0.2
	OPENBSD_6_1_BASE:1.33
	OPENBSD_6_0:1.31.0.4
	OPENBSD_6_0_BASE:1.31
	OPENBSD_5_9:1.31.0.2
	OPENBSD_5_9_BASE:1.31
	OPENBSD_5_8:1.30.0.4
	OPENBSD_5_8_BASE:1.30
	OPENBSD_5_7:1.29.0.2
	OPENBSD_5_7_BASE:1.29
	OPENBSD_5_6:1.29.0.4
	OPENBSD_5_6_BASE:1.29
	OPENBSD_5_5:1.28.0.6
	OPENBSD_5_5_BASE:1.28
	OPENBSD_5_4:1.28.0.2
	OPENBSD_5_4_BASE:1.28
	OPENBSD_5_3:1.27.0.12
	OPENBSD_5_3_BASE:1.27
	OPENBSD_5_2:1.27.0.10
	OPENBSD_5_2_BASE:1.27
	OPENBSD_5_1_BASE:1.27
	OPENBSD_5_1:1.27.0.8
	OPENBSD_5_0:1.27.0.6
	OPENBSD_5_0_BASE:1.27
	OPENBSD_4_9:1.27.0.4
	OPENBSD_4_9_BASE:1.27
	OPENBSD_4_8:1.27.0.2
	OPENBSD_4_8_BASE:1.27
	OPENBSD_4_7:1.26.0.6
	OPENBSD_4_7_BASE:1.26
	OPENBSD_4_6:1.26.0.8
	OPENBSD_4_6_BASE:1.26
	OPENBSD_4_5:1.26.0.4
	OPENBSD_4_5_BASE:1.26
	OPENBSD_4_4:1.26.0.2
	OPENBSD_4_4_BASE:1.26
	OPENBSD_4_3:1.25.0.8
	OPENBSD_4_3_BASE:1.25
	OPENBSD_4_2:1.25.0.6
	OPENBSD_4_2_BASE:1.25
	OPENBSD_4_1:1.25.0.4
	OPENBSD_4_1_BASE:1.25
	OPENBSD_4_0:1.25.0.2
	OPENBSD_4_0_BASE:1.25
	OPENBSD_3_9:1.24.0.4
	OPENBSD_3_9_BASE:1.24
	OPENBSD_3_8:1.24.0.2
	OPENBSD_3_8_BASE:1.24
	OPENBSD_3_7:1.23.0.6
	OPENBSD_3_7_BASE:1.23
	OPENBSD_3_6:1.23.0.4
	OPENBSD_3_6_BASE:1.23
	SMP_SYNC_A:1.23
	SMP_SYNC_B:1.23
	OPENBSD_3_5:1.23.0.2
	OPENBSD_3_5_BASE:1.23
	OPENBSD_3_4:1.21.0.2
	OPENBSD_3_4_BASE:1.21
	UBC:1.18.0.2
	UBC_SYNC_A:1.18
	SMP:1.17.0.4
	OPENBSD_3_3:1.17.0.2
	OPENBSD_3_3_BASE:1.17;
locks; strict;
comment	@ * @;


1.33
date	2016.09.19.06.46.43;	author ratchov;	state Exp;
branches;
next	1.32;
commitid	qGgYgJTgEFuAoGj4;

1.32
date	2016.09.14.06.12.19;	author ratchov;	state Exp;
branches;
next	1.31;
commitid	pi1a9KN0itEngOc4;

1.31
date	2015.09.08.07.14.04;	author deraadt;	state Exp;
branches;
next	1.30;
commitid	EsikxqfygOQoIEgZ;

1.30
date	2015.05.11.06.46.21;	author ratchov;	state Exp;
branches;
next	1.29;
commitid	RaOGL5SyOGOZylwx;

1.29
date	2014.07.12.18.44.41;	author tedu;	state Exp;
branches;
next	1.28;
commitid	uKVPYMN2MLxdZxzH;

1.28
date	2013.05.15.08.29.23;	author ratchov;	state Exp;
branches;
next	1.27;

1.27
date	2010.07.15.03.43.11;	author jakemsr;	state Exp;
branches;
next	1.26;

1.26
date	2008.04.21.00.32.42;	author jakemsr;	state Exp;
branches;
next	1.25;

1.25
date	2006.05.20.01.58.27;	author mickey;	state Exp;
branches;
next	1.24;

1.24
date	2005.04.16.21.54.32;	author mickey;	state Exp;
branches;
next	1.23;

1.23
date	2004.02.13.21.28.19;	author mickey;	state Exp;
branches;
next	1.22;

1.22
date	2003.12.20.21.49.06;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2003.08.15.13.25.53;	author mickey;	state Exp;
branches;
next	1.20;

1.20
date	2003.08.07.19.47.33;	author mickey;	state Exp;
branches;
next	1.19;

1.19
date	2003.06.02.19.54.29;	author jason;	state Exp;
branches;
next	1.18;

1.18
date	2003.05.11.19.41.09;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2003.03.12.09.06.11;	author mickey;	state Exp;
branches
	1.17.4.1;
next	1.16;

1.16
date	2003.02.05.19.24.13;	author jason;	state Exp;
branches;
next	1.15;

1.15
date	2003.02.05.08.47.05;	author jason;	state Exp;
branches;
next	1.14;

1.14
date	2003.01.30.03.34.26;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	2003.01.30.03.23.19;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	2003.01.30.01.23.24;	author jason;	state Exp;
branches;
next	1.11;

1.11
date	2003.01.29.00.52.23;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	2003.01.28.05.12.47;	author jason;	state Exp;
branches;
next	1.9;

1.9
date	2003.01.28.04.20.49;	author jason;	state Exp;
branches;
next	1.8;

1.8
date	2003.01.27.23.12.41;	author jason;	state Exp;
branches;
next	1.7;

1.7
date	2003.01.27.19.16.41;	author jason;	state Exp;
branches;
next	1.6;

1.6
date	2003.01.27.08.12.32;	author jason;	state Exp;
branches;
next	1.5;

1.5
date	2003.01.27.02.32.36;	author jason;	state Exp;
branches;
next	1.4;

1.4
date	2003.01.27.01.38.21;	author jason;	state Exp;
branches;
next	1.3;

1.3
date	2003.01.26.21.25.39;	author jason;	state Exp;
branches;
next	1.2;

1.2
date	2003.01.26.21.14.57;	author jason;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.26.07.21.40;	author jason;	state Exp;
branches;
next	;

1.17.4.1
date	2003.05.13.19.41.03;	author ho;	state Exp;
branches;
next	1.17.4.2;

1.17.4.2
date	2003.06.07.11.11.36;	author ho;	state Exp;
branches;
next	1.17.4.3;

1.17.4.3
date	2004.02.19.10.48.39;	author niklas;	state Exp;
branches;
next	1.17.4.4;

1.17.4.4
date	2004.06.05.23.10.48;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.33
log
@Remove unused getdev() audio driver functions.
@
text
@/*	$OpenBSD: harmony.c,v 1.32 2016/09/14 06:12:19 ratchov Exp $	*/

/*
 * Copyright (c) 2003 Jason L. Wright (jason@@thought.net)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Harmony (CS4215/AD1849 LASI) audio interface.
 */

#include <sys/param.h>
#include <sys/kernel.h>
#include <sys/systm.h>
#include <sys/errno.h>
#include <sys/ioctl.h>
#include <sys/device.h>
#include <sys/proc.h>
#include <sys/malloc.h>

#include <sys/audioio.h>
#include <dev/audio_if.h>
#include <dev/rndvar.h>

#include <machine/cpu.h>
#include <machine/intr.h>
#include <machine/iomod.h>
#include <machine/autoconf.h>
#include <machine/bus.h>

#include <hppa/dev/cpudevs.h>
#include <hppa/gsc/gscbusvar.h>
#include <hppa/gsc/harmonyreg.h>
#include <hppa/gsc/harmonyvar.h>

int     harmony_open(void *, int);
void    harmony_close(void *);
int     harmony_set_params(void *, int, int, struct audio_params *,
    struct audio_params *);
int     harmony_round_blocksize(void *, int);
int     harmony_commit_settings(void *);
int     harmony_halt_output(void *);
int     harmony_halt_input(void *);
int     harmony_set_port(void *, mixer_ctrl_t *);
int     harmony_get_port(void *, mixer_ctrl_t *);
int     harmony_query_devinfo(void *addr, mixer_devinfo_t *);
void *  harmony_allocm(void *, int, size_t, int, int);
void    harmony_freem(void *, void *, int);
size_t  harmony_round_buffersize(void *, int, size_t);
int     harmony_get_props(void *);
int     harmony_trigger_output(void *, void *, void *, int,
    void (*intr)(void *), void *, struct audio_params *);
int     harmony_trigger_input(void *, void *, void *, int,
    void (*intr)(void *), void *, struct audio_params *);

struct audio_hw_if harmony_sa_hw_if = {
	harmony_open,
	harmony_close,
	harmony_set_params,
	harmony_round_blocksize,
	harmony_commit_settings,
	NULL,
	NULL,
	NULL,
	NULL,
	harmony_halt_output,
	harmony_halt_input,
	NULL,
	NULL,
	harmony_set_port,
	harmony_get_port,
	harmony_query_devinfo,
	harmony_allocm,
	harmony_freem,
	harmony_round_buffersize,
	harmony_get_props,
	harmony_trigger_output,
	harmony_trigger_input
};

int harmony_match(struct device *, void *, void *);
void harmony_attach(struct device *, struct device *, void *);
int harmony_intr(void *);
void harmony_intr_enable(struct harmony_softc *);
void harmony_intr_disable(struct harmony_softc *);
u_int32_t harmony_speed_bits(struct harmony_softc *, u_long *);
int harmony_set_gainctl(struct harmony_softc *);
void harmony_reset_codec(struct harmony_softc *);
void harmony_start_cp(struct harmony_softc *);
void harmony_tick_pb(void *);
void harmony_tick_cp(void *);
void harmony_try_more(struct harmony_softc *);

void harmony_acc_tmo(void *);
#define	ADD_CLKALLICA(sc) do {						\
	(sc)->sc_acc <<= 1;						\
	(sc)->sc_acc |= READ_REG((sc), HARMONY_DIAG) & DIAG_CO;		\
	if ((sc)->sc_acc_cnt++ && !((sc)->sc_acc_cnt % 32))		\
		add_true_randomness((sc)->sc_acc_num ^= (sc)->sc_acc);	\
} while(0)

int
harmony_match(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	struct gsc_attach_args *ga = aux;
	bus_space_handle_t bh;
	u_int32_t cntl;

	if (ga->ga_type.iodc_type == HPPA_TYPE_FIO) {
		if (ga->ga_type.iodc_sv_model == HPPA_FIO_A1 ||
		    ga->ga_type.iodc_sv_model == HPPA_FIO_A2NB ||
		    ga->ga_type.iodc_sv_model == HPPA_FIO_A1NB ||
		    ga->ga_type.iodc_sv_model == HPPA_FIO_A2) {
			if (bus_space_map(ga->ga_iot, ga->ga_hpa,
			    HARMONY_NREGS, 0, &bh) != 0)
				return (0);
			cntl = bus_space_read_4(ga->ga_iot, bh, HARMONY_ID) &
			    ID_REV_MASK;
			bus_space_unmap(ga->ga_iot, bh, HARMONY_NREGS);
			if (cntl == ID_REV_TS || cntl == ID_REV_NOTS)
				return (1);
		}
	}
	return (0);
}

void
harmony_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct harmony_softc *sc = (struct harmony_softc *)self;
	struct gsc_attach_args *ga = aux;
	u_int8_t rev;
	u_int32_t cntl;
	int i;

	sc->sc_bt = ga->ga_iot;
	sc->sc_dmat = ga->ga_dmatag;

	if (bus_space_map(sc->sc_bt, ga->ga_hpa, HARMONY_NREGS, 0,
	    &sc->sc_bh) != 0) {
		printf(": couldn't map registers\n");
		return;
	}

	cntl = READ_REG(sc, HARMONY_ID);
	sc->sc_teleshare = (cntl & ID_REV_MASK) == ID_REV_TS;

	if (bus_dmamem_alloc(sc->sc_dmat, sizeof(struct harmony_empty),
	    PAGE_SIZE, 0, &sc->sc_empty_seg, 1, &sc->sc_empty_rseg,
	    BUS_DMA_NOWAIT) != 0) {
		printf(": couldn't alloc DMA memory\n");
		bus_space_unmap(sc->sc_bt, sc->sc_bh, HARMONY_NREGS);
		return;
	}
	if (bus_dmamem_map(sc->sc_dmat, &sc->sc_empty_seg, 1,
	    sizeof(struct harmony_empty), (caddr_t *)&sc->sc_empty_kva,
	    BUS_DMA_NOWAIT) != 0) {
		printf(": couldn't map DMA memory\n");
		bus_dmamem_free(sc->sc_dmat, &sc->sc_empty_seg,
		    sc->sc_empty_rseg);
		bus_space_unmap(sc->sc_bt, sc->sc_bh, HARMONY_NREGS);
		return;
	}
	if (bus_dmamap_create(sc->sc_dmat, sizeof(struct harmony_empty), 1,
	    sizeof(struct harmony_empty), 0, BUS_DMA_NOWAIT,
	    &sc->sc_empty_map) != 0) {
		printf(": can't create DMA map\n");
		bus_dmamem_unmap(sc->sc_dmat, (caddr_t)sc->sc_empty_kva,
		    sizeof(struct harmony_empty));
		bus_dmamem_free(sc->sc_dmat, &sc->sc_empty_seg,
		    sc->sc_empty_rseg);
		bus_space_unmap(sc->sc_bt, sc->sc_bh, HARMONY_NREGS);
		return;
	}
	if (bus_dmamap_load(sc->sc_dmat, sc->sc_empty_map, sc->sc_empty_kva,
	    sizeof(struct harmony_empty), NULL, BUS_DMA_NOWAIT) != 0) {
		printf(": can't load DMA map\n");
		bus_dmamap_destroy(sc->sc_dmat, sc->sc_empty_map);
		bus_dmamem_unmap(sc->sc_dmat, (caddr_t)sc->sc_empty_kva,
		    sizeof(struct harmony_empty));
		bus_dmamem_free(sc->sc_dmat, &sc->sc_empty_seg,
		    sc->sc_empty_rseg);
		bus_space_unmap(sc->sc_bt, sc->sc_bh, HARMONY_NREGS);
		return;
	}

	sc->sc_playback_empty = 0;
	for (i = 0; i < PLAYBACK_EMPTYS; i++)
		sc->sc_playback_paddrs[i] =
		    sc->sc_empty_map->dm_segs[0].ds_addr +
		    offsetof(struct harmony_empty, playback[i][0]);

	sc->sc_capture_empty = 0;
	for (i = 0; i < CAPTURE_EMPTYS; i++)
		sc->sc_capture_paddrs[i] =
		    sc->sc_empty_map->dm_segs[0].ds_addr +
		    offsetof(struct harmony_empty, playback[i][0]);

	bus_dmamap_sync(sc->sc_dmat, sc->sc_empty_map,
	    offsetof(struct harmony_empty, playback[0][0]),
	    PLAYBACK_EMPTYS * HARMONY_BUFSIZE, BUS_DMASYNC_PREWRITE);

	(void)gsc_intr_establish((struct gsc_softc *)parent, ga->ga_irq,
	    IPL_AUDIO, harmony_intr, sc, sc->sc_dv.dv_xname);

	/* set defaults */
	sc->sc_in_port = HARMONY_IN_LINE;
	sc->sc_out_port = HARMONY_OUT_SPEAKER;
	sc->sc_input_lvl.left = sc->sc_input_lvl.right = 240;
	sc->sc_output_lvl.left = sc->sc_output_lvl.right = 244;
	sc->sc_monitor_lvl.left = sc->sc_monitor_lvl.right = 208;
	sc->sc_outputgain = 0;

	/* reset chip, and push default gain controls */
	harmony_reset_codec(sc);

	cntl = READ_REG(sc, HARMONY_CNTL);
	rev = (cntl & CNTL_CODEC_REV_MASK) >> CNTL_CODEC_REV_SHIFT;
	printf(": rev %u", rev);

	if (sc->sc_teleshare)
		printf(", teleshare");
	printf("\n");

	if ((rev & CS4215_REV_VER) >= CS4215_REV_VER_E)
		sc->sc_hasulinear8 = 1;

	audio_attach_mi(&harmony_sa_hw_if, sc, &sc->sc_dv);

	timeout_set(&sc->sc_acc_tmo, harmony_acc_tmo, sc);
	sc->sc_acc_num = 0xa5a5a5a5;
}

void
harmony_reset_codec(struct harmony_softc *sc)
{
	/* silence */
	WRITE_REG(sc, HARMONY_GAINCTL, GAINCTL_OUTPUT_LEFT_M |
	    GAINCTL_OUTPUT_RIGHT_M | GAINCTL_MONITOR_M);

	/* start reset */
	WRITE_REG(sc, HARMONY_RESET, RESET_RST);

	DELAY(100000);		/* wait at least 0.05 sec */

	harmony_set_gainctl(sc);
	WRITE_REG(sc, HARMONY_RESET, 0);
}

void
harmony_acc_tmo(void *v)
{
	struct harmony_softc *sc = v;

	ADD_CLKALLICA(sc);
	timeout_add(&sc->sc_acc_tmo, 1);
}

/*
 * interrupt handler
 */
int
harmony_intr(vsc)
	void *vsc;
{
	struct harmony_softc *sc = vsc;
	struct harmony_channel *c;
	u_int32_t dstatus;
	int r = 0;

	mtx_enter(&audio_lock);
	ADD_CLKALLICA(sc);

	harmony_intr_disable(sc);

	dstatus = READ_REG(sc, HARMONY_DSTATUS);

	if (dstatus & DSTATUS_PN) {
		struct harmony_dma *d;
		bus_addr_t nextaddr;
		bus_size_t togo;

		r = 1;
		c = &sc->sc_playback;
		d = c->c_current;
		togo = c->c_segsz - c->c_cnt;
		if (togo == 0) {
			nextaddr = d->d_map->dm_segs[0].ds_addr;
			c->c_cnt = togo = c->c_blksz;
		} else {
			nextaddr = c->c_lastaddr;
			if (togo > c->c_blksz)
				togo = c->c_blksz;
			c->c_cnt += togo;
		}

		bus_dmamap_sync(sc->sc_dmat, d->d_map,
		    nextaddr - d->d_map->dm_segs[0].ds_addr,
		    c->c_blksz, BUS_DMASYNC_PREWRITE);

		WRITE_REG(sc, HARMONY_PNXTADD, nextaddr);
		SYNC_REG(sc, HARMONY_PNXTADD, BUS_SPACE_BARRIER_WRITE);
		c->c_lastaddr = nextaddr + togo;
		harmony_try_more(sc);
	}

	dstatus = READ_REG(sc, HARMONY_DSTATUS);

	if (dstatus & DSTATUS_RN) {
		c = &sc->sc_capture;
		r = 1;
		harmony_start_cp(sc);
		if (sc->sc_capturing && c->c_intr != NULL)
			(*c->c_intr)(c->c_intrarg);
	}

	if (READ_REG(sc, HARMONY_OV) & OV_OV) {
		sc->sc_ov = 1;
		WRITE_REG(sc, HARMONY_OV, 0);
	} else
		sc->sc_ov = 0;

	harmony_intr_enable(sc);
	mtx_leave(&audio_lock);
	return (r);
}

void
harmony_intr_enable(struct harmony_softc *sc)
{
	WRITE_REG(sc, HARMONY_DSTATUS, DSTATUS_IE);
	SYNC_REG(sc, HARMONY_DSTATUS, BUS_SPACE_BARRIER_WRITE);
}

void
harmony_intr_disable(struct harmony_softc *sc)
{
	WRITE_REG(sc, HARMONY_DSTATUS, 0);
	SYNC_REG(sc, HARMONY_DSTATUS, BUS_SPACE_BARRIER_WRITE);
}

int
harmony_open(void *vsc, int flags)
{
	struct harmony_softc *sc = vsc;

	if (sc->sc_open)
		return (EBUSY);
	sc->sc_open = 1;
	return (0);
}

void
harmony_close(void *vsc)
{
	struct harmony_softc *sc = vsc;

	/* XXX: not useful, halt_*() already called */
	harmony_halt_input(sc);
	harmony_halt_output(sc);
	harmony_intr_disable(sc);
	sc->sc_open = 0;
}

int
harmony_set_params(void *vsc, int setmode, int usemode,
    struct audio_params *p, struct audio_params *r)
{
	struct harmony_softc *sc = vsc;
	u_int32_t bits;

	switch (p->encoding) {
	case AUDIO_ENCODING_ULAW:
		bits = CNTL_FORMAT_ULAW;
		p->precision = 8;
		break;
	case AUDIO_ENCODING_ALAW:
		bits = CNTL_FORMAT_ALAW;
		p->precision = 8;
		break;
	case AUDIO_ENCODING_SLINEAR_BE:
		if (p->precision == 16) {
			bits = CNTL_FORMAT_SLINEAR16BE;
			break;
		}
		return (EINVAL);
	case AUDIO_ENCODING_ULINEAR_LE:
	case AUDIO_ENCODING_ULINEAR_BE:
		if (p->precision == 8) {
			bits = CNTL_FORMAT_ULINEAR8;
			break;
		}
		return (EINVAL);
	default:
		return (EINVAL);
	}

	if (sc->sc_outputgain)
		bits |= CNTL_OLB;

	if (p->channels == 1)
		bits |= CNTL_CHANS_MONO;
	else if (p->channels == 2)
		bits |= CNTL_CHANS_STEREO;
	else
		return (EINVAL);

	r->sample_rate = p->sample_rate;
	r->encoding = p->encoding;
	r->precision = p->precision;
	p->bps = AUDIO_BPS(p->precision);
	r->bps = AUDIO_BPS(r->precision);
	p->msb = r->msb = 1;

	bits |= harmony_speed_bits(sc, &p->sample_rate);
	sc->sc_cntlbits = bits;
	sc->sc_need_commit = 1;

	return (0);
}

int
harmony_round_blocksize(void *vsc, int blk)
{
	return (HARMONY_BUFSIZE);
}

int
harmony_commit_settings(void *vsc)
{
	struct harmony_softc *sc = vsc;
	u_int32_t reg;
	u_int8_t quietchar;
	int i;

	if (sc->sc_need_commit == 0)
		return (0);

	harmony_intr_disable(sc);

	for (;;) {
		reg = READ_REG(sc, HARMONY_DSTATUS);
		if ((reg & (DSTATUS_PC | DSTATUS_RC)) == 0)
			break;
	}

	/* Setting some bits in gainctl requires a reset */
	harmony_reset_codec(sc);

	/* set the silence character based on the encoding type */
	bus_dmamap_sync(sc->sc_dmat, sc->sc_empty_map,
	    offsetof(struct harmony_empty, playback[0][0]),
	    PLAYBACK_EMPTYS * HARMONY_BUFSIZE, BUS_DMASYNC_POSTWRITE);
	switch (sc->sc_cntlbits & CNTL_FORMAT_MASK) {
	case CNTL_FORMAT_ULAW:
		quietchar = 0x7f;
		break;
	case CNTL_FORMAT_ALAW:
		quietchar = 0x55;
		break;
	case CNTL_FORMAT_SLINEAR16BE:
	case CNTL_FORMAT_ULINEAR8:
	default:
		quietchar = 0;
		break;
	}
	for (i = 0; i < PLAYBACK_EMPTYS; i++)
		memset(&sc->sc_empty_kva->playback[i][0],
		    quietchar, HARMONY_BUFSIZE);
	bus_dmamap_sync(sc->sc_dmat, sc->sc_empty_map,
	    offsetof(struct harmony_empty, playback[0][0]),
	    PLAYBACK_EMPTYS * HARMONY_BUFSIZE, BUS_DMASYNC_PREWRITE);

	for (;;) {
		/* Wait for it to come out of control mode */
		reg = READ_REG(sc, HARMONY_CNTL);
		if ((reg & CNTL_C) == 0)
			break;
	}

	bus_space_write_4(sc->sc_bt, sc->sc_bh, HARMONY_CNTL,
	    sc->sc_cntlbits | CNTL_C);

	for (;;) {
		/* Wait for it to come out of control mode */
		reg = READ_REG(sc, HARMONY_CNTL);
		if ((reg & CNTL_C) == 0)
			break;
	}

	sc->sc_need_commit = 0;

	if (sc->sc_playing || sc->sc_capturing)
		harmony_intr_enable(sc);

	return (0);
}

int
harmony_halt_output(void *vsc)
{
	struct harmony_softc *sc = vsc;

	/* XXX: disable interrupts */
	sc->sc_playing = 0;
	return (0);
}

int
harmony_halt_input(void *vsc)
{
	struct harmony_softc *sc = vsc;

	/* XXX: disable interrupts */
	sc->sc_capturing = 0;
	return (0);
}

int
harmony_set_port(void *vsc, mixer_ctrl_t *cp)
{
	struct harmony_softc *sc = vsc;
	int err = EINVAL;

	switch (cp->dev) {
	case HARMONY_PORT_INPUT_LVL:
		if (cp->type != AUDIO_MIXER_VALUE)
			break;
		if (cp->un.value.num_channels == 1)
			sc->sc_input_lvl.left = sc->sc_input_lvl.right =
			    cp->un.value.level[AUDIO_MIXER_LEVEL_MONO];
		else if (cp->un.value.num_channels == 2) {
			sc->sc_input_lvl.left =
			    cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT];
			sc->sc_input_lvl.right =
			    cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT];
		} else
			break;
		sc->sc_need_commit = 1;
		err = 0;
		break;
	case HARMONY_PORT_OUTPUT_LVL:
		if (cp->type != AUDIO_MIXER_VALUE)
			break;
		if (cp->un.value.num_channels == 1)
			sc->sc_output_lvl.left = sc->sc_output_lvl.right =
			    cp->un.value.level[AUDIO_MIXER_LEVEL_MONO];
		else if (cp->un.value.num_channels == 2) {
			sc->sc_output_lvl.left =
			    cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT];
			sc->sc_output_lvl.right =
			    cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT];
		} else
			break;
		sc->sc_need_commit = 1;
		err = 0;
		break;
	case HARMONY_PORT_OUTPUT_GAIN:
		if (cp->type != AUDIO_MIXER_ENUM)
			break;
		sc->sc_outputgain = cp->un.ord ? 1 : 0;
		err = 0;
		break;
	case HARMONY_PORT_MONITOR_LVL:
		if (cp->type != AUDIO_MIXER_VALUE)
			break;
		if (cp->un.value.num_channels != 1)
			break;
		sc->sc_monitor_lvl.left = sc->sc_input_lvl.right =
		    cp->un.value.level[AUDIO_MIXER_LEVEL_MONO];
		sc->sc_need_commit = 1;
		err = 0;
		break;
	case HARMONY_PORT_RECORD_SOURCE:
		if (cp->type != AUDIO_MIXER_ENUM)
			break;
		if (cp->un.ord != HARMONY_IN_LINE &&
		    cp->un.ord != HARMONY_IN_MIC)
			break;
		sc->sc_in_port = cp->un.ord;
		err = 0;
		sc->sc_need_commit = 1;
		break;
	case HARMONY_PORT_OUTPUT_SOURCE:
		if (cp->type != AUDIO_MIXER_ENUM)
			break;
		if (cp->un.ord != HARMONY_OUT_LINE &&
		    cp->un.ord != HARMONY_OUT_SPEAKER &&
		    cp->un.ord != HARMONY_OUT_HEADPHONE)
			break;
		sc->sc_out_port = cp->un.ord;
		err = 0;
		sc->sc_need_commit = 1;
		break;
	}

	return (err);
}

int
harmony_get_port(void *vsc, mixer_ctrl_t *cp)
{
	struct harmony_softc *sc = vsc;
	int err = EINVAL;

	switch (cp->dev) {
	case HARMONY_PORT_INPUT_LVL:
		if (cp->type != AUDIO_MIXER_VALUE)
			break;
		if (cp->un.value.num_channels == 1) {
			cp->un.value.level[AUDIO_MIXER_LEVEL_MONO] =
			    sc->sc_input_lvl.left;
		} else if (cp->un.value.num_channels == 2) {
			cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT] =
			    sc->sc_input_lvl.left;
			cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT] =
			    sc->sc_input_lvl.right;
		} else
			break;
		err = 0;
		break;
	case HARMONY_PORT_INPUT_OV:
		if (cp->type != AUDIO_MIXER_ENUM)
			break;
		cp->un.ord = sc->sc_ov ? 1 : 0;
		err = 0;
		break;
	case HARMONY_PORT_OUTPUT_LVL:
		if (cp->type != AUDIO_MIXER_VALUE)
			break;
		if (cp->un.value.num_channels == 1) {
			cp->un.value.level[AUDIO_MIXER_LEVEL_MONO] =
			    sc->sc_output_lvl.left;
		} else if (cp->un.value.num_channels == 2) {
			cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT] =
			    sc->sc_output_lvl.left;
			cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT] =
			    sc->sc_output_lvl.right;
		} else
			break;
		err = 0;
		break;
	case HARMONY_PORT_OUTPUT_GAIN:
		if (cp->type != AUDIO_MIXER_ENUM)
			break;
		cp->un.ord = sc->sc_outputgain ? 1 : 0;
		err = 0;
		break;
	case HARMONY_PORT_MONITOR_LVL:
		if (cp->type != AUDIO_MIXER_VALUE)
			break;
		if (cp->un.value.num_channels != 1)
			break;
		cp->un.value.level[AUDIO_MIXER_LEVEL_MONO] =
		    sc->sc_monitor_lvl.left;
		err = 0;
		break;
	case HARMONY_PORT_RECORD_SOURCE:
		if (cp->type != AUDIO_MIXER_ENUM)
			break;
		cp->un.ord = sc->sc_in_port;
		err = 0;
		break;
	case HARMONY_PORT_OUTPUT_SOURCE:
		if (cp->type != AUDIO_MIXER_ENUM)
			break;
		cp->un.ord = sc->sc_out_port;
		err = 0;
		break;
	}
	return (0);
}

int
harmony_query_devinfo(void *vsc, mixer_devinfo_t *dip)
{
	int err = 0;

	switch (dip->index) {
	case HARMONY_PORT_INPUT_LVL:
		dip->type = AUDIO_MIXER_VALUE;
		dip->mixer_class = HARMONY_PORT_INPUT_CLASS;
		dip->prev = dip->next = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioNinput, sizeof dip->label.name);
		dip->un.v.num_channels = 2;
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
		break;
	case HARMONY_PORT_INPUT_OV:
		dip->type = AUDIO_MIXER_ENUM;
		dip->mixer_class = HARMONY_PORT_INPUT_CLASS;
		dip->prev = dip->next = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, "overrange", sizeof dip->label.name);
		dip->un.e.num_mem = 2;
		strlcpy(dip->un.e.member[0].label.name, AudioNoff,
		    sizeof dip->un.e.member[0].label.name);
		dip->un.e.member[0].ord = 0;
		strlcpy(dip->un.e.member[1].label.name, AudioNon,
		    sizeof dip->un.e.member[1].label.name);
		dip->un.e.member[1].ord = 1;
		break;
	case HARMONY_PORT_OUTPUT_LVL:
		dip->type = AUDIO_MIXER_VALUE;
		dip->mixer_class = HARMONY_PORT_OUTPUT_CLASS;
		dip->prev = dip->next = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioNoutput, sizeof dip->label.name);
		dip->un.v.num_channels = 2;
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
		break;
	case HARMONY_PORT_OUTPUT_GAIN:
		dip->type = AUDIO_MIXER_ENUM;
		dip->mixer_class = HARMONY_PORT_OUTPUT_CLASS;
		dip->prev = dip->next = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, "gain", sizeof dip->label.name);
		dip->un.e.num_mem = 2;
		strlcpy(dip->un.e.member[0].label.name, AudioNoff,
		    sizeof dip->un.e.member[0].label.name);
		dip->un.e.member[0].ord = 0;
		strlcpy(dip->un.e.member[1].label.name, AudioNon,
		    sizeof dip->un.e.member[1].label.name);
		dip->un.e.member[1].ord = 1;
		break;
	case HARMONY_PORT_MONITOR_LVL:
		dip->type = AUDIO_MIXER_VALUE;
		dip->mixer_class = HARMONY_PORT_MONITOR_CLASS;
		dip->prev = dip->next = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioNmonitor, sizeof dip->label.name);
		dip->un.v.num_channels = 1;
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
		break;
	case HARMONY_PORT_RECORD_SOURCE:
		dip->type = AUDIO_MIXER_ENUM;
		dip->mixer_class = HARMONY_PORT_RECORD_CLASS;
		dip->prev = dip->next = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioNsource, sizeof dip->label.name);
		dip->un.e.num_mem = 2;
		strlcpy(dip->un.e.member[0].label.name, AudioNmicrophone,
		    sizeof dip->un.e.member[0].label.name);
		dip->un.e.member[0].ord = HARMONY_IN_MIC;
		strlcpy(dip->un.e.member[1].label.name, AudioNline,
		    sizeof dip->un.e.member[1].label.name);
		dip->un.e.member[1].ord = HARMONY_IN_LINE;
		break;
	case HARMONY_PORT_OUTPUT_SOURCE:
		dip->type = AUDIO_MIXER_ENUM;
		dip->mixer_class = HARMONY_PORT_MONITOR_CLASS;
		dip->prev = dip->next = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioNoutput, sizeof dip->label.name);
		dip->un.e.num_mem = 3;
		strlcpy(dip->un.e.member[0].label.name, AudioNline,
		    sizeof dip->un.e.member[0].label.name);
		dip->un.e.member[0].ord = HARMONY_OUT_LINE;
		strlcpy(dip->un.e.member[1].label.name, AudioNspeaker,
		    sizeof dip->un.e.member[1].label.name);
		dip->un.e.member[1].ord = HARMONY_OUT_SPEAKER;
		strlcpy(dip->un.e.member[2].label.name, AudioNheadphone,
		    sizeof dip->un.e.member[2].label.name);
		dip->un.e.member[2].ord = HARMONY_OUT_HEADPHONE;
		break;
	case HARMONY_PORT_INPUT_CLASS:
		dip->type = AUDIO_MIXER_CLASS;
		dip->mixer_class = HARMONY_PORT_INPUT_CLASS;
		dip->prev = dip->next = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioCinputs, sizeof dip->label.name);
		break;
	case HARMONY_PORT_OUTPUT_CLASS:
		dip->type = AUDIO_MIXER_CLASS;
		dip->mixer_class = HARMONY_PORT_INPUT_CLASS;
		dip->prev = dip->next = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioCoutputs, sizeof dip->label.name);
		break;
	case HARMONY_PORT_MONITOR_CLASS:
		dip->type = AUDIO_MIXER_CLASS;
		dip->mixer_class = HARMONY_PORT_INPUT_CLASS;
		dip->prev = dip->next = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioCmonitor, sizeof dip->label.name);
		break;
	case HARMONY_PORT_RECORD_CLASS:
		dip->type = AUDIO_MIXER_CLASS;
		dip->mixer_class = HARMONY_PORT_RECORD_CLASS;
		dip->prev = dip->next = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioCrecord, sizeof dip->label.name);
		break;
	default:
		err = ENXIO;
		break;
	}

	return (err);
}

void *
harmony_allocm(void *vsc, int dir, size_t size, int pool, int flags)
{
	struct harmony_softc *sc = vsc;
	struct harmony_dma *d;
	int rseg;

	d = (struct harmony_dma *)malloc(sizeof(struct harmony_dma), pool, flags);
	if (d == NULL)
		goto fail;

	if (bus_dmamap_create(sc->sc_dmat, size, 1, size, 0, BUS_DMA_NOWAIT,
	    &d->d_map) != 0)
		goto fail1;

	if (bus_dmamem_alloc(sc->sc_dmat, size, PAGE_SIZE, 0, &d->d_seg, 1,
	    &rseg, BUS_DMA_NOWAIT) != 0)
		goto fail2;

	if (bus_dmamem_map(sc->sc_dmat, &d->d_seg, 1, size, &d->d_kva,
	    BUS_DMA_NOWAIT) != 0)
		goto fail3;

	if (bus_dmamap_load(sc->sc_dmat, d->d_map, d->d_kva, size, NULL,
	    BUS_DMA_NOWAIT) != 0)
		goto fail4;

	d->d_next = sc->sc_dmas;
	sc->sc_dmas = d;
	d->d_size = size;
	return (d->d_kva);

fail4:
	bus_dmamem_unmap(sc->sc_dmat, d->d_kva, size);
fail3:
	bus_dmamem_free(sc->sc_dmat, &d->d_seg, 1);
fail2:
	bus_dmamap_destroy(sc->sc_dmat, d->d_map);
fail1:
	free(d, pool, sizeof *d);
fail:
	return (NULL);
}

void
harmony_freem(void *vsc, void *ptr, int pool)
{
	struct harmony_softc *sc = vsc;
	struct harmony_dma *d, **dd;

	for (dd = &sc->sc_dmas; (d = *dd) != NULL; dd = &(*dd)->d_next) {
		if (d->d_kva != ptr)
			continue;
		bus_dmamap_unload(sc->sc_dmat, d->d_map);
		bus_dmamem_unmap(sc->sc_dmat, d->d_kva, d->d_size);
		bus_dmamem_free(sc->sc_dmat, &d->d_seg, 1);
		bus_dmamap_destroy(sc->sc_dmat, d->d_map);
		free(d, pool, sizeof *d);
		return;
	}
	printf("%s: free rogue pointer\n", sc->sc_dv.dv_xname);
}

size_t
harmony_round_buffersize(void *vsc, int direction, size_t size)
{
	return ((size + HARMONY_BUFSIZE - 1) & (size_t)(-HARMONY_BUFSIZE));
}

int
harmony_get_props(void *vsc)
{
	return (AUDIO_PROP_FULLDUPLEX);
}

int
harmony_trigger_output(void *vsc, void *start, void *end, int blksize,
    void (*intr)(void *), void *intrarg, struct audio_params *param)
{
	struct harmony_softc *sc = vsc;
	struct harmony_channel *c = &sc->sc_playback;
	struct harmony_dma *d;
	bus_addr_t nextaddr;
	bus_size_t togo;

	for (d = sc->sc_dmas; d->d_kva != start; d = d->d_next)
		/*EMPTY*/;
	if (d == NULL) {
		printf("%s: trigger_output: bad addr: %p\n",
		    sc->sc_dv.dv_xname, start);
		return (EINVAL);
	}

	c->c_intr = intr;
	c->c_intrarg = intrarg;
	c->c_blksz = blksize;
	c->c_current = d;
	c->c_segsz = (caddr_t)end - (caddr_t)start;
	c->c_cnt = 0;
	c->c_lastaddr = d->d_map->dm_segs[0].ds_addr;

	sc->sc_playing = 1;

	togo = c->c_segsz - c->c_cnt;
	if (togo == 0) {
		nextaddr = d->d_map->dm_segs[0].ds_addr;
		c->c_cnt = togo = c->c_blksz;
	} else {
		nextaddr = c->c_lastaddr;
		if (togo > c->c_blksz)
			togo = c->c_blksz;
		c->c_cnt += togo;
	}

	bus_dmamap_sync(sc->sc_dmat, d->d_map,
	    nextaddr - d->d_map->dm_segs[0].ds_addr,
	    c->c_blksz, BUS_DMASYNC_PREWRITE);

	mtx_enter(&audio_lock);
	WRITE_REG(sc, HARMONY_PNXTADD, nextaddr);
	c->c_theaddr = nextaddr;
	SYNC_REG(sc, HARMONY_PNXTADD, BUS_SPACE_BARRIER_WRITE);
	c->c_lastaddr = nextaddr + togo;

	harmony_start_cp(sc);
	harmony_intr_enable(sc);
	mtx_leave(&audio_lock);
	return (0);
}

void
harmony_start_cp(struct harmony_softc *sc)
{
	struct harmony_channel *c = &sc->sc_capture;
	struct harmony_dma *d;
	bus_addr_t nextaddr;
	bus_size_t togo;

	if (sc->sc_capturing == 0) {
		WRITE_REG(sc, HARMONY_RNXTADD,
		    sc->sc_capture_paddrs[sc->sc_capture_empty]);
		if (++sc->sc_capture_empty == CAPTURE_EMPTYS)
			sc->sc_capture_empty = 0;
	} else {
		d = c->c_current;
		togo = c->c_segsz - c->c_cnt;
		if (togo == 0) {
			nextaddr = d->d_map->dm_segs[0].ds_addr;
			c->c_cnt = togo = c->c_blksz;
		} else {
			nextaddr = c->c_lastaddr;
			if (togo > c->c_blksz)
				togo = c->c_blksz;
			c->c_cnt += togo;
		}

		bus_dmamap_sync(sc->sc_dmat, d->d_map,
		    nextaddr - d->d_map->dm_segs[0].ds_addr,
		    c->c_blksz, BUS_DMASYNC_PREWRITE);

		WRITE_REG(sc, HARMONY_RNXTADD, nextaddr);
		SYNC_REG(sc, HARMONY_RNXTADD, BUS_SPACE_BARRIER_WRITE);
		c->c_lastaddr = nextaddr + togo;
	}

	timeout_add(&sc->sc_acc_tmo, 1);
}

int
harmony_trigger_input(void *vsc, void *start, void *end, int blksize,
    void (*intr)(void *), void *intrarg, struct audio_params *param)
{
	struct harmony_softc *sc = vsc;
	struct harmony_channel *c = &sc->sc_capture;
	struct harmony_dma *d;

	for (d = sc->sc_dmas; d->d_kva != start; d = d->d_next)
		/*EMPTY*/;
	if (d == NULL) {
		printf("%s: trigger_input: bad addr: %p\n",
		    sc->sc_dv.dv_xname, start);
		return (EINVAL);
	}

	c->c_intr = intr;
	c->c_intrarg = intrarg;
	c->c_blksz = blksize;
	c->c_current = d;
	c->c_segsz = (caddr_t)end - (caddr_t)start;
	c->c_cnt = 0;
	c->c_lastaddr = d->d_map->dm_segs[0].ds_addr;
	mtx_enter(&audio_lock);
	sc->sc_capturing = 1;
	harmony_start_cp(sc);
	harmony_intr_enable(sc);
	mtx_leave(&audio_lock);
	return (0);
}

static const struct speed_struct {
	u_int32_t speed;
	u_int32_t bits;
} harmony_speeds[] = {
	{ 5125, CNTL_RATE_5125 },
	{ 6615, CNTL_RATE_6615 },
	{ 8000, CNTL_RATE_8000 },
	{ 9600, CNTL_RATE_9600 },
	{ 11025, CNTL_RATE_11025 },
	{ 16000, CNTL_RATE_16000 },
	{ 18900, CNTL_RATE_18900 },
	{ 22050, CNTL_RATE_22050 },
	{ 27428, CNTL_RATE_27428 },
	{ 32000, CNTL_RATE_32000 },
	{ 33075, CNTL_RATE_33075 },
	{ 37800, CNTL_RATE_37800 },
	{ 44100, CNTL_RATE_44100 },
	{ 48000, CNTL_RATE_48000 },
};

u_int32_t
harmony_speed_bits(struct harmony_softc *sc, u_long *speedp)
{
	int i, n, selected = -1;

	n = sizeof(harmony_speeds) / sizeof(harmony_speeds[0]);

	if ((*speedp) <= harmony_speeds[0].speed)
		selected = 0;
	else if ((*speedp) >= harmony_speeds[n - 1].speed)
		selected = n - 1;
	else {
		for (i = 1; selected == -1 && i < n; i++) {
			if ((*speedp) == harmony_speeds[i].speed)
				selected = i;
			else if ((*speedp) < harmony_speeds[i].speed) {
				int diff1, diff2;

				diff1 = (*speedp) - harmony_speeds[i - 1].speed;
				diff2 = harmony_speeds[i].speed - (*speedp);
				if (diff1 < diff2)
					selected = i - 1;
				else
					selected = i;
			}
		}
	}

	if (selected == -1)
		selected = 2;

	*speedp = harmony_speeds[selected].speed;
	return (harmony_speeds[selected].bits);
}

int
harmony_set_gainctl(struct harmony_softc *sc)
{
	u_int32_t bits, mask, val, old;

	/* XXX leave these bits alone or the chip will not come out of CNTL */
	bits = GAINCTL_LE | GAINCTL_HE | GAINCTL_SE | GAINCTL_IS_MASK;

	/* input level */
	bits |= ((sc->sc_input_lvl.left >> (8 - GAINCTL_INPUT_BITS)) <<
	    GAINCTL_INPUT_LEFT_S) & GAINCTL_INPUT_LEFT_M;
	bits |= ((sc->sc_input_lvl.right >> (8 - GAINCTL_INPUT_BITS)) <<
	    GAINCTL_INPUT_RIGHT_S) & GAINCTL_INPUT_RIGHT_M;

	/* output level (inverted) */
	mask = (1 << GAINCTL_OUTPUT_BITS) - 1;
	val = mask - (sc->sc_output_lvl.left >> (8 - GAINCTL_OUTPUT_BITS));
	bits |= (val << GAINCTL_OUTPUT_LEFT_S) & GAINCTL_OUTPUT_LEFT_M;
	val = mask - (sc->sc_output_lvl.right >> (8 - GAINCTL_OUTPUT_BITS));
	bits |= (val << GAINCTL_OUTPUT_RIGHT_S) & GAINCTL_OUTPUT_RIGHT_M;

	/* monitor level (inverted) */
	mask = (1 << GAINCTL_MONITOR_BITS) - 1;
	val = mask - (sc->sc_monitor_lvl.left >> (8 - GAINCTL_MONITOR_BITS));
	bits |= (val << GAINCTL_MONITOR_S) & GAINCTL_MONITOR_M;

	/* XXX messing with these causes CNTL_C to get stuck... grr. */
	bits &= ~GAINCTL_IS_MASK;
	if (sc->sc_in_port == HARMONY_IN_MIC)
		bits |= GAINCTL_IS_LINE;
	else
		bits |= GAINCTL_IS_MICROPHONE;

	/* XXX messing with these causes CNTL_C to get stuck... grr. */
	bits &= ~(GAINCTL_LE | GAINCTL_HE | GAINCTL_SE);
	if (sc->sc_out_port == HARMONY_OUT_LINE)
		bits |= GAINCTL_LE;
	else if (sc->sc_out_port == HARMONY_OUT_SPEAKER)
		bits |= GAINCTL_SE;
	else
		bits |= GAINCTL_HE;

	mask = GAINCTL_LE | GAINCTL_HE | GAINCTL_SE | GAINCTL_IS_MASK;
	old = bus_space_read_4(sc->sc_bt, sc->sc_bh, HARMONY_GAINCTL);
	bus_space_write_4(sc->sc_bt, sc->sc_bh, HARMONY_GAINCTL, bits);
	if ((old & mask) != (bits & mask))
		return (1);
	return (0);
}

void
harmony_try_more(struct harmony_softc *sc)
{
	struct harmony_channel *c = &sc->sc_playback;
	struct harmony_dma *d = c->c_current;
	u_int32_t cur;
	int i, nsegs;

	cur = bus_space_read_4(sc->sc_bt, sc->sc_bh, HARMONY_PCURADD);
	cur &= PCURADD_BUFMASK;
	nsegs = 0;

#ifdef DIAGNOSTIC
	if (cur < d->d_map->dm_segs[0].ds_addr ||
	    cur >= (d->d_map->dm_segs[0].ds_addr + c->c_segsz))
		panic("%s: bad current %x < %lx || %x > %lx",
		    sc->sc_dv.dv_xname, cur, d->d_map->dm_segs[0].ds_addr, cur,
		    d->d_map->dm_segs[0].ds_addr + c->c_segsz);
#endif /* DIAGNOSTIC */

	if (cur > c->c_theaddr) {
		nsegs = (cur - c->c_theaddr) / HARMONY_BUFSIZE;
	} else if (cur < c->c_theaddr) {
		nsegs = (d->d_map->dm_segs[0].ds_addr + c->c_segsz -
		    c->c_theaddr) / HARMONY_BUFSIZE;
		nsegs += (cur - d->d_map->dm_segs[0].ds_addr) /
		    HARMONY_BUFSIZE;
	}

	if (nsegs != 0 && c->c_intr != NULL) {
		for (i = 0; i < nsegs; i++)
			(*c->c_intr)(c->c_intrarg);
		c->c_theaddr = cur;
	}
}

struct cfdriver harmony_cd = {
	NULL, "harmony", DV_DULL
};

struct cfattach harmony_ca = {
	sizeof(struct harmony_softc), harmony_match, harmony_attach
};
@


1.32
log
@Remove drain(), query_encoding(), mappage() and get_default_params()
methods from all audio drivers and from the audio_if structure as they
are never called.
@
text
@d1 1
a1 1
/*	$OpenBSD: harmony.c,v 1.30 2015/05/11 06:46:21 ratchov Exp $	*/
a64 1
int     harmony_getdev(void *, struct audio_device *);
a89 1
	harmony_getdev,
a252 7
	strlcpy(sc->sc_audev.name, ga->ga_name, sizeof(sc->sc_audev.name));
	snprintf(sc->sc_audev.version, sizeof sc->sc_audev.version,
	    "%u.%u;%u", ga->ga_type.iodc_sv_rev,
	    ga->ga_type.iodc_model, ga->ga_type.iodc_revision);
	strlcpy(sc->sc_audev.config, sc->sc_dv.dv_xname,
	    sizeof(sc->sc_audev.config));

a540 10
	return (0);
}

int
harmony_getdev(void *vsc, struct audio_device *retp)
{
	struct harmony_softc *sc = vsc;

	*retp = sc->sc_audev;

@


1.31
log
@sizes for free(), when known; ok semarie
@
text
@a58 1
int     harmony_query_encoding(void *, struct audio_encoding *);
a80 2
	NULL,
	harmony_query_encoding,
a98 1
	NULL,
d101 1
a101 2
	harmony_trigger_input,
	NULL
a396 42
}

int
harmony_query_encoding(void *vsc, struct audio_encoding *fp)
{
	struct harmony_softc *sc = vsc;
	int err = 0;

	switch (fp->index) {
	case 0:
		strlcpy(fp->name, AudioEmulaw, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ULAW;
		fp->precision = 8;
		fp->flags = 0;
		break;
	case 1:
		strlcpy(fp->name, AudioEalaw, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ALAW;
		fp->precision = 8;
		fp->flags = 0;
		break;
	case 2:
		strlcpy(fp->name, AudioEslinear_be, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_SLINEAR_BE;
		fp->precision = 16;
		fp->flags = 0;
		break;
	case 3:
		if (sc->sc_hasulinear8) {
			strlcpy(fp->name, AudioEulinear, sizeof fp->name);
			fp->encoding = AUDIO_ENCODING_ULINEAR;
			fp->precision = 8;
			fp->flags = 0;
			break;
		}
		/*FALLTHROUGH*/
	default:
		err = EINVAL;
	}
	fp->bps = AUDIO_BPS(fp->precision);
	fp->msb = 1;
	return (err);
@


1.30
log
@Remove all audio format conversion code from the kernel (btw holding
the kernel_lock), as we already do better conversions in
user-mode. Yet, no need for every single driver to fiddle with the
conversion code as they are done transparently by common MI code. With
help from armani and miod, support from mpi

ok armani@@
@
text
@d1 1
a1 1
/*	$OpenBSD: harmony.c,v 1.29 2014/07/12 18:44:41 tedu Exp $	*/
d924 1
a924 1
	free(d, pool, 0);
d942 1
a942 1
		free(d, pool, 0);
@


1.29
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: harmony.c,v 1.28 2013/05/15 08:29:23 ratchov Exp $	*/
a43 1
#include <dev/auconv.h>
a429 18
		strlcpy(fp->name, AudioEslinear_le, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_SLINEAR_LE;
		fp->precision = 16;
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 4:
		strlcpy(fp->name, AudioEulinear_be, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ULINEAR_BE;
		fp->precision = 16;
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 5:
		strlcpy(fp->name, AudioEulinear_le, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ULINEAR_LE;
		fp->precision = 16;
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 6:
a437 9
	case 7:
		if (sc->sc_hasulinear8) {
			strlcpy(fp->name, AudioEslinear, sizeof fp->name);
			fp->encoding = AUDIO_ENCODING_SLINEAR;
			fp->precision = 8;
			fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
			break;
		}
		/*FALLTHROUGH*/
a451 2
	void (*pswcode)(void *, u_char *, int cnt) = NULL;
	void (*rswcode)(void *, u_char *, int cnt) = NULL;
a454 2
		if (p->precision != 8)
			return (EINVAL);
d456 1
a458 2
		if (p->precision != 8)
			return (EINVAL);
d460 1
a462 5
		if (p->precision == 8) {
			bits = CNTL_FORMAT_ULINEAR8;
			rswcode = pswcode = change_sign8;
			break;
		}
d468 1
a468 23
	case AUDIO_ENCODING_ULINEAR:
		if (p->precision != 8)
			return (EINVAL);
		bits = CNTL_FORMAT_ULINEAR8;
		break;
	case AUDIO_ENCODING_SLINEAR:
		if (p->precision != 8)
			return (EINVAL);
		bits = CNTL_FORMAT_ULINEAR8;
		rswcode = pswcode = change_sign8;
		break;
	case AUDIO_ENCODING_SLINEAR_LE:
		if (p->precision == 8) {
			bits = CNTL_FORMAT_ULINEAR8;
			rswcode = pswcode = change_sign8;
			break;
		}
		if (p->precision == 16) {
			bits = CNTL_FORMAT_SLINEAR16BE;
			rswcode = pswcode = swap_bytes;
			break;
		}
		return (EINVAL);
a473 17
		if (p->precision == 16) {
			bits = CNTL_FORMAT_SLINEAR16BE;
			rswcode = pswcode = change_sign16_be;
			break;
		}
		return (EINVAL);
	case AUDIO_ENCODING_ULINEAR_LE:
		if (p->precision == 8) {
			bits = CNTL_FORMAT_ULINEAR8;
			break;
		}
		if (p->precision == 16) {
			bits = CNTL_FORMAT_SLINEAR16BE;
			pswcode = change_sign16_swap_bytes_le;
			rswcode = swap_bytes_change_sign16_le;
			break;
		}
d489 3
a491 2
	p->sw_code = pswcode;
	r->sw_code = rswcode;
@


1.28
log
@Introduce a global interrupt-aware mutex protecting data
structures (including sound-card registers) from concurent
access by syscall and interrupt code-paths. Since critical
sections remain the same, calls to splraise/spllower can be
safely replaced by calls to mtx_enter/mtx_leave with two
exceptions: (1) mutexes are not reentrant (the inner splraise
is thus removed), and (2) we're not allowed to sleep with a
mutex (either msleep is used or the mutex is released before
sleeping).

ok and help from kettenis, a lot of work from armani
@
text
@d1 1
a1 1
/*	$OpenBSD: harmony.c,v 1.27 2010/07/15 03:43:11 jakemsr Exp $	*/
d999 1
a999 1
	free(d, pool);
d1017 1
a1017 1
		free(d, pool);
@


1.27
log
@add two new members to structs audio_encoding and audio_prinfo.
for both structs, the new members are 'bps' and 'msb', which
describe the number of bytes per sample and data alignment in the
sample, respectively.  drivers must properly set these fields in
the 'query_encoding', 'set_parameters' and 'get_default_params'
hardware interface methods.

discussed with ratchov, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: harmony.c,v 1.26 2008/04/21 00:32:42 jakemsr Exp $	*/
d311 1
d364 1
a364 1

d398 1
d660 1
d670 1
d1078 1
d1086 1
a1086 1

d1151 1
a1151 1

d1155 1
@


1.26
log
@
allow low level audio drivers to specify a default sample format,
instead of 8-bit mono mulaw @@ 8kHz.

this is just the infrastructure; no drivers are specifying a default
yet.

ok ratchov@@, deanna@@
@
text
@d1 1
a1 1
/*	$OpenBSD: harmony.c,v 1.25 2006/05/20 01:58:27 mickey Exp $	*/
d467 2
a562 1
	bits |= harmony_speed_bits(sc, &p->sample_rate);
d565 5
@


1.25
log
@do not even match on unsupported hw (instead of return from attach); from 710
@
text
@d1 1
a1 1
/*	$OpenBSD: harmony.c,v 1.24 2005/04/16 21:54:32 mickey Exp $	*/
d107 1
@


1.24
log
@round -- not truncate the buffer size
@
text
@d1 1
a1 1
/*	$OpenBSD: harmony.c,v 1.23 2004/02/13 21:28:19 mickey Exp $	*/
d136 2
d143 10
a152 2
		    ga->ga_type.iodc_sv_model == HPPA_FIO_A2)
			return (1);
d178 1
a178 11
	switch ((cntl & ID_REV_MASK)) {
	case ID_REV_TS:
		sc->sc_teleshare = 1;
	case ID_REV_NOTS:
		break;
	default:
		printf(": unknown id == 0x%02x\n",
		    (cntl & ID_REV_MASK) >> ID_REV_SHIFT);
		bus_space_unmap(sc->sc_bt, sc->sc_bh, HARMONY_NREGS);
		return;
	}
@


1.23
log
@order irq,pri args to gsc_intr_establish() the way less confusing compared to other trolley busses around ...
@
text
@d1 1
a1 1
/*	$OpenBSD: harmony.c,v 1.22 2003/12/20 21:49:06 miod Exp $	*/
d1015 1
a1015 1
	return (size & (size_t)(-HARMONY_BUFSIZE));
@


1.22
log
@Pass -Wformat, fix a few uninitialized variables as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: harmony.c,v 1.21 2003/08/15 13:25:53 mickey Exp $	*/
d235 2
a236 2
	(void)gsc_intr_establish((struct gsc_softc *)parent,
	    IPL_AUDIO, ga->ga_irq, harmony_intr, sc, sc->sc_dv.dv_xname);
@


1.21
log
@bitneaks anonymous randomisation
@
text
@d1 1
a1 1
/*	$OpenBSD: harmony.c,v 1.20 2003/08/07 19:47:33 mickey Exp $	*/
d1266 2
a1267 2
		panic("%s: bad current %x < %x || %x > %x", sc->sc_dv.dv_xname,
		    cur, d->d_map->dm_segs[0].ds_addr, cur,
@


1.20
log
@make all intr_establish take the same last arg for name
@
text
@d1 1
a1 1
/*	$OpenBSD: harmony.c,v 1.19 2003/06/02 19:54:29 jason Exp $	*/
d45 1
d122 8
d268 3
d289 9
d310 2
d1112 2
@


1.19
log
@nuke clause 3 & 4
@
text
@d1 1
a1 1
/*	$OpenBSD: harmony.c,v 1.18 2003/05/11 19:41:09 deraadt Exp $	*/
d227 1
a227 1
	    IPL_AUDIO, ga->ga_irq, harmony_intr, sc, &sc->sc_dv);
@


1.18
log
@string cleaning; krw ok
@
text
@d1 1
a1 1
/*	$OpenBSD: harmony.c,v 1.17 2003/03/12 09:06:11 mickey Exp $	*/
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Jason L. Wright
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.17
log
@reclaim more resources on failures.
test the harmony id to filter out unsupported yet
audio types and detect the teleshare.
detect input overload and report to userland.
@
text
@d1 1
a1 1
/*	$OpenBSD: harmony.c,v 1.16 2003/02/05 19:24:13 jason Exp $	*/
d257 2
a258 1
	sprintf(sc->sc_audev.version, "%u.%u;%u", ga->ga_type.iodc_sv_rev,
d392 1
a392 1
		strcpy(fp->name, AudioEmulaw);
d398 1
a398 1
		strcpy(fp->name, AudioEalaw);
d404 1
a404 1
		strcpy(fp->name, AudioEslinear_be);
d410 1
a410 1
		strcpy(fp->name, AudioEslinear_le);
d416 1
a416 1
		strcpy(fp->name, AudioEulinear_be);
d422 1
a422 1
		strcpy(fp->name, AudioEulinear_le);
d429 1
a429 1
			strcpy(fp->name, AudioEulinear);
d438 1
a438 1
			strcpy(fp->name, AudioEslinear);
d821 1
a821 1
		strcpy(dip->label.name, AudioNinput);
d823 2
a824 1
		strcpy(dip->un.v.units.name, AudioNvolume);
d830 1
a830 1
		strcpy(dip->label.name, "overrange");
d832 2
a833 1
		strcpy(dip->un.e.member[0].label.name, AudioNoff);
d835 2
a836 1
		strcpy(dip->un.e.member[1].label.name, AudioNon);
d843 1
a843 1
		strcpy(dip->label.name, AudioNoutput);
d845 2
a846 1
		strcpy(dip->un.v.units.name, AudioNvolume);
d852 1
a852 1
		strcpy(dip->label.name, "gain");
d854 2
a855 1
		strcpy(dip->un.e.member[0].label.name, AudioNoff);
d857 2
a858 1
		strcpy(dip->un.e.member[1].label.name, AudioNon);
d865 1
a865 1
		strcpy(dip->label.name, AudioNmonitor);
d867 2
a868 1
		strcpy(dip->un.v.units.name, AudioNvolume);
d874 1
a874 1
		strcpy(dip->label.name, AudioNsource);
d876 2
a877 1
		strcpy(dip->un.e.member[0].label.name, AudioNmicrophone);
d879 2
a880 1
		strcpy(dip->un.e.member[1].label.name, AudioNline);
d887 1
a887 1
		strcpy(dip->label.name, AudioNoutput);
d889 2
a890 1
		strcpy(dip->un.e.member[0].label.name, AudioNline);
d892 2
a893 1
		strcpy(dip->un.e.member[1].label.name, AudioNspeaker);
d895 2
a896 1
		strcpy(dip->un.e.member[2].label.name, AudioNheadphone);
d903 1
a903 1
		strcpy(dip->label.name, AudioCinputs);
d909 1
a909 1
		strcpy(dip->label.name, AudioCoutputs);
d915 1
a915 1
		strcpy(dip->label.name, AudioCmonitor);
d921 1
a921 1
		strcpy(dip->label.name, AudioCrecord);
@


1.17.4.1
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: harmony.c,v 1.17 2003/03/12 09:06:11 mickey Exp $	*/
d257 1
a257 2
	snprintf(sc->sc_audev.version, sizeof sc->sc_audev.version,
	    "%u.%u;%u", ga->ga_type.iodc_sv_rev,
d391 1
a391 1
		strlcpy(fp->name, AudioEmulaw, sizeof fp->name);
d397 1
a397 1
		strlcpy(fp->name, AudioEalaw, sizeof fp->name);
d403 1
a403 1
		strlcpy(fp->name, AudioEslinear_be, sizeof fp->name);
d409 1
a409 1
		strlcpy(fp->name, AudioEslinear_le, sizeof fp->name);
d415 1
a415 1
		strlcpy(fp->name, AudioEulinear_be, sizeof fp->name);
d421 1
a421 1
		strlcpy(fp->name, AudioEulinear_le, sizeof fp->name);
d428 1
a428 1
			strlcpy(fp->name, AudioEulinear, sizeof fp->name);
d437 1
a437 1
			strlcpy(fp->name, AudioEslinear, sizeof fp->name);
d820 1
a820 1
		strlcpy(dip->label.name, AudioNinput, sizeof dip->label.name);
d822 1
a822 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d828 1
a828 1
		strlcpy(dip->label.name, "overrange", sizeof dip->label.name);
d830 1
a830 2
		strlcpy(dip->un.e.member[0].label.name, AudioNoff,
		    sizeof dip->un.e.member[0].label.name);
d832 1
a832 2
		strlcpy(dip->un.e.member[1].label.name, AudioNon,
		    sizeof dip->un.e.member[1].label.name);
d839 1
a839 1
		strlcpy(dip->label.name, AudioNoutput, sizeof dip->label.name);
d841 1
a841 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d847 1
a847 1
		strlcpy(dip->label.name, "gain", sizeof dip->label.name);
d849 1
a849 2
		strlcpy(dip->un.e.member[0].label.name, AudioNoff,
		    sizeof dip->un.e.member[0].label.name);
d851 1
a851 2
		strlcpy(dip->un.e.member[1].label.name, AudioNon,
		    sizeof dip->un.e.member[1].label.name);
d858 1
a858 1
		strlcpy(dip->label.name, AudioNmonitor, sizeof dip->label.name);
d860 1
a860 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d866 1
a866 1
		strlcpy(dip->label.name, AudioNsource, sizeof dip->label.name);
d868 1
a868 2
		strlcpy(dip->un.e.member[0].label.name, AudioNmicrophone,
		    sizeof dip->un.e.member[0].label.name);
d870 1
a870 2
		strlcpy(dip->un.e.member[1].label.name, AudioNline,
		    sizeof dip->un.e.member[1].label.name);
d877 1
a877 1
		strlcpy(dip->label.name, AudioNoutput, sizeof dip->label.name);
d879 1
a879 2
		strlcpy(dip->un.e.member[0].label.name, AudioNline,
		    sizeof dip->un.e.member[0].label.name);
d881 1
a881 2
		strlcpy(dip->un.e.member[1].label.name, AudioNspeaker,
		    sizeof dip->un.e.member[1].label.name);
d883 1
a883 2
		strlcpy(dip->un.e.member[2].label.name, AudioNheadphone,
		    sizeof dip->un.e.member[2].label.name);
d890 1
a890 1
		strlcpy(dip->label.name, AudioCinputs, sizeof dip->label.name);
d896 1
a896 1
		strlcpy(dip->label.name, AudioCoutputs, sizeof dip->label.name);
d902 1
a902 1
		strlcpy(dip->label.name, AudioCmonitor, sizeof dip->label.name);
d908 1
a908 1
		strlcpy(dip->label.name, AudioCrecord, sizeof dip->label.name);
@


1.17.4.2
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: harmony.c,v 1.17.4.1 2003/05/13 19:41:03 ho Exp $	*/
d15 5
@


1.17.4.3
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a44 1
#include <dev/rndvar.h>
a120 8
void harmony_acc_tmo(void *);
#define	ADD_CLKALLICA(sc) do {						\
	(sc)->sc_acc <<= 1;						\
	(sc)->sc_acc |= READ_REG((sc), HARMONY_DIAG) & DIAG_CO;		\
	if ((sc)->sc_acc_cnt++ && !((sc)->sc_acc_cnt % 32))		\
		add_true_randomness((sc)->sc_acc_num ^= (sc)->sc_acc);	\
} while(0)

d227 1
a227 1
	    IPL_AUDIO, ga->ga_irq, harmony_intr, sc, sc->sc_dv.dv_xname);
a258 3

	timeout_set(&sc->sc_acc_tmo, harmony_acc_tmo, sc);
	sc->sc_acc_num = 0xa5a5a5a5;
a276 9
void
harmony_acc_tmo(void *v)
{
	struct harmony_softc *sc = v;

	ADD_CLKALLICA(sc);
	timeout_add(&sc->sc_acc_tmo, 1);
}

a288 2
	ADD_CLKALLICA(sc);

a1088 2

	timeout_add(&sc->sc_acc_tmo, 1);
d1241 2
a1242 2
		panic("%s: bad current %x < %lx || %x > %lx",
		    sc->sc_dv.dv_xname, cur, d->d_map->dm_segs[0].ds_addr, cur,
@


1.17.4.4
log
@Merge with the trunk
@
text
@d235 2
a236 2
	(void)gsc_intr_establish((struct gsc_softc *)parent, ga->ga_irq,
	    IPL_AUDIO, harmony_intr, sc, sc->sc_dv.dv_xname);
@


1.16
log
@Add knob for getting at the "output level bit", supposedly changes the
full scale outputs between 2.8Vpp and 2.0Vpp for line.
@
text
@d1 1
a1 1
/*	$OpenBSD: harmony.c,v 1.15 2003/02/05 08:47:05 jason Exp $	*/
d163 13
d179 2
a180 1
		printf(": couldn't alloc empty memory\n");
d186 1
a186 1
		printf(": couldn't map empty memory\n");
d189 1
d195 1
a195 1
		printf(": can't create empty dmamap\n");
d200 1
d205 1
a205 1
		printf(": can't load empty dmamap\n");
d211 1
d247 5
a251 1
	printf(": rev %u\n", rev);
d336 6
d758 6
d823 11
@


1.15
log
@Get rid of the pops:
- interrupt is called when the block has been DMA'd... since LASI seems to
include a FIFO this is -not- the same as block completion which we have
to poll for.  Luckily the FIFO is deep enough that polling in the
interrupt handler seems to work.
- This probably breaks capture, but I'll fix that when I get up tomorrow.
(committed to the tune of Fugazi's "Waiting Room")
@
text
@d1 1
a1 1
/*	$OpenBSD: harmony.c,v 1.14 2003/01/30 03:34:26 mickey Exp $	*/
d223 1
d504 3
d667 6
d746 6
d798 11
@


1.14
log
@reread the dma status reg after playing part of the dma got programmed.
according to the doc, the "play next" bit and therefore the device
interrupt may get raised earlier than the "record next" is set,
thus we might not program the record dma and get another harmony
interrupt right after servicing this one. this little optimization
allows to deal w/ the situation more efficiently, should it occur.
jason@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: harmony.c,v 1.13 2003/01/30 03:23:19 mickey Exp $	*/
d39 1
d80 1
a80 1
    void (*intr)(void *), void *arg, struct audio_params *);
d82 1
a82 1
    void (*intr)(void *), void *arg, struct audio_params *);
a120 1
void harmony_start_pb(struct harmony_softc *);
d122 3
d276 5
d282 20
a301 4
		r = 1;
		harmony_start_pb(sc);
		if (sc->sc_playing && c->c_intr != NULL)
			(*c->c_intr)(c->c_intrarg);
d929 2
d949 21
a969 1
	harmony_start_pb(sc);
a976 37
harmony_start_pb(struct harmony_softc *sc)
{
	struct harmony_channel *c = &sc->sc_playback;
	struct harmony_dma *d;
	bus_addr_t nextaddr;
	bus_size_t togo;

	if (sc->sc_playing == 0) {
		WRITE_REG(sc, HARMONY_PNXTADD,
		    sc->sc_playback_paddrs[sc->sc_playback_empty]);
		SYNC_REG(sc, HARMONY_PNXTADD, BUS_SPACE_BARRIER_WRITE);
		if (++sc->sc_playback_empty == PLAYBACK_EMPTYS)
			sc->sc_playback_empty = 0;
	} else {
		d = c->c_current;
		togo = c->c_segsz - c->c_cnt;
		if (togo == 0) {
			nextaddr = d->d_map->dm_segs[0].ds_addr;
			c->c_cnt = togo = c->c_blksz;
		} else {
			nextaddr = c->c_lastaddr;
			if (togo > c->c_blksz)
				togo = c->c_blksz;
			c->c_cnt += togo;
		}

		bus_dmamap_sync(sc->sc_dmat, d->d_map,
		    nextaddr - d->d_map->dm_segs[0].ds_addr,
		    c->c_blksz, BUS_DMASYNC_PREWRITE);

		WRITE_REG(sc, HARMONY_PNXTADD, nextaddr);
		SYNC_REG(sc, HARMONY_PNXTADD, BUS_SPACE_BARRIER_WRITE);
		c->c_lastaddr = nextaddr + togo;
	}
}

void
a1036 1
	harmony_start_pb(sc);
d1145 36
@


1.13
log
@real meat in audio_device; discussed w/ jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: harmony.c,v 1.12 2003/01/30 01:23:24 jason Exp $	*/
d279 2
@


1.12
log
@Check the codec revision... if it's >=CS4215E or >=AD1849K (same value
strangely =) the make ulinear (native) and slinear (emulated) available.
Also, while here, make ulinear_le:16 available via emulation.
(Btw, the LASI docs say that the format code for ulinear is a
reserved value... Probably just wasn't available in the early CS4215/AD1849's)
@
text
@d1 1
a1 1
/*	$OpenBSD: harmony.c,v 1.11 2003/01/29 00:52:23 mickey Exp $	*/
a111 6
const struct audio_device harmony_device = {
	"harmony",
	"gsc",
	"lasi",
};

d231 6
d591 4
a594 1
	*retp = harmony_device;
@


1.11
log
@print out the codec revision in dmesg
@
text
@d1 1
a1 1
/*	$OpenBSD: harmony.c,v 1.10 2003/01/28 05:12:47 jason Exp $	*/
d153 1
d231 5
a235 2
	printf(": rev %d\n",
	    (cntl & CNTL_CODEC_REV_MASK) >> CNTL_CODEC_REV_SHIFT);
d332 1
d366 24
d417 12
a428 1
		if (p->precision != 16)
d430 1
a430 1
		bits = CNTL_FORMAT_SLINEAR16BE;
d432 2
a433 4

	/* emulated formats */
	case AUDIO_ENCODING_SLINEAR_LE:
		if (p->precision != 16)
d435 2
a436 2
		bits = CNTL_FORMAT_SLINEAR16BE;
		rswcode = pswcode = swap_bytes;
d438 12
d451 22
a472 5
		if (p->precision != 16)
			return (EINVAL);
		bits = CNTL_FORMAT_SLINEAR16BE;
		rswcode = pswcode = change_sign16_be;
		break;
d533 1
@


1.10
log
@Ok, you can only set the HE/SE/LE/IS bits in GAINCTL when reset is asserted (why? I have no clue, but not abding this causes the chip to wedge).
So, you can now switch input/output ports to your hearts content...
oh did I mention several commits ago that capture works?
@
text
@d1 1
a1 1
/*	$OpenBSD: harmony.c,v 1.9 2003/01/28 04:20:49 jason Exp $	*/
d153 1
d229 3
a231 1
	printf("\n");
@


1.9
log
@Move device driver specific stuff to *var.h and add most of the code for
dealing with output source selection (doesn't work right yet, so its disabled).
@
text
@d1 1
a1 1
/*	$OpenBSD: harmony.c,v 1.8 2003/01/27 23:12:41 jason Exp $	*/
d124 1
a124 1
void harmony_set_gainctl(struct harmony_softc *);
d448 2
a449 2
	WRITE_REG(sc, HARMONY_GAINCTL, GAINCTL_OUTPUT_LEFT_M |
	    GAINCTL_OUTPUT_RIGHT_M | GAINCTL_MONITOR_M);
a490 1
	harmony_set_gainctl(sc);
d1013 1
a1013 1
void
d1016 1
a1016 2
	/* master (monitor) and playback are inverted */
	u_int32_t bits, mask, val;
a1038 1
#if 0
d1044 1
a1044 1
		bits |= GAINCTL_IS_MIC;
d1047 1
a1047 1
	bits = ~(GAINCTL_LE | GAINCTL_HE | GAINCTL_SE);
d1055 2
a1056 2
#endif

d1058 3
@


1.8
log
@Stupid stupid stupid... DMA will not start until the capture next register
is written.  I'm not sure how to -correctly- handle this for the fullduplex
case, but this seems to make playback sound MUCH better...
@
text
@d1 1
a1 1
/*	$OpenBSD: harmony.c,v 1.7 2003/01/27 19:16:41 jason Exp $	*/
d59 1
a59 74

#define HARMONY_PORT_INPUT_LVL		0
#define	HARMONY_PORT_OUTPUT_LVL		1
#define	HARMONY_PORT_MONITOR_LVL	2
#define	HARMONY_PORT_RECORD_SOURCE	3
#define	HARMONY_PORT_INPUT_CLASS	4
#define	HARMONY_PORT_OUTPUT_CLASS	5
#define	HARMONY_PORT_MONITOR_CLASS	6
#define	HARMONY_PORT_RECORD_CLASS	7

#define	HARMONY_IN_MIC			0
#define	HARMONY_IN_LINE			1

#define	PLAYBACK_EMPTYS			3	/* playback empty buffers */
#define	CAPTURE_EMPTYS			3	/* capture empty buffers */
#define	HARMONY_BUFSIZE			4096

struct harmony_volume {
	u_char left, right;
};

struct harmony_empty {
	u_int8_t	playback[PLAYBACK_EMPTYS][HARMONY_BUFSIZE];
	u_int8_t	capture[CAPTURE_EMPTYS][HARMONY_BUFSIZE];
};

struct harmony_dma {
	struct harmony_dma *d_next;
	bus_dmamap_t d_map;
	bus_dma_segment_t d_seg;
	caddr_t d_kva;
	size_t d_size;
};

struct harmony_channel {
	struct harmony_dma *c_current;
	bus_size_t c_segsz;
	bus_size_t c_cnt;
	bus_size_t c_blksz;
	bus_addr_t c_lastaddr;
	void (*c_intr)(void *);
	void *c_intrarg;
};

struct harmony_softc {
	struct device sc_dv;
	bus_dma_tag_t sc_dmat;
	bus_space_tag_t sc_bt;
	bus_space_handle_t sc_bh;
	int sc_open;
	u_int32_t sc_cntlbits;
	int sc_need_commit;
	int sc_playback_empty;
	bus_addr_t sc_playback_paddrs[PLAYBACK_EMPTYS];
	int sc_capture_empty;
	bus_addr_t sc_capture_paddrs[CAPTURE_EMPTYS];
	bus_dmamap_t sc_empty_map;
	bus_dma_segment_t sc_empty_seg;
	int sc_empty_rseg;
	struct harmony_empty *sc_empty_kva;
	struct harmony_dma *sc_dmas;
	int sc_playing, sc_capturing;
	struct harmony_channel sc_playback, sc_capture;
	struct harmony_volume sc_monitor_lvl, sc_input_lvl, sc_output_lvl;
	int sc_in_port;
};

#define	READ_REG(sc, reg)		\
    bus_space_read_4((sc)->sc_bt, (sc)->sc_bh, (reg))
#define	WRITE_REG(sc, reg, val)		\
    bus_space_write_4((sc)->sc_bt, (sc)->sc_bh, (reg), (val))
#define	SYNC_REG(sc, reg, flags)	\
    bus_space_barrier((sc)->sc_bt, (sc)->sc_bh, (reg), sizeof(u_int32_t), \
	(flags))
d220 1
d584 11
d652 6
d688 1
a688 1
		strcpy(dip->label.name, AudioNoutput);
d703 13
d923 1
a923 3
		bus_space_barrier(sc->sc_bt, sc->sc_bh,
		    HARMONY_RNXTADD, sizeof(u_int32_t),
		    BUS_SPACE_BARRIER_WRITE);
d1021 1
a1021 1
	bits = GAINCTL_HE | GAINCTL_LE | GAINCTL_SE | GAINCTL_IS_MASK;
d1040 19
@


1.7
log
@As promised, I got some sleep and rewrote most of the driver... playback
is still a bit spotty, but at least interrupts are not enabled constantly
any more.
Also discovered a feature: messing with the LINE/MIC bit in GAINCTL has
the side effect of wedging the chip under some circumstances, but I think
this can be worked around by resetting the codec... later.
@
text
@d1 1
a1 1
/*	$OpenBSD: harmony.c,v 1.6 2003/01/27 08:12:32 jason Exp $	*/
d199 2
d329 1
d338 1
d340 3
a342 37
		if (sc->sc_playing == 0) {
			WRITE_REG(sc, HARMONY_PNXTADD,
			    sc->sc_playback_paddrs[sc->sc_playback_empty]);
			SYNC_REG(sc, HARMONY_PNXTADD, BUS_SPACE_BARRIER_WRITE);
			if (++sc->sc_playback_empty == PLAYBACK_EMPTYS)
				sc->sc_playback_empty = 0;
		} else {
			struct harmony_channel *c = &sc->sc_playback;
			struct harmony_dma *d;
			bus_addr_t nextaddr;
			bus_size_t togo;

			d = c->c_current;
			togo = c->c_segsz - c->c_cnt;
			if (togo == 0) {
				nextaddr = d->d_map->dm_segs[0].ds_addr;
				c->c_cnt = togo = c->c_blksz;
			} else {
				nextaddr = c->c_lastaddr;
				if (togo > c->c_blksz)
					togo = c->c_blksz;
				c->c_cnt += togo;
			}

			bus_dmamap_sync(sc->sc_dmat, d->d_map,
			    nextaddr - d->d_map->dm_segs[0].ds_addr,
			    c->c_blksz, BUS_DMASYNC_PREWRITE);

			WRITE_REG(sc, HARMONY_PNXTADD, nextaddr);
			bus_space_barrier(sc->sc_bt, sc->sc_bh,
			    HARMONY_PNXTADD, sizeof(u_int32_t),
			    BUS_SPACE_BARRIER_WRITE);
			c->c_lastaddr = nextaddr + togo;

			if (c->c_intr != NULL)
				(*c->c_intr)(c->c_intrarg);
		}
d346 1
d348 3
a350 36
		if (sc->sc_capturing == 0) {
			WRITE_REG(sc, HARMONY_RNXTADD,
			    sc->sc_capture_paddrs[sc->sc_capture_empty]);
			if (++sc->sc_capture_empty == CAPTURE_EMPTYS)
				sc->sc_capture_empty = 0;
		} else {
			struct harmony_channel *c = &sc->sc_capture;
			struct harmony_dma *d;
			bus_addr_t nextaddr;
			bus_size_t togo;

			d = c->c_current;
			togo = c->c_segsz - c->c_cnt;
			if (togo == 0) {
				nextaddr = d->d_map->dm_segs[0].ds_addr;
				c->c_cnt = togo = c->c_blksz;
			} else {
				nextaddr = c->c_lastaddr;
				if (togo > c->c_blksz)
					togo = c->c_blksz;
				c->c_cnt += togo;
			}

			bus_dmamap_sync(sc->sc_dmat, d->d_map,
			    nextaddr - d->d_map->dm_segs[0].ds_addr,
			    c->c_blksz, BUS_DMASYNC_PREWRITE);

			WRITE_REG(sc, HARMONY_RNXTADD, nextaddr);
			bus_space_barrier(sc->sc_bt, sc->sc_bh,
			    HARMONY_RNXTADD, sizeof(u_int32_t),
			    BUS_SPACE_BARRIER_WRITE);
			c->c_lastaddr = nextaddr + togo;

			if (c->c_intr != NULL)
				(*c->c_intr)(c->c_intrarg);
		}
d890 2
d897 75
a995 5
	bus_space_write_4(sc->sc_bt, sc->sc_bh, HARMONY_RNXTADD,
	    d->d_map->dm_segs[0].ds_addr);
	bus_space_barrier(sc->sc_bt, sc->sc_bh, HARMONY_RNXTADD,
	    sizeof(u_int32_t), BUS_SPACE_BARRIER_WRITE);

d997 2
@


1.6
log
@separate register defns and revise them based on the LASI info... a HUGE
chunk of this driver will be rewritten once I've gotten some zzz's.
@
text
@d1 1
a1 1
/*	$OpenBSD: harmony.c,v 1.5 2003/01/27 02:32:36 jason Exp $	*/
d63 8
a70 3
#define	HARMONY_PORT_INPUT_CLASS	3
#define	HARMONY_PORT_OUTPUT_CLASS	4
#define	HARMONY_PORT_MONITOR_CLASS	5
d123 1
d126 8
d185 1
a185 1
struct audio_device harmony_device = {
a195 2
void harmony_wait(struct harmony_softc *);
void harmony_set_gainctl(struct harmony_softc *, u_int32_t);
d197 2
a198 1
void harmony_set_volume(struct harmony_softc *);
d289 2
a290 1
	/* set default gains */
d295 2
a296 7
	/* reset codec */
	harmony_set_gainctl(sc, GAINCTL_OUTPUT_LEFT_M |
	    GAINCTL_OUTPUT_RIGHT_M | GAINCTL_MONITOR_M);
	harmony_wait(sc);
	bus_space_write_4(sc->sc_bt, sc->sc_bh, HARMONY_RESET, 1);
	DELAY(50000);
	bus_space_write_4(sc->sc_bt, sc->sc_bh, HARMONY_RESET, 0);
d303 16
d332 1
a332 3
	harmony_wait(sc);

	dstatus = bus_space_read_4(sc->sc_bt, sc->sc_bh, HARMONY_DSTATUS);
d337 1
a337 1
			bus_space_write_4(sc->sc_bt, sc->sc_bh, HARMONY_PNXTADD,
d339 1
a339 3
			bus_space_barrier(sc->sc_bt, sc->sc_bh,
			    HARMONY_PNXTADD, sizeof(u_int32_t),
			    BUS_SPACE_BARRIER_WRITE);
d364 1
a364 2
			bus_space_write_4(sc->sc_bt, sc->sc_bh,
			    HARMONY_PNXTADD, nextaddr);
d378 1
a378 1
			bus_space_write_4(sc->sc_bt, sc->sc_bh, HARMONY_RNXTADD,
d404 1
a404 2
			bus_space_write_4(sc->sc_bt, sc->sc_bh,
			    HARMONY_RNXTADD, nextaddr);
d423 2
a424 5
	harmony_wait(sc);
	bus_space_write_4(sc->sc_bt, sc->sc_bh,
	    HARMONY_DSTATUS, DSTATUS_IE);
	bus_space_barrier(sc->sc_bt, sc->sc_bh, HARMONY_DSTATUS,
	    sizeof(u_int32_t), BUS_SPACE_BARRIER_WRITE);
d430 2
a431 23
	harmony_wait(sc);
	bus_space_write_4(sc->sc_bt, sc->sc_bh, HARMONY_DSTATUS, 0);
	bus_space_barrier(sc->sc_bt, sc->sc_bh, HARMONY_DSTATUS,
	    sizeof(u_int32_t), BUS_SPACE_BARRIER_WRITE);
}

void
harmony_wait(struct harmony_softc *sc)
{
	int i = 5000;

	for (i = 5000; i > 0; i++)
		if (((bus_space_read_4(sc->sc_bt, sc->sc_bh, HARMONY_CNTL)
		    & CNTL_C)) == 0)
			return;
	printf("%s: wait timeout\n", sc->sc_dv.dv_xname);
}

void
harmony_set_gainctl(struct harmony_softc *sc, u_int32_t gain)
{
	harmony_wait(sc);
	bus_space_write_4(sc->sc_bt, sc->sc_bh, HARMONY_GAINCTL, gain);
a441 1
	harmony_set_volume(sc);
d452 1
d567 1
d574 10
a583 3
	harmony_wait(sc);
	bus_space_write_4(sc->sc_bt, sc->sc_bh, HARMONY_CNTL,
	    sc->sc_cntlbits | CNTL_C);
d608 18
a625 1
	harmony_set_volume(sc);
d628 3
d708 10
d769 6
d809 11
d838 6
a933 1
	bus_size_t n;
a944 3

	n = (caddr_t)end - (caddr_t)start;

d947 3
a949 6
	c->c_segsz = n;

	if (n > c->c_blksz)
		n = c->c_blksz;
	c->c_cnt = n;
	c->c_lastaddr = d->d_map->dm_segs[0].ds_addr + c->c_blksz;
d952 1
a952 6
	bus_dmamap_sync(sc->sc_dmat, d->d_map, 0, c->c_blksz,
	    BUS_DMASYNC_PREWRITE);
	bus_space_write_4(sc->sc_bt, sc->sc_bh, HARMONY_PNXTADD,
	    d->d_map->dm_segs[0].ds_addr);
	bus_space_barrier(sc->sc_bt, sc->sc_bh, HARMONY_PNXTADD,
	    sizeof(u_int32_t), BUS_SPACE_BARRIER_WRITE);
a953 1
	harmony_intr_enable(sc);
a963 1
	bus_size_t n;
a974 1
	n = (char *)end - (char *)start;
d977 3
a979 5
	c->c_segsz = n;
	if (n > c->c_blksz)
		n = c->c_blksz;
	c->c_cnt = n;
	c->c_lastaddr = d->d_map->dm_segs[0].ds_addr + c->c_blksz;
d1047 1
a1047 1
harmony_set_volume(struct harmony_softc *sc)
d1052 2
a1053 1
	bits = 0x0f000000;	/* XXX I hate linux */
d1073 1
a1073 2
	printf("%s: gainctl(%x)\n", sc->sc_dv.dv_xname, bits);
	harmony_set_gainctl(sc, bits);
@


1.5
log
@I declare defeat... once interrupts are enabled, just leave them enabled.
This is annoying because the chip will keep dma'n, but everytime I disable
interrupts in halt_*, they never come back.  Grr.
@
text
@d1 1
a1 1
/*	$OpenBSD: harmony.c,v 1.4 2003/01/27 01:38:21 jason Exp $	*/
d34 4
d58 1
a58 54

#define	HARMONY_NREGS	0x40

#define	HARMONY_ID		0x00
#define	HARMONY_RESET		0x04
#define	HARMONY_CNTL		0x08
#define	HARMONY_GAINCTL		0x0c		/* gain control */
#define	HARMONY_PLAYNXT		0x10		/* play next address */
#define	HARMONY_PLAYCUR		0x14		/* play current address */
#define	HARMONY_CAPTNXT		0x18		/* capture next address */
#define	HARMONY_CAPTCUR		0x1c		/* capture current address */
#define	HARMONY_DSTATUS		0x20		/* device status */
#define	HARMONY_OV		0x24
#define	HARMONY_PIO		0x28
#define	HARMONY_DIAG		0x3c

#define	CNTL_INCNTL		0x80000000
#define	CNTL_FORMAT_MASK	0x000000c0
#define	CNTL_FORMAT_SLINEAR16BE	0x00000000
#define	CNTL_FORMAT_ULAW	0x00000040
#define	CNTL_FORMAT_ALAW	0x00000080
#define	CNTL_CHANS_MASK		0x00000020
#define	CNTL_CHANS_MONO		0x00000000
#define	CNTL_CHANS_STEREO	0x00000020
#define	CNTL_RATE_MASK		0x0000001f
#define	CNTL_RATE_5125		0x00000010
#define	CNTL_RATE_6615		0x00000017
#define	CNTL_RATE_8000		0x00000008
#define	CNTL_RATE_9600		0x0000000f
#define	CNTL_RATE_11025		0x00000011
#define	CNTL_RATE_16000		0x00000009
#define	CNTL_RATE_18900		0x00000012
#define	CNTL_RATE_22050		0x00000013
#define	CNTL_RATE_27428		0x0000000a
#define	CNTL_RATE_32000		0x0000000b
#define	CNTL_RATE_33075		0x00000016
#define	CNTL_RATE_37800		0x00000014
#define	CNTL_RATE_44100		0x00000015
#define	CNTL_RATE_48000		0x0000000e

#define	GAINCTL_INPUT_LEFT_M	0x0000f000
#define	GAINCTL_INPUT_LEFT_S	12
#define	GAINCTL_INPUT_RIGHT_M	0x000f0000
#define	GAINCTL_INPUT_RIGHT_S	16
#define	GAINCTL_MONITOR_M	0x00f00000
#define	GAINCTL_MONITOR_S	20
#define	GAINCTL_OUTPUT_LEFT_M	0x00000fc0
#define	GAINCTL_OUTPUT_LEFT_S	6
#define	GAINCTL_OUTPUT_RIGHT_M	0x0000003f
#define	GAINCTL_OUTPUT_RIGHT_S	0

#define	DSTATUS_INTRENA		0x80000000
#define	DSTATUS_PLAYNXT		0x00000200
#define	DSTATUS_CAPTNXT		0x00000002
d71 4
a103 1
	u_int32_t sc_gainctl;
d116 2
a117 1
	struct harmony_channel sc_playback;
d185 1
d277 3
a279 7
	sc->sc_gainctl =
	    ((0x2 << GAINCTL_OUTPUT_LEFT_S) & GAINCTL_OUTPUT_LEFT_M) |
	    ((0x2 << GAINCTL_OUTPUT_RIGHT_S) & GAINCTL_OUTPUT_RIGHT_M) |
	    ((0xf << GAINCTL_INPUT_LEFT_S) & GAINCTL_INPUT_LEFT_M) |
	    ((0xf << GAINCTL_INPUT_RIGHT_S) & GAINCTL_INPUT_RIGHT_M) |
	    ((0x2 << GAINCTL_MONITOR_S) & GAINCTL_MONITOR_M) |
	    0x0f000000;
d311 1
a311 1
	if (dstatus & DSTATUS_PLAYNXT) {
d314 1
a314 1
			bus_space_write_4(sc->sc_bt, sc->sc_bh, HARMONY_PLAYNXT,
d317 1
a317 1
			    HARMONY_PLAYNXT, sizeof(u_int32_t),
d344 1
a344 1
			    HARMONY_PLAYNXT, nextaddr);
d346 1
a346 1
			    HARMONY_PLAYNXT, sizeof(u_int32_t),
d355 1
a355 1
	if (dstatus & DSTATUS_CAPTNXT) {
d357 37
a393 4
		bus_space_write_4(sc->sc_bt, sc->sc_bh, HARMONY_CAPTNXT,
		    sc->sc_capture_paddrs[sc->sc_capture_empty]);
		if (++sc->sc_capture_empty == CAPTURE_EMPTYS)
			sc->sc_capture_empty = 0;
d406 1
a406 1
	    HARMONY_DSTATUS, DSTATUS_INTRENA);
d427 1
a427 1
		    & CNTL_INCNTL)) == 0)
d447 1
a447 3

	harmony_set_gainctl(sc, sc->sc_gainctl);

d580 1
a580 1
	    sc->sc_cntlbits | CNTL_INCNTL);
d604 2
d646 8
a653 18
		if (cp->un.value.num_channels == 1) {
			sc->sc_gainctl &=
			    ~(GAINCTL_INPUT_LEFT_M | GAINCTL_INPUT_RIGHT_M);
			sc->sc_gainctl |=
			    (cp->un.value.level[AUDIO_MIXER_LEVEL_MONO] <<
			    GAINCTL_INPUT_LEFT_S) & GAINCTL_INPUT_LEFT_M;
			sc->sc_gainctl |=
			    (cp->un.value.level[AUDIO_MIXER_LEVEL_MONO] <<
			    GAINCTL_INPUT_RIGHT_S) & GAINCTL_INPUT_RIGHT_M;
		} else if (cp->un.value.num_channels == 2) {
			sc->sc_gainctl &=
			    ~(GAINCTL_INPUT_LEFT_M | GAINCTL_INPUT_RIGHT_M);
			sc->sc_gainctl |=
			    (cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT] <<
			    GAINCTL_INPUT_RIGHT_S) & GAINCTL_INPUT_RIGHT_M;
			sc->sc_gainctl |=
			    (cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT] <<
			    GAINCTL_INPUT_RIGHT_S) & GAINCTL_INPUT_RIGHT_M;
d656 1
a656 1
		harmony_set_gainctl(sc, sc->sc_gainctl);
d662 8
a669 18
		if (cp->un.value.num_channels == 1) {
			sc->sc_gainctl &=
			    ~(GAINCTL_OUTPUT_LEFT_M | GAINCTL_OUTPUT_RIGHT_M);
			sc->sc_gainctl |=
			    (cp->un.value.level[AUDIO_MIXER_LEVEL_MONO] <<
			    GAINCTL_OUTPUT_LEFT_S) & GAINCTL_OUTPUT_LEFT_M;
			sc->sc_gainctl |=
			    (cp->un.value.level[AUDIO_MIXER_LEVEL_MONO] <<
			    GAINCTL_OUTPUT_RIGHT_S) & GAINCTL_OUTPUT_RIGHT_M;
		} else if (cp->un.value.num_channels == 2) {
			sc->sc_gainctl &=
			    ~(GAINCTL_OUTPUT_LEFT_M | GAINCTL_OUTPUT_RIGHT_M);
			sc->sc_gainctl |=
			    (cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT] <<
			    GAINCTL_OUTPUT_RIGHT_S) & GAINCTL_OUTPUT_RIGHT_M;
			sc->sc_gainctl |=
			    (cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT] <<
			    GAINCTL_OUTPUT_RIGHT_S) & GAINCTL_OUTPUT_RIGHT_M;
d672 1
a672 1
		harmony_set_gainctl(sc, sc->sc_gainctl);
d680 3
a682 5
		sc->sc_gainctl &= ~GAINCTL_MONITOR_M;
		sc->sc_gainctl |=
		    (cp->un.value.level[AUDIO_MIXER_LEVEL_MONO] <<
		    GAINCTL_MONITOR_S) & GAINCTL_MONITOR_M;
		harmony_set_gainctl(sc, sc->sc_gainctl);
d702 1
a702 2
			    (sc->sc_gainctl & GAINCTL_INPUT_LEFT_M) >>
			    GAINCTL_INPUT_LEFT_S;
d705 1
a705 2
			    (sc->sc_gainctl & GAINCTL_INPUT_LEFT_M) >>
			    GAINCTL_INPUT_LEFT_S;
d707 1
a707 2
			    (sc->sc_gainctl & GAINCTL_INPUT_RIGHT_M) >>
			    GAINCTL_INPUT_RIGHT_S;
d717 1
a717 2
			    (sc->sc_gainctl & GAINCTL_OUTPUT_LEFT_M) >>
			    GAINCTL_OUTPUT_LEFT_S;
d720 1
a720 2
			    (sc->sc_gainctl & GAINCTL_OUTPUT_LEFT_M) >>
			    GAINCTL_OUTPUT_LEFT_S;
d722 1
a722 2
			    (sc->sc_gainctl & GAINCTL_OUTPUT_RIGHT_M) >>
			    GAINCTL_OUTPUT_RIGHT_S;
d733 1
a733 2
		    (sc->sc_gainctl & GAINCTL_MONITOR_M) >>
		    GAINCTL_MONITOR_S;
d905 1
a905 1
	bus_space_write_4(sc->sc_bt, sc->sc_bh, HARMONY_PLAYNXT,
d907 1
a907 1
	bus_space_barrier(sc->sc_bt, sc->sc_bh, HARMONY_PLAYNXT,
d916 1
a916 1
    void (*intr)(void *), void *arg, struct audio_params *param)
d919 27
a946 4
	bus_space_write_4(sc->sc_bt, sc->sc_bh, HARMONY_CAPTNXT,
	    sc->sc_capture_paddrs[sc->sc_capture_empty]);
	if (++sc->sc_capture_empty == CAPTURE_EMPTYS)
		sc->sc_capture_empty = 0;
d1005 30
@


1.4
log
@Write to the cntl register with the c flag set.
@
text
@d1 1
a1 1
/*	$OpenBSD: harmony.c,v 1.3 2003/01/26 21:25:39 jason Exp $	*/
d161 1
a161 1
	int sc_playing, sc_capturing, sc_intr_enable;
d329 8
d353 1
a353 2
	if (sc->sc_intr_enable == 0)
		return (0);
a354 1
	harmony_intr_disable(sc);
d357 1
a357 2
	dstatus = bus_space_read_4(sc->sc_bt, sc->sc_bh, HARMONY_DSTATUS) &
	    (DSTATUS_PLAYNXT | DSTATUS_CAPTNXT);
d364 3
d393 3
a419 1
	sc->sc_intr_enable = 1;
d422 2
d431 2
a432 1
	sc->sc_intr_enable = 0;
a462 10
	/* silence */
	harmony_set_gainctl(sc, GAINCTL_OUTPUT_LEFT_M |
	    GAINCTL_OUTPUT_RIGHT_M | GAINCTL_MONITOR_M);

	/* reset codec */
	harmony_wait(sc);
	bus_space_write_4(sc->sc_bt, sc->sc_bh, HARMONY_RESET, 1);
	DELAY(50000);
	bus_space_write_4(sc->sc_bt, sc->sc_bh, HARMONY_RESET, 0);

a630 1
	harmony_intr_disable(sc);
a639 1
	harmony_intr_disable(sc);
d944 1
d946 1
d951 2
a952 1
	c->c_lastaddr = d->d_map->dm_segs[0].ds_addr + n;
a953 1
	sc->sc_playing = 1;
@


1.3
log
@Ok, playback more or less works, now for capture.  (I forgot to save the pintr/parg)
@
text
@d1 1
a1 1
/*	$OpenBSD: harmony.c,v 1.2 2003/01/26 21:14:57 jason Exp $	*/
d593 2
a594 1
	bus_space_write_4(sc->sc_bt, sc->sc_bh, HARMONY_CNTL, sc->sc_cntlbits);
@


1.2
log
@Ok, this now produces some noise (that's the best way I can describe it),
but the timing appears to get off some how and buffers just stay on the
chip.  Oh well, at least its keeping me from playing in the traffic.
@
text
@d1 1
a1 1
/*	$OpenBSD: harmony.c,v 1.1 2003/01/26 07:21:40 jason Exp $	*/
d915 1
a915 1
    void (*intr)(void *), void *arg, struct audio_params *param)
d929 3
@


1.1
log
@Start on the harmony audio driver.  It doesn't play or capture anything
yet, but the knobs and interrupt routine seem to work.  More to come.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d125 18
d160 3
d178 2
a179 2
void *  harmony_alloc(void *, int, size_t, int, int);
void    harmony_free(void *, void *, int);
a185 1
u_int32_t harmony_speed_bits(struct harmony_softc *, u_long *);
d207 2
a208 2
	NULL,
	NULL,
d229 1
d343 4
a352 4
	if (dstatus == 0)
		return (0);

	printf("%s: intr %x\n", sc->sc_dv.dv_xname, dstatus);
d355 35
a389 4
		bus_space_write_4(sc->sc_bt, sc->sc_bh, HARMONY_PLAYNXT,
		    sc->sc_playback_paddrs[sc->sc_playback_empty]);
		if (++sc->sc_playback_empty == PLAYBACK_EMPTYS)
			sc->sc_playback_empty = 0;
d393 1
d402 1
a402 1
	return (1);
d409 1
d419 1
d579 1
a579 1
	return (blk & (-4));
d628 1
d638 1
d838 63
d904 1
a904 1
	return (size);
d918 11
d930 12
d943 4
a946 3
	    sc->sc_playback_paddrs[sc->sc_playback_empty]);
	if (++sc->sc_playback_empty == PLAYBACK_EMPTYS)
		sc->sc_playback_empty = 0;
d961 1
@

