head	1.29;
access;
symbols
	OPENBSD_6_2_BASE:1.29
	OPENBSD_6_1:1.29.0.8
	OPENBSD_6_1_BASE:1.29
	OPENBSD_6_0:1.29.0.4
	OPENBSD_6_0_BASE:1.29
	OPENBSD_5_9:1.29.0.2
	OPENBSD_5_9_BASE:1.29
	OPENBSD_5_8:1.26.0.8
	OPENBSD_5_8_BASE:1.26
	OPENBSD_5_7:1.26.0.2
	OPENBSD_5_7_BASE:1.26
	OPENBSD_5_6:1.26.0.4
	OPENBSD_5_6_BASE:1.26
	OPENBSD_5_5:1.25.0.40
	OPENBSD_5_5_BASE:1.25
	OPENBSD_5_4:1.25.0.36
	OPENBSD_5_4_BASE:1.25
	OPENBSD_5_3:1.25.0.34
	OPENBSD_5_3_BASE:1.25
	OPENBSD_5_2:1.25.0.32
	OPENBSD_5_2_BASE:1.25
	OPENBSD_5_1_BASE:1.25
	OPENBSD_5_1:1.25.0.30
	OPENBSD_5_0:1.25.0.28
	OPENBSD_5_0_BASE:1.25
	OPENBSD_4_9:1.25.0.26
	OPENBSD_4_9_BASE:1.25
	OPENBSD_4_8:1.25.0.24
	OPENBSD_4_8_BASE:1.25
	OPENBSD_4_7:1.25.0.20
	OPENBSD_4_7_BASE:1.25
	OPENBSD_4_6:1.25.0.22
	OPENBSD_4_6_BASE:1.25
	OPENBSD_4_5:1.25.0.18
	OPENBSD_4_5_BASE:1.25
	OPENBSD_4_4:1.25.0.16
	OPENBSD_4_4_BASE:1.25
	OPENBSD_4_3:1.25.0.14
	OPENBSD_4_3_BASE:1.25
	OPENBSD_4_2:1.25.0.12
	OPENBSD_4_2_BASE:1.25
	OPENBSD_4_1:1.25.0.10
	OPENBSD_4_1_BASE:1.25
	OPENBSD_4_0:1.25.0.8
	OPENBSD_4_0_BASE:1.25
	OPENBSD_3_9:1.25.0.6
	OPENBSD_3_9_BASE:1.25
	OPENBSD_3_8:1.25.0.4
	OPENBSD_3_8_BASE:1.25
	OPENBSD_3_7:1.25.0.2
	OPENBSD_3_7_BASE:1.25
	OPENBSD_3_6:1.24.0.2
	OPENBSD_3_6_BASE:1.24
	SMP_SYNC_A:1.24
	SMP_SYNC_B:1.24
	OPENBSD_3_5:1.23.0.2
	OPENBSD_3_5_BASE:1.23
	OPENBSD_3_4:1.21.0.2
	OPENBSD_3_4_BASE:1.21
	UBC_SYNC_A:1.17
	OPENBSD_3_3:1.17.0.2
	OPENBSD_3_3_BASE:1.17
	OPENBSD_3_2:1.13.0.2
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.12.0.2
	OPENBSD_3_1_BASE:1.12
	UBC_SYNC_B:1.14
	UBC:1.6.0.6
	UBC_BASE:1.6
	OPENBSD_3_0:1.6.0.4
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9:1.6.0.2
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_8:1.5.0.6
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.4
	OPENBSD_2_7_BASE:1.5
	SMP:1.5.0.2
	SMP_BASE:1.5
	kame_19991208:1.5
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.1.0.2
	OPENBSD_2_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.29
date	2015.11.24.17.11.38;	author mpi;	state Exp;
branches;
next	1.28;
commitid	5gdEnqVoJuTuwdTu;

1.28
date	2015.11.24.13.33.18;	author mpi;	state Exp;
branches;
next	1.27;
commitid	5DvsamK0GblTp8ww;

1.27
date	2015.09.14.11.18.48;	author stsp;	state Exp;
branches;
next	1.26;
commitid	AyPOP6b7LKyRd0yH;

1.26
date	2014.03.29.18.09.29;	author guenther;	state Exp;
branches;
next	1.25;

1.25
date	2004.10.28.19.13.30;	author mickey;	state Exp;
branches;
next	1.24;

1.24
date	2004.04.07.18.24.19;	author mickey;	state Exp;
branches;
next	1.23;

1.23
date	2004.02.13.21.28.19;	author mickey;	state Exp;
branches;
next	1.22;

1.22
date	2003.10.27.17.22.58;	author mickey;	state Exp;
branches;
next	1.21;

1.21
date	2003.08.07.19.47.33;	author mickey;	state Exp;
branches;
next	1.20;

1.20
date	2003.08.03.21.28.24;	author mickey;	state Exp;
branches;
next	1.19;

1.19
date	2003.08.03.19.03.50;	author mickey;	state Exp;
branches;
next	1.18;

1.18
date	2003.05.21.02.14.18;	author mickey;	state Exp;
branches;
next	1.17;

1.17
date	2003.01.25.07.22.01;	author jason;	state Exp;
branches;
next	1.16;

1.16
date	2002.12.14.23.00.48;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2002.12.11.06.02.23;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	2002.10.13.14.15.35;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	2002.07.17.22.18.38;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	2002.03.18.19.13.28;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	2002.03.15.21.44.18;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.14.01.26.31;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2002.02.11.21.20.51;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	2002.02.06.19.07.04;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.03.01.46.46;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	2001.01.12.22.57.04;	author mickey;	state Exp;
branches
	1.6.6.1;
next	1.5;

1.5
date	99.11.26.17.47.42;	author mickey;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	99.11.16.17.14.25;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	99.08.16.02.48.39;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	99.08.14.04.08.06;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	99.01.03.23.59.18;	author mickey;	state Exp;
branches;
next	;

1.5.2.1
date	2001.04.18.16.06.04;	author niklas;	state Exp;
branches;
next	1.5.2.2;

1.5.2.2
date	2002.03.06.00.57.22;	author niklas;	state Exp;
branches;
next	1.5.2.3;

1.5.2.3
date	2002.03.28.10.07.19;	author niklas;	state Exp;
branches;
next	1.5.2.4;

1.5.2.4
date	2003.03.27.23.26.53;	author niklas;	state Exp;
branches;
next	1.5.2.5;

1.5.2.5
date	2003.06.07.11.11.36;	author ho;	state Exp;
branches;
next	1.5.2.6;

1.5.2.6
date	2004.02.19.10.48.40;	author niklas;	state Exp;
branches;
next	1.5.2.7;

1.5.2.7
date	2004.06.05.23.10.48;	author niklas;	state Exp;
branches;
next	;

1.6.6.1
date	2002.06.11.03.35.36;	author art;	state Exp;
branches;
next	1.6.6.2;

1.6.6.2
date	2002.10.29.00.28.02;	author art;	state Exp;
branches;
next	1.6.6.3;

1.6.6.3
date	2003.05.19.21.49.41;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.29
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@/*	$OpenBSD: if_ie_gsc.c,v 1.28 2015/11/24 13:33:18 mpi Exp $	*/

/*
 * Copyright (c) 1998-2004 Michael Shalayeff
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR OR HIS RELATIVES BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * References:
 * 1. 82596DX and 82596SX High-Performance 32-bit Local Area Network Coprocessor
 *    Intel Corporation, November 1996, Order Number: 290219-006
 *
 * 2. 712 I/O Subsystem ERS Rev 1.0
 *    Hewlett-Packard, June 17 1992, Dwg No. A-A2263-66510-31
 */
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/socket.h>
#include <sys/sockio.h>

#include <net/if.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <machine/bus.h>
#include <machine/intr.h>
#include <machine/iomod.h>
#include <machine/autoconf.h>

#include <hppa/dev/cpudevs.h>
#include <hppa/gsc/gscbusvar.h>

#include <dev/ic/i82596reg.h>
#include <dev/ic/i82596var.h>

#define	IEGSC_GECKO	IEMD_FLAG0

struct ie_gsc_regs {
	u_int32_t	ie_reset;
	u_int32_t	ie_port;
	u_int32_t	ie_attn;
};

#define	IE_SIZE	0x8000

int	ie_gsc_probe(struct device *, void *, void *);
void	ie_gsc_attach(struct device *, struct device *, void *);

struct cfattach ie_gsc_ca = {
	sizeof(struct ie_softc), ie_gsc_probe, ie_gsc_attach
};

static uint64_t ie_gsc_media[] = {
	IFM_ETHER | IFM_10_2,
};
#define	IE_NMEDIA	(sizeof(ie_gsc_media) / sizeof(ie_gsc_media[0]))

char *ie_mem;

void ie_gsc_reset(struct ie_softc *sc, int what);
void ie_gsc_attend(struct ie_softc *sc);
void ie_gsc_run(struct ie_softc *sc);
void ie_gsc_port(struct ie_softc *sc, u_int);
#ifdef USELEDS
int ie_gsc_intrhook(struct ie_softc *sc, int what);
#endif
u_int16_t ie_gsc_read16(struct ie_softc *sc, int offset);
void ie_gsc_write16(struct ie_softc *sc, int offset, u_int16_t v);
void ie_gsc_write24(struct ie_softc *sc, int offset, int addr);
void ie_gsc_memcopyin(struct ie_softc *sc, void *p, int offset, size_t);
void ie_gsc_memcopyout(struct ie_softc *sc, const void *p, int, size_t);


void
ie_gsc_reset(sc, what)
	struct ie_softc *sc;
	int what;
{
	volatile struct ie_gsc_regs *r = (struct ie_gsc_regs *)sc->ioh;
	int i;

	r->ie_reset = 0;
	/*
	 * per [2] 4.6.2.1
	 * delay for 10 system clocks + 5 transmit clocks,
	 * NB: works for system clocks over 10MHz
	 */
	DELAY(1000);

	switch (what) {
	case IE_CHIP_PROBE:
		break;

	case IE_CARD_RESET:
		/*
		 * after the hardware reset:
		 * inform i825[89]6 about new SCP address,
		 * maddr must be at least 16-byte aligned
		 */
		ie_gsc_port(sc, IE_PORT_SCP);
		ie_gsc_attend(sc);

		for (i = 9000; i-- && ie_gsc_read16(sc, IE_ISCP_BUSY(sc->iscp));
		     DELAY(100))
			pdcache(0, sc->sc_maddr + sc->iscp, IE_ISCP_SZ);

#ifdef I82596_DEBUG
		if (i < 0) {
			printf("timeout for PORT command (%x)%s\n",
			       ie_gsc_read16(sc, IE_ISCP_BUSY(sc->iscp)),
			       (sc->sc_flags & IEGSC_GECKO)? " on gecko":"");
			return;
		}
#endif
		break;
	}
}

void
ie_gsc_attend(sc)
	struct ie_softc *sc;
{
	volatile struct ie_gsc_regs *r = (struct ie_gsc_regs *)sc->ioh;

	fdcache(0, (vaddr_t)ie_mem, IE_SIZE);
	DELAY(1);
	r->ie_attn = 0;
	DELAY(1);
}

void
ie_gsc_run(sc)
	struct ie_softc *sc;
{
}

void
ie_gsc_port(sc, cmd)
	struct ie_softc *sc;
	u_int cmd;
{
	switch (cmd) {
	case IE_PORT_RESET:
		cmd = 0;
		break;
	case IE_PORT_TEST:
		cmd = ((u_int)sc->sc_maddr + sc->scp) | 1;
		break;
	case IE_PORT_SCP:
		cmd = ((u_int)sc->sc_maddr + sc->scp) | 2;
		break;
	case IE_PORT_DUMP:
		cmd = 3;
		break;
	}

	if (sc->sc_flags & IEGSC_GECKO) {
		volatile struct ie_gsc_regs *r = (struct ie_gsc_regs *)sc->ioh;
		r->ie_port = cmd & 0xffff;
		DELAY(1000);
		r->ie_port = cmd >> 16;
		DELAY(1000);
	} else {
		volatile struct ie_gsc_regs *r = (struct ie_gsc_regs *)sc->ioh;
		r->ie_port = cmd >> 16;
		DELAY(1000);
		r->ie_port = cmd & 0xffff;
		DELAY(1000);
	}
}

#ifdef USELEDS
int
ie_gsc_intrhook(sc, where)
	struct ie_softc *sc;
	int where;
{
	switch (where) {
	case IE_INTR_ENRCV:
		ledctl(PALED_NETRCV, 0, 0);
		break;
	case IE_INTR_ENSND:
		ledctl(PALED_NETSND, 0, 0);
		break;
	case IE_INTR_EXIT:
	case IE_INTR_LOOP:
		fdcache(0, (vaddr_t)ie_mem, IE_SIZE);
		break;
	}
	return 0;
}
#endif

u_int16_t
ie_gsc_read16(sc, offset)
	struct ie_softc *sc;
	int offset;
{
	volatile u_int16_t *addr = (volatile u_int16_t *)(sc->bh + offset);

	asm volatile ("fdc	%%r0(%%sr0, %0)" :: "r" (addr));
	return *addr;
}

void
ie_gsc_write16(sc, offset, v)
	struct ie_softc *sc;
	int offset;
	u_int16_t v;
{
	volatile u_int16_t *addr = (volatile u_int16_t *)(sc->bh + offset);

	*addr = v;
	asm volatile ("fdc	%%r0(%%sr0, %0)" :: "r" (addr));
}

void
ie_gsc_write24(sc, offset, v)
	struct ie_softc *sc;
	int offset;
	int v;
{
	volatile u_int16_t *addr = (volatile u_int16_t *)(sc->bh + offset);

	addr[0] = (v      ) & 0xffff;
	addr[1] = (v >> 16) & 0xffff;
	asm volatile ("fdc	%%r0(%%sr0, %0)" :: "r" (addr+0));
	asm volatile ("fdc	%%r0(%%sr0, %0)" :: "r" (addr+1));
}

void
ie_gsc_memcopyin(sc, p, offset, size)
	struct ie_softc	*sc;
	void *p;
	int offset;
	size_t size;
{
	pdcache(0, sc->bh + offset, size);
	bcopy ((void *)((u_long)sc->bh + offset), p, size);
}

void
ie_gsc_memcopyout(sc, p, offset, size)
	struct ie_softc	*sc;
	const void *p;
	int offset;
	size_t size;
{
	bcopy (p, (void *)((u_long)sc->bh + offset), size);
	fdcache(0, sc->bh + offset, size);
}

int
ie_gsc_probe(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	struct gsc_attach_args *ga = aux;

	if (ga->ga_type.iodc_type != HPPA_TYPE_FIO ||
	    (ga->ga_type.iodc_sv_model != HPPA_FIO_LAN &&
	     ga->ga_type.iodc_sv_model != HPPA_FIO_GLAN))
		return 0;

	return 1;
}

void
ie_gsc_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct pdc_lan_station_id pdc_mac PDC_ALIGNMENT;
	struct ie_softc *sc = (struct ie_softc *)self;
	struct gsc_attach_args *ga = aux;
	/*bus_dma_segment_t seg;
	int rseg;*/
	int rv;
#ifdef PMAPDEBUG
	extern int pmapdebug;
	int opmapdebug = pmapdebug;
	pmapdebug = 0;
#endif

	sc->iot = sc->bt = ga->ga_iot;
	if (bus_space_map(sc->iot, ga->ga_hpa, IOMOD_HPASIZE, 0, &sc->ioh)) {
		printf(": can't map IO space\n");
		return;
	}

	if (ga->ga_type.iodc_sv_model == HPPA_FIO_GLAN)
		sc->sc_flags |= IEGSC_GECKO;

	sc->sc_msize = IE_SIZE;
	/* XXX memory must be under 16M until the mi part is fixed */
#if 0
	if (bus_dmamem_alloc(ga->ga_dmatag, sc->sc_msize, NBPG, 0,
			     &seg, 1, &rseg, BUS_DMA_NOWAIT)) {
		printf (": cannot allocate %d bytes of DMA memory\n",
			sc->sc_msize);
		return;
	}
	if (bus_dmamem_map(ga->ga_dmatag, &seg, rseg, sc->sc_msize,
			   (caddr_t *)&sc->bh, BUS_DMA_NOWAIT)) {
		printf (": cannot map DMA memory\n");
		bus_dmamem_free(ga->ga_dmatag, &seg, rseg);
		return;
	}

	bzero((void *)sc->bh, sc->sc_msize);
	sc->sc_maddr = kvtop((caddr_t)sc->bh);

#else
	sc->bh = (u_int)ie_mem;
	sc->sc_maddr = sc->bh;
#endif
	sc->sysbus = 0x40 | IE_SYSBUS_82586 | IE_SYSBUS_INTLOW | IE_SYSBUS_TRG | IE_SYSBUS_BE;

	sc->do_xmitnopchain = 0;
	sc->hwreset = ie_gsc_reset;
	sc->chan_attn = ie_gsc_attend;
	sc->port = ie_gsc_port;
	sc->hwinit = ie_gsc_run;
	sc->memcopyout = ie_gsc_memcopyout;
	sc->memcopyin = ie_gsc_memcopyin;
	sc->ie_bus_read16 = ie_gsc_read16;
	sc->ie_bus_write16 = ie_gsc_write16;
	sc->ie_bus_write24 = ie_gsc_write24;
#ifdef USELEDS
	sc->intrhook = ie_gsc_intrhook;
#else
	sc->intrhook = NULL;
#endif

#ifdef I82596_DEBUG
	printf(" mem %x[%p]/%x", sc->bh, sc->sc_maddr, sc->sc_msize);
	sc->sc_debug = IED_ALL;
#endif
	rv = i82596_probe(sc);
	if (!rv) {
		/*bus_dmamem_free(ga->ga_dmatag, &seg, sc->sc_msize);*/
	}
#ifdef PMAPDEBUG
	pmapdebug = opmapdebug;
#endif
	if (!rv) {
		printf("\n");
		return;
	}

	if (pdc_call((iodcio_t)pdc, 0, PDC_LAN_STATION_ID,
		     PDC_LAN_STATION_ID_READ, &pdc_mac, ga->ga_hpa) < 0)
		bcopy((void *)ASP_PROM, sc->sc_arpcom.ac_enaddr,
		      ETHER_ADDR_LEN);
	else
		bcopy(pdc_mac.addr, sc->sc_arpcom.ac_enaddr, ETHER_ADDR_LEN);

	printf(":");

	sc->iscp = 0;
	sc->scp = 32;
	sc->scb = 94;
	sc->buf_area = 256;
	sc->buf_area_sz = sc->sc_msize - sc->buf_area;
	sc->sc_type = sc->sc_flags & IEGSC_GECKO? "LASI/i82596CA" : "i82596DX";
	sc->sc_vers = ga->ga_type.iodc_model * 10 + ga->ga_type.iodc_sv_rev;
	i82596_attach(sc, sc->sc_type, (char *)sc->sc_arpcom.ac_enaddr,
		      ie_gsc_media, IE_NMEDIA, ie_gsc_media[0]);

	sc->sc_ih = gsc_intr_establish((struct gsc_softc *)parent,
	    ga->ga_irq, IPL_NET, i82596_intr, sc, sc->sc_dev.dv_xname);
}
@


1.28
log
@The only network driver needing <net/if_types.h> is upl(4) for IFT_OTHER.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie_gsc.c,v 1.27 2015/09/14 11:18:48 stsp Exp $	*/
a43 1
#include <net/if_dl.h>
@


1.27
log
@Fix more ifmedia64 fallout in the kernel. It's hiding everywhere...
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie_gsc.c,v 1.26 2014/03/29 18:09:29 guenther Exp $	*/
a44 1
#include <net/if_types.h>
@


1.26
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie_gsc.c,v 1.25 2004/10/28 19:13:30 mickey Exp $	*/
d79 1
a79 1
static int ie_gsc_media[] = {
@


1.25
log
@need to map the regs though lasi used to save us before
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie_gsc.c,v 1.24 2004/04/07 18:24:19 mickey Exp $	*/
d227 1
a227 1
	asm __volatile ("fdc	%%r0(%%sr0, %0)" :: "r" (addr));
d240 1
a240 1
	asm __volatile ("fdc	%%r0(%%sr0, %0)" :: "r" (addr));
d253 2
a254 2
	asm __volatile ("fdc	%%r0(%%sr0, %0)" :: "r" (addr+0));
	asm __volatile ("fdc	%%r0(%%sr0, %0)" :: "r" (addr+1));
@


1.24
log
@update copyright; miod@@ is fine w/ files where he holds it too
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie_gsc.c,v 1.23 2004/02/13 21:28:19 mickey Exp $	*/
d311 6
a344 2
	sc->iot = sc->bt = ga->ga_iot;
	sc->ioh = ga->ga_hpa;
@


1.23
log
@order irq,pri args to gsc_intr_establish() the way less confusing compared to other trolley busses around ...
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie_gsc.c,v 1.22 2003/10/27 17:22:58 mickey Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998,1999 Michael Shalayeff
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Michael Shalayeff.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d19 8
a26 7
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF MIND,
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@


1.22
log
@typos; fom bruno@@rohee.com
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie_gsc.c,v 1.21 2003/08/07 19:47:33 mickey Exp $	*/
d396 2
a397 2
	sc->sc_ih = gsc_intr_establish((struct gsc_softc *)parent, IPL_NET,
	    ga->ga_irq, i82596_intr, sc, sc->sc_dev.dv_xname);
@


1.21
log
@make all intr_establish take the same last arg for name
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie_gsc.c,v 1.20 2003/08/03 21:28:24 mickey Exp $	*/
d34 2
a35 2
 * Referencies:
 * 1. 82596DX and 82596SX High-Perfomance 32-bit Local Area Network Coprocessor
@


1.20
log
@oops
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie_gsc.c,v 1.19 2003/08/03 19:03:50 mickey Exp $	*/
d397 1
a397 1
	    ga->ga_irq, i82596_intr, sc, &sc->sc_dev);
@


1.19
log
@prefer fdc to fdce for cache flushing here
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie_gsc.c,v 1.18 2003/05/21 02:14:18 mickey Exp $	*/
d229 1
a229 1
	u_int16_t *addr = (volatile u_int16_t *)(sc->bh + offset);
d231 1
a231 1
	asm __volatile ("fdc	0(sr0, %0)" :: "r" (addr));
d241 1
a241 1
	u_int16_t *addr = (volatile u_int16_t *)(sc->bh + offset);
d244 1
a244 1
	asm __volatile ("fdc	0(sr0, %0)" :: "r" (addr));
d248 1
a248 1
ie_gsc_write24(sc, offset, addr)
d251 1
a251 1
	int addr;
d253 1
a253 1
	u_int16_t *addr = (volatile u_int16_t *)(sc->bh + offset);
d255 4
a258 4
	addr[0] = (addr      ) & 0xffff;
	addr[1] = (addr >> 16) & 0xffff;
	asm __volatile ("fdc	0(sr0, %0)" :: "r" (addr+0));
	asm __volatile ("fdc	0(sr0, %0)" :: "r" (addr+1));
@


1.18
log
@when looping for more work in the interrupt handler also flush the cache
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie_gsc.c,v 1.17 2003/01/25 07:22:01 jason Exp $	*/
d229 4
a232 2
	fdce(0, sc->bh + offset);
	return *(volatile u_int16_t *)(sc->bh + offset);
d241 4
a244 2
	*(volatile u_int16_t *)(sc->bh + offset) = v;
	fdce(0, sc->bh + offset);
d253 6
a258 4
	*(volatile u_int16_t *)(sc->bh + offset + 0) = (addr      ) & 0xffff;
	*(volatile u_int16_t *)(sc->bh + offset + 2) = (addr >> 16) & 0xffff;
	fdce(0, sc->bh + offset + 0);
	fdce(0, sc->bh + offset + 2);
@


1.17
log
@De-"register"
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie_gsc.c,v 1.16 2002/12/14 23:00:48 deraadt Exp $	*/
d217 1
d391 1
a391 1
				       ga->ga_irq, i82596_intr,sc,&sc->sc_dev);
@


1.16
log
@remove extra space in dmesg
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie_gsc.c,v 1.15 2002/12/11 06:02:23 mickey Exp $	*/
d109 2
a110 2
	register volatile struct ie_gsc_regs *r = (struct ie_gsc_regs *)sc->ioh;
	register int i;
d153 1
a153 1
	register volatile struct ie_gsc_regs *r = (struct ie_gsc_regs *)sc->ioh;
d188 1
a188 1
		register volatile struct ie_gsc_regs *r = (struct ie_gsc_regs *)sc->ioh;
d194 1
a194 1
		register volatile struct ie_gsc_regs *r = (struct ie_gsc_regs *)sc->ioh;
d281 1
a281 1
	register struct gsc_attach_args *ga = aux;
d297 2
a298 2
	register struct ie_softc *sc = (struct ie_softc *)self;
	register struct gsc_attach_args *ga = aux;
@


1.15
log
@delay(1) is enough on attention
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie_gsc.c,v 1.14 2002/10/13 14:15:35 mickey Exp $	*/
d377 1
a377 1
	printf(": ");
@


1.14
log
@split the scp/iscp/scb between the cache lines, make the leds blink better
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie_gsc.c,v 1.13 2002/07/17 22:18:38 mickey Exp $	*/
d156 1
a156 1
	DELAY(10);
d158 1
a158 1
	DELAY(10);
@


1.13
log
@when bailing out from attach, -- pretend to be nice and place a backslashan
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie_gsc.c,v 1.12 2002/03/18 19:13:28 mickey Exp $	*/
d112 8
a121 1
		r->ie_reset = 0;
a124 9
		r->ie_reset = 0;

		/*
		 * per [2] 4.6.2.1
		 * delay for 10 system clocks + 5 transmit clocks,
		 * NB: works for system clocks over 10MHz
		 */
		DELAY(1000);

d156 1
d158 1
d209 2
a210 2
	case IE_INTR_ENTER:
		/* turn it on */
d212 2
a213 2
	case IE_INTR_LOOP:
		/* quick drop and raise */
d216 1
a216 1
		/* drop it */
d228 1
a228 1
	pdcache(0, sc->bh + offset, 2);
d239 1
a239 1
	fdcache(0, sc->bh + offset, 2);
d250 2
a251 1
	fdcache(0, sc->bh + offset, 4);
a275 1

d380 3
a382 3
	sc->scp = sc->iscp + IE_ISCP_SZ;
	sc->scb = sc->scp + IE_SCP_SZ;
	sc->buf_area = sc->scb + 256;
@


1.12
log
@kill debugging printf
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie_gsc.c,v 1.11 2002/03/15 21:44:18 mickey Exp $	*/
d365 2
a366 1
	if (!rv)
d368 1
@


1.11
log
@rewrite a pmap to use multilevel page tables.
lower 12 bits contain the perms, no unused bits left,
but a couple for off-tlb use (as the ref implemented now).
do not use the hvt, which might get some use later
if proven to speed thigs up, tlb handlers would po
another dozen of insns though, but if that's worth its...
move on the data seg and map kernel text rdonly (idea form fredette),
since all of the page0 mods done before that we are all fine
except for some viper fluff, but later w/ that.
this also picks up a bit more of ddb magic for bpt and ss.
tlb handlers can use a little bit more of attention,
but things, visually, seem to be much faster already, --
sorry, no benchmarks for now.

* effort sponsored in part by the `henry st. old ale house'
* and mr.pete and mr.lee in particular in thier generous entrirety.
* the proj took a little more that 72man*h as it was expected,
* but within murhy's law estimations.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie_gsc.c,v 1.10 2002/03/14 01:26:31 millert Exp $	*/
a330 1
	printf("%x ", ie_mem);
@


1.10
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie_gsc.c,v 1.9 2002/02/11 21:20:51 mickey Exp $	*/
d88 1
a88 1
static char mem[IE_SIZE+16];
d157 1
a157 1
	fdcache(0, (vaddr_t)&mem, sizeof(mem));
d331 2
a332 2
	bzero(mem, sizeof(mem));
	sc->bh = ((u_int)&mem + 15) & ~0xf;
@


1.9
log
@extend the hackery to not use kvtop
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie_gsc.c,v 1.8 2002/02/06 19:07:04 mickey Exp $	*/
d76 2
a77 2
int	ie_gsc_probe __P((struct device *, void *, void *));
void	ie_gsc_attach __P((struct device *, struct device *, void *));
d90 4
a93 4
void ie_gsc_reset __P((struct ie_softc *sc, int what));
void ie_gsc_attend __P((struct ie_softc *sc));
void ie_gsc_run __P((struct ie_softc *sc));
void ie_gsc_port __P((struct ie_softc *sc, u_int));
d95 1
a95 1
int ie_gsc_intrhook __P((struct ie_softc *sc, int what));
d97 5
a101 5
u_int16_t ie_gsc_read16 __P((struct ie_softc *sc, int offset));
void ie_gsc_write16 __P((struct ie_softc *sc, int offset, u_int16_t v));
void ie_gsc_write24 __P((struct ie_softc *sc, int offset, int addr));
void ie_gsc_memcopyin __P((struct ie_softc *sc, void *p, int offset, size_t));
void ie_gsc_memcopyout __P((struct ie_softc *sc, const void *p, int, size_t));
@


1.8
log
@remove dangling spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie_gsc.c,v 1.7 2002/02/03 01:46:46 mickey Exp $	*/
d333 1
a334 1
	sc->sc_maddr = kvtop((caddr_t)sc->bh);
@


1.7
log
@flush cache on attention
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie_gsc.c,v 1.6 2001/01/12 22:57:04 mickey Exp $	*/
d111 1
a111 1
	
d234 1
a234 1
	struct ie_softc *sc;	
d244 1
a244 1
	struct ie_softc *sc;	
@


1.6
log
@this is even uglier hack, but it also works; theo did not help (;
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie_gsc.c,v 1.5 1999/11/26 17:47:42 mickey Exp $	*/
d88 2
d157 1
a295 1
	static char mem[IE_SIZE+16];
d312 1
d339 1
d381 1
a381 1
	sc->buf_area = sc->scb + IE_SCB_SZ;
@


1.6.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie_gsc.c,v 1.6 2001/01/12 22:57:04 mickey Exp $	*/
d76 2
a77 2
int	ie_gsc_probe(struct device *, void *, void *);
void	ie_gsc_attach(struct device *, struct device *, void *);
d88 4
a91 6
char *ie_mem;

void ie_gsc_reset(struct ie_softc *sc, int what);
void ie_gsc_attend(struct ie_softc *sc);
void ie_gsc_run(struct ie_softc *sc);
void ie_gsc_port(struct ie_softc *sc, u_int);
d93 1
a93 1
int ie_gsc_intrhook(struct ie_softc *sc, int what);
d95 5
a99 5
u_int16_t ie_gsc_read16(struct ie_softc *sc, int offset);
void ie_gsc_write16(struct ie_softc *sc, int offset, u_int16_t v);
void ie_gsc_write24(struct ie_softc *sc, int offset, int addr);
void ie_gsc_memcopyin(struct ie_softc *sc, void *p, int offset, size_t);
void ie_gsc_memcopyout(struct ie_softc *sc, const void *p, int, size_t);
d109 1
a109 1

a154 1
	fdcache(0, (vaddr_t)ie_mem, IE_SIZE);
d231 1
a231 1
	struct ie_softc *sc;
d241 1
a241 1
	struct ie_softc *sc;
d293 1
a309 1
	/* XXX memory must be under 16M until the mi part is fixed */
d328 2
a329 2
	sc->bh = (u_int)ie_mem;
	sc->sc_maddr = sc->bh;
d331 1
a335 1
	sc->do_xmitnopchain = 0;
d377 1
a377 1
	sc->buf_area = sc->scb + 256;
@


1.6.6.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie_gsc.c,v 1.6.6.1 2002/06/11 03:35:36 art Exp $	*/
a111 8
	r->ie_reset = 0;
	/*
	 * per [2] 4.6.2.1
	 * delay for 10 system clocks + 5 transmit clocks,
	 * NB: works for system clocks over 10MHz
	 */
	DELAY(1000);

d114 1
d118 9
a157 1
	DELAY(10);
a158 1
	DELAY(10);
d209 2
a210 2
	case IE_INTR_ENRCV:
		ledctl(PALED_NETRCV, 0, 0);
d212 2
a213 2
	case IE_INTR_ENSND:
		ledctl(PALED_NETSND, 0, 0);
d216 1
a216 1
	case IE_INTR_LOOP:
d228 1
a228 1
	fdce(0, sc->bh + offset);
d239 1
a239 1
	fdce(0, sc->bh + offset);
d250 1
a250 2
	fdce(0, sc->bh + offset + 0);
	fdce(0, sc->bh + offset + 2);
d275 1
d365 1
a365 2
	if (!rv) {
		printf("\n");
a366 1
	}
d378 3
a380 3
	sc->scp = 32;
	sc->scb = 94;
	sc->buf_area = 256;
@


1.6.6.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d109 2
a110 2
	volatile struct ie_gsc_regs *r = (struct ie_gsc_regs *)sc->ioh;
	int i;
d153 1
a153 1
	volatile struct ie_gsc_regs *r = (struct ie_gsc_regs *)sc->ioh;
d156 1
a156 1
	DELAY(1);
d158 1
a158 1
	DELAY(1);
d188 1
a188 1
		volatile struct ie_gsc_regs *r = (struct ie_gsc_regs *)sc->ioh;
d194 1
a194 1
		volatile struct ie_gsc_regs *r = (struct ie_gsc_regs *)sc->ioh;
d281 1
a281 1
	struct gsc_attach_args *ga = aux;
d297 2
a298 2
	struct ie_softc *sc = (struct ie_softc *)self;
	struct gsc_attach_args *ga = aux;
d377 1
a377 1
	printf(":");
@


1.5
log
@accomodate for mi changes
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie_gsc.c,v 1.4 1999/11/16 17:14:25 mickey Exp $	*/
d134 2
a135 1
		     DELAY(100));
d225 1
d236 1
d247 1
d257 1
d269 1
d293 1
d297 2
a298 2
	bus_dma_segment_t seg;
	int rseg;
d310 1
d327 6
a332 2
	sc->sysbus = 0x40 | IE_SYSBUS_82586 |
		       IE_SYSBUS_INTLOW | IE_SYSBUS_TRG | IE_SYSBUS_BE;
d351 4
d357 1
a357 1
		bus_dmamem_free(ga->ga_dmatag, &seg, sc->sc_msize);
a371 4
#ifdef I82596_DEBUG
	printf(" mem %x[%p]/%x", sc->bh, sc->sc_maddr, sc->sc_msize);
	sc->sc_debug = IED_ALL;
#endif
@


1.5.2.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie_gsc.c,v 1.6 2001/01/12 22:57:04 mickey Exp $	*/
d134 1
a134 2
		     DELAY(100))
			pdcache(0, sc->sc_maddr + sc->iscp, IE_ISCP_SZ);
a223 1
	pdcache(0, sc->bh + offset, 2);
a233 1
	fdcache(0, sc->bh + offset, 2);
a243 1
	fdcache(0, sc->bh + offset, 4);
a252 1
	pdcache(0, sc->bh + offset, size);
a263 1
	fdcache(0, sc->bh + offset, size);
a286 1
	static char mem[IE_SIZE+16];
d290 2
a291 2
	/*bus_dma_segment_t seg;
	int rseg;*/
a302 1
#if 0
d319 2
a320 6
#else
	bzero(mem, sizeof(mem));
	sc->bh = ((u_int)&mem + 15) & ~0xf;
#endif
	sc->sc_maddr = kvtop((caddr_t)sc->bh);
	sc->sysbus = 0x40 | IE_SYSBUS_82586 | IE_SYSBUS_INTLOW | IE_SYSBUS_TRG | IE_SYSBUS_BE;
a338 4
#ifdef I82596_DEBUG
	printf(" mem %x[%p]/%x", sc->bh, sc->sc_maddr, sc->sc_msize);
	sc->sc_debug = IED_ALL;
#endif
d341 1
a341 1
		/*bus_dmamem_free(ga->ga_dmatag, &seg, sc->sc_msize);*/
d356 4
@


1.5.2.2
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a87 2
static char mem[IE_SIZE+16];

d109 1
a109 1

a154 1
	fdcache(0, (vaddr_t)&mem, sizeof(mem));
d231 1
a231 1
	struct ie_softc *sc;
d241 1
a241 1
	struct ie_softc *sc;
d293 1
a309 1
	/* XXX memory must be under 16M until the mi part is fixed */
a329 1
	sc->sc_maddr = sc->bh;
d331 1
a335 1
	sc->do_xmitnopchain = 0;
d377 1
a377 1
	sc->buf_area = sc->scb + 256;
@


1.5.2.3
log
@Merge in -current from about a week ago
@
text
@d76 2
a77 2
int	ie_gsc_probe(struct device *, void *, void *);
void	ie_gsc_attach(struct device *, struct device *, void *);
d88 1
a88 1
char *ie_mem;
d90 4
a93 4
void ie_gsc_reset(struct ie_softc *sc, int what);
void ie_gsc_attend(struct ie_softc *sc);
void ie_gsc_run(struct ie_softc *sc);
void ie_gsc_port(struct ie_softc *sc, u_int);
d95 1
a95 1
int ie_gsc_intrhook(struct ie_softc *sc, int what);
d97 5
a101 5
u_int16_t ie_gsc_read16(struct ie_softc *sc, int offset);
void ie_gsc_write16(struct ie_softc *sc, int offset, u_int16_t v);
void ie_gsc_write24(struct ie_softc *sc, int offset, int addr);
void ie_gsc_memcopyin(struct ie_softc *sc, void *p, int offset, size_t);
void ie_gsc_memcopyout(struct ie_softc *sc, const void *p, int, size_t);
d157 1
a157 1
	fdcache(0, (vaddr_t)ie_mem, IE_SIZE);
d331 2
a332 1
	sc->bh = (u_int)ie_mem;
@


1.5.2.4
log
@Sync the SMP branch with 3.3
@
text
@d109 2
a110 10
	volatile struct ie_gsc_regs *r = (struct ie_gsc_regs *)sc->ioh;
	int i;

	r->ie_reset = 0;
	/*
	 * per [2] 4.6.2.1
	 * delay for 10 system clocks + 5 transmit clocks,
	 * NB: works for system clocks over 10MHz
	 */
	DELAY(1000);
d114 1
d118 9
d155 1
a155 1
	volatile struct ie_gsc_regs *r = (struct ie_gsc_regs *)sc->ioh;
a157 1
	DELAY(1);
a158 1
	DELAY(1);
d188 1
a188 1
		volatile struct ie_gsc_regs *r = (struct ie_gsc_regs *)sc->ioh;
d194 1
a194 1
		volatile struct ie_gsc_regs *r = (struct ie_gsc_regs *)sc->ioh;
d209 2
a210 2
	case IE_INTR_ENRCV:
		ledctl(PALED_NETRCV, 0, 0);
d212 2
a213 2
	case IE_INTR_ENSND:
		ledctl(PALED_NETSND, 0, 0);
d216 1
a216 1
	case IE_INTR_LOOP:
d228 1
a228 1
	fdce(0, sc->bh + offset);
d239 1
a239 1
	fdce(0, sc->bh + offset);
d250 1
a250 2
	fdce(0, sc->bh + offset + 0);
	fdce(0, sc->bh + offset + 2);
d275 1
d281 1
a281 1
	struct gsc_attach_args *ga = aux;
d297 2
a298 2
	struct ie_softc *sc = (struct ie_softc *)self;
	struct gsc_attach_args *ga = aux;
d365 1
a365 2
	if (!rv) {
		printf("\n");
a366 1
	}
d375 1
a375 1
	printf(":");
d378 3
a380 3
	sc->scp = 32;
	sc->scb = 94;
	sc->buf_area = 256;
@


1.5.2.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie_gsc.c,v 1.5.2.4 2003/03/27 23:26:53 niklas Exp $	*/
a216 1
		fdcache(0, (vaddr_t)ie_mem, IE_SIZE);
d390 1
a390 1
	    ga->ga_irq, i82596_intr, sc, &sc->sc_dev);
@


1.5.2.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d34 2
a35 2
 * References:
 * 1. 82596DX and 82596SX High-Performance 32-bit Local Area Network Coprocessor
d229 2
a230 4
	volatile u_int16_t *addr = (volatile u_int16_t *)(sc->bh + offset);

	asm __volatile ("fdc	%%r0(%%sr0, %0)" :: "r" (addr));
	return *addr;
d239 2
a240 4
	volatile u_int16_t *addr = (volatile u_int16_t *)(sc->bh + offset);

	*addr = v;
	asm __volatile ("fdc	%%r0(%%sr0, %0)" :: "r" (addr));
d244 1
a244 1
ie_gsc_write24(sc, offset, v)
d247 1
a247 1
	int v;
d249 4
a252 6
	volatile u_int16_t *addr = (volatile u_int16_t *)(sc->bh + offset);

	addr[0] = (v      ) & 0xffff;
	addr[1] = (v >> 16) & 0xffff;
	asm __volatile ("fdc	%%r0(%%sr0, %0)" :: "r" (addr+0));
	asm __volatile ("fdc	%%r0(%%sr0, %0)" :: "r" (addr+1));
d391 1
a391 1
	    ga->ga_irq, i82596_intr, sc, sc->sc_dev.dv_xname);
@


1.5.2.7
log
@Merge with the trunk
@
text
@d4 1
a4 1
 * Copyright (c) 1998-2004 Michael Shalayeff
d15 5
d24 7
a30 8
 * IN NO EVENT SHALL THE AUTHOR OR HIS RELATIVES BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
d396 2
a397 2
	sc->sc_ih = gsc_intr_establish((struct gsc_softc *)parent,
	    ga->ga_irq, IPL_NET, i82596_intr, sc, sc->sc_dev.dv_xname);
@


1.4
log
@typo in doc ref
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie_gsc.c,v 1.3 1999/08/16 02:48:39 mickey Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998 Michael Shalayeff
d26 2
a27 2
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
a70 4
#define	IE_PORT_RESET	0
#define	IE_PORT_TEST	1
#define	IE_PORT_SCP	2
#define	IE_PORT_DUMP	3
d91 1
d107 1
a107 2
	register volatile struct ie_gsc_regs *r = sc->sc_reg;
	register u_int32_t a;
d111 1
a111 1
	case CHIP_PROBE:
d115 1
a115 1
	case CARD_RESET:
d130 1
a130 14
		a = ((u_int32_t)sc->sc_maddr + sc->scp) | IE_PORT_SCP;
		if (sc->sc_flags & IEGSC_GECKO) {
			register volatile struct ie_gsc_regs *r = sc->sc_reg;
			r->ie_port = a & 0xffff;
			DELAY(1000);
			r->ie_port = a >> 16;
			DELAY(1000);
		} else {
			register volatile struct ie_gsc_regs *r = sc->sc_reg;
			r->ie_port = a >> 16;
			DELAY(1000);
			r->ie_port = a & 0xffff;
			DELAY(1000);
		}
d152 1
a152 1
	register volatile struct ie_gsc_regs *r = sc->sc_reg;
d163 35
d205 1
a205 1
	case INTR_ENTER:
d208 1
a208 1
	case INTR_LOOP:
d211 1
a211 1
	case INTR_EXIT:
a289 2
	register u_int32_t a;
	register int i;
d292 1
a301 23
	if ((i = pdc_call((iodcio_t)pdc, 0, PDC_LAN_STATION_ID,
			  PDC_LAN_STATION_ID_READ, &pdc_mac, ga->ga_hpa)) < 0)
		bcopy ((void *)ASP_PROM, sc->sc_arpcom.ac_enaddr,
		       ETHER_ADDR_LEN);
	else
		bcopy (pdc_mac.addr, sc->sc_arpcom.ac_enaddr, ETHER_ADDR_LEN);

	sc->bt = ga->ga_iot;
	sc->sc_reg = (struct ie_gsc_regs *)ga->ga_hpa;
	sc->hwreset = ie_gsc_reset;
	sc->chan_attn = ie_gsc_attend;
	sc->hwinit = ie_gsc_run;
#ifdef USELEDS
	sc->intrhook = ie_gsc_intrhook;
#else
	sc->intrhook = NULL;
#endif
	sc->memcopyout = ie_gsc_memcopyout;
	sc->memcopyin = ie_gsc_memcopyin;
	sc->ie_bus_read16 = ie_gsc_read16;
	sc->ie_bus_write16 = ie_gsc_write16;
	sc->ie_bus_write24 = ie_gsc_write24;

d319 2
a320 1
	printf (": mem %x[%p]/%x", sc->bh, sc->sc_maddr, sc->sc_msize);
d322 16
a337 5
	sc->iscp = 0;
	sc->scp = sc->iscp + IE_ISCP_SZ;
	sc->scb = sc->scp + IE_SCP_SZ;
	sc->buf_area = sc->scb + IE_SCB_SZ;
	sc->buf_area_sz = sc->sc_msize - sc->buf_area;
d339 3
a341 14
	a = ((u_int32_t)sc->sc_maddr + sc->scp) | IE_PORT_TEST;
	*(volatile int32_t *)(sc->bh + IE_SCP_TEST(sc->scp)) = -1;
	if (sc->sc_flags & IEGSC_GECKO) {
		register volatile struct ie_gsc_regs *r = sc->sc_reg;
		r->ie_port = a & 0xffff;
		DELAY(1000);
		r->ie_port = a >> 16;
		DELAY(1000);
	} else {
		register volatile struct ie_gsc_regs *r = sc->sc_reg;
		r->ie_port = a >> 16;
		DELAY(1000);
		r->ie_port = a & 0xffff;
		DELAY(1000);
d343 12
a354 3
	for (i = 9000; i-- && *(volatile int32_t *)
		     (sc->bh + IE_SCP_TEST(sc->scp));
	     DELAY(100));
d357 1
a357 3
	printf ("test %x:%x ", *((volatile int32_t *)(sc->bh + sc->scp)),
		*(int32_t *)(sc->bh + IE_SCP_TEST(sc->scp)));

d360 1
d362 5
a366 12
	ie_gsc_write16(sc, IE_ISCP_BUSY(sc->iscp), 1);
	ie_gsc_write16(sc, IE_ISCP_SCB(sc->iscp), sc->scb);
	ie_gsc_write24(sc, IE_ISCP_BASE(sc->iscp), sc->sc_maddr);

	ie_gsc_write24(sc, IE_SCP_ISCP(sc->scp), sc->sc_maddr + sc->iscp);
	ie_gsc_write16(sc, IE_SCP_BUS_USE(sc->scp), 0x40 | IE_SYSBUS_82586 |
		       IE_SYSBUS_INTLOW | IE_SYSBUS_TRG | IE_SYSBUS_BE);

	ie_gsc_reset(sc, CARD_RESET);
	ie_gsc_attend(sc);
	delay(100);

d368 1
a373 3
#ifdef PMAPDEBUG
	pmapdebug = opmapdebug;
#endif
@


1.3
log
@evcnt count the interrupts, also optimize diagnostic printing
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie_gsc.c,v 1.2 1999/08/14 04:08:06 mickey Exp $	*/
d39 1
a39 1
 *    Hewlwtt-Packard, June 17 1992, Dwg No. A-A2263-66510-31
@


1.2
log
@this work, smirk, rock, sock (rhymes by fries@@ ;)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ie_gsc.c,v 1.1 1999/01/03 23:59:18 mickey Exp $	*/
d376 1
a376 2
				       ga->ga_irq, i82596_intr, sc,
				       sc->sc_dev.dv_xname);
@


1.1
log
@ie driver, needs MI part, which involves sparc testing and (most likely) i386 rewrite hehe (;
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d33 8
a46 4
#include <vm/vm.h>
#include <vm/vm_kern.h>
#include <vm/pmap.h>

d63 2
a64 2
#include <dev/ic/i82586reg.h>
#include <dev/ic/i82586var.h>
d78 1
a78 6
#define	IE_SCB	0x001e
#define	IE_ISCP	0x0040
#define	IE_SCP	0x0060
#define	IE_BUF	0x1000
#define	IE_EBUF	IE_SIZE
#define	IE_SIZE	0x4000
d87 1
a87 1
static int ie_media[] = {
d90 1
a90 1
#define	IE_NMEDIA	(sizeof(ie_media) / sizeof(ie_media[0]))
a92 1
int ie_gsc_intrhook __P((struct ie_softc *sc, int what));
d95 3
d111 17
d129 34
a162 1
	r->ie_reset = 0;
d180 1
d186 11
d199 1
d206 1
a206 1
	return *(u_int16_t *)(sc->bh + offset);
d215 1
a215 1
	*(u_int16_t *)(sc->bh + offset) = v;
d224 2
a225 2
	*(u_int16_t *)(sc->bh + offset + 0) = (addr      ) & 0xffff;
	*(u_int16_t *)(sc->bh + offset + 2) = (addr >> 16) & 0xffff;
d235 1
a235 10
	register const u_int16_t *src = (void *)((u_long)sc->bh + offset);
	register u_int16_t *dst = p;
#ifdef DIAGNOSTIC
	if (size & 1)
		panic ("ie_gsc_memcopyin: odd size");
#endif
	bus_space_barrier(sc->bt, sc->bh, offset, size,
			  BUS_SPACE_BARRIER_READ);
	for (; size; size -= 2)
		*dst++ = *src++;
d245 1
a245 10
	register u_int16_t *dst = (void *)((u_long)sc->bh + offset);
	register const u_int16_t *src = p;
#ifdef DIAGNOSTIC
	if (size & 1)
		panic ("ie_gsc_memcopyout: odd size");
#endif
	for (; size; size -= 2)
		*dst++ = *src++;
	bus_space_barrier(sc->bt, sc->bh, offset, size,
			  BUS_SPACE_BARRIER_WRITE);
a254 2
	bus_space_handle_t ioh;
	int rv;
d261 1
a261 7
	if (bus_space_map(ga->ga_iot, ga->ga_hpa, IOMOD_HPASIZE, 0, &ioh))
		return 0;

	rv = 1 /* i82586_probe(ga->ga_iot, ioh) */;

	bus_space_unmap(ga->ga_iot, ioh, IOMOD_HPASIZE);
	return rv;
d274 7
d286 5
a290 8
			  PDC_LAN_STATION_ID_READ, &pdc_mac, ga->ga_hpa)) < 0){
		pdc_mac.addr[0] = ((u_int8_t *)ASP_PROM)[0];
		pdc_mac.addr[1] = ((u_int8_t *)ASP_PROM)[1];
		pdc_mac.addr[2] = ((u_int8_t *)ASP_PROM)[2];
		pdc_mac.addr[3] = ((u_int8_t *)ASP_PROM)[3];
		pdc_mac.addr[4] = ((u_int8_t *)ASP_PROM)[4];
		pdc_mac.addr[5] = ((u_int8_t *)ASP_PROM)[5];
	}
d293 1
a293 4
	if (bus_space_map(sc->bt, ga->ga_hpa, IOMOD_HPASIZE,
			  0, (bus_space_handle_t *)&sc->sc_reg))
		panic("ie_gsc_attach: couldn't map I/O ports");

d297 1
d299 3
d309 10
a318 3
	if (!(sc->bh = (bus_space_handle_t)
	      kmem_malloc(kmem_map, sc->sc_msize, 0))) {
		printf (": cannot allocate %d bytes for IO\n", IE_SIZE);
d323 1
a323 1
	sc->sc_maddr = (void *)kvtop((void *)sc->bh);
d325 1
a325 2
	printf (" irq %d: mem %p size %x\n%s: ", sc->sc_dev.dv_cfdata->cf_irq,
		sc->sc_maddr, sc->sc_msize, sc->sc_dev.dv_xname);
d327 5
a331 5
	sc->iscp = IE_ISCP;
	sc->scb = IE_SCB;
	sc->scp = IE_SCP;
	sc->buf_area = IE_BUF;
	sc->buf_area_sz = IE_EBUF - IE_BUF;
d333 2
a334 2
	a = ((u_int32_t)sc->sc_maddr + IE_SCP) | IE_PORT_TEST;
	*(int32_t *)(IE_SCP_TEST(sc->scp)) = -1;
d337 1
a337 1
		r->ie_port = a;
d345 1
a345 1
		r->ie_port = a;
d348 9
a356 7
	for (i = 900; i-- && *(int32_t *)(IE_SCP_TEST(sc->scp)); DELAY(100))
		bus_space_barrier(sc->bt, sc->bh, IE_SCP, 8,
				  BUS_SPACE_BARRIER_READ);

#ifdef I82586_DEBUG
	printf ("test %x:%x ", ((int32_t *)(sc->bh + IE_SCP))[0],
		((int32_t *)(sc->bh + IE_SCP))[1]);
d361 7
a367 25
	ie_gsc_write24(sc, IE_ISCP_BASE(sc->iscp), (u_long)sc->sc_maddr);
	bus_space_barrier(sc->bt, sc->bh, sc->iscp, IE_ISCP_SZ,
			  BUS_SPACE_BARRIER_READ);
	ie_gsc_write16(sc, IE_SCP_BUS_USE(sc->scp), 0x68);
	ie_gsc_write24(sc, IE_SCP_ISCP(sc->scp),
		       (u_long)sc->sc_maddr + sc->iscp);
	bus_space_barrier(sc->bt, sc->bh, sc->scp, IE_SCP_SZ,
			  BUS_SPACE_BARRIER_READ);

	/* inform i825[89]6 about new SCP address,
	   maddr must be at least 16-byte aligned */
	a = ((u_int32_t)sc->sc_maddr + IE_SCP) | IE_PORT_SCP;
	if (sc->sc_flags & IEGSC_GECKO) {
		register volatile struct ie_gsc_regs *r = sc->sc_reg;
		r->ie_port = a;
		DELAY(1000);
		r->ie_port = a >> 16;
		DELAY(1000);
	} else {
		register volatile struct ie_gsc_regs *r = sc->sc_reg;
		r->ie_port = a >> 16;
		DELAY(1000);
		r->ie_port = a;
		DELAY(1000);
	}
d369 1
d371 9
a379 14
	for (i = 900; i-- &&
		     ie_gsc_read16(sc, IE_ISCP_BUSY(sc->iscp)); DELAY(100))
		bus_space_barrier(sc->bt, sc->bh, IE_ISCP_BUSY(sc->iscp), 2,
				  BUS_SPACE_BARRIER_READ);

#ifdef I82586_DEBUG
	if (i < 0) {
		printf("timeout for PORT command (%x)%s\n",
		       ie_gsc_read16(sc, IE_ISCP_BUSY(sc->iscp)),
		       (sc->sc_flags & IEGSC_GECKO)? " on gecko":"");
		return;
	}

	sc->sc_debug = IED_ALL;
a380 7

	i82586_attach(sc, ga->ga_name, pdc_mac.addr,
		      ie_media, IE_NMEDIA, ie_media[0]);

	gsc_intr_establish((struct gsc_softc *)parent,
			   sc->sc_dev.dv_cfdata->cf_irq,
			   IPL_NET, i82586_intr, sc, sc->sc_dev.dv_xname);
a381 2


@

