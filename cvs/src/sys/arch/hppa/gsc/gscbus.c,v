head	1.30;
access;
symbols
	OPENBSD_6_2_BASE:1.30
	OPENBSD_6_1:1.30.0.28
	OPENBSD_6_1_BASE:1.30
	OPENBSD_6_0:1.30.0.24
	OPENBSD_6_0_BASE:1.30
	OPENBSD_5_9:1.30.0.20
	OPENBSD_5_9_BASE:1.30
	OPENBSD_5_8:1.30.0.22
	OPENBSD_5_8_BASE:1.30
	OPENBSD_5_7:1.30.0.14
	OPENBSD_5_7_BASE:1.30
	OPENBSD_5_6:1.30.0.18
	OPENBSD_5_6_BASE:1.30
	OPENBSD_5_5:1.30.0.16
	OPENBSD_5_5_BASE:1.30
	OPENBSD_5_4:1.30.0.12
	OPENBSD_5_4_BASE:1.30
	OPENBSD_5_3:1.30.0.10
	OPENBSD_5_3_BASE:1.30
	OPENBSD_5_2:1.30.0.8
	OPENBSD_5_2_BASE:1.30
	OPENBSD_5_1_BASE:1.30
	OPENBSD_5_1:1.30.0.6
	OPENBSD_5_0:1.30.0.4
	OPENBSD_5_0_BASE:1.30
	OPENBSD_4_9:1.30.0.2
	OPENBSD_4_9_BASE:1.30
	OPENBSD_4_8:1.29.0.2
	OPENBSD_4_8_BASE:1.29
	OPENBSD_4_7:1.27.0.18
	OPENBSD_4_7_BASE:1.27
	OPENBSD_4_6:1.27.0.20
	OPENBSD_4_6_BASE:1.27
	OPENBSD_4_5:1.27.0.16
	OPENBSD_4_5_BASE:1.27
	OPENBSD_4_4:1.27.0.14
	OPENBSD_4_4_BASE:1.27
	OPENBSD_4_3:1.27.0.12
	OPENBSD_4_3_BASE:1.27
	OPENBSD_4_2:1.27.0.10
	OPENBSD_4_2_BASE:1.27
	OPENBSD_4_1:1.27.0.8
	OPENBSD_4_1_BASE:1.27
	OPENBSD_4_0:1.27.0.6
	OPENBSD_4_0_BASE:1.27
	OPENBSD_3_9:1.27.0.4
	OPENBSD_3_9_BASE:1.27
	OPENBSD_3_8:1.27.0.2
	OPENBSD_3_8_BASE:1.27
	OPENBSD_3_7:1.26.0.2
	OPENBSD_3_7_BASE:1.26
	OPENBSD_3_6:1.25.0.2
	OPENBSD_3_6_BASE:1.25
	SMP_SYNC_A:1.25
	SMP_SYNC_B:1.25
	OPENBSD_3_5:1.24.0.2
	OPENBSD_3_5_BASE:1.24
	OPENBSD_3_4:1.23.0.2
	OPENBSD_3_4_BASE:1.23
	UBC_SYNC_A:1.21
	OPENBSD_3_3:1.21.0.2
	OPENBSD_3_3_BASE:1.21
	OPENBSD_3_2:1.19.0.4
	OPENBSD_3_2_BASE:1.19
	OPENBSD_3_1:1.19.0.2
	OPENBSD_3_1_BASE:1.19
	UBC_SYNC_B:1.19
	UBC:1.16.0.2
	UBC_BASE:1.16
	OPENBSD_3_0:1.14.0.2
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9:1.11.0.2
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_8:1.9.0.6
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.9.0.4
	OPENBSD_2_7_BASE:1.9
	SMP:1.9.0.2
	SMP_BASE:1.9
	kame_19991208:1.8
	OPENBSD_2_6:1.8.0.2
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.30
date	2010.11.28.20.09.40;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2010.04.29.13.48.29;	author jsing;	state Exp;
branches;
next	1.28;

1.28
date	2010.04.20.23.35.16;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2005.06.09.18.01.36;	author mickey;	state Exp;
branches;
next	1.26;

1.26
date	2004.09.15.20.11.29;	author mickey;	state Exp;
branches;
next	1.25;

1.25
date	2004.04.07.18.24.19;	author mickey;	state Exp;
branches;
next	1.24;

1.24
date	2004.02.13.21.28.19;	author mickey;	state Exp;
branches;
next	1.23;

1.23
date	2003.08.07.19.47.33;	author mickey;	state Exp;
branches;
next	1.22;

1.22
date	2003.07.30.21.50.38;	author mickey;	state Exp;
branches;
next	1.21;

1.21
date	2002.12.18.23.52.45;	author mickey;	state Exp;
branches;
next	1.20;

1.20
date	2002.12.17.21.54.25;	author mickey;	state Exp;
branches;
next	1.19;

1.19
date	2002.03.14.01.26.31;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2002.02.06.20.12.43;	author mickey;	state Exp;
branches;
next	1.17;

1.17
date	2002.02.05.04.26.06;	author mickey;	state Exp;
branches;
next	1.16;

1.16
date	2001.12.02.04.03.57;	author mickey;	state Exp;
branches
	1.16.2.1;
next	1.15;

1.15
date	2001.11.05.17.25.57;	author art;	state Exp;
branches;
next	1.14;

1.14
date	2001.10.04.22.01.30;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	2001.08.01.20.32.04;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2001.07.30.14.15.59;	author art;	state Exp;
branches;
next	1.11;

1.11
date	2001.03.22.23.29.27;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	2001.01.31.22.39.41;	author jason;	state Exp;
branches;
next	1.9;

1.9
date	2000.02.09.05.04.22;	author mickey;	state Exp;
branches
	1.9.2.1
	1.9.6.1;
next	1.8;

1.8
date	99.08.16.04.05.38;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	99.08.16.02.48.39;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	99.08.14.04.22.51;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	99.07.12.18.10.35;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	99.07.07.20.03.27;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	99.04.20.21.12.24;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	99.02.25.21.07.48;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	98.11.04.17.05.14;	author mickey;	state Exp;
branches;
next	;

1.9.2.1
date	2001.04.18.16.06.03;	author niklas;	state Exp;
branches;
next	1.9.2.2;

1.9.2.2
date	2001.10.31.02.52.46;	author nate;	state Exp;
branches;
next	1.9.2.3;

1.9.2.3
date	2001.11.13.21.00.51;	author niklas;	state Exp;
branches;
next	1.9.2.4;

1.9.2.4
date	2001.12.05.00.39.10;	author niklas;	state Exp;
branches;
next	1.9.2.5;

1.9.2.5
date	2002.03.06.00.57.22;	author niklas;	state Exp;
branches;
next	1.9.2.6;

1.9.2.6
date	2002.03.28.10.07.19;	author niklas;	state Exp;
branches;
next	1.9.2.7;

1.9.2.7
date	2003.03.27.23.26.53;	author niklas;	state Exp;
branches;
next	1.9.2.8;

1.9.2.8
date	2004.02.19.10.48.39;	author niklas;	state Exp;
branches;
next	1.9.2.9;

1.9.2.9
date	2004.06.05.23.10.48;	author niklas;	state Exp;
branches;
next	;

1.9.6.1
date	2001.01.31.22.48.14;	author jason;	state Exp;
branches;
next	;

1.16.2.1
date	2002.06.11.03.35.36;	author art;	state Exp;
branches;
next	1.16.2.2;

1.16.2.2
date	2003.05.19.21.49.41;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.30
log
@Remove unused gscbus bus_dma_tag_t.
@
text
@/*	$OpenBSD: gscbus.c,v 1.29 2010/04/29 13:48:29 jsing Exp $	*/

/*
 * Copyright (c) 1998 Michael Shalayeff
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR OR HIS RELATIVES BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

/* #define GSCDEBUG */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/reboot.h>

#include <machine/iomod.h>
#include <machine/autoconf.h>
#include <machine/cpufunc.h>

#include <hppa/gsc/gscbusvar.h>

int	gscmatch(struct device *, void *, void *);
void	gscattach(struct device *, struct device *, void *);

struct cfattach gsc_ca = {
	sizeof(struct gsc_softc), gscmatch, gscattach
};

struct cfdriver gsc_cd = {
	NULL, "gsc", DV_DULL
};

int
gscmatch(parent, cfdata, aux)   
	struct device *parent;
	void *cfdata;
	void *aux;
{
	struct confargs *ca = aux;

	return !strcmp(ca->ca_name, "gsc");
}

void
gscattach(parent, self, aux)
	struct device *parent;
	struct device *self;
	void *aux;
{
	struct gsc_softc *sc = (struct gsc_softc *)self;
	struct gsc_attach_args *ga = aux;

	sc->sc_iot = ga->ga_iot;
	sc->sc_ic = ga->ga_ic;

#ifdef USELEDS
	if (machine_ledaddr)
		printf(": %sleds", machine_ledword? "word" : "");
#endif
	printf ("\n");

	sc->sc_ih = cpu_intr_establish(IPL_NESTED, ga->ga_irq,
	    gsc_intr, (void *)sc->sc_ic->gsc_base, sc->sc_dev.dv_xname);

	pdc_scanbus(self, &ga->ga_ca, MAXMODBUS, 0, 0);
}

int
gscprint(aux, pnp)
	void *aux;
	const char *pnp;
{
	struct gsc_attach_args *ga = aux;

	if (pnp)
		printf("%s at %s", ga->ga_name, pnp);
	return (UNCONF);
}

void *
gsc_intr_establish(sc, irq, pri, handler, arg, name)
	struct gsc_softc *sc;
	int pri;
	int irq;
	int (*handler)(void *v);
	void *arg;
	const char *name;
{
	volatile u_int32_t *r = sc->sc_ic->gsc_base;
	void *iv;

	if ((iv = cpu_intr_map(sc->sc_ih, pri, irq, handler, arg, name)))
		r[1] |= (1 << irq);
	else {
#ifdef GSCDEBUG
		printf("%s: attaching irq %d, already occupied\n",
		       sc->sc_dev.dv_xname, irq);
#endif
	}

	return (iv);
}

void
gsc_intr_disestablish(sc, v)
	struct gsc_softc *sc;
	void *v;
{
#if notyet
	volatile u_int32_t *r = sc->sc_ic->gsc_base;

	r[1] &= ~(1 << irq);

	cpu_intr_unmap(sc->sc_ih, v);
#endif
}
@


1.29
log
@Currently pdc_scanbus() scans in reverse, which results in physical CPU0
attaching as cpu1 and physical CPU1 attaching as cpu0. Split the device
scan into two parts - the first pass scans forward and attaches memory
and CPUs, whilst the second pass scans in reverse attaching the
remaining devices, thus preserving current semantics.

Found the hard way whilst trying to spin up the secondary CPU on my j6750.

ok miod@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gscbus.c,v 1.27 2005/06/09 18:01:36 mickey Exp $	*/
a54 21
int	gsc_dmamap_create(void *, bus_size_t, int,
			       bus_size_t, bus_size_t, int, bus_dmamap_t *);
void	gsc_dmamap_destroy(void *, bus_dmamap_t);
int	gsc_dmamap_load(void *, bus_dmamap_t, void *,
			     bus_size_t, struct proc *, int);
int	gsc_dmamap_load_mbuf(void *, bus_dmamap_t, struct mbuf *, int);
int	gsc_dmamap_load_uio(void *, bus_dmamap_t, struct uio *, int);
int	gsc_dmamap_load_raw(void *, bus_dmamap_t,
				 bus_dma_segment_t *, int, bus_size_t, int);
void	gsc_dmamap_unload(void *, bus_dmamap_t);
void	gsc_dmamap_sync(void *, bus_dmamap_t, bus_addr_t, bus_size_t,
			     int);

int	gsc_dmamem_alloc(void *, bus_size_t, bus_size_t,
			      bus_size_t, bus_dma_segment_t *, int, int *, int);
void	gsc_dmamem_free(void *, bus_dma_segment_t *, int);
int	gsc_dmamem_map(void *, bus_dma_segment_t *,
			    int, size_t, caddr_t *, int);
void	gsc_dmamem_unmap(void *, caddr_t, size_t);
paddr_t	gsc_dmamem_mmap(void *, bus_dma_segment_t *, int, off_t, int, int);

a86 17
	/* DMA guts */
	sc->sc_dmatag._cookie = sc;
	sc->sc_dmatag._dmamap_create = gsc_dmamap_create;
	sc->sc_dmatag._dmamap_destroy = gsc_dmamap_destroy;
	sc->sc_dmatag._dmamap_load = gsc_dmamap_load;
	sc->sc_dmatag._dmamap_load_mbuf = gsc_dmamap_load_mbuf;
	sc->sc_dmatag._dmamap_load_uio = gsc_dmamap_load_uio;
	sc->sc_dmatag._dmamap_load_raw = gsc_dmamap_load_raw;
	sc->sc_dmatag._dmamap_unload = gsc_dmamap_unload;
	sc->sc_dmatag._dmamap_sync = gsc_dmamap_sync;

	sc->sc_dmatag._dmamem_alloc = gsc_dmamem_alloc;
	sc->sc_dmatag._dmamem_free = gsc_dmamem_free;
	sc->sc_dmatag._dmamem_map = gsc_dmamem_map;
	sc->sc_dmatag._dmamem_unmap = gsc_dmamem_unmap;
	sc->sc_dmatag._dmamem_mmap = gsc_dmamem_mmap;

a137 139
}

int
gsc_dmamap_create(v, size, nseg, maxsegsz, boundary, flags, dmamp)
	void *v;
	bus_size_t size;
	int nseg;
	bus_size_t maxsegsz;
	bus_size_t boundary;
	int flags;
	bus_dmamap_t *dmamp;
{
	return 0;
}

void
gsc_dmamap_destroy(v, map)
	void *v;
	bus_dmamap_t map;
{
}

int
gsc_dmamap_load(v, map, buf, buflen, p, flags)
	void *v;
	bus_dmamap_t map;
	void *buf;
	bus_size_t buflen;
	struct proc *p;
	int flags;
{
	return 0;
}

int
gsc_dmamap_load_mbuf(v, map, mbuf, flags)
	void *v;
	bus_dmamap_t map;
	struct mbuf *mbuf;
	int flags;
{
	return 0;
}

int
gsc_dmamap_load_uio(v, map, uio, flags)
	void *v;
	bus_dmamap_t map;
	struct uio *uio;
	int flags;
{
	return 0;
}

int
gsc_dmamap_load_raw(v, map, segs, nsegs, size, flags)
	void *v;
	bus_dmamap_t map;
	bus_dma_segment_t *segs;
	int nsegs;
	bus_size_t size;
	int flags;
{
	return 0;
}

void
gsc_dmamap_unload(v, map)
	void *v;
	bus_dmamap_t map;
{

}

void
gsc_dmamap_sync(v, map, offset, len, op)
	void *v;
	bus_dmamap_t map;
	bus_addr_t offset;
	bus_size_t len;
	int op;
{

}

int
gsc_dmamem_alloc(v, size, alignment, boundary, segs, nsegs, rsegs, flags)
	void *v;
	bus_size_t size;
	bus_size_t alignment;
	bus_size_t boundary;
	bus_dma_segment_t *segs;
	int nsegs;
	int *rsegs;
	int flags;
{
	return 0;
}

void
gsc_dmamem_free(v, segs, nsegs)
	void *v;
	bus_dma_segment_t *segs;
	int nsegs;
{

}

int
gsc_dmamem_map(v, segs, nsegs, size, kvap, flags)
	void *v;
	bus_dma_segment_t *segs;
	int nsegs;
	size_t size;
	caddr_t *kvap;
	int flags;
{
	return 0;
}

void
gsc_dmamem_unmap(v, kva, size)
	void *v;
	caddr_t kva;
	size_t size;
{

}

paddr_t
gsc_dmamem_mmap(v, segs, nsegs, off, prot, flags)
	void *v;
	bus_dma_segment_t *segs;
	int nsegs;
	off_t off;
	int prot;
	int flags;
{
	return (-1);
@


1.28
log
@more misuse of user.h and sysctl.h
@
text
@d125 1
a125 1
	pdc_scanbus(self, &ga->ga_ca, MAXMODBUS, 0);
@


1.27
log
@it appears asp occupies more space than intially thought and
audio wraps off the edge making troubles.
make sure gsc attachment follows the amsk from the parents
and also extend the asp's range to a full 512m.
found by Graham Gower <graham.gower@@gmail.com> on 735
testing by miod@@ on 715
@
text
@d1 1
a1 1
/*	$OpenBSD: gscbus.c,v 1.26 2004/09/15 20:11:29 mickey Exp $	*/
a34 1
#include <sys/user.h>
@


1.26
log
@scan cpu bus manually for some machines do not support that in prom
@
text
@d1 1
a1 1
/*	$OpenBSD: gscbus.c,v 1.25 2004/04/07 18:24:19 mickey Exp $	*/
a125 1
	ga->ga_hpamask = HPPA_FLEX_MASK;
@


1.25
log
@update copyright; miod@@ is fine w/ files where he holds it too
@
text
@d1 1
a1 1
/*	$OpenBSD: gscbus.c,v 1.24 2004/02/13 21:28:19 mickey Exp $	*/
d127 1
a127 1
	pdc_scanbus(self, &ga->ga_ca, MAXMODBUS);
@


1.24
log
@order irq,pri args to gsc_intr_establish() the way less confusing compared to other trolley busses around ...
@
text
@d1 1
a1 1
/*	$OpenBSD: gscbus.c,v 1.23 2003/08/07 19:47:33 mickey Exp $	*/
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Michael Shalayeff.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d19 8
a26 7
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@


1.23
log
@make all intr_establish take the same last arg for name
@
text
@d1 1
a1 1
/*	$OpenBSD: gscbus.c,v 1.22 2003/07/30 21:50:38 mickey Exp $	*/
d147 1
a147 1
gsc_intr_establish(sc, pri, irq, handler, arg, name)
@


1.22
log
@kill sample device mappings as not really useful
@
text
@d1 1
a1 1
/*	$OpenBSD: gscbus.c,v 1.21 2002/12/18 23:52:45 mickey Exp $	*/
d111 1
a111 1
	    gsc_intr, (void *)sc->sc_ic->gsc_base, &sc->sc_dev);
d147 1
a147 1
gsc_intr_establish(sc, pri, irq, handler, arg, dv)
d153 1
a153 1
	struct device *dv;
d158 1
a158 1
	if ((iv = cpu_intr_map(sc->sc_ih, pri, irq, handler, arg, dv)))
@


1.21
log
@newer machines use phantom bus to attach lasi and other bus adapters.
oledr machines did not have a real device for the phantom bus port.
change the device scanning technique to both include a full device path
in the attach_args and do proper shifting in the pdc_scanbus() and
add a device for the newer machines as well as use a newer device
mapping (path to hpa) available on newer firmware versions, where
old (hversion-dependant) is not available.
tested on 712,715/33,c110, miod@@ ok, weissmandude -- testing
@
text
@d1 1
a1 1
/*	$OpenBSD: gscbus.c,v 1.20 2002/12/17 21:54:25 mickey Exp $	*/
a30 39
 */

/*
 * Sample IO layouts:
 * 712:
 *
 * f0100000 -- lasi0
 * f0102000 -- lpt0
 * f0104000 -- audio0
 * f0105000 -- com0
 * f0106000 -- siop0
 * f0107000 -- ie0
 * f0108000 -- kbd0
 * f0108100 -- pms0
 * f010a000 -- fdc0
 * f010c000 -- *lasi0
 * f0200000 -- wax0
 * f8000000 -- sti0
 * fffbe000 -- cpu0
 * fffbf000 -- mem0
 *
 * 725/50:
 *
 * f0820000 -- dma
 * f0821000 -- hil
 * f0822000 -- com1
 * f0823000 -- com0
 * f0824000 -- lpt0
 * f0825000 -- siop0
 * f0826000 -- ie0
 * f0827000 -- dma reset
 * f0828000 -- timers
 * f0829000 -- domain kbd
 * f082f000 -- asp0
 * f1000000 -- audio0
 * fc000000 -- eisa0
 * fffbe000 -- cpu0
 * fffbf000 -- mem0
 *
@


1.20
log
@real interrupts/spl framework.
tested on 712/* 715/100, 715/33 which main cpu/bus types.
miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: gscbus.c,v 1.19 2002/03/14 01:26:31 millert Exp $	*/
d170 1
a170 1
	pdc_scanbus(self, &ga->ga_ca, ga->ga_mod, MAXMODBUS);
@


1.19
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: gscbus.c,v 1.18 2002/02/06 20:12:43 mickey Exp $	*/
d137 2
a138 2
	register struct gsc_softc *sc = (struct gsc_softc *)self;
	register struct gsc_attach_args *ga = aux;
a141 2
	sc->sc_intrmask = 0;
	bzero(sc->sc_intrvs, sizeof(sc->sc_intrvs));
d149 3
a151 2
	sc->sc_ih = cpu_intr_establish(IPL_IO, ga->ga_irq,
				       gsc_intr, sc, &sc->sc_dev);
a184 1

d194 2
a195 2
	register struct gscbus_intr *iv;
	register u_int32_t mask;
d197 3
a199 2
	mask = 1 << irq;
	if (sc->sc_intrmask & mask) {
a203 1
		return NULL;
a204 10
	sc->sc_intrmask |= mask;
	iv = &sc->sc_intrvs[irq];
	iv->pri = pri;
	iv->handler = handler;
	iv->arg = arg;
	evcnt_attach(dv, dv->dv_xname, &iv->evcnt);
	(sc->sc_ic->gsc_intr_establish)(sc->sc_ic->gsc_dv, mask);
#ifdef GSCDEBUG
	printf("gsc_intr_establish: mask=0x%08x irq=%d iv=%p\n", mask, irq, iv);
#endif
d206 1
a206 1
	return &sc->sc_intrvs[irq];
d214 2
a215 17
	register u_int32_t mask;

	mask = 1 << (sc->sc_intrvs - (struct gscbus_intr *)v);
	sc->sc_intrmask &= ~mask;
	((struct gscbus_intr *)v)->handler = NULL;
	/* evcnt_detach(); */
	(sc->sc_ic->gsc_intr_disestablish)(sc->sc_ic->gsc_dv, mask);
}

int
gsc_intr(v)
	void *v;
{
	register struct gsc_softc *sc = v;
	register struct gscbus_ic *ic = sc->sc_ic;
	register u_int32_t mask;
	int ret;
d217 1
a217 7
#ifdef GSCDEBUG_INTR
	printf("gsc_intr(%p)\n", v);
#endif
	ret = 0;
	while ((mask = (ic->gsc_intr_check)(ic->gsc_dv))) {
		register int i;
		register struct gscbus_intr *iv;
d219 1
a219 10
		i = ffs(mask) - 1;
		iv = &sc->sc_intrvs[i];

#ifdef GSCDEBUG_INTR
		printf("gsc_intr: got mask=0x%08x i=%d iv=%p\n", mask, i, iv);
#endif
		if (iv->handler) {
			int s;
#ifdef GSCDEBUG_INTR
			printf("gsc_intr: calling %p for irq %d\n", v, i);
a220 18
			iv->evcnt.ev_count++;
			s = splraise(iv->pri);
			ret = (iv->handler)(iv->arg);
			splx(s);
#ifdef GSCDEBUG_INTR
			if (!ret)
				printf ("%s: can't handle interrupt\n",
					iv->evcnt.ev_name);
#endif
			ret = 1;
		} else
			printf("%s: stray interrupt %d\n",
			       sc->sc_dev.dv_xname, i);

		(ic->gsc_intr_ack)(ic->gsc_dv, 1 << i);
	}

	return ret;
@


1.18
log
@disable debug
@
text
@d1 1
a1 1
/*	$OpenBSD: gscbus.c,v 1.17 2002/02/05 04:26:06 mickey Exp $	*/
d88 2
a89 2
int	gscmatch __P((struct device *, void *, void *));
void	gscattach __P((struct device *, struct device *, void *));
d99 20
a118 20
int	gsc_dmamap_create __P((void *, bus_size_t, int,
			       bus_size_t, bus_size_t, int, bus_dmamap_t *));
void	gsc_dmamap_destroy __P((void *, bus_dmamap_t));
int	gsc_dmamap_load __P((void *, bus_dmamap_t, void *,
			     bus_size_t, struct proc *, int));
int	gsc_dmamap_load_mbuf __P((void *, bus_dmamap_t, struct mbuf *, int));
int	gsc_dmamap_load_uio __P((void *, bus_dmamap_t, struct uio *, int));
int	gsc_dmamap_load_raw __P((void *, bus_dmamap_t,
				 bus_dma_segment_t *, int, bus_size_t, int));
void	gsc_dmamap_unload __P((void *, bus_dmamap_t));
void	gsc_dmamap_sync __P((void *, bus_dmamap_t, bus_addr_t, bus_size_t,
			     int));

int	gsc_dmamem_alloc __P((void *, bus_size_t, bus_size_t,
			      bus_size_t, bus_dma_segment_t *, int, int *, int));
void	gsc_dmamem_free __P((void *, bus_dma_segment_t *, int));
int	gsc_dmamem_map __P((void *, bus_dma_segment_t *,
			    int, size_t, caddr_t *, int));
void	gsc_dmamem_unmap __P((void *, caddr_t, size_t));
paddr_t	gsc_dmamem_mmap __P((void *, bus_dma_segment_t *, int, off_t, int, int));
d192 1
a192 1
	int (*handler) __P((void *v));
@


1.17
log
@use splraise() when calling handlers; from fredette@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gscbus.c,v 1.16 2001/12/02 04:03:57 mickey Exp $	*/
d72 1
a72 1
#define GSCDEBUG
@


1.16
log
@allow to configure devices on particular bus offsets
to be able to attach units to them.
main reason is the secondary gsc busses on add-on cards
which stick 'emselves in the front.
@
text
@d1 1
a1 1
/*	$OpenBSD: gscbus.c,v 1.15 2001/11/05 17:25:57 art Exp $	*/
d264 1
a264 1
			s = splx(iv->pri);
@


1.16.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: gscbus.c,v 1.16 2001/12/02 04:03:57 mickey Exp $	*/
d72 1
a72 1
/* #define GSCDEBUG */
d88 2
a89 2
int	gscmatch(struct device *, void *, void *);
void	gscattach(struct device *, struct device *, void *);
d99 20
a118 20
int	gsc_dmamap_create(void *, bus_size_t, int,
			       bus_size_t, bus_size_t, int, bus_dmamap_t *);
void	gsc_dmamap_destroy(void *, bus_dmamap_t);
int	gsc_dmamap_load(void *, bus_dmamap_t, void *,
			     bus_size_t, struct proc *, int);
int	gsc_dmamap_load_mbuf(void *, bus_dmamap_t, struct mbuf *, int);
int	gsc_dmamap_load_uio(void *, bus_dmamap_t, struct uio *, int);
int	gsc_dmamap_load_raw(void *, bus_dmamap_t,
				 bus_dma_segment_t *, int, bus_size_t, int);
void	gsc_dmamap_unload(void *, bus_dmamap_t);
void	gsc_dmamap_sync(void *, bus_dmamap_t, bus_addr_t, bus_size_t,
			     int);

int	gsc_dmamem_alloc(void *, bus_size_t, bus_size_t,
			      bus_size_t, bus_dma_segment_t *, int, int *, int);
void	gsc_dmamem_free(void *, bus_dma_segment_t *, int);
int	gsc_dmamem_map(void *, bus_dma_segment_t *,
			    int, size_t, caddr_t *, int);
void	gsc_dmamem_unmap(void *, caddr_t, size_t);
paddr_t	gsc_dmamem_mmap(void *, bus_dma_segment_t *, int, off_t, int, int);
d192 1
a192 1
	int (*handler)(void *v);
d264 1
a264 1
			s = splraise(iv->pri);
@


1.16.2.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d137 2
a138 2
	struct gsc_softc *sc = (struct gsc_softc *)self;
	struct gsc_attach_args *ga = aux;
d142 2
d151 2
a152 3
	sc->sc_ih = cpu_intr_establish(IPL_NESTED, ga->ga_irq,
	    gsc_intr, (void *)sc->sc_ic->gsc_base, &sc->sc_dev);

d171 1
a171 1
	pdc_scanbus(self, &ga->ga_ca, MAXMODBUS);
d186 1
d196 2
a197 2
	volatile u_int32_t *r = sc->sc_ic->gsc_base;
	void *iv;
d199 2
a200 3
	if ((iv = cpu_intr_map(sc->sc_ih, pri, irq, handler, arg, dv)))
		r[1] |= (1 << irq);
	else {
d205 1
d207 10
d218 1
a218 1
	return (iv);
d226 17
a242 2
#if notyet
	volatile u_int32_t *r = sc->sc_ic->gsc_base;
d244 7
a250 1
	r[1] &= ~(1 << irq);
d252 10
a261 1
	cpu_intr_unmap(sc->sc_ih, v);
d263 18
@


1.15
log
@Switch everything to the new bus_dmamap_sync API.
Most work by Wilbern Cobb <vedge@@csoft.org> with some fixes from me, mickey@@
and drahn@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: gscbus.c,v 1.14 2001/10/04 22:01:30 mickey Exp $	*/
d170 1
d179 4
@


1.14
log
@compile w/o USELEDS; from Paul Weissmann <paul@@pdp11.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: gscbus.c,v 1.13 2001/08/01 20:32:04 miod Exp $	*/
d109 2
a110 1
void	gsc_dmamap_sync __P((void *, bus_dmamap_t, bus_dmasync_op_t));
d351 1
a351 1
gsc_dmamap_sync(v, map, op)
d354 3
a356 1
	bus_dmasync_op_t op;
@


1.13
log
@Sync with busdma_map api change.
@
text
@d1 1
a1 1
/*	$OpenBSD: gscbus.c,v 1.12 2001/07/30 14:15:59 art Exp $	*/
d144 1
d147 1
a147 1

@


1.12
log
@Change:
int bus_dmamem_mmap(bus_dma_tag_t, bus_dma_segment_t, int, int, int, int);
to:
paddr_t bus_dmamem_mmap(bus_dma_tag_t, bus_dma_segment_t, int, int, off_t, int);

To allow mmaping offsets larger than INT_MAX. And to simply make more sense.
@
text
@d1 1
a1 1
/*	$OpenBSD: gscbus.c,v 1.11 2001/03/22 23:29:27 mickey Exp $	*/
d406 1
a406 1
	int off;
@


1.11
log
@ifdef on a proper debug define
@
text
@d1 1
a1 1
/*	$OpenBSD: gscbus.c,v 1.10 2001/01/31 22:39:41 jason Exp $	*/
d117 1
a117 1
int	gsc_dmamem_mmap __P((void *, bus_dma_segment_t *, int, int, int, int));
d401 1
a401 1
int
@


1.10
log
@based on art's sparc patch:
mmap should return -1 on failure, not EOPNOTSUPP.
As it was now, an mmap of /dev/mem always returned page 45.
@
text
@d1 1
a1 1
/*	$OpenBSD: gscbus.c,v 1.9 2000/02/09 05:04:22 mickey Exp $	*/
d260 1
a260 1
#ifdef DEBUG
@


1.9
log
@heartbeat -- yeah we have a patch for that
@
text
@d1 1
a1 1
/*	$OpenBSD: gscbus.c,v 1.8 1999/08/16 04:05:38 mickey Exp $	*/
d410 1
a410 1
	return 0;
@


1.9.2.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: gscbus.c,v 1.11 2001/03/22 23:29:27 mickey Exp $	*/
d260 1
a260 1
#ifdef GSCDEBUG_INTR
d410 1
a410 1
	return (-1);
@


1.9.2.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: gscbus.c,v 1.9.2.1 2001/04/18 16:06:03 niklas Exp $	*/
d117 1
a117 1
paddr_t	gsc_dmamem_mmap __P((void *, bus_dma_segment_t *, int, off_t, int, int));
a143 1
#ifdef USELEDS
d146 1
a146 1
#endif
d401 1
a401 1
paddr_t
d406 1
a406 1
	off_t off;
@


1.9.2.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d109 1
a109 2
void	gsc_dmamap_sync __P((void *, bus_dmamap_t, bus_addr_t, bus_size_t,
			     int));
d350 1
a350 1
gsc_dmamap_sync(v, map, offset, len, op)
d353 1
a353 3
	bus_addr_t offset;
	bus_size_t len;
	int op;
@


1.9.2.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD: gscbus.c,v 1.9.2.3 2001/11/13 21:00:51 niklas Exp $	*/
a169 1
	ga->ga_hpamask = HPPA_FLEX_MASK;
a177 4
	struct gsc_attach_args *ga = aux;

	if (pnp)
		printf("%s at %s", ga->ga_name, pnp);
@


1.9.2.5
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d72 1
a72 1
/* #define GSCDEBUG */
d264 1
a264 1
			s = splraise(iv->pri);
@


1.9.2.6
log
@Merge in -current from about a week ago
@
text
@d88 2
a89 2
int	gscmatch(struct device *, void *, void *);
void	gscattach(struct device *, struct device *, void *);
d99 20
a118 20
int	gsc_dmamap_create(void *, bus_size_t, int,
			       bus_size_t, bus_size_t, int, bus_dmamap_t *);
void	gsc_dmamap_destroy(void *, bus_dmamap_t);
int	gsc_dmamap_load(void *, bus_dmamap_t, void *,
			     bus_size_t, struct proc *, int);
int	gsc_dmamap_load_mbuf(void *, bus_dmamap_t, struct mbuf *, int);
int	gsc_dmamap_load_uio(void *, bus_dmamap_t, struct uio *, int);
int	gsc_dmamap_load_raw(void *, bus_dmamap_t,
				 bus_dma_segment_t *, int, bus_size_t, int);
void	gsc_dmamap_unload(void *, bus_dmamap_t);
void	gsc_dmamap_sync(void *, bus_dmamap_t, bus_addr_t, bus_size_t,
			     int);

int	gsc_dmamem_alloc(void *, bus_size_t, bus_size_t,
			      bus_size_t, bus_dma_segment_t *, int, int *, int);
void	gsc_dmamem_free(void *, bus_dma_segment_t *, int);
int	gsc_dmamem_map(void *, bus_dma_segment_t *,
			    int, size_t, caddr_t *, int);
void	gsc_dmamem_unmap(void *, caddr_t, size_t);
paddr_t	gsc_dmamem_mmap(void *, bus_dma_segment_t *, int, off_t, int, int);
d192 1
a192 1
	int (*handler)(void *v);
@


1.9.2.7
log
@Sync the SMP branch with 3.3
@
text
@d137 2
a138 2
	struct gsc_softc *sc = (struct gsc_softc *)self;
	struct gsc_attach_args *ga = aux;
d142 2
d151 2
a152 3
	sc->sc_ih = cpu_intr_establish(IPL_NESTED, ga->ga_irq,
	    gsc_intr, (void *)sc->sc_ic->gsc_base, &sc->sc_dev);

d171 1
a171 1
	pdc_scanbus(self, &ga->ga_ca, MAXMODBUS);
d186 1
d196 2
a197 2
	volatile u_int32_t *r = sc->sc_ic->gsc_base;
	void *iv;
d199 2
a200 3
	if ((iv = cpu_intr_map(sc->sc_ih, pri, irq, handler, arg, dv)))
		r[1] |= (1 << irq);
	else {
d205 1
d207 10
d218 1
a218 1
	return (iv);
d226 17
a242 2
#if notyet
	volatile u_int32_t *r = sc->sc_ic->gsc_base;
d244 7
a250 1
	r[1] &= ~(1 << irq);
d252 10
a261 1
	cpu_intr_unmap(sc->sc_ih, v);
d263 18
@


1.9.2.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d33 39
d150 1
a150 1
	    gsc_intr, (void *)sc->sc_ic->gsc_base, sc->sc_dev.dv_xname);
d186 1
a186 1
gsc_intr_establish(sc, pri, irq, handler, arg, name)
d192 1
a192 1
	const char *name;
d197 1
a197 1
	if ((iv = cpu_intr_map(sc->sc_ih, pri, irq, handler, arg, name)))
@


1.9.2.9
log
@Merge with the trunk
@
text
@d15 5
d24 7
a30 8
 * IN NO EVENT SHALL THE AUTHOR OR HIS RELATIVES BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
d147 1
a147 1
gsc_intr_establish(sc, irq, pri, handler, arg, name)
@


1.9.6.1
log
@Pull in patches from current:
Fix (art,jason):
mmap should return -1 on failure, not EOPNOTSUPP.
As it was now, an mmap of /dev/mem always returned page 45.
@
text
@d1 1
a1 1
/*	$OpenBSD: gscbus.c,v 1.9 2000/02/09 05:04:22 mickey Exp $	*/
d410 1
a410 1
	return (-1);
@


1.8
log
@report unhandled interrupts w/ DEBUG only
@
text
@d1 1
a1 1
/*	$OpenBSD: gscbus.c,v 1.7 1999/08/16 02:48:39 mickey Exp $	*/
d84 1
d143 3
@


1.7
log
@evcnt count the interrupts, also optimize diagnostic printing
@
text
@d1 1
a1 1
/*	$OpenBSD: gscbus.c,v 1.6 1999/08/14 04:22:51 mickey Exp $	*/
d256 1
d260 2
a261 1
			ret++;
@


1.6
log
@fix debug printfs, ipl name
@
text
@d1 1
a1 1
/*	$OpenBSD: gscbus.c,v 1.5 1999/07/12 18:10:35 mickey Exp $	*/
d146 1
a146 1
				       gsc_intr, sc, sc->sc_dev.dv_xname);
d177 1
a177 1
gsc_intr_establish(sc, pri, irq, handler, arg, name)
d183 1
a183 1
	const char *name;
d201 1
a201 1
	evcnt_attach(&sc->sc_dev, name, &iv->evcnt);
d252 1
d254 1
a254 1
			ret += (iv->handler)(iv->arg);
d256 4
@


1.5
log
@note wax in the sample layout
@
text
@d1 1
a1 1
/*	$OpenBSD: gscbus.c,v 1.4 1999/07/07 20:03:27 mickey Exp $	*/
d145 1
a145 1
	sc->sc_ih = cpu_intr_establish(IPL_HIGH, ga->ga_irq,
d233 1
a233 1
#ifdef GSCDEBUG
d244 1
a244 1
#ifdef GSCDEBUG
d249 1
a249 1
#ifdef GSCDEBUG
@


1.4
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: gscbus.c,v 1.3 1999/04/20 21:12:24 mickey Exp $	*/
d47 1
@


1.3
log
@note a couple of typical io layouts for reference
@
text
@d1 1
a1 1
/*	$OpenBSD: gscbus.c,v 1.2 1999/02/25 21:07:48 mickey Exp $	*/
d203 1
a203 1
	printf("gsc_intr_stablish: mask=0x%08x irq=%d iv=%p\n", mask, irq, iv);
@


1.2
log
@chipset-independant irq establishing/handling code; dummy dma stuff
@
text
@d1 1
a1 1
/*	$OpenBSD: gscbus.c,v 1.1 1998/11/04 17:05:14 mickey Exp $	*/
d31 38
@


1.1
log
@GSC bus attachment
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d33 2
d38 3
d59 20
d96 2
a97 1
	struct gsc_attach_args *ga = aux;
d99 25
a123 1
	printf("\n");
d126 235
@

