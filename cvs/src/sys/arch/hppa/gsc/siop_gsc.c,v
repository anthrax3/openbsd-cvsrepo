head	1.4;
access;
symbols
	OPENBSD_6_2:1.4.0.42
	OPENBSD_6_2_BASE:1.4
	OPENBSD_6_1:1.4.0.40
	OPENBSD_6_1_BASE:1.4
	OPENBSD_6_0:1.4.0.36
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.4.0.32
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.4.0.34
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.26
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.30
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.28
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.24
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.22
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.20
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.18
	OPENBSD_5_0:1.4.0.16
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.14
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.12
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.8
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.10
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.6
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.4
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.2
	OPENBSD_4_3_BASE:1.4
	SMP_SYNC_A:1.3
	SMP_SYNC_B:1.3
	UBC_SYNC_A:1.3
	OPENBSD_3_2:1.2.0.4
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.2
	OPENBSD_3_1_BASE:1.2
	UBC_SYNC_B:1.2
	UBC:1.1.0.16
	UBC_BASE:1.1
	OPENBSD_3_0:1.1.0.14
	OPENBSD_3_0_BASE:1.1
	OPENBSD_2_9:1.1.0.12
	OPENBSD_2_9_BASE:1.1
	OPENBSD_2_8:1.1.0.10
	OPENBSD_2_8_BASE:1.1
	OPENBSD_2_7:1.1.0.8
	OPENBSD_2_7_BASE:1.1
	SMP:1.1.0.6
	SMP_BASE:1.1
	kame_19991208:1.1
	OPENBSD_2_6:1.1.0.4
	OPENBSD_2_6_BASE:1.1
	OPENBSD_2_5:1.1.0.2
	OPENBSD_2_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.4
date	2007.08.23.21.01.22;	author kettenis;	state Exp;
branches;
next	1.3;

1.3
date	2003.01.08.02.31.15;	author mickey;	state dead;
branches;
next	1.2;

1.2
date	2002.03.14.01.26.31;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	98.11.04.17.01.35;	author mickey;	state Exp;
branches
	1.1.6.1
	1.1.16.1;
next	;

1.1.6.1
date	2002.03.28.10.07.19;	author niklas;	state Exp;
branches;
next	1.1.6.2;

1.1.6.2
date	2003.03.27.23.26.53;	author niklas;	state dead;
branches;
next	;

1.1.16.1
date	2002.06.11.03.35.36;	author art;	state Exp;
branches;
next	1.1.16.2;

1.1.16.2
date	2003.05.19.21.49.41;	author tedu;	state dead;
branches;
next	;


desc
@@


1.4
log
@First stab at a driver for the onboard Fast-Wide SCSI on the 735 and 755.
Only partly tested; works fine if there are no devices on the SCSI bus.
@
text
@/*	$OpenBSD$	*/

/*
 * Copyright (c) 2007 Mark Kettenis
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/device.h>
#include <sys/systm.h>

#include <machine/autoconf.h>
#include <machine/bus.h>
#include <machine/iomod.h>

#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>

#include <dev/ic/siopreg.h>
#include <dev/ic/siopvar_common.h>
#include <dev/ic/siopvar.h>

#include <hppa/dev/cpudevs.h>
#include <hppa/gsc/gscbusvar.h>

#define	SIOP_GSC_RESET	0x0000
#define	SIOP_GSC_OFFSET	0x0100

int siop_gsc_match(struct device *, void *, void *);
void siop_gsc_attach(struct device *, struct device *, void *);
int siop_gsc_intr(void *);
void siop_gsc_reset(struct siop_common_softc *);

u_int8_t siop_gsc_r1(void *, bus_space_handle_t, bus_size_t);
u_int16_t siop_gsc_r2(void *, bus_space_handle_t, bus_size_t);
void siop_gsc_w1(void *, bus_space_handle_t, bus_size_t, u_int8_t);
void siop_gsc_w2(void *, bus_space_handle_t, bus_size_t, u_int16_t);

struct siop_gsc_softc {
	struct siop_softc sc_siop;
	bus_space_tag_t sc_iot;
	bus_space_handle_t sc_ioh;
	struct hppa_bus_space_tag sc_bustag;
};

struct cfattach siop_gsc_ca = {
	sizeof(struct siop_gsc_softc), siop_gsc_match, siop_gsc_attach
};

int
siop_gsc_match(struct device *parent, void *match, void *aux)
{
	struct gsc_attach_args *ga = aux;

	if (ga->ga_type.iodc_type != HPPA_TYPE_FIO ||
	    ga->ga_type.iodc_sv_model != HPPA_FIO_FWSCSI)
		return 0;

	return 1;
}

void
siop_gsc_attach(struct device *parent, struct device *self, void *aux)
{
	struct siop_gsc_softc *sc = (struct siop_gsc_softc *)self;
	struct gsc_attach_args *ga = aux;

	sc->sc_iot = ga->ga_iot;
	if (bus_space_map(sc->sc_iot, ga->ga_hpa,
	    IOMOD_HPASIZE, 0, &sc->sc_ioh)) {
		printf(": cannot map io space\n");
		return;
	}

	sc->sc_bustag = *sc->sc_iot;
	sc->sc_bustag.hbt_r1 = siop_gsc_r1;
	sc->sc_bustag.hbt_r2 = siop_gsc_r2;
	sc->sc_bustag.hbt_w1 = siop_gsc_w1;
	sc->sc_bustag.hbt_w2 = siop_gsc_w2;

	sc->sc_siop.sc_c.features = SF_CHIP_PF | SF_CHIP_BE | SF_BUS_WIDE;
	sc->sc_siop.sc_c.maxburst = 4;
	sc->sc_siop.sc_c.maxoff = 8;
	sc->sc_siop.sc_c.clock_div = 3;
	sc->sc_siop.sc_c.clock_period = 250;
	sc->sc_siop.sc_c.ram_size = 0;

	sc->sc_siop.sc_c.sc_reset = siop_gsc_reset;
	sc->sc_siop.sc_c.sc_dmat = ga->ga_dmatag;

	sc->sc_siop.sc_c.sc_rt = &sc->sc_bustag;
	bus_space_subregion(sc->sc_iot, sc->sc_ioh, SIOP_GSC_OFFSET,
	    IOMOD_HPASIZE - SIOP_GSC_OFFSET, &sc->sc_siop.sc_c.sc_rh);

	/*
	 * Reset the SCSI subsystem.
	 */
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, SIOP_GSC_RESET, 0);
	DELAY(1000);
	siop_gsc_reset(&sc->sc_siop.sc_c);

	gsc_intr_establish((struct gsc_softc *)parent, ga->ga_irq,
	    IPL_BIO, siop_intr, sc, sc->sc_siop.sc_c.sc_dev.dv_xname);

	printf(": NCR53C720 rev %d\n", bus_space_read_1(sc->sc_siop.sc_c.sc_rt,
	    sc->sc_siop.sc_c.sc_rh, SIOP_CTEST3) >> 4);

	siop_attach(&sc->sc_siop);
}

void
siop_gsc_reset(struct siop_common_softc *sc)
{
	bus_space_write_1(sc->sc_rt, sc->sc_rh, SIOP_DCNTL, DCNTL_EA);
	bus_space_write_1(sc->sc_rt, sc->sc_rh, SIOP_CTEST0, CTEST0_EHP);
	bus_space_write_1(sc->sc_rt, sc->sc_rh, SIOP_CTEST4, CTEST4_MUX);

	bus_space_write_1(sc->sc_rt, sc->sc_rh, SIOP_STIME0,
	    (0xc << STIME0_SEL_SHIFT));
}

u_int8_t
siop_gsc_r1(void *v, bus_space_handle_t h, bus_size_t o)
{
	return *(volatile u_int8_t *)(h + (o ^ 3));
}

u_int16_t
siop_gsc_r2(void *v, bus_space_handle_t h, bus_size_t o)
{
	if (o == SIOP_SIST0) {
		u_int16_t reg;

		reg = siop_gsc_r1(v, h, SIOP_SIST0);
		reg |= siop_gsc_r1(v, h, SIOP_SIST1) << 8;
		return reg;
	}
	return *(volatile u_int16_t *)(h + (o ^ 2));
}

void
siop_gsc_w1(void *v, bus_space_handle_t h, bus_size_t o, u_int8_t vv)
{
	*(volatile u_int8_t *)(h + (o ^ 3)) = vv;
}

void
siop_gsc_w2(void *v, bus_space_handle_t h, bus_size_t o, u_int16_t vv)
{
	*(volatile u_int16_t *)(h + (o ^ 2)) = vv;
}
@


1.3
log
@this one is old and must die now
@
text
@d1 1
a1 1
/*	$OpenBSD: siop_gsc.c,v 1.2 2002/03/14 01:26:31 millert Exp $	*/
d4 1
a4 2
 * Copyright (c) 1998 Michael Shalayeff
 * All rights reserved.
d6 3
a8 13
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Michael Shalayeff.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d10 7
a16 10
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d20 1
a21 1
#include <sys/device.h>
d23 1
a24 1
#include <machine/intr.h>
a25 1
#include <machine/autoconf.h>
d30 3
a32 2
#include <dev/ic/ncr53c7xxreg.h>
#include <dev/ic/ncr53c7xxvar.h>
d35 1
d37 2
a38 2
int	ncr53c7xx_gsc_probe(struct device *, void *, void *);
void	ncr53c7xx_gsc_attach(struct device *, struct device *, void *);
d40 15
a54 3
struct cfattach ncr_ca = {
	sizeof(struct ncr53c7xx_softc),
	ncr53c7xx_gsc_probe, ncr53c7xx_gsc_attach
d57 2
a58 2
struct cfdriver ncr_cd = {
	NULL, "ncr", DV_DULL, NULL, 0
d61 4
a64 6
struct scsi_adapter ncr53c7xx_gsc_scsiswitch = {
	ncr53c7xx_scsicmd,
	ncr53c7xx_minphys,
	0,			/* no lun support */
	0,			/* no lun support */
};
d66 3
a68 6
struct scsi_device ncr53c7xx_gsc_scsidev = {
	NULL,		/* use default error handler */
	NULL,		/* do not have a start functio */
	NULL,		/* have no async handler */
	NULL,		/* Use default done routine */
};
d70 2
d73 5
a77 16
int
ncr53c7xx_gsc_probe(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	register struct confargs *ca = aux;
	register bus_space_tag_t iot;
	bus_space_handle_t ioh;
	int rv = 1;

	if (ca->ca_type.iodc_type != HPPA_TYPE_FIO ||
	    (ca->ca_type.iodc_sv_model != HPPA_FIO_GSCSI &&
	     ca->ca_type.iodc_sv_model != HPPA_FIO_SCSI))
		if (ca->ca_type.iodc_type != HPPA_TYPE_ADMA ||
		    ca->ca_type.iodc_sv_model != HPPA_ADMA_FWSCSI)
			return 0;
d79 33
a111 4
	iot = HPPA_BUS_TAG_SET_BYTE(ca->ca_iot);
	if (bus_space_map(ca->ca_iot, ca->ca_hpa, IOMOD_HPASIZE, 0, &ioh))
		return 0;
	ioh |= IOMOD_DEVOFFSET;
d113 2
d116 2
d119 1
a119 3
	ioh &= ~IOMOD_DEVOFFSET;
	bus_space_unmap(ca->ca_iot, ioh, IOMOD_HPASIZE);
	return rv;
d123 5
a127 33
ncr53c7xx_gsc_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	register struct ncr53c7xx_softc *sc = (void *)self;
	register struct confargs *ca = aux;

	sc->sc_iot = HPPA_BUS_TAG_SET_BYTE(ca->ca_iot);
	if (bus_space_map(sc->sc_iot, ca->ca_hpa, IOMOD_HPASIZE,
			  0, &sc->sc_ioh))
		panic("ncr53c7xx_gsc_attach: couldn't map I/O ports");
	sc->sc_ioh |= IOMOD_DEVOFFSET;

	sc->sc_clock_freq = ca->ca_pdc_iodc_read->filler2[14] / 1000000;
	if (!sc->sc_clock_freq)
		sc->sc_clock_freq = 50;

	if (ca->ca_type.iodc_sv_model == HPPA_FIO_GSCSI)
		sc->sc_type = 10;
	else if (ca->ca_type.iodc_sv_model == HPPA_ADMA_FWSCSI)
		sc->sc_type = 20;
	else
		sc->sc_type = 0;

	sc->sc_ctest7 = 0;
	sc->sc_dcntl = 0;
	sc->sc_flags = NCR53C7XX_NODMA;

	sc->sc_link.adapter_softc = sc;
	sc->sc_link.adapter_target = 7;
	sc->sc_link.adapter = &ncr53c7xx_gsc_scsiswitch;
	sc->sc_link.device = &ncr53c7xx_gsc_scsidev;
	sc->sc_link.openings = 2;
d129 22
a150 1
	ncr53c7xx_initialize(sc);
d152 10
a161 1
	config_found(self, &sc->sc_link, scsiprint);
@


1.2
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: siop_gsc.c,v 1.1 1998/11/04 17:01:35 mickey Exp $	*/
@


1.1
log
@call it siop to be consistant w/ the other ports
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr53c7xx_gsc.c,v 1.1 1998/10/01 05:07:32 mickey Exp $	*/
d50 2
a51 2
int	ncr53c7xx_gsc_probe __P((struct device *, void *, void *));
void	ncr53c7xx_gsc_attach __P((struct device *, struct device *, void *));
@


1.1.16.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: siop_gsc.c,v 1.1 1998/11/04 17:01:35 mickey Exp $	*/
d50 2
a51 2
int	ncr53c7xx_gsc_probe(struct device *, void *, void *);
void	ncr53c7xx_gsc_attach(struct device *, struct device *, void *);
@


1.1.16.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD: siop_gsc.c,v 1.1.16.1 2002/06/11 03:35:36 art Exp $	*/
@


1.1.6.1
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d50 2
a51 2
int	ncr53c7xx_gsc_probe(struct device *, void *, void *);
void	ncr53c7xx_gsc_attach(struct device *, struct device *, void *);
@


1.1.6.2
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD: siop_gsc.c,v 1.1.6.1 2002/03/28 10:07:19 niklas Exp $	*/
@


