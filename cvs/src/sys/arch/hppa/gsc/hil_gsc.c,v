head	1.5;
access;
symbols
	OPENBSD_6_2_BASE:1.5
	OPENBSD_6_1:1.5.0.48
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.5.0.44
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.40
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.42
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.34
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.38
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.36
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.32
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.30
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.28
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.26
	OPENBSD_5_0:1.5.0.24
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.22
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.20
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.16
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.18
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.14
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.12
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.10
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.8
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.6
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.4
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.2
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.4.0.8
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.6
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.4
	OPENBSD_3_6_BASE:1.4
	SMP_SYNC_A:1.4
	SMP_SYNC_B:1.4
	OPENBSD_3_5:1.4.0.2
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.3.0.2
	OPENBSD_3_4_BASE:1.3
	UBC:1.2.0.6
	UBC_SYNC_A:1.2
	SMP:1.2.0.4
	OPENBSD_3_3:1.2.0.2
	OPENBSD_3_3_BASE:1.2;
locks; strict;
comment	@ * @;


1.5
date	2005.12.22.07.09.52;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2004.02.13.21.28.19;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	2003.08.07.19.47.33;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	2003.02.15.23.42.45;	author miod;	state Exp;
branches
	1.2.4.1;
next	1.1;

1.1
date	2003.02.11.19.44.23;	author miod;	state Exp;
branches;
next	;

1.2.4.1
date	2004.02.19.10.48.40;	author niklas;	state Exp;
branches;
next	1.2.4.2;

1.2.4.2
date	2004.06.05.23.10.48;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Postpone the hil console detection logic to the first detection of a keyboard.

On hp300, hil would claim console against dnkbd if no dnkbd was found at
the time the loop is probed, even if the loop is empty. Because of this,
plugging dnkbd later would not select it as console keyboard, which is
really annoying on kernels without wsmux, such as hp300 RAMDISK.
Now the first keyboard plugged will become the console keyboard, whatever
its type.

No functional change on hppa, since the console path gives a definite console
device setting.
@
text
@/*	$OpenBSD: hil_gsc.c,v 1.4 2004/02/13 21:28:19 mickey Exp $	*/
/*
 * Copyright (c) 2003, Miodrag Vallat.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>

#include <machine/cpu.h>
#include <machine/intr.h>
#include <machine/iomod.h>
#include <machine/autoconf.h>
#include <machine/bus.h>

#include <hppa/dev/cpudevs.h>
#include <hppa/gsc/gscbusvar.h>

#include <machine/hil_machdep.h>

#include <dev/hil/hilvar.h>

int	hil_gsc_match(struct device *, void *, void *);
void	hil_gsc_attach(struct device *, struct device *, void *);

struct hil_gsc_softc {
	struct hil_softc sc_hs;
	int		 sc_hil_console;
};

struct cfattach hil_gsc_ca = {
	sizeof(struct hil_gsc_softc), hil_gsc_match, hil_gsc_attach
};

int
hil_gsc_match(struct device *parent, void *match, void *aux)
{
	struct gsc_attach_args *ga = aux;

	if (ga->ga_type.iodc_type != HPPA_TYPE_FIO ||
	    ga->ga_type.iodc_sv_model != HPPA_FIO_HIL)
		return (0);

	return (1);
}

void
hil_gsc_attach(struct device *parent, struct device *self, void *aux)
{
	struct hil_gsc_softc *gsc = (void *)self;
	struct hil_softc *sc = &gsc->sc_hs;
	struct gsc_attach_args *ga = aux;

	sc->sc_bst = ga->ga_iot;
	if (bus_space_map(ga->ga_iot, ga->ga_hpa,
	    HILMAPSIZE, 0, &sc->sc_bsh)) {
		printf(": couldn't map hil controller\n");
		return;
	}

	gsc->sc_hil_console = ga->ga_dp.dp_mod == PAGE0->mem_kbd.pz_dp.dp_mod &&
	    bcmp(ga->ga_dp.dp_bc, PAGE0->mem_kbd.pz_dp.dp_bc, 6) == 0;

	hil_attach(sc, &gsc->sc_hil_console);

	gsc_intr_establish((struct gsc_softc *)parent, ga->ga_irq, IPL_TTY,
	    hil_intr, sc, sc->sc_dev.dv_xname);

	startuphook_establish(hil_attach_deferred, sc);
}
@


1.4
log
@order irq,pri args to gsc_intr_establish() the way less confusing compared to other trolley busses around ...
@
text
@d1 1
a1 1
/*	$OpenBSD: hil_gsc.c,v 1.3 2003/08/07 19:47:33 mickey Exp $	*/
d49 5
d55 1
a55 1
	sizeof(struct hil_softc), hil_gsc_match, hil_gsc_attach
d73 2
a74 1
	struct hil_softc *sc = (void *)self;
a75 1
	int hil_is_console;
d84 1
a84 1
	hil_is_console = ga->ga_dp.dp_mod == PAGE0->mem_kbd.pz_dp.dp_mod &&
d87 1
a87 1
	hil_attach(sc, hil_is_console);
@


1.3
log
@make all intr_establish take the same last arg for name
@
text
@d1 1
a1 1
/*	$OpenBSD: hil_gsc.c,v 1.2 2003/02/15 23:42:45 miod Exp $	*/
d84 2
a85 2
	gsc_intr_establish((struct gsc_softc *)parent, IPL_TTY,
	    ga->ga_irq, hil_intr, sc, sc->sc_dev.dv_xname);
@


1.2
log
@Rework the console management on hppa:
- only attach a keyboard as a console if it matches the PDC keyboard path
- on hil, as there can be multiple keyboards on the loop, attach only the
  first hilkbd device configured as console keyboard. Right now this means
  the one with the lowest hil code, which was the existing behaviour so far.
- do not try to switch to the wscons consdev structure early at all in
  wscons_machdep, but rather wait for the console to be completely
  configured (i.e. both wskbd and wsdisplay are attached) to switch.

With feedback and help from mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hil_gsc.c,v 1.1 2003/02/11 19:44:23 miod Exp $	*/
d85 1
a85 1
	    ga->ga_irq, hil_intr, sc, &sc->sc_dev);
@


1.2.4.1
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d85 1
a85 1
	    ga->ga_irq, hil_intr, sc, sc->sc_dev.dv_xname);
@


1.2.4.2
log
@Merge with the trunk
@
text
@d84 2
a85 2
	gsc_intr_establish((struct gsc_softc *)parent, ga->ga_irq, IPL_TTY,
	    hil_intr, sc, sc->sc_dev.dv_xname);
@


1.1
log
@hil at gsc attachment glue.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d70 1
d79 4
a82 1
	hil_attach(sc);
@

