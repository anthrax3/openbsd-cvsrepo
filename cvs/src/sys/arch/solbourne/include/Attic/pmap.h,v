head	1.11;
access;
symbols
	OPENBSD_5_8:1.10.0.6
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.8.0.6
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.4
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.7.0.2
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.6.0.8
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.6
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.4
	OPENBSD_5_0:1.6.0.2
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.2.0.12
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.2.0.8
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.10
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.6
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.2.0.4
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3:1.2.0.2
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_2:1.1.0.10
	OPENBSD_4_2_BASE:1.1
	OPENBSD_4_1:1.1.0.8
	OPENBSD_4_1_BASE:1.1
	OPENBSD_4_0:1.1.0.6
	OPENBSD_4_0_BASE:1.1
	OPENBSD_3_9:1.1.0.4
	OPENBSD_3_9_BASE:1.1
	OPENBSD_3_8:1.1.0.2
	OPENBSD_3_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.11
date	2015.12.01.08.13.30;	author deraadt;	state dead;
branches;
next	1.10;
commitid	pJfT5kYsmeGT25jh;

1.10
date	2015.02.15.21.34.33;	author miod;	state Exp;
branches;
next	1.9;
commitid	eahBabNpxnDWKzqJ;

1.9
date	2014.12.17.15.27.17;	author deraadt;	state Exp;
branches;
next	1.8;
commitid	TrUT1n8JWJCi0KBz;

1.8
date	2014.01.30.18.16.41;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2013.03.21.02.10.37;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2011.03.23.16.54.37;	author pirofti;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.26.15.41.00;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2010.12.06.20.57.18;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2010.11.18.21.21.38;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2007.09.10.18.49.45;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2005.04.19.21.30.18;	author miod;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Send solbourne to where the ...........
@
text
@/*	$OpenBSD: pmap.h,v 1.10 2015/02/15 21:34:33 miod Exp $	*/

/*
 * Copyright (c) 2005, Miodrag Vallat
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef	_MACHINE_PMAP_H_
#define _MACHINE_PMAP_H_

#include <machine/pte.h>

/*
 * PMAP structure
 */
struct pmap {
	pd_entry_t		*pm_segtab;	/* first level table */
	paddr_t			pm_psegtab;	/* pa of above */

	int			pm_refcount;	/* reference count */
	struct pmap_statistics	pm_stats;	/* pmap statistics */
};

typedef struct pmap *pmap_t;

/*
 * Extra constants passed in the low bits of pa in pmap_enter() to
 * request specific memory attributes.
 */

#define	PMAP_NC		1
#define	PMAP_OBIO	PMAP_NC
#define	PMAP_BWS	2

/*
 * Macro to pass iospace bits in the low bits of pa in pmap_enter().
 * Provided for source code compatibility - we don't need such bits.
 */

#define	PMAP_IOENC(x)	0

#ifdef _KERNEL

extern struct pmap kernel_pmap_store;

#define	kvm_recache(addr, npages) 	kvm_setcache(addr, npages, 1)
#define	kvm_uncache(addr, npages) 	kvm_setcache(addr, npages, 0)
#define	pmap_copy(a,b,c,d,e)		do { /* nothing */ } while (0)
#define	pmap_deactivate(p)		do { /* nothing */ } while (0)
#define	pmap_kernel()			(&kernel_pmap_store)
#define	pmap_resident_count(p)		((p)->pm_stats.resident_count)
#define	pmap_update(p)			do { /* nothing */ } while (0)
#define	pmap_wired_count(p)		((p)->pm_stats.wired_count)
#define	pmap_remove_holes(vm)		do { /* nothing */ } while (0)

#define PMAP_PREFER(fo, ap)		pmap_prefer((fo), (ap))

struct proc;
void		kvm_setcache(caddr_t, int, int);
void		switchexit(struct proc *);		/* locore.s */
void		pmap_bootstrap(size_t);
void		pmap_cache_enable(void);
void		pmap_changeprot(pmap_t, vaddr_t, vm_prot_t, int);
vaddr_t		pmap_map(vaddr_t, paddr_t, paddr_t, int);
int		pmap_pa_exists(paddr_t);
vaddr_t		pmap_prefer(vaddr_t, vaddr_t);
void		pmap_release(pmap_t);
void		pmap_redzone(void);
void		pmap_virtual_space(vaddr_t *, vaddr_t *);
void		pmap_writetext(unsigned char *, int);

#endif /* _KERNEL */

struct pvlist {
	struct		pvlist *pv_next;	/* next pvlist, if any */
	struct		pmap *pv_pmap;		/* pmap of this va */
	vaddr_t		pv_va;			/* virtual address */
	int		pv_flags;		/* flags (below) */
};

struct vm_page_md {
	struct pvlist pv_head;
};

#define VM_MDPAGE_INIT(pg) do {			\
	(pg)->mdpage.pv_head.pv_next = NULL;	\
	(pg)->mdpage.pv_head.pv_pmap = NULL;	\
	(pg)->mdpage.pv_head.pv_va = 0;		\
	(pg)->mdpage.pv_head.pv_flags = 0;	\
} while (0)

#endif /* _MACHINE_PMAP_H_ */
@


1.10
log
@Change pmap_remove_holes() to take a vmspace instead of a map as its argument.

Use this on vax to correctly pick the end of the stack area now that the
stackgap adjustment code will no longer guarantee it is a fixed location.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.9 2014/12/17 15:27:17 deraadt Exp $	*/
@


1.9
log
@remove simplelocks (trivial)
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.8 2014/01/30 18:16:41 miod Exp $	*/
d74 1
a74 1
#define	pmap_remove_holes(map)		do { /* nothing */ } while (0)
@


1.8
log
@Move declaration of struct vm_page_md from <machine/vmparam.h> to
<machine/pmap.h> where it belongs, and compensate in <uvm/uvm_extern.h>
by including <uvm/uvm_pmap.h> before <uvm/uvm_page.h>. Tested on all
MACHINE_ARCH but amd64 and i386 (and hppa64).
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.7 2013/03/21 02:10:37 deraadt Exp $	*/
a40 1
	struct simplelock	pm_lock;
@


1.7
log
@no newlines at end
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.6 2011/03/23 16:54:37 pirofti Exp $	*/
d94 18
@


1.6
log
@Normalize sentinel. Use _MACHINE_*_H_ and _<ARCH>_*_H_ properly and consitently.

Discussed and okay drahn@@. Okay deraadt@@.
@
text
@d1 2
a2 1
/*	$OpenBSD: pmap.h,v 1.5 2010/12/26 15:41:00 miod Exp $	*/
@


1.5
log
@Kill pmap_phys_address(), and force every driver's mmap() routine to return
a physical address [more precisely, something suitable to pass to pmap_enter()'sphysical address argument].

This allows MI drivers to implement mmap() routines without having to know
about the pmap_phys_address() implementation and #ifdef obfuscation.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.4 2010/12/06 20:57:18 miod Exp $	*/
d27 2
a28 2
#ifndef	_SOLBOURNE_PMAP_H_
#define _SOLBOURNE_PMAP_H_
d94 1
a94 1
#endif /* _SOLBOURNE_PMAP_H_ */
@


1.4
log
@Change the signature of PMAP_PREFER from void PMAP_PREFER(..., vaddr_t *) to
vaddr_t PMAP_PREFER(..., vaddr_t). This allows better compiler optimization
when the function is inlined, and avoids accessing memory on architectures
when we can pass function arguments in registers.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.3 2010/11/18 21:21:38 miod Exp $	*/
a70 1
#define	pmap_phys_address(frame)	ptoa(frame)
@


1.3
log
@Declare pmap_proc_iflush() in <uvm/uvm_pmap.h> unless <machine/pmap.h>
provides an inline version of it.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.2 2007/09/10 18:49:45 miod Exp $	*/
a81 1
void		pmap_activate(struct proc *);
a84 12
boolean_t	pmap_clear_modify(struct vm_page *);
boolean_t	pmap_clear_reference(struct vm_page *);
void		pmap_copy_page(struct vm_page *, struct vm_page *);
pmap_t		pmap_create(void);
void		pmap_destroy(pmap_t);
int		pmap_enter(pmap_t, vaddr_t, paddr_t, vm_prot_t, int);
boolean_t	pmap_extract(pmap_t, vaddr_t, paddr_t *);
void		pmap_init(void);
boolean_t	pmap_is_modified(struct vm_page *);
boolean_t	pmap_is_referenced(struct vm_page *);
void		pmap_kenter_pa(vaddr_t, paddr_t, vm_prot_t);
void		pmap_kremove(vaddr_t, vsize_t);
d87 1
a87 4
void		pmap_page_protect(struct vm_page *, vm_prot_t);
void		pmap_prefer(vaddr_t, vaddr_t *);
void		pmap_protect(pmap_t, vaddr_t, vaddr_t, vm_prot_t);
void		pmap_reference(pmap_t);
a89 2
void		pmap_remove(pmap_t, vaddr_t, vaddr_t);
void		pmap_unwire(pmap_t, vaddr_t);
a91 1
void		pmap_zero_page(struct vm_page *);
@


1.2
log
@Introduce a md pmap hook, pmap_remove_holes(), which is supposed to mark
the holes a MMU may have from a given vm_map. This will be automagically
invoked for newly created vmspaces.

On platforms with MMU holes (e.g. sun4, sun4c and vax), this prevents
mmap(2) hints which would end up being in the hole to be accepted as valid,
causing unexpected signals when the process tries to access the hole
(since pmap can not fill the hole anyway).

Unfortunately, the logic mmap() uses to pick a valid address for anonymous
mappings needs work, as it will only try to find an address higher than the
hint, which causes all mmap() with a hint in the hole to fail on vax. This
will be improved later.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.1 2005/04/19 21:30:18 miod Exp $	*/
a101 1
void		pmap_proc_iflush(struct proc *, vaddr_t, vsize_t);
@


1.1
log
@As a late birthday present, a preliminary port to the Solbourne IDT systems
(S3000, S4000 and S4000DX).

Currently limited to diskless and serial console, and userland has issues.
Things will get better in the near future.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d75 1
@

