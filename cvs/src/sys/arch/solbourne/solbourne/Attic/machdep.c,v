head	1.47;
access;
symbols
	OPENBSD_5_8:1.46.0.6
	OPENBSD_5_8_BASE:1.46
	OPENBSD_5_7:1.46.0.2
	OPENBSD_5_7_BASE:1.46
	OPENBSD_5_6:1.42.0.4
	OPENBSD_5_6_BASE:1.42
	OPENBSD_5_5:1.27.0.4
	OPENBSD_5_5_BASE:1.27
	OPENBSD_5_4:1.25.0.4
	OPENBSD_5_4_BASE:1.25
	OPENBSD_5_3:1.25.0.2
	OPENBSD_5_3_BASE:1.25
	OPENBSD_5_2:1.22.0.2
	OPENBSD_5_2_BASE:1.22
	OPENBSD_5_1_BASE:1.21
	OPENBSD_5_1:1.21.0.4
	OPENBSD_5_0:1.21.0.2
	OPENBSD_5_0_BASE:1.21
	OPENBSD_4_9:1.16.0.4
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.16.0.2
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.14.0.2
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.10.0.4
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.8.0.2
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.7.0.2
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.5.0.2
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.4.0.2
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.2.0.4
	OPENBSD_4_1_BASE:1.2
	OPENBSD_4_0:1.2.0.2
	OPENBSD_4_0_BASE:1.2
	OPENBSD_3_9:1.1.0.4
	OPENBSD_3_9_BASE:1.1
	OPENBSD_3_8:1.1.0.2
	OPENBSD_3_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.47
date	2015.12.01.08.13.30;	author deraadt;	state dead;
branches;
next	1.46;
commitid	pJfT5kYsmeGT25jh;

1.46
date	2015.01.16.20.17.07;	author kettenis;	state Exp;
branches;
next	1.45;
commitid	zUWZO3hFvUM3SNEn;

1.45
date	2014.12.10.15.29.53;	author mikeb;	state Exp;
branches;
next	1.44;
commitid	qHQiR2HLROzvZr7B;

1.44
date	2014.11.16.12.30.58;	author deraadt;	state Exp;
branches;
next	1.43;
commitid	yv0ECmCdICvq576h;

1.43
date	2014.09.20.09.28.24;	author kettenis;	state Exp;
branches;
next	1.42;
commitid	IFRB8AkvBMXMTAKW;

1.42
date	2014.07.21.17.25.47;	author uebayasi;	state Exp;
branches;
next	1.41;
commitid	7QO4UJr3EKVAMc8t;

1.41
date	2014.07.13.22.53.39;	author uebayasi;	state Exp;
branches;
next	1.40;
commitid	wsdp3qtXGjMj98oD;

1.40
date	2014.07.13.22.13.07;	author uebayasi;	state Exp;
branches;
next	1.39;
commitid	qYPOd6Qi4aRBKldK;

1.39
date	2014.07.12.18.44.42;	author tedu;	state Exp;
branches;
next	1.38;
commitid	uKVPYMN2MLxdZxzH;

1.38
date	2014.07.11.22.28.05;	author uebayasi;	state Exp;
branches;
next	1.37;
commitid	fOXKrBuMmlMGQdd4;

1.37
date	2014.07.10.21.46.03;	author mpi;	state Exp;
branches;
next	1.36;
commitid	iYq3Z1ZWDKR3sS9G;

1.36
date	2014.07.10.20.15.27;	author uebayasi;	state Exp;
branches;
next	1.35;
commitid	YzvTa4t6mddz7Mh4;

1.35
date	2014.07.10.13.34.32;	author uebayasi;	state Exp;
branches;
next	1.34;
commitid	xpsLTYRIkonFtkr1;

1.34
date	2014.07.10.12.13.49;	author uebayasi;	state Exp;
branches;
next	1.33;
commitid	aofvn6ceiucgjg4N;

1.33
date	2014.05.31.15.49.28;	author mpi;	state Exp;
branches;
next	1.32;
commitid	eA4Y0YE1IUzj6hpW;

1.32
date	2014.05.30.13.46.16;	author mpi;	state Exp;
branches;
next	1.31;

1.31
date	2014.05.25.13.57.48;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2014.03.26.05.23.42;	author guenther;	state Exp;
branches;
next	1.29;

1.29
date	2014.03.22.06.05.45;	author guenther;	state Exp;
branches;
next	1.28;

1.28
date	2014.03.13.03.52.55;	author dlg;	state Exp;
branches;
next	1.27;

1.27
date	2013.11.20.23.57.07;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2013.09.28.12.40.32;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2012.12.02.07.03.31;	author guenther;	state Exp;
branches;
next	1.24;

1.24
date	2012.10.08.21.47.50;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2012.08.22.13.33.32;	author okan;	state Exp;
branches;
next	1.22;

1.22
date	2012.03.23.15.51.26;	author guenther;	state Exp;
branches;
next	1.21;

1.21
date	2011.07.05.04.48.02;	author guenther;	state Exp;
branches;
next	1.20;

1.20
date	2011.06.26.22.40.00;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2011.06.05.19.41.08;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2011.04.18.21.44.55;	author guenther;	state Exp;
branches;
next	1.17;

1.17
date	2011.04.15.04.52.40;	author guenther;	state Exp;
branches;
next	1.16;

1.16
date	2010.07.02.19.57.14;	author tedu;	state Exp;
branches;
next	1.15;

1.15
date	2010.06.27.13.28.47;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2009.08.11.19.17.17;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2009.08.11.18.46.32;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2009.08.09.10.40.18;	author blambert;	state Exp;
branches;
next	1.11;

1.11
date	2009.08.02.16.28.39;	author beck;	state Exp;
branches;
next	1.10;

1.10
date	2009.06.15.17.01.26;	author beck;	state Exp;
branches;
next	1.9;

1.9
date	2009.06.03.21.30.20;	author beck;	state Exp;
branches;
next	1.8;

1.8
date	2009.02.04.17.19.17;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2008.05.03.20.18.24;	author martin;	state Exp;
branches;
next	1.6;

1.6
date	2008.04.09.16.58.10;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2008.01.23.16.37.57;	author jsing;	state Exp;
branches;
next	1.4;

1.4
date	2007.05.29.20.36.48;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2007.05.26.20.26.51;	author pedro;	state Exp;
branches;
next	1.2;

1.2
date	2006.04.15.17.36.47;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2005.04.19.21.30.18;	author miod;	state Exp;
branches;
next	;


desc
@@


1.47
log
@Send solbourne to where the ...........
@
text
@/*	$OpenBSD: machdep.c,v 1.46 2015/01/16 20:17:07 kettenis Exp $	*/
/*	OpenBSD: machdep.c,v 1.105 2005/04/11 15:13:01 deraadt Exp 	*/

/*
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
 *
 * All advertising materials mentioning features or use of this software
 * must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Lawrence Berkeley Laboratory.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)machdep.c	8.6 (Berkeley) 1/14/94
 */

#include <sys/param.h>
#include <sys/signal.h>
#include <sys/signalvar.h>
#include <sys/proc.h>
#include <sys/user.h>
#include <sys/buf.h>
#include <sys/device.h>
#include <sys/reboot.h>
#include <sys/systm.h>
#include <sys/conf.h>
#include <sys/file.h>
#include <sys/timeout.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/mount.h>
#include <sys/msgbuf.h>
#include <sys/syscallargs.h>
#include <sys/exec.h>
#include <sys/sysctl.h>
#include <sys/extent.h>

#include <net/if.h>
#include <uvm/uvm.h>

#include <dev/rndvar.h>

#include <machine/autoconf.h>
#include <machine/frame.h>
#include <machine/cpu.h>
#include <machine/pmap.h>
#include <machine/oldmon.h>
#include <machine/bsd_openprom.h>

#include <machine/idt.h>
#include <machine/kap.h>
#include <machine/prom.h>

#include <sparc/sparc/asm.h>
#include <sparc/sparc/cache.h>
#include <sparc/sparc/cpuvar.h>

#include "auxreg.h"

#include <sparc/sparc/intreg.h>

struct vm_map *exec_map = NULL;
struct vm_map *phys_map = NULL;

int	physmem;

/* sysctl settable */
int	sparc_led_blink = 1;

/*
 * safepri is a safe priority for sleep to set for a spin-wait
 * during autoconfiguration or after a panic.
 */
int   safepri = 0;

/*
 * dvmamap is used to manage DVMA memory. Note: this coincides with
 * the memory range in `phys_map' (which is mostly a place-holder).
 */
vaddr_t dvma_base, dvma_end;
struct extent *dvmamap_extent;

void	dumpsys(void);
static int kap_maskcheck(void);

/*
 * Machine-dependent startup code
 */
void
cpu_startup()
{
#ifdef DEBUG
	extern int pmapdebug;
	int opmapdebug = pmapdebug;
#endif
	vaddr_t minaddr, maxaddr;
	extern struct user *proc0paddr;

#ifdef DEBUG
	pmapdebug = 0;
#endif

	/*
	 * fix message buffer mapping
	 */
	pmap_map(MSGBUF_VA, MSGBUF_PA, MSGBUF_PA + MSGBUFSIZE,
	    PROT_READ | PROT_WRITE);
	initmsgbuf((caddr_t)(MSGBUF_VA + (CPU_ISSUN4 ? 4096 : 0)), MSGBUFSIZE);

	proc0.p_addr = proc0paddr;

	/* I would print this earlier, but I want it in the message buffer */
	if (kap_maskcheck() == 0) {
		printf("WARNING: KAP M2C3 or earlier mask detected.\n"
"THE PROCESSOR IN THIS MACHINE SUFFERS FROM SEVERE HARDWARE ISSUES.\n"
"M2C3 PROCESSORS MAY RUN RELIABLY ENOUGH, OLDER WILL DEFINITELY NOT.\n\n");
	}

	/*
	 * Good {morning,afternoon,evening,night}.
	 */
	printf(version);
	/*identifycpu();*/
	printf("real mem = %d (%dMB)\n", ptoa(physmem),
	    ptoa(physmem) / 1024 / 1024);

	/*
	 * Allocate a submap for exec arguments.  This map effectively
	 * limits the number of processes exec'ing at any time.
	 */
	minaddr = vm_map_min(kernel_map);
	exec_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
				 16*NCARGS, VM_MAP_PAGEABLE, FALSE, NULL);

	/*
	 * Allocate a map for physio.  Others use a submap of the kernel
	 * map, but we want one completely separate, even though it uses
	 * the same pmap.
	 */
	dvma_base = CPU_ISSUN4M ? DVMA4M_BASE : DVMA_BASE;
	dvma_end = CPU_ISSUN4M ? DVMA4M_END : DVMA_END;
	phys_map = uvm_map_create(pmap_kernel(), dvma_base, dvma_end,
	    VM_MAP_INTRSAFE);
	if (phys_map == NULL)
		panic("unable to create DVMA map");

	/*
	 * Allocate DVMA space and dump into a privately managed
	 * extent for double mappings which is usable from
	 * interrupt contexts.
	 */
	if (uvm_km_valloc_wait(phys_map, (dvma_end-dvma_base)) != dvma_base)
		panic("unable to allocate from DVMA map");
	dvmamap_extent = extent_create("dvmamap", dvma_base, dvma_end,
				       M_DEVBUF, NULL, 0, EX_NOWAIT);
	if (dvmamap_extent == 0)
		panic("unable to allocate extent for dvma");

#ifdef DEBUG
	pmapdebug = opmapdebug;
#endif
	printf("avail mem = %lu (%luMB)\n", ptoa(uvmexp.free),
	    ptoa(uvmexp.free) / 1024 / 1024);

	/*
	 * Set up buffers, so they can be used to read disk labels.
	 */
	bufinit();

	/* Early interrupt handlers initialization */
	intr_init();
}

/*
 * Set up registers on exec.
 *
 * XXX this entire mess must be fixed
 */
/* ARGSUSED */
void
setregs(p, pack, stack, retval)
	struct proc *p;
	struct exec_package *pack;
	u_long stack;
	register_t *retval;
{
	struct trapframe *tf = p->p_md.md_tf;
	struct fpstate *fs;
	int psr;

	/*
	 * Setup the process StackGhost cookie which will be XORed into
	 * the return pointer as register windows are over/underflowed
	 */
	p->p_addr->u_pcb.pcb_wcookie = arc4random();

	/* The cookie needs to guarantee invalid alignment after the XOR */
	switch (p->p_addr->u_pcb.pcb_wcookie % 3) {
	case 0: /* Two lsb's already both set except if the cookie is 0 */
		p->p_addr->u_pcb.pcb_wcookie |= 0x3;
		break;
	case 1: /* Set the lsb */
		p->p_addr->u_pcb.pcb_wcookie = 1 |
			(p->p_addr->u_pcb.pcb_wcookie & ~0x3);
		break;
	case 2: /* Set the second most lsb */
		p->p_addr->u_pcb.pcb_wcookie = 2 |
			(p->p_addr->u_pcb.pcb_wcookie & ~0x3);
		break;
	}

	/* Don't allow misaligned code by default */
	p->p_md.md_flags &= ~MDP_FIXALIGN;

	/*
	 * The syscall will ``return'' to npc or %g7 or %g2; set them all.
	 * Set the rest of the registers to 0 except for %o6 (stack pointer,
	 * built in exec()) and psr (retain CWP and PSR_S bits).
	 */
	psr = tf->tf_psr & (PSR_S | PSR_CWP);
	if ((fs = p->p_md.md_fpstate) != NULL) {
		/*
		 * We hold an FPU state.  If we own *the* FPU chip state
		 * we must get rid of it, and the only way to do that is
		 * to save it.  In any case, get rid of our FPU state.
		 */
		if (p == cpuinfo.fpproc) {
			savefpstate(fs);
			cpuinfo.fpproc = NULL;
		}
		free((void *)fs, M_SUBPROC, 0);
		p->p_md.md_fpstate = NULL;
	}
	bzero((caddr_t)tf, sizeof *tf);
	tf->tf_psr = psr;
	tf->tf_npc = pack->ep_entry & ~3;
	tf->tf_global[2] = tf->tf_global[7] = tf->tf_npc;
	/* XXX exec of init(8) returns via proc_trampoline() */
	if (p->p_pid == 1) {
		tf->tf_pc = tf->tf_npc;
		tf->tf_npc += 4;
	}
	stack -= sizeof(struct rwindow);
	tf->tf_out[6] = stack;
	retval[1] = 0;
}

#ifdef DEBUG
int sigdebug = 0;
pid_t sigpid = 0;
#define SDB_FOLLOW	0x01
#define SDB_KSTACK	0x02
#define SDB_FPSTATE	0x04
#endif

struct sigframe {
	int	sf_signo;		/* signal number */
	siginfo_t *sf_sip;		/* points to siginfo_t */
	int	sf_xxx;			/* placeholder */
	caddr_t	sf_addr;		/* SunOS compat */
	struct	sigcontext sf_sc;	/* actual sigcontext */
	siginfo_t sf_si;
};

/*
 * machine dependent system variables.
 */
int
cpu_sysctl(name, namelen, oldp, oldlenp, newp, newlen, p)
	int *name;
	u_int namelen;
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
	struct proc *p;
{
#if (NLED > 0) || (NAUXREG > 0) || (NSCF > 0)
	int oldval;
	int ret;
#endif
	extern int v8mul;

	/* all sysctl names are this level are terminal */
	if (namelen != 1)
		return (ENOTDIR);	/* overloaded */

	switch (name[0]) {
	case CPU_LED_BLINK:
#if (NLED > 0) || (NAUXREG > 0) || (NSCF > 0)
		oldval = sparc_led_blink;
		ret = sysctl_int(oldp, oldlenp, newp, newlen,
		    &sparc_led_blink);

		/*
		 * If we were false and are now true, call led_blink().
		 * led_blink() itself will catch the other case.
		 */
		if (!oldval && sparc_led_blink > oldval) {
#if NAUXREG > 0
			led_blink((caddr_t *)0);
#endif
#if NLED > 0
			led_cycle((caddr_t *)led_sc);
#endif
#if NSCF > 0
			scfblink((caddr_t *)0);
#endif
		}

		return (ret);
#else
		return (EOPNOTSUPP);
#endif
	case CPU_CPUTYPE:
		return (sysctl_rdint(oldp, oldlenp, newp, cputyp));
	case CPU_V8MUL:
		return (sysctl_rdint(oldp, oldlenp, newp, v8mul));
	default:
		return (EOPNOTSUPP);
	}
	/* NOTREACHED */
}

/*
 * Send an interrupt to process.
 */
void
sendsig(catcher, sig, mask, code, type, val)
	sig_t catcher;
	int sig, mask;
	u_long code;
	int type;
	union sigval val;
{
	struct proc *p = curproc;
	struct sigacts *psp = p->p_p->ps_sigacts;
	struct sigframe *fp;
	struct trapframe *tf;
	int caddr, oldsp, newsp;
	struct sigframe sf;

	tf = p->p_md.md_tf;
	oldsp = tf->tf_out[6];

	/*
	 * Compute new user stack addresses, subtract off
	 * one signal frame, and align.
	 */
	if ((p->p_sigstk.ss_flags & SS_DISABLE) == 0 &&
	    !sigonstack(oldsp) && (psp->ps_sigonstack & sigmask(sig)))
		fp = (struct sigframe *)(p->p_sigstk.ss_sp +
					 p->p_sigstk.ss_size);
	else
		fp = (struct sigframe *)oldsp;
	fp = (struct sigframe *)((int)(fp - 1) & ~7);

#ifdef DEBUG
	if ((sigdebug & SDB_KSTACK) && p->p_pid == sigpid)
		printf("sendsig: %s[%d] sig %d newusp %p scp %p\n",
		    p->p_comm, p->p_pid, sig, fp, &fp->sf_sc);
#endif
	/*
	 * Now set up the signal frame.  We build it in kernel space
	 * and then copy it out.  We probably ought to just build it
	 * directly in user space....
	 */
	bzero(&sf, sizeof(sf));
	sf.sf_signo = sig;
	sf.sf_sip = NULL;

	/*
	 * Build the signal context to be used by sigreturn.
	 */
	sf.sf_sc.sc_mask = mask;
	sf.sf_sc.sc_sp = oldsp;
	sf.sf_sc.sc_pc = tf->tf_pc;
	sf.sf_sc.sc_npc = tf->tf_npc;
	sf.sf_sc.sc_psr = tf->tf_psr;
	sf.sf_sc.sc_g1 = tf->tf_global[1];
	sf.sf_sc.sc_o0 = tf->tf_out[0];

	if (psp->ps_siginfo & sigmask(sig)) {
		sf.sf_sip = &fp->sf_si;
		initsiginfo(&sf.sf_si, sig, code, type, val);
	}

	/*
	 * Put the stack in a consistent state before we whack away
	 * at it.  Note that write_user_windows may just dump the
	 * registers into the pcb; we need them in the process's memory.
	 * We also need to make sure that when we start the signal handler,
	 * its %i6 (%fp), which is loaded from the newly allocated stack area,
	 * joins seamlessly with the frame it was in when the signal occurred,
	 * so that the debugger and _longjmp code can back up through it.
	 */
	newsp = (int)fp - sizeof(struct rwindow);
	write_user_windows();
	/* XXX do not copyout siginfo if not needed */
	if (rwindow_save(p) || copyout((caddr_t)&sf, (caddr_t)fp, sizeof sf) ||
	    copyout(&oldsp, &((struct rwindow *)newsp)->rw_in[6],
	      sizeof(register_t)) != 0) {
		/*
		 * Process has trashed its stack; give it an illegal
		 * instruction to halt it in its tracks.
		 */
#ifdef DEBUG
		if ((sigdebug & SDB_KSTACK) && p->p_pid == sigpid)
			printf("sendsig: window save or copyout error\n");
#endif
		sigexit(p, SIGILL);
		/* NOTREACHED */
	}
#ifdef DEBUG
	if (sigdebug & SDB_FOLLOW)
		printf("sendsig: %s[%d] sig %d scp %p\n",
		       p->p_comm, p->p_pid, sig, &fp->sf_sc);
#endif
	/*
	 * Arrange to continue execution at the code copied out in exec().
	 * It needs the function to call in %g1, and a new stack pointer.
	 */
	caddr = p->p_p->ps_sigcode;
	tf->tf_global[1] = (int)catcher;
	tf->tf_pc = caddr;
	tf->tf_npc = caddr + 4;
	tf->tf_out[6] = newsp;
#ifdef DEBUG
	if ((sigdebug & SDB_KSTACK) && p->p_pid == sigpid)
		printf("sendsig: about to return to catcher\n");
#endif
}

/*
 * System call to cleanup state after a signal
 * has been taken.  Reset signal mask and
 * stack state from context left by sendsig (above),
 * and return to the given trap frame (if there is one).
 * Check carefully to make sure that the user has not
 * modified the state to gain improper privileges or to cause
 * a machine fault.
 */
/* ARGSUSED */
int
sys_sigreturn(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_sigreturn_args /* {
		syscallarg(struct sigcontext *) sigcntxp;
	} */ *uap = v;
	struct sigcontext ksc;
	struct trapframe *tf;
	int error;

	/* First ensure consistent stack state (see sendsig). */
	write_user_windows();
	if (rwindow_save(p))
		sigexit(p, SIGILL);
#ifdef DEBUG
	if (sigdebug & SDB_FOLLOW)
		printf("sigreturn: %s[%d], sigcntxp %p\n",
		    p->p_comm, p->p_pid, SCARG(uap, sigcntxp));
#endif
	if ((error = copyin(SCARG(uap, sigcntxp), &ksc, sizeof(ksc))) != 0)
		return (error);
	tf = p->p_md.md_tf;
	/*
	 * Only the icc bits in the psr are used, so it need not be
	 * verified.  pc and npc must be multiples of 4.  This is all
	 * that is required; if it holds, just do it.
	 */
	if (((ksc.sc_pc | ksc.sc_npc) & 3) != 0)
		return (EINVAL);
	/* take only psr ICC field */
	tf->tf_psr = (tf->tf_psr & ~PSR_ICC) | (ksc.sc_psr & PSR_ICC);
	tf->tf_pc = ksc.sc_pc;
	tf->tf_npc = ksc.sc_npc;
	tf->tf_global[1] = ksc.sc_g1;
	tf->tf_out[0] = ksc.sc_o0;
	tf->tf_out[6] = ksc.sc_sp;
	p->p_sigmask = ksc.sc_mask & ~sigcantmask;
	return (EJUSTRETURN);
}

int	waittime = -1;

__dead void
boot(int howto)
{
	int i;
	static char str[4];	/* room for "-sd\0" */

	if (cold) {
		if ((howto & RB_USERREQ) == 0)
			howto |= RB_HALT;
		goto haltsys;
	}

	fb_unblank();
	boothowto = howto;
	if ((howto & RB_NOSYNC) == 0 && waittime < 0) {
		waittime = 0;
		vfs_shutdown();

		if ((howto & RB_TIMEBAD) == 0) {
			resettodr();
		} else {
			printf("WARNING: not updating battery clock\n");
		}
	}
	if_downall();

	uvm_shutdown();
	splhigh();
	cold = 1;

	if ((howto & RB_DUMP) != 0)
		dumpsys();

haltsys:
	config_suspend_all(DVACT_POWERDOWN);

	if ((howto & RB_HALT) != 0 || (howto & RB_POWERDOWN) != 0) {
		printf("halted\n\n");
		romhalt();
	}

	printf("rebooting\n\n");
	i = 1;
	if ((howto & RB_SINGLE) != 0)
		str[i++] = 's';
	if ((howto & RB_KDB) != 0)
		str[i++] = 'd';
	if (i > 1) {
		str[0] = '-';
		str[i] = 0;
	} else
		str[0] = 0;
	romboot(str);
	for (;;) ;
	/* NOTREACHED */
}

/* XXX - needs to be written */
void
dumpconf(void)
{
}

/*
 * Write a crash dump.
 */
void
dumpsys()
{
	printf("dump: TBD\n");
}

/*
 * Map an I/O device given physical address and size in bytes, e.g.,
 *
 *	mydev = (struct mydev *)mapdev(myioaddr, 0,
 *				       0, sizeof(struct mydev));
 *
 * See also machine/autoconf.h.
 *
 * XXXART - verify types (too tired now).
 */
void *
mapdev(phys, virt, offset, size)
	struct rom_reg *phys;
	int offset, virt, size;
{
	vaddr_t va;
	paddr_t pa;
	void *ret;
	static vaddr_t iobase;
	unsigned int pmtype;

	if (iobase == NULL)
		iobase = IODEV_BASE;

	size = round_page(size);
	if (size == 0)
		panic("mapdev: zero size");

	if (virt)
		va = trunc_page(virt);
	else {
		va = iobase;
		iobase += size;
		if (iobase > IODEV_END)	/* unlikely */
			panic("mapiodev");
	}
	ret = (void *)(va | (((u_long)phys->rr_paddr + offset) & PGOFSET));
			/* note: preserve page offset */

	pa = trunc_page((vaddr_t)phys->rr_paddr + offset);
	pmtype = PMAP_IOENC(phys->rr_iospace);

	do {
		pmap_kenter_pa(va, pa | pmtype | PMAP_NC,
		    PROT_READ | PROT_WRITE);
		va += PAGE_SIZE;
		pa += PAGE_SIZE;
	} while ((size -= PAGE_SIZE) > 0);
	pmap_update(pmap_kernel());
	return (ret);
}

/*
 * Soft interrupt handling
 */

int	kap_sir;

void
ienab_bis(int bis)
{
	int s;
	int mask = 1 << (bis - 1);
	u_int32_t icr;

	s = splhigh();
	if (kap_sir < mask) {
		/*
		 * We become the most important bit in kap_sir. Reprogram
		 * the GLU_ICR soft interrupt dispatcher.
		 */
		icr = lda(GLU_ICR, ASI_PHYS_IO) >> 24;
		icr = (icr & ~GICR_DISPATCH_MASK) | bis;
		sta(GLU_ICR, ASI_PHYS_IO, icr << 24);
	}
	kap_sir |= mask;
	splx(s);
}

/*
 * minimal console routines
 */

#include <sys/conf.h>
#include <dev/cons.h>

cons_decl(early);

struct consdev consdev_early = {
	earlycnprobe,
	earlycninit,
	earlycngetc,
	earlycnputc,
	nullcnpollc
};

struct consdev *cn_tab = &consdev_early;

void
earlycnprobe(struct consdev *cn)
{
	cn->cn_dev = makedev(0, 0);
	cn->cn_pri = CN_MIDPRI;
}

void
earlycninit(struct consdev *cn)
{
}

/* getc, putc in locore.s */

int	kapmask_m2c4;
static void kap_maskfault(void);

void
kap_maskfault()
{
	kapmask_m2c4 = 1;
}

/*
 * This routine checks whether we are running on a M2C4 or later mask, by
 * checking for M2C4 behaviour.
 *
 * After mapping a kernel text page with the ``byte-writeable shared''
 * memory attribute, we will attempt to execute code from the new mapping.
 *
 * On M2C4 and later masks, this will cause a text fault, supposedly for
 * us to be able to invalidate the instruction cache first, before resuming
 * execution; while M2C3 and earlier masks will not fault.
 *
 * Since OpenBSD does not use BWS pages and does explicit instruction cache
 * invalidation in ddb and the ptrace interface, this fault never happens in
 * real life. mem_access_fault() in trap.c knows this and will direct
 * execution to kap_maskfault(). Since the test code we have been invoking
 * is a simple empty function, kap_maskfault() will return here.
 *
 * XXX Find some way to identify M2C3, which _should_ run.
 */
int
kap_maskcheck()
{
	extern void masktest(void);
	void (*test)(void);

	pmap_enter(pmap_kernel(), TMPMAP_VA,
	    trunc_page((vaddr_t)masktest) | PMAP_BWS, PROT_READ, 0);
	test = (void (*)(void))(TMPMAP_VA + ((vaddr_t)masktest & PAGE_MASK));

	cpcb->pcb_onfault = (caddr_t)kap_maskfault;
	(*test)();
	cpcb->pcb_onfault = NULL;

	pmap_remove(pmap_kernel(), TMPMAP_VA, TMPMAP_VA + PAGE_SIZE);

	return (kapmask_m2c4);
}
@


1.46
log
@Don't bother to initialize %g1; we don't do this on sparc either.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.45 2014/12/10 15:29:53 mikeb Exp $	*/
@


1.45
log
@retire shutdown hooks; ok deraadt, krw
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.44 2014/11/16 12:30:58 deraadt Exp $	*/
a263 1
	tf->tf_global[1] = (int)PS_STRINGS;
@


1.44
log
@Replace a plethora of historical protection options with just
PROT_NONE, PROT_READ, PROT_WRITE, and PROT_EXEC from mman.h.
PROT_MASK is introduced as the one true way of extracting those bits.
Remove UVM_ADV_* wrapper, using the standard names.
ok doug guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.43 2014/09/20 09:28:24 kettenis Exp $	*/
a550 1
	doshutdownhooks();
@


1.43
log
@Use config_suspend_all(9).

ok mpi@@, uebayasi@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.42 2014/07/21 17:25:47 uebayasi Exp $	*/
d133 2
a134 1
	pmap_map(MSGBUF_VA, MSGBUF_PA, MSGBUF_PA + MSGBUFSIZE, UVM_PROT_RW);
d633 2
a634 1
		pmap_kenter_pa(va, pa | pmtype | PMAP_NC, UVM_PROT_RW);
d737 1
a737 1
	    trunc_page((vaddr_t)masktest) | PMAP_BWS, UVM_PROT_READ, 0);
@


1.42
log
@boot(9): Reduce annoying style diffs

- Always use either: ((x & RB_XXX) != 0) or ((x & RB_XXX) == 0) in boolean
  context (mostly if (x), or x ? y : z)
  - prom_halt() in alpha is confirmed to take int as boolean

Converted by coccinelle.  No functional change intended.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a520 1
	struct device *mainbus;
d551 1
a551 3
	mainbus = device_mainbus();
	if (mainbus != NULL)
		config_suspend(mainbus, DVACT_POWERDOWN);
@


1.41
log
@boot(9): Cosmetic changes to improve diff'ability.
@
text
@d547 1
a547 1
	if (howto & RB_DUMP)
d556 1
a556 1
	if ((howto & RB_HALT) || (howto & RB_POWERDOWN)) {
d563 1
a563 1
	if (howto & RB_SINGLE)
d565 1
a565 1
	if (howto & RB_KDB)
@


1.40
log
@Cosmetic changes to reduce diffs.
@
text
@d573 2
a574 1
	/*NOTREACHED*/
@


1.39
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.38 2014/07/11 22:28:05 uebayasi Exp $	*/
d544 1
a544 1
	splhigh();		/* Disable interrupts. */
@


1.38
log
@boot(9): Undo curproc-overriding hacks

Some (not all) boot(9) implementations have ancient hacks which overrides if
(curproc == NULL).  This was probably made in a hope to forcibly proceed
various clean-shutdown related code, including VFS shutdown.  Let's clarify
that clean-shutdown needs process context; it is impossible to cleanly shutdown
VFS from within e.g. a panic in SPL_HIGH.

OK kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d257 1
a257 1
		free((void *)fs, M_SUBPROC);
@


1.37
log
@Set cold to 1 before executing the DVACT_POWERDOWN handlers when halting or
rebooting a machine, like it is done in the hibernate case.

At least some USB host controller drivers rely on this to busy way instead
of sleeping.  Avoid a panic on macppc with an uhci(4) cardbus plugged in.

ok deraadt@@, uebayashi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.36 2014/07/10 20:15:27 uebayasi Exp $	*/
a531 5
		extern struct proc proc0;

		/* make sure there's a process to charge for I/O in sync() */
		if (curproc == NULL)
			curproc = &proc0;
@


1.36
log
@boot(9): Remove comments about RB_*, "cold", and savectx()

Again remove slightly different comments to reduce diffs.  These will be
re-added once boot() become MI and its specification is clearly re-defined.

OK miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d549 2
a550 1
	(void) splhigh();		/* ??? */
@


1.35
log
@boot(): Remove comments about RB_TIMEBAD to reduce diffs

RB_TIMEBAD is documented well enough that the comment is not needed.  sparc64
does slightly different and its comment is left with XXX.

OK deraadt@@ miod@@
@
text
@a522 1
	/* If system is cold, just halt. */
a523 1
		/* (Unless the user explicitly asked for reboot.) */
@


1.34
log
@boot(): Unify declarations

OK deraadt@@
@
text
@a541 5
		/*
		 * If we've been adjusting the clock, the todr
		 * will be out of synch; adjust it now unless
		 * the system was sitting in ddb.
		 */
@


1.33
log
@Revert previous diff setting cold to 1 on shutdown because it breaks machine
with softraid(4) disks.

softraid(4) is the last real consumer of the doshutdownhooks(9) API and it is
not trivial to convert its hook to a DVACT_POWERDOWN handler since the latter
does not allow to sleep.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.32 2014/05/30 13:46:16 mpi Exp $	*/
d516 2
a517 3
void
boot(howto)
	int howto;
@


1.32
log
@Set cold to 1 before executing the DVACT_POWERDOWN handlers when halting or
rebooting a machine, like it is done in the hibernate case.

At least some USB host controller drivers rely on this to busy way instead
of sleeping.  Avoid a panic on macppc with an uhci(4) cardbus plugged in.

ok deraadt@@, uebayashi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.31 2014/05/25 13:57:48 deraadt Exp $	*/
d557 1
a557 2
	splhigh();		/* Disable interrupts. */
	cold = 1;
@


1.31
log
@Turn on blinky things by default, very useful here
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.30 2014/03/26 05:23:42 guenther Exp $	*/
d557 2
a558 1
	(void) splhigh();		/* ??? */
@


1.30
log
@Move p_emul and p_sigcode from proc to process.
Tweak the handling of ktrace EMUL when changing ktracing: only
generate one per process (not one per thread) and pass the correct
proc pointer down to the VFS layer.  Permit generating of NAMI and
CSW records inside ktrace(2) itself.

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.29 2014/03/22 06:05:45 guenther Exp $	*/
d95 1
a95 1
int	sparc_led_blink = 0;
@


1.29
log
@Move p_sigacts from struct proc to struct process.

testing help mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.28 2014/03/13 03:52:55 dlg Exp $	*/
d450 1
a450 1
	caddr = p->p_sigcode;
@


1.28
log
@get rid of the assumption that the head of the alldevs list is the
"mainbus" device. this breaks when mpath is enabled because it
attaches before mainbus and therefore takes the head position.

have autoconf provide device_mainbus() which looks up mainbus_cd,
and use that instead.

discussed with deraadt who just wants mpath stuff to move forward
despite there being many ways to shine this particular turd.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.27 2013/11/20 23:57:07 miod Exp $	*/
d364 1
a364 1
	struct sigacts *psp = p->p_sigacts;
@


1.27
log
@Update comments mentioning `resource maps' to mention `extents' instead.
Resource maps have been removed more than 10 years ago, it's about time to
update comments to better match reality.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.26 2013/09/28 12:40:32 miod Exp $	*/
d522 1
d564 3
a566 2
	if (!TAILQ_EMPTY(&alldevs))
		config_suspend(TAILQ_FIRST(&alldevs), DVACT_POWERDOWN);
@


1.26
log
@In boot(), do not iterate over alldevs if it's empty (i.e. halting from ddb
with ddb entered early with boot -d or from UKC).
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.25 2012/12/02 07:03:31 guenther Exp $	*/
d175 1
a175 1
	 * resource map for double mappings which is usable from
@


1.25
log
@Determine whether we're currently on the alternative signal stack
dynamically, by comparing the stack pointer against the altstack
base and size, so that you get the correct answer if you longjmp
out of the signal handler, as tested by regress/sys/kern/stackjmp/.
Also, fix alt stack handling on vax, where it was completely broken.

Testing and corrections by miod@@, krw@@, tobiasu@@, pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.24 2012/10/08 21:47:50 deraadt Exp $	*/
d563 2
a564 1
	config_suspend(TAILQ_FIRST(&alldevs), DVACT_POWERDOWN);
@


1.24
log
@Revamp the sequences for suspend/hibernate -> resume so that the code
paths are reflexive.  It is now possible to fail part-way through a
suspend sequence, and recover along the resume code path.
Split DVACT_SUSPEND by adding a new DVACT_POWERDOWN method is used
after hibernate (and suspend too) to finish the job.  Some drivers
must be converted at the same time to use this instead of shutdown hooks
(the others will follow at a later time)
ok kettenis mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.23 2012/08/22 13:33:32 okan Exp $	*/
d367 1
a367 1
	int caddr, oonstack, oldsp, newsp;
d372 1
a372 1
	oonstack = p->p_sigstk.ss_flags & SS_ONSTACK;
d377 2
a378 2
	if ((p->p_sigstk.ss_flags & SS_DISABLE) == 0 && !oonstack &&
	    (psp->ps_sigonstack & sigmask(sig))) {
d381 1
a381 2
		p->p_sigstk.ss_flags |= SS_ONSTACK;
	} else
d395 1
a401 1
	sf.sf_sc.sc_onstack = oonstack;
a509 4
	if (ksc.sc_onstack & 1)
		p->p_sigstk.ss_flags |= SS_ONSTACK;
	else
		p->p_sigstk.ss_flags &= ~SS_ONSTACK;
@


1.23
log
@sigpid should be of type pid_t (only visable with DEBUG).

ok miod@@ (who found others to fix as well)
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.22 2012/03/23 15:51:26 guenther Exp $	*/
a566 1
	/* Run any shutdown hooks */
d568 1
@


1.22
log
@Make rusage totals, itimers, and profile settings per-process instead
of per-rthread.  Handling of per-thread tick and runtime counters
inspired by how FreeBSD does it.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.21 2011/07/05 04:48:02 guenther Exp $	*/
d277 1
a277 1
int sigpid = 0;
@


1.21
log
@Recommit the reverted sigacts change now that the NFS use-after-free
problem has been tracked down.  This fixes the sharing of the signal
handling state: shared bits go in sigacts, per-rthread bits goes in
struct proc.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.20 2011/06/26 22:40:00 deraadt Exp $	*/
d541 1
a541 1
		/* XXX protect against curproc->p_stats.foo refs in sync() */
@


1.20
log
@if_downall() cannot be done MI in sys_reboot() because vfs_shutdown()
might need network (ie. nfs).  Move the call to the MD boot() routines.
This cause for boot hangs diagnosed by kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.19 2011/06/05 19:41:08 deraadt Exp $	*/
d372 1
a372 1
	oonstack = psp->ps_sigstk.ss_flags & SS_ONSTACK;
d377 1
a377 1
	if ((psp->ps_flags & SAS_ALTSTACK) && !oonstack &&
d379 3
a381 3
		fp = (struct sigframe *)(psp->ps_sigstk.ss_sp +
					 psp->ps_sigstk.ss_size);
		psp->ps_sigstk.ss_flags |= SS_ONSTACK;
d512 1
a512 1
		p->p_sigacts->ps_sigstk.ss_flags |= SS_ONSTACK;
d514 1
a514 1
		p->p_sigacts->ps_sigstk.ss_flags &= ~SS_ONSTACK;
@


1.19
log
@Move the bufcachepercent setting code to MI locations -- set it to 42%
for now; that is unlikely to hit some of the remaining starvation bugs.
Repair the bufpages calculation too; i386 was doing it ahead of time
(incorrectly) and then re-calculating it.
ok thib
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.18 2011/04/18 21:44:55 guenther Exp $	*/
d65 1
d558 1
@


1.18
log
@Revert the sigacts diff: NFS can apparently retain pointers to processes
until they're zombies and then send them signals (for intr mounts).  Until
that is untangled, the sigacts change is unsafe.  sthen@@ was the victim
for this one
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.16 2010/07/02 19:57:14 tedu Exp $	*/
a89 14

/*
 * Declare these as initialized data so we can patch them.
 */
#ifndef BUFCACHEPERCENT
#define BUFCACHEPERCENT 5
#endif

#ifdef	BUFPAGES
int	bufpages = BUFPAGES;
#else
int	bufpages = 0;
#endif
int	bufcachepercent = BUFCACHEPERCENT;
@


1.17
log
@Correct the sharing of the signal handling state: stuff that should
be shared (p_sigignore, p_sigcatch, P_NOCLDSTOP, P_NOCLDWAIT) moves
to struct sigacts, wihle stuff that should be per rthread (ps_oldmask,
SAS_OLDMASK, ps_sigstk) moves to struct proc.  Treat the coredumping
state bits (ps_sig, ps_code, ps_type, ps_sigval) as per-rthread
until our locking around coredumping is better.

Oh, and remove the old SunOS-compat ps_usertramp member.

"I like the sound of this" tedu@@
@
text
@d385 1
a385 1
	oonstack = p->p_sigstk.ss_flags & SS_ONSTACK;
d390 1
a390 1
	if ((p->p_sigstk.ss_flags & SS_DISABLE) == 0 && !oonstack &&
d392 3
a394 3
		fp = (struct sigframe *)(p->p_sigstk.ss_sp +
					 p->p_sigstk.ss_size);
		p->p_sigstk.ss_flags |= SS_ONSTACK;
d525 1
a525 1
		p->p_sigstk.ss_flags |= SS_ONSTACK;
d527 1
a527 1
		p->p_sigstk.ss_flags &= ~SS_ONSTACK;
@


1.16
log
@remove support for compat_sunos (and m68k4k).  ok deraadt guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.15 2010/06/27 13:28:47 miod Exp $	*/
d385 1
a385 1
	oonstack = psp->ps_sigstk.ss_flags & SS_ONSTACK;
d390 1
a390 1
	if ((psp->ps_flags & SAS_ALTSTACK) && !oonstack &&
d392 3
a394 3
		fp = (struct sigframe *)(psp->ps_sigstk.ss_sp +
					 psp->ps_sigstk.ss_size);
		psp->ps_sigstk.ss_flags |= SS_ONSTACK;
d525 1
a525 1
		p->p_sigacts->ps_sigstk.ss_flags |= SS_ONSTACK;
d527 1
a527 1
		p->p_sigacts->ps_sigstk.ss_flags &= ~SS_ONSTACK;
@


1.15
log
@If you include <uvm/uvm.h>, you do not need to include any other <uvm/uvm_foo.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.14 2009/08/11 19:17:17 miod Exp $	*/
a298 3
#ifdef COMPAT_SUNOS
	struct	sigcontext *sf_scp;	/* points to user addr of sigcontext */
#else
a299 1
#endif
a381 3
#ifdef COMPAT_SUNOS
	extern struct emul emul_sunos;
#endif
a410 7
#ifdef COMPAT_SUNOS
	if (p->p_emul == &emul_sunos) {
		sf.sf_sip = (void *)code;	/* SunOS has "int code" */
		sf.sf_scp = &fp->sf_sc;
		sf.sf_addr = val.sival_ptr;
	}
#endif
d464 2
a465 9
#ifdef COMPAT_SUNOS
	if (psp->ps_usertramp & sigmask(sig)) {
		caddr = (int)catcher;	/* user does his own trampolining */
	} else
#endif
	{
		caddr = p->p_sigcode;
		tf->tf_global[1] = (int)catcher;
	}
a666 15

#ifdef COMPAT_SUNOS
int
cpu_exec_aout_makecmds(p, epp)
	struct proc *p;
	struct exec_package *epp;
{
	int error = ENOEXEC;

	extern int sunos_exec_aout_makecmds(struct proc *, struct exec_package *);
	if ((error = sunos_exec_aout_makecmds(p, epp)) == 0)
		return 0;
	return error;
}
#endif
@


1.14
log
@Do not bother initializing bufpages in the md code if the computation is
exactly the same the mi could will use if bufinit() is invoked with
bufpages == 0.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.13 2009/08/11 18:46:32 miod Exp $	*/
d65 1
a65 1
#include <uvm/uvm_extern.h>
a82 2

#include <uvm/uvm.h>
@


1.13
log
@With the SysV memory allocation changes, allocsys() doesn't do anything
anymore. Get rid of it completely.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.12 2009/08/09 10:40:18 blambert Exp $	*/
a166 7

	/*
	 * Determine how many buffers to allocate.
	 * We allocate bufcachepercent% of memory for buffer space.
	 */
	if (bufpages == 0)
		bufpages = physmem * bufcachepercent / 100;
@


1.12
log
@Rototill system V message queues.

No longer allocate a static amount of memory for messages in MD
boot path; message queues, message metadata, and message data now
all use dynamic memory, which means that runtime sysctls should now
be trivial to implement.

Since I'm going to be around all week to fix any breakage, this should
probably just go in now.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.11 2009/08/02 16:28:39 beck Exp $	*/
a124 1
caddr_t allocsys(caddr_t);
a133 2
	caddr_t v;
	int sz;
a168 12
	 * Find out how much space we need, allocate it,
	 * and then give everything true virtual addresses.
	 */
	sz = (int)allocsys((caddr_t)0);

	if ((v = (caddr_t)uvm_km_alloc(kernel_map, round_page(sz))) == 0)
		panic("startup: no room for tables");

	if (allocsys(v) - v != sz)
		panic("startup: table size inconsistency");

	/*
a219 20
}

/*
 * Allocate space for system data structures.  We are given
 * a starting virtual address and we return a final virtual
 * address; along the way we set each data structure pointer.
 *
 * You call allocsys() with 0 to find out how much space we want,
 * allocate that much and fill it with zeroes, and then call
 * allocsys() again with the correct base virtual address.
 */
caddr_t
allocsys(v)
	caddr_t v;
{

#define	valloc(name, type, num) \
	    v = (caddr_t)(((name) = (type *)v) + (num))

	return (v);
@


1.11
log
@
Dynamic buffer cache support - a re-commit of what was backed out
after c2k9

allows buffer cache to be extended and grow/shrink dynamically

tested by many, ok oga@@, "why not just commit it" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.10 2009/06/15 17:01:26 beck Exp $	*/
a60 3
#ifdef SYSVMSG
#include <sys/msg.h>
#endif
a252 6
#ifdef SYSVMSG
	valloc(msgpool, char, msginfo.msgmax);
	valloc(msgmaps, struct msgmap, msginfo.msgseg);
	valloc(msghdrs, struct msg, msginfo.msgtql);
	valloc(msqids, struct msqid_ds, msginfo.msgmni);
#endif
@


1.10
log
@Back out all the buffer cache changes I committed during c2k9. This reverts three
commits:

1) The sysctl allowing bufcachepercent to be changed at boot time.
2) The change moving the buffer cache hash chains to a red-black tree
3) The dynamic buffer cache (Which depended on the earlier too).

ok on the backout from marco and todd
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.9 2009/06/03 21:30:20 beck Exp $	*/
a191 6

	/* Restrict to at most 25% filled kvm */
	if (bufpages >
	    (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) / PAGE_SIZE / 4) 
		bufpages = (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) /
		    PAGE_SIZE / 4;
@


1.9
log
@add kern.bufcachepercent sysctl to allow adjusting the buffer cache
size on a running system.
ok art@@, oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.8 2009/02/04 17:19:17 miod Exp $	*/
d192 6
@


1.8
log
@Unify memory size reports a bit more: always report size in MB, and report
reserved memory on alpha and hppa on its own line (as done on sgi).
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.7 2008/05/03 20:18:24 martin Exp $	*/
a191 6

	/* Restrict to at most 25% filled kvm */
	if (bufpages >
	    (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) / PAGE_SIZE / 4) 
		bufpages = (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) /
		    PAGE_SIZE / 4;
@


1.7
log
@catch up with curpriority changes and convert to ptoa/atop

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.6 2008/04/09 16:58:10 deraadt Exp $	*/
d171 2
a172 1
	printf("real mem = %d\n", ptoa(physmem));
d234 2
a235 1
	printf("avail mem = %ld\n", ptoa(uvmexp.free));
@


1.6
log
@Add new stub uvm_shutdown() and call it from the right place in MD boot()
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.6 2008/04/09 16:50:29 deraadt Exp $	*/
d171 1
a171 1
	printf("real mem = %d\n", ctob(physmem));
@


1.5
log
@Cleanup cn_pri. Change constants to more meaningful names, rather than
the hp300 related ones currently in use. CN_NORMAL becomes CN_LOWPRI,
CN_INTERNAL becomes CN_MIDPRI and CN_REMOTE becomes CN_HIGHPRI.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.4 2007/05/29 20:36:48 deraadt Exp $	*/
d649 2
@


1.4
log
@start of dumpconf() unification, which one day we can pray will be MI
(and part of setroot); ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.3 2007/05/26 20:26:51 pedro Exp $	*/
d809 1
a809 1
	cn->cn_pri = CN_INTERNAL;
@


1.3
log
@Dynamic buffer cache. Initial diff from mickey@@, okay art@@ beck@@ toby@@
deraadt@@ dlg@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.2 2006/04/15 17:36:47 miod Exp $	*/
d680 1
a680 1
dumpconf()
@


1.2
log
@Sync proc_trampoline() and setregs() logic with sparc.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.1 2005/04/19 21:30:18 miod Exp $	*/
a98 6
#ifdef	NBUF
int	nbuf = NBUF;
#else
int	nbuf = 0;
#endif

a137 1
	unsigned i;
a139 1
	int base, residual;
a144 1
	vsize_t size;
d185 12
a196 46
        /*
         * allocate virtual and physical memory for the buffers.
         */
        size = MAXBSIZE * nbuf;         /* # bytes for buffers */

        /* allocate VM for buffers... area is not managed by VM system */
        if (uvm_map(kernel_map, (vaddr_t *) &buffers, round_page(size),
                    NULL, UVM_UNKNOWN_OFFSET, 0,
                    UVM_MAPFLAG(UVM_PROT_NONE, UVM_PROT_NONE, UVM_INH_NONE,
                                UVM_ADV_NORMAL, 0)))
        	panic("cpu_startup: cannot allocate VM for buffers");

        minaddr = (vaddr_t) buffers;
        if ((bufpages / nbuf) >= btoc(MAXBSIZE)) {
        	bufpages = btoc(MAXBSIZE) * nbuf; /* do not overallocate RAM */
        }
        base = bufpages / nbuf;
        residual = bufpages % nbuf;

        /* now allocate RAM for buffers */
	for (i = 0 ; i < nbuf ; i++) {
		vaddr_t curbuf;
		vsize_t curbufsize;
		struct vm_page *pg;

		/*
		 * each buffer has MAXBSIZE bytes of VM space allocated.  of
		 * that MAXBSIZE space we allocate and map (base+1) pages
		 * for the first "residual" buffers, and then we allocate
		 * "base" pages for the rest.
		 */
		curbuf = (vaddr_t) buffers + (i * MAXBSIZE);
		curbufsize = PAGE_SIZE * ((i < residual) ? (base+1) : base);

		while (curbufsize) {
			pg = uvm_pagealloc(NULL, 0, NULL, 0);
			if (pg == NULL)
				panic("cpu_startup: "
				    "not enough RAM for buffer cache");
			pmap_kenter_pa(curbuf, VM_PAGE_TO_PHYS(pg),
			    UVM_PROT_RW);
			curbuf += PAGE_SIZE;
			curbufsize -= PAGE_SIZE;
		}
	}
	pmap_update(pmap_kernel());
a233 2
	printf("using %d buffers containing %d bytes of memory\n",
		nbuf, bufpages * PAGE_SIZE);
a266 25
	/*
	 * Determine how many buffers to allocate (enough to
	 * hold 5% of total physical memory, but at least 16).
	 * Allocate 1/2 as many swap buffer headers as file i/o buffers.
	 */
	if (bufpages == 0)
		bufpages = physmem * bufcachepercent / 100;
	if (nbuf == 0) {
		nbuf = bufpages;
		if (nbuf < 16)
			nbuf = 16;
	}
	if (nbuf > 200)
		nbuf = 200;	/* or we run out of PMEGS */
	/* Restrict to at most 70% filled kvm */
	if (nbuf * MAXBSIZE >
	    (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) * 7 / 10)
		nbuf = (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) /
		    MAXBSIZE * 7 / 10;

	/* More buffer pages than fits into the buffers is senseless.  */
	if (bufpages > nbuf * MAXBSIZE / PAGE_SIZE)
		bufpages = nbuf * MAXBSIZE / PAGE_SIZE;

	valloc(buf, struct buf, nbuf);
@


1.1
log
@As a late birthday present, a preliminary port to the Solbourne IDT systems
(S3000, S4000 and S4000DX).

Currently limited to diskless and serial console, and userland has issues.
Things will get better in the near future.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d405 5
@

