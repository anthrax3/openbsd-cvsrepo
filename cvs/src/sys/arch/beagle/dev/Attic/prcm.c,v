head	1.14;
access;
symbols
	OPENBSD_5_4:1.13.0.2
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.9.0.6
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.4
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.2
	OPENBSD_5_0:1.5.0.2
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.4.0.4
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.2
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2;
locks; strict;
comment	@ * @;


1.14
date	2013.09.04.14.38.39;	author patrick;	state dead;
branches;
next	1.13;

1.13
date	2013.06.14.23.13.54;	author patrick;	state Exp;
branches;
next	1.12;

1.12
date	2013.05.21.16.47.54;	author bmercer;	state Exp;
branches;
next	1.11;

1.11
date	2013.05.14.12.01.17;	author rapha;	state Exp;
branches;
next	1.10;

1.10
date	2013.05.03.17.58.15;	author patrick;	state Exp;
branches;
next	1.9;

1.9
date	2011.11.10.19.37.01;	author uwe;	state Exp;
branches;
next	1.8;

1.8
date	2011.11.10.00.19.36;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2011.10.21.22.55.01;	author drahn;	state Exp;
branches;
next	1.6;

1.6
date	2011.09.18.20.02.25;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2011.03.14.15.16.46;	author jasper;	state Exp;
branches;
next	1.4;

1.4
date	2010.08.07.03.50.01;	author krw;	state Exp;
branches;
next	1.3;

1.3
date	2010.02.12.05.31.11;	author drahn;	state Exp;
branches;
next	1.2;

1.2
date	2009.05.24.00.36.41;	author drahn;	state Exp;
branches;
next	1.1;

1.1
date	2009.05.08.03.13.26;	author drahn;	state Exp;
branches;
next	;


desc
@@


1.14
log
@In the future, we shouldn't have one port port ARM SoC, that's just
ridiculous.  This is the first step for a common and generic ARM port
for ARMv7 SoCs.
@
text
@/* $OpenBSD: prcm.c,v 1.13 2013/06/14 23:13:54 patrick Exp $ */
/*
 * Copyright (c) 2007,2009 Dale Rahn <drahn@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*-
 * Copyright (c) 2011
 *	Ben Gray <ben.r.gray@@gmail.com>.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the company nor the name of the author may be used to
 *    endorse or promote products derived from this software without specific
 *    prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY BEN GRAY ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL BEN GRAY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Driver for the Power, Reset and Clock Management Module (PRCM).
 */

#include <sys/types.h>
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/time.h>
#include <sys/device.h>

#include <machine/bus.h>
#include <machine/intr.h>
#include <arm/cpufunc.h>
#include <beagle/dev/omapvar.h>
#include <beagle/dev/prcmvar.h>

#include <beagle/dev/am335x_prcmreg.h>
#include <beagle/dev/omap3_prcmreg.h>
#include <beagle/dev/omap4_prcmreg.h>

#define PRCM_REVISION		0x0800
#define PRCM_SYSCONFIG		0x0810

uint32_t prcm_imask_mask[PRCM_REG_MAX];
uint32_t prcm_fmask_mask[PRCM_REG_MAX];
uint32_t prcm_imask_addr[PRCM_REG_MAX];
uint32_t prcm_fmask_addr[PRCM_REG_MAX];

#define SYS_CLK		13 /* SYS_CLK speed in MHz */

struct prcm_softc {
	struct device		sc_dev;
	bus_space_tag_t		sc_iot;
	bus_space_handle_t	sc_prcm;
	bus_space_handle_t	sc_cm1;
	bus_space_handle_t	sc_cm2;
	void (*sc_setup)(struct prcm_softc *sc);
	void (*sc_enablemodule)(struct prcm_softc *sc, int mod);
	void (*sc_setclock)(struct prcm_softc *sc,
	    int clock, int speed);
	uint32_t		cm1_avail;
	uint32_t		cm2_avail;
};

int	prcm_match(struct device *, void *, void *);
void	prcm_attach(struct device *, struct device *, void *);
int	prcm_setup_dpll5(struct prcm_softc *);
uint32_t prcm_v3_bit(int mod);
uint32_t prcm_am335x_clkctrl(int mod);

void prcm_am335x_enablemodule(struct prcm_softc *, int);
void prcm_am335x_setclock(struct prcm_softc *, int, int);

void prcm_v3_setup(struct prcm_softc *);
void prcm_v3_enablemodule(struct prcm_softc *, int);
void prcm_v3_setclock(struct prcm_softc *, int, int);

void prcm_v4_enablemodule(struct prcm_softc *, int);
int prcm_v4_hsusbhost_activate(int);
int prcm_v4_hsusbhost_set_source(int, int);

struct cfattach	prcm_ca = {
	sizeof (struct prcm_softc), NULL, prcm_attach
};

struct cfdriver prcm_cd = {
	NULL, "prcm", DV_DULL
};

void
prcm_attach(struct device *parent, struct device *self, void *args)
{
	struct omap_attach_args *oa = args;
	struct prcm_softc *sc = (struct prcm_softc *) self;
	u_int32_t reg;

	sc->sc_iot = oa->oa_iot;

	switch (board_id) {
	case BOARD_ID_AM335X_BEAGLEBONE:
		sc->sc_setup = NULL;
		sc->sc_enablemodule = prcm_am335x_enablemodule;
		sc->sc_setclock = prcm_am335x_setclock;
		break;
	case BOARD_ID_OMAP3_BEAGLE:
	case BOARD_ID_OMAP3_OVERO:
		sc->sc_setup = prcm_v3_setup;
		sc->sc_enablemodule = prcm_v3_enablemodule;
		sc->sc_setclock = prcm_v3_setclock;
		break;
	case BOARD_ID_OMAP4_PANDA:
		sc->sc_setup = NULL;
		sc->sc_enablemodule = prcm_v4_enablemodule;
		sc->sc_setclock = NULL;
		sc->cm1_avail = 1;
		sc->cm2_avail = 1;
		break;
	}

	if (bus_space_map(sc->sc_iot, oa->oa_dev->mem[0].addr,
	    oa->oa_dev->mem[0].size, 0, &sc->sc_prcm))
		panic("prcm_attach: bus_space_map failed!");

	if (sc->cm1_avail &&
	    bus_space_map(sc->sc_iot, oa->oa_dev->mem[1].addr,
	    oa->oa_dev->mem[1].size, 0, &sc->sc_cm1))
		panic("prcm_attach: bus_space_map failed!");

	if (sc->cm2_avail &&
	    bus_space_map(sc->sc_iot, oa->oa_dev->mem[2].addr,
	    oa->oa_dev->mem[2].size, 0, &sc->sc_cm2))
		panic("prcm_attach: bus_space_map failed!");

	reg = bus_space_read_4(sc->sc_iot, sc->sc_prcm, PRCM_REVISION);
	printf(" rev %d.%d\n", reg >> 4 & 0xf, reg & 0xf);

	if (sc->sc_setup)
		sc->sc_setup(sc);

	printf("\n");
}

void
prcm_v3_setup(struct prcm_softc *sc)
{
	/* Setup the 120MHZ DPLL5 clock, to be used by USB. */
	prcm_setup_dpll5(sc);

	prcm_fmask_mask[PRCM_REG_CORE_CLK1] = PRCM_REG_CORE_CLK1_FMASK;
	prcm_imask_mask[PRCM_REG_CORE_CLK1] = PRCM_REG_CORE_CLK1_IMASK;
	prcm_fmask_addr[PRCM_REG_CORE_CLK1] = PRCM_REG_CORE_CLK1_FADDR;
	prcm_imask_addr[PRCM_REG_CORE_CLK1] = PRCM_REG_CORE_CLK1_IADDR;

	prcm_fmask_mask[PRCM_REG_CORE_CLK2] = PRCM_REG_CORE_CLK2_FMASK;
	prcm_imask_mask[PRCM_REG_CORE_CLK2] = PRCM_REG_CORE_CLK2_IMASK;
	prcm_fmask_addr[PRCM_REG_CORE_CLK2] = PRCM_REG_CORE_CLK2_FADDR;
	prcm_imask_addr[PRCM_REG_CORE_CLK2] = PRCM_REG_CORE_CLK2_IADDR;

	prcm_fmask_mask[PRCM_REG_CORE_CLK3] = PRCM_REG_CORE_CLK3_FMASK;
	prcm_imask_mask[PRCM_REG_CORE_CLK3] = PRCM_REG_CORE_CLK3_IMASK;
	prcm_fmask_addr[PRCM_REG_CORE_CLK3] = PRCM_REG_CORE_CLK3_FADDR;
	prcm_imask_addr[PRCM_REG_CORE_CLK3] = PRCM_REG_CORE_CLK3_IADDR;

	prcm_fmask_mask[PRCM_REG_USBHOST] = PRCM_REG_USBHOST_FMASK;
	prcm_imask_mask[PRCM_REG_USBHOST] = PRCM_REG_USBHOST_IMASK;
	prcm_fmask_addr[PRCM_REG_USBHOST] = PRCM_REG_USBHOST_FADDR;
	prcm_imask_addr[PRCM_REG_USBHOST] = PRCM_REG_USBHOST_IADDR;
}

void
prcm_setclock(int clock, int speed)
{
	struct prcm_softc *sc = prcm_cd.cd_devs[0];

	if (!sc->sc_setclock)
		panic("%s: not initialised!", __func__);

	sc->sc_setclock(sc, clock, speed);
}

void
prcm_am335x_setclock(struct prcm_softc *sc, int clock, int speed)
{
	u_int32_t oreg, reg, mask;

	/* set CLKSEL register */
	if (clock == 1) {
		oreg = bus_space_read_4(sc->sc_iot, sc->sc_prcm,
		    PRCM_AM335X_CLKSEL_TIMER2_CLK);
		mask = 3;
		reg = oreg & ~mask;
		reg |=0x02;
		bus_space_write_4(sc->sc_iot, sc->sc_prcm,
		    PRCM_AM335X_CLKSEL_TIMER2_CLK, reg);
	} else if (clock == 2) {
		oreg = bus_space_read_4(sc->sc_iot, sc->sc_prcm,
		    PRCM_AM335X_CLKSEL_TIMER3_CLK);
		mask = 3;
		reg = oreg & ~mask;
		reg |=0x02;
		bus_space_write_4(sc->sc_iot, sc->sc_prcm,
		    PRCM_AM335X_CLKSEL_TIMER3_CLK, reg);
	}
}

void
prcm_v3_setclock(struct prcm_softc *sc, int clock, int speed)
{
	u_int32_t oreg, reg, mask;

	if (clock == 1) {
		oreg = bus_space_read_4(sc->sc_iot, sc->sc_prcm, CM_CLKSEL_WKUP);
		mask = 1;
		reg = (oreg &~mask) | (speed & mask);
		bus_space_write_4(sc->sc_iot, sc->sc_prcm, CM_CLKSEL_WKUP, reg);
	} else if (clock >= 2 && clock <= 9) {
		int shift =  (clock-2);
		oreg = bus_space_read_4(sc->sc_iot, sc->sc_prcm, CM_CLKSEL_PER);
		mask = 1 << (shift);
		reg =  (oreg & ~mask) | ( (speed << shift) & mask);
		bus_space_write_4(sc->sc_iot, sc->sc_prcm, CM_CLKSEL_PER, reg);
	} else
		panic("%s: invalid clock %d", __func__, clock);
}

uint32_t
prcm_v3_bit(int mod)
{
	switch(mod) {
	case PRCM_MMC:
		return PRCM_CLK_EN_MMC1;
	case PRCM_USB:
		return PRCM_CLK_EN_USB;
	default:
		panic("%s: module not found\n", __func__);
	}
}

uint32_t
prcm_am335x_clkctrl(int mod)
{
	switch(mod) {
	case PRCM_TIMER2:
		return PRCM_AM335X_TIMER2_CLKCTRL;
	case PRCM_TIMER3:
		return PRCM_AM335X_TIMER3_CLKCTRL;
	case PRCM_MMC:
		return PRCM_AM335X_MMC0_CLKCTRL;
	case PRCM_USB:
		return PRCM_AM335X_USB0_CLKCTRL;
	default:
		panic("%s: module not found\n", __func__);
	}
}

void
prcm_enablemodule(int mod)
{
	struct prcm_softc *sc = prcm_cd.cd_devs[0];

	if (!sc->sc_enablemodule)
		panic("%s: not initialised!", __func__);

	sc->sc_enablemodule(sc, mod);
}

void
prcm_am335x_enablemodule(struct prcm_softc *sc, int mod)
{
	uint32_t clkctrl;
	int reg;

	/*set enable bits in CLKCTRL register */
	reg = prcm_am335x_clkctrl(mod);
	clkctrl = bus_space_read_4(sc->sc_iot, sc->sc_prcm, reg);
	clkctrl &=~AM335X_CLKCTRL_MODULEMODE_MASK;
	clkctrl |= AM335X_CLKCTRL_MODULEMODE_ENABLE;
	bus_space_write_4(sc->sc_iot, sc->sc_prcm, reg, clkctrl);

	/* wait until module is enabled */
	while (bus_space_read_4(sc->sc_iot, sc->sc_prcm, reg) & 0x30000)
		;
}

void
prcm_v3_enablemodule(struct prcm_softc *sc, int mod)
{
	uint32_t bit;
	uint32_t fclk, iclk, fmask, imask, mbit;
	int freg, ireg, reg;

	bit = prcm_v3_bit(mod);
	reg = bit >> 5;

	freg = prcm_fmask_addr[reg];
	ireg = prcm_imask_addr[reg];
	fmask = prcm_fmask_mask[reg];
	imask = prcm_imask_mask[reg];

	mbit = 1 << (bit & 0x1f);
	if (fmask & mbit) { /* dont access the register if bit isn't present */
		fclk = bus_space_read_4(sc->sc_iot, sc->sc_prcm, freg);
		bus_space_write_4(sc->sc_iot, sc->sc_prcm, freg, fclk | mbit);
	}
	if (imask & mbit) { /* dont access the register if bit isn't present */
		iclk = bus_space_read_4(sc->sc_iot, sc->sc_prcm, ireg);
		bus_space_write_4(sc->sc_iot, sc->sc_prcm, ireg, iclk | mbit);
	}
	printf("\n");
}

void
prcm_v4_enablemodule(struct prcm_softc *sc, int mod)
{
	switch (mod) {
		case PRCM_USBP1_PHY:
		case PRCM_USBP2_PHY:
			prcm_v4_hsusbhost_set_source(mod, 0);
		case PRCM_USB:
		case PRCM_USBTLL:
		case PRCM_USBP1_UTMI:
		case PRCM_USBP1_HSIC:
		case PRCM_USBP2_UTMI:
		case PRCM_USBP2_HSIC:
			prcm_v4_hsusbhost_activate(mod);
			return;
	default:
		panic("%s: module not found\n", __func__);
	}
}

int
prcm_v4_hsusbhost_activate(int type)
{
	struct prcm_softc *sc = prcm_cd.cd_devs[0];
	uint32_t i;
	uint32_t clksel_reg_off;
	uint32_t clksel, oclksel;

	switch (type) {
		case PRCM_USB:
		case PRCM_USBP1_PHY:
		case PRCM_USBP2_PHY:
			/* We need the CM_L3INIT_HSUSBHOST_CLKCTRL register in CM2 register set */
			clksel_reg_off = O4_L3INIT_CM2_OFFSET + 0x58;
			clksel = bus_space_read_4(sc->sc_iot, sc->sc_cm2, clksel_reg_off);
			oclksel = clksel;
			/* Enable the module and also enable the optional func clocks */
			if (type == PRCM_USB) {
				clksel &= ~O4_CLKCTRL_MODULEMODE_MASK;
				clksel |=  /*O4_CLKCTRL_MODULEMODE_ENABLE*/2;

				clksel |= (0x1 << 15); /* USB-HOST clock control: FUNC48MCLK */
			}

			break;

		default:
			panic("%s: invalid type %d", type);
			return (EINVAL);
	}
	bus_space_write_4(sc->sc_iot, sc->sc_cm2, clksel_reg_off, clksel);

	/* Try MAX_MODULE_ENABLE_WAIT number of times to check if enabled */
	for (i = 0; i < O4_MAX_MODULE_ENABLE_WAIT; i++) {
		clksel = bus_space_read_4(sc->sc_iot, sc->sc_cm2, clksel_reg_off);
		if ((clksel & O4_CLKCTRL_IDLEST_MASK) == O4_CLKCTRL_IDLEST_ENABLED)
			break;
	}

	/* Check the enabled state */
	if ((clksel & O4_CLKCTRL_IDLEST_MASK) != O4_CLKCTRL_IDLEST_ENABLED) {
		printf("Error: HERE failed to enable module with clock %d\n", type);
		printf("Error: 0x%08x => 0x%08x\n", clksel_reg_off, clksel);
		return (ETIMEDOUT);
	}

	return (0);
}

int
prcm_v4_hsusbhost_set_source(int clk, int clksrc)
{
	struct prcm_softc *sc = prcm_cd.cd_devs[0];
	uint32_t clksel_reg_off;
	uint32_t clksel;
	unsigned int bit;

	if (clk == PRCM_USBP1_PHY)
		bit = 24;
	else if (clk != PRCM_USBP2_PHY)
		bit = 25;
	else
		return (-EINVAL);

	/* We need the CM_L3INIT_HSUSBHOST_CLKCTRL register in CM2 register set */
	clksel_reg_off = O4_L3INIT_CM2_OFFSET + 0x58;
	clksel = bus_space_read_4(sc->sc_iot, sc->sc_cm2, clksel_reg_off);

	/* XXX: Set the clock source to either external or internal */
	if (clksrc == 0)
		clksel |= (0x1 << bit);
	else
		clksel &= ~(0x1 << bit);

	bus_space_write_4(sc->sc_iot, sc->sc_cm2, clksel_reg_off, clksel);

	return (0);
}

/*
 * OMAP35xx Power, Reset, and Clock Management Reference Guide
 * (sprufa5.pdf) and AM/DM37x Multimedia Device Technical Reference
 * Manual (sprugn4h.pdf) note that DPLL5 provides a 120MHz clock for
 * peripheral domain modules (page 107 and page 302).
 * The reference clock for DPLL5 is DPLL5_ALWON_FCLK which is
 * SYS_CLK, running at 13MHz.
 */
int
prcm_setup_dpll5(struct prcm_softc *sc)
{
	uint32_t val;

	/*
	 * We need to set the multiplier and divider values for PLL.
	 * To end up with 120MHz we take SYS_CLK, divide by it and multiply
	 * with 120 (sprugn4h.pdf, 13.4.11.4.1 SSC Configuration)
	 */
	val = ((120 & 0x7ff) << 8) | ((SYS_CLK - 1) & 0x7f);
	bus_space_write_4(sc->sc_iot, sc->sc_prcm, CM_CLKSEL4_PLL, val);

	/* Clock divider from the PLL to the 120MHz clock. */
	bus_space_write_4(sc->sc_iot, sc->sc_prcm, CM_CLKSEL5_PLL, val);

	/*
	 * spruf98o.pdf, page 2319:
	 * PERIPH2_DPLL_FREQSEL is 0x7 1.75MHz to 2.1MHz
	 * EN_PERIPH2_DPLL is 0x7
	 */
	val = (7 << 4) | (7 << 0);
	bus_space_write_4(sc->sc_iot, sc->sc_prcm, CM_CLKEN2_PLL, val);

	/* Disable the interconnect clock auto-idle. */
	bus_space_write_4(sc->sc_iot, sc->sc_prcm, CM_AUTOIDLE2_PLL, 0x0);

	/* Wait until DPLL5 is locked and there's clock activity. */
	while ((val = bus_space_read_4(sc->sc_iot, sc->sc_prcm,
	    CM_IDLEST_CKGEN) & 0x01) == 0x00) {
#ifdef DIAGNOSTIC
		printf("CM_IDLEST_PLL = 0x%08x\n", val);
#endif
	}

	return 0;
}
@


1.13
log
@Rework beagle's ehci driver and add neccessay code to enable the clocks.
Only PandaBoard supported for now.  Lots taken from FreeBSD.

ok bmercer@@
@
text
@d1 1
a1 1
/* $OpenBSD: prcm.c,v 1.12 2013/05/21 16:47:54 bmercer Exp $ */
@


1.12
log
@Small code clean up. Removing noisy printfs.
@
text
@d1 1
a1 1
/* $OpenBSD: prcm.c,v 1.11 2013/05/14 12:01:17 rapha Exp $ */
d18 29
d66 1
d81 4
a84 1
	bus_space_handle_t	sc_ioh;
d88 2
d105 4
a125 7
	if (bus_space_map(sc->sc_iot, oa->oa_dev->mem[0].addr,
	    oa->oa_dev->mem[0].size, 0, &sc->sc_ioh))
		panic("prcm_attach: bus_space_map failed!");

	reg = bus_space_read_4(sc->sc_iot, sc->sc_ioh, PRCM_REVISION);
	printf(" rev %d.%d\n", reg >> 4 & 0xf, reg & 0xf);

d128 1
d134 1
a136 1
		prcm_v3_setup(sc);
d139 2
a140 1
		sc->sc_enablemodule = NULL;
d142 2
d146 22
d215 1
a215 1
		oreg = bus_space_read_4(sc->sc_iot, sc->sc_ioh,
d220 1
a220 1
		bus_space_write_4(sc->sc_iot, sc->sc_ioh,
d223 1
a223 1
		oreg = bus_space_read_4(sc->sc_iot, sc->sc_ioh,
d228 1
a228 1
		bus_space_write_4(sc->sc_iot, sc->sc_ioh,
d239 1
a239 1
		oreg = bus_space_read_4(sc->sc_iot, sc->sc_ioh, CM_CLKSEL_WKUP);
d242 1
a242 1
		bus_space_write_4(sc->sc_iot, sc->sc_ioh, CM_CLKSEL_WKUP, reg);
d245 1
a245 1
		oreg = bus_space_read_4(sc->sc_iot, sc->sc_ioh, CM_CLKSEL_PER);
d248 1
a248 1
		bus_space_write_4(sc->sc_iot, sc->sc_ioh, CM_CLKSEL_PER, reg);
d302 1
a302 1
	clkctrl = bus_space_read_4(sc->sc_iot, sc->sc_ioh, reg);
d305 1
a305 1
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, reg, clkctrl);
d308 1
a308 1
	while (bus_space_read_4(sc->sc_iot, sc->sc_ioh, reg) & 0x30000)
d329 2
a330 2
		fclk = bus_space_read_4(sc->sc_iot, sc->sc_ioh, freg);
		bus_space_write_4(sc->sc_iot, sc->sc_ioh, freg, fclk | mbit);
d333 2
a334 2
		iclk = bus_space_read_4(sc->sc_iot, sc->sc_ioh, ireg);
		bus_space_write_4(sc->sc_iot, sc->sc_ioh, ireg, iclk | mbit);
d339 99
d457 1
a457 1
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, CM_CLKSEL4_PLL, val);
d460 1
a460 1
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, CM_CLKSEL5_PLL, val);
d468 1
a468 1
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, CM_CLKEN2_PLL, val);
d471 1
a471 1
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, CM_AUTOIDLE2_PLL, 0x0);
d474 1
a474 1
	while ((val = bus_space_read_4(sc->sc_iot, sc->sc_ioh,
@


1.11
log
@Add basic prcm support for am335x.
Use separate headers and enable/disablemodule functions for the
different boards. A lot of work by patrick@@.

ok patrick@@, bmercer@@
@
text
@d1 1
a1 1
/* $OpenBSD: prcm.c,v 1.10 2013/05/03 17:58:15 patrick Exp $ */
a183 1
		printf("%s: old %08x new %08x", __func__, oreg, reg);
a189 1
		printf("%s: old %08x new %08x", __func__, oreg, reg);
@


1.10
log
@Fix a shift in the beagle prcm.

ok jsg@@
@
text
@d1 1
a1 1
/* $OpenBSD: prcm.c,v 1.9 2011/11/10 19:37:01 uwe Exp $ */
d35 2
a36 9
#define CM_FCLKEN_IVA2		0x0000
#define CM_CLKEN_PLL_IVA2	0x0004
#define CM_IDLEST_IVA2		0x0020
#define CM_IDLEST_PLL_IVA2	0x0024
#define CM_AUTOIDLE_PLL_IVA2	0x0034
#define CM_CLKSEL1_PLL_IVA2	0x0040
#define CM_CLKSEL2_PLL_IVA2	0x0044
#define CM_CLKSTCTRL_IVA2	0x0048
#define CM_CLKSTST_IVA2		0x004c
a40 104
#define	CM_CLKSEL_MPU		0x0940
#define CM_CLKSTCTRL_MPU	0x0948
#define RM_RSTST_MPU		0x0958
#define PM_WKDEP_MPU		0x09C8
#define PM_EVGENCTRL_MPU	0x09D4
#define PM_EVEGENONTIM_MPU	0x09D8
#define PM_EVEGENOFFTIM_MPU	0x09DC
#define PM_PWSTCTRL_MPU		0x09E0
#define PM_PWSTST_MPU		0x09E4

#define  CM_ICLKEN1_CORE	0x0a10
#define  CM_ICLKEN1_CORE_MSK	0x7ffffed2
#define  CM_ICLKEN2_CORE	0x0a14
#define  CM_ICLKEN2_CORE_MSK	0x0000001f
#define  CM_ICLKEN3_CORE	0x0a18
#define  CM_ICLKEN3_CORE_MSK	0x00000004
#define  CM_ICLKEN4_CORE	0x0a1C
#define  CM_IDLEST1_CORE	0x0a20
#define  CM_IDLEST2_CORE	0x0a24
#define  CM_IDLEST4_CORE	0x0a2C
#define  CM_AUTOIDLE1_CORE	0x0a30
#define  CM_AUTOIDLE2_CORE	0x0a34
#define  CM_AUTOIDLE3_CORE	0x0a38
#define  CM_AUTOIDLE4_CORE	0x0a3C
#define  CM_CLKSEL1_CORE	0x0a40
#define  CM_CLKSEL2_CORE	0x0a44
#define  CM_CLKSTCTRL_CORE	0x0a48
#define  PM_WKEN1_CORE		0x0aA0
#define  PM_WKEN2_CORE		0x0aA4
#define  PM_WKST1_CORE		0x0aB0
#define  PM_WKST2_CORE		0x0aB4
#define  PM_WKDEP_CORE		0x0aC8
#define  PM_PWSTCTRL_CORE	0x0aE0
#define  PM_PWSTST_CORE		0x0aE4
#define  CM_FCLKEN_GFX		0x0b00
#define  CM_ICLKEN_GFX		0x0b10

#define CM_IDLEST_GFX		0x0b20
#define CM_CLKSEL_GFX		0x0b40
#define CM_CLKSTCTRL_GFX	0x0b48
#define RM_RSTCTRL_GFX		0x0b50
#define RM_RSTST_GFX		0x0b58
#define PM_WKDEP_GFX		0x0bC8
#define PM_PWSTCTRL_GFX		0x0bE0
#define PM_PWSTST_GFX		0x0bE4
#define CM_FCLKEN_WKUP		0x0c00
#define		CM_FCLKEN_WKUP_GPT1	1
#define		CM_FCLKEN_WKUP_GPIOS	4
#define		CM_FCLKEN_WKUP_MPU_WDT	8
#define CM_ICLKEN_WKUP		0xc10
#define		CM_ICLKEN_WKUP_GPT1	0x01
#define		CM_ICLKEN_WKUP_32KSYNC	0x02
#define		CM_ICLKEN_WKUP_GPIOS	0x04
#define		CM_ICLKEN_WKUP_MPU_WDT	0x08
#define		CM_ICLKEN_WKUP_WDT1	0x10
#define		CM_ICLKEN_WKUP_OMAPCTRL	0x20
#define	CM_IDLEST_WKUP		0x0c20
#define CM_AUTOIDLE_WKUP	0x0c30
#define CM_CLKSEL_WKUP		0x0c40
#define RM_RSTCTRL_WKUP		0x0c50
#define RM_RSTTIME_WKUP		0x0c54
#define RM_RSTST_WKUP		0x0c58
#define PM_WKEN_WKUP		0x0cA0
#define PM_WKST_WKUP		0x0cB0
#define CM_CLKEN_PLL		0x0d00
#define CM_CLKEN2_PLL		0x0d04
#define CM_IDLEST_CKGEN		0x0d20
#define CM_AUTOIDLE_PLL		0x0d30
#define CM_AUTOIDLE2_PLL	0x0d34
#define CM_CLKSEL1_PLL		0x0d40
#define CM_CLKSEL2_PLL		0x0d44
#define CM_CLKSEL3_PLL		0x0d48
#define CM_CLKSEL4_PLL		0x0d4C
#define CM_CLKSEL5_PLL		0x0d50
#define CM_FCLKEN_PER		0x1000
#define CM_ICLKEN_PER		0x1010
#define CM_IDLEST_PER		0x1020
#define CM_AUTOIDLE_PER		0x1030
#define CM_CLKSEL_PER		0x1040
#define CM_SLEEPDEP_PER		0x1044
#define CM_CLKSTCTRL_PER	0x1048
#define CM_CLKSTST_PER		0x104C

#define CM_CLKSEL1_EMU		0x5140
#define CM_CLKSTCTRL_EMU	0x5148
#define CM_CLKSTST_EMU		0x514C
#define CM_CLKSEL2_EMU		0x5150
#define CM_CLKSEL3_EMU		0x5154

#define CM_POLCTRL		0x529C

#define CM_IDLEST_NEON		0x5320
#define CM_CLKSTCTRL_NEON	0x5348

#define CM_FCLKEN_USBHOST	0x5400
#define CM_ICLKEN_USBHOST	0x5410
#define CM_IDLEST_USBHOST	0x5420
#define CM_AUTOIDLE_USBHOST	0x5430
#define CM_SLEEPDEP_USBHOST	0x5444
#define CM_CLKSTCTRL_USBHOST	0x5448
#define CM_CLKSTST_USBHOST	0x544C

uint32_t prcm_imask_cur[PRCM_REG_MAX];
uint32_t prcm_fmask_cur[PRCM_REG_MAX];
d48 8
a55 2
bus_space_tag_t		prcm_iot;
bus_space_handle_t	prcm_ioh;
d57 12
a68 3
int     prcm_match(struct device *, void *, void *);
void    prcm_attach(struct device *, struct device *, void *);
int	prcm_setup_dpll5(void);
d71 1
a71 1
	sizeof (struct device), NULL, prcm_attach
d82 1
d85 1
a85 1
	prcm_iot = oa->oa_iot;
d87 2
a88 2
	if (bus_space_map(prcm_iot, oa->oa_dev->mem[0].addr,
	    oa->oa_dev->mem[0].size, 0, &prcm_ioh))
d91 1
a91 1
	reg = bus_space_read_4(prcm_iot, prcm_ioh, PRCM_REVISION);
d93 22
a114 1
	
d116 1
a116 1
	prcm_setup_dpll5();
a117 27
	/* XXX */
#if 1
	printf("CM_FCLKEN1_CORE %x\n", bus_space_read_4(prcm_iot, prcm_ioh, CM_FCLKEN1_CORE));
	printf("CM_ICLKEN1_CORE %x\n", bus_space_read_4(prcm_iot, prcm_ioh, CM_ICLKEN1_CORE));
	printf("CM_AUTOIDLE1_CORE %x\n", bus_space_read_4(prcm_iot, prcm_ioh, CM_AUTOIDLE1_CORE));

	printf("CM_FCLKEN_WKUP %x\n", bus_space_read_4(prcm_iot, prcm_ioh, CM_FCLKEN_WKUP));
	printf(" CM_IDLEST_WKUP %x\n", bus_space_read_4(prcm_iot, prcm_ioh,  CM_IDLEST_WKUP));
//	bus_space_write_4(prcm_iot, prcm_ioh, 
#endif

#if 0
	reg = bus_space_read_4(prcm_iot, prcm_ioh, CM_FCLKEN1_CORE);
	reg |= CM_FCLKEN1_CORE_GP3|CM_FCLKEN1_CORE_GP2;
	bus_space_write_4(prcm_iot, prcm_ioh, CM_FCLKEN1_CORE, reg);
	reg = bus_space_read_4(prcm_iot, prcm_ioh, CM_ICLKEN1_CORE);
	reg |= CM_ICLKEN1_CORE_GP3|CM_ICLKEN1_CORE_GP2;
	bus_space_write_4(prcm_iot, prcm_ioh, CM_ICLKEN1_CORE, reg);

	reg = bus_space_read_4(prcm_iot, prcm_ioh, CM_FCLKEN_WKUP);
	reg |= CM_FCLKEN_WKUP_MPU_WDT | CM_FCLKEN_WKUP_GPT1;
	bus_space_write_4(prcm_iot, prcm_ioh, CM_FCLKEN_WKUP, reg);

	reg = bus_space_read_4(prcm_iot, prcm_ioh, CM_ICLKEN_WKUP);
	reg |= CM_ICLKEN_WKUP_MPU_WDT | CM_ICLKEN_WKUP_GPT1;
	bus_space_write_4(prcm_iot, prcm_ioh, CM_ICLKEN_WKUP, reg);
#endif
d137 1
d139 9
d151 26
a176 1
prcm_setclock(int clock, int speed)
a177 1
#if 1
d179 1
d181 1
a181 1
		oreg = bus_space_read_4(prcm_iot, prcm_ioh, CM_CLKSEL_WKUP);
d184 2
a185 2
		printf(" prcm_setclock old %08x new %08x",  oreg, reg );
		bus_space_write_4(prcm_iot, prcm_ioh, CM_CLKSEL_WKUP, reg);
d188 1
a188 2
		oreg = bus_space_read_4(prcm_iot, prcm_ioh, CM_CLKSEL_PER);

d191 35
a225 1
		printf(" prcm_setclock old %08x new %08x",  oreg, reg);
d227 27
a253 4
		bus_space_write_4(prcm_iot, prcm_ioh, CM_CLKSEL_PER, reg);
	} else
		panic("prcm_setclock invalid clock %d", clock);
#endif
d257 1
a257 1
prcm_enableclock(int bit)
d259 2
a260 1
	u_int32_t fclk, iclk, fmask, imask, mbit;
a261 1
	printf("prcm_enableclock %d:", bit);
d263 1
d271 1
a271 5
	mbit =  1 << (bit & 0x1f);
#if 0
	printf("reg %d faddr 0x%08x iaddr 0x%08x, fmask 0x%08x "
	    "imask 0x%08x mbit %x", reg, freg, ireg, fmask, imask, mbit);
#endif
d273 2
a274 4
		fclk = bus_space_read_4(prcm_iot, prcm_ioh, freg);
		prcm_fmask_cur[reg] = fclk | mbit;
		bus_space_write_4(prcm_iot, prcm_ioh, freg, fclk | mbit);
		printf(" fclk %08x %08x",  fclk, fclk | mbit);
a275 1

d277 2
a278 4
		iclk = bus_space_read_4(prcm_iot, prcm_ioh, ireg);
		prcm_imask_cur[reg] = iclk | mbit;
		bus_space_write_4(prcm_iot, prcm_ioh, ireg, iclk | mbit);
		printf(" iclk %08x %08x",  iclk, iclk | mbit);
d280 1
a280 1
	printf ("\n");
d292 1
a292 1
prcm_setup_dpll5(void)
d302 1
a302 1
	bus_space_write_4(prcm_iot, prcm_ioh, CM_CLKSEL4_PLL, val);
d305 1
a305 1
	bus_space_write_4(prcm_iot, prcm_ioh, CM_CLKSEL5_PLL, val);
d313 1
a313 1
	bus_space_write_4(prcm_iot, prcm_ioh, CM_CLKEN2_PLL, val);
d316 1
a316 1
	bus_space_write_4(prcm_iot, prcm_ioh, CM_AUTOIDLE2_PLL, 0x0);
d319 1
a319 1
	while ((val = bus_space_read_4(prcm_iot, prcm_ioh,
@


1.9
log
@Reduce autoconf(4) overuse on beagle

Renamed `ahb' to `omap' and extended it to configure the on-chip
devices directly, based a board-specific table instead of trying to
maintain addresses, interrupt numbers and such for two OMAP variants
in the same config file.

This may be an intermediate step, but should provide us some relief
already. :)

Suggestions from deraadt and drahn; ok drahn@@
@
text
@d1 1
a1 1
/* $OpenBSD: prcm.c,v 1.8 2011/11/10 00:19:36 matthieu Exp $ */
d256 1
a256 1
		mask = 1 << (mask);
@


1.8
log
@Add gumstix overo support. It's very similar to be beagleboard at this
point. So add it's card id and handle it like the beagleboard.
ok drahn@@, miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: prcm.c,v 1.7 2011/10/21 22:55:01 drahn Exp $ */
d32 1
a32 1
#include <beagle/beagle/ahb.h>
a156 2
#define PRCM_SIZE	0x2000

a160 1
int prcm_attached;
d167 1
a167 1
	sizeof (struct device), prcm_match, prcm_attach
a173 18
int
prcm_match(struct device *parent, void *v, void *aux)
{
	/* only attach once */
	switch (board_id) {
	case BOARD_ID_OMAP3_BEAGLE:
	case BOARD_ID_OMAP3_OVERO:
		break; /* continue trying */
	case BOARD_ID_OMAP4_PANDA:
		return 0; /* not ported yet */
	default:
		return 0; /* unknown */
	}
	if (prcm_attached != 0)
		return (0);
	return (1);
}

d177 1
a177 2
        struct ahb_attach_args *aa = args;
	prcm_iot = aa->aa_iot;
d180 4
a183 1
	if (bus_space_map(prcm_iot, aa->aa_addr, PRCM_SIZE, 0, &prcm_ioh))
a188 2
	prcm_attached = 1;

@


1.7
log
@Pile of diffs to improve beagle/panda status. fetching u-boot parameters
out of the register input. (with a beagle_start.S fix from uwe@@)
Devices now detect device_id from u-boot and decide to enable/disable
themselves in the device match routine. ok uwe@@
@
text
@d1 1
a1 1
/* $OpenBSD: prcm.c,v 1.6 2011/09/18 20:02:25 miod Exp $ */
d183 1
@


1.6
log
@Obvious typo in diag message
@
text
@d1 1
a1 1
/* $OpenBSD: prcm.c,v 1.5 2011/03/14 15:16:46 jasper Exp $ */
d181 8
@


1.5
log
@use DPLL5 as a 120MHz reference clock to be used by the usb subsystem which
previously had no clue and would crash.

feedback/ok drahn@@
@
text
@d1 1
a1 1
/* $OpenBSD: prcm.c,v 1.4 2010/08/07 03:50:01 krw Exp $ */
d352 1
a352 1
		printf("CM_IDLEST_PLL = 0x&08x\n", val);
@


1.4
log
@No "\n" needed at the end of panic() strings.

Bogus chunks pointed out by matthew@@ and miod@@. No cookies for
marco@@ and jasper@@.

ok deraadt@@ miod@@ matthew@@ jasper@@ macro@@
@
text
@d1 1
a1 1
/* $OpenBSD: prcm.c,v 1.3 2010/02/12 05:31:11 drahn Exp $ */
d18 4
d113 1
d116 1
d119 3
d159 4
a162 2
bus_space_tag_t prcm_iot;
bus_space_handle_t prcm_ioh;
d167 1
a167 2


d201 3
d311 46
@


1.3
log
@Rework prcm to support additional iclk/fclk registers.
@
text
@d1 1
a1 1
/* $OpenBSD: prcm.c,v 1.2 2009/05/24 00:36:41 drahn Exp $ */
d261 1
a261 1
		panic("prcm_setclock invalid clock %d\n", clock);
@


1.2
log
@Rework for 3530.
@
text
@d1 1
a1 1
/* $OpenBSD: prcm.c,v 1.1 2009/05/08 03:13:26 drahn Exp $ */
a52 10
#define CM_FCLKEN1_CORE		0x0a00
#define CM_FCLKEN1_CORE_MSK	0x41fffe00

#define  CM_FCLKEN2_CORE	0x0a04
#define  CM_FCLKEN2_CORE_MSK	0x00000000
#define  CM_FCLKEN3_CORE	0x0a08
#define  CM_FCLKEN3_CORE_MSK	0x00000007
#define		CM_CORE_EN_USBTLL	(2+64)
#define		CM_CORE_EN_TS		(1+64)
#define		CM_CORE_EN_CPEFUSE	(0+64)
d141 6
a146 2


d218 20
d269 1
a269 1
	int freg, ireg;
d272 6
a277 17
	if (bit < 32){
		freg = CM_FCLKEN1_CORE;
		ireg = CM_ICLKEN1_CORE;
		fmask = CM_FCLKEN1_CORE_MSK;
		imask = CM_ICLKEN1_CORE_MSK;

	} else if (bit < 64) {
		freg = CM_FCLKEN2_CORE;
		ireg = CM_ICLKEN2_CORE;
		fmask = CM_FCLKEN2_CORE_MSK;
		imask = CM_ICLKEN2_CORE_MSK;
	} else {
		freg = CM_FCLKEN3_CORE;
		ireg = CM_ICLKEN3_CORE;
		fmask = CM_FCLKEN3_CORE_MSK;
		imask = CM_ICLKEN3_CORE_MSK;
	}
d280 4
d286 1
d293 1
@


1.1
log
@Initial effort on a port to the omap35xx platform specifically beagleboard,
however other omap system may be supportable. Not functional until armv7
core changes are complete.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d31 69
a99 142
#define PRCM_REVISION		0x000
#define PRCM_SYSCONFIG		0x010
#define PRCM_IRQSTATUS_MPU	0x018
#define PRCM_IRQENABLE_MPU	0x01c
#define PRCM_VOLTCTRL		0x050
#define PRCM_VOLTST		0x054
#define PRCM_CLKSRC_CTRL	0x060
#define PRCM_CLKOUT_CTRL	0x070
#define PRCM_CLKEMUL_CTRL	0x078
#define PRCM_CLKCFG_CTRL	0x080
#define PRCM_CLKCFG_STATUS	0x084
#define PRCM_VOLTSETUP		0x090
#define PRCM_CLKSSETUP		0x094
#define PRCM_POLCTRL		0x098
#define PRCM_GP1		0x0b0
#define PRCM_GP2		0x0b4
#define PRCM_GP3		0x0b8
#define PRCM_GP4		0x0bc
#define PRCM_GP5		0x0c0
#define PRCM_GP6		0x0c4
#define PRCM_GP7		0x0c8
#define PRCM_GP8		0x0cc
#define PRCM_GP9		0x0d0
#define PRCM_GP10		0x0d4
#define PRCM_GP11		0x0d8
#define PRCM_GP12		0x0dc
#define PRCM_GP13		0x0e0
#define PRCM_GP14		0x0e4
#define PRCM_GP15		0x0e8
#define PRCM_GP16		0x0ec
#define PRCM_GP17		0x0f0
#define PRCM_GP18		0x0f4
#define PRCM_GP19		0x0f8
#define PRCM_GP20		0x0fc

#define CM_CLKSEL_MPU		0x140
#define  CM_CLKSTCTRL_MPU	0x148
#define  RM_RSTST_MPU		0x158
#define  PM_WKDEP_MPU		0x1C8
#define  PM_EVGENCTRL_MPU	0x1D4
#define  PM_EVEGENONTIM_MPU	0x1D8
#define  PM_EVEGENOFFTIM_MPU	0x1DC
#define  PM_PWSTCTRL_MPU	0x1E0
#define  PM_PWSTST_MPU		0x1E4
#define  CM_FCLKEN1_CORE	0x200
#define  	CM_FCLKEN1_CORE_DSS1	0x00000001
#define  	CM_FCLKEN1_CORE_DSS2	0x00000002
#define  	CM_FCLKEN1_CORE_TV	0x00000004
#define  	CM_FCLKEN1_CORE_VLYNQ	0x00000008
#define  	CM_FCLKEN1_CORE_GP2	0x00000010
#define  	CM_FCLKEN1_CORE_GP3	0x00000020
#define  	CM_FCLKEN1_CORE_GP4	0x00000040
#define  	CM_FCLKEN1_CORE_GP5	0x00000080
#define  	CM_FCLKEN1_CORE_GP6	0x00000100
#define  	CM_FCLKEN1_CORE_GP7	0x00000200
#define  	CM_FCLKEN1_CORE_GP8	0x00000400
#define  	CM_FCLKEN1_CORE_GP9	0x00000800
#define  	CM_FCLKEN1_CORE_GP10	0x00001000
#define  	CM_FCLKEN1_CORE_GP11	0x00002000
#define  	CM_FCLKEN1_CORE_GP12	0x00004000
#define  	CM_FCLKEN1_CORE_MCBSP1	0x00008000
#define  	CM_FCLKEN1_CORE_MCBSP2	0x00010000
#define  	CM_FCLKEN1_CORE_MCSPI1	0x00020000
#define  	CM_FCLKEN1_CORE_MCSPI2	0x00040000
#define  	CM_FCLKEN1_CORE_I2C1	0x00080000
#define  	CM_FCLKEN1_CORE_I2C2	0x00100000
#define  	CM_FCLKEN1_CORE_UART1	0x00200000
#define  	CM_FCLKEN1_CORE_UART2	0x00400000
#define  	CM_FCLKEN1_CORE_HDQ	0x00800000
#define  	CM_FCLKEN1_CORE_EAC	0x01000000
#define  	CM_FCLKEN1_CORE_FAC	0x02000000
#define  	CM_FCLKEN1_CORE_MMC	0x04000000
#define  	CM_FCLKEN1_CORE_MSPR0	0x08000000
#define  	CM_FCLKEN1_CORE_WDT3	0x10000000
#define  	CM_FCLKEN1_CORE_WDT4	0x20000000
#define  	CM_FCLKEN1_CORE_CAM	0x80000000
#define  CM_FCLKEN2_CORE	0x204
#define  	CM_FCLKEN2_CORE_UART3	0x00000004
#define  	CM_FCLKEN2_CORE_SSI	0x00000002
#define  	CM_FCLKEN2_CORE_USB	0x00000001
#define  CM_ICLKEN1_CORE	0x210
#define  	CM_ICLKEN1_CORE_DSS1	0x00000001
#define  	CM_ICLKEN1_CORE_VLYNQ	0x00000008
#define  	CM_ICLKEN1_CORE_GP2	0x00000010
#define  	CM_ICLKEN1_CORE_GP3	0x00000020
#define  	CM_ICLKEN1_CORE_GP4	0x00000040
#define  	CM_ICLKEN1_CORE_GP5	0x00000080
#define  	CM_ICLKEN1_CORE_GP6	0x00000100
#define  	CM_ICLKEN1_CORE_GP7	0x00000200
#define  	CM_ICLKEN1_CORE_GP8	0x00000400
#define  	CM_ICLKEN1_CORE_GP9	0x00000800
#define  	CM_ICLKEN1_CORE_GP10	0x00001000
#define  	CM_ICLKEN1_CORE_GP11	0x00002000
#define  	CM_ICLKEN1_CORE_GP12	0x00004000
#define  	CM_ICLKEN1_CORE_MCBSP1	0x00008000
#define  	CM_ICLKEN1_CORE_MCBSP2	0x00010000
#define  	CM_ICLKEN1_CORE_MCSPI1	0x00020000
#define  	CM_ICLKEN1_CORE_MCSPI2	0x00040000
#define  	CM_ICLKEN1_CORE_I2C1	0x00080000
#define  	CM_ICLKEN1_CORE_I2C2	0x00100000
#define  	CM_ICLKEN1_CORE_UART1	0x00200000
#define  	CM_ICLKEN1_CORE_UART2	0x00400000
#define  	CM_ICLKEN1_CORE_HDQ	0x00800000
#define  	CM_ICLKEN1_CORE_EAC	0x01000000
#define  	CM_ICLKEN1_CORE_FAC	0x02000000
#define  	CM_ICLKEN1_CORE_MMC	0x04000000
#define  	CM_ICLKEN1_CORE_MSPR0	0x08000000
#define  	CM_ICLKEN1_CORE_WDT3	0x10000000
#define  	CM_ICLKEN1_CORE_WDT4	0x20000000
#define  	CM_ICLKEN1_CORE_MAILBOX	0x40000000
#define  	CM_ICLKEN1_CORE_CAM	0x80000000
#define  CM_ICLKEN2_CORE	0x214
#define  CM_ICLKEN4_CORE	0x21C
#define  CM_IDLEST1_CORE	0x220
#define  CM_IDLEST2_CORE	0x224
#define  CM_IDLEST4_CORE	0x22C
#define  CM_AUTOIDLE1_CORE	0x230
#define  CM_AUTOIDLE2_CORE	0x234
#define  CM_AUTOIDLE3_CORE	0x238
#define  CM_AUTOIDLE4_CORE	0x23C
#define  CM_CLKSEL1_CORE	0x240
#define  CM_CLKSEL2_CORE	0x244
#define  CM_CLKSTCTRL_CORE	0x248
#define  PM_WKEN1_CORE		0x2A0
#define  PM_WKEN2_CORE		0x2A4
#define  PM_WKST1_CORE		0x2B0
#define  PM_WKST2_CORE		0x2B4
#define  PM_WKDEP_CORE		0x2C8
#define  PM_PWSTCTRL_CORE	0x2E0
#define  PM_PWSTST_CORE		0x2E4
#define  CM_FCLKEN_GFX		0x300
#define  CM_ICLKEN_GFX		0x310

#define CM_IDLEST_GFX		0x320
#define CM_CLKSEL_GFX		0x340
#define CM_CLKSTCTRL_GFX	0x348
#define RM_RSTCTRL_GFX		0x350
#define RM_RSTST_GFX		0x358
#define PM_WKDEP_GFX		0x3C8
#define PM_PWSTCTRL_GFX		0x3E0
#define PM_PWSTST_GFX		0x3E4
#define CM_FCLKEN_WKUP		0x400
d103 1
a103 1
#define CM_ICLKEN_WKUP		0x410
d110 45
a154 30
#define	CM_IDLEST_WKUP		0x420
#define CM_AUTOIDLE_WKUP	0x430
#define CM_CLKSEL_WKUP		0x440
#define RM_RSTCTRL_WKUP		0x450
#define RM_RSTTIME_WKUP		0x454
#define RM_RSTST_WKUP		0x458
#define PM_WKEN_WKUP		0x4A0
#define PM_WKST_WKUP		0x4B0
#define CM_CLKEN_PLL		0x500
#define CM_IDLEST_CKGEN		0x520
#define CM_AUTOIDLE_PLL		0x530
#define CM_CLKSEL1_PLL		0x540
#define CM_CLKSEL2_PLL		0x544
#define CM_FCLKEN_DSP		0x800
#define CM_ICLKEN_DSP		0x810
#define CM_IDLEST_DSP		0x820
#define CM_AUTOIDLE_DSP		0x830
#define CM_CLKSEL_DSP		0x840
#define CM_CLKSTCTRL_DSP	0x848
#define RM_RSTCTRL_DSP		0x850
#define RM_RSTST_DSP		0x858
#define PM_WKEN_DSP		0x8A0
#define PM_WKDEP_DSP		0x8C8
#define PM_PWSTCTRL_DSP		0x8E0
#define PM_PWSTST_DSP		0x8E4
#define PRCM_IRQSTATUS_DSP	0x8F0
#define PRCM_IRQENABLE_DSP	0x8F4
#define PRCM_IRQSTATUS_IVA	0x8F8
#define PRCM_IRQENABLE_IVA	0x8FC
#define PRCM_SIZE	0x1000
d208 1
d223 1
d229 7
a235 6
#if 0
	u_int32_t reg;
	if (clock == 0) {
		reg = bus_space_read_4(prcm_iot, prcm_ioh, CM_CLKSEL_WKUP);
		reg &= ~( 3 << ((clock -1) *2 ));
		reg |=  ( speed << ((clock -1) *2 ));
d237 7
a243 2
	} else if (clock > 0 && clock < 13) {
		reg = bus_space_read_4(prcm_iot, prcm_ioh, CM_CLKSEL2_CORE);
d245 1
a245 4
		reg &= ~( 3 << (clock * 2));
		reg |=  ( speed << ((clock -1) *2 ));

		bus_space_write_4(prcm_iot, prcm_ioh, CM_CLKSEL2_CORE, reg);
d254 1
a254 2
#if 0
	u_int32_t fclk, iclk;
d256 1
d258 1
a258 1
	if (bit < 31){
d261 4
a264 1
	} else {
d267 7
d276 11
a286 12
	fclk = bus_space_read_4(prcm_iot, prcm_ioh, freg);
	iclk = bus_space_read_4(prcm_iot, prcm_ioh, ireg);
	fclk |=  1 << (bit & 0x1f);
	iclk |=  1 << (bit & 0x1f);

	/* mask reserved bits (XXX?) */
	if (bit > 31){
		fclk &= 0xbfffffff;
		iclk &= 0xfffffff9;
	} else {
		fclk &= 0x00000007;
		iclk &= 0x00000007;
d288 1
a288 3
	bus_space_write_4(prcm_iot, prcm_ioh, freg, fclk);
	bus_space_write_4(prcm_iot, prcm_ioh, ireg, iclk);
#endif
@

