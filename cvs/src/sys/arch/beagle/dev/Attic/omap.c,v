head	1.11;
access;
symbols
	OPENBSD_5_4:1.10.0.2
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.3.0.6
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.4
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.2;
locks; strict;
comment	@ * @;


1.11
date	2013.09.04.14.38.37;	author patrick;	state dead;
branches;
next	1.10;

1.10
date	2013.06.14.23.13.54;	author patrick;	state Exp;
branches;
next	1.9;

1.9
date	2013.06.11.19.19.43;	author rapha;	state Exp;
branches;
next	1.8;

1.8
date	2013.06.05.15.03.23;	author bmercer;	state Exp;
branches;
next	1.7;

1.7
date	2013.05.22.17.44.47;	author rapha;	state Exp;
branches;
next	1.6;

1.6
date	2013.05.09.15.16.53;	author patrick;	state Exp;
branches;
next	1.5;

1.5
date	2013.05.01.00.16.26;	author patrick;	state Exp;
branches;
next	1.4;

1.4
date	2013.04.25.23.07.17;	author patrick;	state Exp;
branches;
next	1.3;

1.3
date	2011.11.15.23.01.11;	author drahn;	state Exp;
branches;
next	1.2;

1.2
date	2011.11.11.10.46.35;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2011.11.10.19.37.01;	author uwe;	state Exp;
branches;
next	;


desc
@@


1.11
log
@In the future, we shouldn't have one port port ARM SoC, that's just
ridiculous.  This is the first step for a common and generic ARM port
for ARMv7 SoCs.
@
text
@/* $OpenBSD: omap.c,v 1.10 2013/06/14 23:13:54 patrick Exp $ */
/*
 * Copyright (c) 2005,2008 Dale Rahn <drahn@@openbsd.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/reboot.h>
#define _ARM32_BUS_DMA_PRIVATE
#include <machine/bus.h>
#include <arch/arm/armv7/armv7var.h>
#include <beagle/dev/omapvar.h>

struct arm32_bus_dma_tag omap_bus_dma_tag = {
	0,
	0,
	NULL,
	_bus_dmamap_create,
	_bus_dmamap_destroy,
	_bus_dmamap_load,
	_bus_dmamap_load_mbuf,
	_bus_dmamap_load_uio,
	_bus_dmamap_load_raw,
	_bus_dmamap_unload,
	_bus_dmamap_sync,
	_bus_dmamem_alloc,
	_bus_dmamem_free,
	_bus_dmamem_map,
	_bus_dmamem_unmap,
	_bus_dmamem_mmap,
};

struct board_dev {
	char *name;
	int unit;
};

struct board_dev beagleboard_devs[] = {
	{ "prcm",	0 },
	{ "intc",	0 },
	{ "gptimer",	0 },
	{ "gptimer",	1 },
	{ "omdog",	0 },
	{ "omgpio",	0 },
	{ "omgpio",	1 },
	{ "omgpio",	2 },
	{ "omgpio",	3 },
	{ "omgpio",	4 },
	{ "omgpio",	5 },
	{ "ommmc",	0 },		/* HSMMC1 */
	{ "com",	2 },		/* UART3 */
	{ NULL,		0 }
};

struct board_dev beaglebone_devs[] = {
	{ "prcm",	0 },
	{ "sitaracm",	0 },
	{ "intc",	0 },
	{ "dmtimer",	0 },
	{ "dmtimer",	1 },
	{ "omdog",	0 },
	{ "ommmc",	0 },		/* HSMMC0 */
	{ "com",	0 },		/* UART0 */
	{ "cpsw",	0 },
	{ NULL,		0 }
};

struct board_dev overo_devs[] = {
	{ "prcm",	0 },
	{ "intc",	0 },
	{ "gptimer",	0 },
	{ "gptimer",	1 },
	{ "omdog",	0 },
	{ "omgpio",	0 },
	{ "omgpio",	1 },
	{ "omgpio",	2 },
	{ "omgpio",	3 },
	{ "omgpio",	4 },
	{ "omgpio",	5 },
	{ "ommmc",	0 },		/* HSMMC1 */
	{ "com",	2 },		/* UART3 */
	{ NULL,		0 }
};

struct board_dev pandaboard_devs[] = {
	{ "omapid",	0 },
	{ "prcm",	0 },
	{ "omdog",	0 },
	{ "omgpio",	0 },
	{ "omgpio",	1 },
	{ "omgpio",	2 },
	{ "omgpio",	3 },
	{ "omgpio",	4 },
	{ "omgpio",	5 },
	{ "ommmc",	0 },		/* HSMMC1 */
	{ "com",	2 },		/* UART3 */
	{ "ehci",	0 },
	{ NULL,		0 }
};

struct board_dev *board_devs;

struct omap_dev *omap_devs = NULL;

struct omap_softc {
	struct device sc_dv;
};

int	omap_match(struct device *, void *, void *);
void	omap_attach(struct device *, struct device *, void *);
int	omap_submatch(struct device *, void *, void *);

struct cfattach omap_ca = {
	sizeof(struct omap_softc), omap_match, omap_attach
};

struct cfdriver omap_cd = {
	NULL, "omap", DV_DULL
};

int
omap_match(struct device *parent, void *cfdata, void *aux)
{
	return (1);
}

void
omap_attach(struct device *parent, struct device *self, void *aux)
{
	struct board_dev *bd;

	switch (board_id) {
	case BOARD_ID_OMAP3_BEAGLE:
		printf(": BeagleBoard\n");
		omap3_init();
		board_devs = beagleboard_devs;
		break;
	case BOARD_ID_AM335X_BEAGLEBONE:
		printf(": BeagleBone\n");
		am335x_init();
		board_devs = beaglebone_devs;
		break;
	case BOARD_ID_OMAP3_OVERO:
		printf(": Gumstix Overo\n");
		omap3_init();
		board_devs = overo_devs;
		break;
	case BOARD_ID_OMAP4_PANDA:
		printf(": PandaBoard\n");
		omap4_init();
		board_devs = pandaboard_devs;
		break;
	default:
		printf("\n");
		panic("%s: board type 0x%x unknown", __func__, board_id);
	}

	/* Directly configure on-board devices (dev* in config file). */
	for (bd = board_devs; bd->name != NULL; bd++) {
		struct omap_dev *od = omap_find_dev(bd->name, bd->unit);
		struct omap_attach_args oa;

		if (od == NULL) {
			printf("%s: device %s unit %d not found\n",
			    self->dv_xname, bd->name, bd->unit);
			continue;
		}

		memset(&oa, 0, sizeof(oa));
		oa.oa_dev = od;
		oa.oa_iot = &armv7_bs_tag;
		oa.oa_dmat = &omap_bus_dma_tag;

		if (config_found_sm(self, &oa, NULL, omap_submatch) == NULL)
			printf("%s: device %s unit %d not configured\n",
			    self->dv_xname, bd->name, bd->unit);
	}
}

/*
 * We do direct configuration of devices on this SoC "bus", so we
 * never call the child device's match function at all (it can be
 * NULL in the struct cfattach).
 */
int
omap_submatch(struct device *parent, void *child, void *aux)
{
	struct cfdata *cf = child;
	struct omap_attach_args *oa = aux;

	if (strcmp(cf->cf_driver->cd_name, oa->oa_dev->name) == 0)
		return (1);

	/* "These are not the droids you are looking for." */
	return (0);
}

void
omap_set_devs(struct omap_dev *devs)
{
	omap_devs = devs;
}

struct omap_dev *
omap_find_dev(const char *name, int unit)
{
	struct omap_dev *od;

	if (omap_devs == NULL)
		panic("%s: omap_devs == NULL", __func__);

	for (od = omap_devs; od->name != NULL; od++) {
		if (od->unit == unit && strcmp(od->name, name) == 0)
			return (od);
	}

	return (NULL);
}
@


1.10
log
@Rework beagle's ehci driver and add neccessay code to enable the clocks.
Only PandaBoard supported for now.  Lots taken from FreeBSD.

ok bmercer@@
@
text
@d1 1
a1 1
/* $OpenBSD: omap.c,v 1.9 2013/06/11 19:19:43 rapha Exp $ */
@


1.9
log
@Activate the sitaracm driver. (beaglebone only)

ok bmercer@@
@
text
@d1 1
a1 1
/* $OpenBSD: omap.c,v 1.8 2013/06/05 15:03:23 bmercer Exp $ */
d101 1
d111 1
@


1.8
log
@Initial port of the cpsw driver from netbsd. This will support ethernet
on the beaglebone. This will be easier to work on in tree.
OK florian@@ dlg@@ "put it in" patrick@@
@
text
@d1 1
a1 1
/* $OpenBSD: omap.c,v 1.7 2013/05/22 17:44:47 rapha Exp $ */
d71 1
@


1.7
log
@Add am335x as an omap device.

ok patrick@@
@
text
@d1 1
a1 1
/* $OpenBSD: omap.c,v 1.6 2013/05/09 15:16:53 patrick Exp $ */
d77 1
@


1.6
log
@Add a driver for the OMAP identification registers/fuses,
so that we can adjust the timer frequency for PandaBoard version.
From drahn at bitrig.

ok bmercer@@
@
text
@d1 1
a1 1
/* $OpenBSD: omap.c,v 1.5 2013/05/01 00:16:26 patrick Exp $ */
d69 11
d147 5
@


1.5
log
@Add a cortex bus which represents the ARM MPCore Complex.
It will attach only to ARM Cortex A9 and A15 SoCs.
The generic interrupt controller and timer will attach to this bus,
later a secondary cache controller can be added.
The base address for those controllers are figured out using
the periphbase register.

ok bmercer@@
@
text
@d1 1
a1 1
/* $OpenBSD: omap.c,v 1.4 2013/04/25 23:07:17 patrick Exp $ */
d87 1
@


1.4
log
@Add a terminator to the device list, so that we don't end up having
unexpected behaviour when a device isn't found.

ok bmercer@@
@
text
@d1 1
a1 1
/* $OpenBSD: omap.c,v 1.3 2011/11/15 23:01:11 drahn Exp $ */
a86 2
	{ "ampintc",	0 },
	{ "amptimer",	0 },
@


1.3
log
@Bring back 'mostly' working omdog support.
@
text
@d1 1
a1 1
/* $OpenBSD: omap.c,v 1.2 2011/11/11 10:46:35 matthieu Exp $ */
d158 1
a158 1
		if (od == NULL)
d161 2
@


1.2
log
@Re-add overro board support. ok drahn@@
@
text
@d1 1
a1 1
/* $OpenBSD: omap.c,v 1.1 2011/11/10 19:37:01 uwe Exp $ */
d57 1
d74 1
d89 1
@


1.1
log
@Reduce autoconf(4) overuse on beagle

Renamed `ahb' to `omap' and extended it to configure the on-chip
devices directly, based a board-specific table instead of trying to
maintain addresses, interrupt numbers and such for two OMAP variants
in the same config file.

This may be an intermediate step, but should provide us some relief
already. :)

Suggestions from deraadt and drahn; ok drahn@@
@
text
@d1 1
a1 1
/* $OpenBSD: ahb.c,v 1.1 2009/05/08 03:13:26 drahn Exp $ */
d68 16
d134 5
@

