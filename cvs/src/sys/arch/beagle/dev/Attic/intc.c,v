head	1.13;
access;
symbols
	OPENBSD_5_4:1.12.0.2
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.10.0.6
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.4
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.2
	OPENBSD_5_0:1.5.0.2
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.3.0.2
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.1.0.2
	OPENBSD_4_7_BASE:1.1
	OPENBSD_4_6:1.1.0.4
	OPENBSD_4_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.13
date	2013.09.04.14.38.36;	author patrick;	state dead;
branches;
next	1.12;

1.12
date	2013.05.21.15.43.40;	author rapha;	state Exp;
branches;
next	1.11;

1.11
date	2013.05.10.00.18.42;	author patrick;	state Exp;
branches;
next	1.10;

1.10
date	2011.11.10.19.37.01;	author uwe;	state Exp;
branches;
next	1.9;

1.9
date	2011.11.10.00.19.36;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2011.10.24.22.49.07;	author drahn;	state Exp;
branches;
next	1.7;

1.7
date	2011.10.21.22.55.01;	author drahn;	state Exp;
branches;
next	1.6;

1.6
date	2011.09.21.10.09.07;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2011.04.23.03.54.42;	author drahn;	state Exp;
branches;
next	1.4;

1.4
date	2010.09.20.06.33.48;	author matthew;	state Exp;
branches;
next	1.3;

1.3
date	2010.08.07.03.50.01;	author krw;	state Exp;
branches;
next	1.2;

1.2
date	2010.06.01.03.11.43;	author drahn;	state Exp;
branches;
next	1.1;

1.1
date	2009.05.08.03.13.26;	author drahn;	state Exp;
branches;
next	;


desc
@@


1.13
log
@In the future, we shouldn't have one port port ARM SoC, that's just
ridiculous.  This is the first step for a common and generic ARM port
for ARMv7 SoCs.
@
text
@/* $OpenBSD: intc.c,v 1.12 2013/05/21 15:43:40 rapha Exp $ */
/*
 * Copyright (c) 2007,2009 Dale Rahn <drahn@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/queue.h>
#include <sys/malloc.h>
#include <sys/device.h>
#include <sys/evcount.h>
#include <machine/bus.h>
#include <beagle/dev/omapvar.h>
#include "intc.h"

#define INTC_NUM_IRQ intc_nirq
#define INTC_NUM_BANKS (intc_nirq/32)
#define INTC_MAX_IRQ 128
#define INTC_MAX_BANKS (INTC_MAX_IRQ/32)

/* registers */
#define	INTC_REVISION		0x00	/* R */
#define	INTC_SYSCONFIG		0x10	/* RW */
#define		INTC_SYSCONFIG_AUTOIDLE		0x1
#define		INTC_SYSCONFIG_SOFTRESET	0x2
#define	INTC_SYSSTATUS		0x14	/* R */
#define		INTC_SYSSYSTATUS_RESETDONE	0x1
#define	INTC_SIR_IRQ		0x40	/* R */	
#define	INTC_SIR_FIQ		0x44	/* R */
#define	INTC_CONTROL		0x48	/* RW */
#define		INTC_CONTROL_NEWIRQ	0x1
#define		INTC_CONTROL_NEWFIQ	0x2
#define		INTC_CONTROL_GLOBALMASK	0x1
#define	INTC_PROTECTION		0x4c	/* RW */
#define		INTC_PROTECTION_PROT 1	/* only privileged mode */
#define	INTC_IDLE		0x50	/* RW */

#define INTC_IRQ_TO_REG(i)	(((i) >> 5) & 0x3)
#define INTC_IRQ_TO_REGi(i)	((i) & 0x1f)
#define	INTC_ITRn(i)		0x80+(0x20*i)+0x00	/* R */
#define	INTC_MIRn(i)		0x80+(0x20*i)+0x04	/* RW */
#define	INTC_CLEARn(i)		0x80+(0x20*i)+0x08	/* RW */
#define	INTC_SETn(i)		0x80+(0x20*i)+0x0c	/* RW */
#define	INTC_ISR_SETn(i)	0x80+(0x20*i)+0x10	/* RW */
#define	INTC_ISR_CLEARn(i)	0x80+(0x20*i)+0x14	/* RW */
#define INTC_PENDING_IRQn(i)	0x80+(0x20*i)+0x18	/* R */
#define INTC_PENDING_FIQn(i)	0x80+(0x20*i)+0x1c	/* R */

#define INTC_ILRn(i)		0x100+(4*i)
#define		INTC_ILR_IRQ	0x0		/* not of FIQ */
#define		INTC_ILR_FIQ	0x1
#define		INTC_ILR_PRIs(pri)	((pri) << 2)
#define		INTC_ILR_PRI(reg)	(((reg) >> 2) & 0x2f)
#define		INTC_MIN_PRI	63
#define		INTC_STD_PRI	32
#define		INTC_MAX_PRI	0

struct intrhand {
	TAILQ_ENTRY(intrhand) ih_list;	/* link on intrq list */
	int (*ih_func)(void *);		/* handler */
	void *ih_arg;			/* arg for handler */
	int ih_ipl;			/* IPL_* */
	int ih_irq;			/* IRQ number */
	struct evcount	ih_count;
	char *ih_name;
};

struct intrq {
	TAILQ_HEAD(, intrhand) iq_list;	/* handler list */
	int iq_irq;			/* IRQ to mask while handling */
	int iq_levels;			/* IPL_*'s this IRQ has */
	int iq_ist;			/* share type */
};

volatile int softint_pending;

struct intrq intc_handler[INTC_MAX_IRQ];
u_int32_t intc_smask[NIPL];
u_int32_t intc_imask[INTC_MAX_BANKS][NIPL];

bus_space_tag_t		intc_iot;
bus_space_handle_t	intc_ioh;
int			intc_nirq;

void	intc_attach(struct device *, struct device *, void *);
int	intc_spllower(int new);
int	intc_splraise(int new);
void	intc_setipl(int new);
void	intc_calc_mask(void);

struct cfattach	intc_ca = {
	sizeof (struct device), NULL, intc_attach
};

struct cfdriver intc_cd = {
	NULL, "intc", DV_DULL
};

int intc_attached = 0;

void
intc_attach(struct device *parent, struct device *self, void *args)
{
	struct omap_attach_args *oa = args;
	int i;
	u_int32_t rev;

	intc_iot = oa->oa_iot;
	if (bus_space_map(intc_iot, oa->oa_dev->mem[0].addr,
	    oa->oa_dev->mem[0].size, 0, &intc_ioh))
		panic("intc_attach: bus_space_map failed!");

	rev = bus_space_read_4(intc_iot, intc_ioh, INTC_REVISION);

	printf(" rev %d.%d\n", rev >> 4 & 0xf, rev & 0xf);

	/* software reset of the part? */
	/* set protection bit (kernel only)? */
#if 0
	bus_space_write_4(intc_iot, intc_ioh, INTC_PROTECTION,
	     INTC_PROTECTION_PROT);
#endif

	/* enable interface clock power saving mode */
	bus_space_write_4(intc_iot, intc_ioh, INTC_SYSCONFIG,
	    INTC_SYSCONFIG_AUTOIDLE);

	switch (board_id) {
	case BOARD_ID_AM335X_BEAGLEBONE:
		intc_nirq = 128;
		break;
	default:
		intc_nirq = 96;
		break;
	}

	/* mask all interrupts */
	for (i = 0; i < INTC_NUM_BANKS; i++)
		bus_space_write_4(intc_iot, intc_ioh, INTC_MIRn(i), 0xffffffff);

	for (i = 0; i < INTC_NUM_IRQ; i++) {
		bus_space_write_4(intc_iot, intc_ioh, INTC_ILRn(i),
		    INTC_ILR_PRIs(INTC_MIN_PRI)|INTC_ILR_IRQ);

		TAILQ_INIT(&intc_handler[i].iq_list);
	}

	intc_calc_mask();
	bus_space_write_4(intc_iot, intc_ioh, INTC_CONTROL,
	    INTC_CONTROL_NEWIRQ);

	intc_attached = 1;

	/* insert self as interrupt handler */
	arm_set_intr_handler(intc_splraise, intc_spllower, intc_splx,
	    intc_setipl,
	    intc_intr_establish, intc_intr_disestablish, intc_intr_string,
	    intc_irq_handler);

	intc_setipl(IPL_HIGH);  /* XXX ??? */
	enable_interrupts(I32_bit);
}

void
intc_calc_mask(void)
{
	struct cpu_info *ci = curcpu();
	int irq;
	struct intrhand *ih;
	int i;

	for (irq = 0; irq < INTC_NUM_IRQ; irq++) {
		int max = IPL_NONE;
		int min = IPL_HIGH;
		TAILQ_FOREACH(ih, &intc_handler[irq].iq_list, ih_list) {
			if (ih->ih_ipl > max)
				max = ih->ih_ipl;

			if (ih->ih_ipl < min)
				min = ih->ih_ipl;
		}

		intc_handler[irq].iq_irq = max;

		if (max == IPL_NONE)
			min = IPL_NONE;

#ifdef DEBUG_INTC
		if (min != IPL_NONE) {
			printf("irq %d to block at %d %d reg %d bit %d\n",
			    irq, max, min, INTC_IRQ_TO_REG(irq),
			    INTC_IRQ_TO_REGi(irq));
		}
#endif
		/* Enable interrupts at lower levels, clear -> enable */
		for (i = 0; i < min; i++)
			intc_imask[INTC_IRQ_TO_REG(irq)][i] &=
			    ~(1 << INTC_IRQ_TO_REGi(irq));
		for (; i <= IPL_HIGH; i++)
			intc_imask[INTC_IRQ_TO_REG(irq)][i] |=
			    1 << INTC_IRQ_TO_REGi(irq);
		/* XXX - set enable/disable, priority */ 
		bus_space_write_4(intc_iot, intc_ioh, INTC_ILRn(irq),
		    INTC_ILR_PRIs(NIPL-max)|INTC_ILR_IRQ);
	}
	arm_init_smask();
	intc_setipl(ci->ci_cpl);
}

void
intc_splx(int new)
{
	struct cpu_info *ci = curcpu();
	intc_setipl(new);

	if (ci->ci_ipending & arm_smask[ci->ci_cpl])
		arm_do_pending_intr(ci->ci_cpl);
}

int
intc_spllower(int new)
{
	struct cpu_info *ci = curcpu();
	int old = ci->ci_cpl;
	intc_splx(new);
	return (old);
}

int
intc_splraise(int new)
{
	struct cpu_info *ci = curcpu();
	int old;
	old = ci->ci_cpl;

	/*
	 * setipl must always be called because there is a race window
	 * where the variable is updated before the mask is set
	 * an interrupt occurs in that window without the mask always
	 * being set, the hardware might not get updated on the next
	 * splraise completely messing up spl protection.
	 */
	if (old > new)
		new = old;

	intc_setipl(new);
  
	return (old);
}

void
intc_setipl(int new)
{
	struct cpu_info *ci = curcpu();
	int i;
	int psw;
	if (intc_attached == 0)
		return;

	psw = disable_interrupts(I32_bit);
#if 0
	{
		volatile static int recursed = 0;
		if (recursed == 0) {
			recursed = 1;
			if (new != 12) 
				printf("setipl %d\n", new);
			recursed = 0;
		}
	}
#endif
	ci->ci_cpl = new;
	for (i = 0; i < INTC_NUM_BANKS; i++)
		bus_space_write_4(intc_iot, intc_ioh,
		    INTC_MIRn(i), intc_imask[i][new]);
	bus_space_write_4(intc_iot, intc_ioh, INTC_CONTROL,
	    INTC_CONTROL_NEWIRQ);
	restore_interrupts(psw);
}

void
intc_intr_bootstrap(vaddr_t addr)
{
	int i, j;
	extern struct bus_space armv7_bs_tag;
	intc_iot = &armv7_bs_tag;
	intc_ioh = addr;
	for (i = 0; i < INTC_NUM_BANKS; i++)
		for (j = 0; j < NIPL; j++)
			intc_imask[i][j] = 0xffffffff;
}

void
intc_irq_handler(void *frame)
{
	int irq, pri, s;
	struct intrhand *ih;
	void *arg;

	irq = bus_space_read_4(intc_iot, intc_ioh, INTC_SIR_IRQ);
#ifdef DEBUG_INTC
	printf("irq %d fired\n", irq);
#endif

	pri = intc_handler[irq].iq_irq;
	s = intc_splraise(pri);
	TAILQ_FOREACH(ih, &intc_handler[irq].iq_list, ih_list) {
		if (ih->ih_arg != 0)
			arg = ih->ih_arg;
		else
			arg = frame;

		if (ih->ih_func(arg)) 
			ih->ih_count.ec_count++;

	}
	bus_space_write_4(intc_iot, intc_ioh, INTC_CONTROL,
	    INTC_CONTROL_NEWIRQ);

	intc_splx(s);
}

void *
intc_intr_establish(int irqno, int level, int (*func)(void *),
    void *arg, char *name)
{
	int psw;
	struct intrhand *ih;

	if (irqno < 0 || irqno >= INTC_NUM_IRQ)
		panic("intc_intr_establish: bogus irqnumber %d: %s",
		     irqno, name);
	psw = disable_interrupts(I32_bit);

	/* no point in sleeping unless someone can free memory. */
	ih = (struct intrhand *)malloc (sizeof *ih, M_DEVBUF,
	    cold ? M_NOWAIT : M_WAITOK);
	if (ih == NULL)
		panic("intr_establish: can't malloc handler info");
	ih->ih_func = func;
	ih->ih_arg = arg;
	ih->ih_ipl = level;
	ih->ih_irq = irqno;
	ih->ih_name = name;

	TAILQ_INSERT_TAIL(&intc_handler[irqno].iq_list, ih, ih_list);

	if (name != NULL)
		evcount_attach(&ih->ih_count, name, &ih->ih_irq);

#ifdef DEBUG_INTC
	printf("intc_intr_establish irq %d level %d [%s]\n", irqno, level,
	    name);
#endif
	intc_calc_mask();
	
	restore_interrupts(psw);
	return (ih);
}

void
intc_intr_disestablish(void *cookie)
{
	int psw;
	struct intrhand *ih = cookie;
	int irqno = ih->ih_irq;
	psw = disable_interrupts(I32_bit);
	TAILQ_REMOVE(&intc_handler[irqno].iq_list, ih, ih_list);
	if (ih->ih_name != NULL)
		evcount_detach(&ih->ih_count);
	free(ih, M_DEVBUF);
	restore_interrupts(psw);
}

const char *
intc_intr_string(void *cookie)
{
	return "huh?";
}


#if 0
int intc_tst(void *a);

int
intc_tst(void *a)
{
	printf("inct_tst called\n");
	bus_space_write_4(intc_iot, intc_ioh, INTC_ISR_CLEARn(0), 2);
	return 1;
}

void intc_test(void);
void intc_test(void)
{
	void * ih;
	printf("about to register handler\n");
	ih = intc_intr_establish(1, IPL_BIO, intc_tst, NULL, "intctst");

	printf("about to set bit\n");
	bus_space_write_4(intc_iot, intc_ioh, INTC_ISR_SETn(0), 2);

	printf("about to clear bit\n");
	bus_space_write_4(intc_iot, intc_ioh, INTC_ISR_CLEARn(0), 2);

	printf("about to remove handler\n");
	intc_intr_disestablish(ih);

	printf("done\n");
}
#endif
@


1.12
log
@Remove some unused defines and make the number of interrupt lines variable.

ok bmercer@@
@
text
@d1 1
a1 1
/* $OpenBSD: intc.c,v 1.11 2013/05/10 00:18:42 patrick Exp $ */
@


1.11
log
@whitespaces
@
text
@d1 1
a1 1
/* $OpenBSD: intc.c,v 1.10 2011/11/10 19:37:01 uwe Exp $ */
d28 5
d44 1
a44 1
#define		INTC_CONTROL_NEWFIQ	0x1
a60 27
#define	INTC_ITR0		0x80	/* R */
#define	INTC_MIR0		0x84	/* RW */
#define	INTC_CLEAR0		0x88	/* RW */
#define	INTC_SET0		0x8c	/* RW */
#define	INTC_ISR_SET0		0x90	/* RW */
#define	INTC_ISR_CLEAR0		0x94	/* RW */
#define INTC_PENDING_IRQ0	0x98 	/* R */
#define INTC_PENDING_FIQ0	0x9c 	/* R */

#define	INTC_ITR1		0xa0	/* R */
#define	INTC_MIR1		0xa4	/* RW */
#define	INTC_CLEAR1		0xa8	/* RW */
#define	INTC_SET1		0xac	/* RW */
#define	INTC_ISR_SET1		0xb0	/* RW */
#define	INTC_ISR_CLEAR1		0xb4	/* RW */
#define INTC_PENDING_IRQ1	0xb8 	/* R */
#define INTC_PENDING_FIQ1	0xbc 	/* R */

#define	INTC_ITR2		0xc0	/* R */
#define	INTC_MIR2		0xc4	/* RW */
#define	INTC_CLEAR2		0xc8	/* RW */
#define	INTC_SET2		0xcc	/* RW */
#define	INTC_ISR_SET2		0xd0	/* RW */
#define	INTC_ISR_CLEAR2		0xd4	/* RW */
#define INTC_PENDING_IRQ2	0xd8 	/* R */
#define INTC_PENDING_FIQ2	0xdc 	/* R */

a69 2
#define NIRQ	INTC_NUM_IRQ

d89 1
a89 1
struct intrq intc_handler[NIRQ];
d91 1
a91 1
u_int32_t intc_imask[3][NIPL];
d95 1
d136 12
a147 1
	/* XXX - check power saving bit */
d150 2
a151 3
	bus_space_write_4(intc_iot, intc_ioh, INTC_MIR0, 0xffffffff);
	bus_space_write_4(intc_iot, intc_ioh, INTC_MIR1, 0xffffffff);
	bus_space_write_4(intc_iot, intc_ioh, INTC_MIR2, 0xffffffff);
d153 1
a153 1
	for (i = 0; i < NIRQ; i++) {
d184 1
a184 1
	for (irq = 0; irq < NIRQ; irq++) {
d285 1
a285 1
	for (i = 0; i < 3; i++)
d300 1
a300 1
	for (i = 0; i < 3; i++)
d342 1
a342 1
	if (irqno < 0 || irqno >= NIRQ)
d401 1
a401 1
	bus_space_write_4(intc_iot, intc_ioh, INTC_ISR_CLEAR0, 2);
d413 1
a413 1
	bus_space_write_4(intc_iot, intc_ioh, INTC_ISR_SET0, 2);
d416 1
a416 1
	bus_space_write_4(intc_iot, intc_ioh, INTC_ISR_CLEAR0, 2);
@


1.10
log
@Reduce autoconf(4) overuse on beagle

Renamed `ahb' to `omap' and extended it to configure the on-chip
devices directly, based a board-specific table instead of trying to
maintain addresses, interrupt numbers and such for two OMAP variants
in the same config file.

This may be an intermediate step, but should provide us some relief
already. :)

Suggestions from deraadt and drahn; ok drahn@@
@
text
@d1 1
a1 1
/* $OpenBSD: intc.c,v 1.9 2011/11/10 00:19:36 matthieu Exp $ */
d241 1
a241 1
        if (ci->ci_ipending & arm_smask[ci->ci_cpl])
@


1.9
log
@Add gumstix overo support. It's very similar to be beagleboard at this
point. So add it's card id and handle it like the beagleboard.
ok drahn@@, miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: intc.c,v 1.8 2011/10/24 22:49:07 drahn Exp $ */
d25 1
a25 1
#include <arch/beagle/beagle/ahb.h>
a91 2
#define	INTC_SIZE		0x200

a119 1
int	intc_match(struct device *, void *, void *);
d127 1
a127 1
	sizeof (struct device), intc_match, intc_attach
a135 19
int
intc_match(struct device *parent, void *v, void *aux)
{
	switch (board_id) {
	case BOARD_ID_OMAP3_BEAGLE:
	case BOARD_ID_OMAP3_OVERO:
		break; /* continue trying */
	case BOARD_ID_OMAP4_PANDA:
		return 0; /* not ported yet ??? - different */
	default:
		return 0; /* unknown */
	}
	if (intc_attached != 0)
		return 0;

	/* XXX */
	return (1);
}

d139 1
a139 1
        struct ahb_attach_args *aa = args;
d143 3
a145 2
	intc_iot = aa->aa_iot;
	if (bus_space_map(intc_iot, aa->aa_addr, INTC_SIZE, 0, &intc_ioh))
@


1.8
log
@Introduce a pluggable interrupt controller infrastructure for beagle,
to allow panda to share the port.
@
text
@d1 1
a1 1
/* $OpenBSD: intc.c,v 1.7 2011/10/21 22:55:01 drahn Exp $ */
d144 1
@


1.7
log
@Pile of diffs to improve beagle/panda status. fetching u-boot parameters
out of the register input. (with a beagle_start.S fix from uwe@@)
Devices now detect device_id from u-boot and decide to enable/disable
themselves in the device match routine. ok uwe@@
@
text
@d1 1
a1 1
/* $OpenBSD: intc.c,v 1.6 2011/09/21 10:09:07 miod Exp $ */
d26 1
a112 1
volatile int current_ipl_level = IPL_HIGH;
d124 2
a125 2
int	_spllower(int new);
int	_splraise(int new);
a127 1
void	intc_do_pending(void);
a178 1

a180 1

d192 1
d199 7
a205 1
	_splraise(IPL_HIGH);
d212 1
d251 2
a252 65
	for (i = IPL_NONE; i <= IPL_HIGH; i++) {
#if 0
		printf("calc_mask lvl %d val %x %x %x\n", i,
		    intc_imask[0][i], intc_imask[1][i], intc_imask[2][i] );
#endif
		intc_smask[i] = 0;
		if (i < IPL_SOFT)
			intc_smask[i] |= SI_TO_IRQBIT(SI_SOFT);
		if (i < IPL_SOFTCLOCK)
			intc_smask[i] |= SI_TO_IRQBIT(SI_SOFTCLOCK);
		if (i < IPL_SOFTNET)
			intc_smask[i] |= SI_TO_IRQBIT(SI_SOFTNET);
		if (i < IPL_SOFTTTY)
			intc_smask[i] |= SI_TO_IRQBIT(SI_SOFTTTY);
	}
	intc_setipl(current_ipl_level);
}

/*
 * XXX - is it possible to do the soft interrupts with actual interrupt
 * instead of emulating them?
 */
void
intc_do_pending(void)
{
	static int processing = 0;
	int oldirqstate, spl_save;

	oldirqstate = disable_interrupts(I32_bit);

	spl_save = current_ipl_level;

	if (processing == 1) {
		restore_interrupts(oldirqstate);
		return;
	}
//	printf("softint_pending %x\n", softint_pending);

#define DO_SOFTINT(si, ipl) \
	if ((softint_pending & intc_smask[current_ipl_level]) &	\
	    SI_TO_IRQBIT(si)) {						\
		softint_pending &= ~SI_TO_IRQBIT(si);			\
		if (current_ipl_level < ipl)				\
			intc_setipl(ipl);				\
		restore_interrupts(oldirqstate);			\
		softintr_dispatch(si);					\
		oldirqstate = disable_interrupts(I32_bit);		\
		intc_setipl(spl_save);					\
	}

	do {
		DO_SOFTINT(SI_SOFTTTY, IPL_SOFTTTY);
		DO_SOFTINT(SI_SOFTNET, IPL_SOFTNET);
		DO_SOFTINT(SI_SOFTCLOCK, IPL_SOFTCLOCK);
		DO_SOFTINT(SI_SOFT, IPL_SOFT);
	} while (softint_pending & intc_smask[current_ipl_level]);
		

#if 0
	printf("exit softint_pending %x pri %x mask %x\n", softint_pending,
	    current_ipl_level, intc_smask[current_ipl_level]);
#endif

	processing = 0;
	restore_interrupts(oldirqstate);
d256 1
a256 1
splx(int new)
d258 1
a258 1

d261 2
a262 2
	if (softint_pending & intc_smask[current_ipl_level])
		intc_do_pending();
d266 1
a266 1
_spllower(int new)
d268 3
a270 2
	int old = current_ipl_level;
	splx(new);
d275 1
a275 1
_splraise(int new)
d277 1
d279 1
a279 1
	old = current_ipl_level;
a296 16
_setsoftintr(int si)
{
	int oldirqstate;

	oldirqstate = disable_interrupts(I32_bit);
	softint_pending |= SI_TO_IRQBIT(si);
	restore_interrupts(oldirqstate);

	/* Process unmasked pending soft interrupts. */
	if (softint_pending & intc_smask[current_ipl_level])
		intc_do_pending();
}



void
d299 1
d306 12
a317 1
	current_ipl_level = new;
d351 1
a351 1
	s = _splraise(pri);
d364 2
a365 1
	splx(s);	 /* XXX - handles pending */
d420 7
a456 18

#ifdef DIAGNOSTIC
void
intc_splassert_check(int wantipl, const char *func)
{
        int oldipl = current_ipl_level;

        if (oldipl < wantipl) {
                splassert_fail(wantipl, oldipl, func);
                /*
                 * If the splassert_ctl is set to not panic, raise the ipl
                 * in a feeble attempt to reduce damage.
                 */
                intc_setipl(wantipl);
        }
}
#endif

@


1.6
log
@Fix range check in intc_intr_establish()
@
text
@d1 1
a1 1
/* $OpenBSD: intc.c,v 1.5 2011/04/23 03:54:42 drahn Exp $ */
d143 8
@


1.5
log
@start at high ipl (quiets noise on startup).
@
text
@d1 1
a1 1
/* $OpenBSD: intc.c,v 1.4 2010/09/20 06:33:48 matthew Exp $ */
d426 1
a426 1
	if (irqno < 0 || irqno > NIRQ)
@


1.4
log
@Get rid of evcount's support for arranging counters in a tree
hierarchy.  Everything attached to a single root node anyway, so at
best we had a bush.

"i think it is good" deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: intc.c,v 1.3 2010/08/07 03:50:01 krw Exp $ */
d112 1
a112 1
volatile int current_ipl_level;
@


1.3
log
@No "\n" needed at the end of panic() strings.

Bogus chunks pointed out by matthew@@ and miod@@. No cookies for
marco@@ and jasper@@.

ok deraadt@@ miod@@ matthew@@ jasper@@ macro@@
@
text
@d1 1
a1 1
/* $OpenBSD: intc.c,v 1.2 2010/06/01 03:11:43 drahn Exp $ */
d445 1
a445 2
		evcount_attach(&ih->ih_count, name, (void *)&ih->ih_irq,
		    &evcount_intr);
@


1.2
log
@Fix splassert code, (previously hidden in DIAGNOSTIC).
@
text
@d1 1
a1 1
/* $OpenBSD: intc.c,v 1.1 2009/05/08 03:13:26 drahn Exp $ */
d427 1
a427 1
		panic("intc_intr_establish: bogus irqnumber %d: %s\n",
@


1.1
log
@Initial effort on a port to the omap35xx platform specifically beagleboard,
however other omap system may be supportable. Not functional until armv7
core changes are complete.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d502 18
@

