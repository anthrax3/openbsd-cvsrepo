head	1.12;
access;
symbols
	OPENBSD_5_4:1.11.0.2
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.8.0.6
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.4
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.2
	OPENBSD_5_0:1.4.0.4
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.3.0.2
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.1.0.2
	OPENBSD_4_7_BASE:1.1
	OPENBSD_4_6:1.1.0.4
	OPENBSD_4_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.12
date	2013.09.04.14.38.39;	author patrick;	state dead;
branches;
next	1.11;

1.11
date	2013.05.10.00.18.42;	author patrick;	state Exp;
branches;
next	1.10;

1.10
date	2013.05.03.17.54.27;	author patrick;	state Exp;
branches;
next	1.9;

1.9
date	2013.04.25.23.12.34;	author patrick;	state Exp;
branches;
next	1.8;

1.8
date	2011.11.10.19.37.01;	author uwe;	state Exp;
branches;
next	1.7;

1.7
date	2011.11.10.00.19.36;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2011.10.24.22.49.07;	author drahn;	state Exp;
branches;
next	1.5;

1.5
date	2011.10.21.22.55.01;	author drahn;	state Exp;
branches;
next	1.4;

1.4
date	2010.09.20.06.33.48;	author matthew;	state Exp;
branches;
next	1.3;

1.3
date	2010.08.07.03.50.01;	author krw;	state Exp;
branches;
next	1.2;

1.2
date	2010.05.09.15.46.17;	author jasper;	state Exp;
branches;
next	1.1;

1.1
date	2009.05.08.03.13.26;	author drahn;	state Exp;
branches;
next	;


desc
@@


1.12
log
@In the future, we shouldn't have one port port ARM SoC, that's just
ridiculous.  This is the first step for a common and generic ARM port
for ARMv7 SoCs.
@
text
@/* $OpenBSD: omgpio.c,v 1.11 2013/05/10 00:18:42 patrick Exp $ */
/*
 * Copyright (c) 2007,2009 Dale Rahn <drahn@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/queue.h>
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/evcount.h>

#include <arm/cpufunc.h>

#include <machine/bus.h>
#include <machine/intr.h>

#include <beagle/dev/omapvar.h>
#include <beagle/dev/omgpiovar.h>

/* OMAP3 registers */
#define	GPIO3_REVISION		0x00
#define	GPIO3_SYSCONFIG		0x10
#define	GPIO3_SYSSTATUS		0x14
#define	GPIO3_IRQSTATUS1	0x18
#define	GPIO3_IRQENABLE1	0x1C
#define	GPIO3_WAKEUPENABLE	0x20
#define	GPIO3_IRQSTATUS2	0x28
#define	GPIO3_IRQENABLE2	0x2C
#define	GPIO3_CTRL		0x30
#define	GPIO3_OE		0x34
#define	GPIO3_DATAIN		0x38
#define	GPIO3_DATAOUT		0x3C
#define	GPIO3_LEVELDETECT0	0x40
#define	GPIO3_LEVELDETECT1	0x44
#define	GPIO3_RISINGDETECT	0x48
#define	GPIO3_FALLINGDETECT	0x4C
#define	GPIO3_DEBOUNCENABLE	0x50
#define	GPIO3_DEBOUNCINGTIME	0x54
#define	GPIO3_CLEARIRQENABLE1	0x60
#define	GPIO3_SETIRQENABLE1	0x64
#define	GPIO3_CLEARIRQENABLE2	0x70
#define	GPIO3_SETIRQENABLE2	0x74
#define	GPIO3_CLEARWKUENA	0x80
#define	GPIO3_SETWKUENA		0x84
#define	GPIO3_CLEARDATAOUT	0x90
#define	GPIO3_SETDATAOUT	0x94
#define	GPIO3_SIZE		0x100

/* OMAP4 registers */
#define GPIO4_REVISION		0x00
#define GPIO4_SYSCONFIG		0x10
#define GPIO4_IRQSTATUS_RAW_0	0x24
#define GPIO4_IRQSTATUS_RAW_1	0x28
#define GPIO4_IRQSTATUS_0	0x2C
#define GPIO4_IRQSTATUS_1	0x30
#define GPIO4_IRQSTATUS_SET_0	0x34
#define GPIO4_IRQSTATUS_SET_1	0x38
#define GPIO4_IRQSTATUS_CLR_0	0x3C
#define GPIO4_IRQSTATUS_CLR_1	0x40
#define GPIO4_IRQWAKEN_0	0x44
#define GPIO4_IRQWAKEN_1	0x48
#define GPIO4_SYSSTATUS		0x114
#define GPIO4_IRQSTATUS1	0x118
#define GPIO4_IRQENABLE1	0x11C
#define GPIO4_WAKEUPENABLE	0x120
#define GPIO4_IRQSTATUS2	0x128
#define GPIO4_IRQENABLE2	0x12C
#define GPIO4_CTRL		0x130
#define GPIO4_OE		0x134
#define GPIO4_DATAIN		0x138
#define GPIO4_DATAOUT		0x13C
#define GPIO4_LEVELDETECT0	0x140
#define GPIO4_LEVELDETECT1	0x144
#define GPIO4_RISINGDETECT 	0x148
#define GPIO4_FALLINGDETECT	0x14C
#define GPIO4_DEBOUNCENABLE	0x150
#define GPIO4_DEBOUNCINGTIME	0x154
#define GPIO4_CLEARIRQENABLE1	0x160
#define GPIO4_SETIRQENABLE1	0x164
#define GPIO4_CLEARIRQENABLE2	0x170
#define GPIO4_SETIRQENABLE2	0x174
#define GPIO4_CLEARWKUPENA	0x180
#define GPIO4_SETWKUENA		0x184
#define GPIO4_CLEARDATAOUT	0x190
#define GPIO4_SETDATAOUT	0x194

#define GPIO_NUM_PINS		32

struct intrhand {
	int (*ih_func)(void *);		/* handler */
	void *ih_arg;			/* arg for handler */
	int ih_ipl;			/* IPL_* */
	int ih_irq;			/* IRQ number */
	int ih_gpio;			/* gpio pin */
	struct evcount	ih_count;
	char *ih_name;
};

struct omgpio_softc {
	struct device		sc_dev;
	bus_space_tag_t		sc_iot;
	bus_space_handle_t	sc_ioh;
	void			*sc_ih_h;
	void			*sc_ih_l;
	int 			sc_max_il;
	int 			sc_min_il;
	int			sc_irq;
	struct intrhand		*sc_handlers[GPIO_NUM_PINS];
	int			sc_omap_ver;
	unsigned int (*sc_get_bit)(struct omgpio_softc *sc,
	    unsigned int gpio);
	void (*sc_set_bit)(struct omgpio_softc *sc,
	    unsigned int gpio);
	void (*sc_clear_bit)(struct omgpio_softc *sc,
	    unsigned int gpio);
	void (*sc_set_dir)(struct omgpio_softc *sc,
	    unsigned int gpio, unsigned int dir);
};

#define GPIO_PIN_TO_INST(x)	((x) >> 5)
#define GPIO_PIN_TO_OFFSET(x)	((x) & 0x1f)

int omgpio_match(struct device *parent, void *v, void *aux);
void omgpio_attach(struct device *parent, struct device *self, void *args);
void omgpio_recalc_interrupts(struct omgpio_softc *sc);
int omgpio_irq(void *);
int omgpio_irq_dummy(void *);

unsigned int omgpio_v3_get_bit(struct omgpio_softc *, unsigned int);
void omgpio_v3_set_bit(struct omgpio_softc *, unsigned int);
void omgpio_v3_clear_bit(struct omgpio_softc *, unsigned int);
void omgpio_v3_set_dir(struct omgpio_softc *, unsigned int , unsigned int);
unsigned int omgpio_v4_get_bit(struct omgpio_softc *, unsigned int);
void omgpio_v4_set_bit(struct omgpio_softc *, unsigned int);
void omgpio_v4_clear_bit(struct omgpio_softc *, unsigned int);
void omgpio_v4_set_dir(struct omgpio_softc *, unsigned int, unsigned int);
unsigned int omgpio_v4_get_dir(struct omgpio_softc *, unsigned int);


struct cfattach omgpio_ca = {
	sizeof (struct omgpio_softc), omgpio_match, omgpio_attach
};

struct cfdriver omgpio_cd = {
	NULL, "omgpio", DV_DULL
};

int
omgpio_match(struct device *parent, void *v, void *aux)
{
	switch (board_id) {
	case BOARD_ID_OMAP3_BEAGLE:
	case BOARD_ID_OMAP3_OVERO:
		break; /* continue trying */
	case BOARD_ID_OMAP4_PANDA:
		break; /* continue trying */
	default:
		return 0; /* unknown */
	}
	return (1);
}

void
omgpio_attach(struct device *parent, struct device *self, void *args)
{
	struct omap_attach_args *oa = args;
	struct omgpio_softc *sc = (struct omgpio_softc *) self;
	u_int32_t rev;

	sc->sc_iot = oa->oa_iot;
	if (bus_space_map(sc->sc_iot, oa->oa_dev->mem[0].addr,
	    oa->oa_dev->mem[0].size, 0, &sc->sc_ioh))
		panic("omgpio_attach: bus_space_map failed!");


	switch (board_id) {
	case BOARD_ID_OMAP3_BEAGLE:
	case BOARD_ID_OMAP3_OVERO:
		sc->sc_omap_ver  = 3;
		sc->sc_get_bit  = omgpio_v3_get_bit;
		sc->sc_set_bit = omgpio_v3_set_bit;
		sc->sc_clear_bit = omgpio_v3_clear_bit;
		sc->sc_set_dir = omgpio_v3_set_dir;
		break;
	case BOARD_ID_OMAP4_PANDA:
		sc->sc_omap_ver  = 4;
		sc->sc_get_bit  = omgpio_v4_get_bit;
		sc->sc_set_bit = omgpio_v4_set_bit;
		sc->sc_clear_bit = omgpio_v4_clear_bit;
		sc->sc_set_dir = omgpio_v4_set_dir;
		break;
	}

	rev = bus_space_read_4(sc->sc_iot, sc->sc_ioh, GPIO3_REVISION);

	printf(" omap%d rev %d.%d\n", sc->sc_omap_ver, rev >> 4 & 0xf,
	    rev & 0xf);

	sc->sc_irq = oa->oa_dev->irq[0];

	if (sc->sc_omap_ver == 3) {
		bus_space_write_4(sc->sc_iot, sc->sc_ioh,
		    GPIO3_CLEARIRQENABLE1, ~0);
	} else if (sc->sc_omap_ver == 4) {
		/* XXX - nothing? */
	}

	/* XXX - SYSCONFIG */
	/* XXX - CTRL */
	/* XXX - DEBOUNCE */
}

/* XXX - This assumes MCU INTERRUPTS are IRQ1, and DSP are IRQ2 */

#if 0
/* XXX - FIND THESE REGISTERS !!! */
unsigned int
omgpio_get_function(unsigned int gpio, unsigned int fn)
{
	return 0;
}

void
omgpio_set_function(unsigned int gpio, unsigned int fn)
{
}
#endif

/*
 * get_bit() is not reliable if used on an output pin.
 */

unsigned int
omgpio_get_bit(unsigned int gpio)
{
	struct omgpio_softc *sc = omgpio_cd.cd_devs[GPIO_PIN_TO_INST(gpio)];

	return sc->sc_get_bit(sc, gpio);
}

void
omgpio_set_bit(unsigned int gpio)
{
	struct omgpio_softc *sc = omgpio_cd.cd_devs[GPIO_PIN_TO_INST(gpio)];

	sc->sc_set_bit(sc, gpio);
}

void
omgpio_clear_bit(unsigned int gpio)
{
	struct omgpio_softc *sc = omgpio_cd.cd_devs[GPIO_PIN_TO_INST(gpio)];

	sc->sc_clear_bit(sc, gpio);
}
void
omgpio_set_dir(unsigned int gpio, unsigned int dir)
{
	struct omgpio_softc *sc = omgpio_cd.cd_devs[GPIO_PIN_TO_INST(gpio)];

	sc->sc_set_dir(sc, gpio, dir);
}

unsigned int
omgpio_v3_get_bit(struct omgpio_softc *sc, unsigned int gpio)
{
	u_int32_t reg;

	reg = bus_space_read_4(sc->sc_iot, sc->sc_ioh, GPIO3_DATAIN);
	return (reg >> GPIO_PIN_TO_OFFSET(gpio)) & 0x1;
}

void
omgpio_v3_set_bit(struct omgpio_softc *sc, unsigned int gpio)
{
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, GPIO3_SETDATAOUT,
	    1 << GPIO_PIN_TO_OFFSET(gpio));
}

void
omgpio_v3_clear_bit(struct omgpio_softc *sc, unsigned int gpio)
{
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, GPIO3_CLEARDATAOUT,
	    1 << GPIO_PIN_TO_OFFSET(gpio));
}

void
omgpio_v3_set_dir(struct omgpio_softc *sc, unsigned int gpio, unsigned int dir)
{
	int s;
	u_int32_t reg;

	s = splhigh();

	reg = bus_space_read_4(sc->sc_iot, sc->sc_ioh, GPIO3_DATAIN);
	if (dir == OMGPIO_DIR_IN)
		reg |= 1 << GPIO_PIN_TO_OFFSET(gpio);
	else
		reg &= ~(1 << GPIO_PIN_TO_OFFSET(gpio));
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, GPIO3_OE, reg);

	splx(s);
}

unsigned int
omgpio_v4_get_bit(struct omgpio_softc *sc, unsigned int gpio)
{
	u_int32_t reg;

	if(omgpio_v4_get_dir(sc, gpio) == OMGPIO_DIR_IN)
		reg = bus_space_read_4(sc->sc_iot, sc->sc_ioh, GPIO4_DATAIN);
	else
		reg = bus_space_read_4(sc->sc_iot, sc->sc_ioh, GPIO4_DATAOUT);
	return (reg >> GPIO_PIN_TO_OFFSET(gpio)) & 0x1;
}

void
omgpio_v4_set_bit(struct omgpio_softc *sc, unsigned int gpio)
{

	bus_space_write_4(sc->sc_iot, sc->sc_ioh, GPIO4_SETDATAOUT,
		1 << GPIO_PIN_TO_OFFSET(gpio));
}

void
omgpio_v4_clear_bit(struct omgpio_softc *sc, unsigned int gpio)
{
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, GPIO4_CLEARDATAOUT,
		1 << GPIO_PIN_TO_OFFSET(gpio));
}

void
omgpio_v4_set_dir(struct omgpio_softc *sc, unsigned int gpio, unsigned int dir)
{
	int s;
	u_int32_t reg;

	s = splhigh();

	reg = bus_space_read_4(sc->sc_iot, sc->sc_ioh, GPIO4_OE);
	if (dir == OMGPIO_DIR_IN)
		reg |= 1 << GPIO_PIN_TO_OFFSET(gpio);
	else
		reg &= ~(1 << GPIO_PIN_TO_OFFSET(gpio));
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, GPIO4_OE, reg);

	splx(s);
}

unsigned int
omgpio_v4_get_dir(struct omgpio_softc *sc, unsigned int gpio)
{
	int s;
	u_int32_t dir, reg;

	s = splhigh();

	reg = bus_space_read_4(sc->sc_iot, sc->sc_ioh, GPIO4_OE);
	if (reg & (1 << GPIO_PIN_TO_OFFSET(gpio)))
		dir = OMGPIO_DIR_IN;
	else
		dir = OMGPIO_DIR_OUT;

	splx(s);

	return dir;
}

#if 0
void
omgpio_clear_intr(struct omgpio_softc *sc, unsigned int gpio)
{
	struct omgpio_softc *sc = omgpio_cd.cd_devs[GPIO_PIN_TO_INST(gpio)];

	bus_space_write_4(sc->sc_iot, sc->sc_ioh, GPIO3_IRQSTATUS1,
	    1 << GPIO_PIN_TO_OFFSET(gpio));
}

void
omgpio_intr_mask(struct omgpio_softc *sc, unsigned int gpio)
{
	struct omgpio_softc *sc = omgpio_cd.cd_devs[GPIO_PIN_TO_INST(gpio)];

	bus_space_write_4(sc->sc_iot, sc->sc_ioh, GPIO3_CLEARIRQENABLE1,
	    1 << GPIO_PIN_TO_OFFSET(gpio));
}

void
omgpio_intr_unmask(struct omgpio_softc *sc, unsigned int gpio)
{
	struct omgpio_softc *sc = omgpio_cd.cd_devs[GPIO_PIN_TO_INST(gpio)];

	bus_space_write_4(sc->sc_iot, sc->sc_ioh, GPIO3_SETIRQENABLE1,
	    1 << GPIO_PIN_TO_OFFSET(gpio));
}

void
omgpio_intr_level(struct omgpio_softc *sc, unsigned int gpio, unsigned int level)
{
	u_int32_t fe, re, l0, l1, bit;
	struct omgpio_softc *sc = omgpio_cd.cd_devs[GPIO_PIN_TO_INST(gpio)];
	int s;

	s = splhigh();

	fe = bus_space_read_4(sc->sc_iot, sc->sc_ioh, GPIO3_FALLINGDETECT);
	re = bus_space_read_4(sc->sc_iot, sc->sc_ioh, GPIO3_RISINGDETECT);
	l0 = bus_space_read_4(sc->sc_iot, sc->sc_ioh, GPIO3_LEVELDETECT0);
	l1 = bus_space_read_4(sc->sc_iot, sc->sc_ioh, GPIO3_LEVELDETECT1);

	bit = 1 << GPIO_PIN_TO_OFFSET(gpio);

	switch (level) {
	case IST_NONE:
		fe &= ~bit;
		re &= ~bit;
		l0 &= ~bit;
		l1 &= ~bit;
		break;
	case IST_EDGE_FALLING:
		fe |= bit;
		re &= ~bit;
		l0 &= ~bit;
		l1 &= ~bit;
		break;
	case IST_EDGE_RISING:
		fe &= ~bit;
		re |= bit;
		l0 &= ~bit;
		l1 &= ~bit;
		break;
	case IST_PULSE: /* XXX */
		/* FALLTHRU */
	case IST_EDGE_BOTH:
		fe |= bit;
		re |= bit;
		l0 &= ~bit;
		l1 &= ~bit;
		break;
	case IST_LEVEL_LOW:
		fe &= ~bit;
		re &= ~bit;
		l0 |= bit;
		l1 &= ~bit;
		break;
	case IST_LEVEL_HIGH:
		fe &= ~bit;
		re &= ~bit;
		l0 &= ~bit;
		l1 |= bit;
		break;
	default:
		panic("omgpio_intr_level: bad level: %d", level);
		break;
	}

	bus_space_write_4(sc->sc_iot, sc->sc_ioh, GPIO3_FALLINGDETECT, fe);
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, GPIO3_RISINGDETECT, re);
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, GPIO3_LEVELDETECT0, l0);
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, GPIO3_LEVELDETECT1, l1);

	splx(s);
}

void *
omgpio_intr_establish(struct omgpio_softc *sc, unsigned int gpio, int level, int spl,
    int (*func)(void *), void *arg, char *name)
{
	int psw;
	struct intrhand *ih;
	struct omgpio_softc *sc;

	/*
	 * XXX - is gpio here the pin or the interrupt number
	 * which is 96 + gpio pin?
	 */

	if (GPIO_PIN_TO_INST(gpio) > omgpio_cd.cd_ndevs)
		panic("omgpio_intr_establish: bogus irqnumber %d: %s",
		    gpio, name);

	sc = omgpio_cd.cd_devs[GPIO_PIN_TO_INST(gpio)];

	if (sc->sc_handlers[GPIO_PIN_TO_OFFSET(gpio)] != NULL)
		panic("omgpio_intr_establish: gpio pin busy %d old %s new %s",
		    gpio, sc->sc_handlers[GPIO_PIN_TO_OFFSET(gpio)]->ih_name,
		    name);

	psw = disable_interrupts(I32_bit);

	/* no point in sleeping unless someone can free memory. */
	ih = (struct intrhand *)malloc( sizeof *ih, M_DEVBUF,
	    cold ? M_NOWAIT : M_WAITOK);
	if (ih == NULL)
		panic("intr_establish: can't malloc handler info");
	ih->ih_func = func;
	ih->ih_arg = arg;
	ih->ih_ipl = level;
	ih->ih_gpio = gpio;
	ih->ih_irq = gpio + 512;
	ih->ih_name = name;

	sc->sc_handlers[GPIO_PIN_TO_OFFSET(gpio)] = ih;

	evcount_attach(&ih->ih_count, name, &ih->ih_irq);

	omgpio_intr_level(gpio, level);
	omgpio_intr_unmask(gpio);

	omgpio_recalc_interrupts(sc);

	restore_interrupts(psw);

	return (ih);
}

void
omgpio_intr_disestablish(struct omgpio_softc *sc, void *cookie)
{
	int psw;
	struct intrhand *ih = cookie;
	struct omgpio_softc *sc = omgpio_cd.cd_devs[GPIO_PIN_TO_INST(ih->ih_gpio)];
	int gpio = ih->ih_gpio;
	psw = disable_interrupts(I32_bit);

	ih = sc->sc_handlers[GPIO_PIN_TO_OFFSET(gpio)];
	sc->sc_handlers[GPIO_PIN_TO_OFFSET(gpio)] = NULL;

	evcount_detach(&ih->ih_count);

	free(ih, M_DEVBUF);

	omgpio_intr_level(gpio, IST_NONE);
	omgpio_intr_mask(gpio);
	omgpio_clear_intr(gpio); /* Just in case */

	omgpio_recalc_interrupts(sc);

	restore_interrupts(psw);
}

int
omgpio_irq(void *v)
{
	struct omgpio_softc *sc = v;
	u_int32_t pending;
	struct intrhand *ih;
	int bit;

	pending = bus_space_read_4(sc->sc_iot, sc->sc_ioh, GPIO3_IRQSTATUS1);

	while (pending != 0) {
		bit = ffs(pending) - 1;
		ih = sc->sc_handlers[bit];

		if (ih != NULL) {
			if (ih->ih_func(ih->ih_arg))
				ih->ih_count.ec_count++;
			omgpio_clear_intr(ih->ih_gpio);
		} else {
			panic("omgpio: irq fired no handler, gpio %x %x %x",
				sc->sc_dev.dv_unit * 32 + bit, pending,
	bus_space_read_4(sc->sc_iot, sc->sc_ioh, GPIO3_IRQENABLE1)

				);
		}
		pending &= ~(1 << bit);
	}
	return 1;
}

int
omgpio_irq_dummy(void *v)
{
	return 0;
}

void
omgpio_recalc_interrupts(struct omgpio_softc *sc)
{
	struct intrhand *ih;
	int max = IPL_NONE;
	int min = IPL_HIGH;
	int i;

	for (i = 0; i < GPIO_NUM_PINS; i++) {
		ih = sc->sc_handlers[i];
		if (ih != NULL) {
			if (ih->ih_ipl > max)
				max = ih->ih_ipl;

			if (ih->ih_ipl < min)
				min = ih->ih_ipl;
		}
	}
	if (max == IPL_NONE)
		min = IPL_NONE;

#if 0
	if ((max == IPL_NONE || max != sc->sc_max_il) && sc->sc_ih_h != NULL)
		arm_intr_disestablish(sc->sc_ih_h);

	if (max != IPL_NONE && max != sc->sc_max_il) {
		sc->sc_ih_h = arm_intr_establish(sc->sc_irq, max, omgpio_irq,
		    sc, NULL);
	}
#else
	if (sc->sc_ih_h != NULL)
		arm_intr_disestablish(sc->sc_ih_h);

	if (max != IPL_NONE) {
		sc->sc_ih_h = arm_intr_establish(sc->sc_irq, max, omgpio_irq,
		    sc, NULL);
	}
#endif

	sc->sc_max_il = max;

	if (sc->sc_ih_l != NULL)
		arm_intr_disestablish(sc->sc_ih_l);

	if (max != min) {
		sc->sc_ih_h = arm_intr_establish(sc->sc_irq, min,
		    omgpio_irq_dummy, sc, NULL);
	}
	sc->sc_min_il = min;
}
#endif
@


1.11
log
@whitespaces
@
text
@d1 1
a1 1
/* $OpenBSD: omgpio.c,v 1.10 2013/05/03 17:54:27 patrick Exp $ */
@


1.10
log
@Don't return before calling splx.

found by and ok jsg@@
@
text
@d1 1
a1 1
/* $OpenBSD: omgpio.c,v 1.9 2013/04/25 23:12:34 patrick Exp $ */
d153 1
a153 1
struct cfattach	omgpio_ca = {
d190 15
a204 17

		case BOARD_ID_OMAP3_BEAGLE:
		case BOARD_ID_OMAP3_OVERO:
			sc->sc_omap_ver  = 3;
			sc->sc_get_bit  = omgpio_v3_get_bit;
			sc->sc_set_bit = omgpio_v3_set_bit;
			sc->sc_clear_bit = omgpio_v3_clear_bit;
			sc->sc_set_dir = omgpio_v3_set_dir;
			break;
		case BOARD_ID_OMAP4_PANDA:
			sc->sc_omap_ver  = 4;
			sc->sc_get_bit  = omgpio_v4_get_bit;
			sc->sc_set_bit = omgpio_v4_set_bit;
			sc->sc_clear_bit = omgpio_v4_clear_bit;
			sc->sc_set_dir = omgpio_v4_set_dir;
			break;
	
d214 1
a214 1
	if (sc->sc_omap_ver  == 3) {
a251 1
	
d281 1
a281 1
	
d387 1
a387 1
	
d396 1
a396 1
	
d405 1
a405 1
	
d423 1
a423 1
	
d426 2
a427 2
        switch (level) {
        case IST_NONE:
d433 1
a433 1
        case IST_EDGE_FALLING:
d439 1
a439 1
        case IST_EDGE_RISING:
d447 1
a447 1
        case IST_EDGE_BOTH:
d452 1
a452 1
                break;
d458 1
a458 1
                break;
a463 1
                break;
d465 4
a468 4
        default:
                panic("omgpio_intr_level: bad level: %d", level);
                break;
        }
d493 1
a493 1
		     gpio, name);
@


1.9
log
@Add GPIO support for the PandaBoard. Disable BeagleBoard's unused interrupt
functions for now.

ok bmercer@@
@
text
@d1 1
a1 1
/* $OpenBSD: omgpio.c,v 1.8 2011/11/10 19:37:01 uwe Exp $ */
d370 1
a370 1
	u_int32_t reg;
d376 1
a376 1
		return OMGPIO_DIR_IN;
d378 1
a378 1
		return OMGPIO_DIR_OUT;
d381 2
@


1.8
log
@Reduce autoconf(4) overuse on beagle

Renamed `ahb' to `omap' and extended it to configure the on-chip
devices directly, based a board-specific table instead of trying to
maintain addresses, interrupt numbers and such for two OMAP variants
in the same config file.

This may be an intermediate step, but should provide us some relief
already. :)

Suggestions from deraadt and drahn; ok drahn@@
@
text
@d1 1
a1 1
/* $OpenBSD: omgpio.c,v 1.7 2011/11/10 00:19:36 matthieu Exp $ */
d33 66
a98 30

/* registers */
#define	GPIO_REVISION		0x00
#define	GPIO_SYSCONFIG		0x10
#define	GPIO_SYSSTATUS		0x14
#define	GPIO_IRQSTATUS1		0x18
#define	GPIO_IRQENABLE1		0x1C
#define	GPIO_WAKEUPENABLE	0x20
#define	GPIO_IRQSTATUS2		0x28
#define	GPIO_IRQENABLE2		0x2C
#define	GPIO_CTRL		0x30
#define	GPIO_OE			0x34
#define	GPIO_DATAIN		0x38
#define	GPIO_DATAOUT		0x3C
#define	GPIO_LEVELDETECT0	0x40
#define	GPIO_LEVELDETECT1	0x44
#define	GPIO_RISINGDETECT	0x48
#define	GPIO_FALLINGDETECT	0x4C
#define	GPIO_DEBOUNCENABLE	0x50
#define	GPIO_DEBOUNCINGTIME	0x54
#define	GPIO_CLEARIRQENABLE1	0x60
#define	GPIO_SETIRQENABLE1	0x64
#define	GPIO_CLEARIRQENABLE2	0x70
#define	GPIO_SETIRQENABLE2	0x74
#define	GPIO_CLEARWKUENA	0x80
#define	GPIO_SETWKUENA		0x84
#define	GPIO_CLEARDATAOUT	0x90
#define	GPIO_SETDATAOUT		0x94
#define	GPIO_SIZE		0x100

d122 9
d142 11
d169 1
a169 1
		return 0; /* not ported yet ??? - different */
a187 1
	rev = bus_space_read_4(sc->sc_iot, sc->sc_ioh, GPIO_REVISION);
d189 24
a212 1
	printf(" rev %d.%d\n", rev >> 4 & 0xf, rev & 0xf);
d216 6
a221 1
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, GPIO_CLEARIRQENABLE1, ~0);
d252 2
a253 1
	u_int32_t reg;
a254 2
	reg = bus_space_read_4(sc->sc_iot, sc->sc_ioh, GPIO_DATAIN);
	return (reg >> GPIO_PIN_TO_OFFSET(gpio)) & 0x1;
d261 2
a262 3
	
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, GPIO_SETDATAOUT,
	    1 << GPIO_PIN_TO_OFFSET(gpio));
d269 15
d285 8
a292 1
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, GPIO_CLEARDATAOUT,
d297 53
a349 1
omgpio_set_dir(unsigned int gpio, unsigned int dir)
a350 1
	struct omgpio_softc *sc = omgpio_cd.cd_devs[GPIO_PIN_TO_INST(gpio)];
d356 1
a356 1
	reg = bus_space_read_4(sc->sc_iot, sc->sc_ioh, GPIO_DATAIN);
d361 18
a378 1
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, GPIO_OE, reg);
d383 1
d385 1
a385 1
omgpio_clear_intr(unsigned int gpio)
d389 1
a389 1
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, GPIO_IRQSTATUS1,
d394 1
a394 1
omgpio_intr_mask(unsigned int gpio)
d398 1
a398 1
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, GPIO_CLEARIRQENABLE1,
d403 1
a403 1
omgpio_intr_unmask(unsigned int gpio)
d407 1
a407 1
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, GPIO_SETIRQENABLE1,
d412 1
a412 1
omgpio_intr_level(unsigned int gpio, unsigned int level)
d420 4
a423 4
	fe = bus_space_read_4(sc->sc_iot, sc->sc_ioh, GPIO_FALLINGDETECT);
	re = bus_space_read_4(sc->sc_iot, sc->sc_ioh, GPIO_RISINGDETECT);
	l0 = bus_space_read_4(sc->sc_iot, sc->sc_ioh, GPIO_LEVELDETECT0);
	l1 = bus_space_read_4(sc->sc_iot, sc->sc_ioh, GPIO_LEVELDETECT1);
d472 4
a475 4
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, GPIO_FALLINGDETECT, fe);
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, GPIO_RISINGDETECT, re);
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, GPIO_LEVELDETECT0, l0);
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, GPIO_LEVELDETECT1, l1);
d481 1
a481 1
omgpio_intr_establish(unsigned int gpio, int level, int spl,
d533 1
a533 1
omgpio_intr_disestablish(void *cookie)
d565 1
a565 1
	pending = bus_space_read_4(sc->sc_iot, sc->sc_ioh, GPIO_IRQSTATUS1);
d578 1
a578 1
	bus_space_read_4(sc->sc_iot, sc->sc_ioh, GPIO_IRQENABLE1)
d643 1
@


1.7
log
@Add gumstix overo support. It's very similar to be beagleboard at this
point. So add it's card id and handle it like the beagleboard.
ok drahn@@, miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: omgpio.c,v 1.6 2011/10/24 22:49:07 drahn Exp $ */
d30 2
a31 3
#include <arch/beagle/beagle/ahb.h>
#include <arch/beagle/dev/omgpiovar.h>
#include "omgpio.h"
d123 1
a123 1
        struct ahb_attach_args *aa = args;
d127 3
a129 2
	sc->sc_iot = aa->aa_iot;
	if (bus_space_map(sc->sc_iot, aa->aa_addr, GPIO_SIZE, 0, &sc->sc_ioh))
d136 1
a136 1
	sc->sc_irq = aa->aa_intr;
d321 1
a321 1
	if (GPIO_PIN_TO_INST(gpio) > NOMGPIO)
@


1.6
log
@Introduce a pluggable interrupt controller infrastructure for beagle,
to allow panda to share the port.
@
text
@d1 1
a1 1
/* $OpenBSD: omgpio.c,v 1.5 2011/10/21 22:55:01 drahn Exp $ */
d111 1
@


1.5
log
@Pile of diffs to improve beagle/panda status. fetching u-boot parameters
out of the register input. (with a beagle_start.S fix from uwe@@)
Devices now detect device_id from u-boot and decide to enable/disable
themselves in the device match routine. ok uwe@@
@
text
@d1 1
a1 1
/* $OpenBSD: omgpio.c,v 1.4 2010/09/20 06:33:48 matthew Exp $ */
d24 3
d29 1
d342 1
a342 1
	ih->ih_irq = gpio + INTC_NUM_IRQ;
d443 1
a443 1
		intc_intr_disestablish(sc->sc_ih_h);
d446 1
a446 1
		sc->sc_ih_h = intc_intr_establish(sc->sc_irq, max, omgpio_irq,
d451 1
a451 1
		intc_intr_disestablish(sc->sc_ih_h);
d454 1
a454 1
		sc->sc_ih_h = intc_intr_establish(sc->sc_irq, max, omgpio_irq,
d462 1
a462 1
		intc_intr_disestablish(sc->sc_ih_l);
d465 1
a465 1
		sc->sc_ih_h = intc_intr_establish(sc->sc_irq, min,
@


1.4
log
@Get rid of evcount's support for arranging counters in a tree
hierarchy.  Everything attached to a single root node anyway, so at
best we had a bush.

"i think it is good" deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: omgpio.c,v 1.3 2010/08/07 03:50:01 krw Exp $ */
d105 8
@


1.3
log
@No "\n" needed at the end of panic() strings.

Bogus chunks pointed out by matthew@@ and miod@@. No cookies for
marco@@ and jasper@@.

ok deraadt@@ miod@@ matthew@@ jasper@@ macro@@
@
text
@d1 1
a1 1
/* $OpenBSD: omgpio.c,v 1.2 2010/05/09 15:46:17 jasper Exp $ */
d335 1
a335 1
	evcount_attach(&ih->ih_count, name, (void *)&ih->ih_irq, &evcount_intr);
@


1.2
log
@hander -> handler

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: omgpio.c,v 1.1 2009/05/08 03:13:26 drahn Exp $ */
d309 1
a309 1
		panic("omgpio_intr_establish: bogus irqnumber %d: %s\n",
d315 1
a315 1
		panic("omgpio_intr_establish: gpio pin busy %d old %s new %s\n",
d391 1
a391 1
			panic("omgpio: irq fired no handler, gpio %x %x %x\n",
@


1.1
log
@Initial effort on a port to the omap35xx platform specifically beagleboard,
however other omap system may be supportable. Not functional until armv7
core changes are complete.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d391 1
a391 1
			panic("omgpio: irq fired no hander, gpio %x %x %x\n",
@

