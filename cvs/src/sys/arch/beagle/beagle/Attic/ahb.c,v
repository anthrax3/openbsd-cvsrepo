head	1.2;
access;
symbols
	OPENBSD_5_0:1.1.0.10
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.8
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.6
	OPENBSD_4_8_BASE:1.1
	OPENBSD_4_7:1.1.0.2
	OPENBSD_4_7_BASE:1.1
	OPENBSD_4_6:1.1.0.4
	OPENBSD_4_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.2
date	2011.11.10.19.37.01;	author uwe;	state dead;
branches;
next	1.1;

1.1
date	2009.05.08.03.13.26;	author drahn;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Reduce autoconf(4) overuse on beagle

Renamed `ahb' to `omap' and extended it to configure the on-chip
devices directly, based a board-specific table instead of trying to
maintain addresses, interrupt numbers and such for two OMAP variants
in the same config file.

This may be an intermediate step, but should provide us some relief
already. :)

Suggestions from deraadt and drahn; ok drahn@@
@
text
@/* $OpenBSD: ahb.c,v 1.1 2009/05/08 03:13:26 drahn Exp $ */
/*
 * Copyright (c) 2005,2008 Dale Rahn <drahn@@openbsd.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/reboot.h>
#define _ARM32_BUS_DMA_PRIVATE
#include <machine/bus.h>
#include <arch/beagle/beagle/ahb.h>
#include <arch/arm/armv7/armv7var.h>

struct ahb_softc {
	struct device sc_dv;

};

int	ahbmatch(struct device *, void *, void *);
void	ahbattach(struct device *, struct device *, void *);
int	ahbprint(void *, const char *);
void	ahbscan(struct device *, void *);

struct arm32_bus_dma_tag ahb_bus_dma_tag = {
	0,
	0,
	NULL,
	_bus_dmamap_create,
	_bus_dmamap_destroy,
	_bus_dmamap_load,
	_bus_dmamap_load_mbuf,
	_bus_dmamap_load_uio,
	_bus_dmamap_load_raw,
	_bus_dmamap_unload,
	_bus_dmamap_sync,
	_bus_dmamem_alloc,
	_bus_dmamem_free,
	_bus_dmamem_map,
	_bus_dmamem_unmap,
	_bus_dmamem_mmap,
};


struct cfattach ahb_ca = {
	sizeof(struct ahb_softc), ahbmatch, ahbattach
};

struct cfdriver ahb_cd = {
	NULL, "ahb", DV_DULL, 1
};

int
ahbmatch(struct device *parent, void *cfdata, void *aux)
{
	return (1);
}

void
ahbattach(struct device *parent, struct device *self, void *aux)
{
	/*
	struct ahb_softc *sc = (struct ahb_softc *)self; 
	*/

	printf("\n");

	config_scan(ahbscan, self);
}

void
ahbscan(struct device *parent, void *match)
{
	/*
	struct ahb_softc *sc = (struct ahb_softc *)parent;
	*/
	struct device *dev = match;
	struct cfdata *cf = dev->dv_cfdata;
	struct ahb_attach_args aa;

	if (cf->cf_fstate == FSTATE_STAR) {
		printf("ahb does not deal with dev* entries\n");
		free(dev, M_DEVBUF);
		return;
	}

        if (autoconf_verbose)
		printf(">>> probing for %s%d\n", cf->cf_driver->cd_name,
		    cf->cf_unit);

	aa.aa_addr = cf->cf_loc[0];
	aa.aa_size = cf->cf_loc[1];
	aa.aa_intr = cf->cf_loc[2];
	aa.aa_iot = &armv7_bs_tag;
	aa.aa_dmat = &ahb_bus_dma_tag;
	if ((*cf->cf_attach->ca_match)(parent, dev, &aa) > 0) {
		if (autoconf_verbose)
			printf(">>> probing for %s%d succeeded\n",
			    cf->cf_driver->cd_name, cf->cf_unit);
		config_attach(parent, dev, &aa, ahbprint);
	} else {
		if (autoconf_verbose)
			printf(">>> probing for %s%d failed\n",
			    cf->cf_driver->cd_name, cf->cf_unit);
		free(dev, M_DEVBUF);
	}
}

int
ahbprint(void *aux, const char *str)
{
	struct ahb_attach_args *aa = aux;

	if (aa->aa_addr != -1)
		printf(" addr 0x%x", aa->aa_addr);
	if (aa->aa_size != 0)
		printf(" size 0x%x", aa->aa_size);
	if (aa->aa_intr != -1)
		printf(" intr %d", aa->aa_intr);
	return (QUIET);
}
@


1.1
log
@Initial effort on a port to the omap35xx platform specifically beagleboard,
however other omap system may be supportable. Not functional until armv7
core changes are complete.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
@

