head	1.4;
access;
symbols
	OPENBSD_5_4:1.3.0.8
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.6
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.4
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.2;
locks; strict;
comment	@ * @;


1.4
date	2013.09.04.14.38.34;	author patrick;	state dead;
branches;
next	1.3;

1.3
date	2011.11.08.22.41.41;	author krw;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.24.22.49.07;	author drahn;	state Exp;
branches;
next	1.1;

1.1
date	2011.10.21.22.55.01;	author drahn;	state Exp;
branches;
next	;


desc
@@


1.4
log
@In the future, we shouldn't have one port port ARM SoC, that's just
ridiculous.  This is the first step for a common and generic ARM port
for ARMv7 SoCs.
@
text
@/* $OpenBSD: uboot_tags.c,v 1.3 2011/11/08 22:41:41 krw Exp $ */
/*
 * Copyright (c) 2011 Dale Rahn <drahn@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/param.h>
#include <sys/systm.h>

#include <machine/bootconfig.h>

struct uboot_tag_header {
	uint32_t	size;
	uint32_t	tag;
};
struct uboot_tag_core {
	uint32_t	flags;
	uint32_t	pagesize;
	uint32_t	rootdev;
};
struct uboot_tag_serialnr {
	uint32_t	low;
	uint32_t	high;
};
struct uboot_tag_revision {
	uint32_t	rev;
};
struct uboot_tag_mem32 {
	uint32_t	size;
	uint32_t	start;
};
struct uboot_tag_cmdline {
	char		cmdline[1];
};

#define ATAG_CORE	0x54410001
#define	ATAG_MEM	0x54410002
#define	ATAG_CMDLINE	0x54410009
#define	ATAG_SERIAL	0x54410006
#define	ATAG_REVISION	0x54410007
#define	ATAG_NONE	0x00000000
struct uboot_tag {
	struct uboot_tag_header hdr;
	union {
		struct uboot_tag_core		core;
		struct uboot_tag_mem32		mem;
		struct uboot_tag_revision	rev;
		struct uboot_tag_serialnr	serialnr;
		struct uboot_tag_cmdline	cmdline;
	} u;
};

int parse_uboot_tags(void *handle);
int
parse_uboot_tags(void *handle)
{
	uint32_t *p;
	struct uboot_tag *tag;
	int i;

	p = handle;
	tag = (struct uboot_tag *)p;

	while(tag != NULL && tag->hdr.size < 4096 &&
	    tag->hdr.tag != ATAG_NONE) {
		switch (tag->hdr.tag) {
		case ATAG_CORE:
			printf("atag core flags %x pagesize %x rootdev %x\n",
			    tag->u.core.flags,
			    tag->u.core.pagesize,
			    tag->u.core.rootdev);
			break;
		case ATAG_MEM:
			printf("atag mem start 0x%08x size 0x%x\n",
			    tag->u.mem.start,
			    tag->u.mem.size);

			i = bootconfig.dramblocks -1;
			if (bootconfig.dramblocks != 0 &&
			    (tag->u.mem.start == bootconfig.dram[i].address +
			    (bootconfig.dram[i].pages * PAGE_SIZE))) {
				bootconfig.dram[i].pages =
				    bootconfig.dram[i].pages +
				    tag->u.mem.size / PAGE_SIZE;
			} else { 
				i = bootconfig.dramblocks;
				bootconfig.dram[i].address = tag->u.mem.start;
				bootconfig.dram[i].pages = tag->u.mem.size
				    / PAGE_SIZE;
				bootconfig.dramblocks = i + 1;
			}

			break;
		case ATAG_CMDLINE:
			printf("atag cmdline [%s]\n",
			    tag->u.cmdline.cmdline);
			strncpy(bootconfig.bootstring, tag->u.cmdline.cmdline,
			    sizeof(bootconfig.bootstring));
			break;
		case ATAG_SERIAL:
			printf("atag serial 0x%08x:%08x\n",
			    tag->u.serialnr.high,
			    tag->u.serialnr.low);
			break;
		case ATAG_REVISION:
			printf("atag revision %08x\n",
			    tag->u.rev.rev);
			break;
		default:
			printf("uboot tag unknown 0x%08x size %d\n",
			    tag->hdr.tag,
			    tag->hdr.size);
		}
		p = p + tag->hdr.size;
		tag = (struct uboot_tag *)p;
	}
	
	return 0;
}
@


1.3
log
@Let beagle GENERIC work as 'swap generic'.

ok deraadt@@ drahn@@
@
text
@d1 1
a1 1
/* $OpenBSD: uboot_tags.c,v 1.2 2011/10/24 22:49:07 drahn Exp $ */
@


1.2
log
@Introduce a pluggable interrupt controller infrastructure for beagle,
to allow panda to share the port.
@
text
@d1 1
a1 1
/* $OpenBSD: uboot_tags.c,v 1.1 2011/10/21 22:55:01 drahn Exp $ */
d109 2
@


1.1
log
@Pile of diffs to improve beagle/panda status. fetching u-boot parameters
out of the register input. (with a beagle_start.S fix from uwe@@)
Devices now detect device_id from u-boot and decide to enable/disable
themselves in the device match routine. ok uwe@@
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d91 2
a92 1
			if (bootconfig.dramblocks != 0 && (tag->u.mem.start == bootconfig.dram[i].address +
d94 3
a96 1
				bootconfig.dram[i].pages = bootconfig.dram[i].pages + tag->u.mem.size / PAGE_SIZE;
d100 2
a101 1
				bootconfig.dram[i].pages = tag->u.mem.size / PAGE_SIZE;
@

