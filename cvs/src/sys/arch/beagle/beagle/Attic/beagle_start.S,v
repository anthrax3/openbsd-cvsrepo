head	1.6;
access;
symbols
	OPENBSD_5_4:1.5.0.2
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.3.0.6
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.4
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.2
	OPENBSD_5_0:1.1.0.10
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.8
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.6
	OPENBSD_4_8_BASE:1.1
	OPENBSD_4_7:1.1.0.2
	OPENBSD_4_7_BASE:1.1
	OPENBSD_4_6:1.1.0.4
	OPENBSD_4_6_BASE:1.1;
locks; strict;
comment	@# @;


1.6
date	2013.09.04.14.38.33;	author patrick;	state dead;
branches;
next	1.5;

1.5
date	2013.05.01.13.49.18;	author patrick;	state Exp;
branches;
next	1.4;

1.4
date	2013.04.30.13.23.52;	author patrick;	state Exp;
branches;
next	1.3;

1.3
date	2011.10.21.22.55.01;	author drahn;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.17.03.06.05;	author drahn;	state Exp;
branches;
next	1.1;

1.1
date	2009.05.08.03.13.26;	author drahn;	state Exp;
branches;
next	;


desc
@@


1.6
log
@In the future, we shouldn't have one port port ARM SoC, that's just
ridiculous.  This is the first step for a common and generic ARM port
for ARMv7 SoCs.
@
text
@/*	$OpenBSD: beagle_start.S,v 1.5 2013/05/01 13:49:18 patrick Exp $	*/
/*	$NetBSD: lubbock_start.S,v 1.1 2003/06/18 10:51:15 bsh Exp $ */

/*
 * Copyright (c) 2002, 2003  Genetec Corporation.  All rights reserved.
 * Written by Hiroyuki Bessho for Genetec Corporation.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of Genetec Corporation may not be used to endorse or 
 *    promote products derived from this software without specific prior
 *    written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY GENETEC CORPORATION ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL GENETEC CORPORATION
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <machine/asm.h>
#include <arm/armreg.h>
#include <arm/pte.h>
#include <arm/pmap.h>		/* for PMAP_DOMAIN_KERNEL */

#ifndef SDRAM_START
#define SDRAM_START	0x80000000
#endif

/*
 * CPWAIT -- Canonical method to wait for CP15 update.
 * NOTE: Clobbers the specified temp reg.
 * copied from arm/arm/cpufunc_asm_xscale.S
 * XXX: better be in a common header file.
 */
#define	CPWAIT_BRANCH							 \
	sub	pc, pc, #4

#define	CPWAIT(tmp)							 \
	mrc	p15, 0, tmp, c2, c0, 0	/* arbitrary read of CP15 */	;\
	mov	tmp, tmp		/* wait for it to complete */	;\
	CPWAIT_BRANCH			/* branch to next insn */
	
/*
 * Kernel start routine for OMAP
 * this code is excuted at the very first after the kernel is loaded
 * by U-Boot.
 */
	.text

	.global	_C_LABEL(bootstrap_start)
_C_LABEL(bootstrap_start):
	/* Save U-Boot arguments */
	mov	r6, r0
	mov	r7, r1
	mov	r8, r2

	/* Are we running on ROM ? */
	cmp     pc, #0x06000000
	bhi     bootstrap_start_ram

	/* move me to RAM
	 * XXX: we can use memcpy if it is PIC
	 */
	ldr r1, Lcopy_size
	adr r0, _C_LABEL(bootstrap_start)
	add r1, r1, #3
	mov r1, r1, LSR #2
	mov r2, #SDRAM_START
	add r2, r2, #0x00200000
	mov r4, r2

5:	ldr r3,[r0],#4
	str r3,[r2],#4
	subs r1,r1,#1
	bhi 5b

	cmp	pc, r5
	/* Jump to RAM */
	ldr r0, Lstart_off

	blo 1f
	/* if we were running out of virtual mapped space, disable mmu */
	mov	r2, #0
	mov     r1, #(CPU_CONTROL_32BP_ENABLE | CPU_CONTROL_32BD_ENABLE)
	mcr     15, 0, r1, c1, c0, 0
	mcrne   15, 0, r2, c8, c7, 0    /* nail I+D TLB on ARMv4 and greater */
	
1:
	add pc, r4, r0

Lcopy_size:	.word _edata-_C_LABEL(bootstrap_start)
Lstart_off:	.word bootstrap_start_ram-_C_LABEL(bootstrap_start)

bootstrap_start_ram:	
	/*
	 *  Kernel is loaded in SDRAM (0xa0200000..), and is expected to run
	 *  in VA 0xc0200000..  
	 */

	mrc	p15, 0, r0, c2, c0, 0	/* get ttb prepared by redboot */
	adr	r4, mmu_init_table2
	
/*
#define BUILD_STARTUP_PAGETABLE
*/
#ifdef BUILD_STARTUP_PAGETABLE
	mrc	p15, 0, r2, c1, c0, 0
	mov	r2, #0
	tst	r2, #CPU_CONTROL_MMU_ENABLE /* we already have a page table? */
	bne	3f

	/* build page table from scratch */
	ldr	r0, Lstartup_pagetable
	adr	r4, mmu_init_table
	b	3f

2:
	str	r3, [r0, r2]
	add	r2, r2, #4
	add	r3, r3, #(L1_S_SIZE)
	adds	r1, r1, #-1
	bhi	2b
3:	
	ldmia	r4!, {r1,r2,r3}   /* # of sections, PA|attr, VA */
	cmp	r1, #0
	bne	2b	
#endif

	mcr	p15, 0, r0, c2, c0, 0	/* Set TTB */
	mcr	p15, 0, r0, c8, c7, 0	/* Flush TLB */

	/* Set the Domain Access register.  Very important! */
        mov     r0, #((DOMAIN_CLIENT << (PMAP_DOMAIN_KERNEL*2)) | DOMAIN_CLIENT)
	mcr	p15, 0, r0, c3, c0, 0

	/* Enable MMU */
	mrc	p15, 0, r0, c1, c0, 0
	orr	r0, r0, #CPU_CONTROL_MMU_ENABLE
	mcr	p15, 0, r0, c1, c0, 0
	CPWAIT(r0)

	/* Restore U-Boot arguments */
	mov	r0, r6
	mov	r1, r7
	mov	r2, r8

	/* Jump to kernel code in TRUE VA */
	adr	r6, Lstart
	ldr	pc, [r6]

Lstart:
	.word	start

#define MMU_INIT(va,pa,n_sec,attr) \
	.word	n_sec					    ; \
	.word	4*((va)>>L1_S_SHIFT)			    ; \
	.word	(pa)|(attr)				    ;
	
#ifdef BUILD_STARTUP_PAGETABLE
#ifndef STARTUP_PAGETABLE_ADDR
#define STARTUP_PAGETABLE_ADDR 0x82000000
#endif
Lstartup_pagetable:	.word	STARTUP_PAGETABLE_ADDR
mmu_init_table:	
	/* fill all table VA==PA */
	MMU_INIT(0x00000000, 0x00000000, 1<<(32-L1_S_SHIFT), L1_TYPE_S|L1_S_V7_AP(AP_KRW))
	/* map SDRAM VA==PA, WT cacheable */
	MMU_INIT(SDRAM_START, SDRAM_START, 64, L1_TYPE_S|L1_S_C|L1_S_V7_AP(AP_KRW))
#endif
mmu_init_table2:	
	/* map VA 0xc0000000..0xc3ffffff to PA 0xa0000000..0xa3ffffff */
	MMU_INIT(0xc0000000, SDRAM_START, 64, L1_TYPE_S|L1_S_C|L1_S_V7_AP(AP_KRW))

	.word 0	/* end of table */

	.text

/*-
 * Copyright (c) 2011
 *	Ben Gray <ben.r.gray@@gmail.com>.
 * All rights reserved.
 *
 * Based heavily on the Linux OMAP secure API
 *    Copyright (C) 2010 Texas Instruments, Inc.
 *    Written by Santosh Shilimkar <santosh.shilimkar@@ti.com>
 *
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 *	omap4_smc_call - issues a secure monitor API call
 *	@@r0: contains the monitor API number
 *	@@r1: contains the value to set
 * 
 *	This function will send a secure monitor call to the internal rom code in
 *	the trust mode. The rom code expects that r0 will contain the value and 
 *	r12 will contain the API number, so internally the function swaps the
 *	register settings around.  The trust mode code may also alter all the cpu
 *	registers so everything (including the lr register) is saved on the stack
 *	before the call.
 *
 *	RETURNS:
 *	nothing
 */
ENTRY(omap4_smc_call)
	stmfd   sp!, {r2-r12, lr}
	mov     r12, r0
	mov     r0, r1
#if 0
	dsb
#else
	.word	0xf57ff040
#endif
#if 0
	smc     #0	/* XXX or #1 ??? */
#else
	.word	0xe1600070
#endif
	ldmfd   sp!, {r2-r12, pc}

@


1.5
log
@Disable PandaBoard's L2 Cache early on bootup. We will re-enable it
later once we're ready.

ok bmercer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: beagle_start.S,v 1.4 2013/04/30 13:23:52 patrick Exp $	*/
@


1.4
log
@Use ARMv7 access permission bits.

ok bmercer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: beagle_start.S,v 1.3 2011/10/21 22:55:01 drahn Exp $	*/
d188 67
@


1.3
log
@Pile of diffs to improve beagle/panda status. fetching u-boot parameters
out of the register input. (with a beagle_start.S fix from uwe@@)
Devices now detect device_id from u-boot and decide to enable/disable
themselves in the device match routine. ok uwe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: beagle_start.S,v 1.1 2009/05/08 03:13:26 drahn Exp $	*/
d179 1
a179 1
	MMU_INIT(0x00000000, 0x00000000, 1<<(32-L1_S_SHIFT), L1_TYPE_S|L1_S_AP(AP_KRW))
d181 1
a181 1
	MMU_INIT(SDRAM_START, SDRAM_START, 64, L1_TYPE_S|L1_S_C|L1_S_AP(AP_KRW))
d185 1
a185 1
	MMU_INIT(0xc0000000, SDRAM_START, 64, L1_TYPE_S|L1_S_C|L1_S_AP(AP_KRW))
@


1.2
log
@Change to use r8,r9,r10 instead of r0,r1,r2. This is necessary because
the bootloader passes data in r0,r1,r2 which needs to be preserved until
the kernel is booted further.
@
text
@d65 5
d77 11
a87 11
	ldr r9, Lcopy_size
	adr r8, _C_LABEL(bootstrap_start)
	add r9, r9, #3
	mov r9, r9, LSR #2
	mov r10, #SDRAM_START
	add r10, r10, #0x00200000
	mov r4, r10

5:	ldr r3,[r8],#4
	str r3,[r10],#4
	subs r9,r9,#1
d92 1
a92 1
	ldr r8, Lstart_off
d96 4
a99 4
	mov	r10, #0
	mov     r9, #(CPU_CONTROL_32BP_ENABLE | CPU_CONTROL_32BD_ENABLE)
	mcr     15, 0, r9, c1, c0, 0
	mcrne   15, 0, r10, c8, c7, 0    /* nail I+D TLB on ARMv4 and greater */
d102 1
a102 1
	add pc, r4, r8
d113 1
a113 1
	mrc	p15, 0, r8, c2, c0, 0	/* get ttb prepared by redboot */
d120 3
a122 3
	mrc	p15, 0, r10, c1, c0, 0
	mov	r10, #0
	tst	r10, #CPU_CONTROL_MMU_ENABLE /* we already have a page table? */
d126 1
a126 1
	ldr	r8, Lstartup_pagetable
d131 2
a132 2
	str	r3, [r8, r10]
	add	r10, r10, #4
d134 1
a134 1
	adds	r9, r9, #-1
d137 2
a138 2
	ldmia	r4!, {r9,r10,r3}   /* # of sections, PA|attr, VA */
	cmp	r9, #0
d142 2
a143 2
	mcr	p15, 0, r8, c2, c0, 0	/* Set TTB */
	mcr	p15, 0, r8, c8, c7, 0	/* Flush TLB */
d146 2
a147 2
        mov     r8, #((DOMAIN_CLIENT << (PMAP_DOMAIN_KERNEL*2)) | DOMAIN_CLIENT)
	mcr	p15, 0, r8, c3, c0, 0
d150 9
a158 4
	mrc	p15, 0, r8, c1, c0, 0
	orr	r8, r8, #CPU_CONTROL_MMU_ENABLE
	mcr	p15, 0, r8, c1, c0, 0
	CPWAIT(r8)
d161 2
a162 2
	adr	r8, Lstart
	ldr	pc, [r8]
@


1.1
log
@Initial effort on a port to the omap35xx platform specifically beagleboard,
however other omap system may be supportable. Not functional until armv7
core changes are complete.
@
text
@d1 1
a1 1
/*	$OpenBSD: bootstrap_start.S,v 1.2 2005/01/02 19:43:07 drahn Exp $	*/
d57 1
a57 1
 * Kernel start routine for DBPXA250 (Lubbock)
d59 1
a59 1
 * by RedBoot.
d72 11
a82 11
	ldr r1, Lcopy_size
	adr r0, _C_LABEL(bootstrap_start)
	add r1, r1, #3
	mov r1, r1, LSR #2
	mov r2, #SDRAM_START
	add r2, r2, #0x00200000
	mov r4, r2

5:	ldr r3,[r0],#4
	str r3,[r2],#4
	subs r1,r1,#1
d87 1
a87 1
	ldr r0, Lstart_off
d91 4
a94 4
	mov	r2, #0
	mov     r1, #(CPU_CONTROL_32BP_ENABLE | CPU_CONTROL_32BD_ENABLE)
	mcr     15, 0, r1, c1, c0, 0
	mcrne   15, 0, r2, c8, c7, 0    /* nail I+D TLB on ARMv4 and greater */
d97 1
a97 1
	add pc, r4, r0
d108 1
a108 1
	mrc	p15, 0, r0, c2, c0, 0	/* get ttb prepared by redboot */
d115 3
a117 3
	mrc	p15, 0, r2, c1, c0, 0
	mov	r2, #0
	tst	r2, #CPU_CONTROL_MMU_ENABLE /* we already have a page table? */
d121 1
a121 1
	ldr	r0, Lstartup_pagetable
d126 2
a127 2
	str	r3, [r0, r2]
	add	r2, r2, #4
d129 1
a129 1
	adds	r1, r1, #-1
d132 2
a133 2
	ldmia	r4!, {r1,r2,r3}   /* # of sections, PA|attr, VA */
	cmp	r1, #0
d137 2
a138 2
	mcr	p15, 0, r0, c2, c0, 0	/* Set TTB */
	mcr	p15, 0, r0, c8, c7, 0	/* Flush TLB */
d141 2
a142 2
        mov     r0, #((DOMAIN_CLIENT << (PMAP_DOMAIN_KERNEL*2)) | DOMAIN_CLIENT)
	mcr	p15, 0, r0, c3, c0, 0
d145 4
a148 4
	mrc	p15, 0, r0, c1, c0, 0
	orr	r0, r0, #CPU_CONTROL_MMU_ENABLE
	mcr	p15, 0, r0, c1, c0, 0
	CPWAIT(r0)
d151 2
a152 2
	adr	r0, Lstart
	ldr	pc, [r0]
@

