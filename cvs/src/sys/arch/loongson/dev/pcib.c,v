head	1.4;
access;
symbols
	OPENBSD_6_1:1.4.0.18
	OPENBSD_6_1_BASE:1.4
	OPENBSD_6_0:1.4.0.16
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.4.0.12
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.4.0.14
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.6
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.10
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.8
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.4
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.2
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.3.0.8
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.6
	OPENBSD_5_0:1.3.0.4
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.2.0.2
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.1.1.1.0.2
	OPENBSD_4_7_BASE:1.1.1.1
	xmas_lemote:1.1.1.1
	miod:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2012.08.18.16.00.20;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2010.10.14.21.23.04;	author pirofti;	state Exp;
branches;
next	1.2;

1.2
date	2010.05.08.21.59.56;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2009.12.25.21.04.34;	author miod;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2009.12.25.21.04.34;	author miod;	state Exp;
branches;
next	;


desc
@@


1.4
log
@glxpcib(4) invokes pcibattach assuming pcib doesn't need more than a
`struct device' as its softc. This is not the case on loongson, and the
glxpcib softc gets subtly corrupted, causing a kernel panic when attempting
to select the glxpcib timecounter as the current timecounter.

Skirt this by not using the pcib softc fields if we are invoked from
glxpcib - it is not really worth putting pcib_softc in a header for the sake
of MI glxpcib code.
@
text
@/*	$OpenBSD: pcib.c,v 1.3 2010/10/14 21:23:04 pirofti Exp $	*/

/*-
 * Copyright (c) 1996 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>

#include <machine/autoconf.h>
#include <machine/bus.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>

#include <dev/isa/isavar.h>

#include <dev/pci/glxreg.h>
#include <dev/pci/glxvar.h>

#include "isa.h"

int	pcibmatch(struct device *, void *, void *);
void	pcibattach(struct device *, struct device *, void *);

struct pcib_softc {
	struct device	sc_dev;
	bus_space_tag_t	sc_iot;
	bus_space_tag_t	sc_memt;
	bus_dma_tag_t	sc_dmat;
};

const struct cfattach pcib_ca = {
	sizeof(struct pcib_softc), pcibmatch, pcibattach
};

void	pcib_callback(struct device *);
void	pcib_isa_attach(struct pcib_softc *, bus_space_tag_t, bus_space_tag_t,
	    bus_dma_tag_t);
int	pcib_print(void *, const char *);

struct cfdriver pcib_cd = {
	NULL, "pcib", DV_DULL
};

int
pcibmatch(struct device *parent, void *match, void *aux)
{
	struct pci_attach_args *pa = aux;

	switch (PCI_VENDOR(pa->pa_id)) {
	case PCI_VENDOR_INTEL:
		switch (PCI_PRODUCT(pa->pa_id)) {
		case PCI_PRODUCT_INTEL_SIO:
		case PCI_PRODUCT_INTEL_82371MX:
		case PCI_PRODUCT_INTEL_82371AB_ISA:
		case PCI_PRODUCT_INTEL_82440MX_ISA:
			/* The above bridges mis-identify themselves */
			return (1);
		}
		break;
	case PCI_VENDOR_SIS:
		switch (PCI_PRODUCT(pa->pa_id)) {
		case PCI_PRODUCT_SIS_85C503:
			/* mis-identifies itself as a miscellaneous prehistoric */
			return (1);
		}
		break;
	case PCI_VENDOR_VIATECH:
		switch (PCI_PRODUCT(pa->pa_id)) {
		case PCI_PRODUCT_VIATECH_VT82C686A_SMB:
			/* mis-identifies itself as a ISA bridge */
			return (0);
		}
		break;
	}

	if (PCI_CLASS(pa->pa_class) == PCI_CLASS_BRIDGE &&
	    PCI_SUBCLASS(pa->pa_class) == PCI_SUBCLASS_BRIDGE_ISA)
		return (1);

	return (0);
}

void
pcibattach(struct device *parent, struct device *self, void *aux)
{
	struct pcib_softc *sc = (struct pcib_softc *)self;
	struct pci_attach_args *pa = (struct pci_attach_args *)aux;

	printf("\n");

	/*
	 * If we are actually a glxpcib, we can't use softc fields
	 * beyond the base struct device, for this would corrupt
	 * the glxpcib softc. Decide to attach isa immediately in this
	 * case - glxpcib-based designs are not expected to have ISA
	 * slots and attaching isa early should not cause problems.
	 */
	if (strncmp(self->dv_xname, "glxpcib", 7) == 0) {
		pcib_isa_attach(sc, pa->pa_iot, pa->pa_memt, pa->pa_dmat);
	} else {
		/*
		 * Wait until all PCI devices are attached before attaching isa;
		 * existing pcib code on other platforms mentions that not
		 * doing this ``might mess the interrupt setup on some
		 * systems'', although this is very unlikely to be the case
		 * on loongson.
		 */
		sc->sc_iot = pa->pa_iot;
		sc->sc_memt = pa->pa_memt;
		sc->sc_dmat = pa->pa_dmat;
		config_defer(self, pcib_callback);
	}
}

void
pcib_callback(struct device *self)
{
	struct pcib_softc *sc = (struct pcib_softc *)self;

	pcib_isa_attach(sc, sc->sc_iot, sc->sc_memt, sc->sc_dmat);
}

void
pcib_isa_attach(struct pcib_softc *sc, bus_space_tag_t iot,
    bus_space_tag_t memt, bus_dma_tag_t dmat)
{
	struct isabus_attach_args iba;

	/*
	 * Attach the ISA bus behind this bridge.
	 */
	memset(&iba, 0, sizeof(iba));
	iba.iba_busname = "isa";
	iba.iba_iot = iot;
	iba.iba_memt = memt;
#if NISADMA > 0
	iba.iba_dmat = dmat;
#endif
	iba.iba_ic = sys_platform->isa_chipset;
	if (iba.iba_ic != NULL)
		config_found(&sc->sc_dev, &iba, pcib_print);
}

int
pcib_print(void *aux, const char *pnp)
{
	/* Only ISAs can attach to pcib's; easy. */
	if (pnp)
		printf("isa at %s", pnp);
	return (UNCONF);
}
@


1.3
log
@Move glxpcib(4) to MI land unifying the two MD drivers.

Specific features of the companion chip will be handled in MD land.

Okay deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcib.c,v 1.2 2010/05/08 21:59:56 miod Exp $	*/
a51 2
void	pcib_callback(struct device *);
int	pcib_print(void *, const char *);
d64 5
d121 5
a125 2
	 * Wait until all PCI devices are attached before attaching isa;
	 * otherwise this might mess the interrupt setup on some systems.
d127 15
a141 4
	sc->sc_iot = pa->pa_iot;
	sc->sc_memt = pa->pa_memt;
	sc->sc_dmat = pa->pa_dmat;
	config_defer(self, pcib_callback);
d148 8
a159 2
	 * Note that, since we only have a few legacy I/O devices and
	 * no ISA slots, we can attach immediately.
d163 2
a164 2
	iba.iba_iot = sc->sc_iot;
	iba.iba_memt = sc->sc_memt;
d166 1
a166 1
	iba.iba_dmat = sc->sc_dmat;
d170 1
a170 1
		config_found(self, &iba, pcib_print);
@


1.2
log
@Huge work-in-progress commit to support Loongson 2E-based evaluation boards
with a VIA 686 southbridge.

Features:
- 686 setup code (no thanks to PMON for not initializing the beast).
- work in progress ISA interrupt handling code.
- support for vga(4) compatible devices as console, in PC-compatible text mode.
- move legacy (ISA) support code out of bonito(4) to make things clearer.
- support more than 256MB on 2E-based systems.

Tested on a generic 2E-based evaluation board by someone who wishes to remain
anonymous; you know who you are, thank you very much for testing.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcib.c,v 1.1.1.1 2009/12/25 21:04:34 miod Exp $	*/
d45 2
a46 2
#include <loongson/dev/glxreg.h>
#include <loongson/dev/glxvar.h>
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d3 3
a5 2
/*
 * Copyright (c) 2009 Miodrag Vallat.
d7 2
a8 3
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
d10 20
a29 7
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
d36 1
d41 1
d50 1
d52 1
d55 54
d112 2
a113 2
	struct pci_attach_args *pa = aux;
	struct isabus_attach_args iba;
d118 16
d140 2
a141 2
	iba.iba_iot = pa->pa_iot;
	iba.iba_memt = pa->pa_memt;
d143 1
a143 1
	iba.iba_dmat = pa->pa_dmat;
d145 3
a147 1
	config_found(self, &iba, pcib_print);
@


1.1.1.1
log
@By popular demand and peer pressure, check-in work in progress work to support
the Yeelong Lemote mips-based netbook. Kernel bits only for now, needs
polishing; most of this work done during h2k9 last month, although the
porting effort started earlier this year.
@
text
@@
