head	1.32;
access;
symbols
	OPENBSD_6_1_BASE:1.32
	OPENBSD_6_0:1.29.0.4
	OPENBSD_6_0_BASE:1.29
	OPENBSD_5_9:1.29.0.2
	OPENBSD_5_9_BASE:1.29
	OPENBSD_5_8:1.28.0.6
	OPENBSD_5_8_BASE:1.28
	OPENBSD_5_7:1.28.0.2
	OPENBSD_5_7_BASE:1.28
	OPENBSD_5_6:1.23.0.4
	OPENBSD_5_6_BASE:1.23
	OPENBSD_5_5:1.17.0.4
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.16.0.2
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.13.0.2
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.11.0.4
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.2
	OPENBSD_5_0:1.9.0.2
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.8.0.2
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.3.0.2
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2;
locks; strict;
comment	@ * @;


1.32
date	2017.03.27.18.24.08;	author deraadt;	state Exp;
branches;
next	1.31;
commitid	KkdbYCyrebNljBOz;

1.31
date	2016.10.08.05.49.08;	author guenther;	state Exp;
branches;
next	1.30;
commitid	z63v1DilayzHcfkw;

1.30
date	2016.09.03.14.46.56;	author naddy;	state Exp;
branches;
next	1.29;
commitid	RpNaiU9Lz1B3rhqT;

1.29
date	2015.09.28.18.36.36;	author deraadt;	state Exp;
branches;
next	1.28;
commitid	sjQx9dlBaND52EhB;

1.28
date	2015.02.07.01.19.40;	author deraadt;	state Exp;
branches;
next	1.27;
commitid	J7ySI1ZREP62T8hM;

1.27
date	2014.12.19.14.15.50;	author deraadt;	state Exp;
branches;
next	1.26;
commitid	stMP6mZe5CXxXpb4;

1.26
date	2014.12.18.20.01.33;	author deraadt;	state Exp;
branches;
next	1.25;
commitid	u02ybufTMYPtvBX4;

1.25
date	2014.10.31.07.59.27;	author jsg;	state Exp;
branches;
next	1.24;
commitid	5FD1qcWdF60TcmBb;

1.24
date	2014.09.20.09.28.24;	author kettenis;	state Exp;
branches;
next	1.23;
commitid	IFRB8AkvBMXMTAKW;

1.23
date	2014.07.19.18.01.23;	author pirofti;	state Exp;
branches;
next	1.22;
commitid	U9MoL9J3tpANAtRh;

1.22
date	2014.07.19.12.54.09;	author pirofti;	state Exp;
branches;
next	1.21;
commitid	JVctDEuWalguWlKu;

1.21
date	2014.07.16.17.11.37;	author miod;	state Exp;
branches;
next	1.20;
commitid	KMzPJ4135e1km6pK;

1.20
date	2014.06.16.20.32.29;	author pirofti;	state Exp;
branches;
next	1.19;
commitid	JnzfNqQWE1vqmcbK;

1.19
date	2014.03.31.12.11.42;	author mpi;	state Exp;
branches;
next	1.18;

1.18
date	2014.03.13.03.52.55;	author dlg;	state Exp;
branches;
next	1.17;

1.17
date	2013.12.06.21.03.05;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2013.06.05.00.44.24;	author pirofti;	state Exp;
branches;
next	1.15;

1.15
date	2013.06.04.22.39.27;	author pirofti;	state Exp;
branches;
next	1.14;

1.14
date	2013.06.02.21.46.04;	author pirofti;	state Exp;
branches;
next	1.13;

1.13
date	2012.10.17.22.49.27;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2012.10.08.21.47.48;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2011.09.20.14.06.26;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2011.09.18.12.01.06;	author phessler;	state Exp;
branches;
next	1.9;

1.9
date	2011.07.02.22.20.07;	author nicm;	state Exp;
branches;
next	1.8;

1.8
date	2010.09.09.19.06.15;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2010.09.08.21.18.15;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2010.09.01.13.10.42;	author pirofti;	state Exp;
branches;
next	1.5;

1.5
date	2010.08.31.17.35.12;	author pirofti;	state Exp;
branches;
next	1.4;

1.4
date	2010.08.31.10.24.46;	author pirofti;	state Exp;
branches;
next	1.3;

1.3
date	2010.05.08.21.59.56;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2010.02.28.09.37.28;	author otto;	state Exp;
branches;
next	1.1;

1.1
date	2010.02.28.08.30.27;	author otto;	state Exp;
branches;
next	;


desc
@@


1.32
log
@hibernate_free() should not be called from MD code, acpi_sleep_state()
unwinds that.  Upon hibernate fail, this was a collection of double-frees..
ok claudio mlarkin
@
text
@/*	$OpenBSD: apm.c,v 1.31 2016/10/08 05:49:08 guenther Exp $	*/

/*-
 * Copyright (c) 2001 Alexander Guy.  All rights reserved.
 * Copyright (c) 1998-2001 Michael Shalayeff. All rights reserved.
 * Copyright (c) 1995 John T. Kohl.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the names of the authors nor the names of contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHORS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#include "apm.h"
#include "wsdisplay.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/proc.h>
#include <sys/device.h>
#include <sys/fcntl.h>
#include <sys/ioctl.h>
#include <sys/buf.h>
#include <sys/event.h>
#include <sys/reboot.h>
#include <sys/hibernate.h>
#include <dev/rndvar.h>

#include <machine/autoconf.h>
#include <machine/conf.h>
#include <machine/cpu.h>
#include <machine/apmvar.h>

#include <dev/pci/pcivar.h>    /* pci_dopm */

#include <dev/wscons/wsdisplayvar.h>

#include <loongson/dev/kb3310var.h>

#if defined(APMDEBUG)
#define DPRINTF(x)	printf x
#else
#define	DPRINTF(x)	/**/
#endif

struct apm_softc {
	struct device sc_dev;
	struct klist sc_note;
	int    sc_flags;
};

int apmmatch(struct device *, void *, void *);
void apmattach(struct device *, struct device *, void *);

struct cfattach apm_ca = {
	sizeof(struct apm_softc), apmmatch, apmattach
};

struct cfdriver apm_cd = {
	NULL, "apm", DV_DULL
};

#define	APMUNIT(dev)	(minor(dev)&0xf0)
#define	APMDEV(dev)	(minor(dev)&0x0f)
#define APMDEV_NORMAL	0
#define APMDEV_CTL	8

void filt_apmrdetach(struct knote *kn);
int filt_apmread(struct knote *kn, long hint);
int apmkqfilter(dev_t dev, struct knote *kn);
int apm_getdefaultinfo(struct apm_power_info *);

int apm_suspend(int state);

struct filterops apmread_filtops =
	{ 1, NULL, filt_apmrdetach, filt_apmread};

int (*get_apminfo)(struct apm_power_info *) = apm_getdefaultinfo;

/*
 * Flags to control kernel display
 *	SCFLAG_NOPRINT:		do not output APM power messages due to
 *				a power change event.
 *
 *	SCFLAG_PCTPRINT:	do not output APM power messages due to
 *				to a power change event unless the battery
 *				percentage changes.
 */

#define SCFLAG_NOPRINT	0x0008000
#define SCFLAG_PCTPRINT	0x0004000
#define SCFLAG_PRINT	(SCFLAG_NOPRINT|SCFLAG_PCTPRINT)

#define	SCFLAG_OREAD 	(1 << 0)
#define	SCFLAG_OWRITE	(1 << 1)
#define	SCFLAG_OPEN	(SCFLAG_OREAD|SCFLAG_OWRITE)


int
apmmatch(struct device *parent, void *match, void *aux)
{
	struct mainbus_attach_args *maa = aux;

	/*
	 * It only makes sense to attach on a 2F system, since 2E do not
	 * feature speed throttling, and we do not support 2E-based
	 * notebooks yet (assuming there are any).
	 */
	if (strcmp(maa->maa_name, apm_cd.cd_name) == 0 && loongson_ver == 0x2f)
		return (1);
	return (0);
}

void
apmattach(struct device *parent, struct device *self, void *aux)
{
	/* Enable PCI Power Management. */
	pci_dopm = 1;

	printf("\n");
}

int
apmopen(dev_t dev, int flag, int mode, struct proc *p)
{
	struct apm_softc *sc;
	int error = 0;

	/* apm0 only */
	if (!apm_cd.cd_ndevs || APMUNIT(dev) != 0 ||
	    !(sc = apm_cd.cd_devs[APMUNIT(dev)]))
		return ENXIO;

	DPRINTF(("apmopen: dev %d pid %d flag %x mode %x\n",
	    APMDEV(dev), p->p_p->ps_pid, flag, mode));

	switch (APMDEV(dev)) {
	case APMDEV_CTL:
		if (!(flag & FWRITE)) {
			error = EINVAL;
			break;
		}
		if (sc->sc_flags & SCFLAG_OWRITE) {
			error = EBUSY;
			break;
		}
		sc->sc_flags |= SCFLAG_OWRITE;
		break;
	case APMDEV_NORMAL:
		if (!(flag & FREAD) || (flag & FWRITE)) {
			error = EINVAL;
			break;
		}
		sc->sc_flags |= SCFLAG_OREAD;
		break;
	default:
		error = ENXIO;
		break;
	}
	return error;
}

int
apmclose(dev_t dev, int flag, int mode, struct proc *p)
{
	struct apm_softc *sc;

	/* apm0 only */
	if (!apm_cd.cd_ndevs || APMUNIT(dev) != 0 ||
	    !(sc = apm_cd.cd_devs[APMUNIT(dev)]))
		return ENXIO;

	DPRINTF(("apmclose: pid %d flag %x mode %x\n",
	    p->p_p->ps_pid, flag, mode));

	switch (APMDEV(dev)) {
	case APMDEV_CTL:
		sc->sc_flags &= ~SCFLAG_OWRITE;
		break;
	case APMDEV_NORMAL:
		sc->sc_flags &= ~SCFLAG_OREAD;
		break;
	}
	return 0;
}

int
apmioctl(dev_t dev, u_long cmd, caddr_t data, int flag, struct proc *p)
{
	struct apm_softc *sc;
	struct apm_power_info *power;
	int error = 0;

	/* apm0 only */
	if (!apm_cd.cd_ndevs || APMUNIT(dev) != 0 ||
	    !(sc = apm_cd.cd_devs[APMUNIT(dev)]))
		return ENXIO;

	switch (cmd) {
		/* some ioctl names from linux */
	case APM_IOC_STANDBY:
	case APM_IOC_STANDBY_REQ:
	case APM_IOC_SUSPEND:
	case APM_IOC_SUSPEND_REQ:
		if ((flag & FWRITE) == 0)
			error = EBADF;
		else if (sys_platform->suspend == NULL ||
		    sys_platform->resume == NULL)
			error = EOPNOTSUPP;
		else
			error = apm_suspend(APM_IOC_SUSPEND);
		break;
#ifdef HIBERNATE
	case APM_IOC_HIBERNATE:
		if ((flag & FWRITE) == 0)
			error = EBADF;
		else if (sys_platform->suspend == NULL ||
		    sys_platform->resume == NULL)
			error = EOPNOTSUPP;
		else
			error = apm_suspend(APM_IOC_HIBERNATE);
		break;
#endif
	case APM_IOC_PRN_CTL:
		if ((flag & FWRITE) == 0)
			error = EBADF;
		else {
			int flag = *(int *)data;
			DPRINTF(( "APM_IOC_PRN_CTL: %d\n", flag ));
			switch (flag) {
			case APM_PRINT_ON:	/* enable printing */
				sc->sc_flags &= ~SCFLAG_PRINT;
				break;
			case APM_PRINT_OFF: /* disable printing */
				sc->sc_flags &= ~SCFLAG_PRINT;
				sc->sc_flags |= SCFLAG_NOPRINT;
				break;
			case APM_PRINT_PCT: /* disable some printing */
				sc->sc_flags &= ~SCFLAG_PRINT;
				sc->sc_flags |= SCFLAG_PCTPRINT;
				break;
			default:
				error = EINVAL;
				break;
			}
		}
		break;
	case APM_IOC_DEV_CTL:
		if ((flag & FWRITE) == 0)
			error = EBADF;
		else
			error = EOPNOTSUPP; /* XXX */
		break;
	case APM_IOC_GETPOWER:
	        power = (struct apm_power_info *)data;
		error = (*get_apminfo)(power);
		break;
	default:
		error = ENOTTY;
	}

	return error;
}

void
filt_apmrdetach(struct knote *kn)
{
	struct apm_softc *sc = (struct apm_softc *)kn->kn_hook;

	SLIST_REMOVE(&sc->sc_note, kn, knote, kn_selnext);
}

int
filt_apmread(struct knote *kn, long hint)
{
	/* XXX weird kqueue_scan() semantics */
	if (hint && !kn->kn_data)
		kn->kn_data = (int)hint;

	return (1);
}

int
apmkqfilter(dev_t dev, struct knote *kn)
{
	struct apm_softc *sc;

	/* apm0 only */
	if (!apm_cd.cd_ndevs || APMUNIT(dev) != 0 ||
	    !(sc = apm_cd.cd_devs[APMUNIT(dev)]))
		return ENXIO;

	switch (kn->kn_filter) {
	case EVFILT_READ:
		kn->kn_fop = &apmread_filtops;
		break;
	default:
		return (EINVAL);
	}

	kn->kn_hook = (caddr_t)sc;
	SLIST_INSERT_HEAD(&sc->sc_note, kn, kn_selnext);

	return (0);
}

int
apm_getdefaultinfo(struct apm_power_info *info)
{
	info->battery_state = APM_BATT_UNKNOWN;
	info->ac_state = APM_AC_UNKNOWN;
	info->battery_life = 0;
	info->minutes_left = -1;
	return (0);
}

void
apm_setinfohook(int (*hook)(struct apm_power_info *))
{
	get_apminfo = hook;
}

int
apm_record_event(u_int event, const char *src, const char *msg)
{
	static int apm_evindex;
	struct apm_softc *sc;

	/* apm0 only */
	if (apm_cd.cd_ndevs == 0 || (sc = apm_cd.cd_devs[0]) == NULL)
		return ENXIO;

	if ((sc->sc_flags & SCFLAG_NOPRINT) == 0)
		printf("%s: %s %s\n", sc->sc_dev.dv_xname, src, msg);

	/* skip if no user waiting */
	if ((sc->sc_flags & SCFLAG_OPEN) == 0)
		return (1);

	apm_evindex++;
	KNOTE(&sc->sc_note, APM_EVENT_COMPOSE(event, apm_evindex));

	return (0);
}

int
apm_suspend(int state)
{
	int rv;
	int s;

#if NWSDISPLAY > 0
	wsdisplay_suspend();
#endif

	stop_periodic_resettodr();
	resettodr();

	config_suspend_all(DVACT_QUIESCE);
	bufq_quiesce();

	s = splhigh();
	(void)disableintr();
	cold = 2;

	rv = config_suspend_all(DVACT_SUSPEND);

	suspend_randomness();

#ifdef HIBERNATE
	if (state == APM_IOC_HIBERNATE) {
		uvm_pmr_zero_everything();
		if (hibernate_suspend()) {
			printf("apm: hibernate_suspend failed");
			uvm_pmr_dirty_everything();
			return (ECANCELED);
		}
	}
#endif

	/* XXX
	 * Flag to disk drivers that they should "power down" the disk
	 * when we get to DVACT_POWERDOWN.
	 */
	boothowto |= RB_POWERDOWN;
	config_suspend_all(DVACT_POWERDOWN);
	boothowto &= ~RB_POWERDOWN;

	if (rv == 0) {
		rv = sys_platform->suspend();
		if (rv == 0)
			rv = sys_platform->resume();
	}
	inittodr(time_second);	/* Move the clock forward */
	config_suspend_all(DVACT_RESUME);

	cold = 0;
	(void)enableintr();
	splx(s);

	resume_randomness(NULL, 0);	/* force RNG upper level reseed */
	bufq_restart();

	config_suspend_all(DVACT_WAKEUP);

	start_periodic_resettodr();

#if NWSDISPLAY > 0
	wsdisplay_resume();
#endif

	return rv;
}
@


1.31
log
@Various printf claim to report the PID, so actually report that and not the TID

Build testing assistance from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.30 2016/09/03 14:46:56 naddy Exp $	*/
a395 1
			hibernate_free();
@


1.30
log
@Write the system time back to the RTC every 30 minutes.
This fixes the problem that long-running machines which were not
shut down properly would reboot with a badly offset system time.

hints and ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.29 2015/09/28 18:36:36 deraadt Exp $	*/
d156 1
a156 1
	    APMDEV(dev), p->p_pid, flag, mode));
d194 2
a195 1
	DPRINTF(("apmclose: pid %d flag %x mode %x\n", p->p_pid, flag, mode));
@


1.29
log
@In low-level suspend routines, set cold=2.  In tsleep(), use this to
spit out a ddb trace to console.  This should allow us to find suspend
or resume routines which break the rules.  It depends on the console
output function being non-sleeping.... but that's another codepath which
should try to be safe when cold is set.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.28 2015/02/07 01:19:40 deraadt Exp $	*/
d376 1
d426 2
@


1.28
log
@New framework that allows hibernate to pass in entropy from it's fresh
boot.
ok mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.27 2014/12/19 14:15:50 deraadt Exp $	*/
d383 1
a383 1
	cold = 1;
@


1.27
log
@oops, forgot rndvar.h
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.26 2014/12/18 20:01:33 deraadt Exp $	*/
d421 1
a421 1
	resume_randomness();		/* force RNG upper level reseed */
@


1.26
log
@use suspend_randomness() and resume_randomness()
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.25 2014/10/31 07:59:27 jsg Exp $	*/
d48 1
@


1.25
log
@#if NSWDISPLAY > 0 -> #if NWSDISPLAY > 0
now wsdisplay_suspend() will run on suspend
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.24 2014/09/20 09:28:24 kettenis Exp $	*/
d386 2
d420 1
@


1.24
log
@Use config_suspend_all(9).

ok mpi@@, uebayasi@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.23 2014/07/19 18:01:23 pirofti Exp $	*/
d371 1
a371 1
#if NSWDISPLAY > 0
@


1.23
log
@Bring back pci_dopm, but disable it before powerdown.

This fixes both the Lemote reboot issue and the USB issue on the
Gdium's that miod@@ spotted.

Suggested by kettenis@@, thanks!

Okay miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.22 2014/07/19 12:54:09 pirofti Exp $	*/
a367 1
	struct device *mainbus = device_mainbus();
d377 1
a377 1
	config_suspend(mainbus, DVACT_QUIESCE);
d384 1
a384 1
	rv = config_suspend(mainbus, DVACT_SUSPEND);
d403 1
a403 1
	(void) config_suspend(mainbus, DVACT_POWERDOWN);
d412 1
a412 1
	config_suspend(mainbus, DVACT_RESUME);
d420 1
a420 1
	config_suspend(mainbus, DVACT_WAKEUP);
@


1.22
log
@Backout pci_dopm usage as it also breaks reboot on Lemote's.

Noticed by matthieu@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.21 2014/07/16 17:11:37 miod Exp $	*/
d54 2
d137 3
@


1.21
log
@Do not set pci_dopm to 1 on the Gdium; if we do, rebooting puts the USB HCI in
a state PMON doesn't expect, and can't recover from.
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.20 2014/06/16 20:32:29 pirofti Exp $	*/
a53 2
#include <dev/pci/pcivar.h>	/* pci_dopm */

a134 8
	/*
	 * Enable PCI Power Management, except on the Gdium, where this
	 * prevents PMON from initializing the USB controller correctly
	 * after a reboot.
	 */
	if (sys_platform->system_type != LOONGSON_GDIUM)
		pci_dopm = 1;

@


1.20
log
@Enable PCI power management on Lemote.

Remaining battery test results on Lemote after 30m in suspend:

pci_dopm = 0: 82%, 68min
pci_dopm = 1: 86%, 81min


Suggested by deraadt@@
Okay miod@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.19 2014/03/31 12:11:42 mpi Exp $	*/
d137 7
a143 2
	/* Enable PCI Power Management. */
	pci_dopm = 1;
@


1.19
log
@Change the order of operations during a suspend/resume cycle and
call bufq_quiesce() after executing the DVACT_QUIESCE handlers.

This should be safe since no disk nor controller drivers have such
handler but it will allow us to detach sd(4) devices attached to a
USB bus.

Another benefit pointed out by kettenis@@ is that drivers that need
to read a firmware from the disk should be able to do it at resume
time in a DVACT_WAKEUP handler.

ok kettenis@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.18 2014/03/13 03:52:55 dlg Exp $	*/
d54 2
d137 3
@


1.18
log
@get rid of the assumption that the head of the alldevs list is the
"mainbus" device. this breaks when mpath is enabled because it
attaches before mainbus and therefore takes the head position.

have autoconf provide device_mainbus() which looks up mainbus_cd,
and use that instead.

discussed with deraadt who just wants mpath stuff to move forward
despite there being many ways to shine this particular turd.
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.17 2013/12/06 21:03:05 deraadt Exp $	*/
d373 1
a374 1
	config_suspend(mainbus, DVACT_QUIESCE);
@


1.17
log
@Add a DVACT_WAKEUP op to the *_activate() API.  This is called after the
kernel resumes normal (non-cold, able to run processes, etc) operation.
Previously we were relying on specific DVACT_RESUME op's in drivers
creating callback/threads themselves, but that has become too common,
indicating the need for a built-in mechanism.
ok dlg kettenis, tested by a sufficient amount of people
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.16 2013/06/05 00:44:24 pirofti Exp $	*/
d363 1
d374 1
a374 1
	config_suspend(TAILQ_FIRST(&alldevs), DVACT_QUIESCE);
d380 1
a380 1
	rv = config_suspend(TAILQ_FIRST(&alldevs), DVACT_SUSPEND);
d399 1
a399 1
	(void) config_suspend(TAILQ_FIRST(&alldevs), DVACT_POWERDOWN);
d408 1
a408 1
	config_suspend(TAILQ_FIRST(&alldevs), DVACT_RESUME);
d416 1
a416 1
	config_suspend(TAILQ_FIRST(&alldevs), DVACT_WAKEUP);
@


1.16
log
@Keep things sane in the apm ioctl handler.

STANDBY and SUSPEND result in the machine being suspended.
HIBERNATE results in the machine being hibernated.

Also make sure all the hibernate bits are isolated by ifdefs.
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.15 2013/06/04 22:39:27 pirofti Exp $	*/
d414 3
@


1.15
log
@Make apm aware of the APM_IOC_HIBERNATE command.

While at it use STANDBY for RAM and SUSPEND for disk.

Okay miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.14 2013/06/02 21:46:04 pirofti Exp $	*/
d217 2
d225 1
a225 1
			error = apm_suspend(APM_STANDBY_REQ);
d227 1
a227 2
	case APM_IOC_SUSPEND:
	case APM_IOC_SUSPEND_REQ:
d235 1
a235 1
			error = apm_suspend(APM_SUSPEND_REQ);
d237 1
d382 1
a382 1
	if (state == APM_SUSPEND_REQ) {
@


1.14
log
@Start working on hibernate support for Loongson

This is work in progress. Nothing to test or play with for now.
Commiting it now so that I can work on it in-tree.

Okay miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.13 2012/10/17 22:49:27 deraadt Exp $	*/
d227 1
d380 1
a380 1
	if (state == APM_STANDBY_REQ) {
@


1.13
log
@Document the 'boothowto hack' used to flag to (a few) DVACT_POWERDOWN
handlers how hard they should hit the hardware.
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.13 2012/10/17 22:43:50 deraadt Exp $	*/
d47 1
d91 1
a91 1
int apm_suspend(void);
d219 3
d223 1
a223 1
			error = EOPNOTSUPP; /* XXX */
d233 1
a233 1
			error = apm_suspend();
d358 1
a358 1
apm_suspend()
d377 12
@


1.12
log
@Revamp the sequences for suspend/hibernate -> resume so that the code
paths are reflexive.  It is now possible to fail part-way through a
suspend sequence, and recover along the resume code path.
Split DVACT_SUSPEND by adding a new DVACT_POWERDOWN method is used
after hibernate (and suspend too) to finish the job.  Some drivers
must be converted at the same time to use this instead of shutdown hooks
(the others will follow at a later time)
ok kettenis mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.11 2011/09/20 14:06:26 deraadt Exp $	*/
d374 4
@


1.11
log
@Very early in suspend while the clock is still ticking realtime,
save the clock back to the rtc.  The zaurus already did this.
ok phessler miod kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.10 2011/09/18 12:01:06 phessler Exp $	*/
d46 1
d373 5
@


1.10
log
@Update the system clock when we resume.

OK miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.9 2011/07/02 22:20:07 nicm Exp $	*/
d361 3
@


1.9
log
@kqueue attach functions should return an errno or 0, not a plain 1. Fix
the obvious cases to return EINVAL and ENXIO.

ok tedu deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.8 2010/09/09 19:06:15 miod Exp $	*/
d374 1
@


1.8
log
@Sync suspend logic with current practice, and try to handle failure
consistently; discussed with pirofti and deraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.7 2010/09/08 21:18:15 deraadt Exp $	*/
d304 1
a304 1
		return (1);
@


1.7
log
@No need for vfs_syncwait() in a bufq_quiesce() world
ok thib kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.6 2010/09/01 13:10:42 pirofti Exp $	*/
a88 1
int apm_saved_spl;
a89 1
int apm_resume(void);
d214 1
d221 1
d227 2
a228 4
		else {
			if (!(error = apm_suspend()))
				error = apm_resume();
		}
a263 17
	case APM_IOC_STANDBY_REQ:
		if ((flag & FWRITE) == 0)
			error = EBADF;
		else
			error = EOPNOTSUPP; /* XXX */
		break;
	case APM_IOC_SUSPEND_REQ:
		if ((flag & FWRITE) == 0)
			error = EBADF;
		else if (sys_platform->suspend == NULL ||
		    sys_platform->resume == NULL)
			error = EOPNOTSUPP;
		else {
			if (!(error = apm_suspend()))
				error = apm_resume();
		}
		break;
d344 1
a344 1
		return (1);   
d355 3
d362 1
d364 10
a373 11
	apm_saved_spl = splhigh();
	config_suspend(TAILQ_FIRST(&alldevs), DVACT_SUSPEND);

	return sys_platform->suspend();
}

int
apm_resume()
{
	int rv;

d376 3
a378 2
	rv = sys_platform->resume();
	splx(apm_saved_spl);
d384 1
a384 1
	
@


1.6
log
@Clean-up the spl dance around suspend/resume. Okay miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.5 2010/08/31 17:35:12 pirofti Exp $	*/
a45 1
#include <sys/mount.h>
a380 3

	if (cold)
		vfs_syncwait(0);
@


1.5
log
@Do wsdisplay suspend/resume and also the bufq dance.

Reminded by oga@@, okay deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.4 2010/08/31 10:24:46 pirofti Exp $	*/
d90 1
a374 2
	int s;

d380 1
a380 1
	s = splhigh();
a381 1
	splx(s);
d392 1
a392 1
	int s, rv;
a393 1
	s = splhigh();
a394 1
	splx(s);
d397 1
@


1.4
log
@WIP suspend/resume support for loongson lemote. Okay miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.3 2010/05/08 21:59:56 miod Exp $	*/
d35 1
d44 1
d53 2
d376 5
d394 1
a394 1
	int s;
d400 8
a407 1
	return sys_platform->resume();
@


1.3
log
@Huge work-in-progress commit to support Loongson 2E-based evaluation boards
with a VIA 686 southbridge.

Features:
- 686 setup code (no thanks to PMON for not initializing the beast).
- work in progress ISA interrupt handling code.
- support for vga(4) compatible devices as console, in PC-compatible text mode.
- move legacy (ISA) support code out of bonito(4) to make things clearer.
- support more than 256MB on 2E-based systems.

Tested on a generic 2E-based evaluation board by someone who wishes to remain
anonymous; you know who you are, thank you very much for testing.
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.2 2010/02/28 09:37:28 otto Exp $	*/
d44 1
d51 1
a51 1

d86 3
d220 7
a226 2
		else
			error = EOPNOTSUPP; /* XXX */
d271 7
a277 2
		else
			error = EOPNOTSUPP; /* XXX */
d365 27
@


1.2
log
@don't guess info in the absense of a specific driver, just report
"we dont' know"
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.1 2010/02/28 08:30:27 otto Exp $	*/
d114 6
a119 1
	if (strcmp(maa->maa_name, apm_cd.cd_name) == 0)
@


1.1
log
@Basic apm(4), providing battery/power status and events. apm(4) is the
generic part, ykbec(4) provides the device specific parts. Other
battery/power status drivers can easily hook to adb(4). With help
from miod@@; ok matthieu@@ miod@@ jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.14 2009/02/26 17:19:47 oga Exp $	*/
d312 2
a313 2
	info->battery_state = APM_BATTERY_ABSENT;
	info->ac_state = APM_AC_ON;
d315 1
a315 1
	info->minutes_left = 0;
@

