head	1.17;
access;
symbols
	OPENBSD_6_0:1.16.0.12
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.16.0.8
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.16.0.10
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.16.0.2
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.16.0.6
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.16.0.4
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.14.0.4
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.14.0.2
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.13.0.6
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.4
	OPENBSD_5_0:1.13.0.2
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.11.0.2
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.7.0.4
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.2
	OPENBSD_4_7_BASE:1.7
	xmas_lemote:1.1.1.1
	miod:1.1.1;
locks; strict;
comment	@ * @;


1.17
date	2017.01.10.08.26.41;	author fcambus;	state Exp;
branches;
next	1.16;
commitid	dgDjztjJZwsXM5dJ;

1.16
date	2013.10.21.10.36.14;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2013.10.20.20.07.24;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2012.10.03.21.44.51;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2011.07.21.20.36.12;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2011.05.25.21.15.46;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2010.12.26.15.40.59;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2010.08.31.10.24.46;	author pirofti;	state Exp;
branches;
next	1.9;

1.9
date	2010.08.27.12.48.54;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2010.08.26.18.57.14;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2010.02.28.21.35.41;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2010.02.26.14.53.11;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2010.02.18.22.45.28;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2010.02.05.20.56.49;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2010.02.05.20.53.24;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2010.01.31.15.30.29;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2009.12.25.21.19.32;	author miod;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2009.12.25.21.19.32;	author miod;	state Exp;
branches;
next	;


desc
@@


1.17
log
@Display resolution and color depth when attaching.

OK visa@@, kettenis@@, deraadt@@
@
text
@/*	$OpenBSD: smfb.c,v 1.16 2013/10/21 10:36:14 miod Exp $	*/

/*
 * Copyright (c) 2009, 2010 Miodrag Vallat.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * SiliconMotion SM502 and SM712 frame buffer driver.
 *
 * Assumes its video output is an LCD panel, in 5:6:5 mode, and fixed
 * 1024x600 or 800x480 resolution, depending on the system model.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>

#include <machine/autoconf.h>
#include <machine/bus.h>
#include <machine/cpu.h>

#include <uvm/uvm_extern.h>

#include <dev/ic/vgareg.h>
#include <dev/isa/isareg.h>
#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>

#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsdisplayvar.h>
#include <dev/rasops/rasops.h>

#include <loongson/dev/voyagerreg.h>
#include <loongson/dev/voyagervar.h>
#include <loongson/dev/smfbreg.h>

struct smfb_softc;

/* minimal frame buffer information, suitable for early console */
struct smfb {
	struct smfb_softc	*sc;
	struct rasops_info	ri;
	int			is5xx;

	/* DPR registers */
	bus_space_tag_t		dprt;
	bus_space_handle_t	dprh;
	/* MMIO space (SM7xx) or control registers (SM5xx) */
	bus_space_tag_t		mmiot;
	bus_space_handle_t	mmioh;
	/* DCR registers (SM5xx) */
	bus_space_tag_t		dcrt;
	bus_space_handle_t	dcrh;

	struct wsscreen_descr	wsd;
};

#define	DCR_READ(fb, reg) \
	bus_space_read_4((fb)->dcrt, (fb)->dcrh, (reg))
#define	DCR_WRITE(fb, reg, val) \
	bus_space_write_4((fb)->dcrt, (fb)->dcrh, (reg), (val))
#define	DPR_READ(fb, reg) \
	bus_space_read_4((fb)->dprt, (fb)->dprh, (reg))
#define	DPR_WRITE(fb, reg, val) \
	bus_space_write_4((fb)->dprt, (fb)->dprh, (reg), (val))

struct smfb_softc {
	struct device		 sc_dev;
	struct smfb		*sc_fb;
	struct smfb		 sc_fb_store;

	struct wsscreen_list	 sc_wsl;
	struct wsscreen_descr	*sc_scrlist[1];
	int			 sc_nscr;
};

int	smfb_pci_match(struct device *, void *, void *);
void	smfb_pci_attach(struct device *, struct device *, void *);
int	smfb_voyager_match(struct device *, void *, void *);
void	smfb_voyager_attach(struct device *, struct device *, void *);
int	smfb_activate(struct device *, int);

const struct cfattach smfb_pci_ca = {
	sizeof(struct smfb_softc), smfb_pci_match, smfb_pci_attach,
	NULL, smfb_activate
};

const struct cfattach smfb_voyager_ca = {
	sizeof(struct smfb_softc), smfb_voyager_match, smfb_voyager_attach,
	smfb_activate
};

struct cfdriver smfb_cd = {
	NULL, "smfb", DV_DULL
};

int	smfb_alloc_screen(void *, const struct wsscreen_descr *, void **, int *,
	    int *, long *);
void	smfb_burner(void *, uint, uint);
void	smfb_free_screen(void *, void *);
int	smfb_ioctl(void *, u_long, caddr_t, int, struct proc *);
int	smfb_list_font(void *, struct wsdisplay_font *);
int	smfb_load_font(void *, void *, struct wsdisplay_font *);
paddr_t	smfb_mmap(void *, off_t, int);
int	smfb_show_screen(void *, void *, int, void (*)(void *, int, int),
	    void *);

struct wsdisplay_accessops smfb_accessops = {
	.ioctl = smfb_ioctl,
	.mmap = smfb_mmap,
	.alloc_screen = smfb_alloc_screen,
	.free_screen = smfb_free_screen,
	.show_screen = smfb_show_screen,
	.load_font = smfb_load_font,
	.list_font = smfb_list_font,
	.burn_screen = smfb_burner
};

int	smfb_setup(struct smfb *, bus_space_tag_t, bus_space_handle_t,
	    bus_space_tag_t, bus_space_handle_t);

void	smfb_copyrect(struct smfb *, int, int, int, int, int, int);
void	smfb_fillrect(struct smfb *, int, int, int, int, int);
int	smfb_copyrows(void *, int, int, int);
int	smfb_copycols(void *, int, int, int, int);
int	smfb_do_cursor(struct rasops_info *);
int	smfb_erasecols(void *, int, int, int, long);
int	smfb_eraserows(void *, int, int, long);
int	smfb_wait(struct smfb *);

void	smfb_wait_panel_vsync(struct smfb *, int);
uint8_t	smfb_vgats_read(struct smfb *, uint);
void	smfb_vgats_write(struct smfb *, uint, uint8_t);

void	smfb_attach_common(struct smfb_softc *, int, bus_space_tag_t,
	    bus_space_handle_t, bus_space_tag_t, bus_space_handle_t);

static struct smfb smfbcn;

const struct pci_matchid smfb_devices[] = {
	{ PCI_VENDOR_SMI, PCI_PRODUCT_SMI_SM712 }
};

int
smfb_pci_match(struct device *parent, void *vcf, void *aux)
{
	struct pci_attach_args *pa = (struct pci_attach_args *)aux;

	return pci_matchbyid(pa, smfb_devices, nitems(smfb_devices));
}

int
smfb_voyager_match(struct device *parent, void *vcf, void *aux)
{
	struct voyager_attach_args *vaa = (struct voyager_attach_args *)aux;
	struct cfdata *cf = (struct cfdata *)vcf;

	return strcmp(vaa->vaa_name, cf->cf_driver->cd_name) == 0;
}

void
smfb_pci_attach(struct device *parent, struct device *self, void *aux)
{
	struct smfb_softc *sc = (struct smfb_softc *)self;
	struct pci_attach_args *pa = (struct pci_attach_args *)aux;
	bus_space_tag_t memt;
	bus_space_handle_t memh;

	if (pci_mapreg_map(pa, PCI_MAPREG_START, PCI_MAPREG_TYPE_MEM,
	    BUS_SPACE_MAP_LINEAR, &memt, &memh, NULL, NULL, 0) != 0) {
		printf(": can't map frame buffer\n");
		return;
	}

	smfb_attach_common(sc, 0, memt, memh, memt, memh);
}

void
smfb_voyager_attach(struct device *parent, struct device *self, void *aux)
{
	struct smfb_softc *sc = (struct smfb_softc *)self;
	struct voyager_attach_args *vaa = (struct voyager_attach_args *)aux;

	smfb_attach_common(sc, 1, vaa->vaa_fbt, vaa->vaa_fbh, vaa->vaa_mmiot,
	    vaa->vaa_mmioh);
}

void
smfb_attach_common(struct smfb_softc *sc, int is5xx, bus_space_tag_t memt,
    bus_space_handle_t memh, bus_space_tag_t mmiot, bus_space_handle_t mmioh)
{
	struct wsemuldisplaydev_attach_args waa;
	int console;

	console = smfbcn.ri.ri_hw != NULL;

	if (console) {
		sc->sc_fb = &smfbcn;
		sc->sc_fb->sc = sc;
	} else {
		sc->sc_fb = &sc->sc_fb_store;
		sc->sc_fb->is5xx = is5xx;
		if (smfb_setup(sc->sc_fb, memt, memh, mmiot, mmioh) != 0) {
			printf(": can't setup frame buffer\n");
			return;
		}
	}

	printf(": %dx%d, %dbpp\n", sc->sc_fb->ri.ri_width,
	    sc->sc_fb->ri.ri_height, sc->sc_fb->ri.ri_depth);

	sc->sc_scrlist[0] = &sc->sc_fb->wsd;
	sc->sc_wsl.nscreens = 1;
	sc->sc_wsl.screens = (const struct wsscreen_descr **)sc->sc_scrlist;

	waa.console = console;
	waa.scrdata = &sc->sc_wsl;
	waa.accessops = &smfb_accessops;
	waa.accesscookie = sc;
	waa.defaultscreens = 0;

	config_found((struct device *)sc, &waa, wsemuldisplaydevprint);
}

/*
 * wsdisplay accesops
 */

int
smfb_alloc_screen(void *v, const struct wsscreen_descr *type, void **cookiep,
    int *curxp, int *curyp, long *attrp)
{
	struct smfb_softc *sc = (struct smfb_softc *)v;
	struct rasops_info *ri = &sc->sc_fb->ri;

	if (sc->sc_nscr > 0)
		return ENOMEM;

	*cookiep = ri;
	*curxp = *curyp = 0;
	ri->ri_ops.alloc_attr(ri, 0, 0, 0, attrp);
	sc->sc_nscr++;

	return 0;
}

void
smfb_free_screen(void *v, void *cookie)
{
	struct smfb_softc *sc = (struct smfb_softc *)v;

	sc->sc_nscr--;
}

int
smfb_ioctl(void *v, u_long cmd, caddr_t data, int flags, struct proc *p)
{
	struct smfb_softc *sc = (struct smfb_softc *)v;
	struct rasops_info *ri = &sc->sc_fb->ri;
	struct wsdisplay_fbinfo *wdf;

	switch (cmd) {
	case WSDISPLAYIO_GTYPE:
		*(uint *)data = WSDISPLAY_TYPE_SMFB;
		break;
	case WSDISPLAYIO_GINFO:
		wdf = (struct wsdisplay_fbinfo *)data;
		wdf->width = ri->ri_width;
		wdf->height = ri->ri_height;
		wdf->depth = ri->ri_depth;
		wdf->cmsize = 0;
		break;
	case WSDISPLAYIO_LINEBYTES:
		*(uint *)data = ri->ri_stride;
		break;
	default:
		return -1;
	}

	return 0;
}

int
smfb_show_screen(void *v, void *cookie, int waitok,
    void (*cb)(void *, int, int), void *cbarg)
{
	return 0;
}

paddr_t
smfb_mmap(void *v, off_t offset, int prot)
{
	struct smfb_softc *sc = (struct smfb_softc *)v;
	struct rasops_info *ri = &sc->sc_fb->ri;

	if ((offset & PAGE_MASK) != 0)
		return -1;

	if (offset < 0 || offset >= ri->ri_stride * ri->ri_height)
		return -1;

	return XKPHYS_TO_PHYS((paddr_t)ri->ri_bits) + offset;
}

int
smfb_load_font(void *v, void *emulcookie, struct wsdisplay_font *font)
{
	struct smfb_softc *sc = (struct smfb_softc *)v;
	struct rasops_info *ri = &sc->sc_fb->ri;

	return rasops_load_font(ri, emulcookie, font);
}

int
smfb_list_font(void *v, struct wsdisplay_font *font)
{
	struct smfb_softc *sc = (struct smfb_softc *)v;
	struct rasops_info *ri = &sc->sc_fb->ri;

	return rasops_list_font(ri, font);
}

void
smfb_burner(void *v, uint on, uint flg)
{
	struct smfb_softc *sc = (struct smfb_softc *)v;
	struct smfb *fb = sc->sc_fb;

	if (fb->is5xx) {
		if (on) {
			/*
			 * Wait for a few cycles after restoring power,
			 * to prevent white flickering.
			 */
			DCR_WRITE(fb, DCR_PANEL_DISPLAY_CONTROL,
			    DCR_READ(fb, DCR_PANEL_DISPLAY_CONTROL) | PDC_VDD);
			smfb_wait_panel_vsync(fb, 4);
			DCR_WRITE(fb, DCR_PANEL_DISPLAY_CONTROL,
			    DCR_READ(fb, DCR_PANEL_DISPLAY_CONTROL) | PDC_DATA);
			smfb_wait_panel_vsync(fb, 4);
			DCR_WRITE(fb, DCR_PANEL_DISPLAY_CONTROL,
			    DCR_READ(fb, DCR_PANEL_DISPLAY_CONTROL) |
			    (PDC_BIAS | PDC_EN));
		} else
			DCR_WRITE(fb, DCR_PANEL_DISPLAY_CONTROL,
			    DCR_READ(fb, DCR_PANEL_DISPLAY_CONTROL) &
			    ~(PDC_EN | PDC_BIAS | PDC_DATA | PDC_VDD));
	} else {
		if (on) {
			smfb_vgats_write(fb, 0x31,
			    smfb_vgats_read(fb, 0x31) | 0x01);
		} else {
			smfb_vgats_write(fb, 0x21,
			    smfb_vgats_read(fb, 0x21) | 0x30);
			smfb_vgats_write(fb, 0x31,
			    smfb_vgats_read(fb, 0x31) & ~0x01);
		}
	}
}

/*
 * Frame buffer initialization.
 */

int
smfb_setup(struct smfb *fb, bus_space_tag_t memt, bus_space_handle_t memh,
    bus_space_tag_t mmiot, bus_space_handle_t mmioh)
{
	struct rasops_info *ri;
	int accel = 0;
	int rc;

	ri = &fb->ri;
	switch (sys_platform->system_type) {
	case LOONGSON_EBT700:
		ri->ri_width = 800;
		ri->ri_height = 480;
		break;
	default:
	case LOONGSON_GDIUM:
	case LOONGSON_LYNLOONG:
	case LOONGSON_YEELOONG:
		ri->ri_width = 1024;
		ri->ri_height = 600;
		break;
	}
	ri->ri_depth = 16;
	ri->ri_stride = (ri->ri_width * ri->ri_depth) / 8;
	ri->ri_flg = RI_CENTER | RI_CLEAR | RI_FULLCLEAR;
	ri->ri_bits = (void *)bus_space_vaddr(memt, memh);
	ri->ri_hw = fb;

#ifdef __MIPSEL__
	/* swap B and R */
	ri->ri_rnum = 5;
	ri->ri_rpos = 11;
	ri->ri_gnum = 6;
	ri->ri_gpos = 5;
	ri->ri_bnum = 5;
	ri->ri_bpos = 0;
#endif

	rasops_init(ri, 160, 160);

	strlcpy(fb->wsd.name, "std", sizeof(fb->wsd.name));
	fb->wsd.ncols = ri->ri_cols;
	fb->wsd.nrows = ri->ri_rows;
	fb->wsd.textops = &ri->ri_ops;
	fb->wsd.fontwidth = ri->ri_font->fontwidth;
	fb->wsd.fontheight = ri->ri_font->fontheight;
	fb->wsd.capabilities = ri->ri_caps;

	if (fb->is5xx) {
		fb->dcrt = mmiot;
		if ((rc = bus_space_subregion(mmiot, mmioh, SM5XX_DCR_BASE,
		    SM5XX_DCR_SIZE, &fb->dcrh)) != 0)
			return rc;
		fb->dprt = mmiot;
		if ((rc = bus_space_subregion(mmiot, mmioh, SM5XX_DPR_BASE,
		    SMXXX_DPR_SIZE, &fb->dprh)) != 0)
			return rc;
		fb->mmiot = mmiot;
		if ((rc = bus_space_subregion(mmiot, mmioh, SM5XX_MMIO_BASE,
		    SM5XX_MMIO_SIZE, &fb->mmioh)) != 0)
			return rc;
		accel = 1;
	} else {
		fb->dprt = memt;
		if ((rc = bus_space_subregion(memt, memh, SM7XX_DPR_BASE,
		    SMXXX_DPR_SIZE, &fb->dprh)) != 0)
			return rc;
		fb->mmiot = memt;
		if ((rc = bus_space_subregion(memt, memh, SM7XX_MMIO_BASE,
		    SM7XX_MMIO_SIZE, &fb->mmioh)) != 0)
			return rc;
		accel = 1;
	}

	/*
	 * Setup 2D acceleration whenever possible
	 */

	if (accel) {
		if (smfb_wait(fb) != 0)
			accel = 0;
	}
	if (accel) {
		DPR_WRITE(fb, DPR_CROP_TOPLEFT_COORDS, DPR_COORDS(0, 0));
		/* use of width both times is intentional */
		DPR_WRITE(fb, DPR_PITCH,
		    DPR_COORDS(ri->ri_width, ri->ri_width));
		DPR_WRITE(fb, DPR_SRC_WINDOW,
		    DPR_COORDS(ri->ri_width, ri->ri_width));
		DPR_WRITE(fb, DPR_BYTE_BIT_MASK, 0xffffffff);
		DPR_WRITE(fb, DPR_COLOR_COMPARE_MASK, 0);
		DPR_WRITE(fb, DPR_COLOR_COMPARE, 0);
		DPR_WRITE(fb, DPR_SRC_BASE, 0);
		DPR_WRITE(fb, DPR_DST_BASE, 0);
		DPR_READ(fb, DPR_DST_BASE);

		ri->ri_ops.copycols = smfb_copycols;
		ri->ri_ops.copyrows = smfb_copyrows;
		ri->ri_ops.erasecols = smfb_erasecols;
		ri->ri_ops.eraserows = smfb_eraserows;
	}

	return 0;
}

void
smfb_copyrect(struct smfb *fb, int sx, int sy, int dx, int dy, int w, int h)
{
	uint32_t dir;

	/* Compute rop direction */
	if (sy < dy || (sy == dy && sx <= dx)) {
		sx += w - 1;
		dx += w - 1;
		sy += h - 1;
		dy += h - 1;
		dir = DE_CTRL_RTOL;
	} else
		dir = 0;

	DPR_WRITE(fb, DPR_SRC_COORDS, DPR_COORDS(sx, sy));
	DPR_WRITE(fb, DPR_DST_COORDS, DPR_COORDS(dx, dy));
	DPR_WRITE(fb, DPR_SPAN_COORDS, DPR_COORDS(w, h));
	DPR_WRITE(fb, DPR_DE_CTRL, DE_CTRL_START | DE_CTRL_ROP_ENABLE | dir |
	    (DE_CTRL_COMMAND_BITBLT << DE_CTRL_COMMAND_SHIFT) |
	    (DE_CTRL_ROP_SRC << DE_CTRL_ROP_SHIFT));
	DPR_READ(fb, DPR_DE_CTRL);

	smfb_wait(fb);
}

void
smfb_fillrect(struct smfb *fb, int x, int y, int w, int h, int bg)
{
	struct rasops_info *ri;

	ri = &fb->ri;

	DPR_WRITE(fb, DPR_FG_COLOR, ri->ri_devcmap[bg]);
	DPR_WRITE(fb, DPR_DST_COORDS, DPR_COORDS(x, y));
	DPR_WRITE(fb, DPR_SPAN_COORDS, DPR_COORDS(w, h));
	DPR_WRITE(fb, DPR_DE_CTRL, DE_CTRL_START | DE_CTRL_ROP_ENABLE |
	    (DE_CTRL_COMMAND_SOLIDFILL << DE_CTRL_COMMAND_SHIFT) |
	    (DE_CTRL_ROP_SRC << DE_CTRL_ROP_SHIFT));
	DPR_READ(fb, DPR_DE_CTRL);

	smfb_wait(fb);
}

int
smfb_copyrows(void *cookie, int src, int dst, int num)
{
	struct rasops_info *ri = cookie;
	struct smfb *fb = ri->ri_hw;
	struct wsdisplay_font *f = ri->ri_font;

	num *= f->fontheight;
	src *= f->fontheight;
	dst *= f->fontheight;

	smfb_copyrect(fb, ri->ri_xorigin, ri->ri_yorigin + src,
	    ri->ri_xorigin, ri->ri_yorigin + dst, ri->ri_emuwidth, num);

	return 0;
}

int
smfb_copycols(void *cookie, int row, int src, int dst, int num)
{
	struct rasops_info *ri = cookie;
	struct smfb *fb = ri->ri_hw;
	struct wsdisplay_font *f = ri->ri_font;

	num *= f->fontwidth;
	src *= f->fontwidth;
	dst *= f->fontwidth;
	row *= f->fontheight;

	smfb_copyrect(fb, ri->ri_xorigin + src, ri->ri_yorigin + row,
	    ri->ri_xorigin + dst, ri->ri_yorigin + row, num, f->fontheight);

	return 0;
}

int
smfb_erasecols(void *cookie, int row, int col, int num, long attr)
{
	struct rasops_info *ri = cookie;
	struct smfb *fb = ri->ri_hw;
	struct wsdisplay_font *f = ri->ri_font;
	int bg, fg;

	ri->ri_ops.unpack_attr(cookie, attr, &fg, &bg, NULL);

	row *= f->fontheight;
	col *= f->fontwidth;
	num *= f->fontwidth;

	smfb_fillrect(fb, ri->ri_xorigin + col, ri->ri_yorigin + row,
	    num, f->fontheight, bg);

	return 0;
}

int
smfb_eraserows(void *cookie, int row, int num, long attr)
{
	struct rasops_info *ri = cookie;
	struct smfb *fb = ri->ri_hw;
	struct wsdisplay_font *f = ri->ri_font;
	int bg, fg;
	int x, y, w;

	ri->ri_ops.unpack_attr(cookie, attr, &fg, &bg, NULL);

	if ((num == ri->ri_rows) && ISSET(ri->ri_flg, RI_FULLCLEAR)) {
		num = ri->ri_height;
		x = y = 0;
		w = ri->ri_width;
	} else {
		num *= f->fontheight;
		x = ri->ri_xorigin;
		y = ri->ri_yorigin + row * f->fontheight;
		w = ri->ri_emuwidth;
	}
	smfb_fillrect(fb, x, y, w, num, bg);

	return 0;
}

int
smfb_wait(struct smfb *fb)
{
	uint32_t reg;
	int i;

	i = 10000;
	while (i-- != 0) {
		if (fb->is5xx) {
			reg = bus_space_read_4(fb->mmiot, fb->mmioh,
			    VOYAGER_SYSTEM_CONTROL);
			if ((reg & (VSC_FIFO_EMPTY | VSC_2DENGINE_BUSY)) ==
			    VSC_FIFO_EMPTY)
				return 0;
		} else {
			reg = smfb_vgats_read(fb, 0x16);
			if ((reg & 0x18) == 0x10)
				return 0;
		}
		delay(1);
	}

	return EBUSY;
}

/*
 * wait for a few panel vertical retrace cycles (5xx only)
 */
void
smfb_wait_panel_vsync(struct smfb *fb, int ncycles)
{
	while (ncycles-- != 0) {
		/* wait for end of retrace-in-progress */
		while (ISSET(bus_space_read_4(fb->mmiot, fb->mmioh,
		    VOYAGER_COMMANDLIST_STATUS), VCS_SP))
			delay(10);
		/* wait for start of retrace */
		while (!ISSET(bus_space_read_4(fb->mmiot, fb->mmioh,
		    VOYAGER_COMMANDLIST_STATUS), VCS_SP))
			delay(10);
	}
}

/*
 * vga sequencer access through mmio space (non-5xx only)
 */

uint8_t
smfb_vgats_read(struct smfb *fb, uint regno)
{
	bus_space_write_1(fb->mmiot, fb->mmioh, IO_VGA + VGA_TS_INDEX, regno);
	return bus_space_read_1(fb->mmiot, fb->mmioh, IO_VGA + VGA_TS_DATA);
}

void
smfb_vgats_write(struct smfb *fb, uint regno, uint8_t value)
{
	bus_space_write_1(fb->mmiot, fb->mmioh, IO_VGA + VGA_TS_INDEX, regno);
	bus_space_write_1(fb->mmiot, fb->mmioh, IO_VGA + VGA_TS_DATA, value);
}

/*
 * Early console code
 */

int smfb_cnattach(bus_space_tag_t, bus_space_tag_t, pcitag_t, pcireg_t);

int
smfb_cnattach(bus_space_tag_t memt, bus_space_tag_t iot, pcitag_t tag,
    pcireg_t id)
{
	long defattr;
	struct rasops_info *ri;
	bus_space_handle_t fbh, mmioh;
	pcireg_t bar;
	int rc, is5xx;

	/* filter out unrecognized devices */
	switch (id) {
	default:
		return ENODEV;
	case PCI_ID_CODE(PCI_VENDOR_SMI, PCI_PRODUCT_SMI_SM712):
		is5xx = 0;
		break;
	case PCI_ID_CODE(PCI_VENDOR_SMI, PCI_PRODUCT_SMI_SM501):
		is5xx = 1;
		break;
	}

	smfbcn.is5xx = is5xx;

	bar = pci_conf_read_early(tag, PCI_MAPREG_START);
	if (PCI_MAPREG_TYPE(bar) != PCI_MAPREG_TYPE_MEM)
		return EINVAL;
	rc = bus_space_map(memt, PCI_MAPREG_MEM_ADDR(bar), 1 /* XXX */,
	    BUS_SPACE_MAP_LINEAR, &fbh);
	if (rc != 0)
		return rc;

	if (smfbcn.is5xx) {
		bar = pci_conf_read_early(tag, PCI_MAPREG_START + 0x04);
		if (PCI_MAPREG_TYPE(bar) != PCI_MAPREG_TYPE_MEM)
			return EINVAL;
		rc = bus_space_map(memt, PCI_MAPREG_MEM_ADDR(bar), 1 /* XXX */,
		    BUS_SPACE_MAP_LINEAR, &mmioh);
		if (rc != 0)
			return rc;
	} else {
		mmioh = fbh;
	}

	rc = smfb_setup(&smfbcn, memt, fbh, memt, mmioh);
	if (rc != 0)
		return rc;

	ri = &smfbcn.ri;
	ri->ri_ops.alloc_attr(ri, 0, 0, 0, &defattr);
	wsdisplay_cnattach(&smfbcn.wsd, ri, 0, 0, defattr);

	return 0;
}

int
smfb_activate(struct device *self, int act)
{
	struct smfb_softc *sc = (struct smfb_softc *)self;

	switch (act) {
	case DVACT_SUSPEND:
		smfb_burner(sc, 0, 0);
		break;
	case DVACT_RESUME:
		smfb_burner(sc, 1, 0);
		break;
	}

	return 0;
}
@


1.16
log
@Add load_font and list_font accessops to all rasops-based wsdisplay drivers.
Trivial except for tga(4) and gpx(4/vax) which need a bit more care setting
up a new font.
@
text
@d1 1
a1 1
/*	$OpenBSD: smfb.c,v 1.15 2013/10/20 20:07:24 miod Exp $	*/
d222 2
a223 2
	/* XXX print resolution */
	printf("\n");
@


1.15
log
@Use C99 named initializers for struct wsdisplay_accessops fields.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: smfb.c,v 1.14 2012/10/03 21:44:51 miod Exp $	*/
d112 1
d115 3
a119 2
paddr_t	smfb_mmap(void *, off_t, int);
void	smfb_burner(void *, uint, uint);
d127 2
d316 18
@


1.14
log
@Do not use <mips64/archtype.h> for loongson model numbers, but rather put the
list in loongson's <machine/autoconf.h> directly. <mips64/archtype.h> is
intended to be only used on ARCBios-like platforms.
@
text
@d1 1
a1 1
/*	$OpenBSD: smfb.c,v 1.13 2011/07/21 20:36:12 miod Exp $	*/
d120 6
a125 9
	smfb_ioctl,
	smfb_mmap,
	smfb_alloc_screen,
	smfb_free_screen,
	smfb_show_screen,
	NULL,	/* load_font */
	NULL,	/* scrollback */
	NULL,	/* getchar */
	smfb_burner
@


1.13
log
@Support for the eBenton EBT-700 netbook, which is similar to the Lemote
Yeeloong, but with a 7" display with a 800x480 resolution, and no webcam.

There are still problems to get it booting from disk from PMON (colour me
unsurprised), which are being looked at. Loading the boot blocks from a FAT
USB stick, to then boot the kernel from the disk, is a reliable workaround
in the meantime.

Tested by Ban Keong Yee (bankeong dot yee on gmail) who is the ``lucky''
owner of such a machine, thanks for your time!
@
text
@d1 1
a1 1
/*	$OpenBSD: smfb.c,v 1.12 2011/05/25 21:15:46 miod Exp $	*/
a28 2

#include <mips64/include/archtype.h>
@


1.12
log
@Do not dereference ri_devcmap[] twice; found the hard way by Gilbert Fernandes
(firstname dot lastname at orange dot frogland).
@
text
@d1 1
a1 1
/*	$OpenBSD: smfb.c,v 1.11 2010/12/26 15:40:59 miod Exp $	*/
d23 1
a23 1
 * 1024x600 resolution.
d30 3
d370 13
a382 2
	ri->ri_width = 1024;
	ri->ri_height = 600;
@


1.11
log
@Kill pmap_phys_address(), and force every driver's mmap() routine to return
a physical address [more precisely, something suitable to pass to pmap_enter()'sphysical address argument].

This allows MI drivers to implement mmap() routines without having to know
about the pmap_phys_address() implementation and #ifdef obfuscation.
@
text
@d1 1
a1 1
/*	$OpenBSD: smfb.c,v 1.10 2010/08/31 10:24:46 pirofti Exp $	*/
d546 1
a546 1
	    num, f->fontheight, ri->ri_devcmap[bg]);
d572 1
a572 1
	smfb_fillrect(fb, x, y, w, num, ri->ri_devcmap[bg]);
@


1.10
log
@WIP suspend/resume support for loongson lemote. Okay miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: smfb.c,v 1.9 2010/08/27 12:48:54 miod Exp $	*/
a305 1
	paddr_t pa;
d313 1
a313 2
	pa = XKPHYS_TO_PHYS((paddr_t)ri->ri_bits) + offset;
	return atop(pa);
@


1.9
log
@screen blanking code for SM502, and some smfb code cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: smfb.c,v 1.8 2010/08/26 18:57:14 miod Exp $	*/
d93 1
d96 2
a97 1
	sizeof(struct smfb_softc), smfb_pci_match, smfb_pci_attach
d101 2
a102 1
	sizeof(struct smfb_softc), smfb_voyager_match, smfb_voyager_attach
d697 17
@


1.8
log
@Screen burner support for SM712 flavour (Lemote Yeeloong)
@
text
@d1 1
a1 1
/*	$OpenBSD: smfb.c,v 1.7 2010/02/28 21:35:41 miod Exp $	*/
d20 4
a23 1
 * Minimal SiliconMotion SM502 and SM712 frame buffer driver.
a48 6
#define	DPR_READ(fb, reg)	(fb)->dpr[(reg) / 4]
#define	DPR_WRITE(fb, reg, val)	(fb)->dpr[(reg) / 4] = (val)

#define	REG_READ(fb, reg)	(fb)->regs[(reg) / 4]
#define	REG_WRITE(fb, reg, val)	(fb)->regs[(reg) / 4] = (val)

d57 10
a66 3
	volatile uint32_t	*regs;
	volatile uint32_t	*dpr;
	volatile uint8_t	*mmio;
d70 9
a83 6
	bus_space_tag_t		 sc_memt;
	bus_space_handle_t	 sc_memh;

	bus_space_tag_t		 sc_regt;
	bus_space_handle_t	 sc_regh;

d127 2
a128 1
int	smfb_setup(struct smfb *, vaddr_t, vaddr_t);
d139 3
a141 2
uint8_t	smfb_mmio_read(struct smfb *, uint);
void	smfb_mmio_write(struct smfb *, uint, uint8_t);
d143 2
a144 1
void	smfb_attach_common(struct smfb_softc *, int);
d174 2
d178 1
a178 2
	    BUS_SPACE_MAP_LINEAR, &sc->sc_memt, &sc->sc_memh,
	    NULL, NULL, 0) != 0) {
d183 1
a183 1
	smfb_attach_common(sc, 0);
d192 2
a193 6
	sc->sc_memt = vaa->vaa_fbt;
	sc->sc_memh = vaa->vaa_fbh;
	sc->sc_regt = vaa->vaa_mmiot;
	sc->sc_regh = vaa->vaa_mmioh;

	smfb_attach_common(sc, 1);
d197 2
a198 1
smfb_attach_common(struct smfb_softc *sc, int is5xx)
a200 1
	vaddr_t fbbase, regbase;
d211 1
a211 8
		fbbase = (vaddr_t)bus_space_vaddr(sc->sc_memt, sc->sc_memh);
		if (is5xx) {
			regbase = (vaddr_t)bus_space_vaddr(sc->sc_regt,
			    sc->sc_regh);
		} else {
			regbase = 0;
		}
		if (smfb_setup(sc->sc_fb, fbbase, regbase) != 0) {
d322 18
a339 1
		/* XXX TBD */
d342 2
a343 2
			smfb_mmio_write(fb, 0x31,
			    smfb_mmio_read(fb, 0x31) | 0x01);
d345 4
a348 4
			smfb_mmio_write(fb, 0x21,
			    smfb_mmio_read(fb, 0x21) | 0x30);
			smfb_mmio_write(fb, 0x31,
			    smfb_mmio_read(fb, 0x31) & ~0x01);
d358 2
a359 1
smfb_setup(struct smfb *fb, vaddr_t fbbase, vaddr_t regbase)
d363 1
d371 1
a371 1
	ri->ri_bits = (void *)fbbase;
d395 12
a406 3
		fb->dpr = (volatile uint32_t *)(regbase + SM5XX_DPR_BASE);
		fb->mmio = NULL;
		fb->regs = (volatile uint32_t *)(regbase + SM5XX_MMIO_BASE);
d409 8
a416 3
		fb->dpr = (volatile uint32_t *)(fbbase + SM7XX_DPR_BASE);
		fb->mmio = (volatile uint8_t *)(fbbase + SM7XX_MMIO_BASE);
		fb->regs = NULL;
d585 2
a586 1
			reg = REG_READ(fb, VOYAGER_SYSTEM_CONTROL);
d591 1
a591 1
			reg = smfb_mmio_read(fb, 0x16);
d601 22
d624 1
a624 1
smfb_mmio_read(struct smfb *fb, uint regno)
d626 2
a627 3
	fb->mmio[IO_VGA + VGA_TS_INDEX] = regno;
	(void)fb->mmio[IO_VGA + VGA_TS_INDEX];	/* posted write */
	return fb->mmio[IO_VGA + VGA_TS_DATA];
d631 1
a631 1
smfb_mmio_write(struct smfb *fb, uint regno, uint8_t value)
d633 2
a634 4
	fb->mmio[IO_VGA + VGA_TS_INDEX] = regno;
	(void)fb->mmio[IO_VGA + VGA_TS_INDEX];	/* posted write */
	fb->mmio[IO_VGA + VGA_TS_DATA] = value;
	(void)fb->mmio[IO_VGA + VGA_TS_DATA];	/* posted write */
d649 1
a649 2
	bus_space_handle_t fbh, regh;
	vaddr_t fbbase, regbase;
a673 1
	fbbase = (vaddr_t)bus_space_vaddr(memt, fbh);
d680 1
a680 1
		    BUS_SPACE_MAP_LINEAR, &regh);
a682 1
		regbase = (vaddr_t)bus_space_vaddr(memt, regh);
d684 1
a684 1
		regbase = 0;
d687 1
a687 1
	rc = smfb_setup(&smfbcn, fbbase, regbase);
@


1.7
log
@A better bus_space_map() function for bonito PCI memory space, which no
longers assumes all requested mappings fit in the three 64MB PCILO windows,
but will instead check whether the requested mappings can be provided by
PCILO regions or PCIHI regions (and on 2F-based systems, making sure we
only use addresses which get properly routed from CPU to PCI within the
2F crossbar).

This in turn requires early console code to abide the bus_space rules and
get its resources from bus_space_map() rather than doing PCI BAR arithmetic
by itself.

No functional change on Lemote Yeeloong and Gdium Liberty; on Lemote Fuloong
2F this allows BAR set up in PCIHI space by PMON to be mapped by kernel code
without having to compensate for the PCILO offset.
@
text
@d1 1
a1 1
/*	$OpenBSD: smfb.c,v 1.6 2010/02/26 14:53:11 miod Exp $	*/
d32 2
d106 1
d117 1
a117 1
	NULL	/* burner */
d131 3
d315 21
d557 1
a557 3
			fb->mmio[0x3c4] = 0x16;
			(void)fb->mmio[0x3c4];	/* posted write */
			reg = fb->mmio[0x3c5];
d567 17
d602 1
a602 1
	switch(id) {
@


1.6
log
@Subdevice interrupt dispatcher for voyager(4) and ohci@@voyager device, only
allowed to match on old gdium artwork, as newer artwork have nothing
connected to the usb pins, and this causes the empty bus probe to stall the
boot a few seconds.
@
text
@d1 1
a1 1
/*	$OpenBSD: smfb.c,v 1.5 2010/02/18 22:45:28 miod Exp $	*/
d546 1
a546 1
int smfb_cnattach(bus_space_tag_t, pcitag_t, pcireg_t);
d549 2
a550 1
smfb_cnattach(bus_space_tag_t memt, pcitag_t tag, pcireg_t id)
d554 1
d576 5
a580 1
	fbbase = memt->bus_base + PCI_MAPREG_MEM_ADDR(bar);
d586 5
a590 1
		regbase = memt->bus_base + PCI_MAPREG_MEM_ADDR(bar);
@


1.5
log
@Add a master driver for the VoyagerGX SM502 chip found on the Gdium, which is
not only a framebuffer. Allow smfb to attach either at pci or at voyager.

Add gpio@@voyager and gdiumiic@@gpio, a derivative of the MI gpioiic driver.
This allows us to get lmtemp@@iic on the Lemote; the next step being to
write a driver for the i2c todclock chip found on the same bus.
@
text
@d1 1
a1 1
/*	$OpenBSD: smfb.c,v 1.4 2010/02/05 20:56:49 miod Exp $	*/
d526 1
a526 1
			if ((reg & (VSC_FIFO_EMPTY | VSC_STATUS_BUSY)) ==
@


1.4
log
@Blind support for SM501 model. This should give the Gdium Liberty a working,
accelerated console. No regression on Lemote Yeelong.
@
text
@d1 1
a1 1
/*	$OpenBSD: smfb.c,v 1.3 2010/02/05 20:53:24 miod Exp $	*/
d20 1
a20 2
 * Routines for early console with video memory at fixed address.
 * And eventually the whole driver as well.
d40 2
d80 4
a83 2
int	smfb_match(struct device *, void *, void *);
void	smfb_attach(struct device *, struct device *, void *);
d85 6
a90 2
const struct cfattach smfb_ca = {
	sizeof(struct smfb_softc), smfb_match, smfb_attach
d127 2
a128 1
int	smfb_is5xx(pcireg_t);
d132 4
d137 1
a137 1
smfb_is5xx(pcireg_t id)
d139 3
a141 8
	switch(id) {
	default:
		return -1;
	case PCI_ID_CODE(PCI_VENDOR_SMI, PCI_PRODUCT_SMI_SM712):
		return 0;
	case PCI_ID_CODE(PCI_VENDOR_SMI, PCI_PRODUCT_SMI_SM501):
		return 1;
	}
d145 1
a145 1
smfb_match(struct device *parent, void *vcf, void *aux)
d147 2
a148 2
	struct pci_attach_args *pa = (struct pci_attach_args *)aux;
	int is5xx = smfb_is5xx(pa->pa_id);
d150 1
a150 1
	return is5xx < 0 ? 0 : 1;
d154 1
a154 1
smfb_attach(struct device *parent, struct device *self, void *aux)
a157 4
	struct wsemuldisplaydev_attach_args waa;
	vaddr_t fbbase, regbase;
	int console;
	int is5xx = smfb_is5xx(pa->pa_id);
d166 23
a188 8
	if (is5xx) {
		if (pci_mapreg_map(pa, PCI_MAPREG_START + 0x04,
		    PCI_MAPREG_TYPE_MEM,
		    BUS_SPACE_MAP_LINEAR, &sc->sc_regt, &sc->sc_regh,
		    NULL, NULL, 0) != 0) {
			printf(": can't map registers\n%s", self->dv_xname);
		}
	}
d199 1
a199 1
		if (sc->sc_regh != 0) {
d211 1
d349 4
a352 8
		if (regbase != 0) {
			fb->dpr = (volatile uint32_t *)
			    (regbase + SM5XX_DPR_BASE);
			fb->mmio = NULL;
			fb->regs = (volatile uint32_t *)
			    (regbase + SM5XX_REG_BASE);
			accel = 1;
		}
d525 3
a527 3
			reg = REG_READ(fb, REG_SYSTEM_CONTROL);
			if ((reg & (RSC_FIFO_EMPTY | RSC_STATUS_BUSY)) ==
			    RSC_FIFO_EMPTY)
d558 2
a559 2
	is5xx = smfb_is5xx(id);
	if (is5xx < 0)
d561 7
a575 1
	regbase = 0;
d578 5
a582 2
		if (PCI_MAPREG_TYPE(bar) == PCI_MAPREG_TYPE_MEM)
			regbase = memt->bus_base + PCI_MAPREG_MEM_ADDR(bar);
@


1.3
log
@Add a set of functions to access PCI configuration space before bonito(4)
attaches, and use it to walk the PCI bus to figure out where the onboard
frame buffer device lies, if any; and get the frame buffer memory address
from reading the proper PCI BAR instead of hardcoding it; this should allow
the Gdium Liberty to configure its console correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: smfb.c,v 1.2 2010/01/31 15:30:29 miod Exp $	*/
d4 1
a4 1
 * Copyright (c) 2009 Miodrag Vallat.
d46 3
d55 1
d57 1
d71 3
d110 1
a110 1
int	smfb_setup(struct smfb *, vaddr_t);
d120 1
d124 12
a135 3
const struct pci_matchid smfb_devices[] = {
	{ PCI_VENDOR_SMI, PCI_PRODUCT_SMI_SM712 }
};
d140 2
a141 1
	struct pci_attach_args *paa = (struct pci_attach_args *)aux;
d143 1
a143 1
	return pci_matchbyid(paa, smfb_devices, nitems(smfb_devices));
d152 1
a152 1
	vaddr_t fbbase;
d154 1
d163 9
d179 1
d181 7
a187 1
		if (smfb_setup(sc->sc_fb, fbbase) != 0) {
d295 1
a295 1
smfb_setup(struct smfb *fb, vaddr_t fbbase)
d298 1
d329 15
a343 2
	fb->dpr = (volatile uint32_t *)(fbbase + DPR_BASE);
	fb->mmio = (volatile uint8_t *)(fbbase + MMIO_BASE);
d346 1
a346 1
	 * Setup 2D acceleration
d349 23
a371 17
	smfb_wait(fb);

	DPR_WRITE(fb, DPR_CROP_TOPLEFT_COORDS, DPR_COORDS(0, 0));
	/* use of width both times is intentional */
	DPR_WRITE(fb, DPR_PITCH, DPR_COORDS(ri->ri_width, ri->ri_width));
	DPR_WRITE(fb, DPR_SRC_WINDOW, DPR_COORDS(ri->ri_width, ri->ri_width));
	DPR_WRITE(fb, DPR_BYTE_BIT_MASK, 0xffffffff);
	DPR_WRITE(fb, DPR_COLOR_COMPARE_MASK, 0);
	DPR_WRITE(fb, DPR_COLOR_COMPARE, 0);
	DPR_WRITE(fb, DPR_SRC_BASE, 0);
	DPR_WRITE(fb, DPR_DST_BASE, 0);
	DPR_READ(fb, DPR_DST_BASE);

	ri->ri_ops.copycols = smfb_copycols;
	ri->ri_ops.copyrows = smfb_copyrows;
	ri->ri_ops.erasecols = smfb_erasecols;
	ri->ri_ops.eraserows = smfb_eraserows;
d504 1
a504 1
	uint8_t reg;
d509 12
a520 5
		fb->mmio[0x3c4] = 0x16;
		(void)fb->mmio[0x3c4];	/* posted write */
		reg = fb->mmio[0x3c5];
		if ((reg & 0x18) == 0x10)
			return 0;
d538 1
a538 1
	vaddr_t fbbase;
d540 8
a547 1
	int rc;
d554 8
a561 1
	rc = smfb_setup(&smfbcn, fbbase);
@


1.2
log
@Return a correct address in smfb_mmap(), allows X to work with wsfb.
@
text
@d1 1
a1 1
/*	$OpenBSD: smfb.c,v 1.1.1.1 2009/12/25 21:19:32 miod Exp $	*/
d468 1
a468 1
int smfb_cnattach(void);
d471 1
a471 1
smfb_cnattach()
d476 1
a477 1
	extern paddr_t loongson_pci_base;
d479 4
a482 2
	/* XXX hardwired fbmem address */
	fbbase = PHYS_TO_XKPHYS(loongson_pci_base + 0x14000000, CCA_NC);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d250 1
a250 1
	pa = XKPHYS_TO_PHYS((paddr_t)ri->ri_hw) + offset;
@


1.1.1.1
log
@By popular demand and peer pressure, check-in work in progress work to support
the Yeelong Lemote mips-based netbook. Kernel bits only for now, needs
polishing; most of this work done during h2k9 last month, although the
porting effort started earlier this year.
@
text
@@
