head	1.31;
access;
symbols
	OPENBSD_6_0:1.31.0.2
	OPENBSD_6_0_BASE:1.31
	OPENBSD_5_9:1.30.0.2
	OPENBSD_5_9_BASE:1.30
	OPENBSD_5_8:1.28.0.6
	OPENBSD_5_8_BASE:1.28
	OPENBSD_5_7:1.28.0.2
	OPENBSD_5_7_BASE:1.28
	OPENBSD_5_6:1.27.0.4
	OPENBSD_5_6_BASE:1.27
	OPENBSD_5_5:1.24.0.4
	OPENBSD_5_5_BASE:1.24
	OPENBSD_5_4:1.23.0.2
	OPENBSD_5_4_BASE:1.23
	OPENBSD_5_3:1.22.0.2
	OPENBSD_5_3_BASE:1.22
	OPENBSD_5_2:1.19.0.6
	OPENBSD_5_2_BASE:1.19
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.4
	OPENBSD_5_0:1.19.0.2
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.18.0.2
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.15.0.2
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.13.0.2
	OPENBSD_4_7_BASE:1.13
	xmas_lemote:1.1.1.1
	miod:1.1.1;
locks; strict;
comment	@ * @;


1.31
date	2016.03.06.19.42.27;	author mpi;	state Exp;
branches;
next	1.30;
commitid	cyYKarj4qRTft4gD;

1.30
date	2015.09.19.21.07.04;	author semarie;	state Exp;
branches;
next	1.29;
commitid	9KMPSlP02LD1SpJP;

1.29
date	2015.09.08.08.33.26;	author deraadt;	state Exp;
branches;
next	1.28;
commitid	t59bsVfEDCZAKIKs;

1.28
date	2014.09.26.14.32.07;	author jsing;	state Exp;
branches;
next	1.27;
commitid	OvRx4Hf7atBtxEXK;

1.27
date	2014.07.12.18.44.42;	author tedu;	state Exp;
branches;
next	1.26;
commitid	uKVPYMN2MLxdZxzH;

1.26
date	2014.05.24.21.11.01;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2014.03.27.22.16.03;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2013.08.25.08.18.05;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2013.05.30.16.15.01;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2012.10.03.11.18.20;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2012.09.29.19.24.30;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2012.09.29.18.54.36;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2011.03.31.20.37.44;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2010.12.04.17.06.31;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2010.09.20.06.33.48;	author matthew;	state Exp;
branches;
next	1.16;

1.16
date	2010.08.31.10.24.46;	author pirofti;	state Exp;
branches;
next	1.15;

1.15
date	2010.07.18.13.36.13;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2010.05.08.21.59.56;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2010.03.02.20.53.12;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2010.02.28.21.35.41;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2010.02.24.22.33.20;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2010.02.12.08.14.02;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2010.02.10.21.09.40;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2010.02.09.21.31.46;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2010.02.05.20.53.24;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2010.02.05.20.51.22;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2010.02.05.20.47.15;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2010.01.31.19.12.12;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2010.01.26.05.35.55;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2010.01.22.21.45.22;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2009.12.25.22.09.45;	author miod;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2009.12.25.22.09.45;	author miod;	state Exp;
branches;
next	;


desc
@@


1.31
log
@Rename mips64's trap_frame into trapframe.

For coherency with other archs and in order to use it in MI code.

ok visa@@, tobiasu@@
@
text
@/*	$OpenBSD: bonito.c,v 1.30 2015/09/19 21:07:04 semarie Exp $	*/
/*	$NetBSD: bonito_mainbus.c,v 1.11 2008/04/28 20:23:10 martin Exp $	*/
/*	$NetBSD: bonito_pci.c,v 1.5 2008/04/28 20:23:28 martin Exp $	*/

/*
 * Copyright (c) 2009, 2010 Miodrag Vallat.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
/*-
 * Copyright (c) 2001 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * PCI configuration space support for the Loongson PCI and memory controller
 * chip, which is derived from the Algorithmics BONITO chip.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/extent.h>
#include <sys/malloc.h>

#include <machine/autoconf.h>
#include <machine/bus.h>
#include <machine/cpu.h>
#include <mips64/mips_cpu.h>
#include <machine/intr.h>

#include <dev/pci/pcidevs.h>
#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/ppbreg.h>

#include <loongson/dev/bonitoreg.h>
#include <loongson/dev/bonitovar.h>
#include <loongson/dev/bonito_irq.h>

#include <uvm/uvm_extern.h>

#if 0
#define	BONITO_DEBUG
#endif

int	bonito_match(struct device *, void *, void *);
void	bonito_attach(struct device *, struct device *, void *);

const struct cfattach bonito_ca = {
	sizeof(struct bonito_softc), bonito_match, bonito_attach
};

struct cfdriver bonito_cd = {
	NULL, "bonito", DV_DULL
};

#define	wbflush()	mips_sync()

bus_addr_t	bonito_pa_to_device(paddr_t);
paddr_t		bonito_device_to_pa(bus_addr_t);

void	 bonito_intr_makemasks(void);
uint32_t bonito_intr_2e(uint32_t, struct trapframe *);
uint32_t bonito_intr_2f(uint32_t, struct trapframe *);
void	 bonito_intr_dispatch(uint64_t, int, struct trapframe *);

void	 bonito_attach_hook(struct device *, struct device *,
	    struct pcibus_attach_args *);
int	 bonito_bus_maxdevs(void *, int);
pcitag_t bonito_make_tag(void *, int, int, int);
void	 bonito_decompose_tag(void *, pcitag_t, int *, int *, int *);
int	 bonito_conf_size(void *, pcitag_t);
pcireg_t bonito_conf_read(void *, pcitag_t, int);
pcireg_t bonito_conf_read_internal(const struct bonito_config *, pcitag_t, int);
void	 bonito_conf_write(void *, pcitag_t, int, pcireg_t);
int	 bonito_pci_intr_map(struct pci_attach_args *, pci_intr_handle_t *);
const char *
	 bonito_pci_intr_string(void *, pci_intr_handle_t);
void	*bonito_pci_intr_establish(void *, pci_intr_handle_t, int,
	    int (*)(void *), void *, char *);
void	 bonito_pci_intr_disestablish(void *, void *);

int	 bonito_conf_addr(const struct bonito_config *, pcitag_t, int,
	    u_int32_t *, u_int32_t *);

void	 bonito_splx(int);

/*
 * Bonito interrupt handling declarations.
 * See <loongson/dev/bonito_irq.h> for details.
 */
struct intrhand *bonito_intrhand[BONITO_NINTS];
uint64_t bonito_intem;
uint64_t bonito_imask[NIPLS];

struct machine_bus_dma_tag bonito_bus_dma_tag = {
	._dmamap_create = _dmamap_create,
	._dmamap_destroy = _dmamap_destroy,
	._dmamap_load = _dmamap_load,
	._dmamap_load_mbuf = _dmamap_load_mbuf,
	._dmamap_load_uio = _dmamap_load_uio,
	._dmamap_load_raw = _dmamap_load_raw,
	._dmamap_load_buffer = _dmamap_load_buffer,
	._dmamap_unload = _dmamap_unload,
	._dmamap_sync = _dmamap_sync,

	._dmamem_alloc = _dmamem_alloc,
	._dmamem_free = _dmamem_free,
	._dmamem_map = _dmamem_map,
	._dmamem_unmap = _dmamem_unmap,
	._dmamem_mmap = _dmamem_mmap,

	._pa_to_device = bonito_pa_to_device,
	._device_to_pa = bonito_device_to_pa
};

int     bonito_io_map(bus_space_tag_t, bus_addr_t, bus_size_t, int,
	    bus_space_handle_t *);
int     bonito_mem_map(bus_space_tag_t, bus_addr_t, bus_size_t, int,
	    bus_space_handle_t *);

struct mips_bus_space bonito_pci_io_space_tag = {
	.bus_base = PHYS_TO_XKPHYS(BONITO_PCIIO_BASE, CCA_NC),
	._space_read_1 = generic_space_read_1,
	._space_write_1 = generic_space_write_1,
	._space_read_2 = generic_space_read_2,
	._space_write_2 = generic_space_write_2,
	._space_read_4 = generic_space_read_4,
	._space_write_4 = generic_space_write_4,
	._space_read_8 = generic_space_read_8,
	._space_write_8 = generic_space_write_8,
	._space_read_raw_2 = generic_space_read_raw_2,
	._space_write_raw_2 = generic_space_write_raw_2,
	._space_read_raw_4 = generic_space_read_raw_4,
	._space_write_raw_4 = generic_space_write_raw_4,
	._space_read_raw_8 = generic_space_read_raw_8,
	._space_write_raw_8 = generic_space_write_raw_8,
	._space_map = bonito_io_map,
	._space_unmap = generic_space_unmap,
	._space_subregion = generic_space_region,
	._space_vaddr = generic_space_vaddr,
	._space_mmap = generic_space_mmap
};

struct mips_bus_space bonito_pci_mem_space_tag = {
	.bus_base = PHYS_TO_XKPHYS(0, CCA_NC),
	._space_read_1 = generic_space_read_1,
	._space_write_1 = generic_space_write_1,
	._space_read_2 = generic_space_read_2,
	._space_write_2 = generic_space_write_2,
	._space_read_4 = generic_space_read_4,
	._space_write_4 = generic_space_write_4,
	._space_read_8 = generic_space_read_8,
	._space_write_8 = generic_space_write_8,
	._space_read_raw_2 = generic_space_read_raw_2,
	._space_write_raw_2 = generic_space_write_raw_2,
	._space_read_raw_4 = generic_space_read_raw_4,
	._space_write_raw_4 = generic_space_write_raw_4,
	._space_read_raw_8 = generic_space_read_raw_8,
	._space_write_raw_8 = generic_space_write_raw_8,
	._space_map = bonito_mem_map,
	._space_unmap = generic_space_unmap,
	._space_subregion = generic_space_region,
	._space_vaddr = generic_space_vaddr,
	._space_mmap = generic_space_mmap
};

int
bonito_match(struct device *parent, void *vcf, void *aux)
{
	struct mainbus_attach_args *maa = aux;

	if (loongson_ver >= 0x3a)
		return (0);

	if (strcmp(maa->maa_name, bonito_cd.cd_name) == 0)
		return (1);

	return (0);
}

void
bonito_attach(struct device *parent, struct device *self, void *aux)
{
	struct bonito_softc *sc = (struct bonito_softc *)self;
	struct pcibus_attach_args pba;
	pci_chipset_tag_t pc = &sc->sc_pc;
	const struct bonito_config *bc;
	uint32_t reg;

	/*
	 * Loongson 2F processors do not use a real Bonito64 chip but
	 * their own derivative, which is no longer 100% compatible.
	 * We need to make sure we never try to access an unimplemented
	 * register...
	 */
	if (loongson_ver >= 0x2f)
		sc->sc_compatible = 0;
	else
		sc->sc_compatible = 1;

	reg = PCI_REVISION(REGVAL(BONITO_PCI_REG(PCI_CLASS_REG)));
	if (sc->sc_compatible) {
		printf(": BONITO Memory and PCI controller, %s rev %d.%d\n",
		    BONITO_REV_FPGA(reg) ? "FPGA" : "ASIC",
		    BONITO_REV_MAJOR(reg), BONITO_REV_MINOR(reg));
	} else {
		printf(": memory and PCI-X controller, rev %d\n",
		    PCI_REVISION(REGVAL(BONITO_PCI_REG(PCI_CLASS_REG))));
	}

	bc = sys_platform->bonito_config;
	sc->sc_bonito = bc;
	SLIST_INIT(&sc->sc_hook);

#ifdef BONITO_DEBUG
	if (!sc->sc_compatible)
		printf("ISR4C: %08x\n", REGVAL(BONITO_PCI_REG(0x4c)));
	printf("PCIMAP: %08x\n", REGVAL(BONITO_PCIMAP));
	printf("MEMWIN: %08x.%08x - %08x.%08x\n",
	    REGVAL(BONITO_MEM_WIN_BASE_H), REGVAL(BONITO_MEM_WIN_BASE_L),
	    REGVAL(BONITO_MEM_WIN_MASK_H), REGVAL(BONITO_MEM_WIN_MASK_L));
	if (!sc->sc_compatible) {
		printf("HITSEL0: %08x.%08x\n",
		    REGVAL(LOONGSON_PCI_HIT0_SEL_H),
		    REGVAL(LOONGSON_PCI_HIT0_SEL_L));
		printf("HITSEL1: %08x.%08x\n",
		    REGVAL(LOONGSON_PCI_HIT1_SEL_H),
		    REGVAL(LOONGSON_PCI_HIT1_SEL_L));
		printf("HITSEL2: %08x.%08x\n",
		    REGVAL(LOONGSON_PCI_HIT2_SEL_H),
		    REGVAL(LOONGSON_PCI_HIT2_SEL_L));
	}
	printf("PCI BAR 0:%08x 1:%08x 2:%08x 3:%08x 4:%08x 5:%08x\n",
	    REGVAL(BONITO_PCI_REG(PCI_MAPREG_START + 0 * 4)),
	    REGVAL(BONITO_PCI_REG(PCI_MAPREG_START + 1 * 4)),
	    REGVAL(BONITO_PCI_REG(PCI_MAPREG_START + 2 * 4)),
	    REGVAL(BONITO_PCI_REG(PCI_MAPREG_START + 3 * 4)),
	    REGVAL(BONITO_PCI_REG(PCI_MAPREG_START + 4 * 4)),
	    REGVAL(BONITO_PCI_REG(PCI_MAPREG_START + 5 * 4)));
#endif

	/*
	 * Setup proper abitration.
	 */

	if (!sc->sc_compatible) {
		/*
		 * According to Linux, changing the value of this register
		 * ``avoids deadlock of PCI reading/writing lock operation''.
		 *
		 * Unfortunately, documentation for the Implementation
		 * Specific Registers (ISR40 to ISR5C) is only found in the
		 * chinese version of the Loongson 2F documentation.
		 *
		 * The particular bit we set here is ``mas_read_defer''.
		 */
		/* c2000001 -> d2000001 */
		REGVAL(BONITO_PCI_REG(0x4c)) |= 0x10000000;

		/* all pci devices may need to hold the bus */
		reg = REGVAL(LOONGSON_PXARB_CFG);
		reg &= ~LOONGSON_PXARB_RUDE_DEV_MSK;
		reg |= 0xfe << LOONGSON_PXARB_RUDE_DEV_SHFT;
		REGVAL(LOONGSON_PXARB_CFG) = reg;
		(void)REGVAL(LOONGSON_PXARB_CFG);
	}

	/*
	 * Setup interrupt handling.
	 */

	REGVAL(BONITO_GPIOIE) = bc->bc_gpioIE;
	REGVAL(BONITO_INTEDGE) = bc->bc_intEdge;
	if (sc->sc_compatible)
		REGVAL(BONITO_INTSTEER) = bc->bc_intSteer;
	REGVAL(BONITO_INTPOL) = bc->bc_intPol;

	REGVAL(BONITO_INTENCLR) = 0xffffffff;
	(void)REGVAL(BONITO_INTENCLR);
	
	if (sc->sc_compatible) {
		bonito_intem |= BONITO_INTRMASK_MASTERERR;
	}

	if (loongson_ver >= 0x2f)
		set_intr(INTPRI_BONITO, CR_INT_4, bonito_intr_2f);
	else
		set_intr(INTPRI_BONITO, CR_INT_0, bonito_intr_2e);
	register_splx_handler(bonito_splx);

	/*
	 * Attach PCI bus.
	 */

	pc->pc_conf_v = sc;
	pc->pc_attach_hook = bonito_attach_hook;
	pc->pc_bus_maxdevs = bonito_bus_maxdevs;
	pc->pc_make_tag = bonito_make_tag;
	pc->pc_decompose_tag = bonito_decompose_tag;
	pc->pc_conf_size = bonito_conf_size;
	pc->pc_conf_read = bonito_conf_read;
	pc->pc_conf_write = bonito_conf_write;

	pc->pc_intr_v = sc;
	pc->pc_intr_map = bonito_pci_intr_map;
	pc->pc_intr_string = bonito_pci_intr_string;
	pc->pc_intr_establish = bonito_pci_intr_establish;
	pc->pc_intr_disestablish = bonito_pci_intr_disestablish;

	bzero(&pba, sizeof pba);
	pba.pba_busname = "pci";
	pba.pba_iot = &bonito_pci_io_space_tag;
	pba.pba_memt = &bonito_pci_mem_space_tag;
	pba.pba_dmat = &bonito_bus_dma_tag;
	pba.pba_pc = pc;
	pba.pba_domain = pci_ndomains++;
	pba.pba_bus = 0;
#ifdef notyet
	pba.pba_ioex = bonito_get_resource_extent(pc, 1);
	pba.pba_memex = bonito_get_resource_extent(pc, 0);
#endif

	config_found(&sc->sc_dev, &pba, bonito_print);
}

bus_addr_t
bonito_pa_to_device(paddr_t pa)
{
	return pa ^ loongson_dma_base;
}

paddr_t
bonito_device_to_pa(bus_addr_t addr)
{
	return addr ^ loongson_dma_base;
}

int
bonito_print(void *aux, const char *pnp)
{
	struct pcibus_attach_args *pba = aux;

	if (pnp)
		printf("%s at %s", pba->pba_busname, pnp);
	printf(" bus %d", pba->pba_bus);

	return UNCONF;
}

/*
 * Bonito interrupt handling
 */

void *
bonito_intr_establish(int irq, int type, int level, int (*handler)(void *),
    void *arg, const char *name)
{
	struct intrhand **p, *q, *ih;
	int s;

#ifdef DIAGNOSTIC
	if (irq >= BONITO_NINTS || irq == BONITO_ISA_IRQ(2) || irq < 0)
		panic("bonito_intr_establish: illegal irq %d", irq);
#endif

	ih = malloc(sizeof *ih, M_DEVBUF, M_NOWAIT);
	if (ih == NULL)
		return NULL;

	ih->ih_next = NULL;
	ih->ih_fun = handler;
	ih->ih_arg = arg;
	ih->ih_level = level;
	ih->ih_irq = irq;
	evcount_attach(&ih->ih_count, name, &ih->ih_irq);

	s = splhigh();

	/*
	 * Figure out where to put the handler.
	 * This is O(N^2), but we want to preserve the order, and N is
	 * generally small.
	 */
	for (p = &bonito_intrhand[irq]; (q = *p) != NULL; p = &q->ih_next)
		;
	*p = ih;

	bonito_intem |= 1UL << irq;
	bonito_intr_makemasks();

	splx(s);	/* causes hw mask update */

	return (ih);
}

void
bonito_intr_disestablish(void *vih)
{
	struct intrhand *ih = (struct intrhand *)vih;
	struct intrhand **p, *q;
	int irq = ih->ih_irq;
	int s;

#ifdef DIAGNOSTIC
	if (irq >= BONITO_NINTS || irq == BONITO_ISA_IRQ(2) || irq < 0)
		panic("bonito_intr_disestablish: illegal irq %d", irq);
#endif

	s = splhigh();

	evcount_detach(&ih->ih_count);

	for (p = &bonito_intrhand[irq]; (q = *p) != NULL; p = &q->ih_next)
		if (q == ih)
			break;
#ifdef DIAGNOSTIC
	if (q == NULL)
		panic("bonito_intr_disestablish: never registered");
#endif
	*p = ih->ih_next;

	if (ih->ih_next == NULL && p == &bonito_intrhand[irq]) {
		bonito_intem &= ~(1UL << irq);
		bonito_intr_makemasks();
		/*
		 * No need to clear a bit in INTEN through INTCLR,
		 * splhigh() took care of disabling everything and
		 * splx() will not reenable this source after the
		 * mask update.
		 */
	}

	splx(s);

	free(ih, M_DEVBUF, sizeof *ih);
}

/*
 * Update interrupt masks. This is for designs without legacy PIC.
 */

void
bonito_splx(int newipl)
{
	struct cpu_info *ci = curcpu();

	/* Update masks to new ipl. Order highly important! */
	__asm__ (".set noreorder\n");
	ci->ci_ipl = newipl;
	mips_sync();
	__asm__ (".set reorder\n");
	bonito_setintrmask(newipl);
	/* If we still have softints pending trigger processing. */
	if (ci->ci_softpending != 0 && newipl < IPL_SOFTINT)
		setsoftintr0();
}

void
bonito_setintrmask(int level)
{
	uint64_t active;
	uint32_t clear, set;
	register_t sr;

	active = bonito_intem & ~bonito_imask[level];
	/* be sure to mask high bits, there may be other interrupt sources */
	clear = BONITO_DIRECT_MASK(bonito_imask[level]);
	set = BONITO_DIRECT_MASK(active);

	sr = disableintr();

	if (clear != 0) {
		REGVAL(BONITO_INTENCLR) = clear;
		(void)REGVAL(BONITO_INTENCLR);
	}
	if (set != 0) {
		REGVAL(BONITO_INTENSET) = set;
		(void)REGVAL(BONITO_INTENSET);
	}

	setsr(sr);
}

/*
 * Recompute interrupt masks.
 */
void
bonito_intr_makemasks()
{
	int irq, level;
	struct intrhand *q;
	uint intrlevel[BONITO_NINTS];

	/* First, figure out which levels each IRQ uses. */
	for (irq = 0; irq < BONITO_NINTS; irq++) {
		uint levels = 0;
		for (q = bonito_intrhand[irq]; q != NULL; q = q->ih_next)
			levels |= 1 << q->ih_level;
		intrlevel[irq] = levels;
	}

	/*
	 * Then figure out which IRQs use each level.
	 * Note that we make sure never to overwrite imask[IPL_HIGH], in
	 * case an interrupt occurs during intr_disestablish() and causes
	 * an unfortunate splx() while we are here recomputing the masks.
	 */
	for (level = IPL_NONE; level < IPL_HIGH; level++) {
		uint64_t irqs = 0;
		for (irq = 0; irq < BONITO_NINTS; irq++)
			if (intrlevel[irq] & (1 << level))
				irqs |= 1UL << irq;
		bonito_imask[level] = irqs;
	}

	/*
	 * There are tty, network and disk drivers that use free() at interrupt
	 * time, so vm > (tty | net | bio).
	 *
	 * Enforce a hierarchy that gives slow devices a better chance at not
	 * dropping data.
	 */
	bonito_imask[IPL_NET] |= bonito_imask[IPL_BIO];
	bonito_imask[IPL_TTY] |= bonito_imask[IPL_NET];
	bonito_imask[IPL_VM] |= bonito_imask[IPL_TTY];
	bonito_imask[IPL_CLOCK] |= bonito_imask[IPL_VM];

	/*
	 * These are pseudo-levels.
	 */
	bonito_imask[IPL_NONE] = 0;
	bonito_imask[IPL_HIGH] = -1UL;
}

/*
 * Process native interrupts
 */

uint32_t
bonito_intr_2e(uint32_t hwpend, struct trapframe *frame)
{
	uint64_t imr, isr, mask;

	isr = REGVAL(BONITO_INTISR);

	/*
	 * According to Linux code, Bonito64 - at least on Loongson
	 * systems - triggers an interrupt during DMA, which is to be
	 * ignored. Smells like a chip errata to me.
	 */
	while (ISSET(isr, BONITO_INTRMASK_MASTERERR)) {
		delay(1);
		isr = REGVAL(BONITO_INTISR);
	}

	isr &= BONITO_INTRMASK_GPIN;
	imr = REGVAL(BONITO_INTEN);
	isr &= imr;
#ifdef DEBUG
	printf("pci interrupt: imr %04x isr %04x\n", imr, isr);
#endif
	if (isr == 0)
		return 0;	/* not for us */

	/*
	 * Mask all pending interrupts.
	 */
	REGVAL(BONITO_INTENCLR) = isr;
	(void)REGVAL(BONITO_INTENCLR);

	/*
	 * If interrupts are spl-masked, mask them and wait for splx()
	 * to reenable them when necessary.
	 */
	if ((mask = isr & bonito_imask[frame->ipl]) != 0) {
		isr &= ~mask;
		imr &= ~mask;
	}

	/*
	 * Now process allowed interrupts.
	 */
	if (isr != 0) {
		bonito_intr_dispatch(isr, 30, frame);

		/*
		 * Reenable interrupts which have been serviced.
		 */
		REGVAL(BONITO_INTENSET) = imr;
		(void)REGVAL(BONITO_INTENSET);
	}

	return hwpend;
}

uint32_t
bonito_intr_2f(uint32_t hwpend, struct trapframe *frame)
{
	uint64_t imr, isr, mask;

	isr = REGVAL(BONITO_INTISR) & LOONGSON_INTRMASK_LVL4;
	imr = REGVAL(BONITO_INTEN);
	isr &= imr;
#ifdef DEBUG
	printf("pci interrupt: imr %04x isr %04x\n", imr, isr);
#endif
	if (isr == 0)
		return 0;	/* not for us */

	/*
	 * Mask all pending interrupts.
	 */
	REGVAL(BONITO_INTENCLR) = isr;
	(void)REGVAL(BONITO_INTENCLR);

	/*
	 * If interrupts are spl-masked, mask them and wait for splx()
	 * to reenable them when necessary.
	 */
	if ((mask = isr & bonito_imask[frame->ipl]) != 0) {
		isr &= ~mask;
		imr &= ~mask;
	}

	/*
	 * Now process allowed interrupts.
	 */
	if (isr != 0) {
		bonito_intr_dispatch(isr,
		    LOONGSON_INTR_DRAM_PARERR /* skip non-pci interrupts */,
		    frame);

		/*
		 * Reenable interrupts which have been serviced.
		 */
		REGVAL(BONITO_INTENSET) = imr;
		(void)REGVAL(BONITO_INTENSET);
	}

	return hwpend;
}

void
bonito_intr_dispatch(uint64_t isr, int startbit, struct trapframe *frame)
{
	int lvl, bitno;
	uint64_t tmpisr, mask;
	struct intrhand *ih;
	int rc;

	/* Service higher level interrupts first */
	for (lvl = IPL_HIGH - 1; lvl != IPL_NONE; lvl--) {
		tmpisr = isr & (bonito_imask[lvl] ^ bonito_imask[lvl - 1]);
		if (tmpisr == 0)
			continue;
		for (bitno = startbit, mask = 1UL << bitno; mask != 0;
		    bitno--, mask >>= 1) {
			if ((tmpisr & mask) == 0)
				continue;

			rc = 0;
			for (ih = bonito_intrhand[bitno]; ih != NULL;
			    ih = ih->ih_next) {
				splraise(ih->ih_level);
				if ((*ih->ih_fun)(ih->ih_arg) != 0) {
					rc = 1;
					ih->ih_count.ec_count++;
				}
				__asm__ (".set noreorder\n");
				curcpu()->ci_ipl = frame->ipl;
				mips_sync();
				__asm__ (".set reorder\n");
			}
			if (rc == 0) {
				printf("spurious interrupt %d\n", bitno);
#ifdef DEBUG
				printf("ISR %08x IMR %08x ipl %d mask %08x\n",
				    REGVAL(BONITO_INTISR), REGVAL(BONITO_INTEN),
				    frame->ipl, bonito_imask[frame->ipl]);
#ifdef DDB
				Debugger();
#endif
#endif
			}

			if ((isr ^= mask) == 0)
				return;
			if ((tmpisr ^= mask) == 0)
				break;
		}
	}
}

/*
 * various PCI helpers
 */

void
bonito_attach_hook(struct device *parent, struct device *self,
    struct pcibus_attach_args *pba)
{
	pci_chipset_tag_t pc = pba->pba_pc;
	struct bonito_softc *sc = pc->pc_conf_v;
	const struct bonito_config *bc = sc->sc_bonito;

	if (pba->pba_bus != 0)
		return;

	(*bc->bc_attach_hook)(pc);
}

/*
 * PCI configuration space access routines
 */

int
bonito_bus_maxdevs(void *v, int busno)
{
	struct bonito_softc *sc = v;
	const struct bonito_config *bc = sc->sc_bonito;

	return busno == 0 ? 32 - bc->bc_adbase : 32;
}

pcitag_t
bonito_make_tag(void *unused, int b, int d, int f)
{
	return (b << 16) | (d << 11) | (f << 8);
}

void
bonito_decompose_tag(void *unused, pcitag_t tag, int *bp, int *dp, int *fp)
{
	if (bp != NULL)
		*bp = (tag >> 16) & 0xff;
	if (dp != NULL)
		*dp = (tag >> 11) & 0x1f;
	if (fp != NULL)
		*fp = (tag >> 8) & 0x7;
}

int
bonito_conf_addr(const struct bonito_config *bc, pcitag_t tag, int offset,
    u_int32_t *cfgoff, u_int32_t *pcimap_cfg)
{
	int b, d, f;

	bonito_decompose_tag(NULL, tag, &b, &d, &f);

	if (b == 0) {
		d += bc->bc_adbase;
		if (d > 31)
			return 1;
		*cfgoff = (1 << d) | (f << 8) | offset;
		*pcimap_cfg = 0;
	} else {
		*cfgoff = tag | offset;
		*pcimap_cfg = BONITO_PCIMAPCFG_TYPE1;
	}

	return 0;
}

/* PCI Configuration Space access hook structure */
struct bonito_cfg_hook {
	SLIST_ENTRY(bonito_cfg_hook) next;
	int	(*read)(void *, pci_chipset_tag_t, pcitag_t, int, pcireg_t *);
	int	(*write)(void *, pci_chipset_tag_t, pcitag_t, int, pcireg_t);
	void	*cookie;
};

int
bonito_pci_hook(pci_chipset_tag_t pc, void *cookie,
    int (*r)(void *, pci_chipset_tag_t, pcitag_t, int, pcireg_t *),
    int (*w)(void *, pci_chipset_tag_t, pcitag_t, int, pcireg_t))
{
	struct bonito_softc *sc = pc->pc_conf_v;
	struct bonito_cfg_hook *bch;

	bch = malloc(sizeof *bch, M_DEVBUF, M_NOWAIT);
	if (bch == NULL)
		return ENOMEM;

	bch->read = r;
	bch->write = w;
	bch->cookie = cookie;
	SLIST_INSERT_HEAD(&sc->sc_hook, bch, next);
	return 0;
}

int
bonito_conf_size(void *v, pcitag_t tag)
{
	return PCI_CONFIG_SPACE_SIZE;
}

pcireg_t
bonito_conf_read(void *v, pcitag_t tag, int offset)
{
	struct bonito_softc *sc = v;
	struct bonito_cfg_hook *hook;
	pcireg_t data;

	SLIST_FOREACH(hook, &sc->sc_hook, next) {
		if (hook->read != NULL &&
		    (*hook->read)(hook->cookie, &sc->sc_pc, tag, offset,
		      &data) != 0)
			return data;
	}

	return bonito_conf_read_internal(sc->sc_bonito, tag, offset);
}

pcireg_t
bonito_conf_read_internal(const struct bonito_config *bc, pcitag_t tag,
    int offset)
{
	pcireg_t data;
	u_int32_t cfgoff, pcimap_cfg;
	register_t sr;
	uint64_t imr;

	if (bonito_conf_addr(bc, tag, offset, &cfgoff, &pcimap_cfg))
		return (pcireg_t)-1;

	sr = disableintr();
	imr = REGVAL(BONITO_INTEN);
	REGVAL(BONITO_INTENCLR) = 0xffffffff;
	(void)REGVAL(BONITO_INTENCLR);

	/* clear aborts */
	REGVAL(BONITO_PCI_REG(PCI_COMMAND_STATUS_REG)) |=
	    PCI_STATUS_MASTER_ABORT | PCI_STATUS_MASTER_TARGET_ABORT;

	/* high 16 bits of address go into PciMapCfg register */
	REGVAL(BONITO_PCIMAP_CFG) = (cfgoff >> 16) | pcimap_cfg;
	(void)REGVAL(BONITO_PCIMAP_CFG);
	wbflush();

	/* low 16 bits of address are offset into config space */
	data = REGVAL(BONITO_PCICFG_BASE + (cfgoff & 0xfffc));

	/* check for error */
	if (REGVAL(BONITO_PCI_REG(PCI_COMMAND_STATUS_REG)) &
	    (PCI_STATUS_MASTER_ABORT | PCI_STATUS_MASTER_TARGET_ABORT)) {
		REGVAL(BONITO_PCI_REG(PCI_COMMAND_STATUS_REG)) |=
		    PCI_STATUS_MASTER_ABORT | PCI_STATUS_MASTER_TARGET_ABORT;
		data = (pcireg_t) -1;
	}

	REGVAL(BONITO_INTENSET) = imr;
	(void)REGVAL(BONITO_INTENSET);
	setsr(sr);

	return data;
}

void
bonito_conf_write(void *v, pcitag_t tag, int offset, pcireg_t data)
{
	struct bonito_softc *sc = v;
	u_int32_t cfgoff, pcimap_cfg;
	struct bonito_cfg_hook *hook;
	register_t sr;
	uint64_t imr;

	SLIST_FOREACH(hook, &sc->sc_hook, next) {
		if (hook->write != NULL &&
		    (*hook->write)(hook->cookie, &sc->sc_pc, tag, offset,
		      data) != 0)
			return;
	}

	if (bonito_conf_addr(sc->sc_bonito, tag, offset, &cfgoff, &pcimap_cfg))
		panic("bonito_conf_write");

	sr = disableintr();
	imr = REGVAL(BONITO_INTEN);
	REGVAL(BONITO_INTENCLR) = 0xffffffff;
	(void)REGVAL(BONITO_INTENCLR);

	/* clear aborts */
	REGVAL(BONITO_PCI_REG(PCI_COMMAND_STATUS_REG)) |=
	    PCI_STATUS_MASTER_ABORT | PCI_STATUS_MASTER_TARGET_ABORT;

	/* high 16 bits of address go into PciMapCfg register */
	REGVAL(BONITO_PCIMAP_CFG) = (cfgoff >> 16) | pcimap_cfg;
	(void)REGVAL(BONITO_PCIMAP_CFG);
	wbflush();

	/* low 16 bits of address are offset into config space */
	REGVAL(BONITO_PCICFG_BASE + (cfgoff & 0xfffc)) = data;

	REGVAL(BONITO_INTENSET) = imr;
	(void)REGVAL(BONITO_INTENSET);
	setsr(sr);
}

/*
 * PCI Interrupt handling
 */

int
bonito_pci_intr_map(struct pci_attach_args *pa, pci_intr_handle_t *ihp)
{
	struct bonito_softc *sc = pa->pa_pc->pc_intr_v;
	const struct bonito_config *bc = sc->sc_bonito;
	int bus, dev, fn, pin;

	*ihp = (pci_intr_handle_t)-1;

	if (pa->pa_intrpin == 0)	/* no interrupt needed */
		return 1;

#ifdef DIAGNOSTIC
	if (pa->pa_intrpin > 4) {
		printf("%s: bad interrupt pin %d\n", __func__, pa->pa_intrpin);
		return 1;
	}
#endif

	pci_decompose_tag(pa->pa_pc, pa->pa_tag, &bus, &dev, &fn);
	if (pa->pa_bridgetag) {
		pin = PPB_INTERRUPT_SWIZZLE(pa->pa_rawintrpin, dev);
		*ihp = pa->pa_bridgeih[pin - 1];
	} else {
		if (bus == 0)
			*ihp = (*bc->bc_intr_map)(dev, fn, pa->pa_intrpin);

		if (*ihp == (pci_intr_handle_t)-1)
			return 1;
	}

	return 0;
}

const char *
bonito_pci_intr_string(void *cookie, pci_intr_handle_t ih)
{
	static char irqstr[1 + 12];

	if (BONITO_IRQ_IS_ISA(ih))
		snprintf(irqstr, sizeof irqstr, "isa irq %lu",
		    BONITO_IRQ_TO_ISA(ih));
	else
		snprintf(irqstr, sizeof irqstr, "irq %lu", ih);
	return irqstr;
}

void *
bonito_pci_intr_establish(void *cookie, pci_intr_handle_t ih, int level,
    int (*cb)(void *), void *cbarg, char *name)
{
	return bonito_intr_establish(ih, IST_LEVEL, level, cb, cbarg, name);
}

void
bonito_pci_intr_disestablish(void *cookie, void *ihp)
{
	bonito_intr_disestablish(ihp);
}

/*
 * bus_space mapping routines.
 */

/*
 * Legacy I/O access protection.
 * Since MI ISA code does not expect bus access to cause any failure when
 * accessing missing hardware, but only receive bogus data in return, we
 * force bus_space_map() to fail if there is no hardware there.
 */

int
bonito_io_map(bus_space_tag_t t, bus_addr_t offs, bus_size_t size, int flags,
    bus_space_handle_t *bshp)
{
	const struct legacy_io_range *r;
	bus_addr_t rend;

	if (offs < BONITO_PCIIO_LEGACY) {
		if ((r = sys_platform->legacy_io_ranges) == NULL)
			return ENXIO;

		rend = offs + size - 1;
		for (; r->start != 0; r++)
			if (offs >= r->start && rend <= r->end)
				break;

		if (r->end == 0)
			return ENXIO;
	}

	*bshp = t->bus_base + offs;
	return 0;
}

/*
 * PCI memory access.
 * Things are a bit complicated here, as we can either use one of the 64MB
 * windows in PCILO space (making sure ranges spanning multiple windows will
 * turn contiguous), or a direct access within the PCIHI space.
 * Note that, on 2F systems, only the PCIHI range for which CPU->PCI accesses
 * are enabled in the crossbar is usable.
 */

int
bonito_mem_map(bus_space_tag_t t, bus_addr_t offs, bus_size_t size, int flags,
    bus_space_handle_t *bshp)
{
	uint32_t pcimap;
	bus_addr_t pcilo_w[3];
	bus_addr_t ws, we, w;
	bus_addr_t end = offs + size - 1;
	int pcilo_window;

	pcimap = REGVAL(BONITO_PCIMAP);

	/*
	 * Try a PCIHI mapping first.
	 */

	if (loongson_ver >= 0x2f) {
		if (offs >= LS2F_PCIHI_BASE && end <= LS2F_PCIHI_TOP) {
			*bshp = t->bus_base + offs;
			return 0;
		}
	} else {
		/*
		 * Only try HI space if we do not have memory setup there.
		 */
		if (physmem <= atop(BONITO_PCILO_BASE)) {
			/* PCI1.5 */
			if (offs >= BONITO_PCIHI_BASE &&
			    end <= BONITO_PCIHI_TOP) {
				*bshp = t->bus_base + offs;
				return 0;
			}

			/* PCI2 */
			w = pcimap & BONITO_PCIMAP_PCIMAP_2 ? 0x80000000UL : 0;
			if (offs >= w && end < (w + 0x80000000UL)) {
				*bshp = t->bus_base + 0x80000000UL + (offs - w);
				return 0;
			}
		}
	}

	/*
	 * No luck, try a PCILO mapping.
	 */

	/*
	 * Decode PCIMAP, and figure out what PCILO mappings are
	 * possible.
	 */

	pcilo_w[0] = (pcimap & BONITO_PCIMAP_PCIMAP_LO0) >>
	    BONITO_PCIMAP_PCIMAP_LO0_SHIFT;
	pcilo_w[1] = (pcimap & BONITO_PCIMAP_PCIMAP_LO1) >>
	    BONITO_PCIMAP_PCIMAP_LO1_SHIFT;
	pcilo_w[2] = (pcimap & BONITO_PCIMAP_PCIMAP_LO2) >>
	    BONITO_PCIMAP_PCIMAP_LO2_SHIFT;

	/*
	 * Check if the 64MB areas we want to span are all available as
	 * contiguous PCILO mappings.
	 */

	ws = offs >> 26;
	we = end >> 26;

	pcilo_window = -1;
	if (ws == pcilo_w[0])
		pcilo_window = 0;
	else if (ws == pcilo_w[1])
		pcilo_window = 1;
	else if (ws == pcilo_w[2])
		pcilo_window = 2;

	if (pcilo_window >= 0) {
		/* contiguous area test */
		for (w = ws + 1; w <= we; w++) {
			if (pcilo_window + (w - ws) > 2 ||
			    w != pcilo_w[pcilo_window + (w - ws)]) {
				pcilo_window = -1;
				break;
			}
		}
	}

	if (pcilo_window >= 0) {
		*bshp = t->bus_base + BONITO_PCILO_BASE +
		    BONITO_PCIMAP_WINBASE(pcilo_window) +
		    BONITO_PCIMAP_WINOFFSET(offs);
		return 0;
	}

	return EINVAL;
}

/*
 * PCI resource handling
 */

struct extent *
bonito_get_resource_extent(pci_chipset_tag_t pc, int io)
{
	struct bonito_softc *sc = pc->pc_conf_v;
	struct extent *ex;
	char *exname;
	size_t exnamesz;
	uint32_t reg;
	int errors;

	exnamesz = 1 + 16 + 4;
	exname = (char *)malloc(exnamesz, M_DEVBUF, M_NOWAIT);
	if (exname == NULL)
		return NULL;
	snprintf(exname, exnamesz, "%s%s", sc->sc_dev.dv_xname,
	    io ? "_io" : "_mem");

	ex = extent_create(exname, 0, 0xffffffff, M_DEVBUF, NULL, 0,
	    EX_NOWAIT | EX_FILLED);
	if (ex == NULL)
		goto out;

	errors = 0;
	if (io) {
		/*
		 * Reserve the low 16KB of I/O space to the legacy hardware,
		 * if any.
		 */
		if (extent_free(ex, BONITO_PCIIO_LEGACY, BONITO_PCIIO_SIZE,
		    EX_NOWAIT) != 0)
			errors++;
	} else {
		reg = REGVAL(BONITO_PCIMAP);
		if (extent_free(ex,
		    BONITO_PCIMAP_WINBASE((reg & BONITO_PCIMAP_PCIMAP_LO0) >>
		      BONITO_PCIMAP_PCIMAP_LO0_SHIFT),
		    BONITO_PCIMAP_WINSIZE, EX_NOWAIT) != 0)
			errors++;
		if (extent_free(ex,
		    BONITO_PCIMAP_WINBASE((reg & BONITO_PCIMAP_PCIMAP_LO1) >>
		      BONITO_PCIMAP_PCIMAP_LO1_SHIFT),
		    BONITO_PCIMAP_WINSIZE, EX_NOWAIT) != 0)
			errors++;
		if (extent_free(ex,
		    BONITO_PCIMAP_WINBASE((reg & BONITO_PCIMAP_PCIMAP_LO2) >>
		      BONITO_PCIMAP_PCIMAP_LO2_SHIFT),
		    BONITO_PCIMAP_WINSIZE, EX_NOWAIT) != 0)
			errors++;

		if (sc->sc_compatible) {
			/* XXX make PCIMAP_HI available if PCIMAP_2 set */
		}
	}

	if (errors != 0) {
		extent_destroy(ex);
		ex = NULL;
	}

#ifdef BONITO_DEBUG
	extent_print(ex);
#endif

out:
	free(exname, M_DEVBUF, exnamesz);

	return ex;
}

/*
 * Functions used during early system configuration (before bonito attaches).
 */

pcitag_t bonito_make_tag_early(int, int, int);
pcireg_t bonito_conf_read_early(pcitag_t, int);

pcitag_t
bonito_make_tag_early(int b, int d, int f)
{
	return bonito_make_tag(NULL, b, d, f);
}

pcireg_t
bonito_conf_read_early(pcitag_t tag, int reg)
{
	return bonito_conf_read_internal(sys_platform->bonito_config, tag, reg);
}

void
bonito_early_setup()
{
	pci_make_tag_early = bonito_make_tag_early;
	pci_conf_read_early = bonito_conf_read_early;

	early_mem_t = &bonito_pci_mem_space_tag;
	early_io_t = &bonito_pci_io_space_tag;
}
@


1.30
log
@trivial "if(x) free(x)" replacement by "free(x)"

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bonito.c,v 1.29 2015/09/08 08:33:26 deraadt Exp $	*/
d98 3
a100 3
uint32_t bonito_intr_2e(uint32_t, struct trap_frame *);
uint32_t bonito_intr_2f(uint32_t, struct trap_frame *);
void	 bonito_intr_dispatch(uint64_t, int, struct trap_frame *);
d576 1
a576 1
bonito_intr_2e(uint32_t hwpend, struct trap_frame *frame)
d633 1
a633 1
bonito_intr_2f(uint32_t hwpend, struct trap_frame *frame)
d680 1
a680 1
bonito_intr_dispatch(uint64_t isr, int startbit, struct trap_frame *frame)
@


1.29
log
@sizes for free(); ok semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: bonito.c,v 1.28 2014/09/26 14:32:07 jsing Exp $	*/
d1206 1
a1206 2
	if (exname != NULL)
		free(exname, M_DEVBUF, exnamesz);
@


1.28
log
@Use correct format specifiers in various loongson machine dependent code.

Makes a loongson kernel buildable without -Wno-format.

ok miod@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bonito.c,v 1.27 2014/07/12 18:44:42 tedu Exp $	*/
d471 1
a471 1
	free(ih, M_DEVBUF, 0);
d1207 1
a1207 1
		free(exname, M_DEVBUF, 0);
@


1.27
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: bonito.c,v 1.26 2014/05/24 21:11:01 miod Exp $	*/
d979 1
a979 1
		snprintf(irqstr, sizeof irqstr, "isa irq %d",
d982 1
a982 1
		snprintf(irqstr, sizeof irqstr, "irq %d", ih);
@


1.26
log
@Provide bus_space_mmap()
@
text
@d1 1
a1 1
/*	$OpenBSD: bonito.c,v 1.25 2014/03/27 22:16:03 miod Exp $	*/
d471 1
a471 1
	free(ih, M_DEVBUF);
d1207 1
a1207 1
		free(exname, M_DEVBUF);
@


1.25
log
@Remove dependency from wscons_machdep upon bonito. Instead of hardcoding bonito
as the northbridge, have the per-platform early setup code register functions
providing access to the PCI configuration space, for the wscons code to walk the
PCI space in search of a graphics board.

No functional change yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: bonito.c,v 1.24 2013/08/25 08:18:05 miod Exp $	*/
d176 2
a177 1
	._space_vaddr = generic_space_vaddr
d199 2
a200 1
	._space_vaddr = generic_space_vaddr
d207 3
@


1.24
log
@In bonito_mem_map(), initialize pcimap earlier to make sure its value is not
tested before initialization; this would only affect 2e systems.

Found by Maxime Villard; reminded by mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bonito.c,v 1.23 2013/05/30 16:15:01 deraadt Exp $	*/
d1211 3
d1215 1
a1215 1
pci_make_tag_early(int b, int d, int f)
d1221 1
a1221 1
pci_conf_read_early(pcitag_t tag, int reg)
d1224 10
@


1.23
log
@Enforce ca_activate tree-walks over the entire heirarchy for all events,
cleaning up some shutdown-hook related code on the way.
(A few drivers related to sparc are still skipped at kettenis' request)
ok kettenis mlarkin, tested by many others too
@
text
@d1 1
a1 1
/*	$OpenBSD: bonito.c,v 1.22 2012/10/03 11:18:20 miod Exp $	*/
d1048 2
a1088 1
	pcimap = REGVAL(BONITO_PCIMAP);
@


1.22
log
@Split ever-growing mips <machine/cpu.h> into what 99% of the kernel needs,
which will remain in <machine/cpu.h>, and a new mips_cpu.h containing only the
goriest md details, which are only of interest to a handful set of files; this
is similar in spirit to what alpha does, but here <machine/cpu.h> does not
include the new file.
@
text
@d1 1
a1 1
/*	$OpenBSD: bonito.c,v 1.21 2012/09/29 19:24:30 miod Exp $	*/
d85 1
a85 2
	sizeof(struct bonito_softc), bonito_match, bonito_attach,
	NULL, config_activate_children
@


1.21
log
@Handle the coprocessor 0 cause and status registers as a 64 bit value now,
as some odd mips designs need moro than 32 bits in there. This causes a lot
of mechanical changes everywhere getsr() is used.
@
text
@d1 1
a1 1
/*	$OpenBSD: bonito.c,v 1.20 2012/09/29 18:54:36 miod Exp $	*/
d63 1
@


1.20
log
@Proide a mips_sync() macro to wrap asm("sync"), and replace gazillions of
such statements with it.
@
text
@d1 1
a1 1
/*	$OpenBSD: bonito.c,v 1.19 2011/03/31 20:37:44 miod Exp $	*/
d494 1
a494 1
	uint32_t sr;
d851 1
a851 1
	uint32_t sr;
d895 1
a895 1
	uint32_t sr;
@


1.19
log
@Recognize Loongson 3A processors, but don't accept to run on them yet, the
cache routines are not ready. This is mostly low-hanging fruit.
@
text
@d1 1
a1 1
/*	$OpenBSD: bonito.c,v 1.18 2010/12/04 17:06:31 miod Exp $	*/
d62 1
d92 1
a92 1
#define	wbflush()	__asm__ __volatile__ ("sync" ::: "memory")
d481 2
a482 1
	__asm__ ("sync\n\t.set reorder\n");
d702 2
a703 1
				__asm__ ("sync\n\t.set reorder\n");
@


1.18
log
@Introduce a new pci routine, pci_conf_size(), which returns the size of a
given pcitag_t configuration address space. Currently, all pci controllers
will return the usual 0x100 bytes of PCI configuration space, but this will
eventually change on PCIe-capable controlers.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bonito.c,v 1.17 2010/09/20 06:33:48 matthew Exp $	*/
d226 1
a226 1
	if (loongson_ver == 0x2f)
d315 1
a315 1
	if (loongson_ver == 0x2f)
d1049 1
a1049 1
	if (loongson_ver == 0x2f) {
@


1.17
log
@Get rid of evcount's support for arranging counters in a tree
hierarchy.  Everything attached to a single root node anyway, so at
best we had a bush.

"i think it is good" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bonito.c,v 1.16 2010/08/31 10:24:46 pirofti Exp $	*/
d106 1
d330 1
d817 6
@


1.16
log
@WIP suspend/resume support for loongson lemote. Okay miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: bonito.c,v 1.15 2010/07/18 13:36:13 miod Exp $	*/
d403 1
a403 1
	evcount_attach(&ih->ih_count, name, (void *)&ih->ih_irq, &evcount_intr);
@


1.15
log
@Repair Gdium support.
@
text
@d1 1
a1 1
/*	$OpenBSD: bonito.c,v 1.14 2010/05/08 21:59:56 miod Exp $	*/
d83 2
a84 1
	sizeof(struct bonito_softc), bonito_match, bonito_attach
@


1.14
log
@Huge work-in-progress commit to support Loongson 2E-based evaluation boards
with a VIA 686 southbridge.

Features:
- 686 setup code (no thanks to PMON for not initializing the beast).
- work in progress ISA interrupt handling code.
- support for vga(4) compatible devices as console, in PC-compatible text mode.
- move legacy (ISA) support code out of bonito(4) to make things clearer.
- support more than 256MB on 2E-based systems.

Tested on a generic 2E-based evaluation board by someone who wishes to remain
anonymous; you know who you are, thank you very much for testing.
@
text
@d1 1
a1 1
/*	$OpenBSD: bonito.c,v 1.13 2010/03/02 20:53:12 miod Exp $	*/
d998 1
d1001 6
a1006 3
		size--;
		for (r = sys_platform->legacy_io_ranges; r->start != 0; r++)
			if (offs >= r->start && offs + size <= r->end)
@


1.13
log
@Actually prefer PCIHI mappings to PCILO mappings, as the early console code
attempts to map resources without bothering to know their size. I should
probably be more careful and do the BAR dance to get the BAR size, but then
at this point we are reusing mappings set up by PMON, and it's ok to trust it.

This would only have ever become an issue with a framebuffer larger than 64MB
mapped at PCIHI with a PCILO mapping overlapping the first few 64MB anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: bonito.c,v 1.12 2010/02/28 21:35:41 miod Exp $	*/
a52 4
/*
 * XXX The legacy interrupt scheme is entangled and as many parts as
 * XXX possible should move to pcib.c...
 */
a59 2
#include <mips64/archtype.h>

a68 3
#include <dev/isa/isareg.h>
#include <dev/isa/isavar.h>

d73 2
d83 1
a83 2
	sizeof(struct bonito_softc),
	bonito_match, bonito_attach
d96 3
a98 1
uint32_t bonito_intr(uint32_t, struct trap_frame *);
a118 9
void	 bonito_setintrmask(int);

uint	 loongson_get_isa_imr(void);
uint	 loongson_get_isa_isr(void);
void	 loongson_set_isa_imr(uint);
void	 loongson_isa_specific_eoi(int);
uint32_t loongson_isa_intr(uint32_t, struct trap_frame *);
void	 loongson_isa_splx(int);
void	 loongson_isa_setintrmask(int);
a127 2
uint	loongson_isaimr;

d224 1
a224 2
	if (curcpu()->ci_hw.type == MIPS_LOONGSON2 &&
	    (curcpu()->ci_hw.c0prid & 0xff) == 0x2f - 0x2c)
d309 2
a310 8
	if (bc->bc_legacy_pic) {
		set_intr(INTPRI_BONITO, CR_INT_4, bonito_intr);
		set_intr(INTPRI_ISA, CR_INT_0, loongson_isa_intr);
		loongson_isaimr = loongson_get_isa_imr();
		register_splx_handler(loongson_isa_splx);
	} else {
		set_intr(INTPRI_BONITO, CR_INT_4, bonito_intr);
		register_splx_handler(bonito_splx);
d313 6
d424 1
a424 1
bonito_intr_disestablish(void *ih)
d426 37
a462 2
	/* XXX */
	panic("%s not implemented", __func__);
d492 3
a494 3
	/* don't bother masking high bits, there are no isa interrupt sources */
	clear = bonito_imask[level];
	set = active;
d498 1
a498 1
	if (clear != 0)
d500 3
a502 1
	if (set != 0)
d504 2
a505 1
	(void)REGVAL(BONITO_INTENSET);
d566 58
a623 1
bonito_intr(uint32_t hwpend, struct trap_frame *frame)
a625 3
	int bit;
	struct intrhand *ih;
	int rc;
d655 3
a657 33
		int lvl, bitno;
		uint64_t tmpisr;

		/* Service higher level interrupts first */
		bit = LOONGSON_INTR_DRAM_PARERR; /* skip non-pci interrupts */
		for (lvl = IPL_HIGH - 1; lvl != IPL_NONE; lvl--) {
			tmpisr = isr & (bonito_imask[lvl] ^ bonito_imask[lvl - 1]);
			if (tmpisr == 0)
				continue;
			for (bitno = bit, mask = 1UL << bitno; mask != 0;
			    bitno--, mask >>= 1) {
				if ((tmpisr & mask) == 0)
					continue;

				rc = 0;
				for (ih = bonito_intrhand[bitno]; ih != NULL;
				    ih = ih->ih_next) {
					if ((*ih->ih_fun)(ih->ih_arg) != 0) {
						rc = 1;
						ih->ih_count.ec_count++;
					}
				}
				if (rc == 0)
					printf("spurious interrupt %d\n",
					    bitno);

				if ((isr ^= mask) == 0)
					goto done;
				if ((tmpisr ^= mask) == 0)
					break;
			}
		}
done:
d669 50
d929 1
a929 1
	*ihp = -1;
d949 1
a949 1
		if (*ihp < 0)
d963 1
a963 1
		    ih - BONITO_NDIRECT);
d983 1
a983 9
 * Legacy (ISA) interrupt handling
 */

/*
 * Process legacy interrupts.
 *
 * XXX ISA interrupts only occur on LOONGSON_INTR_INT0, but since the other
 * XXX LOONGSON_INTR_INT# are unmaskable, bad things will happen if they
 * XXX are triggered...
a986 213
 * Interrupt dispatcher.
 */
uint32_t
loongson_isa_intr(uint32_t hwpend, struct trap_frame *frame)
{
	uint64_t imr, isr, mask;
	int bit;
	struct intrhand *ih;
	int rc;

	isr = loongson_get_isa_isr();
	imr = loongson_get_isa_imr();

	isr &= imr;
	isr &= ~(1 << 2);	/* cascade */
#ifdef DEBUG
	printf("isa interrupt: imr %04x isr %04x\n", imr, isr);
#endif
	if (isr == 0)
		return 0;	/* not for us */

	/*
	 * Mask all pending interrupts.
	 */

	loongson_set_isa_imr(imr & ~isr);

	/*
	 * If interrupts are spl-masked, mask them and wait for splx()
	 * to reenable them when necessary.
	 */
	if ((mask = isr & (BONITO_ISA_MASK(bonito_imask[frame->ipl]))) != 0) {
		isr &= ~mask;
		imr &= ~mask;
	}

	/*
	 * Now process allowed interrupts.
	 */
	if (isr != 0) {
		int lvl, bitno;
		uint64_t tmpisr;

		/* Service higher level interrupts first */
		bit = BONITO_NISA - 1;
		for (lvl = IPL_HIGH - 1; lvl != IPL_NONE; lvl--) {
			tmpisr = isr & BONITO_ISA_MASK(bonito_imask[lvl] ^
			    bonito_imask[lvl - 1]);
			if (tmpisr == 0)
				continue;
			for (bitno = bit, mask = 1UL << bitno; mask != 0;
			    bitno--, mask >>= 1) {
				if ((tmpisr & mask) == 0)
					continue;

				rc = 0;
				for (ih = bonito_intrhand[BONITO_ISA_IRQ(bitno)];
				    ih != NULL; ih = ih->ih_next) {
					if ((*ih->ih_fun)(ih->ih_arg) != 0) {
						rc = 1;
						ih->ih_count.ec_count++;
					}
				}
				if (rc == 0)
					printf("spurious isa interrupt %d\n",
					    bitno);

				loongson_isa_specific_eoi(bitno);

				if ((isr ^= mask) == 0)
					goto done;
				if ((tmpisr ^= mask) == 0)
					break;
			}
		}
done:

		/*
		 * Reenable interrupts which have been serviced.
		 */
		loongson_set_isa_imr(imr);
	}

	return hwpend;
}

#define	REGVAL8(x)	*((volatile u_int8_t *)PHYS_TO_XKPHYS(x, CCA_NC))

uint
loongson_get_isa_imr()
{
	uint imr1, imr2;

	imr1 = 0xff & ~REGVAL8(BONITO_PCIIO_BASE + IO_ICU1 + 1);
	imr1 &= ~(1 << 2);	/* hide cascade */
	imr2 = 0xff & ~REGVAL8(BONITO_PCIIO_BASE + IO_ICU2 + 1);

	return (imr2 << 8) | imr1;
}

uint
loongson_get_isa_isr()
{
	uint isr1, isr2;

	isr1 = 0xff & REGVAL8(BONITO_PCIIO_BASE + IO_ICU1);
	isr2 = 0xff & REGVAL8(BONITO_PCIIO_BASE + IO_ICU2);

	return (isr2 << 8) | isr1;
}

void
loongson_set_isa_imr(uint newimr)
{
	uint imr1, imr2;

	imr1 = 0xff & ~newimr;
	imr1 &= ~(1 << 2);	/* enable cascade */
	imr2 = 0xff & ~(newimr >> 8);

	/*
	 * For some reason, trying to write the same value to the PIC
	 * registers causes an immediate system freeze, so we only do
	 * this if the value changes.
	 * Note that interrupts have been disabled by the caller.
	 */
	if ((newimr ^ loongson_isaimr) & 0xff00) {
		REGVAL8(BONITO_PCIIO_BASE + IO_ICU2 + 1) = imr2;
		(void)REGVAL8(BONITO_PCIIO_BASE + IO_ICU2 + 1);
	}
	if ((newimr ^ loongson_isaimr) & 0x00ff) {
		REGVAL8(BONITO_PCIIO_BASE + IO_ICU1 + 1) = imr1;
		(void)REGVAL8(BONITO_PCIIO_BASE + IO_ICU1 + 1);
	}
	loongson_isaimr = newimr;
}

void
loongson_isa_specific_eoi(int bit)
{
	if (bit & 8) {
		REGVAL8(BONITO_PCIIO_BASE + IO_ICU2 + 0) = 0x60 | (bit & 7);
		(void)REGVAL8(BONITO_PCIIO_BASE + IO_ICU2 + 0);
		bit = 2;
	}
	REGVAL8(BONITO_PCIIO_BASE + IO_ICU1 + 0) = 0x60 | bit;
	(void)REGVAL8(BONITO_PCIIO_BASE + IO_ICU1 + 0);
}

/*
 * Update interrupt masks. This is for designs with legacy PIC.
 */

void
loongson_isa_splx(int newipl)
{
	struct cpu_info *ci = curcpu();

	/* Update masks to new ipl. Order highly important! */
	__asm__ (".set noreorder\n");
	ci->ci_ipl = newipl;
	__asm__ ("sync\n\t.set reorder\n");
	loongson_isa_setintrmask(newipl);
	/* If we still have softints pending trigger processing. */
	if (ci->ci_softpending != 0 && newipl < IPL_SOFTINT)
		setsoftintr0();
}

void
loongson_isa_setintrmask(int level)
{
	uint64_t active;
	uint32_t clear, set;
	uint32_t sr;

	active = bonito_intem & ~bonito_imask[level];
	clear = BONITO_DIRECT_MASK(bonito_imask[level]);
	set = BONITO_DIRECT_MASK(active);

	sr = disableintr();

	if (clear != 0)
		REGVAL(BONITO_INTENCLR) = clear;
	if (set != 0)
		REGVAL(BONITO_INTENSET) = set;
	(void)REGVAL(BONITO_INTENSET);

	loongson_set_isa_imr(BONITO_ISA_MASK(active));

	setsr(sr);
}

void
isa_attach_hook(struct device *parent, struct device *self,
    struct isabus_attach_args *iba)
{
}

void *
isa_intr_establish(isa_chipset_tag_t ic, int irq, int type, int level,
    int (*handler)(void *), void *arg, char *name)
{
	return bonito_intr_establish(BONITO_ISA_IRQ(irq), type, level,
	    handler, arg, name);
}

void
isa_intr_disestablish(void *v, void *ih)
{
	bonito_intr_disestablish(ih);
}

/*
d1005 1
a1005 1
		if (r->start == 0)
d1030 1
a1030 1
	int is2f, pcilo_window;
d1036 1
a1036 8
	/* may be used before curcpu() points to valid data */
	if ((cp0_get_prid() & 0xffff) ==
	    ((MIPS_LOONGSON2 << 8) | (0x2f - 0x2c)))
		is2f = 1;
	else
		is2f = 0;

	if (is2f) {
d1042 10
a1051 5
		/* PCI1.5 */
		if (offs >= BONITO_PCIHI_BASE && end <= BONITO_PCIHI_TOP) {
			*bshp = t->bus_base + offs;
			return 0;
		}
d1053 6
a1058 5
		/* PCI2 */
		w = pcimap & BONITO_PCIMAP_PCIMAP_2 ? 0x80000000UL : 0;
		if (offs >= w && end < (w + 0x80000000UL)) {
			*bshp = t->bus_base + 0x80000000UL + (offs - w);
			return 0;
@


1.12
log
@A better bus_space_map() function for bonito PCI memory space, which no
longers assumes all requested mappings fit in the three 64MB PCILO windows,
but will instead check whether the requested mappings can be provided by
PCILO regions or PCIHI regions (and on 2F-based systems, making sure we
only use addresses which get properly routed from CPU to PCI within the
2F crossbar).

This in turn requires early console code to abide the bus_space rules and
get its resources from bus_space_map() rather than doing PCI BAR arithmetic
by itself.

No functional change on Lemote Yeeloong and Gdium Liberty; on Lemote Fuloong
2F this allows BAR set up in PCIHI space by PMON to be mapped by kernel code
without having to compensate for the PCILO offset.
@
text
@d1 1
a1 1
/*	$OpenBSD: bonito.c,v 1.11 2010/02/24 22:33:20 miod Exp $	*/
d1160 35
a1238 31
	}

	/*
	 * No luck, try a PCIHI mapping.
	 */

	/* may be used before curcpu() points to valid data */
	if ((cp0_get_prid() & 0xffff) ==
	    ((MIPS_LOONGSON2 << 8) | (0x2f - 0x2c)))
		is2f = 1;
	else
		is2f = 0;

	if (is2f) {
		if (offs >= LS2F_PCIHI_BASE && end <= LS2F_PCIHI_TOP) {
			*bshp = t->bus_base + offs;
			return 0;
		}
	} else {
		/* PCI1.5 */
		if (offs >= BONITO_PCIHI_BASE && end <= BONITO_PCIHI_TOP) {
			*bshp = t->bus_base + offs;
			return 0;
		}

		/* PCI2 */
		w = pcimap & BONITO_PCIMAP_PCIMAP_2 ? 0x80000000UL : 0;
		if (offs >= w && end < (w + 0x80000000UL)) {
			*bshp = t->bus_base + 0x80000000UL + (offs - w);
			return 0;
		}
@


1.11
log
@Update comments: the bit we flip in ISR4C on LS2F systems is not undocumented,
but documentation for it only exists in Chinese. I still don't have the
slightest idea why flipping it is important, but I am more confident flipping
it now (-:
@
text
@d1 1
a1 1
/*	$OpenBSD: bonito.c,v 1.10 2010/02/12 08:14:02 miod Exp $	*/
d168 2
d194 1
a194 1
	.bus_base = PHYS_TO_XKPHYS(BONITO_PCILO_BASE, CCA_NC),
d209 1
a209 1
	._space_map = generic_space_map,
d1138 100
@


1.10
log
@Overhaul per-platform specific operation by moving all the differences into
per-platform structs or function pointers; therefore bonito(4) no longer needs
to know about particular systems.

While there, bring little bits of Fuloong 2F support, tested on otto@@'s
machine.
@
text
@d1 1
a1 1
/*	$OpenBSD: bonito.c,v 1.9 2010/02/10 21:09:40 miod Exp $	*/
d292 8
a299 5
		 * According to Linux, changing the value of this
		 * undocumented register ``avoids deadlock of PCI
		 * reading/writing lock operation''.
		 * Is this really necessary, and if so, does it
		 * matter on other designs?
@


1.9
log
@Blame the right interrupt bit in `spurious interrupt' messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: bonito.c,v 1.8 2010/02/09 21:31:46 miod Exp $	*/
d6 1
a6 1
 * Copyright (c) 2009 Miodrag Vallat.
d53 4
d82 4
a123 7
uint	 bonito_get_isa_imr(void);
uint	 bonito_get_isa_isr(void);
void	 bonito_set_isa_imr(uint);
void	 bonito_isa_specific_eoi(int);

uint32_t bonito_isa_intr(uint32_t, struct trap_frame *);

d127 7
a133 2
void	 bonito_isa_splx(int);
void	 bonito_isa_setintrmask(int);
d143 1
a143 2
#define	REGVAL8(x)	*((volatile u_int8_t *)PHYS_TO_XKPHYS(x, CCA_NC))
uint	bonito_isaimr;
d166 3
d185 1
a185 1
	._space_map = generic_space_map,
a230 1
	struct extent *ioex, *memex;
a231 1
	int real_bonito;
d241 1
a241 1
		real_bonito = 0;
d243 1
a243 1
		real_bonito = 1;
d246 1
a246 1
	if (real_bonito) {
d255 1
a255 1
	bc = sys_config.sys_bc;
d259 27
d290 10
a299 12
	if (!real_bonito) {
		if (sys_config.system_type == LOONGSON_YEELOONG) {
			/*
			 * According to Linux, changing the value of this
			 * undocumented register ``avoids deadlock of PCI
			 * reading/writing lock operation''.
			 * Is this really necessary, and if so, does it
			 * matter on other designs?
			 */
			REGVAL(BONITO_PCI_REG(0x4c)) =  0xd2000001;
							/* was c2000001 */
		}
d315 1
a315 1
	if (real_bonito)
d322 1
a322 2
	switch (sys_config.system_type) {
	case LOONGSON_YEELOONG:
d324 4
a327 5
		set_intr(INTPRI_ISA, CR_INT_0, bonito_isa_intr);
		bonito_isaimr = bonito_get_isa_imr();
		register_splx_handler(bonito_isa_splx);
		break;
	case LOONGSON_GDIUM:
a329 33
		break;
	default:
		/* we should have died way earlier */
		panic("missing interrupt configuration code for this system");
		break;
	}

	/*
	 * Setup PCI resource extents.
	 */

	ioex = extent_create("pciio", 0, 0xffffffff, M_DEVBUF, NULL, 0,
	    EX_NOWAIT | EX_FILLED);
	if (ioex != NULL)
		(void)extent_free(ioex, 0, BONITO_PCIIO_SIZE, EX_NOWAIT);

	memex = extent_create("pcimem", 0, 0xffffffff, M_DEVBUF, NULL, 0,
	    EX_NOWAIT | EX_FILLED);
	if (memex != NULL) {
		reg = REGVAL(BONITO_PCIMAP);
		(void)extent_free(memex, BONITO_PCIMAP_WINBASE((reg &
		    BONITO_PCIMAP_PCIMAP_LO0) >> BONITO_PCIMAP_PCIMAP_LO0_SHIFT),
		    BONITO_PCIMAP_WINSIZE, EX_NOWAIT);
		(void)extent_free(memex, BONITO_PCIMAP_WINBASE((reg &
		    BONITO_PCIMAP_PCIMAP_LO1) >> BONITO_PCIMAP_PCIMAP_LO1_SHIFT),
		    BONITO_PCIMAP_WINSIZE, EX_NOWAIT);
		(void)extent_free(memex, BONITO_PCIMAP_WINBASE((reg &
		    BONITO_PCIMAP_PCIMAP_LO2) >> BONITO_PCIMAP_PCIMAP_LO2_SHIFT),
		    BONITO_PCIMAP_WINSIZE, EX_NOWAIT);

		if (real_bonito) {
			/* XXX make PCIMAP_HI available if PCIMAP_2 set */
		}
d358 4
a361 2
	pba.pba_ioex = ioex;
	pba.pba_memex = memex;
d444 1
a444 2
 * Update interrupt masks. Two set of routines: one when ISA interrupts
 * are involved, one without.
a462 15
bonito_isa_splx(int newipl)
{
	struct cpu_info *ci = curcpu();

	/* Update masks to new ipl. Order highly important! */
	__asm__ (".set noreorder\n");
	ci->ci_ipl = newipl;
	__asm__ ("sync\n\t.set reorder\n");
	bonito_isa_setintrmask(newipl);
	/* If we still have softints pending trigger processing. */
	if (ci->ci_softpending != 0 && newipl < IPL_SOFTINT)
		setsoftintr0();
}

void
a484 24
void
bonito_isa_setintrmask(int level)
{
	uint64_t active;
	uint32_t clear, set;
	uint32_t sr;

	active = bonito_intem & ~bonito_imask[level];
	clear = BONITO_DIRECT_MASK(bonito_imask[level]);
	set = BONITO_DIRECT_MASK(active);

	sr = disableintr();

	if (clear != 0)
		REGVAL(BONITO_INTENCLR) = clear;
	if (set != 0)
		REGVAL(BONITO_INTENSET) = set;
	(void)REGVAL(BONITO_INTENSET);

	bonito_set_isa_imr(BONITO_ISA_MASK(active));

	setsr(sr);
}

d537 1
a537 1
 * Process direct interrupts
a620 95
 * Process ISA interrupts.
 *
 * XXX ISA interrupts only occur on LOONGSON_INTR_INT0, but since the other
 * XXX LOONGSON_INTR_INT# are unmaskable, bad things will happen if they
 * XXX are triggered...
 */

/*
 * Interrupt dispatcher.
 */
uint32_t
bonito_isa_intr(uint32_t hwpend, struct trap_frame *frame)
{
	uint64_t imr, isr, mask;
	int bit;
	struct intrhand *ih;
	int rc;

	isr = bonito_get_isa_isr();
	imr = bonito_get_isa_imr();

	isr &= imr;
	isr &= ~(1 << 2);	/* cascade */
#ifdef DEBUG
	printf("isa interrupt: imr %04x isr %04x\n", imr, isr);
#endif
	if (isr == 0)
		return 0;	/* not for us */

	/*
	 * Mask all pending interrupts.
	 */

	bonito_set_isa_imr(imr & ~isr);

	/*
	 * If interrupts are spl-masked, mask them and wait for splx()
	 * to reenable them when necessary.
	 */
	if ((mask = isr & (BONITO_ISA_MASK(bonito_imask[frame->ipl]))) != 0) {
		isr &= ~mask;
		imr &= ~mask;
	}

	/*
	 * Now process allowed interrupts.
	 */
	if (isr != 0) {
		int lvl, bitno;
		uint64_t tmpisr;

		/* Service higher level interrupts first */
		bit = BONITO_NISA - 1;
		for (lvl = IPL_HIGH - 1; lvl != IPL_NONE; lvl--) {
			tmpisr = isr & BONITO_ISA_MASK(bonito_imask[lvl] ^
			    bonito_imask[lvl - 1]);
			if (tmpisr == 0)
				continue;
			for (bitno = bit, mask = 1UL << bitno; mask != 0;
			    bitno--, mask >>= 1) {
				if ((tmpisr & mask) == 0)
					continue;

				rc = 0;
				for (ih = bonito_intrhand[BONITO_ISA_IRQ(bitno)];
				    ih != NULL; ih = ih->ih_next) {
					if ((*ih->ih_fun)(ih->ih_arg) != 0) {
						rc = 1;
						ih->ih_count.ec_count++;
					}
				}
				if (rc == 0)
					printf("spurious isa interrupt %d\n",
					    bitno);

				bonito_isa_specific_eoi(bitno);

				if ((isr ^= mask) == 0)
					goto done;
				if ((tmpisr ^= mask) == 0)
					break;
			}
		}
done:

		/*
		 * Reenable interrupts which have been serviced.
		 */
		bonito_set_isa_imr(imr);
	}

	return hwpend;
}

/*
d884 9
a892 1
 * ISA Interrupt handling
d895 89
d985 1
a985 1
bonito_get_isa_imr()
d997 1
a997 1
bonito_get_isa_isr()
d1008 1
a1008 1
bonito_set_isa_imr(uint newimr)
d1022 1
a1022 1
	if ((newimr ^ bonito_isaimr) & 0xff00) {
d1026 1
a1026 1
	if ((newimr ^ bonito_isaimr) & 0x00ff) {
d1030 1
a1030 1
	bonito_isaimr = newimr;
d1034 1
a1034 1
bonito_isa_specific_eoi(int bit)
d1045 43
d1109 101
d1222 1
a1222 1
	return bonito_conf_read_internal(sys_config.sys_bc, tag, reg);
@


1.8
log
@Make the bonito_pci_attach_hook per-platform, as a new callback in struct
bonito_config. Move the Geode initalization code previously found there
to yeeloong-specific code; and on Gdium, clear all the BAR of the internal
mini pci slot - it does not get initialized by PMON and the MI PCI code
complains about the bogus values it finds there on cold boots.
@
text
@d1 1
a1 1
/*	$OpenBSD: bonito.c,v 1.7 2010/02/05 20:53:24 miod Exp $	*/
d641 2
a642 1
					printf("spurious interrupt %d\n", bit);
d736 1
a736 1
					    bit);
@


1.7
log
@Add a set of functions to access PCI configuration space before bonito(4)
attaches, and use it to walk the PCI bus to figure out where the onboard
frame buffer device lies, if any; and get the frame buffer memory address
from reading the proper PCI BAR instead of hardcoding it; this should allow
the Gdium Liberty to configure its console correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: bonito.c,v 1.6 2010/02/05 20:51:22 miod Exp $	*/
a76 1
#include <loongson/dev/glxvar.h>
d765 2
a766 3
	pcireg_t id;
	pcitag_t tag;
	int dev;
d771 1
a771 14
	/*
	 * Check for an AMD CS5536 chip; if one is found, register
	 * the proper PCI configuration space hooks.
	 */

	for (dev = pci_bus_maxdevs(pc, pba->pba_bus); dev >= 0; dev--) {
		tag = pci_make_tag(pc, pba->pba_bus, dev, 0);
		id = pci_conf_read(pc, tag, PCI_ID_REG);
		if (id == PCI_ID_CODE(PCI_VENDOR_AMD,
		    PCI_PRODUCT_AMD_CS5536_PCISB)) {
			glx_init(pc, tag, dev);
			break;
		}
	}
@


1.6
log
@Blind support for the EMTEC Gdium Liberty netbook. Per-platform configuration
is moved to specific files, and a pointer to the key configuration structure
is now kept in struct sys_config.
bonito(4) interrupt handling is split, to allow PCI+Legacy interrupt systems
(Lemote Yeelong) and PCI-only Legacy-free systems (Gdium) to coexist
peacefully.
@
text
@d1 1
a1 1
/*	$OpenBSD: bonito.c,v 1.5 2010/02/05 20:47:15 miod Exp $	*/
d105 1
d114 2
a115 2
int	 bonito_conf_addr(struct bonito_softc *, pcitag_t, int, u_int32_t *,
	    u_int32_t *);
d803 1
a803 1
bonito_make_tag(void *v, int b, int d, int f)
d809 1
a809 1
bonito_decompose_tag(void *v, pcitag_t tag, int *bp, int *dp, int *fp)
d820 1
a820 1
bonito_conf_addr(struct bonito_softc *sc, pcitag_t tag, int offset,
d825 1
a825 1
	bonito_decompose_tag(sc, tag, &b, &d, &f);
d828 1
a828 1
		d += sc->sc_bonito->bc_adbase;
d872 1
a873 4
	u_int32_t cfgoff, pcimap_cfg;
	struct bonito_cfg_hook *hook;
	uint32_t sr;
	uint64_t imr;
d882 13
a894 1
	if (bonito_conf_addr(sc, tag, offset, &cfgoff, &pcimap_cfg))
d945 1
a945 1
	if (bonito_conf_addr(sc, tag, offset, &cfgoff, &pcimap_cfg))
d1117 16
@


1.5
log
@Compute and pass resource extents to the MI pci code when attaching pci@@bonito.
@
text
@d1 1
a1 1
/*	$OpenBSD: bonito.c,v 1.4 2010/01/31 19:12:12 miod Exp $	*/
d60 2
d76 1
a77 1
#include <loongson/dev/lemote_irq.h>
a96 1
void	 bonito_splx(int);
a97 2
uint32_t bonito_isa_intr(uint32_t, struct trap_frame *);
void	 bonito_setintrmask(int);
d121 8
d130 2
a131 6
 * Bonito interrupt handling declarations: on the Yeelong, we have 14
 * interrupts on Bonito, and 16 (well, 15) ISA interrupts with the usual
 * 8259 pair. Bonito and ISA interrupts happen on two different levels.
 *
 * For simplicity we allocate 16 vectors for direct interrupts, and 16
 * vectors for ISA interrupts as well.
a132 2

#define	BONITO_NINTS		(16 + 16)
a133 8

#define	BONITO_ISA_IRQ(i)	((i) + 16)
#define	BONITO_DIRECT_IRQ(i)	(i)
#define	BONITO_IRQ_IS_ISA(i)	((i) >= 16)

#define	INTPRI_BONITO	(INTPRI_CLOCK + 1)
#define	INTPRI_ISA	(INTPRI_BONITO + 1)

a215 11
const struct bonito_config yeelong_bonito = {
	.bc_adbase = 11,

	.bc_gpioIE = YEELONG_INTRMASK_GPIO,
	.bc_intEdge = YEELONG_INTRMASK_PCI_SYSERR | YEELONG_INTRMASK_PCI_PARERR,
	.bc_intSteer = 0,
	.bc_intPol = YEELONG_INTRMASK_DRAM_PARERR |
	    YEELONG_INTRMASK_PCI_SYSERR | YEELONG_INTRMASK_PCI_PARERR |
	    YEELONG_INTRMASK_INT0 | YEELONG_INTRMASK_INT1
};

d225 1
d227 11
a237 2
	printf(": memory and PCI-X controller, rev. %d\n",
	    PCI_REVISION(REGVAL(BONITO_PCI_REG(PCI_CLASS_REG))));
d239 9
a247 1
	bc = &yeelong_bonito;
d249 1
d257 12
a268 5
	/*
	 * according to linux, changing the value of this undocumented
	 * register ``avoids deadlock of PCI reading/writing lock operation''.
	 */
	REGVAL(BONITO_PCI_REG(0x4c)) =  0xd2000001; /* instead of c2000001 */
d270 7
a276 6
	/* all pci devices may need to hold the bus */
	reg = REGVAL(LOONGSON_PXARB_CFG);
	reg &= ~LOONGSON_PXARB_RUDE_DEV_MSK;
	reg |= 0xfe << LOONGSON_PXARB_RUDE_DEV_SHFT;
	REGVAL(LOONGSON_PXARB_CFG) = reg;
	(void)REGVAL(LOONGSON_PXARB_CFG);
d284 2
d287 1
d291 16
a306 5
	bonito_isaimr = bonito_get_isa_imr();

	set_intr(INTPRI_BONITO, CR_INT_4, bonito_intr);
	set_intr(INTPRI_ISA, CR_INT_0, bonito_isa_intr);
	register_splx_handler(bonito_splx);
d330 4
d445 5
d465 62
d590 1
a590 1
	isr = REGVAL(BONITO_INTISR) & YEELONG_INTRMASK_LVL4;
d622 1
a622 1
		bit = YEELONG_INTR_DRAM_PARERR;
d664 2
a665 2
 * XXX ISA interrupts only occur on YEELONG_INTR_INT0, but since the other
 * XXX YEELONG_INTR_INT# are unmaskable, bad things will happen if they
d701 1
a701 1
	if ((mask = isr & (bonito_imask[frame->ipl] >> 16)) != 0) {
d714 1
a714 1
		bit = 15;
d716 2
a717 2
			tmpisr = isr &
			    ((bonito_imask[lvl] ^ bonito_imask[lvl - 1]) >> 16);
d726 1
a726 1
				for (ih = bonito_intrhand[bitno + 16];
a755 25

void
bonito_setintrmask(int level)
{
	uint64_t active;
	uint32_t clear, set;
	uint32_t sr;

	active = bonito_intem & ~bonito_imask[level];
	clear = bonito_imask[level] & 0xffff;
	set = active & 0xffff;

	sr = disableintr();

	if (clear != 0)
		REGVAL(BONITO_INTENCLR) = clear;
	if (set != 0)
		REGVAL(BONITO_INTENSET) = set;
	(void)REGVAL(BONITO_INTENSET);

	bonito_set_isa_imr(active >> 16);

	setsr(sr);
}

d967 3
a969 1
	int dev, fn, pin;
d983 1
a983 1
	pci_decompose_tag(pa->pa_pc, pa->pa_tag, NULL, &dev, &fn);
d988 2
a989 33
		switch (dev) {
		/* onboard devices, only pin A is wired */
		case 6:
		case 7:
		case 8:
		case 9:
			if (pa->pa_intrpin == PCI_INTERRUPT_PIN_A)
				*ihp = BONITO_DIRECT_IRQ(YEELONG_INTR_PCIA +
				    (dev - 6));
			break;
		/* PCI slot */
		case 10:
			*ihp = BONITO_DIRECT_IRQ(YEELONG_INTR_PCIA +
			    (pa->pa_intrpin - PCI_INTERRUPT_PIN_A));
			break;
		/* Geode chip */
		case 14:
			switch (fn) {
			case 1:	/* Flash */
				*ihp = BONITO_ISA_IRQ(6);
				break;
			case 2:	/* AC97 */
				*ihp = BONITO_ISA_IRQ(9);
				break;
			case 4:	/* OHCI */
			case 5:	/* EHCI */
				*ihp = BONITO_ISA_IRQ(11);
				break;
			}
			break;
		default:
			break;
		}
d1004 2
a1005 1
		snprintf(irqstr, sizeof irqstr, "isa irq %d", ih - 16);
d1060 6
a1065 1
	/* interrupts have been disabled by the caller */
@


1.4
log
@According to Linux, some magic programming is necessary to prevent deadlocks,
so do the same magic ourselves too.
@
text
@d1 1
a1 1
/*	$OpenBSD: bonito.c,v 1.3 2010/01/26 05:35:55 miod Exp $	*/
d57 2
d241 1
d286 24
d335 2
a336 2
	/* XXX setup extents: I/O is only BONITO_PCIIO_SIZE long, memory is
	  BONITO_PCILO_SIZE and BONITO_PCIHI_SIZE */
@


1.3
log
@Be a bit more paranoid and disable interrupts around critical pieces of code,
such as isa interrupt mask change.
While there, use the same constructs to work around write posting when
updating bonito interrupt masks.
@
text
@d1 1
a1 1
/*	$OpenBSD: bonito.c,v 1.2 2010/01/22 21:45:22 miod Exp $	*/
d239 1
a239 1
	pcireg_t rev;
d241 2
a242 5
	rev = PCI_REVISION(REGVAL(BONITO_PCICLASS));

	printf(": memory and PCI controller, %s rev. %d.%d\n",
	    BONITO_REV_FPGA(rev) ? "FPGA" : "ASIC",
	    BONITO_REV_MAJOR(rev), BONITO_REV_MINOR(rev));
d250 17
a271 1
	REGVAL(BONITO_INTSTEER) = 0;
d273 1
a273 1
	REGVAL(BONITO_INTENCLR) = -1L;
a274 1
	wbflush();
d472 3
a477 3
#ifdef DEBUG
	printf("pci interrupt: imr %04x isr %04x\n", imr, isr);
#endif
a482 1
	wbflush();
d522 2
a523 1
				isr ^= mask;
d528 1
a534 1
		wbflush();
d618 2
a619 1
				isr ^= mask;
d624 1
d639 2
a640 1
	uint64_t active = bonito_intem & ~bonito_imask[level];
d643 4
d648 5
a652 2
	REGVAL(BONITO_INTENCLR) = bonito_imask[level] & 0xffff;
	REGVAL(BONITO_INTENSET) = active & 0xffff;
d654 1
a654 1
	wbflush();
d656 1
d793 1
a793 1
	REGVAL(BONITO_INTENCLR) = -1L;
a794 1
	wbflush();
d797 1
a797 1
	REGVAL(BONITO_PCICMD) |=
d809 1
a809 1
	if (REGVAL(BONITO_PCICMD) &
d811 1
a811 1
		REGVAL(BONITO_PCICMD) |=
a817 1
	wbflush();
d844 1
a844 1
	REGVAL(BONITO_INTENCLR) = -1L;
a845 1
	wbflush();
d848 1
a848 1
	REGVAL(BONITO_PCICMD) |=
a860 1
	wbflush();
d955 4
@


1.2
log
@Move is_memory_range() from mips64 mem.c to a per-architecture location; this
allows /dev/kmem to access the 256MB alias of the low memory on loongson, which
in turns makes procmap(8) happy.
@
text
@d1 1
a1 1
/*	$OpenBSD: bonito.c,v 1.1.1.1 2009/12/25 22:09:45 miod Exp $	*/
d262 2
d471 1
d522 1
d626 1
d628 1
d632 1
d634 1
a672 4
/* Bonito systems are always single-processor, so this is sufficient. */
#define	PCI_CONF_LOCK(s)	(s) = splhigh()
#define	PCI_CONF_UNLOCK(s)	splx((s))

d753 1
a753 1
	u_int32_t cfgoff, dummy, pcimap_cfg;
d755 2
a756 1
	int s;
d768 5
a772 1
	PCI_CONF_LOCK(s);
d780 1
a780 1

a781 2
	/* Issue a read to make sure the write is posted */
	dummy = REGVAL(BONITO_PCIMAP_CFG);
d794 4
a797 1
	PCI_CONF_UNLOCK(s);
d806 1
a806 1
	u_int32_t cfgoff, dummy, pcimap_cfg;
d808 2
a809 1
	int s;
d821 5
a825 1
	PCI_CONF_LOCK(s);
d833 1
a833 1

a834 2
	/* Issue a read to make sure the write is posted */
	dummy = REGVAL(BONITO_PCIMAP_CFG);
d839 4
a842 1
	PCI_CONF_UNLOCK(s);
d969 1
d986 1
a986 1
		(void)REGVAL8(BONITO_PCIIO_BASE + IO_ICU1 + 0);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d303 1
a303 1
	return pa;
d309 1
a309 1
	return addr;
@


1.1.1.1
log
@By popular demand and peer pressure, check-in work in progress work to support
the Yeelong Lemote mips-based netbook. Kernel bits only for now, needs
polishing; most of this work done during h2k9 last month, although the
porting effort started earlier this year.
@
text
@@
