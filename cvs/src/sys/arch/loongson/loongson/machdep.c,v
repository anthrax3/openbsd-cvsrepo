head	1.74;
access;
symbols
	OPENBSD_6_1:1.74.0.2
	OPENBSD_6_1_BASE:1.74
	OPENBSD_6_0:1.64.0.2
	OPENBSD_6_0_BASE:1.64
	OPENBSD_5_9:1.63.0.2
	OPENBSD_5_9_BASE:1.63
	OPENBSD_5_8:1.63.0.4
	OPENBSD_5_8_BASE:1.63
	OPENBSD_5_7:1.61.0.2
	OPENBSD_5_7_BASE:1.61
	OPENBSD_5_6:1.58.0.4
	OPENBSD_5_6_BASE:1.58
	OPENBSD_5_5:1.43.0.4
	OPENBSD_5_5_BASE:1.43
	OPENBSD_5_4:1.42.0.2
	OPENBSD_5_4_BASE:1.42
	OPENBSD_5_3:1.41.0.2
	OPENBSD_5_3_BASE:1.41
	OPENBSD_5_2:1.35.0.2
	OPENBSD_5_2_BASE:1.35
	OPENBSD_5_1_BASE:1.33
	OPENBSD_5_1:1.33.0.4
	OPENBSD_5_0:1.33.0.2
	OPENBSD_5_0_BASE:1.33
	OPENBSD_4_9:1.24.0.2
	OPENBSD_4_9_BASE:1.24
	OPENBSD_4_8:1.22.0.2
	OPENBSD_4_8_BASE:1.22
	OPENBSD_4_7:1.17.0.2
	OPENBSD_4_7_BASE:1.17
	xmas_lemote:1.1.1.1
	miod:1.1.1;
locks; strict;
comment	@ * @;


1.74
date	2017.03.07.11.49.42;	author natano;	state Exp;
branches;
next	1.73;
commitid	qcVMvyIHDSrZgRKv;

1.73
date	2017.03.02.10.38.10;	author natano;	state Exp;
branches;
next	1.72;
commitid	EeVoCYFCx2tYicZQ;

1.72
date	2017.01.19.15.09.04;	author visa;	state Exp;
branches;
next	1.71;
commitid	8FHInuctPjWFPH6r;

1.71
date	2017.01.06.15.37.44;	author fcambus;	state Exp;
branches;
next	1.70;
commitid	0l7pHJQOGB2InAEV;

1.70
date	2016.12.16.12.01.19;	author fcambus;	state Exp;
branches;
next	1.69;
commitid	xLXMXiIz2IQcDoTA;

1.69
date	2016.12.11.07.57.14;	author visa;	state Exp;
branches;
next	1.68;
commitid	L2Mn0DF4e8j2GjWB;

1.68
date	2016.11.17.14.41.21;	author visa;	state Exp;
branches;
next	1.67;
commitid	zpQpluEsJrBQDh6U;

1.67
date	2016.10.09.11.25.39;	author tom;	state Exp;
branches;
next	1.66;
commitid	DfYvEDcFmu1LY9q1;

1.66
date	2016.09.28.14.03.19;	author visa;	state Exp;
branches;
next	1.65;
commitid	pWQz9jt9JOm7twWG;

1.65
date	2016.08.23.12.54.09;	author visa;	state Exp;
branches;
next	1.64;
commitid	AgitREJNEUua9aEN;

1.64
date	2016.03.06.19.42.27;	author mpi;	state Exp;
branches;
next	1.63;
commitid	cyYKarj4qRTft4gD;

1.63
date	2015.05.07.01.55.43;	author jsg;	state Exp;
branches;
next	1.62;
commitid	KhO2CJgSFKm4Q3Hj;

1.62
date	2015.05.05.02.13.46;	author guenther;	state Exp;
branches;
next	1.61;
commitid	dNPv28CJI5BxtRGW;

1.61
date	2014.12.10.15.29.53;	author mikeb;	state Exp;
branches;
next	1.60;
commitid	qHQiR2HLROzvZr7B;

1.60
date	2014.09.26.14.32.07;	author jsing;	state Exp;
branches;
next	1.59;
commitid	OvRx4Hf7atBtxEXK;

1.59
date	2014.09.20.09.28.24;	author kettenis;	state Exp;
branches;
next	1.58;
commitid	IFRB8AkvBMXMTAKW;

1.58
date	2014.07.21.17.25.47;	author uebayasi;	state Exp;
branches;
next	1.57;
commitid	7QO4UJr3EKVAMc8t;

1.57
date	2014.07.19.18.01.23;	author pirofti;	state Exp;
branches;
next	1.56;
commitid	U9MoL9J3tpANAtRh;

1.56
date	2014.07.13.22.53.39;	author uebayasi;	state Exp;
branches;
next	1.55;
commitid	wsdp3qtXGjMj98oD;

1.55
date	2014.07.13.22.13.06;	author uebayasi;	state Exp;
branches;
next	1.54;
commitid	qYPOd6Qi4aRBKldK;

1.54
date	2014.07.11.22.28.05;	author uebayasi;	state Exp;
branches;
next	1.53;
commitid	fOXKrBuMmlMGQdd4;

1.53
date	2014.07.10.21.46.03;	author mpi;	state Exp;
branches;
next	1.52;
commitid	iYq3Z1ZWDKR3sS9G;

1.52
date	2014.07.10.20.15.27;	author uebayasi;	state Exp;
branches;
next	1.51;
commitid	YzvTa4t6mddz7Mh4;

1.51
date	2014.07.10.13.34.32;	author uebayasi;	state Exp;
branches;
next	1.50;
commitid	xpsLTYRIkonFtkr1;

1.50
date	2014.07.10.12.13.49;	author uebayasi;	state Exp;
branches;
next	1.49;
commitid	aofvn6ceiucgjg4N;

1.49
date	2014.05.31.15.49.28;	author mpi;	state Exp;
branches;
next	1.48;
commitid	eA4Y0YE1IUzj6hpW;

1.48
date	2014.05.30.13.46.16;	author mpi;	state Exp;
branches;
next	1.47;

1.47
date	2014.04.03.08.07.16;	author mpi;	state Exp;
branches;
next	1.46;

1.46
date	2014.03.29.23.59.49;	author miod;	state Exp;
branches;
next	1.45;

1.45
date	2014.03.27.22.16.03;	author miod;	state Exp;
branches;
next	1.44;

1.44
date	2014.03.13.03.52.55;	author dlg;	state Exp;
branches;
next	1.43;

1.43
date	2013.09.28.12.40.30;	author miod;	state Exp;
branches;
next	1.42;

1.42
date	2013.06.02.21.46.04;	author pirofti;	state Exp;
branches;
next	1.41;

1.41
date	2013.01.15.23.30.36;	author pirofti;	state Exp;
branches;
next	1.40;

1.40
date	2013.01.14.21.18.47;	author pirofti;	state Exp;
branches;
next	1.39;

1.39
date	2012.10.08.21.47.48;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2012.10.03.21.44.51;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2012.10.03.11.18.23;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2012.09.29.19.11.06;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2012.03.25.13.52.52;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2012.03.15.18.57.20;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2011.07.21.20.36.12;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2011.06.26.22.39.59;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2011.06.24.19.47.48;	author naddy;	state Exp;
branches;
next	1.30;

1.30
date	2011.06.05.19.41.07;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2011.05.30.22.25.21;	author oga;	state Exp;
branches;
next	1.28;

1.28
date	2011.05.25.21.22.27;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2011.03.31.20.37.44;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2011.03.27.15.28.54;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2011.03.16.21.10.17;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2010.10.24.15.40.03;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2010.08.28.22.29.03;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2010.06.27.13.24.39;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2010.06.27.03.03.48;	author thib;	state Exp;
branches;
next	1.20;

1.20
date	2010.06.10.17.54.13;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2010.05.08.21.59.56;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2010.04.27.04.26.20;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2010.03.02.20.54.51;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2010.02.17.17.17.35;	author jasper;	state Exp;
branches;
next	1.15;

1.15
date	2010.02.14.22.39.33;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2010.02.12.19.39.27;	author otto;	state Exp;
branches;
next	1.13;

1.13
date	2010.02.12.19.37.31;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2010.02.12.08.14.02;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2010.02.09.21.30.11;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2010.02.09.19.24.08;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2010.02.05.20.51.22;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2010.02.04.16.41.16;	author otto;	state Exp;
branches;
next	1.7;

1.7
date	2010.02.03.21.46.42;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2010.02.01.05.38.09;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2010.02.01.05.23.21;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2010.01.31.15.29.59;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2010.01.09.23.34.29;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2010.01.09.20.33.16;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2009.12.25.22.06.03;	author miod;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2009.12.25.22.06.03;	author miod;	state Exp;
branches;
next	;


desc
@@


1.74
log
@Disallow setting machdep.lidaction to any other value but [0,2].

suggested by halex
ok deraadt millert
@
text
@/*	$OpenBSD: machdep.c,v 1.73 2017/03/02 10:38:10 natano Exp $ */

/*
 * Copyright (c) 2009, 2010, 2014 Miodrag Vallat.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
/*
 * Copyright (c) 2003-2004 Opsycon AB  (www.opsycon.se / www.opsycon.com)
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/proc.h>
#include <sys/buf.h>
#include <sys/reboot.h>
#include <sys/conf.h>
#include <sys/file.h>
#include <sys/msgbuf.h>
#include <sys/tty.h>
#include <sys/user.h>
#include <sys/exec.h>
#include <sys/sysctl.h>
#include <sys/mount.h>
#include <sys/syscallargs.h>
#include <sys/exec_elf.h>
#ifdef SYSVSHM
#include <sys/shm.h>
#endif
#ifdef SYSVSEM
#include <sys/sem.h>
#endif

#include <net/if.h>

#include <uvm/uvm_extern.h>

#include <machine/db_machdep.h>
#include <ddb/db_interface.h>

#include <machine/autoconf.h>
#include <mips64/cache.h>
#include <machine/cpu.h>
#include <mips64/mips_cpu.h>
#include <machine/memconf.h>
#include <machine/pmon.h>

#ifdef HIBERNATE
#include <machine/hibernate_var.h>
#endif /* HIBERNATE */

#include <dev/cons.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>

/* The following is used externally (sysctl_hw) */
char	machine[] = MACHINE;		/* Machine "architecture" */
char	cpu_model[30];
char	pmon_bootp[80];

/*
 * Even though the system is 64bit, 2E- and 2F-based hardware is constrained
 * to up to 2G of contigous physical memory (direct 2GB DMA area). 2Gq- and
 * 3A-based hardware only supports 32-bit DMA addresses, even though
 * physical memory may exist beyond 4GB.
 */
struct uvm_constraint_range  dma_constraint = { 0x0, 0xffffffffUL };
struct uvm_constraint_range *uvm_md_constraints[] = { NULL };

vm_map_t exec_map;
vm_map_t phys_map;

/*
 * safepri is a safe priority for sleep to set for a spin-wait
 * during autoconfiguration or after a panic.
 */
int   safepri = 0;

caddr_t	msgbufbase;

int	physmem;		/* Max supported memory, changes to actual. */
int	ncpu = 1;		/* At least one CPU in the system. */
int	nnodes = 1;		/* Number of NUMA nodes, only on 3A. */
struct	user *proc0paddr;
int	lid_action = 1;

#ifdef MULTIPROCESSOR
uint64_t cpu_spinup_a0;
uint64_t cpu_spinup_sp;
uint32_t ipi_mask;
#endif

const struct platform *sys_platform;
struct cpu_hwinfo bootcpu_hwinfo;
uint loongson_cpumask = 1;
uint loongson_ver;

/* Pointers to the start and end of the symbol table. */
caddr_t	ssym;
caddr_t	esym;
caddr_t	ekern;

struct phys_mem_desc mem_layout[MAXMEMSEGS];
paddr_t	loongson_memlo_alias;

pcitag_t (*pci_make_tag_early)(int, int, int);
pcireg_t (*pci_conf_read_early)(pcitag_t, int);
bus_space_tag_t early_mem_t;
bus_space_tag_t early_io_t;

static u_long atoi(const char *, uint);
static void dobootopts(int);

void	dumpsys(void);
void	dumpconf(void);
extern	void parsepmonbp(void);
const struct platform *loongson_identify(const char *, int);
vaddr_t	mips_init(uint64_t, uint64_t, uint64_t, uint64_t, char *);

extern	void htb_early_setup(void);

extern	void loongson2e_setup(u_long, u_long);
extern	void loongson2f_setup(u_long, u_long);
extern	void loongson3a_setup(u_long, u_long);

cons_decl(pmon);

struct consdev pmoncons = {
	NULL,
	NULL,
	pmoncngetc,
	pmoncnputc,
	nullcnpollc,
	NULL,
	makedev(0, 0),
	CN_DEAD
};

/*
 * List of supported system types, from the ``Version'' environment
 * variable.
 */

struct bonito_flavour {
	const char *prefix;
	const struct platform *platform;
};

extern const struct platform ebenton_platform;
extern const struct platform fuloong_platform;
extern const struct platform gdium_platform;
extern const struct platform generic2e_platform;
extern const struct platform lynloong_platform;
extern const struct platform rs780e_platform;
extern const struct platform yeeloong_platform;

const struct bonito_flavour bonito_flavours[] = {
#ifdef CPU_LOONGSON2
	/* eBenton EBT700 netbook */
	{ "EBT700",	&ebenton_platform },	/* prefix added by user */
	/* Lemote Fuloong 2F mini-PC */
	{ "LM6002",	&fuloong_platform },	/* dual Ethernet,
						   prefix added by user */
	{ "LM6003",	&fuloong_platform },
	{ "LM6004",	&fuloong_platform },
	/* EMTEC Gdium Liberty 1000 */
	{ "Gdium",	&gdium_platform },
	/* Lemote Yeeloong 8.9" netbook */
	{ "LM8089",	&yeeloong_platform },
	/* supposedly Lemote Yeeloong 10.1" netbook, but those found so far
	   report themselves as LM8089 */
	{ "LM8101",	&yeeloong_platform },
	/* Lemote Lynloong all-in-one computer */
	{ "LM9001",	&lynloong_platform },
#endif
#ifdef CPU_LOONGSON3
	/* Laptops */
	{ "A1004",	&rs780e_platform },	/* 3A */
	{ "A1201",	&rs780e_platform },	/* 2Gq */
	/* Lemote Xinghuo 6100 (mini-ITX PC) */
	{ "A1101",	&rs780e_platform },	/* 3A */
	/* All-in-one PC */
	{ "A1205",	&rs780e_platform },	/* 2Gq */
#endif
	{ NULL }
};

/*
 * Try to figure out what particular machine we run on, depending on the
 * scarce PMON version information and whatever else we can figure.
 */
const struct platform *
loongson_identify(const char *version, int envtype)
{
	const struct bonito_flavour *f;

	switch (envtype) {
#ifdef CPU_LOONGSON3
	case PMON_ENVTYPE_EFI:
		if (loongson_ver == 0x3a || loongson_ver == 0x3b) {
			pcitag_t tag;
			pcireg_t id;

			htb_early_setup();

			/* Determine platform by host bridge. */
			tag = pci_make_tag_early(0, 0, 0);
			id = pci_conf_read_early(tag, PCI_ID_REG);
			switch (id) {
			case PCI_ID_CODE(PCI_VENDOR_AMD,
			    PCI_PRODUCT_AMD_RS780_HB):
				return &rs780e_platform;
			}
		}
		pmon_printf("Unable to figure out model!\n");
		return NULL;
#endif

	default:
	case PMON_ENVTYPE_ENVP:
		if (version == NULL) {
#ifdef CPU_LOONGSON2
			/*
		 	 * If there is no `Version' variable, we expect to be
			 * running on a 2E system, use the generic code and
			 * hope for the best.
		 	 */
			if (loongson_ver == 0x2e)
				return &generic2e_platform;
#endif
			pmon_printf("Unable to figure out model!\n");
			return NULL;
		}

		for (f = bonito_flavours; f->prefix != NULL; f++)
			if (strncmp(version, f->prefix, strlen(f->prefix)) == 0)
				return f->platform;

#ifdef CPU_LOONGSON2
		/*
	 	 * Early Lemote designs shipped without a model prefix.
	 	 *
	 	 * We can reasonably expect these to be close enough to either
		 * the first generation Fuloong 2F design (LM6002), or the 7
		 * inch first netbook model; we can tell them apart by looking
		 * at which video chip they embed.
	 	 *
	 	 * Note that this is only worth doing if the version string is
	 	 * 1.2.something (1.3 onwards are expected to have a model
		 * prefix, and there are currently no reports of 1.1 and
	 	 * below being 2F systems).
	 	 *
	 	 * LM6002 users are encouraged to add the system model prefix to
	 	 * the `Version' variable.
	 	 */
		if (strncmp(version, "1.2.", 4) == 0) {
			const struct platform *p = NULL;
			pcitag_t tag;
			pcireg_t id, class;
			int dev;

			pmon_printf("No model prefix "
			    "in version string \"%s\".\n", version);

			if (loongson_ver == 0x2f)
				for (dev = 0; dev < 32; dev++) {
					tag = pci_make_tag_early(0, dev, 0);
					id = pci_conf_read_early(tag,
					    PCI_ID_REG);
					if (id == 0 || PCI_VENDOR(id) ==
					    PCI_VENDOR_INVALID)
						continue;

					/*
					 * No need to check for
					 * DEVICE_IS_VGA_PCI here, since we
					 * expect a linear framebuffer.
					 */
					class = pci_conf_read_early(tag,
					    PCI_CLASS_REG);
					if (PCI_CLASS(class) !=
					    PCI_CLASS_DISPLAY ||
					    (PCI_SUBCLASS(class) !=
					     PCI_SUBCLASS_DISPLAY_VGA &&
					     PCI_SUBCLASS(class) !=
					     PCI_SUBCLASS_DISPLAY_MISC))
						continue;

					switch (id) {
					case PCI_ID_CODE(PCI_VENDOR_SIS,
				    	    PCI_PRODUCT_SIS_315PRO_VGA):
						p = &fuloong_platform;
						break;
					case PCI_ID_CODE(PCI_VENDOR_SMI,
			    		    PCI_PRODUCT_SMI_SM712):
						p = &ebenton_platform;
						break;
					}
				}

			if (p != NULL) {
				pmon_printf("Attempting to match as "
				    "%s %s\n", p->vendor, p->product);
				return p;
			}
		}
#endif
	}

	pmon_printf("This kernel doesn't support model \"%s\"." "\n", version);
	return NULL;
}

/*
 * Figure out machine parameters using the 'EFI-like' interface.
 */
int
loongson_efi_setup(void)
{
	const struct pmon_env_cpu *cpuenv;
	const struct pmon_env_mem *mem;
	const struct pmon_env_mem_entry *entry;
	paddr_t fp, lp;
	uint32_t i, ncpus, seg = 0;

	cpuenv = pmon_get_env_cpu();
	bootcpu_hwinfo.clock = cpuenv->speed;

	/*
	 * Get available CPUs.
	 */

	ncpus = cpuenv->ncpus;
	if (ncpus > LOONGSON_MAXCPUS)
		ncpus = LOONGSON_MAXCPUS;

	loongson_cpumask = (1u << ncpus) - 1;
	loongson_cpumask &= ~(uint)cpuenv->reserved_cores;

	ncpusfound = 0;
	for (i = 0; i < ncpus; i++) {
		if (ISSET(loongson_cpumask, 1u << i))
			ncpusfound++;
	}

	/*
	 * Get free memory segments.
	 */

	mem = pmon_get_env_mem();
	physmem = 0;
	for (i = 0; i < mem->nentries && seg < MAXMEMSEGS; i++) {
		entry = &mem->mem_map[i];
		if (entry->node != 0 ||
		    (entry->type != PMON_MEM_SYSTEM_LOW &&
		     entry->type != PMON_MEM_SYSTEM_HIGH))
			continue;
		fp = atop(entry->address);
		lp = atop(entry->address + (entry->size << 20));
		if (lp > atop(pfn_to_pad(PG_FRAME)) + 1)
			lp = atop(pfn_to_pad(PG_FRAME)) + 1;
		if (fp >= lp)
			continue;
		physmem += lp - fp;
		mem_layout[seg].mem_first_page = fp;
		mem_layout[seg].mem_last_page = lp;
		seg++;
	}

	return 0;
}

/*
 * Figure out machine parameters using the PMON interface.
 */
int
loongson_envp_setup(void)
{
	const char *envvar;
	u_long cpuspeed, memlo, memhi;

	/*
	 * Figure out processor clock speed.
	 * Hopefully the processor speed, in Hertz, will not overflow
	 * uint32_t...
	 */

	cpuspeed = 0;
	envvar = pmon_getenv("cpuclock");
	if (envvar != NULL)
		cpuspeed = atoi(envvar, 10);	/* speed in Hz */
	if (cpuspeed < 100 * 1000000)
		cpuspeed = 797000000;  /* Reasonable default */
	bootcpu_hwinfo.clock = cpuspeed;

	/*
	 * Guess the available CPUs.
	 */

	switch (loongson_ver) {
#ifdef CPU_LOONGSON3
	case 0x3a:
		loongson_cpumask = 0x0f;
		ncpusfound = 4;
		break;
	case 0x3b:
		loongson_cpumask = 0xff;
		ncpusfound = 8;
		break;
#endif
	}

	/*
	 * Figure out memory information.
	 * PMON reports it in two chunks, the memory under the 256MB
	 * CKSEG limit, and memory above that limit.  We need to do the
	 * math ourselves.
	 */

	envvar = pmon_getenv("memsize");
	if (envvar == NULL) {
		pmon_printf("Could not get memory information"
		    " from the firmware\n");
		return -1;
	}
	memlo = atoi(envvar, 10);	/* size in MB */
	if (memlo < 0 || memlo > 256) {
		pmon_printf("Incorrect low memory size `%s'\n", envvar);
		return -1;
	}

	/* 3A PMON only reports up to 240MB as low memory */
	if (memlo >= 240) {
		envvar = pmon_getenv("highmemsize");
		if (envvar == NULL)
			memhi = 0;
		else
			memhi = atoi(envvar, 10);	/* size in MB */
		if (memhi < 0 || memhi > (64 * 1024) - 256) {
			pmon_printf("Incorrect high memory size `%s'\n",
			    envvar);
			/* better expose the problem than limit to 256MB */
			return -1;
		}
	} else
		memhi = 0;

	switch (loongson_ver) {
	default:
#ifdef CPU_LOONGSON2
	case 0x2e:
		loongson2e_setup(memlo, memhi);
		break;
	case 0x2f:
		loongson2f_setup(memlo, memhi);
		break;
#endif
#ifdef CPU_LOONGSON3
	case 0x3a:
		loongson3a_setup(memlo, memhi);
		break;
#endif
	}

	return 0;
}

/*
 * Do all the stuff that locore normally does before calling main().
 * Reset mapping and set up mapping to hardware and init "wired" reg.
 */

vaddr_t
mips_init(uint64_t argc, uint64_t argv, uint64_t envp, uint64_t cv,
    char *boot_esym)
{
	uint32_t prid;
	vaddr_t xtlb_handler;
	const char *envvar;
	int i;

	extern char start[], edata[], end[];
	extern char exception[], e_exception[];
	extern char *hw_vendor, *hw_prod;
	extern void xtlb_miss;

#ifdef MULTIPROCESSOR
	/*
	 * Set curcpu address on primary processor.
	 */
	setcurcpu(&cpu_info_primary);
#endif

	/*
	 * Make sure we can access the extended address space.
	 * This is not necessary on real hardware, but some emulators
	 * are not aware of this.
	 */
	setsr(getsr() | SR_KX | SR_UX);

	/*
	 * Clear the compiled BSS segment in OpenBSD code.
	 * PMON is supposed to have done this, though.
	 */

	bzero(edata, end - edata);

	/*
	 * Set up early console output.
	 */

	prid = cp0_get_prid();
	pmon_init((int32_t)argc, (int32_t)argv, (int32_t)envp, (int32_t)cv,
	    prid);
	cn_tab = &pmoncons;

	/*
	 * Reserve space for the symbol table, if it exists.
	 */

	/* Attempt to locate ELF header and symbol table after kernel. */
	if (end[0] == ELFMAG0 && end[1] == ELFMAG1 &&
	    end[2] == ELFMAG2 && end[3] == ELFMAG3) {
		/* ELF header exists directly after kernel. */
		ssym = end;
		esym = boot_esym;
		ekern = esym;
	} else {
		ssym = (char *)(vaddr_t)*(int32_t *)end;
		if (((long)ssym - (long)end) >= 0 &&
		    ((long)ssym - (long)end) <= 0x1000 &&
		    ssym[0] == ELFMAG0 && ssym[1] == ELFMAG1 &&
		    ssym[2] == ELFMAG2 && ssym[3] == ELFMAG3) {
			/* Pointers exist directly after kernel. */
			esym = (char *)(vaddr_t)*((int32_t *)end + 1);
			ekern = esym;
		} else {
			/* Pointers aren't setup either... */
			ssym = NULL;
			esym = NULL;
			ekern = end;
		}
	}

	/*
	 * While the kernel supports other processor types than Loongson,
	 * we are currently not expecting to run on a system with a
	 * different processor.  Just to be on the safe side, refuse to
	 * run on non-Loongson processors for now.
	 */

	switch ((prid >> 8) & 0xff) {
	case MIPS_LOONGSON2:
		switch (prid & 0xff) {
#ifdef CPU_LOONGSON2
#ifdef CPU_LOONGSON2C
		case 0x00:
			loongson_ver = 0x2c;
			break;
#endif
		case 0x02:
			loongson_ver = 0x2e;
			break;
		case 0x03:
			loongson_ver = 0x2f;
			break;
#endif
#ifdef CPU_LOONGSON3
		case 0x05:
			loongson_ver = 0x3a;
			break;
#endif
		default:
			break;
		}
	}
	if (loongson_ver == 0) {
		pmon_printf("This kernel doesn't support processor type 0x%x"
		    ", version %d.%d.\n",
		    (prid >> 8) & 0xff, (prid >> 4) & 0x0f, prid & 0x0f);
		goto unsupported;
	}

	/*
	 * Try and figure out what kind of hardware we are.
	 */

	switch (pmon_getenvtype()) {
	default:
		pmon_printf("Unable to figure out "
		    "firmware environment information!\n");
		goto unsupported;

	case PMON_ENVTYPE_EFI:
		break;

	case PMON_ENVTYPE_ENVP:
		envvar = pmon_getenv("systype");
		if (envvar == NULL) {
			pmon_printf("Unable to figure out system type!\n");
			goto unsupported;
		}
		if (strcmp(envvar, "Bonito") != 0) {
			pmon_printf("This kernel doesn't support system type \"%s\".\n",
		    	envvar);
			goto unsupported;
		}
	}

	/*
	 * Try to figure out what particular machine we run on, depending
	 * on the PMON version information.
	 */

	if ((sys_platform = loongson_identify(pmon_getenv("Version"),
	    pmon_getenvtype())) == NULL)
		goto unsupported;

	hw_vendor = sys_platform->vendor;
	hw_prod = sys_platform->product;
	pmon_printf("Found %s %s, setting up.\n", hw_vendor, hw_prod);

	snprintf(cpu_model, sizeof cpu_model, "Loongson %X", loongson_ver);

	/*
	 * Look at arguments passed to us and compute boothowto.
	 */

	boothowto = RB_AUTOBOOT;
	dobootopts(argc);

	switch (pmon_getenvtype()) {
	case PMON_ENVTYPE_EFI:
		if (loongson_efi_setup() != 0)
			goto unsupported;
		break;

	case PMON_ENVTYPE_ENVP:
		if (loongson_envp_setup() != 0)
			goto unsupported;
		break;
	}

	if (sys_platform->setup != NULL)
		(*(sys_platform->setup))();

	/*
	 * PMON functions should no longer be used from now on.
	 */

	/*
	 * Set pagesize to enable use of page macros and functions.
	 * Commit available memory to UVM system.
	 */

	uvmexp.pagesize = PAGE_SIZE;
	uvm_setpagesize();

	for (i = 0; i < MAXMEMSEGS && mem_layout[i].mem_last_page != 0; i++) {
		uint64_t fp, lp;
		uint64_t firstkernpage, lastkernpage;
		paddr_t firstkernpa, lastkernpa;

		/* kernel is linked in CKSEG0 */
		firstkernpa = CKSEG0_TO_PHYS((vaddr_t)start);
		lastkernpa = CKSEG0_TO_PHYS((vaddr_t)ekern);

		firstkernpage = atop(trunc_page(firstkernpa));
#ifdef HIBERNATE
		firstkernpage -= HIBERNATE_RESERVED_PAGES;
#endif
		lastkernpage = atop(round_page(lastkernpa));

		if (loongson_memlo_alias != 0) {
			firstkernpage += atop(loongson_memlo_alias);
			lastkernpage += atop(loongson_memlo_alias);
		}

		fp = mem_layout[i].mem_first_page;
		lp = mem_layout[i].mem_last_page;

		/* Account for kernel and kernel symbol table. */
		if (fp >= firstkernpage && lp < lastkernpage)
			continue;	/* In kernel. */

		if (lp < firstkernpage || fp > lastkernpage) {
			uvm_page_physload(fp, lp, fp, lp, 0);
			continue;	/* Outside kernel. */
		}

		if (fp >= firstkernpage)
			fp = lastkernpage;
		else if (lp < lastkernpage)
			lp = firstkernpage;
		else { /* Need to split! */
			uint64_t xp = firstkernpage;
			uvm_page_physload(fp, xp, fp, xp, 0);
			fp = lastkernpage;
		}
		if (lp > fp) {
			uvm_page_physload(fp, lp, fp, lp, 0);
		}
	}

	bootcpu_hwinfo.c0prid = prid;
	bootcpu_hwinfo.type = (prid >> 8) & 0xff;
	/* FPU reports itself as type 5, version 0.1... */
	bootcpu_hwinfo.c1prid = bootcpu_hwinfo.c0prid;

	/*
	 * Configure cache and tlb.
	 */

	switch (loongson_ver) {
	default:
#ifdef CPU_LOONGSON2
#ifdef CPU_LOONGSON2C
	case 0x2c:
#endif
	case 0x2e:
	case 0x2f:
		bootcpu_hwinfo.tlbsize = 64;
		Loongson2_ConfigCache(curcpu());
		Loongson2_SyncCache(curcpu());
		break;
#endif
#ifdef CPU_LOONGSON3
	case 0x3a:
		bootcpu_hwinfo.tlbsize =
		    1 + ((cp0_get_config_1() >> 25) & 0x3f);
		Loongson3_ConfigCache(curcpu());
		Loongson3_SyncCache(curcpu());
		break;
#endif
	}

	tlb_init(bootcpu_hwinfo.tlbsize);

	/*
	 * Get a console, very early but after initial mapping setup.
	 */

	consinit();
	printf("Initial setup done, switching console.\n");

	/*
	 * Init message buffer. This is similar to pmap_steal_memory(), but
	 * without zeroing the area, to keep the message buffer from the
	 * previous kernel run intact, if any.
	 */
	for (i = 0; i < vm_nphysseg; i++) {
		struct vm_physseg *vps = &vm_physmem[i];
		uint npg = atop(round_page(MSGBUFSIZE));
		int j;

		if (vps->avail_start != vps->start ||
		    vps->avail_start >= vps->avail_end) {
			continue;
		}

		if ((vps->avail_end - vps->avail_start) < npg)
			continue;

		msgbufbase = (caddr_t)PHYS_TO_XKPHYS(ptoa(vps->avail_start),
		    CCA_CACHED);
		vps->avail_start += npg;
		vps->start += npg;

		if (vps->avail_start == vps->end) {
			/* don't bother panicing if nphysseg becomes zero, */
			/* the next pmap_steal_memory() call will. */
			vm_nphysseg--;
			for (j = i; j < vm_nphysseg; j++)
				vm_physmem[j] = vm_physmem[j + 1];
		}

		break;
	}
	if (msgbufbase == NULL)
		panic("not enough contiguous memory for message buffer");
	initmsgbuf(msgbufbase, MSGBUFSIZE);

	/*
	 * Allocate U page(s) for proc[0], pm_tlbpid 1.
	 */

	proc0.p_addr = proc0paddr = curcpu()->ci_curprocpaddr =
	    (struct user *)pmap_steal_memory(USPACE, NULL, NULL);
	proc0.p_md.md_regs = (struct trapframe *)&proc0paddr->u_pcb.pcb_regs;
	tlb_set_pid(MIN_USER_ASID);

	/*
	 * Bootstrap VM system.
	 */

	pmap_bootstrap();

	/*
	 * Copy down exception vector code.
	 */

	bcopy(exception, (char *)CACHE_ERR_EXC_VEC, e_exception - exception);
	bcopy(exception, (char *)GEN_EXC_VEC, e_exception - exception);

	/*
	 * Build proper TLB refill handler trampolines.
	 *
	 * On Loongson 2F, the XTLB refill exception actually uses
	 * the TLB refill vector.
	 */

	xtlb_handler = (vaddr_t)&xtlb_miss;
	build_trampoline(TLB_MISS_EXC_VEC, xtlb_handler);
	build_trampoline(XTLB_MISS_EXC_VEC, xtlb_handler);

	/*
	 * Turn off bootstrap exception vectors.
	 * (this is done by PMON already, but it doesn't hurt to be safe)
	 */

	setsr(getsr() & ~SR_BOOT_EXC_VEC);
	proc0.p_md.md_regs->sr = getsr();

#ifdef DDB
	db_machine_init();
	if (boothowto & RB_KDB)
		Debugger();
#endif

	/*
	 * Return the new kernel stack pointer.
	 */

	return ((vaddr_t)proc0paddr + USPACE - 64);

unsupported:
	pmon_printf("Halting system.\nPress enter to return to PMON\n");
	cngetc();
	return 0;	/* causes us to return to pmon */
}

/*
 * Decode boot options.
 */
static void
dobootopts(int argc)
{
	const char *arg;
	const char *cp;
	int ignore = 1;
	int i;

	/*
	 * Parse the boot command line.
	 *
	 * It should be of the form `boot [flags] filename [args]', so we
	 * need to ignore flags to the boot command.
	 * To achieve this, we ignore argc[0], which is the `boot' command
	 * itself, and ignore arguments starting with dashes until the
	 * boot file has been found.
	 */

	if (argc != 0) {
		arg = pmon_getarg(0);
		if (arg == NULL)
			return;
		/* if `go', not `boot', then no path and command options */
		if (*arg == 'g')
			ignore = 0;
	}
	for (i = 1; i < argc; i++) {
		arg = pmon_getarg(i);
		if (arg == NULL)
			continue;

		/* device path */
		if (*arg == '/' || strncmp(arg, "tftp://", 7) == 0) {
			if (*pmon_bootp == '\0') {
				strlcpy(pmon_bootp, arg, sizeof pmon_bootp);
				parsepmonbp();
			}
			ignore = 0;	/* further options are for the kernel */
			continue;
		}

		/* not an option, or not a kernel option */
		if (*arg != '-' || ignore)
			continue;

		for (cp = arg + 1; *cp != '\0'; cp++)
			switch (*cp) {
			case '-':
				break;
			case 'a':
				boothowto |= RB_ASKNAME;
				break;
			case 'c':
				boothowto |= RB_CONFIG;
				break;
			case 'd':
				boothowto |= RB_KDB;
				break;
			case 's':
				boothowto |= RB_SINGLE;
				break;
			default:
				pmon_printf("unrecognized option `%c'", *cp);
				break;
			}
	}

	/*
	 * Consider parsing the `karg' environment variable here too?
	 */
}


/*
 * Console initialization: called early on from main, before vm init or startup.
 * Do enough configuration to choose and initialize a console.
 */
void
consinit()
{
	static int console_ok = 0;

	if (console_ok == 0) {
		cn_tab = NULL;
		cninit();
		console_ok = 1;
	}
}

/*
 * cpu_startup: allocate memory for variable-sized tables, initialize CPU, and
 * do auto-configuration.
 */
void
cpu_startup()
{
	vaddr_t minaddr, maxaddr;

	/*
	 * Good {morning,afternoon,evening,night}.
	 */
	printf(version);
	printf("real mem = %lu (%luMB)\n", ptoa((psize_t)physmem),
	    ptoa((psize_t)physmem)/1024/1024);

	/*
	 * Allocate a submap for exec arguments. This map effectively
	 * limits the number of processes exec'ing at any time.
	 */
	minaddr = vm_map_min(kernel_map);
	exec_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
	    16 * NCARGS, VM_MAP_PAGEABLE, FALSE, NULL);
	/* Allocate a submap for physio. */
	phys_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
	    VM_PHYS_SIZE, 0, FALSE, NULL);

	printf("avail mem = %lu (%luMB)\n", ptoa(uvmexp.free),
	    ptoa(uvmexp.free)/1024/1024);

	/*
	 * Set up buffers, so they can be used to read disk labels.
	 */
	bufinit();

	/*
	 * Configure the system.
	 */
	if (boothowto & RB_CONFIG) {
#ifdef BOOT_CONFIG
		user_config();
#else
		printf("kernel does not support -c; continuing..\n");
#endif
	}
}

/*
 * Machine dependent system variables.
 */
int
cpu_sysctl(int *name, u_int namelen, void *oldp, size_t *oldlenp, void *newp,
    size_t newlen, struct proc *p)
{
	int val, error;

	/* All sysctl names at this level are terminal. */
	if (namelen != 1)
		return ENOTDIR;		/* Overloaded */

	switch (name[0]) {
	case CPU_LIDSUSPEND:
	case CPU_LIDACTION:
		val = lid_action;
		error = sysctl_int(oldp, oldlenp, newp, newlen, &val);
		if (!error) {
			if (val < 0 || val > 2)
				error = EINVAL;
			else
				lid_action = val;
		}
		return error;
	default:
		return EOPNOTSUPP;
	}
}

int	waittime = -1;

__dead void
boot(int howto)
{
	if (curproc)
		savectx(curproc->p_addr, 0);

	if (cold) {
		if ((howto & RB_USERREQ) == 0)
			howto |= RB_HALT;
		goto haltsys;
	}

	boothowto = howto;
	if ((howto & RB_NOSYNC) == 0 && waittime < 0) {
		waittime = 0;
		vfs_shutdown();

		if ((howto & RB_TIMEBAD) == 0) {
			resettodr();
		} else {
			printf("WARNING: not updating battery clock\n");
		}
	}
	if_downall();

	uvm_shutdown();
	splhigh();
	cold = 1;

	if ((howto & RB_DUMP) != 0)
		dumpsys();

haltsys:
	pci_dopm = 0;
	config_suspend_all(DVACT_POWERDOWN);

	if ((howto & RB_HALT) != 0) {
		if ((howto & RB_POWERDOWN) != 0) {
			if (sys_platform->powerdown != NULL) {
				printf("System Power Down.\n");
				(*(sys_platform->powerdown))();
			} else {
				printf("System Power Down not supported,"
				    " halting system.\n");
			}
		} else
			printf("System Halt.\n");
	} else {
		void (*__reset)(void) = (void (*)(void))RESET_EXC_VEC;
		printf("System restart.\n");
		if (sys_platform->reset != NULL)
			(*(sys_platform->reset))();
		(void)disableintr();
		tlb_set_wired(0);
		tlb_flush(bootcpu_hwinfo.tlbsize);
		__reset();
	}

	for (;;)
		continue;
	/* NOTREACHED */
}

u_long	dumpmag = 0x8fca0101;	/* Magic number for savecore. */
int	dumpsize = 0;			/* Also for savecore. */
long	dumplo = 0;

void
dumpconf(void)
{
	int nblks;

	if (dumpdev == NODEV ||
	    (nblks = (bdevsw[major(dumpdev)].d_psize)(dumpdev)) == 0)
		return;
	if (nblks <= ctod(1))
		return;

	dumpsize = ptoa(physmem);
	if (dumpsize > atop(round_page(dbtob(nblks - dumplo))))
		dumpsize = atop(round_page(dbtob(nblks - dumplo)));
	else if (dumplo == 0)
		dumplo = nblks - btodb(ptoa(physmem));

	/*
	 * Don't dump on the first page in case the dump device includes a
	 * disk label.
	 */
	if (dumplo < btodb(PAGE_SIZE))
		dumplo = btodb(PAGE_SIZE);
}

void
dumpsys()
{
	/* XXX TBD */
}

/*
 * Convert an ASCII string into an integer.
 */
static u_long
atoi(const char *s, uint b)
{
	int c;
	uint base = b, d;
	int neg = 0;
	u_long val = 0;

	if (s == NULL || *s == '\0')
		return 0;

	/* Skip spaces if any. */
	do {
		c = *s++;
	} while (c == ' ' || c == '\t');

	/* Parse sign, allow more than one (compat). */
	while (c == '-') {
		neg = !neg;
		c = *s++;
	}

	/* Parse base specification, if any. */
	if (base == 0 && c == '0') {
		c = *s++;
		switch (c) {
		case 'X':
		case 'x':
			base = 16;
			c = *s++;
			break;
		case 'B':
		case 'b':
			base = 2;
			c = *s++;
			break;
		default:
			base = 8;
			break;
		}
	}

	/* Parse number proper. */
	for (;;) {
		if (c >= '0' && c <= '9')
			d = c - '0';
		else if (c >= 'a' && c <= 'z')
			d = c - 'a' + 10;
		else if (c >= 'A' && c <= 'Z')
			d = c - 'A' + 10;
		else
			break;
		if (d >= base)
			break;
		val *= base;
		val += d;
		c = *s++;
	}

	return neg ? -val : val;
}

/*
 * Early console through pmon routines.
 */

int
pmoncngetc(dev_t dev)
{
	/*
	 * PMON does not give us a getc routine.  So try to get a whole line
	 * and return it char by char, trying not to lose the \n.  Kind
	 * of ugly but should work.
	 *
	 * Note that one could theoretically use pmon_read(STDIN, &c, 1)
	 * but the value of STDIN within PMON is not a constant and there
	 * does not seem to be a way of letting us know which value to use.
	 */
	static char buf[1 + PMON_MAXLN];
	static char *bufpos = buf;
	int c;

	if (*bufpos == '\0') {
		bufpos = buf;
		if (pmon_gets(buf) == NULL) {
			/* either an empty line or EOF. assume the former */
			return (int)'\n';
		} else {
			/* put back the \n sign */
			buf[strlen(buf)] = '\n';
		}
	}

	c = (int)*bufpos++;
	if (bufpos - buf > PMON_MAXLN) {
		bufpos = buf;
		*bufpos = '\0';
	}

	return c;
}

void
pmoncnputc(dev_t dev, int c)
{
	if (c == '\n')
		pmon_printf("\n");
	else
		pmon_printf("%c", c);
}

#ifdef MULTIPROCESSOR

void
hw_cpu_hatch(struct cpu_info *ci)
{
	int s;

	/*
	 * Set curcpu address on this processor.
	 */
	setcurcpu(ci);

	tlb_init(ci->ci_hw.tlbsize);
	tlb_set_pid(0);

	/*
	 * Make sure we can access the extended address space.
	 */
	setsr(getsr() | SR_KX | SR_UX);

	/*
	 * Turn off bootstrap exception vectors.
	 */
	setsr(getsr() & ~SR_BOOT_EXC_VEC);

	/*
	 * Clear out the I and D caches.
	 */
	switch (loongson_ver) {
#ifdef CPU_LOONGSON3
	case 0x3a:
	case 0x3b:
		Loongson3_ConfigCache(ci);
		Loongson3_SyncCache(ci);
		break;
#endif
	default:
		panic("%s: unhandled Loongson version %x\n", __func__,
		    loongson_ver);
	}

	(*md_startclock)(ci);

	mips64_ipi_init();

	ncpus++;
	cpuset_add(&cpus_running, ci);

	spl0();
	(void)updateimask(0);

	SCHED_LOCK(s);
	cpu_switchto(NULL, sched_chooseproc());
}

void
hw_cpu_boot_secondary(struct cpu_info *ci)
{
	sys_platform->boot_secondary_cpu(ci);
}

int
hw_ipi_intr_establish(int (*func)(void *), u_long cpuid)
{
	if (sys_platform->ipi_establish != NULL)
		return sys_platform->ipi_establish(func, cpuid);
	else
		return 0;
}

void
hw_ipi_intr_set(u_long cpuid)
{
	sys_platform->ipi_set(cpuid);
}

void
hw_ipi_intr_clear(u_long cpuid)
{
	if (sys_platform->ipi_clear != NULL)
		sys_platform->ipi_clear(cpuid);
}

#endif /* MULTIPROCESSOR */
@


1.73
log
@Add a new sysctl machdep.lidaction. The sysctl works as follows:

machdep.lidaction=0	# do nothing
machdep.lidaction=1	# suspend
machdep.lidaction=2	# hibernate

lidsuspend is just an alias for lidaction, so if you change one, the
other one will have the same value. The plan is to remove
machdep.lidsuspend eventually when people have upgraded their
/ets/sysctl.conf.

discussed with deraadt, who came up with the new MIB name
no objections mlarkin
ok stsp halex jcs
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.72 2017/01/19 15:09:04 visa Exp $ */
d1022 2
d1031 9
a1039 1
		return sysctl_int(oldp, oldlenp, newp, newlen, &lid_action);
@


1.72
log
@Extend struct platform with MP control functions, and add bootstrap code
for secondary CPUs.

Discussed with miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.71 2017/01/06 15:37:44 fcambus Exp $ */
d119 1
a119 1
int	lid_suspend = 1;
d1028 2
a1029 1
		return sysctl_int(oldp, oldlenp, newp, newlen, &lid_suspend);
@


1.71
log
@Ansify cpu_sysctl() on mips64 platforms.

OK patrick@@, visa@@, jasper@@, mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.70 2016/12/16 12:01:19 fcambus Exp $ */
d121 6
d521 7
d1247 85
@


1.70
log
@Provide the "machdep.lidsuspend" sysctl on Loongson.

OK visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.69 2016/12/11 07:57:14 visa Exp $ */
d1006 2
a1007 8
cpu_sysctl(name, namelen, oldp, oldlenp, newp, newlen, p)
	int *name;
	u_int namelen;
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
	struct proc *p;
@


1.69
log
@Determine the available CPUs.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.68 2016/11/17 14:41:21 visa Exp $ */
d119 1
d1020 2
@


1.68
log
@Add drivers for PCI host bridge and built-in UARTs on Loongson 3A,
and put the pieces together by platform glue.

Feedback from miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.67 2016/10/09 11:25:39 tom Exp $ */
d122 1
d347 1
d351 1
a351 1
	uint32_t i, seg = 0;
d353 23
a375 1
	bootcpu_hwinfo.clock = pmon_get_env_cpu()->speed;
d422 17
@


1.67
log
@Apply consistency to forever loops with continue and NOTREACHED

Same thought from kettenis@@, ok krw@@ phessler@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.66 2016/09/28 14:03:19 visa Exp $ */
d117 1
d146 2
a178 1
extern const struct platform lemote3a_platform;
d180 1
d204 2
a205 2
	{ "A1004",	&lemote3a_platform },	/* 3A */
	{ "A1201",	&lemote3a_platform },	/* 2Gq */
d207 1
a207 1
	{ "A1101",	&lemote3a_platform },	/* 3A */
d209 1
a209 1
	{ "A1205",	&lemote3a_platform },	/* 2Gq */
d226 17
a242 1
		return &lemote3a_platform;
@


1.66
log
@Add logic for figuring out CPU clock rate and usable memory areas
by using Loongson EFI.

Regression testing on Loongson 2F by fcambus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.65 2016/08/23 12:54:09 visa Exp $ */
d1024 2
a1025 1
	for (;;) ;
@


1.65
log
@The TLB refill and XTLB refill exceptions use distinct exception vectors
on Loongson 3A. Consequently, the kernel has to set up both vectors to
prevent panics with virtual address references.

On Loongson 2F, it is enough to set up the TLB refill vector because
the XTLB refill exception uses the same vector address.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.64 2016/03/06 19:42:27 mpi Exp $ */
d129 1
d221 1
d223 2
a224 2
		return NULL;
		break;
d229 1
d235 1
a235 1
			if (loongson_ver == 0x2e) {
d237 3
a239 4
			} else {
				pmon_printf("Unable to figure out model!\n");
				return NULL;
			}
d246 1
d314 1
d321 113
a444 1
	u_long memlo, memhi, cpuspeed;
d509 1
a509 1
	 * run on non-Loongson2 processors for now.
a554 4
		/*
		 * We can reasonably expect to be running on a beast we can
		 * tame, here.
		 */
a585 14
	 * Figure out processor clock speed.
	 * Hopefully the processor speed, in Hertz, will not overflow
	 * uint32_t...
	 */

	cpuspeed = 0;
	envvar = pmon_getenv("cpuclock");
	if (envvar != NULL)
		cpuspeed = atoi(envvar, 10);	/* speed in Hz */
	if (cpuspeed < 100 * 1000000)
		cpuspeed = 797000000;  /* Reasonable default */
	bootcpu_hwinfo.clock = cpuspeed;

	/*
d592 5
a596 6
	/*
	 * Figure out memory information.
	 * PMON reports it in two chunks, the memory under the 256MB
	 * CKSEG limit, and memory above that limit.  We need to do the
	 * math ourselves.
	 */
d598 2
a599 23
	envvar = pmon_getenv("memsize");
	if (envvar == NULL) {
		pmon_printf("Could not get memory information"
		    " from the firmware\n");
		goto unsupported;
	}
	memlo = atoi(envvar, 10);	/* size in MB */
	if (memlo < 0 || memlo > 256) {
		pmon_printf("Incorrect low memory size `%s'\n", envvar);
		goto unsupported;
	}

	/* 3A PMON only reports up to 240MB as low memory */
	if (memlo >= 240) {
		envvar = pmon_getenv("highmemsize");
		if (envvar == NULL)
			memhi = 0;
		else
			memhi = atoi(envvar, 10);	/* size in MB */
		if (memhi < 0 || memhi > (64 * 1024) - 256) {
			pmon_printf("Incorrect high memory size `%s'\n",
			    envvar);
			/* better expose the problem than limit to 256MB */
a600 9
		}
	} else
		memhi = 0;

	switch (loongson_ver) {
	default:
#ifdef CPU_LOONGSON2
	case 0x2e:
		loongson2e_setup(memlo, memhi);
a601 9
	case 0x2f:
		loongson2f_setup(memlo, memhi);
		break;
#endif
#ifdef CPU_LOONGSON3
	case 0x3a:
		loongson3a_setup(memlo, memhi);
		break;
#endif
d628 1
a628 2
		firstkernpage = atop(trunc_page(firstkernpa)) +
		    mem_layout[0].mem_first_page - 1;
d632 6
a637 2
		lastkernpage = atop(round_page(lastkernpa)) +
		    mem_layout[0].mem_first_page - 1;
@


1.64
log
@Rename mips64's trap_frame into trapframe.

For coherency with other archs and in order to use it in MI code.

ok visa@@, tobiasu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.63 2015/05/07 01:55:43 jsg Exp $ */
d706 3
d713 1
@


1.63
log
@fix indentation
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.62 2015/05/05 02:13:46 guenther Exp $ */
d688 1
a688 1
	proc0.p_md.md_regs = (struct trap_frame *)&proc0paddr->u_pcb.pcb_regs;
@


1.62
log
@emul_native is only used for kernel threads which can't dump core, so
delete coredump_trad(), uvm_coredump(), cpu_coredump(), struct md_coredump,
and various #includes that are superfluous.

This leaves compat_linux processes without a coredump callback.  If that
ability is desired, someone should update it to use coredump_elf32() and
verify the results...

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.61 2014/12/10 15:29:53 mikeb Exp $ */
d305 5
a309 5
				if (p != NULL) {
					pmon_printf("Attempting to match as "
					    "%s %s\n", p->vendor, p->product);
					return p;
				}
@


1.61
log
@retire shutdown hooks; ok deraadt, krw
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.60 2014/09/26 14:32:07 jsing Exp $ */
a64 1
#include <sys/kcore.h>
@


1.60
log
@Use correct format specifiers in various loongson machine dependent code.

Makes a loongson kernel buildable without -Wno-format.

ok miod@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.59 2014/09/20 09:28:24 kettenis Exp $ */
a934 1
	doshutdownhooks();
@


1.59
log
@Use config_suspend_all(9).

ok mpi@@, uebayasi@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.58 2014/07/21 17:25:47 uebayasi Exp $ */
d843 1
a843 1
	printf("real mem = %u (%uMB)\n", ptoa((psize_t)physmem),
d857 1
a857 1
	printf("avail mem = %u (%uMB)\n", ptoa(uvmexp.free),
@


1.58
log
@boot(9): Reduce annoying style diffs

- Always use either: ((x & RB_XXX) != 0) or ((x & RB_XXX) == 0) in boolean
  context (mostly if (x), or x ? y : z)
  - prom_halt() in alpha is confirmed to take int as boolean

Converted by coccinelle.  No functional change intended.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a904 2
	struct device *mainbus;

d936 2
a937 5
	mainbus = device_mainbus();
	if (mainbus != NULL) {
		pci_dopm = 0;
		config_suspend(mainbus, DVACT_POWERDOWN);
	}
@


1.57
log
@Bring back pci_dopm, but disable it before powerdown.

This fixes both the Lemote reboot issue and the USB issue on the
Gdium's that miod@@ spotted.

Suggested by kettenis@@, thanks!

Okay miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.56 2014/07/13 22:53:39 uebayasi Exp $ */
d933 1
a933 1
	if (howto & RB_DUMP)
d944 2
a945 2
	if (howto & RB_HALT) {
		if (howto & RB_POWERDOWN) {
@


1.56
log
@boot(9): Cosmetic changes to improve diff'ability.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d939 2
a940 1
	if (mainbus != NULL)
d942 1
@


1.55
log
@Cosmetic changes to reduce diffs.
@
text
@d965 1
a965 1
	/*NOTREACHED*/
@


1.54
log
@boot(9): Undo curproc-overriding hacks

Some (not all) boot(9) implementations have ancient hacks which overrides if
(curproc == NULL).  This was probably made in a hope to forcibly proceed
various clean-shutdown related code, including VFS shutdown.  Let's clarify
that clean-shutdown needs process context; it is impossible to cleanly shutdown
VFS from within e.g. a panic in SPL_HIGH.

OK kettenis@@
@
text
@d930 1
a930 1
	splhigh();		/* Disable interrupts. */
@


1.53
log
@Set cold to 1 before executing the DVACT_POWERDOWN handlers when halting or
rebooting a machine, like it is done in the hibernate case.

At least some USB host controller drivers rely on this to busy way instead
of sleeping.  Avoid a panic on macppc with an uhci(4) cardbus plugged in.

ok deraadt@@, uebayashi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.52 2014/07/10 20:15:27 uebayasi Exp $ */
a917 4
		extern struct proc proc0;
		/* fill curproc with live object */
		if (curproc == NULL)
			curproc = &proc0;
@


1.52
log
@boot(9): Remove comments about RB_*, "cold", and savectx()

Again remove slightly different comments to reduce diffs.  These will be
re-added once boot() become MI and its specification is clearly re-defined.

OK miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d934 2
a935 1
	(void) splhigh();		/* Extreme priority. */
@


1.51
log
@boot(): Remove comments about RB_TIMEBAD to reduce diffs

RB_TIMEBAD is documented well enough that the comment is not needed.  sparc64
does slightly different and its comment is left with XXX.

OK deraadt@@ miod@@
@
text
@a906 1
	/* Take a snapshot before clobbering any registers. */
a910 4
		/*
		 * If the system is cold, just halt, unless the user
		 * explicitly asked for reboot.
		 */
@


1.50
log
@boot(): Unify declarations

OK deraadt@@
@
text
@a926 3
		/*
		 * Synchronize the disks...
		 */
a929 4
		/*
		 * If we've been adjusting the clock, the todr will be out of
		 * sync; adjust it now.
		 */
@


1.49
log
@Revert previous diff setting cold to 1 on shutdown because it breaks machine
with softraid(4) disks.

softraid(4) is the last real consumer of the doshutdownhooks(9) API and it is
not trivial to convert its hook to a DVACT_POWERDOWN handler since the latter
does not allow to sleep.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.48 2014/05/30 13:46:16 mpi Exp $ */
d902 1
a902 1
void
@


1.48
log
@Set cold to 1 before executing the DVACT_POWERDOWN handlers when halting or
rebooting a machine, like it is done in the hibernate case.

At least some USB host controller drivers rely on this to busy way instead
of sleeping.  Avoid a panic on macppc with an uhci(4) cardbus plugged in.

ok deraadt@@, uebayashi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.47 2014/04/03 08:07:16 mpi Exp $ */
d946 1
a946 2
	splhigh();		/* Disable interrupts. */
	cold = 1;
@


1.47
log
@Moar <uvm/uvm.h> -> <uvm/uvm_extern.h> love.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.46 2014/03/29 23:59:49 miod Exp $ */
d946 2
a947 1
	(void) splhigh();		/* Extreme priority. */
@


1.46
log
@Update the loongson codebase to recognize the so-called `EFI-like' interface
supposedly provided by newer PMON firmware (on Loongson 2Gq and Loongson 3A
systems).
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.45 2014/03/27 22:16:03 miod Exp $ */
d68 2
a69 1
#include <uvm/uvm.h>
@


1.45
log
@Remove dependency from wscons_machdep upon bonito. Instead of hardcoding bonito
as the northbridge, have the per-platform early setup code register functions
providing access to the PCI configuration space, for the wscons code to walk the
PCI space in search of a graphics board.

No functional change yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.44 2014/03/13 03:52:55 dlg Exp $ */
d4 1
a4 1
 * Copyright (c) 2009, 2010 Miodrag Vallat.
d96 4
a99 3
 * Even though the system is 64bit, the hardware is constrained to up
 * to 2G of contigous physical memory (direct 2GB DMA area), so there
 * is no particular constraint. paddr_t is long so:
d141 2
a142 2
const struct platform *loongson_identify(const char *);
vaddr_t	mips_init(int32_t, int32_t, int32_t, int32_t, char *);
d146 1
d175 1
d180 1
d197 10
d215 1
a215 1
loongson_identify(const char *version)
d219 19
a237 10
	if (version == NULL) {
		/*
		 * If there is no `Version' variable, we expect to be running
		 * on a 2E system, use the generic code and hope for the best.
		 */
		if (loongson_ver == 0x2e) {
			return &generic2e_platform;
		} else {
			pmon_printf("Unable to figure out model!\n");
			return NULL;
a238 1
	}
d240 3
a242 3
	for (f = bonito_flavours; f->prefix != NULL; f++)
		if (strncmp(version, f->prefix, strlen(f->prefix)) == 0)
			return f->platform;
d244 66
a309 55
	/*
	 * Early Lemote designs shipped without a model prefix.
	 *
	 * We can reasonably expect these to be close enough to either the
	 * first generation Fuloong 2F design (LM6002), or the 7 inch
	 * first netbook model; we can tell them apart by looking at which
	 * video chip they embed.
	 *
	 * Note that this is only worth doing if the version string is
	 * 1.2.something (1.3 onwards are expected to have a model prefix,
	 * and there are currently no reports of 1.1 and
	 * below being 2F systems).
	 *
	 * LM6002 users are encouraged to add the system model prefix to
	 * the `Version' variable.
	 */
	if (strncmp(version, "1.2.", 4) == 0) {
		const struct platform *p = NULL;
		pcitag_t tag;
		pcireg_t id, class;
		int dev;

		pmon_printf("No model prefix in version string \"%s\".\n",
		    version);

		for (dev = 0; dev < 32; dev++) {
			tag = pci_make_tag_early(0, dev, 0);
			id = pci_conf_read_early(tag, PCI_ID_REG);
			if (id == 0 || PCI_VENDOR(id) == PCI_VENDOR_INVALID)
				continue;

			/* no need to check for DEVICE_IS_VGA_PCI here
			   since we expect a linear framebuffer */
			class = pci_conf_read_early(tag, PCI_CLASS_REG);
			if (PCI_CLASS(class) != PCI_CLASS_DISPLAY ||
			    (PCI_SUBCLASS(class) != PCI_SUBCLASS_DISPLAY_VGA &&
			     PCI_SUBCLASS(class) != PCI_SUBCLASS_DISPLAY_MISC))
				continue;

			switch (id) {
			case PCI_ID_CODE(PCI_VENDOR_SIS,
			    PCI_PRODUCT_SIS_315PRO_VGA):
				p = &fuloong_platform;
				break;
			case PCI_ID_CODE(PCI_VENDOR_SMI,
			    PCI_PRODUCT_SMI_SM712):
				p = &ebenton_platform;
				break;
			}

			if (p != NULL) {
				pmon_printf("Attempting to match as %s %s\n",
				    p->vendor, p->product);
				return p;
			}
d324 1
a324 1
mips_init(int32_t argc, int32_t argv, int32_t envp, int32_t cv,
d327 1
a327 1
	uint prid;
d356 3
a358 1
	pmon_init(argc, argv, envp, cv);
a389 15
	 * Try and figure out what kind of hardware we are.
	 */

	envvar = pmon_getenv("systype");
	if (envvar == NULL) {
		pmon_printf("Unable to figure out system type!\n");
		goto unsupported;
	}
	if (strcmp(envvar, "Bonito") != 0) {
		pmon_printf("This kernel doesn't support system type \"%s\".\n",
		    envvar);
		goto unsupported;
	}

	/*
d391 3
a393 3
	 * we are not expecting a Bonito-based system with a different
	 * processor.  Just to be on the safe side, refuse to run on
	 * non Loongson2 processors for now.
a395 1
	prid = cp0_get_prid();
d399 2
d404 1
d411 2
d416 3
d420 2
a421 4
		if (loongson_ver == 0x2e || loongson_ver == 0x2f)
			break;
		/* FALLTHROUGH */
	default:
d429 30
d463 2
a464 1
	if ((sys_platform = loongson_identify(pmon_getenv("Version"))) == NULL)
d530 2
a534 1
	default:
d536 4
d541 1
a541 1
		loongson2f_setup(memlo, memhi);
d543 1
a607 1
	bootcpu_hwinfo.tlbsize = 64;
d610 1
a610 1
	 * Configure cache.
d613 22
a634 2
	Loongson2_ConfigCache(curcpu());
	Loongson2_SyncCache(curcpu());
d823 1
@


1.44
log
@get rid of the assumption that the head of the alldevs list is the
"mainbus" device. this breaks when mpath is enabled because it
attaches before mainbus and therefore takes the head position.

have autoconf provide device_mainbus() which looks up mainbus_cd,
and use that instead.

discussed with deraadt who just wants mpath stuff to move forward
despite there being many ways to shine this particular turd.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.43 2013/09/28 12:40:30 miod Exp $ */
d128 5
@


1.43
log
@In boot(), do not iterate over alldevs if it's empty (i.e. halting from ddb
with ddb entered early with boot -d or from UKC).
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.42 2013/06/02 21:46:04 pirofti Exp $ */
d817 1
d865 3
a867 2
	if (!TAILQ_EMPTY(&alldevs))
		config_suspend(TAILQ_FIRST(&alldevs), DVACT_POWERDOWN);
@


1.42
log
@Start working on hibernate support for Loongson

This is work in progress. Nothing to test or play with for now.
Commiting it now so that I can work on it in-tree.

Okay miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.41 2013/01/15 23:30:36 pirofti Exp $ */
d864 2
a865 1
	config_suspend(TAILQ_FIRST(&alldevs), DVACT_POWERDOWN);
@


1.41
log
@Loongson: Add a stat clock for the lemote machines.

The stat clock is implemented so that it also covers, at least
according to the tests I've done, Torek's paper on randomized sampling.

Most of the bits for randomizing the stat ticks were taken from sparc's
implementation and adapted to the companion chip's MFGPT frequencies.

Before this my lemote showed a 8% cpu usage for the cpuhog example from
Torek's paper even though openssl speed showed differences up to 27%
when ran with and without cpuhog. With the new stat clock  it shows
cpuhog around 18-22%, which I think is the proper value.

Okay miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.40 2013/01/14 21:18:47 pirofti Exp $ */
d65 1
d80 4
d505 3
@


1.40
log
@Loongson: Replace the system clock provided by the CPU with a GLX MFGPT.

CPU throttling was not possible due to the fact that the system clock
was the CPU clock. So slowing down the CPU would also slow down the
passing of time.

This commit adds a driver for the MFGPT1 clock from the AMD companion
chip found on lemote and hooks it up as the system clock.

It also changes the frequency value of hz from the default, which was
100, to 128. That's because the scaling on MFGPT clocks is represented
by powers of two.

Okay miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.39 2012/10/08 21:47:48 deraadt Exp $ */
a419 5

	/*
	 * MFGPT runs on powers of two, adjust the hz value accordingly.
	 */
	hz = 128;
@


1.39
log
@Revamp the sequences for suspend/hibernate -> resume so that the code
paths are reflexive.  It is now possible to fail part-way through a
suspend sequence, and recover along the resume code path.
Split DVACT_SUSPEND by adding a new DVACT_POWERDOWN method is used
after hibernate (and suspend too) to finish the job.  Some drivers
must be converted at the same time to use this instead of shutdown hooks
(the others will follow at a later time)
ok kettenis mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.38 2012/10/03 21:44:51 miod Exp $ */
d420 5
@


1.38
log
@Do not use <mips64/archtype.h> for loongson model numbers, but rather put the
list in loongson's <machine/autoconf.h> directly. <mips64/archtype.h> is
intended to be only used on ARCBios-like platforms.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.37 2012/10/03 11:18:23 miod Exp $ */
d856 1
@


1.37
log
@Split ever-growing mips <machine/cpu.h> into what 99% of the kernel needs,
which will remain in <machine/cpu.h>, and a new mips_cpu.h containing only the
goriest md details, which are only of interest to a handful set of files; this
is similar in spirit to what alpha does, but here <machine/cpu.h> does not
include the new file.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.36 2012/09/29 19:11:06 miod Exp $ */
a83 2

#include <mips64/archtype.h>
@


1.36
log
@Kill the mostly unused VMTLB_xxx and VMNUM_xxx defines. Move all tlb
knowledge to <machine/pte.h>. Add specific routines for tlb handling setup
(at cpu initialization time) and tlb ASID wrap.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.35 2012/03/25 13:52:52 miod Exp $ */
d75 1
@


1.35
log
@Move cache handling routines related definitions to a dedicated header file,
rather than abusing <machine/cpu.h>.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.34 2012/03/15 18:57:20 miod Exp $ */
d543 1
a543 4
	tlb_set_page_mask(TLB_PAGE_MASK);
	tlb_set_wired(0);
	tlb_flush(bootcpu_hwinfo.tlbsize);
	tlb_set_wired(UPAGES / 2);
d596 1
a596 1
	tlb_set_pid(1);
@


1.34
log
@uncached_base was introduced early in IP27 support, since these designs use
subspaces in the CCA_NC uncached memory space. However, being coherent,
there was never a need for bus_dma to use uncached addresses.

This means that, on the only systems where uncached_base was not set to
PHYS_TO_XKPHYS(0, CCA_NC), it was never used.

Remove the variable, and replace PHYS_TO_UNCACHED() with
PHYS_TO_XKPHYS(, CCA_NC). No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.33 2011/07/21 20:36:12 miod Exp $ */
d73 1
@


1.33
log
@Support for the eBenton EBT-700 netbook, which is similar to the Lemote
Yeeloong, but with a 7" display with a 800x480 resolution, and no webcam.

There are still problems to get it booting from disk from PMON (colour me
unsurprised), which are being looked at. Loading the boot blocks from a FAT
USB stick, to then boot the kernel from the disk, is a reliable workaround
in the meantime.

Tested by Ban Keong Yee (bankeong dot yee on gmail) who is the ``lucky''
owner of such a machine, thanks for your time!
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.32 2011/06/26 22:39:59 deraadt Exp $ */
a107 1
vaddr_t	uncached_base;
a461 2

	uncached_base = PHYS_TO_XKPHYS(0, CCA_NC);
@


1.32
log
@if_downall() cannot be done MI in sys_reboot() because vfs_shutdown()
might need network (ie. nfs).  Move the call to the MD boot() routines.
This cause for boot hangs diagnosed by kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.31 2011/06/24 19:47:48 naddy Exp $ */
d79 4
d131 1
d160 1
d168 2
d171 2
a172 1
	{ "LM6002",	&fuloong_platform }, /* dual Ethernet, no prefix */
d188 89
a289 1
	const struct bonito_flavour *f;
d399 2
a400 51
	envvar = pmon_getenv("Version");
	if (envvar == NULL) {
		/*
		 * If this is a 2E system, use the generic code and hope
		 * for the best.
		 */
		if (loongson_ver == 0x2e) {
			sys_platform = &generic2e_platform;
		} else {
			pmon_printf("Unable to figure out model!\n");
			goto unsupported;
		}
	} else {
		for (f = bonito_flavours; f->prefix != NULL; f++)
			if (strncmp(envvar, f->prefix, strlen(f->prefix)) ==
			    0) {
				sys_platform = f->platform;
				break;
			}

		if (sys_platform == NULL) {
			/*
			 * Early Lemote designs shipped without a model prefix.
			 * Hopefully these well be close enough to the first
			 * generation Fuloong 2F design (LM6002); let's warn
			 * the user and try this if version is 1.2.something
			 * (1.3 onwards are expected to have a model prefix,
			 *  and there are currently no reports of 1.1 and
			 *  below being 2F systems).
			 *
			 * Note that this could be handled by adding a
			 * "1.2." machine type entry to the flavours table,
			 * but I prefer have it stand out.
			 * LM6002 users are encouraged to add the system
			 * model prefix to the `Version' variable.
			 */
			if (strncmp(envvar, "1.2.", 4) == 0) {
				pmon_printf("No model prefix in version"
				    " string \"%s\".\n"
				    "Attempting to match as Lemote Fuloong\n",
				    envvar);
				sys_platform = &fuloong_platform;
			}
		}

		if (sys_platform == NULL) {
			pmon_printf("This kernel doesn't support model \"%s\"."
			    "\n", envvar);
			goto unsupported;
		}
	}
@


1.31
log
@machdep.kbdreset enables a shutdown by Ctrl-Alt-Del on amd64 and
i386.  Stop abusing it on other archs for controling a shutdown by
pressing the soft power button:

* Add a MI sysctl hw.allowpowerdown; if set to 1 (the default) it
  allows a power button shutdown.
* Make acpi(4)/acpibtn(4) honor hw.allowpowerdown.
* Switch the various power button intercepts on landisk, sgi, sparc64
  and zaurus over to hw.allowpowerdown.
* Garbage collect the machdep.kbdreset sysctl on all archs other than
  amd64 and i386.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.30 2011/06/05 19:41:07 deraadt Exp $ */
d66 1
d804 1
@


1.30
log
@Move the bufcachepercent setting code to MI locations -- set it to 42%
for now; that is unlikely to hit some of the remaining starvation bugs.
Repair the bufpages calculation too; i386 was doing it ahead of time
(incorrectly) and then re-calculating it.
ok thib
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.29 2011/05/30 22:25:21 oga Exp $ */
a107 1
int	kbd_reset;
a755 4
	case CPU_KBDRESET:
		if (securelevel > 0)
			return (sysctl_rdint(oldp, oldlenp, newp, kbd_reset));
		return (sysctl_int(oldp, oldlenp, newp, newlen, &kbd_reset));
@


1.29
log
@Remove the freelist member from vm_physseg

The new world order of pmemrange makes this data completely redundant
(being dealt with by the pmemrange constraints instead). Remove all code
that messes with the freelist.

While touching every caller of uvm_page_physload() anyway, add the flags
argument to all callers (all but one is 0 and that one already used
PHYSLOAD_DEVICE) and remove the macro magic to allow callers to continue
without it.

Should shrink the code a bit, as well.

matthew@@ pointed out some mistakes i'd made.
``freelist death, I like. Ok.' ariane@@
`I agree with the general direction, go ahead and i'll fix any fallout
shortly'' miod@@ (68k 88k and vax i could not check would build)
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.28 2011/05/25 21:22:27 miod Exp $ */
a83 12

/*
 * Declare these as initialized data so we can patch them.
 */
#ifndef	BUFCACHEPERCENT
#define	BUFCACHEPERCENT	5	/* Can be changed in config. */
#endif
#ifndef	BUFPAGES
#define BUFPAGES 0		/* Can be changed in config. */
#endif
int	bufpages = BUFPAGES;
int	bufcachepercent = BUFCACHEPERCENT;
@


1.28
log
@Set UX and SX in the system register early in boot. While not necessary on
the real hardware, some emulators (such as those which name start with `qe'
and end in `mu' and are four letters long) expect the cpu behaviour to
honour the value of these bits. This is not worth doing but it's cheap.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.27 2011/03/31 20:37:44 miod Exp $ */
a458 1
		unsigned int freelist;
a471 1
		freelist = mem_layout[i].mem_freelist;
d478 1
a478 1
			uvm_page_physload(fp, lp, fp, lp, freelist);
d488 1
a488 1
			uvm_page_physload(fp, xp, fp, xp, freelist);
d492 1
a492 1
			uvm_page_physload(fp, lp, fp, lp, freelist);
@


1.27
log
@Recognize Loongson 3A processors, but don't accept to run on them yet, the
cache routines are not ready. This is mostly low-hanging fruit.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.26 2011/03/27 15:28:54 miod Exp $ */
d210 7
@


1.26
log
@Make sure the message buffer area is not zeroed unconditionaly, instead let
initmsgbuf() decide. This gives up a persistent dmesg.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.25 2011/03/16 21:10:17 miod Exp $ */
d278 14
a291 1
		loongson_ver = 0x2c + (prid & 0xff);
d405 2
a406 1
	if (memlo == 256) {
d429 1
@


1.25
log
@Recognize LM6002 as prefix for earlier Fuloong designs, and also recognize
prefixless `1.2.*' version information as LM6002, with a warning message as
their may be surprises if there are non-Fuloong prototypes in the wild ever
with 1.2 PMON code.
Per discussion with Roland Kammerer who is the happy owner of an LM6002.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.24 2010/10/24 15:40:03 miod Exp $ */
d502 29
a530 2
	 * Init message buffer.
	 */
d532 4
a535 1
	msgbufbase = (caddr_t)pmap_steal_memory(MSGBUFSIZE, NULL,NULL);
@


1.24
log
@Move build_trampoline() and setregs() to a common location for all mips ports.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.23 2010/08/28 22:29:03 miod Exp $ */
d100 1
a100 1
 * is no particular constraint. paddr_t is long so: 
d175 1
d315 25
d655 1
a655 1
 * cpu_startup: allocate memory for variable-sized tables, initialize CPU, and 
d828 1
a828 1
	 * Don't dump on the first page in case the dump device includes a 
@


1.23
log
@Correctly compute memory size if less than 256MB.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.22 2010/06/27 13:24:39 miod Exp $ */
a135 1
void	build_trampoline(vaddr_t, vaddr_t);
a537 67
 * Build a tlb trampoline
 */
void
build_trampoline(vaddr_t addr, vaddr_t dest)
{
	const uint32_t insns[] = {
		0x3c1a0000,	/* lui k0, imm16 */
		0x675a0000,	/* daddiu k0, k0, imm16 */
		0x001ad438,	/* dsll k0, k0, 0x10 */
		0x675a0000,	/* daddiu k0, k0, imm16 */
		0x001ad438,	/* dsll k0, k0, 0x10 */
		0x675a0000,	/* daddiu k0, k0, imm16 */
		0x03400008,	/* jr k0 */
		0x00000000	/* nop */
	};
	uint32_t *dst = (uint32_t *)addr;
	const uint32_t *src = insns;
	uint32_t a, b, c, d;

	/*
	 * Decompose the handler address in the four components which,
	 * added with sign extension, will produce the correct address.
	 */
	d = dest & 0xffff;
	dest >>= 16;
	if (d & 0x8000)
		dest++;
	c = dest & 0xffff;
	dest >>= 16;
	if (c & 0x8000)
		dest++;
	b = dest & 0xffff;
	dest >>= 16;
	if (b & 0x8000)
		dest++;
	a = dest & 0xffff;

	/*
	 * Build the trampoline, skipping noop computations.
	 */
	*dst++ = *src++ | a;
	if (b != 0)
		*dst++ = *src++ | b;
	else
		src++;
	*dst++ = *src++;
	if (c != 0)
		*dst++ = *src++ | c;
	else
		src++;
	*dst++ = *src++;
	if (d != 0)
		*dst++ = *src++ | d;
	else
		src++;
	*dst++ = *src++;
	*dst++ = *src++;

	/*
	 * Note that we keep the delay slot instruction a nop, instead
	 * of branching to the second instruction of the handler and
	 * having its first instruction in the delay slot, so that the
	 * tlb handler is free to use k0 immediately.
	 */
}

/*
a700 32

/*
 * Set registers on exec for native exec format. For o64/64.
 */
void
setregs(p, pack, stack, retval)
	struct proc *p;
	struct exec_package *pack;
	u_long stack;
	register_t *retval;
{
	struct cpu_info *ci = curcpu();

	bzero((caddr_t)p->p_md.md_regs, sizeof(struct trap_frame));
	p->p_md.md_regs->sp = stack;
	p->p_md.md_regs->pc = pack->ep_entry & ~3;
	p->p_md.md_regs->t9 = pack->ep_entry & ~3; /* abicall req */
	p->p_md.md_regs->sr = SR_FR_32 | SR_XX | SR_KSU_USER | SR_KX | SR_UX |
	    SR_EXL | SR_INT_ENAB;
	p->p_md.md_regs->sr |= idle_mask & SR_INT_MASK;
	p->p_md.md_regs->ic = (idle_mask << 8) & IC_INT_MASK;
	p->p_md.md_flags &= ~MDP_FPUSED;
	if (ci->ci_fpuproc == p)
		ci->ci_fpuproc = NULL;
	p->p_md.md_ss_addr = 0;
	p->p_md.md_pc_ctrl = 0;
	p->p_md.md_watch_1 = 0;
	p->p_md.md_watch_2 = 0;

	retval[1] = 0;
}

@


1.22
log
@one more include shuffle
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.21 2010/06/27 03:03:48 thib Exp $ */
d379 2
a380 1
	}
@


1.21
log
@uvm constraints. Add two mandatory MD symbols, uvm_md_constraints
which contains the constraints for DMA/memory allocation for each
architecture, and dma_constraints which contains the range of addresses
that are dma accessable by the system.

This is based on ariane@@'s physcontig diff, with lots of bugfixes and
additions the following additions by my self:

Introduce a new function pool_set_constraints() which sets the address
range for which we allocate pages for the pool from, this is now used
for the mbuf/mbuf cluster pools to keep them dma accessible.

The !direct archs no longer stuff pages into the kernel object in
uvm_km_getpage_pla but rather do a pmap_extract() in uvm_km_putpages.

Tested heavily by my self on i386, amd64 and sparc64. Some tests on
alpha and SGI.

"commit it" beck, art, oga, deraadt
"i like the diff" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.19 2010/05/08 21:59:56 miod Exp $ */
d66 1
a66 1
#include <uvm/uvm_extern.h>
@


1.20
log
@Declare safepri at the MD level on each platform, so that the kern_synch.c
does not have to deal with it as a common.  Some platforms may be missed
by this commit... if you spot one, fix it the same way.
ok miod
@
text
@d97 8
@


1.19
log
@Huge work-in-progress commit to support Loongson 2E-based evaluation boards
with a VIA 686 southbridge.

Features:
- 686 setup code (no thanks to PMON for not initializing the beast).
- work in progress ISA interrupt handling code.
- support for vga(4) compatible devices as console, in PC-compatible text mode.
- move legacy (ISA) support code out of bonito(4) to make things clearer.
- support more than 256MB on 2E-based systems.

Tested on a generic 2E-based evaluation board by someone who wishes to remain
anonymous; you know who you are, thank you very much for testing.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.18 2010/04/27 04:26:20 miod Exp $ */
d99 6
@


1.18
log
@Fuloong with LM6003 signature is apparently similar to LM6004 with different
DDR settings, and is reported to work by ysw at mpcj dot cn after cheating
the Version environment variable, so recognize its model number.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.17 2010/03/02 20:54:51 miod Exp $ */
a79 3
#include <loongson/dev/bonitoreg.h>
#include <loongson/dev/bonitovar.h>

d110 1
d156 1
d185 1
a185 1
	uint prid, loongson_ver;
d282 22
a303 8
		pmon_printf("Unable to figure out model!\n");
		goto unsupported;
	}

	for (f = bonito_flavours; f->prefix != NULL; f++)
		if (strncmp(envvar, f->prefix, strlen(f->prefix)) == 0) {
			sys_platform = f->platform;
			break;
a304 5

	if (sys_platform == NULL) {
		pmon_printf("This kernel doesn't support model \"%s\".\n",
		    envvar);
		goto unsupported;
@


1.17
log
@Add support for the Lemote Lynloong all-in-one PC (basically a Fuloong without
the serial and IR ports, built into a mac-like case). At least PMON initializes
the frame buffer in a much friendlier video mode (1360x768x16), but there is
still no frame buffer acceleration yet.

Tested by wvdputte.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.16 2010/02/17 17:17:35 jasper Exp $ */
d163 1
a163 1
	/* how different is LM6003 ? */
@


1.16
log
@- prevent "anti-memory" from showing up, this makes systems with 2GB of
RAM work.

help and ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.15 2010/02/14 22:39:33 miod Exp $ */
d158 1
d163 1
d172 2
@


1.15
log
@Work in progress standalone boot blocks for OpenBSD/loongson systems. Will
load a kernel from the OpenBSD partition, with symbols.
However:
- does not work on gdium (usb i/o errors)
- no countdown due to PMON limitations, so either `bsd' in the PMON
  environment contains a kernel filename to load, and it will get loaded
  immediately, or it doesn't (e.g. the variable does no exist) and you get
  a prompt and can pass options to the kernel. Note that /etc/boot.conf
  commands can still be used in both cases.
- does not work for me when loaded automatically from PMON (put in the `al'
  environment variable). However, `boot $al' works fine. Need to investigate.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.14 2010/02/12 19:39:27 otto Exp $ */
d682 2
a683 2
	printf("real mem = %u (%uMB)\n", ptoa(physmem),
	    ptoa(physmem)/1024/1024);
@


1.14
log
@tftp boot paths do not start with a /; ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.13 2010/02/12 19:37:31 miod Exp $ */
d128 1
a128 1
vaddr_t	mips_init(int32_t, int32_t, int32_t, int32_t);
d179 2
a180 1
mips_init(int32_t argc, int32_t argv, int32_t envp, int32_t cv)
d209 1
a209 2
	 * Attempt to locate ELF header and symbol table after kernel,
	 * and reserve space for the symbol table, if it exists.
d212 6
a217 7
	ssym = (char *)(vaddr_t)*(int32_t *)end;
	if (((long)ssym - (long)end) >= 0 &&
	    ((long)ssym - (long)end) <= 0x1000 &&
	    ssym[0] == ELFMAG0 && ssym[1] == ELFMAG1 &&
	    ssym[2] == ELFMAG2 && ssym[3] == ELFMAG3 ) {
		/* Pointers exist directly after kernel. */
		esym = (char *)(vaddr_t)*((int32_t *)end + 1);
d220 14
a233 3
		/* Pointers aren't setup either... */
		ssym = esym = NULL;
		ekern = end;
@


1.13
log
@Allow for two more per-platform function pointers, one for extra setup work
while pmon is still available, and one for reset (in addition to the already
existing powerdown routine).
Add reset and powerdown code to the fuloong 2f platform; this also fixes
reset on yeeloong.
Tested by otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.12 2010/02/12 08:14:02 miod Exp $ */
d603 1
a603 1
		if (*arg == '/') {
@


1.12
log
@Overhaul per-platform specific operation by moving all the differences into
per-platform structs or function pointers; therefore bonito(4) no longer needs
to know about particular systems.

While there, bring little bits of Fuloong 2F support, tested on otto@@'s
machine.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.11 2010/02/09 21:30:11 miod Exp $ */
d357 3
d361 1
a361 2
	 * The above call might have altered address mappings,
	 * so pmon_printf() should no longer be used from now on.
d831 5
@


1.11
log
@Flush caches upon startup anyway, the gdium pmon keeps it dirty, unlike
the lemote pmon.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.10 2010/02/09 19:24:08 miod Exp $ */
d111 1
a111 1
struct sys_rec sys_config;
d153 1
a153 2
	int	systype;
	const struct bonito_config *bc;
d156 4
d161 7
a167 3
	/* 8.9" Lemote Yeeloong netbook */
	{ "LM8089",	LOONGSON_YEELOONG,	&yeeloong_bonito },
	/* supposedly 10.1" Lemote Yeeloong netbook, but those found so far
d169 1
a169 3
	{ "LM8101",	LOONGSON_YEELOONG,	&yeeloong_bonito },
	/* EMTEC Gdium Liberty 1000 */
	{ "Gdium",	LOONGSON_GDIUM,		&gdium_bonito },
d275 1
a275 2
			sys_config.system_type = f->systype;
			sys_config.sys_bc = f->bc;
d279 1
a279 1
	if (sys_config.system_type == 0) {
d285 2
a286 13
	switch (sys_config.system_type) {
	case LOONGSON_YEELOONG:
		hw_vendor = "Lemote";
		hw_prod = "Yeeloong";
		break;
	case LOONGSON_GDIUM:
		hw_vendor = "EMTEC";
		hw_prod = "Gdium";
		break;
	default:	/* won't happen */
		goto unsupported;
	}

a419 2
	 * Note that the caches being physically tagged, there is no
	 * need to invalidate or flush it.
d817 6
a822 12
			printf("System Power Down.\n");
			switch (sys_config.system_type) {
			case LOONGSON_YEELOONG:
				REGVAL(BONITO_GPIODATA) &= ~0x00000001;
				REGVAL(BONITO_GPIOIE) &= ~0x00000001;
				break;
			case LOONGSON_GDIUM:
				REGVAL(BONITO_GPIODATA) |= 0x00000002;
				REGVAL(BONITO_GPIOIE) &= ~0x00000002;
				break;
			default:
				break;
@


1.10
log
@Process kernel options correctly when run from a `go' command instead of
`boot'.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.9 2010/02/05 20:51:22 miod Exp $ */
d432 1
@


1.9
log
@Blind support for the EMTEC Gdium Liberty netbook. Per-platform configuration
is moved to specific files, and a pointer to the key configuration structure
is now kept in struct sys_config.
bonito(4) interrupt handling is split, to allow PCI+Legacy interrupt systems
(Lemote Yeelong) and PCI-only Legacy-free systems (Gdium) to coexist
peacefully.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.8 2010/02/04 16:41:16 otto Exp $ */
d595 8
d608 2
a609 2
		if (*arg != '-') {
			/* found filename or non-option argument */
d614 1
a614 1
			ignore = 0;
d618 2
a619 1
		if (ignore)
@


1.8
log
@basic bootpath -> bootdev translation; ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.7 2010/02/03 21:46:42 miod Exp $ */
d4 1
a4 1
 * Copyright (c) 2009 Miodrag Vallat.
d81 1
d147 22
d181 1
d268 6
a273 4
	/* Lemote Yeelong 8089 */
	if (strncmp(envvar, "LM8089", 6) == 0) {
		sys_config.system_type = LOONGSON_YEELONG;
	}
d282 1
a282 1
	case LOONGSON_YEELONG:
d284 5
a288 1
		hw_prod = "Yeelong";
d817 12
a828 2
			REGVAL(BONITO_GPIODATA) &= ~0x00000001;
			REGVAL(BONITO_GPIOIE) &= ~0x00000001;
d952 4
@


1.7
log
@Remove memory limitation to the low 256MB. With the -mfix-loongson2f-btb
workaround in place, the kernel can make use of the whole memory without
freezing.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.6 2010/02/01 05:38:09 miod Exp $ */
d85 1
d126 1
d572 4
@


1.6
log
@Limit memory to 256MB at the moment, (intrusive) part of the branch
prediction workarounds until something better is devised.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.4 2010/01/31 15:29:59 miod Exp $ */
a327 4
#define	I_HEART_SCARY_ERRATA_FROM_HELL
#ifdef	I_HEART_SCARY_ERRATA_FROM_HELL
		memhi = 0;
#endif
@


1.5
log
@Fix thinko in previous.
@
text
@d328 4
@


1.4
log
@If there is only 256MB of physical memory or less, access it from physical
address zero onwards, instead of using the 2GB window.
No functional change (except maybe unbreaking never tried 2E support).
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.3 2010/01/09 23:34:29 miod Exp $ */
d352 4
a355 1
		firstkernpa = CKSEG0_TO_PHYS((vaddr_t)start) +
d357 1
a357 1
		lastkernpa = CKSEG0_TO_PHYS((vaddr_t)ekern) +
a358 3

		firstkernpage = atop(trunc_page(firstkernpa));
		lastkernpage = atop(round_page(lastkernpa));
@


1.3
log
@Move cache information from global variables to per-cpu_info fields; this
allows processors with different cache sizes to be used.

Cache management routines now take a struct cpu_info * as first parameter.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.2 2010/01/09 20:33:16 miod Exp $ */
d352 4
a355 6
		firstkernpa = CKSEG0_TO_PHYS((vaddr_t)start);
		lastkernpa = CKSEG0_TO_PHYS((vaddr_t)ekern);
		if (loongson_ver == 0x2f) {
			firstkernpa |= 0x80000000;
			lastkernpa |= 0x80000000;
		}
@


1.2
log
@Define struct cpu_hwinfo, to hold hardware specific information about each
processor (instead of sys_config.cpu[]), and pass it in the attach_args
when attaching cpu devices.

This allows per-cpu information to be gathered late in the bootstrap process,
and not be limited by an arbitrary MAX_CPUS limit; this will suit IP27 and
IP35 systems better.

While there, use this information to make sure delay() uses the speed
information from the cpu it is invoked on.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.1.1.1 2009/12/25 22:06:03 miod Exp $ */
d401 1
a401 1
	Loongson2_ConfigCache();
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.76 2009/08/02 16:28:39 beck Exp $ */
d110 1
d278 1
a278 1
	sys_config.cpu[0].clock = cpuspeed;
d389 2
a390 3
	sys_config.cpu[0].type = (prid >> 8) & 0xff;
	sys_config.cpu[0].vers_maj = (prid >> 4) & 0x0f;
	sys_config.cpu[0].vers_min = prid & 0x0f;
d392 2
a393 5
	sys_config.cpu[0].fptype = sys_config.cpu[0].type;
	sys_config.cpu[0].fpvers_maj = sys_config.cpu[0].vers_maj;
	sys_config.cpu[0].fpvers_min = sys_config.cpu[0].vers_min;

	sys_config.cpu[0].tlbsize = 64;
a402 1
	sys_config.cpu[0].tlbwired = UPAGES / 2;
d405 2
a406 2
	tlb_flush(sys_config.cpu[0].tlbsize);
	tlb_set_wired(sys_config.cpu[0].tlbwired);
d706 1
a706 1
	extern struct proc *machFPCurProcPtr;
d717 2
a718 2
	if (machFPCurProcPtr == p)
		machFPCurProcPtr = NULL;
@


1.1.1.1
log
@By popular demand and peer pressure, check-in work in progress work to support
the Yeelong Lemote mips-based netbook. Kernel bits only for now, needs
polishing; most of this work done during h2k9 last month, although the
porting effort started earlier this year.
@
text
@@
