head	1.8;
access;
symbols
	OPENBSD_6_2_BASE:1.8
	OPENBSD_6_1:1.8.0.14
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.8.0.10
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.6
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.8
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.2
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.4
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.7.0.8
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.4
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.2
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.6.0.10
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.8
	OPENBSD_5_0:1.6.0.6
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.4
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.2
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.5.0.2
	OPENBSD_4_7_BASE:1.5;
locks; strict;
comment	@ * @;


1.8
date	2014.03.27.22.16.03;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2012.10.03.21.44.51;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2010.05.08.21.59.56;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2010.02.16.21.31.36;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2010.02.12.19.37.31;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2010.02.12.08.14.02;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2010.02.09.21.31.47;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2010.02.05.20.51.22;	author miod;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Remove dependency from wscons_machdep upon bonito. Instead of hardcoding bonito
as the northbridge, have the per-platform early setup code register functions
providing access to the PCI configuration space, for the wscons code to walk the
PCI space in search of a graphics board.

No functional change yet.
@
text
@/*	$OpenBSD: gdium_machdep.c,v 1.7 2012/10/03 21:44:51 miod Exp $	*/

/*
 * Copyright (c) 2010 Miodrag Vallat.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * Gdium Liberty specific code and configuration data.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>

#include <machine/autoconf.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>

#include <loongson/dev/bonitoreg.h>
#include <loongson/dev/bonitovar.h>
#include <loongson/dev/bonito_irq.h>

int	gdium_revision = 0;

void	gdium_attach_hook(pci_chipset_tag_t);
void	gdium_device_register(struct device *, void *);
int	gdium_intr_map(int, int, int);
void	gdium_powerdown(void);
void	gdium_reset(void);
void	gdium_setup(void);

const struct bonito_config gdium_bonito = {
	.bc_adbase = 11,

	.bc_gpioIE = LOONGSON_INTRMASK_GPIO,
	.bc_intEdge = LOONGSON_INTRMASK_PCI_SYSERR |
	    LOONGSON_INTRMASK_PCI_PARERR,
	.bc_intSteer = 0,
	.bc_intPol = LOONGSON_INTRMASK_DRAM_PARERR |
	    LOONGSON_INTRMASK_PCI_SYSERR | LOONGSON_INTRMASK_PCI_PARERR,

	.bc_attach_hook = gdium_attach_hook,
	.bc_intr_map = gdium_intr_map
};

const struct platform gdium_platform = {
	.system_type = LOONGSON_GDIUM,
	.vendor = "EMTEC",
	.product = "Gdium",

	.bonito_config = &gdium_bonito,
	.isa_chipset = NULL,
	.legacy_io_ranges = NULL,

	.setup = gdium_setup,
	.device_register = gdium_device_register,

	.powerdown = gdium_powerdown,
	.reset = gdium_reset
};

void
gdium_attach_hook(pci_chipset_tag_t pc)
{
	pcireg_t id;
	pcitag_t tag;
#ifdef notyet
	int bar;
#endif
#if 0
	pcireg_t reg;
	int dev, func;
#endif

#ifdef notyet
	/*
	 * Clear all BAR of the mini PCI slot; PMON did not initialize
	 * it, and we do not want it to conflict with anything.
	 */
	tag = pci_make_tag(pc, 0, 13, 0);
	for (bar = PCI_MAPREG_START; bar < PCI_MAPREG_END; bar += 4)
		pci_conf_write(pc, tag, bar, 0);
#else
	/*
	 * Force a non conflicting BAR for the wireless controller,
	 * until proper resource configuration code is added to
	 * bonito (work in progress).
	 */
	tag = pci_make_tag(pc, 0, 13, 0);
	pci_conf_write(pc, tag, PCI_MAPREG_START, 0x06228000);
#endif

	/*
	 * Figure out which motherboard we are running on.
	 * Might not be good enough...
	 */
	tag = pci_make_tag(pc, 0, 17, 0);
	id = pci_conf_read(pc, tag, PCI_ID_REG);
	if (id == PCI_ID_CODE(PCI_VENDOR_NEC, PCI_PRODUCT_NEC_USB))
		gdium_revision = 1;
	
#if 0
	/*
	 * Tweak the usb controller capabilities.
	 */
	for (dev = pci_bus_maxdevs(pc, 0); dev >= 0; dev--) {
		tag = pci_make_tag(pc, 0, dev, 0);
		id = pci_conf_read(pc, tag, PCI_ID_REG);
		if (id != PCI_ID_CODE(PCI_VENDOR_NEC, PCI_PRODUCT_NEC_USB))
			continue;
		if (gdium_revision != 0) {
			reg = pci_conf_read(pc, tag, 0xe0);
			/* enable ports 1 and 2 */
			reg |= 0x00000003;
			pci_conf_write(pc, tag, 0xe0, reg);
		} else {
			for (func = 0; func < 2; func++) {
				tag = pci_make_tag(pc, 0, dev, func);
				id = pci_conf_read(pc, tag, PCI_ID_REG);
				if (PCI_VENDOR(id) != PCI_VENDOR_NEC)
					continue;
				if (PCI_PRODUCT(id) != PCI_PRODUCT_NEC_USB &&
				    PCI_PRODUCT(id) != PCI_PRODUCT_NEC_USB2)
					continue;

				reg = pci_conf_read(pc, tag, 0xe0);
				/* enable ports 1 and 3, disable port 2 */
				reg &= ~0x00000007;
				reg |= 0x00000005;
				pci_conf_write(pc, tag, 0xe0, reg);
				pci_conf_write(pc, tag, 0xe4, 0x00000020);
			}
		}
	}
#endif
}

int
gdium_intr_map(int dev, int fn, int pin)
{
	switch (dev) {
	/* mini-PCI slot */
	case 13:	/* C D A B */
		return BONITO_DIRECT_IRQ(LOONGSON_INTR_PCIA + (pin + 1) % 4);
	/* Frame buffer */
	case 14:
		return BONITO_DIRECT_IRQ(LOONGSON_INTR_PCIA);
	/* USB */
	case 15:
		if (gdium_revision == 0)
			return BONITO_DIRECT_IRQ(LOONGSON_INTR_PCIA +
			    (pin - 1));
		else
			return BONITO_DIRECT_IRQ(LOONGSON_INTR_PCIB);
	/* Ethernet */
	case 16:
		return BONITO_DIRECT_IRQ(LOONGSON_INTR_PCID);
	/* USB, not present in old motherboard revision */
	case 17:
		if (gdium_revision != 0)
			return BONITO_DIRECT_IRQ(LOONGSON_INTR_PCIC);
		else
			break;
	default:
		break;
	}

	return -1;
}

/*
 * Due to PMON limitations on the Gdium Liberty, we do not get boot device
 * information from PMON.
 *
 * Because of this, we always pretend the G-Key port is the boot device.
 *
 * Note that, unlike on the Lemote machines, other USB devices gets a fixed
 * numbering (USB0 and USB1).
 */

extern struct cfdriver bonito_cd;
extern struct cfdriver pci_cd;
extern struct cfdriver ehci_cd;
extern struct cfdriver usb_cd;
extern struct cfdriver uhub_cd;
extern struct cfdriver umass_cd;
extern struct cfdriver scsibus_cd;
extern struct cfdriver sd_cd;

#include <dev/pci/pcivar.h>
#include <dev/usb/usb.h>
#include <dev/usb/usbdi.h>

void
gdium_device_register(struct device *dev, void *aux)
{
	struct cfdriver *cf = dev->dv_cfdata->cf_driver;
	static int gkey_chain_pos = 0;
	static struct device *lastparent = NULL;

	if (dev->dv_parent != lastparent && gkey_chain_pos != 0)
		return;

	switch (gkey_chain_pos) {
	case 0:	/* bonito at mainbus */
		if (cf == &bonito_cd)
			goto advance;
		break;
	case 1:	/* pci at bonito */
		if (cf == &pci_cd)
			goto advance;
		break;
	case 2:	/* ehci at pci dev 15 */
		if (cf == &ehci_cd) {
			struct pci_attach_args *paa = aux;
			if (paa->pa_device == 15)
				goto advance;
		}
		break;
	case 3:	/* usb at ehci */
		if (cf == &usb_cd)
			goto advance;
		break;
	case 4:	/* uhub at usb */
		if (cf == &uhub_cd)
			goto advance;
		break;
	case 5:	/* umass at uhub port 3 */
		if (cf == &umass_cd) {
			struct usb_attach_arg *uaa = aux;
			if (uaa->port == 3)
				goto advance;
		}
		break;
	case 6:	/* scsibus at umass */
		if (cf == &scsibus_cd)
			goto advance;
		break;
	case 7:	/* sd at scsibus */
		bootdv = dev;
		break;
	}

	return;

advance:
	gkey_chain_pos++;
	lastparent = dev;
}

void
gdium_powerdown()
{
	REGVAL(BONITO_GPIODATA) |= 0x00000002;
	REGVAL(BONITO_GPIOIE) &= ~0x00000002;
}

void
gdium_reset()
{
	REGVAL(BONITO_GPIODATA) &= ~0x00000002;
	REGVAL(BONITO_GPIOIE) &= ~0x00000002;
}

void
gdium_setup()
{
	bonito_early_setup();
}
@


1.7
log
@Do not use <mips64/archtype.h> for loongson model numbers, but rather put the
list in loongson's <machine/autoconf.h> directly. <mips64/archtype.h> is
intended to be only used on ARCBios-like platforms.
@
text
@d1 1
a1 1
/*	$OpenBSD: gdium_machdep.c,v 1.6 2010/05/08 21:59:56 miod Exp $	*/
d44 1
d69 1
a69 1
	.setup = NULL,
d277 6
@


1.6
log
@Huge work-in-progress commit to support Loongson 2E-based evaluation boards
with a VIA 686 southbridge.

Features:
- 686 setup code (no thanks to PMON for not initializing the beast).
- work in progress ISA interrupt handling code.
- support for vga(4) compatible devices as console, in PC-compatible text mode.
- move legacy (ISA) support code out of bonito(4) to make things clearer.
- support more than 256MB on 2E-based systems.

Tested on a generic 2E-based evaluation board by someone who wishes to remain
anonymous; you know who you are, thank you very much for testing.
@
text
@d1 1
a1 1
/*	$OpenBSD: gdium_machdep.c,v 1.5 2010/02/16 21:31:36 miod Exp $	*/
a26 1
#include <mips64/archtype.h>
@


1.5
log
@Move part of the device_register() logic into platform-specific code. Add
correct root device identification for Gdium (assuming it is booted from the
G-Key), although it will not attach as sd0 if there is anything connected to
the usb port next to the Ethernet port.
@
text
@d1 1
a1 1
/*	$OpenBSD: gdium_machdep.c,v 1.4 2010/02/12 19:37:31 miod Exp $	*/
d31 1
a55 2
	.bc_legacy_pic = 0,

d66 1
@


1.4
log
@Allow for two more per-platform function pointers, one for extra setup work
while pmon is still available, and one for reset (in addition to the already
existing powerdown routine).
Add reset and powerdown code to the fuloong 2f platform; this also fixes
reset on yeeloong.
Tested by otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gdium_machdep.c,v 1.3 2010/02/12 08:14:02 miod Exp $	*/
d40 1
d43 1
d70 2
d73 1
a73 1
	.reset = NULL
a101 1
	 * XXX The card does not work correctly anyway at the moment.
d156 1
a156 1
	/* Wireless */
d185 80
d269 7
@


1.3
log
@Overhaul per-platform specific operation by moving all the differences into
per-platform structs or function pointers; therefore bonito(4) no longer needs
to know about particular systems.

While there, bring little bits of Fuloong 2F support, tested on otto@@'s
machine.
@
text
@d1 1
a1 1
/*	$OpenBSD: gdium_machdep.c,v 1.2 2010/02/09 21:31:47 miod Exp $	*/
d67 3
a69 1
	.powerdown = gdium_powerdown
@


1.2
log
@Make the bonito_pci_attach_hook per-platform, as a new callback in struct
bonito_config. Move the Geode initalization code previously found there
to yeeloong-specific code; and on Gdium, clear all the BAR of the internal
mini pci slot - it does not get initialized by PMON and the MI PCI code
complains about the bogus values it finds there on cold boots.
@
text
@d1 1
a1 1
/*	$OpenBSD: gdium_machdep.c,v 1.1 2010/02/05 20:51:22 miod Exp $	*/
d27 1
d33 1
d41 1
d53 2
d59 11
d75 1
d77 1
d83 1
a87 1

d91 10
a105 1

d111 1
a111 1
#if 0	/* XXX Linux does this... but this causes enumeration to fail */
a114 1

d120 1
a120 1
		if (gdium_revision == 0) {
d122 1
a134 1
				/* 0114331f -> 0114331d */
d136 1
d140 1
a140 5

				/* 00006c42 -> 00006c62 */
				reg = pci_conf_read(pc, tag, 0xe4);
				reg |= 0x00000020;
				pci_conf_write(pc, tag, 0xe4, reg);
d178 7
@


1.1
log
@Blind support for the EMTEC Gdium Liberty netbook. Per-platform configuration
is moved to specific files, and a pointer to the key configuration structure
is now kept in struct sys_config.
bonito(4) interrupt handling is split, to allow PCI+Legacy interrupt systems
(Lemote Yeelong) and PCI-only Legacy-free systems (Gdium) to coexist
peacefully.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d30 1
d35 4
a38 1
int	 gdium_intr_map(int, int, int);
d50 1
d54 70
d136 5
a140 6
#if 0	/* on revision 1 -- how to tell them apart? */
		return BONITO_DIRECT_IRQ(LOONGSON_INTR_PCIA +
		    (pa->pa_intrpin - 1));
#else
		return BONITO_DIRECT_IRQ(LOONGSON_INTR_PCIB);
#endif
d144 1
a144 1
	/* USB */
d146 4
a149 5
#if 0 /* not present on revision 1 */
		break;
#else
		return BONITO_DIRECT_IRQ(LOONGSON_INTR_PCIC);
#endif
@

