head	1.16;
access;
symbols
	OPENBSD_6_2_BASE:1.16
	OPENBSD_6_1:1.16.0.4
	OPENBSD_6_1_BASE:1.16
	OPENBSD_6_0:1.15.0.10
	OPENBSD_6_0_BASE:1.15
	OPENBSD_5_9:1.15.0.6
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.15.0.8
	OPENBSD_5_8_BASE:1.15
	OPENBSD_5_7:1.15.0.2
	OPENBSD_5_7_BASE:1.15
	OPENBSD_5_6:1.15.0.4
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.14.0.6
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.14.0.2
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.13.0.2
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.11.0.6
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.4
	OPENBSD_5_0:1.11.0.2
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.10.0.4
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.10.0.2
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.8.0.2
	OPENBSD_4_7_BASE:1.8
	xmas_lemote:1.1.1.1
	miod:1.1.1;
locks; strict;
comment	@ * @;


1.16
date	2016.09.28.14.03.19;	author visa;	state Exp;
branches;
next	1.15;
commitid	pWQz9jt9JOm7twWG;

1.15
date	2014.03.27.21.58.57;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2013.06.02.21.46.04;	author pirofti;	state Exp;
branches;
next	1.13;

1.13
date	2013.01.16.20.28.06;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2013.01.16.07.17.59;	author pirofti;	state Exp;
branches;
next	1.11;

1.11
date	2011.03.31.20.37.44;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2010.05.08.21.59.56;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2010.04.21.03.03.26;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2010.02.28.12.36.46;	author otto;	state Exp;
branches;
next	1.7;

1.7
date	2010.02.23.20.41.35;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2010.02.17.17.17.35;	author jasper;	state Exp;
branches;
next	1.5;

1.5
date	2010.02.05.20.53.28;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2010.02.05.20.45.37;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2010.01.31.15.29.59;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2010.01.22.21.45.24;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2009.12.25.22.04.21;	author miod;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2009.12.25.22.04.21;	author miod;	state Exp;
branches;
next	;


desc
@@


1.16
log
@Add logic for figuring out CPU clock rate and usable memory areas
by using Loongson EFI.

Regression testing on Loongson 2F by fcambus@@
@
text
@/*	$OpenBSD: loongson2_machdep.c,v 1.15 2014/03/27 21:58:57 miod Exp $	*/

/*
 * Copyright (c) 2009, 2010 Miodrag Vallat.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/proc.h>
#include <sys/sysctl.h>

#include <uvm/uvm_extern.h>

#include <machine/autoconf.h>
#include <machine/cpu.h>
#include <machine/loongson2.h>
#include <machine/memconf.h>
#include <machine/pmon.h>

#ifdef HIBERNATE
#include <machine/hibernate_var.h>
#endif /* HIBERNATE */

#include <loongson/dev/bonitoreg.h>

extern struct phys_mem_desc mem_layout[MAXMEMSEGS];
extern paddr_t loongson_memlo_alias;

boolean_t is_memory_range(paddr_t, psize_t, psize_t);
void	loongson2e_setup(u_long, u_long);
void	loongson2f_setup(u_long, u_long);
void	loongson2f_setup_window(uint, uint, uint64_t, uint64_t, uint64_t, uint);

/* PCI view of CPU memory */
paddr_t loongson_dma_base = 0;

/*
 * Canonical crossbow assignments on Loongson 2F based designs.
 * Might need to move to a per-design header file in the future.
 */

#define	MASTER_CPU		0
#define	MASTER_PCI		1

#define	WINDOW_CPU_LOW		0
#define	WINDOW_CPU_PCILO	1
#define	WINDOW_CPU_PCIHI	2
#define	WINDOW_CPU_DDR		3

#define	WINDOW_PCI_DDR		0

#define	DDR_PHYSICAL_BASE	0x0000000000000000UL	/* memory starts at 0 */
#define	DDR_PHYSICAL_SIZE	0x0000000080000000UL	/* up to 2GB */
#define	DDR_WINDOW_BASE		0x0000000080000000UL	/* mapped at 2GB */

#define	PCI_RESOURCE_BASE	0x0000000000000000UL
#define	PCI_RESOURCE_SIZE	0x0000000080000000UL

#define	PCI_DDR_BASE		0x0000000080000000UL	/* PCI->DDR at 2GB */

/*
 * Setup memory mappings for Loongson 2E processors.
 */

void
loongson2e_setup(u_long memlo, u_long memhi)
{
	if (memhi > ((DDR_PHYSICAL_SIZE - BONITO_PCIHI_BASE) >> 20)) {
		pmon_printf("WARNING! %d MB of memory will not be used",
		    memhi - ((DDR_PHYSICAL_SIZE - BONITO_PCIHI_BASE) >> 20));
		memhi = (DDR_PHYSICAL_SIZE - BONITO_PCIHI_BASE) >> 20;
	}

	memlo = atop(memlo << 20);
	memhi = atop(memhi << 20);
	physmem = memlo + memhi;

	/* do NOT stomp on exception area */
	mem_layout[0].mem_first_page = atop(DDR_PHYSICAL_BASE) + 1;
	mem_layout[0].mem_last_page = atop(DDR_PHYSICAL_BASE) + memlo;

	if (memhi != 0) {
		mem_layout[1].mem_first_page = atop(BONITO_PCIHI_BASE);
		mem_layout[1].mem_last_page = atop(BONITO_PCIHI_BASE) +
		    memhi;
	}

	loongson_dma_base = PCI_DDR_BASE ^ DDR_PHYSICAL_BASE;
}

/*
 * Setup memory mappings for Loongson 2F processors.
 */

void
loongson2f_setup(u_long memlo, u_long memhi)
{
	/*
	 * Because we'll only set up a 2GB window for the PCI bus to
	 * access local memory, we'll limit ourselves to 2GB of usable
	 * memory as well.
	 *
	 * Note that this is a bad justification for this; it should be
	 * possible to setup a 1GB PCI space / 3GB memory access window,
	 * and use bounce buffers if physmem > 3GB; but at the moment
	 * there is no need to solve this problem until Loongson 2F-based
	 * hardware with more than 2GB of memory is commonly encountered.
	 *
	 * Also note that, despite the crossbar window registers being
	 * 64-bit wide, the upper 32-bit always read back as zeroes, so
	 * it is dubious whether it is possible to use more than a 4GB
	 * address space... and thus more than 2GB of physical memory.
	 */

	physmem = memlo + memhi;	/* in MB so far */
	if (physmem > (DDR_PHYSICAL_SIZE >> 20)) {
		pmon_printf("WARNING! %d MB of memory will not be used",
		    physmem - (DDR_PHYSICAL_SIZE >> 20));
		memhi = (DDR_PHYSICAL_SIZE >> 20) - 256;
	}

	memlo = atop(memlo << 20);
	memhi = atop(memhi << 20);
	physmem = memlo + memhi;

	/*
	 * PMON configures the system with only the low 256MB of memory
	 * accessible.
	 *
	 * We need to reprogram the address windows in order to be able to
	 * access the whole memory, both by the local processor and by the
	 * PCI bus.
	 *
	 * To make our life easier, we'll setup the memory as a contiguous
	 * range starting at 2GB, and take into account the fact that the
	 * first 256MB are also aliased at address zero (which is where the
	 * kernel is loaded, really).
	 */

	if (memhi != 0) {
		/* do NOT stomp on exception area */
		mem_layout[0].mem_first_page = atop(DDR_WINDOW_BASE) + 1;
		mem_layout[0].mem_last_page = atop(DDR_WINDOW_BASE) +
		    memlo + memhi;
		loongson_dma_base = PCI_DDR_BASE ^ DDR_WINDOW_BASE;
		loongson_memlo_alias = DDR_WINDOW_BASE;
	} else {
		/* do NOT stomp on exception area */
		mem_layout[0].mem_first_page = atop(DDR_PHYSICAL_BASE) + 1;
		mem_layout[0].mem_last_page = atop(DDR_PHYSICAL_BASE) +
		    memlo /* + memhi */;
		loongson_dma_base = PCI_DDR_BASE ^ DDR_PHYSICAL_BASE;
	}
#ifdef HIBERNATE
	mem_layout[0].mem_first_page += HIBERNATE_RESERVED_PAGES;
#endif

	/*
	 * Allow access to memory beyond 256MB, by programming the
	 * Loongson 2F address window registers.
	 * This also makes sure PCI->DDR accesses can use a contiguous
	 * area regardless of the actual memory size.
	 */

	/*
	 * Master #0 (cpu) window #0 allows access to the low 256MB
	 * of memory at address zero onwards.
	 * This window is inherited from PMON; we set it up just in case.
	 */
	loongson2f_setup_window(MASTER_CPU, WINDOW_CPU_LOW, DDR_PHYSICAL_BASE,
	    ~(0x0fffffffUL), DDR_PHYSICAL_BASE, MASTER_CPU);

	/*
	 * Master #0 (cpu) window #1 allows access to the ``low'' PCI
	 * space (from 0x10000000 to 0x1fffffff).
	 * This window is inherited from PMON; we set it up just in case.
	 */
	loongson2f_setup_window(MASTER_CPU, WINDOW_CPU_PCILO, BONITO_PCILO_BASE,
	    ~(0x0fffffffUL), BONITO_PCILO_BASE, MASTER_PCI);

	/*
	 * Master #1 (PCI) window #0 allows access to the memory space
	 * by PCI devices at addresses 0x80000000 onwards.
	 * This window is inherited from PMON, but its mask might be too
	 * restrictive (256MB) so we make sure it matches our needs.
	 */
	loongson2f_setup_window(MASTER_PCI, WINDOW_PCI_DDR, PCI_DDR_BASE,
	    ~(DDR_PHYSICAL_SIZE - 1), DDR_PHYSICAL_BASE, MASTER_CPU);

	/*
	 * Master #0 (CPU) window #2 allows access to a subset of the ``high''
	 * PCI space (from 0x40000000 to 0x7fffffff only).
	 */
	loongson2f_setup_window(MASTER_CPU, WINDOW_CPU_PCIHI, LS2F_PCIHI_BASE,
	    ~((uint64_t)LS2F_PCIHI_SIZE - 1), LS2F_PCIHI_BASE, MASTER_PCI);

	/*
	 * Master #0 (CPU) window #3 allows access to the whole memory space
	 * at addresses 0x80000000 onwards.
	 */
	loongson2f_setup_window(MASTER_CPU, WINDOW_CPU_DDR, DDR_WINDOW_BASE,
	    ~(DDR_PHYSICAL_SIZE - 1), DDR_PHYSICAL_BASE, MASTER_CPU);

	cpu_cpuspeed = loongson2f_cpuspeed;
}

/*
 * Setup a window in the Loongson2F crossbar.
 */

void
loongson2f_setup_window(uint master, uint window, uint64_t base, uint64_t mask,
    uint64_t mmap, uint slave)
{
	volatile uint64_t *awrreg;

	awrreg = (volatile uint64_t *)PHYS_TO_XKPHYS(
	    LOONGSON_AWR_BASE(master, window), CCA_NC);
	*awrreg = base;
	(void)*awrreg;

	awrreg = (volatile uint64_t *)PHYS_TO_XKPHYS(
	    LOONGSON_AWR_SIZE(master, window), CCA_NC);
	*awrreg = mask;
	(void)*awrreg;

	awrreg = (volatile uint64_t *)PHYS_TO_XKPHYS(
	    LOONGSON_AWR_MMAP(master, window), CCA_NC);
	*awrreg = mmap | slave;
	(void)*awrreg;
}

/*
 * Return whether a given physical address points to managed memory.
 * (used by /dev/mem)
 */

boolean_t
is_memory_range(paddr_t pa, psize_t len, psize_t limit)
{
	struct phys_mem_desc *seg;
	uint64_t fp, lp;
	int i;

	fp = atop(pa);
	lp = atop(round_page(pa + len));

	if (limit != 0 && lp > atop(limit))
		return FALSE;

	/*
	 * Allow access to the low 256MB aliased region on 2F systems,
	 * if we are accessing memory at 2GB onwards.
	 */
	if (pa < 0x10000000 && loongson_ver >= 0x2f) {
		fp += mem_layout[0].mem_first_page - 1;
		lp += mem_layout[0].mem_first_page - 1;
	}

	for (i = 0, seg = mem_layout; i < MAXMEMSEGS; i++, seg++)
		if (fp >= seg->mem_first_page && lp <= seg->mem_last_page)
			return TRUE;

	return FALSE;
}

int
loongson2f_cpuspeed(int *freq)
{
	uint32_t step, val;

	val = REGVAL(LOONGSON_CHIP_CONFIG0);
	step = (val & 0x7) + 1;
	*freq = ((bootcpu_hwinfo.clock / 8) * step) / 1000000;

	return 0;
}

void
loongson2f_setperf(int percent)
{
	uint32_t step, val;

	step = percent * 8 / 100;
	if (step < 2)
		step = 2;

	/*
	 * Set clock step.
	 */
	val = REGVAL(LOONGSON_CHIP_CONFIG0);
	val = (val & ~0x7) | (step - 1);
	REGVAL(LOONGSON_CHIP_CONFIG0) = val;
	(void)REGVAL(LOONGSON_CHIP_CONFIG0);
}
@


1.15
log
@Make sure the HIBERNATE pages get reserved regardless of the memory layout.
@
text
@d1 1
a1 1
/*	$OpenBSD: loongson2_machdep.c,v 1.14 2013/06/02 21:46:04 pirofti Exp $	*/
d40 1
d159 1
@


1.14
log
@Start working on hibernate support for Loongson

This is work in progress. Nothing to test or play with for now.
Commiting it now so that I can work on it in-tree.

Okay miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: loongson2_machdep.c,v 1.13 2013/01/16 20:28:06 miod Exp $	*/
a154 3
#ifdef HIBERNATE
		mem_layout[0].mem_first_page += HIBERNATE_RESERVED_PAGES;
#endif
d162 1
a162 1
		    memlo + memhi;
d165 3
@


1.13
log
@On second thought, do not unconditionnaly register the cpu throttling code
on all Loongson2F systems yet; Gdium does not have a separate scheduling
clock yet and can't afford throttling until then.
@
text
@d1 1
a1 1
/*	$OpenBSD: loongson2_machdep.c,v 1.12 2013/01/16 07:17:59 pirofti Exp $	*/
d33 4
d155 3
@


1.12
log
@Loongson: add throttling support.

This commit allows CPU throttling on the 2F systems.

Inspired by an old diff from otto@@.

Help from and okay miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: loongson2_machdep.c,v 1.11 2011/03/31 20:37:44 miod Exp $	*/
a40 2
int	loongson2f_cpuspeed(int *);
void	loongson2f_setperf(int);
a208 1
	cpu_setperf = loongson2f_setperf;
@


1.11
log
@Recognize Loongson 3A processors, but don't accept to run on them yet, the
cache routines are not ready. This is mostly low-hanging fruit.
@
text
@d1 1
a1 1
/*	$OpenBSD: loongson2_machdep.c,v 1.10 2010/05/08 21:59:56 miod Exp $	*/
d42 1
d211 1
d277 6
a282 1
	*freq = bootcpu_hwinfo.clock / 1000000;
d284 18
@


1.10
log
@Huge work-in-progress commit to support Loongson 2E-based evaluation boards
with a VIA 686 southbridge.

Features:
- 686 setup code (no thanks to PMON for not initializing the beast).
- work in progress ISA interrupt handling code.
- support for vga(4) compatible devices as console, in PC-compatible text mode.
- move legacy (ISA) support code out of bonito(4) to make things clearer.
- support more than 256MB on 2E-based systems.

Tested on a generic 2E-based evaluation board by someone who wishes to remain
anonymous; you know who you are, thank you very much for testing.
@
text
@d1 1
a1 1
/*	$OpenBSD: loongson2_machdep.c,v 1.9 2010/04/21 03:03:26 deraadt Exp $	*/
d260 1
a260 1
	if (pa < 0x10000000 && loongson_ver == 0x2f) {
@


1.9
log
@more cleanup to cope with the change that tries to make proc.h not act
like it is everything.h
ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: loongson2_machdep.c,v 1.8 2010/02/28 12:36:46 otto Exp $	*/
d77 6
a86 6
	/*
	 * Only register the first 256MB of memory.
	 * This will be hopefully be revisited once we get our hands
	 * on Loongson 2E-based hardware...
	 */

d91 6
d133 1
a133 1
	physmem = atop((vsize_t)physmem << 20);
d260 1
a260 1
	if (pa < 0x10000000) {
@


1.8
log
@implement hw.cpuspeed sysctl; ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: loongson2_machdep.c,v 1.7 2010/02/23 20:41:35 miod Exp $	*/
d22 1
@


1.7
log
@Allow CPU->PCI access in a subset of the `high' bonito pci memory space
(1GB@@1GB); that's the best we can do on 2F due to the way the crossbar
windows work.
Necessary for upcoming Fuloong2F changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: loongson2_machdep.c,v 1.6 2010/02/17 17:17:35 jasper Exp $	*/
d22 1
d40 1
d201 2
d263 7
@


1.6
log
@- prevent "anti-memory" from showing up, this makes systems with 2GB of
RAM work.

help and ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: loongson2_machdep.c,v 1.5 2010/02/05 20:53:28 miod Exp $	*/
d48 2
a49 2
#define	MASTER_CPU	0
#define	MASTER_PCI	1
d51 4
a54 3
#define	WINDOW_CPU_LOW	0
#define	WINDOW_CPU_PCI	1
#define	WINDOW_CPU_DDR	2
d56 1
a56 1
#define	WINDOW_PCI_DDR	0
d174 1
a174 1
	loongson2f_setup_window(MASTER_CPU, WINDOW_CPU_PCI, BONITO_PCILO_BASE,
d187 8
a194 1
	 * Master #0 (CPU) window #2 allows access to the whole memory space
@


1.5
log
@Add a set of functions to access PCI configuration space before bonito(4)
attaches, and use it to walk the PCI bus to figure out where the onboard
frame buffer device lies, if any; and get the frame buffer memory address
from reading the proper PCI BAR instead of hardcoding it; this should allow
the Gdium Liberty to configure its console correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: loongson2_machdep.c,v 1.4 2010/02/05 20:45:37 miod Exp $	*/
d123 1
a123 1
	physmem = atop(physmem << 20);
@


1.4
log
@When setting up memory regions on Loongson 2F-based machines, make sure we
reprogram the existing windows to our needs, in case the PCI->DDR window does
not span the whole memory size.
While there, introduce a function to reprogram a window for code clarity.
@
text
@d1 1
a1 1
/*	$OpenBSD: loongson2_machdep.c,v 1.3 2010/01/31 15:29:59 miod Exp $	*/
a39 2
/* CPU view of PCI resources */
paddr_t	loongson_pci_base = 0;
@


1.3
log
@If there is only 256MB of physical memory or less, access it from physical
address zero onwards, instead of using the 2GB window.
No functional change (except maybe unbreaking never tried 2E support).
@
text
@d1 1
a1 1
/*	$OpenBSD: loongson2_machdep.c,v 1.2 2010/01/22 21:45:24 miod Exp $	*/
d4 1
a4 1
 * Copyright (c) 2009 Miodrag Vallat.
d31 2
d38 1
a45 4
 * Setup memory mappings for Loongson 2E processors.
 */

/*
d53 2
a55 1
#define	WINDOW_CPU_PCI	3
a64 1
#define	PCI_WINDOW_BASE		0x0000000100000000UL
d67 4
a70 2
#define	PCI_DDR_SIZE		DDR_PHYSICAL_SIZE
#define	PCI_DDR_WINDOW_BASE	DDR_PHYSICAL_BASE
a98 2
	volatile uint64_t *awrreg;

d109 5
d117 1
a117 1
	if (physmem > 2048) {
d119 2
a120 2
		    physmem - 2048);
		memhi = 2048 - 256;
d163 11
a173 4
	 * Make window #2 span the whole memory at 2GB onwards.
	 * XXX Note that this assumes total memory size is
	 * XXX a power of two.  This is always true on the Lemote
	 * XXX Yeelong, might not be on other products.
d175 30
d206 2
a207 2
	    LOONGSON_AWR_BASE(MASTER_CPU, WINDOW_CPU_DDR), CCA_NC);
	*awrreg = DDR_WINDOW_BASE;
d211 2
a212 2
	    LOONGSON_AWR_SIZE(MASTER_CPU, WINDOW_CPU_DDR), CCA_NC);
	*awrreg = 0xffffffffffffffffUL << (ffs(DDR_PHYSICAL_SIZE) - 1);
d216 2
a217 2
	    LOONGSON_AWR_MMAP(MASTER_CPU, WINDOW_CPU_DDR), CCA_NC);
	*awrreg = DDR_PHYSICAL_BASE | MASTER_CPU;
d220 5
@


1.2
log
@Move is_memory_range() from mips64 mem.c to a per-architecture location; this
allows /dev/kmem to access the 256MB alias of the low memory on loongson, which
in turns makes procmap(8) happy.
@
text
@d1 1
a1 1
/*	$OpenBSD: loongson2_machdep.c,v 1.1.1.1 2009/12/25 22:04:21 miod Exp $	*/
d84 3
a86 2
	mem_layout[0].mem_first_page = 1; /* do NOT stomp on exception area */
	mem_layout[0].mem_last_page = memlo;
d88 1
a88 1
	loongson_dma_base = PCI_DDR_BASE;
d137 13
a149 3
	/* do NOT stomp on exception area */
	mem_layout[0].mem_first_page = atop(DDR_WINDOW_BASE) + 1;
	mem_layout[0].mem_last_page = atop(DDR_WINDOW_BASE) + memlo + memhi;
d154 2
d194 2
a195 1
	 * Allow access to the low 256MB aliased region on 2F systems.
d197 3
a199 6
	if (/* curcpu()->ci_hw.type == MIPS_LOONGSON2 && */
	    (curcpu()->ci_hw.c0prid & 0xff) == 0x2f - 0x2c) {
		if (pa < 0x10000000) {
			fp += atop(DDR_WINDOW_BASE);
			lp += atop(DDR_WINDOW_BASE);
		}
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d33 1
a45 17
void
loongson2e_setup(u_long memlo, u_long memhi)
{
	memlo = atop(memlo << 20);
	memhi = atop(memhi << 20);
	physmem = memlo + memhi;

	/*
	 * Only register the first 256MB of memory.
	 * This will be hopefully be revisited once we get our hands
	 * on Loongson 2E-based hardware...
	 */

	mem_layout[0].mem_first_page = 1; /* do NOT stomp on exception area */
	mem_layout[0].mem_last_page = memlo;
}

d71 19
d165 31
@


1.1.1.1
log
@By popular demand and peer pressure, check-in work in progress work to support
the Yeelong Lemote mips-based netbook. Kernel bits only for now, needs
polishing; most of this work done during h2k9 last month, although the
porting effort started earlier this year.
@
text
@@
