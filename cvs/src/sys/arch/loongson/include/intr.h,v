head	1.14;
access;
symbols
	OPENBSD_6_2:1.14.0.2
	OPENBSD_6_2_BASE:1.14
	OPENBSD_6_1:1.12.0.4
	OPENBSD_6_1_BASE:1.12
	OPENBSD_6_0:1.8.0.2
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.7.0.2
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.6.0.4
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.5.0.4
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.8
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.6
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.2
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.4.0.2
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.3.0.8
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.6
	OPENBSD_5_0:1.3.0.4
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.2.0.2
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.1.1.1.0.2
	OPENBSD_4_7_BASE:1.1.1.1
	xmas_lemote:1.1.1.1
	miod:1.1.1;
locks; strict;
comment	@ * @;


1.14
date	2017.06.11.10.01.23;	author visa;	state Exp;
branches;
next	1.13;
commitid	bPs1aUZZRkMdyaOc;

1.13
date	2017.05.17.11.52.25;	author visa;	state Exp;
branches;
next	1.12;
commitid	8pqsf3Sr1h4mIysD;

1.12
date	2017.02.19.08.59.41;	author visa;	state Exp;
branches;
next	1.11;
commitid	0TmUBawebSoGJLOY;

1.11
date	2017.01.19.15.09.04;	author visa;	state Exp;
branches;
next	1.10;
commitid	8FHInuctPjWFPH6r;

1.10
date	2016.11.17.14.41.21;	author visa;	state Exp;
branches;
next	1.9;
commitid	zpQpluEsJrBQDh6U;

1.9
date	2016.11.06.10.20.33;	author visa;	state Exp;
branches;
next	1.8;
commitid	RRYR9PGvmSKrXqUU;

1.8
date	2016.03.06.19.42.27;	author mpi;	state Exp;
branches;
next	1.7;
commitid	cyYKarj4qRTft4gD;

1.7
date	2015.09.13.20.38.45;	author kettenis;	state Exp;
branches;
next	1.6;
commitid	MW9yRxgkKFAx03on;

1.6
date	2015.07.08.13.37.31;	author dlg;	state Exp;
branches;
next	1.5;
commitid	Ds9kNjjKbF4CbIsT;

1.5
date	2013.05.17.19.38.52;	author kettenis;	state Exp;
branches;
next	1.4;

1.4
date	2013.01.15.23.30.36;	author pirofti;	state Exp;
branches;
next	1.3;

1.3
date	2010.12.21.14.56.24;	author claudio;	state Exp;
branches;
next	1.2;

1.2
date	2010.04.23.03.50.22;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2009.11.24.11.20.50;	author miod;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2009.11.24.11.20.50;	author miod;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Define register_splx_handler() in one place.
@
text
@/*	$OpenBSD: intr.h,v 1.13 2017/05/17 11:52:25 visa Exp $ */

/*
 * Copyright (c) 2001-2004 Opsycon AB  (www.opsycon.se / www.opsycon.com)
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#ifndef _MACHINE_INTR_H_
#define _MACHINE_INTR_H_

/*
 * The interrupt level ipl is a logical level; per-platform interrupt
 * code will turn it into the appropriate hardware interrupt masks
 * values.
 *
 * Interrupt sources on the CPU are kept enabled regardless of the
 * current ipl value; individual hardware sources interrupting while
 * logically masked are masked on the fly, remembered as pending, and
 * unmasked at the first splx() opportunity.
 *
 * An exception to this rule is the clock interrupt. Clock interrupts
 * are always allowed to happen, but will (of course!) not be serviced
 * if logically masked.  The reason for this is that clocks usually sit on
 * INT5 and cannot be easily masked if external hardware masking is used.
 */

/* Interrupt priority `levels'; not mutually exclusive. */
#define	IPL_NONE	0	/* nothing */
#define	IPL_SOFTINT	1	/* soft interrupts */
#define	IPL_BIO		2	/* block I/O */
#define IPL_AUDIO	IPL_BIO
#define	IPL_NET		3	/* network */
#define	IPL_TTY		4	/* terminal */
#define	IPL_VM		5	/* memory allocation */
#define	IPL_CLOCK	6	/* clock */
#define	IPL_STATCLOCK	IPL_CLOCK
#define	IPL_SCHED	7	/* everything */
#define	IPL_HIGH	7	/* everything */
#define	IPL_IPI		8	/* interprocessor interrupt */
#define	NIPLS		9	/* Number of levels */

#define IPL_MPFLOOR	IPL_TTY

/* Interrupt priority 'flags'. */
#define	IPL_MPSAFE	0x100

/* Interrupt sharing types. */
#define	IST_NONE	0	/* none */
#define	IST_PULSE	1	/* pulsed */
#define	IST_EDGE	2	/* edge-triggered */
#define	IST_LEVEL	3	/* level-triggered */

#define	SINTBIT(q)	(q)
#define	SINTMASK(q)	(1 << SINTBIT(q))

/* Soft interrupt masks. */

#define	IPL_SOFT	0
#define	IPL_SOFTCLOCK	1
#define	IPL_SOFTNET	2
#define	IPL_SOFTTTY	3

#define	SI_SOFT		0	/* for IPL_SOFT */
#define	SI_SOFTCLOCK	1	/* for IPL_SOFTCLOCK */
#define	SI_SOFTNET	2	/* for IPL_SOFTNET */
#define	SI_SOFTTTY	3	/* for IPL_SOFTTTY */

#define	SI_NQUEUES	4

#ifndef _LOCORE

#include <machine/mutex.h>
#include <sys/queue.h>

struct soft_intrhand {
	TAILQ_ENTRY(soft_intrhand) sih_list;
	void	(*sih_func)(void *);
	void	*sih_arg;
	struct soft_intrq *sih_siq;
	int	sih_pending;
};

struct soft_intrq {
	TAILQ_HEAD(, soft_intrhand) siq_list;
	int siq_si;
	struct mutex siq_mtx;
};

void	 softintr_disestablish(void *);
void	 softintr_dispatch(int);
void	*softintr_establish(int, void (*)(void *), void *);
void	 softintr_init(void);
void	 softintr_schedule(void *);

#define	splsoft()	splraise(IPL_SOFTINT)
#define splbio()	splraise(IPL_BIO)
#define splnet()	splraise(IPL_NET)
#define spltty()	splraise(IPL_TTY)
#define splaudio()	splraise(IPL_AUDIO)
#define splclock()	splraise(IPL_CLOCK)
#define splvm()		splraise(IPL_VM)
#define splhigh()	splraise(IPL_HIGH)

#define splsoftclock()	splsoft()
#define splsoftnet()	splsoft()
#define splstatclock()	splhigh()

#define splsched()	splhigh()
#define spllock()	splhigh()
#define spl0()		spllower(0)

void	splinit(void);

#define	splassert(X)
#define	splsoftassert(X)

void	register_splx_handler(void (*)(int));
int	splraise(int);
void	splx(int);
int	spllower(int);

/*
 * Interrupt control struct used by interrupt dispatchers
 * to hold interrupt handler info.
 */

#include <sys/evcount.h>

struct intrhand {
	struct	intrhand	*ih_next;
	int			(*ih_fun)(void *);
	void			*ih_arg;
	int			 ih_level;
	int			 ih_irq;
	int			 ih_flags;
#define	IH_MPSAFE		0x01
	struct evcount		 ih_count;
};

void	intr_barrier(void *);

/*
 * Low level interrupt dispatcher registration data.
 */

/* Schedule priorities for base interrupts (CPU) */
#define	INTPRI_IPI	0
#define	INTPRI_CLOCK	1
/* other values are system-specific */

#define NLOWINT	4		/* Number of low level registrations possible */

extern uint32_t idle_mask;

struct trapframe;
void	set_intr(int, uint32_t, uint32_t(*)(uint32_t, struct trapframe *));

uint32_t updateimask(uint32_t);
void	dosoftint(void);

#ifdef MULTIPROCESSOR
extern uint32_t ipi_mask;
#define ENABLEIPI() updateimask(~ipi_mask)
#endif

struct pic {
	void	(*pic_eoi)(int);
	void	(*pic_mask)(int);
	void	(*pic_unmask)(int);
};

#ifdef CPU_LOONGSON3

void	 loongson3_intr_init(void);
void	*loongson3_intr_establish(int, int, int (*)(void *), void*,
	    const char *);
void	 loongson3_intr_disestablish(void *);
void	*loongson3_ht_intr_establish(int, int, int (*)(void *), void*,
	    const char *);
void	 loongson3_ht_intr_disestablish(void *);

void	 loongson3_register_ht_pic(const struct pic *);

#endif /* CPU_LOONGSON3 */

#endif /* _LOCORE */

#endif /* _MACHINE_INTR_H_ */
@


1.13
log
@Make IPL_MPSAFE effective on loongson.

Testing help from fcambus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.12 2017/02/19 08:59:41 visa Exp $ */
d138 1
a138 12
/* Inlines */
static __inline void register_splx_handler(void (*)(int));

typedef void (int_f)(int);
extern int_f *splx_hand;

static __inline void
register_splx_handler(void(*handler)(int))
{
	splx_hand = handler;
}

@


1.12
log
@Add SMP config and IPI control logic for Loongson 3A.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.11 2017/01/19 15:09:04 visa Exp $ */
d66 1
a66 1
#define	IPL_MPSAFE	0	/* no "mpsafe" interrupts */
@


1.11
log
@Extend struct platform with MP control functions, and add bootstrap code
for secondary CPUs.

Discussed with miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.10 2016/11/17 14:41:21 visa Exp $ */
d179 2
a180 1
#define	INTPRI_CLOCK	0
@


1.10
log
@Add drivers for PCI host bridge and built-in UARTs on Loongson 3A,
and put the pieces together by platform glue.

Feedback from miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.9 2016/11/06 10:20:33 visa Exp $ */
d191 5
@


1.9
log
@Add interrupt handling routines for Loongson 3A.

Feedback from miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.8 2016/03/06 19:42:27 mpi Exp $ */
d60 2
a61 1
#define	NIPLS		8	/* Number of levels */
@


1.8
log
@Rename mips64's trap_frame into trapframe.

For coherency with other archs and in order to use it in MI code.

ok visa@@, tobiasu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.7 2015/09/13 20:38:45 kettenis Exp $ */
d166 2
d190 20
@


1.7
log
@intr_barrier(9) for loongson, octeon and sgi.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.6 2015/07/08 13:37:31 dlg Exp $ */
d183 2
a184 2
struct trap_frame;
void	set_intr(int, uint32_t, uint32_t(*)(uint32_t, struct trap_frame *));
@


1.6
log
@unify the mutex implementations on all the mips64 platforms.

this basically copies the sgi implementation to mips64 and removes
it from the rest. this way they get an optimised UP mutex implementation
and correct asserts on all platforms.

ok miod@@ jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.5 2013/05/17 19:38:52 kettenis Exp $ */
d168 2
@


1.5
log
@Add a dummy IPL_MPSAFE definition.

ok miod@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.4 2013/01/15 23:30:36 pirofti Exp $ */
d61 2
@


1.4
log
@Loongson: Add a stat clock for the lemote machines.

The stat clock is implemented so that it also covers, at least
according to the tests I've done, Torek's paper on randomized sampling.

Most of the bits for randomizing the stat ticks were taken from sparc's
implementation and adapted to the companion chip's MFGPT frequencies.

Before this my lemote showed a 8% cpu usage for the cpuhog example from
Torek's paper even though openssl speed showed differences up to 27%
when ran with and without cpuhog. With the new stat clock  it shows
cpuhog around 18-22%, which I think is the proper value.

Okay miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.3 2010/12/21 14:56:24 claudio Exp $ */
d61 3
@


1.3
log
@Convert netisr to a normal soft interrupt instead of hanving MD code
for it. This makes the netisr a real C function which will help further
development. No noticable performance change on i386 and amd64.
With input from kettenis@@ and miod@@ additional OKs mikeb@@ and henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.2 2010/04/23 03:50:22 miod Exp $ */
d57 1
@


1.2
log
@Make sure IPL_SCHED is always defined by MD headers, instead of having a MI
fallback definition in <sys/sched.h>, so that there is no hidden include
ordering requirement between <machine/intr.h> and <sys/sched.h>.
ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.1.1.1 2009/11/24 11:20:50 miod Exp $ */
a107 5

/* XXX For legacy software interrupts. */
extern struct soft_intrhand *softnet_intrhand;

#define	setsoftnet()	softintr_schedule(softnet_intrhand)
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.35 2009/10/26 20:14:14 miod Exp $ */
d57 1
@


1.1.1.1
log
@By popular demand and peer pressure, check-in work in progress work to support
the Yeelong Lemote mips-based netbook. Kernel bits only for now, needs
polishing; most of this work done during h2k9 last month, although the
porting effort started earlier this year.
@
text
@@
