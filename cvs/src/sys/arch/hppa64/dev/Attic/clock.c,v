head	1.6;
access;
symbols
	OPENBSD_5_9:1.5.0.18
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.20
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.12
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.16
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.14
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.10
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.8
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.6
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.4
	OPENBSD_5_0:1.5.0.2
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.2.0.2
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.1.0.18
	OPENBSD_4_7_BASE:1.1
	OPENBSD_4_6:1.1.0.20
	OPENBSD_4_6_BASE:1.1
	OPENBSD_4_5:1.1.0.16
	OPENBSD_4_5_BASE:1.1
	OPENBSD_4_4:1.1.0.14
	OPENBSD_4_4_BASE:1.1
	OPENBSD_4_3:1.1.0.12
	OPENBSD_4_3_BASE:1.1
	OPENBSD_4_2:1.1.0.10
	OPENBSD_4_2_BASE:1.1
	OPENBSD_4_1:1.1.0.8
	OPENBSD_4_1_BASE:1.1
	OPENBSD_4_0:1.1.0.6
	OPENBSD_4_0_BASE:1.1
	OPENBSD_3_9:1.1.0.4
	OPENBSD_3_9_BASE:1.1
	OPENBSD_3_8:1.1.0.2
	OPENBSD_3_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.6
date	2016.05.11.21.52.49;	author deraadt;	state dead;
branches;
next	1.5;
commitid	VpgRpYXqYSJy4P7J;

1.5
date	2011.07.04.17.14.14;	author kettenis;	state Exp;
branches;
next	1.4;

1.4
date	2011.01.09.19.37.51;	author jasper;	state Exp;
branches;
next	1.3;

1.3
date	2011.01.02.13.25.17;	author jasper;	state Exp;
branches;
next	1.2;

1.2
date	2010.07.24.21.27.57;	author kettenis;	state Exp;
branches;
next	1.1;

1.1
date	2005.04.01.10.40.47;	author mickey;	state Exp;
branches;
next	;


desc
@@


1.6
log
@remove hppa64 port, which we never got going beyond broken single users.
hppa reverse-stack gives us a valuable test case, but most developers don't
have a 2nd one to proceed further with this.
ok kettenis
@
text
@/*	$OpenBSD: clock.c,v 1.5 2011/07/04 17:14:14 kettenis Exp $	*/

/*
 * Copyright (c) 2005 Michael Shalayeff
 * All rights reserved.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER IN
 * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
 * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/timetc.h>

#include <machine/iomod.h>
#include <machine/reg.h>

#include <dev/clock_subr.h>

u_long	cpu_hzticks;
int	timeset;

u_int	itmr_get_timecount(struct timecounter *);

struct timecounter itmr_timecounter = {
	itmr_get_timecount, NULL, 0xffffffff, 0, "itmr", 0, NULL
};

void
cpu_initclocks(void)
{
	struct cpu_info *ci = curcpu();
	u_long __itmr;

	cpu_hzticks = (PAGE0->mem_10msec * 100) / hz;

	itmr_timecounter.tc_frequency = PAGE0->mem_10msec * 100;
	tc_init(&itmr_timecounter);

	__itmr = mfctl(CR_ITMR);
	ci->ci_itmr = __itmr;
	__itmr += cpu_hzticks;
	mtctl(__itmr, CR_ITMR);
}

/*
 * initialize the system time from the time of day clock
 */
void
inittodr(time_t t)
{
	struct pdc_tod tod PDC_ALIGNMENT;
	int 	error, tbad = 0;
	struct timespec ts;

	if (t < 12*SECYR) {
		printf ("WARNING: preposterous time in file system");
		t = 6*SECYR + 186*SECDAY + SECDAY/2;
		tbad = 1;
	}

	if ((error = pdc_call((iodcio_t)pdc,
	    1, PDC_TOD, PDC_TOD_READ, &tod, 0, 0, 0, 0, 0)))
		printf("clock: failed to fetch (%d)\n", error);

	ts.tv_sec = tod.sec;
	ts.tv_nsec = tod.usec * 1000;
	tc_setclock(&ts);
	timeset = 1;

	if (!tbad) {
		u_long	dt;

		dt = (tod.sec < t)?  t - tod.sec : tod.sec - t;

		if (dt < 2 * SECDAY)
			return;
		printf("WARNING: clock %s %ld days",
		    tod.sec < t? "lost" : "gained", dt / SECDAY);
	}

	printf (" -- CHECK AND RESET THE DATE!\n");
}

/*
 * reset the time of day clock to the value in time
 */
void
resettodr(void)
{
	struct timeval tv;
	int error;

	/*
	 * We might have been called by boot() due to a crash early
	 * on.  Don't reset the clock chip in this case.
	 */
	if (!timeset)
		return;

	microtime(&tv);

	if ((error = pdc_call((iodcio_t)pdc, 1, PDC_TOD, PDC_TOD_WRITE,
	    tv.tv_sec, tv.tv_usec)))
		printf("clock: failed to save (%d)\n", error);
}

void
setstatclockrate(int newhz)
{
	/* nothing we can do */
}

u_int
itmr_get_timecount(struct timecounter *tc)
{
	return (mfctl(CR_ITMR));
}
@


1.5
log
@Finish ansification.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.4 2011/01/09 19:37:51 jasper Exp $	*/
@


1.4
log
@Check in resettodr() if inittodr() has been called, otherwise we end up
resetting the clock when we don't need to. Found out with booting hppa64
kernels, and the problem also exists on hppa when booting with '-a' and hitting
'exit' when asked for the root filesystem.

help & ok jsing@@
also ok kettenis@@ (who suggested naming the variable like amd64/i386 to
prevent creating yet another variant of this code)
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.3 2011/01/02 13:25:17 jasper Exp $	*/
d40 1
a40 1
cpu_initclocks()
d99 1
a99 1
resettodr()
@


1.3
log
@- move resettodr and inittodr to clock.c, like the other clock related functions
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.2 2010/07/24 21:27:57 kettenis Exp $	*/
d31 1
d79 1
d103 7
@


1.2
log
@Switch hppa64 to timecounters.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.1 2005/04/01 10:40:47 mickey Exp $	*/
d53 54
@


1.1
log
@small batch early bottling hppa64 port
matured in mighty ukrainian oak for 23 months
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d23 4
a26 1
#include <sys/time.h>
d30 8
d41 4
d46 7
d58 1
a58 1

d61 2
a62 2
void
microtime(struct timeval *tv)
d64 1
a64 1

@

