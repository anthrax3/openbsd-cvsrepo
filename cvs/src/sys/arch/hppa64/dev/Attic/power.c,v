head	1.5;
access;
symbols
	OPENBSD_5_9:1.4.0.6
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.4.0.8
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.2
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.4
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.1.0.38
	OPENBSD_5_5_BASE:1.1
	OPENBSD_5_4:1.1.0.34
	OPENBSD_5_4_BASE:1.1
	OPENBSD_5_3:1.1.0.32
	OPENBSD_5_3_BASE:1.1
	OPENBSD_5_2:1.1.0.30
	OPENBSD_5_2_BASE:1.1
	OPENBSD_5_1_BASE:1.1
	OPENBSD_5_1:1.1.0.28
	OPENBSD_5_0:1.1.0.26
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.24
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.22
	OPENBSD_4_8_BASE:1.1
	OPENBSD_4_7:1.1.0.18
	OPENBSD_4_7_BASE:1.1
	OPENBSD_4_6:1.1.0.20
	OPENBSD_4_6_BASE:1.1
	OPENBSD_4_5:1.1.0.16
	OPENBSD_4_5_BASE:1.1
	OPENBSD_4_4:1.1.0.14
	OPENBSD_4_4_BASE:1.1
	OPENBSD_4_3:1.1.0.12
	OPENBSD_4_3_BASE:1.1
	OPENBSD_4_2:1.1.0.10
	OPENBSD_4_2_BASE:1.1
	OPENBSD_4_1:1.1.0.8
	OPENBSD_4_1_BASE:1.1
	OPENBSD_4_0:1.1.0.6
	OPENBSD_4_0_BASE:1.1
	OPENBSD_3_9:1.1.0.4
	OPENBSD_3_9_BASE:1.1
	OPENBSD_3_8:1.1.0.2
	OPENBSD_3_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.5
date	2016.05.11.21.52.50;	author deraadt;	state dead;
branches;
next	1.4;
commitid	VpgRpYXqYSJy4P7J;

1.4
date	2014.07.12.20.18.08;	author uebayasi;	state Exp;
branches;
next	1.3;
commitid	nhoQgK9Q8d952hTz;

1.3
date	2014.07.12.14.12.44;	author uebayasi;	state Exp;
branches;
next	1.2;
commitid	CwxiCWSX4kdxVfoo;

1.2
date	2014.03.29.18.09.29;	author guenther;	state Exp;
branches;
next	1.1;

1.1
date	2005.04.01.10.40.47;	author mickey;	state Exp;
branches;
next	;


desc
@@


1.5
log
@remove hppa64 port, which we never got going beyond broken single users.
hppa reverse-stack gives us a valuable test case, but most developers don't
have a 2nd one to proceed further with this.
ok kettenis
@
text
@/*	$OpenBSD: power.c,v 1.4 2014/07/12 20:18:08 uebayasi Exp $	*/

/*
 * Copyright (c) 2005 Michael Shalayeff
 * All rights reserved.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER IN
 * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
 * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/proc.h>
#include <sys/signalvar.h>
#include <sys/kernel.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/kthread.h>

#include <machine/reg.h>
#include <machine/pdc.h>
#include <machine/autoconf.h>

struct power_softc {
	struct device sc_dev;
	void *sc_ih;

	struct proc *sc_thread;
	void (*sc_kicker)(void *);

	int sc_dr_cnt;
	paddr_t sc_pwr_reg;
	volatile int sc_interrupted;
};

int	powermatch(struct device *, void *, void *);
void	powerattach(struct device *, struct device *, void *);

struct cfattach power_ca = {
	sizeof(struct power_softc), powermatch, powerattach
};

struct cfdriver power_cd = {
	NULL, "power", DV_DULL
};

void power_thread_create(void *v);
void power_thread_reg(void *v);
void power_cold_hook_reg(int);
int power_intr(void *);

int
powermatch(struct device *parent, void *cfdata, void *aux)
{
	struct cfdata *cf = cfdata;
	struct confargs *ca = aux;

	if (cf->cf_unit > 0 && !strcmp(ca->ca_name, "power"))
		return (0);

	return (1);
}

void
powerattach(struct device *parent, struct device *self, void *aux)
{
	struct power_softc *sc = (struct power_softc *)self;
	struct confargs *ca = aux;

	if (ca->ca_hpa) {
		extern void (*cold_hook)(int);

		sc->sc_pwr_reg = ca->ca_hpa;
		cold_hook = power_cold_hook_reg;
		sc->sc_kicker = power_thread_reg;
		printf("\n");
	} else
		printf(": not available\n");

	if (ca->ca_irq >= 0)
		sc->sc_ih = cpu_intr_establish(IPL_CLOCK, ca->ca_irq,
		    power_intr, sc, sc->sc_dev.dv_xname);

	if (sc->sc_kicker)
		kthread_create_deferred(power_thread_create, sc);
}

int
power_intr(void *v)
{
	struct power_softc *sc = v;

	sc->sc_interrupted = 1;

	return (1);
}

void
power_thread_create(void *v)
{
	struct power_softc *sc = v;

	if (kthread_create(sc->sc_kicker, sc, &sc->sc_thread,
	    sc->sc_dev.dv_xname))
		printf("WARNING: failed to create kernel power thread\n");
}

void
power_thread_reg(void *v)
{
	struct power_softc *sc = v;
	u_int32_t r;

	for (;;) {
		__asm volatile("ldwas 0(%1), %0"
		    : "=&r" (r) : "r" (sc->sc_pwr_reg));

		if (!(r & 1))
			prsignal(initprocess, SIGUSR2);

		tsleep(v, PWAIT, "regpower", 10);
	}
}

void
power_cold_hook_reg(int on)
{
	extern struct pdc_power_info pdc_power_info;	/* machdep.c */
	int error;

	if ((error = pdc_call((iodcio_t)pdc, 0, PDC_SOFT_POWER,
	    PDC_SOFT_POWER_ENABLE, &pdc_power_info,
	    on == HPPA_COLD_HOT)))
		printf("power_cold_hook_reg: failed (%d)\n", error);
}
@


1.4
log
@reboot(9): Shutdown system by signaling init(8) from kernel where appropriate

Some ports watch temperature in MD and try to shutdown system, when overheated,
by calling directly (re)boot(9).  Change this to signal init(8) from kernel,
as acpi(4) and acpitz(4) do, which has been more tested.  This also helps to
clarify design that ``clean shutdown must be always started by init(8)''.

Note that SIGUSR2 causes init(8) to call reboot(2) with RB_POWERDOWN, as
acpi(4) etc. already does.  It is reasonable, pointed out by kettenis@@,
considering system is overheated and immediate reboot may be dangerous.

OK deraadt@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.3
log
@boot(9), reboot(9): Migrate MD callers of boot(9) to reboot(9)

I have found that some ports call boot(9) from machine-dependent code to
reboot system.  These should be changed to either:

- Sending signal to init(8) to trigger it to shutdown system cleanly, like
  acpi(4) does, in cases where found problems don't prevent system from working
  immediately, or

- Just doing panic(9) if the situation is severely broken.

For now, just rewrite boot() to reboot().  Actual fixes follow.

Discussed with & OK from kettenis@@
@
text
@d21 2
a24 1
#include <sys/reboot.h>
d127 1
a127 1
			reboot(RB_POWERDOWN | RB_HALT);
@


1.2
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: power.c,v 1.1 2005/04/01 10:40:47 mickey Exp $	*/
d126 1
a126 1
			boot(RB_POWERDOWN | RB_HALT);
@


1.1
log
@small batch early bottling hppa64 port
matured in mighty ukrainian oak for 23 months
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d122 1
a122 1
		__asm __volatile("ldwas 0(%1), %0"
@

