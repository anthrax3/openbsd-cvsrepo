head	1.23;
access;
symbols
	OPENBSD_5_9:1.22.0.2
	OPENBSD_5_9_BASE:1.22
	OPENBSD_5_8:1.22.0.4
	OPENBSD_5_8_BASE:1.22
	OPENBSD_5_7:1.21.0.2
	OPENBSD_5_7_BASE:1.21
	OPENBSD_5_6:1.20.0.4
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.19.0.8
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.19.0.4
	OPENBSD_5_4_BASE:1.19
	OPENBSD_5_3:1.19.0.2
	OPENBSD_5_3_BASE:1.19
	OPENBSD_5_2:1.18.0.2
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.2
	OPENBSD_5_0:1.14.0.2
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.10.0.8
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.10.0.6
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.2
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.10.0.4
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.9.0.2
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.8.0.2
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.7.0.4
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.2
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.4.0.2
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.2.0.6
	OPENBSD_4_0_BASE:1.2
	OPENBSD_3_9:1.2.0.4
	OPENBSD_3_9_BASE:1.2
	OPENBSD_3_8:1.2.0.2
	OPENBSD_3_8_BASE:1.2;
locks; strict;
comment	@ * @;


1.23
date	2016.05.11.21.52.50;	author deraadt;	state dead;
branches;
next	1.22;
commitid	VpgRpYXqYSJy4P7J;

1.22
date	2015.05.05.02.13.46;	author guenther;	state Exp;
branches;
next	1.21;
commitid	dNPv28CJI5BxtRGW;

1.21
date	2014.11.16.12.30.57;	author deraadt;	state Exp;
branches;
next	1.20;
commitid	yv0ECmCdICvq576h;

1.20
date	2014.04.08.09.34.23;	author mpi;	state Exp;
branches;
next	1.19;

1.19
date	2013.01.16.19.04.43;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2012.06.21.00.56.59;	author guenther;	state Exp;
branches;
next	1.17;

1.17
date	2011.09.22.13.50.30;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2011.09.20.21.46.08;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2011.08.17.20.54.39;	author kettenis;	state Exp;
branches;
next	1.14;

1.14
date	2011.07.07.18.18.38;	author kettenis;	state Exp;
branches;
next	1.13;

1.13
date	2011.07.04.17.07.27;	author kettenis;	state Exp;
branches;
next	1.12;

1.12
date	2011.04.16.22.02.32;	author kettenis;	state Exp;
branches;
next	1.11;

1.11
date	2011.04.14.19.34.55;	author kettenis;	state Exp;
branches;
next	1.10;

1.10
date	2009.03.26.17.24.33;	author oga;	state Exp;
branches;
next	1.9;

1.9
date	2008.09.30.18.54.27;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2008.04.20.17.11.24;	author kettenis;	state Exp;
branches;
next	1.7;

1.7
date	2007.06.20.17.29.35;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2007.06.05.17.15.22;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2007.05.27.20.59.25;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2006.11.29.12.57.45;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	2006.11.29.12.26.13;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2005.05.01.19.29.56;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	2005.04.01.10.40.47;	author mickey;	state Exp;
branches;
next	;


desc
@@


1.23
log
@remove hppa64 port, which we never got going beyond broken single users.
hppa reverse-stack gives us a valuable test case, but most developers don't
have a 2nd one to proceed further with this.
ok kettenis
@
text
@/*	$OpenBSD: vm_machdep.c,v 1.22 2015/05/05 02:13:46 guenther Exp $	*/

/*
 * Copyright (c) 2005 Michael Shalayeff
 * All rights reserved.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER IN
 * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
 * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */


#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/signalvar.h>
#include <sys/malloc.h>
#include <sys/buf.h>
#include <sys/vnode.h>
#include <sys/user.h>
#include <sys/ptrace.h>
#include <sys/exec.h>
#include <sys/pool.h>

#include <uvm/uvm_extern.h>

#include <machine/psl.h>
#include <machine/pmap.h>
#include <machine/pcb.h>

extern struct pool hppa_fppl;

void
cpu_fork(struct proc *p1, struct proc *p2, void *stack, size_t stacksize,
    void (*func)(void *), void *arg)
{
	extern register_t switch_tramp_p;

	struct pcb *pcbp;
	struct trapframe *tf;
	register_t sp, osp;

#ifdef DIAGNOSTIC
	if (round_page(sizeof(struct user) + sizeof(*tf)) > PAGE_SIZE)
		panic("USPACE too small for user");
#endif
	fpu_proc_save(p1);

	pcbp = &p2->p_addr->u_pcb;
	bcopy(&p1->p_addr->u_pcb, pcbp, sizeof(*pcbp));
	/* space is cached for the copy{in,out}'s pleasure */
	pcbp->pcb_space = p2->p_vmspace->vm_map.pmap->pm_space;
	pcbp->pcb_fpstate = pool_get(&hppa_fppl, PR_WAITOK);
	*pcbp->pcb_fpstate = *p1->p_addr->u_pcb.pcb_fpstate;
	/* reset any of the pending FPU exceptions from parent */
	pcbp->pcb_fpstate->hfp_regs.fpr_regs[0] =
	    HPPA_FPU_FORK(pcbp->pcb_fpstate->hfp_regs.fpr_regs[0]);
	pcbp->pcb_fpstate->hfp_regs.fpr_regs[1] = 0;
	pcbp->pcb_fpstate->hfp_regs.fpr_regs[2] = 0;
	pcbp->pcb_fpstate->hfp_regs.fpr_regs[3] = 0;

	sp = (register_t)p2->p_addr + PAGE_SIZE;
	p2->p_md.md_regs = tf = (struct trapframe *)sp;
	sp += sizeof(struct trapframe);
	bcopy(p1->p_md.md_regs, tf, sizeof(*tf));

	tf->tf_vtop = (paddr_t)p2->p_vmspace->vm_map.pmap->pm_pdir;
	tf->tf_cr30 = (paddr_t)pcbp->pcb_fpstate;

	tf->tf_sr0 = tf->tf_sr1 = tf->tf_sr2 = tf->tf_sr3 =
	tf->tf_sr4 = tf->tf_sr5 = tf->tf_sr6 =
	tf->tf_iisq[0] = tf->tf_iisq[1] =
		p2->p_vmspace->vm_map.pmap->pm_space;
	tf->tf_pidr1 = tf->tf_pidr2 = pmap_sid2pid(tf->tf_sr0);

	/*
	 * theoretically these could be inherited from the father,
	 * but just in case.
	 */
	tf->tf_sr7 = HPPA_SID_KERNEL;
	tf->tf_eiem = mfctl(CR_EIEM);
	tf->tf_ipsw = PSL_C | PSL_Q | PSL_P | PSL_D | PSL_I /* | PSL_L */ |
	    PSL_O | PSL_W;

	/*
	 * If specified, give the child a different stack.
	 */
	if (stack != NULL)
		setstack(tf, (u_long)stack, 0);	/* XXX ignore error? */

	/*
	 * Build stack frames for the cpu_switchto & co.
	 */
	osp = sp + HPPA_FRAME_SIZE;
	*(register_t*)(osp - HPPA_FRAME_SIZE) = 0;
	*(register_t*)(osp + HPPA_FRAME_RP) = switch_tramp_p;
	*(register_t*)(osp) = (osp - HPPA_FRAME_SIZE);

	sp = osp + HPPA_FRAME_SIZE + 20*8; /* frame + callee-saved registers */
	*(register_t*)(sp - HPPA_FRAME_SIZE + 0) = (register_t)arg;
	*(register_t*)(sp - HPPA_FRAME_SIZE + 8) = KERNMODE(func);
	*(register_t*)(sp - HPPA_FRAME_SIZE + 16) = 0;	/* cpl */
	pcbp->pcb_ksp = sp;
}

void
cpu_exit(struct proc *p)
{
	struct pcb *pcb = &p->p_addr->u_pcb;

	fpu_proc_flush(p);

	pool_put(&hppa_fppl, pcb->pcb_fpstate);

	pmap_deactivate(p);
	sched_exit(p);
}

/*
 * Map an IO request into kernel virtual address space.
 */
void
vmapbuf(struct buf *bp, vsize_t len)
{
	struct pmap *pm = vm_map_pmap(&bp->b_proc->p_vmspace->vm_map);
	vaddr_t kva, uva;
	vsize_t size, off;

#ifdef DIAGNOSTIC
	if ((bp->b_flags & B_PHYS) == 0)
		panic("vmapbuf");
#endif
	bp->b_saveaddr = bp->b_data;
	uva = trunc_page((vaddr_t)bp->b_data);
	off = (vaddr_t)bp->b_data - uva;
	size = round_page(off + len);

	kva = uvm_km_valloc_prefer_wait(phys_map, size, uva);
	bp->b_data = (caddr_t)(kva + off);
	while (size > 0) {
		paddr_t pa;

		if (pmap_extract(pm, uva, &pa) == FALSE)
			panic("vmapbuf: null page frame");
		else
			pmap_kenter_pa(kva, pa, PROT_READ | PROT_WRITE);
		uva += PAGE_SIZE;
		kva += PAGE_SIZE;
		size -= PAGE_SIZE;
	}
	pmap_update(pmap_kernel());
}

/*
 * Unmap IO request from the kernel virtual address space.
 */
void
vunmapbuf(struct buf *bp, vsize_t len)
{
	vaddr_t addr, off;

#ifdef DIAGNOSTIC
	if ((bp->b_flags & B_PHYS) == 0)
		panic("vunmapbuf");
#endif
	addr = trunc_page((vaddr_t)bp->b_data);
	off = (vaddr_t)bp->b_data - addr;
	len = round_page(off + len);
	pmap_kremove(addr, len);
	pmap_update(pmap_kernel());
	uvm_km_free_wakeup(phys_map, addr, len);
	bp->b_data = bp->b_saveaddr;
	bp->b_saveaddr = NULL;
}
@


1.22
log
@emul_native is only used for kernel threads which can't dump core, so
delete coredump_trad(), uvm_coredump(), cpu_coredump(), struct md_coredump,
and various #includes that are superfluous.

This leaves compat_linux processes without a coredump callback.  If that
ability is desired, someone should update it to use coredump_elf32() and
verify the results...

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.21 2014/11/16 12:30:57 deraadt Exp $	*/
@


1.21
log
@Replace a plethora of historical protection options with just
PROT_NONE, PROT_READ, PROT_WRITE, and PROT_EXEC from mman.h.
PROT_MASK is introduced as the one true way of extracting those bits.
Remove UVM_ADV_* wrapper, using the standard names.
ok doug guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.20 2014/04/08 09:34:23 mpi Exp $	*/
a30 1
#include <sys/core.h>
a39 41

/*
 * Dump the machine specific header information at the start of a core dump.
 */
int
cpu_coredump(struct proc *p, struct vnode *vp, struct ucred *cred,
    struct core *core)
{
	struct md_coredump md_core;
	struct coreseg cseg;
	off_t off;
	int error;

	CORE_SETMAGIC(*core, COREMAGIC, MID_HPPA20, 0);
	core->c_hdrsize = ALIGN(sizeof(*core));
	core->c_seghdrsize = ALIGN(sizeof(cseg));
	core->c_cpusize = sizeof(md_core);

	process_read_regs(p, &md_core.md_reg);
	process_read_fpregs(p, &md_core.md_fpreg);

	CORE_SETMAGIC(cseg, CORESEGMAGIC, MID_HPPA20, CORE_CPU);
	cseg.c_addr = 0;
	cseg.c_size = core->c_cpusize;

#define	write(vp, addr, n) \
	vn_rdwr(UIO_WRITE, (vp), (caddr_t)(addr), (n), off, \
	    UIO_SYSSPACE, IO_UNIT, cred, NULL, p)

	off = core->c_hdrsize;
	if ((error = write(vp, &cseg, core->c_seghdrsize)))
		return error;
	off += core->c_seghdrsize;
	if ((error = write(vp, &md_core, sizeof md_core)))
		return error;

#undef write
	core->c_nseg++;

	return error;
}
@


1.20
log
@Less <uvm/uvm.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.19 2013/01/16 19:04:43 miod Exp $	*/
d196 1
a196 1
			pmap_kenter_pa(kva, pa, UVM_PROT_RW);
@


1.19
log
@cpu_coredump() also needs to invoke vn_rdwr() without IO_NODELOCKED; only
affects a.out binaries' core dumps.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.18 2012/06/21 00:56:59 guenther Exp $	*/
d34 2
a38 2

#include <uvm/uvm.h>
@


1.18
log
@__tfork() needs to set the stack address of the new thread in the kernel,
so that it can't get a signal while still running on the parent thread's
stack.  Also, pass in sizeof(struct __tfork) to provide forward compat
when more members are added.  This is an ABI change, so switch syscall
numbers and bump lib majors this time.

ok deraadt@@ matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.17 2011/09/22 13:50:30 deraadt Exp $	*/
d68 1
a68 1
	    UIO_SYSSPACE, IO_NODELOCKED|IO_UNIT, cred, NULL, p)
@


1.17
log
@Start removing some tiny irrelevant differences between hppa64 and hppa
so that important differences can be spotted easier.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.16 2011/09/20 21:46:08 miod Exp $	*/
d139 1
a139 1
		tf->tf_sp = (register_t)stack;
@


1.16
log
@calee -> callee
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.15 2011/08/17 20:54:39 kettenis Exp $	*/
d46 2
a47 5
cpu_coredump(p, vp, cred, core)
	struct proc *p;
	struct vnode *vp;
	struct ucred *cred;
	struct core *core;
d84 2
a85 6
cpu_fork(p1, p2, stack, stacksize, func, arg)
	struct proc *p1, *p2;
	void *stack;
	size_t stacksize;
	void (*func)(void *);
	void *arg;
d142 1
a142 1
	 * Build stack frames for the cpu_switch & co.
d173 1
a173 3
vmapbuf(bp, len)
	struct buf *bp;
	vsize_t len;
d208 1
a208 3
vunmapbuf(bp, len)
	struct buf *bp;
	vsize_t len;
@


1.15
log
@Set the PSL_O bit, like we do for 64-bit capable CPUs on hppa.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.14 2011/07/07 18:18:38 kettenis Exp $	*/
d156 1
a156 1
	sp = osp + HPPA_FRAME_SIZE + 20*8; /* frame + calee-save registers */
@


1.14
log
@Set PSL_W bit for forked processes such that they execute in 64-bit mode
instead of 32-bit mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.13 2011/07/04 17:07:27 kettenis Exp $	*/
d139 2
a140 1
	tf->tf_ipsw = PSL_W | PSL_C | PSL_Q | PSL_P | PSL_D | PSL_I /* | PSL_L */;
@


1.13
log
@Give each pmap its own space ID.  The current algorithm is silly, as we'll wrap
and might end up with duplicates, but that's not an issue until we're
multi-user.  Change the TLB miss code to enter mappings with the right
protection ID.  Properly switch pmaps on context switches.  This makes the
copyins we do before starting init actually work instead of failing with
EFAULT.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.12 2011/04/16 22:02:32 kettenis Exp $	*/
d139 1
a139 1
	tf->tf_ipsw = PSL_C | PSL_Q | PSL_P | PSL_D | PSL_I /* | PSL_L */;
@


1.12
log
@Move the FPU state out of 'struct pcb' like we did for hppa since it causes
evil problems with non-equivalent aliases.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.11 2011/04/14 19:34:55 kettenis Exp $	*/
d124 1
@


1.11
log
@Get rid if pcb_uva, like we did on hppa a while ago since it creates evil
non-equivalent aliases.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.10 2009/03/26 17:24:33 oga Exp $	*/
d32 1
d40 1
a93 1
	extern paddr_t fpu_curpcb;	/* from locore.S */
a94 1
	extern u_int fpu_enable;
a98 1
	paddr_t pa;
d104 1
a104 5
	if (p1->p_md.md_regs->tf_cr30 == fpu_curpcb) {
		mtctl(fpu_enable, CR_CCR);
		fpu_save(fpu_curpcb);
		mtctl(0, CR_CCR);
	}
d110 2
d113 5
a117 5
	pcbp->pcb_fpregs[0] = HPPA_FPU_FORK(pcbp->pcb_fpregs[0]);
	pcbp->pcb_fpregs[1] = 0;
	pcbp->pcb_fpregs[2] = 0;
	pcbp->pcb_fpregs[3] = 0;
	fdcache(HPPA_SID_KERNEL, (vaddr_t)&pcbp->pcb_fpregs[0], 8 * 4);
d124 1
a124 7
	/*
	 * Stash the physical for the pcb of U for later perusal
	 */
	if (!pmap_extract(pmap_kernel(), (vaddr_t)p2->p_addr, &pa))
		panic("pmap_extract(%p) failed", p2->p_addr);

	tf->tf_cr30 = pa;
a158 1
	fdcache(HPPA_SID_KERNEL, (vaddr_t)p2->p_addr, sp - (vaddr_t)p2->p_addr);
d162 1
a162 2
cpu_exit(p)
	struct proc *p;
d164 3
a166 2
	extern paddr_t fpu_curpcb;	/* from locore.S */
	struct trapframe *tf = p->p_md.md_regs;
d168 1
a168 4
	if (fpu_curpcb == tf->tf_cr30) {
		fpu_exit();
		fpu_curpcb = 0;
	}
@


1.10
log
@Remove cpu_wait(). It's original use was to be called from the reaper so
MD code would free resources that couldn't be freed until we were no
longer running in that processor. However, it's is unused on all
architectures since mikeb@@'s tss changes on x86 earlier in the year.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.9 2008/09/30 18:54:27 miod Exp $	*/
a114 1
	pcbp->pcb_uva = (vaddr_t)p2->p_addr;
@


1.9
log
@Do not perform cache operations in vmapbuf(), pmap is supposed to do them
for us if needed.

ok art@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.8 2008/04/20 17:11:24 kettenis Exp $	*/
a185 6
}

void
cpu_wait(p)
	struct proc *p;
{
@


1.8
log
@Catch up with cpu_switchto.  Completely untested.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.7 2007/06/20 17:29:35 miod Exp $	*/
a214 5
	/*
	 * We do it on our own here to be able to specify an offset to uvm_map
	 * so that we can get all benefits of PMAP_PREFER.
	 * - art@@
	 */
a215 1
	fdcache(pm->pm_space, uva, size);
@


1.7
log
@In vunmapbuf(), explicitely remove mappings before invoking uvm_km_free().
Even if the latter would end up removing the mappings by itself, it would
do so using pmap_remove() because phys_map is not intrsafe; but some
platforms use pmap_kenter_pa() in vmapbuf(). By removing the mappings
ourselves, we can ensure the remove function used matches the enter function
which has been used.
Discussed and theoretical ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.6 2007/06/05 17:15:22 miod Exp $	*/
d184 2
a185 2
	exit2(p);
	cpu_switch(p);
@


1.6
log
@Use phys_map, not kernel_map in v{,un}mapbuf. ok mickey
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.5 2007/05/27 20:59:25 miod Exp $	*/
d254 2
@


1.5
log
@pagemove() is no longer used.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.4 2006/11/29 12:57:45 mickey Exp $	*/
d220 1
a220 1
	kva = uvm_km_valloc_prefer_wait(kernel_map, size, uva);
d254 1
a254 1
	uvm_km_free_wakeup(kernel_map, addr, len);
@


1.4
log
@cpu_swapin is nomore
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.3 2006/11/29 12:26:13 miod Exp $	*/
a81 23
}

/*
 * Move pages from one kernel virtual address to another.
 * Both addresses are assumed to reside in the Sysmap.
 */
void
pagemove(from, to, size)
	register caddr_t from, to;
	size_t size;
{
	paddr_t pa;

	while (size > 0) {
		if (pmap_extract(pmap_kernel(), (vaddr_t)from, &pa) == FALSE)
			panic("pagemove");
		pmap_kremove((vaddr_t)from, PAGE_SIZE);
		pmap_kenter_pa((vaddr_t)to, pa, UVM_PROT_RW);
		from += PAGE_SIZE;
		to += PAGE_SIZE;
		size -= PAGE_SIZE;
	}
	pmap_update(pmap_kernel());
@


1.3
log
@Remove cpu_swapin() and cpu_swapout(), they are no longer necessary (except
for cpu_swapin() on hppa* which is kept).
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.2 2005/05/01 19:29:56 mickey Exp $	*/
a106 17
void cpu_swapin(struct proc *p);

void
cpu_swapin(struct proc *p)
{
	struct trapframe *tf = p->p_md.md_regs;
	paddr_t pa;

	/*
	 * Stash the physical for the pcb of U for later perusal
	 */
	if (!pmap_extract(pmap_kernel(), (vaddr_t)p->p_addr, &pa))
		panic("pmap_extract(%p) failed", p->p_addr);

	tf->tf_cr30 = pa;
}

d122 1
d152 1
a152 2
	 * cpu_swapin() is supposed to fill out all the PAs
	 * we gonna need in locore
d154 4
a157 1
	cpu_swapin(p2);
@


1.2
log
@since &func is aplt workaround the switch_trampoline and deref plt for the func aswell
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.1 2005/04/01 10:40:47 mickey Exp $	*/
d107 2
d110 1
a110 2
cpu_swapin(p)
	struct proc *p;
a121 16
}

void
cpu_swapout(p)
	struct proc *p;
{
	extern paddr_t fpu_curpcb;	/* from locore.S */
	extern u_int fpu_enable;
	struct trapframe *tf = p->p_md.md_regs;

	if (tf->tf_cr30 == fpu_curpcb) {
		mtctl(fpu_enable, CR_CCR);
		fpu_save(fpu_curpcb);
		fpu_curpcb = 0;
		mtctl(0, CR_CCR);
	}
@


1.1
log
@small batch early bottling hppa64 port
matured in mighty ukrainian oak for 23 months
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d148 1
d150 1
d213 1
a213 1
	*(register_t*)(osp + HPPA_FRAME_RP) = (register_t)&switch_trampoline;
@

