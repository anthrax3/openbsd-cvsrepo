head	1.81;
access;
symbols
	OPENBSD_5_9:1.78.0.2
	OPENBSD_5_9_BASE:1.78
	OPENBSD_5_8:1.77.0.6
	OPENBSD_5_8_BASE:1.77
	OPENBSD_5_7:1.77.0.2
	OPENBSD_5_7_BASE:1.77
	OPENBSD_5_6:1.71.0.4
	OPENBSD_5_6_BASE:1.71
	OPENBSD_5_5:1.53.0.4
	OPENBSD_5_5_BASE:1.53
	OPENBSD_5_4:1.51.0.2
	OPENBSD_5_4_BASE:1.51
	OPENBSD_5_3:1.50.0.2
	OPENBSD_5_3_BASE:1.50
	OPENBSD_5_2:1.48.0.2
	OPENBSD_5_2_BASE:1.48
	OPENBSD_5_1_BASE:1.45
	OPENBSD_5_1:1.45.0.2
	OPENBSD_5_0:1.39.0.2
	OPENBSD_5_0_BASE:1.39
	OPENBSD_4_9:1.30.0.2
	OPENBSD_4_9_BASE:1.30
	OPENBSD_4_8:1.26.0.2
	OPENBSD_4_8_BASE:1.26
	OPENBSD_4_7:1.20.0.2
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.15.0.4
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.13.0.2
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.12.0.2
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.7.0.4
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.2
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.4.0.6
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.4
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.2
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.2.0.2
	OPENBSD_3_8_BASE:1.2;
locks; strict;
comment	@ * @;


1.81
date	2016.05.11.21.52.50;	author deraadt;	state dead;
branches;
next	1.80;
commitid	VpgRpYXqYSJy4P7J;

1.80
date	2016.05.10.18.39.44;	author deraadt;	state Exp;
branches;
next	1.79;
commitid	qfOifNidEGDB2jL1;

1.79
date	2016.04.20.23.52.04;	author dlg;	state Exp;
branches;
next	1.78;
commitid	hfeQvhMJUSqav4QG;

1.78
date	2015.10.21.07.59.18;	author mpi;	state Exp;
branches;
next	1.77;
commitid	XglPgGQ8qaiL0M4l;

1.77
date	2015.01.20.19.43.20;	author kettenis;	state Exp;
branches;
next	1.76;
commitid	Fn841MmVYz2JHvBP;

1.76
date	2014.12.10.15.29.53;	author mikeb;	state Exp;
branches;
next	1.75;
commitid	qHQiR2HLROzvZr7B;

1.75
date	2014.10.25.17.31.26;	author kettenis;	state Exp;
branches;
next	1.74;
commitid	4yulu09TU8ouklVA;

1.74
date	2014.10.12.20.39.46;	author miod;	state Exp;
branches;
next	1.73;
commitid	n8DZa9w0X2LVgDkM;

1.73
date	2014.09.19.18.21.14;	author kettenis;	state Exp;
branches;
next	1.72;
commitid	oXw0lqB9A4Arhr2x;

1.72
date	2014.08.18.05.11.03;	author dlg;	state Exp;
branches;
next	1.71;
commitid	hjFdrSJM3VTXJUZV;

1.71
date	2014.07.22.01.04.04;	author uebayasi;	state Exp;
branches;
next	1.70;
commitid	NQKNjqRml7IP6o0a;

1.70
date	2014.07.21.17.25.47;	author uebayasi;	state Exp;
branches;
next	1.69;
commitid	7QO4UJr3EKVAMc8t;

1.69
date	2014.07.13.22.53.39;	author uebayasi;	state Exp;
branches;
next	1.68;
commitid	wsdp3qtXGjMj98oD;

1.68
date	2014.07.13.22.13.06;	author uebayasi;	state Exp;
branches;
next	1.67;
commitid	qYPOd6Qi4aRBKldK;

1.67
date	2014.07.13.09.08.20;	author miod;	state Exp;
branches;
next	1.66;
commitid	2861ZNGwagNBNLEr;

1.66
date	2014.07.12.22.37.03;	author uebayasi;	state Exp;
branches;
next	1.65;
commitid	5h3kYJioMDqUXM3V;

1.65
date	2014.07.12.14.12.44;	author uebayasi;	state Exp;
branches;
next	1.64;
commitid	CwxiCWSX4kdxVfoo;

1.64
date	2014.07.10.21.46.03;	author mpi;	state Exp;
branches;
next	1.63;
commitid	iYq3Z1ZWDKR3sS9G;

1.63
date	2014.07.10.20.15.27;	author uebayasi;	state Exp;
branches;
next	1.62;
commitid	YzvTa4t6mddz7Mh4;

1.62
date	2014.07.10.13.34.32;	author uebayasi;	state Exp;
branches;
next	1.61;
commitid	xpsLTYRIkonFtkr1;

1.61
date	2014.07.10.12.13.49;	author uebayasi;	state Exp;
branches;
next	1.60;
commitid	aofvn6ceiucgjg4N;

1.60
date	2014.05.31.15.49.28;	author mpi;	state Exp;
branches;
next	1.59;
commitid	eA4Y0YE1IUzj6hpW;

1.59
date	2014.05.30.13.46.16;	author mpi;	state Exp;
branches;
next	1.58;

1.58
date	2014.04.08.09.34.23;	author mpi;	state Exp;
branches;
next	1.57;

1.57
date	2014.03.29.18.09.29;	author guenther;	state Exp;
branches;
next	1.56;

1.56
date	2014.03.26.05.23.42;	author guenther;	state Exp;
branches;
next	1.55;

1.55
date	2014.03.22.06.05.45;	author guenther;	state Exp;
branches;
next	1.54;

1.54
date	2014.03.13.03.52.55;	author dlg;	state Exp;
branches;
next	1.53;

1.53
date	2013.11.23.07.20.52;	author uebayasi;	state Exp;
branches;
next	1.52;

1.52
date	2013.09.28.12.40.29;	author miod;	state Exp;
branches;
next	1.51;

1.51
date	2013.06.11.16.42.08;	author deraadt;	state Exp;
branches;
next	1.50;

1.50
date	2012.12.02.07.03.31;	author guenther;	state Exp;
branches;
next	1.49;

1.49
date	2012.10.08.21.47.48;	author deraadt;	state Exp;
branches;
next	1.48;

1.48
date	2012.07.13.15.10.51;	author jsing;	state Exp;
branches;
next	1.47;

1.47
date	2012.07.13.14.28.13;	author deraadt;	state Exp;
branches;
next	1.46;

1.46
date	2012.06.21.00.56.59;	author guenther;	state Exp;
branches;
next	1.45;

1.45
date	2011.09.22.21.48.34;	author jsing;	state Exp;
branches;
next	1.44;

1.44
date	2011.09.22.13.50.30;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2011.09.20.13.56.44;	author jsing;	state Exp;
branches;
next	1.42;

1.42
date	2011.09.19.13.21.15;	author jsing;	state Exp;
branches;
next	1.41;

1.41
date	2011.09.18.14.14.48;	author kettenis;	state Exp;
branches;
next	1.40;

1.40
date	2011.08.16.17.36.37;	author kettenis;	state Exp;
branches;
next	1.39;

1.39
date	2011.07.05.04.48.01;	author guenther;	state Exp;
branches;
next	1.38;

1.38
date	2011.06.26.22.39.59;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2011.06.05.19.41.06;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2011.04.18.21.44.55;	author guenther;	state Exp;
branches;
next	1.35;

1.35
date	2011.04.16.22.02.32;	author kettenis;	state Exp;
branches;
next	1.34;

1.34
date	2011.04.15.04.52.39;	author guenther;	state Exp;
branches;
next	1.33;

1.33
date	2011.04.06.14.45.23;	author jsing;	state Exp;
branches;
next	1.32;

1.32
date	2011.04.05.15.46.53;	author jsing;	state Exp;
branches;
next	1.31;

1.31
date	2011.04.05.14.13.25;	author jsing;	state Exp;
branches;
next	1.30;

1.30
date	2011.01.04.17.59.14;	author jasper;	state Exp;
branches;
next	1.29;

1.29
date	2011.01.02.13.25.17;	author jasper;	state Exp;
branches;
next	1.28;

1.28
date	2011.01.01.18.59.26;	author jasper;	state Exp;
branches;
next	1.27;

1.27
date	2010.11.20.20.33.23;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2010.07.24.21.27.57;	author kettenis;	state Exp;
branches;
next	1.25;

1.25
date	2010.07.01.05.09.27;	author jsing;	state Exp;
branches;
next	1.24;

1.24
date	2010.07.01.05.07.26;	author jsing;	state Exp;
branches;
next	1.23;

1.23
date	2010.06.29.20.30.32;	author guenther;	state Exp;
branches;
next	1.22;

1.22
date	2010.06.09.15.44.17;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2010.05.24.15.06.05;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2009.11.25.23.20.59;	author jsing;	state Exp;
branches;
next	1.19;

1.19
date	2009.08.11.19.17.16;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2009.08.11.18.46.32;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2009.08.09.10.40.17;	author blambert;	state Exp;
branches;
next	1.16;

1.16
date	2009.08.02.16.28.39;	author beck;	state Exp;
branches;
next	1.15;

1.15
date	2009.06.15.17.01.25;	author beck;	state Exp;
branches;
next	1.14;

1.14
date	2009.06.03.21.30.19;	author beck;	state Exp;
branches;
next	1.13;

1.13
date	2009.02.04.17.19.17;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2008.06.27.17.22.14;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2008.04.27.17.48.10;	author martin;	state Exp;
branches;
next	1.10;

1.10
date	2008.04.20.21.42.00;	author kettenis;	state Exp;
branches;
next	1.9;

1.9
date	2008.04.20.11.53.11;	author kettenis;	state Exp;
branches;
next	1.8;

1.8
date	2008.04.09.16.58.10;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2007.06.06.17.15.12;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2007.05.27.17.31.56;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2007.05.26.20.26.50;	author pedro;	state Exp;
branches;
next	1.4;

1.4
date	2006.01.10.19.21.14;	author martin;	state Exp;
branches;
next	1.3;

1.3
date	2005.10.26.18.35.45;	author martin;	state Exp;
branches;
next	1.2;

1.2
date	2005.08.06.14.26.52;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2005.04.01.10.40.47;	author mickey;	state Exp;
branches;
next	;


desc
@@


1.81
log
@remove hppa64 port, which we never got going beyond broken single users.
hppa reverse-stack gives us a valuable test case, but most developers don't
have a 2nd one to proceed further with this.
ok kettenis
@
text
@/*	$OpenBSD: machdep.c,v 1.80 2016/05/10 18:39:44 deraadt Exp $	*/

/*
 * Copyright (c) 2005 Michael Shalayeff
 * All rights reserved.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER IN
 * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
 * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/signalvar.h>
#include <sys/kernel.h>
#include <sys/proc.h>
#include <sys/buf.h>
#include <sys/reboot.h>
#include <sys/device.h>
#include <sys/conf.h>
#include <sys/file.h>
#include <sys/timeout.h>
#include <sys/malloc.h>
#include <sys/pool.h>
#include <sys/msgbuf.h>
#include <sys/ioctl.h>
#include <sys/tty.h>
#include <sys/user.h>
#include <sys/exec.h>
#include <sys/sysctl.h>
#include <sys/core.h>
#include <sys/kcore.h>
#include <sys/extent.h>
#include <sys/timetc.h>

#include <sys/mount.h>
#include <sys/syscallargs.h>

#include <net/if.h>
#include <uvm/uvm.h>

#include <dev/cons.h>
#include <dev/clock_subr.h>

#include <machine/pdc.h>
#include <machine/iomod.h>
#include <machine/psl.h>
#include <machine/reg.h>
#include <machine/autoconf.h>
#include <machine/kcore.h>
#include <machine/fpu.h>

#ifdef DDB
#include <machine/db_machdep.h>
#include <ddb/db_access.h>
#include <ddb/db_sym.h>
#include <ddb/db_extern.h>
#endif

#include <hppa/dev/cpudevs.h>

/*
 * Different kinds of flags used throughout the kernel.
 */
int cold = 1;			/* unset when engine is up to go */
extern int msgbufmapped;	/* set when safe to use msgbuf */

/*
 * cache configuration, for most machines is the same
 * numbers, so it makes sense to do defines w/ numbers depending
 * on configured cpu types in the kernel
 */
int icache_stride, icache_line_mask;
int dcache_stride, dcache_line_mask;

/*
 * things to not kill
 */
volatile u_int8_t *machine_ledaddr;
int machine_ledword, machine_leds;
struct cpu_info cpu0_info;

/*
 * CPU params (should be the same for all cpus in the system)
 */
struct pdc_cache pdc_cache PDC_ALIGNMENT;
struct pdc_model pdc_model PDC_ALIGNMENT;

	/* w/ a little deviation should be the same for all installed cpus */
u_int	cpu_ticksnum, cpu_ticksdenom;

	/* exported info */
char	machine[] = MACHINE;
char	cpu_model[128];
int	cpu_hvers;
enum hppa_cpu_type cpu_type;
const char *cpu_typename;
u_int	fpu_version;

dev_t	bootdev;
int	physmem, resvmem, resvphysmem, esym;

/*
 * Things for MI glue to stick on.
 */
struct user *proc0paddr;
long mem_ex_storage[EXTENT_FIXED_STORAGE_SIZE(32) / sizeof(long)];
struct extent *hppa_ex;
struct pool hppa_fppl;
struct hppa_fpstate proc0fpstate;
struct consdev *cn_tab;

struct vm_map *exec_map = NULL;
struct vm_map *phys_map = NULL;

void delay_init(void);
static __inline void fall(int, int, int, int, int);
void dumpsys(void);
void hpmc_dump(void);
void cpuid(void);

/*
 * safepri is a safe priority for sleep to set for a spin-wait
 * during autoconfiguration or after a panic.
 */
int	safepri = 0;

/*
 * wide used hardware params
 */
struct pdc_hwtlb pdc_hwtlb PDC_ALIGNMENT;
struct pdc_coproc pdc_coproc PDC_ALIGNMENT;
struct pdc_coherence pdc_coherence PDC_ALIGNMENT;
struct pdc_spidb pdc_spidbits PDC_ALIGNMENT;
struct pdc_model pdc_model PDC_ALIGNMENT;

#ifdef DEBUG
int sigdebug = 0;
pid_t sigpid = 0;
#define SDB_FOLLOW	0x01
#endif

struct uvm_constraint_range  dma_constraint = { 0x0, (paddr_t)-1 };
struct uvm_constraint_range *uvm_md_constraints[] = { NULL };

int	hppa_cpuspeed(int *mhz);

int
hppa_cpuspeed(int *mhz)
{
	*mhz = PAGE0->mem_10msec / 10000;

	return (0);
}

void
hppa_init(paddr_t start)
{
	extern int kernel_text;
	int error;
	paddr_t	avail_end;

	pdc_init();	/* init PDC iface, so we can call em easy */

	delay_init();	/* calculate cpu clock ratio */

	cpuid();

	/* Enable wide mode for PSW defaults. */
	if ((error = pdc_call((iodcio_t)pdc, 0, PDC_PSW, PDC_PSW_SETDEFAULTS,
	    0x2 /* PDC WIDE BIT */)) < 0)
		panic("Failed to enable wide mode for PSW defaults: %d\n",
		    error);

	/* cache parameters */
	if ((error = pdc_call((iodcio_t)pdc, 0, PDC_CACHE, PDC_CACHE_DFLT,
	    &pdc_cache)) < 0) {
#ifdef DEBUG
		printf("WARNING: PDC_CACHE error %d\n", error);
#endif
	}

	dcache_line_mask = pdc_cache.dc_conf.cc_line * 16 - 1;
	dcache_stride = pdc_cache.dc_stride;
	icache_line_mask = pdc_cache.ic_conf.cc_line * 16 - 1;
	icache_stride = pdc_cache.ic_stride;

	/* cache coherence params (pbably available for 8k only) */
	error = pdc_call((iodcio_t)pdc, 0, PDC_CACHE, PDC_CACHE_SETCS,
	    &pdc_coherence, 1, 1, 1, 1);
#ifdef DEBUG
	printf ("PDC_CACHE_SETCS: %d, %d, %d, %d (%d)\n",
	    pdc_coherence.ia_cst, pdc_coherence.da_cst,
	    pdc_coherence.ita_cst, pdc_coherence.dta_cst, error);
#endif
	error = pdc_call((iodcio_t)pdc, 0, PDC_CACHE, PDC_CACHE_GETSPIDB,
	    &pdc_spidbits, 0, 0, 0, 0);
	printf("SPID bits: 0x%x, error = %d\n", pdc_spidbits.spidbits, error);

#if 0
TODO hpmc/toc/pfr
	/* setup hpmc handler */
	{
		extern u_int hpmc_v[];	/* from locore.s */
		u_int *p = hpmc_v;

		if (pdc_call((iodcio_t)pdc, 0, PDC_INSTR, PDC_INSTR_DFLT, p))
			*p = 0x08000240;

		p[6] = (u_int)&hpmc_dump;
		p[7] = 32;
		p[5] = -(p[0] + p[1] + p[2] + p[3] + p[4] + p[6] + p[7]);
	}

	{
		extern u_int hppa_toc[], hppa_toc_end[];
		u_int cksum, *p;

		for (cksum = 0, p = hppa_toc; p < hppa_toc_end; p++)
			cksum += *p;

		*p = cksum;
		PAGE0->ivec_toc = (u_int)&hppa_toc[0];
		PAGE0->ivec_toclen = (hppa_toc_end - hppa_toc + 1) * 4;
	}

	{
		extern u_int hppa_pfr[], hppa_pfr_end[];
		u_int cksum, *p;

		for (cksum = 0, p = hppa_pfr; p < hppa_pfr_end; p++)
			cksum += *p;

		*p = cksum;
		PAGE0->ivec_mempf = (u_int)&hppa_pfr[0];
		PAGE0->ivec_mempflen = (hppa_pfr_end - hppa_pfr + 1) * 4;
	}
#endif
	avail_end = trunc_page(PAGE0->imm_max_mem);
	if (avail_end > 0x4000000)
		avail_end = 0x4000000;
	physmem = atop(avail_end);
	resvmem = atop(((vaddr_t)&kernel_text));

	/* we hope this won't fail */
	hppa_ex = extent_create("mem", 0, HPPA_PHYSMAP, M_DEVBUF,
	    (caddr_t)mem_ex_storage, sizeof(mem_ex_storage),
	    EX_NOCOALESCE|EX_NOWAIT);
	if (extent_alloc_region(hppa_ex, 0, (vaddr_t)PAGE0->imm_max_mem,
	    EX_NOWAIT))
		panic("cannot reserve main memory");

	/* sets resvphysmem */
	pmap_bootstrap(round_page(start));

	/* space has been reserved in pmap_bootstrap() */
	msgbufp = (struct msgbuf *)((vaddr_t)ptoa(physmem) -
	    round_page(MSGBUFSIZE));
	initmsgbuf((caddr_t)msgbufp, round_page(MSGBUFSIZE));
	msgbufmapped = 1;

	/* they say PDC_COPROC might turn fault light on */
	pdc_call((iodcio_t)pdc, 0, PDC_CHASSIS, PDC_CHASSIS_DISP,
	    PDC_OSTAT(PDC_OSTAT_RUN) | 0xCEC0);

	cpu_cpuspeed = &hppa_cpuspeed;

#ifdef DDB
	ddb_init();
	if (boothowto & RB_KDB)
		Debugger();
#endif
	ptlball();
	ficacheall();
	fdcacheall();

	proc0paddr->u_pcb.pcb_fpstate = &proc0fpstate;
	pool_init(&hppa_fppl, sizeof(struct hppa_fpstate), 16, 0, 0,
	    "hppafp", NULL);
	pool_setipl(&hppa_fppl, IPL_NONE);
}

void
cpuid()
{
	extern u_int fpu_enable;
	struct pdc_cpuid pdc_cpuid PDC_ALIGNMENT;
	int error;

	/* identify system type */
	if ((error = pdc_call((iodcio_t)pdc, 0, PDC_MODEL, PDC_MODEL_INFO,
	    &pdc_model)) < 0) {
#ifdef DEBUG
		printf("WARNING: PDC_MODEL error %d\n", error);
#endif
		pdc_model.hvers = 0;
	}

	bzero(&pdc_cpuid, sizeof(pdc_cpuid));
	if (pdc_call((iodcio_t)pdc, 0, PDC_MODEL, PDC_MODEL_CPUID,
	    &pdc_cpuid, 0, 0, 0, 0) >= 0) {

		/* patch for old 8200 */
		if (pdc_cpuid.version == HPPA_CPU_PCXU &&
		    pdc_cpuid.revision > 0x0d)
			pdc_cpuid.version = HPPA_CPU_PCXUP;

		cpu_type = pdc_cpuid.version;
	}

	/* locate coprocessors and SFUs */
	bzero(&pdc_coproc, sizeof(pdc_coproc));
	if ((error = pdc_call((iodcio_t)pdc, 0, PDC_COPROC, PDC_COPROC_DFLT,
	    &pdc_coproc, 0, 0, 0, 0)) < 0)
		printf("WARNING: PDC_COPROC error %d\n", error);
	else {
		printf("pdc_coproc: 0x%x, 0x%x; model %x rev %x\n",
		    pdc_coproc.ccr_enable, pdc_coproc.ccr_present,
		    pdc_coproc.fpu_model, pdc_coproc.fpu_revision);
		fpu_enable = pdc_coproc.ccr_enable & 0xc0;

		/* a kludge to detect PCXW */
		if (pdc_coproc.fpu_model == HPPA_FPU_PCXW)
			cpu_type = HPPA_CPU_PCXW;
	}

	if (!cpu_type)
		printf("WARNING: UNKNOWN CPU TYPE; GOOD LUCK\n");
	cpu_typename = hppa_mod_info(HPPA_TYPE_CPU, cpu_type);

	if (pdc_model.arch_rev != 8)
		panic("CANNOT RUN 64BIT KERNEL on 32BIT CPU");

	{
		const char *p;
		char buf[32];

		cpu_hvers = pdc_model.hvers >> 4;
		if (!cpu_hvers) {
			p = "(UNKNOWN)";
		} else {
			p = hppa_mod_info(HPPA_TYPE_BOARD, cpu_hvers);
			if (!p) {
				snprintf(buf, sizeof buf, "(UNKNOWN 0x%x)",
				    cpu_hvers);
				p = buf;
			}
		}

		snprintf(cpu_model, sizeof cpu_model,
		    "HP 9000/%s PA-RISC 2.0", p);
	}
#ifdef DEBUG
	printf("%s\n", cpu_model);
#endif
}

void
cpu_startup(void)
{
	vaddr_t minaddr, maxaddr;

	/*
	 * psychodelic kingdom come
	 * ... run, run, run
	 * psychodelic kings and queens
	 * join me in this one love dream
	 */
	printf("%s%s\n", version, cpu_model);
	printf("real mem = %lu (%luMB)\n", ptoa((psize_t)physmem),
	    ptoa((psize_t)physmem) / 1024 / 1024);
	printf("rsvd mem = %lu (%luKB)\n", ptoa(resvmem), ptoa(resvmem) / 1024);

	/*
	 * Allocate a submap for exec arguments.  This map effectively
	 * limits the number of processes exec'ing at any time.
	 */
	minaddr = vm_map_min(kernel_map);
	exec_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
	    16*NCARGS, VM_MAP_PAGEABLE, FALSE, NULL);

	/*
	 * Allocate a submap for physio
	 */
	phys_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
	    VM_PHYS_SIZE, 0, FALSE, NULL);

	printf("avail mem = %lu (%luMB)\n", ptoa(uvmexp.free),
	    ptoa(uvmexp.free) / 1024 / 1024);

	/*
	 * Set up buffers, so they can be used to read disk labels.
	 */
	bufinit();

	/*
	 * Configure the system.
	 */
	if (boothowto & RB_CONFIG) {
#ifdef BOOT_CONFIG
		user_config();
#else
		printf("kernel does not support -c; continuing..\n");
#endif
	}
}

/*
 * compute cpu clock ratio such as:
 *	cpu_ticksnum / cpu_ticksdenom = t + delta
 *	delta -> 0
 */
void
delay_init(void)
{
	u_long num, denom, delta, mdelta;

	mdelta = ULONG_MAX;
	for (denom = 1; denom < 1000; denom++) {
		num = (PAGE0->mem_10msec * denom) / 10000;
		delta = num * 10000 / denom - PAGE0->mem_10msec;
		if (!delta) {
			cpu_ticksdenom = denom;
			cpu_ticksnum = num;
			break;
		} else if (delta < mdelta) {
			cpu_ticksdenom = denom;
			cpu_ticksnum = num;
			mdelta = delta;
		}
	}
}

void
delay(u_int us)
{
	u_long start, end, n;

	start = mfctl(CR_ITMR);
	while (us) {
		n = min(1000, us);
		end = start + n * cpu_ticksnum / cpu_ticksdenom;

		/* N.B. Interval Timer may wrap around */
		if (end < start)
			do
				start = mfctl(CR_ITMR);
			while (start > end);

		do
			start = mfctl(CR_ITMR);
		while (start < end);

		us -= n;
	}
}

static __inline void
fall(int c_base, int c_count, int c_loop, int c_stride, int data)
{
	int loop;

	for (; c_count--; c_base += c_stride)
		for (loop = c_loop; loop--; )
			if (data)
				__asm volatile("fdce 0(%%sr0,%0)"
				    :: "r" (c_base));
			else
				__asm volatile("fice 0(%%sr0,%0)"
				    :: "r" (c_base));
}

void
ficacheall(void)
{
	/*
	 * Flush the instruction, then data cache.
	 */
	fall(pdc_cache.ic_base, pdc_cache.ic_count, pdc_cache.ic_loop,
	    pdc_cache.ic_stride, 0);
	sync_caches();
}

void
fdcacheall(void)
{
	fall(pdc_cache.dc_base, pdc_cache.dc_count, pdc_cache.dc_loop,
	    pdc_cache.dc_stride, 1);
	sync_caches();
}

void
ptlball(void)
{
	pa_space_t sp;
	int i, j, k;

	/* instruction TLB */
	sp = pdc_cache.it_sp_base;
	for (i = 0; i < pdc_cache.it_sp_count; i++) {
		vaddr_t off = pdc_cache.it_off_base;
		for (j = 0; j < pdc_cache.it_off_count; j++) {
			for (k = 0; k < pdc_cache.it_loop; k++)
				pitlbe(sp, off);
			off += pdc_cache.it_off_stride;
		}
		sp += pdc_cache.it_sp_stride;
	}

	/* data TLB */
	sp = pdc_cache.dt_sp_base;
	for (i = 0; i < pdc_cache.dt_sp_count; i++) {
		vaddr_t off = pdc_cache.dt_off_base;
		for (j = 0; j < pdc_cache.dt_off_count; j++) {
			for (k = 0; k < pdc_cache.dt_loop; k++)
				pdtlbe(sp, off);
			off += pdc_cache.dt_off_stride;
		}
		sp += pdc_cache.dt_sp_stride;
	}
}

int waittime = -1;

__dead void
boot(int howto)
{
	/*
	 * On older systems without software power control, prevent mi code
	 * from spinning disks off, in case the operator changes his mind
	 * and prefers to reboot - the firmware will not send a spin up
	 * command to the disks.
	 */
	if (cold_hook == NULL)
		howto &= ~RB_POWERDOWN;

	if (cold) {
		if ((howto & RB_USERREQ) == 0)
			howto |= RB_HALT;
		goto haltsys;
	}

	boothowto = howto | (boothowto & RB_HALT);

	if ((howto & RB_NOSYNC) == 0) {
		waittime = 0;
		vfs_shutdown();

		if ((howto & RB_TIMEBAD) == 0) {
			resettodr();
		} else {
			printf("WARNING: not updating battery clock\n");
		}
	}
	if_downall();

	uvm_shutdown();
	splhigh();
	cold = 1;

	if ((howto & RB_DUMP) != 0)
		dumpsys();

haltsys:
	config_suspend_all(DVACT_POWERDOWN);

	/* in case we came on powerfail interrupt */
	if (cold_hook)
		(*cold_hook)(HPPA_COLD_COLD);

	if ((howto & RB_HALT) != 0) {
		if ((howto & RB_POWERDOWN) != 0) {
			printf("Powering off...");
			DELAY(2000000);
			(*cold_hook)(HPPA_COLD_OFF);
			DELAY(1000000);
		}

		printf("System halted!\n");
		DELAY(2000000);
		__asm volatile("stwas %0, 0(%1)"
		    :: "r" (CMD_STOP), "r" (HPPA_LBCAST + iomod_command));
	} else {
		printf("rebooting...");
		DELAY(2000000);

		/* ask firmware to reset */
                pdc_call((iodcio_t)pdc, 0, PDC_BROADCAST_RESET, PDC_DO_RESET);

		/* forcably reset module if that fails */
		__asm volatile(".export hppa_reset, entry\n\t"
		    ".label hppa_reset");
		__asm volatile("stwas %0, 0(%1)"
		    :: "r" (CMD_RESET), "r" (HPPA_LBCAST + iomod_command));
	}

	for (;;) ;
	/* NOTREACHED */
}

u_long	dumpmag = 0x8fca0101;	/* magic number */
int	dumpsize = 0;		/* pages */
long	dumplo = 0;		/* blocks */

/*
 * cpu_dumpsize: calculate size of machine-dependent kernel core dump headers.
 */
int
cpu_dumpsize(void)
{
	int size;

	size = ALIGN(sizeof(kcore_seg_t)) + ALIGN(sizeof(cpu_kcore_hdr_t));
	if (roundup(size, dbtob(1)) != dbtob(1))
		return -1;

	return 1;
}

/*
 * Called from HPMC handler in locore
 */
void
hpmc_dump(void)
{
	cold = 0;
	panic("HPMC");
	/* NOTREACHED */
}

int
cpu_dump(void)
{
	long buf[dbtob(1) / sizeof (long)];
	kcore_seg_t	*segp;
	cpu_kcore_hdr_t	*cpuhdrp;

	segp = (kcore_seg_t *)buf;
	cpuhdrp = (cpu_kcore_hdr_t *)&buf[ALIGN(sizeof(*segp)) / sizeof (long)];

	/*
	 * Generate a segment header.
	 */
	CORE_SETMAGIC(*segp, KCORE_MAGIC, MID_MACHINE, CORE_CPU);
	segp->c_size = dbtob(1) - ALIGN(sizeof(*segp));

	/*
	 * Add the machine-dependent header info
	 */
	/* nothing for now */

	return (bdevsw[major(dumpdev)].d_dump)
	    (dumpdev, dumplo, (caddr_t)buf, dbtob(1));
}

/*
 * Dump the kernel's image to the swap partition.
 */
#define	BYTES_PER_DUMP	NBPG

void
dumpsys(void)
{
	int psize, bytes, i, n;
	caddr_t maddr;
	daddr_t blkno;
	int (*dump)(dev_t, daddr_t, caddr_t, size_t);
	int error;

	/* Save registers
	savectx(&dumppcb); */

	if (dumpsize == 0)
		dumpconf();
	if (dumplo <= 0) {
		printf("\ndump to dev %x not possible\n", dumpdev);
		return;
	}
	printf("\ndumping to dev %x, offset %ld\n", dumpdev, dumplo);

	psize = (*bdevsw[major(dumpdev)].d_psize)(dumpdev);
	printf("dump ");
	if (psize == -1) {
		printf("area unavailable\n");
		return;
	}

	if (!(error = cpu_dump())) {

		bytes = ptoa(physmem);
		maddr = NULL;
		blkno = dumplo + cpu_dumpsize();
		dump = bdevsw[major(dumpdev)].d_dump;
		for (i = 0; i < bytes; i += n) {

			/* Print out how many MBs we are to go. */
			n = bytes - i;
			if (n && (n % (1024*1024)) == 0)
				printf("%d ", n / (1024 * 1024));

			/* Limit size for next transfer. */
			if (n > BYTES_PER_DUMP)
				n = BYTES_PER_DUMP;

			if ((error = (*dump)(dumpdev, blkno, maddr, n)))
				break;
			maddr += n;
			blkno += btodb(n);
		}
	}

	switch (error) {
	case ENXIO:	printf("device bad\n");			break;
	case EFAULT:	printf("device not ready\n");		break;
	case EINVAL:	printf("area improper\n");		break;
	case EIO:	printf("i/o error\n");			break;
	case EINTR:	printf("aborted from console\n");	break;
	case 0:		printf("succeeded\n");			break;
	default:	printf("error %d\n", error);		break;
	}
}

/* bcopy(), error on fault */
int
kcopy(const void *from, void *to, size_t size)
{
	return spcopy(HPPA_SID_KERNEL, from, HPPA_SID_KERNEL, to, size);
}

int
copystr(const void *src, void *dst, size_t size, size_t *lenp)
{
	return spstrcpy(HPPA_SID_KERNEL, src, HPPA_SID_KERNEL, dst, size, lenp);
}

int
copyinstr(const void *src, void *dst, size_t size, size_t *lenp)
{
	return spstrcpy(curproc->p_addr->u_pcb.pcb_space, src,
	    HPPA_SID_KERNEL, dst, size, lenp);
}


int
copyoutstr(const void *src, void *dst, size_t size, size_t *lenp)
{
	return spstrcpy(HPPA_SID_KERNEL, src,
	    curproc->p_addr->u_pcb.pcb_space, dst, size, lenp);
}


int
copyin(const void *src, void *dst, size_t size)
{
	return spcopy(curproc->p_addr->u_pcb.pcb_space, src,
	    HPPA_SID_KERNEL, dst, size);
}

int
copyout(const void *src, void *dst, size_t size)
{
	return spcopy(HPPA_SID_KERNEL, src,
	    curproc->p_addr->u_pcb.pcb_space, dst, size);
}

/*
 * Set up tf_sp and tf_r3 (the frame pointer) and copy out the
 * frame marker and the old r3.
 * XXX old_r3 is always zero on hppa64?  It's non-zero on hppa in sendsig()
 * XXX Set up tf_ret1 (aka "ap") too?
 */
int
setstack(struct trapframe *tf, u_long stack, register_t old_r3)
{
	static const register_t zero = 0;
	int err;

	tf->tf_r3 = stack;
	err = copyout(&old_r3, (caddr_t)stack, sizeof(register_t));

	tf->tf_sp = stack += HPPA_FRAME_SIZE;
	return (copyout(&zero, (caddr_t)(stack + HPPA_FRAME_RP),
	    sizeof(register_t)) || err);
}

/*
 * Set registers on exec.
 */
void
setregs(struct proc *p, struct exec_package *pack, u_long stack,
    register_t *retval)
{
	struct trapframe *tf = p->p_md.md_regs;
	struct pcb *pcb = &p->p_addr->u_pcb;

	tf->tf_flags = TFF_SYS|TFF_LAST;
	tf->tf_iioq[1] = 4 +
	    (tf->tf_iioq[0] = pack->ep_entry | HPPA_PC_PRIV_USER);
	tf->tf_rp = 0;
	tf->tf_args[0] = p->p_p->ps_strings;
	tf->tf_args[1] = tf->tf_args[2] = 0; /* XXX dynload stuff */

	/* setup terminal stack frame */
	setstack(tf, (stack + 0x1f) & ~0x1f, 0);
	tf->tf_ret1 = tf->tf_sp - 16;	/* ap */

	/* reset any of the pending FPU exceptions */
	fpu_proc_flush(p);
	pcb->pcb_fpstate->hfp_regs.fpr_regs[0] =
	    ((u_int64_t)HPPA_FPU_INIT) << 32;
	pcb->pcb_fpstate->hfp_regs.fpr_regs[1] = 0;
	pcb->pcb_fpstate->hfp_regs.fpr_regs[2] = 0;
	pcb->pcb_fpstate->hfp_regs.fpr_regs[3] = 0;

	retval[1] = 0;
}

/*
 * Send an interrupt to process.
 */
void
sendsig(sig_t catcher, int sig, int mask, u_long code, int type,
    union sigval val)
{
	struct proc *p = curproc;
	struct trapframe *tf = p->p_md.md_regs;
	struct pcb *pcb = &p->p_addr->u_pcb;
	struct sigacts *psp = p->p_p->ps_sigacts;
	struct sigcontext ksc;
	siginfo_t ksi;
	register_t scp, sip;
	int sss;

#ifdef DEBUG
	if ((sigdebug & SDB_FOLLOW) && (!sigpid || p->p_pid == sigpid))
		printf("sendsig: %s[%d] sig %d catcher %p\n",
		    p->p_comm, p->p_pid, sig, catcher);
#endif

	/* Save the FPU context first. */
	fpu_proc_save(p);

	/*
	 * Allocate space for the signal handler context.
	 */
	if ((p->p_sigstk.ss_flags & SS_DISABLE) == 0 &&
	    !sigonstack(tf->tf_sp) && (psp->ps_sigonstack & sigmask(sig)))
		scp = (register_t)p->p_sigstk.ss_sp;
	else
		scp = (tf->tf_sp + 63) & ~63;

	sss = (sizeof(ksc) + 63) & ~63;
	sip = 0;
	if (psp->ps_siginfo & sigmask(sig)) {
		sip = scp + sizeof(ksc);
		sss += (sizeof(ksi) + 63) & ~63;
	}

#ifdef DEBUG
	if ((tf->tf_iioq[0] & ~PAGE_MASK) == SYSCALLGATE)
		printf("sendsig: interrupted syscall at 0x%x:0x%x, flags %b\n",
		    tf->tf_iioq[0], tf->tf_iioq[1], tf->tf_ipsw, PSL_BITS);
#endif

	bzero(&ksc, sizeof(ksc));
	ksc.sc_mask = mask;
	ksc.sc_fp = scp + sss;
	ksc.sc_ps = tf->tf_ipsw;
	ksc.sc_pcoqh = tf->tf_iioq[0];
	ksc.sc_pcoqt = tf->tf_iioq[1];
	bcopy(tf, &ksc.sc_regs[0], 32*8);
	ksc.sc_regs[0] = tf->tf_sar;
	bcopy(&p->p_addr->u_pcb.pcb_fpstate->hfp_regs, ksc.sc_fpregs,
	    sizeof(ksc.sc_fpregs));

	if (setstack(tf, scp + sss, 0))
		sigexit(p, SIGILL);

	tf->tf_args[0] = sig;
	tf->tf_args[1] = sip;
	tf->tf_args[2] = tf->tf_r4 = scp;
	tf->tf_args[3] = (register_t)catcher;
	tf->tf_ipsw &= ~(PSL_N|PSL_B|PSL_T);
	tf->tf_iioq[0] = HPPA_PC_PRIV_USER | p->p_p->ps_sigcode;
	tf->tf_iioq[1] = tf->tf_iioq[0] + 4;
	tf->tf_iisq[0] = tf->tf_iisq[1] = pcb->pcb_space;
	/* disable tracing in the trapframe */

#ifdef DEBUG
	if ((sigdebug & SDB_FOLLOW) && (!sigpid || p->p_pid == sigpid))
		printf("sendsig(%d): sig %d scp %p fp %p sp 0x%x\n",
		    p->p_pid, sig, scp, ksc.sc_fp, tf->tf_sp);
#endif

	ksc.sc_cookie = (long)scp ^ p->p_p->ps_sigcookie;
	if (copyout(&ksc, (void *)scp, sizeof(ksc)))
		sigexit(p, SIGILL);

	if (sip) {
		initsiginfo(&ksi, sig, code, type, val);
		if (copyout(&ksi, (void *)sip, sizeof(ksi)))
			sigexit(p, SIGILL);
	}

#ifdef DEBUG
	if ((sigdebug & SDB_FOLLOW) && (!sigpid || p->p_pid == sigpid))
		printf("sendsig(%d): pc 0x%x, catcher 0x%x\n", p->p_pid,
		    tf->tf_iioq[0], tf->tf_args[3]);
#endif
}

int
sys_sigreturn(struct proc *p, void *v, register_t *retval)
{
	struct sys_sigreturn_args /* {
		syscallarg(struct sigcontext *) sigcntxp;
	} */ *uap = v;
	struct sigcontext *scp = SCARG(uap, sigcntxp), ksc;
	struct trapframe *tf = p->p_md.md_regs;
	int error;

	if (PROC_PC(p) != p->p_p->ps_sigcoderet) {
		printf("%s(%d): sigreturn not from tramp [pc 0x%lx 0x%lx]\n",
		    p->p_comm, p->p_pid, PROC_PC(p), p->p_p->ps_sigcoderet);
		sigexit(p, SIGILL);
		return (EPERM);
	}

	/* flush the FPU ctx first */
	fpu_proc_flush(p);

	if ((error = copyin((caddr_t)scp, (caddr_t)&ksc, sizeof ksc)))
		return (error);

	if (ksc.sc_cookie != ((long)scp ^ p->p_p->ps_sigcookie)) {
		printf("%s(%d): cookie %lx should have been %lx\n",
		    p->p_comm, p->p_pid, ksc.sc_cookie,
		    (long)scp ^ p->p_p->ps_sigcookie);
		sigexit(p, SIGILL);
		return (EFAULT);
	}

	/* Prevent reuse of the sigcontext cookie */
	ksc.sc_cookie = 0;
	(void)copyout(&ksc.sc_cookie, (caddr_t)scp +
	    offsetof(struct sigcontext, sc_cookie),
	    sizeof (ksc.sc_cookie));

#define PSL_MBS (PSL_C|PSL_Q|PSL_P|PSL_D|PSL_I)
#define PSL_MBZ (PSL_Y|PSL_Z|PSL_S|PSL_X|PSL_M|PSL_R)
	if ((ksc.sc_ps & (PSL_MBS|PSL_MBZ)) != PSL_MBS)
		return (EINVAL);

	p->p_sigmask = ksc.sc_mask &~ sigcantmask;

	tf->tf_sar = ksc.sc_regs[0];
	ksc.sc_regs[0] = tf->tf_flags;
	bcopy(&ksc.sc_regs[0], tf, 32*8);
	bcopy(ksc.sc_fpregs, &p->p_addr->u_pcb.pcb_fpstate->hfp_regs,
	    sizeof(ksc.sc_fpregs));

	tf->tf_iioq[0] = ksc.sc_pcoqh | HPPA_PC_PRIV_USER;
	tf->tf_iioq[1] = ksc.sc_pcoqt | HPPA_PC_PRIV_USER;
	if ((tf->tf_iioq[0] & ~PAGE_MASK) == SYSCALLGATE)
		tf->tf_iisq[0] = HPPA_SID_KERNEL;
	else
		tf->tf_iisq[0] = p->p_addr->u_pcb.pcb_space;
	if ((tf->tf_iioq[1] & ~PAGE_MASK) == SYSCALLGATE)
		tf->tf_iisq[1] = HPPA_SID_KERNEL;
	else
		tf->tf_iisq[1] = p->p_addr->u_pcb.pcb_space;
	tf->tf_ipsw = ksc.sc_ps | (curcpu()->ci_psw & PSL_O);

#ifdef DEBUG
	if ((sigdebug & SDB_FOLLOW) && (!sigpid || p->p_pid == sigpid))
		printf("sigreturn(%d): returns\n", p->p_pid);
#endif
	return (EJUSTRETURN);
}

/*
 * machine dependent system variables.
 */
int
cpu_sysctl(int *name, u_int namelen, void *oldp, size_t *oldlenp, void *newp,
    size_t newlen, struct proc *p)
{
	dev_t consdev;

	/* all sysctl names at this level are terminal */
	if (namelen != 1)
		return (ENOTDIR);	/* overloaded */
	switch (name[0]) {
	case CPU_CONSDEV:
		if (cn_tab != NULL)
			consdev = cn_tab->cn_dev;
		else
			consdev = NODEV;
		return (sysctl_rdstruct(oldp, oldlenp, newp, &consdev,
		    sizeof consdev));
	default:
		return (EOPNOTSUPP);
	}
	/* NOTREACHED */
}


/*
 * consinit:
 * initialize the system console.
 */
void
consinit(void)
{
	/*
	 * Initial console setup has been done in pdc_init().
	 */
}

#ifdef DIAGNOSTIC
void
splassert_check(int wantipl, const char *func)
{
	struct cpu_info *ci = curcpu();

	if (ci->ci_cpl < wantipl)
		splassert_fail(wantipl, ci->ci_cpl, func);
}
#endif
@


1.80
log
@SROP mitigation.  sendsig() stores a (per-process ^ &sigcontext) cookie
inside the sigcontext.  sigreturn(2) checks syscall entry was from the
exact PC addr in the (per-process ASLR) sigtramp, verifies the cookie,
and clears it to prevent sigcontext reuse.
not yet tested on landisk, sparc, *88k, socppc.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.79 2016/04/20 23:52:04 dlg Exp $	*/
@


1.79
log
@pool_setipl for floating point context things

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.78 2015/10/21 07:59:18 mpi Exp $	*/
d903 1
d926 1
a926 1
	struct sigcontext *scp, ksc;
d930 6
a935 5
	scp = SCARG(uap, sigcntxp);
#ifdef DEBUG
	if ((sigdebug & SDB_FOLLOW) && (!sigpid || p->p_pid == sigpid))
		printf("sigreturn: pid %d, scp %p\n", p->p_pid, scp);
#endif
d942 14
@


1.78
log
@Do not call uvm_swap_finicrypt_all() a second time in dumpsys().

ok tedu@@, deraadt@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.77 2015/01/20 19:43:20 kettenis Exp $	*/
d288 1
@


1.77
log
@Move ps_strings "after" the random stackgap.  This makes its location a
per-process value, and therefpore turns the VM_PSSTRINGS sysctl into a
per-process one as well.  This gets rid of a pointer to the bottom of the
stack at a fixed location.  Also clears the road for unmapping the stackgap.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.76 2014/12/10 15:29:53 mikeb Exp $	*/
a686 4

#ifdef UVM_SWAP_ENCRYPT
	uvm_swap_finicrypt_all();
#endif
@


1.76
log
@retire shutdown hooks; ok deraadt, krw
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.75 2014/10/25 17:31:26 kettenis Exp $	*/
d811 1
a811 1
	tf->tf_args[0] = (u_long)PS_STRINGS;
@


1.75
log
@Remove vmmap; it isn't used.

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.74 2014/10/12 20:39:46 miod Exp $	*/
a571 1
	doshutdownhooks();
@


1.74
log
@Rough sync with hppa to make this compile again.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.73 2014/09/19 18:21:14 kettenis Exp $	*/
a122 2
/* Virtual page frame for /dev/mem (see mem.c) */
vaddr_t vmmap;
a401 1
	vmmap = uvm_km_valloc_wait(kernel_map, NBPG);
@


1.73
log
@Use config_suspend_all(9).
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.72 2014/08/18 05:11:03 dlg Exp $	*/
d381 1
a381 1
	printf("rsvd mem = %u (%uKB)\n", ptoa(resvmem), ptoa(resvmem) / 1024);
@


1.72
log
@dont rely on mbuf.h to provide pool.h.

ok miod@@, who has offerred to help with any MD fallout
ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.71 2014/07/22 01:04:04 uebayasi Exp $	*/
a537 2
	struct device *mainbus;

d576 1
a576 3
	mainbus = device_mainbus();
	if (mainbus != NULL)
		config_suspend(mainbus, DVACT_POWERDOWN);
@


1.71
log
@boot(9): Reduce diffs between hppa & hppa64 (& others)
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d32 1
a32 1
#include <sys/mbuf.h>
@


1.70
log
@boot(9): Reduce annoying style diffs

- Always use either: ((x & RB_XXX) != 0) or ((x & RB_XXX) == 0) in boolean
  context (mostly if (x), or x ? y : z)
  - prom_halt() in alpha is confirmed to take int as boolean

Converted by coccinelle.  No functional change intended.
@
text
@d540 9
d587 1
a587 1
		if ((howto & RB_POWERDOWN) != 0 && cold_hook) {
@


1.69
log
@boot(9): Cosmetic changes to improve diff'ability.
@
text
@d548 1
a548 1
	if (!(howto & RB_NOSYNC)) {
d564 1
a564 1
	if (howto & RB_DUMP)
d577 2
a578 2
	if (howto & RB_HALT) {
		if (howto & RB_POWERDOWN && cold_hook) {
@


1.68
log
@Cosmetic changes to reduce diffs.
@
text
@d603 1
a603 1
	for (;;) ; /* loop while bus reset is coming up */
@


1.67
log
@These still need <sys/reboot.h> for the RB_ constants.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.66 2014/07/12 22:37:03 uebayasi Exp $	*/
d552 1
a552 1
		if ((howto & RB_TIMEBAD) == 0)
d554 1
a554 1
		else
d556 1
@


1.66
log
@reboot(9), panic(9): Call panic(9) for unrecoverable MD H/W errors (NMIs)

Some architectures have ability to detect hardware sanity and notify system
(NMI, firmware callback, etc.).  Handle these hardware severe errors, same
as software errors, with panic(9).

According to miod@@, SGI IP27 NMI is triggered by pushing some "hidden" button,
which "usual" users/admins don't know.  Pushing such a button is "RB_USERREQ"
(human-triggered) in that the button is pushed by a human, but not "RB_USERREQ"
in that no user intervention in system (== no command input) is done.  miod@@
agreed that changing these from RB_USERREQ to !RB_USERREQ (== panic(9)) is
not a big problem.

OK miod@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d26 1
@


1.65
log
@boot(9), reboot(9): Migrate MD callers of boot(9) to reboot(9)

I have found that some ports call boot(9) from machine-dependent code to
reboot system.  These should be changed to either:

- Sending signal to init(8) to trigger it to shutdown system cleanly, like
  acpi(4) does, in cases where found problems don't prevent system from working
  immediately, or

- Just doing panic(9) if the situation is severely broken.

For now, just rewrite boot() to reboot().  Actual fixes follow.

Discussed with & OK from kettenis@@
@
text
@a25 1
#include <sys/reboot.h>
a629 2
	printf("HPMC\n");

d631 2
a632 1
	reboot(RB_NOSYNC);
@


1.64
log
@Set cold to 1 before executing the DVACT_POWERDOWN handlers when halting or
rebooting a machine, like it is done in the hibernate case.

At least some USB host controller drivers rely on this to busy way instead
of sleeping.  Avoid a panic on macppc with an uhci(4) cardbus plugged in.

ok deraadt@@, uebayashi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.63 2014/07/10 20:15:27 uebayasi Exp $	*/
d634 1
a634 1
	boot(RB_NOSYNC);
@


1.63
log
@boot(9): Remove comments about RB_*, "cold", and savectx()

Again remove slightly different comments to reduce diffs.  These will be
re-added once boot() become MI and its specification is clearly re-defined.

OK miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a558 2
	/* XXX probably save howto into stable storage */

d561 1
@


1.62
log
@boot(): Remove comments about RB_TIMEBAD to reduce diffs

RB_TIMEBAD is documented well enough that the comment is not needed.  sparc64
does slightly different and its comment is left with XXX.

OK deraadt@@ miod@@
@
text
@a539 1
	/* If system is cold, just halt. */
a540 1
		/* (Unless the user explicitly asked for reboot.) */
@


1.61
log
@boot(): Unify declarations

OK deraadt@@
@
text
@d553 1
a553 5
		/*
		 * If we've been adjusting the clock, the todr
		 * will be out of synch; adjust it now unless
		 * the system was sitting in ddb.
		 */
@


1.60
log
@Revert previous diff setting cold to 1 on shutdown because it breaks machine
with softraid(4) disks.

softraid(4) is the last real consumer of the doshutdownhooks(9) API and it is
not trivial to convert its hook to a DVACT_POWERDOWN handler since the latter
does not allow to sleep.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.59 2014/05/30 13:46:16 mpi Exp $	*/
d535 1
a535 1
void
@


1.59
log
@Set cold to 1 before executing the DVACT_POWERDOWN handlers when halting or
rebooting a machine, like it is done in the hibernate case.

At least some USB host controller drivers rely on this to busy way instead
of sleeping.  Avoid a panic on macppc with an uhci(4) cardbus plugged in.

ok deraadt@@, uebayashi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.58 2014/04/08 09:34:23 mpi Exp $	*/
d565 2
a568 1
	cold = 1;
@


1.58
log
@Less <uvm/uvm.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.57 2014/03/29 18:09:29 guenther Exp $	*/
a564 2
	/* XXX probably save howto into stable storage */

d567 1
@


1.57
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.56 2014/03/26 05:23:42 guenther Exp $	*/
a48 2
#include <uvm/uvm_page.h>
#include <uvm/uvm_swap.h>
@


1.56
log
@Move p_emul and p_sigcode from proc to process.
Tweak the handling of ktrace EMUL when changing ktracing: only
generate one per process (not one per thread) and pass the correct
proc pointer down to the VFS layer.  Permit generating of NAMI and
CSW records inside ktrace(2) itself.

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.55 2014/03/22 06:05:45 guenther Exp $	*/
d478 1
a478 1
				__asm __volatile("fdce 0(%%sr0,%0)"
d481 1
a481 1
				__asm __volatile("fice 0(%%sr0,%0)"
d595 1
a595 1
		__asm __volatile("stwas %0, 0(%1)"
d605 1
a605 1
		__asm __volatile(".export hppa_reset, entry\n\t"
d607 1
a607 1
		__asm __volatile("stwas %0, 0(%1)"
@


1.55
log
@Move p_sigacts from struct proc to struct process.

testing help mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.54 2014/03/13 03:52:55 dlg Exp $	*/
d903 1
a903 1
	tf->tf_iioq[0] = HPPA_PC_PRIV_USER | p->p_sigcode;
@


1.54
log
@get rid of the assumption that the head of the alldevs list is the
"mainbus" device. this breaks when mpath is enabled because it
attaches before mainbus and therefore takes the head position.

have autoconf provide device_mainbus() which looks up mainbus_cd,
and use that instead.

discussed with deraadt who just wants mpath stuff to move forward
despite there being many ways to shine this particular turd.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.53 2013/11/23 07:20:52 uebayasi Exp $	*/
d847 1
a847 1
	struct sigacts *psp = p->p_sigacts;
@


1.53
log
@Run doshutdownhooks() and config_suspend() even when boot() is called while
cold != 0.  Indent and make hppa/hppa64 boot() closer to others.

OK kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d540 2
d577 3
a579 2
	if (!TAILQ_EMPTY(&alldevs))
		config_suspend(TAILQ_FIRST(&alldevs), DVACT_POWERDOWN);
@


1.52
log
@In boot(), do not iterate over alldevs if it's empty (i.e. halting from ddb
with ddb entered early with boot -d or from UKC).
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.51 2013/06/11 16:42:08 deraadt Exp $	*/
d545 2
a546 20
	} else {

		boothowto = howto | (boothowto & RB_HALT);

		if (!(howto & RB_NOSYNC)) {
			waittime = 0;
			vfs_shutdown();
			/*
			 * If we've been adjusting the clock, the todr
			 * will be out of synch; adjust it now unless
			 * the system was sitting in ddb.
			 */
			if ((howto & RB_TIMEBAD) == 0)
				resettodr();
			else
				printf("WARNING: not updating battery clock\n");
		}
		if_downall();

		/* XXX probably save howto into stable storage */
d548 1
a548 2
		uvm_shutdown();
		splhigh();
d550 27
a576 7
		if (howto & RB_DUMP)
			dumpsys();

		doshutdownhooks();
		if (!TAILQ_EMPTY(&alldevs))
			config_suspend(TAILQ_FIRST(&alldevs), DVACT_POWERDOWN);
	}
@


1.51
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.50 2012/12/02 07:03:31 guenther Exp $	*/
d573 2
a574 1
		config_suspend(TAILQ_FIRST(&alldevs), DVACT_POWERDOWN);
@


1.50
log
@Determine whether we're currently on the alternative signal stack
dynamically, by comparing the stack pointer against the altstack
base and size, so that you get the correct answer if you longjmp
out of the signal handler, as tested by regress/sys/kern/stackjmp/.
Also, fix alt stack handling on vax, where it was completely broken.

Testing and corrections by miod@@, krw@@, tobiasu@@, pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.49 2012/10/08 21:47:48 deraadt Exp $	*/
d676 2
a677 2
	daddr64_t blkno;
	int (*dump)(dev_t, daddr64_t, caddr_t, size_t);
@


1.49
log
@Revamp the sequences for suspend/hibernate -> resume so that the code
paths are reflexive.  It is now possible to fail part-way through a
suspend sequence, and recover along the resume code path.
Split DVACT_SUSPEND by adding a new DVACT_POWERDOWN method is used
after hibernate (and suspend too) to finish the job.  Some drivers
must be converted at the same time to use this instead of shutdown hooks
(the others will follow at a later time)
ok kettenis mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.48 2012/07/13 15:10:51 jsing Exp $	*/
a856 2
	ksc.sc_onstack = p->p_sigstk.ss_flags & SS_ONSTACK;

d860 2
a861 2
	if ((p->p_sigstk.ss_flags & SS_DISABLE) == 0 && !ksc.sc_onstack &&
	    (psp->ps_sigonstack & sigmask(sig))) {
d863 1
a863 2
		p->p_sigstk.ss_flags |= SS_ONSTACK;
	} else
d879 1
a951 4
	if (ksc.sc_onstack)
		p->p_sigstk.ss_flags |= SS_ONSTACK;
	else
		p->p_sigstk.ss_flags &= ~SS_ONSTACK;
@


1.48
log
@Make hppa64 kernel compile again.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.47 2012/07/13 14:28:13 deraadt Exp $	*/
d573 1
@


1.47
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.46 2012/06/21 00:56:59 guenther Exp $	*/
d795 1
a795 1
	return (copyout(&zero, (caddr_t)(stack + HPPA_FRAME_CRP),
@


1.46
log
@__tfork() needs to set the stack address of the new thread in the kernel,
so that it can't get a signal while still running on the parent thread's
stack.  Also, pass in sizeof(struct __tfork) to provide forward compat
when more members are added.  This is an ABI change, so switch syscall
numbers and bump lib majors this time.

ok deraadt@@ matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.45 2011/09/22 21:48:34 jsing Exp $	*/
d605 1
a605 1
	for (;;) ; /* loop while bus reset is comming up */
@


1.45
log
@Declare waittime variable to unbreak build.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.44 2011/09/22 13:50:30 deraadt Exp $	*/
d780 20
a807 1
	register_t zero;
d817 2
a818 7
	stack = (stack + 0x1f) & ~0x1f;
	tf->tf_r3 = stack;
	tf->tf_sp = stack += HPPA_FRAME_SIZE;
	tf->tf_ret1 = stack - 16;	/* ap */
	zero = 0;
	copyout(&zero, (caddr_t)(stack - HPPA_FRAME_SIZE), sizeof(register_t));
	copyout(&zero, (caddr_t)(stack + HPPA_FRAME_RP), sizeof(register_t));
d844 1
a844 1
	register_t scp, sip, zero;
d891 3
a893 1
	sss += HPPA_FRAME_SIZE;
a897 1
	tf->tf_sp = scp + sss;
d907 1
a907 1
		    p->p_pid, sig, scp, ksc.sc_fp, (register_t)scp + sss);
a917 5

	zero = 0;
	if (copyout(&zero, (caddr_t)scp + sss - HPPA_FRAME_SIZE,
	    sizeof(register_t)))
		sigexit(p, SIGILL);
@


1.44
log
@Start removing some tiny irrelevant differences between hppa64 and hppa
so that important differences can be spotted easier.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.43 2011/09/20 13:56:44 jsing Exp $	*/
d534 2
@


1.43
log
@Use correct index for second iioq/iisq fix up.

Spotted by miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.42 2011/09/19 13:21:15 jsing Exp $	*/
d415 1
a415 1
		printf("kernel does not support -c; continuing...\n");
d548 1
d596 1
d603 1
a603 1
	for(;;); /* loop while bus reset is comming up */
@


1.42
log
@Remove some unnecessary debug code.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.40 2011/08/16 17:36:37 kettenis Exp $	*/
d957 2
a958 2
	if ((tf->tf_iioq[0] & ~PAGE_MASK) == SYSCALLGATE)
		tf->tf_iisq[0] = HPPA_SID_KERNEL;
d960 1
a960 1
		tf->tf_iisq[0] = p->p_addr->u_pcb.pcb_space;
@


1.41
log
@Some fixes for the signal handling code.
@
text
@a384 1
printf("here3\n");
a392 1
printf("here4\n");
a398 1
printf("here5\n");
a407 1
printf("here6\n");
d415 1
a415 1
		printf("kernel does not support -c; continuing..\n");
a417 1
printf("here7\n");
a443 1
printf("nom=%lu denom=%lu\n", cpu_ticksnum, cpu_ticksdenom);
@


1.40
log
@Use pitlbe and pdtlbe instructions when flushing the entire TLB.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.39 2011/07/05 04:48:01 guenther Exp $	*/
d828 1
a834 2
	/* TODO sendsig */

d885 1
a885 1
	tf->tf_ipsw &= ~(PSL_N|PSL_B);
d888 1
a927 2
	/* TODO sigreturn */

d957 11
a967 3
	tf->tf_iioq[0] = ksc.sc_pcoqh;
	tf->tf_iioq[1] = ksc.sc_pcoqt;
	tf->tf_ipsw = ksc.sc_ps;
@


1.39
log
@Recommit the reverted sigacts change now that the NFS use-after-free
problem has been tracked down.  This fixes the sharing of the signal
handling state: shared bits go in sigacts, per-rthread bits goes in
struct proc.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.38 2011/06/26 22:39:59 deraadt Exp $	*/
d522 1
a522 1
				pitlb(sp, off);
d534 1
a534 1
				pdtlb(sp, off);
@


1.38
log
@if_downall() cannot be done MI in sys_reboot() because vfs_shutdown()
might need network (ie. nfs).  Move the call to the MD boot() routines.
This cause for boot hangs diagnosed by kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.37 2011/06/05 19:41:06 deraadt Exp $	*/
d845 1
a845 1
	ksc.sc_onstack = psp->ps_sigstk.ss_flags & SS_ONSTACK;
d850 1
a850 1
	if ((psp->ps_flags & SAS_ALTSTACK) && !ksc.sc_onstack &&
d852 2
a853 2
		scp = (register_t)psp->ps_sigstk.ss_sp;
		psp->ps_sigstk.ss_flags |= SS_ONSTACK;
d948 1
a948 1
		p->p_sigacts->ps_sigstk.ss_flags |= SS_ONSTACK;
d950 1
a950 1
		p->p_sigacts->ps_sigstk.ss_flags &= ~SS_ONSTACK;
@


1.37
log
@Move the bufcachepercent setting code to MI locations -- set it to 42%
for now; that is unlikely to hit some of the remaining starvation bugs.
Repair the bufpages calculation too; i386 was doing it ahead of time
(incorrectly) and then re-calculating it.
ok thib
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.36 2011/04/18 21:44:55 guenther Exp $	*/
d47 1
d565 1
@


1.36
log
@Revert the sigacts diff: NFS can apparently retain pointers to processes
until they're zombies and then send them signals (for intr mounts).  Until
that is untangled, the sigacts change is unsafe.  sthen@@ was the victim
for this one
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.35 2011/04/16 22:02:32 kettenis Exp $	*/
a69 14

/*
 * Patchable buffer cache parameters
 */
#ifndef BUFCACHEPERCENT
#define BUFCACHEPERCENT 10
#endif /* BUFCACHEPERCENT */

#ifdef BUFPAGES
int bufpages = BUFPAGES;
#else
int bufpages = 0;
#endif
int bufcachepercent = BUFCACHEPERCENT;
@


1.35
log
@Move the FPU state out of 'struct pcb' like we did for hppa since it causes
evil problems with non-equivalent aliases.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.34 2011/04/15 04:52:39 guenther Exp $	*/
d857 1
a857 1
	ksc.sc_onstack = p->p_sigstk.ss_flags & SS_ONSTACK;
d862 1
a862 1
	if ((p->p_sigstk.ss_flags & SS_DISABLE) == 0 && !ksc.sc_onstack &&
d864 2
a865 2
		scp = (register_t)p->p_sigstk.ss_sp;
		p->p_sigstk.ss_flags |= SS_ONSTACK;
d960 1
a960 1
		p->p_sigstk.ss_flags |= SS_ONSTACK;
d962 1
a962 1
		p->p_sigstk.ss_flags &= ~SS_ONSTACK;
@


1.34
log
@Correct the sharing of the signal handling state: stuff that should
be shared (p_sigignore, p_sigcatch, P_NOCLDSTOP, P_NOCLDWAIT) moves
to struct sigacts, wihle stuff that should be per rthread (ps_oldmask,
SAS_OLDMASK, ps_sigstk) moves to struct proc.  Treat the coredumping
state bits (ps_sig, ps_code, ps_type, ps_sigval) as per-rthread
until our locking around coredumping is better.

Oh, and remove the old SunOS-compat ps_usertramp member.

"I like the sound of this" tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.33 2011/04/06 14:45:23 jsing Exp $	*/
d60 1
d132 2
d301 4
a304 1
printf("out\n");
a799 1
	extern paddr_t fpu_curpcb;	/* from locore.S */
d821 6
a826 9
	if (tf->tf_cr30 == fpu_curpcb) {
		fpu_exit();
		fpu_curpcb = 0;
	}
	pcb->pcb_fpregs[0] = ((u_int64_t)HPPA_FPU_INIT) << 32;
	pcb->pcb_fpregs[1] = 0;
	pcb->pcb_fpregs[2] = 0;
	pcb->pcb_fpregs[3] = 0;
	fdcache(HPPA_SID_KERNEL, (vaddr_t)pcb->pcb_fpregs, 8 * 4);
a837 2
	extern paddr_t fpu_curpcb;	/* from locore.S */
	extern u_int fpu_enable;
d854 2
a855 7
	/* flush the FPU ctx first */
	if (tf->tf_cr30 == fpu_curpcb) {
		mtctl(fpu_enable, CR_CCR);
		fpu_save(fpu_curpcb);
		/* fpu_curpcb = 0; only needed if fpregs are preset */
		mtctl(0, CR_CCR);
	}
d889 1
a889 1
	bcopy(p->p_addr->u_pcb.pcb_fpregs, ksc.sc_fpregs,
a932 1
	extern paddr_t fpu_curpcb;	/* from locore.S */
d949 1
a949 4
	if (tf->tf_cr30 == fpu_curpcb) {
		fpu_exit();
		fpu_curpcb = 0;
	}
d968 1
a968 3
	bcopy(ksc.sc_fpregs, p->p_addr->u_pcb.pcb_fpregs,
	    sizeof(ksc.sc_fpregs));
	fdcache(HPPA_SID_KERNEL, (vaddr_t)p->p_addr->u_pcb.pcb_fpregs,
@


1.33
log
@Move CPL to struct cpu_info.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.32 2011/04/05 15:46:53 jsing Exp $	*/
d862 1
a862 1
	ksc.sc_onstack = psp->ps_sigstk.ss_flags & SS_ONSTACK;
d867 1
a867 1
	if ((psp->ps_flags & SAS_ALTSTACK) && !ksc.sc_onstack &&
d869 2
a870 2
		scp = (register_t)psp->ps_sigstk.ss_sp;
		psp->ps_sigstk.ss_flags |= SS_ONSTACK;
d969 1
a969 1
		p->p_sigacts->ps_sigstk.ss_flags |= SS_ONSTACK;
d971 1
a971 1
		p->p_sigacts->ps_sigstk.ss_flags &= ~SS_ONSTACK;
@


1.32
log
@Move PSW in struct cpu_info. Also ensure that we leave interrupts disabled
when switching to virtual mode in the trap handler. Re-enabling interrupts
whilst in the trap handler for an interrupt makes life interesting.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.31 2011/04/05 14:13:25 jsing Exp $	*/
d1036 1
a1036 1
	extern int cpl;	/* from locoore.s */
d1038 2
a1039 3
	if (cpl < wantipl) {
		splassert_fail(wantipl, cpl, func);
	}
@


1.31
log
@Enable wide mode for PSW defaults.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.30 2011/01/04 17:59:14 jasper Exp $	*/
a183 2

	mtctl((long)&cpu0_info, 24);
@


1.30
log
@- de-register. no binary change.

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.29 2011/01/02 13:25:17 jasper Exp $	*/
d192 6
@


1.29
log
@- move resettodr and inittodr to clock.c, like the other clock related functions
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.28 2011/01/01 18:59:26 jasper Exp $	*/
d223 1
a223 1
		register u_int *p = hpmc_v;
d235 1
a235 1
		register u_int cksum, *p;
d247 1
a247 1
		register u_int cksum, *p;
d516 2
a517 2
	register pa_space_t sp;
	register int i, j, k;
d522 1
a522 1
		register vaddr_t off = pdc_cache.it_off_base;
d534 1
a534 1
		register vaddr_t off = pdc_cache.dt_off_base;
@


1.28
log
@- ansify

ok jsing@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.27 2010/11/20 20:33:23 miod Exp $	*/
a428 54
 * initialize the system time from the time of day clock
 */
void
inittodr(time_t t)
{
	struct pdc_tod tod PDC_ALIGNMENT;
	int 	error, tbad = 0;
	struct timespec ts;

	if (t < 12*SECYR) {
		printf ("WARNING: preposterous time in file system");
		t = 6*SECYR + 186*SECDAY + SECDAY/2;
		tbad = 1;
	}

	if ((error = pdc_call((iodcio_t)pdc,
	    1, PDC_TOD, PDC_TOD_READ, &tod, 0, 0, 0, 0, 0)))
		printf("clock: failed to fetch (%d)\n", error);

	ts.tv_sec = tod.sec;
	ts.tv_nsec = tod.usec * 1000;
	tc_setclock(&ts);

	if (!tbad) {
		u_long	dt;

		dt = (tod.sec < t)?  t - tod.sec : tod.sec - t;

		if (dt < 2 * SECDAY)
			return;
		printf("WARNING: clock %s %ld days",
		    tod.sec < t? "lost" : "gained", dt / SECDAY);
	}

	printf (" -- CHECK AND RESET THE DATE!\n");
}

/*
 * reset the time of day clock to the value in time
 */
void
resettodr()
{
	struct timeval tv;
	int error;

	microtime(&tv);

	if ((error = pdc_call((iodcio_t)pdc, 1, PDC_TOD, PDC_TOD_WRITE,
	    tv.tv_sec, tv.tv_usec)))
		printf("clock: failed to save (%d)\n", error);
}

/*
d742 1
a742 1
kcopy(const void *src, void *dst, size_t size)
d787 1
a787 1
setregs(struct proc *p, truct exec_package *pack, u_long stack,
d993 1
a993 1
cpu_sysctl(int *name, u_int namelen, void *oldp, size_t oldlenp, void *newp,
@


1.27
log
@This is a first step towards getting rid of avail_start and avail_end in the
kernel, currently limited to low-hanging fruit: these variables were used
by bus_dma to specify the range in which to allocate memory, back when
uvm_pglistalloc() was stupid and would not walk the vm_physseg[].

Nowadays, except on some platforms for early initialization, these variables
are not used, or do not need to be global variables. Therefore:
- remove `extern' declarations of avail_start and avail_end (or close cousins,
  such as arm physical_start and physical_end) from files which no longer need
  to use them.
- make them local variables whenever possible.
- remove them when they are assigned to but no longer used.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.26 2010/07/24 21:27:57 kettenis Exp $	*/
d179 1
a179 2
hppa_init(start)
	paddr_t start;
d432 1
a432 2
inittodr(t)
	time_t t;
d510 1
a510 2
delay(us)
	u_int us;
d534 1
a534 2
fall(c_base, c_count, c_loop, c_stride, data)
	int c_base, c_count, c_loop, c_stride, data;
d599 1
a599 2
boot(howto)
	int howto;
d796 1
a796 4
kcopy(from, to, size)
	const void *from;
	void *to;
	size_t size;
d802 1
a802 5
copystr(src, dst, size, lenp)
	const void *src;
	void *dst;
	size_t size;
	size_t *lenp;
d808 1
a808 5
copyinstr(src, dst, size, lenp)
	const void *src;
	void *dst;
	size_t size;
	size_t *lenp;
d816 1
a816 5
copyoutstr(src, dst, size, lenp)
	const void *src;
	void *dst;
	size_t size;
	size_t *lenp;
d824 1
a824 4
copyin(src, dst, size)
	const void *src;
	void *dst;
	size_t size;
d831 1
a831 4
copyout(src, dst, size)
	const void *src;
	void *dst;
	size_t size;
d841 2
a842 5
setregs(p, pack, stack, retval)
	struct proc *p;
	struct exec_package *pack;
	u_long stack;
	register_t *retval;
d883 2
a884 6
sendsig(catcher, sig, mask, code, type, val)
	sig_t catcher;
	int sig, mask;
	u_long code;
	int type;
	union sigval val;
d986 1
a986 4
sys_sigreturn(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d1047 2
a1048 8
cpu_sysctl(name, namelen, oldp, oldlenp, newp, newlen, p)
	int *name;
	u_int namelen;
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
	struct proc *p;
@


1.26
log
@Switch hppa64 to timecounters.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.25 2010/07/01 05:09:27 jsing Exp $	*/
a123 1
paddr_t	avail_end;
d184 1
@


1.25
log
@Provide uvm constraints.

ok kettenis@@ thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.23 2010/06/29 20:30:32 guenther Exp $	*/
d42 1
d438 1
d450 3
a452 2
	time.tv_sec = tod.sec;
	time.tv_usec = tod.usec;
d457 1
a457 1
		dt = (time.tv_sec < t)?  t - time.tv_sec : time.tv_sec - t;
d462 1
a462 1
		    time.tv_sec < t? "lost" : "gained", dt / SECDAY);
d474 1
d477 2
d480 1
a480 1
	    time.tv_sec, time.tv_usec)))
@


1.24
log
@Provide safepri.
@
text
@d165 3
@


1.23
log
@Remove COMPAT_HPUX.  No one wanted to support it and its fewmets were
blocking other cleanups
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.22 2010/06/09 15:44:17 miod Exp $	*/
d143 6
@


1.22
log
@Move declaration of cn_tab from dev/cons.c to dev/cninit.c, or appropriate
md files for ports which do not use dev/cninit.c. This gets rid of a common
at kernel link time.
feedback drahn@@ ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.21 2010/05/24 15:06:05 deraadt Exp $	*/
a59 4
#ifdef COMPAT_HPUX
#include <compat/hpux/hpux.h>
#endif

a119 3
#ifdef COMPAT_HPUX
int	cpu_model_hpux;	/* contains HPUX_SYSCONF_CPU* kind of value */
#endif
@


1.21
log
@sync to hppa: Add missing prototypes
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.20 2009/11/25 23:20:59 jsing Exp $	*/
d138 1
@


1.20
log
@Fix typo.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.18 2009/08/11 18:46:32 miod Exp $	*/
d164 2
@


1.19
log
@Do not bother initializing bufpages in the md code if the computation is
exactly the same the mi could will use if bufinit() is invoked with
bufpages == 0.
@
text
@d380 1
a380 1
	    ptoa((psize_t)phsymem) / 1024 / 1024);
@


1.18
log
@With the SysV memory allocation changes, allocsys() doesn't do anything
anymore. Get rid of it completely.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.17 2009/08/09 10:40:17 blambert Exp $	*/
a381 7

	/*
	 * Determine how many buffers to allocate.
	 * We allocate bufcachepercent% of memory for buffer space.
	 */
	if (bufpages == 0)
		bufpages = physmem * bufcachepercent / 100;
@


1.17
log
@Rototill system V message queues.

No longer allocate a static amount of memory for messages in MD
boot path; message queues, message metadata, and message data now
all use dynamic memory, which means that runtime sysctls should now
be trivial to implement.

Since I'm going to be around all week to fix any breakage, this should
probably just go in now.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.16 2009/08/02 16:28:39 beck Exp $	*/
d267 1
a267 1
	pmap_bootstrap(start);
@


1.16
log
@
Dynamic buffer cache support - a re-commit of what was backed out
after c2k9

allows buffer cache to be extended and grow/shrink dynamically

tested by many, ok oga@@, "why not just commit it" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.15 2009/06/15 17:01:25 beck Exp $	*/
a41 3
#ifdef SYSVMSG
#include <sys/msg.h>
#endif
a265 16
#ifdef SYSVMSG
{
	vaddr_t v;

	v = round_page(start);
#define valloc(name, type, num) (name) = (type *)v; v = (vaddr_t)((name)+(num))
	valloc(msgpool, char, msginfo.msgmax);
	valloc(msgmaps, struct msgmap, msginfo.msgseg);
	valloc(msghdrs, struct msg, msginfo.msgtql);
	valloc(msqids, struct msqid_ds, msginfo.msgmni);
#undef valloc
	v = round_page(v);
	bzero ((void *)start, (v - start));
	start = v;
}
#endif
@


1.15
log
@Back out all the buffer cache changes I committed during c2k9. This reverts three
commits:

1) The sysctl allowing bufcachepercent to be changed at boot time.
2) The change moving the buffer cache hash chains to a red-black tree
3) The dynamic buffer cache (Which depended on the earlier too).

ok on the backout from marco and todd
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.14 2009/06/03 21:30:19 beck Exp $	*/
a407 6

	/* Restrict to at most 25% filled kvm */
	if (bufpages >
	    (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) / PAGE_SIZE / 4) 
		bufpages = (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) /
		    PAGE_SIZE / 4;
@


1.14
log
@add kern.bufcachepercent sysctl to allow adjusting the buffer cache
size on a running system.
ok art@@, oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.13 2009/02/04 17:19:17 miod Exp $	*/
d408 6
@


1.13
log
@Unify memory size reports a bit more: always report size in MB, and report
reserved memory on alpha and hppa on its own line (as done on sgi).
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.12 2008/06/27 17:22:14 miod Exp $	*/
a407 6

	/* Restrict to at most 25% filled kvm */
	if (bufpages >
	    (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) / PAGE_SIZE / 4) 
		bufpages = (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) /
		    PAGE_SIZE / 4;
@


1.12
log
@Clear swap encryption keys before dumping a kernel image.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.11 2008/04/27 17:48:10 martin Exp $	*/
d398 3
a400 2
	printf("real mem = %u (%u reserved for PROM, %u used by OpenBSD)\n",
	    ptoa(physmem), ptoa(resvmem), ptoa(resvphysmem - resvmem));
d432 2
a433 1
	printf("avail mem = %lu\n", ptoa(uvmexp.free));
@


1.11
log
@replace ctob/btoc by ptoa/atop
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.10 2008/04/20 21:42:00 kettenis Exp $	*/
d51 1
d771 4
@


1.10
log
@Try to reset the machine through the firmware to reboot.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.9 2008/04/20 11:53:11 kettenis Exp $	*/
d257 2
a258 2
	physmem = btoc(avail_end);
	resvmem = btoc(((vaddr_t)&kernel_text));
d398 1
a398 1
	    ctob(physmem), ctob(resvmem), ctob(resvphysmem - resvmem));
d780 1
a780 1
		bytes = ctob(physmem);
@


1.9
log
@Sync console handling with hppa port:

Delay switching to the real serial console until we attach the serial device.
The variety of different serial devices is just too big to make a decision up
front.  This should make the second serial port on four-digit B/C/J-class
workstation work as a serial console too.

Last bit isn't true yet; the code to support com @@ ssio isn't there yet on
hppa64.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.8 2008/04/09 16:58:10 deraadt Exp $	*/
d676 4
@


1.8
log
@Add new stub uvm_shutdown() and call it from the right place in MD boot()
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.8 2008/04/09 16:50:28 deraadt Exp $	*/
d1129 3
a1131 6
	static int initted;

	if (!initted) {
		initted++;
		cninit();
	}
@


1.7
log
@now that all partition size/offsets are potentially 64-bit, change the
type of all variables to daddr64_t.  this includes the APIs for XXsize()
and XXdump(), all range checks inside bio drivers, internal variables
for disklabel handling, and even uvm's swap offsets.  re-read numerous
times by otto, miod, krw, thib to look for errors
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.6 2007/05/27 17:31:56 miod Exp $	*/
d648 1
@


1.6
log
@Make sure the minaddr hint for uvm_km_suballoc() calls is always initialized.
ok pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.5 2007/05/26 20:26:50 pedro Exp $	*/
d750 4
a753 4
	register caddr_t maddr;
	register daddr_t blkno;
	register int (*dump)(dev_t, daddr_t, caddr_t, size_t);
	register int error;
@


1.5
log
@Dynamic buffer cache. Initial diff from mickey@@, okay art@@ beck@@ toby@@
deraadt@@ dlg@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.4 2006/01/10 19:21:14 martin Exp $	*/
d418 1
@


1.4
log
@missing cast to vaddr_t
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.3 2005/10/26 18:35:45 martin Exp $	*/
a77 6
#ifdef NBUF
int nbuf = NBUF;
#else
int nbuf = 0;
#endif

a286 23
	/* buffer cache parameters */
	if (bufpages == 0)
		bufpages = physmem / 100 *
		    (physmem <= 0x1000? 5 : bufcachepercent);

	if (nbuf == 0)
		nbuf = bufpages < 16? 16 : bufpages;

	/* Restrict to at most 50% filled kvm */
	if (nbuf * MAXBSIZE >
	    (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) / 2)
		nbuf = (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) /
		    MAXBSIZE / 2;

	/* More buffer pages than fits into the buffers is senseless. */
	if (bufpages > nbuf * MAXBSIZE / PAGE_SIZE)
		bufpages = nbuf * MAXBSIZE / PAGE_SIZE;

	if (!(buf = (struct buf *)pmap_steal_memory(round_page(nbuf *
	    sizeof(struct buf)), NULL, NULL)))
		panic("cpu_startup: no space for bufs");
	bzero(buf, nbuf * sizeof(struct buf));

a388 2
	vsize_t size;
	int i, base, residual;
d400 12
a411 35
printf("here2\n");
	size = MAXBSIZE * nbuf;
	if (uvm_map(kernel_map, &minaddr, round_page(size),
	    NULL, UVM_UNKNOWN_OFFSET, 0, UVM_MAPFLAG(UVM_PROT_NONE,
	    UVM_PROT_NONE, UVM_INH_NONE, UVM_ADV_NORMAL, 0)))
		panic("cpu_startup: cannot allocate VM for buffers");
	buffers = (caddr_t)minaddr;
	base = bufpages / nbuf;
	residual = bufpages % nbuf;
	for (i = 0; i < nbuf; i++) {
		vaddr_t curbuf;
		int cbpgs, pd;

{ extern int pmapdebug; pd = pmapdebug; pmapdebug = 0; }
		/*
		 * First <residual> buffers get (base+1) physical pages
		 * allocated for them.  The rest get (base) physical pages.
		 *
		 * The rest of each buffer occupies virtual space,
		 * but has no physical memory allocated for it.
		 */
		curbuf = (vaddr_t) buffers + (i * MAXBSIZE);

		for (cbpgs = base + (i < residual? 1 : 0); cbpgs--; ) {
			struct vm_page *pg;

			if ((pg = uvm_pagealloc(NULL, 0, NULL, 0)) == NULL)
				panic("cpu_startup: not enough memory for "
				    "buffer cache");
			pmap_kenter_pa(curbuf, VM_PAGE_TO_PHYS(pg),
			    UVM_PROT_RW);
			curbuf += PAGE_SIZE;
		}
{ extern int pmapdebug; pmapdebug = pd; }
	}
a429 2
	printf("using %u buffers containing %u bytes of memory\n",
	    nbuf, (unsigned)bufpages * PAGE_SIZE);
@


1.3
log
@no more hppa_round_page() and hppa_trunc_page() macros

ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.2 2005/08/06 14:26:52 miod Exp $	*/
d317 2
a318 1
	msgbufp = (struct msgbuf *)(ptoa(physmem) - round_page(MSGBUFSIZE));
@


1.2
log
@We do not need a char machine_arch[] constant.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.1 2005/04/01 10:40:47 mickey Exp $	*/
d278 1
a278 1
	v = hppa_round_page(start);
d285 1
a285 1
	v = hppa_round_page(v);
@


1.1
log
@small batch early bottling hppa64 port
matured in mighty ukrainian oak for 23 months
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d126 1
a126 1
char	machine[] = MACHINE_ARCH;
@

