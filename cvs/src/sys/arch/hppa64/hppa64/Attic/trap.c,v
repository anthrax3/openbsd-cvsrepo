head	1.43;
access;
symbols
	OPENBSD_5_9:1.41.0.4
	OPENBSD_5_9_BASE:1.41
	OPENBSD_5_8:1.41.0.6
	OPENBSD_5_8_BASE:1.41
	OPENBSD_5_7:1.41.0.2
	OPENBSD_5_7_BASE:1.41
	OPENBSD_5_6:1.39.0.4
	OPENBSD_5_6_BASE:1.39
	OPENBSD_5_5:1.33.0.8
	OPENBSD_5_5_BASE:1.33
	OPENBSD_5_4:1.33.0.4
	OPENBSD_5_4_BASE:1.33
	OPENBSD_5_3:1.33.0.2
	OPENBSD_5_3_BASE:1.33
	OPENBSD_5_2:1.30.0.2
	OPENBSD_5_2_BASE:1.30
	OPENBSD_5_1_BASE:1.29
	OPENBSD_5_1:1.29.0.2
	OPENBSD_5_0:1.22.0.2
	OPENBSD_5_0_BASE:1.22
	OPENBSD_4_9:1.13.0.2
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.10.0.2
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.8.0.8
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.10
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.6
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.4
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.2
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.7.0.2
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.6.0.6
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.4
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.6.0.2
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.3.0.2
	OPENBSD_3_8_BASE:1.3;
locks; strict;
comment	@ * @;


1.43
date	2016.05.11.21.52.50;	author deraadt;	state dead;
branches;
next	1.42;
commitid	VpgRpYXqYSJy4P7J;

1.42
date	2016.02.27.13.08.07;	author mpi;	state Exp;
branches;
next	1.41;
commitid	hnv9KfQtxhCytAnd;

1.41
date	2014.11.16.12.30.57;	author deraadt;	state Exp;
branches;
next	1.40;
commitid	yv0ECmCdICvq576h;

1.40
date	2014.10.12.20.39.46;	author miod;	state Exp;
branches;
next	1.39;
commitid	n8DZa9w0X2LVgDkM;

1.39
date	2014.05.11.00.12.44;	author guenther;	state Exp;
branches;
next	1.38;

1.38
date	2014.05.11.00.05.38;	author guenther;	state Exp;
branches;
next	1.37;

1.37
date	2014.05.10.05.33.00;	author guenther;	state Exp;
branches;
next	1.36;

1.36
date	2014.04.18.11.51.16;	author guenther;	state Exp;
branches;
next	1.35;

1.35
date	2014.04.08.09.34.23;	author mpi;	state Exp;
branches;
next	1.34;

1.34
date	2014.03.26.05.23.42;	author guenther;	state Exp;
branches;
next	1.33;

1.33
date	2012.12.31.06.46.13;	author guenther;	state Exp;
branches;
next	1.32;

1.32
date	2012.08.07.17.17.46;	author guenther;	state Exp;
branches;
next	1.31;

1.31
date	2012.08.07.05.16.53;	author guenther;	state Exp;
branches;
next	1.30;

1.30
date	2012.04.11.14.38.55;	author mikeb;	state Exp;
branches;
next	1.29;

1.29
date	2011.11.26.19.14.17;	author kettenis;	state Exp;
branches;
next	1.28;

1.28
date	2011.11.16.20.56.01;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2011.11.16.20.50.18;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2011.09.20.16.44.28;	author jsing;	state Exp;
branches;
next	1.25;

1.25
date	2011.09.19.12.58.30;	author kettenis;	state Exp;
branches;
next	1.24;

1.24
date	2011.09.19.09.07.13;	author kettenis;	state Exp;
branches;
next	1.23;

1.23
date	2011.09.19.08.49.19;	author kettenis;	state Exp;
branches;
next	1.22;

1.22
date	2011.08.07.15.49.34;	author kettenis;	state Exp;
branches;
next	1.21;

1.21
date	2011.07.09.02.12.16;	author kettenis;	state Exp;
branches;
next	1.20;

1.20
date	2011.07.07.18.37.48;	author kettenis;	state Exp;
branches;
next	1.19;

1.19
date	2011.04.16.22.02.32;	author kettenis;	state Exp;
branches;
next	1.18;

1.18
date	2011.04.07.13.13.01;	author jsing;	state Exp;
branches;
next	1.17;

1.17
date	2011.04.06.14.45.23;	author jsing;	state Exp;
branches;
next	1.16;

1.16
date	2011.04.03.14.56.28;	author guenther;	state Exp;
branches;
next	1.15;

1.15
date	2011.03.30.13.54.23;	author jsing;	state Exp;
branches;
next	1.14;

1.14
date	2011.03.30.13.50.55;	author jsing;	state Exp;
branches;
next	1.13;

1.13
date	2011.01.02.13.16.53;	author jsing;	state Exp;
branches;
next	1.12;

1.12
date	2010.12.21.14.56.23;	author claudio;	state Exp;
branches;
next	1.11;

1.11
date	2010.11.27.19.57.23;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2010.07.01.04.33.59;	author jsing;	state Exp;
branches;
next	1.9;

1.9
date	2010.05.24.15.06.05;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2007.09.15.14.55.30;	author krw;	state Exp;
branches;
next	1.7;

1.7
date	2007.03.15.10.22.29;	author art;	state Exp;
branches;
next	1.6;

1.6
date	2005.10.26.18.35.45;	author martin;	state Exp;
branches;
next	1.5;

1.5
date	2005.09.15.21.14.27;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2005.09.15.21.09.29;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2005.08.14.10.54.17;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2005.07.18.02.43.25;	author fgsch;	state Exp;
branches;
next	1.1;

1.1
date	2005.04.01.10.40.47;	author mickey;	state Exp;
branches;
next	;


desc
@@


1.43
log
@remove hppa64 port, which we never got going beyond broken single users.
hppa reverse-stack gives us a valuable test case, but most developers don't
have a 2nd one to proceed further with this.
ok kettenis
@
text
@/*	$OpenBSD: trap.c,v 1.42 2016/02/27 13:08:07 mpi Exp $	*/

/*
 * Copyright (c) 2005 Michael Shalayeff
 * All rights reserved.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER IN
 * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
 * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#undef TRAPDEBUG

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/signalvar.h>
#include <sys/user.h>
#include <sys/syscall.h>
#include <sys/syscall_mi.h>

#include <uvm/uvm_extern.h>

#include <machine/autoconf.h>
#include <machine/cpufunc.h>
#include <machine/psl.h>

#ifdef DDB
#include <machine/db_machdep.h>
#endif

#ifdef TRAPDEBUG
#include <ddb/db_output.h>
#endif

static __inline int inst_store(u_int ins) {
	return (ins & 0xf0000000) == 0x60000000 ||	/* stb/sth/stw */
	       (ins & 0xfc000000) == 0x70000000 ||	/* std/fstd */
	       (ins & 0xfc000000) == 0x78000000 ||	/* fstw */
	       (ins & 0xfc000000) == 0x7c000000 ||	/* stw/fstw */
	       (ins & 0xfc000200) == 0x24000200 ||	/* cstw */
	       (ins & 0xfc000200) == 0x2c000200 ||	/* cstd */
	       (ins & 0xfc001300) == 0x0c001200 ||	/* stb/sth/stw/std */
	       (ins & 0xfc001380) == 0x0c001300 ||	/* stby/stdby */
	       (ins & 0xfc0003c0) == 0x0c0001c0 ||	/* ldcw */
	       (ins & 0xfc0003c0) == 0x0c000140;	/* ldcd */
}

void	ast(struct proc *);

const char *trap_type[] = {
	"invalid",
	"HPMC",
	"power failure",
	"recovery counter",
	"external interrupt",
	"LPMC",
	"ITLB miss fault",
	"instruction protection",
	"Illegal instruction",
	"break instruction",
	"privileged operation",
	"privileged register",
	"overflow",
	"conditional",
	"assist exception",
	"DTLB miss",
	"ITLB non-access miss",
	"DTLB non-access miss",
	"data protection/rights/alignment",
	"data break",
	"TLB dirty",
	"page reference",
	"assist emulation",
	"higher-priv transfer",
	"lower-priv transfer",
	"taken branch",
	"data access rights",
	"data protection",
	"unaligned data ref",
};
int trap_types = sizeof(trap_type)/sizeof(trap_type[0]);

int want_resched, astpending;

#define	frame_regmap(tf,r)	(((register_t *)(tf))[hppa64_regmap[(r)]])
u_char hppa64_regmap[32] = {
	offsetof(struct trapframe, tf_pad[0]) / 8,	/* r0 XXX */
	offsetof(struct trapframe, tf_r1) / 8,
	offsetof(struct trapframe, tf_rp) / 8,
	offsetof(struct trapframe, tf_r3) / 8,
	offsetof(struct trapframe, tf_r4) / 8,
	offsetof(struct trapframe, tf_r5) / 8,
	offsetof(struct trapframe, tf_r6) / 8,
	offsetof(struct trapframe, tf_r7) / 8,
	offsetof(struct trapframe, tf_r8) / 8,
	offsetof(struct trapframe, tf_r9) / 8,
	offsetof(struct trapframe, tf_r10) / 8,
	offsetof(struct trapframe, tf_r11) / 8,
	offsetof(struct trapframe, tf_r12) / 8,
	offsetof(struct trapframe, tf_r13) / 8,
	offsetof(struct trapframe, tf_r14) / 8,
	offsetof(struct trapframe, tf_r15) / 8,
	offsetof(struct trapframe, tf_r16) / 8,
	offsetof(struct trapframe, tf_r17) / 8,
	offsetof(struct trapframe, tf_r18) / 8,
	offsetof(struct trapframe, tf_args[7]) / 8,
	offsetof(struct trapframe, tf_args[6]) / 8,
	offsetof(struct trapframe, tf_args[5]) / 8,
	offsetof(struct trapframe, tf_args[4]) / 8,
	offsetof(struct trapframe, tf_args[3]) / 8,
	offsetof(struct trapframe, tf_args[2]) / 8,
	offsetof(struct trapframe, tf_args[1]) / 8,
	offsetof(struct trapframe, tf_args[0]) / 8,
	offsetof(struct trapframe, tf_dp) / 8,
	offsetof(struct trapframe, tf_ret0) / 8,
	offsetof(struct trapframe, tf_ret1) / 8,
	offsetof(struct trapframe, tf_sp) / 8,
	offsetof(struct trapframe, tf_r31) / 8,
};

void
ast(struct proc *p)
{
	if (astpending) {
		astpending = 0;
		uvmexp.softs++;
		mi_ast(p, want_resched);
	}
}

void
trap(int type, struct trapframe *frame)
{
	struct proc *p = curproc;
	vaddr_t va;
	struct vm_map *map;
	struct vmspace *vm;
	register vm_prot_t vftype;
	register pa_space_t space;
	union sigval sv;
	u_int opcode;
	int ret, trapnum;
	const char *tts;
	vm_fault_t fault = VM_FAULT_INVALID;
#ifdef DIAGNOSTIC
	long oldcpl = curcpu()->ci_cpl;
#endif
	u_long mask;

	trapnum = type & ~T_USER;
	opcode = frame->tf_iir;
	if (trapnum <= T_EXCEPTION || trapnum == T_HIGHERPL ||
	    trapnum == T_LOWERPL || trapnum == T_TAKENBR ||
	    trapnum == T_IDEBUG || trapnum == T_PERFMON ||
	    trapnum == T_IPROT) {
		va = frame->tf_iioq[0];
		space = frame->tf_iisq[0];
		vftype = PROT_EXEC;
	} else {
		va = frame->tf_ior;
		space = frame->tf_isr;
		if (va == frame->tf_iioq[0])
			vftype = PROT_EXEC;
		else if (inst_store(opcode))
			vftype = PROT_WRITE;
		else
			vftype = PROT_READ;
	}

	if (frame->tf_flags & TFF_LAST)
		p->p_md.md_regs = frame;

	if (trapnum > trap_types)
		tts = "reserved";
	else
		tts = trap_type[trapnum];

#ifdef TRAPDEBUG
	if (trapnum != T_INTERRUPT && trapnum != T_IBREAK)
		db_printf("trap: %x, %s for %x:%lx at %x:%lx, fl=%x, fp=%p\n",
		    type, tts, space, va, frame->tf_iisq[0],
		    frame->tf_iioq[0], frame->tf_flags, frame);
	else if (trapnum  == T_IBREAK)
		db_printf("trap: break instruction %x:%x at %x:%lx, fp=%p\n",
		    opcode & 0x1f, (opcode >> 13) & 0x1fff,
		    frame->tf_iisq[0], frame->tf_iioq[0], frame);

	{
		extern int etext;
		if (frame < (struct trapframe *)&etext) {
			printf("trap: bogus frame ptr %p\n", frame);
			goto dead_end;
		}
	}
#endif
	if (trapnum != T_INTERRUPT) {
		uvmexp.traps++;
		mtctl(frame->tf_eiem, CR_EIEM);
	        ssm(PSL_I, mask);
	}

	if (type & T_USER)
		refreshcreds(p);

	switch (type) {
	case T_NONEXIST:
	case T_NONEXIST | T_USER:
		/* we've got screwed up by the central scrutinizer */
		printf("trap: elvis has just left the building!\n");
		goto dead_end;

	case T_RECOVERY:
	case T_RECOVERY | T_USER:
		/* XXX will implement later */
		printf("trap: handicapped");
		goto dead_end;

#ifdef DIAGNOSTIC
	case T_EXCEPTION:
		panic("FPU/SFU emulation botch");

		/* these just can't happen ever */
	case T_PRIV_OP:
	case T_PRIV_REG:
		/* these just can't make it to the trap() ever */
	case T_HPMC:
	case T_HPMC | T_USER:
#endif
	case T_IBREAK:
	case T_DATALIGN:
	case T_DBREAK:
	dead_end:
#ifdef DDB
		if (db_ktrap (type, va, frame)) {
			if (type == T_IBREAK) {
				/* skip break instruction */
				frame->tf_iioq[0] = frame->tf_iioq[1];
				frame->tf_iioq[1] += 4;
			}
			return;
		}
#else
		if (type == T_DATALIGN)
			panic ("trap: %s at 0x%lx", tts, va);
		else
			panic ("trap: no debugger for \"%s\" (%d)", tts, type);
#endif
		break;

	case T_IBREAK | T_USER:
	case T_DBREAK | T_USER:
		/* pass to user debugger */
		trapsignal(p, SIGTRAP, type &~ T_USER, TRAP_BRKPT, sv);
		break;

	case T_EXCEPTION | T_USER: {
		struct hppa_fpstate *hfp;
		u_int64_t *fpp;
		u_int32_t *pex;
		int i, flt;

		hfp = (struct hppa_fpstate *)frame->tf_cr30;
		fpp = (u_int64_t *)&hfp->hfp_regs;

		pex = (u_int32_t *)&fpp[0];
		for (i = 0, pex++; i < 7 && !*pex; i++, pex++);
		flt = 0;
		if (i < 7) {
			u_int32_t stat = HPPA_FPU_OP(*pex);
			if (stat & HPPA_FPU_UNMPL)
				flt = FPE_FLTINV;
			else if (stat & (HPPA_FPU_V << 1))
				flt = FPE_FLTINV;
			else if (stat & (HPPA_FPU_Z << 1))
				flt = FPE_FLTDIV;
			else if (stat & (HPPA_FPU_I << 1))
				flt = FPE_FLTRES;
			else if (stat & (HPPA_FPU_O << 1))
				flt = FPE_FLTOVF;
			else if (stat & (HPPA_FPU_U << 1))
				flt = FPE_FLTUND;
			/* still left: under/over-flow w/ inexact */

			/* cleanup exceptions (XXX deliver all ?) */
			while (i++ < 7)
				*pex++ = 0;
		}
		/* reset the trap flag, as if there was none */
		fpp[0] &= ~(((u_int64_t)HPPA_FPU_T) << 32);
		/* flush out, since load is done from phys, only 4 regs */
		fdcache(HPPA_SID_KERNEL, (vaddr_t)fpp, 8 * 4);

		sv.sival_int = va;
		trapsignal(p, SIGFPE, type &~ T_USER, flt, sv);
		}
		break;

	case T_EMULATION:
		panic("trap: emulation trap in the kernel");
		break;

	case T_EMULATION | T_USER:
		sv.sival_int = va;
		trapsignal(p, SIGILL, type &~ T_USER, ILL_COPROC, sv);
		break;

	case T_OVERFLOW | T_USER:
		sv.sival_int = va;
		trapsignal(p, SIGFPE, type &~ T_USER, FPE_INTOVF, sv);
		break;

	case T_CONDITION | T_USER:
		sv.sival_int = va;
		trapsignal(p, SIGFPE, type &~ T_USER, FPE_INTDIV, sv);
		break;

	case T_PRIV_OP | T_USER:
		sv.sival_int = va;
		trapsignal(p, SIGILL, type &~ T_USER, ILL_PRVOPC, sv);
		break;

	case T_PRIV_REG | T_USER:
		sv.sival_int = va;
		trapsignal(p, SIGILL, type &~ T_USER, ILL_PRVREG, sv);
		break;

		/* these should never got here */
	case T_HIGHERPL | T_USER:
	case T_LOWERPL | T_USER:
		sv.sival_int = va;
		trapsignal(p, SIGSEGV, vftype, SEGV_ACCERR, sv);
		break;

	case T_DPROT | T_USER:
		sv.sival_int = va;
		trapsignal(p, SIGSEGV, vftype, SEGV_ACCERR, sv);
		break;

	case T_ITLBMISSNA:
	case T_ITLBMISSNA | T_USER:
	case T_DTLBMISSNA:
	case T_DTLBMISSNA | T_USER:
		if (space == HPPA_SID_KERNEL)
			map = kernel_map;
		else {
			vm = p->p_vmspace;
			map = &vm->vm_map;
		}

		/* dig probei?,[rw] insns */
		if ((opcode & 0xfc001f80) == 0x04001180) {
			int pl;

			if (opcode & 0x2000)
				pl = (opcode >> 16) & 3;
			else
				pl = frame_regmap(frame,
				    (opcode >> 16) & 0x1f) & 3;

			if ((type & T_USER && space == HPPA_SID_KERNEL) ||
			    (type & T_USER && !pl) ||
			    (type & T_USER && va >= VM_MAXUSER_ADDRESS) ||
			    uvm_fault(map, trunc_page(va), fault,
			     opcode & 0x40? PROT_WRITE : PROT_READ)) {
				frame_regmap(frame, opcode & 0x1f) = 0;
				frame->tf_ipsw |= PSL_N;
			}
		} else if (type & T_USER) {
			sv.sival_int = va;
			trapsignal(p, SIGILL, type & ~T_USER, ILL_ILLTRP, sv);
		} else
			panic("trap: %s @@ 0x%lx:0x%lx for 0x%x:0x%lx irr 0x%08x",
			    tts, frame->tf_iisq[0], frame->tf_iioq[0],
			    space, va, opcode);
		break;

	case T_TLB_DIRTY:
	case T_TLB_DIRTY | T_USER:
	case T_DATACC:
	case T_DATACC | T_USER:
	case T_IPROT | T_USER:
		fault = VM_FAULT_PROTECT;
	case T_ITLBMISS:
	case T_ITLBMISS | T_USER:
	case T_DTLBMISS:
	case T_DTLBMISS | T_USER:
		/*
		 * it could be a kernel map for exec_map faults
		 */
		if (space == HPPA_SID_KERNEL)
			map = kernel_map;
		else {
			vm = p->p_vmspace;
			map = &vm->vm_map;
		}

		/*
		 * user faults out of user addr space are always a fail,
		 * this happens on va >= VM_MAXUSER_ADDRESS, where
		 * space id will be zero and therefore cause
		 * a misbehave lower in the code.
		 *
		 * also check that faulted space id matches the curproc.
		 */
		if ((type & T_USER && va >= VM_MAXUSER_ADDRESS) ||
		    (type & T_USER && map->pmap->pm_space != space)) {
			sv.sival_int = va;
			trapsignal(p, SIGSEGV, vftype, SEGV_ACCERR, sv);
			break;
		}

		ret = uvm_fault(map, trunc_page(va), fault, vftype);

		/*
		 * If this was a stack access we keep track of the maximum
		 * accessed stack size.  Also, if uvm_fault gets a protection
		 * failure it is due to accessing the stack region outside
		 * the current limit and we need to reflect that as an access
		 * error.
		 */
		if (space != HPPA_SID_KERNEL &&
		    va < (vaddr_t)vm->vm_minsaddr) {
			if (ret == 0)
				uvm_grow(p, va);
			else if (ret == EACCES)
				ret = EFAULT;
		}

		if (ret != 0) {
			if (type & T_USER) {
				sv.sival_int = va;
				trapsignal(p, SIGSEGV, vftype,
				    ret == EACCES? SEGV_ACCERR : SEGV_MAPERR,
				    sv);
			} else {
				if (p && p->p_addr->u_pcb.pcb_onfault) {
					frame->tf_iioq[1] = 4 +
					    (frame->tf_iioq[0] =
						p->p_addr->u_pcb.pcb_onfault);
#ifdef DDB
					frame->tf_iir = 0;
#endif
				} else {
					printf("trap: "
					    "uvm_fault(%p, %lx, %d, %d): %d\n",
					    map, va, fault, vftype, ret);
					goto dead_end;
				}
			}
		}
		break;

	case T_DATALIGN | T_USER:
		sv.sival_int = va;
		trapsignal(p, SIGBUS, vftype, BUS_ADRALN, sv);
		break;

	case T_INTERRUPT:
	case T_INTERRUPT | T_USER:
		cpu_intr(frame);
		break;

	case T_CONDITION:
		panic("trap: divide by zero in the kernel");
		break;

	case T_ILLEGAL:
	case T_ILLEGAL | T_USER:
		/* see if it's a SPOP1,,0 */
		if ((opcode & 0xfffffe00) == 0x10000200) {
			frame_regmap(frame, opcode & 0x1f) = 0;
			frame->tf_ipsw |= PSL_N;
			break;
		}
		if (type & T_USER) {
			sv.sival_int = va;
			trapsignal(p, SIGILL, type &~ T_USER, ILL_ILLOPC, sv);
			break;
		}
		/* FALLTHROUGH */

	case T_LOWERPL:
	case T_DPROT:
	case T_IPROT:
	case T_OVERFLOW:
	case T_HIGHERPL:
	case T_TAKENBR:
	case T_POWERFAIL:
	case T_LPMC:
	case T_PAGEREF:
	case T_DATAPID:
	case T_DATAPID | T_USER:
		if (0 /* T-chip */) {
			break;
		}
		/* FALLTHROUGH to unimplemented */
	default:
#ifdef TRAPDEBUG
		if (db_ktrap(type, va, frame))
			return;
#endif
		panic("trap: unimplemented \'%s\' (%d)", tts, trapnum);
	}

#ifdef DIAGNOSTIC
	if (curcpu()->ci_cpl != oldcpl)
		printf("WARNING: SPL (%d) NOT LOWERED ON "
		    "TRAP (%d) EXIT\n", curcpu()->ci_cpl, trapnum);
#endif

	if (trapnum != T_INTERRUPT)
		splx(curcpu()->ci_cpl);	/* process softints */

	/*
	 * in case we were interrupted from the syscall gate page
	 * treat this as we were not really running user code no more
	 * for weird things start to happen on return to the userland
	 * and also see a note in locore.S:TLABEL(all)
	 */
	if ((type & T_USER) &&
	    (frame->tf_iioq[0] & ~PAGE_MASK) != SYSCALLGATE) {
		ast(p);
		userret(p);
	}
}

void
child_return(void *arg)
{
	struct proc *p = (struct proc *)arg;
	struct trapframe *tf = p->p_md.md_regs;

	/*
	 * Set up return value registers as libc:fork() expects
	 */
	tf->tf_ret0 = 0;
	tf->tf_ret1 = 1;	/* ischild */
	tf->tf_r1 = 0;		/* errno */

	ast(p);

	mi_child_return(p);
}

void	syscall(struct trapframe *frame);

/*
 * call actual syscall routine
 */
void
syscall(struct trapframe *frame)
{
	register struct proc *p = curproc;
	register const struct sysent *callp;
	int nsys, code, error;
	register_t args[8], rval[2];
#ifdef DIAGNOSTIC
	long oldcpl = curcpu()->ci_cpl;
#endif

	uvmexp.syscalls++;

	if (!USERMODE(frame->tf_iioq[0]))
		panic("syscall");

	p->p_md.md_regs = frame;
	nsys = p->p_p->ps_emul->e_nsysent;
	callp = p->p_p->ps_emul->e_sysent;

	switch (code = frame->tf_r1) {
	case SYS_syscall:
	case SYS___syscall:
		code = frame->tf_args[0];
		args[0] = frame->tf_args[1];
		args[1] = frame->tf_args[2];
		args[2] = frame->tf_args[3];
		args[3] = frame->tf_args[4];
		args[4] = frame->tf_args[5];
		args[5] = frame->tf_args[6];
		args[6] = frame->tf_args[7];
		break;
	default:
		args[0] = frame->tf_args[0];
		args[1] = frame->tf_args[1];
		args[2] = frame->tf_args[2];
		args[3] = frame->tf_args[3];
		args[4] = frame->tf_args[4];
		args[5] = frame->tf_args[5];
		args[6] = frame->tf_args[6];
		args[7] = frame->tf_args[7];
		break;
	}

	if (code < 0 || code >= nsys)
		callp += p->p_p->ps_emul->e_nosys;	/* bad syscall # */
	else
		callp += code;

	rval[0] = 0;
	rval[1] = frame->tf_ret1;

	error = mi_syscall(p, code, callp, args, rval);

	switch (error) {
	case 0:
		frame->tf_ret0 = rval[0];
		frame->tf_ret1 = rval[1];
		frame->tf_r1 = 0;
		break;
	case ERESTART:
		frame->tf_iioq[0] -= 16;
		frame->tf_iioq[1] -= 16;
	case EJUSTRETURN:
		break;
	default:
		frame->tf_r1 = error;
		frame->tf_ret0 = error;
		frame->tf_ret1 = 0;
		break;
	}

	ast(p);

	mi_syscall_return(p, code, error, rval);

#ifdef DIAGNOSTIC
	if (curcpu()->ci_cpl != oldcpl) {
		printf("WARNING: SPL (0x%x) NOT LOWERED ON "
		    "syscall(0x%x, 0x%lx, 0x%lx, 0x%lx...) EXIT, PID %d\n",
		    curcpu()->ci_cpl, code, args[0], args[1], args[2],
		    p->p_pid);
		curcpu()->ci_cpl = oldcpl;
	}
#endif
	splx(curcpu()->ci_cpl);	/* process softints */
}
@


1.42
log
@Rename kdb_trap() into db_ktrap().

The goal is to include it in the list of functions that must not be
instrumented.  All ddb(8) functions should be in this list and have
their names start with 'db_'.

ok visa@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.41 2014/11/16 12:30:57 deraadt Exp $	*/
@


1.41
log
@Replace a plethora of historical protection options with just
PROT_NONE, PROT_READ, PROT_WRITE, and PROT_EXEC from mman.h.
PROT_MASK is introduced as the one true way of extracting those bits.
Remove UVM_ADV_* wrapper, using the standard names.
ok doug guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.40 2014/10/12 20:39:46 miod Exp $	*/
d243 1
a243 1
		if (kdb_trap (type, va, frame)) {
d508 1
a508 1
		if (kdb_trap(type, va, frame))
@


1.40
log
@Rough sync with hppa to make this compile again.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.39 2014/05/11 00:12:44 guenther Exp $	*/
d167 1
a167 1
		vftype = UVM_PROT_EXEC;
d172 1
a172 1
			vftype = UVM_PROT_EXEC;
d174 1
a174 1
			vftype = UVM_PROT_WRITE;
d176 1
a176 1
			vftype = UVM_PROT_READ;
d373 1
a373 1
			     opcode & 0x40? UVM_PROT_WRITE : UVM_PROT_READ)) {
@


1.39
log
@Move the increment of uvmexp.softs back to the caller of mi_ast():
it needs to be done atomicly on some MP archs and we don't have
atomic_add_int() everywhere yet.  Also, mi_ast() was meant to be inline.

noted by miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.38 2014/05/11 00:05:38 guenther Exp $	*/
d253 1
a253 1
			panic ("trap: %s at 0x%x", tts, va);
d381 1
a381 1
			panic("trap: %s @@ 0x%x:0x%x for 0x%x:0x%x irr 0x%08x",
d638 1
a638 1
		    "syscall(0x%x, 0x%x, 0x%x, 0x%x...) EXIT, PID %d\n",
@


1.38
log
@Pull in <sys/user.h> before <sys/syscall*.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.37 2014/05/10 05:33:00 guenther Exp $	*/
d135 1
@


1.37
log
@Factor out the common ast bits into mi_ast()

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.36 2014/04/18 11:51:16 guenther Exp $	*/
a23 2
#include <sys/syscall.h>
#include <sys/syscall_mi.h>
d27 2
@


1.36
log
@Have each thread keeps its own (counted!) reference to the process's ucreds
to avoid possible use-after-free references when swapping ids in threaded
processes.  "Do I have the right creds?" checks are always made with the
threads creds.

Inspired by FreeBSD and NetBSD
"right time" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.35 2014/04/08 09:34:23 mpi Exp $	*/
d135 1
a135 6
		uvmexp.softs++;
		if (p->p_flag & P_OWEUPC) {
			ADDUPROF(p);
		}
		if (want_resched)
			preempt(NULL);
@


1.35
log
@Less <uvm/uvm.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.34 2014/03/26 05:23:42 guenther Exp $	*/
d214 3
@


1.34
log
@Move p_emul and p_sigcode from proc to process.
Tweak the handling of ktrace EMUL when changing ktracing: only
generate one per process (not one per thread) and pass the correct
proc pointer down to the VFS layer.  Permit generating of NAMI and
CSW records inside ktrace(2) itself.

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.33 2012/12/31 06:46:13 guenther Exp $	*/
d30 1
a30 1
#include <uvm/uvm.h>
@


1.33
log
@Remove emulation errno mapping code from platforms that no longer have
non-native emulations.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.32 2012/08/07 17:17:46 guenther Exp $	*/
d577 2
a578 2
	nsys = p->p_emul->e_nsysent;
	callp = p->p_emul->e_sysent;
d605 1
a605 1
		callp += p->p_emul->e_nosys;	/* bad syscall # */
@


1.32
log
@<sys/ktrace.h> is now pulled in via <sys/syscall_mi.h>, so drop it from here
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.31 2012/08/07 05:16:53 guenther Exp $	*/
d565 1
a565 1
	int nsys, code, oerror, error;
d612 1
a612 1
	oerror = error = mi_syscall(p, code, callp, args, rval);
a625 2
		if (p->p_emul->e_errno)
			error = p->p_emul->e_errno[error];
d634 1
a634 1
	mi_syscall_return(p, code, oerror, rval);
@


1.31
log
@Move the common bits of syscall invocation and return handling into
an MI file, <sys/syscall_mi.h>, correcting inconsistencies and the
handling when copyin() of arguments fails.

Tested on i386, amd64, sparc64, and alpha (thanks naddy@@)
Any issues with other platforms will be fixed in tree.

header name from millert@@; ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.30 2012/04/11 14:38:55 mikeb Exp $	*/
a25 1
#include <sys/ktrace.h>
@


1.30
log
@The first ktrace record for a newly spawned thread is a return
from a fork syscall done by the parent.  Use __tfork, not rfork
here to match the ktrace records for the parent (CALL __tfork,
RET __tfork).  ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.29 2011/11/26 19:14:17 kettenis Exp $	*/
d25 1
a30 3
#include "systrace.h"
#include <dev/systrace.h>

d552 2
a553 8
	userret(p);
#ifdef KTRACE
	if (KTRPOINT(p, KTR_SYSRET))
		ktrsysret(p,
		    (p->p_flag & P_THREAD) ? SYS___tfork :
		    (p->p_p->ps_flags & PS_PPWAIT) ? SYS_vfork : SYS_fork,
		    0, 0);
#endif
a609 9
	oerror = error = 0;

#ifdef SYSCALL_DEBUG
	scdebug_call(p, code, args);
#endif
#ifdef KTRACE
	if (KTRPOINT(p, KTR_SYSCALL))
		ktrsyscall(p, code, callp->sy_argsize, args);
#endif
d612 3
a614 6
#if NSYSTRACE > 0
	if (ISSET(p->p_flag, P_SYSTRACE))
		oerror = error = systrace_redirect(code, p, args, rval);
	else
#endif
		oerror = error = (*callp->sy_call)(p, args, rval);
d634 1
a634 3
#ifdef SYSCALL_DEBUG
	scdebug_ret(p, code, oerror, rval);
#endif
d636 3
a638 5
	userret(p);
#ifdef KTRACE
	if (KTRPOINT(p, KTR_SYSRET))
		ktrsysret(p, code, oerror, rval[0]);
#endif
@


1.29
log
@Make this compile again by removing a spurious opening brace.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.28 2011/11/16 20:56:01 deraadt Exp $	*/
d558 1
a558 1
		    (p->p_flag & P_THREAD) ? SYS_rfork :
@


1.28
log
@oops, need a prototype for ast()
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.27 2011/11/16 20:50:18 deraadt Exp $	*/
d142 1
a142 1
		if (want_resched) {
@


1.27
log
@Make userret() MI.  On architectures which jammed stuff into it in the
past, pull that code out seperately.
ok guenther miod
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.26 2011/09/20 16:44:28 jsing Exp $	*/
d59 2
@


1.26
log
@When restarting a system call we need to go back four instructions, not
three, since this has to match libc/arch/hppa64/SYS.h.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.25 2011/09/19 12:58:30 kettenis Exp $	*/
a130 2
void	userret(struct proc *p, register_t pc, u_quad_t oticks);

d132 1
a132 1
userret(struct proc *p, register_t pc, u_quad_t oticks)
a133 7
	int sig;

	/* take pending signals */
	while ((sig = CURSIG(p)) != 0)
		postsig(sig);

	p->p_priority = p->p_usrpri;
d136 1
d140 2
a142 19
	if (want_resched) {
		/*
		 * We're being preempted.
		 */
		preempt(NULL);
		while ((sig = CURSIG(p)) != 0)
			postsig(sig);
	}

	/*
	 * If profiling, charge recent system time to the trapped pc.
	 */
	if (p->p_flag & P_PROFIL) {
		extern int psratio;

		addupc_task(p, pc, (int)(p->p_sticks - oticks) * psratio);
	}

	p->p_cpu->ci_schedstate.spc_curpriority = p->p_priority;
d532 4
a535 2
	    (frame->tf_iioq[0] & ~PAGE_MASK) != SYSCALLGATE)
		userret(p, frame->tf_iioq[0], 0);
d551 2
a552 1
	userret(p, tf->tf_iioq[0], 0);
d655 2
a656 1
	userret(p, frame->tf_iioq[1], 0);
@


1.25
log
@Disable TRAPDEBUG.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.24 2011/09/19 09:07:13 kettenis Exp $	*/
d662 2
a663 2
		frame->tf_iioq[0] -= 12;
		frame->tf_iioq[1] -= 12;
@


1.24
log
@Handle an instruction memory protection trap from userland as an ordinary
fault.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.23 2011/09/19 08:49:19 kettenis Exp $	*/
d20 1
a20 1
#define TRAPDEBUG
@


1.23
log
@Remove (annoying) debug printf.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.22 2011/08/07 15:49:34 kettenis Exp $	*/
d193 2
a194 1
	    trapnum == T_IDEBUG || trapnum == T_PERFMON) {
a369 1
	case T_IPROT | T_USER:
d417 1
@


1.22
log
@Recognize 64-bit store instructions.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.21 2011/07/09 02:12:16 kettenis Exp $	*/
a446 1
printf("here\n");
@


1.21
log
@syscall() can be a lot simpler on hpaa64.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.20 2011/07/07 18:37:48 kettenis Exp $	*/
d48 10
a57 4
	return (ins & 0xf0000000) == 0x60000000 ||	/* st */
	       (ins & 0xf4000200) == 0x24000200 ||	/* fst/cst */
	       (ins & 0xfc000200) == 0x0c000200 ||	/* stby */
	       (ins & 0xfc0003c0) == 0x0c0001c0;	/* ldcw */
@


1.20
log
@Don't panic if uvm_fault fails, but enter ddb such that we can inspect the
state that caused the fault.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.19 2011/04/16 22:02:32 kettenis Exp $	*/
d588 1
a588 1
	int retq, nsys, code, argsize, argoff, oerror, error;
a593 2
	/* TODO syscall */

a602 1
	argoff = 4; retq = 0;
d605 1
d610 4
a613 15
		argoff = 3;
		break;
	case SYS___syscall:
		if (callp != sysent)
			break;
		/*
		 * this works, because quads get magically swapped
		 * due to the args being laid backwards on the stack
		 * and then copied in words
		 */
		code = frame->tf_args[0];
		args[0] = frame->tf_args[2];
		args[1] = frame->tf_args[3];
		argoff = 2;
		retq = 1;
d620 4
a632 37
	if ((argsize = callp->sy_argsize)) {
		int i;

/* TODO syscallargs */

		/*
		 * coming from syscall() or __syscall we must be
		 * having one of those w/ a 64 bit arguments,
		 * which needs a word swap due to the order
		 * of the arguments on the stack.
		 * this assumes that none of 'em are called
		 * by their normal syscall number, maybe a regress
		 * test should be used, to watch the behaviour.
		 */
		if (!error && argoff < 4) {
			int t;

			i = 0;
			switch (code) {
			case SYS_lseek:		retq = 0;
			case SYS_truncate:
			case SYS_ftruncate:	i = 2;	break;
			case SYS_preadv:
			case SYS_pwritev:
			case SYS_pread:
			case SYS_pwrite:	i = 4;	break;
			case SYS_mquery:
			case SYS_mmap:		i = 6;	break;
			}

			if (i) {
				t = args[i];
				args[i] = args[i + 1];
				args[i + 1] = t;
			}
		}
	}
a640 3
	if (error)
		goto bad;

d652 1
a652 1
		frame->tf_ret1 = rval[!retq];
a660 1
	bad:
@


1.19
log
@Move the FPU state out of 'struct pcb' like we did for hppa since it causes
evil problems with non-equivalent aliases.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.18 2011/04/07 13:13:01 jsing Exp $	*/
d474 2
a475 2
					panic("trap: "
					    "uvm_fault(%p, %lx, %d, %d): %d",
d477 1
@


1.18
log
@Initial interrupt handling implementation for hppa64.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.17 2011/04/06 14:45:23 jsing Exp $	*/
d286 2
a287 1
		u_int64_t *fpp = (u_int64_t *)frame->tf_cr30;
d290 3
@


1.17
log
@Move CPL to struct cpu_info.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.15 2011/03/30 13:54:23 jsing Exp $	*/
d36 1
d181 1
d230 2
a231 1
	/* TODO	mtctl(frame->tf_eiem, CR_EIEM); */
d485 1
a485 2
/*		cpu_intr(frame); */
printf("eirr 0x%08x\n", mfctl(CR_EIRR));
@


1.16
log
@Move PPWAIT flag from struct proc to process, so that rthreads in
a vforked child behave correctly.  Have the parent in a vfork()
wait on a (different) flag in *its* process instead of the child
to prevent a possible use-after-free.  When ktracing the child
return from a fork, call it rfork if an rthread was created.

ok blambert@@
@
text
@d164 1
a164 3
trap(type, frame)
	int type;
	struct trapframe *frame;
a165 1
	extern int cpl;	/* from locore.o */
d178 1
a178 1
	long oldcpl = cpl;
d529 1
a529 1
	if (cpl != oldcpl)
d531 1
a531 1
		    "TRAP (%d) EXIT\n", cpl, trapnum);
d535 1
a535 1
		splx(cpl);	/* process softints */
d549 1
a549 2
child_return(arg)
	void *arg;
a578 1
	extern int cpl;	/* from locore.o */
d584 1
a584 1
	long oldcpl = cpl;
d720 1
a720 1
	if (cpl != oldcpl) {
d723 3
a725 2
		    cpl, code, args[0], args[1], args[2], p->p_pid);
		cpl = oldcpl;
d728 1
a728 1
	splx(cpl);	/* process softints */
@


1.15
log
@Use #ifdef TRAPDEBUG and fix indentation.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.14 2011/03/30 13:50:55 jsing Exp $	*/
d569 3
a571 1
		    (p->p_flag & P_PPWAIT) ? SYS_vfork : SYS_fork, 0, 0);
@


1.14
log
@Fix diagnostic by correctly initialising oldcpl.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.11 2010/11/27 19:57:23 miod Exp $	*/
d524 3
a526 3
#if 1
if (kdb_trap (type, va, frame))
	return;
@


1.13
log
@We need db_machdep.h even when TRAPDEBUG is enabled.
@
text
@d181 1
a181 1
	long oldcpl;
d587 1
a587 1
	long oldcpl;
@


1.12
log
@Convert netisr to a normal soft interrupt instead of hanving MD code
for it. This makes the netisr a real C function which will help further
development. No noticable performance change on i386 and amd64.
With input from kettenis@@ and miod@@ additional OKs mikeb@@ and henning@@
@
text
@d39 3
a43 3
#else
#include <machine/db_machdep.h>
#endif
@


1.11
log
@Remove ddb single-step load and store counters. Most platforms do not
implement them, and they are of questionable usefulness.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.10 2010/07/01 04:33:59 jsing Exp $	*/
a28 2

#include <net/netisr.h>
@


1.10
log
@Fix incorrect function prototype.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.9 2010/05/24 15:06:05 deraadt Exp $	*/
a39 1
#include <machine/db_machdep.h>	/* XXX always needed for inst_store() */
d43 2
d47 7
@


1.9
log
@sync to hppa: Add missing prototypes
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.8 2007/09/15 14:55:30 krw Exp $	*/
d118 1
a118 1
void	userret(struct proc *p);
@


1.8
log
@realy -> really in comments. Most reported on tech@@ by Jung.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.7 2007/03/15 10:22:29 art Exp $	*/
d118 2
d567 1
@


1.7
log
@Since p_flag is often manipulated in interrupts and without biglock
it's a good idea to use atomic.h operations on it. This mechanic
change updates all bit operations on p_flag to atomic_{set,clear}bits_int.

Only exception is that P_OWEUPC is set by MI code before calling
need_proftick and it's automatically cleared by ADDUPC. There's
no reason for MD handling of that flag since everyone handles it the
same way.

kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.6 2005/10/26 18:35:45 martin Exp $	*/
d534 1
a534 1
	 * treat this as we were not realy running user code no more
@


1.6
log
@no more hppa_round_page() and hppa_trunc_page() macros

ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.5 2005/09/15 21:14:27 miod Exp $	*/
a130 1
			p->p_flag &= ~P_OWEUPC;
@


1.5
log
@In syscall(), do not recompute the struct proc * after the syscall has
succeeded. This used to be necessary for fork(), when returning in the child,
but we return in the child in child_return() which does TRT.

ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.4 2005/09/15 21:09:29 miod Exp $	*/
d382 1
a382 1
			    uvm_fault(map, hppa_trunc_page(va), fault,
d431 1
a431 1
		ret = uvm_fault(map, hppa_trunc_page(va), fault, vftype);
@


1.4
log
@Change child_return() to record a proper ktrace record for vfork child
processes.

ok art@@ uwe@@ (some time ago)
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.3 2005/08/14 10:54:17 miod Exp $	*/
a685 2
	p = curproc;
	frame = p->p_md.md_regs;
@


1.3
log
@Add mquery to the system calls which need extra care due to off_t arguments
and reversed stack direction; ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.2 2005/07/18 02:43:25 fgsch Exp $	*/
d561 2
a562 1
		ktrsysret(p, SYS_fork, 0, 0);
@


1.2
log
@remove trailing newline in panic(9); ok millert@@ and deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.1 2005/04/01 10:40:47 mickey Exp $	*/
d655 1
@


1.1
log
@small batch early bottling hppa64 port
matured in mighty ukrainian oak for 23 months
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d391 1
a391 1
			panic("trap: %s @@ 0x%x:0x%x for 0x%x:0x%x irr 0x%08x\n",
@

