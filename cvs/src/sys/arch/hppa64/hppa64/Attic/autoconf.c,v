head	1.24;
access;
symbols
	OPENBSD_5_9:1.23.0.4
	OPENBSD_5_9_BASE:1.23
	OPENBSD_5_8:1.23.0.6
	OPENBSD_5_8_BASE:1.23
	OPENBSD_5_7:1.23.0.2
	OPENBSD_5_7_BASE:1.23
	OPENBSD_5_6:1.18.0.4
	OPENBSD_5_6_BASE:1.18
	OPENBSD_5_5:1.17.0.4
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.16.0.8
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.16.0.6
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.4
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.2
	OPENBSD_5_0:1.14.0.2
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.13.0.4
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.2
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.11.0.6
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.11.0.8
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.4
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.2
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.9.0.4
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.2
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.5.0.2
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.4.0.4
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.2
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.3.0.2
	OPENBSD_3_8_BASE:1.3;
locks; strict;
comment	@ * @;


1.24
date	2016.05.11.21.52.50;	author deraadt;	state dead;
branches;
next	1.23;
commitid	VpgRpYXqYSJy4P7J;

1.23
date	2014.12.09.06.58.28;	author doug;	state Exp;
branches;
next	1.22;
commitid	yWAxzpQP2PPpYlfT;

1.22
date	2014.10.12.20.39.46;	author miod;	state Exp;
branches;
next	1.21;
commitid	n8DZa9w0X2LVgDkM;

1.21
date	2014.09.15.19.08.21;	author miod;	state Exp;
branches;
next	1.20;
commitid	uuiU9j2I8AUx0fez;

1.20
date	2014.09.04.19.01.02;	author miod;	state Exp;
branches;
next	1.19;
commitid	E2EstJWFDNJM8qzB;

1.19
date	2014.08.29.21.21.39;	author miod;	state Exp;
branches;
next	1.18;
commitid	XcQ9UrJqjYkBnPTz;

1.18
date	2014.07.12.18.44.41;	author tedu;	state Exp;
branches;
next	1.17;
commitid	uKVPYMN2MLxdZxzH;

1.17
date	2013.10.04.18.46.07;	author kettenis;	state Exp;
branches;
next	1.16;

1.16
date	2011.09.22.21.51.24;	author jsing;	state Exp;
branches;
next	1.15;

1.15
date	2011.09.22.13.50.30;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2011.04.07.13.13.01;	author jsing;	state Exp;
branches;
next	1.13;

1.13
date	2010.07.01.04.33.23;	author jsing;	state Exp;
branches;
next	1.12;

1.12
date	2010.05.24.15.06.05;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2008.07.21.04.35.54;	author todd;	state Exp;
branches;
next	1.10;

1.10
date	2008.04.20.18.05.25;	author kettenis;	state Exp;
branches;
next	1.9;

1.9
date	2007.06.01.19.25.09;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2007.05.29.20.36.47;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2007.05.04.19.30.55;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2007.05.04.03.44.44;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2006.11.28.16.56.50;	author dlg;	state Exp;
branches;
next	1.4;

1.4
date	2005.12.27.18.31.09;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2005.05.25.20.49.26;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	2005.05.22.01.38.09;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	2005.04.01.10.40.47;	author mickey;	state Exp;
branches;
next	;


desc
@@


1.24
log
@remove hppa64 port, which we never got going beyond broken single users.
hppa reverse-stack gives us a valuable test case, but most developers don't
have a 2nd one to proceed further with this.
ok kettenis
@
text
@/*	$OpenBSD: autoconf.c,v 1.23 2014/12/09 06:58:28 doug Exp $	*/

/*
 * Copyright (c) 1998-2005 Michael Shalayeff
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
 *
 * All advertising materials mentioning features or use of this software
 * must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Lawrence Berkeley Laboratory.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)autoconf.c	8.4 (Berkeley) 10/1/93
 */

#include "pci.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/disklabel.h>
#include <sys/conf.h>
#include <sys/reboot.h>
#include <sys/device.h>
#include <sys/timeout.h>
#include <sys/malloc.h>

#include <machine/iomod.h>
#include <machine/autoconf.h>
#include <machine/reg.h>

#include <dev/cons.h>

#include <hppa/dev/cpudevs.h>

#if NPCI > 0
#include <dev/pci/pcivar.h>
#include <dev/pci/pcireg.h>
#endif

/* device we booted from */
struct device *bootdv;
void	dumpconf(void);
void	print_devpath(const char *label, struct pz_device *pz);

void (*cold_hook)(int); /* see below */

/*
 * LED blinking thing
 */
#ifdef USELEDS
#include <sys/kernel.h>

struct timeout heartbeat_tmo;
void heartbeat(void *);
#endif

#include "cd.h"
#include "sd.h"
#include "st.h"
#include "mpath.h"

#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>
#if NMPATH > 0
#include <scsi/mpathvar.h>
#endif

/*
 * cpu_configure:
 * called at boot time, configure all devices on system
 */
void
cpu_configure(void)
{
	struct confargs ca;

	splhigh();
	bzero(&ca, sizeof(ca));
	if (config_rootfound("mainbus", &ca) == NULL)
		panic("no mainbus found");

	cpu_intr_init();
	spl0();

	if (cold_hook)
		(*cold_hook)(HPPA_COLD_HOT);

#ifdef USELEDS
	timeout_set(&heartbeat_tmo, heartbeat, NULL);
	heartbeat(NULL);
#endif
	cold = 0;
}

void
diskconf(void)
{
	print_devpath("bootpath", &PAGE0->mem_boot);

#if NMPATH > 0
	if (bootdv != NULL)
		bootdv = mpath_bootdv(bootdv);
#endif

	setroot(bootdv, 0, RB_USERREQ);
	dumpconf();
}

#ifdef USELEDS
/*
 * turn the heartbeat alive.
 * right thing would be to pass counter to each subsequent timeout
 * as an argument to heartbeat() incrementing every turn,
 * i.e. avoiding the static hbcnt, but doing timeout_set() on each
 * timeout_add() sounds ugly, guts of struct timeout looks ugly
 * to ponder in even more.
 */
void
heartbeat(void *v)
{
	static u_int hbcnt = 0, ocp_total, ocp_idle;
	int toggle, cp_mask, cp_total, cp_idle;
	struct schedstate_percpu *spc = &(curcpu()->ci_schedstate);

	timeout_add(&heartbeat_tmo, hz / 16);

	cp_idle = spc->spc_cp_time[CP_IDLE];
	cp_total = spc->spc_cp_time[CP_USER] + spc->spc_cp_time[CP_NICE] +
	    spc->spc_cp_time[CP_SYS] + spc->spc_cp_time[CP_INTR] +
	    spc->spc_cp_time[CP_IDLE];
	if (cp_total == ocp_total)
		cp_total = ocp_total + 1;
	if (cp_idle == ocp_idle)
		cp_idle = ocp_idle + 1;
	cp_mask = 0xf0 >> (cp_idle - ocp_idle) * 4 / (cp_total - ocp_total);
	cp_mask &= 0xf0;
	ocp_total = cp_total;
	ocp_idle = cp_idle;
	/*
	 * do this:
	 *
	 *   |~| |~|
	 *  _| |_| |_,_,_,_
	 *   0 1 2 3 4 6 7
	 */
	toggle = 0;
	if (hbcnt++ < 8 && hbcnt & 1)
		toggle = PALED_HEARTBEAT;
	hbcnt &= 15;
	ledctl(cp_mask,
	    (~cp_mask & 0xf0) | PALED_NETRCV | PALED_NETSND | PALED_DISK,
	    toggle);
}
#endif

/*
 * This is called by configure to set dumplo and dumpsize.
 * Dumps always skip the first CLBYTES of disk space
 * in case there might be a disk label stored there.
 * If there is extra space, put dump at the end to
 * reduce the chance that swapping trashes it.
 */
void
dumpconf(void)
{
	extern int dumpsize;
	int nblks, dumpblks;	/* size of dump area */

	if (dumpdev == NODEV ||
	    (nblks = (bdevsw[major(dumpdev)].d_psize)(dumpdev)) == 0)
		return;
	if (nblks <= ctod(1))
		return;

	dumpblks = cpu_dumpsize();
	if (dumpblks < 0)
		return;
	dumpblks += ctod(physmem);

	/* If dump won't fit (incl. room for possible label), punt. */
	if (dumpblks > (nblks - ctod(1)))
		return;

	/* Put dump at end of partition */
	dumplo = nblks - dumpblks;

	/* dumpsize is in page units, and doesn't include headers. */
	dumpsize = physmem;
}

void
print_devpath(const char *label, struct pz_device *pz)
{
	int i;

	printf("%s: ", label);

	for (i = 0; i < 6; i++)
		if (pz->pz_bc[i] >= 0)
			printf("%d/", pz->pz_bc[i]);

	printf("%d.%x", pz->pz_mod, pz->pz_layers[0]);
	for (i = 1; i < 6 && pz->pz_layers[i]; i++)
		printf(".%x", pz->pz_layers[i]);

	printf(" class=%d flags=%b hpa=0x%08x spa=0x%08x io=0x%08x\n",
	    pz->pz_class, pz->pz_flags, PZF_BITS, pz->pz_hpa, pz->pz_spa,
	    pz->pz_iodc_io);
}

u_int32_t pdc_rt[16 / 4 * sizeof(struct pdc_pat_pci_rt)] PDC_ALIGNMENT;
struct pdc_sysmap_find pdc_find PDC_ALIGNMENT;
struct pdc_iodc_read pdc_iodc_read PDC_ALIGNMENT;
struct pdc_pat_cell_id pdc_pat_cell_id PDC_ALIGNMENT;
struct pdc_pat_cell_module pdc_pat_cell_module PDC_ALIGNMENT;
struct pdc_pat_io_num pdc_pat_io_num PDC_ALIGNMENT;
const char *pat_names[] = {
	"central",
	"cpu",
	"memory",
	"sba",
	"lba",
	"pbc",
	"cfc",
	"fabric"
};

void
pdc_scan(struct device *self, struct confargs *ca)
{
	struct device_path path;
	struct confargs nca;
	u_long	rv[16];
	int	i, err, mod = ca->ca_mod;

	if (pdc_call((iodcio_t)pdc, 0, PDC_PAT_CELL, PDC_PAT_CELL_GETID,
	    &pdc_pat_cell_id, 0))
		for (i = 0; !(err = pdc_call((iodcio_t)pdc, 0, PDC_SYSMAP,
		    PDC_SYSMAP_FIND, &pdc_find, &path, i)); i++) {
			if (autoconf_verbose)
				printf(">> hpa %x/%x dp %d/%d/%d/%d/%d/%d.%d\n",
				    pdc_find.hpa, pdc_find.size,
				    path.dp_bc[0], path.dp_bc[1], path.dp_bc[2],
				    path.dp_bc[3], path.dp_bc[4], path.dp_bc[5],
				    path.dp_mod);

			if (path.dp_bc[5] == mod) {
				nca = *ca;
				nca.ca_name = NULL;
				nca.ca_hpa = 0xffffffff00000000ULL |
				    (hppa_hpa_t)pdc_find.hpa;
				nca.ca_hpasz = pdc_find.size;
				nca.ca_mod = path.dp_mod;

				err = pdc_call((iodcio_t)pdc, 0, PDC_IODC,
				    PDC_IODC_READ, &pdc_iodc_read, nca.ca_hpa,
				    IODC_DATA, &nca.ca_type, sizeof(nca.ca_type));
				if (err < 0 || pdc_iodc_read.size < 8) {
					if (autoconf_verbose)
						printf(">> iodc_data error %d\n", err);
					bzero(&nca.ca_type, sizeof(nca.ca_type));
				}

				if (autoconf_verbose) {
					u_int *p = (u_int *)&nca.ca_type;
					printf(">> iodc_data 0x%08x 0x%08x\n",
					    p[0], p[1]);
				}

				config_found(self, &nca, mbprint);
			}
		}

	for (i = 0; !(err = pdc_call((iodcio_t)pdc, 0, PDC_PAT_CELL,
	    PDC_PAT_CELL_MODULE, rv, pdc_pat_cell_id.loc, i,
	    PDC_PAT_PAVIEW, &pdc_pat_cell_module, 0)); i++) {
		if (autoconf_verbose)
			printf(">> chpa %lx info %lx loc %lx "
			    "dp %d/%d/%d/%d/%d/%d.%d\n",
			    pdc_pat_cell_module.chpa, pdc_pat_cell_module.info,
			    pdc_pat_cell_module.loc,
			    pdc_pat_cell_module.dp.dp_bc[0],
			    pdc_pat_cell_module.dp.dp_bc[1],
			    pdc_pat_cell_module.dp.dp_bc[2],
			    pdc_pat_cell_module.dp.dp_bc[3],
			    pdc_pat_cell_module.dp.dp_bc[4],
			    pdc_pat_cell_module.dp.dp_bc[5],
			    pdc_pat_cell_module.dp.dp_mod);

		if (pdc_pat_cell_module.dp.dp_bc[5] == mod) {
			int t;

			t = PDC_PAT_CELL_MODTYPE(pdc_pat_cell_module.info);
			if (t >= sizeof(pat_names)/sizeof(pat_names[0]))
				continue;

			nca = *ca;
			nca.ca_name = pat_names[t];
			nca.ca_hpa = pdc_pat_cell_module.chpa &
			    ~(u_long)PAGE_MASK;
			nca.ca_hpasz =
			    PDC_PAT_CELL_MODSIZE(pdc_pat_cell_module.info);
			nca.ca_mod = pdc_pat_cell_module.dp.dp_mod;

			err = pdc_call((iodcio_t)pdc, 0, PDC_IODC,
			    PDC_IODC_READ, &pdc_iodc_read, nca.ca_hpa,
			    IODC_DATA, &nca.ca_type, sizeof(nca.ca_type));
			if (err < 0 || pdc_iodc_read.size < 8) {
				if (autoconf_verbose)
					printf(">> iodc_data error %d\n", err);
				bzero(&nca.ca_type, sizeof(nca.ca_type));
			}
			if (autoconf_verbose) {
				u_int *p = (u_int *)&nca.ca_type;
				printf(">> iodc_data 0x%08x 0x%08x\n",
				    p[0], p[1]);
			}

			config_found(self, &nca, mbprint);
		}
	}
}

struct pdc_pat_pci_rt *pdc_getirt(int *);

struct pdc_pat_pci_rt *
pdc_getirt(int *pn)
{
	struct pdc_pat_pci_rt *rt;
	int i, num, err;
	long cell;

	cell = -1;
	if (!pdc_call((iodcio_t)pdc, 0, PDC_PAT_CELL, PDC_PAT_CELL_GETID,
	    &pdc_pat_cell_id, 0)) {
		cell = pdc_pat_cell_id.id;

		if ((err = pdc_call((iodcio_t)pdc, 0, PDC_PAT_IO,
		    PDC_PAT_IO_GET_PCI_RTSZ, &pdc_pat_io_num, cell))) {
			printf("irt size error %d\n", err);
			return (NULL);
		}
	} else if ((err = pdc_call((iodcio_t)pdc, 0, PDC_PCI_INDEX,
	    PDC_PCI_GET_INT_TBL_SZ, &pdc_pat_io_num, cpu_gethpa(0)))) {
		printf("irt size error %d\n", err);
		return (NULL);
	}

printf("num %d ", pdc_pat_io_num.num);
	*pn = num = pdc_pat_io_num.num;
	if (num > sizeof(pdc_rt) / sizeof(*rt)) {
		printf("\nPCI IRT is too big %d\n", num);
		return (NULL);
	}

	if (!(rt = mallocarray(num, sizeof(*rt), M_DEVBUF, M_NOWAIT)))
		return (NULL);

	if (cell >= 0) {
		if ((err = pdc_call((iodcio_t)pdc, 0, PDC_PAT_IO,
		    PDC_PAT_IO_GET_PCI_RT, rt, cell))) {
			printf("irt fetch error %d\n", err);
			free(rt, M_DEVBUF, 0);
			return (NULL);
		}
	} else if ((err = pdc_call((iodcio_t)pdc, 0, PDC_PCI_INDEX,
	    PDC_PCI_GET_INT_TBL, &pdc_pat_io_num, cpu_gethpa(0), pdc_rt))) {
		printf("irt fetch error %d\n", err);
		free(rt, M_DEVBUF, 0);
		return (NULL);
	}
	bcopy(pdc_rt, rt, num * sizeof(*rt));

for (i = 0; i < num; i++)
printf("\n%d: ty 0x%02x it 0x%02x trig 0x%02x pin 0x%02x bus %d seg %d line %d addr 0x%llx",
i, rt[i].type, rt[i].itype, rt[i].trigger, rt[i].pin, rt[i].bus, rt[i].seg, rt[i].line, rt[i].addr);
	return rt;
}

const struct hppa_mod_info hppa_knownmods[] = {
#include <arch/hppa/dev/cpudevs_data.h>
};

const char *
hppa_mod_info(int type, int sv)
{
	const struct hppa_mod_info *mi;
	static char fakeid[32];

	for (mi = hppa_knownmods; mi->mi_type >= 0 &&
	    (mi->mi_type != type || mi->mi_sv != sv); mi++);

	if (mi->mi_type < 0) {
		snprintf(fakeid, sizeof fakeid, "type %x, sv %x", type, sv);
		return fakeid;
	} else
		return mi->mi_name;
}

void
device_register(struct device *dev, void *aux)
{
#if NPCI > 0
	extern struct cfdriver pci_cd;
#endif
#if NCD > 0 || NSD > 0 || NST > 0
	extern struct cfdriver scsibus_cd;
#endif
	struct confargs *ca = aux;
	static struct device *elder = NULL;

	if (bootdv != NULL)
		return;	/* We already have a winner */

#if NPCI > 0
	if (dev->dv_parent &&
	    dev->dv_parent->dv_cfdata->cf_driver == &pci_cd) {
		struct pci_attach_args *pa = aux;
		pcireg_t addr;
		int reg;

		for (reg = PCI_MAPREG_START; reg < PCI_MAPREG_END; reg += 4) {
			addr = pci_conf_read(pa->pa_pc, pa->pa_tag, reg);
			if (PCI_MAPREG_TYPE(addr) == PCI_MAPREG_TYPE_IO)
				addr = PCI_MAPREG_IO_ADDR(addr);
			else
				addr = PCI_MAPREG_MEM_ADDR(addr);

			if (addr == (pcireg_t)(u_long)PAGE0->mem_boot.pz_hpa) {
				elder = dev;
				break;
			}
		}
	} else
#endif
	if (ca->ca_hpa == (hppa_hpa_t)PAGE0->mem_boot.pz_hpa) {
		/*
		 * If hpa matches, the only thing we know is that the
		 * booted device is either this one or one of its children.
		 * And the children will not necessarily have the correct
		 * hpa value.
		 * Save this elder for now.
		 */
		elder = dev;
	} else if (elder == NULL) {
		return;	/* not the device we booted from */
	}

	/*
	 * Unfortunately, we can not match on pz_class vs dv_class on
	 * older snakes netbooting using the rbootd protocol.
	 * In this case, we'll end up with pz_class == PCL_RANDOM...
	 * Instead, trust the device class from what the kernel attached
	 * now...
	 */
	switch (dev->dv_class) {
	case DV_IFNET:
		/*
		 * Netboot is the top elder
		 */
		if (elder == dev) {
			bootdv = dev;
		}
		return;
	case DV_DISK:
	case DV_DULL:
		if ((PAGE0->mem_boot.pz_class & PCL_CLASS_MASK) != PCL_RANDOM)
			return;
		break;
	case DV_TAPE:
		if ((PAGE0->mem_boot.pz_class & PCL_CLASS_MASK) != PCL_SEQU)
			return;
		break;
	default:
		/* No idea what we were booted from, but better ask the user */
		return;
	}

	/*
	 * If control goes here, we are booted from a block device and we
	 * matched a block device.
	 *
	 * We only grok SCSI boot currently.  Match on proper device
	 * hierarchy and unit/lun values.
	 */

#if NCD > 0 || NSD > 0 || NST > 0
	if (dev->dv_parent &&
	    dev->dv_parent->dv_cfdata->cf_driver == &scsibus_cd) {
		struct scsi_attach_args *sa = aux;
		struct scsi_link *sl = sa->sa_sc_link;

		/*
		 * sd/st/cd is attached to scsibus which is attached to
		 * the controller. Hence the grandparent here should be
		 * the elder.
		 */
		if (dev->dv_parent->dv_parent != elder) {
			return;
		}

		/*
		 * And now check for proper target and lun values
		 */
		if (sl->target == PAGE0->mem_boot.pz_layers[0] &&
		    sl->lun == PAGE0->mem_boot.pz_layers[1]) {
			bootdv = dev;
		}
	}
#endif
}

struct nam2blk nam2blk[] = {
	{ "rd",		3 },
	{ "sd",		4 },
	{ "st",		5 },
	{ "cd",		6 },
#if 0
	{ "wd",		? },
	{ "fd",		7 },
#endif
	{ "vnd",	2 },
	{ NULL,		-1 }
};
@


1.23
log
@Replace some malloc(n*size,...) calls with mallocarray().

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.22 2014/10/12 20:39:46 miod Exp $	*/
@


1.22
log
@Rough sync with hppa to make this compile again.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.21 2014/09/15 19:08:21 miod Exp $	*/
d385 1
a385 1
	if (!(rt = malloc(num * sizeof(*rt), M_DEVBUF, M_NOWAIT)))
@


1.21
log
@Remove non-standard <sys/dkstat.h> header. It has not contained anything
related to disk stastics for almost 17 years, and the remaining
userland-visible defines duplicate those found in <sys/sched.h>.

Move the remaining _KERNEL defines to <sys/tty.h> where they belong, and
update all users to cope with this.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.20 2014/09/04 19:01:02 miod Exp $	*/
d235 3
a237 2
	printf(" class=%d flags=%b hpa=%p spa=%p io=%p\n", pz->pz_class,
	    pz->pz_flags, PZF_BITS, pz->pz_hpa, pz->pz_spa, pz->pz_iodc_io);
d378 1
a378 1
printf("num %ld ", pdc_pat_io_num.num);
@


1.20
log
@Revert previous change, but use curcpu()->ci_schedstate.spc_cp_time[] instead
of global cp_time[] for live information, as loadavg is not updated fast
enough for hz/16 blinking rate. Prompted by feedback from mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.19 2014/08/29 21:21:39 miod Exp $	*/
a79 1
#include <sys/dkstat.h>
@


1.19
log
@Use the load average from averunnable.ldavg[] instead of bogus cp_time[]
arithmetic to display the load average in leds 5-8 of 8 led systems.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.18 2014/07/12 18:44:41 tedu Exp $	*/
d151 3
a153 2
	static u_int hbcnt = 0;
	int toggle, cp_mask;
d157 12
a168 5
	/* display the load average in the upper leds if any */
	cp_mask = averunnable.ldavg[0] >> FSHIFT;
	if (cp_mask > 0x0f)
		cp_mask = 0x0f;
	cp_mask <<= 4;
@


1.18
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.17 2013/10/04 18:46:07 kettenis Exp $	*/
d151 2
a152 2
	static u_int hbcnt = 0, ocp_total, ocp_idle;
	int toggle, cp_mask, cp_total, cp_idle;
d156 5
a160 11
	cp_idle = cp_time[CP_IDLE];
	cp_total = cp_time[CP_USER] + cp_time[CP_NICE] + cp_time[CP_SYS] +
	    cp_time[CP_INTR] + cp_time[CP_IDLE];
	if (cp_total == ocp_total)
		cp_total = ocp_total + 1;
	if (cp_idle == ocp_idle)
		cp_idle = ocp_idle + 1;
	cp_mask = 0xf0 >> (cp_idle - ocp_idle) * 4 / (cp_total - ocp_total);
	cp_mask &= 0xf0;
	ocp_total = cp_total;
	ocp_idle = cp_idle;
@


1.17
log
@Fix boot device matching in the presence of mpath(4).
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.16 2011/09/22 21:51:24 jsing Exp $	*/
d390 1
a390 1
			free(rt, M_DEVBUF);
d396 1
a396 1
		free(rt, M_DEVBUF);
@


1.16
log
@Ansify functions definitions.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.15 2011/09/22 13:50:30 deraadt Exp $	*/
d90 2
a91 1
#if NCD > 0 || NSD > 0 || NST > 0
d94 2
d129 6
d433 3
a436 1
	char *basename;
d493 1
d509 3
a512 1
	basename = dev->dv_cfdata->cf_driver->cd_name;
a513 4
	/*
	 * We only grok SCSI boot currently. Match on proper device hierarchy,
	 * name and unit/lun values.
	 */
d515 2
a516 2
	if (strcmp(basename, "sd") == 0 || strcmp(basename, "cd") == 0 ||
	    strcmp(basename, "st") == 0) {
d525 1
a525 2
		if (dev->dv_parent == NULL ||
		    dev->dv_parent->dv_parent != elder) {
@


1.15
log
@Start removing some tiny irrelevant differences between hppa64 and hppa
so that important differences can be spotted easier.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.14 2011/04/07 13:13:01 jsing Exp $	*/
d140 1
a140 2
heartbeat(v)
	void *v;
d403 1
a403 2
hppa_mod_info(type, sv)
	int type, sv;
@


1.14
log
@Initial interrupt handling implementation for hppa64.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.12 2010/05/24 15:06:05 deraadt Exp $	*/
d69 2
d72 1
a72 1
void	print_devpath(const char *, struct pz_device *);
a75 3
/* device we booted from */
struct device *bootdv;

d125 1
a125 1
	print_devpath("boot path", &PAGE0->mem_boot);
a210 3

void	print_devpath(const char *label, struct pz_device *pz);

a500 2

	/* TODO wd detect */
@


1.13
log
@Add missing function prototypes.
@
text
@d110 1
a110 1
	mtctl(0xffffffffffffffffULL, CR_EIEM);
@


1.12
log
@sync to hppa: Add missing prototypes
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.11 2008/07/21 04:35:54 todd Exp $	*/
d346 2
@


1.11
log
@nam2blk[] needs a "vnd" entry for some things (like softraid)
ok marco@@ no objection miod@@ need this for regress djm@@ no objection krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.10 2008/04/20 18:05:25 kettenis Exp $	*/
d212 2
@


1.10
log
@Add missing function declaration.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.9 2007/06/01 19:25:09 deraadt Exp $	*/
d544 1
@


1.9
log
@some architectures called setroot() from cpu_configure(), *way* before some
subsystems were enabled.  others used a *md_diskconf -> diskconf() method to
make sure init_main could "do late setroot".  Change all architectures to
have diskconf(), use it directly & late.  tested by todd and myself on most
architectures, ok miod too
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.9 2007/06/01 19:20:46 deraadt Exp $	*/
d70 1
@


1.8
log
@start of dumpconf() unification, which one day we can pray will be MI
(and part of setroot); ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.7 2007/05/04 19:30:55 deraadt Exp $	*/
a111 3
	print_devpath("boot path", &PAGE0->mem_boot);
	setroot(bootdv, 0, RB_USERREQ);
	dumpconf();
d120 8
@


1.7
log
@make findblkmajor() and findblkname() MI; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.6 2007/05/04 03:44:44 deraadt Exp $	*/
a182 1
	int maj;
d184 3
a186 8
	if (dumpdev == NODEV)
		goto bad;
	maj = major(dumpdev);
	if (maj < 0 || maj >= nblkdev)
		panic("dumpconf: bad dumpdev=0x%x", dumpdev);
	if (bdevsw[maj].d_psize == NULL)
		goto bad;
	nblks = (*bdevsw[maj].d_psize)(dumpdev);
d188 2
a189 1
		goto bad;
d192 1
a192 1
		goto bad;
d197 1
a197 1
		goto bad;
a203 5
	return;

bad:
	dumpsize = 0;
	return;
@


1.6
log
@setroot() was a ugly mix of MI and MD code, with different bugs on different
machines.  Instead -- build one solid clean MI version, and thenchange all
the architectures to use it.  ok various people, tested on almost all cases.
(it is a 10094 line diff..)
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.5 2006/11/28 16:56:50 dlg Exp $	*/
d539 1
a539 4
static struct {
	char	name[4];
	int	maj;
} nam2blk[] = {
d548 1
a549 23

int
findblkmajor(struct device *dv)
{
	char *name = dv->dv_xname;
	int i;

	for (i = 0; i < sizeof(nam2blk)/sizeof(nam2blk[0]); i++)
		if (!strncmp(name, nam2blk[i].name, strlen(nam2blk[i].name)))
			return (nam2blk[i].maj);
	return (-1);
}

const char *
findblkname(int maj)
{
	int i;

	for (i = 0; i < sizeof(nam2blk) / sizeof(nam2blk[0]); ++i)
		if (maj == nam2blk[i].maj)
			return (nam2blk[i].name);
	return (NULL);
}
@


1.5
log
@rename scsibus_attach_args to scsi_attach_args. this can help avoid
confusing when trying to attach scsibus to a hba, since it is really meant
for attaching scsi devices to scsibus.

ok deraadt@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.4 2005/12/27 18:31:09 miod Exp $	*/
a68 1
void	setroot(void);
a70 6
int findblkmajor(struct device *dv);
const char *findblkname(int maj);
struct device *parsedisk(char *str, int len, int defpart, dev_t *devp);
struct device *getdisk(char *str, int len, int defpart, dev_t *devp);
int getstr(char *cp, int size);

d112 2
a113 1
	setroot();
a215 124
const struct nam2blk {
	char name[4];
	int maj;
} nam2blk[] = {
	{ "rd",		3 },
	{ "sd",		4 },
	{ "st",		5 },
	{ "cd",		6 },
#if 0
	{ "wd",		? },
	{ "fd",		7 },
#endif
};

#ifdef RAMDISK_HOOKS
struct device fakerdrootdev = { DV_DISK, {}, NULL, 0, "rd0", NULL };
#endif

int
findblkmajor(dv)
	struct device *dv;
{
	char *name = dv->dv_xname;
	int i;

	for (i = 0; i < sizeof(nam2blk)/sizeof(nam2blk[0]); ++i)
		if (!strncmp(name, nam2blk[i].name, strlen(nam2blk[0].name)))
			return (nam2blk[i].maj);
	return (-1);
}

const char *
findblkname(maj)
	int maj;
{
	int i;

	for (i = 0; i < sizeof(nam2blk) / sizeof(nam2blk[0]); ++i)
		if (maj == nam2blk[i].maj)
			return (nam2blk[i].name);
	return (NULL);
}

struct device *
getdisk(str, len, defpart, devp)
	char *str;
	int len, defpart;
	dev_t *devp;
{
	struct device *dv;

	if ((dv = parsedisk(str, len, defpart, devp)) == NULL) {
		printf("use one of:");
#ifdef RAMDISK_HOOKS
		printf(" %s[a-p]", fakerdrootdev.dv_xname);
#endif
		for (dv = alldevs.tqh_first; dv != NULL;
		    dv = dv->dv_list.tqe_next) {
			if (dv->dv_class == DV_DISK)
				printf(" %s[a-p]", dv->dv_xname);
#ifdef NFSCLIENT
			if (dv->dv_class == DV_IFNET)
				printf(" %s", dv->dv_xname);
#endif
		}
		printf(" halt\n");
	}
	return (dv);
}

struct device *
parsedisk(str, len, defpart, devp)
	char *str;
	int len, defpart;
	dev_t *devp;
{
	struct device *dv;
	char *cp, c;
	int majdev, part;

	if (len == 0)
		return (NULL);

	if (len == 4 && !strcmp(str, "halt"))
		boot(RB_HALT);

	cp = str + len - 1;
	c = *cp;
	if (c >= 'a' && c <= ('a' + MAXPARTITIONS - 1)) {
		part = c - 'a';
		*cp = '\0';
	} else
		part = defpart;

#ifdef RAMDISK_HOOKS
	if (strcmp(str, fakerdrootdev.dv_xname) == 0) {
		dv = &fakerdrootdev;
		goto gotdisk;
	}
#endif
	for (dv = alldevs.tqh_first; dv != NULL; dv = dv->dv_list.tqe_next) {
		if (dv->dv_class == DV_DISK &&
		    strcmp(str, dv->dv_xname) == 0) {
#ifdef RAMDISK_HOOKS
gotdisk:
#endif
			majdev = findblkmajor(dv);
			if (majdev < 0)
				panic("parsedisk");
			*devp = MAKEDISKDEV(majdev, dv->dv_unit, part);
			break;
		}
#ifdef NFSCLIENT
		if (dv->dv_class == DV_IFNET &&
		    strcmp(str, dv->dv_xname) == 0) {
			*devp = NODEV;
			break;
		}
#endif
	}

	*cp = c;
	return (dv);
}
a235 242
/*
 * Attempt to find the device from which we were booted.
 * If we can do so, and not instructed not to do so,
 * change rootdev to correspond to the load device.
 *
 * XXX Actually, swap and root must be on the same type of device,
 * (ie. DV_DISK or DV_IFNET) because of how (*mountroot) is written.
 * That should be fixed.
 */
void
setroot(void)
{
	struct swdevt *swp;
	struct device *dv;
	int len, majdev, part;
	dev_t nrootdev, nswapdev = NODEV;
	char buf[128];
	dev_t temp;
	const char *rootdevname;
	struct device *rootdv, *swapdv;
#ifdef NFSCLIENT
	extern char *nfsbootdevname;
#endif

#ifdef RAMDISK_HOOKS
	bootdv = &fakerdrootdev;
#endif
	part = 0;

	print_devpath("boot path", &PAGE0->mem_boot);

	/*
	 * If 'swap generic' and we couldn't determine boot device,
	 * ask the user.
	 */
	if (mountroot == NULL && bootdv == NULL)
		boothowto |= RB_ASKNAME;

	if (boothowto & RB_ASKNAME) {
		for (;;) {
			printf("root device? ");
			if (bootdv != NULL) {
				printf(" (default %s", bootdv->dv_xname);
				if (bootdv->dv_class == DV_DISK)
					printf("%c", part + 'a');
				printf(")");
			}
			printf(": ");
			len = getstr(buf, sizeof(buf));
			if (len == 0 && bootdv != NULL) {
				strlcpy(buf, bootdv->dv_xname, sizeof buf);
				len = strlen(buf);
			}
			if (len > 0 && buf[len - 1] == '*') {
				buf[--len] = '\0';
				dv = getdisk(buf, len, 1, &nrootdev);
				if (dv != NULL) {
					rootdv = swapdv = dv;
					nswapdev = nrootdev;
					goto gotswap;
				}
			}
			dv = getdisk(buf, len, part, &nrootdev);
			if (dv != NULL) {
				rootdv = dv;
				break;
			}
		}

		/*
		 * because swap must be on same device type as root, for
		 * network devices this is easy.
		 */
		if (rootdv->dv_class == DV_IFNET) {
			swapdv = NULL;
			goto gotswap;
		}
		for (;;) {
			printf("swap device (default %s", rootdv->dv_xname);
			if (rootdv->dv_class == DV_DISK)
				printf("b");
			printf("): ");
			len = getstr(buf, sizeof(buf));
			if (len == 0) {
				switch (rootdv->dv_class) {
				case DV_IFNET:
					nswapdev = NODEV;
					break;
				case DV_DISK:
					nswapdev = MAKEDISKDEV(major(nrootdev),
					    DISKUNIT(nrootdev), 1);
					break;
				case DV_TAPE:
				case DV_TTY:
				case DV_DULL:
				case DV_CPU:
					break;
				}
				swapdv = rootdv;
				break;
			}
			dv = getdisk(buf, len, 1, &nswapdev);
			if (dv) {
				if (dv->dv_class == DV_IFNET)
					nswapdev = NODEV;
				swapdv = dv;
				break;
			}
		}
gotswap:
		majdev = major(nrootdev);
		rootdev = nrootdev;
		dumpdev = nswapdev;
		swdevt[0].sw_dev = nswapdev;
		swdevt[1].sw_dev = NODEV;
	} else if (mountroot == NULL) {

		/*
		 * `swap generic': Use the device the ROM told us to use.
		 */
		majdev = findblkmajor(bootdv);
		if (majdev >= 0) {
			/*
			 * Root and swap are on a disk.
			 * Assume swap is on partition b.
			 */
			rootdv = swapdv = bootdv;
			rootdev = MAKEDISKDEV(majdev, bootdv->dv_unit, part);
			nswapdev = dumpdev =
			    MAKEDISKDEV(majdev, bootdv->dv_unit, 1);
		} else {
			/*
			 * Root and swap are on a net.
			 */
			rootdv = swapdv = bootdv;
			nswapdev = dumpdev = NODEV;
		}
		swdevt[0].sw_dev = nswapdev;
		swdevt[1].sw_dev = NODEV;
	} else {
		/*
		 * `root DEV swap DEV': honour rootdev/swdevt.
		 * rootdev/swdevt/mountroot already properly set.
		 */

		rootdevname = findblkname(major(rootdev));
		return;
	}

	switch (rootdv->dv_class) {
#ifdef NFSCLIENT
	case DV_IFNET:
		mountroot = nfs_mountroot;
		nfsbootdevname = rootdv->dv_xname;
		return;
#endif
#ifndef DISKLESS
	case DV_DISK:
		mountroot = dk_mountroot;
		printf("root on %s%c", rootdv->dv_xname,
		    DISKPART(rootdev) + 'a');
		if (nswapdev != NODEV)
			printf(" swap on %s%c", swapdv->dv_xname,
			    DISKPART(nswapdev) + 'a');
		printf("\n");
		break;
#endif
	default:
		printf("can't figure root, hope your kernel is right\n");
		return;
	}

	/*
	 * Make the swap partition on the root drive the primary swap.
	 */
	temp = NODEV;
	for (swp = swdevt; swp->sw_dev != NODEV; swp++) {
		if (majdev == major(swp->sw_dev) &&
		    DISKUNIT(rootdev) == DISKUNIT(swp->sw_dev)) {
			temp = swdevt[0].sw_dev;
			swdevt[0].sw_dev = swp->sw_dev;
			swp->sw_dev = temp;
			break;
		}
	}
	if (swp->sw_dev == NODEV)
		return;

	/*
	 * If dumpdev was the same as the old primary swap device,
	 * move it to the new primary swap device.
	 */
	if (temp == dumpdev)
		dumpdev = swdevt[0].sw_dev;
}

int
getstr(cp, size)
	char *cp;
	int size;
{
	char *lp;
	int c;
	int len;

	lp = cp;
	len = 0;
	for (;;) {
		c = cngetc();
		switch (c) {
		case '\n':
		case '\r':
			printf("\n");
			*lp++ = '\0';
			return (len);
		case '\b':
		case '\177':
		case '#':
			if (len) {
				--len;
				--lp;
				printf("\b \b");
			}
			continue;
		case '@@':
		case 'u'&037:
			len = 0;
			lp = cp;
			printf("\n");
			continue;
		default:
			if (len + 1 >= size || c < ' ') {
				printf("\007");
				continue;
			}
			printf("%c", c);
			++len;
			*lp++ = c;
		}
	}
}

d537 37
@


1.4
log
@Remove unused sw_nblks field of struct swdevt. Then, remove swapconf()
which duplicates work done by uvm_swap_init().
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.3 2005/05/25 20:49:26 mickey Exp $	*/
d887 1
a887 1
		struct scsibus_attach_args *sa = aux;
@


1.3
log
@funcs to fetch pci intr routing table(s)
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.2 2005/05/22 01:38:09 mickey Exp $	*/
a69 1
void	swapconf(void);
a119 1
	swapconf();
a175 23

/*
 * Configure swap space and related parameters.
 */
void
swapconf(void)
{
	struct swdevt *swp;
	int nblks, maj;

	for (swp = swdevt; swp->sw_dev != NODEV; swp++) {
		maj = major(swp->sw_dev);
		if (maj > nblkdev)
			break;
		if (bdevsw[maj].d_psize) {
			nblks = (*bdevsw[maj].d_psize)(swp->sw_dev);
			if (nblks != -1 &&
			    (swp->sw_nblks == 0 || swp->sw_nblks > nblks))
				swp->sw_nblks = nblks;
			swp->sw_nblks = ctod(dtoc(swp->sw_nblks));
		}
	}
}
@


1.2
log
@devices scan for the early new hppa64 machines.
match on product id as well as names in correspondent drivers.
chain pluto later in case it shows up too early...
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.1 2005/04/01 10:40:47 mickey Exp $	*/
d54 1
d633 1
d638 1
d744 54
@


1.1
log
@small batch early bottling hppa64 port
matured in mighty ukrainian oak for 23 months
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d632 1
d648 1
a648 1
pdc_patscan(struct device *self, struct confargs *ca, int mod)
d650 2
d653 1
a653 1
	int	i, err;
d656 36
a691 4
	    &pdc_pat_cell_id, 0)) {
		printf("pat_fetch: cannot fetch cell number\n");
		return;
	}
d693 1
a693 2
	i = 0;
	for (i = 0; !pdc_call((iodcio_t)pdc, 0, PDC_PAT_CELL,
d695 1
a695 1
	    PDC_PAT_PAVIEW, &pdc_pat_cell_module, 0); i++) {
a709 1
			struct confargs nca;
d722 1
@

