head	1.35;
access;
symbols
	OPENBSD_5_9:1.34.0.6
	OPENBSD_5_9_BASE:1.34
	OPENBSD_5_8:1.34.0.8
	OPENBSD_5_8_BASE:1.34
	OPENBSD_5_7:1.34.0.2
	OPENBSD_5_7_BASE:1.34
	OPENBSD_5_6:1.34.0.4
	OPENBSD_5_6_BASE:1.34
	OPENBSD_5_5:1.33.0.6
	OPENBSD_5_5_BASE:1.33
	OPENBSD_5_4:1.33.0.2
	OPENBSD_5_4_BASE:1.33
	OPENBSD_5_3:1.30.0.2
	OPENBSD_5_3_BASE:1.30
	OPENBSD_5_2:1.27.0.4
	OPENBSD_5_2_BASE:1.27
	OPENBSD_5_1_BASE:1.27
	OPENBSD_5_1:1.27.0.2
	OPENBSD_5_0:1.26.0.2
	OPENBSD_5_0_BASE:1.26
	OPENBSD_4_9:1.19.0.2
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.17.0.2
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.16.0.2
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.15.0.4
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.14.0.2
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.12.0.2
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.11.0.4
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.2
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.9.0.4
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.2
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.8.0.2
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.5.0.2
	OPENBSD_3_8_BASE:1.5;
locks; strict;
comment	@ * @;


1.35
date	2016.05.11.21.52.50;	author deraadt;	state dead;
branches;
next	1.34;
commitid	VpgRpYXqYSJy4P7J;

1.34
date	2014.07.11.10.53.07;	author uebayasi;	state Exp;
branches;
next	1.33;
commitid	CaCLs5fTSVpJlqFi;

1.33
date	2013.05.31.17.00.58;	author tedu;	state Exp;
branches;
next	1.32;

1.32
date	2013.03.23.16.12.22;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2013.03.12.09.37.16;	author mpi;	state Exp;
branches;
next	1.30;

1.30
date	2013.02.12.08.06.22;	author mpi;	state Exp;
branches;
next	1.29;

1.29
date	2013.02.11.17.05.25;	author mpi;	state Exp;
branches;
next	1.28;

1.28
date	2012.12.02.07.03.31;	author guenther;	state Exp;
branches;
next	1.27;

1.27
date	2011.08.16.17.36.37;	author kettenis;	state Exp;
branches;
next	1.26;

1.26
date	2011.07.07.18.44.39;	author kettenis;	state Exp;
branches;
next	1.25;

1.25
date	2011.04.21.12.42.59;	author jsing;	state Exp;
branches;
next	1.24;

1.24
date	2011.04.16.22.02.32;	author kettenis;	state Exp;
branches;
next	1.23;

1.23
date	2011.04.07.13.13.01;	author jsing;	state Exp;
branches;
next	1.22;

1.22
date	2011.04.06.14.45.23;	author jsing;	state Exp;
branches;
next	1.21;

1.21
date	2011.04.05.16.05.51;	author jsing;	state Exp;
branches;
next	1.20;

1.20
date	2011.04.05.15.46.53;	author jsing;	state Exp;
branches;
next	1.19;

1.19
date	2010.12.21.14.56.23;	author claudio;	state Exp;
branches;
next	1.18;

1.18
date	2010.09.28.20.27.54;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2010.07.24.21.27.57;	author kettenis;	state Exp;
branches;
next	1.16;

1.16
date	2009.11.25.23.18.14;	author jsing;	state Exp;
branches;
next	1.15;

1.15
date	2009.03.15.19.40.40;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2008.10.10.08.36.28;	author art;	state Exp;
branches;
next	1.13;

1.13
date	2008.10.10.08.05.45;	author art;	state Exp;
branches;
next	1.12;

1.12
date	2008.07.18.23.43.31;	author art;	state Exp;
branches;
next	1.11;

1.11
date	2007.05.16.19.37.06;	author thib;	state Exp;
branches;
next	1.10;

1.10
date	2007.03.15.10.22.29;	author art;	state Exp;
branches;
next	1.9;

1.9
date	2006.03.12.03.14.37;	author brad;	state Exp;
branches;
next	1.8;

1.8
date	2005.09.25.20.48.21;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2005.09.20.23.00.34;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2005.09.20.21.04.14;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2005.05.31.09.31.16;	author art;	state Exp;
branches;
next	1.4;

1.4
date	2005.05.29.03.20.37;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2005.05.25.23.17.47;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	2005.04.19.15.29.48;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	2005.04.01.10.40.48;	author mickey;	state Exp;
branches;
next	;


desc
@@


1.35
log
@remove hppa64 port, which we never got going beyond broken single users.
hppa reverse-stack gives us a valuable test case, but most developers don't
have a 2nd one to proceed further with this.
ok kettenis
@
text
@/*	$OpenBSD: cpu.h,v 1.34 2014/07/11 10:53:07 uebayasi Exp $	*/

/*
 * Copyright (c) 2005 Michael Shalayeff
 * All rights reserved.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER IN
 * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
 * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
/* 
 * Copyright (c) 1988-1994, The University of Utah and
 * the Computer Systems Laboratory at the University of Utah (CSL).
 * All rights reserved.
 *
 * Permission to use, copy, modify and distribute this software is hereby
 * granted provided that (1) source code retains these copyright, permission,
 * and disclaimer notices, and (2) redistributions including binaries
 * reproduce the notices in supporting documentation, and (3) all advertising
 * materials mentioning features or use of this software display the following
 * acknowledgement: ``This product includes software developed by the
 * Computer Systems Laboratory at the University of Utah.''
 *
 * THE UNIVERSITY OF UTAH AND CSL ALLOW FREE USE OF THIS SOFTWARE IN ITS "AS
 * IS" CONDITION.  THE UNIVERSITY OF UTAH AND CSL DISCLAIM ANY LIABILITY OF
 * ANY KIND FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * CSL requests users of this software to return to csl-dist@@cs.utah.edu any
 * improvements that they make and grant CSL redistribution rights.
 *
 * 	Utah $Hdr: cpu.h 1.19 94/12/16$
 */

#ifndef	_MACHINE_CPU_H_
#define	_MACHINE_CPU_H_

#include <machine/trap.h>
#include <machine/frame.h>

/*
 * COPR/SFUs
 */
#define	HPPA_FPUS	0xc0
#define	HPPA_FPUVER(w)	(((w) & 0x003ff800) >> 11)
#define	HPPA_FPU_OP(w)	((w) >> 26)
#define	HPPA_FPU_UNMPL	0x01	/* exception reg, the rest is << 1 */
#define	HPPA_FPU_ILL	0x80	/* software-only */
#define	HPPA_FPU_I	0x01
#define	HPPA_FPU_U	0x02
#define	HPPA_FPU_O	0x04
#define	HPPA_FPU_Z	0x08
#define	HPPA_FPU_V	0x10
#define	HPPA_FPU_D	0x20
#define	HPPA_FPU_T	0x40
#define	HPPA_FPU_XMASK	0x7f
#define	HPPA_FPU_T_POS	25	/* 32bit reg! */
#define	HPPA_FPU_RM	0x00000600
#define	HPPA_FPU_CQ	0x00fff800
#define	HPPA_FPU_C	0x04000000
#define	HPPA_FPU_FLSH	27
#define	HPPA_FPU_INIT	(0)
#define	HPPA_FPU_FORK(s) ((s) & ~((u_int64_t)(HPPA_FPU_XMASK)<<32))
#define	HPPA_PMSFUS	0x20	/* ??? */

#ifndef _LOCORE
#include <sys/time.h>
#include <sys/sched.h>

/*
 * Note that the alignment of ci_trap_save is important since we want to keep
 * it within a single cache line. As a result, it must be kept as the first
 * entry within the cpu_info struct.
 */
struct cpu_info {
	volatile u_long	ci_trap_save[16];

	volatile int	ci_psw;
	volatile int	ci_cpl;

	volatile u_long	ci_ipending;
	volatile int	ci_in_intr;

	struct proc	*ci_curproc;
	struct pcb	*ci_cpcb;
	struct cpu_info	*ci_next;
	paddr_t		ci_fpu_state;		/* Process FPU state. */

	int		ci_number;
	struct schedstate_percpu ci_schedstate;	/* scheduler state */
	u_int32_t	ci_randseed;

	/* Spinning up the CPU */
	void		(*ci_spinup)(void); /* spinup routine */
	void		*ci_initstack;

	u_long		ci_itmr;
#ifdef DIAGNOSTIC
	int		ci_mutex_level;
#endif
#ifdef GPROF
	struct gmonparam *ci_gmon;
#endif
};

struct cpu_info *curcpu(void);
#define	cpu_number()		(curcpu()->ci_number)
#define	CPU_IS_PRIMARY(ci)	((ci)->ci_number == 0)
#define	CPU_INFO_ITERATOR	int
#define	CPU_INFO_FOREACH(cii,ci) \
	for (cii = 0, ci = curcpu(); ci != NULL; ci = ci->ci_next)
#define	CPU_INFO_UNIT(ci)	((ci)->ci_number)
#define MAXCPUS	1
#define cpu_unidle(ci)

#define CPU_BUSY_CYCLE()	do {} while (0)

/* types */
enum hppa_cpu_type {
	hpcxu, hpcxu2, hpcxw
};
extern enum hppa_cpu_type cpu_type;
extern const char *cpu_typename;
extern int cpu_hvers;
#endif

/*
 * Exported definitions unique to hp700/PA-RISC cpu support.
 */

#define	HPPA_PGALIAS	0x0000000000400000UL
#define	HPPA_PGAMASK	0xffffffffffc00000UL
#define	HPPA_PGAOFF	0x00000000003fffffUL

#define	HPPA_PHYSMAP	0x000001ffffffffffUL
#define	HPPA_IOBEGIN	0xfffffff000000000UL
#define	HPPA_IOLEN	0x0000001000000000UL
#define	HPPA_PHYSEND	0xffffffffffffffffUL
#define	HPPA_IOADDR	0xfffffff100000000UL
#define	HPPA_IOBCAST	0xfffffffffffc0000UL
#define	HPPA_LBCAST	0xfffffffffffc0000UL
#define	HPPA_GBCAST	0xfffffffffffe0000UL
#define	HPPA_FPADDR	0xfffffffffff80000UL
#define	HPPA_FLEX_MASK	0xfffffffffffc0000UL
#define	HPPA_DMA_ENABLE	0x00000001
#define	HPPA_SPA_ENABLE	0x00000020
#define	HPPA_NMODSPBUS	64

#define	clockframe		trapframe
#define	CLKF_PC(framep)		((framep)->tf_iioq[0])
#define	CLKF_INTR(framep)	((framep)->tf_flags & TFF_INTR)
#define	CLKF_USERMODE(framep)	((framep)->tf_flags & T_USER)
#define	CLKF_SYSCALL(framep)	((framep)->tf_flags & TFF_SYS)

#define	signotify(p)		(setsoftast())
#define	need_resched(ci)	(want_resched = 1, setsoftast())
#define clear_resched(ci) 	want_resched = 0
#define	need_proftick(p)	setsoftast()

#define	PROC_PC(p)		((p)->p_md.md_regs->tf_iioq[0])
#define	PROC_STACK(p)		((p)->p_md.md_regs->tf_sp)

#ifndef _LOCORE
#ifdef _KERNEL

extern int want_resched, astpending;

#define DELAY(x) delay(x)

void	delay(u_int us);
void	hppa_init(paddr_t start);
void	trap(int type, struct trapframe *frame);
int	spcopy(pa_space_t ssp, const void *src, pa_space_t dsp, void *dst,
	    size_t size);
int	spstrcpy(pa_space_t ssp, const void *src, pa_space_t dsp, void *dst,
	    size_t size, size_t *rsize);
int	copy_on_fault(void);
void	switch_trampoline(void);
int	cpu_dumpsize(void);
int	cpu_dump(void);

#ifdef USELEDS
#define	PALED_NETSND	0x01
#define	PALED_NETRCV	0x02
#define	PALED_DISK	0x04
#define	PALED_HEARTBEAT	0x08
#define	PALED_LOADMASK	0xf0

#define	PALED_DATA	0x01
#define	PALED_STROBE	0x02

extern volatile u_int8_t *machine_ledaddr;
extern int machine_ledword, machine_leds;

static __inline void
ledctl(int on, int off, int toggle)
{
	if (machine_ledaddr) {
		int r;

		if (on)
			machine_leds |= on;
		if (off)
			machine_leds &= ~off;
		if (toggle)
			machine_leds ^= toggle;
			
		r = ~machine_leds;	/* it seems they should be reversed */

		if (machine_ledword)
			*machine_ledaddr = r;
		else {
			register int b;
			for (b = 0x80; b; b >>= 1) {
				*machine_ledaddr = (r & b)? PALED_DATA : 0;
				DELAY(1);
				*machine_ledaddr = ((r & b)? PALED_DATA : 0) |
				    PALED_STROBE;
			}
		}
	}
}
#endif

void fpu_save(vaddr_t va);
void fpu_exit(void);
void ficache(pa_space_t sp, vaddr_t va, vsize_t size);
void fdcache(pa_space_t sp, vaddr_t va, vsize_t size);
void pdcache(pa_space_t sp, vaddr_t va, vsize_t size);
void ficacheall(void);
void fdcacheall(void);
void pitlb(pa_space_t sp, vaddr_t va);
void pdtlb(pa_space_t sp, vaddr_t va);
void pitlbe(pa_space_t sp, vaddr_t va);
void pdtlbe(pa_space_t sp, vaddr_t va);
void ptlball(void);
void mtctl(register_t val, int reg);
register_t mfctl(int reg);
hppa_hpa_t cpu_gethpa(int n);
void sync_caches(void);
#endif

/*
 * Boot arguments stuff
 */

#define	BOOTARG_LEN	(PAGE_SIZE)
#define	BOOTARG_OFF	(0x10000)

/*
 * CTL_MACHDEP definitions.
 */
#define	CPU_CONSDEV		1	/* dev_t: console terminal device */
#define	CPU_MAXID		1	/* number of valid machdep ids */

#define CTL_MACHDEP_NAMES { \
	{ 0, 0 }, \
	{ "console_device", CTLTYPE_STRUCT }, \
}
#endif

#endif /* _MACHINE_CPU_H_ */
@


1.34
log
@CPU_BUSY_CYCLE(): A new MI statement for busy loop power reduction

The new CPU_BUSY_CYCLE() may be put in a busy loop body so that CPU can reduce
power consumption, as Linux's cpu_relax() and FreeBSD's cpu_spinwait().  To
start minimally, use PAUSE on i386/amd64 and empty on others.  The name is
chosen following the existing cpu_idle_*() functions.  Naming and API may be
polished later.

OK kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.33
log
@remove counters for simplelocks
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.32 2013/03/23 16:12:22 deraadt Exp $	*/
d122 2
@


1.32
log
@refactor sys/param.h and machine/param.h.  A lot of #ifdef _KERNEL is added
to keep definitions our of user space.  The MD files now follow a consistant
order -- all namespace intrusion is at the tail can be cleaned up
independently.  locore, bootblocks, and libkvm still see enough visibility to
build.  Checked on 90% of platforms...
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.31 2013/03/12 09:37:16 mpi Exp $	*/
a98 4

	/* DEBUG/DIAGNOSTIC stuff */
	u_long		ci_spin_locks;  /* # of spin locks held */
	u_long		ci_simple_locks;/* # of simple locks held */
@


1.31
log
@Fix kernel profiling on MP systems by using per-CPU buffers and teach
kgmon(8) to deal with them, this time without public header changes.

Previously various CPUs were iterating over the same global buffer at
the same time to modify it and never ended.

This diff includes some ideas submited by Thor Simon to NetBSD via miod@@.

ok deraadt@@, mikeb@@, haesbaert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.30 2013/02/12 08:06:22 mpi Exp $	*/
d256 1
a256 1
#define	BOOTARG_LEN	(NBPG)
@


1.30
log
@Back out per-CPU kernel profiling, it shouldn't modify a public header
at this moment.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.29 2013/02/11 17:05:25 mpi Exp $	*/
d111 3
@


1.29
log
@Fix kernel profiling on MP systems by using per-CPU buffer. Previously
various CPUs were iterating over the same global buffer at the same
time to modify it and never ended.

This diff includes some ideas submited by Thor Simon to NetBSD via miod@@.

ok mikeb@@, haesbaert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.28 2012/12/02 07:03:31 guenther Exp $	*/
a110 3
#endif
#ifdef GPROF
	struct gmonparam *ci_gmon;
@


1.28
log
@Determine whether we're currently on the alternative signal stack
dynamically, by comparing the stack pointer against the altstack
base and size, so that you get the correct answer if you longjmp
out of the signal handler, as tested by regress/sys/kern/stackjmp/.
Also, fix alt stack handling on vax, where it was completely broken.

Testing and corrections by miod@@, krw@@, tobiasu@@, pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.27 2011/08/16 17:36:37 kettenis Exp $	*/
d111 3
@


1.27
log
@Use pitlbe and pdtlbe instructions when flushing the entire TLB.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.26 2011/07/07 18:44:39 kettenis Exp $	*/
d165 3
@


1.26
log
@Raise the cache aliasing boundary to 4MB like we did on hppa a couple of years
ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.25 2011/04/21 12:42:59 jsing Exp $	*/
d237 2
@


1.25
log
@Move interrupt related defines and prototypes from cpu.h to intr.h.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.23 2011/04/07 13:13:01 jsing Exp $	*/
d137 3
a139 3
#define	HPPA_PGALIAS	0x0000000000100000UL
#define	HPPA_PGAMASK	0xfffffffffff00000UL
#define	HPPA_PGAOFF	0x00000000000fffffUL
@


1.24
log
@Move the FPU state out of 'struct pcb' like we did for hppa since it causes
evil problems with non-equivalent aliases.
@
text
@a72 43
/*
 * Interrupts stuff
 */
#define	CPU_NINTS	64

#define	IPL_NONE	0
#define	IPL_SOFTCLOCK	1   
#define	IPL_SOFTNET	2
#define	IPL_BIO		3
#define	IPL_NET		4
#define	IPL_SOFTTTY	5
#define	IPL_TTY		6
#define	IPL_VM		7
#define	IPL_AUDIO	8
#define	IPL_CLOCK	9
#define	IPL_STATCLOCK	10
#define	IPL_SCHED	IPL_STATCLOCK
#define	IPL_HIGH	11

#define	NIPL		12

#define	IST_NONE        0
#define	IST_PULSE       1
#define	IST_EDGE        2
#define	IST_LEVEL       3

#define	splsoftclock()	splraise(IPL_SOFTCLOCK)
#define	splsoftnet()	splraise(IPL_SOFTNET)
#define	splbio()	splraise(IPL_BIO)
#define	splnet()	splraise(IPL_NET)
#define	splsofttty()	splraise(IPL_SOFTTTY)
#define	spltty()	splraise(IPL_TTY)
#define	splvm()		splraise(IPL_VM)
#define	splaudio()	splraise(IPL_AUDIO)
#define	splclock()	splraise(IPL_CLOCK)
#define	splsched()	splraise(IPL_SCHED)
#define	splstatclock()	splraise(IPL_STATCLOCK)
#define	splhigh()	splraise(IPL_HIGH)
#define	spl0()		spllower(IPL_NONE)
#define	splx(c)		spllower(c)

#define	setsoftast()		(astpending = 1)

d115 1
a115 1
#define	cpu_number()	(curcpu()->ci_number)
a123 15
#ifdef DIAGNOSTIC   
void splassert_fail(int, int, const char *);
extern int splassert_ctl;
void splassert_check(int, const char *);
#define splassert(__wantipl) do {			\
	if (splassert_ctl > 0) {			\
		splassert_check(__wantipl, __func__);	\
	}						\
} while (0)
#define splsoftassert(__wantipl) splassert(__wantipl)
#else
#define splassert(__wantipl)		do { /* nada */ } while (0)
#define splsoftassert(__wantipl)	do { /* nada */ } while (0)
#endif /* DIAGNOSTIC */

a172 3
int	splraise(int cpl);
int	spllower(int cpl);

d176 4
a179 4
int	spcopy(pa_space_t ssp, const void *src,
		    pa_space_t dsp, void *dst, size_t size);
int	spstrcpy(pa_space_t ssp, const void *src,
		      pa_space_t dsp, void *dst, size_t size, size_t *rsize);
@


1.23
log
@Initial interrupt handling implementation for hppa64.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.22 2011/04/06 14:45:23 jsing Exp $	*/
d137 1
a138 1
	struct proc	*ci_fpproc;
@


1.22
log
@Move CPL to struct cpu_info.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.21 2011/04/05 16:05:51 jsing Exp $	*/
d76 2
d130 3
@


1.21
log
@Implement syscall_return.

"Go ahead" kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.20 2011/04/05 15:46:53 jsing Exp $	*/
d127 1
@


1.20
log
@Move PSW in struct cpu_info. Also ensure that we leave interrupts disabled
when switching to virtual mode in the trap handler. Re-enabling interrupts
whilst in the trap handler for an interrupt makes life interesting.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.18 2010/09/28 20:27:54 miod Exp $	*/
d118 5
d124 2
@


1.19
log
@Convert netisr to a normal soft interrupt instead of hanving MD code
for it. This makes the netisr a real C function which will help further
development. No noticable performance change on i386 and amd64.
With input from kettenis@@ and miod@@ additional OKs mikeb@@ and henning@@
@
text
@d119 2
@


1.18
log
@Implement a per-cpu held mutex counter if DIAGNOSTIC on all non-x86 platforms,
to complete matthew@@'s commit of a few days ago, and drop __HAVE_CPU_MUTEX_LEVEL
define. With help from, and ok deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.17 2010/07/24 21:27:57 kettenis Exp $	*/
a112 3
#define	setsoftclock()		/* TODO */
#define	setsoftnet()		/* TODO */
#define	setsofttty()		/* TODO */
@


1.17
log
@Switch hppa64 to timecounters.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.16 2009/11/25 23:18:14 jsing Exp $	*/
d140 3
@


1.16
log
@Add ci_randseed.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.14 2008/10/10 08:36:28 art Exp $	*/
d138 2
@


1.15
log
@Introduce splsoftassert(), similar to splassert() but for soft interrupt
levels. This will allow for platforms where soft interrupt levels do not
map to real hardware interrupt levels to have soft ipl values overlapping
hard ipl values without breaking spl asserts.
@
text
@d129 1
@


1.14
log
@Add empty cpu_unidle() macros for architectures that currently don't do
anything special to prod a cpu to leave the idle loop in signotify.
powerpc, i386, amd64 and sparc64 will follow soon so that everyone has
the same interface to wake an idling cpu.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.13 2008/10/10 08:05:45 art Exp $	*/
d158 1
d160 2
a161 1
#define splassert(__wantipl)	do { /* nada */ } while (0)
@


1.13
log
@Define MAXCPUS on all architectures.
For now, sparc64 is arbitrarily set to 256 (only architecture that didn't have
a practical limit in the code on the number of cpus).
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.12 2008/07/18 23:43:31 art Exp $	*/
d147 1
@


1.12
log
@Add a macro that clears the want_resched flag that need_resched sets.
Right now when mi_switch picks up the same proc, we didn't clear the
flag which would mean that every time we service an AST we would attempt
a context switch. For some architectures, amd64 being probably the
most extreme, that meant attempting to context switch for every
trap and interrupt.

Now we clear_resched explicitly after every context switch, even if it
didn't do anything. Which also allows us to remove some more code
in cpu_switchto (not done yet).

miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.11 2007/05/16 19:37:06 thib Exp $	*/
d146 1
@


1.11
log
@splassert_ctl defaults to 1 now, so dont wrap the checks for
splassert_ctl > 0 in __predict_false().

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.10 2007/03/15 10:22:29 art Exp $	*/
d199 1
@


1.10
log
@Since p_flag is often manipulated in interrupts and without biglock
it's a good idea to use atomic.h operations on it. This mechanic
change updates all bit operations on p_flag to atomic_{set,clear}bits_int.

Only exception is that P_OWEUPC is set by MI code before calling
need_proftick and it's automatically cleared by ADDUPC. There's
no reason for MD handling of that flag since everyone handles it the
same way.

kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.9 2006/03/12 03:14:37 brad Exp $	*/
d152 1
a152 1
	if (__predict_false(splassert_ctl > 0)) {	\
@


1.9
log
@remove splimp.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.8 2005/09/25 20:48:21 miod Exp $	*/
d199 1
a199 1
#define	need_proftick(p)	((p)->p_flag |= P_OWEUPC, setsoftast())
@


1.8
log
@Turn CPU_INFO_FOREACH into a real construct, like all queue(3) iterators,
instead of the contents of a for() loop. No functional change.
From the m88k SMP tree; ok art@@ deraadt@@

[complete diff this time]
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.7 2005/09/20 23:00:34 deraadt Exp $	*/
a103 1
#define	splimp()	splvm()
@


1.7
log
@unbreak tree, how did you do that miod
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.5 2005/05/31 09:31:16 art Exp $	*/
d145 1
a145 1
	cii = 0, ci = curcpu(); ci != NULL; ci = ci->ci_next
@


1.6
log
@Turn CPU_INFO_FOREACH into a real construct, like all queue(3) iterators,
instead of the contents of a for() loop. No functional change.
From the m88k SMP tree; ok art@@ deraadt@@
@
text
@d145 1
a145 1
	for (cii = 0, ci = curcpu(); ci != NULL; ci = ci->ci_next)
@


1.5
log
@IPL_SCHED should block statclock on architectures where the scheduler
is clocked by the statclock.

miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.4 2005/05/29 03:20:37 deraadt Exp $	*/
d145 1
a145 1
	cii = 0, ci = curcpu(); ci != NULL; ci = ci->ci_next
@


1.4
log
@sched work by niklas and art backed out; causes panics
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.2 2005/04/19 15:29:48 mickey Exp $	*/
a85 1
#define	IPL_SCHED	9
d87 1
@


1.3
log
@This patch is mortly art's work and was done *a year* ago.  Art wants to thank
everyone for the prompt review and ok of this work ;-)  Yeah, that includes me
too, or maybe especially me.  I am sorry.

Change the sched_lock to a mutex. This fixes, among other things, the infamous
"telnet localhost &" problem.  The real bug in that case was that the sched_lock
which is by design a non-recursive lock, was recursively acquired, and not
enough releases made us hold the lock in the idle loop, blocking scheduling
on the other processors.  Some of the other processors would hold the biglock though,
which made it impossible for cpu 0 to enter the kernel...  A nice deadlock.
Let me just say debugging this for days just to realize that it was all fixed
in an old diff noone ever ok'd was somewhat of an anti-climax.

This diff also changes splsched to be correct for all our architectures.
@
text
@d86 1
a87 1
#define	IPL_SCHED	IPL_STATCLOCK
@


1.2
log
@nothing uses spllowersoftclock() anymore
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.1 2005/04/01 10:40:48 mickey Exp $	*/
a85 1
#define	IPL_SCHED	9
d87 1
@


1.1
log
@small batch early bottling hppa64 port
matured in mighty ukrainian oak for 23 months
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a96 1
#define	spllowersoftclock() spllower(IPL_SOFTCLOCK)
@

