head	1.7;
access;
symbols
	OPENBSD_5_9:1.4.0.6
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.4.0.8
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.2
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.4
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.3.0.12
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.8
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.6
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.4
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.2
	OPENBSD_5_0:1.2.0.4
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.2
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.1.0.22
	OPENBSD_4_8_BASE:1.1
	OPENBSD_4_7:1.1.0.18
	OPENBSD_4_7_BASE:1.1
	OPENBSD_4_6:1.1.0.20
	OPENBSD_4_6_BASE:1.1
	OPENBSD_4_5:1.1.0.16
	OPENBSD_4_5_BASE:1.1
	OPENBSD_4_4:1.1.0.14
	OPENBSD_4_4_BASE:1.1
	OPENBSD_4_3:1.1.0.12
	OPENBSD_4_3_BASE:1.1
	OPENBSD_4_2:1.1.0.10
	OPENBSD_4_2_BASE:1.1
	OPENBSD_4_1:1.1.0.8
	OPENBSD_4_1_BASE:1.1
	OPENBSD_4_0:1.1.0.6
	OPENBSD_4_0_BASE:1.1
	OPENBSD_3_9:1.1.0.4
	OPENBSD_3_9_BASE:1.1
	OPENBSD_3_8:1.1.0.2
	OPENBSD_3_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.7
date	2016.05.11.21.52.50;	author deraadt;	state dead;
branches;
next	1.6;
commitid	VpgRpYXqYSJy4P7J;

1.6
date	2016.04.27.11.10.48;	author mpi;	state Exp;
branches;
next	1.5;
commitid	57btDderNGPG4fjG;

1.5
date	2016.02.27.13.08.07;	author mpi;	state Exp;
branches;
next	1.4;
commitid	hnv9KfQtxhCytAnd;

1.4
date	2014.03.16.20.31.46;	author guenther;	state Exp;
branches;
next	1.3;

1.3
date	2011.11.14.14.29.57;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2010.11.27.19.57.23;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2005.04.01.10.40.48;	author mickey;	state Exp;
branches;
next	;


desc
@@


1.7
log
@remove hppa64 port, which we never got going beyond broken single users.
hppa reverse-stack gives us a valuable test case, but most developers don't
have a 2nd one to proceed further with this.
ok kettenis
@
text
@/*	$OpenBSD: db_machdep.h,v 1.6 2016/04/27 11:10:48 mpi Exp $	*/

/*
 * Copyright (c) 1998-2005 Michael Shalayeff
 * All rights reserved.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER IN
 * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
 * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#ifndef	_MACHINE_DB_MACHDEP_H_
#define	_MACHINE_DB_MACHDEP_H_

#include <uvm/uvm_extern.h>

/* types the generic ddb module needs */
typedef	vaddr_t db_addr_t;
typedef	long db_expr_t;

typedef struct trapframe db_regs_t;
extern db_regs_t	ddb_regs;

#define	PC_REGS(regs)	((db_addr_t)(regs)->tf_iioq[0])
#define	SET_PC_REGS(r,pc) ((r)->tf_iioq[0] = (pc), (r)->tf_iioq[1] = (pc) + 4)

/* Breakpoint related definitions */
#define	BKPT_INST	0x00010000	/* break 0,8 */
#define	BKPT_SIZE	sizeof(int)
#define	BKPT_SET(inst)	BKPT_INST

#define	IS_BREAKPOINT_TRAP(type, code) ((type) == T_IBREAK)
#define	IS_WATCHPOINT_TRAP(type, code) ((type) == T_DBREAK)

#define	FIXUP_PC_AFTER_BREAK(regs) ((regs)->tf_iioq[0] -= sizeof(int))

#define DB_VALID_BREAKPOINT(addr) db_valid_breakpoint(addr)

/* TODO 64bit insns */

static __inline int inst_call(u_int ins) {
	return (ins & 0xfc00e000) == 0xe8000000 ||
	       (ins & 0xfc00e000) == 0xe8004000 ||
	       (ins & 0xfc000000) == 0xe4000000;
}
static __inline int inst_branch(u_int ins) {
	return (ins & 0xf0000000) == 0xe0000000 ||
	       (ins & 0xf0000000) == 0xc0000000 ||
	       (ins & 0xf0000000) == 0xa0000000 ||
	       (ins & 0xf0000000) == 0x80000000;
}
static __inline int inst_return(u_int ins) {
	return (ins & 0xfc00e000) == 0xe800c000 ||
	       (ins & 0xfc000000) == 0xe0000000;
}
static __inline int inst_trap_return(u_int ins)	{
	return (ins & 0xfc001fc0) == 0x00000ca0;
}

#if 0
#define db_clear_single_step(r)	((r)->tf_flags &= ~(PSL_Z))
#define db_set_single_step(r)	((r)->tf_flags |= (PSL_Z))
#else
#define	SOFTWARE_SSTEP		1
#define	SOFTWARE_SSTEP_EMUL	1

static __inline db_addr_t
next_instr_address(db_addr_t addr, int b) {
	return (addr + 4);
}

#define	branch_taken(ins,pc,f,regs)	branch_taken1(ins, pc, regs)
static __inline db_addr_t
branch_taken1(int ins, db_addr_t pc, db_regs_t *regs) {
	return (pc);
}

#endif

int db_valid_breakpoint(db_addr_t);
int db_ktrap(int, int, db_regs_t *);

#endif /* _MACHINE_DB_MACHDEP_H_ */
@


1.6
log
@G/C DDB_REGS.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.h,v 1.5 2016/02/27 13:08:07 mpi Exp $	*/
@


1.5
log
@Rename kdb_trap() into db_ktrap().

The goal is to include it in the list of functions that must not be
instrumented.  All ddb(8) functions should be in this list and have
their names start with 'db_'.

ok visa@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.h,v 1.4 2014/03/16 20:31:46 guenther Exp $	*/
a30 1
#define	DDB_REGS	(&ddb_regs)
@


1.4
log
@DDB supports ELF symbols are all archs, and it's always the same as the
native size, so eliminate the #defines.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.h,v 1.3 2011/11/14 14:29:57 deraadt Exp $	*/
d90 1
a90 1
int kdb_trap(int, int, db_regs_t *);
@


1.3
log
@merge various differences between hppa and hppa64
ok jsing
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.h,v 1.2 2010/11/27 19:57:23 miod Exp $	*/
a23 3

#define	DB_ELF_SYMBOLS
#define	DB_ELFSIZE	64
@


1.2
log
@Remove ddb single-step load and store counters. Most platforms do not
implement them, and they are of questionable usefulness.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.h,v 1.1 2005/04/01 10:40:48 mickey Exp $	*/
d4 1
a4 1
 * Copyright (c) 2005 Michael Shalayeff
@


1.1
log
@small batch early bottling hppa64 port
matured in mighty ukrainian oak for 23 months
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a62 12
}
static __inline int inst_load(u_int ins) {
	return (ins & 0xf0000000) == 0x40000000 ||
	       (ins & 0xf4000200) == 0x24000000 ||
	       (ins & 0xfc000200) == 0x0c000000 ||
	       (ins & 0xfc001fc0) != 0x0c0011c0;
}
static __inline int inst_store(u_int ins) {
	return (ins & 0xf0000000) == 0x60000000 ||	/* st */
	       (ins & 0xf4000200) == 0x24000200 ||	/* fst/cst */
	       (ins & 0xfc000200) == 0x0c000200 ||	/* stby */
	       (ins & 0xfc0003c0) == 0x0c0001c0;	/* ldcw */
@

