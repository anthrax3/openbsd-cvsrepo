head	1.16;
access;
symbols
	OPENBSD_5_9:1.15.0.4
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.15.0.6
	OPENBSD_5_8_BASE:1.15
	OPENBSD_5_7:1.15.0.2
	OPENBSD_5_7_BASE:1.15
	OPENBSD_5_6:1.12.0.4
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.10.0.4
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.9.0.8
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.6
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.4
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.2
	OPENBSD_5_0:1.7.0.2
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.2.0.12
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.2.0.8
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.10
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.6
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.2.0.4
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3:1.2.0.2
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_2:1.1.0.10
	OPENBSD_4_2_BASE:1.1
	OPENBSD_4_1:1.1.0.8
	OPENBSD_4_1_BASE:1.1
	OPENBSD_4_0:1.1.0.6
	OPENBSD_4_0_BASE:1.1
	OPENBSD_3_9:1.1.0.4
	OPENBSD_3_9_BASE:1.1
	OPENBSD_3_8:1.1.0.2
	OPENBSD_3_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.16
date	2016.05.11.21.52.50;	author deraadt;	state dead;
branches;
next	1.15;
commitid	VpgRpYXqYSJy4P7J;

1.15
date	2015.02.15.21.34.33;	author miod;	state Exp;
branches;
next	1.14;
commitid	eahBabNpxnDWKzqJ;

1.14
date	2014.12.17.15.26.21;	author deraadt;	state Exp;
branches;
next	1.13;
commitid	CSUPb3DX3PWNCAdG;

1.13
date	2014.11.16.12.30.57;	author deraadt;	state Exp;
branches;
next	1.12;
commitid	yv0ECmCdICvq576h;

1.12
date	2014.05.08.21.31.56;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2014.04.08.09.34.23;	author mpi;	state Exp;
branches;
next	1.10;

1.10
date	2014.01.30.18.16.41;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2011.09.18.11.55.23;	author kettenis;	state Exp;
branches;
next	1.8;

1.8
date	2011.08.16.07.59.45;	author kettenis;	state Exp;
branches;
next	1.7;

1.7
date	2011.07.07.18.40.12;	author kettenis;	state Exp;
branches;
next	1.6;

1.6
date	2011.05.07.15.27.01;	author oga;	state Exp;
branches;
next	1.5;

1.5
date	2011.04.28.20.43.41;	author ariane;	state Exp;
branches;
next	1.4;

1.4
date	2010.12.26.15.40.59;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2010.12.06.20.57.16;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2007.09.10.18.49.45;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2005.04.01.10.40.48;	author mickey;	state Exp;
branches;
next	;


desc
@@


1.16
log
@remove hppa64 port, which we never got going beyond broken single users.
hppa reverse-stack gives us a valuable test case, but most developers don't
have a 2nd one to proceed further with this.
ok kettenis
@
text
@/*	$OpenBSD: pmap.h,v 1.15 2015/02/15 21:34:33 miod Exp $	*/

/*
 * Copyright (c) 2005 Michael Shalayeff
 * All rights reserved.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER IN
 * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
 * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#ifndef _MACHINE_PMAP_H_
#define _MACHINE_PMAP_H_

#include <uvm/uvm_object.h>

#if !defined(_LOCORE)

#include <sys/lock.h>

struct pv_entry;
struct vm_page_md {
	struct pv_entry	*pvh_list;	/* head of list (locked by pvh_lock) */
	u_int		pvh_attrs;	/* to preserve ref/mod */
};

#define	VM_MDPAGE_INIT(pg) do {				\
	(pg)->mdpage.pvh_list = NULL;			\
	(pg)->mdpage.pvh_attrs = 0;			\
} while (0)
#endif

#ifdef _KERNEL
#include <uvm/uvm_page.h>
#include <machine/pte.h>

struct pmap {
	struct uvm_object pm_obj;	/* object (lck by object lock) */
#define	pm_lock	pm_obj.vmobjlock
	struct vm_page	*pm_ptphint;
	struct pglist	pm_pglist;
	volatile u_int32_t *pm_pdir;	/* page dir (read-only after create) */
	pa_space_t	pm_space;	/* space id (read-only after create) */

	struct pmap_statistics	pm_stats;
};
typedef struct pmap *pmap_t;

struct pv_entry {			/* locked by its list's pvh_lock */
	struct pv_entry	*pv_next;
	struct pmap	*pv_pmap;	/* the pmap */
	vaddr_t		pv_va;		/* the virtual address */
	struct vm_page	*pv_ptp;	/* the vm_page of the PTP */
};

extern struct pmap kernel_pmap_store;

/*
 * pool quickmaps
 */
#define	pmap_map_direct(pg)	((vaddr_t)VM_PAGE_TO_PHYS(pg))
struct vm_page *pmap_unmap_direct(vaddr_t);
#define	__HAVE_PMAP_DIRECT

/*
 * according to the parisc manual aliased va's should be
 * different by high 12 bits only.
 */
#define	PMAP_PREFER(o,h)	pmap_prefer(o, h)
static __inline__ vaddr_t
pmap_prefer(vaddr_t offs, vaddr_t hint)
{
	vaddr_t pmap_prefer_hint = (hint & HPPA_PGAMASK) | (offs & HPPA_PGAOFF);
	if (pmap_prefer_hint < hint)
		pmap_prefer_hint += HPPA_PGALIAS;
	return pmap_prefer_hint;
}

/* pmap prefer alignment */
#define PMAP_PREFER_ALIGN()	(HPPA_PGALIAS)
/* pmap prefer offset within alignment */
#define PMAP_PREFER_OFFSET(of)	((of) & HPPA_PGAOFF)

#define	PMAP_GROWKERNEL
#define	PMAP_STEAL_MEMORY

#define	pmap_sid2pid(s)			(((s) + 1) << 1)
#define pmap_kernel()			(&kernel_pmap_store)
#define	pmap_resident_count(pmap)	((pmap)->pm_stats.resident_count)
#define	pmap_update(pm)			(void)(pm)
#define pmap_copy(dpmap,spmap,da,len,sa)

#define pmap_clear_modify(pg)	pmap_changebit(pg, 0, PTE_DIRTY)
#define pmap_clear_reference(pg) pmap_changebit(pg, PTE_REFTRAP, 0)
#define pmap_is_modified(pg)	pmap_testbit(pg, PTE_DIRTY)
#define pmap_is_referenced(pg)	pmap_testbit(pg, PTE_REFTRAP)

#define pmap_unuse_final(p)		/* nothing */
#define	pmap_remove_holes(vm)		do { /* nothing */ } while (0)

void pmap_bootstrap(vaddr_t);
boolean_t pmap_changebit(struct vm_page *, pt_entry_t, pt_entry_t);
boolean_t pmap_testbit(struct vm_page *, pt_entry_t);
void pmap_write_protect(struct pmap *, vaddr_t, vaddr_t, vm_prot_t);
void pmap_remove(struct pmap *pmap, vaddr_t sva, vaddr_t eva);
void pmap_page_remove(struct vm_page *pg);

static __inline void
pmap_page_protect(struct vm_page *pg, vm_prot_t prot)
{
	if ((prot & PROT_WRITE) == 0) {
		if (prot & (PROT_READ | PROT_EXEC))
			pmap_changebit(pg, 0, PTE_WRITE);
		else
			pmap_page_remove(pg);
	}
}

static __inline void
pmap_protect(struct pmap *pmap, vaddr_t sva, vaddr_t eva, vm_prot_t prot)
{
	if ((prot & PROT_WRITE) == 0) {
		if (prot & (PROT_READ | PROT_EXEC))
			pmap_write_protect(pmap, sva, eva, prot);
		else
			pmap_remove(pmap, sva, eva);
	}
}

#endif /* _KERNEL */

#endif /* _MACHINE_PMAP_H_ */
@


1.15
log
@Change pmap_remove_holes() to take a vmspace instead of a map as its argument.

Use this on vax to correctly pick the end of the stack area now that the
stackgap adjustment code will no longer guarantee it is a fixed location.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.14 2014/12/17 15:26:21 deraadt Exp $	*/
@


1.14
log
@delete simplelocks
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.13 2014/11/16 12:30:57 deraadt Exp $	*/
d107 1
a107 1
#define	pmap_remove_holes(map)		do { /* nothing */ } while (0)
@


1.13
log
@Replace a plethora of historical protection options with just
PROT_NONE, PROT_READ, PROT_WRITE, and PROT_EXEC from mman.h.
PROT_MASK is introduced as the one true way of extracting those bits.
Remove UVM_ADV_* wrapper, using the standard names.
ok doug guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.12 2014/05/08 21:31:56 miod Exp $	*/
a30 1
	struct simplelock pvh_lock;	/* locks every pv on this list */
a35 1
	simple_lock_init(&(pg)->mdpage.pvh_lock);	\
@


1.12
log
@Update #include list after not-so-recent uvm includes cleanups.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.11 2014/04/08 09:34:23 mpi Exp $	*/
d121 2
a122 2
	if ((prot & UVM_PROT_WRITE) == 0) {
		if (prot & (UVM_PROT_RX))
d132 2
a133 2
	if ((prot & UVM_PROT_WRITE) == 0) {
		if (prot & (UVM_PROT_RX))
@


1.11
log
@Less <uvm/uvm.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.10 2014/01/30 18:16:41 miod Exp $	*/
d25 18
d44 1
a140 18

#if !defined(_LOCORE)

#include <sys/lock.h>

struct pv_entry;
struct vm_page_md {
	struct simplelock pvh_lock;	/* locks every pv on this list */
	struct pv_entry	*pvh_list;	/* head of list (locked by pvh_lock) */
	u_int		pvh_attrs;	/* to preserve ref/mod */
};

#define	VM_MDPAGE_INIT(pg) do {				\
	simple_lock_init(&(pg)->mdpage.pvh_lock);	\
	(pg)->mdpage.pvh_list = NULL;			\
	(pg)->mdpage.pvh_attrs = 0;			\
} while (0)
#endif
@


1.10
log
@Move declaration of struct vm_page_md from <machine/vmparam.h> to
<machine/pmap.h> where it belongs, and compensate in <uvm/uvm_extern.h>
by including <uvm/uvm_pmap.h> before <uvm/uvm_page.h>. Tested on all
MACHINE_ARCH but amd64 and i386 (and hppa64).
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.9 2011/09/18 11:55:23 kettenis Exp $	*/
a22 2
#include <machine/pte.h>
#include <uvm/uvm_page.h>
d26 1
@


1.9
log
@Use an uvm object to keep track of the page table pages, just like we do on
hppa to reduce the diffs between the two pmaps.  Also add cache flushing
in places where hppa does them.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.8 2011/08/16 07:59:45 kettenis Exp $	*/
d123 19
@


1.8
log
@Don't export 'struct pmap' to userland.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.7 2011/07/07 18:40:12 kettenis Exp $	*/
d30 2
a31 2
	simple_lock_data_t pm_lock;
	int		pm_refcount;
@


1.7
log
@Bring over a few more cache flushing and TLB purging fixes from hppa.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.6 2011/05/07 15:27:01 oga Exp $	*/
d27 2
a46 2

#ifdef	_KERNEL
@


1.6
log
@So long, uvm_pglist.h

This header defined three thing. two of which are unused throughout the tree,
the final one was the definition of the pagq head type, move that to uvm_page.h
and nuke the header

ok thib@@. Thanks to krw@@ for testing the hppa build for me.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.5 2011/04/28 20:43:41 ariane Exp $	*/
d54 1
a54 1
#define	pmap_unmap_direct(va) PHYS_TO_VM_PAGE((paddr_t)(va))
a89 1
#define pmap_proc_iflush(p,va,len)	/* nothing */
@


1.5
log
@Expose pmap_prefer parameters.
This will enable future uvm_map to make intelligent allocation decisions.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.4 2010/12/26 15:40:59 miod Exp $	*/
d24 1
a24 1
#include <uvm/uvm_pglist.h>
@


1.4
log
@Kill pmap_phys_address(), and force every driver's mmap() routine to return
a physical address [more precisely, something suitable to pass to pmap_enter()'sphysical address argument].

This allows MI drivers to implement mmap() routines without having to know
about the pmap_phys_address() implementation and #ifdef obfuscation.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.3 2010/12/06 20:57:16 miod Exp $	*/
d70 5
@


1.3
log
@Change the signature of PMAP_PREFER from void PMAP_PREFER(..., vaddr_t *) to
vaddr_t PMAP_PREFER(..., vaddr_t). This allows better compiler optimization
when the function is inlined, and avoids accessing memory on architectures
when we can pass function arguments in registers.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.2 2007/09/10 18:49:45 miod Exp $	*/
a83 1
#define pmap_phys_address(ppn)	((ppn) << PAGE_SHIFT)
@


1.2
log
@Introduce a md pmap hook, pmap_remove_holes(), which is supposed to mark
the holes a MMU may have from a given vm_map. This will be automagically
invoked for newly created vmspaces.

On platforms with MMU holes (e.g. sun4, sun4c and vax), this prevents
mmap(2) hints which would end up being in the hole to be accepted as valid,
causing unexpected signals when the process tries to access the hole
(since pmap can not fill the hole anyway).

Unfortunately, the logic mmap() uses to pick a valid address for anonymous
mappings needs work, as it will only try to find an address higher than the
hint, which causes all mmap() with a hint in the hole to fail on vax. This
will be improved later.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.1 2005/04/01 10:40:48 mickey Exp $	*/
d61 9
a69 7
#define	PMAP_PREFER(o,h)	do {					\
	vaddr_t pmap_prefer_hint;					\
	pmap_prefer_hint = (*(h) & HPPA_PGAMASK) | ((o) & HPPA_PGAOFF);	\
	if (pmap_prefer_hint < *(h))					\
		pmap_prefer_hint += HPPA_PGALIAS;			\
	*(h) = pmap_prefer_hint;					\
} while(0)
@


1.1
log
@small batch early bottling hppa64 port
matured in mighty ukrainian oak for 23 months
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d86 1
@

