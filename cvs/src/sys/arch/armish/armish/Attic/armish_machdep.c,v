head	1.41;
access;
symbols
	OPENBSD_6_0:1.39.0.6
	OPENBSD_6_0_BASE:1.39
	OPENBSD_5_9:1.39.0.2
	OPENBSD_5_9_BASE:1.39
	OPENBSD_5_8:1.39.0.4
	OPENBSD_5_8_BASE:1.39
	OPENBSD_5_7:1.36.0.2
	OPENBSD_5_7_BASE:1.36
	OPENBSD_5_6:1.31.0.4
	OPENBSD_5_6_BASE:1.31
	OPENBSD_5_5:1.21.0.4
	OPENBSD_5_5_BASE:1.21
	OPENBSD_5_4:1.18.0.8
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.18.0.6
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.18.0.4
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.2
	OPENBSD_5_0:1.17.0.2
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.16.0.4
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.16.0.2
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.13.0.4
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.13.0.6
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.2
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.12.0.2
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.10.0.4
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.2
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.9.0.4
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.2
	OPENBSD_4_0_BASE:1.9;
locks; strict;
comment	@ * @;


1.41
date	2016.08.10.14.27.16;	author deraadt;	state dead;
branches;
next	1.40;
commitid	nJ2GKPOeS3xtih2N;

1.40
date	2016.08.08.19.27.12;	author kettenis;	state Exp;
branches;
next	1.39;
commitid	9cxQ5QuyMM8g8ZRp;

1.39
date	2015.05.10.15.56.28;	author jsg;	state Exp;
branches;
next	1.38;
commitid	MKYLBBkRhYmhiqiC;

1.38
date	2015.05.08.22.56.53;	author miod;	state Exp;
branches;
next	1.37;
commitid	fFmwBnB0cqyL2Ewy;

1.37
date	2015.05.05.02.13.46;	author guenther;	state Exp;
branches;
next	1.36;
commitid	dNPv28CJI5BxtRGW;

1.36
date	2015.01.18.10.17.42;	author jsg;	state Exp;
branches;
next	1.35;
commitid	EinLpFIBT92msrml;

1.35
date	2014.12.10.15.29.53;	author mikeb;	state Exp;
branches;
next	1.34;
commitid	qHQiR2HLROzvZr7B;

1.34
date	2014.12.03.20.09.32;	author krw;	state Exp;
branches;
next	1.33;
commitid	rapVfhq63upxHrrZ;

1.33
date	2014.11.16.12.30.56;	author deraadt;	state Exp;
branches;
next	1.32;
commitid	yv0ECmCdICvq576h;

1.32
date	2014.09.20.09.28.24;	author kettenis;	state Exp;
branches;
next	1.31;
commitid	IFRB8AkvBMXMTAKW;

1.31
date	2014.07.21.17.25.47;	author uebayasi;	state Exp;
branches;
next	1.30;
commitid	7QO4UJr3EKVAMc8t;

1.30
date	2014.07.13.22.53.38;	author uebayasi;	state Exp;
branches;
next	1.29;
commitid	wsdp3qtXGjMj98oD;

1.29
date	2014.07.13.22.13.06;	author uebayasi;	state Exp;
branches;
next	1.28;
commitid	qYPOd6Qi4aRBKldK;

1.28
date	2014.07.10.21.46.02;	author mpi;	state Exp;
branches;
next	1.27;
commitid	iYq3Z1ZWDKR3sS9G;

1.27
date	2014.07.10.20.15.26;	author uebayasi;	state Exp;
branches;
next	1.26;
commitid	YzvTa4t6mddz7Mh4;

1.26
date	2014.07.10.12.13.48;	author uebayasi;	state Exp;
branches;
next	1.25;
commitid	aofvn6ceiucgjg4N;

1.25
date	2014.05.31.15.49.28;	author mpi;	state Exp;
branches;
next	1.24;
commitid	eA4Y0YE1IUzj6hpW;

1.24
date	2014.05.30.13.46.16;	author mpi;	state Exp;
branches;
next	1.23;

1.23
date	2014.03.23.18.20.59;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2014.03.13.03.52.55;	author dlg;	state Exp;
branches;
next	1.21;

1.21
date	2013.11.13.18.30.48;	author jasper;	state Exp;
branches;
next	1.20;

1.20
date	2013.11.13.07.03.11;	author uebayasi;	state Exp;
branches;
next	1.19;

1.19
date	2013.09.28.14.16.41;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2011.10.19.20.18.31;	author drahn;	state Exp;
branches;
next	1.17;

1.17
date	2011.05.30.22.25.20;	author oga;	state Exp;
branches;
next	1.16;

1.16
date	2010.06.27.08.05.59;	author drahn;	state Exp;
branches;
next	1.15;

1.15
date	2010.06.27.03.03.48;	author thib;	state Exp;
branches;
next	1.14;

1.14
date	2010.06.10.17.54.13;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2008.11.26.01.29.00;	author kevlo;	state Exp;
branches;
next	1.12;

1.12
date	2008.06.08.20.56.31;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2008.03.23.17.05.41;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2007.05.19.15.49.05;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2006.08.01.22.22.20;	author kettenis;	state Exp;
branches;
next	1.8;

1.8
date	2006.08.01.15.44.24;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2006.07.30.21.38.12;	author drahn;	state Exp;
branches;
next	1.6;

1.6
date	2006.07.20.02.48.03;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2006.07.11.05.58.14;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2006.06.15.21.35.30;	author drahn;	state Exp;
branches;
next	1.3;

1.3
date	2006.06.15.21.28.59;	author drahn;	state Exp;
branches;
next	1.2;

1.2
date	2006.05.31.05.54.09;	author drahn;	state Exp;
branches;
next	1.1;

1.1
date	2006.05.29.17.13.19;	author drahn;	state Exp;
branches;
next	;


desc
@@


1.41
log
@armish handled some early-gen arm machines, which required tons of
workarounds.  Some of them will soon stand in the way of armv7.
Off to the attic you go.
@
text
@/*	$OpenBSD: armish_machdep.c,v 1.40 2016/08/08 19:27:12 kettenis Exp $ */
/*	$NetBSD: lubbock_machdep.c,v 1.2 2003/07/15 00:25:06 lukem Exp $ */

/*
 * Copyright (c) 2001, 2002, 2003 Wasabi Systems, Inc.
 * All rights reserved.
 *
 * Written by Jason R. Thorpe for Wasabi Systems, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed for the NetBSD Project by
 *	Wasabi Systems, Inc.
 * 4. The name of Wasabi Systems, Inc. may not be used to endorse
 *    or promote products derived from this software without specific prior
 *    written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY WASABI SYSTEMS, INC. ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL WASABI SYSTEMS, INC
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 1997,1998 Mark Brinicombe.
 * Copyright (c) 1997,1998 Causality Limited.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Mark Brinicombe
 *	for the NetBSD Project.
 * 4. The name of the company nor the name of the author may be used to
 *    endorse or promote products derived from this software without specific
 *    prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * Machine dependant functions for kernel setup for Intel IQ80321 evaluation
 * boards using RedBoot firmware.
 */

/*
 * DIP switches:
 *
 * S19: no-dot: set RB_KDB.  enter kgdb session.
 * S20: no-dot: set RB_SINGLE. don't go multi user mode.
 */

#include <sys/param.h>
#include <sys/device.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/exec.h>
#include <sys/proc.h>
#include <sys/msgbuf.h>
#include <sys/reboot.h>
#include <sys/termios.h>
#include <sys/kcore.h>

#include <uvm/uvm_extern.h>

#include <sys/conf.h>
#include <sys/queue.h>
#include <dev/cons.h>
#include <sys/socket.h>

#include <machine/db_machdep.h>
#include <ddb/db_sym.h>
#include <ddb/db_extern.h>

#include <net/if.h>

#include <machine/bootconfig.h>
#include <machine/bus.h>
#include <machine/cpu.h>
#include <machine/frame.h>
#include <arm/kcore.h>
#include <arm/undefined.h>
#include <arm/machdep.h>

#include <arm/xscale/i80321reg.h>
#include <arm/xscale/i80321var.h>

#include <armish/dev/iq80321reg.h>
#include <armish/dev/iq80321var.h>
#include <armish/dev/obiovar.h>

/* Kernel text starts 2MB in from the bottom of the kernel address space. */
#define	KERNEL_TEXT_BASE	(KERNEL_BASE + 0x00200000)
#define	KERNEL_VM_BASE		(KERNEL_BASE + 0x10000000)
#define KERNEL_VM_SIZE		VM_KERNEL_SPACE_SIZE

/*
 * Address to call from cpu_reset() to reset the machine.
 * This is machine architecture dependant as it varies depending
 * on where the ROM appears when you turn the MMU off.
 */

u_int cpu_reset_address = 0;

/* Define various stack sizes in pages */
#define IRQ_STACK_SIZE	1
#define ABT_STACK_SIZE	1
#define UND_STACK_SIZE	1

BootConfig bootconfig;		/* Boot config storage */
char *boot_args = NULL;
char *boot_file = NULL;

paddr_t physical_start;
paddr_t physical_freestart;
paddr_t physical_freeend;
paddr_t physical_end;
u_int free_pages;
paddr_t pagetables_start;
int physmem = 0;

/*int debug_flags;*/
#ifndef PMAP_STATIC_L1S
int max_processes = 64;			/* Default number */
#endif	/* !PMAP_STATIC_L1S */

/* Physical and virtual addresses for some global pages */
pv_addr_t systempage;
pv_addr_t irqstack;
pv_addr_t undstack;
pv_addr_t abtstack;
extern pv_addr_t kernelstack;
pv_addr_t minidataclean;

paddr_t msgbufphys;

extern u_int data_abort_handler_address;
extern u_int prefetch_abort_handler_address;
extern u_int undefined_handler_address;

#ifdef PMAP_DEBUG
extern int pmap_debug_level;
#endif

#define KERNEL_PT_SYS		0	/* L2 table for mapping zero page */

#define KERNEL_PT_KERNEL	1	/* L2 table for mapping kernel */
#define	KERNEL_PT_KERNEL_NUM	32

					/* L2 table for mapping i80312 */
//#define	KERNEL_PT_IOPXS		(KERNEL_PT_KERNEL + KERNEL_PT_KERNEL_NUM)

					/* L2 tables for mapping kernel VM */ 
//#define KERNEL_PT_VMDATA	(KERNEL_PT_IOPXS + 1)
#define KERNEL_PT_VMDATA	(KERNEL_PT_KERNEL + KERNEL_PT_KERNEL_NUM)
#define	KERNEL_PT_VMDATA_NUM	8	/* start with 16MB of KVM */
#define NUM_KERNEL_PTS		(KERNEL_PT_VMDATA + KERNEL_PT_VMDATA_NUM)

pv_addr_t kernel_pt_table[NUM_KERNEL_PTS];

extern struct user *proc0paddr;

/*
 * safepri is a safe priority for sleep to set for a spin-wait
 * during autoconfiguration or after a panic.
 */
int   safepri = 0;

/* Prototypes */

#define	BOOT_STRING_MAGIC 0x4f425344

char	bootargs[MAX_BOOT_STRING];
void	process_kernel_args(char *);

void	consinit(void);

#include "com.h"
#if NCOM > 0
#include <dev/ic/comreg.h>
#include <dev/ic/comvar.h>
#endif

#ifndef CONSPEED
#define CONSPEED B115200	/* What RedBoot uses */
#endif
#ifndef CONMODE
#define CONMODE ((TTYDEF_CFLAG & ~(CSIZE | CSTOPB | PARENB)) | CS8 | CLOCAL) /* 8N1 */
#endif

int comcnspeed = CONSPEED;
int comcnmode = CONMODE;


/*
 * void boot(int howto)
 *
 * Reboots the system
 *
 * Deal with any syncing, unmounting, dumping and shutdown hooks,
 * then reset the CPU.
 */
void	board_reset(void);
void	board_powerdown(void);
__dead void
boot(int howto)
{
	if (cold) {
		if ((howto & RB_USERREQ) == 0)
			howto |=  RB_HALT;
		goto haltsys;
	}

	/*
	 * If RB_NOSYNC was not specified sync the discs.
	 * Note: Unless cold is set to 1 here, syslogd will die during the
	 * unmount.  It looks like syslogd is getting woken up only to find
	 * that it cannot page part of the binary in as the filesystem has
	 * been unmounted.
	 */
	if ((howto & RB_NOSYNC) == 0)
		bootsync(howto);

	if_downall();

	uvm_shutdown();
	splhigh();
	cold = 1;

	if ((howto & (RB_DUMP | RB_HALT)) == RB_DUMP)
		dumpsys();

haltsys:
	config_suspend_all(DVACT_POWERDOWN);

	/* Make sure IRQ's are disabled */
	IRQdisable;

	if ((howto & RB_HALT) != 0) {
		if ((howto & RB_POWERDOWN) != 0) {
			board_powerdown();
			printf("WARNING: powerdown failed!\n");
		}

		printf("The operating system has halted.\n");
		printf("Please press any key to reboot.\n\n");
		cnpollc(1);
		cngetc();
		cnpollc(0);
	}

	printf("rebooting...\n");

	board_reset();
	cpu_reset();
	printf("reboot failed; spinning\n");
	for (;;) ;
	/* NOTREACHED */
}

/*
 * Mapping table for core kernel memory. These areas are mapped in
 * init time at fixed virtual address with section mappings. 
 */
const struct pmap_devmap iq80321_devmap[] = {
    /*
     * Map the on-board devices VA == PA so that we can access them
     * with the MMU on or off.
     */
    {
	IQ80321_OBIO_BASE,
	IQ80321_OBIO_BASE,
	0x00100000 /*	IQ80321_OBIO_SIZE, */,
	PROT_READ | PROT_WRITE,
	PTE_NOCACHE,
    },
    {0, 0, 0, 0, 0}
};


/*
 * u_int initarm(...)
 *
 * Initial entry point on startup. This gets called before main() is
 * entered.
 * It should be responsible for setting up everything that must be
 * in place when main is called.
 * This includes
 *   Taking a copy of the boot configuration structure.
 *   Initialising the physical console so characters can be printed.
 *   Setting up page tables for the kernel
 *   Relocating the kernel to the bottom of physical memory
 */
u_int
initarm(void *arg0, void *arg1, void *arg2)
{
	extern vaddr_t xscale_cache_clean_addr;
	extern cpu_kcore_hdr_t cpu_kcore_hdr;
	int loop;
	int loop1;
	u_int l1pagetable;
	pv_addr_t kernel_l1pt;
	paddr_t memstart;
	psize_t memsize;
	extern u_int32_t esym;	/* &_end if no symbols are loaded */

#ifdef DIAGNOSTIC
	extern vsize_t xscale_minidata_clean_size; /* used in KASSERT */
#endif

	/* setup a serial console for very early boot */
	consinit();

	/*
	 * Heads up ... Setup the CPU / MMU / TLB functions
	 */
	if (set_cpufuncs())
		panic("cpu not recognized!");

	/*
	 * Examine the boot args string for options we need to know about
	 * now.
	 */
	/* XXX should really be done after setting up the console, but we
	 * XXX need to parse the console selection flags right now. */
	process_kernel_args((char *)0xa0200000 - MAX_BOOT_STRING - 1);

	/* Calibrate the delay loop. */
#if 1
	i80321_calibrate_delay();
#endif

	/* Talk to the user */
	printf("\nOpenBSD/armish booting ...\n");

	/*
	 * Reset the secondary PCI bus.  RedBoot doesn't stop devices
	 * on the PCI bus before handing us control, so we have to
	 * do this.
	 *
	 * XXX This is arguably a bug in RedBoot, and doing this reset
	 * XXX could be problematic in the future if we encounter an
	 * XXX application where the PPB in the i80312 is used as a
	 * XXX PPB.
	 */
//#define VERBOSE_INIT_ARM

	/*
	 * Fetch the SDRAM start/size from the i80312 SDRAM configuration
	 * registers.
	 */
	i80321_sdram_bounds(&obio_bs_tag, VERDE_PMMR_BASE + VERDE_MCU_BASE,
	    &memstart, &memsize);

#define DEBUG
#ifdef DEBUG
	printf("initarm: Configuring system ...\n");
#endif

	/* Fake bootconfig structure for the benefit of pmap.c */
	/* XXX must make the memory description h/w independant */
	bootconfig.dramblocks = 1;
	bootconfig.dram[0].address = memstart;
	bootconfig.dram[0].pages = memsize / PAGE_SIZE;

	/*
	 * Set up the variables that define the availablilty of
	 * physical memory.  For now, we're going to set
	 * physical_freestart to 0xa0200000 (where the kernel
	 * was loaded), and allocate the memory we need downwards.
	 * If we get too close to the page tables that RedBoot
	 * set up, we will panic.  We will update physical_freestart
	 * and physical_freeend later to reflect what pmap_bootstrap()
	 * wants to see.
	 *
	 * XXX pmap_bootstrap() needs an enema.
	 */
	physical_start = bootconfig.dram[0].address;
	physical_end = physical_start + (bootconfig.dram[0].pages * PAGE_SIZE);

	physical_freestart = 0xa0009000UL;
	physical_freeend = 0xa0200000UL;

	physmem = (physical_end - physical_start) / PAGE_SIZE;

#ifdef DEBUG
	/* Tell the user about the memory */
	printf("physmemory: %d pages at 0x%08lx -> 0x%08lx\n", physmem,
	    physical_start, physical_end - 1);
#endif

	/*
	 * Okay, the kernel starts 2MB in from the bottom of physical
	 * memory.  We are going to allocate our bootstrap pages downwards
	 * from there.
	 *
	 * We need to allocate some fixed page tables to get the kernel
	 * going.  We allocate one page directory and a number of page
	 * tables and store the physical addresses in the kernel_pt_table
	 * array.
	 *
	 * The kernel page directory must be on a 16K boundary.  The page
	 * tables must be on 4K boundaries.  What we do is allocate the
	 * page directory on the first 16K boundary that we encounter, and
	 * the page tables on 4K boundaries otherwise.  Since we allocate
	 * at least 3 L2 page tables, we are guaranteed to encounter at
	 * least one 16K aligned region.
	 */

#ifdef VERBOSE_INIT_ARM
	printf("Allocating page tables\n");
#endif

	free_pages = (physical_freeend - physical_freestart) / PAGE_SIZE;

#ifdef VERBOSE_INIT_ARM
	printf("freestart = 0x%08lx, free_pages = %d (0x%08x)\n",
	       physical_freestart, free_pages, free_pages);
#endif

	/* Define a macro to simplify memory allocation */
#define	valloc_pages(var, np)				\
	alloc_pages((var).pv_pa, (np));			\
	(var).pv_va = KERNEL_BASE + (var).pv_pa - physical_start;

#define alloc_pages(var, np)				\
	physical_freeend -= ((np) * PAGE_SIZE);		\
	if (physical_freeend < physical_freestart)	\
		panic("initarm: out of memory");	\
	(var) = physical_freeend;			\
	free_pages -= (np);				\
	memset((char *)(var), 0, ((np) * PAGE_SIZE));

	loop1 = 0;
	kernel_l1pt.pv_pa = 0;
	for (loop = 0; loop <= NUM_KERNEL_PTS; ++loop) {
		/* Are we 16KB aligned for an L1 ? */
		if (((physical_freeend - L1_TABLE_SIZE) & (L1_TABLE_SIZE - 1)) == 0
		    && kernel_l1pt.pv_pa == 0) {
			valloc_pages(kernel_l1pt, L1_TABLE_SIZE / PAGE_SIZE);
		} else {
			valloc_pages(kernel_pt_table[loop1],
			    L2_TABLE_SIZE / PAGE_SIZE);
			++loop1;
		}
	}

	/* This should never be able to happen but better confirm that. */
	if (!kernel_l1pt.pv_pa || (kernel_l1pt.pv_pa & (L1_TABLE_SIZE-1)) != 0)
		panic("initarm: Failed to align the kernel page directory");

	/*
	 * Allocate a page for the system page mapped to V0x00000000
	 * This page will just contain the system vectors and can be
	 * shared by all processes.
	 */
	alloc_pages(systempage.pv_pa, 1);

	/* Allocate stacks for all modes */
	valloc_pages(irqstack, IRQ_STACK_SIZE);
	valloc_pages(abtstack, ABT_STACK_SIZE);
	valloc_pages(undstack, UND_STACK_SIZE);
	valloc_pages(kernelstack, UPAGES);

	/* Allocate enough pages for cleaning the Mini-Data cache. */
	KASSERT(xscale_minidata_clean_size <= PAGE_SIZE);
	valloc_pages(minidataclean, 1);

#ifdef VERBOSE_INIT_ARM
	printf("IRQ stack: p0x%08lx v0x%08lx\n", irqstack.pv_pa,
	    irqstack.pv_va); 
	printf("ABT stack: p0x%08lx v0x%08lx\n", abtstack.pv_pa,
	    abtstack.pv_va); 
	printf("UND stack: p0x%08lx v0x%08lx\n", undstack.pv_pa,
	    undstack.pv_va); 
	printf("SVC stack: p0x%08lx v0x%08lx\n", kernelstack.pv_pa,
	    kernelstack.pv_va); 
#endif

	/*
	 * XXX Defer this to later so that we can reclaim the memory
	 * XXX used by the RedBoot page tables.
	 */
	alloc_pages(msgbufphys, round_page(MSGBUFSIZE) / PAGE_SIZE);

	/*
	 * Ok we have allocated physical pages for the primary kernel
	 * page tables
	 */

#ifdef VERBOSE_INIT_ARM
	printf("Creating L1 page table at 0x%08lx\n", kernel_l1pt.pv_pa);
#endif

	/*
	 * Now we start construction of the L1 page table
	 * We start by mapping the L2 page tables into the L1.
	 * This means that we can replace L1 mappings later on if necessary
	 */
	l1pagetable = kernel_l1pt.pv_pa;

#ifdef HIGH_VECT
	/* Map the L2 pages tables in the L1 page table */
	pmap_link_l2pt(l1pagetable, ARM_VECTORS_HIGH & ~(0x00400000 - 1),
	    &kernel_pt_table[KERNEL_PT_SYS]);
#else
	/* Map the L2 pages tables in the L1 page table */
	pmap_link_l2pt(l1pagetable, 0x00000000,
	    &kernel_pt_table[KERNEL_PT_SYS]);
#endif
	for (loop = 0; loop < KERNEL_PT_KERNEL_NUM; loop++)
		pmap_link_l2pt(l1pagetable, KERNEL_BASE + loop * 0x00400000,
		    &kernel_pt_table[KERNEL_PT_KERNEL + loop]);
	for (loop = 0; loop < KERNEL_PT_VMDATA_NUM; loop++)
		pmap_link_l2pt(l1pagetable, KERNEL_VM_BASE + loop * 0x00400000,
		    &kernel_pt_table[KERNEL_PT_VMDATA + loop]);
#if 0
	pmap_link_l2pt(l1pagetable, IQ80321_IOPXS_VBASE,
	    &kernel_pt_table[KERNEL_PT_IOPXS]);
#endif

	/* update the top of the kernel VM */
	pmap_curmaxkvaddr =
	    KERNEL_VM_BASE + (KERNEL_PT_VMDATA_NUM * 0x00400000);

#ifdef VERBOSE_INIT_ARM
	printf("Mapping kernel\n");
#endif

	/* Now we fill in the L2 pagetable for the kernel static code/data
	 * and the symbol table. */
	{
		extern char etext[];
#ifdef VERBOSE_INIT_ARM
		extern char _end[];
#endif
		size_t textsize = (u_int32_t) etext - KERNEL_TEXT_BASE;
		size_t totalsize = esym - KERNEL_TEXT_BASE;
		u_int logical;

#ifdef VERBOSE_INIT_ARM
		printf("kernelsize text %x total %x end %xesym %x\n",
		    textsize, totalsize, _end, esym);
#endif

		textsize = round_page(textsize);
		totalsize = round_page(totalsize);
		
		logical = 0x00200000;	/* offset of kernel in RAM */

		/* Update dump information */
		cpu_kcore_hdr.kernelbase = KERNEL_BASE;
		cpu_kcore_hdr.kerneloffs = logical;
		cpu_kcore_hdr.staticsize = totalsize;

		logical += pmap_map_chunk(l1pagetable, KERNEL_BASE + logical,
		    physical_start + logical, textsize,
		    PROT_READ | PROT_WRITE, PTE_CACHE);
		pmap_map_chunk(l1pagetable, KERNEL_BASE + logical,
		    physical_start + logical, totalsize - textsize,
		    PROT_READ | PROT_WRITE, PTE_CACHE);
	}

#ifdef VERBOSE_INIT_ARM
	printf("Constructing L2 page tables\n");
#endif

	/* Map the stack pages */
	pmap_map_chunk(l1pagetable, irqstack.pv_va, irqstack.pv_pa,
	    IRQ_STACK_SIZE * PAGE_SIZE, PROT_READ | PROT_WRITE, PTE_CACHE);
	pmap_map_chunk(l1pagetable, abtstack.pv_va, abtstack.pv_pa,
	    ABT_STACK_SIZE * PAGE_SIZE, PROT_READ | PROT_WRITE, PTE_CACHE);
	pmap_map_chunk(l1pagetable, undstack.pv_va, undstack.pv_pa,
	    UND_STACK_SIZE * PAGE_SIZE, PROT_READ | PROT_WRITE, PTE_CACHE);
	pmap_map_chunk(l1pagetable, kernelstack.pv_va, kernelstack.pv_pa,
	    UPAGES * PAGE_SIZE, PROT_READ | PROT_WRITE, PTE_CACHE);

	pmap_map_chunk(l1pagetable, kernel_l1pt.pv_va, kernel_l1pt.pv_pa,
	    L1_TABLE_SIZE, PROT_READ | PROT_WRITE, PTE_PAGETABLE);

	for (loop = 0; loop < NUM_KERNEL_PTS; ++loop) {
		pmap_map_chunk(l1pagetable, kernel_pt_table[loop].pv_va,
		    kernel_pt_table[loop].pv_pa, L2_TABLE_SIZE,
		    PROT_READ | PROT_WRITE, PTE_PAGETABLE);
	}

	/* Map the Mini-Data cache clean area. */
	xscale_setup_minidata(l1pagetable, minidataclean.pv_va,
	    minidataclean.pv_pa);

	/* Map the vector page. */
#ifdef HIGH_VECT
	pmap_map_entry(l1pagetable, ARM_VECTORS_HIGH, systempage.pv_pa,
	    PROT_READ | PROT_WRITE, PTE_CACHE);
#else
        pmap_map_entry(l1pagetable, vector_page, systempage.pv_pa,
	    PROT_READ | PROT_WRITE, PTE_CACHE);
#endif

	pmap_devmap_bootstrap(l1pagetable, iq80321_devmap);

	/*
	 * Give the XScale global cache clean code an appropriately
	 * sized chunk of unmapped VA space starting at 0xff000000
	 * (our device mappings end before this address).
	 */
	xscale_cache_clean_addr = 0xff000000U;

	/*
	 * Now we have the real page tables in place so we can switch to them.
	 * Once this is done we will be running with the REAL kernel page
	 * tables.
	 */

	/*
	 * Update the physical_freestart/physical_freeend/free_pages
	 * variables.
	 */
	{
		physical_freestart = physical_start - KERNEL_BASE +
		    round_page(esym);
		physical_freeend = physical_end;
		free_pages =
		    (physical_freeend - physical_freestart) / PAGE_SIZE;
	}
#ifdef VERBOSE_INIT_ARM
	printf("physical_freestart %x end %x\n", physical_freestart,
	    physical_freeend);
#endif

	/* be a client to all domains */
	cpu_domains(0x55555555);
	/* Switch tables */
#ifdef VERBOSE_INIT_ARM
	printf("freestart = 0x%08lx, free_pages = %d (0x%x)\n",
	       physical_freestart, free_pages, free_pages);
	printf("switching to new L1 page table  @@%#lx...", kernel_l1pt.pv_pa);
#endif


	cpu_domains((DOMAIN_CLIENT << (PMAP_DOMAIN_KERNEL*2)) | DOMAIN_CLIENT);
	setttb(kernel_l1pt.pv_pa);
	cpu_tlb_flushID();
	cpu_domains(DOMAIN_CLIENT << (PMAP_DOMAIN_KERNEL*2));

	/*
	 * Moved from cpu_startup() as data_abort_handler() references
	 * this during uvm init
	 */
	proc0paddr = (struct user *)kernelstack.pv_va;
	proc0.p_addr = proc0paddr;

#ifdef VERBOSE_INIT_ARM
	printf("bootstrap done.\n");
#endif

#ifdef HIGH_VECT
	arm32_vector_init(ARM_VECTORS_HIGH, ARM_VEC_ALL);
#else
	arm32_vector_init(ARM_VECTORS_LOW, ARM_VEC_ALL);
#endif

	/*
	 * Pages were allocated during the secondary bootstrap for the
	 * stacks for different CPU modes.
	 * We must now set the r13 registers in the different CPU modes to
	 * point to these stacks.
	 * Since the ARM stacks use STMFD etc. we must set r13 to the top end
	 * of the stack memory.
	 */
#ifdef VERBOSE_INIT_ARM
	printf("init subsystems: stacks ");
#endif

	set_stackptr(PSR_IRQ32_MODE,
	    irqstack.pv_va + IRQ_STACK_SIZE * PAGE_SIZE);
	set_stackptr(PSR_ABT32_MODE,
	    abtstack.pv_va + ABT_STACK_SIZE * PAGE_SIZE);
	set_stackptr(PSR_UND32_MODE,
	    undstack.pv_va + UND_STACK_SIZE * PAGE_SIZE);

	/*
	 * Well we should set a data abort handler.
	 * Once things get going this will change as we will need a proper
	 * handler.
	 * Until then we will use a handler that just panics but tells us
	 * why.
	 * Initialisation of the vectors will just panic on a data abort.
	 * This just fills in a slightly better one.
	 */
#ifdef VERBOSE_INIT_ARM
	printf("vectors ");
#endif
	data_abort_handler_address = (u_int)data_abort_handler;
	prefetch_abort_handler_address = (u_int)prefetch_abort_handler;
	undefined_handler_address = (u_int)undefinedinstruction_bounce;

	/* Initialise the undefined instruction handlers */
#ifdef VERBOSE_INIT_ARM
	printf("undefined ");
#endif
	undefined_init();

	/* Load memory into UVM. */
#ifdef VERBOSE_INIT_ARM
	printf("page ");
#endif
	uvm_setpagesize();	/* initialize PAGE_SIZE-dependent variables */
	uvm_page_physload(atop(physical_freestart), atop(physical_freeend),
	    atop(physical_freestart), atop(physical_freeend), 0);

	/* Boot strap pmap telling it where the kernel page table is */
#ifdef VERBOSE_INIT_ARM
	printf("pmap ");
#endif
	pmap_bootstrap((pd_entry_t *)kernel_l1pt.pv_va, KERNEL_VM_BASE,
	    KERNEL_VM_BASE + KERNEL_VM_SIZE);

	/* Update dump information */
	cpu_kcore_hdr.pmap_kernel_l1 = (u_int32_t)pmap_kernel()->pm_l1;
	cpu_kcore_hdr.pmap_kernel_l2 = (u_int32_t)&(pmap_kernel()->pm_l2);

	/* Setup the IRQ system */
#ifdef VERBOSE_INIT_ARM
	printf("irq ");
#endif
	i80321intc_intr_init();

#ifdef VERBOSE_INIT_ARM
	printf("done.\n");
#endif

#ifdef DDB
	db_machine_init();

	/* Firmware doesn't load symbols. */
	ddb_init();

	if (boothowto & RB_KDB)
		Debugger();
#endif
    
	cpu_setup();

	/* We return the new stack pointer address */
	return(kernelstack.pv_va + USPACE_SVC_STACK_TOP);
}

void
process_kernel_args(char *args)
{
	char *cp = args;

	if (cp == NULL || *(int *)cp != BOOT_STRING_MAGIC) {
		boothowto = RB_AUTOBOOT;
		return;
	}

	/* Eat the cookie */
	*(int *)cp = 0;
	cp += sizeof(int);

	boothowto = 0;

	/* Make a local copy of the bootargs */
	strncpy(bootargs, cp, MAX_BOOT_STRING - sizeof(int));

	cp = bootargs;
	boot_file = bootargs;

	/* Skip the kernel image filename */
	while (*cp != ' ' && *cp != 0)
		++cp;

	if (*cp != 0)
		*cp++ = 0;

	while (*cp == ' ')
		++cp;

	boot_args = cp;

#if 0
	printf("bootfile: %s\n", boot_file);
	printf("bootargs: %s\n", boot_args);
#endif

	/* Setup pointer to boot flags */
	while (*cp != '-')
		if (*cp++ == '\0')
			return;

	for (;*++cp;) {
		int fl;

		fl = 0;
		switch(*cp) {
		case 'a':
			fl |= RB_ASKNAME;
			break;
		case 'c':
			fl |= RB_CONFIG;
			break;
		case 'd':
			fl |= RB_KDB;
			break;
		case 's':
			fl |= RB_SINGLE;
			break;
		default:
			printf("unknown option `%c'\n", *cp);
			break;
		}
		boothowto |= fl;
	}
}


void
consinit(void)
{
	static const bus_addr_t comcnaddrs[] = {
		IQ80321_UART1          /* com0 */
	};
	static int consinit_called;

	if (consinit_called != 0)
		return;

	consinit_called = 1;

	/*
	 * Console devices are mapped VA==PA.  Our devmap reflects
	 * this, so register it now so drivers can map the console
	 * device.
	 */
	pmap_devmap_register(iq80321_devmap);

#if NCOM > 0
	if (comcnattach(&obio_bs_tag, comcnaddrs[0], comcnspeed,
	    COM_FREQ, comcnmode))
		panic("can't init serial console @@%lx", comcnaddrs[0]);
	comdefaultrate = comcnspeed;
#else
	panic("serial console @@%lx not configured", comcnaddrs[0]);
#endif
}

void
board_startup(void)
{
        if (boothowto & RB_CONFIG) {
#ifdef BOOT_CONFIG
		user_config();
#else
		printf("kernel does not support -c; continuing..\n");
#endif
	}
}
@


1.40
log
@Move the cpu_setup() call to the end of initarm().  On Cortex-A53 processors
atomic instructions don't work unless the data cache is enabled.  This happens
in cpu_setup(), but that gets currently called from cpu_startup() which runs
after a number of kernel subsystems have been initialized.  Since some of
these subsystems use locks, which need atomic instructions, we fault on
Cortex-A53.  Since at the end of initarm() we're done setting up the pmap
and initializing other low-level sense, calling cpu_setup() here makes much
more sense.

Remove setting up proc0paddr as well from cpu_startup(), since that already
happens in initarm().

Tested on zaurus by deraadt@@.

ok jsg@@, patrick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: armish_machdep.c,v 1.39 2015/05/10 15:56:28 jsg Exp $ */
@


1.39
log
@VM_MAX_KERNEL_ADDRESS is the end of the kva range not the end of
addressable virtual memory space but arm ports were using a value of
0xffffffff for this.

Instead of using a shared VM_MAX_KERNEL_ADDRESS define add md
VM_KERNEL_SPACE_SIZE defines based on the KERNEL_VM_SIZE values
from the respective machdep.c files.

djm's novena was hitting "panic: bufinit: can't reserve VM for buffers"
without a similiar change.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: armish_machdep.c,v 1.38 2015/05/08 22:56:53 miod Exp $ */
d773 2
@


1.38
log
@Need explicit <sys/kcore.h> include now.
@
text
@d1 1
a1 1
/*	$OpenBSD: armish_machdep.c,v 1.37 2015/05/05 02:13:46 guenther Exp $ */
a121 2


d125 1
a125 7

/*
 * The range 0xc1000000 - 0xcfffffff is available for kernel VM space
 * Core-logic registers and I/O mappings occupy 0xfd000000 - 0xffffffff
 */
#define KERNEL_VM_SIZE		0x20000000

@


1.37
log
@emul_native is only used for kernel threads which can't dump core, so
delete coredump_trad(), uvm_coredump(), cpu_coredump(), struct md_coredump,
and various #includes that are superfluous.

This leaves compat_linux processes without a coredump callback.  If that
ability is desired, someone should update it to use coredump_elf32() and
verify the results...

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: armish_machdep.c,v 1.36 2015/01/18 10:17:42 jsg Exp $ */
d92 1
a98 1
#include <dev/ic/smc91cxxreg.h>
@


1.36
log
@unifdef IPKDB.  These codepaths are holdouts from NetBSD code and are
not used.
@
text
@d1 1
a1 1
/*	$OpenBSD: armish_machdep.c,v 1.35 2014/12/10 15:29:53 mikeb Exp $ */
a91 1
#include <sys/kcore.h>
@


1.35
log
@retire shutdown hooks; ok deraadt, krw
@
text
@d1 1
a1 1
/*	$OpenBSD: armish_machdep.c,v 1.34 2014/12/03 20:09:32 krw Exp $ */
a146 3
#ifdef IPKDB
#define UND_STACK_SIZE	2
#else
a147 1
#endif
@


1.34
log
@More duplicate #include cleanout.

ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: armish_machdep.c,v 1.33 2014/11/16 12:30:56 deraadt Exp $ */
d275 1
a275 1
	
a276 1
	doshutdownhooks();
@


1.33
log
@Replace a plethora of historical protection options with just
PROT_NONE, PROT_READ, PROT_WRITE, and PROT_EXEC from mman.h.
PROT_MASK is introduced as the one true way of extracting those bits.
Remove UVM_ADV_* wrapper, using the standard names.
ok doug guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: armish_machdep.c,v 1.32 2014/09/20 09:28:24 kettenis Exp $ */
a97 1
#include <sys/device.h>
@


1.32
log
@Use config_suspend_all(9).

ok mpi@@, uebayasi@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: armish_machdep.c,v 1.31 2014/07/21 17:25:47 uebayasi Exp $ */
d319 1
a319 1
	VM_PROT_READ|VM_PROT_WRITE,
d603 1
a603 1
		    VM_PROT_READ|VM_PROT_WRITE, PTE_CACHE);
d606 1
a606 1
		    VM_PROT_READ|VM_PROT_WRITE, PTE_CACHE);
d615 1
a615 1
	    IRQ_STACK_SIZE * PAGE_SIZE, VM_PROT_READ|VM_PROT_WRITE, PTE_CACHE);
d617 1
a617 1
	    ABT_STACK_SIZE * PAGE_SIZE, VM_PROT_READ|VM_PROT_WRITE, PTE_CACHE);
d619 1
a619 1
	    UND_STACK_SIZE * PAGE_SIZE, VM_PROT_READ|VM_PROT_WRITE, PTE_CACHE);
d621 1
a621 1
	    UPAGES * PAGE_SIZE, VM_PROT_READ | VM_PROT_WRITE, PTE_CACHE);
d624 1
a624 1
	    L1_TABLE_SIZE, VM_PROT_READ | VM_PROT_WRITE, PTE_PAGETABLE);
d629 1
a629 1
		    VM_PROT_READ|VM_PROT_WRITE, PTE_PAGETABLE);
d639 1
a639 1
	    VM_PROT_READ|VM_PROT_WRITE, PTE_CACHE);
d642 1
a642 1
	    VM_PROT_READ|VM_PROT_WRITE, PTE_CACHE);
@


1.31
log
@boot(9): Reduce annoying style diffs

- Always use either: ((x & RB_XXX) != 0) or ((x & RB_XXX) == 0) in boolean
  context (mostly if (x), or x ? y : z)
  - prom_halt() in alpha is confirmed to take int as boolean

Converted by coccinelle.  No functional change intended.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a251 2
	struct device *mainbus;

d279 1
a279 3
	mainbus = device_mainbus();
	if (mainbus != NULL)
		config_suspend(mainbus, DVACT_POWERDOWN);
@


1.30
log
@boot(9): Cosmetic changes to improve diff'ability.
@
text
@d267 1
a267 1
	if (!(howto & RB_NOSYNC))
d288 2
a289 2
	if (howto & RB_HALT) {
		if (howto & RB_POWERDOWN) {
@


1.29
log
@Cosmetic changes to reduce diffs.
@
text
@d306 2
a307 2
	while(1);
	/*NOTREACHED*/
@


1.28
log
@Set cold to 1 before executing the DVACT_POWERDOWN handlers when halting or
rebooting a machine, like it is done in the hibernate case.

At least some USB host controller drivers rely on this to busy way instead
of sleeping.  Avoid a panic on macppc with an uhci(4) cardbus plugged in.

ok deraadt@@, uebayashi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: armish_machdep.c,v 1.27 2014/07/10 20:15:26 uebayasi Exp $ */
d273 1
a273 1
	splhigh();		/* Disable interrupts. */
a275 1
	/* Do a dump if requested. */
@


1.27
log
@boot(9): Remove comments about RB_*, "cold", and savectx()

Again remove slightly different comments to reduce diffs.  These will be
re-added once boot() become MI and its specification is clearly re-defined.

OK miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d273 2
a274 3

	/* Say NO to interrupts */
	splhigh();
@


1.26
log
@boot(): Unify declarations

OK deraadt@@
@
text
@a254 4
		/*
		 * If the system is cold, just halt, unless the user
		 * explicitely asked for reboot.
		 */
@


1.25
log
@Revert previous diff setting cold to 1 on shutdown because it breaks machine
with softraid(4) disks.

softraid(4) is the last real consumer of the doshutdownhooks(9) API and it is
not trivial to convert its hook to a DVACT_POWERDOWN handler since the latter
does not allow to sleep.
@
text
@d1 1
a1 1
/*	$OpenBSD: armish_machdep.c,v 1.24 2014/05/30 13:46:16 mpi Exp $ */
d249 1
a249 1
void
@


1.24
log
@Set cold to 1 before executing the DVACT_POWERDOWN handlers when halting or
rebooting a machine, like it is done in the hibernate case.

At least some USB host controller drivers rely on this to busy way instead
of sleeping.  Avoid a panic on macppc with an uhci(4) cardbus plugged in.

ok deraadt@@, uebayashi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: armish_machdep.c,v 1.23 2014/03/23 18:20:59 miod Exp $ */
d277 3
a279 2
	splhigh();		/* Disable interrupts. */
	cold = 1;
@


1.23
log
@Unbreak after last commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: armish_machdep.c,v 1.22 2014/03/13 03:52:55 dlg Exp $ */
d277 2
a278 3

	/* Say NO to interrupts */
	splhigh();
@


1.22
log
@get rid of the assumption that the head of the alldevs list is the
"mainbus" device. this breaks when mpath is enabled because it
attaches before mainbus and therefore takes the head position.

have autoconf provide device_mainbus() which looks up mainbus_cd,
and use that instead.

discussed with deraadt who just wants mpath stuff to move forward
despite there being many ways to shine this particular turd.
@
text
@d1 1
a1 1
/*	$OpenBSD: armish_machdep.c,v 1.21 2013/11/13 18:30:48 jasper Exp $ */
d252 2
@


1.21
log
@add missing headers here too, forgotten after testing the diff.
@
text
@d1 1
a1 1
/*	$OpenBSD: armish_machdep.c,v 1.20 2013/11/13 07:03:11 uebayasi Exp $ */
d285 3
a287 2
	if (!TAILQ_EMPTY(&alldevs))
		config_suspend(TAILQ_FIRST(&alldevs), DVACT_POWERDOWN);
@


1.20
log
@boot(): Don't forget calling if_downall() and uvm_shutdown() on arm ports.

"Unification good" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d101 1
d106 2
@


1.19
log
@A few missing config_suspend(, DVACT_POWERDOWN) constructs after
doshutdownhooks() calls.
XXX arm-based ports ought to really share their reboot code.
@
text
@d1 1
a1 1
/*	$OpenBSD: armish_machdep.c,v 1.18 2011/10/19 20:18:31 drahn Exp $ */
d268 4
@


1.18
log
@API change to initarm to pass arguments from the bootloader thru to MD
C code. Will be used on beagle to process machine id and atags.
Looked at by uwe@@, tested on beagle/armish/zaurus.
@
text
@d1 1
a1 1
/*	$OpenBSD: armish_machdep.c,v 1.17 2011/05/30 22:25:20 oga Exp $ */
d278 2
@


1.17
log
@Remove the freelist member from vm_physseg

The new world order of pmemrange makes this data completely redundant
(being dealt with by the pmemrange constraints instead). Remove all code
that messes with the freelist.

While touching every caller of uvm_page_physload() anyway, add the flags
argument to all callers (all but one is 0 and that one already used
PHYSLOAD_DEVICE) and remove the macro magic to allow callers to continue
without it.

Should shrink the code a bit, as well.

matthew@@ pointed out some mistakes i'd made.
``freelist death, I like. Ok.' ariane@@
`I agree with the general direction, go ahead and i'll fix any fallout
shortly'' miod@@ (68k 88k and vax i could not check would build)
@
text
@d1 1
a1 1
/*	$OpenBSD: armish_machdep.c,v 1.16 2010/06/27 08:05:59 drahn Exp $ */
d338 1
a338 1
initarm(void *arg)
@


1.16
log
@back out for duplicate declarations sprinkled by viking raiders
as bob did for zaurus
@
text
@d1 1
a1 1
/*	$OpenBSD: armish_machdep.c,v 1.15 2010/06/27 03:03:48 thib Exp $ */
d753 1
a753 2
	    atop(physical_freestart), atop(physical_freeend),
	    VM_FREELIST_DEFAULT);
@


1.15
log
@uvm constraints. Add two mandatory MD symbols, uvm_md_constraints
which contains the constraints for DMA/memory allocation for each
architecture, and dma_constraints which contains the range of addresses
that are dma accessable by the system.

This is based on ariane@@'s physcontig diff, with lots of bugfixes and
additions the following additions by my self:

Introduce a new function pool_set_constraints() which sets the address
range for which we allocate pages for the pool from, this is now used
for the mbuf/mbuf cluster pools to keep them dma accessible.

The !direct archs no longer stuff pages into the kernel object in
uvm_km_getpage_pla but rather do a pmap_extract() in uvm_km_putpages.

Tested heavily by my self on i386, amd64 and sparc64. Some tests on
alpha and SGI.

"commit it" beck, art, oga, deraadt
"i like the diff" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: armish_machdep.c,v 1.13 2008/11/26 01:29:00 kevlo Exp $ */
a93 1
#include <uvm/uvm.h>
a176 3

struct uvm_constraint_range  dma_constraint = { 0x0, (paddr_t)-1 };
struct uvm_constraint_range *uvm_md_constraints[] = { NULL };
@


1.14
log
@Declare safepri at the MD level on each platform, so that the kern_synch.c
does not have to deal with it as a common.  Some platforms may be missed
by this commit... if you spot one, fix it the same way.
ok miod
@
text
@d94 1
d178 3
@


1.13
log
@fix boot() function comment

ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: armish_machdep.c,v 1.12 2008/06/08 20:56:31 miod Exp $ */
d203 6
@


1.12
log
@Change boot() logic, to match what other platforms do and avoid duplicating
code in the cold case.
@
text
@d1 1
a1 1
/*	$OpenBSD: armish_machdep.c,v 1.11 2008/03/23 17:05:41 deraadt Exp $ */
d231 1
a231 1
 * void boot(int howto, char *bootstr)
@


1.11
log
@setroot() is supposed to be safe in all cases, so kill the special cases
for RB_DFLTROOT; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: armish_machdep.c,v 1.10 2007/05/19 15:49:05 miod Exp $ */
a242 4
	/*
	 * If we are still cold then hit the air brakes
	 * and crash to earth fast
	 */
d244 7
a250 12
		doshutdownhooks();
		if ((howto & (RB_HALT | RB_USERREQ)) != RB_USERREQ) {
			printf("The operating system has halted.\n");
			printf("Please press any key to reboot.\n\n");
			cngetc();
		}
		printf("rebooting...\n");
		delay(60000);
		cpu_reset();
		printf("reboot failed; spinning\n");
		while(1);
		/*NOTREACHED*/
a252 3
	/* Disable console buffering */
/*	cnpollc(1);*/

d270 1
a270 1
	/* Run any shutdown hooks */
d284 1
d286 1
@


1.10
log
@Kernel crash dump support for arm-based platform, with minimal support in
libkvm, but all the necessary information for a complete _kvm_kvatop() is
available in the crash dump.
@
text
@d1 1
a1 1
/*	$OpenBSD: armish_machdep.c,v 1.9 2006/08/01 22:22:20 kettenis Exp $ */
a373 4
#ifdef RAMDISK_HOOKS
        boothowto |= RB_DFLTROOT;
#endif /* RAMDISK_HOOKS */

@


1.9
log
@Make RB_POWERDOWN work on the Thecus.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: armish_machdep.c,v 1.8 2006/08/01 15:44:24 deraadt Exp $ */
d92 1
d110 1
d345 1
d454 1
a454 1
	 * tables must be on 4K bounaries.  What we do is allocate the
d568 4
a571 2
//	pmap_link_l2pt(l1pagetable, IQ80321_IOPXS_VBASE,
//	    &kernel_pt_table[KERNEL_PT_IOPXS]);
d584 4
a587 1
		extern char etext[], _end[];
d591 5
a595 2
printf("kernelsize text %x total %x end %xesym %x\n", textsize, totalsize,
 _end, esym);
d602 5
d677 1
d680 1
d770 4
@


1.8
log
@trust the bootloader about the root disk; ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: armish_machdep.c,v 1.7 2006/07/30 21:38:12 drahn Exp $ */
d237 1
d287 5
@


1.7
log
@With new kernel and bootloader, argument passing now works, version 1.0.
(and yes this does work on iodata and thecus)
@
text
@d1 1
a1 1
/*	$OpenBSD: armish_machdep.c,v 1.6 2006/07/20 02:48:03 deraadt Exp $ */
d151 1
a151 1
char *boot_file = "wd0a";
@


1.6
log
@assume root is always on wd0a, for now
@
text
@d1 1
a1 1
/*	$OpenBSD: armish_machdep.c,v 1.5 2006/07/11 05:58:14 miod Exp $ */
d364 1
a364 1
//	process_kernel_args((char *)0xa0200000 - MAX_BOOT_STRING - 1);
d805 1
d808 1
@


1.5
log
@Remove old debug goo; drahn@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: armish_machdep.c,v 1.4 2006/06/15 21:35:30 drahn Exp $ */
d151 1
a151 1
char *boot_file = NULL;
@


1.4
log
@rewritten, simplifed interrupt controller for 80321, half the lines
and much less complex. IPL_SERIAL goes at the same time.
@
text
@d1 1
a1 1
/*	$OpenBSD: armish_machdep.c,v 1.3 2006/06/15 21:28:59 drahn Exp $ */
a845 4
	uint32_t *p, old;

	p = (void *)0xc0445000;
	old = *p;
a866 1
	printf("memory value %x@@%p %x\n", 0xc0445000, *(uint32_t*)0xc0445000, old);
@


1.3
log
@All all 256MB on the thecus to configure, by raising the amount of
KVM available.
@
text
@d1 1
a1 1
/*	$OpenBSD: armish_machdep.c,v 1.2 2006/05/31 05:54:09 drahn Exp $ */
d751 1
a751 1
	i80321_intr_init();
@


1.2
log
@Use same defines as on zaurus, need to verify the correct settings here.
again, pointed out by miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: armish_machdep.c,v 1.1 2006/05/29 17:13:19 drahn Exp $ */
d129 1
a129 1
#define KERNEL_VM_SIZE		0x0c000000
a395 3
#if 1
	memsize = 128* 1024 * 1024;
#endif
@


1.1
log
@Add a new port for ARM based products from a variety of vendors, typically
using Redboot as a loader and using pci, that have a variety of fairly minor
hardware differences between them.
@
text
@d1 1
a1 1
/*	$OpenBSD: zaurus_machdep.c,v 1.19 2005/11/11 23:50:03 deraadt Exp $ */
d187 1
a187 1
#define	KERNEL_PT_KERNEL_NUM	16
d195 1
a195 1
#define	KERNEL_PT_VMDATA_NUM	4	/* start with 16MB of KVM */
@

