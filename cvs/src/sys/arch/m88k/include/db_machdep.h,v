head	1.19;
access;
symbols
	OPENBSD_6_0:1.19.0.2
	OPENBSD_6_0_BASE:1.19
	OPENBSD_5_9:1.18.0.6
	OPENBSD_5_9_BASE:1.18
	OPENBSD_5_8:1.18.0.8
	OPENBSD_5_8_BASE:1.18
	OPENBSD_5_7:1.18.0.2
	OPENBSD_5_7_BASE:1.18
	OPENBSD_5_6:1.18.0.4
	OPENBSD_5_6_BASE:1.18
	OPENBSD_5_5:1.17.0.4
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.16.0.4
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.16.0.2
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.15.0.6
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.4
	OPENBSD_5_0:1.15.0.2
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.14.0.2
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.13.0.12
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.6
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.13.0.10
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.8
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.4
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.2
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.12.0.4
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.2
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.10.0.2
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.7.0.2
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.6.0.2
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.3.0.2
	OPENBSD_3_7_BASE:1.3
	OPENBSD_3_6:1.1.0.4
	OPENBSD_3_6_BASE:1.1
	SMP_SYNC_A:1.1
	SMP_SYNC_B:1.1
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.19
date	2016.04.27.11.10.48;	author mpi;	state Exp;
branches;
next	1.18;
commitid	57btDderNGPG4fjG;

1.18
date	2014.03.16.20.31.46;	author guenther;	state Exp;
branches;
next	1.17;

1.17
date	2013.10.17.08.02.16;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2013.01.05.11.20.56;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2011.03.23.16.54.35;	author pirofti;	state Exp;
branches;
next	1.14;

1.14
date	2010.11.27.19.57.23;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2007.11.14.17.54.24;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2007.01.13.22.00.56;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2006.12.24.20.30.35;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2006.05.08.14.03.34;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2006.05.03.18.14.51;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2006.05.02.21.44.37;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2005.11.20.22.07.07;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2005.04.30.16.43.11;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2005.04.30.16.42.36;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2005.04.19.15.23.37;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2005.01.04.21.32.40;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2004.09.30.21.48.56;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2004.04.26.12.34.05;	author miod;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2004.06.05.23.09.47;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.19
log
@G/C DDB_REGS.
@
text
@/*	$OpenBSD: db_machdep.h,v 1.18 2014/03/16 20:31:46 guenther Exp $ */
/*
 * Mach Operating System
 * Copyright (c) 1993-1991 Carnegie Mellon University
 * Copyright (c) 1991 OMRON Corporation
 * All Rights Reserved.
 *
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON AND OMRON ALLOW FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON AND OMRON DISCLAIM ANY LIABILITY OF ANY KIND
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

#ifndef _M88K_DB_MACHDEP_H_
#define _M88K_DB_MACHDEP_H_

/* trap numbers used by ddb */
#define	DDB_ENTRY_BKPT_NO	130
#define	DDB_ENTRY_TRACE_NO	131
#define DDB_ENTRY_TRAP_NO	132

#ifndef	_LOCORE

#include <machine/reg.h>
#include <machine/trap.h>

#include <uvm/uvm_param.h>

#define	SET_PC_REGS(regs, value)					\
do {									\
	(regs)->sxip = (value);						\
	(regs)->snip = (value) + 4;					\
} while (0)

#ifdef DDB

#define BKPT_SIZE	(4)	/* number of bytes in bkpt inst. */
#define BKPT_INST	(0xf000d000 | DDB_ENTRY_BKPT_NO) /* tb0, 0,r0, 130 */
#define BKPT_SET(inst)	(BKPT_INST)

/* Entry trap for the debugger - used for inline assembly breaks*/
#define ENTRY_ASM		"tb0 0, %r0, 132"

typedef	vaddr_t		db_addr_t;
typedef	long		db_expr_t;
typedef	struct reg	db_regs_t;
extern db_regs_t	ddb_regs;	/* register state */

int	ddb_break_trap(int, db_regs_t *);
int	ddb_entry_trap(int, db_regs_t *);
void	m88k_print_instruction(int, u_int, u_int32_t);	/* db_disasm.c */

/*
 * inst_call(ins) - is the instruction a function call.
 * Could be either bsr or jsr.
 */
#define	inst_call(I) \
	(((I) & 0xf8000000) == 0xc8000000 /* bsr */ || \
	 ((I) & 0xfffffbe0) == 0xf400c800 /* jsr */)
/*
 * inst_return(ins) - is the instruction a function call return.
 * Not mutually exclusive with inst_branch. Should be a jmp r1.
 */
#define	inst_return(I)	(((I) & 0xfffffbff) == 0xf400c001)

/*
 * inst_trap_return(ins) - is the instruction a return from trap.
 * Should be a rte.
 */
#define	inst_trap_return(I)	((I) == 0xf400c000)

/* breakpoint/watchpoint foo */
#define IS_BREAKPOINT_TRAP(type,code) ((type)==T_KDB_BREAK)
#define IS_WATCHPOINT_TRAP(type,code) 0

/* machine specific commands have been added to ddb */
#define DB_MACHINE_COMMANDS

#ifdef MULTIPROCESSOR
extern cpuid_t ddb_mp_nextcpu;
#endif

#endif	/* DDB */
#endif	/* _LOCORE */

#endif	/* _M88K_DB_MACHDEP_H_ */
@


1.18
log
@DDB supports ELF symbols are all archs, and it's always the same as the
native size, so eliminate the #defines.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.h,v 1.17 2013/10/17 08:02:16 deraadt Exp $ */
a62 1
#define	DDB_REGS	(&ddb_regs)
@


1.17
log
@Remove support for a.out and ecoff.  We only do elf now.
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.h,v 1.16 2013/01/05 11:20:56 miod Exp $ */
a93 3

#define	DB_ELF_SYMBOLS
#define	DB_ELFSIZE	32
@


1.16
log
@Switch m88k ports to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.h,v 1.15 2011/03/23 16:54:35 pirofti Exp $ */
a94 1
#ifdef __ELF__
a96 3
#else
#define	DB_AOUT_SYMBOLS
#endif
@


1.15
log
@Normalize sentinel. Use _MACHINE_*_H_ and _<ARCH>_*_H_ properly and consitently.

Discussed and okay drahn@@. Okay deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.h,v 1.14 2010/11/27 19:57:23 miod Exp $ */
d57 1
a57 1
#define ENTRY_ASM		"tb0 0, r0, 132"
d95 4
d100 1
@


1.14
log
@Remove ddb single-step load and store counters. Most platforms do not
implement them, and they are of questionable usefulness.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.h,v 1.13 2007/11/14 17:54:24 miod Exp $ */
d29 2
a30 2
#ifndef  _M88K_DB_MACHDEP_H_
#define  _M88K_DB_MACHDEP_H_
@


1.13
log
@Let ``machine cpu #'' hop to the given cpu.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.h,v 1.12 2007/01/13 22:00:56 miod Exp $ */
a64 2
int	inst_load(u_int);
int	inst_store(u_int);
@


1.12
log
@Bring back a <machine/frame.h> for m88k platforms, by splitting <machine/pcb.h>
in its exception-related contents and pcb-related contents.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.h,v 1.11 2006/12/24 20:30:35 miod Exp $ */
d98 4
@


1.11
log
@Define PROC_PC. Then, since profiling information is being reported in
statclock(), do not bother doing this in userret() anymore. As a result,
userret() does not need its pc and ticks arguments, simplify.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.h,v 1.10 2006/05/08 14:03:34 miod Exp $ */
d39 1
a39 1
#include <machine/pcb.h>
@


1.10
log
@Clean the internal m88k trap type codes; while there, simplify and
factorize the build of the VBR page betweem luna88k and mvme88k.

Tested by aoyama@@ and I.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.h,v 1.9 2006/05/03 18:14:51 miod Exp $ */
a42 9

/*
 * Extract the real pc from the exception pipeline.
 */
#define	PC_REGS(regs)							\
	(CPU_IS88110 ? ((regs)->exip & XIP_ADDR) :			\
	 ((regs)->sxip & XIP_V ? (regs)->sxip & XIP_ADDR :		\
	  ((regs)->snip & NIP_V ? (regs)->snip & NIP_ADDR :		\
				   (regs)->sfip & FIP_ADDR)))
@


1.9
log
@Overhaul of the disassembler code, with random fixes, better conditionnal
branches decoding, correct control register descriptions, and (the reason
for these changes in the first place) 88110 instruction support.

ddb will now disassemble by default for the processor it is running for,
and using the alternate format (x/I) disassembles for the other.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.h,v 1.8 2006/05/02 21:44:37 miod Exp $ */
a100 3
#if 0
#define IS_WATCHPOINT_TRAP(type,code) ((type)==T_KDB_WATCH)
#else
a101 1
#endif /* T_WATCHPOINT */
@


1.8
log
@Replace db_{disable,enable}_interrupts with expanded version of themselves,
having macros for this is not worth doing.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.h,v 1.7 2005/11/20 22:07:07 miod Exp $ */
d78 1
a78 1
int	m88k_print_instruction(u_int, long);	/* db_disasm.c */
@


1.7
log
@Complete overhaul of the single-stepping ddb code, close in spirit to the
ptrace single-stepping changes of a few months ago; simpler and smaller
than the (previously used) MI fallback implementation on 88100.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.h,v 1.6 2005/04/30 16:43:11 miod Exp $ */
a110 3

#define	db_enable_interrupt(psr)	set_psr(((psr) = get_psr()) & ~PSR_IND)
#define	db_disable_interrupt(psr)	set_psr(psr)
@


1.6
log
@A simpler and better SET_PC_REGS().
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.h,v 1.5 2005/04/30 16:42:36 miod Exp $ */
d44 4
a47 1
#define PC_REGS(regs)							\
a58 13
/* inst_return(ins) - is the instruction a function call return.
 * Not mutually exclusive with inst_branch. Should be a jmp r1. */
#define inst_return(I) \
	(((I) & 0xfffffbff) == 0xf400c001 ? TRUE : FALSE)

/*
 * inst_call - function call predicate: is the instruction a function call.
 * Could be either bsr or jsr
 */
#define inst_call(I) \
	(((I) & 0xf8000000) == 0xc8000000 /*bsr*/ || \
	 ((I) & 0xfffffbe0) == 0xf400c800 /*jsr*/ ? TRUE : FALSE)

a60 7
/*
 * This is a hack so that mc88100 can use software single step
 * and mc88110 can use the wonderful hardware single step
 * feature. XXX smurph
 */
#define INTERNAL_SSTEP		/* Use local Single Step routines */

d62 1
a62 1
#define BKPT_INST	(0xF000D000 | DDB_ENTRY_BKPT_NO) /* tb0, 0,r0, vector 130 */
d74 24
a97 8
unsigned	inst_load(unsigned);
unsigned	inst_store(unsigned);
boolean_t	inst_branch(unsigned);
db_addr_t	next_instr_address(db_addr_t, unsigned);
db_addr_t	branch_taken(u_int, db_addr_t, db_expr_t (*)(db_regs_t *, int),
    db_regs_t *);
int		ddb_break_trap(int, db_regs_t *);
int		ddb_entry_trap(int, db_regs_t *);
a106 15
#ifdef INTERNAL_SSTEP
db_expr_t getreg_val(db_regs_t *, int);
void db_set_single_step(db_regs_t *);
void db_clear_single_step(db_regs_t *);
#else
/* need software single step */
#define SOFTWARE_SSTEP 1 /* we need this for mc88100 */
#endif

#define DB_ACCESS_LEVEL DB_ACCESS_ANY

/* instruction type checking - others are implemented in db_sstep.c */

#define inst_trap_return(ins)  ((ins) == 0xf400fc00)

a108 2

int m88k_print_instruction(unsigned, long);
@


1.5
log
@Remove m88k_psr_type and function with utterly long names to control the psr,
and use get_psr() / set_psr() or simple macros that expand into them everywhere.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.h,v 1.4 2005/04/19 15:23:37 miod Exp $ */
d52 2
a53 8
	if (CPU_IS88110)						\
		(regs)->exip = ((regs)->exip & ~XIP_ADDR) | old_pc;	\
	else if ((regs)->sxip & XIP_V)					\
		(regs)->sxip = ((regs)->sxip & ~XIP_ADDR) | old_pc;	\
	else if ((regs)->snip & NIP_V)					\
		(regs)->snip = ((regs)->snip & ~NIP_ADDR) | old_pc;	\
	else								\
		(regs)->sfip = ((regs)->sfip & ~FIP_ADDR) | old_pc;	\
@


1.4
log
@Nuke DB_NO_AOUT, and have platforms with a.out symbols explicitely provide
DB_AOUT_SYMBOLS.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.h,v 1.3 2005/01/04 21:32:40 miod Exp $ */
d127 1
a127 1
#define inst_trap_return(ins)  ((ins) == 0xf400fc00U)
d132 1
a132 1
int m88k_print_instruction(unsigned iadr, long inst);
d135 3
@


1.3
log
@Kill old, unused, Mach defines, and provide a correct SET_PC_REGS
implementation - due to the awkwardness of the m88k architecture, PC_REGS
can NOT be an lvalue.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.h,v 1.2 2004/09/30 21:48:56 miod Exp $ */
d133 2
@


1.2
log
@Introduce sparc-like CPU_ISFOO macros, to short-circuit evaluations when
compiling for one flavour only.

This makes code slightly smaller on all m88k-based platforms (my roughly
1KB), and saves more than meets the eye on luna88k, which is m88100-based.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.h,v 1.1 2004/04/26 12:34:05 miod Exp $ */
a28 4
/*
 * Machine-dependent defined for the new kernel debugger
 */

d44 17
a60 8
/*
 * The low two bits of sxip, snip, sfip have valid bits
 * in them that need to masked to get the correct addresses
 */
#define PC_REGS(regs) \
	CPU_IS88110 ? ((regs)->exip & ~3) : \
	  (((regs)->sxip & 2) ? (regs)->sxip & ~3 : \
	    ((regs)->snip & 2 ? (regs)->snip & ~3 : (regs)->sfip & ~3))
d64 2
a65 1
#define inst_return(I) (((I)&0xfffffbffU) == 0xf400c001U ? TRUE : FALSE)
d71 3
a73 5
#define inst_call(I) ({ unsigned i = (I); \
	((((i) & 0xf8000000U) == 0xc8000000U || /*bsr*/ \
          ((i) & 0xfffffbe0U) == 0xf400c800U)   /*jsr*/ \
	? TRUE : FALSE) \
;})
d89 1
a89 1
#define ENTRY_ASM       	"tb0 0, r0, 132"
d97 8
a104 10
extern int db_noisy;

unsigned inst_load(unsigned);
unsigned inst_store(unsigned);
boolean_t inst_branch(unsigned);
db_addr_t next_instr_address(db_addr_t, unsigned);
db_addr_t branch_taken(u_int, db_addr_t, db_expr_t (*)(db_regs_t *, int),
		       db_regs_t *);
int ddb_break_trap(int type, db_regs_t *eframe);
int ddb_entry_trap(int level, db_regs_t *eframe);
d108 1
a108 1
#if defined(T_WATCHPOINT)
a113 3
/* we don't want coff support */
#define DB_NO_COFF 1

a122 4
/*
 * Debugger can get to any address space
 */

a124 4
#define DB_VALID_KERN_ADDR(addr) (!badaddr((void *)(addr), 1))
#define DB_VALID_ADDRESS(addr,user) \
  (user ? db_check_user_addr(addr) : DB_VALID_KERN_ADDR(addr))

a128 3
/* don't need to load symbols */
#define DB_SYMBOLS_PRELOADED 1

d130 1
a130 19
#define DB_MACHINE_COMMANDS 1

/*
 * This routine should return true for instructions that result in unconditonal
 * transfers of the flow of control. (Unconditional Jumps, subroutine calls,
 * subroutine returns, etc).
 *
 *  Trap and return from trap  should not  be listed here.
 */
#define inst_unconditional_flow_transfer(I) ({ unsigned i = (I); \
    ((((i) & 0xf0000000U) == 0xc0000000U || /* br, bsr */ \
      ((i) & 0xfffff3e0U) == 0xf400c000U)   /* jmp, jsr */ \
     ? TRUE: FALSE) \
;})

/* Return true if the instruction has a delay slot.  */
#define db_branch_is_delayed(I)	inst_delayed(I)

#define	db_printf_enter	db_printing
@


1.1
log
@Start factorizing luna88k and mvme88k common parts.
For now, include files only.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_machdep.h,v 1.27 2004/01/12 07:46:16 miod Exp $ */
d53 1
a53 1
	cputyp == CPU_88110 ? ((regs)->exip & ~3) : \
@


1.1.2.1
log
@Merge with the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
@

