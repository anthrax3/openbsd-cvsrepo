head	1.11;
access;
symbols
	OPENBSD_6_1:1.11.0.10
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.11.0.8
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.11.0.4
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.11.0.6
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	OPENBSD_5_6:1.10.0.4
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.8.0.8
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.4
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.2
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.7.0.16
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.14
	OPENBSD_5_0:1.7.0.12
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.10
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.8
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.2
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.6
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.4
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.6.0.4
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.2
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.3.0.2
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.2.0.2
	OPENBSD_4_1_BASE:1.2
	OPENBSD_4_0:1.1.0.4
	OPENBSD_4_0_BASE:1.1
	OPENBSD_3_9:1.1.0.2
	OPENBSD_3_9_BASE:1.1;
locks; strict;
comment	@ * @;


1.11
date	2015.02.11.00.14.11;	author dlg;	state Exp;
branches;
next	1.10;
commitid	OPUATglsyqcmeG4g;

1.10
date	2014.07.15.16.28.11;	author miod;	state Exp;
branches;
next	1.9;
commitid	pnmOuL5y6GMpBFWc;

1.9
date	2014.03.29.18.09.29;	author guenther;	state Exp;
branches;
next	1.8;

1.8
date	2013.01.05.11.20.56;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2009.02.18.21.09.01;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2007.12.02.21.21.29;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2007.10.27.20.36.17;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2007.10.27.20.35.21;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2007.05.19.16.58.43;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2006.11.18.22.47.13;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2005.12.03.19.04.06;	author miod;	state Exp;
branches;
next	;


desc
@@


1.11
log
@make the rwlock implementation MI.

each arch used to have to provide an rw_cas operation, but now we
have the rwlock code build its own version. on smp machines it uses
atomic_cas_ulong. on uniproc machines it avoids interlocked
instructions by using straight loads and stores. this is safe because
rwlocks are only used from process context and processes are currently
not preemptible in our kernel. so alpha/ppc/etc might get a benefit.

ok miod@@ kettenis@@ deraadt@@
@
text
@#ifndef	_M88K_LOCK_H_
#define	_M88K_LOCK_H_
/*	$OpenBSD: lock.h,v 1.10 2014/07/15 16:28:11 miod Exp $	*/

/*
 * Copyright (c) 2005, Miodrag Vallat.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <m88k/asm.h>

typedef volatile u_int	__cpu_simple_lock_t;

/* do not change these - code below assumes r0 == __SIMPLELOCK_UNLOCKED */
#define	__SIMPLELOCK_LOCKED	1
#define	__SIMPLELOCK_UNLOCKED	0

static __inline__ void
__cpu_simple_lock_init(__cpu_simple_lock_t *l)
{
	*l = __SIMPLELOCK_UNLOCKED;
}

static __inline__ int
__cpu_simple_lock_try(__cpu_simple_lock_t *l)
{
	/*
	 * The local __cpu_simple_lock_t is not declared volatile, so that
	 * there are not pipeline synchronization around stores to it.
	 * xmem will do the right thing regardless of the volatile qualifier.
	 */
	u_int old = __SIMPLELOCK_LOCKED;

	__asm__ volatile
	    ("xmem %0, %2, %%r0" : "+r"(old), "+m"(*l) : "r"(l));

	return (old == __SIMPLELOCK_UNLOCKED);
}

static __inline__ void
__cpu_simple_lock(__cpu_simple_lock_t *l)
{
	for (;;) {
		if (__cpu_simple_lock_try(l) != 0)
			break;
		while (*l != __SIMPLELOCK_UNLOCKED)
			;	/* spin without exclusive bus access */
	}
}

static __inline__ void
__cpu_simple_unlock(__cpu_simple_lock_t *l)
{
	*l = __SIMPLELOCK_UNLOCKED;
}

#endif	/* _M88K_LOCK_H_ */
@


1.10
log
@Implement rw_cas() with atomic_cas_ulong() now, instead of a dedicated
routine.
@
text
@d3 1
a3 1
/*	$OpenBSD: lock.h,v 1.9 2014/03/29 18:09:29 guenther Exp $	*/
a75 4

#if defined(_KERNEL) && defined(MULTIPROCESSOR)
#define	rw_cas(p, o, n) (atomic_cas_ulong(p, o, n) != o)
#endif
@


1.9
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@d3 1
a3 1
/*	$OpenBSD: lock.h,v 1.8 2013/01/05 11:20:56 miod Exp $	*/
d78 1
a78 2
int	rw_cas_m88k(volatile unsigned long *, unsigned long, unsigned long);
#define	rw_cas rw_cas_m88k
@


1.8
log
@Switch m88k ports to ELF.
@
text
@d3 1
a3 1
/*	$OpenBSD: lock.h,v 1.7 2009/02/18 21:09:01 miod Exp $	*/
d54 1
a54 1
	__asm__ __volatile__
@


1.7
log
@In __cpu_simple_lock(), do not hog the bus with exclusive accesses; if
xmem didn't return the expected value, spin doing regular loads until it
appears we have a chance to grab the lock again.
@
text
@d3 1
a3 1
/*	$OpenBSD: lock.h,v 1.6 2007/12/02 21:21:29 miod Exp $	*/
d55 1
a55 1
	    ("xmem %0, %2, r0" : "+r"(old), "+m"(*l) : "r"(l));
@


1.6
log
@Provide a specific rw_cas() function for MP kernels, simulating a really
atomic compare-and-swap operation.
@
text
@d3 1
a3 1
/*	$OpenBSD: lock.h,v 1.5 2007/10/27 20:36:17 miod Exp $	*/
a43 18
static __inline__ void
__cpu_simple_lock(__cpu_simple_lock_t *l)
{
	/*
	 * The local __cpu_simple_lock_t is not declared volatile, so that
	 * stores to it can be optimized away, since we will use a register
	 * and only spin on it. xmem will do the right thing regardless of
	 * the volatile qualifier.
	 */
	u_int old;

	do {
		old = __SIMPLELOCK_LOCKED;
		__asm__ __volatile__
		    ("xmem %0, %2, r0" : "+r"(old), "+m"(*l) : "r"(l));
	} while (old != __SIMPLELOCK_UNLOCKED);
}

d58 11
@


1.5
log
@Use the same assembly constraints for all inline assembler xmem constructs.
@
text
@d3 1
a3 1
/*	$OpenBSD: lock.h,v 1.3 2007/05/19 16:58:43 miod Exp $	*/
d83 5
@


1.4
log
@In __cpu_simple_lock() and __cpu_simple_lock_try(), use a local u_int instead
of a local __cpu_simple_lock_t (which is volatile), so that the compiler can
optimize it to a register, instead of using a memory location (and doing
stores into it when __cpu_simple_lock() is spinning).

This makes the MP code a bit smaller and a bit faster.
@
text
@d58 1
a58 1
		    ("xmem %0, %1, r0" : "+r" (old) : "r" (l));
d73 1
a73 1
	    ("xmem %0, %1, r0" : "+r" (old) : "r" (l));
@


1.3
log
@Simpler asm constraints for simplelock operations.
@
text
@d3 1
a3 1
/*	$OpenBSD: lock.h,v 1.2 2006/11/18 22:47:13 miod Exp $	*/
d47 7
a53 1
	__cpu_simple_lock_t old;
d65 6
a70 1
	__cpu_simple_lock_t old = __SIMPLELOCK_LOCKED;
@


1.2
log
@No need to use xmem when unlocking a simple_lock.
@
text
@d3 1
a3 1
/*	$OpenBSD: lock.h,v 1.1 2005/12/03 19:04:06 miod Exp $	*/
d52 1
a52 1
		    ("xmem %0, %2, r0" : "=r" (old) : "0" (old), "r" (l));
d62 1
a62 1
	    ("xmem %0, %2, r0" : "=r" (old) : "0" (old), "r" (l));
@


1.1
log
@Implement __cpu_simple_lock_t for m88k.
@
text
@d3 1
a3 1
/*	$OpenBSD$	*/
d70 1
a70 2
	__asm__ __volatile__
	    ("xmem r0, %0, r0" : : "r" (l));
@

