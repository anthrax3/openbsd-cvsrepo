head	1.13;
access;
symbols
	OPENBSD_6_1:1.13.0.4
	OPENBSD_6_1_BASE:1.13
	OPENBSD_6_0:1.13.0.2
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.12.0.20
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.12.0.22
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.14
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.12.0.18
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.12.0.16
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.12.0.12
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.12.0.10
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.8
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.6
	OPENBSD_5_0:1.12.0.4
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.2
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.11.0.6
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.2
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.11.0.4
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.9.0.8
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.4
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.2
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.8.0.2
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.7.0.4
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.2
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.6.0.2
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.3.0.2
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.1.0.6
	OPENBSD_3_7_BASE:1.1
	OPENBSD_3_6:1.1.0.4
	OPENBSD_3_6_BASE:1.1
	SMP_SYNC_A:1.1
	SMP_SYNC_B:1.1
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.13
date	2016.06.13.23.51.59;	author dlg;	state Exp;
branches;
next	1.12;
commitid	pePIrytkQAoqTKCZ;

1.12
date	2010.12.21.14.56.24;	author claudio;	state Exp;
branches;
next	1.11;

1.11
date	2009.03.15.20.39.53;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2009.03.15.19.40.40;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2007.11.17.05.32.05;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2007.05.16.19.37.06;	author thib;	state Exp;
branches;
next	1.7;

1.7
date	2006.03.13.19.39.52;	author brad;	state Exp;
branches;
next	1.6;

1.6
date	2005.12.03.19.04.06;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2005.10.12.20.53.22;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2005.09.06.19.28.22;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2005.05.01.09.55.49;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2005.04.19.15.29.47;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	2004.04.26.12.34.05;	author miod;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2004.06.05.23.09.48;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.13
log
@rename raiseipl to splraise()

another step toward making splraise an MI api.

ok aoyama@@
@
text
@/*	$OpenBSD: intr.h,v 1.12 2010/12/21 14:56:24 claudio Exp $	*/
/*
 * Copyright (c) 2001 Wasabi Systems, Inc.
 * All rights reserved.
 *
 * Written by Jason R. Thorpe for Wasabi Systems, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed for the NetBSD Project by
 *	Wasabi Systems, Inc.
 * 4. The name of Wasabi Systems, Inc. may not be used to endorse
 *    or promote products derived from this software without specific prior
 *    written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY WASABI SYSTEMS, INC. ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL WASABI SYSTEMS, INC
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
/*
 * Copyright (C) 2000 Steve Murphree, Jr.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef _M88K_INTR_H_
#define _M88K_INTR_H_

#ifdef _KERNEL
#ifndef _LOCORE
int	getipl(void);
int	setipl(int level);
int	splraise(int);
int	spl0(void);

/* SPL asserts */
#ifdef DIAGNOSTIC
/*
 * Although this function is implemented in MI code, it must be in this MD
 * header because we don't want this header to include MI includes.
 */
void splassert_fail(int, int, const char *);
extern int splassert_ctl;
void splassert_check(int, const char *);
#define splassert(__wantipl) do {			\
	if (splassert_ctl > 0) {			\
		splassert_check(__wantipl, __func__);	\
	}						\
} while (0)
#define	splsoftassert(wantipl)	splassert(IPL_SOFTINT)
#else
#define	splassert(wantipl)	do { /* nothing */ } while (0)
#define	splsoftassert(wantipl)	do { /* nothing */ } while (0)
#endif

#endif /* _LOCORE */

#define splsoftclock()		splraise(IPL_SOFTINT)
#define splsoftnet()		splraise(IPL_SOFTINT)
#define splbio()		splraise(IPL_BIO)
#define splnet()		splraise(IPL_NET)
#define spltty()		splraise(IPL_TTY)
#define splclock()		splraise(IPL_CLOCK)
#define splstatclock()		splraise(IPL_STATCLOCK)
#define	splsched()		splraise(IPL_SCHED)
#define splvm()			splraise(IPL_VM)
#define splhigh()		setipl(IPL_HIGH)

#define	spllock()		splhigh()

#define splx(x)			((x) ? setipl((x)) : spl0())

/*
 * Generic software interrupt support for all m88k platforms.
 */

#ifndef _LOCORE

#define	IPL_SOFT		0
#define	IPL_SOFTCLOCK		1
#define	IPL_SOFTNET		2
#define	IPL_SOFTTTY		3

#define	SI_SOFT			0	/* for IPL_SOFT */
#define	SI_SOFTCLOCK		1	/* for IPL_SOFTCLOCK */
#define	SI_SOFTNET		2	/* for IPL_SOFTNET */
#define	SI_SOFTTTY		3	/* for IPL_SOFTTTY */

#define	SI_NQUEUES		4

#include <machine/mutex.h>
#include <sys/queue.h>

struct soft_intrhand {
	TAILQ_ENTRY(soft_intrhand) sih_list;
	void (*sih_func)(void *);
	void *sih_arg;
	struct soft_intrq *sih_siq;
	int sih_pending;
};

struct soft_intrq {
	TAILQ_HEAD(, soft_intrhand) siq_list;
	int siq_si;
	struct mutex siq_mtx;
};

void	 softintr_disestablish(void *);
void	 softintr_dispatch(int);
void	*softintr_establish(int, void (*)(void *), void *);
void	 softintr_init(void);
void	 softintr_schedule(void *);

extern int softpending;

#endif	/* _LOCORE */

#endif /* _KERNEL */
#endif /* _M88K_INTR_H_ */
@


1.12
log
@Convert netisr to a normal soft interrupt instead of hanving MD code
for it. This makes the netisr a real C function which will help further
development. No noticable performance change on i386 and amd64.
With input from kettenis@@ and miod@@ additional OKs mikeb@@ and henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.11 2009/03/15 20:39:53 miod Exp $	*/
d70 1
a70 1
int	raiseipl(int level);
d95 9
a103 9
#define splsoftclock()		raiseipl(IPL_SOFTINT)
#define splsoftnet()		raiseipl(IPL_SOFTINT)
#define splbio()		raiseipl(IPL_BIO)
#define splnet()		raiseipl(IPL_NET)
#define spltty()		raiseipl(IPL_TTY)
#define splclock()		raiseipl(IPL_CLOCK)
#define splstatclock()		raiseipl(IPL_STATCLOCK)
#define	splsched()		raiseipl(IPL_SCHED)
#define splvm()			raiseipl(IPL_VM)
@


1.11
log
@Generic softinterrupt support for m88k based platforms, adapted from arm
with different locking mechanism. 88110 soft ipi are replaced with an
ipi callback which is checked upon return from exception (it can not be kept
as a softintr, as the generic softinterrupt code doesn't have per-cpu
pending softintr queues).
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.10 2009/03/15 19:40:40 miod Exp $	*/
a151 5

/* XXX For legacy software interrupts. */
extern struct soft_intrhand *softnet_intrhand;

#define	setsoftnet()	softintr_schedule(softnet_intrhand)
@


1.10
log
@Introduce splsoftassert(), similar to splassert() but for soft interrupt
levels. This will allow for platforms where soft interrupt levels do not
map to real hardware interrupt levels to have soft ipl values overlapping
hard ipl values without breaking spl asserts.
@
text
@d1 35
a35 1
/*	$OpenBSD: intr.h,v 1.9 2007/11/17 05:32:05 miod Exp $	*/
d68 4
a71 4
int getipl(void);
int setipl(int level);
int raiseipl(int level);
int spl0(void);
d87 1
a87 1
#define splsoftassert(wantipl) splassert(wantipl)
d95 2
a96 2
#define splsoftclock()		raiseipl(IPL_SOFTCLOCK)
#define splsoftnet()		raiseipl(IPL_SOFTNET)
d109 50
@


1.9
log
@Rework {get,set,raise}ipl() to minimize psr modification, especially on
boards such as mvme1[89]7 where spl changes can be atomic.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.8 2007/05/16 19:37:06 thib Exp $	*/
d53 1
d56 1
@


1.8
log
@splassert_ctl defaults to 1 now, so dont wrap the checks for
splassert_ctl > 0 in __predict_false().

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.7 2006/03/13 19:39:52 brad Exp $	*/
d34 3
a36 2
unsigned setipl(unsigned level);
unsigned raiseipl(unsigned level);
@


1.7
log
@remove splimp.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.6 2005/12/03 19:04:06 miod Exp $	*/
d48 1
a48 1
	if (__predict_false(splassert_ctl > 0)) {	\
@


1.6
log
@Implement __cpu_simple_lock_t for m88k.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.5 2005/10/12 20:53:22 miod Exp $	*/
a65 1
#define splimp()		raiseipl(IPL_IMP)
@


1.5
log
@Define IPL_SCHED and spslsched(), matching the statclock level.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.4 2005/09/06 19:28:22 miod Exp $	*/
d69 2
@


1.4
log
@MVME88K -> M88K in include file guard symbols. No functional changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.3 2005/05/01 09:55:49 miod Exp $	*/
a57 1
#define splnone			spl0
d65 1
@


1.3
log
@Bring raise-only semantics to splsoft* on m68k and m88k, as done elsewhere.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.2 2005/04/19 15:29:47 mickey Exp $	*/
d73 1
a73 1
#endif /* _MVME88K_INTR_H_ */
@


1.2
log
@nothing uses spllowersoftclock() anymore
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.1 2004/04/26 12:34:05 miod Exp $	*/
a37 2
/* needs major cleanup - XXX nivas */

a57 8
#define spl1()		setipl(1)
#define spl2()		setipl(2)
#define spl3()		setipl(3)
#define spl4()		setipl(4)
#define spl5()		setipl(5)
#define spl6()		setipl(6)
#define spl7()		setipl(7)

d59 2
a60 2
#define splsoftclock()		setipl(IPL_SOFTCLOCK)
#define splsoftnet()		setipl(IPL_SOFTNET)
d70 1
a70 1
#define splx(x)		((x) ? setipl((x)) : spl0())
@


1.1
log
@Start factorizing luna88k and mvme88k common parts.
For now, include files only.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.14 2004/01/08 14:29:45 miod Exp $	*/
a68 1
#define spllowersoftclock()	setipl(IPL_SOFTCLOCK)
@


1.1.2.1
log
@Merge with the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@

