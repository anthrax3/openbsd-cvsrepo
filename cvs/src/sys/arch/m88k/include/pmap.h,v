head	1.26;
access;
symbols
	OPENBSD_6_2_BASE:1.26
	OPENBSD_6_1:1.26.0.10
	OPENBSD_6_1_BASE:1.26
	OPENBSD_6_0:1.26.0.6
	OPENBSD_6_0_BASE:1.26
	OPENBSD_5_9:1.26.0.2
	OPENBSD_5_9_BASE:1.26
	OPENBSD_5_8:1.26.0.4
	OPENBSD_5_8_BASE:1.26
	OPENBSD_5_7:1.25.0.2
	OPENBSD_5_7_BASE:1.25
	OPENBSD_5_6:1.24.0.6
	OPENBSD_5_6_BASE:1.24
	OPENBSD_5_5:1.24.0.4
	OPENBSD_5_5_BASE:1.24
	OPENBSD_5_4:1.22.0.2
	OPENBSD_5_4_BASE:1.22
	OPENBSD_5_3:1.21.0.6
	OPENBSD_5_3_BASE:1.21
	OPENBSD_5_2:1.21.0.4
	OPENBSD_5_2_BASE:1.21
	OPENBSD_5_1_BASE:1.21
	OPENBSD_5_1:1.21.0.2
	OPENBSD_5_0:1.19.0.4
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.19.0.2
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.15.0.2
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.14.0.2
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.14.0.4
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.12.0.8
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.12.0.4
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.12.0.2
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.9.0.8
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.6
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.4
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.2
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.5.0.2
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.4.0.4
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4;
locks; strict;
comment	@ * @;


1.26
date	2015.07.25.20.45.05;	author miod;	state Exp;
branches;
next	1.25;
commitid	qIXrw7Yr4QCeqfDT;

1.25
date	2015.02.15.21.34.33;	author miod;	state Exp;
branches;
next	1.24;
commitid	eahBabNpxnDWKzqJ;

1.24
date	2014.01.30.18.16.41;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2013.11.02.23.10.30;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2013.05.17.22.33.25;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2011.10.25.18.38.06;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2011.10.09.17.08.22;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2011.01.05.22.20.22;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2010.12.31.21.38.08;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2010.12.26.15.40.59;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2010.11.18.21.21.38;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2010.05.02.22.01.46;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2009.05.02.14.32.27;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2009.03.04.19.39.02;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2007.12.25.00.48.51;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2007.11.21.19.40.33;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2007.09.10.18.49.45;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2005.12.11.21.45.28;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2005.12.03.19.06.08;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2005.12.02.21.16.45;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2005.12.01.22.24.49;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2005.03.28.12.42.44;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2004.08.06.22.39.13;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.04.15.54.37;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2004.07.26.11.08.19;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2004.07.25.11.06.42;	author miod;	state Exp;
branches;
next	;


desc
@@


1.26
log
@Only store mod/ref flags in the vm_page_md struct, not in every pv_entry.
@
text
@/*	$OpenBSD: pmap.h,v 1.25 2015/02/15 21:34:33 miod Exp $	*/
/*
 * Mach Operating System
 * Copyright (c) 1991 Carnegie Mellon University
 * Copyright (c) 1991 OMRON Corporation
 * All Rights Reserved.
 *
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 */
#ifndef _M88K_PMAP_H_
#define _M88K_PMAP_H_

#ifdef	_KERNEL

#include <machine/mmu.h>

/*
 * PMAP structure
 */

struct pmap {
	sdt_entry_t		*pm_stab;	/* virtual pointer to sdt */
	apr_t			 pm_apr;
	int			 pm_count;	/* reference count */
	struct pmap_statistics	pm_stats;	/* pmap statistics */
};

/* 	The PV (Physical to virtual) List.
 *
 * For each vm_page_t, pmap keeps a list of all currently valid virtual
 * mappings of that page. An entry is a pv_entry_t; the list is the
 * pv_head_table. This is used by things like pmap_remove, when we must
 * find and remove all mappings for a particular physical page.
 */
/* XXX - struct pv_entry moved to vmparam.h because of include ordering issues */

typedef struct pmap *pmap_t;
typedef struct pv_entry *pv_entry_t;

extern	pmap_t		kernel_pmap;
extern	struct pmap	kernel_pmap_store;
extern	caddr_t		vmmap;
extern	apr_t		kernel_apr, userland_apr;

#define	pmap_kernel()			(&kernel_pmap_store)
#define pmap_resident_count(pmap)	((pmap)->pm_stats.resident_count)
#define	pmap_wired_count(pmap)		((pmap)->pm_stats.wired_count)

#define pmap_copy(dp,sp,d,l,s)		do { /* nothing */ } while (0)
#define pmap_update(pmap)		do { /* nothing */ } while (0)

#define	pmap_clear_modify(pg)		pmap_unsetbit(pg, PG_M)
#define	pmap_clear_reference(pg)	pmap_unsetbit(pg, PG_U)

void	pmap_bootstrap(paddr_t, paddr_t);
void	pmap_bootstrap_cpu(cpuid_t);
void	pmap_cache_ctrl(vaddr_t, vaddr_t, u_int);
void	pmap_page_uncache(paddr_t);
int	pmap_set_modify(pmap_t, vaddr_t);
void	pmap_unmap_firmware(void);
boolean_t pmap_unsetbit(struct vm_page *, int);

#define pmap_unuse_final(p)		/* nothing */
#define	pmap_remove_holes(vm)		do { /* nothing */ } while (0)

int	pmap_translation_info(pmap_t, vaddr_t, paddr_t *, uint32_t *);
/*
 * pmap_translation_info() return values
 */
#define	PTI_INVALID	0
#define	PTI_PTE		1
#define	PTI_BATC	2

#define	pmap_map_direct(pg)		((vaddr_t)VM_PAGE_TO_PHYS(pg))
#define	pmap_unmap_direct(va)		PHYS_TO_VM_PAGE((paddr_t)va)
#define	__HAVE_PMAP_DIRECT
#define	PMAP_STEAL_MEMORY

#endif	/* _KERNEL */

#ifndef _LOCORE
struct pv_entry {
	struct pv_entry	*pv_next;	/* next pv_entry */
	struct pmap	*pv_pmap;	/* pmap where mapping lies */
	vaddr_t		pv_va;		/* virtual address for mapping */
};

struct vm_page_md {
	struct pv_entry pv_ent;
	int		pv_flags;
};

#define	VM_MDPAGE_INIT(pg)						\
do {									\
	(pg)->mdpage.pv_ent.pv_next = NULL;				\
	(pg)->mdpage.pv_ent.pv_pmap = NULL;				\
	(pg)->mdpage.pv_ent.pv_va = 0;					\
	(pg)->mdpage.pv_flags = 0;					\
} while (0)

#endif /* _LOCORE */

#endif /* _M88K_PMAP_H_ */
@


1.25
log
@Change pmap_remove_holes() to take a vmspace instead of a map as its argument.

Use this on vax to correctly pick the end of the stack area now that the
stackgap adjustment code will no longer guarantee it is a fixed location.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.24 2014/01/30 18:16:41 miod Exp $	*/
d18 2
a21 2
#ifdef	_KERNEL

a90 1
	int		pv_flags;
d94 2
a95 1
	struct pv_entry pvent;
d98 6
a103 5
#define	VM_MDPAGE_INIT(pg) do {			\
	(pg)->mdpage.pvent.pv_next = NULL;	\
	(pg)->mdpage.pvent.pv_pmap = NULL;	\
	(pg)->mdpage.pvent.pv_va = 0;		\
	(pg)->mdpage.pvent.pv_flags = 0;	\
@


1.24
log
@Move declaration of struct vm_page_md from <machine/vmparam.h> to
<machine/pmap.h> where it belongs, and compensate in <uvm/uvm_extern.h>
by including <uvm/uvm_pmap.h> before <uvm/uvm_page.h>. Tested on all
MACHINE_ARCH but amd64 and i386 (and hppa64).
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.23 2013/11/02 23:10:30 miod Exp $	*/
d69 1
a69 1
#define	pmap_remove_holes(map)		do { /* nothing */ } while (0)
@


1.23
log
@Create the initial page tables in the area between the end of the firmware
data area and the kernel image, whenever possible.

On 88100/88200 systems, use BATC mappings to map the kernel text (and the
kernel data for non-MULTIPROCESSOR kernels). 88110 to follow soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.22 2013/05/17 22:33:25 miod Exp $	*/
d85 21
@


1.22
log
@Extend cmmu routines to return the caching mode to use for page tables.

Alter the 88200-specific code to enforce cache-inhibited page tables for
extremely old 88200 versions, and to disable write-back caching on systems
where xmem instructions do not behave correctly when applied to write-back
cached addresses.

No change introduced on 88110 systems, as well as most 88100 systems; the
affected systems are 88100 systems with 88100 revision < 10 and/or 88200
revision < 7; that is, only early MVME181 and MVME188 (not 188A) systems.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.21 2011/10/25 18:38:06 miod Exp $	*/
d64 4
a69 2
int	pmap_set_modify(pmap_t, vaddr_t);
boolean_t pmap_unsetbit(struct vm_page *, int);
@


1.21
log
@Replace the naive 88110 tlb update code, which would always invalidate the
whole tlb (32 of 'em), with smarter `tlb probe and update with new pte if tlb
match found' code. This makes the 88110-specific pmap_update() unnecessary, as
updates are no longer aggregated to avoid the number of flushes. This also
makes tlb handling similar between 88100 and 88110, from the pmap's point of
view, so there is no need to use different routines.

No impact on 88100, no user-noticeable performance change on 88100 GENERIC,
slight improvement on 88110 GENERIC.MP.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.20 2011/10/09 17:08:22 miod Exp $	*/
d48 1
a48 1
extern	apr_t		default_apr;
@


1.20
log
@Let BUS_DMA_COHERENT allocations return cache-inhibited pages.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.19 2011/01/05 22:20:22 miod Exp $	*/
a54 1
#if !defined(M88110)
a55 1
#endif
@


1.19
log
@Pass pmap_bootstrap() the memory range used by the PROM/BUG/firmware/whatever,
instead of assuming it is ``everything below the kernel image''.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.18 2010/12/31 21:38:08 miod Exp $	*/
d65 1
@


1.18
log
@Massive overhauling of the m88k pmap, though I can't pretend it's a new pmap
since a large part of the structures and logic remains.

Since m88k has separate supervisor/user spaces, we can map physical memory 1:1
in supervisor space, and have the kernel virtual address space start from the
end of physical memory.

This allows us to switch to __HAVE_PMAP_DIRECT. And to get rid of the double
mapped sdt, since now their virtual and physical addresses will always match.

The upper bound of the kernel virtual memory space is now platform dependent,
until the code which relies upon some hardware devices being mapped 1:1 in
supervisor mode is updated to no longer require this (this is mainly a PITA on
luna88k, where onboard devices start at 0x40000000, leaving only 1GB of KVA at
the moment - still much better than the previous 512MB).

Tested on mvme88k only (187, 188, 197LE, 197DP). Other platforms ought to
work, aviion will be checked shortly and fixed if necessary. No known
OpenBSD/luna88k system in working condition at the moment.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.17 2010/12/26 15:40:59 miod Exp $	*/
d62 1
a62 1
void	pmap_bootstrap(void);
@


1.17
log
@Kill pmap_phys_address(), and force every driver's mmap() routine to return
a physical address [more precisely, something suitable to pass to pmap_enter()'sphysical address argument].

This allows MI drivers to implement mmap() routines without having to know
about the pmap_phys_address() implementation and #ifdef obfuscation.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.16 2010/11/18 21:21:38 miod Exp $	*/
a29 3
#ifdef MULTIPROCESSOR
	__cpu_simple_lock_t	 pm_lock;
#endif
d62 1
a62 1
void	pmap_bootstrap(vaddr_t);
d64 1
a64 1
void	pmap_cache_ctrl(pmap_t, vaddr_t, vaddr_t, u_int);
d69 13
@


1.16
log
@Declare pmap_proc_iflush() in <uvm/uvm_pmap.h> unless <machine/pmap.h>
provides an inline version of it.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.15 2010/05/02 22:01:46 miod Exp $	*/
a55 1
#define pmap_phys_address(frame)        ((paddr_t)(ptoa(frame)))
@


1.15
log
@Precompute the userland process apr cache bits into a global variable.
On AViiON systems with the 6:1 CMMU:CPU configuration, force cached
mappings to be writethrough - this probably hides a bug in the code, but
that's the only way so far to get such a system running stably.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.14 2009/05/02 14:32:27 miod Exp $	*/
a68 1
void	pmap_proc_iflush(struct proc *, vaddr_t, vsize_t);
@


1.14
log
@Drop the pm_cpus bitmask field from struct pmap, and instead remember the
currently active userland pmap in each processors struct cpu_info.

This thus skips the complete tlb flush if idle switches back to
the proc previously running on this processor.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.13 2009/03/04 19:39:02 miod Exp $	*/
d51 1
@


1.13
log
@Since 88110 processors can not flush individual TLB entries, instead of
flushing the whole TLB block every time a pte is modified, store a bitmask
of pending flushes and do them at pmap_update() time. 88100 behaviour is
unchanged.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.12 2007/12/25 00:48:51 miod Exp $	*/
a29 2
	/* cpus using of this pmap; NCPU must be <= 32 */
	u_int32_t		 pm_cpus;
@


1.12
log
@Do not make struct pmap visible unless _KERNEL.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.11 2007/11/21 19:40:33 miod Exp $	*/
d60 3
a62 1
#define pmap_update(pmap)		do { /* nothing (yet) */ } while (0)
@


1.11
log
@Move pmap_set_modify() prototype to a header file
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.10 2007/09/10 18:49:45 miod Exp $	*/
d20 2
a48 2

#ifdef	_KERNEL
@


1.10
log
@Introduce a md pmap hook, pmap_remove_holes(), which is supposed to mark
the holes a MMU may have from a given vm_map. This will be automagically
invoked for newly created vmspaces.

On platforms with MMU holes (e.g. sun4, sun4c and vax), this prevents
mmap(2) hints which would end up being in the hole to be accepted as valid,
causing unexpected signals when the process tries to access the hole
(since pmap can not fill the hole anyway).

Unfortunately, the logic mmap() uses to pick a valid address for anonymous
mappings needs work, as it will only try to find an address higher than the
hint, which causes all mmap() with a hint in the hole to fail on vax. This
will be improved later.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.9 2005/12/11 21:45:28 miod Exp $	*/
d71 1
@


1.9
log
@Work in progress SMP code; mvme88k boards can spin up secondary CPUs,
kernel boots single user. Still a lot of polishing and bugfixing to do.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.8 2005/12/03 19:06:08 miod Exp $	*/
d70 1
@


1.8
log
@Replace simplelocks with __cpu_simple_locks for cmmu and pmap locking,
for the MULTIPROCESSOR case.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.7 2005/12/02 21:16:45 miod Exp $	*/
d66 1
@


1.7
log
@Better choice of types for struct pmap members and cmmu functions;
no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.6 2005/12/01 22:24:49 miod Exp $	*/
d26 2
a27 2
	apr_t			pm_apr;
	int			pm_count;	/* reference count */
d29 4
a32 2
	u_int32_t		pm_cpus;
	struct simplelock	pm_lock;
@


1.6
log
@Get rid of PMAP_NULL and xx_ENTRY_NULL and simply use NULL when necessary.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.5 2005/03/28 12:42:44 miod Exp $	*/
d26 1
a26 1
	u_int32_t		pm_apr;
@


1.5
log
@Relax dependencies.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.4 2004/08/06 22:39:13 deraadt Exp $	*/
a32 2

#define PMAP_NULL ((pmap_t) 0)
@


1.4
log
@rename sparc kill_user_windows() to pmap_unuse_final().  provide empty stubs
on all other architectures.  remove last architecture dependent #ifdef from
uvm code.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.3 2004/08/04 15:54:37 miod Exp $	*/
a18 1
#include <machine/pcb.h>
@


1.3
log
@Completely remove BATC code. BATC on 88200 are way too small to be worth
using as part of the general pmap machinery (though they might come back
at some point to speed up I/O mappings), and we don't use the 88110 BATC
yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.2 2004/07/26 11:08:19 miod Exp $	*/
d69 1
@


1.2
log
@Provide a real pmap_proc_iflush() routine.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.1 2004/07/25 11:06:42 miod Exp $	*/
a24 1
/* #define PMAP_USE_BATC */
a32 4
#ifdef	PMAP_USE_BATC
	u_int32_t		pm_ibatc[BATC_MAX];	/* instruction BATCs */
	u_int32_t		pm_dbatc[BATC_MAX];	/* data BATCs */
#endif
@


1.1
log
@Merge luna88k and mvme88k pmap. The pmap will now assume that the memory
below the kernel text is reserved for the PROM, instead of using fixed
(but different) values between luna88k and mvme88k.

Tested on mvme88k by myself, on luna88k by aoyama@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d71 3
a73 4
#define pmap_proc_iflush(p,va,len)	do { /* nothing */ } while (0)

void pmap_bootstrap(vaddr_t);
void pmap_cache_ctrl(pmap_t, vaddr_t, vaddr_t, u_int);
@

