head	1.32;
access;
symbols
	OPENBSD_6_2:1.32.0.18
	OPENBSD_6_2_BASE:1.32
	OPENBSD_6_1:1.32.0.16
	OPENBSD_6_1_BASE:1.32
	OPENBSD_6_0:1.32.0.12
	OPENBSD_6_0_BASE:1.32
	OPENBSD_5_9:1.32.0.8
	OPENBSD_5_9_BASE:1.32
	OPENBSD_5_8:1.32.0.10
	OPENBSD_5_8_BASE:1.32
	OPENBSD_5_7:1.32.0.2
	OPENBSD_5_7_BASE:1.32
	OPENBSD_5_6:1.32.0.6
	OPENBSD_5_6_BASE:1.32
	OPENBSD_5_5:1.32.0.4
	OPENBSD_5_5_BASE:1.32
	OPENBSD_5_4:1.30.0.2
	OPENBSD_5_4_BASE:1.30
	OPENBSD_5_3:1.29.0.2
	OPENBSD_5_3_BASE:1.29
	OPENBSD_5_2:1.27.0.4
	OPENBSD_5_2_BASE:1.27
	OPENBSD_5_1_BASE:1.27
	OPENBSD_5_1:1.27.0.2
	OPENBSD_5_0:1.26.0.4
	OPENBSD_5_0_BASE:1.26
	OPENBSD_4_9:1.26.0.2
	OPENBSD_4_9_BASE:1.26
	OPENBSD_4_8:1.23.0.2
	OPENBSD_4_8_BASE:1.23
	OPENBSD_4_7:1.22.0.2
	OPENBSD_4_7_BASE:1.22
	OPENBSD_4_6:1.22.0.6
	OPENBSD_4_6_BASE:1.22
	OPENBSD_4_5:1.22.0.4
	OPENBSD_4_5_BASE:1.22
	OPENBSD_4_4:1.20.0.4
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.20.0.2
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.17.0.4
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.17.0.2
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.16.0.4
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.16.0.2
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.8.0.2
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.5.0.4
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.2
	OPENBSD_3_6_BASE:1.5
	SMP_SYNC_A:1.2
	SMP_SYNC_B:1.2
	SMP:1.2.0.2;
locks; strict;
comment	@ * @;


1.32
date	2013.11.16.18.45.20;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2013.11.02.23.10.30;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2013.05.17.22.33.25;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2013.02.19.21.02.06;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2013.02.17.18.07.36;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2011.10.25.18.38.06;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2011.01.05.22.14.28;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2010.12.31.21.12.16;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2010.12.31.20.54.21;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2010.06.22.17.42.35;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2009.02.16.23.03.31;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2009.02.01.00.52.17;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2007.12.15.19.33.32;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2007.11.22.05.47.45;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2007.11.22.05.42.48;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2007.02.11.12.49.35;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2005.12.11.21.45.28;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2005.12.04.15.00.25;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2005.12.04.12.20.19;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2005.12.03.19.06.08;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2005.12.03.14.30.05;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2005.12.02.21.16.45;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2005.11.25.22.17.14;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2005.09.25.20.55.13;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2005.04.27.14.09.45;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2005.04.27.14.07.09;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2005.03.28.12.42.44;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2004.08.06.13.23.49;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2004.08.04.15.54.37;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.02.08.34.59;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2004.05.07.18.06.39;	author miod;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2004.04.26.12.34.05;	author miod;	state Exp;
branches;
next	;

1.2.2.1
date	2004.06.05.23.09.47;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.32
log
@Allow initial device mappings (from pmap_table) to be backed up by BATC.
Use this on luna88k to map the bitmap planes of the frame buffer used by
the driver. 10% speedup under X.
@
text
@/*	$OpenBSD: cmmu.h,v 1.31 2013/11/02 23:10:30 miod Exp $ */
/*
 * Mach Operating System
 * Copyright (c) 1993-1992 Carnegie Mellon University
 * All Rights Reserved.
 *
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */

#ifndef	_M88K_CMMU_H_
#define	_M88K_CMMU_H_

/*
 * Prototypes and stuff for cmmu.c.
 */
#if defined(_KERNEL) && !defined(_LOCORE)

#include <machine/mmu.h>

/* machine dependent cmmu function pointer structure */
struct cmmu_p {
	cpuid_t (*init)(void);
	void (*batc_setup)(cpuid_t, apr_t);
	void (*setup_board_config)(void);
	void (*cpu_configuration_print)(int);
	void (*shutdown)(void);

	cpuid_t (*cpu_number)(void);

	apr_t (*apr_cmode)(void);
	apr_t (*pte_cmode)(void);
	void (*set_sapr)(apr_t);
	void (*set_uapr)(apr_t);

	void (*tlb_inv_s)(cpuid_t, vaddr_t, pt_entry_t);
	void (*tlb_inv_u)(cpuid_t, vaddr_t, pt_entry_t);
	void (*tlb_inv_all)(cpuid_t);

	void (*cache_wbinv)(cpuid_t, paddr_t, psize_t);
	void (*dcache_wb)(cpuid_t, paddr_t, psize_t);
	void (*icache_inv)(cpuid_t, paddr_t, psize_t);
	void (*dma_cachectl)(paddr_t, psize_t, int);

#ifdef MULTIPROCESSOR
	void (*dma_cachectl_local)(paddr_t, psize_t, int);
	void (*initialize_cpu)(cpuid_t);
#endif
};

extern const struct cmmu_p *cmmu;

#ifdef MULTIPROCESSOR
/*
 * On 8820x-based systems, this lock protects the CMMU SAR and SCR registers;
 * other registers may be accessed without locking it.
 * On 88410-based systems, this lock protects accesses to the BusSwitch GCSR
 * register, which masks or unmasks the 88410 control addresses.
 */
extern __cpu_simple_lock_t cmmu_cpu_lock;
#define CMMU_LOCK   __cpu_simple_lock(&cmmu_cpu_lock)
#define CMMU_UNLOCK __cpu_simple_unlock(&cmmu_cpu_lock)
#else
#define	CMMU_LOCK	do { /* nothing */ } while (0)
#define	CMMU_UNLOCK	do { /* nothing */ } while (0)
#endif	/* MULTIPROCESSOR */

#define cmmu_init			(cmmu->init)
#define cmmu_batc_setup			(cmmu->batc_setup)
#define setup_board_config		(cmmu->setup_board_config)
#define	cpu_configuration_print(cpu)	(cmmu->cpu_configuration_print)(cpu)
#define	cmmu_shutdown			(cmmu->shutdown)
#define	cmmu_cpu_number			(cmmu->cpu_number)
#define	cmmu_apr_cmode			(cmmu->apr_cmode)
#define	cmmu_pte_cmode			(cmmu->pte_cmode)
#define	cmmu_set_sapr(apr)		(cmmu->set_sapr)(apr)
#define	cmmu_set_uapr(apr)		(cmmu->set_uapr)(apr)
#define	cmmu_tlbis(cpu, va, pte) 	(cmmu->tlb_inv_s)(cpu, va, pte)
#define	cmmu_tlbiu(cpu, va, pte) 	(cmmu->tlb_inv_u)(cpu, va, pte)
#define	cmmu_tlbia(cpu) 		(cmmu->tlb_inv_all)(cpu)
#define	cmmu_cache_wbinv(cpu, pa, s)	(cmmu->cache_wbinv)(cpu, pa, s)
#define	cmmu_dcache_wb(cpu, pa, s)	(cmmu->dcache_wb)(cpu, pa, s)
#define	cmmu_icache_inv(cpu,pa,s)	(cmmu->icache_inv)(cpu, pa, s)
#define	dma_cachectl(pa, s, op)		(cmmu->dma_cachectl)(pa, s, op)
#define	dma_cachectl_local(pa, s, op)	(cmmu->dma_cachectl_local)(pa, s, op)
#define	cmmu_initialize_cpu(cpu)	(cmmu->initialize_cpu)(cpu)

/*
 * dma_cachectl{,_local}() modes
 */
#define DMA_CACHE_INV		0x00
#define DMA_CACHE_SYNC_INVAL	0x01
#define DMA_CACHE_SYNC		0x02

/*
 * Current BATC values.
 */

extern batc_t global_dbatc[BATC_MAX], global_ibatc[BATC_MAX];

#endif	/* _KERNEL && !_LOCORE */

#endif	/* _M88K_CMMU_H_ */
@


1.31
log
@Create the initial page tables in the area between the end of the firmware
data area and the kernel image, whenever possible.

On 88100/88200 systems, use BATC mappings to map the kernel text (and the
kernel data for non-MULTIPROCESSOR kernels). 88110 to follow soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmmu.h,v 1.30 2013/05/17 22:33:25 miod Exp $ */
d36 2
d111 6
@


1.30
log
@Extend cmmu routines to return the caching mode to use for page tables.

Alter the 88200-specific code to enforce cache-inhibited page tables for
extremely old 88200 versions, and to disable write-back caching on systems
where xmem instructions do not behave correctly when applied to write-back
cached addresses.

No change introduced on 88110 systems, as well as most 88100 systems; the
affected systems are 88100 systems with 88100 revision < 10 and/or 88200
revision < 7; that is, only early MVME181 and MVME188 (not 188A) systems.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmmu.h,v 1.29 2013/02/19 21:02:06 miod Exp $ */
d39 1
d84 1
@


1.29
log
@Introduce a new cmmu method to return the preferred cache mode bits for the
kernel APR. Return write-back for every design but those involving 88410,
where write through is returned.

Apparently the use of writeback on single-processor kernels using 88410 (197SP,
197DP) has only been working by fat chance, and the last two years of uvm
changes, as well as the switch to ELF (causing kernel rodata to move `up')
exposes silent memory corruption on (88410-size) aliased addresses.
(I am guilty of not using my 197DP board much after making 197LE write-back
capable, as 197LE turned out to be faster and more stable, for I would have
noticed this earlier).

Further thought needs to happen about this. It might be possible to switch to
writeback by default again as long as bus_dma maps things write-through on
88410 designs, and perhaps with a part of the kernel mapped with a write-through
BATC, since BATC have precedence upon page tables. Right now I'm trying to get
a stable release out of the door.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmmu.h,v 1.28 2013/02/17 18:07:36 miod Exp $ */
d45 2
a46 1
	apr_t (*kapr_cmode)(void);
d87 2
a88 1
#define	cmmu_kapr_cmode			(cmmu->kapr_cmode)
@


1.28
log
@Constify struct cmmu.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmmu.h,v 1.27 2011/10/25 18:38:06 miod Exp $ */
d45 1
d86 1
@


1.27
log
@Replace the naive 88110 tlb update code, which would always invalidate the
whole tlb (32 of 'em), with smarter `tlb probe and update with new pte if tlb
match found' code. This makes the 88110-specific pmap_update() unnecessary, as
updates are no longer aggregated to avoid the number of flushes. This also
makes tlb handling similar between 88100 and 88110, from the pmap's point of
view, so there is no need to use different routines.

No impact on 88100, no user-noticeable performance change on 88100 GENERIC,
slight improvement on 88110 GENERIC.MP.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmmu.h,v 1.26 2011/01/05 22:14:28 miod Exp $ */
d63 1
a63 1
extern struct cmmu_p *cmmu;
@


1.26
log
@Now that pmap_copy_page() no longer needs to flush a couple contiguous tlb
entries, drop the count parameter to cmmu_tlb_inv(), and introduce
cmmu_tlb_inv_all() to drop all user tlb entries (to be used during context
switches).
@
text
@d1 1
a1 1
/*	$OpenBSD: cmmu.h,v 1.25 2010/12/31 21:12:16 miod Exp $ */
d42 1
d44 1
d47 3
a49 1
	void (*tlb_inv)(cpuid_t, u_int, vaddr_t);
d51 1
d56 1
d87 3
a89 2
#define	cmmu_tlb_inv(cpu, k, va) 	(cmmu->tlb_inv)(cpu, k, va)
#define	cmmu_tlb_inv_all(cpu) 		(cmmu->tlb_inv_all)(cpu)
@


1.25
log
@Introduce a new cmmu routine, for page writebacks without invalidate. Will be
used two commits from now.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmmu.h,v 1.24 2010/12/31 20:54:21 miod Exp $ */
d45 2
a46 1
	void (*tlb_inv)(cpuid_t, u_int, vaddr_t, u_int);
d81 2
a82 1
#define	cmmu_tlb_inv(cpu, k, va, c) 	(cmmu->tlb_inv)(cpu, k, va, c)
@


1.24
log
@Standardize cache handling functions and defines to use wb/wbinv/inv instead
of flush/sync/inval. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmmu.h,v 1.23 2010/06/22 17:42:35 miod Exp $ */
d47 1
d82 1
@


1.23
log
@Since our caches are snooping, we only need to broadcast cache invalidates
on 88110 designs. Brings a ~8% speedup on GENERIC.MP on 197DP.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmmu.h,v 1.22 2009/02/16 23:03:31 miod Exp $ */
d45 3
a47 3
	void (*flush_tlb)(cpuid_t, u_int, vaddr_t, u_int);
	void (*flush_cache)(cpuid_t, paddr_t, psize_t);
	void (*flush_inst_cache)(cpuid_t, paddr_t, psize_t);
d79 3
a81 3
#define	cmmu_flush_tlb(cpu, k, va, c) 	(cmmu->flush_tlb)(cpu, k, va, c)
#define	cmmu_flush_cache(cpu, pa, s)	(cmmu->flush_cache)(cpu, pa, s)
#define	cmmu_flush_inst_cache(cpu,pa,s)	(cmmu->flush_inst_cache)(cpu, pa, s)
@


1.22
log
@More 88110 SMP work. Contains, horribly entangled:
- dma_cachectl() split into a ``local cpu only'' and ``all cpus'', and an ipi
  to broadcast ``local dma_cachectl'' is added.
- cpu_info fields are rearranged, to have the 88100-specific information
  and the 88110-specific information overlap, and has many more 88110
  ugly things.
- more ipi handling in the 197-specific area. Since it is not possible to
  have the second processor receive any hardware interrupt (selection
  is done on a level basis via ISEL, and we definitely do not want the
  main cpu to lose interrupts), the best we can do is to inflict ourselves
  a soft interrupt for late ipi processing. It gets used for softclock and
  hardclock on the secondary processor, but since the soft interrupt
  dispatcher doesn't have an exception frame, we have to remember parts
  of it to build a fake clockframe from the soft ipi handler (ugly but
  works).

This now lets GENERIC.MP run a few userland binaries before bugs trigger.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmmu.h,v 1.21 2009/02/01 00:52:17 miod Exp $ */
d74 1
a74 1
#define	cpu_configuration_print(a)	(cmmu->cpu_configuration_print)(a)
d77 8
a84 8
#define	cmmu_set_sapr(a)		(cmmu->set_sapr)(a)
#define	cmmu_set_uapr(a)		(cmmu->set_uapr)(a)
#define	cmmu_flush_tlb(a, b, c, d) 	(cmmu->flush_tlb)(a, b, c, d)
#define	cmmu_flush_cache(a, b, c)	(cmmu->flush_cache)(a, b, c)
#define	cmmu_flush_inst_cache(a, b, c)	(cmmu->flush_inst_cache)(a, b, c)
#define	dma_cachectl(a, b, c)		(cmmu->dma_cachectl)(a, b, c)
#define	dma_cachectl_local(a, b, c)	(cmmu->dma_cachectl_local)(a, b, c)
#define	cmmu_initialize_cpu(a)		(cmmu->initialize_cpu)(a)
d89 1
a89 1
#define DMA_CACHE_SYNC		0x00
d91 1
a91 3
#define DMA_CACHE_INV		0x02

#define	DMA_CACHE_MASK		0x03
@


1.21
log
@Remove dma_cachectl() and rename dma_cachectl_pa() to dma_cachectl() now that
the old vs(4) code is gone.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmmu.h,v 1.20 2007/12/15 19:33:32 miod Exp $ */
d50 1
d83 1
d87 1
a87 1
 * dma_cachectl() modes
d89 5
a93 3
#define DMA_CACHE_SYNC		0
#define DMA_CACHE_SYNC_INVAL	1
#define DMA_CACHE_INV		2
@


1.20
log
@Move the cmmu lock back from 8820x-specific code to global, and use it on
MVME197DP to serialize 88410 operations.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmmu.h,v 1.19 2007/11/22 05:47:45 miod Exp $ */
d48 1
a48 2
	void (*dma_cachectl)(pmap_t, vaddr_t, vsize_t, int);
	void (*dma_cachectl_pa)(paddr_t, psize_t, int);
d81 1
a81 2
#define	dma_cachectl(a, b, c, d)	(cmmu->dma_cachectl)(a, b, c, d)
#define	dma_cachectl_pa(a, b, c)	(cmmu->dma_cachectl_pa)(a, b, c)
@


1.19
log
@Remove the cpu parameter from cmmu_set_sapr(), since it is only invoked
for the current processor. And remove now unused cmmu_flush_data_page().
@
text
@d1 1
a1 1
/*	$OpenBSD: cmmu.h,v 1.18 2007/11/22 05:42:48 miod Exp $ */
d56 15
@


1.18
log
@Move the cmmu lock to 88200-specific code. 88110 MP code will use ipis
and will not require such a lock.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmmu.h,v 1.17 2007/02/11 12:49:35 miod Exp $ */
d43 1
a43 1
	void (*set_sapr)(cpuid_t, apr_t);
a47 1
	void (*flush_data_page)(cpuid_t, paddr_t);
d62 1
a62 1
#define	cmmu_set_sapr(a, b)		(cmmu->set_sapr)(a, b)
a66 1
#define	cmmu_flush_data_page(a, b)	(cmmu->flush_data_page)(a, b)
@


1.17
log
@Rework the cache handling routines again. We now try to operate on the exact
address range we've been given, rounded to cache line boundaries, instead
of being lazy and operating on pages as soon as the range was large enough.

Also, since the ranges we'll be invoked for are reasonably small, it does
not make sense to check for segment sizes - we're always smaller, really.

While there, hardcode the size in cmmu_flush_data_cache(), which becomes
cmmu_flush_data_page(), since it was always invoked for complete pages.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmmu.h,v 1.16 2005/12/11 21:45:28 miod Exp $ */
a34 19

#ifdef MULTIPROCESSOR
/*
 * This lock protects the cmmu SAR and SCR's; other ports
 * can be accessed without locking it.
 *
 * May be used from "db_interface.c".
 */
extern __cpu_simple_lock_t cmmu_cpu_lock;

#define CMMU_LOCK   __cpu_simple_lock(&cmmu_cpu_lock)
#define CMMU_UNLOCK __cpu_simple_unlock(&cmmu_cpu_lock)

#else

#define	CMMU_LOCK	do { /* nothing */ } while (0)
#define	CMMU_UNLOCK	do { /* nothing */ } while (0)

#endif	/* MULTIPROCESSOR */
@


1.16
log
@Work in progress SMP code; mvme88k boards can spin up secondary CPUs,
kernel boots single user. Still a lot of polishing and bugfixing to do.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmmu.h,v 1.15 2005/12/04 15:00:25 miod Exp $ */
d67 3
a69 3
	void (*flush_data_cache)(cpuid_t, paddr_t, psize_t);
	int (*dma_cachectl)(pmap_t, vaddr_t, vsize_t, int);
	int (*dma_cachectl_pa)(paddr_t, psize_t, int);
d87 1
a87 1
#define	cmmu_flush_data_cache(a, b, c)	(cmmu->flush_data_cache)(a, b, c)
@


1.15
log
@Let cmmu_init() now return the cpuid of the master cpu.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmmu.h,v 1.14 2005/12/04 12:20:19 miod Exp $ */
d70 3
d90 1
@


1.14
log
@Slight cmmu code cleanup; use shorter function names, remove parity_enable
and the DDB and DEBUG helpers which are of questionable usefulness, some
stylistic changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmmu.h,v 1.13 2005/12/03 19:06:08 miod Exp $ */
d57 1
a57 1
	void (*init)(void);
d60 1
a60 1
	void (*shutdown_now)(void);
a71 1
/* THE pointer! */
a73 1
/* The macros... */
d77 1
a77 1
#define	cmmu_shutdown_now		(cmmu->shutdown_now)
a86 4
#define	cmmu_dump_config		(cmmu->dump_config)
#define	cmmu_show_translation(a, b, c, d) \
	(cmmu->show_translation)(a, b, c, d)
#define show_apr(ap)			(cmmu->show_apr)(ap)
@


1.13
log
@Replace simplelocks with __cpu_simple_locks for cmmu and pmap locking,
for the MULTIPROCESSOR case.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmmu.h,v 1.12 2005/12/03 14:30:05 miod Exp $ */
d57 13
a69 19
	void (*cmmu_init_func)(void);
	void (*setup_board_config_func)(void);
	void (*cpu_configuration_print_func)(int);
	void (*cmmu_shutdown_now_func)(void);
	void (*cmmu_parity_enable_func)(void);
	cpuid_t (*cmmu_cpu_number_func)(void);
	void (*cmmu_set_sapr_func)(cpuid_t, apr_t);
	void (*cmmu_set_uapr_func)(apr_t);
	void (*cmmu_flush_tlb_func)(cpuid_t, unsigned, vaddr_t, u_int);
	void (*cmmu_flush_cache_func)(cpuid_t, paddr_t, psize_t);
	void (*cmmu_flush_inst_cache_func)(cpuid_t, paddr_t, psize_t);
	void (*cmmu_flush_data_cache_func)(cpuid_t, paddr_t, psize_t);
	int (*dma_cachectl_func)(pmap_t, vaddr_t, vsize_t, int);
	int (*dma_cachectl_pa_func)(paddr_t, psize_t, int);
	/* DDB only */
	void (*cmmu_dump_config_func)(void);
	void (*cmmu_show_translation_func)(unsigned, unsigned, unsigned, int);
	/* DEBUG only */
	void (*show_apr_func)(apr_t);
d76 17
a92 17
#define cmmu_init		(cmmu->cmmu_init_func)
#define setup_board_config	(cmmu->setup_board_config_func)
#define	cpu_configuration_print(a)	(cmmu->cpu_configuration_print_func)(a)
#define	cmmu_shutdown_now	(cmmu->cmmu_shutdown_now_func)
#define	cmmu_parity_enable	(cmmu->cmmu_parity_enable_func)
#define	cmmu_cpu_number		(cmmu->cmmu_cpu_number_func)
#define	cmmu_set_sapr(a, b)	(cmmu->cmmu_set_sapr_func)(a, b)
#define	cmmu_set_uapr(a)	(cmmu->cmmu_set_uapr_func)(a)
#define	cmmu_flush_tlb(a, b, c, d) 	(cmmu->cmmu_flush_tlb_func)(a, b, c, d)
#define	cmmu_flush_cache(a, b, c)	(cmmu->cmmu_flush_cache_func)(a, b, c)
#define	cmmu_flush_inst_cache(a, b, c)	(cmmu->cmmu_flush_inst_cache_func)(a, b, c)
#define	cmmu_flush_data_cache(a, b, c)	(cmmu->cmmu_flush_data_cache_func)(a, b, c)
#define	dma_cachectl(a, b, c, d)	(cmmu->dma_cachectl_func)(a, b, c, d)
#define	dma_cachectl_pa(a, b, c)	(cmmu->dma_cachectl_pa_func)(a, b, c)
#define	cmmu_dump_config	(cmmu->cmmu_dump_config_func)
#define	cmmu_show_translation(a, b, c, d)	(cmmu->cmmu_show_translation_func)(a, b, c, d)
#define show_apr(ap)		(cmmu->show_apr_func)(ap)
d95 1
a95 1
 * dma_cachectl modes
@


1.12
log
@Switch m88k ports to __HAVE_CPUINFO. Current cpu pointer is held in SR0
on all running processors.
Tested aoyama@@ and I
@
text
@d1 1
a1 1
/*	$OpenBSD: cmmu.h,v 1.11 2005/12/02 21:16:45 miod Exp $ */
d36 1
d43 1
a43 1
extern struct simplelock cmmu_cpu_lock;
d45 9
a53 2
#define CMMU_LOCK   simple_lock(&cmmu_cpu_lock)
#define CMMU_UNLOCK simple_unlock(&cmmu_cpu_lock)
@


1.11
log
@Better choice of types for struct pmap members and cmmu functions;
no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmmu.h,v 1.10 2005/11/25 22:17:14 miod Exp $ */
a30 1
#if defined(_KERNEL) && !defined(_LOCORE)
d34 1
a34 3
extern unsigned cpu_sets[MAX_CPUS];
extern unsigned master_cpu;
extern int max_cpus;
@


1.10
log
@Let the cache synchronization and invalidation functions report whether
they caused the entire cache to be processed.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmmu.h,v 1.9 2005/09/25 20:55:13 miod Exp $ */
d57 7
a63 7
	unsigned (*cmmu_cpu_number_func)(void);
	void (*cmmu_set_sapr_func)(unsigned, unsigned);
	void (*cmmu_set_uapr_func)(unsigned);
	void (*cmmu_flush_tlb_func)(unsigned, unsigned, vaddr_t, u_int);
	void (*cmmu_flush_cache_func)(int, paddr_t, psize_t);
	void (*cmmu_flush_inst_cache_func)(int, paddr_t, psize_t);
	void (*cmmu_flush_data_cache_func)(int, paddr_t, psize_t);
d70 1
a70 1
	void (*show_apr_func)(unsigned);
@


1.9
log
@Change the size parameter of cmmu_flush_tlb() from bytes to pages. This makes
things easier for the callers, and allows us to inline the "fewer than 4 pages"
situation for speed.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmmu.h,v 1.8 2005/04/27 14:09:45 miod Exp $ */
d64 2
a65 2
	void (*dma_cachectl_func)(pmap_t, vaddr_t, vsize_t, int);
	void (*dma_cachectl_pa_func)(paddr_t, psize_t, int);
@


1.8
log
@Allow userland to cause the data cache to be flushed for any arbitrary address
range in the current process, using trap #451.

This is necessary for proper gcc trampolines operation, and, later, ld.so...
@
text
@d1 1
a1 1
/*	$OpenBSD: cmmu.h,v 1.7 2005/04/27 14:07:09 miod Exp $ */
d60 1
a60 1
	void (*cmmu_flush_tlb_func)(unsigned, unsigned, vaddr_t, vsize_t);
@


1.7
log
@Move constants for dma_cachectl() to cmmu.h where they belong.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmmu.h,v 1.6 2005/03/28 12:42:44 miod Exp $ */
d64 1
a64 1
	void (*dma_cachectl_func)(vaddr_t, vsize_t, int);
d89 1
a89 1
#define	dma_cachectl(a, b, c)	(cmmu->dma_cachectl_func)(a, b, c)
@


1.6
log
@Relax dependencies.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmmu.h,v 1.5 2004/08/06 13:23:49 miod Exp $ */
d41 1
a41 1
 * can be accessed without locking it
d94 7
@


1.5
log
@Merge Luna88k and mvme88k M88200 management code. Features:
- simpler structures (no more redundant or easily computable information).
- split scheme configuration (for 4:1 and 8:1 designs) is only compiled in
  if necessary (read: only on a mvme88k kernel configured for MVME188 support),
  which speeds up CMMU operations on the Luna88k.
- will not enable bus snopping on a monoprocessor system.

Tested on Luna88k-2, MVME187 and various MVME188 by aoyama@@ and I.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmmu.h,v 1.4 2004/08/04 15:54:37 miod Exp $ */
a29 2

#include <machine/mmu.h>
@


1.4
log
@Completely remove BATC code. BATC on 88200 are way too small to be worth
using as part of the general pmap machinery (though they might come back
at some point to speed up I/O mappings), and we don't use the 88110 BATC
yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmmu.h,v 1.3 2004/08/02 08:34:59 miod Exp $ */
d39 1
a39 1
extern int max_cpus, max_cmmus;
@


1.3
log
@More include files cleaning:
- move MAX_CPUS constant to <machine/cpu.h>
- do not include <machine/board.h> unless needed. In fact, remove this file
  entirely on mvme88k, and include <machine/mvme*.h> on a
  compiling-for-this-board basis
- keep MAX_CMMUS constant private to the m8820x code
@
text
@d1 1
a1 1
/*	$OpenBSD: cmmu.h,v 1.2 2004/05/07 18:06:39 miod Exp $ */
a61 1
	void (*cmmu_set_pair_batc_entry_func)(unsigned, unsigned, unsigned);
a62 2
	void (*cmmu_pmap_activate_func)(unsigned, unsigned,
	    u_int32_t i_batc[BATC_MAX], u_int32_t d_batc[BATC_MAX]);
a86 1
#define	cmmu_set_pair_batc_entry(a, b, c)	(cmmu->cmmu_set_pair_batc_entry_func)(a, b, c)
a87 1
#define	cmmu_pmap_activate(a, b, c, d) 	(cmmu->cmmu_pmap_activate_func)(a, b, c, d)
@


1.2
log
@Introduce a new cmmu operation, cachectl_pa, similar to cachectl, but taking
a pa instead of a pmap_kernel va. The cachectl operation is now deprecated and
will disappear soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmmu.h,v 1.1 2004/04/26 12:34:05 miod Exp $ */
d28 2
a29 2
#ifndef	_MACHINE_CMMU_H_
#define	_MACHINE_CMMU_H_
d33 1
a33 1
#ifndef	_LOCORE
d102 1
a102 1
#endif	/* _LOCORE */
d104 1
a104 1
#endif	/* _MACHINE_CMMU_H_ */
@


1.2.2.1
log
@Merge with the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
@


1.1
log
@Start factorizing luna88k and mvme88k common parts.
For now, include files only.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmmu.h,v 1.18 2004/01/20 14:35:52 miod Exp $ */
d70 1
d97 1
a104 1

@

