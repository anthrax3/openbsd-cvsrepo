head	1.65;
access;
symbols
	OPENBSD_6_2:1.65.0.6
	OPENBSD_6_2_BASE:1.65
	OPENBSD_6_1:1.65.0.4
	OPENBSD_6_1_BASE:1.65
	OPENBSD_6_0:1.64.0.6
	OPENBSD_6_0_BASE:1.64
	OPENBSD_5_9:1.64.0.2
	OPENBSD_5_9_BASE:1.64
	OPENBSD_5_8:1.64.0.4
	OPENBSD_5_8_BASE:1.64
	OPENBSD_5_7:1.63.0.2
	OPENBSD_5_7_BASE:1.63
	OPENBSD_5_6:1.62.0.4
	OPENBSD_5_6_BASE:1.62
	OPENBSD_5_5:1.60.0.6
	OPENBSD_5_5_BASE:1.60
	OPENBSD_5_4:1.60.0.2
	OPENBSD_5_4_BASE:1.60
	OPENBSD_5_3:1.58.0.2
	OPENBSD_5_3_BASE:1.58
	OPENBSD_5_2:1.54.0.4
	OPENBSD_5_2_BASE:1.54
	OPENBSD_5_1_BASE:1.54
	OPENBSD_5_1:1.54.0.2
	OPENBSD_5_0:1.53.0.2
	OPENBSD_5_0_BASE:1.53
	OPENBSD_4_9:1.52.0.2
	OPENBSD_4_9_BASE:1.52
	OPENBSD_4_8:1.49.0.6
	OPENBSD_4_8_BASE:1.49
	OPENBSD_4_7:1.49.0.2
	OPENBSD_4_7_BASE:1.49
	OPENBSD_4_6:1.49.0.4
	OPENBSD_4_6_BASE:1.49
	OPENBSD_4_5:1.44.0.4
	OPENBSD_4_5_BASE:1.44
	OPENBSD_4_4:1.35.0.2
	OPENBSD_4_4_BASE:1.35
	OPENBSD_4_3:1.34.0.2
	OPENBSD_4_3_BASE:1.34
	OPENBSD_4_2:1.22.0.2
	OPENBSD_4_2_BASE:1.22
	OPENBSD_4_1:1.18.0.2
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.15.0.2
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.12.0.2
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.5.0.4
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.2
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	SMP_SYNC_A:1.1
	SMP_SYNC_B:1.1
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.65
date	2017.03.19.10.57.29;	author miod;	state Exp;
branches;
next	1.64;
commitid	VsXOX1rAnPUup9UH;

1.64
date	2015.07.02.01.33.59;	author dlg;	state Exp;
branches;
next	1.63;
commitid	HBmwORlhlW47BLMN;

1.63
date	2015.02.11.07.05.39;	author dlg;	state Exp;
branches;
next	1.62;
commitid	JTpbkhDknrIuy9pn;

1.62
date	2014.07.11.10.53.07;	author uebayasi;	state Exp;
branches;
next	1.61;
commitid	CaCLs5fTSVpJlqFi;

1.61
date	2014.03.29.18.09.29;	author guenther;	state Exp;
branches;
next	1.60;

1.60
date	2013.05.31.17.00.58;	author tedu;	state Exp;
branches;
next	1.59;

1.59
date	2013.03.12.09.37.16;	author mpi;	state Exp;
branches;
next	1.58;

1.58
date	2013.02.12.08.06.22;	author mpi;	state Exp;
branches;
next	1.57;

1.57
date	2013.02.11.17.05.25;	author mpi;	state Exp;
branches;
next	1.56;

1.56
date	2013.01.05.11.20.56;	author miod;	state Exp;
branches;
next	1.55;

1.55
date	2012.12.02.07.03.31;	author guenther;	state Exp;
branches;
next	1.54;

1.54
date	2011.10.25.18.38.06;	author miod;	state Exp;
branches;
next	1.53;

1.53
date	2011.03.23.16.54.35;	author pirofti;	state Exp;
branches;
next	1.52;

1.52
date	2011.01.05.22.16.14;	author miod;	state Exp;
branches;
next	1.51;

1.51
date	2010.12.23.20.05.08;	author miod;	state Exp;
branches;
next	1.50;

1.50
date	2010.09.28.20.27.55;	author miod;	state Exp;
branches;
next	1.49;

1.49
date	2009.05.02.14.32.27;	author miod;	state Exp;
branches;
next	1.48;

1.48
date	2009.04.19.17.56.13;	author miod;	state Exp;
branches;
next	1.47;

1.47
date	2009.03.26.17.24.33;	author oga;	state Exp;
branches;
next	1.46;

1.46
date	2009.03.15.20.39.53;	author miod;	state Exp;
branches;
next	1.45;

1.45
date	2009.03.04.19.39.02;	author miod;	state Exp;
branches;
next	1.44;

1.44
date	2009.02.21.18.37.47;	author miod;	state Exp;
branches;
next	1.43;

1.43
date	2009.02.21.18.35.20;	author miod;	state Exp;
branches;
next	1.42;

1.42
date	2009.02.17.21.03.59;	author miod;	state Exp;
branches;
next	1.41;

1.41
date	2009.02.16.23.03.31;	author miod;	state Exp;
branches;
next	1.40;

1.40
date	2009.02.08.21.40.56;	author miod;	state Exp;
branches;
next	1.39;

1.39
date	2008.12.21.21.43.51;	author miod;	state Exp;
branches;
next	1.38;

1.38
date	2008.10.15.23.23.48;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2008.10.10.08.36.28;	author art;	state Exp;
branches;
next	1.36;

1.36
date	2008.10.10.08.05.45;	author art;	state Exp;
branches;
next	1.35;

1.35
date	2008.07.18.23.43.31;	author art;	state Exp;
branches;
next	1.34;

1.34
date	2008.01.13.20.20.29;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2007.12.15.19.34.33;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2007.12.04.23.45.51;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2007.11.15.21.23.16;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2007.11.14.23.12.45;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2007.11.06.21.48.42;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2007.11.06.21.42.56;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2007.10.29.19.57.46;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2007.10.24.20.53.59;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2007.10.16.04.57.37;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2007.10.13.12.54.43;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2007.10.10.15.53.52;	author art;	state Exp;
branches;
next	1.22;

1.22
date	2007.05.19.20.34.32;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2007.05.14.17.00.38;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2007.04.18.21.21.19;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2007.03.15.10.22.29;	author art;	state Exp;
branches;
next	1.18;

1.18
date	2007.01.12.21.41.53;	author aoyama;	state Exp;
branches;
next	1.17;

1.17
date	2006.12.24.20.30.35;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2006.11.29.12.26.13;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2006.05.08.14.36.09;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2006.04.17.16.08.01;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2006.04.15.15.43.36;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2005.12.11.21.45.28;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2005.12.11.21.36.06;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2005.12.03.14.30.05;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2005.11.28.22.22.51;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2005.11.28.22.21.15;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2005.10.13.19.48.32;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2005.10.12.19.05.43;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2004.11.08.16.39.31;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2004.08.02.08.34.59;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2004.07.24.15.05.05;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.13.21.49.17;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	2004.04.26.12.34.05;	author miod;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2004.06.05.23.09.47;	author niklas;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2004.06.06.05.23.39;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.65
log
@Put the address of the per-cpu clock and interrupt registers into the cpu_info
struct, rather than fetching them from arrays every time they are needed.

ok aoyama@@
@
text
@/*	$OpenBSD: cpu.h,v 1.64 2015/07/02 01:33:59 dlg Exp $ */
/*
 * Copyright (c) 1996 Nivas Madhur
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
 *
 * All advertising materials mentioning features or use of this software
 * must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Lawrence Berkeley Laboratory.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#ifndef _M88K_CPU_H_
#define _M88K_CPU_H_

/*
 * CTL_MACHDEP definitions.
 */
#define	CPU_CONSDEV	1	/* dev_t: console terminal device */
#define	CPU_CPUTYPE	2	/* int: cpu type */
#define	CPU_MAXID	3	/* number of valid machdep ids */

#define	CTL_MACHDEP_NAMES { \
	{ 0, 0 }, \
	{ "console_device", CTLTYPE_STRUCT }, \
	{ "cputype", CTLTYPE_INT }, \
}

#ifdef _KERNEL

#include <machine/atomic.h>
#include <machine/pcb.h>
#include <machine/psl.h>
#include <machine/intr.h>
#include <sys/queue.h>
#include <sys/sched.h>

#if defined(MULTIPROCESSOR)
#if !defined(MAX_CPUS) || MAX_CPUS > 4
#undef	MAX_CPUS
#define	MAX_CPUS	4
#endif
#else
#if !defined(MAX_CPUS)
#undef	MAX_CPUS
#define	MAX_CPUS	1
#endif
#endif

#ifndef _LOCORE

#include <machine/lock.h>

/*
 * Per-CPU data structure
 */

struct pmap;

struct cpu_info {
	u_int		 ci_flags;
#define	CIF_ALIVE		0x01		/* cpu initialized */
#define	CIF_PRIMARY		0x02		/* primary cpu */

	struct proc	*ci_curproc;		/* current process... */
	struct pcb	*ci_curpcb;		/* ...its pcb... */
	struct pmap	*ci_curpmap;		/* ...and its pmap */

	u_int		 ci_cpuid;		/* cpu number */

#if defined(MULTIPROCESSOR)
	struct srp_hazard ci_srp_hazards[SRP_HAZARD_NUM];
#endif

	/*
	 * Function pointers used within mplock to ensure
	 * non-interruptability.
	 */
	uint32_t	(*ci_mp_atomic_begin)
			    (__cpu_simple_lock_t *lock, uint *csr);
	void		(*ci_mp_atomic_end)
			    (uint32_t psr, __cpu_simple_lock_t *lock, uint csr);

	/*
	 * Other processor-dependent routines
	 */
	void		(*ci_zeropage)(vaddr_t);
	void		(*ci_copypage)(vaddr_t, vaddr_t);

	/*
	 * The following fields are used differently depending on
	 * the processor type.  Think of them as an anonymous union
	 * of two anonymous structs.
	 */
	u_int		 ci_cpudep0;
	u_int		 ci_cpudep1;
	u_int		 ci_cpudep2;
	u_int		 ci_cpudep3;
	u_int		 ci_cpudep4;
	u_int		 ci_cpudep5;
	u_int		 ci_cpudep6;
	u_int		 ci_cpudep7;

	/* 88100 fields */
#define	ci_pfsr_i0	 ci_cpudep0		/* instruction... */
#define	ci_pfsr_i1	 ci_cpudep1
#define	ci_pfsr_d0	 ci_cpudep2		/* ...and data CMMU PFSRs */
#define	ci_pfsr_d1	 ci_cpudep3

	/* 88110 fields */
#define	ci_ipi_arg1	 ci_cpudep0		/* Complex IPI arguments */
#define	ci_ipi_arg2	 ci_cpudep1
#define	ci_h_sxip	 ci_cpudep2		/* trapframe values */
#define	ci_h_epsr	 ci_cpudep3		/* for hardclock */
#define	ci_s_sxip	 ci_cpudep4		/* and softclock */
#define	ci_s_epsr	 ci_cpudep5

	struct schedstate_percpu
			 ci_schedstate;		/* scheduling state */
	int		 ci_want_resched;	/* need_resched() invoked */

	u_int		 ci_intrdepth;		/* interrupt depth */

	int		 ci_ddb_state;		/* ddb status */
#define	CI_DDB_RUNNING	0
#define	CI_DDB_ENTERDDB	1
#define	CI_DDB_INDDB	2
#define	CI_DDB_PAUSE	3

	u_int32_t	 ci_randseed;		/* per-cpu random seed */

	int		 ci_ipi;		/* pending ipis */
#define	CI_IPI_NOTIFY		0x00000001
#define	CI_IPI_HARDCLOCK	0x00000002
#define	CI_IPI_STATCLOCK	0x00000004
#define	CI_IPI_DDB		0x00000008
/* 88110 simple ipi */
#define	CI_IPI_TLB_FLUSH_KERNEL	0x00000010
#define	CI_IPI_TLB_FLUSH_USER	0x00000020
/* 88110 complex ipi */
#define	CI_IPI_CACHE_FLUSH	0x00000040
#define	CI_IPI_ICACHE_FLUSH	0x00000080
#define	CI_IPI_DMA_CACHECTL	0x00000100
	void		(*ci_softipi_cb)(void);	/* 88110 softipi callback */

#ifdef DIAGNOSTIC
	int	ci_mutex_level;
#endif
#ifdef GPROF
	struct gmonparam *ci_gmon;
#endif
};

extern cpuid_t master_cpu;
extern struct cpu_info m88k_cpus[MAX_CPUS];

#define	CPU_INFO_ITERATOR	cpuid_t
#define	CPU_INFO_FOREACH(cii, ci) \
	for ((cii) = 0; (cii) < MAX_CPUS; (cii)++) \
		if (((ci) = &m88k_cpus[cii])->ci_flags & CIF_ALIVE)
#define	CPU_INFO_UNIT(ci)	((ci)->ci_cpuid)
#define MAXCPUS	MAX_CPUS

#if defined(MULTIPROCESSOR)

static __inline__ struct cpu_info *
curcpu(void)
{
	struct cpu_info *cpuptr;

	__asm__ volatile ("ldcr %0, %%cr17" : "=r" (cpuptr));
	return cpuptr;
}

#define	CPU_IS_PRIMARY(ci)	((ci)->ci_flags & CIF_PRIMARY)

void	cpu_boot_secondary_processors(void);
__dead void cpu_emergency_disable(void);
void	cpu_unidle(struct cpu_info *);
void	m88k_send_ipi(int, cpuid_t);
void	m88k_broadcast_ipi(int);

#else	/* MULTIPROCESSOR */

#define	curcpu()	(&m88k_cpus[0])
#define	cpu_unidle(ci)	do { /* nothing */ } while (0)
#define	CPU_IS_PRIMARY(ci)	1

#endif	/* MULTIPROCESSOR */

#define CPU_BUSY_CYCLE()	do {} while (0)

struct cpu_info *set_cpu_number(cpuid_t);

/*
 * The md code may hardcode this in some very specific situations.
 */
#if !defined(cpu_number)
#define	cpu_number()		curcpu()->ci_cpuid
#endif

#define	curpcb			curcpu()->ci_curpcb

#endif /* _LOCORE */

/*
 * definitions of cpu-dependent requirements
 * referenced in generic code
 */
#define	cpu_exec(p)		do { /* nothing */ } while (0)

#define	cpu_idle_enter()	do { /* nothing */ } while (0)
#define	cpu_idle_cycle()	do { /* nothing */ } while (0)
#define	cpu_idle_leave()	do { /* nothing */ } while (0)

#if defined(MULTIPROCESSOR)
#include <sys/mplock.h>
#endif

/*
 * Arguments to hardclock and gatherstats encapsulate the previous
 * machine state in an opaque clockframe. CLKF_INTR is only valid
 * if the process is in kernel mode. Clockframe is really trapframe,
 * so pointer to clockframe can be safely cast into a pointer to
 * trapframe.
 */
struct clockframe {
	struct trapframe tf;
};

#define	CLKF_USERMODE(framep)	(((framep)->tf.tf_epsr & PSR_MODE) == 0)
#define	CLKF_PC(framep)		((framep)->tf.tf_sxip & XIP_ADDR)
#define	CLKF_INTR(framep) \
	(((struct cpu_info *)(framep)->tf.tf_cpu)->ci_intrdepth > 1)

#define	aston(p)		((p)->p_md.md_astpending = 1)

/*
 * This is used during profiling to integrate system time.
 */
#define	PC_REGS(regs)							\
	(CPU_IS88110 ? ((regs)->exip & XIP_ADDR) :			\
	 ((regs)->sxip & XIP_V ? (regs)->sxip & XIP_ADDR :		\
	  ((regs)->snip & NIP_V ? (regs)->snip & NIP_ADDR :		\
				   (regs)->sfip & FIP_ADDR)))
#define	PROC_PC(p)	PC_REGS((struct reg *)((p)->p_md.md_tf))
#define	PROC_STACK(p)	((p)->p_md.md_tf->tf_sp)

#define clear_resched(ci) 	(ci)->ci_want_resched = 0

/*
 * Give a profiling tick to the current process when the user profiling
 * buffer pages are invalid.  On the m88k, request an ast to send us
 * through trap(), marking the proc as needing a profiling tick.
 */
#define	need_proftick(p)	aston(p)

void	need_resched(struct cpu_info *);
void	signotify(struct proc *);
void	softipi(void);

int	badaddr(vaddr_t addr, int size);
void	set_vbr(register_t);
extern register_t kernel_vbr;

#endif /* _KERNEL */
#endif /* _M88K_CPU_H_ */
@


1.64
log
@introduce srp, which according to the manpage i wrote is short for
"shared reference pointers".

srp allows concurrent access to a data structure by multiple cpus
while avoiding interlocking cpu opcodes. it manages its own reference
counts and the garbage collection of those data structure to avoid
use after frees.

internally srp is a twisted version of hazard pointers, which are
a relative of RCU.

jmatthew wrote the bulk of a hazard pointer implementation and
changed bpf to use it to allow mpsafe access to bpfilters. however,
at s2k15 we were trying to apply it to other data structures but
the memory overhead of every hazard pointer would have blown out
significantly in several uses cases. a bulk of our time at s2k15
was spent reworking hazard pointers into srp.

this diff adds the srp api and adds the necessary metadata to struct
cpuinfo on our MP architectures. srp on uniprocessor platforms has
alternate code that is optimised because it knows there'll be no
concurrent access to data by multiple cpus.

srp is made available to the system via param.h, so it should be
available everywhere in the kernel.

the docs likely need improvement cos im too close to the implementation.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.63 2015/02/11 07:05:39 dlg Exp $ */
d221 1
a221 1
void	set_cpu_number(cpuid_t);
@


1.63
log
@no md code wants lockmgr locks, so no md code needs to include sys/lock.h

with and ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.62 2014/07/11 10:53:07 uebayasi Exp $ */
d98 4
@


1.62
log
@CPU_BUSY_CYCLE(): A new MI statement for busy loop power reduction

The new CPU_BUSY_CYCLE() may be put in a busy loop body so that CPU can reduce
power consumption, as Linux's cpu_relax() and FreeBSD's cpu_spinwait().  To
start minimally, use PAUSE on i386/amd64 and empty on others.  The name is
chosen following the existing cpu_idle_*() functions.  Naming and API may be
polished later.

OK kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a240 1
#include <sys/lock.h>
@


1.61
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.60 2013/05/31 17:00:58 tedu Exp $ */
d214 2
@


1.60
log
@remove counters for simplelocks
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.59 2013/03/12 09:37:16 mpi Exp $ */
d195 1
a195 1
	__asm__ __volatile__ ("ldcr %0, %%cr17" : "=r" (cpuptr));
@


1.59
log
@Fix kernel profiling on MP systems by using per-CPU buffers and teach
kgmon(8) to deal with them, this time without public header changes.

Previously various CPUs were iterating over the same global buffer at
the same time to modify it and never ended.

This diff includes some ideas submited by Thor Simon to NetBSD via miod@@.

ok deraadt@@, mikeb@@, haesbaert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.58 2013/02/12 08:06:22 mpi Exp $ */
a146 2

	u_long		 ci_spin_locks;		/* spin locks counter */
@


1.58
log
@Back out per-CPU kernel profiling, it shouldn't modify a public header
at this moment.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.57 2013/02/11 17:05:25 mpi Exp $ */
d174 3
@


1.57
log
@Fix kernel profiling on MP systems by using per-CPU buffer. Previously
various CPUs were iterating over the same global buffer at the same
time to modify it and never ended.

This diff includes some ideas submited by Thor Simon to NetBSD via miod@@.

ok mikeb@@, haesbaert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.56 2013/01/05 11:20:56 miod Exp $ */
a173 3
#endif
#ifdef GPROF
	struct gmonparam *ci_gmon;
@


1.56
log
@Switch m88k ports to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.55 2012/12/02 07:03:31 guenther Exp $ */
d174 3
@


1.55
log
@Determine whether we're currently on the alternative signal stack
dynamically, by comparing the stack pointer against the altstack
base and size, so that you get the correct answer if you longjmp
out of the signal handler, as tested by regress/sys/kern/stackjmp/.
Also, fix alt stack handling on vax, where it was completely broken.

Testing and corrections by miod@@, krw@@, tobiasu@@, pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.54 2011/10/25 18:38:06 miod Exp $ */
d194 1
a194 1
	__asm__ __volatile__ ("ldcr %0, cr17" : "=r" (cpuptr));
@


1.54
log
@Replace the naive 88110 tlb update code, which would always invalidate the
whole tlb (32 of 'em), with smarter `tlb probe and update with new pte if tlb
match found' code. This makes the 88110-specific pmap_update() unnecessary, as
updates are no longer aggregated to avoid the number of flushes. This also
makes tlb handling similar between 88100 and 88110, from the pmap's point of
view, so there is no need to use different routines.

No impact on 88100, no user-noticeable performance change on 88100 GENERIC,
slight improvement on 88110 GENERIC.MP.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.53 2011/03/23 16:54:35 pirofti Exp $ */
d269 1
@


1.53
log
@Normalize sentinel. Use _MACHINE_*_H_ and _<ARCH>_*_H_ properly and consitently.

Discussed and okay drahn@@. Okay deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.52 2011/01/05 22:16:14 miod Exp $ */
a140 1
#define	ci_pmap_ipi	 ci_cpudep6		/* delayed pmap tlb ipi */
@


1.52
log
@Make copypage() and zeropage() per-cpu function pointers, and use a
different version on 88110, which does load allocate of
to-be-completely-overwritten cache lines.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.51 2010/12/23 20:05:08 miod Exp $ */
d41 2
a42 2
#ifndef __M88K_CPU_H__
#define __M88K_CPU_H__
d289 1
a289 1
#endif /* __M88K_CPU_H__ */
@


1.51
log
@The exception vector page on m88k systems has always been the same page as
the one used by the firmware, which (at least on mvme88k) is at address zero.

This is unfortunate, since this means that NULL pointer dereferences in the
kernel are not caught, and writes cause havoc.

This behaviour was necessary to be able to use the PROM system call interface
during early bootstrap, without having to disassemble the VBR page and
update branches - which use pc-relative displacement - if we were to use
a different VBR address.

On mvme88k, change this and actually set up two VBR pages: one, over the PROM
page (except for the system call vectors), and another one in the kernel
image (which will be mapped read-only). We'll run with the PROM page until
the end of autoconf, and then switch to the kernel one, and unmap all the
PROM below it.

As a bonus, the final kernel page can use optimized data access fault
handlers, which do not have to check for faults caused by badaddr(), since
badaddr() is only used during device probe on buses which do not support
hotplug.

There are a few infrastructure collateral damage on aviion and luna88k, but
these ports do not change their behaviour yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.50 2010/09/28 20:27:55 miod Exp $ */
d107 6
@


1.50
log
@Implement a per-cpu held mutex counter if DIAGNOSTIC on all non-x86 platforms,
to complete matthew@@'s commit of a few days ago, and drop __HAVE_CPU_MUTEX_LEVEL
define. With help from, and ok deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.49 2009/05/02 14:32:27 miod Exp $ */
d279 2
@


1.49
log
@Drop the pm_cpus bitmask field from struct pmap, and instead remember the
currently active userland pmap in each processors struct cpu_info.

This thus skips the complete tlb flush if idle switches back to
the proc previously running on this processor.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.48 2009/04/19 17:56:13 miod Exp $ */
d166 4
@


1.48
log
@Rename max_cpus to ncpusfound and compute it regardless of option
MULTIPROCESSOR.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.47 2009/03/26 17:24:33 oga Exp $ */
d86 2
d94 2
a95 1
	struct pcb	*ci_curpcb;		/* ...and its pcb */
@


1.47
log
@Remove cpu_wait(). It's original use was to be called from the reaper so
MD code would free resources that couldn't be freed until we were no
longer running in that processor. However, it's is unused on all
architectures since mikeb@@'s tss changes on x86 earlier in the year.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.46 2009/03/15 20:39:53 miod Exp $ */
a78 2

extern u_int max_cpus;
@


1.46
log
@Generic softinterrupt support for m88k based platforms, adapted from arm
with different locking mechanism. 88110 soft ipi are replaced with an
ipi callback which is checked upon return from exception (it can not be kept
as a softintr, as the generic softinterrupt code doesn't have per-cpu
pending softintr queues).
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.45 2009/03/04 19:39:02 miod Exp $ */
a221 1
#define	cpu_wait(p)		do { /* nothing */ } while (0)
@


1.45
log
@Since 88110 processors can not flush individual TLB entries, instead of
flushing the whole TLB block every time a pte is modified, store a bitmask
of pending flushes and do them at pmap_update() time. 88100 behaviour is
unchanged.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.44 2009/02/21 18:37:47 miod Exp $ */
a149 1
	int		 ci_softintr;		/* pending soft interrupts */
d164 1
a247 14

/*
 * Get interrupt glue.
 */
#include <machine/intr.h>

#define SIR_NET		0x01
#define SIR_CLOCK	0x02
#define	SIR_IPI		0x04

#define setsoftint(ci,x)	atomic_setbits_int(&ci->ci_softintr, x)
#define setsoftnet()		setsoftint(curcpu(), SIR_NET)
#define setsoftclock()		setsoftint(curcpu(), SIR_CLOCK)
#define	setsoftipi(ci)		setsoftint(ci, SIR_IPI)
@


1.44
log
@Move part of the mp lock logic into per-cpu callbacks; on MVME197DP we need
to disable NMI sources in addition to interrupt sources, and we can not
use a quick sequence with shadowing frozen as done for atomic ops.

This lets GENERIC.MP boot multiuser on MVME197DP boards, and is so far stable
enough to be able to recompile a kernel from scratch (with make -j2).
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.43 2009/02/21 18:35:20 miod Exp $ */
d118 2
d134 1
@


1.43
log
@Get rid of 88110 nmi stacks. This was a good idea, but I outsmarted myself
since it was intended to service NMI occuring in user mode, and we could
end up invoking preempt() and have another cpu start using this stack,
with interesting results.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.42 2009/02/17 21:03:59 miod Exp $ */
d82 2
d99 9
a117 2
	u_int		 ci_cpudep6;
	u_int		 ci_cpudep7;
@


1.42
log
@Pass a cpu_info * to setsoftipi() so it does not need to curcpu(), which
synchronizes the pipeline on 88110.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.41 2009/02/16 23:03:31 miod Exp $ */
d117 6
a122 7
#define	ci_nmi_stack	 ci_cpudep0		/* NMI stack */
#define	ci_ipi_arg1	 ci_cpudep1		/* Complex IPI arguments */
#define	ci_ipi_arg2	 ci_cpudep2
#define	ci_h_sxip	 ci_cpudep3		/* trapframe values */
#define	ci_h_epsr	 ci_cpudep4		/* for hardclock */
#define	ci_s_sxip	 ci_cpudep5		/* and softclock */
#define	ci_s_epsr	 ci_cpudep6
@


1.41
log
@More 88110 SMP work. Contains, horribly entangled:
- dma_cachectl() split into a ``local cpu only'' and ``all cpus'', and an ipi
  to broadcast ``local dma_cachectl'' is added.
- cpu_info fields are rearranged, to have the 88100-specific information
  and the 88110-specific information overlap, and has many more 88110
  ugly things.
- more ipi handling in the 197-specific area. Since it is not possible to
  have the second processor receive any hardware interrupt (selection
  is done on a level basis via ISEL, and we definitely do not want the
  main cpu to lose interrupts), the best we can do is to inflict ourselves
  a soft interrupt for late ipi processing. It gets used for softclock and
  hardclock on the secondary processor, but since the soft interrupt
  dispatcher doesn't have an exception frame, we have to remember parts
  of it to build a fake clockframe from the soft ipi handler (ugly but
  works).

This now lets GENERIC.MP run a few userland binaries before bugs trigger.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.40 2009/02/08 21:40:56 miod Exp $ */
d247 4
a250 4
#define setsoftint(x)	atomic_setbits_int(&curcpu()->ci_softintr, x)
#define setsoftnet()	setsoftint(SIR_NET)
#define setsoftclock()	setsoftint(SIR_CLOCK)
#define	setsoftipi()	setsoftint(SIR_IPI)
d252 1
a252 1
#define	aston(p)	((p)->p_md.md_astpending = 1)
@


1.40
log
@On 88110 processors, use a separate stack to handle NMI; these can occur
while we are switching pcbs and all sort of bad things could happen.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.39 2008/12/21 21:43:51 miod Exp $ */
d87 1
a87 1
	u_int	ci_flags;
d91 2
a92 2
	struct proc *ci_curproc;		/* current process... */
	struct pcb *ci_curpcb;			/* ...and its pcb */
d94 1
a94 1
	u_int	ci_cpuid;			/* cpu number */
d96 32
a127 2
	u_int	ci_pfsr_i0, ci_pfsr_i1;		/* instruction... */
	u_int	ci_pfsr_d0, ci_pfsr_d1;		/* ... and data CMMU PFSRs */
d129 1
a129 2
	struct schedstate_percpu ci_schedstate;	/* scheduling state */
	int	ci_want_resched;		/* need_resched() invoked */
d131 1
a131 1
	u_int	ci_intrdepth;			/* interrupt depth */
d133 1
a133 3
	u_long	ci_spin_locks;			/* spin locks counter */

	int	ci_ddb_state;			/* ddb status */
d139 2
a140 6
	int	ci_softintr;			/* pending soft interrupts */
	u_int32_t ci_randseed;			/* per-cpu random seed */

	vaddr_t	ci_nmi_stack;			/* NMI stack (88110) */

#ifdef MULTIPROCESSOR
d142 1
a142 1
	int	ci_ipi;				/* pending ipis */
d147 1
d150 1
a150 1

d153 1
a153 3
	u_int32_t	ci_ipi_arg1;
	u_int32_t	ci_ipi_arg2;
#endif
d245 1
d250 1
d275 1
@


1.39
log
@Proper cpu_unidle() function for MP kernels. ok art@@ long ago
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.38 2008/10/15 23:23:48 deraadt Exp $ */
d113 3
a115 1
	u_int32_t ci_randseed;
@


1.38
log
@make random(9) return per-cpu values (by saving the seed in the cpuinfo),
which are uniform for the profclock on each cpu in a SMP system (but using
a different seed for each cpu).  on all cpus, avoid seeding with a value out
of the [0, 2^31-1] range (since that is not stable)
ok kettenis drahn
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.37 2008/10/10 08:36:28 art Exp $ */
a140 1
#define cpu_unidle(ci)
d157 1
d164 1
a237 10
/*
 * Preempt the current process if in interrupt from user mode,
 * or after the current trap/syscall if in system mode.
 */
#define	need_resched(ci) \
do {									\
	ci->ci_want_resched = 1;					\
	if (ci->ci_curproc != NULL)					\
		aston(ci->ci_curproc);					\
} while (0)
d247 1
@


1.37
log
@Add empty cpu_unidle() macros for architectures that currently don't do
anything special to prod a cpu to leave the idle loop in signotify.
powerpc, i386, amd64 and sparc64 will follow soon so that everyone has
the same interface to wake an idling cpu.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.36 2008/10/10 08:05:45 art Exp $ */
d113 1
@


1.36
log
@Define MAXCPUS on all architectures.
For now, sparc64 is arbitrarily set to 256 (only architecture that didn't have
a practical limit in the code on the number of cpus).
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.35 2008/07/18 23:43:31 art Exp $ */
d140 1
@


1.35
log
@Add a macro that clears the want_resched flag that need_resched sets.
Right now when mi_switch picks up the same proc, we didn't clear the
flag which would mean that every time we service an AST we would attempt
a context switch. For some architectures, amd64 being probably the
most extreme, that meant attempting to context switch for every
trap and interrupt.

Now we clear_resched explicitly after every context switch, even if it
didn't do anything. Which also allows us to remove some more code
in cpu_switchto (not done yet).

miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.34 2008/01/13 20:20:29 miod Exp $ */
d139 1
@


1.34
log
@Add a machdep.cputype sysctl, which returns the processor type (0 for 88100,
1 for 88110), for userland to have an easy way to figure out.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.33 2007/12/15 19:34:33 miod Exp $ */
d244 1
@


1.33
log
@Since the 88110 can not invalidate a particular tlb entry, do not stack
invalidate tlb ipis, and turn them into simple ``handle once'' ipis.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.32 2007/12/04 23:45:51 miod Exp $ */
d48 2
a49 1
#define	CPU_MAXID	2	/* number of valid machdep ids */
d54 1
@


1.32
log
@Work in progress SMP code for 88110 processor using the BusSwitch chip as
an IPI facility, for MVME197DP.

It's still missing a few remote cache IPIs and IPI do not seem to be reliably
triggered on remote processors at the moment (but this could be a problem
on the board I am currently testing on), at least it will boot multiuser
using only cpu0 to schedule processes.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.31 2007/11/15 21:23:16 miod Exp $ */
d119 2
d122 2
a123 3
#define	CI_IPI_TLB_FLUSH	0x00000010
#define	CI_IPI_CACHE_FLUSH	0x00000020
#define	CI_IPI_ICACHE_FLUSH	0x00000040
@


1.31
log
@Stop referring the initial kernel stack as the ``interrupt stack''. It's
been years since it has last been used for that purpose, so name it the
initialization/startup stack.

While there, do not store the initialization stack in cpu_info, and have
secondary_pre_main() return its value so that the bootstrap code does not
need to fetch it from cpu_info.

This might be reconsidered when the startup stacks will be freed after they
are not used anymore, but there are more things to do first.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.30 2007/11/14 23:12:45 miod Exp $ */
d45 1
a45 1
 * CTL_MACHDEP definitinos.
d93 1
a93 1
	u_int	ci_primary;			/* set if master cpu */
d104 1
a104 1
	int ci_ddb_state;			/* ddb status */
d110 5
a114 1
	int ci_ipi;				/* pending ipis */
d119 7
a125 1
	int	ci_softintr;			/* pending soft interrupts */
@


1.30
log
@Merge the ci_alive and ci_primary boolean values of struct cpu_info into
a single ci_flags bitfield.

Also, set_cpu_number() will no longer set CIF_PRIMARY on the primary processor,
it's up to the initialization code to do this.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.29 2007/11/06 21:48:42 miod Exp $ */
a98 2

	vaddr_t	ci_init_stack;			/* startup stack */
@


1.29
log
@Keep a pending software interrupts mask per processor, instead of having it
global; and only schedule software interrupts on the currently running cpu.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.28 2007/11/06 21:42:56 miod Exp $ */
d85 3
a87 1
	u_int	ci_alive;			/* nonzero if CPU present */
d106 1
a106 1
	volatile int ci_ddb_state;		/* ddb status */
d112 1
a112 1
	volatile int ci_ipi;			/* pending ipis */
d126 1
a126 1
		if (((ci) = &m88k_cpus[cii])->ci_alive != 0)
d140 1
a140 1
#define	CPU_IS_PRIMARY(ci)	((ci)->ci_primary != 0)
@


1.28
log
@Remove the now unused idle_u, and call the secondary processors startup
stack a startup stack.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.27 2007/10/29 19:57:46 miod Exp $ */
d115 1
d205 1
a205 2
extern unsigned int ssir;
#define setsoftint(x)	atomic_setbits_int(&ssir, x)
@


1.27
log
@When a secondary cpu gets its interrupt pin stuck, be sure to savectx
and put the process it was running back on the run queue (unless this was
the idle proc).
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.26 2007/10/24 20:53:59 miod Exp $ */
d98 1
a98 1
	struct pcb *ci_idle_pcb;		/* idle pcb (and stack) */
@


1.26
log
@Turn curcpu() into an inline function instead of a macro relying on a GCC
extension.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.25 2007/10/16 04:57:37 miod Exp $ */
d140 1
@


1.25
log
@Do not expose the end of the proc_trampoline bowels to C code anymore, and
get rid of the ``switchframe'' struct definition. As a bonus, this makes
cpu_fork() simpler and unwastes 8 bytes of u area.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.24 2007/10/13 12:54:43 miod Exp $ */
d128 8
a135 7
#define	curcpu() \
({									\
	struct cpu_info *cpuptr;					\
									\
	__asm__ __volatile__ ("ldcr %0, cr17" : "=r" (cpuptr));		\
	cpuptr;								\
})
@


1.24
log
@It is no longer necessary to fiddle with spl in cpu_idle_{enter,leave} now
that proc_trampoline has been fixed.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.23 2007/10/10 15:53:52 art Exp $ */
a237 8

/*
 * switchframe - should be double word aligned.
 */
struct switchframe {
	u_int	sf_pc;			/* pc */
	void	*sf_proc;		/* proc pointer */
};
@


1.23
log
@Make context switching much more MI:
 - Move the functionality of choosing a process from cpu_switch into
   a much simpler function: cpu_switchto. Instead of having the locore
   code walk the run queues, let the MI code choose the process we
   want to run and only implement the context switching itself in MD
   code.
 - Let MD context switching run without worrying about spls or locks.
 - Instead of having the idle loop implemented with special contexts
   in MD code, implement one idle proc for each cpu. make the idle
   loop MI with MD hooks.
 - Change the proc lists from the old style vax queues to TAILQs.
 - Change the sleep queue from vax queues to TAILQs. This makes
   wakeup() go from O(n^2) to O(n)

there will be some MD fallout, but it will be fixed shortly.
There's also a few cleanups to be done after this.

deraadt@@, kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.22 2007/05/19 20:34:32 miod Exp $ */
d169 1
d171 1
@


1.22
log
@Send an IPI in signotify() if the process runs on a different processor,
similar to the fix which went into i386 and amd64 a few weeks ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.21 2007/05/14 17:00:38 miod Exp $ */
d61 1
d168 2
@


1.21
log
@Work in progress IPI mechanism, currently only implemented on MVME188, to
send clock ticks to secondary processors.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.20 2007/04/18 21:21:19 miod Exp $ */
d232 1
a232 5
/*
 * Notify the current process (p) that it has a signal pending,
 * process as soon as possible.
 */
#define	signotify(p)		aston(p)
@


1.20
log
@Use atomic operations to change the pending software interrupt mask.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.19 2007/03/15 10:22:29 art Exp $ */
d107 7
d138 2
@


1.19
log
@Since p_flag is often manipulated in interrupts and without biglock
it's a good idea to use atomic.h operations on it. This mechanic
change updates all bit operations on p_flag to atomic_{set,clear}bits_int.

Only exception is that P_OWEUPC is set by MI code before calling
need_proftick and it's automatically cleared by ADDUPC. There's
no reason for MD handling of that flag since everyone handles it the
same way.

kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.18 2007/01/12 21:41:53 aoyama Exp $ */
d57 1
d185 2
a186 16
#define SIR_NET		1
#define SIR_CLOCK	2

#ifdef MULTIPROCESSOR
extern void setsoftint(int);
extern int clrsoftint(int);
#else
extern int ssir;
#define setsoftint(x)	(ssir |= (x))
#define	clrsoftint(x)	\
({									\
	int tmpsir = ssir & (x);					\
	ssir ^= tmpsir;							\
	tmpsir;								\
})
#endif	/* MULTIPROCESSOR */
d188 2
@


1.18
log
@Change the secondary CMMU's data cache turn on so that do not hog the
bus while they spin, as same as 3.8.  This have been missed since CMMU
initialize cleanup.

Also m88k_cpus[] should have 4 elements on luna88k, even in
non-MULTIPROCESSOR kernel.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.17 2006/12/24 20:30:35 miod Exp $ */
d232 1
a232 1
#define	need_proftick(p)	((p)->p_flag |= P_OWEUPC, aston(p))
@


1.17
log
@Define PROC_PC. Then, since profiling information is being reported in
statclock(), do not bother doing this in userret() anymore. As a result,
userret() does not need its pc and ticks arguments, simplify.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.16 2006/11/29 12:26:13 miod Exp $ */
d68 1
d71 1
@


1.16
log
@Remove cpu_swapin() and cpu_swapout(), they are no longer necessary (except
for cpu_swapin() on hppa* which is kept).
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.15 2006/05/08 14:36:09 miod Exp $ */
d203 10
@


1.15
log
@Replace gazillions of badvaddr() or badwordaddr() calls with badaddr() calls.
With a few prototype declarations shuffling, this finally allows
<machine/locore.h> to die.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.14 2006/04/17 16:08:01 miod Exp $ */
a154 2
#define	cpu_swapin(p)		do { /* nothing */ } while (0)
#define	cpu_swapout(p)		do { /* nothing */ } while (0)
@


1.14
log
@Save pointers to up to four CMMU PFSR registers into the cpu_info structure.
This allows the exception handling code to skip the PFSR address computations.

The net result is that the PFSR_SAVE code becomes much simpler and smaller,
and that all processors will now spend time in PFSR_SAVE - previously, cpu0
was favored and other processors took a bit more time.

Note that 8:1 configurations do not use these fields - but then this is a
fixed monoprocessor configuration, for which the existing code was already
doing The Right Thing.

Tested on luna88k (2:1) by aoyama@@, and on mvme88k (2:1 and 4:1) by me.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.13 2006/04/15 15:43:36 miod Exp $ */
d136 2
d238 1
a238 1
int badvaddr(vaddr_t, int);
@


1.13
log
@nmihand() is mvme88k only, move it out of m88k common area.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.12 2005/12/11 21:45:28 miod Exp $ */
d88 2
@


1.12
log
@Work in progress SMP code; mvme88k boards can spin up secondary CPUs,
kernel boots single user. Still a lot of polishing and bugfixing to do.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.11 2005/12/11 21:36:06 miod Exp $ */
a234 1
void nmihand(void *);
@


1.11
log
@Factorize soft interrupt code between luna88k and mvme88k.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.10 2005/12/03 14:30:05 miod Exp $ */
d98 4
a101 1
	/* XXX ddb state? */
@


1.10
log
@Switch m88k ports to __HAVE_CPUINFO. Current cpu pointer is held in SR0
on all running processors.
Tested aoyama@@ and I
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.9 2005/11/28 22:22:51 miod Exp $ */
d180 5
d186 8
a195 4

#define siroff(x)	(ssir &= ~(x))

extern int	ssir;
@


1.9
log
@Maintain an interrupt depth counter for CLKF_INTR to be correct.
Tested aoyama@@ martin@@ and I.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.8 2005/11/28 22:21:15 miod Exp $ */
d57 8
a64 1
#ifndef	MAX_CPUS
d67 30
d98 27
a124 2
#include <machine/pcb.h>
#include <machine/psl.h>
d126 2
a127 1
#ifndef _LOCORE
d129 1
a129 1
static unsigned cpu_number(void);
d131 6
a136 3
static __inline__ unsigned cpu_number(void)
{
	unsigned cpu;
d138 1
a138 3
	__asm__ __volatile__ ("ldcr %0, cr18" : "=r" (cpu));
	return (cpu & 3);
}
d151 5
d169 2
a170 2
extern int intrdepth;
#define	CLKF_INTR(framep)	(intrdepth > 1)
a193 1
extern int	want_resched;		/* resched() was called */
d196 3
a198 3
	want_resched = 1;						\
	if (curproc != NULL)						\
		aston(curproc);						\
d203 1
a203 1
 * buffer pages are invalid.  On the sparc, request an ast to send us
@


1.8
log
@Switch to per-process AST flags and clean AST-related codepaths; speeds up
forks as a bonus.
Tested on luna88k and mvme88k by aoyama@@ martin@@ and I.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.7 2005/10/13 19:48:32 miod Exp $ */
d100 2
a101 1
#define	CLKF_INTR(framep)	(0)	/* XXX temporary */
@


1.7
log
@Merge <machine/cpu_number.h> into <machine/cpu.h>, preparing for intrusive
changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.6 2005/10/12 19:05:43 miod Exp $ */
d98 2
a99 2
#define	CLKF_USERMODE(framep)	((((struct trapframe *)(framep))->tf_epsr & PSR_MODE) == 0)
#define	CLKF_PC(framep)		(((struct trapframe *)(framep))->tf_sxip & XIP_ADDR)
d111 2
a112 2
#define setsoftnet()	(ssir |= SIR_NET)
#define setsoftclock()	(ssir |= SIR_CLOCK)
d114 1
a114 1
#define siroff(x)	(ssir &= ~x)
d117 2
a118 1
extern int	want_ast;
d125 6
a130 1
#define	need_resched(ci)		(want_resched = 1, want_ast = 1)
d137 1
a137 1
#define	need_proftick(p)	((p)->p_flag |= P_OWEUPC, want_ast = 1)
d143 1
a143 1
#define	signotify(p)		(want_ast = 1)
@


1.6
log
@Stop mapping the u area at fixed UADDR in addition to its actual va.
While there, attempt to clean and comment stack usage in the kernel.
No functional change.

From the m88k SMP tree; help&test martin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.5 2004/11/08 16:39:31 miod Exp $ */
d63 14
@


1.5
log
@Kill struct md_p, which was really only necessary for mvme88k; on
luna88k it disappears completely, while mvme88k keeps 3 global variables,
one of them scheduled to disappear very soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.4 2004/08/02 08:34:59 miod Exp $ */
d68 4
a71 3
#define	cpu_exec(p)	/* nothing */
#define	cpu_wait(p)	/* nothing */
#define	cpu_swapout(p)	/* nothing */
d86 1
a86 1
#define	CLKF_INTR(framep)	(((struct trapframe *)(framep))->tf_r[31] >= UADDR)
@


1.4
log
@More include files cleaning:
- move MAX_CPUS constant to <machine/cpu.h>
- do not include <machine/board.h> unless needed. In fact, remove this file
  entirely on mvme88k, and include <machine/mvme*.h> on a
  compiling-for-this-board basis
- keep MAX_CMMUS constant private to the m8820x code
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.3 2004/07/24 15:05:05 miod Exp $ */
a130 14

/* This struct defines the machine dependent pointers */
struct md_p {
	void (*clock_init_func)(void);      /* interval clock init function */
	void (*statclock_init_func)(void);  /* statistics clock init function */
	void (*delayclock_init_func)(void); /* delay clock init function */
	void (*delay_func)(void);           /* delay clock function */
	void (*interrupt_func)(u_int, struct trapframe *);       /* interrupt func */
	u_char *volatile intr_mask;
	u_char *volatile intr_ipl;
	u_char *volatile intr_src;
};

extern struct md_p md;
@


1.3
log
@intr_establish() and related defines are mvme88k-only, so move them back from
<m88k/cpu.h>, and simplify the return values while there.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.2 2004/06/13 21:49:17 niklas Exp $ */
d57 5
a62 2
#include <machine/pcb.h>
#include <machine/board.h>
@


1.2
log
@debranch SMP, have fun
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d41 2
a42 2
#ifndef __MACHINE_CPU_H__
#define __MACHINE_CPU_H__
a120 27
struct intrhand {
	int	(*ih_fn)(void *);
	void	*ih_arg;
	int	ih_ipl;
	int	ih_wantframe;
	struct	intrhand *ih_next;
};

int	intr_establish(int vec, struct intrhand *);

/*
 * return values for intr_establish()
 */

#define INTR_EST_SUCC 		0
#define INTR_EST_BADVEC		1
#define INTR_EST_BADIPL		2


/*
 * There are 256 possible vectors on a MVME1x7 platform (including
 * onboard and VME vectors. Use intr_establish() to register a
 * handler for the given vector. vector number is used to index
 * into the intr_handlers[] table.
 */
extern struct intrhand *intr_handlers[256];

d147 1
a147 1
#endif /* __MACHINE_CPU_H__ */
@


1.1
log
@Start factorizing luna88k and mvme88k common parts.
For now, include files only.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.25 2004/04/24 19:51:48 miod Exp $ */
d106 1
a106 1
#define	need_resched()		(want_resched = 1, want_ast = 1)
@


1.1.2.1
log
@Merge with the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
@


1.1.2.2
log
@need_resched macro needs to take ci arg to be compat with MP function
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.1.2.1 2004/06/05 23:09:47 niklas Exp $ */
d106 1
a106 1
#define	need_resched(ci)		(want_resched = 1, want_ast = 1)
@


