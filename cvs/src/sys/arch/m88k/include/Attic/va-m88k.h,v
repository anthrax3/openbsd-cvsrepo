head	1.12;
access;
symbols
	OPENBSD_5_2:1.11.0.8
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.6
	OPENBSD_5_0:1.11.0.4
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.2
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.10.0.8
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.2
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.10.0.6
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.4
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.9.0.10
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.8
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.6
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.4
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.2
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.8.0.2
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.5.0.6
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.4
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.2
	OPENBSD_3_6_BASE:1.5
	SMP_SYNC_A:1.4
	SMP_SYNC_B:1.4
	SMP:1.2.0.2;
locks; strict;
comment	@ * @;


1.12
date	2012.12.04.21.06.51;	author miod;	state dead;
branches;
next	1.11;

1.11
date	2010.12.31.20.37.36;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2008.10.23.21.25.07;	author kettenis;	state Exp;
branches;
next	1.9;

1.9
date	2006.04.09.03.07.53;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2006.01.06.18.53.05;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2005.12.20.14.42.05;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2005.12.14.21.46.31;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2004.07.28.08.47.12;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.09.23.08.19;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2004.06.07.20.44.18;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2004.05.19.21.40.30;	author miod;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2004.04.26.12.34.05;	author miod;	state Exp;
branches;
next	;

1.2.2.1
date	2004.06.05.23.09.48;	author niklas;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2004.06.08.21.07.21;	author niklas;	state Exp;
branches;
next	1.2.2.3;

1.2.2.3
date	2004.06.10.11.40.26;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Remove the gcc 2 m88k varargs logic. You gave me a lot of trouble and no pony,
therefore I don't mind you rotting in the Attic for eternity (scheduled
to start on the 21st anyway, according to MayaBSD developers).
reminded by deraadt@@
@
text
@/*	$OpenBSD: va-m88k.h,v 1.11 2010/12/31 20:37:36 miod Exp $	*/

/* Define __gnuc_va_list.  */

#ifndef __GNUC_VA_LIST
#define __GNUC_VA_LIST

#include <sys/cdefs.h>

typedef struct __va_list_tag {
	unsigned int  __va_arg;		/* argument number */
	unsigned int *__va_stk;		/* start of args passed on stack */
	unsigned int *__va_reg;		/* start of args passed in regs */
} __gnuc_va_list[1];

#endif /* not __GNUC_VA_LIST */

/* If this is for internal libc use, don't define anything but
   __gnuc_va_list.  */
#if defined (_STDARG_H) || defined (_VARARGS_H)

#define __va_start_common(AP,FAKE) \
__extension__ ({							\
   (AP) = (struct __va_list_tag *)__builtin_alloca(sizeof(__gnuc_va_list)); \
  __builtin_memcpy ((AP), __builtin_saveregs (), sizeof(__gnuc_va_list)); \
  })

#ifdef _STDARG_H /* stdarg.h support */

/* Calling __builtin_next_arg gives the proper error message if LASTARG is
   not indeed the last argument.  */
#ifdef lint
#define va_start(AP,LASGARG) ((AP) = (AP))
#else
#define va_start(AP,LASTARG) \
  (__builtin_next_arg (LASTARG), __va_start_common (AP, 0))
#endif /* lint */

#else /* varargs.h support */

#ifdef lint
#define va_start(AP) ((AP) = (AP))
#else
#define va_start(AP) __va_start_common (AP, 1)
#endif /* lint */

#define va_alist __va_1st_arg
#define va_dcl register int va_alist; ...

#endif /* _STDARG_H */

#define __va_reg_p(TYPE)						\
__extension__({								\
    __builtin_classify_type(*(TYPE *)0) < 12 ? /* record, union */	\
	sizeof(TYPE) <= 8 :						\
	sizeof(TYPE) == 4 && __alignof__(*(TYPE *)0) == 4;		\
})

#define	__va_size(TYPE) ((sizeof(TYPE) + 3) >> 2)

/* We cast to void * and then to TYPE * because this avoids
   a warning about increasing the alignment requirement.  */
#define va_arg(AP,TYPE)							\
__extension__(*({							\
    register TYPE *__ptr;						\
									\
    if ((AP)->__va_arg <= 8 && __va_reg_p(TYPE)) {			\
	/* might be in registers */					\
	if (((AP)->__va_arg & 1) != 0 && __alignof__(*(TYPE *)0) > 4)	\
	    (AP)->__va_arg++;						\
	(AP)->__va_arg += __va_size(TYPE);				\
    }									\
									\
    if ((AP)->__va_arg <= 8 && __va_reg_p(TYPE)) {			\
	__ptr = (TYPE *) (void *) ((AP)->__va_reg +			\
	    (AP)->__va_arg - __va_size(TYPE));				\
    } else {								\
	if (((unsigned int)((AP)->__va_stk) & 4) != 0 &&		\
	    __alignof__(*(TYPE *)0) > 4) {				\
	    (AP)->__va_stk++;						\
	} \
	__ptr = (TYPE *) (AP)->__va_stk;				\
	(AP)->__va_stk += __va_size(TYPE);				\
    }									\
    __ptr;								\
}))

#define va_end(AP)	((void)0)

#ifdef lint
#define	__va_copy(dest, src)	((dest) = (src))
#else
/* Copy __gnuc_va_list into another variable of this type.  */
#define __va_copy(dest, src) \
__extension__ ({ \
	(dest) =  \
	   (struct __va_list_tag *)__builtin_alloca(sizeof(__gnuc_va_list)); \
	*(dest) = *(src);\
  })
#endif /* lint */

#endif /* defined (_STDARG_H) || defined (_VARARGS_H) */
@


1.11
log
@Provide a lint-friendly __va_copy(), as done on all other platforms.
@
text
@d1 1
a1 1
/*	$OpenBSD: va-m88k.h,v 1.10 2008/10/23 21:25:07 kettenis Exp $	*/
@


1.10
log
@Move the va_copy define to <sys/stdrag.h> making sure it is uniformaly
protected by __ISO_C_VISIBLE > 1999.  With a little help from miod@@.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: va-m88k.h,v 1.9 2006/04/09 03:07:53 deraadt Exp $	*/
d90 3
d100 1
@


1.9
log
@#ifdef lint wraps for va_start
@
text
@d1 1
a1 1
/*	$OpenBSD: va-m88k.h,v 1.8 2006/01/06 18:53:05 millert Exp $	*/
a96 4

#if __ISO_C_VISIBLE >= 1999
#define va_copy(dest, src) __va_copy(dest, src)
#endif
@


1.8
log
@Adapt things to use __type_t instead of _BSD_TYPE_T_
Add new sys/_types.h header
Include machine/_types.h or sys/_types.h where applicable
@
text
@d1 1
a1 1
/*	$OpenBSD: va-m88k.h,v 1.7 2005/12/20 14:42:05 millert Exp $	*/
d32 3
d37 1
d41 3
d45 2
@


1.7
log
@Fix typo introduced in last commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: va-m88k.h,v 1.6 2005/12/14 21:46:31 millert Exp $	*/
d14 1
a14 1
} __va_list[1], __gnuc_va_list[1];
@


1.6
log
@convert _FOO_SOURCE -> __FOO_VISIBLE in machine.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: va-m88k.h,v 1.5 2004/07/28 08:47:12 miod Exp $	*/
d89 1
a89 1
#if __ISO_VISIBLE >= 1999
@


1.5
log
@In the never-ending saga of getting gcc to work reliably on m88k, today's
changes address incorrect stack usage, when optimization needs more
nameless temporary values than available registers, and has to save them
on stack.

In some (rare) circumstances, it will compute a stack address _outside_
the current function local storage space, overwriting the caller's stack.

Most of the time, this only affects the "outgoing argument area", which is
harmless if it has not been populated; this explains why it has not been
noticed earlier.

Since I see no easy way to fix this, I decided to go the simpler way of
removing this ougoing argument area. This not only reduces stack usage,
but also makes varargs/stdarg code smaller and faster; also functions which
get their first few arguments in registers, then some on the stack, then
some in registers again, will not allocate stack space for the second
set of arguments passed through registers.

This is an ABI change, we are no longer 88Open compliant (have we ever
been?).
@
text
@d1 1
a1 1
/*	$OpenBSD: va-m88k.h,v 1.4 2004/06/09 23:08:19 miod Exp $	*/
d8 2
d89 1
a89 3
#if !defined(_ANSI_SOURCE) && \
    (!defined(_POSIX_C_SOURCE) && !defined(_XOPEN_SOURCE) || \
	defined(_ISOC99_SOURCE) || (__STDC_VERSION__ - 0) >= 199901L)
@


1.4
log
@Among other tricky (or nice, depending upon your involvment) features,
the 88Open ABI allows arguments to be passed through registers, then on
the stack, the through registers, then on the stack again, with some
function signatures.

Unfortunately, gcc has not been designed with this possibility in mind,
and does not handle this situation optimally (since no sane architecture
does this anyway) and will reserve stack storage for the second set of
in-registers parameters.

Fixing this is quite non-trivial (trust me on this), so in the meantime
keep at wasting space stack, but teach varargs about this so that it can
compensate correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: va-m88k.h,v 1.3 2004/06/07 20:44:18 miod Exp $	*/
a11 1
	unsigned int __va_tomfoolery;	/* do we need to eat stack for regs */
a23 3
  if ((AP)->__va_arg > 8)						\
 	(AP)->__va_stk += ((AP)->__va_arg - 8);				\
  (AP)->__va_tomfoolery = 0;						\
a65 2
	if ((AP)->__va_tomfoolery)					\
	    (AP)->__va_stk += __va_size(TYPE);				\
a72 1
	(AP)->__va_tomfoolery = 1;					\
@


1.3
log
@Correctly handle an unaligned long long parameter on stack in varargs functions;
makes some rare situations in the a.out ar working again.
@
text
@d1 1
a1 1
/*	$OpenBSD: va-m88k.h,v 1.2 2004/05/19 21:40:30 miod Exp $	*/
d12 1
d27 1
d70 2
d76 1
a76 1
} \
d79 1
@


1.2
log
@Rewrite va_arg() for correctness. Not only is the new code easier to read,
it also expands to faster code!
@
text
@d1 1
a1 1
/*	$OpenBSD: va-m88k.h,v 1.1 2004/04/26 12:34:05 miod Exp $	*/
d24 2
d69 4
@


1.2.2.1
log
@Merge with the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.2.2.2
log
@sync to head
@
text
@a23 2
  if ((AP)->__va_arg > 8)						\
 	(AP)->__va_stk += ((AP)->__va_arg - 8);				\
a66 4
	if (((unsigned int)((AP)->__va_stk) & 4) != 0 &&		\
	    __alignof__(*(TYPE *)0) > 4) {				\
	    (AP)->__va_stk++;						\
} \
@


1.2.2.3
log
@sync with head, make i386 __HAVE_CPUINFO
@
text
@a11 1
	unsigned int __va_tomfoolery;	/* do we need to eat stack for regs */
a25 1
  (AP)->__va_tomfoolery = 0;						\
a67 2
	if ((AP)->__va_tomfoolery)					\
	    (AP)->__va_stk += __va_size(TYPE);				\
d72 1
a72 1
	} \
a74 1
	(AP)->__va_tomfoolery = 1;					\
@


1.1
log
@Start factorizing luna88k and mvme88k common parts.
For now, include files only.
@
text
@d1 1
a1 9
/*	$OpenBSD: va-m88k.h,v 1.11 2004/01/26 20:11:14 deraadt Exp $	*/

/* This file has local changes by MOTOROLA
Thu Sep  9 09:06:29 CDT 1993 Dale Rahn (drahn@@pacific)
	* Due to C-Front's usage of __alignof__ builtin the
	usage of it must be changed to have an object of that type
	as the argument not just the type.
 */
/* GNU C varargs support for the Motorola 88100  */
d41 6
a46 3
#define __va_reg_p(TYPE) \
  (__builtin_classify_type(*(TYPE *)0) < 12 \
   ? sizeof(TYPE) <= 8 : sizeof(TYPE) == 4 && __alignof__(*(TYPE *)0) == 4)
d52 20
a71 8
#define va_arg(AP,TYPE)							   \
  ( (AP)->__va_arg = (((AP)->__va_arg + (1 << (__alignof__(*(TYPE *)0) >> 3)) - 1) \
		     & ~((1 << (__alignof__(*(TYPE *)0) >> 3)) - 1))	   \
    + __va_size(TYPE),							   \
    *((TYPE *) (void *) ((__va_reg_p(TYPE)				   \
			  && (AP)->__va_arg < 8 + __va_size(TYPE)	   \
			  ? (AP)->__va_reg : (AP)->__va_stk)		   \
			 + ((AP)->__va_arg - __va_size(TYPE)))))
d73 1
a73 1
#define va_end(AP)
@

