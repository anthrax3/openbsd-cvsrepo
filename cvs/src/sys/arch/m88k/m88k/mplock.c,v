head	1.6;
access;
symbols
	OPENBSD_6_1:1.4.0.6
	OPENBSD_6_1_BASE:1.4
	OPENBSD_6_0:1.4.0.2
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.3.0.4
	OPENBSD_5_9_BASE:1.3
	OPENBSD_5_8:1.3.0.6
	OPENBSD_5_8_BASE:1.3
	OPENBSD_5_7:1.3.0.2
	OPENBSD_5_7_BASE:1.3
	OPENBSD_5_6:1.2.0.26
	OPENBSD_5_6_BASE:1.2
	OPENBSD_5_5:1.2.0.24
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.2.0.20
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.18
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.16
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.14
	OPENBSD_5_0:1.2.0.12
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.10
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.8
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.6
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.4
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.0.4
	OPENBSD_4_4_BASE:1.1
	OPENBSD_4_3:1.1.0.2
	OPENBSD_4_3_BASE:1.1;
locks; strict;
comment	@ * @;


1.6
date	2017.05.29.14.19.50;	author mpi;	state Exp;
branches;
next	1.5;
commitid	4u6PWvBw90PH7UDq;

1.5
date	2017.04.30.16.45.45;	author mpi;	state Exp;
branches;
next	1.4;
commitid	2Gtqjzrin9LL2yHk;

1.4
date	2016.03.19.11.34.22;	author mpi;	state Exp;
branches;
next	1.3;
commitid	15xZY6veDWwRM6Iq;

1.3
date	2015.02.11.07.05.39;	author dlg;	state Exp;
branches;
next	1.2;
commitid	JTpbkhDknrIuy9pn;

1.2
date	2009.02.21.18.37.48;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2007.12.02.21.20.17;	author miod;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Kill SPINLOCK_SPIN_HOOK, use CPU_BUSY_CYCLE() instead.

ok visa@@, kettenis@@
@
text
@/*	$OpenBSD: mplock.c,v 1.5 2017/04/30 16:45:45 mpi Exp $	*/

/*
 * Copyright (c) 2004 Niklas Hallqvist.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>

#include <machine/asm_macro.h>
#include <machine/cpu.h>

#include <ddb/db_output.h>

#if defined(MP_LOCKDEBUG)
#ifndef DDB
#error "MP_LOCKDEBUG requires DDB"
#endif

/* CPU-dependent timing, needs this to be settable from ddb. */
extern int __mp_lock_spinout;
#endif

static __inline void
__mp_lock_spin(struct __mp_lock *mpl)
{
#ifndef MP_LOCKDEBUG
	while (mpl->mpl_count != 0)
		CPU_BUSY_CYCLE();
#else
	int nticks = __mp_lock_spinout;

	while (mpl->mpl_count != 0 && nticks-- > 0)
		CPU_BUSY_CYCLE();

	if (nticks == 0) {
 		db_printf("__mp_lock(0x%x): lock spun out", mpl);
		db_enter();
	}
#endif
}

void
__mp_lock(struct __mp_lock *mpl)
{
	struct cpu_info *ci = curcpu();
	uint32_t psr;
	uint gcsr;

	/*
	 * Please notice that mpl_count gets incremented twice for the
	 * first lock. This is on purpose. The way we release the lock
	 * in mp_unlock is to decrement the mpl_count and then check if
	 * the lock should be released. Since mpl_count is what we're
	 * spinning on, decrementing it in mpl_unlock to 0 means that
	 * we can't clear mpl_cpu, because we're no longer holding the
	 * lock. In theory mpl_cpu doesn't need to be cleared, but it's
	 * safer to clear it and besides, setting mpl_count to 2 on the
	 * first lock makes most of this code much simpler.
	 */

	for (;;) {
		psr = (*ci->ci_mp_atomic_begin)(&mpl->mpl_lock, &gcsr);

		if (mpl->mpl_count == 0) {
			mpl->mpl_count = 1;
			mpl->mpl_cpu = ci;
		}
		if (mpl->mpl_cpu == ci) {
			mpl->mpl_count++;
			(*ci->ci_mp_atomic_end)(psr, &mpl->mpl_lock, gcsr);
			break;
		}
		(*ci->ci_mp_atomic_end)(psr, &mpl->mpl_lock, gcsr);

		__mp_lock_spin(mpl);
	}
}

void
__mp_unlock(struct __mp_lock *mpl)
{
	struct cpu_info *ci = curcpu();
	u_int32_t psr;
	uint gcsr;

#ifdef MP_LOCKDEBUG
	if (mpl->mpl_cpu != ci) {
		db_printf("__mp_unlock(%p): not held lock\n", mpl);
		db_enter();
	}
#endif

	psr = (*ci->ci_mp_atomic_begin)(&mpl->mpl_lock, &gcsr);
	if (--mpl->mpl_count == 1) {
		mpl->mpl_cpu = NULL;
		mpl->mpl_count = 0;
	}
	(*ci->ci_mp_atomic_end)(psr, &mpl->mpl_lock, gcsr);
}

int
__mp_release_all(struct __mp_lock *mpl)
{
	struct cpu_info *ci = curcpu();
	u_int32_t psr;
	uint gcsr;
	int rv;

#ifdef MP_LOCKDEBUG
	if (mpl->mpl_cpu != ci) {
		db_printf("__mp_release_all(%p): not held lock\n", mpl);
		db_enter();
	}
#endif

	psr = (*ci->ci_mp_atomic_begin)(&mpl->mpl_lock, &gcsr);
	rv = mpl->mpl_count - 1;
	mpl->mpl_cpu = NULL;
	mpl->mpl_count = 0;
	(*ci->ci_mp_atomic_end)(psr, &mpl->mpl_lock, gcsr);

	return (rv);
}

int
__mp_release_all_but_one(struct __mp_lock *mpl)
{
	struct cpu_info *ci = curcpu();
	u_int32_t psr;
	uint gcsr;
	int rv;

#ifdef MP_LOCKDEBUG
	if (mpl->mpl_cpu != ci) {
		db_printf("__mp_release_all_but_one(%p): not held lock\n", mpl);
		db_enter();
	}
#endif

	psr = (*ci->ci_mp_atomic_begin)(&mpl->mpl_lock, &gcsr);
	rv = mpl->mpl_count - 2;
	mpl->mpl_count = 2;
	(*ci->ci_mp_atomic_end)(psr, &mpl->mpl_lock, gcsr);

	return (rv);
}
@


1.5
log
@Rename Debugger() into db_enter().

Using a name with the 'db_' prefix makes it invisible from the dynamic
profiler.

ok deraadt@@, kettenis@@, visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mplock.c,v 1.4 2016/03/19 11:34:22 mpi Exp $	*/
d31 1
a31 1
#include <machine/lock.h>
a43 2
#define	SPINLOCK_SPIN_HOOK	do { /* nothing */ } while (0)

d49 1
a49 1
		SPINLOCK_SPIN_HOOK;
d54 1
a54 1
		SPINLOCK_SPIN_HOOK;
@


1.4
log
@Reduces the noise around the global ``ticks'' variable by renaming
all the local ones to ``nticks''.

ok stefan@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mplock.c,v 1.3 2015/02/11 07:05:39 dlg Exp $	*/
d60 1
a60 1
		Debugger();
d112 1
a112 1
		Debugger();
d135 1
a135 1
		Debugger();
d159 1
a159 1
		Debugger();
@


1.3
log
@no md code wants lockmgr locks, so no md code needs to include sys/lock.h

with and ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mplock.c,v 1.2 2009/02/21 18:37:48 miod Exp $	*/
d53 1
a53 1
	int ticks = __mp_lock_spinout;
d55 1
a55 1
	while (mpl->mpl_count != 0 && ticks-- > 0)
d58 1
a58 1
	if (ticks == 0) {
@


1.2
log
@Move part of the mp lock logic into per-cpu callbacks; on MVME197DP we need
to disable NMI sources in addition to interrupt sources, and we can not
use a quick sequence with shadowing frozen as done for atomic ops.

This lets GENERIC.MP boot multiuser on MVME197DP boards, and is so far stable
enough to be able to recompile a kernel from scratch (with make -j2).
@
text
@d1 1
a1 1
/*	$OpenBSD: mplock.c,v 1.1 2007/12/02 21:20:17 miod Exp $	*/
a27 1
#include <sys/lock.h>
@


1.1
log
@Rework the __mp_lock code to not spin at spllock(), kinda similar to the
x86 __mp_lock changes, but keeping the internal __cpu_simplelock_t to
guarantee atomic access to the __mp_lock fields.
@
text
@d1 1
a1 1
/*	$OpenBSD: mplock.h,v 1.1 2007/11/26 17:15:29 art Exp $	*/
d70 2
d86 1
a86 1
		u_int32_t psr = get_psr();
a87 2
		set_psr(psr | PSR_IND);
		__cpu_simple_lock(&mpl->mpl_lock);
d94 1
a94 2
			__cpu_simple_unlock(&mpl->mpl_lock);
			set_psr(psr);
d97 1
a97 2
		__cpu_simple_unlock(&mpl->mpl_lock);
		set_psr(psr);
d106 3
a108 1
	u_int32_t psr = get_psr();
d111 1
a111 1
	if (mpl->mpl_cpu != curcpu()) {
d117 1
a117 2
	set_psr(psr | PSR_IND);
	__cpu_simple_lock(&mpl->mpl_lock);
d122 1
a122 2
	__cpu_simple_unlock(&mpl->mpl_lock);
	set_psr(psr);
d128 3
a130 1
	u_int32_t psr = get_psr();
d134 1
a134 1
	if (mpl->mpl_cpu != curcpu()) {
d140 1
a140 2
	set_psr(psr | PSR_IND);
	__cpu_simple_lock(&mpl->mpl_lock);
d144 1
a144 2
	__cpu_simple_unlock(&mpl->mpl_lock);
	set_psr(psr);
d152 3
a154 1
	u_int32_t psr = get_psr();
d158 1
a158 1
	if (mpl->mpl_cpu != curcpu()) {
d164 1
a164 2
	set_psr(psr | PSR_IND);
	__cpu_simple_lock(&mpl->mpl_lock);
d167 1
a167 2
	__cpu_simple_unlock(&mpl->mpl_lock);
	set_psr(psr);
@

