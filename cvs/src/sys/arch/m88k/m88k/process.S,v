head	1.26;
access;
symbols
	OPENBSD_6_1_BASE:1.26
	OPENBSD_6_0:1.26.0.14
	OPENBSD_6_0_BASE:1.26
	OPENBSD_5_9:1.26.0.10
	OPENBSD_5_9_BASE:1.26
	OPENBSD_5_8:1.26.0.12
	OPENBSD_5_8_BASE:1.26
	OPENBSD_5_7:1.26.0.4
	OPENBSD_5_7_BASE:1.26
	OPENBSD_5_6:1.26.0.8
	OPENBSD_5_6_BASE:1.26
	OPENBSD_5_5:1.26.0.6
	OPENBSD_5_5_BASE:1.26
	OPENBSD_5_4:1.26.0.2
	OPENBSD_5_4_BASE:1.26
	OPENBSD_5_3:1.25.0.2
	OPENBSD_5_3_BASE:1.25
	OPENBSD_5_2:1.24.0.14
	OPENBSD_5_2_BASE:1.24
	OPENBSD_5_1_BASE:1.24
	OPENBSD_5_1:1.24.0.12
	OPENBSD_5_0:1.24.0.10
	OPENBSD_5_0_BASE:1.24
	OPENBSD_4_9:1.24.0.8
	OPENBSD_4_9_BASE:1.24
	OPENBSD_4_8:1.24.0.6
	OPENBSD_4_8_BASE:1.24
	OPENBSD_4_7:1.24.0.2
	OPENBSD_4_7_BASE:1.24
	OPENBSD_4_6:1.24.0.4
	OPENBSD_4_6_BASE:1.24
	OPENBSD_4_5:1.23.0.4
	OPENBSD_4_5_BASE:1.23
	OPENBSD_4_4:1.21.0.4
	OPENBSD_4_4_BASE:1.21
	OPENBSD_4_3:1.21.0.2
	OPENBSD_4_3_BASE:1.21
	OPENBSD_4_2:1.16.0.2
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.15.0.2
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.13.0.4
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.13.0.2
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.7.0.6
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.4
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.2
	OPENBSD_3_6_BASE:1.7
	SMP_SYNC_A:1.1
	SMP_SYNC_B:1.1
	SMP:1.1.0.2;
locks; strict;
comment	@# @;


1.26
date	2013.05.17.22.35.19;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2013.01.05.11.20.56;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2009.05.02.14.32.29;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2009.02.13.23.28.55;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2008.10.30.22.06.02;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2007.11.06.21.44.39;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2007.10.28.10.16.20;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2007.10.24.21.02.00;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2007.10.13.12.54.45;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2007.10.10.15.53.52;	author art;	state Exp;
branches;
next	1.16;

1.16
date	2007.05.12.19.59.52;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2006.11.22.22.49.02;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2006.11.18.22.49.43;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2005.12.11.21.45.30;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2005.12.07.07.39.35;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2005.12.03.14.30.06;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2005.11.27.11.06.15;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2005.10.12.19.05.44;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2005.10.12.19.00.21;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2004.08.09.20.52.11;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2004.08.02.17.30.08;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2004.08.02.08.34.21;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2004.07.13.09.45.51;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2004.06.26.20.44.37;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.13.21.49.17;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	2004.04.29.14.33.27;	author miod;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2004.06.05.23.09.48;	author niklas;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2004.06.07.20.19.30;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.26
log
@Unnecessary include
@
text
@/*	$OpenBSD: process.S,v 1.25 2013/01/05 11:20:56 miod Exp $	*/
/*
 * Copyright (c) 1996 Nivas Madhur
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Nivas Madhur.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#include "assym.h"
#include <machine/asm.h>
#include <machine/psl.h>

/*
 * void cpu_switchto(struct proc *oldproc, struct proc *newproc)
 *
 * Switch context from oldproc to newproc. oldproc may be NULL if there is
 * no need to save the current context.
 *
 * Note that this code assumes that oldproc == curproc if not NULL.
 */
ENTRY(cpu_switchto)
	/*
	 * Save state of previous process in its pcb if required.
	 */
	bcnd	eq0,  %r2, 1f

	ldcr	%r2,  CPU
	ld	%r2,  %r2,  CI_CURPCB
	st	%r1,  %r2,  PCB_PC		/* save return address */
	bsr	_ASM_LABEL(__savectx)
	/* note that we don't need to recover r1 at this point */

	/* inline pmap_deactivate(oldproc) */
	ldcr	%r11, CPU
	st	%r0,  %r11, CI_CURPMAP

1:
	ldcr	%r2, PSR
	set	%r2, %r2, 1<PSR_INTERRUPT_DISABLE_BIT>
	stcr	%r2, PSR
	FLUSH_PIPELINE

	ldcr	%r11, CPU
	st	%r3,  %r11, CI_CURPROC			/* curproc = newproc */

	or	%r2,  %r0,  SONPROC
	st.b	%r2,  %r3,  P_STAT
#ifdef MULTIPROCESSOR
	st	%r11, %r3,  P_CPU			/* p->p_cpu = curcpu */
#endif
	ld	%r2,  %r3,  P_ADDR
	st	%r2,  %r11, CI_CURPCB			/* curpcb = p->p_addr */

	bsr.n	_C_LABEL(pmap_activate)		/* pmap_activate(newproc) */
	 or	%r2, %r0, %r3

	ldcr	%r2, PSR
	clr	%r2, %r2, 1<PSR_INTERRUPT_DISABLE_BIT>
	stcr	%r2, PSR
	FLUSH_PIPELINE

	ldcr	%r10,  CPU
	ld	%r10,  %r10, CI_CURPCB

	/* restore from the current context */
	ld.d	%r2,  %r10, PCB_FCR62
	fstcr	%r2,  %fcr62
	fstcr	%r3,  %fcr63
	ld	%r1,  %r10, PCB_PC
	ld.d	%r14, %r10, PCB_R14
	ld.d	%r16, %r10, PCB_R16
	ld.d	%r18, %r10, PCB_R18
	ld.d	%r20, %r10, PCB_R20
	ld.d	%r22, %r10, PCB_R22
	ld.d	%r24, %r10, PCB_R24
	ld.d	%r26, %r10, PCB_R26
	ld.d	%r28, %r10, PCB_R28
	jmp.n	%r1
	 ld.d	%r30, %r10, PCB_R30	/* restore frame pointer & stack */

/*
 * savectx(pcb)
 * Update pcb, saving current processor state.
 */
ENTRY(savectx)
	/*
	 * Save preserved general register set.
	 */
	st	%r1,  %r2,  PCB_PC		/* save return address */
ASLOCAL(__savectx)
	st.d	%r14, %r2,  PCB_R14
	st.d	%r16, %r2,  PCB_R16
	st.d	%r18, %r2,  PCB_R18
	st.d	%r20, %r2,  PCB_R20
	st.d	%r22, %r2,  PCB_R22
	st.d	%r24, %r2,  PCB_R24
	st.d	%r26, %r2,  PCB_R26
	st.d	%r28, %r2,  PCB_R28
	st.d	%r30, %r2,  PCB_R30	/* save frame pointer & stack pointer */

	/*
	 * Save FP state.
	 */
	fldcr	%r4,  %fcr62
	fldcr	%r5,  %fcr63
	jmp.n	%r1
	 st.d	%r4,  %r2, PCB_FCR62
@


1.25
log
@Switch m88k ports to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: process.S,v 1.24 2009/05/02 14:32:29 miod Exp $	*/
a35 1
#include <machine/intr.h>
@


1.24
log
@Drop the pm_cpus bitmask field from struct pmap, and instead remember the
currently active userland pmap in each processors struct cpu_info.

This thus skips the complete tlb flush if idle switches back to
the proc previously running on this processor.
@
text
@d1 1
a1 1
/*	$OpenBSD: process.S,v 1.23 2009/02/13 23:28:55 miod Exp $	*/
d50 1
a50 1
	bcnd	eq0, r2, 1f
d52 3
a54 3
	ldcr	r2,  CPU
	ld	r2,  r2,  CI_CURPCB
	st	r1,  r2,  PCB_PC		/* save return address */
d59 2
a60 2
	ldcr	r11, CPU
	st	r0,  r11, CI_CURPMAP
d63 3
a65 3
	ldcr	r2, PSR
	set	r2, r2, 1<PSR_INTERRUPT_DISABLE_BIT>
	stcr	r2, PSR
d68 2
a69 2
	ldcr	r11, CPU
	st	r3,  r11, CI_CURPROC			/* curproc = newproc */
d71 2
a72 2
	or	r2,  r0,  SONPROC
	st.b	r2,  r3,  P_STAT
d74 1
a74 1
	st	r11, r3,  P_CPU				/* p->p_cpu = curcpu */
d76 2
a77 2
	ld	r2,  r3,  P_ADDR
	st	r2,  r11, CI_CURPCB			/* curpcb = p->p_addr */
d80 1
a80 1
	 or	r2, r0, r3
d82 3
a84 3
	ldcr	r2, PSR
	clr	r2, r2, 1<PSR_INTERRUPT_DISABLE_BIT>
	stcr	r2, PSR
d87 2
a88 2
	ldcr	r10,  CPU
	ld	r10,  r10, CI_CURPCB
d91 14
a104 14
	ld.d	r2,  r10, PCB_FCR62
	fstcr	r2,  fcr62
	fstcr	r3,  fcr63
	ld	r1,  r10, PCB_PC
	ld.d	r14, r10, PCB_R14
	ld.d	r16, r10, PCB_R16
	ld.d	r18, r10, PCB_R18
	ld.d	r20, r10, PCB_R20
	ld.d	r22, r10, PCB_R22
	ld.d	r24, r10, PCB_R24
	ld.d	r26, r10, PCB_R26
	ld.d	r28, r10, PCB_R28
	jmp.n	r1
	 ld.d	r30, r10, PCB_R30	/* restore frame pointer & stack */
d114 1
a114 1
	st	r1,  r2,  PCB_PC		/* save return address */
d116 9
a124 9
	st.d	r14, r2,  PCB_R14
	st.d	r16, r2,  PCB_R16
	st.d	r18, r2,  PCB_R18
	st.d	r20, r2,  PCB_R20
	st.d	r22, r2,  PCB_R22
	st.d	r24, r2,  PCB_R24
	st.d	r26, r2,  PCB_R26
	st.d	r28, r2,  PCB_R28
	st.d	r30, r2,  PCB_R30	/* save frame pointer & stack pointer */
d129 4
a132 4
	fldcr	r4,  fcr62
	fldcr	r5,  fcr63
	jmp.n	r1
	 st.d	r4,  r2, PCB_FCR62
@


1.23
log
@When switching processes, do not reenable interrupts until pmap_activate()
has been invoked on the new process.
@
text
@d1 1
a1 1
/*	$OpenBSD: process.S,v 1.22 2008/10/30 22:06:02 miod Exp $	*/
d58 1
d60 1
a60 2
	bsr.n	_C_LABEL(pmap_deactivate)	/* pmap_deactivate(oldproc) */
	 ld	r2,  r11, CI_CURPROC
@


1.22
log
@In cpu_switchto(), always pmap_deactivate() the process being switched out,
even in non-MP kernels, to avoid unnecessary tlb flushes later when
pmap operates on shared pages.
@
text
@d1 1
a1 1
/*	$OpenBSD: process.S,v 1.21 2007/11/06 21:44:39 miod Exp $	*/
d79 3
a85 3

	bsr.n	_C_LABEL(pmap_activate)		/* pmap_activate(newproc) */
	 or	r2, r0, r3
@


1.21
log
@Be sure to pmap_deactivate() a process during context switches, so that
the cpu which runs it is accounted correctly in MP kernels.
@
text
@d1 1
a1 1
/*	$OpenBSD: process.S,v 1.20 2007/10/28 10:16:20 miod Exp $	*/
d43 2
a57 1
#ifdef MULTIPROCESSOR
a60 1
#endif
@


1.20
log
@Disable interrupts around changing curproc and curpcb so these always match.
@
text
@d1 1
a1 1
/*	$OpenBSD: process.S,v 1.19 2007/10/24 21:02:00 miod Exp $	*/
d56 6
d84 1
a84 2
	/* pmap_activate() the process' pmap */
	bsr.n	_C_LABEL(pmap_activate)
@


1.19
log
@Rely on 16 byte pcb alignment, and use double loads and stores during
context switches. Should have been commited ages ago (when pcb alignment
was fixed). No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: process.S,v 1.18 2007/10/13 12:54:45 miod Exp $	*/
d57 5
d72 5
@


1.18
log
@It is no longer necessary to fiddle with spl in cpu_idle_{enter,leave} now
that proc_trampoline has been fixed.
@
text
@d1 1
a1 1
/*	$OpenBSD: process.S,v 1.17 2007/10/10 15:53:52 art Exp $	*/
d76 1
a76 2
	ld	r2,  r10, PCB_FCR62
	ld	r3,  r10, PCB_FCR63
a78 17
	ld	r15, r10, PCB_R15
	ld	r16, r10, PCB_R16
	ld	r17, r10, PCB_R17
	ld	r18, r10, PCB_R18
	ld	r19, r10, PCB_R19
	ld	r20, r10, PCB_R20
	ld	r21, r10, PCB_R21
	ld	r22, r10, PCB_R22
	ld	r23, r10, PCB_R23
	ld	r24, r10, PCB_R24
	ld	r25, r10, PCB_R25
	ld	r26, r10, PCB_R26
	ld	r27, r10, PCB_R27
	ld	r28, r10, PCB_R28
	ld	r29, r10, PCB_R29
	ld	r30, r10, PCB_R30	/* restore frame pointer & stack */
	ld	r31, r10, PCB_SP
d80 8
d89 1
a89 1
	 ld	r14, r10, PCB_R14
d101 9
a109 18
	st	r14, r2,  PCB_R14
	st	r15, r2,  PCB_R15
	st	r16, r2,  PCB_R16
	st	r17, r2,  PCB_R17
	st	r18, r2,  PCB_R18
	st	r19, r2,  PCB_R19
	st	r20, r2,  PCB_R20
	st	r21, r2,  PCB_R21
	st	r22, r2,  PCB_R22
	st	r23, r2,  PCB_R23
	st	r24, r2,  PCB_R24
	st	r25, r2,  PCB_R25
	st	r26, r2,  PCB_R26
	st	r27, r2,  PCB_R27
	st	r28, r2,  PCB_R28
	st	r29, r2,  PCB_R29
	st	r30, r2,  PCB_R30	/* save frame pointer & stack pointer */
	st	r31, r2,  PCB_SP
a115 1
	st	r4,  r2, PCB_FCR62
d117 1
a117 1
	 st	r5,  r2, PCB_FCR63
@


1.17
log
@Make context switching much more MI:
 - Move the functionality of choosing a process from cpu_switch into
   a much simpler function: cpu_switchto. Instead of having the locore
   code walk the run queues, let the MI code choose the process we
   want to run and only implement the context switching itself in MD
   code.
 - Let MD context switching run without worrying about spls or locks.
 - Instead of having the idle loop implemented with special contexts
   in MD code, implement one idle proc for each cpu. make the idle
   loop MI with MD hooks.
 - Change the proc lists from the old style vax queues to TAILQs.
 - Change the sleep queue from vax queues to TAILQs. This makes
   wakeup() go from O(n^2) to O(n)

there will be some MD fallout, but it will be fixed shortly.
There's also a few cleanups to be done after this.

deraadt@@, kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: process.S,v 1.16 2007/05/12 19:59:52 miod Exp $	*/
a36 24

/*
 * void cpu_idle_enter()
 *
 * Enable all interrupts and lower spl. This actually enables interrupts
 * in the psr; bootstrap of secondary processors depends on this.
 */
ENTRY(cpu_idle_enter)
	ldcr	r2, PSR
	clr	r2, r2, 1<PSR_INTERRUPT_DISABLE_BIT>
	stcr	r2, PSR
	FLUSH_PIPELINE

	br.n	_C_LABEL(setipl)
	 or	r2, r0, IPL_NONE

/*
 * void cpu_idle_leave()
 *
 * Raise ipl to IPL_SCHED, but do not attempt to disable interrupts.
 */
ENTRY(cpu_idle_leave)
	br.n	_C_LABEL(setipl)
	 or	r2, r0, IPL_SCHED
@


1.16
log
@On multiprocessor kernels, update p->p_pcu on exit from the scheduler.
@
text
@d1 1
a1 1
/*	$OpenBSD: process.S,v 1.15 2006/11/22 22:49:02 miod Exp $	*/
a37 24
#ifdef DIAGNOSTIC
	data
	align	4
ASLOCAL(swchanpanic)
	string	"switch wchan %x\0"
	align	4
ASLOCAL(swsrunpanic)
	string	"switch SRUN %x\0"

	text
	align	8
ASLOCAL(Lswchanpanic)
	or.u	r2, r0, hi16(_ASM_LABEL(swchanpanic))
	or	r2, r2, lo16(_ASM_LABEL(swchanpanic))
	bsr.n	_C_LABEL(panic)
	 or	r3, r0, r9

ASLOCAL(Lswsrunpanic)
	or.u	r2, r0, hi16(_ASM_LABEL(swsrunpanic))
	or	r2, r2, lo16(_ASM_LABEL(swsrunpanic))
	bsr.n	_C_LABEL(panic)
	 or	r3, r0, r9
#endif

d39 1
a39 1
 * void switch_exit(struct proc *p)
d41 2
a42 3
 * Do the final work to exit from a process. After switching to the
 * idle stack and pcb, invoke exit2() on behalf of the exiting process,
 * then continue into cpu_switch() to select another process to run.
d44 4
a47 9

ENTRY(switch_exit)
	/*
	 * Disable interrupts since we are about to change the kernel
	 * stack.
	 */
	ldcr	r3, PSR
	set	r3, r3, 1<PSR_INTERRUPT_DISABLE_BIT>
	stcr	r3, PSR
d50 2
a51 13
	/*
	 * Change pcb to idle u. area, i.e., set r31 to top of stack
	 * and set curpcb to point to the cpu's idle stack.
	 * r2 contains proc *p.
	 */
	ldcr	r10, CPU
	ld	r30, r10, CI_IDLE_PCB
	addu	r31, r30, USIZE				/* now on idle stack */
	st	r30, r10, CI_CURPCB			/* curpcb = idle_pcb */

	/* Schedule the vmspace and stack to be freed. */
	bsr.n	_C_LABEL(exit2)
	 st	r0, r10, CI_CURPROC			/* curproc = NULL */
d53 8
a60 6
	/*
	 * exit2() has acquired the scheduler lock for us. Jump into
	 * cpu_switch(), after the context save since we do not need
	 * to save anything.
	 */
	br	_ASM_LABEL(cpu_switch_search)
d63 1
a63 4
 * void cpu_switch(struct proc *p)
 *
 * Find a runnable process and switch to it. On entry, the scheduler lock is
 * held; it has to be released before returning to the process.
d65 2
a66 3
 * Note that this code ignores its proc parameter and assumes it has the
 * same value as curproc. This may change in mi_switch() in the future,
 * be careful.
d68 1
a68 1
ENTRY(cpu_switch)
d70 1
a70 2
	 * Disable interrupts, we do not want to be disturbed while
	 * saving context.
d72 1
a72 4
	ldcr	r2, PSR
	set	r2, r2, 1<PSR_INTERRUPT_DISABLE_BIT>
	stcr	r2, PSR
	FLUSH_PIPELINE
a73 4
	/*
	 * Save state of previous process in its pcb, and pmap_deactivate()
	 * the process.
	 */
d80 1
d82 1
a82 127
	ld	r2,  r11, CI_CURPROC

	/*
	 * Note that we can still use curpcb as our stack after
	 * pmap_deactivate() has been called, as it does not affect the u
	 * area mappings.
	 */
	bsr.n	_C_LABEL(pmap_deactivate)
	 st	r0,  r11, CI_CURPROC		/* curproc = NULL */

#ifdef MULTIPROCESSOR
	/*
	 * We need to switch to the processor's idle stack now (in case the
	 * process we are using the stack of gets scheduled on another
	 * processor).
	 */
	ldcr	r10, CPU
	ld	r30, r10, CI_IDLE_PCB
	addu	r31, r30, USIZE				/* now on idle stack */
	st	r30, r10, CI_CURPCB			/* curpcb = idle_pcb */
#endif

ASLOCAL(cpu_switch_search)
	/*
	 * This is the start of the idle loop. Find the highest-priority
	 * queue that isn't empty, then take the first proc from that queue.
	 */
	or.u	r7, r0, hi16(_C_LABEL(whichqs))
	ld	r7, r7, lo16(_C_LABEL(whichqs))
	bcnd	ne0, r7, _ASM_LABEL(cpu_switch_found)

#if defined(MULTIPROCESSOR) || defined(LOCKDEBUG)
	bsr	_C_LABEL(sched_unlock_idle)
#endif

#ifdef MULTIPROCESSOR
ASGLOBAL(cpu_switch_idle)
#else
ASLOCAL(cpu_switch_idle)
#endif
	/*
	 * There were no runnable processes. Enable all interrupts and
	 * busy-wait for this to change.
	 * Note that, besides doing setipl(IPL_NONE), this will actually enable
	 * interrupts in the psr. Bootstrap of secondary processors
	 * relies upon this.
	 */
	ldcr	r2, PSR
	clr	r2, r2, 1<PSR_INTERRUPT_DISABLE_BIT>
	stcr	r2, PSR
	FLUSH_PIPELINE

	bsr.n	_C_LABEL(setipl)
	 or	r2, r0, IPL_NONE

	or.u	r7, r0, hi16(_C_LABEL(whichqs))
	ld	r7, r7, lo16(_C_LABEL(whichqs))
	bcnd	eq0, r7, _ASM_LABEL(cpu_switch_idle)
	/* XXX run fancy things here, such as page zeroing... */

#if defined(MULTIPROCESSOR) || defined(LOCKDEBUG)
	bsr	_C_LABEL(sched_lock_idle)
#endif

ASLOCAL(cpu_switch_found)
	/*
	 * Disable interrupts.
	 */
	ldcr	r2, PSR
	set	r2, r2, 1<PSR_INTERRUPT_DISABLE_BIT>
	stcr	r2, PSR
	FLUSH_PIPELINE

	/*
	 * An interrupt could have occured between the last whichqs check
	 * and the call to setipl(). Check again that whichqs is nonzero.
	 */
	or.u	r7, r0, hi16(_C_LABEL(whichqs))	/* reload whichqs */
	ld	r7, r7, lo16(_C_LABEL(whichqs))
	bcnd	eq0, r7, _ASM_LABEL(cpu_switch_search)

	/* XXX use ff1, like powerpc... needs *runqueue() adjustments */
	xor	r6, r6, r6		/* set r6 to 0 */
1:	bb1	0,  r7, 2f		/* if rightmost bit set, done */
	extu	r7, r7, 0<1>		/* else, right shift whichqs, */
	br.n	1b			/* increment r6, and repeat */
	 addu	r6, r6, 1
2:
	or.u	r7, r0, hi16(_C_LABEL(qs))
	or	r7, r7, lo16(_C_LABEL(qs))

	/*
	 * Need to make
	 *	p->p_forw->p_back = p->p_back and
	 *	p->p_back->p_forw = p->p_forw where
	 *	p is q->p_forw.
	 * Remember that q->p_forw == p and p->p_back == q.
	 */

	lda.d	r8,  r7[r6]	/* r8 = &qs[ff1(whichqs)] */
	ld	r9,  r8, P_FORW	/* r8 is q, r9 is p */

	ld	r12, r9, P_FORW	/* r12 = p->p_forw */
	st	r8, r12, P_BACK	/* p->p_forw->p_back = q (p->p_back) */
	st	r12, r8, P_FORW	/* q->p_forw = p->p_forw */
	lda.d	r8,  r7[r6]	/* reload r8 with qs[ff1(whichqs)] */
	ld	r12, r8, P_FORW	/* q->p_forw */
	cmp	r12, r12, r8	/* q == q->p_forw; anyone left on queue? */
	bb1	ne,  r12, 3f	/* yes, skip clearing bit in whichqs  */

	or	r12, r0, 1
	mak	r12, r12, r6
	or.u	r7,  r0, hi16(_C_LABEL(whichqs))
	ld	r8,  r7, lo16(_C_LABEL(whichqs))
	and.c	r8,  r8, r12	/* whichqs &= ~the bit */
	st	r8,  r7, lo16(_C_LABEL(whichqs))
3:
#ifdef DIAGNOSTIC
	ld	r2, r9, P_WCHAN
	bcnd	ne0, r2, _ASM_LABEL(Lswchanpanic)
	ld.b	r2, r9, P_STAT
	cmp	r2, r2, SRUN
	bb1	ne, r2, _ASM_LABEL(Lswsrunpanic)
#endif

	ldcr	r11, CPU
	st	r0,  r11, CI_WANT_RESCHED		/* clear want_resched */
a83 1
	st	r9,  r11, CI_CURPROC			/* curproc = p */
d85 1
a85 1
	st.b	r2,  r9,  P_STAT
d87 1
a87 1
	st	r11, r9,  P_CPU				/* p->p_cpu = curcpu */
d89 2
a90 4

	ld	r3,  r9,  P_ADDR
	st	r0,  r9,  P_BACK			/* p->p_back = 0 */
	st	r3,  r11, CI_CURPCB			/* curpcb = p->p_addr */
d94 1
a94 1
	 or	r2, r0, r9
a120 6
#if defined(MULTIPROCESSOR) || defined(LOCKDEBUG)
	bsr.n	_C_LABEL(sched_unlock_idle)
	 or	r14, r10, r0
	ld	r1,  r14, PCB_PC
	ld	r14, r14, PCB_R14
#else
d122 2
a123 12
	ld	r14, r10, PCB_R14
#endif

	/*
	 * Enable interrupts again.
	 */
	ldcr	r2, PSR
	clr	r2, r2, 1<PSR_INTERRUPT_DISABLE_BIT>
	stcr	r2, PSR
	FLUSH_PIPELINE

	jmp	r1
@


1.15
log
@Be more generous with interrupt disabling in the scheduler.
@
text
@d1 1
a1 1
/*	$OpenBSD: process.S,v 1.14 2006/11/18 22:49:43 miod Exp $	*/
d263 3
@


1.14
log
@Stop saving and restoring the current ipl in the pcb when switching processes,
since we know we are at splsched().
@
text
@d1 1
a1 1
/*	$OpenBSD: process.S,v 1.13 2005/12/11 21:45:30 miod Exp $	*/
d72 9
d113 9
d142 12
d169 2
a179 1
	bb0	PSR_INTERRUPT_DISABLE_BIT, r2, 2f
d183 1
a183 1
2:
d189 1
a189 1
	bcnd	eq0, r7, 2b
d197 7
a203 2
	bsr.n	_C_LABEL(setipl)		/* disable interrupts */
	 or	r2, r0, IPL_HIGH
a294 1
	ld	r1,  r10, PCB_PC
d298 4
a301 2
	br.n	_C_LABEL(sched_unlock_idle)
	 ld	r14, r10, PCB_R14
d303 2
a304 2
	jmp.n	r1
	 ld	r14, r10, PCB_R14
d306 10
@


1.13
log
@Work in progress SMP code; mvme88k boards can spin up secondary CPUs,
kernel boots single user. Still a lot of polishing and bugfixing to do.
@
text
@d1 1
a1 1
/*	$OpenBSD: process.S,v 1.12 2005/12/07 07:39:35 miod Exp $	*/
d90 1
a90 1
	bsr	_ASM_LABEL(cpu_switch_search)
d259 3
a261 6
	or	r14, r10, r0		/* preserve curpcb in a register... */
	bsr.n	_C_LABEL(setipl)
	 ld	r2,  r10, PCB_IPL	/* restore interrupt mask */
	ld	r1,  r14, PCB_PC
	ld	r30, r14, PCB_R30	/* restore frame pointer & stack */
	ld	r31, r14, PCB_SP
d264 1
d267 1
a268 1
	 ld	r14, r14, PCB_R14
a299 13
	 * Get the current spl.
	 * We need to save r1 on the stack because we don't know if we were
	 * called as savectx or __savectx.
	 */
	subu	r31, r31, 16		/* allocate stack for r1 and args */
	st	r1,  r31, 0
	bsr.n	_C_LABEL(getipl)	/* get the current interrupt mask */
	 or	r14, r0,  r2
	st	r2,  r14, PCB_IPL	/* save interrupt mask */
	ld	r1,  r31, 0		/* recover return address */
	addu	r31, r31, 16		/* put stack pointer back */

	/*
d302 3
a304 4
	fldcr	r2,  fcr62
	fldcr	r3,  fcr63
	st	r2,  r14, PCB_FCR62
	st	r3,  r14, PCB_FCR63
d306 1
a306 1
	 ld	r14, r14, PCB_R14	/* preserve r14 */
@


1.12
log
@Better use of the scheduler lock; no functional change on UP kernels.
@
text
@d1 1
a1 1
/*	$OpenBSD: process.S,v 1.11 2005/12/03 14:30:06 miod Exp $	*/
a123 3
#ifdef MULTIPROCESSOR
ASGLOBAL(cpu_switch_search)
#else
a124 6
#endif

#if defined(MULTIPROCESSOR) || defined(LOCKDEBUG)
	bsr	_C_LABEL(sched_unlock_idle)
#endif

d133 7
a139 1
ASLOCAL(cpu_switch_idle)
d143 1
a143 1
	 * Note that, besides doing spl0(), this will actually enable
a146 3
	bsr.n	_C_LABEL(setipl)
	 or	r2, r0, IPL_NONE

d148 1
a148 2
	bb0.n	PSR_INTERRUPT_DISABLE_BIT, r2, 2f
	 or.u	r7, r0, hi16(_C_LABEL(whichqs))
d153 4
d158 1
a158 1
	bcnd	eq0, r7, _ASM_LABEL(cpu_switch_idle)
d161 4
a168 4
#if defined(MULTIPROCESSOR) || defined(LOCKDEBUG)
	bsr	_C_LABEL(sched_lock_idle)
#endif

a174 1
#if defined(MULTIPROCESSOR) || defined(LOCKDEBUG)
a175 3
#else
	bcnd	eq0, r7, _ASM_LABEL(cpu_switch_idle)
#endif
a235 4
#if defined(MULTIPROCESSOR) || defined(LOCKDEBUG)
	bsr	_C_LABEL(sched_unlock_idle)
#endif

d265 3
a267 1

d269 1
@


1.11
log
@Switch m88k ports to __HAVE_CPUINFO. Current cpu pointer is held in SR0
on all running processors.
Tested aoyama@@ and I
@
text
@d1 1
a1 1
/*	$OpenBSD: process.S,v 1.10 2005/11/27 11:06:15 miod Exp $	*/
d63 5
a67 5
 * At exit of a process, do a cpu_switch for the last time.
 * The mapping of the pcb at p->p_addr has already been deleted,
 * and the memory for the pcb+stack has been freed.
 * The ipl is high enough to prevent the memory from being reallocated.
 * switch_exit(proc *p)
d124 3
d128 6
d156 1
a156 1
	clr	r2, r2, 1<PSR_INTERRUPT_DISABLE_BIT>	/* ...and enable them */
d168 4
d178 3
d182 1
@


1.10
log
@In the core of the idle loop, be sure to invoke spl0 more than once to
process soft interrupts; fixes luna88k hanging after the rootdev line.
Tested aoyama@@ martin@@ and I
@
text
@d1 1
a1 1
/*	$OpenBSD: process.S,v 1.9 2005/10/12 19:05:44 miod Exp $	*/
d73 1
a73 1
	 * and set curpcb to point to _idle_u.
d76 4
a79 5
	or.u	r30, r0, hi16(_C_LABEL(idle_u))
	or	r30, r30,lo16(_C_LABEL(idle_u))
	addu	r31, r30, USIZE			/* now on idle_u stack */
	or.u	r10, r0, hi16(_C_LABEL(curpcb))
	st	r30, r10,lo16(_C_LABEL(curpcb))		/* curpcb = &idle_u */
a81 1
	or.u	r10, r0, hi16(_C_LABEL(curproc))
d83 1
a83 1
	 st	r0, r10, lo16(_C_LABEL(curproc))	/* curproc = NULL */
d97 4
d107 3
a109 3
	or.u	r2, r0, hi16(_C_LABEL(curpcb))
	ld	r2, r2, lo16(_C_LABEL(curpcb))
	st	r1, r2, PCB_PC		/* save return address */
d113 2
a114 2
	or.u	r11, r0, hi16(_C_LABEL(curproc))
	ld	r2, r11, lo16(_C_LABEL(curproc))
d122 1
a122 1
	 st	r0, r11, lo16(_C_LABEL(curproc))	/* curproc = NULL */
d211 2
a212 2
	or.u	r11, r0, hi16(_C_LABEL(want_resched))
	st	r0, r11, lo16(_C_LABEL(want_resched))	/* clear want_resched */
d214 7
a220 10
	or.u	r11, r0, hi16(_C_LABEL(curproc))
	st	r9,  r11,lo16(_C_LABEL(curproc))	/* curproc = p */
	or	r2, r0, SONPROC
	st.b	r2, r9, P_STAT

	/*  r9 is curproc */
	st	r0, r9, P_BACK				/* p->p_back = 0 */
	ld	r3, r9, P_ADDR
	or.u	r10, r0, hi16(_C_LABEL(curpcb))
	st	r3, r10, lo16(_C_LABEL(curpcb))		/* curpcb = p->p_addr */
a222 1
	or	r14, r0, r9		/* save p in r14 */
a224 1
	or	r9, r0, r14		/* restore p saved in r14 */
d230 2
a231 2
	or.u	r10, r0,  hi16(_C_LABEL(curpcb))
	ld	r10, r10,  lo16(_C_LABEL(curpcb))
d234 20
a253 20
	ld	r2, r10, PCB_FCR62
	ld	r3, r10, PCB_FCR63
	fstcr	r2, fcr62
	fstcr	r3, fcr63
	ld	r15,r10, PCB_R15
	ld	r16,r10, PCB_R16
	ld	r17,r10, PCB_R17
	ld	r18,r10, PCB_R18
	ld	r19,r10, PCB_R19
	ld	r20,r10, PCB_R20
	ld	r21,r10, PCB_R21
	ld	r22,r10, PCB_R22
	ld	r23,r10, PCB_R23
	ld	r24,r10, PCB_R24
	ld	r25,r10, PCB_R25
	ld	r26,r10, PCB_R26
	ld	r27,r10, PCB_R27
	ld	r28,r10, PCB_R28
	ld	r29,r10, PCB_R29
	or	r14,r10, r0		/* preserve curpcb in a register... */
d255 4
a258 4
	 ld	r2, r10, PCB_IPL	/* restore interrupt mask */
	ld	r1, r14, PCB_PC
	ld	r30,r14, PCB_R30	/* restore frame pointer & stack */
	ld	r31,r14, PCB_SP
d261 1
a261 1
	 ld	r14,r14, PCB_R14
@


1.9
log
@Stop mapping the u area at fixed UADDR in addition to its actual va.
While there, attempt to clean and comment stack usage in the kernel.
No functional change.

From the m88k SMP tree; help&test martin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: process.S,v 1.8 2005/10/12 19:00:21 miod Exp $	*/
d67 1
a67 1
 * switch_exit(proc * p)
d130 2
a131 1
1:
d150 1
a150 1
	bcnd	eq0, r7, 2b
d163 1
a163 1
	bcnd	eq0, r7, 1b
a227 1

@


1.8
log
@General scheduler cleanup:
- at the end of switch_exit(), jump in a better location inside cpu_switch()
- skip unnecessary curproc == NULL tests, and remove other dead code
- simplify the idle loop
- optimize whichqs bit operations
- and add comments at strategic places

help&test martin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: process.S,v 1.7 2004/08/09 20:52:11 miod Exp $	*/
a227 9
	/*
	 * Since we are about to replace the u area mapping, we need to
	 * switch to a neutral stack now.
	 */
	or.u	r31, r0, hi16(_ASM_LABEL(intstack_end))
	or	r31,r31, lo16(_ASM_LABEL(intstack_end))

	bsr.n    _C_LABEL(load_u_area)
	 or	r2, r0, r9
@


1.7
log
@Take advantage of the recent ABI change to use less stack space and do
less stack pointer manipulation; the kernel needs to be compiled by an
up-to-date compiler now, or a tree will fall on your house.
@
text
@d1 1
a1 1
/*	$OpenBSD: process.S,v 1.6 2004/08/02 17:30:08 miod Exp $	*/
d38 1
a45 5
#ifdef DEBUG
	align	4
ASLOCAL(boguspsr)
	string	"Invalid PSR in idle loop 0x%x\n\0"
#endif
d60 1
d73 2
a74 1
	 * and set curpcb to point to _idle_u.  r2 contains proc *p.
d86 7
a92 1
	bsr	_C_LABEL(cpu_switch)	/* goto final switch */
d95 4
a98 4
 * cpu_switch()
 * XXX - Arg 1 is a proc pointer (curproc) but this doesn't use it.
 * XXX - how about using stack for saving spl and last proc?
 * XXX rewrite this whole mess in C nivas
a100 1

d102 2
a103 1
	 * Save state of previous process in its pcb.
a112 1
	bcnd	eq0, r2, 1f
d114 7
a120 7
	bsr	_C_LABEL(pmap_deactivate)
	or.u	r11, r0, hi16(_C_LABEL(curproc))

1:
	st	r0, r11, lo16(_C_LABEL(curproc))	/* curproc = NULL */

ASLOCAL(Lidleloop)
d122 1
d124 2
a125 2
	 * Find the highest-priority queue that isn't empty,
	 * then take the first proc from that queue.
a126 1

d129 10
a138 5

	bcnd	ne0, r7, _ASM_LABEL(Ldoneloop)

ASLOCAL(Lloopchk)			/* if whichqs is zero, keep checking */
	bsr.n	_C_LABEL(setipl)	/* unmask all ints... */
d142 2
a143 8
	bb0	PSR_INTERRUPT_DISABLE_BIT, r2, 1f
#ifdef DEBUG
	or	r3, r2, r0
	or.u	r2, r0, hi16(_ASM_LABEL(boguspsr))
	bsr.n	_C_LABEL(printf)
	 or	r2, r2, lo16(_ASM_LABEL(boguspsr))
	ldcr	r2, PSR
#endif
d147 4
a150 4
1:
	br	_ASM_LABEL(Lidleloop)

ASLOCAL(Ldoneloop)
d152 2
a153 1
	bsr.n	_C_LABEL(setipl)	/* disable ints */
d156 4
d162 1
d164 1
a164 2
	bcnd	eq0, r7, _ASM_LABEL(Lloopchk)	/* keep spinning for whichqs to be != 0 */

d171 2
a172 2
	or.u	r7, r0, hi16(_qs)
	or	r7, r7, lo16(_qs)
d193 2
a194 12
	or	r12, r0, 1	/* r12 is 1 now */
1:	bcnd	eq0, r6, 2f
	mak	r12, r12, 0<1>	/* shift left by 1 */
	br.n	1b
	 subu	r6,  r6, 1	/* keep doing this while r6 != 0 */
2:
	/*
	 * NOTE: we could have just used "mak r12, r12, r6" instead of the
	 * loop above. But that will break if NQS is made > 32. I can use
	 * preprocessor to do the right thing, but that means I have to
	 * include sys/proc.h in this file. XXX nivas
	 */
d200 1
d206 1
d217 1
a217 1
	st	r0, r9, P_BACK			/* p->p_back = 0 */
d228 4
d234 1
d238 4
a243 2
	/* XXX Is this correct/necessary? */
	st	r10, r14, P_ADDR	/* p->p_addr = curpcb; restore p_addr */
d271 1
a271 1
	ld	r14,r14, PCB_R14
d273 1
a273 1
	 or	r2, r0, 1		/* return 1 (for alternate returns) */
@


1.6
log
@No need to make __savectx visible and 8-byte aligned.
@
text
@d1 1
a1 1
/*	$OpenBSD: process.S,v 1.5 2004/08/02 08:34:21 miod Exp $	*/
a82 2
	or.u	r10, r0, hi16(_C_LABEL(curproc))
	st	r0, r10, lo16(_C_LABEL(curproc))	/* curproc = NULL */
d85 1
d87 1
a87 2
	 subu	r31, r31, 48		/* allocate stack  */
	addu	r31, r31, 48		/* restore stack */
d111 1
a111 3
	bsr.n	_C_LABEL(pmap_deactivate)
	 subu	r31, r31,48
	addu    r31, r31,48
a223 1
	or	r2, r0, r9		/* r2 = p */
d226 1
a226 2
	 subu	r31, r31,48
	addu    r31, r31,48
a230 1
	subu	r31, r31,48
a232 1
	addu	r31, r31,48
a259 1
	subu	r31,r31,32
a261 1
	addu	r31,r31,32
d303 2
a304 2
	subu	r31, r31, 40		/* allocate stack for r1 and args */
	st	r1,  r31, 32
d308 2
a309 2
	ld	r1,  r31, 32		/* recover return address */
	addu	r31, r31, 40		/* put stack pointer back */
@


1.5
log
@When restoring a process' ipl, invoke setipl() on behalf on the kernel stack,
rather than on the process stack.
@
text
@d1 1
a1 1
/*	$OpenBSD: process.S,v 1.4 2004/07/13 09:45:51 miod Exp $	*/
a286 1
	NOP
d288 1
a288 1
ASENTRY(__savectx)
@


1.4
log
@Do not trash r14 by mistake in __savectx.
@
text
@d1 1
a1 1
/*	$OpenBSD: process.S,v 1.3 2004/06/26 20:44:37 miod Exp $	*/
a251 2
	ld	r1, r10, PCB_PC
	ld	r14,r10, PCB_R14
d267 2
a268 9
	ld	r30,r10, PCB_R30	/* restore frame pointer & stack */
	ld	r31,r10, PCB_SP

/* XXX
 * Should we postpone restoring stack till after ipl is restored?
 * The stack access could fault
 */
	subu	r31,r31,48
	st	r1, r31,36		/* save r1 on stack */
d271 5
a275 2
	ld	r1, r31,36		/* restore r1 from stack */
	addu	r31,r31,48
@


1.3
log
@Fix alignment problem between savectx and __savectx. How could this have
ever worked?
@
text
@d1 1
a1 1
/*	$OpenBSD: process.S,v 1.2 2004/06/13 21:49:17 niklas Exp $	*/
d334 1
d336 1
a336 1
	 st	r3,  r14, PCB_FCR63
@


1.2
log
@debranch SMP, have fun
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d293 1
@


1.1
log
@Continue factorizing m88k common code, this time files in <arch>/<arch>
which were copied verbatim from mvme88k to luna88k.

This requires backing out syntactic sugar in mvme88k kernel configuration
files which would deduct the required processor types from the board models,
as the common code only depends upon the M88100 and M88110 defines.
@
text
@d1 1
a1 1
/*	$OpenBSD: process.S,v 1.29 2004/01/17 22:35:41 miod Exp $	*/
d218 2
@


1.1.2.1
log
@Merge with the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.1.2.2
log
@SONPROC, ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: process.S,v 1.1.2.1 2004/06/05 23:09:48 niklas Exp $	*/
a217 2
	or	r2, r0, SONPROC
	st.b	r2, r9, P_STAT
@


