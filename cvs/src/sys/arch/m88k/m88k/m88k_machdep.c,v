head	1.68;
access;
symbols
	OPENBSD_6_1:1.67.0.4
	OPENBSD_6_1_BASE:1.67
	OPENBSD_6_0:1.64.0.8
	OPENBSD_6_0_BASE:1.64
	OPENBSD_5_9:1.64.0.4
	OPENBSD_5_9_BASE:1.64
	OPENBSD_5_8:1.64.0.6
	OPENBSD_5_8_BASE:1.64
	OPENBSD_5_7:1.64.0.2
	OPENBSD_5_7_BASE:1.64
	OPENBSD_5_6:1.63.0.4
	OPENBSD_5_6_BASE:1.63
	OPENBSD_5_5:1.58.0.4
	OPENBSD_5_5_BASE:1.58
	OPENBSD_5_4:1.57.0.2
	OPENBSD_5_4_BASE:1.57
	OPENBSD_5_3:1.55.0.2
	OPENBSD_5_3_BASE:1.55
	OPENBSD_5_2:1.52.0.2
	OPENBSD_5_2_BASE:1.52
	OPENBSD_5_1_BASE:1.51
	OPENBSD_5_1:1.51.0.6
	OPENBSD_5_0:1.51.0.4
	OPENBSD_5_0_BASE:1.51
	OPENBSD_4_9:1.51.0.2
	OPENBSD_4_9_BASE:1.51
	OPENBSD_4_8:1.50.0.6
	OPENBSD_4_8_BASE:1.50
	OPENBSD_4_7:1.50.0.2
	OPENBSD_4_7_BASE:1.50
	OPENBSD_4_6:1.50.0.4
	OPENBSD_4_6_BASE:1.50
	OPENBSD_4_5:1.46.0.4
	OPENBSD_4_5_BASE:1.46
	OPENBSD_4_4:1.41.0.4
	OPENBSD_4_4_BASE:1.41
	OPENBSD_4_3:1.41.0.2
	OPENBSD_4_3_BASE:1.41
	OPENBSD_4_2:1.21.0.2
	OPENBSD_4_2_BASE:1.21
	OPENBSD_4_1:1.17.0.2
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.16.0.2
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.13.0.2
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.3.0.2
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.2.0.2
	OPENBSD_3_7_BASE:1.2;
locks; strict;
comment	@ * @;


1.68
date	2017.05.29.14.19.50;	author mpi;	state Exp;
branches;
next	1.67;
commitid	4u6PWvBw90PH7UDq;

1.67
date	2017.03.19.10.57.29;	author miod;	state Exp;
branches;
next	1.66;
commitid	VsXOX1rAnPUup9UH;

1.66
date	2016.10.09.20.16.50;	author guenther;	state Exp;
branches;
next	1.65;
commitid	400y9j1UZ2FMv1et;

1.65
date	2016.10.09.11.25.40;	author tom;	state Exp;
branches;
next	1.64;
commitid	DfYvEDcFmu1LY9q1;

1.64
date	2015.02.11.07.05.39;	author dlg;	state Exp;
branches;
next	1.63;
commitid	JTpbkhDknrIuy9pn;

1.63
date	2014.07.15.16.28.11;	author miod;	state Exp;
branches;
next	1.62;
commitid	pnmOuL5y6GMpBFWc;

1.62
date	2014.06.09.16.22.47;	author miod;	state Exp;
branches;
next	1.61;
commitid	T0i2K7JCYBgHxLKq;

1.61
date	2014.05.31.11.19.56;	author miod;	state Exp;
branches;
next	1.60;

1.60
date	2014.05.08.22.17.33;	author miod;	state Exp;
branches;
next	1.59;

1.59
date	2014.03.29.18.09.29;	author guenther;	state Exp;
branches;
next	1.58;

1.58
date	2013.10.07.19.10.49;	author miod;	state Exp;
branches;
next	1.57;

1.57
date	2013.07.17.19.18.15;	author miod;	state Exp;
branches;
next	1.56;

1.56
date	2013.05.15.20.18.04;	author miod;	state Exp;
branches;
next	1.55;

1.55
date	2013.02.17.18.07.36;	author miod;	state Exp;
branches;
next	1.54;

1.54
date	2013.01.26.20.47.08;	author miod;	state Exp;
branches;
next	1.53;

1.53
date	2013.01.05.11.20.56;	author miod;	state Exp;
branches;
next	1.52;

1.52
date	2012.03.23.15.51.26;	author guenther;	state Exp;
branches;
next	1.51;

1.51
date	2010.12.23.20.05.08;	author miod;	state Exp;
branches;
next	1.50;

1.50
date	2009.04.19.17.56.13;	author miod;	state Exp;
branches;
next	1.49;

1.49
date	2009.03.15.20.39.53;	author miod;	state Exp;
branches;
next	1.48;

1.48
date	2009.03.04.19.37.15;	author miod;	state Exp;
branches;
next	1.47;

1.47
date	2009.03.04.05.59.08;	author miod;	state Exp;
branches;
next	1.46;

1.46
date	2009.02.20.20.40.01;	author miod;	state Exp;
branches;
next	1.45;

1.45
date	2009.02.18.21.07.59;	author miod;	state Exp;
branches;
next	1.44;

1.44
date	2009.02.16.23.03.33;	author miod;	state Exp;
branches;
next	1.43;

1.43
date	2008.12.21.21.43.52;	author miod;	state Exp;
branches;
next	1.42;

1.42
date	2008.11.27.20.46.48;	author miod;	state Exp;
branches;
next	1.41;

1.41
date	2007.12.26.22.21.39;	author miod;	state Exp;
branches;
next	1.40;

1.40
date	2007.12.15.19.33.34;	author miod;	state Exp;
branches;
next	1.39;

1.39
date	2007.12.09.19.57.50;	author miod;	state Exp;
branches;
next	1.38;

1.38
date	2007.12.05.22.09.14;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2007.12.04.05.39.42;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2007.12.02.21.23.18;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2007.12.02.21.21.30;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2007.11.22.05.42.50;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2007.11.20.21.47.12;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2007.11.17.05.36.23;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2007.11.15.21.27.22;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2007.11.15.21.24.14;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2007.11.14.23.12.46;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2007.11.09.17.08.44;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2007.11.06.21.48.44;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2007.11.06.21.42.56;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2007.10.29.19.57.48;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2007.10.28.19.42.11;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2007.10.24.20.54.53;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2007.10.10.15.53.52;	author art;	state Exp;
branches;
next	1.21;

1.21
date	2007.05.29.18.10.42;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2007.05.19.20.34.34;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2007.05.18.16.35.02;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2007.04.18.21.21.20;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2006.11.22.22.47.46;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2006.05.08.14.36.09;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2006.05.08.14.03.34;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2006.04.15.15.43.33;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2005.12.11.21.36.06;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2005.12.04.12.12.17;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2005.12.03.19.06.11;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2005.12.03.14.30.06;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2005.11.28.22.22.55;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2005.11.06.17.58.20;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2005.10.13.19.48.33;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2005.10.12.19.30.28;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2005.10.12.19.05.44;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2005.09.25.20.55.14;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2005.04.30.16.44.08;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2004.09.30.21.48.56;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2004.09.30.14.55.54;	author miod;	state Exp;
branches;
next	;


desc
@@


1.68
log
@Kill SPINLOCK_SPIN_HOOK, use CPU_BUSY_CYCLE() instead.

ok visa@@, kettenis@@
@
text
@/*	$OpenBSD: m88k_machdep.c,v 1.67 2017/03/19 10:57:29 miod Exp $	*/
/*
 * Copyright (c) 1998, 1999, 2000, 2001 Steve Murphree, Jr.
 * Copyright (c) 1996 Nivas Madhur
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Nivas Madhur.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */
/*
 * Mach Operating System
 * Copyright (c) 1993-1991 Carnegie Mellon University
 * Copyright (c) 1991 OMRON Corporation
 * All Rights Reserved.
 *
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/proc.h>
#include <sys/user.h>
#include <sys/msgbuf.h>
#include <sys/exec.h>
#include <sys/errno.h>
#include <sys/malloc.h>
#ifdef MULTIPROCESSOR
#include <sys/mplock.h>
#endif

#include <machine/asm.h>
#include <machine/asm_macro.h>
#include <machine/atomic.h>
#include <machine/cmmu.h>
#include <machine/cpu.h>
#include <machine/reg.h>
#ifdef M88100
#include <machine/m88100.h>
#endif

#include <uvm/uvm_extern.h>

#ifdef DDB
#include <machine/db_machdep.h>
#include <ddb/db_extern.h>
#include <ddb/db_interface.h>
#endif /* DDB */

typedef struct {
	u_int32_t word_one, word_two;
} m88k_exception_vector_area;

void	dumpconf(void);
void	dumpsys(void);
void	regdump(struct trapframe *f);
void	*vector_init(m88k_exception_vector_area *, u_int32_t *, int);
void	atomic_init(void);

/*
 * CMMU and CPU variables
 */

#ifdef MULTIPROCESSOR
cpuid_t	master_cpu;
__cpu_simple_lock_t cmmu_cpu_lock = __SIMPLELOCK_UNLOCKED;
#endif

struct cpu_info m88k_cpus[MAX_CPUS] = {
#ifndef MULTIPROCESSOR
	{ .ci_flags = CIF_ALIVE | CIF_PRIMARY }
#endif
};
const struct cmmu_p *cmmu;

/*
 * safepri is a safe priority for sleep to set for a spin-wait
 * during autoconfiguration or after a panic.
 */
int   safepri = IPL_NONE;

/*
 * Set registers on exec.
 * Clear all except sp and pc.
 */
void
setregs(p, pack, stack, retval)
	struct proc *p;
	struct exec_package *pack;
	u_long stack;
	register_t retval[2];
{
	struct trapframe *tf = (struct trapframe *)USER_REGS(p);

	/*
	 * Setup proper floating-point settings. This is necessary because
	 * we will return through the exception path, which only saves the
	 * integer registers, and not through cpu_switchto() (which saves
	 * fcr62 and fcr63 in the pcb).  This is safe to do here since the
	 * FPU is enabled and the kernel doesn't use it.
	 */
	__asm__ volatile ("fstcr %r0, %fcr0");
	__asm__ volatile ("fstcr %r0, %fcr62");
	__asm__ volatile ("fstcr %r0, %fcr63");

	bzero((caddr_t)tf, sizeof *tf);

#ifdef M88110
	if (CPU_IS88110) {
		/*
		 * user mode, interrupts enabled,
		 * graphics unit, fp enabled
		 */
		tf->tf_epsr = PSR_SFD;
	}
#endif
#ifdef M88100
	if (CPU_IS88100) {
		/*
		 * user mode, interrupts enabled,
		 * no graphics unit, fp enabled
		 */
		tf->tf_epsr = PSR_SFD | PSR_SFD2;
	}
#endif

	/*
	 * We want to start executing at pack->ep_entry. The way to
	 * do this is force the processor to fetch from ep_entry.
	 *
	 * However, since we will return through m{88100,88110}_syscall(),
	 * we need to setup registers so that the success return, when
	 * ``incrementing'' the instruction pointers, will cause the
	 * binary to start at the expected address.
	 *
	 * This relies on the fact that binaries start with
	 *
	 *	br.n	1f
	 *	 or	r2, r0, r30
	 * 1:
	 *
	 * So the first two instructions can be skipped.
	 */
#ifdef M88110
	if (CPU_IS88110) {
		/*
		 * m88110_syscall() will resume at exip + 8... which
		 * really is the first instruction we want to run.
		 */
		tf->tf_exip = pack->ep_entry & XIP_ADDR;
	}
#endif
#ifdef M88100
	if (CPU_IS88100) {
		/*
		 * m88100_syscall() will resume at sfip / sfip + 4...
		 */
		tf->tf_sfip = ((pack->ep_entry + 8) & FIP_ADDR) | FIP_V;

		/*
		 * ... unless we are starting init, in which case we
		 * won't be returning through the regular path, and
		 * need to explicitely set up nip and fip (note that
		 * 88110 do not need such a test).
		 * Note that this isn't 100% correct, as it mishandles
		 * a real execve() from userspace by process 1.  However
		 * our init will never do that, so it's okay.
		 */
		if (p->p_p->ps_pid == 1) {
			tf->tf_snip = tf->tf_sfip;
			tf->tf_sfip += 4;
		}
	}
#endif
	tf->tf_r[2] = retval[0] = stack;
	tf->tf_r[31] = stack;
	retval[1] = 0;
}

int
copystr(fromaddr, toaddr, maxlength, lencopied)
	const void *fromaddr;
	void *toaddr;
	size_t maxlength;
	size_t *lencopied;
{
	u_int tally;

	tally = 0;

	while (maxlength--) {
		*(u_char *)toaddr = *(u_char *)fromaddr++;
		tally++;
		if (*(u_char *)toaddr++ == 0) {
			if (lencopied) *lencopied = tally;
			return (0);
		}
	}

	if (lencopied)
		*lencopied = tally;

	return (ENAMETOOLONG);
}

#ifdef DDB
int longformat = 1;
void
regdump(struct trapframe *f)
{
#define R(i) f->tf_r[i]
	printf("R00-05: 0x%08lx  0x%08lx  0x%08lx  0x%08lx  0x%08lx  0x%08lx\n",
	       R(0),R(1),R(2),R(3),R(4),R(5));
	printf("R06-11: 0x%08lx  0x%08lx  0x%08lx  0x%08lx  0x%08lx  0x%08lx\n",
	       R(6),R(7),R(8),R(9),R(10),R(11));
	printf("R12-17: 0x%08lx  0x%08lx  0x%08lx  0x%08lx  0x%08lx  0x%08lx\n",
	       R(12),R(13),R(14),R(15),R(16),R(17));
	printf("R18-23: 0x%08lx  0x%08lx  0x%08lx  0x%08lx  0x%08lx  0x%08lx\n",
	       R(18),R(19),R(20),R(21),R(22),R(23));
	printf("R24-29: 0x%08lx  0x%08lx  0x%08lx  0x%08lx  0x%08lx  0x%08lx\n",
	       R(24),R(25),R(26),R(27),R(28),R(29));
	printf("R30-31: 0x%08lx  0x%08lx\n",R(30),R(31));
#ifdef M88110
	if (CPU_IS88110) {
		printf("exip %lx enip %lx\n", f->tf_exip, f->tf_enip);
	}
#endif
#ifdef M88100
	if (CPU_IS88100) {
		printf("sxip %lx snip %lx sfip %lx\n",
		    f->tf_sxip, f->tf_snip, f->tf_sfip);
	}
	if (CPU_IS88100 && ISSET(f->tf_dmt0, DMT_VALID)) {
		/* print dmt stuff for data access fault */
		printf("fault type %ld\n", (f->tf_dpfsr >> 16) & 0x7);
		dae_print((u_int *)f);
	}
	if (CPU_IS88100 && longformat != 0) {
		printf("fpsr %lx fpcr %lx epsr %lx ssbr %lx\n",
		    f->tf_fpsr, f->tf_fpcr, f->tf_epsr, f->tf_ssbr);
		printf("fpecr %lx fphs1 %lx fpls1 %lx fphs2 %lx fpls2 %lx\n",
		    f->tf_fpecr, f->tf_fphs1, f->tf_fpls1,
		    f->tf_fphs2, f->tf_fpls2);
		printf("fppt %lx fprh %lx fprl %lx fpit %lx\n",
		    f->tf_fppt, f->tf_fprh, f->tf_fprl, f->tf_fpit);
		printf("vector %ld mask %lx flags %lx scratch1 %lx cpu %p\n",
		    f->tf_vector, f->tf_mask, f->tf_flags,
		    f->tf_scratch1, f->tf_cpu);
	}
#endif
#ifdef M88110
	if (CPU_IS88110 && longformat != 0) {
		printf("fpsr %lx fpcr %lx fpecr %lx epsr %lx\n",
		    f->tf_fpsr, f->tf_fpcr, f->tf_fpecr, f->tf_epsr);
		printf("dsap %lx duap %lx dsr %lx dlar %lx dpar %lx\n",
		    f->tf_dsap, f->tf_duap, f->tf_dsr, f->tf_dlar, f->tf_dpar);
		printf("isap %lx iuap %lx isr %lx ilar %lx ipar %lx\n",
		    f->tf_isap, f->tf_iuap, f->tf_isr, f->tf_ilar, f->tf_ipar);
		printf("vector %ld mask %lx flags %lx scratch1 %lx cpu %p\n",
		    f->tf_vector, f->tf_mask, f->tf_flags,
		    f->tf_scratch1, f->tf_cpu);
	}
#endif
}
#endif	/* DDB */

/*
 * Set up the cpu_info pointer and the cpu number for the current processor.
 */
struct cpu_info *
set_cpu_number(cpuid_t number)
{
	struct cpu_info *ci;

#ifdef MULTIPROCESSOR
	ci = &m88k_cpus[number];
#else
	ci = &m88k_cpus[0];
#endif
	ci->ci_cpuid = number;

	__asm__ volatile ("stcr %0, %%cr17" :: "r" (ci));
	flush_pipeline();
	return ci;
}

/*
 * Notify the current process (p) that it has a signal pending,
 * process as soon as possible.
 */
void
signotify(struct proc *p)
{
	aston(p);
	cpu_unidle(p->p_cpu);
}

#ifdef MULTIPROCESSOR
void
cpu_unidle(struct cpu_info *ci)
{
	if (ci != curcpu())
		m88k_send_ipi(CI_IPI_NOTIFY, ci->ci_cpuid);
}
#endif

/*
 * Preempt the current process if in interrupt from user mode,
 * or after the current trap/syscall if in system mode.
 */
void
need_resched(struct cpu_info *ci)
{
	ci->ci_want_resched = 1;

	/* There's a risk we'll be called before the idle threads start */
	if (ci->ci_curproc != NULL) {
		aston(ci->ci_curproc);
		if (ci != curcpu())
			cpu_unidle(ci);
	}
}

/*
 * Generic soft interrupt interface
 */

void	dosoftint(int);
int	softpending;

void
dosoftint(int sir)
{
	int q, mask;

#ifdef MULTIPROCESSOR
	__mp_lock(&kernel_lock);
#endif

	for (q = SI_NQUEUES - 1, mask = 1 << (SI_NQUEUES - 1); mask != 0;
	    q--, mask >>= 1)
		if (mask & sir)
			softintr_dispatch(q);

#ifdef MULTIPROCESSOR
	__mp_unlock(&kernel_lock);
#endif
}

int
spl0()
{
	int sir;
	int s;

	/*
	 * Try to avoid potentially expensive setipl calls if nothing
	 * seems to be pending.
	 */
	if ((sir = atomic_clear_int(&softpending)) != 0) {
		s = setipl(IPL_SOFTINT);
		dosoftint(sir);
		setipl(IPL_NONE);
	} else
		s = setipl(IPL_NONE);

	return (s);
}

#define EMPTY_BR	0xc0000000	/* empty "br" instruction */
#define NO_OP 		0xf4005800	/* "or r0, r0, r0" */

#define BRANCH(FROM, TO) \
	(EMPTY_BR | ((((vaddr_t)(TO) - (vaddr_t)(FROM)) >> 2) & 0x03ffffff))

#define SET_VECTOR_88100(NUM, VALUE) \
	do { \
		vbr[NUM].word_one = NO_OP; \
		vbr[NUM].word_two = BRANCH(&vbr[NUM].word_two, VALUE); \
	} while (0)

#define SET_VECTOR_88110(NUM, VALUE) \
	do { \
		vbr[NUM].word_one = BRANCH(&vbr[NUM].word_one, VALUE); \
		vbr[NUM].word_two = NO_OP; \
	} while (0)

/*
 * vector_init(vector, vector_init_list, bootstrap)
 *
 * This routine sets up the m88k vector table for the running processor,
 * as well as the atomic operation routines for multiprocessor kernels.
 * This is the first C code to run, before anything is initialized.
 *
 * I would add an extra four bytes to the exception vectors page pointed
 * to by the vbr, since the 88100 may execute the first instruction of the
 * next trap handler, as documented in its Errata. Processing trap #511
 * would then fall into the next page, unless the address computation wraps,
 * or software traps can not trigger the issue - the Errata does not provide
 * more detail. And since the MVME BUG does not add an extra NOP after its
 * VBR page, I'll assume this is safe for now -- miod
 */
void *
vector_init(m88k_exception_vector_area *vbr, u_int32_t *vector_init_list,
    int bootstrap)
{
	u_int num;
	u_int32_t vec;

	switch (cputyp) {
	default:
#ifdef M88110
	case CPU_88110:
	    {
		extern void m88110_sigsys(void);
		extern void m88110_syscall_handler(void);
		extern void m88110_cache_flush_handler(void);
		extern void m88110_stepbpt(void);
		extern void m88110_userbpt(void);

		for (num = 0; (vec = vector_init_list[num]) != 0; num++)
			SET_VECTOR_88110(num, vec);

		if (bootstrap)
			SET_VECTOR_88110(0x03, vector_init_list[num + 1]);

		for (; num < 512; num++)
			SET_VECTOR_88110(num, m88110_sigsys);

		SET_VECTOR_88110(450, m88110_syscall_handler);
		SET_VECTOR_88110(451, m88110_cache_flush_handler);
		/*
		 * GCC will by default produce explicit trap 503
		 * for division by zero
		 */
		SET_VECTOR_88110(503, vector_init_list[8]);
		SET_VECTOR_88110(504, m88110_stepbpt);
		SET_VECTOR_88110(511, m88110_userbpt);
	    }
		break;
#endif
#ifdef M88100
	case CPU_88100:
	    {
		extern void sigsys(void);
		extern void syscall_handler(void);
		extern void cache_flush_handler(void);
		extern void stepbpt(void);
		extern void userbpt(void);

		for (num = 0; (vec = vector_init_list[num]) != 0; num++)
			SET_VECTOR_88100(num, vec);

		if (bootstrap)
			SET_VECTOR_88100(0x03, vector_init_list[num + 1]);

		for (; num < 512; num++)
			SET_VECTOR_88100(num, sigsys);

		SET_VECTOR_88100(450, syscall_handler);
		SET_VECTOR_88100(451, cache_flush_handler);
		/*
		 * GCC will by default produce explicit trap 503
		 * for division by zero
		 */
		SET_VECTOR_88100(503, vector_init_list[8]);
		SET_VECTOR_88100(504, stepbpt);
		SET_VECTOR_88100(511, userbpt);
	    }
		break;
#endif
	}

	return vbr;
}

#ifdef MULTIPROCESSOR
/*
 * void atomic_init(void);
 *
 * This routine sets up proper atomic operation code for SMP kernels
 * with both 88100 and 88110 support compiled-in. This is crucial enough
 * to have to be done as early as possible.
 * This is among the first C code to run, before anything is initialized.
 */
void
atomic_init()
{
#if defined(M88100) && defined(M88110)
	if (cputyp == CPU_88100) {
		extern uint32_t __atomic_lock[];
		extern uint32_t __atomic_lock_88100[], __atomic_lock_88100_end[];
		extern uint32_t __atomic_unlock[];
		extern uint32_t __atomic_unlock_88100[], __atomic_unlock_88100_end[];

		uint32_t *s, *e, *d;

		d = __atomic_lock;
		s = __atomic_lock_88100;
		e = __atomic_lock_88100_end;
		while (s != e)
				*d++ = *s++;

		d = __atomic_unlock;
		s = __atomic_unlock_88100;
		e = __atomic_unlock_88100_end;
		while (s != e)
				*d++ = *s++;
	}
#endif	/* M88100 && M88110 */
}
#endif	/* MULTIPROCESSOR */

#ifdef MULTIPROCESSOR

/*
 * This function is invoked when it turns out one secondary processor is
 * not usable.
 * Be sure to put the process currently running on it in the run queues,
 * so that another processor can take care of it.
 */
__dead void
cpu_emergency_disable()
{
	struct cpu_info *ci = curcpu();
	struct schedstate_percpu *spc = &ci->ci_schedstate;
	struct proc *p = curproc;
	int s;
	extern void savectx(struct pcb *);

	if (p != NULL && p != spc->spc_idleproc) {
		savectx(curpcb);

		/*
		 * The following is an inline yield(), without the call
		 * to mi_switch().
		 */
		SCHED_LOCK(s);
		p->p_priority = p->p_usrpri;
		p->p_stat = SRUN;
		setrunqueue(p);
		p->p_ru.ru_nvcsw++;
		SCHED_UNLOCK(s);
	}

	CLR(ci->ci_flags, CIF_ALIVE);
	set_psr(get_psr() | PSR_IND);
	splhigh();

	for (;;)
		continue;
	/* NOTREACHED */
}

#endif	/* MULTIPROCESSOR */
@


1.67
log
@Put the address of the per-cpu clock and interrupt registers into the cpu_info
struct, rather than fetching them from arrays every time they are needed.

ok aoyama@@
@
text
@d1 1
a1 1
/*	$OpenBSD: m88k_machdep.c,v 1.66 2016/10/09 20:16:50 guenther Exp $	*/
a62 1
#include <machine/lock.h>
@


1.66
log
@Tweak the special handling of pid 1 in setregs()...and document that
while it's not 100% correct, it's okay

tested by aoyama@@
@
text
@d1 1
a1 1
/*	$OpenBSD: m88k_machdep.c,v 1.65 2016/10/09 11:25:40 tom Exp $	*/
d299 1
a299 1
void
d313 1
@


1.65
log
@Apply consistency to forever loops with continue and NOTREACHED

Same thought from kettenis@@, ok krw@@ phessler@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: m88k_machdep.c,v 1.64 2015/02/11 07:05:39 dlg Exp $	*/
d194 3
d198 1
a198 1
		if (p->p_pid == 1) {
@


1.64
log
@no md code wants lockmgr locks, so no md code needs to include sys/lock.h

with and ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: m88k_machdep.c,v 1.63 2014/07/15 16:28:11 miod Exp $	*/
d575 2
a576 1
	for (;;) ;
@


1.63
log
@Implement rw_cas() with atomic_cas_ulong() now, instead of a dedicated
routine.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88k_machdep.c,v 1.62 2014/06/09 16:22:47 miod Exp $	*/
a54 1
#include <sys/lock.h>
d63 1
@


1.62
log
@Remove redundant regdump() output.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88k_machdep.c,v 1.61 2014/05/31 11:19:56 miod Exp $	*/
a576 28
}

/*
 * Emulate a compare-and-swap instruction for rwlocks, by using a
 * __cpu_simple_lock as a critical section.
 *
 * Since we are only competing against other processors for rwlocks,
 * it is not necessary in this case to disable interrupts to prevent
 * reentrancy on the same processor.
 */

__cpu_simple_lock_t rw_cas_spinlock = __SIMPLELOCK_UNLOCKED;

int
rw_cas_m88k(volatile unsigned long *p, unsigned long o, unsigned long n)
{
	int rc = 0;

	__cpu_simple_lock(&rw_cas_spinlock);

	if (*p != o)
		rc = 1;
	else
		*p = n;

	__cpu_simple_unlock(&rw_cas_spinlock);

	return (rc);
@


1.61
log
@In regdump(), print DAE registers when they are valid, regardless of the
exception type.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88k_machdep.c,v 1.60 2014/05/08 22:17:33 miod Exp $	*/
a260 6
		printf("dmt0 %lx dmd0 %lx dma0 %lx\n",
		    f->tf_dmt0, f->tf_dmd0, f->tf_dma0);
		printf("dmt1 %lx dmd1 %lx dma1 %lx\n",
		    f->tf_dmt1, f->tf_dmd1, f->tf_dma1);
		printf("dmt2 %lx dmd2 %lx dma2 %lx\n",
		    f->tf_dmt2, f->tf_dmd2, f->tf_dma2);
@


1.60
log
@Format string fixes for m88k; remove -Wno-format from the m88k kernels.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88k_machdep.c,v 1.59 2014/03/29 18:09:29 guenther Exp $	*/
a134 7
	/*
	 * The syscall will ``return'' to snip; set it.
	 * argc, argv, envp are placed on the stack by copyregs.
	 * Point r2 to the stack. crt0 should extract envp from
	 * argc & argv before calling user's main.
	 */

d259 1
a259 1
	if (CPU_IS88100 && f->tf_vector == 0x3) {
@


1.59
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: m88k_machdep.c,v 1.58 2013/10/07 19:10:49 miod Exp $	*/
d245 1
a245 1
	printf("R00-05: 0x%08x  0x%08x  0x%08x  0x%08x  0x%08x  0x%08x\n",
d247 1
a247 1
	printf("R06-11: 0x%08x  0x%08x  0x%08x  0x%08x  0x%08x  0x%08x\n",
d249 1
a249 1
	printf("R12-17: 0x%08x  0x%08x  0x%08x  0x%08x  0x%08x  0x%08x\n",
d251 1
a251 1
	printf("R18-23: 0x%08x  0x%08x  0x%08x  0x%08x  0x%08x  0x%08x\n",
d253 1
a253 1
	printf("R24-29: 0x%08x  0x%08x  0x%08x  0x%08x  0x%08x  0x%08x\n",
d255 1
a255 1
	printf("R30-31: 0x%08x  0x%08x\n",R(30),R(31));
d258 1
a258 1
		printf("exip %x enip %x\n", f->tf_exip, f->tf_enip);
d263 1
a263 1
		printf("sxip %x snip %x sfip %x\n",
d268 1
a268 1
		printf("dmt0 %x dmd0 %x dma0 %x\n",
d270 1
a270 1
		printf("dmt1 %x dmd1 %x dma1 %x\n",
d272 1
a272 1
		printf("dmt2 %x dmd2 %x dma2 %x\n",
d274 1
a274 1
		printf("fault type %d\n", (f->tf_dpfsr >> 16) & 0x7);
d278 1
a278 1
		printf("fpsr %x fpcr %x epsr %x ssbr %x\n",
d280 1
a280 1
		printf("fpecr %x fphs1 %x fpls1 %x fphs2 %x fpls2 %x\n",
d283 1
a283 1
		printf("fppt %x fprh %x fprl %x fpit %x\n",
d285 1
a285 1
		printf("vector %d mask %x flags %x scratch1 %x cpu %p\n",
d292 1
a292 1
		printf("fpsr %x fpcr %x fpecr %x epsr %x\n",
d294 1
a294 1
		printf("dsap %x duap %x dsr %x dlar %x dpar %x\n",
d296 1
a296 1
		printf("isap %x iuap %x isr %x ilar %x ipar %x\n",
d298 1
a298 1
		printf("vector %d mask %x flags %x scratch1 %x cpu %p\n",
@


1.58
log
@Put the kernel VBR page at the beginning of the kernel text, as done on
mvme88k, to be able to unmap the page at address zero in the kernel, and have
the vbr page read-only after being initialized.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88k_machdep.c,v 1.57 2013/07/17 19:18:15 miod Exp $	*/
d131 3
a133 3
	__asm__ __volatile__ ("fstcr %r0, %fcr0");
	__asm__ __volatile__ ("fstcr %r0, %fcr62");
	__asm__ __volatile__ ("fstcr %r0, %fcr63");
d321 1
a321 1
	__asm__ __volatile__ ("stcr %0, %%cr17" :: "r" (ci));
@


1.57
log
@Fix setregs() to match prototype. Exposed by recent _types.h change, found the
hard way by aoyama@@
@
text
@d1 1
a1 1
/*	$OpenBSD: m88k_machdep.c,v 1.56 2013/05/15 20:18:04 miod Exp $	*/
d86 1
a86 1
void	vector_init(m88k_exception_vector_area *, u_int32_t *, int);
d441 1
a441 1
void
d511 2
@


1.56
log
@Initialize a teeny few more globals to reasonable values to allow for printf()
to work as soon as cn_tab is initialized. Allows us to correctly printf or
panic early on unrecognized systems. This used to be the case but got lost a
long time ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88k_machdep.c,v 1.55 2013/02/17 18:07:36 miod Exp $	*/
d120 1
a120 1
	int retval[2];
@


1.55
log
@Constify struct cmmu.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88k_machdep.c,v 1.54 2013/01/26 20:47:08 miod Exp $	*/
d98 5
a102 1
struct cpu_info m88k_cpus[MAX_CPUS];
@


1.54
log
@Make sure new processes get a clean FPU configuration upon startup, by
resetting the appropriate register in setregs(). Similar in spirit to what
m68k does (restoring a null frame), and necessary since m88k doesn't do lazy
fpu switching.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88k_machdep.c,v 1.53 2013/01/05 11:20:56 miod Exp $	*/
d99 1
a99 1
struct cmmu_p *cmmu;
@


1.53
log
@Switch m88k ports to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88k_machdep.c,v 1.52 2012/03/23 15:51:26 guenther Exp $	*/
d119 11
@


1.52
log
@Make rusage totals, itimers, and profile settings per-process instead
of per-rthread.  Handling of per-thread tick and runtime counters
inspired by how FreeBSD does it.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: m88k_machdep.c,v 1.51 2010/12/23 20:05:08 miod Exp $	*/
d306 1
a306 1
	__asm__ __volatile__ ("stcr %0, cr17" :: "r" (ci));
@


1.51
log
@The exception vector page on m88k systems has always been the same page as
the one used by the firmware, which (at least on mvme88k) is at address zero.

This is unfortunate, since this means that NULL pointer dereferences in the
kernel are not caught, and writes cause havoc.

This behaviour was necessary to be able to use the PROM system call interface
during early bootstrap, without having to disassemble the VBR page and
update branches - which use pc-relative displacement - if we were to use
a different VBR address.

On mvme88k, change this and actually set up two VBR pages: one, over the PROM
page (except for the system call vectors), and another one in the kernel
image (which will be mapped read-only). We'll run with the PROM page until
the end of autoconf, and then switch to the kernel one, and unmap all the
PROM below it.

As a bonus, the final kernel page can use optimized data access fault
handlers, which do not have to check for faults caused by badaddr(), since
badaddr() is only used during device probe on buses which do not support
hotplug.

There are a few infrastructure collateral damage on aviion and luna88k, but
these ports do not change their behaviour yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88k_machdep.c,v 1.50 2009/04/19 17:56:13 miod Exp $	*/
d563 1
a563 1
		p->p_stats->p_ru.ru_nvcsw++;
@


1.50
log
@Rename max_cpus to ncpusfound and compute it regardless of option
MULTIPROCESSOR.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88k_machdep.c,v 1.49 2009/03/15 20:39:53 miod Exp $	*/
d86 2
a87 1
void	vector_init(m88k_exception_vector_area *, u_int32_t *);
d397 1
a397 1
	(EMPTY_BR | ((vaddr_t)(TO) - (vaddr_t)(FROM)) >> 2)
d412 1
a412 1
 * vector_init(vector, vector_init_list)
d423 1
a423 1
 * more detail. And since the MVME BUG does not add an extra NOP after their
d427 2
a428 1
vector_init(m88k_exception_vector_area *vbr, u_int32_t *vector_init_list)
d447 3
d477 3
d496 1
d499 11
a509 8
	/*
	 * Setting up the proper atomic operation code is not really
	 * related to vector initialization, but is crucial enough to
	 * be worth doing right now, rather than too late in the C code.
	 *
	 * This is only necessary for SMP kernels with 88100 and 88110
	 * support compiled-in, which happen to run on 88100.
	 */
d532 1
a533 1
}
@


1.49
log
@Generic softinterrupt support for m88k based platforms, adapted from arm
with different locking mechanism. 88110 soft ipi are replaced with an
ipi callback which is checked upon return from exception (it can not be kept
as a softintr, as the generic softinterrupt code doesn't have per-cpu
pending softintr queues).
@
text
@d1 1
a1 1
/*	$OpenBSD: m88k_machdep.c,v 1.48 2009/03/04 19:37:15 miod Exp $	*/
a97 2
u_int	max_cpus;

@


1.48
log
@Introduce atomic_clear_int() as an MD atomic operation to perform atomic
exchange with zero; use it in the soft interrupt code to make it simpler
and faster.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88k_machdep.c,v 1.47 2009/03/04 05:59:08 miod Exp $	*/
d56 1
a72 2
#include <net/netisr.h>

a82 1
void	dosoftint(void);
d349 1
a349 1
 * Soft interrupt interface
d352 2
a353 1
int netisr;
d356 1
a356 1
dosoftint()
d358 1
a358 5
	struct cpu_info *ci = curcpu();
	int sir, n;

	if ((sir = atomic_clear_int(&ci->ci_softintr)) == 0)
		return;
d364 4
a367 16
	uvmexp.softs++;

	if (ISSET(sir, SIR_NET)) {
		while ((n = atomic_clear_int(&netisr)) != 0) {
#define DONETISR(bit, fn)						\
			do {						\
				if (n & (1 << bit))			\
					fn();				\
			} while (0)
#include <net/netisr_dispatch.h>
#undef DONETISR
		}
	}

	if (ISSET(sir, SIR_CLOCK))
		softclock();
a369 3
	if (ISSET(sir, SIR_IPI))
		softipi();

d377 1
a377 1
	struct cpu_info *ci = curcpu();
d384 3
a386 3
	if (ci->ci_softintr != 0) {
		s = setipl(IPL_SOFTCLOCK);
		dosoftint();
@


1.47
log
@Fix stupid logic bug in rw_cas_m88k(), makes NFS much happier on SMP kernels.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88k_machdep.c,v 1.46 2009/02/20 20:40:01 miod Exp $	*/
d362 1
a362 1
	if ((sir = ci->ci_softintr) == 0)
a368 1
	atomic_clearbits_int(&ci->ci_softintr, sir);
d372 1
a372 3
		while ((n = netisr) != 0) {
			atomic_clearbits_int(&netisr, n);

a377 1

a378 1

@


1.46
log
@atomic_{set,clear}bits_int were not safe enough on 88110 systems, as they
can be interrupted by NMI; move the SMP version of these routines from
inlines to a separate file (kernel text shrinks 20KB...).

Since the implementation for 88110 becomes really hairy, the pre-main() code
is responsible for copying the appropriate code over for kernels configured
for both 88100 and 88110 cpus, to avoid having to choose the atomicity
strategy at runtime. Hairy, I said.

This gets GENERIC.MP run much further on 197DP. Not enough to reach multiuser
mode, but boots up to starting sshd and then panics.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88k_machdep.c,v 1.45 2009/02/18 21:07:59 miod Exp $	*/
d610 2
a611 1
	*p = n;
@


1.45
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: m88k_machdep.c,v 1.44 2009/02/16 23:03:33 miod Exp $	*/
a95 1
__cpu_simple_lock_t __atomic_lock = __SIMPLELOCK_UNLOCKED;
d440 2
a441 1
 * This routine sets up the m88k vector table for the running processor.
d444 7
a450 8
 * It fills the exception vectors page. I would add an extra four bytes
 * to the page pointed to by the vbr, since the 88100 may execute the
 * first instruction of the next trap handler, as documented in its
 * Errata. Processing trap #511 would then fall into the next page,
 * unless the address computation wraps, or software traps can not trigger
 * the issue - the Errata does not provide more detail. And since the
 * MVME BUG does not add an extra NOP after their VBR page, I'll assume this
 * is safe for now -- miod
d515 33
@


1.44
log
@More 88110 SMP work. Contains, horribly entangled:
- dma_cachectl() split into a ``local cpu only'' and ``all cpus'', and an ipi
  to broadcast ``local dma_cachectl'' is added.
- cpu_info fields are rearranged, to have the 88100-specific information
  and the 88110-specific information overlap, and has many more 88110
  ugly things.
- more ipi handling in the 197-specific area. Since it is not possible to
  have the second processor receive any hardware interrupt (selection
  is done on a level basis via ISEL, and we definitely do not want the
  main cpu to lose interrupts), the best we can do is to inflict ourselves
  a soft interrupt for late ipi processing. It gets used for softclock and
  hardclock on the secondary processor, but since the soft interrupt
  dispatcher doesn't have an exception frame, we have to remember parts
  of it to build a fake clockframe from the soft ipi handler (ugly but
  works).

This now lets GENERIC.MP run a few userland binaries before bugs trigger.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88k_machdep.c,v 1.43 2008/12/21 21:43:52 miod Exp $	*/
d156 1
a156 1
	 * However, since we will return throug m{88100,88110}_syscall(),
a564 2
 *
 * Updates need to be done with xmem to ensure they are atomic.
@


1.43
log
@Proper cpu_unidle() function for MP kernels. ok art@@ long ago
@
text
@d1 1
a1 1
/*	$OpenBSD: m88k_machdep.c,v 1.42 2008/11/27 20:46:48 miod Exp $	*/
d393 3
@


1.42
log
@On 88100 cpus, make sure userland processes start with SNIP and SFIP valid
(i.e. with the valid bit set in them). Found the hard way by Anders Gavare
trying his latest gxemul, proves the hardware is more permitting than one
would expect it to be...
@
text
@d1 1
a1 1
/*	$OpenBSD: m88k_machdep.c,v 1.41 2007/12/26 22:21:39 miod Exp $	*/
d322 3
d326 6
a331 2
	if (p->p_cpu != curcpu() && p->p_cpu != NULL)
		m88k_send_ipi(CI_IPI_NOTIFY, p->p_cpu->ci_cpuid);
d333 16
@


1.41
log
@Remove the last debug bit from the PSR on 88110: do not force memory accesses
instructions to be serialized (this defeats the purpose of having a superscalar
processor, and accesses to volatile variables are done with explicit memory
barriers anyway).

This brings a HUGE speedup: openssl speed -elapsed shows AES is 90% faster,
blowfish is 75% faster, and sha1 is 50% faster. Not so bad!

However, doing this increases the pressure on the processor bus, so it is
necessary to increase the processor bus timeout on 40MHz boards again (to 256
usec). ``black cat'' 50MHz boards seem to be unaffected, so they remain at
64 usec.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88k_machdep.c,v 1.40 2007/12/15 19:33:34 miod Exp $	*/
d181 1
a181 1
		 * m88100_syscall() will resume at sfip / sfip + 4.
d184 11
@


1.40
log
@Move the cmmu lock back from 8820x-specific code to global, and use it on
MVME197DP to serialize 88410 operations.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88k_machdep.c,v 1.39 2007/12/09 19:57:50 miod Exp $	*/
d136 1
a136 1
		 * user mode, serialize mem, interrupts enabled,
d139 1
a139 1
		tf->tf_epsr = PSR_SRM | PSR_SFD;
@


1.39
log
@I honestly do not remember what 88110 errata convinced me to disable
out-of-order (superscalar) execution on these processors.

Since OoO brings a nice 50% to 250% speedup (as shown by ``openssl speed''),
it is definitely worth enabling.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88k_machdep.c,v 1.38 2007/12/05 22:09:14 miod Exp $	*/
d97 1
@


1.38
log
@xmem can not be used as a reliable atomic operation, they way we do them,
so do the naive operations with interrupts disabled, and an interlock held
if MULTIPROCESSOR.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88k_machdep.c,v 1.37 2007/12/04 05:39:42 miod Exp $	*/
a138 4
		/*
		 * XXX disable OoO for now...
		 */
		tf->tf_epsr |= PSR_SER;
@


1.37
log
@Improve setregs() so that it performs the equivalent of the first two
instructions of the new binary, which allows them to be skipped unconditionaly.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88k_machdep.c,v 1.36 2007/12/02 21:23:18 miod Exp $	*/
d96 1
d516 1
d546 1
a546 3
	/* atomic *p = n; */
	__asm__ __volatile__
	    ("xmem %0, %2, r0" : "+r"(n), "+m"(*p) : "r"(p));
@


1.36
log
@When setting up the vectors page, do not put a nop as the first instruction
if the processor is a 88110, since only the 88100 suffers from the ``will
fetch one instruction too far'' bug.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88k_machdep.c,v 1.35 2007/12/02 21:21:30 miod Exp $	*/
d157 1
d162 8
d174 2
a175 10
		 * Delay slot in exip, so we'll start at enip + 4.
		 * This relies on the fact that binaries start with
		 *
		 *	br.n	1f
		 *	 first instruction
		 * 1:	second instruction
		 *
		 * So by pretending exip is a delay slot, m88110_syscall()
		 * will resume at enip + 4... which really is the first
		 * instruction we want to run.
d177 1
a177 2
		tf->tf_exip = (pack->ep_entry & XIP_ADDR) | 1;
		tf->tf_enip = pack->ep_entry & XIP_ADDR;
d182 4
a185 3
		/* we'll start at sfip / sfip + 4 */
		tf->tf_snip = pack->ep_entry & NIP_ADDR;
		tf->tf_sfip = (pack->ep_entry & FIP_ADDR) | FIP_V;
d188 1
a188 1
	tf->tf_r[2] = stack;
@


1.35
log
@Provide a specific rw_cas() function for MP kernels, simulating a really
atomic compare-and-swap operation.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88k_machdep.c,v 1.34 2007/11/22 05:42:50 miod Exp $	*/
d390 1
a390 1
#define SET_VECTOR(NUM, VALUE) \
d396 6
a422 3
	for (num = 0; (vec = vector_init_list[num]) != 0; num++)
		SET_VECTOR(num, vec);

d434 3
d438 1
a438 1
			SET_VECTOR(num, m88110_sigsys);
d440 9
a448 4
		SET_VECTOR(450, m88110_syscall_handler);
		SET_VECTOR(451, m88110_cache_flush_handler);
		SET_VECTOR(504, m88110_stepbpt);
		SET_VECTOR(511, m88110_userbpt);
d461 3
d465 1
a465 1
			SET_VECTOR(num, sigsys);
d467 9
a475 4
		SET_VECTOR(450, syscall_handler);
		SET_VECTOR(451, cache_flush_handler);
		SET_VECTOR(504, stepbpt);
		SET_VECTOR(511, userbpt);
a479 3

	/* GCC will by default produce explicit trap 503 for division by zero */
	SET_VECTOR(503, vector_init_list[8]);
@


1.34
log
@Move the cmmu lock to 88200-specific code. 88110 MP code will use ipis
and will not require such a lock.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88k_machdep.c,v 1.33 2007/11/20 21:47:12 miod Exp $	*/
d503 31
@


1.33
log
@Fix setregs() on 88110, so that binaries do not skip their first instruction.
Makes binaries beyond init(8) running on MVME197, to some extent.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88k_machdep.c,v 1.32 2007/11/17 05:36:23 miod Exp $	*/
a94 1
__cpu_simple_lock_t cmmu_cpu_lock = __SIMPLELOCK_UNLOCKED;
@


1.32
log
@Replace many ``unsigned'' variables with ``unsigned int'', ``u_int'' or other
appropriate types. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88k_machdep.c,v 1.31 2007/11/15 21:27:22 miod Exp $	*/
d157 5
a161 4
	 * do this is force the processor to fetch from ep_entry. Set
	 * NIP to something bogus and invalid so that it will be a NOOP.
	 * And set sfip to ep_entry with valid bit on so that it will be
	 * fetched.  mc88110 - just set exip to pack->ep_entry.
d165 14
a178 1
		tf->tf_exip = pack->ep_entry & XIP_ADDR;
d183 1
@


1.31
log
@Check for curcpu()->ci_softintr being nonzero before invoking dosoftint(),
in the common case, this saves us two potentially expensive setipl() calls.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88k_machdep.c,v 1.30 2007/11/15 21:24:14 miod Exp $	*/
d240 1
a240 1
		dae_print((unsigned *)f);
@


1.30
log
@Resolve the struct trapframe tf_mode/tf_flags duality by getting rid of
the tf_mode name. This field only contains flags used internally by the
exception processing code.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88k_machdep.c,v 1.29 2007/11/14 23:12:46 miod Exp $	*/
d313 1
a313 1
	int *ssir = &curcpu()->ci_softintr;
d316 1
a316 1
	if ((sir = *ssir) == 0)
d323 1
a323 1
	atomic_clearbits_int(ssir, sir);
d353 1
d356 10
a365 3
	s = setipl(IPL_SOFTCLOCK);

	dosoftint();
a366 1
	setipl(IPL_NONE);
@


1.29
log
@Merge the ci_alive and ci_primary boolean values of struct cpu_info into
a single ci_flags bitfield.

Also, set_cpu_number() will no longer set CIF_PRIMARY on the primary processor,
it's up to the initialization code to do this.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88k_machdep.c,v 1.28 2007/11/09 17:08:44 miod Exp $	*/
d250 2
a251 2
		printf("vector %d mask %x mode %x scratch1 %x cpu %p\n",
		    f->tf_vector, f->tf_mask, f->tf_mode,
d263 2
a264 2
		printf("vector %d mask %x mode %x scratch1 %x cpu %p\n",
		    f->tf_vector, f->tf_mask, f->tf_mode,
@


1.28
log
@On MULTIPROCESSOR kernels, don't forget to grab the kernel lock when
processing soft interrupts; and there was much rejoicing.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88k_machdep.c,v 1.27 2007/11/06 21:48:44 miod Exp $	*/
a287 7

#ifdef MULTIPROCESSOR
	if (number == master_cpu)
#endif
	{
		ci->ci_primary = 1;
	}
@


1.27
log
@Keep a pending software interrupts mask per processor, instead of having it
global; and only schedule software interrupts on the currently running cpu.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88k_machdep.c,v 1.26 2007/11/06 21:42:56 miod Exp $	*/
d326 4
d351 4
@


1.26
log
@Remove the now unused idle_u, and call the secondary processors startup
stack a startup stack.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88k_machdep.c,v 1.25 2007/10/29 19:57:48 miod Exp $	*/
a314 1
unsigned int ssir;
d320 1
d323 1
a323 1
	if ((sir = ssir) == 0)
d326 1
a326 1
	atomic_clearbits_int(&ssir, sir);
@


1.25
log
@When a secondary cpu gets its interrupt pin stuck, be sure to savectx
and put the process it was running back on the run queue (unless this was
the idle proc).
@
text
@d1 1
a1 1
/*	$OpenBSD: m88k_machdep.c,v 1.24 2007/10/28 19:42:11 miod Exp $	*/
a277 1
	extern struct pcb idle_u;
a293 1
		ci->ci_idle_pcb = &idle_u;
@


1.24
log
@Do not flag a processor as ``alive'' until it really is ready to accept IPIs.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88k_machdep.c,v 1.23 2007/10/24 20:54:53 miod Exp $	*/
d445 41
@


1.23
log
@Remove sir_lock, superseded by the atomic bit operations.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88k_machdep.c,v 1.22 2007/10/10 15:53:52 art Exp $	*/
a296 2

	ci->ci_alive = 1;
@


1.22
log
@Make context switching much more MI:
 - Move the functionality of choosing a process from cpu_switch into
   a much simpler function: cpu_switchto. Instead of having the locore
   code walk the run queues, let the MI code choose the process we
   want to run and only implement the context switching itself in MD
   code.
 - Let MD context switching run without worrying about spls or locks.
 - Instead of having the idle loop implemented with special contexts
   in MD code, implement one idle proc for each cpu. make the idle
   loop MI with MD hooks.
 - Change the proc lists from the old style vax queues to TAILQs.
 - Change the sleep queue from vax queues to TAILQs. This makes
   wakeup() go from O(n^2) to O(n)

there will be some MD fallout, but it will be fixed shortly.
There's also a few cleanups to be done after this.

deraadt@@, kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: m88k_machdep.c,v 1.21 2007/05/29 18:10:42 miod Exp $	*/
a96 1
struct __mp_lock sir_lock;
a295 7

#ifdef MULTIPROCESSOR
		/*
		 * Specific initialization for the master processor.
		 */
		__mp_lock_init(&sir_lock);
#endif
@


1.21
log
@Use atomic operations to operate on netisr, instead of clearing it at splhigh.
This changes nothing on legacy architectures, but is a bit faster (and simpler)
on the interesting ones.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88k_machdep.c,v 1.20 2007/05/19 20:34:34 miod Exp $	*/
a202 44
}

void
setrunqueue(p)
	struct proc *p;
{
	struct prochd *q;
	struct proc *oldlast;
	int which = p->p_priority >> 2;

#ifdef DIAGNOSTIC
	if (p->p_back != NULL)
		panic("setrunqueue %p", p);
#endif
	q = &qs[which];
	whichqs |= 1 << which;
	p->p_forw = (struct proc *)q;
	p->p_back = oldlast = q->ph_rlink;
	q->ph_rlink = p;
	oldlast->p_forw = p;
}

/*
 * Remove process p from its run queue, which should be the one
 * indicated by its priority.  Calls should be made at splstatclock().
 */
void
remrunqueue(vp)
	struct proc *vp;
{
	struct proc *p = vp;
	int which = p->p_priority >> 2;
	struct prochd *q;

#ifdef DIAGNOSTIC
	if ((whichqs & (1 << which)) == 0)
		panic("remrq %p", p);
#endif
	p->p_forw->p_back = p->p_back;
	p->p_back->p_forw = p->p_forw;
	p->p_back = NULL;
	q = &qs[which];
	if (q->ph_link == (struct proc *)q)
		whichqs &= ~(1 << which);
@


1.20
log
@Send an IPI in signotify() if the process runs on a different processor,
similar to the fix which went into i386 and amd64 a few weeks ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88k_machdep.c,v 1.19 2007/05/18 16:35:02 miod Exp $	*/
d62 1
d377 4
a380 1
	int sir = ssir;
d383 1
d386 9
a394 8
		uvmexp.softs++;
#define DONETISR(bit, fn) \
	do { \
		if (netisr & (1 << bit)) { \
			netisr &= ~(1 << bit); \
			fn(); \
		} \
	} while (0)
d396 1
d398 1
d401 1
a401 2
	if (ISSET(sir, SIR_CLOCK)) {
		uvmexp.softs++;
a402 1
	}
d412 1
a412 2
	if (ssir)
		dosoftint();
@


1.19
log
@In spl0(), really process soft interrupts at IPL_SOFT instead of whatever
level we were at.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88k_machdep.c,v 1.18 2007/04/18 21:21:20 miod Exp $	*/
d350 14
@


1.18
log
@Use atomic operations to change the pending software interrupt mask.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88k_machdep.c,v 1.17 2006/11/22 22:47:46 miod Exp $	*/
d362 5
a366 1
	if (ISSET(ssir, SIR_NET)) {
a376 1
		atomic_clearbits_int(&ssir, SIR_NET);
d379 1
a379 1
	if (ISSET(ssir, SIR_CLOCK)) {
a381 1
		atomic_clearbits_int(&ssir, SIR_CLOCK);
d390 1
a390 1
	s = splsoftclock();
d395 1
a395 1
	setipl(0);
@


1.17
log
@The softintr lock needs to be an __mp_lock, not a __cpu_simple_lock.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88k_machdep.c,v 1.16 2006/05/08 14:36:09 miod Exp $	*/
d356 1
a356 1
int ssir;
a358 24
#ifdef MULTIPROCESSOR

void
setsoftint(int sir)
{
	__mp_lock(&sir_lock);
	ssir |= sir;
	__mp_unlock(&sir_lock);
}

int
clrsoftint(int sir)
{
	int tmpsir;

	__mp_lock(&sir_lock);
	tmpsir = ssir & sir;
	ssir ^= tmpsir;
	__mp_unlock(&sir_lock);

	return (tmpsir);
}
#endif

d362 1
a362 1
	if (clrsoftint(SIR_NET)) {
d373 1
d376 1
a376 1
	if (clrsoftint(SIR_CLOCK)) {
d379 1
@


1.16
log
@Replace gazillions of badvaddr() or badwordaddr() calls with badaddr() calls.
With a few prototype declarations shuffling, this finally allows
<machine/locore.h> to die.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88k_machdep.c,v 1.15 2006/05/08 14:03:34 miod Exp $	*/
d56 3
d96 1
d340 7
a359 3
#include <sys/lock.h>

__cpu_simple_lock_t sir_lock = __SIMPLELOCK_UNLOCKED;
d364 1
a364 1
	__cpu_simple_lock(&sir_lock);
d366 1
a366 1
	__cpu_simple_unlock(&sir_lock);
d374 1
a374 1
	__cpu_simple_lock(&sir_lock);
d377 1
a377 1
	__cpu_simple_unlock(&sir_lock);
@


1.15
log
@Clean the internal m88k trap type codes; while there, simplify and
factorize the build of the VBR page betweem luna88k and mvme88k.

Tested by aoyama@@ and I.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88k_machdep.c,v 1.14 2006/04/15 15:43:33 miod Exp $	*/
a60 1
#include <machine/locore.h>
d451 7
d465 1
d470 7
d484 1
@


1.14
log
@nmihand() is mvme88k only, move it out of m88k common area.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88k_machdep.c,v 1.13 2005/12/11 21:36:06 miod Exp $	*/
d57 1
d77 4
d85 1
d410 66
@


1.13
log
@Factorize soft interrupt code between luna88k and mvme88k.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88k_machdep.c,v 1.12 2005/12/04 12:12:17 miod Exp $	*/
a94 2
int longformat = 1;  /* for regdump() */

a238 3
void
nmihand(void *framep)
{
d240 1
a240 10
	printf("Abort Pressed\n");
	Debugger();
#else
	struct trapframe *frame = framep;

	printf("Spurious NMI?\n");
	regdump(frame);
#endif /* DDB */
}

d304 1
@


1.12
log
@Oops, simplelock leftover.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88k_machdep.c,v 1.11 2005/12/03 19:06:11 miod Exp $	*/
d55 1
a59 1
#include <machine/lock.h>
d68 2
d76 4
a79 4
/* prototypes */
void regdump(struct trapframe *f);
void dumpsys(void);
void dumpconf(void);
d347 70
@


1.11
log
@Replace simplelocks with __cpu_simple_locks for cmmu and pmap locking,
for the MULTIPROCESSOR case.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88k_machdep.c,v 1.10 2005/12/03 14:30:06 miod Exp $	*/
a91 6

/*
 * This lock protects the cmmu SAR and SCR's; other ports
 * can be accessed without locking it.
 */
struct simplelock cmmu_cpu_lock;
@


1.10
log
@Switch m88k ports to __HAVE_CPUINFO. Current cpu pointer is held in SR0
on all running processors.
Tested aoyama@@ and I
@
text
@d1 1
a1 1
/*	$OpenBSD: m88k_machdep.c,v 1.9 2005/11/28 22:22:55 miod Exp $	*/
d59 1
d84 1
@


1.9
log
@Maintain an interrupt depth counter for CLKF_INTR to be correct.
Tested aoyama@@ martin@@ and I.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88k_machdep.c,v 1.8 2005/11/06 17:58:20 miod Exp $	*/
d56 1
d59 1
d78 19
a98 2
int intrdepth;

d301 1
a301 1
		printf("vector %d mask %x mode %x scratch1 %x cpu %x\n",
d314 1
a314 1
		printf("vector %d mask %x mode %x scratch1 %x cpu %x\n",
d319 30
@


1.8
log
@Invoke regdump() on abort if compiled without DDB support.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88k_machdep.c,v 1.7 2005/10/13 19:48:33 miod Exp $	*/
d77 2
@


1.7
log
@Merge <machine/cpu_number.h> into <machine/cpu.h>, preparing for intrusive
changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88k_machdep.c,v 1.6 2005/10/12 19:30:28 miod Exp $	*/
d65 1
a65 1
#if DDB
d186 1
d189 1
d210 1
d213 1
d225 1
a225 5
#if 0
	struct trapframe *frame = framep;
#endif

#if DDB
d229 2
d232 1
@


1.6
log
@Remove commented out dead wrong FPU handling code in setregs().
@
text
@d1 1
a1 1
/*	$OpenBSD: m88k_machdep.c,v 1.5 2005/10/12 19:05:44 miod Exp $	*/
a57 1
#include <machine/cpu_number.h>
@


1.5
log
@Stop mapping the u area at fixed UADDR in addition to its actual va.
While there, attempt to clean and comment stack usage in the kernel.
No functional change.

From the m88k SMP tree; help&test martin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: m88k_machdep.c,v 1.4 2005/09/25 20:55:14 miod Exp $	*/
a58 3
/*
#include <machine/locore.h>
*/
a103 20
#if 0
	/*
	 * I don't think I need to mess with fpstate on 88k because
	 * we make sure the floating point pipeline is drained in
	 * the trap handlers. Should check on this later. XXX Nivas.
	 */
	if ((fs = p->p_md.md_fpstate) != NULL) {
		/*
		 * We hold an FPU state.  If we own *the* FPU chip state
		 * we must get rid of it, and the only way to do that is
		 * to save it.  In any case, get rid of our FPU state.
		 */
		if (p == fpproc) {
			savefpstate(fs);
			fpproc = NULL;
		}
		free((void *)fs, M_SUBPROC);
		p->p_md.md_fpstate = NULL;
	}
#endif
@


1.4
log
@Change the size parameter of cmmu_flush_tlb() from bytes to pages. This makes
things easier for the callers, and allows us to inline the "fewer than 4 pages"
situation for speed.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88k_machdep.c,v 1.3 2005/04/30 16:44:08 miod Exp $	*/
a77 2
void save_u_area(struct proc *, vaddr_t);
void load_u_area(struct proc *);
a86 30

/*
 * Setup u area ptes for u area double mapping.
 */

void
save_u_area(struct proc *p, vaddr_t va)
{
	int i;

	for (i = 0; i < UPAGES; i++) {
		p->p_md.md_upte[i] = *((pt_entry_t *)kvtopte(va));
		va += PAGE_SIZE;
	}
}

void
load_u_area(struct proc *p)
{
	int i;
	vaddr_t va;
	pt_entry_t *t;

	for (i = 0, va = UADDR; i < UPAGES; i++) {
		t = kvtopte(va);
		*t = p->p_md.md_upte[i];
		va += PAGE_SIZE;
	}
	cmmu_flush_tlb(cpu_number(), 1, UADDR, UPAGES);
}
@


1.3
log
@Use [XNF]IP_ADDR constants rather than their numeric values.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88k_machdep.c,v 1.2 2004/09/30 21:48:56 miod Exp $	*/
d117 1
a117 1
	cmmu_flush_tlb(cpu_number(), 1, UADDR, USPACE);
@


1.2
log
@Introduce sparc-like CPU_ISFOO macros, to short-circuit evaluations when
compiling for one flavour only.

This makes code slightly smaller on all m88k-based platforms (my roughly
1KB), and saves more than meets the eye on luna88k, which is m88100-based.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d194 1
a194 1
		tf->tf_exip = pack->ep_entry & ~3;
d199 2
a200 2
		tf->tf_snip = pack->ep_entry & ~3;
		tf->tf_sfip = (pack->ep_entry & ~3) | FIP_V;
@


1.1
log
@More code shuffling, probably the final touch.
@
text
@a161 1
	if (cputyp == CPU_88110) {
d163 1
d173 1
a174 1
	} else {
d176 1
d182 1
a183 1
	}
a191 1
	if (cputyp == CPU_88110) {
d193 1
d195 1
a196 1
	} else {
d198 1
d201 1
a202 1
	}
d304 2
a305 1
	if (cputyp == CPU_88110) {
d307 4
a310 1
	} else {
d314 1
a314 2
#ifdef M88100
	if (f->tf_vector == 0x3 && cputyp != CPU_88110) {
d325 1
a325 1
	if (longformat && cputyp != CPU_88110) {
d339 1
a339 1
	if (longformat && cputyp == CPU_88110) {
@

