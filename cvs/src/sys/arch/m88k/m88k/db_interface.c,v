head	1.22;
access;
symbols
	OPENBSD_6_2:1.22.0.2
	OPENBSD_6_2_BASE:1.22
	OPENBSD_6_1:1.21.0.6
	OPENBSD_6_1_BASE:1.21
	OPENBSD_6_0:1.21.0.2
	OPENBSD_6_0_BASE:1.21
	OPENBSD_5_9:1.20.0.6
	OPENBSD_5_9_BASE:1.20
	OPENBSD_5_8:1.20.0.8
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.20.0.2
	OPENBSD_5_7_BASE:1.20
	OPENBSD_5_6:1.20.0.4
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.18.0.12
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.18.0.8
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.18.0.6
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.18.0.4
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.2
	OPENBSD_5_0:1.17.0.4
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.17.0.2
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.15.0.6
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.15.0.2
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.15.0.4
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.14.0.4
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.13.0.2
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.12.0.2
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.7.0.2
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.5.0.4
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.2
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.4.0.2
	OPENBSD_3_9_BASE:1.4;
locks; strict;
comment	@ * @;


1.22
date	2017.04.30.16.45.45;	author mpi;	state Exp;
branches;
next	1.21;
commitid	2Gtqjzrin9LL2yHk;

1.21
date	2016.03.09.08.58.50;	author mpi;	state Exp;
branches;
next	1.20;
commitid	5oeMKdWr273HqanP;

1.20
date	2014.05.31.11.19.06;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2014.05.08.22.17.33;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2011.10.25.18.38.06;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2011.01.05.22.14.29;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2010.12.31.20.38.55;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2009.03.15.20.39.53;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2008.10.27.18.03.46;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2008.07.28.17.57.25;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2007.12.04.23.45.52;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2007.11.14.23.15.03;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2007.11.14.23.12.46;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2007.11.14.17.54.25;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2007.11.11.21.15.34;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2007.05.19.20.33.49;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2007.03.21.19.32.17;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2006.05.08.14.36.09;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2005.12.11.21.45.30;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2005.12.04.12.20.19;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2005.11.20.22.04.32;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2005.10.24.19.28.28;	author miod;	state Exp;
branches;
next	;


desc
@@


1.22
log
@Rename Debugger() into db_enter().

Using a name with the 'db_' prefix makes it invisible from the dynamic
profiler.

ok deraadt@@, kettenis@@, visa@@
@
text
@/*	$OpenBSD: db_interface.c,v 1.21 2016/03/09 08:58:50 mpi Exp $	*/
/*
 * Mach Operating System
 * Copyright (c) 1993-1991 Carnegie Mellon University
 * Copyright (c) 1991 OMRON Corporation
 * All Rights Reserved.
 *
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON AND OMRON ALLOW FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON AND OMRON DISCLAIM ANY LIABILITY OF ANY KIND
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

/*
 * m88k interface to ddb debugger
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/reboot.h>

#include <uvm/uvm_extern.h>

#include <machine/asm_macro.h>
#include <machine/cmmu.h>
#include <machine/trap.h>
#include <machine/db_machdep.h>
#include <machine/cpu.h>
#ifdef M88100
#include <machine/m88100.h>
#include <machine/m8820x.h>
#endif

#include <ddb/db_access.h>
#include <ddb/db_command.h>
#include <ddb/db_extern.h>
#include <ddb/db_interface.h>
#include <ddb/db_output.h>
#include <ddb/db_run.h>
#include <ddb/db_sym.h>

extern label_t *db_recover;
extern int frame_is_sane(db_regs_t *, int);	/* db_trace */
extern void cnpollc(int);

void	kdbprinttrap(int);

int	m88k_dmx_print(u_int, u_int, u_int, u_int);

void	m88k_db_trap(int, struct trapframe *);
void	m88k_db_print_frame(db_expr_t, int, db_expr_t, char *);
void	m88k_db_registers(db_expr_t, int, db_expr_t, char *);
void	m88k_db_where(db_expr_t, int, db_expr_t, char *);
void	m88k_db_frame_search(db_expr_t, int, db_expr_t, char *);
void	m88k_db_translate(db_expr_t, int, db_expr_t, char *);
void	m88k_db_cmmucfg(db_expr_t, int, db_expr_t, char *);

db_regs_t ddb_regs;

#ifdef MULTIPROCESSOR
#include <sys/mplock.h>
struct __mp_lock ddb_mp_lock;
cpuid_t	ddb_mp_nextcpu = (cpuid_t)-1;

void	m88k_db_cpu_cmd(db_expr_t, int, db_expr_t, char *);
#endif

/*
 * If you really feel like understanding the following procedure and
 * macros, see pages 6-22 to 6-30 (Section 6.7.3) of
 *
 * MC88100 RISC Microprocessor User's Manual Second Edition
 * (Motorola Order: MC88100UM/AD REV 1)
 *
 * and ERRATA-5 (6-23, 6-24, 6-24) of
 *
 * Errata to MC88100 User's Manual Second Edition MC88100UM/AD Rev 1
 * (Oct 2, 1990)
 * (Motorola Order: MC88100UMAD/AD)
 */

#ifdef M88100
/* macros for decoding dmt registers */

/*
 * return 1 if the printing of the next stage should be suppressed
 */
int
m88k_dmx_print(u_int t, u_int d, u_int a, u_int no)
{
	static const u_int addr_mod[16] = {
		0, 3, 2, 2, 1, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0
	};
	static const char *mode[16]  = {
		"?", ".b", ".b", ".h", ".b", "?", "?", "?",
		".b", "?", "?" , "?" , ".h" , "?", "?", ""
	};
	static const u_int mask[16] = {
		0, 0xff, 0xff00, 0xffff,
		0xff0000, 0, 0, 0,
		0xff000000, 0, 0, 0,
		0xffff0000, 0, 0, 0xffffffff
	};
	static const u_int shift[16] = {
		0,  0, 8, 0, 16, 0, 0, 0,
		24, 0, 0, 0, 16, 0, 0, 0
	};
	int reg = DMT_DREGBITS(t);

	if (ISSET(t, DMT_LOCKBAR)) {
		db_printf("xmem%s%s r%d(0x%x) <-> mem(0x%x),",
		    DMT_ENBITS(t) == 0x0f ? "" : ".bu",
		    ISSET(t, DMT_DAS) ? "" : ".usr", reg,
		    ((t >> 2 & 0xf) == 0xf) ? d : (d & 0xff), a);
		return 1;
	} else if (DMT_ENBITS(t) == 0xf) {
		/* full or double word */
		if (ISSET(t, DMT_WRITE)) {
			if (ISSET(t, DMT_DOUB1) && no == 2)
				db_printf("st.d%s -> mem(0x%x) (** restart sxip **)",
				    ISSET(t, DMT_DAS) ? "" : ".usr", a);
			else
				db_printf("st%s (0x%x) -> mem(0x%x)",
				    ISSET(t, DMT_DAS) ? "" : ".usr", d, a);
		} else {
			/* load */
			if (ISSET(t, DMT_DOUB1) && no == 2)
				db_printf("ld.d%s r%d <- mem(0x%x), r%d <- mem(0x%x)",
				    ISSET(t, DMT_DAS) ? "" : ".usr", reg, a, reg+1, a+4);
			else
				db_printf("ld%s r%d <- mem(0x%x)",
				    ISSET(t, DMT_DAS) ? "" : ".usr", reg, a);
		}
	} else {
		/* fractional word - check if load or store */
		a += addr_mod[DMT_ENBITS(t)];
		if (ISSET(t, DMT_WRITE))
			db_printf("st%s%s (0x%x) -> mem(0x%x)",
			    mode[DMT_ENBITS(t)],
			    ISSET(t, DMT_DAS) ? "" : ".usr",
			    (d & mask[DMT_ENBITS(t)]) >> shift[DMT_ENBITS(t)],
			    a);
		else
			db_printf("ld%s%s%s r%d <- mem(0x%x)",
			    mode[DMT_ENBITS(t)],
			    ISSET(t, DMT_SIGNED) ? "" : "u",
			    ISSET(t, DMT_DAS) ? "" : ".usr", reg, a);
	}
	return (0);
}
#endif	/* M88100 */

void
m88k_db_print_frame(addr, have_addr, count, modif)
	db_expr_t addr;
	int have_addr;
	db_expr_t count;
	char *modif;
{
	struct trapframe *s = (struct trapframe *)addr;
	char *name;
	db_expr_t offset;
#ifdef M88100
	int suppress1 = 0, suppress2 = 0;
#endif
	int c, force = 0, help = 0;

	if (!have_addr) {
		db_printf("requires address of frame\n");
		help = 1;
	}

	while (modif && *modif) {
		switch (c = *modif++, c) {
		case 'f':
			force = 1;
			break;
		case 'h':
			help = 1;
			break;
		default:
			db_printf("unknown modifier [%c]\n", c);
			help = 1;
			break;
		}
	}

	if (help) {
		db_printf("usage: mach frame/[f] ADDRESS\n");
		db_printf("  /f force printing of insane frames.\n");
		return;
	}

	if (badaddr((vaddr_t)s, 4) ||
	    badaddr((vaddr_t)(&((db_regs_t*)s)->fpit), 4)) {
		db_printf("frame at %8p is unreadable\n", s);
		return;
	}

	if (frame_is_sane((db_regs_t *)s, 0) == 0) {
		if (force == 0)
			return;
	}

#define R(i) s->tf_r[i]
#define IPMASK(x) ((x) &  ~(3))
	db_printf("R00-05: 0x%08lx  0x%08lx  0x%08lx  0x%08lx  0x%08lx  0x%08lx\n",
	    R(0), R(1), R(2), R(3), R(4), R(5));
	db_printf("R06-11: 0x%08lx  0x%08lx  0x%08lx  0x%08lx  0x%08lx  0x%08lx\n",
	    R(6), R(7), R(8), R(9), R(10), R(11));
	db_printf("R12-17: 0x%08lx  0x%08lx  0x%08lx  0x%08lx  0x%08lx  0x%08lx\n",
	    R(12), R(13), R(14), R(15), R(16), R(17));
	db_printf("R18-23: 0x%08lx  0x%08lx  0x%08lx  0x%08lx  0x%08lx  0x%08lx\n",
	    R(18), R(19), R(20), R(21), R(22), R(23));
	db_printf("R24-29: 0x%08lx  0x%08lx  0x%08lx  0x%08lx  0x%08lx  0x%08lx\n",
	    R(24), R(25), R(26), R(27), R(28), R(29));
	db_printf("R30-31: 0x%08lx  0x%08lx\n", R(30), R(31));

	db_printf("%cxip: 0x%08lx ",
	    CPU_IS88110 ? 'e' : 's', s->tf_sxip & XIP_ADDR);
	db_find_xtrn_sym_and_offset((db_addr_t)IPMASK(s->tf_sxip),
	    &name, &offset);
	if (name != NULL && (u_int)offset <= db_maxoff)
		db_printf("%s+0x%08x", name, (u_int)offset);
	db_printf("\n");

	if (s->tf_snip != s->tf_sxip + 4) {
		db_printf("%cnip: 0x%08lx ",
		    CPU_IS88110 ? 'e' : 's', s->tf_snip);
		db_find_xtrn_sym_and_offset((db_addr_t)IPMASK(s->tf_snip),
		    &name, &offset);
		if (name != NULL && (u_int)offset <= db_maxoff)
			db_printf("%s+0x%08x", name, (u_int)offset);
		db_printf("\n");
	}

#ifdef M88100
	if (CPU_IS88100) {
		if (s->tf_sfip != s->tf_snip + 4) {
			db_printf("sfip: 0x%08lx ", s->tf_sfip);
			db_find_xtrn_sym_and_offset((db_addr_t)IPMASK(s->tf_sfip),
			    &name, &offset);
			if (name != NULL && (u_int)offset <= db_maxoff)
				db_printf("%s+0x%08x", name, (u_int)offset);
			db_printf("\n");
		}
	}
#endif
#ifdef M88110
	if (CPU_IS88110) {
		db_printf("fpsr: 0x%08lx fpcr: 0x%08lx fpecr: 0x%08lx\n",
			  s->tf_fpsr, s->tf_fpcr, s->tf_fpecr);
		db_printf("dsap 0x%08lx duap 0x%08lx dsr 0x%08lx dlar 0x%08lx dpar 0x%08lx\n",
			  s->tf_dsap, s->tf_duap, s->tf_dsr, s->tf_dlar, s->tf_dpar);
		db_printf("isap 0x%08lx iuap 0x%08lx isr 0x%08lx ilar 0x%08lx ipar 0x%08lx\n",
			  s->tf_isap, s->tf_iuap, s->tf_isr, s->tf_ilar, s->tf_ipar);
	}
#endif

	db_printf("epsr: 0x%08lx                current process: %p\n",
		  s->tf_epsr, curproc);
	db_printf("vector: 0x%02lx                    interrupt mask: 0x%08lx\n",
		  s->tf_vector, s->tf_mask);

	/*
	 * If the vector indicates trap, instead of an exception or
	 * interrupt, skip the check of dmt and fp regs.
	 *
	 * Interrupt and exceptions are vectored at 0-10 and 114-127.
	 */
	if (!(s->tf_vector <= 10 ||
	    (114 <= s->tf_vector && s->tf_vector <= 127))) {
		db_printf("\n");
		return;
	}

#ifdef M88100
	if (CPU_IS88100) {
		if (s->tf_vector == /*data*/3 || s->tf_dmt0 & DMT_VALID) {
			db_printf("dmt,d,a0: 0x%08lx  0x%08lx  0x%08lx ",
			    s->tf_dmt0, s->tf_dmd0, s->tf_dma0);
			db_find_xtrn_sym_and_offset((db_addr_t)s->tf_dma0,
			    &name, &offset);
			if (name != NULL && (u_int)offset <= db_maxoff)
				db_printf("%s+0x%08x", name, (u_int)offset);
			db_printf("\n          ");

			suppress1 = m88k_dmx_print(s->tf_dmt0, s->tf_dmd0,
			    s->tf_dma0, 0);
			db_printf("\n");

			if ((s->tf_dmt1 & DMT_VALID) && (!suppress1)) {
				db_printf("dmt,d,a1: 0x%08lx  0x%08lx  0x%08lx ",
				    s->tf_dmt1, s->tf_dmd1, s->tf_dma1);
				db_find_xtrn_sym_and_offset((db_addr_t)s->tf_dma1,
				    &name, &offset);
				if (name != NULL && (u_int)offset <= db_maxoff)
					db_printf("%s+0x%08x", name,
					    (u_int)offset);
				db_printf("\n          ");
				suppress2 = m88k_dmx_print(s->tf_dmt1,
				    s->tf_dmd1, s->tf_dma1, 1);
				db_printf("\n");

				if ((s->tf_dmt2 & DMT_VALID) && (!suppress2)) {
					db_printf("dmt,d,a2: 0x%08lx  0x%08lx  0x%08lx ",
						  s->tf_dmt2, s->tf_dmd2, s->tf_dma2);
					db_find_xtrn_sym_and_offset((db_addr_t)s->tf_dma2,
					    &name, &offset);
					if (name != 0 &&
					    (u_int)offset <= db_maxoff)
						db_printf("%s+0x%08x", name,
						    (u_int)offset);
					db_printf("\n          ");
					m88k_dmx_print(s->tf_dmt2, s->tf_dmd2,
					    s->tf_dma2, 2);
					db_printf("\n");
				}
			}

			db_printf("fault code %ld\n",
			    CMMU_PFSR_FAULT(s->tf_dpfsr));
		}
	}
#endif	/* M88100 */

	if (s->tf_fpecr & 255) { /* floating point error occurred */
		db_printf("fpecr: 0x%08lx fpsr: 0x%08lx fpcr: 0x%08lx\n",
		    s->tf_fpecr, s->tf_fpsr, s->tf_fpcr);
#ifdef M88100
		if (CPU_IS88100) {
			db_printf("fcr1-4: 0x%08lx  0x%08lx  0x%08lx  0x%08lx\n",
			    s->tf_fphs1, s->tf_fpls1, s->tf_fphs2, s->tf_fpls2);
			db_printf("fcr5-8: 0x%08lx  0x%08lx  0x%08lx  0x%08lx\n",
			    s->tf_fppt, s->tf_fprh, s->tf_fprl, s->tf_fpit);
		}
#endif
	}
	db_printf("\n");
}

void
m88k_db_registers(addr, have_addr, count, modif)
	db_expr_t addr;
	int have_addr;
	db_expr_t count;
	char *modif;
{
	m88k_db_print_frame((db_expr_t)&ddb_regs, TRUE, 0, modif);
}

/*
 * m88k_db_trap - field a TRACE or BPT trap
 * Note that only the tf_regs part of the frame is valid - some ddb routines
 * invoke this function with a promoted struct reg!
 */
void
m88k_db_trap(type, frame)
	int type;
	struct trapframe *frame;
{
#ifdef MULTIPROCESSOR
	struct cpu_info *ci = curcpu();
#endif

	switch(type) {
	case T_KDB_BREAK:
	case T_KDB_TRACE:
	case T_KDB_ENTRY:
		break;
	case -1:
		break;
	default:
		kdbprinttrap(type);
		if (db_recover != 0) {
			db_error("Caught exception in ddb.\n");
			/*NOTREACHED*/
		}
	}

#ifdef MULTIPROCESSOR
	ci->ci_ddb_state = CI_DDB_ENTERDDB;
	__mp_lock(&ddb_mp_lock);
	ci->ci_ddb_state = CI_DDB_INDDB;
	ddb_mp_nextcpu = (cpuid_t)-1;
	m88k_broadcast_ipi(CI_IPI_DDB);		/* pause other processors */
#endif

	ddb_regs = frame->tf_regs;

	cnpollc(TRUE);
	db_trap(type, 0);
	cnpollc(FALSE);

	frame->tf_regs = ddb_regs;

#ifdef MULTIPROCESSOR
	ci->ci_ddb_state = CI_DDB_RUNNING;
	__mp_release_all(&ddb_mp_lock);
#endif
}

extern const char *trap_type[];
extern const int trap_types;

/*
 * Print trap reason.
 */
void
kdbprinttrap(int type)
{
	printf("kernel: ");
	if (type >= trap_types || type < 0)
		printf("type %d", type);
	else
		printf("%s", trap_type[type]);
	printf(" trap\n");
}

void
db_enter(void)
{
	asm (ENTRY_ASM); /* entry trap */
	/* ends up at ddb_entry_trap below */
	return;
}

/*
 * When the below routine is entered interrupts should be on
 * but spl should be high
 *
 * The following routine is for breakpoint and watchpoint entry.
 */

/* breakpoint/watchpoint entry */
int
ddb_break_trap(type, eframe)
	int type;
	db_regs_t *eframe;
{
	m88k_db_trap(type, (struct trapframe *)eframe);

	if (type == T_KDB_BREAK) {
		/*
		 * back up an instruction and retry the instruction
		 * at the breakpoint address.  mc88110's exip reg
		 * already has the address of the exception instruction.
		 */
		if (CPU_IS88100)
			m88100_rewind_insn(eframe);
	}

	return 0;
}

/* enter at splhigh */
int
ddb_entry_trap(level, eframe)
	int level;
	db_regs_t *eframe;
{
	m88k_db_trap(T_KDB_ENTRY, (struct trapframe *)eframe);

	return 0;
}

/*
 * Read bytes from kernel address space for debugger.
 */
void
db_read_bytes(db_addr_t addr, size_t size, char *data)
{
	char *src;

	src = (char *)addr;

	while (size-- > 0) {
		*data++ = *src++;
	}
}

/*
 * Write bytes to kernel address space for debugger.
 */
void
db_write_bytes(db_addr_t addr, size_t size, char *data)
{
	extern pt_entry_t *pmap_pte(pmap_t, vaddr_t);
	char *dst = (char *)addr;
	vaddr_t va;
	paddr_t pa;
	pt_entry_t *pte, opte, npte;
	size_t len, olen;
	int cpu = cpu_number();

	while (size != 0) {
		va = trunc_page((vaddr_t)dst);
#ifdef M88100
		if (CPU_IS88100 && va >= BATC8_VA)
			pte = NULL;
		else
#endif
			pte = pmap_pte(pmap_kernel(), va);
		if (pte != NULL) {
			opte = *pte;
			pa = (opte & PG_FRAME) | ((vaddr_t)dst & PAGE_MASK);
		}
		len = PAGE_SIZE - ((vaddr_t)dst & PAGE_MASK);
		if (len > size)
			len = size;
		size -= olen = len;

		if (pte != NULL && (opte & PG_RO)) {
			npte = opte & ~PG_RO;
			*pte = npte;
			cmmu_tlbis(cpu, va, npte);
		}
		while (len-- != 0)
			*dst++ = *data++;
		if (pte != NULL && (opte & PG_RO)) {
			*pte = opte;
			cmmu_tlbis(cpu, va, opte);
		}
		if (pte != NULL && (opte & (CACHE_INH | CACHE_WT)) == 0) {
			cmmu_dcache_wb(cpu, pa, olen);
			cmmu_icache_inv(cpu, pa, olen);
		}
	}
}

/* display where all the cpus are stopped at */
void
m88k_db_where(addr, have_addr, count, modif)
	db_expr_t addr;
	int have_addr;
	db_expr_t count;
	char *modif;
{
	char *name;
	db_expr_t offset;
	db_addr_t l;

	l = PC_REGS(&ddb_regs); /* clear low bits */

	db_find_xtrn_sym_and_offset(l, &name, &offset);
	if (name && (u_int)offset <= db_maxoff)
		db_printf("stopped at 0x%lx  (%s+0x%lx)\n", l, name, offset);
	else
		db_printf("stopped at 0x%lx\n", l);
}

/*
 * Walk back a stack, looking for exception frames.
 * These frames are recognized by the routine frame_is_sane. Frames
 * only start with zero, so we only call frame_is_sane if the
 * current address contains zero.
 *
 * If addr is given, it is assumed to an address on the stack to be
 * searched. Otherwise, r31 of the current cpu is used.
 */
void
m88k_db_frame_search(addr, have_addr, count, modif)
	db_expr_t addr;
	int have_addr;
	db_expr_t count;
	char *modif;
{
	if (have_addr)
		addr &= ~3; /* round to word */
	else
		addr = (ddb_regs.r[31]);

	/* walk back up stack until 8k boundry, looking for 0 */
	while (addr & ((8 * 1024) - 1)) {
		if (frame_is_sane((db_regs_t *)addr, 1) != 0)
			db_printf("frame found at 0x%lx\n", addr);
		addr += 4;
	}

	db_printf("(Walked back until 0x%lx)\n",addr);
}

#ifdef MULTIPROCESSOR

void
m88k_db_cpu_cmd(db_expr_t addr, int have_addr, db_expr_t count, char *modif)
{
	cpuid_t cpu;
	struct cpu_info *ci;
	char state[15];

	/* switch to another processor if requested */
	if (have_addr) {
		cpu = (cpuid_t)addr;
		if (cpu >= 0 && cpu < MAX_CPUS &&
		    ISSET(m88k_cpus[cpu].ci_flags, CIF_ALIVE)) {
			ddb_mp_nextcpu = cpu;
			db_cmd_loop_done = 1;
		} else {
			db_printf("cpu%ld is not active\n", cpu);
		}
		return;
	}

	db_printf(" cpu  flags state          curproc  curpcb   depth    ipi\n");
	CPU_INFO_FOREACH(cpu, ci) {
		switch (ci->ci_ddb_state) {
		case CI_DDB_RUNNING:
			strlcpy(state, "running", sizeof state);
			break;
		case CI_DDB_ENTERDDB:
			strlcpy(state, "entering ddb", sizeof state);
			break;
		case CI_DDB_INDDB:
			strlcpy(state, "in ddb", sizeof state);
			break;
		case CI_DDB_PAUSE:
			strlcpy(state, "paused", sizeof state);
			break;
		default:
			snprintf(state, sizeof state, "unknown (%d)",
			    ci->ci_ddb_state);
			break;
		}
		db_printf("%ccpu%d   %02x  %-14s %08lx %08lx %3u %08x\n",
		    (cpu == cpu_number()) ? '*' : ' ', CPU_INFO_UNIT(ci),
		    ci->ci_flags, state, (register_t)ci->ci_curproc,
		    (register_t)ci->ci_curpcb, ci->ci_intrdepth, ci->ci_ipi);
	}
}

#endif	/* MULTIPROCESSOR */

/************************/
/* COMMAND TABLE / INIT */
/************************/

struct db_command db_machine_cmds[] = {
#ifdef MULTIPROCESSOR
	{ "ddbcpu",	m88k_db_cpu_cmd,	0,	NULL },
#endif
	{ "frame",	m88k_db_print_frame,	0,	NULL },
	{ "regs",	m88k_db_registers,	0,	NULL },
	{ "searchframe",m88k_db_frame_search,	0,	NULL },
	{ "where",	m88k_db_where,		0,	NULL },
#if defined(EXTRA_MACHDEP_COMMANDS)
	EXTRA_MACHDEP_COMMANDS
#endif
	{ NULL,		NULL,			0,	NULL }
};

void
db_machine_init()
{
	db_machine_commands_install(db_machine_cmds);
#ifdef MULTIPROCESSOR
	__mp_lock_init(&ddb_mp_lock);
#endif
}
@


1.21
log
@Convert DDB_REGS -> &ddb_regs, inputs and ok naddy@@

Put addresses instead of registers inside db_regs[] to match what other
archs do and to get rid of db_setf_regs().
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.20 2014/05/31 11:19:06 miod Exp $	*/
d438 1
a438 1
Debugger()
@


1.20
log
@Introduce m88100_rewind_insn() to rewind the execution pipeline one
instruction, rather than gazillions of inline variants. This also makes
the situations where we clear specific bits in the fip or nip registers
more visible.

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.19 2014/05/08 22:17:33 miod Exp $	*/
d366 1
a366 1
	m88k_db_print_frame((db_expr_t)DDB_REGS, TRUE, 0, modif);
d560 1
a560 1
	l = PC_REGS(DDB_REGS); /* clear low bits */
d588 1
a588 1
		addr = (DDB_REGS->r[31]);
@


1.19
log
@Format string fixes for m88k; remove -Wno-format from the m88k kernels.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.18 2011/10/25 18:38:06 miod Exp $	*/
d466 2
a467 4
		if (CPU_IS88100) {
			eframe->sfip = eframe->snip;
			eframe->snip = eframe->sxip;
		}
@


1.18
log
@Replace the naive 88110 tlb update code, which would always invalidate the
whole tlb (32 of 'em), with smarter `tlb probe and update with new pte if tlb
match found' code. This makes the 88110-specific pmap_update() unnecessary, as
updates are no longer aggregated to avoid the number of flushes. This also
makes tlb handling similar between 88100 and 88110, from the pmap's point of
view, so there is no need to use different routines.

No impact on 88100, no user-noticeable performance change on 88100 GENERIC,
slight improvement on 88110 GENERIC.MP.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.17 2011/01/05 22:14:29 miod Exp $	*/
d224 1
a224 1
	db_printf("R00-05: 0x%08x  0x%08x  0x%08x  0x%08x  0x%08x  0x%08x\n",
d226 1
a226 1
	db_printf("R06-11: 0x%08x  0x%08x  0x%08x  0x%08x  0x%08x  0x%08x\n",
d228 1
a228 1
	db_printf("R12-17: 0x%08x  0x%08x  0x%08x  0x%08x  0x%08x  0x%08x\n",
d230 1
a230 1
	db_printf("R18-23: 0x%08x  0x%08x  0x%08x  0x%08x  0x%08x  0x%08x\n",
d232 1
a232 1
	db_printf("R24-29: 0x%08x  0x%08x  0x%08x  0x%08x  0x%08x  0x%08x\n",
d234 1
a234 1
	db_printf("R30-31: 0x%08x  0x%08x\n", R(30), R(31));
d236 1
a236 1
	db_printf("%cxip: 0x%08x ",
d245 1
a245 1
		db_printf("%cnip: 0x%08x ",
d257 1
a257 1
			db_printf("sfip: 0x%08x ", s->tf_sfip);
d268 1
a268 1
		db_printf("fpsr: 0x%08x fpcr: 0x%08x fpecr: 0x%08x\n",
d270 1
a270 1
		db_printf("dsap 0x%08x duap 0x%08x dsr 0x%08x dlar 0x%08x dpar 0x%08x\n",
d272 1
a272 1
		db_printf("isap 0x%08x iuap 0x%08x isr 0x%08x ilar 0x%08x ipar 0x%08x\n",
d277 1
a277 1
	db_printf("epsr: 0x%08x                current process: %p\n",
d279 1
a279 1
	db_printf("vector: 0x%02x                    interrupt mask: 0x%08x\n",
d297 1
a297 1
			db_printf("dmt,d,a0: 0x%08x  0x%08x  0x%08x ",
d310 1
a310 1
				db_printf("dmt,d,a1: 0x%08x  0x%08x  0x%08x ",
d323 1
a323 1
					db_printf("dmt,d,a2: 0x%08x  0x%08x  0x%08x ",
d338 1
a338 1
			db_printf("fault code %d\n",
d345 1
a345 1
		db_printf("fpecr: 0x%08x fpsr: 0x%08x fpcr: 0x%08x\n",
d349 1
a349 1
			db_printf("fcr1-4: 0x%08x  0x%08x  0x%08x  0x%08x\n",
d351 1
a351 1
			db_printf("fcr5-8: 0x%08x  0x%08x  0x%08x  0x%08x\n",
d566 1
a566 1
		db_printf("stopped at 0x%lx  (%s+0x%x)\n", l, name, offset);
d595 1
a595 1
			db_printf("frame found at 0x%x\n", addr);
d599 1
a599 1
	db_printf("(Walked back until 0x%x)\n",addr);
d619 1
a619 1
			db_printf("cpu%d is not active\n", cpu);
d644 1
a644 1
		db_printf("%ccpu%1d   %02x  %-14s %08x %08x %3d %08x\n",
d646 2
a647 2
		    ci->ci_flags, state, ci->ci_curproc, ci->ci_curpcb,
		    ci->ci_intrdepth, ci->ci_ipi);
@


1.17
log
@Now that pmap_copy_page() no longer needs to flush a couple contiguous tlb
entries, drop the count parameter to cmmu_tlb_inv(), and introduce
cmmu_tlb_inv_all() to drop all user tlb entries (to be used during context
switches).
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.16 2010/12/31 20:38:55 miod Exp $	*/
d511 1
a511 1
	pt_entry_t *pte, opte;
d533 3
a535 2
			*pte = opte & ~PG_RO;
			cmmu_tlb_inv(cpu, TRUE, va);
d541 1
a541 1
			cmmu_tlb_inv(cpu, TRUE, va);
@


1.16
log
@In db_write_bytes(), cope with memory addresses mapped by the two hardwired
88200 BATC entries, and don't bother trying to flip pte bits in that case.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.15 2009/03/15 20:39:53 miod Exp $	*/
d534 1
a534 1
			cmmu_tlb_inv(cpu, TRUE, va, 1);
d540 1
a540 1
			cmmu_tlb_inv(cpu, TRUE, va, 1);
@


1.15
log
@Generic softinterrupt support for m88k based platforms, adapted from arm
with different locking mechanism. 88110 soft ipi are replaced with an
ipi callback which is checked upon return from exception (it can not be kept
as a softintr, as the generic softinterrupt code doesn't have per-cpu
pending softintr queues).
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.14 2008/10/27 18:03:46 miod Exp $	*/
d517 10
a526 4
		pte = pmap_pte(pmap_kernel(), va);
		opte = *pte;

		pa = (opte & PG_FRAME) | ((vaddr_t)dst & PAGE_MASK);
d532 1
a532 1
		if (opte & PG_RO) {
d534 1
a534 1
			cmmu_flush_tlb(cpu, TRUE, va, 1);
d538 1
a538 1
		if (opte & PG_RO) {
d540 5
a544 1
			cmmu_flush_tlb(cpu, TRUE, va, 1);
a545 1
		cmmu_flush_cache(cpu, pa, olen);
@


1.14
log
@Rename "machine cpu" to "machine ddbcpu" in MP kernels, for consistency with
other MP platforms.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.13 2008/07/28 17:57:25 miod Exp $	*/
d614 1
a614 1
	db_printf(" cpu  flags state          curproc  curpcb   depth    ipi softintr\n");
d626 3
d634 1
a634 1
		db_printf("%ccpu%1d   %02x  %-14s %08x %08x %3d %08x %08x\n",
d637 1
a637 1
		    ci->ci_intrdepth, ci->ci_ipi, ci->ci_softintr);
@


1.13
log
@Remove dead code.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.12 2007/12/04 23:45:52 miod Exp $	*/
d646 1
a646 1
	{ "cpu",	m88k_db_cpu_cmd,	0,	NULL },
@


1.12
log
@Work in progress SMP code for 88110 processor using the BusSwitch chip as
an IPI facility, for MVME197DP.

It's still missing a few remote cache IPIs and IPI do not seem to be reliably
triggered on remote processors at the moment (but this could be a problem
on the board I am currently testing on), at least it will boot multiuser
using only cpu0 to schedule processes.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.11 2007/11/14 23:15:03 miod Exp $	*/
a66 2
void	ddb_error_trap(char *, db_regs_t *);
void	m88k_db_pause(u_int);
a369 11
 * pause for 2*ticks many cycles
 */
void
m88k_db_pause(ticks)
	u_int volatile ticks;
{
	while (ticks)
		ticks -= 1;
}

/*
a483 18
}

/*
 * When the below routine is entered interrupts should be on
 * but spl should be high
 */
/* error trap - unreturnable */
void
ddb_error_trap(error, regs)
	char *error;
	db_regs_t *regs;
{
	db_printf("KERNEL:  unrecoverable error [%s]\n", error);
	db_printf("KERNEL:  Exiting debugger will cause abort to rom\n");
	db_printf("at 0x%x ", regs->sxip & XIP_ADDR);
	db_printf("dmt0 0x%x dma0 0x%x", regs->dmt0, regs->dma0);
	m88k_db_pause(1000000);
	m88k_db_trap(T_KDB_BREAK, (struct trapframe *)regs);
@


1.11
log
@Cache curcpu() value into a local variable when it is used more than once in
a function, so that it does not get reloaded from cr17 every time.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.10 2007/11/14 23:12:46 miod Exp $	*/
d645 1
a645 1
	db_printf(" cpu  state          curproc  curpcb   depth    ipi softintr\n");
d662 1
a662 1
		db_printf("%ccpu%1d %-14s %08x %08x %3d %08x %08x\n",
d664 2
a665 2
		    state, ci->ci_curproc, ci->ci_curpcb, ci->ci_intrdepth,
		    ci->ci_ipi, ci->ci_softintr);
@


1.10
log
@Merge the ci_alive and ci_primary boolean values of struct cpu_info into
a single ci_flags bitfield.

Also, set_cpu_number() will no longer set CIF_PRIMARY on the primary processor,
it's up to the initialization code to do this.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.9 2007/11/14 17:54:25 miod Exp $	*/
d392 3
a394 2
	if (get_psr() & PSR_IND)
		db_printf("WARNING: entered debugger with interrupts disabled\n");
d412 1
a412 1
	curcpu()->ci_ddb_state = CI_DDB_ENTERDDB;
d414 1
a414 1
	curcpu()->ci_ddb_state = CI_DDB_INDDB;
d428 1
a428 1
	curcpu()->ci_ddb_state = CI_DDB_RUNNING;
@


1.9
log
@Let ``machine cpu #'' hop to the given cpu.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.8 2007/11/11 21:15:34 miod Exp $	*/
d634 2
a635 1
		if (cpu >= 0 && cpu < MAX_CPUS && m88k_cpus[cpu].ci_alive) {
@


1.8
log
@Give more information in ``machine cpu'' under ddb.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.7 2007/05/19 20:33:49 miod Exp $	*/
d55 1
d81 1
d414 1
d630 12
@


1.7
log
@Force other processors to spin when one is in ddb.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.6 2007/03/21 19:32:17 miod Exp $	*/
d626 1
d628 1
a629 2
		db_printf("%c%4d: ", (cpu == cpu_number()) ? '*' : ' ',
		    CPU_INFO_UNIT(ci));
d632 1
a632 1
			db_printf("running\n");
d635 1
a635 1
			db_printf("entering ddb\n");
d638 1
a638 1
			db_printf("ddb\n");
d641 1
a641 1
			db_printf("? (%d)\n",
d645 4
@


1.6
log
@Uninitialized variable in db_write_bytes().
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.5 2006/05/08 14:36:09 miod Exp $	*/
d412 1
@


1.5
log
@Replace gazillions of badvaddr() or badwordaddr() calls with badaddr() calls.
With a few prototype declarations shuffling, this finally allows
<machine/locore.h> to die.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.4 2005/12/11 21:45:30 miod Exp $	*/
d534 1
a534 1
	char *dst;
@


1.4
log
@Work in progress SMP code; mvme88k boards can spin up secondary CPUs,
kernel boots single user. Still a lot of polishing and bugfixing to do.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.3 2005/12/04 12:20:19 miod Exp $	*/
a43 1
#include <machine/locore.h>
d211 2
a212 2
	if (badwordaddr((vaddr_t)s) ||
	    badwordaddr((vaddr_t)(&((db_regs_t*)s)->fpit))) {
@


1.3
log
@Slight cmmu code cleanup; use shorter function names, remove parity_enable
and the DDB and DEBUG helpers which are of questionable usefulness, some
stylistic changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.2 2005/11/20 22:04:32 miod Exp $	*/
d78 7
d409 6
d422 5
d619 31
d655 3
d672 3
@


1.2
log
@Remove unused ddb_nmi_trap().
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.1 2005/10/24 19:28:28 miod Exp $	*/
a600 61
/*
 * See how a virtual address translates.
 * Must have an address.
 */
void
m88k_db_translate(addr, have_addr, count, modif)
	db_expr_t addr;
	int have_addr;
	db_expr_t count;
	char *modif;
{
	char c;
	int verbose_flag = 0;
	int supervisor_flag = 1;
	int wanthelp = 0;

	if (!have_addr)
		wanthelp = 1;
	else {
		while (c = *modif++, c != 0) {
			switch (c) {
			default:
				db_printf("bad modifier [%c]\n", c);
				wanthelp = 1;
				break;
			case 'h':
				wanthelp = 1;
				break;
			case 'v':
				verbose_flag++;
				break;
			case 's':
				supervisor_flag = 1;
				break;
			case 'u':
				supervisor_flag = 0;
				break;
			}
		}
	}

	if (wanthelp) {
		db_printf("usage: translate[/vvsu] address\n");
		db_printf("flags: v - be verbose (vv - be very verbose)\n");
		db_printf("       s - use cmmu's supervisor area pointer (default)\n");
		db_printf("       u - use cmmu's user area pointer\n");
		return;
	}
	cmmu_show_translation(addr, supervisor_flag, verbose_flag, -1);
}

void
m88k_db_cmmucfg(addr, have_addr, count, modif)
	db_expr_t addr;
	int have_addr;
	db_expr_t count;
	char *modif;
{
	cmmu_dump_config();
}

a608 2
	{ "translate",	m88k_db_translate,	0,	NULL },
	{ "cmmucfg",	m88k_db_cmmucfg,	0,	NULL },
@


1.1
log
@Factorize db_interface code between luna88k and mvme88k, removing dead code
in the process; the arch-agnostic code keeps the ability for a specific
machine to define its own machine commands, such as "machine prom" for
mvme88k, in addition to the ``regular'' m88k machine commands.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.44 2005/04/30 16:44:11 miod Exp $	*/
a66 1
int	ddb_nmi_trap(int, db_regs_t *);
d433 1
a433 12
}

/* fielded a non maskable interrupt */
int
ddb_nmi_trap(level, eframe)
	int level;
	db_regs_t *eframe;
{
	db_printf("kernel: nmi interrupt\n");
	m88k_db_trap(T_KDB_ENTRY, (struct trapframe *)eframe);

	return 0;
@

