head	1.17;
access;
symbols
	OPENBSD_6_2_BASE:1.17
	OPENBSD_6_1:1.16.0.4
	OPENBSD_6_1_BASE:1.16
	OPENBSD_6_0:1.15.0.2
	OPENBSD_6_0_BASE:1.15
	OPENBSD_5_9:1.13.0.6
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.13.0.8
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.13.0.4
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.12.0.16
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.12.0.12
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.12.0.10
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.8
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.6
	OPENBSD_5_0:1.12.0.4
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.2
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.11.0.4
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.2
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.10.0.10
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.8
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.4
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.2
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.9.0.6
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.4
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.2
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.7.0.2
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.6.0.2
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.3.0.2
	OPENBSD_3_7_BASE:1.3
	OPENBSD_3_6:1.2.0.2
	OPENBSD_3_6_BASE:1.2;
locks; strict;
comment	@ * @;


1.17
date	2017.05.30.15.39.04;	author mpi;	state Exp;
branches;
next	1.16;
commitid	PnZZkFEIj4rPydZo;

1.16
date	2016.09.19.21.18.35;	author jasper;	state Exp;
branches;
next	1.15;
commitid	504EMnf4FZsQ0Gj3;

1.15
date	2016.03.09.08.58.50;	author mpi;	state Exp;
branches;
next	1.14;
commitid	5oeMKdWr273HqanP;

1.14
date	2016.03.01.11.56.00;	author mpi;	state Exp;
branches;
next	1.13;
commitid	CZXiyhU8oBcz6IpF;

1.13
date	2014.07.13.12.11.01;	author jasper;	state Exp;
branches;
next	1.12;
commitid	XHZxhpAa5R1Ymp1z;

1.12
date	2011.01.03.05.58.19;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2009.12.16.16.54.43;	author jasper;	state Exp;
branches;
next	1.10;

1.10
date	2007.11.17.05.36.23;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2006.05.08.14.36.09;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2006.05.07.15.47.12;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2005.11.20.22.07.09;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2005.05.15.14.33.04;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2005.05.15.14.16.41;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2005.04.30.16.44.08;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2004.09.30.21.48.56;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2004.07.28.12.33.55;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2004.06.19.18.28.37;	author miod;	state Exp;
branches;
next	;


desc
@@


1.17
log
@Kill db_sym_t.

ok deraadt@@, kettenis@@, jasper@@
@
text
@/*	$OpenBSD: db_trace.c,v 1.16 2016/09/19 21:18:35 jasper Exp $	*/
/*
 * Mach Operating System
 * Copyright (c) 1993-1991 Carnegie Mellon University
 * Copyright (c) 1991 OMRON Corporation
 * All Rights Reserved.
 *
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON AND OMRON ALLOW FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON AND OMRON DISCLAIM ANY LIABILITY OF ANY KIND
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

#include <sys/param.h>
#include <sys/systm.h>

#include <machine/cpu.h>
#include <machine/db_machdep.h>

#include <ddb/db_variables.h>	/* db_variable, DB_VAR_GET, etc.  */
#include <ddb/db_output.h>	/* db_printf                      */
#include <ddb/db_sym.h>		/* DB_STGY_PROC, etc.             */
#include <ddb/db_command.h>	/* db_recover                     */
#include <ddb/db_access.h>
#include <ddb/db_interface.h>

#ifdef DEBUG
#define	DPRINTF(stmt) printf stmt
#else
#define	DPRINTF(stmt) do { } while (0)
#endif

static inline
u_int br_dest(vaddr_t addr, u_int inst)
{
	inst = (inst & 0x03ffffff) << 2;
	/* check if sign extension is needed */
	if (inst & 0x08000000)
		inst |= 0xf0000000;
	return (addr + inst);
}

int frame_is_sane(db_regs_t *regs, int);
const char *m88k_exception_name(u_int vector);
u_int db_trace_get_val(vaddr_t addr, u_int *ptr);

/*
 * Some macros to tell if the given text is the instruction.
 */
#define JMPN_R1(I)		((I) == 0xf400c401)	/* jmp.n r1 */
#define JMP_R1(I)		((I) == 0xf400c001)	/* jmp r1 */

/* gets the IMM16 value from an instruction */
#define IMM16VAL(I)		((I) & 0x0000ffff)

/* subu r31, r31, IMM */
#define SUBU_R31_R31_IMM(I)	(((I) & 0xffff0000) == 0x67ff0000U)

/* st r30, r31, IMM */
#define ST_R30_R31_IMM(I)	(((I) & 0xffff0000) == 0x27df0000U)

extern label_t *db_recover;

/*
 * m88k trace/register state interface for ddb.
 */

#define N(s, x)  {s, (long *)&ddb_regs.x, FCN_NULL}

struct db_variable db_regs[] = {
	N("r1", r[1]),     N("r2", r[2]),    N("r3", r[3]),    N("r4", r[4]),
	N("r5", r[5]),     N("r6", r[6]),    N("r7", r[7]),    N("r8", r[8]),
	N("r9", r[9]),     N("r10", r[10]),  N("r11", r[11]),  N("r12", r[12]),
	N("r13", r[13]),   N("r14", r[14]),  N("r15", r[15]),  N("r16", r[16]),
	N("r17", r[17]),   N("r18", r[18]),  N("r19", r[19]),  N("r20", r[20]),
	N("r21", r[21]),   N("r22", r[22]),  N("r23", r[23]),  N("r24", r[24]),
	N("r25", r[25]),   N("r26", r[26]),  N("r27", r[27]),  N("r28", r[28]),
	N("r29", r[29]),   N("r30", r[30]),  N("r31", r[31]),  N("epsr", epsr),
	N("sxip", sxip),   N("snip", snip),  N("sfip", sfip),  N("ssbr", ssbr),
	N("dmt0", dmt0),   N("dmd0", dmd0),  N("dma0", dma0),  N("dmt1", dmt1),
	N("dmd1", dmd1),   N("dma1", dma1),  N("dmt2", dmt2),  N("dmd2", dmd2),
	N("dma2", dma2),   N("fpecr", fpecr),N("fphs1", fphs1),N("fpls1", fpls1),
	N("fphs2", fphs2), N("fpls2", fpls2),N("fppt", fppt),  N("fprh", fprh),
	N("fprl", fprl),   N("fpit", fpit),  N("fpsr", fpsr),  N("fpcr", fpcr),
};
#undef N

struct db_variable *db_eregs = db_regs + nitems(db_regs);

#define TRASHES    0x001	/* clobbers instruction field D */
#define STORE      0x002	/* does a store to S1+IMM16 */
#define LOAD       0x004	/* does a load from S1+IMM16 */
#define DOUBLE     0x008	/* double-register */
#define FLOW_CTRL  0x010	/* flow-control instruction */
#define DELAYED    0x020	/* delayed flow control */
#define JSR	   0x040	/* flow-control is a jsr[.n] */
#define BSR	   0x080	/* flow-control is a bsr[.n] */

/*
 * Given a word of instruction text, return some flags about that
 * instruction (flags defined above).
 */
static u_int
m88k_instruction_info(u_int32_t instruction)
{
	static const struct {
		u_int32_t mask, value;
		u_int flags;
	} *ptr, control[] = {
		/* runs in the same order as 2nd Ed 88100 manual Table 3-14 */
		{ 0xf0000000U, 0x00000000U, /* xmem */     TRASHES | STORE | LOAD},
		{ 0xec000000U, 0x00000000U, /* ld.d */     TRASHES | LOAD | DOUBLE},
		{ 0xe0000000U, 0x00000000U, /* load */     TRASHES | LOAD},
		{ 0xfc000000U, 0x20000000U, /* st.d */     STORE | DOUBLE},
		{ 0xf0000000U, 0x20000000U, /* store */    STORE},
		{ 0xc0000000U, 0x40000000U, /* arith */    TRASHES},
		{ 0xfc004000U, 0x80004000U, /* ld cr */    TRASHES},
		{ 0xfc004000U, 0x80000000U, /* st cr */    0},
		{ 0xfc008060U, 0x84000000U, /* f */        TRASHES},
		{ 0xfc008060U, 0x84000020U, /* f.d */      TRASHES | DOUBLE},
		{ 0xfc000000U, 0xcc000000U, /* bsr.n */    FLOW_CTRL | DELAYED | BSR},
		{ 0xfc000000U, 0xc8000000U, /* bsr */      FLOW_CTRL | BSR},
		{ 0xe4000000U, 0xc4000000U, /* br/bb.n */  FLOW_CTRL | DELAYED},
		{ 0xe4000000U, 0xc0000000U, /* br/bb */    FLOW_CTRL},
		{ 0xfc000000U, 0xec000000U, /* bcnd.n */   FLOW_CTRL | DELAYED},
		{ 0xfc000000U, 0xe8000000U, /* bcnd */     FLOW_CTRL},
		{ 0xfc00c000U, 0xf0008000U, /* bits */     TRASHES},
		{ 0xfc00c000U, 0xf000c000U, /* trap */     0},
		{ 0xfc00f0e0U, 0xf4002000U, /* st */       0},
		{ 0xfc00cce0U, 0xf4000000U, /* ld.d */     TRASHES | DOUBLE},
		{ 0xfc00c0e0U, 0xf4000000U, /* ld */       TRASHES},
		{ 0xfc00c0e0U, 0xf4004000U, /* arith */    TRASHES},
		{ 0xfc00c3e0U, 0xf4008000U, /* bits */     TRASHES},
		{ 0xfc00ffe0U, 0xf400cc00U, /* jsr.n */    FLOW_CTRL | DELAYED | JSR},
		{ 0xfc00ffe0U, 0xf400c800U, /* jsr */      FLOW_CTRL | JSR},
		{ 0xfc00ffe0U, 0xf400c400U, /* jmp.n */    FLOW_CTRL | DELAYED},
		{ 0xfc00ffe0U, 0xf400c000U, /* jmp */      FLOW_CTRL},
		{ 0xfc00fbe0U, 0xf400e800U, /* ff */       TRASHES},
		{ 0xfc00ffe0U, 0xf400f800U, /* tbnd */     0},
		{ 0xfc00ffe0U, 0xf400fc00U, /* rte */      FLOW_CTRL},
		{ 0xfc000000U, 0xf8000000U, /* tbnd */     0},
	};

	for (ptr = &control[0]; ptr < &control[nitems(control)]; ptr++)
		if ((instruction & ptr->mask) == ptr->value)
			return ptr->flags;
	return 0;
}

static int
hex_value_needs_0x(u_int value)
{
	int c;
	int have_a_hex_digit = 0;

	if (value <= 9)
		return (0);

	while (value != 0) {
		c = value & 0xf;
		value >>= 4;
		if (c > 9)
			have_a_hex_digit = 1;
	}
	if (have_a_hex_digit == 0)	/* has no letter, thus needs 0x */
		return (1);
	if (c > 9)		/* starts with a letter, thus needs 0x */
		return (1);
	return (0);
}

/*
 * returns
 *   1 if regs seems to be a reasonable kernel exception frame.
 *   2 if regs seems to be a reasonable user exception frame
 * 	(in the current task).
 *   0 if this looks like neither.
 */
int
frame_is_sane(db_regs_t *regs, int quiet)
{
	/* no good if we can't read the whole frame */
	if (badaddr((vaddr_t)regs, 4) || badaddr((vaddr_t)&regs->fpit, 4)) {
		if (quiet == 0)
			db_printf("[WARNING: frame at %p : unreadable]\n", regs);
		return 0;
	}

	/* r0 must be 0 (obviously) */
	if (regs->r[0] != 0) {
		if (quiet == 0)
			db_printf("[WARNING: frame at %p : r[0] != 0]\n", regs);
		return 0;
	}

	/* stack sanity ... r31 must be nonzero, and must be word aligned */
	if (regs->r[31] == 0 || (regs->r[31] & 3) != 0) {
		if (quiet == 0)
			db_printf("[WARNING: frame at %p : r[31] == 0 or not word aligned]\n", regs);
		return 0;
	}

#ifdef M88100
	if (CPU_IS88100) {
		/* sxip is reasonable */
#if 0
		if ((regs->sxip & XIP_E) != 0)
			goto out;
#endif
		/* snip is reasonable */
		if ((regs->snip & ~NIP_ADDR) != NIP_V)
			goto out;
		/* sfip is reasonable */
		if ((regs->sfip & ~FIP_ADDR) != FIP_V)
			goto out;
	}
#endif

	/* epsr sanity */
	if (regs->epsr & PSR_BO)
		goto out;

	return ((regs->epsr & PSR_MODE) ? 1 : 2);

out:
	if (quiet == 0)
		db_printf("[WARNING: not an exception frame?]\n");
	return (0);
}

const char *
m88k_exception_name(u_int vector)
{
	switch (vector) {
	default:
	case   0: return "Reset";
	case   1: return "Interrupt";
	case   2: return "Instruction Access Exception";
	case   3: return "Data Access Exception";
	case   4: return "Misaligned Access Exception";
	case   5: return "Unimplemented Opcode Exception";
	case   6: return "Privilege Violation";
	case   7: return "Bounds Check";
	case   8: return "Integer Divide Exception";
	case   9: return "Integer Overflow Exception";
	case  10: return "Error Exception";
	case  11: return "Non Maskable Interrupt";
	case 114: return "FPU precise";
	case 115: return "FPU imprecise";
	case DDB_ENTRY_BKPT_NO:
		return "ddb break";
	case DDB_ENTRY_TRACE_NO:
		return "ddb trace";
	case DDB_ENTRY_TRAP_NO:
		return "ddb trap";
	case 451: return "Syscall";
	}
}

/*
 * Read a word at address addr.
 * Return 1 if was able to read, 0 otherwise.
 */
u_int
db_trace_get_val(vaddr_t addr, u_int *ptr)
{
	label_t db_jmpbuf;
	label_t *prev = db_recover;

	if (setjmp((db_recover = &db_jmpbuf)) != 0) {
		db_recover = prev;
		return 0;
	} else {
		db_read_bytes(addr, 4, (char *)ptr);
		db_recover = prev;
		return 1;
	}
}

#define	FIRST_CALLPRESERVED_REG	14
#define	LAST_CALLPRESERVED_REG	29
#define	FIRST_ARG_REG		2
#define	LAST_ARG_REG		9
#define	RETURN_VAL_REG		1

static u_int global_saved_list = 0x0; /* one bit per register */
static u_int local_saved_list  = 0x0; /* one bit per register */
static u_int trashed_list      = 0x0; /* one bit per register */
static u_int saved_reg[32];		 /* one value per register */

#define	reg_bit(reg)	1 << (reg)

static void
save_reg(int reg, u_int value)
{
	reg &= 0x1f;
	if (trashed_list & reg_bit(reg))
		return;	/* don't save trashed registers */

	saved_reg[reg] = value;
	global_saved_list |= reg_bit(reg);
	local_saved_list |= reg_bit(reg);
}

#define	mark_reg_trashed(reg)	trashed_list |= reg_bit((reg) & 0x1f)

#define	have_global_reg(reg)	(global_saved_list & reg_bit(reg))
#define	have_local_reg(reg)	(local_saved_list & reg_bit(reg))

#define	clear_local_saved_regs()	local_saved_list = trashed_list = 0
#define	clear_global_saved_regs()	local_saved_list = global_saved_list = 0

#define	saved_reg_value(reg)	saved_reg[(reg)]

/*
 * Show any arguments that we might have been able to determine.
 */
static void
print_args(void)
{
	int reg, last_arg;

	/* find the highest argument register saved */
	for (last_arg = LAST_ARG_REG; last_arg >= FIRST_ARG_REG; last_arg--)
		if (have_local_reg(last_arg))
			break;
	if (last_arg < FIRST_ARG_REG)
		return;	/* none were saved */

	db_printf("(");

	/* print each one, up to the highest */
	for (reg = FIRST_ARG_REG; /*nothing */; reg++) {
		if (!have_local_reg(reg))
			db_printf("?");
		else {
			u_int value = saved_reg_value(reg);
			db_printf("%s%x", hex_value_needs_0x(value) ?
				  "0x" : "", value);
		}
		if (reg == last_arg)
			break;
		else
			db_printf(", ");
	}
	db_printf(")");
}

#define JUMP_SOURCE_IS_BAD		0
#define JUMP_SOURCE_IS_OK		1
#define JUMP_SOURCE_IS_UNLIKELY		2

/*
 * Give an address to where we return, and an address to where we'd jumped,
 * Decided if it all makes sense.
 *
 * Gcc sometimes optimized something like
 *	if (condition)
 *		func1();
 *	else
 *		OtherStuff...
 * to
 *	bcnd	!condition, mark
 *	bsr.n	func1
 *	 or	r1, r0, mark2
 *    mark:
 *	OtherStuff...
 *    mark2:
 *
 * So RETURN_TO will be mark2, even though we really did branch via
 * 'bsr.n func1', so this makes it difficult to be certain about being
 * wrong.
 */
static int
is_jump_source_ok(vaddr_t return_to, vaddr_t jump_to)
{
	u_int flags;
	uint32_t instruction;

	/*
	 * Delayed branches are the most common... look two instructions before
	 * where we were going to return to to see if it's a delayed branch.
	 */
	if (!db_trace_get_val(return_to - 8, &instruction))
		return JUMP_SOURCE_IS_BAD;

	flags = m88k_instruction_info(instruction);
	if ((flags & (FLOW_CTRL | DELAYED)) == (FLOW_CTRL | DELAYED) &&
	    (flags & (JSR | BSR)) != 0) {
		if ((flags & JSR) != 0)
			return JUMP_SOURCE_IS_OK; /* have to assume it's correct */
		/* calculate the offset */
		if (br_dest(return_to - 8, instruction) == jump_to)
			return JUMP_SOURCE_IS_OK; /* exactamundo! */
		else
			return JUMP_SOURCE_IS_UNLIKELY;	/* seems wrong */
	}

	/*
	 * Try again, looking for a non-delayed jump one instruction back.
	 */
	if (!db_trace_get_val(return_to - 4, &instruction))
		return JUMP_SOURCE_IS_BAD;

	flags = m88k_instruction_info(instruction);
	if ((flags & (FLOW_CTRL | DELAYED)) == FLOW_CTRL &&
	    (flags & (JSR | BSR)) != 0) {
		if ((flags & JSR) != 0)
			return JUMP_SOURCE_IS_OK; /* have to assume it's correct */
		/* calculate the offset */
		if (br_dest(return_to - 4, instruction) == jump_to)
			return JUMP_SOURCE_IS_OK; /* exactamundo! */
		else
			return JUMP_SOURCE_IS_UNLIKELY;	/* seems wrong */
	}

	return JUMP_SOURCE_IS_UNLIKELY;
}

static int next_address_likely_wrong = 0;

/* How much slop we expect in the stack trace */
#define FRAME_PLAY 8

/*
 *  Stack decode -
 *	vaddr_t addr;    program counter
 *	vaddr_t *stack; IN/OUT stack pointer
 *
 * 	given an address within a function and a stack pointer,
 *	try to find the function from which this one was called
 *	and the stack pointer for that function.
 *
 *	The return value is zero if we get confused or
 *	we determine that the return address has not yet
 *	been saved (early in the function prologue). Otherwise
 *	the return value is the address from which this function
 *	was called.
 *
 *	Note that even is zero is returned (the second case) the
 *	stack pointer can be adjusted.
 */
static vaddr_t
stack_decode(db_addr_t addr, vaddr_t *stack, int (*pr)(const char *, ...))
{
	Elf_Sym *proc;
	db_expr_t offset_from_proc;
	uint instructions_to_search;
	db_addr_t check_addr;
	db_addr_t function_addr;    /* start of function */
	uint32_t r31;
	uint32_t inst;
	vaddr_t ret_addr;	    /* address to which we return */
	u_int tried_to_save_r1 = 0;
	vaddr_t str30_addr = 0;
	vaddr_t last_subu_addr = 0;

	/* get what we hope will be the symbol for the function name */
	proc = db_search_symbol(addr, DB_STGY_PROC, &offset_from_proc);
	if (offset_from_proc == addr) /* i.e. no symbol found */
		proc = NULL;

	/*
	 * Try and find the start of this function, and its stack usage.
	 * If we do not have symbols available, we will need to
	 * look back in memory for a prologue pattern.
	 */
	if (proc != NULL) {
		char *names = NULL;
		db_symbol_values(proc, &names, &function_addr);
		if (names == NULL)
			return 0;
	} else {
		/*
		 * Unable to find symbol. Search back looking for a function
		 * prolog.
		 *
		 * This is a difficult game because of the compiler
		 * optimizations. However, we can rely upon the first two
		 * instructions of the function being:
		 *	subu	r31, r31, imm16
		 *	st	r30, r31, imm16
		 * unless the function did not need a frame, in which case
		 * the store of r30 is missing...
		 */
		instructions_to_search = 400;
		for (check_addr = addr; instructions_to_search-- != 0;
		    check_addr -= 4) {
			if (!db_trace_get_val(check_addr, &inst))
				break;

			if (ST_R30_R31_IMM(inst)) {
				DPRINTF(("{st r30 found at %p}\n",
				    check_addr));
				str30_addr = (vaddr_t)check_addr;
			} else if (SUBU_R31_R31_IMM(inst)) {
				DPRINTF(("{subu r31 found at %p}\n",
				    check_addr));
				if (str30_addr == (vaddr_t)check_addr + 4)
					break;	/* success */
				else
					last_subu_addr = (vaddr_t)check_addr;
			}

			/*
			 * if we come across a [jmp r1] or [jmp.n r1] assume
			 * we have hit the previous functions epilogue and
			 * stop our search.
			 * Since we know we would have hit the "subu r31, r31"
			 * if it was right in front of us, we know this doesn't
			 * have one so we just return failure....
			 */
			if (JMP_R1(inst) || JMPN_R1(inst)) {
				if (last_subu_addr != 0) {
					check_addr = last_subu_addr;
					break;
				} else
					return 0;
			}
		}
		if (instructions_to_search == 0)
			return 0; /* bummer, couldn't find it */
		function_addr = check_addr;
	}

	DPRINTF(("{start of function at %p}\n", function_addr));
	/*
	 * We now know the start of the function (function_addr).
	 * If we're stopped right there, or if it's not a
	 *		subu r31, r31, imm16
	 * then we're done.
	 */
	if (addr == function_addr)
		return 0;
	if (!db_trace_get_val(function_addr, &inst))
		return 0;
	if (!SUBU_R31_R31_IMM(inst))
		return 0;

 	/*
	 * Unfortunately for us, functions with variable number of
	 * arguments will further alter r31 in va_start(), through the
	 * use of __builtin_alloca(). Since panic() is one such
	 * function, we need to take this into account to be able to
	 * backtrack further.
	 *
	 * So we need to look for further addu/subu r31 sequences after the
	 * prologue.
	 *
	 * Of course, control flow may cause execution to NOT pass
	 * through the __builtin_alloca() expansion...
	 */
	DPRINTF(("{orig r31 is %p}\n", *stack));
	*stack += IMM16VAL(inst);

	if (function_addr == (vaddr_t)&panic) /* XXX others? */ {
		check_addr = function_addr + 4;
		instructions_to_search = (addr - check_addr) / 4;
		while (instructions_to_search-- != 0) {
			if (!db_trace_get_val(check_addr, &inst))
				break;
			if (SUBU_R31_R31_IMM(inst)) {
				DPRINTF(("{variadic subu r31 found at %p}\n",
				    check_addr));
				*stack += IMM16VAL(inst);
			}
			check_addr += 4;
		}
	}

	/*
	 * Search from the beginning of the function (function_addr) to where
	 * we are in the function (addr) looking to see what kind of registers
	 * have been saved on the stack.
	 *
	 * We'll stop looking before we get to addr if we hit a branch.
	 */
	clear_local_saved_regs();
	check_addr = function_addr;
	r31 = *stack;
	DPRINTF(("{entry r31 would be %p}\n", r31));
	for (instructions_to_search = (addr - check_addr) / sizeof(uint32_t);
	    instructions_to_search-- != 0; check_addr += 4) {
		uint32_t s1, d;
		uint flags;

		/* read the instruction */
		if (!db_trace_get_val(check_addr, &inst))
			break;

		if (SUBU_R31_R31_IMM(inst)) {
			r31 -= IMM16VAL(inst);
			DPRINTF(("{adjust r31 to %p at %p}\n",
			    r31, check_addr));
		}

		/* find out the particulars about this instruction */
		flags = m88k_instruction_info(inst);

		/* split the instruction in its diatic components anyway */
		s1 = (inst >> 16) & 0x1f;
		d = (inst >> 21) & 0x1f;

		/* if a store to something off the stack pointer, note the value */
		if ((flags & STORE) && s1 == 31 /*stack pointer*/) {
			u_int value;
			if (!have_local_reg(d)) {
				if (d == 1)
					tried_to_save_r1 = r31 + IMM16VAL(inst);
				DPRINTF(("{r%d saved at %p to %p}\n",
				    d, check_addr, r31 + IMM16VAL(inst)));
				if (db_trace_get_val(r31 + IMM16VAL(inst),
				    &value))
					save_reg(d, value);
			}
			if ((flags & DOUBLE) && !have_local_reg(d + 1)) {
				if (d == 0)
					tried_to_save_r1 = r31 +
					    IMM16VAL(inst) + 4;
				DPRINTF(("{r%d saved at %p to %p}\n",
				    d + 1, check_addr, r31 + IMM16VAL(inst)));
				if (db_trace_get_val(r31 + IMM16VAL(inst) + 4,
				    &value))
					save_reg(d + 1, value);
			}
		}

		/* if an inst that kills D (and maybe D+1), note that */
		if (flags & TRASHES) {
			mark_reg_trashed(d);
			if (flags & DOUBLE)
				mark_reg_trashed(d + 1);
		}

		/* if a flow control instruction, stop now (or next if delayed) */
		if ((flags & FLOW_CTRL) && instructions_to_search != 0)
			instructions_to_search = (flags & DELAYED) ? 1 : 0;
	}

	/*
	 * If we didn't save r1 at some point, we're hosed.
	 */
	if (!have_local_reg(1)) {
		if (tried_to_save_r1 != 0) {
			(*pr)("    <return value of next fcn unreadable in %08x>\n",
				  tried_to_save_r1);
		}
		return 0;
	}

	ret_addr = saved_reg_value(1);

	if (ret_addr != 0) {
		switch (is_jump_source_ok(ret_addr, function_addr)) {
		case JUMP_SOURCE_IS_OK:
			break; /* excellent */

		case JUMP_SOURCE_IS_BAD:
			return 0; /* bummer */

		case JUMP_SOURCE_IS_UNLIKELY:
			next_address_likely_wrong = 1;
			break;
		}
	}

	return ret_addr;
}

static void
db_stack_trace_cmd2(db_regs_t *regs, int (*pr)(const char *, ...))
{
	vaddr_t stack;
	u_int depth=1;
	vaddr_t where;
	u_int ft;
	u_int pair[2];
	int i;

	/*
	 * Frame_is_sane returns:
	 *   1 if regs seems to be a reasonable kernel exception frame.
	 *   2 if regs seems to be a reasonable user exception frame
	 *      (in the current task).
	 *   0 if this looks like neither.
	 */
	if ((ft = frame_is_sane(regs, 1)) == 0) {
		(*pr)("Register frame 0x%x is suspicious; skipping trace\n", regs);
		return;
	}

	/* if user space and no user space trace specified, puke */
	if (ft == 2)
		return;

	/* fetch address */
	where = PC_REGS(regs);
	stack = regs->r[31];
	(*pr)("stack base = 0x%x\n", stack);
	(*pr)("(0) "); /* depth of trace */
	db_printsym(where, DB_STGY_PROC, pr);
	clear_global_saved_regs();

	/* see if this routine had a stack frame */
	if ((where = stack_decode(where, &stack, pr)) == 0) {
		where = regs->r[1];
		(*pr)("(stackless)");
	} else
		print_args();
	(*pr)("\n");

	do {
		/*
		 * If requested, show preserved registers at the time
		 * the next-shown call was made. Only registers known to have
		 * changed from the last exception frame are shown, as others
		 * can be gotten at by looking at the exception frame.
		 */
		(*pr)("(%d)%c", depth++, next_address_likely_wrong ? '?' : ' ');
		next_address_likely_wrong = 0;

		db_printsym(where, DB_STGY_PROC, pr);
		where = stack_decode(where, &stack, pr);
		print_args();
		(*pr)("\n");
	} while (where);

	/* try to trace back over trap/exception */

	stack &= ~7; /* double word aligned */
	/* take last top of stack, and try to find an exception frame near it */

	i = FRAME_PLAY;
	while (i) {
		/*
		 * On the stack, a pointer to the exception frame is written
		 * in two adjacent words. In the case of a fault from the kernel,
		 * this should point to the frame right above them:
		 *
		 * Exception Frame Top
		 * ..
		 * Exception Frame Bottom  <-- frame addr
		 * frame addr
		 * frame addr		<-- stack pointer
		 *
		 * In the case of a fault from user mode, the top of stack
		 * will just have the address of the frame
		 * replicated twice.
		 *
		 * frame addr		<-- top of stack
		 * frame addr
		 *
		 * Here we are just looking for kernel exception frames.
		 */

		if (badaddr((vaddr_t)stack, 4) ||
		    badaddr((vaddr_t)(stack + 4), 4))
			break;

		db_read_bytes((vaddr_t)stack, 2 * sizeof(int), (char *)pair);

		/* the pairs should match and equal stack+8 */
		if (pair[0] == pair[1]) {
			if (pair[0] != stack+8) {
#if 0
				if (!badaddr((vaddr_t)pair[0], 4) &&
				    pair[0] != 0)
					(*pr)("stack_trace:found pair 0x%x but != to stack+8\n",
					    pair[0]);
#endif
			} else if (frame_is_sane((db_regs_t*)pair[0], 1) != 0) {
				struct trapframe *frame =
				    (struct trapframe *)pair[0];

				(*pr)("-------------- %s [EF: 0x%x] -------------\n",
				    m88k_exception_name(frame->tf_vector),
				    frame);
				db_stack_trace_cmd2(&frame->tf_regs, pr);
				return;
			}
		}
		stack += 8;
		i--;
	}
}

/*
 * stack trace - needs a pointer to a m88k saved state.
 *
 * If argument f is given, the stack pointer of each call frame is
 * printed.
 */
void
db_stack_trace_print(db_expr_t addr, int have_addr, db_expr_t count,
    char *modif, int (*pr)(const char *, ...))
{
	enum {
		Default, Stack, Frame
	} style = Default;
	db_regs_t frame;
	db_regs_t *regs;
	union {
		db_regs_t *frame;
		db_expr_t num;
	} arg;

	arg.num = addr;

	while (modif && *modif) {
		switch (*modif++) {
		case 's': style = Stack  ; break;
		case 'f': style = Frame  ; break;
		default:
			(*pr)("unknown trace modifier [%c]\n", modif[-1]);
			/*FALLTHROUGH*/
		case 'h':
			(*pr)("usage: trace/[MODIFIER]  [ARG]\n");
			(*pr)("  s = ARG is a stack pointer\n");
			(*pr)("  f = ARG is a frame pointer\n");
			return;
		}
	}

	if (!have_addr && style != Default) {
		(*pr)("expecting argument with /s or /f\n");
		return;
	}
	if (have_addr && style == Default)
		style = Frame;

	switch (style) {
	case Default:
		regs = &ddb_regs;
		break;
	case Frame:
		regs = arg.frame;
		break;
	case Stack:
	    {
		u_int val1, val2, sxip;
		u_int ptr;
		bzero((void *)&frame, sizeof(frame));
#define REASONABLE_FRAME_DISTANCE 2048

		/*
		 * We've got to find the top of a stack frame so we can get both
		 * a PC and and real SP.
		 */
		for (ptr = arg.num;/**/; ptr += 4) {
			/* Read a word from the named stack */
			if (db_trace_get_val(ptr, &val1) == 0) {
				(*pr)("can't read from %x, aborting.\n", ptr);
				return;
			}

			/*
			 * See if it's a frame pointer.... if so it will be larger than
			 * the address it was taken from (i.e. point back up the stack)
			 * and we'll be able to read where it points.
			 */
			if (val1 <= ptr ||
			    (val1 & 3)  ||
			    val1 > (ptr + REASONABLE_FRAME_DISTANCE))
				continue;

			/* peek at the next word to see if it could be a return address */
			if (db_trace_get_val(ptr, &sxip) == 0) {
				(*pr)("can't read from %x, aborting.\n", ptr);
				return;
			}
			if (sxip == 0 || !db_trace_get_val(sxip, &val2))
				continue;

			if (db_trace_get_val(val1, &val2) == 0) {
				(*pr)("can't read from %x, aborting.\n", val1);
				continue;
			}

			/*
			 * The value we've just read will be either
			 * another frame pointer, or the start of
			 * another exception frame.
			 */
			if (val2 == 0x12345678 &&
			    db_trace_get_val(val1 - 4, &val2) &&
			    val2 == val1 &&
			    db_trace_get_val(val1 - 8, &val2) &&
			    val2 == val1) {
				/* we've found a frame, so the stack
				   must have been good */
				(*pr)("%x looks like a frame, accepting %x\n",val1,ptr);
				break;
			}

			if (val2 > val1 && (val2 & 3) == 0) {
				/* well, looks close enough to be another frame pointer */
				(*pr)("*%x = %x looks like a stack frame pointer, accepting %x\n", val1, val2, ptr);
				break;
			}
		}
		frame.r[31] = ptr;
		frame.epsr = 0x800003f0U;
#ifdef M88100
		if (CPU_IS88100) {
			frame.sxip = sxip | XIP_V;
			frame.snip = frame.sxip + 4;
			frame.sfip = frame.snip + 4;
		}
#endif
		(*pr)("[r31=%x, %sxip=%x]\n", frame.r[31],
		    CPU_IS88110 ? "e" : "s", frame.sxip);
		regs = &frame;
	    }
		break;
	}
	db_stack_trace_cmd2(regs, pr);
}
@


1.16
log
@ansify function definitions

ok guenther@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.15 2016/03/09 08:58:50 mpi Exp $	*/
d461 1
a461 1
	db_sym_t proc;
d473 1
a473 1
	/* get what we hope will be the db_sym_t for the function name */
@


1.15
log
@Convert DDB_REGS -> &ddb_regs, inputs and ok naddy@@

Put addresses instead of registers inside db_regs[] to match what other
archs do and to get rid of db_setf_regs().
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.14 2016/03/01 11:56:00 mpi Exp $	*/
d809 2
a810 5
db_stack_trace_print(db_expr_t addr,
		   int have_addr,
		   db_expr_t count,
		   char *modif,
		   int (*pr)(const char *, ...))
@


1.14
log
@DB_SYM_NULL -> NULL.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.13 2014/07/13 12:11:01 jasper Exp $	*/
d83 1
a83 17
/* lifted from mips */
static int
db_setf_regs(struct db_variable      *vp,
	db_expr_t		*valuep,
	int			op)		/* read/write */
{
	int   *regp = (int *) ((char *) DDB_REGS + (int) (vp->valuep));

	if (op == DB_VAR_GET)
		*valuep = *regp;
	else if (op == DB_VAR_SET)
		*regp = *valuep;

	return (0); /* silence warning */
}

#define N(s, x)  {s, (long *)&(((db_regs_t *) 0)->x), db_setf_regs}
d851 1
a851 1
		regs = DDB_REGS;
@


1.13
log
@use nitems() instead of handrolling something identical

ok mpi@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.12 2011/01/03 05:58:19 miod Exp $	*/
d492 1
a492 1
		proc = DB_SYM_NULL;
d499 1
a499 1
	if (proc != DB_SYM_NULL) {
@


1.12
log
@Rework backtrace code, and try to cope with variadic functions better
(those play nasty games with the stack pointer).
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.11 2009/12/16 16:54:43 jasper Exp $	*/
d119 1
a119 1
struct db_variable *db_eregs = db_regs + sizeof(db_regs)/sizeof(db_regs[0]);
@


1.11
log
@zap two more handrolled equivalents of nitems().

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.10 2007/11/17 05:36:23 miod Exp $	*/
d42 6
d65 2
a66 2
#define JMPN_R1(I)	    ( (I) == 0xf400c401)	/* jmp.n   r1 */
#define JMP_R1(I)	    ( (I) == 0xf400c001)	/* jmp     r1 */
d69 1
a69 1
#define IMM16VAL(I)	    ((I) & 0x0000ffff)
d72 1
a72 1
#define SUBU_R31_R31_IMM(I) (((I) & 0xffff0000) == 0x67ff0000U)
d74 2
a75 2
/* st r1, r31, IMM */
#define ST_R1_R31_IMM(I)    (((I) & 0xffff0000) == 0x243f0000U)
d409 1
a409 1
	u_int instruction;
a450 1
static const char *note;
d474 1
a474 1
static int
d479 1
a479 1
	u_int instructions_to_search;
d482 2
a483 2
	u_int32_t r31 = *stack;	    /* the r31 of the function */
	u_int32_t inst;		    /* text of an instruction */
d486 2
d495 3
a497 3
	 * Somehow, find the start of this function.
	 * If we found a symbol above, it'll have the address.
	 * Otherwise, we've got to search for it....
d500 1
a500 1
		char *names;
d502 1
a502 1
		if (names == 0)
a504 1
		int instructions_to_check = 400;
d506 10
a515 2
		 * hmm - unable to find symbol. Search back
		 * looking for a function prolog.
d517 3
a519 1
		for (check_addr = addr; instructions_to_check-- > 0; check_addr -= 4) {
d523 11
a533 20
			if (SUBU_R31_R31_IMM(inst)) {
#if 0
				/*
				 * If the next instruction is "st r1, r31, ####"
				 * then we can feel safe we have the start of
				 * a function.
				 */
				if (!db_trace_get_val(check_addr + 4, &inst))
					continue;
				if (ST_R1_R31_IMM(instr))
					break; /* success */
#else
				/*
				 * Latest GCC optimizer is just too good... the store
				 * of r1 might come much later... so we'll have to
				 * settle for just the "subr r31, r31, ###" to mark
				 * the start....
				 */
				break;
#endif
d535 1
d537 6
a542 5
			 * if we come across a [jmp r1] or [jmp.n r1] assume we have hit
			 * the previous functions epilogue and stop our search.
			 * Since we know we would have hit the "subr r31, r31" if it was
			 * right in front of us, we know this doesn't have one so
			 * we just return failure....
d544 7
a550 2
			if (JMP_R1(inst) || JMPN_R1(inst))
				return 0;
d552 1
a552 1
		if (instructions_to_check < 0)
d557 1
d561 1
a561 1
	 *		subu r31, r31, ####
d571 14
a584 1
	/* add the size of this frame to the stack (for the next frame) */
d587 15
d603 3
a605 3
	 * Search from the beginning of the function (funstart) to where we are
	 * in the function (addr) looking to see what kind of registers have
	 * been saved on the stack.
d607 1
a607 1
	 * We'll stop looking before we get to ADDR if we hit a branch.
d610 7
a616 7
	check_addr = function_addr + 4;	/* we know the first inst isn't a store */

	for (instructions_to_search = (addr - check_addr)/sizeof(long);
	    instructions_to_search-- > 0;
	    check_addr += 4) {
		u_int32_t instruction, s1, d;
		u_int flags;
d619 1
a619 1
		if (!db_trace_get_val(check_addr, &instruction))
d622 6
d629 1
a629 1
		flags = m88k_instruction_info(instruction);
d632 2
a633 2
		s1 = (instruction >> 16) & 0x1f;
		d = (instruction >> 21) & 0x1f;
d640 5
a644 4
					tried_to_save_r1 = r31 +
					    IMM16VAL(instruction);
				if (db_trace_get_val(r31 +
				    IMM16VAL(instruction), &value))
d650 5
a654 3
					    IMM16VAL(instruction) + 4;
				if (db_trace_get_val(r31 +
				    IMM16VAL(instruction) + 4, &value))
d675 1
a675 1
		if (tried_to_save_r1) {
d706 1
a706 1
	u_int where;
a741 4
	if (note) {
		(*pr)("   %s\n", note);
		note = NULL;
	}
a756 4
		if (note) {
			(*pr)("   %s\n", note);
			note = NULL;
		}
@


1.10
log
@Replace many ``unsigned'' variables with ``unsigned int'', ``u_int'' or other
appropriate types. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.9 2006/05/08 14:36:09 miod Exp $	*/
d168 2
a169 2
#define ctrl_count (sizeof(control)/sizeof(control[0]))
	for (ptr = &control[0]; ptr < &control[ctrl_count]; ptr++)
@


1.9
log
@Replace gazillions of badvaddr() or badwordaddr() calls with badaddr() calls.
With a few prototype declarations shuffling, this finally allows
<machine/locore.h> to die.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.8 2006/05/07 15:47:12 miod Exp $	*/
d43 1
a43 1
unsigned br_dest(unsigned addr, u_int inst)
d53 2
a54 2
const char *m88k_exception_name(unsigned vector);
unsigned db_trace_get_val(vaddr_t addr, unsigned *ptr);
d128 2
a129 2
static unsigned
m88k_instruction_info(unsigned instruction)
d132 2
a133 1
		unsigned mask, value, flags;
d176 1
a176 1
hex_value_needs_0x(unsigned value)
d257 1
a257 1
m88k_exception_name(unsigned vector)
d289 2
a290 2
unsigned
db_trace_get_val(vaddr_t addr, unsigned *ptr)
d311 4
a314 4
static unsigned global_saved_list = 0x0; /* one bit per register */
static unsigned local_saved_list  = 0x0; /* one bit per register */
static unsigned trashed_list      = 0x0; /* one bit per register */
static unsigned saved_reg[32];		 /* one value per register */
d319 1
a319 1
save_reg(int reg, unsigned value)
d362 1
a362 1
			unsigned value = saved_reg_value(reg);
d400 1
a400 1
is_jump_source_ok(unsigned return_to, unsigned jump_to)
d402 1
a402 1
	unsigned flags;
d453 2
a454 2
 *	unsigned addr;    program counter
 *	unsigned *stack; IN/OUT stack pointer
d470 1
a470 1
stack_decode(db_addr_t addr, unsigned *stack, int (*pr)(const char *, ...))
d474 1
a474 1
	unsigned instructions_to_search;
d477 4
a480 4
	unsigned r31 = *stack;	    /* the r31 of the function */
	unsigned inst;		    /* text of an instruction */
	unsigned ret_addr;	    /* address to which we return */
	unsigned tried_to_save_r1 = 0;
d572 2
a573 2
		u_int instruction, s1, d;
		unsigned flags;
d588 1
a588 1
			unsigned value;
d652 5
a656 5
	unsigned stack;
	unsigned depth=1;
	unsigned where;
	unsigned ft;
	unsigned pair[2];
d830 2
a831 2
		unsigned val1, val2, sxip;
		unsigned ptr;
@


1.8
log
@Nuke TRACE_DEBUG code. Half of it was useless, and the other half was either
not smart enough to cope with gcc -O2 or with the no longer fixed address
for the kernels stack.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.7 2005/11/20 22:07:09 miod Exp $	*/
d32 1
a33 1
#include <machine/locore.h>
d207 1
a207 1
	if (badwordaddr((vaddr_t)regs) || badwordaddr((vaddr_t)&regs->fpit)) {
d742 2
a743 2
		if (badwordaddr((vaddr_t)stack) ||
		    badwordaddr((vaddr_t)(stack + 4)))
d752 1
a752 1
				if (!badwordaddr((vaddr_t)pair[0]) &&
@


1.7
log
@Complete overhaul of the single-stepping ddb code, close in spirit to the
ptrace single-stepping changes of a few months ago; simpler and smaller
than the (previously used) MI fallback implementation on 88100.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.6 2005/05/15 14:33:04 miod Exp $	*/
a51 2
/* #define TRACE_DEBUG */

a70 20
#ifdef TRACE_DEBUG
static int trace_flags;
#define TRACE_DEBUG_FLAG		0x01
#define TRACE_SHOWCALLPRESERVED_FLAG	0x02
#define TRACE_SHOWADDRESS_FLAG		0x04
#define TRACE_SHOWFRAME_FLAG		0x08
#define TRACE_USER_FLAG			0x10
#define DEBUGGING_ON (trace_flags & TRACE_DEBUG_FLAG)
#define SHOW_INSTRUCTION(Addr, Inst, Note) \
do { \
	if (DEBUGGING_ON) { \
		db_printf("%s0x%x: (0x%08x) ", Note, (unsigned)(Addr), Inst); \
		m88k_print_instruction((unsigned)(Addr), Inst); \
		db_printf("\n"); \
	} \
} while (0)
#else
#define SHOW_INSTRUCTION(Addr, Inst, Note)	do { /* nothing */ } while (0)
#endif

a170 1
	SHOW_INSTRUCTION(0, instruction, "bad m88k_instruction_info");
d321 1
a321 9
#ifdef TRACE_DEBUG
	if (DEBUGGING_ON)
		db_printf("save_reg(%d, %x)\n", reg, value);
#endif
	if (trashed_list & reg_bit(reg)) {
#ifdef TRACE_DEBUG
		if (DEBUGGING_ON)
			db_printf("<trashed>\n");
#endif
d323 1
a323 1
	}
a480 5
#ifdef TRACE_DEBUG
	if (DEBUGGING_ON)
		(*pr)("\n>>>stack_decode(addr=%x, stack=%x)\n", addr, *stack);
#endif

a495 4
#ifdef TRACE_DEBUG
		if (DEBUGGING_ON)
			(*pr)("name %s address 0x%x\n", names, function_addr);
#endif
d534 1
a534 6
			if (JMP_R1(inst) || JMPN_R1(inst)) {
#ifdef TRACE_DEBUG
				if (DEBUGGING_ON)
					(*pr)("ran into a [jmp r1] at %x (addr=%x)\n",
					    check_addr, addr);
#endif
a535 1
			}
d537 1
a537 6
		if (instructions_to_check < 0) {
#ifdef TRACE_DEBUG
			if (DEBUGGING_ON)
				(*pr)("couldn't find func start (addr=%x)\n",
				    addr);
#endif
a538 1
		}
d548 1
a548 5
	if (addr == function_addr) {
#ifdef TRACE_DEBUG
		if (DEBUGGING_ON)
			(*pr)("at start of func\n");
#endif
d550 1
a550 7
	}
	if (!db_trace_get_val(function_addr, &inst)) {
#ifdef TRACE_DEBUG
		if (DEBUGGING_ON)
			(*pr)("couldn't read %x at line %d\n",
			    function_addr, __LINE__);
#endif
d552 1
a552 7
	}
	SHOW_INSTRUCTION(function_addr, inst, "start of function: ");
	if (!SUBU_R31_R31_IMM(inst)) {
#ifdef TRACE_DEBUG
		if (DEBUGGING_ON)
			(*pr)("<not subu,r31,r31,imm>\n");
#endif
a553 1
	}
d575 1
a575 6
		if (!db_trace_get_val(check_addr, &instruction)) {
#ifdef TRACE_DEBUG
			if (DEBUGGING_ON)
				(*pr)("couldn't read %x at line %d\n",
				    check_addr, __LINE__);
#endif
a576 3
		}

		SHOW_INSTRUCTION(check_addr, instruction, "prolog: ");
a625 4
#ifdef TRACE_DEBUG
		if (DEBUGGING_ON)
			(*pr)("didn't save r1\n");
#endif
a630 6
#ifdef TRACE_DEBUG
	if (DEBUGGING_ON)
		(*pr)("Return value is = %x, function_addr is %x.\n",
		    ret_addr, function_addr);
#endif

a636 4
#ifdef TRACE_DEBUG
			if (DEBUGGING_ON)
				(*pr)("jump is bad\n");
#endif
a672 4
#ifdef TRACE_DEBUG
	if (!(trace_flags & TRACE_USER_FLAG))
		return;
#endif
a678 4
#ifdef TRACE_DEBUG
	if (trace_flags & TRACE_SHOWADDRESS_FLAG)
		(*pr)("%08x ", where);
#endif
d686 1
a686 1
	} else {
a687 5
#ifdef TRACE_DEBUG
		if (trace_flags & TRACE_SHOWFRAME_FLAG)
			(*pr)(" [frame 0x%x]", stack);
#endif
	}
a700 24
#ifdef TRACE_DEBUG
		if (trace_flags & TRACE_SHOWCALLPRESERVED_FLAG) {
			int r, title_printed = 0;

			for (r = FIRST_CALLPRESERVED_REG; r<=LAST_CALLPRESERVED_REG; r++) {
				if (have_global_reg(r)) {
					unsigned value = saved_reg_value(r);
					if (title_printed == 0) {
						title_printed = 1;
						(*pr)("[in next func:");
					}
					if (value == 0)
						(*pr)(" r%d", r);
					else if (value <= 9)
						(*pr)(" r%d=%x", r, value);
					else
						(*pr)(" r%d=x%x", r, value);
				}
			}
			if (title_printed)
				(*pr)("]\n");
		}
#endif

a703 4
#ifdef TRACE_DEBUG
		if (trace_flags & TRACE_SHOWADDRESS_FLAG)
			(*pr)("%08x ", where);
#endif
a706 4
#ifdef TRACE_DEBUG
		if (trace_flags & TRACE_SHOWFRAME_FLAG)
			(*pr)(" [frame 0x%x]", stack);
#endif
a719 6

#ifdef TRACE_DEBUG
	if (DEBUGGING_ON)
		(*pr)("(searching for exception frame at 0x%x)\n", stack);
#endif

a766 5
#ifdef TRACE_DEBUG
			else if (DEBUGGING_ON)
				(*pr)("pair matched, but frame at 0x%x looks insane\n",
				    stack + 8);
#endif
a770 34

	/*
	 * If we go here, crawling back on the stack failed to find us
	 * a previous exception frame. Look for a user frame pointer
	 * pointed to by a word 8 bytes off of the top of the stack
	 * if the "u" option was specified.
	 */
#ifdef TRACE_DEBUG
	if (trace_flags & TRACE_USER_FLAG) {
		struct trapframe *user;

		/* Make sure we are back on the right page */
		stack -= 4 * FRAME_PLAY;
		stack = stack & ~(KERNEL_STACK_SIZE-1);	/* point to the bottom */
		stack += KERNEL_STACK_SIZE - 8;

		if (badwordaddr((vaddr_t)stack) ||
		    badwordaddr((vaddr_t)stack + sizeof(int)))
			return;

		db_read_bytes((vaddr_t)stack, 2*sizeof(int), (char *)pair);
		if (pair[0] != pair[1])
			return;

		/* have a hit */
		user = *((struct trapframe **)stack);

		if (frame_is_sane(&user->tf_regs, 1) == 2) {
			(*pr)("---------------- %s [EF : 0x%x] -------------\n",
			    m88k_exception_name(user->tf_vector), user);
			db_stack_trace_cmd2(&user->tf_regs, pr);
		}
	}
#endif
a797 4
#ifdef TRACE_DEBUG
	trace_flags = 0; /* flags will be set via modifers */
#endif

a799 6
#ifdef TRACE_DEBUG
		case 'd':
			trace_flags |= TRACE_DEBUG_FLAG;
			break;
#endif

a801 6
#ifdef TRACE_DEBUG
		case 'p': trace_flags |= TRACE_SHOWCALLPRESERVED_FLAG; break;
		case 'a': trace_flags |= TRACE_SHOWADDRESS_FLAG; break;
		case 'F': trace_flags |= TRACE_SHOWFRAME_FLAG; break;
		case 'u': trace_flags |= TRACE_USER_FLAG; break;
#endif
a806 6
#ifdef TRACE_DEBUG
			(*pr)("  u = include user trace\n");
			(*pr)("  F = print stack frames\n");
			(*pr)("  a = show return addresses\n");
			(*pr)("  p = show call-preserved registers\n");
#endif
a808 3
#ifdef TRACE_DEBUG
			(*pr)("  d = trace-debugging output\n");
#endif
@


1.6
log
@Compile out more code if TRACE_DEBUG is not defined.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.4 2005/04/30 16:44:08 miod Exp $	*/
a41 49
union instruction {
	unsigned rawbits;

	struct {
		unsigned int    : 5;
		unsigned int   n: 1;
		signed int   d26:26;
	} br;

	struct {
		unsigned int      : 4;
		unsigned int isbb1: 1;	/* isbb1==0 means bb0, isbb1==1 means bb1 */
		unsigned int   n  : 1;
		unsigned int  b5  : 5;
		unsigned int  s1  : 5;
		signed   int  d16 :16;
	} bb; /* bcnd too, except "isbb1" makes no sense for bcnd */

	struct {
		unsigned int      : 6;
		unsigned int  b5  : 5;
		unsigned int  s1  : 5;
		unsigned int      : 7;
		unsigned int vec9 : 9;
	} tb; /* tcnd too */

	struct {
		unsigned int      :21;
		unsigned int    n : 1;
		unsigned int      : 5;
		unsigned int   s2 : 5;
	} jump;	/* jmp, jsr */

	struct {
		unsigned int      : 6;
		unsigned int    d : 5;
		unsigned int   s1 : 5;
		unsigned int  i16 :16;
	} diatic;   /* general reg/reg/i16 instructions */

	struct {
		unsigned int      : 6;
		unsigned int    d : 5;
		unsigned int   s1 : 5;
		unsigned int      :11;
		unsigned int   s2 : 5;
	} triatic;  /* general reg/reg/reg instructions */
};

d43 1
a43 1
unsigned br_dest(unsigned addr, union instruction inst)
d45 5
a49 1
	return (addr + inst.br.d26 * 4);
d55 1
a55 1
char *m88k_exception_name(unsigned vector);
d65 1
a65 1
#define IMM16VAL(I)	    (((union instruction)(I)).diatic.i16)
d200 2
a201 4
	int i;
	unsigned last = 0;
	unsigned char c;
	unsigned have_a_hex_digit = 0;
d204 1
a204 1
		return 0;
d206 1
a206 1
	for (i = 0; i < 8; i++) {
a208 2
		if (c)
			last = c;
d212 5
a216 5
	if (have_a_hex_digit == 0)
		return 1;
	if (last > 9)
		return 1;
	return 0;
d254 2
a255 2
		if ((regs->sxip & 1) == 1)
			return 0;
d258 2
a259 2
		if ((regs->snip & 3) != 2)
			return 0;
d261 2
a262 2
		if ((regs->sfip & 3) != 2)
			return 0;
d267 6
a272 10
	if ((regs->epsr & PSR_MODE)) { /* kernel mode */
		if (regs->epsr & PSR_BO)
			return 0;
		return 1;
	}
	if (!(regs->epsr & PSR_MODE)) {	/* user mode */
		if (regs->epsr & PSR_BO)
			return 0;
		return 2;
	}
d275 1
a275 1
	return 0;
d278 1
a278 1
char *
d327 5
a331 5
#define FIRST_CALLPRESERVED_REG 14
#define LAST_CALLPRESERVED_REG  29
#define FIRST_ARG_REG       2
#define LAST_ARG_REG        9
#define RETURN_VAL_REG           1
d338 1
a338 1
#define reg_bit(reg) (1<<((reg)%32))
d343 1
d355 1
a355 1
	saved_reg[(reg%32)] = value;
d357 1
a357 1
	local_saved_list  |= reg_bit(reg);
d360 1
a360 1
#define mark_reg_trashed(reg)	(trashed_list |= reg_bit(reg))
d362 2
a363 2
#define have_global_reg(reg) (global_saved_list & (1<<(reg)))
#define have_local_reg(reg)  (local_saved_list & (1<<(reg)))
d365 2
a366 2
#define clear_local_saved_regs()  { local_saved_list = trashed_list =      0; }
#define clear_global_saved_regs() { local_saved_list = global_saved_list = 0; }
d368 1
a368 1
#define saved_reg_value(reg) (saved_reg[(reg)])
a403 1

d418 3
a420 3
 *	bcnd   !condition  mark
 *	bsr.n  func1
 *	or     r1, r0, mark2
d425 2
a426 2
 * So RETURN_TO will be MARK2, even though we really did branch via
 * 'bsr.n func1', so this makes it difficult to be certaian about being
d433 1
a433 1
	union instruction instruction;
d436 1
a436 1
	 * Delayed branches are most common... look two instructions before
d439 1
a439 1
	if (!db_trace_get_val(return_to - 8, &instruction.rawbits))
a440 1
	flags = m88k_instruction_info(instruction.rawbits);
d442 4
a445 2
	if ((flags & FLOW_CTRL) && (flags & DELAYED) && (flags & (JSR|BSR))) {
		if (flags & JSR)
d455 1
a455 1
	 * Try again, looking for a non-delayed jump one back.
d457 1
a457 1
	if (!db_trace_get_val(return_to - 4, &instruction.rawbits))
a458 1
	flags = m88k_instruction_info(instruction.rawbits);
d460 4
a463 2
	if ((flags & FLOW_CTRL) && !(flags & DELAYED) && (flags & (JSR|BSR))) {
		if (flags & JSR)
d475 1
a475 1
static char *note = 0;
d490 1
a490 1
 *	The return value is zero (if we get confused) or
a497 1
 *
d640 1
a640 1
		union instruction instruction;
d644 1
a644 1
		if (!db_trace_get_val(check_addr, &instruction.rawbits)) {
d653 1
a653 1
		SHOW_INSTRUCTION(check_addr, instruction.rawbits, "prolog: ");
d656 5
a660 1
		flags = m88k_instruction_info(instruction.rawbits);
d663 1
a663 1
		if ((flags & STORE) && instruction.diatic.s1 ==	/*stack pointer*/31) {
d665 7
a671 5
			if (!have_local_reg(instruction.diatic.d)) {
				if (instruction.diatic.d == 1)
					tried_to_save_r1 = r31 + instruction.diatic.i16 ;
				if (db_trace_get_val(r31 + instruction.diatic.i16, &value))
					save_reg(instruction.diatic.d, value);
d673 7
a679 5
			if ((flags & DOUBLE) && !have_local_reg(instruction.diatic.d + 1)) {
				if (instruction.diatic.d == 0)
					tried_to_save_r1 = r31+instruction.diatic.i16 +4;
				if (db_trace_get_val(r31+instruction.diatic.i16 +4, &value))
					save_reg(instruction.diatic.d + 1, value);
d685 1
a685 1
			mark_reg_trashed(instruction.diatic.d);
d687 1
a687 1
				mark_reg_trashed(instruction.diatic.d + 1);
d718 1
a718 9
	/*
	 * In support of this, continuation.s puts the low bit on the
	 * return address for continuations (the return address will never
	 * be used, so it's ok to do anything you want to it).
	 */
	if (ret_addr & 1) {
		note = "<<can not trace past a continuation>>";
		ret_addr = 0;
	} else if (ret_addr != 0x00) {
d770 1
a770 12
	/* use sxip if valid, otherwise try snip or sfip */
#ifdef M88110
	if (CPU_IS88110) {
		where = regs->exip & XIP_ADDR;
	}
#endif
#ifdef M88100
	if (CPU_IS88100) {
		where = ((regs->sxip & 2) ? regs->sxip :
			 ((regs->snip & 2) ? regs->snip : regs->sfip)) & XIP_ADDR;
	}
#endif
d773 1
a773 1
	(*pr)("(0) "); /*depth of trace */
d782 1
a782 1
	if ((where=stack_decode(where, &stack, pr))==0) {
d795 1
a795 1
		note = 0;
d829 1
a829 1
		(*pr)("(%d)%c", depth++, next_address_likely_wrong ? '?':' ');
d846 1
a846 1
			note = 0;
d885 1
a885 1
		    badwordaddr((vaddr_t)(stack+4)))
d888 1
a888 1
		db_read_bytes((vaddr_t)stack, 2*sizeof(int), (char *)pair);
d893 7
a899 8
				/*
				if (!badwordaddr((vaddr_t)pair[0]) && (pair[0]!=0))
				(*pr)("stack_trace:found pair 0x%x but != to stack+8\n",
				pair[0]);
				*/
			}

			else if (frame_is_sane((db_regs_t*)pair[0], 1) != 0) {
d1034 4
a1037 4
		{
			unsigned val1, val2, sxip;
			unsigned ptr;
			bzero((void *)&frame, sizeof(frame));
d1040 11
d1052 3
a1054 2
			 * We've got to find the top of a stack frame so we can get both
			 * a PC and and real SP.
d1056 12
a1067 6
			for (ptr = arg.num;/**/; ptr += 4) {
				/* Read a word from the named stack */
				if (db_trace_get_val(ptr, &val1) == 0) {
					(*pr)("can't read from %x, aborting.\n", ptr);
					return;
				}
d1069 4
a1072 9
				/*
				 * See if it's a frame pointer.... if so it will be larger than
				 * the address it was taken from (i.e. point back up the stack)
				 * and we'll be able to read where it points.
				 */
				if (val1 <= ptr ||
				    (val1 & 3)  ||
				    val1 > (ptr + REASONABLE_FRAME_DISTANCE))
					continue;
d1074 15
a1088 7
				/* peek at the next word to see if it could be a return address */
				if (db_trace_get_val(ptr, &sxip) == 0) {
					(*pr)("can't read from %x, aborting.\n", ptr);
					return;
				}
				if (sxip == 0 || !db_trace_get_val(sxip, &val2))
					continue;
d1090 4
a1093 26
				if (db_trace_get_val(val1, &val2) == 0) {
					(*pr)("can't read from %x, aborting.\n", val1);
					continue;
				}

				/*
				 * The value we've just read will be either
				 * another frame pointer, or the start of
				 * another exception frame.
				 */
				if (val2 == 0x12345678 &&
				    db_trace_get_val(val1 - 4, &val2) &&
				    val2 == val1 &&
				    db_trace_get_val(val1 - 8, &val2) &&
				    val2 == val1) {
					/* we've found a frame, so the stack
					   must have been good */
					(*pr)("%x looks like a frame, accepting %x\n",val1,ptr);
					break;
				}

				if (val2 > val1 && (val2 & 3) == 0) {
					/* well, looks close enough to be another frame pointer */
					(*pr)("*%x = %x looks like a stack frame pointer, accepting %x\n", val1, val2, ptr);
					break;
				}
d1095 3
a1097 2
                        frame.r[31] = ptr;
			frame.epsr = 0x800003f0U;
d1099 5
a1103 5
			if (CPU_IS88100) {
				frame.sxip = sxip | 2;
				frame.snip = frame.sxip + 4;
				frame.sfip = frame.snip + 4;
			}
d1105 5
a1109 4
			(*pr)("[r31=%x, %sxip=%x]\n", frame.r[31],
			    CPU_IS88110 ? "e" : "s", frame.sxip);
			regs = &frame;
		}
@


1.5
log
@Disable ddb backtrace debug code by default.
@
text
@a88 1

d91 2
a92 1
static inline unsigned br_dest(unsigned addr, union instruction inst)
d94 1
a94 1
	return addr + inst.br.d26 * 4;
a96 1

d106 2
a107 2
#define JMPN_R1(I)	    ( (I) == 0xf400c401U)	/* jmp.n   r1 */
#define JMP_R1(I)	    ( (I) == 0xf400c001U)	/* jmp     r1 */
d113 1
a113 1
#define SUBU_R31_R31_IMM(I) (((I) & 0xffff0000U) == 0x67ff0000U)
d116 1
a116 1
#define ST_R1_R31_IMM(I)    (((I) & 0xffff0000U) == 0x243f0000U)
d118 1
d125 9
a133 7

#ifdef TRACE_DEBUG
  #define DEBUGGING_ON (trace_flags & TRACE_DEBUG_FLAG)
#endif

#ifndef TRACE_DEBUG
  #define SHOW_INSTRUCTION(Addr, Inst, Note) 	{ /*nothing*/ }
d135 1
a135 5
  #define SHOW_INSTRUCTION(Addr, Inst, Note) if (DEBUGGING_ON) { 	\
    db_printf("%s0x%x: (0x%08x) ", Note, (unsigned)(Addr), (Inst));	\
    m88k_print_instruction((unsigned)(Addr), (Inst));			\
    db_printf("\n");					\
  }
a181 1

d397 2
a398 1
	if (DEBUGGING_ON) db_printf("save_reg(%d, %x)\n", reg, value);
d402 2
a403 1
		if (DEBUGGING_ON) db_printf("<trashed>\n");
d566 1
a566 2
		(*pr)("\n>>>stack_decode(addr=%x, stack=%x)\n",
			  addr, *stack);
d585 2
a586 2
		if (DEBUGGING_ON) (*pr)("name %s address 0x%x\n",
					    names, function_addr);
d630 1
a630 1
						  check_addr, addr);
d638 2
a639 1
				(*pr)("couldn't find func start (addr=%x)\n", addr);
d654 2
a655 1
		if (DEBUGGING_ON) (*pr)("at start of func\n");
d661 3
a663 2
		if (DEBUGGING_ON) (*pr)("couldn't read %x at line %d\n",
					    function_addr, __LINE__);
d670 2
a671 1
		if (DEBUGGING_ON) (*pr)("<not subu,r31,r31,imm>\n");
d698 3
a700 2
			if (DEBUGGING_ON) (*pr)("couldn't read %x at line %d\n",
						    check_addr, __LINE__);
d748 2
a749 1
		if (DEBUGGING_ON) (*pr)("didn't save r1\n");
d759 1
a759 1
			  ret_addr, function_addr);
d777 2
a778 1
			if (DEBUGGING_ON) (*pr)("jump is bad\n");
d814 1
a814 1
	if (ft == 2 && !(trace_flags & TRACE_USER_FLAG))
d816 4
d837 1
d840 1
d850 1
d853 1
d868 1
d890 1
d895 1
d898 1
d902 1
d905 1
d976 1
a976 1
					  stack+8);
d989 1
d994 1
a994 1
		stack -= 4*FRAME_PLAY;
d999 1
a999 1
		    badwordaddr((vaddr_t)stack))
d1015 1
d1043 1
d1045 1
d1049 1
a1050 1
#ifdef TRACE_DEBUG
d1052 1
a1053 1
			break;
d1057 1
d1062 1
d1068 1
d1073 1
@


1.4
log
@Use [XNF]IP_ADDR constants rather than their numeric values.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.3 2004/09/30 21:48:56 miod Exp $	*/
d98 1
a98 1
#define TRACE_DEBUG	/* undefine to disable debugging */
a1028 2
#else
			db_printtf("<debug trace not compiled in, ignoring>\n");
@


1.3
log
@Introduce sparc-like CPU_ISFOO macros, to short-circuit evaluations when
compiling for one flavour only.

This makes code slightly smaller on all m88k-based platforms (my roughly
1KB), and saves more than meets the eye on luna88k, which is m88100-based.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.2 2004/07/28 12:33:55 miod Exp $	*/
d816 1
a816 1
		where = regs->exip & ~3;
d822 1
a822 1
			 ((regs->snip & 2) ? regs->snip : regs->sfip)) & ~3;
@


1.2
log
@Nuke option JEFF_DEBUG for good.

(This code relies upon undefined C behaviour. Every day in ddb is your lucky
 day...)
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.1 2004/06/19 18:28:37 miod Exp $	*/
d302 2
a303 1
	if (cputyp != CPU_88110) {
d316 1
d814 2
a815 1
	if (cputyp == CPU_88110) {
d817 4
a820 1
	} else {
d822 1
a822 2
			 ((regs->snip & 2) ? regs->snip :
			  regs->sfip) ) & ~3;
d824 1
d1137 2
a1138 1
			if (cputyp != CPU_88110) {
d1143 1
d1145 1
a1145 1
				  cputyp == CPU_88110 ? "e" : "s", frame.sxip);
@


1.1
log
@Share common ddb files accross m88k platforms.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.27 2004/01/29 21:39:05 deraadt Exp $	*/
d1108 3
a1110 2
				 * The value we've just read will be either another frame pointer,
				 * or the start of another exception frame.
d1112 7
a1118 9
				if (
#ifdef JEFF_DEBUG
				   val2 == 0
#else
				   val2 == 0x12345678
#endif
				   && db_trace_get_val(val1-4, &val2) && val2 == val1
				   && db_trace_get_val(val1-8, &val2) && val2 == val1) {
					/* we've found a frame, so the stack must have been good */
@

