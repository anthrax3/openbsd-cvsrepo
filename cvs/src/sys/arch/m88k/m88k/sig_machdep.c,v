head	1.27;
access;
symbols
	OPENBSD_6_1:1.27.0.4
	OPENBSD_6_1_BASE:1.27
	OPENBSD_6_0:1.26.0.2
	OPENBSD_6_0_BASE:1.26
	OPENBSD_5_9:1.23.0.4
	OPENBSD_5_9_BASE:1.23
	OPENBSD_5_8:1.23.0.6
	OPENBSD_5_8_BASE:1.23
	OPENBSD_5_7:1.23.0.2
	OPENBSD_5_7_BASE:1.23
	OPENBSD_5_6:1.22.0.4
	OPENBSD_5_6_BASE:1.22
	OPENBSD_5_5:1.16.0.8
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.16.0.4
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.16.0.2
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.14.0.2
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.4
	OPENBSD_5_0:1.13.0.2
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.10.0.4
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.10.0.2
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.9.0.4
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.8
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.6
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.2
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.8.0.2
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.4.0.8
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.6
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.4
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.2
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.3.0.2
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.2.0.2
	OPENBSD_3_7_BASE:1.2;
locks; strict;
comment	@ * @;


1.27
date	2016.10.08.23.31.57;	author guenther;	state Exp;
branches;
next	1.26;
commitid	xPjZMlky0E4Hz1cm;

1.26
date	2016.06.21.12.31.19;	author aoyama;	state Exp;
branches;
next	1.25;
commitid	3fBuma0XwNgdrzrx;

1.25
date	2016.05.21.00.56.43;	author deraadt;	state Exp;
branches;
next	1.24;
commitid	oWpLaBOdDMvIxei3;

1.24
date	2016.05.10.18.39.46;	author deraadt;	state Exp;
branches;
next	1.23;
commitid	qfOifNidEGDB2jL1;

1.23
date	2015.02.09.08.48.23;	author miod;	state Exp;
branches;
next	1.22;
commitid	nHILVH7gnv1xZfAl;

1.22
date	2014.06.05.21.57.12;	author miod;	state Exp;
branches;
next	1.21;
commitid	nDRQC4Bj38CUA6Tf;

1.21
date	2014.06.02.21.18.56;	author miod;	state Exp;
branches;
next	1.20;
commitid	uo5KRamAXna2Uum1;

1.20
date	2014.06.01.10.40.07;	author miod;	state Exp;
branches;
next	1.19;
commitid	wSWtmEEbbhPlqXb3;

1.19
date	2014.05.31.11.27.50;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2014.03.26.05.23.42;	author guenther;	state Exp;
branches;
next	1.17;

1.17
date	2014.03.22.06.05.45;	author guenther;	state Exp;
branches;
next	1.16;

1.16
date	2012.12.02.07.03.31;	author guenther;	state Exp;
branches;
next	1.15;

1.15
date	2012.08.22.13.33.32;	author okan;	state Exp;
branches;
next	1.14;

1.14
date	2012.05.09.21.25.33;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2011.07.05.04.48.01;	author guenther;	state Exp;
branches;
next	1.12;

1.12
date	2011.04.18.21.44.55;	author guenther;	state Exp;
branches;
next	1.11;

1.11
date	2011.04.15.04.52.39;	author guenther;	state Exp;
branches;
next	1.10;

1.10
date	2010.06.26.23.24.43;	author guenther;	state Exp;
branches;
next	1.9;

1.9
date	2008.07.28.17.50.11;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2007.12.31.09.23.53;	author martin;	state Exp;
branches;
next	1.7;

1.7
date	2007.12.08.18.38.23;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2007.11.21.18.52.52;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2007.11.17.05.36.23;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2006.01.02.19.46.12;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2005.04.30.16.44.08;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2004.09.30.21.48.56;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2004.09.30.09.20.48;	author miod;	state Exp;
branches;
next	;


desc
@@


1.27
log
@Report the PID in sendsig() debugging

tested by aoyama@@
@
text
@/*	$OpenBSD: sig_machdep.c,v 1.26 2016/06/21 12:31:19 aoyama Exp $	*/
/*
 * Copyright (c) 2014 Miodrag Vallat.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
/*
 * Copyright (c) 1998, 1999, 2000, 2001 Steve Murphree, Jr.
 * Copyright (c) 1996 Nivas Madhur
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Nivas Madhur.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */
/*
 * Mach Operating System
 * Copyright (c) 1993-1991 Carnegie Mellon University
 * Copyright (c) 1991 OMRON Corporation
 * All Rights Reserved.
 *
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/signalvar.h>
#include <sys/kernel.h>
#include <sys/proc.h>
#include <sys/mount.h>
#include <sys/syscallargs.h>
#include <sys/errno.h>

#include <machine/reg.h>
#ifdef M88100
#include <machine/m88100.h>
#include <machine/trap.h>
#endif

#include <uvm/uvm_extern.h>

vaddr_t	local_stack_frame(struct trapframe *, vaddr_t, size_t);

struct sigstate {
	int		 ss_flags;	/* which of the following are valid */
	struct trapframe ss_frame;	/* original exception frame */
};

/*
 * WARNING: sigcode() in subr.s assumes sf_scp is the first field of the
 * sigframe.
 */
struct sigframe {
	struct sigcontext	*sf_scp;	/* context ptr for handler */
	struct sigcontext	 sf_sc;		/* actual context */
	siginfo_t		 sf_si;
};

#ifdef DEBUG
int sigdebug = 0;
pid_t sigpid = 0;
#define SDB_FOLLOW	0x01
#define SDB_KSTACK	0x02
#endif

/*
 * Send an interrupt to process.
 */
void
sendsig(sig_t catcher, int sig, int mask, unsigned long code, int type,
    union sigval val)
{
	struct proc *p = curproc;
	struct trapframe *tf;
	struct sigacts *psp = p->p_p->ps_sigacts;
	struct sigframe *fp;
	size_t fsize;
	struct sigframe sf;
	vaddr_t addr;

	tf = p->p_md.md_tf;

	if (psp->ps_siginfo & sigmask(sig))
		fsize = sizeof(struct sigframe);
	else
		fsize = offsetof(struct sigframe, sf_si);

	/*
	 * Allocate space for the signal handler context.
	 */
	if ((p->p_sigstk.ss_flags & SS_DISABLE) == 0 &&
	    !sigonstack(tf->tf_r[31]) && (psp->ps_sigonstack & sigmask(sig))) {
		addr = local_stack_frame(tf,
		    (vaddr_t)p->p_sigstk.ss_sp + p->p_sigstk.ss_size, fsize);
	} else
		addr = local_stack_frame(tf, tf->tf_r[31], fsize);

	fp = (struct sigframe *)addr;

	/*
	 * Build the signal context to be used by sigreturn.
	 */
	bzero(&sf, fsize);
	sf.sf_scp = &fp->sf_sc;
	sf.sf_sc.sc_mask = mask;
	sf.sf_sc.sc_cookie = (long)sf.sf_scp ^ p->p_p->ps_sigcookie;

	if (psp->ps_siginfo & sigmask(sig))
		initsiginfo(&sf.sf_si, sig, code, type, val);

	/*
	 * Copy the whole user context into signal context that we
	 * are building.
	 */
	bcopy((const void *)&tf->tf_regs, (void *)&sf.sf_sc.sc_regs,
	    sizeof(sf.sf_sc.sc_regs));

	if (copyout((caddr_t)&sf, (caddr_t)fp, fsize)) {
		/*
		 * Process has trashed its stack; give it an illegal
		 * instruction to halt it in its tracks.
		 */
		sigexit(p, SIGILL);
		/* NOTREACHED */
	}

	/*
	 * Set up registers for the signal handler invocation.
	 */
	tf->tf_r[1] = p->p_p->ps_sigcode;	/* return to sigcode */
	tf->tf_r[2] = sig;			/* first arg is signo */
	tf->tf_r[3] = psp->ps_siginfo & sigmask(sig) ? (vaddr_t)&fp->sf_si : 0;
	tf->tf_r[4] = (vaddr_t)&fp->sf_sc;
	tf->tf_r[31] = (vaddr_t)fp;
	addr = (vaddr_t)catcher;		/* and resume in the handler */
#ifdef M88100
	if (CPU_IS88100) {
		tf->tf_snip = (addr & NIP_ADDR) | NIP_V;
		tf->tf_sfip = (tf->tf_snip + 4) | FIP_V;
	}
#endif
#ifdef M88110
	if (CPU_IS88110)
		tf->tf_exip = (addr & XIP_ADDR);
#endif

#ifdef DEBUG
	if ((sigdebug & SDB_FOLLOW) ||
	    ((sigdebug & SDB_KSTACK) && p->p_p->ps_pid == sigpid))
		printf("sendsig(%d): sig %d returns\n", p->p_p->ps_pid, sig);
#endif
}

/*
 * System call to cleanup state after a signal has been taken.  Reset signal
 * mask and stack state from context left by sendsig (above).  Return to
 * previous pc and psl as specified by context left by sendsig.  Check
 * carefully to make sure that the user has not modified the psl to gain
 * improper privileges or to cause a machine fault.
 */
int
sys_sigreturn(struct proc *p, void *v, register_t *retval)
{
	struct sys_sigreturn_args /* {
	   syscallarg(struct sigcontext *) sigcntxp;
	} */ *uap = v;
	struct sigcontext ksc, *scp = SCARG(uap, sigcntxp);
	struct trapframe *tf;
	int error;
	vaddr_t pc;

	tf = p->p_md.md_tf;

	/*
	 * This is simpler than PROC_PC, assuming XIP is always valid
	 * on 88100, and doesn't have a delay slot on 88110
	 * (which is the status we expect from the signal code).
	 */ 
	pc = CPU_IS88110 ? tf->tf_regs.exip : tf->tf_regs.sxip ^ XIP_V;
	if (pc != p->p_p->ps_sigcoderet) {
		sigexit(p, SIGILL);
		return (EPERM);
	}

	if (((vaddr_t)scp & 3) != 0)
		return (EFAULT);

	if ((error = copyin((caddr_t)scp, (caddr_t)&ksc, sizeof(*scp))))
		return (error);

	if (ksc.sc_cookie != ((long)scp ^ p->p_p->ps_sigcookie)) {
		sigexit(p, SIGILL);
		return (EFAULT);
	}

	/* Prevent reuse of the sigcontext cookie */
	ksc.sc_cookie = 0;
	(void)copyout(&ksc.sc_cookie, (caddr_t)scp +
	    offsetof(struct sigcontext, sc_cookie), sizeof (ksc.sc_cookie));

	if ((((struct reg *)&ksc.sc_regs)->epsr ^ tf->tf_regs.epsr) &
	    PSR_USERSTATIC)
		return (EINVAL);

	bcopy((const void *)&ksc.sc_regs, (caddr_t)&tf->tf_regs,
	    sizeof(ksc.sc_regs));

	/*
	 * Restore the user supplied information
	 */
	p->p_sigmask = ksc.sc_mask & ~sigcantmask;

#ifdef M88100
	if (CPU_IS88100) {
		/*
		 * If we are returning from a signal handler triggered by
		 * a data access exception, the interrupted access has
		 * never been performed, and will not be reissued upon
		 * returning to userland.
		 *
		 * We can't simply call data_access_emulation(), for
		 * it might fault again. Instead, we invoke trap()
		 * again, which will either trigger another signal,
		 * or end up invoking data_access_emulation if safe.
		 */
		if (ISSET(tf->tf_dmt0, DMT_VALID))
			m88100_trap(T_DATAFLT, tf);
	}
#endif

	/*
	 * We really want to return to the instruction pointed to by the
	 * sigcontext.  However, due to the way exceptions work on 88110,
	 * returning EJUSTRETURN will cause m88110_syscall() to skip one
	 * instruction.  We avoid this by returning ERESTART, which will
	 * indeed cause the instruction pointed to by exip to be run
	 * again.
	 */
	return CPU_IS88100 ? EJUSTRETURN : ERESTART;
}

/*
 * Find out a safe place on the process' stack to put the sigframe struct.
 * While on 88110, this is straightforward, on 88100 we need to be
 * careful and not stomp over potential uncompleted data accesses, which
 * we will want to be able to perform upon sigreturn().
 */
vaddr_t
local_stack_frame(struct trapframe *tf, vaddr_t tos, size_t fsize)
{
	vaddr_t frame;

	frame = (tos - fsize) & ~_STACKALIGNBYTES;

#ifdef M88100
	if (CPU_IS88100 && ISSET(tf->tf_dmt0, DMT_VALID)) {
		for (;;) {
			tos = frame + fsize;
			if (/* ISSET(tf->tf_dmt0, DMT_VALID) && */
			    tf->tf_dma0 >= frame && tf->tf_dma0 < tos) {
				frame = (tf->tf_dma0 - fsize) &
				    ~_STACKALIGNBYTES;
				continue;
			}
			if (ISSET(tf->tf_dmt1, DMT_VALID) &&
			    tf->tf_dma1 >= frame && tf->tf_dma1 < tos) {
				frame = (tf->tf_dma1 - fsize) &
				    ~_STACKALIGNBYTES;
				continue;
			}
			if (ISSET(tf->tf_dmt2, DMT_VALID) &&
			    tf->tf_dma2 >= frame && tf->tf_dma2 < tos) {
				frame = (tf->tf_dma2 - fsize) &
				    ~_STACKALIGNBYTES;
				continue;
			}
			break;
		}
	}
#endif

	return frame;
}
@


1.26
log
@Add sc_cookie in sigcontext, as same as other ports.
From Miod Vallat, tested by him and me.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sig_machdep.c,v 1.25 2016/05/21 00:56:43 deraadt Exp $	*/
d186 2
a187 2
	    ((sigdebug & SDB_KSTACK) && p->p_pid == sigpid))
		printf("sendsig(%d): sig %d returns\n", p->p_pid, sig);
@


1.25
log
@hand-massage sendsig() and sys_sigreturn() to be much more similar.
ok guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: sig_machdep.c,v 1.24 2016/05/10 18:39:46 deraadt Exp $	*/
d143 1
d206 2
d209 9
a217 1
	if (PROC_PC(p) != p->p_p->ps_sigcoderet) {
a236 2

	tf = p->p_md.md_tf;
@


1.24
log
@SROP mitigation.  sendsig() stores a (per-process ^ &sigcontext) cookie
inside the sigcontext.  sigreturn(2) checks syscall entry was from the
exact PC addr in the (per-process ASLR) sigtramp, verifies the cookie,
and clears it to prevent sigcontext reuse.
not yet tested on landisk, sparc, *88k, socppc.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: sig_machdep.c,v 1.23 2015/02/09 08:48:23 miod Exp $	*/
a136 7
#ifdef DEBUG
	if ((sigdebug & SDB_FOLLOW) ||
	    ((sigdebug & SDB_KSTACK) && p->p_pid == sigpid))
		printf("sendsig(%d): sig %d ssp %p usp %p scp %p\n",
		       p->p_pid, sig, &sf, fp, &fp->sf_sc);
#endif

d203 1
a203 1
	struct sigcontext *scp = SCARG(uap, sigcntxp);
a204 1
	struct sigcontext ksc;
a206 2
		printf("%s(%d): sigreturn not from tramp [pc 0x%llx %llx]\n",
		    p->p_comm, p->p_pid, PROC_PC(p), p->p_p->ps_sigcoderet);
d212 2
a213 1
		return (EINVAL);
a217 3
		printf("%s(%d): cookie %lx should have been %lx\n",
		    p->p_comm, p->p_pid, ksc.sc_cookie,
		    (long)scp ^ p->p_p->ps_sigcookie);
d225 1
a225 2
	    offsetof(struct sigcontext, sc_cookie),
	    sizeof (ksc.sc_cookie));
a227 1
	scp = &ksc;
d229 1
a229 1
	if ((((struct reg *)&scp->sc_regs)->epsr ^ tf->tf_regs.epsr) &
d233 2
a234 2
	bcopy((const void *)&scp->sc_regs, (caddr_t)&tf->tf_regs,
	    sizeof(scp->sc_regs));
d239 1
a239 1
	p->p_sigmask = scp->sc_mask & ~sigcantmask;
@


1.23
log
@Do not even try to call uvm_grow() from sendsig. It will be invoked
automagically if copyout() of the signal frame faults.
@
text
@d1 1
a1 1
/*	$OpenBSD: sig_machdep.c,v 1.22 2014/06/05 21:57:12 miod Exp $	*/
d210 1
a210 1
	struct sigcontext *scp;
d214 8
a221 7
	scp = (struct sigcontext *)SCARG(uap, sigcntxp);
#ifdef DEBUG
	if (sigdebug & SDB_FOLLOW)
		printf("sigreturn: pid %d, scp %p\n", p->p_pid, scp);
#endif
	if (((vaddr_t)scp & 3) != 0 ||
	    copyin((caddr_t)scp, (caddr_t)&ksc, sizeof(struct sigcontext)))
d223 16
@


1.22
log
@Remove conditional pipeline rewind on 88100, introduced in 1.19 - this seems
to create subtle problems, and removing it does not prevent existing signal
delivery tests from having the correct behaviour. And this is likely redundant
with DAE processing in sigreturn.

We should probably rewind if XIP_V is not set, but does this ever happen
in real life? To be investigated on a rainy day.

This seems to fix spurious signals encountered building libstdc++ and perl.
@
text
@d1 1
a1 1
/*	$OpenBSD: sig_machdep.c,v 1.21 2014/06/02 21:18:56 miod Exp $	*/
d126 1
a126 4
	 * Allocate and validate space for the signal handler context.
	 * Note that if the stack is in data space, the call to grow()
	 * will be a nop, and the copyout() will fail if the process has
	 * not already allocated the space.
a133 3

	if (addr <= USRSTACK - ptoa(p->p_vmspace->vm_ssize))
		(void)uvm_grow(p, addr);
@


1.21
log
@Apply the ``make sure sigcontext does not overlap pending DAE addresses''
logic in the dedicated signal stack case, too.

Also, every time the sigcontext position is recomputed by the above logic,
recheck the DAE addresses from the beginning, in case a formerly avoided
address now risks being overwritten.
@
text
@d1 1
a1 1
/*	$OpenBSD: sig_machdep.c,v 1.20 2014/06/01 10:40:07 miod Exp $	*/
a165 34

#ifdef M88100
	if (CPU_IS88100) {
		/*
		 * Rewind the pipeline one instruction, in order to
		 * reexecute the faulting instruction upon sigreturn,
		 * if we are sure the instruction execution has not
		 * completed.
		 *
		 * The manual hints the valid bit in XIP should be
		 * enough, but the description of each exception (and
		 * the actual observed behaviour) disagree.
		 *
		 * Note that the values below are vector offset (in
		 * quadword units), matching those used in eh.S, rather
		 * than the logical T_xxx values.
		 */
		switch (tf->tf_vector) {
		case 2:		/* instruction access exception */
		case 3:		/* data access exception */
		case 4:		/* misaligned access exception */
		case 5:		/* unimplemented opcode exception */
		case 6:		/* privilege violation exception */
		case 7:		/* bounds check violation exception */
		case 8:		/* illegal integer divide exception */
		case 9:		/* integer overflow exception */
		case 114:	/* FPU precise exception */
		case 504:	/* single-step breakpoint */
		case 511:	/* breakpoint */
			m88100_rewind_insn((struct reg *)&sf.sf_sc.sc_regs);
			break;
		}
	}
#endif
@


1.20
log
@Take subsequent stack alignment into account in local_stack_frame() when
making sure the sigcontext will not overlap pending DAE accesses.

Fixes sporadic sys/kern/signal/earlysig regress failure.
@
text
@d1 1
a1 1
/*	$OpenBSD: sig_machdep.c,v 1.19 2014/05/31 11:27:50 miod Exp $	*/
d79 1
a79 1
vaddr_t	local_stack_frame(struct trapframe *, size_t);
d133 2
a134 2
		addr = ((vaddr_t)p->p_sigstk.ss_sp +
		    p->p_sigstk.ss_size - fsize) & ~_STACKALIGNBYTES;
d136 1
a136 1
		addr = local_stack_frame(tf, fsize);
d314 1
a314 1
local_stack_frame(struct trapframe *tf, size_t fsize)
d318 1
a318 1
	frame = (tf->tf_r[31] - fsize) & ~_STACKALIGNBYTES;
d322 22
a343 9
		if (/* ISSET(tf->tf_dmt0, DMT_VALID) && */
		    tf->tf_dma0 >= frame && tf->tf_dma0 < tf->tf_r[31])
			frame = (tf->tf_dma0 - fsize) & ~_STACKALIGNBYTES;
		if (ISSET(tf->tf_dmt1, DMT_VALID) &&
		    tf->tf_dma1 >= frame && tf->tf_dma1 < tf->tf_r[31])
			frame = (tf->tf_dma1 - fsize) & ~_STACKALIGNBYTES;
		if (ISSET(tf->tf_dmt2, DMT_VALID) &&
		    tf->tf_dma2 >= frame && tf->tf_dma2 < tf->tf_r[31])
			frame = (tf->tf_dma2 - fsize) & ~_STACKALIGNBYTES;
@


1.19
log
@Address several problems in signal delivery on 88100 processors:
- when building the sigcontext, rewind the pipeline for recoverable
  exceptions, so that sigreturn actually has a chance to cause the
  interrupted instruction to be run again.
- when returning with sigreturn, and the sigcontext contains valid
  DAE information, the DAE need to be emulated before returning, for
  the processor will not reissue them.
- finally, when the sigframe is allocated on the current process' stack,
  be careful not to stomp upon addresses referenced by the DAE information,
  for this would defeat the previous point.

All these changes only affect 88100 processors only. 88110 operation is
unchanged.

While there, do not copyout an empty siginfo struct if the signal handler
does not expect any.

Hair-pulling evil testcase provided by aoyama@@, based upon one of
devel/libsigsegv configure tests (which would spin on 88100 and run happily on
88110).
@
text
@d1 1
a1 1
/*	$OpenBSD: sig_machdep.c,v 1.18 2014/03/26 05:23:42 guenther Exp $	*/
d132 5
a136 5
	    !sigonstack(tf->tf_r[31]) && (psp->ps_sigonstack & sigmask(sig)))
		fp = (struct sigframe *)(p->p_sigstk.ss_sp +
					 p->p_sigstk.ss_size - fsize);
	else
		fp = (struct sigframe *)local_stack_frame(tf, fsize);
d138 2
a139 3
	/* make sure the frame is aligned on a proper stack boundary */
	if (((vaddr_t)fp & _STACKALIGNBYTES) != 0)
		fp = (struct sigframe *)((vaddr_t)fp & ~_STACKALIGNBYTES);
d141 1
a141 2
	if ((vaddr_t)fp <= USRSTACK - ptoa(p->p_vmspace->vm_ssize))
		(void)uvm_grow(p, (vaddr_t)fp);
d318 1
a318 1
	frame = tf->tf_r[31] - fsize;
d324 1
a324 1
			frame = tf->tf_dma0 - fsize;
d327 1
a327 1
			frame = tf->tf_dma1 - fsize;
d330 1
a330 1
			frame = tf->tf_dma2 - fsize;
@


1.18
log
@Move p_emul and p_sigcode from proc to process.
Tweak the handling of ktrace EMUL when changing ktracing: only
generate one per process (not one per thread) and pass the correct
proc pointer down to the VFS layer.  Permit generating of NAMI and
CSW records inside ktrace(2) itself.

ok deraadt@@ millert@@
@
text
@d1 16
a16 1
/*	$OpenBSD: sig_machdep.c,v 1.17 2014/03/22 06:05:45 guenther Exp $	*/
d72 4
d79 2
d114 1
a114 1
	int fsize;
d120 5
d126 4
a129 5
	 * Allocate and validate space for the signal handler
	 * context. Note that if the stack is in data space, the
	 * call to grow() is a nop, and the copyout()
	 * will fail if the process has not already allocated
	 * the space with a `brk'.
a130 1
	fsize = sizeof(struct sigframe);
d136 1
a136 1
		fp = (struct sigframe *)(tf->tf_r[31] - fsize);
d138 3
a140 3
	/* make sure the frame is aligned on a 8 byte boundary */
	if (((vaddr_t)fp & 0x07) != 0)
		fp = (struct sigframe *)((vaddr_t)fp & ~0x07);
d148 1
a148 1
		printf("sendsig(%d): sig %d ssp %x usp %x scp %x\n",
d151 1
d155 1
a155 1
	bzero(&sf, sizeof(sf));
d159 1
a159 1
	if (psp->ps_siginfo & sigmask(sig)) {
a160 1
	}
d169 35
a203 1
	if (copyout((caddr_t)&sf, (caddr_t)fp, sizeof sf)) {
d228 1
a228 1
	if (CPU_IS88110) {
a229 1
	}
a245 2

/* ARGSUSED */
d259 1
a259 1
		printf("sigreturn: pid %d, scp %x\n", p->p_pid, scp);
d280 18
d299 6
a304 6
	 * We really want to return to the instruction pointed to by
	 * the sigcontext.  However, due to the way exceptions work
	 * on 88110, returning EJUSTRETURN will cause m88110_syscall()
	 * to skip one instruction.  We avoid this by returning
	 * ERESTART, which will indeed cause the instruction pointed
	 * to by exip to be run.
d306 31
a336 1
	return (CPU_IS88100 ? EJUSTRETURN : ERESTART);
@


1.17
log
@Move p_sigacts from struct proc to struct process.

testing help mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sig_machdep.c,v 1.16 2012/12/02 07:03:31 guenther Exp $	*/
d157 1
a157 1
	tf->tf_r[1] = p->p_sigcode;		/* return to sigcode */
@


1.16
log
@Determine whether we're currently on the alternative signal stack
dynamically, by comparing the stack pointer against the altstack
base and size, so that you get the correct answer if you longjmp
out of the signal handler, as tested by regress/sys/kern/stackjmp/.
Also, fix alt stack handling on vax, where it was completely broken.

Testing and corrections by miod@@, krw@@, tobiasu@@, pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sig_machdep.c,v 1.15 2012/08/22 13:33:32 okan Exp $	*/
d91 1
a91 1
	struct sigacts *psp = p->p_sigacts;
@


1.15
log
@sigpid should be of type pid_t (only visable with DEBUG).

ok miod@@ (who found others to fix as well)
@
text
@d1 1
a1 1
/*	$OpenBSD: sig_machdep.c,v 1.14 2012/05/09 21:25:33 miod Exp $	*/
d93 1
a93 1
	int oonstack, fsize;
d98 1
a98 1
	oonstack = p->p_sigstk.ss_flags & SS_ONSTACK;
d108 1
a108 2
	    (p->p_sigstk.ss_flags & SS_ONSTACK) == 0 &&
	    (psp->ps_sigonstack & sigmask(sig))) {
d111 1
a111 2
		p->p_sigstk.ss_flags |= SS_ONSTACK;
	} else
d125 1
a125 1
		       p->p_pid, sig, &oonstack, fp, &fp->sf_sc);
d130 1
a131 1
	sf.sf_sc.sc_onstack = oonstack;
a222 4
	if (scp->sc_onstack & SS_ONSTACK)
		p->p_sigstk.ss_flags |= SS_ONSTACK;
	else
		p->p_sigstk.ss_flags &= ~SS_ONSTACK;
@


1.14
log
@Do not include <machine/reg.h> and pollute userland namespace with struct reg
in <machine/signal.h>.
@
text
@d1 1
a1 1
/*	$OpenBSD: sig_machdep.c,v 1.13 2011/07/05 04:48:01 guenther Exp $	*/
d77 1
a77 1
int sigpid = 0;
@


1.13
log
@Recommit the reverted sigacts change now that the NFS use-after-free
problem has been tracked down.  This fixes the sharing of the signal
handling state: shared bits go in sigacts, per-rthread bits goes in
struct proc.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sig_machdep.c,v 1.12 2011/04/18 21:44:55 guenther Exp $	*/
d215 2
a216 1
	if ((scp->sc_regs.epsr ^ tf->tf_regs.epsr) & PSR_USERSTATIC)
@


1.12
log
@Revert the sigacts diff: NFS can apparently retain pointers to processes
until they're zombies and then send them signals (for intr mounts).  Until
that is untangled, the sigacts change is unsafe.  sthen@@ was the victim
for this one
@
text
@d1 1
a1 1
/*	$OpenBSD: sig_machdep.c,v 1.10 2010/06/26 23:24:43 guenther Exp $	*/
d98 1
a98 1
	oonstack = psp->ps_sigstk.ss_flags & SS_ONSTACK;
d107 2
a108 2
	if ((psp->ps_flags & SAS_ALTSTACK) &&
	    (psp->ps_sigstk.ss_flags & SS_ONSTACK) == 0 &&
d110 3
a112 3
		fp = (struct sigframe *)(psp->ps_sigstk.ss_sp +
					 psp->ps_sigstk.ss_size - fsize);
		psp->ps_sigstk.ss_flags |= SS_ONSTACK;
d225 1
a225 1
		p->p_sigacts->ps_sigstk.ss_flags |= SS_ONSTACK;
d227 1
a227 1
		p->p_sigacts->ps_sigstk.ss_flags &= ~SS_ONSTACK;
@


1.11
log
@Correct the sharing of the signal handling state: stuff that should
be shared (p_sigignore, p_sigcatch, P_NOCLDSTOP, P_NOCLDWAIT) moves
to struct sigacts, wihle stuff that should be per rthread (ps_oldmask,
SAS_OLDMASK, ps_sigstk) moves to struct proc.  Treat the coredumping
state bits (ps_sig, ps_code, ps_type, ps_sigval) as per-rthread
until our locking around coredumping is better.

Oh, and remove the old SunOS-compat ps_usertramp member.

"I like the sound of this" tedu@@
@
text
@d98 1
a98 1
	oonstack = p->p_sigstk.ss_flags & SS_ONSTACK;
d107 2
a108 2
	if ((p->p_sigstk.ss_flags & SS_DISABLE) == 0 &&
	    (p->p_sigstk.ss_flags & SS_ONSTACK) == 0 &&
d110 3
a112 3
		fp = (struct sigframe *)(p->p_sigstk.ss_sp +
					 p->p_sigstk.ss_size - fsize);
		p->p_sigstk.ss_flags |= SS_ONSTACK;
d225 1
a225 1
		p->p_sigstk.ss_flags |= SS_ONSTACK;
d227 1
a227 1
		p->p_sigstk.ss_flags &= ~SS_ONSTACK;
@


1.10
log
@Don't #include <sys/user.h> into files that don't need the stuff
it defines.  In some cases, this means pulling in uvm.h or pcb.h
instead, but most of the inclusions were just noise.  Tested on
alpha, amd64, armish, hppa, i386, macpcc, sgi, sparc64, and vax,
mostly by krw and naddy.
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sig_machdep.c,v 1.9 2008/07/28 17:50:11 miod Exp $	*/
d98 1
a98 1
	oonstack = psp->ps_sigstk.ss_flags & SS_ONSTACK;
d107 2
a108 2
	if ((psp->ps_flags & SAS_ALTSTACK) &&
	    (psp->ps_sigstk.ss_flags & SS_ONSTACK) == 0 &&
d110 3
a112 3
		fp = (struct sigframe *)(psp->ps_sigstk.ss_sp +
					 psp->ps_sigstk.ss_size - fsize);
		psp->ps_sigstk.ss_flags |= SS_ONSTACK;
d225 1
a225 1
		p->p_sigacts->ps_sigstk.ss_flags |= SS_ONSTACK;
d227 1
a227 1
		p->p_sigacts->ps_sigstk.ss_flags &= ~SS_ONSTACK;
@


1.9
log
@In process_write_regs() and sigreturn(), be more strict about the bits
userland is allowed to change in psr.
@
text
@d1 1
a1 1
/*	$OpenBSD: sig_machdep.c,v 1.8 2007/12/31 09:23:53 martin Exp $	*/
a51 1
#include <sys/user.h>
@


1.8
log
@replace ctob/btoc by ptoa/atop as done for other architectures
@
text
@d1 1
a1 1
/*	$OpenBSD: sig_machdep.c,v 1.7 2007/12/08 18:38:23 miod Exp $	*/
d215 3
@


1.7
log
@Do not pass a siginfo_t * pointer to the signal handler if no siginfo
is required.
@
text
@d1 1
a1 1
/*	$OpenBSD: sig_machdep.c,v 1.6 2007/11/21 18:52:52 miod Exp $	*/
d121 1
a121 1
	if ((vaddr_t)fp <= USRSTACK - ctob(p->p_vmspace->vm_ssize))
@


1.6
log
@A really horrible fix for sigreturn on 88110. This will probably be replaced
by something better in the future, but for now this will do. Just don't
tell anyone I did this.
@
text
@d1 1
a1 1
/*	$OpenBSD: sig_machdep.c,v 1.5 2007/11/17 05:36:23 miod Exp $	*/
d162 3
a164 1
	tf->tf_r[3] = (vaddr_t)&fp->sf_si;	/* second arg is siginfo */
a176 1
	tf->tf_r[31] = (vaddr_t)fp;
@


1.5
log
@Replace many ``unsigned'' variables with ``unsigned int'', ``u_int'' or other
appropriate types. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: sig_machdep.c,v 1.4 2006/01/02 19:46:12 miod Exp $	*/
d227 9
a235 1
	return (EJUSTRETURN);
@


1.4
log
@Faster signal trampoline code for m88k: instead of pushing everything on
the stack a la m68k, put handler arguments in register, transfer control
to the handler directly, but have it return in the sigcode.
While there, remove wrong comments about the sigcode being on top of the
user stack.
@
text
@d1 1
a1 1
/*	$OpenBSD: sig_machdep.c,v 1.3 2005/04/30 16:44:08 miod Exp $	*/
d121 2
a122 2
	if ((unsigned)fp <= USRSTACK - ctob(p->p_vmspace->vm_ssize))
		(void)uvm_grow(p, (unsigned)fp);
@


1.3
log
@Use [XNF]IP_ADDR constants rather than their numeric values.
@
text
@d1 1
a1 1
/*	$OpenBSD: sig_machdep.c,v 1.2 2004/09/30 21:48:56 miod Exp $	*/
d67 2
a68 2
 * WARNING: sigcode() in locore.s assumes the layout shown for sf_signo
 * through sf_handler so... don't screw with them!
a70 2
	int			 sf_signo;	/* signo for handler */
	siginfo_t		*sf_sip;
a71 1
	sig_t			 sf_handler;	/* handler addr for u_sigc */
a132 1
	sf.sf_signo = sig;
a133 1
	sf.sf_handler = catcher;
a137 1
		sf.sf_sip = &fp->sf_si;
d156 1
d158 1
a158 2
	 * Build the argument list for the signal handler.
	 * Signal trampoline code is at base of user stack.
d160 4
a163 1
	addr = p->p_sigcode;
d175 2
a176 1
	tf->tf_r[31] = (unsigned)fp;
@


1.2
log
@Introduce sparc-like CPU_ISFOO macros, to short-circuit evaluations when
compiling for one flavour only.

This makes code slightly smaller on all m88k-based platforms (my roughly
1KB), and saves more than meets the eye on luna88k, which is m88100-based.
@
text
@d1 1
a1 1
/*	$OpenBSD: sig_machdep.c,v 1.1 2004/09/30 09:20:48 miod Exp $	*/
d169 1
a169 1
		tf->tf_snip = (addr & ~3) | NIP_V;
d175 1
a175 2
		tf->tf_exip = (addr & ~3);
		tf->tf_enip = (tf->tf_exip + 4);
@


1.1
log
@Move common signal code to m88k-agnostic location.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a166 1
	if (cputyp != CPU_88110) {
d168 1
a168 1
		/* mc88100 */
d171 1
a172 1
	} else {
d174 1
a174 1
		/* mc88110 */
d177 1
a178 1
	}
@

