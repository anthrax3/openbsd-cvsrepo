head	1.12;
access;
symbols
	OPENBSD_6_2_BASE:1.12
	OPENBSD_6_1:1.12.0.14
	OPENBSD_6_1_BASE:1.12
	OPENBSD_6_0:1.12.0.10
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.12.0.6
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.12.0.8
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.12.0.4
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.11.0.4
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.7.0.20
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.18
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.16
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.14
	OPENBSD_5_0:1.7.0.12
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.10
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.8
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.2
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.6
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.4
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.6.0.4
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.2
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.3.0.2
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.2.0.2
	OPENBSD_4_1_BASE:1.2
	OPENBSD_4_0:1.1.0.10
	OPENBSD_4_0_BASE:1.1
	OPENBSD_3_9:1.1.0.8
	OPENBSD_3_9_BASE:1.1
	OPENBSD_3_8:1.1.0.6
	OPENBSD_3_8_BASE:1.1
	OPENBSD_3_7:1.1.0.4
	OPENBSD_3_7_BASE:1.1
	OPENBSD_3_6:1.1.0.2
	OPENBSD_3_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.12
date	2014.05.31.11.19.06;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2013.08.24.20.54.29;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2013.08.18.22.17.26;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2013.08.18.22.13.54;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2013.08.15.19.29.46;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2009.02.21.18.37.48;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2007.12.02.21.17.17;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2007.11.20.21.46.18;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2007.11.17.05.36.23;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2007.05.20.20.12.31;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2006.11.18.22.58.28;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2004.08.01.17.18.05;	author miod;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Introduce m88100_rewind_insn() to rewind the execution pipeline one
instruction, rather than gazillions of inline variants. This also makes
the situations where we clear specific bits in the fip or nip registers
more visible.

No functional change.
@
text
@/*	$OpenBSD: m88100_machdep.c,v 1.11 2013/08/24 20:54:29 miod Exp $	*/
/*
 * Mach Operating System
 * Copyright (c) 1993-1991 Carnegie Mellon University
 * Copyright (c) 1991 OMRON Corporation
 * All Rights Reserved.
 *
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON AND OMRON ALLOW FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON AND OMRON DISCLAIM ANY LIABILITY OF ANY KIND
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

#include <sys/param.h>
#include <sys/systm.h>

#include <machine/asm_macro.h>
#include <m88k/m88100.h>

#ifdef MULTIPROCESSOR
uint32_t m88100_mp_atomic_begin(__cpu_simple_lock_t *, uint *);
void	m88100_mp_atomic_end(uint32_t, __cpu_simple_lock_t *, uint);
#endif

/*
 *  Data Access Emulation for M88100 exceptions
 */

#define DMT_BYTE	1
#define DMT_HALF	2
#define DMT_WORD	4

const struct {
	unsigned char    offset;
	unsigned char    size;
} dmt_en_info[16] = {
	{0, 0},
	{3, DMT_BYTE},
	{2, DMT_BYTE},
	{2, DMT_HALF},
	{1, DMT_BYTE},
	{0, 0},
	{0, 0},
	{0, 0},
	{0, DMT_BYTE},
	{0, 0},
	{0, 0},
	{0, 0},
	{0, DMT_HALF},
	{0, 0},
	{0, 0},
	{0, DMT_WORD}
};

#ifdef DATA_DEBUG
int data_access_emulation_debug = 0;
#define DAE_DEBUG(stuff) \
	do { \
		if (data_access_emulation_debug != 0) { \
			stuff; \
		} \
	} while (0)
#else
#define DAE_DEBUG(stuff)
#endif

void	dae_print_one(u_int, u_int, u_int, u_int);
void	dae_process(struct trapframe *, u_int, u_int, u_int, u_int);

void
dae_print(u_int *f)
{
	struct trapframe *eframe = (void *)f;

	if (!ISSET(eframe->tf_dmt0, DMT_VALID))
		return;

	dae_print_one(0, eframe->tf_dma0, eframe->tf_dmd0, eframe->tf_dmt0);
	dae_print_one(1, eframe->tf_dma1, eframe->tf_dmd1, eframe->tf_dmt1);
	dae_print_one(2, eframe->tf_dma2, eframe->tf_dmd2, eframe->tf_dmt2);
}

void
dae_print_one(u_int x, u_int dmax, u_int dmdx, u_int dmtx)
{
	u_int enbits;
	const char *width, *usr, *xmem;

	if (!ISSET(dmtx, DMT_VALID))
		return;

	enbits = DMT_ENBITS(dmtx);
	dmax += dmt_en_info[enbits].offset;

	if (dmtx & DMT_DOUB1)
		width = ".d";
	else {
		switch (dmt_en_info[enbits].size) {
		case DMT_BYTE:
			if (dmtx & DMT_SIGNED)
				width = ".b";
			else
				width = ".bu";
			break;
		case DMT_HALF:
			if (dmtx & DMT_SIGNED)
				width = ".h";
			else
				width = ".hu";
			break;
		case DMT_WORD:
			width = "";
			break;
		default:
			width = ".???";
			break;
		}
	}
	if (dmtx & DMT_DAS)
		usr = "";
	else
		usr = ".usr";
	if (dmtx & DMT_LOCKBAR)
		xmem = "(xmem)";
	else
		xmem = "";

	if (ISSET(dmtx, DMT_WRITE))
		printf("[DMT%d=%x: %sst%s%s %08x to %08x]\n",
		    x, dmtx, xmem, width, usr, dmdx, dmax);
	else
		printf("[DMT%d=%x: %sld%s%s r%d <- %x]\n",
		    x, dmtx, xmem, width, usr, DMT_DREGBITS(dmtx), dmax);
}

void
data_access_emulation(u_int *f)
{
	struct trapframe *eframe = (void *)f;

	if (!ISSET(eframe->tf_dmt0, DMT_VALID))
		return;

	dae_process(eframe, 0,
	    eframe->tf_dma0, eframe->tf_dmd0, eframe->tf_dmt0);
	dae_process(eframe, 1,
	    eframe->tf_dma1, eframe->tf_dmd1, eframe->tf_dmt1);
	dae_process(eframe, 2,
	    eframe->tf_dma2, eframe->tf_dmd2, eframe->tf_dmt2);

	eframe->tf_dmt0 = 0;
}

void
dae_process(struct trapframe *eframe, u_int x,
    u_int dmax, u_int dmdx, u_int dmtx)
{
	u_int v, reg, enbits;

	if (!ISSET(dmtx, DMT_VALID))
		return;

	DAE_DEBUG(dae_print_one(x, dmax, dmdx, dmtx));

	enbits = DMT_ENBITS(dmtx);
	dmax += dmt_en_info[enbits].offset;
	reg = DMT_DREGBITS(dmtx);

	if (!ISSET(dmtx, DMT_LOCKBAR)) {
		/* the fault is not during an XMEM */

		if (x == 2 && ISSET(dmtx, DMT_DOUB1)) {
			/* pipeline 2 (earliest stage) for a double */

			if (ISSET(dmtx, DMT_WRITE)) {
				/*
				 * STORE DOUBLE WILL BE REINITIATED BY rte
				 */
			} else {
				/* EMULATE ld.d INSTRUCTION */
				v = do_load_word(dmax, dmtx & DMT_DAS);
				if (reg != 0)
					eframe->tf_r[reg] = v;
				v = do_load_word(dmax ^ 4, dmtx & DMT_DAS);
				if (reg != 31)
					eframe->tf_r[reg + 1] = v;
			}
		} else {
			/* not pipeline #2 with a double */
			if (dmtx & DMT_WRITE) {
				switch (dmt_en_info[enbits].size) {
				case DMT_BYTE:
				DAE_DEBUG(
					printf("[byte %x -> %08x(%c)]\n",
					    dmdx & 0xff, dmax,
					    ISSET(dmtx, DMT_DAS) ? 's' : 'u')
				);
					do_store_byte(dmax, dmdx,
					    dmtx & DMT_DAS);
					break;
				case DMT_HALF:
				DAE_DEBUG(
					printf("[half %x -> %08x(%c)]\n",
					    dmdx & 0xffff, dmax,
					    ISSET(dmtx, DMT_DAS) ? 's' : 'u')
				);
					do_store_half(dmax, dmdx,
					    dmtx & DMT_DAS);
					break;
				case DMT_WORD:
				DAE_DEBUG(
					printf("[word %x -> %08x(%c)]\n",
					    dmdx, dmax,
					    ISSET(dmtx, DMT_DAS) ? 's' : 'u')
				);
					do_store_word(dmax, dmdx,
					    dmtx & DMT_DAS);
					break;
				}
			} else {
				/* else it's a read */
				switch (dmt_en_info[enbits].size) {
				case DMT_BYTE:
					v = do_load_byte(dmax, dmtx & DMT_DAS);
					if (!ISSET(dmtx, DMT_SIGNED))
						v &= 0x000000ff;
					break;
				case DMT_HALF:
					v = do_load_half(dmax, dmtx & DMT_DAS);
					if (!ISSET(dmtx, DMT_SIGNED))
						v &= 0x0000ffff;
					break;
				case DMT_WORD:
					v = do_load_word(dmax, dmtx & DMT_DAS);
					break;
				}
				DAE_DEBUG(
					if (reg == 0)
						printf("[no write to r0 done]\n");
					else
						printf("[r%d <- %08x]\n", reg, v);
				);
				if (reg != 0)
					eframe->tf_r[reg] = v;
			}
		}
	} else {
		/* if lockbar is set... it's part of an XMEM */
		/*
		 * According to Motorola's "General Information",
		 * the DMT_DOUB1 bit is never set in this case, as it
		 * should be.
		 * If lockbar is set (as it is if we're here) and if
		 * the write is not set, then it's the same as if DOUB1
		 * was set...
		 */
		if (!ISSET(dmtx, DMT_WRITE)) {
			if (x < 2) {
				/* RERUN xmem WITH DMD(x+1) */
				dmdx =
				    x == 0 ? eframe->tf_dmd1 : eframe->tf_dmd2;
			} else {
				/* RERUN xmem WITH DMD2 */
			}

			if (dmt_en_info[enbits].size == DMT_WORD) {
				v = do_xmem_word(dmax, dmdx, dmtx & DMT_DAS);
			} else {
				v = do_xmem_byte(dmax, dmdx, dmtx & DMT_DAS);
			}
			DAE_DEBUG(
				if (reg == 0)
					printf("[no write to r0 done]\n");
				else
					printf("[r%d <- %08x]\n", reg, v);
			);
			if (reg != 0)
				eframe->tf_r[reg] = v;
		} else {
			if (x == 0) {
				if (reg != 0)
					eframe->tf_r[reg] = dmdx;
				m88100_rewind_insn(&(eframe->tf_regs));
				/* xmem RERUN ON rte */
				eframe->tf_dmt0 = 0;
				return;
			}
		}
	}
}

/*
 * Routines to patch the kernel code on 88100 systems not affected by
 * the xxx.usr bug.
 */

void
m88100_apply_patches()
{
#ifdef ERRATA__XXX_USR
	if (((get_cpu_pid() & PID_VN) >> VN_SHIFT) > 10) {
		/*
		 * Patch DAE helpers.
		 *	    before		    after
		 *	branch			branch
		 *	NOP			jmp.n r1
		 *	xxx.usr			xxx.usr
		 *	NOP; NOP; NOP
		 *	jmp r1
		 */
		((u_int32_t *)(do_load_word))[1] = 0xf400c401;
		((u_int32_t *)(do_load_half))[1] = 0xf400c401;
		((u_int32_t *)(do_load_byte))[1] = 0xf400c401;
		((u_int32_t *)(do_store_word))[1] = 0xf400c401;
		((u_int32_t *)(do_store_half))[1] = 0xf400c401;
		((u_int32_t *)(do_store_byte))[1] = 0xf400c401;
	}
#endif
}

#ifdef MULTIPROCESSOR
void
m88100_smp_setup(struct cpu_info *ci)
{
	/*
	 * Setup function pointers for mplock operation.
	 */

	ci->ci_mp_atomic_begin = m88100_mp_atomic_begin;
	ci->ci_mp_atomic_end = m88100_mp_atomic_end;
}

uint32_t
m88100_mp_atomic_begin(__cpu_simple_lock_t *lock, uint *csr)
{
	uint32_t psr;

	psr = get_psr();
	set_psr(psr | PSR_IND);
	__cpu_simple_lock(lock);

	return psr;
}

void
m88100_mp_atomic_end(uint32_t psr, __cpu_simple_lock_t *lock, uint csr)
{
	__cpu_simple_unlock(lock);
	set_psr(psr);
}
#endif
@


1.11
log
@Make sure do_xmem_* return the correct value. This fixes usage of fork()
in programs linked against libpthread on 88100 processors, where the parent
thread issueing fork() would spin.

Interestingly enough, this bug is not found in Mach, but has been introduced
by Nivas when porting to mvme88k, 18 years ago. DAE involving xmem are rare
enough for the issue to have survived so long (and once again, it was a
nightmare to track down).
@
text
@d1 1
a1 1
/*	$OpenBSD: m88100_machdep.c,v 1.10 2013/08/18 22:17:26 miod Exp $	*/
d298 1
a298 3
				eframe->tf_sfip = eframe->tf_snip;
				eframe->tf_snip = eframe->tf_sxip;
				eframe->tf_sxip = 0;
@


1.10
log
@data_access_emulation() may fault. Be sure to clear pcb_onfault before
invoking it.

While there, rework the return-to-pcb_onfault logic to avoid falling through
the DAE code. This allows us to get rid of the bogus DMT_SKIP flag as well:
DAE is only necessary if DMT_VALID is set in DMT0, and DMT0 is reset to zero
afterwards.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88100_machdep.c,v 1.8 2013/08/15 19:29:46 miod Exp $	*/
d286 6
a333 2
		((u_int32_t *)(do_xmem_word))[1] = 0xf400c401;
		((u_int32_t *)(do_xmem_byte))[1] = 0xf400c401;
@


1.9
log
@Rework the DAE print routines again to output something closer to an actual
instruction, and print the target address rather than the rounded address
and the byte enables.
@
text
@d156 1
a156 2
	if (!ISSET(eframe->tf_dmt0, DMT_VALID) ||
	    ISSET(eframe->tf_dmt0, DMT_SKIP))
d166 1
a166 1
	eframe->tf_dmt0 |= DMT_SKIP;
@


1.8
log
@make debug output sligthly more useful
@
text
@d1 1
a1 1
/*	$OpenBSD: m88100_machdep.c,v 1.7 2009/02/21 18:37:48 miod Exp $	*/
d101 3
d107 36
d144 2
a145 5
		printf("[DMT%d=%x: st.%c %x to %x en %x %s %s]\n",
		    x, dmtx, dmtx & DMT_DAS ? 's' : 'u', dmdx, dmax,
		    DMT_ENBITS(dmtx),
		    dmtx & DMT_DOUB1 ? "double": "not double",
		    dmtx & DMT_LOCKBAR ? "xmem": "not xmem");
d147 2
a148 5
		printf("[DMT%d=%x: ld.%c r%d <- %x en %x %s %s]\n",
		    x, dmtx, dmtx & DMT_DAS ? 's' : 'u',
		    DMT_DREGBITS(dmtx), dmax, DMT_ENBITS(dmtx),
		    dmtx & DMT_DOUB1 ? "double": "not double",
		    dmtx & DMT_LOCKBAR ? "xmem": "not xmem");
d174 1
a174 1
	u_int v, reg;
d179 1
a179 14
      DAE_DEBUG(
		if (ISSET(dmtx, DMT_WRITE))
			printf("[DMT%d=%x: st.%c %x to %x en %x %s %s]\n",
			    x, dmtx, dmtx & DMT_DAS ? 's' : 'u', dmdx, dmax,
			    DMT_ENBITS(dmtx),
			    dmtx & DMT_DOUB1 ? "double": "not double",
			    dmtx & DMT_LOCKBAR ? "xmem": "not xmem");
		else
			printf("[DMT%d=%x: ld.%c r%d <- %x en %x %s %s]\n",
			    x, dmtx, dmtx & DMT_DAS ? 's' : 'u',
			    DMT_DREGBITS(dmtx), dmax, DMT_ENBITS(dmtx),
			    dmtx & DMT_DOUB1 ? "double": "not double",
			    dmtx & DMT_LOCKBAR ? "xmem": "not xmem")
	);
d181 2
a182 1
	dmax += dmt_en_info[DMT_ENBITS(dmtx)].offset;
d207 1
a207 1
				switch (dmt_en_info[DMT_ENBITS(dmtx)].size) {
d210 1
a210 1
					printf("[byte %x -> [%x(%c)]\n",
d219 1
a219 1
					printf("[half %x -> [%x(%c)]\n",
d228 1
a228 1
					printf("[word %x -> [%x(%c)]\n",
d238 1
a238 1
				switch (dmt_en_info[DMT_ENBITS(dmtx)].size) {
d257 1
a257 1
						printf("[r%d <- %x]\n", reg, v);
d282 1
a282 1
			if (dmt_en_info[DMT_ENBITS(dmtx)].size == DMT_WORD) {
@


1.7
log
@Move part of the mp lock logic into per-cpu callbacks; on MVME197DP we need
to disable NMI sources in addition to interrupt sources, and we can not
use a quick sequence with shadowing frozen as done for atomic ops.

This lets GENERIC.MP boot multiuser on MVME197DP boards, and is so far stable
enough to be able to recompile a kernel from scratch (with make -j2).
@
text
@d1 1
a1 1
/*	$OpenBSD: m88100_machdep.c,v 1.6 2007/12/02 21:17:17 miod Exp $	*/
d105 1
a105 1
		printf("[DMT%d=%x: st.%c %x to %x as %d %s %s]\n",
d111 1
a111 1
		printf("[DMT%d=%x: ld.%c r%d <- %x as %d %s %s]\n",
d148 1
a148 1
			printf("[DMT%d=%x: st.%c %x to %x as %d %s %s]\n",
d154 1
a154 1
			printf("[DMT%d=%x: ld.%c r%d <- %x as %d %s %s]\n",
d253 1
a253 1
			if (x != 2) {
@


1.6
log
@Change DAE processing so that the C code no longer needs the EF_xxx defines
from assym.h.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88100_machdep.c,v 1.5 2007/11/20 21:46:18 miod Exp $	*/
d35 5
d313 32
@


1.5
log
@In data_access_emulation(), make sure that if we want the pipeline replay
to be disabled, this effectively disables the three slots, instead of only
the first. This will only make (rare) things faster.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88100_machdep.c,v 1.4 2007/11/17 05:36:23 miod Exp $	*/
a28 2
#include "assym.h"	/* EF_xxx */

d47 16
a62 4
	{0, 0}, {3, DMT_BYTE}, {2, DMT_BYTE}, {2, DMT_HALF},
	{1, DMT_BYTE}, {0, 0}, {0, 0}, {0, 0},
	{0, DMT_BYTE}, {0, 0}, {0, 0}, {0, 0},
	{0, DMT_HALF}, {0, 0}, {0, 0}, {0, DMT_WORD}
d77 3
d81 1
a81 1
dae_print(u_int *eframe)
d83 1
a83 2
	int x;
	u_int dmax, dmdx, dmtx;
d85 1
a85 1
	if (!ISSET(eframe[EF_DMT0], DMT_VALID))
d88 4
a91 4
	for (x = 0; x < 3; x++) {
		dmtx = eframe[EF_DMT0 + x * 3];
		if (!ISSET(dmtx, DMT_VALID))
			continue;
d93 5
a97 2
		dmdx = eframe[EF_DMD0 + x * 3];
		dmax = eframe[EF_DMA0 + x * 3];
d99 12
a110 13
		if (ISSET(dmtx, DMT_WRITE))
			printf("[DMT%d=%x: st.%c %x to %x as %d %s %s]\n",
			    x, dmtx, dmtx & DMT_DAS ? 's' : 'u', dmdx, dmax,
			    DMT_ENBITS(dmtx),
			    dmtx & DMT_DOUB1 ? "double": "not double",
			    dmtx & DMT_LOCKBAR ? "xmem": "not xmem");
		else
			printf("[DMT%d=%x: ld.%c r%d <- %x as %d %s %s]\n",
			    x, dmtx, dmtx & DMT_DAS ? 's' : 'u',
			    DMT_DREGBITS(dmtx), dmax, DMT_ENBITS(dmtx),
			    dmtx & DMT_DOUB1 ? "double": "not double",
			    dmtx & DMT_LOCKBAR ? "xmem": "not xmem");
	}
d114 1
a114 1
data_access_emulation(u_int *eframe)
d116 1
a116 3
	int x;
	u_int dmax, dmdx, dmtx;
	u_int v, reg;
d118 2
a119 2
	dmtx = eframe[EF_DMT0];
	if (!ISSET(dmtx, DMT_VALID) || ISSET(dmtx, DMT_SKIP))
d122 6
a127 4
	for (x = 0; x < 3; x++) {
		dmtx = eframe[EF_DMT0 + x * 3];
		if (!ISSET(dmtx, DMT_VALID))
			continue;
d129 11
a139 2
		dmdx = eframe[EF_DMD0 + x * 3];
		dmax = eframe[EF_DMA0 + x * 3];
d156 2
a157 2
		dmax += dmt_en_info[DMT_ENBITS(dmtx)].offset;
		reg = DMT_DREGBITS(dmtx);
d159 2
a160 2
		if (!ISSET(dmtx, DMT_LOCKBAR)) {
			/* the fault is not during an XMEM */
d162 2
a163 2
			if (x == 2 && ISSET(dmtx, DMT_DOUB1)) {
				/* pipeline 2 (earliest stage) for a double */
d165 4
a168 15
				if (ISSET(dmtx, DMT_WRITE)) {
					/*
					 * STORE DOUBLE WILL BE REINITIATED
					 * BY rte
					 */
				} else {
					/* EMULATE ld.d INSTRUCTION */
					v = do_load_word(dmax, dmtx & DMT_DAS);
					if (reg != 0)
						eframe[EF_R0 + reg] = v;
					v = do_load_word(dmax ^ 4,
					    dmtx & DMT_DAS);
					if (reg != 31)
						eframe[EF_R0 + reg + 1] = v;
				}
d170 7
a176 60
				/* not pipeline #2 with a double */
				if (dmtx & DMT_WRITE) {
					switch (dmt_en_info[DMT_ENBITS(dmtx)].size) {
					case DMT_BYTE:
					DAE_DEBUG(
						printf("[byte %x -> [%x(%c)]\n",
						    dmdx & 0xff, dmax,
						    ISSET(dmtx, DMT_DAS) ? 's' : 'u')
					);
						do_store_byte(dmax, dmdx,
						    dmtx & DMT_DAS);
						break;
					case DMT_HALF:
					DAE_DEBUG(
						printf("[half %x -> [%x(%c)]\n",
						    dmdx & 0xffff, dmax,
						    ISSET(dmtx, DMT_DAS) ? 's' : 'u')
					);
						do_store_half(dmax, dmdx,
						    dmtx & DMT_DAS);
						break;
					case DMT_WORD:
					DAE_DEBUG(
						printf("[word %x -> [%x(%c)]\n",
						    dmdx, dmax,
						    ISSET(dmtx, DMT_DAS) ? 's' : 'u')
					);
						do_store_word(dmax, dmdx,
						    dmtx & DMT_DAS);
						break;
					}
				} else {
					/* else it's a read */
					switch (dmt_en_info[DMT_ENBITS(dmtx)].size) {
					case DMT_BYTE:
						v = do_load_byte(dmax,
						    dmtx & DMT_DAS);
						if (!ISSET(dmtx, DMT_SIGNED))
							v &= 0x000000ff;
						break;
					case DMT_HALF:
						v = do_load_half(dmax,
						    dmtx & DMT_DAS);
						if (!ISSET(dmtx, DMT_SIGNED))
							v &= 0x0000ffff;
						break;
					case DMT_WORD:
						v = do_load_word(dmax,
						    dmtx & DMT_DAS);
						break;
					}
					DAE_DEBUG(
						if (reg == 0)
							printf("[no write to r0 done]\n");
						else
							printf("[r%d <- %x]\n", reg, v);
					);
					if (reg != 0)
						eframe[EF_R0 + reg] = v;
				}
d179 19
a197 21
			/* if lockbar is set... it's part of an XMEM */
			/*
			 * According to Motorola's "General Information",
			 * the DMT_DOUB1 bit is never set in this case, as it
			 * should be.
			 * If lockbar is set (as it is if we're here) and if
			 * the write is not set, then it's the same as if DOUB1
			 * was set...
			 */
			if (!ISSET(dmtx, DMT_WRITE)) {
				if (x != 2) {
					/* RERUN xmem WITH DMD(x+1) */
					x++;
					dmdx = eframe[EF_DMD0 + x * 3];
				} else {
					/* RERUN xmem WITH DMD2 */
				}

				if (dmt_en_info[DMT_ENBITS(dmtx)].size ==
				    DMT_WORD) {
					v = do_xmem_word(dmax, dmdx,
d199 8
a206 2
				} else {
					v = do_xmem_byte(dmax, dmdx,
d208 1
d210 23
d234 18
a251 1
					eframe[EF_R0 + reg] = v;
d253 20
a272 10
				if (x == 0) {
					if (reg != 0)
						eframe[EF_R0 + reg] = dmdx;
					eframe[EF_SFIP] = eframe[EF_SNIP];
					eframe[EF_SNIP] = eframe[EF_SXIP];
					eframe[EF_SXIP] = 0;
					/* xmem RERUN ON rte */
					eframe[EF_DMT0] = 0;
					return;
				}
a275 1
	eframe[EF_DMT0] |= DMT_SKIP;
@


1.4
log
@Replace many ``unsigned'' variables with ``unsigned int'', ``u_int'' or other
appropriate types. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88100_machdep.c,v 1.3 2007/05/20 20:12:31 miod Exp $	*/
d107 1
a107 1
	if (!ISSET(dmtx, DMT_VALID))
d112 1
a112 1
		if (!ISSET(dmtx, DMT_VALID) || ISSET(dmtx, DMT_SKIP))
d262 1
a262 1
	eframe[EF_DMT0] = 0;
@


1.3
log
@Since we no longer use 3 bits but the whole 7 to get the processor revision
number, we should test for 10, not 2, as the revision for which the xxx.usr
errata applies; also, going through the errata, revision 2/10 (1010x) _is_
affected.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88100_machdep.c,v 1.2 2006/11/18 22:58:28 miod Exp $	*/
d68 1
a68 1
dae_print(unsigned *eframe)
d71 1
a71 1
	unsigned dmax, dmdx, dmtx;
d100 1
a100 1
data_access_emulation(unsigned *eframe)
d103 2
a104 2
	unsigned dmax, dmdx, dmtx;
	unsigned v, reg;
@


1.2
log
@On 88100 systems which do not need the xxx.usr instruction workaround,
override the DAE helper routines with workaroundless code while the kernel
text is still writable.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88100_machdep.c,v 1.1 2004/08/01 17:18:05 miod Exp $	*/
d274 1
a274 1
	if (((get_cpu_pid() & PID_VN) >> VN_SHIFT) >= 2) {
@


1.1
log
@Move 88100 DAE code to its own file, shared between luna88k and mvme88k.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d34 1
d38 1
a38 1
 *  data access emulation for M88100 exceptions
d263 31
@

