head	1.9;
access;
symbols
	OPENBSD_6_0:1.9.0.36
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.32
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.9.0.34
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.26
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.9.0.30
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.9.0.28
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.24
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.22
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.20
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.18
	OPENBSD_5_0:1.9.0.16
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.14
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.12
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.6
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.10
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.8
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.4
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.2
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.8.0.6
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.4
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.2
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.6.0.2
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.3.0.2
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.2.0.2
	OPENBSD_3_7_BASE:1.2
	OPENBSD_3_6:1.1.0.2
	OPENBSD_3_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.9
date	2007.10.27.20.31.19;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2006.05.04.19.32.21;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2006.05.03.18.14.52;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2005.12.02.20.01.33;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2005.11.20.22.04.12;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2005.09.06.19.30.32;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2005.05.15.14.12.22;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2004.09.30.21.48.56;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2004.06.19.18.28.37;	author miod;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Be more strict when disassembling {f,}{st,x}cr and [bt]cnd instructions,
and display incorrect opcode encodings as invalid opcodes.
@
text
@/*	$OpenBSD: db_disasm.c,v 1.8 2006/05/04 19:32:21 miod Exp $	*/
/*
 * Copyright (c) 2006, Miodrag Vallat
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
/*
 * Mach Operating System
 * Copyright (c) 1993-1991 Carnegie Mellon University
 * Copyright (c) 1991 OMRON Corporation
 * All Rights Reserved.
 *
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON AND OMRON ALLOW FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON AND OMRON DISCLAIM ANY LIABILITY OF ANY KIND
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

/*
 * m88k disassembler for use in ddb
 */

#include <sys/param.h>
#include <sys/systm.h>

#include <machine/db_machdep.h>

#include <ddb/db_sym.h>		/* DB_STGY_PROC, db_printsym() */
#include <ddb/db_access.h>	/* db_get_value() */
#include <ddb/db_output.h>	/* db_printf() */
#include <ddb/db_interface.h>

int	oimmed(int, u_int32_t, const char *, vaddr_t);
int	ctrlregs(int, u_int32_t, const char *, vaddr_t);
int	sindou(int, u_int32_t, const char *, vaddr_t);
int	jump(int, u_int32_t, const char *, vaddr_t);
int	instset(int, u_int32_t, const char *, vaddr_t);
int	obranch(int, u_int32_t, const char *, vaddr_t);
int	brcond(int, u_int32_t, const char *, vaddr_t);
int	otrap(int, u_int32_t, const char *, vaddr_t);
int	obit(int, u_int32_t, const char *, vaddr_t);
int	bitman(int, u_int32_t, const char *, vaddr_t);
int	immem(int, u_int32_t, const char *, vaddr_t);
int	nimmem(int, u_int32_t, const char *, vaddr_t);
int	lognim(int, u_int32_t, const char *, vaddr_t);
int	onimmed(int, u_int32_t, const char *, vaddr_t);
int	pinst(int, u_int32_t, const char *, vaddr_t);

void	printcmp(int, u_int);
void	symofset(u_int, u_int, vaddr_t);
const char *cregname(int, u_int, u_int);

/*
 * Common instruction modifiers
 */

static const char *instwidth[] = {
	".d", "  ", ".h", ".b", ".x"	/* see nimmem() for use of last value */
};
static const char *xinstwidth[4] = {
	".d", "  ", ".x", ".?"
};
static const char *cmpname[0x20] = {
	NULL,
	NULL,
	"eq",
	"ne",
	"gt",
	"le",
	"lt",
	"ge",
	"hi",
	"ls",
	"lo",
	"hs",
	"be",
	"nb",
	"he",
	"nh"
};
static const char *condname[0x20] = {
	NULL,
	"gt",	/* 00001 */
	"eq",	/* 00010 */
	"ge",	/* 00011 */
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	"lt",	/* 01100 */
	"ne",	/* 01101 */
	"le"	/* 01110 */
};
static const char sodname[4] = "sdx?";

/*
 * Descriptive control register names
 */

static const char *m88100_ctrlreg[2][64] = {
	{	/* main unit */
		"PID",
		"PSR",
		"EPSR",
		"SSBR",
		"SXIP",
		"SNIP",
		"SFIP",
		"VBR",
		"DMT0",
		"DMD0",
		"DMA0",
		"DMT1",
		"DMD1",
		"DMA1",
		"DMT2",
		"DMD2",
		"DMA2",
		"SR0",
		"SR1",
		"SR2",
		"SR3",
	},
	{	/* SFU1 = FPU */
		"FPECR",
		"FPHS1",
		"FPLS1",
		"FPHS2",
		"FPLS2",
		"FPPT",
		"FPRH",
		"FPRL",
		"FPIT",
		NULL, NULL,
		NULL, NULL, NULL, NULL, NULL,
		NULL, NULL, NULL, NULL, NULL,
		NULL, NULL, NULL, NULL, NULL,
		NULL, NULL, NULL, NULL, NULL,
		NULL, NULL, NULL, NULL, NULL,
		NULL, NULL, NULL, NULL, NULL,
		NULL, NULL, NULL, NULL, NULL,
		NULL, NULL, NULL, NULL, NULL,
		NULL, NULL, NULL, NULL, NULL,
		NULL, NULL, NULL, NULL, NULL,
		NULL,
		"FPSR",
		"FPCR"
	}
};

static const char *m88110_ctrlreg[2][64] = {
	{	/* main unit */
		"PID",
		"PSR",
		"EPSR",
		NULL,
		"EXIP",
		"ENIP",
		NULL,
		"VBR",
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		"RES1",
		"RES2",
		"SRX",
		"SR0",
		"SR1",
		"SR2",
		"SR3",
		NULL,
		NULL,
		NULL,
		NULL,
		"ICMD",
		"ICTL",
		"ISAR",
		"ISAP",
		"IUAP",
		"IIR",
		"IBP",
		"IPPU",
		"IPPL",
		"ISR",
		"ILAR",
		"IPAR",
		NULL,
		NULL,
		NULL,
		"DCMD",
		"DCTL",
		"DSAR",
		"DSAP",
		"DUAP",
		"DIR",
		"DBP",
		"DPPU",
		"DPPL",
		"DSR",
		"DLAR",
		"DPAR",
	},
	{	/* SFU1 = FPU */
		"FPECR",
		NULL, NULL, NULL, NULL, NULL,
		NULL, NULL, NULL, NULL, NULL,
		NULL, NULL, NULL, NULL, NULL,
		NULL, NULL, NULL, NULL, NULL,
		NULL, NULL, NULL, NULL, NULL,
		NULL, NULL, NULL, NULL, NULL,
		NULL, NULL, NULL, NULL, NULL,
		NULL, NULL, NULL, NULL, NULL,
		NULL, NULL, NULL, NULL, NULL,
		NULL, NULL, NULL, NULL, NULL,
		NULL, NULL, NULL, NULL, NULL,
		NULL, NULL, NULL, NULL, NULL,
		NULL,
		"FPSR",
		"FPCR"
	}
};

/* print a comparison code */		/* XXX favors cmp vs fcmp or pcmp */
void
printcmp(int cpu, u_int code)
{
	const char *cmp;

	if (cpu == CPU_88100 && code > 11)
		cmp = NULL;
	else
		cmp = cmpname[code];
	if (cmp != NULL)
		db_printf("%s(%d)", cmp, code);
	else
		db_printf("%d", code);
}

const char *
cregname(int cpu, u_int sfu, u_int regno)
{
	static char regbuf[20];
	const char *regname;

	switch (sfu) {
	case 0:	/* main unit */
	case 1:	/* SFU1 = FPU */
		regname = cpu != CPU_88100 ?
		    m88110_ctrlreg[sfu][regno] : m88100_ctrlreg[sfu][regno];
		if (regname == NULL)
			snprintf(regbuf, sizeof regbuf,
			    sfu == 0 ? "cr%d" : "fcr%d", regno);
		else
			snprintf(regbuf, sizeof regbuf,
			    sfu == 0 ? "cr%d (%s)" : "fcr%d (%s)",
			    regno, regname);
		break;
	default:	/* can't happen */
		snprintf(regbuf, sizeof regbuf, "sfu%dcr%d", sfu, regno);
		break;
	}

	return (regbuf);
}

void
symofset(u_int disp, u_int bit, vaddr_t iadr)
{
	vaddr_t addr;

	if (disp & (1 << (bit - 1))) {
		/* negative value */
		addr = iadr + ((disp << 2) | (~0U << bit));
	} else {
		addr = iadr + (disp << 2);
	}
	db_printsym(addr, DB_STGY_PROC, db_printf);
}

/* Handles immediate integer arithmetic instructions */
int
oimmed(int cpu, u_int32_t inst, const char *opcode, vaddr_t iadr)
{
	int32_t Linst = inst & 0xffff;
	u_int32_t H6inst = inst >> 26;
	u_int32_t rs1 = (inst >> 16) & 0x1f;
	u_int32_t rd = (inst >> 21) & 0x1f;

	switch (H6inst) {
	case 0x11:	/* and.u */
	case 0x13:	/* mask.u */
	case 0x15:	/* xor.u */
	case 0x17:	/* or.u */
		db_printf("\t%s.u", opcode);
		break;
	default:
		db_printf("\t%s  ", opcode);
		break;
	}
	db_printf("\t\tr%d, r%d, 0x%04x", rd, rs1, Linst);

	return (1);
}

/* Handles instructions dealing with control registers */
int
ctrlregs(int cpu, u_int32_t inst, const char *opcode, vaddr_t iadr)
{
	u_int32_t dir = (inst >> 14) & 0x03;
	u_int32_t sfu = (inst >> 11) & 0x07;
	u_int32_t creg = (inst >> 5) & 0x3f;
	u_int32_t rd = (inst >> 21) & 0x1f;
	u_int32_t rs1 = (inst >> 16) & 0x1f;
	u_int32_t rs2 = (inst >> 0) & 0x1f;

	/* s1 and s2 must match on {,f}{st,x}cr instructions */
	if (rs1 != rs2 && (dir == 0x02 || dir == 0x03))
		return (0);

	db_printf("\t%s\t\t", opcode);

	switch (dir) {
	case 0x01:	/* ldcr, fldcr */
		db_printf("r%d, %s", rd, cregname(cpu, sfu, creg));
		break;
	case 0x02:	/* stcr, fstcr */
		db_printf("r%d, %s", rs1, cregname(cpu, sfu, creg));
		break;
	default:
	case 0x03:	/* xcr, fxcr */
		db_printf("r%d, r%d, %s",
		    rd, rs1, cregname(cpu, sfu, creg));
		break;
	}

	return (1);
}

/* Handles floating point instructions */
int
sindou(int cpu, u_int32_t inst, const char *opcode, vaddr_t iadr)
{
	u_int32_t rs2 = inst & 0x1f;
	u_int32_t td = (inst >> 5) & 0x03;
	u_int32_t t2 = (inst >> 7) & 0x03;
	u_int32_t t1 = (inst >> 9) & 0x03;
	u_int32_t rs1 = (inst >> 16) & 0x1f;
	u_int32_t rd = (inst >> 21) & 0x1f;
	u_int32_t checkbits = (inst >> 11) & 0x0f;
	u_int32_t rf = (inst >> 15) & 0x01;

	/* do not display a specific fcmpu.s encoding as non-existing fcmpu.d */
	if (checkbits == 0x07)
		td = 0;

	/* do not display dot modifiers for mov.x */
	if (checkbits == 0x08) {
		db_printf("\t%s", opcode);
	} else {
		db_printf("\t%s.%c", opcode, sodname[td]);
	}

	switch (checkbits) {
	default:
	case 0x00:	/* fmul */
	case 0x05:	/* fadd */
	case 0x06:	/* fsub */
	case 0x0e:	/* fdiv */
		db_printf("%c%c\t\t", sodname[t1], sodname[t2]);
		if (rf != 0)
			db_printf("x%d,x%d,x%d", rd, rs1, rs2);
		else
			db_printf("r%d,r%d,r%d", rd, rs1, rs2);
		break;
	case 0x01:	/* fcvt */
	case 0x0f:	/* fsqrt */
		db_printf("%c \t\t", sodname[t2]);
		if (rf != 0)
			db_printf("x%d, x%d", rd, rs2);
		else
			db_printf("r%d, r%d", rd, rs2);
		break;
	case 0x04:	/* flt */
		db_printf("%c \t\t", sodname[t2]);
		if ((inst & 0x200) != 0)	/* does not use the RF bit... */
			db_printf("x%d, x%d", rd, rs2);
		else
			db_printf("r%d, r%d", rd, rs2);
		break;
	case 0x07:	/* fcmp, fcmpu */
		db_printf("%c%c\t\t", sodname[t1], sodname[t2]);
		db_printf("r%d, ", rd);
		if (rf != 0)
			db_printf("x%d, x%d", rs1, rs2);
		else
			db_printf("r%d, r%d", rs1, rs2);
		break;
	case 0x08:	/* mov */
		if (rf != 0 && t1 == 0x01) {	/* mov.x, displayed as mov */
			db_printf("   \t\t");
			db_printf("x%d, x%d", rd, rs2);
		} else {
			db_printf(".%c \t\t", sodname[t2]);

			if (t1 == 0)
				db_printf("r%d, x%d", rd, rs2);
			else
				db_printf("x%d, r%d", rd, rs2);
		}
		break;
	case 0x09:	/* int */
	case 0x0a:	/* nint */
	case 0x0b:	/* trnc */
		db_printf("%c \t\t", sodname[t2]);
		if (rf != 0)
			db_printf("r%d, x%d", rd, rs2);
		else
			db_printf("r%d, r%d", rd, rs2);
		break;
	}

	return (1);
}

int
jump(int cpu, u_int32_t inst, const char *opcode, vaddr_t iadr)
{
	u_int32_t rs2 = inst & 0x1f;

	db_printf("\t%s", opcode);
	if ((inst & (1 << 10)) != 0)
		db_printf(".n");
	else
		db_printf("  ");
	db_printf("\t\tr%d", rs2);

	return (1);
}

/* Handles ff1, ff0, tbnd and rte instructions */
int
instset(int cpu, u_int32_t inst, const char *opcode, vaddr_t iadr)
{
	u_int32_t rs2 = inst & 0x1f;
	u_int32_t rs1 = (inst >> 16) & 0x1f;
	u_int32_t rd = (inst >> 21) & 0x1f;
	u_int32_t checkbits = (inst >> 10) & 0x3f;
	u_int32_t H6inst = (inst >> 26) & 0x3f;

	db_printf("\t%s", opcode);
	if (H6inst == 0x3e) { /* tbnd with imm16 */
		db_printf("\t\tr%d, 0x%04x", rs1, inst & 0xffff);
	} else {
		switch (checkbits) {
		case 0x3a:	/* ff1 */
		case 0x3b:	/* ff0 */
			db_printf("\t\tr%d,r%d", rd, rs2);
			break;
		case 0x3e:	/* tbnd */
			db_printf("\t\tr%d,r%d", rs1, rs2);
			break;
		case 0x3f:	/* rte, illop */
			if (rs2 != 0)
				db_printf("%d", rs2);
			break;
		}
	}

	return (1);
}

/* Handles unconditionnal branches */
int
obranch(int cpu, u_int32_t inst, const char *opcode, vaddr_t iadr)
{
	u_int32_t disp = inst & 0x3ffffff;

	db_printf("\t%s", opcode);
	if ((inst & (1 << 26)) != 0)
		db_printf(".n");
	else
		db_printf("  ");
	db_printf("\t\t");
	symofset(disp, 26, iadr);

	return (1);
}

/* Handles branch on conditions instructions */
int
brcond(int cpu, u_int32_t inst, const char *opcode, vaddr_t iadr)
{
	u_int32_t match = (inst >> 21) & 0x1f;
	u_int32_t rs = (inst >> 16) & 0x1f;
	u_int32_t disp = inst & 0xffff;
	int bcnd = ((inst >> 27) & 0x03) == 1;

	/* skip invalid conditions if bcnd */
	if (bcnd && condname[match] == NULL)
		return (0);

	db_printf("\t%s", opcode);
	if ((inst & (1 << 26)) != 0)
		db_printf(".n");
	else
		db_printf("  ");
	db_printf("\t\t");

	if (bcnd)
		db_printf("%s0", condname[match]);
	else
		printcmp(cpu, match);

	db_printf(", r%d, ", rs);
	symofset(disp, 16, iadr);

	return (1);
}

/* Handles trap instructions */
int
otrap(int cpu, u_int32_t inst, const char *opcode, vaddr_t iadr)
{
	u_int32_t vecno = inst & 0x1ff;
	u_int32_t match = (inst >> 21) & 0x1f;
	u_int32_t rs = (inst >> 16) & 0x1f;
	int tcnd = ((inst >> 12) & 0x0f) == 0xe;

	/* skip invalid conditions if tcnd */
	if (tcnd && condname[match] == NULL)
		return (0);

	db_printf("\t%s\t", opcode);
	if (tcnd)
		db_printf("%s0", condname[match]);
	else
		printcmp(cpu, match);
	db_printf(", r%d, 0x%x", rs, vecno);

	return (1);
}

/* Handles 10 bit immediate bit field operations */
int
obit(int cpu, u_int32_t inst, const char *opcode, vaddr_t iadr)
{
	u_int32_t rs = (inst >> 16) & 0x1f;
	u_int32_t rd = (inst >> 21) & 0x1f;
	u_int32_t width = (inst >> 5) & 0x1f;
	u_int32_t offset = inst & 0x1f;

	db_printf("\t%s\t\tr%d, r%d, ", opcode, rd, rs);
	if (((inst >> 10) & 0x3f) != 0x2a)	/* rot */
		db_printf("%d", width);
	db_printf("<%d>", offset);

	return (1);
}

/* Handles triadic mode bit field instructions */
int
bitman(int cpu, u_int32_t inst, const char *opcode, vaddr_t iadr)
{
	u_int32_t rs1 = (inst >> 16) & 0x1f;
	u_int32_t rd = (inst >> 21) & 0x1f;
	u_int32_t rs2 = inst & 0x1f;

	db_printf("\t%s\t\tr%d, r%d, r%d", opcode, rd, rs1, rs2);

	return (1);
}

/* Handles immediate load/store/exchange instructions */
int
immem(int cpu, u_int32_t inst, const char *opcode, vaddr_t iadr)
{
	u_int32_t rd = (inst >> 21) & 0x1f;
	u_int32_t rs = (inst >> 16) & 0x1f;
	u_int32_t st_lda = (inst >> 28) & 0x03;
	u_int32_t aryno = (inst >> 26) & 0x03;
	int rf = 0;
	char c = ' ';

	switch (st_lda) {
	case 0x00:
		if ((aryno & 0x02) != 0) {	/* 0x02, 0x03: ld.hu, ld.bu */
			opcode = "ld";
			c = 'u';
		} else {
			if (cpu == CPU_88100) {
				opcode = "xmem";
				if (aryno == 0) {	/* xmem.bu */
					aryno = 3;
					c = 'u';
				}
			} else {
				/* opcode = "ld"; */
				rf = 1;
			}
		}
		break;

	case 0x03:
		if (cpu != CPU_88100) {
			rf = 1;
			switch (st_lda) {
			case 0x00:		/* ld.x */
				aryno = 2;
				break;
			case 0x03:		/* st, st.d, st.x */
				break;
			}
		}
		break;
	}

	db_printf("\t%s%s%c\t\t", opcode,
	    rf != 0 ? xinstwidth[aryno] : instwidth[aryno], c);
	if (rf != 0)
		db_printf("x%d, r%d, ", rd, rs);
	else
		db_printf("r%d, r%d, ", rd, rs);
	db_printf("0x%x", inst & 0xffff);

	return (1);
}

/* Handles triadic mode load/store/exchange instructions */
int
nimmem(int cpu, u_int32_t inst, const char *opcode, vaddr_t iadr)
{
	u_int32_t scaled = (inst >> 9) & 0x01;
	u_int32_t rd = (inst >> 21) & 0x1f;
	u_int32_t rs1 = (inst >> 16) & 0x1f;
	u_int32_t rs2 = inst & 0x1f;
	u_int32_t st_lda = (inst >> 12) & 0x03;
	u_int32_t aryno = (inst >> 10) & 0x03;
	char c = ' ';
	int rf = 0, wt = 0, usr = 0;

	switch (st_lda) {
	case 0x00:
		switch (aryno) {
		case 0x00:			/* xmem.bu */
			aryno = 3;
			c = 'u';
			/* FALLTHROUGH */
		case 0x01:			/* xmem */
			opcode = "xmem";
			break;
		default:
		case 0x02:			/* ld.hu */
		case 0x03:			/* ld.bu */
			opcode = "ld";
			c = 'u';
			break;
		}
		break;
	case 0x01:
		opcode = "ld";
		if (cpu != CPU_88100) {
			if ((inst & (1 << 26)) == 0)
				rf = 1;
		}
		break;
	case 0x02:	/* st */
		if (cpu != CPU_88100) {
			if ((inst & (1 << 26)) == 0)
				rf = 1;
			if ((inst & (1 << 7)) != 0)
				wt = 1;
		}
		break;
	case 0x03:
		if (cpu != CPU_88100) {
			/* cheat instwidth for lda.x */
			if (aryno == 3)
				aryno = 4;
		}
		break;
	}

	if (st_lda != 0x03 && (inst & (1 << 8)) != 0)
		usr = 1;

	db_printf("\t%s%s%c%s%s\t",
	    opcode, rf != 0 ? xinstwidth[aryno] : instwidth[aryno], c,
	    usr != 0 ? ".usr" : "    ", wt != 0 ? ".wt" : "   ");
	if (rf != 0)
		db_printf("x%d, r%d", rd, rs1);
	else
		db_printf("r%d, r%d", rd, rs1);

	if (scaled != 0)
		db_printf("[r%d]", rs2);
	else
		db_printf(", r%d", rs2);

	return (1);
}

/* Handles triadic mode logical instructions */
int
lognim(int cpu, u_int32_t inst, const char *opcode, vaddr_t iadr)
{
	u_int32_t rd = (inst >> 21) & 0x1f;
	u_int32_t rs1 = (inst >> 16) & 0x1f;
	u_int32_t rs2 = inst & 0x1f;

	db_printf("\t%s", opcode);
	if ((inst & (1 << 10)) != 0)
		db_printf(".c");

	db_printf("\t\tr%d, r%d, r%d", rd, rs1, rs2);

	return (1);
}

/* Handles triadic mode arithmetic instructions */
int
onimmed(int cpu, u_int32_t inst, const char *opcode, vaddr_t iadr)
{
	u_int32_t rd = (inst >> 21) & 0x1f;
	u_int32_t rs1 = (inst >> 16) & 0x1f;
	u_int32_t rs2 = inst & 0x1f;
	u_int32_t carry = (inst >> 8) & 0x03;

	db_printf("\t%s", opcode);

	if ((inst & (1 << 11)) == 0) {
		switch (carry) {
		case 0x01:
			db_printf(".co");
			break;
		case 0x02:
			db_printf(".ci");
			break;
		case 0x03:
			db_printf(".cio");
			break;
		}
	} else {
		if (cpu != CPU_88100 && carry == 0x01)
			db_printf(".d");
	}

	db_printf("\tr%d, r%d, r%d", rd, rs1, rs2);

	return (1);
}

/* Handles 88110 SFU2 instructions */
int
pinst(int cpu, u_int32_t inst, const char *opcode, vaddr_t iadr)
{
	u_int32_t rd = (inst >> 21) & 0x1f;
	u_int32_t rs1 = (inst >> 16) & 0x1f;
	u_int32_t rs2 = inst & 0x1f;
	u_int32_t tfield = (inst >> 5) & 0x03;
	u_int32_t pfunc = (inst >> 11) & 0x1f;
	const char *saturation[] = { NULL, ".u", ".us", ".s" };

	db_printf("\t%s", opcode);

	switch (pfunc) {
	case 0x0c:	/* ppack */
		db_printf(".%d", (inst >> 5) & 0x3c);
		break;
	case 0x0e:	/* prot */
		break;
	default:	/* other instructions have an S field or zero */
	    {
		u_int32_t sfield = (inst >> 7) & 0x03;

		if (sfield != 0)
			db_printf("%s", saturation[sfield]);
	    }
		break;
	}

	if (tfield != 0 || pfunc == 0x0d /* punpk */) {
		if (tfield != 3)
			db_printf(".%c", "nbh"[tfield]);
	}

	switch (pfunc) {
	case 0x0d:	/* punpk */
		db_printf("\tr%d, r%d", rd, rs1);
		break;
	case 0x0e:	/* prot with immediate */
		db_printf("\tr%d, r%d, %d", rd, rs1, (inst >> 5) & 0x3f);
		break;
	default:
		db_printf("\tr%d, r%d, r%d", rd, rs1, rs2);
		break;
	}

	return (1);
}

static const struct opdesc {
	u_int32_t mask, match;
	int (*opfun)(int, u_int32_t, const char *, vaddr_t);
	const char *opcode;
} opdecode_88100[] = {
	/* ORDER IS IMPORTANT BELOW */
	{ 0xf0000000,	0x00000000,	immem,		NULL },	/* xmem/ld */
	{ 0xf0000000,	0x10000000,	immem,		"ld" },
	{ 0xf0000000,	0x20000000,	immem,		"st" },
	{ 0xf0000000,	0x30000000,	immem,		"lda" },

	{ 0xf8000000,	0x40000000,	oimmed,		"and" },
	{ 0xf8000000,	0x48000000,	oimmed,		"mask" },
	{ 0xf8000000,	0x50000000,	oimmed,		"xor" },
	{ 0xf8000000,	0x58000000,	oimmed,		"or" },
	{ 0xfc000000,	0x60000000,	oimmed,		"addu" },
	{ 0xfc000000,	0x64000000,	oimmed,		"subu" },
	{ 0xfc000000,	0x68000000,	oimmed,		"divu" },
	{ 0xfc000000,	0x6c000000,	oimmed,		"mul" },
	{ 0xfc000000,	0x70000000,	oimmed,		"add" },
	{ 0xfc000000,	0x74000000,	oimmed,		"sub" },
	{ 0xfc000000,	0x78000000,	oimmed,		"div" },
	{ 0xfc000000,	0x7c000000,	oimmed,		"cmp" },

	{ 0xfc00f800,	0x80004000,	ctrlregs,	"ldcr" },
	{ 0xfc00f800,	0x80004800,	ctrlregs,	"fldcr" },
	{ 0xfc00f800,	0x80008000,	ctrlregs,	"stcr" },
	{ 0xfc00f800,	0x80008800,	ctrlregs,	"fstcr" },
	{ 0xfc00f800,	0x8000c000,	ctrlregs,	"xcr" },
	{ 0xfc00f800,	0x8000c800,	ctrlregs,	"fxcr" },

	{ 0xfc00f800,	0x84000000,	sindou,		"fmul" },
	{ 0xfc1fff80,	0x84002000,	sindou,		"flt" },
	{ 0xfc00f800,	0x84002800,	sindou,		"fadd" },
	{ 0xfc00f800,	0x84003000,	sindou,		"fsub" },
	{ 0xfc00f860,	0x84003800,	sindou,		"fcmp" },
	{ 0xfc1ffe60,	0x84004800,	sindou,		"int" },
	{ 0xfc1ffe60,	0x84005000,	sindou,		"nint" },
	{ 0xfc1ffe60,	0x84005800,	sindou,		"trnc" },
	{ 0xfc00f800,	0x84007000,	sindou,		"fdiv" },

	{ 0xf8000000,	0xc0000000,	obranch,	"br" },
	{ 0xf8000000,	0xc8000000,	obranch,	"bsr" },

	{ 0xf8000000,	0xd0000000,	brcond,		"bb0" },
	{ 0xf8000000,	0xd8000000,	brcond,		"bb1" },
	{ 0xf8000000,	0xe8000000,	brcond,		"bcnd" },

	{ 0xfc00fc00,	0xf0008000,	obit,		"clr" },
	{ 0xfc00fc00,	0xf0008800,	obit,		"set" },
	{ 0xfc00fc00,	0xf0009000,	obit,		"ext" },
	{ 0xfc00fc00,	0xf0009800,	obit,		"extu" },
	{ 0xfc00fc00,	0xf000a000,	obit,		"mak" },
	{ 0xfc00fc00,	0xf000a800,	obit,		"rot" },

	{ 0xfc00fe00,	0xf000d000,	otrap,		"tb0" },
	{ 0xfc00fe00,	0xf000d800,	otrap,		"tb1" },
	{ 0xfc00fe00,	0xf000e800,	otrap,		"tcnd" },

	{ 0xfc00f0e0,	0xf4000000,	nimmem,		NULL },	/* xmem/ld */
	{ 0xfc00f0e0,	0xf4001000,	nimmem,		"ld" },
	{ 0xfc00f0e0,	0xf4002000,	nimmem,		"st" },
	{ 0xfc00f0e0,	0xf4003000,	nimmem,		"lda" },

	{ 0xfc00fbe0,	0xf4004000,	lognim,		"and" },
	{ 0xfc00fbe0,	0xf4005000,	lognim,		"xor" },
	{ 0xfc00fbe0,	0xf4005800,	lognim,		"or" },

	{ 0xfc00fce0,	0xf4006000,	onimmed,	"addu" },
	{ 0xfc00fce0,	0xf4006400,	onimmed,	"subu" },
	{ 0xfc00fce0,	0xf4006800,	onimmed,	"divu" },
	{ 0xfc00fce0,	0xf4006c00,	onimmed,	"mul" },
	{ 0xfc00fce0,	0xf4007000,	onimmed,	"add" },
	{ 0xfc00fce0,	0xf4007400,	onimmed,	"sub" },
	{ 0xfc00fce0,	0xf4007800,	onimmed,	"div" },
	{ 0xfc00fce0,	0xf4007c00,	onimmed,	"cmp" },

	{ 0xfc00ffe0,	0xf4008000,	bitman,		"clr" },
	{ 0xfc00ffe0,	0xf4008800,	bitman,		"set" },
	{ 0xfc00ffe0,	0xf4009000,	bitman,		"ext" },
	{ 0xfc00ffe0,	0xf4009800,	bitman,		"extu" },
	{ 0xfc00ffe0,	0xf400a000,	bitman,		"mak" },
	{ 0xfc00ffe0,	0xf400a800,	bitman,		"rot" },

	{ 0xfc00fbe0,	0xf400c000,	jump,		"jmp" },
	{ 0xfc00fbe0,	0xf400c800,	jump,		"jsr" },

	{ 0xfc00ffe0,	0xf400e800,	instset,	"ff1" },
	{ 0xfc00ffe0,	0xf400ec00,	instset,	"ff0" },
	{ 0xfc00ffe0,	0xf400f800,	instset,	"tbnd" },
	{ 0xfc00ffe0,	0xf400fc00,	instset,	"rte" },
	{ 0xfc000000,	0xf8000000,	instset,	"tbnd" },
	{ 0,		0,		NULL,		NULL }
}, opdecode_88110[] = {
	/* ORDER IS IMPORTANT BELOW */
	{ 0xe0000000,	0x00000000,	immem,		"ld" },
	{ 0xf0000000,	0x20000000,	immem,		"st" },
	{ 0xfc000000,	0x3c000000,	immem,		"ld" },
	{ 0xf0000000,	0x30000000,	immem,		"st" },

	{ 0xf8000000,	0x40000000,	oimmed,		"and" },
	{ 0xf8000000,	0x48000000,	oimmed,		"mask" },
	{ 0xf8000000,	0x50000000,	oimmed,		"xor" },
	{ 0xf8000000,	0x58000000,	oimmed,		"or" },
	{ 0xfc000000,	0x60000000,	oimmed,		"addu" },
	{ 0xfc000000,	0x64000000,	oimmed,		"subu" },
	{ 0xfc000000,	0x68000000,	oimmed,		"divu" },
	{ 0xfc000000,	0x6c000000,	oimmed,		"mulu" },
	{ 0xfc000000,	0x70000000,	oimmed,		"add" },
	{ 0xfc000000,	0x74000000,	oimmed,		"sub" },
	{ 0xfc000000,	0x78000000,	oimmed,		"divs" },
	{ 0xfc000000,	0x7c000000,	oimmed,		"cmp" },

	{ 0xfc1ff81f,	0x80004000,	ctrlregs,	"ldcr" },
	{ 0xfc1ff81f,	0x80004800,	ctrlregs,	"fldcr" },
	{ 0xffe0f800,	0x80008000,	ctrlregs,	"stcr" },
	{ 0xffe0f800,	0x80008800,	ctrlregs,	"fstcr" },
	{ 0xfc00f800,	0x8000c000,	ctrlregs,	"xcr" },
	{ 0xfc00f800,	0x8000c800,	ctrlregs,	"fxcr" },

	{ 0xfc007800,	0x84000000,	sindou,		"fmul" },
	{ 0xfc1f7e00,	0x84000800,	sindou,		"fcvt" },
	{ 0xfc1ffd80,	0x84002000,	sindou,		"flt" },
	{ 0xfc007800,	0x84002800,	sindou,		"fadd" },
	{ 0xfc007800,	0x84003000,	sindou,		"fsub" },
	{ 0xfc007860,	0x84003800,	sindou,		"fcmp" },
	{ 0xfc007860,	0x84003820,	sindou,		"fcmpu" },
	{ 0xfc1ffe60,	0x8400c000,	sindou,		"mov" },
	{ 0xfc17fe60,	0x84004200,	sindou,		"mov" },
	{ 0xfc1f7e60,	0x84004800,	sindou,		"int" },
	{ 0xfc1f7e60,	0x84005000,	sindou,		"nint" },
	{ 0xfc1f7e60,	0x84005800,	sindou,		"trnc" },
	{ 0xfc007800,	0x84007000,	sindou,		"fdiv" },
	{ 0xfc1f7e00,	0x84007800,	sindou,		"fsqrt" },

	{ 0xfc00ffe0,	0x88000000,	pinst,		"pmul" },
	{ 0xfc00ff80,	0x88002000,	pinst,		"padd" },
	{ 0xfc00fe00,	0x88002000,	pinst,		"padds" },
	{ 0xfc00ff80,	0x88003000,	pinst,		"psub" },
	{ 0xfc00fe00,	0x88003000,	pinst,		"psubs" },
	{ 0xfc00ffe0,	0x88003860,	pinst,		"pcmp" },
	{ 0xfc00f800,	0x88006000,	pinst,		"ppack" },
	{ 0xfc00ff9f,	0x88006800,	pinst,		"punpk" },
	{ 0xfc00f87f,	0x88007000,	pinst,		"prot" },
	{ 0xfc00ffe0,	0x88007800,	pinst,		"prot" },

	{ 0xf8000000,	0xc0000000,	obranch,	"br" },
	{ 0xf8000000,	0xc8000000,	obranch,	"bsr" },

	{ 0xf8000000,	0xd0000000,	brcond,		"bb0" },
	{ 0xf8000000,	0xd8000000,	brcond,		"bb1" },
	{ 0xf8000000,	0xe8000000,	brcond,		"bcnd" },

	{ 0xfc00fc00,	0xf0008000,	obit,		"clr" },
	{ 0xfc00fc00,	0xf0008800,	obit,		"set" },
	{ 0xfc00fc00,	0xf0009000,	obit,		"ext" },
	{ 0xfc00fc00,	0xf0009800,	obit,		"extu" },
	{ 0xfc00fc00,	0xf000a000,	obit,		"mak" },
	{ 0xfc00ffe0,	0xf000a800,	obit,		"rot" },

	{ 0xfc00fe00,	0xf000d000,	otrap,		"tb0" },
	{ 0xfc00fe00,	0xf000d800,	otrap,		"tb1" },
	{ 0xfc00fe00,	0xf000e800,	otrap,		"tcnd" },

	{ 0xfc00f0e0,	0xf4000000,	nimmem,		NULL },	/* ld/xmem */
	{ 0xf800f0e0,	0xf0001000,	nimmem,		"ld" },
	{ 0xf800f060,	0xf0002000,	nimmem,		"st" },
	{ 0xfc00f2e0,	0xf4003200,	nimmem,		"lda" },

	{ 0xfc00fbe0,	0xf4004000,	lognim,		"and" },
	{ 0xfc00fbe0,	0xf4005000,	lognim,		"xor" },
	{ 0xfc00fbe0,	0xf4005800,	lognim,		"or" },

	{ 0xfc00fce0,	0xf4006000,	onimmed,	"addu" },
	{ 0xfc00fce0,	0xf4006400,	onimmed,	"subu" },
	{ 0xfc00fee0,	0xf4006800,	onimmed,	"divu" },
	{ 0xfc00fee0,	0xf4006c00,	onimmed,	"mulu" },
	{ 0xfc00ffe0,	0xf4006e00,	onimmed,	"muls" },
	{ 0xfc00fce0,	0xf4007000,	onimmed,	"add" },
	{ 0xfc00fce0,	0xf4007400,	onimmed,	"sub" },
	{ 0xfc00ffe0,	0xf4007800,	onimmed,	"divs" },
	{ 0xfc00ffe0,	0xf4007c00,	onimmed,	"cmp" },

	{ 0xfc00ffe0,	0xf4008000,	bitman,		"clr" },
	{ 0xfc00ffe0,	0xf4008800,	bitman,		"set" },
	{ 0xfc00ffe0,	0xf4009000,	bitman,		"ext" },
	{ 0xfc00ffe0,	0xf4009800,	bitman,		"extu" },
	{ 0xfc00ffe0,	0xf400a000,	bitman,		"mak" },
	{ 0xfc00ffe0,	0xf400a800,	bitman,		"rot" },

	{ 0xfffffbe0,	0xf400c000,	jump,		"jmp" },
	{ 0xfffffbe0,	0xf400c800,	jump,		"jsr" },

	{ 0xfc1fffe0,	0xf400e800,	instset,	"ff1" },
	{ 0xfc1fffe0,	0xf400ec00,	instset,	"ff0" },
	{ 0xffe0ffe0,	0xf400f800,	instset,	"tbnd" },
	{ 0xffffffff,	0xf400fc00,	instset,	"rte" },
	{ 0xfffffffc,	0xf400fc00,	instset,	"illop" },
	{ 0xffe00000,	0xf8000000,	instset,	"tbnd" },
	{ 0,		0,		NULL,		NULL }
};

void
m88k_print_instruction(int cpu, u_int iadr, u_int32_t inst)
{
	const struct opdesc *p;

	/*
	 * This messes up "or.b" instructions ever so slightly,
	 * but keeps us in sync between routines...
	 */
	if (inst == 0) {
		db_printf("\t.word\t0\n");
	} else {
		p = cpu != CPU_88100 ? opdecode_88110 : opdecode_88100;
		while (p->mask != 0) {
			if ((inst & p->mask) == p->match) {
				if ((*p->opfun)(cpu, inst, p->opcode, iadr)) {
					db_printf("\n");
					return;
				}
				break;
			}
			p++;
		}
		db_printf("\t.word\t0x%x\n", inst);
	}
}

db_addr_t
db_disasm(db_addr_t loc, boolean_t altfmt)
{
	int cpu;

	if (altfmt)
		cpu = CPU_IS88100 ? CPU_88110 : CPU_88100;
	else
		cpu = cputyp;

	m88k_print_instruction(cpu, loc, db_get_value(loc, 4, FALSE));
	return (loc + 4);
}
@


1.8
log
@Even better control register name display logic.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.7 2006/05/03 18:14:52 miod Exp $	*/
d67 15
a81 15
void	oimmed(int, u_int32_t, const char *, vaddr_t);
void	ctrlregs(int, u_int32_t, const char *, vaddr_t);
void	sindou(int, u_int32_t, const char *, vaddr_t);
void	jump(int, u_int32_t, const char *, vaddr_t);
void	instset(int, u_int32_t, const char *, vaddr_t);
void	obranch(int, u_int32_t, const char *, vaddr_t);
void	brcond(int, u_int32_t, const char *, vaddr_t);
void	otrap(int, u_int32_t, const char *, vaddr_t);
void	obit(int, u_int32_t, const char *, vaddr_t);
void	bitman(int, u_int32_t, const char *, vaddr_t);
void	immem(int, u_int32_t, const char *, vaddr_t);
void	nimmem(int, u_int32_t, const char *, vaddr_t);
void	lognim(int, u_int32_t, const char *, vaddr_t);
void	onimmed(int, u_int32_t, const char *, vaddr_t);
void	pinst(int, u_int32_t, const char *, vaddr_t);
a83 1
void	printcond(u_int);
d97 1
a97 1
static const char *cmpname[] = {
d115 1
a115 1
static const char *condname[0x1f] = {
a279 13
/* print a condition mnemnonic */
void
printcond(u_int match)
{
	const char *cond;

	cond = condname[match];
	if (cond != NULL)
		db_printf("%s0", cond);
	else
		db_printf("%d", match);
}

d322 1
a322 1
void
d342 2
d347 1
a347 1
void
d355 5
d376 2
d381 1
a381 1
void
d462 2
d466 1
a466 1
void
d477 2
d482 1
a482 1
void
d509 2
d514 1
a514 1
void
d526 2
d531 1
a531 1
void
d537 5
d550 2
a551 2
	if (((inst >> 27) & 0x03) == 1)	/* bcnd */
		printcond(match);
d557 2
d562 1
a562 1
void
d568 5
d575 2
a576 2
	if (((inst >> 12) & 0x0f) == 0xe)	/* tcnd */
		printcond(match);
d580 2
d585 1
a585 1
void
d597 2
d602 1
a602 1
void
d610 2
d615 1
a615 1
void
d665 2
d670 1
a670 1
void
d739 2
d744 1
a744 1
void
d756 2
d761 1
a761 1
void
d789 2
d794 1
a794 1
void
d838 2
d844 1
a844 1
	void (*opfun)(int, u_int32_t, const char *, vaddr_t);
d1059 5
a1063 3
				(*p->opfun)(cpu, inst, p->opcode, iadr);
				db_printf("\n");
				return;
@


1.7
log
@Overhaul of the disassembler code, with random fixes, better conditionnal
branches decoding, correct control register descriptions, and (the reason
for these changes in the first place) 88110 instruction support.

ddb will now disassemble by default for the processor it is running for,
and using the alternate format (x/I) disassembles for the other.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.6 2005/12/02 20:01:33 miod Exp $	*/
d141 21
a161 21
		"cr0 #PID",
		"cr1 #PSR",
		"cr2 #EPSR",
		"cr3 #SSBR",
		"cr4 #SXIP",
		"cr5 #SNIP",
		"cr6 #SFIP",
		"cr7 #VBR",
		"cr8 #DMT0",
		"cr9 #DMD0",
		"cr10 #DMA0",
		"cr11 #DMT1",
		"cr12 #DMD1",
		"cr13 #DMA1",
		"cr14 #DMT2",
		"cr15 #DMD2",
		"cr16 #DMA2",
		"cr17 #SR0",
		"cr18 #SR1",
		"cr19 #SR2",
		"cr20 #SR3",
d164 9
a172 9
		"fcr0 #FPECR",
		"fcr1 #FPHS1",
		"fcr2 #FPLS1",
		"fcr3 #FPHS2",
		"fcr4 #FPLS2",
		"fcr5 #FPPT",
		"fcr6 #FPRH",
		"fcr7 #FPRL",
		"fcr8 #FPIT",
d185 2
a186 2
		"fcr62 #FPSR",
		"fcr63 #FPCR"
d192 3
a194 3
		"cr0 #PID",
		"cr1 #PSR",
		"cr2 #EPSR",
d196 2
a197 2
		"cr4 #EXIP",
		"cr5 #ENIP",
d199 1
a199 1
		"cr7 #VBR",
d206 7
a212 7
		"cr14 #RES1",
		"cr15 #RES2",
		"cr16 #SRX",
		"cr17 #SR0",
		"cr18 #SR1",
		"cr19 #SR2",
		"cr20 #SR3",
d217 12
a228 12
		"cr25 #ICMD",
		"cr26 #ICTL",
		"cr27 #ISAR",
		"cr28 #ISAP",
		"cr29 #IUAP",
		"cr30 #IIR",
		"cr31 #IBP",
		"cr32 #IPPU",
		"cr33 #IPPL",
		"cr34 #ISR",
		"cr35 #ILAR",
		"cr36 #IPAR",
d232 12
a243 12
		"cr40 #DCMD",
		"cr41 #DCTL",
		"cr42 #DSAR",
		"cr43 #DSAP",
		"cr44 #DUAP",
		"cr45 #DIR",
		"cr46 #DBP",
		"cr47 #DPPU",
		"cr48 #DPPL",
		"cr49 #DSR",
		"cr50 #DLAR",
		"cr51 #DPAR",
d246 1
a246 1
		"fcr0 #FPECR",
d260 2
a261 2
		"fcr62 #FPSR",
		"fcr63 #FPCR"
d265 1
a265 1
/* print a comparison code */
d297 1
a297 1
	static char unnamed[20];
d305 2
a306 2
		if (regname == NULL) {
			snprintf(unnamed, sizeof unnamed,
d308 4
a311 2
			regname = unnamed;
		}
d314 1
a314 3
		snprintf(unnamed, sizeof unnamed,
		    "sfu%dcr%d", sfu, regno);
		regname = unnamed;
d318 1
a318 1
	return (regname);
@


1.6
log
@Fix a few instruction display glitches.
@
text
@d1 25
a25 1
/*	$OpenBSD: db_disasm.c,v 1.5 2005/11/20 22:04:12 miod Exp $	*/
d58 1
a58 1
#include <sys/types.h>
d67 24
a90 3
static const char *instwidth[4] = {
	".d", "  ", ".h", ".b"
};
d92 2
a93 2
static const char *condname[6] = {
	"gt0 ", "eq0 ", "ge0 ", "lt0 ", "ne0 ", "le0 "
d95 2
a96 39

#ifdef M88100
static const char *m88100_ctrlreg[64] = {
	"cr0(PID)   ",
	"cr1(PSR)   ",
	"cr2(EPSR)  ",
	"cr3(SSBR)  ",
	"cr4(SXIP)  ",
	"cr5(SNIP)  ",
	"cr6(SFIP)  ",
	"cr7(VBR)   ",
	"cr8(DMT0)  ",
	"cr9(DMD0)  ",
	"cr10(DMA0) ",
	"cr11(DMT1) ",
	"cr12(DMD1) ",
	"cr13(DMA1) ",
	"cr14(DMT2) ",
	"cr15(DMD2) ",
	"cr16(DMA2) ",
	"cr17(SR0)  ",
	"cr18(SR1)  ",
	"cr19(SR2)  ",
	"cr20(SR3)  ",
	"fcr0(FPECR)",
	"fcr1(FPHS1)",
	"fcr2(FPLS1)",
	"fcr3(FPHS2)",
	"fcr4(FPLS2)",
	"fcr5(FPPT) ",
	"fcr6(FPRH) ",
	"fcr7(FPRL) ",
	"fcr8(FPIT) ",
	NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
	NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
	NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
	NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
	"fcr62(FPSR)",
	"fcr63(FPCR)"
d98 1
a98 11
#endif
#ifdef M88110
static const char *m88110_ctrlreg[64] = {
	"cr0(PID)   ",
	"cr1(PSR)   ",
	"cr2(EPSR)  ",
	NULL,
	"cr4(EXIP)  ",
	"cr5(ENIP)  ",
	NULL,
	"cr7(VBR)   ",
d101 16
d118 3
a123 8
	"cr14(RES1) ",
	"cr15(RES2) ",
	"cr16(SRX)  ",
	"cr17(SR0)  ",
	"cr18(SR1)  ",
	"cr19(SR2)  ",
	"cr20(SR3)  ",
	"fcr0(FPECR)",
a126 12
	"cr25(ICMD) ",
	"cr26(ICTL) ",
	"cr27(ISAR) ",
	"cr28(ISAP) ",
	"cr29(IUAP) ",
	"cr30(IIR)  ",
	"cr31(IBP)  ",
	"cr32(IPPU) ",
	"cr33(IPPL) ",
	"cr34(ISR)  ",
	"cr35(ILAR) ",
	"cr36(IPAR) ",
d129 134
a262 17
	NULL,
	"cr40(DCMD) ",
	"cr41(DCTL) ",
	"cr42(DSAR) ",
	"cr43(DSAP) ",
	"cr44(DUAP) ",
	"cr45(DIR)  ",
	"cr46(DBP)  ",
	"cr47(DPPU) ",
	"cr48(DPPL) ",
	"cr49(DSR)  ",
	"cr50(DLAR) ",
	"cr51(DPAR) ",
	NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
	NULL, NULL,
	"fcr62(FPSR)",
	"fcr63(FPCR)"
a263 44
#endif
#if defined(M88100) && defined(M88110)
#define	ctrlreg	(CPU_IS88100 ? m88100_ctrlreg : m88110_ctrlreg)
#elif defined(M88100)
#define	ctrlreg	m88100_ctrlreg
#else
#define	ctrlreg	m88110_ctrlreg
#endif

#define printval(x) \
	do { \
		if ((x) < 0) \
			db_printf("-0x%X", -(x)); \
		else \
			db_printf("0x%X", (x));	\
	} while (0)

/* prototypes */
void oimmed(int, const char *, long);
void ctrlregs(int, const char *, long);
void printsod(int);
void sindou(int, const char *, long);
void jump(int, const char *, long);
void instset(int, const char *, long);
void symofset(int, int, int);
void obranch(int, const char *, long);
void brcond(int, const char *, long);
void otrap(int, const char *, long);
void obit(int, const char *, long);
void bitman(int, const char *, long);
void immem(int, const char *, long);
void nimmem(int, const char *, long);
void lognim(int, const char *, long);
void onimmed(int, const char *, long);

/* Handlers immediate integer arithmetic instructions */
void
oimmed(int inst, const char *opcode, long iadr)
{
	int Linst = inst & 0177777;
	int Hinst = inst >> 16;
	int H6inst = Hinst >> 10;
	int rs1 = Hinst & 037;
	int rd = (Hinst >> 5) & 037;
d265 25
a289 2
	if (H6inst > 017 && H6inst < 030 && (H6inst & 01) == 1)
		db_printf("\t%s.u", opcode);
d291 28
a318 3
		db_printf("\t%s  ", opcode);
	db_printf("\t\tr%-3d,r%-3d,", rd, rs1);
	printval(Linst);
a320 1
/* Handles instructions dealing with control registers */
d322 1
a322 1
ctrlregs(int inst, const char *opcode, long iadr)
d324 1
a324 4
	int L6inst = (inst >> 11) & 037;
	int creg = (inst >> 5) & 077;
	int rd = (inst >> 21) & 037;
	int rs1 = (inst >> 16) & 037;
d326 8
a333 1
	db_printf("\t%s", opcode);
d335 21
a355 6
	if (L6inst == 010 || L6inst == 011)
		db_printf("\t\tr%-3d,%s", rd, ctrlreg[creg]);
	else if (L6inst == 020 || L6inst == 021)
		db_printf("\t\tr%-3d,%s", rs1, ctrlreg[creg]);
	else
		db_printf("\t\tr%-3d,r%-3d,%s", rd, rs1, ctrlreg[creg]);
d358 1
d360 1
a360 1
printsod(int t)
d362 21
a382 4
	if (t == 0)
		db_printf("s");
	else
		db_printf("d");
d387 1
a387 1
sindou(int inst, const char *opcode, long iadr)
d389 74
a462 15
	int rs2 = inst & 037;
	int td = (inst >> 5) & 03;
	int t2 = (inst >> 7) & 03;
	int t1 = (inst >> 9) & 03;
	int rs1 = (inst >> 16) & 037;
	int rd = (inst >> 21) & 037;
	int checkbits = (inst >> 11) & 037;

	db_printf("\t%s.", opcode);
	printsod(td);
	if ((checkbits > 010 && checkbits < 014) || checkbits == 04) {
		printsod(t2);
		db_printf(" ");
		if (checkbits == 012 || checkbits == 013)
			db_printf("\t\tr%-3d,r%-3d", rd, rs2);
d464 2
a465 5
			db_printf("\t\tr%-3d,r%-3d", rd, rs2);
	} else {
		printsod(t1);
		printsod(t2);
		db_printf("\t\tr%-3d,r%-3d,r%-3d", rd, rs1, rs2);
d470 1
a470 1
jump(int inst, const char *opcode, long iadr)
d472 1
a472 2
	int rs2 = inst & 037;
	int Nbit = (inst >> 10) & 01;
d475 1
a475 1
	if (Nbit == 1)
d479 1
a479 1
	db_printf("\t\tr%-3d", rs2);
d484 1
a484 1
instset(int inst, const char *opcode, long iadr)
d486 5
a490 5
	int rs2 = inst & 037;
	int rs1 = (inst >> 16) & 037;
	int rd = (inst >> 21) & 037;
	int checkbits = (inst >> 10) & 077;
	int H6inst = (inst >> 26) & 077;
d493 2
a494 17
	if (H6inst == 076) {
		db_printf("\t\tr%-3d,", rs1);
		printval(inst & 0177777);
	} else if (checkbits == 072 || checkbits == 073)
		db_printf("\t\tr%-3d,r%-3d", rd, rs2);
	else if (checkbits == 076)
		db_printf("\t\tr%-3d,r%-3d", rs1, rs2);
}

void
symofset(int disp, int bit, int iadr)
{
	long addr;

	if (disp & (1 << (bit - 1))) {
		/* negative value */
		addr = iadr + ((disp << 2) | (~0 << bit));
d496 13
a508 1
		addr = iadr + (disp << 2);
a509 1
	db_printsym(addr, DB_STGY_PROC, db_printf);
d512 1
d514 1
a514 1
obranch(int inst, const char *opcode, long iadr)
d516 1
a516 2
	int cond = (inst >> 26) & 01;
	int disp = inst & 0377777777;
d518 3
a520 2
	if (cond == 0)
		db_printf("\t%s\t\t", opcode);
d522 2
a523 1
		db_printf("\t%s.n\t\t", opcode);
d529 1
a529 1
brcond(int inst, const char *opcode, long iadr)
d531 15
a545 38
	int cond = (inst >> 26) & 1;
	int match = (inst >> 21) & 037;
	int rs = (inst >> 16) & 037;
	int disp = inst & 0177777;

	if (cond == 0)
		db_printf("\t%s\t\t", opcode);
	else
		db_printf("\t%s.n\t\t", opcode);
	if (((inst >> 27) & 03) == 1) {
		switch (match) {
		case 1:
			db_printf("%s,", condname[0]);
			break;
		case 2:
			db_printf("%s,", condname[1]);
			break;
		case 3:
			db_printf("%s,", condname[2]);
			break;
		case 12:
			db_printf("%s,", condname[3]);
			break;
		case 13:
			db_printf("%s,", condname[4]);
			break;
		case 14:
			db_printf("%s,", condname[5]);
			break;
		default:
			printval(match);
			db_printf(",");
			break;
		}
	} else {
		printval(match);
		db_printf(",");
	}
d547 1
a547 1
	db_printf("r%-3d,", rs);
d551 1
d553 1
a553 1
otrap(int inst, const char *opcode, long iadr)
d555 3
a557 3
	int vecno = inst & 0777;
	int match = (inst >> 21) & 037;
	int rs = (inst >> 16) & 037;
d560 5
a564 31
	if (((inst >> 12) & 017) == 0xe) {
		switch (match) {
		case 1:
			db_printf("%s,", condname[0]);
			break;
		case 2:
			db_printf("%s,", condname[1]);
			break;
		case 3:
			db_printf("%s,", condname[2]);
			break;
		case 12:
			db_printf("%s,", condname[3]);
			break;
		case 13:
			db_printf("%s,", condname[4]);
			break;
		case 14:
			db_printf("%s,", condname[5]);
			break;
		default:
			printval(match);
			db_printf(",");
			break;
		}
	} else {
		printval(match);
		db_printf(",");
	}
	db_printf("\tr%-3d,", rs);
	printval(vecno);
d569 1
a569 1
obit(int inst, const char *opcode, long iadr)
d571 9
a579 11
	int rs = (inst >> 16) & 037;
	int rd = (inst >> 21) & 037;
	int width = (inst >> 5) & 037;
	int offset = inst & 037;

	db_printf("\t%s\t\tr%-3d,r%-3d,", opcode, rd, rs);
	if (((inst >> 10) & 077) != 052)
		printval(width);
	db_printf("<");
	printval(offset);
	db_printf(">");
d584 1
a584 1
bitman(int inst, const char *opcode, long iadr)
d586 3
a588 3
	int rs1 = (inst >> 16) & 037;
	int rd = (inst >> 21) & 037;
	int rs2 = inst & 037;
d590 1
a590 1
	db_printf("\t%s\t\tr%-3d,r%-3d,r%-3d", opcode, rd, rs1, rs2);
d595 1
a595 1
immem(int inst, const char *opcode, long iadr)
d597 5
a601 5
	int immed = inst & 0xFFFF;
	int rd = (inst >> 21) & 037;
	int rs = (inst >> 16) & 037;
	int st_lda = (inst >> 28) & 03;
	int aryno = (inst >> 26) & 03;
d605 2
a606 4
	case 0:
		if (aryno == 0 || aryno == 01)
			opcode = "xmem";
		else
a607 3
		if (aryno == 0)
			aryno = 03;
		if (aryno != 01)
d609 12
d622 12
a633 2
	case 1:
		opcode = "ld";
d637 7
a643 3
	db_printf("\t%s%s%c\t\tr%-3d,r%-3d,",
	    opcode, instwidth[aryno], c, rd, rs);
	printval(immed);
d648 1
a648 1
nimmem(int inst, const char *opcode, long iadr)
d650 6
a655 6
	int scaled = (inst >> 9) & 01;
	int rd = (inst >> 21) & 037;
	int rs1 = (inst >> 16) & 037;
	int rs2 = inst & 037;
	int st_lda = (inst >> 12) & 03;
	int aryno = (inst >> 10) & 03;
d657 1
a657 1
	const char *user;
d660 7
a666 2
	case 0:
		if (aryno == 0 || aryno == 01)
d668 4
a671 1
		else
a672 3
		if (aryno == 0)
			aryno = 03;
		if (aryno != 01)
d674 2
d677 1
a677 1
	case 1:
d679 19
d701 2
d704 5
a708 2
	if (st_lda != 03 && ((inst >> 8) & 01) != 0)
		user = ".usr";
d710 1
a710 4
		user = "    ";

	db_printf("\t%s%s%c%s\tr%-3d,r%-3d",
	    opcode, instwidth[aryno], c, user, rd, rs1);
d712 2
a713 2
	if (scaled)
		db_printf("[r%-3d]", rs2);
d715 1
a715 1
		db_printf(",r%-3d", rs2);
d720 1
a720 1
lognim(int inst, const char *opcode, long iadr)
d722 3
a724 5
	int rd = (inst >> 21) & 037;
	int rs1 = (inst >> 16) & 037;
	int rs2 = inst & 037;
	int complemt = (inst >> 10) & 01;
	char *c = "  ";
d726 3
a728 2
	if (complemt)
		c = ".c";
d730 1
a730 1
	db_printf("\t%s%s\t\tr%-3d,r%-3d,r%-3d", opcode, c, rd, rs1, rs2);
d735 1
a735 1
onimmed(int inst, const char *opcode, long iadr)
d737 4
a740 7
	int rd = (inst >> 21) & 037;
	int rs1 = (inst >> 16) & 037;
	int rs2 = inst & 037;
	int carry = (inst >> 8) & 03;
	int nochar = (inst >> 10) & 07;
	int nodecode = (inst >> 11) & 01;
	const char *tab, *c;
d742 1
a742 4
	if (nochar > 02)
		tab = "\t\t";
	else
		tab = "\t";
d744 1
a744 1
	if (!nodecode) {
d746 2
a747 5
		case 01:
			c = ".co ";
			break;
		case 02:
			c = ".ci ";
d749 2
a750 2
		case 03:
			c = ".cio";
d752 2
a753 2
		default:
			c = "    ";
d756 4
a759 2
	} else
		c = "    ";
d761 48
a808 1
	db_printf("\t%s%s%sr%-3d,r%-3d,r%-3d", opcode, c, tab, rd, rs1, rs2);
d812 4
a815 4
	u_int mask, match;
	void (*opfun)(int, const char *, long);
	const char *farg;
} opdecode[] = {
d817 2
a818 2
	{ 0xf0000000,	0x00000000,	immem,		NULL },
	{ 0xf0000000,	0x10000000,	immem,		NULL },
d870 4
a873 8
	{ 0xfc00f2e0,	0xf4000000,	nimmem,		NULL },
	{ 0xfc00f2e0,	0xf4000200,	nimmem,		NULL },
	{ 0xfc00f2e0,	0xf4001000,	nimmem,		NULL },
	{ 0xfc00f2e0,	0xf4001200,	nimmem,		NULL },
	{ 0xfc00f2e0,	0xf4002000,	nimmem,		"st" },
	{ 0xfc00f2e0,	0xf4002200,	nimmem,		"st" },
	{ 0xfc00f2e0,	0xf4003000,	nimmem,		"lda" },
	{ 0xfc00f2e0,	0xf4003200,	nimmem,		"lda" },
d904 107
d1013 2
a1014 2
int
m88k_print_instruction(u_int iadr, long inst)
d1019 1
a1019 1
	 * This messes up "orb" instructions ever so slightly,
d1023 1
a1023 1
		db_printf("\t.word 0");
d1025 2
a1026 1
		for (p = opdecode; p->mask; p++)
d1028 3
a1030 2
				(*p->opfun)(inst, p->farg, iadr);
				break;
d1032 3
a1034 2
		if (!p->mask)
			db_printf("\t.word 0x%x", inst);
a1035 2

	return (iadr + 4);
d1041 8
a1048 2
	m88k_print_instruction(loc, db_get_value(loc, 4, FALSE));
	db_printf("\n");
@


1.5
log
@Factorize control register description array selection.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.4 2005/09/06 19:30:32 miod Exp $	*/
d447 2
a448 1
	if (!st_lda) {
d457 4
a460 3
	} else {
		if (st_lda == 01)
			opcode = "ld";
d478 2
a479 3
	int user_bit = 0;
	int signed_fg = 1;
	char *user = "    ";
d481 2
a482 1
	if (!st_lda) {
d490 5
a494 4
			signed_fg = 0;
	} else {
		if (st_lda == 01)
			opcode = "ld";
a496 5
	if (st_lda != 03) {
		user_bit = (inst >> 8) & 01;
		if (user_bit)
			user = ".usr";
	}
d498 7
a504 10
	if (user_bit && signed_fg && aryno == 01)
		db_printf("\t%s%s\tr%-3d,r%-3d", opcode, user, rd, rs1);
	else {
		if (user_bit && signed_fg)
			db_printf("\t%s%s%s\tr%-3d,r%-3d",
			    opcode, instwidth[aryno], user, rd, rs1);
		else
			db_printf("\t%s%su%s\tr%-3d,r%-3d",
			    opcode, instwidth[aryno], user, rd, rs1);
	}
@


1.4
log
@Correct control registers descriptive names for 88110.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.3 2005/05/15 14:12:22 miod Exp $	*/
d51 1
d90 2
a91 1

d150 8
d215 1
a215 2
		db_printf("\t\tr%-3d,%s", rd,
		    CPU_IS88100 ? m88100_ctrlreg[creg] : m88110_ctrlreg[creg]);
d217 1
a217 2
		db_printf("\t\tr%-3d,%s", rs1,
		    CPU_IS88100 ? m88100_ctrlreg[creg] : m88110_ctrlreg[creg]);
d219 1
a219 2
		db_printf("\t\tr%-3d,r%-3d,%s", rd, rs1,
		    CPU_IS88100 ? m88100_ctrlreg[creg] : m88110_ctrlreg[creg]);
d572 1
a572 1
	unsigned mask, match;
d671 1
a671 1
m88k_print_instruction(unsigned iadr, long inst)
@


1.3
log
@KNF and ANSIfy.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.2 2004/09/30 21:48:56 miod Exp $	*/
d107 5
a111 5
	"cr16(SR0)  ",
	"cr17(SR1)  ",
	"cr18(SR2)  ",
	"cr19(SR3)  ",
	"cr20(SR4)  ",
@


1.2
log
@Introduce sparc-like CPU_ISFOO macros, to short-circuit evaluations when
compiling for one flavour only.

This makes code slightly smaller on all m88k-based platforms (my roughly
1KB), and saves more than meets the eye on luna88k, which is m88100-based.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.1 2004/06/19 18:28:37 miod Exp $	*/
d177 1
a177 1
oimmed(int inst, const char  *opcode, long iadr)
d183 1
a183 1
	int rd = ( Hinst >> 5 ) & 037;
d185 4
a188 6
	if (( H6inst > 017 ) && ( H6inst < 030 ) && ( H6inst & 01) == 1 )
		db_printf("\t%s.u",opcode);
	else {
		db_printf("\t%s",opcode);
		db_printf("  ");
	}
a192 1

d202 1
a202 1
	db_printf("\t%s",opcode);
d204 1
a204 1
	if ( L6inst == 010 || L6inst == 011 )
d206 2
a207 2
			  CPU_IS88100 ? m88100_ctrlreg[creg] : m88110_ctrlreg[creg]);
	else if ( L6inst == 020 || L6inst == 021 )
d209 1
a209 1
			  CPU_IS88100 ? m88100_ctrlreg[creg] : m88110_ctrlreg[creg]);
d212 1
a212 1
			  CPU_IS88100 ? m88100_ctrlreg[creg] : m88110_ctrlreg[creg]);
a214 1

d218 1
a218 1
	if ( t == 0 )
d229 6
a234 6
	int td = ( inst >> 5 ) & 03;
	int t2 = ( inst >> 7 ) & 03;
	int t1 = ( inst >> 9 ) & 03;
	int rs1 = ( inst >> 16 ) & 037;
	int rd = ( inst >> 21 ) & 037;
	int checkbits  = ( inst >> 11 ) & 037;
d236 1
a236 1
	db_printf("\t%s.",opcode);
d238 1
a238 1
	if (( checkbits > 010 && checkbits < 014 ) || ( checkbits == 04 )) {
d241 1
a241 1
		if ( checkbits == 012 || checkbits == 013 )
d246 2
a247 1
		printsod(t1);printsod(t2);
a251 1

d256 1
a256 1
	int Nbit = ( inst >> 10 ) & 01;
d258 2
a259 2
	db_printf("\t%s",opcode);
	if ( Nbit == 1 )
d263 1
a263 1
	db_printf("\t\tr%-3d",rs2);
a265 1

d271 8
a278 8
	int rs1 = ( inst >> 16 ) & 037;
	int rd = ( inst >> 21 ) & 037;
	int checkbits = ( inst >> 10 ) & 077;
	int H6inst = ( inst >> 26 ) & 077;

	db_printf("\t%s",opcode);
	if ( H6inst == 076 ) {
		db_printf("\t\tr%-3d,",rs1);
d280 1
a280 1
	} else if (( checkbits == 072 ) || ( checkbits == 073 ))
d282 2
a283 2
	else if ( checkbits == 076 )
		db_printf("\t\tr%-3d,r%-3d",rs1,rs2);
d287 1
a287 1
symofset(int  disp, int  bit, int iadr)
d291 1
a291 1
	if ( disp & (1 << (bit-1)) ) {
d297 1
a297 2
	db_printsym(addr,DB_STGY_PROC, db_printf);
	return;
d303 2
a304 2
	int cond = ( inst >> 26 ) & 01;
	int disp = inst &0377777777;
d306 5
a310 7
	if ( cond == 0 ) {
		db_printf("\t%s\t\t",opcode);
		symofset(disp, 26, iadr);
	} else {
		db_printf("\t%s.n\t\t",opcode);
		symofset(disp, 26, iadr);
	}
a312 1

d317 4
a320 4
	int cond = ( inst >> 26 ) & 1;
	int match = ( inst >> 21 ) & 037;
	int rs = ( inst >> 16 ) & 037;
	int disp = ( inst & 0177777 );
d322 1
a322 1
	if ( cond == 0 )
d326 1
a326 1
	if ( ( ( inst >> 27 ) & 03 ) == 1 )
d328 20
a347 7
		case 1 : db_printf("%s,", condname[0]); break;
		case 2 : db_printf("%s,", condname[1]); break;
		case 3 : db_printf("%s,", condname[2]); break;
		case 12: db_printf("%s,", condname[3]); break;
		case 13: db_printf("%s,", condname[4]); break;
		case 14: db_printf("%s,", condname[5]); break;
		default: printval(match);
d349 3
a351 1
		} else {
a359 1

d364 2
a365 2
	int match = ( inst >> 21 ) & 037;
	int rs = ( inst >> 16 ) & 037;
d367 2
a368 2
	db_printf("\t%s\t",opcode);
	if ( ( ( inst >> 12 ) & 017 ) == 0xe )
d370 20
a389 7
		case 1 : db_printf("%s,", condname[0]);break;
		case 2 : db_printf("%s,", condname[1]);break;
		case 3 : db_printf("%s,", condname[2]);break;
		case 12: db_printf("%s,", condname[3]);break;
		case 13: db_printf("%s,", condname[4]);break;
		case 14: db_printf("%s,", condname[5]);break;
		default: printval(match);
d391 3
a393 1
		} else {
a400 1

d405 4
a408 4
	int rs = ( inst >> 16 ) & 037;
	int rd = ( inst >> 21 ) & 037;
	int width = ( inst >> 5 ) & 037;
	int offset = ( inst & 037 );
d411 1
a411 5
	if ( ( ( inst >> 10 ) & 077 ) == 052 ) {
		db_printf("<");
		printval(offset);
		db_printf(">");
	} else {
d413 3
a415 4
		db_printf("<");
		printval(offset);
		db_printf(">");
	}
a417 1

d422 2
a423 3

	int rs1 = ( inst >> 16 ) & 037;
	int rd  = ( inst >> 21 ) & 037;
a428 1

d433 3
a435 3
	int immed  = inst & 0xFFFF;
	int rd     = (inst >> 21) & 037;
	int rs     = (inst >> 16) & 037;
d437 1
a437 1
	int aryno  = (inst >> 26) & 03;
d441 1
a441 1
		if ((aryno == 0) || (aryno == 01))
d447 1
a447 1
		if (!(aryno == 01))
d449 1
a449 1
	} else
d451 2
a452 1
		opcode = "ld";
d454 2
a455 2
	db_printf("\t%s%s%c\t\tr%-3d,r%-3d,", opcode, instwidth[aryno],
		  c, rd, rs);
a458 1

d463 6
a468 6
	int scaled  = (inst >> 9) & 01;
	int rd      = (inst >> 21) & 037;
	int rs1     = (inst >> 16) & 037;
	int rs2     = inst & 037;
	int st_lda  = (inst >> 12) & 03;
	int aryno   = (inst >> 10) & 03;
d470 2
a471 3
	int signed_fg  = 1;
	char *user           = "    ";
	char c = ' ';
d474 1
a474 1
		if ((aryno == 0) || (aryno == 01))
d480 1
a480 2
		if (!(aryno == 01)) {
			c = 'u';
d482 1
a482 2
		}
	} else
d484 2
a485 1
		opcode = "ld";
d487 1
a487 1
	if (!(st_lda == 03)) {
d493 6
a498 4
	if (user_bit && signed_fg && (aryno == 01)) {
		if (st_lda)
			db_printf("\t%s%s\tr%-3d,r%-3d", opcode,
				  user, rd, rs1);
d500 3
a502 9
			db_printf("\t%s%s\tr%-3d,r%-3d", opcode,
				  user, rd, rs1);
	} else
		if (user_bit && signed_fg)
		db_printf("\t%s%s%s\tr%-3d,r%-3d", opcode,
			  instwidth[aryno], user, rd, rs1);
	else
		db_printf("\t%s%s%c%s\tr%-3d,r%-3d", opcode,
			  instwidth[aryno], c, user, rd, rs1);
a509 1

d514 3
a516 3
	int rd   = (inst >> 21) & 037;
	int rs1  = (inst >> 16) & 037;
	int rs2  = inst & 037;
a525 1

d530 3
a532 3
	int rd   = (inst >> 21) & 037;
	int rs1  = (inst >> 16) & 037;
	int rs2  = inst & 037;
d536 1
a536 1
	char *tab, *c ;
d544 2
a545 1
		if (carry == 01)
d547 2
a548 2
		else
			if (carry == 02)
d550 2
a551 2
		else
			if (carry == 03)
d553 2
a554 1
		else
d556 2
d561 1
a561 2
	db_printf("\t%s%s%sr%-3d,r%-3d,r%-3d", opcode, c,
		  tab, rd, rs1, rs2);
a568 1

d570 91
a660 92

	{   0xF0000000U, 0x00000000U, immem, NULL},
	{   0xF0000000U, 0x10000000U, immem, NULL},
	{   0xF0000000U, 0x20000000U, immem, "st"},
	{   0xF0000000U, 0x30000000U, immem, "lda"},

	{   0xF8000000U, 0x40000000U, oimmed, "and"},
	{   0xF8000000U, 0x48000000U, oimmed, "mask"},
	{   0xF8000000U, 0x50000000U, oimmed, "xor"},
	{   0xF8000000U, 0x58000000U, oimmed, "or"},
	{   0xFC000000U, 0x60000000U, oimmed, "addu"},
	{   0xFC000000U, 0x64000000U, oimmed, "subu"},
	{   0xFC000000U, 0x68000000U, oimmed, "divu"},
	{   0xFC000000U, 0x6C000000U, oimmed, "mul"},
	{   0xFC000000U, 0x70000000U, oimmed, "add"},
	{   0xFC000000U, 0x74000000U, oimmed, "sub"},
	{   0xFC000000U, 0x78000000U, oimmed, "div"},
	{   0xFC000000U, 0x7C000000U, oimmed, "cmp"},

	{   0xFC00F800U, 0x80004000U, ctrlregs, "ldcr"},
	{   0xFC00F800U, 0x80004800U, ctrlregs, "fldcr"},
	{   0xFC00F800U, 0x80008000U, ctrlregs, "stcr"},
	{   0xFC00F800U, 0x80008800U, ctrlregs, "fstcr"},
	{   0xFC00F800U, 0x8000C000U, ctrlregs, "xcr"},
	{   0xFC00F800U, 0x8000C800U, ctrlregs, "fxcr"},

	{   0xFC00F800U, 0x84000000U, sindou, "fmul"},
	{   0xFC1FFF80U, 0x84002000U, sindou, "flt"},
	{   0xFC00F800U, 0x84002800U, sindou, "fadd"},
	{   0xFC00F800U, 0x84003000U, sindou, "fsub"},
	{   0xFC00F860U, 0x84003800U, sindou, "fcmp"},
	{   0xFC1FFE60U, 0x84004800U, sindou, "int"},
	{   0xFC1FFE60U, 0x84005000U, sindou, "nint"},
	{   0xFC1FFE60U, 0x84005800U, sindou, "trnc"},
	{   0xFC00F800U, 0x84007000U, sindou, "fdiv"},

	{   0xF8000000U, 0xC0000000U, obranch, "br"},
	{   0xF8000000U, 0xC8000000U, obranch, "bsr"},

	{   0xF8000000U, 0xD0000000U, brcond, "bb0"},
	{   0xF8000000U, 0xD8000000U, brcond, "bb1"},
	{   0xF8000000U, 0xE8000000U, brcond, "bcnd"},

	{   0xFC00FC00U, 0xF0008000U, obit, "clr"},
	{   0xFC00FC00U, 0xF0008800U, obit, "set"},
	{   0xFC00FC00U, 0xF0009000U, obit, "ext"},
	{   0xFC00FC00U, 0xF0009800U, obit, "extu"},
	{   0xFC00FC00U, 0xF000A000U, obit, "mak"},
	{   0xFC00FC00U, 0xF000A800U, obit, "rot"},

	{   0xFC00FE00U, 0xF000D000U, otrap, "tb0"},
	{   0xFC00FE00U, 0xF000D800U, otrap, "tb1"},
	{   0xFC00FE00U, 0xF000E800U, otrap, "tcnd"},

	{   0xFC00F2E0U, 0xF4000000U, nimmem, NULL},
	{   0xFC00F2E0U, 0xF4000200U, nimmem, NULL},
	{   0xFC00F2E0U, 0xF4001000U, nimmem, NULL},
	{   0xFC00F2E0U, 0xF4001200U, nimmem, NULL},
	{   0xFC00F2E0U, 0xF4002000U, nimmem, "st"},
	{   0xFC00F2E0U, 0xF4002200U, nimmem, "st"},
	{   0xFC00F2E0U, 0xF4003000U, nimmem, "lda"},
	{   0xFC00F2E0U, 0xF4003200U, nimmem, "lda"},

	{   0xFC00FBE0U, 0xF4004000U, lognim, "and"},
	{   0xFC00FBE0U, 0xF4005000U, lognim, "xor"},
	{   0xFC00FBE0U, 0xF4005800U, lognim, "or"},

	{   0xFC00FCE0U, 0xF4006000U, onimmed, "addu"},
	{   0xFC00FCE0U, 0xF4006400U, onimmed, "subu"},
	{   0xFC00FCE0U, 0xF4006800U, onimmed, "divu"},
	{   0xFC00FCE0U, 0xF4006C00U, onimmed, "mul"},
	{   0xFC00FCE0U, 0xF4007000U, onimmed, "add"},
	{   0xFC00FCE0U, 0xF4007400U, onimmed, "sub"},
	{   0xFC00FCE0U, 0xF4007800U, onimmed, "div"},
	{   0xFC00FCE0U, 0xF4007C00U, onimmed, "cmp"},

	{   0xFC00FFE0U, 0xF4008000U, bitman, "clr"},
	{   0xFC00FFE0U, 0xF4008800U, bitman, "set"},
	{   0xFC00FFE0U, 0xF4009000U, bitman, "ext"},
	{   0xFC00FFE0U, 0xF4009800U, bitman, "extu"},
	{   0xFC00FFE0U, 0xF400A000U, bitman, "mak"},
	{   0xFC00FFE0U, 0xF400A800U, bitman, "rot"},

	{   0xFC00FBE0U, 0xF400C000U, jump, "jmp"},
	{   0xFC00FBE0U, 0xF400C800U, jump, "jsr"},

	{   0xFC00FFE0U, 0xF400E800U, instset, "ff1"},
	{   0xFC00FFE0U, 0xF400EC00U, instset, "ff0"},
	{   0xFC00FFE0U, 0xF400F800U, instset, "tbnd"},
	{   0xFC00FFE0U, 0xF400FC00U, instset, "rte"},
	{   0xFC000000U, 0xF8000000U, instset, "tbnd"},
	{   0, 0, NULL, NULL}
a662 2
static const char *badop = "\t???";

d668 4
a671 2
	/* this messes up "orb" instructions ever so slightly, */
	/* but keeps us in sync between routines... */
d673 1
a673 1
		db_printf ("\t.word 0");
d677 1
a677 1
				(*p->opfun) (inst, p->farg, iadr);
d681 1
a681 1
			db_printf (badop);
d684 1
a684 1
	return iadr+4;
d691 2
a692 2
	db_printf ("\n");
	return loc+4;
@


1.1
log
@Share common ddb files accross m88k platforms.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_disasm.c,v 1.13 2004/01/07 17:52:30 miod Exp $	*/
d33 1
a33 1
#include <sys/param.h>		/* cputyp and friends */
d209 1
a209 1
			  cputyp == CPU_88100 ? m88100_ctrlreg[creg] : m88110_ctrlreg[creg]);
d212 1
a212 1
			  cputyp == CPU_88100 ? m88100_ctrlreg[creg] : m88110_ctrlreg[creg]);
d215 1
a215 1
			  cputyp == CPU_88100 ? m88100_ctrlreg[creg] : m88110_ctrlreg[creg]);
@

