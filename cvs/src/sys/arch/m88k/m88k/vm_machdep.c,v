head	1.25;
access;
symbols
	OPENBSD_6_2:1.25.0.2
	OPENBSD_6_2_BASE:1.25
	OPENBSD_6_1:1.25.0.4
	OPENBSD_6_1_BASE:1.25
	OPENBSD_6_0:1.24.0.6
	OPENBSD_6_0_BASE:1.24
	OPENBSD_5_9:1.24.0.2
	OPENBSD_5_9_BASE:1.24
	OPENBSD_5_8:1.24.0.4
	OPENBSD_5_8_BASE:1.24
	OPENBSD_5_7:1.23.0.2
	OPENBSD_5_7_BASE:1.23
	OPENBSD_5_6:1.22.0.10
	OPENBSD_5_6_BASE:1.22
	OPENBSD_5_5:1.22.0.8
	OPENBSD_5_5_BASE:1.22
	OPENBSD_5_4:1.22.0.4
	OPENBSD_5_4_BASE:1.22
	OPENBSD_5_3:1.22.0.2
	OPENBSD_5_3_BASE:1.22
	OPENBSD_5_2:1.21.0.10
	OPENBSD_5_2_BASE:1.21
	OPENBSD_5_1_BASE:1.21
	OPENBSD_5_1:1.21.0.8
	OPENBSD_5_0:1.21.0.6
	OPENBSD_5_0_BASE:1.21
	OPENBSD_4_9:1.21.0.4
	OPENBSD_4_9_BASE:1.21
	OPENBSD_4_8:1.21.0.2
	OPENBSD_4_8_BASE:1.21
	OPENBSD_4_7:1.20.0.6
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.20.0.10
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.20.0.8
	OPENBSD_4_5_BASE:1.20
	OPENBSD_4_4:1.20.0.4
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.20.0.2
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.15.0.2
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.13.0.4
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.13.0.2
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.10.0.2
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.4.0.4
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.2
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.2.0.2
	OPENBSD_3_6_BASE:1.2;
locks; strict;
comment	@ * @;


1.25
date	2017.02.12.04.55.08;	author guenther;	state Exp;
branches;
next	1.24;
commitid	1rXx7AiXIWFC9gYa;

1.24
date	2015.05.05.02.13.47;	author guenther;	state Exp;
branches;
next	1.23;
commitid	dNPv28CJI5BxtRGW;

1.23
date	2014.11.16.12.30.58;	author deraadt;	state Exp;
branches;
next	1.22;
commitid	yv0ECmCdICvq576h;

1.22
date	2013.01.16.19.04.43;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2010.06.22.17.43.59;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2007.11.24.11.13.56;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2007.11.22.05.46.38;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2007.10.16.04.57.39;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2007.10.13.07.18.01;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2007.10.10.15.53.52;	author art;	state Exp;
branches;
next	1.15;

1.15
date	2007.06.20.17.29.36;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2007.05.27.20.59.25;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2006.06.23.13.46.05;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	2006.05.08.14.36.09;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2006.04.26.20.41.19;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2005.12.11.21.45.30;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2005.12.08.07.02.36;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2005.12.03.14.30.06;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2005.10.13.19.48.33;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2005.10.12.19.05.44;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2005.09.25.20.55.14;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2004.11.09.15.02.22;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2004.10.01.19.00.48;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2004.08.02.08.35.00;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2004.07.23.15.34.03;	author miod;	state Exp;
branches;
next	;


desc
@@


1.25
log
@Split up fork1():
 - FORK_THREAD handling is a totally separate function, thread_fork(),
   that is only used by sys___tfork() and which loses the flags, func,
   arg, and newprocp parameters and gains tcb parameter to guarantee
   the new thread's TCB is set before the creating thread returns
 - fork1() loses its stack and tidptr parameters
Common bits factor out:
 - struct proc allocation and initialization moves to thread_new()
 - maxthread handling moves to fork_check_maxthread()
 - setting the new thread running moves to fork_thread_start()
The MD cpu_fork() function swaps its unused stacksize parameter for
a tcb parameter.

luna88k testing by aoyama@@, alpha testing by dlg@@
ok mpi@@
@
text
@/*	$OpenBSD: vm_machdep.c,v 1.24 2015/05/05 02:13:47 guenther Exp $	*/

/*
 * Copyright (c) 1998 Steve Murphree, Jr.
 * Copyright (c) 1996 Nivas Madhur
 * Copyright (c) 1993 Adam Glass
 * Copyright (c) 1988 University of Utah.
 * Copyright (c) 1982, 1986, 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	from: Utah $Hdr: vm_machdep.c 1.21 91/04/06$
 *	from: @@(#)vm_machdep.c	7.10 (Berkeley) 5/7/91
 *	vm_machdep.c,v 1.3 1993/07/07 07:09:32 cgd Exp
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/signalvar.h>
#include <sys/malloc.h>
#include <sys/buf.h>
#include <sys/user.h>
#include <sys/vnode.h>
#include <sys/exec.h>
#include <sys/ptrace.h>

#include <uvm/uvm_extern.h>

#include <machine/mmu.h>
#include <machine/cmmu.h>
#include <machine/cpu.h>
#include <machine/trap.h>

extern void savectx(struct pcb *);
extern void switch_exit(struct proc *);

/*
 * Finish a fork operation, with process p2 nearly set up.
 * Copy and update the kernel stack and pcb, making the child
 * ready to run, and marking it so that it can return differently
 * than the parent.  Returns 1 in the child process, 0 in the parent.
 */

void
cpu_fork(struct proc *p1, struct proc *p2, void *stack, void *tcb,
    void (*func)(void *), void *arg)
{
	struct ksigframe {
		void (*func)(void *);
		void *arg;
	} *ksfp;
	extern void proc_trampoline(void);

	/* Copy pcb from p1 to p2. */
	if (p1 == curproc) {
		/* Sync the PCB before we copy it. */
		savectx(curpcb);
	}
#ifdef DIAGNOSTIC
	else if (p1 != &proc0)
		panic("cpu_fork: curproc");
#endif

	bcopy(&p1->p_addr->u_pcb, &p2->p_addr->u_pcb, sizeof(struct pcb));
	p2->p_md.md_tf = (struct trapframe *)USER_REGS(p2);

	/*
	 * If specified, give the child a different stack and/or TCB.
	 */
	if (stack != NULL)
		USER_REGS(p2)->r[31] = (u_int)stack;
	if (tcb != NULL)
		USER_REGS(p2)->r[27] = (u_int)tcb;

	ksfp = (struct ksigframe *)((char *)p2->p_addr + USPACE) - 1;
	ksfp->func = func;
	ksfp->arg = arg;

	/*
	 * When this process resumes, r31 will be ksfp and
	 * the process will be at the beginning of proc_trampoline().
	 * proc_trampoline will execute the function func, pop off
	 * ksfp frame, and resume to userland.
	 */

	p2->p_addr->u_pcb.kernel_state.pcb_sp = (u_int)ksfp;
	p2->p_addr->u_pcb.kernel_state.pcb_pc = (u_int)proc_trampoline;
}

/*
 * cpu_exit is called as the last action during exit.
 */
void
cpu_exit(struct proc *p)
{
	pmap_deactivate(p);
	sched_exit(p);
}

/*
 * Map an IO request into kernel virtual address space via phys_map.
 */
void
vmapbuf(bp, len)
	struct buf *bp;
	vsize_t len;
{
	caddr_t addr;
	vaddr_t ova, kva, off;
	paddr_t pa;
	struct pmap *pmap;
	u_int pg;

#ifdef DIAGNOSTIC
	if ((bp->b_flags & B_PHYS) == 0)
		panic("vmapbuf");
#endif

	addr = (caddr_t)trunc_page((vaddr_t)(bp->b_saveaddr = bp->b_data));
	off = (vaddr_t)bp->b_saveaddr & PGOFSET;
	len = round_page(off + len);
	pmap = vm_map_pmap(&bp->b_proc->p_vmspace->vm_map);

	ova = kva = uvm_km_valloc_wait(phys_map, len);

	bp->b_data = (caddr_t)(kva + off);
	for (pg = atop(len); pg != 0; pg--) {
		if (pmap_extract(pmap, (vaddr_t)addr, &pa) == FALSE)
			panic("vmapbuf: null page frame");
		pmap_enter(vm_map_pmap(phys_map), kva, pa,
		    PROT_READ | PROT_WRITE,
		    PROT_READ | PROT_WRITE | PMAP_WIRED);
		addr += PAGE_SIZE;
		kva += PAGE_SIZE;
	}
	pmap_update(pmap_kernel());
}

/*
 * Free the io map PTEs associated with this IO operation.
 * We also restore the original b_addr.
 */
void
vunmapbuf(bp, len)
	struct buf *bp;
	vsize_t len;
{
	vaddr_t addr, off;

#ifdef DIAGNOSTIC
	if ((bp->b_flags & B_PHYS) == 0)
		panic("vunmapbuf");
#endif

	addr = trunc_page((vaddr_t)bp->b_data);
	off = (vaddr_t)bp->b_data & PGOFSET;
	len = round_page(off + len);
	pmap_remove(vm_map_pmap(phys_map), addr, addr + len);
	pmap_update(vm_map_pmap(phys_map));
	uvm_km_free_wakeup(phys_map, addr, len);
	bp->b_data = bp->b_saveaddr;
	bp->b_saveaddr = 0;
}
@


1.24
log
@emul_native is only used for kernel threads which can't dump core, so
delete coredump_trad(), uvm_coredump(), cpu_coredump(), struct md_coredump,
and various #includes that are superfluous.

This leaves compat_linux processes without a coredump callback.  If that
ability is desired, someone should update it to use coredump_elf32() and
verify the results...

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.23 2014/11/16 12:30:58 deraadt Exp $	*/
a69 3
 * We currently double-map the user area so that the stack is at the same
 * address in each process; in the future we will probably relocate
 * the frame pointers on the stack after copying.
d73 2
a74 6
cpu_fork(p1, p2, stack, stacksize, func, arg)
	struct proc *p1, *p2;
	void *stack;
	size_t stacksize;
	void (*func)(void *);
	void *arg;
d96 1
a96 1
	 * If specified, give the child a different stack.
d99 3
a101 1
		USER_REGS(p2)->r[31] = (u_int)stack + stacksize;
@


1.23
log
@Replace a plethora of historical protection options with just
PROT_NONE, PROT_READ, PROT_WRITE, and PROT_EXEC from mman.h.
PROT_MASK is introduced as the one true way of extracting those bits.
Remove UVM_ADV_* wrapper, using the standard names.
ok doug guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.22 2013/01/16 19:04:43 miod Exp $	*/
a51 1
#include <sys/core.h>
a130 43
}

/*
 * Dump the machine specific header information at the start of a core dump.
 */
int
cpu_coredump(p, vp, cred, chdr)
	struct proc *p;
	struct vnode *vp;
	struct ucred *cred;
	struct core *chdr;
{
	struct reg reg;
	struct coreseg cseg;
	int error;

	CORE_SETMAGIC(*chdr, COREMAGIC, MID_MACHINE, 0);
	chdr->c_hdrsize = ALIGN(sizeof(*chdr));
	chdr->c_seghdrsize = ALIGN(sizeof(cseg));
	chdr->c_cpusize = sizeof(reg);

	/* Save registers. */
	error = process_read_regs(p, &reg);
	if (error)
		return error;

	CORE_SETMAGIC(cseg, CORESEGMAGIC, MID_MACHINE, CORE_CPU);
	cseg.c_addr = 0;
	cseg.c_size = chdr->c_cpusize;

	error = vn_rdwr(UIO_WRITE, vp, (caddr_t)&cseg, chdr->c_seghdrsize,
	    (off_t)chdr->c_hdrsize, UIO_SYSSPACE, IO_UNIT, cred, NULL, p);
	if (error)
		return error;

	error = vn_rdwr(UIO_WRITE, vp, (caddr_t)&reg, sizeof(reg),
	    (off_t)(chdr->c_hdrsize + chdr->c_seghdrsize), UIO_SYSSPACE,
	    IO_UNIT, cred, NULL, p);
	if (error)
		return error;

	chdr->c_nseg++;
	return 0;
@


1.22
log
@cpu_coredump() also needs to invoke vn_rdwr() without IO_NODELOCKED; only
affects a.out binaries' core dumps.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.21 2010/06/22 17:43:59 miod Exp $	*/
d208 2
a209 2
			   VM_PROT_READ | VM_PROT_WRITE,
			   VM_PROT_READ | VM_PROT_WRITE | PMAP_WIRED);
@


1.21
log
@Don't play with cacheability in vmapbuf() - pmap_enter() knows what it does.
This is a leftover from a very old workaround for a very old and long gone
pmap_enter() bug.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.20 2007/11/24 11:13:56 miod Exp $	*/
d163 1
a163 2
	    (off_t)chdr->c_hdrsize, UIO_SYSSPACE, IO_NODELOCKED|IO_UNIT, cred,
	    NULL, p);
d169 1
a169 1
	    IO_NODELOCKED|IO_UNIT, cred, NULL, p);
@


1.20
log
@Do not mark any page as global on monoprocessor kernels if running on a
88110, to avoid snooping notification bus cycles, as recommended by the
manual.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.19 2007/11/22 05:46:38 miod Exp $	*/
a213 8

	/* make sure snooping will be possible... */
#if !defined(MULTIPROCESSOR) && defined(M88110)
	if (CPU_IS88110)
		pmap_cache_ctrl(pmap_kernel(), ova, ova + len, 0);
	else
#endif
		pmap_cache_ctrl(pmap_kernel(), ova, ova + len, CACHE_GLOBAL);
@


1.19
log
@Remove explicit tlb flush from vmapbuf(), since pmap_enter() will take
care of this.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.18 2007/10/16 04:57:39 miod Exp $	*/
d214 1
d216 6
a221 1
	pmap_cache_ctrl(pmap_kernel(), ova, ova + len, CACHE_GLOBAL);
@


1.18
log
@Do not expose the end of the proc_trampoline bowels to C code anymore, and
get rid of the ``switchframe'' struct definition. As a bonus, this makes
cpu_fork() simpler and unwastes 8 bytes of u area.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.17 2007/10/13 07:18:01 miod Exp $	*/
a201 7
	/*
	 * You may ask: Why phys_map? kernel_map should be OK - after all,
	 * we are mapping user va to kernel va or remapping some
	 * kernel va to another kernel va. The answer is TLB flushing
	 * when the address gets a new mapping.
	 */

a202 8

	/*
	 * Flush the TLB for the range [kva, kva + off]. Strictly speaking,
	 * we should do this in vunmapbuf(), but we do it lazily here, when
	 * new pages get mapped in.
	 */

	cmmu_flush_tlb(cpu_number(), 1, kva, btoc(len));
@


1.17
log
@Do not splhigh() before invoking sched_exit(), sched_exit() will do it better.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.16 2007/10/10 15:53:52 art Exp $	*/
a62 1
extern void proc_do_uret(struct proc *);
a83 1
	struct switchframe *p2sf;
d86 1
a86 1
		void *proc;
a103 9
	 * Create a switch frame for proc 2
	 */
	p2sf = (struct switchframe *)((char *)p2->p_addr + USPACE - 8) - 1;

	p2sf->sf_pc = (u_int)proc_do_uret;
	p2sf->sf_proc = p2;
	p2->p_addr->u_pcb.kernel_state.pcb_sp = (u_int)p2sf;

	/*
d109 1
a109 2
	ksfp = (struct ksigframe *)p2->p_addr->u_pcb.kernel_state.pcb_sp - 1;

d111 1
a111 1
	ksfp->proc = arg;
d117 1
a117 2
	 * ksfp frame, and call the function in the switchframe
	 * now exposed.
@


1.16
log
@Make context switching much more MI:
 - Move the functionality of choosing a process from cpu_switch into
   a much simpler function: cpu_switchto. Instead of having the locore
   code walk the run queues, let the MI code choose the process we
   want to run and only implement the context switching itself in MD
   code.
 - Let MD context switching run without worrying about spls or locks.
 - Instead of having the idle loop implemented with special contexts
   in MD code, implement one idle proc for each cpu. make the idle
   loop MI with MD hooks.
 - Change the proc lists from the old style vax queues to TAILQs.
 - Change the sleep queue from vax queues to TAILQs. This makes
   wakeup() go from O(n^2) to O(n)

there will be some MD fallout, but it will be fixed shortly.
There's also a few cleanups to be done after this.

deraadt@@, kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.15 2007/06/20 17:29:36 miod Exp $	*/
a138 3
 *
 * Block context switches and then call switch_exit() which will
 * switch to another process thus we never return.
a142 2
	(void)splhigh();

@


1.15
log
@In vunmapbuf(), explicitely remove mappings before invoking uvm_km_free().
Even if the latter would end up removing the mappings by itself, it would
do so using pmap_remove() because phys_map is not intrsafe; but some
platforms use pmap_kenter_pa() in vmapbuf(). By removing the mappings
ourselves, we can ensure the remove function used matches the enter function
which has been used.
Discussed and theoretical ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.14 2007/05/27 20:59:25 miod Exp $	*/
d139 3
a141 5
 * We release the address space and machine-dependent resources,
 * including the memory for the user structure and kernel stack.
 * Once finished, we call switch_exit, which switches to a temporary
 * pcb and stack and never returns.  We block memory allocation
 * until switch_exit has made things safe again.
d146 1
a146 1
	splhigh();
d149 1
a149 2
	switch_exit(p);
	/* NOTREACHED */
@


1.14
log
@pagemove() is no longer used.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.13 2006/06/23 13:46:05 mickey Exp $	*/
d274 2
@


1.13
log
@consistantly count context switches on exit; miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.12 2006/05/08 14:36:09 miod Exp $	*/
a276 32
}

/*
 * Move pages from one kernel virtual address to another.
 */
void
pagemove(from, to, size)
	caddr_t from, to;
	size_t size;
{
	paddr_t pa;
	boolean_t rv;

#ifdef DEBUG
	if ((size & PAGE_MASK) != 0)
		panic("pagemove");
#endif
	while (size > 0) {
		rv = pmap_extract(pmap_kernel(), (vaddr_t)from, &pa);
#ifdef DEBUG
		if (rv == FALSE)
			panic("pagemove 2");
		if (pmap_extract(pmap_kernel(), (vaddr_t)to, NULL) == TRUE)
			panic("pagemove 3");
#endif
		pmap_kremove((vaddr_t)from, PAGE_SIZE);
		pmap_kenter_pa((vaddr_t)to, pa, VM_PROT_READ|VM_PROT_WRITE);
		from += PAGE_SIZE;
		to += PAGE_SIZE;
		size -= PAGE_SIZE;
	}
	pmap_update(pmap_kernel());
@


1.12
log
@Replace gazillions of badvaddr() or badwordaddr() calls with badaddr() calls.
With a few prototype declarations shuffling, this finally allows
<machine/locore.h> to die.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.11 2006/04/26 20:41:19 miod Exp $	*/
a150 1
	uvmexp.swtch++;
@


1.11
log
@In vmapbuf(), instead of invoking pmap_cache_ctrl() for each page, postpone
the call and process the whole range once.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.10 2005/12/11 21:45:30 miod Exp $	*/
a60 1
#include <machine/locore.h>
a277 25
}

int
badvaddr(vaddr_t va, int size)
{
	volatile int x;

	if (badaddr(va, size)) {
		return -1;
	}

	switch (size) {
	case 1:
		x = *(unsigned char *volatile)va;
		break;
	case 2:
		x = *(unsigned short *volatile)va;
		break;
	case 4:
		x = *(unsigned long *volatile)va;
		break;
	default:
                return -1;
	}
	return (0);
@


1.10
log
@Work in progress SMP code; mvme88k boards can spin up secondary CPUs,
kernel boots single user. Still a lot of polishing and bugfixing to do.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.9 2005/12/08 07:02:36 miod Exp $	*/
d210 1
a210 1
	vaddr_t kva, off;
d213 1
d232 1
a232 1
	kva = uvm_km_valloc_wait(phys_map, len);
d243 1
a243 1
	while (len > 0) {
a248 3
		/* make sure snooping will be possible... */
		pmap_cache_ctrl(pmap_kernel(), kva, kva + PAGE_SIZE,
		    CACHE_GLOBAL);
a250 1
		len -= PAGE_SIZE;
d252 2
@


1.9
log
@Do not reset the IPL of the new process context frame in cpu_fork().
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.8 2005/12/03 14:30:06 miod Exp $	*/
a148 2
	pmap_deactivate(p);

d151 1
@


1.8
log
@Switch m88k ports to __HAVE_CPUINFO. Current cpu pointer is held in SR0
on all running processors.
Tested aoyama@@ and I
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.7 2005/10/13 19:48:33 miod Exp $	*/
a103 1
	p2->p_addr->u_pcb.kernel_state.pcb_ipl = IPL_NONE;	/* XXX */
@


1.7
log
@Merge <machine/cpu_number.h> into <machine/cpu.h>, preparing for intrusive
changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.6 2005/10/12 19:05:44 miod Exp $	*/
a90 1
	extern struct pcb *curpcb;
d204 1
a204 20
 * Map an IO request into kernel virtual address space.  Requests fall into
 * one of five catagories:
 *
 *	B_PHYS|B_UAREA:	User u-area swap.
 *			Address is relative to start of u-area (p_addr).
 *	B_PHYS|B_PAGET:	User page table swap.
 *			Address is a kernel VA in usrpt (Usrptmap).
 *	B_PHYS|B_DIRTY:	Dirty page push.
 *			Address is a VA in proc2's address space.
 *	B_PHYS|B_PGIN:	Kernel pagein of user pages.
 *			Address is VA in user's address space.
 *	B_PHYS:		User "raw" IO request.
 *			Address is VA in user's address space.
 *
 * All requests are (re)mapped into kernel VA space via phys_map
 *
 * XXX we allocate KVA space by using kmem_alloc_wait which we know
 * allocates space without backing physical memory.  This implementation
 * is a total crock, the multiple mappings of these physical pages should
 * be reflected in the higher-level VM structures to avoid problems.
@


1.6
log
@Stop mapping the u area at fixed UADDR in addition to its actual va.
While there, attempt to clean and comment stack usage in the kernel.
No functional change.

From the m88k SMP tree; help&test martin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.5 2005/09/25 20:55:14 miod Exp $	*/
a60 1
#include <machine/cpu_number.h>
@


1.5
log
@Change the size parameter of cmmu_flush_tlb() from bytes to pages. This makes
things easier for the callers, and allows us to inline the "fewer than 4 pages"
situation for speed.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.4 2004/11/09 15:02:22 miod Exp $	*/
a93 1
        extern void save_u_area(struct proc *, vaddr_t);
a108 3
	/*XXX these may not be necessary nivas */
	save_u_area(p2, (vaddr_t)p2->p_addr);

a202 14
}

/*
 * Finish a swapin operation.
 * We neded to update the cached PTEs for the user area in the
 * machine dependent part of the proc structure.
 */

void
cpu_swapin(struct proc *p)
{
        extern void save_u_area(struct proc *, vaddr_t);

	save_u_area(p, (vaddr_t)p->p_addr);
@


1.4
log
@Luna88k does not have an iomap, so kill all iomap related defines, and
move the mapiodev()/unmapiodev() code back to mvme88k.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.3 2004/10/01 19:00:48 miod Exp $	*/
d280 1
a280 1
	cmmu_flush_tlb(cpu_number(), 1, kva, len);
@


1.3
log
@More mvme88k code cleaning:
- merge locore_c_routines.c into machdep.c
- split machdep.c into really machdep.c content, and board-specific routines
  (memory sizing, early initialization, etc).

No functionnal change.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.2 2004/08/02 08:35:00 miod Exp $	*/
a51 1
#include <sys/extent.h>
a64 3
extern struct extent *iomap_extent;
extern struct vm_map *iomap_map;

a68 5
vaddr_t iomap_mapin(paddr_t, psize_t, boolean_t);
void iomap_mapout(vaddr_t, vsize_t);
void *mapiodev(void *, int);
void unmapiodev(void *, int);

a320 95
}


/*
 * Map a range [pa, pa+len] in the given map to a kernel address
 * in iomap space.
 *
 * Note: To be flexible, I did not put a restriction on the alignment
 * of pa. However, it is advisable to have pa page aligned since otherwise,
 * we might have several mappings for a given chunk of the IO page.
 */
vaddr_t
iomap_mapin(paddr_t pa, psize_t len, boolean_t canwait)
{
	vaddr_t	iova, tva, off;
	paddr_t ppa;
	int s, error;

	if (len == 0)
		return NULL;

	ppa = trunc_page(pa);
	off = pa & PGOFSET;
	len = round_page(off + len);

	s = splhigh();
	error = extent_alloc(iomap_extent, len, PAGE_SIZE, 0, EX_NOBOUNDARY,
	    canwait ? EX_WAITSPACE : EX_NOWAIT, &iova);
	splx(s);

	if (error != 0)
		return NULL;

	cmmu_flush_tlb(cpu_number(), 1, iova, len);	/* necessary? */

	tva = iova;
	while (len != 0) {
		pmap_enter(vm_map_pmap(iomap_map), tva, ppa,
			   VM_PROT_WRITE | VM_PROT_READ,
			   VM_PROT_WRITE | VM_PROT_READ | PMAP_WIRED);
		len -= PAGE_SIZE;
		tva += PAGE_SIZE;
		ppa += PAGE_SIZE;
	}
	pmap_update(pmap_kernel());

	return (iova + off);
}

/*
 * Free up the mapping in iomap.
 */
void
iomap_mapout(vaddr_t kva, vsize_t len)
{
	vaddr_t 	off;
	int 		s, error;

	off = kva & PGOFSET;
	kva = trunc_page(kva);
	len = round_page(off + len);

	pmap_remove(vm_map_pmap(iomap_map), kva, kva + len);
	pmap_update(vm_map_pmap(iomap_map));

	s = splhigh();
	error = extent_free(iomap_extent, kva, len, EX_NOWAIT);
	splx(s);

	if (error != 0)
		printf("iomap_mapout: extent_free failed\n");
}

/*
 * Allocate/deallocate a cache-inhibited range of kernel virtual address
 * space mapping the indicated physical address range [pa - pa+size)
 */
void *
mapiodev(pa, size)
	void *pa;
	int size;
{
	paddr_t ppa;
	ppa = (paddr_t)pa;
	return ((void *)iomap_mapin(ppa, size, 0));
}

void
unmapiodev(kva, size)
	void *kva;
	int size;
{
	vaddr_t va;
	va = (vaddr_t)kva;
	iomap_mapout(va, size);
@


1.2
log
@More include files cleaning:
- move MAX_CPUS constant to <machine/cpu.h>
- do not include <machine/board.h> unless needed. In fact, remove this file
  entirely on mvme88k, and include <machine/mvme*.h> on a
  compiling-for-this-board basis
- keep MAX_CMMUS constant private to the m8820x code
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.1 2004/07/23 15:34:03 miod Exp $	*/
d68 4
@


1.1
log
@Move luna88k and mvme88k vm_machdep to m88k-agnostic code area.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.3 2004/05/23 20:53:17 miod Exp $	*/
a59 1
#include <machine/board.h>
@

