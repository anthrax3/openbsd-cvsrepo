head	1.27;
access;
symbols
	OPENBSD_6_2:1.27.0.4
	OPENBSD_6_2_BASE:1.27
	OPENBSD_6_1:1.26.0.6
	OPENBSD_6_1_BASE:1.26
	OPENBSD_6_0:1.26.0.2
	OPENBSD_6_0_BASE:1.26
	OPENBSD_5_9:1.24.0.6
	OPENBSD_5_9_BASE:1.24
	OPENBSD_5_8:1.24.0.8
	OPENBSD_5_8_BASE:1.24
	OPENBSD_5_7:1.24.0.2
	OPENBSD_5_7_BASE:1.24
	OPENBSD_5_6:1.24.0.4
	OPENBSD_5_6_BASE:1.24
	OPENBSD_5_5:1.23.0.4
	OPENBSD_5_5_BASE:1.23
	OPENBSD_5_4:1.22.0.4
	OPENBSD_5_4_BASE:1.22
	OPENBSD_5_3:1.22.0.2
	OPENBSD_5_3_BASE:1.22
	OPENBSD_5_2:1.20.0.8
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.6
	OPENBSD_5_0:1.20.0.4
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.20.0.2
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.18.0.2
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.17.0.6
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.17.0.10
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.17.0.8
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.17.0.4
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.17.0.2
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.14.0.4
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.14.0.2
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.11.0.4
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.11.0.2
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.6.0.2
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.5.0.2
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	SMP_SYNC_A:1.1
	SMP_SYNC_B:1.1
	SMP:1.1.0.2;
locks; strict;
comment	@# @;


1.27
date	2017.05.29.06.06.52;	author mpi;	state Exp;
branches;
next	1.26;
commitid	jg8UvpsqxRlmI0q2;

1.26
date	2016.06.21.12.31.19;	author aoyama;	state Exp;
branches;
next	1.25;
commitid	3fBuma0XwNgdrzrx;

1.25
date	2016.05.10.18.39.46;	author deraadt;	state Exp;
branches;
next	1.24;
commitid	qfOifNidEGDB2jL1;

1.24
date	2014.06.08.13.20.39;	author miod;	state Exp;
branches;
next	1.23;
commitid	OaOUrnKw5wRWSVZi;

1.23
date	2013.08.24.20.54.29;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2013.01.11.22.34.43;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2013.01.05.11.20.56;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2011.01.05.22.16.16;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2010.12.23.20.05.08;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2010.04.20.20.28.18;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2008.02.20.18.35.41;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2007.12.22.17.14.39;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2007.12.02.21.22.19;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2006.11.18.22.48.44;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2006.11.17.22.32.35;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2006.11.10.19.20.29;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2006.01.02.19.46.12;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2005.12.03.16.52.16;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2005.12.03.14.30.06;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2005.10.13.19.48.33;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2005.10.12.19.32.19;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2005.05.15.16.23.45;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2004.10.01.20.20.34;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2004.08.02.10.44.51;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.01.17.18.05;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2004.07.07.21.18.11;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2004.04.29.14.33.27;	author miod;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2004.06.05.23.09.48;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.27
log
@copyin32 implementation from miod@@

ok kettenis@@
@
text
@/* $OpenBSD: subr.S,v 1.26 2016/06/21 12:31:19 aoyama Exp $	*/
/*
 * Mach Operating System
 * Copyright (c) 1993-1992 Carnegie Mellon University
 * Copyright (c) 1991 OMRON Corporation
 * Copyright (c) 1996 Nivas Madhur
 * Copyright (c) 1998 Steve Murphree, Jr.
 * All Rights Reserved.
 *
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON AND OMRON ALLOW FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON AND OMRON DISCLAIM ANY LIABILITY OF ANY KIND
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

#include "assym.h"

#include <sys/errno.h>

#include <machine/param.h>
#include <machine/asm.h>
#include <machine/psl.h>
#include <machine/trap.h>

#ifdef	M88100

/*
 * DO_LOAD_ADDRESS
 *
 * 	unsigned int do_load_word(address, supervisor_mode)
 *		vaddr_t address;		\\ in r2
 *		boolean_t supervisor_mode;	\\ in r3
 *
 * Return the word at ADDRESS (from user space if SUPERVISOR_MODE is zero,
 * supervisor space if non-zero).
 *
 */

ENTRY(do_load_word)	/* do_load_word(address, supervisor) */
	bcnd	ne0,%r3,1f
#ifdef ERRATA__XXX_USR
	NOP
	ld.usr	%r2,%r2,%r0
	NOP
	NOP
	NOP
	jmp	%r1
#else
	jmp.n	%r1
	 ld.usr	%r2,%r2,%r0
#endif
1:	jmp.n	%r1
	 ld	%r2,%r2,%r0

ENTRY(do_load_half)	/* do_load_half(address, supervisor) */
	bcnd	ne0,%r3,1f
#ifdef ERRATA__XXX_USR
	NOP
	ld.h.usr	%r2,%r2,%r0
	NOP
	NOP
	NOP
	jmp	%r1
#else
	jmp.n	%r1
	 ld.h.usr	%r2,%r2,%r0
#endif
1:	jmp.n	%r1
	 ld.h	%r2,%r2,%r0

ENTRY(do_load_byte)	/* do_load_byte(address, supervisor) */
	bcnd	ne0,%r3,1f
#ifdef ERRATA__XXX_USR
	NOP
	ld.b.usr	%r2,%r2,%r0
	NOP
	NOP
	NOP
	jmp	%r1
#else
	jmp.n	%r1
	 ld.b.usr	%r2,%r2,%r0
#endif
1:	jmp.n	%r1
	 ld.b	%r2,%r2,%r0

ENTRY(do_store_word)	/* do_store_word(address, data, supervisor) */
	bcnd	ne0,%r4,1f
#ifdef ERRATA__XXX_USR
	NOP
	st.usr	%r3,%r2,%r0
	NOP
	NOP
	NOP
	jmp	%r1
#else
	jmp.n	%r1
	 st.usr	%r3,%r2,%r0
#endif
1:	jmp.n	%r1
	 st	%r3,%r2,%r0

ENTRY(do_store_half)	/* do_store_half(address, data, supervisor) */
	bcnd	ne0,%r4,1f
#ifdef ERRATA__XXX_USR
	NOP
	st.h.usr	%r3,%r2,%r0
	NOP
	NOP
	NOP
	jmp	%r1
#else
	jmp.n	%r1
	 st.h.usr	%r3,%r2,%r0
#endif
1:	jmp.n	%r1
	 st.h	%r3,%r2,%r0

ENTRY(do_store_byte)	/* do_store_byte(address, data, supervisor) */
	bcnd	ne0,%r4,1f
#ifdef ERRATA__XXX_USR
	NOP
	st.b.usr	%r3,%r2,%r0
	NOP
	NOP
	NOP
	jmp	%r1
#else
	jmp.n	%r1
	 st.b.usr	%r3,%r2,%r0
#endif
1:	jmp.n	%r1
	 st.b	%r3,%r2,%r0

ENTRY(do_xmem_word)	/* do_xmem_word(address, data, supervisor) */
	bcnd	ne0,%r4,1f
#ifdef ERRATA__XXX_USR
	NOP
#endif
	xmem.usr	%r3,%r2,%r0
#ifdef ERRATA__XXX_USR
	NOP
	NOP
	NOP
#endif
	jmp.n	%r1
	 or	%r2, %r3, %r0
1:	xmem	%r3,%r2,%r0
	jmp.n	%r1
	 or	%r2, %r3, %r0

ENTRY(do_xmem_byte)	/* do_xmem_byte(address, data, supervisor) */
	bcnd	ne0,%r4,1f
#ifdef ERRATA__XXX_USR
	NOP
#endif
	xmem.bu.usr	%r3,%r2,%r0
#ifdef ERRATA__XXX_USR
	NOP
	NOP
	NOP
#endif
	jmp.n	%r1
	 or	%r2,%r3,%r0
1:	xmem.bu	%r3,%r2,%r0
	jmp.n	%r1
	 or	%r2,%r3,%r0

#endif	/* M88100 */

/*
 * Copy specified amount of data from user space into the kernel
 * copyin(from, to, len)
 *	r2 == from (user source address)
 *	r3 == to (kernel destination address)
 *	r4 == length
 */

#define	SRC	%r2
#define	DEST	%r3
#define	LEN	%r4

ENTRY(copyin)
	/* set up fault handler */
	ldcr	%r5,  CPU
	ld	%r6,  %r5,  CI_CURPCB
	or.u	%r5,  %r0,  %hi16(_ASM_LABEL(Lciflt))
	or	%r5,  %r5,  %lo16(_ASM_LABEL(Lciflt))
	st	%r5,  %r6,  PCB_ONFAULT	/* pcb_onfault = Lciflt */

	/*
	 * If it's a small length (less than 8), then do byte-by-byte.
	 * Despite not being optimal if len is 4, and from and to
	 * are word-aligned, this is still faster than doing more tests
	 * to save an hyperthetical fraction of cycle.
	 */
	cmp	%r9,  LEN,  8
	bb1	lt,   %r9,  _ASM_LABEL(copyin_byte_only)

	/* If they're not aligned similarly, use byte only... */
	xor	%r9,  SRC,  DEST
	mask	%r8,  %r9,  0x3
	bcnd	ne0,  %r8,  _ASM_LABEL(copyin_byte_only)

	/*
	 * At this point, we don't know if they're word aligned or not,
	 * but we know that what needs to be done to one to align
	 * it is what's needed for the other.
	 */
	bb1	0,    SRC,  _ASM_LABEL(copyin_left_align_to_halfword)
ASLOCAL(copyin_left_aligned_to_halfword)
	bb1	1,    SRC,  _ASM_LABEL(copyin_left_align_to_word)
ASLOCAL(copyin_left_aligned_to_word)
	bb1	0,    LEN,  _ASM_LABEL(copyin_right_align_to_halfword)
ASLOCAL(copyin_right_aligned_to_halfword)
	bb1	1,    LEN,  _ASM_LABEL(copyin_right_align_to_word)
ASLOCAL(copyin_right_aligned_to_word)

	/*
	 * At this point, both SRC and DEST are aligned to a word
	 * boundary, and LEN is a multiple of 4. We want it an even
	 * multiple of 4.
	 */
	bb1.n	2,    LEN,  _ASM_LABEL(copyin_right_align_to_doubleword)
	 or	%r7,  %r0,  4

ASLOCAL(copyin_right_aligned_to_doubleword)
#ifdef ERRATA__XXX_USR
	NOP
	ld.usr	%r5,  SRC,  %r0
	NOP
	NOP
	NOP
	ld.usr	%r6,  SRC,  %r7
	NOP
	NOP
	NOP
#else
	ld.usr	%r5,  SRC,  %r0
	ld.usr	%r6,  SRC,  %r7
#endif
	subu	LEN,  LEN,  8
	st	%r5,  DEST, %r0
	addu	SRC,  SRC,  8
	st	%r6,  DEST, %r7
	bcnd.n	ne0,  LEN,  _ASM_LABEL(copyin_right_aligned_to_doubleword)
	 addu	DEST, DEST, 8
	br.n	_ASM_LABEL(Lcidone)
	 or	%r2, %r0, %r0	/* successful return */

ASLOCAL(copyin_left_align_to_halfword)
#ifdef ERRATA__XXX_USR
	NOP
	ld.b.usr	%r5,  SRC, %r0
	NOP
	NOP
	NOP
#else
	ld.b.usr	%r5,  SRC, %r0
#endif
	subu	LEN,  LEN,  1
	st.b	%r5,  DEST, %r0
	addu	SRC,  SRC,  1
	br.n	_ASM_LABEL(copyin_left_aligned_to_halfword)
	 addu	DEST, DEST, 1

ASLOCAL(copyin_left_align_to_word)
#ifdef ERRATA__XXX_USR
	NOP
	ld.h.usr	%r5,   SRC,  %r0
	NOP
	NOP
	NOP
#else
	ld.h.usr	%r5,   SRC,  %r0
#endif
	subu	LEN,  LEN,  2
	st.h	%r5,  DEST, %r0
	addu	SRC,  SRC,  2
	br.n	_ASM_LABEL(copyin_left_aligned_to_word)
	 addu	DEST, DEST, 2

ASLOCAL(copyin_right_align_to_halfword)
	subu	LEN,  LEN,  1
#ifdef ERRATA__XXX_USR
	NOP
	ld.b.usr	%r5,  SRC, LEN
	NOP
	NOP
	NOP
#else
	ld.b.usr	%r5,  SRC, LEN
#endif
	br.n	_ASM_LABEL(copyin_right_aligned_to_halfword)
	 st.b	%r5,  DEST, LEN

ASLOCAL(copyin_right_align_to_word)
	subu	LEN,  LEN,  2
#ifdef ERRATA__XXX_USR
	NOP
	ld.h.usr	%r5,  SRC, LEN
	NOP
	NOP
	NOP
#else
	ld.h.usr	%r5,  SRC, LEN
#endif
	br.n	_ASM_LABEL(copyin_right_aligned_to_word)
	 st.h	%r5,  DEST, LEN

ASLOCAL(copyin_right_align_to_doubleword)
	subu	LEN,  LEN,  4
#ifdef ERRATA__XXX_USR
	NOP
	ld.usr	%r5,  SRC,  LEN
	NOP
	NOP
	NOP
#else
	ld.usr	%r5,  SRC,  LEN
#endif
	bcnd.n	ne0,  LEN, _ASM_LABEL(copyin_right_aligned_to_doubleword)
	 st	%r5,  DEST, LEN
	br.n	_ASM_LABEL(Lcidone)
   	 or	%r2, %r0, %r0	/* successful return */

ASLOCAL(copyin_byte_only)
	bcnd	eq0, LEN, 2f
1:
	subu	LEN, LEN, 1
#ifdef ERRATA__XXX_USR
	NOP
	ld.b.usr	%r5, SRC, LEN
	NOP
	NOP
	NOP
#else
	ld.b.usr	%r5, SRC, LEN
#endif
	bcnd.n	ne0, LEN, 1b
	 st.b	%r5, DEST, LEN
2:
	or	%r2, %r0, %r0	/* successful return */
	/* FALLTHROUGH */

ASLOCAL(Lcidone)
	ldcr	%r5,  CPU
	ld	%r6,  %r5,  CI_CURPCB
	jmp.n	%r1
	 st	%r0,  %r6,  PCB_ONFAULT

ASLOCAL(Lciflt)
	br.n	_ASM_LABEL(Lcidone)
	 or	%r2, %r0, EFAULT	/* return fault */

#undef	SRC
#undef	DEST
#undef	LEN

/*
 * Specific flavour for a single 32-bit word copy.
 * copyin32(from, to)
 *	r2 == from (user source address)
 *	r3 == to (kernel destination address)
 */

#define	SRC	%r2
#define	DEST	%r3

ENTRY(copyin32)
	/* check for source alignment */
	mask	%r8,  SRC,  0x3
	bcnd	ne0,  %r8,  _ASM_LABEL(copyin32_misaligned)

	/* set up fault handler */
	ldcr	%r5,  CPU
	ld	%r6,  %r5,  CI_CURPCB
	or.u	%r5,  %r0,  %hi16(_ASM_LABEL(Lciflt))
	or	%r5,  %r5,  %lo16(_ASM_LABEL(Lciflt))
	st	%r5,  %r6,  PCB_ONFAULT	/* pcb_onfault = Lciflt */

#ifdef ERRATA__XXX_USR
	NOP
	ld.usr	%r5,  SRC,  %r0
	NOP
	NOP
	NOP
#else
	ld.usr	%r5,  SRC,  %r0
#endif
	st	%r5,  DEST, %r0
	br.n	_ASM_LABEL(Lcidone)
   	 or	%r2, %r0, %r0	/* successful return */

ASLOCAL(copyin32_misaligned)
	jmp.n	%r1
	 or	%r2, %r0, EFAULT	/* return fault */

#undef	SRC
#undef	DEST

/*######################################################################*/
/*######################################################################*/

/*
 * Copy a null terminated string from the user space to the kernel
 * address space.
 *
 * copyinstr(from, to, maxlen, &lencopied)
 * r2 == from
 * r3 == to
 * r4 == maxlen
 * r5 == len actually transferred (includes the terminating NUL!!!)
 * r6 & r7 - used as temporaries
 */
#define	SRC	%r2
#define	DEST	%r3
#define	CNT	%r4
#define	LEN	%r5

ENTRY(copyinstr)

	/* setup fault handler */
	ldcr	%r6,  CPU
	ld	%r7,  %r6,   CI_CURPCB
	or.u	%r6,  %r0,   %hi16(_ASM_LABEL(Lcisflt))
	or	%r6,  %r6,   %lo16(_ASM_LABEL(Lcisflt))
	st	%r6,  %r7,   PCB_ONFAULT
	or	%r6,  %r0,   0
	bcnd	lt0,  CNT,  _ASM_LABEL(Lcisflt)
	bcnd	eq0,  CNT,  _ASM_LABEL(Lcistoolong)
1:
#ifdef ERRATA__XXX_USR
	NOP
	ld.bu.usr	%r7,  SRC, %r6
	NOP
	NOP
	NOP
#else
	ld.bu.usr	%r7,  SRC,  %r6
#endif
	st.b	%r7,  DEST, %r6
	bcnd.n	eq0,  %r7,  2f		/* all done */
	 addu	%r6,  %r6,  1
	cmp	%r7,  %r6,  CNT
	bb1	lt,   %r7,  1b

ASLOCAL(Lcistoolong)
	or	%r2,   %r0, ENAMETOOLONG	/* overflow */

ASLOCAL(Lcisnull)
	bcnd	eq0,%r6, _ASM_LABEL(Lcisdone)	/* do not attempt to clear last byte */
					/* if we did not write to the string */
	subu	%r6,  %r6,  1
	st.b	%r0,  DEST, %r6		/* clear last byte */
	br.n	_ASM_LABEL(Lcisdone)
	 addu	%r6,  %r6,  1
2:					/* all done */
	or	%r2,  %r0,  0

ASLOCAL(Lcisdone)
	bcnd	eq0, LEN, 3f
	st	%r6, %r0, LEN
3:
	ldcr	%r5,  CPU
	ld	%r6,  %r5,  CI_CURPCB
	jmp.n	%r1
	 st	%r0,  %r6,  PCB_ONFAULT	/* clear the handler */

ASLOCAL(Lcisflt)
	br.n	_ASM_LABEL(Lcisnull)
	 or	%r2,  %r0,  EFAULT	/* return fault */

#undef	SRC
#undef	DEST
#undef	CNT
#undef	LEN

/*
 * Copy specified amount of data from kernel to the user space
 * Copyout(from, to, len)
 *	r2 == from (kernel source address)
 *	r3 == to (user destination address)
 *	r4 == length
 */

#define	SRC	%r2
#define	DEST	%r3
#define	LEN	%r4

ENTRY(copyout)
	/* setup fault handler */
	ldcr	%r5,  CPU
	ld	%r6,  %r5,  CI_CURPCB
	or.u	%r5,  %r0,  %hi16(_ASM_LABEL(Lcoflt))
	or	%r5,  %r5,  %lo16(_ASM_LABEL(Lcoflt))
	st	%r5,  %r6,  PCB_ONFAULT	/* pcb_onfault = Lcoflt */

	/*
	 * If it's a small length (less than 8), then do byte-by-byte.
	 * Despite not being optimal if len is 4, and from and to
	 * are word-aligned, this is still faster than doing more tests
	 * to save an hyperthetical fraction of cycle.
	 */
	cmp	%r9,  LEN,  8
	bb1	lt,   %r9,   _ASM_LABEL(copyout_byte_only)

	/* If they're not aligned similarly, use byte only... */
	xor	%r9,  SRC,  DEST
	mask	%r8,  %r9,  0x3
	bcnd	ne0,  %r8,  _ASM_LABEL(copyout_byte_only)

	/*
	 * At this point, we don't know if they're word aligned or not,
	 * but we know that what needs to be done to one to align
	 * it is what's needed for the other.
	 */
	bb1	0,    SRC,  _ASM_LABEL(copyout_left_align_to_halfword)
ASLOCAL(copyout_left_aligned_to_halfword)
	bb1	1,    SRC,  _ASM_LABEL(copyout_left_align_to_word)
ASLOCAL(copyout_left_aligned_to_word)
	bb1	0,    LEN,  _ASM_LABEL(copyout_right_align_to_halfword)
ASLOCAL(copyout_right_aligned_to_halfword)
	bb1	1,    LEN,  _ASM_LABEL(copyout_right_align_to_word)
ASLOCAL(copyout_right_aligned_to_word)

	/*
	 * At this point, both SRC and DEST are aligned to a word
	 * boundary, and LEN is a multiple of 4. We want it an even
	 * multiple of 4.
	 */
	bb1.n	2,    LEN,  _ASM_LABEL(copyout_right_align_to_doubleword)
	 or	%r7,  %r0,  4

ASLOCAL(copyout_right_aligned_to_doubleword)
	ld 	%r5,  SRC,  %r0
	ld    	%r6,  SRC,  %r7
	subu	LEN,  LEN,  8
#ifdef ERRATA__XXX_USR
	NOP
	st.usr	%r5,  DEST, %r0
	NOP
	NOP
	NOP
#else
	st.usr	%r5,  DEST, %r0
#endif
	addu	SRC,  SRC,  8
#ifdef ERRATA__XXX_USR
	NOP
	st.usr	%r6,  DEST, %r7
	NOP
	NOP
	NOP
#else
	st.usr	%r6,  DEST, %r7
#endif
	bcnd.n	ne0,  LEN,  _ASM_LABEL(copyout_right_aligned_to_doubleword)
	 addu	DEST, DEST, 8
	or	%r2,  %r0,  %r0	/* successful return */
	br	_ASM_LABEL(Lcodone)

	/***************************************************/
ASLOCAL(copyout_left_align_to_halfword)
	ld.b	%r5,  SRC,  %r0
	subu	LEN,  LEN,  1
#ifdef ERRATA__XXX_USR
	NOP
	st.b.usr	%r5,  DEST, %r0
	NOP
	NOP
	NOP
#else
	st.b.usr	%r5,  DEST, %r0
#endif
	addu	SRC,  SRC,  1
	br.n	_ASM_LABEL(copyout_left_aligned_to_halfword)
	 addu	DEST, DEST, 1

ASLOCAL(copyout_left_align_to_word)
	ld.h	%r5,  SRC,  %r0
	subu	LEN,  LEN,  2
#ifdef ERRATA__XXX_USR
	NOP
	st.h.usr	%r5,  DEST, %r0
	NOP
	NOP
	NOP
#else
	st.h.usr	%r5,  DEST, %r0
#endif
	addu	SRC,  SRC,  2
	br.n	_ASM_LABEL(copyout_left_aligned_to_word)
	 addu	DEST, DEST, 2

ASLOCAL(copyout_right_align_to_halfword)
	subu	LEN,  LEN,  1
	ld.b	%r5,  SRC,  LEN
#ifdef ERRATA__XXX_USR
	NOP
	st.b.usr	%r5,  DEST, LEN
	NOP
	NOP
	NOP
	br	_ASM_LABEL(copyout_right_aligned_to_halfword)
#else
	br.n	_ASM_LABEL(copyout_right_aligned_to_halfword)
	 st.b.usr	%r5,  DEST, LEN
#endif

ASLOCAL(copyout_right_align_to_word)
	subu	LEN,  LEN,  2
	ld.h	%r5,  SRC,  LEN
#ifdef ERRATA__XXX_USR
	NOP
	st.h.usr	%r5,  DEST, LEN
	NOP
	NOP
	NOP
	br	_ASM_LABEL(copyout_right_aligned_to_word)
#else
	br.n	_ASM_LABEL(copyout_right_aligned_to_word)
	 st.h.usr	%r5,  DEST, LEN
#endif

ASLOCAL(copyout_right_align_to_doubleword)
	subu	LEN,  LEN,  4
	ld	%r5,  SRC,  LEN
#ifdef ERRATA__XXX_USR
	NOP
	st.usr	%r5,  DEST, LEN
	NOP
	NOP
	NOP
	bcnd	ne0,  LEN, _ASM_LABEL(copyout_right_aligned_to_doubleword)
#else
	bcnd.n	ne0,  LEN, _ASM_LABEL(copyout_right_aligned_to_doubleword)
	 st.usr	%r5,  DEST, LEN
#endif
	br.n	_ASM_LABEL(Lcodone)
	 or	%r2, %r0, %r0	/* successful return */

ASLOCAL(copyout_byte_only)
	bcnd	eq0, LEN, 2f
1:
	subu	LEN, LEN, 1
	ld.b	%r5, SRC, LEN
#ifdef ERRATA__XXX_USR
	NOP
	st.b.usr	%r5, DEST, LEN
	NOP
	NOP
	NOP
	bcnd	ne0, LEN, 1b
#else
	bcnd.n	ne0, LEN, 1b
	 st.b.usr	%r5, DEST, LEN
#endif

2:
	or	%r2, %r0, %r0	/* successful return */
	/* FALLTHROUGH */

ASLOCAL(Lcodone)
	ldcr	%r5,  CPU
	ld	%r6,  %r5,  CI_CURPCB
	jmp.n	%r1
	 st	%r0,  %r6,  PCB_ONFAULT	/* clear the handler */

ASLOCAL(Lcoflt)
	br.n	_ASM_LABEL(Lcodone)
	 or	%r2, %r0, EFAULT	/* return fault */

#undef	SRC
#undef	DEST
#undef	LEN

/*
 * Copy a null terminated string from the kernel space to the user
 * address space.
 *
 * copyoutstr(from, to, maxlen, &lencopied)
 * r2 == from
 * r3 == to
 * r4 == maxlen that can be copied
 * r5 == len actually copied (including the terminating NUL!!!)
 */

#define	SRC	%r2
#define	DEST	%r3
#define	CNT	%r4
#define	LEN	%r5

ENTRY(copyoutstr)
	/* setup fault handler */
	ldcr	%r6,  CPU
	ld	%r7,  %r6,  CI_CURPCB
	or.u	%r6,  %r0,  %hi16(_ASM_LABEL(Lcosflt))
	or	%r6,  %r6,  %lo16(_ASM_LABEL(Lcosflt))
	st	%r6,  %r7,  PCB_ONFAULT
	bcnd	lt0,  CNT,  _ASM_LABEL(Lcosflt)
	bcnd	eq0,  CNT,  _ASM_LABEL(Lcosdone)
	or	%r6,  %r0,  0
1:
	ld.bu	%r7,  SRC,  %r6
#ifdef ERRATA__XXX_USR
	NOP
	st.b.usr	%r7,  DEST,  %r6
	NOP
	NOP
	NOP
#else
	st.b.usr	%r7,  DEST,  %r6
#endif
	bcnd.n	eq0,  %r7, 2f		/* all done */
	 addu	%r6,  %r6, 1
	cmp	%r7,  %r6, CNT
	bb1	lt,   %r7, 1b
	br.n	_ASM_LABEL(Lcosdone)
	 or	%r2,  %r0, ENAMETOOLONG
2:
	br.n	_ASM_LABEL(Lcosdone)
	 or	%r2,  %r0, 0

ASLOCAL(Lcosflt)
	br.n	_ASM_LABEL(Lcosdone)
	 or	%r2, %r0, EFAULT

ASLOCAL(Lcosdone)
	bcnd	eq0, LEN, 3f
	st	%r6, %r0, LEN
3:
	ldcr	%r5, CPU
	ld	%r6, %r5, CI_CURPCB
	jmp.n	%r1
	 st	%r0, %r6, PCB_ONFAULT	/* clear the handler */

#undef	SRC
#undef	DEST
#undef	CNT
#undef	LEN

/*######################################################################*/

/*
 * kcopy(const void *src, void *dst, size_t len);
 *
 * Copy len bytes from src to dst, aborting if we encounter a page fault.
 */
ENTRY(kcopy)
	subu	%r31, %r31, 16
	ldcr	%r5,  CPU
	ld	%r6,  %r5,  CI_CURPCB
	or.u	%r5,  %r0,  %hi16(_ASM_LABEL(kcopy_fault))
	ld	%r7,  %r6,  PCB_ONFAULT
	or	%r5,  %r5,  %lo16(_ASM_LABEL(kcopy_fault))
	st	%r7,  %r31, 0			/* save old pcb_onfault */
	st	%r5,  %r6,  PCB_ONFAULT		/* pcb_onfault = kcopy_fault */
	bcnd	le0,  %r4,  _ASM_LABEL(kcopy_out) /* nothing to do if <= 0 */
/*
 *	check position of source and destination data
 */
	cmp 	%r9,  %r2,  %r3	/* compare source address to destination */
	bb1	eq,   %r9,  _ASM_LABEL(kcopy_out) /* nothing to do if equal */
	bb1	lo,   %r9,  _ASM_LABEL(kcopy_reverse) /* reverse copy if src < dest */
/*
 *	source address is greater than destination address, copy forward
 */
	cmp 	%r9,  %r4,  16	/* see if we have at least 16 bytes */
	bb1	lt,   %r9,  _ASM_LABEL(kf_byte_copy)	/* copy bytes for small length */
/*
 *	determine copy strategy based on alignment of source and destination
 */
	mask	%r6,  %r2,  3	/* get 2 low order bits of source address */
	mask	%r7,  %r3,  3	/* get 2 low order bits of destination addr */
	mak	%r6,  %r6,  0<4>/* convert source bits to table offset */
	mak	%r7,  %r7,  0<2>/* convert destination bits to table offset */
	or.u	%r12, %r0,  %hi16(_ASM_LABEL(kf_strat))
	or	%r12, %r12, %lo16(_ASM_LABEL(kf_strat))
	addu	%r6,  %r6,  %r7	/* compute final table offset for strategy */
	ld	%r12, %r12, %r6	/* load the strategy routine */
	jmp	%r12		/* branch to strategy routine */

/*
 * Copy three bytes from src to destination then copy words
 */
ASLOCAL(kf_3byte_word_copy)
	ld.bu	%r6,  %r2,  0		/* load byte from source */
	ld.bu	%r7,  %r2,  1		/* load byte from source */
	ld.bu	%r8,  %r2,  2		/* load byte from source */
	st.b	%r6,  %r3,  0		/* store byte to destination */
	st.b	%r7,  %r3,  1		/* store byte to destination */
	st.b	%r8,  %r3,  2		/* store byte to destination */
	addu	%r2,  %r2,  3		/* increment source pointer */
	addu	%r3,  %r3,  3		/* increment destination pointer */
	br.n	_ASM_LABEL(kf_word_copy)/* copy full words */
	 subu	%r4,  %r4,  3		/* decrement length */

/*
 * Copy 1 halfword from src to destination then copy words
 */
ASLOCAL(kf_1half_word_copy)
	ld.hu	%r6,  %r2,  0		/* load half-word from source */
	st.h	%r6,  %r3,  0		/* store half-word to destination */
	addu	%r2,  %r2,  2		/* increment source pointer */
	addu	%r3,  %r3,  2		/* increment destination pointer */
	br.n	_ASM_LABEL(kf_word_copy)/* copy full words */
	 subu	%r4,  %r4,  2		/* decrement remaining length */

/*
 * Copy 1 byte from src to destination then copy words
 */
ASLOCAL(kf_1byte_word_copy)
	ld.bu	%r6,  %r2,  0		/* load 1 byte from source */
	st.b	%r6,  %r3,  0		/* store 1 byte to destination */
	addu	%r2,  %r2,  1		/* increment source pointer */
	addu	%r3,  %r3,  1		/* increment destination pointer */
	subu	%r4,  %r4,  1		/* decrement remaining length */
	/* fall through to word copy */
/*
 * Copy as many full words as possible, 4 words per loop
 */
ASLOCAL(kf_word_copy)
	cmp	%r10, %r4,  16		/* see if we have 16 bytes remaining */
	bb1	lo,   %r10, _ASM_LABEL(kf_byte_copy) 	/* not enough left, copy bytes */
	ld	%r6,  %r2,  0		/* load first word */
	ld	%r7,  %r2,  4		/* load second word */
	ld	%r8,  %r2,  8		/* load third word */
	ld	%r9,  %r2,  12		/* load fourth word */
	st	%r6,  %r3,  0		/* store first word */
	st	%r7,  %r3,  4		/* store second word */
	st 	%r8,  %r3,  8		/* store third word */
	st 	%r9,  %r3,  12		/* store fourth word */
	addu	%r2,  %r2,  16		/* increment source pointer */
	addu	%r3,  %r3,  16		/* increment destination pointer */
	br.n	_ASM_LABEL(kf_word_copy)/* copy another block */
	 subu	%r4,  %r4,  16		/* decrement remaining length */

ASLOCAL(kf_1byte_half_copy)
	ld.bu	%r6,  %r2,  0		/* load 1 byte from source */
	st.b	%r6,  %r3,  0		/* store 1 byte to destination */
	addu	%r2,  %r2,  1		/* increment source pointer */
	addu	%r3,  %r3,  1		/* increment destination pointer */
	subu	%r4,  %r4,  1		/* decrement remaining length */
	/* fall through to half copy */

ASLOCAL(kf_half_copy)
	cmp	%r10, %r4,  16		/* see if we have 16 bytes remaining */
	bb1	lo,   %r10, _ASM_LABEL(kf_byte_copy)	/* not enough left, copy bytes */
	ld.hu	%r6,  %r2,  0		/* load first half-word */
	ld.hu	%r7,  %r2,  2		/* load second half-word */
	ld.hu	%r8,  %r2,  4		/* load third half-word */
	ld.hu	%r9,  %r2,  6		/* load fourth half-word */
	ld.hu	%r10, %r2,  8		/* load fifth half-word */
	ld.hu	%r11, %r2,  10		/* load sixth half-word */
	ld.hu	%r12, %r2,  12		/* load seventh half-word */
	ld.hu	%r13, %r2,  14		/* load eighth half-word */
	st.h	%r6,  %r3,  0		/* store first half-word */
	st.h	%r7,  %r3,  2		/* store second half-word */
	st.h 	%r8,  %r3,  4		/* store third half-word */
	st.h 	%r9,  %r3,  6		/* store fourth half-word */
	st.h	%r10, %r3,  8		/* store fifth half-word */
	st.h	%r11, %r3,  10		/* store sixth half-word */
	st.h 	%r12, %r3,  12		/* store seventh half-word */
	st.h 	%r13, %r3,  14		/* store eighth half-word */
	addu	%r2,  %r2,  16		/* increment source pointer */
	addu	%r3,  %r3,  16		/* increment destination pointer */
	br.n	_ASM_LABEL(kf_half_copy)/* copy another block */
	 subu	%r4,  %r4,  16		/* decrement remaining length */

ASLOCAL(kf_byte_copy)
	bcnd	eq0,  %r4,  _ASM_LABEL(kcopy_out)	/* branch if nothing left to copy */
	ld.bu	%r6,  %r2,  0		/* load byte from source */
	st.b	%r6,  %r3,  0		/* store byte in destination */
	addu	%r2,  %r2,  1		/* increment source pointer */
	addu	%r3,  %r3,  1		/* increment destination pointer */
	br.n	_ASM_LABEL(kf_byte_copy)/* branch for next byte */
	 subu	%r4,  %r4,  1		/* decrement remaining length */

/*
 *	source address is less than destination address, copy in reverse
 */
ASLOCAL(kcopy_reverse)
/*
 * start copy pointers at end of data
 */
	addu	%r2,  %r2,  %r4		/* start source at end of data */
	addu	%r3,  %r3,  %r4		/* start destination at end of data */
/*
 * check for short data
 */
	cmp 	%r9,  %r4,  16		/* see if we have at least 16 bytes */
	bb1	lt,   %r9,  _ASM_LABEL(kr_byte_copy)	/* copy bytes for small data length */
/*
 *	determine copy strategy based on alignment of source and destination
 */
	mask	%r6,  %r2,  3	/* get 2 low order bits of source address */
	mask	%r7,  %r3,  3	/* get 2 low order bits of destination addr */
	mak	%r6,  %r6,  0<4>/* convert source bits to table offset */
	mak	%r7,  %r7,  0<2>/* convert destination bits to table offset */
	or.u	%r12, %r0,  %hi16(_ASM_LABEL(kr_strat))
	or	%r12, %r12, %lo16(_ASM_LABEL(kr_strat))
	addu	%r6,  %r6,  %r7	/* compute final table offset for strategy */
	ld	%r12, %r12, %r6	/* load the strategy routine */
	jmp	%r12		/* branch to strategy routine */

/*
 * Copy three bytes from src to destination then copy words
 */
ASLOCAL(kr_3byte_word_copy)
	subu	%r2,  %r2,  3		/* decrement source pointer */
	subu	%r3,  %r3,  3		/* decrement destination pointer */
	ld.bu	%r6,  %r2,  0		/* load byte from source */
	ld.bu	%r7,  %r2,  1		/* load byte from source */
	ld.bu	%r8,  %r2,  2		/* load byte from source */
	st.b	%r6,  %r3,  0		/* store byte to destination */
	st.b	%r7,  %r3,  1		/* store byte to destination */
	st.b	%r8,  %r3,  2		/* store byte to destination */
	br.n	_ASM_LABEL(kr_word_copy)/* copy full words */
	 subu	%r4,  %r4,  3		/* decrement length */

/*
 * Copy 1 halfword from src to destination then copy words
 */
ASLOCAL(kr_1half_word_copy)
	subu	%r2,  %r2,  2		/* decrement source pointer */
	subu	%r3,  %r3,  2		/* decrement destination pointer */
	ld.hu	%r6,  %r2,  0		/* load half-word from source */
	st.h	%r6,  %r3,  0		/* store half-word to destination */
	br.n	_ASM_LABEL(kr_word_copy)/* copy full words */
	 subu	%r4,  %r4,  2		/* decrement remaining length */

/*
 * Copy 1 byte from src to destination then copy words
 */
ASLOCAL(kr_1byte_word_copy)
	subu	%r2,  %r2,  1		/* decrement source pointer */
	subu	%r3,  %r3,  1		/* decrement destination pointer */
	ld.bu	%r6,  %r2,  0		/* load 1 byte from source */
	st.b	%r6,  %r3,  0		/* store 1 byte to destination */
	subu	%r4,  %r4,  1		/* decrement remaining length */
	/* fall through to word copy */
/*
 * Copy as many full words as possible, 4 words per loop
 */
ASLOCAL(kr_word_copy)
	cmp	%r10, %r4,  16		/* see if we have 16 bytes remaining */
	bb1	lo,   %r10, _ASM_LABEL(kr_byte_copy)	/* not enough left, copy bytes */
	subu	%r2,  %r2,  16		/* decrement source pointer */
	subu	%r3,  %r3,  16		/* decrement destination pointer */
	ld	%r6,  %r2,  0		/* load first word */
	ld	%r7,  %r2,  4		/* load second word */
	ld	%r8,  %r2,  8		/* load third word */
	ld	%r9,  %r2,  12		/* load fourth word */
	st	%r6,  %r3,  0		/* store first word */
	st	%r7,  %r3,  4		/* store second word */
	st 	%r8,  %r3,  8		/* store third word */
	st 	%r9,  %r3,  12		/* store fourth word */
	br.n	_ASM_LABEL(kr_word_copy)/* copy another block */
	 subu	%r4,  %r4,  16	/* decrement remaining length */

ASLOCAL(kr_1byte_half_copy)
	subu	%r2,  %r2,  1		/* decrement source pointer */
	subu	%r3,  %r3,  1		/* decrement destination pointer */
	ld.bu	%r6,  %r2,  0		/* load 1 byte from source */
	st.b	%r6,  %r3,  0		/* store 1 byte to destination */
	subu	%r4,  %r4,  1		/* decrement remaining length */
	/* fall through to half copy */

ASLOCAL(kr_half_copy)
	cmp	%r10, %r4,  16		/* see if we have 16 bytes remaining */
	bb1	lo,   %r10, _ASM_LABEL(kr_byte_copy)	/* not enough left, copy bytes */
	subu	%r2,  %r2,  16		/* decrement source pointer */
	subu	%r3,  %r3,  16		/* decrement destination pointer */
	ld.hu	%r6,  %r2,  0		/* load first half-word */
	ld.hu	%r7,  %r2,  2		/* load second half-word */
	ld.hu	%r8,  %r2,  4		/* load third half-word */
	ld.hu	%r9,  %r2,  6		/* load fourth half-word */
	ld.hu	%r10, %r2,  8		/* load fifth half-word */
	ld.hu	%r11, %r2,  10		/* load sixth half-word */
	ld.hu	%r12, %r2,  12		/* load seventh half-word */
	ld.hu	%r13, %r2,  14		/* load eighth half-word */
	st.h	%r6,  %r3,  0		/* store first half-word */
	st.h	%r7,  %r3,  2		/* store second half-word */
	st.h 	%r8,  %r3,  4		/* store third half-word */
	st.h 	%r9,  %r3,  6		/* store fourth half-word */
	st.h	%r10, %r3,  8		/* store fifth half-word */
	st.h	%r11, %r3,  10		/* store sixth half-word */
	st.h 	%r12, %r3,  12		/* store seventh half-word */
	st.h 	%r13, %r3,  14		/* store eighth half-word */
	br.n	_ASM_LABEL(kr_half_copy)/* copy another block */
	 subu	%r4,  %r4,  16		/* decrement remaining length */

ASLOCAL(kr_byte_copy)
	bcnd	eq0,  %r4,  _ASM_LABEL(kcopy_out)	/* branch if nothing left to copy */
	subu	%r2,  %r2,  1		/* decrement source pointer */
	subu	%r3,  %r3,  1		/* decrement destination pointer */
	ld.bu	%r6,  %r2,  0		/* load byte from source */
	st.b	%r6,  %r3,  0		/* store byte in destination */
	br.n	_ASM_LABEL(kr_byte_copy)/* branch for next byte */
	 subu	%r4,  %r4,  1		/* decrement remaining length */

ASLOCAL(kcopy_out)
	or	%r2,   %r0,  0		/* return success */
ASLOCAL(kcopy_out_fault)
	ldcr	%r5,  CPU
	ld	%r7,  %r31, 0
	ld	%r6,  %r5,  CI_CURPCB
	add	%r31, %r31, 16
	jmp.n	%r1			/* all done, return to caller */
	 st	%r7,  %r6,  PCB_ONFAULT	/* restore previous pcb_onfault */

ASLOCAL(kcopy_fault)
	br.n	_ASM_LABEL(kcopy_out_fault)
	 or	%r2,  %r0,  EFAULT	/* return fault */

	.data
	.align	2
ASLOCAL(kf_strat)
	.word	_ASM_LABEL(kf_word_copy)
	.word	_ASM_LABEL(kf_byte_copy)
	.word	_ASM_LABEL(kf_half_copy)
	.word	_ASM_LABEL(kf_byte_copy)
	.word	_ASM_LABEL(kf_byte_copy)
	.word	_ASM_LABEL(kf_3byte_word_copy)
	.word	_ASM_LABEL(kf_byte_copy)
	.word	_ASM_LABEL(kf_1byte_half_copy)
	.word	_ASM_LABEL(kf_half_copy)
	.word	_ASM_LABEL(kf_byte_copy)
	.word	_ASM_LABEL(kf_1half_word_copy)
	.word	_ASM_LABEL(kf_byte_copy)
	.word	_ASM_LABEL(kf_byte_copy)
	.word	_ASM_LABEL(kf_1byte_half_copy)
	.word	_ASM_LABEL(kf_byte_copy)
	.word	_ASM_LABEL(kf_1byte_word_copy)

ASLOCAL(kr_strat)
	.word	_ASM_LABEL(kr_word_copy)
	.word	_ASM_LABEL(kr_byte_copy)
	.word	_ASM_LABEL(kr_half_copy)
	.word	_ASM_LABEL(kr_byte_copy)
	.word	_ASM_LABEL(kr_byte_copy)
	.word	_ASM_LABEL(kr_1byte_word_copy)
	.word	_ASM_LABEL(kr_byte_copy)
	.word	_ASM_LABEL(kr_1byte_half_copy)
	.word	_ASM_LABEL(kr_half_copy)
	.word	_ASM_LABEL(kr_byte_copy)
	.word	_ASM_LABEL(kr_1half_word_copy)
	.word	_ASM_LABEL(kr_byte_copy)
	.word	_ASM_LABEL(kr_byte_copy)
	.word	_ASM_LABEL(kr_1byte_half_copy)
	.word	_ASM_LABEL(kr_byte_copy)
	.word	_ASM_LABEL(kr_3byte_word_copy)

#ifdef DDB
/*
 * non-local goto
 *	int setjmp(label_t *);
 *	void longjmp(label_t*);
 */
ENTRY(setjmp)
	st	%r1,  %r2, 0
	st	%r14, %r2, 4
	st	%r15, %r2, 2*4
	st	%r16, %r2, 3*4
	st	%r17, %r2, 4*4
	st	%r18, %r2, 5*4
	st	%r19, %r2, 6*4
	st	%r20, %r2, 7*4
	st	%r21, %r2, 8*4
	st	%r22, %r2, 9*4
	st	%r23, %r2, 10*4
	st	%r24, %r2, 11*4
	st	%r25, %r2, 12*4
	st	%r26, %r2, 13*4
	st	%r27, %r2, 14*4
	st	%r28, %r2, 15*4
	st	%r29, %r2, 16*4
	st	%r30, %r2, 17*4
	st	%r31, %r2, 18*4
	jmp.n	%r1
	 or	%r2,  %r0, %r0

ENTRY(longjmp)
	ld	%r1,  %r2, 0
	ld	%r14, %r2, 4
	ld	%r15, %r2, 2*4
	ld	%r16, %r2, 3*4
	ld	%r17, %r2, 4*4
	ld	%r18, %r2, 5*4
	ld	%r19, %r2, 6*4
	ld	%r20, %r2, 7*4
	ld	%r21, %r2, 8*4
	ld	%r22, %r2, 9*4
	ld	%r23, %r2, 10*4
	ld	%r24, %r2, 11*4
	ld	%r25, %r2, 12*4
	ld	%r26, %r2, 13*4
	ld	%r27, %r2, 14*4
	ld	%r28, %r2, 15*4
	ld	%r29, %r2, 16*4
	ld	%r30, %r2, 17*4
	ld	%r31, %r2, 18*4
	jmp.n	%r1
	 or	%r2,  %r0, 1
#endif

/*
 * Signal trampoline code.
 * The kernel arranges for the handler to be invoked directly, and return
 * here.
 */
	 .section .rodata
	 .align	3
	 .type	sigcode,@@function
GLOBAL(sigcode)			/* r31 points to sigframe */
	ld	%r2,  %r31, 0	/* pick sigcontext* */
	or	%r13, %r0,  SYS_sigreturn
GLOBAL(sigcoderet)
	tb0	0,    %r0,  450	/* syscall trap, calling sigreturn */
	NOP			| failure return
#ifdef dontbother		/* sigreturn will not return unless it fails */
	NOP			| success return
#endif
	or	%r13, %r0,  SYS_exit
	tb0	0,    %r0,  450	/* syscall trap, exit */
	/*
	 * this never returns, but we need to provide fetchable instructions
	 * for the 88100 pipeline.
	 */
	NOP
	NOP
GLOBAL(esigcode)

GLOBAL(sigfill)
	tb0	0, %r0, 130	/* breakpoint */
GLOBAL(sigfillsiz)
	.word	_C_LABEL(sigfillsiz) - _C_LABEL(sigfill)

/*
 * Helper functions for pmap_copy_page() and pmap_zero_page().
 */

#ifdef M88100

/*
 * void copypage(vaddr_t src, vaddr_t dst);
 *
 * This copies PAGE_SIZE bytes from src to dst in 32 byte chunks.
 */
ENTRY(m8820x_copypage)
	addu	%r12, %r2, PAGE_SIZE
1:
	ld.d	%r4,  %r2, 0x00
	ld.d	%r6,  %r2, 0x08
	st.d	%r4,  %r3, 0x00
	ld.d	%r8,  %r2, 0x10
	st.d	%r6,  %r3, 0x08
	ld.d	%r10, %r2, 0x18
	st.d	%r8,  %r3, 0x10
	addu	%r2,  %r2, 0x20
	st.d	%r10, %r3, 0x18
	cmp	%r4,  %r2, %r12
	bb1.n	ne,   %r4, 1b
	 addu	%r3,  %r3, 0x20
	jmp	%r1

/*
 * void zeropage(vaddr_t dst);
 *
 * This zeroes PAGE_SIZE bytes from src to dst in 64 byte chunks.
 */
ENTRY(m8820x_zeropage)
	addu	%r12, %r2, PAGE_SIZE
	or	%r3,  %r1, %r0
	or	%r1,  %r0, %r0
1:
	st.d	%r0,  %r2, 0x00
	st.d	%r0,  %r2, 0x08
	st.d	%r0,  %r2, 0x10
	st.d	%r0,  %r2, 0x18
	st.d	%r0,  %r2, 0x20
	st.d	%r0,  %r2, 0x28
	st.d	%r0,  %r2, 0x30
	st.d	%r0,  %r2, 0x38
	addu	%r2,  %r2, 0x40
	cmp	%r4,  %r2, %r12
	bb1	ne,   %r4, 1b
	jmp	%r3

#endif	/* M88100 */

#ifdef M88110

/*
 * void copypage(vaddr_t src, vaddr_t dst);
 *
 * This copies PAGE_SIZE bytes from src to dst in 32 byte chunks (one
 * cache line).
 */
ENTRY(m88110_copypage)
	addu	%r12, %r2, PAGE_SIZE
1:
	ld.h	%r0,  %r2, 0x00	| load allocate
	ld.d	%r4,  %r2, 0x00
	ld.d	%r6,  %r2, 0x08
	st.d	%r4,  %r3, 0x00
	ld.d	%r8,  %r2, 0x10
	st.d	%r6,  %r3, 0x08
	ld.d	%r10, %r2, 0x18
	st.d	%r8,  %r3, 0x10
	addu	%r2,  %r2, 0x20
	st.d	%r10, %r3, 0x18
	cmp	%r4,  %r2, %r12
	addu	%r3,  %r3, 0x20
	bb1	ne,   %r4, 1b
	jmp	%r1

/*
 * void zeropage(vaddr_t dst);
 *
 * This zeroes PAGE_SIZE bytes from src to dst in 32 byte chunks.
 */
ENTRY(m88110_zeropage)
	addu	%r12, %r2, PAGE_SIZE
	or	%r3,  %r1, %r0
	or	%r1,  %r0, %r0
1:
	ld.h	%r0,  %r2, 0x00	| load allocate
	st.d	%r0,  %r2, 0x00
	st.d	%r0,  %r2, 0x08
	st.d	%r0,  %r2, 0x10
	st.d	%r0,  %r2, 0x18
	addu	%r2,  %r2, 0x20
	cmp	%r4,  %r2, %r12
	bb1	ne,   %r4, 1b
	jmp	%r3

#endif	/* M88110 */

/*
 * PSR initialization code, invoked from locore on every processor startup.
 */
ASENTRY(setup_psr)
	ldcr	%r2,  PID
	extu	%r3,  %r2, 8<8>

	/*
	 * Ensure that the PSR is as we like:
	 *	supervisor mode
	 *	big-endian byte ordering
	 *	concurrent operation allowed
	 *	carry bit clear (I don't think we really care about this)
	 *	FPU enabled
	 *	misaligned access raises an exception
	 *	interrupts disabled
	 *	shadow registers frozen
	 *
	 * The manual says not to disable interrupts and freeze shadowing
	 * at the same time because interrupts are not actually disabled
	 * until after the next instruction. Well, if an interrupt
	 * occurs now, we're in deep trouble anyway, so I'm going to do
	 * the two together.
	 *
	 * Upon a reset (or poweron, I guess), the PSR indicates:
	 *   supervisor mode
	 *   interrupts, shadowing, FPU, misaligned exception: all disabled
	 *
	 * We'll just construct our own turning on what we want.
	 *
	 *	jfriedl@@omron.co.jp
	 */

	cmp	%r4, %r3, CPU_88110
	bb1	eq,  %r4, 1f	/* if it's a mc88110, skip SSBR */
	stcr	%r0, SSBR	/* clear this for later */
1:
	stcr	%r0, SR1	/* clear the CPU flags */

	or.u	%r2, %r0, %hi16(KERNEL_PSR)
	or	%r2, %r2, %lo16(KERNEL_PSR)
	stcr	%r2, PSR
	FLUSH_PIPELINE

	jmp	%r1

/*
 * Update the VBR value.
 * This needs to be done with interrupts and shadowing disabled.
 */
GLOBAL(set_vbr)
	ldcr	%r3, PSR
	set	%r4, %r3, 1<PSR_INTERRUPT_DISABLE_BIT>
	set	%r4, %r4, 1<PSR_SHADOW_FREEZE_BIT>
	stcr	%r4, PSR
	FLUSH_PIPELINE

	stcr	%r2, VBR
	FLUSH_PIPELINE

#if defined(M88100) && defined(M88110)
	ldcr	%r2, PID
	extu	%r5, %r2, 8<8>
	cmp	%r4, %r5, CPU_88110
	bb1	eq,  %r4, 1f
#endif
#ifdef M88100
	/* 88100 */
	stcr	%r3, PSR
	FLUSH_PIPELINE
	jmp	%r1
#endif
#ifdef M88110
1:
	/* 88110 */
	stcr	%r1, EXIP
	stcr	%r3, EPSR
	RTE
#endif
@


1.26
log
@Add sc_cookie in sigcontext, as same as other ports.
From Miod Vallat, tested by him and me.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: subr.S,v 1.25 2016/05/10 18:39:46 deraadt Exp $	*/
d374 42
@


1.25
log
@SROP mitigation.  sendsig() stores a (per-process ^ &sigcontext) cookie
inside the sigcontext.  sigreturn(2) checks syscall entry was from the
exact PC addr in the (per-process ASLR) sigtramp, verifies the cookie,
and clears it to prevent sigcontext reuse.
not yet tested on landisk, sparc, *88k, socppc.
ok kettenis
@
text
@d1 1
a1 1
/* $OpenBSD: subr.S,v 1.24 2014/06/08 13:20:39 miod Exp $	*/
d1086 4
a1089 1
ENTRY(sigcode)			/* r31 points to sigframe */
d1092 1
a1093 2
	.globl  _C_LABEL(sigcoderet)
_C_LABEL(sigcoderet):
d1107 5
@


1.24
log
@Stop accepting system calls on trap vectors 128 and 129. Userland has not
been doing this since almost 1.5 years and there has been the 64-bit time_t
bump in between, so no old binary should remain.
@
text
@d1 1
a1 1
/* $OpenBSD: subr.S,v 1.23 2013/08/24 20:54:29 miod Exp $	*/
d1090 2
@


1.23
log
@Make sure do_xmem_* return the correct value. This fixes usage of fork()
in programs linked against libpthread on 88100 processors, where the parent
thread issueing fork() would spin.

Interestingly enough, this bug is not found in Mach, but has been introduced
by Nivas when porting to mvme88k, 18 years ago. DAE involving xmem are rare
enough for the issue to have survived so long (and once again, it was a
nightmare to track down).
@
text
@d1 1
a1 1
/* $OpenBSD: subr.S,v 1.22 2013/01/11 22:34:43 miod Exp $	*/
d1089 1
a1089 1
	tb0	0,    %r0,  128	/* syscall trap, calling sigreturn */
d1095 1
a1095 1
	tb0	0,    %r0,  128	/* syscall trap, exit */
@


1.22
log
@Do not use `#' to introduce comments anymore, as(1) will no longer support
this RSN.
@
text
@d1 1
a1 1
/* $OpenBSD: subr.S,v 1.21 2013/01/05 11:20:56 miod Exp $	*/
d154 1
d156 1
d160 4
a163 2
	jmp	%r1
#else
d165 1
a165 4
	 xmem.usr	%r3,%r2,%r0
#endif
1:	jmp.n	%r1
	 xmem	%r3,%r2,%r0
d171 1
d173 1
d177 4
a180 2
	jmp	%r1
#else
d182 1
a182 4
	 xmem.bu.usr	%r3,%r2,%r0
#endif
1:	jmp.n	%r1
	 xmem.bu	%r3,%r2,%r0
@


1.21
log
@Switch m88k ports to ELF.
@
text
@d1 1
a1 1
/* $OpenBSD: subr.S,v 1.20 2011/01/05 22:16:16 miod Exp $	*/
d1166 1
a1166 1
	ld.h	%r0,  %r2, 0x00	# load allocate
d1191 1
a1191 1
	ld.h	%r0,  %r2, 0x00	# load allocate
@


1.20
log
@Make copypage() and zeropage() per-cpu function pointers, and use a
different version on 88110, which does load allocate of
to-be-completely-overwritten cache lines.
@
text
@d1 1
a1 1
/* $OpenBSD: subr.S,v 1.19 2010/12/23 20:05:08 miod Exp $	*/
d55 1
a55 1
	bcnd	ne0,r3,1f
d58 1
a58 1
	ld.usr	r2,r2,r0
d62 1
a62 1
	jmp	r1
d64 2
a65 2
	jmp.n	r1
	 ld.usr	r2,r2,r0
d67 2
a68 2
1:	jmp.n	r1
	 ld	r2,r2,r0
d71 1
a71 1
	bcnd	ne0,r3,1f
d74 1
a74 1
	ld.h.usr	r2,r2,r0
d78 1
a78 1
	jmp	r1
d80 2
a81 2
	jmp.n	r1
	 ld.h.usr	r2,r2,r0
d83 2
a84 2
1:	jmp.n	r1
	 ld.h	r2,r2,r0
d87 1
a87 1
	bcnd	ne0,r3,1f
d90 1
a90 1
	ld.b.usr	r2,r2,r0
d94 1
a94 1
	jmp	r1
d96 2
a97 2
	jmp.n	r1
	 ld.b.usr	r2,r2,r0
d99 2
a100 2
1:	jmp.n	r1
	 ld.b	r2,r2,r0
d103 1
a103 1
	bcnd	ne0,r4,1f
d106 1
a106 1
	st.usr	r3,r2,r0
d110 1
a110 1
	jmp	r1
d112 2
a113 2
	jmp.n	r1
	 st.usr	r3,r2,r0
d115 2
a116 2
1:	jmp.n	r1
	 st	r3,r2,r0
d119 1
a119 1
	bcnd	ne0,r4,1f
d122 1
a122 1
	st.h.usr	r3,r2,r0
d126 1
a126 1
	jmp	r1
d128 2
a129 2
	jmp.n	r1
	 st.h.usr	r3,r2,r0
d131 2
a132 2
1:	jmp.n	r1
	 st.h	r3,r2,r0
d135 1
a135 1
	bcnd	ne0,r4,1f
d138 1
a138 1
	st.b.usr	r3,r2,r0
d142 1
a142 1
	jmp	r1
d144 2
a145 2
	jmp.n	r1
	 st.b.usr	r3,r2,r0
d147 2
a148 2
1:	jmp.n	r1
	 st.b	r3,r2,r0
d151 1
a151 1
	bcnd	ne0,r4,1f
d154 1
a154 1
	xmem.usr	r3,r2,r0
d158 1
a158 1
	jmp	r1
d160 2
a161 2
	jmp.n	r1
	 xmem.usr	r3,r2,r0
d163 2
a164 2
1:	jmp.n	r1
	 xmem	r3,r2,r0
d167 1
a167 1
	bcnd	ne0,r4,1f
d170 1
a170 1
	xmem.bu.usr	r3,r2,r0
d174 1
a174 1
	jmp	r1
d176 2
a177 2
	jmp.n	r1
	 xmem.bu.usr	r3,r2,r0
d179 2
a180 2
1:	jmp.n	r1
	 xmem.bu	r3,r2,r0
a189 1
 * (r1=return addr)
d192 3
a194 3
#define	SRC	r2
#define	DEST	r3
#define	LEN	r4
d198 5
a202 5
	ldcr	r5,   CPU
	ld	r6,   r5,   CI_CURPCB
	or.u	r5,   r0,   hi16(_ASM_LABEL(Lciflt))
	or	r5,   r5,   lo16(_ASM_LABEL(Lciflt))
	st	r5,   r6,   PCB_ONFAULT	/* pcb_onfault = Lciflt */
d210 2
a211 2
	cmp	r9,   LEN,  8
	bb1	lt,   r9,   _ASM_LABEL(copyin_byte_only)
d214 3
a216 3
	xor	r9,   SRC,  DEST
	mask	r8,   r9,   0x3
	bcnd	ne0,  r8,   _ASM_LABEL(copyin_byte_only)
d238 1
a238 1
	 or	r7,   r0,   4
d243 1
a243 1
	ld.usr	r5,   SRC,  r0
d247 1
a247 1
	ld.usr	r6,   SRC,  r7
d252 2
a253 2
	ld.usr	r5,   SRC,  r0
	ld.usr	r6,   SRC,  r7
d256 1
a256 1
	st	r5,   DEST, r0
d258 1
a258 1
	st	r6,   DEST, r7
d262 1
a262 1
	 or	r2, r0, r0	/* successful return */
d267 1
a267 1
	ld.b.usr	r5,   SRC,  r0
d272 1
a272 1
	ld.b.usr	r5,   SRC,  r0
d275 1
a275 1
	st.b	r5,   DEST, r0
d283 1
a283 1
	ld.h.usr	r5,   SRC,  r0
d288 1
a288 1
	ld.h.usr	r5,   SRC,  r0
d291 1
a291 1
	st.h	r5,   DEST, r0
d300 1
a300 1
	ld.b.usr	r5,   SRC,  LEN
d305 1
a305 1
	ld.b.usr	r5,   SRC,  LEN
d308 1
a308 1
	 st.b	r5,   DEST, LEN
d314 1
a314 1
	ld.h.usr	r5,   SRC,  LEN
d319 1
a319 1
	ld.h.usr	r5,   SRC,  LEN
d322 1
a322 1
	 st.h	r5,   DEST, LEN
d328 1
a328 1
	ld.usr	r5,   SRC,  LEN
d333 1
a333 1
	ld.usr	r5,   SRC,  LEN
d336 1
a336 1
	 st	r5,   DEST, LEN
d338 1
a338 1
   	 or	r2, r0, r0	/* successful return */
d346 1
a346 1
	ld.b.usr	r5, SRC, LEN
d351 1
a351 1
	ld.b.usr	r5, SRC, LEN
d354 1
a354 1
	 st.b	r5, DEST, LEN
d356 1
a356 1
	or	r2, r0, r0	/* successful return */
d360 4
a363 4
	ldcr	r5,   CPU
	ld	r6,   r5,   CI_CURPCB
	jmp.n	r1
	 st	r0,   r6,   PCB_ONFAULT
d367 1
a367 1
	 or	r2, r0, EFAULT	/* return fault */
d387 4
a390 4
#define	SRC	r2
#define	DEST	r3
#define	CNT	r4
#define	LEN	r5
d395 6
a400 6
	ldcr	r6,   CPU
	ld	r7,   r6,   CI_CURPCB
	or.u	r6,   r0,   hi16(_ASM_LABEL(Lcisflt))
	or	r6,   r6,   lo16(_ASM_LABEL(Lcisflt))
	st	r6,   r7,   PCB_ONFAULT
	or	r6,   r0,   0
d406 1
a406 1
	ld.bu.usr	r7,   SRC,  r6
d411 1
a411 1
	ld.bu.usr	r7,   SRC,  r6
d413 5
a417 5
	st.b	r7, DEST, r6
	bcnd.n	eq0,  r7, 2f		/* all done */
	 addu	r6,   r6, 1
	cmp	r7,   r6, CNT
	bb1	lt,   r7, 1b
d420 1
a420 1
	or	r2,   r0, ENAMETOOLONG	/* overflow */
d423 1
a423 1
	bcnd	eq0,r6, _ASM_LABEL(Lcisdone)	/* do not attempt to clear last byte */
d425 2
a426 2
	subu	r6,   r6, 1
	st.b	r0, DEST, r6		/* clear last byte */
d428 1
a428 1
	 addu	r6,   r6, 1
d430 1
a430 1
	or	r2,   r0, 0
d434 1
a434 1
	st	r6, r0, LEN
d436 4
a439 4
	ldcr	r5,   CPU
	ld	r6,   r5,   CI_CURPCB
	jmp.n	r1
	 st	r0,r6,PCB_ONFAULT	/* clear the handler */
d443 1
a443 1
	 or	r2, r0, EFAULT		/* return fault */
d458 3
a460 3
#define	SRC	r2
#define	DEST	r3
#define	LEN	r4
d464 5
a468 5
	ldcr	r5,   CPU
	ld	r6,   r5,   CI_CURPCB
	or.u	r5,   r0,   hi16(_ASM_LABEL(Lcoflt))
	or	r5,   r5,   lo16(_ASM_LABEL(Lcoflt))
	st	r5,   r6,   PCB_ONFAULT	/* pcb_onfault = Lcoflt */
d476 2
a477 2
	cmp	r9,   LEN,  8
	bb1	lt,   r9,   _ASM_LABEL(copyout_byte_only)
d480 3
a482 3
	xor	r9,   SRC,  DEST
	mask	r8,   r9,   0x3
	bcnd	ne0,  r8,   _ASM_LABEL(copyout_byte_only)
d504 1
a504 1
	 or	r7,   r0,   4
d507 2
a508 2
	ld 	r5,   SRC,  r0
	ld    	r6,   SRC,  r7
d512 1
a512 1
	st.usr	r5,   DEST, r0
d517 1
a517 1
	st.usr	r5,   DEST, r0
d522 1
a522 1
	st.usr	r6,   DEST, r7
d527 1
a527 1
	st.usr	r6,   DEST, r7
d531 1
a531 1
	or	r2, r0, r0	/* successful return */
d536 1
a536 1
	ld.b	r5,   SRC,  r0
d540 1
a540 1
	st.b.usr	r5,   DEST, r0
d545 1
a545 1
	st.b.usr	r5,   DEST, r0
d552 1
a552 1
	ld.h	r5,   SRC,  r0
d556 1
a556 1
	st.h.usr	r5,   DEST, r0
d561 1
a561 1
	st.h.usr	r5,   DEST, r0
d569 1
a569 1
	ld.b	r5,   SRC,  LEN
d572 1
a572 1
	st.b.usr	r5,   DEST, LEN
d579 1
a579 1
	 st.b.usr	r5,   DEST, LEN
d584 1
a584 1
	ld.h	r5,   SRC,  LEN
d587 1
a587 1
	st.h.usr	r5,   DEST, LEN
d594 1
a594 1
	 st.h.usr	r5,   DEST, LEN
d599 1
a599 1
	ld	r5,   SRC,  LEN
d602 1
a602 1
	st.usr	r5,   DEST, LEN
d609 1
a609 1
	 st.usr	r5,   DEST, LEN
d612 1
a612 1
	 or	r2, r0, r0	/* successful return */
d618 1
a618 1
	ld.b	r5, SRC, LEN
d621 1
a621 1
	st.b.usr	r5, DEST, LEN
d628 1
a628 1
	 st.b.usr	r5, DEST, LEN
d632 1
a632 1
	or	r2, r0, r0	/* successful return */
d636 4
a639 4
	ldcr	r5,   CPU
	ld	r6,   r5,   CI_CURPCB
	jmp.n	r1
	 st	r0,   r6,   PCB_ONFAULT	/* clear the handler */
d643 1
a643 1
	 or	r2, r0, EFAULT	/* return fault */
d660 4
a663 4
#define	SRC	r2
#define	DEST	r3
#define	CNT	r4
#define	LEN	r5
d667 5
a671 5
	ldcr	r6,   CPU
	ld	r7,   r6,   CI_CURPCB
	or.u	r6,   r0,   hi16(_ASM_LABEL(Lcosflt))
	or	r6,   r6,   lo16(_ASM_LABEL(Lcosflt))
	st	r6,   r7,   PCB_ONFAULT
d674 1
a674 1
	or	r6,   r0,   0
d676 1
a676 1
	ld.bu	r7,   SRC,  r6
d679 1
a679 1
	st.b.usr	r7,   DEST,  r6
d684 1
a684 1
	st.b.usr	r7,   DEST,  r6
d686 4
a689 4
	bcnd.n	eq0,  r7, 2f		/* all done */
	 addu	r6,   r6, 1
	cmp	r7,   r6, CNT
	bb1	lt,   r7, 1b
d691 1
a691 1
	 or	r2,   r0, ENAMETOOLONG
d694 1
a694 1
	 or	r2,   r0, 0
d698 1
a698 1
	 or	r2, r0, EFAULT
d702 1
a702 1
	st	r6, r0, LEN
d704 4
a707 4
	ldcr	r5,   CPU
	ld	r6,   r5,   CI_CURPCB
	jmp.n	r1
	 st	r0,   r6,   PCB_ONFAULT	/* clear the handler */
d722 9
a730 9
	subu	r31,  r31,  16
	ldcr	r5,   CPU
	ld	r6,   r5,   CI_CURPCB
	or.u	r5,   r0,   hi16(_ASM_LABEL(kcopy_fault))
	ld	r7,   r6,   PCB_ONFAULT
	or	r5,   r5,   lo16(_ASM_LABEL(kcopy_fault))
	st	r7,   r31,  0			/* save old pcb_onfault */
	st	r5,   r6,   PCB_ONFAULT		/* pcb_onfault = kcopy_fault */
	bcnd	le0,r4,_ASM_LABEL(kcopy_out)	/* nothing to do if <= 0 */
d734 3
a736 3
	cmp 	r9,r2,r3	/* compare source address to destination */
	bb1	eq,r9,_ASM_LABEL(kcopy_out)	/* nothing to do if equal */
	bb1	lo,r9,_ASM_LABEL(kcopy_reverse)	/* reverse copy if src < dest */
d740 2
a741 2
	cmp 	r9,r4,16	/* see if we have at least 16 bytes */
	bb1	lt,r9,_ASM_LABEL(kf_byte_copy)	/* copy bytes for small length */
d745 9
a753 9
	mask	r6,r2,3		/* get 2 low order bits of source address */
	mask	r7,r3,3		/* get 2 low order bits of destination addr */
	mak	r6,r6,0<4>	/* convert source bits to table offset */
	mak	r7,r7,0<2>	/* convert destination bits to table offset */
	or.u	r12,r0,hi16(_ASM_LABEL(kf_strat))
	or	r12,r12,lo16(_ASM_LABEL(kf_strat))
	addu	r6,r6,r7	/* compute final table offset for strategy */
	ld	r12,r12,r6	/* load the strategy routine */
	jmp	r12		/* branch to strategy routine */
d759 10
a768 10
	ld.bu	r6,r2,0		/* load byte from source */
	ld.bu	r7,r2,1		/* load byte from source */
	ld.bu	r8,r2,2		/* load byte from source */
	st.b	r6,r3,0		/* store byte to destination */
	st.b	r7,r3,1		/* store byte to destination */
	st.b	r8,r3,2		/* store byte to destination */
	addu	r2,r2,3		/* increment source pointer */
	addu	r3,r3,3		/* increment destination pointer */
	br.n	_ASM_LABEL(kf_word_copy)	/* copy full words */
	 subu	r4,r4,3		/* decrement length */
d774 6
a779 6
	ld.hu	r6,r2,0		/* load half-word from source */
	st.h	r6,r3,0		/* store half-word to destination */
	addu	r2,r2,2		/* increment source pointer */
	addu	r3,r3,2		/* increment destination pointer */
	br.n	_ASM_LABEL(kf_word_copy)	/* copy full words */
	 subu	r4,r4,2		/* decrement remaining length */
d785 5
a789 5
	ld.bu	r6,r2,0		/* load 1 byte from source */
	st.b	r6,r3,0		/* store 1 byte to destination */
	addu	r2,r2,1		/* increment source pointer */
	addu	r3,r3,1		/* increment destination pointer */
	subu	r4,r4,1		/* decrement remaining length */
d795 14
a808 14
	cmp	r10,r4,16	/* see if we have 16 bytes remaining */
	bb1	lo,r10,_ASM_LABEL(kf_byte_copy) 	/* not enough left, copy bytes */
	ld	r6,r2,0		/* load first word */
	ld	r7,r2,4		/* load second word */
	ld	r8,r2,8		/* load third word */
	ld	r9,r2,12	/* load fourth word */
	st	r6,r3,0		/* store first word */
	st	r7,r3,4		/* store second word */
	st 	r8,r3,8		/* store third word */
	st 	r9,r3,12	/* store fourth word */
	addu	r2,r2,16	/* increment source pointer */
	addu	r3,r3,16	/* increment destination pointer */
	br.n	_ASM_LABEL(kf_word_copy)	/* copy another block */
	 subu	r4,r4,16	/* decrement remaining length */
d811 5
a815 5
	ld.bu	r6,r2,0		/* load 1 byte from source */
	st.b	r6,r3,0		/* store 1 byte to destination */
	addu	r2,r2,1		/* increment source pointer */
	addu	r3,r3,1		/* increment destination pointer */
	subu	r4,r4,1		/* decrement remaining length */
d819 22
a840 22
	cmp	r10,r4,16	/* see if we have 16 bytes remaining */
	bb1	lo,r10,_ASM_LABEL(kf_byte_copy)	/* not enough left, copy bytes */
	ld.hu	r6,r2,0		/* load first half-word */
	ld.hu	r7,r2,2		/* load second half-word */
	ld.hu	r8,r2,4		/* load third half-word */
	ld.hu	r9,r2,6		/* load fourth half-word */
	ld.hu	r10,r2,8	/* load fifth half-word */
	ld.hu	r11,r2,10	/* load sixth half-word */
	ld.hu	r12,r2,12	/* load seventh half-word */
	ld.hu	r13,r2,14	/* load eighth half-word */
	st.h	r6,r3,0		/* store first half-word */
	st.h	r7,r3,2		/* store second half-word */
	st.h 	r8,r3,4		/* store third half-word */
	st.h 	r9,r3,6		/* store fourth half-word */
	st.h	r10,r3,8	/* store fifth half-word */
	st.h	r11,r3,10	/* store sixth half-word */
	st.h 	r12,r3,12	/* store seventh half-word */
	st.h 	r13,r3,14	/* store eighth half-word */
	addu	r2,r2,16	/* increment source pointer */
	addu	r3,r3,16	/* increment destination pointer */
	br.n	_ASM_LABEL(kf_half_copy)	/* copy another block */
	 subu	r4,r4,16	/* decrement remaining length */
d843 7
a849 7
	bcnd	eq0,r4,_ASM_LABEL(kcopy_out)	/* branch if nothing left to copy */
	ld.bu	r6,r2,0		/* load byte from source */
	st.b	r6,r3,0		/* store byte in destination */
	addu	r2,r2,1		/* increment source pointer */
	addu	r3,r3,1		/* increment destination pointer */
	br.n	_ASM_LABEL(kf_byte_copy)	/* branch for next byte */
	 subu	r4,r4,1		/* decrement remaining length */
d858 2
a859 2
	addu	r2,r2,r4	/* start source at end of data */
	addu	r3,r3,r4	/* start destination at end of data */
d863 2
a864 2
	cmp 	r9,r4,16	/* see if we have at least 16 bytes */
	bb1	lt,r9,_ASM_LABEL(kr_byte_copy)	/* copy bytes for small data length */
d868 9
a876 9
	mask	r6,r2,3		/* get 2 low order bits of source address */
	mask	r7,r3,3		/* get 2 low order bits of destination addr */
	mak	r6,r6,0<4>	/* convert source bits to table offset */
	mak	r7,r7,0<2>	/* convert destination bits to table offset */
	or.u	r12,r0,hi16(_ASM_LABEL(kr_strat))
	or	r12,r12,lo16(_ASM_LABEL(kr_strat))
	addu	r6,r6,r7	/* compute final table offset for strategy */
	ld	r12,r12,r6	/* load the strategy routine */
	jmp	r12		/* branch to strategy routine */
d882 10
a891 10
	subu	r2,r2,3		/* decrement source pointer */
	subu	r3,r3,3		/* decrement destination pointer */
	ld.bu	r6,r2,0		/* load byte from source */
	ld.bu	r7,r2,1		/* load byte from source */
	ld.bu	r8,r2,2		/* load byte from source */
	st.b	r6,r3,0		/* store byte to destination */
	st.b	r7,r3,1		/* store byte to destination */
	st.b	r8,r3,2		/* store byte to destination */
	br.n	_ASM_LABEL(kr_word_copy)	/* copy full words */
	 subu	r4,r4,3		/* decrement length */
d897 6
a902 6
	subu	r2,r2,2		/* decrement source pointer */
	subu	r3,r3,2		/* decrement destination pointer */
	ld.hu	r6,r2,0		/* load half-word from source */
	st.h	r6,r3,0		/* store half-word to destination */
	br.n	_ASM_LABEL(kr_word_copy)	/* copy full words */
	 subu	r4,r4,2		/* decrement remaining length */
d908 5
a912 5
	subu	r2,r2,1		/* decrement source pointer */
	subu	r3,r3,1		/* decrement destination pointer */
	ld.bu	r6,r2,0		/* load 1 byte from source */
	st.b	r6,r3,0		/* store 1 byte to destination */
	subu	r4,r4,1		/* decrement remaining length */
d918 14
a931 14
	cmp	r10,r4,16	/* see if we have 16 bytes remaining */
	bb1	lo,r10,_ASM_LABEL(kr_byte_copy)	/* not enough left, copy bytes */
	subu	r2,r2,16	/* decrement source pointer */
	subu	r3,r3,16	/* decrement destination pointer */
	ld	r6,r2,0		/* load first word */
	ld	r7,r2,4		/* load second word */
	ld	r8,r2,8		/* load third word */
	ld	r9,r2,12	/* load fourth word */
	st	r6,r3,0		/* store first word */
	st	r7,r3,4		/* store second word */
	st 	r8,r3,8		/* store third word */
	st 	r9,r3,12	/* store fourth word */
	br.n	_ASM_LABEL(kr_word_copy)	/* copy another block */
	 subu	r4,r4,16	/* decrement remaining length */
d934 5
a938 5
	subu	r2,r2,1		/* decrement source pointer */
	subu	r3,r3,1		/* decrement destination pointer */
	ld.bu	r6,r2,0		/* load 1 byte from source */
	st.b	r6,r3,0		/* store 1 byte to destination */
	subu	r4,r4,1		/* decrement remaining length */
d942 22
a963 22
	cmp	r10,r4,16	/* see if we have 16 bytes remaining */
	bb1	lo,r10,_ASM_LABEL(kr_byte_copy)	/* not enough left, copy bytes */
	subu	r2,r2,16	/* decrement source pointer */
	subu	r3,r3,16	/* decrement destination pointer */
	ld.hu	r6,r2,0		/* load first half-word */
	ld.hu	r7,r2,2		/* load second half-word */
	ld.hu	r8,r2,4		/* load third half-word */
	ld.hu	r9,r2,6		/* load fourth half-word */
	ld.hu	r10,r2,8	/* load fifth half-word */
	ld.hu	r11,r2,10	/* load sixth half-word */
	ld.hu	r12,r2,12	/* load seventh half-word */
	ld.hu	r13,r2,14	/* load eighth half-word */
	st.h	r6,r3,0		/* store first half-word */
	st.h	r7,r3,2		/* store second half-word */
	st.h 	r8,r3,4		/* store third half-word */
	st.h 	r9,r3,6		/* store fourth half-word */
	st.h	r10,r3,8	/* store fifth half-word */
	st.h	r11,r3,10	/* store sixth half-word */
	st.h 	r12,r3,12	/* store seventh half-word */
	st.h 	r13,r3,14	/* store eighth half-word */
	br.n	_ASM_LABEL(kr_half_copy)	/* copy another block */
	 subu	r4,r4,16	/* decrement remaining length */
d966 7
a972 7
	bcnd	eq0,r4,_ASM_LABEL(kcopy_out)	/* branch if nothing left to copy */
	subu	r2,r2,1		/* decrement source pointer */
	subu	r3,r3,1		/* decrement destination pointer */
	ld.bu	r6,r2,0		/* load byte from source */
	st.b	r6,r3,0		/* store byte in destination */
	br.n	_ASM_LABEL(kr_byte_copy)	/* branch for next byte */
	 subu	r4,r4,1		/* decrement remaining length */
d975 1
a975 1
	or	r2,   r0,   0		/* return success */
d977 6
a982 6
	ldcr	r5,   CPU
	ld	r7,   r31,  0
	ld	r6,   r5,   CI_CURPCB
	add	r31,  r31,  16
	jmp.n	r1		/* all done, return to caller */
	 st	r7,   r6,   PCB_ONFAULT	/* restore previous pcb_onfault */
d986 1
a986 1
	 or	r2,   r0,   EFAULT	/* return fault */
d988 2
a989 2
	data
	align	4
d991 16
a1006 16
	word	_ASM_LABEL(kf_word_copy)
	word	_ASM_LABEL(kf_byte_copy)
	word	_ASM_LABEL(kf_half_copy)
	word	_ASM_LABEL(kf_byte_copy)
	word	_ASM_LABEL(kf_byte_copy)
	word	_ASM_LABEL(kf_3byte_word_copy)
	word	_ASM_LABEL(kf_byte_copy)
	word	_ASM_LABEL(kf_1byte_half_copy)
	word	_ASM_LABEL(kf_half_copy)
	word	_ASM_LABEL(kf_byte_copy)
	word	_ASM_LABEL(kf_1half_word_copy)
	word	_ASM_LABEL(kf_byte_copy)
	word	_ASM_LABEL(kf_byte_copy)
	word	_ASM_LABEL(kf_1byte_half_copy)
	word	_ASM_LABEL(kf_byte_copy)
	word	_ASM_LABEL(kf_1byte_word_copy)
d1009 16
a1024 16
	word	_ASM_LABEL(kr_word_copy)
	word	_ASM_LABEL(kr_byte_copy)
	word	_ASM_LABEL(kr_half_copy)
	word	_ASM_LABEL(kr_byte_copy)
	word	_ASM_LABEL(kr_byte_copy)
	word	_ASM_LABEL(kr_1byte_word_copy)
	word	_ASM_LABEL(kr_byte_copy)
	word	_ASM_LABEL(kr_1byte_half_copy)
	word	_ASM_LABEL(kr_half_copy)
	word	_ASM_LABEL(kr_byte_copy)
	word	_ASM_LABEL(kr_1half_word_copy)
	word	_ASM_LABEL(kr_byte_copy)
	word	_ASM_LABEL(kr_byte_copy)
	word	_ASM_LABEL(kr_1byte_half_copy)
	word	_ASM_LABEL(kr_byte_copy)
	word	_ASM_LABEL(kr_3byte_word_copy)
d1033 21
a1053 21
	st	r1,r2,0
	st	r14,r2,4
	st	r15,r2,2*4
	st	r16,r2,3*4
	st	r17,r2,4*4
	st	r18,r2,5*4
	st	r19,r2,6*4
	st	r20,r2,7*4
	st	r21,r2,8*4
	st	r22,r2,9*4
	st	r23,r2,10*4
	st	r24,r2,11*4
	st	r25,r2,12*4
	st	r26,r2,13*4
	st	r27,r2,14*4
	st	r28,r2,15*4
	st	r29,r2,16*4
	st	r30,r2,17*4
	st	r31,r2,18*4
	jmp.n	r1
	 or	r2,r0,r0
d1056 21
a1076 21
	ld	r1,r2,0
	ld	r14,r2,4
	ld	r15,r2,2*4
	ld	r16,r2,3*4
	ld	r17,r2,4*4
	ld	r18,r2,5*4
	ld	r19,r2,6*4
	ld	r20,r2,7*4
	ld	r21,r2,8*4
	ld	r22,r2,9*4
	ld	r23,r2,10*4
	ld	r24,r2,11*4
	ld	r25,r2,12*4
	ld	r26,r2,13*4
	ld	r27,r2,14*4
	ld	r28,r2,15*4
	ld	r29,r2,16*4
	ld	r30,r2,17*4
	ld	r31,r2,18*4
	jmp.n	r1
	 or	r2,r0,1
d1085 3
a1087 3
	ld	r2,  r31, 0	/* pick sigcontext* */
	or	r13, r0,  SYS_sigreturn
	tb0	0,   r0,  128	/* syscall trap, calling sigreturn */
d1092 2
a1093 2
	or	r13, r0,  SYS_exit
	tb0	0,   r0,  128	/* syscall trap, exit */
d1114 1
a1114 1
	addu	r12, r2, PAGE_SIZE
d1116 13
a1128 13
	ld.d	r4,  r2, 0x00
	ld.d	r6,  r2, 0x08
	st.d	r4,  r3, 0x00
	ld.d	r8,  r2, 0x10
	st.d	r6,  r3, 0x08
	ld.d	r10, r2, 0x18
	st.d	r8,  r3, 0x10
	addu	r2,  r2, 0x20
	st.d	r10, r3, 0x18
	cmp	r4,  r2, r12
	bb1.n	ne,  r4, 1b
	 addu	r3,  r3, 0x20
	jmp	r1
d1136 3
a1138 3
	addu	r12, r2, PAGE_SIZE
	or	r3,  r1, r0
	or	r1,  r0, r0
d1140 12
a1151 12
	st.d	r0,  r2, 0x00
	st.d	r0,  r2, 0x08
	st.d	r0,  r2, 0x10
	st.d	r0,  r2, 0x18
	st.d	r0,  r2, 0x20
	st.d	r0,  r2, 0x28
	st.d	r0,  r2, 0x30
	st.d	r0,  r2, 0x38
	addu	r2,  r2, 0x40
	cmp	r4,  r2, r12
	bb1	ne,  r4, 1b
	jmp	r3
d1164 1
a1164 1
	addu	r12, r2, PAGE_SIZE
d1166 14
a1179 14
	ld.h	r0,  r2, 0x00	# load allocate
	ld.d	r4,  r2, 0x00
	ld.d	r6,  r2, 0x08
	st.d	r4,  r3, 0x00
	ld.d	r8,  r2, 0x10
	st.d	r6,  r3, 0x08
	ld.d	r10, r2, 0x18
	st.d	r8,  r3, 0x10
	addu	r2,  r2, 0x20
	st.d	r10, r3, 0x18
	cmp	r4,  r2, r12
	addu	r3,  r3, 0x20
	bb1	ne,  r4, 1b
	jmp	r1
d1187 3
a1189 3
	addu	r12, r2, PAGE_SIZE
	or	r3,  r1, r0
	or	r1,  r0, r0
d1191 9
a1199 9
	ld.h	r0,  r2, 0x00	# load allocate
	st.d	r0,  r2, 0x00
	st.d	r0,  r2, 0x08
	st.d	r0,  r2, 0x10
	st.d	r0,  r2, 0x18
	addu	r2,  r2, 0x20
	cmp	r4,  r2, r12
	bb1	ne,  r4, 1b
	jmp	r3
d1207 2
a1208 2
	ldcr	r2,  PID
	extu	r3,  r2, 8<8>
d1236 3
a1238 3
	cmp	r4, r3, CPU_88110
	bb1	eq, r4, 1f	/* if it's a mc88110, skip SSBR */
	stcr	r0, SSBR	/* clear this for later */
d1240 1
a1240 1
	stcr	r0, SR1		/* clear the CPU flags */
d1242 3
a1244 3
	or.u	r2, r0, hi16(KERNEL_PSR)
	or	r2, r2, lo16(KERNEL_PSR)
	stcr	r2, PSR
d1247 1
a1247 1
	jmp	r1
d1254 4
a1257 4
	ldcr	r3, PSR
	set	r4, r3, 1<PSR_INTERRUPT_DISABLE_BIT>
	set	r4, r4, 1<PSR_SHADOW_FREEZE_BIT>
	stcr	r4, PSR
d1260 1
a1260 1
	stcr	r2, VBR
d1264 4
a1267 4
	ldcr	r2,  PID
	extu	r5,  r2, 8<8>
	cmp	r4, r5, CPU_88110
	bb1	eq, r4, 1f
d1271 1
a1271 1
	stcr	r3, PSR
d1273 1
a1273 1
	jmp	r1
d1278 2
a1279 2
	stcr	r1, EXIP
	stcr	r3, EPSR
@


1.19
log
@The exception vector page on m88k systems has always been the same page as
the one used by the firmware, which (at least on mvme88k) is at address zero.

This is unfortunate, since this means that NULL pointer dereferences in the
kernel are not caught, and writes cause havoc.

This behaviour was necessary to be able to use the PROM system call interface
during early bootstrap, without having to disassemble the VBR page and
update branches - which use pc-relative displacement - if we were to use
a different VBR address.

On mvme88k, change this and actually set up two VBR pages: one, over the PROM
page (except for the system call vectors), and another one in the kernel
image (which will be mapped read-only). We'll run with the PROM page until
the end of autoconf, and then switch to the kernel one, and unmap all the
PROM below it.

As a bonus, the final kernel page can use optimized data access fault
handlers, which do not have to check for faults caused by badaddr(), since
badaddr() is only used during device probe on buses which do not support
hotplug.

There are a few infrastructure collateral damage on aviion and luna88k, but
these ports do not change their behaviour yet.
@
text
@d1 1
a1 1
/* $OpenBSD: subr.S,v 1.18 2010/04/20 20:28:18 miod Exp $	*/
d1106 3
d1114 1
a1114 1
ENTRY(copypage)
d1136 1
a1136 1
ENTRY(zeropage)
d1153 50
@


1.18
log
@destintation -> destination
@
text
@d1 1
a1 1
/* $OpenBSD: subr.S,v 1.17 2008/02/20 18:35:41 miod Exp $	*/
d1196 34
@


1.17
log
@Preserve pcb_onfault within kcopy(), as expected and as all other platforms do.
@
text
@d1 1
a1 1
/* $OpenBSD: subr.S,v 1.16 2007/12/22 17:14:39 miod Exp $	*/
d747 1
a747 1
	mask	r7,r3,3		/* get 2 low order bits of destintation addr */
d870 1
a870 1
	mask	r7,r3,3		/* get 2 low order bits of destintation addr */
@


1.16
log
@Move initial PSR initialization to a separate routine, instead of duplicating
it five times.
@
text
@d1 1
a1 1
/* $OpenBSD: subr.S,v 1.15 2007/12/02 21:22:19 miod Exp $	*/
d364 1
a364 1
	 st	r0,r6,PCB_ONFAULT
d640 1
a640 1
	 st	r0,r6,PCB_ONFAULT	/* clear the handler */
d708 1
a708 1
	 st	r0,r6,PCB_ONFAULT	/* clear the handler */
d723 1
d727 1
d729 1
d979 1
d981 1
d983 1
a983 1
	 st	r0,   r6,   PCB_ONFAULT	/* clear the handler */
@


1.15
log
@Provide faster bcopy() and bzero() routines for pmap_copy_page() and
pmap_zero_page().
@
text
@d1 1
a1 1
/* $OpenBSD: subr.S,v 1.14 2006/11/18 22:48:44 miod Exp $	*/
d37 1
d1080 1
a1080 1
GLOBAL(sigcode)			/* r31 points to sigframe */
d1106 1
a1106 1
GLOBAL(copypage)
d1128 1
a1128 1
GLOBAL(zeropage)
d1145 46
@


1.14
log
@Unwaste two delay slots in kcopy().
@
text
@d1 1
a1 1
/* $OpenBSD: subr.S,v 1.13 2006/11/17 22:32:35 miod Exp $	*/
d35 1
d1021 1
d1072 1
d1096 48
@


1.13
log
@Move m88k memory copy and fill functions to libkern. The copy functions will
no longer share the same code, but will be instead be duplicated from the same
source, so that bcopy() and memcpy() do not need to check for overlap, and
memcpy() and memmove() are shorter.
@
text
@d1 1
a1 1
/* $OpenBSD: subr.S,v 1.12 2006/11/10 19:20:29 miod Exp $	*/
d975 2
a976 2
	st	r0,r6,PCB_ONFAULT	/* clear the handler */
	jmp	r1		/* all done, return to caller */
d979 2
a980 2
	or	r2,   r0,   EFAULT	/* return fault */
	br	_ASM_LABEL(kcopy_out_fault)
@


1.12
log
@Avoid an unnecessary branch for byte-by-byte copyin() and copyout().
@
text
@d1 1
a1 1
/* $OpenBSD: subr.S,v 1.11 2006/01/02 19:46:12 miod Exp $	*/
a1018 477

/*
 * Gcc 2 generates calls to memcpy for bcopies of unknown size. memcpy can
 * simply be implemented as ovbcopy but the src (r2, r3) and dst args need to
 * be switched.
 */
/*
 * void memcpy(dest, source, count)
 *
 */
ENTRY(memcpy)
	or 	r5, r0, r2	/* dst -> tmp */
	or	r2, r0, r3	/* src -> 1st arg */
	br.n	_C_LABEL(ovbcopy)
	 or	r3, r0, r5	/* dst -> 2nd arg */

/*
 * void bcopy(source, destination, count)
 *
 * copy count bytes of data from source to destination
 * Don Harper (don@@omron.co.jp), Omron Corporation.
 *
 */

ENTRY(bcopy)
ENTRY(ovbcopy)
	bcnd	eq0,r4,_ASM_LABEL(bcopy_out)	/* nothing to do if == 0 */
/*
 *	check position of source and destination data
 */
	cmp 	r9,r2,r3	/* compare source address to destination */
	bb1	eq,r9,_ASM_LABEL(bcopy_out)	/* nothing to do if equal */
	bb1	lo,r9,_ASM_LABEL(bcopy_reverse)	/* reverse copy if src < dest */
/*
 *	source address is greater than destination address, copy forward
 */
	cmp 	r9,r4,16	/* see if we have at least 16 bytes */
	bb1	lt,r9,_ASM_LABEL(f_byte_copy)	/* copy bytes for small data length */
/*
 *	determine copy strategy based on alignment of source and destination
 */
	mask	r6,r2,3		/* get 2 low order bits of source address */
	mask	r7,r3,3		/* get 2 low order bits of destintation addr */
	mak	r6,r6,0<4>	/* convert source bits to table offset */
	mak	r7,r7,0<2>	/* convert destination bits to table offset */
	or.u	r12,r0,hi16(_ASM_LABEL(f_strat))
	or	r12,r12,lo16(_ASM_LABEL(f_strat))
	addu	r6,r6,r7	/* compute final table offset for strategy */
	ld	r12,r12,r6	/* load the strategy routine */
	jmp	r12		/* branch to strategy routine */


/*
 * Copy three bytes from src to destination then copy words
 */
ASLOCAL(f_3byte_word_copy)
	ld.bu	r6,r2,0		/* load byte from source */
	ld.bu	r7,r2,1		/* load byte from source */
	ld.bu	r8,r2,2		/* load byte from source */
	st.b	r6,r3,0		/* store byte to destination */
	st.b	r7,r3,1		/* store byte to destination */
	st.b	r8,r3,2		/* store byte to destination */
	addu	r2,r2,3		/* increment source pointer */
	addu	r3,r3,3		/* increment destination pointer */
	br.n	_ASM_LABEL(f_word_copy)	/* copy full words */
	 subu	r4,r4,3		/* decrement length */

/*
 * Copy 1 halfword from src to destination then copy words
 */
ASLOCAL(f_1half_word_copy)
	ld.hu	r6,r2,0		/* load half-word from source */
	st.h	r6,r3,0		/* store half-word to destination */
	addu	r2,r2,2		/* increment source pointer */
	addu	r3,r3,2		/* increment destination pointer */
	br.n	_ASM_LABEL(f_word_copy)	/* copy full words */
	 subu	r4,r4,2		/* decrement remaining length */

/*
 * Copy 1 byte from src to destination then copy words
 */
ASLOCAL(f_1byte_word_copy)
	ld.bu	r6,r2,0		/* load 1 byte from source */
	st.b	r6,r3,0		/* store 1 byte to destination */
	addu	r2,r2,1		/* increment source pointer */
	addu	r3,r3,1		/* increment destination pointer */
	subu	r4,r4,1		/* decrement remaining length */
	/* fall through to word copy */
/*
 * Copy as many full words as possible, 4 words per loop
 */
ASLOCAL(f_word_copy)
	cmp	r10,r4,16	/* see if we have 16 bytes remaining */
	bb1	lo,r10,_ASM_LABEL(f_byte_copy)	/* not enough left, copy bytes */
	ld	r6,r2,0		/* load first word */
	ld	r7,r2,4		/* load second word */
	ld	r8,r2,8		/* load third word */
	ld	r9,r2,12	/* load fourth word */
	st	r6,r3,0		/* store first word */
	st	r7,r3,4		/* store second word */
	st 	r8,r3,8		/* store third word */
	st 	r9,r3,12	/* store fourth word */
	addu	r2,r2,16	/* increment source pointer */
	addu	r3,r3,16	/* increment destination pointer */
	br.n	_ASM_LABEL(f_word_copy)	/* branch to copy another block */
	 subu	r4,r4,16	/* decrement remaining length */

ASLOCAL(f_1byte_half_copy)
	ld.bu	r6,r2,0		/* load 1 byte from source */
	st.b	r6,r3,0		/* store 1 byte to destination */
	addu	r2,r2,1		/* increment source pointer */
	addu	r3,r3,1		/* increment destination pointer */
	subu	r4,r4,1		/* decrement remaining length */
	/* fall through to half copy */

ASLOCAL(f_half_copy)
	cmp	r10,r4,16	/* see if we have 16 bytes remaining */
	bb1	lo,r10,_ASM_LABEL(f_byte_copy)	/* not enough left, copy bytes */
	ld.hu	r6,r2,0		/* load first half-word */
	ld.hu	r7,r2,2		/* load second half-word */
	ld.hu	r8,r2,4		/* load third half-word */
	ld.hu	r9,r2,6		/* load fourth half-word */
	ld.hu	r10,r2,8	/* load fifth half-word */
	ld.hu	r11,r2,10	/* load sixth half-word */
	ld.hu	r12,r2,12	/* load seventh half-word */
	ld.hu	r13,r2,14	/* load eighth half-word */
	st.h	r6,r3,0		/* store first half-word */
	st.h	r7,r3,2		/* store second half-word */
	st.h 	r8,r3,4		/* store third half-word */
	st.h 	r9,r3,6		/* store fourth half-word */
	st.h	r10,r3,8	/* store fifth half-word */
	st.h	r11,r3,10	/* store sixth half-word */
	st.h 	r12,r3,12	/* store seventh half-word */
	st.h 	r13,r3,14	/* store eighth half-word */
	addu	r2,r2,16	/* increment source pointer */
	addu	r3,r3,16	/* increment destination pointer */
	br.n	_ASM_LABEL(f_half_copy)	/* branch to copy another block */
	 subu	r4,r4,16	/* decrement remaining length */

ASLOCAL(f_byte_copy)
	bcnd	eq0,r4,_ASM_LABEL(bcopy_out)	/* branch if nothing left to copy */
	ld.bu	r6,r2,0		/* load byte from source */
	st.b	r6,r3,0		/* store byte in destination */
	addu	r2,r2,1		/* increment source pointer */
	addu	r3,r3,1		/* increment destination pointer */
	br.n	_ASM_LABEL(f_byte_copy)	/* branch for next byte */
	 subu	r4,r4,1		/* decrement remaining length */

/*
 *	source address is less than destination address, copy in reverse
 */
ASLOCAL(bcopy_reverse)
/*
 * start copy pointers at end of data
 */
	addu	r2,r2,r4	/* start source at end of data */
	addu	r3,r3,r4	/* start destination at end of data */
/*
 * check for short data
 */
	cmp 	r9,r4,16	/* see if we have at least 16 bytes */
	bb1	lt,r9,_ASM_LABEL(r_byte_copy)	/* copy bytes for small data length */
/*
 *	determine copy strategy based on alignment of source and destination
 */
	mask	r6,r2,3		/* get 2 low order bits of source address */
	mask	r7,r3,3		/* get 2 low order bits of destintation addr */
	mak	r6,r6,0<4>	/* convert source bits to table offset */
	mak	r7,r7,0<2>	/* convert destination bits to table offset */
	or.u	r12,r0,hi16(_ASM_LABEL(r_strat))
	or	r12,r12,lo16(_ASM_LABEL(r_strat))
	addu	r6,r6,r7	/* compute final table offset for strategy */
	ld	r12,r12,r6	/* load the strategy routine */
	jmp	r12		/* branch to strategy routine */

/*
 * Copy three bytes from src to destination then copy words
 */
ASLOCAL(r_3byte_word_copy)
	subu	r2,r2,3		/* decrement source pointer */
	subu	r3,r3,3		/* decrement destination pointer */
	ld.bu	r6,r2,0		/* load byte from source */
	ld.bu	r7,r2,1		/* load byte from source */
	ld.bu	r8,r2,2		/* load byte from source */
	st.b	r6,r3,0		/* store byte to destination */
	st.b	r7,r3,1		/* store byte to destination */
	st.b	r8,r3,2		/* store byte to destination */
	br.n	_ASM_LABEL(r_word_copy)	/* copy full words */
	 subu	r4,r4,3		/* decrement length */

/*
 * Copy 1 halfword from src to destination then copy words
 */
ASLOCAL(r_1half_word_copy)
	subu	r2,r2,2		/* decrement source pointer */
	subu	r3,r3,2		/* decrement destination pointer */
	ld.hu	r6,r2,0		/* load half-word from source */
	st.h	r6,r3,0		/* store half-word to destination */
	br.n	_ASM_LABEL(r_word_copy)	/* copy full words */
	 subu	r4,r4,2		/* decrement remaining length */

/*
 * Copy 1 byte from src to destination then copy words
 */
ASLOCAL(r_1byte_word_copy)
	subu	r2,r2,1		/* decrement source pointer */
	subu	r3,r3,1		/* decrement destination pointer */
	ld.bu	r6,r2,0		/* load 1 byte from source */
	st.b	r6,r3,0		/* store 1 byte to destination */
	subu	r4,r4,1		/* decrement remaining length */
	/* fall through to word copy */
/*
 * Copy as many full words as possible, 4 words per loop
 */
ASLOCAL(r_word_copy)
	cmp	r10,r4,16	/* see if we have 16 bytes remaining */
	bb1	lo,r10,_ASM_LABEL(r_byte_copy)	/* not enough left, copy bytes */
	subu	r2,r2,16	/* decrement source pointer */
	subu	r3,r3,16	/* decrement destination pointer */
	ld	r6,r2,0		/* load first word */
	ld	r7,r2,4		/* load second word */
	ld	r8,r2,8		/* load third word */
	ld	r9,r2,12	/* load fourth word */
	st	r6,r3,0		/* store first word */
	st	r7,r3,4		/* store second word */
	st 	r8,r3,8		/* store third word */
	st 	r9,r3,12	/* store fourth word */
	br.n	_ASM_LABEL(r_word_copy)	/* branch to copy another block */
	 subu	r4,r4,16	/* decrement remaining length */

ASLOCAL(r_1byte_half_copy)
	subu	r2,r2,1		/* decrement source pointer */
	subu	r3,r3,1		/* decrement destination pointer */
	ld.bu	r6,r2,0		/* load 1 byte from source */
	st.b	r6,r3,0		/* store 1 byte to destination */
	subu	r4,r4,1		/* decrement remaining length */
	/* fall through to half copy */

ASLOCAL(r_half_copy)
	cmp	r10,r4,16	/* see if we have 16 bytes remaining */
	bb1	lo,r10,_ASM_LABEL(r_byte_copy)	/* not enough left, copy bytes */
	subu	r2,r2,16	/* decrement source pointer */
	subu	r3,r3,16	/* decrement destination pointer */
	ld.hu	r6,r2,0		/* load first half-word */
	ld.hu	r7,r2,2		/* load second half-word */
	ld.hu	r8,r2,4		/* load third half-word */
	ld.hu	r9,r2,6		/* load fourth half-word */
	ld.hu	r10,r2,8	/* load fifth half-word */
	ld.hu	r11,r2,10	/* load sixth half-word */
	ld.hu	r12,r2,12	/* load seventh half-word */
	ld.hu	r13,r2,14	/* load eighth half-word */
	st.h	r6,r3,0		/* store first half-word */
	st.h	r7,r3,2		/* store second half-word */
	st.h 	r8,r3,4		/* store third half-word */
	st.h 	r9,r3,6		/* store fourth half-word */
	st.h	r10,r3,8	/* store fifth half-word */
	st.h	r11,r3,10	/* store sixth half-word */
	st.h 	r12,r3,12	/* store seventh half-word */
	st.h 	r13,r3,14	/* store eighth half-word */
	br.n	_ASM_LABEL(r_half_copy)	/* branch to copy another block */
	 subu	r4,r4,16	/* decrement remaining length */

ASLOCAL(r_byte_copy)
	bcnd	eq0,r4,_ASM_LABEL(bcopy_out)	/* branch if nothing left to copy */
	subu	r2,r2,1		/* decrement source pointer */
	subu	r3,r3,1		/* decrement destination pointer */
	ld.bu	r6,r2,0		/* load byte from source */
	st.b	r6,r3,0		/* store byte in destination */
	br.n	_ASM_LABEL(r_byte_copy)	/* branch for next byte */
	 subu	r4,r4,1		/* decrement remaining length */

ASLOCAL(bcopy_out)
	jmp	r1		/* all done, return to caller */

	data
	align	4
ASLOCAL(f_strat)
	word	_ASM_LABEL(f_word_copy)
	word	_ASM_LABEL(f_byte_copy)
	word	_ASM_LABEL(f_half_copy)
	word	_ASM_LABEL(f_byte_copy)
	word	_ASM_LABEL(f_byte_copy)
	word	_ASM_LABEL(f_3byte_word_copy)
	word	_ASM_LABEL(f_byte_copy)
	word	_ASM_LABEL(f_1byte_half_copy)
	word	_ASM_LABEL(f_half_copy)
	word	_ASM_LABEL(f_byte_copy)
	word	_ASM_LABEL(f_1half_word_copy)
	word	_ASM_LABEL(f_byte_copy)
	word	_ASM_LABEL(f_byte_copy)
	word	_ASM_LABEL(f_1byte_half_copy)
	word	_ASM_LABEL(f_byte_copy)
	word	_ASM_LABEL(f_1byte_word_copy)

ASLOCAL(r_strat)
	word	_ASM_LABEL(r_word_copy)
	word	_ASM_LABEL(r_byte_copy)
	word	_ASM_LABEL(r_half_copy)
	word	_ASM_LABEL(r_byte_copy)
	word	_ASM_LABEL(r_byte_copy)
	word	_ASM_LABEL(r_1byte_word_copy)
	word	_ASM_LABEL(r_byte_copy)
	word	_ASM_LABEL(r_1byte_half_copy)
	word	_ASM_LABEL(r_half_copy)
	word	_ASM_LABEL(r_byte_copy)
	word	_ASM_LABEL(r_1half_word_copy)
	word	_ASM_LABEL(r_byte_copy)
	word	_ASM_LABEL(r_byte_copy)
	word	_ASM_LABEL(r_1byte_half_copy)
	word	_ASM_LABEL(r_byte_copy)
	word	_ASM_LABEL(r_3byte_word_copy)

	text

/*######################################################################*/

/*
 * April 1990, Omron Corporation
 * jfriedl@@nff.ncl.omron.co.jp
 *
 * void bzero(destination, length)
 *
 * Clear (set to zero) LENGTH bytes of memory starting at DESTINATION.
 * Note that there is no return value.
 *
 * This is fast. Really fast. Especially for long lengths.
 */
#define R_dest			r2
#define R_len			r3

#define R_bytes			r4
#define R_mark_address		r5
#define R_addr			r6	/* R_addr && R_temp SHARE */
#define R_temp			r6	/* R_addr && R_temp SHARE */

ENTRY(bzero)
	/*
	 * If the destination is not word aligned, we'll word align
	 * it first to make things easier.
	 *
	 * We'll check to see first if bit #0 is set and then bit #1
	 * (of the destination address). If either are set, it's
	 * not word aligned.
	 */
	bb1	0, R_dest, _ASM_LABEL(not_initially_word_aligned)
	bb1	1, R_dest, _ASM_LABEL(not_initially_word_aligned)

ASLOCAL(now_word_aligned)
	/*
	 * before we get into the main loop, grab the
	 * address of the label "mark" below.
	 */
	or.u	R_mark_address, r0, hi16(_ASM_LABEL(mark))
	or	R_mark_address, R_mark_address, lo16(_ASM_LABEL(mark))

ASLOCAL(top_of_main_loop)
#define MAX_AT_ONE_TIME 128
	/*
	 * Now we find out how many words we can zero-fill in a row.
	 * We do this by doing something like:
	 *
	 *	bytes &= 0xfffffffc;
	 *	if (bytes > MAX_AT_ONE_TIME)
	 *		bytes = MAX_AT_ONE_TIME;
	 */

	/*
	 * Clear lower two bits of length to give us the number of bytes
	 * ALIGNED TO THE WORD LENGTH remaining to move.
	 */
	clr	R_bytes, R_len, 2<0>

	/* if we're done clearing WORDS, jump out */
	bcnd	eq0, R_bytes, _ASM_LABEL(done_doing_words)

	/* if the number of bytes > MAX_AT_ONE_TIME, do only the max */
	cmp	R_temp, R_bytes, MAX_AT_ONE_TIME
	bb1	lt, R_temp, 1f

	/*
	 * Since we're doing the max, we know exactly where we're
	 * jumping (the first one in the list!), so we can jump
	 * right there.  However, we've still got to adjust
	 * the length, so we'll jump to where we ajust the length
	 * which just happens to fall through to the first store zero
	 * in the list.
	 *
	 * Note, however, that we're jumping to an instruction that
	 * would be in the delay slot for the jump in front of it,
	 * so if you change things here, WATCH OUT.
	 */
	br.n	do_max
	 or	R_bytes, r0, MAX_AT_ONE_TIME

1:
	/*
	 * Now we have the number of bytes to zero during this iteration,
	 * (which, as it happens, is the last iteration if we're here).
	 * We'll calculate the proper place to jump and then jump there,
	 * after adjusting the length.  NOTE that there is a label between
	 * the "jmp.n" and the "subu" below... the "subu" is NOT always
	 * executed in the delay slot of the "jmp.n".
 	 */
	subu	R_addr, R_mark_address, R_bytes

	/* and go there (after adjusting the length via ".n") */
	jmp.n	R_addr
ASLOCAL(do_max)
	  subu	R_len, R_len, R_bytes	/* NOTE: this is in the delay slot! */

	st	r0, R_dest, 0x7c	/* 128 */
	st	r0, R_dest, 0x78	/* 124 */
	st	r0, R_dest, 0x74	/* 120 */
	st	r0, R_dest, 0x70	/* 116 */
	st	r0, R_dest, 0x6c	/* 112 */
	st	r0, R_dest, 0x68	/* 108 */
	st	r0, R_dest, 0x64	/* 104 */
	st	r0, R_dest, 0x60	/* 100 */
	st	r0, R_dest, 0x5c	/*  96 */
	st	r0, R_dest, 0x58	/*  92 */
	st	r0, R_dest, 0x54	/*  88 */
	st	r0, R_dest, 0x50	/*  84 */
	st	r0, R_dest, 0x4c	/*  80 */
	st	r0, R_dest, 0x48	/*  76 */
	st	r0, R_dest, 0x44	/*  72 */
	st	r0, R_dest, 0x40	/*  68 */
	st	r0, R_dest, 0x3c	/*  64 */
	st	r0, R_dest, 0x38	/*  60 */
	st	r0, R_dest, 0x34	/*  56 */
	st	r0, R_dest, 0x30	/*  52 */
	st	r0, R_dest, 0x2c	/*  44 */
	st	r0, R_dest, 0x28	/*  40 */
	st	r0, R_dest, 0x24	/*  36 */
	st	r0, R_dest, 0x20	/*  32 */
	st	r0, R_dest, 0x1c	/*  28 */
	st	r0, R_dest, 0x18	/*  24 */
	st	r0, R_dest, 0x14	/*  20 */
	st	r0, R_dest, 0x10	/*  16 */
	st	r0, R_dest, 0x0c	/*  12 */
	st	r0, R_dest, 0x08	/*   8 */
	st	r0, R_dest, 0x04	/*   4 */
	st	r0, R_dest, 0x00	/*   0 */

ASLOCAL(mark)
	br.n	_ASM_LABEL(top_of_main_loop)
	 addu	R_dest, R_dest, R_bytes	/* bump up the dest address */

ASLOCAL(done_doing_words)
	bcnd	ne0, R_len, 1f
	jmp	r1

1:
	subu	R_len, R_len, 1
	bcnd.n	ne0, R_len, 1b
	 st.b	r0, R_dest, R_len
1:
	jmp	r1

ASLOCAL(not_initially_word_aligned)
	/*
	 * Bzero to word-align the address (at least if the length allows it).
	 */
	bcnd	eq0, R_len, 1b
	st.b	r0, R_dest, 0
	addu	R_dest, R_dest, 1
	mask	R_temp, R_dest, 0x3
	bcnd.n	eq0, R_temp, _ASM_LABEL(now_word_aligned)
	 subu	R_len, R_len, 1
	br	_ASM_LABEL(not_initially_word_aligned)

#undef	R_dest
#undef	R_len
#undef	R_bytes
#undef	R_mark_address
#undef	R_addr
#undef	R_temp
#undef	MAX_AT_ONE_TIME
@


1.11
log
@Faster signal trampoline code for m88k: instead of pushing everything on
the stack a la m68k, put handler arguments in register, transfer control
to the handler directly, but have it return in the sigcode.
While there, remove wrong comments about the sigcode being on top of the
user stack.
@
text
@d1 1
a1 1
/* $OpenBSD: subr.S,v 1.10 2005/12/03 16:52:16 miod Exp $	*/
d203 6
a208 8
#if 0
	bcnd	ne0,  LEN,  1f		/* XXX optimize len = 0 case */
	or	r2,   r0,   0
	br	_ASM_LABEL(Lcidone)
1:	bcnd	lt0,  LEN,  _ASM_LABEL(Lciflt)	/* EFAULT if len < 0 */
#endif

	/* If it's a small length (less than 8), then do byte-by-byte */
d231 5
a235 2
	/* At this point, both SRC and DEST are aligned to a word */
	/* boundary, and LEN is an even multiple of 4.             */
a262 2
	/***************************************************/

d355 2
a356 2
	br.n	_ASM_LABEL(Lcidone)
	 or	r2, r0, r0	/* successful return */
d371 1
d468 7
a474 7
#if 0
	bcnd	ne0,  LEN,  1f		/* XXX optimize len = 0 case */
	or	r2,   r0,   0
	br	_ASM_LABEL(Lcodone)
1:	bcnd	lt0,  LEN,  _ASM_LABEL(Lcoflt)	/* EFAULT if len < 0 */
#endif
	/* If it's a small length (less than 8), then do byte-by-byte */
d499 2
a500 1
	 * boundary, and LEN is an even multiple of 4.
d631 2
a632 2
	br.n	_ASM_LABEL(Lcodone)
	 or	r2, r0, r0	/* successful return */
@


1.10
log
@Turn read_processor_identification_register() into a simple macro with a
much, much, much shorter name. It is only used to print cpu revision anyway...
@
text
@d1 1
a1 1
/* $OpenBSD: subr.S,v 1.9 2005/12/03 14:30:06 miod Exp $	*/
d1548 3
a1550 2
 * Trampoline code. Gets copied to the top of
 * user stack in exec.
d1553 3
a1555 8
	ld	r3, r31, 4	/* siginfo_t* */
	ld	r4, r31, 8	/* sigcontext* */
	ld	r5, r31, 12	/* handler */
	jsr.n	r5
	 ld	r2, r31, 0	/* signo */
	ld	r2, r31, 8	/* sigcontext* */
	or	r13,  r0, SYS_sigreturn
	tb0	0, r0, 128	/* syscall trap, calling sigreturn */
d1557 1
a1557 1
#if 0
d1560 2
a1561 3
	/* sigreturn will not return unless it fails */
	or	r13, r0, SYS_exit
	tb0	0, r0, 128	/* syscall trap, exit */
@


1.9
log
@Switch m88k ports to __HAVE_CPUINFO. Current cpu pointer is held in SR0
on all running processors.
Tested aoyama@@ and I
@
text
@d1 1
a1 1
/* $OpenBSD: subr.S,v 1.8 2005/10/13 19:48:33 miod Exp $	*/
a1545 4

ENTRY(read_processor_identification_register)
	jmp.n	r1
	 ldcr	r2, PID
@


1.8
log
@Merge <machine/cpu_number.h> into <machine/cpu.h>, preparing for intrusive
changes.
@
text
@d1 1
a1 1
/* $OpenBSD: subr.S,v 1.7 2005/10/12 19:32:19 miod Exp $	*/
d197 2
a198 2
	or.u	r5,   r0,   hi16(_C_LABEL(curpcb))
	ld	r6,   r5,   lo16(_C_LABEL(curpcb))
d234 1
a234 1
	/* boundry, and LEN is an even multiple of 4.             */
d360 2
a361 2
	or.u	r5,r0,hi16(_C_LABEL(curpcb))
	ld	r6,r5,lo16(_C_LABEL(curpcb))
d394 2
a395 2
	or.u	r6,   r0,   hi16(_C_LABEL(curpcb))
	ld	r7,   r6,   lo16(_C_LABEL(curpcb))
d435 2
a436 2
	or.u	r5,r0,hi16(_C_LABEL(curpcb))
	ld	r6,r5,lo16(_C_LABEL(curpcb))
d463 2
a464 2
	or.u	r5,   r0,   hi16(_C_LABEL(curpcb))
	ld	r6,   r5,   lo16(_C_LABEL(curpcb))
d499 1
a499 1
	 * boundry, and LEN is an even multiple of 4.
d634 2
a635 2
	or.u	r5,r0,hi16(_C_LABEL(curpcb))
	ld	r6,r5,lo16(_C_LABEL(curpcb))
d665 2
a666 2
	or.u	r6,   r0,   hi16(_C_LABEL(curpcb))
	ld	r7,   r6,   lo16(_C_LABEL(curpcb))
d701 3
a703 2
3:	or.u	r5,r0,hi16(_C_LABEL(curpcb))
	ld	r6,r5,lo16(_C_LABEL(curpcb))
d720 2
a721 2
	or.u	r5,   r0,   hi16(_C_LABEL(curpcb))
	ld	r6,   r5,   lo16(_C_LABEL(curpcb))
d972 2
a973 2
	or.u	r5,r0,hi16(_C_LABEL(curpcb))
	ld	r6,r5,lo16(_C_LABEL(curpcb))
a1549 48

/*
 * void set_cpu_number(unsigned number);
 *
 * Sets the kernel cpu number for this cpu to the given value.
 *
 * Input:
 *	r1	return address
 *	r2 	the number (should be 0, 1, 2, or 3).
 *
 * Other registers used:
 *	r3	temp
 *	r4	original PSR
 *	r5	temporary new PSR
 */
ENTRY(set_cpu_number)
#ifdef DEBUG
	/* make sure the CPU number is valid */
	clr	r3, r2, FLAG_CPU_FIELD_WIDTH<0>
	bcnd	ne0, r3, 1f	/* bad cpu number */
#endif

	/* going to change a control register -- disable interrupts */
	ldcr	r4, PSR
	set	r5, r4, 1<PSR_INTERRUPT_DISABLE_BIT>
	stcr	r5, PSR
	FLUSH_PIPELINE

	/* put in the cpu number */
	ldcr	r3, SR1				/* get the flags */
	clr	r3, r3, FLAG_CPU_FIELD_WIDTH<0>	/* clean the slate */
	or	r3, r3, r2			/* add the cpu number */
	stcr	r3, SR1				/* put back */

	/* put back the PSR to what it was before and return */
	stcr	r4, PSR
	FLUSH_PIPELINE
	jmp	r1

#ifdef DEBUG
1:	/* bad cpu number*/
	or.u	r2, r0, hi16(9f)
	bsr.n	_C_LABEL(panic)
	 or	r2, r2, lo16(9f)

	data
9:	string "set_cpu_number: bad CPU number %x\0"
#endif
@


1.7
log
@Move sigcode to the m88k-agnostic location. No functional change.
@
text
@d1 1
a1 1
/* $OpenBSD: subr.S,v 1.6 2005/05/15 16:23:45 miod Exp $	*/
a35 1
#include <machine/cpu_number.h>
@


1.6
log
@Speed up the low-level dae helpers.
@
text
@d1 1
a1 1
/* $OpenBSD: subr.S,v 1.5 2004/10/01 20:20:34 miod Exp $	*/
d1598 28
@


1.5
log
@guarded_access() is really only used by the MVME188 interrupt engine, so
do not provide it on luna88k. Makes trap() slightly faster on non-MVME188
kernels.
@
text
@d1 1
a1 1
/* $OpenBSD: subr.S,v 1.4 2004/08/02 10:44:51 miod Exp $	*/
d61 1
d63 2
a64 1
	ld.usr	r2,r2,r0
d66 2
a67 3
	br	2f
1:	ld	r2,r2,r0
2:	jmp	r1
d77 1
d79 2
a80 1
	ld.h.usr	r2,r2,r0
d82 2
a83 3
	br	2f
1:	ld.h	r2,r2,r0
2:	jmp	r1
d93 1
d95 2
a96 1
	ld.b.usr	r2,r2,r0
d98 2
a99 3
	br	2f
1:	ld.b	r2,r2,r0
2:	jmp	r1
d109 1
d111 2
a112 1
	st.usr	r3,r2,r0
d114 2
a115 3
	br	2f
1:	st	r3,r2,r0
2:	jmp	r1
d125 1
d127 2
a128 1
	st.h.usr	r3,r2,r0
d130 2
a131 3
	br	2f
1:	st.h	r3,r2,r0
2:	jmp	r1
d141 1
d143 2
a144 1
	st.b.usr	r3,r2,r0
d146 2
a147 3
	br	2f
1:	st.b	r3,r2,r0
2:	jmp	r1
d157 1
d159 2
a160 1
	xmem.usr	r3,r2,r0
d162 2
a163 3
	br	2f
1:	xmem	r3,r2,r0
2:	jmp	r1
d173 1
d175 2
a176 1
	xmem.bu.usr	r3,r2,r0
d178 2
a179 3
	br	2f
1:	xmem.bu	r3,r2,r0
2:	jmp	r1
d384 1
a384 1
 * r5 == len actually transferred (includes the terminating NULL!!!)
d656 1
a656 1
 * r5 == len actually copied (including the terminating NULL!!!)
d1044 1
a1044 1
	bcnd	le0,r4,_ASM_LABEL(bcopy_out)	/* nothing to do if <= 0 */
@


1.4
log
@Missed one <machine/board.h>
@
text
@d1 1
a1 1
/* $OpenBSD: subr.S,v 1.3 2004/08/01 17:18:05 miod Exp $	*/
a1541 35

GLOBAL(guarded_access_start)
ENTRY(guarded_access)
	cmp	 r9,r3,4
	bb1	 eq,r9,@@L145
	cmp	 r9,r3,2
	bb1	 eq,r9,@@L144
	cmp	 r9,r3,1
	bb1	 eq,r9,@@L143
	br	 _C_LABEL(guarded_access_bad)
@@L143:
	ld.b	 r9,r0,r2
	tb1	0, r0, 0
	st.b	 r9,r0,r4
	br	 @@L142
@@L144:
	ld.h	 r9,r0,r2
	tb1	0, r0, 0
	st.h	 r9,r0,r4
	br	 @@L142
@@L145:
	ld	 r9,r0,r2
	tb1	0, r0, 0
	st	 r9,r0,r4
	br	 @@L142

GLOBAL(guarded_access_bad)
	jmp.n	 r1
	 or	 r2,r0,EFAULT

@@L142:
	jmp.n	 r1
	 or	 r2,r0,0

GLOBAL(guarded_access_end)
@


1.3
log
@Move 88100 DAE code to its own file, shared between luna88k and mvme88k.
@
text
@d1 1
a1 1
/* $OpenBSD: subr.S,v 1.2 2004/07/07 21:18:11 miod Exp $	*/
a35 1
#include <machine/board.h>
@


1.2
log
@Funny typo.
@
text
@d1 1
a1 1
/* $OpenBSD: subr.S,v 1.1 2004/04/29 14:33:27 miod Exp $	*/
d40 3
a42 1
/*****************************************************************************
d46 2
a47 2
 *	vaddr_t address;		\\ in r2
 *	boolean_t supervisor_mode;	\\ in r3
d173 2
@


1.1
log
@Continue factorizing m88k common code, this time files in <arch>/<arch>
which were copied verbatim from mvme88k to luna88k.

This requires backing out syntactic sugar in mvme88k kernel configuration
files which would deduct the required processor types from the board models,
as the common code only depends upon the M88100 and M88110 defines.
@
text
@d1 1
a1 1
/* $OpenBSD: locore_asm_routines.S,v 1.28 2004/01/23 17:26:06 miod Exp $	*/
d720 1
a720 1
	bb1	lo,r9,_ASM_LABEL(kcopy_revers)e	/* reverse copy if src < dest */
@


1.1.2.1
log
@Merge with the trunk
@
text
@d1 1
a1 1
/* $OpenBSD$	*/
@

