head	1.6;
access;
symbols
	OPENBSD_4_2:1.2.0.14
	OPENBSD_4_2_BASE:1.2
	OPENBSD_4_1:1.2.0.12
	OPENBSD_4_1_BASE:1.2
	OPENBSD_4_0:1.2.0.10
	OPENBSD_4_0_BASE:1.2
	OPENBSD_3_9:1.2.0.8
	OPENBSD_3_9_BASE:1.2
	OPENBSD_3_8:1.2.0.6
	OPENBSD_3_8_BASE:1.2
	OPENBSD_3_7:1.2.0.4
	OPENBSD_3_7_BASE:1.2
	OPENBSD_3_6:1.2.0.2
	OPENBSD_3_6_BASE:1.2
	SMP_SYNC_A:1.1
	SMP_SYNC_B:1.1
	SMP:1.1.0.2;
locks; strict;
comment	@# @;


1.6
date	2007.12.25.00.29.49;	author miod;	state dead;
branches;
next	1.5;

1.5
date	2007.12.21.23.56.54;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2007.12.08.18.39.50;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2007.12.02.21.32.08;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2004.08.09.20.52.11;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2004.04.29.14.33.27;	author miod;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2004.06.05.23.09.48;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Restart the m88110 floating-point trap code from scratch, basing it on the
sparc{,64} floating-point emulator, adapted to the 88110 specifics. Handling
of these traps is now entirely done in C for convenience.

Although there are a few rounding issues to address, and the XRF is ignored,
this allows all the ieee754 regression tests to pass (lib/libc/ieeefp,
sys/kern/signal/fpsig, sys/kern/signal/sigfpe).
@
text
@/*	$OpenBSD: m88110_fp.S,v 1.5 2007/12/21 23:56:54 miod Exp $	*/

/*
 * Copyright (c) 2007, Miodrag Vallat.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice, this permission notice, and the disclaimer below
 * appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include "assym.h"

#include <machine/asm.h>
#include <machine/trap.h>

/* FPECR bits */
#define	FIOV_BIT	7
#define	FUNIMP_BIT	6
#define	FPRV_BIT	5
#define	FROP_BIT	4
#define	FDVZ_BIT	3
#define	FUNF_BIT	2
#define	FOVF_BIT	1
#define	FINX_BIT	0

/* FPSR and FPCR exception bits */
#define	EFINV_BIT	4
#define	EFDVZ_BIT	3
#define	EFUNF_BIT	2
#define	EFOVF_BIT	1
#define	EFINX_BIT	0

ASENTRY(m88110_fpu_exception)
	/*
	 * On entry, r30 point to the exception frame.
	 * Save our guts so that we can call other functions.
	 */
	subu	r31, r31, 16
	st	r1,  r31, 0
	st	r30, r31, 4

	/*
	 * We never saved the floating point exception and control
	 * registers. Do it now, and then decide what kind of exception
	 * we've got.
	 * Note that we can access the control registers even if the
	 * FPU is disabled.
	 */
	fldcr	r2,  FPECR
	fldcr	r3,  FPSR
	fldcr	r4,  FPCR
	st	r2,  r30, EF_FPECR
	st	r3,  r30, EF_FPSR
	st	r4,  r30, EF_FPCR

	/*
	 * Check for floating point unimplemented bit first, as other
	 * bits are undefined if this bit is set.
	 */
	bb1	FUNIMP_BIT, r2, _ASM_LABEL(m88110_funimp)

	/*
	 * Check for the other exceptions.
	 *
	 * FOVF and FUNF need to be checked before FINX.
	 */
	bb1	FIOV_BIT, r2, _ASM_LABEL(m88110_fiov)
	bb1	FPRV_BIT, r2, _ASM_LABEL(m88110_fprv)
	bb1	FROP_BIT, r2, _ASM_LABEL(m88110_frop)
	bb1	FDVZ_BIT, r2, _ASM_LABEL(m88110_fdvz)
	bb1	FUNF_BIT, r2, _ASM_LABEL(m88110_funf)
	bb1	FOVF_BIT, r2, _ASM_LABEL(m88110_fovf)
	bb1	FINX_BIT, r2, _ASM_LABEL(m88110_finx)

	/*
	 * If control goes here, we got a floating point exception,
	 * but no cause bit is set. This shouldn't happen; if it does,
	 * just fall through the unimplemented instruction code.
	 */

ASLOCAL(m88110_funimp)
	/*
	 * Check if the fpu was enabled.
	 */
	ld	r5, r30, EF_EPSR
	/* FPE_FLTINV */
	bb1	PSR_FPU_DISABLE_BIT, r5, _ASM_LABEL(m88110_fpeflt)

	/*
	 * If this is a kernel fault, we were probably trying to reissue
	 * a previously-faulting instruction.
	 * Just return without altering the fpecr, the ``caller'' will
	 * check it afterwards.
	 */
	bb1	PSR_SUPERVISOR_MODE_BIT, r5, _ASM_LABEL(m88110_fp_return_noreset)

	/*
	 * We should check the faulting instruction here.
	 *
	 * According to the documentation, this can be:
	 * - fsqrt (unimplemented)
	 * - any valid fp instruction operating on an odd register pair
	 * - any bogus fp instruction.
	 *
	 * However, real life shows that the 88110 will conveniently only
	 * flag the ``unimplemented instruction'' exception bit, regardless
	 * of the real exception cause. In this case, the fpsr register is
	 * correctly populated. But since bits in it are sticky... we can
	 * not trust its value )-:
	 *
	 * Because of this, we need to sort out real unimplemented opcodes
	 * from incorrectly reported exceptions.
	 * We will only handle odd register pairs for instructions issued
	 * in user mode (since the kernel will not issue any fp instructions
	 * except in this file).
	 */

#ifdef notyet
	/* Fetch the offending instruction */
	ld	r6,  r30, EF_EXIP
	ld.usr	r2,  r6,  r0

	/*
	 * Check the instruction format. All triadic floating point
	 * instruction are built this way:
	 *
	 *	100001 | D | S1 | X | opcode | T1 | T2 | TD | S2
	 *
	 * with:
	 * D (bits 25-21) = destination register
	 * S1 (bits 20-16) = source 1 register
	 * X (bit 15) = extended register file
	 * T1 (bits 10-9), T2 (bits 8-7), TD (bits 6-5) = size of the
	 *    respective registers (00 = single, 01 = double, 10 = X)
	 * S1 (bits 4-0) = source 2 register
	 *
	 * flt is slightly different, in that the X bit is bit 9 (in T1).
	 *
	 * Note that we currently do not support the extended register
	 * file, so instructions referring to the X registers will not
	 * be processed. This includes all forms of the mov instruction.
	 */

	extu	r3,  r2,  6<26>
	cmp	r4,  r3,  0x21	/* 10 0001 */
	bcnd	ne0, r4,  _ASM_LABEL(m88110_bad_opcode)

	/*
	 * Extract the 4-bit opcode and check for the XRF bit.
	 */
	extu	r5,  r2,  4<11>	/* opcode */
	cmp	r4,  r5,  0x04	/* flt */
	bcnd	eq0, r4,  _ASM_LABEL(m88110_check_flt)

	bb1	15,  r2,  _ASM_LABEL(m88110_bad_opcode)

	/* For fcmp, we do not want to check TD. */
	cmp	r4,  r5,  0x07	/* fcmp/fcmpu */
	bcnd	eq0, r4,  _ASM_LABEL(m88110_check_t1)

	/*
	 * Check TD and RD. If TD is 01 and RD is not even,
	 * this is indeed an odd-register pair exception.
	 */
	extu	r6,  r2,  2<5>
	cmp	r7,  r6,  0x01
	bcnd	ne0, r7,  _ASM_LABEL(m88110_check_t1)

	bb1	21,  r2,  _ASM_LABEL(m88110_odd_reg)

ASLOCAL(m88110_check_t1)
	/*
	 * Check T1 and R1. If T1 is 01 and R1 is not even,
	 * this is indeed an odd-register pair exception.
	 */
	extu	r6,  r2,  2<9>
	cmp	r7,  r6,  0x01
	bcnd	ne0, r7,  _ASM_LABEL(m88110_check_t2)

	bb1	16,  r2,  _ASM_LABEL(m88110_odd_reg)

ASLOCAL(m88110_check_t2)
	/*
	 * Check T2 and R2. If T2 is 01 and R2 is not even,
	 * this is indeed an odd-register pair exception.
	 */
	extu	r6,  r2,  2<7>
	cmp	r7,  r6,  0x01
	bcnd	ne0, r7,  _ASM_LABEL(m88110_bad_opcode)

	bb1	 0,  r2,  _ASM_LABEL(m88110_odd_reg)

	br	_ASM_LABEL(m88110_bad_opcode)

ASLOCAL(m88110_check_flt)
	/*
	 * For flt, we only want to check TD. But we also want
	 * to bail out if operating on XRF.
	 */
	bb1	9,   r2,  _ASM_LABEL(m88110_bad_opcode)

	/*
	 * Check TD and RD. If TD is 01 and RD is not even,
	 * this is indeed an odd-register pair exception.
	 */
	extu	r6,  r2,  2<5>
	cmp	r7,  r6,  0x01
	bcnd	ne0, r7,  _ASM_LABEL(m88110_bad_opcode)

	bb1	21,  r2,  _ASM_LABEL(m88110_odd_reg)

ASLOCAL(m88110_bad_opcode)
	/*
	 * This is not an odd-register pair exception.
	 *
	 * We should check for an fsqrt instruction and emulate it.
	 * However since the compiler will not produce it, we can
	 * skip emulating it for now...
	 */
#endif
	br	_ASM_LABEL(m88110_fpeflt)

/*
 * Floating-point integer overflow.
 *
 * Register it in the status register, and if this exception is allowed
 * in the control register, send a trap.
 */
ASLOCAL(m88110_fiov)
	set	r3,  r3,  1<EFINV_BIT>
	fstcr	r3,  FPSR

	/* FPE_FLTSUB */
	bb1	EFINV_BIT, r4, _ASM_LABEL(m88110_fpeflt)

	jmp.n	r1
	 addu	r31, r31, 16

/*
 * Floating-point privilege violation.
 *
 * This exception is caused by fldcr, fstcr or fxcr with either a
 * non-existing register (fcr1-fcr61), or fcr0 from userland.
 */ 
ASLOCAL(m88110_fprv)
	/* ILL_PRVREG */
	or	r2, r0, T_PRIVINFLT
	bsr.n	_C_LABEL(m88110_trap)
	 or	r3, r0, r30

	ld	r1,  r31, 0
	jmp.n	r1
	 addu	r31, r31, 16

/*
 * Floating-point reserved operand.
 */
ASLOCAL(m88110_frop)
	set	r3,  r3,  1<EFINV_BIT>
	fstcr	r3,  FPSR

	/* XXX TBD lots of analysis to do here... */

	/* FPE_FLTINV */
	bb1	EFINV_BIT, r4, _ASM_LABEL(m88110_fpeflt)

	/* XXX TBD ... and then decide on a value... */

	jmp.n	r1
	 addu	r31, r31, 16

/*
 * Floating-point divide by zero.
 *
 * Register it in the status register, and if this exception is allowed
 * in the control register, send a trap.
 */
ASLOCAL(m88110_fdvz)
	set	r3,  r3,  1<EFDVZ_BIT>
	fstcr	r3,  FPSR

	/* FPE_INTDIV */
	bb1	EFDVZ_BIT, r4, _ASM_LABEL(m88110_fpeflt)

	jmp.n	r1
	 addu	r31, r31, 16

/*
 * Floating-point underflow.
 */
ASLOCAL(m88110_funf)
	set	r3,  r3,  1<EFUNF_BIT>
	set	r3,  r3,  1<EFINX_BIT>
	fstcr	r3,  FPSR

	/* FPE_FLTUND */
	bb1	EFUNF_BIT, r4, _ASM_LABEL(m88110_fpeflt)

	/* FPE_FLTRES */
	bb1	EFINX_BIT, r4, _ASM_LABEL(m88110_fpeflt)

	/* XXX TBD check rounding mode, check destination register, write
	   default value to it/them. */

	jmp.n	r1
	 addu	r31, r31, 16


/*
 * Floating-point overflow.
 */
ASLOCAL(m88110_fovf)
	set	r3,  r3,  1<EFOVF_BIT>
	set	r3,  r3,  1<EFINX_BIT>
	fstcr	r3,  FPSR

	/* FPE_FLTOVF */
	bb1	EFOVF_BIT, r4, _ASM_LABEL(m88110_fpeflt)

	/* FPE_FLTRES */
	bb1	EFINX_BIT, r4, _ASM_LABEL(m88110_fpeflt)

	/* XXX TBD check rounding mode, check destination register, write
	   default value to it/them. */

	jmp.n	r1
	 addu	r31, r31, 16

/*
 * Floating-point inexact.
 *
 * Register it in the status register, and if this exception is allowed
 * in the control register, send a trap.
 */
ASLOCAL(m88110_finx)
	set	r3,  r3,  1<EFINX_BIT>
	fstcr	r3,  FPSR

	/* FPE_FLTRES */
	bb1	EFINX_BIT, r4, _ASM_LABEL(m88110_fpeflt)

	jmp.n	r1
	 addu	r31, r31, 16

ASLOCAL(m88110_fpeflt)
	/*
	 * Do not call trap() if the exception comes from kernel mode.
	 */
	ld	r5, r30, EF_EPSR
	bb1	PSR_SUPERVISOR_MODE_BIT, r5, _ASM_LABEL(m88110_fp_return)

	or	r2, r0, T_FPEPFLT
	bsr.n	_C_LABEL(m88110_trap)
	 or	r3, r0, r30

ASLOCAL(m88110_fp_return)
	/*
	 * Reset the exception cause register
	 */
	fstcr	r0,  FPECR

ASLOCAL(m88110_fp_return_noreset)
	ld	r1,  r31, 0
	jmp.n	r1
	 addu	r31, r31, 16

#ifdef notyet
/*
 * Odd-numbered register pair emulation.
 *
 * On entry:
 *	r2 = faulting instruction
 *	r5 = instruction sub opcode (bits 14-11)
 *	r30 = exception frame
 *
 * We'll issue a similar instruction using only even-numbered register pairs,
 * update the exception frame registers with the result, and skip the
 * emulated instruction.
 */
ASLOCAL(m88110_odd_reg)
	or.u	r10, r0,  hi16(_ASM_LABEL(m88110_odd_table))
	or	r10, r10, lo16(_ASM_LABEL(m88110_odd_table))
	ld	r9,  r10 [r5]
	jmp	r9

ASLOCAL(m88110_odd_table)
	.word	_ASM_LABEL(m88110_odd_fmul)
	.word	_ASM_LABEL(m88110_odd_fcvt)
	.word	_ASM_LABEL(m88110_bad_opcode)
	.word	_ASM_LABEL(m88110_bad_opcode)

	.word	_ASM_LABEL(m88110_odd_flt)
	.word	_ASM_LABEL(m88110_odd_fadd)
	.word	_ASM_LABEL(m88110_odd_fsub)
	.word	_ASM_LABEL(m88110_odd_fcmp)

	.word	_ASM_LABEL(m88110_bad_opcode)
	.word	_ASM_LABEL(m88110_odd_int)
	.word	_ASM_LABEL(m88110_odd_nint)
	.word	_ASM_LABEL(m88110_odd_trnc)

	.word	_ASM_LABEL(m88110_bad_opcode)
	.word	_ASM_LABEL(m88110_bad_opcode)
	.word	_ASM_LABEL(m88110_odd_fdiv)
	.word	_ASM_LABEL(m88110_bad_opcode)

ASLOCAL(m88110_odd_fmul)
ASLOCAL(m88110_odd_fcvt)
ASLOCAL(m88110_odd_flt)
ASLOCAL(m88110_odd_fadd)
ASLOCAL(m88110_odd_fsub)
ASLOCAL(m88110_odd_fcmp)
ASLOCAL(m88110_odd_int)
ASLOCAL(m88110_odd_nint)
ASLOCAL(m88110_odd_trnc)
ASLOCAL(m88110_odd_fdiv)
	/* XXX TBD */
	br	_ASM_LABEL(m88110_fp_return)
#endif
@


1.5
log
@Change the EF_xxx constants to be real offsets within the trapframe, instead
of offsets / sizeof(register_t), and nuke the REG_OFF macro. No functional
change.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88110_fp.S,v 1.4 2007/12/08 18:39:50 miod Exp $	*/
@


1.4
log
@Better siginfo fault codes for floating point exceptions on 88110, with
more work in progress to handle these exceptions correctly, and document
a new undocumented and evil chip bug while there.
@
text
@d1 1
a1 1
/*	$OpenBSD: m88110_fp.S,v 1.3 2007/12/02 21:32:08 miod Exp $	*/
d61 3
a63 3
	st	r2,  r30, EF_FPECR * 4
	st	r3,  r30, EF_FPSR * 4
	st	r4,  r30, EF_FPCR * 4
d94 1
a94 1
	ld	r5, r30, EF_EPSR * 4
d129 1
a129 1
	ld	r6,  r30, EF_EXIP * 4
d358 1
a358 1
	ld	r5, r30, EF_EPSR * 4
@


1.3
log
@The beginning of a real floating-point exception handler for the 88110. The
existing code to enable TCFP was broken, as it was not setting the TCFP bit
in the right register.

So far, the exception handler will deliver SIGFPE in all cases. It will
eventually do the necessary rounding, and handle the odd-numbered register
pair operation, as I get time to write this (or see how much can be lifted
from the 88100 floating-point exception code).
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d99 8
d108 2
a109 1
	 * This can be:
d113 95
d209 1
d211 9
a219 1
	/* XXX TBD */
d221 9
d355 6
d365 7
d375 54
@


1.2
log
@Take advantage of the recent ABI change to use less stack space and do
less stack pointer manipulation; the kernel needs to be compiled by an
up-to-date compiler now, or a tree will fall on your house.
@
text
@d1 2
a2 1
/* $OpenBSD: m88110_fp.S,v 1.1 2004/04/29 14:33:27 miod Exp $	*/
d4 6
a9 2
 * Copyright (c) 1999 Steve Murphree, Jr.
 * All rights reserved.
d11 7
a17 32
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Christopher G. Demetriou.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/* Floating point trouble routines */
/*
 * August 1, 1999
 * smurph@@OpenBSD.org
 *
 * Additions to support MVME197 (mc88110) mmu routines.
d20 1
a20 10
/*
 * This is cheesy.  I'm using the TCFP features of the mc88110
 * because it was easy.  It is not 100% IEEE.  But it may be
 * close enough.  We shall see...  XXXsmurph
 * Err... TCFP == "Time Critical Floating Point"
 *
 * The only two SFU1 exceptions that can occure in TCFP mode are:
 * 1) Unimplemented Floating Point Instruction
 * 2) Floating Point Privilege Violation
 */
d22 1
a22 1
#include "assym.h"
a23 1
#include <machine/asm.h>
d25 22
a46 2
ASENTRY(m88110_Xfp_precise)
	or	r29, r3, r0     /*  r29 is now the E.F. */
d49 187
a235 1
	st	r29, r31, 4
d237 1
a237 44
	ld	r2, r29, EF_FPSR * 4
	ld	r3, r29, EF_FPCR * 4
	ld	r4, r29, EF_FPECR * 4

	/*
	 * Load into r1 the return address for the 0 handlers.  Looking
	 * at FPECR, branch to the appropriate 0 handler.  However,
	 * if none of the 0 bits are enabled, then a floating point
	 * instruction was issued with the floating point unit disabled.  This
	 * will cause an unimplemented opcode 0.
	 */

   	bb0	6,r4, 2f   	/* branch to m88110_FPunimp if bit set */
     	br	_ASM_LABEL(m88110_FPuimp)
2:  	bb0	5,r4, 3f 	/* branch to m88110_FPpriviol if bit set */
	br	_ASM_LABEL(m88110_FPpriviol)
3:
	or.u	r4, r4, 0xffff

ASLOCAL(m88110_FPuimp)
	subu	r31,r31,16		/* allocate stack */
	st	r1,r31,4		/* save return address */
	st	r3,r31,0		/* save exception frame */
	or	r2,r0,T_FPEPFLT		/* load trap type */
	bsr.n	_C_LABEL(m88110_trap)	/* trap */
	 or	r3, r29, r0
	ld	r1,r31,4		/* recover return address */
 	jmp.n	r1
	 addu	r31,r31,16		/* deallocate stack */

ASLOCAL(m88110_FPpriviol)
	subu	r31,r31,16		/* allocate stack */
	st	r1,r31,4		/* save return address */
	st	r3,r31,0		/* save exception frame */
	or	r2,r0,T_PRIVINFLT	/* load trap type */
	bsr.n	_C_LABEL(m88110_trap)	/* trap */
	 or	r3, r29, r0
	ld	r1,r31,4		/* recover return address */
 	jmp.n	r1
	 addu	r31,r31,16		/* deallocate stack */

ENTRY(set_tcfp)
	or.u	r2, r0, hi16(0x200000)
	or	r2, r2, lo16(0x200000)
d239 1
a239 1
	 fstcr	r2, fcr0
@


1.1
log
@Continue factorizing m88k common code, this time files in <arch>/<arch>
which were copied verbatim from mvme88k to luna88k.

This requires backing out syntactic sugar in mvme88k kernel configuration
files which would deduct the required processor types from the board models,
as the common code only depends upon the M88100 and M88110 defines.
@
text
@d1 1
a1 1
/* $OpenBSD: m88110_fp.S,v 1.11 2003/08/12 19:33:27 miod Exp $	*/
d57 3
a59 3
	subu	r31, r31, 40
	st	r1,  r31, 32
	st	r29, r31, 36
d81 3
a83 3
	subu	r31,r31,40		/* allocate stack */
	st	r1,r31,36		/* save return address */
	st	r3,r31,32		/* save exception frame */
d85 5
a89 5
	or	r3, r29, r0
	bsr	_C_LABEL(m88110_trap)	/* trap */
	ld	r1,r31,36		/* recover return address */
	addu	r31,r31,40		/* deallocate stack */
 	jmp	r1
d92 3
a94 3
	subu	r31,r31,40		/* allocate stack */
	st	r1,r31,36		/* save return address */
	st	r3,r31,32		/* save exception frame */
d96 3
a98 3
	or	r3, r29, r0
	bsr	_C_LABEL(m88110_trap)	/* trap */
	ld	r1,r31,36		/* recover return address */
d100 1
a100 1
	 addu	r31,r31,40		/* deallocate stack */
@


1.1.2.1
log
@Merge with the trunk
@
text
@d1 1
a1 1
/* $OpenBSD$	*/
@

