head	1.61;
access;
symbols
	OPENBSD_6_1_BASE:1.61
	OPENBSD_6_0:1.61.0.12
	OPENBSD_6_0_BASE:1.61
	OPENBSD_5_9:1.61.0.8
	OPENBSD_5_9_BASE:1.61
	OPENBSD_5_8:1.61.0.10
	OPENBSD_5_8_BASE:1.61
	OPENBSD_5_7:1.61.0.2
	OPENBSD_5_7_BASE:1.61
	OPENBSD_5_6:1.61.0.6
	OPENBSD_5_6_BASE:1.61
	OPENBSD_5_5:1.61.0.4
	OPENBSD_5_5_BASE:1.61
	OPENBSD_5_4:1.58.0.2
	OPENBSD_5_4_BASE:1.58
	OPENBSD_5_3:1.57.0.2
	OPENBSD_5_3_BASE:1.57
	OPENBSD_5_2:1.55.0.8
	OPENBSD_5_2_BASE:1.55
	OPENBSD_5_1_BASE:1.55
	OPENBSD_5_1:1.55.0.6
	OPENBSD_5_0:1.55.0.4
	OPENBSD_5_0_BASE:1.55
	OPENBSD_4_9:1.55.0.2
	OPENBSD_4_9_BASE:1.55
	OPENBSD_4_8:1.54.0.6
	OPENBSD_4_8_BASE:1.54
	OPENBSD_4_7:1.54.0.2
	OPENBSD_4_7_BASE:1.54
	OPENBSD_4_6:1.54.0.4
	OPENBSD_4_6_BASE:1.54
	OPENBSD_4_5:1.53.0.2
	OPENBSD_4_5_BASE:1.53
	OPENBSD_4_4:1.46.0.2
	OPENBSD_4_4_BASE:1.46
	OPENBSD_4_3:1.45.0.2
	OPENBSD_4_3_BASE:1.45
	OPENBSD_4_2:1.24.0.2
	OPENBSD_4_2_BASE:1.24
	OPENBSD_4_1:1.22.0.2
	OPENBSD_4_1_BASE:1.22
	OPENBSD_4_0:1.19.0.2
	OPENBSD_4_0_BASE:1.19
	OPENBSD_3_9:1.16.0.2
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.10.0.2
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.6.0.2
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.5.0.2
	OPENBSD_3_6_BASE:1.5;
locks; strict;
comment	@# @;


1.61
date	2013.09.05.20.40.32;	author miod;	state Exp;
branches;
next	1.60;

1.60
date	2013.08.18.22.10.58;	author miod;	state Exp;
branches;
next	1.59;

1.59
date	2013.08.15.19.29.10;	author miod;	state Exp;
branches;
next	1.58;

1.58
date	2013.05.25.16.22.12;	author miod;	state Exp;
branches;
next	1.57;

1.57
date	2013.01.05.11.20.56;	author miod;	state Exp;
branches;
next	1.56;

1.56
date	2012.12.30.18.13.19;	author miod;	state Exp;
branches;
next	1.55;

1.55
date	2010.12.23.20.05.08;	author miod;	state Exp;
branches;
next	1.54;

1.54
date	2009.03.15.20.39.53;	author miod;	state Exp;
branches;
next	1.53;

1.53
date	2009.03.01.17.43.25;	author miod;	state Exp;
branches;
next	1.52;

1.52
date	2009.02.21.18.35.22;	author miod;	state Exp;
branches;
next	1.51;

1.51
date	2009.02.16.22.55.03;	author miod;	state Exp;
branches;
next	1.50;

1.50
date	2009.02.16.20.18.48;	author miod;	state Exp;
branches;
next	1.49;

1.49
date	2009.02.15.22.25.49;	author miod;	state Exp;
branches;
next	1.48;

1.48
date	2009.02.13.23.33.51;	author miod;	state Exp;
branches;
next	1.47;

1.47
date	2009.02.08.21.40.58;	author miod;	state Exp;
branches;
next	1.46;

1.46
date	2008.07.28.17.49.38;	author miod;	state Exp;
branches;
next	1.45;

1.45
date	2007.12.25.00.29.49;	author miod;	state Exp;
branches;
next	1.44;

1.44
date	2007.12.22.19.38.33;	author miod;	state Exp;
branches;
next	1.43;

1.43
date	2007.12.21.23.56.54;	author miod;	state Exp;
branches;
next	1.42;

1.42
date	2007.12.05.22.12.32;	author miod;	state Exp;
branches;
next	1.41;

1.41
date	2007.12.02.21.32.08;	author miod;	state Exp;
branches;
next	1.40;

1.40
date	2007.12.02.21.28.40;	author miod;	state Exp;
branches;
next	1.39;

1.39
date	2007.12.02.21.27.02;	author miod;	state Exp;
branches;
next	1.38;

1.38
date	2007.11.22.23.30.11;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2007.11.22.23.29.27;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2007.11.22.23.28.52;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2007.11.22.23.28.06;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2007.11.21.19.30.09;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2007.11.17.05.36.23;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2007.11.15.21.27.22;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2007.11.15.21.25.40;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2007.11.15.21.24.14;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2007.11.15.21.23.16;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2007.11.14.22.55.50;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2007.11.09.22.46.38;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2007.10.16.04.57.39;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2007.10.13.12.54.03;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2007.05.18.16.35.54;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2007.05.12.20.02.14;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2007.02.11.12.39.33;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2006.11.19.19.36.40;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2006.11.18.22.53.07;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2006.05.14.08.37.39;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2006.05.08.14.34.01;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2006.05.08.14.03.34;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2005.12.11.21.45.30;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2005.12.03.18.20.50;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2005.12.03.14.30.06;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2005.11.28.22.21.15;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2005.10.12.19.05.44;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2005.09.25.20.30.03;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2005.04.30.16.46.51;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2005.04.27.21.12.46;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2005.04.27.14.09.45;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2005.04.19.18.37.52;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	2004.09.15.05.56.33;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2004.08.05.21.34.11;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2004.08.02.08.34.59;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2004.07.28.12.28.48;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2004.07.28.12.28.07;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2004.07.27.12.16.06;	author miod;	state Exp;
branches;
next	;


desc
@@


1.61
log
@Service the 88100 floating-point exceptions through trap(), keeping the
existing assembly code for now. Make sure the trapframe images of %fpsr and
%fpcr are updated by the assembly handlers (in addition to the real registers
which were already updated). When returning into trap(), check these updated
value to decide whether a signal ought to be sent to the userland process.

With these changes, computations which ought to cause a signal to be delivered
will indeed trigger the signal, even when they are handled by the completion
code in the floating point exception handlers.

This fixes the libc/ieeefp/except and lib/fenv regress tests on 88100 systems,
finally!
@
text
@/*   $OpenBSD: eh_common.S,v 1.60 2013/08/18 22:10:58 miod Exp $	*/
/*
 * Mach Operating System
 * Copyright (c) 1993-1991 Carnegie Mellon University
 * Copyright (c) 1991 OMRON Corporation
 * Copyright (c) 1996 Nivas Madhur
 * Copyright (c) 1998 Steve Murphree, Jr.
 * All Rights Reserved.
 *
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON AND OMRON ALLOW FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON AND OMRON DISCLAIM ANY LIABILITY OF ANY KIND
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

/*
 * NOTICE: This is not a standalone file.  To use it, define the PFSR_SAVE
 * macro (if supporting 88100 processors) and #include this file in your
 * port's eh.S:
 * #include <m88k/m88k/eh_common.S>
 */

/*
 * In the following discussion, references are made to:
 *    MC88100 - RISC MICROPROCESSOR USER'S MANUAL
 * (second edition). Reference in []s refer to section numbers.
 *
 * This discussion assumes that you are at least vaguely familiar with 88100
 * exception handling (chapter 6), the BSD kernel, and that you have a brain
 * (and use it while reading this).
 *
 * I also assume (and hope) that you're not offended by frequent misspellings.
 *
 * Jeffrey Friedl
 * jfriedl@@rna.ncl.omron.co.jp
 * December, 1989
 *  -------------------------------------------------------------------
 *
 * EXCEPTIONS, INTERRUPTS, and TRAPS
 * ---------------------------------
 * This is the machine exception handler.
 * In the MC88100, various "conditions" cause an exception, where
 * processing momentarily jumps here to "service" the exception,
 * and then continues where it left off.
 *
 * There are a number of different types of exceptions.
 * For example, exception #6 is the privilege violation exception which
 * is raised when the user tries to execute a supervisor-only instruction.
 *
 * Exception #1 is the interrupt exception, and is raised when an
 * outside device raises the INT line on the CPU.  This happens,
 * for example, when the clock signals that it is time for a context
 * switch, or perhaps the disk drive signaling that some operation
 * is complete.
 *
 * Traps are also exceptions.  Traps are ways for user programs to request
 * kernel operations.  For example, "tcnd eq0, r0, 450" will raise
 * exception 450, the system call exception.
 *
 *
 * SERVICING AN EXCEPTION
 * -----------------------
 * When an exception occurs, each control register is saved in its
 * respective shadow register and execution continues from the
 * appropriate exception handler.  The exception handler must
 *      - save the context from the time of the exception
 *      - service the exception
 *      - restore the context (registers, etc)
 *      - pick up from where the exception occurred.
 *
 * The context is saved on a stack. Actually, in the user_state area
 * in the PCB if the exception happens in user mode.
 *
 * Servicing the exception is usually straightforward and in fact not dealt
 * with very much here.  Usually a C routine is called to handle it.
 * For example, when a privilege exception is raised, the routine that sends
 * an "illegal instruction" signal to the offending process is called.
 *
 * When the exception has been serviced, the context is restored from the
 * stack and execution resumes from where it left off.
 *
 * In more detail:
 *
 * Saving the exception-time context.
 * ---------------------------------
 *     In saving the exception-time context, we copy the shadow and general
 * purpose registers to memory.  Since one exception may occur while
 * servicing another, the memory used to save the exception-time context may
 * not be static (i.e. the same every time).  Thus, memory on a stack is set
 * aside for the exception frame (area where the exception-time context is
 * saved). The same stack is also used when C routines are called (to
 * service the exception).
 *
 *    Each process has a stack in kernel space (called the "kernel stack",
 * short for "process's kernel stack) as well as the user space stack.  When
 * entering the kernel from user space, the kernel stack is unused.  On this
 * stack we save the exception state and (most likely call a C routine to)
 * service the exception.
 *
 * Before servicing an exception, several issues must be addressed.
 *
 * 1) When an interrupt is recognized by the hardware, the data pipeline is
 *    allowed to clear.  However, if one of these data accesses faults (bad
 *    reference, or a reference to a page which needs to be swapped in), that
 *    reference, as well as any others in the pipeline at the time (at most
 *    three total) are left there, to be taken care of by the exception
 *    handler [6.4.1].  This involves swapping in the proper page and
 *    manually doing the appropriate load or store.
 *
 *    The other (at most, two other) data accesses that might have been in
 *    the pipeline must also be manually completed (even though they may not
 *    be at fault [yes, that's a bad pun, thank you]).
 *
 * 2) If any of the (at most three) uncompleted data access in the pipeline
 *    are loads (from memory to a register), then the bit for the destination
 *    register is set in the SSBR.  Since the hardware will never complete
 *    that load (since we do it manually), the hardware will never clear that
 *    SSBR bit.  Thus, we must clear it manually.  If this isn't done, the
 *    system will hang waiting for a bit to clear that will never.
 *
 * 3) If the exception is the privilege violation exception, the bounds
 *    check exception, or the misaligned access exception, the
 *    destination register bit in the SSBR may need to be cleared.
 *
 * 4) If the exception is one of the floating exceptions, then the
 *    destination register for that floating process won't be written,
 *    and the SSBR must be cleared explicitly.
 *
 * 5) The FPU must be enabled (as it is disabled by the exception processing
 *    hardware) and allowed to complete actions in progress. This is
 *    so that it may be used in the servicing of any instruction.
 *    When the FPU is being restarted, operations attempting to complete
 *    may themselves fault (raising another exception).
 *
 * More on Restarting the FPU
 * --------------------------
 *   The manual [section 6.4.3.4] gives only minor mention to this
 * rather complex task.  Before the FPU is restarted all SSBR bits are
 * cleared for actions that the exception handler completes (as mentioned
 * above) so that the SSBR is clear unless there are FPU operations that
 * have not actually been completed (and hence not written to the registers).
 * Also, all control registers (at least all those that we care about) are
 * saved to the stack exception frame before the FPU is restarted (this
 * is important... the reason comes later).
 *
 * The FPU is restarted by doing an rte to a trap-not-taken (the rte
 * actually enables the fpu because we ensure that the EPSR has the
 * FPU-enable bit on; the trap-not-taken ensures anything in the FPU
 * completes by waiting until scoreboard register is clear).
 *
 * At the time the FPU is restarted (the rte to the trap-not-taken) the FPU
 * can write to ANY of the general registers.  Thus, we must make sure that
 * all general registers (r1..r31) are in their pre-exception state so that
 * when saved to the exception frame after the FPU is enabled, they properly
 * reflect any changes made by the FPU in being restarted.
 *
 * Because we can't save the pointer to the exception frame in a general
 * register during the FPU restart (it could get overwritten by the FPU!),
 * we save it in a control register, SR3, during the restart.
 *
 * HOWEVER .....
 *
 * Because other uncompleted actions in the FPU may fault when the FPU is
 * restarted, a new exception may be raised during the restart. This may
 * happen recursively a number of times. Thus, during a restart, ANY register
 * whatsoever may be modified, including control registers.  Because of this
 * we must make sure that the exception handler preserves SR3 throughout
 * servicing an exception so that, if the exception had been raised during
 * an FPU restart, it is returned unmolested when control returns to the FPU
 * restart.
 *
 * Thus: if an exception is from kernel space, we MUST preserve SR3.
 * (if it from user space, no FPU-enable can be in progress and SR3 is
 *  unimportant).
 *
 * Now is a good time to recap SR1..SR3 usage:
 *   SR1 - CPU flags (exception handler flags)
 *   SR2 - generally free
 *   SR3 - free only if the exception is from user mode
 *
 * Once the FPU has been restarted, the general registers are saved to the
 * exception frame.  If the exception is not the interrupt exception,
 * interrupts are enabled and any faulted data accesses (see above) are
 * serviced.  In either case, the exception is then serviced (usually by
 * calling a C routine).  After servicing, any faulted data accesses are
 * serviced (if it had been the interrupt exception).  The context is then
 * restored and control returns to where the exception occurred.
 *
 */

#include "assym.h"

#include <machine/param.h>
#include <machine/asm.h>
#include <machine/trap.h>

/*
 * SR1 - CPU FLAGS REGISTER
 *
 * SR1 contains flags about the current CPU status.
 *
 * The bit FLAG_IGNORE_DATA_EXCEPTION indicates that any data exceptions
 * 	should be ignored (well, at least treated in a special way).
 * The bit FLAG_ENABLING_FPU indicates that the exception handler is
 * 	in the process of enabling the FPU (so that an exception can
 * 	be serviced).  This is needed because enabling the FPU can
 *	cause other exceptions to happen, and the whole system is
 *	in a rather precarious state and so special cautions must
 * 	be taken.
 */
#define FLAG_IGNORE_DATA_EXCEPTION	0
#define FLAG_ENABLING_FPU		1
#define FLAG_FROM_KERNEL		2

/* GENeral REGister OFFset into the E.F. (exception frame) */
#define GENREG_OFF(num)		(EF_R0 + (num) * 4)

/* Invoke a C function with 2 arguments */
#define	CALL(NAME, ARG1, ARG2) \
	or	%r2, %r0, ARG1; \
	bsr.n	_C_LABEL(NAME); \
	 or	%r3, %r0, ARG2

/* Invoke a function and return elsewhere */
/* CAREFUL: needs to have `RET' after the XCALL in memory */
#define	XCALL(NAME, RET) \
	bsr.n	NAME; \
	 addu	%r1, %r1, RET - . - 4

/*
 * Some registers used during the setting up of the new exception frame.
 * Don't choose r1, r30, or r31 for any of them.
 *
 * Also, if any are 'r2' or 'r3', be careful using with CALL above!
 */
#define	FLAGS			%r2
#define	TMP			%r3
#define	TMP2			%r10
#define	TMP3			%r11
#define	SAVE_TMP2(ef)		st	%r10, ef, GENREG_OFF(10)
#define	SAVE_TMP3(ef)		st	%r11, ef, GENREG_OFF(11)
#define	RESTORE_TMP2(ef)	ld	%r10, ef, GENREG_OFF(10)
#define	RESTORE_TMP3(ef)	ld	%r11, ef, GENREG_OFF(11)

/*
 * EF_SR3
 *   A place to save the exception-time SR3 from just after the
 *   time when an exception is raised until just after the FPU
 *   has been restarted.  This does not necessarly conflict with
 *   the general registers (though it can if you're not careful)
 *   and so we can use a spot later used to save a general register.
 */
#define	EF_SR3		GENREG_OFF(5)

	.text
	.align 3

/*
 *
 * #define PREP881x0(NAME, NUM, SSBR_STUFF, FLAG_CHECK)
 *
 * This is the "exception processing preparation" common to all exception
 * processing.  It is used in the following manner:
 *
 *	ASGLOBAL(foo_handler)
 *		PREP881x0("foo", 11, SSBR_Stuff, Precheck_Stuff)
 *		or	%r2, %r0, T_FOO_FAULT
 *		or	%r3, %r0, %r30
 *		XCALL(trapXXX, check_ast)
 *
 * This defines the exception handler for the "foo" exception.
 * The arguments are:
 * NAME
 *	String for debugging (more info later)
 * NUM
 *	The exception number [see the manual, Table 6-1]
 * SSBR_STUFF
 *	If the exception might leave some bits in the SSBR set,
 *	this should indicate how they are cleared.
 * FLAG_PRECHECK
 *	This is for the data access exception only. See it for
 *	more info.
 *
 * What's in between PREP881x0() and check_ast (usually a XCALL)
 * is the actual servicing of the interrupt.  During this time, any
 * register may be used freely as they've all been saved in the
 * exception frame (which is pointed to by r30).
 */

#ifdef M88100
#define PREP88100(NAME, NUM, SSBR_STUFF, FLAG_PRECHECK) \
	xcr	FLAGS, FLAGS, SR1			; \
	FLAG_PRECHECK					  \
	/* the bsr later clobbers r1, so save now */	  \
	stcr	%r1, SR2	/* r1 now free */	; \
	/* set or clear the FLAG_FROM_KERNEL bit */	  \
	ldcr	%r1, EPSR				; \
	bb0.n	PSR_SUPERVISOR_MODE_BIT, %r1, 1f	; \
	 clr	FLAGS, FLAGS, 1<FLAG_FROM_KERNEL>	; \
	set	FLAGS, FLAGS, 1<FLAG_FROM_KERNEL>	; \
	/* get a stack (exception frame) */		  \
1:	bsr	_ASM_LABEL(m88100_setup_phase_one)	; \
	/* TMP2 now free -- use to set EF_VECTOR */	  \
	or	TMP2, %r0, NUM				; \
	st	TMP2, %r31, EF_VECTOR			; \
	/* Clear any bits in the SSBR (held in TMP) */	  \
	/* SSBR_STUFF may be empty, though.         */	  \
	SSBR_STUFF					  \
	/* call setup_phase_two to restart the FPU  */	  \
	/* and to save all general registers.       */	  \
	bsr	_ASM_LABEL(m88100_setup_phase_two)
#endif

#ifdef M88110
#define PREP88110(NAME, NUM, FLAG_PRECHECK) \
	xcr	FLAGS, FLAGS, SR1			; \
	FLAG_PRECHECK					  \
	/* the bsr later clobbers r1, so save now */	; \
	stcr	%r1, SR2	/* r1 now free */	; \
	/* set or clear the FLAG_FROM_KERNEL bit */	; \
	ldcr	%r1, EPSR 				; \
	clr	FLAGS, FLAGS, 1<FLAG_FROM_KERNEL> 	; \
	bb0	PSR_SUPERVISOR_MODE_BIT, %r1, 1f 	; \
	set	FLAGS, FLAGS, 1<FLAG_FROM_KERNEL>	; \
	/* get a stack and an exception frame */	; \
1:	bsr	_ASM_LABEL(m88110_setup_phase_one)	; \
	/* TMP2 now free -- use to set EF_VECTOR */	; \
	or	TMP2, %r0, NUM				; \
	/* call setup_phase_two to save all general */	; \
	/* registers.                               */	; \
	st	TMP2, %r30, EF_VECTOR			; \
	bsr	_ASM_LABEL(m88110_setup_phase_two)
#endif

/* Some defines for use with PREP88100() */
#define	Clear_SSBR_Dest \
	bsr	_ASM_LABEL(clear_dest_ssbr_bit);
#define	M88100_Data_Precheck \
	bb1.n	FLAG_IGNORE_DATA_EXCEPTION, FLAGS, \
	    _ASM_LABEL(m88100_ignore_data_exception);
#define	M88110_Data_Precheck \
	bb1.n	FLAG_IGNORE_DATA_EXCEPTION, FLAGS, \
	    _ASM_LABEL(m88110_ignore_data_exception);

#ifdef M88100
/*
 * 88100 exception handlers
 */

/* unknown exception handler */
GLOBAL(unknown_handler)
	PREP88100("unknown", 0,,)
	or	%r2, %r0, T_UNKNOWNFLT
	or	%r3, %r0, %r30
	XCALL(_C_LABEL(m88100_trap), _ASM_LABEL(check_ast))

/* interrupt exception handler */
GLOBAL(interrupt_handler)
	PREP88100("interrupt", 1,,)
	or	%r2, %r0, %r30
	XCALL(_C_LABEL(interrupt), _ASM_LABEL(check_ast))

/* instruction access exception handler */
GLOBAL(instruction_access_handler)
	PREP88100("inst", 2,,)
	or	%r2, %r0, T_INSTFLT
	or	%r3, %r0, %r30
	XCALL(_C_LABEL(m88100_trap), _ASM_LABEL(check_ast))

/*
 * data access exception handler --
 *  See badaddr() below for info about Data_Precheck.
 */
GLOBAL(data_exception_handler_bootstrap)
	PREP88100("data", 3,, M88100_Data_Precheck)
	/* No need to call m88100_trap(T_DATAFLT) as PREP will do this for us */
	br	_ASM_LABEL(check_ast)
GLOBAL(data_exception_handler)
	PREP88100("data", 3,,)
	/* No need to call m88100_trap(T_DATAFLT) as PREP will do this for us */
	br	_ASM_LABEL(check_ast)

/* misaligned access exception handler */
GLOBAL(misaligned_handler)
	PREP88100("misalign", 4, Clear_SSBR_Dest,)
	or	%r2, %r0, T_MISALGNFLT
	or	%r3, %r0, %r30
	XCALL(_C_LABEL(m88100_trap), _ASM_LABEL(check_ast))

/* unimplemented opcode exception handler */
GLOBAL(unimplemented_handler)
	PREP88100("unimp", 5,,)
	or	%r2, %r0, T_ILLFLT
	or	%r3, %r0, %r30
	XCALL(_C_LABEL(m88100_trap), _ASM_LABEL(check_ast))

/*
 * Some versions of the chip have a bug whereby false privilege
 * violation exceptions are raised. If the valid bit in the SXIP is clear,
 * it is false.  If so, just return.  The code before PREP handles this....
 */
GLOBAL(privilege_handler)
	stcr	%r1, SR2	/* hold r1 for a moment */
	ldcr	%r1, SXIP	/* look at the sxip... valid bit set? */
	bb1.n	RTE_VALID_BIT, %r1, 1f	/* skip over if a valid exception */
	 ldcr	%r1, SR2	/* restore r1 */
	RTE
1:	PREP88100("privilege", 6, Clear_SSBR_Dest,)
	or	%r2, %r0, T_PRIVINFLT
	or	%r3, %r0, %r30
	XCALL(_C_LABEL(m88100_trap), _ASM_LABEL(check_ast))

/* bounds checking exception handler */
GLOBAL(bounds_handler)
	PREP88100("bounds", 7, Clear_SSBR_Dest,)
	or	%r2, %r0, T_BNDFLT
	or	%r3, %r0, %r30
	XCALL(_C_LABEL(m88100_trap), _ASM_LABEL(check_ast))

/* integer divide-by-zero exception handler */
GLOBAL(divide_handler)
	PREP88100("divide", 8, Clear_SSBR_Dest,)
	or	%r2, %r0, T_ZERODIV
	or	%r3, %r0, %r30
	XCALL(_C_LABEL(m88100_trap), _ASM_LABEL(check_ast))

/* integer overflow exception handler */
GLOBAL(overflow_handler)
	PREP88100("overflow", 9,,)
	or	%r2, %r0, T_OVFFLT
	or	%r3, %r0, %r30
	XCALL(_C_LABEL(m88100_trap), _ASM_LABEL(check_ast))

/* Floating-point precise handler */
#define	FPp_SSBR_STUFF \
	bsr	_ASM_LABEL(clear_FPp_ssbr_bit);
GLOBAL(fp_precise_handler)
	PREP88100("FPU precise", 114, FPp_SSBR_STUFF,)
	or	%r2, %r0, T_FPEPFLT
	or	%r3, %r0, %r30
	XCALL(_C_LABEL(m88100_trap), _ASM_LABEL(check_ast))

/* Floating-point imprecise handler */
#define	FPi_SSBR_STUFF \
	bsr	_ASM_LABEL(clear_FPi_ssbr_bit);
GLOBAL(fp_imprecise_handler)
	PREP88100("FPU imprecise", 115, FPi_SSBR_STUFF,)
	or	%r2, %r0, T_FPEIFLT
	or	%r3, %r0, %r30
	XCALL(_C_LABEL(m88100_trap), _ASM_LABEL(check_ast))

/* trap 450: system calls */
GLOBAL(syscall_handler)
	PREP88100("syscall", 450,,)
	ld	%r2, %r30, GENREG_OFF(13)
	or	%r3, %r0, %r30
	XCALL(_C_LABEL(m88100_syscall), _ASM_LABEL(check_ast))

/* trap 451: cache flush (necessary for trampolines) */
GLOBAL(cache_flush_handler)
	PREP88100("cache_flush", 451,,)
	or	%r2, %r0, %r30
	XCALL(_C_LABEL(cache_flush), _ASM_LABEL(check_ast))

GLOBAL(sigsys)
	PREP88100("sigsys", 501,,)
	or	%r2, %r0, T_SIGSYS
	or	%r3, %r0, %r30
	XCALL(_C_LABEL(m88100_trap), _ASM_LABEL(check_ast))

GLOBAL(stepbpt)
	PREP88100("stepbpt", 504,,)
	or	%r2, %r0, T_STEPBPT
	or	%r3, %r0, %r30
	XCALL(_C_LABEL(m88100_trap), _ASM_LABEL(check_ast))

GLOBAL(userbpt)
	PREP88100("userbpt", 511,,)
	or	%r2, %r0, T_USERBPT
	or	%r3, %r0, %r30
	XCALL(_C_LABEL(m88100_trap), _ASM_LABEL(check_ast))

#ifdef DDB
GLOBAL(break)
	PREP88100("break", 130,,)
	or	%r2, %r0, T_KDB_BREAK
	or	%r3, %r0, %r30
	XCALL(_C_LABEL(m88100_trap), _ASM_LABEL(check_ast))

GLOBAL(trace)
	PREP88100("trace", 131,,)
	or	%r2, %r0, T_KDB_TRACE
	or	%r3, %r0, %r30
	XCALL(_C_LABEL(m88100_trap), _ASM_LABEL(check_ast))

GLOBAL(entry)
	PREP88100("kdb", 132,,)
	or	%r2, %r0, T_KDB_ENTRY
	or	%r3, %r0, %r30
	XCALL(_C_LABEL(m88100_trap), _ASM_LABEL(check_ast))
#endif

/*
 * The error exception and reset exception handler.
 *
 * The error exception is raised when any other non-trap exception is raised
 * while shadowing is off. This is Bad News.
 *
 * The reset exception is raised when the RST signal is asserted (machine
 * is reset), the value of VBR is changed after exceptions are enabled,
 * or when a jmp, br/bsr to addr 0 (accidents do happen :-)
 * To tell the difference, you should check the value of r1 and the valid
 * bit of SXIP.
 * Upon a real reset, VBR is set to zero (0), so code must be at addr 0
 * to handle it!!!
 *
 * The shadow registers are not valid in this case (shadowing was off, if this
 * was an error exception, and may not be on, if this was a reset exception).
 * R1-R31 may be interesting though, so we'll save them.
 *
 * We'll not worry about trashing r26-29 here,
 * since they aren't generally used.
 */
GLOBAL(error_handler)
	br.n	1f
	 or	%r29, %r0, 10
GLOBAL(reset_handler)
	or	%r29, %r0, 0
1:
	or	%r26, %r0,  %r31	/* save old stack */
	or.u	%r31, %r0,  %hi16(_ASM_LABEL(initstack_end))
	or	%r31, %r31, %lo16(_ASM_LABEL(initstack_end))

#ifdef DEBUG
	/* zero the stack, so we'll know what we're lookin' at */
	or.u	%r27, %r0,  %hi16(_ASM_LABEL(initstack))
	or	%r27, %r27, %lo16(_ASM_LABEL(initstack))
1:	cmp	%r28, %r27, %r31
	bb1	ge,   %r28, 2f	/* branch if at the end of the stack */
	st	%r0,  %r0,  %r27
	br.n	1b
	 addu	%r27, %r27, 4	/* bump up */
2:	/* stack has been cleared */
#endif

	/* ensure that stack is 8-byte aligned */
	clr	%r31, %r31, 3<0>	/* round down to 8-byte boundary */

	/* create exception frame on stack */
	subu	%r31, %r31, TRAPFRAME_SIZEOF	/* r31 now our E.F. */

	/* save old R31 and other R registers */
	st.d	%r0 , %r31, GENREG_OFF(0)
	st.d	%r2 , %r31, GENREG_OFF(2)
	st.d	%r4 , %r31, GENREG_OFF(4)
	st.d	%r6 , %r31, GENREG_OFF(6)
	st.d	%r8 , %r31, GENREG_OFF(8)
	st.d	%r10, %r31, GENREG_OFF(10)
	st.d	%r12, %r31, GENREG_OFF(12)
	st.d	%r14, %r31, GENREG_OFF(14)
	st.d	%r16, %r31, GENREG_OFF(16)
	st.d	%r18, %r31, GENREG_OFF(18)
	st.d	%r20, %r31, GENREG_OFF(20)
	st.d	%r22, %r31, GENREG_OFF(22)
	st.d	%r24, %r31, GENREG_OFF(24)
	st	%r30, %r31, GENREG_OFF(30)
	st	%r26, %r31, GENREG_OFF(31)

	/* save shadow registers (are OLD if error_handler, though) */
	ldcr	%r10, EPSR
	st	%r10, %r31, EF_EPSR
	ldcr	%r10, SXIP
	st	%r10, %r31, EF_SXIP
	ldcr	%r10, SNIP
	st	%r10, %r31, EF_SNIP
	ldcr	%r10, SR1
	st	%r10, %r31, EF_FLAGS
	ldcr	%r10, SFIP
	st	%r10, %r31, EF_SFIP
	ldcr	%r10, SSBR
	st	%r10, %r31, EF_SSBR
	stcr	%r0,  SSBR	/* won't want shadow bits bothering us later */

	ldcr	%r10, DMT0
	st	%r10, %r31, EF_DMT0
	ldcr	%r11, DMD0
	st	%r11, %r31, EF_DMD0
	ldcr	%r12, DMA0

	st	%r12, %r31, EF_DMA0
	ldcr	%r10, DMT1
	st	%r10, %r31, EF_DMT1
	FLUSH_PIPELINE
	ldcr	%r11, DMD1
	st 	%r11, %r31, EF_DMD1
	ldcr	%r12, DMA1
	st	%r12, %r31, EF_DMA1

	ldcr	%r10, DMT2
	st	%r10, %r31, EF_DMT2
	ldcr	%r11, DMD2
	st	%r11, %r31, EF_DMD2
	ldcr	%r12, DMA2
	st	%r12, %r31, EF_DMA2

	/* shove sr2 into EF_FPLS1 */
	ldcr	%r10, SR2
	st	%r10, %r31, EF_FPLS1

	/* shove sr3 into EF_FPHS2 */
	ldcr	%r10, SR3
	st	%r10, %r31, EF_FPHS2

	/* save error vector */
	st	%r29, %r31, EF_VECTOR

	/*
	 * Cheap way to enable FPU and start shadowing again.
	 */
	ldcr	%r10, PSR
	clr	%r10, %r10, 1<PSR_FPU_DISABLE_BIT>	/* enable the FPU */
	clr	%r10, %r10, 1<PSR_SHADOW_FREEZE_BIT>	/* and shadowing */
	stcr	%r10, PSR
	FLUSH_PIPELINE

	/* put pointer to regs into r30... r31 will become a simple stack */
	or	%r30, %r31, %r0

	subu	%r31, %r31, 0x10	/* make some breathing space */
	st	%r30, %r31, 0x0c	/* store frame pointer on the stack */
#ifdef DDB
	st	%r30, %r31, 0x08	/* store again for the debugger to recognize */
	or.u	%r20, %r0,  %hi16(0x87654321)
	or	%r20, %r20, %lo16(0x87654321)
	st	%r20, %r31, 0x04
	st	%r20, %r31, 0x00
#endif

	bsr.n	_C_LABEL(error_fatal)
	 or	%r2, %r0, %r30

	/* turn interrupts back on */
	ldcr	%r1, PSR
	clr	%r1, %r1, 1<PSR_INTERRUPT_DISABLE_BIT>
	stcr	%r1, PSR
	FLUSH_PIPELINE

1:
	br	1b
	/* NOTREACHED */
#endif	/* M88100 */

/*
 * This is part of baddadr (below).
 */
#ifdef M88100
ASLOCAL(m88100_ignore_data_exception)
	/*
	 * SR1: previous FLAGS reg
	 * SR2: free
	 * SR3: must preserve
	 * FLAGS: CPU status flags
	 */
	xcr	FLAGS, FLAGS, SR1	/* replace SR1, FLAGS */

	/*
	 * For more info, see badaddr() below.
	 *
	 * We just want to jump to "badaddr__return_nonzero" below.
	 *
	 * We don't worry about trashing r2 here because we're
	 * jumping back to the function badaddr() where we're allowed
	 * to blast r2..r9 as we see fit.
	 */

	/* the "+2" below is to set the VALID bit. */
	or.u	%r2, %r0, %hi16(_ASM_LABEL(badaddr__return_nonzero) + 2)
	or	%r2, %r2, %lo16(_ASM_LABEL(badaddr__return_nonzero) + 2)
	stcr	%r2, SNIP	/* Make it the next instruction to execute */
	addu	%r2, %r2, 4
	stcr	%r2, SFIP	/* and the next one after that, too. */
	stcr	%r0, SSBR	/* make the scoreboard happy. */
	RTE
#endif /* M88100 */

#ifdef M88110
/*
 * This is part of baddadr (below).
 */
ASLOCAL(m88110_ignore_data_exception)
	/*
	 * SR1: previous FLAGS reg
	 * SR2: free
	 * SR3: must preserve
	 * FLAGS: CPU status flags
	 */
	xcr	FLAGS, FLAGS, SR1	/* replace SR1, FLAGS */

	/*
	 * For more info, see badaddr() below.
	 *
	 * We just want to jump to "badaddr__return_nonzero" below.
	 *
	 * We don't worry about trashing R2 here because we're
	 * jumping back to the function badaddr() where we're allowed
	 * to blast r2..r9 as we see fit.
	 */

	or.u	%r2, %r0, %hi16(_ASM_LABEL(badaddr__return_nonzero))
	or	%r2, %r2, %lo16(_ASM_LABEL(badaddr__return_nonzero))
	stcr	%r2, EXIP	/* Make it the next instruction to execute */
	stcr	%r0, DSR	/* Clear exception status */
	RTE
#endif /* M88110 */

/*
 * extern int badaddr(vaddr_t addr, int len)
 *
 * Returns true (non-zero) if the given LEN bytes starting at ADDR are
 * not all currently accessible by the kernel.
 *
 * If all LEN bytes starting at ADDR are accessible, zero is returned.
 *
 * Len may be be 1, 2, 4 or 8.
 *
 * This is implemented by setting a special flag in SR1 before trying to access
 * the given address. If a data access exception is raised, the address
 * is inaccessible. The exception handler will notice the special CPU flag
 * and not try to swap the address in. Rather, it will return to
 * "badaddr__return_nonzero" in this routine so that we may return non-zero
 * to the calling routine.
 *
 * If no fault is raised, we continue to where we return zero to the calling
 * routine (after removing the special CPU flag).
 */

GLOBAL(badaddr)
	/*
	 * Disable interrupts ... don't want a context switch while we're
	 * doing this! Also, save the old PSR in R8 to restore later.
	 */
	ldcr	%r8, PSR
	set	%r4, %r8, 1<PSR_INTERRUPT_DISABLE_BIT>
	stcr	%r4, PSR
	FLUSH_PIPELINE

	ldcr	%r5, SR1
	set	%r5, %r5, 1<FLAG_IGNORE_DATA_EXCEPTION>
	/* resetting r5 to SR1 done in the delay slot below. */

	/* make sure the upper 28 bits of the size are zero... */
	ext	%r6, %r3, 0<4>
	bcnd.n	ne0, %r6, _ASM_LABEL(badaddr__return_nonzero)
	 stcr	%r5, SR1

	or.u	%r6, %r0, %hi16(_ASM_LABEL(badaddr_switch))
	or	%r6, %r6, %lo16(_ASM_LABEL(badaddr_switch))
	lda	%r3, %r6[%r3]
	jmp	%r3

ASLOCAL(badaddr_switch)
	br	_ASM_LABEL(badaddr__return_nonzero)
	br	_ASM_LABEL(badaddr__b)
	br	_ASM_LABEL(badaddr__h)
	br	_ASM_LABEL(badaddr__return_nonzero)
	br	_ASM_LABEL(badaddr__w)
	br	_ASM_LABEL(badaddr__return_nonzero)
	br	_ASM_LABEL(badaddr__return_nonzero)
	br	_ASM_LABEL(badaddr__return_nonzero)
	br	_ASM_LABEL(badaddr__d)
	br	_ASM_LABEL(badaddr__return_nonzero)
	br	_ASM_LABEL(badaddr__return_nonzero)
	br	_ASM_LABEL(badaddr__return_nonzero)
	br	_ASM_LABEL(badaddr__return_nonzero)
	br	_ASM_LABEL(badaddr__return_nonzero)
	br	_ASM_LABEL(badaddr__return_nonzero)
	br	_ASM_LABEL(badaddr__return_nonzero)

	/*
	 * The load attemps below will either fault or not. If they fault,
	 * execution will go to data_access_handler, then to
	 * ignore_data_exception, then to badaddr__return_nonzero, which
	 * will return to the calling function.
	 * If there is no fault, execution will just continue as normal.
	 */

ASLOCAL(badaddr__b)
	FLUSH_PIPELINE
	ld.b	%r6, %r2, 0
	FLUSH_PIPELINE
	br.n	_ASM_LABEL(badaddr__return)
	 or	%r2, %r0, %r0

ASLOCAL(badaddr__h)
	/* It's a bad address if it's misaligned. */
	bb1	0, %r2, _ASM_LABEL(badaddr__return_nonzero)

	FLUSH_PIPELINE
	ld.h	%r6, %r2, 0
	FLUSH_PIPELINE
	br.n	_ASM_LABEL(badaddr__return)
	 or	%r2, %r0, %r0

ASLOCAL(badaddr__w)
	/* It's a bad address if it's misaligned. */
	bb1	0, %r2, _ASM_LABEL(badaddr__return_nonzero)
	bb1	1, %r2, _ASM_LABEL(badaddr__return_nonzero)

	FLUSH_PIPELINE
	ld	%r6, %r2, 0
	FLUSH_PIPELINE
	br.n	_ASM_LABEL(badaddr__return)
	 or	%r2, %r0, %r0	/* indicate a zero (address not bad) return.*/

ASLOCAL(badaddr__d)
	/* It's a bad address if it's misaligned. */
	bb1	0, %r2, _ASM_LABEL(badaddr__return_nonzero)
	bb1	1, %r2, _ASM_LABEL(badaddr__return_nonzero)
	bb1	2, %r2, _ASM_LABEL(badaddr__return_nonzero)

	FLUSH_PIPELINE
	ld.d	%r6, %r2, 0
	FLUSH_PIPELINE
	br.n	_ASM_LABEL(badaddr__return)
	 or	%r2, %r0, %r0	/* indicate a zero (address not bad) return.*/

ASLOCAL(badaddr__return_nonzero)
	or	%r2, %r0, 1
	/* FALLTHROUGH */

ASLOCAL(badaddr__return)
	ldcr	%r4, SR1
	clr	%r4, %r4, 1<FLAG_IGNORE_DATA_EXCEPTION>
	stcr	%r4, SR1

	/*
	 * Restore the PSR to what it was before.
	 * The only difference is that we might be enabling interrupts
	 * (which we turned off above).  If interrupts were already off,
	 * we do not want to turn them on now, so we just restore from
	 * where we saved it.
	 */
	stcr	%r8, PSR
	FLUSH_PIPELINE
	jmp	%r1

#ifdef M88100
ASLOCAL(m88100_setup_phase_one)
	/*
	 * SR1: saved copy of exception-time register now holding FLAGS
	 * SR2: saved copy of exception-time r1
	 * SR3: must be preserved .. may be the exception-time stack
	 * r1: return address to calling exception handler
	 * FLAGS: CPU status flags
	 *
	 * immediate goal:
	 *   Decide where we're going to put the exception frame.
	 *   Might be at the end of R31, SR3, or the process pcb.
	 */

	/* Check if we are coming in from a FPU restart exception.
	   If so, the pcb will be in SR3 */
	NOP
	xcr	%r1, %r1, SR2
	NOP
	NOP
	NOP

	bb1	FLAG_ENABLING_FPU, FLAGS, _ASM_LABEL(m88100_use_SR3_pcb)
	/* are we coming in from user mode? If so, pick up process pcb */
	bb0	FLAG_FROM_KERNEL, FLAGS, _ASM_LABEL(m88100_pickup_stack)

	/* Interrupt in kernel mode, not FPU restart */
	/*
	 * SR1: saved copy of exception-time register now holding FLAGS
	 * SR2: return address to the calling exception handler
	 * SR3: must be preserved; may be important for other exceptions
	 * FLAGS: CPU status flags
	 *
	 * immediate goal:
	 *   We're already on the kernel stack, but not having
	 *   needed to use SR3. We can just make room on the
	 *   stack (r31) for our exception frame.
	 */
	subu	%r31, %r31, TRAPFRAME_SIZEOF	/* r31 now our E.F. */
	st	FLAGS,%r31, EF_FLAGS		/* save flags */
	st	%r1,  %r31, GENREG_OFF(1)	/* save prev. r1 (now free)*/

	ldcr	%r1,  SR3			/* save previous SR3 */
	st	%r1,  %r31, EF_SR3

	addu	%r1,  %r31, TRAPFRAME_SIZEOF	/* save previous r31 */
	br.n	_ASM_LABEL(m88100_have_pcb)
	 st 	%r1,  %r31, GENREG_OFF(31)

ASLOCAL(m88100_use_SR3_pcb)
	/*
	 * SR1: saved copy of exception-time register now holding FLAGS
	 * SR2: return address to the calling exception handler
	 * SR3: must be preserved; exception-time stack pointer
	 * FLAGS: CPU status flags
	 *
	 * immediate goal:
	 *   An exception occurred while enabling the FPU. Since r31
	 *   is the user's r31 while enabling the FPU, we had put
	 *   our pcb pointer into SR3, so make room from
	 *   there for our stack pointer.
	 *   We need to check if SR3 is the old stack pointer or the
	 *   pointer off to the user pcb. If it pointing to the user
	 *   pcb, we need to pick up the kernel stack. Otherwise
	 *   we need to allocate a frame upon it.
	 *   We look at the EPSR to see if it was from user mode
	 *   Unfortunately, we have no registers free at the moment
	 *   But we know register 0 in the pcb frame will always be
	 *   zero, so we can use it as scratch storage.
	 */
	xcr	%r30, %r30, SR3			/* r30 = old exception frame */
	st	%r1,  %r30, GENREG_OFF(0)	/* free up r1 */
	ld	%r1,  %r30, EF_EPSR		/* get back the epsr */
	bb0.n	PSR_SUPERVISOR_MODE_BIT, %r1, 1f/* if user mode */
	 ld	%r1,  %r30, GENREG_OFF(0)	/* restore r1 */
	/* we were in kernel mode - dump frame upon the stack */
	st	%r0,  %r30, GENREG_OFF(0)	/* repair old frame */
	subu	%r30, %r30, TRAPFRAME_SIZEOF	/* r30 now our E.F. */
	st	FLAGS,%r30, EF_FLAGS		/* save flags */
	st	%r1,  %r30, GENREG_OFF(1)	/* save prev r1 (now free) */

	st	%r31, %r30, GENREG_OFF(31)	/* save previous r31 */
	or	%r31, %r0,  %r30		/* make r31 our pointer. */
	addu	%r30, %r30, TRAPFRAME_SIZEOF	/* r30 now has previous SR3 */
	st	%r30, %r31, EF_SR3		/* save previous SR3 */
	br.n	_ASM_LABEL(m88100_have_pcb)
	 xcr	%r30, %r30, SR3			/* restore r30 */
1:
	/* we took an exception while restarting the FPU from user space.
	 * Consequently, we never picked up a stack. Do so now.
	 * R1 is currently free (saved in the exception frame pointed at by
	 * r30) */
	ldcr	%r1,  CPU
	ld	%r1,  %r1,  CI_CURPCB
	addu	%r1,  %r1,  USPACE - TRAPFRAME_SIZEOF
	st	FLAGS,%r1,  EF_FLAGS		/* store flags */
	st	%r31, %r1,  GENREG_OFF(31)	/* store r31 - now free */
	st	%r30, %r1,  EF_SR3		/* store old SR3 (pcb) */
	or	%r31, %r1,  %r0			/* make r31 our exception fp */
	ld	%r1,  %r30, GENREG_OFF(0)	/* restore old r1 */
	st	%r0,  %r30, GENREG_OFF(0)	/* repair that frame */
	st	%r1,  %r31, GENREG_OFF(1)	/* store r1 */
	br.n	_ASM_LABEL(m88100_have_pcb)
	 xcr	%r30, %r30, SR3			/* restore r30 */

ASLOCAL(m88100_pickup_stack)
	/*
	 * SR1: saved copy of exception-time register now holding FLAGS
	 * SR2: return address to the calling exception handler
	 * SR3: free
	 * FLAGS: CPU status flags
	 *
	 * immediate goal:
	 *   Since we're servicing an exception from user mode, we
	 *   know that SR3 is free.  We use it to free up a temp.
	 *   register to be used in getting the process pcb
	 */
	stcr	%r31, SR3	/* save previous r31 */

	/* switch to the process kernel stack. */
	ldcr	%r31, CPU
	ld	%r31, %r31, CI_CURPCB
	addu	%r31, %r31, PCB_USER_STATE	/* point to user save area */

	/*
	 * WARNING! Using pcb->user_state as the exception frame
	 * AND stack pointer, means we can not afford using the stack
	 * until we have saved enough and can go back to the top of the u area,
	 * after the FPU is enabled.
	 */

	st	FLAGS,%r31, EF_FLAGS		/* save flags */
	st	%r1,  %r31, GENREG_OFF(1)	/* save prev. r1 (now free) */
	ldcr	%r1,  SR3			/* save previous r31 */
	st	%r1,  %r31, GENREG_OFF(31)
	/* FALLTHROUGH */

ASLOCAL(m88100_have_pcb)
	/*
	 * SR1: saved copy of exception-time register now holding FLAGS
	 * SR2: return address to the calling exception handler
	 * SR3: free
	 * r1:  free
	 * FLAGS: CPU status flags
	 * r31: our exception frame
	 * Valid in the exception frame:
	 *   Exception-time r1, r31, FLAGS.
	 *   Exception SR3, if appropriate.
	 *
	 * immediate goal:
	 *   Save the shadow registers that need to be saved to
	 *   the exception frame.
	 */
	stcr	TMP, SR3	/* free up TMP, TMP2, TMP3 */
	SAVE_TMP2(%r31)
	SAVE_TMP3(%r31)

	/* save some exception-time registers to the exception frame */
	ldcr	TMP,  EPSR
	st	TMP,  %r31, EF_EPSR
	ldcr	TMP3, SNIP
	st	TMP3, %r31, EF_SNIP
	ldcr	TMP2, SFIP
	st	TMP2, %r31, EF_SFIP
	/* get and store the cpu_info pointer */
	ldcr	TMP,  CPU
	st	TMP,  %r31, EF_CPU

	/*
	 * Save Pbus fault status register from data and inst CMMU.
	 * We can afford calling a function since r1 is safe to use here.
	 */
GLOBAL(pfsr_save)
	PFSR_SAVE
ASLOCAL(pfsr_done)
	
	ldcr	TMP,  SSBR
	ldcr	TMP2, SXIP
	ldcr	TMP3, DMT0
	st	TMP2, %r31, EF_SXIP

/*
 * The above shadow registers are obligatory for any and all
 * exceptions.  Now, if the data access pipeline is not clear,
 * we must save the DMx shadow registers, as well as clear
 * the appropriate SSBR bits for the destination registers of
 * loads or xmems.
 */
	bb0.n	DMT_VALID_BIT, TMP3, 8f
	 st	TMP3, %r31, EF_DMT0

	ldcr	TMP2, DMT1
	ldcr	TMP3, DMT2
	st	TMP2, %r31, EF_DMT1
	st	TMP3, %r31, EF_DMT2

	ldcr	TMP2, DMA0
	ldcr	TMP3, DMA1
	st	TMP2, %r31, EF_DMA0
	st	TMP3, %r31, EF_DMA1

	ldcr	TMP2, DMA2
	ldcr	TMP3, DMD0
	st	TMP2, %r31, EF_DMA2
	st	TMP3, %r31, EF_DMD0

	FLUSH_PIPELINE
	ldcr	TMP2, DMD1
	ldcr	TMP3, DMD2
	st	TMP2, %r31, EF_DMD1
	st	TMP3, %r31, EF_DMD2

	/* make sure an exception in fpu_enable will not see our DMT0 */
	stcr	%r0,   DMT0

	/*
 	 * need to clear "appropriate" bits in the SSBR before
 	 * we restart the FPU
 	 */
	ld	TMP2, %r31, EF_DMT0
	bb1	DMT_LOCK_BIT,  TMP2, 1f
	bb1	DMT_WRITE_BIT, TMP2, 2f
1:
	extu	TMP2, TMP2, DMT_DREG_WIDTH <DMT_DREG_OFFSET>
	set	TMP2, TMP2, 1<5>
	clr	TMP,  TMP,  TMP2
2:
	ldcr	TMP2, DMT1
	bb0	DMT_VALID_BIT, TMP2, 4f
	bb1	DMT_LOCK_BIT,  TMP2, 3f
	bb1	DMT_WRITE_BIT, TMP2, 4f
3:
	extu	TMP2, TMP2, DMT_DREG_WIDTH <DMT_DREG_OFFSET>
	set	TMP2, TMP2, 1<5>
	clr	TMP,  TMP,  TMP2
4:
	ldcr	TMP2, DMT2
	bb0	DMT_VALID_BIT, TMP2, 8f
	bb1	DMT_LOCK_BIT,  TMP2, 5f
	bb1	DMT_WRITE_BIT, TMP2, 8f
	bb1	DMT_DOUBLE_BIT,TMP2, 6f
5:
	extu	TMP2, TMP2, DMT_DREG_WIDTH <DMT_DREG_OFFSET>
	br.n	7f
	 set	TMP2, TMP2, 1<5>	/* single */
6:
	extu	TMP2, TMP2, DMT_DREG_WIDTH <DMT_DREG_OFFSET>
	set	TMP2, TMP2, 1<6>	/* double */
7:
	clr	TMP,  TMP,  TMP2
8:
	/*
	 * SR1: saved copy of exception-time register now holding FLAGS
	 * SR2: return address to the calling exception handler
	 * SR3: saved TMP
	 * r1:  free
	 * TMP: possibly revised SSBR
	 * TMP2: free
	 * TMP3: free
	 * FLAGS: CPU status flags
	 * r31: exception frame
	 * Valid in the exception frame:
	 *   Exception-time r1, r31, FLAGS.
	 *   Exception-time TMP2, TMP3.
	 *   Exception-time epsr, sfip, snip, sxip.
	 *   Dmt0.
	 *   Other data pipeline control registers, if appropriate.
	 *   Exception SR3, if appropriate.
	 */
	ldcr	%r1,  SR2
	jmp	%r1	/* allow the handler to clear more SSBR bits */

ASLOCAL(clear_FPi_ssbr_bit)
	/*
	 * Clear floating point imprecise ssbr bits.
	 * Also, save appropriate FPU control registers to the E.F.
	 *
	 * r1:  return address to calling exception handler
	 * TMP: (possibly) revised ssbr
	 * TMP2: free
	 * TMP3: free
	 */
	fldcr	TMP2, FPSR
	fldcr	TMP3, FPCR
	st	TMP2, %r31, EF_FPSR
	st	TMP3, %r31, EF_FPCR

	fldcr	TMP2, FPECR
	fldcr	TMP3, FPRH
	st	TMP2, %r31, EF_FPECR
	st	TMP3, %r31, EF_FPRH

	fldcr 	TMP2, FPIT
	fldcr	TMP3, FPRL
	st	TMP2, %r31, EF_FPIT
	st	TMP3, %r31, EF_FPRL

	/*
	 * We only need clear the bit in the SSBR for the
	 * 2nd reg of a double result [see section 6.8.5]
	 */
#define FPIT_SIZE_BIT   10
	bb0	FPIT_SIZE_BIT, TMP2, 1f
	extu	TMP2, TMP2, 5<0>	/* get the reg. */
	set	TMP2, TMP2, 1<6>	/* set width */
	clr	TMP,  TMP,  TMP2
1:
	jmp	%r1


ASLOCAL(clear_FPp_ssbr_bit)
	/*
	 * Clear floating point precise ssbr bits.
	 * Also, save appropriate FPU control registers to the E.F.
	 *
	 * r1:  return address to calling exception handler
	 * TMP: (possibly) revised ssbr
	 * TMP2: free
	 * TMP3: free
	 */
	fldcr	TMP2, FPSR
	fldcr	TMP3, FPCR
	st	TMP2, %r31, EF_FPSR
	st	TMP3, %r31, EF_FPCR

	fldcr	TMP3, FPECR
	st	TMP3, %r31, EF_FPECR
	fldcr	TMP2, FPHS1
	fldcr	TMP3, FPHS2
	st	TMP2, %r31, EF_FPHS1
	st	TMP3, %r31, EF_FPHS2

	fldcr	TMP2, FPLS1
	fldcr	TMP3, FPLS2
	st	TMP2, %r31, EF_FPLS1
	st	TMP3, %r31, EF_FPLS2

	fldcr	TMP2, FPPT
	st	TMP2, %r31, EF_FPPT

#define FPPT_SIZE_BIT   5
	bb1.n	FPPT_SIZE_BIT, TMP2, 2f
	 extu	TMP3, TMP2, 5<0>	/* get FP operation dest reg */
	br.n	3f
	 set	TMP3, TMP3, 1<5>	/* size=1 - clear one bit for float */
2:
	set	TMP3, TMP3, 1<6>	/* size=2 - clear two bits for double */
3:
	jmp.n	%r1
	 clr	TMP,  TMP,  TMP3	/* clear bit(s) in ssbr. */


ASLOCAL(clear_dest_ssbr_bit)
	/*
	 * There are various cases where an exception can leave the
	 * destination register's bit in the SB set.
	 * Examples:
	 *   misaligned or privilege exception on a LD or XMEM
	 *   DIV or DIVU by zero.
	 *
	 * I think that if the instruction is LD.D, then two bits must
	 * be cleared.
	 *
	 * Even though there are a number of instructions/exception
	 * combinations that could fire this code up, it's only required
	 * to be run for the above cases.  However, I don't think it'll
	 * ever be a problem to run this in other cases (ST instructions,
	 * for example), so I don't bother checking.  If we had to check
	 * for every possible instruction, this code would be much larger.
	 *
	 * The only checking, then, is to see if it's a LD.D or not.
	 *
	 * At the moment....
	 *  r1:  return address to calling exception handler
	 *  TMP: (possibly) revised ssbr
	 *  TMP2: free
	 *  TMP3: free
	 */

	ldcr	TMP3, EPSR	/* going to check: user or system memory? */
	ldcr	TMP2, SXIP	/* get the instruction's address */
	bb1.n	PSR_SUPERVISOR_MODE_BIT, TMP3, 2f
	 clr	TMP2, TMP2, 2<0>	/* get rid of valid and error bits. */

	/* user space load here */
#if ERRATA__XXX_USR
	NOP
	ld.usr	TMP2, TMP2, %r0	/* get the instruction itself */
	NOP
	NOP
	NOP
	br    3f
#else
	br.n  3f
	 ld.usr	TMP2, TMP2, %r0	/* get the instruction itself */
#endif

2:	/* system space load here */
	ld	TMP2, TMP2, %r0	/* get the instruction itself */

3:	/* now we have the instruction..... */
	/*
	 * Now see if it's a double load
	 * There are three forms of double load [IMM16, scaled, unscaled],
	 * which can be checked by matching against two templates:
	 *          -- 77776666555544443333222211110000 --
	 *   if (((instruction & 11111100000000000000000000000000) ==
	 *             00010000000000000000000000000000) ;;
	 *       ((instruction & 11111100000000001111110011100000) ==
	 *             11110100000000000001000000000000))
	 *   {
	 *      It's a load double, so
	 *      clear two SSBR bits.
	 *   } else {
	 *      It's not a load double.
	 *      Must be a load single, xmem, or st
	 *      Thus, clear one SSBR bit.
	 *   }
	 */
	/* check the first pattern for ld.d */
	extu	TMP3, TMP2, 16<16>	/* get the upper 16 bits */
	mask	TMP3, TMP3, 0xfc00	/* apply the mask */
	cmp	TMP3, TMP3, 0x1000	/* if equal, it's a load double */
	bb1	eq,   TMP3, 2f

	/* still could be -- check the second pattern for ld.d */
	/* look at the upper 16 bits first */
	extu	TMP3, TMP2, 16<16>	/* get the upper 16 bits */
	mask	TMP3, TMP3, 0xfc00	/* apply the mask */
	cmp	TMP3, TMP3, 0xf400	/* if equal, might be a load double */
	bb1	ne,   TMP3, 1f		/* not equal, must be single */

	/* now look at the lower 16 bits */
	extu	TMP3, TMP2, 16<0>	/* get the lower 16 bits */
	mask	TMP3, TMP3, 0xfce0	/* apply the mask */
	cmp	TMP3, TMP3, 0x1000	/* if equal, it's a load double */
	bb1	eq,   TMP3, 2f

1:	/* misaligned single */
	extu	TMP2, TMP2, 5<21>	/* get the destination register */
	br.n	3f
	 set	TMP2, TMP2, 1<5>	/* set size=1 */

2:	/* misaligned double */
	extu	TMP2, TMP2, 5<21>	/* get the destination register */
	set	TMP2, TMP2, 1<6>	/* set size=2 -- clear two bits */
3:
	jmp.n	%r1
	 clr	TMP,  TMP,  TMP2	/* clear bit(s) in ssbr. */

ASLOCAL(m88100_setup_phase_two)
	/*
	 * SR1: saved copy of exception-time register now holding FLAGS
	 * SR2: free
	 * SR3: saved TMP
	 * r1:  return address to calling exception handler
	 * TMP: possibly revised SSBR
	 * TMP2: free
	 * TMP3: free
	 * FLAGS: CPU status flags
	 * r31: our exception frame
	 *    Valid in the exception frame:
	 *   Exception-time r1, r31, FLAGS.
	 *   Exception-time TMP2, TMP3.
	 *   Exception-time epsr, sfip, snip, sxip.
	 *   Exception number (EF_VECTOR).
	 *   Dmt0
	 *   Other data pipeline control registers, if appropriate.
	 *   FPU control registers, if appropriate.
	 *   Exception SR3, if appropriate.
	 *
	 * immediate goal:
	 *   restore the system to the exception-time state (except
	 *   SR3 will be OUR stack pointer) so that we may restart the FPU.
	 */

	stcr	TMP,  SSBR	/* done with SSBR, TMP now free */
	RESTORE_TMP2(%r31)	/* done with extra temp regs */
	RESTORE_TMP3(%r31)	/* done with extra temp regs */

	/* Get the current PSR and modify for the rte to enable the FPU */
	ldcr	TMP,  PSR
	clr	TMP,  TMP, 1<PSR_FPU_DISABLE_BIT>	/* enable the FPU */
	clr	TMP,  TMP, 1<PSR_SHADOW_FREEZE_BIT>	/* and shadowing */
	stcr	TMP,  EPSR

	/* the "+2" below is to set the VALID_BIT */
	or.u	TMP,  %r0, %hi16(_ASM_LABEL(m88100_fpu_enable) + 2)
	or	TMP,  TMP, %lo16(_ASM_LABEL(m88100_fpu_enable) + 2)
	stcr	TMP,  SNIP
	addu	TMP,  TMP, 4
	stcr	TMP,  SFIP

	set	FLAGS, FLAGS, 1<FLAG_ENABLING_FPU>
	xcr	FLAGS, FLAGS, SR1
	st	%r1,   %r31,  EF_RET		/* save the return address */
	ld	%r1,   %r31,  GENREG_OFF(1)	/* get original r1 */

	xcr	TMP,   %r31,  SR3	/* TMP now restored. R31 now saved in SR3 */
	ld	%r31,  %r31,  GENREG_OFF(31)	/* get original r31 */

	/*
	 * SR1: CPU flags
	 * SR2: free
	 * SR3: pointer to our exception frame (our stack pointer)
	 * r1 through r31: original exception-time values
	 *
	 * Valid in the exception frame:
	 *   Exception-time FLAGS.
	 *   Exception-time epsr, sfip, snip, sxip.
	 *   Exception number (EF_VECTOR).
	 *   Dmt0
	 *   Other data pipeline control registers, if appropriate.
	 *   FPU control registers, if appropriate.
	 *   Exception SR3, if appropriate.
	 *   Held temporarly in the exception frame:
	 *   Return address to the calling exception handler.
	 *
	 * immediate goal:
	 *   Do an RTE to restart the fpu and jump to "fpu_enable"
	 *   Another exception (or exceptions) may be raised in
	 *   this, which is why FLAG_ENABLING_FPU is set in SR1.
	 */

	RTE	/* jumps to "m88100_fpu_enable" to enable the FPU. */

ASLOCAL(m88100_fpu_enable)
	FLUSH_PIPELINE
	xcr	TMP,  TMP,  SR3			/* get E.F. pointer */
	st	%r30, TMP,  GENREG_OFF(30)	/* save previous r30, r31 */
	st	%r31, TMP,  GENREG_OFF(31)	/* save previous r30, r31 */
	or	%r31, TMP,  %r0			/* transfer E.F. pointer to r31 */
	ld	TMP,  %r31, EF_SR3		/* get previous SR3 */

	/* make sure that the FLAG_ENABLING_FPU bit is off */
	xcr	FLAGS,FLAGS,SR1
	clr	FLAGS,FLAGS,1<FLAG_ENABLING_FPU>
	xcr	FLAGS,FLAGS,SR1

	xcr	TMP,  TMP,  SR3	/* replace TMP, SR3 */

	/* now save all regs to the exception frame. */
	st	%r0,  %r31, GENREG_OFF(0)
	st	%r1,  %r31, GENREG_OFF(1)
	st	%r2,  %r31, GENREG_OFF(2)
	st	%r3,  %r31, GENREG_OFF(3)
	st	%r4,  %r31, GENREG_OFF(4)
	st	%r5,  %r31, GENREG_OFF(5)
	st	%r6,  %r31, GENREG_OFF(6)
	st	%r7,  %r31, GENREG_OFF(7)
	st	%r8,  %r31, GENREG_OFF(8)
	st	%r9,  %r31, GENREG_OFF(9)
	st	%r10, %r31, GENREG_OFF(10)
	st	%r11, %r31, GENREG_OFF(11)
	st	%r12, %r31, GENREG_OFF(12)
	st	%r13, %r31, GENREG_OFF(13)
	st	%r14, %r31, GENREG_OFF(14)
	st	%r15, %r31, GENREG_OFF(15)
	st	%r16, %r31, GENREG_OFF(16)
	st	%r17, %r31, GENREG_OFF(17)
	st	%r18, %r31, GENREG_OFF(18)
	st	%r19, %r31, GENREG_OFF(19)
	st	%r20, %r31, GENREG_OFF(20)
	st	%r21, %r31, GENREG_OFF(21)
	st	%r22, %r31, GENREG_OFF(22)
	st	%r23, %r31, GENREG_OFF(23)
	st	%r24, %r31, GENREG_OFF(24)
	st	%r25, %r31, GENREG_OFF(25)
	st	%r26, %r31, GENREG_OFF(26)
	st	%r27, %r31, GENREG_OFF(27)
	st	%r28, %r31, GENREG_OFF(28)
	st	%r29, %r31, GENREG_OFF(29)

	/*
	 * SR1: free
	 * SR2: free
	 * SR3: previous exception-time SR3
	 * r1: return address to the calling exception handler
	 * r2 through r30: free
	 * r31: our exception frame
	 *
	 * Valid in the exception frame:
	 *   Exception-time r0 through r31.
	 *   Exception-time FLAGS.
	 *   Exception-time epsr, sfip, snip, sxip.
	 *   Exception number (EF_VECTOR).
	 *   Dmt0
	 *   Other data pipeline control registers, if appropriate.
	 *   FPU control registers, if appropriate.
	 *   Exception SR3, if appropriate.
	 *
	 * immediate goal:
	 *   Pick up a stack if we came in from user mode.
	 *   Put a copy of the exception frame pointer into r30
	 *   Bump the stack a doubleword and write the exception frame pointer.
	 *   If not an interrupt exception, turn on interrupts and service any
	 *     outstanding data access exceptions.
	 *   Return to calling exception handler to service the exception.
	 */

	/*
	 * If it's not the interrupt exception, enable interrupts and
	 * take care of any data access exceptions......
	 */
	or	%r30, %r0,  %r31	/* get a copy of the e.f. pointer */
	ld	%r6,  %r31, EF_EPSR
	bb1	PSR_SUPERVISOR_MODE_BIT, %r6, 1f	/* if in kernel mode */

	ldcr	%r31, CPU
	ld	%r31, %r31, CI_CURPCB
	addu	%r31, %r31, USPACE	/* point at proper end */
1:

	/* get and save IPL */
	bsr	_C_LABEL(getipl)
	st	%r2, %r30, EF_MASK

	/*
	 * here - r30 holds a pointer to the exception frame.
	 * r31 is a pointer to the kernel stack/interrupt stack.
	 */
	subu	%r31, %r31, 8	/* make some breathing space */
	st	%r30, %r31, 0	/* store frame pointer on the stack */
#ifdef DDB
	st	%r30, %r31, 4	/* store it for the debugger to recognize */
#endif

	ld	%r6,  %r30, EF_EPSR
	ld	%r2,  %r30, EF_VECTOR
	bcnd.n	eq0,  %r2,  8f			/* error exception */
	 ld	%r14, %r30, EF_RET

	/*
	 * Do not process possible data exceptions here if this is an interrupt.
	 * Instead, the interrupt handler will take care of this by itself.
	 */
	cmp	%r3,  %r2,  1			/* is an interrupt? */
	bb1.n	eq,   %r3,  8f			/* skip if so */

#ifdef DDB
	 cmp	%r3,  %r2,  130			/* DDB break exception */
	bb1.n	eq,   %r3,  8f
	 cmp	%r3,  %r2,  132			/* DDB entry exception */
	bb1	eq,   %r3,  8f
#else
	 NOP
#endif

	/* turn interrupts back on unless they were not enabled when the
	   trap occured */
	bb1.n	PSR_INTERRUPT_DISABLE_BIT, %r6, 7f
	 ld	%r3,  %r30, EF_DMT0

	ldcr	%r2,  PSR
	clr	%r2,  %r2,  1<PSR_INTERRUPT_DISABLE_BIT>
	stcr	%r2,  PSR
	FLUSH_PIPELINE
7:
	/* service any outstanding data pipeline stuff */
	bb0	DMT_VALID_BIT, %r3, 8f

	/*
	 * r30 can be clobbered by calls. So stuff its value into a preserved
	 * register, say r15. R14 is in use (see return_to_... below).
	 */
	or	%r15, %r0,  %r30
	CALL(m88100_trap, T_DATAFLT, %r15)
	or	%r30, %r0,  %r15

8:
	jmp	%r14	/* loaded above */
#endif /* M88100 */

#ifdef M88110
/*
 * 88110 exception handlers
 */

/* unknown exception handler */
GLOBAL(m88110_unknown_handler)
	PREP88110("unknown", 0,)
	or	%r2, %r0, T_UNKNOWNFLT
	or	%r3, %r0, %r30
	XCALL(_C_LABEL(m88110_trap), _ASM_LABEL(check_ast))

/* interrupt exception handler */
GLOBAL(m88110_interrupt_handler)
	PREP88110("interrupt", 1,)
	or	%r2, %r0, %r30
	XCALL(_C_LABEL(interrupt), _ASM_LABEL(check_ast))

/* instruction access exception handler */
GLOBAL(m88110_instruction_access_handler)
	PREP88110("inst", 2,)
	or	%r2, %r0, T_INSTFLT
	or	%r3, %r0, %r30
	XCALL(_C_LABEL(m88110_trap), _ASM_LABEL(check_ast))
/*
 * data access exception handler --
 *  See badaddr() below for info about Data_Precheck.
 */
GLOBAL(m88110_data_exception_handler_bootstrap)
	PREP88110("data", 3, M88110_Data_Precheck)
	or	%r2, %r0, T_DATAFLT
	or	%r3, %r0, %r30
	XCALL(_C_LABEL(m88110_trap), _ASM_LABEL(check_ast))
GLOBAL(m88110_data_exception_handler)
	PREP88110("data", 3,)
	or	%r2, %r0, T_DATAFLT
	or	%r3, %r0, %r30
	XCALL(_C_LABEL(m88110_trap), _ASM_LABEL(check_ast))

/* misaligned access exception handler */
GLOBAL(m88110_misaligned_handler)
	PREP88110("misalign", 4,)
	or	%r2, %r0, T_MISALGNFLT
	or	%r3, %r0, %r30
	XCALL(_C_LABEL(m88110_trap), _ASM_LABEL(check_ast))

/* unimplemented opcode exception handler */
GLOBAL(m88110_unimplemented_handler)
	PREP88110("unimp", 5,)
	or	%r2, %r0, T_ILLFLT
	or	%r3, %r0, %r30
	XCALL(_C_LABEL(m88110_trap), _ASM_LABEL(check_ast))

/* privilege exception handler */
GLOBAL(m88110_privilege_handler)
	PREP88110("privilege", 6,)
	or	%r2, %r0, T_PRIVINFLT
	or	%r3, %r0, %r30
	XCALL(_C_LABEL(m88110_trap), _ASM_LABEL(check_ast))

/* bounds checking exception handler */
GLOBAL(m88110_bounds_handler)
	PREP88110("bounds", 7,)
	or	%r2, %r0, T_BNDFLT
	or	%r3, %r0, %r30
	XCALL(_C_LABEL(m88110_trap), _ASM_LABEL(check_ast))

/* integer divide-by-zero exception handler */
GLOBAL(m88110_divide_handler)
	PREP88110("divide", 8,)
	or	%r2, %r0, T_ZERODIV
	or	%r3, %r0, %r30
	XCALL(_C_LABEL(m88110_trap), _ASM_LABEL(check_ast))

/* integer overflow exception handler */
GLOBAL(m88110_overflow_handler)
	PREP88110("overflow", 9,)
	or	%r2, %r0, T_OVFFLT
	or	%r3, %r0, %r30
	XCALL(_C_LABEL(m88110_trap), _ASM_LABEL(check_ast))

/* Floating-point precise handler */
GLOBAL(m88110_fpu_handler)
	PREP88110("FPU", 114,)
	or	%r2, %r0, T_FPEPFLT
	or	%r3, %r0, %r30
	XCALL(_C_LABEL(m88110_trap), _ASM_LABEL(check_ast))

/* non-maskable interrupt handler (IPIs, ABORT button) */
GLOBAL(m88110_nonmaskable)
	PREP88110("NMI", 11,)
	or	%r2, %r0, %r30
	XCALL(_C_LABEL(nmi), _ASM_LABEL(nmi_return))

/* software walk data MMU read miss handler */
GLOBAL(m88110_data_read_miss)
	PREP88110("88110 data read miss", 12,)
	or	%r2, %r0, T_110_DRM
	or	%r3, %r0, %r30
	XCALL(_C_LABEL(m88110_trap), _ASM_LABEL(check_ast))

/* software walk data MMU write miss handler */
GLOBAL(m88110_data_write_miss)
	PREP88110("88110 data write miss", 13,)
	or	%r2, %r0, T_110_DWM
	or	%r3, %r0, %r30
	XCALL(_C_LABEL(m88110_trap), _ASM_LABEL(check_ast))

/* software walk inst MMU ATC miss handler */
GLOBAL(m88110_inst_atc_miss)
	PREP88110("88110 inst ATC miss", 14,)
	or	%r2, %r0, T_110_IAM
	or	%r3, %r0, %r30
	XCALL(_C_LABEL(m88110_trap), _ASM_LABEL(check_ast))

/* trap 450: system calls */
GLOBAL(m88110_syscall_handler)
	PREP88110("syscall", 450,)
	ld	%r2, %r30, GENREG_OFF(13)
	or	%r3, %r0, %r30
	XCALL(_C_LABEL(m88110_syscall), _ASM_LABEL(check_ast))

/* trap 451: cache flush (necessary for trampolines) */
GLOBAL(m88110_cache_flush_handler)
	PREP88110("cache_flush", 451,)
	or	%r2, %r0, %r30
	XCALL(_C_LABEL(cache_flush), _ASM_LABEL(check_ast))

GLOBAL(m88110_sigsys)
	PREP88110("sigsys", 501,)
	or	%r2, %r0, T_SIGSYS
	or	%r3, %r0, %r30
	XCALL(_C_LABEL(m88110_trap), _ASM_LABEL(check_ast))

GLOBAL(m88110_stepbpt)
	PREP88110("stepbpt", 504,)
	or	%r2, %r0, T_STEPBPT
	or	%r3, %r0, %r30
	XCALL(_C_LABEL(m88110_trap), _ASM_LABEL(check_ast))

GLOBAL(m88110_userbpt)
	PREP88110("userbpt", 511,)
	or	%r2, %r0, T_USERBPT
	or	%r3, %r0, %r30
	XCALL(_C_LABEL(m88110_trap), _ASM_LABEL(check_ast))

#ifdef DDB
GLOBAL(m88110_break)
	PREP88110("break", 130,)
	or	%r2, %r0, T_KDB_BREAK
	or	%r3, %r0, %r30
	XCALL(_C_LABEL(m88110_trap), _ASM_LABEL(check_ast))

GLOBAL(m88110_trace)
	PREP88110("trace", 131,)
	or	%r2, %r0, T_KDB_TRACE
	or	%r3, %r0, %r30
	XCALL(_C_LABEL(m88110_trap), _ASM_LABEL(check_ast))

GLOBAL(m88110_entry)
	PREP88110("kdb", 132,)
	or	%r2, %r0, T_KDB_ENTRY
	or	%r3, %r0, %r30
	XCALL(_C_LABEL(m88110_trap), _ASM_LABEL(check_ast))
#endif

/*
 * The error exception and reset exception handler.
 *
 * The error exception is raised when any other non-trap exception is raised
 * while shadowing is off. This is Bad News.
 *
 * The reset exception is raised when the RST signal is asserted (machine
 * is reset), the value of VBR is changed after exceptions are enabled,
 * or when a jmp, br/bsr to addr 0 (accidents do happen :-)
 * Upon a real reset, VBR is set to zero (0), so code must be at addr 0
 * to handle it!!!
 *
 * The shadow registers are not valid in this case (shadowing was off, if this
 * was an error exception, and may not be on, if this was a reset exception).
 * R1-R31 may be interesting though, so we'll save them.
 *
 * We'll not worry about trashing r26-29 here,
 * since they aren't generally used.
 */
GLOBAL(m88110_error_handler)
	or	%r29, %r0, 10
	br	1f
GLOBAL(m88110_reset_handler)
	or	%r29, %r0, 0
1:
	or	%r26, %r0,  %r31	/* save old stack */
	or.u	%r31, %r0,  %hi16(_ASM_LABEL(initstack_end))
	or	%r31, %r31, %lo16(_ASM_LABEL(initstack_end))

#ifdef DEBUG
	/* zero the stack, so we'll know what we're lookin' at */
	or.u	%r27, %r0,  %hi16(_ASM_LABEL(initstack))
	or	%r27, %r27, %lo16(_ASM_LABEL(initstack))
1:	cmp	%r28, %r27, %r31
	bb1	ge,   %r28, 2f	/* branch if at the end of the stack */
	st	%r0,  %r0,  %r27
	addu	%r27, %r27, 4	/* bump up */
	br	1b
2:	/* stack has been cleared */
#endif

	/* ensure that stack is 8-byte aligned */
	clr	%r31, %r31, 3<0>	/* round down to 8-byte boundary */

	/* create exception frame on stack */
	subu	%r31, %r31, TRAPFRAME_SIZEOF	/* r31 now our E.F. */

	/* save old R31 and other R registers */
	st.d	%r0,  %r31, GENREG_OFF(0)
	st.d	%r2,  %r31, GENREG_OFF(2)
	st.d	%r4,  %r31, GENREG_OFF(4)
	st.d	%r6,  %r31, GENREG_OFF(6)
	st.d	%r8,  %r31, GENREG_OFF(8)
	st.d	%r10, %r31, GENREG_OFF(10)
	st.d	%r12, %r31, GENREG_OFF(12)
	st.d	%r14, %r31, GENREG_OFF(14)
	st.d	%r16, %r31, GENREG_OFF(16)
	st.d	%r18, %r31, GENREG_OFF(18)
	st.d	%r20, %r31, GENREG_OFF(20)
	st.d	%r22, %r31, GENREG_OFF(22)
	st.d	%r24, %r31, GENREG_OFF(24)
	st	%r30, %r31, GENREG_OFF(30)
	st	%r26, %r31, GENREG_OFF(31)

	/* vector is put in SRO (either 0 or 10 at this point) */
	st	%r29, %r31, EF_VECTOR

	/* save shadow registers (are OLD if error_handler, though) */
	ldcr	%r10, EPSR
	st	%r10, %r31, EF_EPSR
	ldcr	%r10, EXIP
	st	%r10, %r31, EF_EXIP
	ldcr	%r10, ENIP
	st	%r10, %r31, EF_ENIP
	ldcr	%r10, DSR
	st	%r10, %r31, EF_DSR
	ldcr	%r10, DLAR
	st	%r10, %r31, EF_DLAR
	ldcr	%r10, DPAR
	st	%r10, %r31, EF_DPAR
	ldcr	%r10, ISR
	st	%r10, %r31, EF_ISR
	ldcr	%r10, ILAR
	st	%r10, %r31, EF_ILAR
	ldcr	%r10, IPAR
	st	%r10, %r31, EF_IPAR
	ldcr	%r10, SR1
	st	%r10, %r31, EF_FLAGS

	/* shove sr2 into EF_FPLS1 */
	ldcr	%r10, SR2
	st	%r10, %r31, EF_FPLS1

	/* shove sr3 into EF_FPHS2 */
	ldcr	%r10, SR3
	st	%r10, %r31, EF_FPHS2

	/*
	 * Cheap way to enable FPU and start shadowing again.
	 */
	ldcr	%r10, PSR
	clr	%r10, %r10, 1<PSR_FPU_DISABLE_BIT>	/* enable the FPU */
	clr	%r10, %r10, 1<PSR_SHADOW_FREEZE_BIT>	/* and shadowing */
	stcr	%r10, PSR
	FLUSH_PIPELINE

	/* put pointer to regs into r30... r31 will become a simple stack */
	or	%r30, %r31, %r0

	subu	%r31, %r31, 0x10	/* make some breathing space */
	st	%r30, %r31, 0x0c	/* store frame pointer on the stack */
#ifdef DDB
	st	%r30, %r31, 0x08	/* store again for the debugger to recognize */
	or.u	%r20,  %r0, %hi16(0x87654321)
	or	%r20, %r20, %lo16(0x87654321)
	st	%r20, %r31, 0x04
	st	%r20, %r31, 0x00
#endif

	or	%r2, %r0, %r30
	bsr	_C_LABEL(error_fatal)

	/* turn interrupts back on */
	ldcr	%r1, PSR
	clr	%r1, %r1, 1<PSR_INTERRUPT_DISABLE_BIT>
	stcr	%r1, PSR
	FLUSH_PIPELINE

1:
	br	1b
	/* NOTREACHED */

/*
 * 88110 exception handling setup
 *
 * This is much simpler than for 88100, because all exception are
 * precise. Therefore, when reenabling shadowing, we do not risk
 * getting new exceptions caught by the execution pipeline and not
 * reported yet.
 *
 * However, as soon as shadow freezing is over, we can receive a
 * non-maskable interrupt at any time. The code below will cope with
 * this, as long as the stack pointer (r31) is valid in the kernel
 * all the time shadowing is enabled.
 *
 * Thus, unlike the 88100 code, we setup both the exception frame
 * (in r30) and the exception stack (in r31) as early as possible.
 */

ASLOCAL(m88110_setup_phase_one)
	/*
	 * SR1: saved copy of exception-time register now holding FLAGS
	 * SR2: saved copy of exception-time r1
	 * SR3: free
	 * r1: return address to calling exception handler
	 * FLAGS: CPU status flags
	 *
	 * immediate goal:
	 *   Find out where to put the exception frame, and which
	 *   stack to use.
	 */

	NOP
	xcr	%r1,   %r1,   SR2	/* recover exception-time r1 */
	NOP
	NOP
	NOP

	/*
	 * If we were in the kernel when the exception occured, we have
	 * a valid stack. Keep using it, and build the frame on it.
	 *
	 * Note that if this exception is an NMI, we might be currently
	 * switching processes, and curpcb and curproc won't match. It
	 * is nevertheless safe to use curpcb, since nmi are processed
	 * with interrupts disabled, and we won't check for AST or soft
	 * interrupts before returning to the cpu_switchto kernel code.
	 */
	bb1	FLAG_FROM_KERNEL, FLAGS, _ASM_LABEL(m88110_kernel_stack)

	/*
	 * Otherwise, this is an exception in user mode, we'll use the PCB
	 * for the exception frame and the top of the PCB as the stack.
	 */

	/* compute frame address: in PCB */
	stcr	%r30, SR3			/* save r30, now free */
	ldcr	%r30, CPU
	ld	%r30, %r30, CI_CURPCB
	addu	%r30, %r30, PCB_USER_STATE	/* point to user save area */

	/* save a few registers before we lose them*/
	st	%r1,  %r30, GENREG_OFF(1)	/* save prev. r1 (now free)*/
	ldcr	%r1,  SR3			/* save previous r30 */
	st	%r31, %r30, GENREG_OFF(31)
	st	%r1,  %r30, GENREG_OFF(30)

	/* compute stack address: top of U area */
	ldcr	%r1,  CPU
	ld	%r31, %r1,  CI_CURPCB
	addu	%r31, %r31, USPACE

	br	_ASM_LABEL(m88110_have_stack)

ASLOCAL(m88110_kernel_stack)		/* Exception in kernel mode */

	/* compute stack and frame address: allocate them on current stack */
	subu	%r31, %r31, TRAPFRAME_SIZEOF	/* r31 now our E.F. */

	/* save a few registers before we lose them */
	st	%r1,  %r31, GENREG_OFF(1)	/* save prev. r1 (now free) */
	addu	%r1,  %r31, TRAPFRAME_SIZEOF	/* save previous r31 */
	st	%r30, %r31, GENREG_OFF(30)
	st	%r1,  %r31, GENREG_OFF(31)

	/* frame = stack */
	or	%r30, %r31, %r0

	/* FALLTHROUGH */

ASLOCAL(m88110_have_stack)
	/*
	 * SR1: saved copy of exception-time register now holding FLAGS
	 * SR2: return address to the calling exception handler
	 * SR3: free
	 * r1:  free
	 * FLAGS: CPU status flags
	 * r30: incomplete exception frame
	 * r31: exception stack
	 * Valid in the exception frame:
	 *   Exception-time r1, r30, r31, FLAGS.
	 */

	stcr	TMP, SR3	/* free up TMP, TMP2, TMP3 */
	SAVE_TMP2(%r30)
	SAVE_TMP3(%r30)

	/* save some exception-time registers to the exception frame */
	st	FLAGS,%r30, EF_FLAGS		/* save flags */

	ldcr	TMP,  EPSR
	st	TMP,  %r30, EF_EPSR
	ldcr	TMP2, EXIP
	ldcr	TMP3, ENIP
	st	TMP2, %r30, EF_EXIP
	st	TMP3, %r30, EF_ENIP

	/* get and store the cpu_info pointer */
	ldcr	TMP,  CPU
	st	TMP,  %r30, EF_CPU

	/*
	 * Save and clear fault status registers.
	 */
	ldcr	TMP,  ISR
	st	TMP,  %r30, EF_ISR
	bcnd	eq0,  TMP,  1f
	ldcr	TMP2, ILAR
	ldcr	TMP3, IPAR
	st	TMP2, %r30, EF_ILAR
	st	TMP3, %r30, EF_IPAR
	ldcr	TMP,  ISAP
	ldcr	TMP2, IUAP
	st	TMP,  %r30, EF_ISAP
	st	TMP2, %r30, EF_IUAP
	stcr	%r0,  ISR
1:
	ldcr	TMP,  DSR
	st	TMP,  %r30,  EF_DSR
	bcnd	eq0,  TMP,  1f
	ldcr	TMP2, DLAR
	ldcr	TMP3, DPAR
	st	TMP2, %r30,  EF_DLAR
	st	TMP3, %r30,  EF_DPAR
	ldcr	TMP,  DSAP
	ldcr	TMP2, DUAP
	st	TMP,  %r30,  EF_DSAP
	st	TMP2, %r30,  EF_DUAP
	stcr	%r0,  DSR
1:
	ldcr	%r1,  SR2
	jmp	%r1

ASLOCAL(m88110_setup_phase_two)
	/*
	 * SR1: saved copy of exception-time register now holding FLAGS
	 * SR2: free
	 * SR3: saved TMP
	 * r1:  return address to calling exception handler
	 * TMP2: free
	 * TMP3: free
	 * FLAGS: CPU status flags
	 * r30: incomplete exception frame
	 * r31: exception stack
	 * Valid in the exception frame:
	 *   Exception-time r1, r30, r31, FLAGS.
	 *   Exception-time TMP2, TMP3.
	 *   Exception-time epsr, enip, exip.
	 *   Exception number (EF_VECTOR).
	 *
	 * immediate goal:
	 *   restore the system to the exception-time state.
	 */

	RESTORE_TMP2(%r30)	/* done with extra temp regs */
	RESTORE_TMP3(%r30)	/* done with extra temp regs */

	ldcr	TMP,  PSR
	clr	TMP,  TMP,  1<PSR_SHADOW_FREEZE_BIT>	/* enable shadowing */
	stcr	TMP,  EPSR

	or.u	TMP,  %r0,  %hi16(_ASM_LABEL(m88110_shadow_enable))
	or	TMP,  TMP,  %lo16(_ASM_LABEL(m88110_shadow_enable))
	stcr	TMP,  EXIP

	xcr	FLAGS,FLAGS,SR1
	st	%r1,  %r30, EF_RET		/* save the return address */

	xcr	TMP,  %r31, SR3	/* TMP now restored. R31 now saved in SR3 */

	/*
	 * SR1: CPU flags
	 * SR2: free
	 * SR3: pointer to our exception frame (our stack pointer)
	 * r2 through r29: original exception-time values
	 * r30: exception frame
	 * r31: exception stack
	 *
	 * Valid in the exception frame:
	 *   Exception-time r1, r30, r31, FLAGS.
	 *   Exception-time epsr, sfip, enip, exip.
	 *   Exception number (EF_VECTOR).
	 *   DSR/ISR, fault registers, if appropriate.
	 * Held temporarily in the exception frame:
	 *   Return address to the calling exception handler.
	 *
	 * immediate goal:
	 *   Do an RTE to unfreeze the shadow registers.
	 *   Another exception (NMI) may be raised in this.
	 */
	RTE	/* jumps to "m88110_shadow_enable" */

ASLOCAL(m88110_shadow_enable)
	FLUSH_PIPELINE				/* XXX necessary? */

	/* now save all missing regs to the exception frame. */
	st	%r0,  %r30, GENREG_OFF(0)
	st	%r2,  %r30, GENREG_OFF(2)
	st	%r3,  %r30, GENREG_OFF(3)
	st	%r4,  %r30, GENREG_OFF(4)
	st	%r5,  %r30, GENREG_OFF(5)
	st	%r6,  %r30, GENREG_OFF(6)
	st	%r7,  %r30, GENREG_OFF(7)
	st	%r8,  %r30, GENREG_OFF(8)
	st	%r9,  %r30, GENREG_OFF(9)
	st	%r10, %r30, GENREG_OFF(10)
	st	%r11, %r30, GENREG_OFF(11)
	st	%r12, %r30, GENREG_OFF(12)
	st	%r13, %r30, GENREG_OFF(13)
	st	%r14, %r30, GENREG_OFF(14)
	st	%r15, %r30, GENREG_OFF(15)
	st	%r16, %r30, GENREG_OFF(16)
	st	%r17, %r30, GENREG_OFF(17)
	st	%r18, %r30, GENREG_OFF(18)
	st	%r19, %r30, GENREG_OFF(19)
	st	%r20, %r30, GENREG_OFF(20)
	st	%r21, %r30, GENREG_OFF(21)
	st	%r22, %r30, GENREG_OFF(22)
	st	%r23, %r30, GENREG_OFF(23)
	st	%r24, %r30, GENREG_OFF(24)
	st	%r25, %r30, GENREG_OFF(25)
	st	%r26, %r30, GENREG_OFF(26)
	st	%r27, %r30, GENREG_OFF(27)
	st	%r28, %r30, GENREG_OFF(28)
	st	%r29, %r30, GENREG_OFF(29)

	/*
	 * SR1: free
	 * SR2: free
	 * SR3: free
	 * r1 through r29: free
	 * r30: exception frame
	 * r31: exception stack
	 *
	 * Valid in the exception frame:
	 *   Exception-time r0 through r31.
	 *   Exception-time FLAGS.
	 *   Exception-time epsr, enip, exip.
	 *   Exception number (EF_VECTOR).
	 *   Return value (EF_RET).
	 *   DSR/ISR, fault registers, if appropriate.
	 *
	 * immediate goal:
	 *   Bump the stack a doubleword and write the exception frame pointer.
	 *   If not an interrupt exception or an NMI, turn on interrupts.
	 *   Return to calling exception handler to service the exception.
	 */

	/* get and save IPL */
	bsr	_C_LABEL(getipl)
	st	%r2,  %r30, EF_MASK

	subu	%r31, %r31, 8	/* make some breathing space */
	st	%r30, %r31, 0	/* store frame pointer on the stack */
#ifdef DDB
	st	%r30, %r31, 4	/* store it again for the debugger */
#endif

	ld	%r6,  %r30, EF_EPSR
	ld	%r14, %r30, EF_RET

	/* don't turn interrupts back on unless they were enabled when the
	   trap occured */
	bb1	PSR_INTERRUPT_DISABLE_BIT, %r6, 8f

	ld	%r2,  %r30, EF_VECTOR
	bcnd	eq0,  %r2,  8f
	cmp	%r3,  %r2,  1		/* is this an interrupt? */
	bb1	eq,   %r3,  8f
	cmp	%r3,  %r2,  11		/* or NMI? */
	bb1	eq,   %r3,  8f

#ifdef DDB
	cmp	%r3,  %r2,  130		/* DDB break exception */
	bb1	eq,   %r3,  8f
	cmp	%r3,  %r2,  132		/* DDB entry exception */
	bb1	eq,   %r3,  8f
#endif

	ldcr	%r2,  PSR
	clr	%r2,  %r2,  1<PSR_INTERRUPT_DISABLE_BIT>
	stcr	%r2,  PSR
	FLUSH_PIPELINE

8:
	jmp	%r14		/* loaded above */
#endif	/* M88110 */

	.text

#define	FPTR	%r14

ASGLOBAL(check_ast)
	/*
	 * Regs r1-r30 are free. r31 is pointing at the word
	 * on the kernel stack where our pointer to the exception frame
	 * it stored. Reload it now.
	 *
	 * We load it into r14 since it is preserved across function
	 * calls, and we may have to call some routines from within here.
	 *
	 * Control is transferred here from obvious places in this file.
	 */
	ld	FPTR, %r31, 0	/* grab exception frame pointer */

	/*
	 * If the saved ipl is 0, then call spl0() to process soft
	 * interrupts. And if returning to userland, look for ASTs.
	 */

	/* do not service AST and soft interrupts if interrupts were disabled */
	ld	%r2, FPTR, EF_EPSR
	bb1	PSR_INTERRUPT_DISABLE_BIT, %r2, _ASM_LABEL(ast_done)
	/* ...or we were not at spl0 */
	ld	%r2, FPTR, EF_MASK
	bcnd	ne0, %r2, _ASM_LABEL(ast_done)

#ifdef MULTIPROCESSOR
	/*
	 * Check for IPI soft interrupt
	 */
	ldcr	%r3,  CPU
	or	%r15, %r0,  %r0
	addu	%r3,  %r3,  CI_SOFTIPI_CB
	xmem	%r15, %r3,  %r0
	bcnd	eq0,  %r15, _ASM_LABEL(do_softint)

	bsr.n	_C_LABEL(setipl)
	 or	%r2,  %r0,  IPL_NONE

	jsr	%r15
ASLOCAL(do_softint)
#endif

	/*
	 * Process soft interrupts, if any.
	 */
	bsr	_C_LABEL(spl0)

	/* do not service AST if not returning to user mode */
	ld	%r2, FPTR, EF_EPSR
	bb1	PSR_SUPERVISOR_MODE_BIT, %r2, _ASM_LABEL(ast_done)
1:
	ldcr	%r2, CPU
	ld	%r3, %r2, CI_CURPROC
	ld	%r2, %r3, P_ASTPENDING
	bcnd	eq0, %r2, _ASM_LABEL(ast_done)

	bsr.n	_C_LABEL(ast)
	 or	%r2, %r0, FPTR

	br	1b

/*
 * void proc_trampoline(void (*func)(void *), void *proc)
 *
 * When a process setup by cpu_fork() resumes, it will find itself in
 * proc_trampoline, with r31 pointing to a ksigframe. proc_trampoline will
 * load func and proc values from ksigframe, call the function, and on return
 * pop off the ksigframe. Then, it will return to userland.
 */

ENTRY(proc_trampoline)
#ifdef MULTIPROCESSOR
	bsr	_C_LABEL(proc_trampoline_mp)
#endif

	bsr.n	_C_LABEL(setipl)	/* setipl(IPL_NONE) */
	 or	%r2,  %r0,  %r0

	ld	%r1,  %r31, 0		/* load func */
	ld	%r2,  %r31, 4 		/* load arg */
	jsr.n	%r1
	 addu	%r31, %r31, 8		/* release ksigframe */

/*
 * Load FPTR with a pointer to the trap frame for the current proc and
 * continue near the end of check_ast, bypassing soft interrupts and AST
 * checks, to load all the registers and do an RTE.
 */

	ldcr	%r3,  CPU
	ld	%r2,  %r3,  CI_CURPROC

	ld	FPTR, %r2,   P_ADDR		/* p->p_addr */
	addu	FPTR, FPTR, PCB_USER_STATE	/* p->p_addr.u_pcb.user_state */

	/* FALLTHROUGH */

ASGLOBAL(ast_done)
	/* disable interrupts */
	ldcr	%r1, PSR
	set	%r1, %r1, 1<PSR_INTERRUPT_DISABLE_BIT>
	stcr	%r1, PSR
	FLUSH_PIPELINE

	/* now ready to return....*/
	bsr.n	_C_LABEL(setipl)
	 ld	%r2, FPTR, EF_MASK		/* get pre-exception ipl */

#if defined(M88100) && defined(M88110)
	ldcr	%r2, PID
	extu	%r3, %r2, 8<8>
	bcnd	ne0, %r3, _ASM_LABEL(m88110_user_rte)
	/* FALLTHROUGH */
#endif

#ifdef M88100
ASGLOBAL(m88100_user_rte)
	/*
	 * Transfer the frame pointer to r31, since we no longer need a stack.
	 * No page faults here, and interrupts are disabled.
	 */
	or	%r31, %r0,  FPTR

	/* restore r1 later */
	ld	%r2,  %r31, GENREG_OFF(2)
	ld	%r3,  %r31, GENREG_OFF(3)
	ld	%r4,  %r31, GENREG_OFF(4)
	ld	%r5,  %r31, GENREG_OFF(5)
	ld	%r6,  %r31, GENREG_OFF(6)
	ld	%r7,  %r31, GENREG_OFF(7)
	ld	%r8,  %r31, GENREG_OFF(8)
	ld	%r9,  %r31, GENREG_OFF(9)
	ld	%r10, %r31, GENREG_OFF(10)
	ld	%r11, %r31, GENREG_OFF(11)
	ld	%r12, %r31, GENREG_OFF(12)
	ld	%r13, %r31, GENREG_OFF(13)
	ld	%r14, %r31, GENREG_OFF(14)
	ld	%r15, %r31, GENREG_OFF(15)
	ld	%r16, %r31, GENREG_OFF(16)
	ld	%r17, %r31, GENREG_OFF(17)
	ld	%r18, %r31, GENREG_OFF(18)
	ld	%r19, %r31, GENREG_OFF(19)
	ld	%r20, %r31, GENREG_OFF(20)
	ld	%r21, %r31, GENREG_OFF(21)
	ld	%r22, %r31, GENREG_OFF(22)
	ld	%r23, %r31, GENREG_OFF(23)
	ld	%r24, %r31, GENREG_OFF(24)
	ld	%r25, %r31, GENREG_OFF(25)
	ld	%r26, %r31, GENREG_OFF(26)
	ld	%r27, %r31, GENREG_OFF(27)
	ld	%r28, %r31, GENREG_OFF(28)
	ld	%r29, %r31, GENREG_OFF(29)
	/* restore r1, r30, r31 later */

	/* disable shadowing */
	ldcr	%r1, PSR
	set	%r1, %r1, 1<PSR_SHADOW_FREEZE_BIT>
	stcr	%r1, PSR
	FLUSH_PIPELINE

	/* reload the control regs*/
	/*
	 * RTE will cause execution to continue first with the
	 * instruction pointed to by the NIP and then the FIP;
	 * it is not necessary to restore XIP.
	 */
	stcr	%r0,  SSBR
	ld	%r30, %r31, EF_SNIP
	ld	%r1,  %r31, EF_SFIP
	stcr	%r30, SNIP
	stcr	%r1,  SFIP

	ld	%r30, %r31, EF_EPSR
	stcr	%r30, EPSR

	/* Now restore r1, r30, and r31 */
	ld	%r1,  %r31, GENREG_OFF(1)
	ld	%r30, %r31, GENREG_OFF(30)
	ld	%r31, %r31, GENREG_OFF(31)

	RTE
#endif

#ifdef M88110
ASGLOBAL(m88110_user_rte)
	/*
	 * Disable shadowing. This used to be done after all the registers
	 * from the E.F. have been restored, but on 88110 we may receive
	 * an NMI anytime, unless shadowing is frozen, and we rely on r31
	 * being valid.
	 */
	ldcr	%r1, PSR
	set	%r1, %r1, 1<PSR_SHADOW_FREEZE_BIT>
	stcr	%r1, PSR
	FLUSH_PIPELINE

ASLOCAL(m88110_restore)
	/*
	 * Transfer the frame pointer to r31, since we no longer need a stack.
	 * No page faults here, and interrupts are disabled.
	 */
	or	%r31, %r0,  FPTR
	/* restore r1 later */
	ld	%r2,  %r31, GENREG_OFF(2)
	ld	%r3,  %r31, GENREG_OFF(3)
	ld	%r4,  %r31, GENREG_OFF(4)
	ld	%r5,  %r31, GENREG_OFF(5)
	ld	%r6,  %r31, GENREG_OFF(6)
	ld	%r7,  %r31, GENREG_OFF(7)
	ld	%r8,  %r31, GENREG_OFF(8)
	ld	%r9,  %r31, GENREG_OFF(9)
	ld	%r10, %r31, GENREG_OFF(10)
	ld	%r11, %r31, GENREG_OFF(11)
	ld	%r12, %r31, GENREG_OFF(12)
	ld	%r13, %r31, GENREG_OFF(13)
	ld	%r14, %r31, GENREG_OFF(14)
	ld	%r15, %r31, GENREG_OFF(15)
	ld	%r16, %r31, GENREG_OFF(16)
	ld	%r17, %r31, GENREG_OFF(17)
	ld	%r18, %r31, GENREG_OFF(18)
	ld	%r19, %r31, GENREG_OFF(19)
	ld	%r20, %r31, GENREG_OFF(20)
	ld	%r21, %r31, GENREG_OFF(21)
	ld	%r22, %r31, GENREG_OFF(22)
	ld	%r23, %r31, GENREG_OFF(23)
	ld	%r24, %r31, GENREG_OFF(24)
	ld	%r25, %r31, GENREG_OFF(25)
	ld	%r26, %r31, GENREG_OFF(26)
	ld	%r27, %r31, GENREG_OFF(27)
	ld	%r28, %r31, GENREG_OFF(28)
	ld	%r29, %r31, GENREG_OFF(29)
	/* restore r1, r30, r31 later */

	/* reload the control regs*/
	ld	%r30, %r31, EF_ENIP
	ld	%r1,  %r31, EF_EXIP
	stcr	%r30, ENIP
	stcr	%r1,  EXIP

	ld	%r30, %r31, EF_EPSR
	stcr	%r30, EPSR

	/* Now restore r1, r30, and r31 */
	ld	%r1,  %r31, GENREG_OFF(1)
	ld	%r30, %r31, GENREG_OFF(30)
	ld	%r31, %r31, GENREG_OFF(31)

	/*
	 * 88110 errata #18 (fixed in revision 5 cpus):
	 * ``An rte to user mode where the logical address of the rte
	 *   instruction is within two cache lines of the logical address
	 *   in the exip can cause the wrong instruction to be returned
	 *   to if the rte instruction misses in the icache.''
	 *
	 * Since we run with interrupts disabled at this point, all we
	 * need is make sure that the rte will not appear as the first
	 * instruction of a cache line.
	 */
	br	1f

	.align 6	/* 32 bytes might not be enough */
1:
	NOP
	RTE

	/*
	 * NMI return here after processing.
	 * We then decide whether to check for AST and soft interrupts,
	 * or not.
	 */
ASLOCAL(nmi_return)
	bcnd	ne0, %r2, _ASM_LABEL(check_ast)

	ld	FPTR, %r31, 0	/* grab exception frame pointer */

	/*
	 * Disable interrupts and shadowing. The latter used to be done
	 * after all the registers from the E.F. have been restored, but
	 * on 88110 we may receive an NMI anytime, unless shadowing is frozen,
	 * and we rely on r31 being valid.
	 */
	ldcr	%r1, PSR
	set	%r1, %r1, 1<PSR_INTERRUPT_DISABLE_BIT>
	set	%r1, %r1, 1<PSR_SHADOW_FREEZE_BIT>
	stcr	%r1, PSR
	FLUSH_PIPELINE

	/* now ready to return....*/
	bsr.n	_C_LABEL(setipl)
	 ld	%r2, FPTR, EF_MASK		/* get pre-exception ipl */

#ifdef MULTIPROCESSOR
	/*
	 * Reenable NMIs if necessary.
	 */
	or	%r2,   FPTR,  %r0
	bsr	_C_LABEL(nmi_wrapup)
#endif

	br	_ASM_LABEL(m88110_restore)
#endif
@


1.60
log
@No need to test for DMT0 being valid a second time in the `save DMT and
clear proper SSBR bits' code path.
@
text
@d1 1
a1 1
/*   $OpenBSD: eh_common.S,v 1.59 2013/08/15 19:29:10 miod Exp $	*/
d454 1
d456 1
a456 1
	XCALL(_ASM_LABEL(m88100_Xfp_precise), _ASM_LABEL(check_ast))
d463 1
d465 1
a465 1
	XCALL(_ASM_LABEL(Xfp_imprecise), _ASM_LABEL(check_ast))
@


1.59
log
@typos
@
text
@d1 1
a1 1
/*   $OpenBSD: eh_common.S,v 1.58 2013/05/25 16:22:12 miod Exp $	*/
d1072 2
a1073 4
/*
 * need to clear "appropriate" bits in the SSBR before
 * we restart the FPU
 */
d1075 5
a1079 4
	ldcr	TMP2, DMT0
	bb0.n	DMT_VALID_BIT, TMP2, 8f
	/* make sure an exception in fpu_enable will not see our DMT0 */
	 stcr	%r0,   DMT0
@


1.58
log
@Allow badaddr() to be used with a size of 8. Needed by the MVME181 memory
detection code, and forgotten in previous commit.
@
text
@d1 1
a1 1
/*   $OpenBSD: eh_common.S,v 1.57 2013/01/05 11:20:56 miod Exp $	*/
d1135 1
a1135 1
	 * Clear floatingpoint-imprecise ssbr bits.
d1173 1
a1173 1
	 * Clear floating pont precise ssbr bits.
d1207 1
a1207 1
	set	TMP3, TMP3, 1<6>	/* size=2 - clear two bit for double */
@


1.57
log
@Switch m88k ports to ELF.
@
text
@d1 1
a1 1
/*   $OpenBSD: eh_common.S,v 1.56 2012/12/30 18:13:19 miod Exp $	*/
d737 1
a737 1
 * Len may be be 1, 2, or 4.
d764 3
a766 6
	/*
	 * If it's a word we're doing, do that here. Otherwise,
	 * see if it's a halfword.....
	 */
	sub	%r6, %r3, 4
	bcnd.n	ne0, %r6, _ASM_LABEL(badaddr__maybe_halfword)
d769 23
d793 5
a797 1
	 * It's a bad address if it's misaligned.
d799 10
d810 1
a810 10
	bb1	1, %r2, _ASM_LABEL(badaddr__return_nonzero)
	/*
	 * The next line will either fault or not. If it faults, execution
	 * will go to:  data_access_handler (see above)
	 * and then to: ignore_data_exception (see above)
	 * and then to: badaddr__return_nonzero (see below)
	 * which will return to the calling function.
	 *
	 * If there is no fault, execution just continues as normal.
	 */
d812 1
a812 1
	ld	%r5, %r2, 0
d815 1
a815 1
	 or	%r2, %r0, %r0	/* indicate a zero (address not bad) return.*/
d817 2
a818 6
ASLOCAL(badaddr__maybe_halfword)
	/* More or less like the code for checking a word above */
	sub	%r6, %r3, 2
	bcnd	ne0, %r6, _ASM_LABEL(badaddr__maybe_byte)

	/* it's bad if it's misaligned */
d820 1
d823 1
a823 1
	ld.h	%r5, %r2, 0
d826 7
a832 1
	 or	%r2, %r0, %r0
a833 6
ASLOCAL(badaddr__maybe_byte)
#ifdef DEBUG
	/* More or less like the code for checking a word above */
	sub	%r6, %r3, 1
	bcnd	ne0, %r6, _ASM_LABEL(badaddr__unknown_size)
#endif
d835 1
a835 1
	ld.b	%r5, %r2, 0
d838 1
a838 12
	 or	%r2, %r0, %r0
ASLOCAL(badaddr__unknown_size)
#ifdef	DEBUG
	data
1: 	string "bad length (%d) to badaddr() from 0x%x\000"
	text
	or.u	%r2, %r0, %hi16(1b)
	or	%r2, %r2, %lo16(1b)
	bsr.n	_C_LABEL(panic)
	 or	%r4, %r0, %r1
	/*NOTREACHED*/
#endif
@


1.56
log
@Prevent a branch-with-delay-slot instruction to be the delay slot of a previous
branch-with-delay-slot instruction, in the 88100 exception code path, in
kernels configured without DDB. This is undefined behaviour, but we have
apparently be lucky enough since RAMDISK is known to work on 88100.
@
text
@d1 1
a1 1
/*   $OpenBSD: eh_common.S,v 1.55 2010/12/23 20:05:08 miod Exp $	*/
d235 1
a235 1
	or	r2, r0, ARG1; \
d237 1
a237 1
	 or	r3, r0, ARG2
d243 1
a243 1
	 addu	r1, r1, RET - . - 4
d251 8
a258 8
#define	FLAGS			r2
#define	TMP			r3
#define	TMP2			r10
#define	TMP3			r11
#define	SAVE_TMP2(ef)		st	r10, ef, GENREG_OFF(10)
#define	SAVE_TMP3(ef)		st	r11, ef, GENREG_OFF(11)
#define	RESTORE_TMP2(ef)	ld	r10, ef, GENREG_OFF(10)
#define	RESTORE_TMP3(ef)	ld	r11, ef, GENREG_OFF(11)
d270 2
a271 2
	text
	align 8
d282 2
a283 2
 *		or	r2, r0, T_FOO_FAULT
 *		or	r3, r0, r30
d310 1
a310 1
	stcr	r1, SR2	/* r1 now free */		; \
d312 2
a313 2
	ldcr	r1, EPSR				; \
	bb0.n	PSR_SUPERVISOR_MODE_BIT, r1, 1f		; \
d319 2
a320 2
	or	TMP2, r0, NUM				; \
	st	TMP2, r31, EF_VECTOR			; \
d334 1
a334 1
	stcr	r1, SR2	/* r1 now free */		; \
d336 1
a336 1
	ldcr	r1, EPSR 				; \
d338 1
a338 1
	bb0	PSR_SUPERVISOR_MODE_BIT, r1, 1f 	; \
d343 1
a343 1
	or	TMP2, r0, NUM				; \
d346 1
a346 1
	st	TMP2, r30, EF_VECTOR			; \
d368 2
a369 2
	or	r2, r0, T_UNKNOWNFLT
	or	r3, r0, r30
d375 1
a375 1
	or	r2, r0, r30
d381 2
a382 2
	or	r2, r0, T_INSTFLT
	or	r3, r0, r30
d401 2
a402 2
	or	r2, r0, T_MISALGNFLT
	or	r3, r0, r30
d408 2
a409 2
	or	r2, r0, T_ILLFLT
	or	r3, r0, r30
d418 4
a421 4
	stcr	r1, SR2		/* hold r1 for a moment */
	ldcr	r1, SXIP	/* look at the sxip... valid bit set? */
	bb1.n	RTE_VALID_BIT, r1, 1f	/* skip over if a valid exception */
	 ldcr	r1, SR2		/* restore r1 */
d424 2
a425 2
	or	r2, r0, T_PRIVINFLT
	or	r3, r0, r30
d431 2
a432 2
	or	r2, r0, T_BNDFLT
	or	r3, r0, r30
d438 2
a439 2
	or	r2, r0, T_ZERODIV
	or	r3, r0, r30
d445 2
a446 2
	or	r2, r0, T_OVFFLT
	or	r3, r0, r30
d454 1
a454 1
	or	r3, r0, r30
d462 1
a462 1
	or	r3, r0, r30
d468 2
a469 2
	ld	r2, r30, GENREG_OFF(13)
	or	r3, r0, r30
d475 1
a475 1
	or	r2, r0, r30
d480 2
a481 2
	or	r2, r0, T_SIGSYS
	or	r3, r0, r30
d486 2
a487 2
	or	r2, r0, T_STEPBPT
	or	r3, r0, r30
d492 2
a493 2
	or	r2, r0, T_USERBPT
	or	r3, r0, r30
d499 2
a500 2
	or	r2, r0, T_KDB_BREAK
	or	r3, r0, r30
d505 2
a506 2
	or	r2, r0, T_KDB_TRACE
	or	r3, r0, r30
d511 2
a512 2
	or	r2, r0, T_KDB_ENTRY
	or	r3, r0, r30
d539 1
a539 1
	 or	r29, r0, 10
d541 1
a541 1
	or	r29, r0, 0
d543 3
a545 3
	or	r26, r0,  r31	/* save old stack */
	or.u	r31, r0,  hi16(_ASM_LABEL(initstack_end))
	or	r31, r31, lo16(_ASM_LABEL(initstack_end))
d549 5
a553 5
	or.u	r27, r0,  hi16(_ASM_LABEL(initstack))
	or	r27, r27, lo16(_ASM_LABEL(initstack))
1:	cmp	r28, r27, r31
	bb1	ge,  r28, 2f	/* branch if at the end of the stack */
	st	r0,  r0,  r27
d555 1
a555 1
	 addu	r27, r27, 4	/* bump up */
d560 1
a560 1
	clr	r31, r31, 3<0>	/* round down to 8-byte boundary */
d563 1
a563 1
	subu	r31, r31, TRAPFRAME_SIZEOF	/* r31 now our E.F. */
d566 15
a580 15
	st.d	r0 , r31, GENREG_OFF(0)
	st.d	r2 , r31, GENREG_OFF(2)
	st.d	r4 , r31, GENREG_OFF(4)
	st.d	r6 , r31, GENREG_OFF(6)
	st.d	r8 , r31, GENREG_OFF(8)
	st.d	r10, r31, GENREG_OFF(10)
	st.d	r12, r31, GENREG_OFF(12)
	st.d	r14, r31, GENREG_OFF(14)
	st.d	r16, r31, GENREG_OFF(16)
	st.d	r18, r31, GENREG_OFF(18)
	st.d	r20, r31, GENREG_OFF(20)
	st.d	r22, r31, GENREG_OFF(22)
	st.d	r24, r31, GENREG_OFF(24)
	st	r30, r31, GENREG_OFF(30)
	st	r26, r31, GENREG_OFF(31)
d583 35
a617 35
	ldcr	r10, EPSR
	st	r10, r31, EF_EPSR
	ldcr	r10, SXIP
	st	r10, r31, EF_SXIP
	ldcr	r10, SNIP
	st	r10, r31, EF_SNIP
	ldcr	r10, SR1
	st	r10, r31, EF_FLAGS
	ldcr	r10, SFIP
	st	r10, r31, EF_SFIP
	ldcr	r10, SSBR
	st	r10, r31, EF_SSBR
	stcr	r0,  SSBR	/* won't want shadow bits bothering us later */

	ldcr	r10, DMT0
	st	r10, r31, EF_DMT0
	ldcr	r11, DMD0
	st	r11, r31, EF_DMD0
	ldcr	r12, DMA0

	st	r12, r31, EF_DMA0
	ldcr	r10, DMT1
	st	r10, r31, EF_DMT1
	FLUSH_PIPELINE
	ldcr	r11, DMD1
	st 	r11, r31, EF_DMD1
	ldcr	r12, DMA1
	st	r12, r31, EF_DMA1

	ldcr	r10, DMT2
	st	r10, r31, EF_DMT2
	ldcr	r11, DMD2
	st	r11, r31, EF_DMD2
	ldcr	r12, DMA2
	st	r12, r31, EF_DMA2
d620 2
a621 2
	ldcr	r10, SR2
	st	r10, r31, EF_FPLS1
d624 2
a625 2
	ldcr	r10, SR3
	st	r10, r31, EF_FPHS2
d628 1
a628 1
	st	r29, r31, EF_VECTOR
d633 4
a636 4
	ldcr	r10, PSR
	clr	r10, r10, 1<PSR_FPU_DISABLE_BIT>	/* enable the FPU */
	clr	r10, r10, 1<PSR_SHADOW_FREEZE_BIT>	/* and shadowing */
	stcr	r10, PSR
d640 1
a640 1
	or	r30, r31, r0
d642 2
a643 2
	subu	r31, r31, 0x10	/* make some breathing space */
	st	r30, r31, 0x0c	/* store frame pointer on the stack */
d645 5
a649 5
	st	r30, r31, 0x08	/* store again for the debugger to recognize */
	or.u	r20,  r0, hi16(0x87654321)
	or	r20, r20, lo16(0x87654321)
	st	r20, r31, 0x04
	st	r20, r31, 0x00
d653 1
a653 1
	 or	r2, r0, r30
d656 3
a658 3
	ldcr	r1, PSR
	clr	r1, r1, 1<PSR_INTERRUPT_DISABLE_BIT>
	stcr	r1, PSR
d690 6
a695 6
	or.u	r2, r0, hi16(_ASM_LABEL(badaddr__return_nonzero) + 2)
	or	r2, r2, lo16(_ASM_LABEL(badaddr__return_nonzero) + 2)
	stcr	r2, SNIP	/* Make it the next instruction to execute */
	addu	r2, r2, 4
	stcr	r2, SFIP	/* and the next one after that, too. */
	stcr	r0, SSBR	/* make the scoreboard happy. */
d722 4
a725 4
	or.u	r2, r0, hi16(_ASM_LABEL(badaddr__return_nonzero))
	or	r2, r2, lo16(_ASM_LABEL(badaddr__return_nonzero))
	stcr	r2, EXIP	/* Make it the next instruction to execute */
	stcr	r0, DSR		/* Clear exception status */
d755 3
a757 3
	ldcr	r8, PSR
	set	r4, r8, 1<PSR_INTERRUPT_DISABLE_BIT>
	stcr	r4, PSR
d760 2
a761 2
	ldcr	r5, SR1
	set	r5, r5, 1<FLAG_IGNORE_DATA_EXCEPTION>
d768 3
a770 3
	sub	r6,  r3, 4
	bcnd.n	ne0, r6, _ASM_LABEL(badaddr__maybe_halfword)
	 stcr	r5,  SR1
d775 2
a776 2
	bb1	0, r2, _ASM_LABEL(badaddr__return_nonzero)
	bb1	1, r2, _ASM_LABEL(badaddr__return_nonzero)
d787 1
a787 1
	ld	r5, r2, 0
d790 1
a790 1
	 or	r2, r0, r0	/* indicate a zero (address not bad) return.*/
d794 2
a795 2
	sub	r6, r3, 2
	bcnd	ne0, r6, _ASM_LABEL(badaddr__maybe_byte)
d798 1
a798 1
	bb1	0, r2, _ASM_LABEL(badaddr__return_nonzero)
d801 1
a801 1
	ld.h	r5, r2, 0
d804 1
a804 1
	 or	r2, r0, r0
d809 2
a810 2
	sub	r6, r3, 1
	bcnd	ne0, r6, _ASM_LABEL(badaddr__unknown_size)
d813 1
a813 1
	ld.b	r5, r2, 0
d816 1
a816 1
	 or	r2, r0, r0
d822 2
a823 2
	or.u	r2, r0, hi16(1b)
	or	r2, r2, lo16(1b)
d825 1
a825 1
	 or	r4, r0, r1
d830 1
a830 1
	or	r2, r0, 1
d834 3
a836 3
	ldcr	r4, SR1
	clr	r4, r4, 1<FLAG_IGNORE_DATA_EXCEPTION>
	stcr	r4, SR1
d845 1
a845 1
	stcr	r8, PSR
d847 1
a847 1
	jmp	r1
d866 1
a866 1
	xcr	r1,   r1,   SR2
d887 3
a889 3
	subu	r31,  r31,  TRAPFRAME_SIZEOF	/* r31 now our E.F. */
	st	FLAGS,r31,  EF_FLAGS		/* save flags */
	st	r1,   r31,  GENREG_OFF(1)	/* save prev. r1 (now free)*/
d891 2
a892 2
	ldcr	r1,   SR3			/* save previous SR3 */
	st	r1,   r31,  EF_SR3
d894 1
a894 1
	addu	r1,   r31,  TRAPFRAME_SIZEOF	/* save previous r31 */
d896 1
a896 1
	 st 	r1,   r31,  GENREG_OFF(31)
d919 5
a923 5
	xcr	r30,  r30,  SR3			/* r30 = old exception frame */
	st	r1,   r30,  GENREG_OFF(0)	/* free up r1 */
	ld	r1,   r30,  EF_EPSR		/* get back the epsr */
	bb0.n	PSR_SUPERVISOR_MODE_BIT, r1, 1f	/* if user mode */
	 ld	r1,   r30,  GENREG_OFF(0)	/* restore r1 */
d925 9
a933 9
	st	r0,   r30,  GENREG_OFF(0)	/* repair old frame */
	subu	r30,  r30,  TRAPFRAME_SIZEOF	/* r30 now our E.F. */
	st	FLAGS,r30,  EF_FLAGS		/* save flags */
	st	r1,   r30,  GENREG_OFF(1)	/* save prev r1 (now free) */

	st	r31,  r30,  GENREG_OFF(31)	/* save previous r31 */
	or	r31,  r0,   r30			/* make r31 our pointer. */
	addu	r30,  r30,  TRAPFRAME_SIZEOF	/* r30 now has previous SR3 */
	st	r30,  r31,  EF_SR3		/* save previous SR3 */
d935 1
a935 1
	 xcr	r30,  r30,  SR3			/* restore r30 */
d941 10
a950 10
	ldcr	r1,   CPU
	ld	r1,   r1,   CI_CURPCB
	addu	r1,   r1,   USPACE - TRAPFRAME_SIZEOF
	st	FLAGS,r1,   EF_FLAGS		/* store flags */
	st	r31,  r1,   GENREG_OFF(31)	/* store r31 - now free */
	st	r30,  r1,   EF_SR3		/* store old SR3 (pcb) */
	or	r31,  r1,   r0			/* make r31 our exception fp */
	ld	r1,   r30,  GENREG_OFF(0)	/* restore old r1 */
	st	r0,   r30,  GENREG_OFF(0)	/* repair that frame */
	st	r1,   r31,  GENREG_OFF(1)	/* store r1 */
d952 1
a952 1
	 xcr	r30,  r30,  SR3			/* restore r30 */
d966 1
a966 1
	stcr	r31,  SR3	/* save previous r31 */
d969 3
a971 3
	ldcr	r31,  CPU
	ld	r31,  r31,  CI_CURPCB
	addu	r31,  r31,  PCB_USER_STATE	/* point to user save area */
d980 4
a983 4
	st	FLAGS,r31,  EF_FLAGS		/* save flags */
	st	r1,   r31,  GENREG_OFF(1)	/* save prev. r1 (now free) */
	ldcr	r1,   SR3			/* save previous r31 */
	st	r1,   r31,  GENREG_OFF(31)
d1003 2
a1004 2
	SAVE_TMP2(r31)
	SAVE_TMP3(r31)
d1008 1
a1008 1
	st	TMP,  r31,  EF_EPSR
d1010 1
a1010 1
	st	TMP3, r31,  EF_SNIP
d1012 1
a1012 1
	st	TMP2, r31,  EF_SFIP
d1015 1
a1015 1
	st	TMP,  r31,  EF_CPU
d1028 1
a1028 1
	st	TMP2, r31,  EF_SXIP
d1038 1
a1038 1
	 st	TMP3, r31,  EF_DMT0
d1042 2
a1043 2
	st	TMP2, r31,  EF_DMT1
	st	TMP3, r31,  EF_DMT2
d1047 2
a1048 2
	st	TMP2, r31,  EF_DMA0
	st	TMP3, r31,  EF_DMA1
d1052 2
a1053 2
	st	TMP2, r31,  EF_DMA2
	st	TMP3, r31,  EF_DMD0
d1058 2
a1059 2
	st	TMP2, r31,  EF_DMD1
	st	TMP3, r31,  EF_DMD2
d1069 1
a1069 1
	 stcr	r0,   DMT0
d1119 2
a1120 2
	ldcr	r1,   SR2
	jmp	r1	/* allow the handler to clear more SSBR bits */
d1134 2
a1135 2
	st	TMP2, r31,  EF_FPSR
	st	TMP3, r31,  EF_FPCR
d1139 2
a1140 2
	st	TMP2, r31,  EF_FPECR
	st	TMP3, r31,  EF_FPRH
d1144 2
a1145 2
	st	TMP2, r31,  EF_FPIT
	st	TMP3, r31,  EF_FPRL
d1157 1
a1157 1
	jmp	r1
d1172 2
a1173 2
	st	TMP2, r31,  EF_FPSR
	st	TMP3, r31,  EF_FPCR
d1176 1
a1176 1
	st	TMP3, r31,  EF_FPECR
d1179 2
a1180 2
	st	TMP2, r31,  EF_FPHS1
	st	TMP3, r31,  EF_FPHS2
d1184 2
a1185 2
	st	TMP2, r31,  EF_FPLS1
	st	TMP3, r31,  EF_FPLS2
d1188 1
a1188 1
	st	TMP2, r31,  EF_FPPT
d1198 1
a1198 1
	jmp.n	r1
d1237 1
a1237 1
	ld.usr	TMP2,TMP2, r0	/* get the instruction itself */
d1244 1
a1244 1
	 ld.usr	TMP2,TMP2, r0	/* get the instruction itself */
d1248 1
a1248 1
	ld	TMP2, TMP2, r0	/* get the instruction itself */
d1271 1
a1271 1
	mask	TMP3, TMP3, 0xFC00	/* apply the mask */
d1278 2
a1279 2
	mask	TMP3, TMP3, 0xFC00	/* apply the mask */
	cmp	TMP3, TMP3, 0xF400	/* if equal, might be a load double */
d1284 1
a1284 1
	mask	TMP3, TMP3, 0xFCE0	/* apply the mask */
d1297 1
a1297 1
	jmp.n	r1
d1327 2
a1328 2
	RESTORE_TMP2(r31)	/* done with extra temp regs */
	RESTORE_TMP3(r31)	/* done with extra temp regs */
d1332 2
a1333 2
	clr	TMP,  TMP,  1<PSR_FPU_DISABLE_BIT>	/* enable the FPU */
	clr	TMP,  TMP,  1<PSR_SHADOW_FREEZE_BIT>	/* and shadowing */
d1337 2
a1338 2
	or.u	TMP,  r0,   hi16(_ASM_LABEL(m88100_fpu_enable) + 2)
	or	TMP,  TMP,  lo16(_ASM_LABEL(m88100_fpu_enable) + 2)
d1340 1
a1340 1
	addu	TMP,  TMP,  4
d1345 2
a1346 2
	st	r1,   r31,  EF_RET		/* save the return address */
	ld	r1,   r31,  GENREG_OFF(1)	/* get original r1 */
d1348 2
a1349 2
	xcr	TMP,  r31,  SR3	/* TMP now restored. R31 now saved in SR3 */
	ld	r31,  r31,  GENREG_OFF(31)	/* get original r31 */
d1379 4
a1382 4
	st	r30,  TMP,  GENREG_OFF(30)	/* save previous r30, r31 */
	st	r31,  TMP,  GENREG_OFF(31)	/* save previous r30, r31 */
	or	r31,  TMP,  r0			/* transfer E.F. pointer to r31 */
	ld	TMP,  r31,  EF_SR3		/* get previous SR3 */
d1392 30
a1421 30
	st	r0 ,  r31,  GENREG_OFF(0)
	st	r1 ,  r31,  GENREG_OFF(1)
	st	r2 ,  r31,  GENREG_OFF(2)
	st	r3 ,  r31,  GENREG_OFF(3)
	st	r4 ,  r31,  GENREG_OFF(4)
	st	r5 ,  r31,  GENREG_OFF(5)
	st	r6 ,  r31,  GENREG_OFF(6)
	st	r7 ,  r31,  GENREG_OFF(7)
	st	r8 ,  r31,  GENREG_OFF(8)
	st	r9 ,  r31,  GENREG_OFF(9)
	st	r10,  r31,  GENREG_OFF(10)
	st	r11,  r31,  GENREG_OFF(11)
	st	r12,  r31,  GENREG_OFF(12)
	st	r13,  r31,  GENREG_OFF(13)
	st	r14,  r31,  GENREG_OFF(14)
	st	r15,  r31,  GENREG_OFF(15)
	st	r16,  r31,  GENREG_OFF(16)
	st	r17,  r31,  GENREG_OFF(17)
	st	r18,  r31,  GENREG_OFF(18)
	st	r19,  r31,  GENREG_OFF(19)
	st	r20,  r31,  GENREG_OFF(20)
	st	r21,  r31,  GENREG_OFF(21)
	st	r22,  r31,  GENREG_OFF(22)
	st	r23,  r31,  GENREG_OFF(23)
	st	r24,  r31,  GENREG_OFF(24)
	st	r25,  r31,  GENREG_OFF(25)
	st	r26,  r31,  GENREG_OFF(26)
	st	r27,  r31,  GENREG_OFF(27)
	st	r28,  r31,  GENREG_OFF(28)
	st	r29,  r31,  GENREG_OFF(29)
d1454 7
a1460 7
	or	r30,  r0,   r31		/* get a copy of the e.f. pointer */
	ld	r6,   r31,  EF_EPSR
	bb1	PSR_SUPERVISOR_MODE_BIT, r6, 1f	/* if in kernel mode */

	ldcr	r31,  CPU
	ld	r31,  r31,  CI_CURPCB
	addu	r31,  r31,  USPACE	/* point at proper end */
d1465 1
a1465 1
	st	r2, r30, EF_MASK
d1471 2
a1472 2
	subu	r31,  r31,  8	/* make some breathing space */
	st	r30,  r31,  0	/* store frame pointer on the stack */
d1474 1
a1474 1
	st	r30,  r31,  4	/* store it for the debugger to recognize */
d1477 4
a1480 4
	ld	r6,   r30,  EF_EPSR
	ld	r2,   r30,  EF_VECTOR
	bcnd.n	eq0,  r2,   8f			/* error exception */
	 ld	r14,  r30,  EF_RET
d1486 2
a1487 2
	cmp	r3,   r2,   1			/* is an interrupt? */
	bb1.n	eq,   r3,   8f			/* skip if so */
d1490 4
a1493 4
	 cmp	r3,   r2,   130	/* DDB break exception */
	bb1.n	eq,   r3,   8f
	 cmp	r3,   r2,   132	/* DDB entry exception */
	bb1	eq,   r3,   8f
d1500 2
a1501 2
	bb1.n	PSR_INTERRUPT_DISABLE_BIT, r6, 7f
	 ld	r3,   r30,  EF_DMT0
d1503 3
a1505 3
	ldcr	r2,   PSR
	clr	r2,   r2,   1<PSR_INTERRUPT_DISABLE_BIT>
	stcr	r2,   PSR
d1509 1
a1509 1
	bb0	DMT_VALID_BIT, r3, 8f
d1515 3
a1517 3
	or	r15,  r0,   r30
	CALL(m88100_trap, T_DATAFLT, r15)
	or	r30,  r0,   r15
d1520 1
a1520 1
	jmp	r14	/* loaded above */
d1531 2
a1532 2
	or	r2, r0, T_UNKNOWNFLT
	or	r3, r0, r30
d1538 1
a1538 1
	or	r2, r0, r30
d1544 2
a1545 2
	or	r2, r0, T_INSTFLT
	or	r3, r0, r30
d1553 2
a1554 2
	or	r2, r0, T_DATAFLT
	or	r3, r0, r30
d1558 2
a1559 2
	or	r2, r0, T_DATAFLT
	or	r3, r0, r30
d1565 2
a1566 2
	or	r2, r0, T_MISALGNFLT
	or	r3, r0, r30
d1572 2
a1573 2
	or	r2, r0, T_ILLFLT
	or	r3, r0, r30
d1579 2
a1580 2
	or	r2, r0, T_PRIVINFLT
	or	r3, r0, r30
d1586 2
a1587 2
	or	r2, r0, T_BNDFLT
	or	r3, r0, r30
d1593 2
a1594 2
	or	r2, r0, T_ZERODIV
	or	r3, r0, r30
d1600 2
a1601 2
	or	r2, r0, T_OVFFLT
	or	r3, r0, r30
d1607 2
a1608 2
	or	r2, r0, T_FPEPFLT
	or	r3, r0, r30
d1614 1
a1614 1
	or	r2, r0, r30
d1620 2
a1621 2
	or	r2, r0, T_110_DRM
	or	r3, r0, r30
d1627 2
a1628 2
	or	r2, r0, T_110_DWM
	or	r3, r0, r30
d1634 2
a1635 2
	or	r2, r0, T_110_IAM
	or	r3, r0, r30
d1641 2
a1642 2
	ld	r2, r30, GENREG_OFF(13)
	or	r3, r0, r30
d1648 1
a1648 1
	or	r2, r0, r30
d1653 2
a1654 2
	or	r2, r0, T_SIGSYS
	or	r3, r0, r30
d1659 2
a1660 2
	or	r2, r0, T_STEPBPT
	or	r3, r0, r30
d1665 2
a1666 2
	or	r2, r0, T_USERBPT
	or	r3, r0, r30
d1672 2
a1673 2
	or	r2, r0, T_KDB_BREAK
	or	r3, r0, r30
d1678 2
a1679 2
	or	r2, r0, T_KDB_TRACE
	or	r3, r0, r30
d1684 2
a1685 2
	or	r2, r0, T_KDB_ENTRY
	or	r3, r0, r30
d1709 1
a1709 1
	or	r29, r0, 10
d1712 1
a1712 1
	or	r29, r0, 0
d1714 3
a1716 3
	or	r26, r0, r31	/* save old stack */
	or.u	r31, r0,  hi16(_ASM_LABEL(initstack_end))
	or	r31, r31, lo16(_ASM_LABEL(initstack_end))
d1720 6
a1725 6
	or.u	r27, r0,  hi16(_ASM_LABEL(initstack))
	or	r27, r27, lo16(_ASM_LABEL(initstack))
1:	cmp	r28, r27, r31
	bb1	ge,  r28, 2f	/* branch if at the end of the stack */
	st	r0,  r0,  r27
	addu	r27, r27, 4	/* bump up */
d1731 1
a1731 1
	clr	r31, r31, 3<0>	/* round down to 8-byte boundary */
d1734 1
a1734 1
	subu	r31, r31, TRAPFRAME_SIZEOF	/* r31 now our E.F. */
d1737 15
a1751 15
	st.d	r0 , r31, GENREG_OFF(0)
	st.d	r2 , r31, GENREG_OFF(2)
	st.d	r4 , r31, GENREG_OFF(4)
	st.d	r6 , r31, GENREG_OFF(6)
	st.d	r8 , r31, GENREG_OFF(8)
	st.d	r10, r31, GENREG_OFF(10)
	st.d	r12, r31, GENREG_OFF(12)
	st.d	r14, r31, GENREG_OFF(14)
	st.d	r16, r31, GENREG_OFF(16)
	st.d	r18, r31, GENREG_OFF(18)
	st.d	r20, r31, GENREG_OFF(20)
	st.d	r22, r31, GENREG_OFF(22)
	st.d	r24, r31, GENREG_OFF(24)
	st	r30, r31, GENREG_OFF(30)
	st	r26, r31, GENREG_OFF(31)
d1754 1
a1754 1
	st	r29, r31, EF_VECTOR
d1757 20
a1776 20
	ldcr	r10, EPSR
	st	r10, r31, EF_EPSR
	ldcr	r10, EXIP
	st	r10, r31, EF_EXIP
	ldcr	r10, ENIP
	st	r10, r31, EF_ENIP
	ldcr	r10, DSR
	st	r10, r31, EF_DSR
	ldcr	r10, DLAR
	st	r10, r31, EF_DLAR
	ldcr	r10, DPAR
	st	r10, r31, EF_DPAR
	ldcr	r10, ISR
	st	r10, r31, EF_ISR
	ldcr	r10, ILAR
	st	r10, r31, EF_ILAR
	ldcr	r10, IPAR
	st	r10, r31, EF_IPAR
	ldcr	r10, SR1
	st	r10, r31, EF_FLAGS
d1779 2
a1780 2
	ldcr	r10, SR2
	st	r10, r31, EF_FPLS1
d1783 2
a1784 2
	ldcr	r10, SR3
	st	r10, r31, EF_FPHS2
d1789 4
a1792 4
	ldcr	r10, PSR
	clr	r10, r10, 1<PSR_FPU_DISABLE_BIT>	/* enable the FPU */
	clr	r10, r10, 1<PSR_SHADOW_FREEZE_BIT>	/* and shadowing */
	stcr	r10, PSR
d1796 1
a1796 1
	or	r30, r31, r0
d1798 2
a1799 2
	subu	r31, r31, 0x10	/* make some breathing space */
	st	r30, r31, 0x0c	/* store frame pointer on the stack */
d1801 5
a1805 5
	st	r30, r31, 0x08	/* store again for the debugger to recognize */
	or.u	r20,  r0, hi16(0x87654321)
	or	r20, r20, lo16(0x87654321)
	st	r20, r31, 0x04
	st	r20, r31, 0x00
d1808 1
a1808 1
	or	r2, r0, r30
d1812 3
a1814 3
	ldcr	r1, PSR
	clr	r1, r1, 1<PSR_INTERRUPT_DISABLE_BIT>
	stcr	r1, PSR
d1852 1
a1852 1
	xcr	r1,   r1,   SR2		/* recover exception-time r1 */
d1875 4
a1878 4
	stcr	r30,  SR3			/* save r30, now free */
	ldcr	r30,  CPU
	ld	r30,  r30,  CI_CURPCB
	addu	r30,  r30,  PCB_USER_STATE	/* point to user save area */
d1881 4
a1884 4
	st	r1,   r30,  GENREG_OFF(1)	/* save prev. r1 (now free)*/
	ldcr	r1,   SR3			/* save previous r30 */
	st	r31,  r30,  GENREG_OFF(31)
	st	r1,   r30,  GENREG_OFF(30)
d1887 3
a1889 3
	ldcr	r1,   CPU
	ld	r31,  r1,   CI_CURPCB
	addu	r31,  r31,  USPACE
d1896 1
a1896 1
	subu	r31,  r31,  TRAPFRAME_SIZEOF	/* r31 now our E.F. */
d1899 4
a1902 4
	st	r1,   r31,  GENREG_OFF(1)	/* save prev. r1 (now free) */
	addu	r1,   r31,  TRAPFRAME_SIZEOF	/* save previous r31 */
	st	r30,  r31,  GENREG_OFF(30)
	st	r1,   r31,  GENREG_OFF(31)
d1905 1
a1905 1
	or	r30,  r31,  r0
d1923 2
a1924 2
	SAVE_TMP2(r30)
	SAVE_TMP3(r30)
d1927 1
a1927 1
	st	FLAGS,r30,  EF_FLAGS		/* save flags */
d1930 1
a1930 1
	st	TMP,  r30,  EF_EPSR
d1933 2
a1934 2
	st	TMP2, r30,  EF_EXIP
	st	TMP3, r30,  EF_ENIP
d1938 1
a1938 1
	st	TMP,  r30,  EF_CPU
d1944 1
a1944 1
	st	TMP,  r30,  EF_ISR
d1948 2
a1949 2
	st	TMP2, r30,  EF_ILAR
	st	TMP3, r30,  EF_IPAR
d1952 3
a1954 3
	st	TMP,  r30,  EF_ISAP
	st	TMP2, r30,  EF_IUAP
	stcr	r0,   ISR
d1957 1
a1957 1
	st	TMP,  r30,  EF_DSR
d1961 2
a1962 2
	st	TMP2, r30,  EF_DLAR
	st	TMP3, r30,  EF_DPAR
d1965 3
a1967 3
	st	TMP,  r30,  EF_DSAP
	st	TMP2, r30,  EF_DUAP
	stcr	r0,   DSR
d1969 2
a1970 2
	ldcr	r1,   SR2
	jmp	r1
d1993 2
a1994 2
	RESTORE_TMP2(r30)	/* done with extra temp regs */
	RESTORE_TMP3(r30)	/* done with extra temp regs */
d2000 2
a2001 2
	or.u	TMP,  r0,   hi16(_ASM_LABEL(m88110_shadow_enable))
	or	TMP,  TMP,  lo16(_ASM_LABEL(m88110_shadow_enable))
d2004 2
a2005 2
	xcr	FLAGS, FLAGS, SR1
	st	r1,   r30,  EF_RET		/* save the return address */
d2007 1
a2007 1
	xcr	TMP,  r31, SR3	/* TMP now restored. R31 now saved in SR3 */
d2035 29
a2063 29
	st	r0 ,  r30,  GENREG_OFF(0)
	st	r2 ,  r30,  GENREG_OFF(2)
	st	r3 ,  r30,  GENREG_OFF(3)
	st	r4 ,  r30,  GENREG_OFF(4)
	st	r5 ,  r30,  GENREG_OFF(5)
	st	r6 ,  r30,  GENREG_OFF(6)
	st	r7 ,  r30,  GENREG_OFF(7)
	st	r8 ,  r30,  GENREG_OFF(8)
	st	r9 ,  r30,  GENREG_OFF(9)
	st	r10,  r30,  GENREG_OFF(10)
	st	r11,  r30,  GENREG_OFF(11)
	st	r12,  r30,  GENREG_OFF(12)
	st	r13,  r30,  GENREG_OFF(13)
	st	r14,  r30,  GENREG_OFF(14)
	st	r15,  r30,  GENREG_OFF(15)
	st	r16,  r30,  GENREG_OFF(16)
	st	r17,  r30,  GENREG_OFF(17)
	st	r18,  r30,  GENREG_OFF(18)
	st	r19,  r30,  GENREG_OFF(19)
	st	r20,  r30,  GENREG_OFF(20)
	st	r21,  r30,  GENREG_OFF(21)
	st	r22,  r30,  GENREG_OFF(22)
	st	r23,  r30,  GENREG_OFF(23)
	st	r24,  r30,  GENREG_OFF(24)
	st	r25,  r30,  GENREG_OFF(25)
	st	r26,  r30,  GENREG_OFF(26)
	st	r27,  r30,  GENREG_OFF(27)
	st	r28,  r30,  GENREG_OFF(28)
	st	r29,  r30,  GENREG_OFF(29)
d2089 1
a2089 1
	st	r2,   r30,  EF_MASK
d2091 2
a2092 2
	subu	r31,  r31,  8	/* make some breathing space */
	st	r30,  r31,  0	/* store frame pointer on the stack */
d2094 1
a2094 1
	st	r30,  r31,  4	/* store it again for the debugger */
d2097 2
a2098 2
	ld	r6,   r30,  EF_EPSR
	ld	r14,  r30,  EF_RET
d2102 1
a2102 1
	bb1	PSR_INTERRUPT_DISABLE_BIT, r6, 8f
d2104 6
a2109 6
	ld	r2,   r30,  EF_VECTOR
	bcnd	eq0,  r2,   8f
	cmp	r3,   r2,   1	/* is this an interrupt? */
	bb1	eq,   r3,   8f
	cmp	r3,   r2,   11	/* or NMI? */
	bb1	eq,   r3,   8f
d2112 4
a2115 4
	cmp	r3,   r2,   130	/* DDB break exception */
	bb1	eq,   r3,   8f
	cmp	r3,   r2,   132	/* DDB entry exception */
	bb1	eq,   r3,   8f
d2118 3
a2120 3
	ldcr	r2,   PSR
	clr	r2,   r2,   1<PSR_INTERRUPT_DISABLE_BIT>
	stcr	r2,   PSR
d2124 1
a2124 1
	jmp	r14		/* loaded above */
d2127 1
a2127 1
	text
d2129 1
a2129 1
#define	FPTR	r14
d2142 1
a2142 1
	ld	FPTR, r31, 0	/* grab exception frame pointer */
d2150 2
a2151 2
	ld	r2, FPTR, EF_EPSR
	bb1	PSR_INTERRUPT_DISABLE_BIT, r2, _ASM_LABEL(ast_done)
d2153 2
a2154 2
	ld	r2, FPTR, EF_MASK
	bcnd	ne0, r2, _ASM_LABEL(ast_done)
d2160 5
a2164 5
	ldcr	r3,   CPU
	or	r15,  r0,   r0
	addu	r3,   r3,   CI_SOFTIPI_CB
	xmem	r15,  r3,   r0
	bcnd	eq0,  r15,   _ASM_LABEL(do_softint)
d2167 1
a2167 1
	 or	r2,   r0,   IPL_NONE
d2169 1
a2169 1
	jsr	r15
d2179 2
a2180 2
	ld	r2, FPTR, EF_EPSR
	bb1	PSR_SUPERVISOR_MODE_BIT, r2, _ASM_LABEL(ast_done)
d2182 4
a2185 4
	ldcr	r2,  CPU
	ld	r3,  r2, CI_CURPROC
	ld	r2,  r3, P_ASTPENDING
	bcnd	eq0, r2, _ASM_LABEL(ast_done)
d2188 1
a2188 1
	 or	r2, r0, FPTR
d2207 1
a2207 1
	 or	r2,  r0,  r0
d2209 4
a2212 4
	ld	r1,  r31, 0		/* load func */
	ld	r2,  r31, 4 		/* load arg */
	jsr.n	r1
	 addu	r31, r31, 8		/* release ksigframe */
d2220 2
a2221 2
	ldcr	r3,  CPU
	ld	r2,  r3,  CI_CURPROC
d2223 1
a2223 1
	ld	FPTR, r2,   P_ADDR		/* p->p_addr */
d2230 3
a2232 3
	ldcr	r1, PSR
	set	r1, r1, 1<PSR_INTERRUPT_DISABLE_BIT>
	stcr	r1, PSR
d2237 1
a2237 1
	 ld	r2, FPTR, EF_MASK		/* get pre-exception ipl */
d2240 3
a2242 3
	ldcr	r2, PID
	extu	r3,  r2, 8<8>
	bcnd	ne0, r3, _ASM_LABEL(m88110_user_rte)
d2252 2
a2253 1
	or	r31, r0,  FPTR
d2255 28
a2282 28
	ld	r2 , r31, GENREG_OFF(2)
	ld	r3 , r31, GENREG_OFF(3)
	ld	r4 , r31, GENREG_OFF(4)
	ld	r5 , r31, GENREG_OFF(5)
	ld	r6 , r31, GENREG_OFF(6)
	ld	r7 , r31, GENREG_OFF(7)
	ld	r8 , r31, GENREG_OFF(8)
	ld	r9 , r31, GENREG_OFF(9)
	ld	r10, r31, GENREG_OFF(10)
	ld	r11, r31, GENREG_OFF(11)
	ld	r12, r31, GENREG_OFF(12)
	ld	r13, r31, GENREG_OFF(13)
	ld	r14, r31, GENREG_OFF(14)
	ld	r15, r31, GENREG_OFF(15)
	ld	r16, r31, GENREG_OFF(16)
	ld	r17, r31, GENREG_OFF(17)
	ld	r18, r31, GENREG_OFF(18)
	ld	r19, r31, GENREG_OFF(19)
	ld	r20, r31, GENREG_OFF(20)
	ld	r21, r31, GENREG_OFF(21)
	ld	r22, r31, GENREG_OFF(22)
	ld	r23, r31, GENREG_OFF(23)
	ld	r24, r31, GENREG_OFF(24)
	ld	r25, r31, GENREG_OFF(25)
	ld	r26, r31, GENREG_OFF(26)
	ld	r27, r31, GENREG_OFF(27)
	ld	r28, r31, GENREG_OFF(28)
	ld	r29, r31, GENREG_OFF(29)
d2286 3
a2288 3
	ldcr	r1, PSR
	set	r1, r1, 1<PSR_SHADOW_FREEZE_BIT>
	stcr	r1, PSR
d2297 5
a2301 5
	stcr	r0,  SSBR
	ld	r30, r31, EF_SNIP
	ld	r1,  r31, EF_SFIP
	stcr	r30, SNIP
	stcr	r1,  SFIP
d2303 2
a2304 2
	ld	r30, r31, EF_EPSR
	stcr	r30, EPSR
d2307 3
a2309 3
	ld	r1,  r31, GENREG_OFF(1)
	ld	r30, r31, GENREG_OFF(30)
	ld	r31, r31, GENREG_OFF(31)
d2322 3
a2324 3
	ldcr	r1, PSR
	set	r1, r1, 1<PSR_SHADOW_FREEZE_BIT>
	stcr	r1, PSR
d2332 1
a2332 1
	or	r31, r0,  FPTR
d2334 28
a2361 28
	ld	r2 , r31, GENREG_OFF(2)
	ld	r3 , r31, GENREG_OFF(3)
	ld	r4 , r31, GENREG_OFF(4)
	ld	r5 , r31, GENREG_OFF(5)
	ld	r6 , r31, GENREG_OFF(6)
	ld	r7 , r31, GENREG_OFF(7)
	ld	r8 , r31, GENREG_OFF(8)
	ld	r9 , r31, GENREG_OFF(9)
	ld	r10, r31, GENREG_OFF(10)
	ld	r11, r31, GENREG_OFF(11)
	ld	r12, r31, GENREG_OFF(12)
	ld	r13, r31, GENREG_OFF(13)
	ld	r14, r31, GENREG_OFF(14)
	ld	r15, r31, GENREG_OFF(15)
	ld	r16, r31, GENREG_OFF(16)
	ld	r17, r31, GENREG_OFF(17)
	ld	r18, r31, GENREG_OFF(18)
	ld	r19, r31, GENREG_OFF(19)
	ld	r20, r31, GENREG_OFF(20)
	ld	r21, r31, GENREG_OFF(21)
	ld	r22, r31, GENREG_OFF(22)
	ld	r23, r31, GENREG_OFF(23)
	ld	r24, r31, GENREG_OFF(24)
	ld	r25, r31, GENREG_OFF(25)
	ld	r26, r31, GENREG_OFF(26)
	ld	r27, r31, GENREG_OFF(27)
	ld	r28, r31, GENREG_OFF(28)
	ld	r29, r31, GENREG_OFF(29)
d2365 4
a2368 4
	ld	r30, r31, EF_ENIP
	ld	r1,  r31, EF_EXIP
	stcr	r30, ENIP
	stcr	r1,  EXIP
d2370 2
a2371 2
	ld	r30, r31, EF_EPSR
	stcr	r30, EPSR
d2374 3
a2376 3
	ld	r1,  r31, GENREG_OFF(1)
	ld	r30, r31, GENREG_OFF(30)
	ld	r31, r31, GENREG_OFF(31)
d2391 1
a2391 1
	align 64	/* 32 might not be enough */
d2402 1
a2402 1
	bcnd	ne0, r2, _ASM_LABEL(check_ast)
d2404 1
a2404 1
	ld	FPTR, r31, 0	/* grab exception frame pointer */
d2412 4
a2415 4
	ldcr	r1, PSR
	set	r1, r1, 1<PSR_INTERRUPT_DISABLE_BIT>
	set	r1, r1, 1<PSR_SHADOW_FREEZE_BIT>
	stcr	r1, PSR
d2420 1
a2420 1
	 ld	r2, FPTR, EF_MASK		/* get pre-exception ipl */
d2426 1
a2426 1
	or	r2,   FPTR,  r0
@


1.55
log
@The exception vector page on m88k systems has always been the same page as
the one used by the firmware, which (at least on mvme88k) is at address zero.

This is unfortunate, since this means that NULL pointer dereferences in the
kernel are not caught, and writes cause havoc.

This behaviour was necessary to be able to use the PROM system call interface
during early bootstrap, without having to disassemble the VBR page and
update branches - which use pc-relative displacement - if we were to use
a different VBR address.

On mvme88k, change this and actually set up two VBR pages: one, over the PROM
page (except for the system call vectors), and another one in the kernel
image (which will be mapped read-only). We'll run with the PROM page until
the end of autoconf, and then switch to the kernel one, and unmap all the
PROM below it.

As a bonus, the final kernel page can use optimized data access fault
handlers, which do not have to check for faults caused by badaddr(), since
badaddr() is only used during device probe on buses which do not support
hotplug.

There are a few infrastructure collateral damage on aviion and luna88k, but
these ports do not change their behaviour yet.
@
text
@d1 1
a1 1
/*   $OpenBSD: eh_common.S,v 1.54 2009/03/15 20:39:53 miod Exp $	*/
d1494 2
@


1.54
log
@Generic softinterrupt support for m88k based platforms, adapted from arm
with different locking mechanism. 88110 soft ipi are replaced with an
ipi callback which is checked upon return from exception (it can not be kept
as a softintr, as the generic softinterrupt code doesn't have per-cpu
pending softintr queues).
@
text
@d1 1
a1 1
/*   $OpenBSD: eh_common.S,v 1.53 2009/03/01 17:43:25 miod Exp $	*/
d389 4
d394 1
a394 1
	PREP88100("data", 3,, M88100_Data_Precheck)
d730 1
a730 1
 * extern boolean_t badaddr(vaddr_t addr, u_int len)
a770 1
	FLUSH_PIPELINE
d786 1
d1549 5
d1555 1
a1555 1
	PREP88110("data", 3, M88110_Data_Precheck)
@


1.53
log
@Files forgotten during last commit:

Rework nmi handling to handle ``complex'' NMI faster, and return as fast as
possible from the exception, without doing the AST and softintr dance.

This should avoid too much stack usage under load.

ok deraadt@@
@
text
@d1 1
a1 1
/*   $OpenBSD: eh_common.S,v 1.52 2009/02/21 18:35:22 miod Exp $	*/
d2134 1
a2134 1
	 * If the saved ipl is 0, then call dosoftint() to process soft
d2145 9
a2153 4
	/* save us the setipl calls if no pending software interrupts */
	ldcr	r3,  CPU
	ld	r2,   r3, CI_SOFTINTR
	bcnd	eq0,  r2, _ASM_LABEL(softint_done)
d2156 10
a2165 4
	 or	r2, r0, IPL_SOFTCLOCK
	bsr	_C_LABEL(dosoftint)
	bsr.n	_C_LABEL(setipl)
	 or	r2, r0, IPL_NONE
a2166 1
ASGLOBAL(softint_done)
d2170 1
a2170 1

d2176 4
a2179 2
	or	r2, r0, FPTR
	XCALL(_C_LABEL(ast), _ASM_LABEL(ast_done))
@


1.52
log
@Get rid of 88110 nmi stacks. This was a good idea, but I outsmarted myself
since it was intended to service NMI occuring in user mode, and we could
end up invoking preempt() and have another cpu start using this stack,
with interesting results.
@
text
@d1 1
a1 1
/*   $OpenBSD: eh_common.S,v 1.51 2009/02/16 22:55:03 miod Exp $	*/
d1604 1
a1604 1
	XCALL(_C_LABEL(nmi), _ASM_LABEL(check_ast))
d2216 6
a2221 10
	/*
	 * Disable shadowing. This used to be done after all the registers
	 * from the E.F. have been restored, but on 88110 we may receive
	 * an NMI anytime, unless shadowing is frozen, and we rely on r31
	 * being valid.
	 */
	ldcr	r1, PSR
	set	r1, r1, 1<PSR_SHADOW_FREEZE_BIT>
	stcr	r1, PSR
	FLUSH_PIPELINE
d2223 2
d2261 6
a2267 9
#if defined(M88100) && defined(M88110)
	ldcr	r1, PID
	extu	r30, r1, 8<8>
	bcnd	ne0, r30, _ASM_LABEL(m88110_user_rte)
	/* FALLTHROUGH */
#endif

#ifdef M88100
ASGLOBAL(m88100_user_rte)
d2292 49
d2371 36
@


1.51
log
@Since NMI are now handled separately, remove the ``interrupt type'' argument
from interrupt() and related function pointers.
@
text
@d1 1
a1 1
/*   $OpenBSD: eh_common.S,v 1.50 2009/02/16 20:18:48 miod Exp $	*/
a224 2
 * The bit FLAG_NMI_STACK, on 88110, indicates that this exception
 *	should be handled on the NMI stack.
a228 1
#define	FLAG_NMI_STACK			3
a331 1
	clr	FLAGS, FLAGS, 1<FLAG_NMI_STACK>		; \
a358 2
#define	M88110_Set_NMI_Flag \
	set	FLAGS, FLAGS, 1<FLAG_NMI_STACK>
d1602 1
a1602 1
	PREP88110("NMI", 11, M88110_Set_NMI_Flag)
d1849 6
d1859 2
a1860 9
	 * If this is an NMI, pick the NMI stack, and build the frame
	 * in it.
	 */
	bb1	FLAG_NMI_STACK, FLAGS, _ASM_LABEL(m88110_nmi_stack)

	/*
	 * Otherwise, this is a normal exception in user mode, we'll
	 * use the PCB for the exception frame and the top of the PCB
	 * as the stack.
d1882 1
a1882 22
ASLOCAL(m88110_nmi_stack)
	/* NMI exception in user mode */

	/* compute frame address: top of NMI stack */
	stcr	r30,  SR3			/* save r30, now free */
	ldcr	r30,  CPU
	ld	r30,  r30,  CI_NMI_STACK
	addu	r30,  r30,  (USPACE - TRAPFRAME_SIZEOF)

	/* save a few registers before we lose them */
	st	r1,   r30,  GENREG_OFF(1)	/* save prev. r1 (now free) */
	ldcr	r1,   SR3			/* save previous r30 */
	st	r31,  r30,  GENREG_OFF(31)
	st	r1,   r30,  GENREG_OFF(30)

	/* compute stack address: bottom of exception frame */
	or	r31,  r30,  r0

	br	_ASM_LABEL(m88110_have_stack)

ASLOCAL(m88110_kernel_stack)
	/* Exception in kernel mode */
@


1.50
log
@Rewrite the way the initial processing of exceptions is done on 88110 - we
now set up both the exception frame structure and the exception stack as
soon as possible, so that we can safely get interrupted by an NMI as soon
as we reenable shadowing.
@
text
@d1 1
a1 1
/*   $OpenBSD: eh_common.S,v 1.49 2009/02/15 22:25:49 miod Exp $	*/
d381 1
a381 2
	or	r2, r0, T_INT
	or	r3, r0, r30
d1538 1
a1538 2
	or	r2, r0, T_INT
	or	r3, r0, r30
@


1.49
log
@If we are on the NMI stack, do not switch to the curpcb stack moments later,
this defeats the purpose of having a separate stack at this point... Oopsie
@
text
@d1 1
a1 1
/*   $OpenBSD: eh_common.S,v 1.48 2009/02/13 23:33:51 miod Exp $	*/
d254 8
a261 8
#define	FLAGS		r2
#define	TMP		r3
#define	TMP2		r10
#define	TMP3		r11
#define	SAVE_TMP2	st	r10, r31, GENREG_OFF(10)
#define	SAVE_TMP3	st	r11, r31, GENREG_OFF(11)
#define	RESTORE_TMP2	ld	r10, r31, GENREG_OFF(10)
#define	RESTORE_TMP3	ld	r11, r31, GENREG_OFF(11)
d344 1
a344 1
	/* get a stack (exception frame) */		; \
d350 1
a350 1
	st	TMP2, r31, EF_VECTOR			; \
d363 1
a363 1
#define	M88110_NMI_Precheck \
d1006 2
a1007 2
	SAVE_TMP2
	SAVE_TMP3
d1117 1
a1117 1
	 *   Exception-time espr, sfip, snip, sxip.
d1317 1
a1317 1
	 *   Exception-time espr, sfip, snip, sxip.
d1330 2
a1331 2
	RESTORE_TMP2	/* done with extra temp regs */
	RESTORE_TMP3	/* done with extra temp regs */
d1362 1
a1362 1
	 *   Exception-time espr, sfip, snip, sxip.
d1437 1
a1437 1
	 *   Exception-time espr, sfip, snip, sxip.
d1480 1
d1496 1
a1496 1
	bb1.n	eq,   r3,   8f
d1501 2
a1502 1
	bb1	PSR_INTERRUPT_DISABLE_BIT, r6, 7f
d1504 1
a1504 1
	 ldcr	r2,   PSR
a1509 1
	ld	r3,   r30,  EF_DMT0
d1610 1
a1610 1
	PREP88110("NMI", 11, M88110_NMI_Precheck)
d1818 17
d1844 2
a1845 2
	 *   Decide where we're going to put the exception frame.
	 *   Might be at the end of R31, SR3, or the process pcb.
d1849 1
a1849 1
	xcr	r1,   r1,   SR2
d1856 1
a1856 1
	 * a valid stack. Keep using it.
d1860 4
a1863 1
	/* is this an NMI? If so, pick the NMI stack */
a1865 1
	/* Non-NMI exception in user mode */
d1867 16
a1882 9
	 * SR1: saved copy of exception-time register now holding FLAGS
	 * SR2: return address to the calling exception handler
	 * SR3: free
	 * FLAGS: CPU status flags
	 *
	 * immediate goal:
	 *   Pick the process PCB and point our stack to it.
	 */
	stcr	r31,  SR3	/* save previous r31 */
d1884 4
a1887 10
	/* switch to the process kernel stack. */
	ldcr	r31,  CPU
	ld	r31,  r31,  CI_CURPCB
	addu	r31,  r31,  PCB_USER_STATE	/* point to user save area */

	/*
	 * WARNING! Using pcb->user_state as the exception frame
	 * AND stack pointer, means we can not afford using the stack
	 * until we have saved enough and can go back to the top of the u area.
	 */
d1889 1
a1889 5
	st	FLAGS,r31,  EF_FLAGS		/* save flags */
	st	r1,   r31,  GENREG_OFF(1)	/* save prev. r1 (now free)*/
	ldcr	r1,   SR3			/* save previous r31 */
	st	r1,   r31,  GENREG_OFF(31)
	br	_ASM_LABEL(m88110_have_pcb)
a1892 10
	/*
	 * SR1: saved copy of exception-time register now holding FLAGS
	 * SR2: return address to the calling exception handler
	 * SR3: free
	 * FLAGS: CPU status flags
	 *
	 * immediate goal:
	 *   Pick the cpu NMI stack.
	 */
	stcr	r31,  SR3	/* save previous r31 */
d1894 14
a1907 3
	/* switch to the NMI stack */
	ldcr	r31,  CPU
	ld	r31,  r31,  CI_NMI_STACK
d1909 1
a1909 6
	addu	r31,  r31,  (USPACE - TRAPFRAME_SIZEOF)	/* r31 now our E.F. */
	st	FLAGS,r31,  EF_FLAGS		/* save flags */
	st	r1,   r31,  GENREG_OFF(1)	/* save prev. r1 (now free) */
	ldcr	r1,   SR3			/* save previous r31 */
	st	r1,   r31,  GENREG_OFF(31)
	br	_ASM_LABEL(m88110_have_pcb)
d1913 2
a1914 10
	/*
	 * SR1: saved copy of exception-time register now holding FLAGS
	 * SR2: return address to the calling exception handler
	 * SR3: free
	 * FLAGS: CPU status flags
	 *
	 * immediate goal:
	 *   We're already on the kernel stack.  We can just make room on the
	 *   stack (r31) for our exception frame.
	 */
d1916 2
a1917 1
	st	FLAGS,r31,  EF_FLAGS		/* save flags */
d1920 1
d1922 4
d1928 1
a1928 1
ASLOCAL(m88110_have_pcb)
d1935 2
a1936 1
	 * r31: our exception frame
d1938 1
a1938 2
	 *   Exception-time r1, r31, FLAGS.
	 *   Exception SR3, if appropriate.
d1942 2
a1943 2
	SAVE_TMP2
	SAVE_TMP3
d1946 2
d1949 1
a1949 1
	st	TMP,  r31,  EF_EPSR
d1952 2
a1953 2
	st	TMP2, r31,  EF_EXIP
	st	TMP3, r31,  EF_ENIP
d1957 1
a1957 1
	st	TMP,  r31,  EF_CPU
d1963 1
a1963 1
	st	TMP,  r31,  EF_ISR
d1967 2
a1968 2
	st	TMP2, r31,  EF_ILAR
	st	TMP3, r31,  EF_IPAR
d1971 2
a1972 2
	st	TMP,  r31,  EF_ISAP
	st	TMP2, r31,  EF_IUAP
d1976 1
a1976 1
	st	TMP,  r31,  EF_DSR
d1980 2
a1981 2
	st	TMP2, r31,  EF_DLAR
	st	TMP3, r31,  EF_DPAR
d1984 2
a1985 2
	st	TMP,  r31,  EF_DSAP
	st	TMP2, r31,  EF_DUAP
d2000 2
a2001 1
	 * r31: our exception frame
d2003 1
a2003 1
	 *   Exception-time r1, r31, FLAGS.
d2005 1
a2005 1
	 *   Exception-time espr, enip, exip.
d2009 1
a2009 2
	 *   restore the system to the exception-time state (except SR3 will
	 *   be OUR stack pointer).
d2012 2
a2013 2
	RESTORE_TMP2	/* done with extra temp regs */
	RESTORE_TMP3	/* done with extra temp regs */
d2016 1
a2016 1
	clr	TMP,  TMP,  1<PSR_SHADOW_FREEZE_BIT>	/* and shadowing */
d2024 1
a2024 2
	st	r1,   r31,  EF_RET		/* save the return address */
	ld	r1,   r31,  GENREG_OFF(1)	/* get original r1 */
a2026 1
	ld	r31,  r31,  GENREG_OFF(31)	/* get original r31 */
d2032 3
a2034 1
	 * r1 through r31: original exception-time values
d2037 2
a2038 2
	 *   Exception-time FLAGS.
	 *   Exception-time espr, sfip, enip, exip.
d2040 1
a2040 4
	 *   Dmt0
	 *   Other data pipeline control registers, if appropriate.
	 *   FPU control registers, if appropriate.
	 *   Exception SR3, if appropriate.
d2046 1
a2046 2
	 *   Another exception (or exceptions) may be raised in
	 *   this.
d2051 1
a2051 1
	FLUSH_PIPELINE
d2053 30
a2082 37
	xcr	TMP,  TMP,  SR3			/* get E.F. pointer */
	st	r30,  TMP,  GENREG_OFF(30)	/* save previous r30, r31 */
	st	r31,  TMP,  GENREG_OFF(31)	/* save previous r30, r31 */
	or	r31,  TMP,  r0			/* transfer E.F. pointer */
	xcr	TMP,  TMP,  SR3			/* replace TMP, SR3 */

	/* now save all regs to the exception frame. */
	st	r0 ,  r31,  GENREG_OFF(0)
	st	r1 ,  r31,  GENREG_OFF(1)
	st	r2 ,  r31,  GENREG_OFF(2)
	st	r3 ,  r31,  GENREG_OFF(3)
	st	r4 ,  r31,  GENREG_OFF(4)
	st	r5 ,  r31,  GENREG_OFF(5)
	st	r6 ,  r31,  GENREG_OFF(6)
	st	r7 ,  r31,  GENREG_OFF(7)
	st	r8 ,  r31,  GENREG_OFF(8)
	st	r9 ,  r31,  GENREG_OFF(9)
	st	r10,  r31,  GENREG_OFF(10)
	st	r11,  r31,  GENREG_OFF(11)
	st	r12,  r31,  GENREG_OFF(12)
	st	r13,  r31,  GENREG_OFF(13)
	st	r14,  r31,  GENREG_OFF(14)
	st	r15,  r31,  GENREG_OFF(15)
	st	r16,  r31,  GENREG_OFF(16)
	st	r17,  r31,  GENREG_OFF(17)
	st	r18,  r31,  GENREG_OFF(18)
	st	r19,  r31,  GENREG_OFF(19)
	st	r20,  r31,  GENREG_OFF(20)
	st	r21,  r31,  GENREG_OFF(21)
	st	r22,  r31,  GENREG_OFF(22)
	st	r23,  r31,  GENREG_OFF(23)
	st	r24,  r31,  GENREG_OFF(24)
	st	r25,  r31,  GENREG_OFF(25)
	st	r26,  r31,  GENREG_OFF(26)
	st	r27,  r31,  GENREG_OFF(27)
	st	r28,  r31,  GENREG_OFF(28)
	st	r29,  r31,  GENREG_OFF(29)
d2088 3
a2090 3
	 * r1: return address to the calling exception handler
	 * r2 through r30: free
	 * r31: our exception frame
d2095 1
a2095 1
	 *   Exception-time espr, enip, exip.
d2097 2
a2098 1
	 *   DSR/ISR
a2100 1
	 *   Put a copy of the exception frame pointer into r30
d2102 1
a2102 2
	 *   If not an interrupt exception, turn on interrupts and service any
	 *     outstanding data access exceptions.
a2105 16
	/*
	 * If it's not the interrupt exception, enable interrupts and
	 * take care of any data access exceptions......
	 */
	or	r30,  r0,   r31		/* get a copy of the e.f. pointer */
	ld	r6,   r31,  EF_EPSR
	bb1	PSR_SUPERVISOR_MODE_BIT, r6, 1f	/* if in kernel mode */
	ld	r5,   r31,  EF_VECTOR
	cmp	r4,   r5,   11		/* NMI */
	bb1	eq,   r4,   1f

	ldcr	r2,   CPU
	ld	r31,  r2,   CI_CURPCB
	addu	r31,  r31,  USPACE		/* point at proper end */
1:

d2108 1
a2108 1
	st	r2, r30, EF_MASK
a2109 4
	/*
	 * here - r30 holds a pointer to the exception frame.
	 * r31 is a pointer to the kernel stack/interrupt stack.
	 */
d2116 7
a2123 1
	ld	r14,  r30,  EF_RET
d2125 1
a2125 1
	cmp	r3,   r2,   1	/* is an interrupt? */
d2137 1
a2137 5
	/* turn interrupts back on unless they were not enabled when the
	   trap occured */
	bb1	PSR_INTERRUPT_DISABLE_BIT, r6, 8f

	 ldcr	r2,   PSR
d2247 11
a2291 6

	/* disable shadowing */
	ldcr	r1, PSR
	set	r1, r1, 1<PSR_SHADOW_FREEZE_BIT>
	stcr	r1, PSR
	FLUSH_PIPELINE
@


1.48
log
@Use a different dispatcher for the NMI traps on 88110, these are too
different from regular hardware interrupts to be worth handling the
same way.

Disable IPI reception while we are handling pending IPIs. And do not
reenable them by mistake if we need to send an IPI in return.

This lets GENERIC.MP boot single user on a MVME197DP. There are still
many bugs to fix.
@
text
@d1 1
a1 1
/*   $OpenBSD: eh_common.S,v 1.47 2009/02/08 21:40:58 miod Exp $	*/
d335 1
a1844 1
ASLOCAL(m88110_pickup_stack)
a1889 1
	addu	r31,  r31,  USPACE
d1891 1
a1891 1
	subu	r31,  r31,  TRAPFRAME_SIZEOF	/* r31 now our E.F. */
a1929 3
	/* make sure that the FLAG_NMI_STACK bit is off */
	clr	FLAGS, FLAGS, 1<FLAG_NMI_STACK>

d1960 1
a1960 1
	stcr	r0, ISR
d1973 1
a1973 1
	stcr	r0, DSR
d2112 3
d2116 2
a2117 2
	ldcr	r31,  CPU
	ld	r31,  r31,  CI_CURPCB
@


1.47
log
@On 88110 processors, use a separate stack to handle NMI; these can occur
while we are switching pcbs and all sort of bad things could happen.
@
text
@d1 1
a1 1
/*   $OpenBSD: eh_common.S,v 1.46 2008/07/28 17:49:38 miod Exp $	*/
d1609 2
a1610 3
	or	r2, r0, T_NON_MASK
	or	r3, r0, r30
	XCALL(_C_LABEL(interrupt), _ASM_LABEL(check_ast))
@


1.46
log
@According to the manual, delay slot kill the benefits of being superscalar,
so don't use any in the 88110-specific parts of locore.
@
text
@d1 1
a1 1
/*   $OpenBSD: eh_common.S,v 1.45 2007/12/25 00:29:49 miod Exp $	*/
d225 2
d231 1
d362 2
d1606 1
a1606 1
/* MVME197 non-maskable interrupt handler (ABORT button) */
d1608 1
a1608 1
	PREP88110("NMI", 11,)
d1821 1
a1821 1
	 * SR3: must be preserved .. may be the exception-time stack
a1835 4
	/* are we coming in from user mode? If so, pick up process pcb */
	bb0	FLAG_FROM_KERNEL, FLAGS, _ASM_LABEL(m88110_pickup_stack)

	/* Interrupt in kernel mode */
d1837 2
a1838 9
	 * SR1: saved copy of exception-time register now holding FLAGS
	 * SR2: return address to the calling exception handler
	 * SR3: must be preserved; may be important for other exceptions
	 * FLAGS: CPU status flags
	 *
	 * immediate goal:
	 *   We're already on the kernel stack, but not having
	 *   needed to use SR3. We can just make room on the
	 *   stack (r31) for our exception frame.
d1840 1
a1840 3
	subu	r31,  r31,  TRAPFRAME_SIZEOF	/* r31 now our E.F. */
	st	FLAGS,r31,  EF_FLAGS		/* save flags */
	st	r1,   r31,  GENREG_OFF(1)	/* save prev. r1 (now free) */
d1842 2
a1843 6
	ldcr	r1,   SR3			/* save previous SR3 */
	st	r1,   r31,  EF_SR3

	addu	r1,   r31,  TRAPFRAME_SIZEOF	/* save previous r31 */
	st	r1,   r31,  GENREG_OFF(31)
	br	_ASM_LABEL(m88110_have_pcb)
d1846 1
d1854 1
a1854 3
	 *   Since we're servicing an exception from user mode, we
	 *   know that SR3 is free.  We use it to free up a temporary
	 *   register to be used in getting the process pcb.
d1873 44
d1931 4
a1997 1
	 *   Exception SR3, if appropriate.
a2052 1
	ld	TMP,  r31,  EF_SR3		/* get previous SR3 */
d2090 1
a2090 1
	 * SR3: previous exception-time SR3
a2100 1
	 *   Exception SR3, if appropriate.
@


1.45
log
@Restart the m88110 floating-point trap code from scratch, basing it on the
sparc{,64} floating-point emulator, adapted to the 88110 specifics. Handling
of these traps is now entirely done in C for convenience.

Although there are a few rounding issues to address, and the XRF is ignored,
this allows all the ieee754 regression tests to pass (lib/libc/ieeefp,
sys/kern/signal/fpsig, sys/kern/signal/sigfpe).
@
text
@d1 1
a1 1
/*   $OpenBSD: eh_common.S,v 1.44 2007/12/22 19:38:33 miod Exp $	*/
d337 2
a338 2
	bb0.n	PSR_SUPERVISOR_MODE_BIT, r1, 1f 	; \
	 clr	FLAGS, FLAGS, 1<FLAG_FROM_KERNEL> 	; \
d346 2
a347 2
	bsr.n	_ASM_LABEL(m88110_setup_phase_two)	; \
	 st	TMP2, r31, EF_VECTOR
d1700 2
a1701 2
	br.n	1f
	 or	r29, r0, 10
d1716 2
a1717 2
	br.n	1b
	 addu	r27, r27, 4	/* bump up */
d1799 2
a1800 2
	bsr.n	_C_LABEL(error_fatal)
	 or	r2, r0, r30
d1854 2
a1855 2
	br.n	_ASM_LABEL(m88110_have_pcb)
	 st	r1,   r31,  GENREG_OFF(31)
d1920 2
a1921 2
	bcnd.n	eq0,  TMP,  1f
	 st	TMP,  r31,  EF_ISR
d1933 2
a1934 2
	bcnd.n	eq0,  TMP,  1f
	 st	TMP,  r31,  EF_DSR
d2106 2
a2107 2
	bcnd.n	eq0,  r2,   8f
	 ld	r14,  r30,  EF_RET
d2109 3
a2111 3
	bb1.n	eq,   r3,   8f
	 cmp	r3,   r2,   11	/* or NMI? */
	bb1.n	eq,   r3,   8f
d2114 4
a2117 4
	 cmp	r3,   r2,   130	/* DDB break exception */
	bb1.n	eq,   r3,   8f
	 cmp	r3,   r2,   132	/* DDB entry exception */
	bb1.n	eq,   r3,   8f
@


1.44
log
@Make sure we have a real stack when invoking getipl() during exceptions.
Fits in the brown-paperbag bug category.
@
text
@d1 1
a1 1
/*   $OpenBSD: eh_common.S,v 1.43 2007/12/21 23:56:54 miod Exp $	*/
d1597 3
a1599 1
	XCALL(_ASM_LABEL(m88110_fpu_exception), _ASM_LABEL(check_ast))
@


1.43
log
@Change the EF_xxx constants to be real offsets within the trapframe, instead
of offsets / sizeof(register_t), and nuke the REG_OFF macro. No functional
change.
@
text
@d1 1
a1 1
/*   $OpenBSD: eh_common.S,v 1.42 2007/12/05 22:12:32 miod Exp $	*/
d1418 1
a1418 5

	/* get and save IPL */
	bsr.n	_C_LABEL(getipl)
	 st	r29,  r31,  GENREG_OFF(29)
	st	r2, r31, EF_MASK
d1460 4
d2050 1
a2050 5

	/* get and save IPL */
	bsr.n	_C_LABEL(getipl)
	 st	r29,  r31,  GENREG_OFF(29)
	st	r2, r31, EF_MASK
d2088 4
@


1.42
log
@Make the CPU_88100 and CPU_88110 constants match the architectural number
field from the processor identification register; this allows .S code which
needs to decide on the cpu type at runtime to check quicker, without needing
to access memory. No functional change.
@
text
@d1 1
a1 1
/*   $OpenBSD: eh_common.S,v 1.41 2007/12/02 21:32:08 miod Exp $	*/
d230 2
a231 3
/* REGister OFFset into the E.F. (exception frame) */
#define REG_OFF(reg_num)  ((reg_num) * 4) /* (num * sizeof(register_t))  */
#define GENREG_OFF(num)	(REG_OFF(EF_R0 + (num))) /* GENeral REGister OFFset */
d268 1
a268 1
#define	EF_SR3		(EF_R0 + 5)
d320 1
a320 1
	st	TMP2, r31, REG_OFF(EF_VECTOR)		; \
d347 1
a347 1
	 st	TMP2, r31, REG_OFF(EF_VECTOR)
d560 1
a560 1
	subu	r31, r31, SIZEOF_EF	/* r31 now our E.F. */
d581 1
a581 1
	st	r10, r31, REG_OFF(EF_EPSR)
d583 1
a583 1
	st	r10, r31, REG_OFF(EF_SXIP)
d585 1
a585 1
	st	r10, r31, REG_OFF(EF_SNIP)
d587 1
a587 1
	st	r10, r31, REG_OFF(EF_FLAGS)
d589 1
a589 1
	st	r10, r31, REG_OFF(EF_SFIP)
d591 1
a591 1
	st	r10, r31, REG_OFF(EF_SSBR)
d595 1
a595 1
	st	r10, r31, REG_OFF(EF_DMT0)
d597 1
a597 1
	st	r11, r31, REG_OFF(EF_DMD0)
d600 1
a600 1
	st	r12, r31, REG_OFF(EF_DMA0)
d602 1
a602 1
	st	r10, r31, REG_OFF(EF_DMT1)
d605 1
a605 1
	st 	r11, r31, REG_OFF(EF_DMD1)
d607 1
a607 1
	st	r12, r31, REG_OFF(EF_DMA1)
d610 1
a610 1
	st	r10, r31, REG_OFF(EF_DMT2)
d612 1
a612 1
	st	r11, r31, REG_OFF(EF_DMD2)
d614 1
a614 1
	st	r12, r31, REG_OFF(EF_DMA2)
d618 1
a618 1
	st	r10, r31, REG_OFF(EF_FPLS1)
d622 1
a622 1
	st	r10, r31, REG_OFF(EF_FPHS2)
d625 1
a625 1
	st	r29, r31, REG_OFF(EF_VECTOR)
d884 2
a885 2
	subu	r31,  r31,  SIZEOF_EF		/* r31 now our E.F. */
	st	FLAGS,r31,  REG_OFF(EF_FLAGS)	/* save flags */
d889 1
a889 1
	st	r1,   r31,  REG_OFF(EF_SR3)
d891 1
a891 1
	addu	r1,   r31,  SIZEOF_EF		/* save previous r31 */
d918 1
a918 1
	ld	r1,   r30,  REG_OFF(EF_EPSR)	/* get back the epsr */
d923 2
a924 2
	subu	r30,  r30,  SIZEOF_EF		/* r30 now our E.F. */
	st	FLAGS,r30,  REG_OFF(EF_FLAGS)	/* save flags */
d929 2
a930 2
	addu	r30,  r30,  SIZEOF_EF		/* r30 now has previous SR3 */
	st	r30,  r31,  REG_OFF(EF_SR3)	/* save previous SR3 */
d940 2
a941 2
	addu	r1,   r1,   USPACE - SIZEOF_EF
	st	FLAGS,r1,   REG_OFF(EF_FLAGS)	/* store flags */
d943 1
a943 1
	st	r30,  r1,   REG_OFF(EF_SR3)	/* store old SR3 (pcb) */
d977 1
a977 1
	st	FLAGS,r31,  REG_OFF(EF_FLAGS)	/* save flags */
d1005 1
a1005 1
	st	TMP,  r31,  REG_OFF(EF_EPSR)
d1007 1
a1007 1
	st	TMP3, r31,  REG_OFF(EF_SNIP)
d1009 1
a1009 1
	st	TMP2, r31,  REG_OFF(EF_SFIP)
d1012 1
a1012 1
	st	TMP,  r31,  REG_OFF(EF_CPU)
d1025 1
a1025 1
	st	TMP2, r31,  REG_OFF(EF_SXIP)
d1035 1
a1035 1
	 st	TMP3, r31,  REG_OFF(EF_DMT0)
d1039 2
a1040 2
	st	TMP2, r31,  REG_OFF(EF_DMT1)
	st	TMP3, r31,  REG_OFF(EF_DMT2)
d1044 2
a1045 2
	st	TMP2, r31,  REG_OFF(EF_DMA0)
	st	TMP3, r31,  REG_OFF(EF_DMA1)
d1049 2
a1050 2
	st	TMP2, r31,  REG_OFF(EF_DMA2)
	st	TMP3, r31,  REG_OFF(EF_DMD0)
d1055 2
a1056 2
	st	TMP2, r31,  REG_OFF(EF_DMD1)
	st	TMP3, r31,  REG_OFF(EF_DMD2)
d1131 2
a1132 2
	st	TMP2, r31,  REG_OFF(EF_FPSR)
	st	TMP3, r31,  REG_OFF(EF_FPCR)
d1136 2
a1137 2
	st	TMP2, r31,  REG_OFF(EF_FPECR)
	st	TMP3, r31,  REG_OFF(EF_FPRH)
d1141 2
a1142 2
	st	TMP2, r31,  REG_OFF(EF_FPIT)
	st	TMP3, r31,  REG_OFF(EF_FPRL)
d1169 2
a1170 2
	st	TMP2, r31,  REG_OFF(EF_FPSR)
	st	TMP3, r31,  REG_OFF(EF_FPCR)
d1173 1
a1173 1
	st	TMP3, r31,  REG_OFF(EF_FPECR)
d1176 2
a1177 2
	st	TMP2, r31,  REG_OFF(EF_FPHS1)
	st	TMP3, r31,  REG_OFF(EF_FPHS2)
d1181 2
a1182 2
	st	TMP2, r31,  REG_OFF(EF_FPLS1)
	st	TMP3, r31,  REG_OFF(EF_FPLS2)
d1185 1
a1185 1
	st	TMP2, r31,  REG_OFF(EF_FPPT)
d1342 1
a1342 1
	st	r1,   r31,  REG_OFF(EF_RET)	/* save the return address */
d1379 1
a1379 1
	ld	TMP,  r31,  REG_OFF(EF_SR3)	/* get previous SR3 */
d1422 1
a1422 1
	st	r2, r31, REG_OFF(EF_MASK)
d1456 1
a1456 1
	ld	r6,   r31,  REG_OFF(EF_EPSR)
d1474 1
a1474 1
	ld	r2,   r30,  REG_OFF(EF_VECTOR)
d1476 1
a1476 1
	 ld	r14,  r30,  REG_OFF(EF_RET)
d1502 1
a1502 1
	ld	r3,   r30,  REG_OFF(EF_DMT0)
d1723 1
a1723 1
	subu	r31, r31, SIZEOF_EF		/* r31 now our E.F. */
d1743 1
a1743 1
	st	r29, r31, REG_OFF(EF_VECTOR)
d1747 1
a1747 1
	st	r10, r31, REG_OFF(EF_EPSR)
d1749 1
a1749 1
	st	r10, r31, REG_OFF(EF_EXIP)
d1751 1
a1751 1
	st	r10, r31, REG_OFF(EF_ENIP)
d1753 1
a1753 1
	st	r10, r31, REG_OFF(EF_DSR)
d1755 1
a1755 1
	st	r10, r31, REG_OFF(EF_DLAR)
d1757 1
a1757 1
	st	r10, r31, REG_OFF(EF_DPAR)
d1759 1
a1759 1
	st	r10, r31, REG_OFF(EF_ISR)
d1761 1
a1761 1
	st	r10, r31, REG_OFF(EF_ILAR)
d1763 1
a1763 1
	st	r10, r31, REG_OFF(EF_IPAR)
d1765 1
a1765 1
	st	r10, r31, REG_OFF(EF_FLAGS)
d1769 1
a1769 1
	st	r10, r31, REG_OFF(EF_FPLS1)
d1773 1
a1773 1
	st	r10, r31, REG_OFF(EF_FPHS2)
d1844 2
a1845 2
	subu	r31,  r31,  SIZEOF_EF		/* r31 now our E.F. */
	st	FLAGS,r31,  REG_OFF(EF_FLAGS)	/* save flags */
d1849 1
a1849 1
	st	r1,   r31,  REG_OFF(EF_SR3)
d1851 1
a1851 1
	addu	r1,   r31,  SIZEOF_EF		/* save previous r31 */
d1880 1
a1880 1
	st	FLAGS,r31,  REG_OFF(EF_FLAGS)	/* save flags */
d1904 1
a1904 1
	st	TMP,  r31,  REG_OFF(EF_EPSR)
d1907 2
a1908 2
	st	TMP2, r31,  REG_OFF(EF_EXIP)
	st	TMP3, r31,  REG_OFF(EF_ENIP)
d1912 1
a1912 1
	st	TMP,  r31,  REG_OFF(EF_CPU)
d1919 1
a1919 1
	 st	TMP,  r31,  REG_OFF(EF_ISR)
d1922 2
a1923 2
	st	TMP2, r31,  REG_OFF(EF_ILAR)
	st	TMP3, r31,  REG_OFF(EF_IPAR)
d1926 2
a1927 2
	st	TMP,  r31,  REG_OFF(EF_ISAP)
	st	TMP2, r31,  REG_OFF(EF_IUAP)
d1932 1
a1932 1
	 st	TMP,  r31,  REG_OFF(EF_DSR)
d1935 2
a1936 2
	st	TMP2, r31,  REG_OFF(EF_DLAR)
	st	TMP3, r31,  REG_OFF(EF_DPAR)
d1939 2
a1940 2
	st	TMP,  r31,  REG_OFF(EF_DSAP)
	st	TMP2, r31,  REG_OFF(EF_DUAP)
d1980 1
a1980 1
	st	r1,   r31,  REG_OFF(EF_RET)	/* save the return address */
d2017 1
a2017 1
	ld	TMP,  r31,  REG_OFF(EF_SR3)	/* get previous SR3 */
d2054 1
a2054 1
	st	r2, r31, REG_OFF(EF_MASK)
d2085 1
a2085 1
	ld	r6,   r31,  REG_OFF(EF_EPSR)
d2103 1
a2103 1
	ld	r2,   r30,  REG_OFF(EF_VECTOR)
d2105 1
a2105 1
	 ld	r14,  r30,  REG_OFF(EF_RET)
d2154 1
a2154 1
	ld	r2, FPTR, REG_OFF(EF_EPSR)
d2157 1
a2157 1
	ld	r2, FPTR, REG_OFF(EF_MASK)
d2173 1
a2173 1
	ld	r2, FPTR, REG_OFF(EF_EPSR)
d2229 1
a2229 1
	 ld	r2, FPTR, REG_OFF(EF_MASK)	/* get pre-exception ipl */
d2289 2
a2290 2
	ld	r30, r31, REG_OFF(EF_SNIP)
	ld	r1,  r31, REG_OFF(EF_SFIP)
d2294 1
a2294 1
	ld	r30, r31, REG_OFF(EF_EPSR)
d2307 2
a2308 2
	ld	r30, r31, REG_OFF(EF_ENIP)
	ld	r1,  r31, REG_OFF(EF_EXIP)
d2312 1
a2312 1
	ld	r30, r31, REG_OFF(EF_EPSR)
@


1.41
log
@The beginning of a real floating-point exception handler for the 88110. The
existing code to enable TCFP was broken, as it was not setting the TCFP bit
in the right register.

So far, the exception handler will deliver SIGFPE in all cases. It will
eventually do the necessary rounding, and handle the odd-numbered register
pair operation, as I get time to write this (or see how much can be lifted
from the 88100 floating-point exception code).
@
text
@d1 1
a1 1
/*   $OpenBSD: eh_common.S,v 1.40 2007/12/02 21:28:40 miod Exp $	*/
d2276 4
a2279 5
	or.u	r1, r0, hi16(_C_LABEL(cputyp))
	ld	r30, r1, lo16(_C_LABEL(cputyp))
	cmp	r1, r30, CPU_88110
	bb1	ne, r1, _ASM_LABEL(m88100_user_rte)
	br	_ASM_LABEL(m88110_user_rte)
@


1.40
log
@Do not pass UPAGES and USPACE (under the name USIZE) in assym.h, code which
needs it includes <machine/param.h> already.
@
text
@d1 1
a1 1
/*   $OpenBSD: eh_common.S,v 1.39 2007/12/02 21:27:02 miod Exp $	*/
d1596 3
a1598 4
GLOBAL(m88110_fp_precise_handler)
	PREP88110("FPU precise", 114,)
	or	r3, r0, r30
	XCALL(_ASM_LABEL(m88110_Xfp_precise), _ASM_LABEL(check_ast))
@


1.39
log
@Since the 88110 doesn't disable the FPU when handling an exception (and does
not need to), do not try to handle exceptions occuring when we re-enable
shadowing as special - these are just nested exceptions.

While there, add a workaround for the 88110 rte errata (#18).
@
text
@d1 1
a1 1
/*   $OpenBSD: eh_common.S,v 1.38 2007/11/22 23:30:11 miod Exp $	*/
d941 1
a941 1
	addu	r1,   r1,   USIZE - SIZEOF_EF
d1462 1
a1462 1
	addu	r31,  r31,  USIZE	/* point at proper end */
d2092 1
a2092 1
	addu	r31,  r31,  USIZE		/* point at proper end */
@


1.38
log
@Do not reenable interrupts for netsted interrupts if interrupts were
previously disabled on 88110, similar to a recent 88100 fix.
@
text
@d1 1
a1 1
/*   $OpenBSD: eh_common.S,v 1.37 2007/11/22 23:29:27 miod Exp $	*/
d33 2
a34 1
 * macro and #include this file in your port's eh.S:
d44 1
a44 1
 * exception handling (chapter 6), the MACH kernel, and that you have a brain
d345 4
a348 4
	st	TMP2, r31, REG_OFF(EF_VECTOR)		; \
	/* call setup_phase_two to restart the FPU  */	; \
	/* and to save all general registers.       */	; \
	bsr	_ASM_LABEL(m88110_setup_phase_two)
d1321 1
a1321 1
	 *   SR3 will be OUR stack pointer) so that we may resart the FPU.
a1824 2
	/* Check if we are coming in from a FPU restart exception.
	   If so, the pcb will be in SR3 */
a1830 1
	bb1	FLAG_ENABLING_FPU, FLAGS, _ASM_LABEL(m88110_use_SR3_pcb)
d1834 1
a1834 1
	/* Interrupt in kernel mode, not FPU restart */
a1856 57
ASLOCAL(m88110_use_SR3_pcb)
	/*
	 * SR1: saved copy of exception-time register now holding FLAGS
	 * SR2: return address to the calling exception handler
	 * SR3: must be preserved; exception-time stack pointer
	 * FLAGS: CPU status flags
	 *
	 * immediate goal:
	 *   An exception occurred while enabling the FPU. Since r31 is the
	 *   user's r31 while enabling the FPU, we had put our pcb pointer
	 *   into SR3, so make room from there for our stack pointer.
	 *   We need to check if SR3 is the old stack pointer or the pointer
	 *   off to the user pcb. If it pointing to the user pcb, we need to
	 *   pick up the kernel stack. Otherwise we need to allocate a frame
	 *   upon it.
	 *   We look at the EPSR to see if it was from user mode
	 *   Unfortunately, we have no registers free at the moment, but we
	 *   know register 0 in the pcb frame will always be zero, so we can
	 *   use it as scratch storage.
	 */
	xcr	r30,  r30,  SR3			/* r30 = old exception frame */
	st	r1,   r30,  GENREG_OFF(0)	/* free up r1 */
	ld	r1,   r30,  REG_OFF(EF_EPSR)	/* get back the epsr */
	bb0.n	PSR_SUPERVISOR_MODE_BIT, r1, 1f	/* if user mode */
	 ld	r1,   r30,  GENREG_OFF(0)	/* restore r1 */
	/* we were in kernel mode - dump frame upon the stack */
	st	r0,   r30,  GENREG_OFF(0)	/* repair old frame */
	subu	r30,  r30,  SIZEOF_EF		/* r30 now our E.F. */
	st	FLAGS,r30,  REG_OFF(EF_FLAGS)	/* save flags */
	st	r1,   r30,  GENREG_OFF(1)	/* save prev. r1 (now free) */

	st	r31,  r30,  GENREG_OFF(31)	/* save previous r31 */
	or	r31,  r0,   r30			/* make r31 our pointer. */
	addu	r30,  r30,  SIZEOF_EF		/* r30 now has previous SR3 */
	st	r30,  r31,  REG_OFF(EF_SR3)	/* save previous SR3 */
	br.n	_ASM_LABEL(m88110_have_pcb)
	 xcr	r30,  r30,  SR3			/* restore r30 */
1:
	/*
	 * We took an exception while restarting the FPU from user space.
	 * Consequently, we never picked up a stack. Do so now.
	 * R1 is currently free (saved in the exception frame pointed at by
	 * r30)
	 */
	ldcr	r1,   CPU
	ld	r1,   r1,   CI_CURPCB
	addu	r1,   r1,   USIZE - SIZEOF_EF
	st	FLAGS,r1,   REG_OFF(EF_FLAGS)	/* store flags */
	st	r31,  r1,   GENREG_OFF(31)	/* store r31 - now free */
	st	r30,  r1,   REG_OFF(EF_SR3)	/* store old SR3 (pcb) */
	or	r31,  r1,   r0			/* make r31 our exception fp */
	ld	r1,   r30,  GENREG_OFF(0)	/* restore old r1 */
	st	r0,   r30,  GENREG_OFF(0)	/* repair that frame */
	st	r1,   r31,  GENREG_OFF(1)	/* store r1 */
	br.n	_ASM_LABEL(m88110_have_pcb)
	 xcr	r30,  r30,  SR3			/* restore r30 */

d1879 1
a1879 2
	 * until we have saved enough and can go back to the top of the u area,
	 * after the FPU is enabled.
a1898 4
	 *
	 * immediate goal:
	 *   Save the shadow registers that need to be saved to
	 *   the exception frame.
a1962 3
	 *   Dmt0
	 *   Other data pipeline control registers, if appropriate.
	 *   FPU control registers, if appropriate.
d1967 1
a1967 1
	 *   be OUR stack pointer) so that we may resart the FPU.
a1973 1
	clr	TMP,  TMP,  1<PSR_FPU_DISABLE_BIT>	/* enable the FPU */
d1977 2
a1978 2
	or.u	TMP,  r0,   hi16(_ASM_LABEL(m88110_fpu_enable))
	or	TMP,  TMP,  lo16(_ASM_LABEL(m88110_fpu_enable))
a1980 1
	set	FLAGS, FLAGS, 1<FLAG_ENABLING_FPU>
d2006 1
a2006 1
	 *   Do an RTE to restart the fpu and jump to "fpu_enable"
d2008 1
a2008 1
	 *   this, which is why FLAG_ENABLING_FPU is set in SR1.
d2010 1
a2010 1
	RTE	/* jumps to "m88110_fpu_enable" to enable the FPU. */
d2012 1
a2012 1
ASLOCAL(m88110_fpu_enable)
d2020 1
a2020 7

	/* make sure that the FLAG_ENABLING_FPU bit is off */
	xcr	FLAGS,FLAGS,SR1
	clr	FLAGS,FLAGS,1<FLAG_ENABLING_FPU>
	xcr	FLAGS,FLAGS,SR1

	xcr	TMP,  TMP,  SR3	/* replace TMP, SR3 */
d2071 1
a2071 3
	 *   DSR
	 *   Other data pipeline control registers, if appropriate.
	 *   FPU control registers, if appropriate.
a2074 1
	 *   Pick up a stack if we came in from user mode.
d2276 1
a2276 2
#ifdef M88110
#ifdef M88100
d2280 2
a2281 10
	bb1	ne, r1, 1f
#endif
	ld	r30, r31, REG_OFF(EF_ENIP)
	ld	r1,  r31, REG_OFF(EF_EXIP)
	stcr	r30, ENIP
	stcr	r1,  EXIP
#ifdef M88100
	br	2f
1:
#endif
d2283 1
d2285 1
d2296 10
a2305 1
2:
d2307 8
d2323 16
d2340 1
@


1.37
log
@Do not bother saving the fault address registers if the fault status
registers are empty, to speed up a bit non-fault traps.
@
text
@d1 1
a1 1
/*   $OpenBSD: eh_common.S,v 1.36 2007/11/22 23:28:52 miod Exp $	*/
d2165 2
a2166 2
	ld	r2,   r31,  REG_OFF(EF_EPSR)
	bb1	PSR_SUPERVISOR_MODE_BIT, r2, 1f	/* if in kernel mode */
d2185 1
a2185 1
	 ld	r14,  r30,  REG_OFF(EF_RET)	/* load return value XXX!!! */
a2193 1

d2198 4
a2201 1
	/* turn interrupts back on */
@


1.36
log
@Do not redirect exception occuring when enabling the fpu to the error handler,
for we are supposed to be able to recover from them.
@
text
@d1 1
a1 1
/*   $OpenBSD: eh_common.S,v 1.35 2007/11/22 23:28:06 miod Exp $	*/
d1981 1
a1981 1
	 * Save fault status registers from CMMU.
d1984 2
a1987 1
	st	TMP,  r31,  REG_OFF(EF_ISR)
d1994 2
d1997 2
a2000 1
	st	TMP,  r31,  REG_OFF(EF_DSR)
a2006 2

	stcr	r0, ISR
d2008 1
a2008 1

@


1.35
log
@Do not save a copy of the previous exception frame in a fixed memory location.
@
text
@d1 1
a1 1
/*   $OpenBSD: eh_common.S,v 1.34 2007/11/21 19:30:09 miod Exp $	*/
a1878 13
#if 1
	ldcr	TMP,  PSR
	clr	TMP,  TMP,  1<PSR_FPU_DISABLE_BIT>	/* enable the FPU */
	clr	TMP,  TMP,  1<PSR_SHADOW_FREEZE_BIT>	/* and shadowing */
	stcr	TMP,  EPSR

	or.u	TMP,  r0,   hi16(_C_LABEL(m88110_error_handler))
	or	TMP,  TMP,  lo16(_C_LABEL(m88110_error_handler))
	stcr	TMP,  EXIP

	RTE
#else
	/* Testing!!! */
a1914 1
#endif
@


1.34
log
@Move external interrupt and ast handling from m881[01]0_trap() to their
own functions, which do not need to be processor-specific.

This speeds up the exception return sequence a bit.
@
text
@d1 1
a1 1
/*   $OpenBSD: eh_common.S,v 1.33 2007/11/17 05:36:23 miod Exp $	*/
a272 57
#ifdef M88110
#define SAVE_CTX \
	stcr	r31, SRX			; \
	or.u	r31, r0,  hi16(_ASM_LABEL(save_frame))	; \
	or	r31, r31, lo16(_ASM_LABEL(save_frame))	; \
	/* save old R31 and other R registers */; \
	st.d	r0 , r31, GENREG_OFF(0)		; \
	st.d	r2 , r31, GENREG_OFF(2)		; \
	st.d	r4 , r31, GENREG_OFF(4)		; \
	st.d	r6 , r31, GENREG_OFF(6)		; \
	st.d	r8 , r31, GENREG_OFF(8)		; \
	st.d	r10, r31, GENREG_OFF(10)	; \
	st.d	r12, r31, GENREG_OFF(12)	; \
	st.d	r14, r31, GENREG_OFF(14)	; \
	st.d	r16, r31, GENREG_OFF(16)	; \
	st.d	r18, r31, GENREG_OFF(18)	; \
	st.d	r20, r31, GENREG_OFF(20)	; \
	st.d	r22, r31, GENREG_OFF(22)	; \
	st.d	r24, r31, GENREG_OFF(24)	; \
	st.d	r26, r31, GENREG_OFF(26)	; \
	st.d	r28, r31, GENREG_OFF(28)	; \
	st	r30, r31, GENREG_OFF(30)	; \
	ldcr	r1,  SRX			; \
	st	r1,  r31, GENREG_OFF(31)	; \
	ldcr	r1,  EPSR			; \
	ldcr	r2,  EXIP			; \
	ldcr	r3,  ENIP			; \
	st	r1,  r31, REG_OFF(EF_EPSR)	; \
	st	r2,  r31, REG_OFF(EF_EXIP)	; \
	st	r3,  r31, REG_OFF(EF_ENIP)	; \
	ldcr	r1,  DSR			; \
	ldcr	r2,  DLAR			; \
	ldcr	r3,  DPAR			; \
	st	r1,  r31, REG_OFF(EF_DSR)	; \
	st	r2,  r31, REG_OFF(EF_DLAR)	; \
	st	r3,  r31, REG_OFF(EF_DPAR)	; \
	ldcr	r1,  ISR			; \
	ldcr	r2,  ILAR			; \
	ldcr	r3,  IPAR			; \
	st	r1,  r31, REG_OFF(EF_ISR)	; \
	st	r2,  r31, REG_OFF(EF_ILAR)	; \
	st	r3,  r31, REG_OFF(EF_IPAR)	; \
	ldcr	r1, DSAP			; \
	ldcr	r2, DUAP			; \
	st	r1,  r31, REG_OFF(EF_DSAP)	; \
	st	r2,  r31, REG_OFF(EF_DUAP)	; \
	ldcr	r1, ISAP			; \
	ldcr	r2, IUAP			; \
	st	r1,  r31, REG_OFF(EF_ISAP)	; \
	st	r2,  r31, REG_OFF(EF_IUAP)	; \
	/* Restore r1, r2, r3, and r31 */	; \
	ld	r1 , r31, GENREG_OFF(1)		; \
	ld	r2 , r31, GENREG_OFF(2)		; \
	ld	r3 , r31, GENREG_OFF(3)		; \
	ld	r31, r31, GENREG_OFF(31)	;
#endif

a330 1
	SAVE_CTX					  \
a1744 2
	cmp	r29, r29, 0	/* is it the reset exception? */
	bb1.n	ne,  r29, 1f	/* if not, skip */
d1747 1
a1747 1
	 ldcr	r10, EPSR
d1766 1
a1766 2
	br.n	2f
	 st	r10, r31, REG_OFF(EF_FLAGS)
a1767 33
1:
	/* retrieve saved shadow registers for error_handler */
	or.u	r30, r0,  hi16(_ASM_LABEL(save_frame))
	or	r30, r30, lo16(_ASM_LABEL(save_frame))
	ld	r10, r30, REG_OFF(EF_EPSR)
	st	r10, r31, REG_OFF(EF_EPSR)
	ld	r10, r30, REG_OFF(EF_EXIP)
	st	r10, r31, REG_OFF(EF_EXIP)
	ld	r10, r30, REG_OFF(EF_ENIP)
	st	r10, r31, REG_OFF(EF_ENIP)
	ld	r10, r30, REG_OFF(EF_DSR)
	st	r10, r31, REG_OFF(EF_DSR)
	ld	r10, r30, REG_OFF(EF_DLAR)
	st	r10, r31, REG_OFF(EF_DLAR)
	ld	r10, r30, REG_OFF(EF_DPAR)
	st	r10, r31, REG_OFF(EF_DPAR)
	ld	r10, r30, REG_OFF(EF_ISR)
	st	r10, r31, REG_OFF(EF_ISR)
	ld	r10, r30, REG_OFF(EF_ILAR)
	st	r10, r31, REG_OFF(EF_ILAR)
	ld	r10, r30, REG_OFF(EF_IPAR)
	st	r10, r31, REG_OFF(EF_IPAR)
	ld	r10, r30, REG_OFF(EF_ISAP)
	st	r10, r31, REG_OFF(EF_ISAP)
	ld	r10, r30, REG_OFF(EF_DSAP)
	st	r10, r31, REG_OFF(EF_DSAP)
	ld	r10, r30, REG_OFF(EF_IUAP)
	st	r10, r31, REG_OFF(EF_IUAP)
	ld	r10, r30, REG_OFF(EF_DUAP)
	st	r10, r31, REG_OFF(EF_DUAP)
	ldcr	r10, SR1
	st	r10, r31, REG_OFF(EF_FLAGS)
2:
a2218 5

	data
	.align 8		/* needs align 8 for ld.d/st.d */
ASLOCAL(save_frame)
	space SIZEOF_EF
@


1.33
log
@Replace many ``unsigned'' variables with ``unsigned int'', ``u_int'' or other
appropriate types. No functional change.
@
text
@d1 1
a1 1
/*   $OpenBSD: eh_common.S,v 1.32 2007/11/15 21:27:22 miod Exp $	*/
d435 1
a435 1
	XCALL(_C_LABEL(m88100_trap), _ASM_LABEL(check_ast))
d1592 1
a1592 1
	XCALL(_C_LABEL(m88110_trap), _ASM_LABEL(check_ast))
d1663 1
a1663 1
	XCALL(_C_LABEL(m88110_trap), _ASM_LABEL(check_ast))
d2368 4
a2371 21
	bcnd.n	eq0, r2, _ASM_LABEL(ast_done)
	/*
	 * trap(T_ASTFLT,...) will service ast's.
	 */
	 or	r3, r0, FPTR
	or	r2, r0, T_ASTFLT
#if defined(M88110) && defined(M88100)
	or.u	r4, r0, hi16(_C_LABEL(cputyp))
	ld	r5, r4, lo16(_C_LABEL(cputyp))
	cmp	r4, r5, CPU_88110
	bb0	eq, r4, 2f
#endif
#if defined(M88110)
	XCALL(_C_LABEL(m88110_trap), _ASM_LABEL(ast_done))
#endif
#if defined(M88110) && defined(M88100)
2:
#endif
#ifdef M88100
	XCALL(_C_LABEL(m88100_trap), _ASM_LABEL(ast_done))
#endif
@


1.32
log
@Check for curcpu()->ci_softintr being nonzero before invoking dosoftint(),
in the common case, this saves us two potentially expensive setipl() calls.
@
text
@d1 1
a1 1
/*   $OpenBSD: eh_common.S,v 1.31 2007/11/15 21:25:40 miod Exp $	*/
d785 1
a785 1
 * extern boolean_t badaddr(unsigned addr, unsigned len)
@


1.31
log
@Make a few end-of-trap-handling symbols global, to get better ddb traces.
Also, pick better symbol names in the sir/ast processing.
@
text
@d1 1
a1 1
/*   $OpenBSD: eh_common.S,v 1.30 2007/11/15 21:24:14 miod Exp $	*/
d2348 5
@


1.30
log
@Resolve the struct trapframe tf_mode/tf_flags duality by getting rid of
the tf_mode name. This field only contains flags used internally by the
exception processing code.
@
text
@d1 1
a1 1
/*   $OpenBSD: eh_common.S,v 1.29 2007/11/15 21:23:16 miod Exp $	*/
d2324 1
a2324 1
ASLOCAL(check_ast)
d2336 1
d2339 1
a2339 2
	 * interrupts.
	 * If returning to userland, look for ASTs.
d2341 2
a2342 1
	/* do not service soft interrupts if interrupts were disabled... */
d2344 1
a2344 1
	bb1	PSR_INTERRUPT_DISABLE_BIT, r2, _ASM_LABEL(no_softint)
d2347 1
a2347 1
	bcnd	ne0, r2, _ASM_LABEL(no_softint)
a2348 1
	/* do an inline spl0() */
d2355 1
a2355 1
ASLOCAL(no_softint)
d2358 1
a2358 1
	bb1	PSR_SUPERVISOR_MODE_BIT, r2, _ASM_LABEL(no_ast)
d2363 1
a2363 1
	bcnd.n	eq0, r2, _ASM_LABEL(no_ast)
d2376 1
a2376 1
	XCALL(_C_LABEL(m88110_trap), _ASM_LABEL(no_ast))
d2382 1
a2382 1
	XCALL(_C_LABEL(m88100_trap), _ASM_LABEL(no_ast))
d2421 1
a2421 1
ASLOCAL(no_ast)
@


1.29
log
@Stop referring the initial kernel stack as the ``interrupt stack''. It's
been years since it has last been used for that purpose, so name it the
initialization/startup stack.

While there, do not store the initialization stack in cpu_info, and have
secondary_pre_main() return its value so that the bootstrap code does not
need to fetch it from cpu_info.

This might be reconsidered when the startup stacks will be freed after they
are not used anymore, but there are more things to do first.
@
text
@d1 1
a1 1
/*   $OpenBSD: eh_common.S,v 1.28 2007/11/14 22:55:50 miod Exp $	*/
a266 3
 *
 * EF_FLAGS
 *   This is just the old EF_MODE. "EF_MODE" isn't a very good name.
a268 1
#define	EF_FLAGS	EF_MODE
d645 1
a645 1
	st	r10, r31, REG_OFF(EF_MODE)
d1827 1
a1827 1
	 st	r10, r31, REG_OFF(EF_MODE)
d1860 1
a1860 1
	st	r10, r31, REG_OFF(EF_MODE)
@


1.28
log
@When servicing an exception, do not enable interrupts if they were not
enabled when the exception occured. This should not happen in practice,
but better be safe than sorry.
@
text
@d1 1
a1 1
/*   $OpenBSD: eh_common.S,v 1.27 2007/11/09 22:46:38 miod Exp $	*/
d603 2
a604 2
	or.u	r31, r0,  hi16(_ASM_LABEL(intstack_end))
	or	r31, r31, lo16(_ASM_LABEL(intstack_end))
d608 2
a609 2
	or.u	r27, r0,  hi16(_ASM_LABEL(intstack))
	or	r27, r27, lo16(_ASM_LABEL(intstack))
d1767 2
a1768 2
	or.u	r31, r0,  hi16(_ASM_LABEL(intstack_end))
	or	r31, r31, lo16(_ASM_LABEL(intstack_end))
d1772 2
a1773 2
	or.u	r27, r0,  hi16(_ASM_LABEL(intstack))
	or	r27, r27, lo16(_ASM_LABEL(intstack))
@


1.27
log
@Do not bother checking for curproc != NULL if we know a trap comes from
usermode, since curproc can not be NULL outside the kernel.
@
text
@d1 1
a1 1
/*   $OpenBSD: eh_common.S,v 1.26 2007/10/16 04:57:39 miod Exp $	*/
d1518 2
a1519 2
	ld	r2,   r31,  REG_OFF(EF_EPSR)
	bb1	PSR_SUPERVISOR_MODE_BIT, r2, 1f	/* if in kernel mode */
d1554 4
a1557 1
	/* turn interrupts back on */
d1562 1
a1562 1

d2369 1
a2369 1
	 * trap(AST,...) will service ast's.
@


1.26
log
@Do not expose the end of the proc_trampoline bowels to C code anymore, and
get rid of the ``switchframe'' struct definition. As a bonus, this makes
cpu_fork() simpler and unwastes 8 bytes of u area.
@
text
@d1 1
a1 1
/*   $OpenBSD: eh_common.S,v 1.25 2007/10/13 12:54:03 miod Exp $	*/
a2362 1
	bcnd	eq0, r3, _ASM_LABEL(no_ast)	/* no AST if no process! */
d2364 1
a2364 3
	bcnd.n	eq0, r2, _ASM_LABEL(no_ast)	/* .n safe since the first
						   instruction of CALL() is
						   safe in a delay slot. */
@


1.25
log
@Be sure to spl0() in proc_trampoline, so that kernel threads start at IPL_NONE.
@
text
@d1 1
a1 1
/*   $OpenBSD: eh_common.S,v 1.24 2007/05/18 16:35:54 miod Exp $	*/
d2321 1
a2321 26
/*
 * void proc_trampoline(void (*func)(void *), void *proc)
  *
 * When a process setup by cpu_fork() resumes, it will find itself in
 * proc_trampoline, with r31 pointing to a ksigframe. proc_trampoline will
 * load func and proc values from ksigframe, call the function, and on return
 * pop off the ksigframe. Then, it will load pc from the switchframe and
 * jump there (the pc will usually be proc_do_uret).
 */

ENTRY(proc_trampoline)
#ifdef MULTIPROCESSOR
	bsr	_C_LABEL(proc_trampoline_mp)
#endif

	bsr.n	_C_LABEL(setipl)	/* setipl(IPL_NONE) */
	 or	r2,  r0,  r0

	ld	r1,  r31, 0		/* load func */
	ld	r2,  r31, 4 		/* load proc pointer */
	jsr.n	r1
	 addu	r31, r31, 8		/* release ksigframe */
	ld	r1,  r31, 0		/* load pc */
	ld	r2,  r31, 4		/* & proc pointer from switch frame */
	jsr.n	r1
	 addu	r31, r31, 8
a2324 1

d2390 1
a2390 1
 * void proc_do_uret(struct proc *p)
d2392 4
a2395 4
 * This is called as proc_do_uret(proc) from proc_trampoline(). This function
 * loads FPTR with a pointer to the trap frame for the given proc and continues
 * near the end of check_ast, bypassing soft interrupts and AST checks, to
 * load all the registers and do an RTE.
d2398 22
a2419 1
ENTRY(proc_do_uret)
d2422 1
@


1.24
log
@Move proc_do_uret() around so that it can fall through no_ast instead of
jumping to it. No functional change.
@
text
@d1 1
a1 1
/*   $OpenBSD: eh_common.S,v 1.23 2007/05/12 20:02:14 miod Exp $	*/
d2335 6
a2340 2
	ld	r1, r31, 0		/* load func */
	ld	r2, r31, 4 		/* load proc pointer */
@


1.23
log
@Change the 88100 interrupt handlers to process DAEs with interrupts enabled,
as done for DAEs not occuring during interrupts.

Remove the check for unprocessed DAE on return from trap() in eh_common.S,
since this can't happen. As a result, the return-from-trap code becomes
identical on 88100 and 88110 systems.
@
text
@d1 1
a1 1
/*   $OpenBSD: eh_common.S,v 1.22 2007/02/11 12:39:33 miod Exp $	*/
a2345 14
/*
 * void proc_do_uret(struct proc *p)
 *
 * This is called as proc_do_uret(proc) from proc_trampoline(). This function
 * loads FPTR with a pointer to the trap frame for the given proc and continues
 * near the end of check_ast, bypassing soft interrupts and AST checks, to
 * load all the registers and do an RTE.
 */

ENTRY(proc_do_uret)
	ld	FPTR, r2,   P_ADDR		/* p->p_addr */
	br.n	_ASM_LABEL(no_ast)
	 addu	FPTR, FPTR, PCB_USER_STATE	/* p->p_addr.u_pcb.user_state */

d2393 2
d2396 4
a2399 4
	 or.u	r2, r0, hi16(_C_LABEL(cputyp))
	ld	r3, r2, lo16(_C_LABEL(cputyp))
	cmp	r2, r3, CPU_88110
	bb0	eq, r2, 2f
d2402 1
a2402 1
	CALL(m88110_trap, T_ASTFLT, FPTR)
a2404 1
	br	_ASM_LABEL(no_ast)
d2408 1
a2408 1
	CALL(m88100_trap, T_ASTFLT, FPTR)
d2410 14
@


1.22
log
@Shuffle code around so that optimization of the m88110_trap() return gets
computed correctly.
@
text
@d1 1
a1 1
/*   $OpenBSD: eh_common.S,v 1.21 2006/11/19 19:36:40 miod Exp $	*/
d345 1
a345 1
 *		XCALL(trapXXX, return_code)
d360 1
a360 1
 * What's in between PREP881x0() and return_code() (usually a XCALL)
d432 1
a432 1
	XCALL(_C_LABEL(m88100_trap), _ASM_LABEL(m88100_return_code))
d439 1
a439 1
	XCALL(_C_LABEL(m88100_trap), _ASM_LABEL(m88100_return_code))
d446 1
a446 1
	XCALL(_C_LABEL(m88100_trap), _ASM_LABEL(m88100_return_code))
d455 1
a455 1
	br	_ASM_LABEL(m88100_return_code)
d462 1
a462 1
	XCALL(_C_LABEL(m88100_trap), _ASM_LABEL(m88100_return_code))
d469 1
a469 1
	XCALL(_C_LABEL(m88100_trap), _ASM_LABEL(m88100_return_code))
d485 1
a485 1
	XCALL(_C_LABEL(m88100_trap), _ASM_LABEL(m88100_return_code))
d492 1
a492 1
	XCALL(_C_LABEL(m88100_trap), _ASM_LABEL(m88100_return_code))
d499 1
a499 1
	XCALL(_C_LABEL(m88100_trap), _ASM_LABEL(m88100_return_code))
d506 1
a506 1
	XCALL(_C_LABEL(m88100_trap), _ASM_LABEL(m88100_return_code))
d514 1
a514 1
	XCALL(_ASM_LABEL(m88100_Xfp_precise), _ASM_LABEL(m88100_return_code))
d522 1
a522 1
	XCALL(_ASM_LABEL(Xfp_imprecise), _ASM_LABEL(m88100_return_code))
d529 1
a529 1
	XCALL(_C_LABEL(m88100_syscall), _ASM_LABEL(m88100_return_code))
d535 1
a535 1
	XCALL(_C_LABEL(cache_flush), _ASM_LABEL(m88100_return_code))
d541 1
a541 1
	XCALL(_C_LABEL(m88100_trap), _ASM_LABEL(m88100_return_code))
d547 1
a547 1
	XCALL(_C_LABEL(m88100_trap), _ASM_LABEL(m88100_return_code))
d553 1
a553 1
	XCALL(_C_LABEL(m88100_trap), _ASM_LABEL(m88100_return_code))
d560 1
a560 1
	XCALL(_C_LABEL(m88100_trap), _ASM_LABEL(m88100_return_code))
d566 1
a566 1
	XCALL(_C_LABEL(m88100_trap), _ASM_LABEL(m88100_return_code))
d572 1
a572 1
	XCALL(_C_LABEL(m88100_trap), _ASM_LABEL(m88100_return_code))
d1586 1
a1586 1
	XCALL(_C_LABEL(m88110_trap), _ASM_LABEL(m88110_return_code))
d1593 1
a1593 1
	XCALL(_C_LABEL(m88110_trap), _ASM_LABEL(m88110_return_code))
d1600 1
a1600 1
	XCALL(_C_LABEL(m88110_trap), _ASM_LABEL(m88110_return_code))
d1609 1
a1609 1
	XCALL(_C_LABEL(m88110_trap), _ASM_LABEL(m88110_return_code))
d1616 1
a1616 1
	XCALL(_C_LABEL(m88110_trap), _ASM_LABEL(m88110_return_code))
d1623 1
a1623 1
	XCALL(_C_LABEL(m88110_trap), _ASM_LABEL(m88110_return_code))
d1630 1
a1630 1
	XCALL(_C_LABEL(m88110_trap), _ASM_LABEL(m88110_return_code))
d1637 1
a1637 1
	XCALL(_C_LABEL(m88110_trap), _ASM_LABEL(m88110_return_code))
d1644 1
a1644 1
	XCALL(_C_LABEL(m88110_trap), _ASM_LABEL(m88110_return_code))
d1651 1
a1651 1
	XCALL(_C_LABEL(m88110_trap), _ASM_LABEL(m88110_return_code))
d1657 1
a1657 1
	XCALL(_ASM_LABEL(m88110_Xfp_precise), _ASM_LABEL(m88110_return_code))
d1664 1
a1664 1
	XCALL(_C_LABEL(m88110_trap), _ASM_LABEL(m88110_return_code))
d1671 1
a1671 1
	XCALL(_C_LABEL(m88110_trap), _ASM_LABEL(m88110_return_code))
d1678 1
a1678 1
	XCALL(_C_LABEL(m88110_trap), _ASM_LABEL(m88110_return_code))
d1685 1
a1685 1
	XCALL(_C_LABEL(m88110_trap), _ASM_LABEL(m88110_return_code))
d1692 1
a1692 1
	XCALL(_C_LABEL(m88110_syscall), _ASM_LABEL(m88110_return_code))
d1698 1
a1698 1
	XCALL(_C_LABEL(cache_flush), _ASM_LABEL(m88110_return_code))
d1704 1
a1704 1
	XCALL(_C_LABEL(m88110_trap), _ASM_LABEL(m88110_return_code))
d1710 1
a1710 1
	XCALL(_C_LABEL(m88110_trap), _ASM_LABEL(m88110_return_code))
d1716 1
a1716 1
	XCALL(_C_LABEL(m88110_trap), _ASM_LABEL(m88110_return_code))
d1723 1
a1723 1
	XCALL(_C_LABEL(m88110_trap), _ASM_LABEL(m88110_return_code))
d1729 1
a1729 1
	XCALL(_C_LABEL(m88110_trap), _ASM_LABEL(m88110_return_code))
d1735 1
a1735 1
	XCALL(_C_LABEL(m88110_trap), _ASM_LABEL(m88110_return_code))
d2351 1
a2351 1
 * near the end of return_code, bypassing soft interrupts and AST checks, to
d2361 1
a2366 4
	 * At this point, if EF_DMT0 is not zero on MC88100, then
	 * this must have been an interrupt where the fault didn't
	 * get corrected above.  We'll do that now.
	 *
a2371 8

#ifdef M88100
ASLOCAL(m88100_return_code)
	/*
	 * if there happens to be a data fault that hasn't been serviced yet,
	 * go off and service that...
	 */

a2372 3
	ld	r3, FPTR, REG_OFF(EF_DMT0)
	bb0	DMT_VALID_BIT, r3, _ASM_LABEL(check_ast)

d2374 3
a2376 2
	 * If it's the interrupt exception, and interrupts were
	 * initially disabled, enable interrupts again...
a2377 35
	ld	r2, FPTR, REG_OFF(EF_VECTOR)
	cmp	r2, r2, 1	/* is an interrupt? */
	bb1.n	ne, r2, 1f	/* if not so, skip */

	/* ...unless they were already disabled */
	 ld	r2, FPTR, REG_OFF(EF_EPSR)
	bb1.n	PSR_INTERRUPT_DISABLE_BIT, r2, 1f

	 ldcr	r2, PSR
	clr	r2, r2, 1<PSR_INTERRUPT_DISABLE_BIT>
	stcr	r2, PSR
	FLUSH_PIPELINE
1:

	CALL(m88100_trap, T_DATAFLT, r30)
#ifdef M88110
	br	_ASM_LABEL(check_ast)
#else
	/* FALLTHROUGH */
#endif
#endif /* M88100 */

#ifdef M88110
ASLOCAL(m88110_return_code)
#define	FPTR	r14
	ld	FPTR, r31, 0	/* grab exception frame pointer */
	/* FALLTHROUGH */
#endif /* M88110 */

/*
 *   If the saved ipl is 0, then call dosoftint() to process soft
 *   interrupts.
 *   If returning to userland, look for ASTs.
 */
ASLOCAL(check_ast)
@


1.21
log
@You know you're getting too old to code when you're finding stupid bugs
months later. Here, we would service ast based on p != NULL, instead of
p->p_md.md_astpending != 0...
@
text
@d1 1
a1 1
/*   $OpenBSD: eh_common.S,v 1.20 2006/11/18 22:53:07 miod Exp $	*/
d240 1
a1575 244
/*
 * void proc_trampoline(void (*func)(void *), void *proc)
  *
 * When a process setup by cpu_fork() resumes, it will find itself in
 * proc_trampoline, with r31 pointing to a ksigframe. proc_trampoline will
 * load func and proc values from ksigframe, call the function, and on return
 * pop off the ksigframe. Then, it will load pc from the switchframe and
 * jump there (the pc will usually be proc_do_uret).
 */

ENTRY(proc_trampoline)
#ifdef MULTIPROCESSOR
	bsr	_C_LABEL(proc_trampoline_mp)
#endif
	ld	r1, r31, 0		/* load func */
	ld	r2, r31, 4 		/* load proc pointer */
	jsr.n	r1
	 addu	r31, r31, 8		/* release ksigframe */
	ld	r1,  r31, 0		/* load pc */
	ld	r2,  r31, 4		/* & proc pointer from switch frame */
	jsr.n	r1
	 addu	r31, r31, 8

#define	FPTR	r14

/*
 * void proc_do_uret(struct proc *p)
 *
 * This is called as proc_do_uret(proc) from proc_trampoline(). This function
 * loads FPTR with a pointer to the trap frame for the given proc and continues
 * near the end of return_code, bypassing soft interrupts and AST checks, to
 * load all the registers and do an RTE.
 */

ENTRY(proc_do_uret)
	ld	FPTR, r2,   P_ADDR		/* p->p_addr */
	br.n	_ASM_LABEL(no_ast)
	 addu	FPTR, FPTR, PCB_USER_STATE	/* p->p_addr.u_pcb.user_state */


	/*
	 * Regs r1-r30 are free. r31 is pointing at the word
	 * on the kernel stack where our pointer to the exception frame
	 * it stored. Reload it now.
	 *
	 * At this point, if EF_DMT0 is not zero on MC88100, then
	 * this must have been an interrupt where the fault didn't
	 * get corrected above.  We'll do that now.
	 *
	 * We load it into r14 since it is preserved across function
	 * calls, and we may have to call some routines from within here.
	 *
	 * Control is transferred here from obvious places in this file.
	 */

#ifdef M88100
ASLOCAL(m88100_return_code)
	/*
	 * if there happens to be a data fault that hasn't been serviced yet,
	 * go off and service that...
	 */

	ld	FPTR, r31, 0	/* grab exception frame pointer */
	ld	r3, FPTR, REG_OFF(EF_DMT0)
	bb0	DMT_VALID_BIT, r3, _ASM_LABEL(check_ast)

	/*
	 * If it's the interrupt exception, and interrupts were
	 * initially disabled, enable interrupts again...
	 */
	ld	r2, FPTR, REG_OFF(EF_VECTOR)
	cmp	r2, r2, 1	/* is an interrupt? */
	bb1.n	ne, r2, 1f	/* if not so, skip */

	/* ...unless they were already disabled */
	 ld	r2, FPTR, REG_OFF(EF_EPSR)
	bb1.n	PSR_INTERRUPT_DISABLE_BIT, r2, 1f

	 ldcr	r2, PSR
	clr	r2, r2, 1<PSR_INTERRUPT_DISABLE_BIT>
	stcr	r2, PSR
	FLUSH_PIPELINE
1:

	CALL(m88100_trap, T_DATAFLT, r30)
#ifdef M88110
	br	_ASM_LABEL(check_ast)
#else
	/* FALLTHROUGH */
#endif
#endif /* M88100 */

#ifdef M88110
ASLOCAL(m88110_return_code)
#define	FPTR	r14
	ld	FPTR, r31, 0	/* grab exception frame pointer */
	/* FALLTHROUGH */
#endif /* M88110 */

/*
 *   If the saved ipl is 0, then call dosoftint() to process soft
 *   interrupts.
 *   If returning to userland, look for ASTs.
 */
ASLOCAL(check_ast)
	/* do not service soft interrupts if interrupts were disabled... */
	ld	r2, FPTR, REG_OFF(EF_EPSR)
	bb1	PSR_INTERRUPT_DISABLE_BIT, r2, _ASM_LABEL(no_softint)
	/* ...or we were not at spl0 */
	ld	r2, FPTR, REG_OFF(EF_MASK)
	bcnd	ne0, r2, _ASM_LABEL(no_softint)

	/* do an inline spl0() */
	bsr.n	_C_LABEL(setipl)
	 or	r2, r0, IPL_SOFTCLOCK
	bsr	_C_LABEL(dosoftint)
	bsr.n	_C_LABEL(setipl)
	 or	r2, r0, IPL_NONE

ASLOCAL(no_softint)
	/* do not service AST if not returning to user mode */
	ld	r2, FPTR, REG_OFF(EF_EPSR)
	bb1	PSR_SUPERVISOR_MODE_BIT, r2, _ASM_LABEL(no_ast)

	ldcr	r2,  CPU
	ld	r3,  r2, CI_CURPROC
	bcnd	eq0, r3, _ASM_LABEL(no_ast)	/* no AST if no process! */
	ld	r2,  r3, P_ASTPENDING
	bcnd.n	eq0, r2, _ASM_LABEL(no_ast)	/* .n safe since the first
						   instruction of CALL() is
						   safe in a delay slot. */
	/*
	 * trap(AST,...) will service ast's.
	 */
#if defined(M88110) && defined(M88100)
	 or.u	r2, r0, hi16(_C_LABEL(cputyp))
	ld	r3, r2, lo16(_C_LABEL(cputyp))
	cmp	r2, r3, CPU_88110
	bb0	eq, r2, 2f
#endif
#if defined(M88110)
	CALL(m88110_trap, T_ASTFLT, FPTR)
#endif
#if defined(M88110) && defined(M88100)
	br	_ASM_LABEL(no_ast)
2:
#endif
#ifdef M88100
	CALL(m88100_trap, T_ASTFLT, FPTR)
#endif

ASLOCAL(no_ast)
	/* disable interrupts */
	ldcr	r1, PSR
	set	r1, r1, 1<PSR_INTERRUPT_DISABLE_BIT>
	stcr	r1, PSR
	FLUSH_PIPELINE

	/* now ready to return....*/
	bsr.n	_C_LABEL(setipl)
	 ld	r2, FPTR, REG_OFF(EF_MASK)	/* get pre-exception ipl */

	/*
	 * Transfer the frame pointer to r31, since we no longer need a stack.
	 * No page faults here, and interrupts are disabled.
	 */
	or	r31, r0,  FPTR
	/* restore r1 later */
	ld	r2 , r31, GENREG_OFF(2)
	ld	r3 , r31, GENREG_OFF(3)
	ld	r4 , r31, GENREG_OFF(4)
	ld	r5 , r31, GENREG_OFF(5)
	ld	r6 , r31, GENREG_OFF(6)
	ld	r7 , r31, GENREG_OFF(7)
	ld	r8 , r31, GENREG_OFF(8)
	ld	r9 , r31, GENREG_OFF(9)
	ld	r10, r31, GENREG_OFF(10)
	ld	r11, r31, GENREG_OFF(11)
	ld	r12, r31, GENREG_OFF(12)
	ld	r13, r31, GENREG_OFF(13)
	ld	r14, r31, GENREG_OFF(14)
	ld	r15, r31, GENREG_OFF(15)
	ld	r16, r31, GENREG_OFF(16)
	ld	r17, r31, GENREG_OFF(17)
	ld	r18, r31, GENREG_OFF(18)
	ld	r19, r31, GENREG_OFF(19)
	ld	r20, r31, GENREG_OFF(20)
	ld	r21, r31, GENREG_OFF(21)
	ld	r22, r31, GENREG_OFF(22)
	ld	r23, r31, GENREG_OFF(23)
	ld	r24, r31, GENREG_OFF(24)
	ld	r25, r31, GENREG_OFF(25)
	ld	r26, r31, GENREG_OFF(26)
	ld	r27, r31, GENREG_OFF(27)
	ld	r28, r31, GENREG_OFF(28)
	ld	r29, r31, GENREG_OFF(29)
	/* restore r1, r30, r31 later */

	/* disable shadowing */
	ldcr	r1, PSR
	set	r1, r1, 1<PSR_SHADOW_FREEZE_BIT>
	stcr	r1, PSR
	FLUSH_PIPELINE

	/* reload the control regs*/
#ifdef M88110
#ifdef M88100
	or.u	r1, r0, hi16(_C_LABEL(cputyp))
	ld	r30, r1, lo16(_C_LABEL(cputyp))
	cmp	r1, r30, CPU_88110
	bb1	ne, r1, 1f
#endif
	ld	r30, r31, REG_OFF(EF_ENIP)
	ld	r1,  r31, REG_OFF(EF_EXIP)
	stcr	r30, ENIP
	stcr	r1,  EXIP
#ifdef M88100
	br	2f
1:
#endif
#endif
#ifdef M88100
	/*
	 * RTE will cause execution to continue first with the
	 * instruction pointed to by the NIP and then the FIP;
	 * it is not necessary to restore XIP.
	 */
	stcr	r0,  SSBR
	ld	r30, r31, REG_OFF(EF_SNIP)
	ld	r1,  r31, REG_OFF(EF_SFIP)
	stcr	r30, SNIP
	stcr	r1,  SFIP
2:
#endif
	ld	r30, r31, REG_OFF(EF_EPSR)
	stcr	r30, EPSR

	/* Now restore r1, r30, and r31 */
	ld	r1,  r31, GENREG_OFF(1)
	ld	r30, r31, GENREG_OFF(30)
	ld	r31, r31, GENREG_OFF(31)

	RTE

d2320 244
@


1.20
log
@Rework the PFSR register analysis code on mvme88k: split it into four
independent subfunctions, turn PFSR_SAVE into a couple of NOP, and replace
them early at runtime with a branch to the selected routine, which will
return to pfsr_save.
This is really better for 188 systems.
@
text
@d1 1
a1 1
/*   $OpenBSD: eh_common.S,v 1.19 2006/05/14 08:37:39 miod Exp $	*/
d1701 3
a1703 3
	bcnd.n	eq0, r3, _ASM_LABEL(no_ast)	/* no AST if no process! */
	 ld	r2,  r3, P_ASTPENDING
	bcnd.n	eq0, r3, _ASM_LABEL(no_ast)	/* .n safe since the first
@


1.19
log
@Missing semicolon, found by deraadt
@
text
@d1 1
a1 1
/*   $OpenBSD: eh_common.S,v 1.18 2006/05/08 14:34:01 miod Exp $	*/
d1079 1
a1079 1
ASLOCAL(pfsr_save)
@


1.18
log
@Optimize bsr + br sequences commonly found in the individual trap handlers,
save one cycle and some pipeline costs per trap.
@
text
@d1 1
a1 1
/*   $OpenBSD: eh_common.S,v 1.17 2006/05/08 14:03:34 miod Exp $	*/
d330 1
a330 1
	ld	r31, r31, GENREG_OFF(31)
@


1.17
log
@Clean the internal m88k trap type codes; while there, simplify and
factorize the build of the VBR page betweem luna88k and mvme88k.

Tested by aoyama@@ and I.
@
text
@d1 1
a1 1
/*   $OpenBSD: eh_common.S,v 1.16 2005/12/11 21:45:30 miod Exp $	*/
d239 5
d341 4
a344 3
 *		PREP88100("foo", 11, SSBR_Stuff, Precheck_Stuff)
 *		CALL(trapXXX, T_FOO_FAULT, r31)
 *		DONE88100
d359 1
a359 1
 * What's in between PREP881x0() and DONE881x0() (usually a CALL)
d362 1
a362 1
 * exception frame (which is pointed to by r31).
d368 1
a368 1
	FLAG_PRECHECK					; \
d383 1
a383 1
	SSBR_STUFF					; \
d391 1
a391 1
	SAVE_CTX					; \
d393 1
a393 1
	FLAG_PRECHECK					; \
d413 1
a413 1
	bsr	_ASM_LABEL(clear_dest_ssbr_bit)
d416 1
a416 1
	    _ASM_LABEL(m88100_ignore_data_exception)
d419 1
a419 6
	    _ASM_LABEL(m88110_ignore_data_exception)

#define	DONE88100 \
	br	_ASM_LABEL(m88100_return_code)
#define	DONE88110 \
	br	_ASM_LABEL(m88110_return_code)
d423 1
a423 1
 * MVME18x exception handlers
d429 3
a431 2
	CALL(m88100_trap, T_UNKNOWNFLT, r30)
	DONE88100
d436 3
a438 2
	CALL(m88100_trap, T_INT, r30)
	DONE88100
d443 3
a445 2
	CALL(m88100_trap, T_INSTFLT, r30)
	DONE88100
d454 1
a454 1
	DONE88100
d459 3
a461 2
	CALL(m88100_trap, T_MISALGNFLT, r30)
	DONE88100
d466 3
a468 2
	CALL(m88100_trap, T_ILLFLT, r30)
	DONE88100
d482 3
a484 2
	CALL(m88100_trap, T_PRIVINFLT, r30)
	DONE88100
d489 3
a491 2
	CALL(m88100_trap, T_BNDFLT, r30)
	DONE88100
d496 3
a498 2
	CALL(m88100_trap, T_ZERODIV, r30)
	DONE88100
d503 3
a505 2
	CALL(m88100_trap, T_OVFFLT, r30)
	DONE88100
d509 1
a509 1
	bsr	_ASM_LABEL(clear_FPp_ssbr_bit)
d512 2
a513 3
	bsr.n	_ASM_LABEL(m88100_Xfp_precise)
	 or	r3, r0, r30
	DONE88100
d517 1
a517 1
	bsr	_ASM_LABEL(clear_FPi_ssbr_bit)
d520 2
a521 3
	bsr.n	_ASM_LABEL(Xfp_imprecise)
	 or	r3, r0, r30
	DONE88100
d527 2
a528 3
	bsr.n	_C_LABEL(m88100_syscall)
	 or	r3, r0, r30
	DONE88100
d533 2
a534 3
	bsr.n	_C_LABEL(cache_flush)
	 or	r2, r0, r30
	DONE88100
d538 3
a540 2
	CALL(m88100_trap, T_SIGSYS, r30)
	DONE88100
d544 3
a546 2
	CALL(m88100_trap, T_STEPBPT, r30)
	DONE88100
d550 3
a552 2
	CALL(m88100_trap, T_USERBPT, r30)
	DONE88100
d557 3
a559 2
	CALL(m88100_trap, T_KDB_BREAK, r30)
	DONE88100
d563 3
a565 2
	CALL(m88100_trap, T_KDB_TRACE, r30)
	DONE88100
d569 3
a571 2
	CALL(m88100_trap, T_KDB_ENTRY, r30)
	DONE88100
d1821 1
a1821 1
 * MVME197 exception handlers
d1827 3
a1829 2
	CALL(m88110_trap, T_UNKNOWNFLT, r30)
	DONE88110
d1834 3
a1836 2
	CALL(m88110_trap, T_INT, r30)
	DONE88110
d1841 3
a1843 2
	CALL(m88110_trap, T_INSTFLT, r30)
	DONE88110
d1850 3
a1852 2
	CALL(m88110_trap, T_DATAFLT, r30)
	DONE88110
d1857 3
a1859 2
	CALL(m88110_trap, T_MISALGNFLT, r30)
	DONE88110
d1864 3
a1866 2
	CALL(m88110_trap, T_ILLFLT, r30)
	DONE88110
d1871 3
a1873 2
	CALL(m88110_trap, T_PRIVINFLT, r30)
	DONE88110
d1875 1
a1875 4
/*
 * I'm not sure what the trap(T_BNDFLT,...) does, but it doesn't send
 * a signal to the process...
 */
d1878 3
a1880 2
	CALL(m88110_trap, T_BNDFLT, r30)
	DONE88110
d1885 3
a1887 2
	CALL(m88110_trap, T_ZERODIV, r30)
	DONE88110
d1892 3
a1894 2
	CALL(m88110_trap, T_OVFFLT, r30)
	DONE88110
d1899 2
a1900 3
	bsr.n	_ASM_LABEL(m88110_Xfp_precise)
	 or	r3, r0, r30
	DONE88110
d1904 4
a1907 3
	PREP88110("MVME197 non-mask", 11,)
	CALL(m88110_trap, T_NON_MASK, r30)
	DONE88110
d1909 1
a1909 1
/* MVME197 data MMU read miss handler */
d1911 4
a1914 3
	PREP88110("MVME197 data read miss", 12,)
	CALL(m88110_trap, T_110_DRM, r30)
	DONE88110
d1916 1
a1916 1
/* MVME197 data MMU write miss handler */
d1918 4
a1921 3
	PREP88110("MVME197 data write miss", 13,)
	CALL(m88110_trap, T_110_DRM, r30)
	DONE88110
d1923 1
a1923 1
/* MVME197 inst MMU ATC miss handler */
d1925 4
a1928 3
	PREP88110("MVME197 inst ATC miss", 14,)
	CALL(m88110_trap, T_110_IAM, r30)
	DONE88110
d1934 2
a1935 3
	bsr.n	_C_LABEL(m88110_syscall)
	 or	r3, r0, r30
	DONE88110
d1940 2
a1941 3
	bsr.n	_C_LABEL(cache_flush)
	 or	r2, r0, r30
	DONE88110
d1945 3
a1947 2
	CALL(m88110_trap, T_SIGSYS, r30)
	DONE88110
d1951 3
a1953 2
	CALL(m88110_trap, T_STEPBPT, r30)
	DONE88110
d1957 3
a1959 2
	CALL(m88110_trap, T_USERBPT, r30)
	DONE88110
d1964 3
a1966 2
	CALL(m88110_trap, T_KDB_BREAK, r30)
	DONE88110
d1970 3
a1972 2
	CALL(m88110_trap, T_KDB_TRACE, r30)
	DONE88110
d1976 3
a1978 2
	CALL(m88110_trap, T_KDB_ENTRY, r30)
	DONE88110
@


1.16
log
@Work in progress SMP code; mvme88k boards can spin up secondary CPUs,
kernel boots single user. Still a lot of polishing and bugfixing to do.
@
text
@d1 1
a1 1
/*   $OpenBSD: eh_common.S,v 1.15 2005/12/03 18:20:50 miod Exp $	*/
a534 5
GLOBAL(sigtrap)
	PREP88100("sigtrap", 510,,)
	CALL(m88100_trap, T_SIGTRAP, r30)
	DONE88100

a559 15
#else
GLOBAL(break)
	PREP88100("break", 130,,)
	CALL(m88100_trap, T_UNKNOWNFLT, r30)
	DONE88100

GLOBAL(trace)
	PREP88100("trace", 131,,)
	CALL(m88100_trap, T_UNKNOWNFLT, r30)
	DONE88100

GLOBAL(entry)
	PREP88100("unknown", 132,,)
	CALL(m88100_trap, T_UNKNOWNFLT, r30)
	DONE88100
d1892 2
a1893 2
	PREP88110("MVME197 read miss", 12,)
	CALL(m88110_trap, T_197_READ, r30)
d1898 2
a1899 2
	PREP88110("MVME197 write miss", 13,)
	CALL(m88110_trap, T_197_WRITE, r30)
d1904 2
a1905 2
	PREP88110("MVME197 inst miss", 14,)
	CALL(m88110_trap, T_197_INST, r30)
a1927 5
GLOBAL(m88110_sigtrap)
	PREP88110("sigtrap", 510,)
	CALL(m88110_trap, T_SIGTRAP, r30)
	DONE88110

a1951 15
	DONE88110
#else
GLOBAL(m88110_break)
	PREP88110("break", 130,)
	CALL(m88110_trap, T_UNKNOWNFLT, r30)
	DONE88110

GLOBAL(m88110_trace)
	PREP88110("trace", 131,)
	CALL(m88110_trap, T_UNKNOWNFLT, r30)
	DONE88110

GLOBAL(m88110_entry)
	PREP88110("unknown", 132,)
	CALL(m88110_trap, T_UNKNOWNFLT, r30)
@


1.15
log
@intstack does not need to be visible from C code anymore.
@
text
@d1 1
a1 1
/*   $OpenBSD: eh_common.S,v 1.14 2005/12/03 14:30:06 miod Exp $	*/
d225 3
a227 3
#define FLAG_IGNORE_DATA_EXCEPTION	5
#define FLAG_ENABLING_FPU		7
#define FLAG_FROM_KERNEL		8
d1594 3
@


1.14
log
@Switch m88k ports to __HAVE_CPUINFO. Current cpu pointer is held in SR0
on all running processors.
Tested aoyama@@ and I
@
text
@d1 1
a1 1
/*   $OpenBSD: eh_common.S,v 1.13 2005/11/28 22:21:15 miod Exp $	*/
d615 2
a616 2
	or.u	r27, r0,  hi16(_C_LABEL(intstack))
	or	r27, r27, lo16(_C_LABEL(intstack))
d2023 2
a2024 2
	or.u	r27, r0,  hi16(_C_LABEL(intstack))
	or	r27, r27, lo16(_C_LABEL(intstack))
@


1.13
log
@Switch to per-process AST flags and clean AST-related codepaths; speeds up
forks as a bonus.
Tested on luna88k and mvme88k by aoyama@@ martin@@ and I.
@
text
@d1 1
a1 1
/*   $OpenBSD: eh_common.S,v 1.12 2005/10/12 19:05:44 miod Exp $	*/
d136 1
a136 1
 *    violation exception, or the misaligned access exception, the
a174 1
 *
a212 4
 * XXX clean this when the trap handler is reworked. Among the things
 * I like to see is having the trap frame on the kernel stack instead
 * of putting in the PCB. If done properly, we don't need SR1 for doing
 * anything special. nivas
d245 4
a248 4
#define	FLAGS	r2
#define	TMP	r3
#define	TMP2	r10
#define	TMP3	r11
a608 1
	/* pick up the slavestack */
d740 1
a740 1
	 * SR3: must presere
d750 1
a750 1
	 * We don't worry about trashing R2 here because we're
d1007 2
a1008 2
	or.u	r1,   r0,   hi16(_C_LABEL(curpcb))
	ld	r1,   r1,   lo16(_C_LABEL(curpcb))
d1035 2
a1036 2
	or.u	r31,  r0,   hi16(_C_LABEL(curpcb))
	ld	r31,  r31,  lo16(_C_LABEL(curpcb))
d1079 2
a1080 2
	/* get and store the cpu number */
	extu	TMP,  FLAGS,  FLAG_CPU_FIELD_WIDTH<0>	/* TMP = cpu# */
d1528 2
a1529 2
	or.u	r31,  r0,   hi16(_C_LABEL(curpcb))
	ld	r31,  r31,  lo16(_C_LABEL(curpcb))
d1704 2
a1705 2
	or.u	r2,  r0, hi16(_C_LABEL(curproc))
	ld	r3,  r2, lo16(_C_LABEL(curproc))
a2016 1
	/* pick up the slavestack */
d2265 2
a2266 2
	or.u	r1,   r0,   hi16(_C_LABEL(curpcb))
	ld	r1,   r1,   lo16(_C_LABEL(curpcb))
d2294 2
a2295 2
	or.u	r31,  r0,   hi16(_C_LABEL(curpcb))
	ld	r31,  r31,  lo16(_C_LABEL(curpcb))
d2339 2
a2340 2
	/* get and store the cpu number */
	extu	TMP,  FLAGS,  FLAG_CPU_FIELD_WIDTH<0>	/* TMP = cpu# */
d2529 2
a2530 2
	or.u	r31,  r0,   hi16(_C_LABEL(curpcb))
	ld	r31,  r31,  lo16(_C_LABEL(curpcb))
@


1.12
log
@Stop mapping the u area at fixed UADDR in addition to its actual va.
While there, attempt to clean and comment stack usage in the kernel.
No functional change.

From the m88k SMP tree; help&test martin@@
@
text
@d1 1
a1 1
/*   $OpenBSD: eh_common.S,v 1.11 2005/09/25 20:30:03 miod Exp $	*/
d1590 3
a1592 2
 * proc_trampoline.
 * When a process setup by cpu_set_kpc() resumes, it will find itself in
d1596 1
a1596 1
 * jump there.
d1609 2
d1612 6
a1617 4
 * proc_do_uret
 * this is called as proc_do_uret(proc) from proc_trampoline(). This function
 * loads r31 with a pointer to the trap frame for the given proc and calls
 * return_code which loads all the registers and does an RTE.
d1621 4
a1624 12
	ld	r3,r2,P_ADDR		/* p->p_addr */
	addu	r3,r3,PCB_USER_STATE	/* p->p_addr.u_pcb.user_state */
	st	r3,r31,0		/* put it on the stack */
#if defined(M88100) && defined(M88110)
#ifdef M88110
	or.u	r2, r0, hi16(_C_LABEL(cputyp))
	ld	r3, r2, lo16(_C_LABEL(cputyp))
	cmp	r2, r3, CPU_88110
	bb1	eq, r2, _ASM_LABEL(m88110_return_code)
	/* br	_ASM_LABEL(m88100_return_code) */
#endif
#endif
a1647 1
#define	FPTR	r14
d1688 1
a1688 1
 *   If returning to user land, look for ASTs
d1691 6
a1696 4
	ld	r2, FPTR, REG_OFF(EF_EPSR)	/* get pre-exception PSR */
	bb1	PSR_INTERRUPT_DISABLE_BIT, r2, 1f	/* skip if ints off */
	ld	r2, FPTR, REG_OFF(EF_MASK)	/* get pre-exception ipl */
	bcnd	ne0, r2, 1f		/* can't do softint's */
d1698 1
a1700 1
	/* at ipl 1 now */
a1701 1
	/* is this needed? we are going to restore the ipl below XXX nivas */
d1703 1
a1703 11
	 or	r2, r0, IPL_NONE		/* ints are enabled */
	/* at ipl 0 now */
1:
	ld	r2, FPTR, REG_OFF(EF_EPSR)	/* get pre-exception PSR */
	bb1	PSR_SUPERVISOR_MODE_BIT, r2, no_ast	/*skip if system mode */

	/* should assert here - not in user mode with ints off XXX nivas */
	/* get and check want_ast */
	or.u	r2, r0, hi16(_C_LABEL(want_ast))
	ld	r3, r2, lo16(_C_LABEL(want_ast))
	bcnd	eq0, r3, no_ast
d1705 12
d1721 1
a1721 1
	or.u	r2, r0, hi16(_C_LABEL(cputyp))
d1730 1
a1730 1
	br	no_ast
@


1.11
log
@Do not consider userland trap #496 (BUG system call on mvme88k) as special
anymore, since we don't want to allow userland to talk to the BUG. Deliver
SIGSYS instead of doing nothing. Makes things simpler, plus it polluted
luna88k.
@
text
@d1 1
a1 1
/*   $OpenBSD: eh_common.S,v 1.10 2005/04/30 16:46:51 miod Exp $	*/
d1013 3
a1015 3
	or.u	r1,   r0,   hi16(_ASM_LABEL(kstack))
	ld	r1,   r1,   lo16(_ASM_LABEL(kstack))
	addu	r1,   r1,   USIZE-SIZEOF_EF
d1044 8
d1534 2
a1535 2
	or.u	r31,  r0,   hi16(_ASM_LABEL(kstack))
	ld	r31,  r31,  lo16(_ASM_LABEL(kstack))
d2273 3
a2275 3
	or.u	r1,   r0,   hi16(_ASM_LABEL(kstack))
	ld	r1,   r1,   lo16(_ASM_LABEL(kstack))
	addu	r1,   r1,   USIZE-SIZEOF_EF
d2305 8
d2537 2
a2538 2
	or.u	r31,  r0,   hi16(_ASM_LABEL(kstack))
	ld	r31,  r31,  lo16(_ASM_LABEL(kstack))
@


1.10
log
@Move CALL() from <machine/asm.h> to eh.S which is the only user of the macro,
and replace it with faster constructs in some cases; also drop the unused
CALLP() macro.
@
text
@d1 1
a1 1
/*   $OpenBSD: eh_common.S,v 1.9 2005/04/27 21:12:46 miod Exp $	*/
a534 8
/* trap 496: BUG system calls */
GLOBAL(bugtrap)
	PREP88100("bugsyscall", 496,,)
	ld	r2, r30, GENREG_OFF(9)
	bsr.n	_C_LABEL(bugsyscall)
	 or	r3, r0, r30
	DONE88100

a1936 8
	DONE88110

/* trap 496: BUG system calls */
GLOBAL(m88110_bugtrap)
	PREP88110("bugsyscall", 496,)
	ld	r2,  r30, GENREG_OFF(9)
	bsr.n	_C_LABEL(bugsyscall)
	 or	r3, r0, r30
@


1.9
log
@Shave more stack operations, courtesy of the not-so-new-now ABI.
@
text
@d1 1
a1 1
/*   $OpenBSD: eh_common.S,v 1.8 2005/04/27 14:09:45 miod Exp $	*/
d238 6
d342 1
a342 1
 *		CALL(_C_LABEL(trapXXX), T_FOO_FAULT, r31)
d433 1
a433 1
	CALL(_C_LABEL(m88100_trap), T_UNKNOWNFLT, r30)
d439 1
a439 1
	CALL(_C_LABEL(m88100_trap), T_INT, r30)
d445 1
a445 1
	CALL(_C_LABEL(m88100_trap), T_INSTFLT, r30)
d460 1
a460 1
	CALL(_C_LABEL(m88100_trap), T_MISALGNFLT, r30)
d466 1
a466 1
	CALL(_C_LABEL(m88100_trap), T_ILLFLT, r30)
d481 1
a481 1
	CALL(_C_LABEL(m88100_trap), T_PRIVINFLT, r30)
d487 1
a487 1
	CALL(_C_LABEL(m88100_trap), T_BNDFLT, r30)
d493 1
a493 1
	CALL(_C_LABEL(m88100_trap), T_ZERODIV, r30)
d499 1
a499 1
	CALL(_C_LABEL(m88100_trap), T_OVFFLT, r30)
d507 2
a508 1
	CALL(_ASM_LABEL(m88100_Xfp_precise), r0, r30)
d516 2
a517 1
	CALL(_ASM_LABEL(Xfp_imprecise), r0, r30)
d523 3
a525 2
	ld	r13, r30, GENREG_OFF(13)
	CALL(_C_LABEL(m88100_syscall), r13, r30)
d538 3
a540 2
	ld	r9, r30, GENREG_OFF(9)
	CALL(_C_LABEL(bugsyscall), r9, r30)
d545 1
a545 1
	CALL(_C_LABEL(m88100_trap), T_SIGSYS, r30)
d550 1
a550 1
	CALL(_C_LABEL(m88100_trap), T_SIGTRAP, r30)
d555 1
a555 1
	CALL(_C_LABEL(m88100_trap), T_STEPBPT, r30)
d560 1
a560 1
	CALL(_C_LABEL(m88100_trap), T_USERBPT, r30)
d566 1
a566 1
	CALL(_C_LABEL(m88100_trap), T_KDB_BREAK, r30)
d571 1
a571 1
	CALL(_C_LABEL(m88100_trap), T_KDB_TRACE, r30)
d576 1
a576 1
	CALL(_C_LABEL(m88100_trap), T_KDB_ENTRY, r30)
d581 1
a581 1
	CALL(_C_LABEL(m88100_trap), T_UNKNOWNFLT, r30)
d586 1
a586 1
	CALL(_C_LABEL(m88100_trap), T_UNKNOWNFLT, r30)
d591 1
a591 1
	CALL(_C_LABEL(m88100_trap), T_UNKNOWNFLT, r30)
d732 2
a733 1
	CALL(_C_LABEL(error_fatal), r30, r30)
d1582 1
a1582 1
	CALL(_C_LABEL(m88100_trap), T_DATAFLT, r15)
d1674 1
a1674 1
	CALL(_C_LABEL(m88100_trap), T_DATAFLT, r30)
d1728 1
a1728 1
	CALL(_C_LABEL(m88110_trap), T_ASTFLT, FPTR)
d1735 1
a1735 1
	CALL(_C_LABEL(m88100_trap), T_ASTFLT, FPTR)
d1839 1
a1839 1
	CALL(_C_LABEL(m88110_trap), T_UNKNOWNFLT, r30)
d1845 1
a1845 1
	CALL(_C_LABEL(m88110_trap), T_INT, r30)
d1851 1
a1851 1
	CALL(_C_LABEL(m88110_trap), T_INSTFLT, r30)
d1859 1
a1859 1
	CALL(_C_LABEL(m88110_trap), T_DATAFLT, r30)
d1865 1
a1865 1
	CALL(_C_LABEL(m88110_trap), T_MISALGNFLT, r30)
d1871 1
a1871 1
	CALL(_C_LABEL(m88110_trap), T_ILLFLT, r30)
d1877 1
a1877 1
	CALL(_C_LABEL(m88110_trap), T_PRIVINFLT, r30)
d1886 1
a1886 1
	CALL(_C_LABEL(m88110_trap), T_BNDFLT, r30)
d1892 1
a1892 1
	CALL(_C_LABEL(m88110_trap), T_ZERODIV, r30)
d1898 1
a1898 1
	CALL(_C_LABEL(m88110_trap), T_OVFFLT, r30)
d1904 2
a1905 1
	CALL(_ASM_LABEL(m88110_Xfp_precise), r0, r30)
d1911 1
a1911 1
	CALL(_C_LABEL(m88110_trap), T_NON_MASK, r30)
d1917 1
a1917 1
	CALL(_C_LABEL(m88110_trap), T_197_READ, r30)
d1923 1
a1923 1
	CALL(_C_LABEL(m88110_trap), T_197_WRITE, r30)
d1929 1
a1929 1
	CALL(_C_LABEL(m88110_trap), T_197_INST, r30)
d1935 3
a1937 2
	ld	r13, r30, GENREG_OFF(13)
	CALL(_C_LABEL(m88110_syscall), r13, r30)
d1950 3
a1952 2
	ld	r9,  r30, GENREG_OFF(9)
	CALL(_C_LABEL(bugsyscall), r9, r30)
d1957 1
a1957 1
	CALL(_C_LABEL(m88110_trap), T_SIGSYS, r30)
d1962 1
a1962 1
	CALL(_C_LABEL(m88110_trap), T_SIGTRAP, r30)
d1967 1
a1967 1
	CALL(_C_LABEL(m88110_trap), T_STEPBPT, r30)
d1972 1
a1972 1
	CALL(_C_LABEL(m88110_trap), T_USERBPT, r30)
d1978 1
a1978 1
	CALL(_C_LABEL(m88110_trap), T_KDB_BREAK, r30)
d1983 1
a1983 1
	CALL(_C_LABEL(m88110_trap), T_KDB_TRACE, r30)
d1988 1
a1988 1
	CALL(_C_LABEL(m88110_trap), T_KDB_ENTRY, r30)
d1993 1
a1993 1
	CALL(_C_LABEL(m88110_trap), T_UNKNOWNFLT, r30)
d1998 1
a1998 1
	CALL(_C_LABEL(m88110_trap), T_UNKNOWNFLT, r30)
d2003 1
a2003 1
	CALL(_C_LABEL(m88110_trap), T_UNKNOWNFLT, r30)
d2163 2
a2164 1
	CALL(_C_LABEL(error_fatal), r30, r30)
@


1.8
log
@Allow userland to cause the data cache to be flushed for any arbitrary address
range in the current process, using trap #451.

This is necessary for proper gcc trampolines operation, and, later, ld.so...
@
text
@d1 1
a1 1
/*   $OpenBSD: eh_common.S,v 1.7 2005/04/19 18:37:52 mickey Exp $	*/
a521 1
	sub	r31, r31, 32
a523 1
	add	r31, r31, 32
a890 1
	subu	r31, r31, 32
a894 1
	addu	r31, r31, 32
a1481 1
	st	r29,  r31,  GENREG_OFF(29)
d1485 1
a1485 2
	 subu	r31, r31, 32
	addu	r31, r31, 32
d1591 1
a1591 2
	 subu	r31, r31, 32		/* create stack space for function */
	addu	r31, r31, 32 + 8	/* stack space above + ksigframe */
a1688 1
	subu	r31, r31, 32
a1695 1
	addu	r31, r31, 32
a1734 1
	subu	r31, r31, 32
a1736 1
	addu	r31, r31, 32
a1929 1
	sub	r31, r31, 32
a1931 1
	add	r31, r31, 32
a2480 1
	st	r29,  r31,  GENREG_OFF(29)
d2484 1
a2484 2
	 subu	r31, r31, 32
	addu	r31, r31, 32
@


1.7
log
@fix comment
@
text
@d1 1
a1 1
/*   $OpenBSD: eh_common.S,v 1.6 2004/09/15 05:56:33 miod Exp $	*/
d71 2
a72 2
 * kernel operations.  For example, "tcnd eq0, r0, 128" will raise
 * exception 128, the system call exception.
d512 1
a512 1
/* All standard system calls.  */
d514 1
a514 1
	PREP88100("syscall", 128,,)
d519 10
a528 1
/* trap 496 comes here */
d1626 1
a1626 1
	 * Regs r1-r30 are free. R31 is pointing at the word
d1931 1
a1931 1
/* All standard system calls.  */
d1933 1
a1933 1
	PREP88110("syscall", 128,)
d1938 10
a1947 1
/* trap 496 comes here */
d2100 1
a2100 1
	/* retrieve saved shadow registers for error_handler, though) */
@


1.6
log
@Win a cycle in FP exception SSBR processing.
@
text
@d1 1
a1 1
/*   $OpenBSD: eh_common.S,v 1.5 2004/08/05 21:34:11 miod Exp $	*/
d144 1
a144 1
 *    hardware) and allowed to complete actions in progress. This is so
@


1.5
log
@Unbreak luna88k; spotted by aoyama@@
@
text
@d1 1
a1 1
/*   $OpenBSD: eh_common.S,v 1.4 2004/08/02 08:34:59 miod Exp $	*/
a1244 1
1:
d1254 2
a1255 2
	clr	TMP,  TMP,  TMP3	/* clear bit(s) in ssbr. */
	jmp	r1
@


1.4
log
@More include files cleaning:
- move MAX_CPUS constant to <machine/cpu.h>
- do not include <machine/board.h> unless needed. In fact, remove this file
  entirely on mvme88k, and include <machine/mvme*.h> on a
  compiling-for-this-board basis
- keep MAX_CMMUS constant private to the m8820x code
@
text
@d1 1
a1 1
/*   $OpenBSD: eh_common.S,v 1.3 2004/07/28 12:28:48 miod Exp $	*/
a209 3
#ifdef MVME188
#include <machine/m8820x.h>
#endif
@


1.3
log
@Remove EH_DEBUG code.
@
text
@d1 1
a1 1
/*   $OpenBSD: eh_common.S,v 1.2 2004/07/28 12:28:07 miod Exp $	*/
a209 1
#include <machine/board.h>
@


1.2
log
@Keep exception specific defines in the exception handling code, instead of
polluting the kernel namespace.
@
text
@d1 1
a1 1
/*   $OpenBSD: eh_common.S,v 1.1 2004/07/27 12:16:06 miod Exp $	*/
d333 1
a333 1
 * #define PREP881x0(NAME, NUM, BIT, SSBR_STUFF, FLAG_CHECK)
d339 1
a339 1
 *		PREP88100("foo", 11, DEBUG_FOO_BIT, SSBR_Stuff, Precheck_Stuff)
d341 1
a341 1
 *		DONE88100(DEBUG_FOO_BIT)
a348 2
 * BIT
 *	Bit to check in eh_debug for debugging (more info later)
d363 1
a363 1
#define PREP88100(NAME, NUM, BIT, SSBR_STUFF, FLAG_PRECHECK) \
d383 1
a383 3
	bsr	_ASM_LABEL(m88100_setup_phase_two)	; \
	/* All general regs free -- do any debugging */	  \
	PREP_DEBUG(BIT, NAME)
d387 1
a387 1
#define PREP88110(NAME, NUM, BIT, FLAG_PRECHECK) \
d405 1
a405 3
	bsr	_ASM_LABEL(m88110_setup_phase_two)	; \
	/* All general regs free -- do any debugging */	; \
	PREP_DEBUG(BIT, NAME)
d418 1
a418 68
#ifdef EH_DEBUG
/*
 * If we allow debugging, there is a variable "eh_debug"
 * in which there is a bit for each exception.  If the bit
 * is set for an exception, debugging information is printed
 * about that exception whenever it occurs.
 *
 * The bits are defined in "asm.h"
 */

ASGLOBAL(eh_debug)
	word	0x00000000

/*
 * additional pre-servicing preparation to be done when
 * debugging... check eh_debug and make the call if
 * need be.
 */
#define PREP_DEBUG(DebugNumber, Name) \
	or.u	r2, r0, hi16(_ASM_LABEL(eh_debug))	; \
	ld	r3, r2, lo16(_ASM_LABEL(eh_debug))	; \
	bb0	DebugNumber, r3, 4f			; \
	/* call MY_info(ef,SR0,flags,kind)*/		  \
	or	r2, r30, r0				; \
	ldcr	r3, SR0					; \
	ldcr	r4, SR1					; \
	or.u	r5, r0, hi16(2f)			; \
	or	r5, r5, lo16(2f)			; \
	bsr.n	_C_LABEL(MY_info)			; \
	 subu	r31, r31, 32				; \
	br.n	4f					; \
	 addu	r31, r31, 32				; \
	data						; \
2:	string Name					; \
	byte	0					; \
	align	4					; \
	text						; \
4:


/*
 * Post-servicing work to be done.
 * When debugging, check "eh_debug" and call the
 * debug routined if neeed be.
 *
 * Then, return from the interrupt handler.
 */
#define DONE88100(DebugNumber) \
	or.u	r2, r0, hi16(_ASM_LABEL(eh_debug))	; \
	ld	r3, r2, lo16(_ASM_LABEL(eh_debug))	; \
	bb0	DebugNumber, r3, 2f			; \
	ldcr	r4, SR1					; \
	CALL(_C_LABEL(MY_info_done), r31, r4)		; \
2:	br	_ASM_LABEL(m88100_return_code)
#define DONE88110(DebugNumber) \
	or.u	r2, r0, hi16(_ASM_LABEL(eh_debug))	; \
	ld	r3, r2, lo16(_ASM_LABEL(eh_debug))	; \
	bb0	DebugNumber, r3, 2f			; \
	ldcr	r4, SR1					; \
	CALL(_C_LABEL(MY_info_done), r31, r4)		; \
2:	br	_ASM_LABEL(m88110_return_code)
#else
/*
 * If not debugging, then no debug-prep to do.
 * Also, when you're done, you're done!   (no debug check).
 */
#define	PREP_DEBUG(bit, name)
#define	DONE88100(num) \
d420 1
a420 1
#define	DONE88110(num) \
a421 1
#endif	/* EH_DEBUG */
d430 1
a430 1
	PREP88100("unknown", 0, DEBUG_UNKNOWN_BIT,,)
d432 1
a432 1
	DONE88100(DEBUG_UNKNOWN_BIT)
d436 1
a436 1
	PREP88100("interrupt", 1, DEBUG_INTERRUPT_BIT,,)
d438 1
a438 1
	DONE88100(DEBUG_INTERRUPT_BIT)
d442 1
a442 1
	PREP88100("inst", 2, DEBUG_INSTRUCTION_BIT,,)
d444 1
a444 1
	DONE88100(DEBUG_INSTRUCTION_BIT)
d451 1
a451 1
	PREP88100("data", 3, DEBUG_DATA_BIT,, M88100_Data_Precheck)
d453 1
a453 1
	DONE88100(DEBUG_DATA_BIT)
d457 1
a457 1
	PREP88100("misalign", 4, DEBUG_MISALIGN_BIT, Clear_SSBR_Dest,)
d459 1
a459 1
	DONE88100(DEBUG_MISALIGN_BIT)
d463 1
a463 1
	PREP88100("unimp", 5, DEBUG_UNIMPLEMENTED_BIT,,)
d465 1
a465 1
	DONE88100(DEBUG_UNIMPLEMENTED_BIT)
d478 1
a478 1
1:	PREP88100("privilege", 6, DEBUG_PRIVILEGE_BIT, Clear_SSBR_Dest,)
d480 1
a480 1
	DONE88100(DEBUG_PRIVILEGE_BIT)
d484 1
a484 1
	PREP88100("bounds", 7, DEBUG_BOUNDS_BIT, Clear_SSBR_Dest,)
d486 1
a486 1
	DONE88100(DEBUG_BOUNDS_BIT)
d490 1
a490 1
	PREP88100("divide", 8, DEBUG_DIVIDE_BIT, Clear_SSBR_Dest,)
d492 1
a492 1
	DONE88100(DEBUG_DIVIDE_BIT)
d496 1
a496 1
	PREP88100("overflow", 9, DEBUG_OVERFLOW_BIT,,)
d498 1
a498 1
	DONE88100(DEBUG_OVERFLOW_BIT)
d504 1
a504 1
	PREP88100("FPU precise", 114, DEBUG_FPp_BIT, FPp_SSBR_STUFF,)
d506 1
a506 1
	DONE88100(DEBUG_FPp_BIT)
d512 1
a512 1
	PREP88100("FPU imprecise", 115, DEBUG_FPi_BIT, FPi_SSBR_STUFF,)
d514 1
a514 1
	DONE88100(DEBUG_FPi_BIT)
d518 1
a518 1
	PREP88100("syscall", 128, DEBUG_SYSCALL_BIT,,)
d521 1
a521 1
	DONE88100(DEBUG_SYSCALL_BIT)
d525 1
a525 1
	PREP88100("bugsyscall", 496, DEBUG_BUGCALL_BIT,,)
d528 1
a528 1
	DONE88100(DEBUG_BUGCALL_BIT)
d531 1
a531 1
	PREP88100("sigsys", 501, DEBUG_SIGSYS_BIT,,)
d533 1
a533 1
	DONE88100(DEBUG_SIGSYS_BIT)
d536 1
a536 1
	PREP88100("sigtrap", 510, DEBUG_SIGTRAP_BIT,,)
d538 1
a538 1
	DONE88100(DEBUG_SIGTRAP_BIT)
d541 1
a541 1
	PREP88100("stepbpt", 504, DEBUG_SIGTRAP_BIT,,)
d543 1
a543 1
	DONE88100(DEBUG_SIGTRAP_BIT)
d546 1
a546 1
	PREP88100("userbpt", 511, DEBUG_SIGTRAP_BIT,,)
d548 1
a548 1
	DONE88100(DEBUG_SIGTRAP_BIT)
d552 1
a552 1
	PREP88100("break", 130, DEBUG_BREAK_BIT,,)
d554 1
a554 1
	DONE88100(DEBUG_BREAK_BIT)
d557 1
a557 1
	PREP88100("trace", 131, DEBUG_TRACE_BIT,,)
d559 1
a559 1
	DONE88100(DEBUG_TRACE_BIT)
d562 1
a562 1
	PREP88100("kdb", 132, DEBUG_KDB_BIT,,)
d564 1
a564 1
	DONE88100(DEBUG_KDB_BIT)
d567 1
a567 1
	PREP88100("break", 130, DEBUG_BREAK_BIT,,)
d569 1
a569 1
	DONE88100(DEBUG_BREAK_BIT)
d572 1
a572 1
	PREP88100("trace", 131, DEBUG_TRACE_BIT,,)
d574 1
a574 1
	DONE88100(DEBUG_TRACE_BIT)
d577 1
a577 1
	PREP88100("unknown", 132, DEBUG_KDB_BIT,,)
d579 1
a579 1
	DONE88100(DEBUG_KDB_BIT)
d1834 1
a1834 1
	PREP88110("unknown", 0, DEBUG_UNKNOWN_BIT,)
d1836 1
a1836 1
	DONE88110(DEBUG_UNKNOWN_BIT)
d1840 1
a1840 1
	PREP88110("interrupt", 1, DEBUG_INTERRUPT_BIT,)
d1842 1
a1842 1
	DONE88110(DEBUG_INTERRUPT_BIT)
d1846 1
a1846 1
	PREP88110("inst", 2, DEBUG_INSTRUCTION_BIT,)
d1848 1
a1848 1
	DONE88110(DEBUG_INSTRUCTION_BIT)
d1854 1
a1854 1
	PREP88110("data", 3, DEBUG_DATA_BIT, M88110_Data_Precheck)
d1856 1
a1856 1
	DONE88110(DEBUG_DATA_BIT)
d1860 1
a1860 1
	PREP88110("misalign", 4, DEBUG_MISALIGN_BIT,)
d1862 1
a1862 1
	DONE88110(DEBUG_MISALIGN_BIT)
d1866 1
a1866 1
	PREP88110("unimp", 5, DEBUG_UNIMPLEMENTED_BIT,)
d1868 1
a1868 1
	DONE88110(DEBUG_UNIMPLEMENTED_BIT)
d1872 1
a1872 1
	PREP88110("privilege", 6, DEBUG_PRIVILEGE_BIT,)
d1874 1
a1874 1
	DONE88110(DEBUG_PRIVILEGE_BIT)
d1881 1
a1881 1
	PREP88110("bounds", 7, DEBUG_BOUNDS_BIT,)
d1883 1
a1883 1
	DONE88110(DEBUG_BOUNDS_BIT)
d1887 1
a1887 1
	PREP88110("divide", 8, DEBUG_DIVIDE_BIT,)
d1889 1
a1889 1
	DONE88110(DEBUG_DIVIDE_BIT)
d1893 1
a1893 1
	PREP88110("overflow", 9, DEBUG_OVERFLOW_BIT,)
d1895 1
a1895 1
	DONE88110(DEBUG_OVERFLOW_BIT)
d1899 1
a1899 1
	PREP88110("FPU precise", 114, DEBUG_FPp_BIT,)
d1901 1
a1901 1
	DONE88110(DEBUG_FPp_BIT)
d1905 1
a1905 1
	PREP88110("MVME197 non-mask", 11, DEBUG_NON_MASK_BIT,)
d1907 1
a1907 1
	DONE88110(DEBUG_NON_MASK_BIT)
d1911 1
a1911 1
	PREP88110("MVME197 read miss", 12, DEBUG_197_READ_BIT,)
d1913 1
a1913 1
	DONE88110(DEBUG_197_READ_BIT)
d1917 1
a1917 1
	PREP88110("MVME197 write miss", 13, DEBUG_197_WRITE_BIT,)
d1919 1
a1919 1
	DONE88110(DEBUG_197_WRITE_BIT)
d1923 1
a1923 1
	PREP88110("MVME197 inst miss", 14, DEBUG_197_INST_BIT,)
d1925 1
a1925 1
	DONE88110(DEBUG_197_INST_BIT)
d1929 1
a1929 1
	PREP88110("syscall", 128, DEBUG_SYSCALL_BIT,)
d1932 1
a1932 1
	DONE88110(DEBUG_SYSCALL_BIT)
d1936 1
a1936 1
	PREP88110("bugsyscall", 496, DEBUG_BUGCALL_BIT,)
d1939 1
a1939 1
	DONE88110(DEBUG_BUGCALL_BIT)
d1942 1
a1942 1
	PREP88110("sigsys", 501, DEBUG_SIGSYS_BIT,)
d1944 1
a1944 1
	DONE88110(DEBUG_SIGSYS_BIT)
d1947 1
a1947 1
	PREP88110("sigtrap", 510, DEBUG_SIGTRAP_BIT,)
d1949 1
a1949 1
	DONE88110(DEBUG_SIGTRAP_BIT)
d1952 1
a1952 1
	PREP88110("stepbpt", 504, DEBUG_SIGTRAP_BIT,)
d1954 1
a1954 1
	DONE88110(DEBUG_SIGTRAP_BIT)
d1957 1
a1957 1
	PREP88110("userbpt", 511, DEBUG_SIGTRAP_BIT,)
d1959 1
a1959 1
	DONE88110(DEBUG_SIGTRAP_BIT)
d1963 1
a1963 1
	PREP88110("break", 130, DEBUG_BREAK_BIT,)
d1965 1
a1965 1
	DONE88110(DEBUG_BREAK_BIT)
d1968 1
a1968 1
	PREP88110("trace", 131, DEBUG_TRACE_BIT,)
d1970 1
a1970 1
	DONE88110(DEBUG_TRACE_BIT)
d1973 1
a1973 1
	PREP88110("kdb", 132, DEBUG_KDB_BIT,)
d1975 1
a1975 1
	DONE88110(DEBUG_KDB_BIT)
d1978 1
a1978 1
	PREP88110("break", 130, DEBUG_BREAK_BIT,)
d1980 1
a1980 1
	DONE88110(DEBUG_BREAK_BIT)
d1983 1
a1983 1
	PREP88110("trace", 131, DEBUG_TRACE_BIT,)
d1985 1
a1985 1
	DONE88110(DEBUG_TRACE_BIT)
d1988 1
a1988 1
	PREP88110("unknown", 132, DEBUG_KDB_BIT,)
d1990 1
a1990 1
	DONE88110(DEBUG_KDB_BIT)
@


1.1
log
@Factorize exception handling code. The only different part between luna88k
and mvme88k is the retrieval of the CMMU fault registers.

Tested on mvme88k by myself and luna88k by aoyama@@
@
text
@d1 1
a1 1
/*   $OpenBSD$	*/
d217 28
a244 3
 * The exception frame as defined in "machine/pcb.h" (among other places) is
 * a bit outdated and needs to be changed. Until then, we'll define some
 * pseudo-fields there for our needs.
d246 12
@

