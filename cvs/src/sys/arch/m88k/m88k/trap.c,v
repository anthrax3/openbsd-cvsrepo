head	1.107;
access;
symbols
	OPENBSD_6_1:1.106.0.4
	OPENBSD_6_1_BASE:1.106
	OPENBSD_6_0:1.104.0.2
	OPENBSD_6_0_BASE:1.104
	OPENBSD_5_9:1.103.0.2
	OPENBSD_5_9_BASE:1.103
	OPENBSD_5_8:1.102.0.6
	OPENBSD_5_8_BASE:1.102
	OPENBSD_5_7:1.102.0.2
	OPENBSD_5_7_BASE:1.102
	OPENBSD_5_6:1.100.0.4
	OPENBSD_5_6_BASE:1.100
	OPENBSD_5_5:1.88.0.4
	OPENBSD_5_5_BASE:1.88
	OPENBSD_5_4:1.85.0.2
	OPENBSD_5_4_BASE:1.85
	OPENBSD_5_3:1.84.0.2
	OPENBSD_5_3_BASE:1.84
	OPENBSD_5_2:1.80.0.2
	OPENBSD_5_2_BASE:1.80
	OPENBSD_5_1_BASE:1.79
	OPENBSD_5_1:1.79.0.2
	OPENBSD_5_0:1.78.0.2
	OPENBSD_5_0_BASE:1.78
	OPENBSD_4_9:1.73.0.2
	OPENBSD_4_9_BASE:1.73
	OPENBSD_4_8:1.69.0.8
	OPENBSD_4_8_BASE:1.69
	OPENBSD_4_7:1.69.0.4
	OPENBSD_4_7_BASE:1.69
	OPENBSD_4_6:1.69.0.6
	OPENBSD_4_6_BASE:1.69
	OPENBSD_4_5:1.69.0.2
	OPENBSD_4_5_BASE:1.69
	OPENBSD_4_4:1.63.0.2
	OPENBSD_4_4_BASE:1.63
	OPENBSD_4_3:1.61.0.2
	OPENBSD_4_3_BASE:1.61
	OPENBSD_4_2:1.40.0.2
	OPENBSD_4_2_BASE:1.40
	OPENBSD_4_1:1.38.0.2
	OPENBSD_4_1_BASE:1.38
	OPENBSD_4_0:1.33.0.2
	OPENBSD_4_0_BASE:1.33
	OPENBSD_3_9:1.29.0.2
	OPENBSD_3_9_BASE:1.29
	OPENBSD_3_8:1.19.0.2
	OPENBSD_3_8_BASE:1.19
	OPENBSD_3_7:1.15.0.2
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.10.0.2
	OPENBSD_3_6_BASE:1.10
	SMP_SYNC_A:1.5
	SMP_SYNC_B:1.5
	SMP:1.4.0.2;
locks; strict;
comment	@ * @;


1.107
date	2017.09.08.05.36.52;	author deraadt;	state Exp;
branches;
next	1.106;
commitid	uRv5pa9QDlZaYgwD;

1.106
date	2017.02.15.21.18.52;	author miod;	state Exp;
branches;
next	1.105;
commitid	nNXOCNUaiRx2qGBa;

1.105
date	2016.10.19.08.31.33;	author guenther;	state Exp;
branches;
next	1.104;
commitid	FyYQJQUG0i6W5gNT;

1.104
date	2016.06.13.23.51.59;	author dlg;	state Exp;
branches;
next	1.103;
commitid	pePIrytkQAoqTKCZ;

1.103
date	2015.09.13.11.32.29;	author miod;	state Exp;
branches;
next	1.102;
commitid	FmcTJAVqMgSiWrgx;

1.102
date	2015.02.10.10.15.30;	author miod;	state Exp;
branches;
next	1.101;
commitid	kdwecu5GAIMMGLEU;

1.101
date	2014.11.16.12.30.58;	author deraadt;	state Exp;
branches;
next	1.100;
commitid	yv0ECmCdICvq576h;

1.100
date	2014.07.02.18.37.34;	author miod;	state Exp;
branches;
next	1.99;
commitid	67iah2C8h4RSjvdf;

1.99
date	2014.07.01.20.26.09;	author miod;	state Exp;
branches;
next	1.98;
commitid	iAtGSRVdQhSqPb5V;

1.98
date	2014.06.09.16.26.32;	author miod;	state Exp;
branches;
next	1.97;
commitid	CkVHFMR82yg837kv;

1.97
date	2014.06.09.14.33.20;	author miod;	state Exp;
branches;
next	1.96;
commitid	T9yxec6ApVOognSZ;

1.96
date	2014.05.31.11.27.50;	author miod;	state Exp;
branches;
next	1.95;

1.95
date	2014.05.31.11.19.06;	author miod;	state Exp;
branches;
next	1.94;

1.94
date	2014.05.26.17.31.17;	author miod;	state Exp;
branches;
next	1.93;

1.93
date	2014.05.11.00.12.44;	author guenther;	state Exp;
branches;
next	1.92;

1.92
date	2014.05.10.05.33.00;	author guenther;	state Exp;
branches;
next	1.91;

1.91
date	2014.05.08.22.17.33;	author miod;	state Exp;
branches;
next	1.90;

1.90
date	2014.04.18.11.51.17;	author guenther;	state Exp;
branches;
next	1.89;

1.89
date	2014.03.26.05.23.42;	author guenther;	state Exp;
branches;
next	1.88;

1.88
date	2013.09.05.20.40.32;	author miod;	state Exp;
branches;
next	1.87;

1.87
date	2013.08.26.21.38.09;	author miod;	state Exp;
branches;
next	1.86;

1.86
date	2013.08.18.22.17.26;	author miod;	state Exp;
branches;
next	1.85;

1.85
date	2013.04.12.04.48.52;	author miod;	state Exp;
branches;
next	1.84;

1.84
date	2013.01.07.22.47.18;	author miod;	state Exp;
branches;
next	1.83;

1.83
date	2012.12.31.06.46.13;	author guenther;	state Exp;
branches;
next	1.82;

1.82
date	2012.08.07.17.17.46;	author guenther;	state Exp;
branches;
next	1.81;

1.81
date	2012.08.07.05.16.53;	author guenther;	state Exp;
branches;
next	1.80;

1.80
date	2012.04.11.14.38.55;	author mikeb;	state Exp;
branches;
next	1.79;

1.79
date	2011.11.16.20.50.18;	author deraadt;	state Exp;
branches;
next	1.78;

1.78
date	2011.07.11.15.40.47;	author guenther;	state Exp;
branches;
next	1.77;

1.77
date	2011.07.07.18.11.24;	author art;	state Exp;
branches;
next	1.76;

1.76
date	2011.07.06.21.41.37;	author art;	state Exp;
branches;
next	1.75;

1.75
date	2011.04.06.18.01.50;	author miod;	state Exp;
branches;
next	1.74;

1.74
date	2011.04.03.14.56.28;	author guenther;	state Exp;
branches;
next	1.73;

1.73
date	2010.12.31.20.54.21;	author miod;	state Exp;
branches;
next	1.72;

1.72
date	2010.12.23.19.55.24;	author miod;	state Exp;
branches;
next	1.71;

1.71
date	2010.12.20.21.32.06;	author miod;	state Exp;
branches;
next	1.70;

1.70
date	2010.12.20.20.07.49;	author miod;	state Exp;
branches;
next	1.69;

1.69
date	2009.03.01.17.43.25;	author miod;	state Exp;
branches;
next	1.68;

1.68
date	2009.02.16.22.55.03;	author miod;	state Exp;
branches;
next	1.67;

1.67
date	2009.02.13.23.33.51;	author miod;	state Exp;
branches;
next	1.66;

1.66
date	2009.02.08.21.40.13;	author miod;	state Exp;
branches;
next	1.65;

1.65
date	2009.02.01.00.52.19;	author miod;	state Exp;
branches;
next	1.64;

1.64
date	2008.11.27.20.46.48;	author miod;	state Exp;
branches;
next	1.63;

1.63
date	2008.05.02.21.44.46;	author miod;	state Exp;
branches;
next	1.62;

1.62
date	2008.04.01.21.10.18;	author miod;	state Exp;
branches;
next	1.61;

1.61
date	2007.12.25.00.29.49;	author miod;	state Exp;
branches;
next	1.60;

1.60
date	2007.12.12.20.35.37;	author miod;	state Exp;
branches;
next	1.59;

1.59
date	2007.12.08.18.39.50;	author miod;	state Exp;
branches;
next	1.58;

1.58
date	2007.12.04.05.42.48;	author miod;	state Exp;
branches;
next	1.57;

1.57
date	2007.12.04.05.37.40;	author miod;	state Exp;
branches;
next	1.56;

1.56
date	2007.12.04.05.36.34;	author miod;	state Exp;
branches;
next	1.55;

1.55
date	2007.12.02.21.34.34;	author miod;	state Exp;
branches;
next	1.54;

1.54
date	2007.12.02.21.33.56;	author miod;	state Exp;
branches;
next	1.53;

1.53
date	2007.11.25.16.40.04;	author jmc;	state Exp;
branches;
next	1.52;

1.52
date	2007.11.22.23.31.51;	author miod;	state Exp;
branches;
next	1.51;

1.51
date	2007.11.22.23.30.48;	author miod;	state Exp;
branches;
next	1.50;

1.50
date	2007.11.22.06.11.51;	author miod;	state Exp;
branches;
next	1.49;

1.49
date	2007.11.22.05.53.56;	author miod;	state Exp;
branches;
next	1.48;

1.48
date	2007.11.21.19.40.34;	author miod;	state Exp;
branches;
next	1.47;

1.47
date	2007.11.21.19.30.09;	author miod;	state Exp;
branches;
next	1.46;

1.46
date	2007.11.20.22.08.40;	author miod;	state Exp;
branches;
next	1.45;

1.45
date	2007.11.20.21.53.25;	author miod;	state Exp;
branches;
next	1.44;

1.44
date	2007.11.20.21.48.58;	author miod;	state Exp;
branches;
next	1.43;

1.43
date	2007.11.17.05.36.23;	author miod;	state Exp;
branches;
next	1.42;

1.42
date	2007.11.14.22.56.56;	author miod;	state Exp;
branches;
next	1.41;

1.41
date	2007.10.28.10.18.53;	author miod;	state Exp;
branches;
next	1.40;

1.40
date	2007.05.11.10.06.55;	author pedro;	state Exp;
branches;
next	1.39;

1.39
date	2007.03.15.10.22.29;	author art;	state Exp;
branches;
next	1.38;

1.38
date	2007.02.11.12.49.37;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2006.12.24.20.30.35;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2006.12.24.20.29.19;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2006.11.20.21.48.31;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2006.11.10.19.19.50;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2006.05.08.14.36.09;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2006.05.08.14.03.35;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2006.05.04.19.38.45;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2006.05.02.21.44.39;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2005.12.11.21.45.30;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2005.12.11.21.30.30;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2005.12.07.07.38.58;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2005.12.04.12.14.10;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2005.12.03.14.30.06;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2005.12.01.22.24.52;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2005.11.28.22.22.55;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2005.11.28.22.21.15;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2005.09.15.21.14.27;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2005.09.15.21.09.29;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2005.08.06.09.53.36;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2005.05.18.16.44.41;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2005.04.30.16.42.36;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2005.04.27.14.09.45;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2004.12.06.20.12.24;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2004.11.09.21.49.56;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2004.11.08.16.39.31;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2004.10.01.20.20.34;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2004.09.30.21.48.56;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2004.07.26.10.42.56;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2004.07.22.18.58.57;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2004.06.22.18.26.12;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2004.06.22.05.02.32;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2004.06.22.05.01.05;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2004.06.07.10.28.47;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.03.05.18.43;	author miod;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2004.06.03.05.17.36;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2004.05.07.15.31.13;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2004.04.29.14.33.27;	author miod;	state Exp;
branches;
next	;

1.4.2.1
date	2004.06.05.23.09.48;	author niklas;	state Exp;
branches;
next	1.4.2.2;

1.4.2.2
date	2004.06.07.20.41.12;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.107
log
@If you use sys/param.h, you don't need sys/types.h
@
text
@/*	$OpenBSD: trap.c,v 1.106 2017/02/15 21:18:52 miod Exp $	*/
/*
 * Copyright (c) 2004, Miodrag Vallat.
 * Copyright (c) 1998 Steve Murphree, Jr.
 * Copyright (c) 1996 Nivas Madhur
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Nivas Madhur.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */
/*
 * Mach Operating System
 * Copyright (c) 1991 Carnegie Mellon University
 * Copyright (c) 1991 OMRON Corporation
 * All Rights Reserved.
 *
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 */

#include <sys/param.h>
#include <sys/proc.h>
#include <sys/signalvar.h>
#include <sys/user.h>
#include <sys/syscall.h>
#include <sys/systm.h>
#include <sys/syscall_mi.h>

#include <uvm/uvm_extern.h>

#include <machine/asm_macro.h>
#include <machine/cmmu.h>
#include <machine/cpu.h>
#ifdef M88100
#include <machine/m88100.h>
#include <machine/m8820x.h>
#endif
#ifdef M88110
#include <machine/m88110.h>
#endif
#include <machine/fpu.h>
#include <machine/pcb.h>
#include <machine/psl.h>
#include <machine/trap.h>

#include <machine/db_machdep.h>

#define SSBREAKPOINT (0xF000D1F8U) /* Single Step Breakpoint */

#define USERMODE(PSR)   (((PSR) & PSR_MODE) == 0)
#define SYSTEMMODE(PSR) (((PSR) & PSR_MODE) != 0)

void printtrap(int, struct trapframe *);
__dead void panictrap(int, struct trapframe *);
__dead void error_fatal(struct trapframe *);
int double_reg_fixup(struct trapframe *, int);
int ss_put_value(struct proc *, vaddr_t, u_int);

extern void regdump(struct trapframe *f);

const char *trap_type[] = {
	"Reset",
	"Interrupt Exception",
	"Instruction Access",
	"Data Access Exception",
	"Misaligned Access",
	"Unimplemented Opcode",
	"Privilege Violation"
	"Bounds Check Violation",
	"Illegal Integer Divide",
	"Integer Overflow",
	"Error Exception",
	"Non-Maskable Exception",
};

const int trap_types = sizeof trap_type / sizeof trap_type[0];

#ifdef M88100
const char *pbus_exception_type[] = {
	"Success (No Fault)",
	"unknown 1",
	"unknown 2",
	"Bus Error",
	"Segment Fault",
	"Page Fault",
	"Supervisor Violation",
	"Write Violation",
};
#endif

void
printtrap(int type, struct trapframe *frame)
{
#ifdef M88100
	if (CPU_IS88100) {
		if (type == 2) {
			/* instruction exception */
			printf("\nInstr access fault (%s) v = %lx, frame %p\n",
			    pbus_exception_type[
			      CMMU_PFSR_FAULT(frame->tf_ipfsr)],
			    frame->tf_sxip & XIP_ADDR, frame);
		} else if (type == 3) {
			/* data access exception */
			printf("\nData access fault (%s) v = %lx, frame %p\n",
			    pbus_exception_type[
			      CMMU_PFSR_FAULT(frame->tf_dpfsr)],
			    frame->tf_sxip & XIP_ADDR, frame);
		} else
			printf("\nTrap type %d, v = %lx, frame %p\n",
			    type, frame->tf_sxip & XIP_ADDR, frame);
	}
#endif
#ifdef M88110
	if (CPU_IS88110) {
		printf("\nTrap type %d, v = %lx, frame %p\n",
		    type, frame->tf_exip, frame);
	}
#endif
#ifdef DDB
	regdump(frame);
#endif
}

__dead void
panictrap(int type, struct trapframe *frame)
{
	static int panicing = 0;

	if (panicing++ == 0)
		printtrap(type, frame);
	if ((u_int)type < trap_types)
		panic(trap_type[type]);
	else
		panic("trap %d", type);
	/*NOTREACHED*/
}

/*
 * Handle external interrupts.
 */
void
interrupt(struct trapframe *frame)
{
	struct cpu_info *ci = curcpu();

	ci->ci_intrdepth++;
	md_interrupt_func(frame);
	ci->ci_intrdepth--;
}

#ifdef M88110
/*
 * Handle non-maskable interrupts.
 */
int
nmi(struct trapframe *frame)
{
	return md_nmi_func(frame);
}

/*
 * Reenable non-maskable interrupts.
 */
void
nmi_wrapup(struct trapframe *frame)
{
	md_nmi_wrapup_func(frame);
}
#endif

/*
 * Handle asynchronous software traps.
 */
void
ast(struct trapframe *frame)
{
	struct cpu_info *ci = curcpu();
	struct proc *p = ci->ci_curproc;

	p->p_md.md_astpending = 0;

	uvmexp.softs++;
	mi_ast(p, ci->ci_want_resched);
	userret(p);
}

#ifdef M88100
void
m88100_trap(u_int type, struct trapframe *frame)
{
	struct proc *p;
	struct vm_map *map;
	vaddr_t va, pcb_onfault;
	vm_prot_t ftype;
	int fault_type, pbus_type;
	u_long fault_code;
	vaddr_t fault_addr;
	struct vmspace *vm;
	union sigval sv;
	int result;
#ifdef DDB
	int s;
	u_int psr;
#endif
	int sig = 0;

	uvmexp.traps++;
	if ((p = curproc) == NULL)
		p = &proc0;

	if (USERMODE(frame->tf_epsr)) {
		type += T_USER;
		p->p_md.md_tf = frame;	/* for ptrace/signals */
		refreshcreds(p);
	}
	fault_type = SI_NOINFO;
	fault_code = 0;
	fault_addr = frame->tf_sxip & XIP_ADDR;

	switch (type) {
	default:
	case T_ILLFLT:
lose:
		panictrap(frame->tf_vector, frame);
		break;
		/*NOTREACHED*/

#if defined(DDB)
	case T_KDB_BREAK:
		s = splhigh();
		set_psr((psr = get_psr()) & ~PSR_IND);
		ddb_break_trap(T_KDB_BREAK, (db_regs_t*)frame);
		set_psr(psr);
		splx(s);
		return;
	case T_KDB_ENTRY:
		s = splhigh();
		set_psr((psr = get_psr()) & ~PSR_IND);
		ddb_entry_trap(T_KDB_ENTRY, (db_regs_t*)frame);
		set_psr(psr);
		splx(s);
		return;
#endif /* DDB */
	case T_MISALGNFLT:
		printf("kernel misaligned access exception @@0x%08lx\n",
		    frame->tf_sxip);
		goto lose;
	case T_INSTFLT:
		/* kernel mode instruction access fault.
		 * Should never, never happen for a non-paged kernel.
		 */
#ifdef TRAPDEBUG
		pbus_type = CMMU_PFSR_FAULT(frame->tf_ipfsr);
		printf("Kernel Instruction fault #%d (%s) v = 0x%x, frame 0x%x cpu %p\n",
		    pbus_type, pbus_exception_type[pbus_type],
		    fault_addr, frame, frame->tf_cpu);
#endif
		goto lose;
	case T_DATAFLT:
		/* kernel mode data fault */

		/* data fault on the user address? */
		if ((frame->tf_dmt0 & DMT_DAS) == 0) {
			KERNEL_LOCK();
			goto user_fault;
		}

		fault_addr = frame->tf_dma0;
		if (frame->tf_dmt0 & (DMT_WRITE|DMT_LOCKBAR)) {
			ftype = PROT_READ | PROT_WRITE;
			fault_code = PROT_WRITE;
		} else {
			ftype = PROT_READ;
			fault_code = PROT_READ;
		}

		va = trunc_page((vaddr_t)fault_addr);

		KERNEL_LOCK();
		vm = p->p_vmspace;
		map = kernel_map;

		pbus_type = CMMU_PFSR_FAULT(frame->tf_dpfsr);
#ifdef TRAPDEBUG
		printf("Kernel Data access fault #%d (%s) v = 0x%x, frame 0x%x cpu %p\n",
		    pbus_type, pbus_exception_type[pbus_type],
		    fault_addr, frame, frame->tf_cpu);
#endif

		pcb_onfault = p->p_addr->u_pcb.pcb_onfault;
		switch (pbus_type) {
		case CMMU_PFSR_SUCCESS:
			/*
			 * The fault was resolved. Call data_access_emulation
			 * to drain the data unit pipe line and reset dmt0
			 * so that trap won't get called again.
			 */
			p->p_addr->u_pcb.pcb_onfault = 0;
			data_access_emulation((u_int *)frame);
			p->p_addr->u_pcb.pcb_onfault = pcb_onfault;
			frame->tf_dmt0 = 0;
			frame->tf_dpfsr = 0;
			KERNEL_UNLOCK();
			return;
		case CMMU_PFSR_SFAULT:
		case CMMU_PFSR_PFAULT:
			p->p_addr->u_pcb.pcb_onfault = 0;
			result = uvm_fault(map, va, VM_FAULT_INVALID, ftype);
			p->p_addr->u_pcb.pcb_onfault = pcb_onfault;
			if (result == 0) {
				/*
				 * We could resolve the fault. Call
				 * data_access_emulation to drain the data
				 * unit pipe line and reset dmt0 so that trap
				 * won't get called again.
				 */
				p->p_addr->u_pcb.pcb_onfault = 0;
				data_access_emulation((u_int *)frame);
				p->p_addr->u_pcb.pcb_onfault = pcb_onfault;
				frame->tf_dmt0 = 0;
				frame->tf_dpfsr = 0;
				KERNEL_UNLOCK();
				return;
			} else if (pcb_onfault != 0) {
				/*
				 * This could be a fault caused in copyout*()
				 * while accessing kernel space.
				 */
				frame->tf_snip = pcb_onfault | NIP_V;
				frame->tf_sfip = (pcb_onfault + 4) | FIP_V;
				/*
				 * Continue as if the fault had been resolved,
				 * but do not try to complete the faulting
				 * access.
				 */
				frame->tf_dmt0 = 0;
				frame->tf_dpfsr = 0;
				KERNEL_UNLOCK();
				return;
			}
			break;
		}
#ifdef TRAPDEBUG
		printf("PBUS Fault %d (%s) va = 0x%x\n", pbus_type,
		    pbus_exception_type[pbus_type], va);
#endif
		KERNEL_UNLOCK();
		goto lose;
		/* NOTREACHED */
	case T_INSTFLT+T_USER:
		/* User mode instruction access fault */
		/* FALLTHROUGH */
	case T_DATAFLT+T_USER:
		KERNEL_LOCK();
user_fault:
		if (type == T_INSTFLT + T_USER) {
			pbus_type = CMMU_PFSR_FAULT(frame->tf_ipfsr);
#ifdef TRAPDEBUG
			printf("User Instruction fault #%d (%s) v = 0x%x, frame 0x%x cpu %p\n",
			    pbus_type, pbus_exception_type[pbus_type],
			    fault_addr, frame, frame->tf_cpu);
#endif
		} else {
			fault_addr = frame->tf_dma0;
			pbus_type = CMMU_PFSR_FAULT(frame->tf_dpfsr);
#ifdef TRAPDEBUG
			printf("User Data access fault #%d (%s) v = 0x%x, frame 0x%x cpu %p\n",
			    pbus_type, pbus_exception_type[pbus_type],
			    fault_addr, frame, frame->tf_cpu);
#endif
		}

		if (frame->tf_dmt0 & (DMT_WRITE | DMT_LOCKBAR)) {
			ftype = PROT_READ | PROT_WRITE;
			fault_code = PROT_WRITE;
		} else {
			ftype = PROT_READ;
			fault_code = PROT_READ;
		}

		va = trunc_page((vaddr_t)fault_addr);

		vm = p->p_vmspace;
		map = &vm->vm_map;
		if ((pcb_onfault = p->p_addr->u_pcb.pcb_onfault) != 0)
			p->p_addr->u_pcb.pcb_onfault = 0;

		/* Call uvm_fault() to resolve non-bus error faults */
		switch (pbus_type) {
		case CMMU_PFSR_SUCCESS:
			result = 0;
			break;
		case CMMU_PFSR_BERROR:
			result = EACCES;
			break;
		default:
			result = uvm_fault(map, va, VM_FAULT_INVALID, ftype);
			if (result == EACCES)
				result = EFAULT;
			break;
		}

		p->p_addr->u_pcb.pcb_onfault = pcb_onfault;

		if (result == 0 && (caddr_t)va >= vm->vm_maxsaddr)
			uvm_grow(p, va);

		if (result == 0) {
			if (type == T_INSTFLT + T_USER) {
				m88100_rewind_insn(&(frame->tf_regs));
				/* clear the error bit */
				frame->tf_sfip &= ~FIP_E;
				frame->tf_snip &= ~NIP_E;
				frame->tf_ipfsr = 0;
			} else {
				/*
			 	 * We could resolve the fault. Call
			 	 * data_access_emulation to drain the data unit
			 	 * pipe line and reset dmt0 so that trap won't
			 	 * get called again.
			 	 */
				p->p_addr->u_pcb.pcb_onfault = 0;
				data_access_emulation((u_int *)frame);
				p->p_addr->u_pcb.pcb_onfault = pcb_onfault;
				frame->tf_dmt0 = 0;
				frame->tf_dpfsr = 0;
			}
		} else {
			/*
			 * This could be a fault caused in copyin*()
			 * while accessing user space.
			 */
			if (pcb_onfault != 0) {
				frame->tf_snip = pcb_onfault | NIP_V;
				frame->tf_sfip = (pcb_onfault + 4) | FIP_V;
				/*
				 * Continue as if the fault had been resolved,
				 * but do not try to complete the faulting
				 * access.
				 */
				frame->tf_dmt0 = 0;
				frame->tf_dpfsr = 0;
			} else {
				sig = result == EACCES ? SIGBUS : SIGSEGV;
				fault_type = result == EACCES ?
				    BUS_ADRERR : SEGV_MAPERR;
			}
		}
		KERNEL_UNLOCK();
		break;
	case T_MISALGNFLT+T_USER:
		/* Fix any misaligned ld.d or st.d instructions */
		sig = double_reg_fixup(frame, T_MISALGNFLT);
		fault_type = BUS_ADRALN;
		break;
	case T_PRIVINFLT+T_USER:
	case T_ILLFLT+T_USER:
#ifndef DDB
	case T_KDB_BREAK:
	case T_KDB_ENTRY:
#endif
	case T_KDB_BREAK+T_USER:
	case T_KDB_ENTRY+T_USER:
	case T_KDB_TRACE:
	case T_KDB_TRACE+T_USER:
		sig = SIGILL;
		break;
	case T_BNDFLT+T_USER:
		sig = SIGFPE;
		break;
	case T_ZERODIV+T_USER:
		sig = SIGFPE;
		fault_type = FPE_INTDIV;
		break;
	case T_OVFFLT+T_USER:
		sig = SIGFPE;
		fault_type = FPE_INTOVF;
		break;
	case T_FPEPFLT+T_USER:
		m88100_fpu_precise_exception(frame);
		goto userexit;
	case T_FPEIFLT+T_USER:
		m88100_fpu_imprecise_exception(frame);
		goto userexit;
	case T_SIGSYS+T_USER:
		sig = SIGSYS;
		break;
	case T_STEPBPT+T_USER:
#ifdef PTRACE
		/*
		 * This trap is used by the kernel to support single-step
		 * debugging (although any user could generate this trap
		 * which should probably be handled differently). When a
		 * process is continued by a debugger with the PT_STEP
		 * function of ptrace (single step), the kernel inserts
		 * one or two breakpoints in the user process so that only
		 * one instruction (or two in the case of a delayed branch)
		 * is executed.  When this breakpoint is hit, we get the
		 * T_STEPBPT trap.
		 */
		{
			u_int instr;
			vaddr_t pc = PC_REGS(&frame->tf_regs);

			/* read break instruction */
			copyin((caddr_t)pc, &instr, sizeof(u_int));

			/* check and see if we got here by accident */
			if ((p->p_md.md_bp0va != pc &&
			     p->p_md.md_bp1va != pc) ||
			    instr != SSBREAKPOINT) {
				sig = SIGTRAP;
				fault_type = TRAP_TRACE;
				break;
			}

			/* restore original instruction and clear breakpoint */
			KERNEL_LOCK();
			if (p->p_md.md_bp0va == pc) {
				ss_put_value(p, pc, p->p_md.md_bp0save);
				p->p_md.md_bp0va = 0;
			}
			if (p->p_md.md_bp1va == pc) {
				ss_put_value(p, pc, p->p_md.md_bp1save);
				p->p_md.md_bp1va = 0;
			}
			KERNEL_UNLOCK();

			frame->tf_sxip = pc | NIP_V;
			sig = SIGTRAP;
			fault_type = TRAP_BRKPT;
		}
#else
		sig = SIGTRAP;
		fault_type = TRAP_TRACE;
#endif
		break;

	case T_USERBPT+T_USER:
		/*
		 * This trap is meant to be used by debuggers to implement
		 * breakpoint debugging.  When we get this trap, we just
		 * return a signal which gets caught by the debugger.
		 */
		sig = SIGTRAP;
		fault_type = TRAP_BRKPT;
		break;

	}

	/*
	 * If trap from supervisor mode, just return
	 */
	if (type < T_USER)
		return;

	if (sig) {
		sv.sival_ptr = (void *)fault_addr;
		KERNEL_LOCK();
		trapsignal(p, sig, fault_code, fault_type, sv);
		KERNEL_UNLOCK();
		/*
		 * don't want multiple faults - we are going to
		 * deliver signal.
		 */
		frame->tf_dmt0 = 0;
		frame->tf_ipfsr = frame->tf_dpfsr = 0;
	}

userexit:
	userret(p);
}
#endif /* M88100 */

#ifdef M88110
void
m88110_trap(u_int type, struct trapframe *frame)
{
	struct proc *p;
	struct vm_map *map;
	vaddr_t va, pcb_onfault;
	vm_prot_t ftype;
	int fault_type;
	u_long fault_code;
	vaddr_t fault_addr;
	struct vmspace *vm;
	union sigval sv;
	int result;
#ifdef DDB
        int s;
	u_int psr;
#endif
	int sig = 0;

	uvmexp.traps++;
	if ((p = curproc) == NULL)
		p = &proc0;

	fault_type = SI_NOINFO;
	fault_code = 0;
	fault_addr = frame->tf_exip & XIP_ADDR;

	/*
	 * 88110 errata #16 (4.2) or #3 (5.1.1):
	 * ``bsr, br, bcnd, jsr and jmp instructions with the .n extension
	 *   can cause the enip value to be incremented by 4 incorrectly
	 *   if the instruction in the delay slot is the first word of a
	 *   page which misses in the mmu and results in a hardware
	 *   tablewalk which encounters an exception or an invalid
	 *   descriptor.  The exip value in this case will point to the
	 *   first word of the page, and the D bit will be set.
	 *
	 *   Note: if the instruction is a jsr.n r1, r1 will be overwritten
	 *   with erroneous data.  Therefore, no recovery is possible. Do
	 *   not allow this instruction to occupy the last word of a page.
	 *
	 *   Suggested fix: recover in general by backing up the exip by 4
	 *   and clearing the delay bit before an rte when the lower 3 hex
	 *   digits of the exip are 001.''
	 */
	if ((frame->tf_exip & PAGE_MASK) == 0x00000001 && type == T_INSTFLT) {
		u_int instr;

		/*
		 * Note that we have initialized fault_addr above, so that
		 * signals provide the correct address if necessary.
		 */
		frame->tf_exip = (frame->tf_exip & ~1) - 4;

		/*
		 * Check the instruction at the (backed up) exip.
		 * If it is a jsr.n, abort.
		 */
		if (!USERMODE(frame->tf_epsr)) {
			instr = *(u_int *)fault_addr;
			if (instr == 0xf400cc01)
				panic("mc88110 errata #16, exip 0x%lx enip 0x%lx",
				    (frame->tf_exip + 4) | 1, frame->tf_enip);
		} else {
			/* copyin here should not fail */
			if (copyin((const void *)frame->tf_exip, &instr,
			    sizeof instr) == 0 &&
			    instr == 0xf400cc01) {
				uprintf("mc88110 errata #16, exip 0x%lx enip 0x%lx",
				    (frame->tf_exip + 4) | 1, frame->tf_enip);
				sig = SIGILL;
			}
		}
	}

	if (USERMODE(frame->tf_epsr)) {
		type += T_USER;
		p->p_md.md_tf = frame;	/* for ptrace/signals */
		refreshcreds(p);
	}

	if (sig != 0)
		goto deliver;

	switch (type) {
	default:
lose:
		panictrap(frame->tf_vector, frame);
		break;
		/*NOTREACHED*/

#ifdef DEBUG
	case T_110_DRM+T_USER:
	case T_110_DRM:
		printf("DMMU read miss: Hardware Table Searches should be enabled!\n");
		goto lose;
	case T_110_DWM+T_USER:
	case T_110_DWM:
		printf("DMMU write miss: Hardware Table Searches should be enabled!\n");
		goto lose;
	case T_110_IAM+T_USER:
	case T_110_IAM:
		printf("IMMU miss: Hardware Table Searches should be enabled!\n");
		goto lose;
#endif

#ifdef DDB
	case T_KDB_TRACE:
		s = splhigh();
		set_psr((psr = get_psr()) & ~PSR_IND);
		ddb_break_trap(T_KDB_TRACE, (db_regs_t*)frame);
		set_psr(psr);
		splx(s);
		return;
	case T_KDB_BREAK:
		s = splhigh();
		set_psr((psr = get_psr()) & ~PSR_IND);
		ddb_break_trap(T_KDB_BREAK, (db_regs_t*)frame);
		set_psr(psr);
		splx(s);
		return;
	case T_KDB_ENTRY:
		s = splhigh();
		set_psr((psr = get_psr()) & ~PSR_IND);
		ddb_entry_trap(T_KDB_ENTRY, (db_regs_t*)frame);
		set_psr(psr);
		/* skip trap instruction */
		m88110_skip_insn(frame);
		splx(s);
		return;
#endif /* DDB */
	case T_ILLFLT:
		/*
		 * The 88110 seems to trigger an instruction fault in
		 * supervisor mode when running the following sequence:
		 *
		 *	bcnd.n cond, reg, 1f
		 *	arithmetic insn
		 *	...
		 *  	the same exact arithmetic insn
		 *  1:	another arithmetic insn stalled by the previous one
		 *	...
		 *
		 * The exception is reported with exip pointing to the
		 * branch address. I don't know, at this point, if there
		 * is any better workaround than the aggressive one
		 * implemented below; I don't see how this could relate to
		 * any of the 88110 errata (although it might be related to
		 * branch prediction).
		 *
		 * For the record, the exact sequence triggering the
		 * spurious exception is:
		 *
		 *	bcnd.n	eq0, r2,  1f
		 *	 or	r25, r0,  r22
		 *	bsr	somewhere
		 *	or	r25, r0,  r22
		 *  1:	cmp	r13, r25, r20
		 *
		 * within the same cache line.
		 *
		 * Simply ignoring the exception and returning does not
		 * cause the exception to disappear. Clearing the
		 * instruction cache works, but on 88110+88410 systems,
		 * the 88410 needs to be invalidated as well. (note that
		 * the size passed to the flush routines does not matter
		 * since there is no way to flush a subset of the 88110
		 * I$ anyway)
		 */
	    {
		extern void *kernel_text, *etext;

		if (fault_addr >= (vaddr_t)&kernel_text &&
		    fault_addr < (vaddr_t)&etext) {
			cmmu_icache_inv(curcpu()->ci_cpuid,
			    trunc_page(fault_addr), PAGE_SIZE);
			cmmu_cache_wbinv(curcpu()->ci_cpuid,
			    trunc_page(fault_addr), PAGE_SIZE);
			return;
		}
	    }
		goto lose;
	case T_MISALGNFLT:
		printf("kernel misaligned access exception @@%p\n",
		    (void *)frame->tf_exip);
		goto lose;
	case T_INSTFLT:
		/* kernel mode instruction access fault.
		 * Should never, never happen for a non-paged kernel.
		 */
#ifdef TRAPDEBUG
		printf("Kernel Instruction fault exip %x isr %x ilar %x\n",
		    frame->tf_exip, frame->tf_isr, frame->tf_ilar);
#endif
		goto lose;

	case T_DATAFLT:
		/* kernel mode data fault */

		/* data fault on the user address? */
		if ((frame->tf_dsr & CMMU_DSR_SU) == 0) {
			KERNEL_LOCK();
			goto m88110_user_fault;
		}

#ifdef TRAPDEBUG
		printf("Kernel Data access fault exip %x dsr %x dlar %x\n",
		    frame->tf_exip, frame->tf_dsr, frame->tf_dlar);
#endif

		fault_addr = frame->tf_dlar;
		if (frame->tf_dsr & CMMU_DSR_RW) {
			ftype = PROT_READ;
			fault_code = PROT_READ;
		} else {
			ftype = PROT_READ | PROT_WRITE;
			fault_code = PROT_WRITE;
		}

		va = trunc_page((vaddr_t)fault_addr);

		KERNEL_LOCK();
		vm = p->p_vmspace;
		map = kernel_map;

		if (frame->tf_dsr & (CMMU_DSR_SI | CMMU_DSR_PI)) {
			/*
			 * On a segment or a page fault, call uvm_fault() to
			 * resolve the fault.
			 */
			if ((pcb_onfault = p->p_addr->u_pcb.pcb_onfault) != 0)
				p->p_addr->u_pcb.pcb_onfault = 0;
			result = uvm_fault(map, va, VM_FAULT_INVALID, ftype);
			p->p_addr->u_pcb.pcb_onfault = pcb_onfault;
			/*
			 * This could be a fault caused in copyout*()
			 * while accessing kernel space.
			 */
			if (result != 0 && pcb_onfault != 0) {
				frame->tf_exip = pcb_onfault;
				/*
				 * Continue as if the fault had been resolved.
				 */
				result = 0;
			}
			if (result == 0) {
				KERNEL_UNLOCK();
				return;
			}
		}
		KERNEL_UNLOCK();
		goto lose;
	case T_INSTFLT+T_USER:
		/* User mode instruction access fault */
		/* FALLTHROUGH */
	case T_DATAFLT+T_USER:
		KERNEL_LOCK();
m88110_user_fault:
		if (type == T_INSTFLT+T_USER) {
			ftype = PROT_READ;
			fault_code = PROT_READ;
#ifdef TRAPDEBUG
			printf("User Instruction fault exip %x isr %x ilar %x\n",
			    frame->tf_exip, frame->tf_isr, frame->tf_ilar);
#endif
		} else {
			fault_addr = frame->tf_dlar;
			if (frame->tf_dsr & CMMU_DSR_RW) {
				ftype = PROT_READ;
				fault_code = PROT_READ;
			} else {
				ftype = PROT_READ | PROT_WRITE;
				fault_code = PROT_WRITE;
			}
#ifdef TRAPDEBUG
			printf("User Data access fault exip %x dsr %x dlar %x\n",
			    frame->tf_exip, frame->tf_dsr, frame->tf_dlar);
#endif
		}

		va = trunc_page((vaddr_t)fault_addr);

		vm = p->p_vmspace;
		map = &vm->vm_map;
		if ((pcb_onfault = p->p_addr->u_pcb.pcb_onfault) != 0)
			p->p_addr->u_pcb.pcb_onfault = 0;

		/*
		 * Call uvm_fault() to resolve non-bus error faults
		 * whenever possible.
		 */
		if (type == T_INSTFLT+T_USER) {
			/* instruction faults */
			if (frame->tf_isr &
			    (CMMU_ISR_BE | CMMU_ISR_SP | CMMU_ISR_TBE)) {
				/* bus error, supervisor protection */
				result = EACCES;
			} else
			if (frame->tf_isr & (CMMU_ISR_SI | CMMU_ISR_PI)) {
				/* segment or page fault */
				result = uvm_fault(map, va, VM_FAULT_INVALID, ftype);
				if (result == EACCES)
					result = EFAULT;
			} else {
#ifdef TRAPDEBUG
				printf("Unexpected Instruction fault isr %x\n",
				    frame->tf_isr);
#endif
				KERNEL_UNLOCK();
				goto lose;
			}
		} else {
			/* data faults */
			if (frame->tf_dsr & CMMU_DSR_BE) {
				/* bus error */
				result = EACCES;
			} else
			if (frame->tf_dsr & (CMMU_DSR_SI | CMMU_DSR_PI)) {
				/* segment or page fault */
				result = uvm_fault(map, va, VM_FAULT_INVALID, ftype);
				if (result == EACCES)
					result = EFAULT;
			} else
			if (frame->tf_dsr & (CMMU_DSR_CP | CMMU_DSR_WA)) {
				/* copyback or write allocate error */
				result = EACCES;
			} else
			if (frame->tf_dsr & CMMU_DSR_WE) {
				/* write fault  */
				/* This could be a write protection fault or an
				 * exception to set the used and modified bits
				 * in the pte. Basically, if we got a write
				 * error, then we already have a pte entry that
				 * faulted in from a previous seg fault or page
				 * fault.
				 * Get the pte and check the status of the
				 * modified and valid bits to determine if this
				 * indeed a real write fault.  XXX smurph
				 */
				if (pmap_set_modify(map->pmap, va)) {
#ifdef TRAPDEBUG
					printf("Corrected userland write fault, pmap %p va %p\n",
					    map->pmap, va);
#endif
					result = 0;
				} else {
					/* must be a real wp fault */
#ifdef TRAPDEBUG
					printf("Uncorrected userland write fault, pmap %p va %p\n",
					    map->pmap, va);
#endif
					result = uvm_fault(map, va, VM_FAULT_INVALID, ftype);
					if (result == EACCES)
						result = EFAULT;
				}
			} else {
#ifdef TRAPDEBUG
				printf("Unexpected Data access fault dsr %x\n",
				    frame->tf_dsr);
#endif
				KERNEL_UNLOCK();
				goto lose;
			}
		}
		p->p_addr->u_pcb.pcb_onfault = pcb_onfault;

		if (result == 0 && (caddr_t)va >= vm->vm_maxsaddr)
			uvm_grow(p, va);
		KERNEL_UNLOCK();

		/*
		 * This could be a fault caused in copyin*()
		 * while accessing user space.
		 */
		if (result != 0 && pcb_onfault != 0) {
			frame->tf_exip = pcb_onfault;
			/*
			 * Continue as if the fault had been resolved.
			 */
			result = 0;
		}

		if (result != 0) {
			sig = result == EACCES ? SIGBUS : SIGSEGV;
			fault_type = result == EACCES ?
			    BUS_ADRERR : SEGV_MAPERR;
		}
		break;
	case T_MISALGNFLT+T_USER:
		/* Fix any misaligned ld.d or st.d instructions */
		sig = double_reg_fixup(frame, T_MISALGNFLT);
		fault_type = BUS_ADRALN;
		if (sig == 0) {
			/* skip recovered instruction */
			m88110_skip_insn(frame);
			goto userexit;
		}
		break;
	case T_ILLFLT+T_USER:
		/* Fix any ld.d or st.d instruction with an odd register */
		sig = double_reg_fixup(frame, T_ILLFLT);
		fault_type = ILL_PRVREG;
		if (sig == 0) {
			/* skip recovered instruction */
			m88110_skip_insn(frame);
			goto userexit;
		}
		break;
	case T_PRIVINFLT+T_USER:
		fault_type = ILL_PRVREG;
		/* FALLTHROUGH */
#ifndef DDB
	case T_KDB_BREAK:
	case T_KDB_ENTRY:
	case T_KDB_TRACE:
#endif
	case T_KDB_BREAK+T_USER:
	case T_KDB_ENTRY+T_USER:
	case T_KDB_TRACE+T_USER:
		sig = SIGILL;
		break;
	case T_BNDFLT+T_USER:
		sig = SIGFPE;
		/* skip trap instruction */
		m88110_skip_insn(frame);
		break;
	case T_ZERODIV+T_USER:
		sig = SIGFPE;
		fault_type = FPE_INTDIV;
		/* skip trap instruction */
		m88110_skip_insn(frame);
		break;
	case T_OVFFLT+T_USER:
		sig = SIGFPE;
		fault_type = FPE_INTOVF;
		/* skip trap instruction */
		m88110_skip_insn(frame);
		break;
	case T_FPEPFLT+T_USER:
		m88110_fpu_exception(frame);
		goto userexit;
	case T_SIGSYS+T_USER:
		sig = SIGSYS;
		break;
	case T_STEPBPT+T_USER:
#ifdef PTRACE
		/*
		 * This trap is used by the kernel to support single-step
		 * debugging (although any user could generate this trap
		 * which should probably be handled differently). When a
		 * process is continued by a debugger with the PT_STEP
		 * function of ptrace (single step), the kernel inserts
		 * one or two breakpoints in the user process so that only
		 * one instruction (or two in the case of a delayed branch)
		 * is executed.  When this breakpoint is hit, we get the
		 * T_STEPBPT trap.
		 */
		{
			u_int instr;
			vaddr_t pc = PC_REGS(&frame->tf_regs);

			/* read break instruction */
			copyin((caddr_t)pc, &instr, sizeof(u_int));

			/* check and see if we got here by accident */
			if ((p->p_md.md_bp0va != pc &&
			     p->p_md.md_bp1va != pc) ||
			    instr != SSBREAKPOINT) {
				sig = SIGTRAP;
				fault_type = TRAP_TRACE;
				break;
			}

			/* restore original instruction and clear breakpoint */
			KERNEL_LOCK();
			if (p->p_md.md_bp0va == pc) {
				ss_put_value(p, pc, p->p_md.md_bp0save);
				p->p_md.md_bp0va = 0;
			}
			if (p->p_md.md_bp1va == pc) {
				ss_put_value(p, pc, p->p_md.md_bp1save);
				p->p_md.md_bp1va = 0;
			}
			KERNEL_UNLOCK();

			sig = SIGTRAP;
			fault_type = TRAP_BRKPT;
		}
#else
		sig = SIGTRAP;
		fault_type = TRAP_TRACE;
#endif
		break;
	case T_USERBPT+T_USER:
		/*
		 * This trap is meant to be used by debuggers to implement
		 * breakpoint debugging.  When we get this trap, we just
		 * return a signal which gets caught by the debugger.
		 */
		sig = SIGTRAP;
		fault_type = TRAP_BRKPT;
		break;
	}

	/*
	 * If trap from supervisor mode, just return
	 */
	if (type < T_USER)
		return;

	if (sig) {
deliver:
		sv.sival_ptr = (void *)fault_addr;
		KERNEL_LOCK();
		trapsignal(p, sig, fault_code, fault_type, sv);
		KERNEL_UNLOCK();
	}

userexit:
	userret(p);
}
#endif /* M88110 */

__dead void
error_fatal(struct trapframe *frame)
{
	if (frame->tf_vector == 0)
		printf("\nCPU %d Reset Exception\n", cpu_number());
	else
		printf("\nCPU %d Error Exception\n", cpu_number());

#ifdef DDB
	regdump((struct trapframe*)frame);
#endif
	panic("unrecoverable exception %ld", frame->tf_vector);
}

#ifdef M88100
void
m88100_syscall(register_t code, struct trapframe *tf)
{
	int i, nsys, nap;
	struct sysent *callp;
	struct proc *p = curproc;
	int error;
	register_t args[8] __aligned(8);
	register_t rval[2] __aligned(8);
	register_t *ap;

	uvmexp.syscalls++;

	callp = p->p_p->ps_emul->e_sysent;
	nsys  = p->p_p->ps_emul->e_nsysent;

	p->p_md.md_tf = tf;

	/*
	 * For 88k, all the arguments are passed in the registers (r2-r9),
	 * and further arguments (if any) on stack.
	 * For syscall (and __syscall), r2 (and r3) has the actual code.
	 * __syscall  takes a quad syscall number, so that other
	 * arguments are at their natural alignments.
	 */
	ap = &tf->tf_r[2];
	nap = 8; /* r2-r9 */

	switch (code) {
	case SYS_syscall:
		code = *ap++;
		nap--;
		break;
	case SYS___syscall:
		if (callp != sysent)
			break;
		code = ap[_QUAD_LOWWORD];
		ap += 2;
		nap -= 2;
		break;
	}

	if (code < 0 || code >= nsys)
		callp += p->p_p->ps_emul->e_nosys;
	else
		callp += code;

	i = callp->sy_argsize / sizeof(register_t);
	if (i > sizeof(args) / sizeof(register_t))
		panic("syscall nargs");
	if (i > nap) {
		bcopy((caddr_t)ap, (caddr_t)args, nap * sizeof(register_t));
		if ((error = copyin((caddr_t)tf->tf_r[31], args + nap,
		    (i - nap) * sizeof(register_t))))
			goto bad;
	} else
		bcopy((caddr_t)ap, (caddr_t)args, i * sizeof(register_t));

	rval[0] = 0;
	rval[1] = tf->tf_r[3];

	error = mi_syscall(p, code, callp, args, rval);

	/*
	 * system call will look like:
	 *	 or r13, r0, <code>
	 *       tb0 0, r0, <128> <- sxip
	 *	 br err 	  <- snip
	 *       jmp r1 	  <- sfip
	 *  err: or.u r3, r0, hi16(errno)
	 *	 st r2, r3, lo16(errno)
	 *	 subu r2, r0, 1
	 *	 jmp r1
	 *
	 * So, when we take syscall trap, sxip/snip/sfip will be as
	 * shown above.
	 * Given this,
	 * 1. If the system call returned 0, need to skip nip.
	 *	nip = fip, fip += 4
	 *    (doesn't matter what fip + 4 will be but we will never
	 *    execute this since jmp r1 at nip will change the execution flow.)
	 * 2. If the system call returned an errno > 0, plug the value
	 *    in r2, and leave nip and fip unchanged. This will have us
	 *    executing "br err" on return to user space.
	 * 3. If the system call code returned ERESTART,
	 *    we need to rexecute the trap instruction. Back up the pipe
	 *    line.
	 *     fip = nip, nip = xip
	 * 4. If the system call returned EJUSTRETURN, don't need to adjust
	 *    any pointers.
	 */

	switch (error) {
	case 0:
		tf->tf_r[2] = rval[0];
		tf->tf_r[3] = rval[1];
		tf->tf_epsr &= ~PSR_C;
		tf->tf_snip = tf->tf_sfip & ~NIP_E;
		tf->tf_sfip = tf->tf_snip + 4;
		break;
	case ERESTART:
		m88100_rewind_insn(&(tf->tf_regs));
		/* clear the error bit */
		tf->tf_sfip &= ~FIP_E;
		tf->tf_snip &= ~NIP_E;
		break;
	case EJUSTRETURN:
		break;
	default:
	bad:
		tf->tf_r[2] = error;
		tf->tf_epsr |= PSR_C;   /* fail */
		tf->tf_snip = tf->tf_snip & ~NIP_E;
		tf->tf_sfip = tf->tf_sfip & ~FIP_E;
		break;
	}

	mi_syscall_return(p, code, error, rval);
}
#endif /* M88100 */

#ifdef M88110
/* Instruction pointers operate differently on mc88110 */
void
m88110_syscall(register_t code, struct trapframe *tf)
{
	int i, nsys, nap;
	struct sysent *callp;
	struct proc *p = curproc;
	int error;
	register_t args[8] __aligned(8);
	register_t rval[2] __aligned(8);
	register_t *ap;

	uvmexp.syscalls++;

	callp = p->p_p->ps_emul->e_sysent;
	nsys  = p->p_p->ps_emul->e_nsysent;

	p->p_md.md_tf = tf;

	/*
	 * For 88k, all the arguments are passed in the registers (r2-r9),
	 * and further arguments (if any) on stack.
	 * For syscall (and __syscall), r2 (and r3) has the actual code.
	 * __syscall  takes a quad syscall number, so that other
	 * arguments are at their natural alignments.
	 */
	ap = &tf->tf_r[2];
	nap = 8;	/* r2-r9 */

	switch (code) {
	case SYS_syscall:
		code = *ap++;
		nap--;
		break;
	case SYS___syscall:
		if (callp != sysent)
			break;
		code = ap[_QUAD_LOWWORD];
		ap += 2;
		nap -= 2;
		break;
	}

	if (code < 0 || code >= nsys)
		callp += p->p_p->ps_emul->e_nosys;
	else
		callp += code;

	i = callp->sy_argsize / sizeof(register_t);
	if (i > sizeof(args) / sizeof(register_t))
		panic("syscall nargs");
	if (i > nap) {
		bcopy((caddr_t)ap, (caddr_t)args, nap * sizeof(register_t));
		if ((error = copyin((caddr_t)tf->tf_r[31], args + nap,
		    (i - nap) * sizeof(register_t))))
			goto bad;
	} else
		bcopy((caddr_t)ap, (caddr_t)args, i * sizeof(register_t));

	rval[0] = 0;
	rval[1] = tf->tf_r[3];

	error = mi_syscall(p, code, callp, args, rval);

	/*
	 * system call will look like:
	 *	 or r13, r0, <code>
	 *       tb0 0, r0, <128> <- exip
	 *	 br err 	  <- enip
	 *       jmp r1
	 *  err: or.u r3, r0, hi16(errno)
	 *	 st r2, r3, lo16(errno)
	 *	 subu r2, r0, 1
	 *	 jmp r1
	 *
	 * So, when we take syscall trap, exip/enip will be as
	 * shown above.
	 * Given this,
	 * 1. If the system call returned 0, need to jmp r1.
	 *    exip += 8
	 * 2. If the system call returned an errno > 0, increment
	 *    exip += 4 and plug the value in r2. This will have us
	 *    executing "br err" on return to user space.
	 * 3. If the system call code returned ERESTART,
	 *    we need to rexecute the trap instruction. leave exip as is.
	 * 4. If the system call returned EJUSTRETURN, just return.
	 *    exip += 4
	 */

	switch (error) {
	case 0:
		tf->tf_r[2] = rval[0];
		tf->tf_r[3] = rval[1];
		tf->tf_epsr &= ~PSR_C;
		/* skip two instructions */
		m88110_skip_insn(tf);
		m88110_skip_insn(tf);
		break;
	case ERESTART:
		/*
		 * Reexecute the trap.
		 * exip is already at the trap instruction, so
		 * there is nothing to do.
		 */
		break;
	case EJUSTRETURN:
		/* skip one instruction */
		m88110_skip_insn(tf);
		break;
	default:
	bad:
		tf->tf_r[2] = error;
		tf->tf_epsr |= PSR_C;   /* fail */
		/* skip one instruction */
		m88110_skip_insn(tf);
		break;
	}

	mi_syscall_return(p, code, error, rval);
}
#endif	/* M88110 */

/*
 * Set up return-value registers as fork() libc stub expects,
 * and do normal return-to-user-mode stuff.
 */
void
child_return(arg)
	void *arg;
{
	struct proc *p = arg;
	struct trapframe *tf;

	tf = (struct trapframe *)USER_REGS(p);
	tf->tf_r[2] = 0;
	tf->tf_r[3] = 0;
	tf->tf_epsr &= ~PSR_C;
	/* reset r26 (used by the threads library) if __tfork */
	if (p->p_flag & P_THREAD)
		tf->tf_r[26] = 0;
	/* skip br instruction as in syscall() */
#ifdef M88100
	if (CPU_IS88100) {
		tf->tf_snip = (tf->tf_sfip & XIP_ADDR) | XIP_V;
		tf->tf_sfip = tf->tf_snip + 4;
	}
#endif
#ifdef M88110
	if (CPU_IS88110) {
		/* skip two instructions */
		m88110_skip_insn(tf);
		m88110_skip_insn(tf);
	}
#endif

	KERNEL_UNLOCK();

	mi_child_return(p);
}

#ifdef PTRACE

/*
 * User Single Step Debugging Support
 */

#include <sys/ptrace.h>

vaddr_t	ss_branch_taken(u_int, vaddr_t, struct reg *);
int	ss_get_value(struct proc *, vaddr_t, u_int *);
int	ss_inst_branch_or_call(u_int);
int	ss_put_breakpoint(struct proc *, vaddr_t, vaddr_t *, u_int *);

#define	SYSCALL_INSTR	0xf000d080	/* tb0 0,r0,128 */

int
ss_get_value(struct proc *p, vaddr_t addr, u_int *value)
{
	struct uio uio;
	struct iovec iov;

	iov.iov_base = (caddr_t)value;
	iov.iov_len = sizeof(u_int);
	uio.uio_iov = &iov;
	uio.uio_iovcnt = 1;
	uio.uio_offset = (off_t)addr;
	uio.uio_resid = sizeof(u_int);
	uio.uio_segflg = UIO_SYSSPACE;
	uio.uio_rw = UIO_READ;
	uio.uio_procp = curproc;
	return (process_domem(curproc, p->p_p, &uio, PT_READ_I));
}

int
ss_put_value(struct proc *p, vaddr_t addr, u_int value)
{
	struct uio uio;
	struct iovec iov;

	iov.iov_base = (caddr_t)&value;
	iov.iov_len = sizeof(u_int);
	uio.uio_iov = &iov;
	uio.uio_iovcnt = 1;
	uio.uio_offset = (off_t)addr;
	uio.uio_resid = sizeof(u_int);
	uio.uio_segflg = UIO_SYSSPACE;
	uio.uio_rw = UIO_WRITE;
	uio.uio_procp = curproc;
	return (process_domem(curproc, p->p_p, &uio, PT_WRITE_I));
}

/*
 * ss_branch_taken(instruction, pc, regs)
 *
 * instruction will be a control flow instruction location at address pc.
 * Branch taken is supposed to return the address to which the instruction
 * would jump if the branch is taken.
 *
 * This is different from branch_taken() in ddb, as we also need to process
 * system calls.
 */
vaddr_t
ss_branch_taken(u_int inst, vaddr_t pc, struct reg *regs)
{
	u_int regno;

	/*
	 * Quick check of the instruction. Note that we know we are only
	 * invoked if ss_inst_branch_or_call() returns TRUE, so we do not
	 * need to repeat the jpm, jsr and syscall stricter checks here.
	 */
	switch (inst >> (32 - 5)) {
	case 0x18:	/* br */
	case 0x19:	/* bsr */
		/* signed 26 bit pc relative displacement, shift left 2 bits */
		inst = (inst & 0x03ffffff) << 2;
		/* check if sign extension is needed */
		if (inst & 0x08000000)
			inst |= 0xf0000000;
		return (pc + inst);

	case 0x1a:	/* bb0 */
	case 0x1b:	/* bb1 */
	case 0x1d:	/* bcnd */
		/* signed 16 bit pc relative displacement, shift left 2 bits */
		inst = (inst & 0x0000ffff) << 2;
		/* check if sign extension is needed */
		if (inst & 0x00020000)
			inst |= 0xfffc0000;
		return (pc + inst);

	case 0x1e:	/* jmp or jsr */
		regno = inst & 0x1f;	/* get the register value */
		return (regno == 0 ? 0 : regs->r[regno]);

	default:	/* system call */
		/*
		 * The regular (pc + 4) breakpoint will match the error
		 * return. Successful system calls return at (pc + 8),
		 * so we'll set up a branch breakpoint there.
		 */
		return (pc + 8);
	}
}

int
ss_inst_branch_or_call(u_int ins)
{
	/* check high five bits */
	switch (ins >> (32 - 5)) {
	case 0x18: /* br */
	case 0x19: /* bsr */
	case 0x1a: /* bb0 */
	case 0x1b: /* bb1 */
	case 0x1d: /* bcnd */
		return (TRUE);
	case 0x1e: /* could be jmp or jsr */
		if ((ins & 0xfffff3e0) == 0xf400c000)
			return (TRUE);
	}

	return (FALSE);
}

int
ss_put_breakpoint(struct proc *p, vaddr_t va, vaddr_t *bpva, u_int *bpsave)
{
	int rc;

	/* Restore previous breakpoint if we did not trigger it. */
	if (*bpva != 0) {
		ss_put_value(p, *bpva, *bpsave);
		*bpva = 0;
	}

	/* Save instruction. */
	if ((rc = ss_get_value(p, va, bpsave)) != 0)
		return (rc);

	/* Store breakpoint instruction at the location now. */
	*bpva = va;
	return (ss_put_value(p, va, SSBREAKPOINT));
}

int
process_sstep(struct proc *p, int sstep)
{
	struct reg *sstf = USER_REGS(p);
	vaddr_t pc, brpc;
	u_int32_t instr;
	int rc;

	if (sstep == 0) {
		/* Restore previous breakpoints if any. */
		if (p->p_md.md_bp0va != 0) {
			ss_put_value(p, p->p_md.md_bp0va, p->p_md.md_bp0save);
			p->p_md.md_bp0va = 0;
		}
		if (p->p_md.md_bp1va != 0) {
			ss_put_value(p, p->p_md.md_bp1va, p->p_md.md_bp1save);
			p->p_md.md_bp1va = 0;
		}

		return (0);
	}

	/*
	 * User was stopped at pc, e.g. the instruction at pc was not executed.
	 * Fetch what's at the current location.
	 */
	pc = PC_REGS(sstf);
	if ((rc = ss_get_value(p, pc, &instr)) != 0)
		return (rc);

	/*
	 * Find if this instruction may cause a branch, and set up a breakpoint
	 * at the branch location.
	 */
	if (ss_inst_branch_or_call(instr) || instr == SYSCALL_INSTR) {
		brpc = ss_branch_taken(instr, pc, sstf);

		/* self-branches are hopeless */
		if (brpc != pc && brpc != 0) {
			if ((rc = ss_put_breakpoint(p, brpc,
			    &p->p_md.md_bp1va, &p->p_md.md_bp1save)) != 0)
				return (rc);
		}
	}

	if ((rc = ss_put_breakpoint(p, pc + 4,
	    &p->p_md.md_bp0va, &p->p_md.md_bp0save)) != 0)
		return (rc);

	return (0);
}

#endif	/* PTRACE */

#ifdef DIAGNOSTIC
void
splassert_check(int wantipl, const char *func)
{
	int oldipl;

	oldipl = getipl();

	if (oldipl < wantipl) {
		splassert_fail(wantipl, oldipl, func);
		/*
		 * This will raise the spl,
		 * in a feeble attempt to reduce further damage.
		 */
		(void)splraise(wantipl);
	}
}
#endif

/*
 * ld.d and st.d instructions referencing long aligned but not long long
 * aligned addresses will trigger a misaligned address exception.
 *
 * This routine attempts to recover these (valid) statements, by simulating
 * the split form of the instruction. If it fails, it returns the appropriate
 * signal number to deliver.
 *
 * Note that we do not attempt to do anything for .d.usr instructions - the
 * kernel never issues such instructions, and they cause a privileged
 * instruction exception from userland.
 */
int
double_reg_fixup(struct trapframe *frame, int fault)
{
	u_int32_t pc, instr, value;
	int regno, store;
	vaddr_t addr;

	/*
	 * Decode the faulting instruction.
	 */

	pc = PC_REGS(&frame->tf_regs);
	if (copyin((void *)pc, &instr, sizeof(u_int32_t)) != 0)
		return SIGSEGV;

	switch (instr & 0xfc00ff00) {
	case 0xf4001000:	/* ld.d rD, rS1, rS2 */
		addr = frame->tf_r[(instr >> 16) & 0x1f]
		    + frame->tf_r[(instr & 0x1f)];
		store = 0;
		break;
	case 0xf4002000:	/* st.d rD, rS1, rS2 */
		addr = frame->tf_r[(instr >> 16) & 0x1f]
		    + frame->tf_r[(instr & 0x1f)];
		store = 1;
		break;
	default:
		switch (instr >> 26) {
		case 0x10000000 >> 26:	/* ld.d rD, rS, imm16 */
			addr = (instr & 0x0000ffff) +
			    frame->tf_r[(instr >> 16) & 0x1f];
			store = 0;
			break;
		case 0x20000000 >> 26:	/* st.d rD, rS, imm16 */
			addr = (instr & 0x0000ffff) +
			    frame->tf_r[(instr >> 16) & 0x1f];
			store = 1;
			break;
		default:
			return SIGBUS;
		}
		break;
	}

	regno = (instr >> 21) & 0x1f;

	switch (fault) {
	case T_MISALGNFLT:
		/* We only handle long but not long long aligned access here */
		if ((addr & 0x07) != 4)
			return SIGBUS;
		break;
	case T_ILLFLT:
		/* We only handle odd register pair number here */
		if ((regno & 0x01) == 0)
			return SIGILL;
		/* We only handle long aligned access here */
		if ((addr & 0x03) != 0)
			return SIGBUS;
		break;
	}

	if (store) {
		/*
		 * Two word stores.
		 */
		if (regno == 0)
			value = 0;
		else
			value = frame->tf_r[regno];
		if (copyout(&value, (void *)addr, sizeof(u_int32_t)) != 0)
			return SIGSEGV;
		if (regno == 31)
			value = 0;
		else
			value = frame->tf_r[regno + 1];
		if (copyout(&value, (void *)(addr + 4), sizeof(u_int32_t)) != 0)
			return SIGSEGV;
	} else {
		/*
		 * Two word loads. r0 should be left unaltered, but the
		 * value should still be fetched even if it is discarded.
		 */
		if (copyin((void *)addr, &value, sizeof(u_int32_t)) != 0)
			return SIGSEGV;
		if (regno != 0)
			frame->tf_r[regno] = value;
		if (copyin((void *)(addr + 4), &value, sizeof(u_int32_t)) != 0)
			return SIGSEGV;
		if (regno != 31)
			frame->tf_r[regno + 1] = value;
	}

	return 0;
}

void
cache_flush(struct trapframe *tf)
{
	struct proc *p = curproc;
	struct pmap *pmap;
	paddr_t pa;
	vaddr_t va;
	vsize_t len, count;

	p->p_md.md_tf = tf;

	pmap = vm_map_pmap(&p->p_vmspace->vm_map);
	va = tf->tf_r[2];
	len = tf->tf_r[3];

	if (va < VM_MIN_ADDRESS || va >= VM_MAXUSER_ADDRESS ||
	    va + len <= va || va + len >= VM_MAXUSER_ADDRESS)
		len = 0;

	while (len != 0) {
		count = min(len, PAGE_SIZE - (va & PAGE_MASK));
		if (pmap_extract(pmap, va, &pa) != FALSE)	
			dma_cachectl(pa, count, DMA_CACHE_SYNC);
		va += count;
		len -= count;
	}

#ifdef M88100
	if (CPU_IS88100) {
		/* clear the error bit */
		tf->tf_sfip &= ~FIP_E;
		tf->tf_snip &= ~NIP_E;
	}
#endif
#ifdef M88110
	if (CPU_IS88110) {
		/* skip instruction */
		m88110_skip_insn(tf);
	}
#endif

	userret(p);
}
@


1.106
log
@Make this build (and run) with gcc 4.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.105 2016/10/19 08:31:33 guenther Exp $	*/
a47 1
#include <sys/types.h>
@


1.105
log
@Change process_{domem,auxv_offset}() to take a process instead of a proc.
Make process_auxv_offset() take and release a reference of the vmspace like
process_domem() does.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.104 2016/06/13 23:51:59 dlg Exp $	*/
d1149 3
a1151 1
	register_t args[8], rval[2], *ap;
d1272 3
a1274 1
	register_t args[8], rval[2], *ap;
@


1.104
log
@rename raiseipl to splraise()

another step toward making splraise an MI api.

ok aoyama@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.103 2015/09/13 11:32:29 miod Exp $	*/
d1450 1
a1450 1
	return (process_domem(curproc, p, &uio, PT_READ_I));
d1468 1
a1468 1
	return (process_domem(curproc, p, &uio, PT_WRITE_I));
@


1.103
log
@<sys/systm.h> must be before <sys/syscall_mi.h> now.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.102 2015/02/10 10:15:30 miod Exp $	*/
d1632 1
a1632 1
		(void)raiseipl(wantipl);
@


1.102
log
@Enable `va < VM_MIN_ADDRESS' check now that VM_MIN_ADDRESS is nonzero.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.101 2014/11/16 12:30:58 deraadt Exp $	*/
d54 1
a55 1
#include <sys/systm.h>
@


1.101
log
@Replace a plethora of historical protection options with just
PROT_NONE, PROT_READ, PROT_WRITE, and PROT_EXEC from mman.h.
PROT_MASK is introduced as the one true way of extracting those bits.
Remove UVM_ADV_* wrapper, using the standard names.
ok doug guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.100 2014/07/02 18:37:34 miod Exp $	*/
d1760 1
a1760 1
	if (/* va < VM_MIN_ADDRESS || */ va >= VM_MAXUSER_ADDRESS ||
@


1.100
log
@Make sure the kernel lock is held when invoking process_domem(); fixes
ptrace operation on MP kernels.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.99 2014/07/01 20:26:09 miod Exp $	*/
d298 2
a299 2
			ftype = VM_PROT_READ|VM_PROT_WRITE;
			fault_code = VM_PROT_WRITE;
d301 2
a302 2
			ftype = VM_PROT_READ;
			fault_code = VM_PROT_READ;
d402 2
a403 2
			ftype = VM_PROT_READ | VM_PROT_WRITE;
			fault_code = VM_PROT_WRITE;
d405 2
a406 2
			ftype = VM_PROT_READ;
			fault_code = VM_PROT_READ;
d816 2
a817 2
			ftype = VM_PROT_READ;
			fault_code = VM_PROT_READ;
d819 2
a820 2
			ftype = VM_PROT_READ|VM_PROT_WRITE;
			fault_code = VM_PROT_WRITE;
d863 2
a864 2
			ftype = VM_PROT_READ;
			fault_code = VM_PROT_READ;
d872 2
a873 2
				ftype = VM_PROT_READ;
				fault_code = VM_PROT_READ;
d875 2
a876 2
				ftype = VM_PROT_READ|VM_PROT_WRITE;
				fault_code = VM_PROT_WRITE;
@


1.99
log
@Replace the assembly 88100 FPU imprecise exception code (mostly triggered by
denormal results) with C code using softfloat to correctly round the inexact
results in the best possible way according to the current rounding mode.

No functional change intended, and this assembly code was surprisingly almost
non-buggy, as opposed to the precise exception code replaced a few weeks ago;
still an improvement as this replaces 900 lines of arcane assembly with 90
lines of understandable C code.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.98 2014/06/09 16:26:32 miod Exp $	*/
d546 1
d555 1
d1078 1
d1087 1
@


1.98
log
@Replace the unmaintainable assembler code responsible for 88100 precise FPU
fault handling with a C wrapper around the softfloat code, as already done for
88110 kernels.

As a bonus, attempting to read or write FPU control registers but fcr62 and
fcr63 in userland will now correctly signal an illegal instruction, instead
of leaving the destination register unchanged and pretending nothing bad
happened.

Be sure to rm m88100_fp.d in your kernel compile directory after updating your
tree.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.97 2014/06/09 14:33:20 miod Exp $	*/
d512 1
a512 23
		/* Check for a SIGFPE condition */
		if (frame->tf_fpsr & frame->tf_fpcr) {
			sig = SIGFPE;
			if (frame->tf_fpecr & FPECR_FIOV)
				fault_type = FPE_FLTSUB;
			else if (frame->tf_fpecr & FPECR_FROP)
				fault_type = FPE_FLTINV;
			else if (frame->tf_fpecr & FPECR_FDVZ)
				fault_type = FPE_INTDIV;
			else if (frame->tf_fpecr & FPECR_FUNF) {
				if (frame->tf_fpsr & FPSR_EFUNF)
					fault_type = FPE_FLTUND;
				else if (frame->tf_fpsr & FPSR_EFINX)
					fault_type = FPE_FLTRES;
			} else if (frame->tf_fpecr & FPECR_FOVF) {
				if (frame->tf_fpsr & FPSR_EFOVF)
					fault_type = FPE_FLTOVF;
				else if (frame->tf_fpsr & FPSR_EFINX)
					fault_type = FPE_FLTRES;
			} else if (frame->tf_fpecr & FPECR_FINX)
				fault_type = FPE_FLTRES;
		}
		break;
@


1.97
log
@More format string fixes (in 88110 code)
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.96 2014/05/31 11:27:50 miod Exp $	*/
d509 1
a509 1
		goto maysigfpe;
a511 1
maysigfpe:
d618 1
@


1.96
log
@Address several problems in signal delivery on 88100 processors:
- when building the sigcontext, rewind the pipeline for recoverable
  exceptions, so that sigreturn actually has a chance to cause the
  interrupted instruction to be run again.
- when returning with sigreturn, and the sigcontext contains valid
  DAE information, the DAE need to be emulated before returning, for
  the processor will not reissue them.
- finally, when the sigframe is allocated on the current process' stack,
  be careful not to stomp upon addresses referenced by the DAE information,
  for this would defeat the previous point.

All these changes only affect 88100 processors only. 88110 operation is
unchanged.

While there, do not copyout an empty siginfo struct if the signal handler
does not expect any.

Hair-pulling evil testcase provided by aoyama@@, based upon one of
devel/libsigsegv configure tests (which would spin on 88100 and run happily on
88110).
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.95 2014/05/31 11:19:06 miod Exp $	*/
d143 1
a143 1
		printf("\nTrap type %d, v = %x, frame %p\n",
d685 1
a685 1
				panic("mc88110 errata #16, exip %p enip %p",
d692 1
a692 1
				uprintf("mc88110 errata #16, exip %p enip %p",
d808 1
a808 1
		    frame->tf_exip);
@


1.95
log
@Introduce m88100_rewind_insn() to rewind the execution pipeline one
instruction, rather than gazillions of inline variants. This also makes
the situations where we clear specific bits in the fip or nip registers
more visible.

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.94 2014/05/26 17:31:17 miod Exp $	*/
a577 1
			m88100_rewind_insn(&(frame->tf_regs));
a582 1
		m88100_rewind_insn(&(frame->tf_regs));
@


1.94
log
@Do not change the state of the carry bit in the psr when returning with
ERESTART or EJUSTRETURN, for we're not supposed to. (Actually, setting the
carry bit upon syscall failure doesn't make much sense on m88k, since this is
not how the syscall stubs check for failure)
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.93 2014/05/11 00:12:44 guenther Exp $	*/
a358 1
				frame->tf_sxip = 0;
d438 4
a441 6
				/*
				 * back up SXIP, SNIP,
				 * clearing the Error bit
				 */
				frame->tf_sfip = frame->tf_snip & ~FIP_E;
				frame->tf_snip = frame->tf_sxip & ~NIP_E;
a463 1
				frame->tf_sxip = 0;
d578 2
a579 4
#if 1
			frame->tf_sfip = frame->tf_snip;
			frame->tf_snip = pc | NIP_V;
#endif
d584 1
a595 2
		frame->tf_sfip = frame->tf_snip;
		frame->tf_snip = frame->tf_sxip;
d1261 4
a1264 2
		tf->tf_sfip = tf->tf_snip & ~FIP_E;
		tf->tf_snip = tf->tf_sxip & ~NIP_E;
d1794 3
a1796 2
		tf->tf_snip = tf->tf_snip & ~NIP_E;
		tf->tf_sfip = tf->tf_sfip & ~FIP_E;
@


1.93
log
@Move the increment of uvmexp.softs back to the caller of mi_ast():
it needs to be done atomicly on some MP archs and we don't have
atomic_add_int() everywhere yet.  Also, mi_ast() was meant to be inline.

noted by miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.92 2014/05/10 05:33:00 guenther Exp $	*/
a1267 1
		tf->tf_epsr &= ~PSR_C;
a1271 1
		tf->tf_epsr &= ~PSR_C;
a1388 1
		tf->tf_epsr &= ~PSR_C;
a1390 1
		tf->tf_epsr &= ~PSR_C;
@


1.92
log
@Factor out the common ast bits into mi_ast()

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.91 2014/05/08 22:17:33 miod Exp $	*/
d210 1
@


1.91
log
@Format string fixes for m88k; remove -Wno-format from the m88k kernels.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.90 2014/04/18 11:51:17 guenther Exp $	*/
a207 1
	uvmexp.softs++;
a208 7
	if (p->p_flag & P_OWEUPC) {
		KERNEL_LOCK();
		ADDUPROF(p);
		KERNEL_UNLOCK();
	}
	if (ci->ci_want_resched)
		preempt(NULL);
d210 1
@


1.90
log
@Have each thread keeps its own (counted!) reference to the process's ucreds
to avoid possible use-after-free references when swapping ids in threaded
processes.  "Do I have the right creds?" checks are always made with the
threads creds.

Inspired by FreeBSD and NetBSD
"right time" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.89 2014/03/26 05:23:42 guenther Exp $	*/
d126 1
a126 1
			printf("\nInstr access fault (%s) v = %x, frame %p\n",
d132 1
a132 1
			printf("\nData access fault (%s) v = %x, frame %p\n",
d137 1
a137 1
			printf("\nTrap type %d, v = %x, frame %p\n",
d279 1
a279 1
		printf("kernel misaligned access exception @@%p\n",
d1171 1
a1171 1
	panic("unrecoverable exception %d", frame->tf_vector);
@


1.89
log
@Move p_emul and p_sigcode from proc to process.
Tweak the handling of ktrace EMUL when changing ktracing: only
generate one per process (not one per thread) and pass the correct
proc pointer down to the VFS layer.  Permit generating of NAMI and
CSW records inside ktrace(2) itself.

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.88 2013/09/05 20:40:32 miod Exp $	*/
d248 1
d717 1
@


1.88
log
@Service the 88100 floating-point exceptions through trap(), keeping the
existing assembly code for now. Make sure the trapframe images of %fpsr and
%fpcr are updated by the assembly handlers (in addition to the real registers
which were already updated). When returning into trap(), check these updated
value to decide whether a signal ought to be sent to the userland process.

With these changes, computations which ought to cause a signal to be delivered
will indeed trigger the signal, even when they are handled by the completion
code in the floating point exception handlers.

This fixes the libc/ieeefp/except and lib/fenv regress tests on 88100 systems,
finally!
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.87 2013/08/26 21:38:09 miod Exp $	*/
d1184 2
a1185 2
	callp = p->p_emul->e_sysent;
	nsys  = p->p_emul->e_nsysent;
d1214 1
a1214 1
		callp += p->p_emul->e_nosys;
d1305 2
a1306 2
	callp = p->p_emul->e_sysent;
	nsys  = p->p_emul->e_nsysent;
d1335 1
a1335 1
		callp += p->p_emul->e_nosys;
@


1.87
log
@Use %r27 as the thread control block pointer, allowing for __get_tcb() calls
in libpthread to be optimized away.

While there, follow DG/UX's example of using more than one register for thread
purposes (after all, the ABI reserves four of them), and also use %r26 to store
a pointer to the current thread's errno.

Since it is not possible to initialize %r26 at thread creation without
intrusive and potentially race-prone changes, have __tfork() reset %r26 to
zero, and libpthread's __cerror lazy initialize it. As soon as %r26 is nonzero,
it will be used instead of calling __errno().

This means that binaries linked against HEAD libpthread need to run on HEAD
kernels, and we are belatedly jumping on the 64-bit time_t bump (since there
are no 64-bit time_t m88k snapshots yet).

Joint work with guenther@@; "Your love of asm is sick and wrong, and yet
beautiful." and ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.86 2013/08/18 22:17:26 miod Exp $	*/
d517 27
a543 1
		sig = SIGFPE;
@


1.86
log
@data_access_emulation() may fault. Be sure to clear pcb_onfault before
invoking it.

While there, rework the return-to-pcb_onfault logic to avoid falling through
the DAE code. This allows us to get rid of the bogus DMT_SKIP flag as well:
DAE is only necessary if DMT_VALID is set in DMT0, and DMT0 is reset to zero
afterwards.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.85 2013/04/12 04:48:52 miod Exp $	*/
d1404 3
@


1.85
log
@Double-register load and store instructions using an odd-numbered register as
the low part trigger an `illegal instruction' trap on the 88110 (and I can't
see this documented anywhere in the manual). Of course there is code "in the
wild" which uses such constructs (libgmp is one such example).

Extend double_reg_fixup() to take the trap type as an extra argument, and
explicitely allow ld.d or st.d instructions with odd-numbered registers at
aligned addresses if we are invoked from the `illegal instruction' trap
handler, to give this code a chance to run on 88110.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.84 2013/01/07 22:47:18 miod Exp $	*/
d323 1
d331 1
d333 2
a335 1
			frame->tf_dmt0 = 0;
d340 1
a340 2
			if ((pcb_onfault = p->p_addr->u_pcb.pcb_onfault) != 0)
				p->p_addr->u_pcb.pcb_onfault = 0;
a342 16
			/*
			 * This could be a fault caused in copyout*()
			 * while accessing kernel space.
			 */
			if (result != 0 && pcb_onfault != 0) {
				frame->tf_snip = pcb_onfault | NIP_V;
				frame->tf_sfip = (pcb_onfault + 4) | FIP_V;
				frame->tf_sxip = 0;
				/*
				 * Continue as if the fault had been resolved,
				 * but do not try to complete the faulting
				 * access.
				 */
				frame->tf_dmt0 |= DMT_SKIP;
				result = 0;
			}
d350 1
d352 2
d355 15
d371 1
a441 16
		/*
		 * This could be a fault caused in copyin*()
		 * while accessing user space.
		 */
		if (result != 0 && pcb_onfault != 0) {
			frame->tf_snip = pcb_onfault | NIP_V;
			frame->tf_sfip = (pcb_onfault + 4) | FIP_V;
			frame->tf_sxip = 0;
			/*
			 * Continue as if the fault had been resolved, but
			 * do not try to complete the faulting access.
			 */
			frame->tf_dmt0 |= DMT_SKIP;
			result = 0;
		}

d458 1
d460 2
d463 15
d479 5
a484 4
		} else {
			sig = result == EACCES ? SIGBUS : SIGSEGV;
			fault_type = result == EACCES ?
			    BUS_ADRERR : SEGV_MAPERR;
@


1.84
log
@Correctly signal SIGSEGV, instead of SIGBUS, for faults caused by access to
pages mapped without read (or write) permissions.
The existing logic would incorrectly match uvm_fault() returning EACCES with
the CMMU fault logic reporting a bus error (which will still cause SIGBUS
to be sent).
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.83 2012/12/31 06:46:13 guenther Exp $	*/
d84 1
a84 1
int double_reg_fixup(struct trapframe *);
d482 1
a482 1
		sig = double_reg_fixup(frame);
d993 1
a993 1
		sig = double_reg_fixup(frame);
d1001 10
a1013 1
	case T_ILLFLT+T_USER:
d1646 1
a1646 1
double_reg_fixup(struct trapframe *frame)
d1689 1
a1689 3
	/* We only handle long but not long long aligned access here */
	if ((addr & 0x07) != 4)
		return SIGBUS;
d1691 15
a1705 1
	regno = (instr >> 21) & 0x1f;
@


1.83
log
@Remove emulation errno mapping code from platforms that no longer have
non-native emulations.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.82 2012/08/07 17:17:46 guenther Exp $	*/
d427 2
d434 2
a435 6
		if ((caddr_t)va >= vm->vm_maxsaddr) {
			if (result == 0)
				uvm_grow(p, va);
			else if (result == EACCES)
				result = EFAULT;
		}
d904 2
d923 2
d955 2
d969 2
a970 6
		if ((caddr_t)va >= vm->vm_maxsaddr) {
			if (result == 0)
				uvm_grow(p, va);
			else if (result == EACCES)
				result = EFAULT;
		}
@


1.82
log
@<sys/ktrace.h> is now pulled in via <sys/syscall_mi.h>, so drop it from here
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.81 2012/08/07 05:16:53 guenther Exp $	*/
a1237 2
		if (p->p_emul->e_errno)
			error = p->p_emul->e_errno[error];
a1360 2
		if (p->p_emul->e_errno)
			error = p->p_emul->e_errno[error];
@


1.81
log
@Move the common bits of syscall invocation and return handling into
an MI file, <sys/syscall_mi.h>, correcting inconsistencies and the
handling when copyin() of arguments fails.

Tested on i386, amd64, sparc64, and alpha (thanks naddy@@)
Any issues with other platforms will be fixed in tree.

header name from millert@@; ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.80 2012/04/11 14:38:55 mikeb Exp $	*/
a55 1
#include <sys/ktrace.h>
@


1.80
log
@The first ktrace record for a newly spawned thread is a return
from a fork syscall done by the parent.  Use __tfork, not rfork
here to match the ktrace records for the parent (CALL __tfork,
RET __tfork).  ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.79 2011/11/16 20:50:18 deraadt Exp $	*/
d54 1
a57 3
#include "systrace.h"
#include <dev/systrace.h>

a1138 1
	int nolock;
d1181 4
a1184 3
		error = copyin((caddr_t)tf->tf_r[31], (caddr_t)(args + nap),
		    (i - nap) * sizeof(register_t));
	} else {
a1185 5
		error = 0;
	}

	if (error != 0)
		goto bad;
a1186 12
#ifdef SYSCALL_DEBUG
	KERNEL_LOCK();
	scdebug_call(p, code, args);
	KERNEL_UNLOCK();
#endif
#ifdef KTRACE
	if (KTRPOINT(p, KTR_SYSCALL)) {
		KERNEL_LOCK();
		ktrsyscall(p, code, callp->sy_argsize, args);
		KERNEL_UNLOCK();
	}
#endif
d1189 2
a1190 15
#if NSYSTRACE > 0
	if (ISSET(p->p_flag, P_SYSTRACE)) {
		KERNEL_LOCK();
		error = systrace_redirect(code, p, args, rval);
		KERNEL_UNLOCK();
	} else
#endif
	{
		nolock = (callp->sy_flags & SY_NOLOCK);
		if (!nolock)
			KERNEL_LOCK();
		error = (*callp->sy_call)(p, args, rval);
		if (!nolock)
			KERNEL_UNLOCK();
	}
d1238 1
a1238 1
bad:
d1247 2
a1248 13
#ifdef SYSCALL_DEBUG
	KERNEL_LOCK();
	scdebug_ret(p, code, error, rval);
	KERNEL_UNLOCK();
#endif
	userret(p);
#ifdef KTRACE
	if (KTRPOINT(p, KTR_SYSRET)) {
		KERNEL_LOCK();
		ktrsysret(p, code, error, rval[0]);
		KERNEL_UNLOCK();
	}
#endif
a1261 1
	int nolock;
d1304 4
a1307 3
		error = copyin((caddr_t)tf->tf_r[31], (caddr_t)(args + nap),
		    (i - nap) * sizeof(register_t));
	} else {
a1308 2
		error = 0;
	}
a1309 15
	if (error != 0)
		goto bad;

#ifdef SYSCALL_DEBUG
	KERNEL_LOCK();
	scdebug_call(p, code, args);
	KERNEL_UNLOCK();
#endif
#ifdef KTRACE
	if (KTRPOINT(p, KTR_SYSCALL)) {
		KERNEL_LOCK();
		ktrsyscall(p, code, callp->sy_argsize, args);
		KERNEL_UNLOCK();
	}
#endif
d1312 2
a1313 15
#if NSYSTRACE > 0
	if (ISSET(p->p_flag, P_SYSTRACE)) {
		KERNEL_LOCK();
		error = systrace_redirect(code, p, args, rval);
		KERNEL_UNLOCK();
	} else
#endif
	{
		nolock = (callp->sy_flags & SY_NOLOCK);
		if (!nolock)
			KERNEL_LOCK();
		error = (*callp->sy_call)(p, args, rval);
		if (!nolock)
			KERNEL_UNLOCK();
	}
d1363 1
a1363 1
bad:
d1373 1
a1373 13
#ifdef SYSCALL_DEBUG
	KERNEL_LOCK();
	scdebug_ret(p, code, error, rval);
	KERNEL_UNLOCK();
#endif
	userret(p);
#ifdef KTRACE
	if (KTRPOINT(p, KTR_SYSRET)) {
		KERNEL_LOCK();
		ktrsysret(p, code, error, rval[0]);
		KERNEL_UNLOCK();
	}
#endif
a1407 1
	userret(p);
d1409 1
a1409 10
#ifdef KTRACE
	if (KTRPOINT(p, KTR_SYSRET)) {
		KERNEL_LOCK();
		ktrsysret(p,
		    (p->p_flag & P_THREAD) ? SYS___tfork :
		    (p->p_p->ps_flags & PS_PPWAIT) ? SYS_vfork : SYS_fork,
		    0, 0);
		KERNEL_UNLOCK();
	}
#endif
@


1.79
log
@Make userret() MI.  On architectures which jammed stuff into it in the
past, pull that code out seperately.
ok guenther miod
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.78 2011/07/11 15:40:47 guenther Exp $	*/
d1499 1
a1499 1
		    (p->p_flag & P_THREAD) ? SYS_rfork :
@


1.78
log
@Revert art@@'s moving around of the KERNEL_LOCK()/KERNEL_UNLOCK() calls,
as it causes hangs in some ports, including libsigsegv's configure script

confirmed by krw@@, landry@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.76 2011/07/06 21:41:37 art Exp $	*/
a120 12

static inline void
userret(struct proc *p)
{
	int sig;

	/* take pending signals */
	while ((sig = CURSIG(p)) != 0)
		postsig(sig);

	curcpu()->ci_schedstate.spc_curpriority = p->p_priority = p->p_usrpri;
}
@


1.77
log
@There is a bunch of places in the kernel entry points where we don't
hold the kernel lock, but still need call one function that needs it.

Instead of grabbing the lock all over the place, move the locks into
the affected functions: trapsignal, scdebug*, ktrsyscall, ktrsysret,
systrace_redirect and ADDUPROF. In the cases we already hold the biglock
we'll just recurse.

kettenis@@, beck@@ ok
@
text
@d226 1
d228 1
d605 1
d607 1
d1120 1
d1122 1
d1207 1
d1209 1
d1213 1
d1215 1
d1222 1
d1224 1
d1292 1
d1294 1
d1299 1
d1301 1
d1371 1
d1373 1
d1377 1
d1379 1
d1386 1
d1388 1
d1459 1
d1461 1
d1466 1
d1468 1
d1509 1
d1514 1
@


1.76
log
@Clean up after P_BIGLOCK removal.
KERNEL_PROC_LOCK -> KERNEL_LOCK
KERNEL_PROC_UNLOCK -> KERNEL_UNLOCK

oga@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.75 2011/04/06 18:01:50 miod Exp $	*/
a225 1
		KERNEL_LOCK();
a226 1
		KERNEL_UNLOCK();
a602 1
		KERNEL_LOCK();
a603 1
		KERNEL_UNLOCK();
a1115 1
		KERNEL_LOCK();
a1116 1
		KERNEL_UNLOCK();
a1200 1
	KERNEL_LOCK();
a1201 1
	KERNEL_UNLOCK();
a1204 1
		KERNEL_LOCK();
a1205 1
		KERNEL_UNLOCK();
a1211 1
		KERNEL_LOCK();
a1212 1
		KERNEL_UNLOCK();
a1279 1
	KERNEL_LOCK();
a1280 1
	KERNEL_UNLOCK();
a1284 1
		KERNEL_LOCK();
a1285 1
		KERNEL_UNLOCK();
a1354 1
	KERNEL_LOCK();
a1355 1
	KERNEL_UNLOCK();
a1358 1
		KERNEL_LOCK();
a1359 1
		KERNEL_UNLOCK();
a1365 1
		KERNEL_LOCK();
a1366 1
		KERNEL_UNLOCK();
a1436 1
	KERNEL_LOCK();
a1437 1
	KERNEL_UNLOCK();
a1441 1
		KERNEL_LOCK();
a1442 1
		KERNEL_UNLOCK();
a1482 1
		KERNEL_LOCK();
a1486 1
		KERNEL_UNLOCK();
@


1.75
log
@Fix a typo causing a sanity check in m88110_syscall() to never trigger.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.74 2011/04/03 14:56:28 guenther Exp $	*/
d226 1
a226 1
		KERNEL_PROC_LOCK(p);
d228 1
a228 1
		KERNEL_PROC_UNLOCK(p);
d398 1
a398 1
		KERNEL_PROC_LOCK(p);
d495 1
a495 4
		if (type == T_DATAFLT)
			KERNEL_UNLOCK();
		else
			KERNEL_PROC_UNLOCK(p);
d605 1
a605 1
		KERNEL_PROC_LOCK(p);
d607 1
a607 1
		KERNEL_PROC_UNLOCK(p);
d876 1
a876 1
		KERNEL_PROC_LOCK(p);
d926 1
a926 4
				if (type == T_DATAFLT)
					KERNEL_UNLOCK();
				else
					KERNEL_PROC_UNLOCK(p);
d974 1
a974 4
				if (type == T_DATAFLT)
					KERNEL_UNLOCK();
				else
					KERNEL_PROC_UNLOCK(p);
d986 1
a986 4
		if (type == T_DATAFLT)
			KERNEL_UNLOCK();
		else
			KERNEL_PROC_UNLOCK(p);
d1120 1
a1120 1
		KERNEL_PROC_LOCK(p);
d1122 1
a1122 1
		KERNEL_PROC_UNLOCK(p);
d1207 1
a1207 1
	KERNEL_PROC_LOCK(p);
d1209 1
a1209 1
	KERNEL_PROC_UNLOCK(p);
d1213 1
a1213 1
		KERNEL_PROC_LOCK(p);
d1215 1
a1215 1
		KERNEL_PROC_UNLOCK(p);
d1222 1
a1222 1
		KERNEL_PROC_LOCK(p);
d1224 1
a1224 1
		KERNEL_PROC_UNLOCK(p);
d1230 1
a1230 1
			KERNEL_PROC_LOCK(p);
d1233 1
a1233 1
			KERNEL_PROC_UNLOCK(p);
d1292 1
a1292 1
	KERNEL_PROC_LOCK(p);
d1294 1
a1294 1
	KERNEL_PROC_UNLOCK(p);
d1299 1
a1299 1
		KERNEL_PROC_LOCK(p);
d1301 1
a1301 1
		KERNEL_PROC_UNLOCK(p);
d1371 1
a1371 1
	KERNEL_PROC_LOCK(p);
d1373 1
a1373 1
	KERNEL_PROC_UNLOCK(p);
d1377 1
a1377 1
		KERNEL_PROC_LOCK(p);
d1379 1
a1379 1
		KERNEL_PROC_UNLOCK(p);
d1386 1
a1386 1
		KERNEL_PROC_LOCK(p);
d1388 1
a1388 1
		KERNEL_PROC_UNLOCK(p);
d1394 1
a1394 1
			KERNEL_PROC_LOCK(p);
d1397 1
a1397 1
			KERNEL_PROC_UNLOCK(p);
d1459 1
a1459 1
	KERNEL_PROC_LOCK(p);
d1461 1
a1461 1
	KERNEL_PROC_UNLOCK(p);
d1466 1
a1466 1
		KERNEL_PROC_LOCK(p);
d1468 1
a1468 1
		KERNEL_PROC_UNLOCK(p);
d1504 1
a1504 1
	KERNEL_PROC_UNLOCK(p);
d1509 1
a1509 1
		KERNEL_PROC_LOCK(p);
d1514 1
a1514 1
		KERNEL_PROC_UNLOCK(p);
@


1.74
log
@Move PPWAIT flag from struct proc to process, so that rthreads in
a vforked child behave correctly.  Have the parent in a vfork()
wait on a (different) flag in *its* process instead of the child
to prevent a possible use-after-free.  When ktracing the child
return from a fork, call it rfork if an rthread was created.

ok blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.73 2010/12/31 20:54:21 miod Exp $	*/
d1368 1
a1368 1
	if (i > sizeof(args) > sizeof(register_t))
@


1.73
log
@Standardize cache handling functions and defines to use wb/wbinv/inv instead
of flush/sync/inval. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.72 2010/12/23 19:55:24 miod Exp $	*/
d1523 3
a1525 1
		    (p->p_flag & P_PPWAIT) ? SYS_vfork : SYS_fork, 0, 0);
@


1.72
log
@Check for pcb_onfault being set for genuine kernel data faults, copyout()
may be invoked with an address under the kernel text and we're about to
stop having such pages always mapped.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.71 2010/12/20 21:32:06 miod Exp $	*/
d797 1
a797 1
			cmmu_flush_inst_cache(curcpu()->ci_cpuid,
d799 1
a799 1
			cmmu_flush_cache(curcpu()->ci_cpuid,
@


1.71
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.70 2010/12/20 20:07:49 miod Exp $	*/
d84 1
d134 2
a135 2
__dead void
panictrap(int type, struct trapframe *frame)
a136 3
	static int panicing = 0;

	if (panicing++ == 0) {
d138 17
a154 19
		if (CPU_IS88100) {
			if (type == 2) {
				/* instruction exception */
				printf("\nInstr access fault (%s) v = %x, "
				    "frame %p\n",
				    pbus_exception_type[
				      CMMU_PFSR_FAULT(frame->tf_ipfsr)],
				    frame->tf_sxip & XIP_ADDR, frame);
			} else if (type == 3) {
				/* data access exception */
				printf("\nData access fault (%s) v = %x, "
				    "frame %p\n",
				    pbus_exception_type[
				      CMMU_PFSR_FAULT(frame->tf_dpfsr)],
				    frame->tf_sxip & XIP_ADDR, frame);
			} else
				printf("\nTrap type %d, v = %x, frame %p\n",
				    type, frame->tf_sxip & XIP_ADDR, frame);
		}
d157 4
a160 4
		if (CPU_IS88110) {
			printf("\nTrap type %d, v = %x, frame %p\n",
			    type, frame->tf_exip, frame);
		}
d163 1
a163 1
		regdump(frame);
d165 9
a173 1
	}
d270 2
a291 5
	case T_ILLFLT:
		printf("Unimplemented opcode!\n");
		panictrap(frame->tf_vector, frame);
		break;

d293 1
a293 1
		printf("kernel misaligned access exception @@ 0x%08x\n",
d295 1
a295 3
		panictrap(frame->tf_vector, frame);
		break;

d306 1
a306 3
		panictrap(frame->tf_vector, frame);
		break;

a325 3
		if (va == 0) {
			panic("trap: bad kernel access at %x", fault_addr);
		}
d356 16
d392 1
a392 1
		panictrap(frame->tf_vector, frame);
d683 1
a683 1
			instr = *(u_int *)frame->tf_exip;
d806 1
a806 1
		printf("kernel mode misaligned access exception @@ 0x%08x\n",
a808 1

a842 3
		if (va == 0) {
			panic("trap: bad kernel access at %x", fault_addr);
		}
d857 11
a923 1
				p->p_addr->u_pcb.pcb_onfault = pcb_onfault;
d933 1
a933 1
				panictrap(frame->tf_vector, frame);
a943 1
				p->p_addr->u_pcb.pcb_onfault = pcb_onfault;
a973 1
					p->p_addr->u_pcb.pcb_onfault = pcb_onfault;
d984 1
a984 1
				panictrap(frame->tf_vector, frame);
d987 1
@


1.70
log
@mvme88k kernels running on 88110 systems have been prone to panicing for
``invalid opcode'' in kernel mode after being idle for a few hours, since
many months already. This panic does not make sense.

Recently, I've been able to gather enough samples and, looking at the
instructions surrounding the panic location, I have narrowed a pattern,
and I'll conveniently blame these panics upon a (to the best of my
knowledge) new genuine 88110 bug.

The exception handler will now recognize this situation and apply a large
hammer of workaround - probably not the best workaround that could be devised,
but it's short, easy to implement, and works 100% of the time so far. Besides,
since the machine is idle, who cares as long as it keeps running?

(the curious reader will find more information in the trap.c comments)
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.69 2009/03/01 17:43:25 miod Exp $	*/
d785 2
a786 2
		if (fault_addr >= (vaddr_t)kernel_text &&
		    fault_addr <(vaddr_t)&etext) {
@


1.69
log
@Files forgotten during last commit:

Rework nmi handling to handle ``complex'' NMI faster, and return as fast as
possible from the exception, without doing the AST and softintr dance.

This should avoid too much stack usage under load.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.68 2009/02/16 22:55:03 miod Exp $	*/
d745 49
a793 1
		printf("Unimplemented opcode!\n");
@


1.68
log
@Since NMI are now handled separately, remove the ``interrupt type'' argument
from interrupt() and related function pointers.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.67 2009/02/13 23:33:51 miod Exp $	*/
d194 9
d204 1
a204 1
nmi(struct trapframe *frame)
d206 1
a206 1
	md_nmi_func(frame);
@


1.67
log
@Use a different dispatcher for the NMI traps on 88110, these are too
different from regular hardware interrupts to be worth handling the
same way.

Disable IPI reception while we are handling pending IPIs. And do not
reenable them by mistake if we need to send an IPI in return.

This lets GENERIC.MP boot single user on a MVME197DP. There are still
many bugs to fix.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.66 2009/02/08 21:40:13 miod Exp $	*/
d181 1
a181 1
interrupt(u_int type, struct trapframe *frame)
d186 1
a186 1
	md_interrupt_func(type, frame);
@


1.66
log
@Don't bother trying to recover from DSR_WE data faults in kernel mode,
pmap makes sure these can't happen.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.65 2009/02/01 00:52:19 miod Exp $	*/
d189 11
@


1.65
log
@Remove dma_cachectl() and rename dma_cachectl_pa() to dma_cachectl() now that
the old vs(4) code is gone.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.64 2008/11/27 20:46:48 miod Exp $	*/
a785 36
			}
		} else
		if (frame->tf_dsr & CMMU_DSR_WE) {	/* write fault  */
			/*
			 * This could be a write protection fault or an
			 * exception to set the used and modified bits
			 * in the pte. Basically, if we got a write error,
			 * then we already have a pte entry that faulted
			 * in from a previous seg fault or page fault.
			 * Get the pte and check the status of the
			 * modified and valid bits to determine if this
			 * indeed a real write fault.  XXX smurph
			 */
			if (pmap_set_modify(map->pmap, va)) {
#ifdef TRAPDEBUG
				printf("Corrected kernel write fault, pmap %p va %p\n",
				    map->pmap, va);
#endif
				KERNEL_UNLOCK();
				return;
#if 0	/* shouldn't happen */
			} else {
				/* must be a real wp fault */
#ifdef TRAPDEBUG
				printf("Uncorrected kernel write fault, pmap %p va %p\n",
				    map->pmap, va);
#endif
				if ((pcb_onfault = p->p_addr->u_pcb.pcb_onfault) != 0)
					p->p_addr->u_pcb.pcb_onfault = 0;
				result = uvm_fault(map, va, VM_FAULT_INVALID, ftype);
				p->p_addr->u_pcb.pcb_onfault = pcb_onfault;
				if (result == 0) {
					KERNEL_UNLOCK();
					return;
				}
#endif
@


1.64
log
@On 88100 cpus, make sure userland processes start with SNIP and SFIP valid
(i.e. with the valid bit set in them). Found the hard way by Anders Gavare
trying his latest gxemul, proves the hardware is more permitting than one
would expect it to be...
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.63 2008/05/02 21:44:46 miod Exp $	*/
d1817 1
a1817 1
			dma_cachectl_pa(pa, count, DMA_CACHE_SYNC);
@


1.63
log
@Grab the biglock unconditionnaly when system calls go through systrace;
spotted by drahn
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.62 2008/04/01 21:10:18 miod Exp $	*/
d1457 1
a1457 1
		tf->tf_snip = tf->tf_sfip & XIP_ADDR;
@


1.62
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.61 2007/12/25 00:29:49 miod Exp $	*/
d1170 1
a1175 3
	nolock = (callp->sy_flags & SY_NOLOCK);
	if (!nolock)
		KERNEL_PROC_LOCK(p);
d1178 1
a1178 2
		if (nolock)
			KERNEL_PROC_LOCK(p);
d1180 1
a1180 2
		if (nolock)
			KERNEL_PROC_UNLOCK(p);
d1186 2
a1187 1
	if (ISSET(p->p_flag, P_SYSTRACE))
d1189 2
a1190 1
	else
d1192 4
d1197 4
a1229 2
	if (!nolock)
		KERNEL_PROC_UNLOCK(p);
d1334 1
a1339 3
	nolock = (callp->sy_flags & SY_NOLOCK);
	if (!nolock)
		KERNEL_PROC_LOCK(p);
d1342 1
a1342 2
		if (nolock)
			KERNEL_PROC_LOCK(p);
d1344 1
a1344 2
		if (nolock)
			KERNEL_PROC_UNLOCK(p);
d1350 2
a1351 1
	if (ISSET(p->p_flag, P_SYSTRACE))
d1353 2
a1354 1
	else
d1356 4
d1361 4
a1389 2
	if (!nolock)
		KERNEL_PROC_UNLOCK(p);
@


1.61
log
@Restart the m88110 floating-point trap code from scratch, basing it on the
sparc{,64} floating-point emulator, adapted to the 88110 specifics. Handling
of these traps is now entirely done in C for convenience.

Although there are a few rounding issues to address, and the XRF is ignored,
this allows all the ieee754 regression tests to pass (lib/libc/ieeefp,
sys/kern/signal/fpsig, sys/kern/signal/sigfpe).
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.60 2007/12/12 20:35:37 miod Exp $	*/
d1701 1
a1701 1
 * isntruction exception from userland.
@


1.60
log
@Make non-88110 kernels (aviion, luna88k) kernels compile again.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.59 2007/12/08 18:39:50 miod Exp $	*/
d679 1
d684 1
a686 1
#ifdef DEBUG
d688 1
a688 4
#endif
		panictrap(frame->tf_vector, frame);
		break;
		/*NOTREACHED*/
a690 1
#ifdef DEBUG
d692 1
a692 4
#endif
		panictrap(frame->tf_vector, frame);
		break;
		/*NOTREACHED*/
a694 1
#ifdef DEBUG
d696 1
a697 3
		panictrap(frame->tf_vector, frame);
		break;
		/*NOTREACHED*/
d726 1
a726 2
		panictrap(frame->tf_vector, frame);
		break;
d730 1
a730 3
		panictrap(frame->tf_vector, frame);
		break;
		/*NOTREACHED*/
d740 1
a740 3
		panictrap(frame->tf_vector, frame);
		break;
		/*NOTREACHED*/
d825 1
a825 2
		panictrap(frame->tf_vector, frame);
		/* NOTREACHED */
d978 1
d1013 2
a1014 27
		sig = SIGFPE;

		if (frame->tf_fpecr & FPECR_FUNIMP) {
			if (frame->tf_epsr & PSR_SFD1)
				fault_type = FPE_FLTINV;
		} else if (frame->tf_fpecr & FPECR_FIOV)
			fault_type = FPE_FLTSUB;
		else if (frame->tf_fpecr & FPECR_FROP)
			fault_type = FPE_FLTINV;
		else if (frame->tf_fpecr & FPECR_FDVZ)
			fault_type = FPE_INTDIV;
		else if (frame->tf_fpecr & FPECR_FUNF) {
			if (frame->tf_fpsr & FPSR_EFUNF)
				fault_type = FPE_FLTUND;
			else if (frame->tf_fpsr & FPSR_EFINX)
				fault_type = FPE_FLTRES;
		} else if (frame->tf_fpecr & FPECR_FOVF) {
			if (frame->tf_fpsr & FPSR_EFOVF)
				fault_type = FPE_FLTOVF;
			else if (frame->tf_fpsr & FPSR_EFINX)
				fault_type = FPE_FLTRES;
		} else if (frame->tf_fpecr & FPECR_FINX)
			fault_type = FPE_FLTRES;

		/* skip trap instruction */
		m88110_skip_insn(frame);
		break;
d1090 1
@


1.59
log
@Better siginfo fault codes for floating point exceptions on 88110, with
more work in progress to handle these exceptions correctly, and document
a new undocumented and evil chip bug while there.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.58 2007/12/04 05:42:48 miod Exp $	*/
d1852 1
d1856 4
a1859 1
	} else {
d1863 1
@


1.58
log
@In double_reg_fixup(), do not rely on tf_r[0] being zero.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.57 2007/12/04 05:37:40 miod Exp $	*/
d62 1
a62 1
#include <machine/asm_macro.h>   /* enable/disable interrupts */
d66 2
a67 2
#include <machine/m88100.h>		/* DMT_xxx */
#include <machine/m8820x.h>		/* CMMU_PFSR_xxx */
d72 3
a74 2
#include <machine/pcb.h>		/* FIP_E, etc. */
#include <machine/psl.h>		/* FIP_E, etc. */
d240 1
a240 1
	fault_type = 0;
d577 1
a577 1
		sv.sival_int = fault_addr;
d617 1
a617 1
	fault_type = 0;
a731 10
#if 0
	case T_ILLFLT:
		s = splhigh();
		set_psr((psr = get_psr()) & ~PSR_IND);
		ddb_error_trap(type == T_ILLFLT ? "unimplemented opcode" :
		       "error fault", (db_regs_t*)frame);
		set_psr(psr);
		splx(s);
		return;
#endif /* 0 */
d996 2
d1028 23
d1123 1
a1123 1
		sv.sival_int = fault_addr;
@


1.57
log
@Faster splassert_check()
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.56 2007/12/04 05:36:34 miod Exp $	*/
d1752 2
a1753 2
		switch (instr & 0xfc000000) {
		case 0x10000000:	/* ld.d rD, rS, imm16 */
d1758 1
a1758 1
		case 0x20000000:	/* st.d rD, rS, imm16 */
d1779 4
a1782 1
		value = frame->tf_r[regno++];
d1785 1
a1785 1
		if (regno == 32)
d1788 1
a1788 1
			value = frame->tf_r[regno];
@


1.56
log
@Fix userland vs system test in errata #16 handling.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.55 2007/12/02 21:34:34 miod Exp $	*/
d1700 1
a1700 5
	/*
	 * This will raise the spl if too low,
	 * in a feeble attempt to reduce further damage.
	 */
	oldipl = raiseipl(wantipl);
d1704 5
@


1.55
log
@Do not take biglock for NOLOCK system calls.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.54 2007/12/02 21:33:56 miod Exp $	*/
d651 1
a651 1
		if (USERMODE(frame->tf_epsr)) {
@


1.54
log
@Only check for errata #16 for instruction faults.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.53 2007/11/25 16:40:04 jmc Exp $	*/
d1137 1
a1137 1
	struct proc *p;
d1140 1
a1143 2
	p = curproc;

d1192 1
a1193 1
#ifdef SYSCALL_DEBUG
d1195 1
d1197 3
d1201 3
a1203 1
	if (KTRPOINT(p, KTR_SYSCALL))
d1205 3
d1246 2
a1247 1
	KERNEL_PROC_UNLOCK(p);
d1297 1
a1297 1
	struct proc *p;
d1300 1
a1303 2
	p = curproc;

d1352 1
a1353 1
#ifdef SYSCALL_DEBUG
d1355 1
d1357 3
d1361 3
a1363 1
	if (KTRPOINT(p, KTR_SYSCALL))
d1365 3
d1402 2
a1403 1
	KERNEL_PROC_UNLOCK(p);
d1808 1
a1808 1
	struct proc *p;
a1812 3

	if ((p = curproc) == NULL)
		p = &proc0;
@


1.53
log
@spelling fixes, from Martynas Venckus;
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.52 2007/11/22 23:31:51 miod Exp $	*/
a636 4
	 *
	 * (the font in the errata document I have does not make it clear
	 *  whether the jsr.n problem applies to all registers or only
	 *  r1 -- miod)
d638 1
a638 2
	if ((frame->tf_exip & 0x00000fff) == 0x00000001 &&
	    (type == T_DATAFLT || type == T_INSTFLT)) {
d653 1
a653 1
			if ((instr & 0xffffffe0) == 0xf400cc00)
d660 1
a660 1
			    (instr & 0xffffffe0) == 0xf400cc00) {
@


1.52
log
@Introduce an inline function to skip an instruction on 88110 and use it
whenever necessary, instead of duplicating the same code 10+ times.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.51 2007/11/22 23:30:48 miod Exp $	*/
d1581 1
a1581 1
		 * return. Successfull system calls return at (pc + 8),
@


1.51
log
@A decent workaround for errata #16. I have verified it gets triggered, the
hard way.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.50 2007/11/22 06:11:51 miod Exp $	*/
d732 2
a733 5
		/* skip one instruction */
		if (frame->tf_exip & 1)
			frame->tf_exip = frame->tf_enip;
		else
			frame->tf_exip += 4;
d1004 4
d1023 2
d1029 2
d1035 2
d1040 2
d1397 2
a1398 4
		if (tf->tf_exip & 1)
			tf->tf_exip = tf->tf_enip + 4;
		else
			tf->tf_exip += 4 + 4;
d1411 1
a1411 4
		if (tf->tf_exip & 1)
			tf->tf_exip = tf->tf_enip;
		else
			tf->tf_exip += 4;
d1420 1
a1420 4
		if (tf->tf_exip & 1)
			tf->tf_exip = tf->tf_enip;
		else
			tf->tf_exip += 4;
d1465 2
a1466 4
		if (tf->tf_exip & 1)
			tf->tf_exip = tf->tf_enip + 4;
		else
			tf->tf_exip += 4 + 4;
a1788 10
#ifdef M88110
	if (CPU_IS88110) {
		/* skip the offending instruction */
		if (frame->tf_exip & 1)
			frame->tf_exip = frame->tf_enip;
		else
			frame->tf_exip += 4;
	}
#endif

d1827 1
a1827 4
		if (tf->tf_exip & 1)
			tf->tf_exip = tf->tf_enip;
		else
			tf->tf_exip += 4;
@


1.50
log
@On 88110, skip the faulting instruction in double_reg_fixup() if it can
recover, otherwise we'll fault in a loop.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.49 2007/11/22 05:53:56 miod Exp $	*/
a615 4
	if (USERMODE(frame->tf_epsr)) {
		type += T_USER;
		p->p_md.md_tf = frame;	/* for ptrace/signals */
	}
a619 1
#if 0
d642 34
a675 3
	if ((frame->tf_exip & 0x00000fff) == 0x00000001) {
		panic("mc88110 errata #16, exip %p enip %p",
		    frame->tf_exip, frame->tf_enip);
d677 3
a679 1
#endif
d1102 1
@


1.49
log
@Quote a few errata to explain why odd things are done in oddly ways on 88110.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.48 2007/11/21 19:40:34 miod Exp $	*/
d1760 10
@


1.48
log
@Move pmap_set_modify() prototype to a header file
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.47 2007/11/21 19:30:09 miod Exp $	*/
d623 29
@


1.47
log
@Move external interrupt and ast handling from m881[01]0_trap() to their
own functions, which do not need to be processor-specific.

This speeds up the exception return sequence a bit.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.46 2007/11/20 22:08:40 miod Exp $	*/
a610 2

	extern int pmap_set_modify(pmap_t, vaddr_t);
@


1.46
log
@A line got lost while hand-editing diffs...
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.45 2007/11/20 21:53:25 miod Exp $	*/
d176 35
a268 6
	case T_INT:
	case T_INT+T_USER:
		curcpu()->ci_intrdepth++;
		md_interrupt_func(T_INT, frame);
		curcpu()->ci_intrdepth--;
		return;
a566 11
	case T_ASTFLT+T_USER:
		uvmexp.softs++;
		p->p_md.md_astpending = 0;
		if (p->p_flag & P_OWEUPC) {
			KERNEL_PROC_LOCK(p);
			ADDUPROF(p);
			KERNEL_PROC_UNLOCK(p);
		}
		if (curcpu()->ci_want_resched)
			preempt(NULL);
		break;
a698 12
	case T_NON_MASK:
	case T_NON_MASK+T_USER:
		curcpu()->ci_intrdepth++;
		md_interrupt_func(T_NON_MASK, frame);
		curcpu()->ci_intrdepth--;
		return;
	case T_INT:
	case T_INT+T_USER:
		curcpu()->ci_intrdepth++;
		md_interrupt_func(T_INT, frame);
		curcpu()->ci_intrdepth--;
		return;
a1036 12
		break;

	case T_ASTFLT+T_USER:
		uvmexp.softs++;
		p->p_md.md_astpending = 0;
		if (p->p_flag & P_OWEUPC) {
			KERNEL_PROC_LOCK(p);
			ADDUPROF(p);
			KERNEL_PROC_UNLOCK(p);
		}
		if (curcpu()->ci_want_resched)
			preempt(NULL);
@


1.45
log
@Move 88110 trap-on-write processing from two duplicated sections in trap.c to
a single function in pmap.c, which will do the right thing and also perform
mod/ref vm_page flags accounting.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.44 2007/11/20 21:48:58 miod Exp $	*/
d890 1
@


1.44
log
@Fix MP locking issues when processing data access faults on 88110, similar
to the fix already applied to 88100.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.43 2007/11/17 05:36:23 miod Exp $	*/
a195 2
	extern struct vm_map *kernel_map;

a592 1
	pt_entry_t *pte;
d594 1
a594 2
	extern struct vm_map *kernel_map;
	extern pt_entry_t *pmap_pte(pmap_t, vaddr_t);
a744 1
			frame->tf_dsr &= ~CMMU_DSR_WE;	/* undefined */
d757 1
a757 1
		}
d769 1
a769 9
			pte = pmap_pte(map->pmap, va);
#ifdef DEBUG
			if (pte == NULL) {
				KERNEL_UNLOCK();
				panic("NULL pte on write fault??");
			}
#endif
			if (!(*pte & PG_M) && !(*pte & PG_RO)) {
				/* Set modified bit and try the write again. */
d771 2
a772 2
				printf("Corrected kernel write fault, map %x pte %x\n",
				    map->pmap, *pte);
a773 1
				*pte |= PG_M;
d776 1
a776 1
#if 1	/* shouldn't happen */
d780 2
a781 2
				printf("Uncorrected kernel write fault, map %x pte %x\n",
				    map->pmap, *pte);
d885 4
a888 5
				pte = pmap_pte(vm_map_pmap(map), va);
#ifdef DEBUG
				if (pte == NULL) {
					panic("NULL pte on write fault??");
				}
a889 16
				if (!(*pte & PG_M) && !(*pte & PG_RO)) {
					/*
					 * Set modified bit and try the
					 * write again.
					 */
#ifdef TRAPDEBUG
					printf("Corrected userland write fault, map %x pte %x\n",
					    map->pmap, *pte);
#endif
					*pte |= PG_M;
					/*
					 * invalidate ATCs to force
					 * table search
					 */
					set_dcmd(CMMU_DCMD_INV_UATC);
					result = 0;
d893 2
a894 2
					printf("Uncorrected userland write fault, map %x pte %x\n",
					    map->pmap, *pte);
@


1.43
log
@Replace many ``unsigned'' variables with ``unsigned int'', ``u_int'' or other
appropriate types. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.42 2007/11/14 22:56:56 miod Exp $	*/
d721 1
a721 1
			type = T_DATAFLT + T_USER;
d815 1
a840 1
		KERNEL_PROC_LOCK(p);
d850 23
a872 1
		if (type == T_DATAFLT+T_USER) {
a901 1
					KERNEL_PROC_UNLOCK(p);
d920 1
a920 2
					KERNEL_PROC_UNLOCK(p);
					return;
d935 4
a938 20
				KERNEL_PROC_UNLOCK(p);
				panictrap(frame->tf_vector, frame);
			}
		} else {
			/* instruction faults */
			if (frame->tf_isr &
			    (CMMU_ISR_BE | CMMU_ISR_SP | CMMU_ISR_TBE)) {
				/* bus error, supervisor protection */
				result = EACCES;
			} else
			if (frame->tf_isr & (CMMU_ISR_SI | CMMU_ISR_PI)) {
				/* segment or page fault */
				result = uvm_fault(map, va, VM_FAULT_INVALID, ftype);
				p->p_addr->u_pcb.pcb_onfault = pcb_onfault;
			} else {
#ifdef TRAPDEBUG
				printf("Unexpected Instruction fault isr %x\n",
				    frame->tf_isr);
#endif
				KERNEL_PROC_UNLOCK(p);
d949 4
a952 1
		KERNEL_PROC_UNLOCK(p);
@


1.42
log
@When processing a data access fault, keep the kernel lock while invoking
data_access_emulation() to complete the interrupted pipeline operations,
as data_access_emulation() can fault in turn.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.41 2007/10/28 10:18:53 miod Exp $	*/
d178 1
a178 1
m88100_trap(unsigned type, struct trapframe *frame)
d186 1
a186 1
	unsigned fault_addr;
d303 1
a303 1
			data_access_emulation((unsigned *)frame);
d321 1
a321 1
				data_access_emulation((unsigned *)frame);
d428 1
a428 1
				data_access_emulation((unsigned *)frame);
d578 1
a578 1
m88110_trap(unsigned type, struct trapframe *frame)
d586 1
a586 1
	unsigned fault_addr;
d1605 2
a1606 2
	unsigned pc, brpc;
	unsigned instr;
@


1.41
log
@When handling a userland data fault occuring in kernel mode, take the kernel
lock with KERNEL_LOCK, not KERNEL_PROC_LOCK. This lets bsd.mp run multiuser
on a single-processor board.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.40 2007/05/11 10:06:55 pedro Exp $	*/
a394 4
		if (type == T_DATAFLT)
			KERNEL_UNLOCK();
		else
			KERNEL_PROC_UNLOCK(p);
d437 4
@


1.40
log
@Don't use LK_CANRECURSE for the kernel lock, okay miod@@ art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.39 2007/03/15 10:22:29 art Exp $	*/
d267 1
a267 1
			type = T_DATAFLT + T_USER;
d340 1
a368 1
		KERNEL_PROC_LOCK(p);
d395 4
a398 1
		KERNEL_PROC_UNLOCK(p);
d417 9
a425 1
			if (type == T_DATAFLT+T_USER) {
a434 8
			} else {
				/*
				 * back up SXIP, SNIP,
				 * clearing the Error bit
				 */
				frame->tf_sfip = frame->tf_snip & ~FIP_E;
				frame->tf_snip = frame->tf_sxip & ~NIP_E;
				frame->tf_ipfsr = 0;
@


1.39
log
@Since p_flag is often manipulated in interrupts and without biglock
it's a good idea to use atomic.h operations on it. This mechanic
change updates all bit operations on p_flag to atomic_{set,clear}bits_int.

Only exception is that P_OWEUPC is set by MI code before calling
need_proftick and it's automatically cleared by ADDUPC. There's
no reason for MD handling of that flag since everyone handles it the
same way.

kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.38 2007/02/11 12:49:37 miod Exp $	*/
d285 1
a285 1
		KERNEL_LOCK(LK_CANRECURSE | LK_EXCLUSIVE);
d741 1
a741 1
		KERNEL_LOCK(LK_CANRECURSE | LK_EXCLUSIVE);
@


1.38
log
@Rework the cache handling routines again. We now try to operate on the exact
address range we've been given, rounded to cache line boundaries, instead
of being lazy and operating on pages as soon as the range was large enough.

Also, since the ranges we'll be invoked for are reasonably small, it does
not make sense to check for segment sizes - we're always smaller, really.

While there, hardcode the size in cmmu_flush_data_cache(), which becomes
cmmu_flush_data_page(), since it was always invoked for complete pages.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.37 2006/12/24 20:30:35 miod Exp $	*/
a540 1
			p->p_flag &= ~P_OWEUPC;
a1056 1
			p->p_flag &= ~P_OWEUPC;
@


1.37
log
@Define PROC_PC. Then, since profiling information is being reported in
statclock(), do not bother doing this in userret() anymore. As a result,
userret() does not need its pc and ticks arguments, simplify.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.36 2006/12/24 20:29:19 miod Exp $	*/
d1770 3
d1780 2
a1781 1
	dma_cachectl(pmap, tf->tf_r[2], tf->tf_r[3], DMA_CACHE_SYNC);
d1783 22
a1804 2
	tf->tf_snip = tf->tf_snip & ~NIP_E;
	tf->tf_sfip = tf->tf_sfip & ~FIP_E;
@


1.36
log
@Check for want_resched when processing AST and nowhere else. But then, when
doing so, do not check for signals - userret() will do this.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.35 2006/11/20 21:48:31 miod Exp $	*/
d121 1
a121 1
userret(struct proc *p, struct trapframe *frame, u_quad_t oticks)
a123 1
	struct cpu_info *cpu = curcpu();
a127 1
	p->p_priority = p->p_usrpri;
d129 1
a129 19
	if (cpu->ci_want_resched) {
		/*
		 * We're being preempted.
		 */
		preempt(NULL);
		while ((sig = CURSIG(p)) != 0)
			postsig(sig);
	}

	/*
	 * If profiling, charge recent system time to the trapped pc.
	 */
	if (p->p_flag & P_PROFIL) {
		extern int psratio;

		addupc_task(p, frame->tf_sxip & XIP_ADDR,
		    (int)(p->p_sticks - oticks) * psratio);
	}
	cpu->ci_schedstate.spc_curpriority = p->p_priority;
a180 1
	u_quad_t sticks = 0;
a202 1
		sticks = p->p_sticks;
d570 1
a570 1
	userret(p, frame, sticks);
a578 1
	u_quad_t sticks = 0;
a602 1
		sticks = p->p_sticks;
d1081 1
a1081 1
	userret(p, frame, sticks);
a1107 1
	u_quad_t sticks;
a1115 1
	sticks = p->p_sticks;
d1238 1
a1238 1
	userret(p, tf, sticks);
a1258 1
	u_quad_t sticks;
a1266 1
	sticks = p->p_sticks;
d1400 1
a1400 1
	userret(p, tf, sticks);
d1444 1
a1444 1
	userret(p, tf, p->p_sticks);
a1769 1
	u_quad_t sticks;
a1773 1
	sticks = p->p_sticks;
d1782 1
a1782 1
	userret(p, tf, sticks);
@


1.35
log
@In syscall handlers, fix copyin() failure path wrt locking macros.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.34 2006/11/10 19:19:50 miod Exp $	*/
d568 2
d1087 2
@


1.34
log
@Fetch syscall arguments beyond r9 with copyin() from the userland stack,
instead of having the userland syscall code put the first three locations
from the stack in r10-r12.

This will speed-up most of the system calls (but mmap) once these fetches
are removed, in a few weeks from now.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.33 2006/05/08 14:36:09 miod Exp $	*/
a1180 1
	KERNEL_PROC_LOCK(p);
d1183 1
a1333 1
	KERNEL_PROC_LOCK(p);
d1336 1
@


1.33
log
@Replace gazillions of badvaddr() or badwordaddr() calls with badaddr() calls.
With a few prototype declarations shuffling, this finally allows
<machine/locore.h> to die.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.32 2006/05/08 14:03:35 miod Exp $	*/
d1127 1
a1127 1
	register_t args[11], rval[2], *ap;
d1141 2
a1142 1
	 * For 88k, all the arguments are passed in the registers (r2-r12)
d1148 1
a1148 1
	nap = 11; /* r2-r12 */
a1163 1
	/* Callp currently points to syscall, which returns ENOSYS. */
d1166 1
a1166 1
	else {
d1168 9
a1176 7
		i = callp->sy_argsize / sizeof(register_t);
		if (i > nap)
			panic("syscall nargs");
		/*
		 * just copy them; syscall stub made sure all the
		 * args are moved from user stack to registers.
		 */
d1178 1
d1182 2
a1200 3
	 *	 ld r10, r31, 32; r10,r11,r12 might be garbage.
	 *	 ld r11, r31, 36
	 *	 ld r12, r31, 40
d1246 1
d1280 1
a1280 1
	register_t args[11], rval[2], *ap;
d1294 2
a1295 1
	 * For 88k, all the arguments are passed in the registers (r2-r12)
d1301 1
a1301 1
	nap = 11;	/* r2-r12 */
a1316 1
	/* Callp currently points to syscall, which returns ENOSYS. */
d1319 1
a1319 1
	else {
d1321 9
a1329 7
		i = callp->sy_argsize / sizeof(register_t);
		if (i > nap)
			panic("syscall nargs");
		/*
		 * just copy them; syscall stub made sure all the
		 * args are moved from user stack to registers.
		 */
d1331 1
d1333 1
d1335 2
a1353 3
	 *	 ld r10, r31, 32; r10,r11,r12 might be garbage.
	 *	 ld r11, r31, 36
	 *	 ld r12, r31, 40
d1406 1
@


1.32
log
@Clean the internal m88k trap type codes; while there, simplify and
factorize the build of the VBR page betweem luna88k and mvme88k.

Tested by aoyama@@ and I.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.31 2006/05/04 19:38:45 miod Exp $	*/
a64 1
#include <machine/locore.h>
@


1.31
log
@scaled version of ld.d and st.d is obviously not a 64 bit transaction,
so there is no need to take care of it in double_reg_fixup(), as it will
never trigger the kind of misalignment faults this function recovers from.
Doh!
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.30 2006/05/02 21:44:39 miod Exp $	*/
a490 1
	case T_FPEIFLT+T_USER:
a495 4
	case T_SIGTRAP+T_USER:
		sig = SIGTRAP;
		fault_type = TRAP_TRACE;
		break;
d639 3
a641 2
	case T_197_READ+T_USER:
	case T_197_READ:
d643 1
d647 3
a649 2
	case T_197_WRITE+T_USER:
	case T_197_WRITE:
d651 1
d655 3
a657 2
	case T_197_INST+T_USER:
	case T_197_INST:
d659 1
d663 1
a1014 1
	case T_FPEIFLT+T_USER:
a1018 4
		break;
	case T_SIGTRAP+T_USER:
		sig = SIGTRAP;
		fault_type = TRAP_TRACE;
@


1.30
log
@Replace db_{disable,enable}_interrupts with expanded version of themselves,
having macros for this is not worth doing.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.29 2005/12/11 21:45:30 miod Exp $	*/
d105 1
d1700 4
a1725 5
	case 0xf4001200:	/* ld.d rD, rS1[rS2] */
		addr = frame->tf_r[(instr >> 16) & 0x1f]
		    + (frame->tf_r[(instr & 0x1f)] << 3);
		store = 0;
		break;
a1728 5
		store = 1;
		break;
	case 0xf4002200:	/* st.d rD, rS1[rS2] */
		addr = frame->tf_r[(instr >> 16) & 0x1f]
		    + (frame->tf_r[(instr & 0x1f)] << 3);
@


1.29
log
@Work in progress SMP code; mvme88k boards can spin up secondary CPUs,
kernel boots single user. Still a lot of polishing and bugfixing to do.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.28 2005/12/11 21:30:30 miod Exp $	*/
d241 1
a241 1
		db_enable_interrupt(psr);
d243 1
a243 1
		db_disable_interrupt(psr);
d248 1
a248 1
		db_enable_interrupt(psr);
d250 1
a250 1
		db_disable_interrupt(psr);
d664 1
a664 1
		db_enable_interrupt(psr);
d666 1
a666 1
		db_disable_interrupt(psr);
d671 1
a671 1
		db_enable_interrupt(psr);
d673 1
a673 1
		db_disable_interrupt(psr);
d678 1
a678 1
		db_enable_interrupt(psr);
d680 1
a680 1
		db_disable_interrupt(psr);
d691 1
a691 1
		db_enable_interrupt(psr);
d694 1
a694 1
		db_disable_interrupt(psr);
@


1.28
log
@Replace procfs_domem() with a similar interface, process_domem(), which lives
out of procfs and gets a ptrace request PT_{READ,WRITE}_{I,D} as argument;
also procfs_checkioperm() becomes process_checkioperm().

From art@@ some time ago; ok kettenis@@ pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.27 2005/12/07 07:38:58 miod Exp $	*/
d1112 1
a1112 1
		printf("\nReset Exception\n");
d1114 1
a1114 1
		printf("\nError Exception\n");
@


1.27
log
@Sprinkle holds and releases of the kernel lock whenever necessary; no functional
change for UP kernels.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.26 2005/12/04 12:14:10 miod Exp $	*/
a83 3
/* sigh */
extern int procfs_domem(struct proc *, struct proc *, void *, struct uio *);

d1506 1
a1506 1
	return (procfs_domem(curproc, p, NULL, &uio));
d1524 1
a1524 1
	return (procfs_domem(curproc, p, NULL, &uio));
@


1.26
log
@Simplify ptrace branch handling code.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.25 2005/12/03 14:30:06 miod Exp $	*/
d310 1
d331 1
d349 1
d358 1
d393 1
d420 1
d572 1
d574 1
d587 1
d589 1
d765 1
d779 2
a780 1
			if (result == 0)
d782 1
d797 2
a798 1
			if (pte == NULL)
d800 1
d809 1
d822 2
a823 1
				if (result == 0)
d825 1
d829 1
d861 1
d900 2
a901 1
				if (pte == NULL)
d903 1
d920 1
d936 1
d955 1
d966 1
d1087 1
d1089 1
d1102 1
d1104 1
d1184 1
d1232 1
a1241 4
		/*
		 * If (error == ERESTART), back up the pipe line. This
		 * will end up reexecuting the trap.
		 */
a1246 1
		/* if (error == EJUSTRETURN), leave the ip's alone */
a1249 1
		/* error != ERESTART && error != EJUSTRETURN*/
d1259 1
d1261 1
d1265 2
a1266 1
	if (KTRPOINT(p, KTR_SYSRET))
d1268 2
d1333 1
d1377 1
d1419 1
d1421 1
d1425 2
a1426 1
	if (KTRPOINT(p, KTR_SYSRET))
d1428 2
d1449 1
d1466 1
d1470 2
a1471 1
	if (KTRPOINT(p, KTR_SYSRET))
d1474 2
@


1.25
log
@Switch m88k ports to __HAVE_CPUINFO. Current cpu pointer is held in SR0
on all running processors.
Tested aoyama@@ and I
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.24 2005/12/01 22:24:52 miod Exp $	*/
d110 1
d121 1
a262 3
		/* This function pointer is set in machdep.c
		   It calls m188_ext_int or sbc_ext_int depending
		   on the value of brdtyp - smurph */
a1112 9
#ifdef DIAGNOSTIC
	if (USERMODE(tf->tf_epsr) == 0)
		panic("syscall");
	if (curpcb != &p->p_addr->u_pcb)
		panic("syscall curpcb/ppcb");
	if (tf != (struct trapframe *)&curpcb->user_state)
		panic("syscall trapframe");
#endif

a1261 9
#ifdef DIAGNOSTIC
	if (USERMODE(tf->tf_epsr) == 0)
		panic("syscall");
	if (curpcb != &p->p_addr->u_pcb)
		panic("syscall curpcb/ppcb");
	if (tf != (struct trapframe *)&curpcb->user_state)
		panic("syscall trapframe");
#endif

a1346 7
		/*
		 * If fork succeeded and we are the child, our stack
		 * has moved and the pointer tf is no longer valid,
		 * and p is wrong.  Compute the new trapframe pointer.
		 * (The trap frame invariably resides at the
		 * tippity-top of the u. area.)
		 */
d1444 1
a1444 3
vaddr_t	ss_branch_taken(u_int, vaddr_t, u_int (*func)(u_int, struct reg *),
	    struct reg *);
u_int	ss_getreg_val(u_int, struct reg *);
d1446 1
a1446 2
int	ss_inst_branch(unsigned);
int	ss_inst_delayed(unsigned);
d1488 1
a1488 1
 * ss_branch_taken(instruction, program counter, func, func_data)
d1492 1
a1492 3
 * would jump if the branch is taken. Func can be used to get the current
 * register values when invoked with a register number and func_data as
 * arguments.
d1494 2
a1495 1
 * If the instruction is not a control flow instruction, panic.
d1498 1
a1498 2
ss_branch_taken(u_int inst, vaddr_t pc, u_int (*func)(u_int, struct reg *),
    struct reg *func_data)
d1500 1
a1500 9
	/* check for system call */
	if (inst == SYSCALL_INSTR) {
		/*
		 * The regular (pc + 4) breakpoint will match the error
		 * return. Successfull system calls return at (pc + 8),
		 * so we'll set up a branch breakpoint there.
		 */
		return (pc + 8);
	}
d1502 9
a1510 3
	/* check if br/bsr */
	if ((inst & 0xf0000000) == 0xc0000000) {
		/* signed 26 bit pc relative displacement, shift left two bits */
a1515 1
	}
d1517 4
a1520 6
	/* check if bb0/bb1/bcnd case */
	switch (inst & 0xf8000000) {
	case 0xd0000000: /* bb0 */
	case 0xd8000000: /* bb1 */
	case 0xe8000000: /* bcnd */
		/* signed 16 bit pc relative displacement, shift left two bits */
a1525 1
	}
d1527 3
a1529 4
	/* check jmp/jsr case */
	/* check bits 5-31, skipping 10 & 11 */
	if ((inst & 0xfffff3e0) == 0xf400c000)
		return (*func)(inst & 0x1f, func_data);	 /* the register value */
d1531 8
a1538 13
	/* can't happen */
	return (0);
}

/*
 * ss_getreg_val - handed a register number and an exception frame.
 *              Returns the value of the register in the specified
 *              frame. Only makes sense for general registers.
 */
u_int
ss_getreg_val(u_int regno, struct reg *regs)
{
	return (regno == 0 ? 0 : regs->r[regno]);
d1542 1
a1542 1
ss_inst_branch(u_int ins)
a1544 1

d1547 1
d1552 2
a1553 3
		break;
	case 0x1e: /* could be jmp */
		if ((ins & 0xfffffbe0) == 0xf400c000)
a1559 21
/* ss_inst_delayed - this instruction is followed by a delay slot. Could be
   br.n, bsr.n bb0.n, bb1.n, bcnd.n or jmp.n or jsr.n */

int
ss_inst_delayed(u_int ins)
{
	/* check the br, bsr, bb0, bb1, bcnd cases */
	switch ((ins & 0xfc000000) >> (32 - 6)) {
	case 0x31: /* br */
	case 0x33: /* bsr */
	case 0x35: /* bb0 */
	case 0x37: /* bb1 */
	case 0x3b: /* bcnd */
		return (TRUE);
	}

	/* check the jmp, jsr cases */
	/* mask out bits 0-4, bit 11 */
	return (((ins & 0xfffff7e0) == 0xf400c400) ? TRUE : FALSE);
}

d1614 2
a1615 3
	if (ss_inst_branch(instr) || inst_call(instr) || inst_return(instr) ||
	    instr == SYSCALL_INSTR) {
		brpc = ss_branch_taken(instr, pc, ss_getreg_val, sstf);
@


1.24
log
@Get rid of PMAP_NULL and xx_ENTRY_NULL and simply use NULL when necessary.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.23 2005/11/28 22:22:55 miod Exp $	*/
d125 1
d132 1
a132 1
	if (want_resched) {
d150 1
a150 1
	curpriority = p->p_priority;
d264 1
a264 1
		intrdepth++;
d266 1
a266 1
		intrdepth--;
d281 1
a281 1
		printf("Kernel Instruction fault #%d (%s) v = 0x%x, frame 0x%x cpu %d\n",
d316 1
a316 1
		printf("Kernel Data access fault #%d (%s) v = 0x%x, frame 0x%x cpu %d\n",
d366 1
a366 1
			printf("User Instruction fault #%d (%s) v = 0x%x, frame 0x%x cpu %d\n",
d374 1
a374 1
			printf("User Data access fault #%d (%s) v = 0x%x, frame 0x%x cpu %d\n",
d699 1
a699 1
		intrdepth++;
d701 1
a701 1
		intrdepth--;
d705 1
a705 1
		intrdepth++;
d707 1
a707 1
		intrdepth--;
a1105 3
#ifdef DIAGNOSTIC
	extern struct pcb *curpcb;
#endif
a1263 3
#ifdef DIAGNOSTIC
	extern struct pcb *curpcb;
#endif
@


1.23
log
@Maintain an interrupt depth counter for CLKF_INTR to be correct.
Tested aoyama@@ martin@@ and I.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.22 2005/11/28 22:21:15 miod Exp $	*/
d784 1
a784 1
			if (pte == PT_ENTRY_NULL)
d880 1
a880 1
				if (pte == PT_ENTRY_NULL)
@


1.22
log
@Switch to per-process AST flags and clean AST-related codepaths; speeds up
forks as a bonus.
Tested on luna88k and mvme88k by aoyama@@ martin@@ and I.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.21 2005/09/15 21:14:27 miod Exp $	*/
d263 1
d265 1
d698 1
d700 1
d704 1
d706 1
@


1.21
log
@In syscall(), do not recompute the struct proc * after the syscall has
succeeded. This used to be necessary for fork(), when returning in the child,
but we return in the child in child_return() which does TRT.

ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.20 2005/09/15 21:09:29 miod Exp $	*/
d561 1
a561 1
		want_ast = 0;
d1052 1
a1052 1
		want_ast = 0;
@


1.20
log
@Change child_return() to record a proper ktrace record for vfork child
processes.

ok art@@ uwe@@ (some time ago)
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.19 2005/08/06 09:53:36 miod Exp $	*/
a1208 9
		/*
		 * If fork succeeded and we are the child, our stack
		 * has moved and the pointer tf is no longer valid,
		 * and p is wrong.  Compute the new trapframe pointer.
		 * (The trap frame invariably resides at the
		 * tippity-top of the u. area.)
		 */
		p = curproc;
		tf = (struct trapframe *)USER_REGS(p);
a1371 2
		p = curproc;
		tf = (struct trapframe *)USER_REGS(p);
@


1.19
log
@In cache_flush(), after testing for curproc != NULL, do not use curproc
blindly...
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.18 2005/05/18 16:44:41 miod Exp $	*/
d1464 1
d1467 2
a1468 1
		ktrsysret(p, SYS_fork, 0, 0);
@


1.18
log
@Rework the single step implementation; mostly delaying breakpoint
removal so that single stepping delay slots work. Also added the ability
to single step through system calls (which cause an implicit branch if
successfull).

works for me, "looks ok" kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.17 2005/04/30 16:42:36 miod Exp $	*/
a1833 1
	p = curproc;
@


1.17
log
@Remove m88k_psr_type and function with utterly long names to control the psr,
and use get_psr() / set_psr() or simple macros that expand into them everywhere.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.16 2005/04/27 14:09:45 miod Exp $	*/
d90 1
a90 1
int ss_put_value(struct proc *, unsigned, unsigned, int);
d509 2
a510 3
			unsigned va;
			unsigned instr;
			unsigned pc = PC_REGS(&frame->tf_regs);
d513 2
a514 6
			copyin((caddr_t)pc, &instr, sizeof(unsigned));
#if 0
			printf("trap: %s (%d) breakpoint %x at %x: (adr %x ins %x)\n",
			       p->p_comm, p->p_pid, instr, pc,
			       p->p_md.md_ss_addr, p->p_md.md_ss_instr); /* XXX */
#endif
d516 2
a517 2
			if ((p->p_md.md_ss_addr != pc &&
			     p->p_md.md_ss_taken_addr != pc) ||
d523 9
a531 5
			/* restore original instruction and clear BP  */
			va = p->p_md.md_ss_addr;
			if (va != 0) {
				instr = p->p_md.md_ss_instr;
				ss_put_value(p, va, instr, sizeof(instr));
a533 6
			/* branch taken instruction */
			instr = p->p_md.md_ss_taken_instr;
			if (instr != 0) {
				va = p->p_md.md_ss_taken_addr;
				ss_put_value(p, va, instr, sizeof(instr));
			}
a537 4
			p->p_md.md_ss_addr = 0;
			p->p_md.md_ss_instr = 0;
			p->p_md.md_ss_taken_addr = 0;
			p->p_md.md_ss_taken_instr = 0;
d1007 2
a1008 2
			unsigned instr;
			unsigned pc = PC_REGS(&frame->tf_regs);
d1011 2
a1012 6
			copyin((caddr_t)pc, &instr, sizeof(unsigned));
#if 0
			printf("trap: %s (%d) breakpoint %x at %x: (adr %x ins %x)\n",
			       p->p_comm, p->p_pid, instr, pc,
			       p->p_md.md_ss_addr, p->p_md.md_ss_instr); /* XXX */
#endif
d1014 3
a1016 2
#ifdef notyet
			if (p->p_md.md_ss_addr != pc || instr != SSBREAKPOINT) {
a1020 5
#endif
			/* restore original instruction and clear BP  */
			instr = p->p_md.md_ss_instr;
			if (instr != 0)
				ss_put_value(p, pc, instr, sizeof(instr));
d1022 10
a1031 2
			p->p_md.md_ss_addr = 0;
			p->p_md.md_ss_instr = 0;
d1478 7
a1484 7
unsigned ss_get_value(struct proc *, unsigned, int);
unsigned ss_branch_taken(unsigned, unsigned,
    unsigned (*func)(unsigned int, struct reg *), struct reg *);
unsigned int ss_getreg_val(unsigned int, struct reg *);
int ss_inst_branch(unsigned);
int ss_inst_delayed(unsigned);
unsigned ss_next_instr_address(struct proc *, unsigned, unsigned);
d1486 4
a1489 2
unsigned
ss_get_value(struct proc *p, unsigned addr, int size)
a1492 1
	unsigned value;
d1494 2
a1495 2
	iov.iov_base = (caddr_t)&value;
	iov.iov_len = size;
d1499 1
a1499 1
	uio.uio_resid = size;
d1503 1
a1503 2
	procfs_domem(curproc, p, NULL, &uio);
	return value;
d1507 1
a1507 1
ss_put_value(struct proc *p, unsigned addr, unsigned value, int size)
d1513 1
a1513 1
	iov.iov_len = size;
d1517 1
a1517 1
	uio.uio_resid = size;
d1521 1
a1521 1
	return procfs_domem(curproc, p, NULL, &uio);
d1535 3
a1537 3
unsigned
ss_branch_taken(unsigned inst, unsigned pc,
    unsigned (*func)(unsigned int, struct reg *), struct reg *func_data)
d1539 10
d1586 2
a1587 2
unsigned int
ss_getreg_val(unsigned int regno, struct reg *regs)
d1593 1
a1593 1
ss_inst_branch(unsigned ins)
d1602 1
a1602 1
		return TRUE;
d1606 1
a1606 1
			return TRUE;
d1609 1
a1609 1
	return FALSE;
d1616 1
a1616 1
ss_inst_delayed(unsigned ins)
d1625 1
a1625 1
		return TRUE;
d1630 1
a1630 1
	return ((ins & 0xfffff7e0) == 0xf400c400) ? TRUE : FALSE;
d1633 2
a1634 2
unsigned
ss_next_instr_address(struct proc *p, unsigned pc, unsigned delay_slot)
d1636 6
a1641 7
	if (delay_slot == 0)
		return (pc + 4);
	else {
		if (ss_inst_delayed(ss_get_value(p, pc, sizeof(int))))
			return (pc + 4);
		else
			return pc;
d1643 8
d1654 1
a1654 2
cpu_singlestep(p)
	struct proc *p;
d1658 16
a1673 2
	int bpinstr = SSBREAKPOINT;
	unsigned curinstr;
d1675 4
d1680 3
d1684 2
a1685 3
	 * User was stopped at pc, e.g. the instruction
	 * at pc was not executed.
	 * Fetch what's at the current location.
d1687 3
a1689 1
	curinstr = ss_get_value(p, pc, sizeof(int));
d1691 5
a1695 15
	/* compute next address after current location */
	if (curinstr != 0) {
		if (ss_inst_branch(curinstr) ||
		    inst_call(curinstr) || inst_return(curinstr)) {
			brpc = ss_branch_taken(curinstr, pc, ss_getreg_val, sstf);
			if (brpc != pc) {   /* self-branches are hopeless */
				p->p_md.md_ss_taken_addr = brpc;
				p->p_md.md_ss_taken_instr =
				    ss_get_value(p, brpc, sizeof(int));
				/* Store breakpoint instruction at the
				   "next" location now. */
				if (ss_put_value(p, brpc, bpinstr,
				    sizeof(int)) != 0)
					return (EFAULT);
			}
a1696 7
		pc = ss_next_instr_address(p, pc, 0);
	} else {
		pc = PC_REGS(sstf) + 4;
	}

	if (p->p_md.md_ss_addr != NULL) {
		return (EFAULT);
d1699 3
a1701 8
	p->p_md.md_ss_addr = pc;

	/* Fetch what's at the "next" location. */
	p->p_md.md_ss_instr = ss_get_value(p, pc, sizeof(int));

	/* Store breakpoint instruction at the "next" location now. */
	if (ss_put_value(p, pc, bpinstr, sizeof(int)) != 0)
		return (EFAULT);
d1731 2
a1732 2
 * the splitted form of the instruction. If it fails, it returns the
 * appropriate signal number to deliver.
@


1.16
log
@Allow userland to cause the data cache to be flushed for any arbitrary address
range in the current process, using trap #451.

This is necessary for proper gcc trampolines operation, and, later, ld.so...
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.15 2004/12/06 20:12:24 miod Exp $	*/
d213 1
d241 1
a241 1
		db_enable_interrupt();
d243 1
a243 1
		db_disable_interrupt();
d248 1
a248 1
		db_enable_interrupt();
d250 1
a250 1
		db_disable_interrupt();
d618 1
d666 1
a666 1
		db_enable_interrupt();
d668 1
a668 1
		db_disable_interrupt();
d673 1
a673 1
		db_enable_interrupt();
d675 1
a675 1
		db_disable_interrupt();
d680 1
a680 1
		db_enable_interrupt();
d682 1
a682 1
		db_disable_interrupt();
d693 1
a693 1
		db_enable_interrupt();
d696 1
a696 1
		db_disable_interrupt();
@


1.15
log
@Use uvm_grow() to account for stack growth, rather than home-grown code
or nothing.
Inspired by a similar recent change in NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.14 2004/11/09 21:49:56 miod Exp $	*/
d63 1
d1816 23
@


1.14
log
@Kill guarded_access() - the way we map OBIO, there is no need for special
treatement of interrupt vectors variables, a simple read will do.

While there, speed up the interrupt handlers a bit:
- remove old debug code or only compile it if option DEBUG.
- use short circuits for setipl() if we know interrupts are disabled at
  this point: there is no need playing with the psr in these cases.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.13 2004/11/08 16:39:31 miod Exp $	*/
d206 1
a206 1
	unsigned nss, fault_addr;
a399 2
			if (result == EACCES)
				result = EFAULT;
d406 4
a409 5
			if (result == 0) {
				nss = btoc(USRSTACK - va);/* XXX check this */
				if (nss > vm->vm_ssize)
					vm->vm_ssize = nss;
			}
d610 1
a610 1
	unsigned nss, fault_addr;
a862 2
				if (result == EACCES)
					result = EFAULT;
a908 2
					if (result == EACCES)
						result = EFAULT;
a927 2
				if (result == EACCES)
					result = EFAULT;
d938 4
a941 5
			if (result == 0) {
				nss = btoc(USRSTACK - va);/* XXX check this */
				if (nss > vm->vm_ssize)
					vm->vm_ssize = nss;
			}
@


1.13
log
@Kill struct md_p, which was really only necessary for mvme88k; on
luna88k it disappears completely, while mvme88k keeps 3 global variables,
one of them scheduled to disappear very soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.12 2004/10/01 20:20:34 miod Exp $	*/
a215 5
#ifdef MVME188	/* XXX - only MVME188 needs guarded_access() */
	extern caddr_t guarded_access_start;
	extern caddr_t guarded_access_end;
	extern caddr_t guarded_access_bad;
#endif
a316 29
#ifdef MVME188	/* XXX - only MVME188 needs guarded_access() */
		case CMMU_PFSR_BERROR:
			/*
		 	 * If it is a guarded access, bus error is OK.
		 	 */
			if ((frame->tf_sxip & XIP_ADDR) >=
			      (unsigned)&guarded_access_start &&
			    (frame->tf_sxip & XIP_ADDR) <=
			      (unsigned)&guarded_access_end) {
				frame->tf_snip =
				  ((unsigned)&guarded_access_bad    ) | NIP_V;
				frame->tf_sfip =
				  ((unsigned)&guarded_access_bad + 4) | FIP_V;
				frame->tf_sxip = 0;
				/* We sort of resolved the fault ourselves
				 * because we know where it came from
				 * [guarded_access()]. But we must still think
				 * about the other possible transactions in
				 * dmt1 & dmt2.  Mark dmt0 so that
				 * data_access_emulation skips it.  XXX smurph
				 */
				frame->tf_dmt0 |= DMT_SKIP;
				data_access_emulation((unsigned *)frame);
				frame->tf_dpfsr = 0;
				frame->tf_dmt0 = 0;
				return;
			}
			break;
#endif
@


1.12
log
@guarded_access() is really only used by the MVME188 interrupt engine, so
do not provide it on luna88k. Makes trap() slightly faster on non-MVME188
kernels.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.11 2004/09/30 21:48:56 miod Exp $	*/
d266 1
a266 1
		(*md.interrupt_func)(T_INT, frame);
d741 1
a741 1
		(*md.interrupt_func)(T_NON_MASK, frame);
d745 1
a745 1
		(*md.interrupt_func)(T_INT, frame);
@


1.11
log
@Introduce sparc-like CPU_ISFOO macros, to short-circuit evaluations when
compiling for one flavour only.

This makes code slightly smaller on all m88k-based platforms (my roughly
1KB), and saves more than meets the eye on luna88k, which is m88100-based.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.10 2004/07/26 10:42:56 miod Exp $	*/
d216 1
d220 1
d322 1
d350 1
a657 3
	extern unsigned guarded_access_start;
	extern unsigned guarded_access_end;
	extern unsigned guarded_access_bad;
a796 12
		if (frame->tf_dsr & CMMU_DSR_BE) {
			/*
			 * If it is a guarded access, bus error is OK.
			 */
			if ((frame->tf_exip & XIP_ADDR) >=
			      (unsigned)&guarded_access_start &&
			    (frame->tf_exip & XIP_ADDR) <=
			      (unsigned)&guarded_access_end) {
				frame->tf_exip = (unsigned)&guarded_access_bad;
				return;
			}
		}
@


1.10
log
@Shrink more code if option PTRACE is not set; also use ss_put_value()
in trap handlers instead of inlining it by hand.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.9 2004/07/22 18:58:57 miod Exp $	*/
a156 1
		switch (cputyp) {
d158 1
a158 1
		case CPU_88100:
d176 1
a176 1
			break;
d179 1
a179 1
		case CPU_88110:
d182 1
a182 1
			break;
a183 1
		}
d1510 2
a1511 1
	if (cputyp != CPU_88110) {
d1514 4
a1517 1
	} else {
d1524 1
@


1.9
log
@Reset pcb_onfault to NULL before invoking uvm_fault().
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.8 2004/06/22 18:26:12 miod Exp $	*/
d89 1
d529 1
a543 2
			struct uio uio;
			struct iovec iov;
a561 1
			instr = p->p_md.md_ss_instr;
d564 2
a565 10
				iov.iov_base = (caddr_t)&instr;
				iov.iov_len = sizeof(int);
				uio.uio_iov = &iov;
				uio.uio_iovcnt = 1;
				uio.uio_offset = (off_t)va;
				uio.uio_resid = sizeof(int);
				uio.uio_segflg = UIO_SYSSPACE;
				uio.uio_rw = UIO_WRITE;
				uio.uio_procp = curproc;
				procfs_domem(p, p, NULL, &uio);
a569 1
			va = p->p_md.md_ss_taken_addr;
d571 2
a572 10
				iov.iov_base = (caddr_t)&instr;
				iov.iov_len = sizeof(int);
				uio.uio_iov = &iov;
				uio.uio_iovcnt = 1;
				uio.uio_offset = (off_t)va;
				uio.uio_resid = sizeof(int);
				uio.uio_segflg = UIO_SYSSPACE;
				uio.uio_rw = UIO_WRITE;
				uio.uio_procp = curproc;
				procfs_domem(p, p, NULL, &uio);
d585 4
d1059 1
a1072 2
			struct uio uio;
			struct iovec iov;
a1090 1
			/*sig = suiword((caddr_t)pc, p->p_md.md_ss_instr);*/
d1092 2
a1093 11
			if (instr != 0) {
				iov.iov_base = (caddr_t)&instr;
				iov.iov_len = sizeof(int);
				uio.uio_iov = &iov;
				uio.uio_iovcnt = 1;
				uio.uio_offset = (off_t)pc;
				uio.uio_resid = sizeof(int);
				uio.uio_segflg = UIO_SYSSPACE;
				uio.uio_rw = UIO_WRITE;
				uio.uio_procp = curproc;
			}
d1096 1
a1098 1
			break;
d1100 5
a1538 1
int ss_put_value(struct proc *, unsigned, unsigned, int);
@


1.8
log
@Do not use db_printf() without a godd reason; while there, shrinken some
messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.7 2004/06/22 05:02:32 miod Exp $	*/
d203 1
a203 1
	vaddr_t va;
d360 2
d363 1
d418 2
d436 2
d450 3
a452 3
		if (result != 0 && p->p_addr->u_pcb.pcb_onfault != NULL) {
			frame->tf_snip = p->p_addr->u_pcb.pcb_onfault | NIP_V;
			frame->tf_sfip = (p->p_addr->u_pcb.pcb_onfault + 4) | FIP_V;
d655 1
a655 1
	vaddr_t va;
d830 2
d833 1
d868 2
d871 1
d910 2
d926 1
d974 1
d995 1
d1019 2
a1020 2
		if (result != 0 && p->p_addr->u_pcb.pcb_onfault != NULL) {
			frame->tf_exip = p->p_addr->u_pcb.pcb_onfault;
@


1.7
log
@After 88110 exception processing, do not reset the in-frame [di][lp]ar
values, they won't be put back to registers anyways...
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.6 2004/06/22 05:01:05 miod Exp $	*/
d77 1
a77 3
#ifdef DDB
#include <ddb/db_output.h>		/* db_printf()		*/
#endif /* DDB */
a79 6
#ifdef DDB
#define DEBUG_MSG(x) db_printf x
#else
#define DEBUG_MSG(x)
#endif /* DDB */

a152 1
#ifdef DDB
d161 1
a161 1
				db_printf("\nInstr access fault (%s) v = %x, "
d168 1
a168 1
				db_printf("\nData access fault (%s) v = %x, "
d174 1
a174 1
				db_printf("\nTrap type %d, v = %x, frame %p\n",
d180 1
a180 1
			db_printf("\nTrap type %d, v = %x, frame %p\n",
d185 1
d187 1
a188 1
#endif
d257 1
a257 1
		DEBUG_MSG(("Unimplemented opcode!\n"));
d269 2
a270 2
		DEBUG_MSG(("kernel misaligned "
			  "access exception @@ 0x%08x\n", frame->tf_sxip));
d586 2
a587 3
			frame->tf_sfip = frame->tf_snip;    /* set up next FIP */
			frame->tf_snip = pc;    /* set up next NIP */
			frame->tf_snip |= 2;	  /* set valid bit   */
d604 2
a605 2
		frame->tf_sfip = frame->tf_snip;    /* set up the next FIP */
		frame->tf_snip = frame->tf_sxip;    /* set up the next NIP */
d639 1
a639 1
#endif /* m88100 */
d657 1
a657 1
        int s; /* IPL */
d689 1
a689 1
		DEBUG_MSG(("DMMU read miss: Hardware Table Searches should be enabled!\n"));
d695 1
a695 1
		DEBUG_MSG(("DMMU write miss: Hardware Table Searches should be enabled!\n"));
d701 1
a701 1
		DEBUG_MSG(("IMMU miss: Hardware Table Searches should be enabled!\n"));
d744 1
a744 1
		DEBUG_MSG(("Unimplemented opcode!\n"));
a748 2
		/* This function pointer is set in machdep.c
		   It calls m197_ext_int - smurph */
d756 2
a757 2
		DEBUG_MSG(("kernel mode misaligned "
			  "access exception @@ 0x%08x\n", frame->tf_exip));
d839 1
d842 1
d1145 5
a1150 13
	switch (frame->tf_vector) {
	case 0:
		db_printf("\n[RESET EXCEPTION (Really Bad News[tm]) frame %8p]\n", frame);
		db_printf("This is usually caused by a branch to a NULL function pointer.\n");
		db_printf("e.g. jump to address 0.  Use the debugger trace command to track it down.\n");
		break;
	default:
		db_printf("\n[ERROR EXCEPTION (Bad News[tm]) frame %p]\n", frame);
		db_printf("This is usually an exception within an exception.  The trap\n");
		db_printf("frame shadow registers you are about to see are invalid.\n");
		db_printf("(read totally useless)  But R1 to R31 might be interesting.\n");
		break;
	}
d1152 1
a1152 1
#endif /* DDB */
@


1.6
log
@On 88110, simplify enip processing:
- always fetch its value when building trapframe, it is faster than only
  doing it after checking if it will have a meaningful value.
- don't bother setting it to a safe value if we change exip to a
  non-delayslot address.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.5 2004/06/07 10:28:47 miod Exp $	*/
a1011 1
			frame->tf_dsr = frame->tf_isr = 0;
a1144 5
		/*
		 * don't want multiple faults - we are going to
		 * deliver signal.
		 */
		frame->tf_dsr = frame->tf_isr = 0;
@


1.5
log
@Allow userland to issue ld.d or st.d with a long, but not long long aligned
address, by recovering from the misaligned address exception.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.4 2004/06/03 05:18:43 miod Exp $	*/
a738 1
		frame->tf_enip = 0;
a824 1
				frame->tf_enip = 0;
a1011 1
			frame->tf_enip = 0;
d1452 1
a1452 1
	 *	   exip += 8
a1480 1
		tf->tf_enip = 0;
a1496 1
		tf->tf_enip = 0;
a1507 1
		tf->tf_enip = 0;
a1545 1
		tf->tf_enip = 0;
@


1.4
log
@Signal bus errors when a write back operation fails on 88110.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.3 2004/06/03 05:17:36 miod Exp $	*/
d3 1
d96 1
d490 2
a491 1
		sig = SIGBUS;
d1029 2
a1030 1
		sig = SIGBUS;
d1802 99
@


1.4.2.1
log
@Merge with the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.4.2.2
log
@sync to head
@
text
@a2 1
 * Copyright (c) 2004, Miodrag Vallat.
a94 1
int double_reg_fixup(struct trapframe *);
d488 1
a488 2
		/* Fix any misaligned ld.d or st.d instructions */
		sig = double_reg_fixup(frame);
d1026 1
a1026 2
		/* Fix any misaligned ld.d or st.d instructions */
		sig = double_reg_fixup(frame);
a1797 99

/*
 * ld.d and st.d instructions referencing long aligned but not long long
 * aligned addresses will trigger a misaligned address exception.
 *
 * This routine attempts to recover these (valid) statements, by simulating
 * the splitted form of the instruction. If it fails, it returns the
 * appropriate signal number to deliver.
 */
int
double_reg_fixup(struct trapframe *frame)
{
	u_int32_t pc, instr, value;
	int regno, store;
	vaddr_t addr;

	/*
	 * Decode the faulting instruction.
	 */

	pc = PC_REGS(&frame->tf_regs);
	if (copyin((void *)pc, &instr, sizeof(u_int32_t)) != 0)
		return SIGSEGV;

	switch (instr & 0xfc00ff00) {
	case 0xf4001000:	/* ld.d rD, rS1, rS2 */
		addr = frame->tf_r[(instr >> 16) & 0x1f]
		    + frame->tf_r[(instr & 0x1f)];
		store = 0;
		break;
	case 0xf4001200:	/* ld.d rD, rS1[rS2] */
		addr = frame->tf_r[(instr >> 16) & 0x1f]
		    + (frame->tf_r[(instr & 0x1f)] << 3);
		store = 0;
		break;
	case 0xf4002000:	/* st.d rD, rS1, rS2 */
		addr = frame->tf_r[(instr >> 16) & 0x1f]
		    + frame->tf_r[(instr & 0x1f)];
		store = 1;
		break;
	case 0xf4002200:	/* st.d rD, rS1[rS2] */
		addr = frame->tf_r[(instr >> 16) & 0x1f]
		    + (frame->tf_r[(instr & 0x1f)] << 3);
		store = 1;
		break;
	default:
		switch (instr & 0xfc000000) {
		case 0x10000000:	/* ld.d rD, rS, imm16 */
			addr = (instr & 0x0000ffff) +
			    frame->tf_r[(instr >> 16) & 0x1f];
			store = 0;
			break;
		case 0x20000000:	/* st.d rD, rS, imm16 */
			addr = (instr & 0x0000ffff) +
			    frame->tf_r[(instr >> 16) & 0x1f];
			store = 1;
			break;
		default:
			return SIGBUS;
		}
		break;
	}

	/* We only handle long but not long long aligned access here */
	if ((addr & 0x07) != 4)
		return SIGBUS;

	regno = (instr >> 21) & 0x1f;

	if (store) {
		/*
		 * Two word stores.
		 */
		value = frame->tf_r[regno++];
		if (copyout(&value, (void *)addr, sizeof(u_int32_t)) != 0)
			return SIGSEGV;
		if (regno == 32)
			value = 0;
		else
			value = frame->tf_r[regno];
		if (copyout(&value, (void *)(addr + 4), sizeof(u_int32_t)) != 0)
			return SIGSEGV;
	} else {
		/*
		 * Two word loads. r0 should be left unaltered, but the
		 * value should still be fetched even if it is discarded.
		 */
		if (copyin((void *)addr, &value, sizeof(u_int32_t)) != 0)
			return SIGSEGV;
		if (regno != 0)
			frame->tf_r[regno] = value;
		if (copyin((void *)(addr + 4), &value, sizeof(u_int32_t)) != 0)
			return SIGSEGV;
		if (regno != 31)
			frame->tf_r[regno + 1] = value;
	}

	return 0;
}
@


1.3
log
@Be sure to preserve r3 for syscalls which return 32-bit values.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.2 2004/05/07 15:31:13 miod Exp $	*/
d924 1
a924 1
				result = 0;
@


1.2
log
@Make #endif /* foo */ comments really match the #if condition.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.1 2004/04/29 14:33:27 miod Exp $	*/
d1257 1
a1257 1
	rval[1] = 0;
d1426 1
a1426 1
	rval[1] = 0;
@


1.1
log
@Continue factorizing m88k common code, this time files in <arch>/<arch>
which were copied verbatim from mvme88k to luna88k.

This requires backing out syntactic sugar in mvme88k kernel configuration
files which would deduct the required processor types from the board models,
as the common code only depends upon the M88100 and M88110 defines.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.72 2004/01/29 21:39:05 deraadt Exp $	*/
d1154 1
a1154 1
#endif /* MVME197 */
d1522 1
a1522 1
#endif	/* MVME197 */
@

