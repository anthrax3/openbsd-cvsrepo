head	1.14;
access;
symbols
	OPENBSD_6_1:1.14.0.2
	OPENBSD_6_1_BASE:1.14
	OPENBSD_6_0:1.13.0.6
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.2
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.13.0.4
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.11.0.10
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.11.0.8
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.4
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.11.0.2
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.10.0.18
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.16
	OPENBSD_5_0:1.10.0.14
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.12
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.10.0.10
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.6
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.10.0.8
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.4
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.2
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.9.0.4
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.2
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.8.0.2
	OPENBSD_4_1_BASE:1.8
	SH_20061006:1.1.1.1
	miod:1.1.1;
locks; strict;
comment	@ * @;


1.14
date	2017.02.12.04.55.08;	author guenther;	state Exp;
branches;
next	1.13;
commitid	1rXx7AiXIWFC9gYa;

1.13
date	2015.05.05.02.13.47;	author guenther;	state Exp;
branches;
next	1.12;
commitid	dNPv28CJI5BxtRGW;

1.12
date	2014.11.16.12.30.58;	author deraadt;	state Exp;
branches;
next	1.11;
commitid	yv0ECmCdICvq576h;

1.11
date	2013.01.16.19.04.43;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2008.07.14.14.00.00;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2007.05.27.20.59.26;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2007.03.02.06.11.54;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2006.11.17.08.35.43;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2006.11.16.22.27.58;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2006.11.16.00.12.19;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2006.11.14.19.49.48;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2006.11.05.18.57.45;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2006.11.03.03.35.42;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	2006.10.06.21.02.55;	author miod;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.10.06.21.02.55;	author miod;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Split up fork1():
 - FORK_THREAD handling is a totally separate function, thread_fork(),
   that is only used by sys___tfork() and which loses the flags, func,
   arg, and newprocp parameters and gains tcb parameter to guarantee
   the new thread's TCB is set before the creating thread returns
 - fork1() loses its stack and tidptr parameters
Common bits factor out:
 - struct proc allocation and initialization moves to thread_new()
 - maxthread handling moves to fork_check_maxthread()
 - setting the new thread running moves to fork_thread_start()
The MD cpu_fork() function swaps its unused stacksize parameter for
a tcb parameter.

luna88k testing by aoyama@@, alpha testing by dlg@@
ok mpi@@
@
text
@/*	$OpenBSD: vm_machdep.c,v 1.13 2015/05/05 02:13:47 guenther Exp $	*/
/*	$NetBSD: vm_machdep.c,v 1.53 2006/08/31 16:49:21 matt Exp $	*/

/*
 * Copyright (c) 2007 Miodrag Vallat.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice, this permission notice, and the disclaimer below
 * appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
/*-
 * Copyright (c) 2002 The NetBSD Foundation, Inc. All rights reserved.
 * Copyright (c) 1982, 1986 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department, and William Jolitz.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)vm_machdep.c	7.3 (Berkeley) 5/13/91
 */
/*-
 * Copyright (c) 1995 Charles M. Hannum.  All rights reserved.
 * Copyright (c) 1989, 1990 William Jolitz
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department, and William Jolitz.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)vm_machdep.c	7.3 (Berkeley) 5/13/91
 */

/*
 *	Utah $Hdr: vm_machdep.c 1.16.1.1 89/06/23$
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/malloc.h>
#include <sys/vnode.h>
#include <sys/buf.h>
#include <sys/user.h>
#include <sys/exec.h>
#include <sys/ptrace.h>
#include <sys/signalvar.h>

#include <uvm/uvm_extern.h>

#include <sh/locore.h>
#include <sh/cpu.h>
#include <sh/reg.h>
#include <sh/mmu.h>
#include <sh/cache.h>

extern void proc_trampoline(void);

/*
 * Finish a fork operation, with process p2 nearly set up.
 * Copy and update the pcb and trap frame, making the child ready to run.
 * 
 * Rig the child's kernel stack so that it will start out in
 * proc_trampoline() and call 'func' with 'arg' as an argument.
 * For normal processes this is child_return(), which causes the
 * child to go directly to user level with an apparent return value
 * of 0 from fork(), while the parent process returns normally.
 * For kernel threads this will be a function that never return.
 *
 * An alternate user-level stack or TCB can be requested by passing
 * a non-NULL value; these are poked into the PCB so they're in
 * effect at the initial return to userspace.
 */
void
cpu_fork(struct proc *p1, struct proc *p2, void *stack, void *tcb,
    void (*func)(void *), void *arg)
{
	struct pcb *pcb;
	struct trapframe *tf;
	struct switchframe *sf;
	vaddr_t spbase, fptop;
#define	P1ADDR(x)	(SH3_PHYS_TO_P1SEG(*__pmap_kpte_lookup(x) & PG_PPN))

	KDASSERT(p1 == curproc || p1 == &proc0);

	bzero(&p2->p_md, sizeof(p2->p_md));

	/* Copy flags */
	p2->p_md.md_flags = p1->p_md.md_flags;

	pcb = NULL;		/* XXXGCC: -Wuninitialized */
#ifdef SH3
	/*
	 * Convert frame pointer top to P1. because SH3 can't make
	 * wired TLB entry, context store space accessing must not cause
	 * exception. For SH3, we are 4K page, P3/P1 conversion don't
	 * cause virtual-aliasing.
	 */
	if (CPU_IS_SH3)
		pcb = (struct pcb *)P1ADDR((vaddr_t)&p2->p_addr->u_pcb);
#endif /* SH3 */
#ifdef SH4
	/* SH4 can make wired entry, no need to convert to P1. */
	if (CPU_IS_SH4)
		pcb = &p2->p_addr->u_pcb;
#endif /* SH4 */

	p2->p_md.md_pcb = pcb;
	fptop = (vaddr_t)pcb + PAGE_SIZE;

	/* set up the kernel stack pointer */
	spbase = (vaddr_t)p2->p_addr + PAGE_SIZE;
#ifdef P1_STACK
	/* Convert to P1 from P3 */
	/*
	 * wbinv u-area to avoid cache-aliasing, since kernel stack
	 * is accessed from P1 instead of P3.
	 */
	if (SH_HAS_VIRTUAL_ALIAS)
		sh_dcache_wbinv_range((vaddr_t)p2->p_addr, USPACE);
	spbase = P1ADDR(spbase);
#else /* !P1_STACK */
	/* Prepare u-area PTEs */
#ifdef SH3
	if (CPU_IS_SH3)
		sh3_switch_setup(p2);
#endif
#ifdef SH4
	if (CPU_IS_SH4)
		sh4_switch_setup(p2);
#endif
#endif /* !P1_STACK */

#ifdef KSTACK_DEBUG
	/* Fill magic number for tracking */
	memset((char *)fptop - PAGE_SIZE + sizeof(struct user), 0x5a,
	    PAGE_SIZE - sizeof(struct user));
	memset((char *)spbase, 0xa5, (USPACE - PAGE_SIZE));
	memset(&pcb->pcb_sf, 0xb4, sizeof(struct switchframe));
#endif /* KSTACK_DEBUG */

	/*
	 * Copy the user context.
	 */
	p2->p_md.md_regs = tf = (struct trapframe *)fptop - 1;
	memcpy(tf, p1->p_md.md_regs, sizeof(struct trapframe));

	/*
	 * If specified, give the child a different stack.
	 */
	if (stack != NULL)
		tf->tf_r15 = (int)stack;
	if (tcb != NULL)
		tf->tf_gbr = (int)tcb;

	/* Setup switch frame */
	sf = &pcb->pcb_sf;
	sf->sf_r11 = (int)arg;		/* proc_trampoline hook func's arg */
	sf->sf_r12 = (int)func;		/* proc_trampoline hook func */
	sf->sf_r15 = spbase + USPACE - PAGE_SIZE;/* current stack pointer */
	sf->sf_r7_bank = sf->sf_r15;	/* stack top */
	sf->sf_r6_bank = (vaddr_t)tf;	/* current frame pointer */
	/* when switch to me, jump to proc_trampoline */
	sf->sf_pr = (int)proc_trampoline;
	/*
	 * Enable interrupt when switch frame is restored, since
	 * kernel thread begin to run without restoring trapframe.
	 */
	sf->sf_sr = PSL_MD;		/* kernel mode, interrupt enable */

#ifdef SH4
	if (CPU_IS_SH4) {
		/*
		 * Propagate floating point registers to the new process
		 * (they are not in the trapframe).
		 */
		if (p1 == curproc)
			fpu_save(&p1->p_md.md_pcb->pcb_fp);
		bcopy(&p1->p_md.md_pcb->pcb_fp, &pcb->pcb_fp,
		    sizeof(struct fpreg));
	}
#endif
}

/*
 * Map an IO request into kernel virtual address space.
 * All requests are (re)mapped into kernel VA space via the phys_map
 * (a name with only slightly more meaning than "kernel_map")
 */

void
vmapbuf(struct buf *bp, vsize_t len)
{
	vaddr_t faddr, taddr, off;
	paddr_t fpa;
	pmap_t kpmap, upmap;

	if ((bp->b_flags & B_PHYS) == 0)
		panic("vmapbuf");
	bp->b_saveaddr = bp->b_data;
	faddr = trunc_page((vaddr_t)bp->b_data);
	off = (vaddr_t)bp->b_data - faddr;
	len = round_page(off + len);
	taddr = uvm_km_valloc_prefer_wait(phys_map, len, faddr);
	bp->b_data = (caddr_t)(taddr + off);
	/*
	 * The region is locked, so we expect that pmap_pte() will return
	 * non-NULL.
	 * XXX: unwise to expect this in a multithreaded environment.
	 * anything can happen to a pmap between the time we lock a
	 * region, release the pmap lock, and then relock it for
	 * the pmap_extract().
	 *
	 * no need to flush TLB since we expect nothing to be mapped
	 * where we we just allocated (TLB will be flushed when our
	 * mapping is removed).
	 */
	upmap = vm_map_pmap(&bp->b_proc->p_vmspace->vm_map);
	kpmap = vm_map_pmap(phys_map);
	while (len) {
		pmap_extract(upmap, faddr, &fpa);
		pmap_enter(kpmap, taddr, fpa,
		    PROT_READ | PROT_WRITE, PMAP_WIRED);
		faddr += PAGE_SIZE;
		taddr += PAGE_SIZE;
		len -= PAGE_SIZE;
	}
	pmap_update(kpmap);
}

/*
 * Free the io map PTEs associated with this IO operation.
 * We also invalidate the TLB entries and restore the original b_addr.
 */
void
vunmapbuf(struct buf *bp, vsize_t len)
{
	vaddr_t addr, off;
	pmap_t kpmap;

	if ((bp->b_flags & B_PHYS) == 0)
		panic("vunmapbuf");
	addr = trunc_page((vaddr_t)bp->b_data);
	off = (vaddr_t)bp->b_data - addr;
	len = round_page(off + len);
	kpmap = vm_map_pmap(phys_map);
	pmap_remove(kpmap, addr, addr + len);
	pmap_update(kpmap);
	uvm_km_free_wakeup(phys_map, addr, len);
	bp->b_data = bp->b_saveaddr;
	bp->b_saveaddr = 0;
}
@


1.13
log
@emul_native is only used for kernel threads which can't dump core, so
delete coredump_trad(), uvm_coredump(), cpu_coredump(), struct md_coredump,
and various #includes that are superfluous.

This leaves compat_linux processes without a coredump callback.  If that
ability is desired, someone should update it to use coredump_elf32() and
verify the results...

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.12 2014/11/16 12:30:58 deraadt Exp $	*/
d123 1
a123 1
 *
d125 9
a133 12
 * proc_trampoline() and call child_return() with p2 as an
 * argument. This causes the newly-created child process to go
 * directly to user level with an apparent return value of 0 from
 * fork(), while the parent process returns normally.
 *
 * p1 is the process being forked; if p1 == &proc0, we are creating
 * a kernel thread, and the return path and argument are specified with
 * `func' and `arg'.
 *
 * If an alternate user-level stack is requested (with non-zero values
 * in both the stack and stacksize args), set up the user stack pointer
 * accordingly.
d136 1
a136 1
cpu_fork(struct proc *p1, struct proc *p2, void *stack, size_t stacksize,
d213 3
a215 1
		tf->tf_r15 = (u_int)stack + stacksize;
@


1.12
log
@Replace a plethora of historical protection options with just
PROT_NONE, PROT_READ, PROT_WRITE, and PROT_EXEC from mman.h.
PROT_MASK is introduced as the one true way of extracting those bits.
Remove UVM_ADV_* wrapper, using the standard names.
ok doug guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.11 2013/01/16 19:04:43 miod Exp $	*/
a105 1
#include <sys/core.h>
a244 57
}

/*
 * Dump the machine specific segment at the start of a core dump.
 */
struct md_core {
	struct reg intreg;
	struct fpreg fpreg;
};

int
cpu_coredump(struct proc *p, struct vnode *vp, struct ucred *cred,
    struct core *chdr)
{
	struct md_core md_core;
	struct coreseg cseg;
	int error;

	CORE_SETMAGIC(*chdr, COREMAGIC, MID_MACHINE, 0);
	chdr->c_hdrsize = ALIGN(sizeof(*chdr));
	chdr->c_seghdrsize = ALIGN(sizeof(cseg));
	chdr->c_cpusize = sizeof(md_core);

	/* Save integer registers. */
	error = process_read_regs(p, &md_core.intreg);
	if (error)
		return error;

#ifdef SH4
	if (CPU_IS_SH4) {
		error = process_read_fpregs(p, &md_core.fpreg);
		if (error)
			return error;
	}
#endif
#ifdef SH3
	if (CPU_IS_SH3)
		bzero(&md_core.fpreg, sizeof(md_core.fpreg));
#endif

	CORE_SETMAGIC(cseg, CORESEGMAGIC, MID_MACHINE, CORE_CPU);
	cseg.c_addr = 0;
	cseg.c_size = chdr->c_cpusize;

	error = vn_rdwr(UIO_WRITE, vp, (caddr_t)&cseg, chdr->c_seghdrsize,
	    (off_t)chdr->c_hdrsize, UIO_SYSSPACE, IO_UNIT, cred, NULL, p);
	if (error)
		return error;

	error = vn_rdwr(UIO_WRITE, vp, (caddr_t)&md_core, sizeof(md_core),
	    (off_t)(chdr->c_hdrsize + chdr->c_seghdrsize), UIO_SYSSPACE,
	    IO_UNIT, cred, NULL, p);
	if (error)
		return error;

	chdr->c_nseg++;
	return 0;
@


1.11
log
@cpu_coredump() also needs to invoke vn_rdwr() without IO_NODELOCKED; only
affects a.out binaries' core dumps.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.10 2008/07/14 14:00:00 miod Exp $	*/
d343 1
a343 1
		    VM_PROT_READ | VM_PROT_WRITE, PMAP_WIRED);
@


1.10
log
@Use uvm_km_valloc_prefer_wait() instead of uvm_km_valloc_wait() in vmapbuf().

ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.9 2007/05/27 20:59:26 miod Exp $	*/
d291 1
a291 2
	    (off_t)chdr->c_hdrsize, UIO_SYSSPACE, IO_NODELOCKED | IO_UNIT, cred,
	    NULL, p);
d297 1
a297 1
	    IO_NODELOCKED | IO_UNIT, cred, NULL, p);
@


1.9
log
@pagemove() is no longer used.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.8 2007/03/02 06:11:54 miod Exp $	*/
d325 1
a325 1
	taddr = uvm_km_valloc_wait(phys_map, len);
@


1.8
log
@Move landisk to hardware floating point. At the moment the FPU context is
always saved upon context switches, as FPU registers are heavily used for
long long computations (don't ask). Gcc default to -m4.

Credits to drahn@@ otto@@ and deraadt@@ for feedback and help testing.

Upgrade procedure if you don't want to use the damn snapshots:
- build and install new kernel, reboot off it
- build new gcc, do not install it yet
- make includes
- install new gcc
- build and install lib/csu and lib/libc
- make build
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.7 2006/11/17 08:35:43 deraadt Exp $	*/
a303 34
}

/*
 * Move pages from one kernel virtual address to another.
 * Both addresses are assumed to reside in the Sysmap,
 * and size must be a multiple of PAGE_SIZE.
 */

void
pagemove(caddr_t from, caddr_t to, size_t size)
{
	paddr_t pa;
	boolean_t rv;

#ifdef DEBUG
	if (size % PAGE_SIZE)
		panic("pagemove: size=%08lx", (u_long) size);
#endif

	while (size > 0) {
		rv = pmap_extract(pmap_kernel(), (vaddr_t) from, &pa);
#ifdef DEBUG
		if (rv == FALSE)
			panic("pagemove 2");
		if (pmap_extract(pmap_kernel(), (vaddr_t) to, NULL) == TRUE)
			panic("pagemove 3");
#endif
		pmap_kremove((vaddr_t) from, PAGE_SIZE);
		pmap_kenter_pa((vaddr_t) to, pa, VM_PROT_READ|VM_PROT_WRITE);
		from += PAGE_SIZE;
		to += PAGE_SIZE;
		size -= PAGE_SIZE;
	}
	pmap_update(pmap_kernel());
@


1.7
log
@sorry miod, but this version locks the machine up rather fast
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.5 2006/11/16 00:12:19 deraadt Exp $	*/
d4 16
a54 1

d233 13
d253 1
d273 12
@


1.6
log
@pagemove() this time without an accidental line removal
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.4 2006/11/14 19:49:48 miod Exp $	*/
d274 2
a275 1
	pt_entry_t *fpte, *tpte;
d278 1
a278 1
	if (size & PAGE_MASK)
a281 5
	if (SH_HAS_VIRTUAL_ALIAS)
		sh_dcache_wbinv_range((vaddr_t)from, size);

	fpte = __pmap_kpte_lookup((vaddr_t)from);
	tpte = __pmap_kpte_lookup((vaddr_t)to);
d283 9
a291 4
		*tpte++ = *fpte;
		*fpte++ = 0;
		sh_tlb_invalidate_addr(0, (vaddr_t)from);
		sh_tlb_invalidate_addr(0, (vaddr_t)to);
d296 1
@


1.5
log
@backout pagemove() diff; does not work
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.3 2006/11/05 18:57:45 miod Exp $	*/
d274 1
a274 2
	paddr_t pa;
	boolean_t rv;
d277 1
a277 1
	if (size % PAGE_SIZE)
d281 5
d287 4
a290 9
		rv = pmap_extract(pmap_kernel(), (vaddr_t) from, &pa);
#ifdef DEBUG
		if (rv == FALSE)
			panic("pagemove 2");
		if (pmap_extract(pmap_kernel(), (vaddr_t) to, NULL) == TRUE)
			panic("pagemove 3");
#endif
		pmap_kremove((vaddr_t) from, PAGE_SIZE);
		pmap_kenter_pa((vaddr_t) to, pa, VM_PROT_READ|VM_PROT_WRITE);
a294 1
	pmap_update(pmap_kernel());
@


1.4
log
@A less awkward pagemove() implementation.
@
text
@d274 2
a275 1
	pt_entry_t *fpte, *tpte;
d278 1
a278 1
	if (size & PAGE_MASK)
a281 5
	if (SH_HAS_VIRTUAL_ALIAS)
		sh_dcache_wbinv_range((vaddr_t)from, size);

	fpte = __pmap_kpte_lookup((vaddr_t)from);
	tpte = __pmap_kpte_lookup((vaddr_t)to);
d283 9
a291 3
		*tpte++ = *fpte;
		sh_tlb_invalidate_addr(0, (vaddr_t)from);
		sh_tlb_invalidate_addr(0, (vaddr_t)to);
d296 1
@


1.3
log
@Fix a couple of comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.2 2006/11/03 03:35:42 mickey Exp $	*/
d274 1
a274 2
	paddr_t pa;
	boolean_t rv;
d277 1
a277 1
	if (size % PAGE_SIZE)
d281 5
d287 3
a289 9
		rv = pmap_extract(pmap_kernel(), (vaddr_t) from, &pa);
#ifdef DEBUG
		if (rv == FALSE)
			panic("pagemove 2");
		if (pmap_extract(pmap_kernel(), (vaddr_t) to, NULL) == TRUE)
			panic("pagemove 3");
#endif
		pmap_kremove((vaddr_t) from, PAGE_SIZE);
		pmap_kenter_pa((vaddr_t) to, pa, VM_PROT_READ|VM_PROT_WRITE);
a293 1
	pmap_update(pmap_kernel());
@


1.2
log
@mdproc has to be initialised
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.1.1.1 2006/10/06 21:02:55 miod Exp $	*/
d206 2
a207 2
	sf->sf_r11 = (int)arg;		/* proc_trampoline hook func */
	sf->sf_r12 = (int)func;		/* proc_trampoline hook func's arg */
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d135 2
@


1.1.1.1
log
@Preliminary bits for SuperH-based ports, based on NetBSD/sh3 codebase with
minor changes.
@
text
@@
