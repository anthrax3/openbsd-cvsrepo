head	1.37;
access;
symbols
	OPENBSD_6_1:1.37.0.4
	OPENBSD_6_1_BASE:1.37
	OPENBSD_6_0:1.35.0.2
	OPENBSD_6_0_BASE:1.35
	OPENBSD_5_9:1.34.0.2
	OPENBSD_5_9_BASE:1.34
	OPENBSD_5_8:1.33.0.6
	OPENBSD_5_8_BASE:1.33
	OPENBSD_5_7:1.33.0.2
	OPENBSD_5_7_BASE:1.33
	OPENBSD_5_6:1.30.0.4
	OPENBSD_5_6_BASE:1.30
	OPENBSD_5_5:1.21.0.8
	OPENBSD_5_5_BASE:1.21
	OPENBSD_5_4:1.21.0.4
	OPENBSD_5_4_BASE:1.21
	OPENBSD_5_3:1.21.0.2
	OPENBSD_5_3_BASE:1.21
	OPENBSD_5_2:1.19.0.2
	OPENBSD_5_2_BASE:1.19
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.2
	OPENBSD_5_0:1.17.0.2
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.16.0.4
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.16.0.2
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.14.0.4
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.14.0.6
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.14.0.2
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.13.0.2
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.12.0.4
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.12.0.2
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.10.0.2
	OPENBSD_4_1_BASE:1.10
	SH_20061006:1.1.1.1
	miod:1.1.1;
locks; strict;
comment	@ * @;


1.37
date	2017.01.21.05.42.03;	author guenther;	state Exp;
branches;
next	1.36;
commitid	CHRb0fCqa8XxUAMH;

1.36
date	2016.10.08.05.49.09;	author guenther;	state Exp;
branches;
next	1.35;
commitid	z63v1DilayzHcfkw;

1.35
date	2016.02.27.13.08.07;	author mpi;	state Exp;
branches;
next	1.34;
commitid	hnv9KfQtxhCytAnd;

1.34
date	2015.09.10.17.32.19;	author miod;	state Exp;
branches;
next	1.33;
commitid	7BuW1OOSoNvAUMsG;

1.33
date	2015.02.09.09.32.53;	author miod;	state Exp;
branches;
next	1.32;
commitid	hsryN8zg62Yz2knS;

1.32
date	2014.11.16.12.30.58;	author deraadt;	state Exp;
branches;
next	1.31;
commitid	yv0ECmCdICvq576h;

1.31
date	2014.10.13.04.47.22;	author miod;	state Exp;
branches;
next	1.30;
commitid	dvULoNqoEqrcxAwl;

1.30
date	2014.07.10.14.21.20;	author deraadt;	state Exp;
branches;
next	1.29;
commitid	Jjzk0Y0KSLF2oro4;

1.29
date	2014.05.11.00.12.44;	author guenther;	state Exp;
branches;
next	1.28;

1.28
date	2014.05.10.16.56.23;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2014.05.10.05.33.00;	author guenther;	state Exp;
branches;
next	1.26;

1.26
date	2014.05.08.21.43.04;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2014.04.18.11.51.17;	author guenther;	state Exp;
branches;
next	1.24;

1.24
date	2014.03.30.21.54.49;	author guenther;	state Exp;
branches;
next	1.23;

1.23
date	2014.03.29.18.09.30;	author guenther;	state Exp;
branches;
next	1.22;

1.22
date	2014.03.26.05.23.42;	author guenther;	state Exp;
branches;
next	1.21;

1.21
date	2012.12.31.06.46.14;	author guenther;	state Exp;
branches;
next	1.20;

1.20
date	2012.08.07.05.16.54;	author guenther;	state Exp;
branches;
next	1.19;

1.19
date	2012.04.11.14.38.55;	author mikeb;	state Exp;
branches;
next	1.18;

1.18
date	2011.11.16.20.50.19;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2011.04.03.14.56.28;	author guenther;	state Exp;
branches;
next	1.16;

1.16
date	2010.06.27.12.41.23;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2010.06.26.23.24.44;	author guenther;	state Exp;
branches;
next	1.14;

1.14
date	2008.10.04.19.21.50;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2008.06.24.21.24.03;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2007.03.15.10.22.29;	author art;	state Exp;
branches;
next	1.11;

1.11
date	2007.03.13.19.29.33;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2007.03.05.21.47.30;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2007.03.02.06.11.54;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2007.02.06.23.14.11;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2007.02.06.23.12.01;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2006.11.05.18.57.22;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2006.11.03.17.52.27;	author drahn;	state Exp;
branches;
next	1.4;

1.4
date	2006.11.03.02.52.02;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	2006.10.23.19.56.53;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2006.10.17.03.33.39;	author drahn;	state Exp;
branches;
next	1.1;

1.1
date	2006.10.06.21.02.55;	author miod;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.10.06.21.02.55;	author miod;	state Exp;
branches;
next	;


desc
@@


1.37
log
@p_comm is the process's command and isn't per thread, so move it from
struct proc to struct process.

ok deraadt@@ kettenis@@
@
text
@/*	$OpenBSD: trap.c,v 1.36 2016/10/08 05:49:09 guenther Exp $	*/
/*	$NetBSD: exception.c,v 1.32 2006/09/04 23:57:52 uwe Exp $	*/
/*	$NetBSD: syscall.c,v 1.6 2006/03/07 07:21:50 thorpej Exp $	*/

/*-
 * Copyright (c) 2002 The NetBSD Foundation, Inc. All rights reserved.
 * Copyright (c) 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the University of Utah, and William Jolitz.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)trap.c	7.4 (Berkeley) 5/13/91
 */

/*-
 * Copyright (c) 1995 Charles M. Hannum.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the University of Utah, and William Jolitz.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)trap.c	7.4 (Berkeley) 5/13/91
 */

/*
 * SH3 Trap and System call handling
 *
 * T.Horiuchi 1998.06.8
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/pool.h>
#include <sys/kernel.h>
#include <sys/signal.h>
#include <sys/resourcevar.h>
#include <sys/signalvar.h>
#include <uvm/uvm_extern.h>
#include <sys/syscall.h>
#include <sys/syscall_mi.h>

#include <sh/cache.h>
#include <sh/cpu.h>
#include <sh/mmu.h>
#include <sh/pcb.h>
#include <sh/trap.h>
#ifdef SH4
#include <sh/fpu.h>
#endif

#ifdef DDB
#include <machine/db_machdep.h>
#endif

const char * const exp_type[] = {
	NULL,					/* 000 (reset vector) */
	NULL,					/* 020 (reset vector) */
	"TLB miss/invalid (load)",		/* 040 EXPEVT_TLB_MISS_LD */
	"TLB miss/invalid (store)",		/* 060 EXPEVT_TLB_MISS_ST */
	"initial page write",			/* 080 EXPEVT_TLB_MOD */
	"TLB protection violation (load)",	/* 0a0 EXPEVT_TLB_PROT_LD */
	"TLB protection violation (store)",	/* 0c0 EXPEVT_TLB_PROT_ST */
	"address error (load)",			/* 0e0 EXPEVT_ADDR_ERR_LD */
	"address error (store)",		/* 100 EXPEVT_ADDR_ERR_ST */
	"FPU",					/* 120 EXPEVT_FPU */
	NULL,					/* 140 (reset vector) */
	"unconditional trap (TRAPA)",		/* 160 EXPEVT_TRAPA */
	"reserved instruction code exception",	/* 180 EXPEVT_RES_INST */
	"illegal slot instruction exception",	/* 1a0 EXPEVT_SLOT_INST */
	NULL,					/* 1c0 (external interrupt) */
	"user break point trap",		/* 1e0 EXPEVT_BREAK */
	NULL, NULL, NULL, NULL,			/* 200-260 */
	NULL, NULL, NULL, NULL,			/* 280-2e0 */
	NULL, NULL, NULL, NULL,			/* 300-360 */
	NULL, NULL, NULL, NULL,			/* 380-3e0 */
	NULL, NULL, NULL, NULL,			/* 400-460 */
	NULL, NULL, NULL, NULL,			/* 480-4e0 */
	NULL, NULL, NULL, NULL,			/* 500-560 */
	NULL, NULL, NULL, NULL,			/* 580-5e0 */
	NULL, NULL, NULL, NULL,			/* 600-660 */
	NULL, NULL, NULL, NULL,			/* 680-6e0 */
	NULL, NULL, NULL, NULL,			/* 700-760 */
	NULL, NULL, NULL, NULL,			/* 780-7e0 */
	"FPU disabled",				/* 800 EXPEVT_FPU_DISABLE */
	"slot FPU disabled"			/* 820 EXPEVT_FPU_SLOT_DISABLE */
};
const int exp_types = sizeof exp_type / sizeof exp_type[0];

void general_exception(struct proc *, struct trapframe *, uint32_t);
void tlb_exception(struct proc *, struct trapframe *, uint32_t);
void ast(struct proc *, struct trapframe *);
void syscall(struct proc *, struct trapframe *);
void cachectl(struct proc *, struct trapframe *);

/*
 * void general_exception(struct proc *p, struct trapframe *tf):
 *	p  ... curproc when exception occured.
 *	tf ... full user context.
 *	va ... fault va for user mode EXPEVT_ADDR_ERR_{LD,ST}
 */
void
general_exception(struct proc *p, struct trapframe *tf, uint32_t va)
{
	int expevt = tf->tf_expevt;
	int tra;
	int usermode = !KERNELMODE(tf->tf_ssr);
	union sigval sv;

	uvmexp.traps++;

	/*
	 * This function is entered at splhigh. Restore the interrupt
	 * level to what it was when the trap occured.
	 */
	splx(tf->tf_ssr & PSL_IMASK);

	if (usermode) {
		if (p == NULL)
			goto do_panic;
		KDASSERT(p->p_md.md_regs == tf); /* check exception depth */
		expevt |= EXP_USER;
		refreshcreds(p);
	}

	switch (expevt) {
	case EXPEVT_BREAK:
#ifdef DDB
		if (db_ktrap(EXPEVT_BREAK, 0, tf))
			return;
		else
#endif
			goto do_panic;
		break;
	case EXPEVT_TRAPA:
#ifdef DDB
		/* Check for ddb request */
		tra = _reg_read_4(SH_(TRA));
		if (tra == (_SH_TRA_BREAK << 2) &&
		    db_ktrap(expevt, tra, tf))
			return;
		else
#endif
			goto do_panic;
		break;
	case EXPEVT_TRAPA | EXP_USER:
		/* Check for debugger break */
		tra = _reg_read_4(SH_(TRA));
		switch (tra) {
		case _SH_TRA_BREAK << 2:
			tf->tf_spc -= 2; /* back to the breakpoint address */
			sv.sival_ptr = (void *)tf->tf_spc;
			trapsignal(p, SIGTRAP, expevt & ~EXP_USER, TRAP_BRKPT,
			    sv);
			goto out;
		case _SH_TRA_SYSCALL << 2:
			syscall(p, tf);
			return;
		case _SH_TRA_CACHECTL << 2:
			cachectl(p, tf);
			return;
		default:
			sv.sival_ptr = (void *)tf->tf_spc;
			trapsignal(p, SIGILL, expevt & ~EXP_USER, ILL_ILLTRP,
			    sv);
			goto out;
		}
		break;

	case EXPEVT_ADDR_ERR_LD: /* FALLTHROUGH */
	case EXPEVT_ADDR_ERR_ST:
		KDASSERT(p && p->p_md.md_pcb->pcb_onfault != NULL);
		if (p == NULL || p->p_md.md_pcb->pcb_onfault == 0)
			goto do_panic;
		tf->tf_spc = (int)p->p_md.md_pcb->pcb_onfault;
		break;

	case EXPEVT_ADDR_ERR_LD | EXP_USER: /* FALLTHROUGH */
	case EXPEVT_ADDR_ERR_ST | EXP_USER:
		sv.sival_ptr = (void *)va;
		if (((int)va) < 0)
			trapsignal(p, SIGSEGV, expevt & ~EXP_USER, SEGV_ACCERR,
			    sv);
		else
			trapsignal(p, SIGBUS, expevt & ~EXP_USER, BUS_ADRALN,
			    sv);
		goto out;

	case EXPEVT_RES_INST | EXP_USER: /* FALLTHROUGH */
	case EXPEVT_SLOT_INST | EXP_USER:
		sv.sival_ptr = (void *)tf->tf_spc;
		trapsignal(p, SIGILL, expevt & ~EXP_USER, ILL_ILLOPC, sv);
		goto out;

	case EXPEVT_BREAK | EXP_USER:
		sv.sival_ptr = (void *)tf->tf_spc;
		trapsignal(p, SIGTRAP, expevt & ~EXP_USER, TRAP_TRACE, sv);
		goto out;

#ifdef SH4
	case EXPEVT_FPU_DISABLE | EXP_USER: /* FALLTHROUGH */
	case EXPEVT_FPU_SLOT_DISABLE | EXP_USER:
		sv.sival_ptr = (void *)tf->tf_spc;
		trapsignal(p, SIGILL, expevt & ~EXP_USER, ILL_COPROC, sv);
		goto out;

	case EXPEVT_FPU | EXP_USER:
	    {
		int fpscr, sigi;

		/* XXX worth putting in the trapframe? */
		__asm__ volatile ("sts fpscr, %0" : "=r" (fpscr));
		fpscr = (fpscr & FPSCR_CAUSE_MASK) >> FPSCR_CAUSE_SHIFT;
		if (fpscr & FPEXC_E)
			sigi = FPE_FLTINV;	/* XXX any better value? */
		else if (fpscr & FPEXC_V)
			sigi = FPE_FLTINV;
		else if (fpscr & FPEXC_Z)
			sigi = FPE_FLTDIV;
		else if (fpscr & FPEXC_O)
			sigi = FPE_FLTOVF;
		else if (fpscr & FPEXC_U)
			sigi = FPE_FLTUND;
		else if (fpscr & FPEXC_I)
			sigi = FPE_FLTRES;
		else
			sigi = 0;	/* shouldn't happen */
		sv.sival_ptr = (void *)tf->tf_spc;
		trapsignal(p, SIGFPE, expevt & ~EXP_USER, sigi, sv);
	    }
		goto out;
#endif

	default:
		goto do_panic;
	}

	if (!usermode)
		return;
out:
	userret(p);
	return;

do_panic:
	if ((expevt >> 5) < exp_types && exp_type[expevt >> 5] != NULL)
		printf("fatal %s", exp_type[expevt >> 5]);
	else
		printf("EXPEVT 0x%03x", expevt);
	printf(" in %s mode\n", expevt & EXP_USER ? "user" : "kernel");
	printf("va 0x%x spc 0x%x ssr 0x%x pr 0x%x \n",
	    va, tf->tf_spc, tf->tf_ssr, tf->tf_pr);

	panic("general_exception");
	/* NOTREACHED */
}


/*
 * void tlb_exception(struct proc *p, struct trapframe *tf, uint32_t va):
 *	p  ... curproc when exception occured.
 *	tf ... full user context.
 *	va ... fault address.
 */
void
tlb_exception(struct proc *p, struct trapframe *tf, uint32_t va)
{
	struct vm_map *map;
	pmap_t pmap;
	union sigval sv;
	int usermode;
	int err, track, ftype;
	const char *panic_msg;

#define TLB_ASSERT(assert, msg)				\
		do {					\
			if (!(assert)) {		\
				panic_msg =  msg;	\
				goto tlb_panic;		\
			}				\
		} while(/*CONSTCOND*/0)

	/*
	 * This function is entered at splhigh. Restore the interrupt
	 * level to what it was when the trap occured.
	 */
	splx(tf->tf_ssr & PSL_IMASK);

	usermode = !KERNELMODE(tf->tf_ssr);
	if (usermode) {
		KDASSERT(p->p_md.md_regs == tf);
		refreshcreds(p);
	} else {
		KDASSERT(p == NULL ||		/* idle */
		    p == &proc0 ||		/* kthread */
		    p->p_md.md_regs != tf);	/* other */
	}

	switch (tf->tf_expevt) {
	case EXPEVT_TLB_MISS_LD:
		track = PVH_REFERENCED;
		ftype = PROT_READ;
		break;
	case EXPEVT_TLB_MISS_ST:
		track = PVH_REFERENCED;
		ftype = PROT_WRITE;
		break;
	case EXPEVT_TLB_MOD:
		track = PVH_REFERENCED | PVH_MODIFIED;
		ftype = PROT_WRITE;
		break;
	case EXPEVT_TLB_PROT_LD:
		TLB_ASSERT((int)va > 0,
		    "kernel virtual protection fault (load)");
		if (usermode) {
			sv.sival_ptr = (void *)va;
			trapsignal(p, SIGSEGV, tf->tf_expevt, SEGV_ACCERR, sv);
			goto user_fault;
		} else {
			TLB_ASSERT(p->p_md.md_pcb->pcb_onfault != NULL,
			    "no copyin/out fault handler (load protection)");
			tf->tf_spc = (int)p->p_md.md_pcb->pcb_onfault;
		}
		return;

	case EXPEVT_TLB_PROT_ST:
		track = 0;	/* call uvm_fault first. (COW) */
		ftype = PROT_WRITE;
		break;

	default:
		TLB_ASSERT(0, "impossible expevt");
	}

	/* Select address space */
	if (usermode) {
		TLB_ASSERT(p != NULL, "no curproc");
		map = &p->p_vmspace->vm_map;
		pmap = map->pmap;
	} else {
		if ((int)va < 0) {
			map = kernel_map;
			pmap = pmap_kernel();
		} else {
			TLB_ASSERT(p != NULL &&
			    p->p_md.md_pcb->pcb_onfault != NULL,
			    "invalid user-space access from kernel mode");
			if (va == 0) {
				tf->tf_spc = (int)p->p_md.md_pcb->pcb_onfault;
				return;
			}
			map = &p->p_vmspace->vm_map;
			pmap = map->pmap;
		}
	}

	/* Lookup page table. if entry found, load it. */
	if (track && __pmap_pte_load(pmap, va, track)) {
		if (usermode)
			userret(p);
		return;
	}

	err = uvm_fault(map, va, 0, ftype);

	/* User stack extension */
	if (map != kernel_map &&
	    va >= (vaddr_t)p->p_vmspace->vm_maxsaddr) {
		if (err == 0)
			uvm_grow(p, va);
		else if (err == EACCES)
			err = EFAULT;
	}

	/* Page in. load PTE to TLB. */
	if (err == 0) {
		int loaded = __pmap_pte_load(pmap, va, track);
		TLB_ASSERT(loaded, "page table entry not found");
		if (usermode)
			userret(p);
		return;
	}

	/* Page not found. */
	if (usermode) {
		sv.sival_ptr = (void *)va;
		if (err == ENOMEM) {
			printf("UVM: pid %d (%s), uid %d killed: out of swap\n",
			    p->p_p->ps_pid, p->p_p->ps_comm,
			    p->p_ucred ? (int)p->p_ucred->cr_uid : -1);
			trapsignal(p, SIGKILL, tf->tf_expevt, SEGV_MAPERR, sv);
		} else
			trapsignal(p, SIGSEGV, tf->tf_expevt, SEGV_MAPERR, sv);
		goto user_fault;
	} else {
		TLB_ASSERT(p->p_md.md_pcb->pcb_onfault,
		    "no copyin/out fault handler (page not found)");
		tf->tf_spc = (int)p->p_md.md_pcb->pcb_onfault;
	}
	return;

user_fault:
	userret(p);
	ast(p, tf);
	return;

tlb_panic:
	panic("tlb_exception: %s\n"
	      "expevt=%x va=%08x ssr=%08x spc=%08x proc=%p onfault=%p",
	      panic_msg, tf->tf_expevt, va, tf->tf_ssr, tf->tf_spc,
	      p, p ? p->p_md.md_pcb->pcb_onfault : NULL);
#undef	TLB_ASSERT
}


/*
 * void ast(struct proc *p, struct trapframe *tf):
 *	p  ... curproc when exception occured.
 *	tf ... full user context.
 *	This is called upon exception return. if return from kernel to user,
 *	handle asynchronous software traps and context switch if needed.
 */
void
ast(struct proc *p, struct trapframe *tf)
{
	if (KERNELMODE(tf->tf_ssr))
		return;
	KDASSERT(p != NULL);
	KDASSERT(p->p_md.md_regs == tf);

	while (p->p_md.md_astpending) {
		p->p_md.md_astpending = 0;
		refreshcreds(p);
		uvmexp.softs++;
		mi_ast(p, want_resched);
		userret(p);
	}
}

void
cachectl(struct proc *p, struct trapframe *tf)
{
	vaddr_t va;
	vsize_t len;

	if (!SH_HAS_UNIFIED_CACHE) {
		va = (vaddr_t)tf->tf_r4;
		len = (vsize_t)tf->tf_r5;

		if (va < VM_MIN_ADDRESS || va >= VM_MAXUSER_ADDRESS ||
		    va + len <= va || va + len >= VM_MAXUSER_ADDRESS)
			len = 0;

		if (len != 0)
			sh_icache_sync_range_index(va, len);
	}

	userret(p);
}

void
syscall(struct proc *p, struct trapframe *tf)
{
	caddr_t params;
	const struct sysent *callp;
	int error, opc, nsys;
	size_t argsize;
	register_t code, args[8], rval[2], ocode;

	uvmexp.syscalls++;

	opc = tf->tf_spc;
	ocode = code = tf->tf_r0;

	nsys = p->p_p->ps_emul->e_nsysent;
	callp = p->p_p->ps_emul->e_sysent;

	params = (caddr_t)tf->tf_r15;

	switch (code) {
	case SYS_syscall:
		/*
		 * Code is first argument, followed by actual args.
		 */
	        code = tf->tf_r4;
		break;
	case SYS___syscall:
		/*
		 * Like syscall, but code is a quad, so as to maintain
		 * quad alignment for the rest of the arguments.
		 */
		if (callp != sysent)
			break;
#if _BYTE_ORDER == BIG_ENDIAN
		code = tf->tf_r5;
#else
		code = tf->tf_r4;
#endif
		break;
	default:
		break;
	}
	if (code < 0 || code >= nsys)
		callp += p->p_p->ps_emul->e_nosys;		/* illegal */
	else
		callp += code;
	argsize = callp->sy_argsize;
#ifdef DIAGNOSTIC
	if (argsize > sizeof args) {
		callp += p->p_p->ps_emul->e_nosys - code;
		argsize = callp->sy_argsize;
	}
#endif

	switch (ocode) {
	case SYS_syscall:
		if (argsize) {
			args[0] = tf->tf_r5;
			args[1] = tf->tf_r6;
			args[2] = tf->tf_r7;
			if (argsize > 3 * sizeof(int)) {
				argsize -= 3 * sizeof(int);
				if ((error = copyin(params, &args[3],
				    argsize)))
					goto bad;
			}
		}
		break;
	case SYS___syscall:
		if (argsize) {
			args[0] = tf->tf_r6;
			args[1] = tf->tf_r7;
			if (argsize > 2 * sizeof(int)) {
				argsize -= 2 * sizeof(int);
				if ((error = copyin(params, &args[2],
				    argsize)))
					goto bad;
			}
		}
		break;
	default:
		if (argsize) {
			args[0] = tf->tf_r4;
			args[1] = tf->tf_r5;
			args[2] = tf->tf_r6;
			args[3] = tf->tf_r7;
			if (argsize > 4 * sizeof(int)) {
				argsize -= 4 * sizeof(int);
				if ((error = copyin(params, &args[4],
				    argsize)))
					goto bad;
			}
		}
		break;
	}

	rval[0] = 0;
	rval[1] = tf->tf_r1;

	error = mi_syscall(p, code, callp, args, rval);

	switch (error) {
	case 0:
		tf->tf_r0 = rval[0];
		tf->tf_r1 = rval[1];
		tf->tf_ssr |= PSL_TBIT;	/* T bit */
		break;
	case ERESTART:
		/* 2 = TRAPA instruction size */
		tf->tf_spc = opc - 2;
		break;
	case EJUSTRETURN:
		/* nothing to do */
		break;
	default:
	bad:
		tf->tf_r0 = error;
		tf->tf_ssr &= ~PSL_TBIT;	/* T bit */
		break;
	}

	mi_syscall_return(p, code, error, rval);
}

/*
 * void child_return(void *arg):
 *
 *	uvm_fork sets this routine to proc_trampoline's service function.
 *	when returning from here, jump to userland.
 */
void
child_return(void *arg)
{
	struct proc *p = arg;
	struct trapframe *tf = p->p_md.md_regs;

	tf->tf_r0 = 0;
	tf->tf_ssr |= PSL_TBIT; /* This indicates no error. */

	mi_child_return(p);
}

@


1.36
log
@Various printf claim to report the PID, so actually report that and not the TID

Build testing assistance from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.35 2016/02/27 13:08:07 mpi Exp $	*/
d440 1
a440 1
			    p->p_p->ps_pid, p->p_comm,
@


1.35
log
@Rename kdb_trap() into db_ktrap().

The goal is to include it in the list of functions that must not be
instrumented.  All ddb(8) functions should be in this list and have
their names start with 'db_'.

ok visa@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.34 2015/09/10 17:32:19 miod Exp $	*/
d440 1
a440 1
			    p->p_pid, p->p_comm,
@


1.34
log
@Fix error value in ktrace syscall records. ok deraadt@@ dlg@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.33 2015/02/09 09:32:53 miod Exp $	*/
d181 1
a181 1
		if (kdb_trap(EXPEVT_BREAK, 0, tf))
d192 1
a192 1
		    kdb_trap(expevt, tra, tf))
@


1.33
log
@No need to check for va < USRSTACK before invoking uvm_grow() on behalf of
a userland map.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.32 2014/11/16 12:30:58 deraadt Exp $	*/
d517 1
a517 1
	int error, oerror, opc, nsys;
d613 1
a613 1
	switch (oerror = error) {
d633 1
a633 1
	mi_syscall_return(p, code, oerror, rval);
@


1.32
log
@Replace a plethora of historical protection options with just
PROT_NONE, PROT_READ, PROT_WRITE, and PROT_EXEC from mman.h.
PROT_MASK is introduced as the one true way of extracting those bits.
Remove UVM_ADV_* wrapper, using the standard names.
ok doug guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.31 2014/10/13 04:47:22 miod Exp $	*/
d419 1
a419 2
	    (va >= (vaddr_t)p->p_vmspace->vm_maxsaddr) &&
	    (va < USRSTACK)) {
@


1.31
log
@Let this compile without option DDB.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.30 2014/07/10 14:21:20 deraadt Exp $	*/
d353 1
a353 1
		ftype = VM_PROT_READ;
d357 1
a357 1
		ftype = VM_PROT_WRITE;
d361 1
a361 1
		ftype = VM_PROT_WRITE;
d379 1
a379 1
		ftype = VM_PROT_WRITE;
@


1.30
log
@remove most of the boolean_t infection outside uvm/ddb/pmap; ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.29 2014/05/11 00:12:44 guenther Exp $	*/
d180 1
d184 1
d188 1
d195 1
@


1.29
log
@Move the increment of uvmexp.softs back to the caller of mi_ast():
it needs to be done atomicly on some MP archs and we don't have
atomic_add_int() everywhere yet.  Also, mi_ast() was meant to be inline.

noted by miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.28 2014/05/10 16:56:23 deraadt Exp $	*/
d159 1
a159 1
	boolean_t usermode = !KERNELMODE(tf->tf_ssr);
d318 1
a318 1
	boolean_t usermode;
d425 1
a425 1
		boolean_t loaded = __pmap_pte_load(pmap, va, track);
@


1.28
log
@bring things syscall_mi.h needs into scope earlier
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.27 2014/05/10 05:33:00 guenther Exp $	*/
d482 1
@


1.27
log
@Factor out the common ast bits into mi_ast()

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.26 2014/05/08 21:43:04 miod Exp $	*/
d91 1
a93 2

#include <uvm/uvm_extern.h>
@


1.26
log
@Format string fixes and removal of -Wno-format for landisk kernels
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.25 2014/04/18 11:51:17 guenther Exp $	*/
a481 2
		uvmexp.softs++;

d483 1
a483 9
		if (p->p_flag & P_OWEUPC) {
			ADDUPROF(p);
		}

		if (want_resched) {
			/* We are being preempted. */
			preempt(NULL);
		}

@


1.25
log
@Have each thread keeps its own (counted!) reference to the process's ucreds
to avoid possible use-after-free references when swapping ids in threaded
processes.  "Do I have the right creds?" checks are always made with the
threads creds.

Inspired by FreeBSD and NetBSD
"right time" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.24 2014/03/30 21:54:49 guenther Exp $	*/
d299 1
a299 1
	printf("va %p spc %p ssr %p pr %p \n",
@


1.24
log
@Eliminates struct pcred by moving the real and saved ugids into
struct ucred; struct process then directly links to the ucred

Based on a discussion at c2k10 or so before noting that FreeBSD and
NetBSD did this too.

ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.23 2014/03/29 18:09:30 guenther Exp $	*/
d176 1
d340 1
d484 1
@


1.23
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.22 2014/03/26 05:23:42 guenther Exp $	*/
d437 1
a437 2
			    p->p_cred && p->p_ucred ?
				(int)p->p_ucred->cr_uid : -1);
@


1.22
log
@Move p_emul and p_sigcode from proc to process.
Tweak the handling of ktrace EMUL when changing ktracing: only
generate one per process (not one per thread) and pass the correct
proc pointer down to the VFS layer.  Permit generating of NAMI and
CSW records inside ktrace(2) itself.

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.21 2012/12/31 06:46:14 guenther Exp $	*/
d260 1
a260 1
		__asm__ __volatile__ ("sts fpscr, %0" : "=r" (fpscr));
@


1.21
log
@Remove emulation errno mapping code from platforms that no longer have
non-native emulations.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.20 2012/08/07 05:16:54 guenther Exp $	*/
d531 2
a532 2
	nsys = p->p_emul->e_nsysent;
	callp = p->p_emul->e_sysent;
d560 1
a560 1
		callp += p->p_emul->e_nosys;		/* illegal */
d566 1
a566 1
		callp += p->p_emul->e_nosys - code;
@


1.20
log
@Move the common bits of syscall invocation and return handling into
an MI file, <sys/syscall_mi.h>, correcting inconsistencies and the
handling when copyin() of arguments fails.

Tested on i386, amd64, sparc64, and alpha (thanks naddy@@)
Any issues with other platforms will be fixed in tree.

header name from millert@@; ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.19 2012/04/11 14:38:55 mikeb Exp $	*/
a632 2
		if (p->p_emul->e_errno)
			error = p->p_emul->e_errno[error];
@


1.19
log
@The first ktrace record for a newly spawned thread is a return
from a fork syscall done by the parent.  Use __tfork, not rfork
here to match the ktrace records for the parent (CALL __tfork,
RET __tfork).  ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.18 2011/11/16 20:50:19 deraadt Exp $	*/
d92 1
a92 9

#ifdef KTRACE
#include <sys/ktrace.h>
#endif

#include "systrace.h"
#if NSYSTRACE > 0
#include <dev/systrace.h>
#endif
d579 5
a583 6
				error = copyin(params, (caddr_t)&args[3],
					       argsize);
			} else
				error = 0;
		} else
			error = 0;
d591 5
a595 6
				error = copyin(params, (caddr_t)&args[2],
					       argsize);
			} else
				error = 0;
		} else
			error = 0;
d605 5
a609 6
				error = copyin(params, (caddr_t)&args[4],
					       argsize);
			} else
				error = 0;
		} else
			error = 0;
a612 11
#ifdef SYSCALL_DEBUG
	scdebug_call(p, code, args);
#endif
#ifdef KTRACE
	if (KTRPOINT(p, KTR_SYSCALL))
		ktrsyscall(p, code, callp->sy_argsize, args);
#endif

	if (error != 0)
		goto bad;

a614 6
#if NSYSTRACE > 0
	if (ISSET(p->p_flag, P_SYSTRACE))
		error = systrace_redirect(code, p, args, rval);
	else
#endif
		error = (*callp->sy_call)(p, args, rval);
d616 2
a617 1
bad:
d632 1
d640 1
a640 8
#ifdef SYSCALL_DEBUG
	scdebug_ret(p, code, oerror, rval);
#endif
	userret(p);
#ifdef KTRACE
	if (KTRPOINT(p, KTR_SYSRET))
		ktrsysret(p, code, oerror, rval[0]);
#endif
d658 1
a658 9
	userret(p);

#ifdef KTRACE
	if (KTRPOINT(p, KTR_SYSRET))
		ktrsysret(p,
		    (p->p_flag & P_THREAD) ? SYS___tfork :
		    (p->p_p->ps_flags & PS_PPWAIT) ? SYS_vfork : SYS_fork,
		    0, 0);
#endif
@


1.18
log
@Make userret() MI.  On architectures which jammed stuff into it in the
past, pull that code out seperately.
ok guenther miod
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.17 2011/04/03 14:56:28 guenther Exp $	*/
d696 1
a696 1
		    (p->p_flag & P_THREAD) ? SYS_rfork :
@


1.17
log
@Move PPWAIT flag from struct proc to process, so that rthreads in
a vforked child behave correctly.  Have the parent in a vfork()
wait on a (different) flag in *its* process instead of the child
to prevent a possible use-after-free.  When ktracing the child
return from a fork, call it rfork if an rthread was created.

ok blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.16 2010/06/27 12:41:23 miod Exp $	*/
d90 1
a108 1
#include <sh/userret.h>
d488 1
a489 1
		p->p_md.md_astpending = 0;
@


1.16
log
@Bunch of include adjustements to restore compilability.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.15 2010/06/26 23:24:44 guenther Exp $	*/
d696 3
a698 1
		    (p->p_flag & P_PPWAIT) ? SYS_vfork : SYS_fork, 0, 0);
@


1.15
log
@Don't #include <sys/user.h> into files that don't need the stuff
it defines.  In some cases, this means pulling in uvm.h or pcb.h
instead, but most of the inclusions were just noise.  Tested on
alpha, amd64, armish, hppa, i386, macpcc, sgi, sparc64, and vax,
mostly by krw and naddy.
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.14 2008/10/04 19:21:50 miod Exp $	*/
d89 1
@


1.14
log
@Fix potentially uninitialized variables in syscall().
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.13 2008/06/24 21:24:03 deraadt Exp $	*/
a86 1
#include <sys/user.h>
d105 1
@


1.13
log
@On user/kernel shared page table machines, do not let processes map their
own page 0, as discussed with miod (and many others previously, including
art and toby).  On sparc, make this __LDPGSZ because PAGE_SIZE is non-constant
ok miod tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.12 2007/03/15 10:22:29 art Exp $	*/
d574 1
a574 1
		goto bad;
a622 3
	if (error)
		goto bad;

d631 3
d643 1
a657 1
bad:
@


1.12
log
@Since p_flag is often manipulated in interrupts and without biglock
it's a good idea to use atomic.h operations on it. This mechanic
change updates all bit operations on p_flag to atomic_{set,clear}bits_int.

Only exception is that P_OWEUPC is set by MI code before calling
need_proftick and it's automatically cleared by ADDUPC. There's
no reason for MD handling of that flag since everyone handles it the
same way.

kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.11 2007/03/13 19:29:33 miod Exp $	*/
d513 1
a513 1
		if (/* va < VM_MIN_ADDRESS || */ va >= VM_MAXUSER_ADDRESS ||
@


1.11
log
@It is safe to run tlb_exception() at the pre-fault ipl.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.10 2007/03/05 21:47:30 miod Exp $	*/
a490 1
			p->p_flag &= ~P_OWEUPC;
@


1.10
log
@Lower the ipl to what it was at the time of the trap in general_exception,
instead of remaining at splhigh; from NetBSD

ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.9 2007/03/02 06:11:54 miod Exp $	*/
d166 1
a166 1
	int tra, s;
d174 1
a174 1
	 * level to what it was when the trap occureh.
d176 1
a176 2
	s = tf->tf_ssr & PSL_IMASK;
	splx(s);
d337 5
@


1.9
log
@Move landisk to hardware floating point. At the moment the FPU context is
always saved upon context switches, as FPU registers are heavily used for
long long computations (don't ask). Gcc default to -m4.

Credits to drahn@@ otto@@ and deraadt@@ for feedback and help testing.

Upgrade procedure if you don't want to use the damn snapshots:
- build and install new kernel, reboot off it
- build new gcc, do not install it yet
- make includes
- install new gcc
- build and install lib/csu and lib/libc
- make build
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.8 2007/02/06 23:14:11 miod Exp $	*/
d166 1
a166 1
	int tra;
d171 7
@


1.8
log
@Define trap #0x81 for cache range flush, will be necessary soon for gcc
trampoline code and ld.so.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.7 2007/02/06 23:12:01 miod Exp $	*/
d299 2
a300 1
	printf(" spc %x ssr %x pr %x \n", tf->tf_spc, tf->tf_ssr, tf->tf_pr);
a402 9
		return;
	}

	/* Page not found. call fault handler */
	if (!usermode && pmap != pmap_kernel() &&
	    p->p_md.md_pcb->pcb_faultbail) {
		TLB_ASSERT(p->p_md.md_pcb->pcb_onfault != NULL,
		    "no copyin/out fault handler (interrupt context)");
		tf->tf_spc = (int)p->p_md.md_pcb->pcb_onfault;
@


1.7
log
@Use uvm_grow() instead of rolling our own inline version.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.6 2006/11/05 18:57:22 miod Exp $	*/
d103 1
d154 1
d208 3
d499 21
@


1.6
log
@Some basic fpu trap handling.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.5 2006/11/03 17:52:27 drahn Exp $	*/
d415 3
a417 7
		if (err == 0) {
			struct vmspace *vm = p->p_vmspace;
			uint32_t nss;
			nss = btoc(USRSTACK - va);
			if (nss > vm->vm_ssize)
				vm->vm_ssize = nss;
		} else if (err == EACCES) {
a418 1
		}
@


1.5
log
@Return address is way too useful to not print here.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.4 2006/11/03 02:52:02 mickey Exp $	*/
d107 3
d116 30
a145 16
	"--",					/* 0x000 (reset vector) */
	"--",					/* 0x020 (reset vector) */
	"TLB miss/invalid (load)",		/* 0x040 EXPEVT_TLB_MISS_LD */
	"TLB miss/invalid (store)",		/* 0x060 EXPEVT_TLB_MISS_ST */
	"initial page write",			/* 0x080 EXPEVT_TLB_MOD */
	"TLB protection violation (load)",	/* 0x0a0 EXPEVT_TLB_PROT_LD */
	"TLB protection violation (store)",	/* 0x0c0 EXPEVT_TLB_PROT_ST */
	"address error (load)",			/* 0x0e0 EXPEVT_ADDR_ERR_LD */
	"address error (store)",		/* 0x100 EXPEVT_ADDR_ERR_ST */
	"FPU",					/* 0x120 EXPEVT_FPU */
	"--",					/* 0x140 (reset vector) */
	"unconditional trap (TRAPA)",		/* 0x160 EXPEVT_TRAPA */
	"reserved instruction code exception",	/* 0x180 EXPEVT_RES_INST */
	"illegal slot instruction exception",	/* 0x1a0 EXPEVT_SLOT_INST */
	"--",					/* 0x1c0 (external interrupt) */
	"user break point trap",		/* 0x1e0 EXPEVT_BREAK */
d244 34
d289 1
a289 1
	if ((expevt >> 5) < exp_types)
@


1.4
log
@step and stuff works in ddb now too
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.3 2006/10/23 19:56:53 miod Exp $	*/
d243 1
a243 1
	printf(" spc %x ssr %x \n", tf->tf_spc, tf->tf_ssr);
@


1.3
log
@Do not panic on a ddb invocation with curproc == NULL, and don't try to
userret() either on return.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.2 2006/10/17 03:33:39 drahn Exp $	*/
d161 6
d170 4
a173 3
		if (tra == (_SH_TRA_BREAK << 2)) {
			kdb_trap(expevt, tra, tf);
		} else
@


1.2
log
@Dont clobber tf->tf_spc, we might want to print it in do_panic.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.1.1.1 2006/10/06 21:02:55 miod Exp $	*/
a152 3
	if (p == NULL)
 		goto do_panic;

d154 2
a165 1
			goto out;
d168 1
d192 2
a193 2
		KDASSERT(p->p_md.md_pcb->pcb_onfault != NULL);
		if (p->p_md.md_pcb->pcb_onfault == 0)
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d194 2
a196 2
		if (tf->tf_spc == 0)
			goto do_panic;
@


1.1.1.1
log
@Preliminary bits for SuperH-based ports, based on NetBSD/sh3 codebase with
minor changes.
@
text
@@
