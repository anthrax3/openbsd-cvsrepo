head	1.46;
access;
symbols
	OPENBSD_6_1:1.46.0.6
	OPENBSD_6_1_BASE:1.46
	OPENBSD_6_0:1.46.0.2
	OPENBSD_6_0_BASE:1.46
	OPENBSD_5_9:1.41.0.2
	OPENBSD_5_9_BASE:1.41
	OPENBSD_5_8:1.40.0.4
	OPENBSD_5_8_BASE:1.40
	OPENBSD_5_7:1.38.0.2
	OPENBSD_5_7_BASE:1.38
	OPENBSD_5_6:1.37.0.4
	OPENBSD_5_6_BASE:1.37
	OPENBSD_5_5:1.34.0.6
	OPENBSD_5_5_BASE:1.34
	OPENBSD_5_4:1.34.0.2
	OPENBSD_5_4_BASE:1.34
	OPENBSD_5_3:1.33.0.2
	OPENBSD_5_3_BASE:1.33
	OPENBSD_5_2:1.32.0.2
	OPENBSD_5_2_BASE:1.32
	OPENBSD_5_1_BASE:1.31
	OPENBSD_5_1:1.31.0.4
	OPENBSD_5_0:1.31.0.2
	OPENBSD_5_0_BASE:1.31
	OPENBSD_4_9:1.27.0.6
	OPENBSD_4_9_BASE:1.27
	OPENBSD_4_8:1.27.0.4
	OPENBSD_4_8_BASE:1.27
	OPENBSD_4_7:1.27.0.2
	OPENBSD_4_7_BASE:1.27
	OPENBSD_4_6:1.23.0.6
	OPENBSD_4_6_BASE:1.23
	OPENBSD_4_5:1.23.0.2
	OPENBSD_4_5_BASE:1.23
	OPENBSD_4_4:1.20.0.2
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.17.0.2
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.16.0.2
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.10.0.2
	OPENBSD_4_1_BASE:1.10
	SH_20061006:1.1.1.1
	miod:1.1.1;
locks; strict;
comment	@ * @;


1.46
date	2016.05.21.00.56.44;	author deraadt;	state Exp;
branches;
next	1.45;
commitid	oWpLaBOdDMvIxei3;

1.45
date	2016.05.18.20.21.13;	author guenther;	state Exp;
branches;
next	1.44;
commitid	vF64iVVN9U3wxSNG;

1.44
date	2016.05.11.22.33.11;	author deraadt;	state Exp;
branches;
next	1.43;
commitid	LSLra2GOrNDUJ9zt;

1.43
date	2016.05.10.18.39.47;	author deraadt;	state Exp;
branches;
next	1.42;
commitid	qfOifNidEGDB2jL1;

1.42
date	2016.03.05.17.16.33;	author tobiasu;	state Exp;
branches;
next	1.41;
commitid	tnf9BWAlxRCsKh8M;

1.41
date	2015.10.21.07.59.18;	author mpi;	state Exp;
branches;
next	1.40;
commitid	XglPgGQ8qaiL0M4l;

1.40
date	2015.05.15.23.20.25;	author deraadt;	state Exp;
branches;
next	1.39;
commitid	6OLhnSuYWHeAVJb9;

1.39
date	2015.05.05.02.13.47;	author guenther;	state Exp;
branches;
next	1.38;
commitid	dNPv28CJI5BxtRGW;

1.38
date	2015.01.20.19.43.21;	author kettenis;	state Exp;
branches;
next	1.37;
commitid	Fn841MmVYz2JHvBP;

1.37
date	2014.05.08.21.43.04;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2014.03.26.05.23.42;	author guenther;	state Exp;
branches;
next	1.35;

1.35
date	2014.03.22.06.05.45;	author guenther;	state Exp;
branches;
next	1.34;

1.34
date	2013.06.11.16.42.10;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2012.12.02.07.03.31;	author guenther;	state Exp;
branches;
next	1.32;

1.32
date	2012.04.13.18.09.01;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2011.07.05.04.48.01;	author guenther;	state Exp;
branches;
next	1.30;

1.30
date	2011.06.05.19.41.10;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2011.04.18.21.44.55;	author guenther;	state Exp;
branches;
next	1.28;

1.28
date	2011.04.15.04.52.40;	author guenther;	state Exp;
branches;
next	1.27;

1.27
date	2009.11.17.17.06.44;	author kettenis;	state Exp;
branches;
next	1.26;

1.26
date	2009.08.11.19.17.17;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2009.08.11.18.46.32;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2009.08.09.21.13.12;	author blambert;	state Exp;
branches;
next	1.23;

1.23
date	2009.02.04.17.19.17;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2008.12.30.05.33.17;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2008.08.24.03.13.12;	author jsg;	state Exp;
branches;
next	1.20;

1.20
date	2008.06.27.17.22.15;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2008.06.26.05.42.13;	author ray;	state Exp;
branches;
next	1.18;

1.18
date	2008.05.04.21.18.00;	author martin;	state Exp;
branches;
next	1.17;

1.17
date	2007.10.10.15.53.52;	author art;	state Exp;
branches;
next	1.16;

1.16
date	2007.06.06.17.15.12;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2007.05.29.20.36.48;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2007.05.27.17.31.57;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2007.05.26.20.26.51;	author pedro;	state Exp;
branches;
next	1.12;

1.12
date	2007.04.29.17.53.37;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2007.03.13.19.30.38;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2007.03.03.21.37.27;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2007.03.02.06.11.54;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2007.02.26.21.30.18;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2007.01.15.22.22.19;	author martin;	state Exp;
branches;
next	1.6;

1.6
date	2006.11.09.00.12.12;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2006.11.08.10.53.58;	author otto;	state Exp;
branches;
next	1.4;

1.4
date	2006.10.07.20.52.40;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2006.10.06.23.15.12;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	2006.10.06.21.16.57;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	2006.10.06.21.02.55;	author miod;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.10.06.21.02.55;	author miod;	state Exp;
branches;
next	;


desc
@@


1.46
log
@hand-massage sendsig() and sys_sigreturn() to be much more similar.
ok guenther kettenis
@
text
@/*	$OpenBSD: sh_machdep.c,v 1.45 2016/05/18 20:21:13 guenther Exp $	*/
/*	$NetBSD: sh3_machdep.c,v 1.59 2006/03/04 01:13:36 uwe Exp $	*/

/*
 * Copyright (c) 2007 Miodrag Vallat.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice, this permission notice, and the disclaimer below
 * appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
/*-
 * Copyright (c) 1996, 1997, 1998, 2002 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Charles M. Hannum and by Jason R. Thorpe of the Numerical Aerospace
 * Simulation Facility, NASA Ames Research Center.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
/*-
 * Copyright (c) 1982, 1987, 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * William Jolitz.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)machdep.c	7.4 (Berkeley) 6/3/91
 */

#include <sys/param.h>
#include <sys/systm.h>

#include <sys/buf.h>
#include <sys/exec.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/mount.h>
#include <sys/proc.h>
#include <sys/signalvar.h>
#include <sys/syscallargs.h>
#include <sys/user.h>
#include <sys/sched.h>
#include <sys/msg.h>
#include <sys/conf.h>
#include <sys/kcore.h>
#include <sys/reboot.h>

#include <uvm/uvm_extern.h>

#include <dev/cons.h>

#include <sh/cache.h>
#include <sh/clock.h>
#include <sh/fpu.h>
#include <sh/locore.h>
#include <sh/mmu.h>
#include <sh/trap.h>
#include <sh/intr.h>
#include <sh/kcore.h>

/* Our exported CPU info; we can have only one. */
int cpu_arch;
int cpu_product;
char cpu_model[120];

struct vm_map *exec_map;
struct vm_map *phys_map;

int physmem;
struct user *proc0paddr;	/* init_main.c use this. */
struct pcb *curpcb;
struct md_upte *curupte;	/* SH3 wired u-area hack */

#define	VBR	(u_int8_t *)SH3_PHYS_TO_P1SEG(IOM_RAM_BEGIN)
vaddr_t ram_start = SH3_PHYS_TO_P1SEG(IOM_RAM_BEGIN);
/* exception handler holder (sh/sh/vectors.S) */
extern char sh_vector_generic[], sh_vector_generic_end[];
extern char sh_vector_interrupt[], sh_vector_interrupt_end[];
#ifdef SH3
extern char sh3_vector_tlbmiss[], sh3_vector_tlbmiss_end[];
#endif
#ifdef SH4
extern char sh4_vector_tlbmiss[], sh4_vector_tlbmiss_end[];
#endif

/*
 * These variables are needed by /sbin/savecore
 */
u_long dumpmag = 0x8fca0101;	/* magic number */
u_int dumpsize;			/* pages */
long dumplo;	 		/* blocks */
cpu_kcore_hdr_t cpu_kcore_hdr;

void
sh_cpu_init(int arch, int product)
{
	/* CPU type */
	cpu_arch = arch;
	cpu_product = product;

#if defined(SH3) && defined(SH4)
	/* Set register addresses */
	sh_devreg_init();
#endif
	/* Cache access ops. */
	sh_cache_init();

	/* MMU access ops. */
	sh_mmu_init();

	/* Hardclock, RTC initialize. */
	machine_clock_init();

	/* ICU initiailze. */
	intc_init();

	/* Exception vector. */
	memcpy(VBR + 0x100, sh_vector_generic,
	    sh_vector_generic_end - sh_vector_generic);
#ifdef SH3
	if (CPU_IS_SH3)
		memcpy(VBR + 0x400, sh3_vector_tlbmiss,
		    sh3_vector_tlbmiss_end - sh3_vector_tlbmiss);
#endif
#ifdef SH4
	if (CPU_IS_SH4)
		memcpy(VBR + 0x400, sh4_vector_tlbmiss,
		    sh4_vector_tlbmiss_end - sh4_vector_tlbmiss);
#endif
	memcpy(VBR + 0x600, sh_vector_interrupt,
	    sh_vector_interrupt_end - sh_vector_interrupt);

	if (!SH_HAS_UNIFIED_CACHE)
		sh_icache_sync_all();

	__asm volatile("ldc %0, vbr" :: "r"(VBR));

	/* kernel stack setup */
	__sh_switch_resume = CPU_IS_SH3 ? sh3_switch_resume : sh4_switch_resume;

	/* Set page size (4KB) */
	uvm_setpagesize();
}

/*
 * void sh_proc0_init(void):
 *	Setup proc0 u-area.
 */
void
sh_proc0_init(void)
{
	struct switchframe *sf;
	vaddr_t u;

	/* Steal process0 u-area */
	u = uvm_pageboot_alloc(USPACE);
	memset((void *)u, 0, USPACE);

	/* Setup proc0 */
	proc0paddr = (struct user *)u;
	proc0.p_addr = proc0paddr;
	/*
	 * u-area map:
	 * |user| .... | .................. |
	 * | PAGE_SIZE | USPACE - PAGE_SIZE |
         *        frame top        stack top
	 * current frame ... r6_bank
	 * stack top     ... r7_bank
	 * current stack ... r15
	 */
	curpcb = proc0.p_md.md_pcb = &proc0.p_addr->u_pcb;
	curupte = proc0.p_md.md_upte;

	sf = &curpcb->pcb_sf;
	sf->sf_r6_bank = u + PAGE_SIZE;
	sf->sf_r7_bank = sf->sf_r15	= u + USPACE;
	__asm volatile("ldc %0, r6_bank" :: "r"(sf->sf_r6_bank));
	__asm volatile("ldc %0, r7_bank" :: "r"(sf->sf_r7_bank));

	proc0.p_md.md_regs = (struct trapframe *)sf->sf_r6_bank - 1;
#ifdef KSTACK_DEBUG
	memset((char *)(u + sizeof(struct user)), 0x5a,
	    PAGE_SIZE - sizeof(struct user));
	memset((char *)(u + PAGE_SIZE), 0xa5, USPACE - PAGE_SIZE);
#endif /* KSTACK_DEBUG */
}

void
sh_startup(void)
{
	vaddr_t minaddr, maxaddr;

	printf("%s", version);
	if (*cpu_model != '\0')
		printf("%s\n", cpu_model);
#ifdef DEBUG
	printf("general exception handler:\t%d byte\n",
	    sh_vector_generic_end - sh_vector_generic);
	printf("TLB miss exception handler:\t%d byte\n",
#if defined(SH3) && defined(SH4)
	    CPU_IS_SH3 ? sh3_vector_tlbmiss_end - sh3_vector_tlbmiss :
	    sh4_vector_tlbmiss_end - sh4_vector_tlbmiss
#elif defined(SH3)
	    sh3_vector_tlbmiss_end - sh3_vector_tlbmiss
#elif defined(SH4)
	    sh4_vector_tlbmiss_end - sh4_vector_tlbmiss
#endif
	    );
	printf("interrupt exception handler:\t%d byte\n",
	    sh_vector_interrupt_end - sh_vector_interrupt);
#endif /* DEBUG */

	printf("real mem = %lu (%luMB)\n", ptoa(physmem),
	    ptoa(physmem) / 1024 / 1024);

	/*
	 * Allocate a submap for exec arguments.  This map effectively
	 * limits the number of processes exec'ing at any time.
	 */
	minaddr = vm_map_min(kernel_map);
	exec_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
	    16 * NCARGS, VM_MAP_PAGEABLE, FALSE, NULL);

	/*
	 * Allocate a submap for physio
	 */
	phys_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
	    VM_PHYS_SIZE, 0, FALSE, NULL);

	/*
	 * Set up buffers, so they can be used to read disk labels.
	 */
	bufinit();

	printf("avail mem = %lu (%luMB)\n", ptoa(uvmexp.free),
	    ptoa(uvmexp.free) / 1024 / 1024);

	if (boothowto & RB_CONFIG) {
#ifdef BOOT_CONFIG
		user_config();
#else
		printf("kernel does not support -c; continuing..\n");
#endif 
	}
}

void
dumpconf(void)
{
	cpu_kcore_hdr_t *h = &cpu_kcore_hdr;
	u_int dumpextra, totaldumpsize;		/* in disk blocks */
	u_int seg, nblks;

	if (dumpdev == NODEV ||
	    (nblks = (bdevsw[major(dumpdev)].d_psize)(dumpdev)) == 0)
		return;
	if (nblks <= ctod(1))
		return;

	dumpsize = 0;
	for (seg = 0; seg < h->kcore_nsegs; seg++)
		dumpsize += atop(h->kcore_segs[seg].size);
	dumpextra = cpu_dumpsize();

	/* Always skip the first block, in case there is a label there. */
	if (dumplo < btodb(1))
		dumplo = btodb(1);

	/* Put dump at the end of the partition, and make it fit. */
	totaldumpsize = ctod(dumpsize) + dumpextra;
	if (totaldumpsize > nblks - dumplo) {
		totaldumpsize = dbtob(nblks - dumplo);
		dumpsize = dtoc(totaldumpsize - dumpextra);
	}
	if (dumplo < nblks - totaldumpsize)
		dumplo = nblks - totaldumpsize;
}

void
dumpsys(void)
{
	cpu_kcore_hdr_t *h = &cpu_kcore_hdr;
	daddr_t blkno;
	int (*dump)(dev_t, daddr_t, caddr_t, size_t);
	u_int page = 0;
	paddr_t dumppa;
	u_int seg;
	int rc;
	extern int msgbufmapped;

	/* Don't record dump messages in msgbuf. */
	msgbufmapped = 0;

	/* Make sure dump settings are valid. */
	if (dumpdev == NODEV)
		return;
	if (dumpsize == 0) {
		dumpconf();
		if (dumpsize == 0)
			return;
	}
	if (dumplo <= 0) {
		printf("\ndump to dev 0x%x not possible, not enough space\n",
		    dumpdev);
		return;
	}

	dump = bdevsw[major(dumpdev)].d_dump;
	blkno = dumplo;

	printf("\ndumping to dev 0x%x offset %ld\n", dumpdev, dumplo);

	printf("dump ");

	/* Write dump header */
	rc = cpu_dump(dump, &blkno);
	if (rc != 0)
		goto bad;

	for (seg = 0; seg < h->kcore_nsegs; seg++) {
		u_int pagesleft;

		pagesleft = atop(h->kcore_segs[seg].size);
		dumppa = (paddr_t)h->kcore_segs[seg].start;

		while (pagesleft != 0) {
			u_int npages;

#define	NPGMB	atop(1024 * 1024)
			if (page != 0 && (page % NPGMB) == 0)
				printf("%u ", page / NPGMB);

			/* do not dump more than 1MB at once */
			npages = min(pagesleft, NPGMB);
#undef NPGMB
			npages = min(npages, dumpsize);

			rc = (*dump)(dumpdev, blkno,
			    (caddr_t)SH3_PHYS_TO_P2SEG(dumppa), ptoa(npages));
			if (rc != 0)
				goto bad;

			pagesleft -= npages;
			dumppa += ptoa(npages);
			page += npages;
			dumpsize -= npages;
			if (dumpsize == 0)
				goto bad;	/* if truncated dump */
			blkno += ctod(npages);
		}
	}
bad:
	switch (rc) {
	case 0:
		printf("succeeded\n");
		break;
	case ENXIO:
		printf("device bad\n");
		break;
	case EFAULT:
		printf("device not ready\n");
		break;
	case EINVAL:
		printf("area improper\n");
		break;
	case EIO:
		printf("I/O error\n");
		break;
	case EINTR:
		printf("aborted\n");
		break;
	default:
		printf("error %d\n", rc);
		break;
	}

	/* make sure console can output our last message */
	delay(1 * 1000 * 1000);
}

/*
 * Signal frame.
 */
struct sigframe {
#if 0 /* in registers on entry to signal trampoline */
	int		sf_signum;	/* r4 - "signum" argument for handler */
	siginfo_t	*sf_sip;	/* r5 - "sip" argument for handler */
	struct sigcontext *sf_ucp;	/* r6 - "ucp" argument for handler */
#endif
	struct sigcontext sf_uc;	/* actual context */		
	siginfo_t	sf_si;
};

/*
 * Send an interrupt to process.
 */
void
sendsig(sig_t catcher, int sig, int mask, u_long code, int type,
    union sigval val)
{
	struct proc *p = curproc;
	struct sigframe *fp, frame;
	struct trapframe *tf = p->p_md.md_regs;
	struct sigacts *psp = p->p_p->ps_sigacts;
	siginfo_t *sip;

	if ((p->p_sigstk.ss_flags & SS_DISABLE) == 0 &&
	    !sigonstack(p->p_md.md_regs->tf_r15) &&
	    (psp->ps_sigonstack & sigmask(sig)))
		fp = (struct sigframe *)((vaddr_t)p->p_sigstk.ss_sp +
		    p->p_sigstk.ss_size);
	else
		fp = (void *)p->p_md.md_regs->tf_r15;
	--fp;


	bzero(&frame, sizeof(frame));

	if (psp->ps_siginfo & sigmask(sig)) {
		initsiginfo(&frame.sf_si, sig, code, type, val);
		sip = &fp->sf_si;
	} else
		sip = NULL;

	/* Save register context. */
	memcpy(frame.sf_uc.sc_reg, &tf->tf_spc, sizeof(frame.sf_uc.sc_reg));
#ifdef SH4
	if (CPU_IS_SH4)
		fpu_save((struct fpreg *)&frame.sf_uc.sc_fpreg);
#endif

	frame.sf_uc.sc_expevt = tf->tf_expevt;
	/* frame.sf_uc.sc_err = 0; */
	frame.sf_uc.sc_mask = mask;

	frame.sf_uc.sc_cookie = (long)&fp->sf_uc ^ p->p_p->ps_sigcookie;
	if (copyout(&frame, fp, sizeof(frame)) != 0) {
		/*
		 * Process has trashed its stack; give it an illegal
		 * instruction to halt it in its tracks.
		 */
		sigexit(p, SIGILL);
		/* NOTREACHED */
	}

	tf->tf_r4 = sig;		/* "signum" argument for handler */
	tf->tf_r5 = (int)sip;		/* "sip" argument for handler */
	tf->tf_r6 = (int)&fp->sf_uc;	/* "ucp" argument for handler */
 	tf->tf_spc = (int)catcher;
	tf->tf_r15 = (int)fp;
	tf->tf_pr = (int)p->p_p->ps_sigcode;
}

/*
 * System call to cleanup state after a signal
 * has been taken.  Reset signal mask and
 * stack state from context left by sendsig (above).
 * Return to previous pc and psl as specified by
 * context left by sendsig. Check carefully to
 * make sure that the user has not modified the
 * psl to gain improper privileges or to cause
 * a machine fault.
 */
int
sys_sigreturn(struct proc *p, void *v, register_t *retval)
{
	struct sys_sigreturn_args /* {
		syscallarg(struct sigcontext *) sigcntxp;
	} */ *uap = v;
	struct sigcontext ksc, *scp = SCARG(uap, sigcntxp);
	struct trapframe *tf;
	int error;

	if (PROC_PC(p) != p->p_p->ps_sigcoderet) {
		sigexit(p, SIGILL);
		return (EPERM);
	}

	if ((error = copyin(scp, &ksc, sizeof(*scp))) != 0)
		return (error);

	if (ksc.sc_cookie != ((long)scp ^ p->p_p->ps_sigcookie)) {
		sigexit(p, SIGILL);
		return (EFAULT);
	}

	/* Prevent reuse of the sigcontext cookie */
	ksc.sc_cookie = 0;
	(void)copyout(&ksc.sc_cookie, (caddr_t)scp +
	    offsetof(struct sigcontext, sc_cookie), sizeof(ksc.sc_cookie));

	/* Restore signal context. */
	tf = p->p_md.md_regs;

	/* Check for security violations. */
	if (((ksc.sc_reg[1] /* ssr */ ^ tf->tf_ssr) & PSL_USERSTATIC) != 0)
		return (EINVAL);

	memcpy(&tf->tf_spc, ksc.sc_reg, sizeof(ksc.sc_reg));

#ifdef SH4
	if (CPU_IS_SH4)
		fpu_restore((struct fpreg *)&ksc.sc_fpreg);
#endif

	/* Restore signal mask. */
	p->p_sigmask = ksc.sc_mask & ~sigcantmask;

	return (EJUSTRETURN);
}

/*
 * Clear registers on exec
 */
void
setregs(struct proc *p, struct exec_package *pack, u_long stack,
    register_t rval[2])
{
	struct trapframe *tf;
	struct pcb *pcb = p->p_md.md_pcb;

	p->p_md.md_flags &= ~MDP_USEDFPU;

	tf = p->p_md.md_regs;

	tf->tf_gbr = 0;
	tf->tf_macl = 0;
	tf->tf_mach = 0;

	tf->tf_r0 = 0;
	tf->tf_r1 = 0;
	tf->tf_r2 = 0;
	tf->tf_r3 = 0;
	copyin((caddr_t)stack, &tf->tf_r4, sizeof(register_t));	/* argc */
	tf->tf_r5 = stack + 4;			/* argv */
	tf->tf_r6 = stack + 4 * tf->tf_r4 + 8;	/* envp */
	tf->tf_r7 = 0;
	tf->tf_r8 = 0;
	tf->tf_r9 = (int)p->p_p->ps_strings;
	tf->tf_r10 = 0;
	tf->tf_r11 = 0;
	tf->tf_r12 = 0;
	tf->tf_r13 = 0;
	tf->tf_r14 = 0;
	tf->tf_spc = pack->ep_entry;
	tf->tf_ssr = PSL_USERSET;
	tf->tf_r15 = stack;

#ifdef SH4
	if (CPU_IS_SH4) {
		/*
		 * Clear floating point registers.
		 */
		bzero(&pcb->pcb_fp, sizeof(pcb->pcb_fp));
		pcb->pcb_fp.fpr_fpscr = FPSCR_PR;
		fpu_restore(&pcb->pcb_fp);
	}
#endif

	rval[1] = 0;
}

/*
 * Jump to reset vector.
 */
void
cpu_reset(void)
{
	_cpu_exception_suspend();
	_reg_write_4(SH_(EXPEVT), EXPEVT_RESET_MANUAL);

#ifndef __lint__
	goto *(void *)0xa0000000;
#endif
	/* NOTREACHED */
}
@


1.45
log
@Save and restore 'gbr' register when enter/leaving the kernel, and use
it for the TCB pointer.  Eliminate __cerror.

"looks good" kettenis@@, testing and ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sh_machdep.c,v 1.44 2016/05/11 22:33:11 deraadt Exp $	*/
d523 1
a523 1
	struct sigcontext *scp = SCARG(uap, sigcntxp), context;
a527 2
		printf("%s(%d): sigreturn not from sigtramp [pc 0x%x 0x%lx]\n",
		    p->p_comm, p->p_pid, PROC_PC(p), p->p_p->ps_sigcoderet);
d532 1
a532 1
	if ((error = copyin(scp, &context, sizeof(*scp))) != 0)
d535 1
a535 4
	if (context.sc_cookie != ((long)scp ^ p->p_p->ps_sigcookie)) {
		printf("%s(%d): cookie %lx should have been %lx\n",
		    p->p_comm, p->p_pid, context.sc_cookie,
		    (long)scp ^ p->p_p->ps_sigcookie);
d541 3
a543 4
	context.sc_cookie = 0;
	(void)copyout(&context.sc_cookie, (caddr_t)scp +
	    offsetof(struct sigcontext, sc_cookie),
	    sizeof (context.sc_cookie));
d549 1
a549 1
	if (((context.sc_reg[1] /* ssr */ ^ tf->tf_ssr) & PSL_USERSTATIC) != 0)
d552 1
a552 1
	memcpy(&tf->tf_spc, context.sc_reg, sizeof(context.sc_reg));
d556 1
a556 1
		fpu_restore((struct fpreg *)&context.sc_fpreg);
d560 1
a560 1
	p->p_sigmask = context.sc_mask & ~sigcantmask;
@


1.44
log
@delete SROP mitigation debug code; it works
@
text
@d1 1
a1 1
/*	$OpenBSD: sh_machdep.c,v 1.43 2016/05/10 18:39:47 deraadt Exp $	*/
d584 4
@


1.43
log
@SROP mitigation.  sendsig() stores a (per-process ^ &sigcontext) cookie
inside the sigcontext.  sigreturn(2) checks syscall entry was from the
exact PC addr in the (per-process ASLR) sigtramp, verifies the cookie,
and clears it to prevent sigcontext reuse.
not yet tested on landisk, sparc, *88k, socppc.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: sh_machdep.c,v 1.42 2016/03/05 17:16:33 tobiasu Exp $	*/
a489 1
printf("cookie %lx\n", frame.sf_uc.sc_cookie);
@


1.42
log
@Sync no-argument function declaration and definition by adding (void).
Covers all of landisk/sh, per naddy's suggestion.

ok on previous diff deraadt@@ naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sh_machdep.c,v 1.41 2015/10/21 07:59:18 mpi Exp $	*/
d489 2
d524 1
a524 1
	struct sigcontext *scp, context;
d528 8
a535 7
	/*
	 * The trampoline code hands us the context.
	 * It is unsafe to keep track of it ourselves, in the event that a
	 * program jumps out of a signal handler.
	 */
	scp = SCARG(uap, sigcntxp);
	if ((error = copyin((caddr_t)scp, &context, sizeof(*scp))) != 0)
d537 14
@


1.41
log
@Do not call uvm_swap_finicrypt_all() a second time in dumpsys().

ok tedu@@, deraadt@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sh_machdep.c,v 1.40 2015/05/15 23:20:25 deraadt Exp $	*/
d203 1
a203 1
sh_proc0_init()
d242 1
a242 1
sh_startup()
d333 1
a333 1
dumpsys()
d606 1
a606 1
cpu_reset()
@


1.40
log
@still needs kcore.h
@
text
@d1 1
a1 1
/*	$OpenBSD: sh_machdep.c,v 1.39 2015/05/05 02:13:47 guenther Exp $	*/
a101 1
#include <uvm/uvm_swap.h>
a364 4

#ifdef UVM_SWAP_ENCRYPT
	uvm_swap_finicrypt_all();
#endif
@


1.39
log
@emul_native is only used for kernel threads which can't dump core, so
delete coredump_trad(), uvm_coredump(), cpu_coredump(), struct md_coredump,
and various #includes that are superfluous.

This leaves compat_linux processes without a coredump callback.  If that
ability is desired, someone should update it to use coredump_elf32() and
verify the results...

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sh_machdep.c,v 1.38 2015/01/20 19:43:21 kettenis Exp $	*/
d98 1
@


1.38
log
@Move ps_strings "after" the random stackgap.  This makes its location a
per-process value, and therefpore turns the VM_PSSTRINGS sysctl into a
per-process one as well.  This gets rid of a pointer to the bottom of the
stack at a fixed location.  Also clears the road for unmapping the stackgap.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sh_machdep.c,v 1.37 2014/05/08 21:43:04 miod Exp $	*/
a97 2
#include <sys/core.h>
#include <sys/kcore.h>
@


1.37
log
@Format string fixes and removal of -Wno-format for landisk kernels
@
text
@d1 1
a1 1
/*	$OpenBSD: sh_machdep.c,v 1.36 2014/03/26 05:23:42 guenther Exp $	*/
d584 1
a584 1
	tf->tf_r9 = (int)PS_STRINGS;
@


1.36
log
@Move p_emul and p_sigcode from proc to process.
Tweak the handling of ktrace EMUL when changing ktracing: only
generate one per process (not one per thread) and pass the correct
proc pointer down to the VFS layer.  Permit generating of NAMI and
CSW records inside ktrace(2) itself.

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sh_machdep.c,v 1.35 2014/03/22 06:05:45 guenther Exp $	*/
d268 1
a268 1
	printf("real mem = %u (%uMB)\n", ptoa(physmem),
@


1.35
log
@Move p_sigacts from struct proc to struct process.

testing help mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sh_machdep.c,v 1.34 2013/06/11 16:42:10 deraadt Exp $	*/
d509 1
a509 1
	tf->tf_pr = (int)p->p_sigcode;
@


1.34
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: sh_machdep.c,v 1.33 2012/12/02 07:03:31 guenther Exp $	*/
d463 1
a463 1
	struct sigacts *psp = p->p_sigacts;
@


1.33
log
@Determine whether we're currently on the alternative signal stack
dynamically, by comparing the stack pointer against the altstack
base and size, so that you get the correct answer if you longjmp
out of the signal handler, as tested by regress/sys/kern/stackjmp/.
Also, fix alt stack handling on vax, where it was completely broken.

Testing and corrections by miod@@, krw@@, tobiasu@@, pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sh_machdep.c,v 1.32 2012/04/13 18:09:01 miod Exp $	*/
d338 2
a339 2
	daddr64_t blkno;
	int (*dump)(dev_t, daddr64_t, caddr_t, size_t);
@


1.32
log
@Avoid horrible namespace pollution of <machine/signal.h> pulling in
<machine/reg.h> for the needs of struct sigcontext; said struct ought to
only use simple integer types.
Fixes build of groff on landisk.

ok pirofti@@ (who had a similar diff)
@
text
@d1 1
a1 1
/*	$OpenBSD: sh_machdep.c,v 1.31 2011/07/05 04:48:01 guenther Exp $	*/
a464 1
	int onstack;
d466 3
a468 3
	onstack = p->p_sigstk.ss_flags & SS_ONSTACK;
	if ((p->p_sigstk.ss_flags & SS_DISABLE) == 0 && onstack == 0 &&
	    (psp->ps_sigonstack & sigmask(sig))) {
d471 1
a471 2
		p->p_sigstk.ss_flags |= SS_ONSTACK;
	} else
a490 1
	frame.sf_uc.sc_onstack = onstack;
a554 5
	/* Restore signal stack. */
	if (context.sc_onstack)
		p->p_sigstk.ss_flags |= SS_ONSTACK;
	else
		p->p_sigstk.ss_flags &= ~SS_ONSTACK;
@


1.31
log
@Recommit the reverted sigacts change now that the NFS use-after-free
problem has been tracked down.  This fixes the sharing of the signal
handling state: shared bits go in sigacts, per-rthread bits goes in
struct proc.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sh_machdep.c,v 1.30 2011/06/05 19:41:10 deraadt Exp $	*/
d487 1
a487 21
	frame.sf_uc.sc_reg.r_spc = tf->tf_spc;
	frame.sf_uc.sc_reg.r_ssr = tf->tf_ssr;
	frame.sf_uc.sc_reg.r_pr = tf->tf_pr;
	frame.sf_uc.sc_reg.r_mach = tf->tf_mach;
	frame.sf_uc.sc_reg.r_macl = tf->tf_macl;
	frame.sf_uc.sc_reg.r_r15 = tf->tf_r15;
	frame.sf_uc.sc_reg.r_r14 = tf->tf_r14;
	frame.sf_uc.sc_reg.r_r13 = tf->tf_r13;
	frame.sf_uc.sc_reg.r_r12 = tf->tf_r12;
	frame.sf_uc.sc_reg.r_r11 = tf->tf_r11;
	frame.sf_uc.sc_reg.r_r10 = tf->tf_r10;
	frame.sf_uc.sc_reg.r_r9 = tf->tf_r9;
	frame.sf_uc.sc_reg.r_r8 = tf->tf_r8;
	frame.sf_uc.sc_reg.r_r7 = tf->tf_r7;
	frame.sf_uc.sc_reg.r_r6 = tf->tf_r6;
	frame.sf_uc.sc_reg.r_r5 = tf->tf_r5;
	frame.sf_uc.sc_reg.r_r4 = tf->tf_r4;
	frame.sf_uc.sc_reg.r_r3 = tf->tf_r3;
	frame.sf_uc.sc_reg.r_r2 = tf->tf_r2;
	frame.sf_uc.sc_reg.r_r1 = tf->tf_r1;
	frame.sf_uc.sc_reg.r_r0 = tf->tf_r0;
d490 1
a490 1
		fpu_save(&frame.sf_uc.sc_fpreg);
d548 1
a548 1
	if (((context.sc_reg.r_ssr ^ tf->tf_ssr) & PSL_USERSTATIC) != 0)
d551 1
a551 21
	tf->tf_spc = context.sc_reg.r_spc;
	tf->tf_ssr = context.sc_reg.r_ssr;
	tf->tf_macl = context.sc_reg.r_macl;
	tf->tf_mach = context.sc_reg.r_mach;
	tf->tf_pr = context.sc_reg.r_pr;
	tf->tf_r13 = context.sc_reg.r_r13;
	tf->tf_r12 = context.sc_reg.r_r12;
	tf->tf_r11 = context.sc_reg.r_r11;
	tf->tf_r10 = context.sc_reg.r_r10;
	tf->tf_r9 = context.sc_reg.r_r9;
	tf->tf_r8 = context.sc_reg.r_r8;
	tf->tf_r7 = context.sc_reg.r_r7;
	tf->tf_r6 = context.sc_reg.r_r6;
	tf->tf_r5 = context.sc_reg.r_r5;
	tf->tf_r4 = context.sc_reg.r_r4;
	tf->tf_r3 = context.sc_reg.r_r3;
	tf->tf_r2 = context.sc_reg.r_r2;
	tf->tf_r1 = context.sc_reg.r_r1;
	tf->tf_r0 = context.sc_reg.r_r0;
	tf->tf_r15 = context.sc_reg.r_r15;
	tf->tf_r14 = context.sc_reg.r_r14;
d555 1
a555 1
		fpu_restore(&context.sc_fpreg);
@


1.30
log
@Move the bufcachepercent setting code to MI locations -- set it to 42%
for now; that is unlikely to hit some of the remaining starvation bugs.
Repair the bufpages calculation too; i386 was doing it ahead of time
(incorrectly) and then re-calculating it.
ok thib
@
text
@d1 1
a1 1
/*	$OpenBSD: sh_machdep.c,v 1.29 2011/04/18 21:44:55 guenther Exp $	*/
d463 1
a463 1
	struct sigacts *ps = p->p_sigacts;
d467 6
a472 6
	onstack = ps->ps_sigstk.ss_flags & SS_ONSTACK;
	if ((ps->ps_flags & SAS_ALTSTACK) && onstack == 0 &&
	    (ps->ps_sigonstack & sigmask(sig))) {
		fp = (struct sigframe *)((vaddr_t)ps->ps_sigstk.ss_sp +
		    ps->ps_sigstk.ss_size);
		ps->ps_sigstk.ss_flags |= SS_ONSTACK;
d480 1
a480 1
	if (ps->ps_siginfo & sigmask(sig)) {
d600 1
a600 1
		p->p_sigacts->ps_sigstk.ss_flags |= SS_ONSTACK;
d602 1
a602 1
		p->p_sigacts->ps_sigstk.ss_flags &= ~SS_ONSTACK;
@


1.29
log
@Revert the sigacts diff: NFS can apparently retain pointers to processes
until they're zombies and then send them signals (for intr mounts).  Until
that is untangled, the sigacts change is unsafe.  sthen@@ was the victim
for this one
@
text
@d1 1
a1 1
/*	$OpenBSD: sh_machdep.c,v 1.27 2009/11/17 17:06:44 kettenis Exp $	*/
a114 11

#ifndef BUFCACHEPERCENT
#define BUFCACHEPERCENT 5
#endif

#ifdef  BUFPAGES
int	bufpages = BUFPAGES;
#else
int	bufpages = 0;
#endif
int	bufcachepercent = BUFCACHEPERCENT;
@


1.28
log
@Correct the sharing of the signal handling state: stuff that should
be shared (p_sigignore, p_sigcatch, P_NOCLDSTOP, P_NOCLDWAIT) moves
to struct sigacts, wihle stuff that should be per rthread (ps_oldmask,
SAS_OLDMASK, ps_sigstk) moves to struct proc.  Treat the coredumping
state bits (ps_sig, ps_code, ps_type, ps_sigval) as per-rthread
until our locking around coredumping is better.

Oh, and remove the old SunOS-compat ps_usertramp member.

"I like the sound of this" tedu@@
@
text
@d474 1
a474 1
	struct sigacts *psp = p->p_sigacts;
d478 6
a483 6
	onstack = p->p_sigstk.ss_flags & SS_ONSTACK;
	if ((p->p_sigstk.ss_flags & SS_DISABLE) == 0 && onstack == 0 &&
	    (psp->ps_sigonstack & sigmask(sig))) {
		fp = (struct sigframe *)((vaddr_t)p->p_sigstk.ss_sp +
		    p->p_sigstk.ss_size);
		p->p_sigstk.ss_flags |= SS_ONSTACK;
d491 1
a491 1
	if (psp->ps_siginfo & sigmask(sig)) {
d611 1
a611 1
		p->p_sigstk.ss_flags |= SS_ONSTACK;
d613 1
a613 1
		p->p_sigstk.ss_flags &= ~SS_ONSTACK;
@


1.27
log
@Initialize the FPU to be in double precision mode for SH4.  This is what the
Linux kernel does and is obviously what GCC expects.  Fixed segmentation
faults in omalloc_init() for shared executables linked with the pthreads
library.

tested by otto@@, ok deraadt@@, drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sh_machdep.c,v 1.26 2009/08/11 19:17:17 miod Exp $	*/
d474 1
a474 1
	struct sigacts *ps = p->p_sigacts;
d478 6
a483 6
	onstack = ps->ps_sigstk.ss_flags & SS_ONSTACK;
	if ((ps->ps_flags & SAS_ALTSTACK) && onstack == 0 &&
	    (ps->ps_sigonstack & sigmask(sig))) {
		fp = (struct sigframe *)((vaddr_t)ps->ps_sigstk.ss_sp +
		    ps->ps_sigstk.ss_size);
		ps->ps_sigstk.ss_flags |= SS_ONSTACK;
d491 1
a491 1
	if (ps->ps_siginfo & sigmask(sig)) {
d611 1
a611 1
		p->p_sigacts->ps_sigstk.ss_flags |= SS_ONSTACK;
d613 1
a613 1
		p->p_sigacts->ps_sigstk.ss_flags &= ~SS_ONSTACK;
@


1.26
log
@Do not bother initializing bufpages in the md code if the computation is
exactly the same the mi could will use if bufinit() is invoked with
bufpages == 0.
@
text
@d1 1
a1 1
/*	$OpenBSD: sh_machdep.c,v 1.25 2009/08/11 18:46:32 miod Exp $	*/
d109 1
d659 1
@


1.25
log
@With the SysV memory allocation changes, allocsys() doesn't do anything
anymore. Get rid of it completely.
@
text
@d1 1
a1 1
/*	$OpenBSD: sh_machdep.c,v 1.24 2009/08/09 21:13:12 blambert Exp $	*/
a279 13

	/*
	 * Determine how many buffers to allocate.
	 * We allocate bufcachepercent% of memory for buffer space.
	 */
	if (bufpages == 0)
		bufpages = physmem * bufcachepercent / 100;

	/* Restrict to at most 25% filled kvm */
	if (bufpages >
	    (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) / PAGE_SIZE / 4) 
		bufpages = (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) /
		    PAGE_SIZE / 4;
@


1.24
log
@Another lost bit for SysV message queues.
@
text
@d1 1
a1 1
/*	$OpenBSD: sh_machdep.c,v 1.23 2009/02/04 17:19:17 miod Exp $	*/
a150 2
caddr_t allocsys(caddr_t);

a256 2
	caddr_t sysbase;
	caddr_t size;
a281 12
	 * Find out how much space we need, allocate it,
	 * and then give everything true virtual addresses.
	 */
	size = allocsys(NULL);
	sysbase = (caddr_t)uvm_km_zalloc(kernel_map, round_page((vaddr_t)size));
	if (sysbase == 0)
		panic("sh_startup: no room for system tables; %d required",
		    (u_int)size);
	if ((caddr_t)((allocsys(sysbase) - sysbase)) != size)
		panic("cpu_startup: system table size inconsistency");

	/*
a322 17
}

/*
 * Allocate space for system data structures.  We are given
 * a starting virtual address and we return a final virtual
 * address; along the way we set each data structure pointer.
 *
 * We call allocsys() with 0 to find out how much space we want,
 * allocate that much and fill it with zeroes, and then call
 * allocsys() again with the correct base virtual address.
 */
caddr_t
allocsys(caddr_t v)
{
#define	valloc(name, type, num)	v = (caddr_t)(((name) = (type *)v) + (num))

	return v;
@


1.23
log
@Unify memory size reports a bit more: always report size in MB, and report
reserved memory on alpha and hppa on its own line (as done on sgi).
@
text
@d1 1
a1 1
/*	$OpenBSD: sh_machdep.c,v 1.22 2008/12/30 05:33:17 miod Exp $	*/
a353 7

#ifdef SYSVMSG
	valloc(msgpool, char, msginfo.msgmax);
	valloc(msgmaps, struct msgmap, msginfo.msgseg);
	valloc(msghdrs, struct msg, msginfo.msgtql);
	valloc(msqids, struct msqid_ds, msginfo.msgmni);
#endif
@


1.22
log
@savecore(8) wants dumpmag to be an unsigned long.
@
text
@d1 1
a1 1
/*	$OpenBSD: sh_machdep.c,v 1.21 2008/08/24 03:13:12 jsg Exp $	*/
d282 2
a283 1
	printf("real mem = %u (%uK)\n", ptoa(physmem), ptoa(physmem) / 1024);
d329 2
a330 2
	printf("avail mem = %u (%uK)\n", ptoa(uvmexp.free),
	    ptoa(uvmexp.free) / 1024);
@


1.21
log
@surplus semicolon on if statement
@
text
@d1 1
a1 1
/*	$OpenBSD: sh_machdep.c,v 1.20 2008/06/27 17:22:15 miod Exp $	*/
d156 1
a156 1
u_int32_t dumpmag = 0x8fca0101;	/* magic number */
@


1.20
log
@Clear swap encryption keys before dumping a kernel image.
@
text
@d1 1
a1 1
/*	$OpenBSD: sh_machdep.c,v 1.19 2008/06/26 05:42:13 ray Exp $	*/
d383 1
a383 1
	if (dumplo < btodb(1));
@


1.19
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sh_machdep.c,v 1.18 2008/05/04 21:18:00 martin Exp $	*/
d103 1
d429 4
@


1.18
log
@convert to ptoa/atop

tested by maja@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sh_machdep.c,v 1.17 2007/10/10 15:53:52 art Exp $	*/
a35 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.17
log
@Make context switching much more MI:
 - Move the functionality of choosing a process from cpu_switch into
   a much simpler function: cpu_switchto. Instead of having the locore
   code walk the run queues, let the MI code choose the process we
   want to run and only implement the context switching itself in MD
   code.
 - Let MD context switching run without worrying about spls or locks.
 - Instead of having the idle loop implemented with special contexts
   in MD code, implement one idle proc for each cpu. make the idle
   loop MI with MD hooks.
 - Change the proc lists from the old style vax queues to TAILQs.
 - Change the sleep queue from vax queues to TAILQs. This makes
   wakeup() go from O(n^2) to O(n)

there will be some MD fallout, but it will be fixed shortly.
There's also a few cleanups to be done after this.

deraadt@@, kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: sh_machdep.c,v 1.16 2007/06/06 17:15:12 deraadt Exp $	*/
d288 1
a288 1
	printf("real mem = %u (%uK)\n", ctob(physmem), ctob(physmem) / 1024);
@


1.16
log
@now that all partition size/offsets are potentially 64-bit, change the
type of all variables to daddr64_t.  this includes the APIs for XXsize()
and XXdump(), all range checks inside bio drivers, internal variables
for disklabel handling, and even uvm's swap offsets.  re-read numerous
times by otto, miod, krw, thib to look for errors
@
text
@d1 1
a1 1
/*	$OpenBSD: sh_machdep.c,v 1.15 2007/05/29 20:36:48 deraadt Exp $	*/
a716 39
}

void
setrunqueue(struct proc *p)
{
	int whichq = p->p_priority / PPQ;
	struct prochd *q;
	struct proc *prev;

#ifdef DIAGNOSTIC
	if (p->p_back != NULL || p->p_wchan != NULL || p->p_stat != SRUN)
		panic("setrunqueue");
#endif
	q = &qs[whichq];
	prev = q->ph_rlink;
	p->p_forw = (struct proc *)q;
	q->ph_rlink = p;
	prev->p_forw = p;
	p->p_back = prev;
	whichqs |= 1 << whichq;
}

void
remrunqueue(struct proc *p)
{
	struct proc *prev, *next;
	int whichq = p->p_priority / PPQ;

#ifdef DIAGNOSTIC
       if (((whichqs & (1 << whichq)) == 0))
		panic("remrunqueue: bit %d not set", whichq);
#endif
	prev = p->p_back;
	p->p_back = NULL;
	next = p->p_forw;
	prev->p_forw = next;
	next->p_back = prev;
	if (prev == next)
		whichqs &= ~(1 << whichq);
@


1.15
log
@start of dumpconf() unification, which one day we can pray will be MI
(and part of setroot); ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: sh_machdep.c,v 1.14 2007/05/27 17:31:57 miod Exp $	*/
d406 2
a407 2
	daddr_t blkno;
	int (*dump)(dev_t, daddr_t, caddr_t, size_t);
@


1.14
log
@Make sure the minaddr hint for uvm_km_suballoc() calls is always initialized.
ok pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sh_machdep.c,v 1.13 2007/05/26 20:26:51 pedro Exp $	*/
d371 1
a371 1
dumpconf()
a375 1
	int maj;
d377 2
a378 1
	if (dumpdev == NODEV)
d380 1
a380 11

	maj = major(dumpdev);
	if (maj < 0 || maj >= nblkdev) {
		printf("dumpconf: bad dumpdev=0x%x\n", dumpdev);
		dumpdev = NODEV;
		return;
	}
	if (bdevsw[maj].d_psize == NULL)
		return;
	nblks = (u_int)(*bdevsw[maj].d_psize)(dumpdev);
	if (nblks <= btodb(1U))
@


1.13
log
@Dynamic buffer cache. Initial diff from mickey@@, okay art@@ beck@@ toby@@
deraadt@@ dlg@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: sh_machdep.c,v 1.12 2007/04/29 17:53:37 miod Exp $	*/
d319 1
@


1.12
log
@machdep.led_blink sysctl for landisk, also move cpu_sysctl() code and related
variables from arch/sh/ to arch/landisk/. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sh_machdep.c,v 1.11 2007/03/13 19:30:38 miod Exp $	*/
a120 6
#ifdef  NBUF
int	nbuf = NBUF;
#else
int	nbuf = 0;
#endif

a263 1
	u_int loop;
a266 2
	vsize_t bufsize;
	int base, residual;
d303 2
a304 2
	 * Now allocate buffers proper.  They are different than the above
	 * in that they usually occupy more virtual memory than physical.
d306 8
a313 39
	bufsize = MAXBSIZE * nbuf;
	if (uvm_map(kernel_map, (vaddr_t *)&buffers, round_page(bufsize),
	    NULL, UVM_UNKNOWN_OFFSET, 0,
	    UVM_MAPFLAG(UVM_PROT_NONE, UVM_PROT_NONE, UVM_INH_NONE,
	    UVM_ADV_NORMAL, 0)) != 0)
		panic("sh_startup: cannot allocate UVM space for buffers");
	minaddr = (vaddr_t)buffers;
	/* don't want to alloc more physical mem than needed */
	if ((bufpages / nbuf) >= btoc(MAXBSIZE))
		bufpages = btoc(MAXBSIZE) * nbuf;

	base = bufpages / nbuf;
	residual = bufpages % nbuf;
	for (loop = 0; loop < nbuf; ++loop) {
		vsize_t curbufsize;
		vaddr_t curbuf;
		struct vm_page *pg;

		/*
		 * Each buffer has MAXBSIZE bytes of VM space allocated.  Of
		 * that MAXBSIZE space, we allocate and map (base+1) pages
		 * for the first "residual" buffers, and then we allocate
		 * "base" pages for the rest.
		 */
		curbuf = (vaddr_t) buffers + (loop * MAXBSIZE);
		curbufsize = NBPG * ((loop < residual) ? (base+1) : base);

		while (curbufsize) {
			pg = uvm_pagealloc(NULL, 0, NULL, 0);
			if (pg == NULL)
				panic("sh_startup: not enough memory for buffer cache");

			pmap_kenter_pa(curbuf, VM_PAGE_TO_PHYS(pg),
			    VM_PROT_READ|VM_PROT_WRITE);
			curbuf += PAGE_SIZE;
			curbufsize -= PAGE_SIZE;
		}
	}
	pmap_update(pmap_kernel());
a334 2
	printf("using %d buffers containing %u bytes (%uK) of memory\n",
	    nbuf, bufpages * PAGE_SIZE, bufpages * PAGE_SIZE / 1024);
a364 26
	/*
	 * Determine how many buffers to allocate.  We use 10% of the
	 * first 2MB of memory, and 5% of the rest, with a minimum of 16
	 * buffers.  We allocate 1/2 as many swap buffer headers as file
	 * i/o buffers.
	 */
	if (bufpages == 0)
		bufpages = (btoc(2 * 1024 * 1024) + physmem) *
		    bufcachepercent / 100;

	if (nbuf == 0) {
		nbuf = bufpages;
		if (nbuf < 16)
			nbuf = 16;
	}

	/* Restrict to at most 35% filled kvm */
	/* XXX - This needs UBC... */
	if (nbuf >
	    (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) / MAXBSIZE * 35 / 100)
		nbuf = (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) /
		    MAXBSIZE * 35 / 100;

	/* More buffer pages than fits into the buffers is senseless.  */ 
	if (bufpages > nbuf * MAXBSIZE / PAGE_SIZE)
		bufpages = nbuf * MAXBSIZE / PAGE_SIZE;
a365 1
	valloc(buf, struct buf, nbuf);
@


1.11
log
@Move UKC later in the boot process, so that it can use malloc().
@
text
@d1 1
a1 1
/*	$OpenBSD: sh_machdep.c,v 1.10 2007/03/03 21:37:27 miod Exp $	*/
a172 2
int kbd_reset;

a847 31
	/* NOTREACHED */
}

int
cpu_sysctl(int *name, u_int namelen, void *oldp, size_t *oldlenp, void *newp,
    size_t newlen, struct proc *p)
{

	/* all sysctl names at this level are terminal */
	if (namelen != 1)
		return (ENOTDIR);		/* overloaded */

	switch (name[0]) {
	case CPU_CONSDEV: {
		dev_t consdev;
		if (cn_tab != NULL)
			consdev = cn_tab->cn_dev;
		else
			consdev = NODEV;
		return (sysctl_rdstruct(oldp, oldlenp, newp, &consdev,
		    sizeof consdev));
	}

	case CPU_KBDRESET:
		if (securelevel > 0)
			return (sysctl_rdint(oldp, oldlenp, newp, kbd_reset));
		return (sysctl_int(oldp, oldlenp, newp, newlen, &kbd_reset));

	default:
		return (EOPNOTSUPP);
	}
@


1.10
log
@Kernel crash dumps and associated libkvm bits for landisk.
@
text
@d1 1
a1 1
/*	$OpenBSD: sh_machdep.c,v 1.9 2007/03/02 06:11:54 miod Exp $	*/
d107 1
d379 8
@


1.9
log
@Move landisk to hardware floating point. At the moment the FPU context is
always saved upon context switches, as FPU registers are heavily used for
long long computations (don't ask). Gcc default to -m4.

Credits to drahn@@ otto@@ and deraadt@@ for feedback and help testing.

Upgrade procedure if you don't want to use the damn snapshots:
- build and install new kernel, reboot off it
- build new gcc, do not install it yet
- make includes
- install new gcc
- build and install lib/csu and lib/libc
- make build
@
text
@d1 1
a1 1
/*	$OpenBSD: sh_machdep.c,v 1.8 2007/02/26 21:30:18 miod Exp $	*/
d104 3
d118 1
d150 1
a150 1
#define	VBR	(uint8_t *)SH3_PHYS_TO_P1SEG(IOM_RAM_BEGIN)
d167 2
a168 2
uint32_t dumpmag = 0x8fca0101;	/* magic number */
int dumpsize;			/* pages */
d170 1
d432 42
d476 97
a572 1
	/* TODO */
@


1.8
log
@Zero rval[1] in setregs.
@
text
@d1 1
a1 1
/*	$OpenBSD: sh_machdep.c,v 1.7 2007/01/15 22:22:19 martin Exp $	*/
d4 16
a55 1

d479 26
a504 19
	frame.sf_uc.sc_spc = tf->tf_spc;
	frame.sf_uc.sc_ssr = tf->tf_ssr;
	frame.sf_uc.sc_pr = tf->tf_pr;
	frame.sf_uc.sc_r14 = tf->tf_r14;
	frame.sf_uc.sc_r13 = tf->tf_r13;
	frame.sf_uc.sc_r12 = tf->tf_r12;
	frame.sf_uc.sc_r11 = tf->tf_r11;
	frame.sf_uc.sc_r10 = tf->tf_r10;
	frame.sf_uc.sc_r9 = tf->tf_r9;
	frame.sf_uc.sc_r8 = tf->tf_r8;
	frame.sf_uc.sc_r7 = tf->tf_r7;
	frame.sf_uc.sc_r6 = tf->tf_r6;
	frame.sf_uc.sc_r5 = tf->tf_r5;
	frame.sf_uc.sc_r4 = tf->tf_r4;
	frame.sf_uc.sc_r3 = tf->tf_r3;
	frame.sf_uc.sc_r2 = tf->tf_r2;
	frame.sf_uc.sc_r1 = tf->tf_r1;
	frame.sf_uc.sc_r0 = tf->tf_r0;
	frame.sf_uc.sc_r15 = tf->tf_r15;
a508 1
	/* XXX tf_macl, tf_mach not saved */
d560 1
a560 1
	if (((context.sc_ssr ^ tf->tf_ssr) & PSL_USERSTATIC) != 0)
d563 21
a583 1
	tf->tf_ssr = context.sc_ssr;
d585 4
a588 18
	tf->tf_r0 = context.sc_r0;
	tf->tf_r1 = context.sc_r1;
	tf->tf_r2 = context.sc_r2;
	tf->tf_r3 = context.sc_r3;
	tf->tf_r4 = context.sc_r4;
	tf->tf_r5 = context.sc_r5;
	tf->tf_r6 = context.sc_r6;
	tf->tf_r7 = context.sc_r7;
	tf->tf_r8 = context.sc_r8;
	tf->tf_r9 = context.sc_r9;
	tf->tf_r10 = context.sc_r10;
	tf->tf_r11 = context.sc_r11;
	tf->tf_r12 = context.sc_r12;
	tf->tf_r13 = context.sc_r13;
	tf->tf_r14 = context.sc_r14;
	tf->tf_spc = context.sc_spc;
	tf->tf_r15 = context.sc_r15;
	tf->tf_pr = context.sc_pr;
d609 1
d633 10
@


1.7
log
@power(4) driver for the power switch on many landisk models, hooked
up to machdep.kbdreset; modelled after the sparc64 power(4) driver

discussed with miod@@ and jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sh_machdep.c,v 1.6 2006/11/09 00:12:12 deraadt Exp $	*/
d605 2
@


1.6
log
@no newline at end of cpu_model
@
text
@d1 1
a1 1
/*	$OpenBSD: sh_machdep.c,v 1.5 2006/11/08 10:53:58 otto Exp $	*/
d152 2
d680 5
@


1.5
log
@fix sigmask handling bug that caused SIGCHLD to be almost always
masked. DOH! miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sh_machdep.c,v 1.4 2006/10/07 20:52:40 miod Exp $	*/
d258 1
a258 1
		printf("%s", cpu_model);
@


1.4
log
@More bits in progress, adapted from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: sh_machdep.c,v 1.3 2006/10/06 23:15:12 mickey Exp $	*/
d484 1
a484 1
	frame.sf_uc.sc_mask = p->p_sigmask;
@


1.3
log
@debugging delay off
@
text
@d1 1
a1 1
/*	$OpenBSD: sh_machdep.c,v 1.2 2006/10/06 21:16:57 mickey Exp $	*/
a154 2
	int i;

@


1.2
log
@a few fixes to get thru the autoconf
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a167 1
for(i=0xfffffff;i--;);
@


1.1
log
@Initial revision
@
text
@d87 2
d92 2
d101 17
d143 2
d155 2
d168 1
d252 1
d254 4
d281 56
a336 1
	minaddr = 0;
d350 5
d357 59
d608 39
d659 26
@


1.1.1.1
log
@Preliminary bits for SuperH-based ports, based on NetBSD/sh3 codebase with
minor changes.
@
text
@@
