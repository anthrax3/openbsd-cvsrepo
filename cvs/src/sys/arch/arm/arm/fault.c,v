head	1.30;
access;
symbols
	OPENBSD_6_2_BASE:1.30
	OPENBSD_6_1:1.27.0.4
	OPENBSD_6_1_BASE:1.27
	OPENBSD_6_0:1.20.0.2
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.19.0.2
	OPENBSD_5_9_BASE:1.19
	OPENBSD_5_8:1.18.0.6
	OPENBSD_5_8_BASE:1.18
	OPENBSD_5_7:1.18.0.2
	OPENBSD_5_7_BASE:1.18
	OPENBSD_5_6:1.17.0.4
	OPENBSD_5_6_BASE:1.17
	OPENBSD_5_5:1.14.0.4
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.13.0.2
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.12.0.2
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.11.0.4
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.2
	OPENBSD_5_0:1.10.0.18
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.16
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.10.0.14
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.10
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.10.0.12
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.8
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.6
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.4
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.2
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.9.0.2
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.8.0.2
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.6.0.6
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.4
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.2
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.5.0.2
	OPENBSD_3_6_BASE:1.5
	SMP_SYNC_A:1.4
	SMP_SYNC_B:1.4
	OPENBSD_3_5:1.4.0.2
	OPENBSD_3_5_BASE:1.4
	SMP:1.3.0.2;
locks; strict;
comment	@ * @;


1.30
date	2017.09.08.05.36.51;	author deraadt;	state Exp;
branches;
next	1.29;
commitid	uRv5pa9QDlZaYgwD;

1.29
date	2017.07.21.09.19.05;	author kettenis;	state Exp;
branches;
next	1.28;
commitid	VnZuEOg9pJ9Hq1op;

1.28
date	2017.04.30.13.04.49;	author mpi;	state Exp;
branches;
next	1.27;
commitid	xDPbcPU6tYP39nZG;

1.27
date	2017.01.21.05.42.03;	author guenther;	state Exp;
branches;
next	1.26;
commitid	CHRb0fCqa8XxUAMH;

1.26
date	2017.01.06.00.06.02;	author jsg;	state Exp;
branches;
next	1.25;
commitid	YCbIRye8xzoWl68V;

1.25
date	2016.10.22.17.48.41;	author patrick;	state Exp;
branches;
next	1.24;
commitid	1RcSnPLGnOkAWVLw;

1.24
date	2016.10.08.05.49.08;	author guenther;	state Exp;
branches;
next	1.23;
commitid	z63v1DilayzHcfkw;

1.23
date	2016.08.24.13.09.52;	author kettenis;	state Exp;
branches;
next	1.22;
commitid	Emb0lwjQLbMxmqQS;

1.22
date	2016.08.19.19.07.37;	author kettenis;	state Exp;
branches;
next	1.21;
commitid	JoApa3mFVDMWDFDH;

1.21
date	2016.08.19.13.56.08;	author kettenis;	state Exp;
branches;
next	1.20;
commitid	uXjojXCZvopcWMeE;

1.20
date	2016.02.27.13.08.06;	author mpi;	state Exp;
branches;
next	1.19;
commitid	hnv9KfQtxhCytAnd;

1.19
date	2016.01.31.00.14.50;	author jsg;	state Exp;
branches;
next	1.18;
commitid	pbLjedMudUFrVMk6;

1.18
date	2014.11.16.12.30.56;	author deraadt;	state Exp;
branches;
next	1.17;
commitid	yv0ECmCdICvq576h;

1.17
date	2014.05.08.21.17.00;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2014.04.18.11.51.16;	author guenther;	state Exp;
branches;
next	1.15;

1.15
date	2014.03.30.21.54.49;	author guenther;	state Exp;
branches;
next	1.14;

1.14
date	2013.09.10.12.35.25;	author patrick;	state Exp;
branches;
next	1.13;

1.13
date	2013.04.28.13.27.13;	author patrick;	state Exp;
branches;
next	1.12;

1.12
date	2013.01.23.19.57.47;	author patrick;	state Exp;
branches;
next	1.11;

1.11
date	2011.09.20.22.02.11;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2007.05.15.16.02.18;	author drahn;	state Exp;
branches;
next	1.9;

1.9
date	2006.12.24.20.30.35;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2006.05.26.17.06.39;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2006.03.04.10.19.12;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2004.12.30.23.41.07;	author drahn;	state Exp;
branches;
next	1.5;

1.5
date	2004.08.04.20.20.18;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2004.02.23.19.09.57;	author drahn;	state Exp;
branches;
next	1.3;

1.3
date	2004.02.03.15.42.19;	author drahn;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2004.02.01.06.10.33;	author drahn;	state Exp;
branches;
next	1.1;

1.1
date	2004.02.01.05.09.48;	author drahn;	state Exp;
branches;
next	;

1.3.2.1
date	2004.02.19.10.48.00;	author niklas;	state Exp;
branches;
next	1.3.2.2;

1.3.2.2
date	2004.06.05.23.10.44;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.30
log
@If you use sys/param.h, you don't need sys/types.h
@
text
@/*	$OpenBSD: fault.c,v 1.29 2017/07/21 09:19:05 kettenis Exp $	*/
/*	$NetBSD: fault.c,v 1.46 2004/01/21 15:39:21 skrll Exp $	*/

/*
 * Copyright 2003 Wasabi Systems, Inc.
 * All rights reserved.
 *
 * Written by Steve C. Woodford for Wasabi Systems, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed for the NetBSD Project by
 *      Wasabi Systems, Inc.
 * 4. The name of Wasabi Systems, Inc. may not be used to endorse
 *    or promote products derived from this software without specific prior
 *    written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY WASABI SYSTEMS, INC. ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL WASABI SYSTEMS, INC
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
/*
 * Copyright (c) 1994-1997 Mark Brinicombe.
 * Copyright (c) 1994 Brini.
 * All rights reserved.
 *
 * This code is derived from software written for Brini by Mark Brinicombe
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Brini.
 * 4. The name of the company nor the name of the author may be used to
 *    endorse or promote products derived from this software without specific
 *    prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY BRINI ``AS IS'' AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL BRINI OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * RiscBSD kernel project
 *
 * fault.c
 *
 * Fault handlers
 *
 * Created      : 28/11/94
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/user.h>
#include <sys/kernel.h>
#include <sys/signalvar.h>

#include <uvm/uvm_extern.h>

#include <arm/cpuconf.h>

#include <machine/frame.h>
#include <machine/cpu.h>
#include <machine/intr.h>
#ifdef DDB
#include <machine/db_machdep.h>
#endif

#include <arm/db_machdep.h>
#include <arch/arm/arm/disassem.h>
#include <arm/machdep.h>
 
#ifdef DEBUG
int last_fault_code;	/* For the benefit of pmap_fault_fixup() */
#endif

struct sigdata {
	int signo;
	int code;
	vaddr_t addr;
	int trap;
};

struct data_abort {
	int (*func)(trapframe_t *, u_int, u_int, struct proc *,
	    struct sigdata *);
	const char *desc;
};

static int dab_fatal(trapframe_t *, u_int, u_int, struct proc *,
    struct sigdata *sd);
static int dab_align(trapframe_t *, u_int, u_int, struct proc *,
    struct sigdata *sd);
static int dab_buserr(trapframe_t *, u_int, u_int, struct proc *,
    struct sigdata *sd);
extern int dab_access(trapframe_t *, u_int, u_int, struct proc *,
    struct sigdata *sd);

static const struct data_abort data_aborts[] = {
	{dab_fatal,	"V7 fault 00000"},
	{dab_align,	"Alignment fault"},
	{dab_fatal,	"Debug event"},
	{dab_fatal,	"Access flag fault (L1)"},
	{dab_buserr,	"Fault on instruction cache maintenance"},
	{NULL,		"Translation fault (L1)"},
	{dab_access,	"Access flag fault (L2)"},
	{NULL,		"Translation fault (L2)"},
	{dab_buserr,	"Synchronous external abort"},
	{NULL,		"Domain fault (L1)"},
	{dab_fatal,	"V7 fault 01010"},
	{NULL,		"Domain fault (L2)"},
	{dab_buserr,	"Synchronous external abort on translation table walk (L1)"},
	{NULL,		"Permission fault (L1)"},
	{dab_buserr,	"Synchronous external abort on translation table walk (L2)"},
	{NULL,		"Permission fault (L2)"},
	{dab_fatal,	"TLB conflict abort"},
	{dab_fatal,	"V7 fault 10001"},
	{dab_fatal,	"V7 fault 10010"},
	{dab_fatal,	"V7 fault 10011"},
	{dab_fatal,	"Lockdown"},
	{dab_fatal,	"V7 fault 10101"},
	{dab_fatal,	"Asynchronous external abort"},
	{dab_fatal,	"V7 fault 10111"},
	{dab_fatal,	"Asynchronous parity error on memory access"},
	{dab_fatal,	"Synchronous parity error on memory access"},
	{dab_fatal,	"Coprocessor Abort"},
	{dab_fatal,	"V7 fault 11011"},
	{dab_buserr,	"Synchronous parity error on translation table walk (L1)"},
	{dab_fatal,	"V7 fault 11101"},
	{dab_buserr,	"Synchronous parity error on translation table walk (L2)"},
	{NULL,		"V7 fault 11111"},
};

/* Determine if 'ftyp' is a permission fault */
#define	IS_PERMISSION_FAULT(ftyp)				\
	(((1 << (ftyp)) &					\
	  ((1 << FAULT_PERM_P) | (1 << FAULT_PERM_S))) != 0)

void
data_abort_handler(trapframe_t *tf)
{
	struct vm_map *map;
	struct pcb *pcb;
	struct proc *p;
	u_int user, far, fsr, ftyp;
	vm_prot_t ftype;
	void *onfault;
	vaddr_t va;
	int error;
	union sigval sv;
	struct sigdata sd;

	/* Grab FAR/FSR before enabling interrupts */
	far = cpu_dfar();
	fsr = cpu_dfsr();
	ftyp = FAULT_TYPE_V7(fsr);

	/* Update vmmeter statistics */
	uvmexp.traps++;

	/* Re-enable interrupts if they were enabled previously */
	if (__predict_true((tf->tf_spsr & PSR_I) == 0))
		enable_interrupts(PSR_I);

	/* Get the current proc structure or proc0 if there is none */
	p = (curproc != NULL) ? curproc : &proc0;

	/* Data abort came from user mode? */
	user = TRAP_USERMODE(tf);

	/* Grab the current pcb */
	pcb = &p->p_addr->u_pcb;

	/* Invoke the appropriate handler, if necessary */
	if (__predict_false(data_aborts[ftyp].func != NULL)) {
		if ((data_aborts[ftyp].func)(tf, fsr, far, p, &sd)) {
			goto do_trapsignal;
		}
		goto out;
	}

	/*
	 * At this point, we're dealing with one of the following data aborts:
	 *
	 *  FAULT_TRANS_S  - Translation -- Section
	 *  FAULT_TRANS_P  - Translation -- Page
	 *  FAULT_DOMAIN_S - Domain -- Section
	 *  FAULT_DOMAIN_P - Domain -- Page
	 *  FAULT_PERM_S   - Permission -- Section
	 *  FAULT_PERM_P   - Permission -- Page
	 *
	 * These are the main virtual memory-related faults signalled by
	 * the MMU.
	 */

	if (user) {
		p->p_addr->u_pcb.pcb_tf = tf;
		refreshcreds(p);
	}

	/*
	 * Make sure the Program Counter is sane. We could fall foul of
	 * someone executing Thumb code, in which case the PC might not
	 * be word-aligned. This would cause a kernel alignment fault
	 * further down if we have to decode the current instruction.
	 * XXX: It would be nice to be able to support Thumb at some point.
	 */
	if (__predict_false((tf->tf_pc & 3) != 0)) {
		if (user) {
			/*
			 * Give the user an illegal instruction signal.
			 */
			/* Deliver a SIGILL to the process */
			sd.signo = SIGILL;
			sd.code = ILL_ILLOPC;
			sd.addr = far;
			sd.trap = fsr;
			goto do_trapsignal;
		}

		/*
		 * The kernel never executes Thumb code.
		 */
		printf("\ndata_abort_fault: Misaligned Kernel-mode "
		    "Program Counter\n");
		dab_fatal(tf, fsr, far, p, NULL);
	}

	va = trunc_page((vaddr_t)far);

	/*
	 * It is only a kernel address space fault iff:
	 *	1. user == 0  and
	 *	2. pcb_onfault not set or
	 *	3. pcb_onfault set and not LDRT/LDRBT/STRT/STRBT instruction.
	 */
	if (user == 0 && (va >= VM_MIN_KERNEL_ADDRESS ||
	    (va < VM_MIN_ADDRESS && vector_page == ARM_VECTORS_LOW)) &&
	    __predict_true((pcb->pcb_onfault == NULL ||
	     ((*(u_int *)tf->tf_pc) & 0x05200000) != 0x04200000))) {
		map = kernel_map;

		/* Was the fault due to the FPE/IPKDB ? */
		if (__predict_false((tf->tf_spsr & PSR_MODE)==PSR_UND32_MODE)) {
			sd.signo = SIGSEGV;
			sd.code = SEGV_ACCERR;
			sd.addr = far;
			sd.trap = fsr;

			/*
			 * Force exit via userret()
			 * This is necessary as the FPE is an extension to
			 * userland that actually runs in a priveledged mode
			 * but uses USR mode permissions for its accesses.
			 */
			user = 1;
			goto do_trapsignal;
		}
	} else {
		map = &p->p_vmspace->vm_map;
#if 0
		if (l->l_flag & L_SA) {
			KDASSERT(l->l_proc->p_sa != NULL);
			l->l_proc->p_sa->sa_vp_faultaddr = (vaddr_t)far;
			l->l_flag |= L_SA_PAGEFAULT;
		}
#endif
	}

	ftype = fsr & FAULT_WNR ? PROT_WRITE : PROT_READ;

	if (__predict_false(curcpu()->ci_idepth > 0)) {
		if (pcb->pcb_onfault) {
			tf->tf_r0 = EINVAL;
			tf->tf_pc = (register_t) pcb->pcb_onfault;
			return;
		}
		printf("\nNon-emulated page fault with intr_depth > 0\n");
		dab_fatal(tf, fsr, far, p, NULL);
	}

	onfault = pcb->pcb_onfault;
	pcb->pcb_onfault = NULL;
	error = uvm_fault(map, va, 0, ftype);
	pcb->pcb_onfault = onfault;

#if 0
	if (map != kernel_map)
		p->p_flag &= ~L_SA_PAGEFAULT;
#endif

	if (__predict_true(error == 0)) {
		if (user)
			uvm_grow(p, va); /* Record any stack growth */
		goto out;
	}

	if (user == 0) {
		if (pcb->pcb_onfault) {
			tf->tf_r0 = error;
			tf->tf_pc = (register_t) pcb->pcb_onfault;
			return;
		}

		printf("\nuvm_fault(%p, %lx, %x, 0) -> %x\n", map, va, ftype,
		    error);
		dab_fatal(tf, fsr, far, p, NULL);
	}

	sd.signo = SIGSEGV;
	sd.code = SEGV_MAPERR;
	if (error == ENOMEM) {
		printf("UVM: pid %d (%s), uid %d killed: "
		    "out of swap\n", p->p_p->ps_pid, p->p_p->ps_comm,
		    p->p_ucred ? (int)p->p_ucred->cr_uid : -1);
		sd.signo = SIGKILL;
		sd.code = 0;
	}
	if (error == EACCES) 
		sd.code = SEGV_ACCERR;
	if (error == EIO) {
		sd.signo = SIGBUS;
		sd.code = BUS_OBJERR;
	}
	sd.addr = far;
	sd.trap = fsr;
do_trapsignal:
	sv.sival_int = sd.addr;
	trapsignal(p, sd.signo, sd.trap, sd.code, sv);
out:
	/* If returning to user mode, make sure to invoke userret() */
	if (user)
		userret(p);
}

/*
 * dab_fatal() handles the following data aborts:
 *
 *  FAULT_WRTBUF_0 - Vector Exception
 *  FAULT_WRTBUF_1 - Terminal Exception
 *
 * We should never see these on a properly functioning system.
 *
 * This function is also called by the other handlers if they
 * detect a fatal problem.
 *
 * Note: If 'p' is NULL, we assume we're dealing with a prefetch abort.
 */
static int
dab_fatal(trapframe_t *tf, u_int fsr, u_int far, struct proc *p,
    struct sigdata *sd)
{
	const char *mode;
	uint ftyp;

	mode = TRAP_USERMODE(tf) ? "user" : "kernel";

	if (p != NULL) {
		ftyp = FAULT_TYPE_V7(fsr);
		printf("Fatal %s mode data abort: '%s'\n", mode,
		    data_aborts[ftyp].desc);
		printf("trapframe: %p\nDFSR=%08x, DFAR=%08x", tf, fsr, far);
		printf(", spsr=%08lx\n", tf->tf_spsr);
	} else {
		printf("Fatal %s mode prefetch abort at 0x%08lx\n",
		    mode, tf->tf_pc);
		printf("trapframe: %p\nIFSR=%08x, IFAR=%08x, spsr=%08lx\n",
		    tf, fsr, far, tf->tf_spsr);
	}

	printf("r0 =%08lx, r1 =%08lx, r2 =%08lx, r3 =%08lx\n",
	    tf->tf_r0, tf->tf_r1, tf->tf_r2, tf->tf_r3);
	printf("r4 =%08lx, r5 =%08lx, r6 =%08lx, r7 =%08lx\n",
	    tf->tf_r4, tf->tf_r5, tf->tf_r6, tf->tf_r7);
	printf("r8 =%08lx, r9 =%08lx, r10=%08lx, r11=%08lx\n",
	    tf->tf_r8, tf->tf_r9, tf->tf_r10, tf->tf_r11);
	printf("r12=%08lx, ", tf->tf_r12);

	if (TRAP_USERMODE(tf))
		printf("usp=%08lx, ulr=%08lx",
		    tf->tf_usr_sp, tf->tf_usr_lr);
	else
		printf("ssp=%08lx, slr=%08lx",
		    tf->tf_svc_sp, tf->tf_svc_lr);
	printf(", pc =%08lx\n\n", tf->tf_pc);

#ifdef DDB
	db_ktrap(T_FAULT, tf);
#endif
	panic("Fatal abort");
	/*NOTREACHED*/
}

/*
 * dab_align() handles the following data aborts:
 *
 *  FAULT_ALIGN_0 - Alignment fault
 *  FAULT_ALIGN_0 - Alignment fault
 *
 * These faults are fatal if they happen in kernel mode. Otherwise, we
 * deliver a bus error to the process.
 */
static int
dab_align(trapframe_t *tf, u_int fsr, u_int far, struct proc *p,
    struct sigdata *sd)
{
	/* Alignment faults are always fatal if they occur in kernel mode */
	if (!TRAP_USERMODE(tf))
		dab_fatal(tf, fsr, far, p, NULL);

	/* pcb_onfault *must* be NULL at this point */
	KDASSERT(p->p_addr->u_pcb.pcb_onfault == NULL);

	/* Deliver a bus error signal to the process */
	sd->signo = SIGBUS;
	sd->code = BUS_ADRALN;
	sd->addr = far;
	sd->trap = fsr;

	p->p_addr->u_pcb.pcb_tf = tf;

	return (1);
}

/*
 * dab_buserr() handles the following data aborts:
 *
 *  FAULT_BUSERR_0 - External Abort on Linefetch -- Section
 *  FAULT_BUSERR_1 - External Abort on Linefetch -- Page
 *  FAULT_BUSERR_2 - External Abort on Non-linefetch -- Section
 *  FAULT_BUSERR_3 - External Abort on Non-linefetch -- Page
 *  FAULT_BUSTRNL1 - External abort on Translation -- Level 1
 *  FAULT_BUSTRNL2 - External abort on Translation -- Level 2
 *
 * If pcb_onfault is set, flag the fault and return to the handler.
 * If the fault occurred in user mode, give the process a SIGBUS.
 *
 * Note: On XScale, FAULT_BUSERR_0, FAULT_BUSERR_1, and FAULT_BUSERR_2
 * can be flagged as imprecise in the FSR. This causes a real headache
 * since some of the machine state is lost. In this case, tf->tf_pc
 * may not actually point to the offending instruction. In fact, if
 * we've taken a double abort fault, it generally points somewhere near
 * the top of "data_abort_entry" in exception.S.
 *
 * In all other cases, these data aborts are considered fatal.
 */
static int
dab_buserr(trapframe_t *tf, u_int fsr, u_int far, struct proc *p,
    struct sigdata *sd)
{
	struct pcb *pcb = &p->p_addr->u_pcb;

#ifdef __XSCALE__
	if ((fsr & FAULT_IMPRECISE) != 0 &&
	    (tf->tf_spsr & PSR_MODE) == PSR_ABT32_MODE) {
		/*
		 * Oops, an imprecise, double abort fault. We've lost the
		 * r14_abt/spsr_abt values corresponding to the original
		 * abort, and the spsr saved in the trapframe indicates
		 * ABT mode.
		 */
		tf->tf_spsr &= ~PSR_MODE;

		/*
		 * We use a simple heuristic to determine if the double abort
		 * happened as a result of a kernel or user mode access.
		 * If the current trapframe is at the top of the kernel stack,
		 * the fault _must_ have come from user mode.
		 */
		if (tf != ((trapframe_t *)pcb->pcb_un.un_32.pcb32_sp) - 1) {
			/*
			 * Kernel mode. We're either about to die a
			 * spectacular death, or pcb_onfault will come
			 * to our rescue. Either way, the current value
			 * of tf->tf_pc is irrelevant.
			 */
			tf->tf_spsr |= PSR_SVC32_MODE;
			if (pcb->pcb_onfault == NULL)
				printf("\nKernel mode double abort!\n");
		} else {
			/*
			 * User mode. We've lost the program counter at the
			 * time of the fault (not that it was accurate anyway;
			 * it's not called an imprecise fault for nothing).
			 * About all we can do is copy r14_usr to tf_pc and
			 * hope for the best. The process is about to get a
			 * SIGBUS, so it's probably history anyway.
			 */
			tf->tf_spsr |= PSR_USR32_MODE;
			tf->tf_pc = tf->tf_usr_lr;
		}
	}

	/* FAR is invalid for imprecise exceptions */
	if ((fsr & FAULT_IMPRECISE) != 0)
		far = 0;
#endif /* __XSCALE__ */

	if (pcb->pcb_onfault) {
		KDASSERT(TRAP_USERMODE(tf) == 0);
		tf->tf_r0 = EFAULT;
		tf->tf_pc = (register_t) pcb->pcb_onfault;
		return (0);
	}

	/*
	 * At this point, if the fault happened in kernel mode or user mode,
	 * we're toast
	 */
	dab_fatal(tf, fsr, far, p, NULL);

	return (1);
}

/*
 * void prefetch_abort_handler(trapframe_t *tf)
 *
 * Abort handler called when instruction execution occurs at
 * a non existent or restricted (access permissions) memory page.
 * If the address is invalid and we were in SVC mode then panic as
 * the kernel should never prefetch abort.
 * If the address is invalid and the page is mapped then the user process
 * does no have read or execute permission so send it a signal.
 * Otherwise fault the page in and try again.
 */
void
prefetch_abort_handler(trapframe_t *tf)
{
	struct proc *p;
	struct vm_map *map;
	vaddr_t va;
	int error;
	union sigval sv;
	uint fsr, far;

	/* Update vmmeter statistics */
	uvmexp.traps++;

	/* Grab FAR/FSR before enabling interrupts */
	far = cpu_ifar();
	fsr = cpu_ifsr();

	/* Prefetch aborts cannot happen in kernel mode */
	if (__predict_false(!TRAP_USERMODE(tf)))
		dab_fatal(tf, fsr, far, NULL, NULL);

	/*
	 * Enable IRQ's (disabled by the abort) This always comes
	 * from user mode so we know interrupts were not disabled.
	 * But we check anyway.
	 */
	if (__predict_true((tf->tf_spsr & PSR_I) == 0))
		enable_interrupts(PSR_I);

	p = curproc;

	/* Invoke access fault handler if appropriate */
	if (FAULT_TYPE_V7(fsr) == FAULT_ACCESS_2) {
		dab_access(tf, fsr, far, p, NULL);
		goto out;
	}

	p->p_addr->u_pcb.pcb_tf = tf;

	/* Ok validate the address, can only execute in USER space */
	if (__predict_false(far >= VM_MAXUSER_ADDRESS ||
	    (far < VM_MIN_ADDRESS && vector_page == ARM_VECTORS_LOW))) {
		sv.sival_ptr = (u_int32_t *)far;
		trapsignal(p, SIGSEGV, 0, SEGV_ACCERR, sv);
		goto out;
	}

	map = &p->p_vmspace->vm_map;
	va = trunc_page(far);


#ifdef DIAGNOSTIC
	if (__predict_false(curcpu()->ci_idepth > 0)) {
		printf("\nNon-emulated prefetch abort with intr_depth > 0\n");
		dab_fatal(tf, fsr, far, NULL, NULL);
	}
#endif

	error = uvm_fault(map, va, 0, PROT_READ | PROT_EXEC);
	if (__predict_true(error == 0))
		goto out;

	sv.sival_ptr = (u_int32_t *)far;
	if (error == ENOMEM) {
		printf("UVM: pid %d (%s), uid %d killed: "
		    "out of swap\n", p->p_p->ps_pid, p->p_p->ps_comm,
		    p->p_ucred ? (int)p->p_ucred->cr_uid : -1);
		trapsignal(p, SIGKILL, 0, SEGV_MAPERR, sv);
	} else
		trapsignal(p, SIGSEGV, 0, SEGV_MAPERR, sv);

out:
	userret(p);
}

/*
 * Tentatively read an 8, 16, or 32-bit value from 'addr'.
 * If the read succeeds, the value is written to 'rptr' and zero is returned.
 * Else, return EFAULT.
 */
int
badaddr_read(void *addr, size_t size, void *rptr)
{
	extern int badaddr_read_1(const uint8_t *, uint8_t *);
	extern int badaddr_read_2(const uint16_t *, uint16_t *);
	extern int badaddr_read_4(const uint32_t *, uint32_t *);
	union {
		uint8_t v1;
		uint16_t v2;
		uint32_t v4;
	} u;
	int rv;

	cpu_drain_writebuf();

	/* Read from the test address. */
	switch (size) {
	case sizeof(uint8_t):
		rv = badaddr_read_1(addr, &u.v1);
		if (rv == 0 && rptr)
			*(uint8_t *) rptr = u.v1;
		break;

	case sizeof(uint16_t):
		rv = badaddr_read_2(addr, &u.v2);
		if (rv == 0 && rptr)
			*(uint16_t *) rptr = u.v2;
		break;

	case sizeof(uint32_t):
		rv = badaddr_read_4(addr, &u.v4);
		if (rv == 0 && rptr)
			*(uint32_t *) rptr = u.v4;
		break;

	default:
		panic("badaddr: invalid size (%lu)", (u_long) size);
	}

	/* Return EFAULT if the address was invalid, else zero */
	return (rv);
}
@


1.29
log
@Accessing a mmap(2)ed file behind its end should result in a SIGBUS
according to POSIX.

ok bluhm@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fault.c,v 1.28 2017/04/30 13:04:49 mpi Exp $	*/
a79 2

#include <sys/types.h>
@


1.28
log
@Unifdef KGDB.

It doesn't compile und hasn't been working during the last decade.

ok kettenis@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fault.c,v 1.27 2017/01/21 05:42:03 guenther Exp $	*/
d342 2
a343 1
	sv.sival_ptr = (u_int32_t *)far;
d349 8
a356 4
	} else
		sd.signo = SIGSEGV;

	sd.code = (error == EACCES) ? SEGV_ACCERR : SEGV_MAPERR;
@


1.27
log
@p_comm is the process's command and isn't per thread, so move it from
struct proc to struct process.

ok deraadt@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fault.c,v 1.26 2017/01/06 00:06:02 jsg Exp $	*/
d97 1
a97 1
#if defined(DDB) || defined(KGDB)
a98 6
#ifdef KGDB
#include <sys/kgdb.h>
#endif
#if !defined(DDB)
#define db_ktrap	kgdb_trap
#endif
d414 1
a414 1
#if defined(DDB) || defined(KGDB)
@


1.26
log
@unifdef CPU_ARMv7 and ARM_ARCH_7
ok kettenis@@ patrick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fault.c,v 1.25 2016/10/22 17:48:41 patrick Exp $	*/
d351 1
a351 1
		    "out of swap\n", p->p_p->ps_pid, p->p_comm,
d624 1
a624 1
		    "out of swap\n", p->p_p->ps_pid, p->p_comm,
@


1.25
log
@If an Access Flag fault happens while we were running the kernel and
it happened on a kernel page, we need to consult the kernel pmap
instead of the current proc's pmap.  Fixes panic when using tmpfs.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fault.c,v 1.24 2016/10/08 05:49:08 guenther Exp $	*/
a137 18
#ifndef CPU_ARMv7
	{dab_fatal,	"Vector Exception"},
	{dab_align,	"Alignment Fault 1"},
	{dab_fatal,	"Terminal Exception"},
	{dab_align,	"Alignment Fault 3"},
	{dab_buserr,	"External Linefetch Abort (S)"},
	{NULL,		"Translation Fault (S)"},
	{dab_buserr,	"External Linefetch Abort (P)"},
	{NULL,		"Translation Fault (P)"},
	{dab_buserr,	"External Non-Linefetch Abort (S)"},
	{NULL,		"Domain Fault (S)"},
	{dab_buserr,	"External Non-Linefetch Abort (P)"},
	{NULL,		"Domain Fault (P)"},
	{dab_buserr,	"External Translation Abort (L1)"},
	{NULL,		"Permission Fault (S)"},
	{dab_buserr,	"External Translation Abort (L2)"},
	{NULL,		"Permission Fault (P)"}
#else
a169 1
#endif
a193 3
#ifndef CPU_ARMv7
	ftyp = FAULT_TYPE(fsr);
#else
a194 1
#endif
a307 29
#ifndef CPU_ARMv7
	/*
	 * We need to know whether the page should be mapped
	 * as R or R/W. The MMU does not give us the info as
	 * to whether the fault was caused by a read or a write.
	 *
	 * However, we know that a permission fault can only be
	 * the result of a write to a read-only location, so
	 * we can deal with those quickly.
	 *
	 * Otherwise we need to disassemble the instruction
	 * responsible to determine if it was a write.
	 */
	if (IS_PERMISSION_FAULT(fsr))
		ftype = PROT_WRITE; 
	else {
		u_int insn = *(u_int *)tf->tf_pc;

		if (((insn & 0x0c100000) == 0x04000000) ||	/* STR/STRB */
		    ((insn & 0x0e1000b0) == 0x000000b0) ||	/* STRH/STRD */
		    ((insn & 0x0a100000) == 0x08000000))	/* STM/CDT */
			ftype = PROT_WRITE; 
		else
		if ((insn & 0x0fb00ff0) == 0x01000090)		/* SWP */
			ftype = PROT_READ | PROT_WRITE; 
		else
			ftype = PROT_READ; 
	}
#else
a308 18
#endif

#ifndef CPU_ARMv7
	/*
	 * See if the fault is as a result of ref/mod emulation,
	 * or domain mismatch.
	 */
#ifdef DEBUG
	last_fault_code = fsr;
#endif
	if (pmap_fault_fixup(map->pmap, va, ftype, user)) {
#if 0
		if (map != kernel_map)
			p->p_flag &= ~L_SA_PAGEFAULT;
#endif
		goto out;
	}
#endif
a347 1

a391 3
#ifndef CPU_ARMv7
		ftyp = FAULT_TYPE(fsr);
#else
a392 1
#endif
a395 4
#ifndef CPU_ARMv7
		if ((fsr & FAULT_IMPRECISE) != 0)
			printf(" (imprecise)");
#endif
a572 4
#ifndef CPU_ARMv7
	far = tf->tf_pc;
	fsr = 0;
#else
a574 1
#endif
a589 1
#ifdef CPU_ARMv7
a594 1
#endif
a608 10
#ifndef CPU_ARMv7
	/*
	 * See if the pmap can handle this fault on its own...
	 */
#ifdef DEBUG
	last_fault_code = -1;
#endif
	if (pmap_fault_fixup(map->pmap, va, PROT_READ | PROT_EXEC, 1))
		goto out;
#endif
@


1.24
log
@Various printf claim to report the PID, so actually report that and not the TID

Build testing assistance from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fault.c,v 1.23 2016/08/24 13:09:52 kettenis Exp $	*/
a189 3

/* Determine if a fault came from user mode */
#define	TRAP_USERMODE(tf)	((tf->tf_spsr & PSR_MODE) == PSR_USR32_MODE)
@


1.23
log
@Replace pmap_fault_fixup() with an access flag fault handler on armv7.

ok tom@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fault.c,v 1.22 2016/08/19 19:07:37 kettenis Exp $	*/
d425 1
a425 1
		    "out of swap\n", p->p_pid, p->p_comm,
d723 1
a723 1
		    "out of swap\n", p->p_pid, p->p_comm,
@


1.22
log
@Make the FSR encoding strings match the ARMv7 ARM.
@
text
@d1 1
a1 1
/*	$OpenBSD: fault.c,v 1.21 2016/08/19 13:56:08 kettenis Exp $	*/
d134 2
d159 1
a159 1
	{NULL,		"Access flag fault (L1)"},
d162 1
a162 1
	{NULL,		"Access flag fault (L2)"},
d366 1
d381 1
a674 1
	/* Get fault address */
d676 9
d698 1
d707 1
@


1.21
log
@Use Access Flag to do page reference emulation.

ok visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fault.c,v 1.20 2016/02/27 13:08:06 mpi Exp $	*/
d155 9
a163 9
	{dab_align,	"Alignment Fault 1"},
	{dab_fatal,	"Debug Event"},
	{NULL,		"Access Flag Fault (S)"},
	{dab_buserr,	"External Linefetch Abort (S)"},
	{NULL,		"Translation Fault (S)"},
	{NULL,		"Access Flag Fault (P)"},
	{NULL,		"Translation Fault (P)"},
	{dab_buserr,	"External Non-Linefetch Abort (S)"},
	{NULL,		"Domain Fault (S)"},
d165 6
a170 6
	{NULL,		"Domain Fault (P)"},
	{dab_buserr,	"External Translation Abort (L1)"},
	{NULL,		"Permission Fault (S)"},
	{dab_buserr,	"External Translation Abort (L2)"},
	{NULL,		"Permission Fault (P)"},
	{dab_fatal,	"V7 fault 10000"},
d176 1
a176 1
	{dab_fatal,	"Asynchronous External Abort"},
d178 2
a179 2
	{dab_fatal,	"Memory Asynchronous Parity Error"},
	{dab_fatal,	"Memory Synchronous Parity Error"},
d182 1
a182 1
	{dab_buserr,	"External Translation Abort (L1)"},
d184 1
a184 1
	{dab_buserr,	"External Translation Abort (L2)"},
@


1.20
log
@Rename kdb_trap() into db_ktrap().

The goal is to include it in the list of functions that must not be
instrumented.  All ddb(8) functions should be in this list and have
their names start with 'db_'.

ok visa@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fault.c,v 1.19 2016/01/31 00:14:50 jsg Exp $	*/
d157 1
a157 1
	{dab_fatal,	"Access Flag Fault (S)"},
d160 1
a160 1
	{dab_fatal,	"Access Flag Fault (P)"},
@


1.19
log
@Switch from PSR_X_bit and X32_bit PSR macro names to just PSR_X.
This matches FreeBSD and makes things a bit more consistent.
Discussed with Patrick.
@
text
@d1 1
a1 1
/*	$OpenBSD: fault.c,v 1.18 2014/11/16 12:30:56 deraadt Exp $	*/
d103 1
a103 1
#define kdb_trap	kgdb_trap
d499 1
a499 1
	kdb_trap(T_FAULT, tf);
@


1.18
log
@Replace a plethora of historical protection options with just
PROT_NONE, PROT_READ, PROT_WRITE, and PROT_EXEC from mman.h.
PROT_MASK is introduced as the one true way of extracting those bits.
Remove UVM_ADV_* wrapper, using the standard names.
ok doug guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: fault.c,v 1.17 2014/05/08 21:17:00 miod Exp $	*/
d224 2
a225 2
	if (__predict_true((tf->tf_spsr & I32_bit) == 0))
		enable_interrupts(I32_bit);
d668 2
a669 2
	if (__predict_true((tf->tf_spsr & I32_bit) == 0))
		enable_interrupts(I32_bit);
@


1.17
log
@Format string fixes and removal of -Wno-format for arm kernels.
@
text
@d1 1
a1 1
/*	$OpenBSD: fault.c,v 1.16 2014/04/18 11:51:16 guenther Exp $	*/
d346 1
a346 1
		ftype = VM_PROT_WRITE; 
d353 1
a353 1
			ftype = VM_PROT_WRITE; 
d356 1
a356 1
			ftype = VM_PROT_READ | VM_PROT_WRITE; 
d358 1
a358 1
			ftype = VM_PROT_READ; 
d361 1
a361 1
	ftype = fsr & FAULT_WNR ? VM_PROT_WRITE : VM_PROT_READ;
d692 1
a692 1
	if (pmap_fault_fixup(map->pmap, va, VM_PROT_READ|VM_PROT_EXECUTE, 1))
d702 1
a702 1
	error = uvm_fault(map, va, 0, VM_PROT_READ|VM_PROT_EXECUTE);
@


1.16
log
@Have each thread keeps its own (counted!) reference to the process's ucreds
to avoid possible use-after-free references when swapping ids in threaded
processes.  "Do I have the right creds?" checks are always made with the
threads creds.

Inspired by FreeBSD and NetBSD
"right time" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fault.c,v 1.15 2014/03/30 21:54:49 guenther Exp $	*/
d474 1
a474 1
		printf(", spsr=%08x\n", tf->tf_spsr);
d476 1
a476 1
		printf("Fatal %s mode prefetch abort at 0x%08x\n",
d478 1
a478 1
		printf("trapframe: %p\nIFSR=%08x, IFAR=%08x, spsr=%08x\n",
d482 1
a482 1
	printf("r0 =%08x, r1 =%08x, r2 =%08x, r3 =%08x\n",
d484 1
a484 1
	printf("r4 =%08x, r5 =%08x, r6 =%08x, r7 =%08x\n",
d486 1
a486 1
	printf("r8 =%08x, r9 =%08x, r10=%08x, r11=%08x\n",
d488 1
a488 1
	printf("r12=%08x, ", tf->tf_r12);
d491 1
a491 1
		printf("usp=%08x, ulr=%08x",
d494 1
a494 1
		printf("ssp=%08x, slr=%08x",
d496 1
a496 1
	printf(", pc =%08x\n\n", tf->tf_pc);
@


1.15
log
@Eliminates struct pcred by moving the real and saved ugids into
struct ucred; struct process then directly links to the ucred

Based on a discussion at c2k10 or so before noting that FreeBSD and
NetBSD did this too.

ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fault.c,v 1.14 2013/09/10 12:35:25 patrick Exp $	*/
d258 1
a258 1
	if (user)
d260 2
@


1.14
log
@Store the current interrupt depth in curcpu, so that it's per CPU
and not just a global variable.

ok rapha@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fault.c,v 1.13 2013/04/28 13:27:13 patrick Exp $	*/
d420 1
a420 2
		    (p->p_cred && p->p_ucred) ?
		     p->p_ucred->cr_uid : -1);
d708 1
a708 2
		    (p->p_cred && p->p_ucred) ?
		     p->p_ucred->cr_uid : -1);
@


1.13
log
@Improved dealing of ARMv7 faults. Added ARMv7 fault descriptions.

ok bmercer@@
tested on zaurus by todd@@ and patrick@@
tested on armv7 boards
@
text
@d1 1
a1 1
/*	$OpenBSD: fault.c,v 1.12 2013/01/23 19:57:47 patrick Exp $	*/
d377 1
a377 1
	if (__predict_false(current_intr_depth > 0)) {
d695 1
a695 1
	if (__predict_false(current_intr_depth > 0)) {
@


1.12
log
@Add instruction fault register functions, which will be needed for further
ARMv7 support.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fault.c,v 1.11 2011/09/20 22:02:11 miod Exp $	*/
d136 1
d153 34
d192 3
a194 3
/* Determine if 'x' is a permission fault */
#define	IS_PERMISSION_FAULT(x)					\
	(((1 << ((x) & FAULT_TYPE_MASK)) &			\
d203 1
a203 1
	u_int user, far, fsr;
d214 5
d237 2
a238 3
	if (__predict_false(data_aborts[fsr & FAULT_TYPE_MASK].func != NULL)) {
		if ((data_aborts[fsr & FAULT_TYPE_MASK].func)(tf, fsr, far, p,
		    &sd)) {
d330 1
d358 3
d449 1
a449 1
 * Note: If 'l' is NULL, we assume we're dealing with a prefetch abort.
d456 1
d461 5
d467 7
a473 7
		    data_aborts[fsr & FAULT_TYPE_MASK].desc);
		printf("trapframe: %p\nFSR=%08x, FAR=", tf, fsr);
		if ((fsr & FAULT_IMPRECISE) == 0)
			printf("%08x, ", far);
		else
			printf("Invalid,  ");
		printf("spsr=%08x\n", tf->tf_spsr);
d477 2
a478 1
		printf("trapframe: %p, spsr=%08x\n", tf, tf->tf_spsr);
d633 1
a633 1
 * does no have read permission so send it a signal.
d641 1
a641 1
	vaddr_t fault_pc, va;
d644 1
d649 13
a669 4
	/* Prefetch aborts cannot happen in kernel mode */
	if (__predict_false(!TRAP_USERMODE(tf)))
		dab_fatal(tf, 0, tf->tf_pc, NULL, NULL);

a670 1
	fault_pc = tf->tf_pc;
d675 3
a677 3
	if (__predict_false(fault_pc >= VM_MAXUSER_ADDRESS ||
	    (fault_pc < VM_MIN_ADDRESS && vector_page == ARM_VECTORS_LOW))) {
		sv.sival_ptr = (u_int32_t *)fault_pc;
d683 1
a683 1
	va = trunc_page(fault_pc);
d691 1
a691 1
	if (pmap_fault_fixup(map->pmap, va, VM_PROT_READ, 1))
d697 1
a697 1
		dab_fatal(tf, 0, tf->tf_pc, NULL, NULL);
d701 1
a701 1
	error = uvm_fault(map, va, 0, VM_PROT_READ);
d705 1
a705 1
	sv.sival_ptr = (u_int32_t *) fault_pc;
@


1.11
log
@Late spring cleaning of the arm code for old dusty bits we do not want to
keep:
- remove bootconfig parameter passing feature (unused).
- unifdef __PROG32 and remove all remains of arm26 code.
- remove ARMFPE support (unused).
- remove support for ARM2, ARM2AS, ARM3, ARM6, ARM7, ARM7TDMI and StrongARM
  processor families, and the related silicon bug workarounds (especially
  the SA-110 STM^ bug).
- remove cpu_functions no longer necessary after previous removals.
- remove ARM32_DISABLE_ALIGNMENT_FAULTS option (unused).
- make FIQ support conditional on option FIQ (unused, but may be eventually).

Discussed with drahn@@ and jasper@@ long ago, I was sitting on this commit for
no good reason.
@
text
@d1 1
a1 1
/*	$OpenBSD: fault.c,v 1.10 2007/05/15 16:02:18 drahn Exp $	*/
d177 2
a178 2
	far = cpu_faultaddress();
	fsr = cpu_faultstatus();
@


1.10
log
@External bus errors should not occur, so panic. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fault.c,v 1.9 2006/12/24 20:30:35 miod Exp $	*/
a114 6
#if defined(CPU_ARM3) || defined(CPU_ARM6) || \
    defined(CPU_ARM7) || defined(CPU_ARM7TDMI)
/* These CPUs may need data/prefetch abort fixups */
#define	CPU_ABORT_FIXUP_REQUIRED
#endif

a161 30
static __inline int
data_abort_fixup(trapframe_t *tf, u_int fsr, u_int far, struct proc *l)
{
#ifdef CPU_ABORT_FIXUP_REQUIRED
	int error;

	/* Call the cpu specific data abort fixup routine */
	error = cpu_dataabt_fixup(tf);
	if (__predict_true(error != ABORT_FIXUP_FAILED))
		return (error);

	/*
	 * Oops, couldn't fix up the instruction
	 */
	printf("data_abort_fixup: fixup for %s mode data abort failed.\n",
	    TRAP_USERMODE(tf) ? "user" : "kernel");
	printf("pc = 0x%08x, opcode 0x%08x, insn = ", tf->tf_pc,
	    *((u_int *)tf->tf_pc));
	disassemble(tf->tf_pc);

	/* Die now if this happened in kernel mode */
	if (!TRAP_USERMODE(tf))
		dab_fatal(tf, fsr, far, l, NULL);

	return (error);
#else
	return (ABORT_FIXUP_OK);
#endif /* CPU_ABORT_FIXUP_REQUIRED */
}

a249 15
	/* See if the cpu state needs to be fixed up */
	switch (data_abort_fixup(tf, fsr, far, p)) {
	case ABORT_FIXUP_RETURN:
		return;
	case ABORT_FIXUP_FAILED:
		/* Deliver a SIGILL to the process */
		sd.signo = SIGILL;
		sd.code = ILL_ILLOPC;
		sd.addr = far;
		sd.trap = fsr;
		goto do_trapsignal;
	default:
		break;
	}

a473 3
	/* See if the cpu state needs to be fixed up */
	(void) data_abort_fixup(tf, fsr, far, p);

a565 3
	/* See if the cpu state needs to be fixed up */
	(void) data_abort_fixup(tf, fsr, far, p);

a574 31
static __inline int
prefetch_abort_fixup(trapframe_t *tf)
{
#ifdef CPU_ABORT_FIXUP_REQUIRED
	int error;

	/* Call the cpu specific prefetch abort fixup routine */
	error = cpu_prefetchabt_fixup(tf);
	if (__predict_true(error != ABORT_FIXUP_FAILED))
		return (error);

	/*
	 * Oops, couldn't fix up the instruction
	 */
	printf(
	    "prefetch_abort_fixup: fixup for %s mode prefetch abort failed.\n",
	    TRAP_USERMODE(tf) ? "user" : "kernel");
	printf("pc = 0x%08x, opcode 0x%08x, insn = ", tf->tf_pc,
	    *((u_int *)tf->tf_pc));
	disassemble(tf->tf_pc);

	/* Die now if this happened in kernel mode */
	if (!TRAP_USERMODE(tf))
		dab_fatal(tf, 0, tf->tf_pc, NULL, NULL);

	return (error);
#else
	return (ABORT_FIXUP_OK);
#endif /* CPU_ABORT_FIXUP_REQUIRED */
}

a604 17

	/* See if the cpu state needs to be fixed up */
	switch (prefetch_abort_fixup(tf)) {
	case ABORT_FIXUP_RETURN:
		return;
	case ABORT_FIXUP_FAILED:
		/* Deliver a SIGILL to the process */
		sv.sival_ptr = (u_int32_t *) tf->tf_pc;
		trapsignal(p, SIGILL, BUS_ADRERR, ILL_ILLOPC, sv);

		p = curproc;
		p->p_addr->u_pcb.pcb_tf = tf;

		goto out;
	default:
		break;
	}
@


1.9
log
@Define PROC_PC. Then, since profiling information is being reported in
statclock(), do not bother doing this in userret() anymore. As a result,
userret() does not need its pc and ticks arguments, simplify.
@
text
@d1 1
a1 1
/*	$OpenBSD: fault.c,v 1.8 2006/05/26 17:06:39 miod Exp $	*/
d624 2
a625 1
	 * At this point, if the fault happened in kernel mode, we're toast
d627 1
a627 10
	if (!TRAP_USERMODE(tf))
		dab_fatal(tf, fsr, far, p, NULL);

	/* Deliver a bus error signal to the process */
	sd->signo = SIGBUS;
	sd->code = BUS_ADRERR;
	sd->addr = far;
	sd->trap = fsr;

	p->p_addr->u_pcb.pcb_tf = tf;
@


1.8
log
@Get rid of katelib.h, it was almost unused and is marked as deprecated anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: fault.c,v 1.7 2006/03/04 10:19:12 miod Exp $	*/
d443 1
a443 1
		userret(p, tf->tf_pc, p->p_sticks);
d770 1
a770 1
	userret(p, tf->tf_pc, p->p_sticks);
@


1.7
log
@Do not deliver SIGBUS twice.
@
text
@d1 1
a1 1
/*	$OpenBSD: fault.c,v 1.6 2004/12/30 23:41:07 drahn Exp $	*/
a94 1
#include <arm/katelib.h>
d312 1
a312 1
	     (ReadWord(tf->tf_pc) & 0x05200000) != 0x04200000))) {
d357 1
a357 1
		u_int insn = ReadWord(tf->tf_pc);
@


1.6
log
@#include cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: fault.c,v 1.5 2004/08/04 20:20:18 miod Exp $	*/
a518 2
	union sigval sv;

a536 3
	sv.sival_ptr = (u_int32_t *)far;
	trapsignal(p, SIGBUS, 0, BUS_ADRALN, sv);

d715 1
a715 1
		goto do_trapsignal;
d734 1
a734 1
		goto do_trapsignal;
a768 2

do_trapsignal:
@


1.5
log
@Remove the old fetch(9)/store(9) functions, since they are not used in
OpenBSD. This gives us a simpler and faster cpu_switch() as a bonus.

ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fault.c,v 1.4 2004/02/23 19:09:57 drahn Exp $	*/
d108 1
@


1.4
log
@Switch to the 3 arg version of userret to more closely match other OpenBSD
architectures.
@
text
@d1 1
a1 1
/*	$OpenBSD: fault.c,v 1.3 2004/02/03 15:42:19 drahn Exp $	*/
a110 2
extern char fusubailout[];

a253 7

	/* fusubailout is used by [fs]uswintr to avoid page faulting */
	if (__predict_false(pcb->pcb_onfault == fusubailout)) {
		tf->tf_r0 = EFAULT;
		tf->tf_pc = (register_t)pcb->pcb_onfault;
		return;
	}
@


1.3
log
@Remove debug print.
@
text
@d1 1
a1 1
/*	$OpenBSD: fault.c,v 1.2 2004/02/01 06:10:33 drahn Exp $	*/
d452 1
a452 1
		userret(p);
d786 1
a786 1
	userret(p);
@


1.3.2.1
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a237 2
			printf("data abort trap fsr %x far %x pc %x\n",
			fsr, far, tf->tf_pc);
@


1.3.2.2
log
@Merge with the trunk
@
text
@d238 2
d454 1
a454 1
		userret(p, tf->tf_pc, p->p_sticks);
d788 1
a788 1
	userret(p, tf->tf_pc, p->p_sticks);
@


1.2
log
@fix tags...
@
text
@d1 1
a1 1
/*	$OpenBSD: fault.c,v 1.1 2004/02/01 05:09:48 drahn Exp $	*/
a237 2
			printf("data abort trap fsr %x far %x pc %x\n",
			fsr, far, tf->tf_pc);
@


1.1
log
@Arm port, NetBSD codebase stripped down, 32bit only support.
@
text
@d1 2
a2 2
/*	$OpenBSD: fault.c,v 1.2 2004/01/29 16:17:16 drahn Exp $	*/
/*^I$NetBSD: fault.c,v 1.46 2004/01/21 15:39:21 skrll Exp $^I*/$
@

