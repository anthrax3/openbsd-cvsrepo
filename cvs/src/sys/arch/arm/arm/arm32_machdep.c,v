head	1.53;
access;
symbols
	OPENBSD_6_1_BASE:1.53
	OPENBSD_6_0:1.48.0.4
	OPENBSD_6_0_BASE:1.48
	OPENBSD_5_9:1.48.0.2
	OPENBSD_5_9_BASE:1.48
	OPENBSD_5_8:1.47.0.6
	OPENBSD_5_8_BASE:1.47
	OPENBSD_5_7:1.47.0.2
	OPENBSD_5_7_BASE:1.47
	OPENBSD_5_6:1.45.0.4
	OPENBSD_5_6_BASE:1.45
	OPENBSD_5_5:1.41.0.4
	OPENBSD_5_5_BASE:1.41
	OPENBSD_5_4:1.40.0.2
	OPENBSD_5_4_BASE:1.40
	OPENBSD_5_3:1.39.0.6
	OPENBSD_5_3_BASE:1.39
	OPENBSD_5_2:1.39.0.4
	OPENBSD_5_2_BASE:1.39
	OPENBSD_5_1_BASE:1.39
	OPENBSD_5_1:1.39.0.2
	OPENBSD_5_0:1.38.0.2
	OPENBSD_5_0_BASE:1.38
	OPENBSD_4_9:1.36.0.2
	OPENBSD_4_9_BASE:1.36
	OPENBSD_4_8:1.35.0.2
	OPENBSD_4_8_BASE:1.35
	OPENBSD_4_7:1.32.0.2
	OPENBSD_4_7_BASE:1.32
	OPENBSD_4_6:1.29.0.8
	OPENBSD_4_6_BASE:1.29
	OPENBSD_4_5:1.29.0.4
	OPENBSD_4_5_BASE:1.29
	OPENBSD_4_4:1.29.0.2
	OPENBSD_4_4_BASE:1.29
	OPENBSD_4_3:1.27.0.4
	OPENBSD_4_3_BASE:1.27
	OPENBSD_4_2:1.27.0.2
	OPENBSD_4_2_BASE:1.27
	OPENBSD_4_1:1.22.0.4
	OPENBSD_4_1_BASE:1.22
	OPENBSD_4_0:1.22.0.2
	OPENBSD_4_0_BASE:1.22
	OPENBSD_3_9:1.19.0.2
	OPENBSD_3_9_BASE:1.19
	OPENBSD_3_8:1.15.0.2
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.9.0.2
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.5.0.2
	OPENBSD_3_6_BASE:1.5
	SMP_SYNC_A:1.5
	SMP_SYNC_B:1.5
	OPENBSD_3_5:1.4.0.2
	OPENBSD_3_5_BASE:1.4
	SMP:1.3.0.2;
locks; strict;
comment	@ * @;


1.53
date	2017.01.13.09.18.11;	author fcambus;	state Exp;
branches;
next	1.52;
commitid	C556oRR1TXBPfD4D;

1.52
date	2016.09.23.11.38.21;	author kettenis;	state Exp;
branches;
next	1.51;
commitid	sEb5w6mPrtN5hPUF;

1.51
date	2016.09.18.14.32.54;	author deraadt;	state Exp;
branches;
next	1.50;
commitid	oqDjDsCocwWgzHpt;

1.50
date	2016.09.03.15.07.06;	author guenther;	state Exp;
branches;
next	1.49;
commitid	7GsxlyEdJ6zHn1Pg;

1.49
date	2016.08.08.19.27.12;	author kettenis;	state Exp;
branches;
next	1.48;
commitid	9cxQ5QuyMM8g8ZRp;

1.48
date	2016.01.31.00.14.50;	author jsg;	state Exp;
branches;
next	1.47;
commitid	pbLjedMudUFrVMk6;

1.47
date	2015.01.12.16.33.31;	author deraadt;	state Exp;
branches;
next	1.46;
commitid	A44BjxYQVmvEK2uf;

1.46
date	2014.11.16.12.30.56;	author deraadt;	state Exp;
branches;
next	1.45;
commitid	yv0ECmCdICvq576h;

1.45
date	2014.07.10.19.44.35;	author uebayasi;	state Exp;
branches;
next	1.44;
commitid	G9kcweAj8sZh7Wme;

1.44
date	2014.07.10.13.34.32;	author uebayasi;	state Exp;
branches;
next	1.43;
commitid	xpsLTYRIkonFtkr1;

1.43
date	2014.05.08.21.17.00;	author miod;	state Exp;
branches;
next	1.42;

1.42
date	2014.04.03.10.17.34;	author mpi;	state Exp;
branches;
next	1.41;

1.41
date	2013.09.12.11.42.22;	author patrick;	state Exp;
branches;
next	1.40;

1.40
date	2013.03.27.00.18.19;	author patrick;	state Exp;
branches;
next	1.39;

1.39
date	2011.09.20.22.02.10;	author miod;	state Exp;
branches;
next	1.38;

1.38
date	2011.06.24.19.47.48;	author naddy;	state Exp;
branches;
next	1.37;

1.37
date	2011.06.05.19.41.09;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2010.11.28.20.44.15;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2010.06.27.13.28.46;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2010.06.27.03.03.48;	author thib;	state Exp;
branches;
next	1.33;

1.33
date	2010.06.09.15.44.17;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2009.08.11.19.17.16;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2009.08.11.18.46.32;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2009.08.09.21.03.49;	author blambert;	state Exp;
branches;
next	1.29;

1.29
date	2008.05.04.09.57.46;	author martin;	state Exp;
branches;
next	1.28;

1.28
date	2008.03.23.17.05.41;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2007.05.30.17.13.29;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2007.05.29.21.09.43;	author robert;	state Exp;
branches;
next	1.25;

1.25
date	2007.05.26.20.56.49;	author drahn;	state Exp;
branches;
next	1.24;

1.24
date	2007.05.26.20.26.50;	author pedro;	state Exp;
branches;
next	1.23;

1.23
date	2007.05.23.20.33.46;	author pvalchev;	state Exp;
branches;
next	1.22;

1.22
date	2006.07.12.17.29.53;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2006.05.26.17.06.39;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2006.03.15.21.41.37;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2006.01.17.20.30.10;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2005.12.27.18.51.03;	author drahn;	state Exp;
branches;
next	1.17;

1.17
date	2005.12.21.20.36.00;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2005.12.20.19.23.57;	author drahn;	state Exp;
branches;
next	1.15;

1.15
date	2005.08.06.14.26.51;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2005.08.01.15.42.46;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2005.04.26.01.12.27;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2005.04.26.01.09.00;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2005.04.24.18.55.49;	author uwe;	state Exp;
branches;
next	1.10;

1.10
date	2005.03.29.20.00.16;	author uwe;	state Exp;
branches;
next	1.9;

1.9
date	2005.03.07.02.08.45;	author uwe;	state Exp;
branches;
next	1.8;

1.8
date	2005.03.03.22.55.00;	author uwe;	state Exp;
branches;
next	1.7;

1.7
date	2005.01.24.22.20.32;	author uwe;	state Exp;
branches;
next	1.6;

1.6
date	2005.01.21.16.22.32;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2004.05.19.03.17.06;	author drahn;	state Exp;
branches;
next	1.4;

1.4
date	2004.02.26.04.58.38;	author drahn;	state Exp;
branches;
next	1.3;

1.3
date	2004.02.12.04.13.02;	author drahn;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2004.02.01.06.10.33;	author drahn;	state Exp;
branches;
next	1.1;

1.1
date	2004.02.01.05.09.48;	author drahn;	state Exp;
branches;
next	;

1.3.2.1
date	2004.02.22.22.08.19;	author niklas;	state Exp;
branches;
next	1.3.2.2;

1.3.2.2
date	2004.06.05.23.10.44;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.53
log
@Ansify cpu_sysctl() on alpha, arm, arm64, luna88k and sparc64.

OK mpi@@
@
text
@/*	$OpenBSD: arm32_machdep.c,v 1.52 2016/09/23 11:38:21 kettenis Exp $	*/
/*	$NetBSD: arm32_machdep.c,v 1.42 2003/12/30 12:33:15 pk Exp $	*/

/*
 * Copyright (c) 1994-1998 Mark Brinicombe.
 * Copyright (c) 1994 Brini.
 * All rights reserved.
 *
 * This code is derived from software written for Brini by Mark Brinicombe
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Mark Brinicombe
 *	for the NetBSD Project.
 * 4. The name of the company nor the name of the author may be used to
 *    endorse or promote products derived from this software without specific
 *    prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * Machine dependant functions for kernel setup
 *
 * Created      : 17/09/94
 * Updated	: 18/04/01 updated for new wscons
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/reboot.h>
#include <sys/proc.h>
#include <sys/user.h>
#include <sys/kernel.h>
#include <sys/mbuf.h>
#include <sys/mount.h>
#include <sys/buf.h>
#include <sys/msg.h>
#include <sys/msgbuf.h>
#include <sys/device.h>
#include <sys/sysctl.h>

#include <uvm/uvm_extern.h>

#include <dev/cons.h>

#include <arm/machdep.h>
#include <machine/conf.h>

#ifdef CONF_HAVE_APM
#include "apm.h"
#else
#define NAPM	0
#endif
#include "rd.h"

struct vm_map *exec_map = NULL;
struct vm_map *phys_map = NULL;

extern int physmem;

struct uvm_constraint_range  dma_constraint = { 0x0, (paddr_t)-1 };
struct uvm_constraint_range *uvm_md_constraints[] = { NULL };

int cold = 1;

pv_addr_t kernelstack;

/* the following is used externally (sysctl_hw) */
char	machine[] = MACHINE;		/* from <machine/param.h> */

/* Statically defined CPU info. */
struct cpu_info cpu_info_primary;
struct cpu_info *cpu_info_list = &cpu_info_primary;

#ifdef MULTIPROCESSOR
/*
 * Array of CPU info structures.  Must be statically-allocated because
 * curproc, etc. are used early.
 */
struct cpu_info *cpu_info[MAXCPUS] = { &cpu_info_primary };
#endif

caddr_t	msgbufaddr;
extern paddr_t msgbufphys;

struct user *proc0paddr;

#ifdef APERTURE
int allowaperture = 0;
#endif

struct consdev *cn_tab;

/* Prototypes */

void data_abort_handler		(trapframe_t *frame);
void prefetch_abort_handler	(trapframe_t *frame);
extern void configure		(void);

/*
 * arm32_vector_init:
 *
 *	Initialize the vector page, and select whether or not to
 *	relocate the vectors.
 *
 *	NOTE: We expect the vector page to be mapped at its expected
 *	destination.
 */
void
arm32_vector_init(vaddr_t va, int which)
{
	extern unsigned int page0[], page0_data[];
	unsigned int *vectors = (unsigned int *) va;
	unsigned int *vectors_data = vectors + (page0_data - page0);
	int vec;

	/*
	 * Loop through the vectors we're taking over, and copy the
	 * vector's insn and data word.
	 */
	for (vec = 0; vec < ARM_NVEC; vec++) {
		if ((which & (1 << vec)) == 0) {
			/* Don't want to take over this vector. */
			continue;
		}
		vectors[vec] = page0[vec];
		vectors_data[vec] = page0_data[vec];
	}

	/* Now sync the vectors. */
	cpu_icache_sync_range(va, (ARM_NVEC * 2) * sizeof(u_int));

	vector_page = va;

	if (va == ARM_VECTORS_HIGH) {
		/*
		 * Assume the MD caller knows what it's doing here, and
		 * really does want the vector page relocated.
		 *
		 * Note: This has to be done here (and not just in
		 * cpu_setup()) because the vector page needs to be
		 * accessible *before* main() is called.
		 * Think ddb(9) ...
		 *
		 * NOTE: If the CPU control register is not readable,
		 * this will totally fail!  We'll just assume that
		 * any system that has high vector support has a
		 * readable CPU control register, for now.  If we
		 * ever encounter one that does not, we'll have to
		 * rethink this.
		 */
		cpu_control(CPU_CONTROL_VECRELOC, CPU_CONTROL_VECRELOC);
	}
}

/*
 * Debug function just to park the CPU
 */

void
halt()
{
	while (1)
		cpu_sleep(0);
}


/* Sync the discs and unmount the filesystems */

void
bootsync(int howto)
{
	static int bootsyncdone = 0;

	if (bootsyncdone)
		return;

	bootsyncdone = 1;

	/* Make sure we can still manage to do things */
	if (__get_cpsr() & PSR_I) {
		/*
		 * If we get here then boot has been called without RB_NOSYNC
		 * and interrupts were disabled. This means the boot() call
		 * did not come from a user process e.g. shutdown, but must
		 * have come from somewhere in the kernel.
		 */
		IRQenable;
		printf("Warning IRQ's disabled during boot()\n");
	}

	vfs_shutdown();

	if ((howto & RB_TIMEBAD) == 0) {
		resettodr();
	} else {
		printf("WARNING: not updating battery clock\n");
	}
}

/*
 * void cpu_startup(void)
 *
 * Machine dependant startup code. 
 *
 */
void
cpu_startup()
{
	u_int loop;
	paddr_t minaddr;
	paddr_t maxaddr;

	/* Lock down zero page */
	vector_page_setprot(PROT_READ | PROT_EXEC);

	/*
	 * Give pmap a chance to set up a few more things now the vm
	 * is initialised
	 */
	pmap_postinit();

	/*
	 * Allow per-board specific initialization
	 */
	board_startup();

	/*
	 * Initialize error message buffer (at end of core).
	 */

	/* msgbufphys was setup during the secondary boot strap */
	for (loop = 0; loop < atop(MSGBUFSIZE); ++loop)
		pmap_kenter_pa((vaddr_t)msgbufaddr + loop * PAGE_SIZE,
		    msgbufphys + loop * PAGE_SIZE, PROT_READ | PROT_WRITE);
	pmap_update(pmap_kernel());
	initmsgbuf(msgbufaddr, round_page(MSGBUFSIZE));

	/*
	 * Identify ourselves for the msgbuf (everything printed earlier will
	 * not be buffered).
	 */
	printf("%s", version);

	printf("real mem  = %lu (%luMB)\n", ptoa(physmem),
	    ptoa(physmem)/1024/1024);

	/*
	 * Allocate a submap for exec arguments.  This map effectively
	 * limits the number of processes exec'ing at any time.
	 */
	minaddr = vm_map_min(kernel_map);
	exec_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
				   16*NCARGS, VM_MAP_PAGEABLE, FALSE, NULL);

	/*
	 * Allocate a submap for physio
	 */
	phys_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
				   VM_PHYS_SIZE, 0, FALSE, NULL);

	/*
	 * Set up buffers, so they can be used to read disk labels.
	 */
	bufinit(); 

	printf("avail mem = %lu (%luMB)\n", ptoa(uvmexp.free),
	    ptoa(uvmexp.free)/1024/1024);

	curpcb = &proc0.p_addr->u_pcb;
	curpcb->pcb_flags = 0;
	curpcb->pcb_un.un_32.pcb32_und_sp = (u_int)proc0.p_addr +
	    USPACE_UNDEF_STACK_TOP;
	curpcb->pcb_un.un_32.pcb32_sp = (u_int)proc0.p_addr +
	    USPACE_SVC_STACK_TOP;
	pmap_set_pcb_pagedir(pmap_kernel(), curpcb);

        curpcb->pcb_tf = (struct trapframe *)curpcb->pcb_un.un_32.pcb32_sp - 1;
}

/*
 * machine dependent system variables.
 */

int
cpu_sysctl(int *name, u_int namelen, void *oldp, size_t *oldlenp, void *newp,
    size_t newlen, struct proc *p)
{
#if NAPM > 0
	extern int cpu_apmwarn;
#endif

	/* all sysctl names at this level are terminal */
	if (namelen != 1)
		return (ENOTDIR);		/* overloaded */

	switch (name[0]) {
	case CPU_CONSDEV: {
		dev_t consdev;
		if (cn_tab != NULL)
			consdev = cn_tab->cn_dev;
		else
			consdev = NODEV;
		return (sysctl_rdstruct(oldp, oldlenp, newp, &consdev,
			sizeof consdev));
	}

	case CPU_ALLOWAPERTURE:
#ifdef APERTURE
		if (securelevel > 0)
			return (sysctl_int_lower(oldp, oldlenp, newp, newlen,
			    &allowaperture));
		else
			return (sysctl_int(oldp, oldlenp, newp, newlen,
			    &allowaperture));
#else
		return (sysctl_rdint(oldp, oldlenp, newp, 0));
#endif

#if NAPM > 0
	case CPU_APMWARN:
		return (sysctl_int(oldp, oldlenp, newp, newlen, &cpu_apmwarn));
#endif

	default:
		return (EOPNOTSUPP);
	}
	/* NOTREACHED */
}
@


1.52
log
@Use "%s" to print the version string.  Avoids a "format string is not a
string literal" warning from clang and matches what we do on amd64.
@
text
@d1 1
a1 1
/*	$OpenBSD: arm32_machdep.c,v 1.51 2016/09/18 14:32:54 deraadt Exp $	*/
d303 2
a304 8
cpu_sysctl(name, namelen, oldp, oldlenp, newp, newlen, p)
	int *name;
	u_int namelen;
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
	struct proc *p;
@


1.51
log
@option INSECURE is obsolete
@
text
@d1 1
a1 1
/*	$OpenBSD: arm32_machdep.c,v 1.50 2016/09/03 15:07:06 guenther Exp $	*/
d260 1
a260 1
	printf(version);
@


1.50
log
@Remove zaurus sysctl bits
@
text
@d1 1
a1 1
/*	$OpenBSD: arm32_machdep.c,v 1.49 2016/08/08 19:27:12 kettenis Exp $	*/
a105 3
#ifdef INSECURE
int allowaperture = 1;
#else
a106 1
#endif
@


1.49
log
@Move the cpu_setup() call to the end of initarm().  On Cortex-A53 processors
atomic instructions don't work unless the data cache is enabled.  This happens
in cpu_setup(), but that gets currently called from cpu_startup() which runs
after a number of kernel subsystems have been initialized.  Since some of
these subsystems use locks, which need atomic instructions, we fault on
Cortex-A53.  Since at the end of initarm() we're done setting up the pmap
and initializing other low-level sense, calling cpu_setup() here makes much
more sense.

Remove setting up proc0paddr as well from cpu_startup(), since that already
happens in initarm().

Tested on zaurus by deraadt@@.

ok jsg@@, patrick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arm32_machdep.c,v 1.48 2016/01/31 00:14:50 jsg Exp $	*/
a112 5
#if defined(__zaurus__)
int lid_suspend = 1;
extern int xscale_maxspeed;
#endif

a349 18
#endif
#if defined(__zaurus__)
	case CPU_LIDSUSPEND:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		    &lid_suspend));
	case CPU_MAXSPEED:
	{
		extern void pxa2x0_maxspeed(int *);
		int err = EINVAL;

		if (!newp && newlen == 0)
			return (sysctl_int(oldp, oldlenp, 0, 0,
			    &xscale_maxspeed));
		err = (sysctl_int(oldp, oldlenp, newp, newlen,
		    &xscale_maxspeed));
		pxa2x0_maxspeed(&xscale_maxspeed);
		return err;
	}
@


1.48
log
@Switch from PSR_X_bit and X32_bit PSR macro names to just PSR_X.
This matches FreeBSD and makes things a bit more consistent.
Discussed with Patrick.
@
text
@d1 1
a1 1
/*	$OpenBSD: arm32_machdep.c,v 1.47 2015/01/12 16:33:31 deraadt Exp $	*/
d168 1
a168 1
		 * accessible *before* cpu_startup() is called.
a238 6

	proc0paddr = (struct user *)kernelstack.pv_va;
	proc0.p_addr = proc0paddr;

	/* Set the cpu control register */
	cpu_setup();
@


1.47
log
@Enable lid suspends by default in the kernel, and remove the question from
the installer.  We used a full release cycle to learn that suspend/resume
is reliable enough for this default.  Personal policy can disable this using
machdep.lidsuspend=0 in /etc/sysctl.conf
ok more people begging, and less people whining
@
text
@d1 1
a1 1
/*	$OpenBSD: arm32_machdep.c,v 1.46 2014/11/16 12:30:56 deraadt Exp $	*/
d207 1
a207 1
	if (__get_cpsr() & I32_bit) {
@


1.46
log
@Replace a plethora of historical protection options with just
PROT_NONE, PROT_READ, PROT_WRITE, and PROT_EXEC from mman.h.
PROT_MASK is introduced as the one true way of extracting those bits.
Remove UVM_ADV_* wrapper, using the standard names.
ok doug guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: arm32_machdep.c,v 1.45 2014/07/10 19:44:35 uebayasi Exp $	*/
d114 1
a114 1
int lid_suspend;
@


1.45
log
@KNF.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d247 1
a247 1
	vector_page_setprot(VM_PROT_READ|VM_PROT_EXECUTE);
d267 1
a267 1
		    msgbufphys + loop * PAGE_SIZE, VM_PROT_READ|VM_PROT_WRITE);
@


1.44
log
@boot(): Remove comments about RB_TIMEBAD to reduce diffs

RB_TIMEBAD is documented well enough that the comment is not needed.  sparc64
does slightly different and its comment is left with XXX.

OK deraadt@@ miod@@
@
text
@d201 2
a202 1
	if (bootsyncdone) return;
@


1.43
log
@Format string fixes and removal of -Wno-format for arm kernels.
@
text
@d1 1
a1 1
/*	$OpenBSD: arm32_machdep.c,v 1.42 2014/04/03 10:17:34 mpi Exp $	*/
a218 5
	/*
	 * If we've been adjusting the clock, the todr
	 * will be out of synch; adjust it now unless
	 * the system has been sitting in ddb.
	 */
@


1.42
log
@More uvm_extern.h cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: arm32_machdep.c,v 1.41 2013/09/12 11:42:22 patrick Exp $	*/
d281 1
a281 1
	printf("real mem  = %u (%uMB)\n", ptoa(physmem),
d303 1
a303 1
	printf("avail mem = %lu (%uMB)\n", ptoa(uvmexp.free),
@


1.41
log
@Rename cpu_info_store to cpu_info_primary.  Create an array of cpu_infos
for SMP, like on amd64.  Add some SMP defines.

ok rapha@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arm32_machdep.c,v 1.40 2013/03/27 00:18:19 patrick Exp $	*/
a56 1
#include <uvm/uvm.h>
d58 2
@


1.40
log
@Mark vector page as executable and fix a cast.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arm32_machdep.c,v 1.39 2011/09/20 22:02:10 miod Exp $	*/
d87 11
a97 2
/* Our exported CPU info; we can have only one. */
struct cpu_info cpu_info_store;
@


1.39
log
@Late spring cleaning of the arm code for old dusty bits we do not want to
keep:
- remove bootconfig parameter passing feature (unused).
- unifdef __PROG32 and remove all remains of arm26 code.
- remove ARMFPE support (unused).
- remove support for ARM2, ARM2AS, ARM3, ARM6, ARM7, ARM7TDMI and StrongARM
  processor families, and the related silicon bug workarounds (especially
  the SA-110 STM^ bug).
- remove cpu_functions no longer necessary after previous removals.
- remove ARM32_DISABLE_ALIGNMENT_FAULTS option (unused).
- make FIQ support conditional on option FIQ (unused, but may be eventually).

Discussed with drahn@@ and jasper@@ long ago, I was sitting on this commit for
no good reason.
@
text
@d1 1
a1 1
/*	$OpenBSD: arm32_machdep.c,v 1.38 2011/06/24 19:47:48 naddy Exp $	*/
d129 1
a129 1
	unsigned int *vectors = (int *) va;
d241 1
a241 1
	vector_page_setprot(VM_PROT_READ);
@


1.38
log
@machdep.kbdreset enables a shutdown by Ctrl-Alt-Del on amd64 and
i386.  Stop abusing it on other archs for controling a shutdown by
pressing the soft power button:

* Add a MI sysctl hw.allowpowerdown; if set to 1 (the default) it
  allows a power button shutdown.
* Make acpi(4)/acpibtn(4) honor hw.allowpowerdown.
* Switch the various power button intercepts on landisk, sgi, sparc64
  and zaurus over to hw.allowpowerdown.
* Garbage collect the machdep.kbdreset sysctl on all archs other than
  amd64 and i386.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arm32_machdep.c,v 1.37 2011/06/05 19:41:09 deraadt Exp $	*/
a62 1
#include <machine/bootconfig.h>
d238 1
a238 1
	cpu_setup(boot_args);
@


1.37
log
@Move the bufcachepercent setting code to MI locations -- set it to 42%
for now; that is unlikely to hit some of the remaining starvation bugs.
Repair the bufpages calculation too; i386 was doing it ahead of time
(incorrectly) and then re-calculating it.
ok thib
@
text
@d1 1
a1 1
/*	$OpenBSD: arm32_machdep.c,v 1.36 2010/11/28 20:44:15 miod Exp $	*/
a104 2
/* Permit console keyboard to do a nice halt. */
int kbd_reset;
a357 6
	case CPU_KBDRESET:
		if (securelevel > 0)
			return (sysctl_rdint(oldp, oldlenp, newp,
			    kbd_reset));
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		    &kbd_reset));
@


1.36
log
@Get rid of machdep.debug, machdep.booted_device and machdep.booted_kernel
sysctl. Only the first one is really implemented, and it only matters on
older processor flavours we don't run on (and don't want to), so this was
just dead weight.
@
text
@d1 1
a1 1
/*	$OpenBSD: arm32_machdep.c,v 1.35 2010/06/27 13:28:46 miod Exp $	*/
a76 11

#ifndef BUFCACHEPERCENT
#define BUFCACHEPERCENT 5
#endif

#ifdef  BUFPAGES
int     bufpages = BUFPAGES;
#else
int     bufpages = 0;
#endif
int     bufcachepercent = BUFCACHEPERCENT;
@


1.35
log
@If you include <uvm/uvm.h>, you do not need to include any other <uvm/uvm_foo.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: arm32_machdep.c,v 1.34 2010/06/27 03:03:48 thib Exp $	*/
a104 2
int kernel_debug = 0;

a106 3
/* exported variable to be filled in by the bootloaders */
char *booted_kernel;

a343 3
	case CPU_DEBUG:
		return(sysctl_int(oldp, oldlenp, newp, newlen, &kernel_debug));

a351 6
	}
	case CPU_BOOTED_KERNEL: {
		if (booted_kernel != NULL && booted_kernel[0] != '\0')
			return sysctl_rdstring(oldp, oldlenp, newp,
			    booted_kernel);
		return (EOPNOTSUPP);
@


1.34
log
@uvm constraints. Add two mandatory MD symbols, uvm_md_constraints
which contains the constraints for DMA/memory allocation for each
architecture, and dma_constraints which contains the range of addresses
that are dma accessable by the system.

This is based on ariane@@'s physcontig diff, with lots of bugfixes and
additions the following additions by my self:

Introduce a new function pool_set_constraints() which sets the address
range for which we allocate pages for the pool from, this is now used
for the mbuf/mbuf cluster pools to keep them dma accessible.

The !direct archs no longer stuff pages into the kernel object in
uvm_km_getpage_pla but rather do a pmap_extract() in uvm_km_putpages.

Tested heavily by my self on i386, amd64 and sparc64. Some tests on
alpha and SGI.

"commit it" beck, art, oga, deraadt
"i like the diff" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: arm32_machdep.c,v 1.32 2009/08/11 19:17:16 miod Exp $	*/
a57 1
#include <uvm/uvm_extern.h>
@


1.33
log
@Move declaration of cn_tab from dev/cons.c to dev/cninit.c, or appropriate
md files for ports which do not use dev/cninit.c. This gets rid of a common
at kernel link time.
feedback drahn@@ ok deraadt@@
@
text
@d57 1
d89 3
@


1.32
log
@Do not bother initializing bufpages in the md code if the computation is
exactly the same the mi could will use if bufinit() is invoked with
bufpages == 0.
@
text
@d1 1
a1 1
/*	$OpenBSD: arm32_machdep.c,v 1.31 2009/08/11 18:46:32 miod Exp $	*/
d123 2
@


1.31
log
@With the SysV memory allocation changes, allocsys() doesn't do anything
anymore. Get rid of it completely.
@
text
@d1 1
a1 1
/*	$OpenBSD: arm32_machdep.c,v 1.30 2009/08/09 21:03:49 blambert Exp $	*/
a286 13

	/*
	 * Determine how many buffers to allocate.
	 * We allocate bufcachepercent% of memory for buffer space.
	 */
	if (bufpages == 0)
		bufpages = physmem * bufcachepercent / 100;

	/* Restrict to at most 25% filled kvm */
	if (bufpages >
	    (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) / PAGE_SIZE / 4) 
		bufpages = (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) /
		    PAGE_SIZE / 4;
@


1.30
log
@Forgot to commit this bit for the SysV message queue cleanup.

Found by miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arm32_machdep.c,v 1.29 2008/05/04 09:57:46 martin Exp $	*/
a76 1
caddr_t allocsys(caddr_t);
a246 2
	caddr_t sysbase;
	caddr_t size;
a288 13
	 * Find out how much space we need, allocate it,
	 * and then give everything true virtual addresses.
	 */
	size = allocsys(NULL);
	sysbase = (caddr_t)uvm_km_zalloc(kernel_map, round_page((vaddr_t)size));
	if (sysbase == 0)
		panic(
		    "cpu_startup: no room for system tables; %d bytes required",
		    (u_int)size);
	if ((caddr_t)((allocsys(sysbase) - sysbase)) != size)
		panic("cpu_startup: system table size inconsistency");

	/*
a420 19
}

/*
 * Allocate space for system data structures.  We are given
 * a starting virtual address and we return a final virtual
 * address; along the way we set each data structure pointer.
 *
 * We call allocsys() with 0 to find out how much space we want,
 * allocate that much and fill it with zeroes, and then call
 * allocsys() again with the correct base virtual address.
 */
caddr_t
allocsys(caddr_t v)
{

#define	valloc(name, type, num) \
	    v = (caddr_t)(((name) = (type *)v) + (num))

	return v;
@


1.29
log
@convert arm and mips64 platforms to ptoa/atop

tested by maja@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arm32_machdep.c,v 1.28 2008/03/23 17:05:41 deraadt Exp $	*/
a453 7

#ifdef SYSVMSG
	valloc(msgpool, char, msginfo.msgmax);
	valloc(msgmaps, struct msgmap, msginfo.msgseg);
	valloc(msghdrs, struct msg, msginfo.msgtql);
	valloc(msqids, struct msqid_ds, msginfo.msgmni);
#endif
@


1.28
log
@setroot() is supposed to be safe in all cases, so kill the special cases
for RB_DFLTROOT; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: arm32_machdep.c,v 1.27 2007/05/30 17:13:29 miod Exp $	*/
d276 1
a276 1
	for (loop = 0; loop < btoc(MSGBUFSIZE); ++loop)
d288 2
a289 2
	printf("real mem  = %u (%uMB)\n", ctob(physmem),
	    ctob(physmem)/1024/1024);
@


1.27
log
@Missed one minaddr initialization before invoking uvm_km_suballoc().
@
text
@d1 1
a1 1
/*	$OpenBSD: arm32_machdep.c,v 1.26 2007/05/29 21:09:43 robert Exp $	*/
a280 9

	/*
	 * Look at arguments passed to us and compute boothowto.
	 * Default to SINGLE and ASKNAME if no args or
	 * SINGLE and DFLTROOT if this is a ramdisk kernel.
	 */
#ifdef RAMDISK_HOOKS
	boothowto = RB_SINGLE | RB_DFLTROOT;
#endif /* RAMDISK_HOOKS */
@


1.26
log
@Make use of struct wsmouse_calibcoords and add ioctl support
for getting and passing calibration values instead of using
sysctl.
Move the scale struct to uts_softc so that each device can have
it's own values instead of using the global one.
Remove the two MD sysctl (ztsscale and ztsrawmode).

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arm32_machdep.c,v 1.25 2007/05/26 20:56:49 drahn Exp $	*/
d330 1
@


1.25
log
@Remove nbuf count (was missed by pedro)
@
text
@d1 1
a1 1
/*	$OpenBSD: arm32_machdep.c,v 1.24 2007/05/26 20:26:50 pedro Exp $	*/
a121 10

/* Touch pad scaling disable flag and scaling parameters. */
extern int zts_rawmode;
struct ztsscale {
	int ts_minx;
	int ts_maxx;
	int ts_miny;
	int ts_maxy;
};
extern struct ztsscale zts_scale;
a416 1
#include "zts.h"
a437 39
	}
		
	case CPU_ZTSRAWMODE:
#if NZTS > 0
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		    &zts_rawmode));
#else
		return (EINVAL);
#endif /* NZTS > 0 */
	case CPU_ZTSSCALE:
	{
		int err = EINVAL;
#if NZTS > 0
		struct ztsscale *p = newp;
		struct ztsscale ts;
		int s;

		if (!newp && newlen == 0)
			return (sysctl_struct(oldp, oldlenp, 0, 0,
			    &zts_scale, sizeof zts_scale));

		if (!(newlen == sizeof zts_scale &&
		    p->ts_minx < p->ts_maxx && p->ts_miny < p->ts_maxy &&
		    p->ts_minx >= 0 && p->ts_maxx >= 0 &&
		    p->ts_miny >= 0 && p->ts_maxy >= 0 &&
		    p->ts_minx < 32768 && p->ts_maxx < 32768 &&
		    p->ts_miny < 32768 && p->ts_maxy < 32768))
			return (EINVAL);

		ts = zts_scale;
		err = sysctl_struct(oldp, oldlenp, newp, newlen,
		    &ts, sizeof ts);
		if (err == 0) {
			s = splhigh();
			zts_scale = ts;
			splx(s);
		}
#endif /* NZTS > 0 */
		return (err);
@


1.24
log
@Dynamic buffer cache. Initial diff from mickey@@, okay art@@ beck@@ toby@@
deraadt@@ dlg@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: arm32_machdep.c,v 1.23 2007/05/23 20:33:46 pvalchev Exp $	*/
a355 2
	printf("using %d buffers containing %u bytes (%uK) of memory\n",
	    nbuf, bufpages * PAGE_SIZE, bufpages * PAGE_SIZE / 1024);
@


1.23
log
@Print real/available memory in MB as well as bytes in dmesg, and unify
architectures to print it the same way.
ok henning, miod; i386 part from tom
@
text
@d1 1
a1 1
/*	$OpenBSD: arm32_machdep.c,v 1.22 2006/07/12 17:29:53 miod Exp $	*/
a78 6
#ifdef  NBUF
int     nbuf = NBUF;
#else
int     nbuf = 0;
#endif

a259 2
	vsize_t bufsize;
	int base, residual;
d323 6
a328 22
   	/*
	 * Now allocate buffers proper.  They are different than the above
	 * in that they usually occupy more virtual memory than physical.
	 */
	bufsize = MAXBSIZE * nbuf;
	if (uvm_map(kernel_map, (vaddr_t *)&buffers, round_page(bufsize),
	    NULL, UVM_UNKNOWN_OFFSET, 0,
	    UVM_MAPFLAG(UVM_PROT_NONE, UVM_PROT_NONE, UVM_INH_NONE,
	    UVM_ADV_NORMAL, 0)) != 0)
		panic("cpu_startup: cannot allocate UVM space for buffers");
	minaddr = (vaddr_t)buffers;
	if ((bufpages / nbuf) >= btoc(MAXBSIZE)) {
		/* don't want to alloc more physical mem than needed */
		bufpages = btoc(MAXBSIZE) * nbuf;
	}

	base = bufpages / nbuf;
	residual = bufpages % nbuf;
	for (loop = 0; loop < nbuf; ++loop) {
		vsize_t curbufsize;
		vaddr_t curbuf;
		struct vm_page *pg;
d330 5
a334 20
		/*
		 * Each buffer has MAXBSIZE bytes of VM space allocated.  Of
		 * that MAXBSIZE space, we allocate and map (base+1) pages
		 * for the first "residual" buffers, and then we allocate
		 * "base" pages for the rest.
		 */
		curbuf = (vaddr_t) buffers + (loop * MAXBSIZE);
		curbufsize = NBPG * ((loop < residual) ? (base+1) : base);

		while (curbufsize) {
			pg = uvm_pagealloc(NULL, 0, NULL, 0);
			if (pg == NULL)
				panic("cpu_startup: not enough memory for buffer cache");
			pmap_kenter_pa(curbuf, VM_PAGE_TO_PHYS(pg),
				VM_PROT_READ|VM_PROT_WRITE);
			curbuf += PAGE_SIZE;
			curbufsize -= PAGE_SIZE;
		}
	}
	pmap_update(pmap_kernel());
a520 26
	/*
	 * Determine how many buffers to allocate.  We use 10% of the
	 * first 2MB of memory, and 5% of the rest, with a minimum of 16
	 * buffers.  We allocate 1/2 as many swap buffer headers as file
	 * i/o buffers.
	 */
	if (bufpages == 0) {
		bufpages = (btoc(2 * 1024 * 1024) + physmem) *
		    bufcachepercent / 100;
	}
	if (nbuf == 0) {
		nbuf = bufpages;
		if (nbuf < 16)
			nbuf = 16;
	}

	/* Restrict to at most 35% filled kvm */
	/* XXX - This needs UBC... */
	if (nbuf >
	    (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) / MAXBSIZE * 35 / 100) 
		nbuf = (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) /
		    MAXBSIZE * 35 / 100;

	/* More buffer pages than fits into the buffers is senseless.  */
	if (bufpages > nbuf * MAXBSIZE / PAGE_SIZE)
		bufpages = nbuf * MAXBSIZE / PAGE_SIZE;
a521 1
	valloc(buf, struct buf, nbuf);
@


1.22
log
@Turn GetCPSR() into an inline get_cpsr(), and remove more dead code.
@
text
@d1 1
a1 1
/*	$OpenBSD: arm32_machdep.c,v 1.21 2006/05/26 17:06:39 miod Exp $	*/
d315 2
a316 2
	printf("real mem  = %u (%uK) %uMB\n", ctob(physmem),
	    ctob(physmem)/1024, ctob(physmem)/1024/1024);
d393 2
a394 2
	printf("avail mem = %lu (%uK)\n", ptoa(uvmexp.free),
	    ptoa(uvmexp.free)/1024);
@


1.21
log
@Get rid of katelib.h, it was almost unused and is marked as deprecated anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: arm32_machdep.c,v 1.20 2006/03/15 21:41:37 deraadt Exp $	*/
d227 1
a227 1
	if (GetCPSR() & I32_bit) {
@


1.20
log
@use sysctl_int_lower() for the aperture variable.  This lets root close
the aperture without having to reboot, but does not allow re-opening;
ok matthieu
@
text
@d1 1
a1 1
/*	$OpenBSD: arm32_machdep.c,v 1.19 2006/01/17 20:30:10 miod Exp $	*/
a61 1
#include <arm/katelib.h>
@


1.19
log
@Upon halt, invoke resettodr() on arm platforms, unless we have been sitting
in DDB; tested at least by aanriot@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arm32_machdep.c,v 1.18 2005/12/27 18:51:03 drahn Exp $	*/
d455 2
a456 2
			return (sysctl_rdint(oldp, oldlenp, newp,
			    allowaperture));
@


1.18
log
@print real memory in MB as well as KB, also remove unused ifdef code.
@
text
@d1 1
a1 1
/*	$OpenBSD: arm32_machdep.c,v 1.17 2005/12/21 20:36:00 deraadt Exp $	*/
d219 1
a219 1
bootsync(void)
d240 11
@


1.17
log
@sysctl machdep.lidsuspend=1 makes screen closures to cause a suspend.
(opening the screen does not yet wake the machine up, not yet sure if
that is even possible yet)
@
text
@d1 1
a1 1
/*	$OpenBSD: arm32_machdep.c,v 1.16 2005/12/20 19:23:57 drahn Exp $	*/
a98 4
#if NMD > 0 && defined(MEMORY_DISK_HOOKS) && !defined(MEMORY_DISK_ROOT_SIZE)
extern size_t md_root_size;		/* Memory disc size */
#endif	/* NMD && MEMORY_DISK_HOOKS && !MEMORY_DISK_ROOT_SIZE */

d305 2
a306 2
	printf("real mem  = %u (%uK)\n", ctob(physmem), ctob(physmem)/1024);

@


1.16
log
@Add machdep.maxspeed sysctl to change the meaning of hw.setperf=100 on zaurus,
This will scale the speed for hw.setperf, this allows limiting apm -A
to lower speed, or even overclocking. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arm32_machdep.c,v 1.15 2005/08/06 14:26:51 miod Exp $	*/
d132 1
a428 8
#if 0
	case CPU_BOOTED_DEVICE:
		if (booted_device != NULL)
			return (sysctl_rdstring(oldp, oldlenp, newp,
			    booted_device->dv_xname));
		return (EOPNOTSUPP);
#endif

d469 7
d477 9
a524 14
#ifdef __zaurus__	 /* ??? */
	case CPU_MAXSPEED:
	{
		int err = EINVAL;
		void pxa2x0_maxspeed(int *);
		if (!newp && newlen == 0)
			return (sysctl_int(oldp, oldlenp, 0, 0,
			    &xscale_maxspeed));
		err = (sysctl_int(oldp, oldlenp, newp, newlen,
		    &xscale_maxspeed));
		pxa2x0_maxspeed(&xscale_maxspeed);
		return err;
	}
#endif
a530 117

#if 0
/*
 * machine dependent system variables.
 */
static int
sysctl_machdep_booted_device(SYSCTLFN_ARGS)
{
	struct sysctlnode node;

	if (booted_device == NULL)
		return (EOPNOTSUPP);

	node = *rnode;
	node.sysctl_data = booted_device->dv_xname;
	node.sysctl_size = strlen(booted_device->dv_xname) + 1;
	return (sysctl_lookup(SYSCTLFN_CALL(&node)));
}

static int
sysctl_machdep_booted_kernel(SYSCTLFN_ARGS)
{
	struct sysctlnode node;

	if (booted_kernel == NULL || booted_kernel[0] == '\0')
		return (EOPNOTSUPP);

	node = *rnode;
	node.sysctl_data = booted_kernel;
	node.sysctl_size = strlen(booted_kernel) + 1;
	return (sysctl_lookup(SYSCTLFN_CALL(&node)));
}

static int
sysctl_machdep_powersave(SYSCTLFN_ARGS)
{
	struct sysctlnode node = *rnode;
	int error, newval;

	newval = cpu_do_powersave;
	node.sysctl_data = &newval;
	if (cpufuncs.cf_sleep == (void *) cpufunc_nullop)
		node.sysctl_flags &= ~SYSCTL_READWRITE;
	error = sysctl_lookup(SYSCTLFN_CALL(&node));
	if (error || newp == NULL || newval == cpu_do_powersave)
		return (error);

	if (newval < 0 || newval > 1)
		return (EINVAL);
	cpu_do_powersave = newval;

	return (0);
}

SYSCTL_SETUP(sysctl_machdep_setup, "sysctl machdep subtree setup")
{

	sysctl_createv(SYSCTL_PERMANENT,
		       CTLTYPE_NODE, "machdep", NULL,
		       NULL, 0, NULL, 0,
		       CTL_MACHDEP, CTL_EOL);

	sysctl_createv(SYSCTL_PERMANENT|SYSCTL_READWRITE,
		       CTLTYPE_INT, "debug", NULL,
		       NULL, 0, &kernel_debug, 0,
		       CTL_MACHDEP, CPU_DEBUG, CTL_EOL);
	sysctl_createv(SYSCTL_PERMANENT,
		       CTLTYPE_STRING, "booted_device", NULL,
		       sysctl_machdep_booted_device, 0, NULL, 0,
		       CTL_MACHDEP, CPU_BOOTED_DEVICE, CTL_EOL);
	sysctl_createv(SYSCTL_PERMANENT,
		       CTLTYPE_STRING, "booted_kernel", NULL,
		       sysctl_machdep_booted_kernel, 0, NULL, 0,
		       CTL_MACHDEP, CPU_BOOTED_KERNEL, CTL_EOL);
	sysctl_createv(SYSCTL_PERMANENT,
		       CTLTYPE_STRUCT, "console_device", NULL,
		       sysctl_consdev, 0, NULL, sizeof(dev_t),
		       CTL_MACHDEP, CPU_CONSDEV, CTL_EOL);
	sysctl_createv(SYSCTL_PERMANENT|SYSCTL_READWRITE,
		       CTLTYPE_INT, "powersave", NULL,
		       sysctl_machdep_powersave, 0, &cpu_do_powersave, 0,
		       CTL_MACHDEP, CPU_POWERSAVE, CTL_EOL);
}
#endif

#if 0
void
parse_mi_bootargs(args)
	char *args;
{
	int integer;

	if (get_bootconf_option(args, "single", BOOTOPT_TYPE_BOOLEAN, &integer)
	    || get_bootconf_option(args, "-s", BOOTOPT_TYPE_BOOLEAN, &integer))
		if (integer)
			boothowto |= RB_SINGLE;
	if (get_bootconf_option(args, "kdb", BOOTOPT_TYPE_BOOLEAN, &integer)
	    || get_bootconf_option(args, "-k", BOOTOPT_TYPE_BOOLEAN, &integer))
		if (integer)
			boothowto |= RB_KDB;
	if (get_bootconf_option(args, "ask", BOOTOPT_TYPE_BOOLEAN, &integer)
	    || get_bootconf_option(args, "-a", BOOTOPT_TYPE_BOOLEAN, &integer))
		if (integer)
			boothowto |= RB_ASKNAME;

#ifdef PMAP_DEBUG
	if (get_bootconf_option(args, "pmapdebug", BOOTOPT_TYPE_INT, &integer)) {
		pmap_debug_level = integer;
		pmap_debug(pmap_debug_level);
	}
#endif	/* PMAP_DEBUG */

/*	if (get_bootconf_option(args, "nbuf", BOOTOPT_TYPE_INT, &integer))
		bufpages = integer;*/

}
#endif
@


1.15
log
@We do not need a char machine_arch[] constant.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arm32_machdep.c,v 1.14 2005/08/01 15:42:46 miod Exp $	*/
d142 1
d514 14
@


1.14
log
@Kill more "memory might be 2MB or less" checks in bufpages computation.
ok deraadt@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arm32_machdep.c,v 1.13 2005/04/26 01:12:27 deraadt Exp $	*/
a106 1
char	machine_arch[] = MACHINE_ARCH;	/* from <machine/param.h> */
@


1.13
log
@... oh and let it work for all cases
@
text
@d1 1
a1 1
/*	$OpenBSD: arm32_machdep.c,v 1.12 2005/04/26 01:09:00 deraadt Exp $	*/
d669 2
a670 5
		if (physmem < btoc(2 * 1024 * 1024))
			bufpages = physmem / 10;
		else
			bufpages = (btoc(2 * 1024 * 1024) + physmem) *
			    bufcachepercent / 100;
@


1.12
log
@let ramdisks compile after zts changes
@
text
@d1 1
a1 1
/*	$OpenBSD: arm32_machdep.c,v 1.11 2005/04/24 18:55:49 uwe Exp $	*/
d486 2
a490 2
#if NZTS > 0
		int err = EINVAL;
@


1.11
log
@Do down-sampling of the high-resolution touch pad events in kernel,
and provide sysctls for fine-tuning the touch pad area that covers the
screen.  Reasonable defaults are provided, but each machine can be a
bit different due to the manufacturing process.
@
text
@d1 1
a1 1
/*	$OpenBSD: arm32_machdep.c,v 1.10 2005/03/29 20:00:16 uwe Exp $	*/
d469 1
d474 2
a475 3
		else
			return (sysctl_int(oldp, oldlenp, newp, newlen,
			    &kbd_reset));
d478 1
d481 3
a487 1
		int err;
d489 2
d512 1
@


1.10
log
@- Support the machdep.kbdreset sysctl on zaurus.
- Disable unused function parse_mi_bootargs().
@
text
@d1 1
a1 1
/*	$OpenBSD: arm32_machdep.c,v 1.9 2005/03/07 02:08:45 uwe Exp $	*/
d133 10
d476 33
@


1.9
log
@include apm.h only if CONF_HAVE_APM is defined
@
text
@d1 1
a1 1
/*	$OpenBSD: arm32_machdep.c,v 1.8 2005/03/03 22:55:00 uwe Exp $	*/
d130 5
d458 9
d558 1
a558 1
#if 1
@


1.8
log
@Support APM_IOC_PRN_CTL, and machdep.apmwarn as documented in apm(4), and
apmd(8); missing sysctl variable noticed by drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arm32_machdep.c,v 1.7 2005/01/24 22:20:32 uwe Exp $	*/
d65 1
d67 1
d69 3
@


1.7
log
@Pass boot arguments from zboot/zbsdmod to the loaded kernel, and cope
with 32-bit lseek() in zboot (make 'boot' and 'ls' work above 2G).
ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arm32_machdep.c,v 1.6 2005/01/21 16:22:32 miod Exp $	*/
d66 1
d396 4
d443 6
@


1.6
log
@Overhaul of the pxa2x0_lcd code, to allow early (before autoconf) attachment,
and collateral changes.

Because this driver requires us_dma (and as such, vm services) to work, it
can not be selected in consinit(). Instead, add a hook to the arm
cpu_startup() which will, on zaurus, switch console from serial (selected
in consinit()) to lcd.

This also makes the zaurus-specific early pxa2x0_clkman() substitute code
cleaner.

While there, move boot -c handling later, after the glass console is set up.

Tested by drahn@@ and uwe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arm32_machdep.c,v 1.5 2004/05/19 03:17:06 drahn Exp $	*/
d528 1
a528 1
#if 0
@


1.5
log
@de __P of sys/arch/arm.
@
text
@d1 1
a1 1
/*	$OpenBSD: arm32_machdep.c,v 1.4 2004/02/26 04:58:38 drahn Exp $	*/
d255 5
@


1.4
log
@add APERTURE support.
@
text
@d1 1
a1 1
/*	$OpenBSD: arm32_machdep.c,v 1.3 2004/02/12 04:13:02 drahn Exp $	*/
d126 3
a128 3
void data_abort_handler		__P((trapframe_t *frame));
void prefetch_abort_handler	__P((trapframe_t *frame));
extern void configure		__P((void));
@


1.3
log
@Do not overwrite boothowto if not in the ramdisk kernel, allows single
user to work. While here nuke some if0'ed code we we will never use.
@
text
@d1 1
a1 1
/*	$OpenBSD: arm32_machdep.c,v 1.2 2004/02/01 06:10:33 drahn Exp $	*/
d116 7
d422 11
@


1.3.2.1
log
@The merge of these files were done to another date than the rest, fix.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a266 2
#else
	boothowto = RB_AUTOBOOT;
a534 20
#if NMD > 0 && defined(MEMORY_DISK_HOOKS) && !defined(MEMORY_DISK_ROOT_SIZE)
	if (get_bootconf_option(args, "memorydisc", BOOTOPT_TYPE_INT, &integer)
	    || get_bootconf_option(args, "memorydisk", BOOTOPT_TYPE_INT, &integer)) {
		md_root_size = integer;
		md_root_size *= 1024;
		if (md_root_size < 32*1024)
			md_root_size = 32*1024;
		if (md_root_size > 2048*1024)
			md_root_size = 2048*1024;
	}
#endif	/* NMD && MEMORY_DISK_HOOKS && !MEMORY_DISK_ROOT_SIZE */

	if (get_bootconf_option(args, "quiet", BOOTOPT_TYPE_BOOLEAN, &integer)
	    || get_bootconf_option(args, "-q", BOOTOPT_TYPE_BOOLEAN, &integer))
		if (integer)
			boothowto |= AB_QUIET;
	if (get_bootconf_option(args, "verbose", BOOTOPT_TYPE_BOOLEAN, &integer)
	    || get_bootconf_option(args, "-v", BOOTOPT_TYPE_BOOLEAN, &integer))
		if (integer)
			boothowto |= AB_VERBOSE;
@


1.3.2.2
log
@Merge with the trunk
@
text
@a115 7
#ifdef APERTURE
#ifdef INSECURE
int allowaperture = 1;
#else
int allowaperture = 0;
#endif
#endif
d119 3
a121 3
void data_abort_handler		(trapframe_t *frame);
void prefetch_abort_handler	(trapframe_t *frame);
extern void configure		(void);
d267 2
a416 11
	case CPU_ALLOWAPERTURE:
#ifdef APERTURE
		if (securelevel > 0)
			return (sysctl_rdint(oldp, oldlenp, newp,
			    allowaperture));
		else
			return (sysctl_int(oldp, oldlenp, newp, newlen,
			    &allowaperture));
#else
		return (sysctl_rdint(oldp, oldlenp, newp, 0));
#endif
d537 20
@


1.2
log
@fix tags...
@
text
@d1 1
a1 1
/*	$OpenBSD: arm32_machdep.c,v 1.1 2004/02/01 05:09:48 drahn Exp $	*/
a266 2
#else
	boothowto = RB_AUTOBOOT;
a534 20
#if NMD > 0 && defined(MEMORY_DISK_HOOKS) && !defined(MEMORY_DISK_ROOT_SIZE)
	if (get_bootconf_option(args, "memorydisc", BOOTOPT_TYPE_INT, &integer)
	    || get_bootconf_option(args, "memorydisk", BOOTOPT_TYPE_INT, &integer)) {
		md_root_size = integer;
		md_root_size *= 1024;
		if (md_root_size < 32*1024)
			md_root_size = 32*1024;
		if (md_root_size > 2048*1024)
			md_root_size = 2048*1024;
	}
#endif	/* NMD && MEMORY_DISK_HOOKS && !MEMORY_DISK_ROOT_SIZE */

	if (get_bootconf_option(args, "quiet", BOOTOPT_TYPE_BOOLEAN, &integer)
	    || get_bootconf_option(args, "-q", BOOTOPT_TYPE_BOOLEAN, &integer))
		if (integer)
			boothowto |= AB_QUIET;
	if (get_bootconf_option(args, "verbose", BOOTOPT_TYPE_BOOLEAN, &integer)
	    || get_bootconf_option(args, "-v", BOOTOPT_TYPE_BOOLEAN, &integer))
		if (integer)
			boothowto |= AB_VERBOSE;
@


1.1
log
@Arm port, NetBSD codebase stripped down, 32bit only support.
@
text
@d1 2
a2 2
/*	$OpenBSD: arm32_machdep.c,v 1.3 2004/01/29 16:17:16 drahn Exp $	*/
/*^I$NetBSD: arm32_machdep.c,v 1.42 2003/12/30 12:33:15 pk Exp $^I*/$
@

