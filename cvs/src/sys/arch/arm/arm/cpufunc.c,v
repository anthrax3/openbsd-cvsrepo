head	1.50;
access;
symbols
	OPENBSD_6_1:1.50.0.4
	OPENBSD_6_1_BASE:1.50
	OPENBSD_6_0:1.41.0.2
	OPENBSD_6_0_BASE:1.41
	OPENBSD_5_9:1.27.0.2
	OPENBSD_5_9_BASE:1.27
	OPENBSD_5_8:1.27.0.4
	OPENBSD_5_8_BASE:1.27
	OPENBSD_5_7:1.26.0.2
	OPENBSD_5_7_BASE:1.26
	OPENBSD_5_6:1.26.0.4
	OPENBSD_5_6_BASE:1.26
	OPENBSD_5_5:1.24.0.4
	OPENBSD_5_5_BASE:1.24
	OPENBSD_5_4:1.23.0.2
	OPENBSD_5_4_BASE:1.23
	OPENBSD_5_3:1.18.0.2
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.16.0.4
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.2
	OPENBSD_5_0:1.13.0.6
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.4
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.2
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.12.0.2
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.11.0.4
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.8.0.2
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.7.0.10
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.8
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.6
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.4
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.2
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.4.0.2
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.3.0.4
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.2
	OPENBSD_3_7_BASE:1.3
	OPENBSD_3_6:1.2.0.2
	OPENBSD_3_6_BASE:1.2
	SMP_SYNC_A:1.2
	SMP_SYNC_B:1.2
	OPENBSD_3_5:1.1.0.4
	OPENBSD_3_5_BASE:1.1
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.50
date	2017.01.06.00.06.02;	author jsg;	state Exp;
branches;
next	1.49;
commitid	YCbIRye8xzoWl68V;

1.49
date	2017.01.02.00.51.18;	author jsg;	state Exp;
branches;
next	1.48;
commitid	adprazRZa4KO5WRh;

1.48
date	2016.08.25.08.17.57;	author kettenis;	state Exp;
branches;
next	1.47;
commitid	Vhvux0GuX4k61PiS;

1.47
date	2016.08.22.01.41.59;	author jsg;	state Exp;
branches;
next	1.46;
commitid	UOfhQ4F8JDkBUCg3;

1.46
date	2016.08.14.11.30.54;	author jsg;	state Exp;
branches;
next	1.45;
commitid	3XHAPSr5dKOYN1hw;

1.45
date	2016.08.14.10.36.47;	author kettenis;	state Exp;
branches;
next	1.44;
commitid	McCOzF71X4patDyh;

1.44
date	2016.08.10.21.22.43;	author kettenis;	state Exp;
branches;
next	1.43;
commitid	TF23RAMj7RpPlALy;

1.43
date	2016.08.03.07.05.05;	author kettenis;	state Exp;
branches;
next	1.42;
commitid	k28vhAMZpfCRr4Q3;

1.42
date	2016.07.31.03.49.51;	author jsg;	state Exp;
branches;
next	1.41;
commitid	GGqGemCoVm51bBbM;

1.41
date	2016.04.04.09.06.28;	author patrick;	state Exp;
branches;
next	1.40;
commitid	ZuB0flUUaGbKwG8C;

1.40
date	2016.04.04.05.13.50;	author jsg;	state Exp;
branches;
next	1.39;
commitid	mg01EivY8FRy36tV;

1.39
date	2016.04.04.00.41.36;	author jsg;	state Exp;
branches;
next	1.38;
commitid	iyCoBStoO0PiDqbe;

1.38
date	2016.04.03.13.55.23;	author jsg;	state Exp;
branches;
next	1.37;
commitid	Zptl63HVhfEY4Ajo;

1.37
date	2016.03.23.01.09.15;	author patrick;	state Exp;
branches;
next	1.36;
commitid	CgrkH7y9gjPIp58z;

1.36
date	2016.03.22.23.35.01;	author patrick;	state Exp;
branches;
next	1.35;
commitid	RkEnvixfXW2bEpue;

1.35
date	2016.03.22.23.28.02;	author patrick;	state Exp;
branches;
next	1.34;
commitid	bAxWaXK3mkjM56Iw;

1.34
date	2016.03.22.11.18.17;	author patrick;	state Exp;
branches;
next	1.33;
commitid	YjNMWFHczdMD8Xoi;

1.33
date	2016.03.19.09.51.24;	author patrick;	state Exp;
branches;
next	1.32;
commitid	E8GUcpv6nbDyd4Ml;

1.32
date	2016.03.19.09.47.54;	author patrick;	state Exp;
branches;
next	1.31;
commitid	WySdpoZsQMX20beB;

1.31
date	2016.03.19.09.36.56;	author patrick;	state Exp;
branches;
next	1.30;
commitid	PJBEdVboqiwjXPXy;

1.30
date	2016.03.18.13.16.02;	author jsg;	state Exp;
branches;
next	1.29;
commitid	RKG2cJTBtpcdjKgj;

1.29
date	2016.03.18.06.54.21;	author jsg;	state Exp;
branches;
next	1.28;
commitid	82aYg3LAWI4D5T1j;

1.28
date	2016.03.02.23.50.32;	author jsg;	state Exp;
branches;
next	1.27;
commitid	6bYNCgvUHf1Nx5D6;

1.27
date	2015.05.29.05.48.07;	author jsg;	state Exp;
branches;
next	1.26;
commitid	wBu16DsvoGvtioAP;

1.26
date	2014.04.03.10.17.34;	author mpi;	state Exp;
branches;
next	1.25;

1.25
date	2014.03.29.18.09.28;	author guenther;	state Exp;
branches;
next	1.24;

1.24
date	2013.09.03.16.48.26;	author patrick;	state Exp;
branches;
next	1.23;

1.23
date	2013.05.18.17.48.48;	author patrick;	state Exp;
branches;
next	1.22;

1.22
date	2013.05.18.17.42.11;	author patrick;	state Exp;
branches;
next	1.21;

1.21
date	2013.05.18.17.34.01;	author patrick;	state Exp;
branches;
next	1.20;

1.20
date	2013.03.27.00.06.09;	author patrick;	state Exp;
branches;
next	1.19;

1.19
date	2013.03.22.21.24.11;	author patrick;	state Exp;
branches;
next	1.18;

1.18
date	2013.01.23.19.57.47;	author patrick;	state Exp;
branches;
next	1.17;

1.17
date	2013.01.18.00.20.20;	author patrick;	state Exp;
branches;
next	1.16;

1.16
date	2011.11.08.17.06.51;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2011.11.06.13.47.57;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2011.09.20.22.02.10;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2010.07.01.22.40.10;	author drahn;	state Exp;
branches;
next	1.12;

1.12
date	2010.02.22.16.45.29;	author kevlo;	state Exp;
branches;
next	1.11;

1.11
date	2009.05.24.04.56.19;	author drahn;	state Exp;
branches;
next	1.10;

1.10
date	2009.05.11.12.51.24;	author drahn;	state Exp;
branches;
next	1.9;

1.9
date	2009.05.08.02.57.32;	author drahn;	state Exp;
branches;
next	1.8;

1.8
date	2008.09.11.02.38.14;	author kevlo;	state Exp;
branches;
next	1.7;

1.7
date	2006.06.15.21.35.30;	author drahn;	state Exp;
branches;
next	1.6;

1.6
date	2006.05.29.17.01.42;	author drahn;	state Exp;
branches;
next	1.5;

1.5
date	2006.03.07.20.20.28;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2005.12.31.22.13.06;	author drahn;	state Exp;
branches;
next	1.3;

1.3
date	2004.12.30.23.43.15;	author drahn;	state Exp;
branches;
next	1.2;

1.2
date	2004.05.19.03.17.06;	author drahn;	state Exp;
branches;
next	1.1;

1.1
date	2004.02.01.05.09.48;	author drahn;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2004.02.19.10.48.00;	author niklas;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2004.06.05.23.10.44;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.50
log
@unifdef CPU_ARMv7 and ARM_ARCH_7
ok kettenis@@ patrick@@
@
text
@/*	$OpenBSD: cpufunc.c,v 1.49 2017/01/02 00:51:18 jsg Exp $	*/
/*	$NetBSD: cpufunc.c,v 1.65 2003/11/05 12:53:15 scw Exp $	*/

/*
 * arm7tdmi support code Copyright (c) 2001 John Fremlin
 * arm8 support code Copyright (c) 1997 ARM Limited
 * arm8 support code Copyright (c) 1997 Causality Limited
 * arm9 support code Copyright (C) 2001 ARM Ltd
 * Copyright (c) 1997 Mark Brinicombe.
 * Copyright (c) 1997 Causality Limited
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Causality Limited.
 * 4. The name of Causality Limited may not be used to endorse or promote
 *    products derived from this software without specific prior written
 *    permission.
 *
 * THIS SOFTWARE IS PROVIDED BY CAUSALITY LIMITED ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL CAUSALITY LIMITED BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * RiscBSD kernel project
 *
 * cpufuncs.c
 *
 * C functions for supporting CPU / MMU / TLB specific operations.
 *
 * Created      : 30/01/97
 */

#include <sys/types.h>
#include <sys/param.h>
#include <sys/systm.h>

#include <uvm/uvm_extern.h>

#include <machine/pmap.h>
#include <arm/cpuconf.h>
#include <arm/cpufunc.h>

#if defined(PERFCTRS)
struct arm_pmc_funcs *arm_pmc;
#endif

/* PRIMARY CACHE VARIABLES */
int	arm_picache_size;
int	arm_picache_line_size;
int	arm_picache_ways;

int	arm_pdcache_size;	/* and unified */
int	arm_pdcache_line_size;
int	arm_pdcache_ways;

int	arm_pcache_type;
int	arm_pcache_unified;

int	arm_dcache_align;
int	arm_dcache_align_mask;

/* 1 == use cpu_sleep(), 0 == don't */
int cpu_do_powersave;

struct cpu_functions armv7_cpufuncs = {
	/* CPU functions */

	cpufunc_id,			/* id			*/
	cpufunc_nullop,			/* cpwait		*/

	/* MMU functions */

	cpufunc_control,		/* control		*/
	cpufunc_auxcontrol,		/* aux control		*/
	cpufunc_domains,		/* Domain		*/
	armv7_setttb,			/* Setttb		*/
	cpufunc_dfsr,			/* dfsr			*/
	cpufunc_dfar,			/* dfar			*/
	cpufunc_ifsr,			/* ifsr			*/
	cpufunc_ifar,			/* ifar			*/

	/* TLB functions */

	armv7_tlb_flushID,		/* tlb_flushID		*/
	armv7_tlb_flushID_SE,		/* tlb_flushID_SE	*/
	armv7_tlb_flushID,		/* tlb_flushI		*/
	armv7_tlb_flushID_SE,		/* tlb_flushI_SE	*/
	armv7_tlb_flushD,		/* tlb_flushD		*/
	armv7_tlb_flushD_SE,		/* tlb_flushD_SE	*/

	/* Cache operations */

	armv7_icache_sync_all,		/* icache_sync_all	*/
	armv7_icache_sync_range,	/* icache_sync_range	*/

	armv7_dcache_wbinv_all,		/* dcache_wbinv_all	*/
	armv7_dcache_wbinv_range,	/* dcache_wbinv_range	*/
	armv7_dcache_inv_range,		/* dcache_inv_range	*/
	armv7_dcache_wb_range,		/* dcache_wb_range	*/

	armv7_idcache_wbinv_all,	/* idcache_wbinv_all	*/
	armv7_idcache_wbinv_range,	/* idcache_wbinv_range	*/

	cpufunc_nullop,			/* sdcache_wbinv_all	*/
	(void *)cpufunc_nullop,		/* sdcache_wbinv_range	*/
	(void *)cpufunc_nullop,		/* sdcache_inv_range	*/
	(void *)cpufunc_nullop,		/* sdcache_wb_range	*/
	(void *)cpufunc_nullop,		/* sdcache_drain_writebuf */

	/* Other functions */

	cpufunc_nullop,			/* flush_prefetchbuf	*/
	armv7_drain_writebuf,		/* drain_writebuf	*/

	armv7_cpu_sleep,		/* sleep (wait for interrupt) */

	/* Soft functions */
	armv7_context_switch,		/* context_switch	*/
	armv7_setup			/* cpu setup		*/
};

/*
 * Global constants also used by locore.s
 */

struct cpu_functions cpufuncs;
u_int cputype;
u_int cpu_reset_needs_v4_MMU_disable;	/* flag used in locore.s */

int	arm_icache_min_line_size = 32;
int	arm_dcache_min_line_size = 32;
int	arm_idcache_min_line_size = 32;

void arm_get_cachetype_cp15v7 (void);
int	arm_dcache_l2_nsets;
int	arm_dcache_l2_assoc;
int	arm_dcache_l2_linesize;

/*
 * Base 2 logarithm of an int. returns 0 for 0 (yeye, I know).
 */
static int
log2(unsigned int i)
{
	int ret = 0;

	while (i >>= 1)
		ret++;

	return (ret);
}

void
arm_get_cachetype_cp15v7(void)
{
	uint32_t ctype;
	uint32_t cachereg;
	uint32_t cache_level_id;
	uint32_t sets;
	uint32_t sel, level;

	/* CTR - Cache Type Register */
	__asm volatile("mrc p15, 0, %0, c0, c0, 1"
		: "=r" (ctype));

	arm_dcache_min_line_size = 1 << (CPU_CT_DMINLINE(ctype) + 2);
	arm_icache_min_line_size = 1 << (CPU_CT_IMINLINE(ctype) + 2);
	arm_idcache_min_line_size =
	    min(arm_icache_min_line_size, arm_dcache_min_line_size);

	/* CLIDR - Cache Level ID Register */
	__asm volatile("mrc p15, 1, %0, c0, c0, 1"
		: "=r" (cache_level_id) :);
	cpu_drain_writebuf();

	/* L1 Cache available. */
	level = 0;
	if (cache_level_id & (0x7 << level)) {
		/* Unified cache. */
		if (cache_level_id & (0x4 << level))
			arm_pcache_unified = 1;

		/* Unified or data cache separate. */
		if (cache_level_id & (0x4 << level) ||
		    cache_level_id & (0x2 << level)) {
			sel = level << 1 | 0 << 0; /* L1 | unified/data cache */
			/* CSSELR - Cache Size Selection Register */
			__asm volatile("mcr p15, 2, %0, c0, c0, 0"
				:: "r" (sel));
			cpu_drain_writebuf();
			/* CCSIDR - Cache Size Identification Register */
			__asm volatile("mrc p15, 1, %0, c0, c0, 0"
			: "=r" (cachereg) :);
			cpu_drain_writebuf();
			sets = ((cachereg >> 13) & 0x7fff) + 1;
			arm_pdcache_line_size = 1 << ((cachereg & 0x7) + 4);
			arm_pdcache_ways = ((cachereg >> 3) & 0x3ff) + 1;
			arm_pdcache_size = arm_pdcache_line_size * arm_pdcache_ways * sets;
			switch (cachereg & 0xc0000000) {
			case 0x00000000:
				arm_pcache_type = 0;
				break;
			case 0x40000000:
			case 0xc0000000:
				arm_pcache_type = CPU_CT_CTYPE_WB1;
				break;
			case 0x80000000:
				arm_pcache_type = CPU_CT_CTYPE_WT;
				break;
			}
		}

		/* Instruction cache separate. */
		if (cache_level_id & (0x1 << level)) {
			sel = level << 1 | 1 << 0; /* L1 | instruction cache */
			/* CSSELR - Cache Size Selection Register */
			__asm volatile("mcr p15, 2, %0, c0, c0, 0"
				:: "r" (sel));
			cpu_drain_writebuf();
			/* CCSIDR - Cache Size Identification Register */
			__asm volatile("mrc p15, 1, %0, c0, c0, 0"
			: "=r" (cachereg) :);
			cpu_drain_writebuf();
			sets = ((cachereg >> 13) & 0x7fff) + 1;
			arm_picache_line_size = 1 << ((cachereg & 0x7) + 4);
			arm_picache_ways = ((cachereg >> 3) & 0x3ff) + 1;
			arm_picache_size = arm_picache_line_size * arm_picache_ways * sets;
		}
	}

	arm_dcache_align = arm_pdcache_line_size;
	arm_dcache_align_mask = arm_dcache_align - 1;

	arm_dcache_l2_nsets = arm_pdcache_size/arm_pdcache_ways/arm_pdcache_line_size;
	arm_dcache_l2_assoc = log2(arm_pdcache_ways);
	arm_dcache_l2_linesize = log2(arm_pdcache_line_size);
}

/* 
 */
void
armv7_idcache_wbinv_all()
{
	uint32_t arg;
	arg = 0;
	__asm volatile("mcr	p15, 0, r0, c7, c5, 0" :: "r" (arg));
	armv7_dcache_wbinv_all();
}

/* brute force cache flushing */
void
armv7_dcache_wbinv_all()
{
	int sets, ways, lvl;
	int nsets, nways;
	uint32_t wayincr, setincr;
	uint32_t wayval, setval;
	uint32_t word;

	nsets = arm_dcache_l2_nsets;
	nways = arm_pdcache_ways;

	setincr = armv7_dcache_sets_inc;
	wayincr = armv7_dcache_index_inc;

#if 0
	printf("l1 nsets %d nways %d wayincr %x setincr %x\n",
	    nsets, nways, wayincr, setincr);
#endif

	lvl = 0; /* L1 */
	setval = 0;
	for (sets = 0; sets < nsets; sets++)  {
		wayval = 0;
		for (ways = 0; ways < nways; ways++) {
			word = wayval | setval | lvl;

			/* Clean D cache SE with Set/Index */
			__asm volatile("mcr	p15, 0, %0, c7, c10, 2"
			    : : "r" (word));
			wayval += wayincr;
		}
		setval += setincr;
	}
	/* drain the write buffer */
	cpu_drain_writebuf();

	/* L2 cache flushing removed. Our current L2 caches are separate. */
}


/*
 * Cannot panic here as we may not have a console yet ...
 */

int
set_cpufuncs()
{
	cputype = cpufunc_id();
	cputype &= CPU_ID_CPU_MASK;

	/*
	 * NOTE: cpu_do_powersave defaults to off.  If we encounter a
	 * CPU type where we want to use it by default, then we set it.
	 */

	if ((cputype & CPU_ID_ARCH_MASK) == CPU_ID_ARCH_CPUID) {
		uint32_t mmfr0;

		__asm volatile("mrc p15, 0, %0, c0, c1, 4"
			: "=r" (mmfr0));

		switch (mmfr0 & ID_MMFR0_VMSA_MASK) {
		case VMSA_V7:
		case VMSA_V7_PXN:
		case VMSA_V7_LDT:
			cpufuncs = armv7_cpufuncs;
			/* V4 or higher */
			cpu_reset_needs_v4_MMU_disable = 1;
			arm_get_cachetype_cp15v7();
			armv7_dcache_sets_inc = 1U << arm_dcache_l2_linesize;
			armv7_dcache_sets_max = (1U << (arm_dcache_l2_linesize +
			    arm_dcache_l2_nsets)) - armv7_dcache_sets_inc;
			armv7_dcache_index_inc = 1U << (32 -
			    arm_dcache_l2_assoc);
			armv7_dcache_index_max = 0U - armv7_dcache_index_inc;
			pmap_pte_init_armv7();

			/* Use powersave on this CPU. */
			cpu_do_powersave = 1;
			return 0;
		}
	}
	/*
	 * Bzzzz. And the answer was ...
	 */
	panic("No support for this CPU type (%08x) in kernel", cputype);
	return(ARCHITECTURE_NOT_PRESENT);
}

/*
 * CPU Setup code
 */

void
armv7_setup()
{
	uint32_t auxctrl, auxctrlmask;
	uint32_t cpuctrl, cpuctrlmask;
	uint32_t id_pfr1;

	auxctrl = auxctrlmask = 0;

	switch (cputype & CPU_ID_CORTEX_MASK) {
	case CPU_ID_CORTEX_A5:
	case CPU_ID_CORTEX_A9:
		/* Cache and TLB maintenance broadcast */
#ifdef notyet
		auxctrlmask |= CORTEXA9_AUXCTL_FW;
		auxctrl |= CORTEXA9_AUXCTL_FW;
#endif
		/* FALLTHROUGH */
	case CPU_ID_CORTEX_A7:
	case CPU_ID_CORTEX_A15:
	case CPU_ID_CORTEX_A17:
		/* Set SMP to allow LDREX/STREX */
		auxctrlmask |= CORTEXA9_AUXCTL_SMP;
		auxctrl |= CORTEXA9_AUXCTL_SMP;
		break;
	}

	cpuctrlmask = CPU_CONTROL_MMU_ENABLE
	    | CPU_CONTROL_AFLT_ENABLE
	    | CPU_CONTROL_DC_ENABLE
	    | CPU_CONTROL_BPRD_ENABLE
	    | CPU_CONTROL_IC_ENABLE
	    | CPU_CONTROL_VECRELOC
	    | CPU_CONTROL_TRE
	    | CPU_CONTROL_AFE;

	cpuctrl = CPU_CONTROL_MMU_ENABLE
	    | CPU_CONTROL_AFLT_ENABLE
	    | CPU_CONTROL_DC_ENABLE
	    | CPU_CONTROL_BPRD_ENABLE
	    | CPU_CONTROL_IC_ENABLE
	    | CPU_CONTROL_AFE;

	if (vector_page == ARM_VECTORS_HIGH)
		cpuctrl |= CPU_CONTROL_VECRELOC;

	/*
	 * Check for the Virtualization Extensions and enable UWXN of
	 * those are included.
	 */
	__asm volatile("mrc p15, 0, %0, c0, c1, 1" : "=r"(id_pfr1));
	if ((id_pfr1 & 0x0000f000) == 0x00001000) {
		cpuctrlmask |= CPU_CONTROL_UWXN;
		cpuctrl |= CPU_CONTROL_UWXN;
	}

	/* Clear out the cache */
	cpu_idcache_wbinv_all();

	/*
	 * Set the auxilliary control register first, as the SMP bit
	 * needs to be set to 1 before the caches and the MMU are
	 * enabled.
	 */
	cpu_auxcontrol(auxctrlmask, auxctrl);

	/* Set the control register */
	curcpu()->ci_ctrl = cpuctrl;
	cpu_control(cpuctrlmask, cpuctrl);

	/* And again. */
	cpu_idcache_wbinv_all();
}
@


1.49
log
@remove unused armv4 and xscale files
ok kettenis@@ patrick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.c,v 1.48 2016/08/25 08:17:57 kettenis Exp $	*/
a80 1
#ifdef CPU_ARMv7
a136 1
#endif /* CPU_ARMv7 */
a149 1
#ifdef CPU_ARMv7
d265 1
a305 1
#endif /* CPU_ARMv7 */
a322 1
#ifdef CPU_ARMv7
a349 1
#endif /* CPU_ARMv7 */
a360 1
#ifdef CPU_ARMv7
a433 1
#endif	/* CPU_ARMv7 */
@


1.48
log
@Enable the UWXN bit in the SCTRL register when available.  This should
prevent the kernel from accidentally executing userland pages that are
writable.

ok jsg@@, patrick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.c,v 1.47 2016/08/22 01:41:59 jsg Exp $	*/
a139 60
#if defined(CPU_XSCALE_PXA2X0)
struct cpu_functions xscale_cpufuncs = {
	/* CPU functions */

	cpufunc_id,			/* id			*/
	xscale_cpwait,			/* cpwait		*/

	/* MMU functions */

	xscale_control,			/* control		*/
	cpufunc_auxcontrol,		/* aux control		*/
	cpufunc_domains,		/* domain		*/
	xscale_setttb,			/* setttb		*/
	cpufunc_dfsr,			/* dfsr			*/
	cpufunc_dfar,			/* dfar			*/
	cpufunc_ifsr,			/* ifsr			*/
	cpufunc_ifar,			/* ifar			*/

	/* TLB functions */

	armv4_tlb_flushID,		/* tlb_flushID		*/
	xscale_tlb_flushID_SE,		/* tlb_flushID_SE	*/
	armv4_tlb_flushI,		/* tlb_flushI		*/
	(void *)armv4_tlb_flushI,	/* tlb_flushI_SE	*/
	armv4_tlb_flushD,		/* tlb_flushD		*/
	armv4_tlb_flushD_SE,		/* tlb_flushD_SE	*/

	/* Cache operations */

	xscale_cache_syncI,		/* icache_sync_all	*/
	xscale_cache_syncI_rng,		/* icache_sync_range	*/

	xscale_cache_purgeD,		/* dcache_wbinv_all	*/
	xscale_cache_purgeD_rng,	/* dcache_wbinv_range	*/
	xscale_cache_flushD_rng,	/* dcache_inv_range	*/
	xscale_cache_cleanD_rng,	/* dcache_wb_range	*/

	xscale_cache_purgeID,		/* idcache_wbinv_all	*/
	xscale_cache_purgeID_rng,	/* idcache_wbinv_range	*/

	cpufunc_nullop,			/* sdcache_wbinv_all	*/
	(void *)cpufunc_nullop,		/* sdcache_wbinv_range	*/
	(void *)cpufunc_nullop,		/* sdcache_inv_range	*/
	(void *)cpufunc_nullop,		/* sdcache_wb_range	*/
	(void *)cpufunc_nullop,		/* sdcache_drain_writebuf */

	/* Other functions */

	cpufunc_nullop,			/* flush_prefetchbuf	*/
	armv4_drain_writebuf,		/* drain_writebuf	*/

	xscale_cpu_sleep,		/* sleep		*/

	/* Soft functions */
	xscale_context_switch,		/* context_switch	*/
	xscale_setup			/* cpu setup		*/
};
#endif
/* CPU_XSCALE_PXA2X0 */

a151 79
#if defined(CPU_XSCALE_PXA2X0)
static void get_cachetype_cp15 (void);

/* Additional cache information local to this file.  Log2 of some of the
   above numbers.  */
static int	arm_dcache_l2_nsets;
static int	arm_dcache_l2_assoc;
static int	arm_dcache_l2_linesize;

static void
get_cachetype_cp15()
{
	u_int ctype, isize, dsize;
	u_int multiplier;

	__asm volatile("mrc p15, 0, %0, c0, c0, 1"
		: "=r" (ctype));

	/*
	 * ...and thus spake the ARM ARM:
	 *
	 * If an <opcode2> value corresponding to an unimplemented or
	 * reserved ID register is encountered, the System Control
	 * processor returns the value of the main ID register.
	 */
	if (ctype == cpufunc_id())
		goto out;

	if ((ctype & CPU_CT_S) == 0)
		arm_pcache_unified = 1;

	/*
	 * If you want to know how this code works, go read the ARM ARM.
	 */

	arm_pcache_type = CPU_CT_CTYPE(ctype);

	if (arm_pcache_unified == 0) {
		isize = CPU_CT_ISIZE(ctype);
		multiplier = (isize & CPU_CT_xSIZE_M) ? 3 : 2;
		arm_picache_line_size = 1U << (CPU_CT_xSIZE_LEN(isize) + 3);
		if (CPU_CT_xSIZE_ASSOC(isize) == 0) {
			if (isize & CPU_CT_xSIZE_M)
				arm_picache_line_size = 0; /* not present */
			else
				arm_picache_ways = 1;
		} else {
			arm_picache_ways = multiplier <<
			    (CPU_CT_xSIZE_ASSOC(isize) - 1);
		}
		arm_picache_size = multiplier << (CPU_CT_xSIZE_SIZE(isize) + 8);
	}

	dsize = CPU_CT_DSIZE(ctype);
	multiplier = (dsize & CPU_CT_xSIZE_M) ? 3 : 2;
	arm_pdcache_line_size = 1U << (CPU_CT_xSIZE_LEN(dsize) + 3);
	if (CPU_CT_xSIZE_ASSOC(dsize) == 0) {
		if (dsize & CPU_CT_xSIZE_M)
			arm_pdcache_line_size = 0; /* not present */
		else
			arm_pdcache_ways = 1;
	} else {
		arm_pdcache_ways = multiplier <<
		    (CPU_CT_xSIZE_ASSOC(dsize) - 1);
	}
	arm_pdcache_size = multiplier << (CPU_CT_xSIZE_SIZE(dsize) + 8);

	arm_dcache_align = arm_pdcache_line_size;

	arm_dcache_l2_assoc = CPU_CT_xSIZE_ASSOC(dsize) + multiplier - 2;
	arm_dcache_l2_linesize = CPU_CT_xSIZE_LEN(dsize) + 3;
	arm_dcache_l2_nsets = 6 + CPU_CT_xSIZE_SIZE(dsize) -
	    CPU_CT_xSIZE_ASSOC(dsize) - CPU_CT_xSIZE_LEN(dsize);

 out:
	arm_dcache_align_mask = arm_dcache_align - 1;
}
#endif /* XSCALE */

a354 21
#ifdef CPU_XSCALE_PXA2X0
	/* ignore core revision to test PXA2xx CPUs */
	if ((cputype & ~CPU_ID_XSCALE_COREREV_MASK) == CPU_ID_PXA250 ||
	    (cputype & ~CPU_ID_XSCALE_COREREV_MASK) == CPU_ID_PXA27X ||
	    (cputype & ~CPU_ID_XSCALE_COREREV_MASK) == CPU_ID_PXA210) {

		cpufuncs = xscale_cpufuncs;
#if defined(PERFCTRS)
		xscale_pmu_init();
#endif

		cpu_reset_needs_v4_MMU_disable = 1;	/* XScale needs it */
		get_cachetype_cp15();
		pmap_pte_init_xscale();

		/* Use powersave on this CPU. */
		cpu_do_powersave = 1;

		return 0;
	}
#endif /* CPU_XSCALE_PXA2X0 */
a440 53

#if defined(CPU_XSCALE_PXA2X0)
void
xscale_setup()
{
	uint32_t auxctl;
	uint32_t cpuctrl, cpuctrlmask;

	/*
	 * The XScale Write Buffer is always enabled.  Our option
	 * is to enable/disable coalescing.  Note that bits 6:3
	 * must always be enabled.
	 */

	cpuctrl = CPU_CONTROL_MMU_ENABLE | CPU_CONTROL_32BP_ENABLE
		 | CPU_CONTROL_32BD_ENABLE | CPU_CONTROL_SYST_ENABLE
		 | CPU_CONTROL_IC_ENABLE | CPU_CONTROL_DC_ENABLE
		 | CPU_CONTROL_WBUF_ENABLE | CPU_CONTROL_LABT_ENABLE
		 | CPU_CONTROL_BPRD_ENABLE | CPU_CONTROL_AFLT_ENABLE;
	cpuctrlmask = CPU_CONTROL_MMU_ENABLE | CPU_CONTROL_32BP_ENABLE
		 | CPU_CONTROL_32BD_ENABLE | CPU_CONTROL_SYST_ENABLE
		 | CPU_CONTROL_IC_ENABLE | CPU_CONTROL_DC_ENABLE
		 | CPU_CONTROL_WBUF_ENABLE | CPU_CONTROL_ROM_ENABLE
		 | CPU_CONTROL_BEND_ENABLE | CPU_CONTROL_AFLT_ENABLE
		 | CPU_CONTROL_LABT_ENABLE | CPU_CONTROL_BPRD_ENABLE
		 | CPU_CONTROL_CPCLK | CPU_CONTROL_VECRELOC;

	if (vector_page == ARM_VECTORS_HIGH)
		cpuctrl |= CPU_CONTROL_VECRELOC;

	/* Clear out the cache */
	cpu_idcache_wbinv_all();

	/*
	 * Set the control register.  Note that bits 6:3 must always
	 * be set to 1.
	 */
	curcpu()->ci_ctrl = cpuctrl;
/*	cpu_control(cpuctrlmask, cpuctrl);*/
	cpu_control(0xffffffff, cpuctrl);

	/* Make sure write coalescing is turned on */
	__asm volatile("mrc p15, 0, %0, c1, c0, 1"
		: "=r" (auxctl));
#ifdef XSCALE_NO_COALESCE_WRITES
	auxctl |= XSCALE_AUXCTL_K;
#else
	auxctl &= ~XSCALE_AUXCTL_K;
#endif
	__asm volatile("mcr p15, 0, %0, c1, c0, 1"
		: : "r" (auxctl));
}
#endif	/* CPU_XSCALE_PXA2X0 */
@


1.47
log
@Before pmap7.c rev 1.35 and pmap.h rev 1.44 DMA'able memory with the
BUS_DMA_COHERENT flag was mapped as device memory which does not use the
store buffer.  It is now mapped as normal inner and outer non-cacheable
which does.

While we drain the cpu store buffer for this case, on cortex a9 systems we
also need to explicitly drain the PL310 L2's store buffer.  With PL310
revisions r3p2 and later this is done automatically after being present in
the store buffer for 256 cycles.  On i.MX6 PL310 is rev r3p1 which does
not have this behaviour.  This issue is i.MX6 errata ERR055199 and PL310
errata 769419.

This change restores io performance with a usb flash drive attached to
my cubox.  Raw reads go from 3 MB/s to 19 MB/s for example.

Based on code written by patrick@@ some time ago.
ok kettenis@@ patrick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.c,v 1.46 2016/08/14 11:30:54 jsg Exp $	*/
d532 1
d572 10
@


1.46
log
@Remove code for Intel 80219/80321 xscale processors used by armish.
Generic xscale support and support for pxa2x0 used by zaurus remains.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.c,v 1.45 2016/08/14 10:36:47 kettenis Exp $	*/
d125 1
d184 1
@


1.45
log
@Fix setting the SMP bit in the Auxiliary Control Register.  The old code was
toggling the bit, clearing it when already set.  On Cortex-A7 setting the SMP
bit is essential since without it the CPU doesn't actually use its caches.

The SMP bit supposed to be set before turning on the caches and the MMU, so
move the setting of the Auxiliary Control Register before setting the
System Control Register.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.c,v 1.44 2016/08/10 21:22:43 kettenis Exp $	*/
a58 9
#ifdef CPU_XSCALE_80321
#include <arm/xscale/i80321reg.h>
#include <arm/xscale/i80321var.h>
#endif

#if defined(CPU_XSCALE_80321)
#include <arm/xscale/xscalereg.h>
#endif

d139 1
a139 1
#if defined(CPU_XSCALE_80321) || defined(CPU_XSCALE_PXA2X0)
d196 1
a196 1
/* CPU_XSCALE_80321 || CPU_XSCALE_PXA2X0 */
d210 1
a210 1
#if defined(CPU_XSCALE_80321) || defined(CPU_XSCALE_PXA2X0)
a491 31
#ifdef CPU_XSCALE_80321
	if (cputype == CPU_ID_80321_400 || cputype == CPU_ID_80321_600 ||
	    cputype == CPU_ID_80321_400_B0 || cputype == CPU_ID_80321_600_B0 ||
	    cputype == CPU_ID_80219_400 || cputype == CPU_ID_80219_600) {
		i80321intc_init();

#ifdef PERFCTRS
		/*
		 * Reset the Performance Monitoring Unit to a
		 * pristine state:
		 *	- CCNT, PMN0, PMN1 reset to 0
		 *	- overflow indications cleared
		 *	- all counters disabled
		 */
		__asm volatile("mcr p14, 0, %0, c0, c0, 0"
			:
			: "r" (PMNC_P|PMNC_C|PMNC_PMN0_IF|PMNC_PMN1_IF|
			       PMNC_CC_IF));
#endif /* PERFCTRS */

		cpufuncs = xscale_cpufuncs;
#if defined(PERFCTRS)
		xscale_pmu_init();
#endif

		cpu_reset_needs_v4_MMU_disable = 1;	/* XScale needs it */
		get_cachetype_cp15();
		pmap_pte_init_xscale();
		return 0;
	}
#endif /* CPU_XSCALE_80321 */
d589 1
a589 1
#if defined(CPU_XSCALE_80321) || defined(CPU_XSCALE_PXA2X0)
d640 1
a640 1
#endif	/* CPU_XSCALE_80321 || CPU_XSCALE_PXA2X0 */
@


1.44
log
@Shuffle armv7 access permission bits around to something that is compatible
with setting the Access Flag Enable bit in the System Control Register.
The new settings mean that read-only userland pages are no longer writable
by the kernel, which is a good thing.  Set the Access Flag Enable bit.

ok patrick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.c,v 1.43 2016/08/03 07:05:05 kettenis Exp $	*/
d571 20
d613 7
a622 20

	auxctrl = auxctrlmask = 0;

	switch (cputype & CPU_ID_CORTEX_MASK) {
	case CPU_ID_CORTEX_A5:
	case CPU_ID_CORTEX_A9:
		/* Cache and TLB maintenance broadcast */
#ifdef notyet
		auxctrl |= (1 << 0);
#endif
		/* FALLTHROUGH */
	case CPU_ID_CORTEX_A7:
	case CPU_ID_CORTEX_A15:
	case CPU_ID_CORTEX_A17:
		/* Set SMP to allow LDREX/STREX */
		auxctrl |= (1 << 6);
		break;
	}

	cpu_auxcontrol(auxctrlmask, auxctrl);
@


1.43
log
@The ARMv7 architecture deprecates the separate Instruction and Data TLB
maintanenance instruction and recommends to only use the instructions that
operate on the unified TLB.  Those instructions will flush both TLBs on
implementations that still have separate Instruction and Data TLBs.  Switch
the TLB maintenance primitives over to use those.  This allows us to reduce
the number of primitives on armv7.  We still keep separate "ID" and "D"
variants as we still have to flush the branch predictor when changing the
mappings of pages that contain instructions.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.c,v 1.42 2016/07/31 03:49:51 jsg Exp $	*/
d584 2
a585 1
	    | CPU_CONTROL_IC_ENABLE;
@


1.42
log
@Instead of testing MIDR values for every model of Cortex processor check
MMFR0 for an ARMv7 VMSA MMU that can handle short descriptors when
setting ARMv7 function pointers.  ARMv8 in AArch32 mode is documented to
set the same bits.

ok patrick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.c,v 1.41 2016/04/04 09:06:28 patrick Exp $	*/
d112 2
a113 2
	armv7_tlb_flushI,		/* tlb_flushI		*/
	armv7_tlb_flushI_SE,		/* tlb_flushI_SE	*/
@


1.41
log
@Read cache line sizes from CP15 Cache Type Register.

Previously we used the primary data cache's information on how big
the cache lines are.  The CTR gives us better information about how
big the smallest cache line sizes (controlled by the CPU) are.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.c,v 1.40 2016/04/04 05:13:50 jsg Exp $	*/
d473 26
a498 23
	if ((cputype & CPU_ID_CORTEX_A5_MASK) == CPU_ID_CORTEX_A5 ||
	    (cputype & CPU_ID_CORTEX_A7_MASK) == CPU_ID_CORTEX_A7 ||
	    (cputype & CPU_ID_CORTEX_A8_MASK) == CPU_ID_CORTEX_A8 ||
	    (cputype & CPU_ID_CORTEX_A9_MASK) == CPU_ID_CORTEX_A9 ||
	    (cputype & CPU_ID_CORTEX_A15_MASK) == CPU_ID_CORTEX_A15 ||
	    (cputype & CPU_ID_CORTEX_A17_MASK) == CPU_ID_CORTEX_A17 ||
	    (cputype & CPU_ID_CORTEX_A53_MASK) == CPU_ID_CORTEX_A53 ||
	    (cputype & CPU_ID_CORTEX_A57_MASK) == CPU_ID_CORTEX_A57 ||
	    (cputype & CPU_ID_CORTEX_A72_MASK) == CPU_ID_CORTEX_A72) {
		cpufuncs = armv7_cpufuncs;
		cpu_reset_needs_v4_MMU_disable = 1;	/* V4 or higher */
		arm_get_cachetype_cp15v7();
		armv7_dcache_sets_inc = 1U << arm_dcache_l2_linesize;
		armv7_dcache_sets_max =
		    (1U << (arm_dcache_l2_linesize + arm_dcache_l2_nsets)) -
		    armv7_dcache_sets_inc;
		armv7_dcache_index_inc = 1U << (32 - arm_dcache_l2_assoc);
		armv7_dcache_index_max = 0U - armv7_dcache_index_inc;
		pmap_pte_init_armv7();

		/* Use powersave on this CPU. */
		cpu_do_powersave = 1;
		return 0;
@


1.40
log
@use fixed size unsigned variables for reading/writing the control register
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.c,v 1.39 2016/04/04 00:41:36 jsg Exp $	*/
d215 4
d321 1
d326 9
@


1.39
log
@Set the SMP/coherency bit in ACTLR on Cortex A models it is documented
to exist on.  This is required to use ldrex/strex in some cases.

ok patrick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.c,v 1.38 2016/04/03 13:55:23 jsg Exp $	*/
d552 1
a552 1
	int cpuctrl, cpuctrlmask;
d609 1
a609 1
	int cpuctrl, cpuctrlmask;
@


1.38
log
@Add cpu_auxcontrol() to clear and set bits in the implementation/model
specific Auxiliary Control Register (ACTLR).

ok patrick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.c,v 1.37 2016/03/23 01:09:15 patrick Exp $	*/
d551 1
d579 19
a597 1
	/* TODO: Set ACTLR.SMP to e.g. allow LDREX/STREX. */
@


1.37
log
@Cleanup SCTLR mask to only include bits that are actually defined on
most ARMv7 and ARMv8 processors.

Add TODO to set the ACTLR.SMP bit so we can make use of the atomic
instructions available since ARMv6.

Remove unused comment and code while there.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.c,v 1.36 2016/03/22 23:35:01 patrick Exp $	*/
d100 1
d158 1
@


1.36
log
@Remove support for ARM11.  This was the last unused and unmaintained
processor in our code.  Now we're left with only armv7 and XScale for
armish and zaurus.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.c,v 1.35 2016/03/22 23:28:02 patrick Exp $	*/
d551 14
a564 10
	cpuctrl = CPU_CONTROL_MMU_ENABLE | CPU_CONTROL_SYST_ENABLE
	    | CPU_CONTROL_IC_ENABLE | CPU_CONTROL_DC_ENABLE
	    | CPU_CONTROL_BPRD_ENABLE | CPU_CONTROL_AFLT_ENABLE;
	cpuctrlmask = CPU_CONTROL_MMU_ENABLE | CPU_CONTROL_SYST_ENABLE
	    | CPU_CONTROL_IC_ENABLE | CPU_CONTROL_DC_ENABLE
	    | CPU_CONTROL_ROM_ENABLE | CPU_CONTROL_BPRD_ENABLE
	    | CPU_CONTROL_BEND_ENABLE | CPU_CONTROL_AFLT_ENABLE
	    | CPU_CONTROL_ROUNDROBIN | CPU_CONTROL_CPCLK
	    | CPU_CONTROL_VECRELOC | CPU_CONTROL_FI | CPU_CONTROL_VE
	    | CPU_CONTROL_TRE | CPU_CONTROL_AFE;
a571 6
	/* Now really make sure they are clean.  */
	/* XXX */
	/*
	asm volatile ("mcr\tp15, 0, r0, c7, c7, 0" : : );
	*/

d575 2
@


1.35
log
@Remove support for ARM10.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.c,v 1.34 2016/03/22 11:18:17 patrick Exp $	*/
a89 57
#ifdef CPU_ARM11
struct cpu_functions arm11_cpufuncs = {
	/* CPU functions */

	cpufunc_id,			/* id				*/
	cpufunc_nullop,			/* cpwait			*/

	/* MMU functions */

	cpufunc_control,		/* control			*/
	cpufunc_domains,		/* Domain			*/
	arm11_setttb,			/* Setttb			*/
	cpufunc_dfsr,			/* dfsr			*/
	cpufunc_dfar,			/* dfar			*/
	cpufunc_ifsr,			/* ifsr			*/
	cpufunc_ifar,			/* ifar			*/

	/* TLB functions */

	arm11_tlb_flushID,		/* tlb_flushID			*/
	arm11_tlb_flushID_SE,		/* tlb_flushID_SE		*/
	arm11_tlb_flushI,		/* tlb_flushI			*/
	arm11_tlb_flushI_SE,		/* tlb_flushI_SE		*/
	arm11_tlb_flushD,		/* tlb_flushD			*/
	arm11_tlb_flushD_SE,		/* tlb_flushD_SE		*/

	/* Cache operations */

	armv5_icache_sync_all,		/* icache_sync_all	*/
	armv5_icache_sync_range,	/* icache_sync_range	*/

	armv5_dcache_wbinv_all,		/* dcache_wbinv_all	*/
	armv5_dcache_wbinv_range,	/* dcache_wbinv_range	*/
/*XXX*/	armv5_dcache_wbinv_range,	/* dcache_inv_range	*/
	armv5_dcache_wb_range,		/* dcache_wb_range	*/

	armv5_idcache_wbinv_all,	/* idcache_wbinv_all	*/
	armv5_idcache_wbinv_range,	/* idcache_wbinv_range	*/

	cpufunc_nullop,			/* sdcache_wbinv_all	*/
	(void *)cpufunc_nullop,		/* sdcache_wbinv_range	*/
	(void *)cpufunc_nullop,		/* sdcache_inv_range	*/
	(void *)cpufunc_nullop,		/* sdcache_wb_range	*/

	/* Other functions */

	cpufunc_nullop,			/* flush_prefetchbuf	*/
	arm11_drain_writebuf,		/* drain_writebuf	*/

	arm11_cpu_sleep,		/* sleep (wait for interrupt) */

	/* Soft functions */
	arm11_context_switch,		/* context_switch	*/
	arm11_setup			/* cpu setup		*/
};
#endif /* CPU_ARM11 */

d213 1
a213 2
#if defined(CPU_ARM11) || \
    defined(CPU_XSCALE_80321) || defined(CPU_XSCALE_PXA2X0)
a455 19
#ifdef CPU_ARM11
	if (cputype == CPU_ID_ARM1136JS ||
	    cputype == CPU_ID_ARM1136JSR1 || 1) {
		cpufuncs = arm11_cpufuncs;
		cpu_reset_needs_v4_MMU_disable = 1;	/* V4 or higher */
		get_cachetype_cp15();
		arm11_dcache_sets_inc = 1U << arm_dcache_l2_linesize;
		arm11_dcache_sets_max =
		    (1U << (arm_dcache_l2_linesize + arm_dcache_l2_nsets)) -
		    arm11_dcache_sets_inc;
		arm11_dcache_index_inc = 1U << (32 - arm_dcache_l2_assoc);
		arm11_dcache_index_max = 0U - arm11_dcache_index_inc;
		pmap_pte_init_arm11();

		/* Use powersave on this CPU. */
		cpu_do_powersave = 1;
		return 0;
	}
#endif /* CPU_ARM11 */
a543 30

#ifdef CPU_ARM11
void
arm11_setup()
{
	int cpuctrl, cpuctrlmask;

	cpuctrl = CPU_CONTROL_MMU_ENABLE | CPU_CONTROL_SYST_ENABLE
	    | CPU_CONTROL_IC_ENABLE | CPU_CONTROL_DC_ENABLE
	    | CPU_CONTROL_AFLT_ENABLE /* | CPU_CONTROL_BPRD_ENABLE */;
	cpuctrlmask = CPU_CONTROL_MMU_ENABLE | CPU_CONTROL_SYST_ENABLE
	    | CPU_CONTROL_IC_ENABLE | CPU_CONTROL_DC_ENABLE
	    | CPU_CONTROL_ROM_ENABLE | CPU_CONTROL_BPRD_ENABLE
	    | CPU_CONTROL_BEND_ENABLE | CPU_CONTROL_AFLT_ENABLE
	    | CPU_CONTROL_ROUNDROBIN | CPU_CONTROL_CPCLK;

	/* Clear out the cache */
	cpu_idcache_wbinv_all();

	/* Now really make sure they are clean.  */
	asm volatile ("mcr\tp15, 0, r0, c7, c7, 0" : : );

	/* Set the control register */
	curcpu()->ci_ctrl = cpuctrl;
	cpu_control(0xffffffff, cpuctrl);

	/* And again. */
	cpu_idcache_wbinv_all();
}
#endif	/* CPU_ARM11 */
@


1.34
log
@Remove support for ARM9E.  This is another step in the plan to remove
all unused and unmaintained ARM processors from the past.

ok bmercer@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.c,v 1.33 2016/03/19 09:51:24 patrick Exp $	*/
a89 116
#if defined(CPU_ARM10)
struct cpu_functions armv5_ec_cpufuncs = {
	/* CPU functions */

	cpufunc_id,			/* id			*/
	cpufunc_nullop,			/* cpwait		*/

	/* MMU functions */

	cpufunc_control,		/* control		*/
	cpufunc_domains,		/* Domain		*/
	armv5_ec_setttb,		/* Setttb		*/
	cpufunc_dfsr,			/* dfsr			*/
	cpufunc_dfar,			/* dfar			*/
	cpufunc_ifsr,			/* ifsr			*/
	cpufunc_ifar,			/* ifar			*/

	/* TLB functions */

	armv4_tlb_flushID,		/* tlb_flushID		*/
	arm10_tlb_flushID_SE,		/* tlb_flushID_SE	*/
	armv4_tlb_flushI,		/* tlb_flushI		*/
	arm10_tlb_flushI_SE,		/* tlb_flushI_SE	*/
	armv4_tlb_flushD,		/* tlb_flushD		*/
	armv4_tlb_flushD_SE,		/* tlb_flushD_SE	*/

	/* Cache operations */

	armv5_ec_icache_sync_all,	/* icache_sync_all	*/
	armv5_ec_icache_sync_range,	/* icache_sync_range	*/

		/* ...cache in write-though mode... */
	armv5_ec_dcache_wbinv_all,	/* dcache_wbinv_all	*/
	armv5_ec_dcache_wbinv_range,	/* dcache_wbinv_range	*/
	armv5_ec_dcache_wbinv_range,	/* dcache_inv_range	*/
	armv5_ec_dcache_wb_range,	/* dcache_wb_range	*/

	armv5_ec_idcache_wbinv_all,	/* idcache_wbinv_all	*/
	armv5_ec_idcache_wbinv_range,	/* idcache_wbinv_range	*/

	cpufunc_nullop,			/* sdcache_wbinv_all	*/
	(void *)cpufunc_nullop,		/* sdcache_wbinv_range	*/
	(void *)cpufunc_nullop,		/* sdcache_inv_range	*/
	(void *)cpufunc_nullop,		/* sdcache_wb_range	*/

	/* Other functions */

	cpufunc_nullop,			/* flush_prefetchbuf	*/
	armv4_drain_writebuf,		/* drain_writebuf	*/

	(void *)cpufunc_nullop,		/* sleep		*/

	/* Soft functions */
	arm10_context_switch,		/* context_switch	*/
	arm9e_setup			/* cpu setup		*/
};
#endif /* CPU_ARM10 */


#ifdef CPU_ARM10
struct cpu_functions arm10_cpufuncs = {
	/* CPU functions */

	cpufunc_id,			/* id			*/
	cpufunc_nullop,			/* cpwait		*/

	/* MMU functions */

	cpufunc_control,		/* control		*/
	cpufunc_domains,		/* Domain		*/
	armv5_setttb,			/* Setttb		*/
	cpufunc_dfsr,			/* dfsr			*/
	cpufunc_dfar,			/* dfar			*/
	cpufunc_ifsr,			/* ifsr			*/
	cpufunc_ifar,			/* ifar			*/

	/* TLB functions */

	armv4_tlb_flushID,		/* tlb_flushID		*/
	arm10_tlb_flushID_SE,		/* tlb_flushID_SE	*/
	armv4_tlb_flushI,		/* tlb_flushI		*/
	arm10_tlb_flushI_SE,		/* tlb_flushI_SE	*/
	armv4_tlb_flushD,		/* tlb_flushD		*/
	armv4_tlb_flushD_SE,		/* tlb_flushD_SE	*/

	/* Cache operations */

	armv5_icache_sync_all,		/* icache_sync_all	*/
	armv5_icache_sync_range,	/* icache_sync_range	*/

	armv5_dcache_wbinv_all,		/* dcache_wbinv_all	*/
	armv5_dcache_wbinv_range,	/* dcache_wbinv_range	*/
	armv5_dcache_inv_range,		/* dcache_inv_range	*/
	armv5_dcache_wb_range,		/* dcache_wb_range	*/

	armv5_idcache_wbinv_all,	/* idcache_wbinv_all	*/
	armv5_idcache_wbinv_range,	/* idcache_wbinv_range	*/

	cpufunc_nullop,			/* sdcache_wbinv_all	*/
	(void *)cpufunc_nullop,		/* sdcache_wbinv_range	*/
	(void *)cpufunc_nullop,		/* sdcache_inv_range	*/
	(void *)cpufunc_nullop,		/* sdcache_wb_range	*/

	/* Other functions */

	cpufunc_nullop,			/* flush_prefetchbuf	*/
	armv4_drain_writebuf,		/* drain_writebuf	*/

	(void *)cpufunc_nullop,		/* sleep		*/

	/* Soft functions */
	arm10_context_switch,		/* context_switch	*/
	arm10_setup			/* cpu setup		*/
};
#endif /* CPU_ARM10 */

d270 1
a270 1
#if defined(CPU_ARM10) || defined(CPU_ARM11) || \
a513 27
#ifdef CPU_ARM10
	if (cputype == CPU_ID_ARM1026EJS) {
		cpufuncs = armv5_ec_cpufuncs;
		cpu_reset_needs_v4_MMU_disable = 1;	/* V4 or higher */
		get_cachetype_cp15();
		pmap_pte_init_generic();
		return 0;
	}
	if (/* cputype == CPU_ID_ARM1020T || */
	    cputype == CPU_ID_ARM1020E) {
		/*
		 * Select write-through cacheing (this isn't really an
		 * option on ARM1020T).
		 */
		cpufuncs = arm10_cpufuncs;
		cpu_reset_needs_v4_MMU_disable = 1;	/* V4 or higher */
		get_cachetype_cp15();
		armv5_dcache_sets_inc = 1U << arm_dcache_l2_linesize;
		armv5_dcache_sets_max =
		    (1U << (arm_dcache_l2_linesize + arm_dcache_l2_nsets)) -
		    armv5_dcache_sets_inc;
		armv5_dcache_index_inc = 1U << (32 - arm_dcache_l2_assoc);
		armv5_dcache_index_max = 0U - armv5_dcache_index_inc;
		pmap_pte_init_generic();
		return 0;
	}
#endif /* CPU_ARM10 */
a620 44

#if defined(CPU_ARM10)
void
arm9e_setup()
{
	int cpuctrl, cpuctrlmask;

	cpuctrl = CPU_CONTROL_MMU_ENABLE | CPU_CONTROL_SYST_ENABLE
	    | CPU_CONTROL_IC_ENABLE | CPU_CONTROL_DC_ENABLE
	    | CPU_CONTROL_WBUF_ENABLE | CPU_CONTROL_BPRD_ENABLE
	    | CPU_CONTROL_AFLT_ENABLE;
	cpuctrlmask = CPU_CONTROL_MMU_ENABLE | CPU_CONTROL_SYST_ENABLE
	    | CPU_CONTROL_IC_ENABLE | CPU_CONTROL_DC_ENABLE
	    | CPU_CONTROL_WBUF_ENABLE | CPU_CONTROL_ROM_ENABLE
	    | CPU_CONTROL_BEND_ENABLE | CPU_CONTROL_AFLT_ENABLE
	    | CPU_CONTROL_BPRD_ENABLE
	    | CPU_CONTROL_ROUNDROBIN | CPU_CONTROL_CPCLK;

	if (vector_page == ARM_VECTORS_HIGH)
		cpuctrl |= CPU_CONTROL_VECRELOC;

	/* Clear out the cache */
	cpu_idcache_wbinv_all();

	/* Now really make sure they are clean.  */
	__asm volatile ("mcr\tp15, 0, r0, c7, c7, 0" : : );

	/* Set the control register */
	curcpu()->ci_ctrl = cpuctrl;
	cpu_control(0xffffffff, cpuctrl);

	/* And again. */
	cpu_idcache_wbinv_all();
}

void
arm10_setup()
{
	arm9e_setup();

	/* Allow detection code to find the VFP if it's fitted.  */
	__asm volatile ("mcr\tp15, 0, %0, c1, c0, 2" : : "r" (0x0fffffff));
}
#endif	/* CPU_ARM10 */
@


1.33
log
@Remove support for the XScale 80200.  We don't use it, it didn't compile
and the included headers didn't even exist.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.c,v 1.32 2016/03/19 09:47:54 patrick Exp $	*/
d90 1
a90 1
#if defined(CPU_ARM9E) || defined(CPU_ARM10)
d146 1
a146 1
#endif /* CPU_ARM9E || CPU_ARM10 */
d386 1
a386 1
#if defined(CPU_ARM9E) || defined(CPU_ARM10) || defined(CPU_ARM11) || \
d464 1
a464 1
#endif /* ARM7TDMI || ARM9 || XSCALE */
d630 2
a631 2
#if defined(CPU_ARM9E) || defined(CPU_ARM10)
	if (cputype == CPU_ID_ARM926EJS || cputype == CPU_ID_ARM1026EJS) {
a637 2
#endif /* CPU_ARM9E || CPU_ARM10 */
#ifdef CPU_ARM10
d765 1
a765 1
#if defined(CPU_ARM9E) || defined(CPU_ARM10)
a797 1
#endif	/* CPU_ARM9E || CPU_ARM10 */
a798 1
#if defined(CPU_ARM10)
@


1.32
log
@Remove support for IXP425.  This is another architecture that is not
used and has probably never been used at all.  Some included headers
do not even exist.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.c,v 1.31 2016/03/19 09:36:56 patrick Exp $	*/
a58 5
#ifdef CPU_XSCALE_80200
#include <arm/xscale/i80200reg.h>
#include <arm/xscale/i80200var.h>
#endif

d64 1
a64 1
#if defined(CPU_XSCALE_80200) || defined(CPU_XSCALE_80321)
d320 1
a320 2
#if defined(CPU_XSCALE_80200) || defined(CPU_XSCALE_80321) || \
    defined(CPU_XSCALE_PXA2X0)
d376 1
a376 1
/* CPU_XSCALE_80200 || CPU_XSCALE_80321 || CPU_XSCALE_PXA2X0 */
d387 1
a387 2
    defined(CPU_XSCALE_80200) || defined(CPU_XSCALE_80321) || \
    defined(CPU_XSCALE_PXA2X0)
a703 59
#ifdef CPU_XSCALE_80200
	if (cputype == CPU_ID_80200) {
		int rev = cpufunc_id() & CPU_ID_REVISION_MASK;

		i80200_icu_init();

#ifdef PERFCTRS
		/*
		 * Reset the Performance Monitoring Unit to a
		 * pristine state:
		 *	- CCNT, PMN0, PMN1 reset to 0
		 *	- overflow indications cleared
		 *	- all counters disabled
		 */
		__asm volatile("mcr p14, 0, %0, c0, c0, 0"
			:
			: "r" (PMNC_P|PMNC_C|PMNC_PMN0_IF|PMNC_PMN1_IF|
			       PMNC_CC_IF));
#endif /* PERFCTRS */

#if defined(XSCALE_CCLKCFG)
		/*
		 * Crank CCLKCFG to maximum legal value.
		 */
		__asm volatile ("mcr p14, 0, %0, c6, c0, 0"
			:
			: "r" (XSCALE_CCLKCFG));
#endif

		/*
		 * XXX Disable ECC in the Bus Controller Unit; we
		 * don't really support it, yet.  Clear any pending
		 * error indications.
		 */
		__asm volatile("mcr p13, 0, %0, c0, c1, 0"
			:
			: "r" (BCUCTL_E0|BCUCTL_E1|BCUCTL_EV));

		cpufuncs = xscale_cpufuncs;
#if defined(PERFCTRS)
		xscale_pmu_init();
#endif

		/*
		 * i80200 errata: Step-A0 and A1 have a bug where
		 * D$ dirty bits are not cleared on "invalidate by
		 * address".
		 *
		 * Workaround: Clean cache line before invalidating.
		 */
		if (rev == 0 || rev == 1)
			cpufuncs.cf_dcache_inv_range = xscale_cache_purgeD_rng;

		cpu_reset_needs_v4_MMU_disable = 1;	/* XScale needs it */
		get_cachetype_cp15();
		pmap_pte_init_xscale();
		return 0;
	}
#endif /* CPU_XSCALE_80200 */
d881 1
a881 2
#if defined(CPU_XSCALE_80200) || defined(CPU_XSCALE_80321) || \
    defined(CPU_XSCALE_PXA2X0)
d932 1
a932 1
#endif	/* CPU_XSCALE_80200 || CPU_XSCALE_80321 || CPU_XSCALE_PXA2X0 */
@


1.31
log
@Remove support for StrongARM (SA1) and IXP12x0.  Both are ARMv4 and
are not used by any of the arm platforms.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.c,v 1.30 2016/03/18 13:16:02 jsg Exp $	*/
a68 5
#ifdef CPU_XSCALE_IXP425
#include <arm/xscale/ixp425reg.h>
#include <arm/xscale/ixp425var.h>
#endif

d326 1
a326 1
    defined(CPU_XSCALE_PXA2X0) || defined(CPU_XSCALE_IXP425)
d382 1
a382 1
/* CPU_XSCALE_80200 || CPU_XSCALE_80321 || CPU_XSCALE_PXA2X0 || CPU_XSCALE_IXP425 */
d394 1
a394 1
    defined(CPU_XSCALE_PXA2X0) || defined(CPU_XSCALE_IXP425)
a821 17
#ifdef CPU_XSCALE_IXP425
	if (cputype == CPU_ID_IXP425_533 || cputype == CPU_ID_IXP425_400 ||
	    cputype == CPU_ID_IXP425_266) {
		ixp425_icu_init();

		cpufuncs = xscale_cpufuncs;
#if defined(PERFCTRS)
		xscale_pmu_init();
#endif

		cpu_reset_needs_v4_MMU_disable = 1;	/* XScale needs it */
		get_cachetype_cp15();
		pmap_pte_init_xscale();

		return 0;
	}
#endif /* CPU_XSCALE_IXP425 */
d948 1
a948 1
    defined(CPU_XSCALE_PXA2X0) || defined(CPU_XSCALE_IXP425)
d999 1
a999 1
#endif	/* CPU_XSCALE_80200 || CPU_XSCALE_80321 || CPU_XSCALE_PXA2X0 || CPU_XSCALE_IXP425 */
@


1.30
log
@Remove support for ARM9T (armv4t).  Not used by any of the arm platforms.
From Patrick Wildt.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.c,v 1.29 2016/03/18 06:54:21 jsg Exp $	*/
a329 115

#if defined(CPU_SA1100) || defined(CPU_SA1110)
struct cpu_functions sa11x0_cpufuncs = {
	/* CPU functions */

	cpufunc_id,			/* id			*/
	cpufunc_nullop,			/* cpwait		*/

	/* MMU functions */

	cpufunc_control,		/* control		*/
	cpufunc_domains,		/* domain		*/
	sa1_setttb,			/* setttb		*/
	cpufunc_dfsr,			/* dfsr			*/
	cpufunc_dfar,			/* dfar			*/
	cpufunc_ifsr,			/* ifsr			*/
	cpufunc_ifar,			/* ifar			*/

	/* TLB functions */

	armv4_tlb_flushID,		/* tlb_flushID		*/
	sa1_tlb_flushID_SE,		/* tlb_flushID_SE	*/
	armv4_tlb_flushI,		/* tlb_flushI		*/
	(void *)armv4_tlb_flushI,	/* tlb_flushI_SE	*/
	armv4_tlb_flushD,		/* tlb_flushD		*/
	armv4_tlb_flushD_SE,		/* tlb_flushD_SE	*/

	/* Cache operations */

	sa1_cache_syncI,		/* icache_sync_all	*/
	sa1_cache_syncI_rng,		/* icache_sync_range	*/

	sa1_cache_purgeD,		/* dcache_wbinv_all	*/
	sa1_cache_purgeD_rng,		/* dcache_wbinv_range	*/
/*XXX*/	sa1_cache_purgeD_rng,		/* dcache_inv_range	*/
	sa1_cache_cleanD_rng,		/* dcache_wb_range	*/

	sa1_cache_purgeID,		/* idcache_wbinv_all	*/
	sa1_cache_purgeID_rng,		/* idcache_wbinv_range	*/

	cpufunc_nullop,			/* sdcache_wbinv_all	*/
	(void *)cpufunc_nullop,		/* sdcache_wbinv_range	*/
	(void *)cpufunc_nullop,		/* sdcache_inv_range	*/
	(void *)cpufunc_nullop,		/* sdcache_wb_range	*/

	/* Other functions */

	sa11x0_drain_readbuf,		/* flush_prefetchbuf	*/
	armv4_drain_writebuf,		/* drain_writebuf	*/

	sa11x0_cpu_sleep,		/* sleep		*/

	/* Soft functions */
	sa11x0_context_switch,		/* context_switch	*/
	sa11x0_setup			/* cpu setup		*/
};
#endif	/* CPU_SA1100 || CPU_SA1110 */

#ifdef CPU_IXP12X0
struct cpu_functions ixp12x0_cpufuncs = {
	/* CPU functions */

	cpufunc_id,			/* id			*/
	cpufunc_nullop,			/* cpwait		*/

	/* MMU functions */

	cpufunc_control,		/* control		*/
	cpufunc_domains,		/* domain		*/
	sa1_setttb,			/* setttb		*/
	cpufunc_dfsr,			/* dfsr			*/
	cpufunc_dfar,			/* dfar			*/
	cpufunc_ifsr,			/* ifsr			*/
	cpufunc_ifar,			/* ifar			*/

	/* TLB functions */

	armv4_tlb_flushID,		/* tlb_flushID		*/
	sa1_tlb_flushID_SE,		/* tlb_flushID_SE	*/
	armv4_tlb_flushI,		/* tlb_flushI		*/
	(void *)armv4_tlb_flushI,	/* tlb_flushI_SE	*/
	armv4_tlb_flushD,		/* tlb_flushD		*/
	armv4_tlb_flushD_SE,		/* tlb_flushD_SE	*/

	/* Cache operations */

	sa1_cache_syncI,		/* icache_sync_all	*/
	sa1_cache_syncI_rng,		/* icache_sync_range	*/

	sa1_cache_purgeD,		/* dcache_wbinv_all	*/
	sa1_cache_purgeD_rng,		/* dcache_wbinv_range	*/
/*XXX*/	sa1_cache_purgeD_rng,		/* dcache_inv_range	*/
	sa1_cache_cleanD_rng,		/* dcache_wb_range	*/

	sa1_cache_purgeID,		/* idcache_wbinv_all	*/
	sa1_cache_purgeID_rng,		/* idcache_wbinv_range	*/

	cpufunc_nullop,			/* sdcache_wbinv_all	*/
	(void *)cpufunc_nullop,		/* sdcache_wbinv_range	*/
	(void *)cpufunc_nullop,		/* sdcache_inv_range	*/
	(void *)cpufunc_nullop,		/* sdcache_wb_range	*/

	/* Other functions */

	ixp12x0_drain_readbuf,		/* flush_prefetchbuf	*/
	armv4_drain_writebuf,		/* drain_writebuf	*/

	(void *)cpufunc_nullop,		/* sleep		*/

	/* Soft functions */
	ixp12x0_context_switch,		/* context_switch	*/
	ixp12x0_setup			/* cpu setup		*/
};
#endif	/* CPU_IXP12X0 */

a477 52
#if defined(CPU_SA1100) || defined(CPU_SA1110) || defined(CPU_IXP12X0)
/* Cache information for CPUs without cache type registers. */
struct cachetab {
	u_int32_t ct_cpuid;
	int	ct_pcache_type;
	int	ct_pcache_unified;
	int	ct_pdcache_size;
	int	ct_pdcache_line_size;
	int	ct_pdcache_ways;
	int	ct_picache_size;
	int	ct_picache_line_size;
	int	ct_picache_ways;
};

struct cachetab cachetab[] = {
    /* cpuid,		cache type,	  u,  dsiz, ls, wy,  isiz, ls, wy */
    /* XXX is this type right for SA-1? */
    { CPU_ID_SA1100,	CPU_CT_CTYPE_WB1, 0,  8192, 32, 32, 16384, 32, 32 },
    { CPU_ID_SA1110,	CPU_CT_CTYPE_WB1, 0,  8192, 32, 32, 16384, 32, 32 },
    { CPU_ID_IXP1200,	CPU_CT_CTYPE_WB1, 0, 16384, 32, 32, 16384, 32, 32 }, /* XXX */
    { 0, 0, 0, 0, 0, 0, 0, 0}
};

static void get_cachetype_table (void);

static void
get_cachetype_table()
{
	int i;
	u_int32_t cpuid = cpufunc_id();

	for (i = 0; cachetab[i].ct_cpuid != 0; i++) {
		if (cachetab[i].ct_cpuid == (cpuid & CPU_ID_CPU_MASK)) {
			arm_pcache_type = cachetab[i].ct_pcache_type;
			arm_pcache_unified = cachetab[i].ct_pcache_unified;
			arm_pdcache_size = cachetab[i].ct_pdcache_size;
			arm_pdcache_line_size =
			    cachetab[i].ct_pdcache_line_size;
			arm_pdcache_ways = cachetab[i].ct_pdcache_ways;
			arm_picache_size = cachetab[i].ct_picache_size;
			arm_picache_line_size =
			    cachetab[i].ct_picache_line_size;
			arm_picache_ways = cachetab[i].ct_picache_ways;
		}
	}
	arm_dcache_align = arm_pdcache_line_size;

	arm_dcache_align_mask = arm_dcache_align - 1;
}

#endif /* SA110 || SA1100 || SA1111 || IXP12X0 */

a715 35
#ifdef CPU_SA1100
	if (cputype == CPU_ID_SA1100) {
		cpufuncs = sa11x0_cpufuncs;
		cpu_reset_needs_v4_MMU_disable = 1;	/* SA needs it	*/
		get_cachetype_table();
		pmap_pte_init_sa1();

		/* Use powersave on this CPU. */
		cpu_do_powersave = 1;

		return 0;
	}
#endif	/* CPU_SA1100 */
#ifdef CPU_SA1110
	if (cputype == CPU_ID_SA1110) {
		cpufuncs = sa11x0_cpufuncs;
		cpu_reset_needs_v4_MMU_disable = 1;	/* SA needs it	*/
		get_cachetype_table();
		pmap_pte_init_sa1();

		/* Use powersave on this CPU. */
		cpu_do_powersave = 1;

		return 0;
	}
#endif	/* CPU_SA1110 */
#ifdef CPU_IXP12X0
	if (cputype == CPU_ID_IXP1200) {
		cpufuncs = ixp12x0_cpufuncs;
		cpu_reset_needs_v4_MMU_disable = 1;
		get_cachetype_table();
		pmap_pte_init_sa1();
		return 0;
	}
#endif  /* CPU_IXP12X0 */
a967 59

#if defined(CPU_SA1100) || defined(CPU_SA1110)
void
sa11x0_setup()
{
	int cpuctrl, cpuctrlmask;

	cpuctrl = CPU_CONTROL_MMU_ENABLE | CPU_CONTROL_32BP_ENABLE
		 | CPU_CONTROL_32BD_ENABLE | CPU_CONTROL_SYST_ENABLE
		 | CPU_CONTROL_IC_ENABLE | CPU_CONTROL_DC_ENABLE
		 | CPU_CONTROL_WBUF_ENABLE | CPU_CONTROL_LABT_ENABLE
		 | CPU_CONTROL_AFLT_ENABLE;
	cpuctrlmask = CPU_CONTROL_MMU_ENABLE | CPU_CONTROL_32BP_ENABLE
		 | CPU_CONTROL_32BD_ENABLE | CPU_CONTROL_SYST_ENABLE
		 | CPU_CONTROL_IC_ENABLE | CPU_CONTROL_DC_ENABLE
		 | CPU_CONTROL_WBUF_ENABLE | CPU_CONTROL_ROM_ENABLE
		 | CPU_CONTROL_BEND_ENABLE | CPU_CONTROL_AFLT_ENABLE
		 | CPU_CONTROL_LABT_ENABLE | CPU_CONTROL_BPRD_ENABLE
		 | CPU_CONTROL_CPCLK | CPU_CONTROL_VECRELOC;

	if (vector_page == ARM_VECTORS_HIGH)
		cpuctrl |= CPU_CONTROL_VECRELOC;

	/* Clear out the cache */
	cpu_idcache_wbinv_all();

	/* Set the control register */
	cpu_control(0xffffffff, cpuctrl);
}
#endif	/* CPU_SA1100 || CPU_SA1110 */

#if defined(CPU_IXP12X0)
void
ixp12x0_setup()
{
	int cpuctrl, cpuctrlmask;


	cpuctrl = CPU_CONTROL_MMU_ENABLE | CPU_CONTROL_DC_ENABLE
		 | CPU_CONTROL_WBUF_ENABLE | CPU_CONTROL_SYST_ENABLE
		 | CPU_CONTROL_IC_ENABLE | CPU_CONTROL_AFLT_ENABLE;
	cpuctrlmask = CPU_CONTROL_MMU_ENABLE | CPU_CONTROL_AFLT_ENABLE
		 | CPU_CONTROL_DC_ENABLE | CPU_CONTROL_WBUF_ENABLE
		 | CPU_CONTROL_BEND_ENABLE | CPU_CONTROL_SYST_ENABLE
		 | CPU_CONTROL_ROM_ENABLE | CPU_CONTROL_IC_ENABLE
		 | CPU_CONTROL_VECRELOC;

	if (vector_page == ARM_VECTORS_HIGH)
		cpuctrl |= CPU_CONTROL_VECRELOC;

	/* Clear out the cache */
	cpu_idcache_wbinv_all();

	/* Set the control register */
	curcpu()->ci_ctrl = cpuctrl;
	/* cpu_control(0xffffffff, cpuctrl); */
	cpu_control(cpuctrlmask, cpuctrl);
}
#endif /* CPU_IXP12X0 */
@


1.29
log
@Remove support for ARM8, an old armv4 processor without thumb that was
never supported by any arm port and wouldn't have built due to a missing
cpufunc_asm_arm8.S file.

From Patrick Wildt.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.c,v 1.28 2016/03/02 23:50:32 jsg Exp $	*/
a99 58
#ifdef CPU_ARM9
struct cpu_functions arm9_cpufuncs = {
	/* CPU functions */

	cpufunc_id,			/* id			*/
	cpufunc_nullop,			/* cpwait		*/

	/* MMU functions */

	cpufunc_control,		/* control		*/
	cpufunc_domains,		/* Domain		*/
	arm9_setttb,			/* Setttb		*/
	cpufunc_dfsr,			/* dfsr			*/
	cpufunc_dfar,			/* dfar			*/
	cpufunc_ifsr,			/* ifsr			*/
	cpufunc_ifar,			/* ifar			*/

	/* TLB functions */

	armv4_tlb_flushID,		/* tlb_flushID		*/
	arm9_tlb_flushID_SE,		/* tlb_flushID_SE	*/
	armv4_tlb_flushI,		/* tlb_flushI		*/
	(void *)armv4_tlb_flushI,	/* tlb_flushI_SE	*/
	armv4_tlb_flushD,		/* tlb_flushD		*/
	armv4_tlb_flushD_SE,		/* tlb_flushD_SE	*/

	/* Cache operations */

	arm9_icache_sync_all,		/* icache_sync_all	*/
	arm9_icache_sync_range,		/* icache_sync_range	*/

		/* ...cache in write-though mode... */
	arm9_dcache_wbinv_all,		/* dcache_wbinv_all	*/
	arm9_dcache_wbinv_range,	/* dcache_wbinv_range	*/
	arm9_dcache_wbinv_range,	/* dcache_inv_range	*/
	arm9_dcache_wb_range,		/* dcache_wb_range	*/

	arm9_idcache_wbinv_all,		/* idcache_wbinv_all	*/
	arm9_idcache_wbinv_range,	/* idcache_wbinv_range	*/

	cpufunc_nullop,			/* sdcache_wbinv_all	*/
	(void *)cpufunc_nullop,		/* sdcache_wbinv_range	*/
	(void *)cpufunc_nullop,		/* sdcache_inv_range	*/
	(void *)cpufunc_nullop,		/* sdcache_wb_range	*/

	/* Other functions */

	cpufunc_nullop,			/* flush_prefetchbuf	*/
	armv4_drain_writebuf,		/* drain_writebuf	*/

	(void *)cpufunc_nullop,		/* sleep		*/

	/* Soft functions */
	arm9_context_switch,		/* context_switch	*/
	arm9_setup			/* cpu setup		*/
};
#endif /* CPU_ARM9 */

d512 1
a512 2
#if defined(CPU_ARM9) || \
    defined(CPU_ARM9E) || defined(CPU_ARM10) || defined(CPU_ARM11) || \
a808 17
#ifdef CPU_ARM9
	if (((cputype & CPU_ID_IMPLEMENTOR_MASK) == CPU_ID_ARM_LTD ||
	     (cputype & CPU_ID_IMPLEMENTOR_MASK) == CPU_ID_TI) &&
	    (cputype & 0x0000f000) == 0x00009000) {
		cpufuncs = arm9_cpufuncs;
		cpu_reset_needs_v4_MMU_disable = 1;	/* V4 or higher */
		get_cachetype_cp15();
		arm9_dcache_sets_inc = 1U << arm_dcache_l2_linesize;
		arm9_dcache_sets_max =
		    (1U << (arm_dcache_l2_linesize + arm_dcache_l2_nsets)) -
		    arm9_dcache_sets_inc;
		arm9_dcache_index_inc = 1U << (32 - arm_dcache_l2_assoc);
		arm9_dcache_index_max = 0U - arm9_dcache_index_inc;
		pmap_pte_init_arm9();
		return 0;
	}
#endif /* CPU_ARM9 */
a1055 31

#ifdef CPU_ARM9
void
arm9_setup()
{
	int cpuctrl, cpuctrlmask;

	cpuctrl = CPU_CONTROL_MMU_ENABLE | CPU_CONTROL_32BP_ENABLE
	    | CPU_CONTROL_32BD_ENABLE | CPU_CONTROL_SYST_ENABLE
	    | CPU_CONTROL_IC_ENABLE | CPU_CONTROL_DC_ENABLE
	    | CPU_CONTROL_WBUF_ENABLE | CPU_CONTROL_AFLT_ENABLE;
	cpuctrlmask = CPU_CONTROL_MMU_ENABLE | CPU_CONTROL_32BP_ENABLE
		 | CPU_CONTROL_32BD_ENABLE | CPU_CONTROL_SYST_ENABLE
		 | CPU_CONTROL_IC_ENABLE | CPU_CONTROL_DC_ENABLE
		 | CPU_CONTROL_WBUF_ENABLE | CPU_CONTROL_ROM_ENABLE
		 | CPU_CONTROL_BEND_ENABLE | CPU_CONTROL_AFLT_ENABLE
		 | CPU_CONTROL_LABT_ENABLE | CPU_CONTROL_VECRELOC
		 | CPU_CONTROL_ROUNDROBIN;

	if (vector_page == ARM_VECTORS_HIGH)
		cpuctrl |= CPU_CONTROL_VECRELOC;

	/* Clear out the cache */
	cpu_idcache_wbinv_all();

	/* Set the control register */
	curcpu()->ci_ctrl = cpuctrl;
	cpu_control(cpuctrlmask, cpuctrl);

}
#endif	/* CPU_ARM9 */
@


1.28
log
@set armv7 callbacks for cortex a53/a52/a72
from Patrick Wildt who tested this on cortex a53
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.c,v 1.27 2015/05/29 05:48:07 jsg Exp $	*/
a99 57
#ifdef CPU_ARM8
struct cpu_functions arm8_cpufuncs = {
	/* CPU functions */

	cpufunc_id,			/* id			*/
	cpufunc_nullop,			/* cpwait		*/

	/* MMU functions */

	cpufunc_control,		/* control		*/
	cpufunc_domains,		/* domain		*/
	arm8_setttb,			/* setttb		*/
	cpufunc_dfsr,			/* dfsr			*/
	cpufunc_dfar,			/* dfar			*/
	cpufunc_ifsr,			/* ifsr			*/
	cpufunc_ifar,			/* ifar			*/

	/* TLB functions */

	arm8_tlb_flushID,		/* tlb_flushID		*/
	arm8_tlb_flushID_SE,		/* tlb_flushID_SE	*/
	arm8_tlb_flushID,		/* tlb_flushI		*/
	arm8_tlb_flushID_SE,		/* tlb_flushI_SE	*/
	arm8_tlb_flushID,		/* tlb_flushD		*/
	arm8_tlb_flushID_SE,		/* tlb_flushD_SE	*/

	/* Cache operations */

	cpufunc_nullop,			/* icache_sync_all	*/
	(void *)cpufunc_nullop,		/* icache_sync_range	*/

	arm8_cache_purgeID,		/* dcache_wbinv_all	*/
	(void *)arm8_cache_purgeID,	/* dcache_wbinv_range	*/
/*XXX*/	(void *)arm8_cache_purgeID,	/* dcache_inv_range	*/
	(void *)arm8_cache_cleanID,	/* dcache_wb_range	*/

	arm8_cache_purgeID,		/* idcache_wbinv_all	*/
	(void *)arm8_cache_purgeID,	/* idcache_wbinv_range	*/

	cpufunc_nullop,			/* sdcache_wbinv_all	*/
	(void *)cpufunc_nullop,		/* sdcache_wbinv_range	*/
	(void *)cpufunc_nullop,		/* sdcache_inv_range	*/
	(void *)cpufunc_nullop,		/* sdcache_wb_range	*/

	/* Other functions */

	cpufunc_nullop,			/* flush_prefetchbuf	*/
	cpufunc_nullop,			/* drain_writebuf	*/

	(void *)cpufunc_nullop,		/* sleep		*/

	/* Soft functions */
	arm8_context_switch,		/* context_switch	*/
	arm8_setup			/* cpu setup		*/
};
#endif	/* CPU_ARM8 */

d570 1
a570 1
#if defined(CPU_ARM8) || defined(CPU_ARM9) || \
d650 1
a650 1
#endif /* ARM7TDMI || ARM8 || ARM9 || XSCALE */
a867 10
#ifdef CPU_ARM8
	if ((cputype & CPU_ID_IMPLEMENTOR_MASK) == CPU_ID_ARM_LTD &&
	    (cputype & 0x0000f000) == 0x00008000) {
		cpufuncs = arm8_cpufuncs;
		cpu_reset_needs_v4_MMU_disable = 0;	/* XXX correct? */
		get_cachetype_cp15();
		pmap_pte_init_arm8();
		return 0;
	}
#endif	/* CPU_ARM8 */
a1131 35

#ifdef CPU_ARM8
void
arm8_setup()
{
	int integer;
	int cpuctrl, cpuctrlmask;
	int clocktest;
	int setclock = 0;

	cpuctrl = CPU_CONTROL_MMU_ENABLE | CPU_CONTROL_32BP_ENABLE
		 | CPU_CONTROL_32BD_ENABLE | CPU_CONTROL_SYST_ENABLE
		 | CPU_CONTROL_IDC_ENABLE | CPU_CONTROL_WBUF_ENABLE
		 | CPU_CONTROL_AFLT_ENABLE;
	cpuctrlmask = CPU_CONTROL_MMU_ENABLE | CPU_CONTROL_32BP_ENABLE
		 | CPU_CONTROL_32BD_ENABLE | CPU_CONTROL_SYST_ENABLE
		 | CPU_CONTROL_IDC_ENABLE | CPU_CONTROL_WBUF_ENABLE
		 | CPU_CONTROL_BPRD_ENABLE | CPU_CONTROL_ROM_ENABLE
		 | CPU_CONTROL_BEND_ENABLE | CPU_CONTROL_AFLT_ENABLE;

	/* Get clock configuration */
	clocktest = arm8_clock_config(0, 0) & 0x0f;

	/* Clear out the cache */
	cpu_idcache_wbinv_all();

	/* Set the control register */
	curcpu()->ci_ctrl = cpuctrl;
	cpu_control(0xffffffff, cpuctrl);

	/* Set the clock/test register */
	if (setclock)
		arm8_clock_config(0x7f, clocktest);
}
#endif	/* CPU_ARM8 */
@


1.27
log
@add some more cortex A ids
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.c,v 1.26 2014/04/03 10:17:34 mpi Exp $	*/
d1006 4
a1009 1
	    (cputype & CPU_ID_CORTEX_A17_MASK) == CPU_ID_CORTEX_A17) {
@


1.26
log
@More uvm_extern.h cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.c,v 1.25 2014/03/29 18:09:28 guenther Exp $	*/
d1005 2
a1006 1
	    (cputype & CPU_ID_CORTEX_A15_MASK) == CPU_ID_CORTEX_A15) {
@


1.25
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.c,v 1.24 2013/09/03 16:48:26 patrick Exp $	*/
d53 1
a53 1
#include <uvm/uvm.h>
d55 1
@


1.24
log
@Rewrite the ARMv7 cache discovery, as some assumptions in the previous one
were utterly wrong.  Fix Log2(), correct one taken from the scheduler code.

Tested by rapha@@ and Artturi Alm.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.c,v 1.23 2013/05/18 17:48:48 patrick Exp $	*/
d644 1
a644 1
	__asm __volatile("mrc p15, 0, %0, c0, c0, 1"
d789 1
a789 1
	__asm __volatile("mrc p15, 1, %0, c0, c0, 1"
d805 1
a805 1
			__asm __volatile("mcr p15, 2, %0, c0, c0, 0"
d809 1
a809 1
			__asm __volatile("mrc p15, 1, %0, c0, c0, 0"
d834 1
a834 1
			__asm __volatile("mcr p15, 2, %0, c0, c0, 0"
d838 1
a838 1
			__asm __volatile("mrc p15, 1, %0, c0, c0, 0"
d863 1
a863 1
	__asm __volatile("mcr	p15, 0, r0, c7, c5, 0" :: "r" (arg));
d895 1
a895 1
			__asm __volatile("mcr	p15, 0, %0, c7, c10, 2"
d1070 1
a1070 1
		__asm __volatile("mcr p14, 0, %0, c0, c0, 0"
d1080 1
a1080 1
		__asm __volatile ("mcr p14, 0, %0, c6, c0, 0"
d1090 1
a1090 1
		__asm __volatile("mcr p13, 0, %0, c0, c1, 0"
d1129 1
a1129 1
		__asm __volatile("mcr p14, 0, %0, c0, c0, 0"
d1285 1
a1285 1
	__asm __volatile ("mcr\tp15, 0, r0, c7, c7, 0" : : );
d1303 1
a1303 1
	__asm __volatile ("mcr\tp15, 0, %0, c1, c0, 2" : : "r" (0x0fffffff));
d1476 1
a1476 1
	__asm __volatile("mrc p15, 0, %0, c1, c0, 1"
d1483 1
a1483 1
	__asm __volatile("mcr p15, 0, %0, c1, c0, 1"
@


1.23
log
@Mask out the TEX remap and the Access Flag bits when setting the
system control register. Also actually use the mask.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.c,v 1.22 2013/05/18 17:42:11 patrick Exp $	*/
d766 3
d770 1
a770 1
log2(int size)
d772 6
a777 5
	int i = 0;
	while (size != 0)
	for (i = 0; size != 0; i++)
		size >>= 1;
	return i;
a782 1
	extern int pmap_cachevivt;
d785 2
a786 21
	uint32_t line_size, ways, sets, size;
	uint32_t sel;
	uint32_t ctr;

	__asm __volatile("mrc p15, 0, %0, c0, c0, 1"
		: "=r" (ctr) :);

	switch ((ctr >> 14) & 3) {
	case 2:
		pmap_cachevivt = 0;
	#if 0
		pmap_alias_dist = 0x4000;
		pmap_alias_bits = 0x3000;
	#endif
		break;
	case 3:
		pmap_cachevivt = 0;
		break;
	default:
		break;
	}
d788 1
d791 1
d793 53
a845 27
	/* dcache L1 */
	sel = 0;
	__asm __volatile("mcr p15, 2, %0, c0, c0, 0"
		:: "r" (sel));
	cpu_drain_writebuf();
	__asm __volatile("mrc p15, 1, %0, c0, c0, 0"
		: "=r" (cachereg) :);
	line_size = 1 << ((cachereg & 7)+4);
	ways = ((0x00000ff8 & cachereg) >> 3) + 1;
	sets = ((0x0ffff000 & cachereg) >> 13) + 1;
	arm_pcache_unified = (cache_level_id & 0x7) == 2;
	arm_pdcache_line_size = line_size;
	arm_pdcache_ways = ways;
	size = line_size * ways * sets;
	arm_pdcache_size = size;

	switch (cachereg & 0xc0000000) {
	case 0x00000000:
		arm_pcache_type = 0;
		break;
	case 0x40000000:
	case 0xc0000000:
		arm_pcache_type = CPU_CT_CTYPE_WB1;
		break;
	case 0x80000000:
		arm_pcache_type = CPU_CT_CTYPE_WT;
		break;
a847 15
	/* icache L1 */
	sel = 1;
	__asm __volatile("mcr p15, 2, %0, c0, c0, 0"
		:: "r" (sel));
	cpu_drain_writebuf();
	__asm __volatile("mrc p15, 1, %0, c0, c0, 0"
		: "=r" (cachereg) :);
	line_size = 1 << ((cachereg & 7)+4);
	ways = ((0x00000ff8 & cachereg) >> 3) + 1;
	sets = ((0x0ffff000 & cachereg) >> 13) + 1;
	arm_picache_line_size = line_size;
	size = line_size * ways * sets;
	arm_picache_size = size;
	arm_picache_ways = ways;

a848 1

d851 3
a853 13
	/* ucache L2 */
	sel = 1;
	__asm __volatile("mcr p15, 2, %0, c0, c0, 0"
		:: "r" (sel));
	cpu_drain_writebuf();
	__asm __volatile("mrc p15, 1, %0, c0, c0, 0"
		: "=r" (cachereg) :);
	line_size = 1 << ((cachereg & 7)+4);
	ways = ((0x00000ff8 & cachereg) >> 3) + 1;
	sets = ((0x0ffff000 & cachereg) >> 13) + 1;
	arm_dcache_l2_nsets = log2(sets);
	arm_dcache_l2_assoc = log2(ways);
	arm_dcache_l2_linesize = log2(line_size);
d871 1
a871 1
	int nincr, nsets, nways;
d876 2
a877 3
	nsets = arm_picache_size/arm_picache_ways/arm_picache_line_size;
	nways = arm_picache_ways;
	nincr = arm_picache_line_size;
d879 2
a880 2
	wayincr = 1 << (32 - arm_picache_ways);
	setincr = arm_picache_line_size;
d883 2
a884 2
	printf("l1 nsets %d nways %d nincr %d wayincr %x setincr %x\n",
	    nsets, nways, nincr, wayincr, setincr);
d886 1
a886 1
	
d897 1
a897 31
			wayval += nincr;
		}
		setval += setincr;
	}
	/* drain the write buffer */
	cpu_drain_writebuf();

	/* L2 */
	nsets = 1 << arm_dcache_l2_nsets;
	nways = 1 << arm_dcache_l2_assoc;
	nincr = 1 << arm_dcache_l2_linesize;

	wayincr = 1 << (32 - arm_picache_ways);
	setincr = arm_picache_line_size;

#if 0
	printf("l2 nsets %d nways %d nincr %d wayincr %x setincr %x\n",
	    nsets, nways, nincr, wayincr, setincr);
#endif
	
	lvl = 1 << 1; /* L2 */
	setval = 0;
	for (sets = 0; sets < nsets; sets++)  {
		wayval = 0;
		for (ways = 0; ways < nways; ways++) {
			word = wayval | setval | lvl;

			/* Clean D cache SE with Set/Index */
			__asm __volatile("mcr	p15, 0, %0, c7, c10, 2"
			    : : "r" (word));
			wayval += nincr;
d904 1
@


1.22
log
@Make sure we executed the instruction before continuing. Also
replace calls to drain the write buffer with the correct ones for armv7.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.c,v 1.21 2013/05/18 17:34:01 patrick Exp $	*/
d1395 2
a1396 1
	    | CPU_CONTROL_VECRELOC | CPU_CONTROL_FI | CPU_CONTROL_VE;
d1412 1
a1412 1
	cpu_control(0xffffffff, cpuctrl);
@


1.21
log
@Use the actual armv7 dcache_inv_range function instead of the wbinv one.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.c,v 1.20 2013/03/27 00:06:09 patrick Exp $	*/
d811 1
d840 1
d859 1
d917 1
a917 1
	__asm __volatile("mcr	p15, 0, %0, c7, c10, 4" : : "r" (0));
d947 1
a947 1
	__asm __volatile("mcr	p15, 0, %0, c7, c10, 4" : : "r" (0));
@


1.20
log
@Add prototypes for secondary cache operations.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.c,v 1.19 2013/03/22 21:24:11 patrick Exp $	*/
d420 1
a420 1
/*XXX*/	armv7_dcache_wbinv_range,	/* dcache_inv_range	*/
@


1.19
log
@Use different setup functions for ARM9E and ARM10 to fix an undefined
instruction fault on ARM9E caused by a coprocessor call.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.c,v 1.18 2013/01/23 19:57:47 patrick Exp $	*/
d138 5
d196 5
d254 5
d312 5
d369 5
d426 5
d484 5
d541 5
d598 5
@


1.18
log
@Add instruction fault register functions, which will be needed for further
ARMv7 support.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.c,v 1.17 2013/01/18 00:20:20 patrick Exp $	*/
d253 1
a253 1
	arm10_setup			/* cpu setup		*/
d1259 1
a1259 1
arm10_setup()
a1282 3
	/* Allow detection code to find the VFP if it's fitted.  */
	__asm __volatile ("mcr\tp15, 0, %0, c1, c0, 2" : : "r" (0x0fffffff));

d1291 11
@


1.17
log
@Update the ARM CPU ID information. The IDs aren't vendor/product
specific, they are specific to the ARM CPUs themselves.

ok bmercer@@ jsg@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.c,v 1.16 2011/11/08 17:06:51 deraadt Exp $	*/
d111 4
a114 2
	cpufunc_faultstatus,		/* faultstatus		*/
	cpufunc_faultaddress,		/* faultaddress		*/
d163 4
a166 2
	cpufunc_faultstatus,		/* Faultstatus		*/
	cpufunc_faultaddress,		/* Faultaddress		*/
d216 4
a219 2
	cpufunc_faultstatus,		/* Faultstatus		*/
	cpufunc_faultaddress,		/* Faultaddress		*/
d270 4
a273 2
	cpufunc_faultstatus,		/* Faultstatus		*/
	cpufunc_faultaddress,		/* Faultaddress		*/
d322 4
a325 2
	cpufunc_faultstatus,		/* Faultstatus			*/
	cpufunc_faultaddress,		/* Faultaddress			*/
d374 4
a377 2
	cpufunc_faultstatus,		/* Faultstatus		*/
	cpufunc_faultaddress,		/* Faultaddress		*/
d427 4
a430 2
	cpufunc_faultstatus,		/* faultstatus		*/
	cpufunc_faultaddress,		/* faultaddress		*/
d479 4
a482 2
	cpufunc_faultstatus,		/* faultstatus		*/
	cpufunc_faultaddress,		/* faultaddress		*/
d532 4
a535 2
	cpufunc_faultstatus,		/* faultstatus		*/
	cpufunc_faultaddress,		/* faultaddress		*/
@


1.16
log
@remove support for big endian; ok drahn
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.c,v 1.15 2011/11/06 13:47:57 miod Exp $	*/
d978 5
a982 1
	if ((cputype & CPU_ID_CORTEX_A8_MASK) == CPU_ID_CORTEX_A8) {
@


1.15
log
@Correctly report WB and WT cache modes on v7 (they were swapped). ok uwe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.c,v 1.14 2011/09/20 22:02:10 miod Exp $	*/
a1187 4
#ifdef __ARMEB__
	cpuctrl |= CPU_CONTROL_BEND_ENABLE;
#endif

a1221 4
#ifdef __ARMEB__
	cpuctrl |= CPU_CONTROL_BEND_ENABLE;
#endif

a1251 4
#ifdef __ARMEB__
	cpuctrl |= CPU_CONTROL_BEND_ENABLE;
#endif

a1287 4
#ifdef __ARMEB__
	cpuctrl |= CPU_CONTROL_BEND_ENABLE;
#endif

a1358 4
#ifdef __ARMEB__
	cpuctrl |= CPU_CONTROL_BEND_ENABLE;
#endif

a1385 4
#ifdef __ARMEB__
	cpuctrl |= CPU_CONTROL_BEND_ENABLE;
#endif

a1424 4

#ifdef __ARMEB__
	cpuctrl |= CPU_CONTROL_BEND_ENABLE;
#endif
@


1.14
log
@Late spring cleaning of the arm code for old dusty bits we do not want to
keep:
- remove bootconfig parameter passing feature (unused).
- unifdef __PROG32 and remove all remains of arm26 code.
- remove ARMFPE support (unused).
- remove support for ARM2, ARM2AS, ARM3, ARM6, ARM7, ARM7TDMI and StrongARM
  processor families, and the related silicon bug workarounds (especially
  the SA-110 STM^ bug).
- remove cpu_functions no longer necessary after previous removals.
- remove ARM32_DISABLE_ALIGNMENT_FAULTS option (unused).
- make FIQ support conditional on option FIQ (unused, but may be eventually).

Discussed with drahn@@ and jasper@@ long ago, I was sitting on this commit for
no good reason.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.c,v 1.13 2010/07/01 22:40:10 drahn Exp $	*/
d764 4
a769 3
	case 0x80000000:
	case 0xc0000000:
		arm_pcache_type = CPU_CT_CTYPE_WB1;
@


1.13
log
@Add more support bits for ARMv7, including frame for VIPT (pmap_prefer).
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.c,v 1.12 2010/02/22 16:45:29 kevlo Exp $	*/
a51 4
#include <uvm/uvm.h>
#include <machine/cpu.h>
#include <machine/pmap.h>
#include <machine/bootconfig.h>
a98 236
#ifdef CPU_ARM3
struct cpu_functions arm3_cpufuncs = {
	/* CPU functions */

	cpufunc_id,			/* id			*/
	cpufunc_nullop,			/* cpwait		*/

	/* MMU functions */

	arm3_control,			/* control		*/
	NULL,				/* domain		*/
	NULL,				/* setttb		*/
	NULL,				/* faultstatus		*/
	NULL,				/* faultaddress		*/

	/* TLB functions */

	cpufunc_nullop,			/* tlb_flushID		*/
	(void *)cpufunc_nullop,		/* tlb_flushID_SE	*/
	cpufunc_nullop,			/* tlb_flushI		*/
	(void *)cpufunc_nullop,		/* tlb_flushI_SE	*/
	cpufunc_nullop,			/* tlb_flushD		*/
	(void *)cpufunc_nullop,		/* tlb_flushD_SE	*/

	/* Cache operations */

	cpufunc_nullop,			/* icache_sync_all	*/
	(void *) cpufunc_nullop,	/* icache_sync_range	*/

	arm3_cache_flush,		/* dcache_wbinv_all	*/
	(void *)arm3_cache_flush,	/* dcache_wbinv_range	*/
	(void *)arm3_cache_flush,	/* dcache_inv_range	*/
	(void *)cpufunc_nullop,		/* dcache_wb_range	*/

	arm3_cache_flush,		/* idcache_wbinv_all	*/
	(void *)arm3_cache_flush,	/* idcache_wbinv_range	*/

	/* Other functions */

	cpufunc_nullop,			/* flush_prefetchbuf	*/
	cpufunc_nullop,			/* drain_writebuf	*/
	cpufunc_nullop,			/* flush_brnchtgt_C	*/
	(void *)cpufunc_nullop,		/* flush_brnchtgt_E	*/

	(void *)cpufunc_nullop,		/* sleep		*/

	/* Soft functions */

	early_abort_fixup,		/* dataabt_fixup	*/
	cpufunc_null_fixup,		/* prefetchabt_fixup	*/

	NULL,				/* context_switch	*/

	(void *)cpufunc_nullop		/* cpu setup		*/

};
#endif	/* CPU_ARM3 */

#ifdef CPU_ARM6
struct cpu_functions arm6_cpufuncs = {
	/* CPU functions */

	cpufunc_id,			/* id			*/
	cpufunc_nullop,			/* cpwait		*/

	/* MMU functions */

	cpufunc_control,		/* control		*/
	cpufunc_domains,		/* domain		*/
	arm67_setttb,			/* setttb		*/
	cpufunc_faultstatus,		/* faultstatus		*/
	cpufunc_faultaddress,		/* faultaddress		*/

	/* TLB functions */

	arm67_tlb_flush,		/* tlb_flushID		*/
	arm67_tlb_purge,		/* tlb_flushID_SE	*/
	arm67_tlb_flush,		/* tlb_flushI		*/
	arm67_tlb_purge,		/* tlb_flushI_SE	*/
	arm67_tlb_flush,		/* tlb_flushD		*/
	arm67_tlb_purge,		/* tlb_flushD_SE	*/

	/* Cache operations */

	cpufunc_nullop,			/* icache_sync_all	*/
	(void *) cpufunc_nullop,	/* icache_sync_range	*/

	arm67_cache_flush,		/* dcache_wbinv_all	*/
	(void *)arm67_cache_flush,	/* dcache_wbinv_range	*/
	(void *)arm67_cache_flush,	/* dcache_inv_range	*/
	(void *)cpufunc_nullop,		/* dcache_wb_range	*/

	arm67_cache_flush,		/* idcache_wbinv_all	*/
	(void *)arm67_cache_flush,	/* idcache_wbinv_range	*/

	/* Other functions */

	cpufunc_nullop,			/* flush_prefetchbuf	*/
	cpufunc_nullop,			/* drain_writebuf	*/
	cpufunc_nullop,			/* flush_brnchtgt_C	*/
	(void *)cpufunc_nullop,		/* flush_brnchtgt_E	*/

	(void *)cpufunc_nullop,		/* sleep		*/

	/* Soft functions */

#ifdef ARM6_LATE_ABORT
	late_abort_fixup,		/* dataabt_fixup	*/
#else
	early_abort_fixup,		/* dataabt_fixup	*/
#endif
	cpufunc_null_fixup,		/* prefetchabt_fixup	*/

	arm67_context_switch,		/* context_switch	*/

	arm6_setup			/* cpu setup		*/

};
#endif	/* CPU_ARM6 */

#ifdef CPU_ARM7
struct cpu_functions arm7_cpufuncs = {
	/* CPU functions */

	cpufunc_id,			/* id			*/
	cpufunc_nullop,			/* cpwait		*/

	/* MMU functions */

	cpufunc_control,		/* control		*/
	cpufunc_domains,		/* domain		*/
	arm67_setttb,			/* setttb		*/
	cpufunc_faultstatus,		/* faultstatus		*/
	cpufunc_faultaddress,		/* faultaddress		*/

	/* TLB functions */

	arm67_tlb_flush,		/* tlb_flushID		*/
	arm67_tlb_purge,		/* tlb_flushID_SE	*/
	arm67_tlb_flush,		/* tlb_flushI		*/
	arm67_tlb_purge,		/* tlb_flushI_SE	*/
	arm67_tlb_flush,		/* tlb_flushD		*/
	arm67_tlb_purge,		/* tlb_flushD_SE	*/

	/* Cache operations */

	cpufunc_nullop,			/* icache_sync_all	*/
	(void *)cpufunc_nullop,		/* icache_sync_range	*/

	arm67_cache_flush,		/* dcache_wbinv_all	*/
	(void *)arm67_cache_flush,	/* dcache_wbinv_range	*/
	(void *)arm67_cache_flush,	/* dcache_inv_range	*/
	(void *)cpufunc_nullop,		/* dcache_wb_range	*/

	arm67_cache_flush,		/* idcache_wbinv_all	*/
	(void *)arm67_cache_flush,	/* idcache_wbinv_range	*/

	/* Other functions */

	cpufunc_nullop,			/* flush_prefetchbuf	*/
	cpufunc_nullop,			/* drain_writebuf	*/
	cpufunc_nullop,			/* flush_brnchtgt_C	*/
	(void *)cpufunc_nullop,		/* flush_brnchtgt_E	*/

	(void *)cpufunc_nullop,		/* sleep		*/

	/* Soft functions */

	late_abort_fixup,		/* dataabt_fixup	*/
	cpufunc_null_fixup,		/* prefetchabt_fixup	*/

	arm67_context_switch,		/* context_switch	*/

	arm7_setup			/* cpu setup		*/

};
#endif	/* CPU_ARM7 */

#ifdef CPU_ARM7TDMI
struct cpu_functions arm7tdmi_cpufuncs = {
	/* CPU functions */

	cpufunc_id,			/* id			*/
	cpufunc_nullop,			/* cpwait		*/

	/* MMU functions */

	cpufunc_control,		/* control		*/
	cpufunc_domains,		/* domain		*/
	arm7tdmi_setttb,		/* setttb		*/
	cpufunc_faultstatus,		/* faultstatus		*/
	cpufunc_faultaddress,		/* faultaddress		*/

	/* TLB functions */

	arm7tdmi_tlb_flushID,		/* tlb_flushID		*/
	arm7tdmi_tlb_flushID_SE,	/* tlb_flushID_SE	*/
	arm7tdmi_tlb_flushID,		/* tlb_flushI		*/
	arm7tdmi_tlb_flushID_SE,	/* tlb_flushI_SE	*/
	arm7tdmi_tlb_flushID,		/* tlb_flushD		*/
	arm7tdmi_tlb_flushID_SE,	/* tlb_flushD_SE	*/

	/* Cache operations */

	cpufunc_nullop,			/* icache_sync_all	*/
	(void *)cpufunc_nullop,		/* icache_sync_range	*/

	arm7tdmi_cache_flushID,		/* dcache_wbinv_all	*/
	(void *)arm7tdmi_cache_flushID,	/* dcache_wbinv_range	*/
	(void *)arm7tdmi_cache_flushID,	/* dcache_inv_range	*/
	(void *)cpufunc_nullop,		/* dcache_wb_range	*/

	arm7tdmi_cache_flushID,		/* idcache_wbinv_all	*/
	(void *)arm7tdmi_cache_flushID,	/* idcache_wbinv_range	*/

	/* Other functions */

	cpufunc_nullop,			/* flush_prefetchbuf	*/
	cpufunc_nullop,			/* drain_writebuf	*/
	cpufunc_nullop,			/* flush_brnchtgt_C	*/
	(void *)cpufunc_nullop,		/* flush_brnchtgt_E	*/

	(void *)cpufunc_nullop,		/* sleep		*/

	/* Soft functions */

	late_abort_fixup,		/* dataabt_fixup	*/
	cpufunc_null_fixup,		/* prefetchabt_fixup	*/

	arm7tdmi_context_switch,	/* context_switch	*/

	arm7tdmi_setup			/* cpu setup		*/

};
#endif	/* CPU_ARM7TDMI */

a139 2
	cpufunc_nullop,			/* flush_brnchtgt_C	*/
	(void *)cpufunc_nullop,		/* flush_brnchtgt_E	*/
a143 4

	cpufunc_null_fixup,		/* dataabt_fixup	*/
	cpufunc_null_fixup,		/* prefetchabt_fixup	*/

a144 1

a190 2
	cpufunc_nullop,			/* flush_brnchtgt_C	*/
	(void *)cpufunc_nullop,		/* flush_brnchtgt_E	*/
a194 4

	cpufunc_null_fixup,		/* dataabt_fixup	*/
	cpufunc_null_fixup,		/* prefetchabt_fixup	*/

a195 1

a196 1

a241 2
	cpufunc_nullop,			/* flush_brnchtgt_C	*/
	(void *)cpufunc_nullop,		/* flush_brnchtgt_E	*/
a245 4

	cpufunc_null_fixup,		/* dataabt_fixup	*/
	cpufunc_null_fixup,		/* prefetchabt_fixup	*/

a246 1

a247 1

a292 2
	cpufunc_nullop,			/* flush_brnchtgt_C	*/
	(void *)cpufunc_nullop,		/* flush_brnchtgt_E	*/
a296 4

	cpufunc_null_fixup,		/* dataabt_fixup	*/
	cpufunc_null_fixup,		/* prefetchabt_fixup	*/

a297 1

a298 1

a342 2
	cpufunc_nullop,			/* flush_brnchtgt_C	*/
	(void *)cpufunc_nullop,		/* flush_brnchtgt_E	*/
a346 4

	cpufunc_null_fixup,		/* dataabt_fixup	*/
	cpufunc_null_fixup,		/* prefetchabt_fixup	*/

a347 1

a392 2
	cpufunc_nullop,			/* flush_brnchtgt_C	*/
	(void *)cpufunc_nullop,		/* flush_brnchtgt_E	*/
a396 4

	cpufunc_null_fixup,		/* dataabt_fixup	*/
	cpufunc_null_fixup,		/* prefetchabt_fixup	*/

a397 1

a402 57
#ifdef CPU_SA110
struct cpu_functions sa110_cpufuncs = {
	/* CPU functions */

	cpufunc_id,			/* id			*/
	cpufunc_nullop,			/* cpwait		*/

	/* MMU functions */

	cpufunc_control,		/* control		*/
	cpufunc_domains,		/* domain		*/
	sa1_setttb,			/* setttb		*/
	cpufunc_faultstatus,		/* faultstatus		*/
	cpufunc_faultaddress,		/* faultaddress		*/

	/* TLB functions */

	armv4_tlb_flushID,		/* tlb_flushID		*/
	sa1_tlb_flushID_SE,		/* tlb_flushID_SE	*/
	armv4_tlb_flushI,		/* tlb_flushI		*/
	(void *)armv4_tlb_flushI,	/* tlb_flushI_SE	*/
	armv4_tlb_flushD,		/* tlb_flushD		*/
	armv4_tlb_flushD_SE,		/* tlb_flushD_SE	*/

	/* Cache operations */

	sa1_cache_syncI,		/* icache_sync_all	*/
	sa1_cache_syncI_rng,		/* icache_sync_range	*/

	sa1_cache_purgeD,		/* dcache_wbinv_all	*/
	sa1_cache_purgeD_rng,		/* dcache_wbinv_range	*/
/*XXX*/	sa1_cache_purgeD_rng,		/* dcache_inv_range	*/
	sa1_cache_cleanD_rng,		/* dcache_wb_range	*/

	sa1_cache_purgeID,		/* idcache_wbinv_all	*/
	sa1_cache_purgeID_rng,		/* idcache_wbinv_range	*/

	/* Other functions */

	cpufunc_nullop,			/* flush_prefetchbuf	*/
	armv4_drain_writebuf,		/* drain_writebuf	*/
	cpufunc_nullop,			/* flush_brnchtgt_C	*/
	(void *)cpufunc_nullop,		/* flush_brnchtgt_E	*/

	(void *)cpufunc_nullop,		/* sleep		*/

	/* Soft functions */

	cpufunc_null_fixup,		/* dataabt_fixup	*/
	cpufunc_null_fixup,		/* prefetchabt_fixup	*/

	sa110_context_switch,		/* context_switch	*/

	sa110_setup			/* cpu setup		*/
};
#endif	/* CPU_SA110 */

a443 2
	cpufunc_nullop,			/* flush_brnchtgt_C	*/
	(void *)cpufunc_nullop,		/* flush_brnchtgt_E	*/
a447 4

	cpufunc_null_fixup,		/* dataabt_fixup	*/
	cpufunc_null_fixup,		/* prefetchabt_fixup	*/

a448 1

d492 1
a492 1
	ixp12x0_drain_readbuf,			/* flush_prefetchbuf	*/
a493 2
	cpufunc_nullop,			/* flush_brnchtgt_C	*/
	(void *)cpufunc_nullop,		/* flush_brnchtgt_E	*/
a497 4

	cpufunc_null_fixup,		/* dataabt_fixup	*/
	cpufunc_null_fixup,		/* prefetchabt_fixup	*/

a498 1

a544 2
	cpufunc_nullop,			/* flush_brnchtgt_C	*/
	(void *)cpufunc_nullop,		/* flush_brnchtgt_E	*/
a548 4

	cpufunc_null_fixup,		/* dataabt_fixup	*/
	cpufunc_null_fixup,		/* prefetchabt_fixup	*/

a549 1

d563 1
a563 1
#if defined(CPU_ARM7TDMI) || defined(CPU_ARM8) || defined(CPU_ARM9) || \
d645 1
a645 3
#if defined(CPU_ARM2) || defined(CPU_ARM250) || defined(CPU_ARM3) || \
    defined(CPU_ARM6) || defined(CPU_ARM7) || defined(CPU_SA110) || \
    defined(CPU_SA1100) || defined(CPU_SA1110) || defined(CPU_IXP12X0)
a660 8
    { CPU_ID_ARM2,	0,		  1,    0,  0,  0,	0,  0,  0 },
    { CPU_ID_ARM250,    0,		  1,	0,  0,  0,	0,  0,  0 },
    { CPU_ID_ARM3,	CPU_CT_CTYPE_WT,  1,  4096, 16, 64,	0,  0,  0 },
    { CPU_ID_ARM610,	CPU_CT_CTYPE_WT,  1,  4096, 16, 64,	0,  0,  0 },
    { CPU_ID_ARM710,    CPU_CT_CTYPE_WT,  1,  8192, 32,  4,	0,  0,  0 },
    { CPU_ID_ARM7500,   CPU_CT_CTYPE_WT,  1,  4096, 16,  4,	0,  0,  0 },
    { CPU_ID_ARM710A,   CPU_CT_CTYPE_WT,  1,  8192, 16,  4,	0,  0,  0 },
    { CPU_ID_ARM7500FE, CPU_CT_CTYPE_WT,  1,  4096, 16,  4,	0,  0,  0 },
a661 1
    { CPU_ID_SA110,	CPU_CT_CTYPE_WB1, 0, 16384, 32, 32, 16384, 32, 32 },
d695 1
a695 1
#endif /* ARM2 || ARM250 || ARM3 || ARM6 || ARM7 || SA110 || SA1100 || SA1111 || IXP12X0 */
a900 41
#ifdef CPU_ARM3
	if ((cputype & CPU_ID_IMPLEMENTOR_MASK) == CPU_ID_ARM_LTD &&
	    (cputype & 0x00000f00) == 0x00000300) {
		cpufuncs = arm3_cpufuncs;
		cpu_reset_needs_v4_MMU_disable = 0;
		get_cachetype_table();
		return 0;
	}
#endif	/* CPU_ARM3 */
#ifdef CPU_ARM6
	if ((cputype & CPU_ID_IMPLEMENTOR_MASK) == CPU_ID_ARM_LTD &&
	    (cputype & 0x00000f00) == 0x00000600) {
		cpufuncs = arm6_cpufuncs;
		cpu_reset_needs_v4_MMU_disable = 0;
		get_cachetype_table();
		pmap_pte_init_generic();
		return 0;
	}
#endif	/* CPU_ARM6 */
#ifdef CPU_ARM7
	if ((cputype & CPU_ID_IMPLEMENTOR_MASK) == CPU_ID_ARM_LTD &&
	    CPU_ID_IS7(cputype) &&
	    (cputype & CPU_ID_7ARCH_MASK) == CPU_ID_7ARCH_V3) {
		cpufuncs = arm7_cpufuncs;
		cpu_reset_needs_v4_MMU_disable = 0;
		get_cachetype_table();
		pmap_pte_init_generic();
		return 0;
	}
#endif	/* CPU_ARM7 */
#ifdef CPU_ARM7TDMI
	if ((cputype & CPU_ID_IMPLEMENTOR_MASK) == CPU_ID_ARM_LTD &&
	    CPU_ID_IS7(cputype) &&
	    (cputype & CPU_ID_7ARCH_MASK) == CPU_ID_7ARCH_V4T) {
		cpufuncs = arm7tdmi_cpufuncs;
		cpu_reset_needs_v4_MMU_disable = 0;
		get_cachetype_cp15();
		pmap_pte_init_generic();
		return 0;
	}
#endif
a993 9
#ifdef CPU_SA110
	if (cputype == CPU_ID_SA110) {
		cpufuncs = sa110_cpufuncs;
		cpu_reset_needs_v4_MMU_disable = 1;	/* SA needs it */
		get_cachetype_table();
		pmap_pte_init_sa1();
		return 0;
	}
#endif	/* CPU_SA110 */
a1164 356
 * Fixup routines for data and prefetch aborts.
 *
 * Several compile time symbols are used
 *
 * DEBUG_FAULT_CORRECTION - Print debugging information during the
 * correction of registers after a fault.
 * ARM6_LATE_ABORT - ARM6 supports both early and late aborts
 * when defined should use late aborts
 */


/*
 * Null abort fixup routine.
 * For use when no fixup is required.
 */
int
cpufunc_null_fixup(arg)
	void *arg;
{
	return(ABORT_FIXUP_OK);
}


#if defined(CPU_ARM2) || defined(CPU_ARM250) || defined(CPU_ARM3) || \
    defined(CPU_ARM6) || defined(CPU_ARM7) || defined(CPU_ARM7TDMI)

#ifdef DEBUG_FAULT_CORRECTION
#define DFC_PRINTF(x)		printf x
#define DFC_DISASSEMBLE(x)	disassemble(x)
#else
#define DFC_PRINTF(x)		/* nothing */
#define DFC_DISASSEMBLE(x)	/* nothing */
#endif

/*
 * "Early" data abort fixup.
 *
 * For ARM2, ARM2as, ARM3 and ARM6 (in early-abort mode).  Also used
 * indirectly by ARM6 (in late-abort mode) and ARM7[TDMI].
 *
 * In early aborts, we may have to fix up LDM, STM, LDC and STC.
 */
int
early_abort_fixup(arg)
	void *arg;
{
	trapframe_t *frame = arg;
	u_int fault_pc;
	u_int fault_instruction;
	int saved_lr = 0;

	if ((frame->tf_spsr & PSR_MODE) == PSR_SVC32_MODE) {

		/* Ok an abort in SVC mode */

		/*
		 * Copy the SVC r14 into the usr r14 - The usr r14 is garbage
		 * as the fault happened in svc mode but we need it in the
		 * usr slot so we can treat the registers as an array of ints
		 * during fixing.
		 * NOTE: This PC is in the position but writeback is not
		 * allowed on r15.
		 * Doing it like this is more efficient than trapping this
		 * case in all possible locations in the following fixup code.
		 */

		saved_lr = frame->tf_usr_lr;
		frame->tf_usr_lr = frame->tf_svc_lr;

		/*
		 * Note the trapframe does not have the SVC r13 so a fault
		 * from an instruction with writeback to r13 in SVC mode is
		 * not allowed. This should not happen as the kstack is
		 * always valid.
		 */
	}

	/* Get fault address and status from the CPU */

	fault_pc = frame->tf_pc;
	fault_instruction = *((volatile unsigned int *)fault_pc);

	/* Decode the fault instruction and fix the registers as needed */

	if ((fault_instruction & 0x0e000000) == 0x08000000) {
		int base;
		int loop;
		int count;
		int *registers = &frame->tf_r0;

		DFC_PRINTF(("LDM/STM\n"));
		DFC_DISASSEMBLE(fault_pc);
		if (fault_instruction & (1 << 21)) {
			DFC_PRINTF(("This instruction must be corrected\n"));
			base = (fault_instruction >> 16) & 0x0f;
			if (base == 15)
				return ABORT_FIXUP_FAILED;
			/* Count registers transferred */
			count = 0;
			for (loop = 0; loop < 16; ++loop) {
				if (fault_instruction & (1<<loop))
					++count;
			}
			DFC_PRINTF(("%d registers used\n", count));
			DFC_PRINTF(("Corrected r%d by %d bytes ",
			    base, count * 4));
			if (fault_instruction & (1 << 23)) {
				DFC_PRINTF(("down\n"));
				registers[base] -= count * 4;
			} else {
				DFC_PRINTF(("up\n"));
				registers[base] += count * 4;
			}
		}
	} else if ((fault_instruction & 0x0e000000) == 0x0c000000) {
		int base;
		int offset;
		int *registers = &frame->tf_r0;

		/* REGISTER CORRECTION IS REQUIRED FOR THESE INSTRUCTIONS */

		DFC_DISASSEMBLE(fault_pc);

		/* Only need to fix registers if write back is turned on */

		if ((fault_instruction & (1 << 21)) != 0) {
			base = (fault_instruction >> 16) & 0x0f;
			if (base == 13 &&
			    (frame->tf_spsr & PSR_MODE) == PSR_SVC32_MODE)
				return ABORT_FIXUP_FAILED;
			if (base == 15)
				return ABORT_FIXUP_FAILED;

			offset = (fault_instruction & 0xff) << 2;
			DFC_PRINTF(("r%d=%08x\n", base, registers[base]));
			if ((fault_instruction & (1 << 23)) != 0)
				offset = -offset;
			registers[base] += offset;
			DFC_PRINTF(("r%d=%08x\n", base, registers[base]));
		}
	} else if ((fault_instruction & 0x0e000000) == 0x0c000000)
		return ABORT_FIXUP_FAILED;

	if ((frame->tf_spsr & PSR_MODE) == PSR_SVC32_MODE) {

		/* Ok an abort in SVC mode */

		/*
		 * Copy the SVC r14 into the usr r14 - The usr r14 is garbage
		 * as the fault happened in svc mode but we need it in the
		 * usr slot so we can treat the registers as an array of ints
		 * during fixing.
		 * NOTE: This PC is in the position but writeback is not
		 * allowed on r15.
		 * Doing it like this is more efficient than trapping this
		 * case in all possible locations in the prior fixup code.
		 */

		frame->tf_svc_lr = frame->tf_usr_lr;
		frame->tf_usr_lr = saved_lr;

		/*
		 * Note the trapframe does not have the SVC r13 so a fault
		 * from an instruction with writeback to r13 in SVC mode is
		 * not allowed. This should not happen as the kstack is
		 * always valid.
		 */
	}

	return(ABORT_FIXUP_OK);
}
#endif	/* CPU_ARM2/250/3/6/7 */


#if (defined(CPU_ARM6) && defined(ARM6_LATE_ABORT)) || defined(CPU_ARM7) || \
	defined(CPU_ARM7TDMI)
/*
 * "Late" (base updated) data abort fixup
 *
 * For ARM6 (in late-abort mode) and ARM7.
 *
 * In this model, all data-transfer instructions need fixing up.  We defer
 * LDM, STM, LDC and STC fixup to the early-abort handler.
 */
int
late_abort_fixup(arg)
	void *arg;
{
	trapframe_t *frame = arg;
	u_int fault_pc;
	u_int fault_instruction;
	int saved_lr = 0;

	if ((frame->tf_spsr & PSR_MODE) == PSR_SVC32_MODE) {

		/* Ok an abort in SVC mode */

		/*
		 * Copy the SVC r14 into the usr r14 - The usr r14 is garbage
		 * as the fault happened in svc mode but we need it in the
		 * usr slot so we can treat the registers as an array of ints
		 * during fixing.
		 * NOTE: This PC is in the position but writeback is not
		 * allowed on r15.
		 * Doing it like this is more efficient than trapping this
		 * case in all possible locations in the following fixup code.
		 */

		saved_lr = frame->tf_usr_lr;
		frame->tf_usr_lr = frame->tf_svc_lr;

		/*
		 * Note the trapframe does not have the SVC r13 so a fault
		 * from an instruction with writeback to r13 in SVC mode is
		 * not allowed. This should not happen as the kstack is
		 * always valid.
		 */
	}

	/* Get fault address and status from the CPU */

	fault_pc = frame->tf_pc;
	fault_instruction = *((volatile unsigned int *)fault_pc);

	/* Decode the fault instruction and fix the registers as needed */

	/* Was is a swap instruction ? */

	if ((fault_instruction & 0x0fb00ff0) == 0x01000090) {
		DFC_DISASSEMBLE(fault_pc);
	} else if ((fault_instruction & 0x0c000000) == 0x04000000) {

		/* Was is a ldr/str instruction */
		/* This is for late abort only */

		int base;
		int offset;
		int *registers = &frame->tf_r0;

		DFC_DISASSEMBLE(fault_pc);

		/* This is for late abort only */

		if ((fault_instruction & (1 << 24)) == 0
		    || (fault_instruction & (1 << 21)) != 0) {
			/* postindexed ldr/str with no writeback */

			base = (fault_instruction >> 16) & 0x0f;
			if (base == 13 &&
			    (frame->tf_spsr & PSR_MODE) == PSR_SVC32_MODE)
				return ABORT_FIXUP_FAILED;
			if (base == 15)
				return ABORT_FIXUP_FAILED;
			DFC_PRINTF(("late abt fix: r%d=%08x : ",
			    base, registers[base]));
			if ((fault_instruction & (1 << 25)) == 0) {
				/* Immediate offset - easy */

				offset = fault_instruction & 0xfff;
				if ((fault_instruction & (1 << 23)))
					offset = -offset;
				registers[base] += offset;
				DFC_PRINTF(("imm=%08x ", offset));
			} else {
				/* offset is a shifted register */
				int shift;

				offset = fault_instruction & 0x0f;
				if (offset == base)
					return ABORT_FIXUP_FAILED;

				/*
				 * Register offset - hard we have to
				 * cope with shifts !
				 */
				offset = registers[offset];

				if ((fault_instruction & (1 << 4)) == 0)
					/* shift with amount */
					shift = (fault_instruction >> 7) & 0x1f;
				else {
					/* shift with register */
					if ((fault_instruction & (1 << 7)) != 0)
						/* undefined for now so bail out */
						return ABORT_FIXUP_FAILED;
					shift = ((fault_instruction >> 8) & 0xf);
					if (base == shift)
						return ABORT_FIXUP_FAILED;
					DFC_PRINTF(("shift reg=%d ", shift));
					shift = registers[shift];
				}
				DFC_PRINTF(("shift=%08x ", shift));
				switch (((fault_instruction >> 5) & 0x3)) {
				case 0 : /* Logical left */
					offset = (int)(((u_int)offset) << shift);
					break;
				case 1 : /* Logical Right */
					if (shift == 0) shift = 32;
					offset = (int)(((u_int)offset) >> shift);
					break;
				case 2 : /* Arithmetic Right */
					if (shift == 0) shift = 32;
					offset = (int)(((int)offset) >> shift);
					break;
				case 3 : /* Rotate right (rol or rxx) */
					return ABORT_FIXUP_FAILED;
					break;
				}

				DFC_PRINTF(("abt: fixed LDR/STR with "
				    "register offset\n"));
				if ((fault_instruction & (1 << 23)))
					offset = -offset;
				DFC_PRINTF(("offset=%08x ", offset));
				registers[base] += offset;
			}
			DFC_PRINTF(("r%d=%08x\n", base, registers[base]));
		}
	}

	if ((frame->tf_spsr & PSR_MODE) == PSR_SVC32_MODE) {

		/* Ok an abort in SVC mode */

		/*
		 * Copy the SVC r14 into the usr r14 - The usr r14 is garbage
		 * as the fault happened in svc mode but we need it in the
		 * usr slot so we can treat the registers as an array of ints
		 * during fixing.
		 * NOTE: This PC is in the position but writeback is not
		 * allowed on r15.
		 * Doing it like this is more efficient than trapping this
		 * case in all possible locations in the prior fixup code.
		 */

		frame->tf_svc_lr = frame->tf_usr_lr;
		frame->tf_usr_lr = saved_lr;

		/*
		 * Note the trapframe does not have the SVC r13 so a fault
		 * from an instruction with writeback to r13 in SVC mode is
		 * not allowed. This should not happen as the kstack is
		 * always valid.
		 */
	}

	/*
	 * Now let the early-abort fixup routine have a go, in case it
	 * was an LDM, STM, LDC or STC that faulted.
	 */

	return early_abort_fixup(arg);
}
#endif	/* CPU_ARM6(LATE)/7/7TDMI */

/*
a1167 195
#if defined(CPU_ARM6) || defined(CPU_ARM7) || defined(CPU_ARM7TDMI) || \
	defined(CPU_ARM8) || defined (CPU_ARM9) || defined (CPU_ARM9E) || \
	defined(CPU_SA110) || defined(CPU_SA1100) || defined(CPU_SA1110) || \
	defined(CPU_XSCALE_80200) || defined(CPU_XSCALE_80321) || \
	defined(CPU_XSCALE_PXA2X0) || defined(CPU_XSCALE_IXP425) || \
	defined(CPU_ARM10) || defined(CPU_ARM11) || defined(CPU_ARMv7)

#define IGN	0
#define OR	1
#define BIC	2

struct cpu_option {
	char	*co_name;
	int	co_falseop;
	int	co_trueop;
	int	co_value;
};

static u_int parse_cpu_options (char *, struct cpu_option *, u_int);

static u_int
parse_cpu_options(args, optlist, cpuctrl)
	char *args;
	struct cpu_option *optlist;
	u_int cpuctrl;
{
	int integer;

	if (args == NULL)
		return(cpuctrl);

	while (optlist->co_name) {
		if (get_bootconf_option(args, optlist->co_name,
		    BOOTOPT_TYPE_BOOLEAN, &integer)) {
			if (integer) {
				if (optlist->co_trueop == OR)
					cpuctrl |= optlist->co_value;
				else if (optlist->co_trueop == BIC)
					cpuctrl &= ~optlist->co_value;
			} else {
				if (optlist->co_falseop == OR)
					cpuctrl |= optlist->co_value;
				else if (optlist->co_falseop == BIC)
					cpuctrl &= ~optlist->co_value;
			}
		}
		++optlist;
	}
	return(cpuctrl);
}
#endif /* CPU_ARM6 || CPU_ARM7 || CPU_ARM7TDMI || CPU_ARM8 || CPU_SA110 */

#if defined (CPU_ARM6) || defined(CPU_ARM7) || defined(CPU_ARM7TDMI) \
	|| defined(CPU_ARM8)
struct cpu_option arm678_options[] = {
	{ "cpu.cache",		BIC, OR,  CPU_CONTROL_IDC_ENABLE },
	{ "cpu.nocache",	OR,  BIC, CPU_CONTROL_IDC_ENABLE },
	{ "cpu.writebuf",	BIC, OR,  CPU_CONTROL_WBUF_ENABLE },
	{ "cpu.nowritebuf",	OR,  BIC, CPU_CONTROL_WBUF_ENABLE },
	{ NULL,			IGN, IGN, 0 }
};

#endif	/* CPU_ARM6 || CPU_ARM7 || CPU_ARM7TDMI || CPU_ARM8 */

#ifdef CPU_ARM6
struct cpu_option arm6_options[] = {
	{ "arm6.cache",		BIC, OR,  CPU_CONTROL_IDC_ENABLE },
	{ "arm6.nocache",	OR,  BIC, CPU_CONTROL_IDC_ENABLE },
	{ "arm6.writebuf",	BIC, OR,  CPU_CONTROL_WBUF_ENABLE },
	{ "arm6.nowritebuf",	OR,  BIC, CPU_CONTROL_WBUF_ENABLE },
	{ NULL,			IGN, IGN, 0 }
};

void
arm6_setup(args)
	char *args;
{
	int cpuctrl, cpuctrlmask;

	/* Set up default control registers bits */
	cpuctrl = CPU_CONTROL_MMU_ENABLE | CPU_CONTROL_32BP_ENABLE
		 | CPU_CONTROL_32BD_ENABLE | CPU_CONTROL_SYST_ENABLE
		 | CPU_CONTROL_IDC_ENABLE | CPU_CONTROL_WBUF_ENABLE;
	cpuctrlmask = CPU_CONTROL_MMU_ENABLE | CPU_CONTROL_32BP_ENABLE
		 | CPU_CONTROL_32BD_ENABLE | CPU_CONTROL_SYST_ENABLE
		 | CPU_CONTROL_IDC_ENABLE | CPU_CONTROL_WBUF_ENABLE
		 | CPU_CONTROL_ROM_ENABLE | CPU_CONTROL_BEND_ENABLE
		 | CPU_CONTROL_AFLT_ENABLE;

#ifdef ARM6_LATE_ABORT
	cpuctrl |= CPU_CONTROL_LABT_ENABLE;
#endif	/* ARM6_LATE_ABORT */

#ifndef ARM32_DISABLE_ALIGNMENT_FAULTS
	cpuctrl |= CPU_CONTROL_AFLT_ENABLE;
#endif

	cpuctrl = parse_cpu_options(args, arm678_options, cpuctrl);
	cpuctrl = parse_cpu_options(args, arm6_options, cpuctrl);

#ifdef __ARMEB__
	cpuctrl |= CPU_CONTROL_BEND_ENABLE;
#endif

	/* Clear out the cache */
	cpu_idcache_wbinv_all();

	/* Set the control register */
	curcpu()->ci_ctrl = cpuctrl;
	cpu_control(0xffffffff, cpuctrl);
}
#endif	/* CPU_ARM6 */

#ifdef CPU_ARM7
struct cpu_option arm7_options[] = {
	{ "arm7.cache",		BIC, OR,  CPU_CONTROL_IDC_ENABLE },
	{ "arm7.nocache",	OR,  BIC, CPU_CONTROL_IDC_ENABLE },
	{ "arm7.writebuf",	BIC, OR,  CPU_CONTROL_WBUF_ENABLE },
	{ "arm7.nowritebuf",	OR,  BIC, CPU_CONTROL_WBUF_ENABLE },
	{ "arm700.fpaclk",	BIC, OR,  CPU_CONTROL_CPCLK },
	{ NULL,			IGN, IGN, 0 }
};

void
arm7_setup(args)
	char *args;
{
	int cpuctrl, cpuctrlmask;

	cpuctrl = CPU_CONTROL_MMU_ENABLE | CPU_CONTROL_32BP_ENABLE
		 | CPU_CONTROL_32BD_ENABLE | CPU_CONTROL_SYST_ENABLE
		 | CPU_CONTROL_IDC_ENABLE | CPU_CONTROL_WBUF_ENABLE;
	cpuctrlmask = CPU_CONTROL_MMU_ENABLE | CPU_CONTROL_32BP_ENABLE
		 | CPU_CONTROL_32BD_ENABLE | CPU_CONTROL_SYST_ENABLE
		 | CPU_CONTROL_IDC_ENABLE | CPU_CONTROL_WBUF_ENABLE
		 | CPU_CONTROL_CPCLK | CPU_CONTROL_LABT_ENABLE
		 | CPU_CONTROL_ROM_ENABLE | CPU_CONTROL_BEND_ENABLE
		 | CPU_CONTROL_AFLT_ENABLE;

#ifndef ARM32_DISABLE_ALIGNMENT_FAULTS
	cpuctrl |= CPU_CONTROL_AFLT_ENABLE;
#endif

	cpuctrl = parse_cpu_options(args, arm678_options, cpuctrl);
	cpuctrl = parse_cpu_options(args, arm7_options, cpuctrl);

#ifdef __ARMEB__
	cpuctrl |= CPU_CONTROL_BEND_ENABLE;
#endif

	/* Clear out the cache */
	cpu_idcache_wbinv_all();

	/* Set the control register */
	curcpu()->ci_ctrl = cpuctrl;
	cpu_control(0xffffffff, cpuctrl);
}
#endif	/* CPU_ARM7 */

#ifdef CPU_ARM7TDMI
struct cpu_option arm7tdmi_options[] = {
	{ "arm7.cache",		BIC, OR,  CPU_CONTROL_IDC_ENABLE },
	{ "arm7.nocache",	OR,  BIC, CPU_CONTROL_IDC_ENABLE },
	{ "arm7.writebuf",	BIC, OR,  CPU_CONTROL_WBUF_ENABLE },
	{ "arm7.nowritebuf",	OR,  BIC, CPU_CONTROL_WBUF_ENABLE },
	{ "arm700.fpaclk",	BIC, OR,  CPU_CONTROL_CPCLK },
	{ NULL,			IGN, IGN, 0 }
};

void
arm7tdmi_setup(args)
	char *args;
{
	int cpuctrl;

	cpuctrl = CPU_CONTROL_MMU_ENABLE | CPU_CONTROL_32BP_ENABLE
		 | CPU_CONTROL_32BD_ENABLE | CPU_CONTROL_SYST_ENABLE
		 | CPU_CONTROL_IDC_ENABLE | CPU_CONTROL_WBUF_ENABLE;

	cpuctrl = parse_cpu_options(args, arm678_options, cpuctrl);
	cpuctrl = parse_cpu_options(args, arm7tdmi_options, cpuctrl);

#ifdef __ARMEB__
	cpuctrl |= CPU_CONTROL_BEND_ENABLE;
#endif

	/* Clear out the cache */
	cpu_idcache_wbinv_all();

	/* Set the control register */
	curcpu()->ci_ctrl = cpuctrl;
	cpu_control(0xffffffff, cpuctrl);
}
#endif	/* CPU_ARM7TDMI */

a1168 10
struct cpu_option arm8_options[] = {
	{ "arm8.cache",		BIC, OR,  CPU_CONTROL_IDC_ENABLE },
	{ "arm8.nocache",	OR,  BIC, CPU_CONTROL_IDC_ENABLE },
	{ "arm8.writebuf",	BIC, OR,  CPU_CONTROL_WBUF_ENABLE },
	{ "arm8.nowritebuf",	OR,  BIC, CPU_CONTROL_WBUF_ENABLE },
	{ "cpu.branchpredict", 	BIC, OR,  CPU_CONTROL_BPRD_ENABLE },
	{ "arm8.branchpredict",	BIC, OR,  CPU_CONTROL_BPRD_ENABLE },
	{ NULL,			IGN, IGN, 0 }
};

d1170 1
a1170 2
arm8_setup(args)
	char *args;
d1179 2
a1180 1
		 | CPU_CONTROL_IDC_ENABLE | CPU_CONTROL_WBUF_ENABLE;
a1186 7
#ifndef ARM32_DISABLE_ALIGNMENT_FAULTS
	cpuctrl |= CPU_CONTROL_AFLT_ENABLE;
#endif

	cpuctrl = parse_cpu_options(args, arm678_options, cpuctrl);
	cpuctrl = parse_cpu_options(args, arm8_options, cpuctrl);

a1193 28
	/* Special ARM8 clock and test configuration */
	if (get_bootconf_option(args, "arm8.clock.reset", BOOTOPT_TYPE_BOOLEAN, &integer)) {
		clocktest = 0;
		setclock = 1;
	}
	if (get_bootconf_option(args, "arm8.clock.dynamic", BOOTOPT_TYPE_BOOLEAN, &integer)) {
		if (integer)
			clocktest |= 0x01;
		else
			clocktest &= ~(0x01);
		setclock = 1;
	}
	if (get_bootconf_option(args, "arm8.clock.sync", BOOTOPT_TYPE_BOOLEAN, &integer)) {
		if (integer)
			clocktest |= 0x02;
		else
			clocktest &= ~(0x02);
		setclock = 1;
	}
	if (get_bootconf_option(args, "arm8.clock.fast", BOOTOPT_TYPE_BININT, &integer)) {
		clocktest = (clocktest & ~0xc0) | (integer & 3) << 2;
		setclock = 1;
	}
	if (get_bootconf_option(args, "arm8.test", BOOTOPT_TYPE_BININT, &integer)) {
		clocktest |= (integer & 7) << 5;
		setclock = 1;
	}

a1207 12
struct cpu_option arm9_options[] = {
	{ "cpu.cache",		BIC, OR,  (CPU_CONTROL_IC_ENABLE | CPU_CONTROL_DC_ENABLE) },
	{ "cpu.nocache",	OR,  BIC, (CPU_CONTROL_IC_ENABLE | CPU_CONTROL_DC_ENABLE) },
	{ "arm9.cache",	BIC, OR,  (CPU_CONTROL_IC_ENABLE | CPU_CONTROL_DC_ENABLE) },
	{ "arm9.icache",	BIC, OR,  CPU_CONTROL_IC_ENABLE },
	{ "arm9.dcache",	BIC, OR,  CPU_CONTROL_DC_ENABLE },
	{ "cpu.writebuf",	BIC, OR,  CPU_CONTROL_WBUF_ENABLE },
	{ "cpu.nowritebuf",	OR,  BIC, CPU_CONTROL_WBUF_ENABLE },
	{ "arm9.writebuf",	BIC, OR,  CPU_CONTROL_WBUF_ENABLE },
	{ NULL,			IGN, IGN, 0 }
};

d1209 1
a1209 2
arm9_setup(args)
	char *args;
d1216 1
a1216 1
	    | CPU_CONTROL_WBUF_ENABLE;
a1224 6
#ifndef ARM32_DISABLE_ALIGNMENT_FAULTS
	cpuctrl |= CPU_CONTROL_AFLT_ENABLE;
#endif

	cpuctrl = parse_cpu_options(args, arm9_options, cpuctrl);

a1242 12
struct cpu_option arm10_options[] = {
	{ "cpu.cache",		BIC, OR,  (CPU_CONTROL_IC_ENABLE | CPU_CONTROL_DC_ENABLE) },
	{ "cpu.nocache",	OR,  BIC, (CPU_CONTROL_IC_ENABLE | CPU_CONTROL_DC_ENABLE) },
	{ "arm10.cache",	BIC, OR,  (CPU_CONTROL_IC_ENABLE | CPU_CONTROL_DC_ENABLE) },
	{ "arm10.icache",	BIC, OR,  CPU_CONTROL_IC_ENABLE },
	{ "arm10.dcache",	BIC, OR,  CPU_CONTROL_DC_ENABLE },
	{ "cpu.writebuf",	BIC, OR,  CPU_CONTROL_WBUF_ENABLE },
	{ "cpu.nowritebuf",	OR,  BIC, CPU_CONTROL_WBUF_ENABLE },
	{ "arm10.writebuf",	BIC, OR,  CPU_CONTROL_WBUF_ENABLE },
	{ NULL,			IGN, IGN, 0 }
};

d1244 1
a1244 2
arm10_setup(args)
	char *args;
d1250 2
a1251 1
	    | CPU_CONTROL_WBUF_ENABLE | CPU_CONTROL_BPRD_ENABLE;
a1258 6
#ifndef ARM32_DISABLE_ALIGNMENT_FAULTS
	cpuctrl |= CPU_CONTROL_AFLT_ENABLE;
#endif

	cpuctrl = parse_cpu_options(args, arm10_options, cpuctrl);

a1284 9
struct cpu_option arm11_options[] = {
	{ "cpu.cache",		BIC, OR,  (CPU_CONTROL_IC_ENABLE | CPU_CONTROL_DC_ENABLE) },
	{ "cpu.nocache",	OR,  BIC, (CPU_CONTROL_IC_ENABLE | CPU_CONTROL_DC_ENABLE) },
	{ "arm11.cache",	BIC, OR,  (CPU_CONTROL_IC_ENABLE | CPU_CONTROL_DC_ENABLE) },
	{ "arm11.icache",	BIC, OR,  CPU_CONTROL_IC_ENABLE },
	{ "arm11.dcache",	BIC, OR,  CPU_CONTROL_DC_ENABLE },
	{ NULL,			IGN, IGN, 0 }
};

d1286 1
a1286 2
arm11_setup(args)
	char *args;
d1292 1
a1292 1
	    /* | CPU_CONTROL_BPRD_ENABLE */;
a1298 6
#ifndef ARM32_DISABLE_ALIGNMENT_FAULTS
	cpuctrl |= CPU_CONTROL_AFLT_ENABLE;
#endif

	cpuctrl = parse_cpu_options(args, arm11_options, cpuctrl);

a1318 3
struct cpu_option armv7_options[] = {
};

d1320 1
a1320 2
armv7_setup(args)
	char *args;
d1326 1
a1326 1
	    | CPU_CONTROL_BPRD_ENABLE ;
a1333 4
#ifndef ARM32_DISABLE_ALIGNMENT_FAULTS
	cpuctrl |= CPU_CONTROL_AFLT_ENABLE;
#endif

a1336 2
	cpuctrl = parse_cpu_options(args, armv7_options, cpuctrl);

a1354 57
#ifdef CPU_SA110
struct cpu_option sa110_options[] = {
	{ "cpu.cache",		BIC, OR,  (CPU_CONTROL_IC_ENABLE | CPU_CONTROL_DC_ENABLE) },
	{ "cpu.nocache",	OR,  BIC, (CPU_CONTROL_IC_ENABLE | CPU_CONTROL_DC_ENABLE) },
	{ "sa110.cache",	BIC, OR,  (CPU_CONTROL_IC_ENABLE | CPU_CONTROL_DC_ENABLE) },
	{ "sa110.icache",	BIC, OR,  CPU_CONTROL_IC_ENABLE },
	{ "sa110.dcache",	BIC, OR,  CPU_CONTROL_DC_ENABLE },
	{ "cpu.writebuf",	BIC, OR,  CPU_CONTROL_WBUF_ENABLE },
	{ "cpu.nowritebuf",	OR,  BIC, CPU_CONTROL_WBUF_ENABLE },
	{ "sa110.writebuf",	BIC, OR,  CPU_CONTROL_WBUF_ENABLE },
	{ NULL,			IGN, IGN, 0 }
};

void
sa110_setup(args)
	char *args;
{
	int cpuctrl, cpuctrlmask;

	cpuctrl = CPU_CONTROL_MMU_ENABLE | CPU_CONTROL_32BP_ENABLE
		 | CPU_CONTROL_32BD_ENABLE | CPU_CONTROL_SYST_ENABLE
		 | CPU_CONTROL_IC_ENABLE | CPU_CONTROL_DC_ENABLE
		 | CPU_CONTROL_WBUF_ENABLE;
	cpuctrlmask = CPU_CONTROL_MMU_ENABLE | CPU_CONTROL_32BP_ENABLE
		 | CPU_CONTROL_32BD_ENABLE | CPU_CONTROL_SYST_ENABLE
		 | CPU_CONTROL_IC_ENABLE | CPU_CONTROL_DC_ENABLE
		 | CPU_CONTROL_WBUF_ENABLE | CPU_CONTROL_ROM_ENABLE
		 | CPU_CONTROL_BEND_ENABLE | CPU_CONTROL_AFLT_ENABLE
		 | CPU_CONTROL_LABT_ENABLE | CPU_CONTROL_BPRD_ENABLE
		 | CPU_CONTROL_CPCLK;

#ifndef ARM32_DISABLE_ALIGNMENT_FAULTS
	cpuctrl |= CPU_CONTROL_AFLT_ENABLE;
#endif

	cpuctrl = parse_cpu_options(args, sa110_options, cpuctrl);

#ifdef __ARMEB__
	cpuctrl |= CPU_CONTROL_BEND_ENABLE;
#endif

	/* Clear out the cache */
	cpu_idcache_wbinv_all();

	/* Set the control register */
	curcpu()->ci_ctrl = cpuctrl;
/*	cpu_control(cpuctrlmask, cpuctrl);*/
	cpu_control(0xffffffff, cpuctrl);

	/*
	 * enable clockswitching, note that this doesn't read or write to r0,
	 * r0 is just to make it valid asm
	 */
	__asm ("mcr 15, 0, r0, c15, c1, 2");
}
#endif	/* CPU_SA110 */

a1355 12
struct cpu_option sa11x0_options[] = {
	{ "cpu.cache",		BIC, OR,  (CPU_CONTROL_IC_ENABLE | CPU_CONTROL_DC_ENABLE) },
	{ "cpu.nocache",	OR,  BIC, (CPU_CONTROL_IC_ENABLE | CPU_CONTROL_DC_ENABLE) },
	{ "sa11x0.cache",	BIC, OR,  (CPU_CONTROL_IC_ENABLE | CPU_CONTROL_DC_ENABLE) },
	{ "sa11x0.icache",	BIC, OR,  CPU_CONTROL_IC_ENABLE },
	{ "sa11x0.dcache",	BIC, OR,  CPU_CONTROL_DC_ENABLE },
	{ "cpu.writebuf",	BIC, OR,  CPU_CONTROL_WBUF_ENABLE },
	{ "cpu.nowritebuf",	OR,  BIC, CPU_CONTROL_WBUF_ENABLE },
	{ "sa11x0.writebuf",	BIC, OR,  CPU_CONTROL_WBUF_ENABLE },
	{ NULL,			IGN, IGN, 0 }
};

d1357 1
a1357 2
sa11x0_setup(args)
	char *args;
d1364 2
a1365 1
		 | CPU_CONTROL_WBUF_ENABLE | CPU_CONTROL_LABT_ENABLE;
a1373 6
#ifndef ARM32_DISABLE_ALIGNMENT_FAULTS
	cpuctrl |= CPU_CONTROL_AFLT_ENABLE;
#endif

	cpuctrl = parse_cpu_options(args, sa11x0_options, cpuctrl);

a1389 12
struct cpu_option ixp12x0_options[] = {
	{ "cpu.cache",		BIC, OR,  (CPU_CONTROL_IC_ENABLE | CPU_CONTROL_DC_ENABLE) },
	{ "cpu.nocache",	OR,  BIC, (CPU_CONTROL_IC_ENABLE | CPU_CONTROL_DC_ENABLE) },
	{ "ixp12x0.cache",	BIC, OR,  (CPU_CONTROL_IC_ENABLE | CPU_CONTROL_DC_ENABLE) },
	{ "ixp12x0.icache",	BIC, OR,  CPU_CONTROL_IC_ENABLE },
	{ "ixp12x0.dcache",	BIC, OR,  CPU_CONTROL_DC_ENABLE },
	{ "cpu.writebuf",	BIC, OR,  CPU_CONTROL_WBUF_ENABLE },
	{ "cpu.nowritebuf",	OR,  BIC, CPU_CONTROL_WBUF_ENABLE },
	{ "ixp12x0.writebuf",	BIC, OR,  CPU_CONTROL_WBUF_ENABLE },
	{ NULL,			IGN, IGN, 0 }
};

d1391 1
a1391 2
ixp12x0_setup(args)
	char *args;
d1398 1
a1398 2
		 | CPU_CONTROL_IC_ENABLE;

a1404 6
#ifndef ARM32_DISABLE_ALIGNMENT_FAULTS
	cpuctrl |= CPU_CONTROL_AFLT_ENABLE;
#endif

	cpuctrl = parse_cpu_options(args, ixp12x0_options, cpuctrl);

a1423 11
struct cpu_option xscale_options[] = {
	{ "cpu.branchpredict", 	BIC, OR,  CPU_CONTROL_BPRD_ENABLE },
	{ "cpu.cache",		BIC, OR,  (CPU_CONTROL_IC_ENABLE | CPU_CONTROL_DC_ENABLE) },
	{ "cpu.nocache",	OR,  BIC, (CPU_CONTROL_IC_ENABLE | CPU_CONTROL_DC_ENABLE) },
	{ "xscale.branchpredict", BIC, OR,  CPU_CONTROL_BPRD_ENABLE },
	{ "xscale.cache",	BIC, OR,  (CPU_CONTROL_IC_ENABLE | CPU_CONTROL_DC_ENABLE) },
	{ "xscale.icache",	BIC, OR,  CPU_CONTROL_IC_ENABLE },
	{ "xscale.dcache",	BIC, OR,  CPU_CONTROL_DC_ENABLE },
	{ NULL,			IGN, IGN, 0 }
};

d1425 1
a1425 2
xscale_setup(args)
	char *args;
d1440 1
a1440 1
		 | CPU_CONTROL_BPRD_ENABLE;
a1447 6

#ifndef ARM32_DISABLE_ALIGNMENT_FAULTS
	cpuctrl |= CPU_CONTROL_AFLT_ENABLE;
#endif

	cpuctrl = parse_cpu_options(args, xscale_options, cpuctrl);
@


1.12
log
@Use the logical or operator, not the bitwise operator in
the preprocessor.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.c,v 1.11 2009/05/24 04:56:19 drahn Exp $	*/
d52 1
d54 1
d1090 1
d1095 20
d1136 1
d1139 1
d1176 61
d1238 20
@


1.11
log
@Improve the ARMv7 support, still work in progress.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.c,v 1.10 2009/05/11 12:51:24 drahn Exp $	*/
d1847 1
a1847 1
	defined(CPU_ARM10) | defined(CPU_ARM11) || defined(CPU_ARMv7)
@


1.10
log
@Better config for v7.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.c,v 1.9 2009/05/08 02:57:32 drahn Exp $	*/
d1286 1
a1286 1
	if (cputype == CPU_ID_OMAP3430 || cputype == CPU_ID_OMAP3530) {
@


1.9
log
@Pieces of arm11 and armv7 support for newer cpus. This is work in progress
and not complete.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.c,v 1.8 2008/09/11 02:38:14 kevlo Exp $	*/
a2286 6
	{ "cpu.cache",		BIC, OR,  (CPU_CONTROL_IC_ENABLE | CPU_CONTROL_DC_ENABLE) },
	{ "cpu.nocache",	OR,  BIC, (CPU_CONTROL_IC_ENABLE | CPU_CONTROL_DC_ENABLE) },
	{ "armv7.cache",	BIC, OR,  (CPU_CONTROL_IC_ENABLE | CPU_CONTROL_DC_ENABLE) },
	{ "armv7.icache",	BIC, OR,  CPU_CONTROL_IC_ENABLE },
	{ "armv7.dcache",	BIC, OR,  CPU_CONTROL_DC_ENABLE },
	{ NULL,			IGN, IGN, 0 }
d2297 1
a2297 1
	    /* | CPU_CONTROL_BPRD_ENABLE */;
d2302 2
a2303 1
	    | CPU_CONTROL_ROUNDROBIN | CPU_CONTROL_CPCLK;
d2309 3
a2312 4

#ifdef __ARMEB__
	cpuctrl |= CPU_CONTROL_BEND_ENABLE;
#endif
@


1.8
log
@add support for arm9e core, taken from NetBSD.
ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.c,v 1.7 2006/06/15 21:35:30 drahn Exp $	*/
d571 115
d925 1
a925 1
    defined(CPU_ARM9E) || defined(CPU_ARM10) || \
d1069 85
d1266 37
d1847 1
a1847 1
	defined(CPU_ARM10)
d2234 103
@


1.7
log
@rewritten, simplifed interrupt controller for 80321, half the lines
and much less complex. IPL_SERIAL goes at the same time.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.c,v 1.6 2006/05/29 17:01:42 drahn Exp $	*/
d420 2
a421 2
	arm9_cache_syncI,		/* icache_sync_all	*/
	arm9_cache_syncI_rng,		/* icache_sync_range	*/
d424 4
a427 4
	arm9_cache_flushD,		/* dcache_wbinv_all	*/
	arm9_cache_flushD_rng,		/* dcache_wbinv_range	*/
	arm9_cache_flushD_rng,		/* dcache_inv_range	*/
	(void *)cpufunc_nullop,		/* dcache_wb_range	*/
d429 2
a430 2
	arm9_cache_flushID,		/* idcache_wbinv_all	*/
	arm9_cache_flushID_rng,		/* idcache_wbinv_range	*/
d453 60
d524 1
a524 1
	arm10_setttb,			/* Setttb		*/
d539 2
a540 2
	arm10_icache_sync_all,		/* icache_sync_all	*/
	arm10_icache_sync_range,	/* icache_sync_range	*/
d542 4
a545 4
	arm10_dcache_wbinv_all,		/* dcache_wbinv_all	*/
	arm10_dcache_wbinv_range,	/* dcache_wbinv_range	*/
	arm10_dcache_inv_range,		/* dcache_inv_range	*/
	arm10_dcache_wb_range,		/* dcache_wb_range	*/
d547 2
a548 2
	arm10_idcache_wbinv_all,	/* idcache_wbinv_all	*/
	arm10_idcache_wbinv_range,	/* idcache_wbinv_range	*/
d810 1
a810 1
    defined (CPU_ARM10) || \
d1027 6
d1037 9
d1056 2
a1057 2
		arm10_dcache_sets_inc = 1U << arm_dcache_l2_linesize;
		arm10_dcache_sets_max =
d1059 3
a1061 3
		    arm10_dcache_sets_inc;
		arm10_dcache_index_inc = 1U << (32 - arm_dcache_l2_assoc);
		arm10_dcache_index_max = 0U - arm10_dcache_index_inc;
d1606 2
a1607 2
	defined(CPU_ARM8) || defined (CPU_ARM9) || defined(CPU_SA110) || \
	defined(CPU_SA1100) || defined(CPU_SA1110) || \
d1609 2
a1610 1
	defined(CPU_XSCALE_PXA2X0) || defined(CPU_XSCALE_IXP425)
d1912 2
a1913 2
		 | CPU_CONTROL_LABT_ENABLE | CPU_CONTROL_BPRD_ENABLE
		 | CPU_CONTROL_CPCLK;
d1925 3
d1933 1
a1933 1
	cpu_control(0xffffffff, cpuctrl);
d1938 1
a1938 1
#ifdef CPU_ARM10
d1977 3
d1984 4
a1987 1
	asm volatile ("mcr\tp15, 0, r0, c7, c7, 0" : : );
d1996 1
a1996 1
#endif	/* CPU_ARM10 */
@


1.6
log
@Add support for i80321 based systems.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.c,v 1.5 2006/03/07 20:20:28 miod Exp $	*/
d1098 1
a1098 1
		i80321_icu_init();
@


1.5
log
@Remove COMPAT_1x stuff inherited from NetBSD, which does not apply to us.
ok uwe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.c,v 1.4 2005/12/31 22:13:06 drahn Exp $	*/
d1041 1
d1053 1
d1096 2
a1097 1
	    cputype == CPU_ID_80321_400_B0 || cputype == CPU_ID_80321_600_B0) {
d1100 1
d1112 1
@


1.4
log
@whitespace cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.c,v 1.3 2004/12/30 23:43:15 drahn Exp $	*/
a1578 4
#ifdef COMPAT_12
	{ "nocache",		IGN, BIC, CPU_CONTROL_IDC_ENABLE },
	{ "nowritebuf",		IGN, BIC, CPU_CONTROL_WBUF_ENABLE },
#endif	/* COMPAT_12 */
a1642 3
#ifdef COMPAT_12
	{ "fpaclk2",		BIC, OR,  CPU_CONTROL_CPCLK },
#endif	/* COMPAT_12 */
a1688 3
#ifdef COMPAT_12
	{ "fpaclk2",		BIC, OR,  CPU_CONTROL_CPCLK },
#endif	/* COMPAT_12 */
a1724 3
#ifdef COMPAT_12
	{ "branchpredict", 	BIC, OR,  CPU_CONTROL_BPRD_ENABLE },
#endif	/* COMPAT_12 */
a1909 4
#ifdef COMPAT_12
	{ "nocache",		IGN, BIC, (CPU_CONTROL_IC_ENABLE | CPU_CONTROL_DC_ENABLE) },
	{ "nowritebuf",		IGN, BIC, CPU_CONTROL_WBUF_ENABLE },
#endif	/* COMPAT_12 */
a1966 4
#ifdef COMPAT_12
	{ "nocache",		IGN, BIC, (CPU_CONTROL_IC_ENABLE | CPU_CONTROL_DC_ENABLE) },
	{ "nowritebuf",		IGN, BIC, CPU_CONTROL_WBUF_ENABLE },
#endif	/* COMPAT_12 */
a2072 4
#ifdef COMPAT_12
	{ "branchpredict", 	BIC, OR,  CPU_CONTROL_BPRD_ENABLE },
	{ "nocache",		IGN, BIC, (CPU_CONTROL_IC_ENABLE | CPU_CONTROL_DC_ENABLE) },
#endif	/* COMPAT_12 */
@


1.3
log
@pxa270 is xscale
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.c,v 1.2 2004/05/19 03:17:06 drahn Exp $	*/
d104 1
a104 1
	
d162 1
a162 1
	
d165 1
a165 1
 
d224 1
a224 1
	
d282 1
a282 1
	
d340 1
a340 1
	
d391 1
a391 1
};          
d514 1
a514 1
	
d565 1
a565 1
};          
d571 1
a571 1
	
d622 1
a622 1
};          
d628 1
a628 1
	
d679 1
a679 1
};          
d686 1
a686 1
	
d848 9
a856 9
    /* cpuid,           cache type,       u,  dsiz, ls, wy,  isiz, ls, wy */
    { CPU_ID_ARM2,      0,                1,     0,  0,  0,     0,  0,  0 },
    { CPU_ID_ARM250,    0,                1,     0,  0,  0,     0,  0,  0 },
    { CPU_ID_ARM3,      CPU_CT_CTYPE_WT,  1,  4096, 16, 64,     0,  0,  0 },
    { CPU_ID_ARM610,	CPU_CT_CTYPE_WT,  1,  4096, 16, 64,     0,  0,  0 },
    { CPU_ID_ARM710,    CPU_CT_CTYPE_WT,  1,  8192, 32,  4,     0,  0,  0 },
    { CPU_ID_ARM7500,   CPU_CT_CTYPE_WT,  1,  4096, 16,  4,     0,  0,  0 },
    { CPU_ID_ARM710A,   CPU_CT_CTYPE_WT,  1,  8192, 16,  4,     0,  0,  0 },
    { CPU_ID_ARM7500FE, CPU_CT_CTYPE_WT,  1,  4096, 16,  4,     0,  0,  0 },
d949 1
a949 1
#endif	
d982 1
a982 1
		arm10_dcache_sets_max = 
d1027 7
a1033 7
        if (cputype == CPU_ID_IXP1200) {
                cpufuncs = ixp12x0_cpufuncs;
                cpu_reset_needs_v4_MMU_disable = 1;
                get_cachetype_table();
                pmap_pte_init_sa1();
                return 0;
        }
d1143 1
a1143 1
            cputype == CPU_ID_IXP425_266) {
d1255 1
a1255 1
        
d1271 1
a1271 1
				       base, count * 4));
d1284 1
a1284 1
	
d1406 1
a1406 1
		
d1410 1
a1410 1
		    || (fault_instruction & (1 << 21)) != 0) {	
d1420 1
a1420 1
				       base, registers[base]));
d1436 1
a1436 1
                
d1476 1
a1476 1
					       "register offset\n"));
d1547 2
a1548 2
	struct cpu_option *optlist;    
	u_int cpuctrl; 
d1802 1
a1802 1
	
d1810 1
a1810 1
	/* Set the clock/test register */    
d1887 1
a1887 1
	    | CPU_CONTROL_IC_ENABLE | CPU_CONTROL_DC_ENABLE 
d1974 1
a1974 1
	/* 
d2033 1
a2033 1
	/* Set the control register */    
d2084 1
a2084 1
	/* Set the control register */    
@


1.2
log
@de __P of sys/arch/arm.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.c,v 1.1 2004/02/01 05:09:48 drahn Exp $	*/
d1123 1
@


1.1
log
@Arm port, NetBSD codebase stripped down, 32bit only support.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.c,v 1.2 2004/01/29 16:17:11 drahn Exp $	*/
d753 1
a753 1
static void get_cachetype_cp15 __P((void));
d865 1
a865 1
static void get_cachetype_table __P((void));
d1541 1
a1541 1
static u_int parse_cpu_options __P((char *, struct cpu_option *, u_int));
@


1.1.2.1
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.1.2.2
log
@Merge with the trunk
@
text
@d753 1
a753 1
static void get_cachetype_cp15 (void);
d865 1
a865 1
static void get_cachetype_table (void);
d1541 1
a1541 1
static u_int parse_cpu_options (char *, struct cpu_option *, u_int);
@


