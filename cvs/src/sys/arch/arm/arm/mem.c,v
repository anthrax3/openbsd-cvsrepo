head	1.19;
access;
symbols
	OPENBSD_6_1_BASE:1.19
	OPENBSD_6_0:1.14.0.6
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.14.0.2
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.14.0.4
	OPENBSD_5_8_BASE:1.14
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.10.0.18
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.10.0.16
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.10.0.12
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.10.0.10
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.8
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.6
	OPENBSD_5_0:1.10.0.4
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.2
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.9.0.8
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.4
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.6
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.2
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.8.0.2
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.7.0.2
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.6.0.4
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.2
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.5.0.2
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.4.0.2
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.3.0.8
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.6
	OPENBSD_3_7_BASE:1.3
	OPENBSD_3_6:1.3.0.4
	OPENBSD_3_6_BASE:1.3
	SMP_SYNC_A:1.3
	SMP_SYNC_B:1.3
	OPENBSD_3_5:1.3.0.2
	OPENBSD_3_5_BASE:1.3
	SMP:1.2.0.2;
locks; strict;
comment	@ * @;


1.19
date	2016.09.25.15.23.37;	author deraadt;	state Exp;
branches;
next	1.18;
commitid	YxqfPf79WCjoxCH9;

1.18
date	2016.08.16.18.21.54;	author tedu;	state Exp;
branches;
next	1.17;
commitid	HXBbnmTBbLEpa4lm;

1.17
date	2016.08.16.18.17.36;	author tedu;	state Exp;
branches;
next	1.16;
commitid	dgebCYPvUOhYeX5I;

1.16
date	2016.08.15.22.01.59;	author tedu;	state Exp;
branches;
next	1.15;
commitid	hzJmUc5FH2irhNvz;

1.15
date	2016.08.01.15.58.22;	author tedu;	state Exp;
branches;
next	1.14;
commitid	0APfmV8i34pDgCWZ;

1.14
date	2015.05.28.20.53.05;	author jcs;	state Exp;
branches;
next	1.13;
commitid	mm0ThjDof6ifWCwA;

1.13
date	2015.02.10.22.44.35;	author miod;	state Exp;
branches;
next	1.12;
commitid	lsrmQ0A4gY4UmdnD;

1.12
date	2015.02.10.21.56.08;	author miod;	state Exp;
branches;
next	1.11;
commitid	C5iGb36LQxjM60Q3;

1.11
date	2014.11.16.12.30.56;	author deraadt;	state Exp;
branches;
next	1.10;
commitid	yv0ECmCdICvq576h;

1.10
date	2010.12.26.15.40.59;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2008.11.05.06.32.47;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2008.05.04.09.57.46;	author martin;	state Exp;
branches;
next	1.7;

1.7
date	2007.10.06.23.50.54;	author krw;	state Exp;
branches;
next	1.6;

1.6
date	2006.11.29.13.28.45;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2006.03.07.20.20.28;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2005.11.09.18.08.37;	author martin;	state Exp;
branches;
next	1.3;

1.3
date	2004.02.26.04.58.38;	author drahn;	state Exp;
branches;
next	1.2;

1.2
date	2004.02.01.06.10.33;	author drahn;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2004.02.01.05.09.48;	author drahn;	state Exp;
branches;
next	;

1.2.2.1
date	2004.02.19.10.48.01;	author niklas;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2004.06.05.23.10.44;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.19
log
@Make a move towards ending 4 decades of kernel snooping.

Add sysctl kern.allowkmem (default 0) which controls the ability to open
/dev/mem or /dev/kmem at securelevel > 0.  Over 15 years we converted 99%
of utilities in the tree to operate on sysctl-nodes (either by themselves
or via code hiding in the guts of -lkvm).

pstat -d and -v & procmap are affected and continued use of them will
require kern.allowkmem=1 in /etc/sysctl.conf.  acpidump (and it's
buddy sendbug) are affected, but we'll work out a solution soon.

There will be some impact in ports.

ok kettenis guenther
@
text
@/*	$OpenBSD: mem.c,v 1.18 2016/08/16 18:21:54 tedu Exp $	*/
/*	$NetBSD: mem.c,v 1.11 2003/10/16 12:02:58 jdolecek Exp $	*/

/*
 * Copyright (c) 1982, 1986, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
/*
 * Copyright (c) 1988 University of Utah.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Memory special file
 */

#include <sys/param.h>
#include <sys/conf.h>
#include <sys/buf.h>
#include <sys/systm.h>
#include <sys/uio.h>
#include <sys/malloc.h>
#include <sys/proc.h>
#include <sys/fcntl.h>
#include <sys/rwlock.h>

#include <machine/cpu.h>
#include <arm/conf.h>

#include <uvm/uvm_extern.h>

extern char *memhook;            /* poor name! */
caddr_t zeropage;

/* open counter for aperture */
#ifdef APERTURE
static int ap_open_count = 0;
extern int allowaperture;
#endif


int
mmopen(dev_t dev, int flag, int mode, struct proc *p)
{
	extern int allowkmem;

	switch (minor(dev)) {
	case 0:
	case 1:
		if (securelevel <= 0 || allowkmem)
			break;
		return (EPERM);
	case 2:
	case 12:
		break;
#ifdef APERTURE
	case 4:
		if (suser(p, 0) != 0 || !allowaperture)
			return (EPERM);

		/* authorize only one simultaneous open() unless
		 * allowaperture=3 */
		if (ap_open_count > 0 && allowaperture < 3)
			return (EPERM);
		ap_open_count++;
		break;
#endif
	default:
		return (ENXIO);
	}
	return (0);
}

int
mmclose(dev_t dev, int flag, int mode, struct proc *p)
{
#ifdef APERTURE
	if (minor(dev) == 4)
		ap_open_count = 0;
#endif
	return (0);
}

int
mmrw(dev_t dev, struct uio *uio, int flags)
{
	static struct rwlock physlock = RWLOCK_INITIALIZER("mmrw");
	vaddr_t o, v;
	size_t c;
	struct iovec *iov;
	int error = 0;
	vm_prot_t prot;

	if (minor(dev) == 0) {
		/* lock against other uses of shared vmmap */
		error = rw_enter(&physlock, RW_WRITE | RW_INTR);
		if (error)
			return (error);

	}
	while (uio->uio_resid > 0 && error == 0) {
		iov = uio->uio_iov;
		if (iov->iov_len == 0) {
			uio->uio_iov++;
			uio->uio_iovcnt--;
			if (uio->uio_iovcnt < 0)
				panic("mmrw");
			continue;
		}
		switch (minor(dev)) {

		case 0:
			v = uio->uio_offset;
			prot = uio->uio_rw == UIO_READ ? PROT_READ :
			    PROT_WRITE;
			pmap_enter(pmap_kernel(), (vaddr_t)memhook,
			    trunc_page(v), prot, prot|PMAP_WIRED);
			pmap_update(pmap_kernel());
			o = uio->uio_offset & PGOFSET;
			c = ulmin(uio->uio_resid, PAGE_SIZE - o);
			error = uiomove((caddr_t)memhook + o, c, uio);
			pmap_remove(pmap_kernel(), (vaddr_t)memhook,
			    (vaddr_t)memhook + PAGE_SIZE);
			pmap_update(pmap_kernel());
			break;

		case 1:
			v = uio->uio_offset;
			c = ulmin(iov->iov_len, MAXPHYS);
			if (!uvm_kernacc((caddr_t)v, c,
			    uio->uio_rw == UIO_READ ? B_READ : B_WRITE))
				return (EFAULT);
			error = uiomove((caddr_t)v, c, uio);
			break;

		case 2:
			if (uio->uio_rw == UIO_WRITE)
				uio->uio_resid = 0;
			return (0);

		case 12:
			if (uio->uio_rw == UIO_WRITE) {
				uio->uio_resid = 0;
				return (0);
			}
			if (zeropage == NULL)
				zeropage = malloc(PAGE_SIZE, M_TEMP,
				    M_WAITOK | M_ZERO);
			c = ulmin(iov->iov_len, PAGE_SIZE);
			error = uiomove(zeropage, c, uio);
			break;

		default:
			return (ENXIO);
		}
	}
	if (minor(dev) == 0) {
		rw_exit(&physlock);
	}
	return (error);
}

paddr_t
mmmmap(dev_t dev, off_t off, int prot)
{
	struct proc *p = curproc;	/* XXX */

	/*
	 * /dev/mem is the only one that makes sense through this
	 * interface.  For /dev/kmem any physaddr we return here
	 * could be transient and hence incorrect or invalid at
	 * a later time.  /dev/null just doesn't make any sense
	 * and /dev/zero is a hack that is handled via the default
	 * pager in mmap().
	 */
	if (minor(dev) != 0)
		return (-1);

	/* minor device 0 is physical memory */

	if ((paddr_t)off >= ptoa((paddr_t)physmem) &&
	    suser(p, 0) != 0)
		return -1;
	return off;
}

int
mmioctl(dev_t dev, u_long cmd, caddr_t data, int flags, struct proc *p)
{
	return (EOPNOTSUPP);
}
@


1.18
log
@remove #define for /dev/mem minors. let the raw magic of the hardcoded
numbers serve as a warning not to touch them.
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.17 2016/08/16 18:17:36 tedu Exp $	*/
d104 2
d107 3
a109 4
		case 0:
		case 1:
		case 2:
		case 12:
d111 4
d117 1
a117 1
	        if (suser(p, 0) != 0 || !allowaperture)
d127 2
a128 2
		default:
			return (ENXIO);
@


1.17
log
@replace hand rolled tsleep physlock with rwlock. ok mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.16 2016/08/15 22:01:59 tedu Exp $	*/
a136 4
#define DEV_MEM 0
#define DEV_KMEM 1
#define DEV_NULL 2
#define DEV_ZERO 12
d148 1
a148 1
	if (minor(dev) == DEV_MEM) {
d166 1
a166 1
		case DEV_MEM:
d181 1
a181 1
		case DEV_KMEM:
d190 1
a190 1
		case DEV_NULL:
d195 1
a195 1
		case DEV_ZERO:
d211 1
a211 1
	if (minor(dev) == DEV_MEM) {
d230 1
a230 1
	if (minor(dev) != DEV_MEM)
@


1.16
log
@normalize some comments
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.15 2016/08/01 15:58:22 tedu Exp $	*/
d84 1
a92 1
int physlock;
d145 1
d154 4
a157 8
		while (physlock > 0) {
			physlock++;
			error = tsleep((caddr_t)&physlock, PZERO | PCATCH,
			    "mmrw", 0);
			if (error)
				return (error);
		}
		physlock = 1;
d216 1
a216 3
		if (physlock > 1)
			wakeup((caddr_t)&physlock);
		physlock = 0;
@


1.15
log
@bring the light of ansi to a few more files
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.14 2015/05/28 20:53:05 jcs Exp $	*/
d118 1
a118 1
			return(EPERM);
a218 1
/*unlock:*/
@


1.14
log
@when machdep.allowaperture sysctl is set to 3, allow concurrent access
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.13 2015/02/10 22:44:35 miod Exp $	*/
a100 1
/*ARGSUSED*/
d102 1
a102 4
mmopen(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
a127 1
/*ARGSUSED*/
d129 1
a129 4
mmclose(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
a141 1
/*ARGSUSED*/
d143 1
a143 4
mmrw(dev, uio, flags)
	dev_t dev;
	struct uio *uio;
	int flags;
d228 1
a228 4
mmmmap(dev, off, prot)
	dev_t dev;
	off_t off;
	int prot;
d250 1
a250 1
/*ARGSUSED*/
a255 1

@


1.13
log
@Convert to uiomove().
ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.11 2014/11/16 12:30:56 deraadt Exp $	*/
d119 3
a121 2
		/* authorize only one simultaneous open() */
		if (ap_open_count > 0)
@


1.12
log
@First step towards making uiomove() take a size_t size argument:
- rename uiomove() to uiomovei() and update all its users.
- introduce uiomove(), which is similar to uiomovei() but with a size_t.
- rewrite uiomovei() as an uiomove() wrapper.
ok kettenis@@
@
text
@d156 3
a158 3
	register vaddr_t o, v;
	register int c;
	register struct iovec *iov;
d192 2
a193 2
			c = min(uio->uio_resid, (int)(PAGE_SIZE - o));
			error = uiomovei((caddr_t)memhook + o, c, uio);
d201 1
a201 1
			c = min(iov->iov_len, MAXPHYS);
d205 1
a205 1
			error = uiomovei((caddr_t)v, c, uio);
d221 2
a222 2
			c = min(iov->iov_len, PAGE_SIZE);
			error = uiomovei(zeropage, c, uio);
@


1.11
log
@Replace a plethora of historical protection options with just
PROT_NONE, PROT_READ, PROT_WRITE, and PROT_EXEC from mman.h.
PROT_MASK is introduced as the one true way of extracting those bits.
Remove UVM_ADV_* wrapper, using the standard names.
ok doug guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.10 2010/12/26 15:40:59 miod Exp $	*/
d193 1
a193 1
			error = uiomove((caddr_t)memhook + o, c, uio);
d205 1
a205 1
			error = uiomove((caddr_t)v, c, uio);
d222 1
a222 1
			error = uiomove(zeropage, c, uio);
@


1.10
log
@Kill pmap_phys_address(), and force every driver's mmap() routine to return
a physical address [more precisely, something suitable to pass to pmap_enter()'sphysical address argument].

This allows MI drivers to implement mmap() routines without having to know
about the pmap_phys_address() implementation and #ifdef obfuscation.
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.9 2008/11/05 06:32:47 matthieu Exp $	*/
d186 2
a187 2
			prot = uio->uio_rw == UIO_READ ? VM_PROT_READ :
			    VM_PROT_WRITE;
@


1.9
log
@since mmclose() is only called once for the final close,
set ap_open_count = 0 in mmclose() instread of decrementing it.
ok miod@@, oga@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.8 2008/05/04 09:57:46 martin Exp $	*/
d262 1
a262 1
	return atop(off);
@


1.8
log
@convert arm and mips64 platforms to ptoa/atop

tested by maja@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.7 2007/10/06 23:50:54 krw Exp $	*/
d140 1
a140 1
		ap_open_count--;
@


1.7
log
@Simpliest memset(,0,) -> M_ZERO changes. One (caddr *) cast removal,
otherwise just adding M_ZERO to malloc() and removing the immediately
adjacent memset(,0,).
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.6 2006/11/29 13:28:45 miod Exp $	*/
d259 1
a259 1
	if ((paddr_t)off >= ctob((paddr_t)physmem) &&
@


1.6
log
@Use unsigned numbers for comparisons in mmmmap().
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.5 2006/03/07 20:20:28 miod Exp $	*/
d218 3
a220 5
			if (zeropage == NULL) {
				zeropage = (caddr_t)
				    malloc(PAGE_SIZE, M_TEMP, M_WAITOK);
				memset(zeropage, 0, PAGE_SIZE);
			}
@


1.5
log
@Remove COMPAT_1x stuff inherited from NetBSD, which does not apply to us.
ok uwe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.4 2005/11/09 18:08:37 martin Exp $	*/
d261 1
a261 1
	if (off >= ctob(physmem) &&
@


1.4
log
@use atop() and ptoa()

tested by jolan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.3 2004/02/26 04:58:38 drahn Exp $	*/
a212 3
#ifdef COMPAT_16
		case _DEV_ZERO_oARM:
#endif
@


1.3
log
@add APERTURE support.
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.2 2004/02/01 06:10:33 drahn Exp $	*/
d267 1
a267 1
	return arm_btop(off);
@


1.2
log
@fix tags...
@
text
@d1 1
a1 1
/*	$OpenBSD: mem.c,v 1.1 2004/02/01 05:09:48 drahn Exp $	*/
d94 7
d109 14
a122 1
	default:
d124 3
d138 4
a141 1

@


1.2.2.1
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.2.2.2
log
@Merge with the trunk
@
text
@a93 7
/* open counter for aperture */
#ifdef APERTURE
static int ap_open_count = 0;
extern int allowaperture;
#endif


d102 1
a102 14
		case 0:
		case 1:
		case 2:
		case 12:
			break;
#ifdef APERTURE
	case 4:
	        if (suser(p, 0) != 0 || !allowaperture)
			return (EPERM);

		/* authorize only one simultaneous open() */
		if (ap_open_count > 0)
			return(EPERM);
		ap_open_count++;
a103 3
#endif
		default:
			return (ENXIO);
d115 1
a115 4
#ifdef APERTURE
	if (minor(dev) == 4)
		ap_open_count--;
#endif
@


1.1
log
@Arm port, NetBSD codebase stripped down, 32bit only support.
@
text
@d1 2
a2 2
/*	$OpenBSD: mem.c,v 1.2 2004/01/29 16:17:16 drahn Exp $	*/
/*^I$NetBSD: mem.c,v 1.11 2003/10/16 12:02:58 jdolecek Exp $^I*/$
@

