head	1.14;
access;
symbols
	OPENBSD_6_0:1.10.0.2
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.8.0.2
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.4
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.6
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.4
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.6.0.2
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.4.0.2
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.3.0.4
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.2
	OPENBSD_5_0:1.2.0.6
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.4
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.2
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.1.0.2
	OPENBSD_4_7_BASE:1.1
	OPENBSD_4_6:1.1.0.4
	OPENBSD_4_6_BASE:1.1;
locks; strict;
comment	@# @;


1.14
date	2016.08.15.21.08.56;	author kettenis;	state Exp;
branches;
next	1.13;
commitid	21vXHk63zJTKaMiE;

1.13
date	2016.08.06.16.46.25;	author kettenis;	state Exp;
branches;
next	1.12;
commitid	CGAfg7FH1Wq4zBj1;

1.12
date	2016.08.05.19.56.52;	author kettenis;	state Exp;
branches;
next	1.11;
commitid	c9gkhdy0t6MbxbzI;

1.11
date	2016.08.03.07.05.05;	author kettenis;	state Exp;
branches;
next	1.10;
commitid	k28vhAMZpfCRr4Q3;

1.10
date	2016.04.25.04.46.56;	author jsg;	state Exp;
branches;
next	1.9;
commitid	XqdsV6PrfEUXwK4U;

1.9
date	2016.04.04.09.06.28;	author patrick;	state Exp;
branches;
next	1.8;
commitid	ZuB0flUUaGbKwG8C;

1.8
date	2015.06.02.02.30.16;	author jsg;	state Exp;
branches;
next	1.7;
commitid	MDqoReLKfFLYYM4U;

1.7
date	2013.08.30.09.24.41;	author patrick;	state Exp;
branches;
next	1.6;

1.6
date	2013.03.30.01.30.30;	author patrick;	state Exp;
branches;
next	1.5;

1.5
date	2013.03.27.00.20.00;	author patrick;	state Exp;
branches;
next	1.4;

1.4
date	2013.01.25.20.23.48;	author bmercer;	state Exp;
branches;
next	1.3;

1.3
date	2011.11.09.12.29.00;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2010.07.01.22.40.10;	author drahn;	state Exp;
branches;
next	1.1;

1.1
date	2009.05.09.02.28.22;	author drahn;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Don't take shortcuts cleaning/invalidating the caches.  The Cortex-A7 and most
other ARMv7 CPUs have a L2 cache that is larger than 32KB.  And some of those
even have L1 caches larger than that.  So bailing out after 32KB will leave
the cache partially dirty.

Fixes the SATA problems on Allwinner A20 based boards.

ok patrick@@
@
text
@/* $OpenBSD: cpufunc_asm_armv7.S,v 1.13 2016/08/06 16:46:25 kettenis Exp $ */
/*
 * Copyright (c) 2008 Dale Rahn <drahn@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <machine/cpu.h>
#include <machine/asm.h>
#include <arm/armreg.h>
#include <arm/sysreg.h>

ENTRY(armv7_cpu_sleep)
	wfi
	mov	pc, lr

ENTRY(armv7_drain_writebuf)
	dsb	sy
	isb	sy
	mov	pc, lr

/*
 * Function to read the MPCore base address
 */
ENTRY(armv7_periphbase)
	mrc	CP15_CBAR(r0)	
	mov	pc, lr

/* Suitable default for a uniprocessor kernel. */
#define TTBR_DEFAULT	(TTBR_IRGN_WBNWA | TTBR_RGN_WBNWA)

/*
 * Functions to set the MMU Translation Table Base register
 */
ENTRY(armv7_setttb)
	mcr	CP15_ICIALLU		/* Flush I cache */
	mcr	CP15_BPIALL		/* Flush BP cache */
	dsb	sy
	isb	sy

	orr	r0, r0, #TTBR_DEFAULT
	mcr	CP15_TTBR0(r0)		/* load new TTB */
	mcr	CP15_TLBIALL(r0)	/* invalidate unified TLB */
	dsb	sy
	isb	sy

	mov	pc, lr

/*
 * TLB functions
 */
ENTRY(armv7_tlb_flushID_SE)
	mcr	CP15_TLBIMVA(r0)	/* flush unified tlb single entry */
	mcr	CP15_BPIMVA		/* flush va from BP */
	dsb	sy
	isb	sy
	mov	pc, lr

ENTRY(armv7_tlb_flushID)
	mcr	CP15_TLBIALL(r0)	/* flush unified tlb */
	mcr	CP15_BPIALL		/* Flush BP cache */
	dsb	sy
	isb	sy
	mov	pc, lr

ENTRY(armv7_tlb_flushD_SE)
	mcr	CP15_TLBIMVA(r0)	/* flush unified tlb single entry */
	dsb	sy
	isb	sy
	mov	pc, lr

ENTRY(armv7_tlb_flushD)
	mcr	CP15_TLBIALL(r0)	/* flush unified tlb */
	dsb	sy
	isb	sy
	mov	pc, lr


/*
 * Cache operations.  For the entire cache we use the set/index
 * operations.
 */
.Larmv7_dcache_line_size:
	.word	_C_LABEL(arm_dcache_min_line_size)
.Larmv7_icache_line_size:
	.word	_C_LABEL(arm_icache_min_line_size)
.Larmv7_idcache_line_size:
	.word	_C_LABEL(arm_idcache_min_line_size)

	s_max	.req r0
	i_max	.req r1
	s_inc	.req r2
	i_inc	.req r3
ENTRY(armv7_icache_sync_range)
	ldr	ip, .Larmv7_icache_line_size
	ldr	ip, [ip]
	sub	r1, r1, #1		/* Don't overrun */
	sub	r3, ip, #1
	and	r2, r0, r3
	add	r1, r1, r2
	bic	r0, r0, r3
1:
	mcr	CP15_DCCMVAU(r0)	/* Clean D cache SE with VA to PoU */
	mcr	CP15_ICIMVAU(r0)	/* Invalidate I cache SE with VA */
	add	r0, r0, ip
	subs	r1, r1, ip
	bhi	1b
	mcr	CP15_BPIALL		/* Flush BP cache */
	dsb	sy
	isb	sy
	mov	pc, lr

ENTRY(armv7_icache_sync_all)
.Larmv7_icache_sync_all:
	/*
	 * We assume that the code here can never be out of sync with the
	 * dcache, so that we can safely flush the Icache and fall through
	 * into the Dcache cleaning code.
	 */
	mcr	CP15_ICIALLU		/* Flush I cache */
	mcr	CP15_BPIALL		/* Flush BP cache */
	isb	sy
	mov	pc, lr

ENTRY(armv7_dcache_wb_range)
	ldr	ip, .Larmv7_dcache_line_size
	ldr	ip, [ip]
	sub	r1, r1, #1		/* Don't overrun */
	sub	r3, ip, #1
	and	r2, r0, r3
	add	r1, r1, r2
	bic	r0, r0, r3
1:
	mcr	CP15_DCCMVAC(r0)	/* Clean D cache SE with VA */
	add	r0, r0, ip
	subs	r1, r1, ip
	bhi	1b
	dsb	sy
	isb	sy
	mov	pc, lr

ENTRY(armv7_idcache_wbinv_range)
	ldr	ip, .Larmv7_idcache_line_size
	ldr	ip, [ip]
	sub	r1, r1, #1		/* Don't overrun */
	sub	r3, ip, #1
	and	r2, r0, r3
	add	r1, r1, r2
	bic	r0, r0, r3
1:
	mcr	CP15_DCCMVAU(r0)	/* Clean D cache SE with VA to PoU */
	mcr	CP15_ICIMVAU(r0)	/* Invalidate I cache SE with VA */
	mcr	CP15_DCCIMVAC(r0)	/* Purge D cache SE with VA */
	add	r0, r0, ip
	subs	r1, r1, ip
	bhi	1b
	mcr	CP15_BPIALL		/* Flush BP cache */
	dsb	sy
	isb	sy
	mov	pc, lr

ENTRY(armv7_dcache_wbinv_range)
	ldr	ip, .Larmv7_dcache_line_size
	ldr	ip, [ip]
	sub	r1, r1, #1		/* Don't overrun */
	sub	r3, ip, #1
	and	r2, r0, r3
	add	r1, r1, r2
	bic	r0, r0, r3
1:
	mcr	CP15_DCCMVAU(r0)	/* Clean D cache SE with VA to PoU */
	mcr	CP15_ICIMVAU(r0)	/* Invalidate I cache SE with VA */
	mcr	CP15_DCCIMVAC(r0)	/* Purge D cache SE with VA */
	add	r0, r0, ip
	subs	r1, r1, ip
	bhi	1b
	dsb	sy
	isb	sy
	mov	pc, lr

ENTRY(armv7_dcache_inv_range)
	ldr	ip, .Larmv7_dcache_line_size
	ldr	ip, [ip]
	sub	r1, r1, #1		/* Don't overrun */
	sub	r3, ip, #1
	and	r2, r0, r3
	add	r1, r1, r2
	bic	r0, r0, r3
1:
	mcr	CP15_DCCMVAU(r0)	/* Clean D cache SE with VA to PoU */
	mcr	CP15_ICIMVAU(r0)	/* Invalidate I cache SE with VA */
	mcr	CP15_DCIMVAC(r0)	/* Invalidate D cache SE with VA */
	add	r0, r0, ip
	subs	r1, r1, ip
	bhi	1b
	dsb	sy
	isb	sy
	mov	pc, lr


/*
 * Context switch.
 *
 * These is the CPU-specific parts of the context switcher cpu_switch()
 * These functions actually perform the TTB reload.
 *
 * NOTE: Special calling convention
 *	r1, r4-r13 must be preserved
 */
ENTRY(armv7_context_switch)
	/*
	 * We can assume that the caches will only contain kernel addresses
	 * at this point.  So no need to flush them again.
	 */
	mcr	CP15_ICIALLU		/* Flush I cache */
	mcr	CP15_BPIALL		/* Flush BP cache */
	dsb	sy
	isb	sy

	orr	r0, r0, #TTBR_DEFAULT
	mcr	CP15_TTBR0(r0)		/* set the new TTB */
	mcr	CP15_TLBIALL(r0)	/* and flush the unified tlb */
	dsb	sy
	isb	sy
	mov	pc, lr

/* XXX The following macros should probably be moved to asm.h */
#define _DATA_OBJECT(x) .globl x; .type x,_ASM_TYPE_OBJECT; x:
#define C_OBJECT(x)	_DATA_OBJECT(_C_LABEL(x))

	.align 2
C_OBJECT(armv7_dcache_sets_max)
	.word	0
C_OBJECT(armv7_dcache_index_max)
	.word	0
C_OBJECT(armv7_dcache_sets_inc)
	.word	0
C_OBJECT(armv7_dcache_index_inc)
	.word	0
@


1.13
log
@Put page tables in normal cachable memory on armv7.  Check if the MMU walks
the page tables coherently and also skip flushing modified ptes out of the
cache in that case.  Speeds up building a kernel with a factor of two on
Cortex-A9 (tested by me) and Cortex-A8 (tested by mglocker@@).

ok patrick@@
@
text
@d1 1
a1 1
/* $OpenBSD: cpufunc_asm_armv7.S,v 1.12 2016/08/05 19:56:52 kettenis Exp $ */
a105 2
	cmp	r1, #0x8000
	movcs	r1, #0x8000	/* XXX needs to match cache size... */
a136 2
	cmp	r1, #0x8000
	movcs	r1, #0x8000	/* XXX needs to match cache size... */
a153 2
	cmp	r1, #0x8000
	movcs	r1, #0x8000	/* XXX needs to match cache size... */
a173 2
	cmp	r1, #0x8000
	movcs	r1, #0x8000	/* XXX needs to match cache size... */
a192 2
	cmp	r1, #0x8000
	movcs	r1, #0x8000	/* XXX needs to match cache size... */
@


1.12
log
@Replace inappropriate use of CP15_CNTPCT with CP_DCCIMVAC.
No binary change.
@
text
@d1 1
a1 1
/* $OpenBSD: cpufunc_asm_armv7.S,v 1.11 2016/08/03 07:05:05 kettenis Exp $ */
d20 1
d39 3
d51 1
d240 1
@


1.11
log
@The ARMv7 architecture deprecates the separate Instruction and Data TLB
maintanenance instruction and recommends to only use the instructions that
operate on the unified TLB.  Those instructions will flush both TLBs on
implementations that still have separate Instruction and Data TLBs.  Switch
the TLB maintenance primitives over to use those.  This allows us to reduce
the number of primitives on armv7.  We still keep separate "ID" and "D"
variants as we still have to flush the branch predictor when changing the
mappings of pages that contain instructions.

ok jsg@@
@
text
@d1 1
a1 1
/* $OpenBSD: cpufunc_asm_armv7.S,v 1.10 2016/04/25 04:46:56 jsg Exp $ */
d164 1
a164 1
	mcr	CP15_CNTPCT(r0, c7), 1	/* Purge D cache SE with VA */
d186 1
a186 1
	mcr	CP15_CNTPCT(r0, c7), 1	/* Purge D cache SE with VA */
@


1.10
log
@Switch most of the cp14/cp15 use in .S files over to using sysreg.h

Matched and changed by a script, verified to cause no binary change with
armv7, armish, and zaurus kernels.

ok patrick@@
@
text
@d1 1
a1 1
/* $OpenBSD: cpufunc_asm_armv7.S,v 1.9 2016/04/04 09:06:28 patrick Exp $ */
d48 1
a48 1
	mcr	CP15_TLBIALL(r0)	/* invalidate I+D TLBs */
d58 1
a58 2
	mcr	CP15_DTLBIMVA		/* flush D tlb single entry */
	mcr	CP15_ITLBIMVA		/* flush I tlb single entry */
a63 10
ENTRY(armv7_tlb_flushI_SE)
	mcr	CP15_ITLBIMVA		/* flush I tlb single entry */
	mcr	CP15_BPIMVA		/* flush va from BP */
	dsb	sy
	isb	sy
	mov	pc, lr

/*
 * TLB functions
 */
d65 1
a65 1
	mcr	CP15_TLBIALL(r0)	/* flush I+D tlb */
d71 2
a72 3
ENTRY(armv7_tlb_flushI)
	mcr	CP15_ITLBIALL		/* flush I tlb */
	mcr	CP15_BPIALL		/* Flush BP cache */
d78 1
a78 7
	mcr	CP15_DTLBIALL		/* flush D tlb */
	dsb	sy
	isb	sy
	mov	pc, lr

ENTRY(armv7_tlb_flushD_SE)
	mcr	CP15_DTLBIMVA		/* flush D tlb single entry */
d236 1
a236 1
	mcr	CP15_TLBIALL(r0)	/* and flush the I+D tlbs */
@


1.9
log
@Read cache line sizes from CP15 Cache Type Register.

Previously we used the primary data cache's information on how big
the cache lines are.  The CTR gives us better information about how
big the smallest cache line sizes (controlled by the CPU) are.

ok jsg@@
@
text
@d1 1
a1 1
/* $OpenBSD: cpufunc_asm_armv7.S,v 1.8 2015/06/02 02:30:16 jsg Exp $ */
d20 1
d35 1
a35 1
	mrc	p15, 4, r0, c15, c0, 0
d42 2
a43 2
	mcr	p15, 0, r0, c7, c5, 0	/* Flush I cache */
	mcr	p15, 0, r0, c7, c5, 6	/* Flush BP cache */
d47 2
a48 2
	mcr	p15, 0, r0, c2, c0, 0	/* load new TTB */
	mcr	p15, 0, r0, c8, c7, 0	/* invalidate I+D TLBs */
d58 3
a60 3
	mcr	p15, 0, r0, c8, c6, 1	/* flush D tlb single entry */
	mcr	p15, 0, r0, c8, c5, 1	/* flush I tlb single entry */
	mcr	p15, 0, r0, c7, c5, 7	/* flush va from BP */
d66 2
a67 2
	mcr	p15, 0, r0, c8, c5, 1	/* flush I tlb single entry */
	mcr	p15, 0, r0, c7, c5, 7	/* flush va from BP */
d76 2
a77 2
	mcr	p15, 0, r0, c8, c7, 0	/* flush I+D tlb */
	mcr	p15, 0, r0, c7, c5, 6	/* Flush BP cache */
d83 2
a84 2
	mcr	p15, 0, r0, c8, c5, 0	/* flush I tlb */
	mcr	p15, 0, r0, c7, c5, 6	/* Flush BP cache */
d90 1
a90 1
	mcr	p15, 0, r0, c8, c6, 0	/* flush D tlb */
d96 1
a96 1
	mcr	p15, 0, r0, c8, c6, 1	/* flush D tlb single entry */
d128 2
a129 2
	mcr	p15, 0, r0, c7, c11, 1	/* Clean D cache SE with VA to PoU */
	mcr	p15, 0, r0, c7, c5, 1	/* Invalidate I cache SE with VA */
d133 1
a133 1
	mcr	p15, 0, r0, c7, c5, 6	/* Flush BP cache */
d145 2
a146 2
	mcr	p15, 0, r0, c7, c5, 0	/* Flush I cache */
	mcr	p15, 0, r0, c7, c5, 6	/* Flush BP cache */
d161 1
a161 1
	mcr	p15, 0, r0, c7, c10, 1	/* Clean D cache SE with VA */
d180 3
a182 3
	mcr	p15, 0, r0, c7, c11, 1	/* Clean D cache SE with VA to PoU */
	mcr	p15, 0, r0, c7, c5, 1	/* Invalidate I cache SE with VA */
	mcr	p15, 0, r0, c7, c14, 1	/* Purge D cache SE with VA */
d186 1
a186 1
	mcr	p15, 0, r0, c7, c5, 6	/* Flush BP cache */
d202 3
a204 3
	mcr	p15, 0, r0, c7, c11, 1	/* Clean D cache SE with VA to PoU */
	mcr	p15, 0, r0, c7, c5, 1	/* Invalidate I cache SE with VA */
	mcr	p15, 0, r0, c7, c14, 1	/* Purge D cache SE with VA */
d223 3
a225 3
	mcr	p15, 0, r0, c7, c11, 1	/* Clean D cache SE with VA to PoU */
	mcr	p15, 0, r0, c7, c5, 1	/* Invalidate I cache SE with VA */
	mcr	p15, 0, r0, c7, c6, 1	/* Invalidate D cache SE with VA */
d248 2
a249 2
	mcr	p15, 0, r0, c7, c5, 0	/* Flush I cache */
	mcr	p15, 0, r0, c7, c5, 6	/* Flush BP cache */
d253 2
a254 2
	mcr	p15, 0, r0, c2, c0, 0	/* set the new TTB */
	mcr	p15, 0, r0, c8, c7, 0	/* and flush the I+D tlbs */
@


1.8
log
@with binutils 2.17 we can change some raw opcodes into instruction names
ok miod@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: cpufunc_asm_armv7.S,v 1.7 2013/08/30 09:24:41 patrick Exp $ */
d105 7
d117 1
a117 1
	ldr	ip, .Larmv7_line_size
a148 3
.Larmv7_line_size:
	.word	_C_LABEL(arm_pdcache_line_size)

d150 1
a150 1
	ldr	ip, .Larmv7_line_size
d169 1
a169 1
	ldr	ip, .Larmv7_line_size
d191 1
a191 1
	ldr	ip, .Larmv7_line_size
d212 1
a212 1
	ldr	ip, .Larmv7_line_size
@


1.7
log
@Due to our current version of binutils not knowing newer ARMv7 instructions
we define DSB/ISB (Data/Instruction Synchronization Barrier) manually.
There are multiple options for those instructions, i. e. "full system
operation", which is the default of those.

The defines we used were not the defaults we assumed they were, but some
other option which might not actually exist.

In the future we could try using DSB/ISB as a Mask and add the correct
option value.  For now, just fix those values.

ok rapha@@
@
text
@d1 1
a1 1
/* $OpenBSD: cpufunc_asm_armv7.S,v 1.6 2013/03/30 01:30:30 patrick Exp $ */
a20 4
#define	DSB	.long	0xf57ff04f
#define	ISB	.long	0xf57ff06f
#define	WFI	.long	0xe320f003

d22 1
a22 1
	WFI
d26 2
a27 2
	DSB
	ISB
d43 2
a44 2
	DSB
	ISB
d48 2
a49 2
	DSB
	ISB
d60 2
a61 2
	DSB
	ISB
d67 2
a68 2
	DSB
	ISB
d77 2
a78 2
	DSB
	ISB
d84 2
a85 2
	DSB
	ISB
d90 2
a91 2
	DSB
	ISB
d96 2
a97 2
	DSB
	ISB
d126 2
a127 2
	DSB
	ISB
d139 1
a139 1
	ISB
d160 2
a161 2
	DSB
	ISB
d182 2
a183 2
	DSB
	ISB
d203 2
a204 2
	DSB
	ISB
d224 2
a225 2
	DSB
	ISB
d245 2
a246 2
	DSB
	ISB
d250 2
a251 2
	DSB
	ISB
@


1.6
log
@Add a function to read the ARM MPCore base address. This let's us
dynamically determine where e.g. the interrupt controller is.

ok bmercer@@
@
text
@d1 1
a1 1
/* $OpenBSD: cpufunc_asm_armv7.S,v 1.5 2013/03/27 00:20:00 patrick Exp $ */
d21 2
a22 2
#define	DSB	.long	0xf57ff040
#define	ISB	.long	0xf57ff060
@


1.5
log
@Draining the write buffer is accomplished via a DSB.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: cpufunc_asm_armv7.S,v 1.4 2013/01/25 20:23:48 bmercer Exp $ */
d32 7
@


1.4
log
@Updates for beagle/panda work. OK patrick@@ and miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: cpufunc_asm_armv7.S,v 1.3 2011/11/09 12:29:00 miod Exp $ */
a31 1
	mcr	p15, 0, r0, c7, c10, 4	/* drain write buffer */
a41 1
	mcr	p15, 0, r0, c7, c10, 4	/* drain write buffer */
a58 1
	mcr	p15, 0, r0, c7, c10, 4	/* drain write buffer */
a65 1
	mcr	p15, 0, r0, c7, c10, 4	/* drain write buffer */
a75 1
	mcr	p15, 0, r0, c7, c10, 4	/* drain write buffer */
a82 1
	mcr	p15, 0, r0, c7, c10, 4	/* drain write buffer */
a88 1
	mcr	p15, 0, r0, c7, c10, 4	/* drain write buffer */
a94 1
	mcr	p15, 0, r0, c7, c10, 4	/* drain write buffer */
a124 1
	mcr	p15, 0, r0, c7, c10, 4	/* drain the write buffer */
a158 1
	mcr	p15, 0, r0, c7, c10, 4	/* drain the write buffer */
a180 1
	mcr	p15, 0, r0, c7, c10, 4	/* drain the write buffer */
a201 1
	mcr	p15, 0, r0, c7, c10, 4	/* drain the write buffer */
a222 1
	mcr	p15, 0, r0, c7, c10, 4	/* drain the write buffer */
a243 1
	mcr	p15, 0, r0, c7, c10, 4	/* drain the write buffer */
@


1.3
log
@Fix manual wfi instruction encoding.
@
text
@d1 1
a1 1
/* $OpenBSD: cpufunc_asm_armv7.S,v 1.2 2010/07/01 22:40:10 drahn Exp $ */
d21 4
d26 1
a26 5
#if 0
	wfi
#else
	.long	0xe320f003;
#endif
d30 2
a36 3
 *
 * We need to clean and flush the cache as it uses virtual
 * addresses that are about to change.
d39 5
a43 3
	stmfd	sp!, {r0, lr}
	bl	_C_LABEL(armv7_idcache_wbinv_all)
	ldmfd	sp!, {r0, lr}
d46 3
a49 2
	mcr	p15, 0, r0, c8, c7, 0	/* invalidate I+D TLBs */
	mcr	p15, 0, r0, c7, c10, 4	/* drain write buffer */
d58 3
d66 3
d77 3
d85 3
d93 2
d100 2
d116 2
a117 2
	cmp	r1, #0x4000
	bcs	.Larmv7_icache_sync_all
d125 1
a126 1
	mcr	p15, 0, r0, c7, c10, 1	/* Clean D cache SE with VA */
d129 4
a132 1
	bpl	1b
d144 2
a145 16
	/* Fall through to clean Dcache. */

.Larmv7_dcache_wb:
	ldr	ip, .Larmv7_cache_data
	ldmia	ip, {s_max, i_max, s_inc, i_inc}
1:
	orr	ip, s_max, i_max
2:
	mcr	p15, 0, ip, c7, c10, 2	/* Clean D cache SE with Set/Index */
	sub	ip, ip, i_inc
	tst	ip, i_max		/* Index 0 is last one */
	bne	2b			/* Next index */
	mcr	p15, 0, ip, c7, c10, 2	/* Clean D cache SE with Set/Index */
	subs	s_max, s_max, s_inc
	bpl	1b			/* Next set */
	mcr	p15, 0, r0, c7, c10, 4	/* drain the write buffer */
a151 5
#if 1
	/* until pmap can invalidate before unmapping */
	/* XXX this also invalidates */
	b _C_LABEL(armv7_dcache_wbinv_all)
#else
d153 2
a154 2
	cmp	r1, #0x4000
	bcs	.Larmv7_dcache_wb
d165 3
a167 1
	bpl	1b
a168 1
#endif
d173 2
a174 8
	cmp	r1, #0x4000
#if 0
	bcs	.Larmv7_idcache_wbinv_all
#else
	bcc	1f
	mov	r1, #0x4000
1:
#endif
d182 1
d187 4
a190 1
	bpl	1b
d196 2
a197 2
	cmp	r1, #0x4000
	bcs _C_LABEL(armv7_dcache_wbinv_all)
d205 1
d210 25
a234 1
	bpl	1b
d253 4
d258 1
d261 2
a262 5

	/* Paranoia -- make sure the pipeline is empty. */
	nop
	nop
	nop
a267 3

.Larmv7_cache_data:
	.word	_C_LABEL(armv7_dcache_sets_max)
@


1.2
log
@Add more support bits for ARMv7, including frame for VIPT (pmap_prefer).
@
text
@d1 1
a1 1
/* $OpenBSD: cpufunc_asm_armv7.S,v 1.1 2009/05/09 02:28:22 drahn Exp $ */
d25 1
a25 1
	.long	0xe340f003;
@


1.1
log
@Missed adding this file.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d88 27
a114 1
/* STUBS - implement these */
d116 28
a143 3
ENTRY(armv7_icache_sync_range)
ENTRY(armv7_dcache_wbinv_all)
ENTRY(armv7_dcache_wbinv_range)
d145 23
a167 1
ENTRY(armv7_idcache_wbinv_all)
d169 22
d193 20
d240 3
@

