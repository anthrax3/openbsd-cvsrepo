head	1.19;
access;
symbols
	OPENBSD_6_1_BASE:1.19
	OPENBSD_6_0:1.17.0.2
	OPENBSD_6_0_BASE:1.17
	OPENBSD_5_9:1.16.0.2
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.15.0.4
	OPENBSD_5_8_BASE:1.15
	OPENBSD_5_7:1.14.0.2
	OPENBSD_5_7_BASE:1.14
	OPENBSD_5_6:1.13.0.10
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.13.0.8
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.13.0.4
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.13.0.2
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.12.0.4
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.2
	OPENBSD_5_0:1.9.0.12
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.10
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.8
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.4
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.6
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.2
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.8.0.4
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.2
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.6.0.2
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.5.0.2
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.4.0.6
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.4
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.2
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.3.0.4
	OPENBSD_3_7_BASE:1.3
	OPENBSD_3_6:1.3.0.2
	OPENBSD_3_6_BASE:1.3
	SMP_SYNC_A:1.3
	SMP_SYNC_B:1.3
	OPENBSD_3_5:1.2.0.4
	OPENBSD_3_5_BASE:1.2
	SMP:1.2.0.2;
locks; strict;
comment	@ * @;


1.19
date	2017.02.12.04.55.08;	author guenther;	state Exp;
branches;
next	1.18;
commitid	1rXx7AiXIWFC9gYa;

1.18
date	2016.07.31.09.18.01;	author jsg;	state Exp;
branches;
next	1.17;
commitid	5do1fawIQ98C9bBm;

1.17
date	2016.04.24.01.31.02;	author patrick;	state Exp;
branches;
next	1.16;
commitid	a1zPZPWcIN0F3Zcz;

1.16
date	2015.08.15.22.20.20;	author miod;	state Exp;
branches;
next	1.15;
commitid	rjFF3mVWQmD2XvGW;

1.15
date	2015.05.05.02.13.46;	author guenther;	state Exp;
branches;
next	1.14;
commitid	dNPv28CJI5BxtRGW;

1.14
date	2014.11.16.12.30.56;	author deraadt;	state Exp;
branches;
next	1.13;
commitid	yv0ECmCdICvq576h;

1.13
date	2013.01.16.19.04.43;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2011.11.08.17.07.20;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2011.09.21.15.34.47;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2011.09.20.22.02.11;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2009.01.28.08.02.02;	author grange;	state Exp;
branches;
next	1.8;

1.8
date	2007.10.13.07.18.32;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2007.10.10.15.53.51;	author art;	state Exp;
branches;
next	1.6;

1.6
date	2007.05.27.20.59.25;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2006.11.29.12.26.13;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2005.05.23.23.26.55;	author tedu;	state Exp;
branches;
next	1.3;

1.3
date	2004.05.19.03.17.07;	author drahn;	state Exp;
branches;
next	1.2;

1.2
date	2004.02.01.06.10.33;	author drahn;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2004.02.01.05.09.48;	author drahn;	state Exp;
branches;
next	;

1.2.2.1
date	2004.02.19.10.48.01;	author niklas;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2004.06.05.23.10.44;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.19
log
@Split up fork1():
 - FORK_THREAD handling is a totally separate function, thread_fork(),
   that is only used by sys___tfork() and which loses the flags, func,
   arg, and newprocp parameters and gains tcb parameter to guarantee
   the new thread's TCB is set before the creating thread returns
 - fork1() loses its stack and tidptr parameters
Common bits factor out:
 - struct proc allocation and initialization moves to thread_new()
 - maxthread handling moves to fork_check_maxthread()
 - setting the new thread running moves to fork_thread_start()
The MD cpu_fork() function swaps its unused stacksize parameter for
a tcb parameter.

luna88k testing by aoyama@@, alpha testing by dlg@@
ok mpi@@
@
text
@/*	$OpenBSD: vm_machdep.c,v 1.18 2016/07/31 09:18:01 jsg Exp $	*/
/*	$NetBSD: vm_machdep.c,v 1.31 2004/01/04 11:33:29 jdolecek Exp $	*/

/*
 * Copyright (c) 1994-1998 Mark Brinicombe.
 * Copyright (c) 1994 Brini.
 * All rights reserved.
 *
 * This code is derived from software written for Brini by Mark Brinicombe
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Brini.
 * 4. The name of the company nor the name of the author may be used to
 *    endorse or promote products derived from this software without specific
 *    prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY BRINI ``AS IS'' AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL BRINI OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * RiscBSD kernel project
 *
 * vm_machdep.h
 *
 * vm machine specific bits
 *
 * Created      : 08/10/94
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/signalvar.h>
#include <sys/malloc.h>
#include <sys/vnode.h>
#include <sys/buf.h>
#include <sys/user.h>
#include <sys/exec.h>
#include <sys/ptrace.h>

#include <uvm/uvm_extern.h>

#include <machine/cpu.h>
#include <machine/pmap.h>
#include <machine/reg.h>
#include <machine/vmparam.h>

extern pv_addr_t systempage;

int process_read_regs	(struct proc *p, struct reg *regs);
int process_read_fpregs	(struct proc *p, struct fpreg *regs);

extern void proc_trampoline	(void);

/*
 * Special compilation symbols:
 *
 * STACKCHECKS - Fill undefined and supervisor stacks with a known pattern
 *		 on forking and check the pattern on exit, reporting
 *		 the amount of stack used.
 */

/*
 * Finish a fork operation, with process p2 nearly set up.
 * Copy and update the pcb and trap frame, making the child ready to run.
 *
 * Rig the child's kernel stack so that it will start out in
 * proc_trampoline() and call 'func' with 'arg' as an argument.
 * For normal processes this is child_return(), which causes the
 * child to go directly to user level with an apparent return value
 * of 0 from fork(), while the parent process returns normally.
 * For kernel threads this will be a function that never return.
 *
 * An alternate user-level stack or TCB can be requested by passing
 * a non-NULL value; these are poked into the PCB so they're in
 * effect at the initial return to userspace.
 */
void
cpu_fork(struct proc *p1, struct proc *p2, void *stack, void *tcb,
    void (*func)(void *), void *arg)
{
	struct pcb *pcb = (struct pcb *)&p2->p_addr->u_pcb;
	struct trapframe *tf;
	struct switchframe *sf;

	if (p1 == curproc) {
		/* Sync the PCB before we copy it. */
		savectx(curpcb);
	}

	/* Copy the pcb */
	*pcb = p1->p_addr->u_pcb;

	/* 
	 * Set up the undefined stack for the process.
	 * Note: this stack is not in use if we are forking from p1
	 */
	pcb->pcb_un.un_32.pcb32_und_sp = (u_int)p2->p_addr +
	    USPACE_UNDEF_STACK_TOP;
	pcb->pcb_un.un_32.pcb32_sp = (u_int)p2->p_addr + USPACE_SVC_STACK_TOP;

#ifdef STACKCHECKS
	/* Fill the undefined stack with a known pattern */
	memset(((u_char *)p2->p_addr) + USPACE_UNDEF_STACK_BOTTOM, 0xdd,
	    (USPACE_UNDEF_STACK_TOP - USPACE_UNDEF_STACK_BOTTOM));
	/* Fill the kernel stack with a known pattern */
	memset(((u_char *)p2->p_addr) + USPACE_SVC_STACK_BOTTOM, 0xdd,
	    (USPACE_SVC_STACK_TOP - USPACE_SVC_STACK_BOTTOM));
#endif	/* STACKCHECKS */

	pmap_activate(p2);

	pcb->pcb_tf = tf = (struct trapframe *)pcb->pcb_un.un_32.pcb32_sp - 1;
	*tf = *p1->p_addr->u_pcb.pcb_tf;

	/*
	 * If specified, give the child a different stack and/or TCB.
	 * Enforce 8-byte alignment on the stack.
	 */
	if (stack != NULL)
		tf->tf_usr_sp = (vaddr_t)stack & -8;
	if (tcb != NULL)
		p2->p_addr->u_pcb.pcb_tcb = tcb;

	sf = (struct switchframe *)tf - 1;
	sf->sf_r4 = (u_int)func;
	sf->sf_r5 = (u_int)arg;
	sf->sf_pc = (u_int)proc_trampoline;
	pcb->pcb_un.un_32.pcb32_sp = (u_int)sf;
}

void
cpu_exit(struct proc *p)
{
	pmap_deactivate(p);
	sched_exit(p);
}

/*
 * Map a user I/O request into kernel virtual address space.
 * Note: the pages are already locked by uvm_vslock(), so we
 * do not need to pass an access_type to pmap_enter().
 */
void
vmapbuf(struct buf *bp, vsize_t len)
{
	vaddr_t faddr, taddr, off;
	paddr_t fpa;


	if ((bp->b_flags & B_PHYS) == 0)
		panic("vmapbuf");

	faddr = trunc_page((vaddr_t)(bp->b_saveaddr = bp->b_data));
	off = (vaddr_t)bp->b_data - faddr;
	len = round_page(off + len);
	taddr = uvm_km_valloc_wait(phys_map, len);
	bp->b_data = (caddr_t)(taddr + off);

	/*
	 * The region is locked, so we expect that pmap_pte() will return
	 * non-NULL.
	 */
	while (len) {
		(void) pmap_extract(vm_map_pmap(&bp->b_proc->p_vmspace->vm_map),
		    faddr, &fpa);
		pmap_enter(pmap_kernel(), taddr, fpa,
		    PROT_READ | PROT_WRITE,
		    PROT_READ | PROT_WRITE | PMAP_WIRED);
		faddr += PAGE_SIZE;
		taddr += PAGE_SIZE;
		len -= PAGE_SIZE;
	}
	pmap_update(pmap_kernel());
}

/*
 * Unmap a previously-mapped user I/O request.
 */
void
vunmapbuf(struct buf *bp, vsize_t len)
{
	vaddr_t addr, off;

	if ((bp->b_flags & B_PHYS) == 0)
		panic("vunmapbuf");

	/*
	 * Make sure the cache does not have dirty data for the
	 * pages we had mapped.
	 */
	addr = trunc_page((vaddr_t)bp->b_data);
	off = (vaddr_t)bp->b_data - addr;
	len = round_page(off + len);
	
	pmap_remove(pmap_kernel(), addr, addr + len);
	pmap_update(pmap_kernel());
	uvm_km_free_wakeup(phys_map, addr, len);
	bp->b_data = bp->b_saveaddr;
	bp->b_saveaddr = 0;
}

/* End of vm_machdep.c */
@


1.18
log
@Use ansi style function declarations.  No binary change.
From Robert Tate.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.17 2016/04/24 01:31:02 patrick Exp $	*/
d83 1
a83 1
 * 
d85 9
a93 12
 * proc_trampoline() and call child_return() with p2 as an
 * argument. This causes the newly-created child process to go
 * directly to user level with an apparent return value of 0 from
 * fork(), while the parent process returns normally.
 *
 * p1 is the process being forked; if p1 == &proc0, we are creating
 * a kernel thread, and the return path and argument are specified with
 * `func' and `arg'.
 *
 * If an alternate user-level stack is requested (with non-zero values
 * in both the stack and stacksize args), set up the user stack pointer
 * accordingly.
d96 2
a97 2
cpu_fork(struct proc *p1, struct proc *p2, void *stack,
    size_t stacksize, void (*func) (void *), void *arg)
d130 1
a130 2
	p2->p_addr->u_pcb.pcb_tf = tf =
	    (struct trapframe *)pcb->pcb_un.un_32.pcb32_sp - 1;
d134 2
a135 2
	 * If specified, give the child a different stack (make sure
	 * it's 8-byte aligned).
d138 3
a140 1
		tf->tf_usr_sp = ((vaddr_t)(stack) + stacksize) & -8;
@


1.17
log
@EABI's Procedure Call Standard (AAPCS) requires the stack pointer
to be 8-byte aligned. To guarantee this, align the stack pointers
passed to user processes and make sure the in-kernel stacks are
properly aligned, too.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.16 2015/08/15 22:20:20 miod Exp $	*/
d99 2
a100 7
cpu_fork(p1, p2, stack, stacksize, func, arg)
	struct proc *p1;
	struct proc *p2;
	void *stack;
	size_t stacksize;
	void (*func) (void *);
	void *arg;
d164 1
a164 3
vmapbuf(bp, len)
	struct buf *bp;
	vsize_t len;
d200 1
a200 3
vunmapbuf(bp, len)
	struct buf *bp;
	vsize_t len;
@


1.16
log
@Remove orphaned debug code.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.15 2015/05/05 02:13:46 guenther Exp $	*/
d143 2
a144 1
	 * If specified, give the child a different stack.
d147 1
a147 1
		tf->tf_usr_sp = (u_int)stack + stacksize;
@


1.15
log
@emul_native is only used for kernel threads which can't dump core, so
delete coredump_trad(), uvm_coredump(), cpu_coredump(), struct md_coredump,
and various #includes that are superfluous.

This leaves compat_linux processes without a coredump callback.  If that
ability is desired, someone should update it to use coredump_elf32() and
verify the results...

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.14 2014/11/16 12:30:56 deraadt Exp $	*/
a110 5
#ifdef PMAP_DEBUG
	if (pmap_debug_level >= 0)
		printf("cpu_fork: %p %p %p\n", p1, p2, &proc0);
#endif	/* PMAP_DEBUG */

a135 11
#ifdef PMAP_DEBUG
	if (pmap_debug_level >= 0) {
		printf("p1->procaddr=%p p1->procaddr->u_pcb=%p pid=%d pmap=%p\n",
		    p1->p_addr, &p1->p_addr->u_pcb, p1->p_pid,
		    p1->p_vmspace->vm_map.pmap);
		printf("p2->procaddr=%p p2->procaddr->u_pcb=%p pid=%d pmap=%p\n",
		    p2->p_addr, &p2->p_addr->u_pcb, p2->p_pid,
		    p2->p_vmspace->vm_map.pmap);
	}
#endif	/* PMAP_DEBUG */

a175 6
#ifdef PMAP_DEBUG
	if (pmap_debug_level >= 0)
		printf("vmapbuf: bp=%08x buf=%08x len=%08x\n", (u_int)bp,
		    (u_int)bp->b_data, (u_int)len);
#endif	/* PMAP_DEBUG */
    
a210 6

#ifdef PMAP_DEBUG
	if (pmap_debug_level >= 0)
		printf("vunmapbuf: bp=%08x buf=%08x len=%08x\n",
		    (u_int)bp, (u_int)bp->b_data, (u_int)len);
#endif	/* PMAP_DEBUG */
@


1.14
log
@Replace a plethora of historical protection options with just
PROT_NONE, PROT_READ, PROT_WRITE, and PROT_EXEC from mman.h.
PROT_MASK is introduced as the one true way of extracting those bits.
Remove UVM_ADV_* wrapper, using the standard names.
ok doug guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.13 2013/01/16 19:04:43 miod Exp $	*/
a54 1
#include <sys/core.h>
a175 49
}

/*
 * Dump the machine specific segment at the start of a core dump.
 */

int
cpu_coredump(struct proc *p, struct vnode *vp, struct ucred *cred,
    struct core *chdr)
{
	int error;
	struct {
		struct reg regs;
		struct fpreg fpregs;
	} cpustate;
	struct coreseg cseg;

	CORE_SETMAGIC(*chdr, COREMAGIC, MID_MACHINE, 0);
	chdr->c_hdrsize = ALIGN(sizeof(*chdr));
	chdr->c_seghdrsize = ALIGN(sizeof(cseg));
	chdr->c_cpusize = sizeof(cpustate);

	/* Save integer registers. */
	error = process_read_regs(p, &cpustate.regs);
	if (error)
		return error;
	/* Save floating point registers. */
	error = process_read_fpregs(p, &cpustate.fpregs);
	if (error)
		return error;

	CORE_SETMAGIC(cseg, CORESEGMAGIC, MID_MACHINE, CORE_CPU);
	cseg.c_addr = 0;
	cseg.c_size = chdr->c_cpusize;

	error = vn_rdwr(UIO_WRITE, vp, (caddr_t)&cseg, chdr->c_seghdrsize,
	    (off_t)chdr->c_hdrsize, UIO_SYSSPACE, IO_UNIT, cred, NULL, p);
	if (error)
		return error;

	error = vn_rdwr(UIO_WRITE, vp, (caddr_t)&cpustate, sizeof(cpustate),
	    (off_t)(chdr->c_hdrsize + chdr->c_seghdrsize), UIO_SYSSPACE,
	    IO_UNIT, cred, NULL, p);
	if (error)
		return error;

	chdr->c_nseg++;

	return error;
@


1.13
log
@cpu_coredump() also needs to invoke vn_rdwr() without IO_NODELOCKED; only
affects a.out binaries' core dumps.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.12 2011/11/08 17:07:20 deraadt Exp $	*/
d265 2
a266 1
			VM_PROT_READ|VM_PROT_WRITE, VM_PROT_READ|VM_PROT_WRITE|PMAP_WIRED);
@


1.12
log
@merge cpu_coredump() back to where it belongs; ok miod drahn
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.11 2011/09/21 15:34:47 miod Exp $	*/
d213 1
a213 2
	    (off_t)chdr->c_hdrsize, UIO_SYSSPACE,
	    IO_NODELOCKED|IO_UNIT, cred, NULL, p);
d219 1
a219 1
	    IO_NODELOCKED|IO_UNIT, cred, NULL, p);
@


1.11
log
@Get rid of curlwp references; mk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.10 2011/09/20 22:02:11 miod Exp $	*/
d50 1
a53 3
#if 0
#include <sys/pmc.h>
#endif
d55 1
d57 1
a57 1
#include <sys/syslog.h>
d177 50
@


1.10
log
@Late spring cleaning of the arm code for old dusty bits we do not want to
keep:
- remove bootconfig parameter passing feature (unused).
- unifdef __PROG32 and remove all remains of arm26 code.
- remove ARMFPE support (unused).
- remove support for ARM2, ARM2AS, ARM3, ARM6, ARM7, ARM7TDMI and StrongARM
  processor families, and the related silicon bug workarounds (especially
  the SA-110 STM^ bug).
- remove cpu_functions no longer necessary after previous removals.
- remove ARM32_DISABLE_ALIGNMENT_FAULTS option (unused).
- make FIQ support conditional on option FIQ (unused, but may be eventually).

Discussed with drahn@@ and jasper@@ long ago, I was sitting on this commit for
no good reason.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.9 2009/01/28 08:02:02 grange Exp $	*/
d115 1
a115 1
		printf("cpu_fork: %p %p %p %p\n", p1, p2, curlwp, &proc0);
d118 1
a118 2
#if 0 /* XXX */
	if (l1 == curlwp) {
a121 1
#endif
d146 2
a147 2
		    p1->p_addr, &p1->p_addr->u_pcb, p1->p_lid,
		    p1->p_proc->p_vmspace->vm_map.pmap);
d149 2
a150 2
		    p2->p_addr, &p2->p_addr->u_pcb, p2->p_lid,
		    p2->p_proc->p_vmspace->vm_map.pmap);
@


1.9
log
@Add missing braces in trunc_page() call from vmapbuf().

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.8 2007/10/13 07:18:32 miod Exp $	*/
a66 4
#ifdef ARMFPE
#include <arm/fpe-arm/armfpe.h>
#endif

a156 6

#ifdef ARMFPE
	/* Initialise a new FP context for p2 and copy the context from p1 */
	arm_fpe_core_initcontext(FP_CONTEXT(p2));
	arm_fpe_copycontext(FP_CONTEXT(p1), FP_CONTEXT(p2));
#endif	/* ARMFPE */
@


1.8
log
@Fix cpu_exit() comments to be more closer to reality.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.7 2007/10/10 15:53:51 art Exp $	*/
d215 1
a215 1
	faddr = trunc_page((vaddr_t)bp->b_saveaddr = bp->b_data);
@


1.7
log
@Make context switching much more MI:
 - Move the functionality of choosing a process from cpu_switch into
   a much simpler function: cpu_switchto. Instead of having the locore
   code walk the run queues, let the MI code choose the process we
   want to run and only implement the context switching itself in MD
   code.
 - Let MD context switching run without worrying about spls or locks.
 - Instead of having the idle loop implemented with special contexts
   in MD code, implement one idle proc for each cpu. make the idle
   loop MI with MD hooks.
 - Change the proc lists from the old style vax queues to TAILQs.
 - Change the sleep queue from vax queues to TAILQs. This makes
   wakeup() go from O(n^2) to O(n)

there will be some MD fallout, but it will be fixed shortly.
There's also a few cleanups to be done after this.

deraadt@@, kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.6 2007/05/27 20:59:25 miod Exp $	*/
a187 3
#if 0
	pmap_update(p->p_vmspace->vm_map.pmap); /* XXX DSR help stability */
#endif
@


1.6
log
@pagemove() is no longer used.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.5 2006/11/29 12:26:13 miod Exp $	*/
a75 2
void	switch_exit	(struct proc *p, struct proc *p0,
			     void (*)(struct proc *));
a85 17
#if 0
void
cpu_proc_fork(p1, p2)
	struct proc *p1, *p2;
{

#if defined(PERFCTRS)
	if (PMC_ENABLED(p1))
		pmc_md_fork(p1, p2);
	else {
		p2->p_md.pmc_enabled = 0;
		p2->p_md.pmc_state = NULL;
	}
#endif
}
#endif

a184 16
#if 0
void
cpu_setfunc(struct proc *p, void (*func)(void *), void *arg)
{
	struct pcb *pcb = &p->p_addr->u_pcb;
	struct trapframe *tf = pcb->pcb_tf;
	struct switchframe *sf = (struct switchframe *)tf - 1;

	sf->sf_r4 = (u_int)func;
	sf->sf_r5 = (u_int)arg;
	sf->sf_pc = (u_int)proc_trampoline;
	pcb->pcb_un.un_32.pcb32_sp = (u_int)sf;
}
#endif


d188 1
d190 3
a192 1
	switch_exit(p, &proc0, exit2);
@


1.5
log
@Remove cpu_swapin() and cpu_swapout(), they are no longer necessary (except
for cpu_swapin() on hppa* which is kept).
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.4 2005/05/23 23:26:55 tedu Exp $	*/
a224 34
}

/*
 * Move pages from one kernel virtual address to another.
 * Both addresses are assumed to reside in the Sysmap,
 * and size must be a multiple of PAGE_SIZE.
 */

void
pagemove(from, to, size)
	caddr_t from, to;
	size_t size;
{
	paddr_t pa;
	boolean_t rv;

	if (size % PAGE_SIZE)
		panic("pagemove: size=%08lx", (u_long) size);

	while (size > 0) {
		rv = pmap_extract(pmap_kernel(), (vaddr_t) from, &pa);
#ifdef DEBUG
		if (rv == FALSE)
			panic("pagemove 2");
		if (pmap_extract(pmap_kernel(), (vaddr_t) to, NULL) == TRUE)
			panic("pagemove 3");
#endif
		pmap_kremove((vaddr_t) from, PAGE_SIZE);
		pmap_kenter_pa((vaddr_t) to, pa, VM_PROT_READ|VM_PROT_WRITE);
		from += PAGE_SIZE;
		to += PAGE_SIZE;
		size -= PAGE_SIZE;
	}
	pmap_update(pmap_kernel());
@


1.4
log
@loose is not lose. ok deraadt tdeval and a few more typos from jfb
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.3 2004/05/19 03:17:07 drahn Exp $	*/
a225 50

void
cpu_swapin(p)
	struct proc *p;
{
#if 0

	/* Don't do this.  See the comment in cpu_swapout().  */
#ifdef PMAP_DEBUG
	if (pmap_debug_level >= 0)
		printf("cpu_swapin(%p, %d, %s, %p)\n", l, l->l_lid,
		    p->p_comm, p->p_vmspace->vm_map.pmap);
#endif	/* PMAP_DEBUG */

	if (vector_page < KERNEL_BASE) {
		/* Map the vector page */
		pmap_enter(p->p_vmspace->vm_map.pmap, vector_page,
		    systempage.pv_pa, VM_PROT_READ, VM_PROT_READ|PMAP_WIRED);
		pmap_update(p->p_vmspace->vm_map.pmap);
	}
#endif
}


void
cpu_swapout(l)
	struct proc *l;
{
#if 0
	struct proc *p = l->l_proc;

	/* 
	 * Don't do this!  If the pmap is shared with another process,
	 * it will lose its page0 entry.  That's bad news indeed.
	 */
#ifdef PMAP_DEBUG
	if (pmap_debug_level >= 0)
		printf("cpu_swapout(%p, %d, %s, %p)\n", l, l->l_lid,
		    p->p_comm, &p->p_vmspace->vm_map.pmap);
#endif	/* PMAP_DEBUG */

	if (vector_page < KERNEL_BASE) {
		/* Free the system page mapping */
		pmap_remove(p->p_vmspace->vm_map.pmap, vector_page,
		    vector_page + PAGE_SIZE);
		pmap_update(p->p_vmspace->vm_map.pmap);
	}
#endif
}

@


1.3
log
@de __P of sys/arch/arm.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.2 2004/02/01 06:10:33 drahn Exp $	*/
d259 1
a259 1
	 * it will loose it's page0 entry.  That's bad news indeed.
@


1.2
log
@fix tags...
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.1 2004/02/01 05:09:48 drahn Exp $	*/
d73 2
a74 2
int process_read_regs	__P((struct proc *p, struct reg *regs));
int process_read_fpregs	__P((struct proc *p, struct fpreg *regs));
d76 3
a78 3
void	switch_exit	__P((struct proc *p, struct proc *p0,
			     void (*)(struct proc *)));
extern void proc_trampoline	__P((void));
d129 1
a129 1
	void (*func) __P((void *));
@


1.2.2.1
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.2.2.2
log
@Merge with the trunk
@
text
@d73 2
a74 2
int process_read_regs	(struct proc *p, struct reg *regs);
int process_read_fpregs	(struct proc *p, struct fpreg *regs);
d76 3
a78 3
void	switch_exit	(struct proc *p, struct proc *p0,
			     void (*)(struct proc *));
extern void proc_trampoline	(void);
d129 1
a129 1
	void (*func) (void *);
@


1.1
log
@Arm port, NetBSD codebase stripped down, 32bit only support.
@
text
@d1 2
a2 2
/*	$OpenBSD: vm_machdep.c,v 1.2 2004/01/29 16:17:16 drahn Exp $	*/
/*^I$NetBSD: vm_machdep.c,v 1.31 2004/01/04 11:33:29 jdolecek Exp $^I*/$
@

