head	1.36;
access;
symbols
	OPENBSD_6_0:1.30.0.2
	OPENBSD_6_0_BASE:1.30
	OPENBSD_5_9:1.22.0.2
	OPENBSD_5_9_BASE:1.22
	OPENBSD_5_8:1.21.0.4
	OPENBSD_5_8_BASE:1.21
	OPENBSD_5_7:1.20.0.2
	OPENBSD_5_7_BASE:1.20
	OPENBSD_5_6:1.18.0.4
	OPENBSD_5_6_BASE:1.18
	OPENBSD_5_5:1.17.0.4
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.16.0.2
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.15.0.2
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.14.0.4
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.2
	OPENBSD_5_0:1.13.0.2
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.12.0.4
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.12.0.2
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.10.0.2
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.10.0.4
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.9.0.2
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.8.0.6
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.4
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.2
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.7.0.4
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.2
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.6.0.2
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.4.0.2
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.3.0.2
	OPENBSD_3_7_BASE:1.3
	OPENBSD_3_6:1.2.0.6
	OPENBSD_3_6_BASE:1.2
	SMP_SYNC_A:1.2
	SMP_SYNC_B:1.2
	OPENBSD_3_5:1.2.0.4
	OPENBSD_3_5_BASE:1.2
	SMP:1.2.0.2;
locks; strict;
comment	@ * @;


1.36
date	2017.01.05.16.16.17;	author patrick;	state Exp;
branches;
next	1.35;
commitid	4A2j3S336QFvowJq;

1.35
date	2017.01.01.09.54.44;	author jsg;	state Exp;
branches;
next	1.34;
commitid	Lr3h9kcV9hjBOnKS;

1.34
date	2016.09.26.13.34.11;	author kettenis;	state Exp;
branches;
next	1.33;
commitid	1efK1QzJLzTHbtHx;

1.33
date	2016.09.24.13.03.47;	author kettenis;	state Exp;
branches;
next	1.32;
commitid	9PbSYmtcqgKwPRCy;

1.32
date	2016.08.14.11.30.54;	author jsg;	state Exp;
branches;
next	1.31;
commitid	3XHAPSr5dKOYN1hw;

1.31
date	2016.07.31.06.24.38;	author jsg;	state Exp;
branches;
next	1.30;
commitid	cHTUmn3erNchuKuB;

1.30
date	2016.03.22.23.35.01;	author patrick;	state Exp;
branches;
next	1.29;
commitid	RkEnvixfXW2bEpue;

1.29
date	2016.03.22.23.28.02;	author patrick;	state Exp;
branches;
next	1.28;
commitid	bAxWaXK3mkjM56Iw;

1.28
date	2016.03.22.11.18.17;	author patrick;	state Exp;
branches;
next	1.27;
commitid	YjNMWFHczdMD8Xoi;

1.27
date	2016.03.19.09.51.24;	author patrick;	state Exp;
branches;
next	1.26;
commitid	E8GUcpv6nbDyd4Ml;

1.26
date	2016.03.19.09.47.54;	author patrick;	state Exp;
branches;
next	1.25;
commitid	WySdpoZsQMX20beB;

1.25
date	2016.03.19.09.36.56;	author patrick;	state Exp;
branches;
next	1.24;
commitid	PJBEdVboqiwjXPXy;

1.24
date	2016.03.18.13.16.02;	author jsg;	state Exp;
branches;
next	1.23;
commitid	RKG2cJTBtpcdjKgj;

1.23
date	2016.03.18.06.54.21;	author jsg;	state Exp;
branches;
next	1.22;
commitid	82aYg3LAWI4D5T1j;

1.22
date	2015.09.19.02.13.05;	author jsg;	state Exp;
branches;
next	1.21;
commitid	Ce0wEVwBF798D4MX;

1.21
date	2015.05.29.05.48.07;	author jsg;	state Exp;
branches;
next	1.20;
commitid	wBu16DsvoGvtioAP;

1.20
date	2014.11.16.12.30.56;	author deraadt;	state Exp;
branches;
next	1.19;
commitid	yv0ECmCdICvq576h;

1.19
date	2014.11.14.09.56.06;	author dlg;	state Exp;
branches;
next	1.18;
commitid	Z3djpPRPe92exHie;

1.18
date	2014.03.29.18.09.28;	author guenther;	state Exp;
branches;
next	1.17;

1.17
date	2013.08.06.23.15.43;	author jsg;	state Exp;
branches;
next	1.16;

1.16
date	2013.03.22.21.32.31;	author patrick;	state Exp;
branches;
next	1.15;

1.15
date	2013.01.18.00.20.20;	author patrick;	state Exp;
branches;
next	1.14;

1.14
date	2011.09.20.22.02.10;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2011.03.17.21.49.33;	author jasper;	state Exp;
branches;
next	1.12;

1.12
date	2010.07.01.22.39.08;	author drahn;	state Exp;
branches;
next	1.11;

1.11
date	2010.04.22.21.03.17;	author drahn;	state Exp;
branches;
next	1.10;

1.10
date	2009.05.08.02.57.32;	author drahn;	state Exp;
branches;
next	1.9;

1.9
date	2008.09.11.02.38.14;	author kevlo;	state Exp;
branches;
next	1.8;

1.8
date	2007.07.01.19.09.20;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2006.05.29.17.01.42;	author drahn;	state Exp;
branches;
next	1.6;

1.6
date	2005.12.22.20.11.16;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2005.12.22.18.44.42;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2005.05.21.03.27.05;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	2004.12.30.23.33.28;	author drahn;	state Exp;
branches;
next	1.2;

1.2
date	2004.02.01.06.10.33;	author drahn;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2004.02.01.05.09.48;	author drahn;	state Exp;
branches;
next	;

1.2.2.1
date	2004.02.19.10.48.00;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.36
log
@Complete idle PCB allocation for secondary processors so that it makes
sense and builds as part of an MP kernel.

ok kettenis@@ mpi@@
@
text
@/*	$OpenBSD: cpu.c,v 1.35 2017/01/01 09:54:44 jsg Exp $	*/
/*	$NetBSD: cpu.c,v 1.56 2004/04/14 04:01:49 bsh Exp $	*/


/*
 * Copyright (c) 1995 Mark Brinicombe.
 * Copyright (c) 1995 Brini.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Brini.
 * 4. The name of the company nor the name of the author may be used to
 *    endorse or promote products derived from this software without specific
 *    prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY BRINI ``AS IS'' AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL BRINI OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * RiscBSD kernel project
 *
 * cpu.c
 *
 * Probing and configuration for the master CPU
 *
 * Created      : 10/10/95
 */

#include <sys/param.h>

#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/device.h>
#include <sys/user.h>
#include <sys/proc.h>
#include <sys/conf.h>
#include <sys/sched.h>
#include <uvm/uvm_extern.h>
#include <machine/cpu.h>
#include <machine/intr.h>

#include <arm/cpuconf.h>
#include <arm/undefined.h>

char cpu_model[256];

/* Prototypes */
void identify_arm_cpu(struct device *dv, struct cpu_info *);

/*
 * Identify the master (boot) CPU
 */
  
void
cpu_attach(struct device *dv)
{
	curcpu()->ci_dev = dv;

	/* Get the CPU ID from coprocessor 15 */

	curcpu()->ci_arm_cpuid = cpu_id();
	curcpu()->ci_arm_cputype = curcpu()->ci_arm_cpuid & CPU_ID_CPU_MASK;
	curcpu()->ci_arm_cpurev =
	    curcpu()->ci_arm_cpuid & CPU_ID_REVISION_MASK;

	identify_arm_cpu(dv, curcpu());
}

enum cpu_class {
	CPU_CLASS_NONE,
	CPU_CLASS_ARMv7,
	CPU_CLASS_ARMv8
};

static const char * const generic_steppings[16] = {
	"rev 0",	"rev 1",	"rev 2",	"rev 3",
	"rev 4",	"rev 5",	"rev 6",	"rev 7",
	"rev 8",	"rev 9",	"rev 10",	"rev 11",
	"rev 12",	"rev 13",	"rev 14",	"rev 15"
};

struct cpuidtab {
	u_int32_t	cpuid;
	enum		cpu_class cpu_class;
	const char	*cpu_name;
	const char * const *cpu_steppings;
};

const struct cpuidtab cpuids[] = {
	{ CPU_ID_CORTEX_A5,	CPU_CLASS_ARMv7,	"ARM Cortex A5",
	  generic_steppings },
	{ CPU_ID_CORTEX_A7,	CPU_CLASS_ARMv7,	"ARM Cortex A7",
	  generic_steppings },
	{ CPU_ID_CORTEX_A8,	CPU_CLASS_ARMv7,	"ARM Cortex A8",
	  generic_steppings },
	{ CPU_ID_CORTEX_A8_R1,	CPU_CLASS_ARMv7,	"ARM Cortex A8 R1",
	  generic_steppings },
	{ CPU_ID_CORTEX_A8_R2,	CPU_CLASS_ARMv7,	"ARM Cortex A8 R2",
	  generic_steppings },
	{ CPU_ID_CORTEX_A8_R3,	CPU_CLASS_ARMv7,	"ARM Cortex A8 R3",
	  generic_steppings },
	{ CPU_ID_CORTEX_A9,	CPU_CLASS_ARMv7,	"ARM Cortex A9",
	  generic_steppings },
	{ CPU_ID_CORTEX_A9_R1,	CPU_CLASS_ARMv7,	"ARM Cortex A9 R1",
	  generic_steppings },
	{ CPU_ID_CORTEX_A9_R2,	CPU_CLASS_ARMv7,	"ARM Cortex A9 R2",
	  generic_steppings },
	{ CPU_ID_CORTEX_A9_R3,	CPU_CLASS_ARMv7,	"ARM Cortex A9 R3",
	  generic_steppings },
	{ CPU_ID_CORTEX_A9_R4,	CPU_CLASS_ARMv7,	"ARM Cortex A9 R4",
	  generic_steppings },
	{ CPU_ID_CORTEX_A15,	CPU_CLASS_ARMv7,	"ARM Cortex A15",
	  generic_steppings },
	{ CPU_ID_CORTEX_A15_R1,	CPU_CLASS_ARMv7,	"ARM Cortex A15 R1",
	  generic_steppings },
	{ CPU_ID_CORTEX_A15_R2,	CPU_CLASS_ARMv7,	"ARM Cortex A15 R2",
	  generic_steppings },
	{ CPU_ID_CORTEX_A15_R3,	CPU_CLASS_ARMv7,	"ARM Cortex A15 R3",
	  generic_steppings },
	{ CPU_ID_CORTEX_A15_R4,	CPU_CLASS_ARMv7,	"ARM Cortex A15 R4",
	  generic_steppings },
	{ CPU_ID_CORTEX_A17,	CPU_CLASS_ARMv7,	"ARM Cortex A17",
	  generic_steppings },
	{ CPU_ID_CORTEX_A17_R1,	CPU_CLASS_ARMv7,	"ARM Cortex A17 R1",
	  generic_steppings },

	{ CPU_ID_CORTEX_A32,	CPU_CLASS_ARMv8,	"ARM Cortex A32",
	  generic_steppings },
	{ CPU_ID_CORTEX_A35,	CPU_CLASS_ARMv8,	"ARM Cortex A35",
	  generic_steppings },
	{ CPU_ID_CORTEX_A53,	CPU_CLASS_ARMv8,	"ARM Cortex A53",
	  generic_steppings },
	{ CPU_ID_CORTEX_A53_R1,	CPU_CLASS_ARMv8,	"ARM Cortex A53 R1",
	  generic_steppings },
	{ CPU_ID_CORTEX_A57,	CPU_CLASS_ARMv8,	"ARM Cortex A57",
	  generic_steppings },
	{ CPU_ID_CORTEX_A57_R1,	CPU_CLASS_ARMv8,	"ARM Cortex A57 R1",
	  generic_steppings },
	{ CPU_ID_CORTEX_A72,	CPU_CLASS_ARMv8,	"ARM Cortex A72",
	  generic_steppings },
	{ CPU_ID_CORTEX_A72_R1,	CPU_CLASS_ARMv8,	"ARM Cortex A72 R1",
	  generic_steppings },
	{ CPU_ID_CORTEX_A73,	CPU_CLASS_ARMv8,	"ARM Cortex A73",
	  generic_steppings },

	{ 0, CPU_CLASS_NONE, NULL, NULL }
};

struct cpu_classtab {
	const char	*class_name;
	const char	*class_option;
};

const char *cpu_classes[] = {
	"unknown",		/* CPU_CLASS_NONE */
	"ARMv7",		/* CPU_CLASS_ARMv7 */
	"ARMv8"			/* CPU_CLASS_ARMv8 */
};

/*
 * Report the type of the specified arm processor. This uses the generic and
 * arm specific information in the cpu structure to identify the processor.
 * The remaining fields in the cpu structure are filled in appropriately.
 */

static const char * const wtnames[] = {
	"wr-thru",
	"wr-back",
	"wr-back",
	"**unknown 3**",
	"**unknown 4**",
	"wr-back-lock",		/* XXX XScale-specific? */
	"wr-back-lock-A",
	"wr-back-lock-B",
	"**unknown 8**",
	"**unknown 9**",
	"**unknown 10**",
	"**unknown 11**",
	"**unknown 12**",
	"**unknown 13**",
	"**unknown 14**",
	"**unknown 15**"
};

void
identify_arm_cpu(struct device *dv, struct cpu_info *ci)
{
	u_int cpuid;
	enum cpu_class cpu_class = CPU_CLASS_NONE;
	int i;

	cpuid = ci->ci_arm_cpuid;

	if (cpuid == 0) {
		printf("Processor failed probe - no CPU ID\n");
		return;
	}

	for (i = 0; cpuids[i].cpuid != 0; i++)
		if (cpuids[i].cpuid == (cpuid & CPU_ID_CPU_MASK)) {
			cpu_class = cpuids[i].cpu_class;
			snprintf(cpu_model, sizeof(cpu_model),
			    "%s %s (%s core)", cpuids[i].cpu_name,
			    cpuids[i].cpu_steppings[cpuid &
						    CPU_ID_REVISION_MASK],
			    cpu_classes[cpu_class]);
			break;
		}

	if (cpuids[i].cpuid == 0)
		snprintf(cpu_model, sizeof(cpu_model),
		    "unknown CPU (ID = 0x%x)", cpuid);

	printf(": %s\n", cpu_model);

	printf("%s:", dv->dv_xname);

	switch (cpu_class) {
	case CPU_CLASS_ARMv7:
	case CPU_CLASS_ARMv8:
		if ((ci->ci_ctrl & CPU_CONTROL_DC_ENABLE) == 0)
			printf(" DC disabled");
		else
			printf(" DC enabled");
		if ((ci->ci_ctrl & CPU_CONTROL_IC_ENABLE) == 0)
			printf(" IC disabled");
		else
			printf(" IC enabled");
		break;
	default:
		break;
	}
	if ((ci->ci_ctrl & CPU_CONTROL_WBUF_ENABLE) == 0)
		printf(" WB disabled");
	else
		printf(" WB enabled");

	if (ci->ci_ctrl & CPU_CONTROL_LABT_ENABLE)
		printf(" LABT");
	else
		printf(" EABT");

	if (ci->ci_ctrl & CPU_CONTROL_BPRD_ENABLE)
		printf(" branch prediction enabled");

	printf("\n");

	/* Print cache info. */
	if (arm_picache_line_size == 0 && arm_pdcache_line_size == 0)
		goto skip_pcache;

	if (arm_pcache_unified) {
		printf("%s: %dKB/%dB %d-way %s unified cache\n",
		    dv->dv_xname, arm_pdcache_size / 1024,
		    arm_pdcache_line_size, arm_pdcache_ways,
		    wtnames[arm_pcache_type]);
	} else {
		printf("%s: %dKB(%db/l,%dway) I-cache, %dKB(%db/l,%dway) %s D-cache\n",
		    dv->dv_xname, arm_picache_size / 1024,
		    arm_picache_line_size, arm_picache_ways,
		    arm_pdcache_size / 1024, arm_pdcache_line_size, 
		    arm_pdcache_ways, wtnames[arm_pcache_type]);
	}

 skip_pcache:

	switch (cpu_class) {
	case CPU_CLASS_ARMv7:
	case CPU_CLASS_ARMv8:
		break;
	default:
		printf("%s: %s does not fully support this CPU."
		       "\n", dv->dv_xname, ostype);
		break;
	}
}

#ifdef MULTIPROCESSOR
int
cpu_alloc_idle_pcb(struct cpu_info *ci)
{
	vaddr_t uaddr;
	struct pcb *pcb;
	struct trapframe *tf;

	/*
	 * Generate a kernel stack and PCB (in essence, a u-area) for the
	 * new CPU.
	 */
	uaddr = (vaddr_t)km_alloc(USPACE, &kv_any, &kp_zero, &kd_nowait);
	if (uaddr == 0) {
		printf("%s: unable to allocate idle stack\n",
		    __func__);
		return ENOMEM;
	}
	ci->ci_idle_pcb = pcb = (struct pcb *)uaddr;

	/*
	 * This code is largely derived from cpu_fork(), with which it
	 * should perhaps be shared.
	 */

	/* Copy the pcb */
	*pcb = proc0.p_addr->u_pcb;

	/* Set up the undefined stack for the process. */
	pcb->pcb_un.un_32.pcb32_und_sp = uaddr + USPACE_UNDEF_STACK_TOP;
	pcb->pcb_un.un_32.pcb32_sp = uaddr + USPACE_SVC_STACK_TOP;

#ifdef STACKCHECKS
	/* Fill the undefined stack with a known pattern */
	memset(((u_char *)uaddr) + USPACE_UNDEF_STACK_BOTTOM, 0xdd,
	    (USPACE_UNDEF_STACK_TOP - USPACE_UNDEF_STACK_BOTTOM));
	/* Fill the kernel stack with a known pattern */
	memset(((u_char *)uaddr) + USPACE_SVC_STACK_BOTTOM, 0xdd,
	    (USPACE_SVC_STACK_TOP - USPACE_SVC_STACK_BOTTOM));
#endif	/* STACKCHECKS */

	pcb->pcb_tf = tf =
	    (struct trapframe *)pcb->pcb_un.un_32.pcb32_sp - 1;
	*tf = *proc0.p_addr->u_pcb.pcb_tf;
	return 0;
}
#endif /* MULTIPROCESSOR */

void
intr_barrier(void *ih)
{
	sched_barrier(NULL);
}

/* End of cpu.c */
@


1.35
log
@recognise Cortex A32
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.34 2016/09/26 13:34:11 kettenis Exp $	*/
d51 1
d297 1
a297 1
cpu_alloc_idlepcb(struct cpu_info *ci)
a301 1
	int error;
d307 5
a311 5
	if (uvm_uarea_alloc(&uaddr)) {
		error = uvm_fault_wire(kernel_map, uaddr, uaddr + USPACE,
		    VM_FAULT_WIRE, PROT_READ | PROT_WRITE);
		if (error)
			return error;
d313 1
a313 1
	ci->ci_idlepcb = pcb = (struct pcb *)uaddr;
@


1.34
log
@Remove xscale support.  Properly distinguish between ARMv7 and ARMv8.

ok patrick@@, jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.33 2016/09/24 13:03:47 kettenis Exp $	*/
d143 2
@


1.33
log
@Remove a couple of unsused static inline functions.  Also remove a comparis
of an array to a null pointer that is always false.  Found with clang.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.32 2016/08/14 11:30:54 jsg Exp $	*/
d87 2
a88 2
	CPU_CLASS_XSCALE,
	CPU_CLASS_ARMv7
a97 16
/* Steppings for PXA2[15]0 */
static const char * const pxa2x0_steppings[16] = {
	"step A-0",	"step A-1",	"step B-0",	"step B-1",
	"step B-2",	"step C-0",	"rev 6",	"rev 7",
	"rev 8",	"rev 9",	"rev 10",	"rev 11",
	"rev 12",	"rev 13",	"rev 14",	"rev 15"
};

/* Steppings for PXA270 */
static const char * const pxa27x_steppings[16] = {
	"step A-0",	"step A-1",	"step B-0",	"step B-1",
	"step C-0",	"step ?",	"step ?",	"step C-5",
	"rev 8",	"rev 9",	"rev 10",	"rev 11",
	"rev 12",	"rev 13",	"rev 14",	"rev 15"
};

a105 15
	{ CPU_ID_PXA250A,	CPU_CLASS_XSCALE,	"PXA250",
	  pxa2x0_steppings },
	{ CPU_ID_PXA210A,	CPU_CLASS_XSCALE,	"PXA210",
	  pxa2x0_steppings },
	{ CPU_ID_PXA250B,	CPU_CLASS_XSCALE,	"PXA250",
	  pxa2x0_steppings },
	{ CPU_ID_PXA210B,	CPU_CLASS_XSCALE,	"PXA210",
	  pxa2x0_steppings },
	{ CPU_ID_PXA250C, 	CPU_CLASS_XSCALE,	"PXA250",
	  pxa2x0_steppings },
	{ CPU_ID_PXA27X,	CPU_CLASS_XSCALE,	"PXA27x",
	  pxa27x_steppings },
	{ CPU_ID_PXA210C, 	CPU_CLASS_XSCALE,	"PXA210",
	  pxa2x0_steppings },

d143 1
a143 1
	{ CPU_ID_CORTEX_A35,	CPU_CLASS_ARMv7,	"ARM Cortex A35",
d145 1
a145 1
	{ CPU_ID_CORTEX_A53,	CPU_CLASS_ARMv7,	"ARM Cortex A53",
d147 1
a147 1
	{ CPU_ID_CORTEX_A53_R1,	CPU_CLASS_ARMv7,	"ARM Cortex A53 R1",
d149 1
a149 1
	{ CPU_ID_CORTEX_A57,	CPU_CLASS_ARMv7,	"ARM Cortex A57",
d151 1
a151 1
	{ CPU_ID_CORTEX_A57_R1,	CPU_CLASS_ARMv7,	"ARM Cortex A57 R1",
d153 1
a153 1
	{ CPU_ID_CORTEX_A72,	CPU_CLASS_ARMv7,	"ARM Cortex A72",
d155 1
a155 1
	{ CPU_ID_CORTEX_A72_R1,	CPU_CLASS_ARMv7,	"ARM Cortex A72 R1",
d157 1
a157 1
	{ CPU_ID_CORTEX_A73,	CPU_CLASS_ARMv7,	"ARM Cortex A73",
d168 4
a171 5
const struct cpu_classtab cpu_classes[] = {
	{ "unknown",	NULL },			/* CPU_CLASS_NONE */
	{ "XScale",	"CPU_XSCALE_..." },	/* CPU_CLASS_XSCALE */
	{ "ARMv7",	"CPU_ARMv7" }		/* CPU_CLASS_ARMv7 */

d220 1
a220 1
			    cpu_classes[cpu_class].class_name);
a232 1
	case CPU_CLASS_XSCALE:
d234 1
a281 1
#ifdef CPU_ARMv7
d283 1
a283 5
#endif

#if defined(CPU_XSCALE_PXA2X0)
	case CPU_CLASS_XSCALE:
#endif
d286 2
a287 10
		if (cpu_classes[cpu_class].class_option != NULL)
			printf("%s: %s does not fully support this CPU."
			       "\n", dv->dv_xname, ostype);
		else {
			printf("%s: This kernel does not fully support "
			       "this CPU.\n", dv->dv_xname);
			printf("%s: Recompile with \"options %s\" to "
			       "correct this.\n", dv->dv_xname,
			       cpu_classes[cpu_class].class_option);
		}
a289 1
			       
d291 1
@


1.32
log
@Remove code for Intel 80219/80321 xscale processors used by armish.
Generic xscale support and support for pxa2x0 used by zaurus remains.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.31 2016/07/31 06:24:38 jsg Exp $	*/
a101 10
	"rev 8",	"rev 9",	"rev 10",	"rev 11",
	"rev 12",	"rev 13",	"rev 14",	"rev 15"
};

/* Steppings for PXA255/26x.
 * rev 5: PXA26x B0, rev 6: PXA255 A0
 */
static const char * const pxa255_steppings[16] = {
	"rev 0",	"rev 1",	"rev 2",	"step A-0",
	"rev 4",	"step B-0",	"step A-0",	"rev 7",
@


1.31
log
@Recognise Cortex A35 and Cortex A73.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.30 2016/03/22 23:35:01 patrick Exp $	*/
a97 14
static const char * const i80321_steppings[16] = {
	"step A-0",	"step B-0",	"rev 2",	"rev 3",
	"rev 4",	"rev 5",	"rev 6",	"rev 7",
	"rev 8",	"rev 9",	"rev 10",	"rev 11",
	"rev 12",	"rev 13",	"rev 14",	"rev 15"
};

static const char * const i80219_steppings[16] = {
	"step A-0",	"rev 1",	"rev 2",	"rev 3",
	"rev 4",	"rev 5",	"rev 6",	"rev 7",
	"rev 8",	"rev 9",	"rev 10",	"rev 11",
	"rev 12",	"rev 13",	"rev 14",	"rev 15",
};

a131 14
	{ CPU_ID_80321_400,	CPU_CLASS_XSCALE,	"i80321 400MHz",
	  i80321_steppings },
	{ CPU_ID_80321_600,	CPU_CLASS_XSCALE,	"i80321 600MHz",
	  i80321_steppings },
	{ CPU_ID_80321_400_B0,	CPU_CLASS_XSCALE,	"i80321 400MHz",
	  i80321_steppings },
	{ CPU_ID_80321_600_B0,	CPU_CLASS_XSCALE,	"i80321 600MHz",
	  i80321_steppings },

	{ CPU_ID_80219_400,	CPU_CLASS_XSCALE,	"i80219 400MHz",
	  i80219_steppings },
	{ CPU_ID_80219_600,	CPU_CLASS_XSCALE,	"i80219 600MHz",
	  i80219_steppings },

d328 1
a328 1
#if defined(CPU_XSCALE_80321) || defined(CPU_XSCALE_PXA2X0)
@


1.30
log
@Remove support for ARM11.  This was the last unused and unmaintained
processor in our code.  Now we're left with only armv7 and XScale for
armish and zaurus.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.29 2016/03/22 23:28:02 patrick Exp $	*/
d212 2
d225 2
@


1.29
log
@Remove support for ARM10.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.28 2016/03/22 11:18:17 patrick Exp $	*/
a87 1
	CPU_CLASS_ARM11J,
a174 5
	{ CPU_ID_ARM1136JS,	CPU_CLASS_ARM11J,	"ARM1136J-S",
	  generic_steppings },
	{ CPU_ID_ARM1136JSR1,	CPU_CLASS_ARM11J,	"ARM1136J-S R1",
	  generic_steppings },

a235 1
	{ "ARM11J",	"CPU_ARM11" },		/* CPU_CLASS_ARM11J */
a299 1
	case CPU_CLASS_ARM11J:
a347 3
#ifdef CPU_ARM11
	case CPU_CLASS_ARM11J:
#endif
@


1.28
log
@Remove support for ARM9E.  This is another step in the plan to remove
all unused and unmaintained ARM processors from the past.

ok bmercer@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.27 2016/03/19 09:51:24 patrick Exp $	*/
a86 1
	CPU_CLASS_ARM10E,
a146 5
	{ CPU_ID_ARM1020E,	CPU_CLASS_ARM10E,	"ARM1020E",
	  generic_steppings },
	{ CPU_ID_ARM1022ES,	CPU_CLASS_ARM10E,	"ARM1022E-S",
	  generic_steppings },

a240 1
	{ "ARM10E",	"CPU_ARM10" },		/* CPU_CLASS_ARM10E */
a305 1
	case CPU_CLASS_ARM10E:
a355 3
#ifdef CPU_ARM10
	case CPU_CLASS_ARM10E:
#endif
@


1.27
log
@Remove support for the XScale 80200.  We don't use it, it didn't compile
and the included headers didn't even exist.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.26 2016/03/19 09:47:54 patrick Exp $	*/
a86 2
	CPU_CLASS_ARM9ES,
	CPU_CLASS_ARM9EJS,
a147 9
	{ CPU_ID_ARM926EJS,	CPU_CLASS_ARM9EJS,	"ARM926EJ-S",
	  generic_steppings },
	{ CPU_ID_ARM946ES,	CPU_CLASS_ARM9ES,	"ARM946E-S",
	  generic_steppings },
	{ CPU_ID_ARM966ES,	CPU_CLASS_ARM9ES,	"ARM966E-S",
	  generic_steppings },
	{ CPU_ID_ARM966ESR1,	CPU_CLASS_ARM9ES,	"ARM966E-S",
	  generic_steppings },

a246 2
	{ "ARM9E-S",	"CPU_ARM9E" },		/* CPU_CLASS_ARM9ES */
	{ "ARM9EJ-S",	"CPU_ARM9E" },		/* CPU_CLASS_ARM9EJS */
a312 2
	case CPU_CLASS_ARM9ES:
	case CPU_CLASS_ARM9EJS:
a363 4
#ifdef CPU_ARM9E
	case CPU_CLASS_ARM9ES:
	case CPU_CLASS_ARM9EJS:
#endif
@


1.26
log
@Remove support for IXP425.  This is another architecture that is not
used and has probably never been used at all.  Some included headers
do not even exist.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.25 2016/03/19 09:36:56 patrick Exp $	*/
a101 7
static const char * const xscale_steppings[16] = {
	"step A-0",	"step A-1",	"step B-0",	"step C-0",
	"step D-0",	"rev 5",	"rev 6",	"rev 7",
	"rev 8",	"rev 9",	"rev 10",	"rev 11",
	"rev 12",	"rev 13",	"rev 14",	"rev 15"
};

a163 3
	{ CPU_ID_80200,		CPU_CLASS_XSCALE,	"i80200",
	  xscale_steppings },

d393 1
a393 2
#if defined(CPU_XSCALE_80200) || defined(CPU_XSCALE_80321) || \
    defined(CPU_XSCALE_PXA2X0)
@


1.25
log
@Remove support for StrongARM (SA1) and IXP12x0.  Both are ARMv4 and
are not used by any of the arm platforms.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.24 2016/03/18 13:16:02 jsg Exp $	*/
a148 7
static const char * const ixp425_steppings[16] = {
	"step 0",	"rev 1",	"rev 2",	"rev 3",
	"rev 4",	"rev 5",	"rev 6",	"rev 7",
	"rev 8",	"rev 9",	"rev 10",	"rev 11",
	"rev 12",	"rev 13",	"rev 14",	"rev 15"
};

a202 7
	{ CPU_ID_IXP425_533,	CPU_CLASS_XSCALE,	"IXP425 533MHz",
	  ixp425_steppings },
	{ CPU_ID_IXP425_400,	CPU_CLASS_XSCALE,	"IXP425 400MHz",
	  ixp425_steppings },
	{ CPU_ID_IXP425_266,	CPU_CLASS_XSCALE,	"IXP425 266MHz",
	  ixp425_steppings },

d404 1
a404 1
    defined(CPU_XSCALE_PXA2X0) || defined(CPU_XSCALE_IXP425)
@


1.24
log
@Remove support for ARM9T (armv4t).  Not used by any of the arm platforms.
From Patrick Wildt.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.23 2016/03/18 06:54:21 jsg Exp $	*/
a89 1
	CPU_CLASS_SA1,
a101 30
static const char * const sa110_steppings[16] = {
	"rev 0",	"step J",	"step K",	"step S",
	"step T",	"rev 5",	"rev 6",	"rev 7",
	"rev 8",	"rev 9",	"rev 10",	"rev 11",
	"rev 12",	"rev 13",	"rev 14",	"rev 15"
};

static const char * const sa1100_steppings[16] = {
	"rev 0",	"step B",	"step C",	"rev 3",
	"rev 4",	"rev 5",	"rev 6",	"rev 7",
	"step D",	"step E",	"rev 10"	"step G",
	"rev 12",	"rev 13",	"rev 14",	"rev 15"
};

static const char * const sa1110_steppings[16] = {
	"step A-0",	"rev 1",	"rev 2",	"rev 3",
	"step B-0",	"step B-1",	"step B-2",	"step B-3",
	"step B-4",	"step B-5",	"rev 10",	"rev 11",
	"rev 12",	"rev 13",	"rev 14",	"rev 15"
};

static const char * const ixp12x0_steppings[16] = {
	"(IXP1200 step A)",		"(IXP1200 step B)",
	"rev 2",			"(IXP1200 step C)",
	"(IXP1200 step D)",		"(IXP1240/1250 step A)",
	"(IXP1240 step B)",		"(IXP1250 step B)",
	"rev 8",	"rev 9",	"rev 10",	"rev 11",
	"rev 12",	"rev 13",	"rev 14",	"rev 15"
};

a177 10
	{ CPU_ID_SA110,		CPU_CLASS_SA1,		"SA-110",
	  sa110_steppings },
	{ CPU_ID_SA1100,	CPU_CLASS_SA1,		"SA-1100",
	  sa1100_steppings },
	{ CPU_ID_SA1110,	CPU_CLASS_SA1,		"SA-1110",
	  sa1110_steppings },

	{ CPU_ID_IXP1200,	CPU_CLASS_SA1,		"IXP1200",
	  ixp12x0_steppings },

a284 1
	{ "SA-1",	"CPU_SA1100" },		/* CPU_CLASS_SA1 */
a352 1
	case CPU_CLASS_SA1:
a416 3
#if defined(CPU_SA1100) || defined(CPU_SA1110) || defined(CPU_IXP12X0)
	case CPU_CLASS_SA1:
#endif
@


1.23
log
@Remove support for ARM8, an old armv4 processor without thumb that was
never supported by any arm port and wouldn't have built due to a missing
cpufunc_asm_arm8.S file.

From Patrick Wildt.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.22 2015/09/19 02:13:05 jsg Exp $	*/
a86 1
	CPU_CLASS_ARM9TDMI,
a194 4
	{ CPU_ID_ARM920T,	CPU_CLASS_ARM9TDMI,	"ARM920T",
	  generic_steppings },
	{ CPU_ID_ARM922T,	CPU_CLASS_ARM9TDMI,	"ARM922T",
	  generic_steppings },
a196 2
	{ CPU_ID_ARM940T,	CPU_CLASS_ARM9TDMI,	"ARM940T",
	  generic_steppings },
a202 2
	{ CPU_ID_TI925T,	CPU_CLASS_ARM9TDMI,	"TI ARM925T",
	  generic_steppings },
a322 1
	{ "ARM9TDMI",	NULL },			/* CPU_CLASS_ARM9TDMI */
a391 1
	case CPU_CLASS_ARM9TDMI:
a445 3
#ifdef CPU_ARM9
	case CPU_CLASS_ARM9TDMI:
#endif
@


1.22
log
@intr_barrier(9) for arm
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.21 2015/05/29 05:48:07 jsg Exp $	*/
a82 25

#ifdef CPU_ARM8
	if ((curcpu()->ci_arm_cpuid & CPU_ID_CPU_MASK) == CPU_ID_ARM810) {
		int clock = arm8_clock_config(0, 0);
		char *fclk;
		aprint_normal("%s: ARM810 cp15=%02x", dv->dv_xname, clock);
		aprint_normal(" clock:%s", (clock & 1) ? " dynamic" : "");
		aprint_normal("%s", (clock & 2) ? " sync" : "");
		switch ((clock >> 2) & 3) {
		case 0:
			fclk = "bus clock";
			break;
		case 1:
			fclk = "ref clock";
			break;
		case 3:
			fclk = "pll";
			break;
		default:
			fclk = "illegal";
			break;
		}
		aprint_normal(" fclk source=%s\n", fclk);
 	}
#endif
a86 1
	CPU_CLASS_ARM8,
a195 3
	{ CPU_ID_ARM810,	CPU_CLASS_ARM8,		"ARM810",
	  generic_steppings },

a331 1
	{ "ARM8",	"CPU_ARM8" },		/* CPU_CLASS_ARM8 */
a401 6
	case CPU_CLASS_ARM8:
		if ((ci->ci_ctrl & CPU_CONTROL_IDC_ENABLE) == 0)
			printf(" IDC disabled");
		else
			printf(" IDC enabled");
		break;
a456 3
#ifdef CPU_ARM8
	case CPU_CLASS_ARM8:
#endif
@


1.21
log
@add some more cortex A ids
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.20 2014/11/16 12:30:56 deraadt Exp $	*/
d53 1
d56 1
d584 6
@


1.20
log
@Replace a plethora of historical protection options with just
PROT_NONE, PROT_READ, PROT_WRITE, and PROT_EXEC from mman.h.
PROT_MASK is introduced as the one true way of extracting those bits.
Remove UVM_ADV_* wrapper, using the standard names.
ok doug guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.19 2014/11/14 09:56:06 dlg Exp $	*/
d331 4
d336 12
@


1.19
log
@implement the atomic_foo things on arm.

testing and ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.18 2014/03/29 18:09:28 guenther Exp $	*/
d533 1
a533 1
		    VM_FAULT_WIRE, VM_PROT_READ | VM_PROT_WRITE);
@


1.18
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.17 2013/08/06 23:15:43 jsg Exp $	*/
a565 23

/*
 * eventually it would be interesting to have these functions
 * support the V6/V7+ atomic instructions ldrex/strex if available
 * on the CPU.
 */
void
atomic_setbits_int(volatile unsigned int *uip, unsigned int v)
{
	int oldirqstate;
	oldirqstate = disable_interrupts(I32_bit|F32_bit);
	*uip |= v;
	restore_interrupts(oldirqstate);
}

void
atomic_clearbits_int(volatile unsigned int *uip, unsigned int v)
{
	int oldirqstate;
	oldirqstate = disable_interrupts(I32_bit|F32_bit);
	*uip &= ~v;
	restore_interrupts(oldirqstate);
}
@


1.17
log
@add Cortex A15 R4
ok patrick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.16 2013/03/22 21:32:31 patrick Exp $	*/
d573 1
a573 1
atomic_setbits_int(__volatile unsigned int *uip, unsigned int v)
d582 1
a582 1
atomic_clearbits_int(__volatile unsigned int *uip, unsigned int v)
@


1.16
log
@ARM Cortex A8 was defined twice, we don't need that.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.15 2013/01/18 00:20:20 patrick Exp $	*/
d328 2
@


1.15
log
@Update the ARM CPU ID information. The IDs aren't vendor/product
specific, they are specific to the ARM CPUs themselves.

ok bmercer@@ jsg@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.14 2011/09/20 22:02:10 miod Exp $	*/
a301 2
	  generic_steppings },
	{ CPU_ID_CORTEX_A8,	CPU_CLASS_ARMv7,	"ARM Cortex A8",
@


1.14
log
@Late spring cleaning of the arm code for old dusty bits we do not want to
keep:
- remove bootconfig parameter passing feature (unused).
- unifdef __PROG32 and remove all remains of arm26 code.
- remove ARMFPE support (unused).
- remove support for ARM2, ARM2AS, ARM3, ARM6, ARM7, ARM7TDMI and StrongARM
  processor families, and the related silicon bug workarounds (especially
  the SA-110 STM^ bug).
- remove cpu_functions no longer necessary after previous removals.
- remove ARM32_DISABLE_ALIGNMENT_FAULTS option (unused).
- make FIQ support conditional on option FIQ (unused, but may be eventually).

Discussed with drahn@@ and jasper@@ long ago, I was sitting on this commit for
no good reason.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.13 2011/03/17 21:49:33 jasper Exp $	*/
d299 1
a299 1
	{ CPU_ID_OMAP3430,	CPU_CLASS_ARMv7,	"ARM OMAP3[45]30",
d301 1
a301 1
	{ CPU_ID_OMAP3530,	CPU_CLASS_ARMv7,	"ARM OMAP3530",
d303 27
a329 1
	{ CPU_ID_OMAP3630,	CPU_CLASS_ARMv7,	"ARM OMAP3630/DM3730",
@


1.13
log
@- recognize OMAP3630/DM3730, as found in the beagleboard xM

ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.12 2010/07/01 22:39:08 drahn Exp $	*/
a58 5
#ifdef ARMFPE
#include <machine/bootconfig.h> /* For boot args */
#include <arm/fpe-arm/armfpe.h>
#endif

a70 6
#ifdef ARMFPE
	int usearmfpe;

	usearmfpe = 1;	/* when compiled in, its enabled by default */
#endif

a81 6
	if (curcpu()->ci_arm_cputype == CPU_ID_SA110 &&
	    curcpu()->ci_arm_cpurev < 3) {
		printf("%s: SA-110 with bugged STM^ instruction\n",
		       dv->dv_xname);
	}

a105 32

#ifdef ARMFPE
	/*
	 * Ok now we test for an FPA
	 * At this point no floating point emulator has been installed.
	 * This means any FP instruction will cause undefined exception.
	 * We install a temporay coproc 1 handler which will modify
	 * undefined_test if it is called.
	 * We then try to read the FP status register. If undefined_test
	 * has been decremented then the instruction was not handled by
	 * an FPA so we know the FPA is missing. If undefined_test is
	 * still 1 then we know the instruction was handled by an FPA.
	 * We then remove our test handler and look at the
	 * FP status register for identification.
	 */
 
	/*
	 * Ok if ARMFPE is defined and the boot options request the 
	 * ARM FPE then it will be installed as the FPE.
	 * This is just while I work on integrating the new FPE.
	 * It means the new FPE gets installed if compiled int (ARMFPE
	 * defined) and also gives me a on/off option when I boot in
	 * case the new FPE is causing panics.
	 */


	if (boot_args)
		get_bootconf_option(boot_args, "armfpe",
		    BOOTOPT_TYPE_BOOLEAN, &usearmfpe);
	if (usearmfpe)
		initialise_arm_fpe();
#endif
a109 6
	CPU_CLASS_ARM2,
	CPU_CLASS_ARM2AS,
	CPU_CLASS_ARM3,
	CPU_CLASS_ARM6,
	CPU_CLASS_ARM7,
	CPU_CLASS_ARM7TDMI,
a219 34
	{ CPU_ID_ARM2,		CPU_CLASS_ARM2,		"ARM2",
	  generic_steppings },
	{ CPU_ID_ARM250,	CPU_CLASS_ARM2AS,	"ARM250",
	  generic_steppings },

	{ CPU_ID_ARM3,		CPU_CLASS_ARM3,		"ARM3",
	  generic_steppings },

	{ CPU_ID_ARM600,	CPU_CLASS_ARM6,		"ARM600",
	  generic_steppings },
	{ CPU_ID_ARM610,	CPU_CLASS_ARM6,		"ARM610",
	  generic_steppings },
	{ CPU_ID_ARM620,	CPU_CLASS_ARM6,		"ARM620",
	  generic_steppings },

	{ CPU_ID_ARM700,	CPU_CLASS_ARM7,		"ARM700",
	  generic_steppings },
	{ CPU_ID_ARM710,	CPU_CLASS_ARM7,		"ARM710",
	  generic_steppings },
	{ CPU_ID_ARM7500,	CPU_CLASS_ARM7,		"ARM7500",
	  generic_steppings },
	{ CPU_ID_ARM710A,	CPU_CLASS_ARM7,		"ARM710a",
	  generic_steppings },
	{ CPU_ID_ARM7500FE,	CPU_CLASS_ARM7,		"ARM7500FE",
	  generic_steppings },
	{ CPU_ID_ARM710T,	CPU_CLASS_ARM7TDMI,	"ARM710T",
	  generic_steppings },
	{ CPU_ID_ARM720T,	CPU_CLASS_ARM7TDMI,	"ARM720T",
	  generic_steppings },
	{ CPU_ID_ARM740T8K,	CPU_CLASS_ARM7TDMI, "ARM740T (8 KB cache)",
	  generic_steppings },
	{ CPU_ID_ARM740T4K,	CPU_CLASS_ARM7TDMI, "ARM740T (4 KB cache)",
	  generic_steppings },

a316 6
	{ "ARM2",	"CPU_ARM2" },		/* CPU_CLASS_ARM2 */
	{ "ARM2as",	"CPU_ARM250" },		/* CPU_CLASS_ARM2AS */
	{ "ARM3",	"CPU_ARM3" },		/* CPU_CLASS_ARM3 */
	{ "ARM6",	"CPU_ARM6" },		/* CPU_CLASS_ARM6 */
	{ "ARM7",	"CPU_ARM7" },		/* CPU_CLASS_ARM7 */
	{ "ARM7TDMI",	"CPU_ARM7TDMI" },	/* CPU_CLASS_ARM7TDMI */
d322 1
a322 1
	{ "SA-1",	"CPU_SA110" },		/* CPU_CLASS_SA1 */
a387 3
	case CPU_CLASS_ARM6:
	case CPU_CLASS_ARM7:
	case CPU_CLASS_ARM7TDMI:
a448 18
#ifdef CPU_ARM2
	case CPU_CLASS_ARM2:
#endif
#ifdef CPU_ARM250
	case CPU_CLASS_ARM2AS:
#endif
#ifdef CPU_ARM3
	case CPU_CLASS_ARM3:
#endif
#ifdef CPU_ARM6
	case CPU_CLASS_ARM6:
#endif
#ifdef CPU_ARM7
	case CPU_CLASS_ARM7:
#endif
#ifdef CPU_ARM7TDMI
	case CPU_CLASS_ARM7TDMI:
#endif		
d469 1
a469 2
#if defined(CPU_SA110) || defined(CPU_SA1100) || \
    defined(CPU_SA1110) || defined(CPU_IXP12X0)
@


1.12
log
@CPU id is not enough to tell 3430 from 3530 so change the printed name.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.11 2010/04/22 21:03:17 drahn Exp $	*/
d391 2
@


1.11
log
@De-inline atomic_setbits_int and atomic_clearbits_int, on arm these functions
are emulated by disabling interrupts which requires a lot more header files
than a simple atomic operation should be need. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.10 2009/05/08 02:57:32 drahn Exp $	*/
d388 1
a388 1
	{ CPU_ID_OMAP3430,	CPU_CLASS_ARMv7,	"ARM OMAP3430",
@


1.10
log
@Pieces of arm11 and armv7 support for newer cpus. This is work in progress
and not complete.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.9 2008/09/11 02:38:14 kevlo Exp $	*/
d655 23
@


1.9
log
@add support for arm9e core, taken from NetBSD.
ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.8 2007/07/01 19:09:20 miod Exp $	*/
d171 3
a173 1
	CPU_CLASS_XSCALE
d228 4
a231 4
        "step A-0",     "rev 1",        "rev 2",        "rev 3",
        "rev 4",        "rev 5",        "rev 6",        "rev 7",
        "rev 8",        "rev 9",        "rev 10",       "rev 11",
        "rev 12",       "rev 13",       "rev 14",       "rev 15",
d356 1
a356 1
	{ CPU_ID_80219_400,     CPU_CLASS_XSCALE,       "i80219 400MHz",
d358 1
a358 1
	{ CPU_ID_80219_600,     CPU_CLASS_XSCALE,       "i80219 600MHz",
d371 1
a371 1
	{ CPU_ID_PXA27X,        CPU_CLASS_XSCALE,       "PXA27x",
d383 11
d416 4
a419 1
	{ "XScale",	"CPU_XSCALE_..." }	/* CPU_CLASS_XSCALE */
d496 2
d576 7
@


1.8
log
@Move more fpe-related stuff in #ifdef ARMFPU blocks.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.7 2006/05/29 17:01:42 drahn Exp $	*/
d168 1
d314 2
d399 2
a400 1
	{ "ARM9E-S",	NULL },			/* CPU_CLASS_ARM9ES */
d475 2
d550 4
@


1.7
log
@Add support for i80321 based systems.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.6 2005/12/22 20:11:16 deraadt Exp $	*/
d76 1
d80 1
@


1.6
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.5 2005/12/22 18:44:42 deraadt Exp $	*/
d222 7
d348 5
@


1.5
log
@actual step X-# instead of rev # for pxa270
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.4 2005/05/21 03:27:05 mickey Exp $	*/
d175 1
a175 1
	"rev 12",	"rev 13",	"rev 14",	"rev 15",
d182 1
a182 1
	"rev 12",	"rev 13",	"rev 14",	"rev 15",
d189 1
a189 1
	"rev 12",	"rev 13",	"rev 14",	"rev 15",
d196 1
a196 1
	"rev 12",	"rev 13",	"rev 14",	"rev 15",
d205 1
a205 1
	"rev 12",	"rev 13",	"rev 14",	"rev 15",
d212 1
a212 1
	"rev 12",	"rev 13",	"rev 14",	"rev 15",
d219 1
a219 1
	"rev 12",	"rev 13",	"rev 14",	"rev 15",
d227 1
a227 1
	"rev 12",	"rev 13",	"rev 14",	"rev 15",
d237 1
a237 1
	"rev 12",	"rev 13",	"rev 14",	"rev 15",
d243 1
a243 1
	"step C-0",	"step ?,	"step ?",	"step C-5",
d245 3
a247 2
	"rev 12",	"rev 13",	"rev 14",	"rev 15",
}
d252 1
a252 1
	"rev 12",	"rev 13",	"rev 14",	"rev 15",
d385 1
a385 1
	{ "XScale",	"CPU_XSCALE_..." },	/* CPU_CLASS_XSCALE */
d410 1
a410 1
	"**unknown 15**",
@


1.4
log
@put whole cache info on one line; w/ mods from drahn@@; ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.3 2004/12/30 23:33:28 drahn Exp $	*/
d240 7
d352 1
a352 1
	  pxa255_steppings },
@


1.3
log
@Support for pxa270, at least a running start.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.3 2004/12/30 23:34:24 drahn Exp $	*/
d387 3
a389 3
	"write-through",
	"write-back",
	"write-back",
d392 3
a394 3
	"write-back-locking",		/* XXX XScale-specific? */
	"write-back-locking-A",
	"write-back-locking-B",
d489 1
a489 1
		printf("%s: %dKB/%dB %d-way Instruction cache\n",
d491 3
a493 5
		    arm_picache_line_size, arm_picache_ways);
		printf("%s: %dKB/%dB %d-way %s Data cache\n",
		    dv->dv_xname, arm_pdcache_size / 1024, 
		    arm_pdcache_line_size, arm_pdcache_ways,
		    wtnames[arm_pcache_type]);
@


1.2
log
@fix tags...
@
text
@d1 3
a3 2
/*	$OpenBSD: cpu.c,v 1.1 2004/02/01 05:09:48 drahn Exp $	*/
/*	$NetBSD: cpu.c,v 1.54 2003/10/26 23:11:15 chris Exp $	*/
d41 1
a41 1
 * Probing and configuration for the master cpu
d82 1
a82 1
	/* Get the cpu ID from coprocessor 15 */
d222 1
d230 10
d344 2
@


1.2.2.1
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.1
log
@Arm port, NetBSD codebase stripped down, 32bit only support.
@
text
@d1 2
a2 2
/*	$OpenBSD: cpu.c,v 1.2 2004/01/29 16:17:16 drahn Exp $	*/
/*^I$NetBSD: cpu.c,v 1.54 2003/10/26 23:11:15 chris Exp $^I*/$
@

