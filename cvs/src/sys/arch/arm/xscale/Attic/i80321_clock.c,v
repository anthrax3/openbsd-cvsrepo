head	1.12;
access;
symbols
	OPENBSD_6_0:1.11.0.4
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.11.0.2
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.10.0.4
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.9.0.14
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.9.0.18
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.9.0.16
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.12
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.10
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.8
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.6
	OPENBSD_5_0:1.9.0.4
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.2
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.8.0.12
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.8
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.10
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.6
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.4
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.2
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.7.0.2
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.6.0.2
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.5.0.2
	OPENBSD_4_0_BASE:1.5;
locks; strict;
comment	@ * @;


1.12
date	2016.08.14.11.30.54;	author jsg;	state dead;
branches;
next	1.11;
commitid	3XHAPSr5dKOYN1hw;

1.11
date	2016.01.31.00.14.50;	author jsg;	state Exp;
branches;
next	1.10;
commitid	pbLjedMudUFrVMk6;

1.10
date	2015.06.13.07.16.36;	author jsg;	state Exp;
branches;
next	1.9;
commitid	h4MBZBV4zyNpGQH3;

1.9
date	2010.09.20.06.33.47;	author matthew;	state Exp;
branches;
next	1.8;

1.8
date	2008.02.14.19.53.22;	author drahn;	state Exp;
branches;
next	1.7;

1.7
date	2007.05.21.14.54.35;	author drahn;	state Exp;
branches;
next	1.6;

1.6
date	2007.01.11.07.24.52;	author robert;	state Exp;
branches;
next	1.5;

1.5
date	2006.08.24.21.32.19;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2006.07.20.02.34.04;	author drahn;	state Exp;
branches;
next	1.3;

1.3
date	2006.07.10.16.11.08;	author drahn;	state Exp;
branches;
next	1.2;

1.2
date	2006.07.10.16.04.06;	author drahn;	state Exp;
branches;
next	1.1;

1.1
date	2006.06.27.05.18.25;	author drahn;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Remove code for Intel 80219/80321 xscale processors used by armish.
Generic xscale support and support for pxa2x0 used by zaurus remains.
@
text
@/*	$OpenBSD: i80321_clock.c,v 1.11 2016/01/31 00:14:50 jsg Exp $ */

/*
 * Copyright (c) 2006 Dale Rahn <drahn@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/time.h>
#include <sys/device.h>
#include <sys/timetc.h>
#include <dev/clock_subr.h>

#include <machine/bus.h>
#include <machine/intr.h>

#include <arm/cpufunc.h>

#include <arm/xscale/i80321reg.h>
#include <arm/xscale/i80321var.h>

#define TIMER_FREQUENCY	200000000	/* 200MHz */

static struct evcount clk_count;
static struct evcount stat_count;
static int clk_irq = 129; /* XXX */
static int stat_irq = 130; /* XXX */

uint32_t nextstatevent;
uint32_t nexttickevent;
uint32_t ticks_per_intr;
uint32_t ticks_per_second;
uint32_t lastnow;
uint32_t statvar, statmin;
int i80321_timer_inited;
static inline u_int32_t tmr0_read(void);
static inline void tmr0_write(u_int32_t val);
static inline u_int32_t tcr0_read(void);
static inline void tcr0_write(u_int32_t val);
static inline u_int32_t trr0_read(void);
static inline void trr0_write(u_int32_t val);
static inline u_int32_t tmr1_read(void);
static inline void tmr1_write(u_int32_t val);
static inline u_int32_t tcr1_read(void);
static inline void tcr1_write(u_int32_t val);
static inline u_int32_t trr1_read(void);
static inline void trr1_write(u_int32_t val);
static inline u_int32_t tisr_read(void);
static inline void tisr_write(u_int32_t val);
int i80321_intr(void *frame);

u_int tcr1_get_timecount(struct timecounter *tc);

static struct timecounter tcr1_timecounter = {
	tcr1_get_timecount, NULL, 0xffffffff, 0, "tcr1", 0, NULL
};

todr_chip_handle_t todr_handle;

/* 
 * TMR0 is used in non-reload mode as it is used for both the clock
 * timer and sched timer.
 *
 * The counters on 80321 are count down interrupt on 0, not match
 * register based, so it is not possible to find out how much
 * many interrupts passed while irqs were blocked.
 * also it is not possible to atomically add to the register
 * get get it to precisely fire at a non-fixed interval.
 *
 * To work around this both timers are used, TMR1 is used as a reference
 * clock set to  auto reload with 0xffffffff, however we just ignore the
 * interrupt it would generate. NOTE: does this drop one tick
 * ever wrap? Could the reference timer be used in non-reload mode,
 * where it would just keep counting, and not stop at 0 ?
 *
 * Internally this keeps track of when the next timer should fire
 * and based on that time and the current value of the reference
 * clock a number is written into the timer count register to schedule
 * the next event.
 */


static inline u_int32_t
tmr0_read(void)
{
	u_int32_t ret;
	__asm volatile ("mrc p6, 0, %0, c0, c1, 0" : "=r" (ret));
	return ret;
}

static inline void
tmr0_write(u_int32_t val)
{
	__asm volatile ("mcr p6, 0, %0, c0, c1, 0" :: "r" (val));
}

static inline u_int32_t
tcr0_read(void)
{
	u_int32_t ret;
	__asm volatile ("mrc p6, 0, %0, c2, c1, 0" : "=r" (ret));
	return ret;
}

static inline void
tcr0_write(u_int32_t val)
{
	__asm volatile ("mcr p6, 0, %0, c2, c1, 0" :: "r" (val));
}

static inline u_int32_t
trr0_read(void)
{
	u_int32_t ret;
	__asm volatile ("mrc p6, 0, %0, c4, c1, 0" : "=r" (ret));
	return ret;
}

static inline void
trr0_write(u_int32_t val)
{
	__asm volatile ("mcr p6, 0, %0, c4, c1, 0" :: "r" (val));
}

static inline u_int32_t
tmr1_read(void)
{
	u_int32_t ret;
	__asm volatile ("mrc p6, 0, %0, c1, c1, 0" : "=r" (ret));
	return ret;
}

static inline void
tmr1_write(u_int32_t val)
{
	__asm volatile ("mcr p6, 0, %0, c1, c1, 0" :: "r" (val));
}

inline u_int32_t
tcr1_read(void)
{
	u_int32_t ret;
	__asm volatile ("mrc p6, 0, %0, c3, c1, 0" : "=r" (ret));
	return ret;
}

static inline void
tcr1_write(u_int32_t val)
{
	__asm volatile ("mcr p6, 0, %0, c3, c1, 0" :: "r" (val));
}

static inline u_int32_t
trr1_read(void)
{
	u_int32_t ret;
	__asm volatile ("mrc p6, 0, %0, c5, c1, 0" : "=r" (ret));
	return ret;
}

static inline void
trr1_write(u_int32_t val)
{
	__asm volatile ("mcr p6, 0, %0, c5, c1, 0" :: "r" (val));
}

static inline u_int32_t
tisr_read()
{
	u_int32_t ret;
	__asm volatile ("mrc p6, 0, %0, c6, c1, 0" : "=r" (ret));
	return ret;
}

static inline void
tisr_write(u_int32_t val)
{
	__asm volatile ("mcr p6, 0, %0, c6, c1, 0" :: "r" (val));
}

/* counter counts down not up, so reverse the results by subtracting. */
u_int
tcr1_get_timecount(struct timecounter *tc)
{
	return UINT_MAX - tcr1_read();
}

/*
 * timer 1 is running a timebase counter,
 * ie reload 0xffffffff, reload, interrupt ignored
 * timer 0 will be programmed with the delay until the next
 * event. this is not set for reload 
 */
int
i80321_intr(void *frame)
{
	uint32_t now, r;
	uint32_t nextevent;

	tisr_write(TISR_TMR0);
	now = tcr1_read();

#if 0
	if (lastnow < now) {
		/* rollover, remove the missing 'tick'; 1-0xffffffff, not 0- */
		nextstatevent -=1;
		nexttickevent -=1;
	}
#endif
	while ((int32_t) (now - nexttickevent) < 0) {
		nexttickevent -= ticks_per_intr;
		/* XXX - correct nexttickevent? */
		clk_count.ec_count++;
		hardclock(frame);
	}
	while ((int32_t) (now - nextstatevent) < 0) {
		do {   
			r = random() & (statvar -1);
		} while (r == 0); /* random == 0 not allowed */
		nextstatevent -= statmin + r;
		/* XXX - correct nextstatevent? */
		stat_count.ec_count++;
		statclock(frame);
	}
	if ((now - nexttickevent) < (now - nextstatevent))
		nextevent = now - nexttickevent;
	else
		nextevent = now - nextstatevent;
	if (nextevent < 10 /* XXX */)
		nextevent = 10;
	if (nextevent > ticks_per_intr) {
		/*
		 * If interrupts are blocked too long, like during
		 * the root prompt or ddb, the timer can roll over,
		 * this will allow the system to continue to run
		 * even if time is lost.
		 */
		nextevent = ticks_per_intr;
		nexttickevent = now;
		nextstatevent = now;
	}


	tcr0_write(nextevent);
	tmr0_write(TMRx_ENABLE|TMRx_PRIV|TMRx_CSEL_CORE);

	lastnow = now;
	
	return 1;
}

void
cpu_initclocks()
{
	uint32_t now;
	struct timeval rtctime;
	time_t	first_sec, sec;
	u_int32_t first_tb, second_tb;

	/* would it make sense to have this be 100/1000 to round nicely? */
	/* 100/1000 or 128/1024 ? */
	stathz = 100;
	profhz = 1000;


	ticks_per_second = 200 * 1000000; /* 200 MHz */


	if (todr_handle != NULL && todr_gettime(todr_handle, &rtctime) == 0) {
		int psw;
		int new_tps;
		int tps_diff;

		psw = disable_interrupts(PSR_I);

		first_sec =  rtctime.tv_sec;
		do {
			first_tb = tcr1_read();
			todr_gettime(todr_handle, &rtctime);
			sec = rtctime.tv_sec;
		} while (sec == first_sec);
		first_sec = sec;
		do {
			second_tb = tcr1_read();
			todr_gettime(todr_handle, &rtctime);
			sec = rtctime.tv_sec;
		} while (sec == first_sec);

		new_tps = first_tb - second_tb;
		tps_diff = ticks_per_second - new_tps;
		if (tps_diff < 0)
			tps_diff = -tps_diff;

		/*
		 * only if the calculated time is more than 0.1% use the
		 * new calculate time. Otherwise system with accurate clocks
		 * can be penalized. (error in measurement)
		 */
		if (tps_diff > ticks_per_second/1000)
			ticks_per_second = new_tps;

		restore_interrupts(psw);
	}

	setstatclockrate(stathz);

	ticks_per_intr = ticks_per_second / hz;

	evcount_attach(&clk_count, "clock", &clk_irq);
	evcount_attach(&stat_count, "stat", &stat_irq);

	(void) i80321_intr_establish(ICU_INT_TMR0, IPL_CLOCK, i80321_intr,
	    NULL, NULL);

	now = 0xffffffff;
	nextstatevent = now - ticks_per_intr;
	nexttickevent = now - ticks_per_intr;

	tcr1_write(now);
	trr1_write(now);
	tmr1_write(TMRx_ENABLE|TMRx_RELOAD|TMRx_PRIV|TMRx_CSEL_CORE);

	tcr0_write(now); /* known big value */
	tmr0_write(TMRx_ENABLE|TMRx_PRIV|TMRx_CSEL_CORE);
	tcr0_write(ticks_per_intr);

	tcr1_timecounter.tc_frequency = ticks_per_second;
	tc_init(&tcr1_timecounter);


	i80321_timer_inited = 1;
}

void
delay(u_int usecs)
{
	u_int32_t clock, oclock, delta, delaycnt;
	volatile int j;
	int csec, usec;

		csec = usecs / 10000;
		usec = usecs % 10000;

		delaycnt = (TIMER_FREQUENCY / 100) * csec +
		    (TIMER_FREQUENCY / 100) * usec / 10000;

	if (delaycnt <= 1) /* delay too short spin for a bit */
		for (j = 100; j > 0; j--)
			;

	if (i80321_timer_inited == 0) {
		/* clock isn't initialized yet */
		for (; usecs > 0; usecs--)
			for (j = 100; j > 0; j--)
				;
		return;
	}

	oclock = tcr1_read();

	while(1) {
		clock = tcr1_read();
		/* timer counts down, not up so old - new */
		delta = oclock - clock;
		if (delta > delaycnt)
			break;
	}
}

void
setstatclockrate(int newhz)
{
	int minint, statint;
	int s;

	s = splclock();

	statint = ticks_per_second / newhz;
	/* calculate largest 2^n which is smaller that just over half statint */
	statvar = 0x40000000; /* really big power of two */
	minint = statint / 2 + 100;
	while (statvar > minint)
		statvar >>= 1;

	statmin = statint - (statvar >> 1);

	splx(s);

	/*
	 * XXX this allows the next stat timer to occur then it switches
	 * to the new frequency. Rather than switching instantly.
	 */
}

void
i80321_calibrate_delay(void)
{

	tmr1_write(0);			/* stop timer */
	tisr_write(TISR_TMR1);		/* clear interrupt */
	trr1_write(0xffffffff);	/* reload value */
	tcr1_write(0xffffffff);	/* current value */

	tmr1_write(TMRx_ENABLE|TMRx_RELOAD|TMRx_PRIV|TMRx_CSEL_CORE);
}


/*
 * inittodr:
 *
 *	Initialize time from the time-of-day register.
 */
#define	MINYEAR		2003	/* minimum plausible year */
void
inittodr(time_t base)
{
	time_t deltat;
	struct timeval rtctime;
	struct timespec ts;
	int badbase;

	if (base < (MINYEAR - 1970) * SECYR) {
		printf("WARNING: preposterous time in file system\n");
		/* read the system clock anyway */
		base = (MINYEAR - 1970) * SECYR;
		badbase = 1;
	} else
		badbase = 0;

	if (todr_handle == NULL ||
	    todr_gettime(todr_handle, &rtctime) != 0 ||
	    rtctime.tv_sec == 0) {
		/*
		 * Believe the time in the file system for lack of
		 * anything better, resetting the TODR.
		 */
		rtctime.tv_sec = base;
		rtctime.tv_usec = 0;
		if (todr_handle != NULL && !badbase) {
			printf("WARNING: preposterous clock chip time\n");
			resettodr();
		}
		goto bad;
	}

	ts.tv_sec = rtctime.tv_sec;
	ts.tv_nsec = rtctime.tv_usec * 1000;
	tc_setclock(&ts);

	if (!badbase) {
		/*
		 * See if we gained/lost two or more days; if
		 * so, assume something is amiss.
		 */
		deltat = rtctime.tv_sec - base;
		if (deltat < 0)
			deltat = -deltat;
		if (deltat < 2 * SECDAY)
			return;		/* all is well */

		printf("WARNING: clock %s %ld days\n",
		    rtctime.tv_sec < base ? "lost" : "gained",
		    (long)deltat / SECDAY);
	}
 bad:
	printf("WARNING: CHECK AND RESET THE DATE!\n");
}

/*
 * resettodr:
 *
 *	Reset the time-of-day register with the current time.
 */
void
resettodr(void)
{
	struct timeval rtctime;

	if (time_second == 1)
		return;

	microtime(&rtctime);

	if (todr_handle != NULL &&
	   todr_settime(todr_handle, &rtctime) != 0)
		printf("resettodr: failed to set time\n");
}

@


1.11
log
@Switch from PSR_X_bit and X32_bit PSR macro names to just PSR_X.
This matches FreeBSD and makes things a bit more consistent.
Discussed with Patrick.
@
text
@d1 1
a1 1
/*	$OpenBSD: i80321_clock.c,v 1.10 2015/06/13 07:16:36 jsg Exp $ */
@


1.10
log
@When investigating an uninitialised variable in the armv7 resettodr()
miod pointed out that time_second should be compared to 1 not 0 in the
md resettodr() functions as it is initialised to 1.

ok miod@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i80321_clock.c,v 1.9 2010/09/20 06:33:47 matthew Exp $ */
d288 1
a288 1
		psw = disable_interrupts(I32_bit);
@


1.9
log
@Get rid of evcount's support for arranging counters in a tree
hierarchy.  Everything attached to a single root node anyway, so at
best we had a bush.

"i think it is good" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i80321_clock.c,v 1.8 2008/02/14 19:53:22 drahn Exp $ */
d493 1
a493 1
	if (time_second == 0)
@


1.8
log
@Some armish machines do not have very accurate clock generators,
instead of using a fixed number for the time base, measure the
"accurate" value based on the rtc.
ok kettenis@@ mbalmer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i80321_clock.c,v 1.7 2007/05/21 14:54:35 drahn Exp $ */
d323 2
a324 2
	evcount_attach(&clk_count, "clock", (void *)&clk_irq, &evcount_intr);
	evcount_attach(&stat_count, "stat", (void *)&stat_irq, &evcount_intr);
@


1.7
log
@timecounters for armish.
@
text
@d1 1
a1 1
/*	$OpenBSD: i80321_clock.c,v 1.6 2007/01/11 07:24:52 robert Exp $ */
d72 1
d270 3
d279 1
d282 37
a420 1
todr_chip_handle_t todr_handle;
@


1.6
log
@do not report the clock frequencies on arm becuase there is no
real need to be verbose here; discussed with drahn@@

ok kettenis@@, miod@@, deraadt@@ and others
@
text
@d1 1
a1 1
/*	$OpenBSD: i80321_clock.c,v 1.5 2006/08/24 21:32:19 deraadt Exp $ */
d25 1
d50 21
a71 15
u_int32_t tmr0_read(void);
void tmr0_write(u_int32_t val);
inline u_int32_t tcr0_read(void);
void tcr0_write(u_int32_t val);
u_int32_t trr0_read(void);
void trr0_write(u_int32_t val);
u_int32_t tmr1_read(void);
void tmr1_write(u_int32_t val);
u_int32_t tcr1_read(void);
void tcr1_write(u_int32_t val);
u_int32_t trr1_read(void);
void trr1_write(u_int32_t val);
u_int32_t tisr_read(void);
void tisr_write(u_int32_t val);
int i80321_intr(void *frame);
d96 1
a96 1
u_int32_t
d104 1
a104 1
void
d110 1
a110 1
inline u_int32_t
d118 1
a118 1
void
d124 1
a124 1
u_int32_t
d132 1
a132 1
void
d138 1
a138 1
u_int32_t
d146 1
a146 1
void
d152 1
a152 1
u_int32_t
d160 1
a160 1
void
d166 1
a166 1
u_int32_t
d174 1
a174 1
void
d180 1
a180 1
u_int32_t
d188 1
a188 1
void
d194 7
d299 2
a300 8
	i80321_timer_inited = 1;
}

void
microtime(struct timeval *tvp)
{
	int s, deltacnt;
	u_int32_t counter, expected;
a301 5
	if (i80321_timer_inited == 0) {
		tvp->tv_sec = 0;
		tvp->tv_usec = 0;
		return;
	}
d303 1
a303 21
	s = splhigh();
	counter = tcr1_read();
	expected = nexttickevent;

	*tvp = time;
	splx (s);

	deltacnt = ticks_per_intr -counter + expected;

#if 0
	/* low frequency timer algorithm */
	tvp->tv_usec +_= deltacnt * 1000000ULL / TIMER_FREQUENCY;
#else
	/* high frequency timer algorithm - XXX */
	tvp->tv_usec += deltacnt / (TIMER_FREQUENCY / 1000000ULL);
#endif

        while (tvp->tv_usec >= 1000000) {
		tvp->tv_sec++;
		tvp->tv_usec -= 1000000;
	}
d392 1
d410 2
a411 2
		time.tv_sec = base;
		time.tv_usec = 0;
a416 3
	} else {
		time.tv_sec = rtctime.tv_sec;
		time.tv_usec = rtctime.tv_usec;
d419 4
d428 1
a428 1
		deltat = time.tv_sec - base;
d433 1
d435 1
a435 1
		    time.tv_sec < base ? "lost" : "gained",
d452 1
a452 1
	if (time.tv_sec == 0)
d455 1
a455 2
	rtctime.tv_sec = time.tv_sec;
	rtctime.tv_usec = time.tv_usec;
@


1.5
log
@missing newline in a printf
@
text
@d1 1
a1 1
/*	$OpenBSD: i80321_clock.c,v 1.4 2006/07/20 02:34:04 drahn Exp $ */
a265 2

	printf("clock: hz= %d stathz = %d\n", hz, stathz);
@


1.4
log
@Get rid of the 'nextevent out of bounds' error message, if interrupts
are held off for too long, allow the system to continue running, even
if time is lost.
@
text
@d1 1
a1 1
/*	$OpenBSD: i80321_clock.c,v 1.3 2006/07/10 16:11:08 drahn Exp $ */
d414 1
a414 1
		printf("WARNING: preposterous time in file system");
@


1.3
log
@Remove the error_cnt cacluation, this only makes sense when the supplied
clock speed is extrememly accurate and not evenly divisible. Both of
which is not true on armish.
@
text
@d1 1
a1 1
/*	$OpenBSD: i80321_clock.c,v 1.2 2006/07/10 16:04:06 drahn Exp $ */
d231 6
a236 1
		printf("nextevent out of bounds %x\n", nextevent);
d238 2
@


1.2
log
@As pointed out by miod, cpu_initclocks() can use setstatclockrate(), the
spl() is unnecessary. Also cleanup the extra print and dont bother counting
'tick' interrupts since clock and stat counters exist.
@
text
@d1 1
a1 1
/*	$OpenBSD: i80321_clock.c,v 1.1 2006/06/27 05:18:25 drahn Exp $ */
a46 1
uint32_t stat_error_cnt, tick_error_cnt;
a258 1
	tick_error_cnt = ticks_per_second % hz;
a362 1
	stat_error_cnt = ticks_per_second % stathz;
@


1.1
log
@Rewritten clock driver for 80219/80321, actually manages seperate stat
clock and tick timer and detects missing ticks.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a247 1
	int minint;
a248 2
	uint32_t statint;
	int s;
a249 1
	s = splclock();
a255 8
	statint = ticks_per_second / stathz;
	stat_error_cnt = ticks_per_second % stathz;

	/* calculate largest 2^n which is smaller that just over half statint */
	statvar = 0x40000000;
	minint = statint / 2 + 100;
	while (statvar > minint)
		statvar >>= 1;
d257 1
a257 1
	statmin = statint - (statvar >> 1);
a262 2
	printf("ticks_per_intr %x tick_error_cnt %x statmin %x statvar %x\n",
	 ticks_per_intr, tick_error_cnt, statmin, statvar);
d268 1
a268 2
	    NULL, "tick");

a282 1
	splx(s);
d365 2
a367 1
	/* find largest 2^n which is nearly smaller than statint/2 */
@

