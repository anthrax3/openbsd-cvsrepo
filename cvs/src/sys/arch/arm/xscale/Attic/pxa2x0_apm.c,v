head	1.45;
access;
symbols
	OPENBSD_6_0:1.44.0.4
	OPENBSD_6_0_BASE:1.44
	OPENBSD_5_9:1.44.0.2
	OPENBSD_5_9_BASE:1.44
	OPENBSD_5_8:1.43.0.6
	OPENBSD_5_8_BASE:1.43
	OPENBSD_5_7:1.43.0.2
	OPENBSD_5_7_BASE:1.43
	OPENBSD_5_6:1.42.0.4
	OPENBSD_5_6_BASE:1.42
	OPENBSD_5_5:1.41.0.4
	OPENBSD_5_5_BASE:1.41
	OPENBSD_5_4:1.39.0.4
	OPENBSD_5_4_BASE:1.39
	OPENBSD_5_3:1.39.0.2
	OPENBSD_5_3_BASE:1.39
	OPENBSD_5_2:1.37.0.6
	OPENBSD_5_2_BASE:1.37
	OPENBSD_5_1_BASE:1.37
	OPENBSD_5_1:1.37.0.4
	OPENBSD_5_0:1.37.0.2
	OPENBSD_5_0_BASE:1.37
	OPENBSD_4_9:1.36.0.2
	OPENBSD_4_9_BASE:1.36
	OPENBSD_4_8:1.32.0.2
	OPENBSD_4_8_BASE:1.32
	OPENBSD_4_7:1.31.0.2
	OPENBSD_4_7_BASE:1.31
	OPENBSD_4_6:1.31.0.4
	OPENBSD_4_6_BASE:1.31
	OPENBSD_4_5:1.30.0.2
	OPENBSD_4_5_BASE:1.30
	OPENBSD_4_4:1.28.0.6
	OPENBSD_4_4_BASE:1.28
	OPENBSD_4_3:1.28.0.4
	OPENBSD_4_3_BASE:1.28
	OPENBSD_4_2:1.28.0.2
	OPENBSD_4_2_BASE:1.28
	OPENBSD_4_1:1.27.0.2
	OPENBSD_4_1_BASE:1.27
	OPENBSD_4_0:1.25.0.4
	OPENBSD_4_0_BASE:1.25
	OPENBSD_3_9:1.25.0.2
	OPENBSD_3_9_BASE:1.25
	OPENBSD_3_8:1.15.0.2
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.8.0.2
	OPENBSD_3_7_BASE:1.8;
locks; strict;
comment	@ * @;


1.45
date	2016.09.03.13.37.42;	author guenther;	state dead;
branches;
next	1.44;
commitid	6T3r4QcMFKe3Fo5T;

1.44
date	2016.01.31.00.14.50;	author jsg;	state Exp;
branches;
next	1.43;
commitid	pbLjedMudUFrVMk6;

1.43
date	2014.09.20.09.28.24;	author kettenis;	state Exp;
branches;
next	1.42;
commitid	IFRB8AkvBMXMTAKW;

1.42
date	2014.03.13.03.52.55;	author dlg;	state Exp;
branches;
next	1.41;

1.41
date	2013.12.06.21.03.05;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2013.11.18.20.21.51;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2012.10.17.22.49.27;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2012.10.08.21.47.47;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2011.07.02.22.20.07;	author nicm;	state Exp;
branches;
next	1.36;

1.36
date	2010.09.08.21.18.14;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2010.09.07.16.21.35;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2010.08.30.21.37.52;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2010.08.29.02.02.25;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2010.03.30.17.40.55;	author oga;	state Exp;
branches;
next	1.31;

1.31
date	2009.03.27.16.01.37;	author oga;	state Exp;
branches;
next	1.30;

1.30
date	2009.02.26.19.57.10;	author todd;	state Exp;
branches;
next	1.29;

1.29
date	2009.02.26.17.19.47;	author oga;	state Exp;
branches;
next	1.28;

1.28
date	2007.03.29.18.42.38;	author uwe;	state Exp;
branches;
next	1.27;

1.27
date	2006.12.12.23.14.27;	author dim;	state Exp;
branches;
next	1.26;

1.26
date	2006.10.19.10.55.56;	author tom;	state Exp;
branches;
next	1.25;

1.25
date	2005.12.22.00.42.14;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2005.12.22.00.38.23;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2005.12.20.19.23.57;	author drahn;	state Exp;
branches;
next	1.22;

1.22
date	2005.12.20.02.37.09;	author drahn;	state Exp;
branches;
next	1.21;

1.21
date	2005.12.05.21.13.13;	author uwe;	state Exp;
branches;
next	1.20;

1.20
date	2005.12.02.17.50.51;	author uwe;	state Exp;
branches;
next	1.19;

1.19
date	2005.11.19.02.18.00;	author pedro;	state Exp;
branches;
next	1.18;

1.18
date	2005.11.19.01.59.36;	author aaron;	state Exp;
branches;
next	1.17;

1.17
date	2005.10.31.05.23.32;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2005.10.31.04.56.14;	author drahn;	state Exp;
branches;
next	1.15;

1.15
date	2005.08.12.03.23.02;	author uwe;	state Exp;
branches;
next	1.14;

1.14
date	2005.08.09.21.29.26;	author uwe;	state Exp;
branches;
next	1.13;

1.13
date	2005.04.13.05.40.07;	author uwe;	state Exp;
branches;
next	1.12;

1.12
date	2005.04.11.03.07.09;	author uwe;	state Exp;
branches;
next	1.11;

1.11
date	2005.04.06.01.31.05;	author pascoe;	state Exp;
branches;
next	1.10;

1.10
date	2005.03.30.14.24.39;	author dlg;	state Exp;
branches;
next	1.9;

1.9
date	2005.03.29.23.17.45;	author uwe;	state Exp;
branches;
next	1.8;

1.8
date	2005.03.03.22.55.00;	author uwe;	state Exp;
branches;
next	1.7;

1.7
date	2005.02.28.13.21.17;	author uwe;	state Exp;
branches;
next	1.6;

1.6
date	2005.02.24.21.06.02;	author drahn;	state Exp;
branches;
next	1.5;

1.5
date	2005.02.23.02.08.01;	author uwe;	state Exp;
branches;
next	1.4;

1.4
date	2005.02.22.21.53.03;	author uwe;	state Exp;
branches;
next	1.3;

1.3
date	2005.01.26.06.34.53;	author uwe;	state Exp;
branches;
next	1.2;

1.2
date	2005.01.20.23.34.36;	author uwe;	state Exp;
branches;
next	1.1;

1.1
date	2005.01.19.02.02.34;	author uwe;	state Exp;
branches;
next	;


desc
@@


1.45
log
@Retire zaurus, as it hasn't made the EABI jump and will be permanently broken
shortly when we use the hardware thread register in userland
@
text
@/*	$OpenBSD: pxa2x0_apm.c,v 1.44 2016/01/31 00:14:50 jsg Exp $	*/

/*-
 * Copyright (c) 2001 Alexander Guy.  All rights reserved.
 * Copyright (c) 1998-2001 Michael Shalayeff. All rights reserved.
 * Copyright (c) 1995 John T. Kohl.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/kthread.h>
#include <sys/rwlock.h>
#include <sys/proc.h>
#include <sys/buf.h>
#include <sys/device.h>
#include <sys/fcntl.h>
#include <sys/ioctl.h>
#include <sys/reboot.h>
#include <sys/event.h>

#include <machine/conf.h>
#include <machine/cpu.h>
#include <machine/apmvar.h>

#include <arm/xscale/pxa2x0reg.h>
#include <arm/xscale/pxa2x0var.h>
#include <arm/xscale/pxa2x0_apm.h>
#include <arm/xscale/pxa2x0_gpio.h>
#include <dev/wscons/wsdisplayvar.h>

#include "wsdisplay.h"

#if defined(APMDEBUG)
#define DPRINTF(x)	printf x
#else
#define	DPRINTF(x)	/**/
#endif

#define APM_LOCK(sc)    rw_enter_write(&(sc)->sc_lock);
#define APM_UNLOCK(sc)  rw_exit_write(&(sc)->sc_lock);

struct cfdriver apm_cd = {
	NULL, "apm", DV_DULL
};

#define	APMUNIT(dev)	(minor(dev)&0xf0)
#define	APMDEV(dev)	(minor(dev)&0x0f)
#define APMDEV_NORMAL	0
#define APMDEV_CTL	8

int	apm_userstandbys;
int	apm_suspends;
int	apm_battlow;

/* battery percentage at which we get verbose in our warnings.  This
   value can be changed using sysctl(8), value machdep.apmwarn.
   Setting it to zero kills all warnings */
int	cpu_apmwarn = 10;

void	apm_power_print(struct pxa2x0_apm_softc *, struct apm_power_info *);
void	apm_power_info(struct pxa2x0_apm_softc *, struct apm_power_info *);
void	apm_suspend(struct pxa2x0_apm_softc *);
void	apm_resume(struct pxa2x0_apm_softc *);
int	apm_get_event(struct pxa2x0_apm_softc *, u_int *);
int	apm_handle_event(struct pxa2x0_apm_softc *, u_int);
void	apm_thread_create(void *);
void	apm_thread(void *);

extern int perflevel;
int	freq;
void	pxa2x0_setperf(int speed);
int	pxa2x0_cpuspeed(int *speed);

int	apm_record_event(struct pxa2x0_apm_softc *, u_int);
void	filt_apmrdetach(struct knote *kn);
int	filt_apmread(struct knote *kn, long hint);
int	apmkqfilter(dev_t dev, struct knote *kn);

struct filterops apmread_filtops =
	{ 1, NULL, filt_apmrdetach, filt_apmread};

/*
 * Flags to control kernel display
 *	SCFLAG_NOPRINT:		do not output APM power messages due to
 *				a power change event.
 *
 *	SCFLAG_PCTPRINT:	do not output APM power messages due to
 *				to a power change event unless the battery
 *				percentage changes.
 */

#define SCFLAG_NOPRINT	0x0008000
#define SCFLAG_PCTPRINT	0x0004000
#define SCFLAG_PRINT	(SCFLAG_NOPRINT|SCFLAG_PCTPRINT)

#define	SCFLAG_OREAD 	(1 << 0)
#define	SCFLAG_OWRITE	(1 << 1)
#define	SCFLAG_OPEN	(SCFLAG_OREAD|SCFLAG_OWRITE)

/* This structure must be kept in sync with pxa2x0_apm_asm.S. */
struct pxa2x0_memcfg {
	/* SDRAM refresh */
	u_int32_t mdrefr_high;		/* 0x00 */
	u_int32_t mdrefr_low;		/* 0x04 */
	u_int32_t mdrefr_low2;		/* 0x08 */
	/* Synchronous, static, or VLIO interfaces */
	u_int32_t msc_high[3];		/* 0x0c */
	u_int32_t msc_low[3];		/* 0x18 */
	/* XXX move up */
	u_int32_t mdrefr_91;		/* 0x24 */
};

/* XXX */
#define MDREFR_C3000	(MDREFR_K0DB2 | MDREFR_E1PIN | MDREFR_K1RUN | \
			 MDREFR_K1DB2 | MDREFR_K2DB2 | MDREFR_APD)
#define MSC0_HIGH \
		( 7 << MSC_RRR_SHIFT << 16) | \
		(15 << MSC_RDN_SHIFT << 16) | \
		(15 << MSC_RDF_SHIFT << 16) | \
		(MSC_RT_NONBURST     << 16) | \
		( 2 << MSC_RRR_SHIFT)       | \
		(13 << MSC_RDN_SHIFT)       | \
		(13 << MSC_RDF_SHIFT)       | \
		MSC_RBW	/* PXA271 */        | \
		MSC_RT_NONBURST
#define MSC1_HIGH \
		( 7 << MSC_RRR_SHIFT << 16) | \
		(15 << MSC_RDN_SHIFT << 16) | \
		(15 << MSC_RDF_SHIFT << 16) | \
		(MSC_RT_VLIO         << 16) | \
		( 3 << MSC_RRR_SHIFT)       | \
		( 4 << MSC_RDN_SHIFT)       | \
		(13 << MSC_RDF_SHIFT)       | \
		MSC_RT_VLIO
#define MSC2_HIGH \
		( 7 << MSC_RRR_SHIFT << 16) | \
		(15 << MSC_RDN_SHIFT << 16) | \
		(15 << MSC_RDF_SHIFT << 16) | \
		(MSC_RT_NONBURST     << 16) | \
		( 3 << MSC_RRR_SHIFT)       | \
		( 4 << MSC_RDN_SHIFT)       | \
		(13 << MSC_RDF_SHIFT)       | \
		MSC_RT_VLIO
#define MSC0_LOW \
		( 7 << MSC_RRR_SHIFT << 16) | \
		(15 << MSC_RDN_SHIFT << 16) | \
		(15 << MSC_RDF_SHIFT << 16) | \
		(MSC_RT_NONBURST     << 16) | \
		( 1 << MSC_RRR_SHIFT)       | \
		( 8 << MSC_RDN_SHIFT)       | \
		( 8 << MSC_RDF_SHIFT)       | \
		MSC_RBW	/* PXA271 */        | \
		MSC_RT_NONBURST
#define MSC1_LOW \
		( 7 << MSC_RRR_SHIFT << 16) | \
		(15 << MSC_RDN_SHIFT << 16) | \
		(15 << MSC_RDF_SHIFT << 16) | \
		(MSC_RT_VLIO         << 16) | \
		( 1 << MSC_RRR_SHIFT)       | \
		( 2 << MSC_RDN_SHIFT)       | \
		( 6 << MSC_RDF_SHIFT)       | \
		MSC_RT_VLIO
#define MSC2_LOW \
		( 7 << MSC_RRR_SHIFT << 16) | \
		(15 << MSC_RDN_SHIFT << 16) | \
		(15 << MSC_RDF_SHIFT << 16) | \
		(MSC_RT_NONBURST     << 16) | \
		( 1 << MSC_RRR_SHIFT)       | \
		( 2 << MSC_RDN_SHIFT)       | \
		( 6 << MSC_RDF_SHIFT)       | \
		MSC_RT_VLIO
struct pxa2x0_memcfg pxa2x0_memcfg = {
	(MDREFR_C3000 | 0x030),
	(MDREFR_C3000 | 0x00b),
	(MDREFR_C3000 | 0x017),
	{ MSC0_HIGH, MSC1_HIGH, MSC2_HIGH },
	{ MSC1_LOW, MSC1_LOW, MSC2_LOW },
	(MDREFR_C3000 | 0x013)
};

#define PI2C_RETRY_COUNT	10
/* XXX varies depending on voltage regulator IC. */
#define PI2C_VOLTAGE_LOW	0x13	/* 1.00V */
#define PI2C_VOLTAGE_HIGH	0x1a	/* 1.35V */

void	pxa2x0_pi2c_open(bus_space_tag_t, bus_space_handle_t);
void	pxa2x0_pi2c_close(bus_space_tag_t, bus_space_handle_t);
int	pxa2x0_pi2c_read(bus_space_tag_t, bus_space_handle_t, u_char, u_char *);
int	pxa2x0_pi2c_write(bus_space_tag_t, bus_space_handle_t, u_char, u_char);
int	pxa2x0_pi2c_getvoltage(bus_space_tag_t, bus_space_handle_t, u_char *);
int	pxa2x0_pi2c_setvoltage(bus_space_tag_t, bus_space_handle_t, u_char);
#if 0
void	pxa2x0_pi2c_print(struct pxa2x0_apm_softc *);
#endif

/* XXX used in pxa2x0_apm_asm.S */
bus_space_handle_t pxa2x0_gpio_ioh;
bus_space_handle_t pxa2x0_clkman_ioh;
bus_space_handle_t pxa2x0_memctl_ioh;

/* pxa2x0_apm_asm.S */
void	pxa27x_run_mode(void);
void	pxa27x_fastbus_run_mode(int, u_int32_t);
void	pxa27x_frequency_change(int, int, struct pxa2x0_memcfg *);
void	pxa2x0_cpu_suspend(void);
void	pxa2x0_cpu_resume(void);
void	pxa27x_cpu_speed_high(void);
void	pxa27x_cpu_speed_low(void);
void	pxa27x_cpu_speed_91(void);
void	pxa27x_cpu_speed_208(void);

void
apm_power_print(struct pxa2x0_apm_softc *sc, struct apm_power_info *powerp)
{

	if (powerp->battery_life != APM_BATT_LIFE_UNKNOWN)
		printf("%s: battery life expectancy %d%%\n",
		    sc->sc_dev.dv_xname, powerp->battery_life);

	printf("%s: AC ", sc->sc_dev.dv_xname);
	switch (powerp->ac_state) {
	case APM_AC_OFF:
		printf("off,");
		break;
	case APM_AC_ON:
		printf("on,");
		break;
	case APM_AC_BACKUP:
		printf("backup power,");
		break;
	default:
	case APM_AC_UNKNOWN:
		printf("unknown,");
		break;
	}

	printf(" battery is ");
	switch (powerp->battery_state) {
	case APM_BATT_HIGH:
		printf("high");
		break;
	case APM_BATT_LOW:
		printf("low");
		break;
	case APM_BATT_CRITICAL:
		printf("CRITICAL");
		break;
	case APM_BATT_CHARGING:
		printf("charging");
		break;
	case APM_BATT_UNKNOWN:
		printf("unknown");
		break;
	default:
		printf("undecoded (%x)", powerp->battery_state);
		break;
	}

	printf("\n");
}

void
apm_power_info(struct pxa2x0_apm_softc *sc,
    struct apm_power_info *power)
{

	power->ac_state = APM_AC_UNKNOWN;
	power->battery_state = APM_BATT_UNKNOWN;
	power->battery_life = 0 /* APM_BATT_LIFE_UNKNOWN */;
	power->minutes_left = 0;

	if (sc->sc_power_info != NULL)
		sc->sc_power_info(sc, power);
}

void
apm_suspend(struct pxa2x0_apm_softc *sc)
{
	int s;

#if NWSDISPLAY > 0
	wsdisplay_suspend();
#endif /* NWSDISPLAY > 0 */

	resettodr();

	if (sc->sc_suspend == NULL)
		pxa2x0_wakeup_config(PXA2X0_WAKEUP_ALL, 1);
	else
		sc->sc_suspend(sc);

	s = splhigh();
	config_suspend_all(DVACT_SUSPEND);

	/* XXX
	 * Flag to disk drivers that they should "power down" the disk
	 * when we get to DVACT_POWERDOWN.
	 */
	boothowto |= RB_POWERDOWN;
	config_suspend_all(DVACT_POWERDOWN);
	boothowto &= ~RB_POWERDOWN;

	splx(s);

	pxa2x0_apm_sleep(sc);
}

void
apm_resume(struct pxa2x0_apm_softc *sc)
{
	int s;

	s = splhigh();
	config_suspend_all(DVACT_RESUME);
	splx(s);

	inittodr(0);

	/*
	 * Clear the OTG Peripheral hold after running the pxaudc and pxaohci
	 * ca_activate to re-enable their operation. See 3.8.1.2
	 */
	/* XXX ifdef NPXAUDC > 0 */
	bus_space_write_4(sc->sc_iot, sc->sc_pm_ioh, POWMAN_PSSR, PSSR_OTGPH);

	bufq_restart();

	config_suspend_all(DVACT_WAKEUP);

#if NWSDISPLAY > 0
	wsdisplay_resume();
#endif /* NWSDISPLAY > 0 */
}

int
apm_get_event(struct pxa2x0_apm_softc *sc, u_int *typep)
{

	if (sc->sc_get_event != NULL)
		return (sc->sc_get_event(sc, typep));

	*typep = APM_NOEVENT;
	return (1);
}

int
apm_handle_event(struct pxa2x0_apm_softc *sc, u_int type)
{
	struct	apm_power_info power;
	int	ret = 0;

	switch (type) {
	case APM_NOEVENT:
		ret = 1;
		break;
	case APM_CRIT_SUSPEND_REQ:
		DPRINTF(("suspend required immediately\n"));
#if 0
		/* XXX apmd would make us suspend again after resume. */
		(void)apm_record_event(sc, type);
#endif
		/*
		 * We ignore APM_CRIT_RESUME and just suspend here as usual
		 * to simplify the actual apm_get_event() implementation.
		 */
		apm_suspends++;
		ret = 1;
		break;
	case APM_USER_SUSPEND_REQ:
	case APM_SUSPEND_REQ:
		DPRINTF(("suspend requested\n"));
		if (apm_record_event(sc, type)) {
			DPRINTF(("suspend ourselves\n"));
			apm_suspends++;
		}
		break;
	case APM_POWER_CHANGE:
		DPRINTF(("power status change\n"));
		apm_power_info(sc, &power);
		if (power.battery_life != APM_BATT_LIFE_UNKNOWN &&
		    power.battery_life < cpu_apmwarn &&
		    (sc->sc_flags & SCFLAG_PRINT) != SCFLAG_NOPRINT &&
		    ((sc->sc_flags & SCFLAG_PRINT) != SCFLAG_PCTPRINT ||
		    sc->sc_batt_life != power.battery_life)) {
			sc->sc_batt_life = power.battery_life;
			apm_power_print(sc, &power);
		}
		apm_record_event(sc, type);
		break;
	case APM_BATTERY_LOW:
		DPRINTF(("Battery low!\n"));
		apm_battlow++;
		apm_record_event(sc, type);
		break;
	default:
		DPRINTF(("apm_handle_event: unsupported event, code %d\n",
		    type));
	}

	return (ret);
}

void
apm_thread_create(void *v)
{
	struct pxa2x0_apm_softc *sc = v;

	if (kthread_create(apm_thread, sc, &sc->sc_thread,
	    sc->sc_dev.dv_xname)) {
		/* apm_disconnect(sc); */
		printf("%s: failed to create kernel thread, disabled",
		    sc->sc_dev.dv_xname);
	}
}

void
apm_thread(void *v)
{
	struct pxa2x0_apm_softc *sc = v;
	u_int	type;

	for (;;) {
		APM_LOCK(sc);

		while (1) {
			if (apm_get_event(sc, &type) != 0)
				break;
			if (apm_handle_event(sc, type) != 0)
				break;
		}
		if (apm_suspends || apm_userstandbys /* || apm_battlow*/) {
			apm_suspend(sc);
			apm_resume(sc);
		}
		apm_battlow = apm_suspends = apm_userstandbys = 0;

		APM_UNLOCK(sc);
		tsleep(&lbolt, PWAIT, "apmev", 0);
	}
}

int
apmopen(dev_t dev, int flag, int mode, struct proc *p)
{
	struct pxa2x0_apm_softc *sc;
	int error = 0;

	/* apm0 only */
	if (!apm_cd.cd_ndevs || APMUNIT(dev) != 0 ||
	    !(sc = apm_cd.cd_devs[APMUNIT(dev)]))
		return (ENXIO);

	DPRINTF(("apmopen: dev %d pid %d flag %x mode %x\n",
	    APMDEV(dev), p->p_pid, flag, mode));

	switch (APMDEV(dev)) {
	case APMDEV_CTL:
		if (!(flag & FWRITE)) {
			error = EINVAL;
			break;
		}
		if (sc->sc_flags & SCFLAG_OWRITE) {
			error = EBUSY;
			break;
		}
		sc->sc_flags |= SCFLAG_OWRITE;
		break;
	case APMDEV_NORMAL:
		if (!(flag & FREAD) || (flag & FWRITE)) {
			error = EINVAL;
			break;
		}
		sc->sc_flags |= SCFLAG_OREAD;
		break;
	default:
		error = ENXIO;
		break;
	}
	return (error);
}

int
apmclose(dev_t dev, int flag, int mode, struct proc *p)
{
	struct pxa2x0_apm_softc *sc;

	/* apm0 only */
	if (!apm_cd.cd_ndevs || APMUNIT(dev) != 0 ||
	    !(sc = apm_cd.cd_devs[APMUNIT(dev)]))
		return (ENXIO);

	DPRINTF(("apmclose: pid %d flag %x mode %x\n", p->p_pid, flag, mode));

	switch (APMDEV(dev)) {
	case APMDEV_CTL:
		sc->sc_flags &= ~SCFLAG_OWRITE;
		break;
	case APMDEV_NORMAL:
		sc->sc_flags &= ~SCFLAG_OREAD;
		break;
	}
	return (0);
}

int
apmioctl(dev_t dev, u_long cmd, caddr_t data, int flag, struct proc *p)
{
	struct pxa2x0_apm_softc *sc;
	struct apm_power_info *power;
	int error = 0;

	/* apm0 only */
	if (!apm_cd.cd_ndevs || APMUNIT(dev) != 0 ||
	    !(sc = apm_cd.cd_devs[APMUNIT(dev)]))
		return (ENXIO);

	switch (cmd) {
		/* some ioctl names from linux */
	case APM_IOC_STANDBY:
		if ((flag & FWRITE) == 0)
			error = EBADF;
		else
			apm_userstandbys++;
		break;
	case APM_IOC_SUSPEND:
		if ((flag & FWRITE) == 0)
			error = EBADF;
		else
			apm_suspends++;	/* XXX */
		break;
	case APM_IOC_PRN_CTL:
		if ((flag & FWRITE) == 0)
			error = EBADF;
		else {
			int flag = *(int *)data;
			DPRINTF(( "APM_IOC_PRN_CTL: %d\n", flag ));
			switch (flag) {
			case APM_PRINT_ON:	/* enable printing */
				sc->sc_flags &= ~SCFLAG_PRINT;
				break;
			case APM_PRINT_OFF: /* disable printing */
				sc->sc_flags &= ~SCFLAG_PRINT;
				sc->sc_flags |= SCFLAG_NOPRINT;
				break;
			case APM_PRINT_PCT: /* disable some printing */
				sc->sc_flags &= ~SCFLAG_PRINT;
				sc->sc_flags |= SCFLAG_PCTPRINT;
				break;
			default:
				error = EINVAL;
				break;
			}
		}
		break;
	case APM_IOC_DEV_CTL:
		if ((flag & FWRITE) == 0)
			error = EBADF;
		break;
	case APM_IOC_GETPOWER:
	        power = (struct apm_power_info *)data;
		apm_power_info(sc, power);
		break;
	case APM_IOC_STANDBY_REQ:
		if ((flag & FWRITE) == 0)
			error = EBADF;
		else if (apm_record_event(sc, APM_USER_STANDBY_REQ))
			error = EINVAL; /* ? */
		break;
	case APM_IOC_SUSPEND_REQ:
		if ((flag & FWRITE) == 0)
			error = EBADF;
		else if (apm_record_event(sc, APM_USER_SUSPEND_REQ))
			error = EINVAL; /* ? */
	default:
		error = ENOTTY;
	}

	return (error);
}

int
apm_record_event(struct pxa2x0_apm_softc *sc, u_int type)
{
	static int apm_evindex;

	/* skip if no user waiting */
	if ((sc->sc_flags & SCFLAG_OPEN) == 0)
		return (1);

	apm_evindex++;
	KNOTE(&sc->sc_note, APM_EVENT_COMPOSE(type, apm_evindex));

	return (0);
}

void
filt_apmrdetach(struct knote *kn)
{
	struct pxa2x0_apm_softc *sc =
	    (struct pxa2x0_apm_softc *)kn->kn_hook;

	SLIST_REMOVE(&sc->sc_note, kn, knote, kn_selnext);
}

int
filt_apmread(struct knote *kn, long hint)
{
	/* XXX weird kqueue_scan() semantics */
	if (hint && !kn->kn_data)
		kn->kn_data = (int)hint;

	return (1);
}

int
apmkqfilter(dev_t dev, struct knote *kn)
{
	struct pxa2x0_apm_softc *sc;

	/* apm0 only */
	if (!apm_cd.cd_ndevs || APMUNIT(dev) != 0 ||
	    !(sc = apm_cd.cd_devs[APMUNIT(dev)]))
		return (ENXIO);

	switch (kn->kn_filter) {
	case EVFILT_READ:
		kn->kn_fop = &apmread_filtops;
		break;
	default:
		return (EINVAL);
	}

	kn->kn_hook = (caddr_t)sc;
	SLIST_INSERT_HEAD(&sc->sc_note, kn, kn_selnext);

	return (0);
}

void
pxa2x0_apm_attach_sub(struct pxa2x0_apm_softc *sc)
{

	sc->sc_iot = &pxa2x0_bs_tag;

	if (bus_space_map(sc->sc_iot, PXA2X0_POWMAN_BASE,
	    PXA2X0_POWMAN_SIZE, 0, &sc->sc_pm_ioh)) {
		printf("pxa2x0_apm_attach_sub: failed to map POWMAN\n");
		return;
	}

	rw_init(&sc->sc_lock, "apmlk");

	kthread_create_deferred(apm_thread_create, sc);

	printf("\n");

	if (bus_space_map(sc->sc_iot, PXA2X0_CLKMAN_BASE, PXA2X0_CLKMAN_SIZE,
	    0, &pxa2x0_clkman_ioh)) {
		printf("%s: failed to map CLKMAN\n", sc->sc_dev.dv_xname);
		return;
	}

	if (bus_space_map(sc->sc_iot, PXA2X0_MEMCTL_BASE, PXA2X0_MEMCTL_SIZE,
	    0, &pxa2x0_memctl_ioh)) {
		printf("%s: failed to map MEMCTL\n", sc->sc_dev.dv_xname);
		return;
	}
	sc->sc_memctl_ioh = pxa2x0_memctl_ioh;

	if (bus_space_map(sc->sc_iot, PXA2X0_GPIO_BASE, PXA2X0_GPIO_SIZE,
	    0, &pxa2x0_gpio_ioh)) {
		printf("%s: can't map GPIO\n", sc->sc_dev.dv_xname);
		return;
	}

	/* Clear all reset status flags. */
	bus_space_write_4(sc->sc_iot, sc->sc_pm_ioh, POWMAN_RCSR,
	    RCSR_GPR | RCSR_SMR | RCSR_WDR | RCSR_HWR);
}

void
pxa2x0_wakeup_config(u_int wsrc, int enable)
{
	struct pxa2x0_apm_softc *sc;
	u_int32_t prer;
	u_int32_t pfer;
	u_int32_t pkwr;

	if (apm_cd.cd_ndevs < 1 || apm_cd.cd_devs[0] == NULL)
		return;
	sc = apm_cd.cd_devs[0];

	prer = pfer = pkwr = 0;

	if ((wsrc & PXA2X0_WAKEUP_POWERON) != 0) {
		prer |= (1<<0);
		pfer |= (1<<0);
		pkwr |= (1<<12); /* XXX */
	}

	if ((wsrc & PXA2X0_WAKEUP_GPIORST) != 0)
		pfer |= (1<<1);
	if ((wsrc & PXA2X0_WAKEUP_SD) != 0)
		prer |= (1<<9);
	if ((wsrc & PXA2X0_WAKEUP_RC) != 0)
		prer |= (1<<13);
	if ((wsrc & PXA2X0_WAKEUP_SYNC) != 0)
		pkwr |= (1<<1);
	if ((wsrc & PXA2X0_WAKEUP_KEYNS0) != 0)
		prer |= (1<<12);
	if ((wsrc & PXA2X0_WAKEUP_KEYNS1) != 0)
		pkwr |= (1<<2);
	if ((wsrc & PXA2X0_WAKEUP_KEYNS2) != 0)
		pkwr |= (1<<9);
	if ((wsrc & PXA2X0_WAKEUP_KEYNS3) != 0)
		pkwr |= (1<<3);
	if ((wsrc & PXA2X0_WAKEUP_KEYNS4) != 0)
		pkwr |= (1<<4);
	if ((wsrc & PXA2X0_WAKEUP_KEYNS5) != 0)
		pkwr |= (1<<6);
	if ((wsrc & PXA2X0_WAKEUP_KEYNS6) != 0)
		pkwr |= (1<<7);
	if ((wsrc & PXA2X0_WAKEUP_CF0) != 0)
		pkwr |= (1<<11);
	if ((wsrc & PXA2X0_WAKEUP_CF1) != 0)
		pkwr |= (1<<10);
	if ((wsrc & PXA2X0_WAKEUP_USBD) != 0)
		prer |= (1<<24);

	if ((wsrc & PXA2X0_WAKEUP_LOCKSW) != 0) {
		prer |= (1<<15);
		pfer |= (1<<15);
	}

	if ((wsrc & PXA2X0_WAKEUP_JACKIN) != 0) {
		prer |= (1<<23);
		pfer |= (1<<23);
	}

	if ((wsrc & PXA2X0_WAKEUP_CHRGFULL) != 0)
		pkwr |= (1<<18);
	if ((wsrc & PXA2X0_WAKEUP_RTC) != 0)
		prer |= (1<<31);

	if (enable) {
		sc->sc_wakeon |= wsrc;
		prer |= bus_space_read_4(sc->sc_iot, sc->sc_pm_ioh,
		    POWMAN_PRER);
		pfer |= bus_space_read_4(sc->sc_iot, sc->sc_pm_ioh,
		    POWMAN_PFER);
		pkwr |= bus_space_read_4(sc->sc_iot, sc->sc_pm_ioh,
		    POWMAN_PKWR);
	} else {
		sc->sc_wakeon &= ~wsrc;
		prer = bus_space_read_4(sc->sc_iot, sc->sc_pm_ioh,
		    POWMAN_PRER) & ~prer;
		pfer = bus_space_read_4(sc->sc_iot, sc->sc_pm_ioh,
		    POWMAN_PFER) & ~pfer;
		pkwr = bus_space_read_4(sc->sc_iot, sc->sc_pm_ioh,
		    POWMAN_PKWR) & ~pkwr;
	}

	bus_space_write_4(sc->sc_iot, sc->sc_pm_ioh, POWMAN_PKWR, pkwr);
	bus_space_write_4(sc->sc_iot, sc->sc_pm_ioh, POWMAN_PRER, prer);
	bus_space_write_4(sc->sc_iot, sc->sc_pm_ioh, POWMAN_PFER, pfer);
	bus_space_write_4(sc->sc_iot, sc->sc_pm_ioh, POWMAN_PWER,
	    prer | pfer);
}

u_int
pxa2x0_wakeup_status(void)
{
	struct pxa2x0_apm_softc *sc;
	u_int32_t rv;
	u_int	wsrc;

	if (apm_cd.cd_ndevs < 1 || apm_cd.cd_devs[0] == NULL)
		return (0);

	sc = apm_cd.cd_devs[0];
	wsrc = 0;

	rv = bus_space_read_4(sc->sc_iot, sc->sc_pm_ioh, POWMAN_PEDR);
	if ((rv & (1<<0)) != 0)
		wsrc |= PXA2X0_WAKEUP_POWERON;
	if ((rv & (1<<1)) != 0)
		wsrc |= PXA2X0_WAKEUP_GPIORST;
	if ((rv & (1<<9)) != 0)
		wsrc |= PXA2X0_WAKEUP_SD;
	if ((rv & (1<<12)) != 0)
		wsrc |= PXA2X0_WAKEUP_KEYNS0;
	if ((rv & (1<<13)) != 0)
		wsrc |= PXA2X0_WAKEUP_RC;
	if ((rv & (1<<15)) != 0)
		wsrc |= PXA2X0_WAKEUP_LOCKSW;
	if ((rv & (1<<23)) != 0)
		wsrc |= PXA2X0_WAKEUP_JACKIN;
	if ((rv & (1<<24)) != 0)
		wsrc |= PXA2X0_WAKEUP_USBD;
	if ((rv & (1<<31)) != 0)
		wsrc |= PXA2X0_WAKEUP_RTC;

	rv = bus_space_read_4(sc->sc_iot, sc->sc_pm_ioh, POWMAN_PKSR);
	if ((rv & (1<<1)) != 0)
		wsrc |= PXA2X0_WAKEUP_SYNC;
	if ((rv & (1<<2)) != 0)
		wsrc |= PXA2X0_WAKEUP_KEYNS1;
	if ((rv & (1<<9)) != 0)
		wsrc |= PXA2X0_WAKEUP_KEYNS2;
	if ((rv & (1<<3)) != 0)
		wsrc |= PXA2X0_WAKEUP_KEYNS3;
	if ((rv & (1<<4)) != 0)
		wsrc |= PXA2X0_WAKEUP_KEYNS4;
	if ((rv & (1<<6)) != 0)
		wsrc |= PXA2X0_WAKEUP_KEYNS5;
	if ((rv & (1<<7)) != 0)
		wsrc |= PXA2X0_WAKEUP_KEYNS6;
	if ((rv & (1<<10)) != 0)
		wsrc |= PXA2X0_WAKEUP_CF1;
	if ((rv & (1<<11)) != 0)
		wsrc |= PXA2X0_WAKEUP_CF0;
	if ((rv & (1<<12)) != 0)
		wsrc |= PXA2X0_WAKEUP_POWERON;
	if ((rv & (1<<18)) != 0)
		wsrc |= PXA2X0_WAKEUP_CHRGFULL;

	return (wsrc);
}

struct pxa2x0_sleep_data {
	/* OS timer registers */
	u_int32_t sd_osmr0, sd_osmr1, sd_osmr2, sd_osmr3;
	u_int32_t sd_oscr0;
	u_int32_t sd_osmr4, sd_osmr5;
	u_int32_t sd_oscr4;
	u_int32_t sd_omcr4, sd_omcr5;
	u_int32_t sd_oier;
	/* GPIO registers */
	u_int32_t sd_gpdr0, sd_gpdr1, sd_gpdr2, sd_gpdr3;
	u_int32_t sd_grer0, sd_grer1, sd_grer2, sd_grer3;
	u_int32_t sd_gfer0, sd_gfer1, sd_gfer2, sd_gfer3;
	u_int32_t sd_gafr0_l, sd_gafr1_l, sd_gafr2_l, sd_gafr3_l;
	u_int32_t sd_gafr0_u, sd_gafr1_u, sd_gafr2_u, sd_gafr3_u;
	u_int32_t sd_gplr0, sd_gplr1, sd_gplr2, sd_gplr3;
	/* Interrupt controller registers */
	u_int32_t sd_iclr;
	u_int32_t sd_icmr;
	u_int32_t sd_iccr;
	/* Memory controller registers */
	u_int32_t sd_mecr;
	u_int32_t sd_mcmem0, sd_mcmem1;
	u_int32_t sd_mcatt0, sd_mcatt1;
	u_int32_t sd_mcio0, sd_mcio1;
	/* Clocks manager registers */
	u_int32_t sd_cken;
};

void
pxa2x0_apm_sleep(struct pxa2x0_apm_softc *sc)
{
	struct pxa2x0_sleep_data sd;
	bus_space_handle_t ost_ioh;
	int save;
	u_int32_t rv;

	ost_ioh = (bus_space_handle_t)0;
	if (bus_space_map(sc->sc_iot, PXA2X0_OST_BASE, PXA2X0_OST_SIZE, 0,
	    &ost_ioh)) {
		printf("pxa2x0_apm_sleep: can't map OST\n");
		goto out;
	}

	save = disable_interrupts(PSR_I|PSR_F);

	sd.sd_oscr0 = bus_space_read_4(sc->sc_iot, ost_ioh, OST_OSCR0);
	sd.sd_oscr4 = bus_space_read_4(sc->sc_iot, ost_ioh, OST_OSCR4);
	sd.sd_omcr4 = bus_space_read_4(sc->sc_iot, ost_ioh, OST_OMCR4);
	sd.sd_omcr5 = bus_space_read_4(sc->sc_iot, ost_ioh, OST_OMCR5);
	sd.sd_osmr0 = bus_space_read_4(sc->sc_iot, ost_ioh, OST_OSMR0);
	sd.sd_osmr1 = bus_space_read_4(sc->sc_iot, ost_ioh, OST_OSMR1);
	sd.sd_osmr2 = bus_space_read_4(sc->sc_iot, ost_ioh, OST_OSMR2);
	sd.sd_osmr3 = bus_space_read_4(sc->sc_iot, ost_ioh, OST_OSMR3);
	sd.sd_osmr4 = bus_space_read_4(sc->sc_iot, ost_ioh, OST_OSMR4);
	sd.sd_osmr5 = bus_space_read_4(sc->sc_iot, ost_ioh, OST_OSMR5);
	sd.sd_oier = bus_space_read_4(sc->sc_iot, ost_ioh, OST_OIER);

	/* Bring the PXA27x into 416MHz turbo mode. */
        if ((cputype & ~CPU_ID_XSCALE_COREREV_MASK) == CPU_ID_PXA27X &&
	    bus_space_read_4(sc->sc_iot, pxa2x0_clkman_ioh, CLKMAN_CCCR) !=
	    (CCCR_A | CCCR_TURBO_X2 | CCCR_RUN_X16)) {
#if 0
		pxa27x_cpu_speed_high();
#else
#define CLKCFG_T		(1<<0)	/* turbo */
#define CLKCFG_F		(1<<1)	/* frequency change */
#define CLKCFG_B		(1<<3)	/* fast-bus */
		pxa27x_frequency_change(CCCR_A | CCCR_TURBO_X2 |
		    CCCR_RUN_X16, CLKCFG_B | CLKCFG_F | CLKCFG_T,
		    &pxa2x0_memcfg);
#endif
		delay(500000); /* XXX */
	}

suspend_again:
	/* Clear wake-up status. */
	bus_space_write_4(sc->sc_iot, sc->sc_pm_ioh, POWMAN_PEDR,
	    0xffffffff);
	bus_space_write_4(sc->sc_iot, sc->sc_pm_ioh, POWMAN_PKSR,
	    0xffffffff);

	/* XXX control battery charging in sleep mode. */

	/* XXX schedule RTC alarm to check the battery, or schedule
	   XXX wake-up shortly before an already programmed alarm? */

	pxa27x_run_mode();
#define MDREFR_LOW		(MDREFR_C3000 | 0x00b)
	pxa27x_fastbus_run_mode(0, MDREFR_LOW);
	delay(1);
#if 1
	pxa27x_cpu_speed_91();
#else
	pxa27x_frequency_change(CCCR_TURBO_X1 | CCCR_RUN_X7, CLKCFG_F,
	    &pxa2x0_memcfg);
#endif
	pxa2x0_pi2c_setvoltage(sc->sc_iot, sc->sc_pm_ioh, PI2C_VOLTAGE_LOW);

	sd.sd_gpdr0 = bus_space_read_4(sc->sc_iot, pxa2x0_gpio_ioh, GPIO_GPDR0);
	sd.sd_gpdr1 = bus_space_read_4(sc->sc_iot, pxa2x0_gpio_ioh, GPIO_GPDR1);
	sd.sd_gpdr2 = bus_space_read_4(sc->sc_iot, pxa2x0_gpio_ioh, GPIO_GPDR2);
	sd.sd_gpdr3 = bus_space_read_4(sc->sc_iot, pxa2x0_gpio_ioh, GPIO_GPDR3);

	sd.sd_grer0 = bus_space_read_4(sc->sc_iot, pxa2x0_gpio_ioh, GPIO_GRER0);
	sd.sd_grer1 = bus_space_read_4(sc->sc_iot, pxa2x0_gpio_ioh, GPIO_GRER1);
	sd.sd_grer2 = bus_space_read_4(sc->sc_iot, pxa2x0_gpio_ioh, GPIO_GRER2);
	sd.sd_grer3 = bus_space_read_4(sc->sc_iot, pxa2x0_gpio_ioh, GPIO_GRER3);

	sd.sd_gfer0 = bus_space_read_4(sc->sc_iot, pxa2x0_gpio_ioh, GPIO_GFER0);
	sd.sd_gfer1 = bus_space_read_4(sc->sc_iot, pxa2x0_gpio_ioh, GPIO_GFER1);
	sd.sd_gfer2 = bus_space_read_4(sc->sc_iot, pxa2x0_gpio_ioh, GPIO_GFER2);
	sd.sd_gfer3 = bus_space_read_4(sc->sc_iot, pxa2x0_gpio_ioh, GPIO_GFER3);

	sd.sd_gafr0_l = bus_space_read_4(sc->sc_iot, pxa2x0_gpio_ioh, GPIO_GAFR0_L);
	sd.sd_gafr1_l = bus_space_read_4(sc->sc_iot, pxa2x0_gpio_ioh, GPIO_GAFR1_L);
	sd.sd_gafr2_l = bus_space_read_4(sc->sc_iot, pxa2x0_gpio_ioh, GPIO_GAFR2_L);
	sd.sd_gafr3_l = bus_space_read_4(sc->sc_iot, pxa2x0_gpio_ioh, GPIO_GAFR3_L);

	sd.sd_gafr0_u = bus_space_read_4(sc->sc_iot, pxa2x0_gpio_ioh, GPIO_GAFR0_U);
	sd.sd_gafr1_u = bus_space_read_4(sc->sc_iot, pxa2x0_gpio_ioh, GPIO_GAFR1_U);
	sd.sd_gafr2_u = bus_space_read_4(sc->sc_iot, pxa2x0_gpio_ioh, GPIO_GAFR2_U);
	sd.sd_gafr3_u = bus_space_read_4(sc->sc_iot, pxa2x0_gpio_ioh, GPIO_GAFR3_U);

	sd.sd_gplr0 = bus_space_read_4(sc->sc_iot, pxa2x0_gpio_ioh, GPIO_GPLR0);
	sd.sd_gplr1 = bus_space_read_4(sc->sc_iot, pxa2x0_gpio_ioh, GPIO_GPLR1);
	sd.sd_gplr2 = bus_space_read_4(sc->sc_iot, pxa2x0_gpio_ioh, GPIO_GPLR2);
	sd.sd_gplr3 = bus_space_read_4(sc->sc_iot, pxa2x0_gpio_ioh, GPIO_GPLR3);

	sd.sd_iclr = read_icu(INTCTL_ICLR);
	sd.sd_icmr = read_icu(INTCTL_ICMR);
	sd.sd_iccr = read_icu(INTCTL_ICCR);
	write_icu(INTCTL_ICMR, 0);

	sd.sd_mecr = bus_space_read_4(sc->sc_iot, pxa2x0_memctl_ioh,
	    MEMCTL_MECR);
	sd.sd_mcmem0 = bus_space_read_4(sc->sc_iot, pxa2x0_memctl_ioh,
	    MEMCTL_MCMEM(0));
	sd.sd_mcmem1 = bus_space_read_4(sc->sc_iot, pxa2x0_memctl_ioh,
	    MEMCTL_MCMEM(1));
	sd.sd_mcatt0 = bus_space_read_4(sc->sc_iot, pxa2x0_memctl_ioh,
	    MEMCTL_MCATT(0));
	sd.sd_mcatt1 = bus_space_read_4(sc->sc_iot, pxa2x0_memctl_ioh,
	    MEMCTL_MCATT(1));
	sd.sd_mcio0 = bus_space_read_4(sc->sc_iot, pxa2x0_memctl_ioh,
	    MEMCTL_MCIO(0));
	sd.sd_mcio1 = bus_space_read_4(sc->sc_iot, pxa2x0_memctl_ioh,
	    MEMCTL_MCIO(1));

	sd.sd_cken = bus_space_read_4(sc->sc_iot, pxa2x0_clkman_ioh,
	    CLKMAN_CKEN);

	/*
	 * Stop clocks to all units except to the memory controller, and
	 * to the keypad controller if it is enabled as a wake-up source.
	 */
	rv = CKEN_MEM;
	if ((sc->sc_wakeon & PXA2X0_WAKEUP_KEYNS_ALL) != 0)
		rv |= CKEN_KEY;
	bus_space_write_4(sc->sc_iot, pxa2x0_clkman_ioh, CLKMAN_CKEN, rv);

	/* Disable nRESET_OUT. */
	rv = bus_space_read_4(sc->sc_iot, sc->sc_pm_ioh, POWMAN_PSLR);
#define  PSLR_SL_ROD	(1<<20)
	bus_space_write_4(sc->sc_iot, sc->sc_pm_ioh, POWMAN_PSLR,
	    rv | PSLR_SL_ROD);

	/* Clear all reset status flags. */
	bus_space_write_4(sc->sc_iot, sc->sc_pm_ioh, POWMAN_RCSR,
	    RCSR_GPR | RCSR_SMR | RCSR_WDR | RCSR_HWR);

	/* Stop 3/13MHz oscillator; do not float PCMCIA and chip-selects. */
	rv = PCFR_OPDE;
        if ((cputype & ~CPU_ID_XSCALE_COREREV_MASK) == CPU_ID_PXA27X)
		/* Enable nRESET_GPIO as a GPIO reset input. */
		rv |= PCFR_GPR_EN;
	bus_space_write_4(sc->sc_iot, sc->sc_pm_ioh, POWMAN_PCFR, rv);

	/* XXX C3000 */
#define	GPIO_G0_STROBE_BIT		0x0f800000
#define	GPIO_G1_STROBE_BIT		0x00100000
#define	GPIO_G2_STROBE_BIT		0x01000000
#define	GPIO_G3_STROBE_BIT		0x00041880
#define	GPIO_KEY_STROBE0		88
	bus_space_write_4(sc->sc_iot, sc->sc_pm_ioh, POWMAN_PGSR0,
	    0x00144018);
	bus_space_write_4(sc->sc_iot, sc->sc_pm_ioh, POWMAN_PGSR1,
	    0x00ef0000);
	bus_space_write_4(sc->sc_iot, sc->sc_pm_ioh, POWMAN_PGSR2,
	    0x0121c000);
	bus_space_write_4(sc->sc_iot, sc->sc_pm_ioh, POWMAN_PGSR3,
	    0x00600000);
	bus_space_write_4(sc->sc_iot, sc->sc_pm_ioh, POWMAN_PGSR0,
	    0x00144018 & ~GPIO_G0_STROBE_BIT);
	bus_space_write_4(sc->sc_iot, sc->sc_pm_ioh, POWMAN_PGSR1,
	    0x00ef0000 & ~GPIO_G1_STROBE_BIT);
	bus_space_write_4(sc->sc_iot, sc->sc_pm_ioh, POWMAN_PGSR2,
	    0x0121c000 & ~GPIO_G2_STROBE_BIT);
	bus_space_write_4(sc->sc_iot, sc->sc_pm_ioh, POWMAN_PGSR3,
	    0x00600000 & ~GPIO_G3_STROBE_BIT);
	bus_space_write_4(sc->sc_iot, sc->sc_pm_ioh, POWMAN_PGSR2,
	    (0x0121c000 & ~GPIO_G2_STROBE_BIT) |
	    GPIO_BIT(GPIO_KEY_STROBE0));

	/* C3000 */
#define GPIO_EXT_BUS_READY	18
	pxa2x0_gpio_set_function(GPIO_EXT_BUS_READY, GPIO_SET | GPIO_OUT);
	bus_space_write_4(sc->sc_iot, pxa2x0_gpio_ioh, GPIO_GPDR0, 0xd01c4418);
	bus_space_write_4(sc->sc_iot, pxa2x0_gpio_ioh, GPIO_GPDR1, 0xfcefbd21);
	bus_space_write_4(sc->sc_iot, pxa2x0_gpio_ioh, GPIO_GPDR2, 0x13a5ffff);
	bus_space_write_4(sc->sc_iot, pxa2x0_gpio_ioh, GPIO_GPDR3, 0x01e3e10c);

	bus_space_write_4(sc->sc_iot, sc->sc_pm_ioh, POWMAN_PSPR,
	    (u_int32_t)&pxa2x0_cpu_resume - 0xc0200000 + 0xa0200000);

	pxa2x0_cpu_suspend();

	bus_space_write_4(sc->sc_iot, sc->sc_pm_ioh, POWMAN_PSPR, 0);

	pxa2x0_clkman_config(CKEN_SSP|CKEN_PWM0|CKEN_PWM1, 1);
	pxa2x0_clkman_config(CKEN_KEY, 0);

#if 1
	/* Clear all GPIO interrupt sources. */
	bus_space_write_4(sc->sc_iot, pxa2x0_gpio_ioh, GPIO_GEDR0, 0xffffffff);
	bus_space_write_4(sc->sc_iot, pxa2x0_gpio_ioh, GPIO_GEDR1, 0xffffffff);
	bus_space_write_4(sc->sc_iot, pxa2x0_gpio_ioh, GPIO_GEDR2, 0xffffffff);
#endif

	bus_space_write_4(sc->sc_iot, pxa2x0_gpio_ioh, GPIO_GPDR0, sd.sd_gpdr0);
	bus_space_write_4(sc->sc_iot, pxa2x0_gpio_ioh, GPIO_GPDR1, sd.sd_gpdr1);
	bus_space_write_4(sc->sc_iot, pxa2x0_gpio_ioh, GPIO_GPDR2, sd.sd_gpdr2);
	bus_space_write_4(sc->sc_iot, pxa2x0_gpio_ioh, GPIO_GRER0, sd.sd_grer0);
	bus_space_write_4(sc->sc_iot, pxa2x0_gpio_ioh, GPIO_GRER1, sd.sd_grer1);
	bus_space_write_4(sc->sc_iot, pxa2x0_gpio_ioh, GPIO_GRER2, sd.sd_grer2);
	bus_space_write_4(sc->sc_iot, pxa2x0_gpio_ioh, GPIO_GFER0, sd.sd_gfer0);
	bus_space_write_4(sc->sc_iot, pxa2x0_gpio_ioh, GPIO_GFER1, sd.sd_gfer1);
	bus_space_write_4(sc->sc_iot, pxa2x0_gpio_ioh, GPIO_GFER2, sd.sd_gfer2);
	bus_space_write_4(sc->sc_iot, pxa2x0_gpio_ioh, GPIO_GAFR0_L, sd.sd_gafr0_l);
	bus_space_write_4(sc->sc_iot, pxa2x0_gpio_ioh, GPIO_GAFR1_L, sd.sd_gafr1_l);
	bus_space_write_4(sc->sc_iot, pxa2x0_gpio_ioh, GPIO_GAFR2_L, sd.sd_gafr2_l);
	bus_space_write_4(sc->sc_iot, pxa2x0_gpio_ioh, GPIO_GAFR0_U, sd.sd_gafr0_u);
	bus_space_write_4(sc->sc_iot, pxa2x0_gpio_ioh, GPIO_GAFR1_U, sd.sd_gafr1_u);
	bus_space_write_4(sc->sc_iot, pxa2x0_gpio_ioh, GPIO_GAFR2_U, sd.sd_gafr2_u);
	bus_space_write_4(sc->sc_iot, pxa2x0_gpio_ioh, GPIO_GPSR0, sd.sd_gplr0 &
	    sd.sd_gpdr0);
	bus_space_write_4(sc->sc_iot, pxa2x0_gpio_ioh, GPIO_GPSR1, sd.sd_gplr1 &
	    sd.sd_gpdr1);
	bus_space_write_4(sc->sc_iot, pxa2x0_gpio_ioh, GPIO_GPSR2, sd.sd_gplr2 &
	    sd.sd_gpdr2);
	bus_space_write_4(sc->sc_iot, pxa2x0_gpio_ioh, GPIO_GPCR0, ~sd.sd_gplr0 &
	    sd.sd_gpdr0);
	bus_space_write_4(sc->sc_iot, pxa2x0_gpio_ioh, GPIO_GPCR1, ~sd.sd_gplr1 &
	    sd.sd_gpdr1);
	bus_space_write_4(sc->sc_iot, pxa2x0_gpio_ioh, GPIO_GPCR2, ~sd.sd_gplr2 &
	    sd.sd_gpdr2);

	/* PXA27x */
#if 0
	bus_space_write_4(sc->sc_iot, pxa2x0_gpio_ioh, GPIO_GEDR3, 0xffffffff);
#endif
	bus_space_write_4(sc->sc_iot, pxa2x0_gpio_ioh, GPIO_GPDR3, sd.sd_gpdr3);
	bus_space_write_4(sc->sc_iot, pxa2x0_gpio_ioh, GPIO_GRER3, sd.sd_grer3);
	bus_space_write_4(sc->sc_iot, pxa2x0_gpio_ioh, GPIO_GFER3, sd.sd_gfer3);
	bus_space_write_4(sc->sc_iot, pxa2x0_gpio_ioh, GPIO_GAFR3_L, sd.sd_gafr3_l);
	bus_space_write_4(sc->sc_iot, pxa2x0_gpio_ioh, GPIO_GAFR3_U, sd.sd_gafr3_u);
	bus_space_write_4(sc->sc_iot, pxa2x0_gpio_ioh, GPIO_GPSR3, sd.sd_gplr3 &
	    sd.sd_gpdr3);
	bus_space_write_4(sc->sc_iot, pxa2x0_gpio_ioh, GPIO_GPCR3, ~sd.sd_gplr3 &
	    sd.sd_gpdr3);

	bus_space_write_4(sc->sc_iot, pxa2x0_memctl_ioh, MEMCTL_MECR,
	    sd.sd_mecr);
	bus_space_write_4(sc->sc_iot, pxa2x0_memctl_ioh, MEMCTL_MCMEM(0),
	    sd.sd_mcmem0);
	bus_space_write_4(sc->sc_iot, pxa2x0_memctl_ioh, MEMCTL_MCMEM(1),
	    sd.sd_mcmem1);
	bus_space_write_4(sc->sc_iot, pxa2x0_memctl_ioh, MEMCTL_MCATT(0),
	    sd.sd_mcatt0);
	bus_space_write_4(sc->sc_iot, pxa2x0_memctl_ioh, MEMCTL_MCATT(1),
	    sd.sd_mcatt1);
	bus_space_write_4(sc->sc_iot, pxa2x0_memctl_ioh, MEMCTL_MCIO(0),
	    sd.sd_mcio0);
	bus_space_write_4(sc->sc_iot, pxa2x0_memctl_ioh, MEMCTL_MCIO(1),
	    sd.sd_mcio1);

	bus_space_write_4(sc->sc_iot, pxa2x0_clkman_ioh, CLKMAN_CKEN,
	    sd.sd_cken);

	write_icu(INTCTL_ICLR, sd.sd_iclr);
	write_icu(INTCTL_ICCR, sd.sd_iccr);
	write_icu(INTCTL_ICMR, sd.sd_icmr);

	if ((read_icu(INTCTL_ICIP) & 0x1) != 0)
		bus_space_write_4(sc->sc_iot, sc->sc_pm_ioh, POWMAN_PEDR, 0x1);

	bus_space_write_4(sc->sc_iot, ost_ioh, OST_OSMR0, sd.sd_osmr0);
	bus_space_write_4(sc->sc_iot, ost_ioh, OST_OSMR1, sd.sd_osmr1);
	bus_space_write_4(sc->sc_iot, ost_ioh, OST_OSMR2, sd.sd_osmr2);
	bus_space_write_4(sc->sc_iot, ost_ioh, OST_OSMR3, sd.sd_osmr3);
	bus_space_write_4(sc->sc_iot, ost_ioh, OST_OSMR4, sd.sd_osmr4);
	bus_space_write_4(sc->sc_iot, ost_ioh, OST_OSMR5, sd.sd_osmr5);
	bus_space_write_4(sc->sc_iot, ost_ioh, OST_OMCR4, sd.sd_omcr4);
	bus_space_write_4(sc->sc_iot, ost_ioh, OST_OMCR5, sd.sd_omcr5);
	bus_space_write_4(sc->sc_iot, ost_ioh, OST_OSCR0, sd.sd_oscr0);
	bus_space_write_4(sc->sc_iot, ost_ioh, OST_OSCR4, sd.sd_oscr4);
	bus_space_write_4(sc->sc_iot, ost_ioh, OST_OIER, sd.sd_oier);

	pxa2x0_pi2c_setvoltage(sc->sc_iot, sc->sc_pm_ioh, PI2C_VOLTAGE_HIGH);

	/* Change to 208MHz run mode with fast-bus still disabled. */
	pxa27x_frequency_change(CCCR_A | CCCR_TURBO_X2 | CCCR_RUN_X16,
	    CLKCFG_F, &pxa2x0_memcfg);
	delay(1); /* XXX is the delay long enough, and necessary at all? */
	pxa27x_fastbus_run_mode(1, pxa2x0_memcfg.mdrefr_high);

	/* Change to 416MHz turbo mode with fast-bus enabled. */
	pxa27x_frequency_change(CCCR_A | CCCR_TURBO_X2 | CCCR_RUN_X16,
	    CLKCFG_B | CLKCFG_F | CLKCFG_T, &pxa2x0_memcfg);

	if (sc->sc_resume != NULL) {
		if (!sc->sc_resume(sc))
			goto suspend_again;
	}

	/*
	 * Allow immediate entry into deep-sleep mode if power fails.
	 * Resume from immediate deep-sleep is not implemented yet.
	 */
	bus_space_write_4(sc->sc_iot, sc->sc_pm_ioh, POWMAN_PMCR, 0);


	restore_interrupts(save);

	pxa2x0_setperf(perflevel);

 out:
	if (ost_ioh != (bus_space_handle_t)0)
		bus_space_unmap(sc->sc_iot, ost_ioh, PXA2X0_OST_SIZE);
}

void
pxa2x0_pi2c_open(bus_space_tag_t iot, bus_space_handle_t ioh)
{
	u_int32_t rv;

	/* Enable the I2C unit, and disable automatic voltage change. */
	rv = bus_space_read_4(iot, ioh, POWMAN_PCFR);
	bus_space_write_4(iot, ioh, POWMAN_PCFR, rv | PCFR_PI2C_EN);
	rv = bus_space_read_4(iot, ioh, POWMAN_PCFR);
	bus_space_write_4(iot, ioh, POWMAN_PCFR, rv & ~PCFR_FVC);
	delay(1);

	/* Enable the clock to the power manager I2C unit. */
	pxa2x0_clkman_config(CKEN_PI2C, 1);
	delay(1);
}

void
pxa2x0_pi2c_close(bus_space_tag_t iot, bus_space_handle_t ioh)
{
	u_int32_t rv;

	bus_space_write_4(iot, ioh, POWMAN_PICR, PICR_UR);
	bus_space_write_4(iot, ioh, POWMAN_PISAR, 0);
	delay(1);

	/* Disable the clock to the power manager I2C unit. */
	pxa2x0_clkman_config(CKEN_PI2C, 0);
	delay(1);

	/* Disable the I2C unit, and disable automatic voltage change. */
	rv = bus_space_read_4(iot, ioh, POWMAN_PCFR);
	bus_space_write_4(iot, ioh, POWMAN_PCFR,
	    rv & ~(PCFR_PI2C_EN | PCFR_FVC));
	delay(1);
}

int
pxa2x0_pi2c_read(bus_space_tag_t iot, bus_space_handle_t ioh,
    u_char slave, u_char *valuep)
{
	u_int32_t rv;
	int timeout;
	int tries = PI2C_RETRY_COUNT;

retry:

	bus_space_write_4(iot, ioh, POWMAN_PICR, PICR_UR);
	bus_space_write_4(iot, ioh, POWMAN_PISAR, 0x00);
	delay(1);
	bus_space_write_4(iot, ioh, POWMAN_PICR, PICR_IUE | PICR_SCLE);

	/* Write slave device address. */
	bus_space_write_4(iot, ioh, POWMAN_PIDBR, (slave<<1) | 0x1);
	rv = bus_space_read_4(iot, ioh, POWMAN_PICR);
	bus_space_write_4(iot, ioh, POWMAN_PICR, rv | PICR_START);
	rv = bus_space_read_4(iot, ioh, POWMAN_PICR);
	bus_space_write_4(iot, ioh, POWMAN_PICR, rv & ~PICR_STOP);
	rv = bus_space_read_4(iot, ioh, POWMAN_PICR);
	bus_space_write_4(iot, ioh, POWMAN_PICR, rv | PICR_TB);

	timeout = 10000;
	while ((bus_space_read_4(iot, ioh, POWMAN_PISR) & PISR_ITE) == 0) {
		if (timeout-- == 0) {
			bus_space_write_4(iot, ioh, POWMAN_PISR, PISR_ITE);
			goto err;
		}
		delay(1);
	}

	bus_space_write_4(iot, ioh, POWMAN_PISR, PISR_ITE);

	rv = bus_space_read_4(iot, ioh, POWMAN_PICR);
	bus_space_write_4(iot, ioh, POWMAN_PICR, rv & ~PICR_START);

	/* Read data value. */
	rv = bus_space_read_4(iot, ioh, POWMAN_PICR);
	bus_space_write_4(iot, ioh, POWMAN_PICR, rv |
	    (PICR_STOP | PICR_ACKNAK));
	rv = bus_space_read_4(iot, ioh, POWMAN_PICR);
	bus_space_write_4(iot, ioh, POWMAN_PICR, rv | PICR_TB);

	timeout = 10000;
	while ((bus_space_read_4(iot, ioh, POWMAN_PISR) & PISR_IRF) == 0) {
		if (timeout-- == 0) {
			bus_space_write_4(iot, ioh, POWMAN_PISR, PISR_IRF);
			goto err;
		}
		delay(1);
	}

	bus_space_write_4(iot, ioh, POWMAN_PISR, PISR_IRF);
	rv = bus_space_read_4(iot, ioh, POWMAN_PIDBR);
	*valuep = (u_char)rv;
	rv = bus_space_read_4(iot, ioh, POWMAN_PICR);
	bus_space_write_4(iot, ioh, POWMAN_PICR, rv &
	    ~(PICR_STOP | PICR_ACKNAK));

	return (0);
err:
	if (tries-- >= 0)
		goto retry;

	bus_space_write_4(iot, ioh, POWMAN_PICR, PICR_UR);
	bus_space_write_4(iot, ioh, POWMAN_PISAR, 0x00);
	bus_space_write_4(iot, ioh, POWMAN_PICR, PICR_IUE | PICR_SCLE);

	return (-EIO);
}

int
pxa2x0_pi2c_write(bus_space_tag_t iot, bus_space_handle_t ioh,
    u_char slave, u_char value)
{
	u_int32_t rv;
	int timeout;
	int tries = PI2C_RETRY_COUNT;

retry:

	bus_space_write_4(iot, ioh, POWMAN_PICR, PICR_UR);
	bus_space_write_4(iot, ioh, POWMAN_PISAR, 0x00);
	delay(1);
	bus_space_write_4(iot, ioh, POWMAN_PICR, PICR_IUE | PICR_SCLE);

	/* Write slave device address. */
	bus_space_write_4(iot, ioh, POWMAN_PIDBR, (slave<<1));
	rv = bus_space_read_4(iot, ioh, POWMAN_PICR);
	bus_space_write_4(iot, ioh, POWMAN_PICR, rv | PICR_START);
	rv = bus_space_read_4(iot, ioh, POWMAN_PICR);
	bus_space_write_4(iot, ioh, POWMAN_PICR, rv & ~PICR_STOP);
	rv = bus_space_read_4(iot, ioh, POWMAN_PICR);
	bus_space_write_4(iot, ioh, POWMAN_PICR, rv | PICR_TB);

	timeout = 10000;
	while ((bus_space_read_4(iot, ioh, POWMAN_PISR) & PISR_ITE) == 0) {
		if (timeout-- == 0) {
			bus_space_write_4(iot, ioh, POWMAN_PISR, PISR_ITE);
			goto err;
		}
		delay(1);
	}
	if ((bus_space_read_4(iot, ioh, POWMAN_PISR) & PISR_ACKNAK) != 0)
		goto err;
	bus_space_write_4(iot, ioh, POWMAN_PISR, PISR_ITE);

	/* Write data. */
	rv = bus_space_read_4(iot, ioh, POWMAN_PICR);
	bus_space_write_4(iot, ioh, POWMAN_PICR, rv & ~PICR_START);
	rv = bus_space_read_4(iot, ioh, POWMAN_PICR);
	bus_space_write_4(iot, ioh, POWMAN_PICR, rv | PICR_STOP);
	bus_space_write_4(iot, ioh, POWMAN_PIDBR, value);
	rv = bus_space_read_4(iot, ioh, POWMAN_PICR);
	bus_space_write_4(iot, ioh, POWMAN_PICR, rv | PICR_TB);

	timeout = 10000;
	while ((bus_space_read_4(iot, ioh, POWMAN_PISR) & PISR_ITE) == 0) {
		if (timeout-- == 0) {
#if 0
			bus_space_write_4(iot, ioh, POWMAN_PISR, PISR_ITE);
#endif
			goto err;
		}
		delay(1);
	}
	if ((bus_space_read_4(iot, ioh, POWMAN_PISR) & PISR_ACKNAK) != 0)
		goto err;
	bus_space_write_4(iot, ioh, POWMAN_PISR, PISR_ITE);

	rv = bus_space_read_4(iot, ioh, POWMAN_PICR);
	bus_space_write_4(iot, ioh, POWMAN_PICR, rv & ~PICR_STOP);

	return (0);
err:
	bus_space_write_4(iot, ioh, POWMAN_PISR, PISR_ITE);
	if (tries-- >= 0)
		goto retry;

	bus_space_write_4(iot, ioh, POWMAN_PICR, PICR_UR);
	bus_space_write_4(iot, ioh, POWMAN_PISAR, 0x00);
	bus_space_write_4(iot, ioh, POWMAN_PICR, PICR_IUE | PICR_SCLE);

	return (-EIO);
}

int
pxa2x0_pi2c_getvoltage(bus_space_tag_t iot, bus_space_handle_t ioh,
    u_char *valuep)
{
	int res;

	pxa2x0_pi2c_open(iot, ioh);
	res = pxa2x0_pi2c_read(iot, ioh, 0x0c, valuep);
	pxa2x0_pi2c_close(iot, ioh);
	return (res);
}

int
pxa2x0_pi2c_setvoltage(bus_space_tag_t iot, bus_space_handle_t ioh,
    u_char value)
{
	int res;

	pxa2x0_pi2c_open(iot, ioh);
	res = pxa2x0_pi2c_write(iot, ioh, 0x0c, value);
	pxa2x0_pi2c_close(iot, ioh);
	return (res);
}

#if 0
void
pxa2x0_pi2c_print(struct pxa2x0_apm_softc *sc)
{
	u_char value = 0;

	(void)pxa2x0_pi2c_getvoltage(sc->sc_iot, sc->sc_pm_ioh, &value);
	printf("xscale core voltage: %s\n", value == PI2C_VOLTAGE_HIGH ?
	    "high" : (value == PI2C_VOLTAGE_LOW ? "low" : "unknown"));
}
#endif

struct {
	int maxspeed;
	int numspeeds;
	int hz [6];
	int rate [6]; /* could this be simplfied by not having 100% in table? */
}
speedtables[] = {
	{ 91, 1, { 91 }, { 100 }},
	{ 208, 2, { 91, 208}, {50, 100}},
	{ 416, 3, { 91, 208, 416}, {25, 50, 100}},
	{ 520, 4, { 91, 208, 416, 520}, {18, 40 ,80, 100}},
	{ 624, 5, { 91, 208, 416, 520, 624}, {15, 34, 67, 82, 100}},
	{ 0 }
};
int xscale_maxspeed = 416; /* XXX */

int speed_to_freq(int speed);

int
speed_to_freq(int speed)
{
	int i, j;
	int newspeed = 0;
	int numspeeds;
	for (i = 0; speedtables[i].maxspeed != 0; i++) {
		if (speedtables[i].maxspeed != xscale_maxspeed)
			continue;

		if (speed <= speedtables[i].rate[0]) {
			return speedtables[i].hz[0];
			
		}
		numspeeds = speedtables[i].numspeeds;
		if (speed == speedtables[i].rate[numspeeds-1]) {
			return speedtables[i].hz[numspeeds-1];
		}
		for (j = 1; j < numspeeds; j++) {
			if (speed < speedtables[i].rate[j]) {
				return speedtables[i].hz[j-1];
			}
		}
	}
	return newspeed;
}


void
pxa2x0_setperf(int speed)
{
	struct pxa2x0_apm_softc *sc;
	int s;
	int newfreq;

	sc = apm_cd.cd_devs[0];

	newfreq = speed_to_freq(speed);

	if (newfreq == 0) {
		printf("bogus new frequency 0 for rate %d maxclock %d\n",
		    speed, xscale_maxspeed);
	}

	DPRINTF(("setperf speed %d newfreq %d, maxfreq %d\n",
	    speed, newfreq, xscale_maxspeed));

	s = disable_interrupts(PSR_I|PSR_F);

	if (newfreq == 91) {
		if (freq > 91) {
			pxa27x_run_mode();
			pxa27x_fastbus_run_mode(0, MDREFR_LOW);
			pxa27x_cpu_speed_91();
			pxa2x0_pi2c_setvoltage(sc->sc_iot, sc->sc_pm_ioh,
			    PI2C_VOLTAGE_LOW);
			freq = 91;
		}
	} else if (newfreq == 208) {
		if (freq < 208)
			pxa2x0_pi2c_setvoltage(sc->sc_iot, sc->sc_pm_ioh,
			    PI2C_VOLTAGE_HIGH);
		if (freq != 208) {
			pxa27x_frequency_change(CCCR_A | CCCR_TURBO_X2 |
			    CCCR_RUN_X16, CLKCFG_F, &pxa2x0_memcfg);
			pxa27x_fastbus_run_mode(1, pxa2x0_memcfg.mdrefr_high);
			freq = 208;
		}
	} else if (newfreq == 416) {
		if (freq < 208) {
			pxa2x0_pi2c_setvoltage(sc->sc_iot, sc->sc_pm_ioh,
			    PI2C_VOLTAGE_HIGH);
			pxa27x_frequency_change(CCCR_A | CCCR_TURBO_X2 |
			    CCCR_RUN_X16, CLKCFG_F, &pxa2x0_memcfg);
			pxa27x_fastbus_run_mode(1, pxa2x0_memcfg.mdrefr_high);
		}
		if (freq != 416) {
			pxa27x_frequency_change(CCCR_A | CCCR_TURBO_X2 |
			    CCCR_RUN_X16, CLKCFG_B | CLKCFG_F | CLKCFG_T,
			    &pxa2x0_memcfg);
			freq = 416;
		}
	} else if (newfreq == 520) {
		if (freq < 208) {
			pxa2x0_pi2c_setvoltage(sc->sc_iot, sc->sc_pm_ioh,
			    PI2C_VOLTAGE_HIGH);
			pxa27x_frequency_change(CCCR_A | CCCR_TURBO_X2 |
			    CCCR_RUN_X16, CLKCFG_F, &pxa2x0_memcfg);
			pxa27x_fastbus_run_mode(1, pxa2x0_memcfg.mdrefr_high);
		}
		if (freq != 520) {
			pxa27x_frequency_change(CCCR_A | CCCR_TURBO_X25 |
			    CCCR_RUN_X16, CLKCFG_B | CLKCFG_F | CLKCFG_T,
			    &pxa2x0_memcfg);
			freq = 520;
		}
	} else if (newfreq == 624) {
		if (freq < 208) {
			pxa2x0_pi2c_setvoltage(sc->sc_iot, sc->sc_pm_ioh,
			    PI2C_VOLTAGE_HIGH);
			pxa27x_frequency_change(CCCR_A | CCCR_TURBO_X2 |
			    CCCR_RUN_X16, CLKCFG_F, &pxa2x0_memcfg);
			pxa27x_fastbus_run_mode(1, pxa2x0_memcfg.mdrefr_high);
		}
		if (freq != 624) {
			pxa27x_frequency_change(CCCR_A | CCCR_TURBO_X3 |
			    CCCR_RUN_X16, CLKCFG_B | CLKCFG_F | CLKCFG_T,
			    &pxa2x0_memcfg);
			freq = 624;
		}
	}

	restore_interrupts(s);
}

int
pxa2x0_cpuspeed(int *freqp)
{
	*freqp = freq;
	return 0;
}

void pxa2x0_maxspeed(int *speedp);

void
pxa2x0_maxspeed(int *speedp)
{
	/* XXX assumes a pxa270 */

	if (*speedp < 207) {
		*speedp = 91;
	} else if (*speedp < 415) {
		*speedp = 208;
	} else if (*speedp < 519) {
		*speedp = 416;
	} else if (*speedp < 624) {
		*speedp = 520;
#if 0
	} else if (*speedp < 651) {
		*speedp = 624;
#endif
	} else {
		*speedp = 520; /* hope this is safe. */
	}
	xscale_maxspeed = *speedp;
	pxa2x0_setperf(perflevel);
}
@


1.44
log
@Switch from PSR_X_bit and X32_bit PSR macro names to just PSR_X.
This matches FreeBSD and makes things a bit more consistent.
Discussed with Patrick.
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_apm.c,v 1.43 2014/09/20 09:28:24 kettenis Exp $	*/
@


1.43
log
@Use config_suspend_all(9).

ok mpi@@, uebayasi@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_apm.c,v 1.42 2014/03/13 03:52:55 dlg Exp $	*/
d903 1
a903 1
	save = disable_interrupts(I32_bit|F32_bit);
d1486 1
a1486 1
	s = disable_interrupts(I32_bit|F32_bit);
@


1.42
log
@get rid of the assumption that the head of the alldevs list is the
"mainbus" device. this breaks when mpath is enabled because it
attaches before mainbus and therefore takes the head position.

have autoconf provide device_mainbus() which looks up mainbus_cd,
and use that instead.

discussed with deraadt who just wants mpath stuff to move forward
despite there being many ways to shine this particular turd.
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_apm.c,v 1.41 2013/12/06 21:03:05 deraadt Exp $	*/
a308 1
	struct device *mainbus = device_mainbus();
d323 1
a323 1
	config_suspend(mainbus, DVACT_SUSPEND);
d330 1
a330 1
	config_suspend(mainbus, DVACT_POWERDOWN);
a340 1
	struct device *mainbus = device_mainbus();
d344 1
a344 1
	config_suspend(mainbus, DVACT_RESUME);
d358 1
a358 1
	config_suspend(mainbus, DVACT_WAKEUP);
@


1.41
log
@Add a DVACT_WAKEUP op to the *_activate() API.  This is called after the
kernel resumes normal (non-cold, able to run processes, etc) operation.
Previously we were relying on specific DVACT_RESUME op's in drivers
creating callback/threads themselves, but that has become too common,
indicating the need for a built-in mechanism.
ok dlg kettenis, tested by a sufficient amount of people
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_apm.c,v 1.40 2013/11/18 20:21:51 deraadt Exp $	*/
d309 1
d324 1
a324 1
	config_suspend(TAILQ_FIRST(&alldevs), DVACT_SUSPEND);
d331 1
a331 1
	config_suspend(TAILQ_FIRST(&alldevs), DVACT_POWERDOWN);
d342 1
d346 1
a346 1
	config_suspend(TAILQ_FIRST(&alldevs), DVACT_RESUME);
d360 1
a360 1
	config_suspend(TAILQ_FIRST(&alldevs), DVACT_WAKEUP);
@


1.40
log
@simplify kthread_create(). no more stdarg
ok matthew guenther mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_apm.c,v 1.39 2012/10/17 22:49:27 deraadt Exp $	*/
d357 3
@


1.39
log
@Document the 'boothowto hack' used to flag to (a few) DVACT_POWERDOWN
handlers how hard they should hit the hardware.
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_apm.c,v 1.39 2012/10/17 22:43:50 deraadt Exp $	*/
d436 1
a436 1
	    "%s", sc->sc_dev.dv_xname)) {
@


1.38
log
@Revamp the sequences for suspend/hibernate -> resume so that the code
paths are reflexive.  It is now possible to fail part-way through a
suspend sequence, and recover along the resume code path.
Split DVACT_SUSPEND by adding a new DVACT_POWERDOWN method is used
after hibernate (and suspend too) to finish the job.  Some drivers
must be converted at the same time to use this instead of shutdown hooks
(the others will follow at a later time)
ok kettenis mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_apm.c,v 1.37 2011/07/02 22:20:07 nicm Exp $	*/
d325 4
@


1.37
log
@kqueue attach functions should return an errno or 0, not a plain 1. Fix
the obvious cases to return EINVAL and ENXIO.

ok tedu deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_apm.c,v 1.36 2010/09/08 21:18:14 deraadt Exp $	*/
d48 1
d324 5
@


1.36
log
@No need for vfs_syncwait() in a bufq_quiesce() world
ok thib kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_apm.c,v 1.35 2010/09/07 16:21:35 deraadt Exp $	*/
d647 1
a647 1
		return (1);
@


1.35
log
@remove the powerhook code.  All architectures now use the ca_activate tree
traversal code to suspend/resume
ok oga kettenis blambert
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_apm.c,v 1.34 2010/08/30 21:37:52 deraadt Exp $	*/
a42 1
#include <sys/mount.h>		/* for vfs_syncwait() */
a314 3

	if (cold)
		vfs_syncwait(0);
@


1.34
log
@Hurray!  Zaurus apm can now call the activate functions intead of powerhooks.
We call the activate functions at splhigh; unfortunately we cannot suspend a
zaurus at splhigh because on resume the clock is hosed.  We accept this bug
for now... perhaps someone can find it?
(The powerhooks remain in place in the drivers, and will be roto-tilled once
we all the other powerhook-using architectures have switched over)
testing by myself and jakemsr; proof reading by oga
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_apm.c,v 1.33 2010/08/29 02:02:25 deraadt Exp $	*/
d345 1
a345 1
	 * powerhooks to re-enable their operation. See 3.8.1.2
@


1.33
log
@put the bufq_restart() in the right place, so that a 2nd resume works.
how did noone notice for so long?  tsk, tsk, tsk.  of course, I broke it.
tested by jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_apm.c,v 1.32 2010/03/30 17:40:55 oga Exp $	*/
d309 2
a316 2
	dopowerhooks(PWR_SUSPEND);

d325 4
d335 1
d337 3
a339 1
	dopowerhooks(PWR_RESUME);
@


1.32
log
@Prevent the apmd/x races for good.

When we hit suspend time, go through all wsdisplays on the system. if
they are in mode MAPPED, but not MODE_DUMBFB then if possible do a full
vt switch to a !mapped vt, and prevent switching back until resume time.
This has to be called from MD code because this involves userland
running so that X can run the vt switch signal handler. This way, any
case where we are using the "poke registers from userland" model, we
will not be on the hardware when we go down, so the kernel can actually
handle thing properly.

Tested on several acpi laptops (by kettenis@@ and ian@@), x40 (me and
beck@@ at LEAST) and zaurus (me). Maybe others, but if so I forgot who at
this time..

Idea from deraadt somewhere over the Faroe Islands (I thought of a
similar thing myself a while ago). Much prompting from him. Ok and
comments miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_apm.c,v 1.31 2009/03/27 16:01:37 oga Exp $	*/
d45 1
d342 2
@


1.31
log
@convert arm apm lock to rwlock.

ok drahn@@, todd@@ tested.
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_apm.c,v 1.30 2009/02/26 19:57:10 todd Exp $	*/
d58 3
d308 3
d341 3
@


1.30
log
@fix tree break with two missing chars
please commit miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_apm.c,v 1.29 2009/02/26 17:19:47 oga Exp $	*/
d42 1
a42 1
#include <sys/lock.h>
d65 2
a66 2
#define APM_LOCK(sc)    lockmgr(&(sc)->sc_lock, LK_EXCLUSIVE, NULL)
#define APM_UNLOCK(sc)  lockmgr(&(sc)->sc_lock, LK_RELEASE, NULL)
d653 1
a653 1
	lockinit(&sc->sc_lock, PWAIT, "apmlk", 0, 0);
@


1.29
log
@Add a two new ioctls to the apm(4) interface.

APM_IOC_{SUSPEND,STANDBY}_REQ: This is to fix an issue with apm suspend
where a call to zzz suspended the machine immediately, not giving anyone
listening for apm events (other than apmd) a chance to deal with the
upcoming change. This hit X hard since the introduction of drm, since it
needs to have time to idle the 3d engine and otherwise get the device
into a recoverable state. Such things are needed until we support
modesetting in the kernel.

Now, instead of forcing a suspend, using ioctl sends out an event similar
to if you had put the lid down, giving all userland applications a
chance to reply.

tested by sthen@@ and beck@@, especial thanks to sthen for sitting there
while I tried to debug this remotely, I owe him beer.

Prompted by and ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_apm.c,v 1.28 2007/03/29 18:42:38 uwe Exp $	*/
d569 1
a569 1
			error = EINVAL /* ? */
d575 1
a575 1
			error = EINVAL /* ? */
@


1.28
log
@Add power hook to scoop(4), replacing the Zaurus-specific scoop_* calls in
pxa2x0_apm.c.

Set a flag to indicate that scoop is currently suspended.  Test this flag
in scoop_timeout() (and maybe later in other places) to avoid manipulating
scoop registers while the driver is suspended.  The scoop_checkdisk timeout
is intentionally not stopped, as it should be safe to have timeouts running
accross suspend/resume.

Put splhigh() in scoop_gpio_pin_write() to make changing the pin level an
atomic operation.

Result of prodding and diffs from Robert and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_apm.c,v 1.27 2006/12/12 23:14:27 dim Exp $	*/
d565 11
a575 1

@


1.27
log
@Complete gwk's previous patch to stop setperf methods from returning
errors to userland: make all cpu_setperf functions return void.

Tested by many, ok gwk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_apm.c,v 1.26 2006/10/19 10:55:56 tom Exp $	*/
a237 5
/* XXX */
void	scoop_check_mcr(void);
void	scoop_suspend(void);
void	scoop_resume(void);

a902 2
	scoop_check_mcr();

a919 3
	scoop_check_mcr();
	scoop_suspend();

a1115 3

	scoop_check_mcr();
	scoop_resume();
@


1.26
log
@s/Mhz/MHz/ in comments and printf() strings

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_apm.c,v 1.25 2005/12/22 00:42:14 deraadt Exp $	*/
d97 2
a98 2
int pxa2x0_setperf(int speed);
int pxa2x0_cpuspeed(int *speed);
d1442 1
a1442 1
int
a1526 2

	return 0;
@


1.25
log
@remove another debug message
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_apm.c,v 1.24 2005/12/22 00:38:23 deraadt Exp $	*/
d884 1
a884 1
	/* Bring the PXA27x into 416Mhz turbo mode. */
d1002 1
a1002 1
	/* Stop 3/13Mhz oscillator; do not float PCMCIA and chip-selects. */
d1144 1
a1144 1
	/* Change to 208Mhz run mode with fast-bus still disabled. */
d1150 1
a1150 1
	/* Change to 416Mhz turbo mode with fast-bus enabled. */
@


1.24
log
@silence setperf code
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_apm.c,v 1.23 2005/12/20 19:23:57 drahn Exp $	*/
a1504 1
			printf("would switch to 520\n");
@


1.23
log
@Add machdep.maxspeed sysctl to change the meaning of hw.setperf=100 on zaurus,
This will scale the speed for hw.setperf, this allows limiting apm -A
to lower speed, or even overclocking. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_apm.c,v 1.22 2005/12/20 02:37:09 drahn Exp $	*/
d1457 3
a1459 2
	printf("setperf speed %d newfreq %d, maxfreq %d\n",
	    speed, newfreq, xscale_maxspeed);
@


1.22
log
@switch to using clock4 instead of clock0 so that we get clocks when running
at 91MHz (clock4 is programmed to be based of the 32.768KHz clock.
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_apm.c,v 1.21 2005/12/05 21:13:13 uwe Exp $	*/
d1396 46
d1447 1
d1451 9
d1462 1
a1462 1
	if (speed <= 30) {
d1471 1
a1471 1
	} else if (speed < 60) {
d1481 1
a1481 1
	} else {
d1489 1
a1489 1
		if (freq < 416) {
d1495 29
d1536 26
@


1.21
log
@- Run only the necessary code to transition from one speed to another.
- Don't clobber perflevel, instead leave it to the user requested value.
precise description and ok drahn@@ :)
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_apm.c,v 1.20 2005/12/02 17:50:51 uwe Exp $	*/
d831 3
d873 3
d880 2
d1130 12
a1154 6
		/* Restore OS timers only to allow the use of delay(). */
		bus_space_write_4(sc->sc_iot, ost_ioh, OST_OSMR1, sd.sd_osmr1);
		bus_space_write_4(sc->sc_iot, ost_ioh, OST_OSMR2, sd.sd_osmr2);
		bus_space_write_4(sc->sc_iot, ost_ioh, OST_OSMR3, sd.sd_osmr3);
		bus_space_write_4(sc->sc_iot, ost_ioh, OST_OSCR0, sd.sd_oscr0);
		bus_space_write_4(sc->sc_iot, ost_ioh, OST_OIER, sd.sd_oier);
a1164 6
	bus_space_write_4(sc->sc_iot, ost_ioh, OST_OSMR0, sd.sd_osmr0);
	bus_space_write_4(sc->sc_iot, ost_ioh, OST_OSMR1, sd.sd_osmr1);
	bus_space_write_4(sc->sc_iot, ost_ioh, OST_OSMR2, sd.sd_osmr2);
	bus_space_write_4(sc->sc_iot, ost_ioh, OST_OSMR3, sd.sd_osmr3);
	bus_space_write_4(sc->sc_iot, ost_ioh, OST_OSCR0, sd.sd_oscr0);
	bus_space_write_4(sc->sc_iot, ost_ioh, OST_OIER, sd.sd_oier);
a1405 2
#if 0
	/* Not yet, because OSCR0 does not run in low-power mode. */
d1415 1
a1415 3
	} else
#endif
	if (speed < 60) {
@


1.20
log
@no 91Mhz mode for now, because the OSCR0 does not run in low-power mode;
found after prodding by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_apm.c,v 1.19 2005/11/19 02:18:00 pedro Exp $	*/
d1401 4
a1404 6
		pxa27x_run_mode();
		pxa27x_fastbus_run_mode(0, MDREFR_LOW);
		delay(1);
		pxa27x_cpu_speed_91();
		freq = 91;
		if (perflevel > 50)
d1407 2
a1408 1
		perflevel = 25;
d1412 1
a1412 1
		if (perflevel < 50)
d1415 6
a1420 10

		pxa27x_frequency_change(CCCR_A | CCCR_TURBO_X2 | CCCR_RUN_X16,
		    CLKCFG_F, &pxa2x0_memcfg);

		/* XXX is the delay long enough, and necessary at all? */
		delay(1);

		pxa27x_fastbus_run_mode(1, pxa2x0_memcfg.mdrefr_high);
		freq = 208;
		perflevel = 50;
d1422 1
a1422 1
		if (perflevel < 50)
d1425 10
a1434 16

		/* Change to 208Mhz run mode with fast-bus still disabled. */
		pxa27x_frequency_change(CCCR_A | CCCR_TURBO_X2 | CCCR_RUN_X16,
		    CLKCFG_F, &pxa2x0_memcfg);

		/* XXX is the delay long enough, and necessary at all? */
		delay(1);

		pxa27x_fastbus_run_mode(1, pxa2x0_memcfg.mdrefr_high);

		/* Change to 416Mhz turbo mode with fast-bus enabled. */
		pxa27x_frequency_change(CCCR_A | CCCR_TURBO_X2 | CCCR_RUN_X16,
		    CLKCFG_B | CLKCFG_F | CLKCFG_T, &pxa2x0_memcfg);

		freq = 416;
		perflevel = 100;
@


1.19
log
@Remove unnecessary lockmgr() archaism that was costing too much in terms
of panics and bugfixes. Access curproc directly, do not expect a process
pointer as an argument. Should fix many "process context required" bugs.
Incentive and okay millert@@, okay marc@@. Various testing, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_apm.c,v 1.18 2005/11/19 01:59:36 aaron Exp $	*/
d1398 2
d1410 3
a1412 1
	} else if (speed < 60) {
d1418 1
a1418 1
		CLKCFG_F, &pxa2x0_memcfg);
@


1.18
log
@Remove superfluous statement-ending semi-colons.  i.e., "return foo;;" should
just be "return foo;".  Cleaning out some M's in my tree.
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_apm.c,v 1.17 2005/10/31 05:23:32 deraadt Exp $	*/
d65 2
a66 2
#define APM_LOCK(sc)    lockmgr(&(sc)->sc_lock, LK_EXCLUSIVE, NULL, curproc)
#define APM_UNLOCK(sc)  lockmgr(&(sc)->sc_lock, LK_RELEASE, NULL, curproc)
@


1.17
log
@show the speed status in hw.cpuspeed; ok drahn
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_apm.c,v 1.15 2005/08/12 03:23:02 uwe Exp $	*/
d299 1
a299 1
	power->battery_state = APM_BATT_UNKNOWN;;
@


1.16
log
@On suspend/resume save the current time to the RTC earlier and restore it later
so that the very long delay operations do not slow the clock unnecessarily.
Add early support for hw.setperf and hw.cpuspeed for zaurus, it appears
to be able to run at 91MHz and 209MHz as well as the std 416MHz with this
change. Hopefully it is doing the speed changes correctly.
@
text
@d95 2
d98 1
d1160 2
a1387 1
extern int perflevel;
d1394 1
a1394 1
        sc = apm_cd.cd_devs[0];
d1403 1
d1420 1
d1440 1
d1446 7
@


1.15
log
@Do not notify apmd of APM_CRIT_SUSPEND_REQ events; apmd makes us fall
asleep immediately after resume. This needs to be reconsidered later.
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_apm.c,v 1.14 2005/08/09 21:29:26 uwe Exp $	*/
d95 2
d308 2
d329 2
a900 2
	resettodr();

a1147 2
	inittodr(0);

d1383 58
@


1.14
log
@- Don't depend on the APM_CRIT_RESUME event to run PWR_RESUME power hooks
  after a APM_CRIT_SUSPEND_REQ event. This fixes non-working devices after
  resume from battery low suspend.
- Don't suspend automatically on APM_BATT_LOW because that's what could
  be too early (and we now understand APM_CRIT_SUSPEND_REQ).
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_apm.c,v 1.13 2005/04/13 05:40:07 uwe Exp $	*/
d356 2
d359 1
d365 1
@


1.13
log
@Call special suspend and resume hooks.  The latter can cancel a resume.
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_apm.c,v 1.12 2005/04/11 03:07:09 uwe Exp $	*/
d356 6
a361 2
		apm_record_event(sc, type);
		apm_suspend(sc);
d425 1
a425 1
		if (apm_battlow || apm_suspends || apm_userstandbys) {
@


1.12
log
@- ask upper layer for events and call apm_record_event() as appropriate
- allow upper layer to detect the wake-up source which caused a resume
- avoid a temporary bus space mapping
- suspend on battery low events
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_apm.c,v 1.11 2005/04/06 01:31:05 pascoe Exp $	*/
d311 5
d726 1
d734 1
d743 1
a747 9
	bus_space_write_4(sc->sc_iot, sc->sc_pm_ioh, POWMAN_PEDR,
	    0xffffffff);
	bus_space_write_4(sc->sc_iot, sc->sc_pm_ioh, POWMAN_PKWR, pkwr);
	bus_space_write_4(sc->sc_iot, sc->sc_pm_ioh, POWMAN_PKSR,
	    0xffffffff);

	/* XXX do that just before suspend. */
	pxa2x0_clkman_config(CKEN_KEY,
	    (wsrc & PXA2X0_WAKEUP_KEYNS_ALL) != 0);
d876 7
a891 2
	pxa2x0_wakeup_config(PXA2X0_WAKEUP_ALL, 1);

d959 9
a967 2
	bus_space_write_4(sc->sc_iot, pxa2x0_clkman_ioh, CLKMAN_CKEN,
	    CKEN_MEM | CKEN_KEY);
d1030 1
d1035 2
a1114 2
	bus_space_write_4(sc->sc_iot, sc->sc_pm_ioh, POWMAN_PMCR, 0);

d1119 19
a1143 2

	inittodr(0);
@


1.11
log
@spelling/grammar cleanups

jolan drahn uwe dlg ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_apm.c,v 1.10 2005/03/30 14:24:39 dlg Exp $	*/
d90 2
a91 3
int	apm_get_event(struct pxa2x0_apm_softc *, u_long *);
int	apm_handle_event(struct pxa2x0_apm_softc *, u_long);
void	apm_periodic_check(struct pxa2x0_apm_softc *);
d95 1
a206 2
void	pxa2x0_apm_sleep(struct pxa2x0_apm_softc *);

d311 1
a311 1
	pxa2x0_apm_sleep((struct pxa2x0_apm_softc *)sc);
d317 1
d329 1
a329 1
apm_get_event(struct pxa2x0_apm_softc *sc, u_long *event_type)
a330 1
	struct	apm_power_info power;
d332 2
a333 15
	/* Periodic callbacks could be replaced with a machine-dependent
	   get_event function. */
	if (sc->sc_periodic_check != NULL)
		sc->sc_periodic_check(sc);

	apm_power_info(sc, &power);
	if (power.ac_state != sc->sc_ac_state ||
	    power.battery_life != sc->sc_batt_life ||
	    power.battery_state != sc->sc_batt_state) {
		sc->sc_ac_state = power.ac_state;
		sc->sc_batt_life = power.battery_life;
		sc->sc_batt_state = power.battery_state;
		*event_type = APM_POWER_CHANGE;
		return 0;
	}
d335 2
a336 2
	*event_type = APM_NOEVENT;
	return 1;
d340 1
a340 1
apm_handle_event(struct pxa2x0_apm_softc *sc, u_long event_type)
d345 1
a345 1
	switch (event_type) {
d349 13
d363 1
d369 2
a370 2
		    sc->sc_prev_batt_life != power.battery_life)) {
			sc->sc_prev_batt_life = power.battery_life;
d373 6
d382 1
a382 1
		    event_type));
a388 19
apm_periodic_check(struct pxa2x0_apm_softc *sc)
{
	u_long	event_type;

	while (1) {
		if (apm_get_event(sc, &event_type) != 0)
			break;
		if (apm_handle_event(sc, event_type) != 0)
			break;
	}

	if (apm_battlow || apm_suspends || apm_userstandbys) {
		apm_suspend(sc);
		apm_resume(sc);
	}
	apm_battlow = apm_suspends = apm_userstandbys = 0;
}

void
d405 1
d409 13
a421 1
		apm_periodic_check(sc);
d436 1
a436 1
		return ENXIO;
d464 1
a464 1
	return error;
d475 1
a475 1
		return ENXIO;
d487 1
a487 1
	return 0;
d500 1
a500 1
		return ENXIO;
d556 15
d598 1
a598 1
		return ENXIO;
d643 1
d647 1
a647 1
		printf("pxa2x0_apm_sleep: can't map GPIO\n");
d650 4
d657 1
a657 1
pxa2x0_wakeup_config(u_int32_t wsrc, int enable)
d673 1
a673 1
		pkwr |= (1<<12);
d751 60
a840 1
	bus_space_handle_t intctl_ioh;
a844 2
	intctl_ioh = (bus_space_handle_t)0;

a850 6
	if (bus_space_map(sc->sc_iot, PXA2X0_INTCTL_BASE,
	    PXA2X0_INTCTL_SIZE, 0, &intctl_ioh)) {
		printf("pxa2x0_apm_sleep: can't map INTCTL\n");
		goto out;
	}

d933 4
a936 4
	sd.sd_iclr = bus_space_read_4(sc->sc_iot, intctl_ioh, INTCTL_ICLR);
	sd.sd_icmr = bus_space_read_4(sc->sc_iot, intctl_ioh, INTCTL_ICMR);
	sd.sd_iccr = bus_space_read_4(sc->sc_iot, intctl_ioh, INTCTL_ICCR);
	bus_space_write_4(sc->sc_iot, intctl_ioh, INTCTL_ICMR, 0);
d964 1
a964 1
	/* Clear reset controller status. */
d966 3
a968 3
	    RCSR_HWR | RCSR_WDR | RCSR_SMR | RCSR_GPR);
	
	/* Stop 3/13Mhz oscillator, do not float PCMCIA and chip-selects. */
d1083 3
a1085 3
	bus_space_write_4(sc->sc_iot, intctl_ioh, INTCTL_ICLR, sd.sd_iclr);
	bus_space_write_4(sc->sc_iot, intctl_ioh, INTCTL_ICCR, sd.sd_iccr);
	bus_space_write_4(sc->sc_iot, intctl_ioh, INTCTL_ICMR, sd.sd_icmr);
d1087 1
a1087 1
	if ((bus_space_read_4(sc->sc_iot, intctl_ioh, INTCTL_ICIP) & 0x1) != 0)
a1120 2
	if (intctl_ioh != (bus_space_handle_t)0)
		bus_space_unmap(sc->sc_iot, intctl_ioh, PXA2X0_INTCTL_SIZE);
@


1.10
log
@extra gunk to make ohci suspend and resume work on the zaurus

help from and ok uwe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_apm.c,v 1.9 2005/03/29 23:17:45 uwe Exp $	*/
d81 1
a81 1
/* battery percentage at where we get verbose in our warnings.  This
d121 1
a121 1
/* This structure must be keept in sync with pxa2x0_apm_asm.S. */
d334 1
a334 1
	/* Periodic callbacks could be replaced with a machine-dependant
d1272 1
a1272 1
	    "high" : (value == PI2C_VOLTAGE_LOW ? "low" : "unkown"));
@


1.9
log
@Handle apm_battlow flag by suspending, and clear all flags after resume.
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_apm.c,v 1.8 2005/03/03 22:55:00 uwe Exp $	*/
d319 1
d321 6
a326 1
	dopowerhooks(PWR_RESUME);
@


1.8
log
@Support APM_IOC_PRN_CTL, and machdep.apmwarn as documented in apm(4), and
apmd(8); missing sysctl variable noticed by drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_apm.c,v 1.7 2005/02/28 13:21:17 uwe Exp $	*/
d79 1
a79 1
int	apm_battlow;		/* XXX unused */
a312 4
	/* Clear pending standby and suspend requests. */
	apm_userstandbys = 0;
	apm_suspends = 0;

a381 1
	/* Loop until all events are handled. */
d389 1
a389 6
	/*
	 * Counters for pending requests are cleared just before changing
	 * the processor run mode to avoid falling back to sleep after a
	 * wake-up event.
	 */
	if (apm_suspends || apm_userstandbys) {
d393 1
@


1.7
log
@Provide inittodr and resettodr for xscale, remove them from sa11x0, and
restore the time on resume.
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_apm.c,v 1.6 2005/02/24 21:06:02 drahn Exp $	*/
d81 7
a87 2
void	apm_power_info(struct pxa2x0_apm_softc *,
    struct apm_power_info *);
d90 2
d241 50
d327 54
d384 1
d386 7
a392 2
	if (sc->sc_periodic_check != NULL)
		sc->sc_periodic_check(sc);
@


1.6
log
@Workaround for a suspend problem when building on the zaurus.
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_apm.c,v 1.5 2005/02/23 02:08:01 uwe Exp $	*/
d203 1
a205 1
void	pxa2x0_pi2c_close(bus_space_tag_t, bus_space_handle_t);
d208 1
a208 1
void	pxa2x0_pi2c_printregs(bus_space_tag_t, bus_space_handle_t);
d210 1
d697 4
a700 1
	/* XXX schedule RTC alarm to check the battery? */
d930 1
a930 1
	/* XXX update ticks from RTC. */
d1150 1
d1160 2
@


1.5
log
@Make no distinction between standby and suspend requests for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_apm.c,v 1.4 2005/02/22 21:53:03 uwe Exp $	*/
d212 3
a214 3
bus_space_handle_t pxa2x0_gpio_ioh = 0;
bus_space_handle_t pxa2x0_clkman_ioh = 0;
bus_space_handle_t pxa2x0_memctl_ioh = 0;
@


1.4
log
@Initial suspend/resume code with additional powerhooks.  Enter/exit
suspend mode with power button or zzz.  May not work for everyone yet.
ok drahn@@ and deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_apm.c,v 1.3 2005/01/26 06:34:53 uwe Exp $	*/
a82 1
void	apm_standby(struct pxa2x0_apm_softc *);
a199 1
void	pxa2x0_apm_standby(struct pxa2x0_apm_softc *);
a246 27
apm_standby(struct pxa2x0_apm_softc *sc)
{

	dopowerhooks(PWR_STANDBY);

	if (cold)
		vfs_syncwait(0);

	/*
	 * Clear pending standby requests.  Do not enter standby mode if
	 * suspend was requested in the meantime.
	 */
	apm_userstandbys = 0;
	if (apm_suspends) {
		/*
		 * Arbitrary delay to avoid reinitializing some devices
		 * too fast, since PWR_RESUME hooks will be run before
		 * PWR_SUSPEND hooks.  Perhaps this is overly paranoid.
		 */
		delay(500000);
		return;
	}

	pxa2x0_apm_standby((struct pxa2x0_apm_softc *)sc);
}

void
d281 1
a281 1
	if (apm_suspends) {
a283 3
	} else if (apm_userstandbys) {
		apm_standby(sc);
		apm_resume(sc);
a614 8
}

void
pxa2x0_apm_standby(struct pxa2x0_apm_softc *sc)
{

	/* XXX standby mode is not supported. */
	delay(1000000);
@


1.3
log
@New device for the dedicated SSP unit, automatic battery charging, and
reporting the remaining battery life to apmd(8).
ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_apm.c,v 1.2 2005/01/20 23:34:36 uwe Exp $	*/
d57 1
d79 1
a79 1
int	apm_battlow;
a89 3
void	pxa2x0_apm_standby(struct pxa2x0_apm_softc *);
void	pxa2x0_apm_sleep(struct pxa2x0_apm_softc *);

d115 119
d257 15
a278 2
#if 0
	/* XXX something is not restored in PWR_RESUME. */
a279 3
#else
	dopowerhooks(PWR_STANDBY);
#endif
d284 4
d305 5
a310 2
		apm_userstandbys = 0;
		apm_suspends = 0;
a313 1
		apm_userstandbys = 0;
d471 1
a471 1
	return error;
d518 132
d652 36
d689 16
d708 259
a966 1
	/* XXX add power hooks elsewhere, first. */
d969 6
d978 1
a978 1
pxa2x0_apm_sleep(struct pxa2x0_apm_softc *sc)
d980 1
d982 10
a991 2
	/* XXX first make standby work, and then sleep mode. */
	pxa2x0_apm_standby(sc);
d995 22
a1016 1
pxa2x0_apm_attach_sub(struct pxa2x0_apm_softc *sc)
d1018 28
d1047 39
a1085 1
	sc->sc_iot = &pxa2x0_bs_tag;
d1087 54
a1140 4
	if (bus_space_map(sc->sc_iot, PXA2X0_POWMAN_BASE,
	    PXA2X0_POWMAN_SIZE, 0, &sc->sc_pm_ioh)) {
		printf("pxa2x0_apm_attach_sub: failed to map POWMAN\n");
		return;
d1142 6
d1149 36
a1184 1
	lockinit(&sc->sc_lock, PWAIT, "apmlk", 0, 0);
d1186 4
a1189 1
	kthread_create_deferred(apm_thread_create, sc);
d1191 3
a1193 1
	printf("\n");
@


1.2
log
@Enable apm/scoop drivers and report A/C power status correctly.
ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_apm.c,v 1.1 2005/01/19 02:02:34 uwe Exp $	*/
d80 2
a81 2
void	apm_battery_info(struct pxa2x0_apm_softc *,
    struct pxaapm_battery_info *);
d118 2
a119 2
apm_battery_info(struct pxa2x0_apm_softc *sc,
    struct pxaapm_battery_info *battp)
d122 7
a128 3
	bzero(battp, sizeof(struct pxaapm_battery_info));
	if (sc->sc_battery_info != NULL)
		sc->sc_battery_info(battp);
a278 1
	struct pxaapm_battery_info batt;
d331 1
a331 35

		apm_battery_info(sc, &batt);

		power->ac_state = ((batt.flags & PXAAPM_AC_PRESENT) ?
		    APM_AC_ON : APM_AC_OFF);
		power->battery_life =
		    ((batt.cur_charge * 100) / batt.max_charge);

		/*
		 * If the battery is charging, return the minutes left until
		 * charging is complete. apmd knows this.
		 */

		if (!(batt.flags & PXAAPM_BATT_PRESENT)) {
			power->battery_state = APM_BATT_UNKNOWN;
			power->minutes_left = 0;
			power->battery_life = 0;
		} else if ((power->ac_state == APM_AC_ON) &&
			   (batt.draw > 0)) {
			power->minutes_left =
			    (((batt.max_charge - batt.cur_charge) * 3600) /
			    batt.draw) / 60;
			power->battery_state = APM_BATT_CHARGING;
		} else {
			power->minutes_left =
			    ((batt.cur_charge * 3600) / (-batt.draw)) / 60;

			/* XXX - Arbitrary */
			if (power->battery_life > 60)
				power->battery_state = APM_BATT_HIGH;
			else if (power->battery_life < 10)
				power->battery_state = APM_BATT_CRITICAL;
			else
				power->battery_state = APM_BATT_LOW;
		}
@


1.1
log
@APM emulation framework and zaurus scoop driver.  Not enabled yet.
ok drahn@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.9 2003/10/16 03:54:48 deraadt Exp $	*/
a66 7
int	apmmatch(struct device *, void *, void *);
void	apmattach(struct device *, struct device *, void *);

struct cfattach apm_ca = {
	sizeof(struct pxa2x0_apm_softc), apmmatch, apmattach
};

d80 2
a116 6
int
apmmatch(struct device *parent, void *match, void *aux)
{
	return 1;
}

d118 2
a119 1
apmattach(struct device *parent, struct device *self, void *aux)
a120 1
	struct pxa2x0_apm_softc *sc = (struct pxa2x0_apm_softc *)self;
d122 3
a124 1
	pxa2x0_apm_attach_sub((struct pxa2x0_apm_softc *)sc);
d167 3
d275 1
a275 3
#if 0
	struct pmu_battery_info batt;
#endif
d329 1
a329 2
#if 0
		pm_battery_info(0, &batt);
d331 1
a331 1
		power->ac_state = ((batt.flags & PMU_PWR_AC_PRESENT) ?
a334 4
#else
		power->ac_state = APM_AC_ON;
		power->battery_life = 100;
#endif
d341 1
a341 2
#if 0
		if (!(batt.flags & PMU_PWR_BATT_PRESENT)) {
a362 5
#else
		power->battery_state = APM_BATT_UNKNOWN;
		power->minutes_left = 0;
		power->battery_life = 0;
#endif
@

