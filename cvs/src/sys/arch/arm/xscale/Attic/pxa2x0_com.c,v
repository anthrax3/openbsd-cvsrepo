head	1.13;
access;
symbols
	OPENBSD_6_0:1.12.0.24
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.12.0.20
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.12.0.22
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.14
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.12.0.18
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.12.0.16
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.12.0.12
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.12.0.10
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.8
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.6
	OPENBSD_5_0:1.12.0.4
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.2
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.9.0.8
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.4
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.6
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.2
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.8.0.2
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.7.0.12
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.10
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.8
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.6
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.4
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.2
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.3.0.2
	OPENBSD_3_7_BASE:1.3;
locks; strict;
comment	@ * @;


1.13
date	2016.09.03.13.37.42;	author guenther;	state dead;
branches;
next	1.12;
commitid	6T3r4QcMFKe3Fo5T;

1.12
date	2010.09.07.16.21.35;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2010.08.30.21.35.55;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2010.08.27.05.04.06;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2008.11.22.17.05.35;	author drahn;	state Exp;
branches;
next	1.8;

1.8
date	2008.05.15.22.17.08;	author brad;	state Exp;
branches;
next	1.7;

1.7
date	2005.07.18.00.50.19;	author uwe;	state Exp;
branches;
next	1.6;

1.6
date	2005.06.16.21.06.55;	author uwe;	state Exp;
branches;
next	1.5;

1.5
date	2005.05.27.18.42.15;	author uwe;	state Exp;
branches;
next	1.4;

1.4
date	2005.03.22.15.52.16;	author drahn;	state Exp;
branches;
next	1.3;

1.3
date	2005.01.04.02.08.41;	author drahn;	state Exp;
branches;
next	1.2;

1.2
date	2005.01.02.19.52.36;	author drahn;	state Exp;
branches;
next	1.1;

1.1
date	2004.12.30.23.50.07;	author drahn;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Retire zaurus, as it hasn't made the EABI jump and will be permanently broken
shortly when we use the hardware thread register in userland
@
text
@/*	$OpenBSD: pxa2x0_com.c,v 1.12 2010/09/07 16:21:35 deraadt Exp $ */
/*	$NetBSD: pxa2x0_com.c,v 1.4 2003/07/15 00:24:55 lukem Exp $	*/

/*
 * Copyright 2003 Wasabi Systems, Inc.
 * All rights reserved.
 *
 * Written by Steve C. Woodford for Wasabi Systems, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed for the NetBSD Project by
 *      Wasabi Systems, Inc.
 * 4. The name of Wasabi Systems, Inc. may not be used to endorse
 *    or promote products derived from this software without specific prior
 *    written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY WASABI SYSTEMS, INC. ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL WASABI SYSTEMS, INC
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef COM_PXA2X0
#error "You must use options COM_PXA2X0 to get PXA2x0 serial port support"
#endif

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/tty.h>

#include <machine/intr.h>
#include <machine/bus.h>

#include <dev/ic/comreg.h>
#include <dev/ic/comvar.h>

#define com_isr 8
#define ISR_RECV	(ISR_RXPL | ISR_XMODE | ISR_RCVEIR)

#include <arm/xscale/pxa2x0reg.h>
#include <arm/xscale/pxa2x0var.h>

#ifdef __zaurus__
#include <zaurus/dev/zaurus_scoopvar.h>
#endif

int	pxauart_match(struct device *, void *, void *);
void	pxauart_attach(struct device *, struct device *, void *);
int	pxauart_activate(struct device *, int);

struct cfattach com_pxaip_ca = {
        sizeof (struct com_softc), pxauart_match, pxauart_attach, NULL,
	pxauart_activate
};

int
pxauart_match(struct device *parent, void *cf, void *aux)
{
	struct pxaip_attach_args *pxa = aux;
	bus_space_tag_t bt = &pxa2x0_a4x_bs_tag;	/* XXX: This sucks */
	bus_space_handle_t bh;
	int rv;

	switch (pxa->pxa_addr) {
	case PXA2X0_FFUART_BASE:
		if (pxa->pxa_intr != PXA2X0_INT_FFUART)
			return (0);
		break;

	case PXA2X0_STUART_BASE:
		if (pxa->pxa_intr != PXA2X0_INT_STUART)
			return (0);
		break;

	case PXA2X0_BTUART_BASE:	/* XXX: Config file option ... */
		if (pxa->pxa_intr != PXA2X0_INT_BTUART)
			return (0);
		break;

	default:
		return (0);
	}

	pxa->pxa_size = 0x20;

	{
		extern bus_addr_t comconsaddr;

		if (comconsaddr == pxa->pxa_addr)
			return (1);
	}

	if (bus_space_map(bt, pxa->pxa_addr, pxa->pxa_size, 0, &bh))
		return (0);

	/* Make sure the UART is enabled */
	bus_space_write_1(bt, bh, com_ier, IER_EUART);

	rv = comprobe1(bt, bh);
	bus_space_unmap(bt, bh, pxa->pxa_size);

	return (rv);
}

void
pxauart_attach(struct device *parent, struct device *self, void *aux)
{
	struct com_softc *sc = (struct com_softc *)self;
	struct pxaip_attach_args *pxa = aux;

	sc->sc_iot = &pxa2x0_a4x_bs_tag;	/* XXX: This sucks */
	sc->sc_iobase = pxa->pxa_addr;
	sc->sc_frequency = PXA2X0_COM_FREQ;
	sc->sc_uarttype = COM_UART_PXA2X0;

#if 0
	if (com_is_console(sc->sc_iot, sc->sc_iobase, &sc->sc_ioh) == 0 &&
	    bus_space_map(sc->sc_iot, sc->sc_iobase, pxa->pxa_size, 0,
			  &sc->sc_ioh)) {
		printf(": can't map registers\n");
		return;
	}
#endif
	bus_space_map(sc->sc_iot, sc->sc_iobase, pxa->pxa_size, 0, &sc->sc_ioh);

	com_attach_subr(sc);

	(void)pxa2x0_intr_establish(pxa->pxa_intr, IPL_TTY, comintr,
	    sc, sc->sc_dev.dv_xname);
}

int
pxauart_activate(struct device *self, int act)
{
	struct com_softc *sc = (struct com_softc *)self;
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	struct tty *tp = sc->sc_tty;

	switch (act) {
	case DVACT_SUSPEND:
#ifdef __zaurus__
		if (sc->enabled && ISSET(sc->sc_hwflags, COM_HW_SIR))
			scoop_set_irled(0);
#endif
		break;
	case DVACT_RESUME:
		if (sc->enabled) {
			sc->sc_initialize = 1;
			comparam(tp, &tp->t_termios);
			bus_space_write_1(iot, ioh, com_ier, sc->sc_ier);

			if (ISSET(sc->sc_hwflags, COM_HW_SIR)) {
#ifdef __zaurus__
				scoop_set_irled(1);
#endif
				bus_space_write_1(iot, ioh, com_isr,
				    ISR_RECV);
			}
		}
		break;
	}
	return 0;
}
@


1.12
log
@remove the powerhook code.  All architectures now use the ca_activate tree
traversal code to suspend/resume
ok oga kettenis blambert
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_com.c,v 1.11 2010/08/30 21:35:55 deraadt Exp $ */
@


1.11
log
@Convert all powerhooks to activate functions, and provide powerhook stubs.
Of note:  lcd stubs get pulled up to the parent; zts has to keep track of
whether it is in use or not
testing by myself and jakemsr; proof reading by oga
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_com.c,v 1.10 2010/08/27 05:04:06 deraadt Exp $ */
a66 1
void	pxauart_powerhook(int why, void *);
a146 2

	(void)powerhook_establish(pxauart_powerhook, sc);
a180 6
}

void
pxauart_powerhook(int why, void *arg)
{
	pxauart_activate(arg, why);
@


1.10
log
@More killing of PWR_STANDBY.  cvs skipped these files
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_com.c,v 1.9 2008/11/22 17:05:35 drahn Exp $ */
d66 2
a67 1
void	pxauart_power(int why, void *);
d70 2
a71 1
        sizeof (struct com_softc), pxauart_match, pxauart_attach
d149 1
a149 1
	(void)powerhook_establish(&pxauart_power, sc);
d152 2
a153 2
void
pxauart_power(int why, void *arg)
d155 1
a155 1
	struct com_softc *sc = arg;
d160 2
a161 2
	switch (why) {
	case PWR_SUSPEND:
d167 1
a167 1
	case PWR_RESUME:
d183 7
@


1.9
log
@scoop is specific to zaurus, it should have some other mechansim to
make this associate, however ifdef zaurus it for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_com.c,v 1.8 2008/05/15 22:17:08 brad Exp $ */
a159 1
	case PWR_STANDBY:
@


1.8
log
@Remove commented out NetBSD __KERNEL_RCSID macro usage.

ok dlg@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_com.c,v 1.7 2005/07/18 00:50:19 uwe Exp $ */
d161 1
d164 1
d173 1
d175 1
@


1.7
log
@Initialize UART registers after resume, and make functions non-static.
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_com.c,v 1.6 2005/06/16 21:06:55 uwe Exp $ */
a37 5

#include <sys/cdefs.h>
/*
__KERNEL_RCSID(0, "$NetBSD: pxa2x0_com.c,v 1.4 2003/07/15 00:24:55 lukem Exp $");
*/
@


1.6
log
@unbust "com at pxaip" attachment so that there is no need to enable
"com at pcmcia" in RAMDISK as a workaround.
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_com.c,v 1.5 2005/05/27 18:42:15 uwe Exp $ */
d51 1
a51 1
#include <sys/termios.h>
d59 3
d65 7
a71 2
static int	pxauart_match(struct device *, void *, void *);
static void	pxauart_attach(struct device *, struct device *, void *);
d77 1
a77 1
static int
d126 1
a126 1
static void
d149 34
a182 2
	pxa2x0_intr_establish(pxa->pxa_intr, IPL_TTY, comintr, sc,
	    sc->sc_dev.dv_xname);
@


1.5
log
@- Merge changes from pxacom back into the common com driver.

Changes to the common com driver (partly from NetBSD):
- Multiply before divide in comspeed() to avoid overflow (from NetBSD).
- Don't call getc() and send -1 if the output queue is empty.
- Take UART clock frequency as a parameter instead of using COM_FREQ.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_com.c,v 1.4 2005/03/22 15:52:16 drahn Exp $ */
d65 1
a65 5
#ifdef __NetBSD__
CFATTACH_DECL(pxauart, sizeof(struct com_softc),
    pxauart_match, pxauart_attach, NULL, NULL);
#else
struct cfattach pxauart_ca = {
a67 5
	 
struct cfdriver pxauart_cd = {
	NULL, "pxauart", DV_DULL
};
#endif
@


1.4
log
@Use a sane interrupt priority for serial. Has a better chance of working.
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_com.c,v 1.3 2005/01/04 02:08:41 drahn Exp $ */
d56 2
a57 2
#include <arm/xscale/pxacomreg.h>
#include <arm/xscale/pxacomvar.h>
d136 1
@


1.3
log
@Add name argument to pxa2x0_intr_establish, which is standard for openbsd
interrupt handling.
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_com.c,v 1.2 2005/01/02 19:52:36 drahn Exp $ */
d149 1
a149 1
	pxa2x0_intr_establish(pxa->pxa_intr, IPL_SERIAL, comintr, sc,
@


1.2
log
@OpenBSD tags
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d149 2
a150 1
	pxa2x0_intr_establish(pxa->pxa_intr, IPL_SERIAL, comintr, sc);
@


1.1
log
@xscale bits, taken from NetBSD with modifications as appropriate for OpenBSD.
@
text
@d1 1
@

