head	1.29;
access;
symbols
	OPENBSD_6_0:1.28.0.2
	OPENBSD_6_0_BASE:1.28
	OPENBSD_5_9:1.27.0.2
	OPENBSD_5_9_BASE:1.27
	OPENBSD_5_8:1.26.0.8
	OPENBSD_5_8_BASE:1.26
	OPENBSD_5_7:1.26.0.2
	OPENBSD_5_7_BASE:1.26
	OPENBSD_5_6:1.26.0.4
	OPENBSD_5_6_BASE:1.26
	OPENBSD_5_5:1.23.0.8
	OPENBSD_5_5_BASE:1.23
	OPENBSD_5_4:1.23.0.4
	OPENBSD_5_4_BASE:1.23
	OPENBSD_5_3:1.23.0.2
	OPENBSD_5_3_BASE:1.23
	OPENBSD_5_2:1.22.0.4
	OPENBSD_5_2_BASE:1.22
	OPENBSD_5_1_BASE:1.22
	OPENBSD_5_1:1.22.0.2
	OPENBSD_5_0:1.21.0.4
	OPENBSD_5_0_BASE:1.21
	OPENBSD_4_9:1.21.0.2
	OPENBSD_4_9_BASE:1.21
	OPENBSD_4_8:1.20.0.4
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.20.0.2
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.18.0.4
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.17.0.4
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.17.0.2
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.15.0.4
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.15.0.2
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.14.0.2
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.13.0.2
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.12.0.4
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.2
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.9.0.2
	OPENBSD_3_7_BASE:1.9;
locks; strict;
comment	@ * @;


1.29
date	2016.09.03.13.37.42;	author guenther;	state dead;
branches;
next	1.28;
commitid	6T3r4QcMFKe3Fo5T;

1.28
date	2016.04.03.10.29.41;	author jsg;	state Exp;
branches;
next	1.27;
commitid	Wc8k8HnUtCtl1oqF;

1.27
date	2016.01.31.00.14.50;	author jsg;	state Exp;
branches;
next	1.26;
commitid	pbLjedMudUFrVMk6;

1.26
date	2014.07.12.18.44.41;	author tedu;	state Exp;
branches;
next	1.25;
commitid	uKVPYMN2MLxdZxzH;

1.25
date	2014.05.08.21.17.00;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2014.03.29.18.09.28;	author guenther;	state Exp;
branches;
next	1.23;

1.23
date	2012.12.05.23.20.11;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2011.09.20.22.02.13;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2010.09.20.06.33.47;	author matthew;	state Exp;
branches;
next	1.20;

1.20
date	2009.08.26.20.31.43;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2009.08.22.02.54.50;	author mk;	state Exp;
branches;
next	1.18;

1.18
date	2009.04.08.21.19.31;	author kettenis;	state Exp;
branches;
next	1.17;

1.17
date	2008.05.19.18.42.12;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2008.05.15.22.17.08;	author brad;	state Exp;
branches;
next	1.15;

1.15
date	2007.05.19.15.47.16;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2006.12.14.05.02.29;	author niallo;	state Exp;
branches;
next	1.13;

1.13
date	2006.03.07.22.35.57;	author uwe;	state Exp;
branches;
next	1.12;

1.12
date	2005.08.08.16.30.47;	author uwe;	state Exp;
branches;
next	1.11;

1.11
date	2005.05.27.20.21.15;	author uwe;	state Exp;
branches;
next	1.10;

1.10
date	2005.04.06.01.31.05;	author pascoe;	state Exp;
branches;
next	1.9;

1.9
date	2005.02.28.22.10.01;	author drahn;	state Exp;
branches;
next	1.8;

1.8
date	2005.02.23.00.01.09;	author drahn;	state Exp;
branches;
next	1.7;

1.7
date	2005.01.17.04.27.20;	author drahn;	state Exp;
branches;
next	1.6;

1.6
date	2005.01.13.17.59.32;	author drahn;	state Exp;
branches;
next	1.5;

1.5
date	2005.01.11.18.12.30;	author drahn;	state Exp;
branches;
next	1.4;

1.4
date	2005.01.04.23.43.22;	author drahn;	state Exp;
branches;
next	1.3;

1.3
date	2005.01.04.02.08.41;	author drahn;	state Exp;
branches;
next	1.2;

1.2
date	2005.01.02.19.52.36;	author drahn;	state Exp;
branches;
next	1.1;

1.1
date	2004.12.30.23.50.07;	author drahn;	state Exp;
branches;
next	;


desc
@@


1.29
log
@Retire zaurus, as it hasn't made the EABI jump and will be permanently broken
shortly when we use the hardware thread register in userland
@
text
@/*	$OpenBSD: pxa2x0_intr.c,v 1.28 2016/04/03 10:29:41 jsg Exp $ */
/*	$NetBSD: pxa2x0_intr.c,v 1.5 2003/07/15 00:24:55 lukem Exp $	*/

/*
 * Copyright (c) 2002  Genetec Corporation.  All rights reserved.
 * Written by Hiroyuki Bessho for Genetec Corporation.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed for the NetBSD Project by
 *	Genetec Corporation.
 * 4. The name of Genetec Corporation may not be used to endorse or 
 *    promote products derived from this software without specific prior
 *    written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY GENETEC CORPORATION ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL GENETEC CORPORATION
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * IRQ handler for the Intel PXA2X0 processor.
 * It has integrated interrupt controller.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/evcount.h>
#include <sys/queue.h>
#include <uvm/uvm_extern.h>

#include <machine/bus.h>
#include <machine/intr.h>

#include <arm/xscale/pxa2x0reg.h>
#include <arm/xscale/pxa2x0var.h>
#include <arm/xscale/pxa2x0_intr.h>
#include <arm/sa11x0/sa11x0_var.h>

/*
 * INTC autoconf glue
 */
int	pxaintc_match(struct device *, void *, void *);
void	pxaintc_attach(struct device *, struct device *, void *);

#ifdef __NetBSD__
CFATTACH_DECL(pxaintc, sizeof(struct device),
    pxaintc_match, pxaintc_attach, NULL, NULL);
#else
struct cfattach pxaintc_ca = {
        sizeof(struct device), pxaintc_match, pxaintc_attach
};

struct cfdriver pxaintc_cd = {
	NULL, "pxaintc", DV_DULL
};

#endif

static int pxaintc_attached;

int pxa2x0_stray_interrupt(void *);
void pxa2x0_init_interrupt_masks(void);

/*
 * interrupt dispatch table. 
 */
#if 1
#define MULTIPLE_HANDLERS_ON_ONE_IRQ
#endif
#ifdef MULTIPLE_HANDLERS_ON_ONE_IRQ
struct intrhand {
	TAILQ_ENTRY(intrhand)	ih_list;		/* link on intrq list */
	int 			(*ih_func)(void *);	/* handler */
	void 			*ih_arg;		/* arg for handler */
	char 			*ih_name;
	struct evcount  	ih_count;
	int 			ih_irq;
	int 			ih_level;
};
#endif

static struct intrhandler{
#ifdef MULTIPLE_HANDLERS_ON_ONE_IRQ
	TAILQ_HEAD(,intrhand) list;
#else
	pxa2x0_irq_handler_t func;
	char *name;
	void *arg;		/* NULL for stackframe */
	int ih_irq;
	struct evcount ih_count;
#endif
} handler[ICU_LEN];

volatile int softint_pending;
volatile int current_spl_level;
/* interrupt masks for each level */
int pxa2x0_imask[NIPL];
static int extirq_level[ICU_LEN];


int
pxaintc_match(struct device *parent, void *cf, void *aux)
{
	struct pxaip_attach_args *pxa = aux;

	if (pxaintc_attached || pxa->pxa_addr != PXA2X0_INTCTL_BASE)
		return (0);

	return (1);
}

void
pxaintc_attach(struct device *parent, struct device *self, void *args)
{
	int i;

	pxaintc_attached = 1;

	printf(": Interrupt Controller\n");

#define	SAIPIC_ICCR	0x14

	write_icu(SAIPIC_ICCR, 1);
	write_icu(SAIPIC_MR, 0);

	for(i = 0; i < sizeof handler / sizeof handler[0]; ++i){
#ifdef MULTIPLE_HANDLERS_ON_ONE_IRQ
		TAILQ_INIT(&handler[i].list);
		extirq_level[i] = IPL_NONE;
#else
		handler[i].name = "stray";
		handler[i].func = pxa2x0_stray_interrupt;
		handler[i].arg = (void *)(u_int32_t) i;
		extirq_level[i] = IPL_HIGH;
#endif

	}

	pxa2x0_init_interrupt_masks();

	_splraise(IPL_HIGH);
	enable_interrupts(PSR_I);
}

/*
 * Invoked very early on from the board-specific initarm(), in order to
 * inform us the virtual address of the interrupt controller's registers.
 */
vaddr_t pxaic_base;	
void
pxa2x0_intr_bootstrap(vaddr_t addr)
{

	pxaic_base = addr;
}

/*
 * PXA27x has MSL interface and SSP3 interrupts [0,1], USIM interface
 * and SSP2 interrupts [15,16]. PXA255 has bits [0..6,15] reserved and
 * bit [16] network SSP interrupt.  We don't need any of those, so we
 * map software interrupts to bits [0..1,15..16].  Sadly there are no
 * four contiguous bits safe enough to use on both processors.
 */
#define SI_TO_IRQBIT(si)  ((si) < 2 ? 1U<<(si) : 1U<<(15-2+(si)))

/*
 * Map a software interrupt queue to an interrupt priority level.
 */
static const int si_to_ipl[SI_NQUEUES] = {
	IPL_SOFT,		/* SI_SOFT */
	IPL_SOFTCLOCK,		/* SI_SOFTCLOCK */
	IPL_SOFTNET,		/* SI_SOFTNET */
	IPL_SOFTTTY,		/* SI_SOFTTTY */
};

/*
 * called from irq_entry.
 */
void
pxa2x0_irq_handler(void *arg)
{
	struct clockframe *frame = arg;
	uint32_t irqbits;
	int irqno;
	int saved_spl_level;
#ifdef MULTIPLE_HANDLERS_ON_ONE_IRQ
	struct intrhand *ih;
#endif

	saved_spl_level = current_spl_level;

	/* get pending IRQs */
	irqbits = read_icu(SAIPIC_IP);

	while ((irqno = find_first_bit(irqbits)) >= 0) {
		/* XXX: Should we handle IRQs in priority order? */

		/* raise spl to stop interrupts of lower priorities */
		if (saved_spl_level < extirq_level[irqno])
			pxa2x0_setipl(extirq_level[irqno]);

		/* Enable interrupt */
		enable_interrupts(PSR_I);

#ifndef MULTIPLE_HANDLERS_ON_ONE_IRQ
		(* handler[irqno].func)( 
			handler[irqno].arg == 0
			? frame : handler[irqno].arg );
		handler[irqno].ih_count.ec_count++;
#else
		TAILQ_FOREACH(ih, &handler[irqno].list, ih_list) {
			if ((ih->ih_func)( ih->ih_arg == 0
			    ? frame : ih->ih_arg))
				ih->ih_count.ec_count++;
		}
#endif
		
		/* Disable interrupt */
		disable_interrupts(PSR_I);

		irqbits &= ~(1<<irqno);
	}

	/* restore spl to that was when this interrupt happen */
	pxa2x0_setipl(saved_spl_level);
			
	if(softint_pending & pxa2x0_imask[current_spl_level])
		pxa2x0_do_pending();
}

int
pxa2x0_stray_interrupt(void *cookie)
{
	int irqno = (int)cookie;
	printf("stray interrupt %d\n", irqno);

	if (PXA2X0_IRQ_MIN <= irqno && irqno < ICU_LEN){
		int save = disable_interrupts(PSR_I);
		write_icu(SAIPIC_MR,
		    read_icu(SAIPIC_MR) & ~(1U<<irqno));
		restore_interrupts(save);
	}

	return 0;
}



/*
 * Interrupt Mask Handling
 */

#ifdef MULTIPLE_HANDLERS_ON_ONE_IRQ
void pxa2x0_update_intr_masks(void);

void
pxa2x0_update_intr_masks()
#else
void pxa2x0_update_intr_masks(int irqno, int level);

void
pxa2x0_update_intr_masks(int irqno, int irqlevel)
#endif
{
	int psw;

#ifdef MULTIPLE_HANDLERS_ON_ONE_IRQ
	int irq;
#ifdef DEBUG
	int level;
#endif
	struct intrhand *ih;
	psw = disable_interrupts(PSR_I);

	/* First figure out which levels each IRQ uses. */
	for (irq = 0; irq < ICU_LEN; irq++) {
		int i;
		int max = IPL_NONE;
		int min = IPL_HIGH;
		TAILQ_FOREACH(ih, &handler[irq].list, ih_list) {
			if (ih->ih_level > max)
				max = ih->ih_level;

			if (ih->ih_level < min)
				min = ih->ih_level;
		}

		extirq_level[irq] = max;

		if (min == IPL_HIGH)
			min = IPL_NONE;

		/* Enable interrupt at lower level */
		for(i = 0; i < min; ++i)
			pxa2x0_imask[i] |= (1 << irq);

		/* Disable interrupt at upper level */
		for( ; i < NIPL; ++i)
			pxa2x0_imask[i] &= ~(1 << irq);
	}

	/* fixup */
	pxa2x0_imask[IPL_NONE] |=
	    SI_TO_IRQBIT(SI_SOFT) |
	    SI_TO_IRQBIT(SI_SOFTCLOCK) |
	    SI_TO_IRQBIT(SI_SOFTNET) |
	    SI_TO_IRQBIT(SI_SOFTTTY);
	pxa2x0_imask[IPL_SOFT] |=
	    SI_TO_IRQBIT(SI_SOFTCLOCK) |
	    SI_TO_IRQBIT(SI_SOFTNET) |
	    SI_TO_IRQBIT(SI_SOFTTTY);
	pxa2x0_imask[IPL_SOFTCLOCK] |=
	    SI_TO_IRQBIT(SI_SOFTNET) |
	    SI_TO_IRQBIT(SI_SOFTTTY);
	pxa2x0_imask[IPL_SOFTNET] |=
	    SI_TO_IRQBIT(SI_SOFTTTY);
	pxa2x0_imask[IPL_SOFTTTY] |=
	    0;
#else
	int level; /* debug */
	int mask = 1U<<irqno;
	int i;
	psw = disable_interrupts(PSR_I);

	for(i = 0; i < irqlevel; ++i)
		pxa2x0_imask[i] |= mask; /* Enable interrupt at lower level */

	for( ; i < NIPL; ++i)
		pxa2x0_imask[i] &= ~mask; /* Disable interrupt at upper level */
#endif

	/*
	 * Enforce a hierarchy that gives "slow" device (or devices with
	 * limited input buffer space/"real-time" requirements) a better
	 * chance at not dropping data.
	 */
	pxa2x0_imask[IPL_BIO] &= pxa2x0_imask[IPL_SOFTNET];
	pxa2x0_imask[IPL_NET] &= pxa2x0_imask[IPL_BIO];
	pxa2x0_imask[IPL_SOFTTTY] &= pxa2x0_imask[IPL_NET];
	pxa2x0_imask[IPL_TTY] &= pxa2x0_imask[IPL_SOFTTTY];

	/*
	 * splvm() blocks all interrupts that use the kernel memory
	 * allocation facilities.
	 */
	pxa2x0_imask[IPL_VM] &= pxa2x0_imask[IPL_TTY];

	/*
	 * Audio devices are not allowed to perform memory allocation
	 * in their interrupt routines, and they have fairly "real-time"
	 * requirements, so give them a high interrupt priority.
	 */
	pxa2x0_imask[IPL_AUDIO] &= pxa2x0_imask[IPL_VM];

	/*
	 * splclock() must block anything that uses the scheduler.
	 */
	pxa2x0_imask[IPL_CLOCK] &= pxa2x0_imask[IPL_AUDIO];

	/*
	 * splhigh() must block "everything".
	 */
	pxa2x0_imask[IPL_HIGH] &= pxa2x0_imask[IPL_STATCLOCK];

#ifdef DEBUG
	for (level = IPL_NONE; level < NIPL; level++) {
		printf("imask %d, %x\n", level, pxa2x0_imask[level]);
	}
#endif

#ifdef MULTIPLE_HANDLERS_ON_ONE_IRQ
	for (irq = 0; irq < ICU_LEN; irq++) {
		int max_irq = IPL_NONE;
		TAILQ_FOREACH(ih, &handler[irq].list, ih_list) {
			if (ih->ih_level > max_irq) 
				max_irq  = ih->ih_level;
		}
		extirq_level[irq] = max_irq;
	}
#endif

	write_icu(SAIPIC_MR, pxa2x0_imask[current_spl_level]);

	restore_interrupts(psw);
}


void
pxa2x0_init_interrupt_masks(void)
{

	memset(pxa2x0_imask, 0, sizeof(pxa2x0_imask));

	/*
	 * IPL_NONE has soft interrupts enabled only, at least until
	 * hardware handlers are installed.
	 */
	pxa2x0_imask[IPL_NONE] =
	    SI_TO_IRQBIT(SI_SOFT) |
	    SI_TO_IRQBIT(SI_SOFTCLOCK) |
	    SI_TO_IRQBIT(SI_SOFTNET) |
	    SI_TO_IRQBIT(SI_SOFTTTY);

	/*
	 * Initialize the soft interrupt masks to block themselves.
	 */
	pxa2x0_imask[IPL_SOFT] = ~SI_TO_IRQBIT(SI_SOFT);
	pxa2x0_imask[IPL_SOFTCLOCK] = ~SI_TO_IRQBIT(SI_SOFTCLOCK);
	pxa2x0_imask[IPL_SOFTNET] = ~SI_TO_IRQBIT(SI_SOFTNET);
	pxa2x0_imask[IPL_SOFTTTY] = ~SI_TO_IRQBIT(SI_SOFTTTY);

	pxa2x0_imask[IPL_SOFT] &= pxa2x0_imask[IPL_NONE];

	/*
	 * splsoftclock() is the only interface that users of the
	 * generic software interrupt facility have to block their
	 * soft intrs, so splsoftclock() must also block IPL_SOFT.
	 */
	pxa2x0_imask[IPL_SOFTCLOCK] &= pxa2x0_imask[IPL_SOFT];

	/*
	 * splsoftnet() must also block splsoftclock(), since we don't
	 * want timer-driven network events to occur while we're
	 * processing incoming packets.
	 */
	pxa2x0_imask[IPL_SOFTNET] &= pxa2x0_imask[IPL_SOFTCLOCK];
}

void
pxa2x0_do_pending(void)
{
	int oldirqstate, spl_save;

	oldirqstate = disable_interrupts(PSR_I);

	spl_save = current_spl_level;

#define	DO_SOFTINT(si,ipl)						\
	if ((softint_pending & pxa2x0_imask[current_spl_level]) & 	\
	    SI_TO_IRQBIT(si)) {		\
		softint_pending &= ~SI_TO_IRQBIT(si);			\
		if (current_spl_level < ipl)				\
			pxa2x0_setipl(ipl);				\
		restore_interrupts(oldirqstate);			\
		softintr_dispatch(si);					\
		oldirqstate = disable_interrupts(PSR_I);		\
		pxa2x0_setipl(spl_save);				\
	}

	do {
		DO_SOFTINT(SI_SOFTTTY,IPL_SOFTTTY);
		DO_SOFTINT(SI_SOFTNET, IPL_SOFTNET);
		DO_SOFTINT(SI_SOFTCLOCK, IPL_SOFTCLOCK);
		DO_SOFTINT(SI_SOFT, IPL_SOFT);
	} while( softint_pending & pxa2x0_imask[current_spl_level] );

	restore_interrupts(oldirqstate);
}

#undef splx
void
splx(int ipl)
{

	pxa2x0_splx(ipl);
}

#undef _splraise
int
_splraise(int ipl)
{

	return pxa2x0_splraise(ipl);
}

#undef _spllower
int
_spllower(int ipl)
{

	return pxa2x0_spllower(ipl);
}

#undef _setsoftintr
void
_setsoftintr(int si)
{

	return pxa2x0_setsoftintr(si);
}

void *
pxa2x0_intr_establish(int irqno, int level,
    int (*func)(void *), void *arg, const char *name)
{
	int psw;
#ifdef MULTIPLE_HANDLERS_ON_ONE_IRQ
	struct intrhand *ih;
#else
	struct intrhandler *ih;
#endif

	if (irqno < PXA2X0_IRQ_MIN || irqno >= ICU_LEN)
		panic("intr_establish: bogus irq number %d", irqno);

	psw = disable_interrupts(PSR_I);

#ifdef MULTIPLE_HANDLERS_ON_ONE_IRQ
	/* no point in sleeping unless someone can free memory. */
	ih = (struct intrhand *)malloc(sizeof *ih, M_DEVBUF, 
	    cold ? M_NOWAIT : M_WAITOK);
	if (ih == NULL)
		panic("intr_establish: can't malloc handler info");
        ih->ih_func = func;
	ih->ih_arg = arg;
	ih->ih_level = level;
	ih->ih_irq = irqno;

	TAILQ_INSERT_TAIL(&handler[irqno].list, ih, ih_list);
#else
	ih = &handler[irqno];
	ih->arg = arg;
	ih->func = func;
	ih->name = name;
	ih->ih_irq = irqno;
	extirq_level[irqno] = level;
#endif

	if (name != NULL)
		evcount_attach(&ih->ih_count, name, &ih->ih_irq);

#ifdef MULTIPLE_HANDLERS_ON_ONE_IRQ
	pxa2x0_update_intr_masks();
#else
	pxa2x0_update_intr_masks(irqno, level);
#endif

	restore_interrupts(psw);

	return (ih);
}

void
pxa2x0_intr_disestablish(void *cookie)
{

#ifdef MULTIPLE_HANDLERS_ON_ONE_IRQ
	int psw;
	struct intrhand *ih = cookie;
	int irqno =  ih->ih_irq;

	psw = disable_interrupts(PSR_I);
	TAILQ_REMOVE(&handler[irqno].list, ih, ih_list);

	free(ih, M_DEVBUF, 0);

	pxa2x0_update_intr_masks();

	restore_interrupts(psw);
#else
	struct intrhandler *lhandler = cookie;
	int irqno;
	int psw;
	struct intrhandler *ih;
	irqno = lhandler - handler;

	if (irqno < PXA2X0_IRQ_MIN || irqno >= ICU_LEN)
		panic("intr_disestablish: bogus irq number %d", irqno);

	psw = disable_interrupts(PSR_I);

	ih = &handler[irqno];
	if (ih->name != NULL)
		evcount_detach(&ih->ih_count);

	ih->arg = (void *) irqno;
	ih->func = pxa2x0_stray_interrupt;
	ih->name = "stray";
	extirq_level[irqno] = IPL_HIGH;
	pxa2x0_update_intr_masks(irqno, IPL_HIGH);

	restore_interrupts(psw);
#endif
}

/*
 * Glue for drivers of sa11x0 compatible integrated logic.
 */
void *
sa11x0_intr_establish(sa11x0_chipset_tag_t ic, int irq, int type, int level,
    int (*ih_fun)(void *), void *ih_arg, const char *name)
{

	return pxa2x0_intr_establish(irq, level, ih_fun, ih_arg, name);
}

void
pxa2x0_setipl(int new)
{
	u_int32_t intr_mask;

	intr_mask = pxa2x0_imask[new];
	current_spl_level = new;
	write_icu( SAIPIC_MR, intr_mask );
}


void
pxa2x0_splx(int new)
{
	int psw;

	psw = disable_interrupts(PSR_I);
	pxa2x0_setipl(new);
	restore_interrupts(psw);

	/* If there are pending software interrupts, process them. */
	if (softint_pending & pxa2x0_imask[current_spl_level])
		pxa2x0_do_pending();
}


int
pxa2x0_splraise(int ipl)
{
	int	old, psw;

	old = current_spl_level;
	if( ipl > current_spl_level ){
		psw = disable_interrupts(PSR_I);
		pxa2x0_setipl(ipl);
		restore_interrupts(psw);
	}

	return (old);
}

int
pxa2x0_spllower(int ipl)
{
	int old = current_spl_level;
	int psw = disable_interrupts(PSR_I);
	pxa2x0_splx(ipl);
	restore_interrupts(psw);
	return(old);
}

void
pxa2x0_setsoftintr(int si)
{
	softint_pending |=  SI_TO_IRQBIT(si);

	/* Process unmasked pending soft interrupts. */
	if ( softint_pending & pxa2x0_imask[current_spl_level] )
		pxa2x0_do_pending();
}

const char *
pxa2x0_intr_string(void *cookie)
{
#ifdef MULTIPLE_HANDLERS_ON_ONE_IRQ
	struct intrhand *ih = cookie;
#else
	struct intrhandler *lhandler = cookie;
#endif
	static char irqstr[32];

	if (ih == NULL)
		snprintf(irqstr, sizeof irqstr, "couldn't establish interrupt");
	else
		snprintf(irqstr, sizeof irqstr, "irq %d", ih->ih_irq);

	return irqstr;
}

#ifdef DIAGNOSTIC
void
pxa2x0_splassert_check(int wantipl, const char *func)
{
	int oldipl = current_spl_level, psw;

	if (oldipl < wantipl) {
		splassert_fail(wantipl, oldipl, func);
		/*
		 * If the splassert_ctl is set to not panic, raise the ipl
		 * in a feeble attempt to reduce damage.
		 */
		psw = disable_interrupts(PSR_I);
		pxa2x0_setipl(wantipl);
		restore_interrupts(psw);
	}
}
#endif
@


1.28
log
@Remove tests for "processing" which was never set.  It attempted to
protect against multiple entries of a function that handled pending
soft interrupts.  This seems to have been a mistake made when converting
code that used simple lock in the 80321 code which got reused in armv7.

arm softintr_dispatch() already has mutexes around invoked callbacks
which should be enough.  Make the pxa2x0 code work the same way which
removes the last remaining simple lock use on arm.

ok patrick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_intr.c,v 1.27 2016/01/31 00:14:50 jsg Exp $ */
@


1.27
log
@Switch from PSR_X_bit and X32_bit PSR macro names to just PSR_X.
This matches FreeBSD and makes things a bit more consistent.
Discussed with Patrick.
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_intr.c,v 1.26 2014/07/12 18:44:41 tedu Exp $ */
a50 1
#include <machine/lock.h>
a449 1
	static __cpu_simple_lock_t processing = __SIMPLELOCK_UNLOCKED;
d452 1
a452 2
	if (__cpu_simple_lock_try(&processing) == 0)
		return;
a455 3
	oldirqstate = disable_interrupts(PSR_I);

#if 1
a473 13
#else
	while( (si = find_first_bit(softint_pending & pxa2x0_imask[current_spl_level])) >= 0 ){
		softint_pending &= ~SI_TO_IRQBIT(si);
		if (current_spl_level < ipl)
			pxa2x0_setipl(ipl);
		restore_interrupts(oldirqstate);
		softintr_dispatch(si);
		oldirqstate = disable_interrupts(PSR_I);
		pxa2x0_setipl(spl_save);
	}
#endif

	__cpu_simple_unlock(&processing);
a476 1

@


1.26
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_intr.c,v 1.25 2014/05/08 21:17:00 miod Exp $ */
d161 1
a161 1
	enable_interrupts(I32_bit);
d222 1
a222 1
		enable_interrupts(I32_bit);
d238 1
a238 1
		disable_interrupts(I32_bit);
d257 1
a257 1
		int save = disable_interrupts(I32_bit);
d292 1
a292 1
	psw = disable_interrupts(I32_bit);
d342 1
a342 1
	psw = disable_interrupts(I32_bit);
d459 1
a459 1
	oldirqstate = disable_interrupts(I32_bit);
d470 1
a470 1
		oldirqstate = disable_interrupts(I32_bit);		\
d487 1
a487 1
		oldirqstate = disable_interrupts(I32_bit);
d544 1
a544 1
	psw = disable_interrupts(I32_bit);
d590 1
a590 1
	psw = disable_interrupts(I32_bit);
d608 1
a608 1
	psw = disable_interrupts(I32_bit);
d651 1
a651 1
	psw = disable_interrupts(I32_bit);
d668 1
a668 1
		psw = disable_interrupts(I32_bit);
d680 1
a680 1
	int psw = disable_interrupts(I32_bit);
d726 1
a726 1
		psw = disable_interrupts(I32_bit);
@


1.25
log
@Format string fixes and removal of -Wno-format for arm kernels.
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_intr.c,v 1.24 2014/03/29 18:09:28 guenther Exp $ */
d593 1
a593 1
	free(ih, M_DEVBUF);
@


1.24
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_intr.c,v 1.23 2012/12/05 23:20:11 deraadt Exp $ */
d709 1
a709 1
		snprintf(irqstr, sizeof irqstr, "irq %ld", ih->ih_irq);
@


1.23
log
@Remove excessive sys/cdefs.h inclusion
ok guenther millert kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_intr.c,v 1.22 2011/09/20 22:02:13 miod Exp $ */
d113 2
a114 2
__volatile int softint_pending;
__volatile int current_spl_level;
@


1.22
log
@Late spring cleaning of the arm code for old dusty bits we do not want to
keep:
- remove bootconfig parameter passing feature (unused).
- unifdef __PROG32 and remove all remains of arm26 code.
- remove ARMFPE support (unused).
- remove support for ARM2, ARM2AS, ARM3, ARM6, ARM7, ARM7TDMI and StrongARM
  processor families, and the related silicon bug workarounds (especially
  the SA-110 STM^ bug).
- remove cpu_functions no longer necessary after previous removals.
- remove ARM32_DISABLE_ALIGNMENT_FAULTS option (unused).
- make FIQ support conditional on option FIQ (unused, but may be eventually).

Discussed with drahn@@ and jasper@@ long ago, I was sitting on this commit for
no good reason.
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_intr.c,v 1.21 2010/09/20 06:33:47 matthew Exp $ */
a40 2

#include <sys/cdefs.h>
@


1.21
log
@Get rid of evcount's support for arranging counters in a tree
hierarchy.  Everything attached to a single root node anyway, so at
best we had a bush.

"i think it is good" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_intr.c,v 1.20 2009/08/26 20:31:43 deraadt Exp $ */
a690 3
#if 0
	atomic_set_bit( (u_int *)&softint_pending, SI_TO_IRQBIT(si) );
#else
a691 1
#endif
@


1.20
log
@more bloody const crap mk broke
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_intr.c,v 1.19 2009/08/22 02:54:50 mk Exp $ */
d570 1
a570 2
		evcount_attach(&ih->ih_count, name, (void *)&ih->ih_irq,
		    &evcount_intr);
@


1.19
log
@Constify the what/name parameter of pci_intr_establish().

Tested by myself, sthen, oga, kettenis, and jasper.
Input from sthen and jasper.

ok kettenis

(Manpage follows shortly.)
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_intr.c,v 1.18 2009/04/08 21:19:31 kettenis Exp $ */
d632 1
a632 1
    int (*ih_fun)(void *), void *ih_arg, char *name)
@


1.18
log
@Cleanup arm soft interrupt handling; remove the unused IPL_SERIAL and rename
IPL_SOFTSERIAL to IPL_SOFTTTY.

tested by oga@@
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_intr.c,v 1.17 2008/05/19 18:42:12 miod Exp $ */
d534 1
a534 1
    int (*func)(void *), void *arg, char *name)
@


1.17
log
@Change all remaining MD uses of MALLOC and FREE into proper malloc() and
free() calls; prodded by chl@@, ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_intr.c,v 1.16 2008/05/15 22:17:08 brad Exp $ */
d155 1
a155 1
		extirq_level[i] = IPL_SERIAL;
d162 1
a162 1
	_splraise(IPL_SERIAL);
d194 1
a194 1
	IPL_SOFTSERIAL,		/* SI_SOFTSERIAL */
d300 1
a300 1
		int min = IPL_HIGH; /* XXX kill IPL_SERIAL */
d319 1
a319 1
		for( ; i < NIPL-1; ++i)
d328 1
a328 1
	    SI_TO_IRQBIT(SI_SOFTSERIAL);
d332 1
a332 1
	    SI_TO_IRQBIT(SI_SOFTSERIAL);
d335 1
a335 1
	    SI_TO_IRQBIT(SI_SOFTSERIAL);
d337 2
a338 2
	    SI_TO_IRQBIT(SI_SOFTSERIAL);
	pxa2x0_imask[IPL_SOFTSERIAL] |=
d349 1
a349 1
	for( ; i < NIPL-1; ++i)
d360 2
a361 2
	pxa2x0_imask[IPL_SOFTSERIAL] &= pxa2x0_imask[IPL_NET];
	pxa2x0_imask[IPL_TTY] &= pxa2x0_imask[IPL_SOFTSERIAL];
a385 6
	/*
	 * XXX We need serial drivers to run at the absolute highest priority
	 * in order to avoid overruns, so serial > high.
	 */
	pxa2x0_imask[IPL_SERIAL] &= pxa2x0_imask[IPL_HIGH];

d423 1
a423 1
	    SI_TO_IRQBIT(SI_SOFTSERIAL);
d431 1
a431 1
	pxa2x0_imask[IPL_SOFTSERIAL] = ~SI_TO_IRQBIT(SI_SOFTSERIAL);
d477 1
a477 1
		DO_SOFTINT(SI_SOFTSERIAL,IPL_SOFTSERIAL);
d620 2
a621 2
	extirq_level[irqno] = IPL_SERIAL;
	pxa2x0_update_intr_masks(irqno, IPL_SERIAL);
@


1.16
log
@Remove commented out NetBSD __KERNEL_RCSID macro usage.

ok dlg@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_intr.c,v 1.15 2007/05/19 15:47:16 miod Exp $ */
d556 1
a556 1
	MALLOC(ih, struct intrhand *, sizeof *ih, M_DEVBUF, 
d602 1
a602 1
	FREE(ih, M_DEVBUF);
@


1.15
log
@Implement splassert for armish and zaurus.
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_intr.c,v 1.14 2006/12/14 05:02:29 niallo Exp $ */
a40 5

#include <sys/cdefs.h>
/*
__KERNEL_RCSID(0, "$NetBSD: pxa2x0_intr.c,v 1.5 2003/07/15 00:24:55 lukem Exp $");
*/
@


1.14
log
@- enable nested interrupts on zaurus.  most obvious side-effect of this is
  likely that interrupts are properly counted in kern.cp_time sysctl.  so top(1)
  et al will show a value for time spent in interrupts.

tested by many, ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_intr.c,v 1.13 2006/03/07 22:35:57 uwe Exp $ */
d731 19
@


1.13
log
@Fix collision between SI_SOFTSERIAL and OS timers in the interrupt mask.
The new allocation of softintr bits complicates SI_TO_IRQBIT, but I see
no safe way around it.
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_intr.c,v 1.12 2005/08/08 16:30:47 uwe Exp $ */
a227 1
#ifdef notyet
d229 2
a230 1
#endif
a243 1
#ifdef notyet
d245 1
a245 1
#endif
@


1.12
log
@Avoid overlap in USB hard and the soft interrupt bits, update comments
to reflect the new allocation of IRQ bits, and zap duplicate definition
of SI_TO_IRQBIT; help/test niallo@@ ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_intr.c,v 1.11 2005/05/27 20:21:15 uwe Exp $ */
d184 5
a188 2
 * Cotulla's integrated ICU doesn't have IRQ0..7, PXA27x has useful
 * interrupts 0..3, so we map software interrupts to bit 4..7.
d190 1
a190 1
#define SI_TO_IRQBIT(si)  (1U<<(4+(si)))
@


1.11
log
@Dale's lost diff for IRQ sharing, turned on by default.
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_intr.c,v 1.10 2005/04/06 01:31:05 pascoe Exp $ */
d183 5
a645 6

/*
 * Cotulla's integrated ICU doesn't have IRQ0..7, so
 * we map software interrupts to bit 0..3
 */
#define SI_TO_IRQBIT(si)  (1U<<(si))
@


1.10
log
@spelling/grammar cleanups

jolan drahn uwe dlg ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_intr.c,v 1.9 2005/02/28 22:10:01 drahn Exp $ */
d53 1
d93 3
d98 7
a104 3
	TAILQ_ENTRY(intrhand) ih_list;	/* link on intrq list */
	int (*ih_func)(void *);		/* handler */
	void *ih_arg;			/* arg for handler */
d113 1
a113 1
#endif
a114 2
	/* struct evbnt ev; */
	char *name;
d117 1
d153 4
d160 2
a162 1
		extirq_level[i] = IPL_SERIAL;
d204 3
d229 5
a233 2
		/* process all handlers for this interrupt.
		   XXX not yet */
d272 3
d276 7
a282 1
pxa2x0_update_intr_masks(int irqno, int level)
d284 56
a340 1
	int psw = disable_interrupts(I32_bit);
d342 1
d344 1
a344 1
	for(i = 0; i < level; ++i)
d349 1
d390 17
d541 3
d545 1
d552 13
d571 1
d577 3
d581 1
d591 15
a609 1

d628 1
d711 18
@


1.9
log
@Store interrupt state in one variable not two, remove inlines which
signficantly bloat kernel. tested/ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_intr.c,v 1.8 2005/02/23 00:01:09 drahn Exp $ */
d199 1
a199 1
		/* XXX: Shuould we handle IRQs in priority order? */
d265 1
a265 1
		pxa2x0_imask[i] &= ~mask; /* Disable itnerrupt at upper level */
d268 1
a268 1
	 * Enforce a heirarchy that gives "slow" device (or devices with
d494 1
a494 1
 * Glue for drivers of sa11x0 compatible integrated logics.
d530 1
a530 1
	/* If there are software interrupts to process, do it. */
@


1.8
log
@Move code from zaurus machdep to arm/xscale to live with the interrupt
handler where it belongs code had been de-inlined to the wrong file.
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_intr.c,v 1.7 2005/01/17 04:27:20 drahn Exp $ */
d111 1
a111 2
}
handler[ICU_LEN];
a114 1
__volatile int intr_mask;
d228 1
a228 1
	if(softint_pending & intr_mask)
d368 2
a369 1
	if ((softint_pending & intr_mask) & SI_TO_IRQBIT(si)) {		\
d376 1
a376 1
		pxa2x0_setipl(spl_save);					\
d384 1
a384 1
	} while( softint_pending & intr_mask );
d386 1
a386 1
	while( (si = find_first_bit(softint_pending & intr_mask)) >= 0 ){
a459 2
	intr_mask = pxa2x0_imask[current_spl_level];
	
d464 1
a489 2
	intr_mask = pxa2x0_imask[current_spl_level];
	
d513 3
a516 1
	intr_mask = pxa2x0_imask[current_spl_level];
d531 1
a531 1
	if (softint_pending & intr_mask)
d571 1
a571 1
	if ( softint_pending & intr_mask )
@


1.7
log
@Interrupts which are handled by the second level interrupt handler gpio
should not have two counters triggered for each interrupt.
add a flag, name == NULL to pxa_intr to indicate that the event counter
should not be register for such interrupts.
In gpio, register its interrupts with this indication, however it
should count the gpio0 and gpio1 interrupts which are registered.
requested deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_intr.c,v 1.6 2005/01/13 17:59:32 drahn Exp $ */
d506 69
@


1.6
log
@destatic/inline
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_intr.c,v 1.5 2005/01/11 18:12:30 drahn Exp $ */
d455 3
a457 1
	evcount_attach(&ih->ih_count, name, (void *)&ih->ih_irq, &evcount_intr);
d483 2
a484 1
	evcount_detach(&ih->ih_count);
@


1.5
log
@first cut at interrupt stats.
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_intr.c,v 1.4 2005/01/04 23:43:22 drahn Exp $ */
d67 2
a68 2
static int	pxaintc_match(struct device *, void *, void *);
static void	pxaintc_attach(struct device *, struct device *, void *);
d86 2
a87 2
static int stray_interrupt(void *);
static void init_interrupt_masks(void);
d122 1
a122 1
static int
d149 1
a149 1
		handler[i].func = stray_interrupt;
d155 1
a155 1
	init_interrupt_masks();
a172 8
static __inline void
__raise(int ipl)
{

	if (current_spl_level < ipl)
		pxa2x0_setipl(ipl);
}

d234 2
a235 2
static int
stray_interrupt(void *cookie)
d314 2
a315 2
static void
init_interrupt_masks(void)
d370 1
a370 1
	if ((softint_pending & intr_mask) & SI_TO_IRQBIT(si)) {	\
d372 2
a373 1
                __raise(ipl);                                           \
d389 2
a390 1
		__raise(si_to_ipl(si));
d484 1
a484 1
	ih->func = stray_interrupt;
@


1.4
log
@implement intr_disestablish.
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_intr.c,v 1.3 2005/01/04 02:08:41 drahn Exp $ */
d52 1
d109 2
d222 1
d447 1
d454 5
a458 3
	handler[irqno].arg = arg;
	handler[irqno].func = func;
	handler[irqno].name = name;
d460 3
d469 1
a469 1
	return (&handler[irqno]);
d477 1
d486 6
a491 3
	handler[irqno].arg = (void *) irqno;
	handler[irqno].func = stray_interrupt;
	handler[irqno].name = "stray";
@


1.3
log
@Add name argument to pxa2x0_intr_establish, which is standard for openbsd
interrupt handling.
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_intr.c,v 1.2 2005/01/02 19:52:36 drahn Exp $ */
d99 1
a99 1
static struct {
d105 1
a105 1
	void *cookie;		/* NULL for stackframe */
d108 2
a109 1
} handler[ICU_LEN];
d145 1
d147 2
a148 1
		handler[i].cookie = (void *)(u_int32_t) i;
d217 2
a218 2
			handler[irqno].cookie == 0
			? frame : handler[irqno].cookie );
d440 1
a440 1
    int (*func)(void *), void *cookie, char *name)
d449 1
a449 1
	handler[irqno].cookie = cookie;
d460 24
@


1.2
log
@OpenBSD tags
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d107 1
d437 1
a437 1
    int (*func)(void *), void *cookie)
d448 1
d464 1
a464 1
    int (*ih_fun)(void *), void *ih_arg)
d467 1
a467 1
	return pxa2x0_intr_establish(irq, level, ih_fun, ih_arg);
@


1.1
log
@xscale bits, taken from NetBSD with modifications as appropriate for OpenBSD.
@
text
@d1 1
@

