head	1.14;
access;
symbols
	OPENBSD_6_0:1.14.0.10
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.14.0.6
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.14.0.8
	OPENBSD_5_8_BASE:1.14
	OPENBSD_5_7:1.14.0.2
	OPENBSD_5_7_BASE:1.14
	OPENBSD_5_6:1.14.0.4
	OPENBSD_5_6_BASE:1.14
	OPENBSD_5_5:1.13.0.20
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.13.0.16
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.13.0.14
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.12
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.10
	OPENBSD_5_0:1.13.0.8
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.6
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.4
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.2
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.12.0.4
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.11.0.8
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.6
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.4
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.2
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.9.0.6
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.4
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.2
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.8.0.2
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.6.0.2
	OPENBSD_3_7_BASE:1.6;
locks; strict;
comment	@ * @;


1.14
date	2014.03.29.18.09.28;	author guenther;	state Exp;
branches;
next	1.13;

1.13
date	2009.08.26.20.31.43;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2009.03.15.19.40.40;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2007.05.19.15.47.16;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2007.05.15.05.26.44;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2005.09.22.04.14.44;	author drahn;	state Exp;
branches;
next	1.8;

1.8
date	2005.08.08.16.30.47;	author uwe;	state Exp;
branches;
next	1.7;

1.7
date	2005.05.27.20.21.15;	author uwe;	state Exp;
branches;
next	1.6;

1.6
date	2005.02.28.22.10.01;	author drahn;	state Exp;
branches;
next	1.5;

1.5
date	2005.01.14.00.56.22;	author drahn;	state Exp;
branches;
next	1.4;

1.4
date	2005.01.04.23.37.13;	author drahn;	state Exp;
branches;
next	1.3;

1.3
date	2005.01.04.02.08.41;	author drahn;	state Exp;
branches;
next	1.2;

1.2
date	2005.01.02.19.52.36;	author drahn;	state Exp;
branches;
next	1.1;

1.1
date	2004.12.30.23.50.07;	author drahn;	state Exp;
branches;
next	;


desc
@@


1.14
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@/*	$OpenBSD: pxa2x0_intr.h,v 1.13 2009/08/26 20:31:43 deraadt Exp $ */
/*	$NetBSD: pxa2x0_intr.h,v 1.4 2003/07/05 06:53:08 dogcow Exp $ */

/* Derived from i80321_intr.h */

/*
 * Copyright (c) 2001, 2002 Wasabi Systems, Inc.
 * All rights reserved.
 *
 * Written by Jason R. Thorpe for Wasabi Systems, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed for the NetBSD Project by
 *	Wasabi Systems, Inc.
 * 4. The name of Wasabi Systems, Inc. may not be used to endorse
 *    or promote products derived from this software without specific prior
 *    written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY WASABI SYSTEMS, INC. ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL WASABI SYSTEMS, INC
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef _PXA2X0_INTR_H_
#define _PXA2X0_INTR_H_

#define	ARM_IRQ_HANDLER	_C_LABEL(pxa2x0_irq_handler)

#ifndef _LOCORE

#include <arm/armreg.h>
#include <arm/cpufunc.h>
#include <arm/softintr.h>

extern vaddr_t pxaic_base;		/* Shared with pxa2x0_irq.S */
#define read_icu(offset) (*(volatile uint32_t *)(pxaic_base+(offset)))
#define write_icu(offset,value) \
 (*(volatile uint32_t *)(pxaic_base+(offset))=(value))

extern volatile int current_spl_level;
extern volatile int softint_pending;
extern int pxa2x0_imask[];
void pxa2x0_do_pending(void);

void pxa2x0_setipl(int new);
void pxa2x0_splx(int new);
int pxa2x0_splraise(int ipl);
int pxa2x0_spllower(int ipl);
void pxa2x0_setsoftintr(int si);


/*
 * An useful function for interrupt handlers.
 * XXX: This shouldn't be here.
 */
static __inline int
find_first_bit( uint32_t bits )
{
	int count;

	/* since CLZ is available only on ARMv5, this isn't portable
	 * to all ARM CPUs.  This file is for PXA2[15]0 processor. 
	 */
	asm( "clz %0, %1" : "=r" (count) : "r" (bits) );
	return 31-count;
}


int	_splraise(int);
int	_spllower(int);
void	splx(int);
void	_setsoftintr(int);

/*
 * This function *MUST* be called very early on in a port's
 * initarm() function, before ANY spl*() functions are called.
 *
 * The parameter is the virtual address of the PXA2x0's Interrupt
 * Controller registers.
 */
void pxa2x0_intr_bootstrap(vaddr_t);

void pxa2x0_irq_handler(void *);
void *pxa2x0_intr_establish(int irqno, int level, int (*func)(void *),
    void *cookie, const char *name);
void pxa2x0_intr_disestablish(void *cookie);
const char *pxa2x0_intr_string(void *cookie);

#ifdef DIAGNOSTIC
/*
 * Although this function is implemented in MI code, it must be in this MD
 * header because we don't want this header to include MI includes.
 */
void splassert_fail(int, int, const char *);
extern int splassert_ctl;
void pxa2x0_splassert_check(int, const char *);
#define splassert(__wantipl) do {				\
	if (splassert_ctl > 0) {				\
		pxa2x0_splassert_check(__wantipl, __func__);	\
	}							\
} while (0)
#define splsoftassert(wantipl) splassert(wantipl)
#else
#define	splassert(wantipl)	do { /* nothing */ } while (0)
#define	splsoftassert(wantipl)	do { /* nothing */ } while (0)
#endif

#endif /* ! _LOCORE */

#endif /* _PXA2X0_INTR_H_ */
@


1.13
log
@more bloody const crap mk broke
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_intr.h,v 1.12 2009/03/15 19:40:40 miod Exp $ */
d57 2
a58 2
extern __volatile int current_spl_level;
extern __volatile int softint_pending;
@


1.12
log
@Introduce splsoftassert(), similar to splassert() but for soft interrupt
levels. This will allow for platforms where soft interrupt levels do not
map to real hardware interrupt levels to have soft ipl values overlapping
hard ipl values without breaking spl asserts.
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_intr.h,v 1.11 2007/05/19 15:47:16 miod Exp $ */
d102 1
a102 1
    void *cookie, char *name);
@


1.11
log
@Implement splassert for armish and zaurus.
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_intr.h,v 1.10 2007/05/15 05:26:44 miod Exp $ */
d119 1
d122 1
@


1.10
log
@Dummy mutex code for arm platforms. ok drahn@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_intr.h,v 1.9 2005/09/22 04:14:44 drahn Exp $ */
d106 17
a123 2

#define splassert(wantipl) do { /* nada */ } while (0)
@


1.9
log
@NEWINTR is not an option on OpenBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_intr.h,v 1.8 2005/08/08 16:30:47 uwe Exp $ */
a49 1
#include <machine/intr.h>
d108 2
a110 1

@


1.8
log
@Avoid overlap in USB hard and the soft interrupt bits, update comments
to reflect the new allocation of IRQ bits, and zap duplicate definition
of SI_TO_IRQBIT; help/test niallo@@ ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_intr.h,v 1.7 2005/05/27 20:21:15 uwe Exp $ */
a47 2
#define __NEWINTR       /* enables new hooks in cpu_fork()/cpu_switch() */

d110 1
@


1.7
log
@Dale's lost diff for IRQ sharing, turned on by default.
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_intr.h,v 1.6 2005/02/28 22:10:01 drahn Exp $ */
a64 1
#define SI_TO_IRQBIT(si)  (1U<<(si))
@


1.6
log
@Store interrupt state in one variable not two, remove inlines which
signficantly bloat kernel. tested/ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_intr.h,v 1.5 2005/01/14 00:56:22 drahn Exp $ */
d108 1
a108 3

void pxa2x0_update_intr_masks(int irqno, int level);
extern __volatile int current_spl_level;
@


1.5
log
@commit this #if 0 del now.
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_intr.h,v 1.4 2005/01/04 23:37:13 drahn Exp $ */
a60 1
extern __volatile int intr_mask;
a93 9

#if !defined(EVBARM_SPL_NOINLINE)

#define splx(new)		pxa2x0_splx(new)
#define	_spllower(ipl)		pxa2x0_spllower(ipl)
#define	_splraise(ipl)		pxa2x0_splraise(ipl)
#define	_setsoftintr(si)	pxa2x0_setsoftintr(si)

#endif	/* !EVBARM_SPL_NOINTR */
@


1.4
log
@add prototype for disestablish function (coming soon), remove useless
includes, some #if 0 code.
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_intr.h,v 1.3 2005/01/04 02:08:41 drahn Exp $ */
a66 65
#if 0
/*
 * Cotulla's integrated ICU doesn't have IRQ0..7, so
 * we map software interrupts to bit 0..3
 */

static __inline void
pxa2x0_setipl(int new)
{
	current_spl_level = new;
	intr_mask = pxa2x0_imask[current_spl_level];
	write_icu( SAIPIC_MR, intr_mask );
}


static __inline void
pxa2x0_splx(int new)
{
	int psw;

	psw = disable_interrupts(I32_bit);
	pxa2x0_setipl(new);
	restore_interrupts(psw);

	/* If there are software interrupts to process, do it. */
	if (softint_pending & intr_mask)
		pxa2x0_do_pending();
}


static __inline int
pxa2x0_splraise(int ipl)
{
	int	old, psw;

	old = current_spl_level;
	if( ipl > current_spl_level ){
		psw = disable_interrupts(I32_bit);
		pxa2x0_setipl(ipl);
		restore_interrupts(psw);
	}

	return (old);
}

static __inline int
pxa2x0_spllower(int ipl)
{
	int old = current_spl_level;
	int psw = disable_interrupts(I32_bit);
	pxa2x0_splx(ipl);
	restore_interrupts(psw);
	return(old);
}

static __inline void
pxa2x0_setsoftintr(int si)
{
	atomic_set_bit( (u_int *)&softint_pending, SI_TO_IRQBIT(si) );

	/* Process unmasked pending soft interrupts. */
	if ( softint_pending & intr_mask )
		pxa2x0_do_pending();
}
#endif
@


1.3
log
@Add name argument to pxa2x0_intr_establish, which is standard for openbsd
interrupt handling.
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_intr.h,v 1.2 2005/01/02 19:52:36 drahn Exp $ */
a51 4
#if 0
#include <arm/cpu.h>
#include <machine/atomic.h>
#endif
a54 2
#include <arm/xscale/pxa2x0reg.h>

d180 4
a183 2
void *pxa2x0_intr_establish(int irqno, int level,
			    int (*func)(void *), void *cookie, char *name);
@


1.2
log
@OpenBSD tags
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d187 1
a187 1
			    int (*func)(void *), void *cookie);
@


1.1
log
@xscale bits, taken from NetBSD with modifications as appropriate for OpenBSD.
@
text
@d1 1
@

