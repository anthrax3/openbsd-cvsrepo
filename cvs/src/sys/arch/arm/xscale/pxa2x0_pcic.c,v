head	1.20;
access;
symbols
	OPENBSD_6_0:1.20.0.10
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.20.0.6
	OPENBSD_5_9_BASE:1.20
	OPENBSD_5_8:1.20.0.8
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.20.0.2
	OPENBSD_5_7_BASE:1.20
	OPENBSD_5_6:1.20.0.4
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.19.0.4
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.17.0.32
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.17.0.30
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.28
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.26
	OPENBSD_5_0:1.17.0.24
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.17.0.22
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.17.0.20
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.17.0.16
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.17.0.18
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.17.0.14
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.17.0.12
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.17.0.10
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.17.0.8
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.17.0.6
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.17.0.4
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.17.0.2
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.14.0.2
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.11.0.2
	OPENBSD_3_7_BASE:1.11;
locks; strict;
comment	@ * @;


1.20
date	2014.04.03.10.17.34;	author mpi;	state Exp;
branches;
next	1.19;

1.19
date	2013.11.20.17.36.06;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2013.11.18.20.21.51;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2005.12.14.15.08.51;	author uwe;	state Exp;
branches;
next	1.16;

1.16
date	2005.12.13.05.35.54;	author uwe;	state Exp;
branches;
next	1.15;

1.15
date	2005.11.23.11.39.37;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	2005.07.01.23.51.55;	author uwe;	state Exp;
branches;
next	1.13;

1.13
date	2005.04.11.03.38.03;	author uwe;	state Exp;
branches;
next	1.12;

1.12
date	2005.04.06.01.31.05;	author pascoe;	state Exp;
branches;
next	1.11;

1.11
date	2005.03.09.22.11.10;	author drahn;	state Exp;
branches;
next	1.10;

1.10
date	2005.03.09.22.00.23;	author uwe;	state Exp;
branches;
next	1.9;

1.9
date	2005.03.08.23.07.17;	author uwe;	state Exp;
branches;
next	1.8;

1.8
date	2005.02.23.00.05.38;	author drahn;	state Exp;
branches;
next	1.7;

1.7
date	2005.01.27.17.03.23;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2005.01.18.16.26.36;	author drahn;	state Exp;
branches;
next	1.5;

1.5
date	2005.01.15.15.20.50;	author drahn;	state Exp;
branches;
next	1.4;

1.4
date	2005.01.09.05.22.28;	author drahn;	state Exp;
branches;
next	1.3;

1.3
date	2005.01.04.23.48.31;	author drahn;	state Exp;
branches;
next	1.2;

1.2
date	2005.01.04.05.37.43;	author drahn;	state Exp;
branches;
next	1.1;

1.1
date	2004.12.30.23.48.17;	author drahn;	state Exp;
branches;
next	;


desc
@@


1.20
log
@More uvm_extern.h cleanup.
@
text
@/*	$OpenBSD: pxa2x0_pcic.c,v 1.19 2013/11/20 17:36:06 deraadt Exp $	*/

/*
 * Copyright (c) 2005 Dale Rahn <drahn@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/kernel.h>
#include <sys/kthread.h>
#include <sys/malloc.h>

#include <uvm/uvm_extern.h>

#include <machine/bus.h>
#include <machine/intr.h>

#include <dev/pcmcia/pcmciareg.h>
#include <dev/pcmcia/pcmciavar.h>
#include <dev/pcmcia/pcmciachip.h>

#include <arm/xscale/pxa2x0reg.h>
#include <arm/xscale/pxa2x0var.h>
#include <arm/xscale/pxa2x0_gpio.h>
#include <arm/xscale/pxapcicvar.h>

int	pxapcic_print(void *, const char *);
int	pxapcic_submatch(struct device *, void *, void *);

void	pxapcic_create_event_thread(void *);
void    pxapcic_event_thread(void *);
void	pxapcic_event_process(struct pxapcic_socket *);
void	pxapcic_attach_card(struct pxapcic_socket *);
void	pxapcic_detach_card(struct pxapcic_socket *, int);
int	pxapcic_intr(void *);

int	pxapcic_mem_alloc(pcmcia_chipset_handle_t, bus_size_t,
    struct pcmcia_mem_handle *);
void	pxapcic_mem_free(pcmcia_chipset_handle_t,
    struct pcmcia_mem_handle *);
int	pxapcic_mem_map(pcmcia_chipset_handle_t, int, bus_addr_t,
    bus_size_t, struct pcmcia_mem_handle *, bus_size_t *, int *);
void	pxapcic_mem_unmap(pcmcia_chipset_handle_t, int);

int	pxapcic_io_alloc(pcmcia_chipset_handle_t, bus_addr_t,
    bus_size_t, bus_size_t, struct pcmcia_io_handle *);
void	pxapcic_io_free(pcmcia_chipset_handle_t,
    struct pcmcia_io_handle *);
int	pxapcic_io_map(pcmcia_chipset_handle_t, int,
    bus_addr_t, bus_size_t, struct pcmcia_io_handle *, int *);
void	pxapcic_io_unmap(pcmcia_chipset_handle_t, int);

void	*pxapcic_intr_establish(pcmcia_chipset_handle_t,
    struct pcmcia_function *, int, int (*)(void *), void *, char *);
void	pxapcic_intr_disestablish(pcmcia_chipset_handle_t, void *);
const char *pxapcic_intr_string(pcmcia_chipset_handle_t, void *);

void	pxapcic_socket_setup(struct pxapcic_socket *);
void	pxapcic_socket_enable(pcmcia_chipset_handle_t);
void	pxapcic_socket_disable(pcmcia_chipset_handle_t);

struct cfdriver pxapcic_cd = {
	NULL, "pxapcic", DV_DULL
};

/*
 * PCMCIA chipset methods
 */
struct pcmcia_chip_functions pxapcic_pcmcia_functions = {
	pxapcic_mem_alloc,
	pxapcic_mem_free,
	pxapcic_mem_map,
	pxapcic_mem_unmap,
  
	pxapcic_io_alloc,
	pxapcic_io_free,
	pxapcic_io_map,
	pxapcic_io_unmap,
 
	pxapcic_intr_establish,
	pxapcic_intr_disestablish,
	pxapcic_intr_string,

	pxapcic_socket_enable,
	pxapcic_socket_disable,
};

/*
 * PCMCIA Helpers
 */

int
pxapcic_mem_alloc(pcmcia_chipset_handle_t pch, bus_size_t size,
    struct pcmcia_mem_handle *pmh)
{
	struct pxapcic_socket *so = pch;

	/* All we need is the bus space tag */
	memset(pmh, 0, sizeof(*pmh));
	pmh->memt = so->sc->sc_iot;
	return (0);
}

void
pxapcic_mem_free(pcmcia_chipset_handle_t pch, struct pcmcia_mem_handle *pmh)
{
}

int
pxapcic_mem_map(pcmcia_chipset_handle_t pch, int kind, bus_addr_t card_addr,
    bus_size_t size, struct pcmcia_mem_handle *pmh, bus_size_t *offsetp,
    int *windowp)
{
	struct pxapcic_socket *so = pch;
	int error;
	bus_addr_t pa;
 
	pa = trunc_page(card_addr);
	*offsetp = card_addr - pa;
	size = round_page(card_addr + size) - pa;
	pmh->realsize = size;

#define PXA2X0_SOCKET_OFFSET	(PXA2X0_PCMCIA_SLOT1-PXA2X0_PCMCIA_SLOT0)
#define PXAPCIC_ATTR_OFFSET	0x08000000
#define PXAPCIC_COMMON_OFFSET	0x0C000000

	pa += PXA2X0_PCMCIA_SLOT0;
	pa += PXA2X0_SOCKET_OFFSET * so->socket;

	switch (kind & ~PCMCIA_WIDTH_MEM_MASK) {
	case PCMCIA_MEM_ATTR:   
		pa += PXAPCIC_ATTR_OFFSET;
		break;
	case PCMCIA_MEM_COMMON:
		pa += PXAPCIC_COMMON_OFFSET;
		break;
	default:
		panic("pxapcic_mem_map: bogus kind");
	}

	error = bus_space_map(so->sc->sc_iot, pa, size, 0, &pmh->memh);
	if (! error)
		*windowp = (int)pmh->memh;
	return (error);
}

void
pxapcic_mem_unmap(pcmcia_chipset_handle_t pch, int window)
{
        struct pxapcic_socket *so = pch;

        bus_space_unmap(so->sc->sc_iot, (bus_addr_t)window, 4096); /* XXX */
}

int
pxapcic_io_alloc(pcmcia_chipset_handle_t pch, bus_addr_t start,
    bus_size_t size, bus_size_t align, struct pcmcia_io_handle *pih)
{
        struct pxapcic_socket *so = pch;
        int error;
        bus_addr_t pa;
        
        memset(pih, 0, sizeof(*pih));
        pih->iot = so->sc->sc_iot;
        pih->addr = start;
        pih->size = size;
        
        pa = pih->addr;
        pa += PXA2X0_PCMCIA_SLOT0;
        pa += PXA2X0_SOCKET_OFFSET * so->socket;

#if 0
        printf("pxapcic_io_alloc: %x %x\n", (unsigned int)pa,
                 (unsigned int)size);
#endif
        /* XXX Are we ignoring alignment constraints? */
        error = bus_space_map(so->sc->sc_iot, pa, size, 0, &pih->ioh);
                
        return (error);
}
                
void
pxapcic_io_free(pcmcia_chipset_handle_t pch, struct pcmcia_io_handle *pih)
{
        struct pxapcic_socket *so = pch;
        
        bus_space_unmap(so->sc->sc_iot, pih->ioh, pih->size);
}
 
int
pxapcic_io_map(pcmcia_chipset_handle_t pch, int width, bus_addr_t offset,
    bus_size_t size, struct pcmcia_io_handle *pih, int *windowp)
{
        return (0);
}

void pxapcic_io_unmap(pcmcia_chipset_handle_t pch, int window)
{
}

void *
pxapcic_intr_establish(pcmcia_chipset_handle_t pch,
    struct pcmcia_function *pf, int ipl, int (*fct)(void *), void *arg,
    char *name)
{
        struct pxapcic_socket *so = pch;
        /* XXX need to check if something should be done here */

	return (pxa2x0_gpio_intr_establish(so->irqpin, IST_EDGE_FALLING,
	    ipl, fct, arg, name));
}

void
pxapcic_intr_disestablish(pcmcia_chipset_handle_t pch, void *ih)
{
	pxa2x0_gpio_intr_disestablish(ih);
}

const char *
pxapcic_intr_string(pcmcia_chipset_handle_t pch, void *ih)
{
	return (pxa2x0_gpio_intr_string(ih));
}

void
pxapcic_socket_enable(pcmcia_chipset_handle_t pch)
{
	struct pxapcic_socket *so = pch;
	int i;

	/* Power down the card and socket before setting the voltage. */
	so->pcictag->write(so, PXAPCIC_CARD_POWER, PXAPCIC_POWER_OFF);
	so->pcictag->set_power(so, PXAPCIC_POWER_OFF);

	/*
	 * Wait 300ms until power fails (Tpf).  Then, wait 100ms since
	 * we are changing Vcc (Toff).   
	 */
	delay((300 + 100) * 1000);

	/* Power up the socket and card at appropriate voltage. */
	if (so->power_capability & PXAPCIC_POWER_5V) {
		so->pcictag->set_power(so, PXAPCIC_POWER_5V);
		so->pcictag->write(so, PXAPCIC_CARD_POWER,
		    PXAPCIC_POWER_5V);
	} else {
		so->pcictag->set_power(so, PXAPCIC_POWER_3V);
		so->pcictag->write(so, PXAPCIC_CARD_POWER,
		    PXAPCIC_POWER_3V);
	}

	/*
	 * Wait 100ms until power raise (Tpr) and 20ms to become
	 * stable (Tsu(Vcc)).
	 *
	 * Some machines require some more time to be settled
	 * (another 200ms is added here).
	 */
	delay((100 + 20 + 200) * 1000);

	/* Hold RESET at least 10us. */
	so->pcictag->write(so, PXAPCIC_CARD_RESET, 1);
	delay(10);
	/* XXX wrong, but lets TE-CF100 cards work for some reason. */
	delay(3000);
	so->pcictag->write(so, PXAPCIC_CARD_RESET, 0);

	/* Wait 20ms as per PC Card standard (r2.01) section 4.3.6. */
	delay(20000);

	/* Wait for the card to become ready. */
	for (i = 0; i < 10000; i++) {
		if (so->pcictag->read(so, PXAPCIC_CARD_READY))
			break;
		delay(500);
#ifdef PCICDEBUG
		if ((i>5000) && (i%100 == 99))
			printf(".");
#endif
	}
}

void
pxapcic_socket_disable(pcmcia_chipset_handle_t pch)
{
	struct pxapcic_socket *so = pch;

#ifdef PCICDEBUG
	printf("pxapcic_socket_disable: socket %d\n", so->socket);
#endif

	/* Power down the card and socket. */
	so->pcictag->write(so, PXAPCIC_CARD_POWER, PXAPCIC_POWER_OFF);
	so->pcictag->set_power(so, PXAPCIC_POWER_OFF);
}

/*
 * Attachment and initialization
 */

int
pxapcic_print(void *aux, const char *name)
{
	return (UNCONF);
}

int
pxapcic_submatch(struct device *parent, void *match, void *aux)
{
	struct cfdata *cf = match;

	return ((*cf->cf_attach->ca_match)(parent, cf, aux));
}

void
pxapcic_attach(struct pxapcic_softc *sc,
    void (*socket_setup_hook)(struct pxapcic_socket *))
{
	struct pcmciabus_attach_args paa;
	struct pxapcic_socket *so;
	int i;

	printf(": %d slot%s\n", sc->sc_nslots, sc->sc_nslots==1 ? "" : "s");

	if (bus_space_map(sc->sc_iot, PXA2X0_MEMCTL_BASE, PXA2X0_MEMCTL_SIZE,
	    0, &sc->sc_memctl_ioh)) {
		printf("%s: failed to map MEMCTL\n", sc->sc_dev.dv_xname);
		return;
	}

	/* Clear CIT (card present) and set NOS correctly. */
	bus_space_write_4(sc->sc_iot, sc->sc_memctl_ioh, MEMCTL_MECR,
	    sc->sc_nslots == 2 ? MECR_NOS : 0);

	/* zaurus: configure slot 1 first to make internal drive be wd0. */
	for (i = sc->sc_nslots-1; i >= 0; i--) {
		so = &sc->sc_socket[i];
		so->sc = sc;
		so->socket = i;
		so->flags = 0;

		socket_setup_hook(so);

		paa.paa_busname = "pcmcia";
		paa.pct = (pcmcia_chipset_tag_t)&pxapcic_pcmcia_functions;
		paa.pch = (pcmcia_chipset_handle_t)so;
		paa.iobase = 0;
		paa.iosize = 0x4000000;
	
		so->pcmcia = config_found_sm(&sc->sc_dev, &paa,
		    pxapcic_print, pxapcic_submatch);

		pxa2x0_gpio_set_function(sc->sc_irqpin[i], GPIO_IN);
		pxa2x0_gpio_set_function(sc->sc_irqcfpin[i], GPIO_IN);
	
		/* Card slot interrupt */
		so->irq = pxa2x0_gpio_intr_establish(sc->sc_irqcfpin[i],
		    IST_EDGE_BOTH, IPL_BIO /* XXX */, pxapcic_intr, so,
		    sc->sc_dev.dv_xname);
	
		/* GPIO pin for interrupt */
		so->irqpin = sc->sc_irqpin[i];

#ifdef DO_CONFIG_PENDING
		config_pending_incr();
#endif
		kthread_create_deferred(pxapcic_create_event_thread, so);
	}
}

/*
 * Card slot interrupt handling
 */

int
pxapcic_intr(void *arg)
{
        struct pxapcic_socket *so = arg;

	so->pcictag->clear_intr(so);
        wakeup(so);
        return (1);
}

/*
 * Event management
 */

void
pxapcic_create_event_thread(void *arg)
{
	struct pxapcic_socket *sock = arg;
	struct pxapcic_softc *sc = sock->sc;
	char name[MAXCOMLEN+1];
	u_int cs;

	/* If there's a card there, attach it. */
	cs = sock->pcictag->read(sock, PXAPCIC_CARD_STATUS);
	if (cs == PXAPCIC_CARD_VALID)
		pxapcic_attach_card(sock);

	snprintf(name, sizeof name, "%s-%d", sc->sc_dev.dv_xname, sock->socket);
	if (kthread_create(pxapcic_event_thread, sock, &sock->event_thread,
	     name))
		printf("%s: unable to create event thread for %s\n",
		     sc->sc_dev.dv_xname, sock->socket ? "1" : "0");
#ifdef DO_CONFIG_PENDING
	config_pending_decr();
#endif
}

void   
pxapcic_event_thread(void *arg)
{
	struct pxapcic_socket *sock = arg;
	u_int cs;
	int present;

	while (sock->sc->sc_shutdown == 0) {

		(void) tsleep(sock, PWAIT, "pxapcicev", 0);

		/* sleep .25s to avoid chattering interrupts */
		(void) tsleep((caddr_t)sock, PWAIT,
		    "pxapcicss", hz/4);

		cs = sock->pcictag->read(sock, PXAPCIC_CARD_STATUS);

		present = sock->flags & PXAPCIC_FLAG_CARDP;

		if ((cs == PXAPCIC_CARD_VALID) == (present == 1))
			continue; /* state unchanged */

		/* XXX Do both? */
		pxapcic_event_process(sock);
	}
	
	sock->event_thread = NULL;

	/* In case parent is waiting for us to exit. */
	wakeup(sock->sc);
	 
	kthread_exit(0);
}

void
pxapcic_event_process(struct pxapcic_socket *sock)
{
	u_int cs;

	cs = sock->pcictag->read(sock, PXAPCIC_CARD_STATUS);

	if (cs == PXAPCIC_CARD_VALID) {
		if (!(sock->flags & PXAPCIC_FLAG_CARDP))
			pxapcic_attach_card(sock);
	} else {
		if ((sock->flags & PXAPCIC_FLAG_CARDP))
			pxapcic_detach_card(sock, DETACH_FORCE);
	}
}

void
pxapcic_attach_card(struct pxapcic_socket *h)
{
	struct pxapcic_softc *sc = h->sc;
	u_int32_t rv;

	if (h->flags & PXAPCIC_FLAG_CARDP)
		panic("pcic_attach_card: already attached"); 
	h->flags |= PXAPCIC_FLAG_CARDP;

	/* Set CIT if any card is present. */
	rv = bus_space_read_4(sc->sc_iot, sc->sc_memctl_ioh, MEMCTL_MECR);
	bus_space_write_4(sc->sc_iot, sc->sc_memctl_ioh, MEMCTL_MECR,
	    rv | MECR_CIT);
 
	/* call the MI attach function */
	pcmcia_card_attach(h->pcmcia);
}

void
pxapcic_detach_card(struct pxapcic_socket *h, int flags)
{
	struct pxapcic_softc *sc = h->sc;
	u_int32_t rv;
	int i;

	if (h->flags & PXAPCIC_FLAG_CARDP) {
		h->flags &= ~PXAPCIC_FLAG_CARDP;
	 
		/* call the MI detach function */
		pcmcia_card_detach(h->pcmcia, flags);
	}

	/* Clear CIT if no other card is present. */
	for (i = 0; i < sc->sc_nslots; i++)
		if (sc->sc_socket[i].flags & PXAPCIC_FLAG_CARDP)
			return;
	rv = bus_space_read_4(sc->sc_iot, sc->sc_memctl_ioh, MEMCTL_MECR);
	bus_space_write_4(sc->sc_iot, sc->sc_memctl_ioh, MEMCTL_MECR,
	    rv & ~MECR_CIT);
}
@


1.19
log
@oops, typo
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_pcic.c,v 1.18 2013/11/18 20:21:51 deraadt Exp $	*/
d25 2
a26 1
#include <uvm/uvm.h>
d30 1
a30 1
        
@


1.18
log
@simplify kthread_create(). no more stdarg
ok matthew guenther mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_pcic.c,v 1.17 2005/12/14 15:08:51 uwe Exp $	*/
d418 1
a418 2
		     sc->sc_dev.dv_xname,  sock->socket ? "1" : "0");
	}
@


1.17
log
@Don't hard-code card present and number of socket bits in the PCMCIA bus
configuration register, but control these bits from PCMCIA code.
ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_pcic.c,v 1.16 2005/12/13 05:35:54 uwe Exp $	*/
d406 1
d414 1
d416 1
a416 1
	     sc->sc_dev.dv_xname, sock->socket ? "1" : "0")) {
@


1.16
log
@It would seem that some cards do not get reset correctly if RESET is
held only for 10us but the same cards work just fine on other platforms.
A really long delay lets those cards reset correctly on zaurus, but it
is only an ugly workaround until the socket setup is fixed.
ok for now fgs@@, drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_pcic.c,v 1.15 2005/11/23 11:39:37 mickey Exp $	*/
d337 10
d476 3
d482 5
d495 4
d505 8
@


1.15
log
@use proper bus_size_t for register offsets and not bus_addr_t; uwe@@ miod@@ testing
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_pcic.c,v 1.14 2005/07/01 23:51:55 uwe Exp $	*/
d276 2
@


1.14
log
@Move all zaurus specific code from pxa2x0_pcic.c into scoop_pcic.c
without affecting the way the driver works.
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_pcic.c,v 1.13 2005/04/11 03:38:03 uwe Exp $	*/
d54 1
a54 1
    bus_size_t, struct pcmcia_mem_handle *, bus_addr_t *, int *);
d123 1
a123 1
    bus_size_t size, struct pcmcia_mem_handle *pmh, bus_addr_t *offsetp,
@


1.13
log
@no need to include sys/timeout.h
@
text
@d1 2
a2 1
/* $OpenBSD: pxa2x0_pcic.c,v 1.12 2005/04/06 01:31:05 pascoe Exp $ */
a18 1
#include <sys/types.h>
d39 10
d56 1
d64 1
d69 2
a70 1
void	pxapcic_wait_ready(struct pxapcic_socket *);
a73 25
void    pxapcic_event_thread(void *);
         
void    pxapcic_delay(int, const char *);

int     pxapcic_match(struct device *, void *, void *);
void    pxapcic_attach(struct device *, struct device *, void *);
void	pxapcic_create_event_thread(void *arg);
int	pxapcic_submatch(struct device *parent, void *, void *aux);
int	pxapcic_print(void *aux, const char *name);
int	pxapcic_intr(void *arg);

void	pxapcic_event_process(struct pxapcic_socket *);

void	pxapcic_attach_card(struct pxapcic_socket *h);
void	pxapcic_detach_card(struct pxapcic_socket *h, int flags);

int pxapcic_intr_detect(void *arg);

/* DON'T CONFIGURE CF slot 1 for now */
#define NUM_CF_CARDS 2

struct cfattach pxapcic_ca = {
	sizeof(struct pxapcic_softc), pxapcic_match, pxapcic_attach
};

d78 3
d100 3
a102 1

d105 2
a106 4
pxapcic_mem_alloc(pch, size, pmh)
	pcmcia_chipset_handle_t pch;
	bus_size_t size;
	struct pcmcia_mem_handle *pmh;
d117 1
a117 3
pxapcic_mem_free(pch, pmh)
	pcmcia_chipset_handle_t pch;
	struct pcmcia_mem_handle *pmh;
d122 3
a124 8
pxapcic_mem_map(pch, kind, card_addr, size, pmh, offsetp, windowp)
	pcmcia_chipset_handle_t pch;
	int kind;
	bus_addr_t card_addr;
	bus_size_t size;
	struct pcmcia_mem_handle *pmh;
	bus_addr_t *offsetp;
	int *windowp;
d160 1
a160 3
pxapcic_mem_unmap(pch, window)
        pcmcia_chipset_handle_t pch;
        int window;
d168 2
a169 6
pxapcic_io_alloc(pch, start, size, align, pih)
        pcmcia_chipset_handle_t pch;
        bus_addr_t start;
        bus_size_t size;
        bus_size_t align;
        struct pcmcia_io_handle *pih;
d195 1
a195 3
pxapcic_io_free(pch, pih)
        pcmcia_chipset_handle_t pch;
        struct pcmcia_io_handle *pih;
d203 2
a204 7
pxapcic_io_map(pch, width, offset, size, pih, windowp)
        pcmcia_chipset_handle_t pch;
        int width;
        bus_addr_t offset;
        bus_size_t size;
        struct pcmcia_io_handle *pih;
        int *windowp;
d209 1
a209 3
void pxapcic_io_unmap(pch, window)
        pcmcia_chipset_handle_t pch;
        int window;
d214 3
a216 7
pxapcic_intr_establish(pch, pf, ipl, fct, arg, name)
        pcmcia_chipset_handle_t pch;
        struct pcmcia_function *pf;
        int ipl;
        int (*fct)(void *);
        void *arg;
	char *name;
d221 2
a222 2
	return pxa2x0_gpio_intr_establish(so->irqpin, IST_EDGE_FALLING,
	    ipl, fct, arg, name);
d226 1
a226 3
pxapcic_intr_disestablish(pch, ih)
        pcmcia_chipset_handle_t pch;
        void *ih;
d232 1
a232 3
pxapcic_intr_string(pch, ih)
        pcmcia_chipset_handle_t pch;
        void *ih;
d234 1
a234 1
	return pxa2x0_gpio_intr_string(ih);
d238 1
a238 2
pxapcic_wait_ready(so)
	struct pxapcic_socket *so;
d240 1
a240 1
	bus_space_tag_t iot = so->sc->sc_iot;
d243 3
a245 48
	for (i = 0; i < 10000; i++) {
		if (bus_space_read_2(iot, so->scooph, SCOOP_REG_CSR) &
		    SCP_CSR_READY)
			return;
		delay(500);
#ifdef PCICDEBUG
		if ((i>5000) && (i%100 == 99))
			printf(".");
#endif
	}

#ifdef DIAGNOSTIC
	printf("pxapcic_wait_ready: ready never happened, status = %02x\n",
	    bus_space_read_2(iot, so->scooph, SCOOP_REG_CSR));
#endif
}

void
pxapcic_socket_enable(pch)
        pcmcia_chipset_handle_t pch;
{
	struct pxapcic_socket *so = pch;
	bus_space_tag_t iot = so->sc->sc_iot;
	u_int16_t reg;

#ifdef PCICDEBUG
	printf("pxapcic_socket_enable: socket %d\n", so->socket);
#endif

	/* XXX fix scoop1 base address before trying that. */
	if (so->socket == 1)
		return;

	/* XXX bit 2 was clear on boot with card preconfigured. */
	reg = bus_space_read_2(iot, so->scooph, SCOOP_REG_IRM);
	bus_space_write_2(iot, so->scooph, SCOOP_REG_IRM, reg & ~0x0004);

	/* Enable CF socket 0 power. */
	if (so->socket == 0) {
		reg = bus_space_read_2(iot, so->scooph, SCOOP_REG_GPWR);
		bus_space_write_2(iot, so->scooph, SCOOP_REG_GPWR,
		    reg | (1<<6)); /* SCOOP0_CF_POWER_C3000 */
	}

 	/* XXX */
	reg = bus_space_read_2(iot, so->scooph, SCOOP_REG_CPR);
	reg = reg & ~(SCP_CPR_PWR|SCP_CPR_5V|SCP_CPR_3V);
	bus_space_write_2(iot, so->scooph, SCOOP_REG_CPR, reg);
d248 1
a248 1
	 * wait 300ms until power fails (Tpf).  Then, wait 100ms since
d253 10
a262 3
	/* Socket 1 supports only 5 V (which really is 3.3) for C3000? */
	reg = reg | (SCP_CPR_PWR|SCP_CPR_5V);
	bus_space_write_2(iot, so->scooph, SCOOP_REG_CPR, reg);
d265 1
a265 1
	 * wait 100ms until power raise (Tpr) and 20ms to become
d268 1
a268 1
	 * some machines require some more time to be settled
d273 2
a274 1
	bus_space_write_2(iot, so->scooph, SCOOP_REG_CCR, SCP_CCR_RESET);
d276 1
a276 1
	bus_space_write_2(iot, so->scooph, SCOOP_REG_CCR, 0);
d278 1
a278 3

	/* wait 20ms as per pc card standard (r2.01) section 4.3.6 */
		   
d281 8
a288 4
	pxapcic_wait_ready(so);

#if 0
	printf("cardtype %d\n", h->pcmcia);
d290 1
d294 1
a294 2
pxapcic_socket_disable(pch)
        pcmcia_chipset_handle_t pch;
a296 2
	bus_space_tag_t iot = so->sc->sc_iot;
	u_int16_t reg;
d302 3
a304 15
	/* XXX fix scoop1 base address before trying that. */
	if (so->socket == 1)
		return;

 	/* XXX */
	reg = bus_space_read_2(iot, so->scooph, SCOOP_REG_CPR);
	reg = reg & ~(SCP_CPR_PWR|SCP_CPR_5V|SCP_CPR_3V);
	bus_space_write_2(iot, so->scooph, SCOOP_REG_CPR, reg);

	/* Disable CF socket 0 power. */
	if (so->socket == 0) {
		reg = bus_space_read_2(iot, so->scooph, SCOOP_REG_GPWR);
		bus_space_write_2(iot, so->scooph, SCOOP_REG_GPWR,
		    reg & ~(1<<6)); /* SCOOP0_CF_POWER_C3000 */
	}
d307 6
a312 5
#if 0
void
pxapcic_socket_settype(pch, type)
        pcmcia_chipset_handle_t pch;
        int type;
d314 1
a314 2

        /* XXX */
a315 1
#endif
d317 2
a318 3
#if 0
void
pxapcic_socket_setup(struct pxapcic_socket *sp)
d320 3
a322 4
	/*
        sp->power_capability = PXAPCIC_POWER_3V;
	*/
        sp->pcictag = &pxapcic_sacpcic_functions;
a323 1
#endif
a324 1
#if 0
d326 2
a327 1
pxapcic_set_power(struct pxapcic_socket *so, int arg)
d329 40
a368 1
	/* 3 volt only, not supported - XXX */
d371 4
a374 1
#endif
d376 1
a376 1
pxapcic_match(struct device *parent, void *v, void *aux)
d378 4
d383 27
a409 1
}     
d415 1
a415 1
	u_int16_t csr;
d426 1
a426 2
		csr = bus_space_read_2(sock->sc->sc_iot, sock->scooph,
		    SCOOP_REG_CSR);
d430 1
a430 1
		if (((csr & SCP_CSR_MISSING) == 0) == (present == 1))
d446 16
a479 123
	} else {
		//DPRINTF(("pcic_detach_card: already detached"));
	}
}


void pxapcic_event_process_st(void *h);
void
pxapcic_event_process_st(void *v)
{
	struct pxapcic_socket *h = v;
	pxapcic_event_process(h);
}
void
pxapcic_event_process(sock)
	struct pxapcic_socket *sock;
{
	struct pxapcic_softc *sc = sock->sc;
	u_int16_t csr;

	csr = bus_space_read_2(sc->sc_iot, sock->scooph, SCOOP_REG_CSR);

	switch (csr & SCP_CSR_MISSING) {
	case 0: /* PRESENT */
		//DPRINTF(("%s: insertion event\n", sock->sc->dv_xname));
		if (!(sock->flags & PXAPCIC_FLAG_CARDP))
			pxapcic_attach_card(sock);
		break;

	case SCP_CSR_MISSING:
		//DPRINTF(("%s: removal event\n", sock->sc->dv_xname));
		if ((sock->flags & PXAPCIC_FLAG_CARDP))
			pxapcic_detach_card(sock, DETACH_FORCE);
		break;
	}
}

void
pxapcic_create_event_thread(void *arg)
{
	struct pxapcic_socket *sock = arg;
	struct pxapcic_softc *sc = sock->sc;
	u_int16_t csr;

	csr = bus_space_read_2(sc->sc_iot, sock->scooph, SCOOP_REG_CSR);

	/* if there's a card there, attach it  */

	switch (csr & SCP_CSR_MISSING) {
	case 0: /* PRESENT */
		pxapcic_attach_card(sock);
		break;
	default:
		;
	}

	if (kthread_create(pxapcic_event_thread, sock, &sock->event_thread,
	     sc->sc_dev.dv_xname, sock->socket ? "1" : "0")) {
		printf("%s: unable to create event thread for %s\n",
		     sc->sc_dev.dv_xname,  sock->socket ? "1" : "0");
	}
#ifdef DO_CONFIG_PENDING
	config_pending_decr();
#endif
}

int
pxapcic_submatch(struct device *parent, void *match, void *aux)
{
	struct cfdata *cf = match;

	return ((*cf->cf_attach->ca_match)(parent, cf, aux));

}

int
pxapcic_print(void *aux, const char *name)
{
	return (UNCONF);
}


void
pxapcic_attach(struct device *parent, struct device *self, void *aux)
{
	struct pcmciabus_attach_args paa;
	struct pxapcic_softc *sc = (struct pxapcic_softc *)self;
	struct pxaip_attach_args *pxa = aux;
	struct pxapcic_socket *so;
	bus_space_tag_t iot;
	bus_space_handle_t scooph;
	int i;
	int error;
	bus_addr_t pa;
	bus_size_t size = 0x100;

	iot = sc->sc_iot = pxa->pxa_iot;

	sc->sc_shutdown = 0;

	printf("\n");

	/*
	 * should be model based not processor based, and in zaurus/...
	 * not arm/xscale
	 */
	if ((cputype & ~CPU_ID_XSCALE_COREREV_MASK) == CPU_ID_PXA27X) {
#define C3000_CF0_IRQ 105
#define C3000_CF1_IRQ 106
#define C3000_CF0_CD 94
#define C3000_CF1_CD 93
		sc->sc_nslots = 2;
		sc->sc_irqpin[0] = C3000_CF0_IRQ;
		sc->sc_irqcfpin[0] = C3000_CF0_CD;
		sc->sc_irqpin[1] = C3000_CF1_IRQ;
		sc->sc_irqcfpin[1] = C3000_CF1_CD;
	} else {
#define C860_CF0_IRQ 17
#define C860_CF0_CD 14
		/* C860 */
		sc->sc_nslots = 1;
		sc->sc_irqpin[0] = C860_CF0_IRQ;
		sc->sc_irqcfpin[0] = C860_CF0_CD;
a480 90

	for(i = 0; i < NUM_CF_CARDS; i++) {
		so = &sc->sc_socket[i];
		so->sc = sc;
		so->socket = i;
		so->flags = 0;

		/* scoop? */
		if (so->socket == 0)
			pa = 0x10800000;
		else if (so->socket == 1)
			pa = 0x14800000; /* 0x08800040 */
		else {
			printf ("%s: invalid CF slot %d\n", sc->sc_dev.dv_xname,
			    i);
			continue;
		}
		error = bus_space_map(iot, pa, size, 0, &scooph);
		if (error) {
			printf ("%s%d: failed to map memory %x for scoop\n",
			    sc->sc_dev.dv_xname, i, pa);
			    continue;
		}
		so->scooph = scooph;

		bus_space_write_2(iot, scooph, SCOOP_REG_IMR, 0x00c0);

		/* setup */
		bus_space_write_2(iot, scooph, SCOOP_REG_MCR, 0x0100);
		bus_space_write_2(iot, scooph, SCOOP_REG_CDR, 0x0000);
		bus_space_write_2(iot, scooph, SCOOP_REG_CPR, 0x0000);
		bus_space_write_2(iot, scooph, SCOOP_REG_IMR, 0x0000);
		bus_space_write_2(iot, scooph, SCOOP_REG_IRM, 0x00ff);
		bus_space_write_2(iot, scooph, SCOOP_REG_ISR, 0x0000);
		bus_space_write_2(iot, scooph, SCOOP_REG_IRM, 0x0000);

		bus_space_write_2(iot, scooph, SCOOP_REG_CPR,
		    SCP_CPR_PWR|SCP_CPR_5V); /* 5 V for 3000? */
	

		paa.paa_busname = "pcmcia";
		paa.pct = (pcmcia_chipset_tag_t) &pxapcic_pcmcia_functions;
		paa.pch = (pcmcia_chipset_handle_t)&sc->sc_socket[i];
		paa.iobase = 0;
		paa.iosize = 0x4000000;

		so->pcmcia = config_found_sm(&sc->sc_dev, &paa, pxapcic_print,
		     pxapcic_submatch);
	}

	/* configure slot 1 first to make internal drive be wd0 */
	for (i = sc->sc_nslots-1; i >= 0; i--) {
		so = &sc->sc_socket[i];
		pxa2x0_gpio_set_function(sc->sc_irqpin[i], GPIO_IN);
		pxa2x0_gpio_set_function(sc->sc_irqcfpin[i], GPIO_IN);

		sc->sc_socket[i].irq = pxa2x0_gpio_intr_establish(
		    sc->sc_irqcfpin[i], 
		    IST_EDGE_BOTH, IPL_BIO /* XXX */, pxapcic_intr_detect,
		    so, sc->sc_dev.dv_xname);

		/* GPIO pin for interrupt */
		sc->sc_socket[i].irqpin = sc->sc_irqpin[i];

		bus_space_write_2(iot, so->scooph, SCOOP_REG_IMR, 0x00ce);
		bus_space_write_2(iot, so->scooph, SCOOP_REG_MCR, 0x0111);

#ifdef DO_CONFIG_PENDING
		config_pending_incr();
#endif
		kthread_create_deferred(pxapcic_create_event_thread, so);
	}
}

int
pxapcic_intr_detect(void *arg)
{
        struct pxapcic_socket *so = arg;
	bus_space_tag_t iot;

	iot = so->sc->sc_iot;

	/*
        (so->pcictag->clear_intr)(so->socket);
	*/
	bus_space_write_2(iot, so->scooph, SCOOP_REG_IRM, 0x00ff);
	bus_space_write_2(iot, so->scooph, SCOOP_REG_ISR, 0x0000);
	bus_space_write_2(iot, so->scooph, SCOOP_REG_IRM, 0x0000);
        wakeup(so);
        return 1;
@


1.12
log
@spelling/grammar cleanups

jolan drahn uwe dlg ok
@
text
@d1 1
a1 1
/* $OpenBSD: pxa2x0_pcic.c,v 1.11 2005/03/09 22:11:10 drahn Exp $ */
a21 1
#include <sys/timeout.h>
@


1.11
log
@With some correct interrupt acknowledgement and register initialization,
the pcic insert/removal polling can be removed. prod by uwe.
@
text
@d1 1
a1 1
/* $OpenBSD: pxa2x0_pcic.c,v 1.10 2005/03/09 22:00:23 uwe Exp $ */
d80 1
a80 1
/* DONT CONFIGURE CF slot 1 for now */
d120 1
a120 1
	/* All we need is bus space tag */
d444 1
a444 1
		/* sleep .25s to avoid chatterling interrupts */
d533 1
a533 1
	/* if there's a card there, then attach it  */
d630 1
a630 1
			printf ("%s%d:failed to map memory %x for scoop\n",
@


1.10
log
@Wait for card to become ready after reset; ok drahn@@
@
text
@d1 1
a1 1
/* $OpenBSD: pxa2x0_pcic.c,v 1.9 2005/03/08 23:07:17 uwe Exp $ */
a440 1
		/* sleep .25s to avoid chatterling interrupts */
d442 1
a442 2
		/* poll every 5 seconds in case we miss an interrupt */
		(void) tsleep(sock, PWAIT, "pxapcicev", hz*5);
d444 1
d645 1
a645 1
		bus_space_write_2(iot, scooph, SCOOP_REG_IMR, 0x0000);
d689 3
a691 1
	printf("pxapcic_intr_detect %x\n", so->socket);
d696 3
@


1.9
log
@Enable or disable CF sockets at appropriate times, but be sure to
enable socket 0 power via GPIO.  Socket 1 can be ignored for now.
Initial diff, testing, and ok drahn@@.
@
text
@d1 1
a1 1
/* $OpenBSD: pxa2x0_pcic.c,v 1.8 2005/02/23 00:05:38 drahn Exp $ */
d58 1
d278 24
d309 4
a325 1
		delay(1000);
d361 2
d376 4
a393 1
		delay(1000);	/* XXX needed? */
@


1.8
log
@fix copyright, use pxa2x0_gpio_intr_string()
@
text
@d1 1
a1 1
/* $OpenBSD: pxa2x0_pcic.c,v 1.7 2005/01/27 17:03:23 millert Exp $ */
d280 56
a335 1
	/* XXX */
d342 20
a361 1
        /* XXX */
d429 1
a429 1
		
d590 1
a590 1
			pa = 0x14800000;
@


1.7
log
@Add pcmcia_intr_string() to format the intr string for pcmcia attach
routines.
@
text
@d1 1
a1 1
/* $OpenBSD: pxa2x0_pcic.c,v 1.6 2005/01/18 16:26:36 drahn Exp $ */
d3 1
a3 1
 * Copyright (c) Dale Rahn <drahn@@openbsd.org>
d273 1
a273 8
	struct pxapcic_socket *so = pch;
	static char irqstr[64];

	if (ih == NULL)
		snprintf(irqstr, sizeof(irqstr), "couldn't establish interrupt");
	else
		snprintf(irqstr, sizeof(irqstr), "irq %d", so->irqpin);
	return (irqstr);
@


1.6
log
@Clean up pxapcic attachment code, make it closer to easy to split the
driver. Also attach the slots in reverse order, so that the internal
HD on C3000 always is wd0.
@
text
@d1 1
a1 1
/* $OpenBSD: pxa2x0_pcic.c,v 1.5 2005/01/15 15:20:50 drahn Exp $ */
d57 1
d103 1
d266 15
@


1.5
log
@Better effort on pcic detection, poll every 5 seconds.
@
text
@d1 1
a1 1
/* $OpenBSD: pxa2x0_pcic.c,v 1.4 2005/01/09 05:22:28 drahn Exp $ */
d149 1
a149 2
#define PXAPCIC_BASE_OFFSET	0x20000000
#define PXAPCIC_SOCKET_OFFSET	0x10000000
d153 2
a154 2
	pa += PXAPCIC_BASE_OFFSET;
	pa += PXAPCIC_SOCKET_OFFSET * so->socket;
d201 2
a202 2
        pa += PXAPCIC_BASE_OFFSET;
        pa += PXAPCIC_SOCKET_OFFSET * so->socket;
d432 1
a432 1
	/*
d434 1
a434 1
	*/
d467 1
a467 1
	sc->sc_iot = pxa->pxa_iot;
d473 23
a496 1
		iot = sc->sc_iot;
d545 5
a549 10
#if 0
	/* XXX 860 */
	so = &sc->sc_socket[0];
	pxa2x0_gpio_set_function(14, GPIO_IN);
	pxa2x0_gpio_set_function(17, GPIO_IN);

	sc->sc_socket[0].irq = pxa2x0_gpio_intr_establish(14 /*???*/,
	    IST_EDGE_FALLING, IPL_BIO /* XXX */, pxapcic_intr_detect,
	    so, sc->sc_dev.dv_xname);
	sc->sc_socket[0].irqpin = 17;	/* GPIO pin for interrupt */
d551 4
a554 2
	bus_space_write_2(sc->sc_iot, so->scooph, SCOOP_REG_IMR, 0x00ce);
	bus_space_write_2(sc->sc_iot, so->scooph, SCOOP_REG_MCR, 0x0111);
d556 2
a557 27
	/*
	config_pending_incr();
	*/
	kthread_create_deferred(pxapcic_create_event_thread, so);
#else
#define C3000_CF0_IRQ 105
#define C3000_CF1_IRQ 106
#define C3000_CF0_CD 94
#define C3000_CF1_CD 93

	/* XXX c3000 */
	so = &sc->sc_socket[0];
	pxa2x0_gpio_set_function(C3000_CF0_IRQ, GPIO_IN); /* GPIO_CF_IRQ  */
	pxa2x0_gpio_set_function(C3000_CF0_CD, GPIO_IN); /* GPIO_CF_CD */

	sc->sc_socket[0].irq = pxa2x0_gpio_intr_establish(C3000_CF0_CD,
	    IST_EDGE_FALLING, IPL_BIO /* XXX */, pxapcic_intr_detect,
	    so, sc->sc_dev.dv_xname);
	sc->sc_socket[0].irqpin = C3000_CF0_IRQ;	/* GPIO pin for interrupt */

	bus_space_write_2(sc->sc_iot, so->scooph, SCOOP_REG_IMR, 0x00ce);
	bus_space_write_2(sc->sc_iot, so->scooph, SCOOP_REG_MCR, 0x0111);

	/*
	config_pending_incr();
	*/
	kthread_create_deferred(pxapcic_create_event_thread, so);
d559 2
a560 9
#if NUM_CF_CARDS > 1
	pxa2x0_gpio_set_function(C3000_CF1_IRQ, GPIO_IN); /* GPIO_CF1_IRQ */
	pxa2x0_gpio_set_function(C3000_CF1_CD, GPIO_IN); /* GPIO_CF1_CD */

	so = &sc->sc_socket[1];
	sc->sc_socket[1].irq = pxa2x0_gpio_intr_establish(C3000_CF1_CD, 
	    IST_EDGE_FALLING, IPL_BIO /* XXX */, pxapcic_intr_detect,
	    so, sc->sc_dev.dv_xname);
	sc->sc_socket[1].irqpin = C3000_CF1_IRQ;	/* GPIO pin for interrupt */
d562 2
a563 8
	bus_space_write_2(sc->sc_iot, so->scooph, SCOOP_REG_IMR, 0x00ce);
	bus_space_write_2(sc->sc_iot, so->scooph, SCOOP_REG_MCR, 0x0111);

	/*
	config_pending_incr();
	*/
	kthread_create_deferred(pxapcic_create_event_thread, so);
#endif /* NUM_CF_CARDS > 1 */
d565 2
a566 1

@


1.4
log
@Some fixes on pcic attachment.
@
text
@d1 1
a1 1
/* $OpenBSD: pxa2x0_pcic.c,v 1.3 2005/01/04 23:48:31 drahn Exp $ */
d327 2
a328 1
		(void) tsleep(sock, PWAIT, "pxapcicev", 0);
@


1.3
log
@Seems to be working on C3000, still needs layering fix and 1/2 slot 'probing'.
@
text
@d1 1
a1 1
/* $OpenBSD: pxa2x0_pcic.c,v 1.2 2005/01/04 05:37:43 drahn Exp $ */
a252 2
        struct pxapcic_softc *sc = so->sc;

d255 1
a255 2
	return pxa2x0_gpio_intr_establish(sc->sc_gpio, IST_EDGE_FALLING,
	/* IST_EDGE_RISING,*/
d327 2
d432 1
d434 1
d529 3
a531 2
	sc->sc_irq  = pxa2x0_gpio_intr_establish(14 /*???*/, IST_EDGE_FALLING,
	    IPL_BIO /* XXX */, pxapcic_intr_detect, so, sc->sc_dev.dv_xname);
d537 1
d539 1
d542 4
d549 2
a550 2
	pxa2x0_gpio_set_function(105, GPIO_IN); /* GPIO_CF_IRQ  */
	pxa2x0_gpio_set_function(94, GPIO_IN); /* GPIO_CF_CD */
d552 1
a552 1
	sc->sc_socket[0].irq = pxa2x0_gpio_intr_establish(94 /*???*/,
d555 1
a555 1
	sc->sc_socket[0].irqpin = 105;	/* GPIO pin for interrupt */
d560 1
d562 1
d566 2
a567 2
	pxa2x0_gpio_set_function(106, GPIO_IN); /* GPIO_CF2_IRQ */
	pxa2x0_gpio_set_function(93, GPIO_IN); /* GPIO_CF2_CD */
d570 1
a570 1
	sc->sc_socket[1].irq = pxa2x0_gpio_intr_establish(93 /*???*/,
d573 1
a573 1
	sc->sc_socket[1].irqpin = 106;	/* GPIO pin for interrupt */
d578 1
d580 1
d591 1
d596 1
a596 1
        wakeup(so->sc);
a598 2


@


1.2
log
@Framed up support for C3000, however not working yet so match is disabled.
@
text
@d1 1
a1 1
/* $OpenBSD: pxa2x0_pcic.c,v 1.1 2004/12/30 23:48:17 drahn Exp $ */
d34 2
d79 1
a79 1
#define NUM_CF_CARDS 1
d317 1
a317 1
        return (0);
a416 2
	printf("%s%d: create event, csr %d\n", sc->sc_dev.dv_xname, 
	    sock->socket, csr);
a432 1
	/*
a433 1
	*/
a496 17
		{
		u_int16_t val;
		/* probe */
		val = bus_space_read_2(iot, scooph, SCOOP_REG_IMR);
		printf("scoop%d: IMR %x\n", i, val);
		val = bus_space_read_2(iot, scooph, SCOOP_REG_MCR);
		printf("scoop%d: MCR %x\n", i, val);
		val = bus_space_read_2(iot, scooph, SCOOP_REG_CDR);
		printf("scoop%d: CDR %x\n", i, val);
		val = bus_space_read_2(iot, scooph, SCOOP_REG_CPR);
		printf("scoop%d: CPR %x\n", i, val);
		val = bus_space_read_2(iot, scooph, SCOOP_REG_IRM);
		printf("scoop%d: IRM %x\n", i, val);
		val = bus_space_read_2(iot, scooph, SCOOP_REG_ISR);
		printf("scoop%d: ISR %x\n", i, val);
		}

d509 1
a509 1
		    SCP_CPR_PWR|SCP_CPR_3V);
a541 1
	pxa2x0_gpio_set_function(106, GPIO_IN); /* GPIO_CF2_IRQ */
a542 1
	pxa2x0_gpio_set_function(93, GPIO_IN); /* GPIO_CF2_CD */
a551 1
	/*
a552 1
	*/
d555 4
a567 1
	/*
a568 1
	*/
d570 1
@


1.1
log
@pcmcia (CF) adapter. Needs to be split into seperate layers so
that the offchip portion (not on pxa*) is not embedded here, interrupt
routing is performed offchip.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d315 1
a315 1
        return (1);
d321 1
a321 1
	struct pxapcic_softc *sc = arg;
d325 1
a325 1
	while (sc->sc_shutdown == 0) {
d328 1
a328 1
		(void) tsleep((caddr_t)sc, PWAIT,
d331 1
a331 1
		csr = bus_space_read_2(sc->sc_iot, sc->sc_scooph,
d334 1
a334 1
		present = sc->sc_socket[0].flags & PXAPCIC_FLAG_CARDP;
a338 20

#if 0
		printf("pxapcic_event_thread\n");

		printf("SCOOP_CSR 0x%04x\n",
		    bus_space_read_2(sc->sc_iot, sc->sc_scooph, SCOOP_REG_CSR));
		printf("SCOOP_CDR 0x%04x\n",
		    bus_space_read_2(sc->sc_iot, sc->sc_scooph, SCOOP_REG_CDR));
		printf("SCOOP_CPR 0x%04x\n",
		    bus_space_read_2(sc->sc_iot, sc->sc_scooph, SCOOP_REG_CPR));
		printf("SCOOP_CCR 0x%04x\n",
		    bus_space_read_2(sc->sc_iot, sc->sc_scooph, SCOOP_REG_CCR));
		printf("SCOOP_MCR 0x%04x\n",
		    bus_space_read_2(sc->sc_iot, sc->sc_scooph, SCOOP_REG_MCR));
		printf("SCOOP_IMR 0x%04x\n",
		    bus_space_read_2(sc->sc_iot, sc->sc_scooph, SCOOP_REG_IMR));
		printf("SCOOP_IRR 0x%04x\n",
		    bus_space_read_2(sc->sc_iot, sc->sc_scooph, SCOOP_REG_IRR));
#endif

d340 1
a340 4
		pxapcic_event_process(&sc->sc_socket[0]);
#if NUM_CF_CARDS > 1
		pxapcic_event_process(&sc->sc_socket[1]);
#endif
d343 1
a343 1
	sc->sc_event_thread = NULL;
d346 1
a346 1
	wakeup(sc);
d384 2
a385 2
pxapcic_event_process(h)
	struct pxapcic_socket *h;
d387 1
a387 1
	struct pxapcic_softc *sc = h->sc;
d390 1
a390 1
	csr = bus_space_read_2(sc->sc_iot, sc->sc_scooph, SCOOP_REG_CSR);
d394 3
a396 3
		//DPRINTF(("%s: insertion event\n", h->sc->dv_xname));
		if (!(h->flags & PXAPCIC_FLAG_CARDP))
			pxapcic_attach_card(h);
d400 3
a402 3
		//DPRINTF(("%s: removal event\n", h->sc->dv_xname));
		if ((h->flags & PXAPCIC_FLAG_CARDP))
			pxapcic_detach_card(h, DETACH_FORCE);
d410 2
a411 1
	struct pxapcic_softc *sc = arg;
d414 3
a416 1
	csr = bus_space_read_2(sc->sc_iot, sc->sc_scooph, SCOOP_REG_CSR);
d422 1
a422 1
		pxapcic_attach_card(&sc->sc_socket[0]);
d428 2
a429 2
	if (kthread_create(pxapcic_event_thread, sc, &sc->sc_event_thread,
	     sc->sc_dev.dv_xname, "0")) {
d431 1
a431 1
		     sc->sc_dev.dv_xname, "0");
d433 1
d435 1
d461 2
d465 1
a465 1
	bus_addr_t pa = 0x10800000;
a469 4
/*
	pxa->pxa_addr;
	pxa->pxa_size = 0x20;
*/
a470 32
	
	/* scoop? */
	error = bus_space_map(sc->sc_iot, pa, size, 0, &sc->sc_scooph);

	bus_space_write_2(sc->sc_iot, sc->sc_scooph, SCOOP_REG_IMR,
	    0x00c0);


#if 0
	printf("SCOOP_CSR 0x%04x\n",
	    bus_space_read_2(sc->sc_iot, sc->sc_scooph, SCOOP_REG_CSR));
	printf("SCOOP_CDR 0x%04x\n",
	    bus_space_read_2(sc->sc_iot, sc->sc_scooph, SCOOP_REG_CDR));
	printf("SCOOP_CPR 0x%04x\n",
	    bus_space_read_2(sc->sc_iot, sc->sc_scooph, SCOOP_REG_CPR));
	printf("SCOOP_CCR 0x%04x\n",
	    bus_space_read_2(sc->sc_iot, sc->sc_scooph, SCOOP_REG_CCR));
	printf("SCOOP_MCR 0x%04x\n",
	    bus_space_read_2(sc->sc_iot, sc->sc_scooph, SCOOP_REG_MCR));
	printf("SCOOP_IMR 0x%04x\n",
	    bus_space_read_2(sc->sc_iot, sc->sc_scooph, SCOOP_REG_IMR));
	printf("SCOOP_IRR 0x%04x\n",
	    bus_space_read_2(sc->sc_iot, sc->sc_scooph, SCOOP_REG_IRR));
#endif

	bus_space_write_2(sc->sc_iot, sc->sc_scooph, SCOOP_REG_MCR, 0x0100);
	bus_space_write_2(sc->sc_iot, sc->sc_scooph, SCOOP_REG_CDR, 0x0000);
	bus_space_write_2(sc->sc_iot, sc->sc_scooph, SCOOP_REG_CPR, 0x0000);
	bus_space_write_2(sc->sc_iot, sc->sc_scooph, SCOOP_REG_IMR, 0x0000);
	bus_space_write_2(sc->sc_iot, sc->sc_scooph, SCOOP_REG_IRM, 0x00ff);
	bus_space_write_2(sc->sc_iot, sc->sc_scooph, SCOOP_REG_ISR, 0x0000);
	bus_space_write_2(sc->sc_iot, sc->sc_scooph, SCOOP_REG_IMR, 0x0000);
a471 3
	bus_space_write_2(sc->sc_iot, sc->sc_scooph, SCOOP_REG_CPR,
	    SCP_CPR_PWR|SCP_CPR_3V);
	
d475 1
d481 37
d519 11
d541 3
d547 10
d558 11
a568 3
	sc->sc_irq  = pxa2x0_gpio_intr_establish(14 /*???*/, IST_EDGE_FALLING,
	    IPL_BIO /* XXX */, pxapcic_intr_detect, sc, sc->sc_dev.dv_xname);
		     
d570 2
d573 4
a576 2
	bus_space_write_2(sc->sc_iot, sc->sc_scooph, SCOOP_REG_IMR, 0x00ce);
	bus_space_write_2(sc->sc_iot, sc->sc_scooph, SCOOP_REG_MCR, 0x0111);
d578 5
d584 4
a587 2
	sc->sc_gpio  = 17;	/* GPIO pin for interrupt */
	    
d589 3
a591 1
	kthread_create_deferred(pxapcic_create_event_thread, sc);
@

