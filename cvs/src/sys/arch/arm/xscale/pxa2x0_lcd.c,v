head	1.27;
access;
symbols
	OPENBSD_6_0:1.27.0.4
	OPENBSD_6_0_BASE:1.27
	OPENBSD_5_9:1.27.0.2
	OPENBSD_5_9_BASE:1.27
	OPENBSD_5_8:1.26.0.8
	OPENBSD_5_8_BASE:1.26
	OPENBSD_5_7:1.26.0.2
	OPENBSD_5_7_BASE:1.26
	OPENBSD_5_6:1.26.0.4
	OPENBSD_5_6_BASE:1.26
	OPENBSD_5_5:1.25.0.4
	OPENBSD_5_5_BASE:1.25
	OPENBSD_5_4:1.24.0.12
	OPENBSD_5_4_BASE:1.24
	OPENBSD_5_3:1.24.0.10
	OPENBSD_5_3_BASE:1.24
	OPENBSD_5_2:1.24.0.8
	OPENBSD_5_2_BASE:1.24
	OPENBSD_5_1_BASE:1.24
	OPENBSD_5_1:1.24.0.6
	OPENBSD_5_0:1.24.0.4
	OPENBSD_5_0_BASE:1.24
	OPENBSD_4_9:1.24.0.2
	OPENBSD_4_9_BASE:1.24
	OPENBSD_4_8:1.22.0.14
	OPENBSD_4_8_BASE:1.22
	OPENBSD_4_7:1.22.0.10
	OPENBSD_4_7_BASE:1.22
	OPENBSD_4_6:1.22.0.12
	OPENBSD_4_6_BASE:1.22
	OPENBSD_4_5:1.22.0.8
	OPENBSD_4_5_BASE:1.22
	OPENBSD_4_4:1.22.0.6
	OPENBSD_4_4_BASE:1.22
	OPENBSD_4_3:1.22.0.4
	OPENBSD_4_3_BASE:1.22
	OPENBSD_4_2:1.22.0.2
	OPENBSD_4_2_BASE:1.22
	OPENBSD_4_1:1.21.0.6
	OPENBSD_4_1_BASE:1.21
	OPENBSD_4_0:1.21.0.4
	OPENBSD_4_0_BASE:1.21
	OPENBSD_3_9:1.21.0.2
	OPENBSD_3_9_BASE:1.21
	OPENBSD_3_8:1.19.0.2
	OPENBSD_3_8_BASE:1.19
	OPENBSD_3_7:1.16.0.2
	OPENBSD_3_7_BASE:1.16;
locks; strict;
comment	@ * @;


1.27
date	2016.01.31.00.14.50;	author jsg;	state Exp;
branches;
next	1.26;
commitid	pbLjedMudUFrVMk6;

1.26
date	2014.07.12.18.44.41;	author tedu;	state Exp;
branches;
next	1.25;
commitid	uKVPYMN2MLxdZxzH;

1.25
date	2013.10.21.10.36.09;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2010.08.30.21.35.55;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2010.08.27.05.04.06;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2007.05.27.16.12.11;	author matthieu;	state Exp;
branches;
next	1.21;

1.21
date	2005.12.22.18.45.46;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2005.09.15.20.23.10;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2005.05.23.23.59.19;	author uwe;	state Exp;
branches;
next	1.18;

1.18
date	2005.04.30.23.13.47;	author pascoe;	state Exp;
branches;
next	1.17;

1.17
date	2005.04.11.03.32.48;	author uwe;	state Exp;
branches;
next	1.16;

1.16
date	2005.02.22.21.53.03;	author uwe;	state Exp;
branches;
next	1.15;

1.15
date	2005.02.17.23.16.33;	author drahn;	state Exp;
branches;
next	1.14;

1.14
date	2005.02.17.23.07.46;	author drahn;	state Exp;
branches;
next	1.13;

1.13
date	2005.02.17.19.24.30;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2005.01.31.06.41.25;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2005.01.21.16.22.34;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2005.01.17.04.22.34;	author drahn;	state Exp;
branches;
next	1.9;

1.9
date	2005.01.06.23.47.20;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2005.01.06.16.50.44;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2005.01.05.23.04.23;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2005.01.05.19.12.47;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2005.01.05.18.11.54;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2005.01.04.03.53.46;	author drahn;	state Exp;
branches;
next	1.3;

1.3
date	2005.01.03.04.50.22;	author drahn;	state Exp;
branches;
next	1.2;

1.2
date	2005.01.02.19.52.36;	author drahn;	state Exp;
branches;
next	1.1;

1.1
date	2004.12.30.23.50.07;	author drahn;	state Exp;
branches;
next	;


desc
@@


1.27
log
@Switch from PSR_X_bit and X32_bit PSR macro names to just PSR_X.
This matches FreeBSD and makes things a bit more consistent.
Discussed with Patrick.
@
text
@/*	$OpenBSD: pxa2x0_lcd.c,v 1.26 2014/07/12 18:44:41 tedu Exp $ */
/* $NetBSD: pxa2x0_lcd.c,v 1.8 2003/10/03 07:24:05 bsh Exp $ */

/*
 * Copyright (c) 2002  Genetec Corporation.  All rights reserved.
 * Written by Hiroyuki Bessho for Genetec Corporation.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed for the NetBSD Project by
 *	Genetec Corporation.
 * 4. The name of Genetec Corporation may not be used to endorse or 
 *    promote products derived from this software without specific prior
 *    written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY GENETEC CORPORATION ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL GENETEC CORPORATION
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Support PXA2[15]0's integrated LCD controller.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/conf.h>
#include <sys/uio.h>
#include <sys/malloc.h>
#include <sys/kernel.h>			/* for cold */

#include <uvm/uvm_extern.h>

#include <dev/cons.h> 

#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsdisplayvar.h> 
#include <dev/rasops/rasops.h>

#include <machine/bus.h>
#include <machine/cpu.h>
#include <arm/cpufunc.h>

#include <arm/xscale/pxa2x0var.h>
#include <arm/xscale/pxa2x0reg.h>
#include <arm/xscale/pxa2x0_lcd.h>
#include <arm/xscale/pxa2x0_gpio.h>

/*
 * Console variables. These are necessary since console is setup very early,
 * before devices get attached.
 */
struct {
	bus_space_tag_t			 iot;
	bus_space_handle_t		 ioh;
	bus_dma_tag_t			 dma_tag;
	const struct lcd_panel_geometry	*geometry;
	struct pxa2x0_lcd_screen	 scr;
} pxa2x0_lcd_console;

int	lcdintr(void *);
void	pxa2x0_lcd_geometry(bus_space_tag_t, bus_space_handle_t,
	    const struct lcd_panel_geometry *);
void	pxa2x0_lcd_initialize(bus_space_tag_t, bus_space_handle_t,
	    const struct lcd_panel_geometry *, void (*)(u_int, int));
int	pxa2x0_lcd_new_screen(struct pxa2x0_lcd_softc *,
	    struct pxa2x0_lcd_screen *, int);
void	pxa2x0_lcd_setup_console(struct pxa2x0_lcd_softc *,
	    const struct pxa2x0_wsscreen_descr *);
void	pxa2x0_lcd_setup_rasops(struct rasops_info *,
	    struct pxa2x0_wsscreen_descr *,
	    const struct lcd_panel_geometry *);
void	pxa2x0_lcd_start_dma(bus_space_tag_t, bus_space_handle_t,
	    struct pxa2x0_lcd_screen *);
void	pxa2x0_lcd_stop_dma(bus_space_tag_t, bus_space_handle_t);

/*
 * Setup display geometry parameters.
 */
void
pxa2x0_lcd_geometry(bus_space_tag_t iot, bus_space_handle_t ioh,
    const struct lcd_panel_geometry *info)
{
	int lines;
	uint32_t ccr0;

	ccr0 = LCCR0_IMASK;
	if (info->panel_info & LCDPANEL_ACTIVE)
		ccr0 |= LCCR0_PAS;	/* active mode */
	if ((info->panel_info & (LCDPANEL_DUAL | LCDPANEL_ACTIVE))
	    == LCDPANEL_DUAL)
		ccr0 |= LCCR0_SDS; /* dual panel */
	if (info->panel_info & LCDPANEL_MONOCHROME)
		ccr0 |= LCCR0_CMS;
	/* XXX - Zaurus C3000 */
	ccr0 |= LCCR0_LDDALT | 
	    LCCR0_OUC |
	    LCCR0_CMDIM |
	    LCCR0_RDSTM;

	bus_space_write_4(iot, ioh, LCDC_LCCR0, ccr0);

	bus_space_write_4(iot, ioh, LCDC_LCCR1,
	    (info->panel_width - 1)
	    | ((info->hsync_pulse_width - 1) << 10)
	    | ((info->end_line_wait - 1) << 16)
	    | ((info->beg_line_wait - 1) << 24));

	if (info->panel_info & LCDPANEL_DUAL)
		lines = info->panel_height / 2 + info->extra_lines;
	else
		lines = info->panel_height + info->extra_lines;

	bus_space_write_4(iot, ioh, LCDC_LCCR2,
	    (lines - 1)
	    | (info->vsync_pulse_width << 10)
	    | (info->end_frame_wait << 16)
	    | (info->beg_frame_wait << 24));

	bus_space_write_4(iot, ioh, LCDC_LCCR3,
	    (info->pixel_clock_div << 0)
	    | (info->ac_bias << 8)
	    | ((info->panel_info & 
		(LCDPANEL_VSP | LCDPANEL_HSP | LCDPANEL_PCP | LCDPANEL_OEP))
		<< 20)
	    | (4 << 24) /* 16bpp */
	    | ((info->panel_info & LCDPANEL_DPC) ? (1 << 27) : 0)
	    );
}

/*
 * Initialize the LCD controller.
 */
void
pxa2x0_lcd_initialize(bus_space_tag_t iot, bus_space_handle_t ioh,
    const struct lcd_panel_geometry *geom, void (*clkman)(u_int, int))
{
	int nldd;
	u_int32_t lccr0, lscr;

	/* Check if LCD is enabled before programming, it should not
	 * be enabled while it is being reprogrammed, therefore disable
	 * it first.
	 */
	lccr0 = bus_space_read_4(iot, ioh, LCDC_LCCR0);
	if (lccr0 & LCCR0_ENB) {
		lccr0 |= LCCR0_LDM;
		bus_space_write_4(iot, ioh, LCDC_LCCR0, lccr0);
		lccr0 = bus_space_read_4(iot, ioh, LCDC_LCCR0); /* paranoia */
		lccr0 |= LCCR0_DIS;
		bus_space_write_4(iot, ioh, LCDC_LCCR0, lccr0);
		do {
			lscr = bus_space_read_4(iot, ioh, LCDC_LCSR); 
		} while (!(lscr & LCSR_LDD));
	}

	/* enable clock */
	(*clkman)(CKEN_LCD, 1);

	bus_space_write_4(iot, ioh, LCDC_LCCR0, LCCR0_IMASK);

	/*
	 * setup GP[77:58] for LCD
	 */
	/* Always use [FLP]CLK, ACBIAS */
	pxa2x0_gpio_set_function(74, GPIO_ALT_FN_2_OUT);
	pxa2x0_gpio_set_function(75, GPIO_ALT_FN_2_OUT);
	pxa2x0_gpio_set_function(76, GPIO_ALT_FN_2_OUT);
	pxa2x0_gpio_set_function(77, GPIO_ALT_FN_2_OUT);

	if ((geom->panel_info & LCDPANEL_ACTIVE) ||
	    ((geom->panel_info & (LCDPANEL_MONOCHROME|LCDPANEL_DUAL)) ==
	    LCDPANEL_DUAL)) {
		/* active and color dual panel need L_DD[15:0] */
		nldd = 16;
	} else if ((geom->panel_info & LCDPANEL_DUAL) ||
	    !(geom->panel_info & LCDPANEL_MONOCHROME)) {
		/* dual or color need L_DD[7:0] */
		nldd = 8;
	} else {
		/* Otherwise just L_DD[3:0] */
		nldd = 4;
	}

	while (nldd--)
		pxa2x0_gpio_set_function(58 + nldd, GPIO_ALT_FN_2_OUT);

	pxa2x0_lcd_geometry(iot, ioh, geom);
}

/*
 * Common driver attachment code.
 */
void
pxa2x0_lcd_attach_sub(struct pxa2x0_lcd_softc *sc, 
    struct pxaip_attach_args *pxa, struct pxa2x0_wsscreen_descr *descr,
    const struct lcd_panel_geometry *geom, int console)
{
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
	int error;

	sc->n_screens = 0;
	LIST_INIT(&sc->screens);

	/* map controller registers if not console */
	if (console != 0) {
		iot = pxa2x0_lcd_console.iot;
		ioh = pxa2x0_lcd_console.ioh;
	} else {
		iot = pxa->pxa_iot;
		error = bus_space_map(iot, PXA2X0_LCDC_BASE, PXA2X0_LCDC_SIZE,
		    0, &ioh);
		if (error) {
			printf(": failed to map registers %d", error);
			return;
		}
	}

	sc->iot = iot;
	sc->ioh = ioh;
	sc->dma_tag = &pxa2x0_bus_dma_tag;

	sc->ih = pxa2x0_intr_establish(17, IPL_BIO, lcdintr, sc,
	    sc->dev.dv_xname);
	if (sc->ih == NULL)
		printf("%s: unable to establish interrupt at irq %d",
		    sc->dev.dv_xname, 17);

	sc->geometry = geom;

	if (console != 0) {
		/* complete console attachment */
		pxa2x0_lcd_setup_console(sc, descr);
	} else {
		struct rasops_info dummy;

		pxa2x0_lcd_initialize(iot, ioh, geom, pxa2x0_clkman_config);

		/*
		 * Initialize a dummy rasops_info to compute fontsize and
		 * the screen size in chars.
		 */
		bzero(&dummy, sizeof(dummy));
		pxa2x0_lcd_setup_rasops(&dummy, descr, geom);
	}
}

/*
 * Interrupt handler.
 */
int
lcdintr(void *arg)
{
	struct pxa2x0_lcd_softc *sc = arg;
	bus_space_tag_t iot = sc->iot;
	bus_space_handle_t ioh = sc->ioh;

	static uint32_t status;

	status = bus_space_read_4(iot, ioh, LCDC_LCSR);
	/* Clear sticky status bits */
	bus_space_write_4(iot, ioh, LCDC_LCSR, status);

	return 1;
}

/*
 * Enable DMA to cause the display to be refreshed periodically.
 * This brings the screen to life...
 */
void
pxa2x0_lcd_start_dma(bus_space_tag_t iot, bus_space_handle_t ioh,
    struct pxa2x0_lcd_screen *scr)
{
	uint32_t tmp;
	int val, save;

	save = disable_interrupts(PSR_I);

	switch (scr->depth) {
	case 1: val = 0; break;
	case 2: val = 1; break;
	case 4: val = 2; break;
	case 8: val = 3; break;
	case 16:
		/* FALLTHROUGH */
	default:
		val = 4; break;		
	}

	tmp = bus_space_read_4(iot, ioh, LCDC_LCCR3);
	bus_space_write_4(iot, ioh, LCDC_LCCR3, 
	    (tmp & ~LCCR3_BPP) | (val << LCCR3_BPP_SHIFT));

	bus_space_write_4(iot, ioh, LCDC_FDADR0, 
	    scr->depth == 16 ? scr->dma_desc_pa :
	    scr->dma_desc_pa + 2 * sizeof (struct lcd_dma_descriptor));
	bus_space_write_4(iot, ioh, LCDC_FDADR1, 
	    scr->dma_desc_pa + 1 * sizeof (struct lcd_dma_descriptor));

	/* clear status */
	bus_space_write_4(iot, ioh, LCDC_LCSR, 0);

	delay(1000);			/* ??? */

	/* Enable LCDC */
	tmp = bus_space_read_4(iot, ioh, LCDC_LCCR0);
	/*tmp &= ~LCCR0_SFM;*/
	bus_space_write_4(iot, ioh, LCDC_LCCR0, tmp | LCCR0_ENB);

	restore_interrupts(save);
}

/*
 * Disable screen refresh.
 */
void
pxa2x0_lcd_stop_dma(bus_space_tag_t iot, bus_space_handle_t ioh)
{

	/* Stop LCD DMA after current frame */
	bus_space_write_4(iot, ioh, LCDC_LCCR0,
	    LCCR0_DIS |
	    bus_space_read_4(iot, ioh, LCDC_LCCR0));

	/* wait for disabling done.
	   XXX: use interrupt. */
	while (LCCR0_ENB &
	    bus_space_read_4(iot, ioh, LCDC_LCCR0))
		;

	bus_space_write_4(iot, ioh, LCDC_LCCR0,
	    ~LCCR0_DIS &
	    bus_space_read_4(iot, ioh, LCDC_LCCR0));
}

#define _rgb(r,g,b)	(((r)<<11) | ((g)<<5) | b)
#define rgb(r,g,b)	_rgb((r)>>1,g,(b)>>1)

#define L	0x1f			/* low intensity */
#define H	0x3f			/* high intensity */

static uint16_t basic_color_map[] = {
	rgb(	0,   0,   0),		/* black */
	rgb(	L,   0,   0),		/* red */
	rgb(	0,   L,   0),		/* green */
	rgb(	L,   L,   0),		/* brown */
	rgb(	0,   0,   L),		/* blue */
	rgb(	L,   0,   L),		/* magenta */
	rgb(	0,   L,   L),		/* cyan */
	rgb( 0x31,0x31,0x31),		/* white */

	rgb(	L,   L,   L),		/* black */
	rgb(	H,   0,   0),		/* red */
	rgb(	0,   H,   0),		/* green */
	rgb(	H,   H,   0),		/* brown */
	rgb(	0,   0,   H),		/* blue */
	rgb(	H,   0,   H),		/* magenta */
	rgb(	0,   H,   H),		/* cyan */
	rgb(	H,   H,   H)
};

#undef H
#undef L

static void
init_palette(uint16_t *buf, int depth)
{
	int i;

	/* convert RGB332 to RGB565 */
	switch (depth) {
	case 8:
	case 4:
#if 0
		for (i = 0; i <= 255; ++i) {
			buf[i] = ((9 * ((i >> 5) & 0x07)) << 11) |
			    ((9 * ((i >> 2) & 0x07)) << 5) |
			    ((21 * (i & 0x03)) / 2);
		}
#else
		memcpy(buf, basic_color_map, sizeof basic_color_map);
		for (i = 16; i < (1 << depth); ++i)
			buf[i] = 0xffff;
#endif
		break;
	case 16:
		/* palette is not needed */
		break;
	default:
		/* other depths are not supported */
		break;
	}
}

/*
 * Create and initialize a new screen buffer.
 */
int
pxa2x0_lcd_new_screen(struct pxa2x0_lcd_softc *sc,
    struct pxa2x0_lcd_screen *scr, int depth)
{
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
	bus_dma_tag_t dma_tag;
	const struct lcd_panel_geometry *geometry;
	int width, height;
	bus_size_t size;
	int error, palette_size;
	int busdma_flag = (cold ? BUS_DMA_NOWAIT : BUS_DMA_WAITOK);
	struct lcd_dma_descriptor *desc;
	paddr_t buf_pa, desc_pa;

	if (sc != NULL) {
		iot = sc->iot;
		ioh = sc->ioh;
		dma_tag = sc->dma_tag;
		geometry = sc->geometry;
	} else {
		/* We are creating the console screen. */
		iot = pxa2x0_lcd_console.iot;
		ioh = pxa2x0_lcd_console.ioh;
		dma_tag = pxa2x0_lcd_console.dma_tag;
		geometry = pxa2x0_lcd_console.geometry;
	}

	width = geometry->panel_width;
	height = geometry->panel_height;
	palette_size = 0;

	switch (depth) {
	case 1:
	case 2:
	case 4:
	case 8:
		palette_size = (1 << depth) * sizeof (uint16_t);
		/* FALLTHROUGH */
	case 16:
		size = roundup(width, 4) * depth / 8 * height;
		break;
	default:
		printf("%s: Unknown depth (%d)\n",
		    sc != NULL ? sc->dev.dv_xname : "console", depth);
		return (EINVAL);
	}

	bzero(scr, sizeof *scr);

	scr->nsegs = 0;
	scr->depth = depth;
	scr->buf_size = size;
	scr->buf_va = NULL;
	size = roundup(size, 16) + 3 * sizeof (struct lcd_dma_descriptor)
	    + palette_size;

	error = bus_dmamem_alloc(dma_tag, size, 16, 0,
	    scr->segs, 1, &(scr->nsegs), busdma_flag);
	if (error != 0 || scr->nsegs != 1) {
		/* XXX: Actually we can handle nsegs > 1 case by means
		   of multiple DMA descriptors for a panel.  It would
		    make code here a bit hairy */
		if (error == 0)
			error = E2BIG;
		goto bad;
	}

	error = bus_dmamem_map(dma_tag, scr->segs, scr->nsegs,
	    size, (caddr_t *)&(scr->buf_va), busdma_flag | BUS_DMA_COHERENT);
	if (error != 0)
		goto bad;

	memset(scr->buf_va, 0, scr->buf_size);

	/* map memory for DMA */
	if (bus_dmamap_create(dma_tag, 1024 * 1024 * 2, 1, 
	    1024 * 1024 * 2, 0,  busdma_flag, &scr->dma))
		goto bad;
	error = bus_dmamap_load(dma_tag, scr->dma,
	    scr->buf_va, size, NULL, busdma_flag);
	if (error != 0) {
		goto bad;
	}

	buf_pa = scr->segs[0].ds_addr;
	desc_pa = buf_pa + roundup(size, PAGE_SIZE) - 3 * sizeof *desc;

	/* make descriptors at the top of mapped memory */
	desc = (struct lcd_dma_descriptor *)
	    ((caddr_t)(scr->buf_va) + roundup(size, PAGE_SIZE) -
	     3 * sizeof *desc);

	desc[0].fdadr = desc_pa;
	desc[0].fsadr = buf_pa;
	desc[0].ldcmd = scr->buf_size;

	if (palette_size) {
		init_palette((uint16_t *)((char *)desc - palette_size), depth);

		desc[2].fdadr = desc_pa; /* chain to panel 0 */
		desc[2].fsadr = desc_pa - palette_size;
		desc[2].ldcmd = palette_size | LDCMD_PAL;
	}

	if (geometry->panel_info & LCDPANEL_DUAL) {
		/* Dual panel */
		desc[1].fdadr = desc_pa + sizeof *desc;
		desc[1].fsadr = buf_pa + scr->buf_size / 2;
		desc[0].ldcmd = desc[1].ldcmd = scr->buf_size / 2;

	}

#if 0
	desc[0].ldcmd |= LDCMD_SOFINT;
	desc[1].ldcmd |= LDCMD_SOFINT;
#endif

	scr->dma_desc = desc;
	scr->dma_desc_pa = desc_pa;
	scr->map_size = size;		/* used when unmap this. */

	if (sc != NULL) {
		LIST_INSERT_HEAD(&(sc->screens), scr, link);
		sc->n_screens++;
	}
	
	return (0);

 bad:
	if (scr->buf_va)
		bus_dmamem_unmap(dma_tag, scr->buf_va, size);
	if (scr->nsegs)
		bus_dmamem_free(dma_tag, scr->segs, scr->nsegs);
	return (error);
}

/*
 * Initialize rasops for a screen, as well as struct wsscreen_descr if this
 * is the first screen creation.
 */
void
pxa2x0_lcd_setup_rasops(struct rasops_info *rinfo,
    struct pxa2x0_wsscreen_descr *descr,
    const struct lcd_panel_geometry *geom)
{

	rinfo->ri_flg = descr->flags;
	rinfo->ri_depth = descr->depth;
	rinfo->ri_width = geom->panel_width;
	rinfo->ri_height = geom->panel_height;
	rinfo->ri_stride = rinfo->ri_width * rinfo->ri_depth / 8;
#ifdef notyet
	rinfo->ri_wsfcookie = -1;	/* XXX */
#endif

	/* swap B and R */
	if (descr->depth == 16) {
		rinfo->ri_rnum = 5;
		rinfo->ri_rpos = 11;
		rinfo->ri_gnum = 6;
		rinfo->ri_gpos = 5;
		rinfo->ri_bnum = 5;
		rinfo->ri_bpos = 0;
	}

	if (descr->c.nrows == 0) {
		/* get rasops to compute screen size the first time */
		rasops_init(rinfo, 100, 100);
	} else
#ifndef __zaurus__
		rasops_init(rinfo, descr->c.nrows, descr->c.ncols);
#else
		/* XXX swap rows/cols for second call because of rotation */
		rasops_init(rinfo, descr->c.ncols, descr->c.nrows);
#endif

	descr->c.nrows = rinfo->ri_rows;
	descr->c.ncols = rinfo->ri_cols;
	descr->c.capabilities = rinfo->ri_caps;
	descr->c.textops = &rinfo->ri_ops;
}

/*
 * Early console attachment.
 * This initializes the LCD, then creates and displays a screen buffer.
 * This screen will be accounted for in the softc when the lcd device attaches.
 */
int
pxa2x0_lcd_cnattach(struct pxa2x0_wsscreen_descr *descr,
    const struct lcd_panel_geometry *geom, void (*clkman)(u_int, int))
{
	struct rasops_info *ri;
	long defattr;
	int error;

	/* map controller registers */
	pxa2x0_lcd_console.iot = &pxa2x0_bs_tag;
	error = bus_space_map(pxa2x0_lcd_console.iot,
	    PXA2X0_LCDC_BASE, PXA2X0_LCDC_SIZE, 0, &pxa2x0_lcd_console.ioh);
	if (error != 0)
		return (error);
	
	pxa2x0_lcd_console.dma_tag = &pxa2x0_bus_dma_tag;
	pxa2x0_lcd_console.geometry = geom;

	pxa2x0_lcd_initialize(pxa2x0_lcd_console.iot, pxa2x0_lcd_console.ioh,
	    pxa2x0_lcd_console.geometry, clkman);

	error = pxa2x0_lcd_new_screen(NULL, &pxa2x0_lcd_console.scr,
	    descr->depth);
	if (error != 0)
		return (error);

	ri = &pxa2x0_lcd_console.scr.rinfo;
	ri->ri_hw = (void *)&pxa2x0_lcd_console.scr;
	ri->ri_bits = pxa2x0_lcd_console.scr.buf_va;
	pxa2x0_lcd_setup_rasops(ri, descr, pxa2x0_lcd_console.geometry);

	/* assumes 16 bpp */
	ri->ri_ops.alloc_attr(ri, 0, 0, 0, &defattr);

	pxa2x0_lcd_start_dma(pxa2x0_lcd_console.iot, pxa2x0_lcd_console.ioh,
	    &pxa2x0_lcd_console.scr);

	wsdisplay_cnattach(&descr->c, ri, ri->ri_ccol, ri->ri_crow, defattr);

	return (0);
}

/*
 * Do the necessary accounting to bring the console variables in the softc.
 */
void
pxa2x0_lcd_setup_console(struct pxa2x0_lcd_softc *sc,
    const struct pxa2x0_wsscreen_descr *descr)
{
	struct pxa2x0_lcd_screen *scr = &pxa2x0_lcd_console.scr;

	/*
	 * Register the console screen as if it had been created
	 * when the lcd device attached.
	 */
	LIST_INSERT_HEAD(&(sc->screens), &pxa2x0_lcd_console.scr, link);
	sc->n_screens++;
	sc->active = scr;
}

/*
 * wsdisplay accessops
 */

int
pxa2x0_lcd_show_screen(void *v, void *cookie, int waitok,
    void (*cb)(void *, int, int), void *cbarg)
{
	struct pxa2x0_lcd_softc *sc = v;
	struct rasops_info *ri = cookie;
	struct pxa2x0_lcd_screen *scr = ri->ri_hw, *old;
	
	old = sc->active;
	if (old == scr)
		return 0;

	if (old)
		pxa2x0_lcd_stop_dma(sc->iot, sc->ioh);
	
	pxa2x0_lcd_start_dma(sc->iot, sc->ioh, scr);

	sc->active = scr;
	return 0;
}

int
pxa2x0_lcd_alloc_screen(void *v, const struct wsscreen_descr *_type,
    void **cookiep, int *curxp, int *curyp, long *attrp)
{
	struct pxa2x0_lcd_softc *sc = v;
	struct pxa2x0_lcd_screen *scr;
	struct rasops_info *ri;
	struct pxa2x0_wsscreen_descr *type =
	    (struct pxa2x0_wsscreen_descr *)_type;
	int error;

	scr = malloc(sizeof *scr, M_DEVBUF, (cold ? M_NOWAIT : M_WAITOK));
	if (scr == NULL)
		return (ENOMEM);

	error = pxa2x0_lcd_new_screen(sc, scr, type->depth);
	if (error != 0) {
		free(scr, M_DEVBUF, 0);
		return (error);
	}

	/*
	 * initialize raster operation for this screen.
	 */
	ri = &scr->rinfo;
	ri->ri_hw = (void *)scr;
	ri->ri_bits = scr->buf_va;
	pxa2x0_lcd_setup_rasops(ri, type, sc->geometry);

	/* assumes 16 bpp */
	ri->ri_ops.alloc_attr(ri, 0, 0, 0, attrp);

	*cookiep = ri;
	*curxp = 0;
	*curyp = 0;

	return 0;
}

void
pxa2x0_lcd_free_screen(void *v, void *cookie)
{
	struct pxa2x0_lcd_softc *sc = v;
	struct rasops_info *ri = cookie;
	struct pxa2x0_lcd_screen *scr = ri->ri_hw;

	LIST_REMOVE(scr, link);
	sc->n_screens--;
	if (scr == sc->active) {
		/* at first, we need to stop LCD DMA */
		sc->active = NULL;

#ifdef DEBUG
		printf("lcd_free on active screen\n");
#endif

		pxa2x0_lcd_stop_dma(sc->iot, sc->ioh);
	}

	if (scr->buf_va)
		bus_dmamem_unmap(sc->dma_tag, scr->buf_va, scr->map_size);

	if (scr->nsegs > 0)
		bus_dmamem_free(sc->dma_tag, scr->segs, scr->nsegs);

	free(scr, M_DEVBUF, 0);
}

int
pxa2x0_lcd_ioctl(void *v, u_long cmd, caddr_t data, int flag, struct proc *p)
{
	struct pxa2x0_lcd_softc *sc = v;
	struct wsdisplay_fbinfo *wsdisp_info;
	struct pxa2x0_lcd_screen *scr = sc->active;  /* ??? */

	switch (cmd) {
	case WSDISPLAYIO_GTYPE:
		*(u_int *)data = WSDISPLAY_TYPE_PXALCD; /* XXX */
		break;

	case WSDISPLAYIO_GINFO:
		wsdisp_info = (struct wsdisplay_fbinfo *)data;

		wsdisp_info->height = sc->geometry->panel_height;
		wsdisp_info->width = sc->geometry->panel_width;
		wsdisp_info->depth = 16; /* XXX */
		wsdisp_info->cmsize = 0;
		break;

	case WSDISPLAYIO_GETSUPPORTEDDEPTH:
		*(u_int *)data = WSDISPLAYIO_DEPTH_16;
		break;

	case WSDISPLAYIO_GETCMAP:
	case WSDISPLAYIO_PUTCMAP:
		return EINVAL;	/* XXX Colormap */

	case WSDISPLAYIO_SVIDEO:
	case WSDISPLAYIO_GVIDEO:
		break;

	case WSDISPLAYIO_GCURPOS:
	case WSDISPLAYIO_SCURPOS:
	case WSDISPLAYIO_GCURMAX:
	case WSDISPLAYIO_GCURSOR:
	case WSDISPLAYIO_SCURSOR:
	default:
		return -1;	/* not implemented */

        case WSDISPLAYIO_LINEBYTES:
		*(u_int *)data = scr->rinfo.ri_stride;
		break;
	}
	return (0);
}

paddr_t
pxa2x0_lcd_mmap(void *v, off_t offset, int prot)
{
	struct pxa2x0_lcd_softc *sc = v;
	struct pxa2x0_lcd_screen *screen = sc->active;  /* ??? */

	if ((offset & PAGE_MASK) != 0)
		return (-1);

	if (screen == NULL)
		return (-1);

	if (offset < 0 ||
	    offset >= screen->rinfo.ri_stride * screen->rinfo.ri_height)
		return (-1);

	return (bus_dmamem_mmap(sc->dma_tag, screen->segs, screen->nsegs,
	    offset, prot, BUS_DMA_WAITOK | BUS_DMA_COHERENT));
}

int
pxa2x0_lcd_load_font(void *v, void *emulcookie, struct wsdisplay_font *font)
{
	struct pxa2x0_lcd_softc *sc = v;
	struct pxa2x0_lcd_screen *screen = sc->active;

	if (screen == NULL)
		return ENXIO;

	return rasops_load_font(&screen->rinfo, emulcookie, font);
}

int
pxa2x0_lcd_list_font(void *v, struct wsdisplay_font *font)
{
	struct pxa2x0_lcd_softc *sc = v;
	struct pxa2x0_lcd_screen *screen = sc->active;

	if (screen == NULL)
		return ENXIO;

	return rasops_list_font(&screen->rinfo, font);
}

void
pxa2x0_lcd_suspend(struct pxa2x0_lcd_softc *sc)
{

	if (sc->active != NULL) {
		pxa2x0_lcd_stop_dma(sc->iot, sc->ioh);

		pxa2x0_clkman_config(CKEN_LCD, 0);
	}
}

void
pxa2x0_lcd_resume(struct pxa2x0_lcd_softc *sc)
{

	if (sc->active != NULL) {
		pxa2x0_lcd_initialize(sc->iot, sc->ioh, sc->geometry,
		    pxa2x0_clkman_config);
		pxa2x0_lcd_start_dma(sc->iot, sc->ioh, sc->active);
	}
}
@


1.26
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_lcd.c,v 1.25 2013/10/21 10:36:09 miod Exp $ */
d295 1
a295 1
	save = disable_interrupts(I32_bit);
@


1.25
log
@Add load_font and list_font accessops to all rasops-based wsdisplay drivers.
Trivial except for tga(4) and gpx(4/vax) which need a bit more care setting
up a new font.
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_lcd.c,v 1.24 2010/08/30 21:35:55 deraadt Exp $ */
d706 1
a706 1
		free(scr, M_DEVBUF);
d754 1
a754 1
	free(scr, M_DEVBUF);
@


1.24
log
@Convert all powerhooks to activate functions, and provide powerhook stubs.
Of note:  lcd stubs get pulled up to the parent; zts has to keep track of
whether it is in use or not
testing by myself and jakemsr; proof reading by oga
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_lcd.c,v 1.23 2010/08/27 05:04:06 deraadt Exp $ */
d823 24
@


1.23
log
@More killing of PWR_STANDBY.  cvs skipped these files
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_lcd.c,v 1.22 2007/05/27 16:12:11 matthieu Exp $ */
a843 16
	}
}

void
pxa2x0_lcd_power(int why, void *v)
{
	struct pxa2x0_lcd_softc *sc = v;

	switch (why) {
	case PWR_SUSPEND:
		pxa2x0_lcd_suspend(sc);
		break;

	case PWR_RESUME:
		pxa2x0_lcd_resume(sc);
		break;
@


1.22
log
@implement WSDISPLAYIO_GETSUPPORTEDDEPTHS. ok miod@@ uwe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_lcd.c,v 1.21 2005/12/22 18:45:46 deraadt Exp $ */
a853 1
	case PWR_STANDBY:
@


1.21
log
@do not do delay(HUGEVALUE) after enabling/disabling the lcd dma.  yes, it
has a weird effect when you enable it and the backlight at the same time,
but most people don't see it because they are flipping the lid open.  and
it is not actually weird, it is actually rather neat.  ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_lcd.c,v 1.20 2005/09/15 20:23:10 miod Exp $ */
d776 4
@


1.20
log
@Stop compiling the texte console rotation code #ifdef __zaurus__, but use
a flag in the rasops_info structure; drivers which may use it shall declare
a specific attribute for the config(8) machinery, so that the necessary code
is compiled in.

In addition to this, rotated font computation is now done on-demand, and a
list of unrotated-rotated font cookie pairs is kept, rather than rotating all
built-in wsfonts at initialization time.

No user-perceptible functional change.

Tested matthieu@@ uwe@@, ok uwe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_lcd.c,v 1.19 2005/05/23 23:59:19 uwe Exp $ */
a91 2
void	pxa2x0_lcd_suspend(struct pxa2x0_lcd_softc *);
void	pxa2x0_lcd_resume(struct pxa2x0_lcd_softc *);
d192 1
a192 2
	} else
	if ((geom->panel_info & LCDPANEL_DUAL) ||
d827 1
a828 1
		delay(1000000);	/* XXX */
a839 2
		/* XXX wait here to avoid a weird fade-in effect. */
		delay(1000000);
@


1.19
log
@fix rasops initialization when not acting as console; ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_lcd.c,v 1.18 2005/04/30 23:13:47 pascoe Exp $ */
d566 1
a566 1
	rinfo->ri_flg = 0;
@


1.18
log
@Temporary hack to (un)rotate the Zaurus console until a proper rasops
rotation framework is ready.
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_lcd.c,v 1.17 2005/04/11 03:32:48 uwe Exp $ */
a587 5

		descr->c.nrows = rinfo->ri_rows;
		descr->c.ncols = rinfo->ri_cols;
		descr->c.capabilities = rinfo->ri_caps;
		descr->c.textops = &rinfo->ri_ops;
d595 5
a643 4
	descr->c.nrows = ri->ri_rows;
	descr->c.ncols = ri->ri_cols;
	descr->c.capabilities = ri->ri_caps;
	descr->c.textops = &ri->ri_ops;
@


1.17
log
@- eliminate extra powerhook in pxalcd, inspired by ohci changes
- update file comment for zaurus_lcd.c
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_lcd.c,v 1.16 2005/02/22 21:53:03 uwe Exp $ */
d594 1
d596 4
@


1.16
log
@Initial suspend/resume code with additional powerhooks.  Enter/exit
suspend mode with power button or zzz.  May not work for everyone yet.
ok drahn@@ and deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_lcd.c,v 1.15 2005/02/17 23:16:33 drahn Exp $ */
a93 1
void	pxa2x0_lcd_powerhook(int, void *);
a265 2

	(void)powerhook_establish(pxa2x0_lcd_powerhook, sc);
d848 1
a848 1
pxa2x0_lcd_powerhook(int why, void *v)
@


1.15
log
@How he wanted it work, from/ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_lcd.c,v 1.14 2005/02/17 23:07:46 drahn Exp $ */
d92 3
d267 2
d824 41
@


1.14
log
@untested, no ok, and it broke. revert.
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_lcd.c,v 1.13 2005/02/17 19:24:30 miod Exp $ */
d261 1
a563 1
	bzero(rinfo, sizeof(struct rasops_info));
a626 1
	pxa2x0_lcd_setup_rasops(ri, descr, pxa2x0_lcd_console.geometry);
d629 1
a713 1
	pxa2x0_lcd_setup_rasops(ri, type, sc->geometry);
d716 1
@


1.13
log
@Setup ri_bits before invoking rasops_init(), in case we want to use RI_CLEAR
in ri_flg someday.
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_lcd.c,v 1.12 2005/01/31 06:41:25 miod Exp $ */
d627 1
a629 1
	pxa2x0_lcd_setup_rasops(ri, descr, pxa2x0_lcd_console.geometry);
d714 1
a716 1
	pxa2x0_lcd_setup_rasops(ri, type, sc->geometry);
@


1.12
log
@Be sure to always return an error for unrecognized ioctls. Found by matthieu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_lcd.c,v 1.11 2005/01/21 16:22:34 miod Exp $ */
a626 1
	pxa2x0_lcd_setup_rasops(ri, descr, pxa2x0_lcd_console.geometry);
d629 1
a713 1
	pxa2x0_lcd_setup_rasops(ri, type, sc->geometry);
d716 1
@


1.11
log
@Overhaul of the pxa2x0_lcd code, to allow early (before autoconf) attachment,
and collateral changes.

Because this driver requires us_dma (and as such, vm services) to work, it
can not be selected in consinit(). Instead, add a hook to the arm
cpu_startup() which will, on zaurus, switch console from serial (selected
in consinit()) to lcd.

This also makes the zaurus-specific early pxa2x0_clkman() substitute code
cleaner.

While there, move boot -c handling later, after the glass console is set up.

Tested by drahn@@ and uwe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_lcd.c,v 1.10 2005/01/17 04:22:34 drahn Exp $ */
d791 1
@


1.10
log
@Add LINEBYTES for wsfb, change type to PXALCD.
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_lcd.c,v 1.9 2005/01/06 23:47:20 miod Exp $ */
d51 1
a53 1
#include <dev/wscons/wscons_callbacks.h>
a54 1
#include <dev/wsfont/wsfont.h>
d65 27
a91 1
int lcdintr(void *);
d93 3
d97 1
a97 1
pxa2x0_lcd_geometry(struct pxa2x0_lcd_softc *sc,
a100 2
	bus_space_tag_t iot = sc->iot;
	bus_space_handle_t ioh = sc->ioh;
a102 2
	sc->geometry = info;

d106 1
a106 1
	if ((info->panel_info & (LCDPANEL_DUAL|LCDPANEL_ACTIVE))
d120 4
a123 4
	    (info->panel_width-1)
	    | ((info->hsync_pulse_width-1)<<10)
	    | ((info->end_line_wait-1)<<16)
	    | ((info->beg_line_wait-1)<<24));
d126 1
a126 1
		lines = info->panel_height/2 + info->extra_lines;
d131 4
a134 4
	    (lines-1)
	    | (info->vsync_pulse_width<<10)
	    | (info->end_frame_wait<<16)
	    | (info->beg_frame_wait<<24));
d137 1
a137 1
	    (info->pixel_clock_div<<0)
d140 2
a141 2
		(LCDPANEL_VSP|LCDPANEL_HSP|LCDPANEL_PCP|LCDPANEL_OEP))
		<<20)
d143 1
a143 1
	    | ((info->panel_info & LCDPANEL_DPC) ? (1<<27) : 0)
d147 3
d151 2
a152 2
pxa2x0_lcd_attach_sub(struct pxa2x0_lcd_softc *sc, 
    struct pxaip_attach_args *pxa, const struct lcd_panel_geometry *geom)
d154 1
a154 3
	bus_space_tag_t iot = pxa->pxa_iot;
	bus_space_handle_t ioh;
	int error, nldd;
a156 22
	sc->n_screens = 0;
	LIST_INIT(&sc->screens);

	/* map controller registers */
	error = bus_space_map(iot, PXA2X0_LCDC_BASE, PXA2X0_LCDC_SIZE, 0, &ioh);
	if (error) {
		printf(": failed to map registers %d", error);
		return;
	}

	sc->iot = iot;
	sc->ioh = ioh;
	sc->dma_tag = &pxa2x0_bus_dma_tag;

	sc->ih = pxa2x0_intr_establish(17, IPL_BIO, lcdintr, sc,
	    sc->dev.dv_xname);
	if (sc->ih == NULL)
		printf("%s: unable to establish interrupt at irq %d",
		    sc->dev.dv_xname, 17);

	/* Initialize LCD controller */

d174 1
a174 1
	pxa2x0_clkman_config(CKEN_LCD, 1);
d205 58
a262 1
	pxa2x0_lcd_geometry(sc, geom);
d265 3
d284 4
d289 1
a289 1
pxa2x0_lcd_start_dma(struct pxa2x0_lcd_softc *sc,
a292 2
	bus_space_tag_t iot = sc->iot;
	bus_space_handle_t ioh = sc->ioh;
a328 1

d331 5
a335 2
static void
pxa2x0_lcd_stop_dma(struct pxa2x0_lcd_softc *sc)
d337 1
d339 1
a339 1
	bus_space_write_4(sc->iot, sc->ioh, LCDC_LCCR0,
d341 1
a341 1
	    bus_space_read_4(sc->iot, sc->ioh, LCDC_LCCR0));
d346 1
a346 1
	    bus_space_read_4(sc->iot, sc->ioh, LCDC_LCCR0))
d349 1
a349 1
	bus_space_write_4(sc->iot, sc->ioh, LCDC_LCCR0,
d351 1
a351 1
	    bus_space_read_4(sc->iot, sc->ioh, LCDC_LCCR0));
d393 4
a396 4
		for (i=0; i <= 255; ++i) {
			buf[i] = ((9 * ((i>>5) & 0x07)) <<11) |
			    ((9 * ((i>>2) & 0x07)) << 5) |
			    ((21 * (i & 0x03))/2);
d400 1
a400 1
		for (i=16; i < (1<<depth); ++i)
d413 4
a416 1
struct pxa2x0_lcd_screen *
d418 1
a418 1
    int depth)
d420 4
a423 1
	struct pxa2x0_lcd_screen *scr = NULL;
d431 15
a445 2
	width = sc->geometry->panel_width;
	height = sc->geometry->panel_height;
d453 1
a453 1
		palette_size = (1<<depth) * sizeof (uint16_t);
d456 1
a456 1
		size = roundup(width,4)*depth/8 * height;
d459 3
a461 2
		printf("%s: Unknown depth (%d)\n", sc->dev.dv_xname, depth);
		return NULL;
d464 1
a464 6
	scr = malloc(sizeof *scr, M_DEVBUF, (cold ? M_NOWAIT : M_WAITOK));

	if (scr == NULL)
		return NULL;

	bzero (scr, sizeof *scr);
d470 1
a470 1
	size = roundup(size,16) + 3 * sizeof (struct lcd_dma_descriptor)
d473 1
a473 1
	error = bus_dmamem_alloc(sc->dma_tag, size, 16, 0,
d475 1
a475 2

	if (error || scr->nsegs != 1) {
d479 2
d484 1
a484 1
	error = bus_dmamem_map(sc->dma_tag, scr->segs, scr->nsegs,
d486 1
a486 1
	if (error)
d489 1
a489 1
	memset (scr->buf_va, 0, scr->buf_size);
d492 2
a493 2
	if (bus_dmamap_create(sc->dma_tag, 1024*1024*2, 1, 
	    1024*1024*2, 0,  busdma_flag, &scr->dma))
d495 1
a495 1
	error = bus_dmamap_load(sc->dma_tag, scr->dma,
d497 1
a497 1
	if (error) {
d502 1
a502 1
	desc_pa = buf_pa + roundup(size, PAGE_SIZE) - 3*sizeof *desc;
d505 3
a507 3
	desc = (struct lcd_dma_descriptor *)(
		(caddr_t)(scr->buf_va) + roundup(size, PAGE_SIZE) -
			  3*sizeof *desc);
d521 1
a521 1
	if (sc->geometry->panel_info & LCDPANEL_DUAL) {
d524 2
a525 2
		desc[1].fsadr = buf_pa + scr->buf_size/2;
		desc[0].ldcmd = desc[1].ldcmd = scr->buf_size/2;
d538 4
a541 2
	LIST_INSERT_HEAD(&(sc->screens), scr, link);
	sc->n_screens++;
d543 1
a543 1
	return scr;
d546 5
a550 8
	if (scr) {
		if (scr->buf_va)
			bus_dmamem_unmap(sc->dma_tag, scr->buf_va, size);
		if (scr->nsegs)
			bus_dmamem_free(sc->dma_tag, scr->segs, scr->nsegs);
		free(scr, M_DEVBUF);
	}
	return NULL;
d554 2
a555 2
 * Initialize struct wsscreen_descr based on values calculated by 
 * raster operation subsystem.
d557 2
a558 2
int
pxa2x0_lcd_setup_wsscreen(struct pxa2x0_lcd_softc *sc,
d560 1
a560 2
    const struct lcd_panel_geometry *geom,
    const char *fontname)
a561 7
	int width = geom->panel_width;
	int height = geom->panel_height;
	int cookie = -1;
	struct rasops_info *rinfo;

	rinfo = &sc->sc_ro;
	memset(rinfo, 0, sizeof(struct rasops_info));
d563 6
d570 1
a570 10
	if (fontname) {
		wsfont_init();
		cookie = wsfont_find((char *)fontname, 0, 0, 0, 
		    WSDISPLAY_FONTORDER_L2R, WSDISPLAY_FONTORDER_L2R);
		if (cookie < 0 ||
		    wsfont_lock(cookie, &rinfo.ri_font))
			return -1;
	} else {
		/* let rasops_init() choose any font */
	}
d573 1
a573 9
	/* let rasops_init calculate # of cols and rows in character */
	rinfo->ri_flg = 0;
	rinfo->ri_depth = descr->depth;
	rinfo->ri_bits = NULL;
	rinfo->ri_width = width;
	rinfo->ri_height = height;
	rinfo->ri_stride = width * rinfo->ri_depth / 8;
	rinfo->ri_wsfcookie = cookie;

d583 37
a619 1
	rasops_init(rinfo, 100, 100);
d621 21
a641 4
	descr->c.nrows = rinfo->ri_rows;
	descr->c.ncols = rinfo->ri_cols;
	descr->c.capabilities = rinfo->ri_caps;
	descr->c.textops = &rinfo->ri_ops;
d643 1
a643 1
	return cookie;
d646 4
a649 1
int
d653 1
a653 1
	struct pxa2x0_lcd_screen *scr;
d655 8
a662 7
	scr = pxa2x0_lcd_new_screen(sc, descr->depth);
	if (scr == NULL)
		return (ENOMEM);
	
	sc->sc_ro.ri_hw = (void *)scr;
	sc->sc_ro.ri_bits = scr->buf_va;
	bcopy(&sc->sc_ro, &scr->rinfo, sizeof(struct rasops_info));
d664 3
a666 3
	pxa2x0_lcd_show_screen(sc, &sc->sc_ro, 0, NULL, NULL);
	return (0);
}
d681 1
a681 1
		pxa2x0_lcd_stop_dma(sc);
d683 1
a683 1
	pxa2x0_lcd_start_dma(sc, scr);
d696 3
a698 1
	struct pxa2x0_wsscreen_descr *type = (struct pxa2x0_wsscreen_descr *)_type;
d700 1
a700 1
	scr = pxa2x0_lcd_new_screen(sc, type->depth);
d704 6
d714 1
a715 2
	ri->ri_flg = 0;
	ri->ri_depth = type->depth;
a716 17
	ri->ri_width = sc->geometry->panel_width;
	ri->ri_height = sc->geometry->panel_height;
	ri->ri_stride = ri->ri_width * ri->ri_depth / 8;
#ifdef notyet
	ri->ri_wsfcookie = -1;	/* XXX */
#endif

	if (type->depth == 16) {
		ri->ri_rnum = 5;
		ri->ri_rpos = 11;
		ri->ri_gnum = 6;
		ri->ri_gpos = 5;
		ri->ri_bnum = 5;
		ri->ri_bpos = 0;
	}

	rasops_init(ri, type->c.nrows, type->c.ncols);
d718 1
d741 1
d743 1
d745 1
a745 1
		pxa2x0_lcd_stop_dma(sc);
d813 1
a813 1
	    offset > screen->rinfo.ri_stride * screen->rinfo.ri_height)
@


1.9
log
@Lazy man's display console on Zaurus: allow the display to be attached as a
console when it is probed. Earlier boot messages are still being sent to the
serial port for now.

While there, swap blue and red in 16bpp mode to get the expected display
colours.

Tested and ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_lcd.c,v 1.8 2005/01/06 16:50:44 miod Exp $ */
d648 1
d652 1
a652 1
		*(u_int *)data = WSDISPLAY_TYPE_UNKNOWN; /* XXX */
d678 4
a682 1

@


1.8
log
@Bring back the code simplifications after debug and testing by drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_lcd.c,v 1.7 2005/01/05 23:04:23 miod Exp $ */
d456 1
a456 1

d483 1
a483 1
	struct rasops_info rinfo;
d485 2
a486 1
	memset(&rinfo, 0, sizeof rinfo);
d502 23
a524 7
	rinfo.ri_flg = 0;
	rinfo.ri_depth = descr->depth;
	rinfo.ri_bits = NULL;
	rinfo.ri_width = width;
	rinfo.ri_height = height;
	rinfo.ri_stride = width * rinfo.ri_depth / 8;
	rinfo.ri_wsfcookie = cookie;
d526 2
a527 1
	rasops_init(&rinfo, 100, 100);
d529 13
a541 10
	/*
	 * Since we will use a rasops structure per screen, we need to
	 * keep a copy of the emulops (which will always be the same)
	 * in the softc, so as not to require an extra indirection layer.
	 */
	sc->emulops = rinfo.ri_ops;
	descr->c.nrows = rinfo.ri_rows;
	descr->c.ncols = rinfo.ri_cols;
	descr->c.capabilities = rinfo.ri_caps;
	descr->c.textops = &sc->emulops;
d543 2
a544 1
	return cookie;
d580 1
a580 1
	
d595 9
@


1.7
log
@Let wsdisplay drivers return zero for WSDISPLAYIO_[GS]VIDEO ioctls - most
of the work is done in the upper layer, but they get to see the ioctl,
so don't always return an error.
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_lcd.c,v 1.6 2005/01/05 19:12:47 miod Exp $ */
d475 2
a476 1
pxa2x0_lcd_setup_wsscreen(struct pxa2x0_wsscreen_descr *descr,
d511 6
d520 1
d530 2
a531 1
	struct pxa2x0_lcd_screen *scr = cookie, *old;
d552 1
d562 8
a569 6
	scr->rinfo.ri_flg = 0;
	scr->rinfo.ri_depth = type->depth;
	scr->rinfo.ri_bits = scr->buf_va;
	scr->rinfo.ri_width = sc->geometry->panel_width;
	scr->rinfo.ri_height = sc->geometry->panel_height;
	scr->rinfo.ri_stride = scr->rinfo.ri_width * scr->rinfo.ri_depth / 8;
d571 1
a571 1
	scr->rinfo.ri_wsfcookie = -1;	/* XXX */
d574 1
a574 1
	rasops_init(&scr->rinfo, type->c.nrows, type->c.ncols);
d576 1
a576 1
	scr->rinfo.ri_ops.alloc_attr(&scr->rinfo, 0, 0, 0, attrp);
d578 1
a578 1
	*cookiep = scr;
d589 2
a590 1
	struct pxa2x0_lcd_screen *scr = cookie;
a669 80

static void
pxa2x0_lcd_cursor(void *cookie, int on, int row, int col)
{
	struct pxa2x0_lcd_screen *scr = cookie;

	(* scr->rinfo.ri_ops.cursor)(&scr->rinfo, on, row, col);
}

static int
pxa2x0_lcd_mapchar(void *cookie, int c, unsigned int *cp)
{
	struct pxa2x0_lcd_screen *scr = cookie;

	return (* scr->rinfo.ri_ops.mapchar)(&scr->rinfo, c, cp);
}

static void
pxa2x0_lcd_putchar(void *cookie, int row, int col, u_int uc, long attr)
{
	struct pxa2x0_lcd_screen *scr = cookie;

	(* scr->rinfo.ri_ops.putchar)(&scr->rinfo,
	    row, col, uc, attr);
}

static void
pxa2x0_lcd_copycols(void *cookie, int row, int src, int dst, int num)
{
	struct pxa2x0_lcd_screen *scr = cookie;

	(* scr->rinfo.ri_ops.copycols)(&scr->rinfo,
	    row, src, dst, num);
}

static void
pxa2x0_lcd_erasecols(void *cookie, int row, int col, int num, long attr)
{
	struct pxa2x0_lcd_screen *scr = cookie;

	(* scr->rinfo.ri_ops.erasecols)(&scr->rinfo,
	    row, col, num, attr);
}

static void
pxa2x0_lcd_copyrows(void *cookie, int src, int dst, int num)
{
	struct pxa2x0_lcd_screen *scr = cookie;

	(* scr->rinfo.ri_ops.copyrows)(&scr->rinfo,
	    src, dst, num);
}

static void
pxa2x0_lcd_eraserows(void *cookie, int row, int num, long attr)
{
	struct pxa2x0_lcd_screen *scr = cookie;

	(* scr->rinfo.ri_ops.eraserows)(&scr->rinfo,
	    row, num, attr);
}

static int
pxa2x0_lcd_alloc_attr(void *cookie, int fg, int bg, int flg, long *attr)
{
	struct pxa2x0_lcd_screen *scr = cookie;

	return scr->rinfo.ri_ops.alloc_attr(&scr->rinfo, fg, bg, flg, attr);
}

const struct wsdisplay_emulops pxa2x0_lcd_emulops = {
	pxa2x0_lcd_cursor,
	pxa2x0_lcd_mapchar,
	pxa2x0_lcd_putchar,
	pxa2x0_lcd_copycols,
	pxa2x0_lcd_erasecols,
	pxa2x0_lcd_copyrows,
	pxa2x0_lcd_eraserows,
	pxa2x0_lcd_alloc_attr
};
@


1.6
log
@Partially revert some of these changes - misunderstanding between drahn@@ and I
about which diff he had tested.
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_lcd.c,v 1.5 2005/01/05 18:11:54 miod Exp $ */
d608 1
a608 1
		return 0;
d617 1
a617 1
		return 0;
d625 2
d635 1
a635 1
	return -1;
@


1.5
log
@First steps in cleaning the Zaurus display code:
- kill the non-wscons code. Really.
- KNF, and english fixes.
- do not handle WSDISPLAYIO_[GS]VIDEO in the driver - the wsdisplay layer
  can do this, as long as we provide a burner accessop, so provide one.
- kill the emulops indirection.
- when setting the color palette in 8 or 4bpp mode, match the values used
  in the rasops color table (only affects normal white value).

test and ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_lcd.c,v 1.4 2005/01/04 03:53:46 drahn Exp $ */
d475 1
a475 2
pxa2x0_lcd_setup_wsscreen(struct pxa2x0_lcd_softc *sc,
    struct pxa2x0_wsscreen_descr *descr,
a509 6
	/*
	 * Since we will use a rasops structure per screen, we need to
	 * keep a copy of the emulops (which will always be the same)
	 * in the softc, so as not to require an extra indirection layer.
	 */
	sc->emulops = rinfo.ri_ops;
a512 1
	descr->c.textops = &sc->emulops;
d566 1
a566 1
	*cookiep = &scr->rinfo;
d655 80
@


1.4
log
@Remove debug printfs.
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_lcd.c,v 1.3 2005/01/03 04:50:22 drahn Exp $ */
a40 5
#include <sys/cdefs.h>
/*
__KERNEL_RCSID(0, "$NetBSD: pxa2x0_lcd.c,v 1.8 2003/10/03 07:24:05 bsh Exp $");
*/

a65 2
#include "wsdisplay.h"

d136 1
a136 2
	error = bus_space_map(iot, PXA2X0_LCDC_BASE,
			       PXA2X0_LCDC_SIZE, 0, &ioh);
a204 1

d215 1
a215 1
	/* Clear stickey status bits */
d237 2
a238 1
	case 16:    /* FALLTHROUGH */
a266 2

#if NWSDISPLAY > 0
a284 1
#endif
d290 1
a290 1
#define H	0x3f			/* hight intensity */
d300 1
a300 1
	_rgb(0x1c,0x38,0x1c),		/* white */
d316 1
a316 1
init_pallet(uint16_t *buf, int depth)
d337 1
a337 1
		/* pallet is not needed */
d352 1
a352 1
        int error, pallet_size;
d359 1
a359 1
	pallet_size = 0;
d366 1
a366 1
		pallet_size = (1<<depth) * sizeof (uint16_t);
d376 1
a376 2
	scr = malloc(sizeof *scr, M_DEVBUF, 
	    (cold ? M_NOWAIT : M_WAITOK));
d388 1
a388 1
	    + pallet_size;
d390 1
a390 1
        error = bus_dmamem_alloc(sc->dma_tag, size, 16, 0,
d393 4
a396 4
        if (error || scr->nsegs != 1) {
		/* XXX: Actually we can handle nsegs>1 case by means
                   of multiple DMA descriptors for a panel.  it will
                   makes code here a bit hairly */
d398 1
a398 1
        }
a404 1

d429 2
a430 2
	if (pallet_size) {
		init_pallet((uint16_t *)((char *)desc - pallet_size), depth);
d433 2
a434 2
		desc[2].fsadr = desc_pa - pallet_size;
		desc[2].ldcmd = pallet_size | LDCMD_PAL;
a469 3

#if NWSDISPLAY > 0

d475 2
a476 1
pxa2x0_lcd_setup_wsscreen(struct pxa2x0_wsscreen_descr *descr,
d487 1
a487 1
#if 0
d495 1
a495 2
	}
	else {
d511 6
d520 1
a520 1

a524 1

d555 1
a555 1
		return -1;
d566 1
d568 1
d574 1
a574 2

	*cookiep = scr;
a580 1

a611 1
	uint32_t ccr0;
a631 9
		if (*(int *)data == WSDISPLAYIO_VIDEO_ON) {
		  /* turn it on */
		}
		else {
		  /* start LCD shutdown */
		  /* sleep until interrupt */
		}
		return 0;

a632 7
		ccr0 = bus_space_read_4(sc->iot, sc->ioh, LCDC_LCCR0);
		*(u_int *)data = (ccr0 & (LCCR0_ENB|LCCR0_DIS)) == LCCR0_ENB ?
		    WSDISPLAYIO_VIDEO_ON : WSDISPLAYIO_VIDEO_OFF;
		return 0;
		


d638 1
a638 1
		return -1;	/* XXX */
d650 3
d654 1
a654 15
		return -1;

	return bus_dmamem_mmap(sc->dma_tag, screen->segs, screen->nsegs,
	    offset, prot, BUS_DMA_WAITOK|BUS_DMA_COHERENT);
	return -1;
}


static void
pxa2x0_lcd_cursor(void *cookie, int on, int row, int col)
{
	struct pxa2x0_lcd_screen *scr = cookie;

	(* scr->rinfo.ri_ops.cursor)(&scr->rinfo, on, row, col);
}
d656 3
a658 4
static int
pxa2x0_lcd_mapchar(void *cookie, int c, unsigned int *cp)
{
	struct pxa2x0_lcd_screen *scr = cookie;
d660 2
a661 1
	return (* scr->rinfo.ri_ops.mapchar)(&scr->rinfo, c, cp);
a662 67

static void
pxa2x0_lcd_putchar(void *cookie, int row, int col, u_int uc, long attr)
{
	struct pxa2x0_lcd_screen *scr = cookie;

	(* scr->rinfo.ri_ops.putchar)(&scr->rinfo,
	    row, col, uc, attr);
}

static void
pxa2x0_lcd_copycols(void *cookie, int row, int src, int dst, int num)
{
	struct pxa2x0_lcd_screen *scr = cookie;

	(* scr->rinfo.ri_ops.copycols)(&scr->rinfo,
	    row, src, dst, num);
}

static void
pxa2x0_lcd_erasecols(void *cookie, int row, int col, int num, long attr)
{
	struct pxa2x0_lcd_screen *scr = cookie;

	(* scr->rinfo.ri_ops.erasecols)(&scr->rinfo,
	    row, col, num, attr);
}

static void
pxa2x0_lcd_copyrows(void *cookie, int src, int dst, int num)
{
	struct pxa2x0_lcd_screen *scr = cookie;

	(* scr->rinfo.ri_ops.copyrows)(&scr->rinfo,
	    src, dst, num);
}

static void
pxa2x0_lcd_eraserows(void *cookie, int row, int num, long attr)
{
	struct pxa2x0_lcd_screen *scr = cookie;

	(* scr->rinfo.ri_ops.eraserows)(&scr->rinfo,
	    row, num, attr);
}

static int
pxa2x0_lcd_alloc_attr(void *cookie, int fg, int bg, int flg, long *attr)
{
	struct pxa2x0_lcd_screen *scr = cookie;

	return scr->rinfo.ri_ops.alloc_attr(&scr->rinfo, fg, bg, flg, attr);
}


const struct wsdisplay_emulops pxa2x0_lcd_emulops = {
	pxa2x0_lcd_cursor,
	pxa2x0_lcd_mapchar,
	pxa2x0_lcd_putchar,
	pxa2x0_lcd_copycols,
	pxa2x0_lcd_erasecols,
	pxa2x0_lcd_copyrows,
	pxa2x0_lcd_eraserows,
	pxa2x0_lcd_alloc_attr
};

#endif /* NWSDISPLAY > 0 */
@


1.3
log
@Close to working display, just rotated 90 degrees.
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa2x0_lcd.c,v 1.2 2005/01/02 19:52:36 drahn Exp $ */
a160 12
	{
		printf("\nbefore\n");
		u_int32_t tmp;
		tmp = bus_space_read_4(iot, ioh, LCDC_LCCR0);
		printf("LCCR0 %08x\n", tmp);
		tmp = bus_space_read_4(iot, ioh, LCDC_LCCR1);
		printf("LCCR1 %08x\n", tmp);
		tmp = bus_space_read_4(iot, ioh, LCDC_LCCR2);
		printf("LCCR2 %08x\n", tmp);
		tmp = bus_space_read_4(iot, ioh, LCDC_LCCR3);
		printf("LCCR3 %08x\n", tmp);
	}
a210 12
	{
		printf("\nafter\n");
		u_int32_t tmp;
		tmp = bus_space_read_4(iot, ioh, LCDC_LCCR0);
		printf("LCCR0 %08x\n", tmp);
		tmp = bus_space_read_4(iot, ioh, LCDC_LCCR1);
		printf("LCCR1 %08x\n", tmp);
		tmp = bus_space_read_4(iot, ioh, LCDC_LCCR2);
		printf("LCCR2 %08x\n", tmp);
		tmp = bus_space_read_4(iot, ioh, LCDC_LCCR3);
		printf("LCCR3 %08x\n", tmp);
	}
@


1.2
log
@OpenBSD tags
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d94 6
d137 1
d154 2
a155 1
	sc->ih = pxa2x0_intr_establish(17, IPL_BIO, lcdintr, sc);
d161 28
d223 12
@


1.1
log
@xscale bits, taken from NetBSD with modifications as appropriate for OpenBSD.
@
text
@d1 1
@

