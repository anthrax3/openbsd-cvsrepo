head	1.12;
access;
symbols
	OPENBSD_6_1:1.12.0.2
	OPENBSD_6_1_BASE:1.12
	OPENBSD_6_0:1.7.0.2
	OPENBSD_6_0_BASE:1.7;
locks; strict;
comment	@ * @;


1.12
date	2017.01.23.06.13.34;	author kettenis;	state Exp;
branches;
next	1.11;
commitid	J4f1bwarWfUVpRLB;

1.11
date	2016.10.21.20.09.49;	author patrick;	state Exp;
branches;
next	1.10;
commitid	8qZ3HSsDuqTYbfJh;

1.10
date	2016.10.05.07.44.24;	author patrick;	state Exp;
branches;
next	1.9;
commitid	rIdfUeWIVU4K3W95;

1.9
date	2016.09.18.17.50.26;	author kettenis;	state Exp;
branches;
next	1.8;
commitid	XjdKlUGzIxJpPpq7;

1.8
date	2016.07.27.11.45.02;	author patrick;	state Exp;
branches;
next	1.7;
commitid	yc14meyJgxIAcvAg;

1.7
date	2016.07.18.11.53.32;	author patrick;	state Exp;
branches;
next	1.6;
commitid	nXR3LHsNZuLoIA4t;

1.6
date	2016.07.13.20.42.44;	author patrick;	state Exp;
branches;
next	1.5;
commitid	nKlQOlxpchcfALtZ;

1.5
date	2016.06.12.13.10.06;	author kettenis;	state Exp;
branches;
next	1.4;
commitid	oHjOxHSCAqz5FscP;

1.4
date	2016.06.09.12.32.42;	author kettenis;	state Exp;
branches;
next	1.3;
commitid	XdEaFDh9p2eyWIY0;

1.3
date	2016.05.23.13.57.04;	author kettenis;	state Exp;
branches;
next	1.2;
commitid	zL4dJtIxU1UHXbLa;

1.2
date	2016.05.16.21.26.54;	author kettenis;	state Exp;
branches;
next	1.1;
commitid	bH5C7JL7WhBQiugV;

1.1
date	2016.05.02.08.15.55;	author patrick;	state Exp;
branches;
next	;
commitid	SxPSz6lxaCE62Tnc;


desc
@@


1.12
log
@No need to explicitly use config_activate_children in the cfattach struct.
@
text
@/* $OpenBSD: simplebus.c,v 1.11 2016/10/21 20:09:49 patrick Exp $ */
/*
 * Copyright (c) 2016 Patrick Wildt <patrick@@blueri.se>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/malloc.h>

#include <dev/ofw/openfirm.h>
#include <dev/ofw/fdt.h>

#include <arm/fdt.h>
#include <arm/simplebus/simplebusvar.h>

int simplebus_match(struct device *, void *, void *);
void simplebus_attach(struct device *, struct device *, void *);

void simplebus_attach_node(struct device *, int);
int simplebus_bs_map(void *, uint64_t, bus_size_t, int, bus_space_handle_t *);

struct cfattach simplebus_ca = {
	sizeof(struct simplebus_softc), simplebus_match, simplebus_attach
};

struct cfdriver simplebus_cd = {
	NULL, "simplebus", DV_DULL
};

/*
 * Simplebus is a generic bus with no special casings.
 */
int
simplebus_match(struct device *parent, void *cfdata, void *aux)
{
	struct fdt_attach_args *fa = (struct fdt_attach_args *)aux;

	if (fa->fa_node == 0)
		return (0);

	if (!OF_is_compatible(fa->fa_node, "simple-bus"))
		return (0);

	return (1);
}

void
simplebus_attach(struct device *parent, struct device *self, void *aux)
{
	struct simplebus_softc *sc = (struct simplebus_softc *)self;
	struct fdt_attach_args *fa = (struct fdt_attach_args *)aux;
	char name[32];
	int node;

	sc->sc_node = fa->fa_node;
	sc->sc_iot = fa->fa_iot;
	sc->sc_dmat = fa->fa_dmat;
	sc->sc_acells = OF_getpropint(sc->sc_node, "#address-cells",
	    fa->fa_acells);
	sc->sc_scells = OF_getpropint(sc->sc_node, "#size-cells",
	    fa->fa_scells);
	sc->sc_pacells = fa->fa_acells;
	sc->sc_pscells = fa->fa_scells;

	if (OF_getprop(sc->sc_node, "name", name, sizeof(name)) > 0) {
		name[sizeof(name) - 1] = 0;
		printf(": \"%s\"", name);
	}

	printf("\n");

	memcpy(&sc->sc_bus, sc->sc_iot, sizeof(sc->sc_bus));
	sc->sc_bus.bs_cookie = sc;
	sc->sc_bus.bs_map = simplebus_bs_map;

	sc->sc_rangeslen = OF_getproplen(sc->sc_node, "ranges");
	if (sc->sc_rangeslen > 0 && !(sc->sc_rangeslen % sizeof(uint32_t))) {
		sc->sc_ranges = malloc(sc->sc_rangeslen, M_TEMP, M_WAITOK);
		OF_getpropintarray(sc->sc_node, "ranges", sc->sc_ranges,
		    sc->sc_rangeslen);
	}

	/* Scan the whole tree. */
	sc->sc_early = 1;
	for (node = OF_child(sc->sc_node); node; node = OF_peer(node)) 
		simplebus_attach_node(self, node);

	sc->sc_early = 0;
	for (node = OF_child(sc->sc_node); node; node = OF_peer(node)) 
		simplebus_attach_node(self, node);
}

int
simplebus_submatch(struct device *self, void *match, void *aux)
{
	struct simplebus_softc	*sc = (struct simplebus_softc *)self;
	struct cfdata *cf = match;

	if (cf->cf_loc[0] == sc->sc_early)
		return (*cf->cf_attach->ca_match)(self, match, aux);
	return 0;
}

/*
 * Look for a driver that wants to be attached to this node.
 */
void
simplebus_attach_node(struct device *self, int node)
{
	struct simplebus_softc	*sc = (struct simplebus_softc *)self;
	struct fdt_attach_args	 fa;
	char			 buffer[128];
	int			 i, len, line;
	uint32_t		*cell, *reg;

	if (!OF_getprop(node, "compatible", buffer, sizeof(buffer)))
		return;

	if (OF_getprop(node, "status", buffer, sizeof(buffer)))
		if (!strcmp(buffer, "disabled"))
			return;

	memset(&fa, 0, sizeof(fa));
	fa.fa_name = "";
	fa.fa_node = node;
	fa.fa_iot = &sc->sc_bus;
	fa.fa_dmat = sc->sc_dmat;
	fa.fa_acells = sc->sc_acells;
	fa.fa_scells = sc->sc_scells;

	len = OF_getproplen(node, "reg");
	line = (sc->sc_acells + sc->sc_scells) * sizeof(uint32_t);
	if (len > 0 && line > 0 && (len % line) == 0) {
		reg = malloc(len, M_TEMP, M_WAITOK);
		OF_getpropintarray(node, "reg", reg, len);

		fa.fa_reg = malloc((len / line) * sizeof(struct fdt_reg),
		    M_DEVBUF, M_WAITOK | M_ZERO);
		fa.fa_nreg = (len / line);

		for (i = 0, cell = reg; i < len / line; i++) {
			if (sc->sc_acells >= 1)
				fa.fa_reg[i].addr = cell[0];
			if (sc->sc_acells == 2) {
				fa.fa_reg[i].addr <<= 32;
				fa.fa_reg[i].addr |= cell[1];
			}
			cell += sc->sc_acells;
			if (sc->sc_scells >= 1)
				fa.fa_reg[i].size = cell[0];
			if (sc->sc_scells == 2) {
				fa.fa_reg[i].size <<= 32;
				fa.fa_reg[i].size |= cell[1];
			}
			cell += sc->sc_scells;
		}

		free(reg, M_TEMP, len);
	}

	len = OF_getproplen(node, "interrupts");
	if (len > 0 && (len % sizeof(uint32_t)) == 0) {
		fa.fa_intr = malloc(len, M_DEVBUF, M_WAITOK);
		fa.fa_nintr = len / sizeof(uint32_t);

		OF_getpropintarray(node, "interrupts", fa.fa_intr, len);
	}

	config_found_sm(self, &fa, NULL, simplebus_submatch);

	free(fa.fa_reg, M_DEVBUF, fa.fa_nreg * sizeof(struct fdt_reg));
	free(fa.fa_intr, M_DEVBUF, fa.fa_nintr * sizeof(uint32_t));
}

/*
 * Translate memory address if needed.
 */
int
simplebus_bs_map(void *t, uint64_t bpa, bus_size_t size,
    int flag, bus_space_handle_t *bshp)
{
	struct simplebus_softc *sc = (struct simplebus_softc *)t;
	uint64_t addr, rfrom, rto, rsize;
	uint32_t *range;
	int parent, rlen, rone;

	addr = bpa;
	parent = OF_parent(sc->sc_node);
	if (parent == 0)
		return bus_space_map(sc->sc_iot, addr, size, flag, bshp);

	if (sc->sc_rangeslen < 0)
		return EINVAL;
	if (sc->sc_rangeslen == 0)
		return bus_space_map(sc->sc_iot, addr, size, flag, bshp);

	rlen = sc->sc_rangeslen / sizeof(uint32_t);
	rone = sc->sc_pacells + sc->sc_acells + sc->sc_scells;

	/* For each range. */
	for (range = sc->sc_ranges; rlen >= rone; rlen -= rone, range += rone) {
		/* Extract from and size, so we can see if we fit. */
		rfrom = range[0];
		if (sc->sc_acells == 2)
			rfrom = (rfrom << 32) + range[1];
		rsize = range[sc->sc_acells + sc->sc_pacells];
		if (sc->sc_scells == 2)
			rsize = (rsize << 32) +
			    range[sc->sc_acells + sc->sc_pacells + 1];

		/* Try next, if we're not in the range. */
		if (addr < rfrom || (addr + size) > (rfrom + rsize))
			continue;

		/* All good, extract to address and translate. */
		rto = range[sc->sc_acells];
		if (sc->sc_pacells == 2)
			rto = (rto << 32) + range[sc->sc_acells + 1];

		addr -= rfrom;
		addr += rto;

		return bus_space_map(sc->sc_iot, addr, size, flag, bshp);
	}

	return ESRCH;
}
@


1.11
log
@Outsource simplebus softc definition so that it can be used by
simplebus compatible bus drivers.

ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: simplebus.c,v 1.10 2016/10/05 07:44:24 patrick Exp $ */
d37 1
a37 2
	sizeof(struct simplebus_softc), simplebus_match, simplebus_attach, NULL,
	config_activate_children
@


1.10
log
@Some device trees use 64-bit intermediate virtual addresses.  This
means that even though the hardware in the end never leaves the 32-bit
address space, some addresses used solely in the device tree can be
bigger than 32-bit.  As bus_space_map(9) takes addresses of size
bus_addr_t, which is 32-bit on ARMv7, we cannot pass those virtual
addresses to the parent bus, even though it will be mapped back into a
32-bit address in the end.  To work around this, make bus_space_map(9)
take a 64-bit address.  Since this is implemented as a macro and
function pointer we can safely do that without harming any other
architecture.

ok kettenis@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: simplebus.c,v 1.9 2016/09/18 17:50:26 kettenis Exp $ */
d28 1
a34 15

struct simplebus_softc {
	struct device		 sc_dev;
	int			 sc_node;
	bus_space_tag_t		 sc_iot;
	bus_dma_tag_t		 sc_dmat;
	int			 sc_acells;
	int			 sc_scells;
	int			 sc_pacells;
	int			 sc_pscells;
	struct bus_space	 sc_bus;
	int			*sc_ranges;
	int			 sc_rangeslen;
	int			 sc_early;
};
@


1.9
log
@Use a locator (named "early") to let designated drivers attach before others.

ok patrick@@, jsg@@
@
text
@d1 1
a1 1
/* $OpenBSD: simplebus.c,v 1.8 2016/07/27 11:45:02 patrick Exp $ */
d33 1
a33 1
int simplebus_bs_map(void *, bus_addr_t, bus_size_t, int, bus_space_handle_t *);
d208 1
a208 1
simplebus_bs_map(void *t, bus_addr_t bpa, bus_size_t size,
@


1.8
log
@Instead of passing the raw reg property to simplebus nodes,
pass a pre-processed array of fdt_reg structs.  This means
that the drivers don't have to understand the cell properties
themselves but can rely on the 64-bit addr/size pairs.

ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: simplebus.c,v 1.7 2016/07/18 11:53:32 patrick Exp $ */
d47 1
d113 2
a114 4
	for (node = OF_child(sc->sc_node);
	    node != 0;
	    node = OF_peer(node))
	{
d116 15
a130 1
	}
d198 1
a198 3
	/* TODO: attach the device's clocks first? */

	config_found(self, &fa, NULL);
@


1.7
log
@Some SoCs have a ranges property set in their device trees.  This can
be used to translate one memory address to another.  Currently we just
pass the child's memory address to bus space map.  If one of the parent
busses implements a ranges property, the child's address property is
not the real address.  This change hooks up a bus space map function
that is aware of the ranges property and translates the addresses if
needed.

ok kettenis@@
looks fine jsg@@
@
text
@d1 1
a1 1
/* $OpenBSD: simplebus.c,v 1.6 2016/07/13 20:42:44 patrick Exp $ */
d25 1
d129 2
a130 1
	int			 len;
d148 25
a172 3
	if (len > 0 && (len % sizeof(uint32_t)) == 0) {
		fa.fa_reg = malloc(len, M_DEVBUF, M_WAITOK);
		fa.fa_nreg = len / sizeof(uint32_t);
d174 1
a174 1
		OF_getpropintarray(node, "reg", fa.fa_reg, len);
d189 1
a189 1
	free(fa.fa_reg, M_DEVBUF, fa.fa_nreg * sizeof(uint32_t));
@


1.6
log
@The "#address-cells" and "#size-cells" properties define the size
of the memory address and length information.  The root node passes
this information down to the children and it can be overwritten by
other nodes inbetween.  Pass these properties as part of the fdt
attach args, so that we can grab that information quickly inside
the drivers.

ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: simplebus.c,v 1.5 2016/06/12 13:10:06 kettenis Exp $ */
d32 1
d41 5
d89 2
d99 11
d140 1
a140 1
	fa.fa_iot = sc->sc_iot;
d167 54
@


1.5
log
@Use OF_getpropintarray().
@
text
@d1 1
a1 1
/* $OpenBSD: simplebus.c,v 1.4 2016/06/09 12:32:42 kettenis Exp $ */
d38 2
d79 4
d123 2
@


1.4
log
@Fetch "reg" and "interrupts" properties and pass them down as attach args to
our children.

ok jsg@@
@
text
@d1 1
a1 1
/* $OpenBSD: simplebus.c,v 1.3 2016/05/23 13:57:04 kettenis Exp $ */
d103 1
a103 1
	int			 len, i;
d123 1
a123 3
		OF_getprop(node, "reg", fa.fa_reg, len);
		for (i = 0; i < fa.fa_nreg; i++)
			fa.fa_reg[i] = bemtoh32(&fa.fa_reg[i]);
d131 1
a131 3
		OF_getprop(node, "interrupts", fa.fa_intr, len);
		for (i = 0; i < fa.fa_nintr; i++)
			fa.fa_intr[i] = bemtoh32(&fa.fa_intr[i]);
@


1.3
log
@Print the name from the corresponding FDT node to make identifying simplebus(4)
instances easier.

ok jsg@@, patrick@@
@
text
@d1 1
a1 1
/* $OpenBSD: simplebus.c,v 1.2 2016/05/16 21:26:54 kettenis Exp $ */
d22 1
d103 1
d118 20
d141 3
@


1.2
log
@Use OF_is_compatible(9) here.

ok patrick@@
@
text
@d1 1
a1 1
/* $OpenBSD: simplebus.c,v 1.1 2016/05/02 08:15:55 patrick Exp $ */
d70 1
d76 5
@


1.1
log
@Rework mainbus and implement simplebus to be able to span a tree-like
topology based on device tree information.  Introduce a common attach
args structure to be used for all fdt-capable bus devices.

ok jsg@@ kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a54 1
	char buffer[128];
d59 1
a59 5
	if (!OF_getprop(fa->fa_node, "compatible", buffer,
	    sizeof(buffer)))
		return (0);

	if (strcmp(buffer, "simple-bus"))
@

