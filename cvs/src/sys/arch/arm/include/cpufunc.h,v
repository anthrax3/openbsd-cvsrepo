head	1.29;
access;
symbols
	OPENBSD_6_2_BASE:1.29
	OPENBSD_6_1:1.29.0.4
	OPENBSD_6_1_BASE:1.29
	OPENBSD_6_0:1.25.0.2
	OPENBSD_6_0_BASE:1.25
	OPENBSD_5_9:1.16.0.2
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.15.0.8
	OPENBSD_5_8_BASE:1.15
	OPENBSD_5_7:1.15.0.2
	OPENBSD_5_7_BASE:1.15
	OPENBSD_5_6:1.15.0.4
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.14.0.6
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.14.0.2
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.10.0.2
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.9.0.4
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.2
	OPENBSD_5_0:1.8.0.2
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.7.0.4
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.2
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.6.0.2
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.4
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.5.0.2
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.4.0.4
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.2
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.3.0.6
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.4
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.3.0.2
	OPENBSD_4_0_BASE:1.3
	OPENBSD_3_9:1.2.0.8
	OPENBSD_3_9_BASE:1.2
	OPENBSD_3_8:1.2.0.6
	OPENBSD_3_8_BASE:1.2
	OPENBSD_3_7:1.2.0.4
	OPENBSD_3_7_BASE:1.2
	OPENBSD_3_6:1.2.0.2
	OPENBSD_3_6_BASE:1.2
	SMP_SYNC_A:1.2
	SMP_SYNC_B:1.2
	OPENBSD_3_5:1.1.0.4
	OPENBSD_3_5_BASE:1.1
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.29
date	2017.01.06.00.06.02;	author jsg;	state Exp;
branches;
next	1.28;
commitid	YCbIRye8xzoWl68V;

1.28
date	2017.01.04.00.40.49;	author jsg;	state Exp;
branches;
next	1.27;
commitid	wyJlaIFS0yAv07lJ;

1.27
date	2016.08.22.01.42.00;	author jsg;	state Exp;
branches;
next	1.26;
commitid	UOfhQ4F8JDkBUCg3;

1.26
date	2016.08.14.11.30.54;	author jsg;	state Exp;
branches;
next	1.25;
commitid	3XHAPSr5dKOYN1hw;

1.25
date	2016.04.03.13.55.23;	author jsg;	state Exp;
branches;
next	1.24;
commitid	Zptl63HVhfEY4Ajo;

1.24
date	2016.03.22.23.35.01;	author patrick;	state Exp;
branches;
next	1.23;
commitid	RkEnvixfXW2bEpue;

1.23
date	2016.03.22.23.28.02;	author patrick;	state Exp;
branches;
next	1.22;
commitid	bAxWaXK3mkjM56Iw;

1.22
date	2016.03.22.11.18.17;	author patrick;	state Exp;
branches;
next	1.21;
commitid	YjNMWFHczdMD8Xoi;

1.21
date	2016.03.19.09.51.24;	author patrick;	state Exp;
branches;
next	1.20;
commitid	E8GUcpv6nbDyd4Ml;

1.20
date	2016.03.19.09.47.54;	author patrick;	state Exp;
branches;
next	1.19;
commitid	WySdpoZsQMX20beB;

1.19
date	2016.03.19.09.36.57;	author patrick;	state Exp;
branches;
next	1.18;
commitid	PJBEdVboqiwjXPXy;

1.18
date	2016.03.18.13.16.02;	author jsg;	state Exp;
branches;
next	1.17;
commitid	RKG2cJTBtpcdjKgj;

1.17
date	2016.03.18.06.54.21;	author jsg;	state Exp;
branches;
next	1.16;
commitid	82aYg3LAWI4D5T1j;

1.16
date	2016.01.31.00.14.50;	author jsg;	state Exp;
branches;
next	1.15;
commitid	pbLjedMudUFrVMk6;

1.15
date	2014.03.29.18.09.28;	author guenther;	state Exp;
branches;
next	1.14;

1.14
date	2013.03.30.01.30.30;	author patrick;	state Exp;
branches;
next	1.13;

1.13
date	2013.03.30.00.57.47;	author patrick;	state Exp;
branches;
next	1.12;

1.12
date	2013.03.27.00.06.09;	author patrick;	state Exp;
branches;
next	1.11;

1.11
date	2013.03.22.21.24.11;	author patrick;	state Exp;
branches;
next	1.10;

1.10
date	2013.01.23.19.57.47;	author patrick;	state Exp;
branches;
next	1.9;

1.9
date	2011.09.20.22.02.13;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2011.03.23.16.54.34;	author pirofti;	state Exp;
branches;
next	1.7;

1.7
date	2010.04.22.21.01.45;	author drahn;	state Exp;
branches;
next	1.6;

1.6
date	2009.05.08.02.57.32;	author drahn;	state Exp;
branches;
next	1.5;

1.5
date	2008.09.11.02.38.14;	author kevlo;	state Exp;
branches;
next	1.4;

1.4
date	2007.09.22.19.57.45;	author kettenis;	state Exp;
branches;
next	1.3;

1.3
date	2006.07.12.17.29.55;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2004.05.19.03.17.07;	author drahn;	state Exp;
branches;
next	1.1;

1.1
date	2004.02.01.05.09.49;	author drahn;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2004.02.19.10.48.02;	author niklas;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2004.06.05.23.10.45;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.29
log
@unifdef CPU_ARMv7 and ARM_ARCH_7
ok kettenis@@ patrick@@
@
text
@/*	$OpenBSD: cpufunc.h,v 1.28 2017/01/04 00:40:49 jsg Exp $	*/
/*	$NetBSD: cpufunc.h,v 1.29 2003/09/06 09:08:35 rearnsha Exp $	*/

/*
 * Copyright (c) 1997 Mark Brinicombe.
 * Copyright (c) 1997 Causality Limited
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Causality Limited.
 * 4. The name of Causality Limited may not be used to endorse or promote
 *    products derived from this software without specific prior written
 *    permission.
 *
 * THIS SOFTWARE IS PROVIDED BY CAUSALITY LIMITED ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL CAUSALITY LIMITED BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * RiscBSD kernel project
 *
 * cpufunc.h
 *
 * Prototypes for cpu, mmu and tlb related functions.
 */

#ifndef _ARM_CPUFUNC_H_
#define _ARM_CPUFUNC_H_

#ifdef _KERNEL

#include <sys/types.h>
#include <arm/cpuconf.h>

struct cpu_functions {

	/* CPU functions */
	
	u_int	(*cf_id)		(void);
	void	(*cf_cpwait)		(void);

	/* MMU functions */

	u_int	(*cf_control)		(u_int clear, u_int set);
	u_int	(*cf_auxcontrol)	(u_int clear, u_int set);
	void	(*cf_domains)		(u_int domains);
	void	(*cf_setttb)		(u_int ttb);
	u_int	(*cf_dfsr)		(void);
	u_int	(*cf_dfar)		(void);
	u_int	(*cf_ifsr)		(void);
	u_int	(*cf_ifar)		(void);

	/* TLB functions */

	void	(*cf_tlb_flushID)	(void);	
	void	(*cf_tlb_flushID_SE)	(u_int va);	
	void	(*cf_tlb_flushI)	(void);
	void	(*cf_tlb_flushI_SE)	(u_int va);	
	void	(*cf_tlb_flushD)	(void);
	void	(*cf_tlb_flushD_SE)	(u_int va);	

	/*
	 * Cache operations:
	 *
	 * We define the following primitives:
	 *
	 *	icache_sync_all		Synchronize I-cache
	 *	icache_sync_range	Synchronize I-cache range
	 *
	 *	dcache_wbinv_all	Write-back and Invalidate D-cache
	 *	dcache_wbinv_range	Write-back and Invalidate D-cache range
	 *	dcache_inv_range	Invalidate D-cache range
	 *	dcache_wb_range		Write-back D-cache range
	 *
	 *	idcache_wbinv_all	Write-back and Invalidate D-cache,
	 *				Invalidate I-cache
	 *	idcache_wbinv_range	Write-back and Invalidate D-cache,
	 *				Invalidate I-cache range
	 *
	 * Note that the ARM term for "write-back" is "clean".  We use
	 * the term "write-back" since it's a more common way to describe
	 * the operation.
	 *
	 * There are some rules that must be followed:
	 *
	 *	I-cache Synch (all or range):
	 *		The goal is to synchronize the instruction stream,
	 *		so you may beed to write-back dirty D-cache blocks
	 *		first.  If a range is requested, and you can't
	 *		synchronize just a range, you have to hit the whole
	 *		thing.
	 *
	 *	D-cache Write-Back and Invalidate range:
	 *		If you can't WB-Inv a range, you must WB-Inv the
	 *		entire D-cache.
	 *
	 *	D-cache Invalidate:
	 *		If you can't Inv the D-cache, you must Write-Back
	 *		and Invalidate.  Code that uses this operation
	 *		MUST NOT assume that the D-cache will not be written
	 *		back to memory.
	 *
	 *	D-cache Write-Back:
	 *		If you can't Write-back without doing an Inv,
	 *		that's fine.  Then treat this as a WB-Inv.
	 *		Skipping the invalidate is merely an optimization.
	 *
	 *	All operations:
	 *		Valid virtual addresses must be passed to each
	 *		cache operation.
	 */
	void	(*cf_icache_sync_all)	(void);
	void	(*cf_icache_sync_range)	(vaddr_t, vsize_t);

	void	(*cf_dcache_wbinv_all)	(void);
	void	(*cf_dcache_wbinv_range) (vaddr_t, vsize_t);
	void	(*cf_dcache_inv_range)	(vaddr_t, vsize_t);
	void	(*cf_dcache_wb_range)	(vaddr_t, vsize_t);

	void	(*cf_idcache_wbinv_all)	(void);
	void	(*cf_idcache_wbinv_range) (vaddr_t, vsize_t);

	void	(*cf_sdcache_wbinv_all)	(void);
	void	(*cf_sdcache_wbinv_range) (vaddr_t, paddr_t, vsize_t);
	void	(*cf_sdcache_inv_range)	(vaddr_t, paddr_t, vsize_t);
	void	(*cf_sdcache_wb_range)	(vaddr_t, paddr_t, vsize_t);
	void	(*cf_sdcache_drain_writebuf) (void);

	/* Other functions */

	void	(*cf_flush_prefetchbuf)	(void);
	void	(*cf_drain_writebuf)	(void);

	void	(*cf_sleep)		(int mode);

	/* Soft functions */
	void	(*cf_context_switch)	(u_int);
	void	(*cf_setup)		(void);
};

extern struct cpu_functions cpufuncs;
extern u_int cputype;

#define cpu_id()		cpufuncs.cf_id()
#define	cpu_cpwait()		cpufuncs.cf_cpwait()

#define cpu_control(c, s)	cpufuncs.cf_control(c, s)
#define cpu_auxcontrol(c, s)	cpufuncs.cf_auxcontrol(c, s)
#define cpu_domains(d)		cpufuncs.cf_domains(d)
#define cpu_setttb(t)		cpufuncs.cf_setttb(t)
#define cpu_dfsr()		cpufuncs.cf_dfsr()
#define cpu_dfar()		cpufuncs.cf_dfar()
#define cpu_ifsr()		cpufuncs.cf_ifsr()
#define cpu_ifar()		cpufuncs.cf_ifar()

#define	cpu_tlb_flushID()	cpufuncs.cf_tlb_flushID()
#define	cpu_tlb_flushID_SE(e)	cpufuncs.cf_tlb_flushID_SE(e)
#define	cpu_tlb_flushI()	cpufuncs.cf_tlb_flushI()
#define	cpu_tlb_flushI_SE(e)	cpufuncs.cf_tlb_flushI_SE(e)
#define	cpu_tlb_flushD()	cpufuncs.cf_tlb_flushD()
#define	cpu_tlb_flushD_SE(e)	cpufuncs.cf_tlb_flushD_SE(e)

#define	cpu_icache_sync_all()	cpufuncs.cf_icache_sync_all()
#define	cpu_icache_sync_range(a, s) cpufuncs.cf_icache_sync_range((a), (s))

#define	cpu_dcache_wbinv_all()	cpufuncs.cf_dcache_wbinv_all()
#define	cpu_dcache_wbinv_range(a, s) cpufuncs.cf_dcache_wbinv_range((a), (s))
#define	cpu_dcache_inv_range(a, s) cpufuncs.cf_dcache_inv_range((a), (s))
#define	cpu_dcache_wb_range(a, s) cpufuncs.cf_dcache_wb_range((a), (s))

#define	cpu_idcache_wbinv_all()	cpufuncs.cf_idcache_wbinv_all()
#define	cpu_idcache_wbinv_range(a, s) cpufuncs.cf_idcache_wbinv_range((a), (s))

#define	cpu_sdcache_enabled()	(cpufuncs.cf_sdcache_wbinv_all != cpufunc_nullop)
#define	cpu_sdcache_wbinv_all()	cpufuncs.cf_sdcache_wbinv_all()
#define	cpu_sdcache_wbinv_range(va, pa, s) cpufuncs.cf_sdcache_wbinv_range((va), (pa), (s))
#define	cpu_sdcache_inv_range(va, pa, s) cpufuncs.cf_sdcache_inv_range((va), (pa), (s))
#define	cpu_sdcache_wb_range(va, pa, s) cpufuncs.cf_sdcache_wb_range((va), (pa), (s))
#define	cpu_sdcache_drain_writebuf() cpufuncs.cf_sdcache_drain_writebuf()

#define	cpu_flush_prefetchbuf()	cpufuncs.cf_flush_prefetchbuf()
#define	cpu_drain_writebuf()	cpufuncs.cf_drain_writebuf()

#define cpu_sleep(m)		cpufuncs.cf_sleep(m)

#define cpu_context_switch(a)		cpufuncs.cf_context_switch(a)
#define cpu_setup(a)			cpufuncs.cf_setup(a)

int	set_cpufuncs		(void);
#define ARCHITECTURE_NOT_PRESENT	1	/* known but not configured */
#define ARCHITECTURE_NOT_SUPPORTED	2	/* not known */

void	cpufunc_nullop		(void);
int	early_abort_fixup	(void *);
int	late_abort_fixup	(void *);
u_int	cpufunc_id		(void);
u_int	cpufunc_control		(u_int clear, u_int set);
u_int	cpufunc_auxcontrol	(u_int clear, u_int set);
void	cpufunc_domains		(u_int domains);
u_int	cpufunc_dfsr		(void);
u_int	cpufunc_dfar		(void);
u_int	cpufunc_ifsr		(void);
u_int	cpufunc_ifar		(void);

void	armv7_setttb		(u_int);

void	armv7_tlb_flushID_SE	(u_int);
void	armv7_tlb_flushI_SE	(u_int);

void	armv7_context_switch	(u_int);

void	armv7_setup		(void);
void	armv7_tlb_flushID	(void);
void	armv7_tlb_flushI	(void);
void	armv7_tlb_flushD	(void);
void	armv7_tlb_flushD_SE	(u_int va);

void	armv7_drain_writebuf	(void);
void	armv7_cpu_sleep		(int mode);

u_int	armv7_periphbase	(void);

void	armv7_icache_sync_all		(void);
void	armv7_icache_sync_range		(vaddr_t, vsize_t);

void	armv7_dcache_wbinv_all		(void);
void	armv7_dcache_wbinv_range	(vaddr_t, vsize_t);
void	armv7_dcache_inv_range		(vaddr_t, vsize_t);
void	armv7_dcache_wb_range		(vaddr_t, vsize_t);

void	armv7_idcache_wbinv_all		(void);
void	armv7_idcache_wbinv_range	(vaddr_t, vsize_t);

extern unsigned armv7_dcache_sets_max;
extern unsigned armv7_dcache_sets_inc;
extern unsigned armv7_dcache_index_max;
extern unsigned armv7_dcache_index_inc;

#define tlb_flush	cpu_tlb_flushID
#define setttb		cpu_setttb
#define drain_writebuf	cpu_drain_writebuf

/*
 * Macros for manipulating CPU interrupts
 */
/* Functions to manipulate the CPSR. */
static __inline u_int32_t __set_cpsr_c(u_int bic, u_int eor);
static __inline u_int32_t __get_cpsr(void);

static __inline u_int32_t
__set_cpsr_c(u_int bic, u_int eor)
{
	u_int32_t	tmp, ret;

	__asm volatile(
		"mrs	%0, cpsr\n\t"	/* Get the CPSR */
		"bic	%1, %0, %2\n\t"	/* Clear bits */
		"eor	%1, %1, %3\n\t"	/* XOR bits */
		"msr	cpsr_c, %1"	/* Set CPSR control field */
	: "=&r" (ret), "=&r" (tmp)
	: "r" (bic), "r" (eor));

	return ret;
}

static __inline u_int32_t
__get_cpsr()
{
	u_int32_t	ret;

	__asm volatile("mrs	%0, cpsr" : "=&r" (ret));

	return ret;
}

#define disable_interrupts(mask)					\
	(__set_cpsr_c((mask) & (PSR_I | PSR_F), \
		      (mask) & (PSR_I | PSR_F)))

#define enable_interrupts(mask)						\
	(__set_cpsr_c((mask) & (PSR_I | PSR_F), 0))

#define restore_interrupts(old_cpsr)					\
	(__set_cpsr_c((PSR_I | PSR_F), (old_cpsr) & (PSR_I | PSR_F)))

/*
 * Functions to manipulate cpu r13
 * (in arm/arm/setstack.S)
 */

void set_stackptr	(u_int mode, u_int address);
u_int get_stackptr	(u_int mode);

/*
 * Miscellany
 */

int get_pc_str_offset	(void);

/*
 * CPU functions from locore.S
 */

void cpu_reset		(void) __attribute__((__noreturn__));

/*
 * Cache info variables.
 */

/* PRIMARY CACHE VARIABLES */
extern int	arm_picache_size;
extern int	arm_picache_line_size;
extern int	arm_picache_ways;

extern int	arm_pdcache_size;	/* and unified */
extern int	arm_pdcache_line_size;
extern int	arm_pdcache_ways; 

extern int	arm_pcache_type;
extern int	arm_pcache_unified;

extern int	arm_dcache_align;
extern int	arm_dcache_align_mask;

#endif	/* _KERNEL */
#endif	/* _ARM_CPUFUNC_H_ */

/* End of cpufunc.h */
@


1.28
log
@unifdef CPU_XSCALE_PXA2X0, ARM_MMU_XSCALE, ARM_MMU_GENERIC (armv3)
and remove some xscale definitions.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.h,v 1.27 2016/08/22 01:42:00 jsg Exp $	*/
a220 1
#ifdef CPU_ARMv7
a253 1
#endif
@


1.27
log
@Before pmap7.c rev 1.35 and pmap.h rev 1.44 DMA'able memory with the
BUS_DMA_COHERENT flag was mapped as device memory which does not use the
store buffer.  It is now mapped as normal inner and outer non-cacheable
which does.

While we drain the cpu store buffer for this case, on cortex a9 systems we
also need to explicitly drain the PL310 L2's store buffer.  With PL310
revisions r3p2 and later this is done automatically after being present in
the store buffer for 256 cycles.  On i.MX6 PL310 is rev r3p1 which does
not have this behaviour.  This issue is i.MX6 errata ERR055199 and PL310
errata 769419.

This change restores io performance with a usb flash drive attached to
my cubox.  Raw reads go from 3 MB/s to 19 MB/s for example.

Based on code written by patrick@@ some time ago.
ok kettenis@@ patrick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.h,v 1.26 2016/08/14 11:30:54 jsg Exp $	*/
a255 50


#if defined(CPU_XSCALE_PXA2X0)
void	armv4_tlb_flushID	(void);
void	armv4_tlb_flushI	(void);
void	armv4_tlb_flushD	(void);
void	armv4_tlb_flushD_SE	(u_int va);

void	armv4_drain_writebuf	(void);
#endif

#if defined(CPU_XSCALE_PXA2X0) || (ARM_MMU_XSCALE == 1)
void	xscale_cpwait		(void);

void	xscale_cpu_sleep	(int mode);

u_int	xscale_control		(u_int clear, u_int bic);

void	xscale_setttb		(u_int ttb);

void	xscale_tlb_flushID_SE	(u_int va);

void	xscale_cache_flushID	(void);
void	xscale_cache_flushI	(void);
void	xscale_cache_flushD	(void);
void	xscale_cache_flushD_SE	(u_int entry);

void	xscale_cache_cleanID	(void);
void	xscale_cache_cleanD	(void);
void	xscale_cache_cleanD_E	(u_int entry);

void	xscale_cache_clean_minidata (void);

void	xscale_cache_purgeID	(void);
void	xscale_cache_purgeID_E	(u_int entry);
void	xscale_cache_purgeD	(void);
void	xscale_cache_purgeD_E	(u_int entry);

void	xscale_cache_syncI	(void);
void	xscale_cache_cleanID_rng (vaddr_t start, vsize_t end);
void	xscale_cache_cleanD_rng	(vaddr_t start, vsize_t end);
void	xscale_cache_purgeID_rng (vaddr_t start, vsize_t end);
void	xscale_cache_purgeD_rng	(vaddr_t start, vsize_t end);
void	xscale_cache_syncI_rng	(vaddr_t start, vsize_t end);
void	xscale_cache_flushD_rng	(vaddr_t start, vsize_t end);

void	xscale_context_switch	(u_int);

void	xscale_setup		(void);
#endif	/* CPU_XSCALE_PXA2X0 */
@


1.26
log
@Remove code for Intel 80219/80321 xscale processors used by armish.
Generic xscale support and support for pxa2x0 used by zaurus remains.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.h,v 1.25 2016/04/03 13:55:23 jsg Exp $	*/
d143 1
d195 1
@


1.25
log
@Add cpu_auxcontrol() to clear and set bits in the implementation/model
specific Auxiliary Control Register (ACTLR).

ok patrick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.h,v 1.24 2016/03/22 23:35:01 patrick Exp $	*/
d256 1
a256 1
#if defined(CPU_XSCALE_80321) || defined(CPU_XSCALE_PXA2X0)
d265 1
a265 2
#if defined(CPU_XSCALE_80321) || \
    defined(CPU_XSCALE_PXA2X0) || (ARM_MMU_XSCALE == 1)
d303 1
a303 1
#endif	/* CPU_XSCALE_80321 || CPU_XSCALE_PXA2X0 */
@


1.24
log
@Remove support for ARM11.  This was the last unused and unmaintained
processor in our code.  Now we're left with only armv7 and XScale for
armish and zaurus.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.h,v 1.23 2016/03/22 23:28:02 patrick Exp $	*/
d60 2
a61 1
	u_int	(*cf_control)		(u_int bic, u_int eor);
d162 2
a163 1
#define cpu_control(c, e)	cpufuncs.cf_control(c, e)
d211 2
a212 1
u_int	cpufunc_control		(u_int clear, u_int bic);
@


1.23
log
@Remove support for ARM10.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.h,v 1.22 2016/03/22 11:18:17 patrick Exp $	*/
a214 39

#ifdef CPU_ARM11
void	arm11_setttb		(u_int);

void	arm11_tlb_flushID_SE	(u_int);
void	arm11_tlb_flushI_SE	(u_int);

void	arm11_context_switch	(u_int);

void	arm11_setup		(void);
void	arm11_tlb_flushID	(void);
void	arm11_tlb_flushI	(void);
void	arm11_tlb_flushD	(void);
void	arm11_tlb_flushD_SE	(u_int	va);

void	arm11_drain_writebuf	(void);
void	arm11_cpu_sleep		(int	mode);
#endif


#if defined(CPU_ARM11)
void	armv5_setttb			(u_int);

void	armv5_icache_sync_all		(void);
void	armv5_icache_sync_range		(vaddr_t, vsize_t);

void	armv5_dcache_wbinv_all		(void);
void	armv5_dcache_wbinv_range	(vaddr_t, vsize_t);
void	armv5_dcache_inv_range		(vaddr_t, vsize_t);
void	armv5_dcache_wb_range		(vaddr_t, vsize_t);

void	armv5_idcache_wbinv_all		(void);
void	armv5_idcache_wbinv_range	(vaddr_t, vsize_t);

extern unsigned armv5_dcache_sets_max;
extern unsigned armv5_dcache_sets_inc;
extern unsigned armv5_dcache_index_max;
extern unsigned armv5_dcache_index_inc;
#endif
@


1.22
log
@Remove support for ARM9E.  This is another step in the plan to remove
all unused and unmaintained ARM processors from the past.

ok bmercer@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.h,v 1.21 2016/03/19 09:51:24 patrick Exp $	*/
a215 23
#if defined(CPU_ARM10)
void	arm10_tlb_flushID_SE	(u_int);
void	arm10_tlb_flushI_SE	(u_int);

void	arm10_context_switch	(u_int);

void	arm9e_setup		(void);
void	arm10_setup		(void);

void	armv5_ec_setttb			(u_int);

void	armv5_ec_icache_sync_all	(void);
void	armv5_ec_icache_sync_range	(vaddr_t, vsize_t);

void	armv5_ec_dcache_wbinv_all	(void);
void	armv5_ec_dcache_wbinv_range	(vaddr_t, vsize_t);
void	armv5_ec_dcache_inv_range	(vaddr_t, vsize_t);
void	armv5_ec_dcache_wb_range	(vaddr_t, vsize_t);

void	armv5_ec_idcache_wbinv_all	(void);
void	armv5_ec_idcache_wbinv_range	(vaddr_t, vsize_t);
#endif

d235 1
a235 1
#if defined (CPU_ARM10) || defined(CPU_ARM11)
d292 1
a292 3
#if defined(CPU_ARM10) || \
    defined(CPU_XSCALE_80321) || defined(CPU_XSCALE_PXA2X0)

@


1.21
log
@Remove support for the XScale 80200.  We don't use it, it didn't compile
and the included headers didn't even exist.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.h,v 1.20 2016/03/19 09:47:54 patrick Exp $	*/
d216 1
a216 1
#if defined(CPU_ARM9E) || defined(CPU_ARM10)
a223 1
#endif
a224 1
#if defined(CPU_ARM9E) || defined (CPU_ARM10)
d315 1
a315 1
#if defined(CPU_ARM9E) || defined(CPU_ARM10) || \
@


1.20
log
@Remove support for IXP425.  This is another architecture that is not
used and has probably never been used at all.  Some included headers
do not even exist.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.h,v 1.19 2016/03/19 09:36:57 patrick Exp $	*/
d318 1
a318 2
    defined(CPU_XSCALE_80200) || defined(CPU_XSCALE_80321) || \
    defined(CPU_XSCALE_PXA2X0)
d328 1
a328 1
#if defined(CPU_XSCALE_80200) || defined(CPU_XSCALE_80321) || \
d367 1
a367 1
#endif	/* CPU_XSCALE_80200 || CPU_XSCALE_80321 || CPU_XSCALE_PXA2X0 */
@


1.19
log
@Remove support for StrongARM (SA1) and IXP12x0.  Both are ARMv4 and
are not used by any of the arm platforms.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.h,v 1.18 2016/03/18 13:16:02 jsg Exp $	*/
d319 1
a319 1
    defined(CPU_XSCALE_PXA2X0) || defined(CPU_XSCALE_IXP425)
d330 1
a330 2
    defined(CPU_XSCALE_PXA2X0) || defined(CPU_XSCALE_IXP425) || \
    (ARM_MMU_XSCALE == 1)
d368 1
a368 1
#endif	/* CPU_XSCALE_80200 || CPU_XSCALE_80321 || CPU_XSCALE_PXA2X0 || CPU_XSCALE_IXP425 */
@


1.18
log
@Remove support for ARM9T (armv4t).  Not used by any of the arm platforms.
From Patrick Wildt.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.h,v 1.17 2016/03/18 06:54:21 jsg Exp $	*/
a215 37
#if defined(CPU_SA1100) || defined(CPU_SA1110)
void	sa11x0_drain_readbuf	(void);

void	sa11x0_context_switch	(u_int);
void	sa11x0_cpu_sleep	(int mode);
 
void	sa11x0_setup		(void);
#endif

#if defined(CPU_SA1100) || defined(CPU_SA1110)
void	sa1_setttb		(u_int ttb);

void	sa1_tlb_flushID_SE	(u_int va);

void	sa1_cache_flushID	(void);
void	sa1_cache_flushI	(void);
void	sa1_cache_flushD	(void);
void	sa1_cache_flushD_SE	(u_int entry);

void	sa1_cache_cleanID	(void);
void	sa1_cache_cleanD	(void);
void	sa1_cache_cleanD_E	(u_int entry);

void	sa1_cache_purgeID	(void);
void	sa1_cache_purgeID_E	(u_int entry);
void	sa1_cache_purgeD	(void);
void	sa1_cache_purgeD_E	(u_int entry);

void	sa1_cache_syncI		(void);
void	sa1_cache_cleanID_rng	(vaddr_t start, vsize_t end);
void	sa1_cache_cleanD_rng	(vaddr_t start, vsize_t end);
void	sa1_cache_purgeID_rng	(vaddr_t start, vsize_t end);
void	sa1_cache_purgeD_rng	(vaddr_t start, vsize_t end);
void	sa1_cache_syncI_rng	(vaddr_t start, vsize_t end);

#endif

a317 1
    defined(CPU_SA1100) || defined(CPU_SA1110) || \
a326 6
#endif

#if defined(CPU_IXP12X0)
void	ixp12x0_drain_readbuf	(void);
void	ixp12x0_context_switch	(u_int);
void	ixp12x0_setup		(void);
@


1.17
log
@Remove support for ARM8, an old armv4 processor without thumb that was
never supported by any arm port and wouldn't have built due to a missing
cpufunc_asm_arm8.S file.

From Patrick Wildt.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.h,v 1.16 2016/01/31 00:14:50 jsg Exp $	*/
a252 26
#ifdef CPU_ARM9
void	arm9_setttb			(u_int);

void	arm9_tlb_flushID_SE		(u_int);

void	arm9_icache_sync_all		(void);
void	arm9_icache_sync_range		(vaddr_t, vsize_t);

void	arm9_dcache_wbinv_all		(void);
void	arm9_dcache_wbinv_range		(vaddr_t, vsize_t);
void	arm9_dcache_inv_range		(vaddr_t, vsize_t);
void	arm9_dcache_wb_range		(vaddr_t, vsize_t);

void	arm9_idcache_wbinv_all		(void);
void	arm9_idcache_wbinv_range	(vaddr_t, vsize_t);

void	arm9_context_switch		(u_int);

void	arm9_setup			(void);

extern unsigned arm9_dcache_sets_max;
extern unsigned arm9_dcache_sets_inc;
extern unsigned arm9_dcache_index_max;
extern unsigned arm9_dcache_index_inc;
#endif

d354 1
a354 1
#if defined(CPU_ARM9) || defined(CPU_ARM9E) || defined(CPU_ARM10) || \
@


1.16
log
@Switch from PSR_X_bit and X32_bit PSR macro names to just PSR_X.
This matches FreeBSD and makes things a bit more consistent.
Discussed with Patrick.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.h,v 1.15 2014/03/29 18:09:28 guenther Exp $	*/
a214 25

#ifdef CPU_ARM8
void	arm8_setttb		(u_int ttb);
void	arm8_tlb_flushID	(void);
void	arm8_tlb_flushID_SE	(u_int va);
void	arm8_cache_flushID	(void);
void	arm8_cache_flushID_E	(u_int entry);
void	arm8_cache_cleanID	(void);
void	arm8_cache_cleanID_E	(u_int entry);
void	arm8_cache_purgeID	(void);
void	arm8_cache_purgeID_E	(u_int entry);

void	arm8_cache_syncI	(void);
void	arm8_cache_cleanID_rng	(vaddr_t start, vsize_t end);
void	arm8_cache_cleanD_rng	(vaddr_t start, vsize_t end);
void	arm8_cache_purgeID_rng	(vaddr_t start, vsize_t end);
void	arm8_cache_purgeD_rng	(vaddr_t start, vsize_t end);
void	arm8_cache_syncI_rng	(vaddr_t start, vsize_t end);

void	arm8_context_switch	(u_int);

void	arm8_setup		(void);

u_int	arm8_clock_config	(u_int, u_int);
#endif
@


1.15
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.h,v 1.14 2013/03/30 01:30:30 patrick Exp $	*/
d504 2
a505 2
	(__set_cpsr_c((mask) & (I32_bit | F32_bit), \
		      (mask) & (I32_bit | F32_bit)))
d508 1
a508 1
	(__set_cpsr_c((mask) & (I32_bit | F32_bit), 0))
d511 1
a511 1
	(__set_cpsr_c((I32_bit | F32_bit), (old_cpsr) & (I32_bit | F32_bit)))
@


1.14
log
@Add a function to read the ARM MPCore base address. This let's us
dynamically determine where e.g. the interrupt controller is.

ok bmercer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.h,v 1.13 2013/03/30 00:57:47 patrick Exp $	*/
d482 1
a482 1
	__asm __volatile(
d498 1
a498 1
	__asm __volatile("mrs	%0, cpsr" : "=&r" (ret));
@


1.13
log
@Remove duplicate prototypes.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.h,v 1.12 2013/03/27 00:06:09 patrick Exp $	*/
d384 2
@


1.12
log
@Add prototypes for secondary cache operations.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.h,v 1.11 2013/03/22 21:24:11 patrick Exp $	*/
a374 1
void	armv7_context_switch	(u_int);
a383 2

void	armv7_setttb			(u_int);
@


1.11
log
@Use different setup functions for ARM9E and ARM10 to fix an undefined
instruction fault on ARM9E caused by a coprocessor call.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.h,v 1.10 2013/01/23 19:57:47 patrick Exp $	*/
d138 5
d186 6
@


1.10
log
@Add instruction fault register functions, which will be needed for further
ARMv7 support.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.h,v 1.9 2011/09/20 22:02:13 miod Exp $	*/
d299 1
@


1.9
log
@Late spring cleaning of the arm code for old dusty bits we do not want to
keep:
- remove bootconfig parameter passing feature (unused).
- unifdef __PROG32 and remove all remains of arm26 code.
- remove ARMFPE support (unused).
- remove support for ARM2, ARM2AS, ARM3, ARM6, ARM7, ARM7TDMI and StrongARM
  processor families, and the related silicon bug workarounds (especially
  the SA-110 STM^ bug).
- remove cpu_functions no longer necessary after previous removals.
- remove ARM32_DISABLE_ALIGNMENT_FAULTS option (unused).
- make FIQ support conditional on option FIQ (unused, but may be eventually).

Discussed with drahn@@ and jasper@@ long ago, I was sitting on this commit for
no good reason.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.h,v 1.8 2011/03/23 16:54:34 pirofti Exp $	*/
d63 4
a66 2
	u_int	(*cf_faultstatus)	(void);
	u_int	(*cf_faultaddress)	(void);
d159 4
a162 2
#define cpu_faultstatus()	cpufuncs.cf_faultstatus()
#define cpu_faultaddress()	cpufuncs.cf_faultaddress()
d200 4
a203 2
u_int	cpufunc_faultstatus	(void);
u_int	cpufunc_faultaddress	(void);
@


1.8
log
@Normalize sentinel. Use _MACHINE_*_H_ and _<ARCH>_*_H_ properly and consitently.

Discussed and okay drahn@@. Okay deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.h,v 1.7 2010/04/22 21:01:45 drahn Exp $	*/
a139 2
	void	(*cf_flush_brnchtgt_C)	(void);
	void	(*cf_flush_brnchtgt_E)	(u_int va);
a143 4

	int	(*cf_dataabt_fixup)	(void *arg);
	int	(*cf_prefetchabt_fixup)	(void *arg);

d145 1
a145 2

	void	(*cf_setup)		(char *string);
a179 2
#define	cpu_flush_brnchtgt_C()	cpufuncs.cf_flush_brnchtgt_C()
#define	cpu_flush_brnchtgt_E(e)	cpufuncs.cf_flush_brnchtgt_E(e)
a182 6
#define cpu_dataabt_fixup(a)		cpufuncs.cf_dataabt_fixup(a)
#define cpu_prefetchabt_fixup(a)	cpufuncs.cf_prefetchabt_fixup(a)
#define ABORT_FIXUP_OK		0	/* fixup succeeded */
#define ABORT_FIXUP_FAILED	1	/* fixup failed */
#define ABORT_FIXUP_RETURN	2	/* abort handler should return */

a190 1
int	cpufunc_null_fixup	(void *);
a198 31
#ifdef CPU_ARM3
u_int	arm3_control		(u_int clear, u_int bic);
void	arm3_cache_flush	(void);
#endif	/* CPU_ARM3 */

#if defined(CPU_ARM6) || defined(CPU_ARM7)
void	arm67_setttb		(u_int ttb);
void	arm67_tlb_flush		(void);
void	arm67_tlb_purge		(u_int va);
void	arm67_cache_flush	(void);
void	arm67_context_switch	(u_int);
#endif	/* CPU_ARM6 || CPU_ARM7 */

#ifdef CPU_ARM6
void	arm6_setup		(char *string);
#endif	/* CPU_ARM6 */

#ifdef CPU_ARM7
void	arm7_setup		(char *string);
#endif	/* CPU_ARM7 */

#ifdef CPU_ARM7TDMI
int	arm7_dataabt_fixup	(void *arg);
void	arm7tdmi_setup		(char *string);
void	arm7tdmi_setttb		(u_int ttb);
void	arm7tdmi_tlb_flushID	(void);
void	arm7tdmi_tlb_flushID_SE	(u_int va);
void	arm7tdmi_cache_flushID	(void);
void	arm7tdmi_context_switch	(u_int);
#endif /* CPU_ARM7TDMI */

d219 1
a219 1
void	arm8_setup		(char *string);
a223 5
#ifdef CPU_SA110
void	sa110_setup		(char *string);
void	sa110_context_switch	(u_int);
#endif	/* CPU_SA110 */

d230 1
a230 1
void	sa11x0_setup		(char *string);
d233 1
a233 1
#if defined(CPU_SA110) || defined(CPU_SA1100) || defined(CPU_SA1110)
d279 1
a279 1
void	arm9_setup			(char *string);
d293 1
a293 1
void	arm10_setup		(char *string);
d319 1
a319 1
void	arm11_setup		(char	*string);
d359 1
a359 1
void	armv7_setup		(char *string);
d389 1
a389 1
    defined(CPU_SA110) || defined(CPU_SA1100) || defined(CPU_SA1110) || \
d404 1
a404 1
void	ixp12x0_setup		(char *string);
d446 1
a446 1
void	xscale_setup		(char *string);
a455 1
#ifdef __PROG32
a494 16
#else /* ! __PROG32 */
#define	disable_interrupts(mask)					\
	(set_r15((mask) & (R15_IRQ_DISABLE | R15_FIQ_DISABLE),		\
		 (mask) & (R15_IRQ_DISABLE | R15_FIQ_DISABLE)))

#define	enable_interrupts(mask)						\
	(set_r15((mask) & (R15_IRQ_DISABLE | R15_FIQ_DISABLE), 0))

#define	restore_interrupts(old_r15)					\
	(set_r15((R15_IRQ_DISABLE | R15_FIQ_DISABLE),			\
		 (old_r15) & (R15_IRQ_DISABLE | R15_FIQ_DISABLE)))

/* Functions to manipulate the processor control bits in r15. */
u_int	set_r15(u_int bic, u_int eor);
u_int	get_r15(void);
#endif /* __PROG32 */
@


1.7
log
@Whitespace cleanup on generated asm code, so it is readable.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.h,v 1.6 2009/05/08 02:57:32 drahn Exp $	*/
d43 2
a44 2
#ifndef _ARM32_CPUFUNC_H_
#define _ARM32_CPUFUNC_H_
d605 1
a605 1
#endif	/* _ARM32_CPUFUNC_H_ */
@


1.6
log
@Pieces of arm11 and armv7 support for newer cpus. This is work in progress
and not complete.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.h,v 1.5 2008/09/11 02:38:14 kevlo Exp $	*/
d519 4
a522 4
		"mrs	%0, cpsr\n"	/* Get the CPSR */
		"bic	 %1, %0, %2\n"	/* Clear bits */
		"eor	 %1, %1, %3\n"	/* XOR bits */
		"msr	cpsr_c, %1\n"	/* Set the control field of CPSR */
@


1.5
log
@add support for arm9e core, taken from NetBSD.
ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.h,v 1.4 2007/09/22 19:57:45 kettenis Exp $	*/
d363 20
a382 1
#if defined (CPU_ARM10)
d402 38
d519 1
a519 1
		"mrs     %0, cpsr\n"	/* Get the CPSR */
d522 1
a522 1
		"msr     cpsr_c, %1\n"	/* Set the control field of CPSR */
@


1.4
log
@cf_context_switch takes an u_int argument.

ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.h,v 1.3 2006/07/12 17:29:55 miod Exp $	*/
d314 1
a314 1
void	arm9_setttb		(u_int);
d316 1
a316 1
void	arm9_tlb_flushID_SE	(u_int va);
d318 2
a319 6
void	arm9_cache_flushID	(void);
void	arm9_cache_flushID_SE	(u_int);
void	arm9_cache_flushI	(void);
void	arm9_cache_flushI_SE	(u_int);
void	arm9_cache_flushD	(void);
void	arm9_cache_flushD_SE	(u_int);
d321 4
a324 1
void	arm9_cache_cleanID	(void);
d326 2
a327 4
void	arm9_cache_syncI	(void);
void	arm9_cache_flushID_rng	(vaddr_t, vsize_t);
void	arm9_cache_flushD_rng	(vaddr_t, vsize_t);
void	arm9_cache_syncI_rng	(vaddr_t, vsize_t);
d329 1
a329 1
void	arm9_context_switch	(u_int);
d331 6
a336 1
void	arm9_setup		(char *string);
d339 1
a339 3
#ifdef CPU_ARM10
void	arm10_setttb		(u_int);

d343 4
a346 2
void	arm10_icache_sync_all	(void);
void	arm10_icache_sync_range	(vaddr_t, vsize_t);
d348 2
a349 4
void	arm10_dcache_wbinv_all	(void);
void	arm10_dcache_wbinv_range (vaddr_t, vsize_t);
void	arm10_dcache_inv_range	(vaddr_t, vsize_t);
void	arm10_dcache_wb_range	(vaddr_t, vsize_t);
d351 2
a352 2
void	arm10_idcache_wbinv_all	(void);
void	arm10_idcache_wbinv_range (vaddr_t, vsize_t);
d354 11
a364 1
void	arm10_context_switch	(u_int);
d366 2
a367 1
void	arm10_setup		(char *string);
d369 12
a380 4
extern unsigned arm10_dcache_sets_max;
extern unsigned arm10_dcache_sets_inc;
extern unsigned arm10_dcache_index_max;
extern unsigned arm10_dcache_index_inc;
d383 2
a384 2
#if defined(CPU_ARM9) || defined(CPU_ARM10) || defined(CPU_SA110) || \
    defined(CPU_SA1100) || defined(CPU_SA1110) || \
@


1.3
log
@Turn GetCPSR() into an inline get_cpsr(), and remove more dead code.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.h,v 1.2 2004/05/19 03:17:07 drahn Exp $	*/
d150 1
a150 1
	void	(*cf_context_switch)	(void);
d198 1
d225 1
a225 1
void	arm67_context_switch	(void);
d243 1
a243 1
void	arm7tdmi_context_switch	(void);
d264 1
a264 1
void	arm8_context_switch	(void);
d273 1
a273 1
void	sa110_context_switch	(void);
d279 1
a279 1
void	sa11x0_context_switch	(void);
d332 1
a332 1
void	arm9_context_switch	(void);
d354 1
a354 1
void	arm10_context_switch	(void);
d379 1
a379 1
void	ixp12x0_context_switch	(void);
d420 1
a420 1
void	xscale_context_switch	(void);
@


1.2
log
@de __P of sys/arch/arm.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.h,v 1.1 2004/02/01 05:09:49 drahn Exp $	*/
d432 3
a434 1
static __inline u_int32_t __set_cpsr_c(u_int bic, u_int eor) __attribute__((__unused__));
d452 10
a481 1
#endif /* __PROG32 */
a482 5
#ifdef __PROG32
/* Functions to manipulate the CPSR. */
u_int	SetCPSR(u_int bic, u_int eor);
u_int	GetCPSR(void);
#else
@


1.1
log
@Arm port, NetBSD codebase stripped down, 32bit only support.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.h,v 1.2 2004/01/29 16:17:16 drahn Exp $	*/
d55 2
a56 2
	u_int	(*cf_id)		__P((void));
	void	(*cf_cpwait)		__P((void));
d60 5
a64 5
	u_int	(*cf_control)		__P((u_int bic, u_int eor));
	void	(*cf_domains)		__P((u_int domains));
	void	(*cf_setttb)		__P((u_int ttb));
	u_int	(*cf_faultstatus)	__P((void));
	u_int	(*cf_faultaddress)	__P((void));
d68 6
a73 6
	void	(*cf_tlb_flushID)	__P((void));	
	void	(*cf_tlb_flushID_SE)	__P((u_int va));	
	void	(*cf_tlb_flushI)	__P((void));
	void	(*cf_tlb_flushI_SE)	__P((u_int va));	
	void	(*cf_tlb_flushD)	__P((void));
	void	(*cf_tlb_flushD_SE)	__P((u_int va));	
d125 2
a126 2
	void	(*cf_icache_sync_all)	__P((void));
	void	(*cf_icache_sync_range)	__P((vaddr_t, vsize_t));
d128 4
a131 4
	void	(*cf_dcache_wbinv_all)	__P((void));
	void	(*cf_dcache_wbinv_range) __P((vaddr_t, vsize_t));
	void	(*cf_dcache_inv_range)	__P((vaddr_t, vsize_t));
	void	(*cf_dcache_wb_range)	__P((vaddr_t, vsize_t));
d133 2
a134 2
	void	(*cf_idcache_wbinv_all)	__P((void));
	void	(*cf_idcache_wbinv_range) __P((vaddr_t, vsize_t));
d138 4
a141 4
	void	(*cf_flush_prefetchbuf)	__P((void));
	void	(*cf_drain_writebuf)	__P((void));
	void	(*cf_flush_brnchtgt_C)	__P((void));
	void	(*cf_flush_brnchtgt_E)	__P((u_int va));
d143 1
a143 1
	void	(*cf_sleep)		__P((int mode));
d147 2
a148 2
	int	(*cf_dataabt_fixup)	__P((void *arg));
	int	(*cf_prefetchabt_fixup)	__P((void *arg));
d150 1
a150 1
	void	(*cf_context_switch)	__P((void));
d152 1
a152 1
	void	(*cf_setup)		__P((char *string));
d200 1
a200 1
int	set_cpufuncs		__P((void));
d204 9
a212 9
void	cpufunc_nullop		__P((void));
int	cpufunc_null_fixup	__P((void *));
int	early_abort_fixup	__P((void *));
int	late_abort_fixup	__P((void *));
u_int	cpufunc_id		__P((void));
u_int	cpufunc_control		__P((u_int clear, u_int bic));
void	cpufunc_domains		__P((u_int domains));
u_int	cpufunc_faultstatus	__P((void));
u_int	cpufunc_faultaddress	__P((void));
d215 2
a216 2
u_int	arm3_control		__P((u_int clear, u_int bic));
void	arm3_cache_flush	__P((void));
d220 5
a224 5
void	arm67_setttb		__P((u_int ttb));
void	arm67_tlb_flush		__P((void));
void	arm67_tlb_purge		__P((u_int va));
void	arm67_cache_flush	__P((void));
void	arm67_context_switch	__P((void));
d228 1
a228 1
void	arm6_setup		__P((char *string));
d232 1
a232 1
void	arm7_setup		__P((char *string));
d236 7
a242 7
int	arm7_dataabt_fixup	__P((void *arg));
void	arm7tdmi_setup		__P((char *string));
void	arm7tdmi_setttb		__P((u_int ttb));
void	arm7tdmi_tlb_flushID	__P((void));
void	arm7tdmi_tlb_flushID_SE	__P((u_int va));
void	arm7tdmi_cache_flushID	__P((void));
void	arm7tdmi_context_switch	__P((void));
d246 16
a261 16
void	arm8_setttb		__P((u_int ttb));
void	arm8_tlb_flushID	__P((void));
void	arm8_tlb_flushID_SE	__P((u_int va));
void	arm8_cache_flushID	__P((void));
void	arm8_cache_flushID_E	__P((u_int entry));
void	arm8_cache_cleanID	__P((void));
void	arm8_cache_cleanID_E	__P((u_int entry));
void	arm8_cache_purgeID	__P((void));
void	arm8_cache_purgeID_E	__P((u_int entry));

void	arm8_cache_syncI	__P((void));
void	arm8_cache_cleanID_rng	__P((vaddr_t start, vsize_t end));
void	arm8_cache_cleanD_rng	__P((vaddr_t start, vsize_t end));
void	arm8_cache_purgeID_rng	__P((vaddr_t start, vsize_t end));
void	arm8_cache_purgeD_rng	__P((vaddr_t start, vsize_t end));
void	arm8_cache_syncI_rng	__P((vaddr_t start, vsize_t end));
d263 1
a263 1
void	arm8_context_switch	__P((void));
d265 1
a265 1
void	arm8_setup		__P((char *string));
d267 1
a267 1
u_int	arm8_clock_config	__P((u_int, u_int));
d271 2
a272 2
void	sa110_setup		__P((char *string));
void	sa110_context_switch	__P((void));
d276 1
a276 1
void	sa11x0_drain_readbuf	__P((void));
d278 2
a279 2
void	sa11x0_context_switch	__P((void));
void	sa11x0_cpu_sleep	__P((int mode));
d281 1
a281 1
void	sa11x0_setup		__P((char *string));
d285 1
a285 1
void	sa1_setttb		__P((u_int ttb));
d287 1
a287 1
void	sa1_tlb_flushID_SE	__P((u_int va));
d289 20
a308 20
void	sa1_cache_flushID	__P((void));
void	sa1_cache_flushI	__P((void));
void	sa1_cache_flushD	__P((void));
void	sa1_cache_flushD_SE	__P((u_int entry));

void	sa1_cache_cleanID	__P((void));
void	sa1_cache_cleanD	__P((void));
void	sa1_cache_cleanD_E	__P((u_int entry));

void	sa1_cache_purgeID	__P((void));
void	sa1_cache_purgeID_E	__P((u_int entry));
void	sa1_cache_purgeD	__P((void));
void	sa1_cache_purgeD_E	__P((u_int entry));

void	sa1_cache_syncI		__P((void));
void	sa1_cache_cleanID_rng	__P((vaddr_t start, vsize_t end));
void	sa1_cache_cleanD_rng	__P((vaddr_t start, vsize_t end));
void	sa1_cache_purgeID_rng	__P((vaddr_t start, vsize_t end));
void	sa1_cache_purgeD_rng	__P((vaddr_t start, vsize_t end));
void	sa1_cache_syncI_rng	__P((vaddr_t start, vsize_t end));
d313 1
a313 1
void	arm9_setttb		__P((u_int));
d315 1
a315 1
void	arm9_tlb_flushID_SE	__P((u_int va));
d317 6
a322 6
void	arm9_cache_flushID	__P((void));
void	arm9_cache_flushID_SE	__P((u_int));
void	arm9_cache_flushI	__P((void));
void	arm9_cache_flushI_SE	__P((u_int));
void	arm9_cache_flushD	__P((void));
void	arm9_cache_flushD_SE	__P((u_int));
d324 1
a324 1
void	arm9_cache_cleanID	__P((void));
d326 4
a329 4
void	arm9_cache_syncI	__P((void));
void	arm9_cache_flushID_rng	__P((vaddr_t, vsize_t));
void	arm9_cache_flushD_rng	__P((vaddr_t, vsize_t));
void	arm9_cache_syncI_rng	__P((vaddr_t, vsize_t));
d331 1
a331 1
void	arm9_context_switch	__P((void));
d333 1
a333 1
void	arm9_setup		__P((char *string));
d337 1
a337 1
void	arm10_setttb		__P((u_int));
d339 2
a340 2
void	arm10_tlb_flushID_SE	__P((u_int));
void	arm10_tlb_flushI_SE	__P((u_int));
d342 2
a343 2
void	arm10_icache_sync_all	__P((void));
void	arm10_icache_sync_range	__P((vaddr_t, vsize_t));
d345 4
a348 4
void	arm10_dcache_wbinv_all	__P((void));
void	arm10_dcache_wbinv_range __P((vaddr_t, vsize_t));
void	arm10_dcache_inv_range	__P((vaddr_t, vsize_t));
void	arm10_dcache_wb_range	__P((vaddr_t, vsize_t));
d350 2
a351 2
void	arm10_idcache_wbinv_all	__P((void));
void	arm10_idcache_wbinv_range __P((vaddr_t, vsize_t));
d353 1
a353 1
void	arm10_context_switch	__P((void));
d355 1
a355 1
void	arm10_setup		__P((char *string));
d368 4
a371 4
void	armv4_tlb_flushID	__P((void));
void	armv4_tlb_flushI	__P((void));
void	armv4_tlb_flushD	__P((void));
void	armv4_tlb_flushD_SE	__P((u_int va));
d373 1
a373 1
void	armv4_drain_writebuf	__P((void));
d377 3
a379 3
void	ixp12x0_drain_readbuf	__P((void));
void	ixp12x0_context_switch	__P((void));
void	ixp12x0_setup		__P((char *string));
d385 1
a385 1
void	xscale_cpwait		__P((void));
d387 1
a387 1
void	xscale_cpu_sleep	__P((int mode));
d389 1
a389 1
u_int	xscale_control		__P((u_int clear, u_int bic));
d391 1
a391 1
void	xscale_setttb		__P((u_int ttb));
d393 1
a393 1
void	xscale_tlb_flushID_SE	__P((u_int va));
d395 4
a398 4
void	xscale_cache_flushID	__P((void));
void	xscale_cache_flushI	__P((void));
void	xscale_cache_flushD	__P((void));
void	xscale_cache_flushD_SE	__P((u_int entry));
d400 3
a402 3
void	xscale_cache_cleanID	__P((void));
void	xscale_cache_cleanD	__P((void));
void	xscale_cache_cleanD_E	__P((u_int entry));
d404 1
a404 1
void	xscale_cache_clean_minidata __P((void));
d406 4
a409 4
void	xscale_cache_purgeID	__P((void));
void	xscale_cache_purgeID_E	__P((u_int entry));
void	xscale_cache_purgeD	__P((void));
void	xscale_cache_purgeD_E	__P((u_int entry));
d411 7
a417 7
void	xscale_cache_syncI	__P((void));
void	xscale_cache_cleanID_rng __P((vaddr_t start, vsize_t end));
void	xscale_cache_cleanD_rng	__P((vaddr_t start, vsize_t end));
void	xscale_cache_purgeID_rng __P((vaddr_t start, vsize_t end));
void	xscale_cache_purgeD_rng	__P((vaddr_t start, vsize_t end));
void	xscale_cache_syncI_rng	__P((vaddr_t start, vsize_t end));
void	xscale_cache_flushD_rng	__P((vaddr_t start, vsize_t end));
d419 1
a419 1
void	xscale_context_switch	__P((void));
d421 1
a421 1
void	xscale_setup		__P((char *string));
d487 2
a488 2
void set_stackptr	__P((u_int mode, u_int address));
u_int get_stackptr	__P((u_int mode));
d494 1
a494 1
int get_pc_str_offset	__P((void));
d500 1
a500 1
void cpu_reset		__P((void)) __attribute__((__noreturn__));
@


1.1.2.1
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.1.2.2
log
@Merge with the trunk
@
text
@d55 2
a56 2
	u_int	(*cf_id)		(void);
	void	(*cf_cpwait)		(void);
d60 5
a64 5
	u_int	(*cf_control)		(u_int bic, u_int eor);
	void	(*cf_domains)		(u_int domains);
	void	(*cf_setttb)		(u_int ttb);
	u_int	(*cf_faultstatus)	(void);
	u_int	(*cf_faultaddress)	(void);
d68 6
a73 6
	void	(*cf_tlb_flushID)	(void);	
	void	(*cf_tlb_flushID_SE)	(u_int va);	
	void	(*cf_tlb_flushI)	(void);
	void	(*cf_tlb_flushI_SE)	(u_int va);	
	void	(*cf_tlb_flushD)	(void);
	void	(*cf_tlb_flushD_SE)	(u_int va);	
d125 2
a126 2
	void	(*cf_icache_sync_all)	(void);
	void	(*cf_icache_sync_range)	(vaddr_t, vsize_t);
d128 4
a131 4
	void	(*cf_dcache_wbinv_all)	(void);
	void	(*cf_dcache_wbinv_range) (vaddr_t, vsize_t);
	void	(*cf_dcache_inv_range)	(vaddr_t, vsize_t);
	void	(*cf_dcache_wb_range)	(vaddr_t, vsize_t);
d133 2
a134 2
	void	(*cf_idcache_wbinv_all)	(void);
	void	(*cf_idcache_wbinv_range) (vaddr_t, vsize_t);
d138 4
a141 4
	void	(*cf_flush_prefetchbuf)	(void);
	void	(*cf_drain_writebuf)	(void);
	void	(*cf_flush_brnchtgt_C)	(void);
	void	(*cf_flush_brnchtgt_E)	(u_int va);
d143 1
a143 1
	void	(*cf_sleep)		(int mode);
d147 2
a148 2
	int	(*cf_dataabt_fixup)	(void *arg);
	int	(*cf_prefetchabt_fixup)	(void *arg);
d150 1
a150 1
	void	(*cf_context_switch)	(void);
d152 1
a152 1
	void	(*cf_setup)		(char *string);
d200 1
a200 1
int	set_cpufuncs		(void);
d204 9
a212 9
void	cpufunc_nullop		(void);
int	cpufunc_null_fixup	(void *);
int	early_abort_fixup	(void *);
int	late_abort_fixup	(void *);
u_int	cpufunc_id		(void);
u_int	cpufunc_control		(u_int clear, u_int bic);
void	cpufunc_domains		(u_int domains);
u_int	cpufunc_faultstatus	(void);
u_int	cpufunc_faultaddress	(void);
d215 2
a216 2
u_int	arm3_control		(u_int clear, u_int bic);
void	arm3_cache_flush	(void);
d220 5
a224 5
void	arm67_setttb		(u_int ttb);
void	arm67_tlb_flush		(void);
void	arm67_tlb_purge		(u_int va);
void	arm67_cache_flush	(void);
void	arm67_context_switch	(void);
d228 1
a228 1
void	arm6_setup		(char *string);
d232 1
a232 1
void	arm7_setup		(char *string);
d236 7
a242 7
int	arm7_dataabt_fixup	(void *arg);
void	arm7tdmi_setup		(char *string);
void	arm7tdmi_setttb		(u_int ttb);
void	arm7tdmi_tlb_flushID	(void);
void	arm7tdmi_tlb_flushID_SE	(u_int va);
void	arm7tdmi_cache_flushID	(void);
void	arm7tdmi_context_switch	(void);
d246 16
a261 16
void	arm8_setttb		(u_int ttb);
void	arm8_tlb_flushID	(void);
void	arm8_tlb_flushID_SE	(u_int va);
void	arm8_cache_flushID	(void);
void	arm8_cache_flushID_E	(u_int entry);
void	arm8_cache_cleanID	(void);
void	arm8_cache_cleanID_E	(u_int entry);
void	arm8_cache_purgeID	(void);
void	arm8_cache_purgeID_E	(u_int entry);

void	arm8_cache_syncI	(void);
void	arm8_cache_cleanID_rng	(vaddr_t start, vsize_t end);
void	arm8_cache_cleanD_rng	(vaddr_t start, vsize_t end);
void	arm8_cache_purgeID_rng	(vaddr_t start, vsize_t end);
void	arm8_cache_purgeD_rng	(vaddr_t start, vsize_t end);
void	arm8_cache_syncI_rng	(vaddr_t start, vsize_t end);
d263 1
a263 1
void	arm8_context_switch	(void);
d265 1
a265 1
void	arm8_setup		(char *string);
d267 1
a267 1
u_int	arm8_clock_config	(u_int, u_int);
d271 2
a272 2
void	sa110_setup		(char *string);
void	sa110_context_switch	(void);
d276 1
a276 1
void	sa11x0_drain_readbuf	(void);
d278 2
a279 2
void	sa11x0_context_switch	(void);
void	sa11x0_cpu_sleep	(int mode);
d281 1
a281 1
void	sa11x0_setup		(char *string);
d285 1
a285 1
void	sa1_setttb		(u_int ttb);
d287 1
a287 1
void	sa1_tlb_flushID_SE	(u_int va);
d289 20
a308 20
void	sa1_cache_flushID	(void);
void	sa1_cache_flushI	(void);
void	sa1_cache_flushD	(void);
void	sa1_cache_flushD_SE	(u_int entry);

void	sa1_cache_cleanID	(void);
void	sa1_cache_cleanD	(void);
void	sa1_cache_cleanD_E	(u_int entry);

void	sa1_cache_purgeID	(void);
void	sa1_cache_purgeID_E	(u_int entry);
void	sa1_cache_purgeD	(void);
void	sa1_cache_purgeD_E	(u_int entry);

void	sa1_cache_syncI		(void);
void	sa1_cache_cleanID_rng	(vaddr_t start, vsize_t end);
void	sa1_cache_cleanD_rng	(vaddr_t start, vsize_t end);
void	sa1_cache_purgeID_rng	(vaddr_t start, vsize_t end);
void	sa1_cache_purgeD_rng	(vaddr_t start, vsize_t end);
void	sa1_cache_syncI_rng	(vaddr_t start, vsize_t end);
d313 1
a313 1
void	arm9_setttb		(u_int);
d315 1
a315 1
void	arm9_tlb_flushID_SE	(u_int va);
d317 6
a322 6
void	arm9_cache_flushID	(void);
void	arm9_cache_flushID_SE	(u_int);
void	arm9_cache_flushI	(void);
void	arm9_cache_flushI_SE	(u_int);
void	arm9_cache_flushD	(void);
void	arm9_cache_flushD_SE	(u_int);
d324 1
a324 1
void	arm9_cache_cleanID	(void);
d326 4
a329 4
void	arm9_cache_syncI	(void);
void	arm9_cache_flushID_rng	(vaddr_t, vsize_t);
void	arm9_cache_flushD_rng	(vaddr_t, vsize_t);
void	arm9_cache_syncI_rng	(vaddr_t, vsize_t);
d331 1
a331 1
void	arm9_context_switch	(void);
d333 1
a333 1
void	arm9_setup		(char *string);
d337 1
a337 1
void	arm10_setttb		(u_int);
d339 2
a340 2
void	arm10_tlb_flushID_SE	(u_int);
void	arm10_tlb_flushI_SE	(u_int);
d342 2
a343 2
void	arm10_icache_sync_all	(void);
void	arm10_icache_sync_range	(vaddr_t, vsize_t);
d345 4
a348 4
void	arm10_dcache_wbinv_all	(void);
void	arm10_dcache_wbinv_range (vaddr_t, vsize_t);
void	arm10_dcache_inv_range	(vaddr_t, vsize_t);
void	arm10_dcache_wb_range	(vaddr_t, vsize_t);
d350 2
a351 2
void	arm10_idcache_wbinv_all	(void);
void	arm10_idcache_wbinv_range (vaddr_t, vsize_t);
d353 1
a353 1
void	arm10_context_switch	(void);
d355 1
a355 1
void	arm10_setup		(char *string);
d368 4
a371 4
void	armv4_tlb_flushID	(void);
void	armv4_tlb_flushI	(void);
void	armv4_tlb_flushD	(void);
void	armv4_tlb_flushD_SE	(u_int va);
d373 1
a373 1
void	armv4_drain_writebuf	(void);
d377 3
a379 3
void	ixp12x0_drain_readbuf	(void);
void	ixp12x0_context_switch	(void);
void	ixp12x0_setup		(char *string);
d385 1
a385 1
void	xscale_cpwait		(void);
d387 1
a387 1
void	xscale_cpu_sleep	(int mode);
d389 1
a389 1
u_int	xscale_control		(u_int clear, u_int bic);
d391 1
a391 1
void	xscale_setttb		(u_int ttb);
d393 1
a393 1
void	xscale_tlb_flushID_SE	(u_int va);
d395 4
a398 4
void	xscale_cache_flushID	(void);
void	xscale_cache_flushI	(void);
void	xscale_cache_flushD	(void);
void	xscale_cache_flushD_SE	(u_int entry);
d400 3
a402 3
void	xscale_cache_cleanID	(void);
void	xscale_cache_cleanD	(void);
void	xscale_cache_cleanD_E	(u_int entry);
d404 1
a404 1
void	xscale_cache_clean_minidata (void);
d406 4
a409 4
void	xscale_cache_purgeID	(void);
void	xscale_cache_purgeID_E	(u_int entry);
void	xscale_cache_purgeD	(void);
void	xscale_cache_purgeD_E	(u_int entry);
d411 7
a417 7
void	xscale_cache_syncI	(void);
void	xscale_cache_cleanID_rng (vaddr_t start, vsize_t end);
void	xscale_cache_cleanD_rng	(vaddr_t start, vsize_t end);
void	xscale_cache_purgeID_rng (vaddr_t start, vsize_t end);
void	xscale_cache_purgeD_rng	(vaddr_t start, vsize_t end);
void	xscale_cache_syncI_rng	(vaddr_t start, vsize_t end);
void	xscale_cache_flushD_rng	(vaddr_t start, vsize_t end);
d419 1
a419 1
void	xscale_context_switch	(void);
d421 1
a421 1
void	xscale_setup		(char *string);
d487 2
a488 2
void set_stackptr	(u_int mode, u_int address);
u_int get_stackptr	(u_int mode);
d494 1
a494 1
int get_pc_str_offset	(void);
d500 1
a500 1
void cpu_reset		(void) __attribute__((__noreturn__));
@


