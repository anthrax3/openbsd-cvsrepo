head	1.45;
access;
symbols
	OPENBSD_6_0:1.41.0.2
	OPENBSD_6_0_BASE:1.41
	OPENBSD_5_9:1.40.0.2
	OPENBSD_5_9_BASE:1.40
	OPENBSD_5_8:1.39.0.8
	OPENBSD_5_8_BASE:1.39
	OPENBSD_5_7:1.39.0.2
	OPENBSD_5_7_BASE:1.39
	OPENBSD_5_6:1.39.0.4
	OPENBSD_5_6_BASE:1.39
	OPENBSD_5_5:1.38.0.4
	OPENBSD_5_5_BASE:1.38
	OPENBSD_5_4:1.35.0.2
	OPENBSD_5_4_BASE:1.35
	OPENBSD_5_3:1.33.0.2
	OPENBSD_5_3_BASE:1.33
	OPENBSD_5_2:1.30.0.4
	OPENBSD_5_2_BASE:1.30
	OPENBSD_5_1_BASE:1.30
	OPENBSD_5_1:1.30.0.2
	OPENBSD_5_0:1.27.0.2
	OPENBSD_5_0_BASE:1.27
	OPENBSD_4_9:1.26.0.2
	OPENBSD_4_9_BASE:1.26
	OPENBSD_4_8:1.24.0.6
	OPENBSD_4_8_BASE:1.24
	OPENBSD_4_7:1.24.0.2
	OPENBSD_4_7_BASE:1.24
	OPENBSD_4_6:1.24.0.4
	OPENBSD_4_6_BASE:1.24
	OPENBSD_4_5:1.23.0.2
	OPENBSD_4_5_BASE:1.23
	OPENBSD_4_4:1.19.0.2
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.18.0.4
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.18.0.2
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.14.0.2
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.12.0.4
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.12.0.2
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.9.0.2
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.6.0.2
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	SMP_SYNC_A:1.4
	SMP_SYNC_B:1.4
	OPENBSD_3_5:1.3.0.2
	OPENBSD_3_5_BASE:1.3
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.45
date	2017.03.03.14.54.02;	author tom;	state Exp;
branches;
next	1.44;
commitid	jp361XE2XEhMJf9Q;

1.44
date	2017.03.02.10.38.10;	author natano;	state Exp;
branches;
next	1.43;
commitid	EeVoCYFCx2tYicZQ;

1.43
date	2017.01.06.00.06.02;	author jsg;	state Exp;
branches;
next	1.42;
commitid	YCbIRye8xzoWl68V;

1.42
date	2017.01.05.16.16.17;	author patrick;	state Exp;
branches;
next	1.41;
commitid	4A2j3S336QFvowJq;

1.41
date	2016.04.04.09.13.44;	author patrick;	state Exp;
branches;
next	1.40;
commitid	kyi1uK5Qbg4pXWh9;

1.40
date	2016.01.31.00.14.50;	author jsg;	state Exp;
branches;
next	1.39;
commitid	pbLjedMudUFrVMk6;

1.39
date	2014.07.11.10.53.07;	author uebayasi;	state Exp;
branches;
next	1.38;
commitid	CaCLs5fTSVpJlqFi;

1.38
date	2013.09.12.11.43.51;	author patrick;	state Exp;
branches;
next	1.37;

1.37
date	2013.09.12.11.42.22;	author patrick;	state Exp;
branches;
next	1.36;

1.36
date	2013.09.10.12.35.26;	author patrick;	state Exp;
branches;
next	1.35;

1.35
date	2013.05.31.17.00.58;	author tedu;	state Exp;
branches;
next	1.34;

1.34
date	2013.03.12.09.37.16;	author mpi;	state Exp;
branches;
next	1.33;

1.33
date	2013.02.12.08.06.22;	author mpi;	state Exp;
branches;
next	1.32;

1.32
date	2013.02.11.17.05.25;	author mpi;	state Exp;
branches;
next	1.31;

1.31
date	2012.12.02.07.03.31;	author guenther;	state Exp;
branches;
next	1.30;

1.30
date	2011.11.16.20.50.18;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2011.10.24.22.49.07;	author drahn;	state Exp;
branches;
next	1.28;

1.28
date	2011.09.20.22.02.13;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2011.06.24.19.47.48;	author naddy;	state Exp;
branches;
next	1.26;

1.26
date	2010.11.28.20.44.20;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2010.09.28.20.27.54;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2009.03.26.17.24.33;	author oga;	state Exp;
branches;
next	1.23;

1.23
date	2008.10.15.23.23.46;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2008.10.10.08.36.28;	author art;	state Exp;
branches;
next	1.21;

1.21
date	2008.10.10.08.05.45;	author art;	state Exp;
branches;
next	1.20;

1.20
date	2008.10.09.08.43.43;	author art;	state Exp;
branches;
next	1.19;

1.19
date	2008.07.18.23.43.31;	author art;	state Exp;
branches;
next	1.18;

1.18
date	2007.08.14.15.18.07;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2007.05.29.21.09.43;	author robert;	state Exp;
branches;
next	1.16;

1.16
date	2007.05.14.07.07.09;	author art;	state Exp;
branches;
next	1.15;

1.15
date	2007.03.15.10.22.29;	author art;	state Exp;
branches;
next	1.14;

1.14
date	2007.02.11.21.59.32;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2006.12.24.20.30.35;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2006.01.17.20.30.12;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2005.12.21.20.36.02;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2005.12.20.19.23.57;	author drahn;	state Exp;
branches;
next	1.9;

1.9
date	2005.04.24.18.55.49;	author uwe;	state Exp;
branches;
next	1.8;

1.8
date	2005.04.19.15.14.11;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	2005.03.29.20.00.16;	author uwe;	state Exp;
branches;
next	1.6;

1.6
date	2005.03.03.22.55.00;	author uwe;	state Exp;
branches;
next	1.5;

1.5
date	2005.01.21.16.22.34;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2004.05.19.03.17.07;	author drahn;	state Exp;
branches;
next	1.3;

1.3
date	2004.02.26.04.58.38;	author drahn;	state Exp;
branches;
next	1.2;

1.2
date	2004.02.23.19.09.57;	author drahn;	state Exp;
branches;
next	1.1;

1.1
date	2004.02.01.05.09.49;	author drahn;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2004.02.19.10.48.02;	author niklas;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2004.06.05.23.10.45;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.45
log
@Fix the lidsuspend sysctl name in arm/include/cpu.h

From Markus Hennecke, thanks
@
text
@/*	$OpenBSD: cpu.h,v 1.44 2017/03/02 10:38:10 natano Exp $	*/
/*	$NetBSD: cpu.h,v 1.34 2003/06/23 11:01:08 martin Exp $	*/

/*
 * Copyright (c) 1994-1996 Mark Brinicombe.
 * Copyright (c) 1994 Brini.
 * All rights reserved.
 *
 * This code is derived from software written for Brini by Mark Brinicombe
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Brini.
 * 4. The name of the company nor the name of the author may be used to
 *    endorse or promote products derived from this software without specific
 *    prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY BRINI ``AS IS'' AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL BRINI OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * RiscBSD kernel project
 *
 * cpu.h
 *
 * CPU specific symbols
 *
 * Created      : 18/09/94
 *
 * Based on kate/katelib/arm6.h
 */

#ifndef _ARM_CPU_H_
#define _ARM_CPU_H_

/*
 * User-visible definitions
 */

/*  CTL_MACHDEP definitions. */
		/*		1	   formerly int: CPU_DEBUG */
		/*		2	   formerly string: CPU_BOOTED_DEVICE */
		/*		3	   formerly string: CPU_BOOTED_KERNEL */
#define	CPU_CONSDEV		4	/* struct: dev_t of our console */
#define	CPU_POWERSAVE		5	/* int: use CPU powersave mode */
#define	CPU_ALLOWAPERTURE	6	/* int: allow mmap of /dev/xf86 */
#define CPU_APMWARN		7	/* APM battery warning percentage */
		/*		8	   formerly int: keyboard reset */
		/*		9	   formerly int: CPU_ZTSRAWMODE */
		/*		10	   formerly struct: CPU_ZTSSCALE */
#define	CPU_MAXSPEED		11	/* int: number of valid machdep ids */
#define CPU_LIDSUSPEND		12	/* int: closing lid causes suspend */
#define CPU_LIDACTION		13	/* action caused by lid close */
#define	CPU_MAXID		14	/* number of valid machdep ids */

#define	CTL_MACHDEP_NAMES { \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ "console_device", CTLTYPE_STRUCT }, \
	{ "powersave", CTLTYPE_INT }, \
	{ "allowaperture", CTLTYPE_INT }, \
	{ "apmwarn", CTLTYPE_INT }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ "maxspeed", CTLTYPE_INT }, \
	{ "lidsuspend", CTLTYPE_INT }, \
	{ "lidaction", CTLTYPE_INT }, \
}

#ifdef _KERNEL

/*
 * Kernel-only definitions
 */

#include <arm/cpuconf.h>

#include <machine/intr.h>
#ifndef _LOCORE
#if 0
#include <sys/user.h>
#endif
#include <machine/frame.h>
#include <machine/pcb.h>
#endif	/* !_LOCORE */

#include <arm/armreg.h>

#ifndef _LOCORE
/* 1 == use cpu_sleep(), 0 == don't */
extern int cpu_do_powersave;
#endif

#ifdef _LOCORE
#define IRQdisable \
	stmfd	sp!, {r0} ; \
	mrs	r0, cpsr ; \
	orr	r0, r0, #(PSR_I) ; \
	msr	cpsr_c, r0 ; \
	ldmfd	sp!, {r0}

#define IRQenable \
	stmfd	sp!, {r0} ; \
	mrs	r0, cpsr ; \
	bic	r0, r0, #(PSR_I) ; \
	msr	cpsr_c, r0 ; \
	ldmfd	sp!, {r0}		

#else
#define IRQdisable __set_cpsr_c(PSR_I, PSR_I);
#define IRQenable __set_cpsr_c(PSR_I, 0);
#endif	/* _LOCORE */

#ifndef _LOCORE

/* All the CLKF_* macros take a struct clockframe * as an argument. */

/*
 * CLKF_USERMODE: Return TRUE/FALSE (1/0) depending on whether the
 * frame came from USR mode or not.
 */
#define CLKF_USERMODE(frame)	((frame->if_spsr & PSR_MODE) == PSR_USR32_MODE)

/*
 * CLKF_INTR: True if we took the interrupt from inside another
 * interrupt handler.
 */
#define CLKF_INTR(frame)	(curcpu()->ci_idepth > 1) 

/*
 * CLKF_PC: Extract the program counter from a clockframe
 */
#define CLKF_PC(frame)		(frame->if_pc)

/*
 * PROC_PC: Find out the program counter for the given process.
 */
#define PROC_PC(p)	((p)->p_addr->u_pcb.pcb_tf->tf_pc)
#define PROC_STACK(p)	((p)->p_addr->u_pcb.pcb_tf->tf_usr_sp)

/* The address of the vector page. */
extern vaddr_t vector_page;
void	arm32_vector_init(vaddr_t, int);

#define	ARM_VEC_RESET			(1 << 0)
#define	ARM_VEC_UNDEFINED		(1 << 1)
#define	ARM_VEC_SWI			(1 << 2)
#define	ARM_VEC_PREFETCH_ABORT		(1 << 3)
#define	ARM_VEC_DATA_ABORT		(1 << 4)
#define	ARM_VEC_ADDRESS_EXCEPTION	(1 << 5)
#define	ARM_VEC_IRQ			(1 << 6)
#define	ARM_VEC_FIQ			(1 << 7)

#define	ARM_NVEC			8
#define	ARM_VEC_ALL			0xffffffff

/*
 * Per-CPU information.  For now we assume one CPU.
 */

#include <sys/device.h>
#include <sys/sched.h>
struct cpu_info {
	struct device *ci_dev;		/* Device corresponding to this CPU */
	struct cpu_info *ci_next;
	struct schedstate_percpu ci_schedstate; /* scheduler state */

	struct proc *ci_curproc;
	u_int32_t ci_cpuid;
	u_int32_t ci_randseed;

	struct pcb *ci_curpcb;
	struct pcb *ci_idle_pcb;

	u_int32_t ci_arm_cpuid;		/* aggregate CPU id */
	u_int32_t ci_arm_cputype;	/* CPU type */
	u_int32_t ci_arm_cpurev;	/* CPU revision */
	u_int32_t ci_ctrl;		/* The CPU control register */

	uint32_t ci_cpl;
	uint32_t ci_ipending;
	uint32_t ci_idepth;
#ifdef DIAGNOSTIC
	int	ci_mutex_level;
#endif

#ifdef GPROF
	struct gmonparam *ci_gmon;
#endif
};

extern struct cpu_info cpu_info_primary;
extern struct cpu_info *cpu_info_list;

static inline struct cpu_info *
curcpu(void)
{
	struct cpu_info *__ci;
	__asm volatile("mrc	p15, 0, %0, c13, c0, 4" : "=r" (__ci));
	return (__ci);
}

#ifndef MULTIPROCESSOR
#define cpu_number()	0
#define CPU_IS_PRIMARY(ci)	1
#define CPU_INFO_ITERATOR	int
#define CPU_INFO_FOREACH(cii, ci) \
	for (cii = 0, ci = curcpu(); ci != NULL; ci = NULL)
#define CPU_INFO_UNIT(ci)	0
#define MAXCPUS	1
#define cpu_unidle(ci)
#else
#define cpu_number()		(curcpu()->ci_cpuid)
#define CPU_IS_PRIMARY(ci)	((ci) == &cpu_info_primary)
#define CPU_INFO_ITERATOR		int
#define CPU_INFO_FOREACH(cii, ci)	for (cii = 0, ci = cpu_info_list; \
					    ci != NULL; ci = ci->ci_next)

#define CPU_INFO_UNIT(ci)	((ci)->ci_dev ? (ci)->ci_dev->dv_unit : 0)
#define MAXCPUS	4
#define cpu_unidle(ci)

extern struct cpu_info *cpu_info[MAXCPUS];

void cpu_boot_secondary_processors(void);
#endif /* !MULTIPROCESSOR */

#define CPU_BUSY_CYCLE()	do {} while (0)

#define curpcb		curcpu()->ci_curpcb

/*
 * Scheduling glue
 */

extern int astpending;
#define setsoftast() (astpending = 1)

/*
 * Notify the current process (p) that it has a signal pending,
 * process as soon as possible.
 */

#define signotify(p)            setsoftast()

/*
 * Preempt the current process if in interrupt from user mode,
 * or after the current trap/syscall if in system mode.
 */
extern int want_resched;	/* resched() was called */
#define	need_resched(ci)	(want_resched = 1, setsoftast())
#define clear_resched(ci) 	want_resched = 0

/*
 * Give a profiling tick to the current process when the user profiling
 * buffer pages are invalid.  On the i386, request an ast to send us
 * through trap(), marking the proc as needing a profiling tick.
 */
#define	need_proftick(p)	setsoftast()

/*
 * cpu device glue (belongs in cpuvar.h)
 */

struct device;
void	cpu_attach(struct device *);
int	cpu_alloc_idle_pcb(struct cpu_info *);

/*
 * Random cruft
 */

/* cpuswitch.S */
struct pcb;
void	savectx		(struct pcb *pcb);

/* machdep.h */
void bootsync		(int);

/* fault.c */
int badaddr_read	(void *, size_t, void *);

/* syscall.c */
void swi_handler	(trapframe_t *);

/* machine_machdep.c */
void board_startup(void);

#endif	/* !_LOCORE */

#endif /* _KERNEL */

#endif /* !_ARM_CPU_H_ */

/* End of cpu.h */
@


1.44
log
@Add a new sysctl machdep.lidaction. The sysctl works as follows:

machdep.lidaction=0	# do nothing
machdep.lidaction=1	# suspend
machdep.lidaction=2	# hibernate

lidsuspend is just an alias for lidaction, so if you change one, the
other one will have the same value. The plan is to remove
machdep.lidsuspend eventually when people have upgraded their
/ets/sysctl.conf.

discussed with deraadt, who came up with the new MIB name
no objections mlarkin
ok stsp halex jcs
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.43 2017/01/06 00:06:02 jsg Exp $	*/
d85 2
a86 2
	{ "lidsuspend", CTLTYPE_INT } \
	{ "lidaction", CTLTYPE_INT } \
@


1.43
log
@unifdef CPU_ARMv7 and ARM_ARCH_7
ok kettenis@@ patrick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.42 2017/01/05 16:16:17 patrick Exp $	*/
d69 2
a70 1
#define	CPU_MAXID		13	/* number of valid machdep ids */
d86 1
@


1.42
log
@Complete idle PCB allocation for secondary processors so that it makes
sense and builds as part of an MP kernel.

ok kettenis@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.41 2016/04/04 09:13:44 patrick Exp $	*/
a211 1
#ifdef CPU_ARMv7
a218 3
#else
#define	curcpu()	(&cpu_info_primary)
#endif
@


1.41
log
@Store curcpu pointer in TPIDRPRW.

This will especially be helpful in future multiprocessor efforts.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.40 2016/01/31 00:14:50 jsg Exp $	*/
d190 1
d287 2
a288 2
void	cpu_attach	(struct device *);
int	cpu_alloc_idlepcb	(struct cpu_info *);
@


1.40
log
@Switch from PSR_X_bit and X32_bit PSR macro names to just PSR_X.
This matches FreeBSD and makes things a bit more consistent.
Discussed with Patrick.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.39 2014/07/11 10:53:07 uebayasi Exp $	*/
d211 12
a223 1
#define	curcpu()	(&cpu_info_primary)
@


1.39
log
@CPU_BUSY_CYCLE(): A new MI statement for busy loop power reduction

The new CPU_BUSY_CYCLE() may be put in a busy loop body so that CPU can reduce
power consumption, as Linux's cpu_relax() and FreeBSD's cpu_spinwait().  To
start minimally, use PAUSE on i386/amd64 and empty on others.  The name is
chosen following the existing cpu_idle_*() functions.  Naming and API may be
polished later.

OK kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d115 1
a115 1
	orr	r0, r0, #(I32_bit) ; \
d122 1
a122 1
	bic	r0, r0, #(I32_bit) ; \
d127 2
a128 2
#define IRQdisable __set_cpsr_c(I32_bit, I32_bit);
#define IRQenable __set_cpsr_c(I32_bit, 0);
@


1.38
log
@Store curpcb in cpu_info instead of a global variable, for SMP.

ok rapha@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.37 2013/09/12 11:42:22 patrick Exp $	*/
d236 2
@


1.37
log
@Rename cpu_info_store to cpu_info_primary.  Create an array of cpu_infos
for SMP, like on amd64.  Add some SMP defines.

ok rapha@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.36 2013/09/10 12:35:26 patrick Exp $	*/
d182 1
d186 4
a194 1
	u_int32_t ci_randseed;
d236 2
@


1.36
log
@Store the current interrupt depth in curcpu, so that it's per CPU
and not just a global variable.

ok rapha@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.35 2013/05/31 17:00:58 tedu Exp $	*/
d204 3
d208 1
a208 2
extern struct cpu_info cpu_info_store;
#define	curcpu()	(&cpu_info_store)
d217 15
a231 1
#endif
@


1.35
log
@remove counters for simplelocks
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.34 2013/03/12 09:37:16 mpi Exp $	*/
d145 1
a145 2
extern int current_intr_depth;
#define CLKF_INTR(frame)	(current_intr_depth > 1) 
d181 3
a185 5
	struct schedstate_percpu ci_schedstate; /* scheduler state */
#ifdef DIAGNOSTIC
	int	ci_mutex_level;
#endif
	struct device *ci_dev;		/* Device corresponding to this CPU */
d194 5
@


1.34
log
@Fix kernel profiling on MP systems by using per-CPU buffers and teach
kgmon(8) to deal with them, this time without public header changes.

Previously various CPUs were iterating over the same global buffer at
the same time to modify it and never ended.

This diff includes some ideas submited by Thor Simon to NetBSD via miod@@.

ok deraadt@@, mikeb@@, haesbaert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.33 2013/02/12 08:06:22 mpi Exp $	*/
a184 4
#if defined(DIAGNOSTIC) || defined(LOCKDEBUG)
	u_long ci_spin_locks;		/* # of spin locks held */
	u_long ci_simple_locks;		/* # of simple locks held */
#endif
@


1.33
log
@Back out per-CPU kernel profiling, it shouldn't modify a public header
at this moment.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.32 2013/02/11 17:05:25 mpi Exp $	*/
d201 3
@


1.32
log
@Fix kernel profiling on MP systems by using per-CPU buffer. Previously
various CPUs were iterating over the same global buffer at the same
time to modify it and never ended.

This diff includes some ideas submited by Thor Simon to NetBSD via miod@@.

ok mikeb@@, haesbaert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.31 2012/12/02 07:03:31 guenther Exp $	*/
a200 3
#ifdef GPROF
	struct gmonparam *ci_gmon;
#endif
@


1.31
log
@Determine whether we're currently on the alternative signal stack
dynamically, by comparing the stack pointer against the altstack
base and size, so that you get the correct answer if you longjmp
out of the signal handler, as tested by regress/sys/kern/stackjmp/.
Also, fix alt stack handling on vax, where it was completely broken.

Testing and corrections by miod@@, krw@@, tobiasu@@, pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.30 2011/11/16 20:50:18 deraadt Exp $	*/
d201 3
@


1.30
log
@Make userret() MI.  On architectures which jammed stuff into it in the
past, pull that code out seperately.
ok guenther miod
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.29 2011/10/24 22:49:07 drahn Exp $	*/
d157 1
@


1.29
log
@Introduce a pluggable interrupt controller infrastructure for beagle,
to allow panda to share the port.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.28 2011/09/20 22:02:13 miod Exp $	*/
a258 3

/* ast.c */
void userret		(struct proc *p);
@


1.28
log
@Late spring cleaning of the arm code for old dusty bits we do not want to
keep:
- remove bootconfig parameter passing feature (unused).
- unifdef __PROG32 and remove all remains of arm26 code.
- remove ARMFPE support (unused).
- remove support for ARM2, ARM2AS, ARM3, ARM6, ARM7, ARM7TDMI and StrongARM
  processor families, and the related silicon bug workarounds (especially
  the SA-110 STM^ bug).
- remove cpu_functions no longer necessary after previous removals.
- remove ARM32_DISABLE_ALIGNMENT_FAULTS option (unused).
- make FIQ support conditional on option FIQ (unused, but may be eventually).

Discussed with drahn@@ and jasper@@ long ago, I was sitting on this commit for
no good reason.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.27 2011/06/24 19:47:48 naddy Exp $	*/
d197 3
@


1.27
log
@machdep.kbdreset enables a shutdown by Ctrl-Alt-Del on amd64 and
i386.  Stop abusing it on other archs for controling a shutdown by
pressing the soft power button:

* Add a MI sysctl hw.allowpowerdown; if set to 1 (the default) it
  allows a power button shutdown.
* Make acpi(4)/acpibtn(4) honor hw.allowpowerdown.
* Switch the various power button intercepts on landisk, sgi, sparc64
  and zaurus over to hw.allowpowerdown.
* Garbage collect the machdep.kbdreset sysctl on all archs other than
  amd64 and i386.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.26 2010/11/28 20:44:20 miod Exp $	*/
a110 1
#ifdef __PROG32
a129 1
#endif
a138 1
#ifdef __PROG32
a139 3
#else
#define CLKF_USERMODE(frame)	((frame->if_r15 & R15_MODE) == R15_MODE_USR)
#endif
a145 6
#ifdef __PROG32
/* Hack to treat FPE time as interrupt time so we can measure it */
#define CLKF_INTR(frame)						\
	((current_intr_depth > 1) ||					\
	    (frame->if_spsr & PSR_MODE) == PSR_UND32_MODE)
#else
a146 1
#endif
a150 1
#ifdef __PROG32
a151 3
#else
#define CLKF_PC(frame)		(frame->if_r15 & R15_PC)
#endif
a155 1
#ifdef __PROG32
a156 3
#else
#define PROC_PC(p)	((p)->p_addr->u_pcb.pcb_tf->tf_r15 & R15_PC)
#endif
a159 1
#ifdef __PROG32
a172 1
#endif
a195 3
#ifdef MULTIPROCESSOR
	MP_CPU_INFO_MEMBERS
#endif
a211 6
#ifdef __PROG32
void	cpu_proc_fork(struct proc *, struct proc *);
#else
#define	cpu_proc_fork(p1, p2)
#endif

a240 1
#ifndef acorn26
a247 2
#endif

a251 4

/* locore.S */
void atomic_set_bit	(u_int *address, u_int setmask);
void atomic_clear_bit	(u_int *address, u_int clearmask);
@


1.26
log
@Get rid of machdep.debug, machdep.booted_device and machdep.booted_kernel
sysctl. Only the first one is really implemented, and it only matters on
older processor flavours we don't run on (and don't want to), so this was
just dead weight.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.25 2010/09/28 20:27:54 miod Exp $	*/
d64 1
a64 1
#define CPU_KBDRESET		8	/* int: console keyboard reset */
d80 1
a80 1
	{ "kbdreset", CTLTYPE_INT }, \
@


1.25
log
@Implement a per-cpu held mutex counter if DIAGNOSTIC on all non-x86 platforms,
to complete matthew@@'s commit of a few days ago, and drop __HAVE_CPU_MUTEX_LEVEL
define. With help from, and ok deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.24 2009/03/26 17:24:33 oga Exp $	*/
d57 3
a59 3
#define	CPU_DEBUG		1	/* int: misc kernel debug control */
#define	CPU_BOOTED_DEVICE	2	/* string: device we booted from */
#define	CPU_BOOTED_KERNEL	3	/* string: kernel we booted */
d73 3
a75 3
	{ "debug", CTLTYPE_INT }, \
	{ "booted_device", CTLTYPE_STRING }, \
	{ "booted_kernel", CTLTYPE_STRING }, \
@


1.24
log
@Remove cpu_wait(). It's original use was to be called from the reaper so
MD code would free resources that couldn't be freed until we were no
longer running in that processor. However, it's is unused on all
architectures since mikeb@@'s tss changes on x86 earlier in the year.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.23 2008/10/15 23:23:46 deraadt Exp $	*/
d210 3
@


1.23
log
@make random(9) return per-cpu values (by saving the seed in the cpuinfo),
which are uniform for the profclock on each cpu in a SMP system (but using
a different seed for each cpu).  on all cpus, avoid seeding with a value out
of the [0, 2^31-1] range (since that is not stable)
ok kettenis drahn
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.22 2008/10/10 08:36:28 art Exp $	*/
a253 2

#define cpu_wait(p)    /* nothing */
@


1.22
log
@Add empty cpu_unidle() macros for architectures that currently don't do
anything special to prod a cpu to leave the idle loop in signotify.
powerpc, i386, amd64 and sparc64 will follow soon so that everyone has
the same interface to wake an idling cpu.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.21 2008/10/10 08:05:45 art Exp $	*/
d219 1
@


1.21
log
@Define MAXCPUS on all architectures.
For now, sparc64 is arbitrarily set to 256 (only architecture that didn't have
a practical limit in the code on the number of cpus).
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.20 2008/10/09 08:43:43 art Exp $	*/
d231 1
@


1.20
log
@Implement CPU_INFO_UNIT for everyone, not just MP kernels.
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.19 2008/07/18 23:43:31 art Exp $	*/
d230 1
@


1.19
log
@Add a macro that clears the want_resched flag that need_resched sets.
Right now when mi_switch picks up the same proc, we didn't clear the
flag which would mean that every time we service an AST we would attempt
a context switch. For some architectures, amd64 being probably the
most extreme, that meant attempting to context switch for every
trap and interrupt.

Now we clear_resched explicitly after every context switch, even if it
didn't do anything. Which also allows us to remove some more code
in cpu_switchto (not done yet).

miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.18 2007/08/14 15:18:07 deraadt Exp $	*/
d229 1
@


1.18
log
@removal of zts sysctls created a numeric gap.  repair.  ok miod robert
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.17 2007/05/29 21:09:43 robert Exp $	*/
d259 1
@


1.17
log
@Make use of struct wsmouse_calibcoords and add ioctl support
for getting and passing calibration values instead of using
sysctl.
Move the scale struct to uts_softc so that each device can have
it's own values instead of using the global one.
Remove the two MD sysctl (ztsscale and ztsrawmode).

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.16 2007/05/14 07:07:09 art Exp $	*/
d65 2
d81 2
d85 1
a85 1
}    
@


1.16
log
@Switch arm to __HAVE_CPUINFO. Least effort.

deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.15 2007/03/15 10:22:29 art Exp $	*/
a64 2
#define CPU_ZTSRAWMODE		9	/* int: zts returns unscaled x/y */
#define CPU_ZTSSCALE		10	/* struct: zts scaling parameters */
a78 2
	{ "ztsrawmode", CTLTYPE_INT }, \
	{ "ztsscale", CTLTYPE_STRUCT }, \
@


1.15
log
@Since p_flag is often manipulated in interrupts and without biglock
it's a good idea to use atomic.h operations on it. This mechanic
change updates all bit operations on p_flag to atomic_{set,clear}bits_int.

Only exception is that P_OWEUPC is set by MI code before calling
need_proftick and it's automatically cleared by ADDUPC. There's
no reason for MD handling of that flag since everyone handles it the
same way.

kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.14 2007/02/11 21:59:32 miod Exp $	*/
a201 1
/*
a202 1
*/
d204 2
a205 1
#if 0 
a206 1
#endif
d225 4
@


1.14
log
@Remove now unused evcnt field from struct cpu_info.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.13 2006/12/24 20:30:35 miod Exp $	*/
d263 1
a263 1
#define	need_proftick(p)	((p)->p_flag |= P_OWEUPC, setsoftast())
@


1.13
log
@Define PROC_PC. Then, since profiling information is being reported in
statclock(), do not bother doing this in userret() anymore. As a result,
userret() does not need its pc and ticks arguments, simplify.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.12 2006/01/17 20:30:12 miod Exp $	*/
a217 1
	struct evcnt ci_arm700bugcount;
@


1.12
log
@Upon halt, invoke resettodr() on arm platforms, unless we have been sitting
in DDB; tested at least by aanriot@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.11 2005/12/21 20:36:02 deraadt Exp $	*/
d290 1
a290 1
void userret (register struct proc *p, u_int32_t pc, quad_t ticks);
@


1.11
log
@sysctl machdep.lidsuspend=1 makes screen closures to cause a suspend.
(opening the screen does not yet wake the machine up, not yet sure if
that is even possible yet)
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.10 2005/12/20 19:23:57 drahn Exp $	*/
d293 1
a293 1
void bootsync		(void);
@


1.10
log
@Add machdep.maxspeed sysctl to change the meaning of hw.setperf=100 on zaurus,
This will scale the speed for hw.setperf, this allows limiting apm -A
to lower speed, or even overclocking. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.9 2005/04/24 18:55:49 uwe Exp $	*/
d67 3
a69 2
#define	CPU_MAXSPEED		11	/* number of valid machdep ids */
#define	CPU_MAXID		12	/* number of valid machdep ids */
d83 2
a84 1
	{ "maxspeed", CTLTYPE_INT } \
@


1.9
log
@Do down-sampling of the high-resolution touch pad events in kernel,
and provide sysctls for fine-tuning the touch pad area that covers the
screen.  Reasonable defaults are provided, but each machine can be a
bit different due to the manufacturing process.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.8 2005/04/19 15:14:11 mickey Exp $	*/
d67 2
a68 1
#define	CPU_MAXID		11	/* number of valid machdep ids */
d82 1
@


1.8
log
@CLKF_BASEPRI we do not have no more; noticed by miod
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.7 2005/03/29 20:00:16 uwe Exp $	*/
d65 3
a67 1
#define	CPU_MAXID		9	/* number of valid machdep ids */
d79 2
@


1.7
log
@- Support the machdep.kbdreset sysctl on zaurus.
- Disable unused function parse_mi_bootargs().
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.6 2005/03/03 22:55:00 uwe Exp $	*/
a137 9

/*
 * CLKF_BASEPRI: True if we were at spl0 before the interrupt.
 *
 * This is hard-wired to 0 on the ARM, since spllowersoftclock() might
 * not actually be able to unblock the interrupt, which would cause us
 * to run the softclock interrupts with hardclock blocked.
 */
#define CLKF_BASEPRI(frame)	0
@


1.6
log
@Support APM_IOC_PRN_CTL, and machdep.apmwarn as documented in apm(4), and
apmd(8); missing sysctl variable noticed by drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.5 2005/01/21 16:22:34 miod Exp $	*/
d64 2
a65 1
#define	CPU_MAXID		8	/* number of valid machdep ids */
d76 1
@


1.5
log
@Overhaul of the pxa2x0_lcd code, to allow early (before autoconf) attachment,
and collateral changes.

Because this driver requires us_dma (and as such, vm services) to work, it
can not be selected in consinit(). Instead, add a hook to the arm
cpu_startup() which will, on zaurus, switch console from serial (selected
in consinit()) to lcd.

This also makes the zaurus-specific early pxa2x0_clkman() substitute code
cleaner.

While there, move boot -c handling later, after the glass console is set up.

Tested by drahn@@ and uwe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.4 2004/05/19 03:17:07 drahn Exp $	*/
d63 2
a64 1
#define	CPU_MAXID		7	/* number of valid machdep ids */
d74 1
@


1.4
log
@de __P of sys/arch/arm.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.3 2004/02/26 04:58:38 drahn Exp $	*/
d297 3
@


1.3
log
@add APERTURE support.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.2 2004/02/23 19:09:57 drahn Exp $	*/
d269 2
a270 2
void	cpu_attach	__P((struct device *));
int	cpu_alloc_idlepcb	__P((struct cpu_info *));
d279 2
a280 2
void atomic_set_bit	__P((u_int *address, u_int setmask));
void atomic_clear_bit	__P((u_int *address, u_int clearmask));
d284 1
a284 1
void	savectx		__P((struct pcb *pcb));
d290 1
a290 1
void bootsync		__P((void));
d293 1
a293 1
int badaddr_read	__P((void *, size_t, void *));
d296 1
a296 1
void swi_handler	__P((trapframe_t *));
@


1.2
log
@Switch to the 3 arg version of userret to more closely match other OpenBSD
architectures.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.1 2004/02/01 05:09:49 drahn Exp $	*/
d62 2
a63 1
#define	CPU_MAXID		6	/* number of valid machdep ids */
d72 1
@


1.1
log
@Arm port, NetBSD codebase stripped down, 32bit only support.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.3 2004/01/29 16:17:16 drahn Exp $	*/
d285 1
a285 1
void userret		__P((register struct proc *p));
@


1.1.2.1
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.1.2.2
log
@Merge with the trunk
@
text
@d62 1
a62 2
#define	CPU_ALLOWAPERTURE	6	/* int: allow mmap of /dev/xf86 */
#define	CPU_MAXID		7	/* number of valid machdep ids */
a70 1
	{ "allowaperture", CTLTYPE_INT }, \
d267 2
a268 2
void	cpu_attach	(struct device *);
int	cpu_alloc_idlepcb	(struct cpu_info *);
d277 2
a278 2
void atomic_set_bit	(u_int *address, u_int setmask);
void atomic_clear_bit	(u_int *address, u_int clearmask);
d282 1
a282 1
void	savectx		(struct pcb *pcb);
d285 1
a285 1
void userret (register struct proc *p, u_int32_t pc, quad_t ticks);
d288 1
a288 1
void bootsync		(void);
d291 1
a291 1
int badaddr_read	(void *, size_t, void *);
d294 1
a294 1
void swi_handler	(trapframe_t *);
@


