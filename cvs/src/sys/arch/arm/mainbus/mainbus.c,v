head	1.19;
access;
symbols
	OPENBSD_6_2:1.19.0.4
	OPENBSD_6_2_BASE:1.19
	OPENBSD_6_1:1.15.0.4
	OPENBSD_6_1_BASE:1.15
	OPENBSD_6_0:1.11.0.2
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.7.0.10
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.7.0.12
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.4
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.8
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.6
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.2
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.6.0.6
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.4
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	OPENBSD_5_0:1.5.0.4
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.4.0.2
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.16
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.18
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.14
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.12
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.3.0.10
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.3.0.8
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.6
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.3.0.4
	OPENBSD_4_0_BASE:1.3
	OPENBSD_3_9:1.3.0.2
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.2.0.6
	OPENBSD_3_8_BASE:1.2
	OPENBSD_3_7:1.2.0.4
	OPENBSD_3_7_BASE:1.2
	OPENBSD_3_6:1.2.0.2
	OPENBSD_3_6_BASE:1.2
	SMP_SYNC_A:1.2
	SMP_SYNC_B:1.2
	OPENBSD_3_5:1.1.0.4
	OPENBSD_3_5_BASE:1.1
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.19
date	2017.09.11.05.38.51;	author jsg;	state Exp;
branches;
next	1.18;
commitid	nTtgPvIpYNFAhbEw;

1.18
date	2017.05.02.14.45.26;	author kettenis;	state Exp;
branches;
next	1.17;
commitid	LJtXiPROkSuTMJKZ;

1.17
date	2017.04.30.22.35.33;	author kettenis;	state Exp;
branches;
next	1.16;
commitid	CTSmGvt4613QBnGZ;

1.16
date	2017.04.27.22.41.46;	author kettenis;	state Exp;
branches;
next	1.15;
commitid	rgPwijkvyGZe1DHZ;

1.15
date	2017.01.06.00.06.02;	author jsg;	state Exp;
branches;
next	1.14;
commitid	YCbIRye8xzoWl68V;

1.14
date	2017.01.03.19.57.01;	author kettenis;	state Exp;
branches;
next	1.13;
commitid	fs9AbY79UEfLzZyj;

1.13
date	2016.08.06.00.04.39;	author jsg;	state Exp;
branches;
next	1.12;
commitid	tVjajZAHcIrcv5vL;

1.12
date	2016.08.04.12.17.36;	author kettenis;	state Exp;
branches;
next	1.11;
commitid	AWZg9QZdbT4sIbJP;

1.11
date	2016.07.13.20.42.44;	author patrick;	state Exp;
branches;
next	1.10;
commitid	nKlQOlxpchcfALtZ;

1.10
date	2016.05.29.11.03.34;	author jsg;	state Exp;
branches;
next	1.9;
commitid	kYMWcILjTKZ7cKch;

1.9
date	2016.05.18.22.55.23;	author kettenis;	state Exp;
branches;
next	1.8;
commitid	3F9JV9gcDaM81aVG;

1.8
date	2016.05.02.08.15.55;	author patrick;	state Exp;
branches;
next	1.7;
commitid	SxPSz6lxaCE62Tnc;

1.7
date	2013.05.30.16.15.01;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2011.09.22.17.45.59;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2010.08.30.21.35.57;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2010.04.27.16.43.23;	author drahn;	state Exp;
branches;
next	1.3;

1.3
date	2005.12.31.23.03.58;	author drahn;	state Exp;
branches;
next	1.2;

1.2
date	2004.05.19.03.17.07;	author drahn;	state Exp;
branches;
next	1.1;

1.1
date	2004.02.01.05.09.49;	author drahn;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2004.02.19.10.48.02;	author niklas;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2004.06.05.23.10.45;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.19
log
@Remove whitespace in inline assembly output constraint strings.  While
gcc is documented as ignoring whitespace in any position but the first
clang gives "error: invalid output constraint '=r ' in asm".
@
text
@/* $OpenBSD: mainbus.c,v 1.18 2017/05/02 14:45:26 kettenis Exp $ */
/*
 * Copyright (c) 2016 Patrick Wildt <patrick@@blueri.se>
 * Copyright (c) 2017 Mark Kettenis <kettenis@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/malloc.h>

#include <dev/ofw/openfirm.h>
#include <dev/ofw/fdt.h>

#include <arm/mainbus/mainbus.h>

int mainbus_match(struct device *, void *, void *);
void mainbus_attach(struct device *, struct device *, void *);

void mainbus_attach_node(struct device *, int, cfmatch_t);
int mainbus_match_status(struct device *, void *, void *);
void mainbus_attach_cpus(struct device *, cfmatch_t);
int mainbus_match_primary(struct device *, void *, void *);
int mainbus_match_secondary(struct device *, void *, void *);
void mainbus_attach_framebuffer(struct device *);

struct mainbus_softc {
	struct device		 sc_dev;
	int			 sc_node;
	bus_space_tag_t		 sc_iot;
	bus_dma_tag_t		 sc_dmat;
	int			 sc_acells;
	int			 sc_scells;
	int			*sc_ranges;
	int			 sc_rangeslen;
	int			 sc_early;
};

struct cfattach mainbus_ca = {
	sizeof(struct mainbus_softc), mainbus_match, mainbus_attach, NULL,
	config_activate_children
};

struct cfdriver mainbus_cd = {
	NULL, "mainbus", DV_DULL
};

struct arm32_bus_dma_tag mainbus_dma_tag = {
	0,
	0,
	NULL,
	_bus_dmamap_create,
	_bus_dmamap_destroy,
	_bus_dmamap_load,
	_bus_dmamap_load_mbuf,
	_bus_dmamap_load_uio,
	_bus_dmamap_load_raw,
	_bus_dmamap_unload,
	_bus_dmamap_sync,
	_bus_dmamem_alloc,
	_bus_dmamem_free,
	_bus_dmamem_map,
	_bus_dmamem_unmap,
	_bus_dmamem_mmap,
};

/*
 * Mainbus takes care of FDT and non-FDT machines, so we
 * always attach.
 */
int
mainbus_match(struct device *parent, void *cfdata, void *aux)
{
	return (1);
}

extern char *hw_prod;
extern struct bus_space armv7_bs_tag;
void platform_init_mainbus(struct device *);

void
mainbus_attach(struct device *parent, struct device *self, void *aux)
{
	struct mainbus_softc *sc = (struct mainbus_softc *)self;
	char model[128];
	int node, len;

	arm_intr_init_fdt();

	sc->sc_node = OF_peer(0);
	sc->sc_iot = &armv7_bs_tag;
	sc->sc_dmat = &mainbus_dma_tag;
	sc->sc_acells = OF_getpropint(OF_peer(0), "#address-cells", 1);
	sc->sc_scells = OF_getpropint(OF_peer(0), "#size-cells", 1);

	len = OF_getprop(sc->sc_node, "model", model, sizeof(model));
	if (len > 0) {
		printf(": %s\n", model);
		hw_prod = malloc(len, M_DEVBUF, M_NOWAIT);
		if (hw_prod)
			strlcpy(hw_prod, model, len);
	} else
		printf(": unknown model\n");

	/* Attach primary CPU first. */
	mainbus_attach_cpus(self, mainbus_match_primary);

	platform_init_mainbus(self);

	sc->sc_rangeslen = OF_getproplen(OF_peer(0), "ranges");
	if (sc->sc_rangeslen > 0 && !(sc->sc_rangeslen % sizeof(uint32_t))) {
		sc->sc_ranges = malloc(sc->sc_rangeslen, M_TEMP, M_WAITOK);
		OF_getpropintarray(OF_peer(0), "ranges", sc->sc_ranges,
		    sc->sc_rangeslen);
	}

	/* Scan the whole tree. */
	sc->sc_early = 1;
	for (node = OF_child(sc->sc_node); node != 0; node = OF_peer(node))
		mainbus_attach_node(self, node, NULL);

	sc->sc_early = 0;
	for (node = OF_child(sc->sc_node); node != 0; node = OF_peer(node))
		mainbus_attach_node(self, node, NULL);
	
	mainbus_attach_framebuffer(self);

	/* Attach secondary CPUs. */
	mainbus_attach_cpus(self, mainbus_match_secondary);
}

/*
 * Look for a driver that wants to be attached to this node.
 */
void
mainbus_attach_node(struct device *self, int node, cfmatch_t submatch)
{
	struct mainbus_softc	*sc = (struct mainbus_softc *)self;
	struct fdt_attach_args	 fa;
	int			 i, len, line;
	uint32_t		*cell, *reg;

	memset(&fa, 0, sizeof(fa));
	fa.fa_name = "";
	fa.fa_node = node;
	fa.fa_iot = sc->sc_iot;
	fa.fa_dmat = sc->sc_dmat;
	fa.fa_acells = sc->sc_acells;
	fa.fa_scells = sc->sc_scells;

	len = OF_getproplen(node, "reg");
	line = (sc->sc_acells + sc->sc_scells) * sizeof(uint32_t);
	if (len > 0 && (len % line) == 0) {
		reg = malloc(len, M_TEMP, M_WAITOK);
		OF_getpropintarray(node, "reg", reg, len);

		fa.fa_reg = malloc((len / line) * sizeof(struct fdt_reg),
		    M_DEVBUF, M_WAITOK);
		fa.fa_nreg = (len / line);

		for (i = 0, cell = reg; i < len / line; i++) {
			if (sc->sc_acells >= 1)
				fa.fa_reg[i].addr = cell[0];
			if (sc->sc_acells == 2) {
				fa.fa_reg[i].addr <<= 32;
				fa.fa_reg[i].addr |= cell[1];
			}
			cell += sc->sc_acells;
			if (sc->sc_scells >= 1)
				fa.fa_reg[i].size = cell[0];
			if (sc->sc_scells == 2) {
				fa.fa_reg[i].size <<= 32;
				fa.fa_reg[i].size |= cell[1];
			}
			cell += sc->sc_scells;
		}

		free(reg, M_TEMP, len);
	}

	len = OF_getproplen(node, "interrupts");
	if (len > 0 && (len % sizeof(uint32_t)) == 0) {
		fa.fa_intr = malloc(len, M_DEVBUF, M_WAITOK);
		fa.fa_nintr = len / sizeof(uint32_t);

		OF_getpropintarray(node, "interrupts", fa.fa_intr, len);
	}

	if (submatch == NULL)
		submatch = mainbus_match_status;
	config_found_sm(self, &fa, NULL, submatch);

	free(fa.fa_reg, M_DEVBUF, fa.fa_nreg * sizeof(struct fdt_reg));
	free(fa.fa_intr, M_DEVBUF, fa.fa_nintr * sizeof(uint32_t));
}

int
mainbus_match_status(struct device *parent, void *match, void *aux)
{
	struct mainbus_softc *sc = (struct mainbus_softc *)parent;
	struct fdt_attach_args *fa = aux;
	struct cfdata *cf = match;
	char buf[32];

	if (OF_getprop(fa->fa_node, "status", buf, sizeof(buf)) > 0 &&
	    strcmp(buf, "disabled") == 0)
		return 0;

	if (cf->cf_loc[0] == sc->sc_early)
		return (*cf->cf_attach->ca_match)(parent, match, aux);
	return 0;
}

void
mainbus_attach_cpus(struct device *self, cfmatch_t match)
{
	struct mainbus_softc *sc = (struct mainbus_softc *)self;
	int node = OF_finddevice("/cpus");
	int acells, scells;

	if (node == 0)
		return;

	acells = sc->sc_acells;
	scells = sc->sc_scells;
	sc->sc_acells = OF_getpropint(node, "#address-cells", 1);
	sc->sc_scells = OF_getpropint(node, "#size-cells", 0);

	for (node = OF_child(node); node != 0; node = OF_peer(node))
		mainbus_attach_node(self, node, match);

	sc->sc_acells = acells;
	sc->sc_scells = scells;
}

int
mainbus_match_primary(struct device *parent, void *match, void *aux)
{
	struct fdt_attach_args *fa = aux;
	struct cfdata *cf = match;
	uint32_t mpidr;

	__asm volatile("mrc p15, 0, %0, c0, c0, 5" : "=r" (mpidr));

	if (fa->fa_nreg < 1 || fa->fa_reg[0].addr != (mpidr & MPIDR_AFF))
		return 0;

	return (*cf->cf_attach->ca_match)(parent, match, aux);
}

int
mainbus_match_secondary(struct device *parent, void *match, void *aux)
{
	struct fdt_attach_args *fa = aux;
	struct cfdata *cf = match;
	uint32_t mpidr;

	__asm volatile("mrc p15, 0, %0, c0, c0, 5" : "=r" (mpidr));

	if (fa->fa_nreg < 1 || fa->fa_reg[0].addr == (mpidr & MPIDR_AFF))
		return 0;

	return (*cf->cf_attach->ca_match)(parent, match, aux);
}

void
mainbus_attach_framebuffer(struct device *self)
{
	int node = OF_finddevice("/chosen");

	if (node == 0)
		return;

	for (node = OF_child(node); node != 0; node = OF_peer(node))
		mainbus_attach_node(self, node, NULL);
}

/*
 * Legacy support for SoCs that do not fully use FDT.
 */
void
mainbus_legacy_found(struct device *self, char *name)
{
	union mainbus_attach_args ma;

	memset(&ma, 0, sizeof(ma));
	ma.ma_name = name;

	config_found(self, &ma, NULL);
}
@


1.18
log
@Remove check for compatible property.  Turns out sunxi relied on the broken
check we had before rev 1.16.

Suggested by jmatthew@@
@
text
@d1 1
a1 1
/* $OpenBSD: mainbus.c,v 1.17 2017/04/30 22:35:33 kettenis Exp $ */
d256 1
a256 1
	__asm volatile("mrc p15, 0, %0, c0, c0, 5" : "=r " (mpidr));
d271 1
a271 1
	__asm volatile("mrc p15, 0, %0, c0, c0, 5" : "=r " (mpidr));
@


1.17
log
@Make early attrbute work here as well.  Remove unreachable panic while there.

ok visa@@, patrick@@, drahn@@
@
text
@d1 1
a1 1
/* $OpenBSD: mainbus.c,v 1.16 2017/04/27 22:41:46 kettenis Exp $ */
a154 3

	if (OF_getproplen(node, "compatible") <= 0)
		return;
@


1.16
log
@Bring over the changes to mainbus(4) and simplebus(4) from arm64.
@
text
@d1 1
a1 1
/* $OpenBSD: mainbus.c,v 1.15 2017/01/06 00:06:02 jsg Exp $ */
d42 1
d49 1
a100 3
	if ((node = OF_peer(0)) == 0)
		panic("mainbus: no device tree");

d103 1
d109 2
a110 1
	if ((len = OF_getprop(node, "model", model, sizeof(model))) > 0) {
d131 2
a132 1
	for (node = OF_child(node); node != 0; node = OF_peer(node))
d135 4
d216 1
d225 3
a227 1
	return (*cf->cf_attach->ca_match)(parent, match, aux);
@


1.15
log
@unifdef CPU_ARMv7 and ARM_ARCH_7
ok kettenis@@ patrick@@
@
text
@d1 1
a1 1
/* $OpenBSD: mainbus.c,v 1.14 2017/01/03 19:57:01 kettenis Exp $ */
d4 1
d33 5
a37 1
void mainbus_attach_node(struct device *, int);
a39 2
int mainbus_legacy_search(struct device *, void *, void *);

d96 1
a96 1
	char buffer[128];
d99 2
a100 5
	if ((node = OF_peer(0)) == 0) {
		printf(": no device tree\n");
		config_search(mainbus_legacy_search, self, aux);
		return;
	}
d109 2
a110 2
	if ((len = OF_getprop(node, "model", buffer, sizeof(buffer))) > 0) {
		printf(": %s\n", buffer);
d113 1
a113 1
			strlcpy(hw_prod, buffer, len);
d117 3
a119 2
	/* Attach CPU first. */
	mainbus_legacy_found(self, "cpu");
a121 2
	/* TODO: Scan for interrupt controllers and attach them first? */

d131 1
a131 1
		mainbus_attach_node(self, node);
d134 3
d143 1
a143 1
mainbus_attach_node(struct device *self, int node)
a146 1
	char			 buffer[128];
d150 1
a150 1
	if (!OF_getprop(node, "compatible", buffer, sizeof(buffer)))
a152 4
	if (OF_getprop(node, "status", buffer, sizeof(buffer)))
		if (!strcmp(buffer, "disabled"))
			return;

d199 3
a201 3
	/* TODO: attach the device's clocks first? */

	config_found(self, &fa, NULL);
d207 14
d222 1
a222 1
mainbus_attach_framebuffer(struct device *self)
d224 3
a226 1
	int node = OF_finddevice("/chosen");
d231 5
d237 19
a255 1
		mainbus_attach_node(self, node);
a257 3
/*
 * Legacy support for SoCs that do not use FDT.
 */
d259 1
a259 1
mainbus_legacy_search(struct device *parent, void *match, void *aux)
d261 3
a263 2
	union mainbus_attach_args ma;
	struct cfdata		*cf = match;
d265 1
a265 2
	memset(&ma, 0, sizeof(ma));
	ma.ma_name = cf->cf_driver->cd_name;
d267 1
a267 2
	/* allow for devices to be disabled in UKC */
	if ((*cf->cf_attach->ca_match)(parent, cf, &ma) == 0)
d270 1
a270 2
	config_attach(parent, cf, &ma, NULL);
	return 1;
d273 15
@


1.14
log
@Add simplefb(4), a driver to support the framebuffer set up by the firmware
on some platforms that use device trees.  Works on Allwinner (sunxi) and
should also work on Raspberry Pi (broadcom) armv7 platforms.

ok jsg@@, visa@@
@
text
@d1 1
a1 1
/* $OpenBSD: mainbus.c,v 1.13 2016/08/06 00:04:39 jsg Exp $ */
d86 2
a101 1
#ifdef CPU_ARMv7
a102 1
#endif
a103 2
#ifdef CPU_ARMv7
	extern struct bus_space armv7_bs_tag;
a104 1
#endif
a118 2
#ifdef CPU_ARMv7
	extern void platform_init_mainbus(struct device *);
a119 1
#endif
@


1.13
log
@Set up the fdt attach args for devices that attach directly to mainbus
the same way as for those that attach to simplebus.

ok kettenis@@ patrick@@
@
text
@d1 1
a1 1
/* $OpenBSD: mainbus.c,v 1.12 2016/08/04 12:17:36 kettenis Exp $ */
d33 1
d137 1
a137 4
	for (node = OF_child(node);
	    node != 0;
	    node = OF_peer(node))
	{
d139 2
a140 1
	}
d214 12
@


1.12
log
@Add support for pre-registering interrupts.  This allows device drivers to
establish interrupts before their interrupt controller attaches, solving
dependency problems in various device trees.

Also add support for handing interrupt handlers over to parent interrupt
controllers.

ok jsg@@ patrick@@ (on an earlier diff)
@
text
@d1 1
a1 1
/* $OpenBSD: mainbus.c,v 1.11 2016/07/13 20:42:44 patrick Exp $ */
d25 1
d42 2
d128 7
d153 2
d171 38
d212 3
@


1.11
log
@The "#address-cells" and "#size-cells" properties define the size
of the memory address and length information.  The root node passes
this information down to the children and it can be overwritten by
other nodes inbetween.  Pass these properties as part of the fdt
attach args, so that we can grab that information quickly inside
the drivers.

ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: mainbus.c,v 1.10 2016/05/29 11:03:34 jsg Exp $ */
d95 4
@


1.10
log
@use fdt "model" string for hw.product
ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: mainbus.c,v 1.9 2016/05/18 22:55:23 kettenis Exp $ */
d39 2
d101 2
d152 2
@


1.9
log
@Introduce a per-platform init_mainbus() hook that can be used to attach
platform-specific devices to mainbus before we start walking the FDT.

ok patrick@@
@
text
@d1 1
a1 1
/* $OpenBSD: mainbus.c,v 1.8 2016/05/02 08:15:55 patrick Exp $ */
d22 1
d79 2
d86 1
a86 1
	int node;
d100 1
a100 1
	if (OF_getprop(node, "model", buffer, sizeof(buffer)))
d102 4
a105 1
	else
@


1.8
log
@Rework mainbus and implement simplebus to be able to span a tree-like
topology based on device tree information.  Introduce a common attach
args structure to be used for all fdt-capable bus devices.

ok jsg@@ kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a32 1
void mainbus_legacy_found(struct device *, char *);
d104 4
@


1.7
log
@Enforce ca_activate tree-walks over the entire heirarchy for all events,
cleaning up some shutdown-hook related code on the way.
(A few drivers related to sparc are still skipped at kettenis' request)
ok kettenis mlarkin, tested by many others too
@
text
@d1 1
a1 3
/*	$OpenBSD: mainbus.c,v 1.6 2011/09/22 17:45:59 miod Exp $	*/
/* $NetBSD: mainbus.c,v 1.3 2001/06/13 17:52:43 nathanw Exp $ */

d3 1
a3 32
 * Copyright (c) 1994,1995 Mark Brinicombe.
 * Copyright (c) 1994 Brini.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Brini.
 * 4. The name of the company nor the name of the author may be used to
 *    endorse or promote products derived from this software without specific
 *    prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY BRINI ``AS IS'' AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL BRINI OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * RiscBSD kernel project
d5 11
a15 5
 * mainbus.c
 *
 * mainbus configuration
 *
 * Created      : 15/12/94
d23 2
d27 2
a28 1
/* Prototypes for functions provided */
d30 1
a30 4
int  mainbusmatch(struct device *, void *, void *);
void mainbusattach(struct device *, struct device *, void *);
int  mainbusprint(void *aux, const char *mainbus);
int mainbussearch(struct device *,  void *, void *);
d32 8
a39 1
/* attach and device structures for the device */
d42 2
a43 1
	sizeof(struct device), mainbusmatch, mainbusattach
d50 19
d70 2
a71 1
 * int mainbusmatch(struct device *parent, struct cfdata *cf, void *aux)
a72 1

d74 1
a74 1
mainbusmatch(struct device *parent, void *cf, void *aux)
d79 38
d118 1
a118 3
 * void mainbusattach(struct device *parent, struct device *self, void *aux)
 *
 * probe and attach all children
a119 1

d121 1
a121 1
mainbusattach(struct device *parent, struct device *self, void *aux)
d123 16
a138 1
	printf("\n");
d140 3
a142 1
	config_search(mainbussearch, self, aux);
d145 3
d149 1
a149 1
mainbussearch(struct device *parent, void *vcf, void *aux)
d151 2
a152 2
	struct mainbus_attach_args ma;
	struct cfdata *cf = vcf;
d154 1
d161 1
a161 1
	config_attach(parent, cf, &ma, mainbusprint);
d165 2
a166 8
/*
 * int mainbusprint(void *aux, const char *mainbus)
 *
 * print routine used during config of children
 */

int
mainbusprint(void *aux, const char *mainbus)
d168 1
a168 1
	struct mainbus_attach_args *ma = aux;
d170 2
a171 2
	if (mainbus != NULL)
		printf("%s at %s", ma->ma_name, mainbus);
d173 1
a173 1
	return (UNCONF);
@


1.6
log
@None of the mainbus child devices care about getting a bus_space_tag_t from
its parent, because they know better; so don't bother providing one, which
allows more unused code to go to the Attic.

While there, redo the config machinery for mainbus child devices, to bring
it to our current standards. This also allows them to be disabled in UKC,
should there be a need for this in the future.
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.5 2010/08/30 21:35:57 deraadt Exp $	*/
d62 1
a62 2
	sizeof(struct device), mainbusmatch, mainbusattach, NULL,
	config_activate_children
@


1.5
log
@Convert all powerhooks to activate functions, and provide powerhook stubs.
Of note:  lcd stubs get pulled up to the parent; zts has to keep track of
whether it is in use or not
testing by myself and jakemsr; proof reading by oga
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.4 2010/04/27 16:43:23 drahn Exp $	*/
a47 2
#include <sys/conf.h>
#include <sys/malloc.h>
a49 1
#include <machine/bus.h>
a51 8
/*
 * mainbus is a root device so we a bus space tag to pass to children
 *
 * The tag is provided by mainbus_io.c and mainbus_io_asm.S
 */

extern struct bus_space mainbus_bs_tag;

d54 4
a57 4
int  mainbusmatch  (struct device *, void *, void *);
void mainbusattach (struct device *, struct device *, void *);
int  mainbusprint  (void *aux, const char *mainbus);
int mainbussearch (struct device *,  void *, void *);
a71 2
 *
 * Always match for unit 0
d91 1
a91 1
	config_search(mainbussearch, self, self);
d95 1
a95 1
mainbussearch(struct device *parent, void *c, void *aux)
d98 1
a98 2
	struct cfdata *cf = c;

a99 1
	ma.ma_iot = &mainbus_bs_tag;
d102 3
a104 1
	config_found(parent, &ma, mainbusprint);
d106 1
d119 6
a124 2
/* XXXX print flags */
	return (QUIET);
@


1.4
log
@arm32 define isn't used on any arm platforms, and machine/io.h doesn't exist,
delete the check.  ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.3 2005/12/31 23:03:58 drahn Exp $	*/
d73 2
a74 1
	sizeof(struct device), mainbusmatch, mainbusattach
@


1.3
log
@Search for the devices to attach to mainbus, not hardcoded. ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.2 2004/05/19 03:17:07 drahn Exp $	*/
a51 3
#if defined(arm32)		/* XXX */
#include <machine/io.h>
#endif
a53 3
/*
#include "locators.h"
*/
@


1.2
log
@de __P of sys/arch/arm.
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.1 2004/02/01 05:09:49 drahn Exp $	*/
d74 1
a74 1
int  mainbussearch (struct device *, struct cfdata *, void *);
d107 8
d116 2
a117 1
	printf("\n");
d120 5
a124 5
	ma.ma_name = "cpu";
	config_found(self, &ma, mainbusprint); /* XXX */
	ma.ma_iot = &mainbus_bs_tag;
	ma.ma_name = "footbridge";
	config_found(self, &ma, mainbusprint); /* XXX */
@


1.1
log
@Arm port, NetBSD codebase stripped down, 32bit only support.
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.2 2004/01/17 05:11:33 drahn Exp $	*/
d71 4
a74 4
int  mainbusmatch  __P((struct device *, void *, void *));
void mainbusattach __P((struct device *, struct device *, void *));
int  mainbusprint  __P((void *aux, const char *mainbus));
int  mainbussearch __P((struct device *, struct cfdata *, void *));
@


1.1.2.1
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.1.2.2
log
@Merge with the trunk
@
text
@d71 4
a74 4
int  mainbusmatch  (struct device *, void *, void *);
void mainbusattach (struct device *, struct device *, void *);
int  mainbusprint  (void *aux, const char *mainbus);
int  mainbussearch (struct device *, struct cfdata *, void *);
@


