head	1.12;
access;
symbols
	SMP_SYNC_A:1.12
	SMP_SYNC_B:1.12
	UBC_SYNC_A:1.12
	UBC_SYNC_B:1.12
	NIKLAS_UNDEAD:1.11.0.12
	OPENBSD_2_8:1.11.0.10
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.11.0.8
	OPENBSD_2_7_BASE:1.11
	SMP:1.11.0.6
	SMP_BASE:1.11
	kame_19991208:1.11
	OPENBSD_2_6:1.11.0.4
	OPENBSD_2_6_BASE:1.11
	OPENBSD_2_5:1.11.0.2
	OPENBSD_2_5_BASE:1.11
	OPENBSD_2_4:1.10.0.4
	OPENBSD_2_4_BASE:1.10
	OPENBSD_2_3:1.10.0.2
	OPENBSD_2_3_BASE:1.10
	OPENBSD_2_2:1.7.0.4
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	PEFO_960624:1.1.1.1
	PEFO:1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2001.02.07.07.45.13;	author art;	state dead;
branches;
next	1.11;

1.11
date	99.01.11.05.11.10;	author millert;	state Exp;
branches
	1.11.6.1;
next	1.10;

1.10
date	98.03.16.09.38.52;	author pefo;	state Exp;
branches;
next	1.9;

1.9
date	98.01.29.14.54.56;	author pefo;	state Exp;
branches;
next	1.8;

1.8
date	98.01.28.13.46.38;	author pefo;	state Exp;
branches;
next	1.7;

1.7
date	97.05.24.18.36.26;	author pefo;	state Exp;
branches;
next	1.6;

1.6
date	97.04.19.17.20.04;	author pefo;	state Exp;
branches;
next	1.5;

1.5
date	96.11.23.21.45.35;	author kstailey;	state Exp;
branches;
next	1.4;

1.4
date	96.09.14.15.58.29;	author pefo;	state Exp;
branches;
next	1.3;

1.3
date	96.07.30.20.24.32;	author pefo;	state Exp;
branches;
next	1.2;

1.2
date	96.07.16.07.46.18;	author pefo;	state Exp;
branches;
next	1.1;

1.1
date	96.06.24.09.07.18;	author pefo;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.06.24.09.07.18;	author pefo;	state Exp;
branches;
next	;

1.11.6.1
date	2001.04.18.16.03.05;	author niklas;	state dead;
branches;
next	;


desc
@@


1.12
log
@We need to loose some weight.
If someone feels very opposed to this, the code is left in the Attic.
Just revive and _make_it_work_.
@
text
@/*	$OpenBSD: picabus.c,v 1.11 1999/01/11 05:11:10 millert Exp $	*/
/*	$NetBSD: tc.c,v 1.2 1995/03/08 00:39:05 cgd Exp $	*/

/*
 * Copyright (c) 1994, 1995 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Author: Chris G. Demetriou
 * Author: Per Fogelstrom. (Mips R4x00)
 * 
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" 
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND 
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/user.h>
#include <sys/device.h>

#include <machine/intr.h>
#include <machine/pte.h>
#include <machine/cpu.h>
#include <machine/pio.h>
#include <machine/autoconf.h>

#include <mips/archtype.h>
#include <arc/pica/pica.h>
#include <arc/dev/dma.h>

struct pica_softc {
	struct	device sc_dv;
	struct	abus sc_bus;
	struct	pica_dev *sc_devs;
};

/* Definition of the driver for autoconfig. */
int	picamatch(struct device *, void *, void *);
void	picaattach(struct device *, struct device *, void *);
int	picaprint(void *, const char *);

struct cfattach pica_ca = {
	sizeof(struct pica_softc), picamatch, picaattach
};
struct cfdriver pica_cd = {
	NULL, "pica", DV_DULL, NULL, 0
};

void	pica_intr_establish __P((struct confargs *, int (*)(void *), void *));
void	pica_intr_disestablish __P((struct confargs *));
caddr_t	pica_cvtaddr __P((struct confargs *));
int	pica_matchname __P((struct confargs *, char *));
int	pica_iointr __P((unsigned int, struct clockframe *));
int	pica_clkintr __P((unsigned int, struct clockframe *));

/*
 *  Interrupt dispatch table.
 */
struct pica_int_desc int_table[] = {
	{0, pica_intrnull, (void *)NULL, 0 },  /*  0 */
	{0, pica_intrnull, (void *)NULL, 0 },  /*  1 */
	{0, pica_intrnull, (void *)NULL, 0 },  /*  2 */
	{0, pica_intrnull, (void *)NULL, 0 },  /*  3 */
	{0, pica_intrnull, (void *)NULL, 0 },  /*  4 */
	{0, pica_intrnull, (void *)NULL, 0 },  /*  5 */
	{0, pica_intrnull, (void *)NULL, 0 },  /*  6 */
	{0, pica_intrnull, (void *)NULL, 0 },  /*  7 */
	{0, pica_intrnull, (void *)NULL, 0 },  /*  8 */
	{0, pica_intrnull, (void *)NULL, 0 },  /*  9 */
	{0, pica_intrnull, (void *)NULL, 0 },  /* 10 */
	{0, pica_intrnull, (void *)NULL, 0 },  /* 11 */
	{0, pica_intrnull, (void *)NULL, 0 },  /* 12 */
	{0, pica_intrnull, (void *)NULL, 0 },  /* 13 */
	{0, pica_intrnull, (void *)NULL, 0 },  /* 14 */
	{0, pica_intrnull, (void *)NULL, 0 },  /* 15 */
};

struct pica_dev {
	struct confargs	ps_ca;
	u_int		ps_mask;
	intr_handler_t	ps_handler;
	void 		*ps_base;
};
struct pica_dev acer_pica_61_cpu[] = {
	{{ "dallas_rtc",0, 0, },
	   0,			 pica_intrnull, (void *)PICA_SYS_CLOCK, },
	{{ "lpt",	1, 0, },
	   PICA_SYS_LB_IE_PAR1,	 pica_intrnull, (void *)PICA_SYS_PAR1, },
	{{ "fdc",	2, 0, },
	   PICA_SYS_LB_IE_FLOPPY,pica_intrnull, (void *)PICA_SYS_FLOPPY, },
	{{ NULL,	3, NULL, },
	   0, pica_intrnull, (void *)NULL, },
	{{ NULL,	4, NULL, },
	   0, pica_intrnull, (void *)NULL, },
	{{ "sonic",	5, 0, },
	   PICA_SYS_LB_IE_SONIC, pica_intrnull, (void *)PICA_SYS_SONIC, },
	{{ "asc",	6, 0, },
	   PICA_SYS_LB_IE_SCSI,  pica_intrnull, (void *)PICA_SYS_SCSI, },
	{{ "pc",	7, 0, },
	   PICA_SYS_LB_IE_KBD,	 pica_intrnull, (void *)PICA_SYS_KBD, },
	{{ "pms",	8, NULL, },
	   PICA_SYS_LB_IE_MOUSE, pica_intrnull, (void *)PICA_SYS_KBD, },
	{{ "com",	9, 0, },
	   PICA_SYS_LB_IE_COM1,	 pica_intrnull, (void *)PICA_SYS_COM1, },
	{{ "com",      10, 0, },
	   PICA_SYS_LB_IE_COM2,	 pica_intrnull, (void *)PICA_SYS_COM2, },
	{{ NULL,       -1, NULL, },
	   0, NULL, (void *)NULL, },
};

struct pica_dev *pica_cpu_devs[] = {
        NULL,                   /* Unused */
        acer_pica_61_cpu,       /* Acer PICA */
        acer_pica_61_cpu,       /* MAGNUMS same as Acer PICA */
	NULL,
	NULL,
	NULL,
        acer_pica_61_cpu,       /* NEC-R94 same as MAGNUM */
};
int npica_cpu_devs = sizeof pica_cpu_devs / sizeof pica_cpu_devs[0];

int local_int_mask = 0;	/* Local interrupt enable mask */

int
picamatch(parent, cfdata, aux)
	struct device *parent;
	void *cfdata;
	void *aux;
{
	struct cfdata *cf = cfdata;
	struct confargs *ca = aux;

        /* Make sure that we're looking for a PICA. */
        if (strcmp(ca->ca_name, pica_cd.cd_name) != 0)
                return (0);

        /* Make sure that unit exists. */
	if (cf->cf_unit != 0 ||
	    system_type > npica_cpu_devs || pica_cpu_devs[system_type] == NULL)
		return (0);

	return (1);
}

void
picaattach(parent, self, aux)
	struct device *parent;
	struct device *self;
	void *aux;
{
	struct pica_softc *sc = (struct pica_softc *)self;
	struct confargs *nca;
	int i;

	printf("\n");

	/* keep our CPU device description handy */
	sc->sc_devs = pica_cpu_devs[system_type];

	/* set up interrupt handlers */
	set_intr(INT_MASK_1, pica_iointr, 2);

	sc->sc_bus.ab_dv = (struct device *)sc;
	sc->sc_bus.ab_type = BUS_PICA;
	sc->sc_bus.ab_intr_establish = pica_intr_establish;
	sc->sc_bus.ab_intr_disestablish = pica_intr_disestablish;
	sc->sc_bus.ab_cvtaddr = pica_cvtaddr;
	sc->sc_bus.ab_matchname = pica_matchname;

	/* Initialize PICA Dma */
	picaDmaInit();

	/* Try to configure each PICA attached device */
	for (i = 0; sc->sc_devs[i].ps_ca.ca_slot >= 0; i++) {

		if(sc->sc_devs[i].ps_ca.ca_name == NULL)
			continue; /* Empty slot */

		nca = &sc->sc_devs[i].ps_ca;
		nca->ca_bus = &sc->sc_bus;

		/* Tell the autoconfig machinery we've found the hardware. */
		config_found(self, nca, picaprint);
	}
}

int
picaprint(aux, pnp)
	void *aux;
	const char *pnp;
{
	struct confargs *ca = aux;

        if (pnp)
                printf("%s at %s", ca->ca_name, pnp);
        printf(" slot %ld offset 0x%lx", ca->ca_slot, ca->ca_offset);
        return (UNCONF);
}

caddr_t
pica_cvtaddr(ca)
	struct confargs *ca;
{
	struct pica_softc *sc = pica_cd.cd_devs[0];

	return(sc->sc_devs[ca->ca_slot].ps_base + ca->ca_offset);

}

void
pica_intr_establish(ca, handler, val)
	struct confargs *ca;
	intr_handler_t handler;
	void *val;
{
	struct pica_softc *sc = pica_cd.cd_devs[0];

	int slot;

	slot = ca->ca_slot;
	if(slot == 0) {		/* Slot 0 is special, clock */
		set_intr(INT_MASK_4, pica_clkintr, 1);
	}

	if(int_table[slot].int_mask != 0) {
		panic("pica intr already set");
	}
	else {
		int_table[slot].int_mask = sc->sc_devs[slot].ps_mask;;
		local_int_mask |= int_table[slot].int_mask;
		int_table[slot].int_hand = handler;
		int_table[slot].param = val;
	}
	out16(PICA_SYS_LB_IE, local_int_mask);
}

void
pica_intr_disestablish(ca)
	struct confargs *ca;
{
	int slot;

	slot = ca->ca_slot;
	if(slot != 0)		 {	/* Slot 0 is special, clock */
		local_int_mask &= ~int_table[slot].int_mask;
		int_table[slot].int_mask = 0;
		int_table[slot].int_hand = pica_intrnull;
		int_table[slot].param = (void *)NULL;
	}
}

int
pica_matchname(ca, name)
	struct confargs *ca;
	char *name;
{
	return (strcmp(name, ca->ca_name) == 0);
}

int
pica_intrnull(val)
	void *val;
{
	panic("uncaught PICA intr for slot %d", val);
}

/*
 *   Handle pica i/o interrupt.
 */
int
pica_iointr(mask, cf)
	unsigned mask;
	struct clockframe *cf;
{
	int vector;

	while((vector = inb(PVIS) >> 2) != 0) {
		(*int_table[vector].int_hand)(int_table[vector].param);
	}
	return(~0);  /* Dont reenable */
}

/*
 * Handle pica interval clock interrupt.
 */
int
pica_clkintr(mask, cf)
	unsigned mask;
	struct clockframe *cf;
{
	int temp;

	temp = inw(R4030_SYS_IT_STAT);
	hardclock(cf);

	/* Re-enable clock interrupts */
	splx(INT_MASK_4 | SR_INT_ENAB);

	return(~INT_MASK_4); /* Keep clock interrupts enabled */
}

@


1.11
log
@panic prints a newline for you, don't do it in the panic string
@
text
@d1 1
a1 1
/*	$OpenBSD: picabus.c,v 1.10 1998/03/16 09:38:52 pefo Exp $	*/
@


1.11.6.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: picabus.c,v 1.11 1999/01/11 05:11:10 millert Exp $	*/
@


1.10
log
@DDB.

Support for Algorithmics R5000/R10000 evaluation board. So far only the
RM5260 is supported. RM5270 - RM7000 later. R5000 and R10000 depending
on access to cpu modules.

vm_machdep.c moved to arch/mips/mips.
@
text
@d1 1
a1 1
/*	$OpenBSD: picabus.c,v 1.9 1998/01/29 14:54:56 pefo Exp $	*/
d281 1
a281 1
	panic("uncaught PICA intr for slot %d\n", val);
@


1.9
log
@Some more arc/sgi fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: picabus.c,v 1.8 1998/01/28 13:46:38 pefo Exp $	*/
a100 1
#ifdef ACER_PICA_61
a126 1
#endif
a129 1
#ifdef ACER_PICA_61
d131 1
a131 1
#else
d133 3
a135 1
#endif
@


1.8
log
@Moving around files for new mips arch layout
@
text
@d1 1
a1 1
/*	$OpenBSD: picabus.c,v 1.7 1997/05/24 18:36:26 pefo Exp $	*/
a71 2

extern int system_type;
@


1.7
log
@Close shave.. lpr -> lpt
@
text
@d1 1
a1 1
/*	$OpenBSD: picabus.c,v 1.6 1997/04/19 17:20:04 pefo Exp $	*/
d44 1
a45 1
#include <arc/arc/arctype.h>
d73 1
a73 1
extern int cputype;
d159 1
a159 1
	    cputype > npica_cpu_devs || pica_cpu_devs[cputype] == NULL)
d178 1
a178 1
	sc->sc_devs = pica_cpu_devs[cputype];
@


1.6
log
@-Wall cleanup.
Change to new MI assym.h file generation. (genassym.cf)
@
text
@d1 1
a1 1
/*	$OpenBSD: picabus.c,v 1.5 1996/11/23 21:45:35 kstailey Exp $	*/
d107 1
a107 1
	{{ "lpr",	1, 0, },
@


1.5
log
@added const to second parameter of cfprint_t routines
@
text
@d1 1
a1 1
/*	$OpenBSD: picabus.c,v 1.4 1996/09/14 15:58:29 pefo Exp $	*/
d33 3
d38 2
d46 1
a260 2
	struct pica_softc *sc = pica_cd.cd_devs[0];

d264 1
a264 3
	if(slot = 0) {		/* Slot 0 is special, clock */
	}
	else {
@


1.4
log
@First shot at a multivendor kernel. This version handles pica's and desk-
station tyne's. Auto detection still needs to be compleeted.
Checked in version is hardwired for pica's. Use the PICA config file.
@
text
@d1 1
a1 1
/*	$OpenBSD: picabus.c,v 1.3 1996/07/30 20:24:32 pefo Exp $	*/
d51 1
a51 1
int	picaprint(void *, char *);
d204 1
a204 1
	char *pnp;
@


1.3
log
@Cleanup, endian and abi stuff fixies. Some stuff added for MIPS Magnum.
(PICA and Magnum uses very similar core chipsets).
@
text
@d1 1
a1 1
/*	$OpenBSD: picabus.c,v 1.2 1996/07/16 07:46:18 pefo Exp $	*/
d64 2
a65 2
int	pica_iointr __P((void *));
int	pica_clkintr __P((unsigned, unsigned, unsigned, unsigned));
d289 3
a291 2
pica_iointr(val)
	void *val;
d305 1
a305 1
pica_clkintr(mask, pc, statusReg, causeReg)
d307 1
a307 3
	unsigned pc;
	unsigned statusReg;
	unsigned causeReg;
a308 1
	struct clockframe cf;
d312 1
a312 3
	cf.pc = pc;
	cf.sr = statusReg;
	hardclock(&cf);
@


1.2
log
@Rename some 'pica' names to 'mips'.
@
text
@d1 1
a1 1
/*	$OpenBSD: picabus.c,v 1.1.1.1 1996/06/24 09:07:18 pefo Exp $	*/
d313 1
a313 1
	temp = inw(PICA_SYS_IT_STAT);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d101 1
a101 1
	{{ "lpt",	1, 0, },
@


1.1.1.1
log
@Next try. ARC tree import. "New" Mips (spim) ARC compliant systems tree.
This tree will eventually suport viritualy all ARC compliant Mips systems,
that is all we can lay our hands on for porting/testing. It will supersede
the pica tree which will be removed shortly when this tree is functioning.
@
text
@@

