head	1.40;
access;
symbols
	SMP_SYNC_A:1.40
	SMP_SYNC_B:1.40
	UBC_SYNC_A:1.40
	UBC_SYNC_B:1.40
	NIKLAS_UNDEAD:1.39.0.4
	OPENBSD_2_8:1.39.0.2
	OPENBSD_2_8_BASE:1.39
	OPENBSD_2_7:1.38.0.2
	OPENBSD_2_7_BASE:1.38
	SMP:1.36.0.4
	SMP_BASE:1.36
	kame_19991208:1.36
	OPENBSD_2_6:1.36.0.2
	OPENBSD_2_6_BASE:1.36
	OPENBSD_2_5:1.35.0.2
	OPENBSD_2_5_BASE:1.35
	OPENBSD_2_4:1.34.0.2
	OPENBSD_2_4_BASE:1.34
	OPENBSD_2_3:1.32.0.2
	OPENBSD_2_3_BASE:1.32
	OPENBSD_2_2:1.29.0.4
	OPENBSD_2_2_BASE:1.29
	OPENBSD_2_1:1.29.0.2
	OPENBSD_2_1_BASE:1.29
	OPENBSD_2_0:1.15.0.2
	OPENBSD_2_0_BASE:1.15
	PEFO_960624:1.1.1.1
	PEFO:1.1.1;
locks; strict;
comment	@ * @;


1.40
date	2001.02.07.07.45.00;	author art;	state dead;
branches;
next	1.39;

1.39
date	2000.10.27.00.16.04;	author mickey;	state Exp;
branches;
next	1.38;

1.38
date	2000.04.11.02.44.25;	author pjanzen;	state Exp;
branches;
next	1.37;

1.37
date	2000.03.23.09.59.53;	author art;	state Exp;
branches;
next	1.36;

1.36
date	99.05.22.21.22.19;	author weingart;	state Exp;
branches
	1.36.4.1;
next	1.35;

1.35
date	99.01.30.22.39.31;	author imp;	state Exp;
branches;
next	1.34;

1.34
date	98.10.15.21.29.59;	author imp;	state Exp;
branches;
next	1.33;

1.33
date	98.09.15.10.58.54;	author pefo;	state Exp;
branches;
next	1.32;

1.32
date	98.03.25.11.48.14;	author pefo;	state Exp;
branches;
next	1.31;

1.31
date	98.03.16.09.38.30;	author pefo;	state Exp;
branches;
next	1.30;

1.30
date	98.01.28.13.45.55;	author pefo;	state Exp;
branches;
next	1.29;

1.29
date	97.05.19.16.21.20;	author pefo;	state Exp;
branches;
next	1.28;

1.28
date	97.05.19.16.01.09;	author pefo;	state Exp;
branches;
next	1.27;

1.27
date	97.05.18.13.45.21;	author pefo;	state Exp;
branches;
next	1.26;

1.26
date	97.05.01.15.15.29;	author pefo;	state Exp;
branches;
next	1.25;

1.25
date	97.04.19.17.19.44;	author pefo;	state Exp;
branches;
next	1.24;

1.24
date	97.04.10.16.29.08;	author pefo;	state Exp;
branches;
next	1.23;

1.23
date	97.03.23.11.34.30;	author pefo;	state Exp;
branches;
next	1.22;

1.22
date	97.03.17.08.11.12;	author pefo;	state Exp;
branches;
next	1.21;

1.21
date	97.03.12.19.16.43;	author pefo;	state Exp;
branches;
next	1.20;

1.20
date	97.02.03.15.05.08;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	97.02.02.00.47.42;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	97.02.01.11.02.41;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	97.01.28.03.54.52;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	96.10.20.22.40.32;	author imp;	state Exp;
branches;
next	1.15;

1.15
date	96.09.24.19.37.24;	author pefo;	state Exp;
branches;
next	1.14;

1.14
date	96.09.19.22.30.07;	author pefo;	state Exp;
branches;
next	1.13;

1.13
date	96.09.19.00.30.36;	author imp;	state Exp;
branches;
next	1.12;

1.12
date	96.09.14.15.58.16;	author pefo;	state Exp;
branches;
next	1.11;

1.11
date	96.09.06.04.57.52;	author imp;	state Exp;
branches;
next	1.10;

1.10
date	96.09.05.08.04.14;	author pefo;	state Exp;
branches;
next	1.9;

1.9
date	96.09.04.21.18.19;	author pefo;	state Exp;
branches;
next	1.8;

1.8
date	96.09.02.21.33.29;	author imp;	state Exp;
branches;
next	1.7;

1.7
date	96.09.02.20.45.45;	author imp;	state Exp;
branches;
next	1.6;

1.6
date	96.09.02.11.33.23;	author pefo;	state Exp;
branches;
next	1.5;

1.5
date	96.08.26.11.11.54;	author pefo;	state Exp;
branches;
next	1.4;

1.4
date	96.07.30.20.24.17;	author pefo;	state Exp;
branches;
next	1.3;

1.3
date	96.07.27.11.40.29;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.07.16.07.46.12;	author pefo;	state Exp;
branches;
next	1.1;

1.1
date	96.06.24.09.07.21;	author pefo;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.06.24.09.07.21;	author pefo;	state Exp;
branches;
next	;

1.36.4.1
date	2000.03.24.09.07.02;	author niklas;	state Exp;
branches;
next	1.36.4.2;

1.36.4.2
date	2001.04.18.16.02.29;	author niklas;	state dead;
branches;
next	;


desc
@@


1.40
log
@We need to loose some weight.
If someone feels very opposed to this, the code is left in the Attic.
Just revive and _make_it_work_.
@
text
@/*	$OpenBSD: machdep.c,v 1.39 2000/10/27 00:16:04 mickey Exp $	*/
/*
 * Copyright (c) 1988 University of Utah.
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department, The Mach Operating System project at
 * Carnegie-Mellon University and Ralph Campbell.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	from: @@(#)machdep.c	8.3 (Berkeley) 1/12/94
 *      $Id: machdep.c,v 1.39 2000/10/27 00:16:04 mickey Exp $
 */

/* from: Utah Hdr: machdep.c 1.63 91/04/24 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/signalvar.h>
#include <sys/kernel.h>
#include <sys/map.h>
#include <sys/proc.h>
#include <sys/buf.h>
#include <sys/reboot.h>
#include <sys/conf.h>
#include <sys/file.h>
#include <sys/clist.h>
#include <sys/timeout.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/msgbuf.h>
#include <sys/ioctl.h>
#include <sys/tty.h>
#include <sys/user.h>
#include <sys/exec.h>
#include <sys/sysctl.h>
#include <sys/mount.h>
#include <sys/syscallargs.h>
#ifdef SYSVSHM
#include <sys/shm.h>
#endif
#ifdef SYSVSEM
#include <sys/sem.h>
#endif
#ifdef SYSVMSG
#include <sys/msg.h>
#endif
#ifdef MFS
#include <ufs/mfs/mfs_extern.h>
#endif

#include <vm/vm_kern.h>

#include <machine/pte.h>
#include <machine/cpu.h>
#include <machine/reg.h>
#include <machine/pio.h>
#include <machine/psl.h>
#include <machine/bus.h>
#include <machine/autoconf.h>
#include <machine/memconf.h>

#include <sys/exec_ecoff.h>

#include <dev/cons.h>

#include <mips/archtype.h>
#include <mips/mips/arcbios.h>
#include <arc/pica/pica.h>
#include <arc/dti/desktech.h>
#include <arc/algor/algor.h>

extern struct consdev *cn_tab;
extern char kernel_text[];
extern void makebootdev __P((char *));
extern void stacktrace __P((void));
extern void configure __P((void));
extern void pmap_bootstrap __P((vm_offset_t));
extern int kbc_8042sysreset __P((void));

/* the following is used externally (sysctl_hw) */
char	machine[] = "arc";	/* cpu "architecture" */
char	cpu_model[30];

vm_map_t buffer_map;

/*
 * Declare these as initialized data so we can patch them.
 */
int	nswbuf = 0;
#ifdef	NBUF
int	nbuf = NBUF;
#else
int	nbuf = 0;
#endif
#ifdef	BUFPAGES
int	bufpages = BUFPAGES;
#else
int	bufpages = 0;
#endif
int	msgbufmapped = 0;	/* set when safe to use msgbuf */
int	physmem;		/* max supported memory, changes to actual */
int	cpucfg;			/* Value of processor config register */
int	l2cache_is_snooping;	/* Set if L2 cache snoops uncached writes */
int	system_type;		/* Mother board type */
int	num_tlbentries = 48;	/* Size of the CPU tlb */
int	ncpu = 1;		/* At least one cpu in the system */
int	CONADDR;		/* Well, ain't it just plain stupid... */
struct arc_bus_space arc_bus_io;/* Bus tag for bus.h macros */
struct arc_bus_space arc_bus_mem;/* Bus tag for bus.h macros */
char   **environment;		/* On some arches, pointer to environment */
char	eth_hw_addr[6];		/* HW ether addr not stored elsewhere */

struct mem_descriptor mem_layout[MAXMEMSEGS];

extern	int Mips_spl0 __P((void)), Mips_spl1 __P((void)), Mips_spl2 __P((void));
extern	int Mips_spl3 __P((void)), Mips_spl4 __P((void)), Mips_spl5 __P((void));
int	(*Mips_splnet)(void) = splhigh;
int	(*Mips_splbio)(void) = splhigh;
int	(*Mips_splimp)(void) = splhigh;
int	(*Mips_spltty)(void) = splhigh;
int	(*Mips_splclock)(void) = splhigh;
int	(*Mips_splstatclock)(void) = splhigh;

void mips_init __P((int, char *[], char *[]));	
void initcpu __P((void));
void dumpsys __P((void));
void dumpconf __P((void));

static void tlb_init_pica __P((void));
static void tlb_init_tyne __P((void));
static int get_simm_size __P((int *, int));
static char *getenv __P((char *env));
static void get_eth_hw_addr __P((char *));
static int atoi __P((char *, int));


/*
 * safepri is a safe priority for sleep to set for a spin-wait
 * during autoconfiguration or after a panic.
 */
int	safepri = PSL_LOWIPL;

struct	user *proc0paddr;
struct	proc nullproc;		/* for use by swtch_exit() */

/*
 * Do all the stuff that locore normally does before calling main().
 * Process arguments passed to us by the BIOS.
 * Reset mapping and set up mapping to hardware and init "wired" reg.
 * Return the first page address following the system.
 */
void
mips_init(argc, argv, envv)
	int argc;
	char *argv[];
	char *envv[];	/* Not on all arches... */
{
	char *cp;
	int i;
	unsigned firstaddr;
	caddr_t sysend;
	caddr_t start;
	struct tlb tlb;
	extern char edata[], end[];
	extern char MipsTLBMiss[], MipsTLBMissEnd[];
	extern char MipsException[], MipsExceptionEnd[];

	/* clear the BSS segment in OpenBSD code */
	sysend = (caddr_t)mips_round_page(end);
	bzero(edata, sysend - edata);

	environment = &argv[1];

	/* Initialize the CPU type */
	bios_ident();

	/*
	 * Get config register now as mapped from BIOS since we are
	 * going to demap these addresses later. We want as may TLB
	 * entries as possible to do something useful :-).
	 */

	switch (system_type) {
	case ACER_PICA_61:	/* ALI PICA 61 and MAGNUM is almost the */
	case MAGNUM:		/* Same kind of hardware. NEC goes here too */
		if(system_type == MAGNUM) {
			strcpy(cpu_model, "MIPS Magnum");
		}
		else {
			strcpy(cpu_model, "Acer Pica-61");
		}
		arc_bus_io.bus_base = PICA_V_ISA_IO;
		arc_bus_mem.bus_base = PICA_V_ISA_MEM;
		CONADDR = 0;
		break;

	case DESKSTATION_RPC44:
		strcpy(cpu_model, "Deskstation rPC44");
		arc_bus_io.bus_base = RPC44_V_ISA_IO;
		arc_bus_mem.bus_base = RPC44_V_ISA_MEM;
		CONADDR = 0; /* Don't screew the mouse... */
		break;

	case DESKSTATION_TYNE:
		strcpy(cpu_model, "Deskstation Tyne");
		arc_bus_io.bus_base = TYNE_V_ISA_IO;
		arc_bus_mem.bus_base = TYNE_V_ISA_MEM;
		CONADDR = 0; /* Don't screew the mouse... */
		break;

	case SNI_RM200:
		strcpy(cpu_model, "Siemens Nixdorf RM200");
#if 0
		arc_bus_io.bus_base = RM200_V_ISA_IO;
		arc_bus_mem.bus_base = RM200_V_ISA_MEM;
#endif
		CONADDR = 0; /* Don't screew the mouse... */
		break;

	case -1:	/* Not identified as an ARC system. We have a couple */
			/* of other options. Systems not having an ARC Bios  */

			/* Make this more fancy when more comes in here */
		environment = envv;
#if 0
		system_type = ALGOR_P4032;
		strcpy(cpu_model, "Algorithmics P-4032");
		arc_bus_io.bus_sparse1 = 2;
		arc_bus_io.bus_sparse2 = 1;
		arc_bus_io.bus_sparse4 = 0;
		arc_bus_io.bus_sparse8 = 0;
		CONADDR = P4032_COM1;
#else
		system_type = ALGOR_P5064;
		strcpy(cpu_model, "Algorithmics P-5064");
		arc_bus_io.bus_sparse1 = 0;
		arc_bus_io.bus_sparse2 = 0;
		arc_bus_io.bus_sparse4 = 0;
		arc_bus_io.bus_sparse8 = 0;
		CONADDR = P5064_COM1;
#endif

		mem_layout[0].mem_start = 0;
		mem_layout[0].mem_size = mips_trunc_page(CACHED_TO_PHYS(kernel_text));
		mem_layout[1].mem_start = CACHED_TO_PHYS((int)sysend);
		if(getenv("memsize") != 0) {
			i = atoi(getenv("memsize"), 10);
			i = 1024 * 1024 * i;
			mem_layout[1].mem_size = i - (int)(CACHED_TO_PHYS(sysend));
			physmem = i;
		}
		else {
			i = get_simm_size((int *)0, 128*1024*1024);
			mem_layout[1].mem_size = i - (int)(CACHED_TO_PHYS(sysend));
			physmem = i;
/*XXX Ouch!!! */
			mem_layout[2].mem_start = i;
			mem_layout[2].mem_size = get_simm_size((int *)(i), 0);
			physmem += mem_layout[2].mem_size;
			mem_layout[3].mem_start = i+i/2;
			mem_layout[3].mem_size = get_simm_size((int *)(i+i/2), 0);
			physmem += mem_layout[3].mem_size;
		}
/*XXX*/
		argv[0] = getenv("bootdev");
		if(argv[0] == 0)
			argv[0] = "unknown";


		break;

	default:	/* This is probably the best we can do... */
		bios_putstring("kernel not configured for this system\n");
		boot(RB_HALT | RB_NOSYNC);
	}
	physmem = btoc(physmem);

	/* look at argv[0] and compute bootdev for autoconfig setup */
	makebootdev(argv[0]);

	/*
	 * Look at arguments passed to us and compute boothowto.
	 * Default to SINGLE and ASKNAME if no args or
	 * SINGLE and DFLTROOT if this is a ramdisk kernel.
	 */
#ifdef RAMDISK_HOOKS
	boothowto = RB_SINGLE | RB_DFLTROOT;
#else
	boothowto = RB_SINGLE | RB_ASKNAME;
#endif /* RAMDISK_HOOKS */

#ifdef KADB
	boothowto |= RB_KDB;
#endif

	get_eth_hw_addr(getenv("ethaddr"));
	cp = getenv("osloadoptions");
	if(cp) {
		while(*cp) {
			switch (*cp++) {
			case 'a': /* autoboot */
				boothowto &= ~RB_SINGLE;
				break;

			case 'd': /* use compiled in default root */
				boothowto |= RB_DFLTROOT;
				break;

			case 'n': /* ask for names */
				boothowto |= RB_ASKNAME;
				break;

			case 'N': /* don't ask for names */
				boothowto &= ~RB_ASKNAME;
				break;

			case 's': /* use serial console */
				boothowto |= RB_SERCONS;
				break;
			}

		}
	}

	/*
	 * Now its time to abandon the BIOS and be self supplying.
	 * Start with cleaning out the TLB. Bye bye Microsoft....
	 */
	cpucfg = R4K_ConfigCache();
	switch(cpu_id.cpu.cp_imp) {
	case MIPS_R4300:
		num_tlbentries = 32;
		break;
	default:
		num_tlbentries = 48;
		break;
	}

	R4K_SetWIRED(0);
	R4K_TLBFlush(num_tlbentries);
	R4K_SetWIRED(VMWIRED_ENTRIES);
	
	switch (system_type) {
	case ACER_PICA_61:
	case MAGNUM:
		tlb_init_pica();
		break;

	case DESKSTATION_TYNE:
		tlb_init_tyne();
		break;

	case DESKSTATION_RPC44:
		break;

	case ALGOR_P4032:
	case ALGOR_P5064:
		break;

	case SNI_RM200:
		/*XXX*/
		break;
	}

	/*
	 * Init mapping for u page(s) for proc[0], pm_tlbpid 1.
	 */
	sysend = (caddr_t)(((int)sysend + 3) & -4);
	start = sysend;
	curproc->p_addr = proc0paddr = (struct user *)sysend;
	curproc->p_md.md_regs = proc0paddr->u_pcb.pcb_regs;
	firstaddr = CACHED_TO_PHYS(sysend);
	for (i = 0; i < UPAGES; i+=2) {
		tlb.tlb_mask = PG_SIZE_4K;
		tlb.tlb_hi = vad_to_vpn((UADDR + (i << PGSHIFT))) | 1;
		tlb.tlb_lo0 = vad_to_pfn(firstaddr) | PG_V | PG_M | PG_CACHED;
		tlb.tlb_lo1 = vad_to_pfn(firstaddr + NBPG) | PG_V | PG_M | PG_CACHED;
		curproc->p_md.md_upte[i] = tlb.tlb_lo0;
		curproc->p_md.md_upte[i+1] = tlb.tlb_lo1;
		R4K_TLBWriteIndexed(i,&tlb);
		firstaddr += NBPG * 2;
	}
	sysend += UPAGES * NBPG;
	sysend = (caddr_t)(((int)sysend + 3) & -4);
	R4K_SetPID(1);

	/*
	 * init nullproc for swtch_exit().
	 * init mapping for u page(s), pm_tlbpid 0
	 * This could be used for an idle process.
	 */
	nullproc.p_addr = (struct user *)sysend;
	nullproc.p_md.md_regs = nullproc.p_addr->u_pcb.pcb_regs;
	bcopy("nullproc", nullproc.p_comm, sizeof("nullproc"));
	firstaddr = CACHED_TO_PHYS(sysend);
	for (i = 0; i < UPAGES; i+=2) {
		nullproc.p_md.md_upte[i] = vad_to_pfn(firstaddr) | PG_V | PG_M | PG_CACHED;
		nullproc.p_md.md_upte[i+1] = vad_to_pfn(firstaddr + NBPG) | PG_V | PG_M | PG_CACHED;
		firstaddr += NBPG * 2;
	}
	sysend += UPAGES * NBPG;

	/* clear pages for u areas */
	bzero(start, sysend - start);

	/*
	 * Copy down exception vector code.
	 */
	if (MipsTLBMissEnd - MipsTLBMiss > 0x80)
		panic("startup: TLB code too large");
	bcopy(MipsTLBMiss, (char *)TLB_MISS_EXC_VEC,
		MipsTLBMissEnd - MipsTLBMiss);
	bcopy(MipsException, (char *)GEN_EXC_VEC,
		MipsExceptionEnd - MipsException);

	/*
	 * Clear out the I and D caches.
	 */
	R4K_FlushCache();

	i = *(volatile u_int32_t *)0x80000300;	/* Read and cache */
	R4K_FlushCache();			/* Flush */
	*(volatile u_int32_t *)0xa0000300 = ~i;	/* Write uncached */
	l2cache_is_snooping = (~i == *(volatile u_int32_t *)0x80000300);
	*(volatile u_int32_t *)0x80000300 = i;	/* Write uncached */
	R4K_FlushCache();			/* Flush */


	/*
	 * Initialize error message buffer.
	 */
	msgbufp = (struct msgbuf *)(sysend);
	sysend = (caddr_t)(sysend + (sizeof(struct msgbuf)));
	msgbufmapped = 1;

	/*
	 * Allocate space for system data structures.
	 * The first available kernel virtual address is in "sysend".
	 * As pages of kernel virtual memory are allocated, "sysend"
	 * is incremented.
	 *
	 * These data structures are allocated here instead of cpu_startup()
	 * because physical memory is directly addressable. We don't have
	 * to map these into virtual address space.
	 */
	start = sysend;

#define	valloc(name, type, num) \
	    (name) = (type *)sysend; sysend = (caddr_t)((name)+(num))
#define	valloclim(name, type, num, lim) \
	    (name) = (type *)sysend; sysend = (caddr_t)((lim) = ((name)+(num)))
#ifdef REAL_CLISTS
	valloc(cfree, struct cblock, nclist);
#endif
	valloc(timeouts, struct timeout, ntimeout);
#ifdef SYSVSHM
	valloc(shmsegs, struct shmid_ds, shminfo.shmmni);
#endif
#ifdef SYSVSEM
	valloc(sema, struct semid_ds, seminfo.semmni);
	valloc(sem, struct sem, seminfo.semmns);
	/* This is pretty disgusting! */
	valloc(semu, int, (seminfo.semmnu * seminfo.semusz) / sizeof(int));
#endif
#ifdef SYSVMSG
	valloc(msgpool, char, msginfo.msgmax);
	valloc(msgmaps, struct msgmap, msginfo.msgseg);
	valloc(msghdrs, struct msg, msginfo.msgtql);
	valloc(msqids, struct msqid_ds, msginfo.msgmni);
#endif

#ifndef BUFCACHEPERCENT
#define BUFCACHEPERCENT 5
#endif

	/*
	 * Determine how many buffers to allocate.
	 * We allocate more buffer space than the BSD standard of
	 * using 10% of memory for the first 2 Meg, 5% of remaining.
	 * We just allocate a flat 10%. Ensure a minimum of 16 buffers.
	 * We allocate 1/2 as many swap buffer headers as file i/o buffers.
	 */
	if (bufpages == 0) {
		if (physmem < btoc(2 * 1024 * 1024))
			bufpages = physmem / (10 * CLSIZE);
		else
			bufpages = (btoc(2 * 1024 * 1024) + physmem) *
			    BUFCACHEPERCENT / (100 * CLSIZE);
	}
	if (nbuf == 0) {
		nbuf = bufpages;
		if (nbuf < 16)
			nbuf = 16;
	}

	/* Restrict to at most 70% filled kvm */
	if (nbuf * MAXBSIZE >
	    (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) * 7 / 10)
		nbuf = (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) /
		    MAXBSIZE * 7 / 10;

	/* More buffer pages than fits into the buffers is senseless.  */
	if (bufpages > nbuf * MAXBSIZE / CLBYTES)
		bufpages = nbuf * MAXBSIZE / CLBYTES;

	if (nswbuf == 0) {
		nswbuf = (nbuf / 2) &~ 1;	/* force even */
		if (nswbuf > 256)
			nswbuf = 256;		/* sanity */
	}
	valloc(swbuf, struct buf, nswbuf);
	valloc(buf, struct buf, nbuf);

	/*
	 * Clear allocated memory.
	 */
	bzero(start, sysend - start);

	/*
	 * Initialize the virtual memory system.
	 */
	vm_set_page_size();	/* XXX Works when default page size is 4k */
	pmap_bootstrap((vm_offset_t)sysend);
}

void
tlb_init_pica()
{
	struct tlb tlb;

	tlb.tlb_mask = PG_SIZE_256K;
	tlb.tlb_hi = vad_to_vpn(R4030_V_LOCAL_IO_BASE);
	tlb.tlb_lo0 = vad_to_pfn(R4030_P_LOCAL_IO_BASE) | PG_IOPAGE;
	tlb.tlb_lo1 = vad_to_pfn(PICA_P_INT_SOURCE) | PG_IOPAGE;
	R4K_TLBWriteIndexed(1, &tlb);

	tlb.tlb_mask = PG_SIZE_1M;
	tlb.tlb_hi = vad_to_vpn(PICA_V_LOCAL_VIDEO_CTRL);
	tlb.tlb_lo0 = vad_to_pfn(PICA_P_LOCAL_VIDEO_CTRL) | PG_IOPAGE;
	tlb.tlb_lo1 = vad_to_pfn(PICA_P_LOCAL_VIDEO_CTRL + PICA_S_LOCAL_VIDEO_CTRL/2) | PG_IOPAGE;
	R4K_TLBWriteIndexed(2, &tlb);

	tlb.tlb_mask = PG_SIZE_1M;
	tlb.tlb_hi = vad_to_vpn(PICA_V_EXTND_VIDEO_CTRL);
	tlb.tlb_lo0 = vad_to_pfn(PICA_P_EXTND_VIDEO_CTRL) | PG_IOPAGE;
	tlb.tlb_lo1 = vad_to_pfn(PICA_P_EXTND_VIDEO_CTRL + PICA_S_EXTND_VIDEO_CTRL/2) | PG_IOPAGE;
	R4K_TLBWriteIndexed(3, &tlb);

	tlb.tlb_mask = PG_SIZE_4M;
	tlb.tlb_hi = vad_to_vpn(PICA_V_LOCAL_VIDEO);
	tlb.tlb_lo0 = vad_to_pfn(PICA_P_LOCAL_VIDEO) | PG_IOPAGE;
	tlb.tlb_lo1 = vad_to_pfn(PICA_P_LOCAL_VIDEO + PICA_S_LOCAL_VIDEO/2) | PG_IOPAGE;
	R4K_TLBWriteIndexed(4, &tlb);

	tlb.tlb_mask = PG_SIZE_16M;
	tlb.tlb_hi = vad_to_vpn(PICA_V_ISA_IO);
	tlb.tlb_lo0 = vad_to_pfn(PICA_P_ISA_IO) | PG_IOPAGE;
	tlb.tlb_lo1 = vad_to_pfn(PICA_P_ISA_MEM) | PG_IOPAGE;
	R4K_TLBWriteIndexed(5, &tlb);
}

void
tlb_init_tyne()
{
	struct tlb tlb;

	tlb.tlb_mask = PG_SIZE_256K;
	tlb.tlb_hi = vad_to_vpn(TYNE_V_BOUNCE);
	tlb.tlb_lo0 = vad_to_pfn64(TYNE_P_BOUNCE) | PG_IOPAGE;
	tlb.tlb_lo1 = PG_G;
	R4K_TLBWriteIndexed(1, &tlb);

	tlb.tlb_mask = PG_SIZE_1M;
	tlb.tlb_hi = vad_to_vpn(TYNE_V_ISA_IO);
	tlb.tlb_lo0 = vad_to_pfn64(TYNE_P_ISA_IO) | PG_IOPAGE;
	tlb.tlb_lo1 = PG_G;
	R4K_TLBWriteIndexed(2, &tlb);

	tlb.tlb_mask = PG_SIZE_1M;
	tlb.tlb_hi = vad_to_vpn(TYNE_V_ISA_MEM);
	tlb.tlb_lo0 = vad_to_pfn64(TYNE_P_ISA_MEM) | PG_IOPAGE;
	tlb.tlb_lo1 = PG_G;
	R4K_TLBWriteIndexed(3, &tlb);

	tlb.tlb_mask = PG_SIZE_4K;
	tlb.tlb_hi = vad_to_vpn(0xe3000000);
	tlb.tlb_lo0 = 0x03ffc000 | PG_IOPAGE;
	tlb.tlb_lo1 = PG_G;
	R4K_TLBWriteIndexed(4, &tlb);
}

/*
 * Simple routine to figure out SIMM module size.
 * This code is a real hack and can surely be improved on... :-)
 */
static int
get_simm_size(fadr, max)
	int *fadr;
	int max;
{
	int msave;
	int msize;
	int ssize;
	static int a1 = 0, a2 = 0;
	static int s1 = 0, s2 = 0;

	if(!max) {
		if(a1 == (int)fadr)
			return(s1);
		else if(a2 == (int)fadr)
			return(s2);
		else
			return(0);
	}
	fadr = (int *)PHYS_TO_UNCACHED(CACHED_TO_PHYS((int)fadr));

	msize = max - 0x400000;
	ssize = msize - 0x400000;

	/* Find bank size of last module */
	while(ssize >= 0) {
		msave = fadr[ssize / 4];
		fadr[ssize / 4] = 0xC0DEB00F;
		if(fadr[msize /4 ] == 0xC0DEB00F) {
			fadr[ssize / 4] = msave;
			if(fadr[msize/4] == msave) {
				break;	/* Wrap around */
			}
		}
		fadr[ssize / 4] = msave;
		ssize -= 0x400000;
	}
	msize = msize - ssize;
	if(msize == max)
		return(msize);	/* well it never wrapped... */

	msave = fadr[0];
	fadr[0] = 0xC0DEB00F;
	if(fadr[msize / 4] == 0xC0DEB00F) {
		fadr[0] = msave;
		if(fadr[msize / 4] == msave)
			return(msize);	/* First module wrap = size */
	}

	/* Ooops! Two not equal modules. Find size of first + second */
	s1 = s2 = msize;
	ssize = 0;
	while(ssize < max) {
		msave = fadr[ssize / 4];
		fadr[ssize / 4] = 0xC0DEB00F;
		if(fadr[msize /4 ] == 0xC0DEB00F) {
			fadr[ssize / 4] = msave;
			if(fadr[msize/4] == msave) {
				break;	/* Found end of module 1 */
			}
		}
		fadr[ssize / 4] = msave;
		ssize += s2;
		msize += s2;
	}

	/* Is second bank dual sided? */
	fadr[(ssize+ssize/2)/4] = ~fadr[ssize];
	if(fadr[(ssize+ssize/2)/4] != fadr[ssize]) {
		a2 = ssize+ssize/2;
	}
	a1 = ssize;

	return(ssize);
}

/*
 * Return a pointer to the given environment variable.
 */
static char *
getenv(envname)
	char *envname;
{
	char **env = environment;
	int i;

	i = strlen(envname);

	while(*env) {
		if(strncasecmp(envname, *env, i) == 0 && (*env)[i] == '=') {
			return(&(*env)[i+1]);
		}
		env++;
	}
	return(NULL);
}

/*
 * Console initialization: called early on from main,
 * before vm init or startup.  Do enough configuration
 * to choose and initialize a console.
 */
void
consinit()
{
	static int initted;

	if (initted)
		return;
	initted = 1;
	cninit();
}

/*
 * cpu_startup: allocate memory for variable-sized tables,
 * initialize cpu, and do autoconfiguration.
 */
void
cpu_startup()
{
	register unsigned i;
	int base, residual;
	vm_offset_t minaddr, maxaddr;
	vm_size_t size;
#ifdef DEBUG
	extern int pmapdebug;
	int opmapdebug = pmapdebug;

	pmapdebug = 0;		/* Shut up pmap debug during bootstrap */
#endif

	/*
	 * Good {morning,afternoon,evening,night}.
	 */
	printf(version);
	printf("real mem = %d\n", ctob(physmem));

	/*
	 * Allocate virtual address space for file I/O buffers.
	 * Note they are different than the array of headers, 'buf',
	 * and usually occupy more virtual memory than physical.
	 */
	size = MAXBSIZE * nbuf;
	buffer_map = kmem_suballoc(kernel_map, (vm_offset_t *)&buffers,
				   &maxaddr, size, TRUE);
	minaddr = (vm_offset_t)buffers;
	if (vm_map_find(buffer_map, vm_object_allocate(size), (vm_offset_t)0,
			&minaddr, size, FALSE) != KERN_SUCCESS)
		panic("startup: cannot allocate buffers");
	base = bufpages / nbuf;
	residual = bufpages % nbuf;
	if (base >= MAXBSIZE / CLBYTES) {
		/* don't want to alloc more physical mem than needed */
		base = MAXBSIZE / CLBYTES;
		residual = 0;
	}

	for (i = 0; i < nbuf; i++) {
		vm_size_t curbufsize;
		vm_offset_t curbuf;

		/*
		 * First <residual> buffers get (base+1) physical pages
		 * allocated for them.  The rest get (base) physical pages.
		 *
		 * The rest of each buffer occupies virtual space,
		 * but has no physical memory allocated for it.
		 */
		curbuf = (vm_offset_t)buffers + i * MAXBSIZE;
		curbufsize = CLBYTES * (i < residual ? base+1 : base);
		vm_map_pageable(buffer_map, curbuf, curbuf+curbufsize, FALSE);
		vm_map_simplify(buffer_map, curbuf);
	}
	/*
	 * Allocate a submap for exec arguments.  This map effectively
	 * limits the number of processes exec'ing at any time.
	 */
	exec_map = kmem_suballoc(kernel_map, &minaddr, &maxaddr,
				 16 * NCARGS, TRUE);
	/*
	 * Allocate a submap for physio
	 */
	phys_map = kmem_suballoc(kernel_map, &minaddr, &maxaddr,
				 VM_PHYS_SIZE, TRUE);

	/*
	 * Finally, allocate mbuf pool.  Since mclrefcnt is an off-size
	 * we use the more space efficient malloc in place of kmem_alloc.
	 */
	mclrefcnt = (char *)malloc(NMBCLUSTERS+CLBYTES/MCLBYTES,
				   M_MBUF, M_NOWAIT);
	bzero(mclrefcnt, NMBCLUSTERS+CLBYTES/MCLBYTES);
	mb_map = kmem_suballoc(kernel_map, (vm_offset_t *)&mbutl, &maxaddr,
			       VM_MBUF_SIZE, FALSE);
	/*
	 * Initialize timeouts
	 */
	timeout_init();

#ifdef DEBUG
	pmapdebug = opmapdebug;
#endif
	printf("avail mem = %d\n", ptoa(cnt.v_free_count));
	printf("using %d buffers containing %d bytes of memory\n",
		nbuf, bufpages * CLBYTES);
	/*
	 * Set up CPU-specific registers, cache, etc.
	 */
	initcpu();

	/*
	 * Set up buffers, so they can be used to read disk labels.
	 */
	bufinit();

	/*
	 * Configure the system.
	 */
	if (boothowto & RB_CONFIG) {
#ifdef BOOT_CONFIG
		user_config();
#else
		printf("kernel does not support -c; continuing..\n");
#endif
	}
	configure();

	spl0();		/* safe to turn interrupts on now */
}

/*
 * machine dependent system variables.
 */
int
cpu_sysctl(name, namelen, oldp, oldlenp, newp, newlen, p)
	int *name;
	u_int namelen;
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
	struct proc *p;
{
	dev_t consdev;

	/* all sysctl names at this level are terminal */
	if (namelen != 1)
		return (ENOTDIR);		/* overloaded */

	switch (name[0]) {
	case CPU_CONSDEV:
		if (cn_tab != NULL)
			consdev = cn_tab->cn_dev;
		else
			consdev = NODEV;
		return (sysctl_rdstruct(oldp, oldlenp, newp, &consdev,
		    sizeof consdev));
	default:
		return (EOPNOTSUPP);
	}
	/* NOTREACHED */
}

/*
 * Set registers on exec.
 * Clear all registers except sp, pc.
 */
void
setregs(p, pack, stack, retval)
	register struct proc *p;
	struct exec_package *pack;
	u_long stack;
	register_t *retval;
{
	extern struct proc *machFPCurProcPtr;

	bzero((caddr_t)p->p_md.md_regs, (FSR + 1) * sizeof(int));
	p->p_md.md_regs[SP] = stack;
	p->p_md.md_regs[PC] = pack->ep_entry & ~3;
	p->p_md.md_regs[T9] = pack->ep_entry & ~3; /* abicall req */
	p->p_md.md_regs[PS] = PSL_USERSET;
	p->p_md.md_flags &= ~MDP_FPUSED;
	if (machFPCurProcPtr == p)
		machFPCurProcPtr = (struct proc *)0;
	p->p_md.md_ss_addr = 0;
}

/*
 * WARNING: code in locore.s assumes the layout shown for sf_signum
 * thru sf_handler so... don't screw with them!
 */
struct sigframe {
	int	sf_signum;		/* signo for handler */
	siginfo_t *sf_sip;		/* pointer to siginfo_t */
	struct	sigcontext *sf_scp;	/* context ptr for handler */
	sig_t	sf_handler;		/* handler addr for u_sigc */
	struct	sigcontext sf_sc;	/* actual context */
	siginfo_t sf_si;
};

#ifdef DEBUG
int sigdebug = 0;
int sigpid = 0;
#define SDB_FOLLOW	0x01
#define SDB_KSTACK	0x02
#define SDB_FPSTATE	0x04
#endif

/*
 * Send an interrupt to process.
 */
void
sendsig(catcher, sig, mask, code, type, val)
	sig_t catcher;
	int sig, mask;
	u_long code;
	int type;
	union sigval val;
{
	register struct proc *p = curproc;
	register struct sigframe *fp;
	register int *regs;
	register struct sigacts *psp = p->p_sigacts;
	int oonstack, fsize;
	struct sigcontext ksc;
	extern char sigcode[], esigcode[];

	regs = p->p_md.md_regs;
	oonstack = psp->ps_sigstk.ss_flags & SA_ONSTACK;
	/*
	 * Allocate and validate space for the signal handler
	 * context. Note that if the stack is in data space, the
	 * call to grow() is a nop, and the copyout()
	 * will fail if the process has not already allocated
	 * the space with a `brk'.
	 */
	fsize = sizeof(struct sigframe);
	if (!(psp->ps_siginfo & sigmask(sig)))
		fsize -= sizeof(siginfo_t);
	if ((psp->ps_flags & SAS_ALTSTACK) &&
	    (psp->ps_sigstk.ss_flags & SA_ONSTACK) == 0 &&
	    (psp->ps_sigonstack & sigmask(sig))) {
		fp = (struct sigframe *)(psp->ps_sigstk.ss_sp +
					 psp->ps_sigstk.ss_size - fsize);
		psp->ps_sigstk.ss_flags |= SA_ONSTACK;
	} else
		fp = (struct sigframe *)(regs[SP] - fsize);
	if ((unsigned)fp <= USRSTACK - ctob(p->p_vmspace->vm_ssize)) 
		(void)grow(p, (unsigned)fp);
#ifdef DEBUG
	if ((sigdebug & SDB_FOLLOW) ||
	    ((sigdebug & SDB_KSTACK) && (p->p_pid == sigpid)))
		printf("sendsig(%d): sig %d ssp %x usp %x scp %x\n",
		       p->p_pid, sig, &oonstack, fp, &fp->sf_sc);
#endif
	/*
	 * Build the signal context to be used by sigreturn.
	 */
	ksc.sc_onstack = oonstack;
	ksc.sc_mask = mask;
	ksc.sc_pc = regs[PC];
	ksc.mullo = regs[MULLO];
	ksc.mulhi = regs[MULHI];
	ksc.sc_regs[ZERO] = 0xACEDBADE;		/* magic number */
	bcopy((caddr_t)&regs[1], (caddr_t)&ksc.sc_regs[1],
		sizeof(ksc.sc_regs) - sizeof(int));
	ksc.sc_fpused = p->p_md.md_flags & MDP_FPUSED;
	if (ksc.sc_fpused) {
		extern struct proc *machFPCurProcPtr;

		/* if FPU has current state, save it first */
		if (p == machFPCurProcPtr)
			MipsSaveCurFPState(p);
		bcopy((caddr_t)&p->p_md.md_regs[F0], (caddr_t)ksc.sc_fpregs,
			sizeof(ksc.sc_fpregs));
	}

	if (psp->ps_siginfo & sigmask(sig)) {
		siginfo_t si;

		initsiginfo(&si, sig, code, type, val);
		if (copyout((caddr_t)&si, (caddr_t)&fp->sf_si, sizeof si))
			goto bail;
	}

	if (copyout((caddr_t)&ksc, (caddr_t)&fp->sf_sc, sizeof(ksc))) {
bail:
		/*
		 * Process has trashed its stack; give it an illegal
		 * instruction to halt it in its tracks.
		 */
		SIGACTION(p, SIGILL) = SIG_DFL;
		sig = sigmask(SIGILL);
		p->p_sigignore &= ~sig;
		p->p_sigcatch &= ~sig;
		p->p_sigmask &= ~sig;
		psignal(p, SIGILL);
		return;
	}
	/* 
	 * Build the argument list for the signal handler.
	 */
	regs[A0] = sig;
	regs[A1] = (psp->ps_siginfo & sigmask(sig)) ? (int)&fp->sf_si : NULL;
	regs[A2] = (int)&fp->sf_sc;
	regs[A3] = (int)catcher;

	regs[PC] = (int)catcher;
	regs[T9] = (int)catcher;
	regs[SP] = (int)fp;
	/*
	 * Signal trampoline code is at base of user stack.
	 */
	regs[RA] = (int)PS_STRINGS - (esigcode - sigcode);
#ifdef DEBUG
	if ((sigdebug & SDB_FOLLOW) ||
	    ((sigdebug & SDB_KSTACK) && (p->p_pid == sigpid)))
		printf("sendsig(%d): sig %d returns\n",
		       p->p_pid, sig);
#endif
}

/*
 * System call to cleanup state after a signal
 * has been taken.  Reset signal mask and
 * stack state from context left by sendsig (above).
 * Return to previous pc and psl as specified by
 * context left by sendsig. Check carefully to
 * make sure that the user has not modified the
 * psl to gain improper priviledges or to cause
 * a machine fault.
 */
/* ARGSUSED */
int
sys_sigreturn(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_sigreturn_args /* {
		syscallarg(struct sigcontext *) sigcntxp;
	} */ *uap = v;
	register struct sigcontext *scp;
	register int *regs;
	struct sigcontext ksc;
	int error;

	scp = SCARG(uap, sigcntxp);
#ifdef DEBUG
	if (sigdebug & SDB_FOLLOW)
		printf("sigreturn: pid %d, scp %x\n", p->p_pid, scp);
#endif
	regs = p->p_md.md_regs;
	/*
	 * Test and fetch the context structure.
	 * We grab it all at once for speed.
	 */
	error = copyin((caddr_t)scp, (caddr_t)&ksc, sizeof(ksc));
	if (error || ksc.sc_regs[ZERO] != 0xACEDBADE) {
#ifdef DEBUG
		if (!(sigdebug & SDB_FOLLOW))
			printf("sigreturn: pid %d, scp %x\n", p->p_pid, scp);
		printf("  old sp %x ra %x pc %x\n",
			regs[SP], regs[RA], regs[PC]);
		printf("  new sp %x ra %x pc %x err %d z %x\n",
			ksc.sc_regs[SP], ksc.sc_regs[RA], ksc.sc_regs[PC],
			error, ksc.sc_regs[ZERO]);
#endif
		return (EINVAL);
	}
	scp = &ksc;
	/*
	 * Restore the user supplied information
	 */
	if (scp->sc_onstack & 01)
		p->p_sigacts->ps_sigstk.ss_flags |= SA_ONSTACK;
	else
		p->p_sigacts->ps_sigstk.ss_flags &= ~SA_ONSTACK;
	p->p_sigmask = scp->sc_mask &~ sigcantmask;
	regs[PC] = scp->sc_pc;
	regs[MULLO] = scp->mullo;
	regs[MULHI] = scp->mulhi;
	bcopy((caddr_t)&scp->sc_regs[1], (caddr_t)&regs[1],
		sizeof(scp->sc_regs) - sizeof(int));
	if (scp->sc_fpused)
		bcopy((caddr_t)scp->sc_fpregs, (caddr_t)&p->p_md.md_regs[F0],
			sizeof(scp->sc_fpregs));
	return (EJUSTRETURN);
}

int	waittime = -1;

void
boot(howto)
	register int howto;
{

	/* take a snap shot before clobbering any registers */
	if (curproc)
		savectx(curproc->p_addr, 0);

#ifdef DEBUG
	if (panicstr)
		stacktrace();
#endif

	boothowto = howto;
	if ((howto & RB_NOSYNC) == 0 && waittime < 0) {
		extern struct proc proc0;
		/* fill curproc with live object */
		if (curproc == NULL)
			curproc = &proc0;
		/*
		 * Synchronize the disks....
		 */
		waittime = 0;
		vfs_shutdown();

		/*
		 * If we've been adjusting the clock, the todr
		 * will be out of synch; adjust it now.
		 */
		resettodr();
	}
	(void) splhigh();		/* extreme priority */
	if (howto & RB_HALT) {
		printf("System halted.\n");
		while(1); /* Forever */
	}
	else {
		if (howto & RB_DUMP)
			dumpsys();
		printf("System restart.\n");
#if NPC > 0
		/* This is only done on systems with pccons driver */
		if(system_type != ALGOR_P4032) {
			(void)kbc_8042sysreset();       /* Try this first */
			delay(100000);                  /* Give it a chance */
		}
#endif
		__asm__(" li $2, 0xbfc00000; jr $2; nop\n");
		while(1); /* Forever */
	}
	/*NOTREACHED*/
}

int	dumpmag = (int)0x8fca0101;	/* magic number for savecore */
int	dumpsize = 0;		/* also for savecore */
long	dumplo = 0;

void
dumpconf()
{
	int nblks;

	dumpsize = physmem;
	if (dumpdev != NODEV && bdevsw[major(dumpdev)].d_psize) {
		nblks = (*bdevsw[major(dumpdev)].d_psize)(dumpdev);
		if (dumpsize > btoc(dbtob(nblks - dumplo)))
			dumpsize = btoc(dbtob(nblks - dumplo));
		else if (dumplo == 0)
			dumplo = nblks - btodb(ctob(physmem));
	}
	/*
	 * Don't dump on the first CLBYTES (why CLBYTES?)
	 * in case the dump device includes a disk label.
	 */
	if (dumplo < btodb(CLBYTES))
		dumplo = btodb(CLBYTES);
}

/*
 * Doadump comes here after turning off memory management and
 * getting on the dump stack, either when called above, or by
 * the auto-restart code.
 */
void
dumpsys()
{

	msgbufmapped = 0;
	if (dumpdev == NODEV)
		return;
	/*
	 * For dumps during autoconfiguration,
	 * if dump device has already configured...
	 */
	if (dumpsize == 0)
		dumpconf();
	if (dumplo < 0)
		return;
	printf("\ndumping to dev %x, offset %d\n", dumpdev, dumplo);
	printf("dump not yet implemented");
#if 0 /* XXX HAVE TO FIX XXX */
	switch (error = (*bdevsw[major(dumpdev)].d_dump)(dumpdev, dumplo,)) {

	case ENXIO:
		printf("device bad\n");
		break;

	case EFAULT:
		printf("device not ready\n");
		break;

	case EINVAL:
		printf("area improper\n");
		break;

	case EIO:
		printf("i/o error\n");
		break;

	default:
		printf("error %d\n", error);
		break;

	case 0:
		printf("succeeded\n");
	}
#endif
}

/*
 * Return the best possible estimate of the time in the timeval
 * to which tvp points.  Unfortunately, we can't read the hardware registers.
 * We guarantee that the time will be greater than the value obtained by a
 * previous call.
 */
void
microtime(tvp)
	register struct timeval *tvp;
{
	int s = splclock();
	static struct timeval lasttime;

	*tvp = time;
#ifdef notdef
	tvp->tv_usec += clkread();
	while (tvp->tv_usec >= 1000000) {
		tvp->tv_sec++;
		tvp->tv_usec -= 1000000;
	}
#endif
	if (tvp->tv_sec == lasttime.tv_sec &&
	    tvp->tv_usec <= lasttime.tv_usec &&
	    (tvp->tv_usec = lasttime.tv_usec + 1) >= 1000000) {
		tvp->tv_sec++;
		tvp->tv_usec -= 1000000;
	}
	lasttime = *tvp;
	splx(s);
}

void
initcpu()
{

	switch(system_type) {
	case ACER_PICA_61:
	case MAGNUM:
		/*
		 * Disable all interrupts. New masks will be set up
		 * during system configuration
		 */
		out16(PICA_SYS_LB_IE,0x000);
		out32(R4030_SYS_EXT_IMASK, 0x00);
		break;
	}
}
/*
 * Convert "xx:xx:xx:xx:xx:xx" string to ethernet hardware address.
 */
static void
get_eth_hw_addr(s)
	char *s;
{
	int i;
	if(s != NULL) {
		for(i = 0; i < 6; i++) {
			eth_hw_addr[i] = atoi(s, 16);
			s += 3;		/* Don't get to fancy here :-) */
		}
	}
}

/*
 * Convert an ASCII string into an integer.
 */
static int
atoi(s, b)
	char *s;
	int   b;
{
	int c;
	unsigned base = b, d;
	int neg = 0, val = 0;

	if (s == 0 || (c = *s++) == 0)
		goto out;

	/* skip spaces if any */
	while (c == ' ' || c == '\t')
		c = *s++;

	/* parse sign, allow more than one (compat) */
	while (c == '-') {
		neg = !neg;
		c = *s++;
	}

	/* parse base specification, if any */
	if (c == '0') {
		c = *s++;
		switch (c) {
		case 'X':
		case 'x':
			base = 16;
			c = *s++;
			break;
		case 'B':
		case 'b':
			base = 2;
			c = *s++;
			break;
		default:
			base = 8;
		}
	}

	/* parse number proper */
	for (;;) {
		if (c >= '0' && c <= '9')
			d = c - '0';
		else if (c >= 'a' && c <= 'z')
			d = c - 'a' + 10;
		else if (c >= 'A' && c <= 'Z')
			d = c - 'A' + 10;
		else
			break;
		val *= base;
		val += d;
		c = *s++;
	}
	if (neg)
		val = -val;
out:
	return val;	
}
@


1.39
log
@more precise BUFCACHEPERCENT calculations.
from gluk@@ptci.ru; deraadt@@ and niklas@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.38 2000/04/11 02:44:25 pjanzen Exp $	*/
d41 1
a41 1
 *      $Id: machdep.c,v 1.38 2000/04/11 02:44:25 pjanzen Exp $
@


1.38
log
@Check usec for >= 1000000, not just > ; as msaitoh@@NetBSD.org
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.37 2000/03/23 09:59:53 art Exp $	*/
d41 1
a41 1
 *      $Id: machdep.c,v 1.37 2000/03/23 09:59:53 art Exp $
d517 2
a518 2
			bufpages = (btoc(2 * 1024 * 1024) + physmem) /
			    ((100/BUFCACHEPERCENT) * CLSIZE);
@


1.37
log
@New API for timeouts. Replaces the old timeout()/untimeout() API and
makes it the callers responsibility to allocate resources for the
timeouts.

This is a KISS implementation and does _not_ solve the problems of slow
handling of a large number of pending timeouts (this will be solved in
future work) (although hardclock is now guarateed to take constant time
for handling of timeouts).

Old timeout() and untimeout() are implemented as wrappers around the new
API and kept for compatibility. They will be removed as soon as all
subsystems are converted to use the new API.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.36 1999/05/22 21:22:19 weingart Exp $	*/
d41 1
a41 1
 *      $Id: machdep.c,v 1.36 1999/05/22 21:22:19 weingart Exp $
d1264 1
a1264 1
	while (tvp->tv_usec > 1000000) {
d1271 1
a1271 1
	    (tvp->tv_usec = lasttime.tv_usec + 1) > 1000000) {
@


1.36
log
@Add new vm_swap code for dynamic swap.  From netbsd, munged some by me, and
others.   syscall commit pending.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.35 1999/01/30 22:39:31 imp Exp $	*/
d41 1
a41 1
 *      $Id: machdep.c,v 1.35 1999/01/30 22:39:31 imp Exp $
d57 1
a57 1
#include <sys/callout.h>
d485 1
a485 1
	valloc(callout, struct callout, ncallout);
d821 1
a821 1
	 * Initialize callouts
d823 1
a823 4
	callfree = callout;
	for (i = 1; i < ncallout; i++)
		callout[i-1].c_next = &callout[i];
	callout[i-1].c_next = NULL;
@


1.36.4.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d41 1
a41 1
 *      $Id$
d57 1
a57 1
#include <sys/timeout.h>
d485 1
a485 1
	valloc(timeouts, struct timeout, ntimeout);
d821 1
a821 1
	 * Initialize timeouts
d823 4
a826 1
	timeout_init();
@


1.36.4.2
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.36.4.1 2000/03/24 09:07:02 niklas Exp $	*/
d41 1
a41 1
 *      $Id: machdep.c,v 1.36.4.1 2000/03/24 09:07:02 niklas Exp $
@


1.35
log
@

Remove various kludges I did to get rpc44 working.

o Use #define for addresses on Deskstation rPC44
o Attempt to support X on rpc44, it appears to kinda work, but hangs
  sometimes.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.34 1998/10/15 21:29:59 imp Exp $	*/
d41 1
a41 1
 *      $Id: machdep.c,v 1.34 1998/10/15 21:29:59 imp Exp $
a485 1
	valloc(swapmap, struct map, nswapmap = maxproc * 2);
@


1.34
log
@
Back out PEFO's trap change.  It breaks everybody, it seems.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.32 1998/03/25 11:48:14 pefo Exp $	*/
d41 1
a41 1
 *      $Id: machdep.c,v 1.32 1998/03/25 11:48:14 pefo Exp $
d229 2
a230 2
		arc_bus_io.bus_base = 0xb0000000;		/*XXX*/
		arc_bus_mem.bus_base = 0xa0000000;		/*XXX*/
d573 1
a573 1
	
d579 1
a579 1
	
d585 1
a585 1
	
a620 1

@


1.33
log
@Real trapframe and no more __FORK_BRAINDAMAGE
@
text
@d85 1
a85 1
#include <machine/frame.h>
a90 1
#include <machine/regnum.h>
d161 1
d255 17
a271 20

		cp = getenv("boardtype");
		if(cp && strncasecmp("P-4032", cp, 6) == 0) {
			system_type = ALGOR_P4032;
			strcpy(cpu_model, "Algorithmics P-4032");
			arc_bus_io.bus_sparse1 = 2;
			arc_bus_io.bus_sparse2 = 1;
			arc_bus_io.bus_sparse4 = 0;
			arc_bus_io.bus_sparse8 = 0;
			CONADDR = P4032_COM1;
		}
		else { /* Default to P-5064 */
			system_type = ALGOR_P5064;
			strcpy(cpu_model, "Algorithmics P-5064");
			arc_bus_io.bus_sparse1 = 0;
			arc_bus_io.bus_sparse2 = 0;
			arc_bus_io.bus_sparse4 = 0;
			arc_bus_io.bus_sparse8 = 0;
			CONADDR = P5064_COM1;
		}
d279 2
d283 10
a292 1
			i = 1024 * 1024 * 16;  /* Reasonable default */
d294 1
a294 3
		mem_layout[1].mem_size = i - (int)(CACHED_TO_PHYS(sysend));
		physmem = i;

d401 1
a401 1
	curproc->p_md.md_regs = (struct trap_frame *)&proc0paddr->u_pcb.pcb_regs;
d423 1
a423 1
	nullproc.p_md.md_regs = (struct trap_frame *)&nullproc.p_addr->u_pcb.pcb_regs;
d625 80
d907 5
a911 5
	bzero((caddr_t)p->p_md.md_regs, sizeof(struct trap_frame));
	p->p_md.md_regs->sp = stack;
	p->p_md.md_regs->pc = pack->ep_entry & ~3;
	p->p_md.md_regs->t9 = pack->ep_entry & ~3; /* abicall req */
	p->p_md.md_regs->sr = PSL_USERSET;
d950 4
a953 4
	struct proc *p = curproc;
	struct sigframe *fp;
	struct trap_frame *regs;
	struct sigacts *psp = p->p_sigacts;
d977 1
a977 1
		fp = (struct sigframe *)(regs->sp - fsize);
d991 5
a995 5
	ksc.sc_pc = regs->pc;
	ksc.mullo = regs->mullo;
	ksc.mulhi = regs->mulhi;
	ksc.sc_regs[0] = 0xACEDBADE;		/* magic number */
	bcopy((caddr_t)&regs->ast, (caddr_t)&ksc.sc_regs[1],
d1004 1
a1004 1
		bcopy((caddr_t)&p->p_md.md_regs->f0, (caddr_t)ksc.sc_fpregs,
d1033 8
a1040 8
	regs->a0 = sig;
	regs->a1 = (psp->ps_siginfo & sigmask(sig)) ? (int)&fp->sf_si : NULL;
	regs->a2 = (int)&fp->sf_sc;
	regs->a3 = (int)catcher;

	regs->pc = (int)catcher;
	regs->t9 = (int)catcher;
	regs->sp = (int)fp;
d1044 1
a1044 1
	regs->ra = (int)PS_STRINGS - (esigcode - sigcode);
d1073 2
a1074 2
	struct sigcontext *scp;
	struct trap_frame *regs;
d1094 1
a1094 1
			regs->sp, regs->ra, regs->pc);
d1110 4
a1113 4
	regs->pc = scp->sc_pc;
	regs->mullo = scp->mullo;
	regs->mulhi = scp->mulhi;
	bcopy((caddr_t)&scp->sc_regs[1], (caddr_t)&regs->ast,
d1116 1
a1116 1
		bcopy((caddr_t)scp->sc_fpregs, (caddr_t)&p->p_md.md_regs->f0,
a1157 4
		if(system_type == ALGOR_P5064 && howto & RB_POWERDOWN) {
			printf("Shutting off!\n");
			*(int *)(0xbffa000c) = 1;
		}
@


1.32
log
@call vm_set_page_size
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.31 1998/03/16 09:38:30 pefo Exp $	*/
d41 1
a41 1
 *      $Id: machdep.c,v 1.31 1998/03/16 09:38:30 pefo Exp $
d85 1
a85 1
#include <machine/reg.h>
d91 1
a161 1
static int get_simm_size __P((int *, int));
d255 20
a274 17
#if 0
		system_type = ALGOR_P4032;
		strcpy(cpu_model, "Algorithmics P-4032");
		arc_bus_io.bus_sparse1 = 2;
		arc_bus_io.bus_sparse2 = 1;
		arc_bus_io.bus_sparse4 = 0;
		arc_bus_io.bus_sparse8 = 0;
		CONADDR = P4032_COM1;
#else
		system_type = ALGOR_P5064;
		strcpy(cpu_model, "Algorithmics P-5064");
		arc_bus_io.bus_sparse1 = 0;
		arc_bus_io.bus_sparse2 = 0;
		arc_bus_io.bus_sparse4 = 0;
		arc_bus_io.bus_sparse8 = 0;
		CONADDR = P5064_COM1;
#endif
a281 2
			mem_layout[1].mem_size = i - (int)(CACHED_TO_PHYS(sysend));
			physmem = i;
d284 1
a284 10
			i = get_simm_size((int *)0, 128*1024*1024);
			mem_layout[1].mem_size = i - (int)(CACHED_TO_PHYS(sysend));
			physmem = i;
/*XXX Ouch!!! */
			mem_layout[2].mem_start = i;
			mem_layout[2].mem_size = get_simm_size((int *)(i), 0);
			physmem += mem_layout[2].mem_size;
			mem_layout[3].mem_start = i+i/2;
			mem_layout[3].mem_size = get_simm_size((int *)(i+i/2), 0);
			physmem += mem_layout[3].mem_size;
d286 3
a288 1
/*XXX*/
d395 1
a395 1
	curproc->p_md.md_regs = proc0paddr->u_pcb.pcb_regs;
d417 1
a417 1
	nullproc.p_md.md_regs = nullproc.p_addr->u_pcb.pcb_regs;
a618 80
 * Simple routine to figure out SIMM module size.
 * This code is a real hack and can surely be improved on... :-)
 */
static int
get_simm_size(fadr, max)
	int *fadr;
	int max;
{
	int msave;
	int msize;
	int ssize;
	static int a1 = 0, a2 = 0;
	static int s1 = 0, s2 = 0;

	if(!max) {
		if(a1 == (int)fadr)
			return(s1);
		else if(a2 == (int)fadr)
			return(s2);
		else
			return(0);
	}
	fadr = (int *)PHYS_TO_UNCACHED(CACHED_TO_PHYS((int)fadr));

	msize = max - 0x400000;
	ssize = msize - 0x400000;

	/* Find bank size of last module */
	while(ssize >= 0) {
		msave = fadr[ssize / 4];
		fadr[ssize / 4] = 0xC0DEB00F;
		if(fadr[msize /4 ] == 0xC0DEB00F) {
			fadr[ssize / 4] = msave;
			if(fadr[msize/4] == msave) {
				break;	/* Wrap around */
			}
		}
		fadr[ssize / 4] = msave;
		ssize -= 0x400000;
	}
	msize = msize - ssize;
	if(msize == max)
		return(msize);	/* well it never wrapped... */

	msave = fadr[0];
	fadr[0] = 0xC0DEB00F;
	if(fadr[msize / 4] == 0xC0DEB00F) {
		fadr[0] = msave;
		if(fadr[msize / 4] == msave)
			return(msize);	/* First module wrap = size */
	}

	/* Ooops! Two not equal modules. Find size of first + second */
	s1 = s2 = msize;
	ssize = 0;
	while(ssize < max) {
		msave = fadr[ssize / 4];
		fadr[ssize / 4] = 0xC0DEB00F;
		if(fadr[msize /4 ] == 0xC0DEB00F) {
			fadr[ssize / 4] = msave;
			if(fadr[msize/4] == msave) {
				break;	/* Found end of module 1 */
			}
		}
		fadr[ssize / 4] = msave;
		ssize += s2;
		msize += s2;
	}

	/* Is second bank dual sided? */
	fadr[(ssize+ssize/2)/4] = ~fadr[ssize];
	if(fadr[(ssize+ssize/2)/4] != fadr[ssize]) {
		a2 = ssize+ssize/2;
	}
	a1 = ssize;

	return(ssize);
}

/*
d821 5
a825 5
	bzero((caddr_t)p->p_md.md_regs, (FSR + 1) * sizeof(int));
	p->p_md.md_regs[SP] = stack;
	p->p_md.md_regs[PC] = pack->ep_entry & ~3;
	p->p_md.md_regs[T9] = pack->ep_entry & ~3; /* abicall req */
	p->p_md.md_regs[PS] = PSL_USERSET;
d864 4
a867 4
	register struct proc *p = curproc;
	register struct sigframe *fp;
	register int *regs;
	register struct sigacts *psp = p->p_sigacts;
d891 1
a891 1
		fp = (struct sigframe *)(regs[SP] - fsize);
d905 5
a909 5
	ksc.sc_pc = regs[PC];
	ksc.mullo = regs[MULLO];
	ksc.mulhi = regs[MULHI];
	ksc.sc_regs[ZERO] = 0xACEDBADE;		/* magic number */
	bcopy((caddr_t)&regs[1], (caddr_t)&ksc.sc_regs[1],
d918 1
a918 1
		bcopy((caddr_t)&p->p_md.md_regs[F0], (caddr_t)ksc.sc_fpregs,
d947 8
a954 8
	regs[A0] = sig;
	regs[A1] = (psp->ps_siginfo & sigmask(sig)) ? (int)&fp->sf_si : NULL;
	regs[A2] = (int)&fp->sf_sc;
	regs[A3] = (int)catcher;

	regs[PC] = (int)catcher;
	regs[T9] = (int)catcher;
	regs[SP] = (int)fp;
d958 1
a958 1
	regs[RA] = (int)PS_STRINGS - (esigcode - sigcode);
d987 2
a988 2
	register struct sigcontext *scp;
	register int *regs;
d1008 1
a1008 1
			regs[SP], regs[RA], regs[PC]);
d1024 4
a1027 4
	regs[PC] = scp->sc_pc;
	regs[MULLO] = scp->mullo;
	regs[MULHI] = scp->mulhi;
	bcopy((caddr_t)&scp->sc_regs[1], (caddr_t)&regs[1],
d1030 1
a1030 1
		bcopy((caddr_t)scp->sc_fpregs, (caddr_t)&p->p_md.md_regs[F0],
d1072 4
@


1.31
log
@DDB.

Support for Algorithmics R5000/R10000 evaluation board. So far only the
RM5260 is supported. RM5270 - RM7000 later. R5000 and R10000 depending
on access to cpu modules.

vm_machdep.c moved to arch/mips/mips.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.30 1998/01/28 13:45:55 pefo Exp $	*/
d41 1
a41 1
 *      $Id: machdep.c,v 1.30 1998/01/28 13:45:55 pefo Exp $
d553 1
@


1.30
log
@Moving around files for new mips arch layout
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.29 1997/05/19 16:21:20 pefo Exp $	*/
d41 1
a41 1
 *      $Id: machdep.c,v 1.29 1997/05/19 16:21:20 pefo Exp $
d103 1
a103 1
extern char kernel_start[];
a224 11

		/*
		 * Set up interrupt handling and I/O addresses.
		 */
#if 0 /* XXX FIXME */
		Mips_splnet = Mips_spl1;
		Mips_splbio = Mips_spl0;
		Mips_splimp = Mips_spl1;
		Mips_spltty = Mips_spl2;
		Mips_splstatclock = Mips_spl3;
#endif
d255 1
d263 9
d274 1
a274 1
		mem_layout[0].mem_size = mips_trunc_page(CACHED_TO_PHYS(kernel_start));
d321 1
d325 1
d346 4
d387 1
d1289 1
@


1.29
log
@Hmm, to fast after issuing reset.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.28 1997/05/19 16:01:09 pefo Exp $	*/
d41 1
a41 1
 *      $Id: machdep.c,v 1.28 1997/05/19 16:01:09 pefo Exp $
d96 2
a97 2
#include <arc/arc/arctype.h>
#include <arc/arc/arcbios.h>
d134 1
a134 1
int	cputype;		/* Mother board type */
d145 8
a152 8
extern	int Mach_spl0 __P((void)), Mach_spl1 __P((void)), Mach_spl2 __P((void));
extern	int Mach_spl3 __P((void)), Mach_spl4 __P((void)), Mach_spl5 __P((void));
int	(*Mach_splnet)(void) = splhigh;
int	(*Mach_splbio)(void) = splhigh;
int	(*Mach_splimp)(void) = splhigh;
int	(*Mach_spltty)(void) = splhigh;
int	(*Mach_splclock)(void) = splhigh;
int	(*Mach_splstatclock)(void) = splhigh;
d195 2
a196 2
	extern char MachTLBMiss[], MachTLBMissEnd[];
	extern char MachException[], MachExceptionEnd[];
d213 1
a213 1
	switch (cputype) {
d216 1
a216 1
		if(cputype == MAGNUM) {
d230 5
a234 5
		Mach_splnet = Mach_spl1;
		Mach_splbio = Mach_spl0;
		Mach_splimp = Mach_spl1;
		Mach_spltty = Mach_spl2;
		Mach_splstatclock = Mach_spl3;
d252 9
d266 1
a266 1
		cputype = ALGOR_P4032;
d368 1
a368 1
	switch (cputype) {
d383 4
d433 1
a433 1
	if (MachTLBMissEnd - MachTLBMiss > 0x80)
d435 4
a438 4
	bcopy(MachTLBMiss, (char *)TLB_MISS_EXC_VEC,
		MachTLBMissEnd - MachTLBMiss);
	bcopy(MachException, (char *)GEN_EXC_VEC,
		MachExceptionEnd - MachException);
d996 1
a996 1
			MachSaveCurFPState(p);
d1157 7
a1163 3
		delay(2000000);
		(void)kbc_8042sysreset();	/* Try this first */
		delay(100000);			/* Give it a chance */
d1281 1
a1281 1
	switch(cputype) {
@


1.28
log
@Make PICA's really reboot on rebbot command
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.27 1997/05/18 13:45:21 pefo Exp $	*/
d41 1
a41 1
 *      $Id: machdep.c,v 1.27 1997/05/18 13:45:21 pefo Exp $
d1146 1
@


1.27
log
@RAMDISK additions
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.26 1997/05/01 15:15:29 pefo Exp $	*/
d41 1
a41 1
 *      $Id: machdep.c,v 1.26 1997/05/01 15:15:29 pefo Exp $
d108 1
d1145 1
@


1.26
log
@No serial console on pica/magnums yet
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.25 1997/04/19 17:19:44 pefo Exp $	*/
d41 1
a41 1
 *      $Id: machdep.c,v 1.25 1997/04/19 17:19:44 pefo Exp $
d304 2
a305 1
	 * Default to SINGLE and ASKNAME if no args.
d307 3
d311 1
a327 4
			case 'm': /* mini root present in memory */
				boothowto |= RB_MINIROOT;
				break;

a338 12

#ifdef MFS
	/*
	 * Check to see if a mini-root was loaded into memory. It resides
	 * at the start of the next page just after the end of BSS.
	 */
	if (boothowto & RB_MINIROOT) {
		boothowto |= RB_DFLTROOT;
		bios_load_miniroot(NULL, sysend);
		sysend += mfs_initminiroot(sysend);
	}
#endif
@


1.25
log
@-Wall cleanup.
Change to new MI assym.h file generation. (genassym.cf)
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.24 1997/04/10 16:29:08 pefo Exp $	*/
d41 1
a41 1
 *      $Id: machdep.c,v 1.24 1997/04/10 16:29:08 pefo Exp $
d223 1
a223 1
		CONADDR = PICA_SYS_COM1;
d346 1
@


1.24
log
@Attempt to clean up local devices.
Added support for new QED RT52x0 processors.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.23 1997/03/23 11:34:30 pefo Exp $	*/
d41 1
a41 1
 *      $Id: machdep.c,v 1.23 1997/03/23 11:34:30 pefo Exp $
d77 3
d83 1
a87 1
#include <machine/pte.h>
d104 4
d132 1
d144 20
a163 15
extern	int Mach_spl0(), Mach_spl1(), Mach_spl2(), Mach_spl3();
extern	int Mach_spl4(), Mach_spl5(), splhigh();
int	(*Mach_splnet)() = splhigh;
int	(*Mach_splbio)() = splhigh;
int	(*Mach_splimp)() = splhigh;
int	(*Mach_spltty)() = splhigh;
int	(*Mach_splclock)() = splhigh;
int	(*Mach_splstatclock)() = splhigh;

static void tlb_init_pica();
static void tlb_init_tyne();
static int get_simm_size(int *fadr, int max);
static char *getenv(char *env);
static void get_eth_hw_addr(char *);
static int atoi(char *s, int b);
d181 1
d388 1
a388 1
	sysend = (caddr_t)((int)sysend + 3 & -4);
d404 1
a404 1
	sysend = (caddr_t)((int)sysend+3 & -4);
d441 8
a737 1
	register caddr_t v;
d853 1
d901 1
a901 1
	p->p_md.md_flags & ~MDP_FPUSED;
d971 1
a971 1
	    (sigdebug & SDB_KSTACK) && p->p_pid == sigpid)
d1036 1
a1036 1
	    (sigdebug & SDB_KSTACK) && p->p_pid == sigpid)
d1053 1
d1164 1
d1190 1
a1192 1
	int error;
d1206 3
a1208 2
	printf("dump ");
	switch (error = (*bdevsw[major(dumpdev)].d_dump)(dumpdev)) {
d1233 1
d1267 1
@


1.23
log
@Adding more arches require more structuring and cleanup. More to come...
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.22 1997/03/17 08:11:12 pefo Exp $	*/
d41 1
a41 1
 *      $Id: machdep.c,v 1.22 1997/03/17 08:11:12 pefo Exp $
d129 2
a130 1
struct arc_bus_space arc_bus;	/* Bus tag for bus.h macros */
a197 5
	arc_bus.isa_io_sparse1 = 0;
	arc_bus.isa_io_sparse2 = 0;
	arc_bus.isa_io_sparse4 = 0;
	arc_bus.isa_io_sparse8 = 0;

d207 2
a208 2
		arc_bus.isa_io_base = PICA_V_ISA_IO;
		arc_bus.isa_mem_base = PICA_V_ISA_MEM;
d225 2
a226 2
		arc_bus.isa_io_base = 0xb0000000;		/*XXX*/
		arc_bus.isa_mem_base = 0xa0000000;		/*XXX*/
d232 2
a233 2
		arc_bus.isa_io_base = TYNE_V_ISA_IO;
		arc_bus.isa_mem_base = TYNE_V_ISA_MEM;
d241 1
d244 4
a247 6
		arc_bus.isa_io_base = 0;
		arc_bus.isa_io_sparse1 = 2;
		arc_bus.isa_io_sparse2 = 1;
		arc_bus.isa_io_sparse4 = 0;
		arc_bus.isa_io_sparse8 = 0;
		arc_bus.isa_mem_base = 0;
a248 1
		num_tlbentries = 32;
d253 10
a262 3
		i = get_simm_size((int *)0, 128*1024*1024);
		mem_layout[1].mem_size = i - (int)(CACHED_TO_PHYS(sysend));
		physmem = i;
d264 7
a270 6
		mem_layout[2].mem_start = i;
		mem_layout[2].mem_size = get_simm_size((int *)(i), 0);
		physmem += mem_layout[2].mem_size;
		mem_layout[3].mem_start = i+i/2;
		mem_layout[3].mem_size = get_simm_size((int *)(i+i/2), 0);
		physmem += mem_layout[3].mem_size;
a271 1
		environment = envv;
d273 2
d340 10
a424 1
	cpucfg = R4K_ConfigCache();
@


1.22
log
@Serial console trouble again...
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.21 1997/03/12 19:16:43 pefo Exp $	*/
d41 1
a41 1
 *      $Id: machdep.c,v 1.21 1997/03/12 19:16:43 pefo Exp $
a98 8
#if 0
#include <asc.h>

#if NASC > 0
#include <arc/dev/ascreg.h>
#endif
#endif

d129 3
a131 1
struct arc_bus_space arc_bus;
d147 3
d167 1
a167 1
mips_init(argc, argv, code)
d170 1
a170 1
	u_int code;
d172 4
a175 4
	register char *cp;
	register int i;
	register unsigned firstaddr;
	register caddr_t sysend;
d186 2
d201 1
d262 11
a272 5
#if 0
		mem_layout[2].mem_start = 0x800000;
		mem_layout[2].mem_size = 0x1000000;
		physmem += 8192 * 1024;
#endif
d276 1
a276 1
	default:
d293 25
a317 25
	if (argc > 1) {
		for (i = 1; i < argc; i++) {
			if(strncasecmp("osloadoptions=",argv[i],14) == 0) {
				for (cp = argv[i]+14; *cp; cp++) {
					switch (*cp) {
					case 'a': /* autoboot */
						boothowto &= ~RB_SINGLE;
						break;

					case 'd': /* use compiled in default root */
						boothowto |= RB_DFLTROOT;
						break;

					case 'm': /* mini root present in memory */
						boothowto |= RB_MINIROOT;
						break;

					case 'n': /* ask for names */
						boothowto |= RB_ASKNAME;
						break;

					case 'N': /* don't ask for names */
						boothowto &= ~RB_ASKNAME;
						break;
					}
a318 2
				}
			}
d581 1
d590 12
a601 1

d604 2
a605 1
	msize = 1024*1024;
d607 6
a612 5
	while(max >= msize) {
		msave = fadr[0];
		fadr[0] = 0xC0DEB00F;
		if(fadr[msize/4] == 0xC0DEB00F) {
			fadr[0] = msave;
d617 10
d628 2
a629 1
		msize += msize;
d631 16
a646 2
	if(msize <= max) {
		return(msize);
d648 28
a675 2
	else {
		return(-1);
d677 1
d1243 15
d1262 2
a1263 2
int
atoi(s)
d1265 1
d1268 1
a1268 1
	unsigned base = 10, d;
@


1.21
log
@Addition of support for a PCI based Vr4300 board from Algorithmics, the P-4032.
Changes to io macros were done to handle sparse bus addressing dynamically.
This is a first cut (rough).
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.20 1997/02/03 15:05:08 deraadt Exp $	*/
d41 1
a41 1
 *      $Id: machdep.c,v 1.20 1997/02/03 15:05:08 deraadt Exp $
d99 1
d105 1
d152 1
d231 1
a231 1
		CONADDR = 0xa0000000+0x3f8;	/* Standard PC Com0 address */
d238 1
a238 1
		CONADDR = TYNE_V_ISA_MEM+0x3f8;	/* Standard PC Com0 address */
d259 3
a261 2
		mem_layout[1].mem_size = 0x800000 - (int)(CACHED_TO_PHYS(sysend));
		physmem = 8192 * 1024;
a500 2
consinit();
mdbpanic();
d573 35
@


1.20
log
@More siginfo implementations (alpha and mips might even work)
move "siginfo_t *" to 2nd arg of signal handler as 1003.1b requires.
I really wish I had 1003.1b documentation.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.19 1997/02/02 00:47:42 deraadt Exp $	*/
d41 1
a41 1
 *      $Id: machdep.c,v 1.19 1997/02/02 00:47:42 deraadt Exp $
d85 1
d97 1
d106 1
d132 1
d134 2
a135 2
int	isa_io_base;		/* Base address of ISA io port space */
int	isa_mem_base;		/* Base address of ISA memory space */
d195 4
d208 3
a210 2
		isa_io_base = PICA_V_ISA_IO;
		isa_mem_base = PICA_V_ISA_MEM;
d226 3
a228 2
		isa_io_base = 0xb0000000;		/*XXX*/
		isa_mem_base = 0xa0000000;		/*XXX*/
d233 31
a263 2
		isa_io_base = TYNE_V_ISA_IO;
		isa_mem_base = TYNE_V_ISA_MEM;
d330 1
a330 1
	R4K_TLBFlush();
d345 3
d497 2
@


1.19
log
@attempt at siginfo.. Per must look this over
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.18 1997/02/01 11:02:41 deraadt Exp $	*/
d41 1
a41 1
 *      $Id: machdep.c,v 1.18 1997/02/01 11:02:41 deraadt Exp $
d728 1
a728 1
	int	sf_code;		/* additional info for handler */
d732 1
d772 2
d811 9
d821 1
d838 1
a838 1
	regs[A1] = code;
@


1.18
log
@Implement BUFCACHEPERCENT. Allow bufpages/nbuf larger than 1 (still max out
at all buffers be MAXBSIZE).  Remove faulty limit test of buffer pages
allocation.  The check is now done at the bufpages+nbuf calculations.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.17 1997/01/28 03:54:52 deraadt Exp $	*/
d41 1
a41 1
 *      $Id: machdep.c,v 1.17 1997/01/28 03:54:52 deraadt Exp $
d746 1
a746 1
sendsig(catcher, sig, mask, code, addr)
d750 2
a751 1
	caddr_t addr;
@


1.17
log
@add addr arg to sendsig/trapsignal; no siginfo_t support yet
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.14 1996/09/19 22:30:07 pefo Exp $	*/
d41 1
a41 1
 *      $Id: machdep.c,v 1.16 1996/10/20 22:40:32 imp Exp $
d409 4
d420 7
a426 2
	if (bufpages == 0)
		bufpages = physmem / 10 / CLSIZE;
d432 11
d584 6
@


1.16
log
@Spaces -> tabs that were my fault
@
text
@d41 1
a41 1
 *      $Id: machdep.c,v 1.15 1996/09/24 19:37:24 pefo Exp $
d720 1
a720 1
sendsig(catcher, sig, mask, code)
d724 1
@


1.15
log
@Some problems with Pica systems and noncontigous memory config fixed.
@
text
@d41 1
a41 1
 *      $Id: machdep.c,v 1.14 1996/09/19 22:30:07 pefo Exp $
d305 1
a305 1
        break;
@


1.14
log
@reboot stuff + cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.13 1996/09/19 00:30:36 imp Exp $	*/
d41 1
a41 1
 *      $Id: machdep.c,v 1.13 1996/09/19 00:30:36 imp Exp $
d246 1
a246 1
			if(strncmp("OSLOADOPTIONS=",argv[i],14) == 0) {
@


1.13
log
@Deskstation rPC44 tweaks
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.12 1996/09/14 15:58:16 pefo Exp $	*/
d41 1
a41 1
 *      $Id: machdep.c,v 1.12 1996/09/14 15:58:16 pefo Exp $
a146 3
void vid_print_string(const char *str);
void vid_putchar(dev_t dev, char c);

a522 1
/* mdbpanic(); */
d918 1
a918 1
	if (howto & RB_HALT)
d920 2
d926 3
a929 1
	while(1); /* Forever */
a1112 74
}

/*
 * This code is temporary for debugging at startup
 */

static int vid_xpos=0, vid_ypos=0;

static void 
vid_wrchar(char c)
{
	volatile unsigned short *video;

	video = (unsigned short *)(0xe08b8000) + vid_ypos * 80 + vid_xpos;
	*video = (*video & 0xff00) | 0x0f00 | (unsigned short)c;
}

static void
vid_scroll()
{
	volatile unsigned short *video;
	int i;

	video = (unsigned short *)(0xe08b8000);
	for(i = 0; i < 80 * 24; i++) {
		*video = *(video + 80);
		video++;
	}
	for(i = 0; i < 80; i++) {
		*video = *video & 0xff00 | ' ';
		video++;
	}
}
void
vid_print_string(const char *str)
{
	unsigned char c;

	while(c = *str++) {
		vid_putchar((dev_t)0, c);
	}
}

void
vid_putchar(dev_t dev, char c)
{
	switch(c) {
	case '\n':
		vid_xpos = 0;
		if(vid_ypos == 24)
			vid_scroll();
		else
			vid_ypos++;
		DELAY(500000);
		break;

	case '\r':
		vid_xpos = 0;
		break;

	case '\t':
		do {
			vid_putchar(dev, ' ');
		} while(vid_xpos & 7);
		break;

	default:
		vid_wrchar(c);
		vid_xpos++;
		if(vid_xpos == 80) {
			vid_xpos = 0;
			vid_putchar(dev, '\n');
		}
	}
@


1.12
log
@First shot at a multivendor kernel. This version handles pica's and desk-
station tyne's. Auto detection still needs to be compleeted.
Checked in version is hardwired for pica's. Use the PICA config file.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.11 1996/09/06 04:57:52 imp Exp $	*/
d41 1
a41 1
 *      $Id: machdep.c,v 1.11 1996/09/06 04:57:52 imp Exp $
d220 2
a221 2
		isa_io_base = TYNE_V_ISA_IO;		/*XXX*/
		isa_mem_base = TYNE_V_ISA_MEM;		/*XXX*/
d306 3
d526 1
a526 1
mdbpanic();
@


1.11
log
@Implement bios_ident() which will identify each type of CPU that we
support.  First cut at more complete ARC BIOS support.  bios_ident() will
eventually be table driven as soon as I generate the tables.

Much information on the BIOS calls has come from the Linux/MIPS MILO
boot loader.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.10 1996/09/05 08:04:14 pefo Exp $	*/
d41 1
a41 1
 *      $Id: machdep.c,v 1.10 1996/09/05 08:04:14 pefo Exp $
a125 1
int	maxmem;			/* max memory per process */
a126 2
int	memcfg;			/* memory config register */
int	brdcfg;			/* motherboard config register */
d174 1
a174 1
	register caddr_t v;
d182 2
a183 2
	v = (caddr_t)mips_round_page(end);
	bzero(edata, v - edata);
d185 2
a186 2
    /* Initialize the CPU type */
    bios_ident();
a197 2
			/* XXX this is likely broken */
			memcfg = in32(R4030_SYS_CONFIG);
a200 2
			memcfg = in32(PICA_MEMORY_SIZE_REG);
			brdcfg = in32(PICA_CONFIG_REG);
a215 20

		/*
		 * Size is determined from the memory config register.
		 *  d0-d2 = bank 0 size (sim id)
		 *  d3-d5 = bank 1 size
		 *  d6 = bus width. (doubels memory size)
		 */
		if((memcfg & 7) <= 5)
			physmem = 2097152 << (memcfg & 7);
		if(((memcfg >> 3) & 7) <= 5)
			physmem += 2097152 << ((memcfg >> 3) & 7);

		if((memcfg & 0x40) == 0)
			physmem += physmem;	/* 128 bit config */

		mem_layout[0].mem_start = 0x00100000;
		mem_layout[0].mem_size = physmem - mem_layout[0].mem_start;
		mem_layout[1].mem_start = 0x00020000;
		mem_layout[1].mem_size =  0x00100000 - mem_layout[1].mem_start;
		mem_layout[2].mem_start = 0x0;
d220 2
a221 8

		/*XXX Need to find out how to size mem */
		physmem = 1024 * 1024 * 32;
		mem_layout[0].mem_start = 0x00100000;
		mem_layout[0].mem_size = physmem - mem_layout[0].mem_start;
		mem_layout[1].mem_start = 0x00008000;
		mem_layout[1].mem_size = 0x000a0000 - mem_layout[1].mem_start;
		mem_layout[2].mem_start = 0x0;
a227 8

		/*XXX Need to find out how to size mem */
		physmem = 1024 * 1024 * 16;
		mem_layout[0].mem_start = 0x00100000;
		mem_layout[0].mem_size = physmem - mem_layout[0].mem_start;
		mem_layout[1].mem_start = 0x00020000;
		mem_layout[1].mem_size =  0x00100000 - mem_layout[1].mem_start;
		mem_layout[2].mem_start = 0x0;
d231 1
a231 2
/*XXX printf doesn't work here .... use bios?? */
		printf("kernel not configured for systype 0x%x\n", i);
d285 1
a285 1
		v += mfs_initminiroot(v);
d311 3
a313 3
	v = (caddr_t)((int)v+3 & -4);
	start = v;
	curproc->p_addr = proc0paddr = (struct user *)v;
d315 1
a315 1
	firstaddr = CACHED_TO_PHYS(v);
d326 2
a327 2
	v += UPAGES * NBPG;
	v = (caddr_t)((int)v+3 & -4);
d335 1
a335 1
	nullproc.p_addr = (struct user *)v;
d338 1
a338 1
	firstaddr = CACHED_TO_PHYS(v);
d344 1
a344 1
	v += UPAGES * NBPG;
d347 1
a347 1
	bzero(start, v - start);
d366 1
a366 1
	 * Find out how much memory is available.
d368 2
a369 8
	/* Already know from above!!! */
	maxmem = physmem;

	/*
	 * Initialize error message buffer (at end of core).
	 */
	maxmem -= btoc(sizeof (struct msgbuf));
	msgbufp = (struct msgbuf *)(PHYS_TO_CACHED(maxmem << PGSHIFT));
d374 3
a376 2
	 * The first available kernel virtual address is in "v".
	 * As pages of kernel virtual memory are allocated, "v" is incremented.
d382 1
a382 1
	start = v;
d385 1
a385 1
	    (name) = (type *)v; v = (caddr_t)((name)+(num))
d387 1
a387 1
	    (name) = (type *)v; v = (caddr_t)((lim) = ((name)+(num)))
d434 1
a434 1
	bzero(start, v - start);
d439 1
a439 1
	pmap_bootstrap((vm_offset_t)v);
d483 1
a483 1
	tlb.tlb_mask = PG_SIZE_64K;
d500 7
d523 1
d1037 10
a1046 7
	/*
	 * Disable all interrupts. New masks will be set up
	 * during system configuration
	 */
	out16(PICA_SYS_LB_IE,0x000);
	out32(R4030_SYS_EXT_IMASK, 0x00);

@


1.10
log
@include dti
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.9 1996/09/04 21:18:19 pefo Exp $	*/
d41 1
a41 1
 *      $Id: machdep.c,v 1.9 1996/09/04 21:18:19 pefo Exp $
d93 1
d188 2
a189 3
	cputype = ACER_PICA_61; /* FIXME find systemtype */

	cputype = DESKSTATION_TYNE; /* FIXME find systemtype */
@


1.9
log
@Some changes for new arc boxes
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.8 1996/09/02 21:33:29 imp Exp $	*/
d41 1
a41 1
 *      $Id: machdep.c,v 1.8 1996/09/02 21:33:29 imp Exp $
d94 1
a94 1
#include <arc/desktech/desktech.h>
@


1.8
log
@Cleanup before the integration of the machine identification code:
	o Merge all the case statements into one.
	o Cleanup Tyne and rPC44 support
	o Removed the soon to be obsolete code to get the sysid (which
		then just ignored it)
Hopefully not break the working PICA port in the process....
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.7 1996/09/02 20:45:45 imp Exp $	*/
d41 1
a41 1
 *      $Id: machdep.c,v 1.7 1996/09/02 20:45:45 imp Exp $
d92 1
d94 1
a94 1
#include <arc/arc/arctype.h>
d146 3
d189 2
d198 12
a209 4
	case ACER_PICA_61:	/* ALI PICA 61 */
		memcfg = in32(PICA_MEMORY_SIZE_REG);
		brdcfg = in32(PICA_CONFIG_REG);
	picacommon:
d212 1
a212 1
		strcpy(cpu_model, "ACER PICA-61");
a244 8
	case MAGNUM:
		strcpy(cpu_model, "MIPS MAGNUM");

		/* XXX this is likely broken */
		memcfg = in32(R4030_SYS_CONFIG);
		goto picacommon;
		break;

d259 2
d263 1
a263 1
		physmem = 1024 * 1024 * 32;
d272 1
d278 1
a278 1
	/* look at argv[0] and compute bootdev */
d338 6
d345 4
a348 9
	/*
	 * Set up mapping for hardware the way we want it!
	 */

	tlb.tlb_mask = PG_SIZE_256K;
	tlb.tlb_hi = vad_to_vpn(R4030_V_LOCAL_IO_BASE);
	tlb.tlb_lo0 = vad_to_pfn(R4030_P_LOCAL_IO_BASE) | PG_IOPAGE;
	tlb.tlb_lo1 = vad_to_pfn(PICA_P_INT_SOURCE) | PG_IOPAGE;
	R4K_TLBWriteIndexed(1, &tlb);
a349 24
	tlb.tlb_mask = PG_SIZE_1M;
	tlb.tlb_hi = vad_to_vpn(PICA_V_LOCAL_VIDEO_CTRL);
	tlb.tlb_lo0 = vad_to_pfn(PICA_P_LOCAL_VIDEO_CTRL) | PG_IOPAGE;
	tlb.tlb_lo1 = vad_to_pfn(PICA_P_LOCAL_VIDEO_CTRL + PICA_S_LOCAL_VIDEO_CTRL/2) | PG_IOPAGE;
	R4K_TLBWriteIndexed(2, &tlb);
	
	tlb.tlb_mask = PG_SIZE_1M;
	tlb.tlb_hi = vad_to_vpn(PICA_V_EXTND_VIDEO_CTRL);
	tlb.tlb_lo0 = vad_to_pfn(PICA_P_EXTND_VIDEO_CTRL) | PG_IOPAGE;
	tlb.tlb_lo1 = vad_to_pfn(PICA_P_EXTND_VIDEO_CTRL + PICA_S_EXTND_VIDEO_CTRL/2) | PG_IOPAGE;
	R4K_TLBWriteIndexed(3, &tlb);
	
	tlb.tlb_mask = PG_SIZE_4M;
	tlb.tlb_hi = vad_to_vpn(PICA_V_LOCAL_VIDEO);
	tlb.tlb_lo0 = vad_to_pfn(PICA_P_LOCAL_VIDEO) | PG_IOPAGE;
	tlb.tlb_lo1 = vad_to_pfn(PICA_P_LOCAL_VIDEO + PICA_S_LOCAL_VIDEO/2) | PG_IOPAGE;
	R4K_TLBWriteIndexed(4, &tlb);
	
	tlb.tlb_mask = PG_SIZE_16M;
	tlb.tlb_hi = vad_to_vpn(PICA_V_ISA_IO);
	tlb.tlb_lo0 = vad_to_pfn(PICA_P_ISA_IO) | PG_IOPAGE;
	tlb.tlb_lo1 = vad_to_pfn(PICA_P_ISA_MEM) | PG_IOPAGE;
	R4K_TLBWriteIndexed(5, &tlb);
	
d487 60
@


1.7
log
@NetBSD -> OpenBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.6 1996/09/02 11:33:23 pefo Exp $	*/
d41 1
a41 1
 *      $Id: machdep.c,v 1.6 1996/09/02 11:33:23 pefo Exp $
a144 2
typedef void * (*FUNCPTR)();

a177 4
	struct sid {
		char vendor[8];
		u_char prodid[8];
	} *sys_id;
a182 6
	/* check what model platform we are running on */

	/* I just hate function pointer pointers.... */
	sys_id = (struct sid *)((*(FUNCPTR)((*(caddr_t **)0x80001020))[17])());


d195 1
d198 31
d232 5
d240 9
d252 9
d264 2
a265 2
		memcfg = -1;
		break;
d267 1
a420 33
	/* check what model platform we are running on */
	switch (cputype) {
	case ACER_PICA_61:	/* ALI PICA 61 */
		/*
		 * Set up interrupt handling and I/O addresses.
		 */
#if 0 /* XXX FIXME */
		Mach_splnet = Mach_spl1;
		Mach_splbio = Mach_spl0;
		Mach_splimp = Mach_spl1;
		Mach_spltty = Mach_spl2;
		Mach_splstatclock = Mach_spl3;
#endif
		strcpy(cpu_model, "ACER PICA_61");
		break;

	case MAGNUM:
		strcpy(cpu_model, "MIPS MAGNUM");
		break;

	case DESKSTATION_RPC44:
		strcpy(cpu_model, "DESKSTATION_RPC44");
		break;

	case DESKSTATION_TYNE:
		strcpy(cpu_model, "DESKSTATION_TYNE");
		break;

	default:
		printf("kernel not configured for systype 0x%x\n", i);
		boot(RB_HALT | RB_NOSYNC);
	}

d424 1
a424 68

	switch (cputype) {
	case ACER_PICA_61:
		/*
		 * Size is determined from the memory config register.
		 *  d0-d2 = bank 0 size (sim id)
		 *  d3-d5 = bank 1 size
		 *  d6 = bus width. (doubels memory size)
		 */
		if((memcfg & 7) <= 5)
			physmem = 2097152 << (memcfg & 7);
		if(((memcfg >> 3) & 7) <= 5)
			physmem += 2097152 << ((memcfg >> 3) & 7);

		if((memcfg & 0x40) == 0)
			physmem += physmem;	/* 128 bit config */

		mem_layout[0].mem_start = 0x00100000;
		mem_layout[0].mem_size = physmem - mem_layout[0].mem_start;
		mem_layout[1].mem_start = 0x00020000;
		mem_layout[1].mem_size =  0x00100000 - mem_layout[1].mem_start;
		mem_layout[2].mem_start = 0x0;
		
		physmem = btoc(physmem);
		break;

	case DESKSTATION_RPC44:
	case DESKSTATION_TYNE:
		/*XXX Need to find out how to size mem */
		physmem = 1024 * 1024 * 32;
		mem_layout[0].mem_start = 0x00100000;
		mem_layout[0].mem_size = physmem - mem_layout[0].mem_start;
		mem_layout[1].mem_start = 0x00008000;
		mem_layout[1].mem_size = 0x000a0000 - mem_layout[1].mem_start;
		mem_layout[2].mem_start = 0x0;

		physmem = btoc(physmem);
		break;

	case MAGNUM:
		memcfg = in32(R4030_SYS_CONFIG);

		physmem = btoc(physmem);
		break;

	default:
		physmem = btoc((u_int)v - KERNBASE);
		cp = (char *)PHYS_TO_UNCACHED(physmem << PGSHIFT);
		while (cp < (char *)MAX_MEM_ADDR) {
			if (badaddr(cp, 4))
				break;
			i = *(int *)cp;
			*(int *)cp = 0xa5a5a5a5;
			/*
			 * Data will persist on the bus if we read it right away
			 * Have to be tricky here.
			 */
			((int *)cp)[4] = 0x5a5a5a5a;
			wbflush();
			if (*(int *)cp != 0xa5a5a5a5)
				break;
			*(int *)cp = i;
			cp += NBPG;
			physmem++;
		}
		break;
	}

@


1.6
log
@ZAP GENERIC!
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.5 1996/08/26 11:11:54 pefo Exp $	*/
d41 1
a41 1
 *      $Id: machdep.c,v 1.5 1996/08/26 11:11:54 pefo Exp $
d185 1
a185 1
	/* clear the BSS segment in NetBSD code */
@


1.5
log
@Changes and bugfixes in memory handling system.
Sysmap too small.
Alloc map page failure.
Support for discontigous memory. Needs testing.
Name changes. "Mach" removal.
Kernel memory size increased.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.4 1996/07/30 20:24:17 pefo Exp $	*/
d41 1
a41 1
 *      $Id: machdep.c,v 1.4 1996/07/30 20:24:17 pefo Exp $
d211 4
a214 1
	case DESKSTATION:
d217 1
a217 1
	case MAGNUM:
d230 1
a231 1
#ifdef GENERIC
a232 3
#else
	boothowto = RB_SINGLE;
#endif
d393 6
a398 2
	case DESKSTATION:
		strcpy(cpu_model, "DESKSTATION");
d401 2
a402 2
	case MAGNUM:
		strcpy(cpu_model, "MIPS MAGNUM");
d439 2
a440 7
	case MAGNUM:
		memcfg = in32(R4030_SYS_CONFIG);

		physmem = btoc(physmem);
		break;

	case DESKSTATION:
d448 6
@


1.4
log
@Cleanup, endian and abi stuff fixies. Some stuff added for MIPS Magnum.
(PICA and Magnum uses very similar core chipsets).
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.3 1996/07/27 11:40:29 deraadt Exp $	*/
d41 1
a41 1
 *      $Id: machdep.c,v 1.3 1996/07/27 11:40:29 deraadt Exp $
d86 1
d134 2
d282 3
a284 3
	MachSetWIRED(0);
	MachTLBFlush();
	MachSetWIRED(VMWIRED_ENTRIES);
d294 1
a294 1
	MachTLBWriteIndexed(1, &tlb);
d300 1
a300 1
	MachTLBWriteIndexed(2, &tlb);
d306 1
a306 1
	MachTLBWriteIndexed(3, &tlb);
d312 1
a312 1
	MachTLBWriteIndexed(4, &tlb);
d318 1
a318 1
	MachTLBWriteIndexed(5, &tlb);
d335 1
a335 1
		MachTLBWriteIndexed(i,&tlb);
d340 1
a340 1
	MachSetPID(1);
d374 2
a375 2
	cpucfg = MachConfigCache();
	MachFlushCache();
d426 6
d437 2
d442 9
@


1.3
log
@handle RB_CONFIG
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.2 1996/07/16 07:46:12 pefo Exp $	*/
d41 1
a41 1
 *      $Id: machdep.c,v 1.2 1996/07/16 07:46:12 pefo Exp $
d142 2
d177 4
a181 1
vid_print_string("Starting\n");
d187 5
d207 7
d288 2
a289 2
	tlb.tlb_hi = vad_to_vpn(PICA_V_LOCAL_IO_BASE);
	tlb.tlb_lo0 = vad_to_pfn(PICA_P_LOCAL_IO_BASE) | PG_IOPAGE;
d387 9
a395 1
		strcpy(cpu_model, "PICA_61");
d408 1
a408 1
	case ACER_PICA_61:	/* ALI PICA 61 */
d426 7
d661 2
d1066 1
a1066 1
	out32(PICA_SYS_EXT_IMASK, 0x00);
a1067 1
	spl0();		/* safe to turn interrupts on now */
@


1.2
log
@Rename some 'pica' names to 'mips'.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.1.1.1 1996/06/24 09:07:21 pefo Exp $	*/
d41 1
a41 1
 *      $Id: machdep.c,v 1.1.1.1 1996/06/24 09:07:21 pefo Exp $
d621 7
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d41 1
a41 1
 *      $Id: machdep.c,v 1.9 1996/06/06 23:07:37 deraadt Exp $
d178 1
a178 1
	v = (caddr_t)pica_round_page(end);
@


1.1.1.1
log
@Next try. ARC tree import. "New" Mips (spim) ARC compliant systems tree.
This tree will eventually suport viritualy all ARC compliant Mips systems,
that is all we can lay our hands on for porting/testing. It will supersede
the pica tree which will be removed shortly when this tree is functioning.
@
text
@@

